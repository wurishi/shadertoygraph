{"ver":"0.1","info":{"id":"WsKXWD","date":"1574090904","viewed":243,"name":"FXAA RaymarchTest","username":"Fogrex","description":"Antialiased by FXAA","likes":3,"published":1,"flags":32,"usePreview":0,"tags":["antialiasing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Output to screen\n    fragColor = texture(iChannel0, uv);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define PI 3.14159265359\n#define PI2 6.28318530718\n\nconst int STEP = 128;\nconst float NEAR = 2.0;\nconst vec3 LIGHT_DIR = vec3(0.577,-0.577,0.577);\n\nstruct Ray\n{\n    vec3 direction;\n    vec3 origin;\n    vec4 color;\n    bool frag;\n};\n\n\n//transform function(inverse)\nvec3 transform(in vec3 pos, in vec3 move, in vec3 rot)\n{\n    vec4 p = vec4(pos.x, pos.y, pos.z, 1.0);\n    mat4 m = mat4(\n        1.0,    0.0,    0.0,    0.0,\n        0.0,    1.0,    0.0,    0.0,\n        0.0,    0.0,    1.0,    0.0,\n        -move.x,    -move.y,    -move.z,    1.0\n    );\n    mat4 rx = mat4(\n        1.0,    0.0,        0.0,            0.0,\n        0.0,    cos(-rot.x), sin(-rot.x),    0.0,\n        0.0,    -sin(-rot.x), cos(-rot.x),     0.0,\n        0.0,    0.0,        0.0,            1.0\n    );\n    mat4 ry = mat4(\n        cos(-rot.y),     0.0,    -sin(-rot.y), 0.0,\n        0.0,            1.0,    0.0,        0.0,\n        sin(-rot.y),    0.0,    cos(-rot.y), 0.0,\n        0.0,            0.0,    0.0,        1.0\n    );\n    mat4 rz = mat4(\n        cos(-rot.z), sin(-rot.z),    0.0,    0.0,\n        -sin(-rot.z), cos(-rot.z),     0.0,    0.0,\n        0.0,        0.0,            1.0,    0.0,\n        0.0,        0.0,            0.0,    1.0\n    );\n\n    return (ry * rx * rz * m * p).xyz;\n}\n\nvec3 translate(in vec3 pos, in vec3 move)\n{\n    vec4 p = vec4(pos.x, pos.y, pos.z, 1.0);\n    mat4 m = mat4(\n        1.0,    0.0,    0.0,    0.0,\n        0.0,    1.0,    0.0,    0.0,\n        0.0,    0.0,    1.0,    0.0,\n        -move.x,    -move.y,    -move.z,    1.0\n    );\n   \n    return (m * p).xyz;\n}\n\nvec3 rotate(in vec3 pos, in vec3 rot)\n{\n    vec4 p = vec4(pos.x, pos.y, pos.z, 1.0);\n    mat4 rx = mat4(\n        1.0,    0.0,        0.0,            0.0,\n        0.0,    cos(-rot.x), sin(-rot.x),    0.0,\n        0.0,    -sin(-rot.x), cos(-rot.x),     0.0,\n        0.0,    0.0,        0.0,            1.0\n    );\n    mat4 ry = mat4(\n        cos(-rot.y),     0.0,    -sin(-rot.y), 0.0,\n        0.0,            1.0,    0.0,        0.0,\n        sin(-rot.y),    0.0,    cos(-rot.y), 0.0,\n        0.0,            0.0,    0.0,        1.0\n    );\n    mat4 rz = mat4(\n        cos(-rot.z), sin(-rot.z),    0.0,    0.0,\n        -sin(-rot.z), cos(-rot.z),     0.0,    0.0,\n        0.0,        0.0,            1.0,    0.0,\n        0.0,        0.0,            0.0,    1.0\n    );\n\n    return (ry * rx * rz * p).xyz;\n}\n\n// distance functions\nfloat sphere(in vec3 p, in float r)\n{\n    return length(p) - r;\n}\n\nfloat box(in vec3 pos, in vec3 size)\n{\n    vec3 d = abs(pos) - size;\n    return length(max(d,0.0))+ min(max(d.x,max(d.y,d.z)),0.0);\n}\n\nfloat cylinder(in vec3 pos, in float r)\n{\n    return length(pos.xz) - r;\n}\n\nfloat plane(in vec3 pos, in float h)\n{\n    return pos.y - h;\n}\n\n// mixing shapes\nfloat nsUnion(in float d1, in float d2) {return min(d1, d2);}\n\nfloat nsSubtraction(in float d1, in float d2) {return max(-d1, d2);}\nfloat nsIntersection(in float d1, in float d2) {return max(d1, d2);}\nfloat sUnion(in float d1, in float d2, in float k){\n    float h = clamp(0.5 + 0.5*(d2-d1)/k, 0.0, 1.0);\n    return mix(d2, d1, h) - k*h*(1.0-h);\n}\nfloat sSubtraction(in float d1, in float d2, in float k){\n    float h = clamp(0.5 - 0.5*(d2+d1)/k, 0.0, 1.0);\n    return mix(d2, -d1, h) + k*h*(1.0-h);\n}\nfloat sIntersection(in float d1, in float d2, in float k){\n    float h = clamp(0.5 - 0.5*(d2-d1)/k, 0.0, 1.0);\n    return mix(d2, d1, h) + k*h*(1.0-h);\n}\n\n\n//mapping\nfloat map(in vec3 pos)\n{\n    \n    float s1 = sphere(pos, 1.2);\n    float b1 = box(pos, vec3(1.0,1.0,1.0));\n    float bss = nsSubtraction(s1,b1);\n    float r = 0.3;\n    float k = 2.0;\n    float d = 1.5;\n    vec3 rot = vec3(iTime*0.57, iTime*0.73, iTime*1.12)*0.3;\n    bss = sUnion(bss, sphere(translate(rotate(pos, rot),vec3(d,d,d)),r),k);\n    bss = sUnion(bss, sphere(translate(rotate(pos, rot),vec3(d,-d,-d)),r),k);\n    bss = sUnion(bss, sphere(translate(rotate(pos, rot),vec3(-d,d,-d)),r),k);\n    bss = sUnion(bss, sphere(translate(rotate(pos, rot),vec3(-d,-d,d)),r),k);\n    \n    bss = sUnion(bss, plane(pos, -5.0), k);\n    return bss;\n    \n}\n\n// calculating normal\nvec3 calcNorm(in vec3 pos)\n{\n    float d = 0.0001;\n    float center = map(pos);\n    vec3 grad = vec3(map(pos+vec3(d,0.0,0.0))-center, map(pos+vec3(0.0,d,0.0))-center, map(pos+vec3(0.0,0.0,d))-center);\n    return normalize(grad / d);\n}\n\n// lambert model\nvec4 lambert(in vec3 pos)\n{\n    vec3 n = calcNorm(pos);\n    float b = max(0.0, dot(n, -LIGHT_DIR))*0.9+0.1;\n    return vec4(b, b, b, 1.0);\n}\n\nvec4 visualizeNormal(in vec3 pos)\n{\n    return vec4(calcNorm(pos),1.0)*0.8 + vec4(1.0,1.0,1.0,1.0)*0.2;\n}\n\n// raymarching\nRay raymarch(in Ray r)\n{\n    vec3 pos = r.origin;\n    vec3 dir = r.direction;\n    \n    float d = 0.0;\n    \n    for(int i=0;i<STEP;i++)\n    {\n        d = map(pos);\n        if(d < 0.0001)\n        {\n            \n            r.origin = pos;\n            r.color = lambert(pos);\n            r.frag = false;\n            return r;\n        }\n        pos = pos + dir * d;\n    }\n    r.frag = true;\n    r.color = vec4(0.0,0.0,0.0,1.0);\n    return r;\n}\n\nRay castShadow(in Ray r)\n{\n    vec3 dir = -LIGHT_DIR;\n    vec3 pos = r.origin + dir * 0.01;;\n    \n    float d = 0.0;\n    \n    for(int i=0;i<STEP;i++)\n    {\n        d = map(pos);\n        if(d < 0.0001)\n        {\n            r.color = vec4(0.0,0.0,0.0,1.0);\n            return r;\n        }\n        pos = pos + dir * d;\n    }\n    return r;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 fc = (fragCoord*2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n    \n\tvec3 ray = normalize(vec3(fc, NEAR));\n    vec3 pos = vec3(fc, NEAR);\n    \n    \n    // camera moving\n    pos = translate(pos, vec3(0.0,0.0,6.0));\n    \n    //camera rotating\n    float rx = (iMouse.x/iResolution.x*2.0 - 1.0) * PI;\n    float ry = (iMouse.y/iResolution.y*2.0 - 1.0) * PI * 0.5;\n    pos = rotate(pos, vec3(ry,-rx,0.0));\n    ray = rotate(ray, vec3(ry,-rx,0.0));\n    \n    Ray r;\n    r.direction = ray;\n    r.origin = pos;\n    r.color = vec4(0.0,0.0,0.0,1.0);\n    r.frag = false;\n    \n    \n    r = raymarch(r);\n    if(!r.frag) r = castShadow(r);\n    fragColor = r.color;\n}\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"\n\n#define FXAA_SPAN_MAX\t8.0\n#define FXAA_REDUCE_MUL 1.0/8.0\n#define FXAA_REDUCE_MIN 1.0/128.0\n\nvec3 getPixel(in vec2 uv)\n{\n    return texture(iChannel0,uv).xyz;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) \n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\n\tif (abs(uv.x-0.5) < 0.003) \n\t{\n\t\t// centerline\n\t\tfragColor = vec4(0.1, 0.3, 0.1, 1.0);\n\t\treturn;\n\t}\n\tif (uv.x < 0.5) \n\t{\n\t\tfragColor = texture(iChannel0, uv);\n\t\treturn;\n\t}\n\tvec2 add = vec2(1.0) / iResolution.xy;\n\t\t\t\n\tvec3 rgbNW = getPixel(uv+vec2(-add.x, -add.y));\n\tvec3 rgbNE = getPixel(uv+vec2( add.x, -add.y));\n\tvec3 rgbSW = getPixel(uv+vec2(-add.x,  add.y));\n\tvec3 rgbSE = getPixel(uv+vec2( add.x,  add.y));\n\tvec3 rgbM  = getPixel(uv);\n\t\n\tvec3 luma\t = vec3(0.299, 0.587, 0.114);\n\tfloat lumaNW = dot(rgbNW, luma);\n\tfloat lumaNE = dot(rgbNE, luma);\n\tfloat lumaSW = dot(rgbSW, luma);\n\tfloat lumaSE = dot(rgbSE, luma);\n\tfloat lumaM  = dot(rgbM,  luma);\n\t\n\tfloat lumaMin = min(lumaM, min(min(lumaNW, lumaNE), min(lumaSW, lumaSE)));\n\tfloat lumaMax = max(lumaM, max(max(lumaNW, lumaNE), max(lumaSW, lumaSE)));\n\t\n\tvec2 dir;\n\tdir.x = -((lumaNW + lumaNE) - (lumaSW + lumaSE));\n\tdir.y =  ((lumaNW + lumaSW) - (lumaNE + lumaSE));\n\t\n\t\n\tfloat dirReduce = max(\n\t\t(lumaNW + lumaNE + lumaSW + lumaSE) * (0.25 * FXAA_REDUCE_MUL), FXAA_REDUCE_MIN);\n\t  \n\tfloat rcpDirMin = 1.0/(min(abs(dir.x), abs(dir.y)) + dirReduce);\n\t\n\n\tdir = min(vec2( FXAA_SPAN_MAX,  FXAA_SPAN_MAX),\n\t\t  max(vec2(-FXAA_SPAN_MAX, -FXAA_SPAN_MAX),\n\t\t  dir * rcpDirMin)) * add;\n\n\t\t\n\tvec3 rgbA = (1.0/2.0) * (getPixel(uv + dir * (1.0/3.0 - 0.5)) +\n\t\t\t\t\t\t\t getPixel(uv + dir * (2.0/2.0 - 0.5)));\n\t\n\tvec3 rgbB = rgbA * (1.0/2.0) + (1.0/4.0) *\n\t\t(getPixel(uv.xy + dir * (0.0/3.0 - 0.5)) +\n\t\t getPixel(uv.xy + dir * (3.0/3.0 - 0.5)));\n\t\n\tfloat lumaB = dot(rgbB, luma);\n\tif((lumaB < lumaMin) || (lumaB > lumaMax))\n\t{\n\t\tfragColor.xyz=rgbA;\n\t}else\n\t{\n\t\tfragColor.xyz=rgbB;\n\t}\n}","name":"Buffer B","description":"","type":"buffer"}]}