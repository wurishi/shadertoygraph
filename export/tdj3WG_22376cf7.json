{"ver":"0.1","info":{"id":"tdj3WG","date":"1549914754","viewed":159,"name":"cell2","username":"sshinderman","description":"yet another cell ... using second order distance to find edge.","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["cellnoise"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float rand1(vec2 n) {\n    return fract(abs(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453));\n}\n\nfloat rand2(vec2 n) {\n    return fract(abs(sin(dot(n, vec2(92.198, 103.114 + 1000.0))) * 147583.5453));\n}\n\nvec2 getRandomCenter( vec2 index )\n{\n    float c1 = rand1( index );\n    float c2 = rand2( index );\n\n    return vec2(c1, c2);\n}\n\nvec2 getRandomCenterWithMotion( vec2 index, float time )\n{\n    float c1 = rand1( index );\n    float c2 = rand2( index );\n\n    float theta = (c1 * c2 - .5) * time * 3.14159;\n   \tc1 += 0.25 * cos(theta);\n   \tc2 += 0.25 * sin(theta);\n        \n    return vec2(c1, c2);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord;  ///iResolution.xy;\n\n    // Time varying pixel color\n//     vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\tfloat scale = 1.0 / 20.0;\n    float t = iTime;\n    \n    vec2 tileCoord = fract(uv * scale);\n    vec2 tileIndex = vec2( floor( uv * scale ));\n    \n    float minDistance = 1e20;\n    float secondDistance = 1e20;\n    vec2 secondIndex = vec2(0,0);\n    vec2 minIndex = vec2(0,0);\n    vec2 minCenter = vec2(0,0);\n    vec2 secondCenter = vec2(0,0);\n\n    for (int j=-1;  j <= 1;  j++)\n    {\n        for (int i=-1;  i <= 1;  i++)\n        {\n            vec2 offset = vec2( i, j );\n            vec2 center = getRandomCenterWithMotion( tileIndex + offset, t ) + offset;\n            vec2 diff = tileCoord - center;\n\n            float distance = dot(diff,diff);\n            if (distance < minDistance)\n            {\n                secondDistance = minDistance;\n                secondIndex = minIndex;\n                secondCenter = minCenter;\n                \n                minDistance = distance;\n                minIndex = tileIndex + offset;\n                minCenter = center;\n            } \n            else if (distance < secondDistance)\n            {\n               secondDistance = distance;\n               secondIndex = tileIndex + offset;\n               secondCenter = center;\n            }            \n        }\n    }\n\n    \n    float d1 = sqrt(minDistance);\n    float d2 = sqrt(secondDistance);    \n    //float halfway = 0.5 * length(minCenter - secondCenter);\n    \n    vec2 dir = normalize(secondCenter - minCenter);\n    vec2 midpoint = 0.5 * ( minCenter + secondCenter );\n    float distToEdge = 1.0 - abs(dot(tileCoord - midpoint, dir));\n    \n    float c  = smoothstep( 0.95, 1.0, distToEdge);\n    // colorize the cell\n    float c2 = (1.0-c) * rand1( minIndex );\n\n    vec4 resultColor = vec4(c2,c2,c2, 1.0 );\n    \n    \n    // Output to screen\n    fragColor = resultColor;\n}\n","name":"Image","description":"","type":"image"}]}