{"ver":"0.1","info":{"id":"4cGyRm","date":"1732024733","viewed":111,"name":"Perlin-based Earth topography","username":"lchaumartin","description":"Sampling earth heightmap with perlin noise only","likes":4,"published":3,"flags":0,"usePreview":0,"tags":["noise"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Doesn't work on Mobile\n// Inspired by FFT 2D signal decomposition, replacing sinus with perlin noise because why not\n\n#define EARTH_RADIUS 1.0\n#define PI 3.14159\n#define TWO_PI 6.28319\n#define HALF_PI 1.5708\n\n#define OCTAVES 8\n\n#define SEA_LEVEL 0.5 // Remapping [-10984m...8849m] to [0...1], sea level would be 0.5536\n#define GRASS_START (SEA_LEVEL+0.025)\n#define STONE_START 0.7\n#define SNOW_START 0.95\n\nfloat offsets[OCTAVES];\nfloat persistences[OCTAVES];\nfloat lacunarities[OCTAVES];\nfloat contrasts[OCTAVES];\n\n//3D Pseudo-random hash function\nfloat hash(vec3 p) {\n    return fract(sin(dot(p, vec3(127.1, 311.7, 74.7))) * 43758.5453123);\n}\n\n// Interpolation function for vec3 (smoothstep)\nvec3 fade(vec3 t) {\n    return t * t * t * (t * (t * 6.0 - 15.0) + 10.0);\n}\n\n// Gradient noise function in 3D\nfloat gradientNoise(vec3 p) {\n    // Grid cell coordinates\n    vec3 i = floor(p);\n    vec3 f = fract(p);\n\n    // Eight corner random values\n    float a = hash(i);\n    float b = hash(i + vec3(1.0, 0.0, 0.0));\n    float c = hash(i + vec3(0.0, 1.0, 0.0));\n    float d = hash(i + vec3(1.0, 1.0, 0.0));\n    float e = hash(i + vec3(0.0, 0.0, 1.0));\n    float f_hash = hash(i + vec3(1.0, 0.0, 1.0));\n    float g = hash(i + vec3(0.0, 1.0, 1.0));\n    float h = hash(i + vec3(1.0, 1.0, 1.0));\n\n    // Interpolation weights\n    vec3 u = fade(f);\n\n    // Trilinear interpolation\n    return mix(\n        mix(mix(a, b, u.x), mix(c, d, u.x), u.y),\n        mix(mix(e, f_hash, u.x), mix(g, h, u.x), u.y),\n        u.z\n    );\n}\n\n// Main noise function with offset for 3D\nfloat noise(vec3 p, float offset) {\n    return gradientNoise(p + vec3(offset));\n}\n\nfloat contrast(float h, float wet) {\n    return mix(h,(sin((0.25+h)*4.0*PI) + 4.0*PI*h)/(4.0*PI), wet);\n}\n\n// Example usage: create multi-octave 3D noise\nfloat getHeight(vec3 p) {\n    float amplitude = 2.0;\n    float frequency = 0.5/EARTH_RADIUS;\n    float noiseSum = 0.0;\n    float maxAmplitude = 0.0;\n\n    for (int i = 0; i < OCTAVES; i++) {\n        amplitude *= persistences[i];\n        frequency *= lacunarities[i];\n        noiseSum += amplitude * noise(p * frequency, offsets[i]);\n        maxAmplitude += amplitude;\n    }\n\n    // Normalize result to [0,1]\n    return contrast(noiseSum / maxAmplitude, 0.950);\n}\n\nvec3 getGradient(float value) {\n    // Define colors for each zone\n    vec3 seaColor = vec3(0.0, 0.4, 0.7);\n    vec3 grassColor = vec3(0.4, 0.7, 0.0);\n    vec3 stoneColor = vec3(0.5, 0.5, 0.5);\n    vec3 snowColor = vec3(1.0, 1.0, 1.0);\n\n    if (value < SEA_LEVEL) {\n        return mix(vec3(0.0, 0.0, 0.2), seaColor, value/SEA_LEVEL);\n    } else if (value < GRASS_START) {\n        float t = (value - SEA_LEVEL) / (GRASS_START - SEA_LEVEL);\n        return mix(seaColor, grassColor, t);\n    } else if (value < STONE_START) {\n        float t = (value - GRASS_START) / (STONE_START - GRASS_START);\n        return mix(grassColor, stoneColor, t);\n    } else if (value < SNOW_START) {\n        float t = (value - STONE_START) / (SNOW_START - STONE_START);\n        return mix(stoneColor, snowColor, t);\n    } else {\n        return snowColor;\n    }\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Homogeneous Lat/Lon coordinates accross the viewport (Gall-Peters Projection equivalent)\n    // https://en.wikipedia.org/wiki/Gall%E2%80%93Peters_projection\n    vec2 latlon = fragCoord.yx/iResolution.yx * vec2(PI, TWO_PI) - vec2(HALF_PI, PI);\n    \n    // Spherical to Cartesian\n    vec3 cartesianCoords = EARTH_RADIUS * vec3(\n        cos(latlon.x) * cos(latlon.y), // X\n        cos(latlon.x) * sin(latlon.y), // Y\n        sin(latlon.x)                  // Z\n    );\n\n    // Each octave will have its own offset, persistence and lacunarity.\n    for (int i = 0; i < OCTAVES; i++) {\n        offsets[i] = float(10*i) + iTime*0.25;\n        lacunarities[i] = 2.0;\n        persistences[i] = 0.5;\n    }\n    \n    // Who knows, maybe fine-tuned values for each octave would result in actual earth topography\n    // I tested each combination of 10000 offsets, 10 lacunarites and 10 persistences for the first 3 octaves\n    // Here are the values with the best correlation score with a reference heightmap\n    \n    offsets[0] = 156.0;\n    lacunarities[0] = 1.1;\n    persistences[0] = 0.25;\n    \n    \n    offsets[1] = 46.0;\n    lacunarities[1] = 1.1;\n    persistences[1] = 0.25;\n    \n    offsets[2] = 650.0;\n    lacunarities[2] = 1.92;\n    persistences[2] = 0.75;\n    \n    \n    offsets[3] = 2104.0;\n    lacunarities[3] = 1.48;\n    persistences[3] = 0.5;\n    \n    /* //Keeping the other octaves time-dependant for animation\n    offsets[4] = iTime;\n    lacunarities[4] = 2.0;\n    persistences[4] = 0.5;\n    \n    offsets[5] = iTime;\n    lacunarities[5] = 2.0;\n    persistences[5] = 0.5;\n    \n    offsets[6] = iTime;\n    lacunarities[6] = 2.0;\n    persistences[6] = 0.5;\n    \n    offsets[7] = iTime;\n    lacunarities[7] = 2.0;\n    persistences[7] = 0.5;\n    */\n\n    // Output to screen\n    fragColor = vec4(getGradient(1.0-getHeight(cartesianCoords)), 1.0);\n    //fragColor = vec4(1.0-getHeight(cartesianCoords));\n}","name":"Image","description":"","type":"image"}]}