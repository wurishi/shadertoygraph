{"ver":"0.1","info":{"id":"7s23Ry","date":"1617648598","viewed":391,"name":"Inertial Ink","username":"Alien01","description":"2.6k of graphics in executable form\nTools:\n    blossom by yx\n    Shader Minifier by LLB\n    Crinkler by Mentor & Blueberry\n    Greetings to the ptscene and all who share their knowledge ","likes":18,"published":1,"flags":32,"usePreview":0,"tags":["revision","revision2021","executablegraphics"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv=fragCoord.xy/iResolution.xy;\n    fragColor = texelFetch(iChannel0,ivec2(fragCoord),0);\n}\n\n/**\n                            \n                            ~~Inertial Ink / alien01~~\n\n                    2.6k of graphics in executable form\n                    Tools:\n                    Blossom by yx\n                    Shader Minifier by LLB\n                    Crinkler by Mentor & Blueberry\n                    Greetings to the ptscene and all who share their knowledge                            \n                    \n                            ~~~~~~~~~~~~~~~~~~~~~~~~~~\n                            \n    Make sure to play with the #defines in BufferA for different versions I considered submitting.\n\n    I started from the same rendering code as my last exegfx which is pretty much taken wholsale from demofox's blog\n    https://blog.demofox.org/2020/05/25/casual-shadertoy-path-tracing-1-basic-camera-diffuse-emissive/\n    and accompanying shadertoy\n    https://www.shadertoy.com/view/tsBBWW \n\n    The painterly look is achieved by a combination of the kifs in distort() and low steps in the raymarching loop.\n \n\n*/\n\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":" #define PAINT 1\n #define DOF 0\n \n float FAR = 25.0f;\n float PI = acos(-1.);\n\nstruct Smat{\n    vec3 alb;\n    float spc;\n    float spr;\n    vec3 spcl;\n    float ior;\n};\n\nstruct Sri\n{\n    float dist;\n\tvec3 normal;\n    Smat material;\n};\n\nSmat GetZeroedMaterial(){\n    Smat ret;\n    ret.alb = vec3(0.);\n    ret.spc = 0.;\n    ret.spr = 0.;\n    ret.spcl = vec3(0.);\n    ret.ior = 1.;\n    return ret;\n}\n\nvoid PopulateMaterial(inout Smat mat, vec3 albedo, float specChance, float specRoughness, vec3 specColor, float ior){\n    mat = GetZeroedMaterial();\n    mat.alb = albedo;\n    mat.spc = specChance;\n    mat.spr = specRoughness;\n    mat.spcl = specColor;\n    mat.ior = ior;\n}\n\nmat2 rot(float a) { return mat2(cos(a), -sin(a), sin(a), cos(a));}\n\nuint wang_hash(inout uint seed)\n{\n    seed = uint(seed ^ uint(61)) ^ uint(seed >> uint(16));\n    seed *= uint(9);\n    seed = seed ^ (seed >> 4);\n    seed *= uint(0x27d4eb2d);\n    seed = seed ^ (seed >> 15);\n    return seed;\n}\n\nfloat smin(float a, float b, float k){\n\tfloat h = max(k-abs(a-b), 0.0 ) / k;\n\treturn min(a,b) - h*h*k*(1.0/4.0);\n}\n \nfloat RandomFloat01(inout uint state){return float(wang_hash(state)) / 4294967296.0;}\n\n\nfloat Rand(vec2 p) {\n    return fract(sin(dot(p, vec2(42312.23142, 831234.23124)))*214130.213213);\n}\n \nvec3 RandomUnitVector(inout uint state)\n{\n    float z = RandomFloat01(state) * 2.0f - 1.0f;\n    float a = RandomFloat01(state) * PI * 2.0 ;\n    float r = sqrt(1.0f - z * z);\n    float x = r * cos(a);\n    float y = r * sin(a);\n    return vec3(x, y, z);\n}\n\nfloat FresnelReflectAmount(float n1, float n2, vec3 normal, vec3 incident, float f0, float f90){\n    float r0 = (n1-n2) / (n1+n2);\n    r0 *= r0;\n    float cosX = -dot(normal, incident);\n    if(n1 > n2){\n        float n = n1/n2;\n        float sinT2 = n*n*(1.0 - cosX*cosX);\n        if(sinT2 > 1.0)\n            return f90;\n        cosX = sqrt(1.0 - sinT2);\n    }\n    float x = 1.0f - cosX;\n    float ret = r0 + (1.0-r0) * x * x * x * x * x;\n    return mix(f0, f90, ret);\n}\n\nfloat box2(vec2 p, vec2 b){\n\tvec2 d = abs(p)-b;\n\treturn length(max(d, 0.0)) + min(max(d.x, d.y), 0.0);\n}\n\nfloat box3(vec3 p, vec3 b){\n\tvec3 d = abs(p)-b;\n\treturn length(max(d, 0.0)) + min(max(d.x, max(d.y, d.z)), 0.0);\n}\n\nfloat distort(vec3 p){\n\tfloat final = 0.0;\n\tfloat y = p.y;\n\tp.z -= 10.0;\n\tp.xz *= vec2(0.1, 0.5);\n\tfor(int i = 0; i < 4; i++){\n\t\tfinal += box2(p.xz, vec2(5*i));\n\t\tp.z -= 10.0;\n\t\tp.x *= 2.0;\n\t\tp.xz *= rot(0.2*float(i)*y);\n\t\tp.x = abs(p.x);\n\t\tp.z = cos(p.x * 2.0+sin(p.z * 2.0));\n\t\tp.z -= 5.0;\n\t\tp.xz *= rot(0.8 - p.y);\n\t\tp.x -= 5.0;\n\t}\n\treturn final  / 22.0;\n}\n\nfloat extrude(vec3 p, float sdf, float h){\n\tvec2 w = vec2(sdf, abs(p.y) - h);\n\treturn min(max(w.x, w.y), 0.0 )+length(max(w, 0.0));\n}\n\nfloat repeatSphere(vec3 p){\n\tfloat final = 1000000.0;\n\tp.zy += vec2(20, -2);\n\tp.yz *= rot(PI*0.5);\n\tp.x = abs(p.x)-3.0;\n\tp.xz*=rot(0.7);\n\tp.y = abs(p.y)-10.0;\n\tfor(int i = 0; i < 6; i++){\n\t\tfloat s = length(p)-(1.0 - float(i)*0.11);\n\t\tfinal = min(final, s);\t\n\t\tp.x -= 2.5;\n\t\tp.xz *= rot(1.2);\n\t\tp.xy *= rot(-0.5);\n\t\tp.z -= 0.5;\n\t\tp.yz *= rot(-0.6);\n\t}\n\treturn final;\n}\n\n\nfloat map(vec3 p){\n\n\tvec3 spp = p;\n\tvec3 pp = p;\n\tvec3 cp = p;\n\tfloat sp = length(p-vec3(0, 0, -30))-30.0;\n\tp.y += 2.5;\n\tp.x *= atan(p.y, p.z) ;\n\t\n\tfloat d =  distort(p);\n\tfloat final = extrude(p, d, 3.0);\n\tfinal = max(sp, final);\n\n\tfloat rp = repeatSphere(spp);\n\tfinal = smin(final, rp, 3.0);\n\n\tspp.z += 40.0;\n\tspp.y -= -1.5;\n\tspp.xz *= rot(PI/4.0);\n\tspp.yz *= rot(PI/4.0);\n\tfloat bo = box3(spp , vec3(0.8) );\n\tfinal = smin(final, bo, 1.5); \n    return final ;\n}\n\nvec3 GetNormal(vec3 p){\n   float h = 0.0001;\n   vec2 k = vec2(1, -1);\n  return normalize(\n  k.xyy * map(p + k.xyy*h) + \n  k.yyx * map(p + k.yyx*h) +\n  k.yxy * map(p + k.yxy*h) +\n  k.xxx * map(p + k.xxx*h));\n}\n\nvoid TestSceneMarch(in vec3 ro, in vec3 rd, inout Sri hitInfo){\n    float a = 0.01;\n\tint i = 0;\n    #if PAINT\n    for(i = 0; i < 60; i++){\n    #else\n    for(i = 0; i < 256; i++){\n    #endif\n        float b = map(ro + rd*a);\n        a += b;\n        if(a>FAR)\n            break;\n        else if(abs(b) < 0.00001) {\n            vec3 p = ro+a*rd;\n            hitInfo.dist = a;\n\t\t    hitInfo.normal = GetNormal(p);\n\t\t\tif( (p.x+sin(p.y*1.9)*5.0)/(.17+tan(hitInfo.normal.z)) < 0.0)\n\t\t\t\tPopulateMaterial(hitInfo.material, vec3(0.0), 0.1, 0.3, vec3(1.0f, 1.0f, 1.0f) * 0.8f, 1.);\n\t\t\telse\n\t\t\t\tPopulateMaterial(hitInfo.material, vec3(0.8f, 0.1f, 0.1f), 0.1, 0.5, vec3(0.1f, 0.4f, 1.0f) * 0.8f, 0.9);\n            break;\n        }\n    }\n}\n\nvec3 GetColorFromRay(in vec3 _ro, in vec3 _rd, inout uint rng){\n    vec3 ret = vec3(0.0f, 0.0f, 0.0f);\n    vec3 throughput = vec3(1.0f, 1.0f, 1.0f);\n    vec3 ro = _ro;\n    vec3 rd = _rd;\n    float dist=0.0;\n    for(int i = 0; i <= 3; ++i){\n        Sri hitInfo;\n        hitInfo.material = GetZeroedMaterial();\n        hitInfo.dist = FAR;\n        TestSceneMarch(ro, rd, hitInfo);\n        dist = hitInfo.dist;\n        if(hitInfo.dist >= FAR){\n            ret += 0.5 * throughput;\n            break;\n        }\n  \n        float specularChance = hitInfo.material.spc;\n\n        float rayProbability = 1.f;\n        if(specularChance > 0.0f){\n            specularChance = FresnelReflectAmount(\n                    1.0,\n                    hitInfo.material.ior,\n                    rd, hitInfo.normal, hitInfo.material.spc, 1.0f\n            );\n        }\n\n        float doSpecular = 0.0f;\n        float raySelectRoll = RandomFloat01(rng);\n        if(specularChance > 0. && raySelectRoll < specularChance){\n            doSpecular = 1.0f;\n            rayProbability = specularChance;\n        }\n        else {\n            rayProbability = 1.0f - (specularChance);\n        }\n\n        rayProbability = max(rayProbability, 0.001f);\n\n        \n        ro = (ro + rd * hitInfo.dist) + hitInfo.normal * 0.0001f;\n\n        vec3 diffuse_rd = normalize(hitInfo.normal + RandomUnitVector(rng));\n\n        vec3 specular_rd = reflect(rd, hitInfo.normal);\n        specular_rd = normalize(mix(specular_rd, diffuse_rd, hitInfo.material.spr * hitInfo.material.spr));\n        \n        \n        rd = mix(diffuse_rd, specular_rd, doSpecular);\n\n        \n\n        throughput *= mix(hitInfo.material.alb, hitInfo.material.spcl, doSpecular);\n\n        throughput /= rayProbability;\n\n        {\n            float p = max(throughput.x, max(throughput.y, throughput.z));\n            if(RandomFloat01(rng) > p)\n                break;\n            throughput *= 1.0f / p;\n        }\n    }\n    return ret ;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy;\n    vec3 ro = vec3(0.0f, 1.0f, -55.0f);\n    vec3 cameraUp = vec3(0.0f, 1.0f, 0.0f);\n    vec3 cameraRight = vec3(1.0f, 0.0f, 0.0f);\n    uint rng = uint(uint(uv.x/iResolution.x) * uint(1973) + uint(uv.y/iResolution.y) * uint(9277) + uint(iFrame) * uint(26699)) | uint(1);\n    vec2 jitter = vec2(RandomFloat01(rng), RandomFloat01(rng)) - 0.5f;\n    vec3 rd;\n\tvec2 uvJittered = (uv+jitter)/iResolution.xy;\n\tvec2 screen = uvJittered * 2.0f - 1.0f;\n\tscreen.y /= (iResolution.x/iResolution.y);\n\trd = vec3(screen, 1.0f/tan(70.0f * 0.5f * PI / 180.0f));\n\trd.yz *= rot(0.2);\n\trd = normalize(mat3(cameraRight, cameraUp, vec3(0.0f, 0.0f, 1.0f)) * rd);\n    float angle = RandomFloat01(rng) * 2.0f * PI;\n    float dof = 0.05;\n    #if DOF\n    dof = 1.0f;\n    #endif\n\tvec2 offset = vec2(cos(angle), sin(angle)) * sqrt(RandomFloat01(rng))*dof;\n\tvec3 focalPoint = ro + rd * 15.0;\n\tro += offset.x * cameraRight + offset.y * cameraUp;\n\trd = normalize(focalPoint - ro); \n    vec3 color = GetColorFromRay(ro, rd, rng);\n\tfragColor = texelFetch(iChannel0,ivec2(fragCoord),0);\n    fragColor += vec4(color,1);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"vec3 LessThan(vec3 f, float value)\n{\n    return vec3(\n        (f.x < value) ? 1.0f : 0.0f,\n        (f.y < value) ? 1.0f : 0.0f,\n        (f.z < value) ? 1.0f : 0.0f);\n}\n \nvec3 LinearToSRGB(vec3 rgb)\n{\n    rgb = clamp(rgb, 0.0f, 1.0f);\n    return mix(\n        pow(rgb, vec3(1.0f / 2.4f)) * 1.055f - 0.055f,\n        rgb * 12.92f,\n        LessThan(rgb, 0.0031308f)\n    );\n}\n\nvec3 ACESFilm(vec3 x)\n{\n    float a = 2.51f;\n    float b = 0.03f;\n    float c = 2.43f;\n    float d = 0.59f;\n    float e = 0.14f;\n    return clamp((x*(a*x + b)) / (x*(c*x + d) + e), 0.0f, 1.0f);\n}\n \nvoid mainImage(out vec4 fragColor, vec2 fragCoord){\n\tvec2 uv=fragCoord.xy/iResolution.xy;\n\tvec4 tex=texelFetch(iChannel0,ivec2(fragCoord),0);\n\tvec3 color=tex.rgb/tex.a;\n    color = ACESFilm(color);\n    color = LinearToSRGB(color);\n\tuv -= 0.5;\n\tfragColor.rgb = color * (1.0-dot(uv,uv)*1.5);\n}\n","name":"Buffer B","description":"","type":"buffer"}]}