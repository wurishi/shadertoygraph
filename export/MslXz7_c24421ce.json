{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[],"code":"// 2nd order SH example by Morgan McGuire, http://graphicscodex.com\n//\n// See also:\n//    http://dickyjim.wordpress.com/2013/09/04/spherical-harmonics-for-beginners/ \n//     (and dickyjim's example that this is based on at https://www.shadertoy.com/view/Xds3Rl)\n//    http://home.comcast.net/~tom_forsyth/papers/SH_GDCE_TomF.zip\n//    http://ppsloan.org/publications/StupidSH36.pdf\n// \n\n#define Radiance3 vec3\n#define Irradiance3 vec3\n#define Vector3 vec3\n#define Color3 vec3\n\n// 2nd order SH\n#define SH vec4\n\nconst float PI = 3.141592654;\n\n// Increase this from 1.0 to increase terminator onset at the expense of ringing.\n// Decrease towards 0.0 to blur lighting and reduce ringing and sharpness.\nconst float SHSharpness = 1.0;\n\nstruct Light {\n\tvec3 directionToLight;\n\tvec3 radiance;\n};\n\n// The actual lights\nconst int NUM_LIGHTS = 2;\nLight lightArray[NUM_LIGHTS];\n\n// The environment map contribution, which in this simple example\n// is modeled as constant.\nRadiance3 environment;\n\n// A uniform flat environment color. This helps hide some of the SH\n// ringing, which can force the environment term to zero.\nRadiance3 ambient;\n\n// SH approximation of all of the lights.\n// Array index is color channel.\nSH lightProbeSH[3];\n\nconst float SHCosWtIntOrder2 = 0.75;\nconst float SHDirectionalLightNormalizationFactor = PI / SHCosWtIntOrder2;\n\nSH projectToSH(Vector3 direction) {\t\n\tconst float p_1_1 = -0.488602511902919920;\t\n\treturn vec4(\n\t\t// l=0, m=0\t\n\t\t0.282094791773878140,\n\n\t\t// l=1, m=0\n\t\t0.488602511902919920 * direction.z,\n\t\t\n\t\t// l=1, m=-1\n\t\tp_1_1 * direction.y,\n\n\t\t// l=1, m=+1\n\t\tp_1_1 * direction.x);\n}\n\n\n\nvoid convertToIrradianceProbe(inout SH sh_l) {\n\tconst float sh_c0 = (2.0 - SHSharpness) * 1.0;\n\tconst float sh_c1 = SHSharpness * 2.0 / 3.0;\n\tsh_l *= vec4(sh_c0, vec3(sh_c1));\n}\n\n\n///////////////////////////////////////////////////////////////////////\n// Lighting\n\n/* In a real application, this step would be precomputed (per frame or per scene)\n   for each SH probe */\t\nvoid computeSHLightProbe(Light lightArray[NUM_LIGHTS]) {\n\tfor (int c = 0; c < 3; ++c) {\n\t\tlightProbeSH[c] = vec4(environment[c], vec3(0));\n\t}\n\t\n\tfor (int i = 0; i < NUM_LIGHTS; ++i) {\n\t\tvec4 lightSH = projectToSH(lightArray[i].directionToLight) * SHDirectionalLightNormalizationFactor;\n\t\n\t\t// Compute the probe\n\t\tfor (int c = 0; c < 3; ++c) {\n\t\t\tlightProbeSH[c] += lightSH * lightArray[i].radiance[c];\n\t\t}\n\t}\n\n\tfor (int c = 0; c < 3; ++c) {\n\t\tconvertToIrradianceProbe(lightProbeSH[c]);\n\t}\n}\n\n\n/* Per-pixel shading */\nRadiance3 shade(SH lightProbeSH[3], Vector3 normal, Color3 surfaceReflectivity) {\n\tvec4 normalSH = projectToSH(normal);\n\n\t// This is a 4x3 x 3x1 matrix product, but WebGL can't\n\t// express that.\n\tIrradiance3 result;\n\tfor (int c = 0; c < 3; ++c) {\n\t\tresult[c] = dot(lightProbeSH[c], normalSH);\n\t}\n\t\n\t// Better results could be obtained by handling the ambient term separately\n\t// so that ringing can't force the color to black.\n\treturn (max(result, vec3(0)) + ambient) * surfaceReflectivity / PI;\n}\n\n\n///////////////////////////////////////////////////////////////////////\n// Shadertoy setup\n\n\n/* Returns w=0 if the ray misses */\nvec4 intersectSphere(vec2 pix, float size) {\n\tvec2 uv = pix / size;\n\tfloat offset = uv.x * uv.x + uv.y * uv.y;\n\treturn (offset > 1.0) ? vec4(0.0) : vec4(uv, sqrt(1.0 - offset), 1.0);\n}\n\n\nRadiance3 shade2(Light lightArray[NUM_LIGHTS], Vector3 normal, Color3 surfaceReflectivity) {\n\tIrradiance3 result = ambient + environment;\n\n\tfor (int i = 0; i < NUM_LIGHTS; ++i) {\n\t\tresult += max(dot(lightArray[i].directionToLight, normal), 0.0) * lightArray[i].radiance;\n\t}\n\t\t\n\treturn result * surfaceReflectivity / PI;\n}\n\n\t\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\t// These are directional lights, but we could instead evaluate point lights\n\t// into directional lights at the location of the SH light probe.\n\tlightArray[0] = Light(normalize(vec3(cos(iTime * 0.2 + 2.0),1,0.1)), 1.0 * Radiance3(0.75,0.75,0.75));\n\tlightArray[1] = Light(normalize(vec3(1,cos(iTime),sin(iTime))), 1.2 * Radiance3(0.75,0.6,0));\n\tenvironment = Radiance3(0.05, 0.1, 0.1);\n\tambient = Radiance3(0.1);\n\t\n\t// Click near the top to simplify the lighting rig\n\tif (iMouse.y > iResolution.y * 0.9) {\n\t\tlightArray[1].radiance *= 0.0;\n\t\tenvironment *= 0.0;\n\t\tambient *= 0.0;\n\t}\n\n\tcomputeSHLightProbe(lightArray);\t\n\n\n\t// Fraction of light reflected, on [0, 1]. The integral of f(wi,wo)*|n . wi| over the hemisphere.\n\tconst Color3 surfaceReflectivity = vec3(1);\n\n\tvec2 pix = vec2(mod(fragCoord.x, iResolution.x * 0.5) - iResolution.x * 0.25,\n           \t\tfragCoord.y - iResolution.y * 0.5);\n\tpix *= 0.6;\n\t\n\tvec4 position = intersectSphere(pix, 0.25 * min(iResolution.x, iResolution.y));\n\t\n\t// For a sphere about the origin, the position is the normal\n\tvec3 normal = normalize(position.xyz);\n\t\n\tfloat mouseX = (iMouse.x > 0.0) ? iMouse.x : iResolution.x * 0.5;\n\t\n\tRadiance3 L = (fragCoord.x > mouseX) ? \n\t\tshade(lightProbeSH, normal, surfaceReflectivity) :\n\t\tshade2(lightArray, normal, surfaceReflectivity);\n\t\n\tconst float gamma = 2.1;\t\n\t\n\tfragColor = vec4(\n\t\t(abs(fragCoord.x - mouseX) < 1.0) ? \n\t\t  vec3(1.0) :\n\t\t  pow(mix(Radiance3(0.3 + 0.3 * fragCoord.y / iResolution.y, 0.5, 0.35 - 0.05 * fragCoord.y / iResolution.y), L, position.w), vec3(1.0 / gamma)), \n\t\t1.0);\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"MslXz7","date":"1398707803","viewed":3380,"name":"2nd Order SH Lighting","username":"morgan3d","description":"Simple WebGL reference implementation of 2nd order directional SH lighting of a Lambertian surface. \nPer-light computation on the left, SH approximation on the right. Wipe with the mouse.\n","likes":31,"published":1,"flags":0,"usePreview":0,"tags":["lighting","diffuse","sphericalharmonics","secondorder"],"hasliked":0,"parentid":"","parentname":""}}