{"ver":"0.1","info":{"id":"cld3Wj","date":"1686236862","viewed":90,"name":"RM tutorial: simple shapes","username":"jakecariello","description":"as the title says","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","simple","tutorial","shapes"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n    conventions:\n    - d = distance\n    - sd = surface distance\n    - if a function expects a unit vector, it will normalize just in case\n\n*/\n\n#define S(a, b, t) smoothstep(a, b, t)\n#define PI 3.14159265\n\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_THRESH .001\n#define K_FACTOR 0.5\n#define FUZZ_AMPLITUDE 1.\n \n\n// comment lines here to control effects\n#define ORBIT\n//#define FUZZ\n\nfloat rand21(vec2 v){\n  return fract(sin(dot(v.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\n// smoothmin function for metaball effect\n// from: https://github.com/glslify/glsl-smooth-min/blob/master/poly.glsl\nfloat smin(float a, float b, float k) {\n  float h = clamp(0.5 + 0.5 * (b - a) / k, 0.0, 1.0);\n  return mix(b, a, h) - k * h * (1.0 - h);\n}\nvec4 smin(vec4 a, vec4 b, float k) {\n  vec4 h = clamp(0.5 + 0.5 * (b - a) / k, 0.0, 1.0);\n  return mix(b, a, h) - k * h * (1.0 - h);\n}\n\n// from: https://github.com/glslify/glsl-look-at/tree/gh-pages\nmat3 lookAt(vec3 origin, vec3 target, float roll) {\n  vec3 rr = vec3(sin(roll), cos(roll), 0.0);\n  vec3 ww = normalize(target - origin);\n  vec3 uu = normalize(cross(ww, rr));\n  vec3 vv = normalize(cross(uu, ww));\n  return mat3(uu, vv, ww);\n}\n\n// 3D rotation matrix around an axis\n// from: https://github.com/dmnsgn/glsl-rotate/blob/main/rotation-3d.glsl\nmat4 rotate(vec3 axis, float angle) {\n  axis = normalize(axis);\n  float s = sin(angle);\n  float c = cos(angle);\n  float oc = 1.0 - c;\n\n  return mat4(\n    oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n    oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n    oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n    0.0,                                0.0,                                0.0,                                1.0\n  );\n}\n\n// SPHERE\n// s = (x, y, z, r)\nfloat sdSphere(vec3 p, vec4 s) {\n    return length(p - s.xyz) - s.w;\n}\n\n// CAPSULE\n// i.e., 3D line segment between a and b with thickness of 2r\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r) {\n    vec3 ab = b - a;\n    vec3 ap = p - a;\n    float t = clamp(dot(ab, ap) / dot(ab, ab), 0., 1.);\n    return length(p - (a + t * ab)) - r;\n}\nfloat sdCapsule(vec3 p, vec3 a, vec3 b) { return sdCapsule(p, a, b, .15); }\n\n// CYLINDER\nfloat sdCylinder(vec3 p, vec3 a, vec3 b, float r) {\n    vec3 ab = b - a;\n    vec3 ap = p - a;\n    float t = dot(ab, ap) / dot(ab, ab);\n    float x = length(p - (a + t * ab)) - r;\n    float y = length(ab) * (abs(t - .5) - .5);\n    float e = length(max(vec2(x, y), 0.));\n    float i = min(max(x, y), 0.);\n    return e + i;\n}\nfloat sdCylinder(vec3 p, vec3 a, vec3 b) { return sdCapsule(p, a, b, .15); }\n\n// TORUS\n// r = (rTube, rHole)\n// c = center\nfloat sdTorus(vec3 p, vec3 c, vec2 r) {\n    float x = length(p.xz - c.xz) - r.x;\n    return length(vec2(x, p.y - c.y)) - r.y;\n}\n\n// CUBE\n// c = (x, y, z, s)\n// (x, y, z) = center\n// s = side length\n// r = edge radius buffer\nfloat sdCube(vec3 p, vec4 c, float r) { // r\n    return length(max(abs(p - c.xyz) - c.w / 2. + r, 0.)) - r;\n}\nfloat sdCube(vec3 p, vec4 c) { return sdCube(p, c, .05); }\n\n// scene = (r, g, b, d), where d is distance\nvoid add(inout vec4 scene, vec4 object) {\n    float dd = object.w - scene.w;\n    scene.rgb = mix(scene.rgb, object.rgb, S(1., -1., dd));\n    scene.w = smin(scene.w, object.w, K_FACTOR);\n}\n\n// distance from p to the scene's surfaces, initialized with floor plane\nvec4 buildScene(vec3 p) {\n    vec4 scene = vec4(vec3(1), p.y);\n    add(scene, vec4(vec3(1, 0, 0), sdSphere(p, vec4(0, 2, 1, 0.5))));\n    add(scene, vec4(vec3(0, 1, 0), sdCapsule(p, vec3(1, 1, 0), vec3(3, 1, 0), .25)));\n    add(scene, vec4(vec3(0, 0, 1), sdTorus(p, vec3(0, 2. * (sin(iTime) + 1.) / 2., 0), vec2(2., .25))));\n    add(scene, vec4(vec3(1, 1, 0), sdCube(p, vec4(-3, 2, 0, 1))));\n    add(scene, vec4(vec3(0, 1, 1), sdCylinder(p, \n        vec3(1. + 2. * sin(iTime), 2, 1. + 2. * cos(iTime)), vec3(1. - 2. * sin(iTime), 2, 1. - 2. * cos(iTime)), .25)));\n    return scene;\n}\n\n// perform a ray march from ro in direction rd\n// ro: ray origin\n// rd: ray direction\nvec4 rayMarch(vec3 ro, vec3 rd) {\n    vec4 L = vec4(0);\n    float dL = SURF_THRESH;\n    vec3 dir = normalize(rd), p = ro;\n    for (int i = 0; i < MAX_STEPS && !(L.w > MAX_DIST || dL < SURF_THRESH); i += 1) {\n        vec4 scene = buildScene(p);\n        dL = scene.w;\n        L.rgb = scene.rgb;\n        L.w += dL;\n        p = ro + dir * L.w;\n    }\n    return L;\n}\n\n// surface normal at point P\n// calculates 3D \"gradient\" (surface normal points along gradient)\nvec3 normal(vec3 p) {\n    float d = buildScene(p).w;\n    vec2 e = vec2(.01, 0);\n    vec3 n = d - vec3(\n        buildScene(p - e.xyy).w,\n        buildScene(p - e.yxy).w,\n        buildScene(p - e.yyx).w);\n    vec3 c = cross(p, n);\n    #ifdef FUZZ\n    float fuzz = FUZZ_AMPLITUDE * (sin(2. * PI * iTime / 4.)  + 1.) / 2.;\n    n = (rotate(c, fuzz * PI / 2. * ((rand21(n.xy + n.xz + p.yz) - .5))) * vec4(n, 1)).xyz;\n    #endif\n    return normalize(n);\n}\n\n// calculate lighting value at point p for light position l\nfloat light(vec3 p, vec3 l) {\n    vec3 lp = l - p;\n    vec3 n = normal(p);\n    // diffuse light: measures \"alignment\" between...\n    // 1. lp: unit vector pointing from point to light source\n    // 2: n: the point's surface unit normal\n    // maximized when n == lp\n    float diff = clamp(dot(n, normalize(lp)), 0., 1.);\n    // distance to light from p (need to offset away from surface to prevent ray marching prematurely exiting)\n    float dl = rayMarch(p + n * SURF_THRESH * 20., lp).w;\n    if (dl < length(lp)) diff *= .4;\n    return clamp(diff, .2, 1.);  \n}\n\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord )\n{\n    // [-.5, .5] ... 0-centering required for that convenient rd trick below\n    vec2 uv = (fragCoord - iResolution.xy / 2.)/min(iResolution.x, iResolution.y);\n\n    vec3 col = vec3(0);\n\n    // ray origin and direction\n    vec3 ro = vec3(0, 5, -5);\n    \n    #ifdef ORBIT\n    ro.xz = 5. * vec2(sin(iTime / 2.), cos(iTime / 2.));\n    #endif\n    \n    vec3 rd = normalize(lookAt(ro, vec3(0), 0.) * vec3(uv, 1));\n    vec4 rm = rayMarch(ro, rd);\n    vec3 p = ro + normalize(rd) * rm.w;;\n    vec3 dif = light(p, vec3(5. * sin(iTime ), 5, 5. * cos(iTime))) * rm.rgb;\n    \n    \n    col = dif;\n\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}