{"ver":"0.1","info":{"id":"3st3zB","date":"1568798597","viewed":251,"name":"Doodling : Utrecht","username":"Flopine","description":"I worked on this shader for the showdown that happened at Utrecht during Cultural Sundays, this one being organized with CCU : https://twitter.com/cc_utr","likes":14,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","flower","spikes"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Code by Flopine\n// Thanks to wsmind, leon, XT95, lsdlive, lamogui, Coyhot, Alkama and YX for teaching me\n// Thanks LJ for giving me the love of shadercoding :3\n\n// Thanks to the Cookie Collective, which build a cozy and safe environment for me \n// and others to sprout :)  https://twitter.com/CookieDemoparty\n\n#define PI 3.141592\n\nmat2 rot (float a)\n{return mat2(cos(a),sin(a),-sin(a),cos(a));}\n\nfloat cyl (vec3 p, float r, float h)\n{return max(length(p.xy)-r, abs(p.z)-h);}\n\nfloat box (vec3 p, vec3 c)\n{\n    return length(max(abs(p)-c,0.));\n}\n\nvoid moda(inout vec2 p, float rep)\n{\n    float a = atan(p.y,p.x);\n    float per = 2.*PI/rep;\n    float l = length(p);\n    a = mod(a-per*0.5, per)-per*0.5;\n    p = vec2(cos(a),sin(a))*l;\n}\n\nvoid mo (inout vec2 p, vec2 d)\n{\n    p = abs(p)-d;\n    if (p.y>p.x) p = p.yx;\n}\n\nfloat tunnel (vec3 p)\n{\n    p.x += texture(iChannel0, p.yz*0.01).r*0.4;\n    p.y += texture(iChannel0, p.xz*0.008).r*0.5;\n    return -cyl(p, 5., 1e10);\n}\n\nfloat ribs (vec3 p)\n{    \n    float per = .5;\n    p.z = mod(p.z-per*0.5, per)-per*0.5;\n    p.y += p.x*p.x*0.6;\n    return cyl(p.yzx, .2-abs(p.x)*0.2, 5.);\n}\n\nfloat g1 = 0.;\nfloat skeleton (vec3 p)\n{\n    p.z += iTime;\n    p.xy *= rot(p.z*0.1);\n    mo(p.xy, vec2(1., 1.8));\n    p.x -= 2.5;\n    p.y += sin(p.z*0.6);\n    p.x += cos(p.z)*0.2;\n    p.xy *= rot(p.z*0.1);\n    float spine = cyl(p, 0.25,1e10);\n    float d =  min(spine, ribs(p));\n    g1 += 0.1/(0.1+d*d);\n    return d;\n}\n\nfloat g2 = 0.;\nfloat flower(vec3 p)\n{\n    p.z -= 2.+iTime;\n    p.xz *= rot(iTime);\n    p.xz *= rot(p.y*0.5);\n    mo(p.xy, vec2(0.5));\n    mo(p.xz, vec2(1.));\n    moda(p.xz, 3.);\n    p.x -= 0.5;\n    float d = box(p, vec3(.05-sin(p.y-.5),1.5,0.05));\n    g2 += 0.1/(0.1+d*d);\n    return d;\n}\n\nfloat SDF (vec3 p)\n{\n    return min(flower(p),min(tunnel(p), skeleton(p)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = 2.*(fragCoord/iResolution.xy)-1.;\n\tuv.x *= iResolution.x/iResolution.y;\n    float dither = texture(iChannel0, uv).r;\n    \n    vec3 ro = vec3(0.001,0.001, -3.+iTime); vec3 p = ro;\n    vec3 rd = normalize(vec3(uv,1.));\n    vec3 col = vec3(0.);\n    \n    float shad = 0.;\n    \n    for (float i=0.; i<64.; i++)\n    {\n        float d = SDF(p);\n        if (d<0.01)\n        {\n            shad = i/64.;\n            break;\n        }\n        d *= 0.6+dither*0.1;\n        p+=d*rd;\n    }\n    \n    col = vec3(shad);\n    col += g1*vec3(0.08,0.12,0.08)*exp(-fract(iTime))*0.25;\n    col += g2 * vec3(0.5,0.1,0.2)*0.2;\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}