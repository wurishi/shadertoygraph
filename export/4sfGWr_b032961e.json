{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[{"channel":0,"type":"texture","id":"XdXGzn","filepath":"/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"code":"/* Basic idea:\n   Show a surface of voronoi shapes. We generate n centroids, and\n\tvary their positions over time, using noise and/or fbm and/or just sine functions.\n   Then for each uv, we find the nearest centroid, and render the point using diffuse &\n   specular reflection.\n   The normal could be computed maybe as if on a sphere whose center is the centroid.\n\n   Bonus points for iridescent coloring. :-)\n   Or probably color each sphere a stable color, maybe based on its index.\n\tBut it could have iridescence on top.\n   Also, could reflect a cubemap.\n   \n   iChannel0 supplies the colors for the various regions.\n   I've used the texture that looks like colored static, but others\n   are good too.\n\n   Also try weighted voronoi diagrams - multiplicatively or additively\n   (for circular or hyperbolic edges).\n   It's easy to modify the d formula; the trouble comes in adjusting the\n   drawing of centroid dots and borders to match.\n\n   Another option: shading by distance from nearest centroid.\n */\n\n\nconst float PI = 3.14159265;\nconst float centroidDotRadius = 0.02;\nconst float lineThickness = 0.02;\n\n// Uncomment to use FBM: more random motion of centroids, but slower framerate.\n// #define USE_FBM 1 // not working at present\n\n// rand, noise, and fbm copied from https://www.shadertoy.com/view/Xsl3zN \"Fire\" by @301z\n\n// Given a vec2 seed n, return a pseudorandom float between 0 and 1.\nfloat rand(vec2 n) { \n\treturn fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\n\n#ifdef USE_FBM\n// Seems to be pretty fast. Should return a number between 0 and 1.\nfloat noise(vec2 n) {\n\tconst vec2 d = vec2(0.0, 1.0);\n\tvec2 b = floor(n), f = smoothstep(vec2(0.0), vec2(1.0), fract(n));\n\treturn mix(mix(rand(b), rand(b + d.yx), f.x), mix(rand(b + d.xy), rand(b + d.yy), f.x), f.y);\n}\n\n// Fractional brownian motion. Should return a number between 0 and 2,\n// with the highest probabilities nearest 1 (gaussian distribution?).\nfloat fbm(vec2 n) {\n\tfloat total = 0.0, amplitude = 1.0;\n\tfor (int i = 0; i < 7; i++) {\n\t\ttotal += noise(n) * amplitude;\n\t\tn += n;\n\t\tamplitude *= 0.5;\n\t}\n\treturn total;\n}\n#endif\n\nconst int nRegions = 16;\n\n// No point in storing them:\n// struct region {\tvec2 c; } regions[nRegions];\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord.xy * 2.0 - iResolution.xy) / iResolution.yy;\n\n\tvec4 col = vec4(0.0, 0.0, 0.0, 1.0);\n\n\tint closestI = -1;\n\tfloat closestD = 9998.0, nextClosestD = 9999.0;\n\tvec2 closestC, nextClosestC;\n\tbool isDot = false;\n\t\n\t// place region centroids, and find nearest\n\tfor (int i=0; i < nRegions; i++) {\n\t\t// convert i to a float between -1 and 1:\n\t\tfloat fi = (2.0 * float(i) / float(nRegions) - 1.0);\n\n\t\tfloat t = (iTime + 200.0) * (0.2 + fi * 0.3) * 0.2;\n\n\t\t// to do: add in noise or fbm to placement.\n\t\t// TODO: use i. Maybe a spiral path.\n\t\tfloat a1 = (2.0 * PI) * (t * 0.2 + 0.1);\n\t\tfloat r1 = 0.7 + 0.5 * sin(t * fi * 0.2);\n\t\tfloat a2 = t * 1.67 + 3.8;\n\t\tfloat r2 = 0.4 + 0.7 * sin(t * (0.6 + fi * 0.27));\n#ifdef USE_FBM\n\t\tfloat xoff = fbm(vec2(t + fi, t + fi + 1.0)) - 0.5;\n\t\tfloat yoff = fbm(vec2(t - fi, t - fi + 1.0)) - 0.5;\n#else\n\t\tfloat xoff = 0.0, yoff = 0.0;\n#endif\n\t\t// Assign this to regions[i].c if needed.\n\t\tvec2 c = vec2(cos(a1) * r1 + cos(a2) * r2 + xoff * 0.5,\n\t\t\t\t\t  sin(a1) * r1 + sin(a2) * r2 + yoff * 0.5);\n\t\t// vec2(sin(t * 2.0 + 0.5), cos(t * 2.5));\n\t\t// weighting\n\t\tfloat w = 2.0 + fi;\n\n\t\tif (!isDot) {\n\t\t\tfloat d = distance(c, uv); // distance to centroid // *w or -w\n\t\t\tif (d < closestD) {\n\t\t\t\tclosestI = i;\n\t\t\t\tnextClosestD = closestD;\n\t\t\t\tclosestD = d;\n\t\t\t\tnextClosestC = closestC;\n\t\t\t\tclosestC = c;\n\t\t\t\tif (d < centroidDotRadius) {\n\t\t\t\t\tisDot = true;\n\t\t\t\t}\n\t\t\t} else if (d < nextClosestD) {\n\t\t\t\tnextClosestD = d;\n\t\t\t\tnextClosestC = c;\n\t\t\t}\n\t\t}\t\t\n\t}\n\t\n\tclosestD = max(closestD, 0.00001); // avoid /0 errors\n\n\t// Get color of region i from texture.\n\tfloat rr1 = rand(vec2(float(closestI), 1.0));\n\tfloat rr2 = rand(vec2(float(closestI + 1), 1.0));\n\tcol = mix(texture(iChannel0, vec2(rr1, rr2)), vec4(1.0), 0.5);\n\t\n\tif (isDot) {\n\t\tcol *= smoothstep(centroidDotRadius * 0.5,\n\t\t\t\t\t\t  centroidDotRadius * 1.5, closestD);\n\t} else {\n\t\t// Shade according to distance from nearest centroid\n\t\t// TODO: make this dropoff bell-shaped. The gaussian formula at\n\t\t// http://en.wikipedia.org/wiki/Normal_distribution looks complicated, but\n\t\t// maybe that's the best answer. Use mu=0, sigma^2=5?\n\t\t// What about http://en.wikipedia.org/wiki/Normal_distribution#Standard_normal_distribution ?\n\t\t// That seems to imply mu=0, sigma=1\n\t\t// Here is the standard normal distribution, with the constant coefficient (1 / sqrt(2 pi)) removed.\n\t\t// That puts it more in the range we want, anyway. I think.\n\t\tconst float sigma = 0.8; // Greater sigma makes bell curve less steep.\n\t\tcol *= 1.2 * exp(closestD * closestD * (-0.5 / (sigma * sigma)));\n\t\t\n\t\t// Compute distance from edge of region, so we can draw border.\n\t\t// midpoint between two closes centroids:\n\t\tvec2 c3 = (nextClosestC + closestC) * 0.5;\n\t\tvec2 pc3 = c3 - uv;\n\t\tvec2 c1c2 = nextClosestC - closestC;\n\t\tfloat fromEdge = dot(normalize(c1c2), pc3);\n\t\t\n\t\tif (fromEdge <= lineThickness) {\n\t\t\t// TODO: why are there weird kinks at the corners?\n\t\t\tcol *= smoothstep(lineThickness * 0.25, lineThickness * 0.75, fromEdge);\n\t\t}\n\t}\n\n\tfragColor = col;\n}\n","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"4sfGWr","date":"1369160419","viewed":1078,"name":"Voronoitoy","username":"huttarl","description":"A simple voronoi polygon demo.","likes":15,"published":1,"flags":0,"usePreview":0,"tags":["procedural","voronoi"],"hasliked":0,"parentid":"","parentname":""}}