{"ver":"0.1","info":{"id":"stSBDG","date":"1652770334","viewed":160,"name":"SH - Spherical Harmonics","username":"42yeah","description":"Calculate spherical harmonics from the ground up. Modify band and m at top of the shader.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","sphericalharmonics","sh"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const int L = 3; // band\nconst int M = -2; // M \\in [-L, L]\n\nvec2 sol(vec3 p) {\n    return vec2(p.y, 0.0);\n}\n\nvec2 sphere(vec3 p) {\n    vec3 local = vec3(p.x, p.y - 1.0, p.z);\n    return vec2(length(local) - 1.0, 3.0);\n}\n\nvec2 map(vec3 p) {\n    vec2 info = sol(p);\n    vec2 iSphere = sphere(p);\n    if (iSphere.x < info.x) {\n        info = iSphere;\n    }\n    return info;\n}\n\nvec2 trace(vec3 ro, vec3 rd) {\n    float depth = 0.0;\n    float id = -1.0;\n    \n    for (int i = 0; i < 200; i++) {\n        vec2 info = map(ro + rd * depth);\n        if (info.x < 0.001) {\n            id = info.y;\n            break;\n        }\n        depth += info.x;\n    }\n    return vec2(depth, id);\n}\n\nconst float PI = 3.14159265359;\n\nfloat fac(int f) {\n    float val = 1.0;\n    for (int i = 2; i <= f; i++) {\n        val *= float(i);\n    }\n    return val;\n}\n\nfloat doublefac(int f) {\n    float val = 1.0;\n    while (f > 0) {\n        val *= float(f);\n        f -= 2;\n    }\n    return val;\n}\n\nfloat K(float l, float m) {\n    float lmmfac = fac(int(l) - abs(int(m)));\n    float lpmfac = fac(int(l) + abs(int(m)));\n    return sqrt((2.0 * l + 1.0) / (4.0 * PI) * (lmmfac / lpmfac));\n}\n\nfloat P(int l, int m, float x) {\n    float pmm = pow(-1.0, float(m)) * doublefac(int(2 * m - 1)) * pow(1.0 - x * x, float(m) / 2.0);\n    if (l == m) {\n        return pmm;\n    }\n    // otherwise lift ONE time \n    float pmmp1 = pmm * (2.0 * float(m) + 1.0) * x;\n    if (l == m + 1) {\n        return pmmp1;\n    }\n    // otherotherwise lift using rule 1\n    float pll = 0.0;\n    for (int ll = m + 2; ll <= l; ll++) {\n        pll = (x * (2.0 * float(ll) - 1.0) * pmmp1 - (float(ll) + float(m) - 1.0) * pmm) / (float(ll) - float(m));\n        pmm = pmmp1;\n        pmmp1 = pll;\n    }\n    return pll;\n}\n\nfloat sh(int l, int m, float theta, float phi) {\n    float shvalue = 0.0;\n    const float sqrt2 = sqrt(2.0);\n    if (m == 0) {\n        shvalue = K(float(l), 0.0) * P(l, 0, cos(theta));\n    } else if (m > 0) {\n        shvalue = sqrt2 * K(float(l), float(m)) * cos(float(m) * phi) * P(l, m, cos(theta));\n    } else if (m < 0) {\n        shvalue = sqrt2 * K(float(l), float(m)) * sin(-float(m) * phi) * P(l, -m, cos(theta));\n    }\n    \n    return shvalue;\n}\n\nvec3 shColor(vec3 p, int l, int m) {\n    vec3 local = normalize(vec3(p.x, p.y - 1.0, p.z));\n    float theta = acos(local.z);\n    float phi = 0.0;\n    if (1.0 - local.z * local.z > 0.0) {\n        float phi1 = acos(clamp(local.x / (sqrt(1.0 - local.z * local.z)), -1.0, 1.0));\n        float phi2 = 2.0 * PI - phi1;\n        float d1 = abs(sin(phi1) * sin(theta) - local.y);\n        float d2 = abs(sin(phi2) * sin(theta) - local.y);\n        phi = phi1;\n        if (d2 < d1) {\n            phi = phi2;\n        }\n    }\n    \n    float shvalue = sh(l, m, theta, phi) * 0.5 + 0.5;\n    vec3 neg = vec3(0.164, 0.337, 0.552);\n    vec3 pos = vec3(1.0, 0.941, 0.729);\n    \n    // uncomment this for a smooth ball\n    // return mix(neg, pos, shvalue);\n    \n    if (shvalue < 0.5) {\n        return neg;\n    }\n    return pos;\n}\n\nvec3 getColor(int id, vec3 pos, vec3 normal) {\n    vec3 ambient = vec3(0.0);\n    vec3 diffuse = vec3(0.0);\n    vec3 fresnel = vec3(0.0);\n    switch (id) {\n    case 0:\n        // tiled floor\n        vec2 fl = floor(pos.xz);\n        vec3 tileColor = vec3(1.0, 1.0, 1.0);\n        if (int(fl.x + fl.y) % 2 == 0) {\n            tileColor = vec3(0.8, 0.8, 0.8);\n        }\n        return vec3(tileColor);\n        \n    case 1:\n        ambient = 0.8 * vec3(1.0, 1.0, 1.0) * vec3(1.0, 0.5, 0.0);\n        diffuse = vec3(0.5, 0.5, 0.5) * vec3(1.0, 0.5, 0.0) * clamp(dot(vec3(0.0, 1.0, 0.0), normal), 0.0, 1.0);\n        return diffuse + ambient + fresnel;\n        \n    case 2:\n        ambient = 0.8 * vec3(1.0, 1.0, 1.0) * vec3(0.5, 1.0, 0.0);\n        diffuse = vec3(0.5, 0.5, 0.5) * vec3(0.5, 1.0, 0.0) * clamp(dot(vec3(0.0, 1.0, 0.0), normal), 0.0, 1.0);\n        return normal;\n        \n    case 3:\n        vec3 sC = shColor(pos, L, M);\n        ambient = 0.8 * vec3(1.0, 1.0, 1.0) * sC;\n        diffuse = vec3(0.5, 0.5, 0.5) * sC * clamp(dot(vec3(0.0, 1.0, 0.0), normal), 0.0, 1.0);\n        return ambient + diffuse + fresnel;\n    }\n}\n\nfloat epsilon = 0.001;\nvec3 getNormal(vec3 p) {\n    float x = map(p).x;\n    return normalize(vec3(x - map(vec3(p.x - epsilon, p.y, p.z)).x,\n        x - map(vec3(p.x, p.y - epsilon, p.z)).x,\n        x - map(vec3(p.x, p.y, p.z - epsilon)).x));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord.xy / iResolution.xy * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    // camera\n    vec3 center = vec3(0.0, 1.0, 0.0);\n    vec3 ro = vec3(3.0 * cos(iTime), 1.0, 3.0 * sin(iTime));\n    \n    vec3 front = normalize(center - ro);\n    vec3 right = cross(front, vec3(0.0, 1.0, 0.0));\n    vec3 up = cross(right, front);\n    \n    mat3 lookAt = mat3(right, up, front);\n    \n    vec3 rd = lookAt * vec3(uv, 1.0);\n    \n    vec2 info = trace(ro, rd);\n    vec3 pos = ro + rd * info.x;\n    vec3 color = getColor(int(info.y), pos, getNormal(pos));\n    \n    if (info.y < 0.0) {\n        // map sky \n        color = mix(vec3(0.89, 0.98, 1.0), vec3(0.58, 0.7, 0.9), clamp(uv.y, 0.0, 1.0));\n    }\n\n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}