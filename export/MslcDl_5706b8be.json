{"ver":"0.1","info":{"id":"MslcDl","date":"1490440859","viewed":202,"name":"Graph Plotter","username":"luluco250","description":"Plots the curve of a function onto a graph.","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["2d","graph","function","plot"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sXGzn","filepath":"/media/a/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3","previewfilepath":"/media/ap/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3","type":"music","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n\tGraph Plotter by luluco250\n\n\tPlots the curve of a function onto a graph.\n\n\tMIT Licensed:\n\tCopyright (c) 2017 Lucas Melo\n\n    Permission is hereby granted, free of charge, to any person obtaining a copy\n    of this software and associated documentation files (the \"Software\"), to deal\n    in the Software without restriction, including without limitation the rights\n    to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n    copies of the Software, and to permit persons to whom the Software is\n    furnished to do so, subject to the following conditions:\n\n    The above copyright notice and this permission notice shall be included in all\n    copies or substantial portions of the Software.\n\n    THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n    SOFTWARE.\n*/\n\n#define GRAPH_SCALE 0.3, 2.0\n#define GRAPH_OFFSET 0.05, 0.1\n#define LINE_SCALE 2\n#define LINE_COLOR 1.0, 0.0, 0.0\n#define GRID_SCALE 64\n#define CROSS_SCALE 2\n\n//This is the function that will be plotted on the graph\nfloat function(float x) {\n    float music_wave = texture(iChannel0, vec2(x)).x;\n    return music_wave;\n}\n\n/*float function(float x) {\n    vec2 mouse = iMouse.xy / iResolution.xy;\n    mouse -= vec2(GRAPH_OFFSET);\n    mouse.x -= 0.5;\n    mouse *= vec2(GRAPH_SCALE);\n    \n    mouse.x = (iMouse.z <= 0.0) ? sin(iTime) : mouse.x;\n    \n    return sin(x - mouse.x) * mouse.y;\n    //return sqrt(x);\n    //return sin(x);\n    //return cos(x);\n    //return atan(x);\n}*/\n\nbvec2 is_in_pixel(vec2, vec2, float);\nbvec2 checkers(vec2, float, float);\nvoid create_grid(inout vec3, vec2);\nvoid create_cross(inout vec3, vec2);\nvoid plot_graph(inout vec3, vec2, vec2);\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 col = vec3(1.0);\n\n    create_grid(col, uv);\n    create_cross(col, uv);\n    plot_graph(col, uv, vec2(GRAPH_SCALE));\n\n    fragColor = vec4(col, 1.0);\n}\n\nbvec2 is_in_pixel(vec2 target, vec2 uv, float size) {\n    vec2 ps = vec2(1.0) / iResolution.xy;\n    bool vert = (uv.x + ps.x * size > target.x) && (uv.x - ps.x * size < target.x);\n    bool hori = (uv.y + ps.y * size > target.y) && (uv.y - ps.y * size < target.y);\n    return bvec2(vert, hori);\n}\n\nbvec2 checkers(vec2 uv, float scale, float modulus) {\n    vec2 iuv = uv * iResolution.xy;\n    return bvec2(floor(mod(iuv / scale, modulus * scale)));\n}\n\nvoid create_grid(inout vec3 col, vec2 uv) {\n    bvec2 grid = checkers(uv - vec2(GRAPH_OFFSET), 1.0, float(GRID_SCALE));\n    col = !(grid.x && grid.y) ? vec3(0.1) : col;\n}\n\nvoid create_cross(inout vec3 col, vec2 uv) {\n    bvec2 line = is_in_pixel(vec2(GRAPH_OFFSET), uv, float(CROSS_SCALE));\n    col = line.x || line.y ? vec3(0.0) : col;\n}\n\nvoid plot_graph(inout vec3 col, vec2 uv, vec2 scale) {\n    uv -= vec2(GRAPH_OFFSET);\n    float x = uv.x * scale.x;\n    float y = function(x);\n    bvec2 line = is_in_pixel(vec2(x, y) / scale, uv, float(LINE_SCALE));\n    col = line.x && line.y ? vec3(LINE_COLOR) : col;\n}\n","name":"Image","description":"","type":"image"}]}