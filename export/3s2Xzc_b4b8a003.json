{"ver":"0.1","info":{"id":"3s2Xzc","date":"1554568527","viewed":361,"name":"Wireframe Tunnel Glow PointLight","username":"takumifukasawa","description":"Wireframe Tunnel Glow PointLight","likes":9,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","wireframe","rgb","csg","glow"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define EPS 0.0001\n#define PI 3.14159265359\n#define FLT_MAX 3.402823466e+38\n#define FLT_MIN 1.175494351e-38\n#define DBL_MAX 1.7976931348623158e+308\n#define DBL_MIN 2.2250738585072014e-308\n\nprecision highp float;\n\nconst int maxIterations = 128;\nconst float stepScale = 1.;\nconst float stopThreshold = .005;\n\nfloat fov = .6;\nfloat nearClip = 0.;\nfloat farClip = 80.;\nfloat speed = .8;\n\nstruct Light {\n  vec3 position;\n  float intensity;\n  vec3 color;\n  vec3 diffuse;\n  vec3 specular;\n  float attenuation;\n};\n    \nLight pointLightRed;\nLight pointLightGreen;\nLight pointLightBlue;\n    \nstruct Surface {\n  float dist;\n  vec3 position;\n  vec3 baseColor;\n  vec3 normal;\n  vec3 emissiveColor;\n};\n    \nstruct Hit {\n  Surface surface;\n  Surface near;\n};\n    \nfloat saturate(float s) {\n  return clamp(s, 0., 1.);\n}\n\nfloat distanceToLine(vec3 origin, vec3 dir, vec3 point) {\n\tvec3 pointToOrigin = point - origin;\n    float pointToOriginLength = length(pointToOrigin);\n    vec3 pointToOriginNorm = normalize(pointToOrigin);\n    float theta = dot(dir, pointToOriginNorm);\n    return pointToOriginLength * sqrt(1. - theta * theta);\n}\n\nfloat invert(float m) {\n  return 1.0 / m;\n}\n\nmat2 invert(mat2 m) {\n  return mat2(m[1][1],-m[0][1],\n             -m[1][0], m[0][0]) / (m[0][0]*m[1][1] - m[0][1]*m[1][0]);\n}\n\nmat3 invert(mat3 m) {\n  float a00 = m[0][0], a01 = m[0][1], a02 = m[0][2];\n  float a10 = m[1][0], a11 = m[1][1], a12 = m[1][2];\n  float a20 = m[2][0], a21 = m[2][1], a22 = m[2][2];\n\n  float b01 = a22 * a11 - a12 * a21;\n  float b11 = -a22 * a10 + a12 * a20;\n  float b21 = a21 * a10 - a11 * a20;\n\n  float det = a00 * b01 + a01 * b11 + a02 * b21;\n\n  return mat3(b01, (-a22 * a01 + a02 * a21), (a12 * a01 - a02 * a11),\n              b11, (a22 * a00 - a02 * a20), (-a12 * a00 + a02 * a10),\n              b21, (-a21 * a00 + a01 * a20), (a11 * a00 - a01 * a10)) / det;\n}\n\nmat4 invert(mat4 m) {\n  float\n      a00 = m[0][0], a01 = m[0][1], a02 = m[0][2], a03 = m[0][3],\n      a10 = m[1][0], a11 = m[1][1], a12 = m[1][2], a13 = m[1][3],\n      a20 = m[2][0], a21 = m[2][1], a22 = m[2][2], a23 = m[2][3],\n      a30 = m[3][0], a31 = m[3][1], a32 = m[3][2], a33 = m[3][3],\n\n      b00 = a00 * a11 - a01 * a10,\n      b01 = a00 * a12 - a02 * a10,\n      b02 = a00 * a13 - a03 * a10,\n      b03 = a01 * a12 - a02 * a11,\n      b04 = a01 * a13 - a03 * a11,\n      b05 = a02 * a13 - a03 * a12,\n      b06 = a20 * a31 - a21 * a30,\n      b07 = a20 * a32 - a22 * a30,\n      b08 = a20 * a33 - a23 * a30,\n      b09 = a21 * a32 - a22 * a31,\n      b10 = a21 * a33 - a23 * a31,\n      b11 = a22 * a33 - a23 * a32,\n\n      det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;\n\n  return mat4(\n      a11 * b11 - a12 * b10 + a13 * b09,\n      a02 * b10 - a01 * b11 - a03 * b09,\n      a31 * b05 - a32 * b04 + a33 * b03,\n      a22 * b04 - a21 * b05 - a23 * b03,\n      a12 * b08 - a10 * b11 - a13 * b07,\n      a00 * b11 - a02 * b08 + a03 * b07,\n      a32 * b02 - a30 * b05 - a33 * b01,\n      a20 * b05 - a22 * b02 + a23 * b01,\n      a10 * b10 - a11 * b08 + a13 * b06,\n      a01 * b08 - a00 * b10 - a03 * b06,\n      a30 * b04 - a31 * b02 + a33 * b00,\n      a21 * b02 - a20 * b04 - a23 * b00,\n      a11 * b07 - a10 * b09 - a12 * b06,\n      a00 * b09 - a01 * b07 + a02 * b06,\n      a31 * b01 - a30 * b03 - a32 * b00,\n      a20 * b03 - a21 * b01 + a22 * b00) / det;\n}\n\nmat4 scale(vec3 s) {\n  return invert(mat4(\n    s.x, 0., 0., 0.,\n    0., s.y, 0., 0.,\n    0., 0., s.z, 0.,\n    0., 0., 0., 1.\n  ));\n}\n\nmat4 rotateX(float angle) {\n  return invert(mat4(\n    1., 0., 0., 0.,\n    0., cos(angle), -sin(angle), 0.,\n    0., sin(angle), cos(angle), 0.,\n    0., 0., 0., 1.\n  ));\n}\n\nmat4 rotateY(float angle) {\n  return invert(mat4(\n    cos(angle), 0., sin(angle), 0.,\n    0., 1., 0., 0.,\n    -sin(angle), 0., cos(angle), 0.,\n    0., 0., 0., 1.\n  ));\n}\n\nmat4 rotateZ(float angle) {\n  return invert(mat4(\n    cos(angle), -sin(angle), 0., 0.,\n    sin(angle), cos(angle), 0., 0.,\n    0., 0., 1., 0.,\n    0., 0., 0., 1.\n  ));\n}\n\nmat4 translate(vec3 p) {\n  return invert(mat4(\n    1., 0., 0., p.x,\n    0., 1., 0., p.y,\n    0., 0., 1., p.z,\n    0., 0., 0., 1.\n  ));\n}\n\nfloat sphere(vec3 p, float size) {\n  return length(p) - size;\n}\n\nfloat box(vec3 p, vec3 size) {\n  vec3 d = abs(p) - size;\n  return length(max(d, 0.)) + min(max(d.x, max(d.y, d.z)), 0.);\n}\n\nfloat tube2(vec2 p, float size) {\n  return length(p) - size;\n}\n\nfloat box2(vec2 p, float size) {\n  return length(max(abs(p) - size, 0.));\n}\n\nfloat cylindar(vec3 p, vec3 c) {\n  return length(p.xz - c.xy) - c.z;\n}\n\nfloat displacement(vec3 p, vec3 power) {\n  return sin(power.x * p.x) * sin(power.y * p.y) * sin(power.z * p.z);\n}\n\nvec3 repeat(vec3 p, float c) {\n  return mod(p, c) - c * .5;\n}\n\nfloat smin(float a, float b, float k) {\n  float res = exp(-k * a) + exp(-k * b);\n  return -log(res) / k;\n}\n\nfloat scene(vec3 p) {\n  float c = 0.;\n    \n  vec3 _pt = repeat(\n    (vec4(p, 1.)\n       * translate(vec3(0., 0., mod(iTime, 1.5)))\n       * rotateZ(iTime / 8.)\n    ).xyz,\n    1.5\n  );\n  float t1 = tube2(_pt.xy, .1);\n  float t2 = tube2(_pt.yz, .1);\n  float t3 = tube2(_pt.xz, .1);\n    \n  c = smin(t1, t2, 16.);\n  c = smin(c, t3, 16.);\n    \n  return c;\n}\n\nfloat calcAO(vec3 p, vec3 n) {\n  float k = 1.;\n  float occ = 0.;\n  for(int i = 0; i < 5; i++) {\n    float len = .15 * (float(i) + 1.);\n    float distance = scene(n * len + p);\n    occ += (len - distance) * k;\n    k *= .5;\n  }\n  return clamp(1. - occ, 0., 1.);\n}\n\nvec3 getNormal(vec3 p) {\n  const float e = EPS;\n  return normalize(vec3(\n    scene(p + vec3(e,   0.0, 0.0)) - scene(p + vec3(-e,  0.0, 0.0)),\n    scene(p + vec3(0.0,   e, 0.0)) - scene(p + vec3(0.0,  -e, 0.0)),\n    scene(p + vec3(0.0, 0.0,   e)) - scene(p + vec3(0.0, 0.0,  -e))\n  ));\n}\n\nSurface near(Surface needle, Surface target) {\n  if(needle.dist < 0. || needle.dist < target.dist) {\n    return needle;\n  }\n  return target;\n}\n\nHit rayMarching(vec3 origin, vec3 dir, float start, float end) {\n  Surface cs;  // current surface\n  cs.dist = -1.;\n    \n  Surface ns; // near surface\n  ns.dist = FLT_MAX;\n    \n  Hit hit;\n\n  float sceneDist = 0.;\n  float rayDepth = start;\n\n  for(int i = 0; i < maxIterations; i++) {\n    sceneDist = scene(origin + dir * rayDepth);\n      \n    // cache near distance\n    if(sceneDist < ns.dist) {\n      ns.dist = sceneDist;\n    }\n\n    if((sceneDist < stopThreshold) || (rayDepth >= end)) {\n     break;\n    }\n    rayDepth += sceneDist * stepScale;\n    cs.dist = rayDepth;\n  }\n    \n  /*\n  if (sceneDist >= stopThreshold) {\n    rayDepth = end;\n  } else {\n    rayDepth += sceneDist;\n  }\n  */\n    \n  cs.dist = rayDepth;\n  hit.surface = cs;\n  hit.near = ns;\n\n  return hit;\n}\n\nfloat getSpecular(vec3 position, vec3 normal, Light light, float diffuse, vec3 cameraPos) {\n  vec3 lightDir = light.position - position;\n  vec3 ref = reflect(-normalize(lightDir), normal);\n  float specular = 0.;\n  if(diffuse > 0.) {\n    specular = max(0., dot(ref, normalize(cameraPos - normal)));\n    float specularPower = 32.;\n    specular = pow(specular, specularPower);\n  }\n  return specular;\n}\n\nvoid calcDirectionalLight(inout Light light, Surface surface, vec3 cameraPos) {\n  // diffuse\n  float diffuseCoef = max(0., dot(surface.normal, normalize(light.position)));\n  vec3 diffuse = diffuseCoef * light.attenuation * light.color * light.intensity;\n  // specular\n  float specularCoef = getSpecular(surface.position, surface.normal, light, diffuseCoef, cameraPos);\n  vec3 specular = vec3(specularCoef * light.attenuation * light.color * light.intensity);  \n\n  light.diffuse = diffuse;\n  light.specular = specular;\n}\n\nvoid calcPointLight(inout Light light, Surface surface, vec3 cameraPos) {\n  float d = distance(light.position, surface.position);\n  vec3 k = vec3(.06, .08, .09);\n  light.attenuation = 1. / (k.x + (k.y * d) + (k.z * d * d));\n\n  // point light\n  vec3 lightDir = light.position - surface.position;\n  // diffuse\n  float diffuseCoef = max(0., dot(surface.normal, normalize(lightDir)));\n  vec3 diffuse = diffuseCoef * light.color * light.intensity * light.attenuation;\n  // specular\n  float specularCoef = getSpecular(surface.position, surface.normal, light, diffuseCoef, cameraPos);\n  vec3 specular = vec3(specularCoef * light.attenuation * light.color * light.intensity); \n    \n  light.diffuse = diffuse;\n  light.specular = specular;\n}\n\nvec3 lighting(Surface surface, vec3 cameraPos) {\n  vec3 position = surface.position;\n\n  vec3 color = vec3(0.);\n  vec3 sceneColor = vec3(0.);\n  vec3 normal = surface.normal;\n\n  vec3 objColor = vec3(.1);\n  vec3 specularColor = vec3(.9);\n\n  Light directionalLight;\n  directionalLight.position = vec3(0., 0., 6.);\n  directionalLight.intensity = .1;\n  directionalLight.color = vec3(1., 1., 1.);\n  directionalLight.attenuation = 1.;\n  calcDirectionalLight(directionalLight, surface, cameraPos);\n\n  // update lights\n  float m = .5;    \n  pointLightRed.color = vec3(1., .1, .1);\n  pointLightRed.intensity = .1;\n  pointLightRed.position = vec3(cos(iTime * 1.6) * m, sin(iTime * 2.) * m, 0.);\n  calcPointLight(pointLightRed, surface, cameraPos);\n\n  pointLightGreen.color = vec3(.1, 1., .1);\n  pointLightGreen.intensity = .1;\n  pointLightGreen.position = vec3(cos(iTime * 2.) * m, sin(iTime * 1.8) * m, 0.);\n  calcPointLight(pointLightGreen, surface, cameraPos);\n\n  pointLightBlue.color = vec3(.1, .1, 1.);\n  pointLightBlue.intensity = .1;\n  pointLightBlue.position = vec3(cos(iTime * 1.8) * m, sin(iTime * 1.8) * m, 0.);            \n  calcPointLight(pointLightBlue, surface, cameraPos);  \n    \n  // ambient\n  Light ambientLight;\n  ambientLight.color = vec3(1., 1., 1.);\n  ambientLight.intensity = .2;\n  vec3 ambientColor = ambientLight.color * ambientLight.intensity * objColor;\n  float ao = calcAO(position, normal);\n  vec3 ambient = ambientColor * ao;\n\n  vec3 diffuse = \n    directionalLight.diffuse\n    + pointLightRed.diffuse\n    + pointLightGreen.diffuse\n    + pointLightBlue.diffuse;\n      \n  vec3 specular =\n    directionalLight.specular\n    + pointLightRed.specular\n    + pointLightGreen.specular\n    + pointLightBlue.specular;\n    \n  color += objColor * diffuse + specularColor * specular + ambient;\n  \n  return color;\n}\n\nvec3 emissiveLight(Light light, Surface surface, vec3 rayOrigin, vec3 rayDirection) {\n  vec3 eyeDirection = rayOrigin + rayDirection;\n  \n  float lightEmissive = pow(distanceToLine(eyeDirection, rayDirection, light.position) + .8, -7.5);\n\n  float c = dot(surface.normal, normalize(light.position - surface.position));\n  c = clamp(c, 0., 1.);\n  float em = 0.;\n\n  em = c + (1. - c) * step(farClip, surface.dist);\n\n  return lightEmissive * light.color * light.intensity * em;  \n}\n\nvec3 emissiveLighting(Surface surface, vec3 rayOrigin, vec3 rayDirection) {\n  vec3 eyeDirection = rayOrigin + rayDirection;\n  vec3 normal = surface.normal;\n\n  // adjust for emissive lighting\n  pointLightRed.intensity = 1.;    \n  pointLightGreen.intensity = 1.;    \n  pointLightBlue.intensity = 1.;    \n    \n  vec3 color = vec3(0.);\n  color += emissiveLight(pointLightRed, surface, rayOrigin, rayDirection);\n  color += emissiveLight(pointLightGreen, surface, rayOrigin, rayDirection);\n  color += emissiveLight(pointLightBlue, surface, rayOrigin, rayDirection);\n\n  return color;    \n}\n\nvec3 fog(vec3 color, float distance, vec3 fogColor, float b) {\n  float fogAmount = 1. - exp(-distance * b);\n  return mix(color, fogColor, fogAmount);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 aspect = vec2(iResolution.x / iResolution.y, 1.);\n  vec2 screenCoord = (2. * fragCoord.xy / iResolution.xy - 1.) * aspect;\n  vec2 mouse = iMouse.xy / iResolution.xy - .5;\n  \n  // camera settings\n  vec3 lookAt = vec3(cos(iTime * .4) * .2, sin(iTime * .6) * .2, 0.);\n  vec3 cameraPos = vec3(mouse.x * .5, mouse.y * .5, 2.);\n\n  // camera vectors\n  vec3 forward = normalize(lookAt - cameraPos);\n  vec3 right = normalize(cross(forward, vec3(0., 1., 0.)));\n  vec3 up = normalize(cross(right, forward));        \n    \n  // raymarch\n  vec3 rayOrigin = cameraPos;\n  vec3 rayDirection = normalize(forward + fov * screenCoord.x * right + fov * screenCoord.y * up);\n  Hit hit = rayMarching(rayOrigin, rayDirection, nearClip, farClip);\n  Surface surface = hit.surface;\n  Surface near = hit.near;\n\n  surface.position = rayOrigin + rayDirection * surface.dist;\n    \n  // color\n  vec3 sceneColor = vec3(0.);\n\n  surface.normal = getNormal(surface.position);    \n    \n  // no hit or too far\n  if(surface.dist >= farClip) {\n    vec3 bgColor = vec3(0.);\n    sceneColor = bgColor;\n  } else {\n    sceneColor += lighting(surface, cameraPos);\n  }\n\n  // emissive lighting (not surface lighting)\n  sceneColor += emissiveLighting(surface, rayOrigin, rayDirection);\n    \n  sceneColor = fog(sceneColor, surface.dist, vec3(0.), .08);\n\n  fragColor = vec4(sceneColor, 1.);\n}\n","name":"Image","description":"","type":"image"}]}