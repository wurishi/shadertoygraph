{"ver":"0.1","info":{"id":"wdXcR7","date":"1584385626","viewed":278,"name":"Exploring Mandelbrot","username":"solquemal","description":"Experimental use of distance estimator to render fractals","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["fractal"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 bump3 (vec3 x) {\n    vec3 y = vec3(1.,1.,1.) - x * x;\n    y = max(y, vec3(0.,0.,0.));\n    return y;\n}\n\nvec3 spectralGems (float x) {\n    return bump3\n    (   vec3\n        (\n            4. * (x - 0.7), // Red\n            4. * (x - 0.5), // Green\n            4. * (x - 0.23) // Blue\n        )\n    );\n}\n\n\nvec2 distanceEstimatorPot3(vec2 c) {\n\tvec2 z = vec2(0.);\n    vec2 dz = vec2(0.); \n\n    float m2 = 0.;\n    float dis = 1000.;\n    \n   \n    for( int i=0; i<300; i++ )\n    {\n        if( m2 > 1024.0) {  break;}\n        float dzX= 3.*(z.x*z.x-z.y*z.y)*dz.x-(6.*z.x*z.y)*dz.y;\n        float dzY = (6.*z.x*z.y)*dz.x + 3.*(z.x*z.x-z.y*z.y)*dz.y;\n\n        dz = vec2(dzX,dzY)+ vec2(1.);\n\n        z = vec2( pow(z.x,3.) - 3.*z.y*z.y*z.x,3.0*z.x*z.x*z.y-pow(z.y,3.) ) + c;\n \n        m2 = dot(z,z);  \n    }\n    return vec2(sqrt( m2/dot(dz,dz) )*log(m2),m2);\n\n    \n}\n\nvec2 distanceEstimatorJulia(vec2 c) {\n    vec2 z = vec2(1.);\n    vec2 dz = vec2(0.); \n\n    float m2 = 0.;\n    float dis = 1000.;\n    \n   \n    for( int i=0; i<300; i++ )\n    {\n        if( m2 > 1024.0) {  break;}\n\n        dz = 2.0*vec2(z.x*dz.x-z.y*dz.y, z.x*dz.y + z.y*dz.x);\n\n        z = vec2( z.x*z.x - z.y*z.y, 2.0*z.x*z.y ) + c;\n \n\n        m2 = dot(z,z);  \n    }\n    return vec2(sqrt( m2/dot(dz,dz) )*0.5*log(m2),m2);\n}\n\nvec2 distanceEstimatorMandelbrot(vec2 c) {\n    vec2 z = vec2(0.);\n    vec2 dz = vec2(0.); \n\n    float m2 = 0.;\n    float dis = 1000.;\n    \n   \n    for( int i=0; i<300; i++ )\n    {\n        if( m2 > 1000.0) {  break; }\n\n        dz = 2.0*vec2(z.x*dz.x-z.y*dz.y, z.x*dz.y + z.y*dz.x) + vec2(1.);\n\n        z = vec2( z.x*z.x - z.y*z.y, 2.0*z.x*z.y ) + c;\n \n\n        m2 = dot(z,z);  \n    }\n    return vec2(sqrt( m2/dot(dz,dz) )*log(m2),m2);\n}\n\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 st = fragCoord.xy/iResolution.xy;\n    st.x *= iResolution.x/iResolution.y;\n    st = st*2.7-vec2(2.5,1.3);\n  \t//st.x +=cos(iTime*0.1)*0.5;\n\t//st.y +=sin(iTime*0.1)*0.5;\n    \n    // ZOOM in\n\tst *= pow( 0.7, 5.0 + 13.*(1.+cos(0.0425*iTime)));\n    //st = st*pow(0.4,12. *abs(sin(iTime*0.0270)))+vec2(-0.18,.8289);\n    st += vec2(-0.4256621,0.576550);\n    \n    vec2 f =  distanceEstimatorMandelbrot(st);      //f(z) = z ^ 2 + k\n    vec2 f2 =  distanceEstimatorPot3(st);      //f(z) = z ^ 3 + k\n  \n    vec3 col;\n    float d1 =f.x;\n    float d2 =f2.x;\n    \n    d1 = clamp( pow(4.0*d1,0.0998),0., 1.);\n    d2 = clamp( pow(4.0*d2,0.128),0.,1.);\n   /// col = spectralGems(max(0.2,abs(sin(Time*0.051)))-d/2.);\n  \n    col = spectralGems((1.-d1)*1.15);\n    col += spectralGems(d2*1.96);\n  \n    //Trying to colorize equipotential lines. Change the escaping radius limit, and transformation over f.y// Observe.\n  \t//col = spectralGems((f.y - 1000.)/9500.);\n    \n    // Nice first color-map\n    //col += f.y/1000.;\n  \n    //Combinig both versions\n     //col += vec3(1.-d);\n    \n   \t//col=vec3(f.y);\n  \n    fragColor = vec4(col,1.);\n\n}","name":"Image","description":"","type":"image"}]}