{"ver":"0.1","info":{"id":"3ssGWr","date":"1559779901","viewed":511,"name":"Circle Fitting 2","username":"BigWIngs","description":"Another attempt at fitting circle arcs into a spline","likes":18,"published":1,"flags":0,"usePreview":0,"tags":["circle","spline","arc","fitting"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Circle Fitting 2 by Martijn Steinrucken aka BigWings - 2019\n// countfrolic@gmail.com  Twitter: @The_ArtOfCode\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n// This is an old doodle I had lying around. It is my attempt to come up with some sort of spline by\n// fitting arcs together. You can move the mouse to see the thing in action.\n// I figure that a reliable way to connect two arbitrary points with two arbitrary tangents by using\n// circle arcs would be very useful for many applications.\n// Perhaps the community can build on this, so I figured I'd make it public.\n\n#define S(a,b,t) smoothstep(a,b,t)\n\nfloat circ(vec2 uv, vec2 p, float r) {\n\treturn S(r, r*.9, length(uv-p));\n}\n\nfloat circ2(vec2 uv, vec2 p, float r, float w) {\n\treturn S(w, w*.5, abs(length(uv-p)-r));\n}\n\nfloat circ3(vec2 p, vec2 c, vec2 a, vec2 b, float w) {\n\tvec2 ca=a-c, pa=a-p, cb=b-c, cp=p-c, ba=a-b;\n    \n    float r = length(ca);\n    \n    float circle = S(w, w*.5, abs(length(cp)-r));\n    cp = vec2(-cp.y, cp.x);\n    float maskA = step(dot(ca, cp),0.);\n    float maskB = step(0., dot(cb, cp));\n    \n    float mask = 0.;\n    \n    float s = step(0., dot(ba, vec2(-ca.y, ca.x)));\n    if(s>0.) \n        mask = min(1., maskA+maskB);\n    else\n        mask = maskA*maskB;\n    \n    return circle*mask;\n}\n\n\nfloat linedist(vec2 p, vec2 a, vec2 b) {\n    vec2 pa = p - a, ba = b - a;\n    float paba = dot(pa,ba);\n\tfloat h = paba / dot(ba,ba);\t\n\treturn length(pa - ba * h);\n}\n\nfloat lineseg(vec2 p, vec2 a, vec2 b,  float w) {\n    \n    vec2 pa = p - a, ba = b - a;\n\tfloat h = clamp(dot(pa,ba) / dot(ba,ba), 0., 1.);\t\n\tfloat d = length(pa - ba * h);\n\n    return S(w, w*.8, d);\n}\n\nvec2 LineIntersect(vec2 a, vec2 b, vec2 c, vec2 d) {\n    float e = (b.x-a.x)*(d.y-c.y)-(b.y-a.y)*(d.x-c.x);\n    float r = ((a.y-c.y)*(d.x-c.x)-(a.x-c.x)*(d.y-c.y)) / e;\n    return a+r*(b-a);\n}\n\n\nfloat arc(vec2 p, vec2 a, vec2 b, float dist, float w) {\n\tvec2 M = (iMouse.xy-.5*iResolution.xy)/iResolution.y;\n    \n    vec2 ab = b-a;\n    vec2 mid = (a+b)*.5;\n    vec2 c = mid - normalize(vec2(-ab.y, ab.x))*dist;\n    \n    vec2 ca = a-c;\n    vec2 cmid = mid-c;\n    vec2 cp = p-c;\n    \n    float t = dot(cmid, cp)/dot(cmid,cmid);\n    \n    vec2 s = c + (mid-c)*t;\n    float r = length(ca);\n    \n    float d = length(cp);\n    float cd = abs(d-r);\n    float m = smoothstep(w, w*.5, cd);\n    \n    float dd = length(s-p);\n    \n    m += circ(p, c, .01);\n    m += circ(p, a, .01);\n    m += circ(p, b, .01);\n\n    w = t*length(ab)*.5;\n    float sd = (w-dd)*length(cmid);\n    \n    float mask = step(0., sd);\n   \n    float da = length(a-p.xy);\n    float db = length(b-p.xy);\n    float dab = min(da, db);\n\n    return mix(dab, cd, mask);\n}\n\nfloat arcDist(vec2 uv) {\n    vec2 A = vec2(-.6, 0);\n    vec2 B = vec2(.0, -.4);\n    vec2 C = vec2(.7, .0);\n    \n    vec2 M = (iMouse.xy-.5*iResolution.xy)/iResolution.y;\n    \n    \n    return arc(uv, A, M, .5*sin(iTime),.03);\n}\n\nfloat arcseg(vec2 p, vec2 a, vec2 b, vec2 c, vec2 d, float w ) {\n\tvec2 M = (iMouse.xy-.5*iResolution.xy)/iResolution.y;\n    \n    vec2 ab = b-a,\n        bc = c-b,\n        cd = d-c,\n        ba = normalize(vec2(-ab.y, ab.x)),\n        dc = normalize(vec2(-cd.y, cd.x));\n    \n    float flip = 1.;\n    ba *= flip;\n    dc *= -flip;\n    \n    vec2 k = b-c, z = ba-dc;\n    \n    float A = dot(k, k);\n    float B = dot(k, z);\n    float C = dot(z, z);\n    \n\tfloat r = (sqrt(-A*C + 4.*A + B*B)+B) / (4.-C);\n    \n    vec2 centerRed = b+ba*r;\n    vec2 centerGreen = c+dc*r;\n    vec2 center = (centerRed+centerGreen)/2.;\n    \n    float m = 0.;\n    m += circ(p, centerRed, .003);   \n    m += circ(p, centerGreen, .003);\n    m += circ(p, center, .006);\n \n    float circRed = circ2(p, centerRed, abs(r),.003);\n    float circGreen = circ2(p, centerGreen, abs(r),.003);\n    \n    m += circ3(p, centerRed, b, center, .002);\n    m += circ3(p, centerGreen, c, center, .002);\n    return m;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\tvec2 M = (iMouse.xy-.5*iResolution.xy)/iResolution.y;\n    float aspect = iResolution.x/iResolution.y;\n    \n    vec3 col = vec3(0);\n    float t = iTime;\n    \n    vec2 B = sin(t*vec2(.234,.765))*.0;\n   \tvec2 A = B + vec2(sin(t), cos(t))*.2;\n   \n    float start = S(.01,.005,length(uv-A));\n    start += S(.02,.01,length(uv-B));\n    start += lineseg(uv, A, B, .005);\n    col += start*vec3(1,0,0);\n    \n    vec2 C = vec2(-1., 0)*.45;\n   \tvec2 D = C + normalize(M-C)*.2;\n   \n    float end = S(.01,.005,length(uv-D));\n    end += S(.02,.01,length(uv-C));\n    end += lineseg(uv, C, D, .005);\n    col += end*vec3(0,1,0);\n    \n    col += lineseg(uv, B, C, .002)*.3;\n    col += arcseg(uv, A, B, C, D, .01);\n    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}