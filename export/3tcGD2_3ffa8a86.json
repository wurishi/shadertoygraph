{"ver":"0.1","info":{"id":"3tcGD2","date":"1577551562","viewed":228,"name":"Ball Pit","username":"petermcneeley","description":"Rendering an simulation of thousands of stateful objects.\nScatter writes cannot be done in this framerwork so here we emulate them by a gather inversion.\nBased loosely on: https://www.shadertoy.com/view/XdtSRn and https://www.shadertoy.com/view/4dG3RW\n\n\n","likes":5,"published":1,"flags":32,"usePreview":0,"tags":["raymarch","simulation","physics","scatter"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":3,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n\nfloat getRealTime()\n{\n    return FIXED_TIMESTEP * float(iFrame);\n}\n\nvoid doCamera( out vec3 camPos, out vec3 camTar, in float time, in float mouseX )\n{\n    float an = getRealTime() * 0.1;\n    vec3 cent = vec3(NUM_DIM_X, 40 -10, NUM_DIM_Z)/2.0;\n    camPos = cent  + vec3(cos(an),0.1,sin(an))*float(NUM_DIM_Z)*2.5;\n    camTar = cent;\n}\n\nmat3 calcLookAtMatrix( in vec3 ro, in vec3 ta, in float roll )\n{\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(sin(roll),cos(roll),0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    return mat3( uu, vv, ww );\n}\n\n\nvec4 getParticlePosR(int partIndex)\n{\n    ivec2 uvi =  indexToTexel(partIndex, iChannelResolution[2].xy);\n    return texelFetch(iChannel2, uvi, 0);\n}\n\nvec3 sphereSizeToColor(float sizeSphere)\n{\n    if(sizeSphere==0.0)\n    {\n       return vec3(0.0,0.0,0.0);\n    } \n    else if(sizeSphere <= 0.32)\n    {\n        return vec3(1.0,0.6,0.6);\n    }\n    else if( sizeSphere <= 0.4)\n    {\n        return vec3(0.6,1.0,0.6);\n    }\n    else\n    {\n        return vec3(0.6,0.6,1.0);\n    }\n \n}\n\n\nfloat traceAgainstCell(ivec4 cellPos, vec3 rayDir, vec3 rayOrigin, ivec3 delw, out ivec4  cellSlot, float ret)\n{\n    ivec3 wp = cellPos.xyz + delw;\n    if(isCellInsideVolume( wp) )\n    {\n        for(int slotCnt = 0; slotCnt < NUM_SLOTS; slotCnt++)\n        {\n            int slotIndex = slotToIndex(wp, slotCnt);\n            vec4 posr = getParticlePosR(slotIndex);\n            if(posr.w == 0.0)\n            {\n               break; // empty skip remaining slots\n            }\n            else\n            {\n                vec4 sphere = posr;\n                float sect = sphereRayIntersection(sphere, rayDir, rayOrigin);\n                if(sect > 0.0)\n                {\n                    if( sect < ret)\n                    {\n                        cellSlot.xyz = wp;\n                        cellSlot.w = slotCnt;\n                        ret = sect;\n                    }\n                }\n            }\n        }\n\n    }\n    \n    return ret;\n}\n\n\nfloat traceAgainstMultiCell(ivec4 cellPos, vec3 rayDir, vec3 rayOrigin, out ivec4 cellSlot)\n{\n \tfloat ret = 100000.0;\n    cellSlot = ivec4(-1,-1,-1,-1);\n    for(int x = -1; x <= 1; x++)\n    {\n        for(int y = -1; y <= 1; y++)\n    \t{\n          \tfor(int z = -1; z <= 1; z++)\n    \t\t{\n        \t\tret =  traceAgainstCell(cellPos, rayDir, rayOrigin, ivec3( x,y,z), cellSlot, ret);\n    \t\t}\n    \t}\n    }\n       \n    if( ret > 10000.0)\n        ret = -1.0f;\n    \n    \n    return ret;\n}\n\nbool isNearVolume(vec3 testPos)\n{\n \tvec4 asSphere = vec4(testPos.x, testPos.y, testPos.z, -1.5); // neg so its larger not smaller\n    \n    return (asSphere == confineSphereToSimBox(asSphere));\n}\n\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    \n    vec2 p = (-iResolution.xy + 2.0*fragCoord.xy)/iResolution.y;\n    vec2 m = iMouse.xy/iResolution.xy;\n\n    // code from  https://www.shadertoy.com/view/XdtSRn\n    //-----------------------------------------------------\n    // camera\n    //-----------------------------------------------------\n    \n    // camera movement\n    vec3 ro, ta;\n    doCamera( ro, ta, iTime, m.x );\n    //doCamera( ro, ta, 3.0, 0.0 );\n\n    // camera matrix\n    mat3 camMat = calcLookAtMatrix( ro, ta, 0.0 );  // 0.0 is the camera roll\n    \n\t// create view ray\n\tvec3 rd = normalize( camMat * vec3(p.xy,2.0) ); // 2.0 is the lens length\n\n    // Very lazy raymarching\n    // this is highly unoptimal and probably could be made 2x\n    float dist = 10000.0;\n    ivec4 cellSlot= ivec4(-1,-1,-1,-1);\n    for(float x = RAY_DIST_START; x < RAY_DIST_END; x+=2.5)\n    {\n        vec3 worldPos = ro + rd *x;\n        if(! isNearVolume(worldPos))\n        {\n            continue;\n        }\n\n        ivec4 cellPos = worldPosToCell( worldPos);\n        float sect = traceAgainstMultiCell(cellPos, rd, ro, cellSlot);\n        if( sect > 0.0)\n        {\n            dist = sect;\n            break;  \t\n        }   \n    }\n\n    \n    if(cellSlot.w == -1 || dist == 10000.0)\n    {\n        fragColor = vec4(1.0,1.0,1.0,1.0);\n    }\n    else\n    {\n        int slotIndex = slotToIndex(cellSlot.xyz, cellSlot.w);\n        vec4 posr = getParticlePosR(slotIndex);\n\n        vec3 surfacePoint = ro + rd * dist;\n        vec3 normAtSurace = normalize( surfacePoint - posr.xyz);\n        ivec4 surfaceCellSlot = worldPosToCell(surfacePoint);\n\t\tfloat aoSum = 0.0;\n        // neigh search for Ambient Occlusion\n        for(int x = -AO_QUALITY; x <=AO_QUALITY; x++)\n        {\n            for(int y = -AO_QUALITY; y <=AO_QUALITY; y++)\n            {\n                for(int z = -AO_QUALITY; z <=AO_QUALITY; z++)\n                {\n                    ivec3 testCell = cellSlot.xyz + ivec3(x, y, z);\n                    if(isCellInsideVolume( testCell ))\n                    {\n                        for(int sloti = 0 ; sloti < NUM_SLOTS;sloti++)\n                        {\n                            int neighIndex = slotToIndex(testCell.xyz, sloti);\n\n                            vec4 neighposr =  getParticlePosR( neighIndex);\n                            if(neighposr.w == 0.0)\n                            {\n                               break;\n                            }\n                            else if( neighIndex == slotIndex)\n                            {\n                                continue; // self\n                            }\n                            else\n                            {\n                                vec3 vecToCont = neighposr.xyz - surfacePoint;\n                      \n                                float asScaleFactor =  0.11* neighposr.w / pow(length(vecToCont), 2.8);\n                                   \n                                aoSum += max(dot(normalize(neighposr.xyz- surfacePoint), normAtSurace),0.0)\n                                    * asScaleFactor;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        \n        float outDim = 0.88 +  max(0.0, dot(-rd, normAtSurace)) *.12;\n        \n        // Output to screen\n        vec3 col = sphereSizeToColor(posr.w) *  sqrt((1.0-aoSum) * outDim);\n    \tfragColor = vec4(col.x,col.y, col.z ,1.0);\n    }\n    \n    \n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// update particle position here\n// need to check for push of wall and sphere\n// at the end of this our position will change and we could be in a new cell\n\n\nbool hasInit()\n{\n    ivec2 uvi =  indexToTexel(0, iChannelResolution[3].xy);\n    return texelFetch(iChannel3, uvi, 0).x == 1.0;\n}\n\n\nvec4 getParticlePosR(int partIndex)\n{\n    ivec2 uvi =  indexToTexel(partIndex, iChannelResolution[2].xy);\n    return texelFetch(iChannel2, uvi, 0);\n}\n\nvec4 getParticleVelq(int partIndex)\n{\n    ivec2 uvi =  indexToTexel(partIndex, iChannelResolution[1].xy);\n    return texelFetch(iChannel1, uvi, 0);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  \n    int index = texelToIndex(fragCoord, iChannelResolution[1].xy);\n    \n    if(!indexInCellSlotRange(index))\n    {\n        fragColor = vec4(0,0,0,0);\n        return;\n    }\n    \n    vec4 posr = getParticlePosR( index);\n    vec4 velq = getParticleVelq( index);\n    ivec4 cellSlot = indexToSlot(index);\n    \n    if(!hasInit())\n    {\n        // init cells with random spheres\n       \tif(  cellSlot.w == 0 && cellSlot.y >= 5  && cellSlot.z <10)\n        {\n            vec4 rnd  = getRnd(fragCoord);\n            vec3 initPos = vec3(cellSlot.xyz) + vec3(0.5,0.5,0.5) + rnd.xyz*.2;\n            fragColor = vec4(initPos.x, initPos.y, initPos.z, rnd.z *0.15 + 0.3);\n        }\n        else\n        {\n            fragColor = vec4(0,0,0,0);\n        }\n    }\n    else if( posr.w == 0.0) \n    {\n        fragColor = posr; // zero radius non sphere indicates\n    }\n    else\n    {   \n        posr.xyz = posr.xyz + velq.xyz * FIXED_TIMESTEP;\n        vec3 posNew = posr.xyz;\n        // neighbor search to find sphere intersections\n        for(int x = -1; x <=1; x++)\n        {\n            for(int y = -1; y <=1; y++)\n            {\n                for(int z = -1; z <=1; z++)\n                {\n                    ivec3 testCell = cellSlot.xyz + ivec3(x, y, z);\n                    if(isCellInsideVolume( testCell ))\n                    {\n                        for(int sloti = 0 ; sloti < NUM_SLOTS;sloti++)\n                        {\n                            int slotIndex = slotToIndex(testCell.xyz, sloti);\n\n                            vec4 contposr =  getParticlePosR( slotIndex);\n                            // project other contact sphere location via velocity assumption\n                            contposr.xyz = contposr.xyz + velq.xyz * FIXED_TIMESTEP;\n                            if(posr.w == 0.0)\n                            {\n                                break;\n                            }\n                            else if( index == slotIndex)\n                            {\n                                continue;\n                            }\n                            else\n                            {\n                                vec3 vecToCont = contposr.xyz - posr.xyz;\n                                float sphereLength = contposr.w + posr.w;\n                                if( sphereLength > length(vecToCont))\n                                {\n                                    // push sphere to proper location\n                                    // this has an iterative solver like effect on simuation\n                                    posNew = posNew -\n                                        (sphereLength - length(vecToCont)) * normalize(vecToCont) *0.47;\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }   \n        \n        posr.xyz = posNew;\n        // this clip to box can have the effect of having \n        // the volume have zero reflectance (absorbs all incident motion)\n        posr = confineSphereToSimBox( posr);\n        fragColor = posr;\n    }\n    \n    \n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// update particle velocity here\n// need to check for push of wall and sphere\n// at the end of this our position will change and we could be in a new cell\n\n\nfloat getRealTime()\n{\n    return FIXED_TIMESTEP * float(iFrame);\n}\n\n\nbool hasInit()\n{\n    ivec2 uvi =  indexToTexel(0, iChannelResolution[3].xy);\n    return texelFetch(iChannel3, uvi, 0).x == 1.0;\n}\n\nvec4 getParticlePosR(int partIndex)\n{\n    ivec2 uvi =  indexToTexel(partIndex, iChannelResolution[0].xy);\n    return texelFetch(iChannel0, uvi, 0);\n}\n\nvec4 getParticlePosR_prev(int partIndex)\n{\n    ivec2 uvi =  indexToTexel(partIndex, iChannelResolution[2].xy);\n    return texelFetch(iChannel2, uvi, 0);\n}\n\nvec4 getParticleVelq(int partIndex)\n{\n    ivec2 uvi =  indexToTexel(partIndex, iChannelResolution[1].xy);\n    return texelFetch(iChannel1, uvi, 0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  \n    int index = texelToIndex(fragCoord, iChannelResolution[1].xy);\n    \n    if(!indexInCellSlotRange(index))\n    {\n        fragColor = vec4(0,0,0,0);\n        return;\n    }      \n\t\n\n    \n    if(!hasInit())\n    {\n        vec4 posr = getParticlePosR( index);\n        if( posr.w != 0.0)\n        {\n            // init random velocity for all real spheres\n            fragColor = (getRnd(fragCoord)-vec4(0.5,0.5,0.5,0)) ;\n            fragColor.w = 0.0;\n        }\n        else\n        {\n            // not a sphere. empty slot\n            fragColor = vec4(0,0,0,0);\n        }\n    }\n\telse\n    {\n        int slotCnt = 0;\n\t\tivec4 cellSlot = indexToSlot(index);\n        fragColor = vec4(0,0,0,0);\n\t\t    \n    \tivec4 targetCellSlot = ivec4(-1,-1,-1,-1);\n    \t// This slot counting technique finds \n        // the particle for which this current fragCoord should output\n        \n        // since we cannot coordinate across threads we have to\n        // do the work of the other in a local coordinated effort\n        for(int x = -1; x <=1; x++)\n        {\n            for(int y = -1; y <=1; y++)\n            {\n                for(int z = -1; z <=1; z++)\n                {\n                    ivec3 testCell = cellSlot.xyz + ivec3(x, y, z);\n                    if(isCellInsideVolume( testCell ))\n                    {\n                        for(int sloti = 0 ; sloti < NUM_SLOTS;sloti++)\n                        {\n                            int slotIndex = slotToIndex(testCell.xyz, sloti);\n\n                            vec4 posr =  getParticlePosR( slotIndex);\n                            if(posr.w == 0.0)\n                            {\n                                break;\n                            }\n                            else\n                            {\n                                if(isParticleInside(posr.xyz, cellSlot.xyz))\n                                {\n                                    if(cellSlot.w == slotCnt)\n                                    {\n                                        targetCellSlot = ivec4(testCell.x, testCell.y, testCell.z, sloti);  \n                                    }\n                                    slotCnt++;\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }   \n        \n        // this cellSlot will write out to this this fragCoord\n        if( targetCellSlot.w != -1)\n        {\n             \n            int realSlotIndex = slotToIndex(targetCellSlot.xyz, targetCellSlot.w);\n            vec4 velq = getParticleVelq(realSlotIndex); \n            vec4 posr = getParticlePosR(realSlotIndex);\n  \n            \n            vec4 prevposr = getParticlePosR_prev(realSlotIndex);\n            vec4 currposr = getParticlePosR(realSlotIndex);\n            velq.xyz = ( currposr.xyz - prevposr.xyz) / FIXED_TIMESTEP; // dx/dt\n            \n            for(int x = -1; x <=1; x++)\n            {\n                for(int y = -1; y <=1; y++)\n                {\n                    for(int z = -1; z <=1; z++)\n                    {\n                        ivec3 testCell = cellSlot.xyz + ivec3(x, y, z);\n                        if(isCellInsideVolume( testCell ))\n                        {\n                            for(int sloti = 0 ; sloti < NUM_SLOTS;sloti++)\n                            {\n                                int slotIndex = slotToIndex(testCell.xyz, sloti);\n\n                                vec4 contposr =  getParticlePosR_prev( slotIndex);\n                                vec4 contvelq = getParticleVelq( slotIndex);  \n                                if(posr.w == 0.0)\n                                {\n                                    break;\n                                }\n                                else if( realSlotIndex == slotIndex)\n                                {\n                                    continue;\n                                }\n                                else\n                                {\n                                    vec3 vecToCont = contposr.xyz - posr.xyz;\n                                    vec3 normToCont = normalize(vecToCont);\n                                    float sphereLength = contposr.w + posr.w;\n                                    if( sphereLength > length(vecToCont))\n                                    {\n                                        vec3 relVel = velq.xyz - contvelq.xyz;\n                                        float normRelVel = dot(normToCont,relVel);\n                                        // simple velocity smoothing via averaging\n                                        if( normRelVel > 0.0)\n                                        { \n                                       \t\tvelq.xyz = velq.xyz*0.95  +  contvelq.xyz*.05f;\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }   \n\n          \n\n            \n            velq.y = velq.y - GRAVITY * FIXED_TIMESTEP ;\n#if DEMO_SLANTED\n            if(getRealTime() > 13.0)\n            {\n            \tvelq.x = velq.x - GRAVITY * FIXED_TIMESTEP * sign(.5 -mod(getRealTime()*.03,1.0));\n            }\n#endif\n            \n            if(length(velq.xyz) > MAX_SPEED)\n            {\n                velq.xyz = normalize(velq.xyz) * MAX_SPEED;\n            }\n                \n            fragColor = velq;\n        }\n    }\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"\n// 3d cell update here\n// search neighbor cells for new particles for tracking\n\nvec4 getParticlePosR(int partIndex)\n{\n    ivec2 uvi =  indexToTexel(partIndex, iChannelResolution[0].xy);\n    return texelFetch(iChannel0, uvi, 0);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0,0,0,0);\n    int index = texelToIndex(fragCoord, iChannelResolution[0].xy );\n    if(!indexInCellSlotRange(index))\n    {\n        \n        return;\n    }\n    \n    ivec4 cellSlot = indexToSlot(index);\n    int slotCnt = 0;\n    // scatter via gather inversion\n    for(int x = -1; x <=1; x++)\n    {\n        for(int y = -1; y <=1; y++)\n    \t{\n            for(int z = -1; z <=1; z++)\n            {\n                ivec3 testCell = cellSlot.xyz + ivec3(x, y, z);\n                if(isCellInsideVolume( testCell ))\n                {\n                    for(int sloti = 0 ; sloti < NUM_SLOTS;sloti++)\n                    {\n                      \tint slotIndex = slotToIndex(testCell.xyz, sloti);\n                        \n                        vec4 posr =  getParticlePosR( slotIndex);\n                        if(posr.w == 0.0)\n                        {\n                           break;\n                        }\n                        else\n                        {\n                            if(isParticleInside(posr.xyz, cellSlot.xyz))\n                            {\n                                if(cellSlot.w == slotCnt)\n                                {\n                          \n        \t\t\t\t\t\t\tvec4 posr =  getParticlePosR( slotIndex);\n        \t\t\t\t\t\t\tfragColor = posr;\n                                    return;\n                                }\n                                slotCnt++;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    } \n}","name":"Buffer C","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"\nvec4 initData()\n{\n    ivec2 uvi =  indexToTexel(0, iChannelResolution[3].xy);\n    return texelFetch(iChannel3, uvi, 0) ;\n}\n\nvec4 initDataHash(float resetValue)\n{\n    return vec4(resetValue,\n                iChannelResolution[3].x* iChannelResolution[3].y,\n                NUM_DIM_X * NUM_DIM_Y * NUM_DIM_Z,\n                0.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    if(texelToIndex(fragCoord, iChannelResolution[3].xy) == 0)\n    {  \n        vec4 initCurr = initData();\n    \tif(initCurr != initDataHash(1.0f))\n        {\n            if( initCurr.x == 0.0)\n            {\n            \tinitCurr = initDataHash(1.0);\n            }\n            else\n            {\n                initCurr = initDataHash(0.0);// reset for res\n            }\n        }\n    \n   \t\tfragColor = initCurr; \n    }\n    else\n    {\n       discard;\n    }\n\n}","name":"Buffer D","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"\n// There is not much to this demo aside from the techniques \n// used to get around the limitations of the framework\n\n\n// Features:\n// - spatial partion cells hold slots for spheres. There is no limit on number of spheres in one cell.\n// - sphere speed and scale is limited by cell size\n// - updates use a reverse gather technique to scatter spheres to cells\n// - render is marched through cells. This is not highly optimized.\n// - Ambient occlusion gives shape and contact. This is approximate AO.\n// - stable simuation via velocity construction in verlet step\n\n// so spheres slosh back and forth\n#define DEMO_SLANTED 1\n\n// hacky optimizations to help with perf\n#define RAY_DIST_START 0.0\n#define RAY_DIST_END 120.0\n\n\n\n// simulation parameters\n#define NUM_DIM_X 20\n#define NUM_DIM_Y 40\n#define NUM_DIM_Z 20\n#define FIXED_TIMESTEP 0.01666\n#define GRAVITY 8.0\n#define AO_QUALITY 2\n#define MAX_SPEED 15.0\n\n\n#define NUM_SLOTS 40\n\nvec3 getVolMax()\n{\n   return vec3(NUM_DIM_X, NUM_DIM_Y,NUM_DIM_Z);\n}\n\nvec4 confineSphereToSimBox(vec4 posr)\n{\n    // add radius\n    vec3 maxext = getVolMax() -posr.www;\n    vec3 minext = posr.www;\n    \n   \tvec3 ret = max( minext, min( maxext, posr.xyz));\n    return vec4(ret.x, ret.y, ret.z, posr.w);      \n}\n\n\nint texelToIndex (vec2 uv, vec2 res) {\n    int uvx = int( uv.x);\n    int uvy = int( uv.y);\n    int resx = int(res.x);\n    return uvy * resx + uvx;\n}\n\nivec2 indexToTexel (int index, vec2 res) {\n    int finx = int( index);\n    int resx = int(res.x);\n    int x = finx % resx;\n    int y = (finx - x) / resx;\n    return ivec2(x,y);\n}\n\nfloat sphereRayIntersection(vec4 sphere, vec3 rayDir, vec3 rayOrigin)\n{\n    float rsq = sphere.w * sphere.w;\n    vec3 omc= rayOrigin - sphere.xyz;\n    \n    float bp = dot(rayDir, omc);\n    float cp = dot(omc, omc) - rsq;\n    \n    if( bp * bp  > cp)\n    {\n        return -bp - sqrt(bp*bp - cp);\n    }\n    else\n    {\n        return -1.0f;\n    }\n}\n\n\nfloat getRndFloat(in vec2 xy, in float seed)\n{\n    return  fract(dot(xy, vec2(123.123551, 723.1237711)) * seed);\n}\n\nvec4 getRnd(vec2 xy)\n{\n    return vec4( getRndFloat(xy, 1.434521),\n                getRndFloat(xy, 7.23421),\n                getRndFloat(xy, 3.777721),\n                getRndFloat(xy, 5.11721));\n    \n}\n\n\nbool indexInCellSlotRange(int index)\n{\n    return index >= 0 && index < (NUM_DIM_X *NUM_DIM_Y*NUM_DIM_Z* NUM_SLOTS);\n}\n\nivec4 indexToSlot(int index)\n{\n    ivec4 ret;\n    ret.x = index % NUM_DIM_X;\n    index = index - ret.x;\n    index = index / NUM_DIM_X;\n    ret.y = index % NUM_DIM_Y;\n    index = index - ret.y;\n    index = index / NUM_DIM_Y;\n    ret.z = index % NUM_DIM_Z;\n    index = index - ret.z;\n    index = index / NUM_DIM_Z;\n    ret.w = index % NUM_SLOTS;\n\treturn ret;    \n}\n\nint slotToIndex(ivec3 pos, int slotI)\n{\n    return pos.x + pos.y * NUM_DIM_X + pos.z * NUM_DIM_X * NUM_DIM_Y +  NUM_DIM_X * NUM_DIM_Y * NUM_DIM_Z * slotI;\n}\n\n\nbool isCellInsideVolume(ivec3 cellPos)\n{\n    if( cellPos.x >= 0 && cellPos.x < NUM_DIM_X)\n    {\n        if( cellPos.y >= 0 && cellPos.y < NUM_DIM_Y)\n    \t{\n            if( cellPos.z >= 0 && cellPos.z < NUM_DIM_Z)\n            {\n                return true;\n            }\n        }\n    }\n    \n    return false;\n}\n\nivec4 worldPosToCell(vec3 pos)\n{\n    ivec4 ret = ivec4(pos.xyzz);\n    ret.w = -1;\n    if(isCellInsideVolume(ret.xyz))\n    {\n        ret.w = 1;\n    }\n\n    return ret;\n    \n}\n\n\nbool isParticleInside(vec3 pos, ivec3 cell)\n{\n    ivec4 corpos = worldPosToCell(pos);\n\tif(corpos.w > 0 && corpos.xyz == cell)\n    {\n        return true;\n    }\n    \n    return false;\n}","name":"Common","description":"","type":"common"}]}