{"ver":"0.1","info":{"id":"3dlBWN","date":"1588272465","viewed":78,"name":"Croix contre X block nxn","username":"Aurus","description":"Croix contre X block nxn","likes":1,"published":1,"flags":32,"usePreview":0,"tags":["jeuxdevie"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n Le projet consisté à pousser un peut le concept de jeux de la vie en changeant les cellules \n qui sont les simples pixels avec les cellules multiples en forme de carre 3x3 5x5 ou autres \n en changeant le paramètre t_cellule.\n\n Deux cellules opposées sont des cellules en forme de lettre X et en forme de croix verticale + \n \n par exemple pour 3x3  en forme de X: xox        en forme de + : oxo     \n                                      oxo                        xox\n                                      xox                        oxo\n donc on peut différencier  les cellules par leur couleur de centre x(noir) o(blanch).\n \nP.S.\n\tLa premiere exemple 3x3 en dur regarder ici (https://www.shadertoy.com/view/3slfD4)\n\nP.S. \n    Malgrais mes efforts je n'ai pas réussi à obtenir totalement la forme attendue, \n\tje suppose que c'est liée au sistaime de coordonnées qui est relatif.\n \n \n*/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 col = texelFetch( iChannel0, ivec2(fragCoord), 0 ).xyz; \n    fragColor = vec4(col,1.0); \n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Génération d'un nombre aléatoire\n// en fonction de la position dans le buffer\n// Pour plus d'info voir https://www.shadertoy.com/view/XtX3D4\n// Thanks to Michael Pohoreski https://www.shadertoy.com/user/MichaelPohoreski\nfloat random( vec2 p )\n{\n    vec2 K1 = vec2(23.14069263277926, 2.665144142690225); // 23.14=e^pi (Gelfond's constant) et 2.66=2^sqrt(2) (Gelfond–Schneider constant)\n    return fract( cos( dot(p,K1) ) * 12345.6789 );\n}\n\n// Fonction principale game of life by John Conway, published in 1970\n// Thanks to Pascal Ballet (https://www.shadertoy.com/user/pascalballet)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 col;\n    int t_cellule = 5;\n    \n    \n    float modx = mod(fragCoord.x, float(t_cellule));\n    float mody = mod(fragCoord.y,float(t_cellule));\n    int modxi = int(modx);\n    int modyi = int(mody);\n   \n    \n    if( iFrame == 0 ) { // Initialisation\n       \n        \n        \n        if(modxi == (t_cellule - 1)/2 && modyi == (t_cellule - 1)/2 ) {\n    \t\tif(random(fragCoord) < 0.5) {\n    \t\t\tcol = vec3(0.0, 0.0, 0.0);\n        \t} else {\n            \tcol = vec3(1.0, 1.0, 1.0);\n        \t}\n        } else {\n    \t\t\tcol = vec3(0.0, 0.0, 0.0);\n        }\n        \n        \n    }else{\n        \n        col = texelFetch( iChannel0, ivec2(fragCoord), 0 ).xyz;\n       \n        \n    \tif(modxi == (t_cellule - 1)/2 && modyi == (t_cellule - 1)/2){\n            \n            // on cherche les couleurs des centres de celules qui nous entoure \n            vec3 col_g = texelFetch( iChannel0, ivec2(fragCoord + vec2(-float(t_cellule), 0.0) ), 0 ).xyz;\n            vec3 col_d = texelFetch( iChannel0, ivec2(fragCoord + vec2( float(t_cellule), 0.0) ), 0 ).xyz;\n            vec3 col_h = texelFetch( iChannel0, ivec2(fragCoord + vec2( 0.0, float(t_cellule)) ), 0 ).xyz;\n            vec3 col_b = texelFetch( iChannel0, ivec2(fragCoord + vec2( 0.0,-float(t_cellule)) ), 0 ).xyz;\n            vec3 col_gb = texelFetch( iChannel0, ivec2(fragCoord + vec2(-float(t_cellule),-float(t_cellule)) ), 0 ).xyz;\n            vec3 col_db = texelFetch( iChannel0, ivec2(fragCoord + vec2( float(t_cellule),-float(t_cellule)) ), 0 ).xyz;\n            vec3 col_gh = texelFetch( iChannel0, ivec2(fragCoord + vec2(-float(t_cellule), float(t_cellule)) ), 0 ).xyz;\n            vec3 col_dh = texelFetch( iChannel0, ivec2(fragCoord + vec2( float(t_cellule), float(t_cellule)) ), 0 ).xyz;\n            \n            int nbCroix= 0;\n            if( col_g == vec3(0.0,0.0,0.0)) nbCroix++;\n            if( col_d == vec3(0.0,0.0,0.0)) nbCroix++;\n            if( col_h == vec3(0.0,0.0,0.0)) nbCroix++;\n            if( col_b == vec3(0.0,0.0,0.0)) nbCroix++;\n            if( col_gb == vec3(0.0,0.0,0.0)) nbCroix++;\n            if( col_db == vec3(0.0,0.0,0.0)) nbCroix++;\n            if( col_gh == vec3(0.0,0.0,0.0)) nbCroix++;\n            if( col_dh == vec3(0.0,0.0,0.0)) nbCroix++;\n            \n            if(col == vec3(1.0, 1.0, 1.0) ) { // FORME EN X\n            \tif( nbCroix == 3) col = vec3(0.0, 0.0, 0.0); // NAISSANCE DE CROIX VERTICALE +\n            } else { // CROIX VERTICAL\n                if( nbCroix < 2) col = vec3(1.0, 1.0, 1.0); // NAISSANCE DE FORME EN X (isolement)\n                if( nbCroix == 2 || nbCroix == 3) col = vec3(0.0, 0.0, 0.0);//SURVIE CROIX VERTICALE +\n                if( nbCroix > 3) col = vec3(1.0, 1.0, 1.0); // NAISSANCE DE FORME EN X (surpopulation)\n            }\n            \n        }else{\n            \n            int mooveX = 0;\n            int mooveY = 0;\n            int flag = 0;\n\t\t\t\n            // si sur diagonale / de FORME EN X\n            if (modxi == modyi){\n                mooveX = (t_cellule - 1)/2 - modxi;\n                mooveY = (t_cellule - 1)/2 - modyi;\n            // si sur diagonale \\ de FORME EN X    \n            }else if(modxi + modyi == (t_cellule - 1)){\n\t\t\t\tmooveX = modxi - (t_cellule - 1)/2;\n                mooveY = modyi - (t_cellule - 1)/2;\n            // si sur ligne verticale | de CROIX VERTICALE \n            }else if(modxi != modyi && modxi == 4){\n            \tmooveX = 0;\n                mooveY = (t_cellule - 1)/2 - modyi;\n                flag = 1;\n           \n            }else{\n            \tint mooveX = 0;\n            \tint mooveY = 0;\n            }\n        \t\n            // on adapte la couleur au couleur de centre de cellule \n            col = texelFetch( iChannel0, ivec2(fragCoord + vec2( mooveX, mooveY) ), 0 ).xyz;\n            \n            // si forme de CROIX VERTICALE on change la couleur à l'opposé\n            if( flag == 1){\n                if( col == vec3(0.0,0.0,0.0)){\n                \tcol = vec3(1.0,1.0,1.0);\n                }else{\n                \tcol = vec3(0.0,0.0,0.0);\n                }\n            }\n           \n        }\n        \n        \n\n    }  \n    \n    fragColor = vec4(col, 1.0);\n}\n","name":"Buffer A","description":"","type":"buffer"}]}