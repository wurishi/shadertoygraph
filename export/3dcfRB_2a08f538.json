{"ver":"0.1","info":{"id":"3dcfRB","date":"1605374596","viewed":175,"name":"Light experiments 2","username":"julianlumia","description":":octopus:  :octopusballoon:  :octopus:\n","likes":12,"published":1,"flags":32,"usePreview":0,"tags":["refraction"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n#define T(uv) texture(iChannel0,uv)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord/iResolution.xy);\n\n    \n    float f = length(uv  - 0.5);\n    fragColor.x = T(uv + f*0.01).x;\n    fragColor.y = T(uv -f*0.009).y;\n    fragColor.z = T(uv-f*0.02).z;\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\n#define MAX_STEPS 40\n#define MAX_DIST 30.\n#define SURF_DIST .001\n\n#define PI 3.14159\n\n\nfloat smin (float a, float b, float r)\n{\n float h = clamp(.5+.5*(b-a)/r,0.,1.);\n return mix(b, a, h) - r*h*(1.-h);\n}\n\nvec3 spherepos;\n\nvec2 condmin(in vec2 d1, in vec2 d2) {\nreturn vec2(min(d1.x, d2.x), mix(d1.y, d2.y, step(d2.x, d1.x)));\n}\n\nfloat sdOctahedron( vec3 p, float s)\n{\n p = abs(p);\n return (p.x+p.y+p.z-s)*0.57735027;\n}\n\nmat2 Rot(float a) {\n float s = sin(a);\n float c = cos(a);\n return mat2(c, -s, s, c);\n}\n\n\nfloat sdSphere(vec3 p, float s)\n{\n return length(p) - s;\n}\n\nfloat sdBox(vec3 p, vec3 s) {\n p = abs(p)-s;\n return length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.);\n}\n\nfloat g4;\nfloat T;\nfloat rnd(float x){return fract(sin(x * 1100.082) * 13485.8372);}\n\nvec2 GetDist(vec3 p) {\n     float n = sin(dot(floor(p), vec3(27, 113, 57)));\n// vec3 rnd = fract(vec3(2097152, 262144, 32768)*n)*5. - .0;\n //     float t = iTime-.015*rnd(p.y*1.+p.x*7.7);\n\n float the;\n vec2 d;\n float gap = 1.;\n vec3   p3 = p; \n p3.zy = mod(p3.zy + gap,2.0 * gap) - gap;\n vec3 p7 = p;\n vec3 p4 = p;\n float gap2 =2.;\n p4.z = mod(p.z + gap2,2.0 * gap) - gap;\n\n// spherepos =  vec3(-1.5,cos(iTime*.5)*5.+2.,sin(iTime*.5)*5.+2.);\n spherepos =  vec3(-1.5,cos(iTime*.5)*5.+2.,-1.);\n vec3 p5 = p;\n p5 -=vec3(1.12,1.0,2.9);\n p5.xz *= mat2(cos(the), -sin(the), sin(the), cos(the));\n p5.yz *= mat2(cos(the), -sin(the), sin(the), cos(the));\n vec2 box = vec2(sdBox(p5, vec3(.7,.3,.02)),9);\n vec2 box2 = vec2(sdBox(p-vec3(-1.0,0.0,.0), vec3(.4,.3,.3)),3);\n vec2 box3 = vec2(sdBox(p3-vec3(2,0.,0), vec3(0.1,1.,1.)),3);\n the = .4;\n p.xz *= mat2(cos(the), -sin(the), sin(the), cos(the));\n the = .6;\n p.zx *= mat2(cos(the), -sin(the), sin(the), cos(the));\n n = sin(dot(floor(p), vec3(27, 113, 57)));\n //rnd = fract(vec3(2097152, 262144, 32768)*n)*.16 - .05;\n vec3 rnd2 = fract(vec3(2097152, 262144, 32768)*n)*0.1 - 0.1;\n the =  floor(iTime*.5)+smoothstep(0.,.4,fract(iTime*.5));\n;\n p7-=vec3(.8,1.01,1.5);\n p7.xz *= mat2(cos(the), -sin(the), sin(the), cos(the));\n the = iTime*0.5;\n p7.yz *= mat2(cos(the), -sin(the), sin(the), cos(the));\n vec2 dbox9 =vec2( sdOctahedron( p7,.5),6);   \n gap = 1.;\n p = mod(p + gap,2.0 * gap) - gap;\n //float size = .8+ rnd.y;\n the =  .6;\n p.xz *= mat2(cos(the), -sin(the), sin(the), cos(the));\n vec2 dbox2 = vec2(sdBox( p,vec3(1.))*.1,3);\n vec2 dbox20 = vec2(sdOctahedron( p,.5),2);\n vec2 dbox21 = vec2(sdOctahedron( p5,.5),6);\n box.x = mix (box.x,dbox21.x,.2);\n dbox2.x = mix (dbox2.x,dbox20.x,1.);\n g4 +=1./(.5+pow(abs(dbox9.x),10.));\n box = condmin(box3,box);\n vec2  ebox = box;\n ebox = condmin(ebox,dbox9);\n ebox   = condmin(ebox,dbox2);\n\n return ebox ;\n}\n\n\nvec2 RayMarch(vec3 ro, vec3 rd) {\nvec2 h, t=vec2( 0.);   \nfor (int i=0; i<MAX_STEPS; i++) \n{   \nh = GetDist(ro + t.x * rd);\nif(h.x<SURF_DIST*(1.+t.x)||abs(t.x)>MAX_DIST) break;\nt.x+=h.x *1.;\nt.y=h.y;\n}\nif(t.x>MAX_DIST) \nt.x=0.;\nt.x +=h.x*1.;\nreturn t;\n}\nfloat marchCount;\n\n\nfloat traceRef(vec3 o, vec3 r){\n    \n float t = 0.0;\n marchCount = 0.0;\n float dO = 0.;  \n for (int i = 0; i <40; i++)\n {\n  vec3 p = o + r * t;   \n  float d = GetDist (p).x;\n  if(d<.015 || abs(t)>10.) break;\n  t += d * .5;\n  marchCount+= 1./d*1.;\n }    \n return t;\n}\n\n\nvec3 R(vec2 uv, vec3 p, vec3 l, float z) {\n vec3 f = normalize(l-p),\n r = normalize(cross(vec3(0,1,0), f)),\n u = cross(f,r),\n c = p+f*z,\n i = c + uv.x*r + uv.y*u,\n d = normalize(i-p);\n return d;\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr ){\n vec3 cw = normalize(ta-ro);\n vec3 cp = vec3(sin(cr), cos(cr),0.0);\n vec3 cu = normalize( cross(cw,cp) );\n vec3 cv = cross(cu,cw);\n return mat3( cu, cv, cw );\n}\n\nvec3 GetNormal(vec3 p){\nvec2 e = vec2(.00035, -.00035); \nreturn normalize(\n e.xyy * GetDist(p + e.xyy).x + \n e.yyx * GetDist(p + e.yyx).x + \n e.yxy * GetDist(p + e.yxy).x + \n e.xxx * GetDist(p + e.xxx).x);\n}\n\n\n// from: XT95\n//https://www.shadertoy.com/view/4sdGWN\n\nconst float PI2 = 3.14159265359;\n#define HASHSCALE1 .1031\nfloat hash(float p)\n{\n\tvec3 p3  = fract(vec3(p) * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec3 randomSphereDir(vec2 rnd)\n{\n\tfloat s = rnd.x*PI*2.;\n\tfloat t = rnd.y*2.-1.;\n\treturn vec3(sin(s), cos(s), t) / sqrt(1.0 + t * t);\n}\nvec3 randomHemisphereDir(vec3 dir, float i)\n{\n\tvec3 v = randomSphereDir( vec2(hash(i+1.), hash(i+2.)) );\n\treturn v * sign(dot(v, dir));\n}\n\n\nfloat ambientOcclusion( in vec3 p, in vec3 n, in float maxDist, in float falloff )\n{\n\tconst int nbIte = 32;\n    const float nbIteInv = 1./float(nbIte);\n    const float rad = 1.-1.*nbIteInv; //Hemispherical factor (self occlusion correction)\n    \n\tfloat ao = 0.0;\n    \n    for( int i=0; i<nbIte; i++ )\n    {\n        float l = hash(float(i))*maxDist;\n        vec3 rd = normalize(n+randomHemisphereDir(n, l )*rad)*l; // mix direction with the normal\n        \t\t\t\t\t\t\t\t\t\t\t\t\t    // for self occlusion problems!\n        \n        ao += (l - max(GetDist( p + rd ),0.).x) / maxDist * falloff;\n    }\n\t\n    return clamp( 1.-ao*nbIteInv, 0., 1.);\n}\n//-----------------\n\n\n\nfloat shadow(vec3 r0, vec3 rd, float maxDist)\n{\n    float d = .001;\n    float shadow = .4;\n    while(d < maxDist)\n    {\n        float t = GetDist(r0 + d * rd).x;\n        if(t < 0.01) return 0.0;\n        d += t;\n        shadow = min(shadow,5.0 * (t / d));\n    }\n    return shadow;\n}\n\nfloat GetLight(vec3 p) {\n    vec3 lightPos = vec3(spherepos);\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    \n    float dif = clamp(dot(n, l)*.5+.5, 0., 1.);\n    float d = RayMarch(p+n*SURF_DIST*1., l).x;\n    return dif;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n vec2 uv =( 2. * fragCoord.xy - iResolution.xy ) / iResolution.y;\n //   float t = iTime-0.15*rnd(p.y*3.3+p.x*7.7);\n // p.xy *=rot(floor(t)+smoothstep(0.,.4,fract(t)));\n vec3 eye = 1.0*vec3(1.4,sin(iTime)*.5+1.,4.);   \n float the =(eye.z*.1);\n vec3 hoek = vec3(1,1.,1);  \n the = (T*.2)-2.5;\n mat3 camera = setCamera( eye, hoek,4.7);\n float fov = 1.;\n vec3 dir = camera * normalize(vec3(uv, fov));\n vec3 focalPoint = eye + (dir );\n vec3 shiftedRayOrigin = eye;\n vec3 shiftedRay = (focalPoint - shiftedRayOrigin);\n vec3 shiftedRay2 = (focalPoint - shiftedRayOrigin);\n vec2 d = RayMarch(shiftedRayOrigin, shiftedRay);\n float t =d.x *1.;\n vec3  shiftedRayOrigin2 = shiftedRayOrigin;\n vec3 col;\n vec3 baseColor = vec3(0.,0.,0.);\n float a;\n if(t<MAX_DIST) {\n  shiftedRayOrigin2 += shiftedRay2 * t;\n  vec3 sn = GetNormal(shiftedRayOrigin);\n  vec3 sn2 = GetNormal(shiftedRayOrigin2);\n  shiftedRay2 = refract(shiftedRay2, sn2,.85);\n  if(d.y==9.) traceRef(shiftedRayOrigin2 +  shiftedRay2*1., shiftedRay2);\n  if(d.y==9.) baseColor = vec3(0.,0.02,0.04);\n  if(d.y==6.) baseColor = vec3(1.7,0.02,0.04);\n  vec3 p = shiftedRayOrigin + shiftedRay * t;\n  vec3 n= GetNormal(p.xyz);\n  float accum = 0.0;\n  vec3 lp =  vec3(spherepos);\n  const int numIter =60;\n  vec3 vD = shiftedRay;\n  vD = normalize(vD);\n  float stepSize = length(p - shiftedRayOrigin) / float(numIter);\n  vec3 vO = shiftedRayOrigin + stepSize * vD;\n  for(int i = 0; i  < numIter; ++i)\n   {\n \tvec3 ld = normalize(lp - vO);\n    float shad = shadow(vO, ld,10.);\n\tfloat d = dot(vO, vO);\n\taccum += (.002/ d ) * shad;\n\tvO += stepSize * vD;\n   }\n  col += baseColor;\n  col += accum*vec3(2.,3.,3.8)*1.5;;\n  float a = ambientOcclusion(p,n, 0.12,4.5);\n  col +=g4*vec3(0.001)*vec3(0.4,.4,.3);    \n  col *= GetLight(p);\n  col *= (a+0.5);   \n  shiftedRayOrigin += shiftedRay * t;\n  col *= GetLight(shiftedRayOrigin)*5.;\n  col += marchCount * vec3(.0005) * 1.;\n }\n vec3 sky = vec3(0.1,0.1,0.1);\n col = mix(sky, col, 1.4/(d.x*d.x/1./1.+.0)); \n col=pow(col, vec3(1.));\n fragColor = vec4(col,t);\n}\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// Dof code from: 42yeah, https://shadertoy.com/view/wsXBRf\n\n// Random hash function\nvec2 rand2d(vec2 uv) {\n    return fract(sin(vec2(\n        dot(uv, vec2(215.1616, 82.1225)),\n        dot(uv, vec2(12.345, 856.125))\n    )) * 41234.45) * 2.0 - 1.0;\n}\n\n// Calculate CoC: https://developer.download.nvidia.com/books/HTML/gpugems/gpugems_ch23.html\nfloat getCoC(float depth, float focalPlane) {\n    float focalLength = .01;\n    float aperture = min(1.0, focalPlane * focalPlane);\n    return abs(aperture * (focalLength * (focalPlane - depth)) /\n        (depth * (focalPlane - focalLength)));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // Sample original texture data at uv\n    vec4 texData = texture(iChannel0, uv);\n    \n    // Get its depth\n    float depth = texData.w;\n    \n    // Focal plane at 3.9 (the camera is looking at the center from ~4.0)\n   // float focalPlane =sin(iTime)+0.7;\n    \n       float focalPlane =sin(iTime*0.5)+.5;\n\n    \n    // Calculate CoC, see above\n    float coc = getCoC(depth, focalPlane);\n    \n    // Sample count\n    const int taps = 32;\n    \n    // Golden ratio: https://www.youtube.com/watch?v=sj8Sg8qnjOg\n    float golden = 3.141592 * (3.0 - sqrt(5.0));\n    \n    // Color & total weight\n    vec3 color = vec3(0.0);\n    float tot = 0.01;\n    \n    for (int i = 0; i < taps; i++) {\n        // Radius slowly increases as i increases, all the way up to coc\n        float radius = coc * sqrt(float(i)) / sqrt(float(taps));\n        \n        // Golden ratio sample offset\n        float theta = float(i) * golden;\n        vec2 tapUV = uv + vec2(sin(theta), cos(theta)) * radius;\n        \n        // Sample the bit over there\n        vec4 tapped = texture(iChannel0, tapUV);\n        float tappedDepth = tapped.w;\n\n        if (tappedDepth > 0.0) {\n            // Use CoC over there as weight\n            float tappedCoC = getCoC(tappedDepth, focalPlane);\n            float weight = max(0.001, tappedCoC);\n            \n            // Contribute to final color\n            color += tapped.rgb * weight;\n            // And final weight sum\n            tot += weight;\n        }\n    }\n    // And normalize the final color by final weight sum\n    color /= tot;\n    fragColor = vec4(color, 1.0);\n}\n","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord/iResolution.xy;\n\tvec2 uvn = (fragCoord - 0.5*iResolution.xy)/iResolution.xy;\n    float steps = 20.0;\n    float scale = 0.00 + pow(length(uv - 0.5)*1.2,3.)*0.4;\n    float chromAb = pow(length(uv - 0.5),1.4)*2.1;\n    vec2 offs = vec2(0);\n    vec4 radial = vec4(0);\n    for(float i = 0.; i < steps; i++){  \n        scale *= -1.15;\n        vec2 target = uv + offs;\n        offs -= normalize(uvn)*scale/steps;\n    \tradial.r += texture(iChannel0, target + chromAb*1./iResolution.xy).x;\n    \tradial.g += texture(iChannel0, target).y;\n    \tradial.b += texture(iChannel0, target - chromAb*1./iResolution.xy).z;\n    }\n    radial /= steps;  \n    fragColor = radial*1.;   \n    fragColor *= 1.;\n    fragColor = mix(fragColor,smoothstep(0.,1.,fragColor), .2);  \n    fragColor = max(fragColor, 0.);\n    fragColor *= 1. - dot(uvn,uvn)*1.8;\n}","name":"Buffer C","description":"","type":"buffer"}]}