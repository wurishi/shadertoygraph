{"ver":"0.1","info":{"id":"7tt3z2","date":"1636392786","viewed":99,"name":"Path of the shader - 1.","username":"SOMATICBITS","description":"1. shader on the path to learning shaders.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["somaticbits"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Note: using clamp a lot to keep sure values stay between 0. and 1. \n// and act in a consistent way with colors\n// Most of the knowledge acquired in this shader comes from Flopine's tutorials\n// https://www.twitch.tv/flopine/\n\nmat2 rot(float a) {\n    return mat2(cos(a), sin(a), -sin(a), cos(a));\n}\n\nfloat circle(vec2 uv) {\n    return length(uv);\n}\n\nfloat square(vec2 uv) {\n    uv = abs(uv);\n    return max(uv.x, uv.y);;\n}\n\n// smoothstep on pixel width\nfloat ss(float s, float size) {\n    float w = fwidth(s);\n    return smoothstep(size+w, size-w, s);\n}\n\nfloat shape(vec2 uv) {\n    return clamp(ss(square(uv),.2) - ss(circle(uv),.15),0.,1.);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    vec2 uv = (2. * fragCoord - iResolution.xy) / iResolution.y;\n    \n    uv *= 6.;\n    uv += .5; // adjustment for centering\n    \n    vec2 guv = fract(uv)-.5; // grid + center coords\n    vec2 id = floor(uv); // gives id of each cell\n    guv *= rot(iTime - (length(id)+0.1)*0.3); // rotate uv starting from center\n    guv *= cos(.3*(length(id)-iTime)); // scale uv\n    \n    float s = shape(guv); // add shape\n    \n    vec3 col = clamp(vec3(s),0.,1.) + 0.1;\n    col.r += clamp(cos(.2*(length(id)-iTime)),0.,1.); // cycle color\n\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}