{"ver":"0.1","info":{"id":"3tSGDW","date":"1559569963","viewed":118,"name":"English_Workshop","username":"profchen","description":"Construction tree.","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["implicit"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// ====== Bloc paramètres ====== //\n#define SHADERTOY\n#define GLSL330 (__VERSION__ >= 330)\n#ifdef SHADERTOY\n  #define DEF_S(type, name, default) const type name = default;\n  #define S(name) name\n#else\n  #if GLSL330\n    #define DEF_S(type, name, default) type name;\n    #define S(name) name\n  #else\n    #define DEF_S(type, name, default) uniform type name = default;\n    #define S(name) name\n  #endif\n#endif\n\n#if GLSL330\nlayout(std140) uniform SettingsBlock {\n#endif\n  DEF_S(bool, showGrid, false)\n  DEF_S(bool, showFriability, false)\n\n  DEF_S(bool, axisSkysphere, false)\n  DEF_S(vec3, skysphereColor1, vec3(0.949, 0.812, 0.659))\n  DEF_S(vec3, skysphereColor2, vec3(0.7, 0.8, 1.0))\n\n  DEF_S(vec3, stripeyColor1, vec3(0.906, 0.588, 0.173))\n  DEF_S(vec3, stripeyColor2, vec3(0.949, 0.812, 0.659))\n  DEF_S(vec3, stripeyScale, vec3(2.0, 8.0, 2.0))\n\n  DEF_S(vec3, sandColor1, vec3(0.949, 0.89, 0.8))\n  DEF_S(vec3, sandColor2, vec3(0.941, 0.792, 0.537))\n  DEF_S(float, sandThreshold, 0.6)\n  DEF_S(float, sandScale, 64.0)\n\n  DEF_S(vec3, hardRockColor1, vec3(0.906, 0.588, 0.173))\n\n  DEF_S(bool, cameraOrbiter, true)\n  DEF_S(vec3, cameraPosition, vec3(0.0, 0.0, 0.0))\n  DEF_S(vec3, cameraPitchYawRoll, vec3(0.0, 0.0, 0.0))\n  DEF_S(float, cameraFov, -4.0)\n#if GLSL330\n};\n#endif\n// ====== Fin bloc paramètres ====== //\n\nconst float PI = 3.1415926535897932384626433832795;\nconst float PI_2 = 1.57079632679489661923;\nconst float PI_4 = 0.785398163397448309616;\n\nconst vec3 sunPosition = normalize(vec3(1.0, 0.0, 0.0));\n\n// Trace ray using ray marching\n// o : ray origin\n// u : ray direction\n// h : hit\n// s : Number of steps\nconst float rA=0.0; // maximum du rayon\nconst float rB=40.0; // minimum du rayon\nconst int Steps = 1000;\nconst float Epsilon = 0.005;\n\n//#define FIELDVIEW\n//#define FRIABVIEW\n\n// Transforms\nvec3 rotateX(vec3 p, float a)\n{\n  float sa = sin(a);\n  float ca = cos(a);\n  return vec3(p.x, ca*p.y - sa*p.z, sa*p.y + ca*p.z);\n}\n\nvec3 rotateY(vec3 p, float a)\n{\n  float sa = sin(a);\n  float ca = cos(a);\n  return vec3(ca*p.x + sa*p.z, p.y, -sa*p.x + ca*p.z);\n}\n\nvec3 rotateZ(vec3 p, float a)\n{\n  float sa = sin(a);\n  float ca = cos(a);\n  return vec3(ca*p.x + sa*p.y, -sa*p.x + ca*p.y, p.z);\n}\n\n\nvec3 translate(vec3 p, vec3 t)\n{\n\treturn p + t;\n}\n\nvec3 stretch(vec3 p, vec3 s)\n{\n\treturn p *s;\n}\n\n// Smooth falloff function\n// r : small radius\n// R : Large radius\nfloat falloff( float r, float R )\n{\n  float x = clamp(r/R,0.0,1.0);\n  float y = (1.0-x*x);\n  return y*y*y;\n}\n\n\n// Primitive functions\n\n// Point skeleton\n// p : point\n// c : center of skeleton\n// e : energy associated to skeleton\n// R : large radius\nfloat point(vec3 p, float e,float R)\n{\n  return e * falloff(length(p), R);\n}\n\nfloat cube(vec3 p, float e, float R)\n{\n  return e * falloff(max(abs(p.x), max(abs(p.y), abs(p.z))), R);\n}\n\nfloat cylinder(vec3 p, float e, float R)\n{\n  return e * falloff(max(abs(p.y / 2.0), length(p.xz)), R);\n}\n\n// Plane skeleton\n// p : point\n// d : plane definition (x, y, z, d)\nfloat plane(vec3 p, vec4 d, float e, float R)\n{\n  return e * falloff((dot(d.xyz, p) + d.w)/length(d.xyz), R);\n}\n\n\n// Blending\n// a : field function of left sub-tree\n// b : field function of right sub-tree\nfloat Blend(float a,float b)\n{\n    return a+b;\n}\n\n// Union\n// a : field function of left sub-tree\n// b : field function of right sub-tree\nfloat Union(float a,float b)\n{\n    return max(a,b);\n}\n\n\n\n\n// Potential field of the object\n// _point : point\nfloat object(vec3 _point)\n{\n#ifdef FIELDVIEW\n  return plane(_point, vec4(-1.0, 0.0, 0.0, sin(iTime)), 1.0, 1.0)-0.5;\n#else\n  return point(stretch(_point,vec3(1.5,1.0,1.0)),2.0,2.0) - 0.5;\n#endif\n}\n\nfloat friability(vec3 _point) {\n  return 0.0;\n}\n\nfloat raymarch(vec3 origin, vec3 dir, out bool h, out float v)\n{\n  h = false;\n\n  // Don't start at the origin, instead move a little bit forward\n  float t=rA;\n\n  for (int i=0; i<Steps; i++)\n  {\n    vec3 p = origin + t * dir;\n    v = object(p);\n    // Hit object\n    if (v > 0.0) //sin(iTime/1000.0)/10.0)\n    {\n        h = true;\n        break;\n    }\n    // Move along ray\n    t += max(Epsilon,abs(v)/4.0);\n    // Escape marched far away\n    if (t>rB)\n    {\n      break;\n    }\n  }\n  return t;\n}\n\n// Background color\nvec3 background(vec3 rd)\n{\n  if (S(axisSkysphere)) {\n    return (abs(rd.x*32.0)<1.0 || abs(rd.y*32.0)<1.0 || abs(rd.z*32.0)<1.0)?rd*32.0+vec3(0.5):vec3(0.0);\n  } else {\n    vec3 nrd = normalize(rd);\n    // clamp(asin(nrd.y)/PI_2, 0.0, 1.0))\n    return mix(S(skysphereColor1), S(skysphereColor2), clamp(nrd.y, 0.0, 1.0)) + falloff(1.0-dot(nrd, sunPosition), 0.001);\n  }\n}\n\n\n// Calculate object normal\n// p : point\nvec3 ObjectNormal(in vec3 p, in float v)\n{\n  float eps = 0.0001;\n  vec3 n;\n  //float v = object(p);\n  n.x = object( vec3(p.x+eps, p.y, p.z) ) - v;\n  n.y = object( vec3(p.x, p.y+eps, p.z) ) - v;\n  n.z = object( vec3(p.x, p.y, p.z+eps) ) - v;\n  return normalize(n);\n}\n\nfloat rand(float n){return fract(sin(n) * 43758.5453123);}\n\nfloat noise(float p){\n\tfloat fl = floor(p);\n  float fc = fract(p);\n\treturn mix(rand(fl), rand(fl + 1.0), fc);\n}\n\nfloat rand(vec2 n) { \n\treturn fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\n\nfloat noise(vec2 p){\n\tvec2 ip = floor(p);\n\tvec2 u = fract(p);\n\tu = u*u*(3.0-2.0*u);\n\t\n\tfloat res = mix(\n\t\tmix(rand(ip),rand(ip+vec2(1.0,0.0)),u.x),\n\t\tmix(rand(ip+vec2(0.0,1.0)),rand(ip+vec2(1.0,1.0)),u.x),u.y);\n\treturn res*res;\n}\n\nvec3 val2color(float v) {\n  const float d0 = -1.0, d1 = -0.5, d2 = -0.1, d3 = 0.1, d4 = 0.5, d5 = 1.0, d6 = 2.0;\n  if (v < d1) {\n    return mix(vec3(1.0, 0.0, 0.0), vec3(1.0, 1.0, 0.0), (v - d0) / (d1 - d0));\n  } else if (v >= d1 && v < d2) {\n    return mix(vec3(1.0, 1.0, 0.0), vec3(0.0, 1.0, 0.0), (v - d1) / (d2 - d1));\n  } else if (v >= d2 && v < d3) {\n    return vec3(0.0);\n  } else if (v >= d3 && v < d4) {\n    return mix(vec3(0.0, 1.0, 0.0), vec3(0.0, 1.0, 1.0), (v - d3) / (d4 - d3));\n  } else if (v >= d4 && v < 8.0) {\n    return mix(vec3(0.0, 1.0, 1.0), vec3(0.0, 0.0, 1.0), (v - d4) / (d5 - d4));\n  } else {\n    return mix(vec3(0.0, 0.0, 1.0), vec3(1.0, 0.0, 1.0), (v - d5) / (d6 - d5));\n  }\n}\n\n// Shading and lighting\n// p : point,\n// n : normal at point\nvec3 Shade(vec3 p, vec3 n)\n{\n#ifdef FIELDVIEW\n  vec3 _point = p;\n  return vec3(val2color({{ code }}));\n#endif\n\n  if (S(showGrid)) {\n    if (fract(p.x) < 0.05) return vec3(1.0, 0.5, 0.5);\n    if (fract(p.y) < 0.05) return vec3(0.5, 1.0, 0.5);\n    if (fract(p.z) < 0.05) return vec3(0.5, 0.5, 1.0);\n  }\n\n  // point light\n  const vec3 lightPos = vec3(5.0, 5.0, 5.0);\n  const vec3 lightColor = vec3(0.5, 0.5, 0.5);\n  float lightIntensity = 2.0;\n\n#ifdef SHADOW\n  bool hit; float v;\n  vec3 rd = sunPosition, ro = p + rd * 0.1;\n  float dist = raymarch(ro, rd, hit, v);\n  if (hit) {\n    lightIntensity /= 4.0;\n  }\n#endif\n\n  vec3 c = background(-n);\n\n  // Not even Phong shading, use weighted cosine instead for smooth transitions\n  const float ambient = 0.2;\n  float diff = lightIntensity*0.5*(1.0+dot(-n, sunPosition));\n\n  if (S(showFriability)) {\n    float friability = friability(p) + 0.10001;\n    return clamp(diff, 0.1, 1.0) * vec3(val2color(friability));\n  }\n\n  float stripey = noise(p.y*S(stripeyScale).y + noise(vec2(p.x*S(stripeyScale).x+8543.2, p.z*S(stripeyScale).z-17548.6)));\n  vec3 albedo = mix(S(stripeyColor1), S(stripeyColor2), stripey);\n\n  albedo = mix(S(hardRockColor1), albedo, clamp(friability(p), 0.0, 1.0));\n\n  float sandAmount = ((-n.y)-S(sandThreshold))/(1.0-S(sandThreshold));\n  if (sandAmount > 0.0) {\n    albedo = mix(albedo, mix(S(sandColor1), S(sandColor2), noise(p.xz*S(sandScale))), sandAmount);\n  }\n\n  return (ambient+diff*(1.0-ambient))*lightColor*albedo+0.25*c;\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n  vec2 mouseNorm = vec2(iMouse.x / iResolution.x, iMouse.y / iResolution.y) * 2.0 - 1.0;\n  vec2 pixel = (fragCoord / iResolution.xy)*2.0-1.0;\n\n  // compute ray origin and direction\n  float asp = iResolution.x / iResolution.y;\n  vec3 rd = normalize(vec3(asp*pixel.x, pixel.y, S(cameraFov)));\n  vec3 ro;\n  if (S(cameraOrbiter)) {\n    ro = vec3(0.0, 0.0, 20.0);\n    ro = rotateX(ro, ((mouseNorm.y - 1.0) / 4.0) * 3.14159);\n    rd = rotateX(rd, ((mouseNorm.y - 1.0) / 4.0) * 3.14159);\n    ro = rotateY(ro, (mouseNorm.x - 1.0) * -3.14159);\n    rd = rotateY(rd, (mouseNorm.x - 1.0) * -3.14159);\n    ro += S(cameraPosition);\n  } else {\n    ro = S(cameraPosition);\n    rd = rotateZ(rd, cameraPitchYawRoll.z);\n    rd = rotateX(rd, cameraPitchYawRoll.x);\n    rd = rotateY(rd, cameraPitchYawRoll.y);\n  }\n\n  bool hit;\n  float v;\n  float t2 = raymarch(ro, rd, hit, v);\n  vec3 pos = ro + t2*rd;\n  vec3 rgb;\n\n  if (hit)\n  {\n    // Compute normal\n    vec3 n = ObjectNormal(pos, v);\n\n    const float fadeOut = 0.9;\n    rgb = mix(Shade(pos, n), background(rd), clamp((t2/rB-fadeOut)/(1.0-fadeOut), 0.0, 1.0));\n  }\n  else\n  {\n    rgb = background(rd);\n  }\n\n  fragColor = vec4(rgb,1.0);\n  \n  //if (position.x > 0) fragColor = vec4(vec3(t2), 1.0);\n  \n  //fragColor = vec4(vec3(distance(oh, eh)), 1.0);\n}\n","name":"Image","description":"","type":"image"}]}