{"ver":"0.1","info":{"id":"McSfzG","date":"1725077082","viewed":18,"name":"Funky Vortex ","username":"DoctorBirdy","description":" based on [SH2014] Cellular","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["mouse","blackhole","mousereactive"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Original shader by Haiku\n#define t iTime\n#define res iResolution.xy\n\nfloat hash(float n) {\n    return fract(sin(n) * 43758.5453);\n}\n\nvec2 rotate(vec2 v, float a) {\n    float s = sin(a);\n    float c = cos(a);\n    return vec2(v.x * c - v.y * s, v.x * s + v.y * c);\n}\n\nvec3 hsv2rgb(vec3 c) {\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * res) / res.y;\n    vec2 mouse = (iMouse.xy - 0.5 * res) / res.y;\n    \n    // Black hole parameters\n    float blackHoleRadius = 0.1;\n    vec2 blackHoleCenter = mouse;\n    if (iMouse.z <= 0.0) blackHoleCenter = vec2(0.0);\n    \n    // Gravitational lensing\n    vec2 offset = uv - blackHoleCenter;\n    float dist = length(offset);\n    float distortionFactor = 1.0 / (1.0 + exp((dist - blackHoleRadius * 2.0) * 10.0));\n    vec2 distortedUV = blackHoleCenter + offset * (1.0 - distortionFactor * 0.5);\n    \n    // Accretion disk (purple)\n    float diskWidth = 0.05;\n    float diskRadius = blackHoleRadius * 3.0;\n    float diskDist = abs(length(distortedUV - blackHoleCenter) - diskRadius);\n    float disk = smoothstep(diskWidth, 0.0, diskDist);\n    \n    // Orbiting dots\n    vec3 col = vec3(0.0);\n    int numDots = 1000; // Massively increased number of dots\n    for (int i = 0; i < numDots; i++) {\n        float seedX = hash(float(i));\n        float seedY = hash(float(i) + 1.0);\n        float seedZ = hash(float(i) + 2.0);\n        \n        float orbitRadius = mix(diskRadius * 0.5, diskRadius * 2.5, seedX);\n        float orbitSpeed = (1.0 / orbitRadius) * 0.5;\n        float dotSize = mix(0.002, 0.02, pow(seedY, 2.0)); // Increased max size and added non-linear distribution\n        \n        vec2 orbitPos = vec2(orbitRadius, 0.0);\n        orbitPos = rotate(orbitPos, t * orbitSpeed + seedZ * 6.28);\n        orbitPos += blackHoleCenter;\n        \n        vec2 dotOffset = distortedUV - orbitPos;\n        float dotDist = length(dotOffset);\n        \n        // Apply gravitational lensing to the dot\n        float dotDistortion = 1.0 / (1.0 + exp((length(orbitPos - blackHoleCenter) - blackHoleRadius * 2.0) * 10.0));\n        dotDist *= 1.0 + dotDistortion;\n        \n        float dot = smoothstep(dotSize, 0.0, dotDist);\n        \n        // Color the dot based on its speed and position (adjusted for purple theme)\n        vec3 dotColor = hsv2rgb(vec3(\n            mod(atan(orbitPos.y, orbitPos.x) / 6.28 + 0.7 + t * 0.1, 1.0),\n            0.8,\n            1.0\n        ));\n        \n        col += dot * dotColor * (1.0 - dotDistortion * 0.5);\n    }\n    \n    // Blend accretion disk (purple) with dots\n    vec3 purpleHaze = vec3(0.5, 0.0, 1.0);\n    col = mix(col, purpleHaze, disk * 0.7);\n    \n    // Black hole\n    float blackHole = 1.0 - smoothstep(blackHoleRadius * 0.9, blackHoleRadius, dist);\n    col = mix(col, vec3(0.0), blackHole);\n    \n    // Add subtle purple glow\n    col += vec3(0.2, 0.0, 0.4) * (1.0 / (1.0 + dist * 10.0));\n    \n    // Tone mapping to handle the increased brightness from more dots\n    col = col / (col + vec3(1.0));\n    \n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}