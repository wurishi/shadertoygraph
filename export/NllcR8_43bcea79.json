{"ver":"0.1","info":{"id":"NllcR8","date":"1647594286","viewed":206,"name":"SDF with smin","username":"carbene","description":"SDF with smin","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["sdf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nfloat sphereSDF(in vec3 samplePoint, in vec3 pos, in float radius){\n   return length(samplePoint - pos) - radius;\n}\nfloat cubeSDF(in vec3 samplePoint, in vec3 pos, in vec3 b) {\n  return length(max(abs(samplePoint - pos)-b,0.0));\n}\n\nfloat smin( float a, float b, float k){\n     float h = max( k-abs(a-b), 0.0 )/k;\n     return min(a, b) - h*h*k*(1.0/4.0);\n}\n\nfloat sceneSDF(in vec3 sp){\n    float sp1 = sphereSDF(sp, vec3(2.0 * sin(iTime * 2.0), 0.0, 0), 0.7);\n    float sp2 = sphereSDF(sp, vec3(0), 0.5);\n    float cb1 = cubeSDF(sp, vec3(-2.0, 0, 0), vec3(0.5));\n    return smin(smin(sp1, sp2, 0.9), cb1, 0.9);\n}\n\n#define DH 1e-4\nvec3 sceneNormal(in vec3 sp){\n    return normalize(vec3(\n        sceneSDF(sp + vec3(DH, 0.0, 0.0)) - sceneSDF(sp),\n        sceneSDF(sp + vec3(0.0, DH, 0.0)) - sceneSDF(sp),\n        sceneSDF(sp + vec3(0.0, 0.0, DH)) - sceneSDF(sp)\n    ));\n}\n\nstruct inter{\n    vec3 position;\n    vec3 normal;\n    vec3 refractDir;\n};\n\nfloat fresnelApprox(in vec3 I, in vec3 N){\n    float R0 = (1.55 - 1.0) / (1.55 + 1.0);\n    R0 *= R0;\n    return R0 + (1.0 - R0) * pow(1.0 - (dot(I, N)), 5.0);\n}\n\n#define MAX_STEPS 100\n#define EPS 1e-4\n#define MAX_DIST 100.0\nbool rayMarch(in vec3 ori, in vec3 dir, out inter hit){\n    float stepSize = 0.0;\n    vec3 p = ori;\n    float depth = 0.0;\n    for(int i = 0; i <= MAX_STEPS; i++){\n        p += stepSize * dir;\n        float dist = sceneSDF(p);\n        depth += dist;\n        if(dist < EPS){\n            hit.position = p;\n            hit.normal = sceneNormal(p);\n            hit.refractDir = refract(dir, hit.normal, 0.66);\n            return true;\n        }\n        if(depth > MAX_DIST){\n            return false;\n        }\n        stepSize = dist;\n    }\n    return false;\n}\n\nvec3 rayDirection(float fovY, vec2 fragCoord){\n    vec2 xy = fragCoord - iResolution.xy / 2.0;\n    float z = iResolution.y / tan(radians(fovY) * 0.5);\n    return normalize(vec3(xy, -z));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec3 ori = vec3(0.0, 0.0, 5.0);\n    vec3 dir = rayDirection(90.0, fragCoord);\n    \n    inter hit;\n    vec3 color = vec3(0.0);\n    if(rayMarch(ori, dir, hit)){\n        vec4 texColor;\n        if(iMouse.z > 0.0){\n            texColor = texture(iChannel0, hit.refractDir);\n        }else{\n            texColor = texture(iChannel0, reflect(dir, hit.normal));\n        }\n        color = texColor.rgb;\n    }else{\n        color = texture(iChannel0, dir).rgb;\n    }\n    // Output to screen\n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}