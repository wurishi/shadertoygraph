{"ver":"0.1","info":{"id":"mss3WM","date":"1666249747","viewed":152,"name":"Extruded blobs","username":"Envy24","description":"Hold LMB and drag to change pixel size.\n\nBufferA - Blobs.\nBufferB - Temporal blur (source: https://www.shadertoy.com/view/Dsl3Rn)\nImage  - Extrusion, Light, Color (source: https://www.shadertoy.com/view/Dsl3Rn)","likes":15,"published":1,"flags":32,"usePreview":0,"tags":["blobs","smin","extrusion","tempolarblur"],"hasliked":0,"parentid":"DdfGD7","parentname":"Blobs __"},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec2 grad(vec2 TC, float d)\n{\n    vec2 delta = vec2(d, 0);\n    return \n        vec2(TEX0(TC + delta.xy).x - TEX0(TC - delta.xy).x,\n             TEX0(TC + delta.yx).x - TEX0(TC - delta.yx).x);\n}\n\nvoid mainImage( out vec4 O, in vec2 SC )\n{\n    /*Calculate diffuse light.*/\n    vec3 light_dir = normalize(vec3(1,-1,1));\n    vec2 gradient = grad(TO_TEX_COORDS(SC), 1./R.y);    \n    vec3 normal = normalize(vec3(gradient, 1.));\n    float diffuse = dot(normal, light_dir);\n    /**/\n    float saturation = 3.;  \n    vec3 color = mix(HASH3(10., 1., -2.), HASH3(6., 35., -7.), TEXF0(SC).rgb * saturation);\n\n    O = vec4(color * diffuse, 1);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define R                         ( iResolution )\n#define AR                        ( R.x / R.y )\n#define UNIT                      ( 2.0 / R.y )\n#define SMAA(x)                   ( smoothstep(UNIT, 0., x) )\n#define LMB_IS_HOLD               ( iMouse.z > 0.0 )\n#define PIXEL_SIZE                ( LMB_IS_HOLD ? 1.+floor(iMouse.y / (R.y / 20.)) : 1. )\n#define PIXELATE(SC)              ( floor( (SC) / (PIXEL_SIZE) ) * (PIXEL_SIZE) )\n#define TEX0(TC)                  ( texture(iChannel0, (TC)) )\n#define TEXF0(SC)                 ( texelFetch(iChannel0, ivec2(PIXELATE(SC)), 0) )  // (channel, integer coordinates, mipmap level)\n#define TEXF1(SC)                 ( texelFetch(iChannel1, ivec2(PIXELATE(SC)), 0) )  // (channel, integer coordinates, mipmap level)\n#define TO_TEX_COORDS(SC)         ( (SC) / (R.xy) )                        // in range x=[0.0; 1.0], y=[0.0; 1.0]\n#define NMY                       ( iMouse.y / R.y )                       // in range [0.0; 1.0]\n\n/* Returns sine modulated value in range [min, max]. */\nfloat sinOSC(in float min, in float max, in float T)\n{\n    float v = (sin(T) + 1.0) * 0.5; // map T to [0.0, 1.0];\n    return min + v * (max - min);   // map T to [min, max];\n}\n\nfloat diskSDF_L2(vec2 NDC, vec2 C, float r)\n{\n    return length(C - NDC)-r;\n}\n\n/* \n    Returns random vec2([-1.0; 1.0], [-1.0; 1.0]).\n*/\nvec2 hash2to2(\n    const uint x,\n    const uint y)\n{\n    // Pick some enthropy source values.\n    // Try different values.\n    const uint entropy0 = 123u;\n    const uint entropy1 = 456u;\n    const uint entropy2 = 789u;\n\n    // Use linear offset method to mix coordinates.\n    uint value0 = y * entropy2 + x;\n    uint value1 = x * entropy2 + y;\n\n    // Calculate hash.\n\tvalue0 += entropy1; value0 *= 445593459u; value0 ^= entropy0;\n    value1 += entropy1; value1 *= 445593459u; value1 ^= entropy0;\n    \n    // 2.0f / 4294967295.0f = 4.6566128730773926e-10\n\n    return \n        vec2(\n            float(value0 * value0 * value0) * 4.6566128730773926e-10f - 1.0f,\n            float(value1 * value1 * value1) * 4.6566128730773926e-10f - 1.0f);\n}\n#define HASH2(x, y) ( hash2to2(uint(x), uint(y)) )\n\n/* \n    Returns random vec3([-1.0; 1.0], [-1.0; 1.0], [-1.0; 1.0]).\n*/\nvec3 hash3to3(\n    const uint x,\n    const uint y,\n    const uint z)\n{\n    // Pick some enthropy source values.\n    // Try different values.\n    const uint entropy0 = 1200u;\n    const uint entropy1 = 4500u;\n    const uint entropy2 = 6700u;\n    const uint entropy3 = 8900u;\n\n    // Use linear offset method to mix coordinates.\n    uint value0 = z * entropy3 * entropy2 + y * entropy2 + x;\n    uint value1 = y * entropy3 * entropy2 + x * entropy2 + z;\n    uint value2 = x * entropy3 * entropy2 + z * entropy2 + y;\n\n    // Calculate hash.\n\tvalue0 += entropy1; value0 *= 445593459u; value0 ^= entropy0;\n    value1 += entropy1; value1 *= 445593459u; value1 ^= entropy0;\n    value2 += entropy1; value2 *= 445593459u; value2 ^= entropy0;\n\n    // 2.0f / 4294967295.0f = 4.6566128730773926e-10\n\n    return vec3(\n        float(value0 * value0 * value0) * 4.6566128730773926e-10f - 1.0f,\n        float(value1 * value1 * value1) * 4.6566128730773926e-10f - 1.0f,\n        float(value2 * value2 * value2) * 4.6566128730773926e-10f - 1.0f);\n}\n#define HASH3(x, y, z) ( abs(hash3to3(uint(x), uint(y), uint(z))) )","name":"Common","description":"","type":"common"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"float vertical_line(vec2 NDC, float x0) { return SMAA(abs(NDC.x-x0)); }\nfloat horizontal_line(vec2 NDC, float y0) { return SMAA(abs(NDC.y-y0)); }\n\nvec2 map_to_centered_ndc(in vec2 SC, in float scale, in vec2 ndc_offset)\n{\n    /**\n    vec2 M = \n        iMouse.z > 0. ?\n            iMouse.xy - R.xy * 0.5 : // map xy from [0; R.x][0; R.y] to [-R.x/2; R.x/2][-R.y/2; R.y/2]\n            vec2(0);                 // supress mouse offset\n    SC -= M;                         // apply mouse offset\n    /**/\n    SC = 2. * SC - R.xy;             // map xy from [0; R.x][0; R.y] to [-R.x; R.x][-R.y; R.y]\n    SC /= R.y;                       // map xy from [-R.x; R.x][-R.y; R.y] to [-AR; AR][-1; 1]\n    SC *= scale;                     // map xy from [-AR;AR][-1;1] to [-AR*scale; AR*scale][-scale; scale]\n    \n    return SC - ndc_offset;          // apply \"static\" offset in ndc space\n}\n#define STD_MAP(SC) ( map_to_centered_ndc(SC, 1., vec2(0)) )\n\n// Source: https://iquilezles.org/articles/smin/\nfloat smin( float a, float b, float k )\n{\n    float h = max( k-abs(a-b), 0.0 )/k;\n    return min( a, b ) - h*h*k*(1.0/4.0);\n}\nfloat union_sdf(float dl, float dr) { return smin(dl, dr, 0.15); }\n\nvoid mainImage( out vec4 O, in vec2 SC )\n{\n    vec2 NDC = STD_MAP(SC);\n    vec3 color = HASH3(10., 1., -2.);\n       \n    float scene_dist = 99., T = 0.5*iTime;\n    \n    for (float i = 0.; i < 300.; i += 1.)\n    {\n        vec2 r = HASH2(i, i+1.),                 // random vector xy [-1;1][-1;1]\n             dir = r * T*fract(i/100.),          // random direction times velocity\n             C = mod(r + dir, vec2(4))-vec2(2);  // wrapped disk coordinates.\n             \n        float tresholded_r =\n            abs(r.y) > 0.1 ?\n                0.1*abs(r.x) :\n                abs(r.x)*abs(r.x),\n\n              radius = 64.*tresholded_r*UNIT,\n              dist = diskSDF_L2(NDC, C, radius);\n        \n        scene_dist = union_sdf( scene_dist, dist ); \n    }\n    //color = mix( color, HASH3(6., 35., -7.), SMAA(abs(scene_dist)) );\n    color = mix( color, HASH3(6., 35., -7.), SMAA(scene_dist) );\n    //color = mix( color, vec3(1), SMAA(scene_dist) );\n    \n    O = vec4(color, 1); \n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"void mainImage( out vec4 O, in vec2 SC )\n{\n    float t = 0.50;\n\n    O = \n        iFrame == 0 ?\n            vec4( 0 ) :\n            TEXF0(SC) * (1. - t) + TEXF1(SC) * t;\n}","name":"Buffer B","description":"","type":"buffer"}]}