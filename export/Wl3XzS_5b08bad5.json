{"ver":"0.1","info":{"id":"Wl3XzS","date":"1581576589","viewed":133,"name":"Sine Ground","username":"vstelegin","description":"Yet another landscape","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const vec3 light1 = normalize(vec3(-0.2, 0.5, -0.5));\nconst vec3 light2 = normalize(vec3(-1.0,0.0, 0.0));\n#define collisionIterations 10\n//https://iquilezles.org/articles/smin\nfloat sminCubic( float a, float b, float k )\n{\n    float h = max( k-abs(a-b), 0.0 )/k;\n    return min( a, b ) - h*h*h*k*(1.0/6.0);\n}\nvec3 mirrorLoop(vec3 p){\n\treturn abs(fract(0.5 - p) - 0.5);\n}\nfloat mirrorLoop(float p){\n\treturn abs(fract(0.5 - p) - 0.5);\n}\nfloat random (vec2 st) {\n    return mod(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))*\n        47123777.537, 1.0);\n}\nfloat noise2(vec2 v){\n    float l = sin(v.x*0.5 + 21.321) - sin(v.y*0.44 + 219.34);\n    float m = sin(v.x*4.0 + 42.4291 + l) + sin(v.y*2.0 + 2.14 + l);\n    float n = sin(v.x*2.0 + l + 3.32) + sin(v.y*2.2 + m + 451.23);\n\treturn  sin(l * 0.1)*5.0 + n + m*0.4;\n}\n\nfloat tiles (vec3 p){\n    vec2 ipos = floor(p.xz*0.5);\n\n\treturn step(random(ipos),0.1);//1.0 - clamp(smoothstep(x,0.0, 0.45) +  smoothstep(z, 0.0, 0.45),0.0,1.0);\n\t}\n\nfloat scene (vec3 p){\n    float size = 0.5;\n    vec3 pMod = mod(p - 0.5,5.0) - 2.5;\n    pMod.y = p.y + sin(p.y)*0.5;\n    //pMod.y += 3.0;\n    pMod.y *= 0.1;\n    vec3 q = abs(pMod) - size;\n    //q.y = 0.0;\n    float cubes = length(max(q,0.0));\n    //float spheres = length(mod(p,0.4) - 0.2) - 0.2;\n    //return length(p) - 1.0;\n    float height = 2.5 - abs(p.y ) ;\n    height = (height + 1.0 + noise2(p.xz*0.1 + p.y*0.15) + length(noise2(p.xz*0.5))*0.2);\n    //return cubes;\n    return mix(height, sminCubic(height,cubes, 2.9), 0.5);\n}\n\nvec3 nor( vec3 p, float prec )\n{\n    vec2 e = vec2( prec, 0. );\n    vec3 n = vec3(\n\t\tscene(p+e.xyy) - scene(p-e.xyy),\n\t\tscene(p+e.yxy) - scene(p-e.yxy),\n\t\tscene(p+e.yyx) - scene(p-e.yyx) );\n    return normalize(n);\n}\n\nfloat grid (vec3 p){\n\n    float x = abs(fract(0.5 - p.x ) - 0.5);\n    float z = abs(fract(0.5 - p.z ) - 0.5);\n\treturn smoothstep(x,0.0, 0.45) +  smoothstep(z, 0.0, 0.45);\n\t}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 uv = (fragCoord+fragCoord - iResolution.xy) / iResolution.y;\n\n\n    fragColor = vec4(0,0,0,1.0);\n    \n    vec3 ro = vec3(0,0.0,2.0 + iTime);\n\n    \n    float a = iMouse.x*0.01;\n    //ro.x =  ro.z * sin(a);\n    //ro.z =  ro.z * cos(a);\n    \n    vec3 w = normalize(ro);\n    vec3 u = cross(w, vec3(0.0, 1.0, 0.0));\n    vec3 v = cross(u, w);\n    u = normalize(u);\n    v = normalize(v);\n    vec3 rd = normalize( uv.x * u + uv.y * v + 1.0*w);\n    \n    float altitude = 0.0;\n    for (int i=0; i < collisionIterations; i++){\n    \taltitude += scene(ro + rd*float(i)*0.5);\n    }\n    altitude /= float(collisionIterations);\n    ro.y = ro.y + 1.9 - altitude; \n    float d = 0.0;\n    float raystep = 0.01;\n    for (int i=0; i<64; i++){\n    \tvec3 p = ro + rd * d;\n    \tfloat r = scene(p);\n        int outside = int (r > 0.001);\n        d += float(outside) * r;\n    }\n    vec3 p = ro + rd * d;\n    float result = step(scene(p), 1.0);\n    vec3 normal =  nor(p, 0.05);\n   \tfloat diffuse = dot(light1,normal);\n    diffuse = clamp(diffuse, 0.0, 1.0);\n    float specular = dot(reflect(rd,normal), light2);\n    specular = clamp(specular*specular,0.0,1.0);\n    vec3 color = vec3 (0.7, 0.2, length(ro - p)*0.25);\n    float patternMask = (d*0.25 - 2.0); \n    vec3 pattern = vec3(grid(p)) * clamp(2.0 - patternMask*patternMask, 0.0,1.0); \n    float wallsMask = 1.0 - clamp(dot(vec3(0.0,0.0,-1.0), normal),0.0,1.0);\n    pattern *=wallsMask;\n    float fresnel = 1.0 - clamp(dot(-rd, normal),0.0,1.0);\n    \n    float fog = clamp(color.z*0.1,0.0,1.0);\n    vec4 finalColor = vec4( diffuse * color + specular,0 );\n    finalColor = mix(finalColor, vec4(0.0,0.0,1.0,1.0),fog + pattern.x*pattern.x*400.0);\n    //finalColor = mix(finalColor, vec4(0.0,0.0,1.0,1.0), pattern);\n    fragColor =  finalColor +fog*fresnel*0.15 ;\n}","name":"Image","description":"","type":"image"}]}