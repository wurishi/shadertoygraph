{"ver":"0.1","info":{"id":"fsscRM","date":"1641874184","viewed":144,"name":"Sphere of Moire Patterns","username":"TheTimesweeper","description":"should I have forked the not old one?\n\nAt the end of the video I was curious about the moire effects seen, so I had fun rudimentarily poking through the code, aligning the cube, and letting the simulation grow more and more distorted as it went on","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["raytracing"],"hasliked":0,"parentid":"NsXGzB","parentname":"Sphere of cubes (old)"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// derived from BrunoLevy's RayTracing tutorial - step 1, shadertoy.com/view/wdfXR4\n \nstruct Camera {\n    vec3 Obs;\n    vec3 View;\n    vec3 Up;\n    vec3 Horiz;\n    float H;\n    float W;\n    float z;\n};\n\nstruct Ray {\n    vec3 Origin;\n    vec3 Dir;\n};\n\nCamera camera(in vec3 Obs, in vec3 LookAt, in float aperture) {\n   Camera C;\n   C.Obs = Obs;\n   C.View = normalize(LookAt - Obs);\n   C.Horiz = normalize(cross(vec3(0.0, 0.0, 1.0), C.View));\n   C.Up = cross(C.View, C.Horiz);\n   C.W = float(iResolution.x);\n   C.H = float(iResolution.y);\n   C.z = (C.H/2.0) / tan((aperture * 3.1415 / 180.0) / 2.0);\n   return C;\n}\n\nRay launch(in Camera C, in vec2 XY) {\n   return Ray(\n      C.Obs,\n      C.z*C.View+(XY.x-C.W/2.0)*C.Horiz+(XY.y-C.H/2.0)*C.Up \n   );\n}\n\nstruct Sphere {\n   vec3 Center;\n   float R;\n};\n\nbool intersect_sphere(in Ray R, in Sphere S, out float t, out float t2) {\n   vec3 CO = R.Origin - S.Center;\n   float a = dot(R.Dir, R.Dir);\n   float b = 2.0*dot(R.Dir, CO);\n   float c = dot(CO, CO) - S.R*S.R;\n   float delta = b*b - 4.0*a*c;\n   if(delta < 0.0) {\n      return false;\n   }\n   t = (-b-sqrt(delta)) / (2.0*a);\n   t2 = (-b+sqrt(delta)) / (2.0*a);\n   return true;\n}\n\nbool step_forward(in Ray R, inout float t, inout vec3 roundpoint, out int coord, in float max_t, in float cubeWidth, in float cubesRad){\n    vec3 point = R.Origin + t*R.Dir;\n    vec3 signDir = sign(R.Dir);\n    /// solve for param: point + param*Dir = roundpoint + 0.5*(signDir)*cubeWidth component by component\n    vec3 params = (roundpoint - point + 0.5*signDir*cubeWidth)/R.Dir;\n\n    // find out which wall we hit next\n    if(params.x < params.y){\n        if(params.x < params.z){ coord = 0;}\n        else{ coord = 2;}\n    }\n    else{\n        if(params.y < params.z){ coord = 1;}\n        else{ coord = 2;}\n    }\n    \n    if(coord == 0){\n        t += params.x;\n        roundpoint += signDir*vec3(cubeWidth,0.0,0.0);\n    }\n    else if(coord == 1){\n        t += params.y;\n        roundpoint += signDir*vec3(0.0,cubeWidth,0.0);\n    }\n    else if(coord == 2){\n        t += params.z;\n        roundpoint += signDir*vec3(0.0,0.0,cubeWidth);\n    }\n    \n    if(length(roundpoint) < cubesRad){ return false; } // we hit a cube \n    if(t > max_t){ coord = 3; \n        return false;\n    }  // meaning that we were tangent to the sphere of cubes and didnt hit anything\n \n    return true; // keep going\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n   float timeTravel = 50.0;//-7800.0;\n   float cubeBaseWidth = 0.1f;\n   float timescale = 1.0;\n   \n   float time = float(100 + iFrame)/100.0 * timescale;\n   float cubeWidth = cubeBaseWidth/(time+timeTravel);  //0.01;\n   float sphereRad = 1.0;\n   float cubesRad = sphereRad - cubeWidth*0.5*sqrt(3.0); // cube with center within this rad is contained in sphere\n \n   vec3 red = vec3(1.0,0.0,0.0);\n   vec3 green = vec3(0.0,1.0,0.0);\n   vec3 blue = vec3(0.0,0.0,1.0);\n   \n   //I wanna do math with u\n   const float pi = 3.141592653589793238462643383279502884197169399;\n   \n   float beta = pi / 4.0;// + 0.3 * time;\n   float s = sin(beta);\n   float c = cos(beta); \n\n   // Initialize the Camera \n   Camera C = camera(\n       vec3(2.0*c, 2.0*s, sqrt(2.0)),//pi * (0.5 - 0.03)),\n       vec3(0.0, 0.0, 0.0),\n       50.0\n   );\n \n   Ray R = launch(C, fragCoord);\n   Sphere S = Sphere(vec3(0.0, 0.0, 0.0), sphereRad);\n   \n   fragColor = vec4(0.5, 0.5, 0.5, 1.0);\n   \n   float t;\n   float max_t;\n   int coord;\n   \n   vec3 col;\n   if(intersect_sphere(R,S,t,max_t)) {\n      vec3 point = R.Origin + t*R.Dir;\n      vec3 roundpoint = round(point/cubeWidth)*cubeWidth;\n      \n      bool cont = true;\n      for(int i = 0; i <= 50; i++) { \n          cont = step_forward(R, t, roundpoint, coord, max_t, cubeWidth, cubesRad);\n          if(cont == false){break;}\n      }\n      if(coord <= 2){\n          if(coord == 0){ col = red; }\n          else if(coord == 1){ col = green; }\n          else if(coord == 2){ col = blue; }\n          \n          fragColor = vec4(col, 1.0);\n      }\n   }\n\n}","name":"Image","description":"","type":"image"}]}