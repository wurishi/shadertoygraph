{"ver":"0.1","info":{"id":"XdGczc","date":"1555089861","viewed":95,"name":"Julia Set Explorer 2","username":"chronosis","description":"Julia Set with orbital regions shaded based on the speed of escape\n\nDrag + Click Mouse to manually explore set values","likes":3,"published":1,"flags":16,"usePreview":0,"tags":["fractal","julia"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":3,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Non-UV-distorted version of https://www.shadertoy.com/view/MdVyWm\n\n#define textScale 26.\n#define textXOffset 0.0\n#define colorStep 48.\n#define scale 2.667\n#define itr 1024.\n#define escape 2.\n#define cen vec2(0.5, 0.5)\n#define LEN(x) dot(x,x)\n\nvec4 char(vec2 p, int c) {\n    if (p.x < .0 || p.x > 1. || p.y < 0. || p.y > 1.) return vec4(0,0,0,1e5);\n\treturn textureGrad( iChannel2, p / 16. + fract( vec2(c, 15 - c / 16) / 16. ), \n                        dFdx(p / 16.), dFdy(p / 16.) );\n}\n#define num(u,c) char(u,48+(c)).x\n\n\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\n// Madlebrot X - scaling factor\n//float scalex(float v, float s) {\n//   return (v * s) - (s * (5. / 7.));\n//}\n\nvec2 scalev(vec2 v, float s) {\n   return (v * s) - (s * 0.5);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    float mn = min(iResolution.x, iResolution.y);\n    vec2 res = iResolution.xy,\n        off = cen * res,\n        uv = .5 + ( fragCoord - off ) / mn,\n    \tm = .5 + ( iMouse.xy - off ) / mn;\n      \t\n    if (iMouse.z <= 0.) {\n        float time = iTime * 1.5;\n        m = .5 + .3 * vec2(-cos(time * .15), sin(time * .33));\n    }\n\n    // Julia/Mandlebrot is z(n) = z(n-1)^2 + c\n    // Julia: \n    //   Where z and c are points on the complex plane\n    //   z(0) is the point being drawn on the plane\n    //   c is an arbitrary point on the plane\n    // Mandlebrot:\n    //   Where z and c are points on the complex plane\n    //   z(0) is an arbitrary point on the plane usually initialized to 0 + 0i\n    //   c is the point being drawn on the plane\n    \n    // Complex numbers take the form (a + bi)\n    // Squared complex numbers take the following algebraic expansion\n    //   (x + yi) ^ 2\n\t//   ==> (x + yi)(x + yi)\n    //   ==> (x^2 + 2xyi + (yi)^2)\n    //   ==> (x^2 + 2xyi - y^2)\n    //   ==> (x^2 - y^2) + (2xy)i\n    //   ==> x' + y'i\n    // Where x' = (x^2 - y^2) and y' = 2xy\n    \n    // Julia\n    float xtemp = 0.;\n    vec2 z = scalev(uv, scale);\n    vec2 nextZ = z;\n\n    // Mandlebrot\n    //vec2 z = vec2(0.);\n\n    // Madlebrot (extended by mouse position)\n    //vec2 z = vec2(scalex(m.x, scale), scaley(m.y, scale));\n\n    float l = LEN(z);\n    float nextL = l;\n    float o = 0.;\n    float dd = 0.;\n\n    for(float i = 1.; i <= itr; i++) {\n        vec2 s = scalev(m, scale);       \n        //xtemp = (z.x * z.x) - (z.y * z.y) + s.x;\n        //z.y = (2. * z.x * z.y) + s.y;\n        //z.x = xtemp;\n        \n        // deMoivre Matrix forumlation basically does the above\n        // |  z.x z.y |   \n        // | -z.y z.x | * | z.x z.y | + s\n        //   ==> z.x = (z.x * z.x) - (z.y * -z.y)\n        //   ==> z.y = (z.x * z.y) + (z.x + z.y)\n        z = mat2(z, -z.y, z.x) * z + s;\n        nextZ = mat2(z, -z.y, z.x) * z + s;\n        l = LEN(z);\n        nextL = LEN(nextZ);\n\n        if(nextL > escape) {\n            o = i + 1.;\n            dd = (nextL - l) / escape;\n            break;            \n        }\n    }          \n    \n    vec4 col = vec4(0.);\n    float dis = distance(m, uv);\n    if (dis < 0.005) {\n        // Draw Indicator\n        col = vec4(1.);\n    }\n    else {\n        float t;\n        if (o == 0.) {\n\t        // Inside Set (Black regions)\n\t        t = dis;\n        } else {          \n        \tt = (o + dd) / float(itr / colorStep) + (0.5 * iTime);\n        }\n        vec3 cola = pal(t, vec3(0.5), vec3(0.5), vec3(1.0), vec3(0.0, 0.10, 0.20) );\n        vec3 colb = pal(t, vec3(0.5), vec3(0.5), vec3(1.0, 0.7, 0.4), vec3(0.0, 0.15, 0.20) );\n        col = vec4(mix(cola, colb, (sin(0.1 * iTime) + 1.) * 0.5), 1.0);\n        //fragColor = vec4(0.);\n    }\n\n    // This is a mess, there has to be a better way\n    vec2 zw = uv * textScale;\n    zw.x += textXOffset;\n    col += char(zw + vec2(10., -0.), 122).x;\n    col += char(zw + vec2(9.5, -0.), 40).x;\n    col += char(zw + vec2(9., -0.), 110).x;\n    col += char(zw + vec2(8.5, -0.), 41).x;\n    col += char(zw + vec2(8., -0.), 61).x;\n    col += char(zw + vec2(7.5, -0.), 122).x;\n    col += char(zw + vec2(7., -0.), 40).x;    \n    col += char(zw + vec2(6.5, -0.), 110).x;    \n    col += char(zw + vec2(6., -0.), 45).x;    \n    col += char(zw + vec2(5.5, -0.), 49).x;    \n    col += char(zw + vec2(5., -0.), 41).x;    \n    col += char(zw + vec2(4.5, -0.), 94).x;    \n    col += char(zw + vec2(4., -0.), 50).x;    \n    col += char(zw + vec2(3.5, -0.), 43).x;    \n    col += char(zw + vec2(3., -0.), 99).x;    \n    \n    col += char(zw + vec2(-30., -2.), 99).x;\n    col += char(zw + vec2(-31., -2.), 86).x;\n    col += char(zw + vec2(-31.5, -2.), 97).x;\n    col += char(zw + vec2(-32., -2.), 108).x;\n    col += char(zw + vec2(-32.5, -2.), 117).x;\n    col += char(zw + vec2(-33., -2.), 101).x;\n\n    col += char(zw + vec2(-30., -1.), 88).x;\n    col += char(zw + vec2(-30., 0.), 89).x;\n    col += char(zw + vec2(-30.5, -1.), 58).x;\n    col += char(zw + vec2(-30.5, 0.), 58).x;\n    vec2 nn = m - .5;\n    vec2 n = abs(nn);\n    if (nn.x < 0.) col += char(zw + vec2(-31., -1.), 45).x;\n    if (nn.y < 0.) col += char(zw + vec2(-31., 0.), 45).x;\n    col += num(zw + vec2(-31.5, -1.), int(floor(n.x)));\n    col += num(zw + vec2(-31.5, 0.), int(floor(n.y)));\n    col += char(zw + vec2(-32., -1.), 46).x;\n    col += char(zw + vec2(-32., 0.), 46).x;\n\n    for (float j = 0.; j < 6.; j++) {\n    \tn = fract(n) * 10.;\n\t    col += num(zw + vec2(-32.5 - (j * .5), -1.), int(floor(n.x)));\n\t    col += num(zw + vec2(-32.5 - (j * .5), 0.), int(floor(n.y)));\n    }\n    \n    // Output to screen\n    fragColor = col;\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"vec3 hsv2rgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n","name":"Common","description":"","type":"common"}]}