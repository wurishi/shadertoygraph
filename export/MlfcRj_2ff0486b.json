{"ver":"0.1","info":{"id":"MlfcRj","date":"1505430314","viewed":99,"name":"Planetary Transits","username":"aw","description":"1 - Raymarching | Buffers | Test | Introduction to Shadertoy.\nJust playing around to see how shadertoy works, trying some existing code for things I haven't used before (raymarching) and concepts I'm familiar (post-processing) with and playing around.","likes":1,"published":1,"flags":32,"usePreview":0,"tags":["test"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//\tFirst time using shadertoy.  Just experimenting with how the different pieces work, and\n//\tusing/modifying existing examples to see how things fit together, using multiple buffers, etc.\n//\n//\tStarting point was Daedelus's raymarching tutorial, as a base to work off.\n//\thttps://www.shadertoy.com/view/XlBGDW.\n//\n//\tI'm certain that these aren't the best or most efficient way to do things, but this\n//\tis definitely a fun playground and different to typical game-shader work.\n//\n//\tPost processing on a 2nd buffer.\n\n#define BUFFER iChannel0\n\n\n//\tBased on CA by https://www.shadertoy.com/view/Mds3zn.\nvec4 AddChromaticAbberation(sampler2D tex, vec2 uv)\n{\n    float strength = 0.001;\n\t\n    vec3 color;\n    color.r = texture(tex, vec2(uv.x + strength, uv.y)).r;\n    color.g = texture(tex, uv ).g;\n    color.b = texture(tex, vec2(uv.x - strength, uv.y)).b;\n\n\tcolor *= (1.0 - strength * 0.5);\n\t\n    return vec4(color, 1.0);\n}\n\n\n//\tBased on vignette by https://www.shadertoy.com/view/lsKSWR.\nvec4 AddVignette(vec4 color, vec2 uv)\n{\n    float intensity = 30.0;\n    float range = 0.15;\n    uv *=  1.0 - uv.yx;    \n    float vignette = uv.x * uv.y * intensity;\n    vignette = pow(vignette, range);\n    \n    color = vec4(color.x * vignette, color.y * vignette, color.z * vignette, 1.0);\n    return color;\n}\n\n\n//\tVignette by iq:  https://www.shadertoy.com/view/MsSSWV.\nvec4 AddNaturalVignette(vec4 color, vec2 uv)\n{\n    color *= 0.2 + 0.8*pow(16.0*uv.x*uv.y*(1.0-uv.x)*(1.0-uv.y),0.15);\n    return color;\n}\n\n\n//\tDraw to screen.\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy; \n    fragColor = AddChromaticAbberation(BUFFER, uv);\n    fragColor = AddVignette(fragColor, uv);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4sf3Rn","filepath":"/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","previewfilepath":"/media/ap/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//\tStarting point was Daedelus's raymarching tutorial, as a base for me to experiment with.\n//\tReally useful tutorial for someone who hasn't used shadertoy or raymarching before.\n//\tI've left his comments in where necessary, for future reference.\n//\thttps://www.shadertoy.com/view/XlBGDW.\n//\n//\tRaymarching, displacement testing.\n\n//\tConstants.\n#define NEAR_CLIPPING_PLANE 0.1\n#define FAR_CLIPPING_PLANE 100.0\n#define NUMBER_OF_MARCH_STEPS 150\n#define EPSILON 0.0180\n#define DISTANCE_BIAS 0.7\n\n//\tDistance to sphere function (p is world position of the ray, s is sphere radius)\n//\tfrom https://iquilezles.org/articles/distfunctions.\nfloat sdSphere(vec3 p, float s)\n{\n\treturn length(p) - s;\n}\n\n\n//\tUse the distance to sphere function to generate an area glow around\n//\tthe sphere.\nfloat sdSphereGlow(vec3 p, float s)\n{\n    return sdSphere(p, s * 1.4);\n} \n\n\nfloat fmod(float a, float b)\n{\n    if(a < 0.0)\n    {\n        return b - mod(abs(a), b);\n    }\n    return mod(a, b);\n}\n\n\n//\tI'm sure this isn't the way to to it, but given this is my first time writing a raymarched shader,\n//  it's the way I'm doing it lol.  This will return the distance, material, and glow of color\n//\t(which should allow me to add glows to the planets in a hacky way).\nvec3 scene(vec3 position)\n{\n    /*\n\tThis function generates a distance to the given position\n\tThe distance is the closest point in the world to that position\n\t*/\n    //\tTo move the sphere one unit forward, we must subtract that translation from the world position\n    vec3 translate = vec3(0.0, -0.5, 1.0);\n    vec2 res = vec2(1.0, 1.0);\n    float glow = 0.0;\n\t\n    float distance1 = sdSphere(position - translate, 0.5);\n    float distance = sdSphere(position - translate, 0.5);\n    \n    //\tApply displacement if we are on a portion of the sphere.\n    //\tAlso from https://iquilezles.org/articles/distfunctions.\n    float time = iTime * 3.0;\n    if(distance < 2.0)\n    {\n    \tdistance += sin(iTime * 0.5) * 0.08 * sin(time + 50.0 * (position.x - translate.x)) * sin(50.0 * (position.y - translate.y)) * sin(50.0 * (position.z - translate.z));   \n    }\n\n\tfloat materialID = 1.0;\n    float orbitScale = 0.8;\n    float orbitTime = iTime * 0.5;\n    \n    translate = vec3(sin(orbitTime) * orbitScale, -0.5, (cos(orbitTime) + 1.0) * orbitScale);\n\n    vec3 sphere_pos = position - translate;\n    float distance2 = sdSphere(sphere_pos, 0.06);\n\tfloat materialID2 = 2.0; // the second sphere should have another colour\n    \n    //\tTo combine two objects we use the minimum distance\n    if(distance2 < distance)\n    {\n\t\tdistance = distance2;\n        materialID = materialID2;     \n    }\n    \n    float planetGlow = sdSphereGlow(sphere_pos, 0.37);\n    if(planetGlow <= 0.1 && planetGlow >= -0.3)\n    {\n\t\tglow = 1.0 - planetGlow * 10.0;\n    }\n\n    \n    orbitScale = 1.5;\n    orbitTime = iTime * 0.25;\n    \n    translate = vec3(sin(orbitTime) * orbitScale, -0.5, (cos(orbitTime) + 1.0) * orbitScale);\n\n    sphere_pos = position - translate;\n    float distance3 = sdSphere(sphere_pos, 0.01);\n\tfloat materialID3 = 3.0; // the second sphere should have another colour\n    \n    //\tTo combine three objects we compare the minimum distance.  However, if we don't do this,\n    //\tit generates a really interesting effect.\n    //if(distance3 < distance2 && distance3 < distance1)\n    if(distance3 < distance2)\n    {\n\t\tdistance = distance3;\n        materialID = materialID3;\n    }\n    \n    //\tWe return a vec2 packing the distance and material of the closes object together\n    return vec3(distance, materialID, glow);\n}\n\n\nvec3 raymarch(vec3 position, vec3 direction)\n{\n\t//\tThis function iteratively analyses the scene to approximate the closest ray-hit\n    //\tWe track how far we have moved so we can reconstruct the end-point later\n    float total_distance = NEAR_CLIPPING_PLANE;\n    for(int i = 0 ; i < NUMBER_OF_MARCH_STEPS ; ++i)\n    {\n        vec3 result = scene(position + direction * total_distance);\n        //\tIf our ray is very close to a surface we assume we hit it\n        //\tand return it's material\n        if(result.x < EPSILON)\n        {\n            return vec3(total_distance, result.y, result.z);\n        }\n        \n        // Accumulate distance traveled\n        // The result.x contains closest distance to the world\n        // so we can be sure that if we move it that far we will not accidentally\n        // end up inside an object. Due to imprecision we do increase the distance\n        // by slightly less... it avoids normal errors especially.\n        total_distance += result.x * DISTANCE_BIAS;\n        \n        // Stop if we are headed for infinity\n        if(total_distance > FAR_CLIPPING_PLANE)\n            break;\n    }\n    // By default we return no material and the furthest possible distance\n    // We only reach this point if we didn't get close to a surface during the loop above\n    return vec3(FAR_CLIPPING_PLANE, 0.0, 0.0);\n}\n\n\n//\tCalculate the normals.\nvec3 normal(vec3 ray_hit_position, float smoothness)\n{\t\n    //\tFrom https://www.shadertoy.com/view/MdSGDW\n\tvec3 n;\n\tvec2 dn = vec2(smoothness, 0.0);\n\tn.x\t= scene(ray_hit_position + dn.xyy).x - scene(ray_hit_position - dn.xyy).x;\n\tn.y\t= scene(ray_hit_position + dn.yxy).x - scene(ray_hit_position - dn.yxy).x;\n\tn.z\t= scene(ray_hit_position + dn.yyx).x - scene(ray_hit_position - dn.yyx).x;\n\treturn normalize(n);\n}\n\n\n//\tDraw to buffer.\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 originalUV = fragCoord.xy / iResolution.xy;\n    \n    // Given the pixel X, Y coordinate and the resolution we can get 0-1 UV space\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    // Our rays should shoot left and right, so we move the 0-1 space and make it -1 to 1\n    uv = uv * 2.0 - 1.0;\n    // Last we deal with an aspect ratio in the window, to make sure our results are square\n    // we must correct the X coordinate by the stretching of the resolution\n    uv.x *= iResolution.x / iResolution.y;\n    vec3 direction = normalize(vec3(uv, 3.5));\n    \n    // if you rotate the direction with a rotation matrix you can turn the camera to!    \n    vec3 camera_origin = vec3(0.0, -0.4, -2.5); // you can move the camera here\n    \n    \n    vec3 result = raymarch(camera_origin, direction); // this raymarches the scene\n    \n    // arbitrary fog to hide artifacts near the far plane\n    // 1.0 / distance results in a nice fog that starts white\n    // but if distance is 0 \n    float fog = pow(1.0 / (1.0 + result.x), 0.45) + 0.1;\n    \n    //\tBackground fog.\n    if(result.y == 0.0)\n    {\n\t\tfog = 1.0;   \n    }\n    \n    //\tBackground.\n    vec3 time = vec3(sin(iTime * 0.3) * 0.5, cos(iTime * 0.3), 0.5);\n    float brightness = 0.25;\n    vec3 backgroundColor = vec3(time.x * brightness, time.y * brightness, brightness);\n    \n    //\tNow let's pick a color\n    vec3 materialColor = vec3(0.0, 0.0, 0.0);\n    if(result.y == 1.0)\n    {\n        materialColor = vec3(0.0, 1.0, 0.851);\n    }\n    if(result.y == 2.0)\n    {\n       \tmaterialColor = vec3(0.4);\n    }\n    if(result.y == 3.0)\n    {\n       \tmaterialColor = vec3(1.9);\n    }\n    \n    //\tBackground.\n    if(result.y == 0.0)\n    {\n        vec3 backgroundTexture = texture(iChannel0, uv * vec2(2)).rgb;\n        if(backgroundTexture.r > 0.93)\n        {\n            float col = clamp(backgroundTexture.r * sin(iTime) * uv.x * (1.0 / uv.y), 0.25, 0.3);\n            materialColor = vec3(col);\n        }\n        else\n        {\n        \tmaterialColor = backgroundColor;\n        }\n    }\n    \n    if(result.z > 0.0)\n    {\n        float strength = 0.2;\n        float adjustment = clamp(result.z * strength, 0.0, 0.5);\n        materialColor -= vec3(adjustment, adjustment + 0.1, adjustment);\n    }\n    \n    //\tWe can reconstruct the intersection point using the distance and original ray\n    vec3 intersection = camera_origin + direction * result.x;\n    \n    //\tThe normals can be retrieved in a fast way\n    //\tby taking samples close to the end-result sample\n    //\ttheir resulting distances to the world are used to see how the surface curves in 3D\n    //\tThis math I always steal from somewhere ;)\n    vec3 nrml = normal(intersection, 0.01);\n    \n    //\tLambert lighting is the dot product of a directional light and the normal\n    vec3 light_dir = normalize(vec3(0.0, 1.0, 0.0));\n   \tfloat diffuse = dot(light_dir, nrml);\n    \n    //\tWrap the lighting around\n    //\thttps://developer.valvesoftware.com/wiki/Half_Lambert\n    diffuse = diffuse * 0.5 + 0.5;\n\n    vec3 light_color = vec3(1.4, 1.2, 0.7);\n    vec3 ambient_color = vec3(0.2, 0.45, 0.6);\n    vec3 diffuseLit = materialColor * (diffuse * light_color + ambient_color);\n\n\tfragColor = vec4(diffuseLit, 1.0) * fog; /* applying the fog last */\n}\n","name":"Buf A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"//\tFXAA on the buffer.  First time using shadertoy.\n\n#define BUFFER iChannel0\n#define FXAA_SPAN_MAX 8.0\n#define FXAA_REDUCE_MUL   (1.0/FXAA_SPAN_MAX)\n#define FXAA_REDUCE_MIN   (1.0/128.0)\n#define FXAA_SUBPIX_SHIFT (1.0/4.0)\n\n\n//\tFXAA shader from https://www.shadertoy.com/view/ls3GWS.\nvec3 FxaaPixelShader( vec4 uv, sampler2D tex, vec2 rcpFrame)\n{    \n    vec3 rgbNW = textureLod(tex, uv.zw, 0.0).xyz;\n    vec3 rgbNE = textureLod(tex, uv.zw + vec2(1,0)*rcpFrame.xy, 0.0).xyz;\n    vec3 rgbSW = textureLod(tex, uv.zw + vec2(0,1)*rcpFrame.xy, 0.0).xyz;\n    vec3 rgbSE = textureLod(tex, uv.zw + vec2(1,1)*rcpFrame.xy, 0.0).xyz;\n    vec3 rgbM  = textureLod(tex, uv.xy, 0.0).xyz;\n\n    vec3 luma = vec3(0.299, 0.587, 0.114);\n    float lumaNW = dot(rgbNW, luma);\n    float lumaNE = dot(rgbNE, luma);\n    float lumaSW = dot(rgbSW, luma);\n    float lumaSE = dot(rgbSE, luma);\n    float lumaM  = dot(rgbM,  luma);\n\n    float lumaMin = min(lumaM, min(min(lumaNW, lumaNE), min(lumaSW, lumaSE)));\n    float lumaMax = max(lumaM, max(max(lumaNW, lumaNE), max(lumaSW, lumaSE)));\n\n    vec2 dir;\n    dir.x = -((lumaNW + lumaNE) - (lumaSW + lumaSE));\n    dir.y =  ((lumaNW + lumaSW) - (lumaNE + lumaSE));\n\n    float dirReduce = max(\n        (lumaNW + lumaNE + lumaSW + lumaSE) * (0.25 * FXAA_REDUCE_MUL),\n        FXAA_REDUCE_MIN);\n    float rcpDirMin = 1.0/(min(abs(dir.x), abs(dir.y)) + dirReduce);\n    \n    dir = min(vec2( FXAA_SPAN_MAX,  FXAA_SPAN_MAX),\n          max(vec2(-FXAA_SPAN_MAX, -FXAA_SPAN_MAX),\n          dir * rcpDirMin)) * rcpFrame.xy;\n\n    vec3 rgbA = (1.0/2.0) * (\n        textureLod(tex, uv.xy + dir * (1.0/3.0 - 0.5), 0.0).xyz +\n        textureLod(tex, uv.xy + dir * (2.0/3.0 - 0.5), 0.0).xyz);\n    vec3 rgbB = rgbA * (1.0/2.0) + (1.0/4.0) * (\n        textureLod(tex, uv.xy + dir * (0.0/3.0 - 0.5), 0.0).xyz +\n        textureLod(tex, uv.xy + dir * (3.0/3.0 - 0.5), 0.0).xyz);\n    \n    float lumaB = dot(rgbB, luma);\n\n    if((lumaB < lumaMin) || (lumaB > lumaMax)) return rgbA;\n    \n    return rgbB; \n}\n\n\n//\tDraw to buffer.\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 rcpFrame = 1./iResolution.xy;\n    vec4 uv2 = vec4(uv, uv - (rcpFrame * (0.5 + FXAA_SUBPIX_SHIFT)));\n    fragColor.xyz = FxaaPixelShader(uv2, BUFFER, 1./iResolution.xy);\n}","name":"Buf B","description":"","type":"buffer"}]}