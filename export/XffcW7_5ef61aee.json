{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[{"channel":0,"type":"cubemap","id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"}},{"channel":1,"type":"music","id":"XdfGzn","filepath":"/media/a/894a09f482fb9b2822c093630fc37f0ce6cfec02b652e4e341323e4b6e4a4543.mp3","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"code":"/* \n    Xyphora\n\n    Net of beings having a party. This project took me almost 5 years to complete. \n    From it’s first sketch and scenes, stalling for years and now decided to recreate \n    it from sketch in a few days, with a fresh mind and much more experience. \n    It’s a tribute to @alexgreycosm “Net of Beings” who has been vastly influential \n    not only to me, as well many of my own visions of hyperdimensional realms. \n\n    \n    Always wanted to have a good head model in this and recently found the awesome head SDF \n    by tdhooper https://www.shadertoy.com/view/wlf3WX which looks way better \n    than any of my own attempts. \n\n    Creative Commons Licence Attribution-NonCommercial-ShareAlike \n\n    phreax/jiagual 2024\n\n*/\n\n#define PI 3.141592\n#define TAU (2.*PI)\n#define SIN(x) (sin(x)*.5+.5)\n#define BUMP_EPS 0.004\n#define sabsk(x, k) sqrt(x * x + k * k)\n#define sabs(x) (sabsk(x, .5))\n#define S(a, b, x) smoothstep(a, b, x) \n#define F(t0, d) S(t0, t0+d, iTime)\n#define BPM (145./60.)\n#define sat(x) (clamp(x, 0., 1.))\n#define tBpm (iTime/BPM)\n\nfloat tt, g_mat;\nvec3 ro;\n\n\nfloat rect( vec2 p, vec2 b, float r ) {\n    vec2 d = abs(p) - (b - r);\n    return length(max(d, 0.)) + min(max(d.x, d.y), 0.) - r;\n}\n\nfloat tickTack(float time, float period) {\n    return smoothstep(.2, .8,sin(time*(2.*PI)*period)*.5+.5);\n}\n\nfloat fadeLin(float t1, float t2) {\n    return sat((iTime - t1) / (t2 - t1));\n}\n\n// Sequencing\nfloat sIntro, sSunrise, sBright, sHeadsTick, sAnimateHeads, sDistort,\n      sCamRotate, sCamRotateX, sCamRotateY, sCamRotateZ, sCamUpDown, sCamZ, sCamTick, sCamOrbit, sFocal, sCamBetween,\n      sTorusHeight, sHeight, sSpacing, sTorusRadius, sFlash, sFaster, sSplitCenter, sWarp,\n      sWave,\n      st;\n      \nint scene;\n  \n// check for scene\nfloat sc(int n) {\n    return float(n==scene);\n}\n\n// check if greater/equal than scene\nfloat scg(int n) {\n    return float(scene >= n);\n}\n\nvoid initScenes() {\n\n\n    // intro 0-1\n    \n    sIntro = 0.;\n    st = 0.;\n    sFlash = 0.;\n    sTorusHeight = 2.2;\n    sIntro = 0.0;\n    sSunrise = 0.0;\n    sBright = 0.0;\n    sHeadsTick = 0.0;\n    sAnimateHeads = 0.0;\n    sCamUpDown = 0.0;\n    sCamTick = 0.0;\n    sCamOrbit = 0.0;\n    sCamZ = 2.;\n    sCamRotate = 0.0;\n    sCamRotateX = 0.0;\n    sCamRotateY = 0.0;\n    sCamRotateZ = 0.0;\n    sCamBetween = 0.0;\n    sFocal = .8;\n    sSpacing = 3.0;\n    sTorusRadius = 0.0;\n    sSplitCenter = 0.0;\n    sFaster = 0.0;\n    sWarp = 0.;\n    sDistort = 0.;\n    sHeight = .9;\n    sWave = 0.;\n    st = 0.0;\n    scene = 0;\n    \n    sIntro = S(0., 1., iTime);\n    sSunrise = S(10., 11., iTime);\n    sFocal = mix(.4, .8, sIntro);\n    sBright = S(35., 36., iTime);\n    \n   \n    float from = 0., to = 0.;\n    \n    tt += 2.*F(13., .5) +  2.*F(16., .5) + 2.*F(19.5, .5);\n    if(iTime <= 1.) {\n        scene = 0;\n        from = 0.;\n        to = 1.;\n        st = fadeLin(from, to);\n        sCamOrbit = 1.;\n        sAnimateHeads = 1.;\n        sCamTick = 0.;\n        \n    } else if(iTime < 9.8) {\n        scene = 1;\n        from = 1.;\n        to = 11.;\n        st = fadeLin(from, to);\n        sCamOrbit = 1.;\n  \n        sAnimateHeads = 1.;\n    } else if(iTime < 23.) {\n        scene = 2;\n        sSunrise *= 1.-.9*SIN(PI+tBpm*4.);\n        \n        from = 9.8;\n        to = 23.;\n        scene = 2;\n        sCamOrbit = 1.;\n        sCamBetween = 0.;\n        sAnimateHeads = 1.;\n        \n        sCamRotateX = 1.;\n        sCamRotateY = 1.;\n        sFocal = .7;\n \n        sCamZ = mix(sCamZ, 7.8, F(from, 0.));\n               \n    } else if(iTime < 36.) {\n        scene = 3;\n        sAnimateHeads = 1.;\n        sCamOrbit = 0.;\n        sCamBetween = 1.;\n        sHeadsTick = 1.;\n        sFlash = 0.;\n        sSunrise = 1.;\n        sCamZ = 3.;\n        sCamUpDown = 1.;\n        sCamRotateZ = S(29.5, 33., iTime);\n        sCamRotateX = F(33., 3.);\n    \n        sCamTick = F(26., .0);\n   \n    } else if(iTime < 42.) {\n    \n        sCamTick = 1.;\n        scene = 4;\n        sAnimateHeads = 1.;\n        sCamOrbit = 0.;\n        sCamBetween = 1.;\n        sHeadsTick = 1.;\n        sFlash = 1.;\n        sCamZ = 3.;\n        sCamRotate = 1.;\n        sFocal -= .4*SIN(.8*tt);\n        sCamUpDown = 1.;  \n        sCamRotateX = F(39., 3.);\n     \n      //  sCamRotateZ = cos(tBpm);\n\n    } else if(iTime < 48.7) {\n        //sSpacing = 6.2;\n        from = 42.;\n        sCamTick = 1.;\n        scene = 5;\n        sAnimateHeads = 1.;\n       // sCamOrbit = 1.;\n        sCamBetween = 1.;\n        sHeadsTick = 1.;\n        sFlash = 1.;\n        sCamZ = 3.;\n        sCamRotate = 1.;\n        sFocal -= .4*SIN(.8*tt);\n        sCamUpDown = 1.;  \n        sDistort = F(from, 2.);\n        sCamRotateX = F(45.5, 3.)*.5;\n\n          \n    } else if(iTime < 62.) {\n        sCamRotateX = (1.-F(62., 2.))*.5;\n        sCamRotateY = .5;\n        //sSpacing = 6.2;\n         from = 47.8;\n        sCamTick = 1.;\n        scene = 6;\n        sAnimateHeads = 1.;\n       // sCamOrbit = 1.;\n        sCamBetween = 1.;\n        sHeadsTick = 1.;\n        sFlash = 1.;\n        sCamZ = 3.;\n        sCamRotate = 1.;\n        sFocal -= .4*SIN(.8*tt);\n        sCamUpDown = 1.;  \n        sWarp = F(from, .4);\n        sDistort = 1.;\n        \n    } else if(iTime < 78.) {\n        scene = 7;\n        sAnimateHeads = 1.;\n        sCamOrbit = 1.;\n        sWarp = 1.;\n        sFocal = .5;\n        sBright = 0.;\n        sSunrise = .1;\n        sCamRotateX = sCamRotateY= F(78., 3.);     \n    } else if(iTime < 105.) {\n        scene = 8;\n        from = 78.;\n        sBright = sSunrise = F(78., 1.);\n        sCamOrbit = 1.;\n        sHeadsTick = 1.;\n        sFlash = 1.;\n        sCamZ = 7.8;\n     //   sSpacing = 6.2;\n        sTorusHeight = 1.4;\n        sFocal = .5;\n        sHeight = mix(.9, .5, F(from, 3.));;\n        sDistort = .2*F(from+3., 3.);\n        sWave = 1.;\n        \n        sAnimateHeads = 1.;\n       \n                 \n    } else {\n        sAnimateHeads = 1.;\n    }\n      \n}\n\nvoid cam(inout vec3 p) {\n\n   // p.z -= tt;\n   p.x += 1.5*sCamBetween;  // in between columns\n\n\n   p.xz *= rot(-.3*tt * sCamOrbit);\n   \n   p.xz *= rot(PI*sCamRotateZ);\n   \n   p.x -= 3.*sCamRotateZ;\n   p.z -= 7.4*sin(PI/2.+tBpm)*sCamTick;\n\n}\n\n\n\n// from https://mercury.sexy/hg_sdf/\nfloat pModPolar(inout vec2 p, float repetitions) {\n\tfloat angle = 2.*PI/repetitions;\n\tfloat a = atan(p.y, p.x) + angle/2.;\n\tfloat r = length(p);\n\tfloat c = floor(a/angle);\n\ta = mod(a,angle) - angle/2.;\n\tp = vec2(cos(a), sin(a))*r;\n\t// For an odd number of repetitions, fix cell index of the cell in -x direction\n\t// (cell index would be e.g. -5 and 5 in the two halves of the cell):\n\tif (abs(c) >= (repetitions/2.)) c = abs(c);\n\treturn c;\n}\n\n\n\nfloat box(vec3 p, vec3 r) {\n  vec3 d = abs(p) - r;\n  return length(max(d, 0.0)) + min(max(d.x, max(d.y, d.z)), 0.0);\n}\n\n\nfloat smin(float a, float b, float k) {\n  float h = clamp((a-b)/k * .5 + .5, 0.0, 1.0);\n  return mix(a, b, h) - h*(1.-h)*k;\n}\n\n\n\nfloat pMod(inout float p, float size) {\n\tfloat halfsize = size*0.5;\n\tfloat c = floor((p + halfsize)/size);\n\tp = mod(p + halfsize, size) - halfsize;\n\treturn c;\n}\n\n\nfloat n21(vec2 p) {\n      return fract(sin(dot(p, vec2(524.423,123.34)))*3228324.345);\n}\n\n// smooth noise\nfloat noise(vec2 n) {\n    const vec2 d = vec2(0., 1.0);\n    vec2 b = floor(n);\n    vec2 f = mix(vec2(0.0), vec2(1.0), fract(n));\n    return mix(mix(n21(b), n21(b + d.yx), f.x), mix(n21(b + d.xy), n21(b + d.yy), f.x), f.y);\n}\n\nfloat g_glow;\n\nvoid pR(inout vec2 p, float a) {\n    p = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\nvec2 pRi(vec2 p, float a) {\n    pR(p, a);\n    return p;\n}\n\n#define saturate(x) clamp(x, 0., 1.)\n\nfloat vmax(vec2 v) {\n    return max(v.x, v.y);\n}\n\nfloat vmax(vec3 v) {\n    return max(max(v.x, v.y), v.z);\n}\n\nfloat vmin(vec3 v) {\n    return min(min(v.x, v.y), v.z);\n}\n\nfloat vmin(vec2 v) {\n    return min(v.x, v.y);\n}\n\nfloat fBox(vec3 p, vec3 b) {\n    vec3 d = abs(p) - b;\n    return length(max(d, vec3(0))) + vmax(min(d, vec3(0)));\n}\n\nfloat fCorner2(vec2 p) {\n    return length(max(p, vec2(0))) + vmax(min(p, vec2(0)));\n}\n\nfloat fDisc(vec3 p, float r) {\n    float l = length(p.xz) - r;\n    return l < 0. ? abs(p.y) : length(vec2(p.y, l));\n}\n\n// IQ https://www.shadertoy.com/view/Xds3zN\nfloat sdRoundCone( in vec3 p, in float r1, float r2, float h )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    \n    float b = (r1-r2)/h;\n    float a = sqrt(1.0-b*b);\n    float k = dot(q,vec2(-b,a));\n    \n    if( k < 0.0 ) return length(q) - r1;\n    if( k > a*h ) return length(q-vec2(0.0,h)) - r2;\n        \n    return dot(q, vec2(a,b) ) - r1;\n}\n\nfloat smin2(float a, float b, float r) {\n    vec2 u = max(vec2(r - a,r - b), vec2(0));\n    return max(r, min (a, b)) - length(u);\n}\n\nfloat smax2(float a, float b, float r) {\n    vec2 u = max(vec2(r + a,r + b), vec2(0));\n    return min(-r, max (a, b)) + length(u);\n}\n\n\nfloat smax(float a, float b, float k) {\n    return -smin(-a, -b, k);\n}\n\nfloat smin3(float a, float b, float k){\n    return min(\n        smin(a, b, k),\n        smin2(a, b, k)\n    );\n}\n\nfloat smax3(float a, float b, float k){\n    return max(\n        smax(a, b, k),\n        smax2(a, b, k)\n    );\n}\n\n\nfloat ellip(vec3 p, vec3 s) {\n    float r = vmin(s);\n    p *= r / s;\n    return length(p) - r;\n}\n\nfloat ellip(vec2 p, vec2 s) {\n    float r = vmin(s);\n    p *= r / s;\n    return length(p) - r;\n}\n\nfloat fCylinder(vec3 p, float r, float height) {\n\tfloat d = length(p.xz) - r;\n\td = max(d, abs(p.y) - height);\n\treturn d;\n}\n\nfloat curve(float t, float d) {\n  float off = .25;\n  t = ((t-off)/d);\n  return mix(floor(t), floor(t)+1., pow(smoothstep(0.,1.,fract(t)), 20.));\n}\n\nbool isEye = false;\n\n\n\nvec3 transformHeads(vec3 p) {\n\n    p.xz *= rot(-PI/2.);\n\n\n    float w = mix(-.15, 0.04, S(.5, 2.5, iTime));\n    //  p.x *= 2.;\n    \n    //w = mix(-0.2, .1, 1.-SIN(5.*tt));\n    p.x = sabsk(p.x, .1) - w;\n\n    p.xz *= rot(PI/2.);\n\n    p.x = sabsk(p.x, .1) - w;\n\n    //p.x = sabsk(p.x, .2) +.15;\n    // p.xz *= rot(PI/2.);\n\n    p.xz *= rot(PI/4.);\n\n    p.y *= .9;\n   // p.x *= .9;\n    p.z *= mix(1.1, 1., S(-.5, .0, p.y));\n      //  p.x += abs(SIN(p.y*20.+3.*tt)*.01);\n    return p;\n}\n\nvec3 headUpDown(vec3 p) {\n     p.yz *= rot(.2*SIN(tBpm*4.)*sAnimateHeads);\n     return p;\n}\n\nfloat mHead(vec3 p, vec2 tileId) {\n\n    \n    vec3 p0 = p;\n\n    float f = length(p);\n    float t1 = mix(BPM, BPM/2., scg(2));\n    float headRot = curve(tt, t1);\n\n    float dir = sign(tileId.x-.5);\n    headRot = mix(headRot, .5*tickTack(iTime, BPM/2.), sHeadsTick); \n    p.xz *= rot(dir*PI/2.*headRot*sAnimateHeads);\n\n    //   p.xz *= rot(5.*p.y*SIN(5.*tt));\n    //   p *= 1.5;\n    p = transformHeads(p);\n\n    //  pR(p.yz, .05-.3*SIN(PI/2.*curve(tt, 1.)));\n    p = headUpDown(p);\n\n    p.y -= .11;\n\n\n    vec3 pa = p;\n    vec3 ps = p;\n    ps.x = sqrt(ps.x * ps.x + .0005);\n    p.x = abs(p.x);\n    vec3 pp = p;\n\n    float d = 1e12;\n\n    // skull back\n    p += vec3(0,-.135,.09);\n    d = ellip(p, vec3(.395, .385, .395));\n\n    // skull base\n    p = pp;\n    p += vec3(0,-.135,.09) + vec3(0,.1,.07);\n    d = smin(d, ellip(p, vec3(.38, .36, .35)), .05);\n\n    // forehead\n    p = pp;\n    p += vec3(0,-.145,-.175);\n    d = smin(d, ellip(p, vec3(.315, .3, .33)), .18);\n\n    p = pp;\n    pR(p.yz, -.5);\n    float bb = fBox(p, vec3(.5,.67,.7));\n    d = smax(d, bb, .2);\n\n    // face base\n    p = pp;\n    p += vec3(0,.25,-.13);\n    d = smin(d, length(p) - .28, .1);\n\n    // behind ear\n    p = ps;\n    p += vec3(-.15,.13,.06);\n   // d = smin(d, ellip(p, vec3(.15,.15,.15)), .15);\n\n    p = ps;\n    p += vec3(-.07,.18,.1);\n    d = smin(d, length(p) - .2, .18);\n\n    // cheek base\n    p = pp;\n    p += vec3(-.2,.12,-.14);\n    d = smin(d, ellip(p, vec3(.15,.22,.2) * .8), .15);\n\n    // jaw base\n    p = pp;\n    p += vec3(0,.475,-.16);\n    pR(p.yz, .8);\n    d = smin(d, ellip(p, vec3(.19,.1,.2)), .1);\n    \n    // brow\n    p = pp;\n    p += vec3(0,-.0,-.18);\n    vec3 bp = p;\n    float brow = length(p) - .36;\n    p.x -= .37;\n    brow = smax(brow, dot(p, normalize(vec3(1,.2,-.2))), .2);\n    p = bp;\n    brow = smax(brow, dot(p, normalize(vec3(0,.6,1))) - .43, .25);\n    p = bp;\n    pR(p.yz, -.5);\n    float peak = -p.y - .165;\n    peak += smoothstep(.0, .2, p.x) * .01;\n    peak -= smoothstep(.12, .29, p.x) * .025;\n    brow = smax(brow, peak, .07);\n    p = bp;\n    pR(p.yz, .5);\n    brow = smax(brow, -p.y - .06, .15);\n    d = smin(d, brow, .06);\n\n    // jaw\n\n    vec3 jo = vec3(-.25,.4,-.07);\n    p = ps + jo;\n    float jaw = dot(p, normalize(vec3(1,-.2,-.05))) - .069;\n    jaw = smax(jaw, dot(p, normalize(vec3(.5,-.25,.35))) - .13, .12);\n    jaw = smax(jaw, dot(p, normalize(vec3(-.0,-1.,-.8))) - .12, .15);\n    jaw = smax(jaw, dot(p, normalize(vec3(.98,-1.,.15))) - .13, .08);\n    jaw = smax(jaw, dot(p, normalize(vec3(.6,-.2,-.45))) - .19, .15);\n    jaw = smax(jaw, dot(p, normalize(vec3(.5,.1,-.5))) - .26, .15);\n    jaw = smax(jaw, dot(p, normalize(vec3(1,.2,-.3))) - .22, .15);\n\n    p = pp;\n    p += vec3(0,.63,-.2);\n    pR(p.yz, .15);\n    float cr = .5;\n    jaw = smax(jaw, length(p.xy - vec2(0,cr)) - cr, .05);\n\n    p = pp + jo;\n    jaw = smax(jaw, dot(p, normalize(vec3(0,-.4,1))) - .35, .1);\n    jaw = smax(jaw, dot(p, normalize(vec3(0,1.5,2))) - .3, .2);\n    jaw = max(jaw, length(pp + vec3(0,.6,-.3)) - .7);\n\n    p = pa;\n    p += vec3(.2,.5,-.1);\n    float jb = length(p);\n    jb = smoothstep(.0, .4, jb);\n    float js = mix(0., -.005, jb);\n    jb = mix(.01, .04, jb);\n\n    d = smin(d, jaw - js, jb);\n\n    // chin\n    p = pp;\n    p += vec3(0,.585,-.395);\n    p.x *= .7;\n    d = smin(d, ellip(p, vec3(.028,.028,.028)*1.2), .15);\n\n    // nose\n    p = pp;\n    p += vec3(0,.03,-.45);\n    pR(p.yz, 3.);\n    d = smin(d, sdRoundCone(p, .008, .05, .18), .1);\n\n    p = pp;\n    p += vec3(0,.06,-.47);\n    pR(p.yz, 2.77);\n    d = smin(d, sdRoundCone(p, .005, .04, .225), .05);\n\n    // cheek\n    p = pp;\n    p += vec3(-.2,.2,-.28);\n    pR(p.xz, .5);\n    pR(p.yz, .4);\n    float ch = ellip(p, vec3(.1,.1,.12)*1.05);\n    d = smin(d, ch, .1);\n\n    p = pp;\n    p += vec3(-.26,.02,-.1);\n    pR(p.xz, .13);\n    pR(p.yz, .5);\n    float temple = ellip(p, vec3(.1,.1,.15));\n    temple = smax(temple, p.x - .07, .1);\n    d = smin(d, temple, .1);\n\n    p = pp;\n    p += vec3(.0,.2,-.32);\n    ch = ellip(p, vec3(.1,.08,.1));\n    d = smin(d, ch, .1);\n\n    p = pp;\n    p += vec3(-.17,.31,-.17);\n    ch = ellip(p, vec3(.1));\n    d = smin(d, ch, .1);\n\n    // mouth base\n    p = pp;\n    p += vec3(-.0,.29,-.29);\n    pR(p.yz, -.3);\n    d = smin(d, ellip(p, vec3(.13,.15,.1)), .18);\n\n    p = pp;\n    p += vec3(0,.37,-.4);\n    d = smin(d, ellip(p, vec3(.03,.03,.02) * .5), .1);\n\n    p = pp;\n    p += vec3(-.09,.37,-.31);\n    d = smin(d, ellip(p, vec3(.04)), .18);\n\n    // bottom lip\n    p = pp;\n    p += vec3(0,.455,-.455);\n    p.z += smoothstep(.0, .2, p.x) * .05;\n    float lb = mix(.035, .03, smoothstep(.05, .15, length(p)));\n    vec3 ls = vec3(.055,.028,.022) * 1.25;\n    float w = .192;\n    vec2 pl2 = vec2(p.x, length(p.yz * vec2(.79,1)));\n    float bottomlip = length(pl2 + vec2(0,w-ls.z)) - w;\n    bottomlip = smax(bottomlip, length(pl2 - vec2(0,w-ls.z)) - w, .055);\n    d = smin(d, bottomlip, lb);\n    \n    // top lip\n    p = pp;\n    p += vec3(0,.38,-.45);\n    pR(p.xz, -.3);\n    ls = vec3(.065,.03,.05);\n    w = ls.x * (-log(ls.y/ls.x) + 1.);\n    vec3 pl = p * vec3(.78,1,1);\n    float toplip = length(pl + vec3(0,w-ls.y,0)) - w;\n    toplip = smax(toplip, length(pl - vec3(0,w-ls.y,0)) - w, .055);\n    p = pp;\n    p += vec3(0,.33,-.45);\n    pR(p.yz, .7);\n    float cut;\n    cut = dot(p, normalize(vec3(.5,.25,0))) - .056;\n    float dip = smin(\n        dot(p, normalize(vec3(-.5,.5,0))) + .005,\n        dot(p, normalize(vec3(.5,.5,0))) + .005,\n        .025\n    );\n    cut = smax(cut, dip, .00);\n    cut = smax(cut, p.x - .1, .05);\n    toplip = smax(toplip, cut, .02);\n\n    d = smin(d, toplip, .07);\n\n    // seam\n    p = pp;\n    p += vec3(0,.425,-.44);\n    lb = length(p);\n    float lr = mix(.04, .02, smoothstep(.05, .12, lb));\n    pR(p.yz, .1);\n    p.y -= smoothstep(0., .03, p.x) * .002;\n    p.y += smoothstep(.03, .1, p.x) * .007;\n    p.z -= .133;\n    float seam = fDisc(p, .2);\n    seam = smax(seam, -d - .015, .01); // fix inside shape\n    d = mix(d, smax(d, -seam, lr), .65);\n\n    // nostrils base\n    p = pp;\n    p += vec3(0,.3,-.43);\n    d = smin(d, length(p) - .05, .07);\n\n    // nostrils\n    p = pp;\n    p += vec3(0,.27,-.52);\n    pR(p.yz, .2);\n    float nostrils = ellip(p, vec3(.055,.05,.06));\n\n    p = pp;\n    p += vec3(-.043,.28,-.48);\n    pR(p.xy, .15);\n    p.z *= .8;\n    nostrils = smin(nostrils, sdRoundCone(p, .042, .0, .12), .02);\n\n    d = smin(d, nostrils, .02);\n\n    p = pp;\n    p += vec3(-.033,.3,-.515);\n    pR(p.xz, .5);\n    d = smax(d, -ellip(p, vec3(.011,.03,.025)), .015);\n\n    //return d;\n\n    // eyelids\n    p = pp;\n    p += vec3(-.16,.07,-.34);\n    float eyelids = ellip(p, vec3(.08,.1,.1));\n\n    p = pp;\n    p += vec3(-.16,.09,-.35);\n    float eyelids2 = ellip(p, vec3(.09,.1,.07));\n\n    // edge top\n    p = pp;\n    p += vec3(-.173,.148,-.43);\n    p.x *= .97;\n    float et = length(p.xy) - .09;\n\n    // edge bottom\n    p = pp;\n    p += vec3(-.168,.105,-.43);\n    p.x *= .9;\n    float eb = dot(p, normalize(vec3(-.1,-1,-.2))) + .001;\n    eb = smin(eb, dot(p, normalize(vec3(-.3,-1,0))) - .006, .01);\n    eb = smax(eb, dot(p, normalize(vec3(.5,-1,-.5))) - .018, .05);\n\n    float edge = max(max(eb, et), -d);\n\n    d = smin(d, eyelids, .01);\n    d = smin(d, eyelids2, .03);\n    d = smax(d, -edge, .005);\n\n    // eyeball\n    p = pp;\n    p += vec3(-.165,.0715,-.346);\n    float eyeball = length(p) - .088;\n\tisEye = eyeball < d;\n    d = min(d, eyeball);\n\n    // tear duct\n    p = pp;\n    p += vec3(-.075,.1,-.37);\n    d = min(d, length(p) - .05);\n\n   \n    // targus\n    p = pp;\n    p += vec3(-.34,.2,.02);\n    d = smin2(d, ellip(p, vec3(.015,.025,.015)), .035);\n    p = pp;\n    p += vec3(-.37,.18,.03);\n    pR(p.xz, .5);\n    pR(p.yz, -.4);\n    d = smin(d, ellip(p, vec3(.01,.03,.015)), .015);\n    \n    // third eye\n    \n    p = pp;\n    \n    p.y *= 1.2;\n    p.x *= 1.2;\n\n    p.z -=  0.9;\n    p.y -= .1;\n        \n    p.z += SIN(length(p.xy)*100.-3.*tt)*.03;\n    p.yz *= rot(PI/2.);\n   // p.y -= sin(length(p.xy)*20.)*.1;\n\n    float thirdeye = fCylinder(p, .18, .4);\n\n    d = smax(d, -thirdeye, .01)*.4;\n\n    return d;\n}\n\n\nfloat fTorus(vec3 p, float smallRadius, float largeRadius) {\n\treturn length(vec2(length(p.xz) - largeRadius, p.y)) - smallRadius;\n}\n\n\nfloat sdCapsule( vec3 p, float h, float r )\n{\n  p.y -= clamp( p.y, 0.0, h );\n  return length( p ) - r;\n}\n\n\n\nfloat tentacle(vec3 p) {\n\n    float s = .3;\n\n    p /= s;\n    float len = 6.;\n\n\n    p.y += 25.;\n\n    float m = 4.;\n    float angle = p.y/50.*2.*PI;\n    p.x += sin(angle-2.*tt) * m;\n    p.z += cos(angle-2.*tt) * m;\n\n    float r = mix(.5, 3.5,  S(25., 0., abs(p.y-25.)));\n\n   // r *= .1+SIN(p.y*.3+5.*tt);\n    float ds = sdCapsule(p, 50., r);\n\n    // ds = smin(ds, length(p) - 2., 10.);\n    return ds*s;\n}\n\nfloat g_id = 0.;\n\nvec2 pMod2(inout vec2 p, vec2 size) {\n\tvec2 c = floor((p + size*0.5)/size);\n\tp = mod(p + size*0.5,size) - size*0.5;\n\treturn c;\n}\n\n\nvec2 transformSpace( inout vec3 p) {\n    \n \n    vec2 tpId = pMod2(p.xz, vec2(sSpacing));\n    return tpId;\n}\n\nvec2 floorId(inout vec3 p) {\n    return pMod2(p.xz, vec2(.3));\n}\n\n \nfloat ceilId(inout vec3 p) {\n       pMod(p.x, 1.);\n    p.x = abs(p.x)-.1;\n \n    p.x += sin(p.z*5.)*.1;\n    \n  return pMod(p.x, 0.14);\n}\n\nfloat mFloor(vec3 p, float h) {\n\n    p.y += h;\n    \n    p.y += sin((p.x*p.z)*1.)*0.005;\n    \n    floorId(p);\n    \n    float d = box(p, vec3(vec2(.13), 0.02).xzy)-.01;\n    return d*.8;\n}\n\nfloat mCeil(vec3 p, float h) {\n\n    p.y -= h;\n    \n    p.y += sin((p.z+2. + tt*sWave)*2.)*0.2*sin(p.x+2.*2.+tt*sWave);\n     \n    \n    ceilId(p);\n     \n    \n    float d = box(p, vec3(.05, 0.005, 10000.))-.01;\n    return d;\n}\n\nvec3 transformDistort(vec3 p) {\n    p.y -= sin(p.z*.3 +tt*sWave)*sDistort;\n    p.xy *= rot(sin(p.z*.5 +tBpm)*.4 *sDistort);\n    return p;\n}\n\nfloat map(vec3 p) {  \n\n\n    p = transformDistort(p);\n    \n    float h = 1.8;\n    float fl = mFloor(p, h);\n    float cl = mCeil(p, h);\n    \n    vec2 tpId = transformSpace(p);\n    vec3 pp = p;\n    p.y *= sHeight;\n    float torus = -(length(vec2(length(p.xz) -sTorusHeight, p.y)) -2.); // torus\n    \n    p = pp;\n    \n    \n    float head = mHead(p, tpId);\n    \n    float d = smin(torus, head, .1);\n \n    if(fl*2. < d) g_mat = 1.;\n    \n    if(cl*2. < d) g_mat = 2.;\n    d = smin(d, fl, 0.01);\n    d = smin(d, cl, 0.05);\n  \n\n\n    return d*mix(1.3, 1., sDistort);\n    \n}\n\n\nvec3 getNormal(vec3 p) {\n\n    vec2 eps = vec2(0.001, 0.0);\n    return normalize(vec3(map(p + eps.xyy) - map(p - eps.xyy),\n                          map(p + eps.yxy) - map(p - eps.yxy),\n                          map(p + eps.yyx) - map(p - eps.yyx)\n                         )\n                     );\n}\n\nfloat gridSurf( in vec3 p){\n\n    p.z += .3*tt;\n    p = abs(mod(p*2., 1.*0.125)-0.0125);\n    \n    float x = min(p.x,min(p.z, p.y))/0.03125;\n\n    return clamp(x, 0., 1.);\n\n\n}\n\n// Standard function-based bump mapping function (from Shane)\nvec3 doBumpMap(in vec3 p, in vec3 nor, float bumpfactor) {\n    \n    const float eps = BUMP_EPS;\n    float ref = gridSurf(p);                 \n    vec3 grad = vec3( gridSurf(vec3(p.x-eps, p.y, p.z))-ref,\n                      gridSurf(vec3(p.x, p.y-eps, p.z))-ref,\n                      gridSurf(vec3(p.x, p.y, p.z-eps))-ref )/eps;                     \n          \n    grad -= nor*dot(nor, grad);          \n                      \n    return normalize( nor + bumpfactor*grad );\n}\n\n// iq's shadow function\nfloat softshadow( in vec3 ro, in vec3 rd, float mint, float maxt, float k ) {\n\n    float res = 1.0;\n    float ph = 1e20;\n    for( float t=mint; t<maxt; )\n    {\n        float h = map(ro + rd*t);\n        if( h<0.001 )\n            return 0.0;\n        float y = h*h/(2.0*ph);\n        float d = sqrt(h*h-y*y);\n        res = min( res, k*d/max(0.0,t-y) );\n        ph = h;\n        t += h;\n    }\n    return res;\n}\n\n\n// why not put the raymarcher in a separate function (;\nvec3 raymarch(vec3 ro, vec3 rd, float steps) {\n\n    //steps = 250.;\n    float mat = 0.,\n          t   = 0.,\n          d   = 0.;\n    vec3 p = ro;\n    for(float i=.0; i<steps; i++) {\n    \n        d = map(p);\n        mat = g_mat;  // save global material\n        \n        t += d;\n        p += rd*d;\n        if(abs(d) < 0.001 || t > 30.) break;\n    }\n    \n    \n    return vec3(t, mat, d);\n}\n\n\n\n// from iq code\nfloat softshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n\tfloat res = 1.0;\n    float t = mint;\n    for( int i=0; i<1; i++ )\n    {\n\t\tfloat h = map( ro + rd*t );\n        res = min( res, 8.0*h/t );\n        t += h*.25;\n        if( h<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0., 1. );\n}\n\nfloat calcAO(vec3 p, vec3 n)\n{\n\tfloat sca = 2.0, occ = 0.0;\n    for( int i=0; i<5; i++ ){\n    \n        float hr = 0.01 + float(i)*0.5/4.0;        \n        float dd = map(n * hr + p);\n        occ += (hr - dd)*sca;\n        sca *= 0.7;\n    }\n    return clamp( 1.0 - occ, 0.0, 1.0 );    \n}\n\nvec3 rdToCol(vec3 rd) {\n    // Ray direction as color\n    vec3 col = 0.5 + 0.5*rd;\n\n    // Output to cubemap\n\n    col.g *=.7;\n    return col;\n}\n\nvec3 getRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    \n    // camera system\n    vec3 f = normalize(l - p),  // forward vector\n         r = normalize(cross(vec3(0, 1, 0), f)), // right vector\n         u = cross(f, r), // up vector\n         c = p + f * z, // center of virtual screen\n         i = c + uv.x * r + uv.y * u, // intersection with screen\n         rd = normalize(i - p);  // ray direction\n         \n    return rd;\n    \n}\n\n// Shane awesome work below\n// Tri-Planar blending function. Based on an old Nvidia tutorial.\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n ){\n    \n    //return cellTileColor(p);\n\n    n = max((abs(n) - 0.2)*7., 0.001); // n = max(abs(n), 0.001), etc.\n    n /= (n.x + n.y + n.z ); \n    return ( texture(tex, p.zx)*n.y).xyz;\n\t//return (texture(tex, p.yz)*n.x + texture(tex, p.zx)*n.y + texture(tex, p.xy)*n.z).xyz;\n}\n\n// Texture bump mapping. Four tri-planar lookups, or 12 texture lookups in total. I tried to \n// make it as concise as possible. Whether that translates to speed, or not, I couldn't say.\nvec3 texBump( sampler2D tx, in vec3 p, in vec3 n, float bf){\n   \n    const vec2 e = vec2(0.002, 0);\n    \n    // Three gradient vectors rolled into a matrix, constructed with offset greyscale texture values.    \n    mat3 m = mat3( tex3D(tx, p - e.xyy, n), tex3D(tx, p - e.yxy, n), tex3D(tx, p - e.yyx, n));\n    \n    vec3 coeffs = vec3(0.299*SIN(tt), 0.587, 0.114*SIN(.7*tt));\n    vec3 g = coeffs*m; // Converting to greyscale.\n    g = (g - dot(tex3D(tx,  p , n), coeffs) )/e.x; g -= n*dot(n, g);\n                      \n    return normalize( n + g*bf ); // Bumped normal. \"bf\" - bump factor.\n\t\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   \tvec2 uv = (fragCoord - .5*iResolution.xy)/iResolution.y;\n\n\n    tt = .5*iTime;\n    \n    initScenes();\n    \n    if(sSplitCenter > 0.) {\n        uv.x = sabsk(uv.x, .00) - .2*sSplitCenter; \n        }\n\n  // uv = vec2(-uv.y, uv.x);\n    uv.xy *= mix(1.0, .4, SIN(abs(length(uv)*3.+tt+1.*sCamTick)*sWarp));\n  \n    uv *= rot(mix(PI/4., 0., sIntro) + sCamRotate*(PI+PI*sin(PI+tBpm)));\n\n\n    //uv.x = (sabsk(uv.x, .01) - .0);\n\n\n    vec3  lp = vec3(4., 3., -10.),\n          lp2 = vec3(-4., -2., -10.);\n\n   \n    //uv = uv.yx;\n    vec3 col = vec3(0);\n    float id = 0.;\n    \n    ro = vec3(.0, 0.0 + mix(1.4, 0., sIntro), sCamZ);\n    \n    ro.y += .4*sin(2.*tt) * sCamUpDown;\n    vec3 lookat = vec3(0, 0, 0), p;\n\n\n    lookat.x += 5.*sin(1.*tBpm)*sCamRotateX;\n    lookat.y += 1.*cos(1.*tBpm)*sCamRotateY;\n    cam(ro);\n    cam(lp);\n    cam(lp2);\n    cam(lookat);\n      \n    vec3 rd = getRayDir(uv, ro, lookat, .5);        \n    \n    float mat = 0., matId = 0.,\n          t   = 0.,\n          d   = 0.;\n          \n    bool l_isEye = false;\n     \n\n    vec2 e = vec2(0.0035, -0.0035);\n     \n    // background color\n    vec3 c1 = vec3(0.686,0.227,0.071);\n    vec3 c2 = vec3(0.298,0.537,0.102);\n    \n   \n    \n    c2 = mix(c2, vec3(0.176,0.671,0.706), sBright);\n\n    vec3 lc1 = vec3(0.894,0.843,0.957);\n    vec3 lc2 = vec3(0.314,0.984,0.984);\n\n    float flashLevel = mix(1., 1.3, S(.8, .2, SIN(iTime*BPM*8.)*sFlash));\n    vec3 bg = mix(c1, c2, uv.y+.5) *.7*mix(.05, 1., sSunrise*flashLevel);\n\n\n    for(float i = 0.; i < 1.; i++) {\n        float steps = i > 0. ? 50. : 250.;\n        vec3 rm = raymarch(ro, rd, steps);\n        l_isEye = isEye;\n        id = g_id;\n        float glow = g_glow;\n        mat = rm.y;\n        \n        \n        vec3 p = ro + rm.x*rd;\n\n        vec3 n = normalize( e.xyy*map(p+e.xyy) + e.yyx*map(p+e.yyx) +\n                            e.yxy*map(p+e.yxy) + e.xxx*map(p+e.xxx));\n    \n        \n        p = transformDistort(p);\n        \n        vec3 texCol = vec3(0);\n        vec3 q = p * 0.02;\n\n\n        if(rm.z < 0.001) {\n        \n            vec3 l = normalize(lp-p);\n            vec3 l2 = normalize(lp2-p);\n            float dif = max(dot(n, l), .0);\n            float dif2 = max(dot(n, l2), .0);\n            float spe = pow(max(dot(reflect(-rd, n), -l), .0), 40.);\n            \n            float shd = softshadow( p, l2+l, 2., 5. );\n       \n            float sss = smoothstep(0., 1., map(p + l * .3)) / .4;\n            float sss2 = smoothstep(0., 1., map(p + l2 * .3)) / .4;\n\n\n            vec3 n2 = n;\n            n2.xy += noise(p.xy) * .5 - .025;\n            n2 = normalize(n2);\n            float height = atan(n2.y, n2.x);\n\n            vec3 iri = spectral_zucconi6(height*1.11)*smoothstep(.8, .2, abs(n2.z))-.02;\n\n            col = vec3(sss + dif*lc1 + dif2*lc2 + sss2) + iri;\n          \n            // apply ambient occlusion\n            float ao = calcAO(p, n);\n            col *= mix(col, col*ao, 1.);\n            \n            // apply fake cubemap reflections\n            rd = reflect(rd, n);\n\n            vec3 refl = texture(iChannel0, rd).rgb;\n\n            refl = vec3(dot(refl, vec3(.33))); // not interested in the color from the cube map\n\n            refl = invGamma(refl);\n\n            refl *= mix(vec3(1), spectral_zucconi6(n.x*n.y*3.), .6);// reflect rainbows too\n          \n            col = mix(col, refl, .98);\n                \n            if(mat < 1.) { // archs and heads\n           \n                vec2 tpId = transformSpace(p);\n                float res = mix(1., .4, length(tpId));\n                \n                   // p.xz *= rot(curve(tt, 2.));\n                p = transformHeads(p);\n \n                float dark = SIN(q.x*5.4+q.y*4.2+tt+PI/2.);\n                matId =  mod(id, 2.);\n                \n                float pal = mix(4., 3., mod(tpId.x+tpId.y, 2.));\n                \n                float colMod = SIN(p.z*300.*res+5.*tt)*.8 +  .5*SIN( p.y*20.*res*p.x);\n                \n                vec3 rainbow = getColorRamp(int(pal), colMod);\n                \n                p = headUpDown(p);\n                           \n                p.y *= 1.2;\n          \n                vec3 col1 = 1.0*mix(col, mix(col*rainbow, rainbow, .5), 1.*.5); \n                vec3 col2 = 1.0*mix(col, mix(col*rainbow, rainbow, .5), 0.); \n            \n           \n                col = mix(col1, col2, .4 + .0*SIN(q.x*3.4+q.y*4.2+tt)); \n                \n                col = mix(col, col+.08*rainbow, S(.1, .9, SIN(length(tpId)*2.+3.*tt)));\n                \n                // third eye glow\n                p.y -= .22;\n                \n                float mask = S(.3, .9, SIN(p.z*50.-4.*tt));\n                vec3 thirdeye = getColorRamp(1, SIN(p.z*100.-2.*tt+length(tpId)));\n                \n                col += .3*(1.-smoothstep(0.0, .2, length(p.xy)))*thirdeye*mask;\n               \n                // eye glow\n                if(l_isEye) col = mix(col, vec3(0.165,0.455,0.408), .4);\n               \n            \n            }\n            else if(mat < 2.) { // floor\n                vec2 id = floorId(p);\n                \n                vec3 checker = getColorRamp(3, mod(id.x + id.y, 2.)/2.+1.);\n                col = mix(col, mix(col*checker, checker, .5), .5);\n                \n           \n           }\n           else if(mat < 3.) { // ceiling\n           \n              float id = ceilId(p);\n              \n              vec3 rainbow = getColorRamp(4, id/2.+.5);\n               col = mix(col, mix(col*rainbow, rainbow, .5), .5);\n           }\n            t = rm.x;\n\n            float fog = 1.-exp(-t*t*mix(0.004, 0.002, sDistort));\n\n\n            col = mix(col, bg, fog);\n\n            col = mix(col*shd, col, .5);;\n\n        } else {\n           col = bg;\n\n        } \n        \n    }\n    \n    \n\n    col += mix(-NOISE_GRANULARITY, NOISE_GRANULARITY, random(uv));\n    col *= mix(.2, 1., (1.5-pow(dot(uv, uv), .5))); // vignette\n    \n    col = pow(col*1.3, vec3(2.9))*6.;\n    \n    col = gamma(col); // gamma\n    \n    \n    fragColor = vec4(col, 1.0 - t * 0.03);\n}","name":"Image","description":"","type":"image"},{"outputs":[],"inputs":[],"code":"#define COPY_COLOR(N, colorsK)  for(int i = 0; i < N; i++) { colors[i] = colorsK[i]; }\n\nconst highp float NOISE_GRANULARITY = 0.5/255.0;\n\n\n\nvec3 rgb2hsl(vec3 color) {\n    float r = color.r;\n    float g = color.g;\n    float b = color.b;\n    float max = max(max(r, g), b);\n    float min = min(min(r, g), b);\n    float h, s, l;\n    l = (max + min) / 2.0;\n\n    if (max == min) {\n        h = s = 0.0; // achromatic\n    } else {\n        float d = max - min;\n        s = l > 0.5 ? d / (2.0 - max - min) : d / (max + min);\n        if (max == r) {\n            h = (g - b) / d + (g < b ? 6.0 : 0.0);\n        } else if (max == g) {\n            h = (b - r) / d + 2.0;\n        } else if (max == b) {\n            h = (r - g) / d + 4.0;\n        }\n        h /= 6.0;\n    }\n    return vec3(h, s, l);\n}\n\n\nconst vec3 colors2[] = vec3[](\n    vec3(27, 231, 255) / 255.0, // Electric blue\n    vec3(110, 235, 131) / 255.0, // Light green\n    vec3(228, 255, 26) / 255.0, // Lemon Lime\n    vec3(255, 184, 0) / 255.0, // Selective yellow\n    vec3(255, 87, 20) / 255.0 // Giants orange\n);\n\nconst vec3 colors1[] = vec3[](\n    vec3(84, 13, 110) / 255.0, // Indigo\n    vec3(238, 66, 102) / 255.0, // Red (Crayola)\n    vec3(255, 210, 63) / 255.0, // Sunglow\n    vec3(59, 206, 172) / 255.0, // Turquoise\n    vec3(14, 173, 105) / 255.0 // Jade\n);\n  \n\nconst vec3 colors3[] = vec3[](\n    vec3(155, 93, 229) / 255.0, // Amethyst\n    vec3(241, 91, 181) / 255.0, // Brilliant rose\n    vec3(254, 228, 64) / 255.0, // Maize\n    vec3(0, 187, 249) / 255.0, // Deep Sky Blue\n    vec3(0, 245, 212) / 255.0 // Aquamarine\n);\n\n\nconst vec3 colors4[] = vec3[](\n    vec3(0.169, 0.761, 0.718),\n    vec3(0.357, 0.518, 0.008),\n    vec3(0.604, 0.851, 0.259),\n    vec3(0.820, 0.235, 0.196),\n    vec3(0.522, 0.075, 0.020)\n);\n\nconst vec3 colors5[] = vec3[](\n    vec3(237, 174, 73) / 255.0, // Hunyadi yellow\n    vec3(209, 73, 91) / 255.0, // Amaranth\n    vec3(0, 121, 140) / 255.0, // Caribbean Current\n    vec3(48, 99, 142) / 255.0, // Lapis Lazuli\n    vec3(0, 61, 91) / 255.0 // Indigo dye\n);\n\n\nconst vec3 colors6[] = vec3[](\n    vec3(0, 204, 255) / 255.0, // Vivid sky blue\n    vec3(0, 255, 204) / 255.0, // Aquamarine\n    vec3(255, 255, 0) / 255.0, // Yellow\n    vec3(255, 0, 204) / 255.0, // Hot magenta\n    vec3(204, 0, 255) / 255.0 // Electric purple\n);\n\nconst vec3 colors77[] = vec3[](\n    vec3(0.600,0.271,0.000), // Vivid sky blue\n    vec3(0.949,0.600,0.314), // Aquamarine\n    vec3(0.941,0.984,1.000), // Yellow\n    vec3(0.071,0.537,0.769), // Hot magenta\n    vec3(0.051,0.212,0.686) // Electric purple\n);\n\nconst vec3 colors78[] = vec3[](\n    vec3(249, 65, 68) / 255.0, // Imperial red\n    vec3(243, 114, 44) / 255.0, // Orange (Crayola)\n    vec3(248, 150, 30) / 255.0, // Carrot orange\n    vec3(249, 132, 74) / 255.0, // Coral\n    vec3(249, 199, 79) / 255.0, // Saffron\n    vec3(144, 190, 109) / 255.0, // Pistachio\n    vec3(67, 170, 139) / 255.0, // Zomp\n    vec3(77, 144, 142) / 255.0, // Dark cyan\n    vec3(87, 117, 144) / 255.0, // Payne's gray\n    vec3(39, 125, 161) / 255.0 // Cerulean\n);\n\nconst vec3 colors7[] = vec3[](\n    vec3(176.,29.,30.) / 255.,\n    vec3(241.,104.,38.) / 255.,\n    vec3(234.,211.,95.) / 255.,\n    vec3(0.,187.,173.) / 255.,\n    vec3(0.,107.,228.) / 255.,\n    vec3(126.,99.,180.) / 255.\n);\n\n\n// Allow up to 10 colors per palette\nvec3 getColorRamp_(vec3 cols[10], int N, float x ) {\n    // Calculate adjusted length to ensure end color is reachable within [0, 1]\n    float len = float(N);\n    \n    // Scale x according to the adjusted length and apply modulo for wrapping\n    float scaledX = mod(x * (len-1.), len);\n    \n    // Calculate indices. Ensure index2 wraps around to the start if necessary\n    int index1 = int(scaledX);\n    int index2 = index1 + 1;\n    if (index2 >= cols.length()) {\n        index2 = 0; // Wrap to the start to close the loop\n    }\n    \n    // Calculate the fraction between the two indices for smooth interpolation\n    float frac = fract(scaledX);\n    \n    // Interpolate between the two selected colors\n    return mix(cols[index1], cols[index2], smoothstep(0.0, .9, frac));\n}\n\nvec3 getColorRamp(int palette, float x) {\n\n    vec3 colors[10];\n    int len;\n    \n    \n    if(palette == 0) {\n        len = colors1.length();\n        COPY_COLOR(len, colors1);       \n    }\n    \n    if(palette == 1) {\n        len = colors2.length();\n        COPY_COLOR(len, colors2);\n    }\n    if(palette == 2) {\n        len = colors3.length();\n        COPY_COLOR(len, colors3);\n        \n    }\n    if(palette == 3) {\n        len = colors4.length();\n        COPY_COLOR(len, colors4);    \n    }\n    \n    if(palette == 4) {\n        len = colors5.length();\n        COPY_COLOR(len, colors5);    \n    }\n    if(palette == 5) {\n        len = colors6.length();\n        COPY_COLOR(len, colors6);    \n    }\n    if(palette == 6) {\n        len = colors7.length();\n        COPY_COLOR(len, colors7);    \n    }\n    return getColorRamp_(colors, len, x);\n\n}\n\nvec3 invGamma(vec3 col) {\n    return pow(col, vec3(2.2));\n}\n\nvec3 gamma(vec3 col) {\n    return pow(col, vec3(1./2.2));\n}\n\nmat2 rot(float a) { return mat2(cos(a), -sin(a), sin(a), cos(a)); }\n\n\nfloat saturate(float x) {\n    return clamp(x, 0., 1.);\n}\n\n// zucconis spectral palette https://www.alanzucconi.com/2017/07/15/improving-the-rainbow-2/\nvec3 bump3y (vec3 x, vec3 yoffset)\n{\n    vec3 y = 1. - x * x;\n    y = clamp((y-yoffset), vec3(0), vec3(1));\n    return y;\n}\n\n//  some 2d noise for dithering\nhighp float random(highp vec2 coords) {\n   return fract(sin(dot(coords.xy, vec2(12.9898,78.233))) * 43758.5453);\n}\n\n// Zucconi's spectral palette\nvec3 spectral_zucconi6(float x) {\n    x = fract(x);\n    const vec3 c1 = vec3(3.54585104, 2.93225262, 2.41593945);\n    const vec3 x1 = vec3(0.69549072, 0.49228336, 0.27699880);\n    const vec3 y1 = vec3(0.02312639, 0.15225084, 0.52607955);\n    const vec3 c2 = vec3(3.90307140, 3.21182957, 3.96587128);\n    const vec3 x2 = vec3(0.11748627, 0.86755042, 0.66077860);\n    const vec3 y2 = vec3(0.84897130, 0.88445281, 0.73949448);\n    return bump3y(c1 * (x - x1), y1) + bump3y(c2 * (x - x2), y2) ;\n}\n\n","name":"Common","description":"","type":"common"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"XffcW7","date":"1734442759","viewed":206,"name":"[phreax] xyphora","username":"phreax","description":"Never formerly released this one, here you go. Demo length about 100seconds\n\nHead SDF by tdhooper https://www.shadertoy.com/view/wlf3WX ","likes":29,"published":1,"flags":0,"usePreview":1,"tags":["raymarching","demo","heads"],"hasliked":0,"parentid":"","parentname":""}}