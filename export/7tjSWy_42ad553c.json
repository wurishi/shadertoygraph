{"ver":"0.1","info":{"id":"7tjSWy","date":"1628549025","viewed":1695,"name":"Surveillance mosaic","username":"felipetovarhenao","description":"Animated eye mosaic using value noise, and shaping functions.","likes":35,"published":1,"flags":0,"usePreview":0,"tags":["sdf","eyes","mosaic"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n    Author: Felipe Tovar-Henao [www.felipe-tovar-henao.com]\n    Description: Animated eye mosaic using value noise, and shaping functions.\n*/\n\n#define PI 3.14159265359\n#define TWO_PI 6.28318530718\n#define edge 0.005\n\n\n/* -------- SHAPERS/MISC -------- */\nfloat fold(in float x) {\n    return abs(mod(x+1.0,2.0)-1.0);\n}\n\nfloat reliRamp(in float x, in float s) {\n    return floor(x) + clamp((max(1.0, s)*(fract(x) - 0.5)) + 0.5, 0.0, 1.0);\n}\n\nfloat cosine_ramp(in float x, in float s) {\n    float y = cos(fract(x)*3.14159265359);\n    return floor(x) + 0.5 - (0.5*pow(abs(y), 1.0/s)*sign(y));\n}\nfloat camel_ramp(in float x, in float s) {\n    float y = fract(x);\n    return floor(x) + pow(0.5 - (0.5 * cos(6.28318530718*y) * cos(3.14159265359*y)), s);\n}\n\nvec2 rotate2D(in vec2 vUV, in float theta) {\n    return vUV * mat2(cos(theta), -sin(theta), sin(theta), cos(theta));\n}\n\nfloat scale(in float x, in float inmin, in float inmax, in float outmin, in float outmax) {\n    return ((x-inmin)/(inmax-inmin))*(outmax-outmin)+outmin;\n}\n\n/* -------- NOISE -------- */\nfloat random1D(in vec2 vUV, in int seed) {\n    return fract(abs(sin(dot(vUV, vec2(11.13, 57.05)) + float(seed)) * 48240.41));\n}\n\nfloat value_noise(in vec2 vUV, in int seed) {\n    vec2 x = floor(vUV);\n    vec2 m = fract(vUV);\n\n    float bl = random1D(x, seed);\n    float br = random1D(x + vec2(1.0, 0.0), seed);\n    float tl = random1D(x + vec2(0.0, 1.0), seed);\n    float tr = random1D(x + vec2(1.0, 1.0), seed);\n\n    vec2 cf = smoothstep(vec2(0.0), vec2(1.0), m);\n\n    float tm = mix(tl, tr, cf.x);\n    float bm = mix(bl, br, cf.x);\n\n    return mix(bm, tm, cf.y);\n}\n\n/* -------- EYE FUNCTIONS -------- */\nfloat eyeSDF(in vec2 vUV, in float s) {\n    float o = 0.125;\n    vec2 uv = abs(vUV*vec2(1. + o, 1.0));\n    float x = clamp(uv.x*(1.-o),0.0,0.5);\n    uv -= vec2(0.5, pow(cos(x*PI)/s, s));\n    return length(max(vec2(0.0), uv)) + min(0.0, max(uv.x, uv.y));\n}\n\nvec4 mk_tearduct(in float sdf, in float t) {\n    vec3 col = mix(vec3(0.0, 0.0, 0.0), vec3(0.8471, 0.8471, 0.8471), cosine_ramp(fold(sdf*60.0 + t*0.25), 2.0));\n    float a = smoothstep(edge, 0.0, sdf+edge);\n    return vec4(col, a);\n}\n\nvec4 mk_eyelids(in float sdf) {\n    return smoothstep(edge*2.0, 0.0, abs(sdf)-0.01) * vec4(0.6471, 0.6471, 0.6471, 1.0);\n}\n\nvec4 mk_sclera(in vec2 vUV, in float d, in float t) {\n    float g = rotate2D(vUV, length(vUV)*TWO_PI*sin(t*0.1) + t*0.01).y;\n    vec3 glow = smoothstep(edge, 0.0, g) * vec3(1.0);\n    vec4 sclera = smoothstep(edge, 0.0, d-0.25) * vec4(0.8275, 0.8235, 0.8235, 1.0);\n    vec4 border = smoothstep(edge, 0.0, abs(d-0.25)-0.0025) * vec4(0.2549, 0.2549, 0.2549, 1.0);\n    sclera.rgb = mix(sclera.rgb, glow, glow.r);\n    sclera = mix(sclera, border, border.a);\n    return sclera;\n}\n\nvec4 mk_iris(in vec2 vUV, in float d, in float t) {\n    float a = atan(vUV.x, vUV.y);\n    vec3 col = mix(vec3(0.6784, 0.7922, 0.8431), vec3(0.6118, 0.7255, 0.7804), fold(cosine_ramp(sin(a*3.0*cos(a*2.0)+t*0.5), 4.0)));\n    col = mix(col, vec3(0.7765, 0.8196, 0.8392), cosine_ramp(cos(3.0*a*sin(-a*1.5) + t*0.4)* 0.5 + 0.5, 4.0));\n    vec4 iris = smoothstep(edge, 0.0, d-0.125) * vec4(col, 1.0);\n    vec4 border = smoothstep(edge, 0.0, abs(d-0.125)-0.002) * vec4(0.2627, 0.2353, 0.2353, 1.0);\n\n    float shade = cos(a+t*0.25)*0.5+0.5;\n    shade *= shade;\n    shade = cosine_ramp(shade, 4.0);\n    iris = mix(iris, border, border.a);\n    iris.rgb = mix(iris.rgb, vec3(0.3529, 0.4627, 0.4941), shade*0.75);\n    \n    return iris;\n} \n\nvec4 mk_pupil(in float d, in float t) {\n    t = sin(d+t*0.125)*0.01;\n    return smoothstep(edge, 0.0, d-0.05+t) * vec4(0.0627, 0.0588, 0.0588, 1.0);\n}\n\nvec4 mk_glow(in vec2 vUV, in float t) {\n    float d = length(vUV);\n    vUV *= vec2(sin(d*2.123 - t*0.798347), cos(d*3.123 + t*0.91823))*0.1 + 1.0;\n    d = length((vUV-(vUV.y*0.1))-0.05);\n\n    vec4 glow = smoothstep(edge*1.5, 0.0, d-0.03) * vec4(1.0);\n\n    d = length((vUV-(vUV.y*0.1))+0.05);\n    glow = mix(glow, smoothstep(edge*1.25, 0.0, d-0.02) * vec4(1.0), 1.0-glow.a);\n\n    return glow;\n}\n\nvec4 mk_retina(in vec2 vUV, in float t) {\n    vec4 retina = vec4(0.0);\n    vUV *= length(vUV)*1.5+1.0;\n    vUV += vec2(cos(t*0.98), sin(t*0.234))*0.08;\n    float d = length(vUV);\n    vec4 glow = mk_glow(vUV, t);\n    vec4 iris = mk_iris(vUV, d, t);;\n    vec4 pupil = mk_pupil(d+sin(t*0.5 + 0.12)*0.005, t);    \n\n    retina = mix(retina, iris, iris.a);\n    retina = mix(retina, pupil, pupil.a*retina.a);\n    retina = mix(retina, glow, glow.a*0.975*iris.a);\n\n    return retina;\n}\n\nvec4 mk_eyeball(in vec2 vUV, in float t) {\n    float d = length(vUV);\n    vec4 eyeball = vec4(0.0);\n    vec4 sclera = mk_sclera(vUV, d, t);\n    vec4 retina = mk_retina(vUV, t + reliRamp(t, 2.0));\n    \n    eyeball = mix(eyeball, sclera, sclera.a);\n    eyeball = mix(eyeball, retina, retina.a*sclera.a);\n\n    return eyeball;\n}\n\nvec4 mk_eye(in vec2 vUV, in float b, in float t) {\n    vec4 eye = vec4(0.0);\n    float eye_sdf = eyeSDF(vUV*1.06, b);\n    vec4 tearduct = mk_tearduct(eye_sdf, t);\n    vec4 eyelids = mk_eyelids(eye_sdf);\n    vec4 eyeball = mk_eyeball(vUV, t);\n\n    eye = mix(eye, tearduct, tearduct.a);\n    eye = mix(eye, eyeball, eyeball.a*tearduct.a);\n    eye = mix(eye, eyelids, eyelids.a);\n\n    return vec4(eye);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 vUV = fragCoord.xy / iResolution.xy;\n    vUV.x *= iResolution.x / iResolution.y;\n    float scl = 1.75;\n    vec2 pUV = vUV * scl + vec2(iTime * 0.01, iTime * -0.0107);\n    vec4 color = vec4(0.0);\n    float sdf = 1.0;\n\n    for (float i = 0.0; i <= 1.0; i ++) {\n        vUV = pUV + 7.5*(1.0-i);\n        vec2 iUV = floor(vUV);\n        vUV = fract(vUV)-0.5;\n        float rand = value_noise(iUV, int(vUV.x*vUV.y));\n        float t = (iTime + 100.0*(i+0.5)) * (rand + 1.0);\n        vUV = rotate2D(vUV, t*0.01);\n        float b = scale(pow(fold(t * 0.1), 100.0), 0.0, 1.0, 2.0, 10.0);\n        vec4 eye = mk_eye(vUV*pow(2.0, rand), b, t * 0.5);\n        sdf = min(sdf, eyeSDF(vUV*scl, b));\n        color = mix(color, eye, eye.a);\n    }\n    \n    sdf = camel_ramp(fold(sdf*(16. + sin(iTime*0.25)*2.0) - iTime*0.1), 1.0);\n    sdf *= sdf;\n    color = mix(color, sdf*vec4(0.6824, 0.6824, 0.6824, 1.0), sdf*(1.0-color.a));\n    fragColor = color;\n}","name":"Image","description":"","type":"image"}]}