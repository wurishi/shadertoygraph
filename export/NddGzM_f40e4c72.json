{"ver":"0.1","info":{"id":"NddGzM","date":"1629398239","viewed":88,"name":"the clash","username":"nexor","description":".","likes":5,"published":1,"flags":32,"usePreview":0,"tags":["2d","sdf","rgb"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  fragColor = texelFetch(iChannel0,ivec2(fragCoord),0);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define pi 3.14159\n#define NUM_NOISE_OCTAVES 5\n\nmat2 rot(float a){float c=cos(a),s=sin(a);return mat2(c,-s,s,c);}\n\nfloat circle(vec2 p, float r)\n{\n    return length(p)-r;\n}\n\nvec2 get_inf_off(float t)\n{\n    return vec2(cos(t*pi),sin(t*2.*pi)*.5)*.25;\n}\n\nfloat sdf2col(float sdf, float w)\n{\n    return smoothstep(0.,w,sdf);\n}\n\nvec2 dir_vec(float a)\n{\n    return vec2(cos(a),sin(a));\n}\n\nfloat hash(vec2 p) {vec3 p3 = fract(vec3(p.xyx) * 0.13); p3 += dot(p3, p3.yzx + 3.333); return fract((p3.x + p3.y) * p3.z); }\n\nfloat noise(vec2 x) {\n    vec2 i = floor(x);\n    vec2 f = fract(x);\n\n\t// Four corners in 2D of a tile\n\tfloat a = hash(i);\n    float b = hash(i + vec2(1.0, 0.0));\n    float c = hash(i + vec2(0.0, 1.0));\n    float d = hash(i + vec2(1.0, 1.0));\n\n    // Simple 2D lerp using smoothstep envelope between the values.\n\t// return vec3(mix(mix(a, b, smoothstep(0.0, 1.0, f.x)),\n\t//\t\t\tmix(c, d, smoothstep(0.0, 1.0, f.x)),\n\t//\t\t\tsmoothstep(0.0, 1.0, f.y)));\n\n\t// Same code, with the clamps in smoothstep and common subexpressions\n\t// optimized away.\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\treturn mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y;\n}\n\nfloat fbm(vec2 x) {\n\tfloat v = 0.0;\n\tfloat a = 0.5;\n\tvec2 shift = vec2(100);\n\t// Rotate to reduce axial bias\n    mat2 rot = mat2(cos(0.5), sin(0.5), -sin(0.5), cos(0.50));\n\tfor (int i = 0; i < NUM_NOISE_OCTAVES; ++i) {\n\t\tv += a * noise(x);\n\t\tx = rot * x * 2.0 + shift;\n\t\ta *= 0.5;\n\t}\n\treturn v;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    vec2 uv = (2.*fragCoord.xy-iResolution.xy)/iResolution.x;\n    float w = fwidth(uv.y);\n    vec2 q = uv;\n\n    vec3 col = vec3(0);\n    float fps = 240.;\n    float ft = float(iFrame)/fps;\n    \n    float slow = 1.;\n    float t = fract(ft/slow);\n    int i=4-int(ft/slow)%4;\n    mat2 R = rot(-float(i)*pi/2.);\n    float sbig=.025;\n    float slit=sbig*.5;\n    \n    float d = 1e3;\n    \n    //guidelines\n    if(false){\n    col += 1.-step(0.,abs(uv.y)-w);\n    col += 1.-step(0.,abs(uv.y-.25)-w);\n    col += 1.-step(0.,abs(uv.y+.25)-w);\n    col += 1.-step(0.,abs(uv.x)-w);\n    col += 1.-step(0.,abs(uv.x-.25)-w);\n    col += 1.-step(0.,abs(uv.x+.25)-w);\n    }\n    \n    // chasers\n    vec2 off = vec2(0);\n    float K = pow(1.-abs(cos(t*pi)),5.);\n    off.x = t*.5;\n    off.y = K*.25;\n    vec2 offbig=off;\n    vec2 offlit=off;\n    float dbig = circle(R*uv+offbig-.25,sbig);\n    \n    \n    d=1e3;\n    d=min(d,dbig);\n    d=sdf2col(d,w);\n    col += 1.-d;\n    vec2 ruv = R*uv;\n    float a = atan(ruv.y,ruv.x);\n    \n    for(int j=0;j<=2;++j)\n    {\n        vec2 p = ruv-dir_vec(a+pi/2.+length(ruv)*140.)*float(j-1)*K*slit*4.;\n        float dlit = circle(p-offlit+.25,slit);\n        d=1e3;\n        d=min(d,dlit);\n        d=sdf2col(d,w);\n        col[j]+=1.-d;\n    }\n    \n    //col=vec3(0);\n    \n    float ns = smoothstep(.6,1.,noise(dir_vec(a)*15.));\n    \n    float k = (smoothstep(.48,.6,t));\n    float kk = smoothstep(.5,.6,t);\n    d=circle(uv,slit*k*15.);\n    d=abs(d)-slit;\n    col += vec3(1,1,0)*(1.-sdf2col(d,w*20.))*(1.-kk)*(k)\n    *ns;\n    \n    \n    \n    \n    \n    // square\n    d=1e3;\n    vec2 sq=abs(q)-.275;\n    float sqd=max(sq.x,sq.y)+length(max(sq,0.));\n    sqd=abs(sqd)-w;\n    d = sdf2col(sqd,w);\n    col += 1.-d;\n    \n    vec3 buf=texelFetch(iChannel0,ivec2(fragCoord),0).rgb;\n    col=pow(col,vec3(1./2.2));\n    col = col+buf*.8;\n    \n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Buffer A","description":"","type":"buffer"}]}