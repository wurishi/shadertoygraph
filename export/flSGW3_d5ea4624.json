{"ver":"0.1","info":{"id":"flSGW3","date":"1624794592","viewed":99,"name":"Pretty Pattern","username":"lesserfish","description":"This was forked! This is absolutely NO need for this many buffers! But fuck it!\nCaution: May cause dizziness.\n\nThis is slow as FUCK! gotta optimize it somehow! no fucking clue as of yet!","likes":2,"published":1,"flags":32,"usePreview":0,"tags":["2d","uv","normal"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec2 rotate(vec2 inp, float deg)\n{\n    vec2 rotation = vec2(cos(deg)*inp.x + sin(deg) * inp.y,\n                            -1.0*sin(deg)*inp.x + cos(deg) * inp.y);\n    return rotation;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float rotspeed = 0.2;\n    fragCoord = rotate(fragCoord, iTime * rotspeed + 0.15*sin(iTime*0.5));\n    vec2 uv = fragCoord/iResolution.xy;\n    uv = 2.0*uv - 1.0;\n    float base = 8.0;\n    float speed = 0.3;\n    float f = base * sin(iTime * speed) + base*1.2;\n    \n    uv = mod(f*uv, 1.0);\n    fragColor = texture(iChannel0, uv);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// This buffer gets the normal UV map of a circle\n\n#define PI 3.14159265359\n\nvec2 Normal(vec2 pos) //Calculates the normal of a point in the S1 circunference\n{\n    return normalize(pos); // The normal of the S1 circunference is the identity\n}\nvec2 integral(vec2 pos)\n{\n    float interval = 0.1; //Interval of the ingral\n    vec2 sum = vec2(0.0, 0.0); //Value we are going to return\n    \n    for(float alpha = 0.0; alpha < 2.0*PI; alpha += interval)\n    {\n        vec2 circlepos = 0.7*vec2(cos(alpha), sin(alpha)); // Position of the circle given angle alpha\n        vec2 val = (1.0/(max(length(circlepos - pos), 0.001))) * Normal(circlepos); // Normal of point Circlepos multiplied by the weight it has on position pos.\n        sum = sum + interval * val;\n    }\n    return (1.0/(4.0*PI))*sum; // We normalize it by the length of the path, which is precisely the perimeter of S1. That is, 2PI\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from -1 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv = 2.0*uv - 1.0;\n    uv = uv * vec2(iResolution.x / iResolution.y, 1.0); //Corrects Distortion caused by screen\n    \n    vec2 i = integral(uv); // Gets the extension of the identity of function of the circunference to the entire space\n    fragColor = vec4(0.5) + 0.5*vec4(i.xy, 1.0, 0.0); //Convert normal vector to standard RGB representation.\n\n       \n    \n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// This buffers get the normal UV map of a square\n\nvec2 Normal(vec2 pos) //Calculates the normal of a point in the 2D Square\n{\n    return float(pos.y >= 0.5) * vec2(0.0, 1.0) + float(!(pos.y >= 0.5))*(\n               float(pos.y <= -0.5) * vec2(0.0, -1.0) + float(!(pos.y <= -0.5)) * (\n                   float(pos.x >= 0.5) * vec2(1.0, 0.0) + float(!(pos.x >= 0.5))*\n                       vec2(-1.0, 0.0) ));\n}\nvec2 integral(vec2 pos)\n{\n    float interval = 0.1; //Interval of the integral\n    vec2 sum = vec2(0.0, 0.0); \n    \n    for(float alpha = 0.0; alpha < 4.0; alpha += interval)\n    {\n        vec2 squareposition = float(alpha <= 1.0) * vec2(0.5, -0.5 + alpha) + float(!(alpha <= 1.0)) *(\n                                float(alpha <= 2.0) * vec2(0.5 - (alpha - 1.0) , 0.5) + float(!(alpha <= 2.0))*(\n                                  float(alpha <= 3.0) * vec2(-0.5, 0.5 - (alpha - 2.0)) + float(!(alpha <= 3.0))*\n                                    vec2(-0.5 + (alpha - 3.0), -0.5)));\n        \n        vec2 val = (1.0/(max(length(squareposition - pos), 0.001))) * Normal(squareposition); // Normal of point Square multiplied by the weight it has on position pos.\n        \n        sum = sum + interval * val;\n    }\n    return (1.0/(2.0*4.0))*sum; // Normalization of path length\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from -1 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv = 2.0*uv - 1.0;\n    uv = uv * vec2(iResolution.x / iResolution.y, 1.0); //Corrects Distortion caused by screen\n    \n    vec2 i = integral(uv); // Gets the extension of the identity of function of the circunference to the entire space\n    fragColor = vec4(0.5) + 0.5*vec4(i.xy, 1.0, 0.0); //Convert normal vector to standard RGB representation.\n\n       \n    \n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"\nvec4 GetLight(vec2 uv) // Calculates the light of a point given it's normal\n{\n    vec3 ligdir = normalize(vec3(cos(iTime), sin(iTime), -0.4 + 0.1*sin(iTime*0.7))); //Direction of the Light\n    \n    float border = 0.5;\n    float secondborder = 0.1;\n    float ratio =  0.5*((1.0 - uv.x) * (1.0/border) + 1.0);\n    float sratio = 1.0 - (2.0 - uv.x)*(1.0/secondborder);\n    \n    \n    float c1 = float(uv.x >= 1.0 + border); // I heard doing shit like this makes things run faster on the GPU\n    float c2 = float(uv.x <= 1.0 - border); // This reads like shit!\n    float c3 = float(uv.x > 2.0 - secondborder); // Fuck it!\n    \n    vec2 tex = c3 * ((1.0 - sratio)* texture(iChannel0, uv - vec2(0.0, 1.0)).xy + sratio*texture(iChannel1, uv - vec2(2.0, 1.0)).xy)\n                    + (1.0 - c3)*(\n                    c2 *\n                    texture(iChannel0, uv - vec2(0.0, 1.0)).xy + (1.0 - c2)*\n                    (c1 * \n                    texture(iChannel1, uv - vec2(1.0, 1.0)).xy + (1.0 - c1)*(\n                    (1.0 - ratio)*texture(iChannel1, uv - vec2(1.0, 1.0)).xy + ratio*texture(iChannel0, uv - vec2(0.0, 1.0)).xy)));\n    \n    \n    vec3 normal = normalize(2.0*vec3(tex, 0.0) - 1.0); //Convert RGB Coordinates back into Normal vectors\n    \n    float intensity = dot(ligdir, normal); //Light it\n    \n    vec4 Color = normalize(vec4(1.0, 0.0, 0.5, 0.0));\n    vec4 BColor = vec4(0.0, 0.0, 0.2, 0.0);\n    \n    return intensity*Color + (1.0-intensity)*BColor;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = 2.0*fragCoord/iResolution.xy;\n    \n    float border = 0.5;\n    float secondborder = 0.25;\n    float ratio =  0.5*((1.0 - uv.y) * (1.0/border) + 1.0);\n    float sratio = 1.0 - (2.0 - uv.y)*(1.0/secondborder);\n    \n    \n    float c1 = float(uv.y >= 1.0 + border);\n    float c2 = float(uv.y <= 1.0 - border);\n    float c3 = float(uv.y > 2.0 - secondborder);\n    \n    fragColor = c3*((1.0 - sratio)* GetLight(uv) + sratio*GetLight(uv - vec2(0.0, 2.0)))\n        +\n        (1.0 - c3)*(c2* \n        GetLight(uv + vec2(0.0, 1.0)) // uv.y <= 1.0\n        + (1.0 - c2) * \n        (c1 * GetLight(uv) + (1.0-c1)*( (1.0 - ratio)*GetLight(uv) + ratio * GetLight(uv + vec2(0.0, 1.0))))); // 1.0 <= uv.y <= 2.0\n    \n        \n}","name":"Buffer C","description":"","type":"buffer"}]}