{"ver":"0.1","info":{"id":"NddGR2","date":"1630230938","viewed":143,"name":"mixed Intersector+SDF Shapes","username":"kastorp","description":"proof of concept: defining a unique map() function, which uses intersector to get ray distance, and SDF to get AO, soft shadows and normal\nleft: usual raymarching, right: mixed algorithm\nSeems to work, but I don't know if this could have any usage \n","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["raytracing","sdf","intersector"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//mixed intersector+SDF Shapes\"   by Kastorp\n// left: usual raymarching, right: mixed algorithm (with raytraced shadows and SDF AO and normals)\n// performances seem to be 3x better with mixed algorithm\n//----------------\n//the MAP function is the same for the Tracing and the SDF\nfloat map(in mRay m,vec3 p ) { \n    vec4 d =  mPlane(m,p,vec3(0,1,0),0.);\n    \n    d =  mUnion(m,d,mSphere(m,p-vec3(0,1,0),1.));\n\n    for(float x=-3.;x<4.;x++)  for(float z=-3.;z<4.;z++) d =  mUnion(m,d,mSphere(m,p-vec3(x,.3,z),.3));\n    d = mUnion(m,d,mBox(m,p-vec3(0,0,0),vec3(1.)));\n    \n    //d = mSub(m,d, mSphere(m,p-vec3(0,2.1,0),1.));\n    d = mSub(m,d,mBox(m,p-vec3(0,1.6,0),vec3(.5)));\n    return d.x;\n}\n\n//------------------------------------\nfloat trace(vec3 ro, vec3 rd) {\n    return map( mRay(rd,0.), ro);\n}\n\nfloat march(vec3 ro, vec3 rd) {\n\t// Raymarch.\n\tvec3 p;\n\tfloat d = .01;\n\tfor (float i = 0.; i < 120.; i++) {\n\t\tp = ro + rd * d;\n\t\tfloat h = map(mSDF,p);\n\t\tif (abs(h) < .0015)\n\t\t\tbreak;\n\t\td += h; \n\t}\n    return d;\n}\n\nvec3 calcN(vec3 p, float t) {\n\tfloat h = .001 * t;\n\tvec3 n = vec3(0);\n    \n\tfor (int i = min(iFrame, 0); i < 4; i++) {\n\t\tvec3 e = .5773 * (2. * vec3((((i + 3) >> 1) & 1), (i >> 1) & 1, i & 1) - 1.);\n\t\tn += e * map(mSDF,p + e * h);\n\t}\n\n\treturn normalize(n);\n}\n\n\nfloat calcShadow(vec3 p, vec3 ld) {\n\t\n\n\treturn smoothstep(2.,100., map( mRay(ld,0.), p ));\n}\n\n\n\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, float tmin, float tmax, const float k )\n{\n\tfloat res = 1.0;\n    float t = tmin;\n    for( int i=0; i<100; i++ )\n    {\n\t\tfloat h = map(mSDF, ro + rd*t );\n        res = min( res, k*h/t );\n        t += clamp( h, 0.02, 0.20 );\n        if( res<0.005 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\nfloat ao(vec3 p, vec3 n, float h) {\n\treturn map(mSDF,p + h * n) / h;\n}\n\n#define MM (iMouse.x>0.?iMouse.x/iResolution.y -.5*iResolution.x/iResolution.y:0.)\n\nvec3 lights(vec3 p, vec3 rd, float d,bool sdf) {\n    vec3 lightDir = normalize( vec3(5.,9.-iMouse.x/iResolution.x*3.,8.) );\n\tvec3 ld = normalize(lightDir*6.5 - p), n = calcN(p, d) ;\n\n\tfloat ao = 1. + .9 * dot(vec3(ao(p, n, .1), ao(p, n, .4), ao(p, n, 2.)), vec3(.2, .3, .5)),\n\tl1 = max(0., .5 + .5 * dot(ld, n)),\n\t\n\tspe = max(0., dot(rd, reflect(ld, n))) * .1,\n\n\tfre = smoothstep(.7, 1., 1. + dot(rd, n));\n\n    //left:soft shadows with SDF, right:shadows with intersectors\n    vec3 pp=p+.02*n;\n\tl1 *= .1 + .9 * (sdf?calcShadow(pp, ld):calcSoftshadow(pp, ld,0.01,3.,4.));\n\tvec3 lig = (l1 * ao + spe) * vec3(1.) *2.5;\n\treturn mix(.3, .4, fre) * lig;\n}\n\nvec3 getRayDir(vec3 ro, vec3 lookAt, vec2 uv) {\n\tvec3 f = normalize(lookAt - ro),\n\t\t r = normalize(cross(vec3(0, 1, 0), f));\n\treturn normalize(f + r * uv.x + cross(f, r) * uv.y);\n}\n\n\nvoid mainImage(out vec4 fragColor, vec2 fc)\n{\n\t\n    float t=-iTime*.5;\n\tvec3 ro = vec3(3.*cos(t), 3.+4.*iMouse.y/iResolution.y, 3.*sin(t));\n\t\n\tvec2 uv = (fc - .5 * iResolution.xy) / iResolution.y;\n    vec3 rd =  getRayDir(ro, vec3(-0.), uv);\n    \n    float d;\n    //left:raymarching with SDF, right:ray tracing with intersectors\n    if(uv.x>MM) d= trace(ro,rd);\n    else d=march(ro,rd);\n      \n    vec3 p=ro+rd*d; \n    vec3 col=lights(p, rd, d,uv.x>MM) * exp(-d * .085)*(p.y<0.01? vec3(0,1,1):vec3(1));\n    col=mix(col,vec3(1,0,0),smoothstep(.005,0.,abs(uv.x-MM)));\n\tfragColor = vec4(pow(col, vec3(.45)), 0);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"//functions from  https://iquilezles.org\n//where intestectors return value was adapted:\n// no hit --> distance=far\n// hit in opposite direction --> distance=far\n// internal hit -->  distance=0.\n\n#define NOHIT 1e5\n\nvec2 iSphere( in vec3 ro, in vec3 rd, float ra )\n{\n    vec3 oc = ro ;\n    float b = dot( oc, rd );\n    float c = dot( oc, oc ) - ra*ra;\n    float h = b*b - c;\n    if( h<0. ) return vec2(NOHIT); // no intersection\n    h = sqrt( h );\n    return h-b < 0. ? vec2(NOHIT) : -b-h>0. ?  vec2(-b-h,h-b): vec2(0.,h-b);\n}\nfloat sSphere( in vec3 p,  float ra )\n{\n    return length(p)-ra; \n}\n\nvec2 iBox( in vec3 ro, in vec3 rd, vec3 boxSize ) \n{\n    vec3 m = 1.0/rd; // can precompute if traversing a set of aligned boxes\n    vec3 n = m*ro;   // can precompute if traversing a set of aligned boxes\n    vec3 k = abs(m)*boxSize;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n    if( tN>tF || tF<0.) return vec2(NOHIT); // no intersection\n    //outNormal = -sign(rd)*step(t1.yzx,t1.xyz)*step(t1.zxy,t1.xyz);\n    return tN<0.? vec2(0.,tF): vec2(tN,tF);\n}\n\nfloat sBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n\n//--------------------\n\n// plane defined by p (p.xyz must be normalized)\nfloat iPlane( in vec3 ro, in vec3 rd, in vec3 n ,float h)\n{\n    float d= -(dot(ro,n)+h)/dot(rd,n);\n    return d>0.?d:NOHIT;\n}\n\nfloat sPlane( vec3 p, vec3 n, float h )\n{\n  return dot(p,n) + h;\n\n  \n}\n\n\n//-----------------------------------\n//mixed functions\nstruct mRay{\n    vec3 rd;\n    float t;\n};\n\n\n\nconst mRay mSDF=mRay(vec3(0),-1.);\n\nvec4 mSphere( in mRay m,vec3 p, float ra )\n{\n    if(m.t<0.) return  vec4(sSphere(  p,  ra ),0,0,0);\n    else return  vec4(iSphere(p,m.rd,ra),0,0);\n}\n\nvec4 mBox(  in mRay m,vec3 p, in vec3 b)\n{\n    if(m.t<0.) return  vec4(sBox(  p,b ),0,0,0);\n    else return  vec4(iBox(p,m.rd,b),0,0);\n}\n\nvec4 mPlane(  in mRay m, vec3 p, in vec3 n ,float h)\n{\n    if(m.t<0.) return  vec4(sPlane(  p,n,h ),0,0,0);\n    else return  vec4(iPlane(p,m.rd,n,h),0,0,0);\n}\nvec4 mUnion(in mRay m, vec4 a, vec4 b)\n{\n    if(m.t<0.) return  min(a,b);\n    else {\n        /*\n        if(a.x==NOHIT) return b;\n        if(b.x==NOHIT) return a;\n        if(a.y < b.x )                            return vec4(a.x,a.y,b.x,b.y);     //AAAA---BBBBB\n        if(a.x < b.x  && a.y > b.x && a.y<b.y )   return vec4(a.x,b.y,vec2(NOHIT)); //AAAB***ABBBB\n        if(a.x < b.x  && a.y > b.y )              return vec4(a.x,a.y,vec2(NOHIT)); //AAAB***BAAAA\n        if(a.x > b.x && a.x<b.y   &&  a.y < b.y ) return vec4(b.x,b.y,vec2(NOHIT)); //BBBA***ABBB\n        if(a.x > b.x && a.x<b.y   &&  a.y > b.y ) return vec4(b.x,a.y,vec2(NOHIT)); //BBBA***BAAA\n        if(a.x > b.y )                            return vec4(b.x,b.y,a.x,a.y); //BBBBB--AAA\n        */\n        return vec4(min(a.x,b.x),max(a.y,b.y),NOHIT,NOHIT);\n    }\n}\n\n//WIP https://web.cse.ohio-state.edu/~parent.1/classes/681/Lectures/19.RayTracingCSG.pdf\nvec4 mSub(in mRay m, vec4 b, vec4 a)\n{\n    if(m.t<0.) return   vec4(max(-a,b));\n    else{\n        if(b.x==NOHIT || a.x==NOHIT) return b; //no intersection\n        else if(a.x< b.x && a.y>b.x  && b.y>=a.y ) return vec4(a.y,b.x,NOHIT,NOHIT);              \n        else return b;\n    }\n}","name":"Common","description":"","type":"common"}]}