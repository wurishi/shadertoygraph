{"ver":"0.1","info":{"id":"3lffz2","date":"1597138499","viewed":125,"name":"Curl Boundary","username":"yuyujunjun","description":"Show 2D Curl with collision avoidance boundary. Use radius to control the range of fields affected.\nArrow drawing algorithm is from https://www.shadertoy.com/view/MdK3zy","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["2d","curl","boundary"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float TILE_SIZE = 0.045;\nconst float radius=0.3;\nvec2 velocity(){\n\t//return vec2(0);\n\treturn 0.1*vec2(sin(iTime),cos(iTime));\n}\nfloat sdfSphere(vec2 pos){\n\treturn length(pos)-0.2;\n}\nfloat sdPentagon( in vec2 p, in float r )\n{\n    const vec3 k = vec3(0.809016994,0.587785252,0.726542528);\n    p.x = abs(p.x);\n    p -= 2.0*min(dot(vec2(-k.x,k.y),p),0.0)*vec2(-k.x,k.y);\n    p -= 2.0*min(dot(vec2( k.x,k.y),p),0.0)*vec2( k.x,k.y);\n    p -= vec2(clamp(p.x,-r*k.z,r*k.z),r);    \n    return length(p)*sign(p.y);\n}\nfloat sdf( vec2 p)\n{\n\tp+=vec2(-1,-0.5)+0.3*vec2(sin(.5*iTime),cos(.2*iTime));\n\t//p+=velocity();\n\tfloat sphereDis=sdfSphere(p+0.1);\n\tfloat dis=sdPentagon(p,0.2);\n\t//return dis;\n\tif(sphereDis<dis){\n\t\treturn sphereDis;\n\t}else{\n\t\treturn dis;\n\t}\n\n}\nfloat ramp(float r){\n\tif(r>1.)return 1.;\n\tif(r<-1.)return -1.;\n\treturn r*15./8.-r*r*r*10./8.+3./8.*r*r*r*r*r;\n}\n\nvec2 sdOrientedBox( in vec2 p, in vec2 a, in vec2 b, float th )\n{\n    float l = length(b-a);\n//\tif(l<0.000000000000001)return 0.;\n    vec2  d = (b-a)/l;\n    vec2  q = (p-(a+b)*0.5);\n          q = mat2(d.x,-d.y,d.y,d.x)*q;\n          q = abs(q)-vec2(l,th)*0.5;\n\tfloat dis=length(p-a);\n\tfloat dis1=length(p-b);\n\tvec2 result;\n\tresult.x=length(max(q,0.0001)) + min(max(q.x,q.y),0.0);\n\tresult.y=dis>dis1?-1.:1.;\n    return     result;\n}\n// get the arrow color under pos (transparent if no hit)\nvec3 arrowColor(vec2 p, vec2 arrow_center, vec2 arrow_vec) \n{\n    float scale = TILE_SIZE;\n    //arrow_vec = normalize( arrow_vec );\n\t\n\tvec2 darrow = sdOrientedBox(p, arrow_center - arrow_vec*scale, arrow_center + arrow_vec*scale,0.1*scale);\n\tif( darrow.x> 0.0 )\n        return vec3(0.0);\n    return darrow.y>0.?vec3(1,0,0):vec3(0,1,1);\n    return vec3( 1 );\n}\n// comp\n// computes arrow center location from given pos\nvec2 arrowTilePos(vec2 p) \n{\n\treturn ((floor(p / TILE_SIZE)+0.5)*TILE_SIZE) ;\n}\nvec2 field2d(vec2 p)\n{\n\tvec2 field;\n    field.x = cos(3.0*p.x)* sin(5.0*p.y);\n\tp+=vec2(0.001);\n\tfield.y= cos(3.0*p.x)* sin(5.0*p.y);\n    return (field);\n}\n\n\n\nvec2 curl2d(vec2 p)\n{\n    vec3 e = vec3(0.01,-0.01,0.0);\n\n    float fxp = field2d(p + e.xz).x;\n\tfxp*=ramp(sdf(p+e.xz)/radius);\n\t\n    float fxm = field2d(p + e.yz).x;\n\tfxm*=ramp(sdf(p+e.yz)/radius);\n\n    float fyp = field2d(p + e.zx).x;\n\tfyp*=ramp(sdf(p+e.zx)/radius);\n\t\n    float fym = field2d(p + e.zy).x;\n\tfym*=ramp(sdf(p+e.zy)/radius);\n\t\n    vec2 c = vec2( \t(fyp - fym) / (2.*e.x),\n                 \t(-fxp + fxm) / (2.*e.x) );\n\treturn c;   \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = vec2( (fragCoord.xy / iResolution.xx ) * 2.0 );\n    \n    vec3 col = vec3(0.0);\n    col = arrowColor( p, arrowTilePos(p), curl2d( arrowTilePos(p) ) );\n\tfloat a=sdf(p);\n\tif(a<0.003&&a>-0.003)col=vec3(0.8,0.3,0.4);\n    \n    fragColor = vec4(col,1.);\n}","name":"Image","description":"","type":"image"}]}