{"ver":"0.1","info":{"id":"7dsyWn","date":"1641981264","viewed":175,"name":"Fresh and Tasty","username":"PGRacer","description":"WASD + space + shift to move\n\nMy first attempt to model out a full scene.  I think it went well!\n\n\n\n","likes":20,"published":1,"flags":48,"usePreview":0,"tags":["3d","raymarching","sdf","texturemapping"],"hasliked":0,"parentid":"slVXDz","parentname":"PGRacer - Raymarching Template"},"renderpass":[{"inputs":[{"id":"4sXGRn","filepath":"/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","previewfilepath":"/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","previewfilepath":"/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//////////////////\n// IMAGE SHADER //\n//////////////////\n\n// Dimensions\nfloat canBodyHeight = 6.0;\nfloat canRadius = 2.0;\nfloat canThickness = 0.05;\nfloat taperHeight = 0.4;\nfloat taperCapRatio = 0.2;\nfloat rimInnerRadius = 0.1;\nfloat trayThickness = 0.1;\nfloat trayRadius = 13.0;\nfloat linkRadius = 0.4;\nfloat canOffset = 2.0;\n\nfloat MAT_LABEL = 1.0;\nfloat MAT_OUTER_CAN = 2.0;\nfloat MAT_LIQUID = 3.0;\nfloat MAT_WOOD = 4.0;\nfloat MAT_METAL = 5.0;\n\nvec3 pCan;\n\nvec2 Tab(vec3 p)\n{\n    vec2 dLink = Link(p, linkRadius, linkRadius, 0.075);\n    vec2 dTorus1 = Torus(p - FORWARD * 0.25, 0.25, 0.05);\n    \n    vec2 dTab = SmoothUnion(dLink, dTorus1, 0.1);\n    dTab.y = MAT_OUTER_CAN;\n    \n    return dTab;\n}\n\nvec2 End(vec3 p)\n{\n    vec3 pCone = p - UP * (canBodyHeight + taperHeight) / 2.0;\n    vec2 dCone = CappedCone(pCone, taperHeight / 2.0, canRadius, canRadius * 0.75);\n    vec3 pConeCavity = pCone - DOWN * canThickness;\n    vec2 dConeCavity = CappedCone(pConeCavity, taperHeight / 2.0, canRadius, canRadius * 0.75);\n    \n    vec3 pRim = p - UP * (canBodyHeight / 2.0 + 0.4);\n    vec2 dRim = Torus(pRim, canRadius * 0.75, rimInnerRadius);\n    \n    vec2 dEnd = Difference(dCone, dConeCavity);\n    dEnd = SmoothUnion(dEnd, dRim, 0.1);\n    dEnd.y = MAT_OUTER_CAN;\n    \n    return dEnd;\n}\n\nvec2 Body(vec3 p)\n{    \n    vec2 dOutside = Tube(p, canBodyHeight, canRadius - canThickness, canThickness);\n    dOutside.y = MAT_LABEL;\n    \n    vec2 dBody = dOutside;\n    \n    return dBody;\n}\n\nvec2 Can(vec3 p, vec2 prevNearest)\n{\n    vec2 dBoundingVolume = Box(p - UP * 0.3, vec3(canRadius * 2.05, (canBodyHeight + 2.0 * taperHeight) * 1.15, canRadius * 2.01));\n    if (dBoundingVolume.x > prevNearest.x)\n    {\n       return prevNearest;\n    }\n    \n    vec2 dBody = Body(p);\n    \n    vec3 pEnds = AbsY(p);\n    vec2 dEnds = End(pEnds);\n    \n    vec3 pTab = RotateX(-PI / 6.0) * (p - vec3(0.0, 0.45 + (taperHeight + canBodyHeight) *0.5, -0.2));\n    vec2 dTab = Tab(pTab);\n    \n    vec3 pHole = RotateZ(PI / 2.0) * (p - vec3(0.0, canBodyHeight / 2.0 + taperHeight, 0.6));\n    vec2 dHole = Capsule(pHole, canRadius * 0.2, canRadius * 0.25);\n    \n    vec3 pDepression1 = p - UP * (canBodyHeight / 2.0 + taperHeight + rimInnerRadius * 0.75);\n    vec2 dDepression1 = Torus(pDepression1, canRadius * 0.62, rimInnerRadius);\n    \n    vec3 pDepression2 = p - vec3(0.0, 0.05 + canBodyHeight / 2.0 + taperHeight, -0.3);\n    vec4 eDepression2 = Elongate(pDepression2, vec3(0.0, 0.0, 0.2));\n    vec2 dDepression2 = eDepression2.w + Cylinder(eDepression2.xyz, 0.05, canRadius * 0.3);\n    \n    vec2 dCan = Union(dBody, dEnds);\n    dCan = Difference(dCan, dHole);\n    dCan = SmoothDifference(dCan, dDepression1, 0.01);\n    dCan = SmoothDifference(dCan, dDepression2, 0.075);\n    dCan = Union(dCan, dTab);\n    \n    pCan = p; // Store p so we can calc can tex coords if its an actual hit. Only really works here because the bounding boxes on the can never intersect in this scene.\n    \n    return dCan;\n}\n\nvec2 Tray(vec3 p)\n{\n    vec2 dSurface = Cylinder(p, trayThickness, trayRadius);\n    dSurface.y = MAT_WOOD;\n\n    vec3 pRim = p - UP * trayThickness * 2.0;\n    vec2 dRim = Torus(pRim, trayRadius - trayThickness / 2.0, trayThickness * 2.0);\n    dRim.y = MAT_METAL;\n\n    vec2 dTray = Union(dSurface, dRim);\n\n    return dTray;\n}\n\nvec2 Flow(vec3 p)\n{\n    float angle1 = atan(p.y, p.x);\n    float angle2 = atan(p.y, p.z);\n    float radius = 0.35 + sin((-TIME * 14.678 + angle1) * 10.0) * 0.02 + sin((TIME * 11.234 + angle2) * 5.0) * 0.02;\n    vec3 pFlow = RotateZ(-PI * 0.16) * p;\n    vec2 dFlow = CappedTorus(pFlow, PI * 0.2, 1.5, radius);\n    dFlow.y = MAT_LIQUID;\n    \n    return dFlow * 0.95;\n}\n\nvec2 Puddle(vec3 p)\n{\n    float angle = atan(p.z, p.x);\n    angle = cos(angle * TAU);\n    float puddleNoiseMagnitude = 0.06;\n    float ratio = NSin(angle * 3.0) * puddleNoiseMagnitude + (1.0 - puddleNoiseMagnitude);\n    \n    p.x *= ratio;\n    p.z *= ratio;\n    \n    float dFromFlow = length(p - vec3(2.25, 0.0, 1.0));\n    float pWaveHeight = NSin((dFromFlow - TIME * 5.0) * 14.678) * min(0.1, pow(0.025, dFromFlow * 0.4));\n    \n    vec3 pPuddle1 = p / vec3(1.8, 1.0, 1.0);\n    vec2 dPuddle1 = Cylinder(pPuddle1, pWaveHeight, 1.65);\n    \n    vec3 pPuddle2 = (p - vec3(-1.3, 0.0, 0.98)) / vec3(2.32, 1.0, 1.3);\n    vec2 dPuddle2 = Cylinder(pPuddle2, pWaveHeight, 0.9);\n    \n    vec3 pPuddle3 = (p - vec3(2.3, 0.0, 0.83)) / vec3(3.5, 1.0, 1.9);\n    vec2 dPuddle3 = Cylinder(pPuddle3, pWaveHeight, 1.2);\n    \n    vec3 pPuddle4 = (p - vec3(-0.3, 0.0, 1.5)) / vec3(2.1, 1.0, 2.0);\n    vec2 dPuddle4 = Cylinder(pPuddle4, pWaveHeight, 1.2);\n    \n    vec2 dPuddle = Union(dPuddle1, dPuddle2);\n    dPuddle = Union(dPuddle, dPuddle3);\n    dPuddle = Union(dPuddle, dPuddle4);\n    dPuddle.x -= 0.1;\n    dPuddle.y = MAT_LIQUID;\n    \n    dPuddle.x *= 0.9;\n    \n    return dPuddle;\n}\n\nvec2 Scene(vec3 p)\n{   \n    float canHeight = canBodyHeight + 2.0 * (taperHeight + rimInnerRadius);\n    \n    vec3 pSixPack = RotateY(-0.3) * (p - vec3(4.0, 0.5 * canHeight, 5.0));\n    pSixPack = RepeatRange(pSixPack, vec3(canRadius * 2.15, canHeight, canRadius * 2.15), vec3(3.0, 1.0, 2.0));\n    \n    vec3 pFlowingCan = RotateX(-PI * 0.5) * RotateY(TAU / 3.0) * (p - vec3(5.0, canRadius + 0.5 * trayThickness, -7.8));\n    float roll = sin(TIME * 1.5) * 0.5;\n    vec3 pRollingCan = RotateY(-roll) * (RotateZ(PI * 0.25) * RotateX(PI / 2.0) * (p - vec3(-7.0 + roll * canRadius, canRadius + 0.5 * trayThickness, -2.0 + roll * canRadius)));\n    \n    vec3 pPuddle = p - vec3(-1.0, 0.1, -11.0);\n    vec2 dPuddle = Puddle(pPuddle);\n    vec3 pFlow = RotateY(PI * 0.2) * (p - vec3(2.5, -0.2, -9.2));\n    vec2 dFlow = Flow(pFlow);\n    vec2 dLiquid = SmoothUnion(dPuddle, dFlow, 0.27);\n    vec2 dTray = Tray(p);\n\n    vec2 dist = dTray;\n    \n    dist = Union(dist, dLiquid);\n    dist = Union(dist, Can(pFlowingCan, dist));\n    dist = Union(dist, Can(pRollingCan, dist));\n    dist = Union(dist, Can(pSixPack, dist));\n    \n    return Union(dist, dTray);\n}\n\nvec3 GetNormal(vec3 p)\n{\n\tvec2 e = vec2(NORMAL_CHECK_OFFSET, 0);\n    \n\tvec3 n = Scene(p).x - vec3(\n\t\tScene(p - e.xyy).x,\n\t\tScene(p - e.yxy).x,\n\t\tScene(p - e.yyx).x\n\t\t);\n\treturn normalize(n);\n}\n\nfloat ambientOcclusion(vec3 p, vec3 n) {\n  float stepSize = AMBIENT_OCCLUSION_STEP_SIZE;\n  float t = stepSize;\n\n  float ac = 0.0;\n\n  for(int i = 0; i < AMBIENT_OCCLUSION_STEP_COUNT; i++) {\n    float d = Scene(p + n * t).x;\n    ac += t - d;\n    t += stepSize;\n  }\n\n    //return ac;\n    return clamp((1.0 - smoothstep(-AMBIENT_OCCLUSION_ATTENUATION, AMBIENT_OCCLUSION_ATTENUATION, ac)) * (1.0 - AMBIENT_STRENGTH) + AMBIENT_STRENGTH, 0.0, 1.0);\n}\n\nfloat HardShadow(vec3 surfPos, vec3 lightPos)\n{\n    float dO = 0.0;\n    vec3 rayDir = normalize(lightPos - surfPos);\n    float lightDist = distance(surfPos, lightPos);\n    float ao;\n    \n    while (dO < lightDist)\n\t{\n        vec3 p = surfPos + rayDir * dO;\n        float d = Scene(p).x;\n        dO += d;\n        \n        if (d <= SURFACE_DISTANCE_TOLERANCE)\n        {\n            return 0.0;\n        }\n    }\n    \n    return 1.0;\n}\n\nfloat SoftShadow(vec3 ro, vec3 rd, float tMax)\n{\n    float res = 1.0;\n    float t = SHADOW_CORRECTION;\n    for( int i=0; i<50; i++ )\n    {\n        float h = Scene(ro + rd*t).x;\n        res = min( res, tMax*h/t );\n        t += h;clamp( h, 0.005, 0.5 );\n        if( res<0.005 || t>tMax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\nvec4 Raymarch(vec3 origin, vec3 rayDir, out float distFromOrigin, out bool hit, out bool outline)\n{\n    float outlineWidth = OUTLINE_WIDTH / iResolution.x;\n    vec3 point;\n    float prevDist = MAX_DIST;\n    vec2 surfaceHit;\n\n    for (int i = 0; i < MAX_STEPS; i++)\n    {\n        point = origin + rayDir * distFromOrigin;\n\t\tsurfaceHit = Scene(point);\n\t\tdistFromOrigin += surfaceHit.x;\n        \n        if (surfaceHit.x < outlineWidth * pow(distFromOrigin, OUTLINE_DIST_COMP))\n\t\t{\n\t\t\toutline = true;\n\t\t}\n        \n        if (distFromOrigin >= MAX_DIST)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\n\t\tif (surfaceHit.x < SURFACE_DISTANCE_TOLERANCE)\n\t\t{\n            hit = true;\n\t\t\toutline = false;\n\t\t\tbreak;\n\t\t}\n        \n        if (outline && prevDist < surfaceHit.x)\n        {\n            hit = false;\n            break;\n        }\n        \n        prevDist = surfaceHit.x;\n    }\n    \n    return vec4(point.xyz, surfaceHit.y);\n}\n\nvec3 GetLight(vec3 p, vec3 normal)\n{\n    vec3 lightColor = vec3(1.0);\n\n    //lightColor = pow(abs(normal), vec3(COLOR_SHARPENING));\n    float ao = ambientOcclusion(p, normal);\n    vec3 absNormal = abs(normal);\n\n    vec3 lightPos = vec3(-20.0, 24.0, -30.0);\n    //lightPos = RotateY(TIME * 0.623) * lightPos; \n\n    vec3 lightDir = normalize(p - lightPos);\n\n    float lightDistance = distance(p, lightPos);\n    float shadowValue = SoftShadow(p, -lightDir, lightDistance);\n    //float shadowValue = HardShadow(p + normal * SURFACE_DISTANCE_TOLERANCE * 1.01, lightPos);\n\n    float lightDist = distance(p, lightPos);\n    float attenuation = 1.0 / (pow(lightDist, LIGHT_ATTENUATION));\n    float light = LIGHT_STRENGTH * attenuation;\n\n    float scalar = dot(-lightDir, normal);\n    float specular = SPECULAR_POWER * pow(scalar, SPECULAR_FOCUS);\n    light += specular;\n    scalar = clamp(scalar, 0.0, 1.0);\n    light = mix(AMBIENT_STRENGTH, light, scalar);\n    light = mix(AMBIENT_STRENGTH, light, shadowValue);\n    light = max(AMBIENT_STRENGTH, light);\n    lightColor *= light;\n    lightColor *= ao;\n        \n    return lightColor;\n}\n\nvec3 GetTriPlanarTexture(vec3 p, vec3 normal, sampler2D sampler)\n{\n    vec3 texXY = texture(sampler, p.xy * 0.5 + 0.5).rgb;\n    vec3 texXZ = texture(sampler, p.xz * 0.5 + 0.5).rgb;\n    vec3 texYZ = texture(sampler, p.yz * 0.5 + 0.5).rgb; \n        \n    normal = abs(normal);\n    normal = pow(normal, vec3(1.0));\n    normal /= SumComponents(normal);\n    \n    vec3 tex = texXY * normal.z + texXZ * normal.y + texYZ * normal.x;\n    \n    return tex;\n}\n\nvec3 GetColor(float matID, vec3 p, vec3 normal)\n{\n    if (matID == MAT_LABEL)\n    {\n        vec2 uvCan = vec2(atan(pCan.z, pCan.x) / TAU + 0.5, pCan.y / canBodyHeight + 0.5);\n        return texture(iChannel1, uvCan).rgb;    \n    }\n    if (matID == MAT_OUTER_CAN) return vec3(0.7);\n    if (matID == MAT_LIQUID) return BROWN * 0.5;\n    if (matID == MAT_WOOD) \n    {\n        p *= vec3(0.2);\n        vec3 tex = GetTriPlanarTexture(p, normal, iChannel2);\n        return tex;\n    }\n    if (matID == MAT_METAL)\n    {\n        vec3 tex = GetTriPlanarTexture(p, normal, iChannel3);\n        return tex;\n    }\n}\n\nvec3 ColorCorrection(vec3 color)\n{\n    if (COLOR_BIT_DEPTH < 8.0)\n    {\n        float colorsPerChannel = pow(2.0, COLOR_BIT_DEPTH);\n        color = floor(color * colorsPerChannel) / colorsPerChannel;\n    }\n    \n    color = (color - vec3(0.5)) * CONTRAST + vec3(0.5);\n    color = pow(color / 255.0, vec3(1.0 / GAMMA)) * 255.0;\n    color = mix(vec3(AvgComponentLength(color)), color, SATURATION);\n    color = mix(color, vec3(1.0) - color, NEGATIVE);\n    color *= TINT;\n\n    return color;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Alter resolution for old-school look\n    fragCoord *= RESOLUTION_RATIO;\n    fragCoord = floor(fragCoord) / RESOLUTION_RATIO;\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    // Split-screen stereoscopy\n#ifdef STEREO_ENABLED\n    bool leftEye = uv.x >= 0.5;\n    uv.x = fract(uv.x * 2.0);\n    uv.x *= 0.5;\n    uv -= vec2(0.25, 0.5);\n#else\n    uv -= vec2(0.5);\n#endif\n\n    // Vignette\n    float uvLength = length(uv);\n    uvLength = uvLength * 1.33333 - .25;\n    float vignette = smoothstep(0.99, 0.001, uvLength);\n    \n    // Aspect ratio\n    float aspectRatio = iResolution.x / iResolution.y;\n    uv.x *= aspectRatio;\n\n    // Camera Stuff\n    vec3 camPos = textureLod(iChannel0, vec2(0.5, 0.5)/iResolution.xy, 0.0).xyz;\n\n\n    // Camera look direction\n    vec3 camRot = textureLod(iChannel0, vec2(1.5, 0.5)/iResolution.xy, 0.0).xyz;\n    mat3x3 yawMat = Rotate3(camRot.x, UP);\n    mat3x3 pitchMat = Rotate3(camRot.y, RIGHT);\n    mat3x3 rollMat = Rotate3(camRot.z, FORWARD);\n    mat3x3 rotMat = yawMat * pitchMat * rollMat;\n    vec3 camDir = rotMat * normalize(vec3(uv.x, uv.y, 1.0));\n    \n#ifdef STEREO_ENABLED\n    // Stereo eye-positioning\n    camPos += rotMat * ((leftEye ? LEFT : RIGHT) * INTERPUPILARY_DISTANCE * 0.5);\n#endif\n    \n    // Do raymarching\n    float distFromOrigin = 0.0;\n    bool hit;\n\tbool outline;\n    float prevDist = MAX_DIST * MAX_DIST;\n\n    vec4 p = Raymarch(camPos, camDir, distFromOrigin, hit, outline);\n    \n    // Background\n    vec3 bgColor = mix(vec3(0.0), vec3(1.0, 1.0, 1.0), smoothstep(-1.0, -.25, -abs(camDir.y)));\n    vec3 color = WHITE;\n    \n    float distRatio = distFromOrigin / MAX_DIST;\n    \n    // Apply color to pixel\n    if (hit)\n    {\n        vec3 hitPoint = p.xyz;\n        float matID = p.w;\n        vec3 normal = GetNormal(p.xyz);\n        color = GetColor(matID, hitPoint, normal);\n        \n        color *= GetLight(hitPoint, normal);\n        float distRatio = distFromOrigin / MAX_DIST;\n    }\n    else if (outline)\n    {\n        color = vec3(0.0);\n    }\n    else\n    {\n        color = bgColor;\n    }\n    \n    // Saturate and apply distance fade\n    color = clamp(color, vec3(0.0), vec3(1.0));\n    color = mix(color, bgColor, pow(distRatio, FADE_ATTENUATION));\n    \n    // Apply color correction\n    color = ColorCorrection(color);\n    \n#ifdef SCAN_LINES_ENABLED\n    if (mod(fragCoord.y * RESOLUTION_RATIO, 2.0) < 1.0) color = BLACK;\n#endif\n    \n    // Fade scene in at start\n    color *= smoothstep(FADE_IN_DELAY, FADE_IN_DELAY + FADE_IN_LENGTH, iTime);\n    color *= vignette;\n        \n    // Output to screen\n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"/////////////////////////////////\n// COMMON FUNCTIONS AND VALUES //\n/////////////////////////////////\n\n// RAYMARCHING\n#define MAX_STEPS 2000\n#define MAX_DIST 50.0\n#define SURFACE_DISTANCE_TOLERANCE 0.0001\n#define NORMAL_CHECK_OFFSET 0.001\n\n// TIMING\n#define TIME iTime * 0.5\n\n// OUTLINE\n#define OUTLINE_WIDTH 8.0\n#define OUTLINE_DIST_COMP 0.7 // 0.0 lines shrink linearly with distance, 0.5 - lines stay same world-width at all distances, 1.0 - lines stay same screen width at distance \n\n// LIGHTING\n#define LIGHT_STRENGTH 3000.0\n#define LIGHT_ATTENUATION 2.0\n#define FADE_ATTENUATION 1.5\n#define SPECULAR_POWER 2.0\n#define SPECULAR_FOCUS 64.0\n#define AMBIENT_STRENGTH 0.5\n#define AMBIENT_OCCLUSION_STEP_SIZE 0.03\n#define AMBIENT_OCCLUSION_STEP_COUNT 15\n#define AMBIENT_OCCLUSION_ATTENUATION 6.0\n#define SHADOW_CORRECTION 0.01\n#define SHADOW_SHARPEN 1.0\n\n// SCENE START\n#define FADE_IN_DELAY 0.1\n#define FADE_IN_LENGTH 1.0\n\n// COMMON CONSTANTS\n#define TAU 6.283185\n#define PI  TAU / 2.0\n#define ROOT2 1.414213\n\n// AXIAL VECTORS\n#define FORWARD vec3(0.0, 0.0, 1.0)\n#define BACKWARD vec3(0.0, 0.0, -1.0)\n#define LEFT vec3(-1.0, 0.0, 0.0)\n#define RIGHT vec3(1.0, 0.0, 0.0)\n#define UP vec3(0.0, 1.0, 0.0)\n#define DOWN vec3(0.0, -1.0, 0.0)\n\n// COLORS\n#define BLACK vec3(0.0)\n#define BLUE vec3(0.0, 0.0, 1.0)\n#define BROWN vec3(0.5, 0.2, 0.0)\n#define DARK_GREY vec3(0.25, 0.25, 0.25)\n#define FUCHSIA vec3(1.0, 0.0, 1.0)\n#define GREEN vec3(0.0, 1.0, 0.0)\n#define LIGHT_GREY vec3(0.75, 0.75, 0.75)\n#define MEDIUM_GREY vec3(0.5, 0.5, 0.5)\n#define ORANGE vec3(1.0, 0.5, 0.0)\n#define PINK vec3(1.0, 0.5, 0.5)\n#define RED vec3(1.0, 0.0, 0.0)\n#define TURQOISE vec3(0.0, 1.0, 1.0)\n#define WHITE vec3(1.0)\n#define YELLOW vec3(1.0, 1.0, 0.0)\n\n// COLOR CORRECTION\n#define COLOR_BIT_DEPTH 8.0\n#define GAMMA 1.0\n#define CONTRAST 1.0\n#define SATURATION 1.0\n#define NEGATIVE 0.0\n#define TINT WHITE\n\n// RENDERING OPTIONS\n//#define STEREO_ENABLED // Comment/Uncomment to disable/enable. Use cross-eye method to view.\n#define INTERPUPILARY_DISTANCE 1.0 // Not a real world measurment. Maybe in the future.\n//#define SCAN_LINES_ENABLED // Comment/Uncomment to disable/enable.\n#define RESOLUTION_RATIO 1.0 // 0.0 will result in divide-by-zero, magnitude 1.0+ will have no effect.  negative values will shift pixels (-1,-1).\n\n// INPUT KEYS\n#define KEY_SHIFT   16\n#define KEY_CONTROL 17\n#define KEY_SPACE   32\n#define KEY_LEFT    37\n#define KEY_UP      38\n#define KEY_RIGHT   39\n#define KEY_DOWN    40\n#define KEY_A       65\n#define KEY_B       66\n#define KEY_C       67\n#define KEY_D       68\n#define KEY_E       69\n#define KEY_F       70\n#define KEY_G       71\n#define KEY_H       72\n#define KEY_I       73\n#define KEY_J       74\n#define KEY_K       75\n#define KEY_L       76\n#define KEY_M       77\n#define KEY_N       78\n#define KEY_O       79\n#define KEY_P       80\n#define KEY_Q       81\n#define KEY_R       82\n#define KEY_S       83\n#define KEY_T       84\n#define KEY_U       85\n#define KEY_V       86\n#define KEY_W       87\n#define KEY_X       88\n#define KEY_Y       89\n#define KEY_Z       90\n#define KEY_0       48\n#define KEY_1       49\n#define KEY_2       50\n#define KEY_3       51\n#define KEY_4       52\n#define KEY_5       53\n#define KEY_6       54\n#define KEY_7       55\n#define KEY_8       56\n#define KEY_9       57\n\n// MOUSE BUTTON INPUT\nbool IsNewClick(vec2 mouseData)\n{\n    return mouseData.x > 0.0 && mouseData.y < 1.0;\n}\n\nbool IsPersistentClick(vec2 mouseData)\n{\n    return mouseData.x > 0.0 && mouseData.y > 0.0;\n}\n\nbool IsNewRelease(vec2 mouseData)\n{\n    return mouseData.x < 1.0 && mouseData.y > 0.0;\n}\n\nbool IsPersistentRelease(vec2 mouseData)\n{\n    return mouseData.x < 1.0 && mouseData.y < 1.0;\n}\n\n// KEYBOARD INPUT\nbool ReadKey(sampler2D sampler, int key, bool toggle)\n{\n\treturn textureLod(sampler, vec2( (float(key)+.5)/256.0, toggle?.75:.25 ), 0.0 ).x > 0.0;\n}\n\n// MATRICES\nmat2x2 Rotate2(float angle)\n{\n    float s = sin(angle);\n    float c = cos(angle);\n    return mat2x2(c, -s, s, c);\n}\n\nmat3x3 Rotate3(float angle, vec3 axis)\n{\n\tfloat c = cos(angle);\n    float s = sin(angle);\n\n\tfloat t = 1.0 - c;\n\tfloat x = axis.x;\n\tfloat y = axis.y;\n\tfloat z = axis.z;\n\n\treturn mat3x3\n\t(\n        t * x * x + c,      t * x * y - s * z,  t * x * z + s * y,\n\t\tt * x * y + s * z,  t * y * y + c,      t * y * z - s * x,\n\t\tt * x * z - s * y,  t * y * z + s * x,  t * z * z + c\n\t);\n}\n\nmat3 RotateX(float angle) {\n\tfloat s = sin(angle);\n\tfloat c = cos(angle);\n\n\treturn mat3(\n\t\t1.0, 0.0, 0.0,\n\t\t0.0, c, s,\n\t\t0.0, -s, c\n\t);\n}\n\nmat3 RotateY(float angle) {\n\tfloat s = sin(angle);\n\tfloat c = cos(angle);\n\n\treturn mat3(\n\t\tc, 0.0, -s,\n\t\t0.0, 1.0, 0.0,\n\t\ts, 0.0, c\n\t);\n}\n\nmat3 RotateZ(float angle) {\n\tfloat s = sin(angle);\n\tfloat c = cos(angle);\n\n\treturn mat3(\n\t\tc, s, 0.0,\n\t\t-s, c, 0.0,\n\t\t0.0, 0.0, 1.0\n\t);\n}\n\n// USEFUL MATH STUFF\nfloat SumComponents(vec3 v)\n{\n    return v.x + v.y + v.z;\n}\nfloat SumComponentLength(vec3 v)\n{\n    return SumComponents(abs(v));\n}\n\nfloat AvgComponents(vec3 v)\n{\n    return (v.x + v.y + v.z) / 3.0;\n}\n\nfloat AvgComponentLength(vec3 v)\n{\n    return AvgComponents(abs(v));\n}\n\nfloat NSin(float value)\n{\n    return sin(value) * 0.5 + 0.5;\n}\n\nfloat NCos(float value)\n{\n    return cos(value) * 0.5 + 0.5;\n}\n\nfloat SFract(float v)\n{\n    if (v >= 0.0)\n    {\n        return v - floor(v);\n    }\n    return -(v - ceil(v));\n}\n\nvec2 SFract(vec2 v)\n{\n    return vec2(SFract(v.x), SFract(v.y));\n}\n\nvec3 SFract(vec3 v)\n{\n    return vec3(SFract(v.xy), SFract(v.z));\n}\n\nfloat SMod(float v, float x)\n{\n    return x == 0.0 ? v : SFract(v / x) * x;\n}\n\nvec2 SMod(vec2 v, vec2 x)\n{\n    return vec2(SMod(v.x, x.x), SMod(v.y, x.y));\n}\n\nvec3 SMod(vec3 v, vec3 x)\n{\n    return vec3(SMod(v.xy, x.xy), SMod(v.z, x.z));\n}\n\nvec3 FlipX(vec3 p)\n{\n    return vec3(-p.x, p.y, p.z);\n}\n\nvec3 FlipY(vec3 p)\n{\n    return vec3(p.x, -p.y, p.z);\n}\n\nvec3 FlipZ(vec3 p)\n{\n    return vec3(p.x, p.y, -p.z);\n}\n\nvec3 AbsX(vec3 p)\n{\n    return vec3(abs(p.x), p.y, p.z);\n}\n\nvec3 AbsY(vec3 p)\n{\n    return vec3(p.x, abs(p.y), p.z);\n}\n\nvec3 AbsZ(vec3 p)\n{\n    return vec3(p.x, p.y, abs(p.z));\n}\n\nvec3 AbsXY(vec3 p)\n{\n    return vec3(abs(p.x), abs(p.y), p.z);\n}\n\nvec3 AbsXZ(vec3 p)\n{\n    return vec3(abs(p.x), p.y, abs(p.z));\n}\n\nvec3 AbsYZ(vec3 p)\n{\n    return vec3(p.x, abs(p.y), abs(p.z));\n}\n\nvec3 NegateX(vec3 p)\n{\n    return vec3(-abs(p.x), p.y, p.z);\n}\n\nvec3 NegateY(vec3 p)\n{\n    return vec3(p.x, -abs(p.y), p.z);\n}\n\nvec3 NegateZ(vec3 p)\n{\n    return vec3(p.x, p.y, -abs(p.z));\n}\n\n// COMBINATIONS\nvec2 Union(vec2 d1, vec2 d2)\n{\n    return d1.x < d2.x ? d1 : d2;\n}\n\nvec2 SmoothUnion(vec2 d1, vec2 d2, float smoothing)\n{\n    float h = clamp(0.5 + 0.5 * (d2.x - d1.x) / smoothing, 0.0, 1.0);\n    return vec2(mix(d2.x, d1.x, h) - smoothing * h * (1.0 - h), d1.y);\n}\n\nvec2 Difference(vec2 d1, vec2 d2)\n{\n    return d1.x > -d2.x ? d1 : vec2(-d2.x, d1.y);\n}\n\nvec2 SmoothDifference(vec2 d1, vec2 d2, float smoothing) {\n    float h = max(smoothing - abs(-d2.x - d1.x), 0.0);\n    return vec2(max(d1.x, -d2.x) + h * h  *0.25 / smoothing, d1.y);\n}\n\nvec2 Intersection(vec2 d1, vec2 d2)\n{\n    return d1.x > d2.x ? d1 : d2;\n}\n\nvec2 SmoothIntersection(vec2 d1, vec2 d2, float smoothing) {\n    float h = clamp(0.5 - 0.5 * (d2.x-d1.x) / smoothing, 0.0, 1.0);\n    return vec2(mix(d2.x, d1.x, h) + smoothing * h * (1.0 - h), d1.y);\n}\n\nfloat Layer(float d, float h)\n{\n    return abs(d) - h;\n}\n\nvec2 CapX(vec3 p, vec2 d, float h)\n{\n    return Intersection(d, vec2(p.x - h, d.y));\n}\n\nvec2 CapY(vec3 p, vec2 d, float h)\n{\n    return Intersection(d, vec2(p.y - h, d.y));\n}\n\nvec2 CapZ(vec3 p, vec2 d, float h)\n{\n    return Intersection(d, vec2(p.z - h, d.y));\n}\n\n// DISTORTIONS\nvec3 Twist(vec3 p, float twist)\n{\n    float c = cos(twist * p.y);\n    float s = sin(twist * p.y);\n    mat2  m = mat2(c, -s ,s, c);\n    vec3  q = vec3(m * p.xz, p.y);\n    return q;\n}\n\nvec3 Bend(vec3 p, float bend)\n{\n    float c = cos(bend * p.x);\n    float s = sin(bend * p.x);\n    mat2  m = mat2(c, -s, s, c);\n    vec3  q = vec3(m * p.xy, p.z);\n    return q;\n}\n\nvec4 Elongate(vec3 p, vec3 h)\n{   \n    // Usage: dist = min(dist, w.w+DistFunc(w.xyz, ... ) );\n    // Where w is the output of this function\n    vec3 q = abs(p)-h;\n    return vec4( max(q,0.0), min(max(q.x,max(q.y,q.z)),0.0) );\n}\n\n// Repetitions\nvec3 RepeatRange( in vec3 p, in vec3 c, in vec3 l)\n{\n    p -= c * 0.5 * (1.0 - mod(l, 2.0));\n    return p - c * (clamp(round(p / c), ceil(-l * 0.5), ceil(l * 0.5) - vec3(1.0)));\n}\n\nvec3 RepeatInfinite(in vec3 p, in vec3 c)\n{\n    return mod(p + 0.5 * c, c) - 0.5 * c;\n}\n\nfloat Extrusion(vec3 p, float d, float h)\n{\n    vec2 w = vec2(d, abs(p.y) - h * 0.5);\n    return min(max(w.x, w.y), 0.0) + length(max(w, 0.0));\n}\n\n// 2D PRIMITIVES\nvec2 Circle(vec3 p, float r)\n{\n    return vec2(length(vec2(p.x, p.z)) - r, 0.0);\n}\n\nfloat Star5(in vec2 p, in float r, in float rf)\n{\n    const vec2 k1 = vec2(0.809016994375, -0.587785252292);\n    const vec2 k2 = vec2(-k1.x,k1.y);\n    p.x = abs(p.x);\n    p -= 2.0*max(dot(k1,p),0.0)*k1;\n    p -= 2.0*max(dot(k2,p),0.0)*k2;\n    p.x = abs(p.x);\n    p.y -= r;\n    vec2 ba = rf*vec2(-k1.y,k1.x) - vec2(0,1);\n    float h = clamp( dot(p,ba)/dot(ba,ba), 0.0, r );\n    return length(p-ba*h) * sign(p.y*ba.x-p.x*ba.y);\n}\n\n// 3D PRIMITIVES - Mostly adapted from https://iquilezles.org/articles/distfunctions\nvec2 SquareColumn(vec3 p, vec2 d)\n{\n    p = abs(p);\n    return vec2(max(p.x - d.x / 2.0, p.z - d.y / 2.0), 0.0);\n}\n\nvec2 Sphere(vec3 p, float r)\n{\n\treturn vec2(length(p) - r, 0.0);\n}\n\nvec2 Disk(vec3 p, float w, float r)\n{\n\treturn vec2(length(vec2(length(p.xz) - w, p.y)) - r, 0.0);\n}\n    \nvec2 CappedTorus(in vec3 p, in float angle, in float ra, in float rb)\n{\n    vec2 c = vec2(sin(angle),cos(angle));\n    \n    p.x = abs(p.x);\n    float k = (c.y * p.x > c.x * p.y) ? dot(p.xy, c) : length(p.xy);\n    return vec2(sqrt(dot(p, p) + ra * ra - 2.0 * ra * k) - rb, 0.0);\n}\n\nvec2 Capsule(vec3 p, float h, float r)\n{\n\tvec3 a = vec3(0.0, h * 0.5, 0.0);\n\tvec3 b = vec3(0.0, -h * 0.5, 0.0);\n\tvec3 ab = b - a;\n\tvec3 ap = p - a;\n\n\tfloat t = dot(ab, ap) / dot(ab, ab);\n\tt = clamp(t, 0.0, 1.0);\n\n\tvec3 c = a + t * ab;\n\treturn vec2(length(p - c) - r, 0.0);\n}\n\nvec2 Cylinder(vec3 p, float h, float r)\n{\n  vec2 d = abs(vec2(length(p.xz), p.y)) - vec2(r, h * 0.5);\n  return vec2(min(max(d.x, d.y), 0.0) + length(max(d, 0.0)), 0.0);\n}\n\nvec2 Tube(vec3 p, float h, float r, float t)\n{\n    float dHoop = abs(Circle(p, r).x) - t;\n    return vec2(Extrusion(p, dHoop, h), 0.0);\n}\n\nvec2 Torus(vec3 p, float w, float r)\n{\n\treturn vec2(length(vec2(length(p.xz) - w, p.y)) - r, 0.0);\n}\n\nvec2 CappedTorus(vec3 p, vec2 sc, float ra, float rb)\n{\n  p.x = abs(p.x);\n  float k = (sc.y * p.x > sc.x * p.y) ? dot(p.xy, sc) : length(p.xy);\n  return vec2(sqrt( dot(p, p) + ra * ra - 2.0 * ra * k) - rb, 0.0);\n}\n\nvec2 Link(vec3 p, float le, float r1, float r2)\n{   \n    vec4 w = Elongate(p, FORWARD * le / 2.0);\n    return w.w + Torus(w.xyz, r1, r2);\n}\n\nvec2 HollowCylinder(vec3 p, float h, float r, float t)\n{\n    float c1 = Cylinder(p, h, r).x;\n    float c2 = Cylinder(p, h, r - t).x;\n    \n    return vec2(Difference(vec2(c1, 0.0), vec2(c2, 0.0)).x, 0.0);\n}\n\nvec2 Gyroid(vec3 p, vec3 repetition, float width, vec2 bias)\n{\n    p *= repetition;\n    float avgRepetition = AvgComponentLength(repetition);\n    return vec2(abs(dot(sin(p * bias.x), cos(p.zxy * bias.y))) / avgRepetition - width, 0.0);\n}\n\nvec2 Box(vec3 p, vec3 dimensions)\n{\n\treturn vec2(length(max(abs(p) - (0.5 * dimensions), 0.0)), 0.0);\n}\n\nvec2 BoxFrame(vec3 p, vec3 b, float e)\n{\n  p = abs(p)-b;\n  vec3 q = abs(p+e)-e;\n  float minimum = min(min(\n      length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n      length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n      length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n      \n      return vec2(minimum, 0.0);\n}\n\nvec2 Plane(vec3 p)\n{\n    return vec2(abs(p.y), 0.0);\n}\n\nvec2 InfiniteCone(vec3 p, float angle)\n{\n    vec2 c = vec2(sin(angle), cos(angle));\n    vec2 q = vec2(length(p.xz), -p.y);\n    float d = length(q - c * max(dot(q, c), 0.0));\n    return vec2(d * ((q.x * c.y - q.y * c.x < 0.0) ? -1.0 : 1.0), 0.0);\n}\n\nvec2 CappedInfiniteCone(vec3 p, float angle, float depth)\n{\n    float iCone = InfiniteCone(p - UP * depth, angle).x;\n    return CapY(p - DOWN * depth, vec2(iCone, 0.0), depth);\n}\n\nvec2 Cone(vec3 p, float angle, float height)\n{\n    p -= UP * height;\n    float iCone = InfiniteCone(p, angle).x;\n    return CapY(FlipY(p), vec2(iCone, 0.0), height);\n}\n\nvec2 CappedCone(vec3 p, float h, float r1, float r2)\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    vec2 k1 = vec2(r2,h);\n    vec2 k2 = vec2(r2-r1,2.0*h);\n    vec2 ca = vec2(q.x-min(q.x,(q.y<0.0)?r1:r2), abs(q.y)-h);\n    vec2 cb = q - k1 + k2*clamp( dot(k1-q,k2)/dot(k2,k2), 0.0, 1.0 );\n    float s = (cb.x<0.0 && ca.y<0.0) ? -1.0 : 1.0;\n    return vec2(s*sqrt( min(dot(ca,ca),dot(cb,cb)) ), 0.0);\n}\n\n// Slicing\nfloat SliceXZ(vec3 p, float d)\n{\n    return max(abs(p.y), d);\n}\n\nfloat SliceXY(vec3 p, float d)\n{\n    return max(abs(p.z), d);\n}\n\nfloat SliceYZ(vec3 p, float d)\n{\n    return max(abs(p.x), d);\n}\n\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//////////////////\n// INPUT SHADER //\n//////////////////\n\n//\n#define INIT_CAM_POS vec3(0.0, 15.0, -20.0)\n#define INIT_CAM_YAW 0.0\n#define INIT_CAM_PITCH -PI/4.5\n#define INIT_CAM_ROLL 0.0\n\n// SPEEDS\n#define ROTATION_SPEED 8.0\n#define BASE_MOVE_SPEED 10.0\n#define MOVE_ACCELERATION 1.01\n\n// UPDATE AND RECORD INPUT\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    fragColor = vec4(0.0,0.0,0.0,1.0);\n    \n    if (int(fragCoord.y) == 0 )\n    {\n        if (int(fragCoord.x) <= 1)\n        {\n            // CAMERA CONTROLS\n            vec4 camPos = texture(iChannel0, vec2(0.5, 0.5) / iResolution.xy, -100.0);\n            vec4 camRot = texture(iChannel0, vec2(1.5, 0.5) / iResolution.xy, -100.0);\n            vec2 mousePosData = texture(iChannel0, vec2(3.5, 0.5) / iResolution.xy, -100.0).xy;\n            \n            float yawAngle = camRot.x - ROTATION_SPEED * mousePosData.x / iResolution.x;\n            float pitchAngle = clamp(camRot.y + ROTATION_SPEED * mousePosData.y / iResolution.y, -PI / 2.0, PI / 2.0);\n            float rollAngle = camRot.z;\n\n            //if (ReadKey(iChannel1, KEY_Q, false))\n            //{\n            //    rollAngle -= ROTATION_SPEED * iTimeDelta;\n            //}\n\n            //if (ReadKey(iChannel1, KEY_E, false))\n            //{\n            //    rollAngle += ROTATION_SPEED * iTimeDelta;\n            //}\n            \n            if (camRot.w == 0.0)\n            {\n                // ADD INIT ANGLES\n                yawAngle += INIT_CAM_YAW;\n                pitchAngle += INIT_CAM_PITCH;\n                rollAngle += INIT_CAM_ROLL;\n            }\n            \n            if (ReadKey(iChannel1, KEY_F, false))\n            {\n                rollAngle = 0.0;\n            }\n            \n            if (int(fragCoord.x) == 0)\n            {\n                // CAMERA POSITION\n                vec3 moveDir = vec3(0.0);\n                \n                mat3x3 yawMat = Rotate3(yawAngle, UP);\n                mat3x3 pitchMat = Rotate3(pitchAngle, RIGHT);\n                mat3x3 rollMat = Rotate3(rollAngle, FORWARD);\n                mat3x3 rotMat = yawMat * pitchMat * rollMat;\n                \n                float moveSpeed = camPos.w;\n                \n                if (camRot.w == 0.0)\n                {\n                    // SET INIT MOVE SPEED\n                    moveSpeed = BASE_MOVE_SPEED;\n                }\n                \n                // ACCELERATE/DECELERATE\n                if (ReadKey(iChannel1, KEY_UP, false))\n                {\n                    moveSpeed *= MOVE_ACCELERATION;\n                }\n                if (ReadKey(iChannel1, KEY_DOWN, false))\n                {\n                    moveSpeed /= MOVE_ACCELERATION;\n                }\n                \n                // MOVEMENT\n                if (ReadKey(iChannel1, KEY_W, false))\n                {\n                    moveDir += rotMat * FORWARD;\n                }\n                if (ReadKey(iChannel1, KEY_S, false))\n                {\n                    moveDir += rotMat * BACKWARD;;\n                }\n                if (ReadKey(iChannel1, KEY_A, false))\n                {\n                    moveDir += rotMat * LEFT;\n                }\n                if (ReadKey(iChannel1, KEY_D, false))\n                {\n                    moveDir += rotMat * RIGHT;\n                }\n                if (ReadKey(iChannel1, KEY_SPACE, false))\n                {\n                    moveDir += rotMat * UP;\n                }\n                if (ReadKey(iChannel1, KEY_SHIFT, false))\n                {\n                    moveDir += rotMat * DOWN;\n                }            \n\n                vec3 movement = vec3(0.0);\n                if (length(moveDir) > 0.0)\n                {\n                    movement = normalize(moveDir) * iTimeDelta * moveSpeed;\n                }\n\n                if (camRot.w == 0.0)\n                {\n                    // ADD INIT POSITION\n                    movement += INIT_CAM_POS;\n                }\n                \n                fragColor = vec4(camPos.xyz + movement, moveSpeed);\n            }\n            else\n            {                \n                // CAMERA ROTATION\n                fragColor = vec4(yawAngle, pitchAngle, rollAngle, 1.0); // w value 1.0 means no longer first frame\n            }\n        }\n        else if (int(fragCoord.x) == 2)\n        {\n            // MOUSE CLICK\n            vec4 mouseClickData = texture(iChannel0, vec2(2.5, 0.5) / iResolution.xy, -100.0);            \n            fragColor = vec4(iMouse.z, mouseClickData.x, IsNewClick(mouseClickData.xy) || IsPersistentClick(mouseClickData.xy) ? iMouse.xy : vec2(0.0));\n        }\n        else if (int(fragCoord.x) == 3)\n        {\n            // MOUSE MOVEMENT\n            vec4 mouseClickData = texture(iChannel0, vec2(2.5, 0.5) / iResolution.xy, -100.0);\n            vec4 mousePosData = texture(iChannel0, vec2(3.5, 0.5) / iResolution.xy, -100.0);\n            vec2 mouseDelta = IsPersistentClick(mouseClickData.zw) ? iMouse.xy - mouseClickData.zw : vec2(0.0);\n            vec2 mouseCumulative = mousePosData.zw + mouseDelta;\n            fragColor = vec4(mouseDelta, mouseCumulative);\n        }\n    }\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[{"id":"XsXGR8","channel":0}],"code":"////////////////////////\n// CAN TEXTURE SHADER //\n////////////////////////\n\n#define FONT_WEIGHT 10.0\n#define LINE_WIDTH 1.0\n\n// https://iquilezles.org/articles/distfunctions2d\nfloat Bezier( in vec2 pos, in vec2 A, in vec2 B, in vec2 C )\n{    \n    vec2 a = B - A;\n    vec2 b = A - 2.0 * B + C;\n    vec2 c = a * 2.0;\n    vec2 d = A - pos;\n    float kk = 1.0 / dot(b, b);\n    float kx = kk * dot(a, b);\n    float ky = kk * (2.0 * dot(a, a) + dot(d, b)) / 3.0;\n    float kz = kk * dot(d, a);      \n    float res = 0.0;\n    float p = ky - kx * kx;\n    float p3 = p * p * p;\n    float q = kx*(2.0 * kx  *kx-3.0 * ky) + kz;\n    float h = q * q + 4.0 * p3;\n    if( h >= 0.0) \n    { \n        h = sqrt(h);\n        vec2 x = (vec2(h, -h) - q) / 2.0;\n        vec2 uv = sign(x) * pow(abs(x), vec2(1.0 / 3.0));\n        float t = clamp(uv.x + uv.y - kx, 0.0, 1.0);\n        vec2 v = d + (c + b * t) * t;\n        res = dot(v, v);\n    }\n    else\n    {\n        float z = sqrt(-p);\n        float v = acos(q / (p * z * 2.0)) / 3.0;\n        float m = cos(v);\n        float n = sin(v) * 1.732050808;\n        vec3  t = clamp(vec3(m + m, -n - m, n - m) * z - kx, 0.0, 1.0);\n        vec2 v1 = d + (c + b * t.x) * t.x;\n        vec2 v2 = d + (c + b * t.y) * t.y;\n        res = min( dot(v1, v1),\n                   dot(v2, v2));\n    }\n    return sqrt( res );\n}\n\nfloat Box( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p) - b;\n    return length(max(d, 0.0)) + min(max(d.x, d.y), 0.0);\n}\n\nfloat TUpper(vec2 p);\n\nfloat ALower(vec2 p)\n{\n    float dBounds = Box(p - vec2(0.09, 0.08), vec2(0.14, 0.12));\n    if (dBounds > 0.0) return 2.0;\n    \n    float d1 = Bezier(p, vec2(0.108, 0.115), vec2(0.113, 0.145), vec2(0.08, 0.14));\n    float d2 = Bezier(p, vec2(0.08, 0.14), vec2(0.07, 0.14), vec2(0.05, 0.125));\n    float d3 = Bezier(p, vec2(0.05, 0.125), vec2(0.0, 0.075), vec2(0.01, 0.035));\n    float d4 = Bezier(p, vec2(0.01, 0.035), vec2(0.02, 0.0), vec2(0.05, 0.015));\n    float d5 = Bezier(p, vec2(0.05, 0.015), vec2(0.08, 0.025), vec2(0.1, 0.085));\n    float d6 = Bezier(p, vec2(0.1, 0.085), vec2(0.075, 0.015), vec2(0.11, 0.011));\n    float d7 = Bezier(p, vec2(0.11, 0.011), vec2(0.15, 0.025), vec2(0.175, 0.1));\n    \n    float d = min(d1, d2);\n    d = min(d, d3);\n    d = min(d, d4);\n    d = min(d, d5);\n    d = min(d, d6);\n    d = min(d, d7);\n        \n    return d;\n}\n\nfloat ELower(vec2 p)\n{\n    float dBounds = Box(p - vec2(0.08, 0.08), vec2(0.12, 0.12));\n    if (dBounds > 0.0) return 2.0;\n    \n    float d1 = Bezier(p, vec2(0.021, 0.1), vec2(0.1, 0.1), vec2(0.105, 0.14));\n    float d2 = Bezier(p, vec2(0.105, 0.14), vec2(0.1, 0.16), vec2(0.07, 0.15));\n    float d3 = Bezier(p, vec2(0.07, 0.15), vec2(0.0, 0.11), vec2(0.012, 0.04));\n    float d4 = Bezier(p, vec2(0.012, 0.04), vec2(0.04, -0.015), vec2(0.1, 0.03));\n    float d5 = Bezier(p, vec2(0.1, 0.03), vec2(0.125, 0.05), vec2(0.15, 0.095));\n    \n    float d = min(d1, d2);\n    d = min(d, d3);\n    d = min(d, d4);\n    d = min(d, d5);\n    \n    return d;\n}\n\nfloat FUpper(vec2 p)\n{\n    float dBounds = Box(p - vec2(0.16, 0.14), vec2(0.22, 0.18));\n    if (dBounds > 0.0) return 2.0;\n\n    // Top\n    float dFTUpper = TUpper(p);\n    \n    // Cross\n    float dFUpperCross1 = Bezier(p, vec2(0.1, 0.12), vec2(0.11, 0.14), vec2(0.13, 0.125));\n    float dFUpperCross2 = Bezier(p, vec2(0.13, 0.125), vec2(0.17, 0.1), vec2(0.18, 0.13));\n    \n    float dFUpperCross = min(dFUpperCross1, dFUpperCross2);\n    \n    float d = min(dFTUpper, dFUpperCross);\n    \n    return d;\n}\n\nfloat HLower(vec2 p)\n{\n    float dBounds = Box(p - vec2(0.1, 0.14), vec2(0.14, 0.18));\n    if (dBounds > 0.0) return 2.0;\n    \n    float d1 = Bezier(p, vec2(0.095, 0.265), vec2(0.0525, 0.138), vec2(0.01, 0.01));\n    float d2 = Bezier(p, vec2(0.01, 0.01), vec2(0.06, 0.14), vec2(0.12, 0.155));\n    float d3 = Bezier(p, vec2(0.12, 0.155), vec2(0.15, 0.16), vec2(0.135, 0.12));\n    float d4 = Bezier(p, vec2(0.135, 0.12), vec2(0.08, 0.0), vec2(0.12, 0.01));\n    float d5 = Bezier(p, vec2(0.12, 0.01), vec2(0.155, 0.015), vec2(0.2, 0.1));\n    \n    float d = min(d1, d2);\n    d = min(d, d3);\n    d = min(d, d4);\n    d = min(d, d5);\n    \n    return d;\n}\n\nfloat RLower(vec2 p)\n{\n    float dBounds = Box(p - vec2(0.09, 0.09), vec2(0.13, 0.12));\n    if (dBounds > 0.0) return 2.0;\n    \n    float d1 = Bezier(p, vec2(0.02, 0.095), vec2(0.04, 0.13), vec2(0.03, 0.15));\n    float d2 = Bezier(p, vec2(0.03, 0.15), vec2(0.024, 0.18), vec2(0.01, 0.15));\n    float d3 = Bezier(p, vec2(0.01, 0.15), vec2(0.0, 0.135), vec2(0.075, 0.135));\n    float d4 = Bezier(p, vec2(0.075, 0.135), vec2(0.1, 0.135), vec2(0.12, 0.15));\n    float d5 = Bezier(p, vec2(0.12, 0.15), vec2(0.05, 0.01), vec2(0.1, 0.01));\n    float d6 = Bezier(p, vec2(0.1, 0.01), vec2(0.13, 0.02), vec2(0.17, 0.08));\n    \n    float d = min(d1, d2);\n    d = min(d, d3);\n    d = min(d, d4);\n    d = min(d, d5);\n    d = min(d, d6);\n    \n    return d;\n}\n\nfloat SLower(vec2 p)\n{\n    float dBounds = Box(p - vec2(0.07, 0.08), vec2(0.11, 0.12));\n    if (dBounds > 0.0) return 2.0;\n    \n    float d1 = Bezier(p, vec2(0.015, 0.1), vec2(-0.01, 0.015), vec2(0.05, 0.01));\n    float d2 = Bezier(p, vec2(0.05, 0.01), vec2(0.1, 0.01), vec2(0.12, 0.045));\n    float d3 = Bezier(p, vec2(0.12, 0.045), vec2(0.13, 0.075), vec2(0.09, 0.09));\n    float d4 = Bezier(p, vec2(0.09, 0.09), vec2(0.06, 0.105), vec2(0.07, 0.125));\n    float d5 = Bezier(p, vec2(0.07, 0.125), vec2(0.075, 0.14), vec2(0.09, 0.15));\n    float d6 = Bezier(p, vec2(0.09, 0.15), vec2(0.125, 0.16), vec2(0.12, 0.125));\n\n    float d = min(d1, d2);\n    d = min(d, d3);\n    d = min(d, d4);\n    d = min(d, d5);\n    d = min(d, d6);\n\n    return d;\n}\n\nfloat TUpper(vec2 p)\n{\n    float dBounds = Box(p - vec2(0.17, 0.14), vec2(0.22, 0.18));\n    if (dBounds > 0.0) return 2.0;\n    \n    // Top\n    float dT1 = Bezier(p, vec2(0.075, 0.155), vec2(0.05, 0.215), vec2(0.1, 0.245));\n    float dT2 = Bezier(p, vec2(0.1, 0.245), vec2(0.13, 0.265), vec2(0.27, 0.23));\n    float dT3 = Bezier(p, vec2(0.27, 0.23), vec2(0.32, 0.225), vec2(0.33, 0.265));\n    \n    float dT = min(dT1, dT2);\n    dT = min(dT, dT3);\n    \n    // Bottom\n    float dB1 = Bezier(p, vec2(0.075, 0.06), vec2(0.085, 0.125), vec2(0.035, 0.1));\n    float dB2 = Bezier(p, vec2(0.035, 0.1), vec2(0.01, 0.08), vec2(0.01, 0.05));\n    float dB3 = Bezier(p, vec2(0.01, 0.05), vec2(0.015, 0.01), vec2(0.055, 0.01));\n    float dB4 = Bezier(p, vec2(0.055, 0.01), vec2(0.11, 0.01), vec2(0.125, 0.065));\n    float dB5 = Bezier(p, vec2(0.125, 0.065), vec2(0.155, 0.185), vec2(0.185, 0.2));\n    \n    float dB = min(dB1, dB2);\n    dB = min(dB, dB3);\n    dB = min(dB, dB4);\n    dB = min(dB, dB5);\n    \n    float d = min(dT, dB);\n    \n    return d;\n}\n\nfloat TLower(vec2 p)\n{\n    float dBounds = Box(p - vec2(0.14, 0.14), vec2(0.19, 0.18));\n    if (dBounds > 0.0) return 2.0;\n    \n    // TLower Bottom\n    float dB1 = Bezier(p, vec2(0.055, 0.255), vec2(-0.005, 0.015), vec2(0.04, 0.01));\n    float dB2 = Bezier(p, vec2(0.04, 0.01), vec2(0.075, 0.01), vec2(0.117, 0.1));\n    \n    float dB = min(dB1, dB2);\n    \n    // TLower Top\n    float dT1 = Bezier(p, vec2(0.005, 0.205), vec2(0.005, 0.235), vec2(0.04, 0.225));\n    float dT2 = Bezier(p, vec2(0.04, 0.225), vec2(0.15, 0.2), vec2(0.2, 0.195));\n    float dT3 = Bezier(p, vec2(0.2, 0.195), vec2(0.27, 0.185), vec2(0.27, 0.255));\n    \n    float dT = min(dT1, dT2);\n    dT = min(dT, dT3);\n    \n    float d = min(dB, dT);\n    \n    return d;\n}\n\nfloat YLower(vec2 p)\n{\n    float dBounds = Box(p - vec2(0.15, 0.02), vec2(0.2, 0.19));\n    if (dBounds > 0.0) return 2.0;\n    \n    float d1 = Bezier(p, vec2(0.06, 0.145), vec2(0.03, 0.0), vec2(0.08, 0.012));\n    float d2 = Bezier(p, vec2(0.08, 0.012), vec2(0.13, 0.025), vec2(0.15, 0.145));\n    float d3 = Bezier(p, vec2(0.15, 0.145), vec2(0.13, 0.025), vec2(0.08, -0.095));\n    float d4 = Bezier(p, vec2(0.08, -0.095), vec2(0.06, -0.145), vec2(0.02, -0.105));\n    float d5 = Bezier(p, vec2(0.02, -0.105), vec2(-0.01, -0.065), vec2(0.025, -0.045));\n    float d6 = Bezier(p, vec2(0.025, -0.045), vec2(0.06, -0.025), vec2(0.23, -0.09));\n    float d7 = Bezier(p, vec2(0.23, -0.09), vec2(0.31, -0.115), vec2(0.3, -0.04));\n    \n    float d = min(d1, d2);\n    d = min(d, d3);\n    d = min(d, d4);\n    d = min(d, d5);\n    d = min(d, d6);\n    d = min(d, d7);\n    \n    return d;\n}\n\nfloat Tasty(vec2 p, float r)\n{\n    float dBounds = Box(p - vec2(0.44, 0.074), vec2(0.455, 0.225));\n    if (dBounds > 0.0) return 2.0;\n    \n    float dT1 = TUpper(p - vec2(0.0, 0.0));\n    float dA = ALower(p - vec2(0.18, 0.0));\n    float dS = SLower(p - vec2(0.338, 0.0));\n    float dT2 = TLower(p - vec2(0.478, 0.0));\n    float dY = YLower(p - vec2(0.543, 0.0));\n    \n    float d = min(dT1, dA);\n    d = min(d, dS);\n    d = min(d, dT2);\n    d = min(d, dY);\n    \n    return d - r * 0.001;\n}\n\nfloat Fresh(vec2 p, float r)\n{\n    float dBounds = Box(p - vec2(0.44, 0.074), vec2(0.455, 0.22));\n    if (dBounds > 0.0) return 2.0;\n    \n    float dF = FUpper(p);\n    float dR = RLower(p - vec2(0.18, 0.0));\n    float dE = ELower(p - vec2(0.338, 0.0));\n    float dS = SLower(p - vec2(0.475, 0.0));\n    float dH = HLower(p - vec2(0.605, 0.0));\n    \n    float d = min(dF, dR);\n    d = min(d, dE);\n    d = min(d, dS);\n    d = min(d, dH);\n    \n    return d - r * 0.001 + 0.000;\n}\n\nfloat Stars(vec2 p)\n{\n    float dBigStar = abs(Star5(p, 0.15, 0.5)) - 0.01;\n    \n    p.x = abs(p.x);\n    vec2 pSmallStars = p - vec2(0.25, -0.06);\n    float dSmallStars = abs(Star5(pSmallStars, 0.1, 0.5)) - 0.01;\n\n    float dStars = min(dBigStar, dSmallStars);\n    \n    return dStars;\n}\n\nfloat Wave(vec2 p)\n{\n     return p.y - NSin((p.x - 0.1) * 2.0 * PI) * 0.25 - 0.375 + NCos(p.x * TAU * 8.0) * 0.2 - 0.1;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    float aspect = iResolution.x / iResolution.y;\n\n    vec3 col = vec3(1.0, 0.0, 0.0);\n   \n    \n    float outlineSize = LINE_WIDTH * 0.01;\n    float dWave = Wave(uv);\n    \n    if (dWave > 0.0) col = BLUE;\n    dWave = abs(dWave) - NSin(uv.x * TAU * 2.0 + PI) * 0.05;    \n    \n    uv.x *= aspect;\n    \n    vec2 pTasty = Rotate2(0.25) * (uv - vec2(1.2, 0.65)) / 0.6;\n    float dTasty = Tasty(pTasty, FONT_WEIGHT);\n        \n    vec2 pFresh = Rotate2(0.25) * (uv - vec2(0.125, 0.15)) / 0.6;\n    float dFresh = Fresh(pFresh, FONT_WEIGHT);\n    \n    vec2 pStars1 = (uv - vec2(0.3, 0.85)) / 0.6;\n    float dStars1 = Stars(pStars1);\n    \n    vec2 pStars2 = (uv - vec2(1.05, 0.15)) / 0.6;\n    float dStars2 = Stars(pStars2);\n    \n    float d = min(dTasty, dFresh);\n    d = min(d, dStars1);\n    d = min(d, dStars2);\n    d = min(d, dWave);\n    \n    col = mix(BLACK, col, smoothstep(outlineSize, outlineSize * 2.0, d));\n    col = mix(LIGHT_GREY, col, smoothstep(0.0, outlineSize, d));\n\n    fragColor = vec4(col,1.0);\n}","name":"Buffer B","description":"","type":"buffer"}]}