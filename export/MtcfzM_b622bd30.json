{"ver":"0.1","info":{"id":"MtcfzM","date":"1539005901","viewed":1525,"name":"yin-yang","username":"teraspora","description":".","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["yinyang"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.141592653588\n//#define f fragCoord.xy\n// Some useful colours:\nconst vec3 white =      vec3(1.,   1.,   1.  );\nconst vec3 crimson =      vec3(1.,   0.,   0.4  );\nconst vec3 yellow =      vec3(1.,   1.,   0.  );\nconst vec3 black =      vec3(0.,   0.,   0.  );\nconst vec3 orange = vec3(1.0, 0.4, 0.);\nconst vec3 cyan = vec3(0., 0.4, 1.0);\nconst vec3 magenta = vec3(1.0, 0., 1.0);\nconst vec3 gold = vec3(1.0, 0.84, 0.66);\n\nvec3[] cols = vec3[](white, crimson, yellow, magenta, gold, cyan, orange);\nvec3 col;\n\n// My inline library of useful functions:\n// =======================================\n\nfloat arg(vec2 z) {\n    return atan(z.y, z.x);\n}\n\nvec2 polar(float r, float phi) {\n    return vec2(r * cos(phi), r * sin(phi));\n}\n\nvec2 times(vec2 v, vec2 w) {\n    return vec2(v.x * w.x - v.y * w.y, v.x * w.y + v.y * w.x);\n}\n\nvec2 rotate(vec2 v, float phi) {\n    return times(v, polar(1.0, phi)) ;\n}\n\nfloat om(float x) {\n\treturn 1. - x;\n}\n\nvec3 om(vec3 v) {\n\treturn 1. - v;\n}\n\nfloat op(float x) {\n\treturn 1. + x;\n}\n\nfloat nsin(float x) {\n\treturn op(sin(x)) * 0.5;\n}\n\nfloat ncos(float x) {\n\treturn op(cos(x)) * 0.5;\n}\n\nfloat sqrtp(float x) {\n\treturn sqrt(x < 0. ? -x : x); \n}\n\nfloat nmmod(float x, float y) {\n\tfloat xmn = 2. * mod(x, y) / y;\n    return xmn < 1. ? xmn : om(xmn);\n}\n\nvec3 omss(float mn, float mx, vec3 val) {\n\treturn om(smoothstep(mn, mx, val));\n}\n\nvec2 nmouse() {\n\treturn iMouse.xy / iResolution.xy;\n}\n\nvec3 invert(vec3 col) {\n \treturn 1. - clamp(col, 0., 1.);   \n}\n\nbool isOdd(float p) {\n    return fract(p * 0.5) >= 0.5;\n}\n\n// =======================================\n\n// rand generator from \n// https://www.youtube.com/watch?v=l-07BXzNdPw&t=740s\nvec2 r22(vec2 p) {\n\tvec3 a = fract(p.xyx * vec3(123.34, 234.34, 345.65));\n\ta += dot(a, a + 34.45);\n    return fract(vec2(a.x * a.y, a.y * a.z));\n}\n\n\nfloat f(float x) {\n\treturn sin(cos(0.2 * iTime * x)) + cos(2. * sin(0.23 * iTime * x)) - sqrt(0.2 *abs(x) * cos(0.02 * iTime * x));\n}\n\nvec3 drawBorder(vec3 col, float b, vec3 insetColour, vec2 pp, vec2 hr, float tileIndex) {\n    // `b` is the border width\n    // `col` is the input (and output) colour\n    // `pp` is (unnormalised) coordinate of pixel\n    // `hr` is (unnormalised) resolution\n    // Make a border: `b` px solid black; with `insetColour` inset:\n    if (tileIndex != -1.) {\n    \t//  any special code for single-pane use goes here    \n    }\n    // Make a line inset:\n    if ((pp.x > b - 1. && pp.x <= b + 1.) || (pp.x > hr.x - b - 1. && pp.x < hr.x - b + 1.)) col = insetColour;\n    if ((pp.y > b - 1. && pp.y <= b + 1.) || (pp.y > hr.y - b - 1. && pp.y < hr.y - b + 1.)) col = insetColour;\n    \n    // Now put a black border on top:\n    col *= step(b, pp.x);\n    col *= step(b, pp.y);\n    col *= (1. - step(hr.x - b, pp.x));\n    col *= (1. - step(hr.y - b, pp.y));\n    return col;\n    \n    }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    float t = 24. - iTime / 24.;\n    float scale = 0.6 * sin(t / 2.);\n\tfloat asp = iResolution.x/iResolution.y;\n    // Normalized pixel coordinates (y from 0 to 1)\n    vec2 uv = (fragCoord/iResolution.y - vec2(0.5 * asp, 0.5)) / scale;\n\t//uv.y = abs(uv.y);\n    if (nmouse().x >= 0.5) uv = abs(uv);\n    \n    uv += 0.5 * cos(t / 12.) * vec2(cos(uv.x * t), sin(uv.y * t));\n    uv.x += 8. * nsin(t / 10.) * ncos(t / 10.) * sin(uv.y);\n    uv.y += .04 * ncos(uv.x * t / 3.) * ncos(t / 7.) * sin(44. * uv.y);\n    \n    \n    \n    col = vec3(sin(3. * sin(t) * length(uv) * 40.) + sin(t * 6.  + uv.x * 20.));\n    col.b *= length(uv);\n    col.r *= nsin(abs(length(uv* 1000.) + uv.x));\n    col.g = ncos(13. * sin(6. *t) * length(uv) * 50.) + cos(t * 0.125  + (uv.x + uv.y * 0.02 * nsin(t)));\n    \n    \n    \n    \n    \n    \n    // Border code:    \n    // ============    \n    float borderWidth = 6.;\n    vec3 borderInsetLineColour = orange;\n \tcol = drawBorder(col, borderWidth, borderInsetLineColour, fragCoord, iResolution.xy, -1.);\n    \n    // Output to screen\n    fragColor = vec4(col.gbr, 1.);\n}","name":"Image","description":"","type":"image"}]}