{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"//all visualization code is from Gleurop. I just did the ellipse DE functions :)\n//Added IQ's function\n/*\n\nSimply click somewhere outside the object and drag your mouse\ntowards (what should be) the nearest surface. The indicator\nwill tell you how correct the distance field is by marching a\nray from your original click position to the new position.\n\nThe green circles are the raymarching steps.\n\nThe bar at the bottom displays the number of raymarching steps taken.\n\nField colors:\nWhite: Positive distance\nGreen: Negative distance\nPink: Zero distance (surface)\n\nDot colors:\nBlue: Ray origin\nRed: Ray target\nWhite: Intersection\n\nIndicator colors:\nGreen: Distance is accurate.\nYellow: Distance is too small (this is okay, just means multiple steps are needed).\nRed: Distance is too big (this is bad).\nBlue: No object was hit.\n\nKnown issues:\nIt sometimes steps over objects and without turning the indicator\nred if the field is very inaccurate\n\n*/\n\nconst float ACCURATE_DIST = 0.01;\nconst int NUM_MARCH_ITER = 50;\n\n//IQ's analytic solution//////////////////////////////////////////////////////////////////\nfloat distanceToEllipse( in vec2 p, in vec2 ax )\n{\n\tif(p.x>p.y){p=p.yx; ax=ax.yx;}// in order to avoid the errorneous output near the x axis\n\t\n\tfloat k = ax.y*ax.y - ax.x*ax.x;\n\t\n    vec2  a = ax*p/k; vec2 a2 = a*a;\n\t\n    float c = (dot(a,a) - 1.0)/3.0; float c3 = c*c*c;\n\n    float q = c3 + a2.y*a2.x*2.0;\n    float d = c3 + a2.y*a2.x;\n    float g = a.x + a.x*a2.y;\n\n    float co;\n\n    if( d<0.0 )\n    {\n        float p = acos(q/c3)/3.0;\n        float m = cos(p);\n        float n = sin(p)*sqrt(3.0);\n        float rx = sqrt( -c*(m + n + 2.0) + a2.x );\n        float ry = sqrt( -c*(m - n + 2.0) + a2.x );\n        co = ( ry + sign(k)*rx + abs(g)/(rx*ry) - a.x)/2.0;\n    }\n    else\n    {\n        float h = 2.0*a.x*a.y*sqrt( d );\n        float s = sign(q+h)*pow( abs(q+h), 1.0/3.0 );\n        float u = sign(q-h)*pow( abs(q-h), 1.0/3.0 );\n        float rx = -s - u - c*4.0 + 2.0*a2.x;\n        float ry = (s - u)*sqrt(3.0);\n        float rm = sqrt( rx*rx + ry*ry );\n        float p = ry/sqrt(rm-rx);\n        co = (p + 2.0*g/rm - a.x)/2.0;\n    }\n\n    float si = sqrt( 1.0 - co*co );\n \n    vec2 closestPoint = vec2( ax.x*co, ax.y*si );\n\t\n    return length(closestPoint - p ) * sign(p.y-closestPoint.y);\n}\n//\n//ellipse DE code begin//////////////////////////////////////////////////////////////////////\nvec2 foo(vec2 p,vec2 p0,float a,float b){\n\treturn vec2((p.x-p0.x)*b*p.y-(p.y-p0.y)*a*p.x,a*p.x*p.x+b*p.y*p.y-1.);\n}\n\nfloat jfoo(vec2 p,vec2 p0,out mat2 jp,float a,float b){//jacobian of foo()\n   jp[0][0]= 2.*b*p.y; jp[1][0]=a*p.x-b*(p.x-p0.x);\n   jp[0][1]=-2.*a*p.x; jp[1][1]=b*p.y-a*(p.y-p0.y);\n   return jp[0][0]*jp[1][1]-jp[1][0]*jp[0][1];\n}\n\nvec2 pseudonearest(vec2 p,float a,float b){//IIRC it's based on elliptic coordinates\n\ta=1./a; b=1./b;\n\tfloat d=(a+b-dot(p,p));\n\td=d*d;\n\tvec2 p2=p*p;\n\td-=4.*(a*b-dot(p2,vec2(b,a)));\n\td=sqrt(d);\n\tfloat m=0.5*(dot(p,p)-a-b-d);\n\treturn sqrt(abs(vec2(a*(a+m),b*(b+m))/(a-b)));\n}\n\nfloat ellipse(vec2 p0,float a, float b){\n\tp0=abs(p0);\n\tvec2 p=p0, dp=vec2(1.,1.), fp=vec2(1.,1.);\n\tmat2 jp;\n\t//initial estimate\n\tp=pseudonearest(p,a,b);\n\t//newton iterations\n\tfor(int i=0;i<5;i++){//0 iteration already gives very good DE\n\t\tfp=foo(p,p0,a,b);//evaluate function\n\t\t//if(abs(fp[0])+abs(fp[1])<0.001) break;//close enought?\n\t\tfloat det=jfoo(p,p0,jp,a,b);//get inverse jacobian\n\t\tdet=1./det;\n\t\t//get delta\n\t\tdp=det*jp*fp;\n\t\tp-=dp;//next estimate\n\t}\n\tfloat inside=sign(p0.x*p0.x*a+p0.y*p0.y*b-1.);\n\treturn inside*length(p0-p);\n}\n\nfloat ellipse0(vec2 p, float a2, float b2){//same as ellipse() but without newton iter.\n\tp=abs(p);\n\tvec2 pn=pseudonearest(p,a2,b2);\n\tfloat inside=sign(p.x*p.x*a2+p.y*p.y*b2-1.);\n\treturn inside*length(pn-p)*0.95;//the DE have to be slightly scaled down.\n}\n//Medial axis ellipse DE//////////////////////////////////////////////////////////////////////\nfloat ellipseDistMA(vec2 p, float a, float b){\n   //go to 1st quadrant. the distance field is symmetric about x and y axis.\n   float x=abs(p.x), y=abs(p.y);\n   \n   //we use them many times\n   float x2=x*x, y2=y*y, a2=a*a, b2=b*b;\n      \n   //find an approximation to t\n   float bb=a2+b2-x2-y2;\n   float cc=a2*b2-x2*b2-y2*a2;\n   float d=sqrt(bb*bb-4.*cc);\n   float t=0.5*(bb+d);//this is the \"hyperbolic\" part of the elliptic coordinates of (x,y)\n   x2=a2*(a2-t)/(a2-b2);//x coordinate squared of the approximated nearest point to (x,y)\n   t=sqrt(x2)*(1.-b2/a2);//t on medial axis corresponding to x2.\n   //t is the first approximation\n\t\n   //Refine by newton algorithm\n   //fx is the dot product of the vector (x,y)-(t,0) and the vector perpendicular to (x(t),y(t))-(t,0)\n   //x(t) = a^2 * t / ( a^2 - b^2 )\n   //y(t) is the point corresponding to x(t) on the ellipse: x(t)/aÂ²+y(t)/bÂ²=1\n\t\n\tfloat t2=t*t;\n   \tfloat fx=t2*y2*b2+(x-t)*(x-t)*(t2*a2-(a2-b2)*(a2-b2));\n   \n   \tfor(int i=0;i<4 /*&& abs(fx)>0.0000001*/; i++){\n      //derivative of fx\n      float dfx=2.*(t*(y2*b2+(x-t)*(x-t)*a2)-t2*(x-t)*a2+(x-t)*(a2-b2)*(a2-b2));\n      \n\t  t=t-fx/dfx;//update t\n      \n\t  t2=t*t;\n      fx=t2*y2*b2+(x-t)*(x-t)*(t2*a2-(a2-b2)*(a2-b2));\n   \t}\n   \n   float dx=sqrt(1.-t2/(a2-b2))*b;//distance from t to the ellipse. t is always on the medial axis of the ellipse.\n   return sqrt((x-t)*(x-t)+y2)-dx; //distance we are looking for\n}\n//ellipse DE code end//////////////////////////////////////////////////////////////////////\n\n// Put a distance function you want to test in here\nfloat map(vec2 p)\n{\n\treturn ellipseDistMA(p,1.,0.5); \n\t//return ellipse(p,1.,4.);\n\t//return ellipse0(p,1.,4.);\n\t//return distanceToEllipse( abs(p), sqrt(vec2(1.,4.).yx)*0.5  );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat aspect = iResolution.x / iResolution.y;\n\tvec2 indicator = vec2(aspect - 0.3, 0.7);\n\tvec2 uv = -1.0 + 2.0 * fragCoord.xy / iResolution.xy;\n\tuv.x *= aspect;\n\t//uv*=.125;\n\tvec4 m = -1.0 + 2.0 * iMouse / iResolution.xyxy;\n\tm.xz *= aspect;\n\t\n\t// Background color\n\tfloat d = map(uv);\n\tvec4 color = vec4(1, 1, 1, 1) * max(d, 0.0) + \n\t\t\t\t vec4(0, 1, 0, 1) * max(-d, 0.0);\n\tif (abs(d) < 0.005)\n\t\tcolor = vec4(1, 0, 1, 1);\n\n\t// March a ray from the click pos to the current pos\n\tif (m.z > -aspect) { // If mouse down\n\t\t// Mouse dots\n\t\tif (distance(m.xy, uv) < 0.02)\n\t\t\tcolor = vec4(1, 0, 0, 1);\n\t\tif (distance(m.zw, uv) < 0.02)\n\t\t\tcolor = vec4(0, 0, 1, 1);\n\t\n\t\tvec2 p = m.zw;\n\t\tvec2 rd = normalize(m.xy - m.zw);\n\t\tfloat md = 1.0;\n\t\tint ls = int(sign(map(p)));\n\t\tfloat steps = 0.0;\n\t\tfor (int i = 0; i < NUM_MARCH_ITER; i++) {\n\t\t\tif (md < ACCURATE_DIST) continue;\n\t\t\tmd = map(p);\n\t\t\t// The sign flipped, field is too big\n\t\t\tif (int(sign(md)) != ls && abs(md) > ACCURATE_DIST) {\n\t\t\t\tm.zw = vec2(1000.0);\n\t\t\t\tmd = 0.0;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tls = int(sign(md));\n\t\t\tmd = abs(md);\n\t\n\t\t\t// Display marching steps\n\t\t\tfloat sd = distance(p, uv);\n\t\t\tif (sd < md && sd > md-0.01)\n\t\t\t\tcolor = vec4(0, 1, 0, 1);\n\n\t\t\tp += md * rd;\n\t\t\tsteps++;\n\t\t}\n\t\tfloat total = distance(p, m.zw);\n\t\tif (distance(p, uv) < 0.02)\n\t\t\tcolor = vec4(1);\n\t\n\t\t// Indicator\n\t\tif (distance(uv, indicator) < 0.1) {\n\t\t\tif (md < ACCURATE_DIST && \n\t\t\t\t\tdistance(p, m.zw) > 0.001) { // Fix for unsigned distance fields\n\t\t\t\tif (distance(abs(map(m.zw)), total) < ACCURATE_DIST)\n\t\t\t\t\tcolor = vec4(0, 1, 0, 1);\n\t\t\t\telse if (m.z > 999.0)\n\t\t\t\t\tcolor = vec4(1, 0, 0, 1);\n\t\t\t\telse if (abs(map(m.zw)) < total)\n\t\t\t\t\tcolor = vec4(1, 1, 0, 1);\n\t\t\t} else {\n\t\t\t\tcolor = vec4(0, 0, 1, 1);\n\t\t\t}\n\t\t} else if (distance(uv, indicator) < 0.15) {\n\t\t\tcolor = vec4(0);\n\t\t}\n\t\t\n\t\t// Num steps bar\n\t\tif (-uv.y > 0.95) {\n\t\t\tif (uv.x/aspect * 0.5 + 0.5 < steps/float(NUM_MARCH_ITER))\n\t\t\t\tcolor = vec4(1, 0, 0, 1);\n\t\t\telse\n\t\t\t\tcolor = vec4(1);\n\t\t}\n\t}\n\n\tfragColor = color;\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"4dl3Dl","date":"1381779749","viewed":596,"name":"Ellipse DE","username":"knighty","description":"Distance estimator for the ellipse. Based on an evaldraw script I have written last year. I forgot how I did it exactly :/","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["distance","ellipse"],"hasliked":0,"parentid":"","parentname":""}}