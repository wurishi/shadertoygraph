{"ver":"0.1","info":{"id":"cdKXWm","date":"1681207721","viewed":61,"name":"Nathan's terrain","username":"Nafffen","description":"terrain","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["terrain"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","previewfilepath":"/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//================================================\n//Perlin noise\n//================================================\nconst float PI=3.14159265;\nvec2 randDir(vec2 id,float time)\n{\n    id+=vec2(3,181);\n    float t=time+PI*2.*fract(sin(83.*id.x)*(id.y)*(414.-id.y*5.));\n    return vec2(cos(t),sin(t));\n}\n\nfloat pnoise(vec2 uv, float t)\n{\n    vec2 id=floor(uv);uv=fract(uv);\n    vec2 of=vec2(1,0);\n    float a=dot(uv-of.yy,randDir(id+of.yy,t)),\n          b=dot(uv-of.xy,randDir(id+of.xy,t)),\n          c=dot(uv-of.yx,randDir(id+of.yx,t)),\n          d=dot(uv-of.xx,randDir(id+of.xx,t));\n    uv=uv*uv*(vec2(3.)-2.*uv);//f'(0)=f'(1)=0\n    a=mix(a,b,uv.x),b=mix(c,d,uv.x);      \n    return mix(a,b,uv.y)/1.4+.5;\n}\nfloat fbm(vec2 uv, float t)\n{\n    float res=0.;\n    res+=pnoise(uv, t);\n    res+=pnoise(uv*2., t)*0.5;\n    res+=pnoise(uv*4., t)*0.25;\n    res+=pnoise(uv*8., t)*0.125;\n    return res;\n}\n\n\n//================================================\n//maths\n//================================================\n//Helpers for Coloring: Start\nstruct Surface {\n    float sd; // signed distance value\n    vec3 col_1; // color when y == y_min\n    vec3 col_2; // color when y == y_max\n    float y_min;\n    float y_max;\n};\n\nfloat opUnion( float d1, float d2 )\n{\n    return min(d1,d2);\n}\n\nSurface opUnionWithColor (Surface obj1, Surface obj2) {\n  if (obj2.sd < obj1.sd) return obj2; // The sd component of the struct holds the \"signed distance\" value\n  return obj1;\n}\n\n//================================================\n//object\n//================================================\n\nfloat sdBox( vec3 p, vec3 b)\n{\n  vec3 q = abs(p) - b;\n  float d = length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n  return d;\n}\n\n//================================================\n//scene\n//================================================\n\nSurface map(in vec3 pos)\n{\n\n    vec3 posMap = vec3(0.0,-6.0,-16.0);\n    pos = pos - posMap;\n    \n    //montagne\n    Surface box = \n        Surface(\n            sdBox (pos,vec3(16.,0.,24.0)),\n            vec3(0.), //colors here will be override\n            vec3(0.),\n            0.,\n            0.\n        );\n    float freq_noise = 0.25;\n    float amplitude = 2.f;\n    float noise = fbm(pos.xz*freq_noise, 0.)*amplitude;\n    Surface d2 = \n        Surface(\n            box.sd-noise,\n            vec3(0.,1.,0.),\n            vec3(1.,1.,0.),\n            -4.5,\n            -3.5\n        );\n    \n    //eau\n    pos = pos - vec3(0.,1.3,0.);\n    Surface box_water = \n        Surface(\n            sdBox (pos,vec3(16.,0.,24.0)),\n            vec3(0.), //colors here will be override\n            vec3(0.),\n            0.,\n            0.\n        );\n    float freq_noise_water = 0.25;\n    float amplitude_water = 0.5f;\n    float noise_water = fbm(pos.xz*freq_noise_water, iTime)*amplitude_water;\n    Surface d3 = \n        Surface(\n            box_water.sd-noise_water,\n            vec3(0.,0.,1.),\n            vec3(0.,1.,1.),\n            -4.7,\n            -4.\n        );\n    \n    return opUnionWithColor(d2, d3);\n}\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal( in vec3 pos )\n{\n    const float ep = 0.0001;\n    vec2 e = vec2(1.0,-1.0)*0.5773;\n    return normalize( e.xyy*(map(pos + e.xyy*ep).sd ) + \n\t\t\t\t\t  e.yyx*(map(pos + e.yyx*ep).sd ) + \n\t\t\t\t\t  e.yxy*(map(pos + e.yxy*ep).sd ) + \n\t\t\t\t\t  e.xxx*(map(pos + e.xxx*ep).sd ));\n}\n\n// https://iquilezles.org/articles/rmshadows\n//slightly adapted because of COLORING\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, float tmin, float tmax, const float k )\n{\n\tfloat res = 1.0;\n    float t = tmin;\n    for( int i=0; i<50; i++ )\n    {\n        Surface s = map( ro + rd*t );\n\t\tfloat h = s.sd;\n        res = min( res, k*h/t );\n        t += clamp( h, 0.02, 0.20 );\n        if( res<0.005 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    float time = iTime;\n    vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y; \n    //center of screen: (0,0)\n    //dimensions: +/- 0.5\n\n    vec3 tot = vec3(0.);\n    \n    vec3 camDir = vec3(0.,1.6,-6.);\n    vec3 camPos = vec3(0., 3., 10.);\n    vec3 sunPos = vec3(-1.0+cos(time)/10.,0.8+cos(time)/10.,-0.2+cos(time)/10.);\n\n    vec3 ro = camPos;\n    vec3 rd = normalize(vec3(p-camDir.xy,camDir.z));\n    \n    \n    \n    \n    \n    \n    //ray marching\n    Surface s;\n    \n    float min_dist = 6.0;\n    float max_dist = 50.0;\n    for( int i=0; i<128; i++ )\n    {\n        vec3 p = ro + min_dist*rd;\n        s = map(p);\n        if( abs(s.sd)<0.0001 || min_dist>max_dist ) break;\n        min_dist += s.sd;\n    }\n    \n    vec3 sky = vec3(0.42,0.62,1.1) - p.y*0.4;\n    vec3 col = sky;\n    \n    //exact intersection point: ro+min_dist*rd\n    \n    //light + color\n    if( min_dist<max_dist )\n    {\n        vec3 pos = ro + min_dist*rd;\n        vec3 nor = calcNormal(pos);\n        vec3 lig = normalize(sunPos);\n        float dif = clamp(dot(nor,lig),0.0,1.0);\n        float sha = calcSoftshadow( pos, lig, 0.001, 10., 16.0 );\n        float amb = 0.2 + 0.1*nor.y;\n        float y = (ro+min_dist*rd).y;\n        col = vec3(0.1,0.1,0.1)*amb + vec3(1.,1.,1.)*dif*sha*\n            //mix(s.col_1, s.col_2, clamp((y-s.y_min)/(s.y_max-s.y_min), 0., 1.));\n            mix(s.col_1, s.col_2, (y-s.y_min)/(s.y_max-s.y_min));\n    }\n    \n    //pour avoir moins de contraste\n    //= ombre moins noires\n    col = sqrt( col );\n    tot += col;\n    \n    fragColor = vec4( tot, 1.0 );\n    //fragColor = vec4( vec3(fbm(p.xy)), 1.0 );\n}","name":"Image","description":"","type":"image"}]}