{"ver":"0.1","info":{"id":"4tfBWX","date":"1513473350","viewed":173,"name":"Chaos Game: Sierpinsky Triangle","username":"dbrgn","description":"My first shader: Drawing (inefficiently) the Sierpinsky Triangle using the [url=https://en.wikipedia.org/wiki/Chaos_game]Chaos Game[/url] rules.\n\nInspired by [url=https://s.dbrgn.ch/JmYU]this Quora post[/url].","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["math","triangle","chaos","sierpinsky"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/**\n * Drawing Sierpinsky traingles using the Chaos Game.\n *\n * Inspired by: https://www.quora.com/What-are-some-mind-blowing-facts-that-sound-like-BS-but-are-actually-true/answer/David-Prifti-1\n *\n * Rules:\n *\n * - The three points of the triangle are points A, B and C\n * - Choose a random starting point\n * - For every iteration, randomly choose point A, B or C.\n *   Move half way from the last point to that point.\n */\n\n// Radius of points being drawn\nconst float RADIUS = 1.0;\n\n// Offset from image border\nconst float OFFSET = 10.0;\n\n// Seed for hash function\nconst vec2 SEED = vec2(0.5, 0.7);\n\n// Speed: Number of points per second\nconst float SPEED = 50.0;\n\n// Starting points\n#define A scale(vec2(0.5, 1.0))\n#define B scale(vec2(1.0, 0.0))\n#define C scale(vec2(0.0, 0.0))\n\n/**\n * Scale coordinates between 0.1 to the output image resolution, with the specified border offset.\n */\nvec2 scale(vec2 coords) {\n\treturn coords * (iResolution.xy - OFFSET * 2.0) + OFFSET;\n}\n\n/**\n * Return whether the `fragCoord` pair is within `RADIUS` of `point`.\n */\nbool isPixel(vec2 fragCoord, vec2 point) {\n\treturn distance(fragCoord, point) < RADIUS;\n}\n\n/**\n * Random function from http://shadertoy.wikia.com/wiki/Noise\n */\nvec2 rand(vec2 p) {\n    return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\n/**\n * Randomly choose a point A, B or C with 1/3 probability.\n */\nvec2 randABC(vec2 seed) {\n    vec2 r = rand(seed);\n    if (r.x < (1.0/3.0)) {\n        return A;\n    } else if (r.x < (1.0/3.0*2.0)) {\n    \treturn B;\n    } else {\n        return C;\n    }\n}\n\n/**\n * Return whether the `fragCoord` coordinate pair is a valid point in the\n * sequence of points derived from the `start` point.\n */\nbool validPoint(vec2 fragCoord, vec2 start) {\n    int iteration = int(iTime * SPEED); // Add 1 point per second\n    \n    if (isPixel(fragCoord, start)) {\n        return true;\n    }\n    \n    // We start at the starting point\n    vec2 currentPoint = start;\n    \n    // Increment every second\n    for (int i = 0; i < iteration; i++) {\n        // First, derive a different seed for each iteration.\n        vec2 seed = vec2(float(i) * 0.001, float(i) * 0.002 / 3.0);\n        vec2 targetPoint = randABC(seed);\n        currentPoint = currentPoint + ((targetPoint - currentPoint) / 2.0);\n        if (isPixel(fragCoord, currentPoint)) {\n        \treturn true;\n        }\n    }\n    \n    return false;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec4 red = vec4(1.0, 0.0, 0.0, 1.0);\n    vec4 white = vec4(1.0, 1.0, 1.0, 1.0);\n    vec4 black = vec4(0.0, 0.0, 0.0, 1.0);\n    vec4 color = vec4(fragCoord.xy / iResolution.xy * 1.4, 1.0, 1.0); // Nicer colors depending on XY coords\n\n    // Random starting point\n    vec2 R = scale(rand(SEED));\n        \n    // Determine whether this is a start point\n    bool isStartPoint =\n        isPixel(fragCoord, A) ||\n        isPixel(fragCoord, B) ||\n        isPixel(fragCoord, C);\n    \n    // Determine whether this is a valid point (depending on time)\n    bool isValidPoint =\n        validPoint(fragCoord, R);\n    \n    if (isStartPoint) {\n    \tfragColor = red;\n    } else if (isValidPoint) {\n        fragColor = color;\n    } else {\n        fragColor = black;\n    }\n}","name":"Image","description":"","type":"image"}]}