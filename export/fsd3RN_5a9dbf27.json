{"ver":"0.1","info":{"id":"fsd3RN","date":"1629279817","viewed":85,"name":"reptilian octaves","username":"xenn","description":"forked from \"shepard scale\" by fabrice neyret\nI always liked the aesthetic of the original shader\n\nI think the shepard scale is quite fascinating really. control the speed editing PLAY_SPEED by an order of magnitude factor\nOscillating play speed","likes":4,"published":1,"flags":32,"usePreview":0,"tags":["illusion"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//radial blur code from jeyko: https://www.shadertoy.com/view/WlKXRR :)\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord/iResolution.xy;\n\tvec2 uvn = (fragCoord - 0.5*iResolution.xy)/iResolution.xy;\n    float steps = 20.0;\n    float scale = 0.00 + pow(length(uv - 0.5)*1.2,3.)*0.4;\n    float chromAb = pow(length(uv - 0.5),1.4)*2.1;\n    vec2 offs = vec2(0);\n    vec4 radial = vec4(0);\n    for(float i = 0.; i < steps; i++){  \n        scale *= -1.02;\n        vec2 target = uv + offs;\n        offs -= normalize(uvn)*scale/steps;\n    \tradial.r += texture(iChannel0, target + chromAb*1./iResolution.xy).x;\n    \tradial.g += texture(iChannel0, target).y;\n    \tradial.b += texture(iChannel0, target - chromAb*1./iResolution.xy).z;\n        \n        radial.r += texture(iChannel1, target + chromAb*1./iResolution.xy).x;\n    \tradial.g += texture(iChannel1, target).y;\n    \tradial.b += texture(iChannel1, target - chromAb*1./iResolution.xy).z;\n    }\n    radial /= steps;  \n    fragColor = radial*1.;   \n    fragColor *= 1.;\n    fragColor *= fragColor * (fragColor * (radial.rgb,1.)),1.;\n    fragColor = mix(fragColor,smoothstep(0.,1.,fragColor), .2);  \n    fragColor = max(fragColor, 0.);\n  //  fragColor.xyz = pow(fragColor.xyz, vec3(3.,sin(iTime)*0.+1.,1.));\n    fragColor *= 1. - dot(uvn,uvn)*1.9;\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Fork of \"shepardscale\" by Carandiru. https://shadertoy.com/view/7dtGz8\n// 2021-08-18 09:40:39\n\n// forked from \"shepard scale\" by fabrice neyret\n\n\n// [ warp speed at ~139s @ default playspeed ]\n\n#define PLAY_SPEED 0.005 // better to use orders of magnitude to see differences.\n\n\n#define fma(a,b,c) (a*b+c)\nvec3 rotate( in vec3 p, in float angle )\n{\n\t#define c_ x\n\t#define s_ y\n\tvec2 cossin = vec2(cos(angle), sin(angle));\n\treturn( vec3(fma(p.x, cossin.c_, p.z * cossin.s_), p.y, fma(p.x, -cossin.s_, p.z * cossin.c_)) );\n\n\t#undef c_\n\t#undef s_\n}\n\n\nfloat fabriceScale(in vec2 uv, in float t0)\n{\n    float e = (1.-cos(6.283*uv.x))/2.;\n    float phase = 50.*uv.x-3.*(iTime - t0);\n    float v = pow((sin(phase)+1.)/2.,20.); \t\t\t\t\t// peaks\n    v *= step((-.45 + (1.0*cos(iTime / 2.0))),uv.y*3.)*smoothstep(e,e-.05,-.5+uv.y*2.); // enveloppe\n    \n    return(v);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float t = ((512.0f + (100.10 * (sin(iTime * 0.01)))) * (.00250 * abs(sin(iTime * (PLAY_SPEED * (.10*sin(iTime / 2560.0)))) + 17.0f)));\n    vec3 uvw = vec3(fragCoord.xy / iResolution.xy, 0.0f);\n        \n    float v = 0.0f;\n    \n    uvw = rotate(uvw * t*0.1f, t*0.5f);\n    \n    for (uvw.z = -32.0f; uvw.z <= 4.0f; ++uvw.z) {\n        \n        float z = uvw.z;\n        \n        vec2 n = z * vec2(0.05f * (1.0f + z*0.05f), 0.07f);\n        v += 0.75f * (.50f - v) * fabriceScale(uvw.xy + n, t * z * z);\n    \n    }\n\tfragColor = vec4(v);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"// Fork of \"Space Warfare V.3tqqt\" by julianlumia. https://shadertoy.com/view/tlSfzR\n// 2020-08-24 09:40:19\n\n// Fork of \"Space Warfare V.3\" by julianlumia. https://shadertoy.com/view/WlXfDl\n// 2020-08-23 13:57:55\n\n// Fork of \"Space Warfare\" by julianlumia. https://shadertoy.com/view/3lsfWf\n// 2020-08-21 10:23:12\n\n\n#define T(uv) texture(iChannel0,uv)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord/iResolution.xy);\n\n    \n    float f = length(uv  - 0.5);\n    fragColor.x = T(uv + f*0.005).x;\n    fragColor.y = T(uv -f*0.006).y;\n    fragColor.z = T(uv-f*0.03).z;\n}","name":"Buffer D","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// Dof code from: 42yeah, https://shadertoy.com/view/wsXBRf\n\n// Random hash function\nvec2 rand2d(vec2 uv) {\n    return fract(sin(vec2(\n        dot(uv, vec2(215.1616, 82.1225)),\n        dot(uv, vec2(12.345, 856.125))\n    )) * 41234.45) * 2.0 - 1.0;\n}\n\n// Calculate CoC: https://developer.download.nvidia.com/books/HTML/gpugems/gpugems_ch23.html\nfloat getCoC(float depth, float focalPlane) {\n    float focalLength = .01;\n    float aperture = min(.0010, focalPlane * focalPlane);\n    return abs(aperture * ((focalLength * (.10 * sin(iTime)))* (focalPlane - depth)) /\n        (depth * (focalPlane - focalLength)));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // Sample original texture data at uv\n    vec4 texData = texture(iChannel0, uv);\n    \n    // Get its depth\n    float depth = texData.w;\n    \n    // Focal plane at 3.9 (the camera is looking at the center from ~4.0)\n   // float focalPlane =sin(iTime)+0.7;\n    \n       float focalPlane =1.;\n\n    \n    // Calculate CoC, see above\n    float coc = getCoC(depth, focalPlane);\n    \n    // Sample count\n    const int taps = 64;\n    \n    // Golden ratio: https://www.youtube.com/watch?v=sj8Sg8qnjOg\n    float golden = 3.141592 * (3.0 - sqrt(5.0));\n    \n    // Color & total weight\n    vec3 color = vec3(0.0);\n    float tot = 0.01;\n    \n    for (int i = 0; i < taps; i++) {\n        // Radius slowly increases as i increases, all the way up to coc\n        float radius = coc * sqrt(float(i)) / sqrt(float(taps));\n        \n        // Golden ratio sample offset\n        float theta = float(i) * golden;\n        vec2 tapUV = uv + vec2(sin(theta), cos(theta)) * radius;\n        \n        // Sample the bit over there\n        vec4 tapped = texture(iChannel0, tapUV);\n        float tappedDepth = tapped.w;\n\n        if (tappedDepth > 0.0) {\n            // Use CoC over there as weight\n            float tappedCoC = getCoC(tappedDepth,focalPlane) ;\n            float weight = max(0.001, tappedCoC);\n            \n            // Contribute to final color\n            color += tapped.rgb * (weight );\n            // And final weight sum\n            tot += weight;\n        }\n    }\n    // And normalize the final color by final weight sum\n    color /= tot;\n    fragColor = vec4(color, 1.0);\n}\n","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"// Fork of \"Space Warfare V.3tqqt\" by julianlumia. https://shadertoy.com/view/tlSfzR\n// 2020-08-24 09:40:19\n\n// Fork of \"Space Warfare V.3\" by julianlumia. https://shadertoy.com/view/WlXfDl\n// 2020-08-23 13:57:55\n\n// Fork of \"Space Warfare\" by julianlumia. https://shadertoy.com/view/3lsfWf\n// 2020-08-21 10:23:12\n\n\n#define T(uv) texture(iChannel0,uv)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord/iResolution.xy);\n\n    \n    float f = length(uv  - 0.5);\n    fragColor.x = T(uv + f*0.005).x;\n    fragColor.y = T(uv -f*0.006).y;\n    fragColor.z = T(uv-f*0.03).z;\n}","name":"Buffer C","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define frakColor vec4(texture(iChannel1, uv))\n\n// your code here\n#define PI2 6.283185\n\n#define Res0 vec2(textureSize(iChannel0,0))\n#define Res1 vec2(textureSize(iChannel1,0))\n\nvec2 scuv(vec2 uv) {\n    float zoom=1.;\n    #ifdef SHADEROO\n    zoom=1.-iMouseData.z/1000.;\n    #endif\n    return (uv-.5)*1.2*zoom+.5; \n}\n\nvec2 uvSmooth(vec2 uv,vec2 res)\n{\n    // no interpolation\n    //return uv;\n    // sinus interpolation\n    //return uv+.8*sin(uv*res*PI2)/(res*PI2);\n    // iq's polynomial interpolation\n    vec2 f = fract(uv*res);\n    return (uv*res+.5-f+3.*f*f-2.0*f*f*f)/res;\n}\n\n#define PI 3.14159265359\n\nfloat sinNorm(float x)\n{\n    return sin(x)*0.5+0.5;\n}\n\nfloat line(in int lineWidth, in vec2 pos, in vec2 point, in vec3 iResolution) {\n    float normalizedLineRadius = (float(lineWidth) / iResolution.y) / 2.;\n    float edgeWidth = 1. / iResolution.y;\n    if(normalizedLineRadius<1./iResolution.x)\n        return 0.;\n\treturn smoothstep(pos.y-normalizedLineRadius,pos.y-edgeWidth,point.y-normalizedLineRadius+edgeWidth) * \n        (1.-smoothstep(pos.y+normalizedLineRadius-edgeWidth, pos.y+normalizedLineRadius+edgeWidth, point.y));\n}\n\nfloat smoothVal(in float x, in float max) {\n\treturn clamp(smoothstep(0.0,1.0,x/max)*(1.-smoothstep(0.0,1.0,x/max))*4.,0.,1.);\n}\n\n//f(x) = amplitude*sinNormalized(frequency*x-offsetX)+d\nfloat normSinFunct(in float amplitude, in float freq, in float offsetX, in float offsetY, in float x) {\n    return amplitude*sinNorm(freq*x-offsetX)+offsetY;\n}\n\nfloat rand(float seed) {\n    return fract(sin(dot(vec2(seed, seed / PI) ,vec2(12.9898,78.233))) * 43758.5453);   \n}\n\nvec3 rgb2hsv(vec3 c)\n{\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n    ","name":"Common","description":"","type":"common"}]}