{"ver":"0.1","info":{"id":"lllXWH","date":"1436542214","viewed":430,"name":"Cloud-free Twister","username":"Blueberry","description":"Partycoded contribution to the Solskogen 2015 Shadertoy compo.\n\nAdjust the AUDIO_ADJUST constant to compensate for audio delay and make the kickdrum match up with the twister pulses. This delay seems to be very different on different machines.\n","likes":9,"published":1,"flags":8,"usePreview":0,"tags":["twister"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[],"code":"\n#define DIST 40.0\n#define FAR 100.0\n#define M_PI 3.14159265358979\n#define M_2PI (2.0*3.14159265358979)\n#define SPEED 7.0\n#define STEPSIZE 0.6\n#define ITERATIONS 40\n\n// Texture lookup\nfloat tp(int u, int v) {\n    vec2 coord = (vec2(u,v) + 0.5) / iChannelResolution[0].xy;\n    return texture(iChannel0, coord).r;\n}\n\n// Manual bilinear interpolation to get around interpolation accuracy\nfloat itp(vec2 p) {\n\tivec2 c = ivec2(floor(p));\n    vec2 f = smoothstep(vec2(0),vec2(1),p-floor(p));\n    return mix(mix(tp(c.x,c.y),tp(c.x+1,c.y),f.x),mix(tp(c.x,c.y+1),tp(c.x+1,c.y+1),f.x),f.y);\n}\n\n// Defines twister shape\nfloat shape(float u, float v) {\n    return itp(vec2(u,v));\n}\n\n// Shading\nvec3 light(vec3 n, vec3 l, vec3 col) {\n\tl = normalize(l);\n\tvec3 h = normalize(mix(l, vec3(0,0,1), 0.5));\n    vec3 d = max(0.0, dot(n,l)) * col;\n    vec3 s = pow(max(0.0, dot(n,h)), 42.0) * col;\n    return d + s;\n}\n\n// Compute distance to twister\nfloat tv(float r, float s, float d, float c, float k) {\n\tvec2 p = vec2(DIST,0) - s * vec2(1,d);\n    float a = atan(p.y,p.x)*3.0 + r;\n\tfloat h = shape(c,a) * 10.0 + (sin(c*2.0)*5.0 + 5.0) * k;\n    return length(p) - h;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat time = iTime;\n    vec2 xy = (fragCoord.xy - iResolution.xy / 2.0) / iResolution.y;\n    \n    // Rotate display\n\tfloat gr = time*0.2 + sin(time)*0.5;\n\tvec2 xyr = mat2(cos(gr),sin(gr),-sin(gr),cos(gr)) * xy;\n\n    // Init twister parameters\n    float c = xyr.y*3.0 + time;\n    float d = xyr.x;\n    float dist0 = DIST;\n\tfloat depth = FAR;\n    float t = c + time*3.0;\n\tfloat r = t + sin(t*0.3)*10.0;\n\n    // Pulse to the beat\n\tfloat k = 1.0;\n    float kickspacing = 8.0/SPEED;\n\tfloat kickindex = floor(time / kickspacing);\n    float kicktime = time - kickindex * kickspacing;\n    if (fract(kickindex / 32.0) >= 0.5) {\n\t\tk = 1.0 + 0.5*sin(kicktime*SPEED*M_PI)*exp(-kicktime*3.0);\n    }\n\n    // Accelerate sure misses\n    float hmax = 10.0 + (sin(c*2.0)*5.0 + 5.0) * k;\n    float closest_s = DIST / (d*d+1.0);\n\tvec2 closest_p = vec2(DIST,0) - closest_s * vec2(1,d);\n\tfloat closest_dist = length(closest_p) - hmax;\n    \n    // Trace the twister\n    if (closest_dist <= 0.0) {\n        for (int it = 0 ; it < ITERATIONS ; it++) {\n            float s1 = DIST - hmax + float(it) * STEPSIZE;\n            float dist1 = tv(r, s1, d, c, k);\n            if (dist1 <= 0.0) {\n                float s0 = s1-STEPSIZE;\n                for (int i = 0 ; i < 8 ; i++) {\n                    float hs = (s0 + s1) * 0.5;\n                    float hdist = tv(r, hs, d, c, k);\n                    if (hdist > 0.0) {\n                        s0 = hs;\n                        dist0 = hdist;\n                    } else {\n                        s1 = hs;\n                        dist1 = hdist;\n                    }\n                }\n                depth = (s0 + s1) * 0.5;\n                break;\n            }\n            dist0 = dist1;\n        }\n    }\n\n   \t// Compute normal\n    vec3 pos = vec3(xy,depth*0.01);\n    vec3 n = normalize(cross(dFdx(pos),dFdy(pos)));\n\n    // Move light ball\n    float revtime = time*0.8;\n    vec3 ball = vec3(0.25*sin(revtime),0.05*sin(time*0.3),0.25*-cos(revtime));\n\tfloat bdist = DIST*0.01-ball.z;\n    vec2 ballpos = ball.xy / bdist;\n\tfloat b = 0.0003 / (bdist * dot(xyr - ballpos, xyr - ballpos));\n\n    vec3 color;\n    if (depth == FAR) {\n        // Background\n        color = (vec3(0,0.0,0.1) + floor(fract((c-xyr.x*xyr.x*xyr.y)*0.5)*2.0)*vec3(0.1,0.1,0.1)) * d*d*1.5;\n\t\tfloat f = 0.3 + 0.28*sin(time*1.3);\n\n        // Glow\n        vec3 glowcol = vec3(0.2,0.0,0.0) + f * vec3(0.3,0.7,0.7);\n        float ms = max(0.0, -sin(time*0.2));\n        float glow = exp(-closest_dist*0.2)*(0.7-0.3*sin(time*SPEED*M_PI))*ms;\n        color += glowcol*glow;\n\n        // Draw ball if behind\n        if (ball.z < 0.0) color = min(color,vec3(1)) * (1.0 - b) + b;\n    } else {\n\t\t// Twister\n        color = vec3(0);\n        color += light(n, vec3(1,-1,1), vec3(1.2,0.6,0.15));\n        color += light(n, vec3(-2,1,1), vec3(0,0.05,0.1));\n\t\tvec3 ballvec = ball-vec3(xyr,depth*0.01);\n        color += light(n, ballvec, vec3(0.5,0.7,0.9))*max(0.0,ball.z)*5.0;\n    }\n    color = min(color,vec3(1));\n\t\n    // Draw ball if in front\n    if (ball.z >= 0.0) color = mix(color, vec3(1), b);\n\n    fragColor = vec4(sqrt(color),1);\n}\n","name":"","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// Adjust this to make the kicks match the pulses\n#define AUDIO_ADJUST 0.1\n\n#define M_PI 3.14159265358979\n#define M_2PI (2.0*3.14159265358979)\n#define SPEED 7.0\n\n// Waveform used in melody: detuned sawtooth\nvec2 wave(float t) {\n\tvec2 w = vec2(0);\n    for (int l = 0; l < 5; l++) {\n\t\tvec2 t2 = t*(1.0 + 0.01*sin(float(l)*vec2(37,42)));\n\t\tw += fract(t2)-0.5;\n    }\n\treturn w;\n}\n\n// Play some notes\nvec2 melody(float time) {\n    float t = time*SPEED;\n\tint n = int(floor(t));\n    float freq = 100.0;\n    for (int i = 0 ; i < 5 ; i++) {\n        if (n / 2 * 2 != n) break;\n        freq *= pow(2.0, 1.0/3.0);\n        n = n / 2;\n    }\n    return vec2(wave(freq*time)*min(1.0,10.0*min(fract(t),1.0-fract(t))));\n}\n\n// ... with echo\nvec2 melody2(float time) {\n    return melody(time) + melody(time-0.4)*0.3;\n}\n\n// This is how a ball of light sounds\nvec2 tingle(float time) {\n\t// Compute light ball position\n    float revtime = time*0.8;\n    vec3 ball = vec3(0.25*sin(revtime),0.05*sin(time*0.3),0.25*-cos(revtime));\n\tfloat gr = time*0.2 + sin(time)*0.5;\n   \tvec2 xy = mat2(cos(gr),-sin(gr),sin(gr),cos(gr)) * ball.xy;\n\n    // Pan sound according to x position\n    float pan = xy.x*3.0;\n    vec2 panvec = vec2(sin(M_PI*0.25-pan),sin(M_PI*0.25+pan));\n\n    // Tingling sound, attenuated by distance\n    float w = sin(time*1600.0*M_2PI)*sin(time*SPEED*M_2PI) + sin(time*50.0*M_2PI);\n    return w*(0.08+0.3*ball.z)*panvec;\n}\n\n// Filter\nvec2 melody3(float time)\n{\n\tfloat f = 0.3 + 0.28*sin(time*1.3);\n    vec2 sum = vec2(0);\n\tfloat gsum = 0.0;\n    for (int i = -10 ; i <= 10 ; i++) {\n        float g = exp(-f*float(i*i));\n\t\tsum += melody2(time + float(i)*0.00005) * g;\n\t\tgsum += g;\n    }\n\treturn sum / sqrt(gsum) * 0.1;\n}\n\n// Drum\nvec2 kick(float time) {\n\treturn vec2(sin(60.0*exp(-time*20.0))*time*exp(-time*8.0)*20.0);\n}\n\nvec2 mainSound( in int samp,float time)\n{\n    time += AUDIO_ADJUST;\n    float ms = max(0.0, -sin(time*0.2));\n    vec2 sound = melody3(time)*ms + tingle(time);\n\n    float kickspacing = 8.0/SPEED;\n\tfloat kickindex = floor(time / kickspacing);\n    float kicktime = time - kickindex * kickspacing;\n    if (fract(kickindex / 32.0) >= 0.5) {\n\t\tsound += kick(kicktime) * 0.5;\n    }\n    return sound;\n}","name":"","description":"","type":"sound"}]}