{"ver":"0.1","info":{"id":"3tycRD","date":"1610548082","viewed":230,"name":"Infinity 1","username":"Leasel","description":"Uses complex numbers to calculate rotations(, and it also strongly resembles matrix multiplucations).","likes":1,"published":3,"flags":0,"usePreview":0,"tags":["complex","matrix"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void RotateL(inout vec2 point)\n{\n    point.y += BS + bL*BS;\n    point.x -= aL*BS - BS;\n    point = vec2(aL*point.x - bL*point.y, bL * point.x + aL*point.y + BS);\n}\n\nvoid RotateR(inout vec2 point)\n{\n    point.y += BS - bR*BS;\n    point.x -= -aR*BS + BS;\n    point = vec2(aR*point.x - bR*point.y, bR * point.x + aR*point.y + BS);\n}\n\n//https://iquilezles.org/articles/distfunctions\nbool sdCapsule( vec2 p, vec2 a, vec2 b)\n{\n  vec2 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) > 0.002;\n}\n\nbool TestDistance(in vec2[lengthPoints] Points, in vec2 p)\n{\n    return \n    (\n        sdCapsule(p, Points[0], Points[1]) && \n        sdCapsule(p, Points[1], Points[2]) && \n        sdCapsule(p, Points[2], Points[3]) && \n        sdCapsule(p, Points[3], Points[0])\n    );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from -0.5 to 0.5)\n    vec2 uv = fragCoord/iResolution.y - 0.5 - vec2(Ratio, 0.);\n    \n    vec3 col;\n    \n    //Rotation of the complex\n    int r = 0;\n    bool NotHitPoint = TestDistance(pointsB, uv);\n    for(int i = 0; i < iterations && NotHitPoint; i++)\n    {\n        for(int r = 0; r < pointsEL.length() && NotHitPoint; r++)\n        {\n            //NotHitPoint = length(pointsEL[r] - uv) > 0.002;\n            RotateL(pointsEL[r]);\n        }\n        NotHitPoint = NotHitPoint && TestDistance(pointsEL, uv);\n        for(int r = 0; r < pointsER.length() && NotHitPoint; r++)\n        {\n            //NotHitPoint = length(pointsER[r] - uv) > 0.002;\n            RotateR(pointsER[r]);\n        }\n        NotHitPoint = NotHitPoint && TestDistance(pointsER, uv);\n    }\n    \n    col = !NotHitPoint ? vec3(1.) : vec3(0.);\n\n    fragColor = vec4(col, 1.);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"//This is the rotation with a complex number (a + bi)*z\n#define pi 3.14159265359\n#define phi (iTime*0.01)*pi\n#define aL cos(phi)\n#define bL sin(phi) \n#define aR cos(-phi)\n#define bR sin(-phi) \n#define iterations 80\n#define Ratio iResolution.y/(iResolution.y + iResolution.x)\n#define BS 0.02\n#define lengthPoints pointsB.length()\n\nconst vec2 pointsB[] = vec2[](vec2(-BS, -BS), vec2( BS, -BS), vec2( BS, BS), vec2(-BS, BS));\nvec2 pointsEL[] = pointsB;\nvec2 pointsER[] = pointsB;\n\n","name":"Common","description":"","type":"common"}]}