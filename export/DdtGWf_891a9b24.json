{"ver":"0.1","info":{"id":"DdtGWf","date":"1678019753","viewed":376,"name":"Conetraced Soft shadows","username":"Poisson","description":"I created a new way to make raymarched soft shadows, conetraced soft shadows!","likes":32,"published":1,"flags":0,"usePreview":1,"tags":["3d","raymarching","reflection","sss","ray","shadow","fog","raymarcher","csg","specular","scattering","subsurface","penumbra","soft","smooth","pbr","softshadow"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// right - classic shadows\n// left - my improved version\n\n#define AA 1 // antialiasing\n\n// sphere sdf\nfloat sdSphere(vec3 p, float r) {\n    return length(p)-r;\n}\n\n// box sdf\nfloat sdBox(vec3 p, vec3 b) {\n    vec3 q = abs(p) - b;\n    return length(max(q,0.)) + min(max(q.x,max(q.y,q.z)),0.);\n}\n\n// smooth minimum\n// thanks to iq: https://iquilezles.org/articles/smin/\nfloat smin(float a, float b, float k) {\n\tfloat h = clamp(.5+.5*(b-a)/k, 0., 1.);\n\treturn mix(b, a, h) - k*h*(1.-h);\n}\n\n// sdf union\nvec2 opU(vec2 a, vec2 b) {\n    return a.x<b.x ? a : b;\n}\n\n// scene\n// return distance and material id\nvec2 map(vec3 p) {\n    vec2 d = vec2(1e10);\n    \n    float bb = sdBox(p,vec3(2)); // bounding box\n    if (bb<0.) {\n        // csg shape\n        d = opU(d, vec2(smin(sdBox(p,vec3(.4))-.1, -sdSphere(p,.5-.1*(.5+.5*sin(iTime))), -.2), 1));\n\n        // balls\n        float b = 1e10;\n        vec3 q = p;\n        q.x = abs(q.x);\n        b = smin(b, sdSphere(q-vec3(.5+.5*sin(iTime),0,0), .2), .1);\n        q = p.yxz;\n        q.x = abs(q.x);\n        b = smin(b, sdSphere(q-vec3(.5+.5*sin(iTime),0,0), .2), .1);\n        q = p.zyx;\n        q.x = abs(q.x);\n        b = smin(b, sdSphere(q-vec3(.5+.5*sin(iTime),0,0), .2), .1);\n\n        d = opU(d, vec2(b, 2));\n    }\n    \n    // plane\n    d = opU(d, vec2(p.y+.5, 0));\n       \n    return d;\n}\n\n// raymarching function\n// return the distance and the material id\nvec2 intersect(vec3 ro, vec3 rd, float tmin, float tmax) {\n    float t = tmin; // distance travelled\n    \n    for (int i=0; i<256; i++) { // marching loop\n        vec3 p = ro + rd*t; // current point\n        \n        vec2 h = map(p); // distance to the scene\n        if (h.x<.001) return vec2(t,h.y); // we hit the surface\n        \n        t += h.x; // march\n        if (t>tmax) break;\n    }\n    return vec2(-1);\n}\n\n// normal estimation\nvec3 calcNormal(vec3 p) {\n    float h = map(p).x;\n    // epsilon\n    const vec2 e = vec2(.0001,0); // vec2(h,0);\n    \n    return normalize(h - vec3(map(p-e.xyy).x,\n                              map(p-e.yxy).x,\n                              map(p-e.yyx).x));\n}\n\n// soft shadow technique\nint technique;\n// technique 0 by iq: https://iquilezles.org/articles/rmshadows/\n// technique 1 by me\n\n// soft shadow function\n// k is the softness\nfloat shadow(vec3 ro, vec3 rd, float tmax, float k) {\n    float res = 1.; // final result\n    \n    for (float t=0.; t<tmax;) {\n        vec3 p = ro + rd*t;\n        \n        float h = map(p).x;\n        if (h<.001) return 0.;\n        \n        if (technique==0)\n            res = min(res, k*h/t); // get the closest penumbra\n        else {\n            float ra = t/k; // cone radius\n            // penumbra coverage\n            //res *= smoothstep(-ra, ra, h);\n            res *= clamp((h+ra)/(2.*ra),0.,1.);\n        }\n        t += h; // march\n    }\n    if (technique==0)\n        return res*res*(3.-2.*res); // S curve\n    else\n        return res;\n}\n\n// ambient occlusion funtion by me\n// ra is the occlusion distance\nfloat occlusion(vec3 p, vec3 n, float ra) {\n    float res = 0.;\n    const int N = 8; // samples\n        \n    for (int i=0; i<N; i++) {\n        float h = ra * float(i)/float(N); // sampling distance\n        res += clamp(.5+.5*map(p + n*h).x / h,0.,1.);\n    }\n    res /= float(N);\n    \n    return res*res;\n}\n\n// sss function by me\n// ra is the subsurface radius\nfloat subsurface(vec3 ro, vec3 rd, float ra) {\n    float res = 0.;\n    const int N = 8; // samples\n    \n    for (int i=0; i<N; i++) {\n        float h = ra * float(i)/float(N); // sampling distance\n        res += clamp(map(ro + rd*h).x / h,0.,1.);\n    }\n    res /= float(N);\n    \n    return res*res*(3.-2.*res); // S curve\n}\n\nconst vec3 sunDir = normalize(vec3(1)); // sun direction\nconst vec3 sunCol = vec3(1,.8,.6)*2.3; // sun color\n\n// simple background\nvec3 sky(vec3 rd) {\n    return mix(vec3(.45,.65,1)-.5*rd.y, vec3(.5,.7,1)*.7+.3, clamp(exp(-17.*rd.y),0.,1.));\n}\n\n// rendering\nvec3 render(vec3 ro, vec3 rd) {\n    vec3 col = sky(rd);\n    \n    // distance and material\n    vec2 tm = intersect(ro, rd, 0., 16.);\n    if (tm.x>0.) {\n        vec3 p = ro + rd*tm.x; // hit point\n        vec3 n = calcNormal(p); // normal\n        vec3 r = reflect(rd, n); // reflection vector\n        \n        // lighting\n        \n        float dif = clamp(dot(n, sunDir), 0., 1.); // diffuse\n        float sha = shadow(p+n*.002, sunDir, 16., 5.); // shadow\n        float bac = clamp(dot(n, -sunDir), 0., 1.); // back light\n        float occ = occlusion(p, n, .5)*(.5+.5*n.y); // ambient occlusion\n        float bou = .5-.5*n.y; // bounce light\n        float spe = clamp(dot(r, sunDir), 0., 1.); // sun specular\n        float fre = 1.+dot(rd, n); // fresnel\n        float ref = shadow(p+n*.002, r, 16., 16.); // reflection\n        float sss = subsurface(p, sunDir, .4); // subsurface scattering\n        \n        // material color\n        vec3 mat;\n        if (tm.y<.5) {\n            float ch = mod(floor(p.x)+floor(p.z),2.);\n            mat = vec3(.18) + .07*ch;\n            sss *= 0.;\n        } else if (tm.y<1.5) {\n            mat = vec3(.3,.15,.5);\n        } else if (tm.y<2.5) {\n            mat = vec3(.5,.35,.15);\n        }\n                \n        vec3 lin = vec3(0);\n        lin += sunCol * dif*sha; // sun light\n        lin += mat*sunCol * occ*(.5+.5*bac)*bou; // sun gi\n        lin += .4*vec3(1,.3,.1)*sunCol * sss*(1.-dif*sha); // sun sss\n        lin += .5*vec3(.4,.6,1) * occ; // sky diffuse\n                \n        col = mat*lin;\n        float ks = .05+.95*pow(fre,5.); // reflectivity\n        col += .2*sunCol*pow(spe,32.)*ref; // sun reflection\n        col += vec3(.4,.6,1)*ref*ks; // sky reflection\n        \n        col = mix(col, sky(rd), 1.-exp(-tm.x*tm.x*tm.x*.0005)); // fog\n    }\n    col += .3*sunCol*sunCol*pow(clamp(dot(rd, sunDir),0.,1.),5.); // sun glare\n\n    // output\n    return col;\n}\n\n// camera function\nmat3 setCamera(vec3 ro, vec3 ta) {\n    vec3 w = normalize(ta - ro); // forward vector\n    vec3 u = normalize(cross(w, vec3(0,1,0))); // side vector\n    vec3 v = cross(u, w); // up vector\n    return mat3(u, v, w);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float an = -.4*iTime; // camera xz rotation\n    vec3 ro = vec3(3.*sin(an),1,3.*cos(an)); // ray origin\n    vec3 ta = vec3(0); // target\n    mat3 ca = setCamera(ro, ta); // camera matrix\n    \n    // normalized mouse coordinates\n    vec2 m = iMouse.z>0. ? iMouse.xy / iResolution.xy :\n                           vec2(.5,0);\n    // normalized pixel coordinates\n    vec2 p = fragCoord / iResolution.xy;\n    technique = p.x<m.x ? 1 : 0;\n    \n    vec3 tot = vec3(0); // accumulated color\n    for (int m=0; m<AA; m++)\n    for (int n=0; n<AA; n++) {\n        vec2 off = vec2(m,n) / float(AA) - .5; // AA offset\n        // pixel coordinates centered at the origin\n        vec2 p = (fragCoord+off - .5*iResolution.xy) / iResolution.y;\n        \n        vec3 rd = ca * normalize(vec3(p,1.5));\n        vec3 col = render(ro, rd); // render\n        \n        col = 1.4*col/(1.+.5*col); // tonemapping\n        col = pow(col, vec3(.4545)); // gamma correction\n                \n        tot += col;\n    }\n    tot /= float(AA*AA);\n    \n    // contrast\n    tot = tot*.8+.2*tot*tot*(3.-2.*tot);\n    \n    // red line\n    float e = 1./iResolution.y;\n    tot = mix(tot, vec3(1,0,0), smoothstep(e, 0., abs(p.x-m.x)));\n\n    // vignette\n    vec2 q = fragCoord/iResolution.xy;\n    tot *= .3+.7*pow(32. * q.x*q.y*(1.-q.x)*(1.-q.y), .1);\n    \n    fragColor = vec4(tot,1.0);\n}","name":"Image","description":"","type":"image"}]}