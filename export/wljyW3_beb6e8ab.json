{"ver":"0.1","info":{"id":"wljyW3","date":"1595588163","viewed":564,"name":"Perfect SDF Texture Generator","username":"sdfgeoff","description":"I wanted a tool that generated texture containing SDF's from straight line segments and couldn't find one. So here one is. Fairly well documented","likes":16,"published":1,"flags":0,"usePreview":0,"tags":["sdf","line","generator","tool","neon"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/* \nSDF TEXTURE GENERAOR. \n\nGenerates mathematically perfect textures of distance fields\nfrom straight line segments. Clicking enables a preview\nof the lines the SDF will draw.\n\nI was looking for a tool to generate SDF textures for a game, \nand couldn't find one I liked. This should do the job.\nNote that this is designed as a tool for creating assets and\nis not intended to be used in an actual game. As a result it\nis written for clarity rather than performance.\n\nLicense is LGPLv3. Shader written by sdfgeoff\n*/\n\n/* ////////////////// OUTPUT //////////////////////\nWhen previews are disabled, the output SDF is in the blue\nchannel. \n\nSDF_SCALE scales the SDF output. With a scale of 1.0, a\nvertical line on the left of the image will result in the\nchannel maximum being reached on the right of the image.\nThe default of 1.0 means that you can multiply by the sprite\nsize in pixels and the result will be true, however it does not\nmake optimal use of the channels space. For a more accurate SDF\nyou can increase it.\n\nThe configuration option ENABLE_NORMALS enables the output of\na vector pointing to the closest line segment in the red and\ngreen channels.\n\nINVERT_SDF When set to true, this makes the SDF = 1.0 where it\nreaches the line segment. When this is false the SDF = 0.0 where\nit reaches the segment.\n*/\nfloat SDF_SCALE = 1.0;\nbool ENABLE_NORMALS = true;\nbool INVERT_SDF = true;\n\n\n\n/* ///////////////// PREVIEWS ///////////////////\n\nENABLE_SIMPLE_PREVIEW is useful for when you are creating \nthe drawing to check it shows what you expect. It shows thin\nblack lines on a white background.\n\nENABLE_NEON_PREVIEW shows the SDF with a \"neon glow\" effect.\nThis is how the sprites appear in the game I'm working\non, so it's how I want to be able to preview the texture.\n\nENABLE_CONTOUR_PREVIEW is useful for debugging the shader and \nvalidating the SDF output is correct. It overwrites the blue\nchannel\n*/\nbool ENABLE_NEON_PREVIEW = false;\nbool ENABLE_SIMPLE_PREVIEW = false;\nbool ENABLE_CONTOUR_PREVIEW = false;\n\n\n/* //////////// COORDINATE_SYSTEM //////////////////\nBy default the coordinate in the middle is (0,0) and\nthe top right is (1,1) and bottom left is (-1, -1)\n\nOFFSET changes where the origin of the coordinates are\nFor example and offset of (0.5, 0.5) will put the origin\nat (0.5, 0.5). It is the same as adding the offset vector\nto each line segment\n\nZOOM zooms the whole image in and out. Bigger numberes\nmeans the line segments become \"closer\". ZOOM does *not*\nscale the SDF component of the image, merely adjusts the\npositioning of the line segments.\n\nMIRROR mirrors along the X axis. Note that this truncates\nthe negative X axis so segments crossing the centerline\nare not displayed. However invisible segments can affect\nthe distance field, so if MIRROR is true, no segments\nshould have negative X values.\n\n*/\nvec2 OFFSET = vec2(0.0, -0.25);\nfloat ZOOM = 1.0;\nbool MIRROR = true;\n\n\n/* //////////////// THE DRAWING ////////////////////\nThe image is described as a series of straight line segments.\nThe lines can be disjoint.\n\nNUM_LINES is the number of line segments to draw.\n\nLINES is an array of line segments. Each element in the array\nis a vec4. The first two floats are the start position, the\nthird and fourth floats are the end position.\n*/\nconst int NUM_LINES = 10;\nvec4[NUM_LINES] LINES = vec4[NUM_LINES](\n    // Wings and fuselage\n    vec4(0.0, 0.75, 0.5, 0.0),\n    vec4(0.15, -0.35, 0.5, 0.0),\n    vec4(0.15, -0.35, 0.15, 0.25),\n    vec4(0.0, 0.5, 0.15, 0.25),\n    \n    // Engine bits\n    vec4(0.15, -0.2, 0.0, -0.25),\n    vec4(0.11, -0.22, 0.06, -0.35),\n    vec4(0.0, -0.35, 0.06, -0.35),\n    \n    // Cockpit\n    vec4(0.1, 0.2, 0.0, 0.35),\n    vec4(0.1, 0.2, 0.1, 0.1),\n    vec4(0.0, 0.15, 0.1, 0.1)\n);\n\n\nvec3 distance_from_segment(vec2 point, vec2 segment_start, vec2 segment_end) {\n    // the first component is the distance, second and third component are\n    // direction to the line segment\n    vec2 line_direction = segment_start - segment_end;\n    vec2 point_on_line = segment_end;\n    float segment_length = length(line_direction);\n\n\n    float projected_distance = dot(normalize(line_direction), point - point_on_line);\n    vec2 closest_point = point_on_line + projected_distance * line_direction / segment_length;\n\n    float distance_from_end = -projected_distance;\n    float distance_from_start = projected_distance - segment_length;\n\n    // Rounded caps on segment\n    if (distance_from_start > 0.0) {\n        closest_point = segment_start;\n    }\n    if (distance_from_end > 0.0) {\n        closest_point = segment_end;\n    }\n\n    return vec3(\n        length(point - closest_point),\n        normalize(point - closest_point).xy\n    );\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Set coordinate (0, 0) as the center of the screen by default\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 coords = (uv - 0.5) * 2.0;\n    coords.x *= iResolution.x / iResolution.y;\n    \n    // Black boxes so we're working with a square texture\n    if (coords.x > 1.0 || coords.x < -1.0) {\n        fragColor = vec4(0.0);\n        return;\n    }\n    \n    coords -= OFFSET;\n    coords /= ZOOM;\n    \n    vec2 unmirrored = coords; // Avoids losing information. Mirroring is lossy\n    if (MIRROR) {\n        coords.x = abs(coords.x);\n    }\n    \n    // Initial SDF vector. \n    // x is the sdf. yz is the direction to line segment\n    vec3 sdf = vec3(999.9, 0.0, 0.0);\n    \n    for (int i=0; i<NUM_LINES; i++) {\n        // Draw and combine each line\n        vec4 line = LINES[i];\n        vec3 new_sdf = distance_from_segment(coords, line.xy, line.zw);\n        \n        if (new_sdf.x < sdf.x){\n            sdf = new_sdf;\n        }\n    }\n    \n    // The mirror operation results in the left side having\n    // flipped normals (it is a clone of the right side)\n    // So we need to restore them\n    if (MIRROR && unmirrored.x > 0.0) {\n       sdf.y *= -1.0; // Y channel is the X normal. Bleh, sorry.\n    }\n    \n    // Scale the SDF output. The 0.5 is because the original coordinate\n    // system spans -1.0 to 1.0 which is a distance of 2.0\n    sdf.x *= SDF_SCALE * 0.5; \n    \n    \n    float raw_sdf = sdf.x;\n    if (INVERT_SDF) {\n        sdf.x = 1.0 - sdf.x;\n    }\n    \n    \n    // The usual output\n    fragColor.rgba = vec4(sdf.x);\n    if (ENABLE_NORMALS) {\n        fragColor.rg = sdf.yz * 0.5 + 0.5;\n    }\n    \n    // Previews\n    if (ENABLE_NEON_PREVIEW) {\n        float ramp1 = pow(clamp(1.0 - raw_sdf * 10.0, 0.0, 1.0), 2.0);\n        float ramp2 = pow(clamp(1.0 - raw_sdf * 15.0, 0.0, 1.0), 2.0);\n        float ramp3 = pow(clamp(1.0 - raw_sdf * 30.0, 0.0, 1.0), 2.0);\n    \tfragColor = vec4(0.0, 0.0, 1.0, 1.0) * ramp1;\n        fragColor += vec4(0.0, 1.0, 1.0, 1.0) * ramp2;\n        fragColor += vec4(1.0, 1.0, 1.0, 1.0) * ramp3;\n    }\n    if (ENABLE_SIMPLE_PREVIEW || iMouse.z > 0.5) {\n        fragColor.rgb = vec3(raw_sdf > 0.005);\n    }\n    \n    if (ENABLE_CONTOUR_PREVIEW) {\n        fragColor.b = float(mod(sdf.x, 0.1)>0.09);\n    }\n    \n}","name":"Image","description":"","type":"image"}]}