{"ver":"0.1","info":{"id":"WsdBDl","date":"1606275411","viewed":118,"name":"Dual Spheres 2d Sdf","username":"Firal","description":"I had an idea for deriving an sdf between two spheres where they were connected by their shared line of tangency, but tl;dr: turns out that it is mechanically the same as iq's: https://www.shadertoy.com/view/4lcBWn.","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["sdf","capsule"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\nhttps://www.shadertoy.com/view/tddfRB\nMade by Firal (Zack Misso)\n*/\n\n// I had an idea for deriving and sdf between two circles where they were connected by their shared line of\n// tangency, so I implemented it. However, I realized immediately after finishing this that this does the\n// same thing as iq's uneven capsule sdf which is ultimately nicer than my implementation. His can be found\n// here: https://www.shadertoy.com/view/4lcBWn.\n\nfloat sdDualCircle(vec2 p, vec2 a, vec2 b, float ra, float rb)\n{  \n    vec2 ba = b-a;\n    float bal = length(ba);\n    ba = normalize(ba);\n    float cr = (ra - rb) / bal;\n    float to_c = rb / cr + bal;\n    vec2 c = ba * to_c + a;\n    float angle = asin(ra / to_c);\n    \n    vec2 rgt = vec2(-ba.y, ba.x);\n    float sgn = sign(dot(rgt, p-a));\n    rgt = normalize(sgn * rgt);\n    angle *= -sgn;\n    \n    vec2 to_d = vec2(rgt.x * cos(angle) - rgt.y * sin(angle),\n                     rgt.x * sin(angle) + rgt.y * cos(angle));\n    \n    vec2 da = a + to_d * ra;\n    vec2 db = b + to_d * rb;\n    vec2 dba = db - da;\n    vec2 dn = sgn * vec2(-dba.y, dba.x);\n    \n    vec2 pda = p-da;\n    float t = dot(pda,dba) / dot(dba,dba);\n    \n    float dist_3 = 10000.;\n    if (t < 1.0 && t > 0.0)\n    {\n        // flip sign of the internal parts\n        dist_3 = sign(dot(dn, p - db)) * length( pda - dba*t );\n    }\n    else\n    {\n        \n        t = clamp(t, 0.0, 1.0);\n        dist_3 = length( pda - dba*t );\n    }\n    \n    \n    float dist_1 = length(p - a) - ra;\n    float dist_2 = length(p - b) - rb;\n    \n    return min(dist_3, min(dist_1, dist_2));\n}\n\n// the shading routine. Modified version of iq's\n// https://www.shadertoy.com/view/3ltSW2\nvec3 shade(float sd)\n{\n    vec3 col = vec3(1.0) - sign(sd) * vec3(0.9,0.4,0.2);\n    \n    col *= 1.0 - exp(-6.0*abs(sd));\n\tcol *= 0.8 + 0.2*cos(140.0*sd);\n\tcol = mix( col, vec3(1.0, 0.0, 0.0), 1.0-smoothstep(0.0,0.02,abs(sd)) );\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    vec2 world_p = vec2(p*1.3);\n    \n    vec2 a_pos = vec2(0.0 + 1.0 * sin(iTime), -0.1 + 0.8 * cos(iTime));\n    vec2 b_pos = vec2(0.0 + 0.2 * sin(iTime), 0.5 + 0.2 * cos(iTime));\n    float ra = 0.4 + 0.2 * sin(2.0 * iTime);\n    float rb = 0.2 + 0.2 * cos(2.0 * iTime);\n\t\n    fragColor = vec4(shade(sdDualCircle(world_p, a_pos, b_pos, ra, rb)), 1.0);\n}","name":"Image","description":"","type":"image"}]}