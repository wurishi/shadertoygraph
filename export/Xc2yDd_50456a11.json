{"ver":"0.1","info":{"id":"Xc2yDd","date":"1723179297","viewed":43,"name":"Accumulation Test 3","username":"pkncoder","description":"This is one of my accumulation tests for my shader engine.","likes":0,"published":1,"flags":32,"usePreview":0,"tags":["raytracing","pathtracing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 color = texture(iChannel0, fragCoord / iResolution.xy).rgb;\n    fragColor = vec4(color, 1.0f);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"precision highp float;\n\n#define PI 3.14159265359\n#define time int(iTime) * 10\n\nstruct RayTracingMaterial {\n    vec3 color;\n    float emmisive;\n    float smoothness;\n};\n\nstruct Sphere {\n    vec3 coords;\n    float radius;\n    RayTracingMaterial material;\n};\n\nstruct HitInfo {\n    bool hit;\n    vec3 hitPos;\n    float dist;\n    vec3 normal;\n    RayTracingMaterial material;\n};\n\nstruct Ray {\n    vec3 orgin;\n    vec3 direction;\n};\n\nstruct Box {\n    vec3 orgin;\n    vec3 boxSize;\n    RayTracingMaterial material;\n};\n\nHitInfo intersect(Ray ray, Sphere sphere) {\n    HitInfo hit;\n\n    hit.hit = false;\n\n    vec3 rayOffset = ray.orgin - sphere.coords;\n\n    float a = dot(ray.direction, ray.direction);\n    float b = dot(rayOffset, ray.direction);\n    float c = dot(rayOffset, rayOffset) - sphere.radius * sphere.radius;\n\n    float det = b * b - a * c;\n\n    if (det < 0.0) {return hit;}\n\n    float t0 = (-b - sqrt(det)) / (a);\n\n    if (t0 < 0.0) {\n        return hit;\n    }\n\n    hit.hit = true;\n    hit.hitPos = ray.orgin + ray.direction * t0;\n    hit.dist = t0;\n    hit.normal = normalize(hit.hitPos - sphere.coords);\n    hit.material = sphere.material;\n\n    return hit;\n}\n\n//https://iquilezles.org/articles/intersectors/\n// axis aligned box centered at the origin, with size box.boxSize\nHitInfo intersect( Ray ray, Box box ) \n{\n\n    HitInfo hit;\n    hit.hit = false;\n\n    vec3 m = 1./ray.direction;\n    vec3 n = m*(ray.orgin - box.orgin);\n    vec3 k = abs(m) * box.boxSize;\n\t\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\n\tfloat tN = max( max( t1.x, t1.y ), t1.z );\n\tfloat tF = min( min( t2.x, t2.y ), t2.z );\n\t\n\tif( tN > tF || tF < 0.) return hit;\n    \n    float t = tN < 0.1 ? tF : tN;\n\n    hit.hit = true;\n    hit.hitPos = ray.orgin + ray.direction * t;\n    hit.dist = t;\n    hit.normal = -sign(ray.direction)*step(t1.yzx,t1.xyz)*step(t1.zxy,t1.xyz);;\n    hit.material = box.material;\n\n    return hit;\n}\n\nmat2 rot2D(float angle) {\n    float s = sin(angle);\n    float c = cos(angle);\n    return mat2(c, -s, s, c);\n}\n\nint NextRandom(inout int state)\n{\n    state = state * 747796405 + 2891336453;\n    int result = ((state >> ((state >> 28) + 4)) ^ state) * 277803737;\n    result = (result >> 22) ^ result;\n    return result;\n}\n\nfloat RandomValue(inout int state)\n{\n    return float(NextRandom(state)) / 4294967295.0; // 2^32 - 1\n}\n\n// Random value in normal distribution (with mean=0 and sd=1)\nfloat RandomValueNormalDistribution(inout int state)\n{\n    // Thanks to https://stackoverflow.com/a/6178290\n    float theta = 2.0 * 3.1415926 * RandomValue(state);\n    float rho = sqrt(-2.0 * log(RandomValue(state)));\n    return rho * cos(theta);\n}\n\n// Calculate a random direction\nvec3 RandomDirection(inout int state)\n{\n    // Thanks to https://math.stackexchange.com/a/1585996\n    float x = RandomValueNormalDistribution(state);\n    float y = RandomValueNormalDistribution(state);\n    float z = RandomValueNormalDistribution(state);\n    return normalize(vec3(x, y, z));\n}\n\nHitInfo calculateClosestHit(Ray ray, int depth) {\n\n    Sphere[1] spheres;\n    Box[7] boxes;\n\n    spheres[0] = Sphere(\n        vec3(0.0, 0.0, -4.0),\n        2.0,\n        RayTracingMaterial(\n            vec3(1.0, 1.0, 1.0),\n            0.0,\n            0.0\n        )\n    );\n\n    boxes[0] = Box(\n        vec3(-4.0, 0.0, -3.0),\n        vec3(0.1, 4.0, 4.0),\n        RayTracingMaterial(\n            vec3(1.0, 0.0, 0.0),\n            0.0,\n            0.0\n        )\n    );\n\n    boxes[1] = Box(\n        vec3(0.0, 0.0, -1.0),\n        vec3(4.0, 4.0, 0.1),\n        RayTracingMaterial(\n            vec3(0.2, 0.2, 0.2),\n            0.0,\n            0.0\n        )\n    );\n\n    boxes[2] = Box(\n        vec3(4.0, 0.0, -3.0),\n        vec3(0.1, 4.0, 4.0),\n        RayTracingMaterial(\n            vec3(0.0, 0.0, 1.0),\n            0.0,\n            0.0\n        )\n    );\n\n    boxes[3] = Box(\n        vec3(0.0, -4.0, -3.0),\n        vec3(4.0, 0.1, 4.0),\n        RayTracingMaterial(\n            vec3(0.0, 1.0, 0.0),\n            0.0,\n            0.0\n        )\n    );\n\n    boxes[4] = Box(\n        vec3(0.0, 4.0, -3.0),\n        vec3(4.0, 0.1, 4.0),\n        RayTracingMaterial(\n            vec3(1.0, 1.0, 1.0),\n            0.0,\n            0.0\n        )\n    );\n    boxes[5] = Box(\n        vec3(0.0, 3.8, -3.0),\n        vec3(1.0, 0.2, 1.0),\n        RayTracingMaterial(\n            vec3(1.0, 1.0, 1.0),\n            10.0,\n            0.0\n        )\n    );\n\n    boxes[6] = Box(\n        vec3(0.0, 0.0, -7.0),\n        vec3(4.0, 4.0, 0.2),\n        RayTracingMaterial(\n            vec3(1.0, 0.9843, 0.0),\n            0.0,\n            0.0\n        )\n    );\n\n    HitInfo closestHit;\n    closestHit.hit = false;\n    closestHit.dist = 800000.0; // Infinity\n\n    for (int i = 0; i < spheres.length(); i++) {\n        HitInfo sphereHit = intersect(ray, spheres[i]);\n\n        if (sphereHit.hit && sphereHit.dist < closestHit.dist) {\n            closestHit = sphereHit;\n        }\n    }\n\n    int ignore = 0;\n    if (depth < 1) { ignore = 1; }\n\n    for (int i = 0; i < boxes.length() - ignore; i++) {\n        HitInfo boxHit = intersect(ray, boxes[i]);\n\n        if (boxHit.hit && boxHit.dist < closestHit.dist) {\n            closestHit = boxHit;\n        }\n    }\n\n    return closestHit;\n}\n\nvec3 trace(Ray ray, int rngState) {\n    int numBounces = 5;\n\n    vec3 colorMult = vec3(1.0);\n    vec3 color = vec3(0.0);\n\n    for (int b = 0; b <= numBounces; b++) {\n\n        HitInfo closestHit = calculateClosestHit(ray, b);\n\n        if (!closestHit.hit) {\n            break;\n        }\n\n        // check\n        vec3 offset = (closestHit.normal + RandomDirection(rngState));\n\n        if (dot(closestHit.normal, offset) < 0.0) {\n            offset = -offset;\n        }\n\n        // check\n        ray.orgin = closestHit.hitPos;\n\n        vec3 diffuseDirection = normalize(offset);\n        vec3 specularDirection = reflect(ray.direction, closestHit.normal);\n\n        ray.direction = normalize(mix(diffuseDirection, specularDirection, closestHit.material.smoothness));\n\n        vec3 emittedLight = closestHit.material.emmisive * closestHit.material.color;\n        color += emittedLight * colorMult;\n        colorMult *= closestHit.material.color;\n        \n        float p = max(colorMult.r, max(colorMult.g, colorMult.b));\n        if (RandomValue(rngState) >= p) {\n            break;\n        }\n        colorMult *= 1.0f / p; \n    }\n\n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = ((fragCoord.xy / iResolution.xy) * 2.0 - 1.0) * vec2(iResolution.x / iResolution.y, 1.0);\n    \n    float angle = tan((PI * 0.5 * 30.0) / 180.0);\n    vec2 xy = vec2(angle, angle);\n    uv *= xy;\n    Ray ray = Ray(\n        vec3(0.0, 0.0, -20.0),\n        normalize(vec3(uv, 1.0))\n    );\n\n    int pixelIndex = int(fragCoord.y * iResolution.x + fragCoord.x);\n\tint rngState = int((pixelIndex + int(time) * 719393));\n\n    vec3 color = vec3(0.0);\n    \n    for (int r = 0; r < 12; r++) {\n        color += trace(ray, rngState + int(pow(float(r), 3.0)));\n    }\n    \n    color /= 3.0;\n    color = pow(color, vec3(1.0 / 2.2));\n    \n    vec3 lastFrameColor = texture(iChannel0, fragCoord / iResolution.xy).rgb;\n    color = mix(lastFrameColor, color, 1.0f / float(iFrame+1));\n\n\n    fragColor = vec4(color, 1.0);\n}","name":"Buffer A","description":"","type":"buffer"}]}