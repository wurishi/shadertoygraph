{"ver":"0.1","info":{"id":"ddtXzS","date":"1680066974","viewed":110,"name":"Procedural desert shore terrain","username":"Miroika","description":"Hey first time creating a shader on shadertoy, take me a day.\nI like it even though there is still some issues such as:\n- The very far water which is glichy.\n- When hills are too big there became also glichy.","likes":9,"published":1,"flags":0,"usePreview":0,"tags":["terrain","water","desert"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sf3Rn","filepath":"/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","previewfilepath":"/media/ap/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const vec3 SUN_DIRECTION = normalize(vec3(0.25, 1, 0));\nconst float CAMERA_OFFSET_MULTIPLIER = 4.0; // 0 -> x\nconst float HILL_SIZE = 0.1;\n\n// RAY MARCHING\nconst int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float PRECISION = 0.001;\n\n// WATER\nconst float WATER_LEVEL = -1.;\nconst vec3 WATER_SHORE_COLOUR = vec3(0.5, 0.8, 1.0);\nconst vec3 WATER_SEA_COLOUR = vec3(0.4, 0.5, 0.9);\n\n// FOG\nconst float FOG_HARDNESS = 1.0; // 1 -> x\nconst float FOG_HEIGHT = 1.0; // 0 -> 2\nconst vec3 FOG_COLOUR = vec3(1.0, 1.0, 1.0);\n\n// OTHER COLOURS\nconst vec3 SKY_COLOUR = vec3(0.29, 0.56, 0.85);\nconst vec3 ROCK_COLOUR = vec3(0.95, 0.69, 0.54);\nconst vec3 GROUND_MAIN_COLOUR = vec3(0.94, 0.86, 0.62);\nconst vec3 GROUND_SECONDARY_COLOUR = vec3(1.0, 0.91, 0.77);\n\nfloat GetHeightAtPoint(vec2 p, float size)\n{\n    return texture(iChannel1, p * size).x;\n}\n\nfloat GetBumpinessAtPoint(vec2 p, float size)\n{\n    return texture(iChannel2, p * size).x;\n}\n\nfloat GetVariationMapAtPoint(vec2 p, float size)\n{\n    return texture(iChannel1, p * size).r;\n}\n\n// Returns the distance to the scene at a given point\nfloat sdScene(vec3 point)\n{\n    // Get the noise value and set it to also be used as the terrainShape intensity\n    float noiseValue = GetVariationMapAtPoint(point.xz, 0.002);\n    float terrainShapeIntensity = noiseValue;\n    \n    float bumpiness = GetBumpinessAtPoint(point.xz, 0.1);\n    float height = GetHeightAtPoint(point.xz, 0.00001) * 2.0;\n    \n    // Calculate the global shape of the terrain\n    float cubicCurvePoint = (point.x + noiseValue * 10.0) + 1.0;\n    float oceanDepth = min(0.0, point.x * 0.025);\n    float terrainShape = (min(HILL_SIZE, max(oceanDepth, (cubicCurvePoint * cubicCurvePoint * cubicCurvePoint) * 0.001))) * (1.0 + terrainShapeIntensity * 3.0);\n\n    // Calculate the distance to the scene at the given point\n    float distance = 1.0 + point.y\n        + (mix(bumpiness * 0.3, (1.0 - bumpiness) * 0.9, clamp(-0.3 + terrainShapeIntensity, 0.0, 1.0)))\n        - (-3.0 + height * 8.0) * terrainShape;\n\n    // Clamp the distance to prevent negative values and adjust for the intensity of the terrainShape\n    distance = min(distance - terrainShapeIntensity * 4.0 * terrainShape, distance);\n\n    return distance;\n}\n\nfloat rayMarch(vec3 rayOrigin, vec3 rayDirection)\n{\n  float depth = MIN_DIST;\n  \n  for (int i = 0; i < MAX_MARCHING_STEPS; i++)\n  {\n    vec3 point = rayOrigin + rayDirection * depth;\n    float clossestSurfaceDistance = sdScene(point);\n    \n    // Step forward\n    depth += clossestSurfaceDistance;\n    if (clossestSurfaceDistance < PRECISION || depth > MAX_DIST)\n        break;\n  }\n\n  return depth;\n}\n\nvec3 calcNormal(vec3 hitPoint)\n{;\n    vec2 e = vec2(1.0, -1.0) * 0.15;\n    return normalize(\n      e.xyy * sdScene(hitPoint + e.xyy) +\n      e.yyx * sdScene(hitPoint + e.yyx) +\n      e.yxy * sdScene(hitPoint + e.yxy) +\n      e.xxx * sdScene(hitPoint + e.xxx));\n}\n\n// Not working properly but good enough for the result I want\nfloat getAngle(vec3 v1, vec3 v2)\n{\n    return acos(dot(v1, v2)) * 6.28318530718;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n  vec3 col;\n  vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n\n  float cameraOffset = 0.0;\n  if (iMouse.x >= 10.0 && iMouse.x <= iResolution.x)\n  {\n      cameraOffset += ((iMouse.x / iResolution.x) - 0.5) * 2.0;\n  }\n  \n  // Camera\n  vec3 cameraPos = vec3(0.0 + cameraOffset * CAMERA_OFFSET_MULTIPLIER, 3.0, iTime * -1.0);\n  vec3 rayDirection = normalize(vec3(uv, -1));\n\n  float hitDistance = rayMarch(cameraPos, rayDirection);\n  vec3 hitPoint = cameraPos + rayDirection * hitDistance;\n   \n  if (hitDistance > MAX_DIST) {\n    col = SKY_COLOUR;\n  }\n  else {\n    \n    // Sun Light\n    vec3 normal = calcNormal(hitPoint);\n    float diffuse = clamp(dot(normal, SUN_DIRECTION), 0., 1.);\n    \n    // Solid color\n    vec3 diffuseColor;\n    if (abs(getAngle(normal, vec3(0.0, 1, 0.0))) >= 4.0)\n        diffuseColor = ROCK_COLOUR;\n    else \n    {\n       // Mix different color of ground for better looking landscape\n        diffuseColor = mix(GROUND_MAIN_COLOUR, GROUND_SECONDARY_COLOUR, GetBumpinessAtPoint(hitPoint.xz, 0.01));\n        diffuseColor += (GetBumpinessAtPoint(hitPoint.xz, 0.02) * 0.05);\n    }\n  \n    col = diffuse * diffuseColor;\n  }\n  \n  // Water\n  if (hitPoint.y <= WATER_LEVEL)\n  {\n      // Compute factor that change the colour of the water\n      float shoreGradiant = min(1.0, max(0.0, abs(hitPoint.x) * 0.01));\n      float depthGradiant = abs(hitPoint.y) / 8.0;\n      \n      // Mix all the factor to get the water colour\n      vec3 waterColour = mix(WATER_SHORE_COLOUR, WATER_SEA_COLOUR, max(depthGradiant, shoreGradiant));\n      if (hitDistance > MAX_DIST)\n          col = waterColour;\n      else\n          // mix with ground color for translucency\n          col = mix(col, waterColour, min(1.0, depthGradiant + 0.5));\n  }\n  else\n  {\n    // Fog (very basic)\n    float fogGradient = min(1.0, max(0.0, rayDirection.y * -5.0 + FOG_HEIGHT));\n    vec3 colWithFog = mix(col, FOG_COLOUR, min(MAX_DIST, hitDistance * FOG_HARDNESS) / MAX_DIST);\n    col = mix(col, colWithFog, fogGradient);\n  }\n   \n  \n  // Output\n  fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}