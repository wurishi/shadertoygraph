{"ver":"0.1","info":{"id":"tdVXzy","date":"1574363887","viewed":79,"name":"Another FBM Remix","username":"dust","description":"More FBM fun between builds","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["procedural","noise","fbm","rgb","animation"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n// Slow, high-quality 2D hash adapted from nimitz's\n// WebGL2 hash collection\n// (https://www.shadertoy.com/view/Xt3cDn)\nvec2 hash22(uvec2 p)\n{\n    const uint PRIME32_2 = 2246822519U, PRIME32_3 = 3266489917U;\n\tconst uint PRIME32_4 = 668265263U, PRIME32_5 = 374761393U;\n    uint h32 = p.y + PRIME32_5 + p.x*PRIME32_3;\n    h32 = PRIME32_4*((h32 << 17) | (h32 >> (32 - 17))); //Initial testing suggests this line could be omitted for extra perf\n    h32 = PRIME32_2*(h32^(h32 >> 15));\n    h32 = PRIME32_3*(h32^(h32 >> 13));\n    h32 = h32^(h32 >> 16);\n    uvec2 rz = uvec2(h32, h32*48271U);\n    return vec2(rz.xy & uvec2(0x7fffffffU)) / float(0x7fffffff);\n}\n\n// Specialty Perlin ease-in/out function\nvec2 soften(vec2 t)\n{\n    vec2 t3 = t * t * t;\n    vec2 t4 = t3 * t;\n    vec2 t5 = t4 * t;\n    return 6.0f * t5 - \n           15.0f * t4 +\n           10.0f * t3;\n}\n\n// Perlin noise function, taking corner + pixel positions as input\nfloat Perlin(vec2 uv)\n{\n    // Find corner coordinates\n    vec4 lwrUpr = vec4(floor(uv), ceil(uv));\n    mat4x2 crnrs = mat4x2(lwrUpr.xw, lwrUpr.zw,\n                          lwrUpr.xy, lwrUpr.zy);\n    \n    // Generate gradients at each corner\n    mat4x2 dirs = mat4x2(hash22(uvec2(floatBitsToUint(crnrs[0]))),\n                         hash22(uvec2(floatBitsToUint(crnrs[1]))),\n                         hash22(uvec2(floatBitsToUint(crnrs[2]))),\n                         hash22(uvec2(floatBitsToUint(crnrs[3]))));\n    \n    // Shift gradients into [-1...0...1]\n    dirs *= 2.0f;\n    dirs -= mat4x2(vec2(1.0f), vec2(1.0f), \n                   vec2(1.0f), vec2(1.0f));\n    \n    // Normalize\n    dirs[0] = normalize(dirs[0]);\n    dirs[1] = normalize(dirs[1]);\n    dirs[2] = normalize(dirs[2]);\n    dirs[3] = normalize(dirs[3]);\n        \n    // Find per-cell pixel offset\n    vec2 offs = mod(uv, 1.0f);\n    \n    // Compute gradient weights for each corner; take each offset relative\n    // to corners on the square in-line\n    vec4 values = vec4(dot(dirs[0], (offs - vec2(0.0f, 1.0f))),\n                       dot(dirs[1], (offs - vec2(1.0f))),\n                       dot(dirs[2], (offs - vec2(0.0f))),\n                       dot(dirs[3], (offs - vec2(1.0f, 0.0f))));\n    \n    // Return smoothly interpolated values\n    vec2 softXY = offs;//soften(offs);\n    return mix(mix(values.z, \n                   values.w, softXY.x),\n               mix(values.x, \n                   values.y, softXY.x),\n               softXY.y);\n}\n\n// Compute fractal noise for a given pixel position\nvec3 fbm(vec2 uv)\n{\n    const uint depth = 24u;\n    const vec2 dFreq = vec2(1.01f, 1.02f);\n    const float dAmpl = 1.2f;\n    vec2 srct = vec2(1.0f);//vec2((sin(iTime) * 0.1f, cos(iTime) * 0.1f));// + vec2(200.0f);\n    vec2 t = srct;//min((srct * (0.075 / log(srct)) + sin(srct * 0.01)), 400.0);\n    vec2 sfreq = vec2(1.01f + (sin(t) * 2.0)); // Starting noise scaling frequency\n    vec2 rfreq = vec2(1.1f); // Starting noise rotational frequency\n    float ampl = 0.25f; // Starting noise intensity\n    float f = 0.0f;\n    for (uint i = 0u; i < depth; i += 1u)\n    {\n        float f0 = Perlin(uv);\n        f += ampl * f0 * abs(Perlin(uv));\n        ampl *= dAmpl;\n        uv += (sfreq + rfreq) * ampl;\n    }\n    return vec3(f, pow(ampl, dAmpl), uv.x * uv.y);\n}\n\n//#define NOISE_MIRR\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Normalized pixel coordinates (from 0 to [1.0 / [cellSize]])\n    float cellSize = 0.0825f + Perlin((fragCoord / iResolution.y + (sin(vec2(iTime, log(iTime))) + 1.8f)) * 0.01f);\n    #ifdef NOISE_MIRR\n    \tfloat hAspect = (iResolution.x / iResolution.y) * 0.5f;\n    \tvec2 uv = abs((fragCoord / iResolution.y) - vec2(hAspect, 0.5f)) / cellSize;\n    #else\n    \tvec2 uv = (fragCoord / iResolution.y) / cellSize;\n    #endif\n    //uv += (vec2(0.1) + texture(iChannel1, uv).rr) * 0.1;\n    // Generate per-channel fbm()\n    // fbm(p + fbm(p + fbm(p)))\n    // FBM recursion function from iq through the Book of Shaders:\n    // https://iquilezles.org/articles/warp\n    // https://thebookofshaders.com/13/\n    vec2 uv2 = uv + vec2(sin(iTime), cos(iTime));\n\tvec3 rgb = fbm(uv + fbm(uv2).xy); //vec3(r, g, r * g);\n    \n    // Output to screen\n    fragColor = vec4(rgb, 1.0);\n}","name":"Image","description":"","type":"image"}]}