{"ver":"0.1","info":{"id":"lldyW2","date":"1534215677","viewed":1633,"name":"Retro cyberpunk sunset","username":"Carandiru","description":"variant of original shader: https://www.shadertoy.com/view/ldVyDy\n","likes":21,"published":1,"flags":32,"usePreview":0,"tags":["sunset","retro","cyberpunk"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14159 \n\n// Slight fish eye effect, bulge in the middle\nvec2 deformUv(vec2 uv) \n{\n\tfloat yMul = 0.92 - 0.08 * sin(uv.x * PI);\n            \n    if(uv.y >= 0.5)\n    {\n    \treturn vec2(uv.x, yMul*(uv.y-0.5)+0.5 );\n    }\n    else\n    {\n    \treturn vec2(uv.x, 0.5+yMul*(uv.y-0.5));\n    }\n}\n\n// Intensity of the image is faded around the edges\nfloat edgeIntensity(vec2 uv)\n{\n\tfloat edgeIntensityX = 1.0;\n    if( uv.x < 0.1)\n    {\n    \tedgeIntensityX = 0.7 + 0.3*(uv.x/0.1);\n    }\n    else if( uv.x > 0.90)   \n    {\n    \tedgeIntensityX = 0.7 + 0.3*((1.0-uv.x)/0.1);\n    }\n        \n    float edgeIntensityY = 1.0;\n    if( uv.y < 0.15)\n    {\n    \tedgeIntensityY = 0.6 + 0.4*(uv.y/0.15);\n    }\n    else if( uv.y > 0.85)   \n    {\n    \tedgeIntensityY = 0.6 + 0.4*((1.0-uv.y)/0.15);\n    }        \n    return edgeIntensityX*edgeIntensityY;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Deform like old CRT, bulge in the middle\n    vec2 uv = deformUv(fragCoord/iResolution.xy);\n\t\n    // Take multiple samples to displace different color channels\n    vec4 sample1 = texture(iChannel0, vec2(uv.x-0.002,uv.y-0.001));\n\tvec4 sample2 = texture(iChannel0, uv);\n\tvec4 sample3 = texture(iChannel0, vec2(uv.x+0.002,uv.y+0.001));                           \n\tvec4 color = vec4(0.5*sample1.r+0.5*sample2.r, \n                      0.25*sample1.g+0.5*sample2.g+0.25*sample3.g, \n                      0.5*sample2.b+0.5*sample3.b, \n                      1.0);\n    \n    // Fade around the edges        \n    color.rgb *= edgeIntensity(uv);\n        \n    fragColor = color;\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"vec4 gridTexture(in vec2 uv)\n{\n    if(uv.y < 0.0)\n    {\n    \treturn vec4(0.0,0.0,0.0,0.0);\n    }\n    float thickness = 0.15;\n\tfloat speed = 1.5;\n    \n    float xPhase = mod(6.0*uv.x-speed*iTime*0.5f, 1.0);\n    float yPhase = mod(6.0*uv.y+speed*iTime, 1.0);\n            \n    float xIntensity = max(0.0, 1.0-abs(0.5-xPhase)/thickness);\n    float yIntensity = max(0.0, 1.0-abs(0.5-yPhase)/thickness);\n    \n    vec4 color = vec4(0.3, 0.7, 1.0, 1.0);\n    \n    vec4 result = (yIntensity+xIntensity)*color;\n\treturn result;\n}\n\nvec4 backgroundNoise(in vec2 uv)\n{\n    vec4 bottomColor = vec4(0.8, 0.2, 1.0, 1.0); \n    vec4 topColor = vec4(1.0, 0.0, 0.5, 1.0);\n    float intensity = 0.25;\n    \n    uv = uv*3.0;\n    uv.x += iTime*13.0;\n    uv.y += iTime*7.0;\n\tfloat noiseSample = texture(iChannel0, uv).r;\n    \n    vec4 result = bottomColor + noiseSample * topColor;\n    result.rgb *= intensity;\n \treturn result;   \n}\n/*\nvec4 mountain(in vec2 uv, in float seed, in float height, in float x)\n{\n    vec4 result = vec4(0.0,0.0,0.0,1.0);\n\tif(uv.y <= 0.45) \n    {\n    \treturn vec4(0.0,0.0,0.0,0.0);\n    }\n    else \n    {\n    \tfloat rand1 = texture(iChannel0, vec2((x + uv.x)/20.0, seed)).r;\n        float rand2 = texture(iChannel0, vec2((x + uv.x)/37.0, seed+0.2)).r;\n        float rand = height + (rand1+rand2)/4.0;\n        if(rand > uv.y)\n        {\n    \t\treturn vec4(1.0,1.0,1.0,1.0);    \n        }        \t        \n    }\n    return vec4(0.0,0.0,0.0,0.0);\n}\n*/\nfloat line(float center, float size, float edge, float y) {\n\treturn max(\n        max(\n        \tsmoothstep(center - size - edge, center - size, y) *\n            smoothstep(center + size + edge, center + size, y),\n        \tsmoothstep(center + size + edge - 1.0, center + size - 1.0, y)\n        ),\n        smoothstep(center - size + 1.0 - edge, center - size + 1.0, y)\n    );\n}\n\nvec4 sun(in vec2 uv)        \n{\n    \n    vec2 fragCoord = vec2(iResolution.x*uv.x,iResolution.y*uv.y);\n    vec2 texelSize = vec2(1.0 / iResolution.x, 1.0 / iResolution.y);\n    \n    vec2 sunCenter = vec2(0.5*iResolution.x,0.55*iResolution.y);\n    float sunRadius = 0.3 * iResolution.y;\n    float horizon = 0.42;\n\n    float bloomIntensity = 0.4;\n\tvec4 bloom = vec4(1.0, 1.0, 0.4, bloomIntensity);\n\tfloat bloomRadius = 1.4 * sunRadius;\n    \n    float dist = distance(fragCoord,sunCenter);\n    \n    // get a 0 -> 1 value within our sun \n    float sunValue = smoothstep(0.2, 0.63, uv.y-horizon*0.25f);\n    // line size increases the closer we are to the bottom of the sun\n    float lineSize = floor(mix(80.0, 0.0, sunValue)) * texelSize.y;\n\n    // line speed ( 1 - to make it go down)\n    float lineInt = 1.0 - fract(iTime * 0.5);\n    \n    // line count\n    float lineY = fract(uv.y * 14.0);\n    \n    // select our lines, invert so that active lines = 0\n    float lines = 1.0 - line(lineInt, lineSize, 0.05, lineY);\n    \n    // cutoff the top lines\n    lines = max(lines, step(0.75f, uv.y));\n    \n    vec4 color1 = vec4(1.0,1.0,0.0,1.0);\n    vec4 color2 = vec4(1.0,0.3,0.3,1.0);\n      \n    float intensity = 1.0 - (dist-sunRadius)/(bloomRadius-sunRadius);\n   \tbloom.a *= intensity*intensity;\n    \n    if(uv.y > horizon && dist < sunRadius)\n    {\n        vec4 sunColor = mix(color2, color1, 0.1+2.0*(uv.y-0.5));\n    \treturn mix((bloom*(lines+0.30f)), sunColor, lines);\n    }\n    else if(uv.y > horizon && dist < bloomRadius)\n    {\n        return (bloom*1.2f);\n    }\n       \n    \n    return vec4(0.0,0.0,0.0,0.0);\n    \n}\n\n// Get uv of the plane for laser texture\nvec2 planeProjection(in vec2 uv)\n{\n\tvec3 eye = vec3(0.0, -0.25, 0.0);\n    float viewPortZ = 0.5;\n    float viewPortH = 2.0;\n    float viewPortW = viewPortH * iResolution.x / iResolution.y;\n    vec2 center = vec2(viewPortW/2.0, viewPortH/2.0);\n    \n    vec2 dir = (vec2(uv.x*viewPortW, uv.y*viewPortH) - center) / viewPortZ; // (dx,dy) per unit of z \n    \n    \n    // Intersecting (x,z) plane in y=0.0\n    float zIntersect = eye.y / dir.y;\n    float xIntersect = zIntersect * dir.x;\n            \n    vec2 planeUv = vec2(xIntersect, zIntersect);\n\n    if(planeUv.y > 1.0)\n    {\n    \tplaneUv.y = -1.0;\n    }\n    \n    return planeUv;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 planeUv = planeProjection(uv);\n    vec4 sample1 = gridTexture(planeUv+vec2(iTime/8.0,0.01));\n    vec4 sample2 = gridTexture(planeUv+vec2(iTime/8.0,0.0));\n    vec4 sample3 = gridTexture(planeUv+vec2(iTime/8.0,-0.01));\n    vec4 gridColor = (0.5*sample1+sample2+0.5*sample3)/2.0;\n    vec4 bgColor = backgroundNoise(uv);    \n    /*vec4 mountainColor1 = mountain(uv, 0.0, 0.32, iTime/100.0);\n    vec4 mountainColor2 = mountain(uv, 0.25, 0.38, iTime/200.0);\n    vec4 mountainColor3 = mountain(uv, 0.6, 0.38, iTime/400.0);\n    if(mountainColor1.a > 0.5)\n    {\n\t\tbgColor.rgb *= 0.4;    \n    }\n    else if(mountainColor2.a > 0.5)\n    {\n\t\tbgColor.rgb *= 0.7;\n    }\n    else if(mountainColor3.a > 0.5)\n    {\n\t\tbgColor.rgb *= 0.85;\n    }    \n    else */\n    {\n    \tvec4 sunColor = sun(uv);\n      \tbgColor.rgb += sunColor.rgb * sunColor.a;\n    }\n    \n    fragColor = gridColor + bgColor;\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define PI 3.14159\n\nvec4 scanLine( in vec4 c, in float y ) \n{\n\tfloat scanLines = 280.0;\n    float intensity = 0.8 + 0.2 * sin(y * scanLines * 2.0*PI);\n    vec4 result = vec4(intensity * c.rgb, 1.0);\n    return result;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    \n    fragColor = texture(iChannel0, uv);\n    \n    fragColor = scanLine(fragColor, uv.y-iTime*0.01f);\n}    ","name":"Buffer A","description":"","type":"buffer"}]}