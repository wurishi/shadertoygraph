{"ver":"0.1","info":{"id":"MltSRf","date":"1480970947","viewed":494,"name":"Flower test","username":"TLC123","description":"ray marching flower\nRay marcher by Inigo Quilez\nI only made flower function\nadded comments","likes":22,"published":1,"flags":0,"usePreview":0,"tags":["raymarchingflower"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Created by inigo quilez - iq/2013\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// A list of usefull distance function to simple primitives, and an example on how to \n// do some interesting boolean operations, repetition and displacement.\n//\n// More info here: https://iquilezles.org/articles/distfunctions\n\nfloat sdPlane(vec3 p) {\n\treturn p.y;\n}\n\nfloat sdSphere(vec3 p, float s) {\n\treturn length(p) - s;\n}\n\nfloat sdBox(vec3 p, vec3 b) {\n\tvec3 d = abs(p) - b;\n\treturn min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));\n}\n\nfloat sdEllipsoid( in vec3 p, in vec3 r) {\n\treturn (length(p / r) - 1.0) * min(min(r.x, r.y), r.z);\n}\n\nfloat udRoundBox(vec3 p, vec3 b, float r) {\n\treturn length(max(abs(p) - b, 0.0)) - r;\n}\n\nfloat sdTorus(vec3 p, vec2 t) {\n\treturn length(vec2(length(p.xz) - t.x, p.y)) - t.y;\n}\n\n \n\nfloat sdCylinder(vec3 p, vec2 h) {\n\tvec2 d = abs(vec2(length(p.xz), p.y)) - h;\n\treturn min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\nfloat sdCone( in vec3 p, in vec3 c) {\n\tvec2 q = vec2(length(p.xz), p.y);\n\tfloat d1 = -q.y - c.z;\n\tfloat d2 = max(dot(q, c.xy), q.y);\n\treturn length(max(vec2(d1, d2), 0.0)) + min(max(d1, d2), 0.);\n}\n\nfloat sdConeSection( in vec3 p, in float h, in float r1, in float r2) {\n\tfloat d1 = -p.y - h;\n\tfloat q = p.y - h;\n\tfloat si = 0.5 * (r1 - r2) / h;\n\tfloat d2 = max(sqrt(dot(p.xz, p.xz) * (1.0 - si * si)) + q * si - r2, q);\n\treturn length(max(vec2(d1, d2), 0.0)) + min(max(d1, d2), 0.);\n}\n\nfloat length2(vec2 p) {\n\treturn sqrt(p.x * p.x + p.y * p.y);\n}\n\nfloat length6(vec2 p) {\n\tp = p * p * p;\n\tp = p * p;\n\treturn pow(p.x + p.y, 1.0 / 6.0);\n}\n\nfloat length8(vec2 p) {\n\tp = p * p;\n\tp = p * p;\n\tp = p * p;\n\treturn pow(p.x + p.y, 1.0 / 8.0);\n}\n\nfloat sdTorus82(vec3 p, vec2 t) {\n\tvec2 q = vec2(length2(p.xz) - t.x, p.y);\n\treturn length8(q) - t.y;\n}\n\nfloat sdTorus88(vec3 p, vec2 t) {\n\tvec2 q = vec2(length8(p.xz) - t.x, p.y);\n\treturn length8(q) - t.y;\n}\n\nfloat sdCylinder6(vec3 p, vec2 h) {\n\treturn max(length6(p.xz) - h.x, abs(p.y) - h.y);\n}\n\nfloat flower(vec3 p, float r) {\n\tfloat q = length(p);\n\tp -= vec3(sin(p.x * 15.1), sin(p.y * 25.1), sin(p.z * 15.0)) * 0.01; //some space warping\n\tvec3 n = normalize(p);\n\tq = length(p); // distance before flowerwarp\n\n\tfloat rho = atan(length(vec2(n.x, n.z)), n.y) * 20.0 + q * 15.01; //vertical part of  cartesian to polar with some q warp\n\tfloat theta = atan(n.x, n.z) * 6.0 + p.y * 3.0 + rho * 1.50; //horizontal part plus some warp by z(bend up) and by rho(twist)\n\treturn length(p) - (r + sin(theta) * 0.3 * (1.3 - abs(dot(n, vec3(0, 1, 0)))) //the 1-abs(dot()) is limiting the warp effect at poles\n\t\t+ sin(rho - iTime * 2.0) * 0.3 * (1.3 - abs(dot(n, vec3(0, 1, 0))))); // 1.3-abs(dot()means putting some back in \n}\n\nfloat TTorus(vec3 p, vec2 t) {\n\tvec2 q = vec2(length(p.xz) - t.x, p.y);\n\treturn length(q) - t.y;\n}\n\nfloat ChamferBox(vec3 p, vec3 b, float ch) {\n\tp = max(abs(p) - b, 0.0); // + vec3(ch, ch, ch);\n\tif ((p.x - ch) > (p.y + p.z)) {\n\t\treturn length(p - vec3(ch, 0, 0));\n\t}\n\telse if ((p.y - ch) > (p.x + p.z)) {\n\t\treturn length(p - vec3(0, ch, 0));\n\t}\n\telse if ((p.z - ch) > (p.y + p.x)) {\n\t\treturn length(p - vec3(0, 0, ch));\n\t}\n\telse {\n\t\treturn\n\t\tmax(dot(vec3(0.57735, 0.57735, 0.57735), p) / 0.7967329 - ch * 0.7967329,\n\t\t\tmax(dot(vec3(0.0, 0.707107, 0.707107), p) - ch * 0.7967329,\n\t\t\t\tmax(dot(vec3(0.707107, 0.0, 0.707107), p) - ch * 0.7967329,\n\t\t\t\t\tdot(vec3(0.707107, 0.707107, 0.0), p) - ch * 0.7967329))) + 0.005;\n\t}\n}\n//----------------------------------------------------------------------\n\nfloat opS(float d1, float d2) {\n\treturn max(-d2, d1);\n}\n\nvec2 opU(vec2 d1, vec2 d2) {\n\treturn (d1.x < d2.x) ? d1 : d2;\n}\n\nvec3 opRep(vec3 p, vec3 c) {\n\treturn mod(p, c) - 0.5 * c;\n}\n\nvec3 opTwist(vec3 p) {\n\tfloat c = cos(10.0 * p.y + 10.0);\n\tfloat s = sin(10.0 * p.y + 10.0);\n\tmat2 m = mat2(c, -s, s, c);\n\treturn vec3(m * p.xz, p.y);\n}\n\n//----------------------------------------------------------------------\n\nvec2 map( in vec3 pos) {\n\n\treturn vec2(flower(pos, 0.750), 15.1);\n\n}\n\nvec2 castRay( in vec3 ro, in vec3 rd) {\n\tfloat tmin = 1.0;\n\tfloat tmax = 20.0;\n\n\t#if 0\n    {\n        float tp1 = (0.0 - ro.y) / rd.y;\n\tif (tp1 > 0.0) tmax = min(tmax, tp1);\n\tfloat tp2 = (1.6 - ro.y) / rd.y;\n\tif (tp2 > 0.0) {\n\t\tif (ro.y > 1.6) tmin = max(tmin, tp2);\n\t\telse tmax = min(tmax, tp2);\n\t}\n    #\tendif\n\n\tfloat precis = 0.1;\n\tfloat t = tmin;\n\tfloat m = -1.0;\n\tfor (int i = 0; i < 400; i++) {\n\t\tvec2 res = map(ro + rd * t);\n\t\tif (res.x < precis || t > tmax) break;\n\t\tt += res.x * 0.05;\n\t\tm = res.y;\n\t}\n\n\tif (t > tmax) m = -1.0;\n\treturn vec2(t, m);\n}\n\nfloat softshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax) {\n\tfloat res = 1.0;\n\tfloat t = mint;\n\tfor (int i = 0; i < 16; i++) {\n\t\tfloat h = map(ro + rd * t).x;\n\t\tres = min(res, 8.0 * h / t);\n\t\tt += clamp(h, 0.02, 0.10);\n\t\tif (h < 0.001 || t > tmax) break;\n\t}\n\treturn clamp(res, 0.0, 1.0);\n\n}\n\nvec3 calcNormal( in vec3 pos) {\n\tvec3 eps = vec3(0.001, 0.0, 0.0);\n\tvec3 nor = vec3(\n\t\tmap(pos + eps.xyy).x - map(pos - eps.xyy).x,\n\t\tmap(pos + eps.yxy).x - map(pos - eps.yxy).x,\n\t\tmap(pos + eps.yyx).x - map(pos - eps.yyx).x);\n\treturn normalize(nor);\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor) {\n\tfloat occ = 0.0;\n\tfloat sca = 1.0;\n\tfor (int i = 0; i < 15; i++) {\n\t\tfloat hr = 0.05 + 0.12 * float(i) / 4.0;\n\t\tvec3 aopos = nor * hr + pos;\n\t\tfloat dd = map(aopos).x;\n\t\tocc += -(dd - hr) * sca;\n\t\tsca *= 0.95;\n\t}\n\treturn clamp(1.0 - 3.0 * occ, 0.0, 1.0);\n}\n\nvec3 render( in vec3 ro, in vec3 rd) {\n\tvec3 col = vec3(0.7, 0.9, 1.0) + rd.y * 0.8;\n\tvec2 res = castRay(ro, rd);\n\tfloat t = res.x;\n\tfloat m = res.y;\n\tif (m > -0.5) {\n\t\tvec3 pos = ro + t * rd;\n\t\tvec3 nor = calcNormal(pos);\n\t\tvec3 ref = reflect(rd, nor);\n\n\t\t// material        \n\t\tcol = 0.50 + 0.3 * sin(vec3(2.3 - pos.y / 2.0, 2.15 - pos.y / 4.0, -1.30) * (m - 1.0));\n\n\t\tif (m < 1.5) {\n\n\t\t\tfloat f = mod(floor(5.0 * pos.z) + floor(5.0 * pos.x), 2.0);\n\t\t\tcol = 0.4 + 0.1 * f * vec3(1.0);\n\t\t}\n\n\t\t// lighitng        \n\t\tfloat occ = calcAO(pos, nor);\n\t\tvec3 lig = normalize(vec3(-0.6, 0.7, -0.5));\n\t\tfloat amb = 0.0; // clamp( 0.5+0.5*nor.y, 0.0, 1.0 );\n\t\tfloat dif = clamp(dot(nor, lig), 0.0, 1.0);\n\t\tfloat bac = 0.0; // clamp( dot( nor, normalize(vec3(-lig.x,0.0,-lig.z))), 0.0, 1.0 )*clamp( 1.0-pos.y,0.0,1.0);\n\t\tfloat dom = smoothstep(-0.1, 0.1, ref.y);\n\t\tfloat fre = 0.750; //pow( clamp(1.0+dot(nor,rd),0.0,1.0), 2.0 );\n\t\tfloat spe = 0.0; //pow(clamp( dot( ref, lig ), 0.0, 1.0 ),16.0);\n\n\t\t//dif *= softshadow( pos, lig, 0.02, 2.5 );\n\t\t//dom *= softshadow( pos, ref, 0.02, 2.5 );\n\n\t\tvec3 lin = vec3(0.0);\n\t\tlin += 1.20 * dif * vec3(1.00, 0.85, 0.55);\n\t\tlin += 1.20 * spe * vec3(1.00, 0.85, 0.55) * dif;\n\t\tlin += 0.20 * amb * vec3(0.50, 0.70, 1.00) * occ;\n\t\tlin += 0.30 * dom * vec3(0.50, 0.70, 1.00) * occ;\n\t\tlin += 0.30 * bac * vec3(0.25, 0.25, 0.25) * occ;\n\t\tlin += 0.40 * fre * vec3(1.00, 1.00, 1.00) * occ;\n\t\tcol = col * lin;\n\n\t\tcol = mix(col, vec3(0.8, 0.9, 1.0), 1.0 - exp(-0.002 * t * t));\n\n\t}\n\n\treturn vec3(clamp(col, 0.0, 1.0));\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr) {\n\tvec3 cw = normalize(ta - ro);\n\tvec3 cp = vec3(sin(cr), cos(cr), 0.0);\n\tvec3 cu = normalize(cross(cw, cp));\n\tvec3 cv = normalize(cross(cu, cw));\n\treturn mat3(cu, cv, cw);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\tvec2 q = fragCoord.xy / iResolution.xy;\n\tvec2 p = -1.0 + 2.0 * q;\n\tp.x *= iResolution.x / iResolution.y;\n\tvec2 mo = iMouse.xy / iResolution.xy;\n\n\tfloat time = 15.0 + iTime * 3.0;\n\n\t// camera\t\n\tvec3 ro = vec3(0.0, 3.5 * cos(0.1 * -time), 4.0);\n\n\t//vec3( -0.5+3.5*cos(0.1*time + 6.0*mo.x),1.0+3.5*sin(6.0* mo.y), 0.0 + 3.5*sin(0.1*time + 6.0*mo.x)-3.5*cos(  6.0*-mo.y) );\n\tvec3 ta = vec3(-0.1, 0, 0.10);\n\n\t// camera-to-world transformation\n\tmat3 ca = setCamera(ro, ta, 0.0);\n\n\t// ray direction\n\tvec3 rd = ca * normalize(vec3(p.xy, 2.0));\n\n\t// render\t\n\tvec3 col = render(ro, rd);\n\n\tcol = pow(col, vec3(0.4545));\n\n\tfragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}