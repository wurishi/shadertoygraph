{"ver":"0.1","info":{"id":"sdjcDy","date":"1644970851","viewed":272,"name":"Concept of Great Wall (WFC)","username":"qubailiang00","description":"A WFC test, Happy Chinese New Yearï¼","likes":18,"published":1,"flags":32,"usePreview":0,"tags":["procedural","3d","raymarching","sdf","wfc"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define Far 10000.0\n\nstruct Ray\n{\n    vec3 ro;\n    vec3 rd;\n    float t;\n};\n\nstruct Material\n{\n    float idType;\n    vec3 albedo;\n    float roughness;\n    vec3 emissive;\n    vec3 specular;\n};\n\nstruct MarchingInfo\n{\n    float hit;\n    Material material;\n};\n\nstruct SurfGeoInfo\n{\n    vec3 pos;\n    vec3 coord;\n    vec3 normal;\n};\n\nstruct HitSurfInfo\n{\n    SurfGeoInfo geoInfo;\n    Material material;\n};\n\n// init\nvoid setRay(inout Ray ray, vec3 ro, vec3 rd, float t) {\n\n    ray.ro = ro;\n    ray.rd = rd;\n    ray.t = t;\n}\n\nRay setRay(vec3 ro, vec3 rd, float t) {\n\n    Ray ray;\n    ray.ro = ro;\n    ray.rd = rd;\n    ray.t = t;\n    return ray;\n}\n\nMaterial setMaterialInfo(float idType, vec3 albedo, float roughness, vec3 emissive, vec3 specular) {\n\n    Material info;\n    info.idType = idType;\n    info.albedo = albedo;\n    info.roughness = roughness;\n    info.emissive = emissive;\n    info.specular = specular;\n    return info;\n}\n\nMaterial setMaterialInfo(Material material) {\n\n    Material info;\n    info.idType = material.idType;\n    info.albedo = material.albedo;\n    info.roughness = material.roughness;\n    info.emissive = material.emissive;\n    info.specular = material.specular;\n    return info;\n}\n\nMaterial initMaterialInfo() {\n\n    Material matInfo;\n    matInfo.albedo = vec3(0.0);\n    matInfo.roughness = 0.1;\n    matInfo.emissive = vec3(0.0);\n    matInfo.specular = vec3(0.5);\n\n    return matInfo;\n}\n\nvec2 boundingBox(in vec3 ro, in vec3 rd, in vec3 k) {\n\n    vec3 a = ro / rd;\n    vec3 b = k / abs(rd);\n    vec3 t1 = -a - b;\n    vec3 t2 = -a + b;\n\n    float n = max(max(t1.x, t1.y), t1.z);\n    float f = min(min(t2.x, t2.y), t2.z);\n\t\n    if(n > f || f < 0.0) return vec2(-1.0); \n    return vec2(n, f);\n}\n\nfloat opUn(float d1, float d2) {  return min(d1, d2); }\nfloat opSub(float d1, float d2) { return max(d1, -d2); }\nfloat opInter(float d1, float d2) { return max(d1, d2); }\n\nmat2 rot(float a) {\n    \n    float c = cos(a);\n    float s = sin(a);\n    return mat2(c, s, -s, c);\n}\n\nfloat sdSphere(vec3 p, float s) {\n\n    return length(p) - s;\n}\n\nfloat sdCube(vec3 p, vec3 b) {\n\n    vec3 d = abs(p) - b;\n    return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));\n}\n\nfloat sCCyl(vec3 p, float r, float h) {\n\n    vec2 d = abs(vec2(length(p.xz), p.y)) - vec2(r, h);\n    return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\nfloat IwallConfiguration(vec3 p){\n\n    vec3 p0 = p;\n    p0.y += 0.425;\n\n    float f = sdCube(p0, vec3(0.3, 0.075, 0.5));\n\n    vec3 p1 = p;\n    p1.x = abs(p.x);\n    p1.x -= 0.25;\n    p1.y += 0.3;\n    f = opUn(f, sdCube(p1, vec3(0.04, 0.05, 0.5)));\n    \n    p1.y -= 0.07;\n    f = opUn(f, sdCube(p1, vec3(0.05, 0.05, 0.0625)));\n\n    p1.z = abs(p1.z);\n    p1.z -= 0.25;\n    f = opUn(f, sdCube(p1, vec3(0.05, 0.05, 0.0625)));\n\n    p1.z -= 0.25 - 0.0625 / 2.0;\n    f = opUn(f, sdCube(p1, vec3(0.05, 0.05, 0.0625 / 2.0)));\n\n    // p1.z += 0.75;\n    // f = opUn(f, sdCube(p1, vec3(0.05, 0.05, 0.0625)));\n\n    // p1.z += 0.25;\n    // f = opUn(f, sdCube(p1, vec3(0.05, 0.05, 0.0625)));\n\n    // p.y += 0.5;\n    // float f = sdCube(p, vec3(0.3, 0.05, 0.5));\n    // f = opUn(f, sdCube(p - vec3(0.25, 0.18, 0.0), vec3(0.025, 0.15, 0.025)));\n    // f = opUn(f, sdCube(p - vec3(-0.25, 0.18, 0.0), vec3(0.025, 0.15, 0.025)));\n\n    // f = opSub(f, sdCube(p - vec3(1.0, 0.0, 0.0), vec3(0.5)));\n    // f = opSub(f, sdCube(p - vec3(0.0, 0.0, -1.0), vec3(0.5)));\n    // f = opSub(f, sdCube(p - vec3(-1.0, 0.0, 0.0), vec3(0.5)));\n    // f = opSub(f, sdCube(p - vec3(0.0, 0.0, 1.0), vec3(0.5)));\n    // for(float i = 1.0; i < 2.5; i += 1.0){\n\n    //     f = opUn(f, sdCube(p - vec3(0.25, 0.18, -0.2 * i), vec3(0.025, 0.15, 0.025)));\n    //     f = opUn(f, sdCube(p - vec3(-0.25, 0.18, -0.2 * i), vec3(0.025, 0.15, 0.025)));\n    //     f = opUn(f, sdCube(p - vec3(-0.25, 0.18, 0.2 * i), vec3(0.025, 0.15, 0.025)));\n    //     f = opUn(f, sdCube(p - vec3(0.25, 0.18, 0.2 * i), vec3(0.025, 0.15, 0.025)));\n    // }\n    return f;\n}\n\nfloat gate(vec3 p, float f){\n\n    vec3 p0 = p;\n    p0.y += 0.425;\n\n    f = opUn(f, sdCube(p0 - vec3(0.0, 0.4, 0.0), vec3(0.3, 0.3, 0.3)));\n    f = opSub(f, sdCube(p0 - vec3(0.0, 0.8, 0.0), vec3(0.25)));\n\n    p0 = abs(p0);\n    f = opSub(f, sdCube(p0 - vec3(0.0, 0.75, 0.0), vec3(0.04, 0.1, 0.5)));\n    //f = opSub(f, sdCube(p0 - vec3(-0.15, 0.75, 0.0), vec3(0.04, 0.1, 0.5)));\n    f = opSub(f, sdCube(p0 - vec3(0.15, 0.75, 0.0), vec3(0.04, 0.1, 0.5)));\n\n    f = opSub(f, sdCube(p0 - vec3(0.17, 0.4, 0.0), vec3(0.02, 0.02, 0.5)));\n\n    p0.xz = rot(3.1416 / 2.0) * p.xz;\n    p0 = abs(p0);\n\n    f = opSub(f, sdCube(p0 - vec3(0.17, 0.4, 0.0), vec3(0.02, 0.02, 0.5)));\n\n\n    f = opSub(f, sdCube(p0 - vec3(0.0, 0.75, 0.0), vec3(0.04, 0.1, 0.5)));\n    // f = opSub(f, sdCube(p0 - vec3(-0.15, 0.75, 0.0), vec3(0.04, 0.1, 0.5)));\n    f = opSub(f, sdCube(p0 - vec3(0.15, 0.75, 0.0), vec3(0.04, 0.1, 0.5)));\n\n    f = opSub(f, sdCube(p0 - vec3(0.0, 0.2, 0.0), vec3(0.1, 0.1, 0.5)));\n    p0.xz = p.xz;\n    f = opSub(f, sdCube(p0 - vec3(0.0, 0.2, 0.0), vec3(0.1, 0.1, 0.5)));\n\n    vec3 p1 = p;\n    p1.yz = rot(3.1416 / 2.0) * p.yz;\n    f = opSub(f, sCCyl(p1 - vec3(0.0, 0.0, -0.14), 0.1, 0.5));\n    p1.xy = rot(3.1416 / 2.0) * p.xz;\n    f = opSub(f, sCCyl(p1 - vec3(0.0, 0.0, -0.14), 0.1, 0.5));\n\n    // vec3 p0 = p;\n    // float f = sdCube(p - vec3(0.0, 0.25, 0.0), vec3(0.3, 0.25, 0.3));\n    // p0.yz = rot(3.1416 / 2.0) * p.yz;\n    // f = opSub(f, sCCyl(p0 - vec3(0.0, 0.0, 0.25), 0.2, 0.4));\n    // p0.xy = rot(3.1416 / 2.0) * p.xz;\n    // f = opSub(f, sCCyl(p0 - vec3(0.0, 0.0, 0.25), 0.2, 0.4));\n    return f;\n}\n\nfloat IgateTowerConfiguration(vec3 p){\n\n    //p.y += 0.5;\n    float f = IwallConfiguration(p);//sdCube(p, vec3(0.3, 0.05, 0.5));\n    f = gate(p, f);\n   \n    // f = opUn(f, sdCube(p - vec3(0.0, 0.25, 0.0), vec3(0.3, 0.25, 0.3)));\n    // p0.yz = rot(3.1416 / 2.0) * p.yz;\n    // f = opSub(f, sCCyl(p0 - vec3(0.0, 0.0, 0.25), 0.2, 0.4));\n    // p0.xy = rot(3.1416 / 2.0) * p.xz;\n    // f = opSub(f, sCCyl(p0 - vec3(0.0, 0.0, 0.25), 0.2, 0.4));\n    return f;\n}\n\nfloat LwallConfiguration(vec3 p){\n\n    vec3 p0 = p;\n    p0 -= vec3(0.0, 0.0, -0.2);\n    float f = IwallConfiguration(p0);\n\n    p0 = p;\n    p0.xz = rot(3.1416 / 2.0) * p.xz;\n    p0 -= vec3(0.0, 0.0, 0.2);\n    f = opUn(f, IwallConfiguration(p0));\n\n    f = opSub(f, sdCube(p - vec3(0.0, -0.25, -0.1), vec3(0.21, 0.1, 0.3)));\n    p0 = p;\n    p0.xz = rot(3.1416 / 2.0) * p.xz;\n    f = opSub(f, sdCube(p0 - vec3(0.0, -0.25, 0.1), vec3(0.21, 0.1, 0.3)));\n\n    f = opSub(f, sdCube(p - vec3(1.0, 0.0, 0.0), vec3(0.5)));\n    f = opSub(f, sdCube(p - vec3(0.0, 0.0, -1.0), vec3(0.5)));\n\n    // p.xz = rot(3.1416 * 1.5) * p.xz;\n    // p.y += 0.5;\n    // vec3 p0 = p;\n    // p0.z += 0.1;\n    // float f = sdCube(p0, vec3(0.3, 0.05, 0.4));\n    // p0.xz = rot(3.1416 / 2.0) * p.xz;\n    // f = opUn(f, sdCube(p0 - vec3(0.0, 0.0, -0.1), vec3(0.3, 0.05, 0.4)));\n\n    // f = opUn(f, sdCube(p - vec3(0.25, 0.18, 0.25), vec3(0.025, 0.15, 0.025)));\n    // f = opUn(f, sdCube(p - vec3(0.05, 0.18, 0.25), vec3(0.025, 0.15, 0.025)));\n    // f = opUn(f, sdCube(p - vec3(-0.15, 0.18, 0.25), vec3(0.025, 0.15, 0.025)));\n    // f = opUn(f, sdCube(p - vec3(-0.35, 0.18, 0.25), vec3(0.025, 0.15, 0.025)));\n    // f = opUn(f, sdCube(p - vec3(0.25, 0.18, 0.05), vec3(0.025, 0.15, 0.025)));\n    // f = opUn(f, sdCube(p - vec3(0.25, 0.18, -0.15), vec3(0.025, 0.15, 0.025)));\n    // f = opUn(f, sdCube(p - vec3(0.25, 0.18, -0.35), vec3(0.025, 0.15, 0.025)));\n    return f;\n}\n\nfloat LgateTowerConfiguration(vec3 p){\n\n    float f = LwallConfiguration(p);\n\n    // p.xz = rot(3.1416 * 1.5) * p.xz;\n    // //p.y += 0.5;\n    // vec3 p0 = p;\n    // p0.y += 0.5;\n    // p0.z += 0.1;\n    // float f = sdCube(p0, vec3(0.3, 0.05, 0.4));\n    // p0.xz = rot(3.1416 / 2.0) * p.xz;\n    // f = opUn(f, sdCube(p0 - vec3(0.0, 0.0, -0.1), vec3(0.3, 0.05, 0.4)));\n    //f = opUn(f, gate(p));\n    f = gate(p, f);\n    return f;\n}\n\nfloat TwallConfiguration(vec3 p){\n\n    vec3 p0 = p;\n    p0 -= vec3(0.0, 0.0, -0.2);\n    float f = IwallConfiguration(p0);\n\n    p0 = p;\n    p0.xz = rot(3.1416 / 2.0) * p.xz;\n    //p0 -= vec3(0.0, 0.0, 0.2);\n    f = opUn(f, IwallConfiguration(p0));\n\n    f = opSub(f, sdCube(p - vec3(0.0, -0.25, -0.1), vec3(0.21, 0.1, 0.3)));\n    p0 = p;\n    p0.xz = rot(3.1416 / 2.0) * p.xz;\n    f = opSub(f, sdCube(p0 - vec3(0.0, -0.25, 0.0), vec3(0.21, 0.1, 0.5)));\n\n    f = opSub(f, sdCube(p - vec3(0.0, 0.0, -1.0), vec3(0.5)));\n\n    // vec3 p0 = p;\n    // p0.y += 0.5;\n\n    // p0.z += 0.1;\n    // float f = sdCube(p0, vec3(0.3, 0.05, 0.4));\n    // p0.xz = rot(3.1416 / 2.0) * p.xz;\n    // f = opUn(f, sdCube(p0, vec3(0.3, 0.05, 0.5)));\n    return f;\n}\n\nfloat obtainStairsConfiguration(vec3 p){\n\n    //p.xz = rot(3.1416) * p.xz;\n    //p.z = -p.z;\n    p.y -= 0.45;\n    float f = sdCube(p - vec3(0.0, 0.0, 0.45), vec3(0.3, 0.05, 0.05));\n    for(float i = 1.0; i < 9.5; i += 1.0) {\n\n        f = opUn(f, sdCube(p + vec3(0.0, 0.1 * i, -0.45 + i * 0.1), vec3(0.3, 0.05, 0.05)));\n    }\n    return f;\n}\n\nfloat obtainStairsConfiguration2(vec3 p){\n\n    //p.xz = rot(3.1416) * p.xz;\n    //p.z = -p.z;\n    p.y -= 0.45;\n    float f = sdCube(p - vec3(0.0, 0.0, 0.45), vec3(0.3, 0.05, 0.05));\n    for(float i = 1.0; i < 9.5; i += 1.0)\n    f = opUn(f, sdCube(p + vec3(0.15, 0.1 * i, -0.45 + i * 0.1), vec3(0.15, 0.05, 0.05)));\n    f = opUn(f, sdCube(p - vec3(0.15, -0.95, 0.0), vec3(0.15, 0.05, 0.5)));\n    return f;\n}\n\nMarchingInfo unionSDF(MarchingInfo infoA, MarchingInfo infoB) {\n\n    //return infoA.hit < infoB.hit ? infoA : infoB;\n    if(infoA.hit < infoB.hit) return infoA;\n    return infoB;\n}\n\nMarchingInfo sdBallObj(vec3 pos) {\n\n    MarchingInfo info;\n    info.hit = sdSphere(pos, 0.44);\n    info.material = setMaterialInfo(0.0, vec3(0.75, 0.12, 0.16), 0.1, vec3(0.0), vec3(0.0));\n    return info;\n}\n\nMarchingInfo sdBoxObj(vec3 pos) {\n\n    MarchingInfo info;\n    info.hit = sdCube(pos, vec3(0.35, 0.1, 0.3));\n    info.material =setMaterialInfo(0.0, vec3(0.5, 0.6, 0.97), 0.1, vec3(0.0), vec3(0.0));\n    return info;\n}\n\nMarchingInfo IrampartObj(vec3 pos) {\n\n    MarchingInfo info;\n    info.hit = IwallConfiguration(pos);\n    info.material = setMaterialInfo(0.0, vec3(0.75, 0.12, 0.16), 0.1, vec3(0.0), vec3(0.0));\n    return info;\n}\n\nMarchingInfo IgateTowerObj(vec3 pos) {\n\n    MarchingInfo info;\n    info.hit = IgateTowerConfiguration(pos);\n    info.material = setMaterialInfo(0.0, vec3(0.75, 0.12, 0.16), 0.1, vec3(0.0), vec3(0.0));\n    return info;\n}\n\nMarchingInfo LrampartObj(vec3 pos) {\n\n    MarchingInfo info;\n    info.hit = LwallConfiguration(pos);\n    info.material = setMaterialInfo(0.0, vec3(0.75, 0.12, 0.16), 0.1, vec3(0.0), vec3(0.0));\n    return info;\n}\n\nMarchingInfo LgateTowerObj(vec3 pos) {\n\n    MarchingInfo info;\n    info.hit = LgateTowerConfiguration(pos);\n    info.material = setMaterialInfo(0.0, vec3(0.75, 0.12, 0.16), 0.1, vec3(0.0), vec3(0.0));\n    return info;\n}\n\nMarchingInfo TrampartObj(vec3 pos) {\n\n    MarchingInfo info;\n    info.hit = TwallConfiguration(pos);\n    info.material = setMaterialInfo(0.0, vec3(0.75, 0.12, 0.16), 0.1, vec3(0.0), vec3(0.0));\n    return info;\n}\n\nMarchingInfo StairsConfigurationObj(vec3 pos) {\n\n    MarchingInfo info;\n    info.hit = obtainStairsConfiguration(pos);\n    info.material = setMaterialInfo(0.0, vec3(0.75, 0.12, 0.16), 0.1, vec3(0.0), vec3(0.0));\n    return info;\n}\n\nMarchingInfo StairsConfigurationObj2(vec3 pos) {\n\n    MarchingInfo info;\n    info.hit = obtainStairsConfiguration2(pos);\n    info.material = setMaterialInfo(0.0, vec3(0.75, 0.12, 0.16), 0.1, vec3(0.0), vec3(0.0));\n    return info;\n}\n\nMarchingInfo sdBallEntity(vec3 pos) {\n\n    return sdBallObj(pos);\n}\n\nMarchingInfo sdBoxEntity(vec3 pos) {\n\n    return sdBoxObj(pos);\n}\n\nMarchingInfo IrampartEntity(vec3 pos) {\n\n    return IrampartObj(pos);\n}\n\nMarchingInfo IgateTowerEntity(vec3 pos) {\n\n    return IgateTowerObj(pos);\n}\n\nMarchingInfo LrampartEntity(vec3 pos) {\n\n    return LrampartObj(pos);\n}\n\nMarchingInfo LgateTowerEntity(vec3 pos) {\n\n    return LgateTowerObj(pos);\n}\n\nMarchingInfo TrampartEntity(vec3 pos) {\n\n    return TrampartObj(pos);\n}\n\nMarchingInfo StairsConfigurationEntity(vec3 pos) {\n\n    return StairsConfigurationObj(pos);\n}\n\nMarchingInfo StairsConfigurationEntity2(vec3 pos) {\n\n    return StairsConfigurationObj2(pos);\n}\n\nMarchingInfo sdfScene(vec3 pos, vec3 coord) {\n\n    MarchingInfo info;\n    info.hit = Far;\n    info.material = setMaterialInfo(0.0, vec3(0.5), 0.1, vec3(0.0), vec3(0.0));\n\n    vec3 data = texture(iChannel0, wtu(coord, iResolution)).rgb;\n    if(data.x < 0.0) return info;\n\n    float index = data.x;\n    float pose = data.y;\n\n    mat3 my = mat3(cos(3.1416 / 2.0 * pose), 0.0, -sin(3.1416 / 2.0 * pose),\n                  0.0, 1.0, 0.0, \n                  sin(3.1416 / 2.0 * pose), 0.0, cos(3.1416 / 2.0 * pose));\n    pos = pos * my;\n\n    if(index > 6.5) return info;//info = unionSDF(info, sdBoxEntity(pos));\n    else if(index > 5.5) info = unionSDF(info, TrampartEntity(pos));\n    else if(index > 4.5) info = unionSDF(info, StairsConfigurationEntity2(pos));\n    else if(index > 3.5) info = unionSDF(info, StairsConfigurationEntity(pos));//unionSDF(info, TrampartEntity(pos));\n    else if(index > 2.5) info = unionSDF(info, LgateTowerEntity(pos));\n    else if(index > 1.5) info = unionSDF(info, LrampartEntity(pos));\n    else if(index > 0.5) info = unionSDF(info, IgateTowerEntity(pos));\n    else info = unionSDF(info, IrampartEntity(pos));//unionSDF(info, sdBoxEntity(pos));//\n\n    return info;\n}\n\nMarchingInfo sdfScene(inout Ray ray) {\n\n    vec3 pos = ray.ro + ray.rd * ray.t;\n    vec3 coord = floor(pos);\n    pos = pos - coord - vec3(0.5);\n    return sdfScene(pos, coord);\n}\n\nvec3 calcNormal(in Ray ray) {\n    \n    vec2 e = vec2(1.0, -1.0) * 0.5773;\n    const float eps = 0.00025;\n    //vec3 v[4] = vec3[](e.xyy, e.yyx, e.yxy, e.xxx);\n\n    Ray r = ray;\n    vec3 res = vec3(0.0);\n    // for(int i = 0; i < 4; i++) {\n\n    //     r.ro = ray.ro + v[i] * eps;\n    //     res += sdfScene(r).hit * v[i];\n    // }\n\n    {\n        r.ro = ray.ro + e.xyy * eps;\n        res += sdfScene(r).hit * e.xyy;\n    }\n\n    {\n        r.ro = ray.ro + e.yyx * eps;\n        res += sdfScene(r).hit * e.yyx;\n    }\n    \n    {\n        r.ro = ray.ro + e.yxy * eps;\n        res += sdfScene(r).hit * e.yxy;\n    }\n    \n    {\n        r.ro = ray.ro + e.xxx * eps;\n        res += sdfScene(r).hit * e.xxx;\n    }\n\n\n    return normalize(res);\n}\n\n\nHitSurfInfo intersect(inout Ray ray) {\n\n    HitSurfInfo hitInfo;\n    SurfGeoInfo geoInfo;\n\n    Ray r = ray;\n    r.ro.x -= _dims.x * 0.5;\n    r.ro.y -= _dims.y * 0.5;\n    r.ro.z -= _dims.z * 0.5;\n\n    vec2 b = boundingBox(r.ro, r.rd, _dims * 0.5 - 0.001);\n\n\tif(b.y > 0.0) {\n\n        ray.t = max(b.x, 0.001);\n\n    \tgeoInfo.pos = ray.ro + ray.rd * ray.t;\n        geoInfo.coord = floor(geoInfo.pos);\n\n        for(int i = 0; i < 128 && ray.t < b.y; i++) {\n\n            vec3 p = geoInfo.pos - geoInfo.coord - vec3(0.5);\n\n            MarchingInfo info = sdfScene(p, geoInfo.coord);\n            if(info.hit < 0.001 && info.hit > -0.0001) {\n\n                hitInfo.geoInfo = geoInfo;\n                hitInfo.geoInfo.normal = calcNormal(ray);\n                hitInfo.material = info.material;\n                return hitInfo;\n            }\n\n            float t = ray.t + info.hit;\n            vec3 pos = ray.ro + ray.rd * t;\n            vec3 coord = floor(pos);\n            vec3 tmp = coord - geoInfo.coord;\n            if(dot(tmp, tmp) > 0.05) {\n                \n                ray.t += boundingBox(p, ray.rd, vec3(0.5)).y + 0.01;\n                geoInfo.pos = ray.ro + ray.rd * ray.t;\n                geoInfo.coord = floor(geoInfo.pos);\n            }\n            else {\n\n                ray.t = t;\n                geoInfo.pos = pos;\n            }\n        }\n        //hitInfo.geoInfo = geoInfo;\n        //hitInfo.geoInfo.normal = calcNormal(ray);\n        //.material = setMaterialInfo(11.0, vec3(0.5, 0.2, 1.0), 0.1, vec3(0.0), vec3(0.0));\n        //return hitInfo;\n    }\n\n    hitInfo.material = setMaterialInfo(12.0, vec3(0.89, 0.4, 0.416), 0.1, vec3(0.0), vec3(0.0));\n    return hitInfo;\n}\n\n\nvec3 render(Ray ray) {\n\n    HitSurfInfo info = intersect(ray);\n    if(info.material.idType > 10.0) return info.material.albedo;\n    vec3 n = info.geoInfo.normal;\n    \n    vec3 light = normalize(vec3(0.8, 10.2, 1.6));\n    vec3 lightPos = vec3(0.0, 15.0, 10.0);\n    vec3 spec = info.material.albedo * max(dot(n, normalize(normalize(lightPos - info.geoInfo.pos) - ray.rd)), 0.0);\n\n    vec3 a = (n + vec3(1.0)) / 2.0;\n    return spec + a * info.material.albedo * 0.2;\n}\n\nvoid setCamera(vec4 mouse, inout Ray ray){\n\n    vec2 mo = mouse.xy / iResolution.xy;\n    float x = -(mo.x * 2.0 - 1.0) * PI;\n    float y = (mo.y * 2.0 - 1.0) * 1.5707963268;\n    mat4 my = mat4(cos(x), 0.0, sin(x), 0.0,\n                  0.0, 1.0, 0.0, 0.0,\n                  -sin(x), 0.0, cos(x), 0.0,\n                  0.0, 0.0, 0.0, 1.0);\n\n    mat4 mx = mat4(1.0, 0.0, 0.0, 0.0,\n                  0.0, cos(y), -sin(y), 0.0,\n                  0.0, sin(y), cos(y), 0.0,\n                  0.0, 0.0, 0.0, 1.0);\n\n    ray.ro = (my * mx * vec4(ray.ro, 1.0)).xyz;\n\n    ray.ro -= vec3(-_dims.x * 0.5, 0.0, -_dims.z * 0.5);\n    ray.rd = (my * mx * vec4(ray.rd, 0.0)).xyz;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n    vec2 uv = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n    \n    Ray ray;\n    vec3 o = vec3(0.0, 0.0, -18.0);\n    vec3 d = normalize(vec3(uv, -16.3) - o);\n    setRay(ray, o, d, Far);\n    \n    setCamera(iMouse, ray);\n\n    vec3 color = render(ray);\n\n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define SynapticType float\n#define none 0.0\n#define board 1.0\n#define dormer 2.0\n\n#define Up 0.0\n#define Down 1.0\n#define Left 2.0\n#define Right 3.0\n#define Front 4.0\n#define Back 5.0\n\nstruct Synapse\n{\n    SynapticType _up;\n    SynapticType _down;\n    SynapticType _left;\n    SynapticType _right;\n    SynapticType _front;\n    SynapticType _back;\n};\n\nuint wang_hash(inout uint seed) {\n\n    seed = uint(seed ^ uint(61)) ^ uint(seed >> uint(16));\n    seed *= uint(9);\n    seed = seed ^ (seed >> 4);\n    seed *= uint(0x27d4eb2d);\n    seed = seed ^ (seed >> 15);\n    return seed;\n}\n\nfloat randomFloat01(inout uint state) {\n\n    return float(wang_hash(state)) / 4294967296.0;\n}\n\nSynapse getSynapse(float c) {\n\n    Synapse synapse;\n    if(c > 6.5) {\n\n        synapse._up = none;\n        synapse._down = dormer;\n        synapse._left = none;\n        synapse._right = none;\n        synapse._front = board;\n        synapse._back = none;\n    }\n    else if(c > 5.5) {\n\n        synapse._up = none;\n        synapse._down = none;\n        synapse._left = board;\n        synapse._right = board;\n        synapse._front = none;\n        synapse._back = board;\n    }\n    else if(c > 4.5) {\n\n        synapse._up = dormer;\n        synapse._down = dormer;\n        synapse._left = none;\n        synapse._right = none;\n        synapse._front = board;\n        synapse._back = board;\n    }\n    else if(c > 3.5) {\n\n        synapse._up = dormer;\n        synapse._down = none;\n        synapse._left = none;\n        synapse._right = none;\n        synapse._front = none;\n        synapse._back = board;\n    }\n    else if(c > 2.5) {\n\n        synapse._up = none;\n        synapse._down = none;\n        synapse._left = none;\n        synapse._right = board;\n        synapse._front = none;\n        synapse._back = board;\n    }\n    else if(c > 1.5) {\n\n        synapse._up = none;\n        synapse._down = none;\n        synapse._left = none;\n        synapse._right = board;\n        synapse._front = none;\n        synapse._back = board;\n    }\n    else if(c > 0.5) {\n\n        synapse._up = none;\n        synapse._down = none;\n        synapse._left = none;\n        synapse._right = none;\n        synapse._front = board;\n        synapse._back = board;\n    }\n    else {\n\n        synapse._up = none;\n        synapse._down = none;\n        synapse._left = none;\n        synapse._right = none;\n        synapse._front = board;\n        synapse._back = board;\n    }\n    return synapse;\n}\n\nSynapse synapseRotate(Synapse synapse, float pose) {\n\n    Synapse s;\n    if(pose > 2.5) {\n\n        s._up = synapse._up;\n        s._down = synapse._down;\n        s._left = synapse._front;\n        s._right = synapse._back;\n        s._front = synapse._right;\n        s._back = synapse._left;\n    }\n    else if(pose > 1.5) {\n\n        s._up = synapse._up;\n        s._down = synapse._down;\n        s._left = synapse._right;\n        s._right = synapse._left;\n        s._front = synapse._back;\n        s._back = synapse._front;\n    }\n    else if(pose > 0.5) {\n\n        s._up = synapse._up;\n        s._down = synapse._down;\n        s._left = synapse._back;\n        s._right = synapse._front;\n        s._front = synapse._left;\n        s._back = synapse._right;\n    }\n    else {\n\n        s = synapse;\n    }\n    return s;\n}\n\nSynapticType getSynapticType(Synapse synapse, float dir) {\n\n    if(dir > 4.5) return synapse._back;\n    else if(dir > 3.5) return synapse._front;\n    else if(dir > 2.5) return synapse._right;\n    else if(dir > 1.5) return synapse._left;\n    else if(dir > 0.5) return synapse._down;\n    else return synapse._up;\n}\n\nint imod(int x, int y) {\n\n    int i = x / y;\n    return x - i * y;\n}\n\nbool getBit(int n, uint _fields) { return (_fields & (uint(1) << n)) != uint(0); }\nvoid unsetBit(int n, inout uint _fields) { _fields &= ~(uint(1) << n); }\n\nvoid tryEstablishSynapses(inout uint _fields, SynapticType synapticType, float pose, float dir) {\n\n    for(int i = 0; i < 32; i++) {\n\n        if (!getBit(i, _fields)) continue;\n        float state = float(i / 4);\n        float pose0 = float(imod(i, 4));\n        Synapse synapse = getSynapse(state);\n        synapse = synapseRotate(synapse, pose0);\n        SynapticType s = getSynapticType(synapse, dir);\n        if(abs(synapticType - s) > 0.5) unsetBit(i, _fields);\n        if(dir < 1.5 && abs(pose0 - pose) > 0.5) unsetBit(i, _fields);\n    }\n}\n\nint countBits(uint x) {\n\n    int localCount = 0;\n    for (; x != uint(0); x &= x - uint(1)) localCount++;\n    return localCount;\n}\n\nint find(int n, uint _fields) {\n\n    int count = 0;\n    for (int i = 0; i < 32; i++) if(getBit(i, _fields) && count++ == n) return i;\n    return -1;\n}\n\nvoid eliminationElement(int index, inout uint _fields) {\n\n    int x = index * 4;\n    for (int i = 0; i < 4; i++) unsetBit(i + x, _fields);\n}\n\nvoid reset(inout vec4 fragColor, in vec2 fragCoord, vec2 uv) {\n\n    uint random = uint(uint(fragCoord.x) * uint(1973) + uint(fragCoord.y) * uint(9277) + uint(iFrame) * uint(26699)) | uint(1);\n\n    float fx = mod(floor(randomFloat01(random) * _dims.x), _dims.x);\n    float fz = mod(floor(randomFloat01(random) * _dims.z), _dims.z);\n    vec2 v = wtu(vec3(fx, 0.0, fz), iResolution);\n    //vec2 v = wtu(vec3(5.0, 0.0, 7.0));\n    if(uv == v) {\n\n        float data = mod(floor(randomFloat01(random) * 20.0), 20.0);\n        float index = floor(data / 4.0);\n        float pose = mod(data, 4.0);\n        fragColor = vec4(index, pose, 0.0, 0.0);\n        return;\n    }\n    fragColor = vec4(-1.0, 1.0, 0.0, 0.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n    vec2 uv = fragCoord / iResolution.xy;\n    fragColor = vec4(-1.0);\n    if(iFrame < 1) return;\n\n    if(iFrame < 2 || imod(iFrame, 300) > 298) {\n\n        float data;\n        float index;\n        float pose;\n\n        //uint(9);//\n        //uint random = uint(uint(fragCoord.x) * uint(1973) + uint(fragCoord.y) * uint(9277) + uint(iFrame) * uint(26699)) | uint(1);\n        //uint random = uint(1);//uint(uint(fragCoord.x) * uint(1973) + uint(fragCoord.y) * uint(9277) + uint(iFrame) * uint(26699)) | uint(1);\n\n        //float tx = randomFloat01(random);\n        //float tz = randomFloat01(random);\n\n        //tx = ((tx * 2.0 - 1.0) * 0.7 + 1.0) * 0.5;\n        //tz = ((tz * 2.0 - 1.0) * 0.7 + 1.0) * 0.5;\n\n        // tx = tx * 2.0;\n        // tz = tz * 2.0;\n\n        //float fx = mod(floor(tx * _dims.x), _dims.x);\n        //float fz = mod(floor(tz * _dims.z), _dims.z);\n\n        //vec2 v = wtu(vec3(fx, 0.0, fz));\n        vec2 v = wtu(vec3(floor(_dims.x / 2.0), 0.0, floor(_dims.z / 2.0)), iResolution);\n        if(uv == v) {\n\n            data = 24.0;//mod(floor(randomFloat01(random) * 20.0), 20.0);\n\n            index = floor(data / 4.0);\n            pose = mod(data, 4.0);\n            fragColor = vec4(index, pose, 0.0, 0.0);\n            return;\n        }\n\n        return;\n    }\n\n    vec3 p = utw(uv, iResolution);\n    if(p.x < 0.0) return;\n\n    vec2 tex = texture(iChannel0, uv).rg;\n    if(tex.x > -0.5) {\n\n        fragColor = vec4(tex.x, tex.y, 0.0, 0.0);\n        return;\n    }\n\n    //*\n    uint _fields = ~uint(0);\n\n    bool token = false;\n\n    if(p.x > 0.5) {\n\n        vec3 p0 = p;\n        p0.x -= 1.0;\n        vec2 v = wtu(p0, iResolution);\n        vec2 t = texture(iChannel0, v).rg;\n        if(t.x > -0.5) {\n\n            Synapse synapse = getSynapse(t.x);\n            synapse = synapseRotate(synapse, t.y);\n            SynapticType synapticType = getSynapticType(synapse, Right);\n            tryEstablishSynapses(_fields, synapticType, t.y, Left);\n            if(synapticType > 0.5) token = true;\n        }\n    }\n    \n    if(p.x < _dims.x - 1.5) {\n\n        vec3 p0 = p;\n        p0.x += 1.0;\n        vec2 v = wtu(p0, iResolution);\n        vec2 t = texture(iChannel0, v).rg;\n        if(t.x > -0.5) {\n\n            Synapse synapse = getSynapse(t.x);\n            synapse = synapseRotate(synapse, t.y);\n            SynapticType synapticType = getSynapticType(synapse, Left);\n            tryEstablishSynapses(_fields, synapticType, t.y, Right);\n            if(synapticType > 0.5) token = true;\n        }\n    }\n    \n    if(p.y > 0.5) {\n\n        vec3 p0 = p;\n        p0.y -= 1.0;\n        vec2 v = wtu(p0, iResolution);\n        vec2 t = texture(iChannel0, v).rg;\n        if(t.x > -0.5) {\n\n            Synapse synapse = getSynapse(t.x);\n            synapse = synapseRotate(synapse, t.y);\n            SynapticType synapticType = getSynapticType(synapse, Up);\n            tryEstablishSynapses(_fields, synapticType, t.y, Down);\n            if(synapticType > 0.5) token = true;\n        }\n    }\n    \n    if(p.y < _dims.y - 1.5) {\n\n        vec3 p0 = p;\n        p0.y += 1.0;\n        vec2 v = wtu(p0, iResolution);\n        vec2 t = texture(iChannel0, v).rg;\n        if(t.x > -0.5) {\n\n            Synapse synapse = getSynapse(t.x);\n            synapse = synapseRotate(synapse, t.y);\n            SynapticType synapticType = getSynapticType(synapse, Down);\n            tryEstablishSynapses(_fields, synapticType, t.y, Up);\n            if(synapticType > 0.5) token = true;\n        }\n    }\n    if(p.z > 0.5) {\n\n        vec3 p0 = p;\n        p0.z -= 1.0;\n        vec2 v = wtu(p0, iResolution);\n        vec2 t = texture(iChannel0, v).rg;\n        if(t.x > -0.5) {\n\n            Synapse synapse = getSynapse(t.x);\n            synapse = synapseRotate(synapse, t.y);\n            SynapticType synapticType = getSynapticType(synapse, Front);\n            tryEstablishSynapses(_fields, synapticType, t.y, Back);\n            if(synapticType > 0.5) token = true;\n        }\n    }\n    \n    if(p.z < _dims.z - 1.5) {\n\n        vec3 p0 = p;\n        p0.z += 1.0;\n        vec2 v = wtu(p0, iResolution);\n        vec2 t = texture(iChannel0, v).rg;\n        if(t.x > -0.5) {\n\n            Synapse synapse = getSynapse(t.x);\n            synapse = synapseRotate(synapse, t.y);\n            SynapticType synapticType = getSynapticType(synapse, Back);\n            tryEstablishSynapses(_fields, synapticType, t.y, Front);\n            if(synapticType > 0.5) token = true;\n        }\n    }\n    \n\n    if(p.y < 0.5) {\n\n        eliminationElement(7, _fields);\n        eliminationElement(5, _fields);\n    }\n    \n    if(p.y > _dims.y - 1.5) {\n\n        eliminationElement(4, _fields);\n        eliminationElement(5, _fields);\n    }\n\n    if(token) {\n\n        int count = countBits(_fields);\n        if(count > 0) {\n\n            uint r = uint(uint(fragCoord.x) * uint(1973) + uint(fragCoord.y) * uint(9277) + uint(iFrame) * uint(26699)) | uint(1);\n            int n = int(mod(floor(randomFloat01(r) * float(count)), float(count)));\n            float index = float(find(n, _fields));\n            fragColor = vec4(floor(index / 4.0), mod(index, 4.0), 0.0, 0.0);\n        }\n    }\n    //*/\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define PI 3.1416\n\n#define _dims vec3(20.0, 3.0, 20.0)\n\nvec2 wtu(vec3 p, vec3 iResolution) {\n\n    float index = p.z * _dims.x + p.x + p.y * _dims.x * _dims.z;\n    float y = floor(index / iResolution.x);\n    float x = index - y * iResolution.x;\n    return vec2((x + 0.5) / iResolution.x, (y + 0.5) / iResolution.y);\n}\n\nvec3 utw(vec2 uv, vec3 iResolution) {\n\n    uv *= iResolution.xy;\n    uv = floor(uv);\n    float index = uv.y * iResolution.x + uv.x;\n    if(index > _dims.x * _dims.y * _dims.z - 0.5) return vec3(-1.0);\n    float x = mod(index, _dims.x);\n    float y = floor(index / (_dims.x * _dims.z));\n    float z = floor((index - y * _dims.x * _dims.z) / _dims.x);\n    return vec3(x, y, z);\n}\n","name":"Common","description":"","type":"common"}]}