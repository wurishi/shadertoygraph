{"ver":"0.1","info":{"id":"4dXfz4","date":"1494958855","viewed":97,"name":"Pruebas_02","username":"ps","description":"raymarching borrador anterior","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// recursos interesantes \n// elevated de iq https://www.shadertoy.com/view/MdX3Rr\n// raymarching de iq https://iquilezles.org/articles/rmshadows\n// iluminación de iq https://iquilezles.org/articles/outdoorslighting\n// (buena explicación de raymarching) tutorial para esfera con iluminacion phong mediante raymarching http://jamie-wong.com/2016/07/15/ray-marching-signed-distance-functions/\n// la base del codigo paret de esta https://www.youtube.com/watch?v=RGmgHfbU0hU\n\n// Constantes.\n#define STEPS 64\n#define EPS 0.01\n#define FAR 10.0\n#define PI 3.14159265359\n\n// define el terreno (signed distanced function) dada unas coordenadas x y z devuelve si ha colisionado o no\nfloat terrainSDF (vec2 posxz){\n    float x=posxz.x;\n    float  z=posxz.y;\n    return 3.2 + 0.1*sin(20.0*x)*cos(20.0*z);\n}\n// escena donde se guardara la composición de objetos de la escena\nfloat scene(vec2 posxz){\n    return terrainSDF(posxz);\n}\n// \nfloat intersect( in vec3 ro, in vec3 rd, in float tmin, in float tmax )\n{\n    vec3 pos;\n    float t = tmin;\n\t\tfor( int i=0; i<256; i++ )\n\t{\n         pos = ro + t*rd;\n\t\tfloat h = pos.y - scene( pos.xz );\n\t\tif( h<(0.002*t) || t>tmax ) break;\n\t\tt += 0.5*h;\n\t}\n\n\treturn t;\n}\n\n\nvec3 calcNormal( in vec3 pos, float t )\n{\n    vec2  eps = vec2( 0.002*t, 0.0 );\n    return normalize( vec3( scene(pos.xz-eps.xy) - scene(pos.xz+eps.xy),\n                            2.0*eps.x,\n                            scene(pos.xz-eps.yx) - scene(pos.xz+eps.yx) ) );\n}\n\nvec3 calcNormal( in vec3 pos)\n{\n    vec2  eps = vec2( 0.0001 );\n    return normalize( vec3( scene(pos.xz-eps.xy) - scene(pos.xz+eps.xy),\n                            2.0*eps.x,\n                            scene(pos.xz-eps.yx) - scene(pos.xz+eps.yx) ) );\n}\n\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    vec3 N = calcNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n/**\n * Lighting via Phong illumination.\n * \n * The vec3 returned is the RGB color of that point after lighting is applied.\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye, vec3 nor, vec3 ro) {\n \n    vec3 ambientLight = 0.5 * k_d;\n    vec3 color = ambientLight * k_a;\n   // vec3 light1Pos = vec3(10.0, 1.0, 10.0);\n    // hacemos que se mueva para que quede mas interesante\n    vec3 light1Pos = vec3(ro.x+10.0 * sin(iTime),\n                          ro.y+2.0,\n                          ro.z+10.0 * cos(iTime));\n    vec3 light1Intensity = vec3(0.4, 0.4, 0.4);\n    \n    \n    vec3 pointToLight = light1Pos - p; // Vector foco-vértice\n\tfloat distanceToLight = length(pointToLight);\n\tvec3 L = normalize(pointToLight);\n\tvec3 power = k_d;// * atenuate(distanceToLight,omniLights[i].fade);// Fade de distancia\n\tvec3 diff = power * k_d * dot(nor, L);\n\tcolor+=clamp(diff,0.0,1.0);\n\n    // Especular\n    vec3 R = reflect(-L,nor);\n    vec3 V=pointToLight;\n    float Sfactor = max(dot(R,V),0.0001);\n\n    Sfactor=pow(Sfactor,length(nor));\n    vec3 spec = power * k_s * Sfactor;\n    color+=clamp(spec,0.0,1.0);\n    return color;\n    \n}\n\n\nvec4 render ( vec3 ro, in vec3 rd){\n    vec3 light1 = normalize( vec3(4.8,10.4,4.3) );\n\tfloat tmin = 1.0;\n    float tmax = 100.; // distancia maxima del rayo\n\tvec3 col;\n\tvec3 colorGround=vec3(0.474, 0.313, 0.086);\n    vec3 colorBackground=vec3(0.1,0.1,0.8);\n \n\tfloat t = intersect( ro, rd, tmin, tmax );\n    if (t>tmax){\n        //draw background\n         col = colorBackground;\n         t = -1.0;\n    }else{\n        //draw terrain\n        vec3 pos = ro + t*rd;\n        vec3 matGround=colorGround;\n        vec3 nor = calcNormal( pos, t );\n        return vec4(nor,1.0);\n        vec3 ref = reflect( rd, nor );\n\n        vec3 K_a = vec3(0.5, 0.5, 0.5);\n        vec3 K_d = vec3(0.7, 0.2, 0.2);\n        vec3 K_s = vec3(1.0, 1.0, 1.0);\n        float shininess = 10.0;\n\n        vec3 p=pos;\n        vec3 eye=ro;\n        vec3 color = phongIllumination(K_a, K_d, K_s, shininess, p, eye, nor,ro);\n        return vec4(color,1.0);\n\n        vec3 col=color;   \n        // gamma correction (se supone que asi se ve mejor)\n        col = pow( col, vec3(1.0/2.2) );\n        //col= colorGround;\n    }\n\treturn vec4(col,t);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // Pixeles de la imagen\n\tvec2 uv = (-iResolution.xy + 2.0*fragCoord.xy) / iResolution.y;\n    \n    vec3 ro = vec3(0.0, 5.0, +2.5-iTime); // inicio de rayo\n    vec3 rd = normalize(vec3(uv, -1.0)); // direccion de rayo\n    vec4 res= render(ro,rd); //funcion que nos devolverá el color del fragmento\n\t\n\tfragColor = vec4(res.xyz,1.0);\n}","name":"Image","description":"","type":"image"}]}