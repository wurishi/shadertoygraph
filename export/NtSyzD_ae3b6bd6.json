{"ver":"0.1","info":{"id":"NtSyzD","date":"1649414682","viewed":62,"name":"shader v2","username":"Mistermuggles","description":"Shader v2","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["v2"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Shader de Thomas Reynard LP-MI 2021-2011\n#define R iResolution.xy\n#define DIST_MIN 0.5 // minimum distance to objects\n#define DIST_MAX 30.0 // maximum distance to objects\n#define RAY_MARCH_STEPS 100\n#define RAY_MARCH_PRECI 0.001\n#define PI 3.14159265359\n\n// ray structure\nstruct Ray {\n    vec3 o; // origin\n    vec3 d; // direction\n};\n\nstruct Surface {\n    float t; // surface distance\n    vec3 c; // surface color\n};\n\n//fonction sdSphere by Inigo Quilez \nfloat sdSphere( vec3 p, float s ) {\n  return length(p)-s;\n}\n\n//fonction sdTorus by Inigo Quilez \nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n\n//fonction trouvée sur ce shadertoy https://www.shadertoy.com/view/Wt2yDG by Baruch\nvec3 yToRgb(float y)\n{    \n    float r, g, b;\n    \n    // functions where created based on the default linear equation\n    // f(x) = mx + b, where m is the slope and b the intersection point\n    // with the x axis f(0) = b ;)\n    // you can view the graph of the functions here: \n    // https://iquilezles.org/apps/graphtoy/?f3(x)=1-abs(x*2-1)&f4(x)=clamp(1-x*2,%200,%201)&f6(x)=clamp((x-0.5)*2,%200,%201)\n    \n    b = clamp(1.0-y*2.0, 0.0, 1.0);\n    g = 1.0-abs(y*2.0-1.0);\n    r = clamp((y-0.5)*2.0, 0.0, 1.0);\n    \n    return vec3(r, g, b);\n}\n\nSurface scene(in vec3 p) {\n   \n    //float d1 = sdSphere(vec3(p.x+sin(iTime), p.y, p.z+cos(iTime)), 0.3);\n    //float d1 = sdDeathStar(p+vec3(0.,0.,0.),1.,0.4,0.95);\n    vec3 c = p;\n    vec3 c1 = p;\n    vec3 c2 = p;\n    vec3 c3 = p;\n    \n    //donne l'angle de l'objet que l'on veut créer\n    c = vec3(cos(PI/4.)*p.x-sin(PI/4.)*p.y,sin(PI/4.)*p.x+cos(PI/4.)*p.y, p.z);\n    //applique la rotation à l'objet\n    c = vec3(cos(iTime*5.)*c.x-sin(iTime*5.)*c.z,c.y,sin(iTime*5.)*c.x+cos(iTime*5.)*c.z);\n    //place l'objet dans la scène\n    c = c + vec3(1.5,0,0);\n    \n    c1 = vec3(cos(-PI/4.)*p.x-sin(-PI/4.)*p.y,sin(-PI/4.)*p.x+cos(-PI/4.)*p.y, p.z);\n    c1 = vec3(cos(-iTime*2.)*c1.x-sin(-iTime*2.)*c1.z,c1.y,sin(-iTime*2.)*c1.x+cos(-iTime*2.)*c1.z);\n    c1 = c1 + vec3(1.5,0,0);\n    \n    c2 = vec3(p.x,p.y, p.z);\n    c2 = vec3(cos(iTime*3.5)*c2.x-sin(iTime*3.5)*c2.z,c2.y,sin(iTime*3.5)*c2.x+cos(iTime*3.5)*c2.z);\n    c2 = c2 + vec3(1.5,0,0);\n    \n    c3 = vec3(cos(PI/2.)*p.x-sin(PI/2.)*p.y,sin(PI/2.)*p.x+cos(PI/2.)*p.y,p.z);\n    c3 = vec3(cos(-iTime*2.5)*c3.x-sin(-iTime*2.5)*c3.z,c3.y,sin(-iTime*2.5)*c3.x+cos(-iTime*2.5)*c3.z);\n    c3 = c3 + vec3(1.5,0,0);\n    \n    //crée l'objet selon les modifications appliquées à c préalablement\n    float d1 = sdSphere(c, 0.15);\n    float d2 = sdTorus(vec3(cos(PI/4.)*p.x-sin(PI/4.)*p.y,sin(PI/4.)*p.x+cos(PI/4.)*p.y, p.z),vec2(1.5,0.02));\n    float d3 = sdSphere(p,0.8);\n    float d4 = sdTorus(vec3(cos(-PI/4.)*p.x-sin(-PI/4.)*p.y,sin(-PI/4.)*p.x+cos(-PI/4.)*p.y, p.z),vec2(1.5,0.02));\n    float d5 = sdTorus(vec3(p.x,p.y,p.z),vec2(1.5,0.02));\n    float d6 = sdTorus(vec3(cos(PI/2.)*p.x-sin(PI/2.)*p.y,sin(PI/2.)*p.x+cos(PI/2.)*p.y,p.z),vec2(1.5,0.02));\n    float d7 = sdSphere(c1, 0.15);\n    float d8 = sdSphere(c2, 0.15);\n    float d9 = sdSphere(c3, 0.15);\n    \n    //bout de code ci-dessous trouvé sur https://thebookofshaders.com/06/\n\n    vec3 colorA = vec3(1.,0.,1.);\n    vec3 colorB = vec3(0,1.,1.);\n    \n    float pct = abs(sin(iTime*0.5));\n    vec3 color = vec3(0.0);\n    // Mix uses pct (a value from 0-1) to\n    // mix the two colors\n    color = mix(colorA, colorB, pct);\n    \n    \n    Surface d = Surface(DIST_MAX,vec3(1.));\n    \n    if(d1<d.t) {\n        d = Surface(d1,color);\n    }\n    \n    if(d2<d.t) {\n        d = Surface(d2,color);\n    }\n    \n    if(d3<d.t) {\n        d = Surface(d3,color);\n    }\n    \n    if(d4<d.t) {\n        d = Surface(d4,color);\n    }\n    \n    if(d5<d.t) {\n        d = Surface(d5,color);\n    }\n    \n    if(d6<d.t) {\n        d = Surface(d6,color);\n    }\n    \n    if(d7<d.t) {\n        d = Surface(d7,color);\n    }\n    \n    if(d8<d.t) {\n        d = Surface(d8,color);\n    }\n    \n    if(d9<d.t) {\n        d = Surface(d9,color);\n    }\n    \n    \n    return d;\n}\n\n\nSurface march(in Ray r) {\n    float t = DIST_MIN;\n\n    for(int i=0;i<RAY_MARCH_STEPS,t<=DIST_MAX;++i) {\n        Surface s = scene(r.o+t*r.d);\n\n        if(s.t<RAY_MARCH_PRECI) {\n            return Surface(t+s.t,s.c);\n        }\n\n        t = t+s.t;\n    }\n\n    return Surface(DIST_MAX,vec3(0.7,0.3,1.));\n}\n\nvec3 normalAt(in Surface s,in Ray r) {\n    const float e = 0.01;\n    vec3 p = r.o+s.t*r.d;\n    float nx = scene(vec3(p.x+e,p.y,p.z)).t-scene(vec3(p.x-e,p.y,p.z)).t;\n    float ny = scene(vec3(p.x,p.y+e,p.z)).t-scene(vec3(p.x,p.y-e,p.z)).t;\n    float nz = scene(vec3(p.x,p.y,p.z+e)).t-scene(vec3(p.x,p.y,p.z-e)).t;\n\n    return normalize(vec3(nx,ny,nz));\n}\n\nRay camRay(in vec2 p) {\n    // p is the current pixel coord, in [-1,1]\n\n    // normalized mouse position1\n    vec2 m = iMouse.xy/R.y;\n    \n    // camera position\n    float DP = 10.;\n    float d = DP/2.;\n    vec3 ro = vec3(d*cos(6.0*m.x),DP/5.0,d*sin(6.0*m.x) );\n    //vec3 ro = vec3(d*cos(6.0*m.x),(DP/2.0)*(m.y*4.),d*sin(6.0*m.x) );\n\n    //vec3 ro = vec3(0.,0.,-7.);\n\n    // target point\n    //vec3 ta = vec3(0.0,DP/10.0,0.0);\n    vec3 ta = vec3(0.0,0.0,0.0);\n\n    // camera view vector\n    vec3 cw = normalize(ta-ro);\n\n    // camera up vector\n    vec3 cp = vec3(0.0,1.0,0.0);\n\n    // camera right vector\n    vec3 cu = normalize(cross(cw,cp));\n\n    // camera (normalized) up vector\n    vec3 cv = normalize(cross(cu,cw));\n    \n    float fovDeg = 45.;\n    float fovRad = (fovDeg/360.)*2.*PI;\n    float zf = 1./tan(fovRad/2.);\n    \n    // view vector, including perspective (the more you multiply cw, the less fovy)\n    vec3 rd = normalize(p.x*cu + p.y*cv*(R.y/R.x) + 2.*cw);\n\n    return Ray(ro,rd);\n}\n\nvec3 shade(in Surface surf, in Ray ray) {\n    // tous les vecteurs nécessaires au shading\n    vec3 n = normalAt(surf,ray);\n    vec3 l = normalize(vec3(1.));\n    vec3 v = ray.d;\n    vec3 r = reflect(l,n);\n    \n    // parametres du materiau\n    vec3 kd = surf.c;\n    vec3 ks = vec3(0.8);\n    float s = 20.;\n    \n    // coeficients diffus et spéculaires\n    float diff = max(dot(n,l),0.);\n    float spec = pow(max(dot(r,v),0.),s);\n    \n    return kd*diff + ks*spec;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord / R.xy)*2.-1.;\n    \n    Ray r = camRay(uv*1.5);\n    Surface s = march(r);\n    vec3 c = s.c;\n    \n    if(s.t<DIST_MAX) {\n        c = shade(s,r);\n    }\n    \n    //fragColor = vec4(c+yToRgb(uv.y),1.0);\n    fragColor = vec4(c+yToRgb(cos(uv.y)),1.0);\n}","name":"Image","description":"","type":"image"}]}