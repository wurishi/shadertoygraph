{"ver":"0.1","info":{"id":"4ctBRH","date":"1732713723","viewed":69,"name":"GTAO+ (unidirectional)","username":"TinyTexel","description":"Unidirectional version of GTAO+: https://www.shadertoy.com/view/lctBzH\nleft: GTAO+ | right: ray marched reference AO\nCamera controls via mouse + shift key","likes":3,"published":3,"flags":48,"usePreview":0,"tags":["ao","occlusion","ambient","gtao","vbao"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// https://x.com/Mirko_Salm/status/1833211198009184650\n/*\n    Unidirectional version of GTAO+: https://www.shadertoy.com/view/lctBzH\n    \n    This is a screen space AO variant for which I replaced the bitmask logic of GT-VBAO with a less ALU-heavy (but also less accurate) \n    horizon+interval logic similar to that of GTAO (GTAO only uses horizon angles; the additional intervals allow GTAO+ to handle \n    surfaces of finite thicknesses better).\n    \n    This is basically a version of GTAO that supports importance sampling while also handling perspective cameras correctly. \n    It therefore converges to the same results that the reference ray marcher converges to iff Thickness = inf (i.e. depth buffer == height field).\n    \n    With respect to performance GTAO+ beats GT-VBAO if the main memory bandwidth pressure is sufficiently small.\n    Judging from my limited tests it seems that that might be rarely the case in practice, though (even when not using the ALU-heavy importance sampling).\n    Also, GT-VBAO seems to always at least match the quality of GTAO+. \n    Especially in the presence of high depth buffer complexity GT-VBAO is generally more reliable than GTAO+.\n    \n    \n    Buffer A: input logic\n    Buffer B: g-buffer rendering\n    Buffer C: GTAO+ + reference ray marcher/caster\n    Image   : documentation + presentation\n\n    Controls:\n    1: split screen comparison of GTAO+ (left) and reference ray marcher (right)\n    2: GT-VBAO\n    3: reference ray marcher\n    4: grey-scale difference betwwen GTAO+ and reference (white: too bright | black: too dark)\n    5: colored    difference betwwen GTAO+ and reference (red  : too bright | blue : too dark)\n    6: blurred version of 4\n    7: blurred version of 5\n    -> options 4-7 only make sense to use with converged results\n\n    toggles:\n    \n    Tab  : toggle temporal accumulation on/off\n    Ctrl : toggle ortho cam off/on\n    U    : toggle UI off/on\n    \n    Camera controls via mouse + shift key.\n    \n\n    Related/Sources:\n    \n        -  bidirectional GT-VBAO: https://www.shadertoy.com/view/XXGSDd\n        - unidirectional GT-VBAO: https://www.shadertoy.com/view/Xc3yzs\n        -  bidirectional GTAO+  : https://www.shadertoy.com/view/lctBzH\n        - unidirectional GTAO+  : https://www.shadertoy.com/view/4ctBRH\n\n        - Screen Space Indirect Lighting with Visibility Bitmask: the original VBAO\n          https://arxiv.org/abs/2301.11376\n          \n        - An overview of the original VBAO including source code (Olivier Therrien's blog): my initial implementation was based on this\n          https://cdrinmatane.github.io/posts/ssaovb-code/\n          \n        - Practical Real-Time Strategies for Accurate Indirect Occlusion: introduces GTAO, which VBAO is a variant of\n          https://www.activision.com/cdn/research/Practical_Real_Time_Strategies_for_Accurate_Indirect_Occlusion_NEW%20VERSION_COLOR.pdf\n          \n        - Horizon Based Indirect Lighting (HBIL)\n          https://github.com/Patapom/GodComplex/tree/master/Tests/TestHBIL\n*/\n\n\n/*\n    This work is licensed under a dual license, public domain and MIT, unless noted otherwise. Choose the one that best suits your needs:\n    \n    CC0 1.0 Universal https://creativecommons.org/publicdomain/zero/1.0/\n    To the extent possible under law, the author has waived all copyrights and related or neighboring rights to this work.\n    \n    or\n    \n    The MIT License\n    Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), \n    to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, \n    and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: \n    The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. \n    THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \n    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, \n    DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR \n    THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n\n#define KeyBoard iChannel2\n\nfloat ReadKey(int keyCode) {return texelFetch(KeyBoard, ivec2(keyCode, 0), 0).x;}\nfloat ReadKeyToggle(int keyCode) {return texelFetch(KeyBoard, ivec2(keyCode, 2), 0).x;}\n\n#define VarTex iChannel3\n#define OutCol outCol\n#define OutChannel w\n\nfloat ReadVar(int cx, int cy) {return texelFetch(VarTex, ivec2(cx, cy), 0).OutChannel;}\nvec4 ReadVar4(int cx, int cy) {return vec4(ReadVar(cx, cy), ReadVar(cx, cy + 1), ReadVar(cx, cy + 2), ReadVar(cx, cy + 3));}\n\n/////////////////////////////////////////////////////////////////////////////////// UI\n//===============================================================================//\n\nfloat glyph2(bool style, vec2 tc)\n{\n    float r0 = 10.0;\n    float r1 = 1.;\n    float b = max(abs(tc.x), abs(tc.y)) - r0;\n    float c = length(tc) - r0*0.9;\n    \n    b = max(b, -c);\n    \n    if(!style) if(r1 != 0.0) b = abs(b) - r1;\n    \n    b = max(b, -(abs(tc.x) - r1));\n    b = max(b, -(abs(tc.y) - r1));\n    \n    return 1.0 - clamp(b + 0.5, 0.0, 1.0);\n}\n\nfloat glyph(bool type, vec2 tc, float r0, float r1, bool separator)\n{\n    float b = (type ? length(tc) : max(abs(tc.x), abs(tc.y))) - r0;\n    \n    if(r1 != 0.0) b = abs(b) - r1;\n    \n    if(separator) b = max(b, -(abs(tc.x) - r1));\n    \n    return 1.0 - clamp(b + 0.5, 0.0, 1.0);\n}\n\nvec2 EvalUI(vec2 uv0, float id, bvec2 modes)\n{\n    vec2 s = vec2(30.0, 30.0);\n\n    vec2 uv = uv0;\n\n    vec2 uvI = floor(uv / s);\n    vec2 uvF = uv - uvI * s;\n\n    if(uvI.y > 0.0 || uvI.x < 0.0 || uvI.x > 3.0) { return vec2(0.0); }\n\n    vec2 tc = uvF-s*0.5;\n\n    float k = 0.35;\n    if(uvI.x == id) k = 0.9;\n\n    bool isSolid = false;\n\n    if(uvI.x == 0.0) \n    isSolid = tc.x   < 0.0 ? modes.x : modes.y;\n    else\n    isSolid = uvI.x == 1.0 ? modes.x : modes.y;\n    \n    bool type = uvI.x == 1.0;\n    if(uvI.x == 0.0) type = tc.x < 0.0;\n\n    float v = glyph(type, tc, 8.0, isSolid ? 0.0 : 2.0, uvI.x == 0.0);\n    if(uvI.x == 3.0) v = glyph2(modes.x || modes.y, tc);\n\n    //if(uvI.y > 0.0 || uvI.x < 0.0 || uvI.x > 3.0) { v = 0.0; k = 0.0; }\n\n    return vec2(v, k);\n}\n\n//===============================================================================//\n///////////////////////////////////////////////////////////////////////////////////\n\nfloat ReadDenoisedAO(vec2 uv0);\n\nvoid mainImage(out vec4 outCol, in vec2 uv0)\n{\n    Resolution = iResolution.xy;\n\n    float num = ReadVar(4, VAR_ROW);\n\n    ivec2 uv = ivec2(uv0.xy - 0.5);\n\tvec2 tex = uv0.xy / iResolution.xy;\n    \n    vec3 col = vec3(0.0);\n        \n    vec2 ao = textureLod(iChannel0, tex, 0.0).rg;\n    //num=1.0;\n    if(num == 0.0)// split screen: gtvbao | ray-marched reference\n    {\n        col = vec3(uv0.x > iResolution.x * 0.5 ? ao.x : ao.y);\n    }\n    else if(num == 1.0)// gtvbao\n    {\n        col = vec3(ao.y);\n    }\n    else if(num == 2.0)// ray-marched reference\n    {\n        col = vec3(ao.x);\n    }\n    else if(num == 3.0 || num == 4.0)// visualize error\n    {\n        float diff = (ao.y - ao.x) * 8.0;\n        \n        if(num == 3.0)\n        {\n            col = vec3(0.5 + diff*2.0);\n        }\n        else// num == 4.0: gtvbao brighter than ref -> red | gtvbao darker than ref -> blue\n        {\n            col = abs(diff) * 3.0 * (diff > 0.0 ? vec3(1.0, 0.0, 0.0) : vec3(0.0, 0.18, 1.0));\n        }\n    }\n    else if(num == 5.0 || num == 6.0)// visualize error blurred\n    {\n        float count = 10.0;\n        float wa = 0.0;\n        \n        for(float j = -count; j <= count; ++j)\n        for(float i = -count; i <= count; ++i)\n        {\n            vec2 o = vec2(i, j);\n            vec2 w2 = pow(1.0 - pow(abs(o)/(count+0.5), vec2(2.0)), vec2(1.0));\n            \n            float w = 1.0;\n            w = w2.x * w2.y;\n            \n            vec2 ao = textureLod(iChannel0, (uv0 + o) / iResolution.xy, 0.0).rg;\n            \n            float diff = (ao.y - ao.x) * 8.0;\n\n            vec3 col0;\n            \n            if(num == 5.0)\n            {\n                col0 = vec3(abs(diff));\n                col0 = vec3(0.5 + diff*2.0);\n            }\n            else\n            {\n                col0 = abs(diff) * 3.0 * (diff > 0.0 ? vec3(1.0, 0.0, 0.0) : vec3(0.0, 0.18, 1.0));\n            }\n        \n            col += col0 * w;\n            wa += w;\n        }\n        \n        col /= wa;\n    }\n    \n    #if 0\n    if(num < 3.0 && ReadKeyToggle(KEY_S) != 0.0)\n    {\n        // isolines\n        col = 1.0-(cos(col * 32.0) * 0.5 + 0.5);\n    }\n    #endif\n    \n    // highlight pixels green if they clip beneath 0 or above 1: \n    if(ReadKeyToggle(KEY_N) != 0.0)\n    if(col.r < 0.0 || col.r > 1.0 || col.g < 0.0 || col.g > 1.0 || col.b < 0.0 || col.b > 1.0) col.rgb = vec3(0.0, 1.0, 0.0);\n    \n    //col = vec3(ReadDenoisedAO(uv0));\n    \n    outCol = vec4(pow(clamp01(col), vec3(1.0/2.2)), 0.0);\n    \n    \n    if(SHOW_UI_COND)\n    {\n        bvec2 modes = bvec2(false);\n        \n        vec2 ui = EvalUI(uv0, min(num, 3.0), modes.xx);\n        \n        outCol.rgb = mix(outCol.rgb, vec3(ui.y) * mix(vec3(0., 0.6, 1.0), vec3(1.0), 0.9), ui.x);\n    }    \n}\n\n\n\n\n/////////////////////////////////////////////////////////////////////////////////// multi-pass denoising experiments\n//===============================================================================//\n\nfloat Read0(vec2 uv0)\n{\n    //return floor(uv0.x) == floor(iResolution.x*0.5) && floor(uv0.y) == floor(iResolution.y*0.5) ? 1.0 : 0.0;\n    return textureLod(iChannel0, uv0 / iResolution.xy, 0.0).g;\n}\n\nfloat ReadA(vec2 uv0)\n{\n    float v0 = Read0(uv0);\n    \n    vec2 off = vec2(2.0, 0.0);\n    for(float i = 0.0; i < 4.0; ++i)\n    {\n        vec2 uvB = uv0 + off;\n        \n        float vB = Read0(uvB);\n        \n        v0 += vB;\n        \n        off = vec2(-off.y, off.x);\n    }\n    \n    v0 *= 0.2;\n    \n    return v0;\n}\n\nfloat ReadB(vec2 uv0)\n{\n    float v0 = ReadA(uv0);\n    \n    vec2 off = vec2(2.0, 1.0);\n    for(float i = 0.0; i < 4.0; ++i)\n    {\n        vec2 uvB = uv0 + off;\n        \n        float vB = ReadA(uvB);\n        \n        v0 += vB;\n        \n        off = vec2(-off.y, off.x);\n    }\n    \n    v0 *= 0.2;\n    \n    return v0;\n}\n\nfloat ReadC(vec2 uv0)\n{\n    float v0 = ReadB(uv0);\n    \n    vec2 off = vec2(2.0, -1.0);\n    for(float i = 0.0; i < 4.0; ++i)\n    {\n        vec2 uvB = uv0 + off;\n        \n        float vB = ReadB(uvB);\n        \n        v0 += vB;\n        \n        off = vec2(-off.y, off.x);\n    }\n    \n    v0 *= 0.2;\n    \n    return v0;\n}\n\nfloat ReadD(vec2 uv0)\n{\n    float v0 = 0.0;\n    \n    for(float y = -1.0; y <= 1.0; ++y)\n    for(float x = -1.0; x <= 1.0; ++x)\n    {\n        vec2 off = vec2(x, y);\n        \n        vec2 uvB = uv0 + off*3.0 + vec2(-off.y, off.x);\n        \n        float vB = ReadA(uvB);\n        \n        v0 += vB;\n    }\n    \n    v0 /= 9.0;\n    \n    return v0;\n}\n\n\nfloat ReadDenoisedAO(vec2 uv0)\n{\n    return ReadD(uv0);\n}\n\n//===============================================================================//\n///////////////////////////////////////////////////////////////////////////////////\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"/*\n    This work is licensed under a dual license, public domain and MIT, unless noted otherwise. Choose the one that best suits your needs:\n    \n    CC0 1.0 Universal https://creativecommons.org/publicdomain/zero/1.0/\n    To the extent possible under law, the author has waived all copyrights and related or neighboring rights to this work.\n    \n    or\n    \n    The MIT License\n    Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), \n    to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, \n    and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: \n    The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. \n    THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \n    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, \n    DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR \n    THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n\n/*\n    Input logic\n*/\n\n#define KeyBoard iChannel1\n\nfloat ReadKey(int keyCode) {return texelFetch(KeyBoard, ivec2(keyCode, 0), 0).x;}\nfloat ReadKeyToggle(int keyCode) {return texelFetch(KeyBoard, ivec2(keyCode, 2), 0).x;}\n\n#define VarTex iChannel3\n#define OutCol outCol\n#define OutChannel w\n\n#define WriteVar(v, cx, cy) {if(uv.x == uint(cx) && uv.y == uint(cy)) OutCol.OutChannel = v;}\n#define WriteVar4(v, cx, cy) {WriteVar(v.x, cx, cy) WriteVar(v.y, cx, cy + 1) WriteVar(v.z, cx, cy + 2) WriteVar(v.w, cx, cy + 3)}\n\nfloat ReadVar(int cx, int cy) {return texelFetch(VarTex, ivec2(cx, cy), 0).OutChannel;}\nvec4 ReadVar4(int cx, int cy) {return vec4(ReadVar(cx, cy), ReadVar(cx, cy + 1), ReadVar(cx, cy + 2), ReadVar(cx, cy + 3));}\n\n\nvoid mainImage(out vec4 outCol, in vec2 uv0)\n{     \n    if(uv0.x >= 256.0 || uv0.y >= 8.0) discard;\n    \n    Resolution = iResolution.xy;\n\n    uvec2 uv = uvec2(uv0.xy - 0.5);\n\n    outCol = vec4(0.0);\n    \n    // blit key board texture\n    outCol = texelFetch(KeyBoard, ivec2(uv0 - 0.5), 0);\n    \n    // program state:\n    {\n        vec4 iMouseLast     = ReadVar4(0, VAR_ROW);\n        vec4 iMouseAccuLast = ReadVar4(1, VAR_ROW);\n        vec4 wasdAccuLast   = ReadVar4(2, VAR_ROW);\n        float frameAccuLast = ReadVar (3, VAR_ROW);\n        float num           = ReadVar (4, VAR_ROW);\n        \n\n        bool shift = ReadKey(KEY_SHIFT) != 0.0;\n\n        float kW = ReadKey(KEY_W);\n        float kA = ReadKey(KEY_A);\n        float kS = ReadKey(KEY_S);\n        float kD = ReadKey(KEY_D);\n\n        float left  = ReadKey(KEY_LEFT);\n        float right = ReadKey(KEY_RIGHT);\n        float up    = ReadKey(KEY_UP);\n        float down  = ReadKey(KEY_DOWN);\n        \n        if(ReadKey(KEY_N1) != 0.0) num = 0.0;\n        if(ReadKey(KEY_N2) != 0.0) num = 1.0;\n        if(ReadKey(KEY_N3) != 0.0) num = 2.0;\n        if(ReadKey(KEY_N4) != 0.0) num = 3.0;\n        if(ReadKey(KEY_N5) != 0.0) num = 4.0;\n        if(ReadKey(KEY_N6) != 0.0) num = 5.0;\n        if(ReadKey(KEY_N7) != 0.0) num = 6.0;\n        \n        bool anyK = false;\n        \n        anyK = anyK || iMouse.z > 0.0;\n        anyK = anyK || shift;\n        anyK = anyK || kW != 0.0;\n        anyK = anyK || kA != 0.0;\n        anyK = anyK || kS != 0.0;\n        anyK = anyK || kD != 0.0;\n        anyK = anyK || left  != 0.0;\n        anyK = anyK || right != 0.0;\n        anyK = anyK || up    != 0.0;\n        anyK = anyK || down  != 0.0;\n        anyK = anyK || ReadKey(KEY_TAB) != 0.0;\n        anyK = anyK || ReadKey(KEY_SHIFT) != 0.0;\n        anyK = anyK || ReadKey(KEY_SPACE) != 0.0;\n        anyK = anyK || ReadKey(KEY_CTRL) != 0.0;\n        \n        float frameAccu = frameAccuLast;\n        //if(anyK) frameAccuLast = 0.0;\n        \n\n        vec4 wasdAccu = wasdAccuLast;\n        wasdAccu += vec4(kW, kA, kS, kD);\n        wasdAccu += vec4(up, left, down, right);        \n\n        \n        vec2 mouseDelta = iMouse.xy - iMouseLast.xy;\n\n\n\n        bool cond0 = iMouse.z > 0.0 && iMouseLast.z > 0.0;\n        vec2 mouseDelta2 = cond0 && !shift ? mouseDelta.xy : vec2(0.0);\n        vec2 mouseDelta3 = cond0 &&  shift ? mouseDelta.xy : vec2(0.0);\n\n        vec4 iMouseAccu = iMouseAccuLast + vec4(mouseDelta2, mouseDelta3);\n\n        if(cond0 && dot(abs(mouseDelta), vec2(1.0)) != 0.0) frameAccu = 0.0;\n        if(ReadKey(KEY_TAB ) != 0.0) frameAccu = 0.0;\n        if(ReadKey(KEY_CTRL) != 0.0) frameAccu = 0.0;\n        if(ReadKey(KEY_R   ) != 0.0) frameAccu = 0.0;\n        if(ReadKey(KEY_W   ) != 0.0) frameAccu = 0.0;\n        if(ReadKey(KEY_SPACE)!= 0.0) frameAccu = 0.0;\n        \n        frameAccu += 1.0;\n        \n        vec4 toggles = vec4(\n        ReadKeyToggle(KEY_TAB  ) != 0.0 ? 1.0 : 0.0,\n        ReadKeyToggle(KEY_SHIFT) != 0.0 ? 1.0 : 0.0,\n        ReadKeyToggle(KEY_SPACE) != 0.0 ? 1.0 : 0.0,\n        ReadKeyToggle(KEY_CTRL ) != 0.0 ? 1.0 : 0.0);\n        \n        WriteVar4(iMouse,        0, VAR_ROW);\n        WriteVar4(iMouseAccu,    1, VAR_ROW);\n        WriteVar4(wasdAccu,      2, VAR_ROW);\n        WriteVar (frameAccu,     3, VAR_ROW);\n        WriteVar (num,           4, VAR_ROW);\n        WriteVar4(iMouseAccuLast,5, VAR_ROW);\n        WriteVar4(toggles       ,6, VAR_ROW);\n    }\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"/*\n    This work is licensed under a dual license, public domain and MIT, unless noted otherwise. Choose the one that best suits your needs:\n    \n    CC0 1.0 Universal https://creativecommons.org/publicdomain/zero/1.0/\n    To the extent possible under law, the author has waived all copyrights and related or neighboring rights to this work.\n    \n    or\n    \n    The MIT License\n    Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), \n    to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, \n    and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: \n    The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. \n    THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \n    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, \n    DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR \n    THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n\nvec2 Resolution;\n\n#define USE_TEMP_ACCU_COND                (ReadKeyToggle(KEY_TAB  ) != 0.0)\n#define USE_PERSPECTIVE_CAM_COND          (ReadKeyToggle(KEY_CTRL ) == 0.0)\n#define SHOW_UI_COND                      (ReadKeyToggle(KEY_U    ) == 0.0)\n\n////////////////////////////////////////////////////////////////////////////////////////////////////////////// misc\n//==========================================================================================================//\n#define VAR_ROW 4\n\n/* http://keycode.info/ */\n#define KEY_LEFT  37\n#define KEY_UP    38\n#define KEY_RIGHT 39\n#define KEY_DOWN  40\n\n#define KEY_TAB 9\n#define KEY_CTRL 17\n#define KEY_ALT 18\n#define KEY_SHIFT 16\n#define KEY_SPACE 32 \n\n#define KEY_Q 81\n#define KEY_W 87\n#define KEY_E 69\n#define KEY_R 82\n#define KEY_T 84\n\n#define KEY_A 65\n#define KEY_S 83\n#define KEY_D 68\n#define KEY_F 70\n#define KEY_G 71\n\n#define KEY_N1 49\n#define KEY_N2 50\n#define KEY_N3 51\n#define KEY_N4 52\n#define KEY_N5 53\n#define KEY_N6 54\n#define KEY_N7 55\n#define KEY_N8 56\n\n#define KEY_M 77\n#define KEY_N 78\n#define KEY_O 79\n#define KEY_U 85\n\n#define clamp01(x) clamp(x, 0.0, 1.0)\n#define If(cond, resT, resF) mix(resF, resT, cond)\nconst float Pi   = 3.1415926535897930;\nconst float Pi05 = 1.5707963267948966;\nconst float Pi2= Pi * 2.0;\nconst float RcpPi = 1.0 / Pi;\nconst float RcpPi05 = 1.0 / Pi05;\n\nfloat Pow2(float x) {return x*x;}\nfloat Pow3(float x) {return x*x*x;}\nfloat Pow4(float x) {return Pow2(Pow2(x));}\n\n//==========================================================================================================//\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n\n////////////////////////////////////////////////////////////////////////////////////////////////////////////// camera logic + transforms\n//==========================================================================================================//\nbool isPerspectiveCam;// ortho/proj cam toggle\nfloat cdist, nearZ;// camera dist from origin + z-near\nmat3 cmat;// camera matrix\nvec3 cpos;// camera pos\nmat4 pmat, ipmat;// proj matrix + inverse\n\nvoid PrepareCam(vec4 mouseAccu, bool isPerspectiveCam0)\n{\n    isPerspectiveCam = isPerspectiveCam0;\n    \n    vec2 ang = vec2(Pi * 0.25, Pi * -0.1);\n    //ang = vec2(Pi05, Pi * -0.5);// start top-down\n    ang += mouseAccu.xy * 0.008;\n\n    vec3 front, right, up;\n    {\n        float sinPhi   = sin(ang.x);\n        float cosPhi   = cos(ang.x);\n        float sinTheta = sin(ang.y);\n        float cosTheta = cos(ang.y);    \n\n        front = vec3(cosPhi * cosTheta, \n                              sinTheta, \n                     sinPhi * cosTheta);\n\n        right = vec3(-sinPhi, 0.0, cosPhi);\n        \n        up    = vec3(-cosPhi * sinTheta,\n                               cosTheta,\n                     -sinPhi * sinTheta);\n        \n    }\n\n    cmat = mat3(right, up, front);\n    \n    cdist = exp2(1.5 + mouseAccu.w * 0.02);\n\n    float aspect = Resolution.x / Resolution.y;\n\n    vec2 vpSize = vec2(1.0, 1.0 / aspect) * 2.0;// viewport size at focal length\n\n    if(!isPerspectiveCam) vpSize *= cdist;\n\n    nearZ = isPerspectiveCam ? 0.125 : 0.0;\n\n   #if 1\n    float focalLen = 0.8;// = cot(fov * 0.5) for w == 2\n\n    float w = vpSize.x;\n    float h = vpSize.y;\n\n    float m00 = 2.0 * focalLen / w;\n    float m11 = 2.0 * focalLen / h;\n   #else \n\n    float fovX = 0.570447 * Pi;// 2 * arccot(focalLen) fpr w == 2\n    float m00 = cos(fovX * 0.5) / sin(fovX * 0.5);\n    float m11 = m00 * aspect;\n   #endif\n    \n    \n    float m23 = -nearZ;\n    float m32 = 1.0;\n    \n    float m33 = 0.0;\n    \n    if(!isPerspectiveCam)\n    {\n        m00 = 2.0 / vpSize.x;\n        m11 = 2.0 / vpSize.y;\n    \n        m23 = m32 = 0.0;\n        m33 = 1.0;\n    }    \n    \n    pmat = mat4(m00, 0.0, 0.0, 0.0,\n                0.0, m11, 0.0, 0.0,\n                0.0, 0.0, 1.0, m32,\n                0.0, 0.0, m23, m33);\n    \n    float i00 = 1.0 / m00;\n    float i11 = 1.0 / m11;\n    \n    float i22 = 0.0;\n    \n    float i23 = 1.0;\n    float i32 =-1.0/nearZ;\n    \n    float i33 = 1.0/nearZ;\n    \n    if(!isPerspectiveCam)\n    {\n        i22 = i33 = 1.0;\n        i23 = i32 = 0.0;\n    }\n                \n    ipmat = mat4(i00, 0.0, 0.0, 0.0,\n                 0.0, i11, 0.0, 0.0,\n                 0.0, 0.0, i22, i32,\n                 0.0, 0.0, i23, i33);\n    \n    \n    if(isPerspectiveCam)\n    {\n        cpos = -front * cdist;\n    }\n    else\n    {\n        cpos = -front * 8.0;\n    }    \n}\n\nfloat LinDepth_from_NonLinDepth(float depth)\n{\n    if(!isPerspectiveCam) return depth;\n    \n    //1.0 / (-depth/nearZ + 1.0/nearZ);\n    //1.0 / ((-depth + 1.0)/nearZ);\n    //nearZ / (-depth + 1.0);\n    return nearZ / (1.0 - depth);\n}\n\nfloat NonLinDepth_from_LinDepth(float depth)\n{\n    if(!isPerspectiveCam) return depth;\n\n    //return (depth - n) / depth;\n    return 1.0 - nearZ / depth;\n}\n\n\n// ====== View <-> World ====== //\nvec3 VPos_from_WPos(vec3 wpos)\n{\n    return (wpos - cpos) * cmat;\n}\n\nvec3 VVec_from_WVec(vec3 wvec)\n{\n    return wvec * cmat;\n}\n\n////\n\nvec3 WPos_from_VPos(vec3 vpos)\n{\n    return cmat * vpos + cpos;\n}\n\nvec3 WVec_from_VVec(vec3 vvec)\n{\n    return cmat * vvec;\n}\n// =========================== //\n\n// ====== Proj <-> View ====== //\nvec4 PPos_from_VPos(vec3 vpos)\n{\n    return pmat * vec4(vpos, 1.0);\n}\n\nvec3 VPos_from_PPos(vec4 ppos)\n{\n    vec4 vpos = ipmat * ppos;\n    \n    return vpos.xyz / vpos.w;\n}\n\nvec4 PVec_from_VVec(vec3 vvec)\n{\n    return pmat * vec4(vvec, 0.0);\n}\n// =========================== //\n\n\n// ====== Screen <-> View ====== //\nvec3 SPos_from_VPos(vec3 vpos)\n{\n    vec4 ppos = PPos_from_VPos(vpos);\n    \n    vec2 tc21 = ppos.xy / ppos.w;\n    \n    vec2 uv0 = (tc21 * 0.5 + 0.5) * Resolution;\n    \n    return vec3(uv0, vpos.z);\n}\n\nvec3 SVec_from_VVec_Ortho(vec3 vvec)\n{\n    vec4 pvec = PVec_from_VVec(vvec);\n    \n    vec2 xy = (pvec.xy * 0.5) * Resolution;\n    \n    return vec3(xy, vvec.z);\n}\n////\n\nvec3 VPos_from_SPos(vec3 spos)\n{\n    vec2 uv0 = spos.xy;\n    float depth = spos.z;\n          depth = NonLinDepth_from_LinDepth(depth);\n    \n    vec2 tc21 = uv0 / Resolution * 2.0 - 1.0;\n    \n    vec3 ppos = vec3(tc21, depth);\n    \n    vec4 vpos = ipmat * vec4(ppos, 1.0); \n    \n    vpos /= vpos.w;\n    \n    return vpos.xyz;  \n}\n// ============================= //\n\n// ====== Proj <-> World ====== //\nvec4 PPos_from_WPos(vec3 wpos)\n{\n    vec3 vpos = VPos_from_WPos(wpos);\n    \n    return PPos_from_VPos(vpos);\n}\n\nvec3 WPos_from_PPos(vec4 ppos)\n{\n    vec3 vpos = VPos_from_PPos(ppos);\n    \n    return WPos_from_VPos(vpos);\n}\n\nvec4 PVec_from_WVec(vec3 wvec)\n{\n    vec3 vvec = VVec_from_WVec(wvec);\n    \n    return PVec_from_VVec(vvec);\n}\n// =========================== //\n\n// ====== Screen <-> World ====== //\nvec3 SPos_from_WPos(vec3 wpos)\n{\n    vec3 vpos = VPos_from_WPos(wpos);\n\n    return SPos_from_VPos(vpos);\n}\n\n////\n\nvec3 WPos_from_SPos(vec3 spos)\n{\n    vec3 vpos = VPos_from_SPos(spos);\n\n    return WPos_from_VPos(vpos);\n}\n// ============================== //\n\nvoid GetRay(vec2 uv0, out vec3 rp, out vec3 rd)\n{\n    vec3 spos = vec3(uv0, nearZ);\n    \n    vec3 vpos = VPos_from_SPos(spos); \n\n    if(isPerspectiveCam)\n    {\n        rp = cpos;\n        rd = WVec_from_VVec(normalize(vpos)); \n    }\n    else\n    {\n        rp = WPos_from_VPos(vpos); \n        rd = cmat[2];\n    }\n}\n//==========================================================================================================//\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n\n////////////////////////////////////////////////////////////////////////////////////////////////////////////// intersection routines\n//==========================================================================================================//\n/*\nIN:\n\trp\t\t: ray start position\n\trd\t\t: ray direction (normalized)\n\t\n\tcp\t\t: cube position\n\tcth\t\t: cube thickness (cth = 0.5 -> unit cube)\n\t\nOUT:\n\tt\t\t: distances to intersection points (negative if in backwards direction)\n\nEXAMPLE:\t\n\tvec2 t;\n\tfloat hit = Intersect_Ray_Cube(pos, dir, vec3(0.0), vec3(0.5), OUT t);\n*/\nfloat Intersect_Ray_Cube(\nvec3 rp, vec3 rd, \nvec3 cp, vec3 cth, \nout vec2 t)\n{\t\n\trp -= cp;\n\t\n\tvec3 m = 1.0 / -rd;\n\tvec3 o = If(lessThan(rd, vec3(0.0)), -cth, cth);\n\t\n\tvec3 uf = (rp + o) * m;\n\tvec3 ub = (rp - o) * m;\n\t\n\tt.x = max(uf.x, max(uf.y, uf.z));\n\tt.y = min(ub.x, min(ub.y, ub.z));\n\t\n\t// if(ray start == inside cube) \n\tif(t.x < 0.0 && t.y > 0.0) {t.xy = t.yx;  return 1.0;}\n\t\n\treturn t.y < t.x ? 0.0 : (t.x > 0.0 ? 1.0 : -1.0);\n}\n\n/*\n[...]\n\nOUT:\n\tn0 : normal for t.x\n\tn1 : normal for t.y\n\nEXAMPLE:\t\n\tvec2 t; vec3 n0, n1;\n\tfloat hit = Intersect_Ray_Cube(pos, dir, vec3(0.0), vec3(0.5), OUT t, n0, n1);\n*/\nfloat Intersect_Ray_Cube(\nvec3 rp, vec3 rd, \nvec3 cp, vec3 cth, \nout vec2 t, out vec3 n0, out vec3 n1)\n{\t\n\trp -= cp;\n\t\n\tvec3 m = 1.0 / -rd;\n    vec3 os = If(lessThan(rd, vec3(0.0)), vec3(1.0), vec3(-1.0));\n    //vec3 os = sign(-rd);\n\tvec3 o = -cth * os;\n\t\n    \n\tvec3 uf = (rp + o) * m;\n\tvec3 ub = (rp - o) * m;\n\t\n\t//t.x = max(uf.x, max(uf.y, uf.z));\n\t//t.y = min(ub.x, min(ub.y, ub.z));\n\t\n    if(uf.x > uf.y) {t.x = uf.x; n0 = vec3(os.x, 0.0, 0.0);} else \n                    {t.x = uf.y; n0 = vec3(0.0, os.y, 0.0);}\n    if(uf.z > t.x ) {t.x = uf.z; n0 = vec3(0.0, 0.0, os.z);}\n    \n    if(ub.x < ub.y) {t.y = ub.x; n1 = vec3(os.x, 0.0, 0.0);} else \n                    {t.y = ub.y; n1 = vec3(0.0, os.y, 0.0);}\n    if(ub.z < t.y ) {t.y = ub.z; n1 = vec3(0.0, 0.0, os.z);}\n    \n    \n\t// if(ray start == inside cube) \n\tif(t.x < 0.0 && t.y > 0.0) \n    {\n        t.xy = t.yx;  \n        \n        vec3 n00 = n0;\n        n0 = n1;\n        n1 = n00;\n        \n        return 1.0;\n    }\n\t\n\treturn t.y < t.x ? 0.0 : (t.x > 0.0 ? 1.0 : -1.0);\n}\n\n/*\nIN:\n\trp\t\t: ray start position\n\trd\t\t: ray direction (normalized)\n\t\n\tsp2\t\t: sphere position\n\tsr2\t\t: sphere radius squared\n\t\nOUT:\n\tt\t\t: distances to intersection points (negative if in backwards direction)\n\nEXAMPLE:\t\n\tvec2 t;\n\tfloat hit = Intersect_Ray_Sphere(pos, dir, vec3(0.0), 1.0, OUT t);\n*/\nfloat Intersect_Ray_Sphere(\nvec3 rp, vec3 rd, \nvec3 sp, float sr2, \nout vec2 t)\n{\t\n\trp -= sp;\n\t\n\tfloat a = dot(rd, rd);\n\tfloat b = 2.0 * dot(rp, rd);\n\tfloat c = dot(rp, rp) - sr2;\n\t\n\tfloat D = b*b - 4.0*a*c;\n\t\n\tif(D < 0.0) return 0.0;\n\t\n\tfloat sqrtD = sqrt(D);\n\t// t = (-b + (c < 0.0 ? sqrtD : -sqrtD)) / a * 0.5;\n\tt = (-b + vec2(-sqrtD, sqrtD)) / a * 0.5;\n\t\n\t// if(start == inside) ...\n\tif(c < 0.0) t.xy = t.yx;\n\n\t// t.x > 0.0 || start == inside ? infront : behind\n\treturn t.x > 0.0 || c < 0.0 ? 1.0 : -1.0;\n}\n\nbvec2 minmask(vec2 v)\n{\n    bool x = v.x < v.y || isnan(v.y);\n    \n    return bvec2(x, !x);\n}\n\n\nbvec2 maxmask(vec2 v)\n{\n    bool x = v.x >= v.y || isnan(v.y);\n    \n    return bvec2(x, !x);\n}\n\n\nbvec3 minmask(vec3 v)\n{    \n    return bvec3(v.x <= v.y && v.x <= v.z,\n                 v.y <  v.z && v.y <  v.x,\n                 v.z <  v.x && v.z <= v.y);\n}\n\nbvec3 maxmask(vec3 v)\n{\n    return bvec3(v.x >= v.y && v.x >= v.z,\n                 v.y >  v.z && v.y >  v.x,\n                 v.z >  v.x && v.z >= v.y);\n}\n\nbvec3 minmask2(vec3 v)\n{\n    bool x = !(v.x >  v.y || v.x >  v.z) && !isnan(v.x);\n    bool y = !(v.y >= v.z || v.y >= v.x) && !isnan(v.y);\n    \n    return bvec3(x, y, !(x || y));\n}\n\nbvec3 maxmask2(vec3 v)\n{\n    bool x = !(v.x <  v.y || v.x <  v.z) && !isnan(v.x);\n    bool y = !(v.y <= v.z || v.y <= v.x) && !isnan(v.y);\n    \n    return bvec3(x, y, !(x || y));\n}\n\nvoid Intersect_Ray_CubeBackside(\nvec3 rp, vec3 rd, \nvec3 cp, vec3 cth, \nout float t, out vec3 N)\n{\t\n\trp -= cp;\n\t\n\tvec3 m = 1.0 / -rd;\n    vec3 os = If(lessThan(rd, vec3(0.0)), vec3(1.0), vec3(-1.0));\n\tvec3 o = -cth * os;\n\t\n\tvec3 ub = (rp - o) * m;\n\t\n    bvec3 mb = minmask2(ub);\n    \n    N = os * vec3(mb);\n    \n    t = mb.x ? ub.x : mb.y ? ub.y : ub.z;\n}\n\nbool IsInsideCube(vec3 p, vec3 cp, vec3 cd)\n{\n    vec3 b = abs(p - cp);\n    \n    return b.x < cd.x && b.y < cd.y && b.z < cd.z;\n}\n//==========================================================================================================//\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n\n////////////////////////////////////////////////////////////////////////////////////////////////////////////// scene intersection\n//==========================================================================================================//\nvoid Intersect_Ray_Cube(vec3 rp, vec3 rd, vec3 c0p, vec3 c0d, \n                        inout float hit, inout float t, inout vec3 n)\n{\n    vec2 tt; vec3 n0, n1;\n    float th = Intersect_Ray_Cube(rp, rd, c0p, c0d, /*out:*/ tt, n0, n1);\n\n    if(th > 0.0)\n    if(hit <= 0.0 || tt.x < t)\n    {\n        t = tt.x;\n        n = n0;\n\n        hit = 1.0;\n    }        \n}\n\nbool Intersect_Ray_Plate(vec3 rp, vec3 rd, vec3 c0p, vec3 c0d, float c1p_y, float c1dxz, float c1dy, float c1ps,\n                        inout float hit, inout float t, inout vec3 n)\n{\n    vec3 c1p = vec3(0.0, c1p_y, 0.0);\n    vec3 c1d = vec3(c1dxz, c1dy, c1dxz);\n\n    //c1p.y = 0.0;// remove tile pattern\n\n    c1p.xz = (floor(rp.xz*c1ps+0.5))/c1ps;\n\n    bool isInsideC0 = IsInsideCube(rp, c0p, c0d);\n    bool isInsideC1 = IsInsideCube(rp, c1p, c1d);\n\n    if(isInsideC0 && isInsideC1)\n    {\n        float t0; vec3 n0;\n        Intersect_Ray_CubeBackside(rp, rd, c1p, c1d, t0, n0);\n\n        if(IsInsideCube(rp+rd*t0, c0p, c0d))\n        {\n            if(hit <= 0.0 || t0 < t)\n            {\n                hit = 1.0;\n                t = t0;\n                n = n0;\n            \n                return true;\n            }\n        }\n    }\n    else\n    {\n        vec2 tt; vec3 n0, n1;\n        float th = Intersect_Ray_Cube(rp, rd, c0p, c0d, /*out:*/ tt, n0, n1);\n\n        bool hit0 = th > 0.0;\n        if ( hit0 )\n        {\n            c1p.xz = (floor((rp.xz+rd.xz*tt.x)*c1ps+0.5))/c1ps;\n            \n            if(IsInsideCube(rp+rd*tt.x, c1p, c1d))\n            {\n                float t0; vec3 n0;\n                Intersect_Ray_CubeBackside(rp, rd, c1p, c1d, t0, n0);\n\n                if(IsInsideCube(rp+rd*t0, c0p, c0d))\n                {\n                    if(hit <= 0.0 || t0 < t)\n                    {\n                        hit = 1.0;\n                        t = t0;\n                        n = n0;\n\n                        return true;\n                    }\n                }\n            }\n            else\n            {\n                if(hit <= 0.0 || tt.x < t)\n                {\n                    hit = 1.0;\n                    t = tt.x;\n                    n = n0;\n\n                    return true;\n                }\n            }\n\n        }        \n    }\n    \n    return false;\n}\n\nvec3 TransA(vec3 u, bool foo)\n{\n    if(foo)\n    {\n        u.xy = u.yx;\n        u.x *= -1.0;\n    }\n    else\n    {\n        u.x *= -1.0;\n        u.xy = u.yx;\n    }\n    \n    return u;\n}\n\nvec3 TransB(vec3 u, bool foo)\n{\n    if(foo)\n    {\n        u.zy = u.yz;\n        u.z *= -1.0;\n    }\n    else\n    {\n        u.z *= -1.0;\n        u.zy = u.yz;\n    }\n    \n    return u;\n}\n\n\nvoid Intersect_Ray_Plates(vec3 rp, vec3 rd, vec3 c0p, vec3 c0d, float c1p_y, float c1dxz, float c1dy, float c1ps,\n                         inout float hit, inout float t, inout vec3 n)\n{\n    rp.x += exp2(-18.0);\n    //if(false)\n    if(Intersect_Ray_Plate(TransA(rp, false), TransA(rd, false), c0p, c0d, c1p_y, c1dxz, c1dy, c1ps, /*inout*/ hit, t, n))\n    {\n        n = TransA(n, true);\n    }\n    //if(false)\n    if(Intersect_Ray_Plate(TransB(rp, false), TransB(rd, false), c0p, c0d, c1p_y, c1dxz, c1dy, c1ps, /*inout*/ hit, t, n))\n    {\n        n = TransB(n, true);\n    }    \n}\n\nfloat Intersect_Scene(\nvec3 rp, vec3 rd,\nout float t, out vec3 n, out vec3 a)\n{\n    float hit = 0.0;\n\n    float c1dxz = 0.4;\n    float c1ps = 0.85;\n\n    // ground plate thingy:\n    //if(false)\n    {\n        Intersect_Ray_Plate(rp, rd, vec3(0.0, -0.8, 0.0), vec3(2.0, 0.125*1.2, 2.0), -0.64, c1dxz,  0.125, c1ps, /*inout*/ hit, t, n);\n        \n        Intersect_Ray_Plates(rp, rd, vec3(0.0, -2., 0.0), vec3(2.0, 0.05, 2.0), -1.9, 0.2,  0.5, 2., /*inout*/ hit, t, n);\n    }\n    \n    // slim pillars:\n    //if(false)\n    {\n        float r = 0.125*0.25;\n        float u = 1.0/c1ps;\n        float l = 0.4;\n        float h = 1.0;\n        \n        vec3 c0p = vec3(c1dxz, l, c1dxz);\n         c0p = vec3(u - c1dxz, l, u - c1dxz);\n         c0p = vec3(u - c1dxz, l, c1dxz);\n        vec3 c0d = vec3(r, h, r);\n        \n        vec3 pa = vec3(u - c1dxz, l,     c1dxz);\n        vec3 pb = vec3(u - c1dxz, l, u - c1dxz);\n        vec3 pc = vec3(    c1dxz, l, u - c1dxz);\n        \n        //Intersect_Ray_Cube(rp, rd, c0p, c0d, /*inout*/ hit, t, n);\n        Intersect_Ray_Cube(rp, rd, pa, c0d, /*inout*/ hit, t, n);\n        Intersect_Ray_Cube(rp, rd, pb, c0d, /*inout*/ hit, t, n);\n        Intersect_Ray_Cube(rp, rd, pc, c0d, /*inout*/ hit, t, n);\n        \n        pa = vec3(-pa.z, pa.y, pa.x);\n        pb = vec3(-pb.z, pb.y, pb.x);\n        pc = vec3(-pc.z, pc.y, pc.x);\n        \n        Intersect_Ray_Cube(rp, rd, pa, c0d, /*inout*/ hit, t, n);\n        Intersect_Ray_Cube(rp, rd, pb, c0d, /*inout*/ hit, t, n);\n        Intersect_Ray_Cube(rp, rd, pc, c0d, /*inout*/ hit, t, n);\n        \n        pa = vec3(-pa.z, pa.y, pa.x);\n        pb = vec3(-pb.z, pb.y, pb.x);\n        pc = vec3(-pc.z, pc.y, pc.x);\n        \n        #if 0\n        Intersect_Ray_Cube(rp, rd, pa, c0d, /*inout*/ hit, t, n);\n        Intersect_Ray_Cube(rp, rd, pb, c0d, /*inout*/ hit, t, n);\n        Intersect_Ray_Cube(rp, rd, pc, c0d, /*inout*/ hit, t, n);\n        #endif\n        \n        pa = vec3(-pa.z, pa.y, pa.x);\n        pb = vec3(-pb.z, pb.y, pb.x);\n        pc = vec3(-pc.z, pc.y, pc.x);\n        \n        Intersect_Ray_Cube(rp, rd, pa, c0d, /*inout*/ hit, t, n);\n        Intersect_Ray_Cube(rp, rd, pb, c0d, /*inout*/ hit, t, n);\n        Intersect_Ray_Cube(rp, rd, pc, c0d, /*inout*/ hit, t, n);\n    }\n    \n    // top sphere:\n    //if(false)\n    {\n        vec2 tt;\n\t\tfloat th = Intersect_Ray_Sphere(rp, rd, vec3(0.0), 0.5, /*out:*/ tt);\n        \n        if(th > 0.0)\n        if(hit <= 0.0 || tt.x < t)\n        {\n            t = tt.x;\n            n = normalize(rp + rd * tt.x);\n            a = vec3(1.0);\n            \n            hit = 1.0;\n        }\n    }\n    \n    // bottom sphere:\n    if(false)\n    {\n        vec2 tt;\n\t\tfloat th = Intersect_Ray_Sphere(rp, rd, vec3(0.0, -2.25, 0.0), 2.0, /*out:*/ tt);\n        \n        if(th > 0.0)\n        if(hit <= 0.0 || tt.x < t)\n        {\n            t = tt.x;\n            n = normalize(rp + rd * tt.x - vec3(0.0, -2.25, 0.0));\n            a = vec3(1.0);\n            \n            hit = 1.0;\n        }\n    }\n    \n    if(hit <= 0.0)\n    {\n        t = exp2(20.0);\n        n = vec3(0.0);\n        a = vec3(0.0);\n    }\n    \n    return hit;\n}\n//==========================================================================================================//\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n////////////////////////////////////////////////////////////////////////////////////////////////////////////// sampling routines\n//==========================================================================================================//\n\n// s0 [-1..1], s1 [-1..1]\n// samples spherical cap for s1 [cosAng05..1]\n// samples hemisphere if s1 [0..1]\nvec3 Sample_Sphere(float s0, float s1)\n{\n    float ang = Pi * s0;\n    float s1p = sqrt(1.0 - s1*s1);\n    \n    return vec3(cos(ang) * s1p, \n                           s1 , \n                sin(ang) * s1p);\n}\n\nvec3 Sample_Sphere(vec2 s) { return Sample_Sphere(s.x, s.y); }\n\n//==========================================================================================================//\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n// interleaved gradient noise | license: unclear\n// Jorge Jimenez http://www.iryoku.com/next-generation-post-processing-in-call-of-duty-advanced-warfare\nfloat IGN(vec2 uv) { return fract(52.9829189 * fract(dot(uv, vec2(0.06711056, 0.00583715)))); }\n\nfloat IGN(vec2 uv, uint frame)\n{\n    frame = frame % 64u;\n    \n    uv += 5.588238 * float(frame);\n    \n    return IGN(uv);\n}\n\n// linearizes uv using a Hilbert curve; tile dimension = 2^N\nuint EvalHilbertCurve(uvec2 uv, uint N)\n{\n    uint C = 0xB4361E9Cu;// cost lookup\n    uint P = 0xEC7A9107u;// pattern lookup\n    \n    uint c = 0u;// accumulated cost\n    uint p = 0u;// current pattern\n\n    for(uint i = N; --i < N;)\n    {\n        uvec2 m = (uv >> i) & 1u;// local uv\n\n        uint n = m.x ^ (m.y << 1u);// linearized local uv\n\n        uint o = (p << 3u) ^ (n << 1u);// offset into lookup tables\n\n        c += ((C >> o) & 3u) << (i << 1u);// accu cost (scaled by level)\n\n        p = (P >> o) & 3u;// update pattern\n    }\n    \n    return c;\n}\n\n////////////////////////////////////////////////////////////////////////////////////////////////////////////// low-discrepancy sobol noise\n//==========================================================================================================//\n// \"Shuffled Scrambled Sobol (2D)\" - https://www.shadertoy.com/view/3lcczS | license: unclear\n//  code taken from \"Practical Hash-based Owen Scrambling\" - http://www.jcgt.org/published/0009/04/01/\nuint reverse_bits(uint x) \n{\n    x = (((x & 0xaaaaaaaau) >> 1) | ((x & 0x55555555u) << 1));\n    x = (((x & 0xccccccccu) >> 2) | ((x & 0x33333333u) << 2));\n    x = (((x & 0xf0f0f0f0u) >> 4) | ((x & 0x0f0f0f0fu) << 4));\n    x = (((x & 0xff00ff00u) >> 8) | ((x & 0x00ff00ffu) << 8));\n    \n    return ((x >> 16) | (x << 16));\n}\n\n// license: unclear\nuint laine_karras_permutation(uint x, uint seed) \n{\n    x += seed;\n    x ^= x*0x6c50b47cu;\n    x ^= x*0xb82f1e52u;\n    x ^= x*0xc7afe638u;\n    x ^= x*0x8d22f6e6u;\n    \n    return x;\n}\n\n// license: unclear\nuint nested_uniform_scramble(uint x, uint seed) \n{\n    x = reverse_bits(x);\n    x = laine_karras_permutation(x, seed);\n    x = reverse_bits(x);\n    \n    return x;\n}\n\n// from https://www.shadertoy.com/view/3ldXzM | license: unclear\nuvec2 sobol_2d(uint index) \n{\n    uvec2 p = uvec2(0u);\n    uvec2 d = uvec2(0x80000000u);\n\n    for(; index != 0u; index >>= 1u) \n    {\n        if((index & 1u) != 0u) \n        {\n            p ^= d;\n        }\n\n        d.x >>= 1u;  // 1st dimension Sobol matrix, is same as base 2 Van der Corput\n        d.y ^= d.y >> 1u; // 2nd dimension Sobol matrix\n    }\n    \n    return p;\n}\n\n// license: unclear\nuvec2 shuffled_scrambled_sobol_2d(uint index, uint seed) \n{\n    index = nested_uniform_scramble(index, seed);\n    \n    uvec2 p = sobol_2d(index);\n    \n    seed = seed * 2891336453u + 1u;\n    p.x = nested_uniform_scramble(p.x, seed );\n    seed = seed * 2891336453u + 1u;\n    p.y = nested_uniform_scramble(p.y, seed);\n   \n    return p;\n}\n\nuint shuffled_scrambled_sobol_angle01(uint x, uint seed) \n{\n    x = reverse_bits(x);\n    \n    x = laine_karras_permutation(x, seed);\n    \n    return x;\n}\n//==========================================================================================================//\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// RNG\n//==============================================================================================================================================//\nuint  asuint2(float x) { return x == 0.0 ? 0u : floatBitsToUint(x); }\nuvec2 asuint2(vec2 x) { return uvec2(asuint2(x.x ), asuint2(x.y)); }\nuvec3 asuint2(vec3 x) { return uvec3(asuint2(x.xy), asuint2(x.z)); }\nuvec4 asuint2(vec4 x) { return uvec4(asuint2(x.xy), asuint2(x.zw)); }\n\nfloat Float01(uint x) { return float(    x ) * (1.0 / 4294967296.0); }\nfloat Float11(uint x) { return float(int(x)) * (1.0 / 2147483648.0); }\n\nvec2 Float01(uvec2 x) { return vec2(      x ) * (1.0 / 4294967296.0); }\nvec2 Float11(uvec2 x) { return vec2(ivec2(x)) * (1.0 / 2147483648.0); }\n\nvec3 Float01(uvec3 x) { return vec3(      x ) * (1.0 / 4294967296.0); }\nvec3 Float11(uvec3 x) { return vec3(ivec3(x)) * (1.0 / 2147483648.0); }\n\nvec4 Float01(uvec4 x) { return vec4(      x ) * (1.0 / 4294967296.0); }\nvec4 Float11(uvec4 x) { return vec4(ivec4(x)) * (1.0 / 2147483648.0); }\n\n// http://extremelearning.com.au/unreasonable-effectiveness-of-quasirandom-sequences/\n// https://probablydance.com/2018/06/16/fibonacci-hashing-the-optimization-that-the-world-forgot-or-a-better-alternative-to-integer-modulo/\nconst float rPhif1 =      0.6180340;\nconst vec2  rPhif2 = vec2(0.7548777, 0.5698403);\nconst vec3  rPhif3 = vec3(0.8191725, 0.6710436, 0.5497005);\nconst vec4  rPhif4 = vec4(0.8566749, 0.7338919, 0.6287067, 0.5385973);\n\nconst uint  rPhi1 =       2654435769u;\nconst uvec2 rPhi2 = uvec2(3242174889u, 2447445413u);\nconst uvec3 rPhi3 = uvec3(3518319153u, 2882110345u, 2360945575u);\nconst uvec4 rPhi4 = uvec4(3679390609u, 3152041523u, 2700274805u, 2313257605u);\n\n// low bias version | https://nullprogram.com/blog/2018/07/31/ | license: public domain (http://unlicense.org/)\nuint WellonsHash(uint x)\n{\n    x ^= x >> 16u;\n    x *= 0x7feb352dU;\n    x ^= x >> 15u;\n    x *= 0x846ca68bU;\n    x ^= x >> 16u;\n\n    return x;\n}\n\n// minimal bias version | https://nullprogram.com/blog/2018/07/31/ | license: public domain (http://unlicense.org/)\nuint WellonsHash2(uint x)\n{\n    x ^= x >> 17u;\n    x *= 0xed5ad4bbU;\n    x ^= x >> 11u;\n    x *= 0xac4c1b51U;\n    x ^= x >> 15u;\n    x *= 0x31848babU;\n    x ^= x >> 14u;\n\n    return x;\n}\n\n// http://marc-b-reynolds.github.io/math/2016/03/29/weyl_hash.html | license: public domain (http://unlicense.org/)\nuint WeylHash(uvec2 c)\n{ \n    return ((c.x * 0x3504f333u) ^ (c.y * 0xf1bbcdcbu)) * 741103597u;\n}\n\n// Pierre L'Ecuyer - \"TABLES OF LINEAR CONGRUENTIAL GENERATORS OF DIFFERENT SIZES AND GOOD LATTICE STRUCTURE\"\n// https://www.ams.org/journals/mcom/1999-68-225/S0025-5718-99-00996-5/S0025-5718-99-00996-5.pdf\nconst uint lcgM = 2891336453u;// ideal for 32 bits with odd c\n\nuint lcg(uint h)\n{\n    return h * lcgM + 0x5C995C6Du;\n}\n\n#define SEED uvec4(0x5C995C6Du, 0x6A3C6A57u, 0xC65536CBu, 0x3563995Fu)\n\n// Melissa E. O’Neill - \"PCG: A Family of Simple Fast Space-Efficient Statistically Good Algorithms for Random Number Generation\"\n// https://www.cs.hmc.edu/tr/hmc-cs-2014-0905.pdf\n\n// Mark Jarzynski & Marc Olano - \"Hash Functions for GPU Rendering\"\n// http://jcgt.org/published/0009/03/02/ | https://www.shadertoy.com/view/XlGcRh\nuvec3 pcg3Mix(uvec3 h)\n{\n    h.x += h.y * h.z; \n    h.y += h.z * h.x; \n    h.z += h.x * h.y;\n    \n    return h;\n}\n\nuvec3 pcg3Permute(uvec3 h)\n{\n    h = pcg3Mix(h);\n\n    h ^= h >> 16u;\n    \n    return pcg3Mix(h);\n}\n\nuvec3 pcg3(inout uint state)\n{\n    state = lcg(state);\n\n    return pcg3Permute(uvec3(2447445413u, state, 3242174889u));\n}\n\nuvec3 pcg3(uvec3 h, uint seed)\n{\n    uvec3 c = (seed << 1u) ^ SEED.xyz;\n    \n    return pcg3Permute(h * lcgM + c);\n}\n\nuvec4 pcg4Mix(uvec4 h)\n{\n    h.x += h.y * h.w; \n    h.y += h.z * h.x; \n    h.z += h.x * h.y;\n    h.w += h.y * h.z;\n    \n    return h;\n}\n\nuvec4 pcg4Permute(uvec4 h)\n{\n    h = pcg4Mix(h);\n\n    h ^= h >> 16u;\n    \n    return pcg4Mix(h);\n}\n\nuvec4 pcg4(inout uint state)\n{\n    state = lcg(state);\n\n    return pcg4Permute(uvec4(2882110345u, state, 3518319153u, 2360945575u));\n}\n\nuvec4 pcg4(uvec4 h, uint seed)\n{\n    uvec4 c = (seed << 1u) ^ SEED;\n\n    return pcg4Permute(h * lcgM + c);\n}\n\nuint pcg(inout uint state)\n{\n    state = lcg(state);\n    \n    uint word = ((state >> ((state >> 28u) + 4u)) ^ state) * 277803737u;\n    \n    return (word >> 22u) ^ word;\n}\n\nuint pcg(uint h, uint seed)\n{\n    uint c = (seed << 1u) ^ SEED.x;\n\n    h = h * lcgM + c;\n    \n    h = ((h >> ((h >> 28u) + 4u)) ^ h) * 277803737u;\n    \n    return (h >> 22u) ^ h;\n}\n\n#undef SEED\n\n//---------------------------------------------------------------------------------------------//\n\nuint  Hash(uint  h, uint seed) { return pcg(h, seed); }\nuvec2 Hash(uvec2 h, uint seed) { return pcg3(uvec3(h, 0u), seed).xy; }\nuvec3 Hash(uvec3 h, uint seed) { return pcg3(h, seed); }\nuvec4 Hash(uvec4 h, uint seed) { return pcg4(h, seed); }\n\nvec4 Hash01x4(vec4  v, uint seed) { return Float01(pcg4(asuint2(v), seed)); }\nvec4 Hash01x4(vec3  v, uint seed) { return Hash01x4(vec4(v, 0.0          ), seed); }\nvec4 Hash01x4(vec2  v, uint seed) { return Hash01x4(vec4(v, 0.0, 0.0     ), seed); }\nvec4 Hash01x4(float v, uint seed) { return Hash01x4(vec4(v, 0.0, 0.0, 0.0), seed); }\n\nvec3 Hash01x3(vec4  v, uint seed) { return Float01(pcg4(asuint2(v), seed).xyz); }\nvec3 Hash01x3(vec3  v, uint seed) { return Float01(pcg3(asuint2(v), seed)); }\nvec3 Hash01x3(vec2  v, uint seed) { return Hash01x3(vec3(v, 0.0     ), seed); }\nvec3 Hash01x3(float v, uint seed) { return Hash01x3(vec3(v, 0.0, 0.0), seed); }\n\nvec2 Hash01x2(vec4  v, uint seed) { return Float01(pcg4(asuint2(v), seed).xy); }\nvec2 Hash01x2(vec3  v, uint seed) { return Float01(pcg3(asuint2(v), seed).xy); }\nvec2 Hash01x2(vec2  v, uint seed) { return Hash01x3(vec3(v, 0.0     ), seed).xy; }\nvec2 Hash01x2(float v, uint seed) { return Hash01x3(vec3(v, 0.0, 0.0), seed).xy; }\n\nfloat Hash01(vec4  v, uint seed) { return Float01(pcg4(asuint2(v), seed).x); }\nfloat Hash01(vec3  v, uint seed) { return Float01(pcg3(asuint2(v), seed).x); }\nfloat Hash01(vec2  v, uint seed) { return Float01(pcg3(asuint2(vec3(v, 0.0)), seed).x); }\nfloat Hash01(float v, uint seed) { return Float01(pcg(asuint2(v), seed)); }\n\n\nvec4 Hash11x4(vec4  v, uint seed) { return Float11(pcg4(asuint2(v), seed)); }\nvec4 Hash11x4(vec3  v, uint seed) { return Hash11x4(vec4(v, 0.0          ), seed); }\nvec4 Hash11x4(vec2  v, uint seed) { return Hash11x4(vec4(v, 0.0, 0.0     ), seed); }\nvec4 Hash11x4(float v, uint seed) { return Hash11x4(vec4(v, 0.0, 0.0, 0.0), seed); }\n\nvec3 Hash11x3(vec4  v, uint seed) { return Float11(pcg4(asuint2(v), seed).xyz); }\nvec3 Hash11x3(vec3  v, uint seed) { return Float11(pcg3(asuint2(v), seed)); }\nvec3 Hash11x3(vec2  v, uint seed) { return Hash11x3(vec3(v, 0.0     ), seed); }\nvec3 Hash11x3(float v, uint seed) { return Hash11x3(vec3(v, 0.0, 0.0), seed); }\n\nvec2 Hash11x2(vec4  v, uint seed) { return Float11(pcg4(asuint2(v), seed).xy); }\nvec2 Hash11x2(vec3  v, uint seed) { return Float11(pcg3(asuint2(v), seed).xy); }\nvec2 Hash11x2(vec2  v, uint seed) { return Hash11x3(vec3(v, 0.0     ), seed).xy; }\nvec2 Hash11x2(float v, uint seed) { return Hash11x3(vec3(v, 0.0, 0.0), seed).xy; }\n\nfloat Hash11(vec4  v, uint seed) { return Float11(pcg4(asuint2(v), seed).x); }\nfloat Hash11(vec3  v, uint seed) { return Float11(pcg3(asuint2(v), seed).x); }\nfloat Hash11(vec2  v, uint seed) { return Float11(pcg3(asuint2(vec3(v, 0.0)), seed).x); }\nfloat Hash11(float v, uint seed) { return Float11(pcg(asuint2(v), seed)); }\n\n\nvec4 Hash01x4(uvec4 v, uint seed) { return Float01(pcg4(v, seed)); }\nvec4 Hash01x4(uvec3 v, uint seed) { return Hash01x4(uvec4(v, 0u        ), seed); }\nvec4 Hash01x4(uvec2 v, uint seed) { return Hash01x4(uvec4(v, 0u, 0u    ), seed); }\nvec4 Hash01x4(uint  v, uint seed) { return Hash01x4(uvec4(v, 0u, 0u, 0u), seed); }\n\nvec3 Hash01x3(uvec4 v, uint seed) { return Float01(pcg4(v, seed).xyz); }\nvec3 Hash01x3(uvec3 v, uint seed) { return Float01(pcg3(v, seed)); }\nvec3 Hash01x3(uvec2 v, uint seed) { return Hash01x3(uvec3(v, 0u    ), seed); }\nvec3 Hash01x3(uint  v, uint seed) { return Hash01x3(uvec3(v, 0u, 0u), seed); }\n\nvec2 Hash01x2(uvec4 v, uint seed) { return Float01(pcg4(v, seed).xy); }\nvec2 Hash01x2(uvec3 v, uint seed) { return Float01(pcg3(v, seed).xy); }\nvec2 Hash01x2(uvec2 v, uint seed) { return Hash01x3(uvec3(v, 0u    ), seed).xy; }\nvec2 Hash01x2(uint  v, uint seed) { return Hash01x3(uvec3(v, 0u, 0u), seed).xy; }\n\nfloat Hash01(uvec4 v, uint seed) { return Float01(pcg4(v, seed).x); }\nfloat Hash01(uvec3 v, uint seed) { return Float01(pcg3(v, seed).x); }\nfloat Hash01(uvec2 v, uint seed) { return Float01(pcg3(uvec3(v, 0u), seed).x); }\nfloat Hash01(uint  v, uint seed) { return Float01(pcg(v, seed)); }\n\n\nvec4 Hash11x4(uvec4 v, uint seed) { return Float11(pcg4(v, seed)); }\nvec4 Hash11x4(uvec3 v, uint seed) { return Hash11x4(uvec4(v, 0u        ), seed); }\nvec4 Hash11x4(uvec2 v, uint seed) { return Hash11x4(uvec4(v, 0u, 0u    ), seed); }\nvec4 Hash11x4(uint  v, uint seed) { return Hash11x4(uvec4(v, 0u, 0u, 0u), seed); }\n\nvec3 Hash11x3(uvec4 v, uint seed) { return Float11(pcg4(v, seed).xyz); }\nvec3 Hash11x3(uvec3 v, uint seed) { return Float11(pcg3(v, seed)); }\nvec3 Hash11x3(uvec2 v, uint seed) { return Hash11x3(uvec3(v, 0u    ), seed); }\nvec3 Hash11x3(uint  v, uint seed) { return Hash11x3(uvec3(v, 0u, 0u), seed); }\n\nvec2 Hash11x2(uvec4 v, uint seed) { return Float11(pcg4(v, seed).xy); }\nvec2 Hash11x2(uvec3 v, uint seed) { return Float11(pcg3(v, seed).xy); }\nvec2 Hash11x2(uvec2 v, uint seed) { return Hash11x3(uvec3(v, 0u    ), seed).xy; }\nvec2 Hash11x2(uint  v, uint seed) { return Hash11x3(uvec3(v, 0u, 0u), seed).xy; }\n\nfloat Hash11(uvec4 v, uint seed) { return Float11(pcg4(v, seed).x); }\nfloat Hash11(uvec3 v, uint seed) { return Float11(pcg3(v, seed).x); }\nfloat Hash11(uvec2 v, uint seed) { return Float11(pcg3(uvec3(v, 0u), seed).x); }\nfloat Hash11(uint  v, uint seed) { return Float11(pcg(v, seed)); }\n\n//==============================================================================================================================================//\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"/*\n    This work is licensed under a dual license, public domain and MIT, unless noted otherwise. Choose the one that best suits your needs:\n    \n    CC0 1.0 Universal https://creativecommons.org/publicdomain/zero/1.0/\n    To the extent possible under law, the author has waived all copyrights and related or neighboring rights to this work.\n    \n    or\n    \n    The MIT License\n    Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), \n    to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, \n    and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: \n    The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. \n    THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \n    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, \n    DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR \n    THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n\n/*\n    G-buffer rendering: vec4(world space normal.xyz, linear depth)\n    \n    Camera controls via mouse + shift key.\n*/\n\n\n#define KeyBoard iChannel1\n\nfloat ReadKey(int keyCode) {return texelFetch(KeyBoard, ivec2(keyCode, 0), 0).x;}\nfloat ReadKeyToggle(int keyCode) {return texelFetch(KeyBoard, ivec2(keyCode, 2), 0).x;}\n\n#define VarTex iChannel3\n#define OutCol outCol\n#define OutChannel w\n\n#define WriteVar(v, cx, cy) {if(uv.x == uint(cx) && uv.y == uint(cy)) OutCol.OutChannel = v;}\n#define WriteVar4(v, cx, cy) {WriteVar(v.x, cx, cy) WriteVar(v.y, cx, cy + 1) WriteVar(v.z, cx, cy + 2) WriteVar(v.w, cx, cy + 3)}\n\nfloat ReadVar(int cx, int cy) {return texelFetch(VarTex, ivec2(cx, cy), 0).OutChannel;}\nvec4 ReadVar4(int cx, int cy) {return vec4(ReadVar(cx, cy), ReadVar(cx, cy + 1), ReadVar(cx, cy + 2), ReadVar(cx, cy + 3));}\n\n\nvoid mainImage(out vec4 outCol, in vec2 uv0)\n{     \n    Resolution = iResolution.xy;\n    \n    uvec2 uv = uvec2(uv0.xy - 0.5);\n\tvec2 tex = uv0.xy / iResolution.xy;\n    vec2 tex21 = tex * 2.0 - vec2(1.0);\n    \n    uint frame = uint(iFrame);\n    \n    vec4 mouseAccu = ReadVar4(1, VAR_ROW);\n\n    PrepareCam(mouseAccu, USE_PERSPECTIVE_CAM_COND);\n    \n    vec3 rp, rd;\n    GetRay(uv0, /*out*/ rp, rd);\n    \n    float t; vec3 N; vec3 a;\n    Intersect_Scene(rp, rd, /*out:*/ t, N, a);    \n    \n    vec3 wpos = rp + rd * t;\n    \n    vec3 vpos = VPos_from_WPos(wpos);\n    \n    // N     : world space normal.xyz\n    // vpos.z: linear depth\n    outCol = vec4(N, vpos.z);\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":2,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"/*\n    This work is licensed under a dual license, public domain and MIT, unless noted otherwise. Choose the one that best suits your needs:\n    \n    CC0 1.0 Universal https://creativecommons.org/publicdomain/zero/1.0/\n    To the extent possible under law, the author has waived all copyrights and related or neighboring rights to this work.\n    \n    or\n    \n    The MIT License\n    Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), \n    to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, \n    and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: \n    The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. \n    THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \n    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, \n    DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR \n    THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n\n////////////////////////////////////////////////////////////////////////////////////// config\n//==================================================================================//\n\n/*\n    toggles:\n    \n    Tab  : toggle temporal accumulation on/off\n    Ctrl : toggle ortho cam off/on\n\n    U    : toggle UI off/on\n*/\n\n/*\n    1: uniform sampling + slice weighting\n    2: exact  importance sampling via 2 random numbers\n    3: approx importance sampling via 1 random number (default)\n*/\n#define GTAO_SLICE_SAMPLING_MODE 3\n\n//#define  GTAO_USE_WHITE_NOISE\n//#define REFAO_USE_WHITE_NOISE\n\n/*\n    1: GTAOFastAcos         : fastest; good enough\n    2: improved GTAOFastAcos: slightly slower than 1, but quite a bit better\n    3: acos                 : very slow, but very accurate (useful for testing/debugging)\n*/\n#define ACOS_QUALITY_MODE 2\n\n//#define USE_INFINITE_THICKNESS\n\n#if 0\n    // use high quality variants for testing (so there is as little unintentional bias as possible when comparing to reference)\n    #undef  ACOS_QUALITY_MODE\n    #define ACOS_QUALITY_MODE 3\n    \n   #if 1\n    // when using mode 1 or 2 + white noise + Thickness = inf, GTAO+ converges exactly to the reference (but mode 3 is the more practical one)\n    #undef  GTAO_SLICE_SAMPLING_MODE\n    #define GTAO_SLICE_SAMPLING_MODE 2\n    #define GTAO_USE_WHITE_NOISE\n    #define USE_INFINITE_THICKNESS\n   #endif\n#endif\n\n// #define USE_ANALYTICAL_RAYCASTING\n\nconst float Raymarching_SampleCount = 32.0;\nconst float Raymarching_Width = 512.0;\n#ifdef USE_INFINITE_THICKNESS\nconst float Thickness = 1.0/0.0;\n#else\nconst float Thickness = 0.5;\n#endif\n//==================================================================================//\n////////////////////////////////////////////////////////////////////////////////////// \n\n\nbool isLeft;// true on the left half of the screen; for debugging purposes\n\n#define KeyBoard iChannel3\n\nfloat ReadKey(int keyCode) {return texelFetch(KeyBoard, ivec2(keyCode, 0), 0).x;}\nfloat ReadKeyToggle(int keyCode) {return texelFetch(KeyBoard, ivec2(keyCode, 2), 0).x;}\n\n#define VarTex iChannel3\n#define OutCol outCol\n#define OutChannel w\n\n#define WriteVar(v, cx, cy) {if(uv.x == uint(cx) && uv.y == uint(cy)) OutCol.OutChannel = v;}\n#define WriteVar4(v, cx, cy) {WriteVar(v.x, cx, cy) WriteVar(v.y, cx, cy + 1) WriteVar(v.z, cx, cy + 2) WriteVar(v.w, cx, cy + 3)}\n\nfloat ReadVar(int cx, int cy) {return texelFetch(VarTex, ivec2(cx, cy), 0).OutChannel;}\nvec4 ReadVar4(int cx, int cy) {return vec4(ReadVar(cx, cy), ReadVar(cx, cy + 1), ReadVar(cx, cy + 2), ReadVar(cx, cy + 3));}\n\n\n////////////////////////////////////////////////////////////////////////////////////// atan/acos/asin approx\n//==================================================================================//\n\n// https://www.shadertoy.com/view/lXBfWm\n// dir: normalized vector | out: angle in radians [-Pi, Pi] (max abs error ~0.000000546448 rad)\nfloat ArcTan(vec2 dir)\n{\n    const float Pi = 3.14159265359;\n\n    float x = abs(dir.x);\n    float y =     dir.y;\n    \n    //float u = 0.63662 + x * (0.405285 + x * (-0.0602976 + x * (0.0289292 + x * (-0.0162831 + (0.0075353 - 0.00178826 * x) * x))));\n    float u = 0.63662 + x * (0.405285 + x * (-0.0602976 + (0.0261141 - 0.00772104 * x) * x));// max abs err ~0.0000454545 rad\n          \n    float f = y / u;\n    \n    if(dir.x < 0.0) f = (dir.y < 0.0 ? -Pi : Pi) - f;\n    \n    return f;\n}\n\nfloat ArcTan11(vec2 dir)// == ArcTan(dir) / Pi\n{\n    float x = abs(dir.x);\n    float y =     dir.y;\n    \n    //float u = 2.0 + x * (1.27324 + x * (-0.189431 + x * (0.0908837 + x * (-0.0511549 + (0.0236728 - 0.005618 * x) * x))));\n    float u = 2.0 + x * (1.27324 + x * (-0.189431 + (0.08204 - 0.0242564 * x) * x));\n          \n    float f = y / u;\n    \n    if(dir.x < 0.0) f = (dir.y < 0.0 ? -1.0 : 1.0) - f;\n    \n    return f;\n}\n\nfloat ACosPoly(float x)\n{\n#if ACOS_QUALITY_MODE == 1\n    // GTAOFastAcos\n    return 1.5707963267948966 - 0.1565827644218014 * x;\n#else    \n    // higher quality version of GTAOFastAcos (for the cost of one additional mad)\n    // minimizes max abs(ACos_Approx(cos(x)) - x)\n    return 1.5707963267948966 + (-0.20491203466059038 + 0.04832927023878897 * x) * x;\n#endif    \n}\n\nfloat ACos_Approx(float x)\n{\n    float u = ACosPoly(abs(x)) * sqrt(1.0 - abs(x));\n\t\t\t\n    return x >= 0.0 ? u : Pi - u;\n}\n\nfloat ACos01_Approx(float x)// x: [0,1]\n{\n    return ACosPoly(x) * sqrt(1.0 - x);\n}\n\nfloat ASin_Approx(float x)\n{\n    float u = ACosPoly(abs(x)) * sqrt(1.0 - abs(x)) - 1.5707963267948966;\n\t\t\t\n    return x >= 0.0 ? -u : u;    \n}\n\nfloat ASin01_Approx(float x)// x: [0,1]\n{\n\treturn 1.5707963267948966 - ACosPoly(x) * sqrt(1.0 - x);\n}\n\n#if ACOS_QUALITY_MODE == 1 || ACOS_QUALITY_MODE == 2\nfloat ACos(float x)\n{\n    return ACos_Approx(clamp(x, -1.0, 1.0));\n}\n#else\nfloat ACos(float x)// very slow; for debugging\n{   \n    return acos(clamp(x, -1.0, 1.0));\n}\n#endif\n\nvec2 ACos(vec2 v)\n{\n    return vec2(ACos(v.x), ACos(v.y));\n}\n\nvec3 ACos(vec3 v)\n{\n    return vec3(ACos(v.x), ACos(v.y), ACos(v.z));\n}\n\n//==================================================================================//\n//////////////////////////////////////////////////////////////////////////////////////\n\n\n////////////////////////////////////////////////////////////////////////////////////// partial slice sampling\n//==================================================================================//\n\nvec2 cmul(vec2 c0, vec2 c1)\n{\n\treturn vec2(c0.x * c1.x - c0.y * c1.y, \n\t\t        c0.y * c1.x + c0.x * c1.y);\n}\n\nfloat SamplePartialSlice(float x, float sin_thVN)\n{\n    const float Pi   = 3.1415926535897930;\n    const float Pi05 = 1.5707963267948966;\n    \n    if(x == 0.0 || abs(x) >= 1.0) return x;\n    \n    bool sgn = x < 0.0;\n    x = abs(x);\n    \n    float s = sin_thVN;\n    \n  #if 1\n    float o = s - s * s;\n    float slp0 = 1.0 / (1.0 + (Pi  - 1.0        ) * (s - o * 0.30546           ));\n    float slp1 = 1.0 / (1.0 - (1.0 - exp2(-20.0)) * (s + o * mix(0.5, 0.785, s)));\n    \n    float k = mix(0.1, 0.25, s);  \n  #else\n    // slightly better, but also slower\n    float angVN = ASin01_Approx(s);\n    float c = cos(angVN);\n    \n    float slp0 = 1.0 / (c + s * (    angVN  + Pi05));\n    float slp1 = 1.0 / (c + s * (abs(angVN) - Pi05));\n    \n    float sb = s + (s - s*s) * -0.1;\n    float cb = c + (c - c*c) * -0.;\n    \n    float k = sb * cb * 0.494162;\n  #endif\n    \n    float a = 1.0 - (Pi - 2.0) / (Pi - 1.0);\n    float b = 1.0 / (Pi - 1.0);\n    \n    float d0 =   a - slp0 * b;\n    float d1 = 1.0 - slp1;\n    \n    float f0 = d0 * (Pi * x - ASin01_Approx(x));\n    float f1 = d1 * (     x - 1.0);\n    \n    float kk = k * k;\n    \n    float h0 = sqrt(f0*f0 + kk) - k;\n    float h1 = sqrt(f1*f1 + kk) - k;\n    \n    float hh = (h0 * h1) / (h0 + h1);\n    \n    float y = x - sqrt(hh*(hh + 2.0*k));\n    \n    return sgn ? -y : y;\n}\n\n// vvsN: view vec space normal | rnd01: [0, 1]\nvec2 SamplePartialSliceDir(vec3 vvsN, float rnd01)\n{\n    float ang0 = rnd01 * Pi2;\n    \n    vec2 dir0 = vec2(cos(ang0), sin(ang0));\n\n    float l = length(vvsN.xy);\n\n    if(l == 0.0) return dir0;\n    \n    vec2 n = vvsN.xy / l;    \n    \n    // align n with x-axis\n    dir0 = cmul(dir0, n * vec2(1.0, -1.0));\n\n    // sample slice angle\n    float ang;\n    {\n        float x = ArcTan11(dir0);\n        float sinNV = l;\n\n        ang = SamplePartialSlice(x, sinNV) * Pi;\n    }\n    \n    // ray space slice direction\n    vec2 dir = vec2(cos(ang), sin(ang));\n    \n    // align x-axis with n\n    dir = cmul(dir, n);\n    \n    return dir;\n}\n\n//==================================================================================//\n//////////////////////////////////////////////////////////////////////////////////////\n\n\n////////////////////////////////////////////////////////////////////////////////////// quaternion utils\n//==================================================================================//\n\nvec4 GetQuaternion(vec3 from, vec3 to)\n{\n    vec3 xyz = cross(from, to);\n    float s  =   dot(from, to);\n\n    float u = inversesqrt(max(0.0, s * 0.5 + 0.5));// rcp(cosine half-angle formula)\n    \n    s    = 1.0 / u;\n    xyz *= u * 0.5;\n\n    return vec4(xyz, s);  \n}\n\nvec4 GetQuaternion(vec3 to)\n{\n    //vec3 from = vec3(0.0, 0.0, 1.0);\n\n    vec3 xyz = vec3(-to.y, to.x, 0.0);// cross(from, to);\n    float s  =                   to.z;//   dot(from, to);\n\n    float u = inversesqrt(max(0.0, s * 0.5 + 0.5));// rcp(cosine half-angle formula)\n    \n    s    = 1.0 / u;\n    xyz *= u * 0.5;\n\n    return vec4(xyz, s);  \n}\n\n// transform v by unit quaternion q.xyzs\nvec3 Transform(vec3 v, vec4 q)\n{\n    vec3 k = cross(q.xyz, v);\n    \n    return v + 2.0 * vec3(dot(vec3(q.wy, -q.z), k.xzy),\n                          dot(vec3(q.wz, -q.x), k.yxz),\n                          dot(vec3(q.wx, -q.y), k.zyx));\n}\n\n// transform v by unit quaternion q.xy0s\nvec3 Transform_Qz0(vec3 v, vec4 q)\n{\n    float k = v.y * q.x - v.x * q.y;\n    float g = 2.0 * (v.z * q.w + k);\n    \n    vec3 r;\n    r.xy = v.xy + q.yx * vec2(g, -g);\n    r.z  = v.z  + 2.0 * (q.w * k - v.z * dot(q.xy, q.xy));\n    \n    return r;\n}\n\n// transform v.xy0 by unit quaternion q.xy0s\nvec3 Transform_Vz0Qz0(vec2 v, vec4 q)\n{\n    float o = q.x * v.y;\n    float c = q.y * v.x;\n    \n    vec3 b = vec3( o - c,\n                  -o + c,\n                   o - c);\n    \n    return vec3(v, 0.0) + 2.0 * (b * q.yxw);\n}\n\n//==================================================================================//\n//////////////////////////////////////////////////////////////////////////////////////\n\n\n////////////////////////////////////////////////////////////////////////////////////// blue noise utils\n//==================================================================================//\n\n// increases bit depth of 8 bit per channel blue noise texture\nvec4 MixBlueNoiseBits(vec4 bnoise)\n{\n   const vec4 a = exp2(-vec4(0.0, 8.0, 16.0, 24.0));\n   const vec4 b = a / (a.x + a.y + a.z + a.w);\n\n   return vec4(dot(bnoise.xyzw, b), \n               dot(bnoise.yzwx, b), \n               dot(bnoise.zwxy, b), \n               dot(bnoise.wxyz, b));\n}\n\n// blue noise randomized via uv jittering\nvec4 BlueNoise01x4(uvec2 uv, uint n)\n{\n    const uint res = 1024u;\n\n    ivec2 uvi = ivec2((uv + (rPhi2 * n)) & (res - 1u));\n\n    return MixBlueNoiseBits(texelFetch(iChannel1, uvi, 0));\n}\n\n// blue noise randomized via value jittering\n// -> stratifies values along the time axis\nfloat BlueNoise01(uvec2 uv, uint n)\n{\n    const uint res = 1024u;\n\n    ivec2 uvi = ivec2(uv & (res - 1u));\n\n    float rnd01 = MixBlueNoiseBits(texelFetch(iChannel1, uvi, 0)).r;    \n\n    return Float01(uint(rnd01 * 4294967295.0) + rPhi1 * n);// == fract(rnd01 + rPhif1 * float(n));\n}\n\n//==================================================================================//\n//////////////////////////////////////////////////////////////////////////////////////\n\n\n////////////////////////////////////////////////////////////////////////////////////// GT-VBAO\n//==================================================================================//\n\n// returns 4 uniformly distributed rnd numbers [0,1]\n// rnd01.x/rnd01.xy -> used to sample a slice direction (exact importance sampling needs 2 rnd numbers)\n// rnd01.z -> used to jitter sample positions along ray marching direction\n// rnd01.w -> used to jitter sample positions radially around slice normal\nvec4 Rnd01x4(vec2 uv, uint n)\n{\n    uvec2 uvu = uvec2(uv);\n\n    vec4 rnd01 = vec4(0.0);\n    \n  #if GTAO_SLICE_SAMPLING_MODE == 1 || GTAO_SLICE_SAMPLING_MODE == 3\n    \n   #ifdef GTAO_USE_WHITE_NOISE\n    rnd01.xzw = Hash01x3(uvec3(uvu, n), 0x9CF617FAu);\n   #else\n    rnd01.x  = BlueNoise01  (uvu, n);\n    //rnd01.x  = IGN(floor(uv), n);\n  //rnd01.y  = unused\n    rnd01.zw = BlueNoise01x4(uvu, n).zw;\n   #endif\n    \n  #elif GTAO_SLICE_SAMPLING_MODE == 2\n        \n   #ifdef GTAO_USE_WHITE_NOISE\n    rnd01 = Hash01x4(uvec3(uvu, n), 0x9CF617FAu);\n   #else\n    rnd01   = BlueNoise01x4(uvu, n);\n    rnd01.x = BlueNoise01  (uvu, n);\n   #endif\n   \n  #endif\n    \n    return rnd01;\n}\n\n\nfloat SliceRelCDF_Cos(float x, float angN, float cosN, bool isPhiLargerThanAngN)\n{\n    if(x <= 0.0 || x >= 1.0) return x;\n    \n    float phi = x * Pi - Pi05;\n\n    bool c = isPhiLargerThanAngN;\n    \n    float n0 = c ?  3.0 : 1.0;\n    float n1 = c ? -1.0 : 1.0;\n    float n2 = c ?  4.0 : 0.0;\n    \n    float t0 = n0 * cosN + n1 * cos(angN - 2.0 * phi) + (n2 * angN + (n1 * 2.0) * phi + Pi) * sin(angN);\n    float t1 = 4.0 * (cosN + angN * sin(angN));\n\n    return t0 / t1;\n}\n\n\nfloat uniGTAOp(vec2 uv0, vec3 wpos, vec3 N, uint dirCount)\n{\n    vec3 positionVS = VPos_from_WPos(wpos);\n    vec3 normalVS   = VVec_from_WVec(N);\n    \n    vec3 V = isPerspectiveCam ? -normalize(positionVS) : vec3(0.0, 0.0, -1.0);\n    \n    vec2 rayStart = SPos_from_VPos(positionVS).xy;\n\n    uint frame = USE_TEMP_ACCU_COND ? uint(iFrame) : 0u;\n\n    float ao = 0.0;\n    for(uint i = 0u; i < dirCount; ++i)\n    {        \n        uint n = frame * dirCount + i;\n        vec4 rnd01 = Rnd01x4(uv0, n);\n        \n        ////////////////////////////////////////////////// slice direction sampling\n        vec3 smplDirVS;// view space sampling vector\n        vec2 dir;// screen space sampling vector\n        {\n           #if GTAO_SLICE_SAMPLING_MODE == 1\n            // sample partial slice dir uniformly and later compute slice_weight accordingly\n            \n            float rndAng = rnd01.x * Pi2;\n            \n            dir = vec2(cos(rndAng), sin(rndAng));\n\n            smplDirVS = vec3(dir.xy, 0.0);\n\n            if(isPerspectiveCam)\n            {\n                // set up View Vec Space -> View Space mapping\n                vec4 Q_toV = GetQuaternion(V);\n            \n                smplDirVS = Transform_Vz0Qz0(dir, Q_toV);\n\n                vec3 rayStart = SPos_from_VPos(positionVS);\n                vec3 rayEnd   = SPos_from_VPos(positionVS + smplDirVS*(nearZ*0.5));\n\n                vec3 rayDir   = rayEnd - rayStart;\n\n                rayDir /= length(rayDir.xy);\n\n                dir = rayDir.xy;\n            }\n            \n           #elif GTAO_SLICE_SAMPLING_MODE == 2\n            // exact partial slice dir importance sampling via 2 rnd numbers\n            // sample cos lobe in world space and project dir to screen space to be used as partial slice dir\n            \n            vec2 s = rnd01.xy * 2.0 - 1.0;\n\n            vec3 cosDir;\n            {\n              #if 1\n                // align up-axis of local sampling frame with view vector\n                // -> results in better noise profile when looking straight at a surface\n                vec3 sph;// = Sample_Sphere(s); inlined here to ensure z is up\n                {\n                    float ang = Pi * s.x;\n                    float s1p = sqrt(1.0 - s.y*s.y);\n\n                    sph = vec3(vec2(cos(ang), sin(ang)) * s1p, s.y);\n                }\n\n                if(isPerspectiveCam)\n                {\n                    sph = Transform_Qz0(sph, GetQuaternion(V));\n                }\n\n                vec3 cosDirVS = normalize(sph + VVec_from_WVec(N));\n                     cosDir   = WVec_from_VVec(cosDirVS);\n\n                smplDirVS = cosDirVS;\n                \n              #else\n              \n                cosDir = normalize(Sample_Sphere(s) + N);\n\n                smplDirVS = VVec_from_WVec(cosDir);\n                \n              #endif\n            }\n            \n            vec3 rayDir = smplDirVS;\n            \n            if(isPerspectiveCam)\n            {\n                rayDir = SPos_from_WPos(wpos + cosDir * (nearZ * 0.5)) - SPos_from_WPos(wpos);\n            }\n            \n            // 1 px step size\n            rayDir /= length(rayDir.xy);\n\n            dir = rayDir.xy;\n\n            // make orthogonal to V (alternatively use sliceN = normalize(sliceN);)\n            smplDirVS = normalize(smplDirVS - V * dot(V, smplDirVS));\n\n           #elif GTAO_SLICE_SAMPLING_MODE == 3\n            // approximate partial slice dir importance sampling via 1 rnd number\n            \n            // set up View Vec Space <-> View Space mapping\n            vec4   Q_toV = GetQuaternion(V);\n            vec4 Q_fromV = Q_toV * vec4(vec3(-1.0), 1.0);// conjugate\n\n            vec3 normalVVS = normalVS;\n\n            if(isPerspectiveCam) normalVVS = Transform_Qz0(normalVS, Q_fromV);\n\n            dir = SamplePartialSliceDir(normalVVS, rnd01.x);\n\n            smplDirVS = vec3(dir.xy, 0.0);\n\n            if(isPerspectiveCam)\n            {\n                smplDirVS = Transform_Vz0Qz0(dir, Q_toV);\n\n                vec3 rayStart = SPos_from_VPos(positionVS);\n                vec3 rayEnd   = SPos_from_VPos(positionVS + smplDirVS*(nearZ*0.5));\n\n                vec3 rayDir   = rayEnd - rayStart;\n\n                rayDir /= length(rayDir.xy);\n\n                dir = rayDir.xy;\n            }\n           #endif\n        }\n        //////////////////////////////////////////////////\n        \n        ////////////////////////////////////////////////// construct slice\n        float cosN, angN, projNRcpLen, VoT;\n        {\n            vec3 sliceN = cross(V, smplDirVS);\n            \n            vec3 projN = normalVS - sliceN * dot(normalVS, sliceN);\n\n            float projNSqrLen = dot(projN, projN);\n               if(projNSqrLen == 0.0) return 1.0;\n\n            projNRcpLen = inversesqrt(projNSqrLen);\n\n            cosN = dot(projN, V) * projNRcpLen;\n\n            vec3 T = cross(sliceN, projN);//TODO?\n            \n            VoT = dot(V, T) * projNRcpLen;\n            \n            float sgn = VoT < 0.0 ? -1.0 : 1.0;\n            \n            angN = sgn * ACos(cosN);\n        }\n        //////////////////////////////////////////////////\n\n        float angOff = angN * RcpPi + 0.5;\n\n        // percentage of the slice we don't use ([0, angN]-integrated slice-relative pdf)\n        float w0 = clamp((sin(angN) / (cos(angN) + angN * sin(angN))) * (Pi/4.0) + 0.5, 0.0, 1.0);\n        \n        // partial slice re-mapping constants\n        float w0_remap_mul = 1.0 / (1.0 - w0);\n        float w0_remap_add = -w0 * w0_remap_mul;\n        \n        float  min_horCos = 1.0;\n        float  max_horCos = VoT;\n        float max2_horCos = VoT;\n        \n        float ao0 = 0.0;\n        {\n            vec2 rayDir = dir.xy;\n            \n            const float count = Raymarching_SampleCount;\n            \n            const float s = pow(Raymarching_Width, 1.0/count);\n            \n            float t = pow(s, rnd01.z);// init t: [1, s]\n            \n            for (float i = 0.0; i < count; ++i)\n            {\n                vec2 samplePos = rayStart + rayDir * t;\n                \n                t *= s;\n                \n                // handle oob\n                if(samplePos.x < 0.0 || samplePos.x >= iResolution.x || samplePos.y < 0.0 || samplePos.y >= iResolution.y) break;\n                \n                float sampleDepth = textureLod(iChannel2, samplePos / Resolution.xy, 0.0).w;\n                \n                vec3 samplePosVS = VPos_from_SPos(vec3(samplePos, sampleDepth));\n\n                vec3 deltaPosFront = samplePosVS - positionVS;\n                vec3 deltaPosBack  = deltaPosFront - V * Thickness;\n                \n               #if 1\n                // required for correctness, but probably not worth to keep active in a practical application:\n                if(isPerspectiveCam)\n                {\n                   #if 1\n                    deltaPosBack = VPos_from_SPos(vec3(samplePos, sampleDepth + Thickness)) - positionVS;\n                   #else\n                    // also valid, but not consistent with reference ray marcher\n                    deltaPosBack = deltaPosFront + normalize(samplePosVS) * Thickness;\n                   #endif\n                }\n               #endif\n\n                // project samples onto unit circle and compute angles relative to V\n                vec2 horCos = vec2(dot(normalize(deltaPosFront), V), \n                                   dot(normalize(deltaPosBack ), V));\n                                   \n                horCos = max(horCos, VoT);\n                                   \n                if(horCos.x != horCos.y)\n                {\n                    if(horCos.y <= max2_horCos)\n                    {\n                        // update horizon\n                        max2_horCos = max(max2_horCos, horCos.x);\n                    }\n                    else\n                    {\n                        // update interval\n                        max_horCos = max(max_horCos, horCos.x);\n                        min_horCos = min(min_horCos, horCos.y);\n                    }\n                    \n                    if(min_horCos <= max2_horCos)\n                    {\n                        // merge interval into horizon\n                        max2_horCos = max_horCos;\n\n                        // reset horizon\n                        max_horCos = VoT;\n                        min_horCos = 1.0;\n                    }\n                }\n            }\n\n            vec3 horAng = ACos(vec3(min_horCos, max_horCos, max2_horCos));\n            \n            // shift relative angles from V to N + map to [0,1]\n            vec3 hor01 = clamp(horAng * RcpPi + angOff, 0.0, 1.0);\n            \n            // map to slice relative distribution\n            hor01.x = SliceRelCDF_Cos(hor01.x, angN, cosN, true);\n            hor01.y = SliceRelCDF_Cos(hor01.y, angN, cosN, true);\n            hor01.z = SliceRelCDF_Cos(hor01.z, angN, cosN, true);\n            \n            // partial slice re-mapping\n            hor01 = hor01 * w0_remap_mul + w0_remap_add;\n            \n            // compute AO contribution\n            {\n                float occ0 = clamp(hor01.x - hor01.y, 0.0, 1.0);// interval\n                      occ0+= clamp(    1.0 - hor01.z, 0.0, 1.0);// horizon\n               \n                float w;\n               \n              #if GTAO_SLICE_SAMPLING_MODE == 1\n                w = 2.0 - 2.0 * w0;\n              #else\n                w = 1.0;\n              #endif\n                \n                ao0 = w - w * occ0;\n            }\n        }\n        \n        // accumulate AO contribution\n        {\n            float slice_weight = 1.0;\n\n           #if GTAO_SLICE_SAMPLING_MODE == 1\n            // if we sample the partial slice dir from a uniform distribution we need to account for that here\n            slice_weight = max(0.0, 1.0/projNRcpLen * (cosN + angN * sin(angN)));\n           #endif\n\n            ao += ao0 * slice_weight;\n        }\n    }\n    \n    ao /= float(dirCount);\n    \n    return ao;\n}\n\n//==================================================================================//\n//////////////////////////////////////////////////////////////////////////////////////\n\n\n////////////////////////////////////////////////////////////////////////////////////// reference AO\n//==================================================================================//\n\nfloat ReferenceAO(vec2 uv0, vec3 wpos, vec3 N, uint dirCount)\n{\n    uvec2 uvu = uvec2(uv0);\n\n   #ifndef REFAO_USE_WHITE_NOISE\n    // randomly shift noise pattern around\n    if(USE_TEMP_ACCU_COND) uvu += Hash(uvec2(iFrame, 0u), 0xBD1E0BB0u).xy;\n\n    // linearize uv in a locality preserving way\n    uint pxId = EvalHilbertCurve(uvu, 9u);\n   #endif\n\n    vec3 positionVS = VPos_from_WPos(wpos);\n\n    uint frame = USE_TEMP_ACCU_COND ? uint(iFrame) : 0u;\n\n    float occ = 0.0;\n    \n    for(uint i = 0u; i < dirCount; ++i)\n    {\n        uint n = frame * dirCount + i;\n        \n      #ifdef REFAO_USE_WHITE_NOISE\n        vec2 s = Hash11x2(uvec3(uvu, n), 0x3579A945u);\n      #else\n        uint h = pxId * dirCount + i;\n        vec2 s = Float11(shuffled_scrambled_sobol_2d(h, 0xCC925D21u));\n      #endif\n        \n        // cosine weighted hemisphere\n        vec3 rayDir = normalize(Sample_Sphere(s) + N); \n        \n       #ifdef USE_ANALYTICAL_RAYCASTING\n        {\n            float t; vec3 n; vec3 a;\n            occ += Intersect_Scene(wpos, rayDir, /*out:*/ t, n, a) > 0.0 ? 1.0 : 0.0;\n        }\n       #else\n        // ray march in screen space\n        if(isPerspectiveCam)\n        {\n            vec4 rayStart = PPos_from_WPos(wpos);\n            vec4 rayEnd   = PPos_from_WPos(wpos + rayDir * (nearZ * 0.5));\n            \n            float rwStart = 1.0 / rayStart.w;\n            float rwEnd   = 1.0 / rayEnd.w;\n            \n            vec2 tcStart = rayStart.xy * rwStart * 0.5 + 0.5;\n            vec2 tcEnd   = rayEnd.xy   * rwEnd   * 0.5 + 0.5;\n            \n            vec2  tcDelta0 = tcEnd - tcStart;\n            float rwDelta0 = rwEnd - rwStart;\n            \n            vec2  uvDelta0       = tcDelta0 * iResolution.xy;\n            float uvDelta0RcpLen = inversesqrt(dot(uvDelta0, uvDelta0));\n\n            // 1 px step size\n            vec2  tcDelta = tcDelta0 * uvDelta0RcpLen;\n            float rwDelta = rwDelta0 * uvDelta0RcpLen;\n            \n            float rnd01 = Hash01(uvec3(uvu, n), 0x2D56DA3Bu);\n\n            const float count = Raymarching_SampleCount;\n            \n            const float s = pow(Raymarching_Width, 1.0/count);\n            \n            float t = pow(s, rnd01);// init t: [1, s]\n\n            for (float i = 0.0; i < count; ++i)\n            {\n                vec2  tc = tcStart + tcDelta * t;\n                float rw = rwStart + rwDelta * t;\n\n                t *= s;\n\n                float depth = 1.0 / rw;\n\n                // handle oob\n                if(tc.x < 0.0 || tc.x >= 1.0 || tc.y < 0.0 || tc.y >= 1.0) break;\n                \n                float sampleDepth = textureLod(iChannel2, tc.xy, 0.0).w;\n\n                if(depth > sampleDepth && depth < sampleDepth + Thickness)\n                {\n                    occ += 1.0;\n                    \n                    break;\n                }\n             }\n        }\n        else\n        {\n            vec3 rayStart = SPos_from_WPos(wpos);\n            vec3 rayDir   = SVec_from_VVec_Ortho(VVec_from_WVec(rayDir));\n            \n            // 1 px step size\n            rayDir /= length(rayDir.xy);\n\n            float rnd01 = Hash01(uvec3(uvu, n), 0x2D56DA3Bu);\n\n            const float count = Raymarching_SampleCount;\n                        \n            const float s = pow(Raymarching_Width, 1.0/count);\n            \n            float t = pow(s, rnd01);// init t: [1, s]\n            \n            for (float i = 0.0; i < count; ++i)\n            {\n                vec3 samplePos = rayStart + rayDir * t;\n                \n                t *= s;\n\n                vec2 tc = samplePos.xy / iResolution.xy;\n\n                // handle oob\n                if(tc.x < 0.0 || tc.x >= 1.0 || tc.y < 0.0 || tc.y >= 1.0) break;\n                \n                float sampleDepth = textureLod(iChannel2, tc.xy, 0.0).w;\n\n                if(samplePos.z > sampleDepth && samplePos.z < sampleDepth + Thickness)\n                {\n                    occ += 1.0;\n                    \n                    break;\n                }\n            }\n        }\n       #endif\n    }\n    \n    occ /= float(dirCount);\n    \n    return 1.0 - occ;\n}\n\n//==================================================================================//\n//////////////////////////////////////////////////////////////////////////////////////\n\n\nvoid mainImage(out vec4 outCol, in vec2 uv0)\n{     \n    Resolution = iResolution.xy;\n    isLeft = uv0.x < iResolution.x * 0.5;\n    \n    vec4 mouseAccu  = ReadVar4(1, VAR_ROW);\n    float frameAccu = ReadVar (3, VAR_ROW);\n    \n    PrepareCam(mouseAccu, USE_PERSPECTIVE_CAM_COND);\n    \n    vec4 gbuffer = textureLod(iChannel2, uv0 / iResolution.xy, 0.0);\n    vec3  N     = gbuffer.xyz;\n    float depth = gbuffer.w;\n    \n    if(depth >= exp2(10.0))\n    {\n        outCol = vec4(0.0);\n        \n        return;\n    }\n    \n    vec3 spos = vec3(uv0, depth);\n    \n    vec3 wpos = WPos_from_SPos(spos);\n         wpos+= N * (1.0/1024.0);\n\n    \n    vec3 col = vec3(0.0);\n\n    float refao;\n    {\n        uint count = 1u;\n        \n        refao = ReferenceAO(uv0, wpos, N, count);\n    }\n    \n    float ssao;\n    {\n        uint count = 1u;\n        \n        ssao = uniGTAOp(uv0, wpos, N, count);\n    }\n    \n    col = vec3(refao, ssao, 0.0);\n    \n    // accumulate frames\n    if(USE_TEMP_ACCU_COND)\n    {\n        vec2 tc = uv0.xy / iResolution.xy;\n    \n        vec4 colLast = textureLod(iChannel0, tc, 0.0);\n\n        col = mix(colLast.rgb, col, 1.0 / (frameAccu));\n        \n        frameAccu += 1.0;\n        \n        outCol = vec4(col.rgb, frameAccu);\n        \n        return;\n    }\n   \n    outCol = vec4(col, 0.0);\n}\n\n\n","name":"Buffer C","description":"","type":"buffer"}]}