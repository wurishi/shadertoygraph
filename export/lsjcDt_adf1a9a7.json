{"ver":"0.1","info":{"id":"lsjcDt","date":"1494440119","viewed":150,"name":"Cellular noise with a buffer","username":"liamegan","description":"Cellular noise generated using an animated buffer texture.\nhttps://thebookofshaders.com/12/","likes":4,"published":1,"flags":32,"usePreview":0,"tags":["2d","noise","distancefield","texture","cellular","buffer"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float iterations = 15.0;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv.x *= 1.5; // for teh circles!\n    \n    float dist = 1.0;\n    \n    for(float i = 1.0; i <= iterations; i++) {\n        vec4 pixelData = texture(iChannel0, vec2( i / iterations ));\n        vec2 texelPos = vec2(-1.) + vec2(pixelData.r, pixelData.g) * 4.0;\n        \n        dist = min(dist, length(texelPos - uv));\n    }\n    fragColor = vec4(floor(fract((1.0 - clamp(dist * 2.0, 0.0, 1.0) * 10.0)) * 1.2));\n    // uncomment for the raw distance field\n    // fragColor = vec4(1.0 - clamp(dist * 2.0, 0.0, 1.0));\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"float noise(in vec2 position) {\n    return fract(sin(dot(position.xy,\n                         vec2(12.9898,78.233)))*\n        43758.5453123);\n}\n\nfloat interpolate(float a, float b) {\n    return a + ( b - a ) * ( ( 1.0 - a ) / ( b - a ) );\n}\n\n// Value Noise courtesy of Book of Shaders\n// https://thebookofshaders.com/11/\nfloat noise2d(vec2 uv) {\n    \n    vec2 pos = floor(uv);\n    vec2 fractional = fract(uv);\n    \n    // four corners\n    float a = noise(pos);\t\t\t\t\t// bottom left\n    float b = noise(pos + vec2(1., 0.));\t// bottom right\n    float c = noise(pos + vec2(1., 1.));\t// top right\n    float d = noise(pos + vec2(0., 1.));\t// top left\n    \n    vec2 intermix = smoothstep(0., 1., fractional);\n    \n    float value = mix(a, b, intermix.x);\n    value += (d - a) * intermix.y * (1.0 - intermix.x);\n    value += (c - b) * intermix.x * intermix.y;\n    \n    return value;\n}\n\n// Fractal noise courtesy of iq\n// https://www.shadertoy.com/view/XdXGW8\nfloat fractalNoise2d(vec2 uv) {\n    \n    mat2 rotate = mat2(1.6, 1.2, -1.2, 1.6);\n    \n    float value = 0.5 * noise2d(uv);\n    uv *= rotate;\n    value += 0.25 * noise2d(uv);\n    uv *= rotate;\n    value += 0.125 * noise2d(uv);\n    uv *= rotate;\n    value += 0.0625 * noise2d(uv);\n    \n    return value;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    uv += vec2(iTime / 250.0, 0.0);\n    \n    uv *= 20.0;\n    \n    float x = fractalNoise2d(uv);\n    float y = fractalNoise2d(uv + 1.0);\n    \n    fragColor = vec4(x, y, 1.0, 1.0);\n}","name":"Buf A","description":"","type":"buffer"}]}