{"ver":"0.1","info":{"id":"MsdcWr","date":"1529322995","viewed":351,"name":"Thick glass shell","username":"onepride","description":"A hemi-spherical shell of fixed thickness with transmittance and approximation of inscattered light within a medium. This is an experimental shader for a realtime game, so refraction is not taken into account while sampling background","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["transparency","glass","transmittance","freshnel"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//const vec3 T0 = vec3(0.95, 0.85, 0.5);//default transmittance for NoV = 1.0\n//const vec3 T0 = vec3(0.7, 0.85, 0.95);//default transmittance for NoV = 1.0\nconst vec3 T0 = vec3(0.9, 1.0, 0.9);//default transmittance for NoV = 1.0\nconst float d0 = 0.1;//medium thickness\nconst float n1 = 1.000292; //air\nconst float n2 = 1.49; //plexiglass\n//const float n2 = 1.334; //water\n\n//RoVcrit - critical cosine of the total internal reflection while transmitting light from n2 to n1.\n//Should be determined over the surface curvature and the medium thickness, or adjusted visually for a suitable result\nconst float RoVcrit = 0.75;\n\nconst float inscatterFactor = 0.7;//artistic choice\n\n\nconst vec3 GAMMA = vec3(2.2);\n\n\nvec3 getScatteringCoef(vec3 T, float dist){\n    return log(vec3(1.0,1.0,1.0) / T) / dist;\n}\n\nvec3 getTransmittance(vec3 scatteringCoef, float dist){\n    return exp(-scatteringCoef*dist);\n}\n\nvec3 getTransmittance(vec3 t0, float D0, float dist){\n    return getTransmittance(getScatteringCoef(t0, D0), dist);\n}\n\n//reflected energy lobe - modified Shlick's approximation for the critical angle of total internal reflection, cosAlpha = NoV\nfloat getFresnelFactor(float cosAlpha, float cosAlphaCrit){\n    return max(0.0, min( 1.0, pow(1.0 - (cosAlpha + cosAlphaCrit - 1.0) / cosAlphaCrit, 5.0)));\n}\n\n//cosine of refraction angle (NoR)\nfloat getCosGamma(float cosAlpha, float N1, float N2){\n    return sqrt(1.0 - N1*N1*(1.0-cosAlpha*cosAlpha)/(N2*N2));\n}\n\n//refracted ray length relative to incidence angle of 0 degrees and a unit shell thickness\nfloat getRefractedRayLength(float cosAlpha, float N1, float N2){\n    return 1.0 / getCosGamma(cosAlpha, N1, N2);\n}\n\n//https://iquilezles.org/articles/spherefunctions\nfloat sphIntersect( vec3 ro, vec3 rd, vec4 sph )\n{\n    vec3 oc = ro - sph.xyz;\n    float b = dot( oc, rd );\n    float c = dot( oc, oc ) - sph.w*sph.w;\n    float h = b*b - c;\n    if( h<0.0 ) return -1.0;\n    h = sqrt( h );\n    return -b - h;\n}\n\nvec3 sampleEnvironment(vec3 dir)\n{\n    return pow(texture(iChannel0, dir).rgb, GAMMA);\n}\n\nvec2 V;\n#define rot(a) mat2( V = sin(vec2(1.57, 0.0) + a), -V.y, V.x)\n\nvec3 ambientLight()\n{\n    return (sampleEnvironment(vec3( 1, 0, 0)) +\n\t\t\tsampleEnvironment(vec3(-1, 0, 0)) +\n\t\t\tsampleEnvironment(vec3( 0, 1, 0)) +\n\t\t\tsampleEnvironment(vec3( 0,-1, 0)) +\n\t\t\tsampleEnvironment(vec3( 0, 0, 1)) +\n\t\t\tsampleEnvironment(vec3( 0, 0,-1))) / 6.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy*2.0-1.0;\n    float aspect = iResolution.x / iResolution.y;\n    uv.x *= aspect;\n\n    const vec3 spherePos = vec3(0.0,0.0,0.0);\n    const float sphereRadius = 1.0;\n    vec3 eyePos = vec3(0.0,0.0,1.5);\n    \n    vec3 rayDir = normalize(vec3(uv.x, uv.y, -1.0));\n    \n    vec2 rotv = vec2(-1.57, 0.0);\n    if (iMouse.z > 0.0)\n        rotv += vec2((iMouse.xy - iResolution.xy*0.5)*0.01);\n    \n    mat2 rot1 = rot(rotv.x);\n    mat2 rot2 = rot(-rotv.y);\n    rayDir.yz *= rot2;\n    eyePos.yz *= rot2;\n    rayDir.xz *= rot1;\n    eyePos.xz *= rot1;      \n    \n    float s = sphIntersect(eyePos, rayDir, vec4(spherePos, sphereRadius));\n    \n    vec3 N = normalize(eyePos + rayDir*s - spherePos);\n    \n    vec3 col = sampleEnvironment(rayDir);\n    \n    if(s>=0.0)\n    {\n        vec3 view = -rayDir;\n        float NoV = dot(N,view);\n        \n        //transmitted light    \n        float Ft = 1.0 - getFresnelFactor(NoV, RoVcrit);//energy lobe\n        float d = d0 * getRefractedRayLength(NoV, n1, n2);\n        vec3 T = getTransmittance(pow(T0, GAMMA), d0, d);\n       \tcol *= T * Ft * (1.0-getFresnelFactor(NoV, 1.0));\n        //magic approximation: inscattered light within shell thickness\n        col += getTransmittance(pow(T0, GAMMA), d0, d*4.0) * ambientLight() * (1.0 - Ft) * pow(inscatterFactor, GAMMA.x);\n\n        //reflected light\n        const float specularLobeMin = 0.04;\n        float Fr = specularLobeMin + (1.0-specularLobeMin) * getFresnelFactor(NoV, 1.0);\n        vec3 R = N * vec3(NoV, NoV, NoV) * vec3(2.0, 2.0, 2.0) - view;\n        col.rgb += sampleEnvironment(R) * Fr;//specular                \n    }\n    else\n    {\n        //col = texture(iChannel0, view).rgb;\n    }    \n  \n    fragColor = vec4(pow(col, vec3(1.0/GAMMA)),1.0);\n}","name":"Image","description":"","type":"image"}]}