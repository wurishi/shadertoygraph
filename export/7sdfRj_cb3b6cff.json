{"ver":"0.1","info":{"id":"7sdfRj","date":"1657033719","viewed":151,"name":"CRT Test 11","username":"Makeavoy","description":"fullscreen!\n\nPixels are divided by rgb to separate \"lights\" in the screen, in this iteration a higher luminance merges the pixel lights more easily.\n\nnow features glitchy scan line shifting, screen curvature, and a turning-on animation\n\nVery WIP","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["pixel","crt","weird"],"hasliked":0,"parentid":"NsBcW1","parentname":"CRT Experiment 3"},"renderpass":[{"inputs":[{"id":"4sX3Rn","filepath":"/media/a/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv","previewfilepath":"/media/ap/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv","type":"video","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define RESOLUTION 240.\n#define LOW_RANGE 0.05\n#define HIGH_RANGE 0.6\n#define DARK_FACTOR 0.4\n#define LUMEN_THRESHOLD 0.2\n#define GLITCHY 3.\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float AR = iResolution.x / iResolution.y;\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    \n    const float corner_harshness=1.2;\n    const float corner_ease=4.;\n    \n    float vv=2.-min(mod(iTime,10.),2.);\n    //float vv=cos(iTime*1.)*2.;\n    float fade=max(pow(vv,16.),1.);\n    \n    float xx=(abs(uv.x -0.5)*corner_harshness);\n    float yy=(abs(uv.y -0.5)*corner_harshness)*fade;\n    float rr=(1.+pow((xx*xx+yy*yy),corner_ease));\n    vec2 tuv=(uv-0.5)*rr+0.5;\n    tuv=clamp(tuv,0.,1.);\n    //if(rr<1.01){\n    \n    uv=tuv;\n    vec2 limit=step(vec2(0.,.0),uv)*step(uv,vec2(1.,1.));\n    if(  uv.x>0. && uv.x<1. && uv.y>0. && uv.y<1.){\n\n    \n    //resolution factor\n    float res=RESOLUTION;\n    vec2 res2=vec2(res,res/AR);\n    vec2 res3=res2;\n    vec2 res4=res2;\n\n    \n    vec2 pre_i=floor(uv*res2);\n    \n    vec2 i=pre_i/res2;\n    \n    float even=0.;\n    \n    if(mod(pre_i.y,2.)==0.){\n        even=0.5/res2.x;//2./res;\n\n        uv.x+=even;\n        float pre_y=floor(uv.x*res2.x);\n        i.y=pre_y/res2.x;\n        \n        i=floor(uv*res2)/res2;\n    }\n    \n    vec4 tex = texture(iChannel0, i);\n    float lum=(0.2126*tex.r + 0.7152*tex.g + 0.0722*tex.b);\n    \n    //this calculation is very particular\n    float value=smoothstep(LOW_RANGE,HIGH_RANGE,1.-lum);\n    \n    float v=min(value,1.);\n    \n    \n    //// scan lines?\n    float tiny=cos(6.28*mod((uv.y+iTime*.1)*.2,.01)*300.);\n    float L=0. +0.01*cos(uv.x*1.2+iTime*20.);\n    float wave=cos(6.28*smoothstep(i.y,L,L+0.05))/5.;\n    float scan=cos(1.57+3.14*(.2-wave)*tiny);\n    ////\n    \n    \n    //first factor to determine how much rgb pixels split up\n    //1. is complete seperation, 0. is merged\n    float split=max(.33,v);\n    \n    \n\n \n    \n    vec2 uv2=uv+vec2(-split*0.2/res,0.);\n    \n    vec2 uv3=uv+vec2(-split*0.4/res,0.);\n    \n    \n\n    uv2.x+=GLITCHY*scan/RESOLUTION;\n    uv3.y-=GLITCHY*scan/RESOLUTION;\n\n    \n    \n    //vec2 c=mod(uv,1./res)*res;\n    vec2 cr=mod(uv,1./res2)*res2;\n    vec2 cg=mod(uv2,1./res3)*res3;\n    vec2 cb=mod(uv3,1./res4)*res4;\n\n    \n    vec2 i2=floor(uv2*res3)/res3;//vec2(i.x+t*3.,i.y-t);\n    vec2 i3=floor(uv3*res4)/res4;//vec2(i.x-t*6.,i.y+t);\n\n    \n    vec4 tex2 = texture(iChannel0, i2);\n    vec4 tex3 = texture(iChannel0, i3);\n\n  \n    //darkness factor (between 0 and 1 or higher, higher means dark barely splits\n    \n    float ar=1.;\n    float ag=1.;\n    float ab=1.;\n    \n    \n    \n    float pixel_size=(DARK_FACTOR+1.-split)*2. ;\n    \n\n    cr.x*=0.66+split;\n    cg.x*=0.66+split;\n    cb.x*=0.66+split;\n    \n    if(split>LUMEN_THRESHOLD){\n     ar=(0.5-abs(cr.x-.5))*(0.5-abs(cr.y-0.5))*pixel_size;\n     ag=(0.5-abs(cg.x-.5))*(0.5-abs(cg.y-0.5))*pixel_size;\n     ab=(0.5-abs(cb.x-.5))*(0.5-abs(cb.y-0.5))*pixel_size;\n        \n     }\n    \n    ar=min(floor(ar+0.97),1.0);\n    ag=min(floor(ag+0.97),1.0);\n    ab=min(floor(ab+0.97),1.0);\n    \n    \n\n    // Time varying pixel color\n    vec3 col = vec3(tex.r*ar,tex2.g*ag,tex3.b*ab); //vec3(r);//\n    \n    vec3 backup=vec3(tex.r,tex2.g,tex3.b);\n    // Output to screen\n    fragColor = vec4(col,1.);//vec4(cos(i2.x*100.),1.0,1.,1.0);\n    //}else{\n    //    fragColor = vec4(0.,0.,0.,1.);\n    //}\n    }else{\n    fragColor=vec4(0.,0.,0.,1.);\n    }\n    \n    \n}","name":"Image","description":"","type":"image"}]}