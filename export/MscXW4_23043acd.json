{"ver":"0.1","info":{"id":"MscXW4","date":"1459286622","viewed":213,"name":"tweaked spline","username":"adrians","description":"tweaked cubic root finder to avoid trig","likes":11,"published":1,"flags":0,"usePreview":0,"tags":["spline"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Signed Distance to a Quadratic Bezier Curve\n// - Adam Simmons (@adamjsimmons) 2015\n//\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n//\n// Inspired by http://www.pouet.net/topic.php?which=9119\n// and various shaders by iq, T21, and demofox\n// \n// I needed the -signed- distance to a quadratic bezier\n// curve but couldn't find any examples online that\n// were both fast and precise. This is my solution.\n//\n// v1 - Initial release\n// v2 - Faster and more robust sign computation\n//\n\n// Test if point p crosses line (a, b), returns sign of result\nfloat testCross(vec2 a, vec2 b, vec2 p) {\n    return sign((b.y-a.y) * (p.x-a.x) - (b.x-a.x) * (p.y-a.y));\n}\n\n// Determine which side we're on (using barycentric parameterization)\nfloat signBezier(vec2 A, vec2 B, vec2 C, vec2 p)\n{ \n    vec2 a = C - A, b = B - A, c = p - A;\n    vec2 bary = vec2(c.x*b.y-b.x*c.y,a.x*c.y-c.x*a.y) / (a.x*b.y-b.x*a.y);\n    vec2 d = vec2(bary.y * 0.5, 0.0) + 1.0 - bary.x - bary.y;\n    return mix(sign(d.x * d.x - d.y), mix(-1.0, 1.0, \n        step(testCross(A, B, p) * testCross(B, C, p), 0.0)),\n        step((d.x - d.y), 0.0)) * testCross(A, C, B);\n}\n\nfloat cbrt(float x) {\n    return sign(x) * pow(abs(x), 1.0 / 3.0);\n}\n\nvec2 cossin_third(float x) {\n    float c = (0.866017 +1.25203 * x + 0.431996 * x * x + 0.0161423 * x * x * x)\n        /(1.0 + 1.25325 * x + 0.312933 * x * x);\n    \n//    float c = (0.871828 + 1.03347 * x + 0.110724 * x*x - 0.0657648 * x*x*x)/(1.0 + 0.970619 * x);\n    float s = sqrt(1.0 - c * c);\n    return vec2(c, s);\n#if 0\n    float v = acos(x) / 3.0;\n//  return vec2(cos(v), sin(v));\n    \n    float t = -cbrt(sqrt(x * x - 1.0) - x);\n    float c = (t + 1.0 / t) / 2.0;\n    float s = sqrt(1.0 - c * c);\n    return vec2(c, s);\n   #endif\n}\n\n// Solve cubic equation for roots\nvec3 solveCubic(float a, float b, float c, out int type)\n{\n    float p = b - a*a / 3.0, p3 = p*p*p;\n    float q = a * (2.0*a*a - 9.0*b) / 27.0 + c;\n    float d = q*q + 4.0*p3 / 27.0;\n    float offset = -a / 3.0;\n    if(d >= 0.0) {\n        type = 1;\n        float z = sqrt(d);\n        vec2 x = (vec2(z, -z) - q) / 2.0;\n        vec2 uv = sign(x)*pow(abs(x), vec2(1.0/3.0));\n        return vec3(offset + uv.x + uv.y);\n    }\n    type = 0;\n    vec2 cs = cossin_third(-sqrt(-27.0 / p3) * q / 2.0);\n    float m = cs.x, n = cs.y * 1.732050808;\n//  float v = acos(-sqrt(-27.0 / p3) * q / 2.0) / 3.0;\n//  float m = cos(v), n = sin(v)*1.732050808;  \n    return vec3(m + m, -n - m, n - m) * sqrt(-p / 3.0) + offset;\n}\n\nvec2 sincos(float t) {\n    return vec2(cos(t), sin(t));\n}\nvec3 solveCubic2(float a, float b, float c, out int type) {\n    float sqrt3 = 1.732050808;\n\n\tfloat\te\t= a / 3.0;\n\tfloat\tf\t= e * e - b / 3.0;\n\tfloat\tg\t= (e * b - c) / 2.0 - e * e * e;\n\tfloat\th\t= g * g - f * f * f;\n\n\tif (h < 0.0) {\n\t\t//3 real roots\n        type = 0;\n\t\tvec2\tt\t= sincos(atan(g, sqrt(-h) * sign(g)) / 3.0);\n\t\treturn (vec3(2, -1, -1) * t.x + vec3(0, -sqrt3, sqrt3) * t.y) * sqrt(f) - e;\n\t} else if (h > 0.0) {\n\t\t//1 real root, 2 imaginary (y + iz) & (y - iz)\n        type = 1;\n        float\tz = sqrt(h);\n        vec2\tx = vec2(z, -z) + g;\n\t\tvec2\tt = sign(x) * pow(abs(x), vec2(1.0/3.0));\n\t\treturn vec3(t.x + t.y - e);\n//\t\treturn vec3(1, -0.5, sqrt3/2.0) * t.x + vec3(1, -0.5, sqrt3/2.0) * t.y - vec3(e, e, 0);\n\t} else {\n\t\t//3 real and equal\n        type = 2;\n\t\treturn vec3(pow(-c, 1.0 / 3.0));\n\t}\n}\n// Find the signed distance from a point to a bezier curve\nfloat sdBezier(vec2 A, vec2 B, vec2 C, vec2 p, out int type)\n{    \n    B = mix(B + vec2(1e-4), B, abs(sign(B * 2.0 - A - C)));\n    vec2 a = B - A, b = A - B * 2.0 + C, c = a * 2.0, d = A - p;\n    vec3 k = vec3(3.*dot(a,b),2.*dot(a,a)+dot(d,b),dot(d,a)) / dot(b,b);\n    vec3 t = clamp(solveCubic(k.x, k.y, k.z, type), 0.0, 1.0);\n    vec2 pos = A + (c + b*t.x)*t.x;\n    float dis = length(pos - p);\n    pos = A + (c + b*t.y)*t.y;\n    dis = min(dis, length(pos - p));\n    pos = A + (c + b*t.z)*t.z;\n    dis = min(dis, length(pos - p));\n    return dis * signBezier(A, B, C, p);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (2.0*fragCoord.xy-iResolution.xy)/iResolution.y;\n    vec2 m = mix((2.0*iMouse.xy-iResolution.xy)/iResolution.y,\n        vec2(cos(iTime * 1.2) * 0.8, 0.0), step(iMouse.z, 0.0));\n    \n    // Define the control points of our curve\n    vec2 A = vec2(0.4, -0.6), C = vec2(0.0, +0.6), B = (4.0 * m - A - C) / 2.0;\n    \n    // Render the control points\n    float d = min(distance(p, A),(min(distance(p, m),distance(p, C))));\n    if (d < 0.04) { fragColor = vec4(1.0 - smoothstep(0.025, 0.034, d)); return; }\n    \n    // Get the signed distance to bezier curve\n    int\ttype;\n    d = sdBezier(A, B, C, p, type);\n    \n    // Visualize the distance field using iq's orange/blue scheme\n    vec4 col = vec4(type == 0, type == 1, type == 2, 1);\n    if (d < 0.0)\n        col *= 0.5;\n    fragColor = col * (1.0 - exp(-4.0*abs(d))) * (0.8 + 0.2*cos(140.*d));\n    fragColor = mix(fragColor, vec4(1.0), 1.0-smoothstep(0.0,0.02,abs(d)) );\n}","name":"Image","description":"","type":"image"}]}