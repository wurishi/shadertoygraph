{"ver":"0.1","info":{"id":"ftjyzw","date":"1649378365","viewed":135,"name":"TunnelLoading","username":"MelisaHot","description":"Loading page tunnel\nSome functions from: \nhttps://www.shadertoy.com/view/ltyfRD","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["loading","enter"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"mat2 rotate(float a)\n{\n\tfloat c = cos(a);\n\tfloat s = sin(a);\n\treturn mat2(c, s, -s, c);\n}\n\nvec2 trajectory(in float pz)\n{ \n    vec2 path= vec2(cos(iTime*0.9+pz*0.5),cos(iTime*0.7+pz*0.4));\n    return path;\n}\n\nfloat Tunnel(vec3 p, float dist)\n{\n\tfloat dist2 = dist - length(p.xy);\n    float z = dot(sin(p - cos(p.yzx)), cos(p*0.2));\n    dist2+=z;\n    return dist2;\n}\n\nfloat map(vec3 p)\n{\n\tvec2 tr = trajectory(iTime*12.+p.z);   \n    p.xy *= rotate(p.z*0.15);\n    p.z += iTime*23.;\n    float d2 = Tunnel(p,10.0 + sin(iTime+p.z*0.5) );\n\treturn d2;\n}\n\nvec3 normal(vec3 p)\n{\n    vec2 e = vec2(0.0025, -0.0025); \n    return normalize(\n        e.xyy * map(p + e.xyy) + \n        e.yyx * map(p + e.yyx) + \n        e.yxy * map(p + e.yxy) + \n        e.xxx * map(p + e.xxx));    \n}\n\nvec3 phong(vec3 lightDir, vec3 normal, vec3 rd) {\n  // ambient\n  float k_a = 0.3;\n  vec3 i_a =0.4 + 0.5*cos(iTime*0.5+vec3(0,3,3));;\n  vec3 ambient = k_a * i_a;\n\n  // diffuse\n  float k_d = 0.9;\n  float dotLN = clamp(dot(lightDir, normal), 0., .5);\n  vec3 i_d = vec3(0.1, 0.5, 0.5)*dot(sin (iTime), cos(iTime*1.25));\n  vec3 diffuse = k_d * dotLN * i_d;\n\n  // specular\n  float k_s = 0.8;\n  float dotRV = clamp(dot(reflect(lightDir, normal), -rd), 0., 1.);\n  vec3 i_s = vec3(.4, .4, .4);\n  float alpha = 2.;\n  vec3 specular = k_s * pow(dotRV, alpha) * i_s;\n\n  return ambient+diffuse+specular ;\n}\nvec3 render(vec2 uv)\n{\n\tvec3 ro = vec3(1.0,1.0,0.0);\n\tvec3 rd = normalize(vec3(uv*1.5, 1.));\n\tvec3 p = vec3(0.);\n\tfloat t = 0.;\n    float co;\n\tfor (int i = 0; i < 32; i++)\n    {\n\t\tp = ro + rd * t;\n\t\tco = map(p);\n\t\tif (co < .000001 || t > 100.) break;\n\t\tt +=0.25*co;\n\t}\n    \n\tvec3 n = normal(p);\n\tvec3 lp = normalize(ro - p);\n    \n    lp.x += sin(iTime)*.5;\n    lp.y += cos(iTime)*.5;\n    \n\tfloat diff = .5 * max(dot(lp, n), 0.);\n    float lv = (1. + t * t *0.001);\n    \n    vec3 col =  vec3(0.,1.5,1.5)*diff / lv;\n   \n      vec3 lightPosition1 = vec3(20, 20, 0);\n      vec3 lightDirection1 = normalize(lightPosition1 - co);\n      float lightIntensity1 = 0.9;\n      \n      vec3 lightPosition2 = vec3(0, 0, 10);\n      vec3 lightDirection2 = normalize(lightPosition2 - co);\n      float lightIntensity2 = 0.9;\n       \n       \n      col = lightIntensity1 * phong(lightDirection1, n, rd);\n      col += lightIntensity2 * phong(lightDirection2, n , rd);\n      float fresnel = pow(clamp(1. - dot(n, -rd), 0., .8), 10.);\n      vec3 rimColor = vec3(1, 1, 0.6);\n      col += fresnel*rimColor;\n    return col;\n\t\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (2. * fragCoord.xy - iResolution.xy) / iResolution.y;\n    \n    vec3 color = vec3(0.0,0.0,0.0);\n    \n\tcolor = render(uv);\n   \n\tfragColor = vec4(color, .1);\n}\n\n\n","name":"Image","description":"","type":"image"}]}