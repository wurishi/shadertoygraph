{"ver":"0.1","info":{"id":"M33GDM","date":"1716548786","viewed":8,"name":"LineWidthGapAndCap","username":"rkgekk","description":"Line with gap and cap shader ","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["line"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14159265358979323846\n\nconst vec4 bg_color = vec4(1.0, 1.0, 1.0, 1.0);\nconst float screen_wide = 2.0;\nconst float inv_sw = 1.0 / screen_wide;\n\nstruct UniformsLine {\n    mat4 modelViewProjection;\n    vec4 color;\n    vec2 dash;\n    float width;\n    float gap_width;\n};\n\nstruct LineDashVertex {\n    vec3 position;\n    vec3 normal;\n    vec4 color;\n    float len;\n    float len_sum;\n};\n\nstruct LineDashFragment {\n    vec4 position;\n    vec4 color;\n    vec3 halfWidth;\n    vec3 len;\n    float len_sum;\n};\n\nstruct CapJoinVertex {\n    vec3 position;\n    vec3 normal;\n    vec4 color;\n    vec2 direction;\n};\n\nstruct CapJoinFragment {\n    vec4 position;\n    vec4 color;\n    vec4 radius;\n    float direction;\n};\n\nCapJoinFragment vertexCapJoin(CapJoinVertex v, UniformsLine ubo) {\n    CapJoinFragment result;\n    \n    float w = ubo.width;\n    float g = ubo.gap_width;\n    float halfWidth = (w + sign(g)*(w + g)) * 0.5;\n    vec3 radius = halfWidth * v.normal;\n    \n    result.position = ubo.modelViewProjection * vec4(v.position.xyz + vec3(radius.xy, 0.0), 1.0);\n    result.radius = vec4(radius, g * 0.5);\n    result.color = v.color * ubo.color;\n    result.direction = dot(v.direction, v.normal.xy);\n    return result;\n}\n\nvec4 fragCapJoin(CapJoinFragment f) {\n    float resolution_y = iResolution.y;\n    float kOnePixel = screen_wide / resolution_y;\n    //float kAntialiasingPixelsCount = 1.5;\n    float kAntialiasingPixelsCount = kOnePixel * 1.5;\n\n    float halfWidth = f.radius.z;\n    vec2 normal = f.radius.xy;\n    \n    float currentWidth = length(normal);\n    float diff = halfWidth - currentWidth;\n    \n    float oneUntilStepValue = clamp(diff / kOnePixel, 0.0, 1.0);\n    \n    float halfCut = step(0.0, f.direction);\n    \n    float gap_with = f.radius.w;\n    float gap_diff = gap_with - currentWidth + kAntialiasingPixelsCount;\n    float zero_until_gap = 1.0 - clamp(gap_diff / kOnePixel, 0.0, 1.0);\n    float gap_alpha = zero_until_gap;\n    \n    vec4 color = f.color;\n    return color * oneUntilStepValue * gap_alpha * halfCut;\n}\n\nLineDashFragment vertexDashedLine(LineDashVertex v, UniformsLine ubo) {\n    LineDashFragment result;\n\n    vec2 normal = v.normal.xy;\n    float w = ubo.width;\n    float g = ubo.gap_width;\n    float halfWidth = (w + sign(g)*(w + g)) * 0.5;\n    float side = v.normal.z;\n    float forInterpolateDiff = side * halfWidth;\n    result.halfWidth = vec3(forInterpolateDiff, halfWidth, g * 0.5);\n    \n    vec4 lineWidthOffset = vec4(v.position.xyz + vec3(normal, 0.0) * halfWidth, 1.0);\n    result.position = ubo.modelViewProjection * lineWidthOffset;\n\n    result.color = v.color * ubo.color;\n    result.len = vec3(v.len, ubo.dash);\n    result.len_sum = v.len_sum;\n    \n    return result;\n}\n\nvec4 fragDashedLine(LineDashFragment f) {\n    float resolution_y = iResolution.y;\n    float kOnePixel = screen_wide / resolution_y;\n    //float kAntialiasingPixelsCount = 1.5;\n    float kAntialiasingPixelsCount = kOnePixel * 1.5;\n\n    float currentWidth = abs(f.halfWidth.x);\n    float halfWidth = f.halfWidth.y;\n    float diff = halfWidth - currentWidth;\n    float one_until_bar = clamp(diff / kAntialiasingPixelsCount, 0.0, 1.0);\n    float alpha = mix(0.3, 1.0, one_until_bar);\n    \n    float gap_with = f.halfWidth.z;\n    float gap_diff = gap_with - currentWidth + kAntialiasingPixelsCount;\n    float zero_until_gap = 1.0 - clamp(gap_diff / kAntialiasingPixelsCount, 0.0, 1.0);\n    float gap_alpha = zero_until_gap;\n\n    float len = f.len.x + f.len_sum;\n    float dash = f.len.y;\n    float gap = f.len.z;\n    float partLength = dash + gap;\n    float dashLineColor = 1.0 - step(dash, mod(len, partLength));\n\n    vec4 color = f.color * alpha * dashLineColor * gap_alpha;\n\n    return color;\n}\n\nstruct LineType {\n    vec2 p0;\n    vec2 p1;\n    vec2 tangent;\n    vec2 normal;\n    float width;\n    float dash;\n    float gap;\n    float gap_width;\n    vec4 color;\n};\n\nstruct RectType {\n    vec2 start;\n    vec2 end;\n    float width;\n};\n\nstruct CapType {\n    vec2 center;\n    vec2 direction;\n    vec4 color;\n};\n\nUniformsLine make_ubo(mat4 mvp, LineType line) {\n    UniformsLine ubo;\n    ubo.modelViewProjection = mvp;\n    ubo.color = line.color;\n    ubo.dash = vec2(line.dash, line.gap);\n    ubo.gap_width = line.gap_width;\n    ubo.width = line.width;\n    return ubo;\n}\n\nLineType make_line(RectType rect, float dash, float gap, float gap_width, vec4 color) {\n    LineType line;\n    float w = rect.width;\n    float g = gap_width;\n    line.width = w;\n    line.tangent = normalize(rect.end - rect.start);\n    line.normal = vec2(-line.tangent.y, line.tangent.x);\n    line.p0 = rect.start;\n    line.p1 = rect.end;\n    line.dash = dash;\n    line.gap = gap;\n    line.color = color;\n    line.gap_width = gap_width * 0.5;\n    \n    return line;\n}\n\nstruct VertexBuffer {\n    LineDashVertex v0;\n    LineDashVertex v1;\n    LineDashVertex v2;\n    LineDashVertex v3;\n};\n\nmat4 make_id() {\n    return mat4 (\n        1.0, 0.0, 0.0, 0.0,\n        0.0, 1.0, 0.0, 0.0,\n        0.0, 0.0, 1.0, 0.0,\n        0.0, 0.0, 0.0, 1.0\n    );\n}\n\nVertexBuffer make_vb(LineType line, float len_sum) {\n    VertexBuffer vb;\n    \n    float line_len = length(line.p1 - line.p0);\n\n    vb.v0.position = vec3(line.p0, 0.0);\n    vb.v0.normal = vec3(line.normal, -1.0);\n    //vb.v0.color = vec4(1.0, 0.0, 0.0, 1.0);\n    vb.v0.color = vec4(1.0, 1.0, 1.0, 1.0);\n    vb.v0.len = 0.0;\n    vb.v0.len_sum = len_sum;\n\n    vb.v1.position = vec3(line.p0, 0.0);\n    vb.v1.normal = vec3(-line.normal, 1.0);\n    //vb.v1.color = vec4(0.0, 1.0, 0.0, 1.0);\n    vb.v1.color = vec4(1.0, 1.0, 1.0, 1.0);\n    vb.v1.len = 0.0;\n    vb.v1.len_sum = len_sum;\n\n    vb.v2.position = vec3(line.p1, 0.0);\n    vb.v2.normal = vec3(line.normal, -1.0);\n    //vb.v2.color = vec4(0.0, 0.0, 1.0, 1.0);\n    vb.v2.color = vec4(1.0, 1.0, 1.0, 1.0);\n    vb.v2.len = line_len;\n    vb.v2.len_sum = len_sum;\n\n    vb.v3.position = vec3(line.p1, 0.0);\n    vb.v3.normal = vec3(-line.normal, 1.0);\n    vb.v3.color = vec4(1.0, 1.0, 1.0, 1.0);\n    vb.v3.len = line_len;\n    vb.v3.len_sum = len_sum;\n\n    return vb;\n}\n\nstruct CapVertexBuffer {\n    CapJoinVertex v0;\n    CapJoinVertex v1;\n    CapJoinVertex v2;\n};\n\nCapVertexBuffer make_cap_vb(vec2 pos, vec2 dir) {\n    float kSqrt3 = sqrt(3.0);\n    float radius = 1.0;\n    \n    CapVertexBuffer vb;\n    vb.v0.position = vec3(pos, 0.0);\n    vb.v0.normal = vec3(-radius * kSqrt3, -radius, radius);\n    vb.v0.color = vec4(1.0, 1.0, 1.0, 1.0);\n    vb.v0.direction = dir;\n    \n    vb.v1.position = vec3(pos, 0.0);\n    vb.v1.normal = vec3(radius * kSqrt3, -radius, radius);\n    vb.v1.color = vec4(1.0, 1.0, 1.0, 1.0);\n    vb.v1.direction = dir;\n    \n    vb.v2.position = vec3(pos, 0.0);\n    vb.v2.normal = vec3(0.0, 2.0*radius, radius);\n    vb.v2.color = vec4(1.0, 1.0, 1.0, 1.0);\n    vb.v2.direction = dir;\n    \n    return vb;\n}\n\nmat3 rot_matrix(vec3 R, float a) {\n    float c = cos(a); float s = sin(a);\n    float x = R.x; float y = R.y; float z = R.z;\n    return mat3(\n        c + (1.0 - c)*x*x  , (1.0 - c)*x*y + s*z, (1.0 - c)*x*z - s*y,\n        (1.0 - c)*x*y - s*z, c + (1.0 - c)*y*y  , (1.0 - c)*y*z + s*x,\n        (1.0 - c)*x*z - s*y, (1.0 - c)*y*z - s*x, c + (1.0 - c)*z*z\n    );\n}\n\nvec2 rotate(vec2 p, vec2 z, float a) {\n    mat3 rot_mat = rot_matrix(vec3(0.0, 0.0, 1.0), a);\n    return (vec3((p - z), 0.0)*rot_mat).xy + z;\n}\n\nvec3 make_barycentric(vec4 V0, vec4 V1, vec4 V2, vec4 P) {\n    vec4 A1 = V1 - V0;\n    vec4 B1 = P - V0;\n    vec4 A2 = V2 - V1;\n    vec4 B2 = P - V1;\n    vec4 A3 = V0 - V2;\n    vec4 B3 = P - V2;\n    float inv_area = 1.0 / determinant(mat2(A1.xy, A2.xy));\n    float w1 = determinant(mat2(A1.xy, B1.xy))*inv_area;\n    float w2 = determinant(mat2(A2.xy, B2.xy))*inv_area;\n    float w3 = determinant(mat2(A3.xy, B3.xy))*inv_area;\n    return vec3(w1, w2, w3);\n}\n\nLineDashFragment interpolate_line_frag(vec3 w, LineDashFragment frag0, LineDashFragment frag1, LineDashFragment frag2) {\n    LineDashFragment f;\n    f.position  = frag0.position  * w.y + frag1.position  * w.z + frag2.position  * w.x;\n    f.color     = frag0.color     * w.y + frag1.color     * w.z + frag2.color     * w.x;\n    f.halfWidth = frag0.halfWidth * w.y + frag1.halfWidth * w.z + frag2.halfWidth * w.x;\n    f.len       = frag0.len       * w.y + frag1.len       * w.z + frag2.len       * w.x;\n    f.len_sum   = frag0.len_sum   * w.y + frag1.len_sum   * w.z + frag2.len_sum   * w.x;\n    return f;\n}\n\nCapJoinFragment interpolate_cap_frag(vec3 w, CapJoinFragment frag0, CapJoinFragment frag1, CapJoinFragment frag2) {\n    CapJoinFragment f;\n    f.position  = frag0.position  * w.y + frag1.position  * w.z + frag2.position  * w.x;\n    f.color     = frag0.color     * w.y + frag1.color     * w.z + frag2.color     * w.x;\n    f.radius    = frag0.radius    * w.y + frag1.radius    * w.z + frag2.radius    * w.x;\n    f.direction = frag0.direction * w.y + frag1.direction * w.z + frag2.direction * w.x;\n    return f;\n}\n\n//https://www.scratchapixel.com/lessons/3d-basic-rendering/rasterization-practical-implementation/rasterization-stage.html\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 resolution = iResolution.xy;\n    float aspect = resolution.x/resolution.y;\n    vec2 uv = (screen_wide*fragCoord - resolution)/resolution.y;\n    \n    float kOnePixel = screen_wide / resolution.y;\n    float kHalfPixel = kOnePixel * 0.5;\n    \n    vec2 line1_start = vec2(0.0, 0.0);\n    vec2 line1_end = vec2(0.5, 0.0);\n    vec2 line2_end = vec2(1.0, 0.5);\n    vec4 line_color = vec4(1.0, 0.0, 0.0, 1.0);\n    float line_width = kOnePixel * 60.0;\n    float line_gap_width = kOnePixel * 30.0;\n    float scale_dash = (line_width + sign(line_gap_width)*(line_width + line_gap_width));\n    //float line_dash = scale_dash * 1.0;\n    float line_dash = scale_dash * 1.0 + iTime*0.025;\n    float line_gap = scale_dash * 1.0;\n    \n    //float alpha_rad = iTime*PI*0.25;\n    float alpha_rad = 0.0;\n    \n    line1_end = rotate(line1_end, line1_start, alpha_rad);\n    line2_end = rotate(line2_end, line1_end, alpha_rad);\n    \n    vec4 result_color = bg_color;\n    \n    float line1_len = length(line1_end - line1_start);\n    vec2 line2_direction = line2_end - line1_end;\n    float line2_len = length(line2_direction);\n    \n    RectType rect1 = RectType(line1_start, line1_end, line_width);\n    LineType line1 = make_line(rect1, line_dash, line_gap, line_gap_width, line_color);\n    RectType rect2 = RectType(line1_end, line2_end, line_width);\n    LineType line2 = make_line(rect2, line_dash, line_gap, line_gap_width, line_color);\n\n    UniformsLine ubo = make_ubo(make_id(), line1);\n\n    VertexBuffer vb1 = make_vb(line1, 0.0);\n    LineDashFragment frag0 = vertexDashedLine(vb1.v0, ubo);\n    LineDashFragment frag1 = vertexDashedLine(vb1.v1, ubo);\n    LineDashFragment frag2 = vertexDashedLine(vb1.v2, ubo);\n    LineDashFragment frag3 = vertexDashedLine(vb1.v3, ubo);\n    \n    frag0.position = vec4(frag0.position.xyz / frag0.position.w, 1.0);\n    frag1.position = vec4(frag1.position.xyz / frag1.position.w, 1.0);\n    frag2.position = vec4(frag2.position.xyz / frag2.position.w, 1.0);\n    frag3.position = vec4(frag3.position.xyz / frag3.position.w, 1.0);\n\n    VertexBuffer vb2 = make_vb(line2, line1_len);\n    LineDashFragment frag4 = vertexDashedLine(vb2.v0, ubo);\n    LineDashFragment frag5 = vertexDashedLine(vb2.v1, ubo);\n    LineDashFragment frag6 = vertexDashedLine(vb2.v2, ubo);\n    LineDashFragment frag7 = vertexDashedLine(vb2.v3, ubo);\n    \n    frag4.position = vec4(frag4.position.xyz / frag4.position.w, 1.0);\n    frag5.position = vec4(frag5.position.xyz / frag5.position.w, 1.0);\n    frag6.position = vec4(frag6.position.xyz / frag6.position.w, 1.0);\n    frag7.position = vec4(frag7.position.xyz / frag7.position.w, 1.0);\n    \n    vec4 P = vec4(uv.xy, 0.0, 1.0);\n    \n    vec3 t1_w = make_barycentric(frag0.position, frag1.position, frag2.position, P);\n    if(t1_w.x >= 0.0 && t1_w.y >= 0.0 && t1_w.z >= 0.0) {\n        \n        LineDashFragment f = interpolate_line_frag(t1_w, frag0, frag1, frag2);\n        vec4 color = fragDashedLine(f);\n        result_color = mix(result_color, color, color.a);\n    }\n    \n    vec3 t2_w = make_barycentric(frag1.position, frag3.position, frag2.position, P);\n    if(t2_w.x >= 0.0 && t2_w.y >= 0.0 && t2_w.z >= 0.0) {\n        \n        LineDashFragment f = interpolate_line_frag(t2_w, frag1, frag3, frag2);\n        vec4 color = fragDashedLine(f);\n        result_color = mix(result_color, color, color.a);\n    }\n    \n    vec3 t3_w = make_barycentric(frag4.position, frag5.position, frag6.position, P);\n    if(t3_w.x >= 0.0 && t3_w.y >= 0.0 && t3_w.z >= 0.0) {\n        \n        LineDashFragment f = interpolate_line_frag(t3_w, frag4, frag5, frag6);\n        vec4 color = fragDashedLine(f);\n        result_color = mix(result_color, color, color.a);\n    }\n    \n    vec3 t4_w = make_barycentric(frag5.position, frag7.position, frag6.position, P);\n    if(t4_w.x >= 0.0 && t4_w.y >= 0.0 && t4_w.z >= 0.0) {\n        \n        LineDashFragment f = interpolate_line_frag(t4_w, frag5, frag7, frag6);\n        vec4 color = fragDashedLine(f);\n        result_color = mix(result_color, color, color.a);\n    }\n    \n    CapVertexBuffer cap_vb = make_cap_vb(line2_end, line2_direction);\n    CapJoinFragment cap_frag0 = vertexCapJoin(cap_vb.v0, ubo);\n    CapJoinFragment cap_frag1 = vertexCapJoin(cap_vb.v1, ubo);\n    CapJoinFragment cap_frag2 = vertexCapJoin(cap_vb.v2, ubo);\n    \n    vec3 t5_w = make_barycentric(cap_frag0.position, cap_frag1.position, cap_frag2.position, P);\n    if(t5_w.x >= 0.0 && t5_w.y >= 0.0 && t5_w.z >= 0.0) {\n        //result_color = vec4(0.0, 1.0, 0.0, 1.0);\n        CapJoinFragment f = interpolate_cap_frag(t5_w, cap_frag0, cap_frag1, cap_frag2);\n        vec4 color = fragCapJoin(f);\n        result_color = mix(result_color, color, color.a);\n    }\n    \n    fragColor = result_color;\n}","name":"Image","description":"","type":"image"}]}