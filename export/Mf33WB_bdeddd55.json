{"ver":"0.1","info":{"id":"Mf33WB","date":"1731691652","viewed":52,"name":"Raymarched Planet","username":"Tsuki","description":"An old project of mine.\n\nThanks Bingle and morimea for heling me fix this glitchy terrain.","likes":9,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","noise","terrain"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Noise generation method: https://gist.github.com/patriciogonzalezvivo/670c22f3966e662d2f83\n\nfloat mod289(float x){return x - floor(x * (1.0 / 289.0)) * 289.0;}\nvec4 mod289(vec4 x){return x - floor(x * (1.0 / 289.0)) * 289.0;}\nvec4 perm(vec4 x){return mod289(((x * 34.0) + 1.0) * x);}\n\nfloat noise(vec3 p){\n    vec3 a = floor(p);\n    vec3 d = p - a;\n    d = d * d * (3.0 - 2.0 * d);\n\n    vec4 b = a.xxyy + vec4(0.0, 1.0, 0.0, 1.0);\n    vec4 k1 = perm(b.xyxy);\n    vec4 k2 = perm(k1.xyxy + b.zzww);\n\n    vec4 c = k2 + a.zzzz;\n    vec4 k3 = perm(c);\n    vec4 k4 = perm(c + 1.0);\n\n    vec4 o1 = fract(k3 * (1.0 / 41.0));\n    vec4 o2 = fract(k4 * (1.0 / 41.0));\n\n    vec4 o3 = o2 * d.z + o1 * (1.0 - d.z);\n    vec2 o4 = o3.yw * d.x + o3.xz * (1.0 - d.x);\n\n    return o4.y * d.y + o4.x * (1.0 - d.y);\n}\n\nfloat fbm(vec3 x, int NUM_OCTAVES) {\n\tfloat v = 0.0;\n\tfloat a = 0.5;\n\tvec3 shift = vec3(100);\n\tfor (int i = 0; i < NUM_OCTAVES; ++i) {\n\t\tv += a * noise(x);\n\t\tx = x * 2.0 + shift;\n\t\ta *= 0.5;\n\t}\n\treturn v;\n}\n\n\n////////////////////////////////////////////////////////\n\n////////////////////////////////////////////////////////\n\nmat2 rotate(float a) {\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat distanceFromSphere( vec3 pos, vec4 sphere ) {\n    return length(pos - sphere.xyz) - sphere.w;\n}\n\nfloat mapWorld (in vec3 pos, in vec4 sphere)\n{\n    pos.zx *= rotate(iTime * 0.1);\n    pos.xy *= rotate(iTime * 0.1);\n    pos.yz *= rotate(iTime * 0.1);\n\n    \n    float sphere0 = distanceFromSphere(pos, sphere);\n    float displacement = fbm(pos / 3., 3) * -2.;\n\n    return sphere0 + displacement;\n}\n\nvec3 calculateNormal (in vec3 pos, in vec4 sphere)\n{\n    const vec3 small_step = vec3(0.001, 0.0, 0.0);\n\n    float gradient_x = mapWorld(pos + small_step.xyy, sphere) - mapWorld(pos - small_step.xyy, sphere);\n    float gradient_y = mapWorld(pos + small_step.yxy, sphere) - mapWorld(pos - small_step.yxy, sphere);\n    float gradient_z = mapWorld(pos + small_step.yyx, sphere) - mapWorld(pos - small_step.yyx, sphere);\n\n    vec3 normal = vec3(gradient_x, gradient_y, gradient_z);\n\n    return normalize(normal);\n}\n\nvec3 colorGradient( vec3 pos, vec4 sphere ) {\n    float x = mapWorld(pos, sphere) - distanceFromSphere(pos, sphere);\n    x /= -2.;\n\n    if( x > 0.7 ) {\n        return vec3(1.);\n    } else if( x > 0.6 ) {\n        return vec3(0.25);\n    } else if( x > 0.5 ) {\n        return vec3(0., 0.6, 0.);\n    } else if( x > 0.4 ) {\n        return vec3(0., 0.8, 0.);\n    } else if( x > 0.39 ) {\n        return vec3(0.8, 0.8, 0.);\n    } else if( x > 0.3 ){\n        return vec3(0., 0.5, 1.);\n    } else if( x > 0.2 ){\n        return vec3(0., 0., 1.);\n    } else if( x > 0. ){\n        return vec3(0., 0., 0.5);\n    }\n}\n\nvec3 raymarch(in vec3 rayOrigin, in vec3 rayDirection, in vec3 lightSource, in vec4 sphere, in vec2 uv) {\n    \n    float distanceTraveled = 0.0;\n    float closestDistance = iResolution.x + iResolution.y;\n    \n    const int NUMBER_OF_STEPS = 128;\n    const float MINIMUM_HIT_DISTANCE = 0.01;\n    const float MAXIMUM_TRACE_DISTANCE = 100.0;\n    \n    for (int i = 0; i < NUMBER_OF_STEPS; ++i) {\n    \n        vec3 currentPos = rayOrigin + distanceTraveled * rayDirection;\n\n        float distanceToClosest = mapWorld(currentPos, sphere);\n\n        if (distanceToClosest < MINIMUM_HIT_DISTANCE) {\n        \n            vec3 normal = calculateNormal(currentPos, sphere);\n            vec3 directionToLight = normalize(currentPos - lightSource);\n\n            float diffuseIntensity = max(0.0, dot(normal, directionToLight));\n            vec3 color = colorGradient(currentPos, sphere);\n\n            return color * diffuseIntensity * 1.5; //(fbm(currentPos, 4)\n        }\n        \n        if (closestDistance > distanceToClosest) {\n            closestDistance = distanceToClosest;\n        }\n\n        if (distanceTraveled > MAXIMUM_TRACE_DISTANCE) {\n            \n            break;\n        }\n        \n        distanceTraveled += distanceToClosest * 0.7;\n    }\n    \n    return vec3(0., 1., 0.);\n}\n\n////////////////////////////////////////////////////////\n\n////////////////////////////////////////////////////////\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord * 2. - iResolution.xy) / iResolution.y;\n    // Time varying pixel color\n    //vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    \n    vec3 cameraPosition = vec3(0.0, 0.0, -15.0);\n    vec3 rayOrigin = cameraPosition;\n    vec3 rayDirection = vec3(uv, 1.0);\n    \n    vec3 lightSource = vec3(10.0, -5.0, -1.0);\n    \n    vec3 spherePos = vec3(0.0, 0.0, 0.0); // Position\n    \n    vec4 sphere = vec4(spherePos, 10.0); // Radius\n    \n    vec3 col = raymarch(rayOrigin, rayDirection, lightSource, sphere, uv);\n       \n    if( col == vec3(0., 1., 0.)) {\n        fragColor = vec4(0.0); //texture(iChannel0, uv / 2.0) * 1.5 - 0.25;\n    } else {\n        fragColor = vec4(vec3(col),1.);\n    }\n        \n}","name":"Image","description":"","type":"image"}]}