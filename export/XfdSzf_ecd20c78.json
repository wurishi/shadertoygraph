{"ver":"0.1","info":{"id":"XfdSzf","date":"1714255676","viewed":433,"name":"Model Challenge","username":"Xor","description":"Trying to recreate [url=https://twitter.com/odd_enough/status/1783921824016809985]this[/url]","likes":22,"published":1,"flags":0,"usePreview":0,"tags":["tutorial","raymarcher"],"hasliked":0,"parentid":"7ldfzj","parentname":"Xor's Basic Raymarcher"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n    \"Model Challenge\" by @XorDev\n\n    https://twitter.com/odd_enough/status/1783921824016809985\n    \n    This is a little guide on raymarching to go along with my mini tutorial series:\n    https://mini.gmshaders.com/p/gm-shaders-mini-raymarching-1351092\n    \n    \n    \n    Original: https://www.shadertoy.com/view/7ldfzj\n*/\n\n//Raymarcher \"Epsilon\" meaning how close to the surface we need to get to stop the loop\n#define EPS 0.001\n//Max distance to travel before we stop the loop\n#define MAX 50.0\n//Light direction vector\n#define LIGHT normalize(vec3(1,3,-1))\n//Gamma for gamma correction\n#define GAMMA 2.2\n\n\n//Smooth max/min function from iq\nfloat blend(float a, float b, float k)\n{\n    return log(exp(a*k)+exp(b*k))/k;\n}\n//SDF to cylinder\nfloat cylinder_x(vec3 p,float t, float l)\n{\n    vec2 d = vec2(abs(p.x)-l,length(p.yz)-t);\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\nmat2 rotate(float a)\n{\n    return mat2(cos(a+asin(vec4(0,-1,1,0))));\n}\n//Distance field function\nfloat dist(vec3 p)\n{\n    vec2 A = iMouse.xy/iResolution.xy*vec2(6.2831,3.1415);\n    if (A==-A) A = vec2(2.9,1.1);\n    \n    p.xz *= rotate(A.x);\n    p.yx *= rotate(-.3);\n    p.yz *= rotate(A.y);\n    \n    float d = cylinder_x(p,.4,.5);\n    \n    p.y -= .4;\n    p.xy *= mat2(1,-1,1,1)*sqrt(.5);\n    \n    d = blend(d,cylinder_x(p-vec3(.2,0,0),.2,.2),-50.);\n    d = blend(d,-cylinder_x(p+vec3(.2,0,0),.2,.2),50.);\n    \n    return d;\n}\n\n\n//Compute normal from the distance field\nvec3 normal(vec3 p)\n{\n    //Signed epsilon for computing distance field derivative\n    const vec2 e = vec2(2, -2) * EPS;\n    \n    //Basically we're offsetting by slight amounts and computing rate of change.\n    //This tells us which direction is most positive and then we normalize the vector.\n    return normalize(dist(p+e.xxy)*e.xxy + dist(p+e.xyx)*e.xyx + dist(p+e.yxx)*e.yxx + dist(p+e.y)*e.y);\n}\n//Basic raymarching function\nvec4 raymarch(vec3 pos, vec3 dir)\n{\n\tfloat d = 0.0; //Starting distance\n\n\tfor(int i = 0; i<200; i++) //Step 200 times\n\t{\n\t\tfloat step_dist = dist(pos + dir * d); //Check distance field\n\t\td += step_dist; //March forward\n\t\tif (step_dist<EPS || d>MAX) break; //Stop at intersection or max distance\n\n\t}\n\treturn vec4(pos + dir * d, d); //Return intersection point and distance\n\n}\n//Basic soft shadow function\nfloat shadow(vec3 pos, vec3 dir, float mx)\n{\n    float d = 0.01; //Starting distance\n    float s = 1.0; //Shadow value\n\n\tfor(int i = 0; i<40; i++) // Step 40 times\n\t{\n\t\tfloat step_dist = dist(pos + dir * d); //Check distance field\n\t\td += step_dist; //March forward\n        \n        \n\t\tif (step_dist<EPS) return 0.0; //Stop at intersection\n        if (d>mx) break; //Stop at max distance\n        s = min(s, step_dist / d * 5.0); //Brightness from proximity\n\n\t}\n\treturn s; //Return shadow brightness\n}\n//Sample color at any given point\nvec3 color(vec3 pos, vec3 dir, float dep)\n{\n    //Get normal\n    vec3 n = normal(pos);\n    vec3 col = vec3(1);\n    \n    //Dot product lighting\n    float light = dot(n, LIGHT);\n    //Fade to black\n    light = max(light, 0.1+light*0.1);\n    \n    //Shadow raymarching\n    float shade = shadow(pos, LIGHT, MAX)*0.9+0.1;\n    //Blend the shading together with ambient light\n    vec3 amb = pow(vec3(0.01,0.2,0.3), vec3(GAMMA));\n    col *= mix(amb, vec3(1), min(light, shade));\n    \n    //Compute sky color using simple gradient\n    vec3 sky = pow(vec3(0), vec3(GAMMA));\n    //Fade to background sky color\n    col = mix(col, sky, smoothstep(0.0, MAX, dep));\n    \n    //Set color from dot lighting\n    return col;\n}\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    //Camera position (scrolling forward)\n    vec3 p = vec3(0,0,-1.7);\n    //Ray direction\n    vec3 d = normalize(vec3(fragCoord-.5*iResolution.xy,iResolution.y));\n    \n    //Find raymarch intersection\n    vec4 m = raymarch(p, d);\n    //Find color at intersection\n    vec3 c = color(m.xyz, d, m.w);\n    \n    c = pow(c, vec3(1.0/GAMMA));\n        \n    //Output color\n    fragColor = vec4(c, 1.0);\n}","name":"Image","description":"","type":"image"}]}