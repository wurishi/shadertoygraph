{"ver":"0.1","info":{"id":"XdcSWX","date":"1461688427","viewed":171,"name":"Lighting/Coloring Test","username":"gsitcia","description":"Figured out a less cop out way to do lighting. Also added color. Use the mouse to move the camera.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat udBox( vec3 p, vec3 b )\n{\n  return length(max(abs(p)-b,0.0));\n}\n\nfloat sdCone( vec3 p, vec2 c )\n{\n    // c must be normalized\n    float q = length(p.xy);\n    return dot(c,vec2(q,p.z));\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat rpBox( vec3 p, vec3 c ) {\n    vec3 q = mod(p,c)-0.5*c;\n    return udBox( p, vec3(0.5, 0.5, 0.5) );\n}\n\nfloat sdPlane( vec3 p )\n{\n  // n must be normalized\n  return p.y;\n}\n\nfloat omap( vec3 p ) {\n    float d1 = sdPlane( p );\n    float d2 = sdSphere( p - vec3(0.0, 0.5, 0.0), 1.0);\n    float d3 = udBox( p - vec3(-1.0, 1.0, 0.0), vec3(1.7, 2.0, 2.0) );\n    float d4 = sdSphere( p - vec3(0.0, 0.5, 0.0), 2.0);\n    return min(max(-d2, max(d3, d4)), d1);\n}\n\nfloat map( vec3 p ) {\n    float d1 = sdPlane(p);\n    float d2 = udBox( p - vec3(0.0, 0.9, 0.0), vec3(0.1, 0.9, 0.4) );\n    float d3 = udBox( p - vec3(1.0, 0.2, 0.0), vec3(0.2, 0.2, 0.2) );\n    return min(min(d1, d3), d2);\n}\n\nvec3 cmap( vec3 p ) {\n    float d1 = sdPlane(p); // White\n    float d2 = udBox( p - vec3(0.0, 0.9, 0.0), vec3(0.1, 0.9, 0.4) ); // Dark Gray\n    float d3 = udBox( p - vec3(1.0, 0.2, 0.0), vec3(0.2, 0.2, 0.2) ); // Barely White\n    float z = min(d1, d2);\n    z = min(z, d3);\n    if (z == d1) {\n        return vec3(1.0, 0.5, 0.3);\n    }\n    if (z == d2) {\n        return vec3(0.1, 0.3, 0.1);\n    }\n    if (z == d3) {\n        return vec3(0.6, 0.6, 0.4);\n    }\n    return vec3(0.0, 0.0, 0.0);\n}\n\nvec3 norm( vec3 p, vec3 dir ) {\n    vec3 up = normalize(vec3(dir.x, 0.0, dir.z)) * -dir.y + vec3(0.0, 1.0, 0.0) * length(dir.xz);\n    up = normalize(up);\n    vec3 down = -1.0 * up;\n    vec3 right = cross(dir, up);\n    vec3 left = -1.0 * right;\n    \n    float mp = map(p);\n    up *= mp;\n    down *= mp;\n    right *= mp;\n    left *= mp;\n    \n    vec3 pu = p + up;\n    vec3 pd = p + down;\n    vec3 pr = p + right;\n    vec3 pl = p + left;\n    \n    float mu = map(pu);\n    float md = map(pd);\n    float mr = map(pr);\n    float ml = map(pl);\n    \n    // up down part\n    vec2 ud1 = normalize(vec2(sqrt(mu * md), mp - mu));\n    vec2 ud2 = normalize(vec2(sqrt(mu * md), mp - md));\n    \n    // right left part\n    vec2 rl1 = normalize(vec2(sqrt(mu * md), mp - mr));\n    vec2 rl2 = normalize(vec2(sqrt(mu * md), mp - ml));\n    \n    vec3 norm1 = -1.0 * normalize(ud1.x * up + ud1.y * dir + rl1.x * right + rl1.y * dir);\n    vec3 norm2 = -1.0 * normalize(ud2.x * up + ud2.y * dir + rl2.x * right + rl2.y * dir);\n    \n    dir = -1.0 * dir;\n    \n    if (abs(distance(norm1, dir) - distance(norm2, dir)) < 0.01) {\n        return (norm1 + norm2) / 2.0;\n    }\n    \n    if (distance(norm1, dir) > distance(norm2, dir)) {\n        return norm1;\n    } else {\n        return norm2;\n    }\n}\n\nfloat shadow( vec3 p, vec4 l ) {\n    vec3 dr = normalize(p - l.xyz);\n    float dst = 0.0;\n    float res = 1.0;\n    for (int i = 0; i < 100; ++i) {\n        float dt = map(l.xyz);\n        l.xyz += dr * dt * 0.8;\n        dst += dt * 0.8;\n        if (dt < 0.0001) {\n            if (distance(l.xyz, p) < 0.001) {\n                return res;\n            } else {\n            \treturn 0.0;\n            }\n        }\n        res = min(res, 4.0 * dt * dst / length(p - l.xyz));\n    }\n    return res * l.w;\n}\n\nfloat shadown( vec3 p, vec4 l ) {\n    vec3 dr = normalize(p - l.xyz);\n    vec3 orig = l.xyz;\n    float dst = 0.0;\n    for (int i = 0; i < 100; ++i) {\n        float dt = map(l.xyz);\n        l.xyz += dr * dt * 0.8;\n        dst += dt * 0.8;\n        if (dt < 0.0001) {\n            if (distance(l.xyz, orig) < 0.0001) {\n                return 0.0;\n            } else {\n                return 1.0;\n            }\n        }\n    }\n    return 0.0;\n}\n\nvec3 lights( vec3 p, vec4 l, vec4 ldir ) {\n    float dt = map( p );\n    vec3 ld = normalize(p - l.xyz);\n    vec3 ds = norm(p, ld);\n    float li = dot(ds, ld);\n   \treturn cmap(p) * li * l.w * pow(clamp(ldir.w/distance(ld, ldir.xyz), 0.0, 1.0), 1.0/ldir.w);\n    /*if (distance(ld, ldir.xyz) < ldir.w) {\n    \treturn cmap(p) * li * l.w;\n    } else {\n        return vec3(0.03, 0.03, 0.03);\n    }*/\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec3 id = vec3(1.0, 1.0, 1.0);\n    \n    float mindist = min(iResolution.x, iResolution.y);\n    \n    vec3 uv = vec3((gl_FragCoord.xy - iResolution.xy / 2.0) / mindist, 0.0);\n    \n    // vec3 eye = vec3((2.0 * (iMouse.xy - iResolution.xy / 2.0) / mindist) + vec2(0.0, 1.0), -2.5);\n    \n    vec3 eye = vec3(3.0 * sin(iMouse.x * 3.141592 / 360.0), (iResolution.y - iMouse.y) / 45.0 , 3.0 * cos(iMouse.x * 3.141592 / 360.0));\n    \n    // vec3 eye = 1.0 *vec3(2.0 * sin(iTime * 3.141592 / 50.0), 2.0, 2.0  * cos(iTime * 3.141592 / 50.0));\n    \n    float fl = 1.0;\n    \n    vec3 fo = normalize(-1.0 * eye);\n    \n    // vec3 up = normalize(vec3(0.0, 1.0, 0.0)); // 2 point perspective\n    \n    vec3 up;\n    \n    up.xz = -1.0 * fo.xz;\n    \n    up.xz *= fo.y / length(fo.xz);\n    \n    up.y = length(fo.xz); // 3 point perspective\n    \n    vec3 si = cross(up, fo);\n    \n    uv = eye + fl * fo + uv.x * si + uv.y * up;\n    \n    vec3 dr = uv - eye;\n    \n    dr = dr / length(dr);\n    \n    float dt = 0.0;\n    \n    for (int i = 0; i < 1000; ++i) {\n        dt = map( uv );\n        if (dt < 0.0001) {\n            dt = float(i);\n            break;\n        }\n        uv = uv + dr * dt * 0.8;\n    }\n    \n    // reflect\n    /*\n    if (abs(uv.y) > 0.001) {\n    \tdt = map( uv );\n    \t\n    \tvec3 ds;\n    \tds.x = min(map( uv + vec3(dt, 0.0, 0.0) ), map( uv - vec3(dt, 0.0, 0.0) ));\n    \tds.y = min(map( uv + vec3(0.0, dt, 0.0) ), map( uv - vec3(0.0, dt, 0.0) ));\n    \tds.z = min(map( uv + vec3(0.0, 0.0, dt) ), map( uv - vec3(0.0, 0.0, dt) ));\n    \tds = normalize(-1.0 * ds);\n    \t\n    \tfloat kfe = 2.0 * dot(ds, -dr) / dot(ds, ds);\n    \t\n    \tdr = kfe * dr - ds;\n    \t\n    \tdt = 1.0;\n    \t\n    \tfor (int i = 0; i < 100; ++i) {\n    \t    if (dt < 0.0001) {\n    \t        dt = float(i);\n    \t        break;\n    \t    }\n    \t    uv = uv + dr * dt * 0.8;\n            dt = map( uv );\n    \t}\n    }\n    \n    // vec3 dc = vec3(dt, dt, dt) / 50.0;\n   \t\n    /* if (dt == 100.0) {\n       \tdc = vec3(0.0, 1.0, 0.5);\n    } else {\n        dc = vec3(dt, dt, dt) / 50.0;\n    } */\n    \n    vec4 light = vec4(3.0 * sin(iTime * 3.141592 / 45.0), 3.0, 3.0  * cos(iTime * 3.141592 / 45.0), 2.0);\n    \n    vec4 lightdir = vec4(normalize(-1.0 * light.xyz), 0.3);\n    \n    vec3 dc = shadow( uv, light ) * lights( uv, light, lightdir );\n    \n    fragColor = vec4(dc, 0.0);\n}","name":"Image","description":"","type":"image"}]}