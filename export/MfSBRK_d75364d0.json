{"ver":"0.1","info":{"id":"MfSBRK","date":"1725178887","viewed":23,"name":"dancing mouse","username":"dragonmuffin","description":"dancing mouse","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["3d"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const int MAX_STEPS = 1000;\nconst float FAR = 400.;\nconst float EPS = 0.0001;\n//const vec3 CAM_POS = vec3(0.,-10.,0.);\nconst vec3 RED = vec3(1.,0.,0.);\nconst vec3 BLUE = vec3(0.,0.,1.);\nconst vec3 BACKGROUND = vec3(0.,.5,.5);\nconst vec3 LGRAY = vec3(.8);\nconst vec3 DGRAY = vec3(.4);\nconst vec3 MGRAY = vec3(.6);\nconst vec3 BLACK = vec3(0.);\nconst vec3 WHITE = vec3(1.);\nconst float AMBIENT = .4;\nconst float DIFFUSE = 1. - AMBIENT;\nconst float pi = 3.1415926;\n//const vec3 LIGHT_POS = vec3(2., 0., 0.);\n\nmat3 rotx(float alp) {\n    float s=sin(alp);float c=cos(alp);\n    return mat3(\n        vec3(1,0,0),\n        vec3(0,c,-s),\n        vec3(0,s,c)\n    );\n}\n\nmat3 roty(float alp) {\n    float s=sin(alp);float c=cos(alp);\n    return mat3(\n        vec3(c,0,s),\n        vec3(0,1,0),\n        vec3(-s,0,c)\n    );\n}\n\nmat3 rotz(float alp) {\n    float s=sin(alp);float c=cos(alp);\n    return mat3(\n        vec3(c,-s,0),\n        vec3(s,c,0),\n        vec3(0,0,1)\n    );\n}\n\nfloat SphereSdf(in vec3 center, in float radius, in vec3 crd) {\n    return length(crd-center)-radius;\n}\n\nfloat FloorSdf(in vec3 crd) {\n    return abs(crd.z+5.);\n}\n\nfloat sdCone(vec3 p, vec2 c, float h)\n{\n  // c is the sin/cos of the angle, h is height\n  // Alternatively pass q instead of (c,h),\n  // which is the point at the base in 2D\n  vec2 q = h*vec2(c.x/c.y,-1.0);\n    \n  vec2 w = vec2( length(p.xz), p.y );\n  vec2 a = w - q*clamp( dot(w,q)/dot(q,q), 0.0, 1.0 );\n  vec2 b = w - q*vec2( clamp( w.x/q.x, 0.0, 1.0 ), 1.0 );\n  float k = sign( q.y );\n  float d = min(dot( a, a ),dot(b, b));\n  float s = max( k*(w.x*q.y-w.y*q.x),k*(w.y-q.y)  );\n  return sqrt(d)*sign(s);\n}\n\n\nfloat sdVesicaSegment( in vec3 p, in vec3 a, in vec3 b, in float w )\n{\n    vec3  c = (a+b)*0.5;\n    float l = length(b-a);\n    vec3  v = (b-a)/l;\n    float y = dot(p-c,v);\n    vec2  q = vec2(length(p-c-y*v),abs(y));\n    \n    float r = 0.5*l;\n    float d = 0.5*(r*r-w*w)/w;\n    vec3  h = (r*q.x<d*(q.y-r)) ? vec3(0.0,r,0.0) : vec3(-d,0.0,d+w);\n \n    return length(q-h.xy) - h.z;\n}\n\nfloat sdEllipsoid( vec3 p, vec3 r )\n{\n  float k0 = length(p/r);\n  float k1 = length(p/(r*r));\n  return k0*(k0-1.0)/k1;\n}\n\nfloat opSmoothUnion( float d1, float d2, float k )\n{\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\nfloat opSmoothSubtraction( float d1, float d2, float k )\n{\n    //return max(d1,-d2);\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h);\n}\n\nvec4 colmin(vec4 a,vec4 b) {// minimum with color\n    return (a.x < b.x)?a:b;\n}\n\nvec4 SceneSdf(in vec3 crd) {\n    vec3 reflectedcrd = vec3(abs(crd.x),crd.yz);\n    vec4 d = vec4(FloorSdf(crd),mod(floor(crd.x)+floor(crd.y),2.0)>0.?LGRAY:DGRAY);\n    float head = sdCone(crd*rotz(pi),vec2(0.1,0.4),1.5)-0.2;\n    head = opSmoothUnion(head,SphereSdf(vec3(0.,2.2,.3),1.2,crd),.2);\n    float ear = sdVesicaSegment(reflectedcrd,vec3(0.,2.4,.5),vec3(1.8,2.4,2.2),.6);\n    ear = opSmoothSubtraction(sdVesicaSegment(reflectedcrd, vec3(0.,1.9,.5), vec3(1.8,1.9,2.2),.2), ear, 0.2);\n    head = min(head,ear);\n    d = colmin(d,vec4(head,(length(crd.xz - vec2(0.,-.4)) < .3 && length(crd.xz - vec2(0.,-.2)) > .3)?WHITE:MGRAY));\n    float nose = SphereSdf(vec3(0.,-.2,0.),.15,crd);\n    d = colmin(d,vec4(nose,BLACK));\n    float eyes = SphereSdf(vec3(.5,1.24,.8),.1,reflectedcrd);\n    d = colmin(d,vec4(eyes,BLACK));\n    float body = sdEllipsoid(crd-vec3(0.,2.4,-2.6),vec3(1.,1.,1.9));\n    d = colmin(d,vec4(body,MGRAY));\n    float legs = SphereSdf(vec3(1.2,2.4,-5.),1.,reflectedcrd);\n    d = colmin(d,vec4(legs,MGRAY));\n    float rarm = sdEllipsoid(((crd-vec3(0.,2.4,-2.))*roty(-.8)*rotx(sin(iTime*8.)-pi/2.)-vec3(0.,0.,2.)),vec3(.2,.2,1.));\n    d = colmin(d,vec4(rarm,MGRAY));\n    float larm = sdEllipsoid(((crd-vec3(0.,2.4,-2.))*roty(-pi/2.)-vec3(0.,0.,-2.)),vec3(.2,.2,1.));\n    d = colmin(d,vec4(larm,MGRAY));\n    return d;\n}\n\nvec3 calc_norm(in vec3 p) {\n    const float eps = 0.001;\n    const vec2 h = vec2(eps,0);\n    return normalize(vec3(SceneSdf(p + h.xyy).x - SceneSdf(p - h.xyy).x,\n                          SceneSdf(p + h.yxy).x - SceneSdf(p - h.yxy).x,\n                          SceneSdf(p + h.yyx).x - SceneSdf(p - h.yyx).x));\n}\n\nfloat RayMarch(in vec3 start, in vec3 orientation) {\n    vec3 pos = start;\n    float dist;\n    float depth = 0.;\n    for(int i=0;i<MAX_STEPS;i++) {\n        dist = SceneSdf(pos).x;\n        if(dist<EPS || depth>FAR) {\n            break;\n        }\n        depth += dist;\n        pos = start + orientation * depth;\n    }\n    return depth;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec3 CAM_POS = vec3(0.,-10.,0.);\n    float rotan = iMouse.x/iResolution.x*8.-4.;\n    CAM_POS *= rotz(rotan);\n    //vec3 LIGHT_COL = vec3();\n    vec3 LIGHT_POS;\n    vec3 LIGHT_COL;\n    if(mod(floor(iTime/pi*8.),2.)<1.) {\n        LIGHT_POS = vec3(5.,0.,0.);\n        LIGHT_COL = vec3(0.,1.,0.);\n    } else {\n        LIGHT_POS = vec3(-5.,0.,0.);\n        LIGHT_COL = vec3(1.,0.,0.);\n    }\n    if(mod(floor(iTime/pi*8.),3.) < 1.) {\n        LIGHT_COL = vec3(1.,0.,0.);\n    } else if(mod(floor(iTime/pi*8.),3.) < 2.){\n        LIGHT_COL = vec3(0.,1.,0.);\n    } else{\n        LIGHT_COL = vec3(0.,0.,1.);\n    }\n    vec2 uv = fragCoord/iResolution.xy-0.5;\n    uv.x *= iResolution.x/iResolution.y;\n    vec3 orientation = normalize(vec3(uv.x,1.,uv.y))*rotz(rotan);\n    float dpt = RayMarch(CAM_POS,orientation);\n    if(dpt>FAR) {\n        fragColor = vec4(BACKGROUND,1.);\n        return;\n    }\n    vec3 pos = CAM_POS + orientation * dpt;\n    vec3 norm = calc_norm(pos);\n    vec3 lo = normalize(LIGHT_POS - pos); // light orientation\n    float k = AMBIENT + DIFFUSE * max(dot(norm,lo),0.);\n    if(RayMarch(pos + norm * EPS, lo) < length(LIGHT_POS - pos)) {\n        k = AMBIENT;\n    }\n    vec3 col = SceneSdf(pos).yzw * k * LIGHT_COL;\n    fragColor = vec4(col,1.);\n}\n\n","name":"Image","description":"","type":"image"}]}