{"ver":"0.1","info":{"id":"3dfXDH","date":"1551209090","viewed":359,"name":"Bird VS Mankind","username":"Kushulain","description":"Help bird escape mankinds fractal.\n\n- Drag the mouse from view center (roll & ptich)\n- ESDF (yaw & thrust)\n\nCredits :\nFractal formula : PauloFalcao\nQuaternion implementation : ciberxtrem\nMusic : Jake Chudnow\nShadertoy : Thanks for the 3dfx in the URL ! :D","likes":20,"published":1,"flags":113,"usePreview":0,"tags":["fractal","ray","interactive","marching","city","physics","fly"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"MtXGW4","filepath":"https://soundcloud.com/jakechudnow/pressed-pennies","previewfilepath":"https://soundcloud.com/jakechudnow/pressed-pennies","type":"musicstream","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float time;\n\nvec4 Get(float var)\n{\n    return texture(iChannel0,vec2(varWdth*0.5 + var * varWdth,0.2)/iResolution.xy).rgba;\n}\n\nvec3 lmp;\nvec3 camPos;\nvec4 camQuat;\nvec3 dpos;\nvec3 rd;\n\n\nvec4 GetSamplePosVR(vec3 origin, vec3 dir)\n{\n    dir.x = -dir.x;\n    rd = normalize(dir) * 9.;\n    rd = Rotate(BuildQuat(vec3(0,1,0),3.1415),rd);\n    \n    vec3 lro = vec3(0.,0.,-.1);\n    vec3 lrd = rd;\n    \n    ro = camPos ;\n    rd = Rotate(camQuat,rd);\n    \n    \n    vec3 mp=ro;\n    lmp=lro;\n    \n    int i;\n    for (i=0;i<maxStepRayMarching;i++){\n        dist = map(mp,lmp+dpos*0.005,time-(length(ro-mp)/speedOfLight));\n        //if(abs(rayDist)<mix(0.0001,0.1,(mp.z+camDist)*0.005))\n        if(dist<0.0001)\n            break;\n        mp+=rd*dist;\n        lmp+=lrd*dist;\n    }\n    \n    float ma=1.-float(i)/80.;\n    \n    return vec4(mp,ma);\n}\n\nvec4 GetSamplePos(vec2 uv)\n{\n    \n    rd = vec3(0.,0.,9.);\n    rd = Rotate(BuildQuat(vec3(1,0,0),-uv.y*FOV),rd);\n    rd = Rotate(BuildQuat(vec3(0,1,0),uv.x*FOV),rd);\n    \n    vec3 lro = vec3(0.,0.,-.1);\n    vec3 lrd = rd;\n    \n    ro = camPos;\n    rd = Rotate(camQuat,rd);\n    \n    \n    vec3 mp=ro;\n    lmp=lro;\n    \n    int i;\n    for (i=0;i<maxStepRayMarching;i++){\n        dist = map(mp,lmp+dpos*0.005,time-(length(ro-mp)/speedOfLight));\n        //if(abs(rayDist)<mix(0.0001,0.1,(mp.z+camDist)*0.005))\n        if(dist<0.0001)\n            break;\n        mp+=rd*dist;\n        lmp+=lrd*dist;\n    }\n    \n    float ma=1.-float(i)/80.;\n    \n    return vec4(mp,ma);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-iResolution.xy*0.5)/iResolution.yy;\n\n    camPos = Get(POS).xyz;\n    camQuat = Get(QUAT);\n    dpos = Rotate(camQuat,Get(D_POS).xyz);\n    time = Get(TIME).x;\n    \n    vec4 pos = GetSamplePos(uv);\n    float height = fog;\n    vec3 normal = GetNormal(pos.xyz,lmp+dpos*0.005,camQuat,time-(length(ro-pos.xyz)/speedOfLight)).xyz;\n    \n    \n    vec3 lightPOV = vec3(1.,1.,1.);\n    vec3 lightPOV2 = vec3(-1.,-1.,1.);\n    vec3 lightPOV3 = vec3(0.,0.,1.);\n    \n    vec3 camDir = normalize(ro-pos.xyz);\n    \n    pos.w *= pos.w * pos.w;\n    \n    //diffuse\n    vec3 finalCol = (1.2+dot(normal,lightPOV)) * vec3(0.,.6,1.);\n    finalCol +=  (1.2+dot(normal,lightPOV2)) * vec3(.5,.4,0.);\n    finalCol +=  (1.2+dot(normal,lightPOV3)) * vec3(.5,.0,0.);\n    finalCol *= 0.4;\n    \n    //roads\n    if (height < 0.0 && pos.w > 0.01)\n    \tfinalCol *= 0.5;\n    //specular\n    else\n    \tfinalCol += pow(max(0.,dot(normal,camDir)),10.)*1.;\n    \n    \n    vec3 fogCol = normalize(rd) + 1.8;\n    //vec3 fogCol = vec3(1.,0.8,0.7);\n    float rayLgth = length(pos.xyz-ro) * 0.005;\n    finalCol = mix(finalCol*pos.w,fogCol,rayLgth*0.5);\n    \n    \n    fragColor = vec4(min(vec3(1.),finalCol),1.0);\n    \n    fragColor.gb *= min(1.,Get(COLLISION).x*50.);\n    \n    \n    //displays Buffer\n    //fragColor += (texture(iChannel0,fragCoord/iResolution.xy).rgba );\n    \n    //displays normal\n    //fragColor = vec4(normal*0.5+0.5,1.);\n    \n    \n    \n}\n\nvoid mainVR( out vec4 fragColor, in vec2 fragCoord, in vec3 fragRayOri, in vec3 fragRayDir )\n{\n    \n    vec2 uv = (fragCoord-iResolution.xy*0.5)/iResolution.yy;\n\n    camPos = Get(POS).xyz;\n    camQuat = Get(QUAT);\n    dpos = Rotate(camQuat,Get(D_POS).xyz);\n    time = Get(TIME).x;\n    \n    vec4 pos = GetSamplePosVR(fragRayOri,fragRayDir);\n    float height = fog;\n    vec3 normal = GetNormal(pos.xyz,lmp+dpos*0.005,camQuat,time-(length(ro-pos.xyz)/speedOfLight)).xyz;\n    \n    \n    vec3 lightPOV = vec3(1.,1.,1.);\n    vec3 lightPOV2 = vec3(-1.,-1.,1.);\n    vec3 lightPOV3 = vec3(0.,0.,1.);\n    \n    vec3 camDir = normalize(ro-pos.xyz);\n    \n    pos.w *= pos.w * pos.w;\n    \n    //diffuse\n    vec3 finalCol = (1.2+dot(normal,lightPOV)) * vec3(0.,.6,1.);\n    finalCol +=  (1.2+dot(normal,lightPOV2)) * vec3(.5,.4,0.);\n    finalCol +=  (1.2+dot(normal,lightPOV3)) * vec3(.5,.0,0.);\n    finalCol *= 0.4;\n    \n    //roads\n    if (height < 0.0 && pos.w > 0.01)\n    \tfinalCol *= 0.5;\n    //specular\n    else\n    \tfinalCol += pow(max(0.,dot(normal,camDir)),10.)*1.;\n    \n    \n    vec3 fogCol = normalize(rd) + 1.8;\n    //vec3 fogCol = vec3(1.,0.8,0.7);\n    float rayLgth = length(pos.xyz-ro) * 0.005;\n    finalCol = mix(finalCol*pos.w,fogCol,rayLgth*0.5);\n    \n    \n    fragColor = vec4(min(vec3(1.),finalCol),1.0);\n    \n    fragColor.gb *= min(1.,Get(COLLISION).x*50.);\n    \n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\n\n\nvec4 Get(float var)\n{\n    return texture(iChannel0,vec2(varWdth*0.5 + var * varWdth,.5)/iResolution.xy).rgba;\n}\n\nbool Processing(float var, float pos)\n{\n    return (pos > var * varWdth) && (pos < (var+1.) * varWdth);\n}\n\n\nvoid mainVR( out vec4 fragColor, in vec2 fragCoord, in vec3 fragRayOri, in vec3 fragRayDir )\n{\n    mainImage(fragColor,fragCoord);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float uvx = fragCoord.x;\n    \n    if (fragCoord.y > 10. || fragCoord.x > varWdth*10.)\n    {\n        fragColor = vec4(0.);\n        return;\n    }\n    \n    vec3 dragfactors = maxSpeed;\n    \n    vec3 pos = Get(POS).xyz;\n    vec3 dpos = Get(D_POS).xyz;\n    vec4 quat = Get(QUAT);\n    vec4 dquat = Get(D_QUAT);\n    vec3 grav = Get(GRAVITY).xyz;\n    float time = Get(TIME).x;\n    vec2 res = Get(RES).xy;\n    float roll = Get(SMOOTHKEY).x;\n    float deltaT = min(0.1,iTimeDelta);\n    deltaT *= timeFactor;\n    time += deltaT;\n    \n    \n    vec3 acc = vec3(0.);\n    \n    vec2 e = vec2(0.002,0.);\n    \n    vec3 forward = Rotate(quat,vec3(0.,0.,1.));\n    vec3 up = Rotate(quat,vec3(0.,1.,0.));\n    vec3 right = Rotate(quat,vec3(1.,0.,0.));\n    \n    \n    vec3 velDir = normalize(dpos);\n    vec4 normDist = GetNormal(pos+forward*0.1,vec3(10000.),vec4(0.,0.,0.,1.),time);\n    vec3 norm = normDist.xyz;\n    float proxAlert = normDist.a;\n    //grav += normalize(norm-grav) * iTimeDelta;\n    \n    //collisions\n    float collisionViolence = dot(velDir,-norm);\n    \n\tif (proxAlert < 0.0 && collisions)\n    {\n        if (collisionViolence > 0.)\n        \tdpos = reflect(dpos,norm)/(collisionViolence*10.+1.);\n        dpos += norm*0.5;\n    }\n   \n    \n    //gravity\n    acc += gravity;// * abs(dot(norm,forward));\n        \n\t//inputs\n    vec2 joystick = (iMouse.xy-iResolution.xy*0.5)/iResolution.yy;\n    \n    roll = mix(roll,\n                     texture(iChannel1, vec2(KEY_S, 0.2)).x - texture(iChannel1, vec2(KEY_F, 0.2)).x,\n                     deltaT*5.);\n\n    \n    if (iMouse.x == 0. && iMouse.y == 0.)\n        joystick *= 0.;\n    \n    joystick *= max(1.,joystick.x);\n    joystick *= 8.0;\n    \n    float thurst = texture(iChannel1, vec2(KEY_E, 0.2)).x - texture(iChannel1, vec2(KEY_D, 0.2)).x;\n    \n    if (VRControls)\n    {\n        quat = MulQuat(BuildQuat(right, deltaT*thurst),quat);\n        quat = MulQuat(BuildQuat(forward, deltaT*roll*2.),quat);\n    }\n    else\n    {\n        quat = MulQuat(BuildQuat(right, deltaT*joystick.y),quat);\n        quat = MulQuat(BuildQuat(forward, -deltaT*joystick.x),quat);\n        quat = MulQuat(BuildQuat(up, -deltaT*roll*5.),quat);\n    }\n    \n    \n    //speed\n    float dragfactor = abs(dot(norm,forward));\n    \n    \n    if (VRControls)\n        thurst = 1.;\n    acc += thurst*forward*thrustForce;\n    \n    \n    //drag XYZ\n    float linSpeed = dot(right,dpos);\n    acc -= (abs(linSpeed)/dragfactors.x)*right*linSpeed;\n    \n    linSpeed = dot(up,dpos);\n    acc -= (abs(linSpeed)/dragfactors.y)*up*linSpeed;\n    \n    linSpeed = dot(forward,dpos);\n    acc -= (abs(linSpeed)/dragfactors.z)*forward*linSpeed;\n    \n    //add acceleration\n    dpos +=  deltaT*acc;\n    \n    //velDir = normalize(dpos);\n    \n    //nose fall / stall\n    quat = MulQuat(BuildQuat(cross(forward,velDir),length(velDir-forward)*deltaT),quat);\n    \n    //add derivatives\n    pos += deltaT*dpos;\n    \n    if (dieAndRetry && proxAlert < 0.0)\n    {\n        time = 0.0;\n        pos = vec3(0.,0.,10.);\n        dpos = vec3(0.,0.,0.1);\n        quat = BuildQuat(vec3(1.,0.,0.),1.57);\n    }\n    if (iFrame == 0)\n    {\n        pos = vec3(0.,0.,10.);\n        dpos = vec3(0.,0.,0.1);\n        quat = BuildQuat(vec3(1.,0.,0.),1.57);\n        grav = vec3(0.,1.,0.);\n    }\n    if (iResolution.xy != res)\n    {\n        //time = 0.0;\n        dpos = vec3(0.,0.,0.1);\n        quat = BuildQuat(vec3(1.,0.,0.),1.57);\n        grav = vec3(0.,1.,0.);\n    }\n    res = iResolution.xy;\n    \n    if (Processing(POS,uvx) )\n    \tfragColor = vec4(pos,1.);\n    if (Processing(D_POS,uvx) )\n    \tfragColor = vec4(dpos,1.);\n    if (Processing(QUAT,uvx) )\n    \tfragColor = vec4(quat);\n    if (Processing(D_QUAT,uvx) )\n    \tfragColor = vec4(dquat);\n    if (Processing(COLLISION,uvx) )\n    \tfragColor = vec4(proxAlert);\n    if (Processing(GRAVITY,uvx) )\n    \tfragColor = vec4(grav,1.);\n    if (Processing(DD_POS,uvx) )\n    \tfragColor = vec4(acc,1.);\n    if (Processing(TIME,uvx) )\n    \tfragColor = vec4(time);\n    if (Processing(RES,uvx) )\n    \tfragColor = vec4(res,0.,0.);\n    if (Processing(SMOOTHKEY,uvx) )\n    \tfragColor = vec4(roll);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"\n//decrease to get better performances, or increase to get more details\n#define maxStepRayMarching 50\n\n#define fractalSteps 12\n\n#define maxSpeed vec3(0.8,0.8,4.)\n#define thrustForce 3.5\n#define gravity vec3(0.,0.,-0.7)\n\n#define timeFactor 0.5\n#define FOV 1.4\n\n#define collisions true\n\n#define dieAndRetry false\n\n#define displayBird true\n\n#define speedOfLight 300.0\n\n#define VRControls false\n\n\n\n// Keys\nconst float KEY_E = 69.5/255.;\nconst float KEY_D = 68.5/255.;\nconst float KEY_F = 70.5/255.;\nconst float KEY_S = 83.5/255.;\n\nfloat varWdth = 5.;\n\nfloat POS = 0.;\nfloat D_POS = 1.;\nfloat QUAT = 2.;\nfloat D_QUAT = 3.;\nfloat COLLISION = 4.;\nfloat GRAVITY = 5.;\nfloat DD_POS = 6.;\nfloat TIME = 7.;\nfloat RES = 8.;\nfloat SMOOTHKEY = 9.;\n\nmat2 rz2(float a){float c=cos(a),s=sin(a);return mat2(c,s,-s,c);}\n\nfloat dist = 1000.0;\nvec3 rayColor = vec3(0.0,0.0,0.0);\nvec3 ro;\n\nfloat fog = 0.;\n\n\n//Life saving Quaternion function by ciberxtrem !\nvec4 NormQuat(vec4 q)\n{\n    float lenSQ = dot(q, q);\n    float invLenSQ = 1./lenSQ;\n    return q*invLenSQ;\n}\n\nvec4 BuildQuat(vec3 axis, float angle)\n{\n    angle *= 0.5;\n    float s = sin(angle);\n    return NormQuat(vec4(axis*s, cos(angle)));\n}\n\nvec4 MulQuat(vec4 q1, vec4 q2)\n{\n    vec4 res = vec4(0.);\n    res.w   = q1.w*q2.w - dot(q1.xyz, q2.xyz);\n    res.xyz = q1.w*q2.xyz + q2.w*q1.xyz + cross(q1.xyz, q2.xyz);\n    return NormQuat(res);\n}\n\nvec3 Rotate(vec4 q, vec3 v)\n{\n    vec3 t = 2.*cross(q.xyz, v);\n    return v + q.w*t + cross(q.xyz, t);\n}\n\n//Basic Ray marching primitives\nfloat sphere(vec3 ray,vec3 pos, float radius)\n{\n    return length(ray-pos) - radius;\n}\n\nfloat cylinder(vec3 ray,vec3 pos, float radius, float height)\n{\n    return max(length(ray.xy-pos.xy) - radius, abs(ray.z-pos.z)-height);\n}\n\nfloat cube(vec3 ray, vec3 pos, float size)\n{\n    ray = abs(ray-pos) - size;\n    return max(max(ray.x,ray.y),ray.z);\n}\n\nfloat line(vec3 ray, vec3 pos, float size)\n{\n    ray = abs(ray-pos) - size;\n    return max(ray.z,ray.y);\n}\n\nfloat box(vec3 ray, vec3 pos, vec3 size)\n{\n    ray = abs(ray-pos) - size;\n    return max(max(ray.x,ray.y),ray.z);\n}\n\n//not used\nvec3 Spherize(vec3 pos)\n{\n    vec3 result = vec3(0.,0.,0.);\n    result.x = atan(normalize(pos.xy)).y * 10.0;\n    result.y = atan(normalize(pos.zx)).y * 10.0;\n    result.z = (2.*length(pos))-15.;\n    result.xy += 10.;\n    return result;\n}\n\n//kaleidoscope\nvec3 FractalSpace(vec3 pos, float time)\n{\n    pos *= 0.1;\n    \n    float height = length(pos) * 10.0;\n    float s=3.;\n\tfor(int i=0;i<fractalSteps;i++){\n\t\tpos.xy=abs(pos).xy-s; \n        pos.xy *= rz2(1.4-0.01*time);\n        pos.xz *= rz2(time*0.018); \n        pos.yz *= rz2(time*0.005);\n\t\ts=s/1.3;\n\t}\n    \n    return pos;\n}\n\n//build a block of buildings ~8\nfloat map(vec3 pos, vec3 lPos, float time)\n{\n    float rayDist = 0.;\n    \n    //pos = Spherize(pos);\n    \n    pos = FractalSpace(pos,time);\n    pos.xy += .05;\n    \n    vec3 pos1 = pos;\n    pos1.x = abs(pos.x);\n    vec3 pos2 = pos;\n    \n    pos.xyz = abs(pos.xyz);\n    pos.z -= .01;\n    \n    \n    //ground\n    rayDist = box(pos,vec3(0.0,0.0,-0.1),vec3(2.,10.0,0.1));\n    //roads\n    rayDist = max(rayDist,-box(pos,vec3(0.0,0.0,0.0),vec3(0.02,10.0,0.002)));\n    rayDist = max(rayDist,-box(pos,vec3(0.0,0.0,0.0),vec3(10.,0.02,0.002)));\n    \n    rayDist = max(rayDist,-box(pos,vec3(0.15,0.0,0.0),vec3(0.01,10.0,0.002)));\n    rayDist = max(rayDist,-box(pos,vec3(0.0,0.15,0.0),vec3(10.,0.01,0.002)));\n    //big building\n    vec3 b2 = pos;\n    b2.xy -= 0.22;\n    //b2.xy -= vec2(0.22,-0.08);\n    b2 = abs(b2);\n    rayDist = min(rayDist,box(b2,vec3(0.,0.,0.0),vec3(0.05,0.05,0.1)));\n    rayDist = min(rayDist,box(b2,vec3(0.,0.,0.05),vec3(0.04,0.04,0.1)));\n    //rayDist = min(rayDist,box(b0,vec3(0.,0.,0.006),vec3(0.048,0.048,0.005)));\n    \n    //Paris building\n    vec3 b1 = pos;\n    b1.xy -= vec2(0.22,0.08);\n    b1 = abs(b1);\n    float XYsize =  max(0.,.5*pos.z-0.02);\n    float Zsize =  max(0.,0.4*max(b1.x,b1.y)-0.01);\n    rayDist = min(rayDist,box(b1,vec3(0.,0.,0.0),vec3(0.05-XYsize,0.05-XYsize,0.06-Zsize)));\n    rayDist = max(rayDist,-box(b1,vec3(0.0,0.0,0.05),vec3(0.02+XYsize,0.02+XYsize,0.05)));\n    \n    rayDist = min(rayDist,box(b1,vec3(0.02,0.04,0.046),vec3(0.005,0.009,0.008)));\n    rayDist = min(rayDist,box(b1,vec3(0.04,0.01,0.05),vec3(0.005,0.001,0.008)));\n    \n    b1.xy *= 0.56;\n    b1 = abs(b1-0.02);\n    rayDist = max(rayDist,-box(b1,vec3(0.01,0.01,0.01),vec3(0.003,0.003,0.008)));\n    \n    //Garden walls\n    vec3 b0 = pos1;\n    b0.xy -= 0.08;\n    rayDist = min(rayDist,box(b0,vec3(0.,0.,0.005),vec3(0.05,0.05,0.005)));\n    rayDist = max(rayDist,-box(b0,vec3(0.,0.,0.006),vec3(0.048,0.048,0.005)));\n    \n    //Garden trees\n    float noise = 1.+0.1*length(sin(pos*2000.0))+0.2*length(sin(pos*900.0)); \n    \n    b0.xy = abs(b0.xy);\n    b0.xy -= 0.02;\n    b0.xy = abs(b0.xy);\n    b0 -= vec3(0.01,0.01,0.02);\n    rayDist = min(rayDist,cylinder(b0,vec3(0.,0.,-0.01),0.001,0.006));\n    b0*=noise;\n    rayDist = min(rayDist,sphere(b0,vec3(0.),0.008));\n\n    \n    //parking\n    vec3 b3 = pos2;\n    b3.xy -= vec2(0.08,0.-0.08);\n    b3 = abs(b3);\n    rayDist = min(rayDist,box(b3,vec3(0.,0.,0.033),vec3(0.05,0.05,0.033)));\n    rayDist = max(rayDist,-box(b3,vec3(0.,0.0,0.064),vec3(0.049,0.049,0.006)));\n    rayDist = min(rayDist,box(b3,vec3(0.,0.,0.02),vec3(0.051,0.051,0.002)));\n    rayDist = min(rayDist,box(b3,vec3(0.,0.,0.04),vec3(0.051,0.051,0.002)));\n    rayDist = max(rayDist,-box(b3,vec3(0.022,0.,0.033),vec3(0.01,0.051,0.003)));\n    rayDist = max(rayDist,-box(b3,vec3(0.,0.022,0.033),vec3(0.051,0.01,0.003)));\n    rayDist = max(rayDist,-box(b3,vec3(0.022,0.,0.053),vec3(0.01,0.051,0.003)));\n    rayDist = max(rayDist,-box(b3,vec3(0.,0.022,0.053),vec3(0.051,0.01,0.003)));\n    \n    //square\n    vec3 b4 = pos2;\n    b4.xy -= vec2(0.08,0.-0.22);\n    b4 = abs(b4);\n    rayDist = min(rayDist,box(b4,vec3(0.,0.,0.003),vec3(0.05,0.05,0.003)));\n    rayDist = max(rayDist,-box(b4,vec3(0.,0.,0.004),vec3(0.049,0.049,0.004)));\n    rayDist = max(rayDist,-box(b4,vec3(0.,0.,0.004),vec3(0.051,0.01,0.004)));\n    rayDist = max(rayDist,-box(b4,vec3(0.,0.,0.004),vec3(0.01,0.051,0.004)));\n    \n    vec3 cone = b4;\n    vec3 stairs = b4;\n    \n    rayDist = min(rayDist,cylinder(b4,vec3(0.,0.,0.015),0.015,0.006));\n    \n    cone.xy += (cone.z-0.021);\n    rayDist = min(rayDist,cylinder(cone,vec3(0.,0.,0.027),0.015,0.006));\n    \n    stairs.xy += floor(stairs.z * 800.0)/800.0;\n    rayDist = min(rayDist,box(stairs,vec3(0.018,0.018,0.0),vec3(0.01,0.01,0.01)));\n    rayDist = min(rayDist,box(stairs,vec3(0.00,0.0,0.01),vec3(0.01,0.01,0.02)));\n    \n    \n    //Business building\n    vec3 b5 = pos2;\n    b5.xy -= vec2(-0.08,0.-0.22);\n    b5.xy *= 1.+2.0*floor(b5.z * 50.0)/50.0;\n    b5.xy *= rz2(b5.z);\n    rayDist = min(rayDist,box(b5,vec3(0.,0.,0.15),vec3(0.05,0.05,0.15)));\n    \n    \n    //Bird\n    if (displayBird && length(lPos) < 2.)\n    {\n        lPos *= 0.1;\n        lPos.x *= 2.0;\n        float rep = 0.002;\n        lPos.x = rep-abs(abs(lPos.x)-rep);\n        \n        float flap = sin(time*40.0+lPos.x*600.0);\n\n        float feathers = -lPos.y*4000.;\n        lPos.z += abs(mod((feathers),1.)-0.5)*0.2*lPos.z;\n        feathers = -lPos.x*2000.;\n        lPos.z += abs(mod((feathers),1.)-0.5)*0.2*lPos.z;\n\n        //lPos.x = abs(lPos.x);\n        lPos.x *= pow(abs(lPos.x*500.),2.);\n        lPos.xz *= rz2(-.5);\n        lPos.y += flap*0.0004;\n        //lPos.yz *= rz2(sin(time*0.5)*0.1);\n        //lPos.xy *= 1.+abs(lPos.z*1.);\n        //lPos.z *= pow(abs(lPos.z),0.2);\n        lPos.z -= 0.001;\n        lPos.yz += 0.003;\n        rep = -0.0001;\n        //lPos.z += mod((-pos.y*50.),1.)*0.0005;\n        lPos.y = rep-abs(abs(lPos.y)-rep);\n\n        //lPos.z = mod(lPos.z*10000.,1.)/10000.;\n        //\n        //0.5-smoothstep(0.,0.002,abs(lPos.z*0.1))\n        float size = 0.0005;// * (length(sin(pos*20.0))+0.2*length(sin(pos*50.0)));\n        rayDist = min(rayDist,sphere(lPos,vec3(0.002,0,lPos.z),size*((1.-pow(abs(lPos.z*200.),2.)))));\n    }\n    \n    fog = pos.z;\n    \n    return rayDist;\n}\n\n\nvec4 GetNormal(vec3 pos, vec3 lpos, vec4 shipQuat, float time)\n{\n    vec2 e = vec2(0.003,0.) * length(pos-ro);\n    float o = map(pos,lpos,time);\n    return vec4(normalize(vec3(\tmap(pos+e.xyy,lpos+Rotate(shipQuat,e.xyy),time) - o,\n                          \t\tmap(pos+e.yxy,lpos+Rotate(shipQuat,e.yxy),time) - o,\n                          \t\tmap(pos+e.yyx,lpos+Rotate(shipQuat,e.yyx),time) - o)),o);\n}","name":"Common","description":"","type":"common"}]}