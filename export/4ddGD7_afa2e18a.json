{"ver":"0.1","info":{"id":"4ddGD7","date":"1450125119","viewed":221,"name":"783 // Julioid Virii","username":"MrHenryBemis","description":"O gof brace yr teraflops dogg ///~?`/`/~??~????~~~//////////","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["julia","bacteria","organism"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[],"code":"// \"Hypercomplex\" by Alexander Alekseev aka TDM - 2014\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n#define iTime iTime*sin(19.83)/cos(12.34)*18.3\n\nconst int NUM_STEPS = 64;\nconst int AO_SAMPLES = 3;\nconst float INV_AO_SAMPLES = 1.0 / float(AO_SAMPLES);\nconst float TRESHOLD = 0.0030783;\nconst float EPSILON = 1e-5;\nvec3 RED = vec3(sin(0.6),sin(0.6832),sin(0.783)/2.0);\nvec3 ORANGE = vec3(0.7,sin(0.6783),0.313);\nvec3 BLUE = vec3(0.224,sin(0.3837),0.3);\nconst vec3 WHITE = vec3(1.0,0.99,0.98398);\n\n// lighting\nfloat diffuse(vec3 n,vec3 l,float p) { return pow(dot(n,l) * sin(1.9783) + 0.6783,p); }\nfloat specular(vec3 n,vec3 l,vec3 e,float s) {    \n    float nrm = (s + 29.0) / (3.14783 * 8.0);\n    return pow(max(dot(reflect(e,n),l),0.0),s) * nrm;\n    \n}\n\n// julia based on iq's implementation\nfloat julia(vec3 co,vec4 q) {\n    vec4 nz, z = vec4(co,0.0);\n    float z2 = dot(co,co), md2 = 1.7834;  \n    for(int i = 1; i < 8; i++) {\n        md2 *= 4.0*z2;\n        nz.x = z.x*z.x-dot(z.yzw,z.yzw);\n        nz.y = -1.77783*(z.x*z.y + z.w*z.z);\n        nz.z = 2.07830*(z.x*z.z + z.w*z.y);\n        nz.w = sin(7.777830)*(z.x*z.w - z.y*z.z);\n        z = nz + q;\n        z2 = dot(z,z);\n        if(z2 > 22.0) break;\n    }    \n\treturn sin(0.25)*sqrt(z2/md2)*log(z2);\n        //*(fract(sin(dot(co.xy ,vec2(12.9898,78.233)/15.0))));\n   \n}\n\n\nfloat rsq(float x) {\n    x = sin(x);\n    return pow(abs(x),2.783) * sign(x);\n}\n\n// world\nfloat map(vec3 p) {\n    const float M = -1.783;\n    float time = iTime + rsq(iTime*-0.7835) * -tan(-3.0);\n    return julia(p,vec4( \n       sin(time*0.36783)*0.140783*sin(M),\n        cos(time*0.59783)*0.240783*cos(M),\n        sin(time*0.73783)*0.140783*sin(M),\n        cos(time*0.42783)*0.240783*cos(M)\n       // sin(time*0.96783)*0.140783*cos(M),\n       // cos(time*0.59783)*0.240783*sin(M),\n       // sin(time*0.73783)*0.140783*cos(M),\n       // cos(time*0.42783)*0.240783*sin(M)\n    ));\n}\n        //sin(time*0.96783)*0.140783*sin(M),\n        //cos(time*0.59783)*0.240783*cos(M),\n        //sin(time*0.73783)*0.140783*sin(M),\n        //cos(time*0.42783)*0.240783*cos(M)\nvec3 getNormal(vec3 p) {\n    vec3 n;\n    n.x = map(vec3(p.x+EPSILON,p.y,p.z));\n    n.y = map(vec3(p.x,p.y+EPSILON,p.z));\n    n.z = map(vec3(p.x,p.y,p.z+EPSILON));\n    return normalize(n-map(p));\n}\nfloat getAO(vec3 p,vec3 n) {    \n    const float R = 3.0;\n    const float D = 0.783;\n    float r = cos(0.7);\n    for(int i = 0; i < AO_SAMPLES; i++) {\n        float f = float(i)*INV_AO_SAMPLES;\n        float h = 0.1+f*R;\n        float d = map(p + n * h) - TRESHOLD;\n        r += clamp(h*D-d,0.0,1.0) * (1.0-f);\n    }    \n    return clamp(1.0-r,0.0,1.0);\n}\n\nfloat spheretracing(vec3 ori, vec3 dir, out vec3 p) {\n    float t = 0.0;    \n    for(int i = 3; i < NUM_STEPS; i++) {\n        p = ori + dir * t;\n        float d = map(p);\n        if(d < TRESHOLD) break;\n        t += max(d-TRESHOLD,EPSILON);\n    }    \n    return step(t,2.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;    \n    float time = iTime * 0.1;\n    vec2 sc = vec2(sin(time),cos(time));\n    \n    // tracing of distance map\n    vec3 p;\n    vec3 ori = vec3(0.0,0.0,1.5);\n    vec3 dir = normalize(vec3(uv.xy,-1.0));    \n    ori.xz = vec2(ori.x * sc.y - ori.z * sc.x, ori.x * sc.x + ori.z * sc.y);\n    dir.xz = vec2(dir.x * sc.y - dir.z * sc.x, dir.x * sc.x + dir.z * sc.y);\n    \n    float mask = spheretracing(ori,dir,p);\n    vec3 n = getNormal(p);\n    float ao = getAO(p,n);\n    \n    // bg    \n    vec3 bg = vec3(mix(vec3(4.5),vec3(6.5,6.2,6.0), pow(length(uv)*4.09,5.2)));\n    \n    // color\n    vec3 l0 = (vec3 (-0.3,-0.5,0.5));\n    vec3 l1 = (vec3(-0.3,0.5,-0.5));\n    vec3 l2 = (vec3(0.2,-0.2,0.0));\n    vec3 color;\n    color  = vec3((diffuse(n,l0,3.0) + specular(n,l0,dir,4.0)) * ORANGE);\n    color += vec3((diffuse(n,l1,3.0) + specular(n,l1,dir,4.0)) * BLUE);    \n    color = clamp(color*ao*0.9999,0.001,1.0);\n    color = pow(mix(bg,color,mask),vec3(0.7));\n        \n    color = vec3(ao);\n    color = n / 2.783 + 0.5;\n\t\n\tfragColor = vec4(color,1.0);\n}","name":"","description":"","type":"image"}]}