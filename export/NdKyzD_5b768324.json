{"ver":"0.1","info":{"id":"NdKyzD","date":"1654541429","viewed":194,"name":"Hommage à Jochen Lempert","username":"DrNoob","description":"Inspired by the photographs of Jochen Lempert:\nhttps://en.wikipedia.org/wiki/Jochen_Lempert","likes":17,"published":1,"flags":0,"usePreview":0,"tags":["3dnoise","2dnoise","photography","reproduction"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Author: Thomas Stehle\n// Title: Hommage à Jochen Lempert\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n//\n// Inspired by the photographs of Jochen Lempert:\n// https://en.wikipedia.org/wiki/Jochen_Lempert\n\n#ifndef NUM_OCTAVES\n#define NUM_OCTAVES 5\n#endif\n\nfloat sdf_circle(in vec2 p, in vec2 c, in float r) {\n    return length(p - c) - r;\n}\n\nfloat sdf_oriented_box(in vec2 p, in vec2 a, in vec2 b, float th) {\n    float l = length(b-a);\n    vec2  d = (b-a)/l;\n    vec2  q = p-(a+b)*0.5;\n          q = mat2(d.x,-d.y,d.y,d.x)*q;\n          q = abs(q)-vec2(l,th)*0.5;\n    return length(max(q,0.0)) + min(max(q.x,q.y),0.0);\n}\n\nfloat hash(in vec2 p) {\n    vec3 p3 = fract(vec3(p.xyx) * 0.13);\n    p3 += dot(p3, p3.yzx + 3.333);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat hash(in vec3 p) {\n    vec3 q = fract(p * 0.1031);\n    q += dot(q, q.yzx + 33.33);\n    return fract((q.x + q.y) * q.z);\n}\n\nvec2 hash2(in vec2 p) {\n    const vec2 k = vec2(0.3183099, 0.3678794);\n    p = p*k + k.yx;\n    return fract(16.0 * k*fract(p.x * p.y * (p.x + p.y)));\n}\n\nvec3 hash3(in vec3 p) {\n    const vec3 MOD3 = vec3(0.1031, 0.11369, 0.13787);\n    p = fract(p * MOD3);\n    p += dot(p, p.yxz + 19.19);\n    return -1.0 + 2.0 * fract(vec3((p.x + p.y)*p.z, (p.x + p.z)*p.y, (p.y + p.z)*p.x));\n}\n\nfloat gnoise(in vec3 p) {\n    vec3 i = floor(p);\n    vec3 f = fract(p);\n    vec3 u = f*f*(3.0-2.0*f);\n    return mix( mix( mix( dot( hash3(i + vec3(0, 0, 0)), f - vec3(0, 0, 0) ),\n                          dot( hash3(i + vec3(1, 0, 0)), f - vec3(1, 0, 0) ), u.x),\n                     mix( dot( hash3(i + vec3(0, 1, 0)), f - vec3(0, 1, 0) ),\n                          dot( hash3(i + vec3(1, 1, 0)), f - vec3(1, 1, 0) ), u.x), u.y),\n                mix( mix( dot( hash3(i + vec3(0, 0, 1)), f - vec3(0, 0, 1) ),\n                          dot( hash3(i + vec3(1, 0, 1)), f - vec3(1, 0, 1) ), u.x),\n                     mix( dot( hash3(i + vec3(0, 1, 1)), f - vec3(0, 1, 1) ),\n                          dot( hash3(i + vec3(1, 1, 1)), f - vec3(1, 1, 1) ), u.x), u.y), u.z );\n}\n\nfloat snoise(in vec2 p) {\n    const float K1 = 0.366025404; // (sqrt(3)-1)/2\n    const float K2 = 0.211324865; // (3-sqrt(3))/6\n    vec2  i = floor(p + (p.x + p.y)*K1);\n    vec2  a = p - i + (i.x + i.y)*K2;\n    float m = step(a.y, a.x); \n    vec2  o = vec2(m, 1.0 - m);\n    vec2  b = a - o + K2;\n    vec2  c = a - 1.0 + 2.0*K2;\n    vec3  h = max(0.5 - vec3(dot(a,a), dot(b,b), dot(c,c)), 0.0);\n    vec3  n = h*h*h*h * vec3(\n        dot(a, -1.0 + 2.0 * hash2(i + 0.0)),\n        dot(b, -1.0 + 2.0 * hash2(i + o)),\n        dot(c, -1.0 + 2.0 * hash2(i + 1.0)) );\n    return 0.5 + 0.5 * dot(n, vec3(70.0));\n}\n\nfloat snoise(in vec3 p) {\n    vec3 i = floor(p);\n    vec3 f = fract(p);\n    f = f*f*(3.0-2.0*f);\n    return mix(mix(mix( hash(i + vec3(0, 0, 0)),\n                        hash(i + vec3(1, 0, 0)), f.x),\n                   mix( hash(i + vec3(0, 1, 0)),\n                        hash(i + vec3(1, 1, 0)), f.x), f.y),\n               mix(mix( hash(i + vec3(0, 0, 1)),\n                        hash(i + vec3(1, 0, 1)), f.x),\n                   mix( hash(i + vec3(0, 1, 1)),\n                        hash(i + vec3(1, 1, 1)), f.x), f.y), f.z);\n}\n\nfloat vnoise(in vec2 p) {\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n\n    // Four corners in 2D of a tile\n    float a = hash(i);\n    float b = hash(i + vec2(1.0, 0.0));\n    float c = hash(i + vec2(0.0, 1.0));\n    float d = hash(i + vec2(1.0, 1.0));\n\n    // Smooth interpolation (smoothstep without clamping)\n    vec2 u = f*f * (3.0 - 2.0*f);\n\n    // Mix 4 corners\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\nfloat sfbm(in vec3 p) {\n    float v = 0.0;\n    float a = 0.5;\n    for (int i = 0; i < NUM_OCTAVES; ++i) {\n        v += a * snoise(p);\n        a *= 0.5;\n    }\n    return v;\n}\n\nfloat vfbm(in vec2 p) {\n    float v = 0.0;\n    float a = 0.5;\n    vec2 shift = vec2(100.0);\n    for (int i = 0; i < NUM_OCTAVES; ++i) {\n        v += a * vnoise(p);\n        p = p * 2.0 + shift;\n        a *= 0.5;\n    }\n    return v;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Coordinate normalization\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    float ar = iResolution.x / iResolution.y;\n    uv.x *= ar;\n\n    // Time\n    float time = 0.2 * iTime;\n\n    // Background\n    vec3 col = vec3(0.5 + 0.5 * gnoise(vec3(uv, time)));\n\n    // Clouds\n    mat2 rot = mat2(1.6, -1.0, 1.0, 1.6);\n    vec2 q = rot * uv;\n    q.x *= 0.5;\n    q.y *= 5.0;\n    float clouds = 0.5 * sfbm(vec3(q, time));\n    col += vec3(clouds);\n\n    // Flying thing\n    vec2 c = vec2(ar * 0.6, 0.5) + vec2(0.1 * sin(time), 0.01 * cos(time));\n\n    float body = sdf_circle(vec2(uv.x, 0.5 * uv.y), vec2(c.x, 0.5 * c.y), 0.001);\n    body = smoothstep(0.002, 0.0001, body);\n    col = mix(col, vec3(0.2), body);\n\n    c.y += 0.025 + 0.01 * sin(time);\n    float head = sdf_circle(vec2(0.35 * uv.x, uv.y), vec2(0.35 * c.x, c.y), 0.002);\n    head = smoothstep(0.004, 0.0001, head);\n    col = mix(col, vec3(0.2), head);\n\n    // Foreground\n    float width = 0.25 + 0.05 * sin(time);\n    float fgd = sdf_oriented_box(vec2(uv.x, uv.y + 0.2 * vfbm(10.0 * uv)), vec2(-1.0, 0.0), vec2(2.0, 0.0), width);\n    fgd = smoothstep(0.15, 0.1, fgd);\n    col = mix(col, vec3(0.05), fgd);\n\n    // Lens flare/overexposure in bottom right\n    float flare = sdf_circle(uv, vec2(1.5 * ar, 0.2), 1.0);\n    flare = sfbm(vec3(7.5 * uv, time)) * smoothstep(0.3, 0.0, flare);\n    col = mix(col, vec3(1.75), flare);\n\n    // Film grain\n    float r = hash(vec3(gl_FragCoord.xy, fract(0.0005 * iTime)));\n    col += 0.15 * vec3(r - 0.5);\n\n    // Vignetting\n    vec2 st = uv * (vec2(1.0, ar) - uv.yx);\n    float vig = st.x * st.y * 10.0;\n    col *= pow(vig, 0.2);\n\n    // Final color\n    fragColor = vec4(col, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}