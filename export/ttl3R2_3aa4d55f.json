{"ver":"0.1","info":{"id":"ttl3R2","date":"1557000160","viewed":1760,"name":"Scattered Honey","username":"fizzer","description":"Some kind of glass, using accumulation for anti-aliasing. I'm not actually 100% sure if the glass material is really correct, but I kept playing with it anyway until I got a result I'm happy with. By the way, this uses a tent filter for anti-aliasing.","likes":68,"published":1,"flags":32,"usePreview":0,"tags":["raymarching","transparency","glass"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = fragCoord / iResolution.xy * 2. - 1.;\n    p.x *= iResolution.x / iResolution.y;\n\n    fragColor = vec4(0);\n\n    float wsum = 0.;\n\n    const int maxRadius = 16;\n\n    int rsq = clamp(int(pow(abs(p.x / 2. + p.y), 1.5) * iResolution.x / 300.), 0, maxRadius);\n\n    if(rsq > 0)\n    {\n        rsq *= rsq;\n\n        vec2 sz = vec2(textureSize(iChannel0, 0).xy);\n\n        // Depth of field posteffect\n        \n        for(int y = -maxRadius; y <= +maxRadius; ++y)\n            for(int x = -maxRadius; x <= +maxRadius; ++x)\n            {\n                if(x * x + y * y < rsq)\n                {\n                    float w = mix(.5, 1., smoothstep(0., 1., length(vec2(x, y)) / float(rsq)));\n                    vec4 samp = texelFetch(iChannel0, ivec2(clamp(fragCoord.xy + vec2(x, y), vec2(.5), sz - .5)), 0);\n                    samp /= samp.w;\n                    fragColor += samp * w;\n                    wsum += w;\n                }\n            }\n\n        fragColor /= wsum;\n    }\n    else\n    {\n        fragColor = texelFetch(iChannel0, ivec2(fragCoord.xy), 0);\n        fragColor /= fragColor.w;\n    }\n\n    // Tonemap and \"colourgrade\"\n\n    fragColor /= (fragColor + .4) / 2.;\n    fragColor.rgb = pow(fragColor.rgb, mix(vec3(1), vec3(1,1.4,1.8), .5));\n\n    // Gamma correction\n\n    fragColor.rgb = pow(clamp(fragColor.rgb, 0., 1.), vec3(1. / 2.2)) +\n        texelFetch(iChannel1, ivec2(fragCoord) & 1023, 0).rgb / 100.;\n    \n    fragColor.a = 1.;\n}\n\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4sfGzn","filepath":"/media/a/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png","previewfilepath":"/media/ap/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"XdX3Rr","filepath":"/media/a/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin","previewfilepath":"/media/ap/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin","type":"volume","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"const float pi = acos(-1.);\n\n// Signed distance field\nfloat map(vec3 p)\n{\n    float d = 0.;\n    \n    p.x += 11.5;\n\n    p += (smoothSample(iChannel2, p * 2., 0).rgb - .5) * .001;\n    p += (smoothSample(iChannel2, p / 18. - 10. / 205. * vec3(0, 0, 1), 0).rgb - .5) * 1.5;\n    d += length(p.yz) - .6;\n\n    d = max(d - .2, -(length(mod(p, .2) - .1) - .015));\n    \n    d = min(d, length(abs(p.yz) - 1.5) - .05);\n    d = min(d, length(p.yz - 1.2) - .05);\n    \n    return d;\n}\n\nvec3 mapNormal(vec3 p)\n{\n    vec3 e = vec3(1e-3, 0., 0.);\n    return normalize(vec3(map(p + e.xyy) - map(p - e.xyy),\n                          map(p + e.yxy) - map(p - e.yxy),\n                          map(p + e.yyx) - map(p - e.yyx)));\n}\n\nvec4 render(vec2 fragCoord)\n{    \n    // Set up primary ray\n\n    vec2 p = fragCoord / iResolution.xy * 2. - 1.;\n    p.x *= iResolution.x / iResolution.y;\n\n    vec3 ro = vec3(0, 0, 3.5);\n    vec3 rd = normalize(vec3(p, -2.8));\n\n    // Camera rotation\n    \n    mat3 m = rotY(.6) * rotZ(-.3);\n\n    rd = m * rd;\n\n    vec4 fragColor = vec4(0);\n\n    // When flip is positive, the march is outside of the glass.\n    // When it's negative, the march is inside of the glass.\n    float flip = +1.;\n    \n    vec3 transfer = vec3(1);\n\n    vec3 rp = ro + rd * 2., prevhitrp = rp;\n\n    for(int i = 0; i < 400; ++i)\n    {\n        float d = map(rp) * flip;\n\n        // Test for surface hit\n        if(abs(d) < 1e-4)\n        {\n            // Get the surface normal here\n            vec3 n = mapNormal(rp), on = n;\n            \n            // Put the normal and ray direction on the same side of the plane\n            n *= -sign(dot(rd, n));\n            \n            // Fresnel term\n            float fr = mix(.01, .4, pow(clamp(1. - dot(-rd, n), 0., 1.), 5.));\n            \n            // Refract ray direction, or reflect if there is no solution (as per Snell's law).\n            // This accounts for total internal reflection.\n            float ior = 1.25;\n            vec3 refr = normalize(refract(normalize(rd), normalize(n), flip < 0. ? ior : 1. / ior));\n            rd = dot(refr, refr) > 0. ? refr : reflect(rd, n);\n\n            float dist = distance(rp, prevhitrp);\n\n            // If the ray is just leaving a solid volume then aborb some energy\n            // according to Beer's law.\n            if(flip < 0.)\n                transfer *= exp(-abs(dist) * vec3(.3, .5, .7) * 2.2);\n\n            // Just directly add a reflection here, to avoid the need for a branch path.\n            // This isn't correct, but a reflection is needed somehow to get any kind of\n            // convincing material appearance.\n            fragColor.rgb += textureLod(iChannel1, reflect(rd, n), 2.).rgb * transfer * fr;\n            \n\n            prevhitrp = rp;\n\n            flip = -flip;\n            d = 2e-4;\n            \n            // Push the ray position through the surface along the normal.\n            // This is more robust than pushing it along the ray's direction.\n            rp += -n * 1e-3;\n            \n            transfer *= (1. - fr);\n        }\n\n        rp += rd * d * .3;\n\n        // Test for far plane escape\n        if(distance(rp, ro) > 15.)\n            break;\n    }\n\n    vec3 refc = vec3(0);\n\n    float wsum = 0.;\n    \n    // Filtered environment map lookup\n    for(int z = -2; z < 2; ++z)\n        for(int y = -2; y < 2; ++y)\n            for(int x = -2; x < 2; ++x)\n            {\n                float w = 1. - float(max(abs(x), max(abs(y), abs(z)))) / 3.;\n                refc.rgb += textureLod(iChannel1, rd + vec3(x, y, z) * .1, 3.).rgb * w;\n                wsum += w;\n            }\n    \n    fragColor.rgb += refc * transfer / wsum;\n\n    // Vignet\n    fragColor.rgb *= 1. - (pow(abs(p.x)/2.2,4.) + pow(abs(p.y)/1.4,4.)) * .7;\n\n    fragColor.a = 1.;\n\n    return fragColor;\n}\n\n// Halton sequence (radical inverse)\nfloat halton(const uint b, uint j)\n{\n   float h = 0.0, f = 1.0 / float(b), fct = f;\n\n   while(j > 0U)\n   {\n      h += float(j % b) * fct;\n      j /= b;\n      fct *= f;\n   }\n\n   return h;\n}\n\n// Sample unit disc\nvec2 disc(vec2 uv)\n{\n   float a = uv.x * pi * 2.;\n   float r = sqrt(uv.y);\n   return vec2(cos(a), sin(a)) * r;\n}\n\n// Sample cone PDF (for tent filtering)\nvec2 cone(vec2 v)\n{\n\treturn disc(vec2(v.x, 1. - sqrt(1. - v.y)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0);\n\n    vec4 oldColor = texelFetch(iChannel3, ivec2(fragCoord), 0);\n\n    if(iMouse.z > .5)\n        oldColor = vec4(0);\n\n    vec2 uv = vec2(halton(2U, uint(oldColor.w) & 2047U), halton(3U, uint(oldColor.w) & 2047U));\n    \n    vec2 aaOffset = cone(uv) * 1.2;\n        \n\tfragColor = oldColor + vec4(clamp(render(fragCoord + aaOffset).rgb, 0., 1.), 1.);\n}\n\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"\nmat3 rotX(float a)\n{\n    return mat3(1., 0., 0.,\n                0., cos(a), sin(a),\n                0., -sin(a), cos(a));\n}\n\nmat3 rotY(float a)\n{\n    return mat3(cos(a), 0., sin(a),\n                0., 1., 0.,\n                -sin(a), 0., cos(a));\n}\n\nmat3 rotZ(float a)\n{\n    return mat3(cos(a), sin(a), 0.,\n                -sin(a), cos(a), 0.,\n                0., 0., 1.);\n}\n\n// Smooth 3D texture interpolation\nvec4 smoothSample(sampler3D tex, vec3 p, int level)\n{\n    vec3 sz = vec3(textureSize(tex, 0));\n    \n    ivec3 ip = ivec3(floor(p * sz));\n    \n    vec4 s0 = texelFetch(tex, (ip + ivec3(0, 0, 0)) & ivec3(sz - 1.), level);\n    vec4 s1 = texelFetch(tex, (ip + ivec3(1, 0, 0)) & ivec3(sz - 1.), level);\n    vec4 s2 = texelFetch(tex, (ip + ivec3(0, 1, 0)) & ivec3(sz - 1.), level);\n    vec4 s3 = texelFetch(tex, (ip + ivec3(1, 1, 0)) & ivec3(sz - 1.), level);\n    vec4 s4 = texelFetch(tex, (ip + ivec3(0, 0, 1)) & ivec3(sz - 1.), level);\n    vec4 s5 = texelFetch(tex, (ip + ivec3(1, 0, 1)) & ivec3(sz - 1.), level);\n    vec4 s6 = texelFetch(tex, (ip + ivec3(0, 1, 1)) & ivec3(sz - 1.), level);\n    vec4 s7 = texelFetch(tex, (ip + ivec3(1, 1, 1)) & ivec3(sz - 1.), level);\n    vec3 f = smoothstep(0., 1., fract(p * sz));\n\n    return mix(\n        mix(mix(s0, s1, f.x),\n            mix(s2, s3, f.x), f.y),\n        mix(mix(s4, s5, f.x),\n            mix(s6, s7, f.x), f.y),\n        f.z);\n}\n","name":"Common","description":"","type":"common"}]}