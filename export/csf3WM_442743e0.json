{"ver":"0.1","info":{"id":"csf3WM","date":"1666193016","viewed":99,"name":"Erosion Lab - CIS 566","username":"lianghaoquan","description":"Erosion Lab for CIS 566","likes":1,"published":1,"flags":32,"usePreview":0,"tags":["cis566"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Pause and reset time to play\n\n// Color Palette (from IQ's blog)\nvec3 a = vec3(0.5, 0.5, 0.5);\nvec3 b = vec3(0.5, 0.5, 0.5);\nvec3 c = vec3(1.0, 1.0, 1.0);\nvec3 d = vec3(0.3, 0.2, 0.2);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n//  fragColor = texture(iChannel0, uv);\n\n    vec4 col = texture(iChannel0, uv);\n    fragColor = vec4(a + b * cos(2.0 * 3.1415926 * (c * col.rgb + d)), 1.f);\n\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord ) {\nvec2 uv = fragCoord / iResolution.x;\n    if(iFrame == 0) {\n        float f = fbm(uv);\n        vec2 warp1 = NoiseVectorFBM(uv) * 0.6;\n        float w = WorleyNoise(uv * vec2(1., 6.) + warp1);\n        float h = gain(mix(w, f, 0.33), 0.4);\n        fragColor = vec4(h,h,h,1.);\n    }\n    else {\n        // Here's how to read a pixel from the input buffer. This gets us the cell stored in a single pixel\n        float curr = texture(iChannel0, fragCoord / iResolution.xy).r;\n        \n        // 1. Get the values from the neighboring cells\n        float neighbors[9];\n        \n        int idx = 0;\n        for (int i=-1; i <= 1; ++i)\n        {\n            for (int j=-1; j<=1; ++j)\n            {   \n                neighbors[idx] = texture(iChannel0, (fragCoord + vec2(i, j)) / iResolution.xy).r;\n                idx++;\n            }\n        }\n        \n        \n        // 2. Get change in slope b/t each of 8 neighbors\n        float diffs[9];\n        \n        for(int i = 0; i < 9; ++i) \n        {\n            diffs[i] = neighbors[i] - curr;\n        }\n        \n        \n        // 3. For each negative slope, subtract height from\n        // curr proportional to diff. For each positive slope,\n        // add height to curr (represents neighbor losing\n        // height to us)\n        // To mimic erosion due to gravity, only do this when between\n        // certain thresholds. Here are some recommendations!\n        \n        #define THR_LOWER 0.0035\n        #define THR_UPPER 0.0085        \n       \n        for(int i = 0; i < 9; ++i) \n        {\n            if (abs(diffs[i]) > THR_LOWER && abs(diffs[i]) < THR_UPPER)\n            {\n                curr += EROSION_SCALAR * diffs[i];\n            }\n        }\n        \n       \n        fragColor = vec4(curr, curr, curr, 1.);\n    }\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define EROSION_SCALAR 0.05\n#define FBM_OCTAVES 8\n\nfloat bias(float t, float b) {\n    return (t / ((((1.0/b) - 2.0)*(1.0 - t))+1.0));\n}\n\nfloat gain(float time, float gain)\n{\n  if(time < 0.5)\n    return bias(time * 2.0,gain)/2.0;\n  else\n    return bias(time * 2.0 - 1.0,1.0 - gain)/2.0 + 0.5;\n}\n\nvec2 rotate(vec2 p, float deg) {\n    float rad = deg * 3.14159 / 180.0;\n    return vec2(cos(rad) * p.x - sin(rad) * p.y,\n                sin(rad) * p.x + cos(rad) * p.y);\n}\n\nvec2 random2( vec2 p ) {\n    return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\nfloat random1( vec2 p ) {\n    return fract(sin(dot(p,vec2(127.1,311.7)))*43758.5453);\n}\n\nfloat mySmootherStep(float a, float b, float t) {\n    t = t*t*t*(t*(t*6.0 - 15.0) + 10.0);\n    return mix(a, b, t);\n}\n\n\nfloat bilerpNoise(vec2 uv) {\n    ivec2 uvFloor = ivec2(floor(uv));\n    vec2 uvFract = fract(uv);\n    float ll = random1(vec2(uvFloor));\n    float lr = random1(vec2(uvFloor + ivec2(1, 0)));\n    float ul = random1(vec2(uvFloor + ivec2(0, 1)));\n    float ur = random1(vec2(uvFloor + ivec2(1, 1)));\n\n    float lerpXL = mySmootherStep(ll, lr, uvFract.x);\n    float lerpXU = mySmootherStep(ul, ur, uvFract.x);\n\n    return mySmootherStep(lerpXL, lerpXU, uvFract.y);\n}\n\nfloat fbm(vec2 uv) {\n    float amp = 0.5;\n    float freq = 8.0;\n    float sum = 0.0;\n    for(int i = 0; i < FBM_OCTAVES; i++) {\n        sum += bilerpNoise(uv * freq) * amp;\n        amp *= 0.5;\n        freq *= 2.0;\n    }\n    return sum;\n}\n\nfloat WorleyNoise(vec2 uv) {\n    // Tile the space\n    vec2 uvInt = floor(uv);\n    vec2 uvFract = fract(uv);\n    float minDist = 1.0; // Minimum distance initialized to max.\n\n    // Search all neighboring cells and this cell for their point\n    for(int y = -1; y <= 1; y++) {\n        for(int x = -1; x <= 1; x++) {\n            vec2 neighbor = vec2(float(x), float(y));\n\n            // Random point inside current neighboring cell\n            vec2 point = random2(uvInt + neighbor);\n\n            // Compute the distance b/t the point and the fragment\n            // Store the min dist thus far\n            vec2 diff = neighbor + point - uvFract;\n            float dist = length(diff);\n            minDist = min(minDist, dist);\n        }\n    }\n    return minDist;\n}\n\nvec2 NoiseVectorFBM(vec2 uv) {\n    float x = fbm(uv) * 2.0 - 1.0;\n    float y = fbm(rotate(uv, 60.0)) * 2.0 - 1.0;\n    return vec2(x, y);\n}","name":"Common","description":"","type":"common"}]}