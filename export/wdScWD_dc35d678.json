{"ver":"0.1","info":{"id":"wdScWD","date":"1586688372","viewed":989,"name":"Borderlands Toon Filter (WebCam)","username":"demios","description":"Borderlands style toon filter.\n\nPost-Processing filter - compositing a large low threshold surface blur with sobel outlines.","likes":8,"published":1,"flags":34,"usePreview":0,"tags":["sobel","cartoon","toon","surfaceblur","borderlands"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sf3zn","filepath":"/presets/webcam.png","previewfilepath":"/presets/webcam.png","type":"webcam","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n//Final Output\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    //Default Toon Output\n\tvec3 blurCol = texture(iChannel2, uv).xyz; \n    vec3 soblCol = texture(iChannel1, uv).xyz; \n\n    vec3 outline = vec3(1) - min(pow(soblCol, vec3(outlineRamp)), vec3(1));\n  \n    vec3 c = mix(blurCol, blurCol * outline, outlineHardness);       \n    c = pow(c, vec3(gamma));\n    \n \n    //Optional Outputs\n    if (fragCoord.x < iMouse.x)\n    {\n        //Original Source\n        c = texture(iChannel0, uv).xyz; \n         \n        //Sobel Edges\n     \tif (fragCoord.y < iMouse.y)\n        \tc = soblCol;\n    }\n    \n    fragColor = vec4(c, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"\n/**********************\n * Toon Shader Config *\n **********************/\n\n//Final Image Gamma Ramp\nconst float gamma = 0.6;\n\n//Sobel Outline Ramp\nconst float sobelPow = 2.5;\n\n//Final Outline Ramp (Uses ramped sobel as input)\nconst float outlineRamp = 7.2;\n\n//Outline Hardness (0 - no outline, 1 - full outline)\nconst float outlineHardness = 0.8;\n\n//SurfaceBlur Edge Threshold\nconst float blurEdge = 0.3;\n\n\n/***********************\n * Image Sizing Config *\n ***********************/\n\n//Hardcoded sobel step (should be 1 for true sobel) -> hacky way of mipmapping sobel for larger and/or blurry images\nconst float sobelStep = 1.2;\n\n//Blur Kernel size in pixels\nconst int mSize = 17;\n\n\n\n\nconst int kSize = (mSize - 1) / 2;\nconst float sigma = float(kSize);\nfloat kernel[mSize];\n\nfloat normpdf(in float x, in float sigma) \n{\n\treturn 0.39894*exp(-0.5*x*x/(sigma*sigma))/sigma;\n}\n\n\n//Based on surfaceBlur algorithm from rinsor (https://www.shadertoy.com/view/4sVyzR)\n// Only slight modifications were making the kernel size variable and removing the edge differences,\n// so no bluring occurs at all on hard edges. Not a true surface blur but seems to provide better\n// results with the sobel outlines.\nvec3 fastSurfaceBlur( sampler2D inputColor, sampler2D inputEdge, vec2 uv, vec2 blurStep)\n{\n\t// Normalized gauss kernel\n    for (int j = 0; j <= kSize; ++j) {\n        kernel[kSize+j] = kernel[kSize-j] = normpdf(float(j), sigma);\n    }\n\n\tvec3 result = blurEdge*kernel[kSize]*texture(inputColor,uv).xyz;\n\tfloat Z = blurEdge*kernel[kSize];\n\t\t\n\t// Right direction\n\tfloat weight = blurEdge;\n\tfor(int i = 1; i < kSize; i++){\n\t\tvec2 currentPos = uv + float(i)*blurStep;\n\t\t\n\t\tweight -= texture(inputEdge,currentPos).x;\n\t\tif (weight <= 0.0) break;\n\t\t\n\t\tfloat coef = weight*kernel[kSize+i];\n\t\tresult += coef*texture(inputColor,currentPos).xyz;\n\t\tZ += coef;\n\t}\n    \n\t// Left direction\n\tweight = blurEdge;\n\tfor(int i = 1; i<kSize; i++){\n\t\tvec2 currentPos = uv - float(i)*blurStep;\n\t\t\n\t\tweight -= texture(inputEdge,currentPos).x;\n\t\tif (weight <= 0.0) break;\n\t\t\n\t\tfloat coef = weight*kernel[kSize-i];\n\t\tresult += coef*texture(inputColor,currentPos).xyz;\n\t\tZ += coef;\n\t}\n    return result / Z;\n}\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4sf3zn","filepath":"/presets/webcam.png","previewfilepath":"/presets/webcam.png","type":"webcam","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Sobel edge detection from https://gist.github.com/Hebali/6ebfc66106459aacee6a9fac029d0115\n// - Added sobel ramp as a final step to provide control over edge hardness\n// - Hackily changed sobelStep from 1.0 to a custom scalar to allow jumping partial pixels larger than one.\n\nvoid make_kernel(inout vec4 n[9], sampler2D tex, vec2 coord)\n{\n\tfloat w = sobelStep / iResolution.x;\n\tfloat h = sobelStep / iResolution.y;\n\n\tn[0] = texture(tex, coord + vec2( -w, -h));\n\tn[1] = texture(tex, coord + vec2(0.0, -h));\n\tn[2] = texture(tex, coord + vec2(  w, -h));\n\tn[3] = texture(tex, coord + vec2( -w, 0.0));\n\tn[4] = texture(tex, coord);\n\tn[5] = texture(tex, coord + vec2(  w, 0.0));\n\tn[6] = texture(tex, coord + vec2( -w, h));\n\tn[7] = texture(tex, coord + vec2(0.0, h));\n\tn[8] = texture(tex, coord + vec2(  w, h));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec4 n[9];\n\tmake_kernel( n, iChannel0, fragCoord/iResolution.xy );\n\n\tvec4 sobel_edge_h = n[2] + (2.0*n[5]) + n[8] - (n[0] + (2.0*n[3]) + n[6]);\n  \tvec4 sobel_edge_v = n[0] + (2.0*n[1]) + n[2] - (n[6] + (2.0*n[7]) + n[8]);\n\tvec4 sobel = sqrt((sobel_edge_h * sobel_edge_h) + (sobel_edge_v * sobel_edge_v));\n    \n    sobel.xyz = min(pow(sobel.xyz, vec3(sobelPow)), vec3(1));\n\n    fragColor = vec4(vec3(dot(sobel.xyz, vec3(1))),2.0);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4sf3zn","filepath":"/presets/webcam.png","previewfilepath":"/presets/webcam.png","type":"webcam","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"\n//First Pass Surface Blur (Horizontal)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 result = fastSurfaceBlur(iChannel0,iChannel1,fragCoord/iResolution.xy,vec2(1.0/iResolution.x,0.0)).rgb;\n\n    fragColor = vec4(result.rgb,1.0);\n}\n\n","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"\n//Second Pass Surface Blur (Vertical)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec3 bluredColor = fastSurfaceBlur(iChannel1,iChannel0,fragCoord/iResolution.xy,vec2(0.0,1.0/iResolution.y)).rgb;\n    \n    fragColor = vec4(bluredColor,1.0);\n}","name":"Buffer C","description":"","type":"buffer"}]}