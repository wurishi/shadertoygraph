{"ver":"0.1","info":{"id":"3sjSRD","date":"1560028044","viewed":251,"name":"Deformed spheres","username":"matistjati","description":"Raymarching spheres using a deformed distance function","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float mapSphere(vec3 p, vec3 ray, float radius)\n{\n\treturn length(p - ray) - radius;\n}\n\nfloat smin( float a, float b, float k )\n{\n    float res = exp2( -k*a ) + exp2( -k*b );\n    return -log2( res )/k;\n}\n\nfloat mapAll(vec3 p, float time)\n{\n    const float disp = 7.;\n    const float speed = 0.5;\n    float displacement = sin(sin(time * speed) * p.x * disp)\n        * cos(sin(time * speed) * p.y * disp)\n        * sin(sin(time * speed) * p.z * disp) * 0.25;\n\n    float sphere_0 = mapSphere(p, vec3(-2.*sin(time * speed),0.,0.), 1.0) + displacement;\n\tfloat sphere_1 = mapSphere(p, vec3(1.*sin(time * speed),0.,0.), 1.0) + displacement;\n\n    \n    return smin(sphere_0, sphere_1, 32.);\n}\n\nvec3 calculateNormal(in vec3 p, float time)\n{\n    const vec3 small_step = vec3(0.001, 0.0, 0.0);\n\n    float gradient_x = mapAll(p + small_step.xyy, time) - mapAll(p - small_step.xyy, time);\n    float gradient_y = mapAll(p + small_step.yxy, time) - mapAll(p - small_step.yxy, time);\n    float gradient_z = mapAll(p + small_step.yyx, time) - mapAll(p - small_step.yyx, time);\n\n    vec3 normal = vec3(gradient_x, gradient_y, gradient_z);\n\n    return normalize(normal);\n}\n\nvec3 trace(vec3 ro, vec3 rd, float time)\n{\n    int maxSteps = 10;\n\n    float t = 0.0;\n    float totalDist = 0.0;\n    \n    int i = 0;\n    for (; i < maxSteps; i++)\n    {\n        vec3 position = ro + rd * t;\n    \tfloat dist = mapAll(position, time);\n        totalDist += dist;\n        \n        if (totalDist > 4.0)\n        {\n            return vec3(0.0, 0.0, 0.0);\n        }\n        \n        if (dist < 0.01)\n        {\n            vec3 normal = calculateNormal(position, time);\n\t\t\t\n            vec3 lightPosition = vec3(2.0, -5.0, 3.0);\n\n            vec3 directionToLight = normalize(position - lightPosition);\n\n            float diffuseIntensity = max(0.0, dot(normal, directionToLight));\n\t\t\tvec3 light = vec3(0.0, abs(sin(iTime)), abs(cos(iTime))) * diffuseIntensity;\n            \n            \n            return light;\n            //return texture(iChannel0, position.xy, 0.0).xyz;\n        }\n        t += dist;        \n    }\n    \n    return vec3(0.0, 0.0, 0.0);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec3 origin = vec3(.5, 0.0, -2);\n    // Time varying pixel color\n    vec3 col = trace(origin, vec3(uv.xy, 1), iTime);\n\n    fragColor = vec4(col.xyz, 1.0);\n}","name":"Image","description":"","type":"image"}]}