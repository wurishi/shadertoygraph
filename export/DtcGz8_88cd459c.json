{"ver":"0.1","info":{"id":"DtcGz8","date":"1681944351","viewed":68,"name":"Scatter Colors Hyperbolic","username":"izutionix","description":"Mouse.x = Value; Mouse.y = Saturation of the input color.\nTry different variations by uncommenting //commenting the defines at the top.\n(Some strange patterns observed out of bounds, I wouldn't go there if I were you..)","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["colors","scatter"],"hasliked":0,"parentid":"3dXfWH","parentname":"Scatter Colors (simplified)"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// variations: (for invCol function line 16)\n//#define useInverse // (normalized) combined with multiplyLength gives the same effect as all variations off but a bit broken\n//#define useInvert // the most insightful\n//#define multiplyLength // multiplies (normalized inverse) with length of original color\n//\n\n//#define animateHue // uses an atmospherey color otherwise\n//#define debugInputColor\n\n\nconst float PI = 3.14159265358979;\n\n//const vec3 tint = vec3(0.01, 0.25, 0.5); // blue\n//const vec3 tint = vec3(0.75, 0.25, 0.02); // orange\n\nvec3 invCol(vec3 x) {\n    vec3 res = x;\n    #ifdef useInvert\n    res = 1.-x; // invert\n    #endif\n    #ifdef useInverse\n    res = normalize(1./x); // inverse\n    #endif\n    #ifdef multiplyLength\n    res *= length(x);\n    #endif\n    return res;\n}\n\nvec3 changeExposure(vec3 col, vec3 b) {\n    b *= col;\n    return b/(b-col+1.);\n}\n\nvec3 changeExposure(vec3 col, float b) {\n    return changeExposure(col, vec3(b));\n}\n\nvec3 exposure01(vec3 c, float x) {\n    return c*x / (c*(2.*x-1.) - x+1.);\n    //return pow(c, vec3(1.-x));\n}\n\nvec3 ScatterColors(vec3 c, float g) // color c, gradient g\n{\n    float ig = g;\n    g = 1.-g;\n    vec3 g3 = vec3(g);\n    vec3 G1 = exposure01(c, g);\n    vec3 G2 = invCol(exposure01(invCol(c), ig));\n\n    vec3 A = G1*(1.-(G1));\n    vec3 B = G2*(1.-(G2));\n\n    return 4.*mix(A, B, ig);\n}\n            \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float t = iTime + 6.6;\n    vec2 uv = fragCoord/iResolution.xy;\n    //uv = 1.7*(uv-.5)+.5; // uncomment (with all variations enabled) if you're feeling adventurous..\n\n    vec3 col = vec3(.009, .288, .828);\n    vec3 hsv = vec3(.610, .989, .828); // hsv = rgb2hsv(col);\n    hsv.zy = .5+.4999*vec2(cos(0.618*t), sin(t)); // path if no mouse detected\n    if (iMouse.xy!=vec2(0)) { // if mouse\n        vec2 mouse = iMouse.xy/iResolution.xy;\n        hsv.zy = mouse; // mouse.x controls Value, mouse.y controls Saturation\n    }\n    #ifdef animateHue\n    hsv.x = (sin(t/3.)+1.)/2.; // uncomment to animate hue (comment to keep atmospherey color)\n    col = hsv2rgb_smooth(hsv);\n    #else\n    col = hsv2rgb(hsv);\n    #endif\n    \n    #ifndef debugInputColor\n    // does it in two passes; comment out one line to see better what is going on\n    col = ScatterColors(col, uv.x); // color is controlled by mouse (mouse.x = Value, mouse.y = Saturation)\n    col = ScatterColors(col, uv.y); // uses the colors acquired at the previous line as input\n    #endif\n\n    fragColor = vec4(col, 1.);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// hsv conversion is just for changing the input color; doesn't actually produce the effect of the shader\n// from: https://www.ronja-tutorials.com/2019/04/16/hsv-colorspace.html\nvec3 hue2rgb(float hue) {\n    hue = fract(hue);\n    float r = abs(hue * 6. - 3.) - 1.;\n    float g = 2. - abs(hue * 6. - 2.);\n    float b = 2. - abs(hue * 6. - 4.);\n    vec3 rgb = vec3(r,g,b);\n    rgb = clamp(rgb, 0., 1.);\n    return rgb;\n}\n\nvec3 hsv2rgb(vec3 hsv) {\n    vec3 rgb = hue2rgb(hsv.x);\n    rgb = mix(vec3(1.), rgb, hsv.yyy);\n    rgb = rgb * hsv.z;\n    return rgb;\n}\n\nvec3 rgb2hsv(vec3 rgb) {\n    float maxComponent = max(rgb.r, max(rgb.g, rgb.b));\n    float minComponent = min(rgb.r, min(rgb.g, rgb.b));\n    float diff = maxComponent - minComponent;\n    float hue = 0.;\n    if(maxComponent == rgb.r) {\n    hue = 0.+(rgb.g-rgb.b)/diff;\n    } else if(maxComponent == rgb.g) {\n    hue = 2.+(rgb.b-rgb.r)/diff;\n    } else if(maxComponent == rgb.b) {\n    hue = 4.+(rgb.r-rgb.g)/diff;\n    }\n    hue = fract(hue / 6.);\n    \n    float saturation = diff / maxComponent;\n    float value = maxComponent;\n    \n    return vec3(hue, saturation, value);\n}\n\n\n// Smooth HSV to RGB conversion modified from iq's: https://www.shadertoy.com/view/MsS3Wc\nvec3 hsv2rgb_smooth( in vec3 c ) {\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n    \n    rgb = 0.5-0.5*cos(rgb*3.1415926536); // cosine smoothing\n\t//rgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}","name":"Common","description":"","type":"common"}]}