{"ver":"0.1","info":{"id":"dddyD4","date":"1695087742","viewed":29,"name":"trying out 3d or something","username":"samsthenerd","description":"practicing","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["practice"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdfGRn","filepath":"/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","previewfilepath":"/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n// gets the corresponding uv coordinates\nvec2 getQuadCoords(vec2[4] points, vec2 p){\n    float lowestX = 1000.0;\n    float highestX = -1000.0;\n    float lowestY = 1000.0;\n    float highestY = -1000.0;\n    for(int i = 0; i < points.length(); i++){\n        if(points[i].x > highestX)\n            highestX = points[i].x;\n        if(points[i].x < lowestX)\n            lowestX = points[i].x;\n        if(points[i].y > highestY)\n            highestY = points[i].y;\n        if(points[i].y < lowestY)\n            lowestY = points[i].y;\n    }\n    float leftishV = (p.y - points[0].y) / (points[3].y - points[0].y);\n    float rightishV = (p.y - points[1].y) / (points[2].y - points[1].y);\n    float horPercent = (p.x - lowestX) / (highestX - lowestX);\n    float goodV = leftishV * (1.0-horPercent) + rightishV * horPercent;\n    float topishU = (p.x - points[0].x) / (points[2].x - points[0].x);\n    float bottomishU = (p.x - points[3].x) / (points[2].x - points[3].x);\n    float verPercent = (p.y - lowestY) / (highestY - lowestY);\n    float goodU = topishU * (1.0-verPercent) + bottomishU * verPercent;\n    return vec2(goodU, goodV);\n}\n\nvec2 getTriUVs(vec2[3] points, vec2[3] UVs, vec2 p){\n    return p;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // float dist = signedDistanceQuad(vec2(0.25, 0.25), vec2(0.75, 0.25), vec2(0.75, 0.75), vec2(0.25, 0.75), uv);\n    // vec2[4] rectangle = vec2[](vec2(0.25, 0.25), vec2(0.75, 0.25), vec2(0.75, 0.75), vec2(0.25, 0.75));\n    vec2[4] rectangle = vec2[](vec2(0.25+ 0.1*cos(iTime), 0.25), \n            vec2(0.75, 0.25), vec2(0.75, 0.75+ 0.1*sin(iTime)), iMouse.xy/iResolution.xy);\n    float dist = signedDistanceQuad(rectangle, uv);\n\n    // Time varying pixel color\n    vec3 col = dist >= 0.0 ? vec3(1,0,0) : vec3(0,1,1);\n    \n    vec2 texUV = getQuadCoords(rectangle, uv);\n    if(texUV.x < 0.0 || texUV.x > 1.0\n    || texUV.y < 0.0 || texUV.y > 1.0){\n        //fragColor = vec4(col, 1);\n    } else {\n        vec4 texCol = texture(iChannel0, texUV, 0.0);\n        fragColor = texCol ;//+ 0.25 * vec4(col, 0);\n    }\n    \n    \n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"float signedDistanceTri(vec2 a, vec2 b, vec2 c, vec2 p){\n    vec2[3] points = vec2[](a, b, c);\n    float dist = 100000.0;\n    bool realInside = true;\n    for(int i = 0; i < points.length(); i++){\n        vec2 v1 = points[i % points.length()];\n        vec2 v2 = points[(i+1) % points.length()];\n        vec2 v3 = points[(i+2) % points.length()];\n        vec2 v12 = v2 - v1;\n        vec2 v1p = p - v1;\n        vec2 v13 = v3 - v1;\n        vec2 normv12 = v12 / length(v12);\n        float v12CompOfv1p = dot(normv12, v1p);\n        float v12CompOfv13 = dot(normv12, v13);\n        vec2 shortest = v1p - normv12 * v12CompOfv1p;\n        float newDist = length(shortest);\n        vec2 sidedVec = v13 - normv12 * v12CompOfv13;\n        bool inside;\n        if(sidedVec.x != 0.0) {\n            inside = (shortest.x / sidedVec.x) > 0.0;\n        } else {\n            inside = (shortest.y / sidedVec.y) > 0.0;\n        }\n        if(v12CompOfv1p < 0.0){\n            newDist = distance(p, v1);\n        }\n        if(v12CompOfv1p >= length(v12)){\n            newDist = distance(p, v2);\n        }\n        if(!inside) realInside = false;\n        if(dist > 0.0 && !inside){ // if the current distance says we're inside but this says we're not then put us outside\n            dist = -newDist;\n        } else if(newDist < dist && realInside){ // if this is shorter than the current distance and we're still inside\n           dist = newDist;\n        } else if(!inside && newDist < -dist){\n            dist = -newDist;\n        }\n    }\n    return dist;\n}\n\nfloat signedDistanceQuad(vec2[4] points, vec2 p){\n    float dist = 100000.0;\n    bool realInside = true;\n    for(int i = 0; i < points.length(); i++){\n        vec2 v1 = points[i % points.length()];\n        vec2 v2 = points[(i+1) % points.length()];\n        vec2 v3 = points[(i+2) % points.length()];\n        vec2 v12 = v2 - v1;\n        vec2 v1p = p - v1;\n        vec2 v13 = v3 - v1;\n        vec2 normv12 = v12 / length(v12);\n        float v12CompOfv1p = dot(normv12, v1p);\n        float v12CompOfv13 = dot(normv12, v13);\n        vec2 shortest = v1p - normv12 * v12CompOfv1p;\n        float newDist = length(shortest);\n        vec2 sidedVec = v13 - normv12 * v12CompOfv13;\n        bool inside;\n        if(sidedVec.x != 0.0) {\n            inside = (shortest.x / sidedVec.x) > 0.0;\n        } else {\n            inside = (shortest.y / sidedVec.y) > 0.0;\n        }\n        if(v12CompOfv1p < 0.0){\n            newDist = distance(p, v1);\n        }\n        if(v12CompOfv1p >= length(v12)){\n            newDist = distance(p, v2);\n        }\n        if(!inside) realInside = false;\n        if(dist > 0.0 && !inside){ // if the current distance says we're inside but this says we're not then put us outside\n            dist = -newDist;\n        } else if(newDist < dist && realInside){ // if this is shorter than the current distance and we're still inside\n           dist = newDist;\n        } else if(!inside && newDist < -dist){\n            dist = -newDist;\n        }\n    }\n    return dist;\n}\n\nfloat signedDistanceQuad(vec2 a, vec2 b, vec2 c, vec2 d, vec2 p){\n    vec2[4] points = vec2[](a, b, c, d);\n    return signedDistanceQuad(points, p);\n}\n\n\n\n\n","name":"Common","description":"","type":"common"}]}