{"ver":"0.1","info":{"id":"Mt2fR1","date":"1541447360","viewed":225,"name":"Perlin Displacement Fire","username":"nr4","description":"Perlin displacement fire.\n","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["fire","perlin"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n * Perlin Displacement Fire\n * \n * Copyright (C) 2018  Alexander Kraus <nr4@z10.info>\n * \n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n * \n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n * \n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\nconst vec2 c=vec2(1.,0.);\n#define blend(a) ((6.*a-15.)*a+10.)*a*a*a\n#define rand(a0) fract(sin(dot(a0.xy ,vec2(12.9898,78.233)))*43758.5453)\n#define g(a,a0) (2.*rand(vec2(a,a0))-1.)\n#define interpolate(d,w00,w10,w01,w11) mix(mix(w00,w10,blend(d.x)),mix(w01,w11,blend(d.x)),blend(d.y))\n#define perlin1d(a,seed) mix(g(floor(a),seed)*fract(a),dot(vec2(g(floor(a)+1.,seed)),vec2(fract(a),-1.)),blend(fract(a)))\n\nfloat mfperlin1d(float x, float seed, float fmin, float fmax, float phi)\n{\n    float sum = 0.;\n    float a = 1.;\n    \n    for(float f = fmin; f<fmax; f = f*2.)\n    {\n        sum = a*perlin1d(f*x, seed) + sum;\n        a = a*phi;\n    }\n    \n    return sum;\n}\n\nvec2 g2d(vec2 x, float seed)\n{\n    return vec2(-1.)+2.*vec2(rand(x+vec2(seed+2., seed+1.)), rand(x+vec2(seed+3.,seed+4.)));\n}\n\nfloat perlin2d(vec2 x, float seed)\n{\n    return interpolate(fract(x),\n                       dot(g2d(floor(x), seed), fract(x)), \n                       dot(g2d(floor(x).xy+c.xy, seed), fract(x).xy-c.xy), \n                       dot(g2d(floor(x).xy+c.yx, seed), fract(x).xy-c.yx), \n                       dot(g2d(floor(x).xy+c.xx, seed), fract(x).xy-c.xx));\n}\n\nfloat mfperlin2d(vec2 x, float seed, float fmin, float fmax, float phi)\n{\n    float sum = 0.;\n    float a = 1.;\n    \n    for(float f = fmin; f<fmax; f = f*2.)\n    {\n        sum = a*perlin2d(f*x, seed) + sum;\n        a = a*phi;\n    }\n    \n    return sum;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = 1.5*(fragCoord.xy/iResolution.xy-iTime*vec2(0.,2.));\n    \n\tfragColor = mix(\n        c.yyyx, \n        vec4(1.,81./255.,0./255.,1.), \n        abs(mfperlin2d(vec2(1.5,.44)*uv-vec2(.4*perlin2d(2.*uv-7.2*iTime*c.xy,1.), perlin2d(1.*uv-4.4*iTime+1.,5.)),10.,1.,3.e1,.3))\n    );\n    fragColor += mix(\n        fragColor, \n        vec4(1.,173./255.,57./255.,1.), \n        mfperlin2d(vec2(1.6,.3)*uv-vec2(.4*perlin2d(1.4*uv-9.3*iTime*c.xy,1.), perlin2d(1.3*uv-5.7*iTime+1.,5.)),10.,1.,4.e1,.7)\n    );\n    fragColor += mix(\n        fragColor,\n        -vec4(1.,173./255.,57./255.,1.), \n        mfperlin2d(vec2(1.4,.1)*uv-vec2(.2*perlin2d(2.1*uv-6.1*iTime*c.xy,1.), perlin2d(1.7*uv-3.4*iTime+1.,5.)),10.,1.,3.e1,.9)\n    );\n    \n    fragColor = clamp(2.*tanh(fragColor),0.,1.);\n}","name":"Image","description":"","type":"image"}]}