{"ver":"0.1","info":{"id":"XtG3Dc","date":"1477099822","viewed":746,"name":"Pseudo kleinian test","username":"stduhpf","description":"I'm just playing with knighty's pseudo kleinian fractal","likes":35,"published":1,"flags":32,"usePreview":0,"tags":["raymarching","fractal","distancefield","dof"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//#define SHOW_FOCUS //show where the camera is focusing\n\n\n// #define CEL_SHADING // depth derivative  based outline effect. It works, but disabeld because it does not looks good with dof and the light blob\n#define DOF //Depth of field\n#define focus_mode 1 //0=focus on pointer,1=focus on center, default=focus on depth 1\n#define target (cross for pointing the center of the image)\n\n#define gamma 1.4 // gamma correction\n\n#define res  iResolution\n\nfloat GA =2.399;  // golden angle = 2pi/(1+phi)\n\n#define blit 50 // blur iterations (changes the quality , but also the radius of the blur\n#define  rot  mat2(cos(GA),sin(GA),-sin(GA),cos(GA))\n\n\n//this blur is not from me, it's a modified version of the simplified version of Dave Hoskin's blur I copied from: https://www.shadertoy.com/view/ltKGzc\nvec3 dof(sampler2D tex,vec2 uv,float rad)\n{\n\tvec3 acc=vec3(0);\n    vec2 pixel=vec2(.002*res.y/res.x,.002),angle=vec2(0,rad);\n    rad=1.;\n\tfor (int j=0;j<blit;j++)\n    {  \n        rad += 1./rad;\n\t    angle*=rot;\n        vec4 col=texture(tex,uv+pixel*(rad-1.)*angle);\n\t\tacc+=col.xyz;\n\t}\n\treturn acc/float(blit) ;\n}\nvec4 pow4(vec4 v, float p)\n{\n    return vec4(pow(v.x,p),pow(v.y,p),pow(v.z,p),pow(v.w,p));}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    #ifdef DOF\n    float depth =texture(iChannel0,fragCoord/res.xy).w;\n  float d0;\n    if(focus_mode==0)\n    {\n    vec2 um = iMouse.xy/res.xy;\n        if(iMouse.xy ==vec2(0))\n        um = vec2(.5);\n     \t d0 = texture(iChannel0,vec2(um)).w; // click to focus\n  \t\t  }\n        else\n        {\n          d0=1.;\n   \t\t if (focus_mode ==1)\n\t\t \td0 = texture(iChannel0,vec2(.5)).w;\n        }\n    \n    if(d0==0.)d0=50.;\n\tdepth =depth ==0.?0.:abs(.5* log(depth/d0));\n    \n   fragColor = pow4(vec4(dof(iChannel0,fragCoord/res.xy,depth),1.),gamma);\n    \n    #ifdef SHOW_FOCUS\n   if(depth-.02<0.&& depth !=0.)\n       fragColor=vec4(length(fragColor.rgb),0.,0.,0.);\n    #endif\n\n    #else\n    fragColor  = pow4(texture(iChannel0,fragCoord/res.xy),gamma);\n    #endif\n    #ifdef CEL_SHADING\n    vec2 e = vec2(.003,0);\n    vec4 dif = vec4(texture(iChannel0,fragCoord/res.xy+e.xy).w,texture(iChannel0,fragCoord/res.xy+e.yx).w,\n                    texture(iChannel0,fragCoord/res.xy-e.xy).w,texture(iChannel0,fragCoord/res.xy-e.yx).w);\n    dif = log(dif);\n    float d = length(vec2(abs(dif.x-dif.z),abs(dif.y-dif.w)));\n    if(d>.1)  fragColor*=0.;\n    #endif\n    #ifdef target\n    vec2 uv = fragCoord-iResolution.xy/2.;\n    fragColor= abs(uv.x)<1.&&abs(uv.y)<20.||abs(uv.y)<1.&&abs(uv.x)<20.?1.-fragColor:fragColor;\n    #endif\n\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// fractal constants ( i'm not sure how to call them, but you can try to change them.)\n#define s vec3(.8,1.,.6)\n#define scale .7\n#define maxi .75\n#define fr_it 8\n\n#define ray_it 500\n#define prec .003\n\n#define mdist 15.\n\n#define time 1.*iTime\n\nfloat pk(vec3 p)\n{\n    float k=1.;\n    for( int i =0;i<fr_it;i++)\n    {\n        p=2.*clamp(p,-s,s)-p;//boxfold (repetition)\n        float f = max(scale/dot(p,p),maxi);\n        p*=f;\n        k*=f*1.05;\n    }\n    return max(length(p.xz)-.9,length(p.xz)*abs(p.y)/length(p))/k;\n}\n\nfloat intersect(vec3 ro,vec3 rd)\n{\n    vec3 p = ro;\n    float db = 0.;\n    for(int i = 0;i<ray_it;i++)\n    {\n        float d = pk(p);\n        if(d<prec)\n            return db;\n        p+=d*rd;\n        db+=d;\n        if(db>mdist)\n            break;\n    }\n    return -mdist;\n}\n\nvec3 normal(vec3 p)\n{\n    vec2 e = vec2(.00001,0);\n    return normalize( vec3 (pk(p+e.xyy)-pk(p-e.xyy),pk(p+e.yxy)-pk(p-e.yxy),pk(p+e.yyx)-pk(p-e.yyx)));\n}\n\n\nfloat calcshadow(vec3 orig, vec3 rd,float dist)\n{\n    float f=.02;\n    for(int i = 0; i <ray_it; i++)\n    {\n        float h = pk(orig+f*rd);\n        if(h<prec)\n            return 0.;\n        f+=h;      \n        if(f > dist)\n        \tbreak;\n    }\n    return 1.;\n}\n\nfloat ao(vec3 p, vec3 n)\n{\n    const float ao_it =5.;\n    float d=0.;\n    float sm =0.;\n    for(float i=1.;i<ao_it;i++)\n    {\n        d+=.075;\n        float h = pk(p+d*n);\n        sm+=(d-h)/pow(2.,i);\n    }\n    return 1.-sm*4.;\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.x- vec2(.5,.5+(iResolution.y-iResolution.x)/(2.*iResolution.x));\n    \n    vec2 mse =iMouse.xy/iResolution.x-vec2(.5,.5+(iResolution.y-iResolution.x)/(2.*iResolution.x));\n    mse*=8.;\n    if(iMouse.xy==vec2(0))\n        mse=vec2(-2.3,-.7);\nmat3 ry = mat3(1,0,0,0,cos(mse.y),sin(mse.y),0,-sin(mse.y),cos(mse.y));\nmat3 rx = mat3(cos(mse.x),0,sin(mse.x),0,1,0,-sin(mse.x),0,cos(mse.x));\n    \n    vec3 ro = vec3(.5,.8,.5);\n    vec3 rd = normalize(vec3(uv,.5))*ry*rx;\n    float d = intersect(ro,rd);\n    vec3 lo=vec3(-.5+.05*cos(time),.5+.1*cos(1.1*time+1.),.5*sin(.9*time));\n    vec3 col = vec3(1);\n    if(d>0.)\n    {\n        vec3 pos = ro+d*rd;\n        vec3 ld = normalize(lo-pos);\n        float l =distance(pos,lo);\n        vec3 n =normal(pos);\n        float light=ao(pos,n);\n        float sh = calcshadow(pos,ld,l);\n        light*=clamp(pow(dot(n,ld)*sh/(l*l*.5),.5),.2,1.2);\n        col = clamp(.5+.5*n,0.,1.);\n        col*=light;\n        col=mix(col,vec3(1,.9,.8),sh*.02/distance(rd,reflect(ld,n))/l);\n    }\n    col=mix(col,vec3(.1),abs(d)/mdist);\n    col=mix(col,vec3(1,.9,.8),calcshadow(ro,rd,distance(ro,lo))*.02/distance(rd,normalize(lo-ro)));\n    \n    fragColor = vec4(clamp(col,0.,1.),abs(d));\n}","name":"Buffer A","description":"","type":"buffer"}]}