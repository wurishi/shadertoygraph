{"ver":"0.1","info":{"id":"ltjcRc","date":"1509623174","viewed":192,"name":"Planetary setup","username":"Ultraviolet","description":"WIP","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["ray","planet","tracing","frame"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n#define M_PI 3.1415972\n\n// Sky parameters\nvec3 sunDir = normalize(vec3(0.0, 1.0, 1.0));\nvec3 sunCol = normalize(vec3(1.0));\n\nvec3 getSky(vec3 rd)\n{\n    return pow(texture(iChannel0, rd).rgb, vec3(1.0/0.45));\n    //return pow(mix(vec3(0.5), vec3(0.6, 0.6, 0.8), clamp(rd.y+0.5, 0.0, 1.0)), vec3(1.0/0.45));\n}\n\n\nvec3 shading(vec3 color, vec3 normal, vec3 rd)\n{\n    float t = 0.1+0.9*max(dot(sunDir, normal), 0.0);\n    float spec = pow(max(0.0, dot(reflect(rd, normal), sunDir)), 128.0);\n    return color*sunCol*t + sunCol*spec;\n    //return color*sunCol*t + getSky(normal)*0.2;\n}\n\nfloat cylinderDistance(vec3 pos, vec3 o, vec3 d, float r)\n{\n    return length(pos-o-d*dot(pos-o,d)/dot(d,d)) - r;\n}\n\nvec4 traceCylindre(vec3 ro, vec3 rd, inout float t, vec3 o, vec3 d, float r, vec3 in_col, vec3 out_col)\n{\n    float h_min = 0.0;\n    float h_max = length(d);\n    \n    float t_max = t;\n    \n    vec3 A = rd - d*dot(rd,d)/dot(d,d);\n    vec3 B = ro - o - d*dot(ro-o,d)/dot(d,d);\n    \n    float delta = dot(A,B)*dot(A,B) - dot(A,A)*(dot(B,B)-r*r);\n    \n    if(delta<0.0)\n    {\n        return vec4(0.0);\n    }\n    \n    delta = sqrt(delta);\n    \n    float t0 = (-dot(A,B)-delta)/dot(A,A);\n    float t1 = (-dot(A,B)+delta)/dot(A,A);\n    \n    if(t1<0.0)\n    {\n        return vec4(0.0);\n    }\n    \n    t = t0>0.0?t0:t1;\n    \n    vec3 pos = ro+rd*t;\n    \n    float opp = sign(cylinderDistance(ro, o, d, r));\n    float h = dot(d,pos-o)/length(d);\n    if(h<h_min)\n    {\n        t = t1;\n    \tpos = ro+rd*t;\n        h = dot(d,pos-o)/length(d);\n        opp *= -1.0;\n        if(h<h_min)\n        {\n            t = t_max;\n        \treturn vec4(0.0);\n        }\n    }\n\n    if(h>h_max)\n    {\n        t = t1;\n    \tpos = ro+rd*t;\n        h = dot(d,pos-o)/length(d);\n        opp *= -1.0;\n        if(h>h_max || h<h_min)\n        {\n            t = t_max;\n        \treturn vec4(0.0);\n        }\n    }\n    \n    if(t > t_max)\n    {\n            t = t_max;\n        \treturn vec4(0.0);\n    }\n    \n    \n    vec3 norm = -normalize(cross(d, cross(d, pos-o)));\n    norm *= opp;\n    \n    //vec3 col = mix(in_col, out_col, 0.5+0.5*opp);\n        \n    //col *= max(0.0, dot(norm, sunDir));\n    \n    vec3 col = shading(out_col, norm, rd);\n    \n    return vec4(col, 1.0);\n}\n\nfloat coneDistance(vec3 pos, vec3 o, vec3 d, float r)\n{\n    return length(pos-o-d*dot(pos-o,d)) - abs(dot(pos-o,d))*r;\n}\n\nvec4 traceCone(vec3 ro, vec3 rd, inout float t, vec3 o, vec3 d, float h_max, float r, vec3 col)\n{\n    float t_max = t;\n    \n    //--------------------------------------\n    // polynome terms computation\n    // \n    \n    // cylindrical part\n    vec3 A = rd - d*dot(rd,d);\n    vec3 B = ro - o - d*dot(ro-o,d);\n    \n    // conical part\n    vec3 A_ = d*dot(rd,d);\n    vec3 B_ = d*dot(ro-o,d);\n    \n    float a = dot(A,A) - r*r*dot(A_, A_);\n    float b = dot(A,B) - r*r*dot(A_, B_);\n    float c = dot(B,B) - r*r*dot(B_, B_);\n    \n    float delta = b*b-a*c;\n    \n    if(delta<0.0)\n    {\n        return vec4(0.0);\n    }\n    \n    \n    delta = sqrt(delta);\n    \n    float t0 = (-b-delta)/a;\n    float t1 = (-b+delta)/a;\n    \n    // warning: 'a' can be negative, we therefore need extra precaution (compared to the cynlindrical case)\n    float tt0 = min(t0, t1);\n    float tt1 = max(t0, t1);\n    \n    if(tt1 < 0.0)\n        return vec4(0.0);\n    \n    t = tt0>0.0?tt0:tt1; // we retain the smallest positive value\n        \n    vec3 pos = ro+rd*t;\n    \n    // this parameter is -1 if ro lies inside the cone and 1 else\n    // -- it is used for inverting inside normals in the former case\n    float opp = sign(coneDistance(ro,o,d,r));\n    \n    //--------------------------------\n    // height tests\n    \n    float h = dot(d,pos-o);\n    float h_min = 0.0;\n    if(h<h_min)\n    {\n        // only possible if t == tt0\n        t = tt1;\n    \tpos = ro+rd*t;\n        h = dot(d,pos-o);\n        opp *= -1.0;\n        if(h<h_min)\n        {\n            t = t_max;\n        \treturn vec4(0.0);\n        }\n    }\n\n    if(h>h_max)\n    {\n        // only possible if t == tt0\n        t = tt1;\n    \tpos = ro+rd*t;\n        h = dot(d,pos-o);\n        opp *= -1.0;\n        if(h>h_max || h<h_min)\n        {\n            t = t_max;\n        \treturn vec4(0.0);\n        }\n    }\n    \n    if(t>t_max)\n    {\n        t = t_max;\n        return vec4(0.0);\n    }\n    \n    vec3 norm = -normalize(cross(pos-o, cross(d, pos-o)));\n    norm *= sign(dot(d, pos-o));\n    norm *= opp;\n    \n        \n    col = shading(col, norm, rd);\n    \n    return vec4(col, 1.0);\n}\n\nvec4 traceCap(vec3 ro, vec3 rd, inout float t, vec3 c, vec3 n, float rad, vec3 col)\n{\n    float t_max = t;\n    \n    t = dot(c-ro, n)/dot(rd,n);\n    if(t<0.0 || t > t_max)\n    {\n        t = t_max;\n        return vec4(0.0);\n    }\n    \n    vec3 p_proj = ro+rd*t;\n    \n    if(length(c-p_proj) > rad)\n    {\n        t = t_max;\n        return vec4(0.0);\n    }\n    \n    col = shading(col, n, rd);\n    \n    return vec4(col, 1.0);\n}\n\n\nvec4 traceCapedCone(vec3 ro, vec3 rd, inout float t, vec3 o, vec3 d, float h_max, float r, vec3 in_col)\n{\n    vec4 res = traceCone(ro, rd, t, o, d/length(d), h_max, r, in_col);\n    vec4 col = vec4(0.0);\n    col = res;\n    \n    res = traceCap(ro, rd, t, o+normalize(d)*h_max, normalize(d), r*h_max, in_col) ;\n    col = vec4(col.rgb*(1.0-res.a)+res.rgb*res.a, max(res.a, col.a));\n                \n    return col;\n}\n\nvec4 traceSphere(vec3 ro, vec3 rd, inout float t, vec3 o, float r, vec3 col)\n{\n    float t_max = t;\n    float delta = pow(dot(rd, ro) - dot(o,rd), 2.0) - (dot(o, o)+dot(ro,ro)-2.*dot(o, ro)-r*r);\n    \n    if(delta < 0.0)\n    \treturn vec4(0.0);\n    \n    delta = sqrt(delta);\n    float t1 = dot(o, rd) - dot(rd, ro) - delta;\n    float t2 = t1 + 2.0*delta;\n    \n    t = t1 > 0.0 ? t1 : t2;\n    \n    if(t > t_max || t < 0.0)\n    {\n        t = t_max;\n        return vec4(0.0);\n    }\n    \n    vec3 p = ro + t*rd;\n    vec3 n=normalize(p-o);\n    \n    col = shading(col, n, rd);\n    \n    return vec4(col, 1.0);\n}\n\nvec4 tracePlane(vec3 ro, vec3 rd, inout float t, vec3 o, vec3 n, vec3 col)\n{\n    float t_max = t;\n    \n    t = -dot(ro, n)/dot(rd,n);\n    if(t<0. || t>t_max)\n    {\n        t = t_max;\n        return vec4(0.0);\n    }\n    \n    col = shading(col, n, rd);\n    \n    return vec4(col, 1.0);\n}\n\nvec4 traceArrow(in vec3 ro, in vec3 rd, inout float t, vec3 base, vec3 top, float r, vec3 col)\n{    \n    vec4 tempCol = traceCapedCone(ro, rd, t, top, base-top, 2.0*length(top-base)*0.2, 0.5*r/length(top-base)*5., col);\n    vec4 col_ = tempCol;\n    tempCol = traceCylindre(ro, rd, t, base, 3.0*(top-base)*0.2, 0.5*r, col, col);\n    col_ = mix(col_, tempCol, tempCol.w);\n    \n    return col_;\n}\n\n\nvec4 traceFrame(in vec3 ro, in vec3 rd, inout float t, in mat4 m)\n{\n    vec4 col = vec4(0.0);\n    float t0 = t;\n    \n    float r = (length(m[0])+length(m[1])+length(m[2]))/3./5.0;\n    \n    vec4 tempCol;\n    \n    tempCol = traceSphere(ro, rd, t, m[3].xyz, r, vec3(1.0));\n    col = tempCol;\n    \n    tempCol = traceArrow(ro, rd, t, m[3].xyz, m[3].xyz+m[0].xyz, r, vec3(1.0, 0.0, 0.0));\n    col = mix(col, tempCol, tempCol.w);\n    \n    tempCol = traceArrow(ro, rd, t, m[3].xyz, m[3].xyz+m[1].xyz, r, vec3(0.0, 1.0, 0.0));\n    col = mix(col, tempCol, tempCol.w);\n    \n    tempCol = traceArrow(ro, rd, t, m[3].xyz, m[3].xyz+m[2].xyz, r, vec3(0.0, 0.0, 1.0));\n    col = mix(col, tempCol, tempCol.w);\n    \n    return col;\n}\n\nmat4 Identity()\n{\n    mat4 m;\n    m[0] = vec4(1.0, 0.0, 0.0, 0.0);\n    m[1] = vec4(0.0, 1.0, 0.0, 0.0);\n    m[2] = vec4(0.0, 0.0, 1.0, 0.0);\n    m[3] = vec4(0.0, 0.0, 0.0, 1.0);\n    \n    return m;\n}\n\nmat4 Rotation(vec3 axisAngle)\n{\n    float alpha = length   (axisAngle);\n    vec3  axis  = normalize(axisAngle);\n    \n    float c = cos(alpha);\n    float s = sin(alpha);\n    float t = 1.0-c;\n    float x = axis.x;\n    float y = axis.y;\n    float z = axis.z;\n    \n    mat4 m;\n    m[0] = vec4(t*x*x + c,   t*x*y + z*s, t*x*z - y*s, 0.0);\n    m[1] = vec4(t*x*y - z*s, t*y*y + c  , t*y*z + x*s, 0.0);\n    m[2] = vec4(t*x*z + y*s, t*y*z - x*s, t*z*z + c  , 0.0);\n    m[3] = vec4(0.0, 0.0, 0.0, 1.0);\n    // Note : see here http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToMatrix/index.htm\n    \n    return m;\n}\n\nmat4 Translation(vec3 d)\n{\n    mat4 m;\n    m[0] = vec4(1.0, 0.0, 0.0, 0.0);\n    m[1] = vec4(0.0, 1.0, 0.0, 0.0);\n    m[2] = vec4(0.0, 0.0, 1.0, 0.0);\n    m[3] = vec4(d, 1.0);\n    \n    return m;\n}\n\nmat4 Scale(float factor)\n{\n    mat4 m;\n    m[0] = vec4(factor, 0.0, 0.0, 0.0);\n    m[1] = vec4(0.0, factor, 0.0, 0.0);\n    m[2] = vec4(0.0, 0.0, factor, 0.0);\n    m[3] = vec4(0.0, 0.0, 0.0, 1.0);\n    \n    return m;\n}\n\nmat4 GPS(float latitude, float longitude)\n{\n    vec3 north = vec3(-sin(latitude)*cos(longitude), cos(latitude), sin(latitude)*sin(longitude));\n    vec3 up    = vec3(cos(latitude)*cos(longitude),sin(latitude),cos(latitude)*sin(-longitude));\n    vec3 east  = vec3(-sin(longitude),0.,-cos(longitude));\n\n    \n    mat4 m;\n    m[0] = vec4(north, 0.0);\n    m[1] = vec4(up, 0.0);\n    m[2] = vec4(east, 0.0);\n    m[3] = vec4(up, 1.0);\n    \n    return m;\n}\n\nvec3 render( in vec3 ro, in vec3 rd)\n{\n\t//vec3 col = vec3(1.0);\n\tvec3 col = getSky(rd);\n    \n    float t = 100.0;\n    vec4 res; \n    \n    mat4 I = Identity();\n    mat4 R = Rotation(vec3(iTime*2.));\n    mat4 T = Translation(1.0*vec3(cos(iTime*2.), 0., sin(iTime*2.)));\n    mat4 S = Scale(1.0+cos(iTime*3.)*0.5);\n    \n    mat4 m;\n    \n    m = I;\n    res = traceFrame(ro, rd, t, m) ;\n    col = col*(1.0-res.a)+res.rgb*res.a;\n    \n    mat4 T_rotation  = Translation(3.0*vec3(cos(iTime), 0., sin(iTime)));\n    mat4 R_obliquity = Rotation(vec3(0.0, 0.0, 23.*M_PI/180.));\n    mat4 R_time      = Rotation(vec3(0.0, iTime*5., 0.0));\n    m = T_rotation*R_obliquity*R_time*Scale(0.5);\n    res = traceFrame(ro, rd, t, m) ;\n    col = col*(1.0-res.a)+res.rgb*res.a;\n    \n    m = T_rotation*R_obliquity*R_time*Scale(0.5)*GPS(M_PI/4., 0.)*Scale(0.5);\n    res = traceFrame(ro, rd, t, m) ;\n    col = col*(1.0-res.a)+res.rgb*res.a;\n    \n    vec3 lightDir = normalize(-m[3].xyz);\n    float lightDirX = dot(lightDir, m[0].xyz)/length(m[0].xyz);\n    float lightDirY = dot(lightDir, m[1].xyz)/length(m[1].xyz);\n    float lightDirZ = dot(lightDir, m[2].xyz)/length(m[2].xyz);\n    float altitude  = acos(lightDirY);\n    float azimut    = atan(lightDirZ, lightDirX);\n    lightDir = vec3(sin(altitude)*cos(azimut), cos(altitude), sin(altitude)*sin(azimut));\n    lightDir = (m * vec4(lightDir, 0)).xyz * 4.;\n    res = traceArrow(ro, rd, t, m[3].xyz, m[3].xyz+.5*lightDir, 0.1, vec3(1.0, 1.0, 0.0));\n    col = mix(col, res.rgb, res.a);\n    \n    res = traceSphere(ro, rd, t, 3.0*vec3(cos(iTime), 0., sin(iTime)), .5, vec3(0.5, 0.5, 1.0)) ;\n    col = col*(1.0-res.a*0.3)+res.rgb*res.a*0.3;\n    \n    \n    \n    return  col;\n}\n\nvec3 postEffects(vec3 col, vec2 uv)\n{\n\t// Gamma correction\n\tcol = pow(col, vec3(0.45));\n\t\n\treturn col;\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (-iResolution.xy + 2.0*fragCoord.xy)/ iResolution.y;\n\n    vec2 m = iMouse.xy/iResolution.xy;\n    \n    float speed = 0.0;\n    \n    // camera & ray\n    float phi = m.x * M_PI * 2.0;\n    if(iMouse.x < 0.5)\n        phi=iTime*M_PI*0.1;\n    \n    float psi = m.y * M_PI;\n    if(iMouse.y < 0.5)\n        psi = 0.33*M_PI;\n    vec3 ro = 5.0*vec3(cos(phi)*sin(psi), cos(psi), sin(phi)*sin(psi));\n\tvec3 ta = vec3(0.0);\n    mat3 ca = setCamera( ro, ta, 0.0 );\n    vec3 rd = ca * normalize( vec3(p.xy,1.5));\n    \n    \n    vec3 col = render( ro, rd);\n    \n\tcol = postEffects(col, fragCoord/iResolution.xy);\n    \n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}