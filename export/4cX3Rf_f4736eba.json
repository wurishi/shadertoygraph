{"ver":"0.1","info":{"id":"4cX3Rf","date":"1703297905","viewed":175,"name":"A Postcard From Timeline-1","username":"msm01","description":"HO HO HO ! The original text was three times longer (2700 chars), but I got a compile error for large array from Shadertoy. :O So I downsized it in a hurry, which is a bit sad but life goes on I guess. MERRY CHRISTMAS AND A HAPPY NEW YEAR ! :D","likes":23,"published":1,"flags":64,"usePreview":0,"tags":["christmas","text","space","painting","tree","scifi","art","scroller","spaceship","2023"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsX3Rn","filepath":"/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg","previewfilepath":"/media/ap/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Mdd3zf","filepath":"https://soundcloud.com/malmen/nouveau","previewfilepath":"https://soundcloud.com/malmen/nouveau","type":"musicstream","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// —/— Mandatory Bonus Fiction —/—\n\n// Meanwhile in Timeline-987654 :\n// —Ugh, it's those damn posers from Timeline-1 again... Flipping\n// bits in my NVIDIA without asking ! Why can't they leave me alone !?\n// —I know, right ?! With their fancy spaceships, their interdimensional\n// postcards and their unsufferable humble brag...\n// —\"It'S 2023 AnD We'Re 12000 liGhT-YeArS fRoM EaRtH, aWeSOoOoOomE !\"\n// —Those damn bastards !\n// —They're just the worst...\n\n// —/— Instructions —/—\n\n// Click on the right part of the screen to enjoy a Christmas-free\n// scifi scenery, or click on the left for shiny colors, happy mood,\n// and to read a postcard from another -admittedly better- timeline.\n\n// —/— Commentary —/—\n\n// \"But msm01, it's a 2D side-scroller with a spaceship... again !\"\n\n// Yes. Yes it is. Isn't that great ?! :D I love 2D side-scrollers, also\n// I don't think I have explored everything there is to know about them\n// (far from it!).\n// That being said, I DID in fact expect to comeback with something a bit\n// different. Hahaha, well, maybe next time.\n\n// Ross : \"The word you're searching for is... Anyway...\"\n\n// Happy New Year and Merry Christmas to all of you ! :)\n\n// The music is Nouveau, a very recent one by Malmen... Check it out !\n// https://soundcloud.com/malmen/nouveau\n// https://creativecommons.org/licenses/by-nc-sa/3.0/\n\n// Basic Geometry Functions.\n\nfloat sdCircle(in vec2 p, float radius, vec2 pos, float prec)\n{\n      return smoothstep(0.0,prec,radius - length(pos-p));\n}\n\n// This belongs to Iq...\n\nfloat dis_e(vec2 center, float a, float b, vec2 coord)\n{\n      float x2 = (coord.x-center.x)*(coord.x-center.x);\n      float y2 = (coord.y-center.y)*(coord.y-center.y);\n      float a2 = a*a;\n      float b2 = b*b;\n      float d = 1.0;\n      d = x2/a2+y2/b2;\n      return d;\n}\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n      vec2 d = abs(p)-b;\n      return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat sdStar5(in vec2 p, in float r, in float rf)\n{\n    const vec2 k1 = vec2(0.809016994375, -0.587785252292);\n    const vec2 k2 = vec2(-k1.x,k1.y);\n    p.x = abs(p.x);\n    p -= 2.0*max(dot(k1,p),0.0)*k1;\n    p -= 2.0*max(dot(k2,p),0.0)*k2;\n    p.x = abs(p.x);\n    p.y -= r;\n    vec2 ba = rf*vec2(-k1.y,k1.x) - vec2(0,1);\n    float h = clamp( dot(p,ba)/dot(ba,ba), 0.0, r );\n    return length(p-ba*h) * sign(p.y*ba.x-p.x*ba.y);\n}\n\nfloat sdTriangle( in vec2 p, in vec2 p0, in vec2 p1, in vec2 p2 )\n{\n    vec2 e0 = p1-p0, e1 = p2-p1, e2 = p0-p2;\n    vec2 v0 = p -p0, v1 = p -p1, v2 = p -p2;\n    vec2 pq0 = v0 - e0*clamp( dot(v0,e0)/dot(e0,e0), 0.0, 1.0 );\n    vec2 pq1 = v1 - e1*clamp( dot(v1,e1)/dot(e1,e1), 0.0, 1.0 );\n    vec2 pq2 = v2 - e2*clamp( dot(v2,e2)/dot(e2,e2), 0.0, 1.0 );\n    float s = sign( e0.x*e2.y - e0.y*e2.x );\n    vec2 d = min(min(vec2(dot(pq0,pq0), s*(v0.x*e0.y-v0.y*e0.x)),\n                     vec2(dot(pq1,pq1), s*(v1.x*e1.y-v1.y*e1.x))),\n                     vec2(dot(pq2,pq2), s*(v2.x*e2.y-v2.y*e2.x)));\n    return -sqrt(d.x)*sign(d.y);\n}\n\n// Still searching for the unknown Shadertoyer that wrote this :\n\nfloat metaDiamond(vec2 p, vec2 pixel, float r)\n{\n      vec2 d = abs(p-pixel);\n      return 1.0*r / (d.x + d.y);\n}\n\n// Code Start\n\nfloat traceChar( in vec2 v,float charac, vec2 PosTxt)\n{\n      float colorChar = 0.0;\n      v = vec2(v.x, 1.0-v.y);\n      if( v.x > PosTxt.x && v.x < PosTxt.x + 1.0/16.0 )\n      {\n          if( v.y > PosTxt.y && v.y < PosTxt.y + 1.0/16.0 )\n          {\n              vec2 Disp = vec2(mod(float(charac),16.0),floor(float(charac) / 16.0))/16.0;\n              colorChar = texture(iChannel1,vec2(Disp.x + (v.x - PosTxt.x),-Disp.y - (v.y - PosTxt.y) )).x;\n          };\n      };\n      return colorChar;\n}\n\nfloat Smooth1D(in vec2 v_p)\n{\n      float VarX1 = 0.0;\n      float VarX2 = 0.0;\n      float VarD0 = 0.0;\n      float Amplitude = 0.5;\n      float Periode   = 2.0;\n      float pvpx = Periode*v_p.x;\n      VarX1 = Amplitude*floor(pvpx);\n      VarX2 = Amplitude*floor(pvpx + 1.0);\n      VarD0 = fract(pvpx);\n      return mix(noise(vec2(VarX1)),noise(vec2(VarX2)),smoothstep(0.0,1.0,VarD0));\n}\n\nfloat drawStars(in vec2 p)\n{\n      float Disp_Star = 0.0;\n      float Buff_Star = 0.0;\n      float PosX_Star = 0.0;\n      float PosY_Star = 0.0;\n      float Dist_Star = 0.0;\n      float Magn_Star = 0.0;\n      if( length(p) > 2.5 ) // Masking Gas Giant\n      {\n          for( float j = 0.0; j < 40.0 ; j+=1.0 )\n          {\n               PosX_Star  = mod((15.0*noise(vec2(0.35*j))-7.5) - Disp_Star,15.0) - 7.5;\n               PosY_Star  = 9.0*noise(vec2(j + 176.0));\n               Dist_Star  = length(p - vec2(PosX_Star,PosY_Star));\n               if( Dist_Star < 0.1 ) // Masking Each Star\n               {\n                   Magn_Star  = 0.0002*noise(vec2(j));\n                   Buff_Star += Magn_Star/(Dist_Star*Dist_Star); // instead of \"pow\" call...\n               };\n          };\n      };\n      return Buff_Star;\n}\n\nvec4 drawText(in vec2 p,vec4 col)\n{\n     float LineHeight = 0.0;\n     float CurrentPos = 0.0;\n     int   CursorPos  = 0;\n     vec2 Centrage = vec2(-30.0*0.028/2.0,0.0);\n     float Start = mod(14.0*TimeVar,Total_Nb_Char);\n     p += vec2(mod(0.028*14.0*TimeVar,0.028),0.008*sin(20.0*p.x + 15.0*TimeVar) + 0.007);\n     for( float i = Start ; i < Start + 30.0 ; i+=1.0 )\n     {\n          if( TxtB[int(mod(i,Total_Nb_Char))]!=32)\n          {\n              col = mix(col,vec4(0.5,0.0,0.0,1.0),traceChar(p + vec2(0.000,0.150),float(TxtB[int(mod(i,Total_Nb_Char))]), Centrage + vec2(CurrentPos ,0.0 + LineHeight)));\n              col = mix(col,vec4(1.0,1.0,1.0,1.0),traceChar(p + vec2(0.003,0.137),float(TxtB[int(mod(i,Total_Nb_Char))]), Centrage + vec2(CurrentPos ,0.0 + LineHeight)));\n              col = mix(col,        GoldOrSilver1,traceChar(p + vec2(0.000,0.140),float(TxtB[int(mod(i,Total_Nb_Char))]), Centrage + vec2(CurrentPos ,0.0 + LineHeight)));\n          };\n          if( CursorPos > 50 && TxtB[int(mod(i,Total_Nb_Char))]==32){ CurrentPos = 0.0; LineHeight += 0.05; CursorPos = 0; }else{ CursorPos += 1; CurrentPos += 0.028; };\n     };\n     return col;\n}\n\nvec4 drawStarField(in vec2 p,vec4 col)\n{\n     float Disp_Star = 0.000;\n     float Buff_Star = 0.000;\n     float PosX_Star = 0.000;\n     float PosY_Star = 0.000;\n     float PosZ_Star = 0.000;\n     float Dist_Star = 0.000;\n     float Magn_Star = 0.000;\n\n     for( float j = 0.0; j < 15.0 ; j+=1.0 )\n     {\n          PosX_Star  = mod((7.0*noise(vec2(j))-3.5) - Disp_Star,7.0) - 3.5;\n          PosY_Star  = 5.5*noise(vec2(j + 176.0))-2.75;\n          PosZ_Star  = mod(-240.0*TimeVar + 80.0*Smooth1D(vec2(1.38*j)),80.0);\n          float PxEcran = 5.0*PosX_Star/(5.0+PosZ_Star);\n          float PyEcran = 5.0*PosY_Star/(5.0+PosZ_Star);\n          float Dist_Star = length(p-vec2(PxEcran,PyEcran));\n          if( Dist_Star < 0.05 )Buff_Star += pow(300.0*Dist_Star,-1.4);\n     };\n     col += Buff_Star;\n     return col;\n}\n\nvec4 drawPines(in vec2 p, vec4 col, float Change)\n{\n     // Scaling, positioning\n     p *= 0.5;\n     p += vec2(0.0,-0.65);\n\n     // Numbering the current item\n     float Case = floor(p.x + 2.6*TimeVar);\n     if( abs(fract(p.x + 2.6*TimeVar) - 0.5) < 0.4)\n     {\n         // Select threshold 0..1\n         if( Smooth1D(vec2(Case +  Change)) > 0.65)\n         {\n             p.x = fract(p.x + 2.6*TimeVar)-0.5; // For each 1.0*p.x - center\n\n             p*=r2d(-0.25*Smooth1D(vec2(Case*41.5)) + 0.125); // Each Tree has its own tilt\n\n             // Carbon Nanotube Reinforced Trunk\n             col = mix(col,vec4(0.5) - smoothstep(0.05,0.0,abs(p.x)),smoothstep(0.01,0.0,abs(p.y + 0.5) - 0.15)*smoothstep(0.01,0.0,abs(p.x) - 0.05));\n\n             // A pine tree is basically a triangle with irregular sides.\n             // We draw lines for left and right with a bit of noise and a parabola for the bottom.\n             // \"That's all there is to it !\" *Hamster Dance song intensifies*\n             float Left   = smoothstep(0.5,0.0,p.y-2.0*p.x + 0.1*Smooth1D(vec2(20.0*p.y)));\n             float Right  = smoothstep(0.5,0.0,p.y+2.0*p.x + 0.1*Smooth1D(vec2(20.0*p.y)));\n             float Bottom = smoothstep(0.0,0.5,p.y-1.2*p.x*p.x + 0.02*Smooth1D(vec2(20.0*p.y))  + 0.5);\n\n             // Introduce a bit of randomness into p along y for noisy drawing\n             p += vec2(0.0,-0.3 - 0.02*Smooth1D(vec2(10.0*p.x + 102.5*Case)));\n\n             // Preparing to color the pine : base color\n             vec4 Shading01 = vec4(0.1,0.4,0.3,1.0);\n             // adding whitish parabola stripes at various heights to simulate snow\n             Shading01 += vec4(1.0)*smoothstep(0.07,0.0,abs(p.y - p.x*p.x + 0.69) - 0.03);\n             Shading01 += vec4(1.0)*smoothstep(0.07,0.0,abs(p.y - p.x*p.x + 0.52) - 0.03);\n             Shading01 += vec4(1.0)*smoothstep(0.07,0.0,abs(p.y - p.x*p.x + 0.35) - 0.03);\n             Shading01 += vec4(1.0)*smoothstep(0.07,0.0,abs(p.y - p.x*p.x + 0.18) - 0.03);\n             // radial shading\n             Shading01 -= vec4(0.5)*smoothstep(0.0,1.0,sin(3.*atan(p.x/p.y) + 1.5));\n\n             col = mix(col,1.5*Shading01,smoothstep(0.0,0.05,Left*Right*Bottom));\n\n             // Neutralise randomness\n             p -= vec2(0.0,-0.3 - 0.02*Smooth1D(vec2(10.0*p.x + 102.5*Case)));\n\n             // Drawing the star above pine trees...\n             vec4 ColorLight = vec4(1.0);\n             switch( int(mod(Case,7.0)) ) // Star Color Choices\n             {\n                     case 0 : ColorLight = vec4(0.99,0.99,0.00,1.0); break;\n                     case 1 : ColorLight = vec4(0.99,0.99,0.00,1.0); break;\n                     case 2 : ColorLight = vec4(0.99,0.99,0.99,1.0); break;\n                     case 3 : ColorLight = vec4(0.99,0.00,0.99,1.0); break;\n                     case 4 : ColorLight = vec4(0.99,0.00,0.00,1.0); break;\n                     case 5 : ColorLight = vec4(0.00,0.99,0.99,1.0); break;\n                     case 6 : ColorLight = vec4(0.99,0.00,0.00,1.0); break;\n             };\n             // Make some stars rotate, not all of them...\n             float Rota = 0.0;\n             if(mod(Case,2.0)< 1.0)Rota = 4.0*TimeVar;\n             // The star above the pine tree\n             col = mix(col,ColorLight,smoothstep(0.001,0.0,sdStar5(r2d(Rota)*(p + vec2(0.0,-0.4)),0.1,0.5)));\n             // Add some \"shine\" to the star...\n             col += (ColorLight*metaDiamond(r2d(Rota)*(p-vec2(0.0,0.4)),vec2(0.0,0.0),0.04) + vec4(1.0,1.0,0.0,1.0)*metaDiamond(r2d(Rota)*(p-vec2(0.0,0.4)),vec2(0.0,0.0),0.02))\n                    *smoothstep(0.5,0.0,length(p-vec2(0.0,0.4)));\n         };\n     };\n     return col;\n}\n\nvec4 drawBall(in vec2 p, vec4 col,vec4 Color,bool NeedlesShade)\n{\n     // Draw tree balls\n     if( length(p)<0.08 ) // Masking\n     {\n         // Ball\n         vec4 NeedlesShadeColor = vec4(0.0);\n         float VarCut = 1.0;\n         if( NeedlesShade )\n         {\n             NeedlesShadeColor= vec4(1.0)*smoothstep(0.0,0.05,p.y - 0.02*Smooth1D(vec2(50.0*p.x)) + 0.03);\n             VarCut = smoothstep(0.05,0.0,p.y - 0.02*Smooth1D(vec2(50.0*p.x)) + 0.00);\n         }else{\n             col = mix(col,vec4(0.9,0.9,0.9,1.0),sdCircle(p,0.015,vec2(0.0,0.07),0.01));\n         };\n\n         col = mix(col, Color\n         + 0.15*GoldOrSilver1                                         // base colors\n         - 0.9*sdCircle(p,0.14,vec2(0.10,-0.03),0.1)                  // sphere shading\n         -1.0*NeedlesShadeColor                                       // fake shadow from the tree branches\n         + 0.5*texture(iChannel0,1.0*p + vec2(0.05*TimeVar,0.0)).xxxx // some surface detail + fake rotation\n         +0.3*metaDiamond(p + vec2(0.05,-0.03),vec2(0.0,0.0),0.02),   // fake reflective spot\n         sdCircle(p,0.075,vec2(0.0,0.0),0.01)*VarCut);                // VarCut simulates a branche partially hanging over the ball... hence hiding it.\n     };\n     return col;\n}\n\nvec4 drawChristmasTree(in vec2 p, vec4 col, float Change)\n{\n     // This is just the function above, customised...\n\n     // Scaling, positioning\n     p *= 0.50;\n     p += vec2(0.0,-1.2);\n\n     // Make the giant Christmas tree scroll slowly from right to left\n     p+= vec2(mod(0.025*TimeVar + 2.5,10.0) - 5.0,0.0);\n\n     if( abs(p.x)<0.55 && p.y < 1.6 && p.y > -0.6 ) // Masking\n     {\n         // First draw three red balls partially hidden by the tree\n         col = drawBall(0.9*(p + vec2( 0.40,-0.40)),col,vec4(0.5,0.0,0.0,1.0),false);\n         col = drawBall(0.9*(p + vec2(-0.45,-0.20)),col,vec4(0.5,0.0,0.0,1.0),false);\n         col = drawBall(1.2*(p + vec2(-0.23,-0.85)),col,vec4(0.5,0.0,0.0,1.0),false);\n\n         // Carbon Nanotube Reinforced Trunk With Advanced Microstructure for Ultra-High Tensile Strength. (i.e. \"Timeline-1 tech, bitch !\")\n         col = mix(col,vec4(1.0) - smoothstep(0.05,0.0,abs(p.x)),smoothstep(0.01,0.0,abs(p.y + 0.5) - 0.15)*smoothstep(0.01,0.0,abs(p.x) - 0.05));\n\n         // Same as small pine trees, except bigger\n         float Left   = smoothstep(0.75,0.00,p.y - 3.0*p.x     + 0.15*Smooth1D(vec2(20.0*p.y)) - 1.0);\n         float Right  = smoothstep(0.75,0.00,p.y + 3.0*p.x     + 0.15*Smooth1D(vec2(20.0*p.y)) - 1.0);\n         float Bottom = smoothstep(0.00,0.75,p.y - 1.2*p.x*p.x + 0.10*Smooth1D(vec2(20.0*p.y)) + 0.5);\n\n         p += vec2(0.0,-0.3);\n\n         vec4 Shading01 = vec4(0.1,0.4,0.3,1.0) + 0.5*texture(iChannel0,p).xxxx;\n         Shading01 += texture(iChannel0,0.5*p).xxxx*smoothstep(1.0,0.0,sin(20.0*p.y));\n         Shading01 -= vec4(0.75)*smoothstep(0.0,1.0,sin(5.*atan(p.x/(p.y-1.3)) + 1.5));\n         Shading01 -= vec4(0.25)*smoothstep(0.0,1.0,sin(2.5*atan(p.x/(p.y-1.3)) + 1.5));\n\n         col = mix(col,Shading01 + vec4(0.15,0.15,0.3,1.0)*smoothstep(0.0,0.5,p.y - 2.0*p.x + 0.5),smoothstep(0.0,0.05,Left*Right*Bottom));\n\n         p -= vec2(0.0,-0.3);\n\n         // Scrolling Lights\n         p *= r2d((PI/3.0)*sin(TimeVar));\n\n         if( smoothstep(0.0,0.01,Left*Right*Bottom-0.01) > 0.0 ) // if within pine tree\n         {\n             if( mod(floor(10.0*p.y) - 25.0*TimeVar,5.0) < 1.0 )\n             {\n                 col += 1.0/(11.0*length(vec2(fract(10.0*p.x) - 0.5,fract(10.0*p.y) - 0.5)));\n             };\n         };\n\n         p *= r2d(-(PI/3.0)*sin(TimeVar));\n\n         // draw 5 balls in front of the tree\n         col = drawBall(     p + vec2( 0.20, 0.00) , col, vec4(0.5,0.0,0.0,1.0),  true);\n         col = drawBall(0.9*(p + vec2( 0.00,-0.50)), col, vec4(0.0,0.5,0.0,1.0),  true);\n         col = drawBall(0.9*(p + vec2( 0.15,-0.90)), col, vec4(0.7,0.5,0.0,1.0),  true);\n         col = drawBall(     p + vec2(-0.25,-0.20) , col, vec4(0.0,0.5,0.5,1.0),  true);\n         col = drawBall(1.4*(p + vec2( 0.00,-1.30)), col, vec4(0.9,0.0,0.0,1.0), false);\n\n         // Fake 3D rotation of a ball around the tree in 5 easy steps\n         // 1-We quantify rotation :\n         float CoefRot = mod(TimeVar,2.0*PI);\n         // 2-We create a \"visible\" factor :\n         float Viz = 1.0;\n         // 3-If the rotation is in its second half (i.e. behind the tree), account for the tree !\n         if(CoefRot > PI)Viz = smoothstep(0.025,0.0,Left*Right*Bottom);\n         // 4-Draw the ball, if visible, and add a bit of z-scaling to enhance the illusion...\n         if(Viz>0.0)col = drawBall((1.0 - 0.1*sin(CoefRot))*p + vec2( 0.30*cos(TimeVar),-1.2),col,vec4(1.0),false);\n         // 5-Profit ?!\n     };\n\n     // Draw the big star (of Bethlehem !) above the Christmas tree !\n     if( length(p+vec2(0.0,-1.7 - 0.025*sin(TimeVar))) < 0.5)\n     {\n         vec4 ColorLight = vec4(1.0);\n         float Rota = 0.50*TimeVar;\n         // The star\n         col = mix(col,ColorLight,smoothstep(0.025,0.0,sdStar5(r2d(0.25*TimeVar)*(p + vec2(0.0,-1.7 - 0.025*sin(TimeVar))),0.2,0.5)));\n         // The ghost star\n         col += 0.25*(1.1-mod(2.0*TimeVar,1.1))*ColorLight*smoothstep(0.05,0.0,sdStar5(r2d(0.25*TimeVar)*(p + vec2(0.0,-1.7 - 0.025*sin(TimeVar))),0.2*(1.0+mod(2.0*TimeVar,1.1)),0.5));\n     };\n\n     // Add some glow, otherwise James Cameron and Mario are not happy !\n     col += vec4(1.0,0.5,0.0,1.0)*metaDiamond(p+vec2(0.0,-1.7 - 0.025*sin(TimeVar)),vec2(0.0,0.0),0.25+0.125*sin(TimeVar));\n\n     // Add two \"firefly drones\" that check and repair the structure when necessary...\n     // Also give them erratic moves.\n     col += vec4(1.0)*(0.5+0.5*Smooth1D(vec2(TimeVar + 21.59)))*metaDiamond(p+vec2(Smooth1D(vec2(0.35*TimeVar         )) - 0.5,-1.5 + Smooth1D(vec2(0.35*TimeVar + 22.89))-0.5     ),vec2(0.0,0.0),0.02);\n     col += vec4(1.0)*(0.5+0.5*Smooth1D(vec2(TimeVar + 85.72)))*metaDiamond(p+vec2(Smooth1D(vec2(0.35*TimeVar + 189.10)) - 0.5,-1.0*(1.5*Smooth1D(vec2(0.35*TimeVar + 89.10))-0.75)),vec2(0.0,0.0),0.02);\n\n     return col;\n}\n\nvec4 drawWaterfalls(in vec2 p, vec4 col, float Change)\n{\n     // Draw some random waterfalls to add a bit of detail to the Great Ice Barrier of Sentak-105 !\n     float Case = floor(p.x + 0.1666667*TimeVar);\n     if( Smooth1D(vec2(Case)) > 0.75)\n     {\n         p.x = fract(p.x + 0.1666667*TimeVar) - 0.5;\n         col = mix(col,\n                   vec4(0.8,0.9,0.88,1.0) + 0.75*texture(iChannel0,vec2(0.9,0.05)*p + vec2(0.71*Case,0.05*TimeVar)).xxxx,\n                   smoothstep(0.1,0.0,(Smooth1D(vec2(Case)) - 0.4)*abs(p.x))*smoothstep(0.05,0.0,p.y-1.2));\n     };\n     return col;\n}\n\nvec4 drawStar(in vec2 p, vec4 col)\n{\n     // Blue Giant with mandatory halo\n     col = mix(col,vec4(0.5,0.5,1.0,1.0),pow((7.5 + 1.5*sin(TimeVar))*length(p-vec2(-2.0,6.0)),-1.2));\n     // Draw a halo\n     p += vec2(2.0,-6.0);\n     col += vec4(0.5,0.5,1.0,1.0)*clamp(sdCircle(p,0.7,vec2(0.0),0.5) - sdCircle(p,0.5,vec2(0.0),0.1),0.0,1.0)*(0.25 + 0.15*sin(TimeVar));\n     // Draw horizontal bar...\n     col += vec4(0.5,0.5,1.0,1.0)*0.25*smoothstep(1.0,0.0,abs(p.x))*smoothstep(0.025,0.0,abs(p.y));\n     // Draw vertical bar...\n     p *= r2d( PI/2.0);\n     col += vec4(0.5,0.5,1.0,1.0)*0.25*smoothstep(1.0,0.0,abs(p.x))*smoothstep(0.025,0.0,abs(p.y));\n     return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n     vec2 p = vec2( (1.0/iResolution.y)*(fragCoord.x - iResolution.x/2.0),fragCoord.y / iResolution.y);\n\n     // In case of interactivity\n     TiltX = -0.0010*(iMouse.x - iResolution.x/2.0);\n     AltiY = -0.0020*(iMouse.y - iResolution.y    );\n     \n     TimeVar = 1.0*iTime;\n\n     // The world is a joke. And a vec4.\n     vec4 col = vec4(0.0,0.0,0.0,1.0);\n\n     // Switch GoldOrSilver vars every 10 seconds...\n     GoldOrSilver1 = vec4(0.88,0.88,0.88,1.0) + 0.4*vec4(sin(100.0*p.y + 10.0*TimeVar));\n     if(mod(TimeVar,20.0)<10.0)GoldOrSilver1 = vec4(0.99,0.74,0.40,1.0) + 0.4*vec4(sin(100.0*p.y + 10.0*TimeVar));\n     GoldOrSilver2 = vec4(0.88,0.88,0.88,1.0) + 0.4*vec4(sin(20.0*p.y + 2.0*TimeVar));\n     if(mod(TimeVar,20.0)<10.0)GoldOrSilver2 = vec4(0.99,0.74,0.4,1.0) + 0.4*vec4(sin(20.0*p.y + 2.0*TimeVar));\n     p *= r2d(PI/4.0);\n     GoldOrSilver3 = vec4(0.88,0.88,0.88,1.0) + 0.4*vec4(sin(16.0*p.y - 4.0*TimeVar));\n     if(mod(TimeVar,20.0)<10.0)GoldOrSilver3 = vec4(0.99,0.74,0.4,1.0) + 0.4*vec4(sin(16.0*p.y - 4.0*TimeVar));\n     p *= r2d(-PI/4.0);\n\n     vec2 last_p = p;\n\n     // Scaling, positioning\n     p*= 5.0;\n     p.y += -0.1;\n\n     // Zoom in and out gently\n     p*= 1.5 + 0.5*sin(0.25*TimeVar);\n\n     // Draw bluish fixed-position starfield\n     col = vec4(0.5,0.5,1.0,1.0)*drawStars(p);\n\n     // Draw Blue Giant 01\n     col = drawStar(p,col);\n     // Draw Blue Giant 02\n     col = drawStar(vec2(2.0)*(p + vec2(-5.5,-0.5)),col);\n\n     // Just a hint of an atmosphere\n     col += 0.25*vec4(0.0,0.25,0.25,1.0)*smoothstep(0.,0.5,p.y);\n\n     // Draw the galaxy\n     if( length(p) > 2.5 ) // Masking gas giant\n     {\n         // Break right !\n         p *= r2d(-0.7);\n         // Galactic core glow\n         col += 0.8*vec4(0.8, 0.5, 0.3, 1.0)*(1.0- 0.1*texture(iChannel0,0.25*p))*sdCircle(vec2(0.5,1.0)*p,1.50,vec2(0.0,3.0),0.9);\n         // Dark dust clouds\n         if(texture(iChannel0,0.5*p).x>0.75)col -= 0.35*smoothstep(0.5,0.0,abs(p.y-3.0))*smoothstep(0.9,0.0,abs(0.2*p.x));\n         // Bluish galactic halo\n         col += vec4(0.2 , 0.2 , 0.35, 1.0)*smoothstep(2.00,0.0,abs(p.y + 0.5*Smooth1D(vec2(0.5*p.x)) - 3.0) - 0.5);\n         // Galactic core, \"faster, more intensity\"\n         col += vec4(1.0 , 0.6 , 0.0, 1.0)*(1.0 - 0.2*texture(iChannel0,0.25*p))*smoothstep(1.20,0.0,abs(p.y + 0.2*Smooth1D(vec2(0.5*p.x)) - 3.0))*smoothstep(0.5,0.0,abs(0.1*p.x));\n         // Galactic plane, wide\n         col += (vec4(0.8, 0.5, 0.3, 1.0)*texture(iChannel0,0.25*p))*smoothstep(0.8,0.0,abs(p.y + 0.2*Smooth1D(vec2(0.5*p.x)) - 3.0) + 0.3)*smoothstep(0.2,0.0,abs(0.02*p.x));\n         p *= r2d( 0.7);\n     };\n\n     if( length(p) < 2.7) // Masking\n     {\n         p *= r2d(0.8);\n         // Gas Giant Halo\n         col += vec4(0.5)*smoothstep(0.1,0.0,abs(sdCircle(p,2.7,vec2(0.0,0.0),0.9) - 0.1));\n         // Gas Giant\n         col = mix(col,vec4(0.3,0.4,0.5,1.0) + 0.5*texture(iChannel0,vec2(0.05,0.005)*p),clamp(sdCircle(p,2.52,vec2(0.0,0.0),0.01)-0.5*sdCircle(p,2.8,vec2(0.0,-0.5),0.5),0.0,1.0));\n         p*= r2d( PI/2.0);\n         if(length(p)<2.51) col -= vec4(0.15)*smoothstep(0.05,0.0,abs(p.y));\n         p*= r2d(-PI/2.0);\n         p *= r2d(-0.8);\n     };\n\n     p *= r2d( PI/2.0 + 0.8);\n     if(p.y > 0.0 || (p.y<0.0 && length(p)>2.55))col += 0.75*(1.0-0.9*Smooth1D(vec2(20.0*(atan(20.0*p.x/p.y)))))*smoothstep(0.0075,0.0,abs(dis_e(vec2(0.0,0.0),45.0,0.5,p)-0.015));\n     p *= r2d(-PI/2.0 - 0.8);\n\n     // Build a freaking 1km Christmas tree... in 2 days.\n     // Using nanotech and raw materials from an icy moon.\n     // In your face, Pericles !\n     if( iMouse.x < 200.0 )col = drawChristmasTree(p,col,1.0);\n\n     // The Big Ice Barrier...\n     if(abs(p.y - 1.3)>0.0)col = mix(col, vec4(0.5,0.65,0.72,1.0)                                                                    // Base Color\n                                          - 0.40*vec4(1.0,0.9,0.8,1.0)*smoothstep(0.5,0.0,p.y-Smooth1D(vec2(6.0*p.x + 1.0*TimeVar))) // Vertical stripes\n                                          + 0.25*texture(iChannel0,vec2(0.5,0.05)*p + vec2(0.08333333*TimeVar,0.0)).xxxx,            // add a bit detail\n                                          smoothstep(0.01,0.0,p.y +0.05*Smooth1D(vec2(6.0*p.x + TimeVar)) - 1.3));\n\n     // Low mist over the edge...\n     col += vec4(0.70)*smoothstep(0.3,0.0,abs(p.y - 0.05*Smooth1D(vec2(1.5*p.x + 0.25*TimeVar)) - 1.25));\n\n     if( p.y < -0.05*Smooth1D(vec2(6.0*p.x + TimeVar)) + 1.3 )\n     {\n         // Shading the top - White\n         col += vec4(0.5)*smoothstep(0.2,0.0,abs(p.y +0.5*Smooth1D(vec2(18.0*p.x + 3.0*TimeVar)) - 1.55));\n         // Shading the top - Bluish\n         col = mix(col,vec4(0.0,0.9,1.0,1.0),0.25*smoothstep(0.3,0.0,abs(p.y +0.75*Smooth1D(vec2(9.0*p.x + 1.5*TimeVar)) - 1.55)));\n         // Shading the bottom\n         col += vec4(0.25)*smoothstep(0.2,0.0,abs(p.y +0.5*Smooth1D(vec2(18.0*p.x + 3.0*TimeVar)) - 0.6));\n     };\n     // Darkening the base\n     col-= vec4(0.25)*smoothstep(0.25,0.0,abs(p.y-0.5));\n\n     // Draw... the waterfalls !\n     col = drawWaterfalls(p,col,85.0);\n\n     // The icefield\n     if(p.y<0.5)col = vec4(0.5,0.65,0.72,1.0) + 0.2*vec4(texture(iChannel0,vec2( 0.0050*(p.x)/((0.50-p.y))+0.10*TimeVar,0.9*sqrt(0.50-p.y))).xxxx);\n     // Lighting the icefield\n     if(p.y<0.5)col+= vec4(0.2)*smoothstep(0.25,0.0,abs(p.y-0.5));\n\n     // Add some random icebergs...\n     float Icebergs = -0.7 + 1.3*Smooth1D(vec2(1.2*p.x + 0.3*TimeVar + 30.5));\n     col = mix(col, (vec4(0.3,0.45,0.52,1.0)\n                    -0.5*smoothstep(0.9,0.0,Smooth1D(vec2(5.0*p.x + 1.25*TimeVar)))\n                    +0.8*Smooth1D(vec2(2.0*(p.x+0.25*TimeVar))))\n                    +0.2*vec4(texture(iChannel0,p + vec2(0.25*TimeVar,0.0))).xxxx,\n                    smoothstep(0.05,0.0,p.y + Icebergs - 0.1)*smoothstep(0.0,0.05,p.y - 0.45));\n\n     // Add some mist\n     col+= vec4(0.35)*smoothstep(0.075,0.0,abs(p.y-0.5));\n\n     // THE SPACESHIP !\n\n     // Random position changes\n     p += vec2(1.0*sin(0.1*TimeVar),-0.9 + 0.2*sin(0.25*TimeVar));\n\n     // ZOOM !\n     p *= 0.5;\n\n     // Draw the thruster radial glow\n     col += vec4(0.0,0.5,1.0,1.0)*pow((20.0 + 7.0*sin(1.0*TimeVar))*length(p-vec2(-1.36,1.53)),-1.1);\n\n     // Draw the plasma contrail\n     vec2 last_w = p;\n     p.y = abs(p.y - 1.53) ;\n     if(p.x<-1.35 && p.y < 0.05)col += vec4(0.0,0.7,1.0,1.0)*smoothstep(0.025,0.0,abs(p.y + 0.01*sin(5.0*p.x+40.0*TimeVar)));\n     p = last_w;\n\n     float Spot = mod(floor(24.0*TimeVar),8.0);\n     if( length(p-vec2(0.0,1.7))<1.5 && p.y < 1.85 && p.y > 1.3)\n     {\n         // Bottom Half !\n         p.y -= 0.1;\n         float BotInf = smoothstep(0.05,0.0,p.y + 0.1*clamp(sin(5.0*p.x),0.0,0.2) - 0.15*p.x*p.x - 1.2);\n         col = mix(col,vec4(0.2,0.2,0.2,1.0)*smoothstep(0.2,0.0,abs(p.y - 1.35)) + 0.15*texture(iChannel0,vec2(0.001*p.x,0.2*p.y)).xxxx,smoothstep(0.05,0.0,BotInf)*smoothstep(0.01,0.0,p.y - 1.45));\n         p.y += 0.1;\n\n         // Top Half !\n         float ShapeInf = smoothstep(0.050,0.0,p.y - 0.1*clamp(sin(7.0*p.x),0.0,0.2) - 1.5);\n         float ShapeSup = smoothstep(0.050,0.0,p.y - 0.1*clamp(sin(5.0*p.x),0.0,0.2) + 0.1*p.x*p.x - 1.7)\n                         +smoothstep(0.005,0.0,sdTriangle(0.5*(p + vec2(1.2,-1.6)),vec2(0.0 , 0.0 ),vec2(0.15, 0.0 ),vec2(0.05,0.15)))*smoothstep(0.01,0.0,p.y-1.80);\n         col = mix(col,clamp((0.5 + 0.5*smoothstep(0.5,0.0,sqrt(p.y-1.5)) + 0.05*texture(iChannel0,p).xxxx),0.0,1.0),smoothstep(0.0,0.1,ShapeSup-ShapeInf));\n\n         // Super cool tech/scifi chevron lines that you can generate with just sinus and clamp.\n         // MacGyver would be so proud.\n         float Lines01 = smoothstep(0.005,0.0,abs(p.y + 0.2*clamp(sin(4.0*p.x + PI/2.0),0.0,0.2) + 0.05*p.x*p.x - 1.65));\n         col = mix(col,vec4(0.2),smoothstep(0.0,0.05,Lines01*(ShapeSup-ShapeInf)));\n\n         Lines01 = smoothstep(0.01,0.0,abs(p.y + 0.2*clamp(sin(4.0*p.x + PI/2.0),0.0,0.2) + 0.05*p.x*p.x - 1.65));\n         col += vec4(1.0,0.7,0.3,1.0)*smoothstep(0.9,0.0,Smooth1D(vec2(15.0*p.x+20.0 )))*smoothstep(0.0,0.5,Lines01*(ShapeSup-ShapeInf));\n\n         float Lines03 = smoothstep(0.01,0.0,abs(p.y + 1.0*p.x*p.x -2.50));\n         col -= vec4(0.25)*smoothstep(0.0,0.05,Lines03*(ShapeSup-ShapeInf));\n\n         float Lines04 = smoothstep(0.002,0.0,abs(p.y + 0.1*p.x*p.x - 1.74));\n         col -= vec4(0.15)*smoothstep(0.0,0.05,Lines04*(ShapeSup-ShapeInf));\n\n         float Lines02 = smoothstep(0.025,0.0,abs(p.y - 0.1*clamp(sin(7.0*p.x),0.0,0.2) - 1.50));\n         col = mix(col,vec4(0.5),smoothstep(0.0,0.05,Lines02*(ShapeSup-ShapeInf)));\n\n         // Mille Sabords ! (circular laser openings because Timeline-1, while peaceful, is always ready to rock !)\n         float Sabords01 = 0.0;\n         for(float i = 0.0; i < 8.0 ; i+=1.0 )Sabords01 += 0.2*sdCircle(p,0.015,vec2(-0.4 + i*0.05,1.55),0.01);\n\n         // \"Mille millions de mille milliards de mille sabords !\"\n         // Triangular ports for projectiles... The radiological kind.\n         // Also, Timeline-1 has antimatter nuclear warheads, because I TOLD YOU THEY ARE READY !\n         float Sabords02;\n         for( float j = 0.0; j < 5.0 ; j+=1.0 )\n         {\n              Sabords02 += smoothstep(0.005,0.0,sdTriangle(p + vec2(-0.5+0.0  - 0.06*j,-1.55),vec2(0.0,0.0 ),vec2(0.03,0.0 ),vec2(0.015,0.03)));\n              Sabords02 += smoothstep(0.005,0.0,sdTriangle(p + vec2(-0.5+0.03 - 0.06*j,-1.55),vec2(0.0,0.03),vec2(0.03,0.03),vec2(0.015,0.0 )));\n              Sabords02 += smoothstep(0.005,0.0,sdTriangle(p + vec2( 0.8+0.0  - 0.06*j,-1.55),vec2(0.0,0.0 ),vec2(0.03,0.0 ),vec2(0.015,0.03)));\n              Sabords02 += smoothstep(0.005,0.0,sdTriangle(p + vec2( 0.8+0.03 - 0.06*j,-1.55),vec2(0.0,0.03),vec2(0.03,0.03),vec2(0.015,0.0 )));\n         };\n\n         // Ça saborde grave !\n         col -= 0.15*Sabords02;\n         col -= vec4(Sabords01);\n         float Dist_Spot = length(p-vec2(-0.4 + Spot*0.05,1.55));\n         if(Dist_Spot<0.05)col += vec4(1.0,0.5,0.0,1.0)*pow(200.0*Dist_Spot,-1.7);\n         col -= vec4(0.25)*sdCircle(p,0.025,vec2( 1.0,1.56),0.01);\n     };\n\n     // In Timeline-1 they wired JM Jarre's brain to an upgraded Arduino\n     // and now he can drive the spaceship's laser guns ! Hence the psychotic\n     // blinking and rotating frenzy.\n     if( iMouse.x<200.0)\n     {\n         // This is high laser physics taken straight from\n         // Stephen Hawking secret notes, I honestly don't\n         // understand half of what happens here.\n         if( Smooth1D(vec2(floor(TimeVar))) > 0.5 )\n         {\n             // Super advanced effect from 30 years in the future\n             col = drawStarField(p-vec2( 1.0,1.56),col);\n             p -= vec2( 1.0,1.56);\n             p *= r2d(PI*Smooth1D(vec2(10.0*TimeVar)));\n             int LaserColor = int(floor(mod(0.2*TimeVar,5.0)));\n             vec4 LaserTube = vec4(0.0);\n             vec4 LaserCore = vec4(0.0);\n             // Electron lasers can take any color, if you got the right energy source !\n             switch( LaserColor)\n             {\n                     case 0: LaserTube = vec4(0.80,0.80,0.80,1.00); LaserCore = vec4(1.0,1.0,1.0,1.0); break;\n                     case 1: LaserTube = vec4(1.00,0.22,0.00,1.00); LaserCore = vec4(1.0,1.0,0.0,1.0); break;\n                     case 2: LaserTube = vec4(0.00,0.55,1.00,1.00); LaserCore = vec4(0.0,1.0,0.5,1.0); break;\n                     case 3: LaserTube = vec4(1.00,0.00,1.00,1.00); LaserCore = vec4(1.0,1.0,1.0,1.0); break;\n                     case 4: LaserTube = vec4(0.20,0.80,0.20,1.00); LaserCore = vec4(0.0,1.0,0.0,1.0); break;\n             };\n             if(abs(p.y)< 0.5)col += clamp(LaserPower,0.0,1.0)*LaserTube*smoothstep(0.12*length(p),0.0,abs(p.y) + 0.005*Smooth1D(vec2(10.0*p.x) - 150.0*TimeVar));\n             if(abs(p.y)< 0.5)col += clamp(LaserPower,0.0,1.0)*LaserCore*smoothstep(0.03*length(p),0.0,abs(p.y) + 0.005*Smooth1D(vec2(10.0*p.x) - 150.0*TimeVar));\n             p *= r2d(-PI*Smooth1D(vec2(10.0*TimeVar)));\n             col += LaserCore*metaDiamond(p,vec2(0.0),0.01);\n             p += vec2( 1.0,1.56);\n         };\n     };\n     // Even when idle, the laser still outputs a few watts...\n     col += metaDiamond(p,vec2(1.0,1.56),0.01);\n     p *= 2.0;\n\n     p += vec2(0.0, 0.9-0.2*sin(0.25*TimeVar));\n\n     // Spaceship's shadow on the icefield\n     col -= 0.5*sdCircle(p*vec2(0.2,2.0),0.5,vec2(0.0,0.35),0.4);\n\n     p -= vec2(1.0*sin(0.1*TimeVar),0.0);\n\n     // END OF SPACESHIP !\n\n     if( p.y < 0.6 )\n     {\n        // Foreground\n        col = mix(col,\n                  0.65*vec4(0.5,0.65,0.72,1.0) + 0.3*vec4(texture(iChannel0,p + vec2(5.2*TimeVar,0.0)).xxxx)*(1.0-0.7*smoothstep(0.5,0.0,Smooth1D(vec2(p.x + 5.2*TimeVar)))),\n                  smoothstep(0.01,0.0,p.y - 0.25*Smooth1D(vec2(1.0*p.x + 105.7 + 5.2*TimeVar))\n                                          - 0.05*Smooth1D(vec2(20.0*p.x + 105.7 + 104.0*TimeVar)) - 0.1));\n\n        // Foreground snow ribbon (it's really charming, isn't it ?!)\n        col = mix(col,vec4(1.0) + vec4(0.5)*Smooth1D(vec2(p.x  + 105.7 + 5.2*TimeVar)),smoothstep(0.05,0.0,abs(p.y - 0.25*Smooth1D(vec2(1.0*p.x + 105.7 + 5.2*TimeVar)) - 0.10) - 0.2*Smooth1D(vec2(p.x + 5.2*TimeVar))));\n     };\n\n     if( iMouse.x < 200.0 )\n     {\n         // Draw... pines !\n         if(p.y<2.75 && p.y> -0.2)col = drawPines(p + vec2(0.0,0.25),col,0.0);\n\n         // Color fine-tuning...\n         col *= vec4(0.8,.8,0.99,1.0);\n\n         p = last_p;\n\n         if( abs(p.y - 0.82) < 0.07)\n         {\n             // Shadow Text Ribbon\n             col = mix(col,vec4(0.2),0.5*smoothstep(0.005,0.0,abs(p.y-0.81) - 0.05));\n             // Borders Text Ribbon\n             col = mix(col,GoldOrSilver3,smoothstep(0.005,0.0,abs(p.y-0.82) - 0.05));\n             // Red Text Ribbon\n             col = mix(col,vec4(1.0,0.0,0.0,1.0) - vec4(0.5,0.0,0.0,1.0)*Smooth1D(vec2(p.x + 0.5*TimeVar)),smoothstep(0.005,0.0,abs(p.y-0.82) - 0.039));\n         };\n\n         // The text of the postcard !\n         if(p.y>0.70 && p.y<0.90 && abs(p.x) < 0.4 )col = drawText(p + vec2(0.0,0.0),col);\n\n         if( mod(fragCoord.x + 30.0,iResolution.x) < 60.0 || mod(fragCoord.y + 30.0,iResolution.y) < 60.0)\n         {\n             // Big Card Border\n             col = mix( col, GoldOrSilver2,smoothstep(0.001,0.00,abs(sdBox(p + vec2(0.0,-1.0/2.0),vec2(0.5*iResolution.x/iResolution.y - 0.015,0.5*1.0-0.015)))-0.005));\n             // Small Card Border\n             col = mix( col, GoldOrSilver2,smoothstep(0.001,0.00,abs(sdBox(p + vec2(0.0,-1.0/2.0),vec2(0.5*iResolution.x/iResolution.y - 0.025,0.5*1.0-0.025)))-0.001));\n         };\n\n         // Two GoldOrSilver1 Stars\n         p.x = abs(p.x);\n         if( length(p + vec2(-0.40,-0.82)) < 0.125 )\n         {\n             float tmpSign = sign(p.x);\n             col = mix(col,vec4(0.2),0.5*smoothstep(0.005,0.0,sdStar5(r2d(tmpSign*3.0*TimeVar)*(p + vec2(-0.40,-0.795)),0.1,0.5)));\n             col = mix(col,GoldOrSilver1,smoothstep(0.005,0.0,sdStar5(r2d(tmpSign*3.0*TimeVar)*(p + vec2(-0.40,-0.820)),0.1,0.5)));\n             col = mix(col,GoldOrSilver1,smoothstep(0.005,0.0,abs(sdStar5(r2d(tmpSign*3.0*TimeVar)*(p + vec2(-0.40,-0.82)),0.115,0.5))));\n         };\n\n     };\n\n     // HO HO HO !\n     fragColor = clamp(col,0.0,1.0);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define PI 3.14159\n\nfloat TimeVar;\nfloat LaserPower   = 0.4; // Max 1.0 but beams are thinner and sharper like this (imho).\nfloat TiltX;\nfloat AltiY;\nvec4  GoldOrSilver1;\nvec4  GoldOrSilver2;\nvec4  GoldOrSilver3;\nint  TxtB[873] = int[] ( 32, 46, 46, 46, 32, 87, 65, 82, 78, 73, 78, 71, 32, 33, 32, 73, 78, 67, 79, 77, 73, 78, 71, 32, 73, 78, 84, 69, 82, 68, 73, 77, 69, 78, 83, 73, 79, 78, 65, 76, 32, 77, 69, 83, 83, 65, 71, 69, 32, 33, 32, 77, 69, 83, 83, 65, 71, 69, 32, 83, 84, 65, 82, 84, 83, 32, 58, 32, 71, 114, 101, 101, 116, 105, 110, 103, 115, 32, 102, 114, 111, 109, 32, 116, 104, 101, 32, 84, 105, 109, 101, 108, 105, 110, 101, 45, 49, 32, 71, 97, 108, 97, 99, 116, 105, 99, 32, 69, 120, 112, 101, 100, 105, 116, 105, 111, 110, 32, 33, 32, 87, 101, 39, 118, 101, 32, 114, 101, 97, 99, 104, 101, 100, 32, 112, 108, 97, 110, 101, 116, 32, 83, 101, 110, 116, 97, 107, 45, 49, 48, 53, 32, 106, 117, 115, 116, 32, 105, 110, 32, 116, 105, 109, 101, 32, 102, 111, 114, 32, 67, 104, 114, 105, 115, 116, 109, 97, 115, 32, 50, 48, 50, 51, 32, 33, 32, 87, 101, 32, 97, 108, 108, 32, 109, 105, 115, 115, 32, 69, 97, 114, 116, 104, 32, 105, 110, 32, 115, 117, 99, 104, 32, 111, 99, 99, 97, 115, 105, 111, 110, 115, 44, 32, 115, 111, 32, 119, 101, 32, 100, 101, 99, 105, 100, 101, 100, 32, 116, 111, 32, 99, 101, 108, 101, 98, 114, 97, 116, 101, 32, 119, 105, 116, 104, 32, 115, 116, 121, 108, 101, 46, 32, 84, 114, 117, 101, 32, 101, 110, 111, 117, 103, 104, 44, 32, 116, 104, 101, 32, 101, 110, 103, 105, 110, 101, 101, 114, 105, 110, 103, 32, 116, 101, 97, 109, 32, 109, 105, 103, 104, 116, 32, 104, 97, 118, 101, 32, 103, 111, 110, 101, 32, 97, 32, 108, 105, 116, 116, 108, 101, 32, 111, 118, 101, 114, 98, 111, 97, 114, 100, 32, 119, 105, 116, 104, 32, 116, 104, 101, 32, 100, 101, 99, 111, 114, 97, 116, 105, 111, 110, 115, 44, 32, 98, 117, 116, 32, 115, 101, 114, 105, 111, 117, 115, 108, 121, 32, 58, 32, 108, 111, 111, 107, 32, 97, 116, 32, 116, 104, 105, 115, 32, 103, 105, 103, 97, 110, 116, 105, 99, 32, 67, 104, 114, 105, 115, 116, 109, 97, 115, 32, 84, 114, 101, 101, 32, 116, 111, 119, 101, 114, 105, 110, 103, 32, 49, 107, 109, 32, 97, 98, 111, 118, 101, 32, 97, 110, 32, 105, 99, 121, 44, 32, 100, 101, 115, 111, 108, 97, 116, 101, 32, 119, 111, 114, 108, 100, 32, 49, 50, 48, 48, 48, 32, 108, 105, 103, 104, 116, 45, 121, 101, 97, 114, 115, 32, 97, 119, 97, 121, 32, 33, 32, 70, 111, 114, 32, 117, 115, 44, 32, 105, 116, 39, 115, 32, 109, 111, 114, 101, 32, 116, 104, 97, 110, 32, 97, 32, 119, 105, 110, 116, 101, 114, 32, 116, 114, 97, 100, 105, 116, 105, 111, 110, 32, 58, 32, 105, 116, 32, 105, 115, 32, 97, 32, 115, 97, 99, 114, 101, 100, 32, 108, 105, 110, 107, 32, 116, 111, 32, 111, 117, 114, 32, 104, 111, 109, 101, 119, 111, 114, 108, 100, 32, 97, 110, 100, 32, 111, 117, 114, 32, 101, 110, 116, 105, 114, 101, 32, 115, 112, 101, 99, 105, 101, 115, 46, 32, 73, 116, 32, 105, 115, 32, 97, 32, 119, 101, 108, 99, 111, 109, 105, 110, 103, 44, 32, 119, 97, 114, 109, 32, 97, 110, 100, 32, 119, 104, 111, 108, 101, 115, 111, 109, 101, 32, 115, 105, 103, 104, 116, 32, 105, 110, 32, 97, 32, 117, 110, 105, 118, 101, 114, 115, 101, 32, 115, 111, 32, 97, 110, 99, 105, 101, 110, 116, 44, 32, 118, 97, 115, 116, 32, 97, 110, 100, 32, 97, 108, 105, 101, 110, 32, 105, 116, 32, 115, 111, 109, 101, 116, 105, 109, 101, 115, 32, 102, 101, 101, 108, 115, 32, 108, 111, 110, 101, 108, 121, 46, 46, 46, 32, 83, 111, 32, 114, 101, 106, 111, 105, 99, 101, 32, 33, 32, 69, 110, 106, 111, 121, 32, 33, 32, 72, 97, 118, 101, 32, 97, 32, 103, 111, 111, 100, 32, 116, 105, 109, 101, 44, 32, 101, 97, 116, 44, 32, 100, 114, 105, 110, 107, 44, 32, 116, 97, 108, 107, 44, 32, 108, 97, 117, 103, 104, 44, 32, 115, 105, 110, 103, 32, 97, 110, 100, 32, 100, 97, 110, 99, 101, 32, 33, 32, 87, 101, 32, 119, 105, 115, 104, 32, 121, 111, 117, 32, 97, 108, 108, 32, 65, 32, 77, 69, 82, 82, 89, 32, 67, 72, 82, 73, 83, 84, 77, 65, 83, 32, 50, 48, 50, 51, 32, 97, 110, 100, 32, 65, 32, 72, 65, 80, 80, 89, 32, 78, 69, 87, 32, 89, 69, 65, 82, 32, 50, 48, 50, 52, 44, 32, 73, 78, 32, 84, 72, 73, 83, 32, 85, 78, 73, 86, 69, 82, 83, 69, 32, 65, 78, 68, 32, 77, 65, 78, 89, 32, 79, 84, 72, 69, 82, 83, 32, 33 );\nfloat Total_Nb_Char = 873.0;\n\n\nmat2  r2d(    float a ){ float c = cos(a), s = sin(a); return mat2( c, s, -s, c ); }\nfloat noise(  vec2 st ){ return fract( sin( dot( st.xy, vec2(12.9898,78.233)))*43758.5453123 ); }\nfloat dot2( in vec2 v ){ return dot(v,v); }","name":"Common","description":"","type":"common"}]}