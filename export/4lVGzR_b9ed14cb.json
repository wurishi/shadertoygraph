{"ver":"0.1","info":{"id":"4lVGzR","date":"1472810402","viewed":403,"name":"RayRefraction","username":"albertelwin","description":"Light refracting through a glass sphere :)","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["3d","raytracing","refraction"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n#define SUPERSAMPLING 1\n\n#define TAU 6.28318530717958647692\n#define TO_RAD 0.01745329251\n#define GAMMA 2.2\n\n#define EPS 0.001\n#define MAX_DIST 1000.0\n\nvec3 refraction(vec3 rd, vec3 n, float p) {\n\tfloat dot_nd = dot(rd, n);\n    return p * (rd - dot_nd * n) - sqrt(1.0 - (p * p) * (1.0 - dot_nd * dot_nd)) * n;\n}\n\nvec3 texture_linear(samplerCube tex, vec3 tex_coord) {\n\treturn pow(textureLod(tex, vec3(tex_coord.x, -tex_coord.y, tex_coord.z), 0.0).rgb, vec3(GAMMA));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    float fov = 90.0;\n    float tan_fov = tan(fov * 0.5 * TO_RAD);\n    vec2 image_plane = vec2(tan_fov, tan_fov * (iResolution.y / iResolution.x));\n\n#define MAX_SAMPLE_COUNT 8\n    vec2 sample_offsets[MAX_SAMPLE_COUNT];\n\tsample_offsets[0] = vec2(0.125, 0.875);\n    sample_offsets[1] = vec2(0.625, 0.875);\n    sample_offsets[2] = vec2(0.375, 0.625);\n    sample_offsets[3] = vec2(0.875, 0.625);\n    sample_offsets[4] = vec2(0.125, 0.375);\n    sample_offsets[5] = vec2(0.625, 0.375);\n    sample_offsets[6] = vec2(0.375, 0.125);\n    sample_offsets[7] = vec2(0.875, 0.125);\n\n#if SUPERSAMPLING\n    #define SAMPLE_COUNT MAX_SAMPLE_COUNT\n#else\n    #define SAMPLE_COUNT 1\n#endif\n\n    vec3 color = vec3(0.0);\n\n    for(int sample_index = 0; sample_index < SAMPLE_COUNT; sample_index++) {\n        vec2 sample_pos = fragCoord.xy + sample_offsets[sample_index];\n        vec3 image_point = vec3((2.0 * sample_pos / iResolution.xy - 1.0) * image_plane, 2.0);\n\n        vec3 ro = vec3(0.0, 0.0, image_point.z + 1.0);\n        vec3 rd = normalize(image_point - ro);\n        \n        vec3 sp = vec3(sin(iTime), 0.0, 0.0);\n        //vec3 sp = vec3(0.0);\n        float sr = 1.0;\n        float sr2 = sr * sr;\n        \n        vec3 h = sp - ro;\n    \tfloat a = dot(rd, h);\n    \tfloat b2 = dot(h, h) - a * a;\n    \tfloat d = sqrt(sr2 - b2);\n    \tfloat t = a - d;\n    \tif(t > 0.0 && t < MAX_DIST) {\n        \tvec3 p = ro + t * rd;\n            vec3 n = normalize(p - sp);\n\t\t\tvec3 v = ro - p;\n            vec3 r = (2.0 * dot(n, v)) * n - v;\n            \n\t\t\tvec3 ior = vec3(1.4551, 1.4751, 1.4851);\n            vec3 f0 = vec3(0.103085, 0.110537, 0.114313);            \n            \n            vec3 i2_r, i2_g, i2_b;\n            vec3 s;\n            \n            {\n            \tvec3 i = refraction(rd, n, 1.0 / ior.r);\n                s.r = dot(i, n) * -2.0 * sr;\n            \tvec3 p2 = p + s.r * i;\n            \ti2_r = refraction(i, normalize(sp - p2), ior.r);                \n            }\n            \n\t\t\t{\n            \tvec3 i = refraction(rd, n, 1.0 / ior.g);\n                s.g = dot(i, n) * -2.0 * sr;\n            \tvec3 p2 = p + s.g * i;\n            \ti2_g = refraction(i, normalize(sp - p2), ior.g);                \n            }\n            \n            {\n            \tvec3 i = refraction(rd, n, 1.0 / ior.b);\n                s.b = dot(i, n) * -2.0 * sr;\n            \tvec3 p2 = p + s.b * i;\n            \ti2_b = refraction(i, normalize(sp - p2), ior.b);                \n            }\n            \n\n\t\t\tvec3 refr;\n            refr.r = texture_linear(iChannel0, i2_r).r;\n            refr.g = texture_linear(iChannel0, i2_g).g;\n            refr.b = texture_linear(iChannel0, i2_b).b;\n            \n\t\t\tvec3 refl = texture_linear(iChannel0, r); \n\n            //NOTE: Approximate dot(v, h) because we don't have a half vector\n            float dot_nv = clamp(dot(n, v), 0.0, 1.0);            \n            vec3 f = f0 + (vec3(1.0) - f0) * pow(1.0 - dot_nv, 5.0);\n\n            color += (refr * (1.0 - f) + refl * f);\n    \t}\n        else {\n            color += texture_linear(iChannel0, rd);\n        }\n    }\n\n    color *= (1.0 / float(SAMPLE_COUNT));\n    color = pow(color, vec3(1.0 / GAMMA));\n\n    fragColor.xyz = color;\n}","name":"Image","description":"","type":"image"}]}