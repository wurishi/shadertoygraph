{"ver":"0.1","info":{"id":"3lGfWy","date":"1614944252","viewed":161,"name":"Spherify UVs","username":"nebbul","description":"Spherify UVs to render a sphere","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["uv","distort","sphere"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// background grid from https://www.shadertoy.com/view/XtBfzz\n\nconst float N = 2.0; // grid ratio\nfloat gridTexture( in vec2 p )\n{\n    // coordinates\n    vec2 i = step( fract(p), vec2(1.0/N) );\n    //pattern\n    //return (1.0-i.x)*(1.0-i.y);   // grid (N=10)\n    \n    // other possible patterns are these\n    //return 1.0-i.x*i.y;           // squares (N=4)\n    return 1.0-i.x-i.y+2.0*i.x*i.y; // checker (N=2)\n}\n\n// from twitter\n// https://twitter.com/bgolus/status/1233279164947451909\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy/iResolution.yy;\n\n    vec2 uv_dot = ((uv - 0.5) * 2.);\n    \n    uv_dot -= vec2(0.75, 0.);\n    uv_dot *= 1.1;\n    \n    float d = sqrt(1.-clamp(dot(uv_dot, uv_dot), 0., 1.));\n    vec3 normals = vec3(uv_dot, d);\n    \n    // anti aliased mask\n    float mask = smoothstep(0., .05, d);\n    \n    vec2 uv_scale = 1./vec2(3., 3.);\n    vec2 q = (vec2(d, d) + vec2(1.,1.)) * uv_scale;\n    \n    uv_dot /= q;\n    uv_dot = (uv_dot +1.) * 0.5;\n    \n    // background\n    vec4 bg = 0.2 * vec4(1., 1., 1., 1.) * gridTexture(fragCoord.xy/iResolution.xx * vec2(5., 5.)) + 0.6;\n    \n    // foreground mouse\n\tvec2 p = fragCoord / iResolution.x;\n    vec4 m = iMouse / iResolution.x;\n    \n    float mSens = 3.;\n    vec2 mFrom = (p - m.xy) * mSens;\n    vec2 mTo = (p-abs(m.zw)) * mSens;\n    vec2 mAdd = mFrom - mTo;\n    \n    // foreground\n    vec2 fg_uv_final = uv_dot + vec2(iTime * .05, 0.) + mAdd;\n    vec4 fg = texture(iChannel0, fg_uv_final).xxxx;\n    //if (m.z > 0.) uv_dot = floor(uv_dot*4.), fg.r = mod(uv_dot.x + uv_dot.y,2.);\n    \n    // foreground lighting\n    vec3 lightdir = vec3(1, 1, 1.);\n    fg *= (dot(lightdir, normals) + 1.) / 2.;\n    \n    vec4 col = mix(bg, fg, mask);\n\n    // Output to screen\n    fragColor = vec4(col);\n}","name":"Image","description":"","type":"image"}]}