{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"\n/*\n   Different distance estimations from:http://blog.hvidtfeldts.net/index.php/2011/09/distance-estimated-3d-fractals-v-the-mandelbulb-different-de-approximations/\n\n * z = r*(sin(theta)cos(phi) + i cos(theta) + j sin(theta)sin(phi)\n * zn+1 = zn^8 +c\n * z^8 = r^8 * (sin(8*theta)*cos(8*phi) + i cos(8*theta) + j sin(8*theta)*sin(8*theta)\n * zn+1' = 8 * zn^7 * zn' + 1\n\n\n*/\n\nfloat stime, ctime;\nbool is_julia = true;\nvec3 julia = vec3(-0.6,-0.8,0.7);\n\nvec3 gradient;\n\n#define EPS 0.0001\n\nvoid ry(inout vec3 p, float a){  \n    float c,s;vec3 q=p;  \n    c = cos(a); s = sin(a);  \n    p.x = c * q.x + s * q.z;  \n    p.z = -s * q.x + c * q.z; \n}  \n\nvoid rx(inout vec3 p, float a){  \n    float c,s;vec3 q=p;  \n    c = cos(a); s = sin(a);  \n    p.y = c * q.y - s * q.z;  \n    p.z = s * q.y + c * q.z; \n}  \n\nvec3 hash3(float n){\n    return fract(sin(vec3(n,n+1.0,n+2.0))*vec3(43758.5453123, 22578.1459123, 19642.3490423));\n}\n\nfloat hash(vec2 p){\n    float h=dot(p,vec2(127.1, 311.7));\n    return -1.0+2.0*fract(sin(h)*43758.5453123);\n}\n\nfloat noise(vec2 p){\n   vec2 i=floor(p);\n   vec2 f=fract(p);\n   vec2 u=f*f*(3.0-2.0*f);\n   return mix(mix(hash(i+vec2(0.0,0.0)), hash(i+vec2(1.0,0.0)), u.x),\n              mix(hash(i+vec2(0.0,1.0)), hash(i+vec2(1.0,1.0)), u.x),\n              u.y);\n}\n\t\nfloat plane(vec3 p, float y) { return distance(p, vec3(p.x, y, p.z)); }\n\nvec3 bulb_power(vec3 z, float power) {\n    float r = length(z);\n\n    float theta = acos(z.y / r) * power;\n    float phi = atan(z.z, z.x) * power;\n\n    return pow(r, power) * vec3(sin(theta)*cos(phi), cos(theta), sin(theta)*sin(phi));\n}\n\n\n/* method 1: the potential gradient approximation -------------------------------------------*/ \n// use gradient.\nfloat _sinh(float x) {\n    return 0.5 * (exp(x) - exp(-x));\n}\n\nvec3 potential(vec3 p) {\n    vec3 z = p;\n    float power = 8.0;\n    float t0 = 1.0;\n    float r;\n    float iter = 0.0;\n\tvec3 c = p;\n\tif(is_julia)\n\t\tc = julia;\n\tjulia.y = stime;\n\tjulia.x = ctime;\n\n    for(int i = 1; i < 8; ++i) {\n        z = bulb_power(z, power) + c;\n        r = length(z);\n\t\try(z, stime);\n        // orbit trap to mimic ao\n        t0 = min(t0, r);\n\n        if(r > 2.0) {\n            iter = float(i);\n            break;\n        }\n    }\n    return vec3(log(r) / pow(power, iter), t0, 0.0);\n}\n\nvec3 mb_p(vec3 p) {\n    vec3 pt = potential(p);\n    if(pt.x == 0.0) return vec3(0.0);\n    vec3 e=vec3(EPS,0.0,0.0); \n    gradient = (vec3(potential(p+e.xyy).x, \n                potential(p+e.yxy).x, \n                potential(p+e.yyx).x) \n            - pt.x) / e.x; \n    return vec3((0.5 / exp(pt.x)) * _sinh(pt.x) / length(gradient), pt.y, pt.z); /* syntopia method */\n    /*return vec3((0.5 * pt.x) / length(gradient), pt.y, pt.z);*/  /* quilez method */\n}\n/* the potential gradient approximation -------------------------------------------*/ \n\n\n\n\n/* method 2: the scalar distance estimator------------------------------------------------*/\n/* the normal is calculated by central difference */\nvec3 mb_s(vec3 p) {\n    /*p.xyz=p.xzy;*/\n    vec3 z = p;\n    float power = 8.0;\n    float r, theta, phi;\n    float dr = 1.0;\n\tvec3 c = p;\n\tif(is_julia)\n\t\tc = julia;\n    float t0 = 1.0;\n\tjulia.y = stime;\n\tjulia.x = ctime;\n\tjulia.z = 0.5*cos(stime);\n\n    for(int i = 0; i < 7; ++i) {\n        r = length(z);\n        if(r > 2.0) continue;\n\n        dr = pow(r, power - 1.0) * dr * power + 1.0; \n\n        theta = acos(z.y / r) * power;\n        phi = atan(z.z, z.x) * power;\n        r = pow(r, power);\n        z = r * vec3(sin(theta)*cos(phi), cos(theta), sin(theta)*sin(phi)) + c;\n        ry(z, stime);\n\n        // the Positive-z variation\n        /*theta = atan(z.y, z.x) * power;*/\n        /*phi = asin(z.z/ r) * power;*/\n        /*r = pow(r, power);*/\n        /*z = r * vec3(cos(theta)*cos(phi), sin(theta)*cos(phi), sin(phi)) + p;*/\n        t0 = min(t0, length(z));\n    }\n    return vec3(0.5 * log(r) * r / dr, t0, 0.0);\n}\n/* the scalar distance estimator------------------------------------------------*/\n\n\n\n\n/* method 3: the escape length approximation -------------------------------------------*/ \n/* reffered to as Makin/Buddhi 4-point Delta-DE formula */\nint last = 0; // global to ensure evaluating the escape length at the same iteration each time\nvec3 escape_length(vec3 p) {\n    vec3 z = p;\n    float power = 8.0, r;\n    float t0 = 1.0;\n\tvec3 c = p;\n\tif(is_julia)\n\t\tc = julia;\n\n    for(int i = 1; i < 8; ++i) {\n        z = bulb_power(z, power) + c;\n        r = length(z);\n        t0 = min(t0, r);\n        \n        if ((r > 2.0 && last == 0) || (i == last))\n        {\n            last = i;\n            return vec3(r, t0, 0.0);\n        }\n    }\n    return vec3(length(z), 0.0, 0.0);\n}\n\nvec3 mb_e(vec3 p) {\n    last = 0;\n    vec3 el = escape_length(p);\n    if(el.x * el.x < 2.0) return vec3(0.0);\n    vec3 e=vec3(EPS,0.0,0.0); \n    gradient = (vec3(escape_length(p+e.xyy).x, escape_length(p+e.yxy).x, escape_length(p+e.yyx).x) - el.x) / e.x; \n    return vec3(0.5 * el.x * log(el.x) / length(gradient), el.y, el.z); \n}\n/* the escape length approximation -------------------------------------------*/ \n\n\nvec3 f(vec3 p){ \n    vec2 uv=p.xz*1.0;\n\tfloat noi = noise(uv);\n\tnoi = 0.5 + 0.5 * noi;\n  \n   float a=plane(vec3(p.x, p.y + noi * 0.2, p.z), -0.71);\n\t\n\t\n\t//ry(p, stime * 0.5);\n\tp.yz = p.zy;\n    \n\t//p.x = mod(p.x, 3.0) - 1.5;\n\tp.y = mod(p.y, 2.0) - 1.0;\n\t//p.xz = mod(p.xz, 8.0) - 4.0;\n\t\n\t//p.yz = -p.zy;\n    vec3 b = mb_s(p);\n\tvec3 res = vec3(a, 0.8, 1.0);\n\tif(a > b.x)\n\t\tres = b;\n\treturn res;\n\n}\n\n\nfloat softshadow(vec3 ro, vec3 rd, float k ){ \n    float akuma=1.0,h=0.0; \n    float t = 0.01;\n    for(int i=0; i < 32; ++i){ \n        h=f(ro+rd*t).x; \n        if(h<0.001)return 0.02; \n        akuma=min(akuma, k*h/t); \n        t+=clamp(h,0.01,2.0); \n    } \n    return akuma; \n} \nvec3 nor(vec3 p){ \n    vec3 e=vec3(EPS,0.0,0.0); \n    return normalize(vec3(f(p+e.xyy).x-f(p-e.xyy).x, \n                f(p+e.yxy).x-f(p-e.yxy).x, \n                f(p+e.yyx).x-f(p-e.yyx).x)); \n} \n\n\nvec3 intersect( in vec3 ro, in vec3 rd )\n{\n    float t = 0.0;\n    vec3 res = vec3(-1.0);\n    vec3 h = vec3(1.0);\n    for( int i=0; i<196; i++ )\n    {\n\t\t// To avoid compiler bug\n        if( h.x<0.0006 || t>20.0 ) {\n           \n        }\n\t\telse{\n        \th = f(ro + rd*t);\n        \tres = vec3(t,h.yz);\n        \tt += h.x;  // marching\n\t\t}\n    }\n    if( t>20.0 ) res=vec3(-1.0);\n    return res;\n}\n\nvec3 lighting(in vec3 p, in vec3 n, in vec3 rd, in float ao) {\n\tvec3 l1_pos = normalize(vec3(0.0, 0.8, 1.8)) * 11.0;\n\tvec3 l1_dir = normalize(l1_pos - p);\n    vec3 l1_col = vec3(1.37, 0.99, 0.79);\n\t\n    vec3 l2_dir = normalize(vec3(0.0, -0.8, -1.8));\n    vec3 l2_col = vec3(1.19, 0.99, 1.0); \n    \n    float shadow = softshadow(p, l1_dir, 10.0 );\n\n    float dif1 = max(0.0, dot(n, l1_col));\n    float dif2 = max(0.0, dot(n, l2_col));\n    float bac1 = max(0.3 + 0.7 * dot(vec3(-l1_dir.x, -1.0, -l1_dir.z), n), 0.0);\n    float bac2 = max(0.2 + 0.8 * dot(vec3(-l2_dir.x, -1.0, -l2_dir.z), n), 0.0);\n    float spe = max(0.0, pow(clamp(dot(l1_dir, reflect(rd, n)), 0.0, 1.0), 10.0)); \n\n    vec3 col = 2.3 * l1_col * dif1 * shadow;\n    col += 1.4 * l2_col * dif2 * ao;\n    col += 0.7 * bac1 * l1_col * ao;\n    col += 0.7 * bac2 * l2_col * ao; \n    col += 6.0 * spe * vec3(1.0, 0.84313, 0.0); \n    \n\tao = pow(clamp(ao, 0.0, 1.0), 2.55);\n\tvec3 tc0 = 0.5 + 0.5 * sin(3.0 + 3.7 * ao + vec3(1.4, 0.0, 0.0));\n\tvec3 tc1 = 0.5 + 0.5 * sin(3.0 + 3.9 * ao + vec3(1.0, 0.84313, 0.0));\n\tcol *= 0.2 * tc0 * tc1;\n\t\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) \n{ \n    vec2 q=fragCoord.xy/iResolution.xy; \n    vec2 uv = -1.0 + 2.0*q; \n    uv.x*=iResolution.x/iResolution.y; \n    // camera\n    stime=sin(iTime*0.2); \n    ctime=cos(iTime*0.2); \n\n    vec3 ta=vec3(0.0,0.3-0.3*ctime,-4.0); \n\t//vec3 ta = vec3(0.0);\n    vec3 ro = vec3(5.0 * stime, 2.0, 1.0 * ctime);\n\n    vec3 cf = normalize(ta-ro); \n    vec3 cs = normalize(cross(cf,vec3(0.0,1.0,0.0))); \n    vec3 cu = normalize(cross(cs,cf)); \n    vec3 rd = normalize(uv.x*cs + uv.y*cu + 7.8*cf);  // transform from view to world\n\n    vec3 bg = vec3(0.0, 0.0, 0.0);\n\n    float halo=clamp(dot(normalize(vec3(-ro.x, -ro.y, -ro.z)), rd), 0.0, 1.0); \n    vec3 col=bg+vec3(0.3, 0.0, 0.0) * pow(halo,9.0); \n\n\n    float t=0.0;\n    vec3 p=ro; \n    float normal_back_step = 1.0;\n\n\n    vec3 res = intersect(ro, rd);\n\tfloat ao = res.y;\n\t\n    if(res.x > 0.5){\n        p = ro + res.x * rd;\n        vec3 n=nor(p);   // for mb_s\n\t\t//vec3 n = normalize(gradient);  // for mb_p and mb_e\n       \tcol = lighting(p, n, rd, ao);\n        col=mix(col,bg, 1.0-exp(-0.01*res.x*res.x)); \n    }\n\n    // post\n    col=pow(clamp(col,0.0,1.0),vec3(0.45)); \n    col=col*0.6+0.4*col*col*(3.0-2.0*col);  // contrast\n    col=mix(col, vec3(dot(col, vec3(0.33))), -0.5);  // satuation\n    col*=0.5+0.5*pow(16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.7);  // vigneting\n    fragColor=vec4(col.x,col.y,col.z,1.0); \n}\n","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"MdsSzj","date":"1404655812","viewed":626,"name":"mandelbulbs","username":"EvilRyu","description":"http://blog.hvidtfeldts.net/index.php/2011/09/distance-estimated-3d-fractals-v-the-mandelbulb-different-de-approximations/","likes":14,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","fractal"],"hasliked":0,"parentid":"","parentname":""}}