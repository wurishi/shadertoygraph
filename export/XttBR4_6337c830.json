{"ver":"0.1","info":{"id":"XttBR4","date":"1538786357","viewed":105,"name":"Nature-Entangling of Flower Buds","username":"rlarp","description":"Attempt to create the effect of (basic) flower buds getting entangled","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["education","organic","nature","school","flowers","buds","entangled","entangling"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define repeat(v, r) (mod(v, r)-r/2.)\n\nstruct Shape{ // Basic constructor for shape \n  float dist; // Distance from center\n  vec4 color; // Color of shape \n};\n\n\n    \n//=======================\n// Utility Functions\n//=======================\nfloat random(vec3 v) { // Utility function that utilizes the fract() function to create recurring patterns.\n  return fract(tan(dot(v*100.1, vec3(400.654, 160.546, 100.)))*46.2);\n}\n\nmat2 rot(float a){ // Rotates and gives the rotated matrix \n  float r = cos(a);\n  float f = sin(a);\n  return mat2(-r, -f, f, -r);\n}\n\nfloat sphere(vec3 v, float r){ // Creates a sphere \n  return length(v)-r;\n}\n\n\nfloat pole(vec2 v, float r){ // Creates a pole \n  return length(v)-r;\n}\n\nfloat mixColors(float r, float v, float z){ \n  return clamp(0.5+0.5*(v-r)/z, 0., 1.);\n}\n\n\nfloat mixShapes(float v, float f, float r){ // Mixes both the color and the shape of objects.\t\n  float z = mixColors(v, f, r);\n  return mix(f,v,z)-r*z*(1.-z);\n}\n\nfloat pModPolar(inout vec2 v, float r){\n  float f = 6.28318/r;\n  float z = atan(v.y, v.x)+f*0.5;\n  float m = floor(z/f);\n  z = mod(z, f)-f*0.5;\n  v = vec2(cos(z), sin(z))*length(v);\n  return m;\n}\n//=======================\n\nShape vines(vec3 c){ // Creates a vine shape (kind of an extension of Shape\n  Shape shape; // Creates basic Shape first\n  float vine;\n  shape.dist = 100.; // Draw Distance\n  shape.color = vec4(3.); // Initial Color\n\n  // Shape Attributes\n  float twist = 5.; // Vine Repeat\n  float vineOffset = 5.; // Leaf Offset\n\n\n  // Stems\n    random(c);// Passes vec3 c through the random function first\n  \tvec3 i = c;\n    i.xz *= rot(c.y*0.2+iTime*0.2); // Rotates the vines about the xz system.\n    float detail = pModPolar(i.xz, twist); \n    float x = mix(5., 5.1, mod(detail, 1.)); // Small Ripples\n    i.x -= vineOffset; // Offset Stems\n  \tfloat stemWidth = .15;\n    //stemWidth/= 10000000.;\n  \tvine = pole(i.xz, stemWidth+0.02*sin(i.y*x));\n\n\n  vec4 color = vec4(0.4, 1.0, 0.4, 10.); // Initialize vine color\n\n  shape.dist = vine;\n  shape.color = color;\n\n  return shape; \n}\n\nShape orb(vec3 c){\n  Shape shape;\n  float orb;\n  shape.dist = 1000.; // Draw Distance\n  shape.color = vec4(1.); // Initial Color\n\n  // Stems\n  vec3 i = c;\n    //i.xz *= rot(iTime);\n    i.y = repeat(i.y, 2.5); // Repeats the orbs in they y direction every 2.5 pixels.\n    i.y = abs(i.y)-2.5;\n    i.x = abs(i.x)-1.5;\n    orb = sphere(i, cos(sin(iTime)*0.25)*2.25);\n    \n\n  vec4 color = vec4(0.8, 1., 0.8, 1.); // Initializes color\n\n  shape.dist = orb;\n  shape.color = color;\n\n  return shape;\n}\n\n \nShape map(vec3 c, vec3 c1){\n  Shape vines = vines(c); // Create vines\n  Shape orbs = orb(c); // Create orbs\n \n  float df = mixShapes(vines.dist, orbs.dist, 1.); // Mix vines and orbs\n  vines.dist = df;\n    \n  vines.color = mix(vines.color, \n                    orbs.color*0.8, \n                    mixColors(orbs.dist*=0.9, vines.dist, 0.0)); // Mixes the colors \n\treturn vines; // Returns everything as one \n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 v = (fragCoord.xy-0.5 * iResolution.xy) / iResolution.y; // Normalize \n  \n  \n  vec3 cam = vec3(0., sin(iTime)-3.5, -10.); // Dictates where the camera is/will move. \n  random(cam+0.5);\n  vec3 f = normalize(vec3(v, .9));\n  random(f);\n  vec3 scene = cam;\n  random(scene);\n  vec3 scene1 = cam *= 5.; \n  fragColor = vec4(0.2);\n\n  // Ray Marcher\n  for(float z = 0.001 ; z <= 10.; z += 0.1){\n    Shape c = map(scene, scene1); // Calc SDF\n    if(c.dist < 0.4){\n      fragColor = c.color*(1.-z); // Hit  - invert pixels\n      break;\n    }\n    scene += f * c.dist;\n\t\n\n  }\n}\n\n","name":"Image","description":"","type":"image"}]}