{"ver":"0.1","info":{"id":"7sc3Rn","date":"1628970558","viewed":86,"name":"[Letters]","username":"Langwedocjusz","description":"I did this in one sitting, trying to write as fast as I could, so don't expect clean code ","likes":1,"published":1,"flags":32,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define USE_BOKEH\n\n#ifdef USE_BOKEH\n\n#define GOLDEN_ANGLE 2.39996\n#define ITERATIONS 100\n#define MAX_BLUR 0.05\n\nmat2 rot = mat2(cos(GOLDEN_ANGLE), sin(GOLDEN_ANGLE), -sin(GOLDEN_ANGLE), cos(GOLDEN_ANGLE));\n\n//Single pass bokeh, pinched from https://www.shadertoy.com/view/Wt23Ww\nvec3 Bokeh(sampler2D tex, vec2 uv, float radius, float aspect)\n{\n\tvec3 acc = vec3(0), div = acc;\n    float r = 1.;\n    vec2 vangle = vec2(0.0,radius*.05 / sqrt(float(ITERATIONS)));\n    float l = length(vangle);\n    \n\tfor (int j = 0; j < ITERATIONS; j++)\n    {  \n        r += 1. / r;\n\t    vangle = rot * vangle;\n        \n        //The only thing I added is aspect ratio correction here:\n        vec2 coords = uv + (r-1.) * vangle;\n        coords.y *= aspect;\n        vec3 col = texture(tex, coords).xyz;\n\t\tvec3 bokeh = pow(col, vec3(5.));\n\t\tacc += col * bokeh;\n\t\tdiv += bokeh;\n\t}\n\treturn acc / div;\n}\n\n\n#endif\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    #ifdef USE_BOKEH\n    vec2 uv = fragCoord.xy / iResolution.x;\n    vec2 uv2 = fragCoord.xy/iResolution.xy;\n    \n    float mask = saturate(1.0 - 25.0 * texture(iChannel1, uv2).r);\n    \n    fragColor = vec4(Bokeh(iChannel0, uv, MAX_BLUR*mask, iResolution.x / iResolution.y), 1.0);\n    //fragColor = vec4(vec3(mask), 1.0);\n    \n    #else\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 color = texture(iChannel0, uv).rgb;\n    fragColor = vec4(color, 1.0);\n    #endif\n    \n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"float saturate(float x) {return clamp(x, 0.0, 1.0);}\n\nmat3 rotationX(float theta){\n    return mat3(1.0, 0.0,         0.0,\n                0.0, cos(theta), -sin(theta),\n                0.0, sin(theta),  cos(theta));\n}\n\nmat3 rotationY(float theta){\n    return mat3(cos(theta), 0.0, -sin(theta),\n                0.0,        1.0,  0.0,\n                sin(theta), 0.0,  cos(theta));\n}\n\nfloat hash(float x){\n    return fract(sin(x) * 43758.5453123);\n}\n\nfloat hash(vec2 p ){\n\tfloat h = dot(p,vec2(127.1,311.7));\n\n    return -1.0 + 2.0*fract(sin(h)*43758.5453123);\n}\n\nfloat noise(vec2 p) {\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n\tvec2 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( hash( i + vec2(0.0,0.0) ), \n                     hash( i + vec2(1.0,0.0) ), u.x),\n                mix( hash( i + vec2(0.0,1.0) ), \n                     hash( i + vec2(1.0,1.0) ), u.x), u.y);\n}\n\n","name":"Common","description":"","type":"common"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define MAX_MARCH_STEPS 128\n#define MAX_MARCH_DIST 100.0\n#define MIN_MARCH_DIST 0.001\n\n\nfloat sdfBox( vec3 point, vec3 box_dims ){\n  vec3 q = abs(point) - box_dims;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdfTriPrism(vec3 point, float size){\n  vec2 h = size*vec2(1.0, 0.01);\n  vec3 q = abs(point);\n  q.x *= 0.5;\n  return max(q.z-h.y,max(q.x*0.866025+point.y*0.5,-point.y)-h.x*0.5);\n}\n\nfloat sdfCylinder( vec3 p, float h, float r )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdfEnvelope(vec3 point, float size){\n    vec3 mirror = vec3(1.0, -1.0, 1.0);\n    vec3 translation = vec3(0.0, -1.0, 0.03);\n    vec3 box_translation = vec3(0.0, 0.51, -0.03);\n    vec3 box_dims = size*vec3(1.79, 1.02, 0.01);\n    \n    return min(sdfBox(point - box_translation, box_dims),\n           min(sdfTriPrism(point, size), sdfTriPrism((mirror*point)-translation, size))) \n           - 0.02;\n}\n\nfloat sdfBentEnvelope(vec3 point){\n    return sdfEnvelope(point, 1.0 + 0.01*sin(4.0*point.x) + 0.01*sin(3.0*point.y));\n}\n\nfloat sdfCyl(vec3 point){\n    vec3 q = point*rotationX(3.14259265 / 2.0);\n    float radius = 0.3 + 0.005*sin(25.0*point.y) + 0.005*sin(25.0*point.x); \n    float height = 0.01;\n    return sdfCylinder(q, radius, height) - 0.05;\n}\n\nfloat sdfSeal(vec3 point){\n    vec3 translation = vec3(0.0, 0.0, 0.035);\n    return sdfCyl(point - translation);\n}\n\n\nfloat sdfEnvelopes(vec3 point){\n    vec3 l = vec3(10.0);\n    float c = 10.0;\n    vec3 q = point - c*clamp(round(point/c), -l, l);\n    return sdfBentEnvelope(q);\n}\n\nfloat sdfSeals(vec3 point){\n    vec3 l = vec3(10.0);\n    float c = 10.0;\n    vec3 q = point - c*clamp(round(point/c), -l, l);\n    return sdfSeal(q);\n}\n\nfloat Map(vec3 point){\n    vec3 q = point*rotationY(3274.58/2.0);\n    \n    float dEnvelope = sdfEnvelopes(q);\n    float dSeal = sdfSeals(q);\n    \n    return min(dEnvelope, dSeal);\n}\n\n#define MAT_DEFAULT 0\n#define MAT_ENVELOPE 1\n#define MAT_SEAL 2\n\nint MapMaterial(vec3 point){\n    vec3 q = point*rotationY(3274.58/2.0);\n    \n    float dEnvelope = sdfEnvelopes(q);\n    float dSeal = sdfSeals(q);\n    \n    float dist = min(dEnvelope, dSeal);\n    \n    if( dist==dEnvelope) {\n        return MAT_ENVELOPE;\n    }\n    \n    else if (dist==dSeal){\n        return MAT_SEAL;\n    }\n    \n    else {\n        return MAT_DEFAULT;\n    }\n}\n\nfloat March(vec3 origin, vec3 direction, float orientation){\n    float total_dist = 0.0;\n    float current_dist;\n    for (int i=0; i<MAX_MARCH_STEPS; i++){\n        //Orientation = 1 when outside, -1 when inside\n        current_dist = Map(origin + total_dist * direction) * orientation;\n        if (current_dist < MIN_MARCH_DIST){\n            return total_dist;\n        }\n        total_dist += current_dist;\n        if (total_dist >= MAX_MARCH_DIST){\n            return MAX_MARCH_DIST;\n        }\n        \n    }\n    return total_dist;\n}\n\nvec3 GetNormal(vec3 point ){\n    //Tetrahedron technique:\n    //https://iquilezles.org/articles/normalsSDF\n    const float h = 0.0001;\n    const vec2 k = vec2(1,-1);\n    return normalize( k.xyy*Map( point + k.xyy*h ) + \n                      k.yyx*Map( point + k.yyx*h ) + \n                      k.yxy*Map( point + k.yxy*h ) + \n                      k.xxx*Map( point + k.xxx*h ) );\n}\n\nvec3 Shade(vec3 point, vec3 ray, vec3 normal, vec3 origin){\n    vec3 sun_dir = normalize(vec3(-1.0, 1.0, -1.0));\n    vec3 sun_color = vec3(1.0, 1.0, 0.66);\n    vec3 sky_color = vec3(0.75, 0.75, 1.0);\n    return (0.65*saturate(dot(sun_dir, normal))) * sun_color \n           + 0.2 * sky_color\n           + pow(saturate(dot(normal, normalize(sun_dir+origin))), 16.0);\n}\n\nvec3 getMaterial(vec3 point){\n    int id = MapMaterial(point);\n    \n    switch(id){\n    \n    case MAT_DEFAULT:\n        return vec3(1.0);\n    case MAT_ENVELOPE:\n        float noise = 0.06*sin(noise(vec2(12.5*point.x, 100.0*point.y)));\n        float color = saturate(1.0 + noise);\n        return vec3(color);\n    case MAT_SEAL:\n        return vec3(0.8, 0.1, 0.1);\n    }\n}\n\n//Naive classical AO, lifted from here:\n//http://www.aduprat.com/portfolio/?page=articles/hemisphericalSDFAO\nfloat AmbientOcclusion(vec3 point, vec3 normal)\n{\n    float AO = 0.0, maxDist = 0.05, falloff=0.66;\n    const int nbIte = 24;\n    for( int i=0; i<nbIte; i++ )\n    {\n        float l = hash(float(i))*maxDist;\n        vec3 rd = normal*l;\n\n        AO += (l - max(Map( point + rd ),0.)) / maxDist * falloff;\n    }\n\n    return clamp( 1.0 - AO/float(nbIte), 0.0, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    //Normalize coordinates to (-1;1):\n    uv = 2.0 * uv - 1.0;\n    //Aspect ratio correction:\n    uv.x *= iResolution.x / iResolution.y;\n    \n    //Background color:\n    vec3 col = (1.0 - uv.y) * vec3(0.0, 0.3, 1.0) + uv.y * vec3(0.0, 0.1, 1.0);;\n    \n    //Raymarching:\n    vec3 ray = normalize(vec3(uv, 1.0));\n    vec3 origin = vec3(0.0, 0.0, -3.0);\n    \n    float dist = March(origin, ray, 1.0);\n    vec3 point = origin + dist * ray;\n    vec3 normal = GetNormal(point);\n    \n    float AO = AmbientOcclusion(point, normal);\n    AO *= AO;\n    \n    if (dist < MAX_MARCH_DIST) {\n        col = AO * Shade(point, ray, normal, origin) * getMaterial(point);\n        //col = AO * vec3(1.0);\n    }\n    \n    #define GAMMA 2.2\n    #define EXPOSURE 1.66\n    \n    //Exposure tone mapping\n    col = vec3(1.0) - exp(-col * EXPOSURE);\n    //Gamma correction\n    col = pow(col, vec3(1.0 / GAMMA));\n    //Hack to retrieve some saturation lost with tone mapping\n    col = pow(col, vec3(1.5));\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[{"id":"XsXGR8","channel":0}],"code":"#define MAX_MARCH_STEPS 128\n#define MAX_MARCH_DIST 100.0\n#define MIN_MARCH_DIST 0.001\n\n\nfloat sdfBox( vec3 point, vec3 box_dims ){\n  vec3 q = abs(point) - box_dims;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdfTriPrism(vec3 point, float size){\n  vec2 h = size*vec2(1.0, 0.01);\n  vec3 q = abs(point);\n  q.x *= 0.5;\n  return max(q.z-h.y,max(q.x*0.866025+point.y*0.5,-point.y)-h.x*0.5);\n}\n\nfloat sdfCylinder( vec3 p, float h, float r )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdfEnvelope(vec3 point, float size){\n    vec3 mirror = vec3(1.0, -1.0, 1.0);\n    vec3 translation = vec3(0.0, -1.0, 0.03);\n    vec3 box_translation = vec3(0.0, 0.51, -0.03);\n    vec3 box_dims = size*vec3(1.79, 1.02, 0.01);\n    \n    return min(sdfBox(point - box_translation, box_dims),\n           min(sdfTriPrism(point, size), sdfTriPrism((mirror*point)-translation, size))) \n           - 0.02;\n}\n\nfloat sdfBentEnvelope(vec3 point){\n    return sdfEnvelope(point, 1.0 + 0.01*sin(4.0*point.x) + 0.01*sin(3.0*point.y));\n}\n\nfloat sdfCyl(vec3 point){\n    vec3 q = point*rotationX(3.14259265 / 2.0);\n    float radius = 0.3 + 0.005*sin(25.0*point.y) + 0.005*sin(25.0*point.x); \n    float height = 0.01;\n    return sdfCylinder(q, radius, height) - 0.05;\n}\n\nfloat sdfSeal(vec3 point){\n    vec3 translation = vec3(0.0, 0.0, 0.035);\n    return sdfCyl(point - translation);\n}\n\n\nfloat sdfEnvelopes(vec3 point){\n    vec3 l = vec3(10.0);\n    float c = 10.0;\n    vec3 q = point - c*clamp(round(point/c), -l, l);\n    return sdfBentEnvelope(q);\n}\n\nfloat sdfSeals(vec3 point){\n    vec3 l = vec3(10.0);\n    float c = 10.0;\n    vec3 q = point - c*clamp(round(point/c), -l, l);\n    return sdfSeal(q);\n}\n\nfloat Map(vec3 point){\n    vec3 q = point*rotationY(3274.58/2.0);\n    \n    float dEnvelope = sdfEnvelopes(q);\n    float dSeal = sdfSeals(q);\n    \n    return min(dEnvelope, dSeal);\n}\n\nfloat March(vec3 origin, vec3 direction, float orientation){\n    float total_dist = 0.0;\n    float current_dist;\n    for (int i=0; i<MAX_MARCH_STEPS; i++){\n        //Orientation = 1 when outside, -1 when inside\n        current_dist = Map(origin + total_dist * direction) * orientation;\n        if (current_dist < MIN_MARCH_DIST){\n            return total_dist;\n        }\n        total_dist += current_dist;\n        if (total_dist >= MAX_MARCH_DIST){\n            return MAX_MARCH_DIST;\n        }\n        \n    }\n    return total_dist;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    //Normalize coordinates to (-1;1):\n    uv = 2.0 * uv - 1.0;\n    //Aspect ratio correction:\n    uv.x *= iResolution.x / iResolution.y;\n    \n    //Raymarching:\n    vec3 ray = normalize(vec3(uv, 1.0));\n    vec3 origin = vec3(0.0, 0.0, -3.0);\n    \n    float dist = March(origin, ray, 1.0);\n    float lorentz = 5.0 / (1.0 + dist * dist * 0.1);\n    \n    vec3 col = lorentz * vec3(1.0);\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n\n","name":"Buffer B","description":"","type":"buffer"}]}