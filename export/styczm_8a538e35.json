{"ver":"0.1","info":{"id":"styczm","date":"1663341962","viewed":620,"name":"Conformal Group limit set 3D","username":"flo72","description":"I tried to make a 3D Version of the Shader https://www.shadertoy.com/view/MtKXRh of Jos Leys. \nIncreasing the ITER_STEPS leads to a more complete calculation of the fractal but of course slows down the speed.","likes":10,"published":1,"flags":0,"usePreview":0,"tags":["fractal","kleinian"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS 600\n#define MAX_DIST 30.\n#define SURF_DIST .0002\n\n\n#define ITER_STEPS 60 \n\nvec4 orb;\nfloat colorind; \n\n  float sdSphere(vec3 p, vec4 mr){\n      return length(p-mr.xyz)-mr.w;\n  }\n\n  float GetDist(vec3 p){\n    float u = 1.9+0.056*sin(-iTime*.1);  \n    float v = 0.054-0.042*sin(-iTime*.1);\n    vec3 ph=p;\n\tvec3 phh=ph;\n    float d=min(p.y,u-p.y);\n\n    float scale = 1.0;\n\n    orb = vec4(1000.0); \n    colorind=0.;\n\n    for (int i = 0; i < ITER_STEPS ; i++){\n      p.xz -= 2.*floor(0.5*(p.xz+vec2(v/u*p.y+1.,1)));\n      //Above the separation line make point reflection\n      if  (p.y >= u * 0.5 + sign(v) *(2.*u-1.95)/4. * sign(p.x + v * 0.5)* (1. - exp(-(7.2-(1.95-u)*15.)* abs(p.x + v * 0.5))))\t\n      p = vec3(-v, u, 0.) - p;\n          \n      if(p.y < 0.) break; \n\n      //Apply transformation \n      float rr=dot(p,p);\n      orb = min( orb, vec4(abs(p),rr) );\n      ++colorind;\n\n      float iR = 1./rr;\n      p *= -iR;\n      p.x = -v - p.x; p.y = u + p.y; \n      scale *= iR;\n      if(abs(phh.x-p.x) < 1.e-6){\n\t\t\treturn min(d,.05/max(scale,1.));\n\t  }\n      phh=ph;\n      ph=p;\n      \n    }\n    \n    return min(d,.3*min(p.y,.3)/max(scale,1.));\n  }\n\n\n  float RayMarch(vec3 ro,vec3 rd){\n      float dO=0.;\n      \n      for(int i=0; i<MAX_STEPS; i++){\n      vec3 p=ro+rd*dO;\n          float dS=GetDist(p);\n          dO +=dS;\n          if(dO > MAX_DIST || abs(dS)< SURF_DIST) break;        \n      \n      }\n      return dO;\n  }\n      \n  vec3 GetNormal(vec3 p){\n    float d=GetDist(p);\n      vec2 e=vec2(SURF_DIST*.5,0);\n      \n      vec3 n= d-vec3(\n          GetDist(p-e.xyy),\n          GetDist(p-e.yxy),\n          GetDist(p-e.yyx));\n          \n    return normalize(n);\n  }\n\nvec3 render( in vec3 ro, in vec3 rd)\n{\n    vec3 col = vec3(0.0);\n    float t = RayMarch( ro, rd);\n    \n    vec3 pos = ro + t*rd;\n    vec3 nor = GetNormal( pos);\n\n    // lighting\n    vec3  light1 = vec3(  0.577, 0.577, -0.577 );\n    vec3  light2 = vec3( -0.707, 0.000,  0.707 );\n    float key = clamp( dot( light1, nor ), 0.0, 1.0 );\n    float bac = clamp( 0.2 + 0.8*dot( light2, nor ), 0.0, 1.0 );\n    float amb = (0.7+0.3*nor.y);\n    float ao = pow( clamp(orb.w*2.0,0.0,1.0), 1.2 );\n\n    vec3 brdf  = 1.0*vec3(0.40,0.40,0.40)*amb*ao;\n    brdf += 1.0*vec3(1.00,1.00,1.00)*key*ao;\n    brdf += 1.0*vec3(0.40,0.40,0.40)*bac*ao;\n\t\t\n    vec3 rgb = vec3(1.0);\n    rgb = mix( vec3(1.0,0.3,0.),rgb, clamp(colorind*.1,0.0,1.0) );\n    rgb = mix( rgb, vec3(0.4,0.6,0.1), pow(clamp(1.-2.0*(orb.x+orb.z),0.0,1.0),8.0) );\n\n    col = rgb*brdf*exp(-0.2*t);\n\n    return sqrt(col);\n}\n\n  void mainImage( out vec4 fragColor, in vec2 fragCoord )\n  {\n    float time = iTime*0.25 + 0.01*iMouse.x;\n\n        vec2 q = fragCoord.xy+vec2(1.,1.);\n        vec2 p = (2.0*q-iResolution.xy)/iResolution.y;\n\n        // camera\n        vec3 ro = vec3( 2.8*cos(0.1+.33*time), 0.4 + 0.30*cos(0.37*time), 2.8*cos(0.5+0.35*time) );\n        vec3 ta = vec3( 1.9*cos(1.2+.41*time), 0.4 + 0.10*cos(0.27*time), 1.9*cos(2.0+0.38*time) );\n        float roll = 0.2*cos(0.1*time);\n        vec3 cw = normalize(ta-ro);\n        vec3 cp = vec3(sin(roll), cos(roll),0.0);\n        vec3 cu = normalize(cross(cw,cp));\n        vec3 cv = normalize(cross(cu,cw));\n        vec3 rd = normalize( p.x*cu + p.y*cv + 2.0*cw );\n\n        vec3 col = render( ro, rd);\n    \n    \n    fragColor = vec4(col,1.0);\n  }\n","name":"Image","description":"","type":"image"}]}