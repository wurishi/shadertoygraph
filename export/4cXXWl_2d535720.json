{"ver":"0.1","info":{"id":"4cXXWl","date":"1705847587","viewed":41,"name":"shaes","username":"EnderSpace","description":"Testing different shapes sdf.","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define ITERS 1000\n#define BG_COL vec3(.1, .5, .95)\n\n\nfloat sdSphere(vec3 pos, float radius, vec3 point) {\n    return length(point - pos) - radius;\n}\n\n\nfloat sdPlane(float h, vec3 point) {\n    return abs(point.y - h);\n}\n\n\nvec2 rot2D(vec2 p, float a) {\n    // rot must be normalized (to avoid scaling)\n    vec2 r = vec2(cos(a), sin(a));\n    return vec2(p.x * r.x - p.y * r.y, p.x * r.y + p.y * r.x);\n}\n\n\nvec3 rot3D(vec3 p, vec3 r) { // point, rotation\n    // r contains the angle od rotation of each axis\n    p = vec3(rot2D(p.xy, r.z), p.z);\n    p = vec3(p.x, rot2D(p.yz, r.x));\n    vec2 pxz = rot2D(p.xz, r.y);\n    p = vec3(pxz.x, p.y, pxz.y);\n    return p;\n}\n\n\nfloat sceneSDF(vec3 p) {\n    const vec4 sphere = vec4(0., .8, 0., .8);\n    return min(sdSphere(sphere.xyz, sphere.w, p), sdPlane(0., p));\n}\n\n\nvec3 getNormal(vec3 p) {\n    const float t = .001;\n    vec3 v1 = vec3(\n        sceneSDF(p + vec3(t, 0., 0.)),\n        sceneSDF(p + vec3(0., t, 0.)),\n        sceneSDF(p + vec3(0., 0., t)));\n    vec3 v2 = vec3(\n        sceneSDF(p - vec3(t, 0., 0.)),\n        sceneSDF(p - vec3(0., t, 0.)),\n        sceneSDF(p - vec3(0., 0., t)));\n    return normalize(v1 - v2);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = (fragCoord * 2. - iResolution.xy) / iResolution.y;\n    \n    const vec3 sun = normalize(vec3(-2., -2., 1.));\n    \n    vec3 col = vec3(0.);\n    \n    vec3 ro = vec3(0., 1., -5);\n    vec3 rd = normalize(vec3(uv.xy, 2.));\n    \n    \n    float d = 0.;\n    \n    vec3 p = vec3(0.);\n    \n    for (int i = 0; i < ITERS; i++) {\n        p = ro + rd * d;\n        \n        float sd = sceneSDF(p);\n        \n        d += sd;\n        \n        if (d > 100.) {\n            col = BG_COL;\n            break;\n        };\n        \n        if (sd < .1) {\n            col = vec3(1.);\n            col = col * max(.14, smoothstep(.5, 2., 1. - dot(getNormal(p), sun)));\n            break;\n        };\n    }\n    \n    float fogMask = 1. - d * .01;\n    \n    //col = col * fogMask;\n    \n    fragColor = vec4(col, 1.);\n}\n","name":"Image","description":"","type":"image"}]}