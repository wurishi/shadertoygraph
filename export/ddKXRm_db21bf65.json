{"ver":"0.1","info":{"id":"ddKXRm","date":"1680898520","viewed":120,"name":"Hodgepodge Machine","username":"luh0","description":"A configurable hodge-podge machine","likes":0,"published":1,"flags":32,"usePreview":0,"tags":["cellularautomata"],"hasliked":0,"parentid":"msVSRm","parentname":"Belousov-Zhabotinsky (nope)"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float resolutionScale = .3;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec4 draw = vec4(texture(iChannel0, uv));\n    vec3 c = mix(background, color, draw.r);\n    fragColor = vec4(c, 1.);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"float Value(vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    float value = texture(iChannel0, uv).x;\n    return value;\n}\n\nfloat FirstIteration(vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    float value = texture(iChannel0, uv).y;\n    return value;\n}\n\nfloat NeighborhoodAverage(vec2 fragCoord)\n{\n    float average = 0.;\n    for (float i = 0.; i < neighborhoodSize.x; ++i)\n    {\n        for (float j = 0.; j < neighborhoodSize.y; ++j)\n        {\n            vec2 cFactor = vec2(neighborhoodSize.x/2., neighborhoodSize.y/2.);\n            cFactor = -floor(cFactor);\n            vec2 offset = vec2(j, i)+cFactor;\n            average += Value(fragCoord+offset);\n        }\n    }\n    average /= neighborhoodSize.x*neighborhoodSize.y;\n    return average;\n}\n\nuint CountIllNeighbors(vec2 fragCoord)\n{\n    uint numIll = 0u;\n    for (float i = 0.; i < neighborhoodSize.x; ++i)\n    {\n        for (float j = 0.; j < neighborhoodSize.y; ++j)\n        {\n            vec2 cFactor = vec2(neighborhoodSize.x/2., neighborhoodSize.y/2.);\n            cFactor = -floor(cFactor);\n            vec2 offset = vec2(j, i)+cFactor;\n            float value = Value(fragCoord+offset);\n            numIll += (value==1. ? 1u : 0u);\n        }\n    }\n    return numIll;\n}\n\nuint CountInfectedNeighbors(vec2 fragCoord)\n{\n    uint numInfected = 0u;\n    for (float i = 0.; i < neighborhoodSize.x; ++i)\n    {\n        for (float j = 0.; j < neighborhoodSize.y; ++j)\n        {\n            vec2 cFactor = vec2(neighborhoodSize.x/2., neighborhoodSize.y/2.);\n            cFactor = -floor(cFactor);\n            vec2 offset = vec2(j, i)+cFactor;\n            float value = Value(fragCoord+offset);\n            numInfected += (value>0. && value<1. ? 1u : 0u);\n        }\n    }\n    return numInfected;\n}\n\nvec3 Cell(vec2 fragCoord, float states, float spread)\n{\n    float value = Value(fragCoord);\n    if (value == 0.) // if healthy\n    {\n        uint infectedNeighbors = CountInfectedNeighbors(fragCoord);\n        uint illNeighbors = CountIllNeighbors(fragCoord);\n        // should this cell be infected?\n        if (infectedNeighbors > a || illNeighbors > b)\n        {\n            // set infection level\n            value = float(min(0u, infectedNeighbors-a))/float(n);\n            value += float(min(0u, illNeighbors-b))/float(n);\n            //value /= float(n);\n        }\n    }\n    else if (value >= 1.) // if ill\n    {\n        value = 0.;\n    }\n    else // if infected\n    {\n        value = NeighborhoodAverage(fragCoord)+c;\n    }\n    \n    float firstIteration = FirstIteration(fragCoord);\n    if (firstIteration == 0.)\n    {\n        firstIteration = 1.;\n        vec2 uv = fragCoord.xy / iResolution.xy;\n        value = texture(iChannel1, uv).x;\n    }\n    \n    vec3 cell = vec3(value, firstIteration, 0.);\n    return cell;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    float states = 1.; // normally denoted as n\n    float spread = .01; // normally denoted as g\n    \n    vec3 c = vec3(0);\n    c += Cell(fragCoord, states, spread);\n    fragColor = vec4(vec3(c.r, c.g, c.r), 1.0);\n    if (liveUpdate)\n    {\n        fragColor.g = c.r;\n    }\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"// More information:\n\n// Rules:\n// 1. Every cell can have three states (healthy, infected, ill)\n// 2. States are numbered from 0 to n (n is often around 100)\n// 3. Cells contain a real value between 0 and 1\n// \t1. Healthy: =0\n// \t2. Infected: >0\n// \t3. Ill: =1\n// 4. A Ill cell will become healthy in the next generation (not immune)\n// 5. _Generally:_ A Cell may become (more) infected or ill if the surrounding neighborhood is infected \n\n// Further information:\n// - A neighborhood is a field of variable size around a cell (mostly 3x3)\n// - The Hodgepodge machine depends on 4 parameters: a, b, c, n\n// \t- _a_ and _b_ are thresholds for the amount of neighbors a cell needs to have to become infected (or ill)\n// \t  --> the subsequent infection-level is the number of times the thresholds are exceeded divided by _n_\n// \t- For updating the infection levels on a infected cell the average infection-levels are added together with _c_\n// \t  --> _c_ is a __bias__ for infection growth (growth rate of the infection)\n\n// All information presented was gathered from: https://webbox.lafayette.edu/~reiterc/mvq/hodgepodge/withj_hodgepodge.pdf\n\n// settings and variables\nconst vec2 neighborhoodSize = vec2(3., 3.); // size of scanned neighborhood for each cell\nconst uint a = 2u; // infection threshold\nconst uint b = 3u; // illness threshold\nconst float c = 0.1; // growth rate\nconst uint n = 100u; // state count\nconst bool liveUpdate = true; // updating image (if off one-shot)\nconst vec3 color = vec3(0.4, 0.8, 0.7); // color at value 1.0\nconst vec3 background = vec3(0.6, 0.2, 0.3); // color at value 0.0\n\n// EXTRAS:\n// If you feel like a masochist you may want to try replacing iChannel1 in Buffer A with a webcam","name":"Common","description":"","type":"common"}]}