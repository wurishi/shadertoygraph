{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[{"channel":0,"type":"texture","id":"XsXGRn","filepath":"/media/a/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"code":"/*****************************************************/\n/*  uncomment/comment below to customize shader      */\n/*****************************************************/\n\n//#define interactive\n#define ver2\n#define useao\n#define clouds\n\n/*****************************************************/\n\n#define marchsteps 60\n#define c1 0.1\n#define c2 0.2\n#define c3 0.3\n#define numiter 12\nfloat scale= -5.34642;\nvec3 from;\n\n/****************************************************/\n#ifdef ver2\nfloat DE1(vec3 pos) {\n   \tvec3 z=pos-from;\n   \tfloat r=dot(pos-from,pos-from)*pow(length(z),2.0);\n   \treturn (1.0-smoothstep(0.0,0.01,r))*0.01;\n}\n#endif\n\nfloat DE2(vec3 pos)  {\n\tvec4 p = vec4(pos,1.0);\n\tvec4 c=vec4(c1,c2,c3,0.5)-0.5; \n\n\tfor (int i=0 ;i<numiter ; i++) {\n\t\tp.xyz=clamp(p.xyz, -1.0, 1.0) * 2.0 - p.xyz;\t\t\n\t   \tfloat r2 = dot(p.xyz,p.xyz);\n\t   \tif(r2<2.0) p*=(1.0/r2); else p*=0.5;\t\t\t\t\n    \tp=p*scale+c;\n   \t}\n   \treturn length(p.xyz)/p.w;\n}\n\n/****************************************************/\n/****************************************************/\n#ifdef clouds\nfloat hash(float n) {\n\treturn fract(sin(n)*43758.5453);\n}\n\nfloat noise( in vec3 x ) {\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    float n = p.x + p.y*57.0 + 113.0*p.z;\n    return mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                   mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\n               mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                   mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\n}\n\nfloat DEclouds(vec3 p) {\n\tfloat d = -p.y -1.5;\n\tvec3 q = p - vec3(0.1, 0.1, 0.1)*iTime;\n\tfloat f;\n\tf = 0.5 * noise(q); q*=2.02;\n\tf += 0.25 * noise(q); q *= 2.03;\n\tf += 0.125 * noise(q); q *= 2.01;\n\tf += 0.0625 * noise(q);\n\td += 3.0*f;\n\td = clamp(d,0.0, 1.0);\n\treturn d;\n}\n#endif\n/****************************************************/\n/****************************************************/\n\nvec3 map(vec3 pos) {\n#ifdef clouds\n\tfloat fog=DEclouds(pos);\n#else\n\tfloat fog=0.0;\n#endif\n\t\n#ifdef ver2\n\tfloat d1=DE1(pos);   \n   \tfloat d2=DE2(pos);\n\treturn vec3( max(d1,d2), 1.0, fog);\n#else\n \tfloat d1=DE2(pos);\n\treturn vec3( d1, 1.0, fog);\n#endif\n}\n\n/****************************************************/\n\nvec3 tex3D( vec3 pos, vec3 nor, sampler2D s) {\n\treturn texture( s, pos.yz).xyz*abs(nor.x)+\n\t       texture( s, pos.xz).xyz*abs(nor.y)+\n\t       texture( s, pos.xy).xyz*abs(nor.z);\n}\n\n#ifdef useao\nfloat cao(vec3 pos, vec3 nor){\n\tfloat sca = 1.0;\n\tfloat totao = 0.0;\n\tfor (int i=0; i<5; i++) {\n        \tfloat hr = 0.01 + 0.05*float(i);\n        \tvec3 aopos =  nor * hr + pos;\n        \tfloat dd = map(aopos).x;\n        \ttotao += -(dd-hr)*sca;\n        \tsca *= 0.75;\n    \t}\n    return clamp( totao, 0.0, 1.0 );\n}\n#endif\n\nfloat csh(vec3 ro, vec3 rd, float t, float k ) {\n    float res = 1.0;\n    for( int i=0; i<10; i++ ) {\n    \tfloat h = map(ro + rd*t).x;\n        res = min( res, k*h/t );\n        t += h;\n\t}\n    return clamp(res,0.0,1.0);\n}\n\nvec3 normal(vec3 p ) {\n\tvec3 e=vec3(0.01,-0.01,0.0);\n\treturn normalize( vec3(\te.xyy*map(p+e.xyy).x +\te.yyx*map(p+e.yyx).x +\te.yxy*map(p+e.yxy).x +\te.xxx*map(p+e.xxx).x));\n}\n\n\n#ifdef interactive\nvoid rot( inout vec3 p, vec3 r) {\n\tfloat sa=sin(r.y); float sb=sin(r.x); float sc=sin(r.z);\n\tfloat ca=cos(r.y); float cb=cos(r.x); float cc=cos(r.z);\n\tp*=mat3( cb*cc, cc*sa*sb-ca*sc, ca*cc*sb+sa*sc,\tcb*sc, ca*cc+sa*sb*sc, -cc*sa+ca*sb*sc,\t-sb, cb*sa, ca*cb );\n}\n#endif\n\nvoid interact( inout vec3 ro, inout vec3 rd, inout vec3 lig) {\n#ifdef interactive\n\tvec2 mp=iMouse.xy/iResolution.xy;\n\trot(ro,vec3(mp.x,mp.y,0.0));\n\trot(lig,vec3(mp.x,mp.y,0.0));\n#else\t\n\tro.z=ro.z+cos(iTime*0.155)*0.47;\n\tro.x=ro.x+cos(iTime*0.215)*0.74;\n\tro.y=ro.y+cos(iTime*0.110)*0.92;\n\tlig.z=lig.z+cos(iTime*0.155)*0.47;\n\tlig.x=lig.x+cos(iTime*0.215)*0.74;\n\tlig.y=lig.y+cos(iTime*0.110)*0.92;\t\n#endif\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\t\n    vec2 p = -1.0 + 2.0 * fragCoord.xy / iResolution.xy;\n    p.x *= iResolution.x/iResolution.y;\t\n\tvec3 ta = vec3(0.0, 0.0, 0.0);\n\tvec3 ro =vec3(0.0, 0.0, -0.01);\n\tvec3 lig=vec3(0.0, 3.0, 1.0);\n\t\n\tinteract(ro, ta, lig);\t\n\n\tvec3 cf = normalize( ta - ro );\n    vec3 cr = normalize( cross(cf,vec3(0.0,1.0,0.0) ) );\n    vec3 cu = normalize( cross(cr,cf));\n\tvec3 rd = normalize( p.x*cr + p.y*cu + 2.5*cf );\t\n\t\n\tfrom=ro;\t\n\tscale+= sin(iTime*0.2)*0.5-0.1;\t\n\t\n\t//march\n#ifdef clouds\n\tvec4 fog = vec4(0,0,0,0);\n#endif\n\tvec3 r=vec3(0.0);\n\tfloat f=0.0;\n\tfor(int i=0; i<marchsteps; i++) {\n\t\tr=map(ro+rd*f);\n\t\tif( r.x<0.0 ) break;\n#ifdef clouds\n\tif (fog.w < 0.99 || r.z>0.0) {\n\t\tfloat dif = clamp((r.z - map((ro+rd*f)+0.3*lig).z)/0.6, 0.0, 1.0);\n\t\tvec3 lin = vec3(0.65,0.68,0.7)*1.35 + 0.45*vec3(0.7, 0.5, 0.3)*dif;\n\t\tvec4 tfog = vec4(r.z);\n\t\t\t tfog.xyz= mix(1.15*vec3(1.0, 0.95, 0.8), vec3(0.7,0.7,0.7), r.z) * lin;\n\t\ttfog.w *= 0.35;\n\t\ttfog.xyz *= tfog.w;\n\t\tfog = fog + tfog*(1.0 - fog.w);\t\t\n\t}\t\t\n#endif\t\t\n\t\tf+=r.x;\n\t}\n\tr.x=f;\n\tif( r.x>30.0 ) r.y=0.0;\n\n#ifdef clouds\n\tfog.xyz /= (0.001 + fog.w);\n\tfog=clamp(fog, 0.0, 1.0);\n#endif\t\n\t\n\t//process\t\n\tvec3 col=vec3(1.0);\n\tif (r.y>0.5) {\n\t\t//obj\n\t\tvec3 ww=ro+rd*r.x;\n\t\tvec3 nor=normal(ww);\n\t\t\n\t\t\t\t\t\t\n\t\tvec3 rgb=tex3D(ww,nor,iChannel0);\n\n//\t\tvec3 rgb=vec3(1.0, 0.8, 0.7);\n\n\t\tlig=normalize(lig);\n\t\tfloat amb =0.2*ww.y;\n\t\tfloat dif =0.7*clamp(dot(lig, nor), 0.0,1.0);\n\t\tfloat bac =0.4*clamp(dot(nor,-lig), 0.0,1.0);\n//\tfloat rim =0.3*pow(1.+dot(nor,rd), 5.0);\n//\tfloat spe =0.5*pow(clamp( dot( lig, reflect(rd,nor) ), 0.0, 1.0 ) ,32.0 );\n#ifdef useao\n\t\tfloat ao=cao(ww, nor);\n#endif\n\t\tfloat sh=csh(ww, lig, 0.01, 1.0);\n\t\t\t\t//amb+dif+bac-ao+sh\n#ifdef useao\n\t     col  = (amb+dif+bac-ao+sh)*vec3(1.);\n#else\t\t\n\t     col  = (amb+dif+bac+sh)*vec3(1.);\n#endif\t\t\n\t\t col *= rgb;\n//\t\t col += (rim+spe)*vec3(1.);\n\t\t\n\t}\t\n#ifdef clouds\n\tcol = mix(col, fog.xyz, r.z*0.9);\n#endif\t\n\n\t\n\t//post \n\tcol*=exp(0.09*r.x);\n\tcol*=0.85;\n\n\tfragColor=vec4( col, 1.0);\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"4sSGzK","date":"1390510584","viewed":592,"name":"nice thing","username":"avix","description":"I was browsing fractalforums for some info on terrain fractals then i found something interesting and played a bit with it, and this came out... looked so good so i had to post it here.\nUpdate: added clouds/fog and interactive mode","likes":14,"published":1,"flags":0,"usePreview":0,"tags":["3d","fractal","raymarch"],"hasliked":0,"parentid":"","parentname":""}}