{"ver":"0.1","info":{"id":"3ds3RN","date":"1545234954","viewed":431,"name":"cold sky","username":"cailuming","description":"a cold sky, and simple 2d mountain ","likes":17,"published":1,"flags":0,"usePreview":0,"tags":["noise"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4df3Rn","filepath":"/media/a/3c33c415862bb7964d256f4749408247da6596f2167dca2c86cc38f83c244aa6.mp3","previewfilepath":"/media/ap/3c33c415862bb7964d256f4749408247da6596f2167dca2c86cc38f83c244aa6.mp3","type":"music","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.1415926\nvec3 getColor(float c){\n   float r = cos((c-0.75)*PI);\n   float g = cos((c-0.55)*PI);\n   float b = cos((c-0.25)*PI);\n   return vec3(r,g,b);\n}\n\nmat2 rot2D(float a){\n   float c = cos(a);\n   float s = cos(a);\n   return mat2(c,s,-s,c); \n}\n\nfloat hash1(vec2 p){\n  vec2 v = vec2(PI*1453.0,exp(1.)*3054.0);\n  return fract(sin(dot(p,v)*0.1)*4323.0);\n}\n\nvec2 hash2(vec2 p){\n  vec2 v = vec2(hash1(p),hash1(p*p));   \n  return v+v*rot2D(iTime*0.5); \n}\n\nfloat noise1D(float x){\n   float p = floor(x);\n   float f = fract(x);\n   \n   float p1 = p+1.0;\n   float h1 = hash1(vec2(p));\n   float h2 = hash1(vec2(p1));\n   \n   f = f*f*f*(f*(f*6.-15.)+10.);\n   float v = mix(h1,h2,f); \n    \n   return v;\n}\n\nfloat noise2D(vec2 uv){\n   vec2 p = floor(uv);\n   vec2 f = fract(uv);\n   vec2 e = vec2(1,0);\n   vec2 p00 = p;\n   vec2 p10 = p+e;\n   vec2 p11 = p+e.xx;\n   vec2 p01 = p+e.yx;\n   float v00 = dot(f-e.yy,hash2(p00));\n   float v10 = dot(f-e.xy,hash2(p10));\n   float v11 = dot(f-e.xx,hash2(p11));\n   float v01 = dot(f-e.yx,hash2(p01));\n    \n   f = f*f*f*(f*(f*6.-15.)+10.); \n   \n   return mix(mix(v00,v10,f.x),mix(v01,v11,f.x),f.y);\n}\n\nfloat fbm1d(vec2 uv){\n    float freq  = 1.0;\n    float ampli = 3.0;\n    float ret   = 0.0;\n\n    for(int i=0;i<5;i++){\n       ret += noise1D(uv.x*freq)*ampli;\n       ampli*=0.6;\n       freq*=2.0;\n       uv+=sin(0.01*float(i));\n    }\n    return ret;\n}\n\nfloat fbm(vec2 uv){\n    float freq  = 1.0;\n    float ampli = 3.0;\n    float ret   = 0.0;\n\n    for(int i=0;i<5;i++){\n       ret += noise2D(uv*freq)*ampli;\n       ampli*=0.6;\n       freq*=2.0;\n       uv+=sin(0.01*float(i));\n    }\n    return ret;\n}\n\nvoid mountain(inout vec3 col,vec2 uv,vec2 cuv){\n    cuv.y+=6.;\n    cuv.x+=7.0;\n    float n = fbm1d(cuv*0.12);\n    vec2  f = vec2(cuv.x,n);\n    float v = 0.1/length(cuv-f);\n    v = pow(v,3.5);\n    if(cuv.y<=n){\n      col-= 20.;\n    }else {\n      col-=v*10.;\n    }\n    \n}\n\nvoid moon(inout vec3 col,vec2 uv,vec2 cuv){\n   uv -= vec2(5.,3.);\n   uv*=vec2(0.1);\n   \n   vec2 f  = vec2(uv.x,uv.y);\n   float r = .1; \n   float v = r/(length(uv));\n   float t =  0.0;\n   \n   for(int i=0;i<4;i++){\n       t = iTime*0.5+float(i)*0.8;\n       v+=fbm(cuv+vec2(t,t*0.1))*0.05;\n   }\n    \n   col+= getColor(0.16)*v; \n}\n\nvoid star(inout vec3 col,vec2 uv,vec2 cuv){\n   float v =0.0;\n   \n    \n   v+=abs(0.5)/length(uv-70.*vec2(hash2(uv*5.0)));\n    \n   col+= getColor(0.14)*v*1.4; \n}\n\n\nvoid drawMeteor(inout vec3 col, in vec2 uv,vec2 startP,vec2 endP,float linWidth){\n \n   uv*=3.0;\n   vec2 lineDir=endP-startP;\n   vec2 fragDir=uv-startP;\n   \n   // keep the line coefficient bewteen [0,1] so that the projective dir on the \n   // lineDir will not exceed or we couldn't get a line segment but a line.\n   float lineCoe=clamp(dot(lineDir,fragDir)/dot(lineDir,lineDir),0.,1.0);\n                       \n   vec2 projDir=lineCoe*lineDir;\n    \n   vec2 fragToLineDir= fragDir- projDir;\n    \n   float dis=length(fragToLineDir);\n   float disToTail = length(projDir);\n   dis=linWidth/dis;\n     \n   col += dis*getColor(0.3)*pow(disToTail,3.0);\n    \n}\n \nvoid drawMeteors(inout vec3 col,vec2 uv){\n    \n    vec2 dir = normalize(vec2(-1.0,-0.5));\n    vec2 mv  = -dir*cos(mod(iTime*2.,PI))*60.0;\n    vec2 sp  = vec2(10.0+100.0*hash1(vec2(floor(iTime*2./PI))),10.0);\n    vec2 ep  = sp+dir*5.0;\n\n    drawMeteor(col,uv,sp+mv,ep+mv,0.0005);\n\n}\n \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 cuv = uv - vec2(0.5);\n    cuv.x *= iResolution.x/iResolution.y;\n    // Time varying pixel color\n    vec3 col = vec3(0);\n    cuv *=10.;\n    moon(col,cuv,uv);\n \n    star(col,uv,cuv);\n    drawMeteors(col,cuv);\n    mountain(col,uv,cuv);\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}