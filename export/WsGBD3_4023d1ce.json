{"ver":"0.1","info":{"id":"WsGBD3","date":"1608046911","viewed":100,"name":"Weaving Bezier Network","username":"Reynolds","description":"Playing around with this Bezier representation.","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["distancefunction","beziercurve","cubicbezier"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float sdCapsule( vec2 p, vec2 a, vec2 b, float r )\n{\n\tvec2 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h ) - r;\n}\n\n\nfloat cubBez(float x, vec2 cps) {\n    return 3.0*(1.0-x)*x*((1.0-x)*cps.x + x*cps.y);\n}\n\n\n/*\n    the bezier curve is converted to an axis dependent bezier curve\n    the second control point is located at\n        vec2(1/3, ts.x)\n    and the third\n        vec2(2/3, ts.y)\n    the first and last are a and b\n*/\nfloat cubicBezier(vec2 p, vec2 a, vec2 b, vec2 ts, float D) {\n    vec2 ba = b - a;\n    vec2 n = vec2(-ba.y, ba.x);\n    \n    //convert to coordinate system relative to ab\n    vec2 q = vec2(dot(p-a, normalize(ba)) / length(ba),\n                  dot(p-a, normalize(n)) / length(ba));\n    //find distance relative to displace curve\n    q.y = q.y + cubBez(q.x, ts);\n    \n    //return distance\n    return sdCapsule(q, vec2(0.0, 0.0), vec2(1.0, 0.0), D);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.y + vec2(iTime/40.0);\n    \n    float rr = 0.2;\n    vec2 ruv = mod(uv, vec2(rr)) / vec2(rr);\n    \n    float bb = 1.0/3.0;\n    float t = bb*sin(iTime/1.5 + uv.x);\n    float q = -bb*sin(iTime/3.0 + uv.y);\n    \n    if(mod(uv.x/rr, 3.0) > 2.0) t = -t;\n    if(mod(uv.x/rr, 4.0) > 2.0) q = -q;\n    if(mod(uv.y/rr, 2.0) > 1.0) t = -t;\n    if(mod(uv.y/rr, 6.0) > 5.0) q = -q;\n    \n    \n    float d = 0.0125;\n    float w = 0.05;\n    vec2 A = vec2(w, w);\n    vec2 B = vec2(1.0 - w, w);\n    vec2 C = vec2(1.0 - w, 1.0 - w);\n    vec2 D = vec2(w, 1.0 - w);\n                 \n    \n    float l = cubicBezier(ruv, A, C, vec2(-t, t), d);\n    l = min(l, cubicBezier(ruv, C, A, vec2(-q, -q), d));\n    l = min(l, cubicBezier(ruv, B, D, vec2(-t, q), d));\n    l = min(l, cubicBezier(ruv, D, B, vec2(-q, t), d));\n    l = min(l, length(vec2(0.0) - ruv) - 0.1);\n    l = min(l, length(vec2(1.0, 0.) - ruv) - 0.1);\n    l = min(l, length(vec2(1.0, 1.) - ruv) - 0.1);\n    l = min(l, length(vec2(0.0, 1.) - ruv) - 0.1);\n\n\n    float a = 1.-60.*l; \n    fragColor = vec4(l<0.,1,1,1)\n                - smoothstep(1.,0.,abs(a)); \n  \n}","name":"Image","description":"","type":"image"}]}