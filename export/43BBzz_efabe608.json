{"ver":"0.1","info":{"id":"43BBzz","date":"1729429098","viewed":51,"name":"Sausages","username":"Alpaga","description":"Made using corner tiles. Assign a random bit to each point of the grid. Each connected set of points having the same bit is a region. Separate different regions by strings of sausages.","likes":16,"published":1,"flags":0,"usePreview":0,"tags":["truchet","sausages","cornertiles"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dX3Rn","filepath":"/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg","previewfilepath":"/media/ap/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsX3Rn","filepath":"/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg","previewfilepath":"/media/ap/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Uncomment if your card is powerful enough.\n//#define AA\n\n#define SHADOWS\n\nconst int STEPS = 300;\nconst float FAR = 300.;\n\nconst float fov = 35.0;\n\nconst int SAUSAGES = 0, TABLE = 1;\n\nstruct Material {\n    vec3 albedo;\n    vec3 specular;\n};\n\nfloat radius;\n\nvec3 ambient = vec3(0.2);\nconst vec3 lightDirection = normalize(vec3(3,5,-4));\nconst vec3 lightCol = vec3(1,1,.7);\n\nvec2 delta = vec2(0.0,0.001);\n\nfloat time;\n\n// Hash function from Dave_Hoskins\n// https://www.shadertoy.com/view/4djSRW\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\nfloat randBit(vec2 p) {\n    return step(hash12(p),.5);\n}\n\n// Signed distance fields\nfloat sdSausages(vec3 p) {\n    // If far from the plane, don't do useless calculations\n    if(p.y>.5) return p.y-.2;\n\n    vec2 fl = floor(p.xz);\n    vec2 fr = fract(p.xz);\n    radius = 2.*max(abs(fr.x-.5),abs(fr.y-.5));\n    radius = .1*(1.-pow(radius,6.));\n\n    // A random bit at each corner of the tile\n    vec4 c = vec4(randBit(fl),randBit(fl+vec2(1,0)),randBit(fl+vec2(0,1)),randBit(fl+vec2(1,1)));\n    float s = c.x+c.y+c.z+c.w;\n    \n    float d=.2;\n    if(s==0. || s==4.) {\n        return d;\n    }\n    if(s==2.) {\n        if(c.x==c.w) {\n            // Cross\n            if(c.x==0.) {\n                return min(d, min(length(vec2(length(fr)-.5,p.y))-radius,length(vec2(length(1.-fr)-.5,p.y))-radius));\n            } else {\n                return min(d, min(length(vec2(length(vec2(1,0)-fr)-.5,p.y))-radius,length(vec2(length(vec2(0,1)-fr)-.5,p.y))-radius));\n            }\n            return min(d, min(length(vec2(fr.x-.5,p.y))-radius,length(vec2(fr.y-.5,p.y))-radius));\n        } else {\n            if(c.x==c.y) {\n                // Horizontal\n                return min(d,length(vec2(fr.y-.5,p.y))-radius);\n            } else {\n                // Vertical\n                return min(d,length(vec2(fr.x-.5,p.y))-radius);\n            }\n        }\n    }\n    // Corner\n    if(c.x==c.y) {\n        fr.y=1.-fr.y;\n        c = c.zwxy;\n    }\n    if(c.x==c.z) {\n        fr.x = 1.-fr.x;\n        c = c.yxwz;\n    }\n    return min(d,length(vec2(length(fr)-.5,p.y))-radius);\n}\n\nfloat sdRoughSausages(vec3 p) {\n    return sdSausages(p)+.0025*texture(iChannel1,p.xz).r;\n}\nfloat sdTable(vec3 p) {\n    return p.y+.1+.0025*texture(iChannel0,p.xz).r;\n}\nfloat sd(vec3 p, out int id) {\n    float d,minD = 1e6;\n    vec2 pos,dir;\n    int tmp;\n    \n    // Sausages\n    d = sdRoughSausages(p);\n    if(d<minD) {\n        id = SAUSAGES;\n        minD = d;\n    }\n    \n    // Table\n    d = sdTable(p);\n    if(d<minD) {\n        id = TABLE;\n        minD = d;\n    }\n    \n    return minD;\n}\n\n\nMaterial material(vec3 p, int id) {   \n    vec3 alb, spe = vec3(.04);\n    switch(id) {\n        case SAUSAGES:\n            alb = mix(vec3(.8,.22,.27),vec3(1,.5,.55),smoothstep(0.,1.,texture(iChannel1,p.xz).r));\n            break;\n        case TABLE:\n            // Vichy\n            vec2 fr = abs(mod(3.*p.xz,2.)-1.);\n            fr = smoothstep(.47,.53,fr);\n            alb = mix(vec3(1),vec3(1,0,0),.5*(fr.x+fr.y));\n            spe = vec3(.015);\n            break;\n    }\n    return Material(alb,spe);\n}\n\nvec3 normal(vec3 p) {\n    int id;\n    float d = sd(p,id);\n    return normalize(vec3(\n        sd(p+delta.yxx,id),\n        sd(p+delta.xyx,id),\n        sd(p+delta.xxy,id))-d);\n}\n\nfloat march(vec3 start, vec3 dir, out int id) {\n\tfloat total = 0.0, d = 1.0;\n    float epsilon = 0.5/iResolution.y;\n    int i=0;\n    for(; i<STEPS; i++) {\n        if(d<epsilon*total || total>FAR) break;\n        d = sd(start + total*dir,id);\n        total += d;\n    }\n    if(total>FAR || i==STEPS) id = -100;\n    return total;\n}\n\nfloat lightMarch(vec3 start, vec3 dir) {\n\tfloat d = 1.0, total = 0.0;\n    float epsilon = 0.5/iResolution.y;\n    float minD = 1000.0;\n    int id;\n    for(int i=0; i<STEPS; i++) {\n        if(d<epsilon*total || total>5.) break;\n        d = sd(start + total*dir, id);\n        total += d;\n        minD = min(minD,d);\n    }\n    return minD;\n}\nfloat shadow(vec3 p, vec3 toLight) {\n    float minD = lightMarch(p+0.05*toLight, toLight);\n    return smoothstep(0.0,0.04,minD);\n}\n\nvec3 rayColor(vec3 start, vec3 dir) {\n    vec3 color = vec3(0);\n    \n    int id;\n    \n    float d = march(start, dir,id);\n    vec3 p = start + d * dir;\n\n    vec3 normal = normal(p);\n    Material mat = material(p,id);\n\n    color += ambient*mat.albedo;\n\n    // Diffuse\n    vec3 diff = mat.albedo * max(dot(lightDirection, normal), 0.);\n    // Specular\n    vec3 h = normalize(lightDirection-dir);\n    vec3 spec = 20.*mat.specular * pow(max(dot(h,normal),0.), 150.);\n\n    #ifdef SHADOWS\n    // Shadow\n    float sh = shadow(p, lightDirection);\n    #else\n    float sh = 1.;\n    #endif\n\n    color += sh*(diff + spec)*lightCol;\n\n    return color;\n}\n\nmat3 setupCamera(vec3 forward, vec3 up) {\n \tvec3 w = forward;\n    vec3 u = normalize(cross(up, w));\n    vec3 v = cross(w, u);\n    \n    return mat3(u,v,w);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    time = 1.*iTime;\n    \n    vec3 lookAt = vec3(.5*time,0,-.1*time);\n    float elevation = 1.3, azimuth = .1*time;\n    float camDistance = (12.-7.*cos(.2*time));\n\n    if(iMouse.z>0.0) {\n        camDistance *= exp(2.5*(abs(iMouse.w)-iMouse.y)/iResolution.y);\n    }\n\n    vec3 forward = vec3(cos(azimuth)*cos(elevation),sin(elevation),sin(azimuth)*cos(elevation));\n    vec3 cam = lookAt + camDistance*forward;\n    mat3 m = setupCamera(forward, vec3(0,1,0));\n    \n    vec3 color = vec3(0);\n\n    vec2 uv;\n    #ifdef AA\n    for(float i=-0.25; i<0.5; i+=0.5) {\n        for(float j=-0.25; j<0.5; j+=0.5) {\n            uv = 2.0*(fragCoord + vec2(i,j) - 0.5 * iResolution.xy)/iResolution.y;\n            vec3 pix = vec3(tan(0.5*fov*0.01745)*uv,-1.0);\n    \n            vec3 dir = normalize(m*pix);\n    \n            color += rayColor(cam, dir);\n        }\n    }\n    color /= 4.0;\n    #else\n    uv = 2.0*(fragCoord - 0.5 * iResolution.xy)/iResolution.y;\n    vec3 pix = vec3(tan(0.5*fov*0.01745)*uv,-1.0);\n    vec3 dir = normalize(m*pix);\n\n    color = rayColor(cam, dir);\n    #endif\n    \n    // Vignette\n    uv = fragCoord.xy / iResolution.xy;\n    uv *=  1. - uv.yx;\n    color *= pow(uv.x*uv.y * 15.0, 0.25);\n    \n    // Gamma\n    color = pow(color, vec3(1./2.2));\n        \n    fragColor = vec4(color,1.0);\n}\n","name":"Image","description":"","type":"image"}]}