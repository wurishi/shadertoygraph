{"ver":"0.1","info":{"id":"NltcD4","date":"1659828829","viewed":166,"name":"SDF from 3D buffer","username":"mattdeeds","description":"I render the SDF to a buffer, and then look up the values from the texture.  The result is something that looks a lot like Marching Cubes.","likes":1,"published":1,"flags":32,"usePreview":0,"tags":["3d","raymarching","sdf","3dtexture"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define kDistanceToScreen 2.0\n#define kOutsideSteps 64\n\n// The position must be in the closed interval [0..1]\n// Please check this before calling the transform.\nvec2 xyzToUV(in vec3 pos) {\n  float u = pos.x * 0.125;\n  float v = pos.y * 0.125;\n  \n  float a = floor(8.0 * pos.z);\n  float b = floor(8.0 * fract(8.0 * pos.z));\n  return vec2(u + a * 0.125, v + b * 0.125);\n}\n\n\nfloat sdf(vec3 pos) {\n  if (pos.x < 0.0 || pos.x > 1.0\n    || pos.y < 0.0 || pos.y > 1.0\n    || pos.z < 0.0 || pos.z > 1.0) { \n    return 1e12; \n  }\n  \n  float p = fract(64.0 * pos.z);\n  \n  \n  vec2 low_uv = xyzToUV(pos);\n  vec2 high_uv = xyzToUV(pos + vec3(0, 0, 1.0 / 64.0));\n  \n  vec4 low_col = texture(iChannel0, low_uv);\n  vec4 high_col = texture(iChannel0, high_uv);\n  return mix(low_col.g, high_col.g, p);\n}\n\n\n\n// https://michaelwalczyk.com/blog-ray-marching.html\nvec3 calculate_normal(in vec3 pos)\n{\n  // If this is too large, you will see a bright color between parallel surfaces\n  // e.g. the bottom of the spheres.  Try 0.1 to see what I mean.\n  const vec3 del = vec3(0.001, 0.0, 0.0);\n\n  vec3 normal = vec3(\n    sdf(pos + del.xyy) - sdf(pos - del.xyy),\n    sdf(pos + del.yxy) - sdf(pos - del.yxy),\n    sdf(pos + del.yyx) - sdf(pos - del.yyx));\n  return normalize(normal);\n}\n\nvec2 getDepth(vec3 ray_origin, vec3 ray_direction, float end) {\n  float depth = 0.0;\n  vec3 ray_position = ray_origin;\n  for (int i = 0; i < kOutsideSteps; ++i) {\n      float distance = sdf(ray_position);\n      depth += distance;\n      if (distance < 0.0003) {\n       return vec2(depth, float(i));\n      }\n      if (depth >= end) {\n        return vec2(end, float(i));\n      }\n      ray_position += ray_direction * distance;\n  }\n  return vec2(depth, float(kOutsideSteps));\n}\n\nfloat ambientLight(vec3 pos, vec3 n) {\n  float al = 0.0;\n  float epsilon = 0.1;\n  vec3 step = epsilon * n;\n  for (int i = 0; i < 6; ++i) {\n    pos += step;\n    al += 1.0 - (epsilon * float(i) - sdf(pos));\n  }\n  al /= 6.0;\n  al = pow(al, 3.2);\n  return clamp(al, 0.0, 1.0);\n\n}\n\nconst vec3 directSource = normalize(vec3(1.0, 0.5, 0.5));\n\nfloat directLight(vec3 pos, vec3 n) {\n  pos += 0.02 * n;\n  vec2 depth = getDepth(pos, directSource, 5.0);\n  if (depth.x >= 5.0) {\n    return clamp(dot(n, directSource), 0.0, 1.0);\n  } else {\n    return 0.0;\n  }\n  //return depth.y / float(kOutsideSteps);\n}\n\nvec4 render(in vec2 fragCoord) {\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = 2.0 * (fragCoord - (iResolution.xy * 0.5)) / iResolution.yy;\n    vec3 view = normalize(vec3(uv.x, uv.y, -kDistanceToScreen));\n    \n    float t = iTime * 0.2;\n    mat3 rotate = mat3(sin(t), cos(t), 0, cos(t), -sin(t), 0, 0, 0, 1);\n    view.zxy = rotate * view.zxy;\n    \n    \n    vec3 origin = vec3(0.5);\n    vec2 depth = getDepth(origin, view, 2.0);\n    \n    if (depth.x >= 2.0) {\n      return vec4(0.5, 0.5, 0.8,1.0);\n    }\n    \n    \n    vec3 intersection = origin + depth.x * view;\n    vec3 normal = calculate_normal(intersection);\n    vec3 direct = vec3(1.0, 0.5, 0.0) * directLight(intersection, normal);\n    vec3 ambient = vec3(0.0, 0.5, 1.0) * (ambientLight(intersection, normal));\n    \n    vec3 col = direct + ambient;\n    return vec4(col, 1.0);\n    // Output to screen\n}\n\nvec4 fromBuffer(in vec2 fragCoord) {\n    vec2 uv =fragCoord / iResolution.xy;\n   return texture(iChannel0, uv);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = render(fragCoord);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\nfloat sphere(vec3 pos, vec3 center, float radius) {\n  return length(pos - center) - radius;\n}\n\n\nfloat rnd(float s, int n) {\n  return floor(float(n) * fract(abs(s * 103.1483214124)));\n}\n\nvec3 rnd3(float s) {\n  return vec3(\n    fract(abs(s * 1503.1483214124)),\n    fract(abs(s * 2313.2483314124)),\n    fract(abs(s * 9121.548334124)));\n}\n\nfloat sdf(vec3 pos) {\n  float d = 1e12;\n  for (int i = 0; i < 150; ++i) {\n    vec3 center = rnd3(float(i));\n    center -= vec3(0.5);\n    center = normalize(center) * 0.4;\n    center += vec3(0.5);    \n    d = min(d, sphere(pos, center, 0.02 + rnd(float(i), 10) * 0.01));\n  }\n  return d;\n}\n\n\nvec3 uvToXYZ(in vec2 uv) {\n  float x = fract(uv.x * 8.0);\n  float y = fract(uv.y * 8.0);\n  \n  float a = floor(uv.x * 8.0);\n  float b = floor(uv.y * 8.0);\n  \n  float z = 0.125 * a + 0.125 * 0.125 * b;\n  \n  return vec3(x, y, z);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // This magic causes only 1% of the buffer to be recomputed each frame.\n    if (rnd(uv.x, 100) == rnd(iTime, 100)) {\n      // Time varying pixel color\n      vec3 col = vec3(sdf(uvToXYZ(uv)));\n      col.b = smoothstep(-0.1, 0.1, col.b);\n      col.r = smoothstep(0.1, -0.1, col.r);\n      col.g = col.g;\n      // Output buffer\n      fragColor = vec4(col,1.0);\n    } else {\n      // Buffer A is an input to Buffer A so that we can persist the old value in the 99% case where we are not\n      // recalculating the pixel.\n      fragColor = texture(iChannel0, uv);\n    }\n\n}","name":"Buffer A","description":"","type":"buffer"}]}