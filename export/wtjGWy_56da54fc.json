{"ver":"0.1","info":{"id":"wtjGWy","date":"1561019739","viewed":672,"name":"Tri-Planar Texture Mapping","username":"edo_m18","description":"Tri-Planar Texture Mapping.\n\nRefer to : https://gamedevelopment.tutsplus.com/articles/use-tri-planar-texture-mapping-for-better-terrain--gamedev-13821","likes":5,"published":1,"flags":0,"usePreview":1,"tags":["triplanartexturemapping"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"mat3 camera(vec3 ro, vec3 ta)\n{\n    vec3 up = normalize(vec3(0, 1, 0));\n    vec3 cw = normalize(ta - ro);\n    vec3 cu = normalize(cross(cw, up));\n    vec3 cv = normalize(cross(cu, cw));\n    return mat3(cu, cv, cw);\n}\n\nvec3 tex3D(sampler2D tex, vec3 p, vec3 n)\n{\n    vec3 blending = abs(n);\n    blending = normalize(max(blending, 0.00001));\n    \n    // normalized total value to 1.0\n    float b = (blending.x + blending.y + blending.z);\n    blending /= b;\n    \n    vec4 xaxis = texture(tex, p.yz);\n    vec4 yaxis = texture(tex, p.xz);\n    vec4 zaxis = texture(tex, p.xy);\n    \n    // blend the results of the 3 planar projections.\n    return (xaxis * blending.x + yaxis * blending.y + zaxis * blending.z).rgb;\n}\n\nfloat sdBox(vec3 p, vec3 b)\n{\n    return length(max(abs(p) - b, 0.0));\n}\n\nfloat sdSphere(vec3 p, vec3 offs, float r)\n{\n    return length(p - offs) - r;\n}\n\nfloat map(vec3 p)\n{\n    float d1 = sdSphere(p, vec3(-2, -1, 0), 1.0);\n    float d2 = sdBox(p, vec3(0.5));\n    return min(d1, d2);\n}\n\nvec3 normal(vec3 p)\n{\n    vec2 e = vec2(0.0001, 0.0);\n    float d = map(p);\n    vec3 n = d - vec3(\n        map(p - e.xyy),\n        map(p - e.yxy),\n        map(p - e.yyx));\n    return normalize(n);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy)/iResolution.y;\n\n\tvec3 col = vec3(0);\n    \n    float time = iTime * 0.5;\n    vec3 ro = vec3(cos(time) * 7., 2., sin(time) * 7.);\n    vec3 ta = vec3(0);\n    \n    vec3 p = ro;\n    vec3 ray = camera(ro, ta) * normalize(vec3(uv, 1.5));\n    \n    float d = 0., t = 0.;\n\n    for (int i = 0; i < 64; i++)\n    {\n        d = map(p);\n        if (d < 0.01) break;\n        p += ray * d;\n    }\n    \n    if (d < 0.01)\n    {\n        vec3 n = normal(p);\n        vec3 tex = tex3D(iChannel0, p, n);\n        col = tex;\n    }\n    else\n    {\n    \tvec3 sky = vec3(0.5, 0.8, 1.5) * abs(1.0 - uv.y);\n    \tcol = sky;\n    }\n    \n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}