{"ver":"0.1","info":{"id":"l3KSzy","date":"1720133827","viewed":110,"name":"Happy 4th 🧨 ","username":"gllama","description":"Achieved the goal of a crazy firework skybox but alas not the performance I need yet for what I had in mind.\n\nTechnique from [url=https://www.youtube.com/watch?v=xDxAnguEOn8]@The_ArtOfCode[/url] applied in 3D equirectangular space.\n\nLicense CC0-1.0","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["explosion","spherical","skybox","fireworks","cc0","explosions","equirectangular"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Happy 4th 🧨 - License CC0-1.0\n// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n// Technique from a @The_ArtOfCode tutorial. Go follow him 🙏\n//    => https://www.youtube.com/watch?v=xDxAnguEOn8\n//\n// Instead of flat-space we put the fireworks on a spherical surface\n// in order to create a crazy equirectangular fireworks skybox texture. \n//\n// Some things I'd like to add (but ran out of time): \n//    => Performance upgrades \n//    => Experiment w/raymarching a firework\n//    => Account for distance-to-camera in particle size\n// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n\n// Create random point on normal-sphere from float\nvec3 Hash123(float t) {\n  float x = fract(sin(t * 456.51) * 195.23);\n  float y = fract(sin((t + x) * 951.2) * 462.1);\n  float z = fract(sin((t + x + y) * 375.2) * 108.1);\n  return normalize((vec3(x, y, z)-.5)*2.);//.;\n}\n\n\n// This function let's us jump from 2D-UV to spherical 3D-XYZ position\nvec3 uvTo3D(vec2 uv) {\n    // The 2-Sphere point via UV => Lat/Long angles\n    float theta = uv.x * 2.0 * 3.14159265359; // Longitude\n    float phi = uv.y * 3.14159265359; // Latitude\n    // Trigonometry from 2-Sphere angles to an XYZ normalized [-1,1].\n    float x = sin(phi) * cos(theta);\n    float y = sin(phi) * sin(theta);\n    float z = cos(phi);\n    // { Dev Note }\n    // If you're porting this shader to a material, I strongly recommend you skip this function and just use the XYZ of your `varying vNormal` in place of the result you would get here. Should be suitable for all spheres and most round geometries\n    return vec3(x, y, z);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 col= vec3(0.);\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 pos = uvTo3D(uv);\n    pos = normalize(pos);\n    //pos+=1.;\n    //float t = fract(iTime);\n    float sTime=iTime*.5;\n    vec3 color = sin(4.0 * vec3(0.34, 0.54, 0.43) * floor(sTime)) * 0.25 + 0.75;\n\n    for(float j=0.;j<4.;j++){\n        float t=fract(sTime+(.25*j));\n        vec3 dir = Hash123(floor(sTime+(.25*j))+j);\n        \n        for(float i=0.;i<50.;i++){\n            vec3 dir2 = Hash123(floor(sTime)+i)*1.5;\n            float d = length(pos-normalize(dir+dir2*t));\n            //d=length(pos);\n            //float brightness=.001;\n            float brightness = mix(0.0005, 0.001,smoothstep(.5,0.,t));\n            brightness*=sin(t*20.+i)*.25+.75;\n            brightness*=smoothstep(1.,.05,t);\n            //if(brightness<.001){\n            //    brightness*=smoothstep(1.,.05,length(pos-dir)*1.);\n            //}\n            col+=brightness/d;\n            //col*=2.;\n            //col*=;        \n            }\n        col*=color;\n        col*=2.;\n        color = sin(4.0 * vec3(0.34, 0.54, 0.43) * floor(sTime+j)) * 0.25 + 0.75;\n    }\n    fragColor.xyz=col;\n\n}","name":"Image","description":"","type":"image"}]}