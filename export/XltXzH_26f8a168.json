{"ver":"0.1","info":{"id":"XltXzH","date":"1478517429","viewed":292,"name":"Stereo Projection","username":"soma_arc","description":"stereographic projection","likes":11,"published":1,"flags":0,"usePreview":0,"tags":["3d","mobius"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xsf3Rn","filepath":"/media/a/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png","previewfilepath":"/media/ap/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png","type":"texture","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGRr","filepath":"/media/a/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm","previewfilepath":"/media/ap/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm","type":"video","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n// from Syntopia http://blog.hvidtfeldts.net/index.php/2015/01/path-tracing-3d-fractals/\nvec2 rand2n(vec2 co, float sampleIndex) {\n\tvec2 seed = co * (sampleIndex + 1.0);\n\tseed+=vec2(-1,1);\n\t// implementation based on: lumina.sourceforge.net/Tutorials/Noise.html\n\treturn vec2(fract(sin(dot(seed.xy ,vec2(12.9898,78.233))) * 43758.5453),\n                 fract(cos(dot(seed.xy ,vec2(4.898,7.23))) * 23421.631));\n}\n\nconst float PI = 3.14159265359;\nconst float PI_2 = PI/2.;\nconst float PI_4 = PI/4.;\n\nconst float fourPI = 12.566368;\nconst float EPSILON = 0.001;\n\nconst vec3 BLACK = vec3(0);\nconst vec3 WHITE = vec3(1);\nconst vec3 LIGHT_GRAY = vec3(0.78);\nconst vec3 RED = vec3(1, 0, 0);\nconst vec3 GREEN = vec3(0, .78, 0);\nconst vec3 BLUE = vec3(0, 0, 1);\nconst vec3 YELLOW = vec3(1, 1, 0);\nconst vec3 PINK = vec3(.78, 0, .78);\nconst vec3 LIGHT_BLUE = vec3(0, 1, 1);\n\nconst float NO_HIT = 9999999.;\n\nconst int MTL_PLANE = 0;\nconst int MTL_SPHERE = 1;\nconst int MTL_CYLINDER = 2;\nint g_mtl = -1;\n\nvec4 intersectPlane(vec3 p, vec3 n, \n                    vec3 rayOrigin, vec3 rayDir, vec4 isect){\n    float d = -dot(p, n);\n    float v = dot(n, rayDir);\n    float t = -(dot(n, rayOrigin) + d) / v;\n    if(EPSILON < t && t < isect.x){\n        g_mtl = MTL_PLANE;\n    \treturn vec4(t, n);\n    }\n    return isect;\n}\n\nfloat dot2( in vec3 v ) { return dot(v,v); }\nfloat triangle( vec2 p2, vec3 a, vec3 b, vec3 c ){\n    vec3 p = vec3(p2, 0);\n    vec3 ba = b - a; vec3 pa = p - a;\n    vec3 cb = c - b; vec3 pb = p - b;\n    vec3 ac = a - c; vec3 pc = p - c;\n    vec3 nor = cross( ba, ac );\n\n    return sqrt(\n    (sign(dot(cross(ba,nor),pa)) +\n     sign(dot(cross(cb,nor),pb)) +\n     sign(dot(cross(ac,nor),pc))<2.0)\n     ?\n     min( min(\n     dot2(ba*clamp(dot(ba,pa)/dot2(ba),0.0,1.0)-pa),\n     dot2(cb*clamp(dot(cb,pb)/dot2(cb),0.0,1.0)-pb) ),\n     dot2(ac*clamp(dot(ac,pc)/dot2(ac),0.0,1.0)-pc) )\n     :\n     dot(nor,pa)*dot(nor,pa)/dot2(nor) );\n}\n\nfloat hexagram(vec2 pos, float radius){\n    float hexR = radius;\n    float rad = radians(60.);\n    float offset = radians(30.);\n    vec3 hexTP1 = vec3(hexR * cos(rad * 6. + offset), hexR * sin(rad * 6. + offset), 0);\n    vec3 hexTP2 = vec3(hexR * cos(rad + offset), hexR * sin(rad + offset), 0);\n    vec3 hexTP3 = vec3(hexR * cos(rad * 2. + offset), hexR * sin(rad * 2. + offset), 0);\n    vec3 hexTP4 = vec3(hexR * cos(rad * 3. + offset), hexR * sin(rad * 3. + offset), 0);\n    vec3 hexTP5 = vec3(hexR * cos(rad * 4. + offset), hexR * sin(rad * 4. + offset), 0);\n    vec3 hexTP6 = vec3(hexR * cos(rad * 5. + offset), hexR * sin(rad * 5. + offset), 0);\n \n    float dd = triangle(pos, hexTP1, hexTP3, hexTP5);\n    dd = min(dd, triangle(pos, hexTP2, hexTP4, hexTP6));\n\treturn dd;\n}\n\nvec4 intersectSphere(vec3 sphereCenter, float radius, \n                      vec3 rayOrigin, vec3 rayDir, vec4 isect){\n  vec3 v = rayOrigin - sphereCenter;\n  float b = dot(rayDir, v);\n  float c = dot(v, v) - radius * radius;\n  float d = b * b - c;\n  if(d >= 0.){\n    float s = sqrt(d);\n    float t = -b - s;\n    if(t <= EPSILON) t = -b + s;\n    if(EPSILON < t && t < isect.x){\n      g_mtl = MTL_SPHERE;\n      vec3 p = (rayOrigin + t * rayDir);\n      return vec4(t, normalize(p - sphereCenter));\n    }\n  }\n  return isect;\n}\n\nvec4 intersectXZCylinder(float r, vec3 center, mat3 invRotationMat,\n                         vec3 rayOrigin, vec3 rayDir, vec4 isect){\n    rayOrigin = (rayOrigin - center) * invRotationMat;\n    rayDir = rayDir * invRotationMat;\n    float a = rayDir.x * rayDir.x + rayDir.z * rayDir.z;\n    float b = 2. * ( rayOrigin.x * rayDir.x + rayOrigin.z * rayDir.z);\n    float c = rayOrigin.x * rayOrigin.x + rayOrigin.z * rayOrigin.z - r * r;\n    float d = b * b - 4. * a * c;\n    if(d >= 0.){\n        float s = sqrt(d);\n        float t = (-b - s) / (2. * a);\n        if(t <= EPSILON) t = (-b + s) / (2. * a);\n        if(EPSILON < t && t < isect.x){\n            vec3 p = (rayOrigin + t * rayDir);\n            g_mtl = MTL_CYLINDER;\n            return vec4(t, normalize(vec3(p.x, 0, p.z)));\n        }\n    }\n    return isect;\n}\n\n// catPos is upper left position of texture\nvec4 getNyanCatColor(float scale, vec2 catPos,vec2 p){\n    p /= scale;\n    p -= catPos;\n\tp = clamp(p,0.0,1.0);\n\tp.x = p.x*40.0/256.0;\n    float fr = floor( mod( 20.0*iTime, 6.0 ) );\n\tp.x += fr*40.0/256.0;\n\treturn texture( iChannel0, p);\n}\n\nvec4 getVideo(float scale, vec2 videoPos, vec2 p){\n    p -= videoPos;\n    p /= scale;\n\tp /= iResolution.xy; \n    if(p.x < 0. || 1. < p.x ||\n       p.y < 0. || 1. < p.y){\n    \treturn vec4(0);\n    }\n\treturn texture(iChannel1, vec2(1)-p);\n}\n\nconst vec3 LIGHT_DIR = normalize(vec3(0.0, -0.5, 0.5));\nconst vec3 ambientFactor = vec3(0.1);\n\nvec2 stereoProject(vec3 p){\n\treturn vec2(p.x / (1. - p.y), p.z / (1. - p.y));\n}\n\nconst vec3 SPHERE_CENTER = vec3(0, 0.5, 0);\nconst float SPHERE_RADIUS = 0.5;\nconst float CYLINDER_RADIUS = 0.01;\nvec4 getIntersection(vec3 eye, vec3 ray){\n\tvec4 isect = vec4(NO_HIT);\n    isect = intersectPlane(vec3(0, 0., 0.), vec3(0, 1, 0),\n                            eye, ray, isect);\n    isect = intersectSphere(SPHERE_CENTER, SPHERE_RADIUS,\n                            eye, ray, isect);\n    \n    mat3 m = mat3(cos(-PI_4), -sin(-PI_4), 0,\n                  sin(-PI_4), cos(-PI_4), 0,\n                  0, 0, 1);\n    isect = intersectXZCylinder(CYLINDER_RADIUS, vec3(0,1,0), m,\n                         \t\teye, ray, isect);\n    m = mat3(cos(PI_4), -sin(PI_4), 0,\n             sin(PI_4), cos(PI_4), 0,\n             0, 0, 1);\n    isect = intersectXZCylinder(CYLINDER_RADIUS, vec3(0,1,0), m,\n                           \t\teye, ray, isect);\n    return isect;\n}\n\nbool visible(vec3 eye, vec3 target){\n    vec3 v = normalize(target - eye);\n\treturn getIntersection(eye, v).x == NO_HIT;\n}\n\nvec3 diffuseLighting(const vec3 p, const vec3 n, const vec3 diffuseColor,\n                     const vec3 lightPos, const vec3 lightPower){\n  \tvec3 v = lightPos - p;\n  \tfloat d = dot(n, normalize(v));\n  \tfloat r = length(v);\n  \treturn (d > 0. && visible(p + EPSILON * n, lightPos)) ?\n    \t(lightPower * (d / (fourPI * r * r))) * diffuseColor\n    \t: BLACK;\n}\n\n\nconst vec3 CIRCLE_COLOR = RED;\nconst vec3 LINE_COLOR = BLUE;\nconst float LINE_THICKNESS = 0.05;\nvec2 gCatPos;\nvec3 getFloorColor(vec2 p, vec3 floorColor){\n    float catScale = 1.;\n    \n    float len = length(p);\n    if(1. - LINE_THICKNESS <= len &&\n       len <= 1. + LINE_THICKNESS) floorColor = CIRCLE_COLOR;\n    \n    if(- LINE_THICKNESS <= p.y &&\n       p.y <= LINE_THICKNESS) floorColor = LINE_COLOR;\n    \n\tvec4 nc = getNyanCatColor(catScale, gCatPos, p);\n    if(nc.w == 1.) floorColor = nc.xyz;\n    \n    //float d = hexagram(p - vec2(1.4, .7), 0.5);\n    //if(d < 0.01) floorColor = vec3(1, 0, 0.7);\n    \n    float videoScale = 0.005;\n    vec2 videoPos = vec2(-1.5, -2.5);\n    vec4 vc = getVideo(videoScale, videoPos, p);\n    if(vc.w == 1.) floorColor = vc.xyz;\n\n    return floorColor;\n}\n\nconst vec3 LIGHT_POS = vec3(0, 5, 1);\nconst vec3 LIGHT_POWER = vec3(300.);\n\nvec3 calcColor(vec3 eye, vec3 ray){\n    vec3 l = BLACK;\n\tvec4 isect = getIntersection(eye, ray);\n    if(isect.x != NO_HIT){\n        vec3 matColor = WHITE;\n\t\tvec3 intersection = eye + ray * isect.x;\n\t    vec3 normal = isect.yzw;\n        if(g_mtl == MTL_PLANE){\n            matColor = vec3(0.7);\n\t\t\tmatColor = getFloorColor(intersection.xz, matColor);\n        }else if(g_mtl == MTL_SPHERE){\n            matColor = vec3(0.7, 0.4, 0.4);\n            matColor = getFloorColor(stereoProject(intersection), matColor);\n        }else if(g_mtl == MTL_CYLINDER){\n            matColor = GREEN;\n        }\n      \t// diffuse lighting by directionalLight\n\t\t//vec3 diffuse =  clamp(dot(normal, LIGHT_DIR), 0., 1.) * matColor;\n       \tvec3 diffuse = diffuseLighting(intersection, normal, matColor,\n                                        LIGHT_POS, LIGHT_POWER);\n\t\tvec3 ambient = matColor * ambientFactor;\n\t\tl += (diffuse + ambient);\n    }\n\treturn l;\n}\n\nvec3 hsv2rgb(vec3 c){\n\tconst vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  \tvec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  \treturn c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n\nconst float DISPLAY_GAMMA_COEFF = 1. / 2.2;\nvec3 gammaCorrect(vec3 rgb) {\n\treturn vec3((min(pow(rgb.r, DISPLAY_GAMMA_COEFF), 1.)),\n      \t        (min(pow(rgb.g, DISPLAY_GAMMA_COEFF), 1.)),\n                (min(pow(rgb.b, DISPLAY_GAMMA_COEFF), 1.)));\n}\n\nvec3 calcRay (const vec3 eye, const vec3 target,\n              const vec3 up, const float fov,\n              const float width, const float height, const vec2 coord){\n  float imagePlane = (height * .5) / tan(radians(fov) * .5);\n  vec3 v = normalize(target - eye);\n  vec3 focalXAxis = normalize(cross(v, up));\n  vec3 focalYAxis =  normalize(cross(v, focalXAxis ));\n  vec3 center = v * imagePlane;\n  vec3 origin = center - (focalXAxis * (width  * .5)) - (focalYAxis * (height * .5));\n  return normalize(origin + (focalXAxis * coord.x) + (focalYAxis * (height - coord.y)));\n}\n\nconst float SAMPLE_NUM = 20.;\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord ){\n    float dist = 2.8;\n\t//vec3 eye = vec3(0, .5, 2);\n    vec3 eye = vec3(dist * sin(iTime), 1.5, dist * cos(iTime));\n    gCatPos = 2. * vec2(sin(iTime) - 0.5, 0);\n\n    vec3 target = vec3(0);\n    vec3 up = vec3(0, 1, 0);\n    float fov = 60.;\n    \n  \tvec3 sum = vec3(0);\n  \tfor(float i = 0. ; i < SAMPLE_NUM ; i++){\n    \tvec2 coordOffset = rand2n(gl_FragCoord.xy, i);\n          \n    \tvec3 ray = calcRay(eye, target, up, fov,\n        \t               iResolution.x, iResolution.y,\n            \t           gl_FragCoord.xy + coordOffset);\n          \n    \tsum += calcColor(eye, ray);\n  \t}\n \t vec3 col = (sum/SAMPLE_NUM);\n          \n  \tfragColor = vec4(gammaCorrect(col), 1.);\n}\n","name":"Image","description":"","type":"image"}]}