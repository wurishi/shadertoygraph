{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[{"channel":0,"type":"texture","id":"4dX3Rn","filepath":"/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}},{"channel":1,"type":"texture","id":"XsX3Rn","filepath":"/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}},{"channel":2,"type":"texture","id":"4sXGRn","filepath":"/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}},{"channel":3,"type":"keyboard","id":"4dXGRr","filepath":"/presets/tex00.jpg","sampler":{"filter":"nearest","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"}}],"code":"// Hazel Quantock 2014\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// keys\nconst int kA=65,kB=66,kC=67,kD=68,kE=69,kF=70,kG=71,kH=72,kI=73,kJ=74,kK=75,kL=76,kM=77,kN=78,kO=79,kP=80,kQ=81,kR=82,kS=83,kT=84,kU=85,kV=86,kW=87,kX=88,kY=89,kZ=90;\nconst int k0=48,k1=49,k2=50,k3=51,k4=52,k5=53,k6=54,k7=55,k8=56,k9=57;\nconst int kSpace=32,kLeft=37,kUp=38,kRight=39,kDown=40;\n\n\n// TOGGLES:\n\n// demo mode - cycle through the effects\nint kDemoMode = kD;\n\n// aesthetic toggles\nint kAnimate = kA;  float pauseTime = 3.6;\nint kPrintedPaper = kP;\nint kLensFX = kL;\n\n// lighting\nint kLighting = k0; // turn all diffuse illumination on/off (to see reflections better)\nint kAlbedo = k1;\nint kShadow = k2;\nint kDirectLight = k3;\nint kAmbientGradient = k4;\nint kAmbientOcclusion = k5;\n\n// specular\nint kSpecular = k9; // turn all specular on/off (to see diffuse better)\nint kSpecularHighlight = kQ;\nint kFresnel = kW;\nint kReflectionOcclusion = kE;\nint kReflections = kR;\n\n\n// key is javascript keycode: http://www.webonweboff.com/tips/js/event_key_codes.aspx\nbool ReadKey( int key, bool toggle )\n{\n\tfloat keyVal = textureLod( iChannel3, vec2( (float(key)+.5)/256.0, toggle?.75:.25 ), 0.0 ).x;\n\treturn (keyVal>.5)?true:false;\n}\n\n\nbool Toggle( int val, int index )\n{\n\tfloat cut = fract(iTime/30.0)*11.0;\n\tif ( !ReadKey( kDemoMode, true ) && float(index) > cut )\n\t{\n\t\treturn false;\n\t}\n\t\n\t// default everything to \"on\"\n\treturn !ReadKey( val, true );\n}\n\n\n\nvec3 tetOffset = vec3(-.1);\n\nvec3 Transform( vec3 p )\n{\n\t// fractalise space, rotate then mirror on axis\n\tconst float tau = 6.2831853;\n\tconst float phi = 1.61803398875;\n\t\n\tfloat T = pauseTime;\n\tif ( Toggle(kAnimate,-1) ) T = iTime;\n\tT *= 1.0;\n\tfloat a0 = .2*phi*(T+sin(T));\n\tfloat a1 = .05*phi*(T-sin(T))*phi;\n\tfloat c0 = cos(a0);\n\tvec2 s0 = vec2(1,-1)*sin(a0);\n\tfloat c1 = cos(a1);\n\tvec2 s1 = vec2(1,-1)*sin(a1);\n\t\n\t\n\tconst int n = 9;\n\tfloat o = 1.0;\n\n\t// centre on the first mirror\n// actually I prefer the off-centre look.\n//\tp.x -= o;\n\t\n\t// and the second\n//\tp.y += o*.75*s0.x;\n//\tp.z -= o*.75*s1.x;\n\t\n\tfor ( int i=0; i < n; i++ )\n\t{\n\t\tp.x = abs(p.x+o)-o;\n\t\tp.xy = p.xy*c0 + p.yx*s0;\n\t\tp.xz = p.xz*c1 + p.zx*s1;\n\t\t//o = o/sqrt(2.0);\n\t\to = o*.75;\n\t\t//o = max( o*.8 - .02, o*.7 );\n\t\t//o = o-1.0/float(n);\n\t\t//o = o*(float(n-i-1)/float(n-i)); // same as^\n\t\t//o = o*.8*(float(n-i-1)/float(n-i));\n\t\t//o = o*.9*(float(n-i-1)/float(n-i));\n\t\t//o = o/phi;\n\t}\n\n\treturn p;\n}\n\nfloat DistanceField( vec3 pos )\n{\n\tvec3 p = Transform(pos);\n\n\t// spheres\t\n//\treturn length(p)-.15;\n\n\t// cubes\n//\treturn max(abs(p.x),max(abs(p.y),abs(p.z)))-.14;\n\n\t// octahedra\t\n//\treturn (abs(p.x)+abs(p.y)+abs(p.z))/sqrt(3.0)-.1;\n\t\n\t// spikes! Precision issues, but wow!\n//\treturn (abs(p.z)*.05+length(p.xy)*sqrt(1.0-.05*.05))-.1;\n\n\t// stretched octahedra\n//\tvec3 s = vec3(1,1,.3);\tp = abs(p)*s/length(s);\treturn dot(p,vec3(1))-.2;\n\t\n\t// tetrahedra\n\tp -= tetOffset; // offset tetrahedra, for more variety\n\treturn max( max( p.x+p.y+p.z, -p.x-p.y+p.z), max( p.x-p.y-p.z, -p.x+p.y-p.z ) )/sqrt(3.0) -.2;\n\t\n\t// cones\n//\treturn max( -p.z, p.z*7.0/25.0+length(p.xy)*24.0/25.0 ) - .2;\n}\n\n\nvec3 Sky( vec3 ray )\n{\n\treturn mix( vec3(.8), vec3(0), exp2(-(1.0/max(ray.y,.01))*vec3(.4,.6,1.0)) );\n}\n\n\nvec3 Shade( vec3 pos, vec3 ray, vec3 normal, vec3 lightDir, vec3 lightCol, float distance )\n{\n\tvec3 uv = Transform(pos);\n\tfloat grain = texture( iChannel0, uv.xy/.2 ).r;\n\t\n\tvec3 ambient = vec3(.5);\n\tif ( Toggle(kAmbientGradient,2) )\n\t\tambient = mix( vec3(.2,.27,.4), vec3(.4), (-normal.y*.5+.5) ); // ambient\n//\t\tambient = mix( vec3(.03,.05,.08), vec3(.1), (-normal.y+1.0) ); // ambient\n\t// ambient occlusion, based on my DF Lighting: https://www.shadertoy.com/view/XdBGW3\n\tfloat aoRange = distance/10.0;\n\tfloat occlusion = max( 0.0, 1.0 - DistanceField( pos + normal*aoRange )/aoRange ); // can be > 1.0\n\tocclusion = exp2( -2.0*pow(occlusion,2.0) ); // tweak the curve\n\tocclusion *= mix(.5,1.0,pow(grain,.2));\n\tif ( Toggle(kAmbientOcclusion,1) )\n\t\tambient *= occlusion;\n\n\tfloat ndotl = max(.0,dot(normal,lightDir));\n\tfloat lightCut = smoothstep(.0,.1,ndotl);//pow(ndotl,2.0);\n\tvec3 light = vec3(0);\n\n\tif ( Toggle(kDirectLight,3) )\n\t\t\tlight += lightCol*ndotl;\n\n\tlight += ambient;\n\t\n\t\n\tfloat specularity = grain;\n\t\n\tvec3 h = normalize(lightDir-ray);\n\tfloat specPower = exp2(1.0+1.0*specularity);\n\tvec3 specular = lightCol*pow(max(.0,dot(normal,h))*lightCut, specPower)*specPower/32.0;\n\t\n\tvec3 rray = reflect(ray,normal);\n\tvec3 reflection = vec3(0);\n\t\n\tif ( Toggle(kReflections,6) )\n\t\treflection = Sky( rray );\n\t\n\t// prevent sparkles in heavily occluded areas\n\tif ( Toggle(kReflectionOcclusion,7) )\n\t\treflection *= occlusion;\n\t\n\t// specular occlusion, adjust the divisor for the gradient we expect\n\tocclusion = max( 0.0, 1.0 - DistanceField( pos + rray*aoRange )/(aoRange*dot(rray,normal)) ); // can be > 1.0\n\tocclusion = exp2( -2.0*pow(occlusion,2.0) ); // tweak the curve\n\t\n\tif ( Toggle(kReflectionOcclusion,7) )\n\t\treflection *= occlusion; // could fire an additional ray for more accurate results\n\t\n\tfloat fresnel = pow( 1.0+dot(normal,ray), 5.0 );\n\tfresnel = mix( mix( .0, .05, specularity ), .8, fresnel );\n\t\n\tif ( !Toggle(kFresnel,8) )\n\t\tfresnel = 1.0; // chrome\n\t\n\t//vec3 albedo = vec3(.1,.7,.05);//.02,.06,.1);//.04);//.6,.3,.15);//.8,.02,0);\n\tuv -= tetOffset;\n\tvec3 uv2 = uv;\n\tif ( uv2.x+uv2.z < .0 ) uv2.xz = -uv2.zx;\n\tif ( uv2.z < uv2.x ) uv2.x = uv2.z;\n\tfloat side = uv2.x+uv2.y;\n\t\n\tvec3 print = vec3(.1,.7,.05);\n\tif ( Toggle(kPrintedPaper,-1) )\n\t{\n\t\tvec3 tex = texture(iChannel2,uv.xy*.7).rgb;\n\t\tprint = mix( vec3(1,0,0), vec3(0,0,.5), smoothstep(.38,.47,tex.r) );\n\t\tprint = mix( print, vec3(1,.7,.05), smoothstep(.012,.008,abs(tex.b-.5)) );\n//\tvec3 print = mix( vec3(0,.3,0), vec3(.1,.03,.0), smoothstep(.3,.6,tex.r) );\n//\tprint = mix( print, vec3(1,.7,.05), smoothstep(.012,.008,abs(tex.b-.5)) );\n\t}\n\tvec3 albedo = mix( print, vec3(1), step(.0,side) );\n\t\n\tif ( !Toggle(kAlbedo,5) ) albedo = vec3(1);\n\t\n\tvec3 result = vec3(0);\n\tif ( Toggle(kLighting,-1) )\n\t\tresult = light*albedo;\n\n\tif ( Toggle(kSpecular,6) )\n\t{\n\t\tresult = mix( result, reflection, fresnel );\n\t\n\t\tif ( Toggle(kSpecularHighlight,9) )\n\t\t\tresult += specular;\n\t}\n\n\treturn result;\n}\n\n\n\n\n// Isosurface Renderer\n\nfloat traceStart = .1; // set these for tighter bounds for more accuracy\nfloat traceEnd = 20.0;\nfloat Trace( vec3 pos, vec3 ray )\n{\n\tfloat t = traceStart;\n\tfloat h;\n\tfor( int i=0; i < 60; i++ )\n\t{\n\t\th = DistanceField( pos+t*ray );\n\t\tif ( h < .001 || t > traceEnd )\n\t\t\tbreak;\n\t\tt = t+h;\n\t}\n\t\n\tif ( t > traceEnd )//|| h > .001 )\n\t\treturn 0.0;\n\t\n\treturn t;\n}\n\nfloat TraceMin( vec3 pos, vec3 ray )\n{\n\tfloat Min = traceEnd;\n\tfloat t = traceStart;\n\tfloat h;\n\tfor( int i=0; i < 60; i++ )\n\t{\n\t\th = DistanceField( pos+t*ray );\n\t\tMin = min(h,Min);\n\t\tif ( /*h < .001 ||*/ t > traceEnd )\n\t\t\tbreak;\n\t\tt = t+max(h,.1);\n\t}\n\t\n\treturn Min;\n}\n\nvec3 Normal( vec3 pos, vec3 ray, float distance )\n{\n\t// in theory we should be able to get a good gradient using just 4 points\n//\tvec2 d = vec2(-1,1) * .01;\n\tvec2 d = vec2(-1,1) * .5 * distance / iResolution.x;\n\tvec3 p0 = pos+d.xxx; // tetrahedral offsets\n\tvec3 p1 = pos+d.xyy;\n\tvec3 p2 = pos+d.yxy;\n\tvec3 p3 = pos+d.yyx;\n\t\n\tfloat f0 = DistanceField(p0);\n\tfloat f1 = DistanceField(p1);\n\tfloat f2 = DistanceField(p2);\n\tfloat f3 = DistanceField(p3);\n\t\n\tvec3 grad = p0*f0+p1*f1+p2*f2+p3*f3 - pos*(f0+f1+f2+f3);\n\t\n\t// prevent normals pointing away from camera (caused by precision errors)\n\tfloat gdr = dot ( grad, ray );\n\tgrad -= max(.0,gdr)*ray;\n\t\n\treturn normalize(grad);\n}\n\n\n// Camera\n\nvec3 Ray( float zoom, vec2 fragCoord )\n{\n\treturn vec3( fragCoord.xy-iResolution.xy*.5, iResolution.x*zoom );\n}\n\nvec3 Rotate( inout vec3 v, vec2 a )\n{\n\tvec4 cs = vec4( cos(a.x), sin(a.x), cos(a.y), sin(a.y) );\n\t\n\tv.yz = v.yz*cs.x+v.zy*cs.y*vec2(-1,1);\n\tv.xz = v.xz*cs.z+v.zx*cs.w*vec2(1,-1);\n\t\n\tvec3 p;\n\tp.xz = vec2( -cs.w, -cs.z )*cs.x;\n\tp.y = cs.y;\n\t\n\treturn p;\n}\n\n\n// Camera Effects\n\nvoid BarrelDistortion( inout vec3 ray, float degree )\n{\n\t// would love to get some disperson on this, but that means more rays\n\tray.z /= degree;\n\tray.z = ( ray.z*ray.z - dot(ray.xy,ray.xy) ); // fisheye\n\tray.z = degree*sqrt(ray.z);\n}\n\nvec3 LensFlare( vec3 ray, vec3 light, float lightVisible, float sky, vec2 fragCoord )\n{\n\tvec2 dirtuv = fragCoord.xy/iResolution.x;\n\t\n\tfloat dirt = 1.0-texture( iChannel1, dirtuv ).r;\n\t\n\tfloat l = (dot(light,ray)*.5+.5);\n\t\n\treturn (((pow(l,30.0)+.1)*dirt*.1 + 1.0*pow(l,200.0))*lightVisible + sky*1.0*pow(l,5000.0))*vec3(1.05,1,.95);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 ray = Ray(1.0,fragCoord);\n\t\n\tif ( Toggle(kLensFX,10) )\n\t\tBarrelDistortion( ray, .5 );\n\t\n\tray = normalize(ray);\n\tvec3 localRay = ray;\n\n\tvec2 mouse = .5-iMouse.yx/iResolution.yx;\n\tvec3 pos = 8.0*Rotate( ray, vec2(-.2,-2.5)+vec2(1.0,-6.3)*mouse );\n\t\n\tvec3 col;\n\n\tvec3 lightDir = normalize(vec3(3,2,-1));\n\t\n\tfloat t = Trace( pos, ray );\n\tif ( t > .0 )\n\t{\n\t\tvec3 p = pos + ray*t;\n\t\t\n\t\t// shadow test\n\t\tfloat s = 0.0;\n\t\tif ( Toggle(kShadow,4) ) s = Trace( p, lightDir );\n\t\t\n\t\tvec3 n = Normal(p, ray, t);\n\t\tcol = Shade( p, ray, n, lightDir, (s>.0)?vec3(0):vec3(1.1,1,.9), t );\n\t\t\n\t\t// fog\n\t\tfloat f = 1000.0;\n\t\tcol = mix( vec3(.8), col, exp2(-t*vec3(.4,.6,1.0)/f) );\n\t}\n\telse\n\t{\n\t\tcol = Sky( ray );\n\t}\n\t\n\tif ( Toggle(kLensFX,10) )\n\t{\n\t\t// lens flare\n\t\tfloat sun = TraceMin( pos, lightDir );\n\t\tcol += LensFlare( ray, lightDir, smoothstep(-.04,.1,sun), step(t,.0), fragCoord );\n\t\n\t\t// vignetting:\n\t\tcol *= smoothstep( .5, .0, dot(localRay.xy,localRay.xy) );\n\t\n\t\t// compress bright colours, ( because bloom vanishes in vignette )\n\t\tvec3 c = (col-1.0);\n\t\tc = sqrt(c*c+.05); // soft abs\n\t\tcol = mix(col,1.0-c,.48); // .5 = never saturate, .0 = linear\n\t\t\n/* oops, ran out of texture channels\n\t\t// grain\n\t\tvec2 grainuv = fragCoord.xy + floor(iTime*60.0)*vec2(37,41);\n\t\tvec2 filmNoise = texture( iChannel0, .5*grainuv/iChannelResolution[0].xy ).rb;\n\t\tcol *= mix( vec3(1), mix(vec3(1,.5,0),vec3(0,.5,1),filmNoise.x), .1*filmNoise.y );*/\n\t}\n\t\n\tfragColor = vec4(pow(col,vec3(1.0/2.2)),1);\n}\n","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":true,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"4dXXzS","date":"1402924332","viewed":809,"name":"Origami Toggles","username":"TekF","description":"Toggle demo mode auto-cycle: D, Lens effects: L, Printed paper: P, Static object: A>\nDiffuse toggles: 1,2,3,4,5 toggle all: 0>\nSpecular toggles: Q,W,E,R toggle all: 9 (more toggles in code->)","likes":27,"published":1,"flags":16,"usePreview":0,"tags":["fractal","lighting","ambientocclusion","specularocclusion"],"hasliked":0,"parentid":"","parentname":""}}