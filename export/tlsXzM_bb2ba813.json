{"ver":"0.1","info":{"id":"tlsXzM","date":"1562597130","viewed":144,"name":"Midpoint Triangle (test 2)","username":"tgsstdio","description":"Calculating the triangles/quads required to create a circular hole within a triangle ","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["triangle","circle"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// TIME FUNCTIONS see https://www.shadertoy.com/view/MtXyD2\n\n// CONTROLS NO OF QUADS PER TRI\n\n#define SUBDIVISION_LOOP_IN_SECS 7.0\n#define NO_OF_DIVISIONS 7\n\nconst int sections[NO_OF_DIVISIONS] = int[](\n    6,\n    12,\n    24,\n    30,\n    48,\n    60,        \n    96       \n);    \n\n\n// CONTROLS RADIUS OF INNER HOLE\n\n#define MID_POINT 0.3\n#define RANGE_OF_TRIG_FUNC 0.2\n#define TWO_PI 6.283185307179586476925286766559\n// in hertz (per sec)\n#define FREQUENCY 0.5\n\n// RENDER SCALE\n\nconst float UNIT_SCALE = 4.0;\n\n// https://www.shadertoy.com/view/XsXSz4\n// signed distance to a 2D triangle\nfloat sdTriangle( in vec2 p0, in vec2 p1, in vec2 p2, in vec2 p )\n{\n\tvec2 e0 = p1 - p0;\n\tvec2 e1 = p2 - p1;\n\tvec2 e2 = p0 - p2;\n\n\tvec2 v0 = p - p0;\n\tvec2 v1 = p - p1;\n\tvec2 v2 = p - p2;\n\n\tvec2 pq0 = v0 - e0*clamp( dot(v0,e0)/dot(e0,e0), 0.0, 1.0 );\n\tvec2 pq1 = v1 - e1*clamp( dot(v1,e1)/dot(e1,e1), 0.0, 1.0 );\n\tvec2 pq2 = v2 - e2*clamp( dot(v2,e2)/dot(e2,e2), 0.0, 1.0 );\n    \n    float s = sign( e0.x*e2.y - e0.y*e2.x );\n    vec2 d = min( min( vec2( dot( pq0, pq0 ), s*(v0.x*e0.y-v0.y*e0.x) ),\n                       vec2( dot( pq1, pq1 ), s*(v1.x*e1.y-v1.y*e1.x) )),\n                       vec2( dot( pq2, pq2 ), s*(v2.x*e2.y-v2.y*e2.x) ));\n\n\treturn -sqrt(d.x)*sign(d.y);\n}\n\nvec2 getMidpoint(vec2 a, vec2 b)\n{\n    vec2 dir = b - a;\n    return a + 0.5 * dir;\n}\n\nvec2 getInnerPoint(vec2 p1, vec2 p2, float ratio)\n{\n    vec2 dir = p2 - p1;\n    return p1 + (ratio * dir);\n}\n\nvec2 getRadialPoint(vec2 centre, vec2 outer, float radius)\n{\n    vec2 n = normalize(outer - centre);    \n    return centre + radius * n;\n}\n\nvec4 drawColouredQuad(vec2 uv, vec2 a, vec2 b, vec2 c, vec2 d)\n{\n    vec4 outColor = vec4(0,0,0,0);\n    // QUAD 2\n    \t// outer [i+1] -> outer[i] \n    \t// inner [i+1] -> inner[i]\n    \t// inner[i+1], inner[i], outer[i+1]\n    if (sdTriangle(a, b, c, uv) <= 0.0) {       \n    \toutColor += vec4(1,0,1,1);       \n    }            \n   \n   \t// inner[i], outer[i], outer[i+1]    \n    if (sdTriangle(a, c, d, uv) <= 0.0) {       \n    \toutColor += vec4(1,1,0,1);       \n    }        \n    return outColor;\n}\n\nvec4 drawArm(vec2 centre, vec2 uv, vec2 left, vec2 right, float radius, int division)\n{\n    vec2 left_i = getRadialPoint(centre, left, radius);\n    \n    vec2 right_i = getRadialPoint(centre, right, radius);\n    \n    vec2 top_0 = left;\n    vec2 inside_0 = left_i;\n    \n    vec4 outColor = vec4(0,0,0,0);\n\n    float offset = 1. / float(division);\n    for (int i = 1; i < division; i += 1)\n    {\n        vec2 top_1 = getInnerPoint(left, right, float(i) * offset);  \n        vec2 inside_1 = getRadialPoint(centre, top_1, radius); \n\t\toutColor += drawColouredQuad(uv, top_0, inside_0, inside_1, top_1);\n        top_0 = top_1;\n        inside_0 = inside_1;\n    } \n\n    \n    outColor += drawColouredQuad(uv, top_0, inside_0, right_i, right);\n    return outColor;\n}\n\nvec4 drawCorner3(vec2 centre, vec2 uv, vec2 right, vec2 mid, vec2 left, float radius, int noOfQuads)\n{ \n    // QUAD 1\n    vec4 outColor = vec4(0,0,0,0);      \n    outColor += drawArm(centre, uv, left, mid, radius, noOfQuads / 2);\n    outColor += drawArm(centre, uv, mid, right, radius, noOfQuads / 2);        \n    return outColor;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  \n    // SCREEN CORRECTION TO SQUARE\n    float fov = (iResolution.y / iResolution.x);\n\tvec2 uv = (fragCoord.xy / iResolution.xy);\n    uv -= 0.5;\n    uv.y *= fov;\n    \n    // SCALE \n    uv *= UNIT_SCALE;   \t     \n    \n   \n    float front = 0.4;\n    float radius = 2.0;\n    vec2 scale = vec2(1,1);    \n    vec2 radialDir = vec2(1,-1); // BOTTOM RIGHT    \n         \n    \n    float halfHeight = radius * sqrt(3.)/4.;\n    float halfWidth = radius * .5;    \n    \n    vec2 a =  vec2(0.,  halfHeight); \n    vec2 b = vec2(-halfWidth, -halfHeight);    \n    vec2 c = vec2(halfWidth, -halfHeight);  \n\n    // INTERSECTION OF MIDPOINT\n    // CENTRE CAN BE ANYTHING\n    vec2 centre = vec2(0., c.y + (halfWidth * 1. / sqrt(3.)));  \n    \n    vec2 mid_a_b = getMidpoint(a, b);\n    vec2 mid_b_c = getMidpoint(b, c);\n    vec2 mid_c_a = getMidpoint(c, a);     \n    \n    // TOP: subdividing sections by value within int array           \n    float gapTimeStep = mod(iTime, SUBDIVISION_LOOP_IN_SECS) / SUBDIVISION_LOOP_IN_SECS;         \n\n    int division = sections[int(gapTimeStep * float(NO_OF_DIVISIONS))];  \n    float innerRadius = MID_POINT + RANGE_OF_TRIG_FUNC * sin( FREQUENCY * TWO_PI * iTime);\n    \n    fragColor += drawCorner3(centre, uv, mid_c_a, a, mid_a_b, innerRadius, division / 3);\n    fragColor += drawCorner3(centre, uv, mid_a_b, b, mid_b_c, innerRadius, division / 3);\n    fragColor += drawCorner3(centre, uv, mid_b_c, c, mid_c_a, innerRadius, division / 3);    \n}","name":"Image","description":"","type":"image"}]}