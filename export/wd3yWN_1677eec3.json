{"ver":"0.1","info":{"id":"wd3yWN","date":"1600952012","viewed":179,"name":"14 - Line grid waves v2","username":"Krabcode","description":"mouse xy: change wave frequency and direction","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["grid","line","sin","rgb"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Fork of \"11 - Line grid waves\" by Krabcode. https://shadertoy.com/view/WscyDn\n// 2020-09-24 12:13:10\n\n// Based on ideas from LiveCoding - The Universe Within by Art of Code\n// https://youtu.be/3CycKKJiwis\n\n// no code police beyond this line\n\n#define tau 6.28\n\nconst float scale = 12.;\nconst float centerSize = .75;\nvec2 uv;\n\nmat2 rotate(float rad){\n    float c = cos(rad);\n    float s = sin(rad);\n    return mat2(c, -s, s, c);\n}\n\n// cubic pulse by iq\nfloat cubicPulse( float c, float w, float x )\n{\n    x = abs(x - c);\n    if( x>w ) return 0.0;\n    x /= w;\n    return 1.0 - x*x*(3.0-2.0*x);\n}\n\n// 2D sdf by iq\nfloat sdOrientedBox( in vec2 p, in vec2 a, in vec2 b, float th )\n{\n    float l = length(b-a);\n    vec2  d = (b-a)/l;\n    vec2  q = (p-(a+b)*0.5);\n    q = mat2(d.x,-d.y,d.y,d.x)*q;\n    q = abs(q)-vec2(l,th)*0.5;\n    return length(max(q,0.0)) + min(max(q.x,q.y),0.0);    \n}\n\nfloat sdRoundedLine(in vec2 p, in vec2 a, in vec2 b, float weight, float roundedness){\n    return sdOrientedBox(p, a, b, weight)-roundedness;\n}\n\nfloat sdGridLine(vec2 cellPos, vec2 a, vec2 b){\n    float lineLength = distance(a,b);\n    float line = sdOrientedBox(cellPos, a, b, 0.);\n    float smallLength = 0.0;\n    float bigLength = 2.0;\n    float closeness = smoothstep(bigLength, smallLength, lineLength); \n    float thickness = 0.05;\n    return closeness*smoothstep(thickness, 0., line);\n}\n\n// Hash without Sine\n// David Hoskins.\n\nfloat hash12(vec2 p)\n{\n    vec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec2 getGridPoint(vec2 id){\n    float t = float(iFrame) * .01;\n    vec2 p = vec2(0);\n    vec2 mRaw = iMouse.xy / iResolution.xy;\n    vec2 m = (iMouse.xy - .5 * iResolution.xy) / iResolution.y;\n    if(length(mRaw) < 0.01){\n        vec2 defaultMouseValue = vec2(.2, -.5);\n        m = defaultMouseValue;\n    }\n    float center = .45*smoothstep(scale*centerSize, 0., length(id));\n    float wave = .75 * sin(id.x*3.*m.x + id.y*3.*m.y - t);\n    p.y += center * wave;\n\treturn p;\n}\n\nfloat allLinesOnThisCell(vec2 cellPos, vec2[9] points){\n \tfloat sum = 0.0;\n    sum = max(sum, sdGridLine(cellPos, points[4], points[0]));\n    sum = max(sum, sdGridLine(cellPos, points[4], points[1]));\n    sum = max(sum, sdGridLine(cellPos, points[4], points[2]));\n    sum = max(sum, sdGridLine(cellPos, points[4], points[3]));\n    sum = max(sum, sdGridLine(cellPos, points[4], points[5]));\n    sum = max(sum, sdGridLine(cellPos, points[4], points[6]));\n    sum = max(sum, sdGridLine(cellPos, points[4], points[7]));\n    sum = max(sum, sdGridLine(cellPos, points[4], points[8]));\n    sum = max(sum, sdGridLine(cellPos, points[1], points[3]));\n    sum = max(sum, sdGridLine(cellPos, points[1], points[5]));\n    sum = max(sum, sdGridLine(cellPos, points[3], points[7]));\n    sum = max(sum, sdGridLine(cellPos, points[5], points[7]));\n    return sum;\n}\n\nvec2[9] createPointMatrix(vec2 cellId){\n \tvec2[9] pointMatrix;\n    float range = 1.;\n    int i = 0;\n    for(float x = -range; x <= range; x++){\n        for(float y = -range; y <= range; y++){\n            vec2 offset = vec2(x,y);\n            pointMatrix[i] = getGridPoint(cellId + offset) + offset;\n            i++;\n        }\n    }   \n    return pointMatrix;\n}\n\nfloat render(vec2 uv){\n    float pct = 0.12;\n    vec2 cellPos = fract(uv * scale) - .5;    \n    vec2 cellId = floor(uv * scale) + .5;\n    vec2[9] pointMatrix = createPointMatrix(cellId);\n    float lines = allLinesOnThisCell(cellPos, pointMatrix);\n    float vignette = smoothstep(centerSize*1.5, centerSize, length(uv));\n    return lines*vignette;\n}\n\nvec3 gammaCorrection(vec3 rgb){\n    float gamma = 2.2;\n    rgb = smoothstep(0., 1., rgb);\n    return pow(max(rgb, 0.), vec3(1.0/gamma));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   \tuv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec2 colorOffset = normalize(uv)*.0025*smoothstep(0.2, 0.5, length(uv));\n    vec3 col = vec3(\n        render(uv-colorOffset),\n        render(uv),\n        render(uv+colorOffset));\n    fragColor = vec4(gammaCorrection(col), 1.);\n}\n","name":"Image","description":"","type":"image"}]}