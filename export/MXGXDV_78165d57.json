{"ver":"0.1","info":{"id":"MXGXDV","date":"1720505475","viewed":31,"name":"Simple Hashing Base In 140 Chars","username":"rikr","description":"This will be my basic template whenever I want to experiment with new uint hashing ideas in shaders. Most code is explained to my future self.\n\nMade using 140 characters by Rik Riesmeijer.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["noise","template","float","tweet","onetweet","codegolf","hashing","uint"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Simple Hashing Base In 140 Chars\n// By Rik Riesmeijer, 2024 - No Rights Reserved\n\n// License: CC0 1.0 Universal - Commercial Use Allowed.\n// Copyright Has Been Released To The Public Domain. \n// More information at: CreativeCommons.org/publicdomain.\n\n// Hashing function goes here:\nuint h(uint x) { return ~x; } // This is the reason why I need \n\n// This mess is explained at length down below, it helps to play around with float bits.\n// It may seem a bit scary at first with all of these hexadecimal magic spells below,\n// however, there are many well presented tutorials that explain float specifications well.\n// Mine may not be the most helpful treatment of floats, but it is directed at myself mostly.\nvoid mainImage(out vec4 c, vec2 v) {\n    c = vec4(uintBitsToFloat(h(floatBitsToUint(v.x)) & 0x007FFFFFu | 0x3F800000u) - 1.);\n}\n\n// Uint To Float By Rik Riesmeijer, 2024\n//\n// License: CC0 1.0 Universal - Commercial Use Allowed.\n// Copyright Has Been Released To The Public Domain. \n// More information at: CreativeCommons.org/publicdomain.\n//\n// Bithacks explained:\n//\n// uint to floating point number conversion explanation with diagrams:\n// To get a floating point number from random uint bits we use IEEE-754 binary32 specs.\n// IEEE-754 binary32 floating point number specifications are guarranteed in GLSL.\n// The specification is as follows:\n//    a) The first bit is taken to be the sign of the floating point value.\n//    b) The second bit and the 8 bits that follow the sign bit are taken\n//       to be the exponent bits of the floating point value (Order Of Magnitude).\n//    c) The remaining bits are taken to be the the mantissa of the float\n//       (Fractional factor for the exponent bits on the half open unit interval, so\n//       roughly spoken having value between 0 and 1). The mantissa is interpreted\n//       as having an omitted leading 1 that translates the value that is used\n//       to the interval between 1 and 2.\n//\n// The float's value is then given by:\n//      value = sign * (1.0 + mantissa) * pow(2.0, exponent - halfway exponent).\n//\n// To extract only the mantissa bits of the uint we take the mask made out of all of the\n// bits that come after the ninth bit up to the thirty second bit of the uint.\n//\n// So, looking at the binary mask in a diagram laying out the IEEE-754 binary32 specs, we have:\n// Bit location:     | 0    | 1 | 2 | 3 | 4 | 5 | 6 | 7     | 8 | 9 | 10 | 11  | 12 | 13 | 14 | 15 | 16 | 17 | 18 | 19 | 20 | 21 | 22 | etc.\n// Bit mask value:   | 0    | 0 | 0 | 0 | 0 | 0 | 0 | 0     | 0 | 1 | 1  | 1   | 1  | 1  | 1  | 1  | 1  | 1  | 1  | 1  | 1  | 1  | 1  | etc.\n// Hexadecimal 0x:   |-First Hexchar: 0-|-Second Hexchar: 0 |-Third Hexchar: 7-|-Fourth Hexchar: F-|-Fifth Hexchar: F--| etc.\n// Bytes:            |------I----First Byte: Hex = 00------ |---I------Second Byte: Hex = 7F-------|---Third Byte: Hex = FF--Etc.\n// Section       :   | Sign | Exponent                          | Mantissa                           Mantissa etc.\n//\n// Therefore our bitmask to extract the mantissa bits using bitwise logical AND\n// has hexadecimal representation given by the 0x formatted string: 0x007FFFFFu.\n// More simply put, all bits zero except for the last 23 bits.\n//\n// Similarly we figure out that 1.0 is represented with: 0x3F800000u.\n//\n// So we can extract the fractional part and give it the right leading bits to configure it\n// into a floating point number between 1.0 and 2.0, we do this by taking the logical OR with these bits.\n// So then we get our desired floating point value on the unit interval by subtracting 1.0.\n// Done as a floating point operation.\n//\n// This concludes how I'm coding the floating point number synthesis from an input uint value.\n// Implementation with intermediate hashing stage with hashing function h(.):\n//\n// uintBitsToFloat(h(floatBitsToUint(v.x)) & 0x007FFFFFu | 0x3F800000u) - 1.\n//\n// End of explaining glsl float specifications.\n//","name":"Image","description":"","type":"image"}]}