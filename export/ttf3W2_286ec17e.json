{"ver":"0.1","info":{"id":"ttf3W2","date":"1557666922","viewed":278,"name":"Particle walls","username":"ciphered","description":"Messing up with the raytracing algorithm, not looking really good","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raymarchingraytracing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdfGzn","filepath":"/media/a/894a09f482fb9b2822c093630fc37f0ce6cfec02b652e4e341323e4b6e4a4543.mp3","previewfilepath":"/media/ap/894a09f482fb9b2822c093630fc37f0ce6cfec02b652e4e341323e4b6e4a4543.mp3","type":"music","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/**\n * Basic raytracing algorithm \n */\n\n#define NEAR 0.001\n#define FAR 100.0\n#define FOG 0.00008\n#define FOV 0.5\n#define RT_ITERATIONS 128\n#define TARGET vec3(0.0)\n#define PI 3.14159265359\n\n\n\nfloat glow = 0.0, ttpi;\n\nvec3 cw, cu, cv, rd;\nvec3 np;\n\nvec2 e = vec2(0.00035, -0.00035);\n\n// useful functions\nmat2 r2 (float r) { return mat2(cos(r), sin(r), -cos(r), cos(r)); }\nfloat noise (vec3 p) {\n\tvec3 ip = floor(p),\n         s = vec3(7.0, 157.0, 113.0);\n    p-= ip;\n    vec4 h = vec4(0.0, s.yz, s.y+s.z) + dot(ip, s);\n    h = mix(fract(sin(h)*43758.5), fract(sin(h+s.x)*43758.5), p.x);\n    h.xy = mix(h.xz, h.yw, p.y);\n    return mix(h.x, h.y, p.z);\n}\n\n\n/**\n * Distance functions for primitives \n */\n// box\nfloat bo (vec3 p, vec3 r) { \n    p = abs(p)-r; \n    return max(max(p.x, p.y), p.z); \n}\n// rounded box\nfloat roBo (vec3 p, vec3 b, float r) {\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0)) - r\n         + min(max(d.x,max(d.y,d.z)),0.0); // remove this line for an only partially signed sdf \n}\n// capsule, a, b are the extremity points of the capsule\nfloat ca (vec3 p, vec3 a, vec3 b, float r) {\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\n\n/**\n * this function generates a scene, distance based\n */\nvec2 fb (in vec3 p) {\n    /*vec2 h, t = vec2(ca(p+vec3(0.0,2.0,0.0), 4.0, 1.0), 5.0);\n    t.x = min(bo(abs(p)-vec3(4.8,4.8,4.8), vec3(1.2, 1.2, 1.2)), t.x);\n    \n    h = vec2(ca(p, 10.0, 0.2), 3.0);\n    \n    t = t.x < h.x ? t : h;\n    */\n    \n    vec2 t = vec2(roBo(p, vec3(3.9, 3.9, 3.9), 0.8), 5.0);\n    \n    t.x = max(-ca(p, vec3(-8.0, 0.0, 0.0), vec3(8.0, 0.0, 0.0), 3.0), t.x);\n    t.x = max(-ca(p, vec3(0.0, -8.0, 0.0), vec3(0.0, 8.0, 0.0), 3.0), t.x);\n    t.x = max(-ca(p, vec3(0.0, 0.0, -8.0), vec3(0.0, 0.0, 8.0), 3.0), t.x);\n    \n    t.x*= 0.5;\n    \n    glow+= 0.1 / (0.1+t.x*t.x*100.0);\n    \n    return t;\n}\n\n\n/**\n * MAPPING FUNCTION\n */\nvec2 mp (vec3 p) {\n    float bass = texture(iChannel0, vec2(0.0, 0.0)).r;\n    \n    p.xy*= r2(iTime/3.0);\n    \n    p.z = mod(p.z-iTime*9.0, 20.0)-8.0;\n    \n    // this breaks the ray marching, giving the particule texture to the scene\n    p.xy*= r2(p.z * (iTime*bass));\n    \n    np = p;\n    \n    float s = sin(p.z*2.0-5.0)*0.1;\n    \n    for (float i = 0.0; i < 7.0; i++) {\n    \tnp = abs(np) - vec3(2.8, 1.0-bass*1.2, 2.5);\n        np.xz*= r2(0.1+s);\n    }\n    \n    vec2 h, t = fb(np.xyz);\n    \n    return t;\n}\n\n\n/**\n * RAY TRACING METHOD \n */\nvec2 tr (in vec3 ro, in vec3 rd) {\n    vec2 h, t = vec2(0.1);\n    for (int i = 0; i < RT_ITERATIONS; i++) {\n        h = mp(ro+rd*t.x);\n        if (h.x < NEAR || t.x > FAR) break;\n        t.x+= h.x;\n        t.y = h.y;\n    }\n    if (t.x > FAR) t.x = 0.0;\n    return t;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv-= 0.5;\n    uv/= vec2(iResolution.y/iResolution.x, 1.0);\n    \n    // a bit naive but enough\n    float bassLevel = (texture(iChannel0, vec2(0.0, 0.0)).r+texture(iChannel0, vec2(0.2, 0.0)).r)/2.0;\n    \n    // time \n    float tt = mod(iTime, 100.0),\n          bb = 0.5 + clamp(sin(tt), -0.5, 0.5);\n    \n    // background\n    vec3 col, fo, ld = normalize(vec3(0.1,0.5,-0.5));\n    col = fo = vec3(0.4)*cos(iTime/8.0) + vec3(0.1) * (1.0 - length(uv)*1.5 - 0.1);\n    \n    // camera \n    ttpi = mod(tt, 2.0*PI);\n    ttpi = ttpi > PI ? 2.0*PI-ttpi : ttpi;\n    //vec3 ro = vec3(cos(ttpi)*15.0, 0.0, sin(ttpi)*16.0);\n    vec3 ro = vec3(0.0,0.0,20.0);\n    cw = normalize(TARGET-ro);\n    cu = normalize(cross(cw, vec3(0.0, 1.0, 0.0)));\n    cv = normalize(cross(cu, cw));\n    rd = mat3(cu, cv, cw) * normalize(vec3(uv, FOV));\n    \n    // raytracer algorithm is called\n    vec2 sc = tr(ro, rd);\n    \n    // distance camera / object\n    float d = sc.x;\n    \n    // if d > 0, we compute the color of the pixel based on the scene \n    if (d > 0.0) {\n   \t\tvec3 po = ro + rd*d,\n             no = normalize(e.xyy*mp(po+e.xyy).x + e.yyx*mp(po+e.yyx).x + e.yxy*mp(po+e.yxy).x + e.xxx*mp(po+e.xxx).x),\n             al = mix(vec3(1.0-d/12.0, 1.0,1.0), vec3(1.0, 0.0, 0.32), 0.0);\n        \n        if (sc.y < 5.0) {\n            al = mix(vec3(1.0, 1.0,1.0), vec3(1.0, 0.0, 0.8),abs(cos(iTime/5.0)));\n        }\n        \n        // lighting\n        \n        float dif = max(0.0, dot(no, ld)),\n              aor = d / 50.0,\n              ao = exp2(-2.0*pow(max(0.0, 1.0-mp(po+no*aor).x/aor), 2.0)),\n              spo = exp2(1.0+3.0*noise(np/vec3(0.4, 0.8, 0.6)) + noise(np/vec3(0.2))),\n              fr = pow(1.0+dot(no, rd), 4.0);\n        \n        vec3 sss = vec3(1.5) * smoothstep(0.0, 1.0, mp(po+ld*0.4).x/0.4),\n             sp = vec3(1.0) * pow(max(dot(reflect(-ld, no), -rd), 0.0), spo);\n            \n        \n        col = mix(sp + al * (0.8*ao+0.2) +al*(dif+sss), fo, min(fr, 0.5));\n        col = mix(col, fo, 1.0 - exp(-FOG*d*d*d));\n    }\n    \n    // we add the glow\n    //bassLevel*= bassLevel;\n    col+= vec3(0.0,.9,.3)*glow*0.05*bassLevel;\n    \n    // Output to screen\n    fragColor = vec4(col, 1.0);\n    \n}","name":"Image","description":"","type":"image"}]}