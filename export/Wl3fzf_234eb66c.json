{"ver":"0.1","info":{"id":"Wl3fzf","date":"1615054593","viewed":140,"name":"procedural stone texture (vlll)","username":"valalalalala","description":"This stone texture is based of some small modifications to my brick texture. I spent some time on and off trying to color per brick before giving up.... \n\nFeedback appreciated...","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["procedural","raymarching","texture","stone"],"hasliked":0,"parentid":"WtdfD8","parentname":"procedural brick texture vlllll"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"        /////////////////////////////////////////////////////////////////\n       //                                                            ////\n      //  \"procedural stone texture\"                                // //\n     //                                                            //  //\n    //  Modification of the brick texture. I wanted to color      //   //\n   //  stone differently, but my brain kept sliding off it,      //    //\n  //  so here it is just to get it off my plate.                //     //\n //                                                            //     //\n////////////////////////////////////////////////////////////////     // \n//                                                            //    //\n// Creative Commons Attribution-NonCommercial-ShareAlike      //   //\n// 3.0 Unported License                                       //  //\n//                                                            // //\n// by Val \"valalalalala\" GvM ðŸ’ƒ 2021                          ////\n//                                                            ///\n////////////////////////////////////////////////////////////////\n\n// Some other textures:\n//\n// iq voronoi rocks:     https://www.shadertoy.com/view/MsXGzM\n// shane tunnel:         https://www.shadertoy.com/view/XdcfDf\n// shane voronoi rocks:  https://www.shadertoy.com/view/ldtGWj\n// fabrice pebbles:      https://www.shadertoy.com/view/3dcyzS\n\n////////////////////////////////////////////////////////////////\n// scene definition\n\nconst vec3 ball_center  = vec3( .0, .6, .0 );\nconst vec3 light        = vec3( .0, 5., .0 );\n\nconst vec3 mortar2      = vec3( .6 );\nconst vec3 mortar       = vec3( .7, .5, .4 );\n\nconst vec3 stone2       = vec3( .4 );\nconst vec3 stone        = vec3( .6, .4, .3 );\n\nconst float scale_plane = 1.1;\nconst float scale_ball  = 1.2;\n    \n////////////////////////////////////////////////////////////////\n// stone making \n\nfloat everyOtherRow( in float value, in float row ) {\n    return mod( value + .5 * step( 1., mod( row, 2. ) ), 1. );\n}\n\nfloat noisyInset( in vec2 p, in vec2 scale, in vec2 inOut ) {\n    vec2 s = scale * p;\n    vec2 f = fract( s );\n    vec2 i = s - f;\n    \n    float h = hash( i.xy );\n    \n    if ( h > .5 ) {\n        f.x = everyOtherRow( f.x, i.y );\n    }\n    \n    f.xy -= .5;\n    f.xy *= rotate2d( TAU * h );\n    f.xy += .5;\n        \n    vec2 q = min( f, 1. -f );\n    return smoothstep( inOut.x, inOut.y, min( q.x,q.y ) );\n}\n\nfloat stoner( vec3 p, float displacement ) {\n    vec4 theF = fbm( p + 0.33, vec3( .10, .03, .01 ), vec3( 3., 9., 23. ) );\n    float f = theF.w;\n    float a = f * .5 + .5;\n\n    vec2 brickSize = 3.5 * vec2( .6, .6 )  + f * 2.; \n    vec2 brickGap  = 1.2 * vec2( .1, .01 ) + f * .2;\n   \n    displacement *= .8 + f * 3.3;\n    return displacement * ( .2 * noisyInset( p.xy, brickSize, brickGap ) + a * 2.2 );\n}\n\n////////////////////////////////////////////////////////////////\n// the scene\n\nfloat rockPlane( vec3 p ) {\n    float displacement = .38;\n    return p.y + 1. + stoner( p.xzy * scale_plane, displacement );\n}\n\nfloat rockBall( vec3 p, float bd ) {\n    float displacement = .36;\n    return bd - 2. + stoner( p * scale_ball, displacement );\n}\n\nfloat map( vec3 p ) {\n    float fudge = .77;\n\n    float plane = p.y > -.0 ? 1. : rockPlane( p ) * fudge;\n    \n    float ballThreshold = 2.5;\n    float bd = length( p - ball_center );\n    float ball = bd > ballThreshold ? ballThreshold : rockBall( p, bd ) * fudge;\n    \n    return min( plane, ball );// * fudge;\n}\n\n////////////////////////////////////////////////////////////////\n\nvec3 colorForPoint( vec3 p ) {\n#if 0\n    // gave up trying to color per block...\n    vec2 i = floor( p.xy );\n    vec2 j = abs( p.xy );\n    float n = fract( j.x + j.y );\n    return vec3(n);\n    \n    if ( n < .25 ) return vec3( 1., .0, .0 );\n    if ( n < .50 ) return vec3( .0, 1., .0 );\n    if ( n < .75 ) return vec3( .0, .0, 1. );\n    return vec3( 1., 1., 0 );\n#endif\n    return stone;\n}\n\nvec3 colorHit( vec3 eye, vec3 direction, float d ) {\n    vec3 p = eye + direction * d;\n    vec3 n = mapNormal( p, d );\n    \n    /////////////////////////////\n    // lighting\n        \n    vec3 q = p + n * 2. * MARCH.y;\n    vec3 toLight = light - q + eye;\n    vec3 toLightN = normalize( toLight );\n    float lightD = length( toLight );\n    \n    float l = dot( n, toLightN );\n    \n    // bit o' occlussion....\n    \n    float occlussion = march( q, toLightN );\n    l *= 1. - .4 * step( occlussion, lightD );\n    l = clamp( l, .0, 1. );\n    \n    /////////////////////////////\n    /// gross way to do this...\n    \n    if ( p.y > -.75 ) {\n        vec3 bo = p - ball_center;\n        float bd = dot( bo, bo );\n        vec3 color = colorForPoint( p * scale_ball );\n        return l * mix( color, mortar, step( bd, 2.2 ) );\n        return l * mix( color, mortar, step( bd, 2.78 ) );\n    } else {\n        vec3 color = colorForPoint( p.xzy * scale_plane );\n        return .7 * l * mix( color, mortar, step( p.y, -1.58 ) );\n    }\n}\n\nvec3 colorMiss( in vec2 uv ) {\n    float s = stoner( uv.xyx * 3.3, .44 );\n    vec3 c = mix( stone, mortar, step( .64, s ) );\n    return c * s;\n    return stoner( uv.xyx * 3.3, .44 ) * stone;\n}\n\n////////////////////////////////////////////////////////////////\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    fragColor = boilerPlateMain( fragCoord, iMouse, iResolution, iTime );\n}\n\n// EOF\n////////////////////////////////////////////////////////////////","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"////////////////////////////////////////////////////////////////\n// cool hack for forward declarations https://www.shadertoy.com/view/WldSRj\n#ifndef HW_PERFORMANCE\n#define _SHADERTOY_TAB_COMMON\n#endif\n\n///////////////////////////////////////////////////////////////////\n// scene controls\n\n#define CAMERA_DISTANCE 2.9\n#define CAMERA_ZOOM     1.\n\n////////////////////////////////////////////////////////////////\n// try to hide the boilerplate a little\n\n////////////////////////////////////////////////////////////////\n// handy constants\n\n#define ZED   .0\n#define PI    3.141592653589793 \n#define TAU   6.283185307179586\n\n///////////////////////////////////////////////////////////////////\n// ray marching\n\nconst vec3 MARCH = vec3( .0, .01, 88. );\n\n#define NX1 map( p - MARCH.yxx * d )\n#define NX2 map( p - MARCH.xyx * d )\n#define NX3 map( p - MARCH.xxy * d )\n\nfloat map( vec3 p );\n#ifdef _SHADERTOY_TAB_COMMON\nfloat map( vec3 p ) { return 33.44; }\n#endif\n\nfloat march( vec3 eye, vec3 direction ) { \n    float total = .0, now;\n    vec3 current = eye;\n    for( int i = 0 ; i < int( MARCH.z ) ; i++ ) {\n        total += ( now = map( current ) );\n        if ( abs( now ) < MARCH.y || total > MARCH.z ) break;\n        current += now * direction;\n    }\n    return total + MARCH.z * step( MARCH.z, total );\n}\n\nvec3 mapNormal( vec3 p, float d ) {\n    return normalize( map( p ) - vec3( NX1, NX2, NX3 ) );\n}\n\n////////////////////////////////////////////////////////////////\n\n#define FROM_SCREEN(uv,R)  ( ( 2. * (uv) - (R).xy ) / (R).y )\n#define MAP_11_01(v)       ( (v) * .5 + .5 )\n\nvec2 trig( float a ) {\n    return vec2( cos( a  * TAU ), sin( a * TAU ) );\n}\n\n////////////////////////////////////////////////////////////////\n// rotation \n\nmat2 rotate2d( float angle ) {\n    vec2 t = trig( angle );\n    return mat2( t.x, -t.y, t.y, t.x ); // //c-ssc\n}\n\nmat2 rotate2dQuarter() {\n    return mat2( .7071, -.7071, .7071, .7071 );\n}\n\nmat2 rotate2dHalt() {\n    return mat2( .0, -1., .0, 1. );\n}\n\n////////////////////////////////////////////////////////////////\n// basic camera controls\n\n// zab,xZup,yXz | zxy:ab,zup,xz\nmat3 makeCamera( vec3 a, vec3 b, float roll ) {\n    vec3 up = vec3( trig( roll ).yx, ZED );\n\tvec3 z = normalize( b - a );\n\tvec3 x = normalize( cross( z, up ) );\n\tvec3 y = normalize( cross( x, z ) );\n\treturn mat3( x, y, z );\n}\n\nvec3 cameraEye( float viewDistance, vec4 mouse, vec3 resolution, float time ) {\n    vec2 ms = mouse.z > .0 ? mouse.xy / resolution.xy : vec2( time *.1, .2 );\n    vec2 t = viewDistance * trig( ms.x );\n    float ey = 1.2 * viewDistance * sin( ms.y  * 1.33 - .44);\n    return vec3( t.x, ey, t.y );\n}\n\n////////////////////////////////////////////////////////////////\n// hash and noise\n\nvec2 hash2( in vec2 uv ) {\n    vec3 q = fract( uv.xyx * vec3( 19.191, 53.733, 73.761 ) );\n    q += dot( q, q + vec3( 41.557, 23.929, 37.983 ) );\n    return fract( vec2( q.x * q.y, q.y * q.z ) );\n}\n\nfloat hash( in vec2 uv ) {\n    vec2 q = hash2( uv );\n    return fract( q.x + q.y );\n}\n\nfloat hash( in vec3 p ) {\n    p = fract( p * vec3( 19.191, 53.733, 73.761 ) );\n    p += dot( p, p + vec3( 41.557, 23.929, 37.983 ) );\n    return fract( ( p.x +  p.y ) * p.z );\n}\n\n// from iq's https://www.shadertoy.com/view/4sfGzS\nfloat noise( in vec3 x )\n{\n    vec3 i = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    return mix(mix(mix( hash(i+vec3(0,0,0)), \n                        hash(i+vec3(1,0,0)),f.x),\n                   mix( hash(i+vec3(0,1,0)), \n                        hash(i+vec3(1,1,0)),f.x),f.y),\n               mix(mix( hash(i+vec3(0,0,1)), \n                        hash(i+vec3(1,0,1)),f.x),\n                   mix( hash(i+vec3(0,1,1)), \n                        hash(i+vec3(1,1,1)),f.x),f.y),f.z);\n}\n\nfloat noise( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n\tvec2 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( dot( hash2( i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ), \n                     dot( hash2( i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\n                mix( dot( hash2( i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ), \n                     dot( hash2( i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);\n}\n\n////////////////////////////////////////////////////////////////\n// fractional brownian noise\n\nvec4 fbm( vec3 p, vec3 weights, vec3 scales ) {\n    vec4 n = vec4(\n        noise( p * scales.x ),\n        noise( p * scales.y ),\n        noise( p * scales.z ),\n        .0\n    );\n    n.w = dot( n.xyz, weights );\n    return n;\n}\n\n////////////////////////////////////////////////////////////////\n\nvec3 colorHit( vec3 eye, vec3 direction, float d );\nvec3 colorMiss( in vec2 uv );\n#ifdef _SHADERTOY_TAB_COMMON\nvec3 colorHit( vec3 eye, vec3 direction, float d ) { return vec3( 1. ); }\nvec3 colorMiss( in vec2 uv ) { return vec3( .0 ); }\n#endif\n\nvec4 boilerPlateMain( in vec2 fragCoord, vec4 mouse, vec3 resolution, float time ) {\n    vec2 uv = FROM_SCREEN( fragCoord, resolution );\n\n    ////////////////////////////////////////////////////////////////\n\n    vec3 eye = cameraEye( CAMERA_DISTANCE, mouse, resolution, time );\n    vec3 b = vec3( ZED );\n    vec3 ab = normalize( makeCamera( eye, b, .0 ) * vec3( uv, CAMERA_ZOOM ) );\n    \n    ////////////////////////////////////////////////////////////////\n\n    float d = march( eye, ab );\n    float hit = step( d, MARCH.z * .5);\n\n    vec3 color = mix( colorMiss( uv ), colorHit( eye, ab, d ), hit );\n    color = mix( color, vec3( .22 ), pow( d / MARCH.z, .33 ) * hit );\n\n    ////////////////////////////////////////////////////////////////\n    \n    return vec4( color, 1. );\n}\n\n// EOF\n////////////////////////////////////////////////////////////////","name":"Common","description":"","type":"common"}]}