{"ver":"0.1","info":{"id":"ttGczW","date":"1610580209","viewed":506,"name":"Super Simple Fluid texelFetch()","username":"niels747","description":"Staggered pressure and velocity grids. Divergence is not zero locally, fluid is compressible. Mass is conserved, because when the flow converges, the pressure will increase and it will have to diverge again to get back to 0 pressure. \n","likes":11,"published":1,"flags":32,"usePreview":0,"tags":["simulation","fluid","convection"],"hasliked":0,"parentid":"3lyczW","parentname":"Simple Water Wave Simulation"},"renderpass":[{"inputs":[{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec4 fluid = texture(iChannel0,uv);\n    \n    vec2 normMouse = iMouse.xy / iResolution.xy;\n    \n    // temperature view\n    fragColor = vec4(hsv2rgb(vec3(-fluid.w*0.31+0.3,1.0,1.0)),1.0); // hue\n    //fragColor = vec4(1.0 + fluid.w, 1.0 - abs(fluid.w),1.0 - fluid.w, 1.0); // red and blue\n    \n    // presure view\n    fluid.z*=4.;\n    //fragColor = vec4(1.0 + fluid.z, 1.0 - abs(fluid.z),1.0 - fluid.z, 1.0); // red and blue\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"/*\nx = horizontal velocity\ny = vertical velocity\nz = pressure\nw = temperature\n*/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 iRes = ivec2(iResolution);\n    ivec2 center = ivec2(fragCoord);\n    ivec2 right  = center + ivec2(1,0);\n    ivec2 up     = center + ivec2(0,1);\n    \n    if(right.x > iRes.x-1) // needed for wrapping texture horizontally with texelFetch\n    right.x = 0;\n   \n    \n    vec4 t = texelFetch(iChannel0,center,0);\n    \n    // velocity changes proportional to pressure gradient across point\n    t.x += t.z - texelFetch(iChannel0,right,0).z; \n    t.y += t.z - texelFetch(iChannel0,up,0).z; \n    \n    t.y += t.w * 0.002; //0.002 Buoyancy force\n    \n    t.x *=0.998; // drag to prevent too high velocities\n    t.y *=0.998; // simulation is only stable and accurate if x and y velocies < 1.0 (fragments/iteration)\n    \n\n    // mouse adds heat\n    if(length(iMouse.xy - fragCoord) < 30.1 && iMouse.z > 0.5){\n        t.w += 0.1;\n    }\n    \n    // heating and cooling\n   // if(center.x > 10 && center.x < iRes.x - 11){\n    if(center.y < 200 && center.y > 5)\n    t.w += 0.0005; // heat at bottem\n    else if(center.y > iRes.y - 200 && center.y < iRes.y - 5)\n    t.w -= 0.0005; // cool at top\n  //  }\n  \n  \n  if(iTime < 1.0 && length(vec2(center - iRes/2)) < 10.) // add some slight asymmetry to get it started\n  t.w -= 0.01;\n    \n    t.w = clamp(t.w,-1.0,1.0); // constrain temperature\n    \n    if(center.y < 1 || center.y > iRes.y - 2){ // top and bottem\n    //if(center.x < 1 || center.x > iRes.x - 2 || center.y < 1 || center.y > iRes.y - 2){ // all 4 sides\n    t.x = t.y = 0.0; // set velocity to 0 at boundaries\n    }\n\n    fragColor = vec4(t.x ,t.y, t.z, t.w);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"/*\nx = horizontal velocity\ny = vertical velocity\nz = pressure\n*/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    ivec2 iRes = ivec2(iResolution);\n    ivec2 center = ivec2(fragCoord);\n    ivec2 left  = center + ivec2(-1,0);\n    ivec2 down     = center + ivec2(0,-1);\n    \n    \n    if(left.x < 0) // needed for wrapping texture horizontally with texelFetch\n    left.x = iRes.x-1;\n    \n\nvec4 t = texelFetch(iChannel0,center,0);\n   \n   // pressure changes proportional to the net inflow - outflow of the cell\n   t.z += (texelFetch(iChannel0,left,0).x - t.x + texelFetch(iChannel0,down,0).y - t.y) *0.499; // multiplier has to be < 0.5\n\n   fragColor = vec4(t.x, t.y, t.z, t.w);\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"// Advection\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\nvec4 t = texelFetch(iChannel0,ivec2(fragCoord),0);\n\nvec2 center = fragCoord/iResolution.xy;\nvec2 backtracedPos = center - t.xy/iResolution.xy;\n\n    fragColor = texture(iChannel0,backtracedPos);\n}","name":"Buffer C","description":"","type":"buffer"}]}