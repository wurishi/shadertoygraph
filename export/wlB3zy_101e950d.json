{"ver":"0.1","info":{"id":"wlB3zy","date":"1559999522","viewed":189,"name":"Primordial Goo","username":"jblanper","description":"I modified the ray marching algorithm slightly to get a blending effect between the the main orb and the repeated blobs. I also used smooth union operators for this effect.","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["3d","raymarching","sdf","repetition","boolean"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"mat2 rotate(float a) {\n  return mat2(cos(a), -sin(a), sin(a), cos(a));\n}\n\nfloat smin( float a, float b, float k ) {\n  float h = max( k-abs(a-b), 0.0 )/k;\n  return min( a, b ) - h*h*h*k*(1.0/6.0);\n}\n\nfloat sphereSDF (vec3 p, float r) {\n  return length(p) - r;\n}\n\nfloat displacement(vec3 p, float n) {\n  return sin(p.x * n) * cos(p.y * n + n) - sin(p.z + p.y * n);\n}\n\nfloat map (vec3 p) {\n  vec3 p1 = p;\n  p1.xz *= rotate(iTime * .3);\n  p1.yz *= rotate(iTime * .2);\n\n  float s1 = sphereSDF(p1, .6);\n  s1 += sin((p1.x + p1.y * p1.z) * (3.14 * 10.) - iTime * 2.) * .015 - sin((p1.x - p1.y * p1.z) * (3.14 * 12.) - iTime) * .01;\n\n  p.z -= iTime * .2;\n  vec3 c = vec3(1.4, 0., 2.);\n  p = mod(p, c) - .5 * c;\n\n  float s2 = sphereSDF(p, .3);\n  s2 += sin((p.x + p.y * p.z) * 20. + iTime * 2.) * .03 + cos(length(p.x - p.y * p.z) * 65. - iTime) * .01;\n\n  return smin(s1 * .5 + displacement(p1, 7. * (sin(p1.x * p1.z + iTime * .5) * .5 + .8)) * .1, s2 * .3, .3);\n  //return smin(s1 * .5 + displacement(p1, 7. * (sin(p1.x * p1.z + iTime * .5) * .5 + .8)) * .1, s2 * .8, .3);\n}\n\nfloat trace (vec3 ro, vec3 rd) {\n  float e = .001;\n  float d = e * 2.;\n  float t = 0.;\n  for (int i = 0; i < 40; i++) {\n    if (d < e || t > 50.) continue;\n    d = map(ro + rd * t);\n    t += d * (sin(iTime * .2) * .3 + .7);\n    //t += d * (sin(iTime * .2) * .6 + .8);\n  }\n  return t;\n}\n\nvec3 getNormal (vec3 p) {\n  float d = map(p);\n  vec2 e = vec2(.01, 0.);\n\n  return normalize(d - vec3(\n    map(p - e.xyy),\n    map(p - e.yxy),\n    map(p - e.yyx)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 uv = (fragCoord.xy / iResolution.xy) * 2.0 - 1.0;\n  uv.x *= iResolution.x / iResolution.y;\n  vec3 color;\n\n  // camera\n  vec3 ro = vec3(0., 1., 3.);\n  vec3 rd = normalize(vec3(uv.x, uv.y - 1., -3.));\n  ro.xz *= rotate(iTime * .1);\n  rd.xz *= rotate(iTime * .1);\n\n  float t = trace(ro, rd);\n  vec3 p = ro + rd * t;\n\n  // texture\n  color += sin(length(p + cos(atan(p.x, p.z * p.z) * 5.)) * 30.) * (t * .08);\n  color *= cos(dot(p.xy, uv) * 5. - iTime) * .5;\n\n  // lighting\n  vec3 light = normalize(vec3(3., 2., 1.));\n  //light.xz *= rotate(iTime * .5);\n  vec3 nor = getNormal(p);\n  float lOcclusion = .8;\n  float ambient = clamp(.5 + .5 * nor.y, 0., 1.) * .3;\n  float diffuse = clamp(dot(nor, light), 0., 1.) * .8;\n  vec3 half_way = normalize(-rd + light);\n  float specular = pow(clamp(dot(half_way, nor), 0.0, 1.0), 16.) * diffuse * 1.2;\n\n  color += (ambient + diffuse + specular) * lOcclusion * vec3(.5, .6, .2);\n  color += vec3(.3 + p.y * .5, .2 + p.x * .2, .8 + p.z * .2) * .6;\n\n  float fog = 1. / (1. + t * t * .2);\n  color *= fog * 2.;\n\n  fragColor = vec4(color, 1.);\n}\n","name":"Image","description":"","type":"image"}]}