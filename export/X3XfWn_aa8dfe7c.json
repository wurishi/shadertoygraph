{"ver":"0.1","info":{"id":"X3XfWn","date":"1728332993","viewed":15,"name":"Fun with Ray marching 1","username":"Firemage0","description":"Raymarching versuch","likes":0,"published":3,"flags":0,"usePreview":0,"tags":["test"],"hasliked":0,"parentid":"43lBRM","parentname":"RayMarching with Camera movement"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 repeated( vec3 p )\n{\n    p.x = p.x - round(p.x);\n    p.y = p.y - round(p.y);\n    p.z = p.z - round(p.z);\n    return p;\n}\nfloat smin( float a, float b, float k ){\n    k *= log(2.0);\n    float x = (b-a)/k;\n    float g = x/(1.0-exp2(-x));\n    return b - k * g;\n}\n\nmat2 rot2D(float angle) {\n    float s = sin(angle);\n    float c = cos(angle);\n    return mat2(c, -s, s, c);\n}\n\nvec3 opTwist( vec3 p, float k)\n{\n    float c = cos(k*p.y);\n    float s = sin(k*p.y);\n    mat2  m = mat2(c,-s,s,c);\n    vec3  q = vec3(m*p.xz,p.y);\n    return q;\n}\nfloat opDisplace( float sdfDistance, float displacement )\n{\n    return sdfDistance+displacement;\n}\n\n\n\nfloat sdSphere( vec3 pos, float size ) {\n  return length(pos)-size;\n}\nfloat sdOctahedron( vec3 p, float s)\n{\n  p = abs(p);\n  return (p.x+p.y+p.z-s)*0.57735027;\n}\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n  const vec3 k = vec3(-0.8660254, 0.5, 0.57735);\n  p = abs(p);\n  p.xy -= 2.0*min(dot(k.xy, p.xy), 0.0)*k.xy;\n  vec2 d = vec2(\n       length(p.xy-vec2(clamp(p.x,-k.z*h.x,k.z*h.x), h.x))*sign(p.y-h.x),\n       p.z-h.y );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n  vec3 q = abs(p);\n  return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n}\nfloat sdPyramid( vec3 p, float h )\n{\n  float m2 = h*h + 0.25;\n    \n  p.xz = abs(p.xz);\n  p.xz = (p.z>p.x) ? p.zx : p.xz;\n  p.xz -= 0.5;\n\n  vec3 q = vec3( p.z, h*p.y - 0.5*p.x, h*p.x + 0.5*p.y);\n   \n  float s = max(-q.x,0.0);\n  float t = clamp( (q.y-0.5*p.z)/(m2+0.25), 0.0, 1.0 );\n    \n  float a = m2*(q.x+s)*(q.x+s) + q.y*q.y;\n  float b = m2*(q.x+0.5*t)*(q.x+0.5*t) + (q.y-m2*t)*(q.y-m2*t);\n    \n  float d2 = min(q.y,-q.x*m2-q.y*0.5) > 0.0 ? 0.0 : min(a,b);\n    \n  return sqrt( (d2+q.z*q.z)/m2 ) * sign(max(q.z,-p.y));\n}\n\n\nfloat minLen(vec3 pos) {\n    //return smin(sdSphere(pos,.25), sdSphere2(pos+.5, .25), 0.25);\n    vec3 sphere1Pos = pos-vec3(0,0,.3);\n    vec3 octahedron1Pos = opTwist(pos-vec3(0,0,0), .1*cos(iTime*.75));\n    octahedron1Pos.z += iTime*2.5;\n    octahedron1Pos.x += cos(iTime)*.25;\n    \n    float[] values = float[]\n    (\n    //sdBox(pos-vec3(0.,0.,0.), pos-vec3(0.,0.,0.)),\n    //sdPlane(pos-vec3(1,1.,1), pos-vec3(0.,6.,0.), -5.),\n    \n    //ground\n    //pos.y+1.,\n    sdOctahedron(repeated(octahedron1Pos),.2)+(0.054*cos(iTime*0.75)+0.0275)\n    /*smin(\n        sdSphere(pos-vec3(0,0,2.),1.), \n        sdOctahedron(pos-vec3(0,0,0.9*cos(iTime*1.5)), .5), \n        .3\n        ),*/\n    //sdHexPrism(pos-vec3(2.,0,1.),vec2(0.5+0.3*cos(iTime*3.), 0.25)),\n    //sdTriPrism(pos-vec3(1.5,0.,-.6), vec2(.5,.45+0.3*sin(iTime*2.))),\n    //opDisplace(sdSphere(pos-vec3(-3.4,0,2.3),1.),sin(2.*iTime+pos.x+3.4)*sin(2.*pos.y-0.)*sin(2.*pos.z-1.)),\n    //sdPyramid(opTwist(pos-vec3(-1.6,0,-1.6),.8*sin((iTime+1.)*1.5)),2.5)\n    \n    );\n    int objectCount = 10;\n    \n    float currentMin = values[0];\n    for(int i=1; i<objectCount; i++) {\n        if(values[i] < currentMin) currentMin = values[i];\n    }\n    return currentMin;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n//TIME 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord*2.-iResolution.xy)/iResolution.y;\n    vec3 col = vec3(1,0,1);\n    vec2 mouse = ((iMouse.xy/iResolution.xy) -0.5)*10.;\n    \n    vec3 cam = vec3(0,0,4);\n    int maxIterations = 75;\n    \n    vec3 rayOrigin = vec3(uv.xy,0.)-cam;\n    vec3 rayDir = normalize(vec3(uv.x, uv.y, 1.));\n    \n    rayOrigin.yz*=rot2D(-1.41);\n    rayDir.yz*=rot2D(-1.41);\n    rayOrigin.xz*=rot2D(-2.);\n    rayDir.xz*=rot2D(-2.);\n\n    \n    int i = 0;\n    float distance = minLen(rayOrigin);\n    while(i < maxIterations) {\n        if(distance < 0.001) break;\n        if(distance > 10000.) break;\n        \n        \n        rayOrigin+=rayDir*distance;\n        distance = minLen(rayOrigin);\n        \n        i++;\n    }\n    \n    \n    if(distance < 0.001) \n    {\n        col = vec3(1.-(float(i)/float(maxIterations))*(abs(1.3*cos(iTime*.75))+.4),0,length(rayOrigin)/40.);\n    } else \n    {\n        col = vec3(0,0,0);\n    }\n    if(i == 2) {\n      //col = vec3(0,1,0);\n    }\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n","name":"Image","description":"","type":"image"}]}