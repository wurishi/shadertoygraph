{"ver":"0.1","info":{"id":"sssyR8","date":"1641727898","viewed":111,"name":"Animating Noise Size","username":"sdfgeoff","description":"When you want to animate noise scale, one way is to scale the input coordinates (left). However this creates a very obvious \"zoom\" effect. because all the features move in sync. Another solution is to use some static noise sizes and select between them.","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["noise","zoom","animate"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// When you want to animate noise scale, one way is to scale the input\n// coordinates (left). However this creates a very obvious \"zoom\" effect.\n// because all the features move in sync.\n// Another solution is to use a static set of noise sizes and lerp between\n// them. This makes a \"static\" noise that just changes size. \n//\n// I am not completely happy with the function used to pick the sizes to use.\n// You can see which ones are selected in the bottom right.\n//\n// I suspect you can do arbitrary zoom levels by computing the \"sizes\" vector\n// based on binning the desired noise scale. However, some quick experiments \n// weren't amazing;\n//\n// This is inspired by the GDC talk: https://youtu.be/MKX45_riWQA?t=1413\n// but is likely a very poor implementation. Having written this and thinking about\n// it some more, I'm fairly sure they are just sampling different mip levels of \n// their noise texture.\n//\n// If you do a better one, please let me know\n//\n//                                                     ---- sdfgeoff, 2022\n\n\nfloat hash12(vec2 p) {\n    // This hash function taken from https://www.shadertoy.com/view/4djSRW\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat noise_source(vec2 co) {\n    // Simple bilinear noise\n    vec2 rounded = floor(co);\n    vec2 delta = co - rounded;\n    float here = hash12(rounded);\n    float above = hash12(rounded + vec2(0,1));\n    float right = hash12(rounded + vec2(1,0));\n    float above_right = hash12(rounded+vec2(1));\n    \n    return mix(\n        mix(here, right, delta.x),\n        mix(above, above_right, delta.x),\n        delta.y\n    );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    float noise_scale = sin(iTime) * 0.45 + 0.55;\n    if (iMouse.z > 0.0) {\n        noise_scale = iMouse.x / iResolution.x;\n    }\n\n    if (uv.x < 0.498) {\n        \n        // Bilinear noise of 4 octaves\n        float noise = (\n            noise_source(fragCoord * noise_scale * 1.0) * 0.5 +\n            noise_source(fragCoord * noise_scale * 2.0) * 0.25 +\n            noise_source(fragCoord * noise_scale * 4.0) * 0.125 +\n            noise_source(fragCoord * noise_scale * 8.0) * 0.125\n        );\n        fragColor = vec4(noise);\n        \n        \n    } else if (uv.x > 0.502) {\n    \n        vec4 col_debug = vec4(0.0);\n        \n        vec4 sizes = vec4(\n            1.0,\n            0.5,\n            0.25,\n            0.125\n        );\n\n        vec4 noise = vec4(\n            noise_source(fragCoord * sizes.x),\n            noise_source(fragCoord * sizes.y),\n            noise_source(fragCoord * sizes.z),\n            noise_source(fragCoord * sizes.a)\n        );\n        float spread = 2.0;\n        vec4 mask = vec4(\n            max(1.0 - abs(sizes.x - noise_scale) * spread, 0.0),\n            max(1.0 - abs(sizes.y - noise_scale) * spread, 0.0),\n            max(1.0 - abs(sizes.z - noise_scale) * spread, 0.0),\n            max(1.0 - abs(sizes.a - noise_scale) * spread, 0.0)\n        );\n        mask /= (mask.x + mask.y + mask.z + mask.a);\n        \n        fragColor = vec4(dot(mask, noise));\n        \n        \n        // Debug visualization\n        if (uv.y < 0.2) {\n            if (uv.y < 0.192) {\n                int index = int(floor(uv.x * 8.0 - 4.0));\n                vec4 debug_mask = vec4(\n                    index == 0,\n                    index == 1,\n                    index == 2,\n                    index == 3\n                );\n                float noise_base = dot(noise, debug_mask);\n                col_debug = vec4(noise_base);\n                float scale = mask[index];\n\n                if (abs(scale - uv.y * 5.0) < 0.02) {\n                    col_debug = vec4(1,0,0,1);\n                }\n                fragColor = col_debug;\n            } else {\n                fragColor = vec4(0,0,1,1);\n            }\n            \n        }\n    } else {\n        fragColor = vec4(0,0,1,1);\n    }\n    \n}","name":"Image","description":"","type":"image"}]}