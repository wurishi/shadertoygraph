{"ver":"0.1","info":{"id":"7dsBR8","date":"1644665805","viewed":291,"name":"Water Wave In Moon Light","username":"March3rd","description":"I used turbulence noise, and make its vector length changing with sin. Then used a simple way to shade——dot normal and view, the result is used for mix sea color with sky color","likes":3,"published":3,"flags":0,"usePreview":0,"tags":["test","noise","wave","learn"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEP 100\n#define STEP_LEN 0.1\n#define MAX_DEPTH 50.0\n#define BLANK_COLOR vec3(0.0, 0.0, 0.0)\n#define SURFACE_DIST 0.001\n\n//----Globals----//\nstruct Ray {\n    vec3 ro;\n    vec3 rd;\n};\nstruct Light {\n     vec3 pos;\n     vec3 col;\n     float range;\n};\n\nRay _view;\n\nLight _light[1];\nint _lightNum = 1;\nvec3 _ambient;\n\nfloat _depthBuffer;\nvec3 _colorBuffer;\n//---------------//\n\n//----SDFs----//\nfloat PlaneSDF(vec3 base, vec3 normal, vec3 pos) {\n    return dot(pos - base, normalize(normal)); \n}\n//-----------//\n\n//----Noise----//\nvec2 Hash22(vec2 p) {\n    p = vec2( dot(p,vec2(127.1,311.7)),\n              dot(p,vec2(269.5,183.3)));\n\n    vec2 result = normalize(-1.0 + 2.0 * fract(sin(p)*43758.5453123));\n    result *= sin(iTime * 1.0 + p.x * 3.14 + p.y * 3.14);\n    return result;\n}\nvec2 Tilling(vec2 p, int n) {\n    if (abs(p.x - float(n)) < 0.1) p.x = 0.0;\n    if (abs(p.y - float(n)) < 0.1) p.y = 0.0;\n    return p;\n}\nfloat PerlinNoise(vec2 p, int n, float frequency) {\n    p *= frequency;\n    p = fract(p);\n    p *= float(n);\n    vec2 pi = floor(p);\n    vec2 pf = p - pi;\n\n    vec2 w = pf * pf * (3.0 - 2.0 * pf);\n\n    return mix(mix(dot(Hash22(Tilling(pi + vec2(0.0, 0.0), n)), pf - vec2(0.0, 0.0)), \n                   dot(Hash22(Tilling(pi + vec2(1.0, 0.0), n)), pf - vec2(1.0, 0.0)), w.x), \n               mix(dot(Hash22(Tilling(pi + vec2(0.0, 1.0), n)), pf - vec2(0.0, 1.0)), \n                   dot(Hash22(Tilling(pi + vec2(1.0, 1.0), n)), pf - vec2(1.0, 1.0)), w.x),\n               w.y);\n}\nfloat Turbulence(vec2 p, int n, float frequency, int octaves, float attenFrequency, float attenAmplitude) {\n    float value = 0.0;\n    float amplitude = 1.0 - attenAmplitude;\n    for (int i = 0; i < octaves; i ++) {\n        value += amplitude * abs(PerlinNoise(p, n, frequency));\n        amplitude *= attenAmplitude;\n        frequency *= attenFrequency;\n    }\n    return pow(1.0 - clamp(value, 0.0, 1.0), 8.0);;\n}\nfloat Wave(vec2 p, int n, float frequency, int octaves, float attenFrequency, float attenAmplitude) {\n    return Turbulence(p + vec2(iTime, iTime), n, frequency, octaves, attenFrequency, attenAmplitude);\n}\n//-------------//\n\n//----Classes----//\n//Plane\nstruct Plane {\n    vec3 base;\n    vec3 normal;\n    vec3 col;\n    float downOffset;\n};\n\nfloat MapPlane(Plane plane, vec3 pos) {\n    return PlaneSDF(plane.base, plane.normal, pos);\n}\nvec3 GetNormalPlane(vec2 pos, int n, float frequency, int octaves, float attenFrequency, float attenAmplitude) {\n    float o = Wave(pos.xy, 10, 0.01, 6, 2.0, 0.5);\n    float delta = 0.0001;\n    float dx = Wave(pos.xy + vec2(delta, 0.0), 10, 0.01, 6, 2.0, 0.5) - o;\n    float dz = Wave(pos.xy + vec2(0.0, delta), 10, 0.01, 6, 2.0, 0.5) - o;\n    return normalize(vec3(-dx, delta, -dz));\n}\nvec3 ShadePlaneWithLight(Plane plane, vec3 pos, vec3 normal, Light light) {\n    vec3 seaCol = vec3(0.0, 0.1, 0.25);\n    vec3 skyCol = vec3(0.3, 0.5, 0.6);\n    vec3 reflectDir = reflect(_view.rd, normal);\n    if (dot(reflectDir, normalize(light.pos - pos)) > 0.975) {\n        seaCol = light.col;\n    }\n    float h = clamp(dot(-_view.rd, normal), 0.0, 1.0);\n    return mix(skyCol, seaCol, h);\n}\nvoid ShadePlane(Plane plane, float depth) {\n    vec3 pos = _view.ro + _view.rd * depth;\n    float height = Wave(pos.xz, 10, 0.01, 6, 2.0, 0.5);\n    if (height + plane.base.y - plane.downOffset >= pos.y) {\n        vec3 col = vec3(0.0, 0.0, 0.0);\n        vec3 normal = GetNormalPlane(pos.xz, 10, 0.01, 6, 2.0, 0.5);\n        for (int i = 0; i < _lightNum; i ++) {\n            col += ShadePlaneWithLight(plane, pos, normal, _light[i]);\n        }\n        _depthBuffer = depth;\n        _colorBuffer = col;\n    }\n}\n\nfloat RenderPlane(Plane plane, float depth) {\n    float dist = MapPlane(plane, _view.ro + _view.rd * depth);\n    if (dist > SURFACE_DIST) {\n        return dist;\n    } else {\n        ShadePlane(plane, depth);\n        \n        return STEP_LEN;\n    }\n}\n//---------------//\n\n//----PostEffects----//\nvoid EdgeFog(float depth, float distLimit, vec3 fogCol) {\n    float h = clamp(depth / distLimit, 0.0, 1.0);\n    _colorBuffer = mix(_colorBuffer, fogCol, pow(h, 2.0));\n}\nvoid RayBloom(Light light, float powDecay, float centerFull) {\n    float dist = length(light.pos - _view.ro);\n    float attenuation = (dist < light.range) ? pow(1.0 - dist / light.range, 2.0) : 0.0;\n    float h = clamp(dot(_view.rd, normalize(light.pos - _view.ro)) + centerFull, 0.0, 1.0);\n    _colorBuffer = mix(_colorBuffer, light.col * attenuation, pow(h, powDecay));\n}\n//-------------------//\n\n//----PipeLine----//\nvoid Pipeline() {\n    //Objects\n    Plane plane;\n    plane.base = vec3(0.0, -7.5, 0.0);\n    plane.normal = vec3(0.0, 1.0, 0.0);\n    plane.col = vec3(0.3, 0.3, 0.6);\n    plane.downOffset = 1.0;\n    //Opaque\n\n    //Transparant\n    float depth = 0.0;\n    for (int i = 0; i < MAX_STEP; i ++) {\n        float dist = RenderPlane(plane, depth);\n        depth += dist;\n        if (depth > _depthBuffer) {\n            break;\n        }\n    }\n    //PostEffects\n    EdgeFog(depth, MAX_DEPTH, vec3(0.1, 0.1, 0.15));\n    RayBloom(_light[0], 128.0, 0.02);\n}\n//----------------//\n\n//----Entry----//\nvoid Init() {\n    //light0\n    _light[0].pos = vec3(0.0, 150.0, 250.0);\n    _light[0].col = vec3(0.85, 0.9, 0.75);\n    _light[0].range = 100000.0;\n    //ambient\n    _ambient = vec3(0.3, 0.3, 0.3);\n    //buffer\n    _depthBuffer = MAX_DEPTH;\n    _colorBuffer = BLANK_COLOR;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord) {\n    //Init\n    Init();\n    //Normalized pixel coordinates\n    vec2 uv = (fragCoord-0.5*iResolution.xy) / iResolution.y;\n    //Ray\n    _view.ro = vec3(0.0, 0.0, -0.5);\n    _view.rd = normalize(vec3(uv.x, uv.y, 0.5));\n    //Pipeline\n    Pipeline();\n    // Output to screen\n    fragColor = vec4(_colorBuffer, 1.0);\n}\n//-------------//","name":"Image","description":"","type":"image"}]}