{"ver":"0.1","info":{"id":"styBzt","date":"1665024762","viewed":74,"name":"10.05.2022:SweepAndDesist","username":"g___r___e___g","description":"A continuation of yesterday's unfinished shader. Trying to understand how to create radial symmetry, but ultimately I had to render every dot for every pixel anyway, due to the animation converging at the origin.","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["fragtober"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define TAU 6.2832\n\nvec2 rotate(vec2 p, float a) {\n  float c = cos(a), s = sin(a);\n  return mat2(c, -s, s, c) * p;\n}\n\nvec3 hsv(vec3 c) {\n  vec3 rgb = c.x * 6. + vec3(0., 4., 2.);\n  rgb = mod(rgb, 6.) - 3.;\n  rgb = abs(rgb) - 1.;\n  rgb = clamp(rgb, 0., 1.);\n\n  return c.z * mix(vec3(1), rgb, c.y);\n}\n\n// returns 0 to 1 arc(turns of a circle) with 0 and 1 at the right\nfloat hue(vec2 p) {\n  return fract(atan(p.y, p.x) / TAU + 1.);\n}\n\nfloat stepLinear(float a, float b, float t) {\n  return clamp((t - a)/(b - a), 0., 1.);\n}\n\n// originally https://www.shadertoy.com/view/ltl3DB\nfloat easeSpring(float a, float b, float t) {\n    t = stepLinear(a, b, t);\n    return 1.0 - cos(t * TAU * 3.0) * exp(-t * 12.5);\n}\n\nfloat easeInOutExpo(float t) {\n  return (t == 0. || t == 1.)\n    ? t\n    : (t *= 2.) < 1.\n    ? 0.5 * pow(2., 10. * (t - 1.))\n    : 0.5 * (-pow(2., -10. * (t - 1.)) + 2.);\n}\n\n// iquilez - https://www.shadertoy.com/view/wl23RK\n// sc is the sin/cos of the aperture\nfloat sdArc( in vec2 p, in vec2 sc, in float ra, float rb )\n{\n    p.x = abs(p.x);\n    return ((sc.y*p.x>sc.x*p.y) ? length(p-sc*ra) : \n                                  abs(length(p)-ra)) - rb;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  float sf = 1./min(iResolution.x, iResolution.y);\n  vec2 uv = (fragCoord - .5 * iResolution.xy) * sf;\n  vec3 color = vec3(0);\n\n  float d = abs(length(uv) - 0.25) - 0.025;\n  vec3 rainbow = hsv(vec3(hue(uv), 1., 1.));\n  // rainbow = mix(vec3(1), rainbow, smoothstep(sf, -sf, d));\n\n  float t = mod((iTime) * 0.9, 3.);\n\n  float phaseOffset = 3. * TAU / 8.;\n  float a = atan(uv.y, uv.x);\n  a /= TAU;\n  a += 1.;\n  a = fract(a);\n  a = clamp(a, 0., 1.);\n  a += 1./8.;\n  float aRepeat = floor(a * 4.);\n  uv = rotate(uv, aRepeat * TAU / 4.);\n\n  float h = hue(uv);\n\n  float r = 0.25 * (\n     easeSpring(0., 1., t)\n    -easeSpring(2., 3., t)\n  );\n  float radius = 0.025;\n  float tSweep = easeInOutExpo(stepLinear(1., 2., t));\n  float aDot = tSweep * TAU / 4. - TAU / 8.;\n  float innerD = 1e100;\n  for (float i = -1.; i <= 3.; i++) {\n    vec2 pDot2 = rotate(uv, aDot + TAU / 4. * i);\n    float arcLength = TAU / 16. * tSweep;\n    float arc = sdArc(pDot2, vec2(sin(arcLength), cos(arcLength)), r, radius);\n    innerD = min(innerD, arc);\n  }\n\n  float hueMix = 1. - abs((r/0.25)- 1.);\n  float dCut = smoothstep(sf, -sf, innerD);\n  color = mix(color, vec3(1), dCut);\n  color = mix(color, color*rainbow, hueMix);\n\n  fragColor = vec4(color, 1);\n}","name":"Image","description":"","type":"image"}]}