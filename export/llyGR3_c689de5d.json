{"ver":"0.1","info":{"id":"llyGR3","date":"1475780443","viewed":690,"name":"Fractal Vibrations","username":"gPlatl","description":"Still a crazy idea - sound vibration of a fractal - which was created by BlooD2oo1.\nFor fractal see https://www.shadertoy.com/view/Xly3R3\nUse mouse to change view...","likes":18,"published":1,"flags":1,"usePreview":0,"tags":["fractal","sound","visualizer"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdfGzn","filepath":"/media/a/894a09f482fb9b2822c093630fc37f0ce6cfec02b652e4e341323e4b6e4a4543.mp3","previewfilepath":"/media/ap/894a09f482fb9b2822c093630fc37f0ce6cfec02b652e4e341323e4b6e4a4543.mp3","type":"music","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n//------------------------------------------------------\n//\n// Fractal_Vibrations.glsl\n//\n// original:  https://www.shadertoy.com/view/Xly3R3\n//            2016-10-05  Kaleo by BlooD2oo1\n//\n//   v1.0  2016-10-06  first release\n//   v1.1  2018-03-23  AA added, mainVR untested!!! \n//   v1.2  2018-09-02  supersampling corrected\n//\n// description  a koleidoscopic 3d fractal\n//\n// Hires B/W fractal picture:\n//   https://c2.staticflickr.com/6/5609/15527309729_b2a1d5a491_o.jpg\n//\n//------------------------------------------------------\n\nfloat g_fScale = 1.2904082537;\n\nmat4 g_matIterator1 = mat4(-0.6081312299, -0.7035965919, 0.3675977588, 0.0000000000,\n                            0.5897225142, -0.0904228687, 0.8025279045, 0.0000000000,\n                           -0.5314166546, 0.7048230171, 0.4699158072, 0.0000000000,\n                            0.0000000000, 0.0000000000, 0.0000000000, 1.0000000000 );\n\nmat4 g_matIterator2 = mat4(-0.7798885703, 0.6242666245, -0.0454343557, -0.2313748300,\n                            0.0581589043, 0.0000002980, -0.9983071089, -0.2313748300,\n                           -0.6232098937, -0.7812111378, -0.0363065004, -0.2313748300,\n                            0.0000000000, 0.0000000000, 0.0000000000, 1.0000000000 );\n\nmat4 g_matReflect1 = mat4( 0.9998783469, -0.0103046382, -0.0117080826, 0.0000000000,\n                          -0.0103046382, 0.1270489097, -0.9918430448, 0.0000000000,\n                          -0.0117080826, -0.9918430448, -0.1269274950, 0.0000000000,\n                           0.0000000000, 0.0000000000, 0.0000000000, 1.0000000000 );\n\nmat4 g_matReflect2 = mat4( 0.7935718298, -0.0946179554, 0.6010749936, 0.0000000000,\n                          -0.0946179554, 0.9566311240, 0.2755074203, 0.0000000000,\n                           0.6010749936, 0.2755074203, -0.7502027750, 0.0000000000,\n                           0.0000000000, 0.0000000000, 0.0000000000, 1.0000000000 );\n\nmat4 g_matReflect3 = mat4(-0.7127467394, -0.5999681950, 0.3633601665, 0.0000000000,\n                          -0.5999681950, 0.7898335457, 0.1272835881, 0.0000000000,\n                           0.3633601665, 0.1272835881, 0.9229129553, 0.0000000000,\n                           0.0000000000, 0.0000000000, 0.0000000000, 1.0000000000 );\n\nvec4 g_planeReflect1 = vec4( 0.0077987094, 0.6606628895, 0.7506421208, -0.0000000000 );\n\nvec4 g_planeReflect2 = vec4( 0.3212694824, 0.1472563744, -0.9354685545, -0.0000000000 );\n\nvec4 g_planeReflect3 = vec4( -0.9254043102, -0.3241653740, 0.1963250339, -0.0000000000 );\n\n/////////////////////////////////////////////////////////////////////////////////////////\n\nvec3 HSVtoRGB(float h, float s, float v) \n{\n  return((clamp(abs(fract(h +vec3(0.,2./3.,1./3.))*2.-1.)*3.-1.,0.,1.)-1.)*s+1.)*v;\n}\n\nmat3 rot3xy( vec2 angle )\n{\n  vec2 c = cos( angle );\n  vec2 s = sin( angle );\n  return mat3( c.y,       -s.y,        0.0,\n               s.y * c.x,  c.y * c.x, -s.x,\n               s.y * s.x,  c.y * s.x,  c.x );\n}\n\nvec4 DE1( in vec4 v )\n{\n  float fR = dot( v.xyz, v.xyz );\n  vec4 q;\n  int k = 0;\n  vec3 vO = vec3( 0.0, 0.0, 0.0 );\n\n  for ( int i = 0; i < 32; i++ )\n  {\n    q = v*g_matIterator1;\n    v.xyz = q.xyz;\n\n    if ( dot( v, g_planeReflect1 ) < 0.0 )\n    {\n      q = v*g_matReflect1;\n      v.xyz = q.xyz;\n      vO.x += 1.0;\n    }\n\n    if ( dot( v, g_planeReflect2 ) < 0.0 )\n    {\n      q = v*g_matReflect2;\n      v.xyz = q.xyz;\n      vO.y += 1.0;\n    }\n\n    if ( dot( v, g_planeReflect3 ) < 0.0 )\n    {\n      q = v*g_matReflect3;\n      v.xyz = q.xyz;\n      vO.z += 1.0;\n    }\n\n    q = v*g_matIterator2;\n    v.xyz = q.xyz;\n\n    v.xyz = v.xyz*g_fScale;\n    fR = dot( v.xyz, v.xyz );\n    k = i;\n  }\n  return vec4( vO, ( sqrt( fR ) - 2.0 ) * pow( g_fScale, -float(k+1) ) );\n}\n\n//------------------------------------------------------\n\nfloat time = 0.0;  \nfloat fL = 1.0;\n\n//------------------------------------------------------\nvec4 renderRay (in vec3 rayOrig, in vec3 rayDir)\n{\n  rayDir = normalize( rayDir );\n\n  const float fRadius = 2.0;\n  float b = dot( rayDir, rayOrig ) * 2.0;\n  float c = dot( rayOrig, rayOrig ) - fRadius*fRadius;\n  float ac4 = 4.0 * c;\n  float b2 = b*b;\n\n  vec4 color = vec4(0,0,0,1);\n  color.rgb = -rayDir*0.2+0.8;\n  color.rgb = pow( color.rgb, vec3( 0.9, 0.8, 0.5 ) );\n  color.rgb *= 1.0-fL;\n  if ( b2 - ac4 <= 0.0 )  return color;\n\n  float root = sqrt( b2-ac4 );\n  float at1 = max(0.0, (( -b - root ) / 2.0));\n  float at2 = ( -b + root ) / 2.0;\n\n  float t = at1;\n  vec4 v = vec4( rayOrig + rayDir * t, 1.0 );\n  vec4 vDE = vec4( 0.0, 0.0, 0.0, 0.0 );\n  float fEpsilon = 0.0;\n\n  float fEpsilonHelper = 1.0 / iResolution.x;\n    \n  float count = 0.0;\n  for ( int k = 0; k < 100; k++ )\n  {\n    vDE = DE1( v );\n    t += vDE.w;\n    v.xyz = rayOrig + rayDir * t;\n\n    fEpsilon = fEpsilonHelper * t;\n\t\t\n    if ( vDE.a < fEpsilon ) \n    {\n        count = float(k);\n        break;\n    }\n    if ( t > at2 )     return color;\n  }\n    \n  // colorizing by distance of fractal\n  color.rgb = HSVtoRGB(count/25., 1.0-count/50., 0.8);\n    \n  vec4 vOffset = vec4( fEpsilon*1.8, 0.0, 0.0, 0.0 );\n  vec4 vNormal = vec4(0.0);\n  vNormal.x = DE1( v + vOffset.xyzw ).w - DE1( v - vOffset.xyzw ).w;\n  vNormal.y = DE1( v + vOffset.yxzw ).w - DE1( v - vOffset.yxzw ).w;\n  vNormal.z = DE1( v + vOffset.zyxw ).w - DE1( v - vOffset.zyxw ).w;\n  vNormal.xyz = normalize( vNormal.xyz );\n\n  vec4 vReflect = vec4(0.7);\n  vReflect.xyz = reflect( rayDir, vNormal.xyz );\n\n  vec2 vOccRefl = vec2( 0.0, 0.4 );\n  \n  float fMul = 2.0;\n  float fMulMul = pow( 2.0, 9.0/10.0 ) * pow( fEpsilon, 1.0/10.0 ) * 0.5;\n  float fW = 0.0;\n  for ( int k = 0; k < 8; k++ )\n  {\n    vOccRefl.x += DE1( v + vNormal * fMul ).w / fMul;\n    vOccRefl.y += DE1( v + vReflect * fMul ).w / fMul;\n    fMul *= fMulMul;\n  }\n  vOccRefl /= 6.0;\n  \n  color.rgb *= vec3( vOccRefl.x * vOccRefl.y );\n  color.rgb *= (vNormal.xyz*0.5+0.5)*(1.0-vOccRefl.x) +vec3(1.5)* vOccRefl.y;\n  color.rgb = pow( color.rgb, vec3( 0.4, 0.5, 0.6 ) );\n  color.rgb *= 1.0-fL;\n  return vec4(color.rgb, 1.0);\n}\n\n//------------------------------------------------------\nvoid mainVR (out vec4 fragColor, in vec2 fragCoord\n            ,in vec3 fragRayOri, in vec3 fragRayDir)\n{\n  vec2 uv = (fragCoord - iResolution.xy*0.5) / iResolution.x;\n  fL = length( uv );\n  fragColor = renderRay (fragRayOri, fragRayDir);\n}\n\n//------------------------------------------------------\nvec4 render(in vec2 pos)\n{\n  time = iTime * 0.1;  \n  vec2 mouse = iMouse.xy / iResolution.xy;\n  vec3 rayOrig = vec3( -3.0 - sin( time ), 0.0, 0.0 );\n  vec2 uv = (pos - iResolution.xy*0.5) / iResolution.x;\n  fL = length( uv );\n  uv /= fL;\n  uv *= 1.0-pow( 1.0-fL, 0.7 );\n  vec3 rayDir = vec3(0.45+mouse.y, uv );\n\n  mat3 rot = rot3xy( vec2( 0.0, time + mouse.x * 4.0) );\n  rayDir  = rot * rayDir;\n  rayOrig = rot * rayOrig;\n    \n  return renderRay (rayOrig, rayDir);\n}\n\n//------------------------------------------------------\n\n#define AAX 2   // supersampling level. Make higher for more quality.\n#define AAY 1   \n\nfloat AA = float(AAX * AAY);\n\n//------------------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  float tr = texture(iChannel0,vec2(0.01, 0.01)).r;  // sound value\n  g_fScale -= (tr*2.3 - 2.0) / 18.0;    // fractal scaling\n\n  if (AAX>1 || AAY>1)\n  {\n    vec4 col = vec4(0,0,0,1);\n    for (int xp = 0; xp < AAX; xp++)\n    for (int yp = 0; yp < AAY; yp++)\n    {\n      vec2 pos = fragCoord + vec2(xp,yp) / vec2(AAX,AAY);\n      col += render (pos);\n    }\n    fragColor.rgb = col.rgb / AA;\n  }\n  else fragColor = render (fragCoord);\n}\n","name":"Image","description":"","type":"image"}]}