{"ver":"0.1","info":{"id":"ssB3WK","date":"1617953448","viewed":95,"name":"Voronoi in Kyoto / Shogi","username":"tomoe","description":"Left: 2D, Center: 2D+rotation, Right: 3D\nUp: Shogi, Down: Kyoto\n(fork from [url=https://www.shadertoy.com/view/NsB3WG]Voronoi sample[/url] and [url=https://www.shadertoy.com/view/7sS3WK]Euclid / Kyoto / Shogi[/url])","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["bd202104"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec2 fragCoord_;\nconst float PI = 3.14159265359;\n//start hash\nuvec3 k = uvec3(0x456789abu, 0x6789ab45u, 0x89ab4567u);\nuvec3 u = uvec3(1, 2, 3);\nconst uint UINT_MAX = 0xffffffffu;\nuint uhash11(uint n) {\n    n ^= (n << u.x);\n    n ^= (n >> u.x);\n    n *= k.x;\n    n ^= (n << u.x);\n    return n * k.x;\n}\nuvec2 uhash22(uvec2 n) {\n    n ^= (n.yx << u.xy);\n    n ^= (n.yx >> u.xy);\n    n *= k.xy;\n    n ^= (n.yx << u.xy);\n    return n * k.xy;\n}\nuvec3 uhash33(uvec3 n) {\n    n ^= (n.yzx << u);\n    n ^= (n.yzx >> u);\n    n *= k;\n    n ^= (n.yzx << u);\n    return n * k;\n}\nfloat hash11(float p){\n    uint n = floatBitsToUint(p);\n    return float(uhash11(n)) / float(UINT_MAX);\n}\nfloat hash21(vec2 p){\n    uvec2 n = floatBitsToUint(p);\n    return float(uhash22(n).x) / float(UINT_MAX);\n}\nfloat hash31(vec3 p) {\n    uvec3 n = floatBitsToUint(p);\n    return float(uhash33(n).x) / float(UINT_MAX);\n}\nvec2 hash22(vec2 p) {\n    uvec2 n = floatBitsToUint(p);\n    return vec2(uhash22(n)) / vec2(UINT_MAX);\n}\nvec3 hash33(vec3 p) {\n    uvec3 n = floatBitsToUint(p);\n    return vec3(uhash33(n)) / vec3(UINT_MAX);\n}\n//end hash\nmat2 rot2(float t) {\n    return mat2(cos(t), sin(t), -sin(t),  cos(t));\n}\nmat3 rotX(float t){\n    return mat3(\n        1.,0.,0.,\n        0.,sin(t),cos(t),\n        0.,-cos(t),sin(t)\n    );\n}\nfloat length2(vec2 p) {\n    p = abs(p);\n    if (fragCoord_.y < 0.5 * iResolution.y) {\n        return dot(p, vec2(1.0));\n    } else {\n        return max(p.x, p.y);\n    }\n}\nfloat length3(vec3 p) {\n    p = abs(p);\n    if (fragCoord_.y < 0.5 * iResolution.y) {\n        return dot(p, vec3(1.0));\n    } else {\n        return max(max(p.x, p.y), p.z);\n    }\n}\nvec2 voronoi2(vec2 p){   \n    vec2 n = round(p);\n    vec2 f = p - round(p);\n    float dist = length2(abs(f) + 0.5);\n    vec2 sgn = vec2(1.0);\n    vec2 glid = vec2(0.0);\n    vec2 ind;\n    for(float j = 0.0; j <= 2.0; j ++ ) {\n        glid.y += sgn.y * j;\n        sgn.y *= -1.0;\n        if (abs(glid.y - f.y) - 0.5 > dist){\n            continue;\n        }\n        for(float i = 0.0; i <= 2.0; i ++ ){\n            glid.x += sgn.x * i;\n            sgn.x *= -1.0;\n            vec2 nbd = glid;\n            if(fragCoord_.x < 0.33 * iResolution.x){\n                nbd += hash22(n + nbd) - 0.5; \n            } else {\n                nbd += rot2(iTime) * (hash22(n + nbd) - 0.5)/sqrt(2.0);\n            }\n            if(length2(nbd - f) < dist){\n                ind = n + glid;\n                dist = length2(nbd - f);\n            }\n        }\n        glid.x = 0.0;\n    }\n    return ind;\n}\nvec3 voronoi3(vec3 p){   \n    vec3 n = round(p);\n    vec3 f = p - round(p);\n    float dist = length3(abs(f) + 0.5);\n    vec3 sgn = vec3(1.0);\n    vec3 glid = vec3(0.0);\n    vec3 ind;\n    for(float k = 0.0; k <= 2.0; k ++ ) {\n            glid.z += sgn.z * k;\n            sgn.z *= -1.0;\n            if (abs(glid.z - f.z) - 0.5 > dist){\n                continue;\n            }\n        for(float j = 0.0; j <= 2.0; j ++ ) {\n            glid.y += sgn.y * j;\n            sgn.y *= -1.0;\n            if (abs(glid.y - f.y) - 0.5 > dist){\n                continue;\n            }\n            for(float i = 0.0; i <= 2.0; i ++ ){\n                glid.x += sgn.x * i;\n                sgn.x *= -1.0;\n                vec3 nbd = glid + hash33(n + glid) -0.5;\n                if(length3(nbd - f) < dist){\n                    ind = n + glid;\n                    dist = length3(nbd - f);\n                }\n            }\n            glid.x = 0.0;\n        }\n        glid.y = 0.0;\n    }\n    return ind;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    fragCoord_ = fragCoord;\n    vec2 pos = fragCoord.xy/ iResolution.xx;\n    pos *= 10.0;\n    pos += iTime;\n    vec3 v;\n    if(gl_FragCoord.x < 0.66 * iResolution.x){\n        v = vec3(hash22(voronoi2(pos)), 1.0);  \n    } else {\n        v = hash33(voronoi3(vec3(pos, 0.5 * iTime)));   \n    }\n    if (fragCoord.y < 0.5 * iResolution.y){\n        v = v.zxy;\n    }\n    fragColor = vec4(vec3(v), 1.0);\n}\n","name":"Image","description":"","type":"image"}]}