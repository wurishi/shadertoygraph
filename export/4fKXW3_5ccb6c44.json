{"ver":"0.1","info":{"id":"4fKXW3","date":"1715863991","viewed":23,"name":"Scena z inicjałami JK","username":"kruzlaczek","description":"Zaliczenie na programowanie wizualne","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["noise","beam","initials","swir"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define saturate(x) clamp(x,0.,1.) // Funkcja saturacji ogranicza wartości do przedziału [0, 1]\n\n// Funkcja do rysowania znaku na podstawie pozycji i kodu znaku\nfloat char(vec2 p, float c){\n    if(p.x < 0.0 || p.x > 1.0 || p.y < 0.0 || p.y > 1.0) return 1e5; // Zwraca dużą wartość, jeśli pozycja jest poza zakresem\n    return texture(iChannel0, p / 16.0 + fract(floor(vec2(c, 16.0 - c / 16.0)) / 16.0)).a; // Pobiera wartość alfa z tekstury znaku\n}\n\n// Funkcja generująca szum\nfloat noise(vec2 p){\n    return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453); // Prosty szum oparty na iloczynie skalarnym i sinusie\n}\n\n// Funkcja sigmoid z wymuszonym kształtem\nfloat forcedSigmoid(float x, float a){\n    return (x > 0.5 ? 2.0 - pow((-2.0 * x) + 2.0, a) : pow(x * 2.0, a)) / 2.0; // Kształtuje funkcję sigmoid w zależności od a\n}\n\n// Funkcja główna rysująca obraz\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec2 uv = (fragCoord.xy / iResolution.xy) - 0.5; // Normalizacja współrzędnych ekranu do zakresu [-0.5, 0.5]\n    uv.x *= iResolution.x / iResolution.y; // Korekta proporcji ekranu\n    uv *= 4.0; // Skalowanie współrzędnych dla efektów wizualnych\n    float time = iTime; // Czas animacji\n    float weight = 0.5; // Waga dla rysowania znaków\n    float sharpen = 100.0; // Parametr wyostrzania\n    float drawing = 1.0; // Zmienna do przechowywania rysowanych znaków\n\n    // Efekt wiru w tle\n    float angle = atan(uv.y, uv.x) + time; // Obliczanie kąta dla efektu wiru\n    float radius = length(uv); // Obliczanie promienia od środka\n    vec2 swirlUV = vec2(cos(angle), sin(angle)) * radius; // Współrzędne po przekształceniu wiru\n    \n    // Kolory tła, mieszanie dwóch kolorów w zależności od pozycji\n    vec3 color1 = vec3(0.2, 0.3, 0.7); // Kolor 1\n    vec3 color2 = vec3(0.8, 0.4, 0.1); // Kolor 2\n    vec3 backgroundColor = mix(color1, color2, swirlUV.y * 0.5 + 0.5); // Mieszanie kolorów w zależności od współrzędnej y\n\n    // Efekt świetlnego promienia\n    float beam = sin(uv.x * 10.0 + time * 5.0) * 0.5 + 0.5; // Obliczanie promienia świetlnego\n    vec3 beamColor = vec3(1.0, 1.0, 0.5) * beam; // Kolor promienia świetlnego\n    backgroundColor += beamColor * 0.5; // Dodanie efektu promienia do tła\n\n    // Animowane litery J i K\n    float yOffset = 0.5 * sin(time * 2.0); // Przesunięcie liter w osi y w zależności od czasu\n    float charJ = char((uv - vec2(-0.75, yOffset)) + 0.5, 74.0); // Rysowanie litery J bliżej środka\n    float charK = char((uv - vec2(0.25, yOffset)) + 0.5, 75.0); // Rysowanie litery K bliżej środka\n\n    // Dynamiczny kolor liter z efektem szumu\n    vec3 charColor = vec3(\n        0.5 + 0.5 * sin(time * 2.0 + noise(uv * 10.0)), // Kolor czerwony z szumem\n        0.5 + 0.5 * sin(time * 3.0 + 2.0 + noise(uv * 10.0)), // Kolor zielony z szumem\n        0.5 + 0.5 * sin(time * 4.0 + 4.0 + noise(uv * 10.0)) // Kolor niebieski z szumem\n    );\n\n    // Wyostrzanie i rysowanie liter\n    float drawingJ = 1.0 - saturate((charJ - weight) * sharpen); // Rysowanie litery J \n    float drawingK = 1.0 - saturate((charK - weight) * sharpen); // Rysowanie litery K \n\n    // Aplikacja koloru liter\n    vec3 finalColor = mix(backgroundColor, charColor, drawingJ + drawingK); // Mieszanie tła i kolorów liter\n\n    fragColor = vec4(finalColor, 1.0); // Ustawienie koloru końcowego piksela\n}","name":"Image","description":"","type":"image"}]}