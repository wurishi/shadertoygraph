{"ver":"0.1","info":{"id":"3tsczj","date":"1592501423","viewed":194,"name":"Hexagoing mad here","username":"ShaderLyf","description":"I'm going a bit mad here, trying to work out how if it is possible to map an individual pixel from the fft texture to trigger or colour a specific grid cell. \n\nCan't work out how to avoid just repeating the fft texture inside the cell. Any ideas?","likes":9,"published":1,"flags":0,"usePreview":0,"tags":["audio","hexagon"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGzn","filepath":"/media/a/29de534ed5e4a6a224d2dfffab240f2e19a9d95f5e39de8898e850efdb2a99de.mp3","previewfilepath":"/media/ap/29de534ed5e4a6a224d2dfffab240f2e19a9d95f5e39de8898e850efdb2a99de.mp3","type":"music","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.1415926535\n#define TWO_PI 6.2831853\n\nfloat hexD(vec2 p)\n{\n    p = abs(p);\n    float c = dot(p,normalize(vec2(1.0,1.73)));\n    c = max(c,p.x);\n    return c;\n}\n\nvec2 getV(vec2 uv)\n{\n    vec2 repeat =vec2 (1.0,1.73);\n    vec2 h = repeat*0.5;\n    vec2 a1=mod(uv,repeat)-h; // gridify, but it's offset\n    vec2 b1=mod(uv-h,repeat)-h; // gridify and center\n    vec2 getv = dot(a1,a1)<dot(b1,b1)?a1:b1;//if else function without if/else\n    \n    return getv;\n}\n\nvec4 hex (vec2 uv)\n{\n    vec2 getv = getV(uv);\n    float x = atan(getv.x,getv.y);\n    float y = 0.5-hexD(getv);\n    vec2 id = uv-getv;\n    \n    vec4 co = vec4(x,y,id.x,id.y); // coords and id\n    return co;\n    \n}\nvec3 triD(vec2 uv,float s)\n{\n    vec2 repeat =vec2 (1.0,1.73);\n    vec2 h = repeat*0.5;\n    vec2 a1=mod(uv,repeat)-h; // gridify, but it's offset\n    vec2 b1=mod(uv-h,repeat)-h; // gridify and center\n    vec2 getv = dot(a1,a1)<dot(b1,b1)?a1:b1;//if else function\n    float d = 0.0;\n    // Taken from the book of shaders\n    // Number of sides of your shape\n    int N = 3;\n    // Angle and radius from the current pixel\n    float a = atan(getv.x,getv.y)+PI;\n    float r = TWO_PI/float(N);\n    \n    vec2 id = getv-uv;\n    // Shaping function that modulate the distance\n    d = cos(floor(0.5+a/r)*r-a)*length(getv);\n    vec3 col = vec3(1.0-smoothstep(s,s+0.01,d));//*sin(id.x*id.y+iTime)));\n    \n    return col;\n}\n\n// if 0-128 range of values passed in, remapped to co-ord via:\n// x = fft/7;\n// xr = mod(x,7);\n// y = xr/4;\n\n// then divide by scale factor eg 6,\n// to normalise to uv range.\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // create pixel coordinates\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tvec2 uv2 = (fragCoord.xy-0.5*iResolution.xy)/iResolution.y;\n    // the sound texture is 512x2\n    //uv2+=0.5;\n    \n    vec4 h = hex(uv2*6.);\n    vec4 t = hex(uv2*1.5);\n    vec4 t2 = hex(uv2*0.75);\n    vec4 t3 = hex(uv2*3.0);\n    \n    int tx = int(h.y*16.0);\n    int tx2 = int(t.y*16.0+16.);\n    int tx3 = int(t2.y*16.0+32.);\n    int tx4 = int(t3.y*16.0+48.);\n    \n    //int tx = int(mod(uv.x*128.+64.,12.0));\n\tvec4 hex1  = texelFetch( iChannel0, ivec2(tx,0), 0 ); \n    vec4 hex2  = texelFetch( iChannel0, ivec2(tx2,0), 0 ); \n    vec4 hex3  = texelFetch( iChannel0, ivec2(tx3,0), 0 ); \n    vec4 hex4  = texelFetch( iChannel0, ivec2(tx4,0), 0 ); \n\t//vec4 h = hex(vec2(tx,uv.x));\n    vec3 e2 = (0.5 + 0.5*cos(iTime+uv.xyx+vec3(hex1.z,2,4)) * 0.75);\n    float time = iTime * 0.2;\n    vec2 d = abs((uv - 0.5) * 2.0);\n    d = pow(d, vec2(2.0, 2.0));\n        \n\n\tvec3 col;\n    col+=hex1.xxx;\n\tcol+=hex2.xxx;\n    //col-=hex4.xxx;\n    col-=hex3.xxx;\n    col-=e2;\n    \n    vec2 r = col.r - d * 1.025;\n    vec2 g = col.g + d * 0.125;\n    float b = col.b;\n\tvec3 rgb = vec3(r.r,g.g,b);\n    \n    col+=rgb.xyz;\n    // add wave form on top\t\n\n\t// output final color\n\tfragColor = vec4(rgb*0.8,1.0);\n    //fragColor = h;\n}","name":"Image","description":"","type":"image"}]}