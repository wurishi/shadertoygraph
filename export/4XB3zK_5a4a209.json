{"ver":"0.1","info":{"id":"4XB3zK","date":"1708611172","viewed":69,"name":"raytracer_","username":"HexaPhoenix","description":"Common - settings\nBuffer A  - raytracer\nImage    - displays buffer A","likes":1,"published":1,"flags":32,"usePreview":0,"tags":["raytracing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord ) \n{\n    ivec2 p = ivec2(fragCoord);\n    vec3 color = texelFetch(iChannel0, p, 0).rgb;\n    \n    color *= live ? 1. : 1./(float(iFrame + 1));\n    \n    fragColor = vec4(color, 1);\n    }","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define pi acos(0.) * 2.\n\nvec3 camPos()\n{\n    return vec3(0, 0, -2);\n}\n\n\nfloat random(vec3 p, float seed)\n{\n    float x;\n    x = dot(p, vec3(123.45, 234.56, 345.67));\n    x += iTime * 97.32 + seed * 80.32;\n    \n    return fract(73.42 * sin(x));\n}\n\nvec2 randomGradient(vec2 p)\n{\n\n    p += 0.2;\n    float x,y;\n    x = dot(p, vec2(123.45,234.56));\n    y = dot(p, vec2(345.67,456.78));\n\n    return 0.5 + 0.5*sin(73.42*sin(vec2(x,y)));\n}\n\nvec3 randomColor(vec2 p)\n{\n    p += 0.2;\n    float x,y,z;\n    x = dot(p, vec2(123.45,234.56));\n    y = dot(p, vec2(345.67,456.78));\n    z = dot(p, vec2(456.78,567.89));\n\n    return 0.5 + 0.5*sin(73.42*sin(vec3(x,y,z)));\n}\n\nvec3 voronoi(vec2 p)\n{\n    vec2 id = floor(p);\n    vec2 uv = fract(p);\n\n    float minDist = 0.9; //intentionally low for random round egdes\n    vec2 minCell;\n\n    for(int x=-1;x<2;x++)\n    {\n        for(int y=-1;y<2;y++)\n        {\n            vec2 offset = vec2(x, y);\n            vec2 cell = id + offset;\n            float dist = distance(uv, randomGradient(cell) + offset);\n\n            if(dist < minDist)\n            {\n                minDist = dist;\n                minCell = cell;\n            }\n        }\n    }\n    return vec3(randomColor(minCell));\n}\n\nfloat randomNormalDistribution(vec3 p, float seed)\n{\n    float theta = 2. * pi * random(p, seed);\n    float rho = sqrt(-2. * log(random(p, seed + 0.5)));\n    return rho * cos(theta);\n}\n\nvec3 randomReflect(vec3 normal, vec3 p)\n{\n    vec3 random = vec3(\n        randomNormalDistribution(p, 0.),\n        randomNormalDistribution(p, 1.),\n        randomNormalDistribution(p, 2.)\n    );\n    \n    return random * sign(dot(random, normal));\n}\n\nstruct Ray\n{\n    vec3 pos;\n    vec3 dir;\n};\n\nstruct Mesh\n{\n    vec3 color;\n    float emit;\n    vec3 emitColor;\n    float smoothness;\n};\n\n\n\nstruct Sphere\n{\n    vec3 pos;\n    float radius;\n    Mesh mesh;\n};\n\nvec3 raySphere(Ray ray, Sphere sphere)\n{\n    float radius = sphere.radius;\n    vec3 rayPos = ray.pos - sphere.pos;\n    vec3 rayDir = normalize(ray.dir);\n    \n    float a = dot(rayDir, rayDir);\n    float b = 2. * dot(rayPos, rayDir);\n    float c = dot(rayPos, rayPos) - radius*radius;\n    \n    float discr = b*b - 4.*a*c;\n    \n    if(discr<0.)\n    {\n        return vec3(0);\n    }\n    else\n    {\n        float dist = (-b - sqrt(discr)) / (2.*a);\n        \n        if(dist >= 0.)\n        {\n            vec3 hitPos = ray.pos + rayDir * dist;\n        \n            return vec3(hitPos);\n        \n        }\n        else\n        {\n            return vec3(0);\n        }\n    }    \n}\n\n\nvec3 trace(vec3 camDir)\n{\n    //////////////////////////////////////////////////////////////////\n    //left\n    Sphere s1;\n    s1.pos = vec3(-1, (live ? (0.5 + 0.5*sin(iTime)) : 0.), 0);\n    s1.radius = 0.5;\n    s1.mesh.color = vec3(1, 0.75, 0.75);\n    s1.mesh.smoothness = 1.;\n    \n    //right\n    Sphere s2;\n    s2.pos = vec3(1, (live ? (0.5 + 0.5*cos(iTime)) : 0.), 0);\n    s2.radius = 0.5;\n    s2.mesh.color = vec3(0.75, 0.75, 1);\n    s2.mesh.smoothness = 1.;\n    \n    //floor\n    Sphere s3;\n    s3.pos = vec3(0, -10000.5, 0);\n    s3.radius = 10000.;\n    //s3.mesh.color = vec3(1, 1, 1);\n    s3.mesh.smoothness = 0.;\n    \n    const int sphereCount = 3;\n    Sphere[sphereCount] spheres = Sphere[sphereCount](s1, s2, s3);\n    //////////////////////////////////////////////////////////////////\n    \n    Ray ray;\n    ray.pos = camPos();\n    ray.dir = camDir;\n    \n    Sphere sphere;\n    vec3 color = vec3(1);\n    vec3 light = vec3(0);\n\n    for(int bounce=0; bounce<reflections; bounce++)\n    {\n        float minCamDist = 99999999999.;\n        vec3 minCamHitPos = vec3(0);\n        \n        Sphere minCamSphere;\n        minCamSphere.mesh.color;\n\n        for(int i=0; i<sphereCount; i++)\n        {\n            sphere = spheres[i];\n            vec3 hitPos = raySphere(ray, sphere);\n            \n            //floor coloring\n            if(sphere.pos == s3.pos) {vec2 p = hitPos.xz*2.; sphere.mesh.color = voronoi(p);}\n\n\n            float camDist = distance(camPos(), hitPos);\n            \n            if(camDist < minCamDist && hitPos != vec3(0))\n            {\n                minCamDist = camDist;\n                minCamHitPos = hitPos;\n                minCamSphere = sphere;\n            }    \n        }\n        \n        vec3 hitNormal = normalize(minCamHitPos - minCamSphere.pos);\n        Mesh mesh = minCamSphere.mesh;\n        \n        if(minCamHitPos == vec3(0)) \n        {\n            vec3 bg = texture(iChannel1, (ray.dir)).rgb;\n            light += bg * color;\n\n            return light;\n        }\n        \n        light += mesh.emitColor * mesh.emit * color * dot(-hitNormal, ray.dir);\n        color *= mesh.color; \n        \n        ray.pos = minCamHitPos;\n        ray.dir = normalize(mix(\n            randomReflect(hitNormal, minCamHitPos),\n            reflect(ray.dir, hitNormal),\n            mesh.smoothness\n        ));\n    }\n    return light;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord.xy*2. - iResolution.xy) / iResolution.x;\n    vec3 camDir = vec3(uv.x, uv.y, 1);\n    vec3 color = live ? vec3(0) : texelFetch(iChannel0, ivec2(fragCoord), 0).rgb;\n    \n    int iter = live ? rays : 1;\n    \n    for(int i=0;i<iter;i++)\n    {\n        color += trace(normalize(mix(\n            camDir,\n            randomReflect(camDir, vec3(fragCoord, i)),\n            1./max(iResolution.x, iResolution.y))\n        ));\n    }\n    \n    color /= live ? float(iter) : 1.;\n    \n    fragColor = vec4(color, 1);\n}\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define live false     //real-time-rendering if live\n#define rays 1         //rays per pixel; always 1 if not live\n#define reflections 32 //maximum surface reflections","name":"Common","description":"","type":"common"}]}