{"ver":"0.1","info":{"id":"ttGfDG","date":"1614956022","viewed":233,"name":"yet another mandelbrot shader","username":"arnestenkrona","description":"A very simple mandelbrot implementation","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["fractal","mandelbrot"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const vec3 palette[ 8 ] = vec3[8](   vec3( 0.0, 0.0, 0.0 ),\n                                vec3( 0.5, 0.5, 0.5 ),\n                                vec3( 1.0, 0.5, 0.5 ),\n                                vec3( 0.5, 1.0, 0.5 ),\n                                vec3( 0.5, 0.5, 1.0 ),\n                                vec3( 0.5, 1.0, 1.0 ),\n                                vec3( 1.0, 0.5, 1.0 ),\n                                vec3( 1.0, 1.0, 0.5 ) );\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    float depth = 16.0;\n    float scale = 1.5 / pow(2.0,depth*abs(sin(iTime/depth)));\n    vec2 offset = vec2(-1.5,0.0);\n\n\n    float aspectRatio = iResolution.x / iResolution.y;\n    vec2 uv = fragCoord/iResolution.xy;\n    float re0 = scale * 2.0 * (2.0 * (fragCoord.x /iResolution.x) - 1.0) + offset.x;\n    float im0 = scale * 2.0 * (1.0/aspectRatio) * (2.0 * (fragCoord.y /iResolution.y) - 1.0) + offset.y;\n\n\n    bool diverged = false;\n    float re = re0;\n    float im = im0;\n    int i;\n    for (i = 0; i < 200; ++i) {\n        if (re*re + im*im > 2000.0*2000.0) {\n            diverged = true;\n            break;\n        } \n        float retemp = re*re - im*im + re0;\n        im = 2.0*re*im + im0;\n        re = retemp;\n\n    }\n\n    vec3 col;\n\n    if (diverged) {\n        int nPalette = 8;\n\n        float gradScale = 1.0;\n        float smoothed = log2(log2(re*re+im*im) / 2.0);\n        float fColorIndex = (sqrt(float(i) + 10.0 - smoothed) * gradScale);\n\n        float colorLerp = fract(fColorIndex);\n        colorLerp = colorLerp*colorLerp*(3.0-2.0*colorLerp);\n        int colorIndexA = int(fColorIndex) % nPalette;\n        int colorIndexB = (colorIndexA + 1) % nPalette;\n\n        col = mix(palette[colorIndexA], palette[colorIndexB], colorLerp);\n    } else {\n        col = vec3(0,0,0);\n    }\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}