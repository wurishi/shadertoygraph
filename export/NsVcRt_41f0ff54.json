{"ver":"0.1","info":{"id":"NsVcRt","date":"1655391116","viewed":308,"name":"Simple NTSC codec","username":"Astherix","description":"This is a stripped down version of my more complete NTSC decoder\n\nThis one doesn't have any noise or overshoot, it's completely bare-bones","likes":4,"published":1,"flags":32,"usePreview":0,"tags":["ntsc"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Simple NTSC codec\n// Change Buffer A to whatever you want\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    fragColor = texture(iChannel0, fragCoord.xy / iResolution.xy);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Change this pass to whatever you want!\n\n// Robby Kraft\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float br = 0.75; // a less popular SMPTE version uses 1.0\n\n\tvec2 st = fragCoord.xy/iResolution.xy;\n\n\tbool sev1 = bool( step(st.x, 1.0/7.0) );\n\tbool sev2 = bool( step(st.x, 2.0/7.0) );\n\tbool sev3 = bool( step(st.x, 3.0/7.0) );\n\tbool sev4 = bool( step(st.x, 4.0/7.0) );\n\tbool sev5 = bool( step(st.x, 5.0/7.0) );\n\tbool sev6 = bool( step(st.x, 6.0/7.0) );\n\n\tbool row1 = !bool( step(st.y, 0.3333) );\n\tbool row2 = !bool( step(st.y, 0.25) );\n\n\t/////////////////////////////////////////\n\t// R : 0.75  1.0            1.0  1.0      \n\t// G : 0.75  1.0  1.0  1.0                \n\t// B : 0.75       1.0       1.0       1.0\n\t/////////////////////////////////////////\n\tfloat top_red =   br * float((sev6 && !sev4) || sev2 );\n\tfloat top_green = br * float(sev4);\n\tfloat top_blue =  br * float(!sev6 || (sev5 && !sev4) || (sev3 && !sev2) || sev1 );\n\n\t/////////////////////////////////////////\n\t// R :           1.0                 0.75      \n\t// G :                     1.0       0.75                \n\t// B : 1.0       1.0       1.0       0.75\n\t/////////////////////////////////////////\n\tfloat mid_red =   0.075*float( (sev6 && !sev5)||(sev4 && !sev3)||(sev2 && !sev1) ) + br * float(!sev6 || (sev3 && !sev2) );\n\tfloat mid_green = 0.075*float( (sev6 && !sev5)||(sev4 && !sev3)||(sev2 && !sev1) ) + br * float(!sev6 || (sev5 && !sev4) );\n\tfloat mid_blue =  0.075*float( (sev6 && !sev5)||(sev4 && !sev3)||(sev2 && !sev1) ) + br * float(!sev6 || (sev5 && !sev4) || (sev3 && !sev2) || sev1);\n\n\t///////////////////////\n\t// R: 0.00  1.0  0.22\n\t// G: 0.24  1.0  0.00\n\t// B: 0.35  1.0  0.5\n\t/////////////////////// \n\tbool fourth1 = bool( step(st.x, 1.0*(5.0/7.0)/4.0 ));\n\tbool fourth2 = bool( step(st.x, 2.0*(5.0/7.0)/4.0 ));\n\tbool fourth3 = bool( step(st.x, 3.0*(5.0/7.0)/4.0 ));\n\tbool fourth4 = bool( step(st.x, (5.0/7.0) ));\n\n\tbool littleThird1 = bool( step(st.x, 5.0/7.0 + 1.0/7.0/3.0) );\n\tbool littleThird2 = bool( step(st.x, 5.0/7.0 + 1.0/7.0/3.0*2.0) );\n\tbool littleThird3 = bool( step(st.x, 5.0/7.0 + 1.0/7.0/3.0*3.0) );\n\n\tfloat bottom_red =                         float(fourth2 && !fourth1) + 0.22*float(fourth3 && !fourth2) + 0.075*float(fourth4 && !fourth3) + 0.075*float(littleThird2 && !littleThird1) + 0.15*float(littleThird3 && !littleThird2) + 0.075*float(!sev6);\n\tfloat bottom_green = 0.24*float(fourth1) + float(fourth2 && !fourth1)                                   + 0.075*float(fourth4 && !fourth3) + 0.075*float(littleThird2 && !littleThird1) + 0.15*float(littleThird3 && !littleThird2) + 0.075*float(!sev6);\n\tfloat bottom_blue =  0.35*float(fourth1) + float(fourth2 && !fourth1) + 0.5*float(fourth3 && !fourth2)  + 0.075*float(fourth4 && !fourth3) + 0.075*float(littleThird2 && !littleThird1) + 0.15*float(littleThird3 && !littleThird2) + 0.075*float(!sev6);\n\n\tfragColor = vec4(top_red*float(row1)   + mid_red*float(row2 && !row1) + bottom_red*float(!row2), \n\t                 top_green*float(row1) + mid_green*float(row2 && !row1) + bottom_green*float(!row2), \n\t                 top_blue*float(row1)  + mid_blue*float(row2 && !row1) + bottom_blue*float(!row2),1.);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// Encoder or Modulator\n// This pass converts RGB colors on iChannel0 to\n// a YIQ (NTSC) Composite signal.\n\n#define PI   3.14159265358979323846\n#define TAU  6.28318530717958647693\n\nconst mat3 rgb_to_yiq = mat3(0.299, 0.596, 0.211,\n                             0.587,-0.274,-0.523,\n                             0.114,-0.322, 0.312);\n\n// Alternative RGB to YIQ matrix\n// const mat3 rgb_to_yiq = mat3(0.299, 0.587, 0.114,\n//                              0.596,-0.274,-0.322,\n//                              0.211,-0.523, 0.312);\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Chroma encoder oscillator frequency \n    float fc = iResolution.x;\n    \n    // Base oscillator angle for this dot\n    float t = float(fragCoord.x);\n    \n    // Get a pixel from iChannel0\n    vec3 rgb = texture(iChannel0, fragCoord.xy / iResolution.xy).rgb;\n\n    // Convert to YIQ\n    vec3 yiq = rgb_to_yiq * rgb;\n    \n    // Final oscillator angle\n    float f = fc * t;\n    \n    // Modulate IQ signals\n    float i = yiq.y * cos(f), // I signal\n          q = yiq.z * sin(f); // Q signal\n    \n    // Add to Y to get the composite signal\n    float c = yiq.x + (i + q); // Composite\n    \n    // Return a grayscale representation of the signal\n    fragColor = vec4(vec3(c), 1.0);\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"// Decoder or Demodulator\n// This pass takes the Composite signal generated on Buffer B\n// and decodes it\n\n#define PI   3.14159265358979323846\n#define TAU  6.28318530717958647693\n\n#define BRIGHTNESS_FACTOR        10.0\n\n// The decoded IQ signals get multiplied by this\n// factor. Bigger values yield more color saturation\n#define CHROMA_SATURATION_FACTOR 7.0\n\n// Size of the decoding FIR filter. bigger values\n// yield more smuggly video and are more expensive\n#define CHROMA_DECODER_FIR_SIZE  20\n#define LUMA_DECODER_FIR_SIZE  10\n\n// YIQ to RGB matrix\nconst mat3 yiq_to_rgb = mat3(1.000, 1.000, 1.000,\n                             0.956,-0.272,-1.106,\n                             0.621,-0.647, 1.703);\n\nfloat blackman(float n, float N) {\n    float a0 = (1.0 - 0.16) / 2.0;\n    float a1 = 1.0 / 2.0;\n    float a2 = 0.16 / 2.0;\n    \n    return a0 - (a1 * cos((2.0 * PI * n) / N)) + (a2 * cos((4.0 * PI * n) / N)) * 1.0;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Chroma decoder oscillator frequency\n    float fc = iResolution.x;\n    \n    float counter = 0.0;\n    \n    // Sum and decode NTSC samples\n    // This is essentially a simple averaging filter\n    // that happens to be weighted by two cos and sin\n    // oscillators at a very specific frequency\n    vec3 yiq;\n    \n    // Decode Luma first\n    for (int d = 0; d < LUMA_DECODER_FIR_SIZE; d++) {\n        vec2 pos = vec2(fragCoord.x + float(d) - float(LUMA_DECODER_FIR_SIZE / 2), fragCoord.y);\n\n        vec3 s = texture(iChannel0, pos / iResolution.xy).rgb;\n\n        float t = fc * (fragCoord.x + float(d));\n        \n        // Apply Blackman window for smoother colors\n        float window = blackman(float(d), float(LUMA_DECODER_FIR_SIZE)); \n\n        yiq += s * vec3(BRIGHTNESS_FACTOR, 0.0, 0.0) * window;\n\n        //counter++;\n    }\n    \n    // Then decode chroma\n    for (int d = -CHROMA_DECODER_FIR_SIZE; d < CHROMA_DECODER_FIR_SIZE; d++) {\n        vec2 pos = vec2(fragCoord.x + float(d), fragCoord.y);\n\n        vec3 s = texture(iChannel0, pos / iResolution.xy).rgb;\n\n        float t = fc * (fragCoord.x + float(d));\n        \n        // Apply Blackman window for smoother colors\n        float window = blackman(float(d + CHROMA_DECODER_FIR_SIZE), float(CHROMA_DECODER_FIR_SIZE * 2 + 1)); \n\n        yiq += s * vec3(0.0, cos(t), sin(t)) * window;\n\n        counter++;\n    }\n\n    yiq /= counter;\n\n    // Saturate chroma (IQ)\n    yiq.yz *= CHROMA_SATURATION_FACTOR;\n\n    fragColor = vec4((yiq_to_rgb * yiq), 1.0);\n}","name":"Buffer C","description":"","type":"buffer"}]}