{"ver":"0.1","info":{"id":"4d3cDn","date":"1518397604","viewed":491,"name":"Falling sandbox","username":"Scoo","description":"A colorful interactive sandbox. Spawn sand by dragging the mouse around.\n\nControls:\n* 1/2/3: set sand color\n* E: switch to eraser\n* R: reset\n* A: toggle auto-fill mode\n* F: flip","likes":6,"published":1,"flags":48,"usePreview":0,"tags":["interactive","falling","drawing","sand"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Sand visualization based on the state computed in the simulation.\n\n// Sand 1: white/grey\nconst vec4 SAND_1_COLOR_1 = vec4(0.75, 0.70, 0.70, 1.0);\nconst vec4 SAND_1_COLOR_2 = vec4(0.55, 0.60, 0.60, 1.0);\n// Sand 2: black/grey\nconst vec4 SAND_2_COLOR_1 = vec4(0.25, 0.28, 0.28, 1.0);\nconst vec4 SAND_2_COLOR_2 = vec4(0.18, 0.18, 0.22, 1.0);\n// Sand 3: tan/orange\nconst vec4 SAND_3_COLOR_1 = vec4(0.70, 0.40, 0.13, 1.0);\nconst vec4 SAND_3_COLOR_2 = vec4(0.95, 0.68, 0.47, 1.0);\n\n// Samples the simulation state at the given location.\nvec4 fetchSimState(vec2 fragCoord) {\n    return texelFetch(iChannel0, ivec2(fragCoord), 0);\n}\n\n// Samples other state at the given location.\nvec4 fetchOtherState(ivec2 fragCoord) {\n    return texelFetch(iChannel1, fragCoord, 0);\n}\n\n// Blends `source` color into `dest` color, using `source` alpha.\n// `dest` alpha is ignored and the output alpha is 1.0.\nvec4 alphaBlend(vec4 dest, vec4 source) {\n    vec3 blended = (source.rgb * source.a) + (dest.rgb * (1.0 - source.a));\n    return vec4(blended, 1.0);\n}\n\nvec4 getSandColor(vec4 simState) {   \n    if (simState.x == 1.0) {\n    \treturn mix(SAND_1_COLOR_1, SAND_1_COLOR_2, simState.y);\n    } else if (simState.x == 2.0) {\n        return mix(SAND_2_COLOR_1, SAND_2_COLOR_2, simState.y);\n    } else if (simState.x == 3.0) {\n        return mix(SAND_3_COLOR_1, SAND_3_COLOR_2, simState.y);\n    } else {\n        return vec4(0.0, 0.0, 0.0, 1.0);\n    }\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Draw the simulation (colored sand).\n    vec4 simState = fetchSimState(fragCoord);\n    fragColor = getSandColor(simState);\n    \n    // Draw UI for tool state.\n    vec4 toolState = fetchOtherState(STATE_LOCATION_TOOL);\n    if (toolState.x == STATE_TOOL_TYPE_BRUSH) {\n        // Show what color of sand the brush is set to.\n        // TODO: show brush shape, modulate/animate somehow?\n        vec4 sandColor = getSandColor(vec4(toolState.y + 1.0, 0.0, 0.0, 1.0));\n        if (fragCoord.x < 20.0 && fragCoord.y > iResolution.y - 20.0) {\n           fragColor = sandColor; \n        }\n    } else if (toolState.x == STATE_TOOL_TYPE_ERASER) {\n        // Draw a circle around the eraser when in use.\n        if (iMouse.z > 0.0 && abs(distance(fragCoord, iMouse.xy) - BRUSH_SIZE) < 1.0) {\n            fragColor = alphaBlend(fragColor, vec4(1.0, 1.0, 1.0, 0.9));\n        }\n    }\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Sand simulation.\n// Each cell (texel) tracks whether it contains sand or not.\n// The simulation advances at one step per frame (not framerate independent).\n//\n// State for each texel is defined as:\n//   x: type of sand (0.0 = none, 1.0 = type 1, 2.0 = type 2, etc.)\n//   y: color variation in range [0.0, 1.0]\n//   z: unused\n//   w: unused\n\n#define SOLID_GROUND_BELOW\n#define WALLS_ON_THE_SIDES\n\nconst int KEY_F = 70;\nconst int KEY_R = 82;\n\n// Keyboard input functions. Reference: https://www.shadertoy.com/view/lsXGzf .\nbool isKeyHeld   (int keyCode) { return texelFetch(iChannel3, ivec2(keyCode, 0), 0).x == 1.0; }\nbool isKeyPressed(int keyCode) { return texelFetch(iChannel3, ivec2(keyCode, 1), 0).x == 1.0; }\nbool isKeyToggled(int keyCode) { return texelFetch(iChannel3, ivec2(keyCode, 2), 0).x == 1.0; }\n\n// Samples the simulation state at the given location.\nvec4 fetchSimState(vec2 fragCoord, ivec2 offset) {\n    return texelFetch(iChannel0, ivec2(fragCoord) + offset, 0);\n}\n\n// Samples other state at the given location.\nvec4 fetchOtherState(ivec2 fragCoord) {\n    return texelFetch(iChannel1, fragCoord, 0);\n}\n\n// Alternates which direction sand falls each frame.\n// TODO: randomized updating across the image (figure out how to make consistent)\nbool updatingLeft() {\n    return mod(float(iFrame), 2.0) == 0.0;\n}\n\nvec4 updateState(vec2 fragCoord) {\n    vec4 previousState = fetchSimState(fragCoord, ivec2(0, 0));\n    vec4 nextState = previousState;\n    \n    // Sand falls down if there is empty space below.\n    // Sand can only fall into a cell if there is no sand already in it.\n    // Each cell (fragment) wants to know \"Will I have sand next tick?\".\n    \n    vec4 stateLeft  = fetchSimState(fragCoord, ivec2(-1, 0));\n    vec4 stateRight = fetchSimState(fragCoord, ivec2( 1, 0));\n    \n    if (previousState.x > 0.0) {\n        // This cell has sand. Keep it or let it fall below.\n        vec4 stateBelow      = fetchSimState(fragCoord, ivec2( 0, -1));\n        vec4 stateBelowLeft  = fetchSimState(fragCoord, ivec2(-1, -1));\n        vec4 stateBelowRight = fetchSimState(fragCoord, ivec2( 1, -1));\n        #ifdef SOLID_GROUND_BELOW\n        if (fragCoord.y < 1.0) {\n            stateBelow      = vec4(1.0);\n            stateBelowLeft  = vec4(1.0);\n            stateBelowRight = vec4(1.0);\n        }\n        #endif  // SOLID_GROUND_BELOW\n        #ifdef WALLS_ON_THE_SIDES\n        if (fragCoord.x < 1.0)                 { stateBelowLeft  = vec4(1.0); }\n        if (fragCoord.x > iResolution.x - 1.0) { stateBelowRight = vec4(1.0); }\n        #endif  // WALLS_ON_THE_SIDES\n        \n        if (stateBelow.x == 0.0) {\n            // Fall down.\n            nextState.x = 0.0;\n            nextState.y = 0.0;\n        } else if ( updatingLeft() && stateBelowLeft.x  == 0.0 && stateLeft.x  == 0.0) {\n            // Fall down left.\n            nextState.x = 0.0;\n            nextState.y = 0.0;\n        } else if (!updatingLeft() && stateBelowRight.x == 0.0 && stateRight.x == 0.0) {\n            // Fall down right.\n            nextState.x = 0.0;\n            nextState.y = 0.0;\n        } else {\n            // Keep sand in this cell. Keep previous state.\n        }\n    } else {\n        // TODO: Remove else? Can both steps run in a single pass?\n        \n        // This cell does not have sand. Try to receive sand from above.\n        vec4 stateAbove      = fetchSimState(fragCoord, ivec2( 0, 1));\n        vec4 stateAboveLeft  = fetchSimState(fragCoord, ivec2(-1, 1));\n        vec4 stateAboveRight = fetchSimState(fragCoord, ivec2( 1, 1));\n        \n        if (stateAbove.x > 0.0) {\n            // Receive from above.\n            nextState.x = stateAbove.x;\n            nextState.y = stateAbove.y;\n        } else if ( updatingLeft() && stateAboveRight.x != 0.0 && stateRight.x != 0.0) {\n            // Receive from above right.\n            nextState.x = stateAboveRight.x;\n            nextState.y = stateAboveRight.y;\n        } else if (!updatingLeft() && stateAboveLeft.x  != 0.0 && stateLeft.x  != 0.0) {\n            // Receive from above left.\n            nextState.x = stateAboveLeft.x;\n            nextState.y = stateAboveLeft.y;\n        } else {\n            // No sand to recieve. Keep previous state.\n        }\n    }\n    \n    return nextState;\n}\n\n// Adds sand at the provided coordinates.\nvec4 applyBrushFill(vec2 fragCoord, vec4 simulationState, vec4 toolState) {\n    if (simulationState.x != 0.0) {\n        return simulationState;\n    }\n    \n    float sandType = toolState.y + 1.0;\n    \n    // Triangle wave /\\/\\/\\/\\/\\ over time.\n    // TODO: mix some spatial noise into this?\n    // TODO: pull into Common so Image can use show the current brush in the UI\n    float colorVariation = abs(mod(iTime, 2.0) - 1.0);\n    \n    return vec4(sandType, colorVariation, 0.0, 1.0);\n}\n\n// Erases sand at the provided coordinates.\nvec4 applyBrushEraser(vec2 fragCoord, vec4 simulationState, vec4 toolState) {\n    return vec4(0.0, 0.0, 0.0, 1.0);\n}\n\n// Fills sand without mouse input when auto-mode is enabled.\nvec4 applyAutoModeBrush(vec2 fragCoord, vec4 simulationState) {\n    float x = (sin(iTime) + 1.0) / 2.0 * iResolution.x;\n    float y = iResolution.y - BRUSH_SIZE - 20.0;\n    vec2 autoMouse = vec2(x, y);\n    \n    if (distance(fragCoord, autoMouse) >= AUTO_BRUSH_SIZE) {\n        return simulationState;\n    }\n        \n    float sandType = floor(abs(mod(iTime / 10.0, 2.0) - 1.0) * 3.0);\n    vec4 autoToolState = vec4(0.0, sandType, 0.0, 1.0);\n    \n    return applyBrushFill(fragCoord, simulationState, autoToolState);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Reset when the R key is pressed.\n    if (isKeyPressed(KEY_R)) {\n        fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n        return;\n    }\n    \n    // Flip when the F key is pressed.\n    if (isKeyPressed(KEY_F)) {\n        ivec2 flippedCoord = ivec2(fragCoord.x, iResolution.y - fragCoord.y);\n        fragColor = texelFetch(iChannel0, flippedCoord, 0);\n        return;\n    }\n    \n    // Tick simulation.\n    vec4 nextState = updateState(fragCoord);\n    \n    // Process input.\n    vec4 toolState = fetchOtherState(STATE_LOCATION_TOOL);\n    \n    // Apply brushes around where the mouse is held.\n    // TODO: different brush shapes\n    if (iMouse.z > 0.0 && distance(fragCoord, iMouse.xy) < BRUSH_SIZE) {\n        if (toolState.x == STATE_TOOL_TYPE_BRUSH) {\n            nextState = applyBrushFill(fragCoord, nextState, toolState);     \n        } else if (toolState.x == STATE_TOOL_TYPE_ERASER) {\n            nextState = applyBrushEraser(fragCoord, nextState, toolState);\n        }\n    }\n    \n    vec4 autoModeState = fetchOtherState(STATE_LOCATION_AUTO_MODE);\n    if (autoModeState.x == 0.0) {\n    \tnextState = applyAutoModeBrush(fragCoord, nextState);        \n    }\n    \n    fragColor = nextState;\n}","name":"Buf A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// Other state tracking. UI / Controls.\n\nconst int KEY_1 = 49;\nconst int KEY_2 = 50;\nconst int KEY_3 = 51;\nconst int KEY_A = 65;\nconst int KEY_E = 69;\n\n// Keyboard input functions. Reference: https://www.shadertoy.com/view/lsXGzf .\nbool isKeyHeld   (int keyCode) { return texelFetch(iChannel3, ivec2(keyCode, 0), 0).x == 1.0; }\nbool isKeyPressed(int keyCode) { return texelFetch(iChannel3, ivec2(keyCode, 1), 0).x == 1.0; }\nbool isKeyToggled(int keyCode) { return texelFetch(iChannel3, ivec2(keyCode, 2), 0).x == 1.0; }\n\n// Helper function to sample the state at a given location.\nvec4 fetchState(ivec2 fragCoord) {\n    return texelFetch(iChannel0, fragCoord, 0);\n}\n\n// Updates tool state.\n// x: tool type (STATE_TOOL_TYPE_BRUSH, STATE_TOOL_TYPE_ERASER)\n// y: variation (sand type - 1 for brush, -1 so the default state is type 1)\n// TODO: brush shape\nvec4 updateToolState() {\n    vec4 previousToolState = fetchState(STATE_LOCATION_TOOL);\n    \n    if (isKeyPressed(KEY_1)) {\n        return vec4(STATE_TOOL_TYPE_BRUSH, 0.0, 0.0, 1.0);\n    } else if (isKeyPressed(KEY_2)) {\n        return vec4(STATE_TOOL_TYPE_BRUSH, 1.0, 0.0, 1.0);\n    } else if (isKeyPressed(KEY_3)) {\n        return vec4(STATE_TOOL_TYPE_BRUSH, 2.0, 0.0, 1.0);\n    } else if (isKeyPressed(KEY_E)) {\n        return vec4(STATE_TOOL_TYPE_ERASER, 0.0, 0.0, 1.0);\n    }\n    \n    return previousToolState;\n}\n\nvec4 updateAutoModeState() {\n    return isKeyToggled(KEY_A) ? vec4(1.0, 0.0, 0.0, 1.0) : vec4(0.0, 0.0, 0.0, 1.0);    \n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    if (ivec2(fragCoord) == STATE_LOCATION_TOOL) {\n        fragColor = updateToolState();\n    } else if (ivec2(fragCoord) == STATE_LOCATION_AUTO_MODE) {\n        fragColor = updateAutoModeState();\n    } else {\n        // Unused\n        fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n    }\n}","name":"Buf B","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define AUTO_BRUSH_SIZE 4.0\n#define BRUSH_SIZE 16.0\n\n// State locations tracked in Buf B.\nconst ivec2 STATE_LOCATION_TOOL = ivec2(0, 0);\nconst ivec2 STATE_LOCATION_AUTO_MODE = ivec2(1, 0);\nconst float STATE_TOOL_TYPE_BRUSH  = 0.0;\nconst float STATE_TOOL_TYPE_ERASER = 1.0;","name":"Common","description":"","type":"common"}]}