{"ver":"0.1","info":{"id":"mtKSWw","date":"1686144348","viewed":40,"name":"Eliminate dither variance bands","username":"stduhpf","description":"follow-up of https://www.shadertoy.com/view/NltBD7\nEven when dithering color gradients to avoid banding, it can be easy to notice some bands of very low variance. Increasing the variance overall can help mitigate this effect.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["dithering"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":0,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n// Fork of \"Linear dithering doesn't matter\" by stduhpf. https://shadertoy.com/view/NltBD7\n// 2023-06-06 16:23:01\n\n#define BIT_DEPTH 4\n#define GAMMA 2.2\n\n\nfloat sqd(float a, float b){\n    a-=b;\n    return a*a;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float eps = 1./iResolution.y;\n    vec2 uv = fragCoord*eps;\n    \n    vec4 noise = texture(iChannel0,(fragCoord)/iChannelResolution[0].xy);\n    //merge channels for better noise precision;\n    noise = noise*255./256.+noise.yzwx*255./(256.*256.);\n    noise+=noise.zwxy/(256.*256.); // the two last channels\n    \n    \n    const float prec = float((1<<BIT_DEPTH)-1); //8-bit color range: 0.->255.\n    \n    float x =uv.x*iResolution.y/iResolution.x;\n    \n    float max_ = 1.; // max brightness of the color ramp\n    float max_l = pow(max_,GAMMA); // same thing but in linear\n\n    float l0 = max_*(x); //gamma-space value\n    float lin0 = pow(l0,GAMMA); //linear-space value\n\n\n    //default quantization (causes banding)\n    float q = round(l0*prec)/prec;\n    float q0 = max(q-.5/prec,0.);\n    float q1 = min(q+.5/prec,1.);\n    \n    float lq = pow(q,GAMMA);\n    float lq0 = pow(q0,GAMMA);\n    float lq1 = pow(q1,GAMMA);\n\n    \n    //pre-dithering (linear)\n    float xp = (lin0-lq0)/(lq1-lq0);\n    \n    float l = uv.y*4.<2.?l0:mix(q0,q1,step(noise.x,xp));\n    float lin = uv.y*4.<2.?lin0:mix(lq0,lq1,step(noise.x,xp));\n    \n    \n    float lpvarl = mix(sqd(lin0,lq0),sqd(lin0,lq1),xp);\n    float lpvarg = mix(sqd(l0,q0),sqd(l0,q1),xp);\n\n    \n    // get quantization \"bounds\"\n    float lfg = floor(l*prec)/prec;\n    float lcg = ceil(l*prec)/prec;\n    \n    // convert bounds to linear\n    float lfl = pow(lfg,GAMMA);\n    float lcl = pow(lcg,GAMMA);\n    \n    float xl = (lin-lfl)/(lcl-lfl);\n            \n    //varience\n    float lvarl = mix(sqd(lin,lfl),sqd(lin,lcl),xl);\n    \n    //perceptual variance\n    float gvarl = mix(sqd(l,lfg),sqd(l,lcg),xl);\n    \n    \n    //get total variance\n    float lvartot,gvartot;\n    {\n        float lvarl0,gvarl0;\n        {float l = q0+.01, lin = lq0;\n            float lfg = floor(l*prec)/prec;\n            float lcg = ceil(l*prec)/prec;\n\n            // convert bounds to linear\n            float lfl = pow(lfg,GAMMA);\n            float lcl = pow(lcg,GAMMA);\n\n            float xl = (lin-lfl)/(lcl-lfl);\n\n            //varience\n            lvarl0 = mix(sqd(lin0,lfl),sqd(lin0,lcl),xl);\n\n            //perceptual variance\n            gvarl0 = mix(sqd(l0,lfg),sqd(l0,lcg),xl);\n        }\n        float lvarl1,gvarl1;\n        {float l = q1-.01, lin = lq1;\n            float lfg = floor(l*prec)/prec;\n            float lcg = ceil(l*prec)/prec;\n\n            // convert bounds to linear\n            float lfl = pow(lfg,GAMMA);\n            float lcl = pow(lcg,GAMMA);\n\n            float xl = (lin-lfl)/(lcl-lfl);\n\n            //varience\n            lvarl1 = mix(sqd(lin0,lfl),sqd(lin0,lcl),xl);\n\n            //perceptual variance\n            gvarl1 = mix(sqd(l0,lfg),sqd(l0,lcg),xl);\n        }\n        \n        lvartot = mix(lvarl0,lvarl1,xp);\n        if(isnan(lvartot))lvartot = 1e6;\n        gvartot = mix(gvarl0,gvarl1,xp);\n    \n    }\n    \n    vec3 dithered = vec3(\n        uv.y*4.<1.?\n            sqrt(gvarl)*prec:\n            uv.y*4.<2.?\n                mix(lfg,lcg,step(noise.y,xl)):\n                uv.y*4.<3.?\n                    sqrt(gvartot)*prec: \n                    mix(lfg,lcg,step(noise.y,xl))\n        ); \n        \n\n    fragColor = vec4(dithered,0.);\n}","name":"Image","description":"","type":"image"}]}