{"ver":"0.1","info":{"id":"dtd3Dr","date":"1682282366","viewed":89,"name":"Random poisson disk","username":"david_huculak","description":"Playing around with a poisson disk that can be used for soft shadow sampling as per https://developer.nvidia.com/gpugems/gpugems2/part-ii-shading-lighting-and-shadows/chapter-17-efficient-soft-edged-shadows-using","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["shadows"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define AA 1\n\n#if AA\nconst float AA_BLUR = 1.5; // higher value means more blur\n#endif\n\n// controls the number of dots aka samples. dot count will be GRID_DIM * GRID_DIM\nconst int GRID_DIM = 8;\n\nconst float GRID_SIZE = 250.0;\nconst float CELL_SIZE = GRID_SIZE / float(GRID_DIM);\n\nconst float DOT_RADIUS = 3.0;\nconst vec3 BACKGROUND_COL = vec3(0.0, 0.0, 0.0);\nconst vec3 EARLY_TEST_DOT_COLOR = vec3(0.0, 0.4, 0.0);\nconst vec3 BASE_GRID_COL = vec3(0.2, 0.2, 0.2);\nconst vec3 JITTER_GRID_COL = vec3(0.6, 0.1, 0.1);\n\nvec2 to_screen_space(vec2 coord)\n{\n    vec2 grid_top_left_corner = vec2((iResolution.x - GRID_SIZE) / 2.0, (iResolution.y - GRID_SIZE) / 2.0);\n    return coord * GRID_SIZE + grid_top_left_corner;\n}\n\nvec2 grid_test(ivec2 grid_coord, vec2 fragCoord)\n{\n    // base grid\n    float cell_size = 1.0 / float(GRID_DIM);\n    vec2 cell_center = cell_size / 2.0 + vec2(\n        cell_size  * float(grid_coord.x),\n        cell_size  * float(grid_coord.y)\n    );\n    \n    // jittered grid\n    float base_seed = round(iTime * 2.0);\n    float t = float(grid_coord.x * GRID_DIM + grid_coord.y);\n    float seed_x = base_seed + t * 2.0;\n    float seed_y = base_seed + (t + 0.5) * 4.0;\n    vec2 jitter = 2.0 * vec2(noise(seed_x), noise(seed_y)) - 1.0;\n    float max_jitter = cell_size / 2.0;\n    vec2 jittered_cell_center = cell_center + max_jitter * jitter;\n\n    // disk warp\n    cell_center = disk_warp(cell_center);\n    jittered_cell_center = disk_warp(jittered_cell_center);\n    \n#if AA\n     return vec2(\n         smoothstep(1.0, 0.0, (distance(to_screen_space(cell_center), fragCoord) - DOT_RADIUS) / AA_BLUR),\n         smoothstep(1.0, 0.0, (distance(to_screen_space(jittered_cell_center), fragCoord) - DOT_RADIUS) / AA_BLUR)\n     );\n#else\n    if (distance(to_screen_space(jittered_cell_center), fragCoord) <= DOT_RADIUS) {\n        return vec2(0.0, 1.0);\n    } else if (distance(to_screen_space(cell_center), fragCoord) <= DOT_RADIUS) {\n        return vec2(1.0, 0.0);\n    }\n#endif\n\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 col = BACKGROUND_COL;\n    \n    float cell_size = 1.0 / float(GRID_DIM);\n    \n    ivec2[] early_test_coords = ivec2[] (\n        ivec2(0, 0),\n        ivec2(0, 0),\n        ivec2(0, 0),\n        ivec2(0, 0)\n    );\n    if (GRID_DIM == 8)\n    {\n        early_test_coords = ivec2[] (\n            ivec2(1, 7),\n            ivec2(3, 7),\n            ivec2(5, 7),\n            ivec2(7, 7)\n        );\n    }\n    if (GRID_DIM == 6)\n    {\n        early_test_coords = ivec2[] (\n            ivec2(0, 5),\n            ivec2(1, 5),\n            ivec2(2, 5),\n            ivec2(4, 5)\n        );\n    }\n    if (GRID_DIM == 4)\n    {\n        early_test_coords = ivec2[] (\n            ivec2(0, 3),\n            ivec2(1, 3),\n            ivec2(2, 3),\n            ivec2(3, 3)\n        );\n    }\n\n    // early test samples\n    for (int i = 0; i < 4; i++)\n    {\n        ivec2 coord = early_test_coords[i];\n        vec2 grid_test_result = grid_test(coord, fragCoord);\n        bool is_base_grid_col = grid_test_result.x > 0.0;\n        bool is_jitter_grid_col = grid_test_result.y > 0.0;\n#if AA\n        col += EARLY_TEST_DOT_COLOR * grid_test_result.x;\n        col += EARLY_TEST_DOT_COLOR * 2.0 * grid_test_result.y;\n#else\n        if (is_jitter_grid_col) {\n            col += EARLY_TEST_DOT_COLOR * 2.0;\n        } else if (is_base_grid_col) {\n            col += EARLY_TEST_DOT_COLOR;\n        }\n#endif\n    }\n    \n    // the rest of the samples\n    for (int i = 0; i < GRID_DIM; i++) { \n        for (int j = 0; j < GRID_DIM; j++) {\n            ivec2 coord = ivec2(i, j);\n            if (early_test_coords[0] == coord)\n            {\n                continue;\n            }\n            if (early_test_coords[1] == coord)\n            {\n                continue;\n            }\n            if (early_test_coords[2] == coord)\n            {\n                continue;\n            }\n            if (early_test_coords[3] == coord)\n            {\n                continue;\n            }\n            vec2 grid_test_result = grid_test(coord, fragCoord);\n#if AA\n            col += BASE_GRID_COL * grid_test_result.x;\n            col += JITTER_GRID_COL * grid_test_result.y;\n#else\n            bool is_base_grid_col = grid_test_result.x > 0.0;\n            bool is_jitter_grid_col = grid_test_result.y > 0.0;\n            if (is_jitter_grid_col) {\n                col += JITTER_GRID_COL;\n            } else if (is_base_grid_col) {\n                col += BASE_GRID_COL;\n            }\n#endif\n        }\n\t}\n\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"const float PI = 3.14159265359;\n\nfloat rand(float n)\n{\n    return fract(sin(n) * 43758.5453123);\n}\n\n// https://gist.github.com/munrocket/236ed5ba7e409b8bdf1ff6eca5dcdc39\nfloat noise(float p)\n{\n  float fl = floor(p);\n  float fc = fract(p);\n  return mix(rand(fl), rand(fl + 1.), fc);\n}\n\n// https://developer.nvidia.com/gpugems/gpugems2/part-ii-shading-lighting-and-shadows/chapter-17-efficient-soft-edged-shadows-using\nvec2 disk_warp(vec2 coord)\n{\n    return 0.5 * vec2(\n        sqrt(coord.y) * cos(2.0 * PI * coord.x),\n        sqrt(coord.y) * sin(2.0 * PI * coord.x)\n    ) + 0.5;\n}","name":"Common","description":"","type":"common"}]}