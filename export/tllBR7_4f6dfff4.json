{"ver":"0.1","info":{"id":"tllBR7","date":"1596419224","viewed":75,"name":"Growing Gyroid","username":"Giraugh","description":"Basic ray-marcher engine with a couple of shapes implemented.\nAdapted from a tutorial by `The Art of Code`","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .01\n#define AMBIENT_LIGHT 0.3\n\nmat2 Rot(float a) {\n\tfloat s = sin(a);\n\tfloat c = cos(a);\n\treturn mat2(\n    \tc, -s, s, c\n    );\n}\n\nfloat sdBox(vec3 point, vec3 origin, vec3 size) {\n    point = abs((point-origin)) - size;\n\treturn length(max(point, 0.))+min(max(point.x, max(point.y, point.z)), 0.);\n}\n\nfloat sdSphere(vec3 point, vec3 origin, float radius) {\n\treturn length(point - origin) - radius;\n}\n\nfloat sdGyroid(vec3 p, float scale, float thickness, float bias) {\n    float ss = iTime/30.;\n    p *= scale;\n\treturn abs(bias + dot(sin(p*ss), cos(p.zxy))) / (scale * max(1., ss)) - thickness;\n}\n\nfloat GetDist(vec3 p) {\n\t// plane at origin with normal of Y axis\n    float planeD = p.y;\n    \n    // Sphere\n    vec3 sphereO = vec3(0, 1, 0);\n    float sphereR = 1.;\n    float sphereD = sdSphere(p, sphereO, sphereR);\n    \n    // Box \n    vec3 boxO = vec3(0, 1, 0);\n    vec3 boxS = vec3(1);\n    float boxD = sdBox(p, boxO, boxS);\n    \n    // Blend the sphere and the box\n    float blendD = mix(sphereD, boxD, (1. + sin(iTime))/2.);\n    \n    \n    float container = sdBox(p, vec3(0), vec3(4));\n    float gyroid = sdGyroid(p, 2., .05, 1.);\n    \n    return max(container, gyroid*.7);\n    \n    // return min(min(blendD, planeD), gyroid);\n}\n\nfloat RayMarch(vec3 rayOrigin, vec3 rayDirection) {\n\tfloat d = 0.;\n    for (int i=0; i<MAX_STEPS; i++) {\n        vec3 p = rayOrigin + d*rayDirection;\n        float delta_d = GetDist(p);\n        d += delta_d;\n        if (d > MAX_DIST || abs(delta_d) < SURF_DIST) break;\n    }\n    return d;\n}\n\nvec3 GetNormal(vec3 point) {\n    // We use 'e' to represent a small step\n    vec2 e = vec2(.001,0);\n    \n    // Get distance to scene at P\n    float d = GetDist(point);\n    \n    // Compute normal by sampling scene dist at\n    // small offsets\n    vec3 n = d - vec3(\n    \tGetDist(point - e.xyy),\n        GetDist(point - e.yxy),\n        GetDist(point - e.yyx)\n    );\n    \n    return normalize(n);\n}\n\nfloat GetLightingPoint(vec3 point) {\n\t// Define light position\n    vec3 lightPos = vec3(2, 6, 4); // vec3(sin(iTime*.5)*2., 4, 3. + cos(iTime*.5)*2.);\n    \n    // Calculate the normal\n\tvec3 normal = GetNormal(point);    \n    \n    // Direction to light\n    vec3 l = normalize(lightPos - point);\n \t\n    // Calculate Diffuse level\n    float diffuse = dot(l,normal);\n    \n    // In shadow? Raycast to the light to check\n    float lightD = RayMarch(\n        point+normal*SURF_DIST*2., l);\n    if (lightD < length(lightPos-point))\n    \tdiffuse *= 0.1;\n    \n    return clamp(diffuse, 0., 1.);\n}\n\nfloat GetLightingSun(vec3 point, bool shadow) {\n    vec3 lightDir = vec3(0.4, -1, 0);\n    \n    // Calculate the normal\n\tvec3 normal = GetNormal(point);   \n    \n    // Direction to light\n    vec3 l = normalize(-lightDir);\n \t\n    // Calculate Diffuse level\n    float diffuse = dot(l,normal);\n    \n    // In shadow? Raycast to the light to check\n    if (shadow) {\n        float lightD = RayMarch(\n            point+normal*SURF_DIST*2., l);\n        if (lightD < MAX_DIST * 0.9)\n            diffuse *= 0.1;\n    }\n    \n    return clamp(diffuse, 0., 1.);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Re-Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    \n    vec3 rayOrigin = vec3(0, 3, -13);\n    vec3 rayDirection = normalize(vec3(uv.x, uv.y, 1));\n    \n    rayOrigin = vec3(0,0,-13);\n    float rotX = mix(-3.14, 3.14, 1. - iMouse.x / iResolution.x);\n    float rotY = mix(-3.14/2., 3.14/2., 1. - iMouse.y / iResolution.y);\n    rayOrigin.yz *= Rot(rotY);\n    rayOrigin.xz *= Rot(rotX);\n    rayDirection.yz *= Rot(rotY);\n    rayDirection.xz *= Rot(rotX);\n    rayDirection = normalize(rayDirection);\n    \n    // RayMarch to find distance\n    float dist = RayMarch(rayOrigin, rayDirection);\n    vec3 hitPoint = rayOrigin + dist * rayDirection;\n    \n    vec3 normal = GetNormal(hitPoint);\n    \n    // Calculate Lighting\n    float diffuseP = GetLightingPoint(hitPoint);\n    float diffuseAmbient = AMBIENT_LIGHT * GetLightingSun(hitPoint, false);\n    vec3 col = vec3(diffuseP + diffuseAmbient);\n    \n    col += .3 * normal;\n    \n    // Output colour with full opacity\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}