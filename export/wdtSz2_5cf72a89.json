{"ver":"0.1","info":{"id":"wdtSz2","date":"1572436436","viewed":359,"name":"Galaxy Road","username":"nr4","description":"Galaxy road scene from PC-64k-intro \"Hardcyber\" by Team210, shown at Deadline 2k19.","likes":20,"published":1,"flags":32,"usePreview":0,"tags":["demoscene"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/* Hardcyber - PC-64k-Intro by Team210 at Deadline 2k19\n * Copyright (C) 2019  Alexander Kraus <nr4@z10.info>\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <https://www.gnu.org/licenses/>.\n */\n\nconst float fsaa = 144.;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 col = vec3(0.);\n    float bound = sqrt(fsaa)-1.;\n   \tfor(float i = -.5*bound; i<=.5*bound; i+=1.)\n        for(float j=-.5*bound; j<=.5*bound; j+=1.)\n        {\n     \t\tcol += texture(iChannel0, fragCoord/iResolution.xy+vec2(i,j)*mix(3.,20.,2.*abs(fragCoord.y/iResolution.y-.5))*exp(-abs(1.e-2*length(fragCoord.xy)/iResolution.y-.5))/max(bound, 1.)/iResolution.xy).xyz;\n        }\n    col /= fsaa;\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"/* Hardcyber - PC-64k-Intro by Team210 at Deadline 2k19\n * Copyright (C) 2019  Alexander Kraus <nr4@z10.info>\n * \n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n * \n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n * \n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\nconst float pi = acos(-1.);\nconst vec3 c = vec3(1.,0.,-1.);\nfloat a = 1.0;\n\n// Creative Commons Attribution-ShareAlike 4.0 International Public License\n// Created by David Hoskins.\n// See https://www.shadertoy.com/view/4djSRW\nvoid hash22(in vec2 p, out vec2 d)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    d = fract((p3.xx+p3.yz)*p3.zy);\n}\n// End of David Hoskins Code\n\nvoid rand(in vec2 x, out float n)\n{\n    x += 400.;\n    n = fract(sin(dot(sign(x)*abs(x) ,vec2(12.9898,78.233)))*43758.5453);\n}\n\nvoid lfnoise(in vec2 t, out float n)\n{\n    vec2 i = floor(t);\n    t = fract(t);\n    t = smoothstep(c.yy, c.xx, t);\n    vec2 v1, v2;\n    rand(i, v1.x);\n    rand(i+c.xy, v1.y);\n    rand(i+c.yx, v2.x);\n    rand(i+c.xx, v2.y);\n    v1 = c.zz+2.*mix(v1, v2, t.y);\n    n = mix(v1.x, v1.y, t.x);\n}\n\nvoid mfnoise(in vec2 x, in float d, in float b, in float e, out float n)\n{\n    n = 0.;\n    float a = 1., nf = 0., buf;\n    for(float f = d; f<b; f *= 2.)\n    {\n        lfnoise(f*x, buf);\n        n += a*buf;\n        a *= e;\n        nf += 1.;\n    }\n    n *= (1.-e)/(1.-pow(e, nf));\n}\n\nvoid dist(in vec2 a, in vec2 b, out float d)\n{\n    d = length(b-a);\n}\n\nvoid nearest_controlpoint(in vec2 x, out vec2 p)\n{\n    float dmin = 1.e5, \n        d;\n    vec2 dp,\n        y = floor(x);\n    \n    float i = 0.;\n    for(float i = -1.; i <= 1.; i += 1.)\n        for(float j = -1.; j <= 1.; j += 1.)\n        {\n            hash22(y+vec2(i,j), dp);\n            dp += y+vec2(i,j);\n            dist(x, dp, d);\n            if(d<dmin)\n            {\n                dmin = d;\n                p = dp;\n            }\n        }\n}\n\nvoid dvoronoi(in vec2 x, out float d, out vec2 p, out float control_distance)\n{\n    d = 1.e4;\n    vec2 y,\n        dp;\n    \n    nearest_controlpoint(x, p);\n    y = floor(p);\n    \n    control_distance = 1.e4;\n    \n    for(float i = -2.; i <= 2.; i += 1.)\n        for(float j = -2.; j <= 2.; j += 1.)\n        {\n            if(i==0. && j==0.) continue;\n            hash22(y+vec2(i,j), dp);\n            dp += y+vec2(i,j);\n            vec2 o = p - dp;\n            float l = length(o);\n            d = min(d,abs(.5*l-dot(x-dp,o)/l));\n            control_distance = min(control_distance,.5*l);\n        }\n}\n\nfloat dspiral(vec2 x, float a, float d)\n{\n    float p = atan(x.y, x.x),\n        n = floor((abs(length(x)-a*p)+d*p)/(2.*pi*a));\n    p += (n*2.+1.)*pi;\n    return -abs(length(x)-a*p)+d*p;\n}\n\nfloat sm(float d)\n{\n    return smoothstep(1.5/iResolution.y, -1.5/iResolution.y, d);\n}\n\nvoid stroke(in float d0, in float s, out float d)\n{\n    d = abs(d0)-s;\n}\n\nvoid colorize(in vec2 x, inout vec3 col)\n{\n    float v, n = 64., r, vn;\n    vec2 ind;\n    dvoronoi(n*x, v, ind, vn);\n    rand(ind, r);\n    vec2 y = x-ind/n;\n    vec3 c1;\n    rand(ind+1337., c1.x);\n    rand(ind+2337., c1.y);\n    rand(ind+3337., c1.z);\n    c1 *= vec3(1.,.7,.3);\n    c1 = .5+.5*c1;\n    c1 *= vec3(.4,.6,1.);\n    float d = length(y)-.002*r;\n    if(r > .75)\n        col = mix(col, c1, sm(d));\n    if(r>.5)\n    {\n        col = mix(col, mix(col, 2.*c1, .8), sm(d-.004*r*r));\n        col = mix(col, mix(col, 3.*c1, .4), sm(d-.01*r*r));\n    }\n    \n    dvoronoi(2.*n*x, v, ind, vn);\n    y = x-ind/n/2.;\n    rand(ind, r);\n    d = length(y)-.002*r;\n    col = mix(col, c.xxx, sm(d));\n    \n    lfnoise(x.xy-v*v*v, d);\n    col = mix(col, c.yyy, .5+.5*d);\n    \n    col = .6*col+.3*step(.8,col);\n    col *= 2.;\n    \n    v = dspiral(x, .1,.01);\n    col = mix(col, c.yyy, 1.-sm(v*6.e-3));\n    col = mix(col, 2.5*col, sm(v*2.e-3));\n}\n\nvoid dbox(in vec2 x, in vec2 b, out float d)\n{\n    vec2 da = abs(x)-b;\n    d = length(max(da,c.yy)) + min(max(da.x,da.y),0.0);\n}\n\nvoid street(in vec2 x, out vec3 col)\n{\n    x.y += .3*iTime;\n    \n    float dx;\n    lfnoise(x.y*c.xx, dx);\n    x.x += .1*dx;\n    \n    col = .4*c.xxx;\n    float da = mod(x.y, .1)-.05;\n    dbox(vec2(x.x,da), vec2(.005,.025), da);\n    col = mix(col, c.xxx, sm(da));\n    col = mix(col, c.xxx, sm(abs(abs(x.x)-.1)-.01));\n    \n    float n;\n    mfnoise(x.xy, mix(8.,1.,smoothstep(.4,1.6,abs(x.x))),200., .35,n);\n    col = mix(col, .5*col, .5+.5*n);\n    \n    col = mix(col, .6*c.xxx, abs(n)-.1);\n    \n    vec2 ind;\n    float v, vn;\n    dvoronoi(256.*x, v, ind, vn);\n    ind = x-ind/256.;\n    col = mix(col, .0*c.xxx, sm(length(ind)-.0001));\n}\n\nvoid dbox3(in vec3 x, in vec3 b, out float d)\n{\n  vec3 da = abs(x) - b;\n  d = length(max(da,0.0))\n         + min(max(da.x,max(da.y,da.z)),0.0);\n}\n\nvoid add(in vec2 sda, in vec2 sdb, out vec2 sdf)\n{\n    sdf = (sda.x<sdb.x)?sda:sdb;\n}\n\nvoid scene(in vec3 x, out vec2 sdf)\n{\n    x.y += .3*iTime;\n    \n    float dx;\n    lfnoise((x.y)*c.xx, dx);\n    x.x += .1*dx;\n    \n    sdf = c.xx;\n    float n;\n    mfnoise(x.xy, mix(8.,1.,smoothstep(.4,1.6,abs(x.x))),200., mix(.35,.45,smoothstep(.4,1.6,abs(x.x))),n);\n    float n0 = n;\n    n = .5+.5*n;\n    n *= smoothstep(.1,.3,abs(x.x))+smoothstep(.4,1.2,abs(x.x));\n    sdf.x = x.z-.1*n;\n    sdf.y = 1.;\n    \n    float d;\n    dbox3(x-c.yyx*.005*step(.1,abs(n0)-.01), vec3(.1,1.e3,.001+.01*n0), d);\n    \n    add(sdf, vec2(d, 2.), sdf);\n}\n\nvoid normal(in vec3 x, out vec3 n, in float dx)\n{\n    vec2 s, na;\n    \n    scene(x,s);\n    scene(x+dx*c.xyy, na);\n    n.x = na.x;\n    scene(x+dx*c.yxy, na);\n    n.y = na.x;\n    scene(x+dx*c.yyx, na);\n    n.z = na.x;\n    n = normalize(n-s.x);\n}\n\nvoid palette(in float scale, out vec3 col)\n{\n    const int N = 5;\n    const vec3 colors[N] = vec3[N](\n            vec3(0.27,0.13,0.26),\n            vec3(0.43,0.21,0.33),\n            vec3(0.69,0.36,0.42),\n            vec3(0.87,0.52,0.45),\n            vec3(0.99,0.68,0.53)\n    );\n\tfloat index = floor(scale*float(N)), \n        remainder = scale*float(N)-index;\n    col = mix(colors[int(index)],colors[int(index)+1], remainder);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    a = iResolution.x/iResolution.y;\n    vec2 uv = (fragCoord.xy-.5*iResolution.xy)/iResolution.y,\n        s;\n\n        vec3 col = c.yyy,\n        o = .3*c.yyx+c.yzy,\n        r = c.xyy,\n        t = c.yyy, \n        u = cross(normalize(t-o),-r),\n        dir,\n        n, \n        x;\n    int N = 250,\n        i;\n    t = uv.x * r + uv.y * u;\n    \n    dir = normalize(t-o);\n\n    vec3 c1;\n    float d = -(o.z-.18)/dir.z;\n    \n    for(i = 0; i<N; ++i)\n    {\n     \tx = o + d * dir;\n        scene(x,s);\n        if(s.x < 1.e-5)break;\n        if(x.z<0.)\n        {\n            i = N;\n            break;\n        }\n        d += s.x;\n    }\n    \n    if(i < N)\n    {\n        vec3 l = c.yyx;\n        normal(x,n, 2.e-6);\n        \n        if(s.y == 1.)\n        {\n            palette(x.z/.22, col);\n            col = .1*col \n                + .1*col*dot(l, n)\n                + .6*col*pow(abs(dot(reflect(-l,n),dir)),2.);\n        }\n        else if(s.y == 2.)\n        {\n            street(x.xy, col);\n            col = .1*col \n                + .1*col*dot(l, n)\n                + .6*col*pow(abs(dot(reflect(-l,n),dir)),2.);\n        }\n        else \n        {\n            colorize(x.xy, col);\n            col = .1*col \n                + .1*col*dot(l, n)\n                + .8*col*pow(abs(dot(reflect(-l,n),dir)),2.);\n        }\n        if(x.z>.05)\n            col = mix(col, 3.*col, smoothstep(.95,.951, n.z));\n    }\n\n    col = 12.*col*col;\n    \n    col = mix(col, c.yyy, tanh(2.e-1*d));\n    \n    vec3 c2;\n    colorize(4.*uv, c2);\n    col = mix(col, 2.*c2, smoothstep(.3,.5, uv.y));\n    \n    fragColor = vec4(clamp(col,0.,1.), 1.);\n}\n","name":"Buf A","description":"","type":"buffer"}]}