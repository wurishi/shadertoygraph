{"ver":"0.1","info":{"id":"ldjcDm","date":"1492468532","viewed":664,"name":"Collision Detection (voxels)","username":"Polygon","description":"WASD + spacebar controls.\n\nI've created voxel collision detection from scratch. It's probably un-optimized, and it won't work with a low framerate, but I'm pretty proud of it!","likes":18,"published":1,"flags":48,"usePreview":0,"tags":["3d","voxels","collisiondetection"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// THIS USES DISCRETE COLLISION DETECTION, WHICH MEANS THAT IT\n// WILL NOT WORK WITH A LOW FRAMERATE.\n//\n// Don't go fullscreen unless your computer is a beast.\n//\n// I have pretty much no knowledge of how rendering or collision detection is usually done,\n// so everything here is using algorithms that I discovered. So I'm sorry with how un-optimized\n// it is.\n//\n// Also, I didn't know that #define existed until just now, and I've been using lowercase\n// for constants. Sue me :P\n\n#define DISTANCE 128\n#define ANTI_ALIAS false\n\nconst float pi = 3.14159265;\nconst float d2r = 0.0174533;\nconst float fov = 70.0;\n\nconst vec3 loadPos = vec3(0.5, 0.5, 0.0);\nconst vec3 loadRot = vec3(2.5, 0.5, 0.0);\n\nvec3 loadVec3(vec3 place);\nvec2 loadVec2(vec3 place);\nfloat square(float num);\nvec4 render(vec2 i, vec4 o);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    \n    if (ANTI_ALIAS) {\n    //Anti-Aliasing by averaging colors of four points\n    \tfragColor += render(fragCoord + vec2(0.25, 0.25), fragColor) / 4.0;\n    \tfragColor += render(fragCoord + vec2(-0.25, 0.25), fragColor) / 4.0;\n    \tfragColor += render(fragCoord + vec2(-0.25, -0.25), fragColor) / 4.0;\n    \tfragColor += render(fragCoord + vec2(0.25, -0.25), fragColor) / 4.0;\n    } else {\n        \n        \n    \tfragColor = render(fragCoord, fragColor);\n    }\n}\n\nvec4 render(vec2 i, vec4 o) {\n    vec2 uv = i.xy / iResolution.xy;\n    vec2 uvM = iMouse.xy / iResolution.xy;\n    \n    float maxRes = max(iResolution.x, iResolution.y);\n    \n    vec2 s = i.xy / maxRes - vec2(0.5 * iResolution.x / maxRes, 0.5 * iResolution.y / maxRes);\n    \n    \n    vec3 pos = loadVec3(loadPos);\n    if (pos == vec3(0))\n        pos = vec3(0.0, 10.0, 0.0);\n    \n    vec2 rot = loadVec2(loadRot);\n    if (rot == vec2(0))\n        rot = vec2(225.0 * d2r, 0.0);\n    \n    //Direction of ray\n    vec3 direction = vec3(2.0 * s.x * tan(d2r * fov / 2.0), 2.0 * s.y * tan(d2r * fov / 2.0), 1.0);\n    direction /= length(direction);\n    \n    //Rotations of screen\n    direction = vec3(direction.x, direction.y * cos(rot.y) + direction.z * sin(rot.y), direction.z * cos(rot.y) - direction.y * sin(rot.y));\n    direction = vec3(direction.x * cos(rot.x) + direction.z * sin(rot.x), direction.y, direction.z * cos(rot.x) - direction.x * sin(rot.x));\n    \n    \n    vec3 planeMod;\n    planeMod.x = (direction.x > 0.0) ? 1.0 : 0.0;\n    planeMod.y = (direction.y > 0.0) ? 1.0 : 0.0;\n    planeMod.z = (direction.z > 0.0) ? 1.0 : 0.0;\n    \n    \n    vec3 nextPlane = floor(pos + planeMod);\n    \n    //0 = x, 1 = y, 2 = z\n    int directionHit;\n    \n    o = vec4(0.5 - 0.5 * sin(direction.y), 0.7 - 0.3 * sin(direction.y),1.0,0.0);\n    \n    vec3 startPos = pos;\n    \n    for (int j = 0; j < DISTANCE; j++) {\n        \n        vec3 distToNext;\n        distToNext = (nextPlane - pos) / direction;\n        \n        if (distToNext.x < min(distToNext.y, distToNext.z)) {\n            pos += direction * distToNext.x;\n            pos.x = nextPlane.x;\n            nextPlane.x += sign(direction.x);\n            directionHit = 0;\n        } else if (distToNext.y < distToNext.z) {\n            pos += direction * distToNext.y;\n            pos.y = nextPlane.y;\n            nextPlane.y += sign(direction.y);\n            directionHit = 1;\n        } else {\n            pos += direction * distToNext.z;\n            pos.z = nextPlane.z;\n            nextPlane.z += sign(direction.z);\n            directionHit = 2;\n        }\n            \n        if ((nextPlane - planeMod).y < 3.0 * sin((nextPlane - planeMod).x / 10.0) + 4.0 * sin((nextPlane - planeMod).z / 10.0)) {\n        if (directionHit == 0)\n   \t\t    o = vec4(0.1, 1.0, 0.0, 1.0) * 0.6;\n        \telse if (directionHit == 1)\n        \t    o = vec4(0.1, 1.0, 0.0, 1.0);\n        \telse if (directionHit == 2)\n        \t    o = vec4(0.1, 1.0, 0.0, 1.0) * 0.8;\n            \n            float dist = distance(pos, startPos);\n            o.xyz /= (dist / 25.0 + 1.0);\n            o.xyz += (vec4(0.5 - 0.5 * sin(direction.y), 0.7 - 0.3 * sin(direction.y),1.0,0.0).xyz) / (5.0 - dist / 25.0 + 1.0);\n            \n        \tbreak;\n     \t}\n    }\n    \n    \n    return o;\n}\n\n\n\n\nfloat square(float num) {\n    return num * num;\n}\n\nvec3 loadVec3(vec3 place) {\n    if (place.z == 0.0)\n    \treturn texture(iChannel0, vec2(place.x / iResolution.x, place.y / iResolution.y)).xyz;\n    else if (place.z == 1.0)\n        texture(iChannel0, vec2(place.x / iResolution.x, place.y / iResolution.y)).yzw;\n}\n\nvec2 loadVec2(vec3 place) {\n    if (place.z == 0.0)\n    \treturn texture(iChannel0, vec2(place.x / iResolution.x, place.y / iResolution.y)).xy;\n    else if (place.z == 1.0)\n        texture(iChannel0, vec2(place.x / iResolution.x, place.y / iResolution.y)).yz;\n    else if (place.z == 2.0)\n        texture(iChannel0, vec2(place.x / iResolution.x, place.y / iResolution.y)).zw;\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//This stores your position, rotation, mouse position, and velocity.\n\nconst float pi = 3.14159265;\nconst float d2r = 0.0174533;\nconst float maxSpeed = 10.0;\n\nconst float gravity = -32.0;\n\nbool getKey(int key);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float affectedByGravity = texture(iChannel0, vec2(3.5 / iResolution.x, 0.5 / iResolution.y)).w;\n    \n    vec3 vel = texture(iChannel0, vec2(3.5 / iResolution.x, 0.5 / iResolution.y)).xyz;\n    \n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 mouse = iMouse.xy / iResolution.xy;\n    vec2 prevMouse = texture(iChannel0, vec2(1.5 / iResolution.x, 0.5 / iResolution.y)).xy / iResolution.xy;\n\n    \n    vec3 pos = texture(iChannel0, vec2(0.5 / iResolution.x, 0.5 / iResolution.y)).xyz;\n    if (pos == vec3(0))\n        pos = vec3(0.0, 10.0, 0.0);\n    \n    vec2 rot = texture(iChannel0, vec2(2.5 / iResolution.x, 0.5 / iResolution.y)).xy;\n    if (rot == vec2(0))\n        rot = vec2(225.0 * d2r, 0.0);\n    \n    \n    //Screen dragging\n    if (iMouse.z > 0.0) {\n        if (texture(iChannel0, vec2(1.5 / iResolution.x, 0.5 / iResolution.y)).z <= 0.0) {\n        \tprevMouse = mouse;\n        }\n        \n        rot += vec2(2.0 * pi * (mouse.x - prevMouse.x), pi * (mouse.y - prevMouse.y));\n        \n        if (rot.y > pi / 2.0)\n            rot.y = pi / 2.0;\n        if (rot.y < -pi / 2.0)\n            rot.y = -pi / 2.0;\n    }\n    \n    vec3 nextPos = pos;\n    \n    //Keyboard controls\n    if (getKey(87) && !getKey(83)) {\n        if (getKey(68) && !getKey(65)) {\n            //W + D\n            nextPos += vec3(10.0 * iTimeDelta * (sin(rot.x) + cos(rot.x)), 0.0, 10.0 * iTimeDelta * (cos(rot.x) - sin(rot.x))) / sqrt(2.0);\n        }\n        else if (getKey(65) && !getKey(68)) {\n            //W + A\n            nextPos += vec3(10.0 * iTimeDelta * (sin(rot.x) - cos(rot.x)), 0.0, 10.0 * iTimeDelta * (cos(rot.x) + sin(rot.x))) / sqrt(2.0);\n        }\n        else {\n            //W\n        \tnextPos += vec3(10.0 * iTimeDelta * sin(rot.x), 0.0, 10.0 * iTimeDelta * cos(rot.x));\n        }\n    }\n    else if (getKey(83) && !getKey(87)) {\n        if (getKey(68) && !getKey(65)) {\n            //S + D\n            nextPos += vec3(10.0 * iTimeDelta * (-sin(rot.x) + cos(rot.x)), 0.0, 10.0 * iTimeDelta * (-cos(rot.x) - sin(rot.x))) / sqrt(2.0);\n        }\n        else if (getKey(65) && !getKey(68)) {\n            //S + A\n            nextPos += vec3(10.0 * iTimeDelta * (-sin(rot.x) - cos(rot.x)), 0.0, 10.0 * iTimeDelta * (-cos(rot.x) + sin(rot.x))) / sqrt(2.0);\n        }\n        else {\n            //S\n        \tnextPos += vec3(-10.0 * iTimeDelta * sin(rot.x), 0.0, -10.0 * iTimeDelta * cos(rot.x));\n        }\n    }\n    else if (getKey(68) && !getKey(65)) {\n         //D\n        nextPos += vec3(10.0 * iTimeDelta * cos(rot.x), 0.0, -10.0 * iTimeDelta * sin(rot.x));\n    }\n    else if (getKey(65) && !getKey(68)) {\n        //A\n        nextPos += vec3(-10.0 * iTimeDelta * cos(rot.x), 0.0, 10.0 * iTimeDelta * sin(rot.x));\n    }\n    \n    //Space bar\n    if (texture(iChannel1, vec2(32.5 / 256.0, 1.0 / 6.0)).x > 0.0) {\n        if (floor(nextPos.y) - 3.01 < floor(3.0 * sin(floor(pos.x) / 10.0) + 4.0 * sin(floor(pos.z) / 10.0)) && vel.y <= 0.0) {\n        vel.y = 10.0;\n        affectedByGravity = 1.0;\n        }\n    }\n    \n    if (affectedByGravity == 1.0) {\n    \tnextPos += vec3(0.0, vel.y * iTimeDelta - 0.5 * gravity * iTimeDelta * iTimeDelta, 0.0);\n    \t\n        vel.y += gravity * iTimeDelta;\n    }\n    \n    \n    \n    \n    \n    if (floor(pos.y) - 2.0 > floor(3.0 * sin(floor(nextPos.x) / 10.0) + 4.0 * sin(floor(pos.z) / 10.0))) {\n        pos.x = nextPos.x;\n    } else {\n        pos.x = floor(nextPos.x + 0.5) + 0.01 * (floor(nextPos.x - floor(nextPos.x) + 0.5) - 0.5);\n    }\n        \n    if (floor(pos.y) - 2.0 > floor(3.0 * sin(floor(pos.x) / 10.0) + 4.0 * sin(floor(nextPos.z) / 10.0))) {\n        pos.z = nextPos.z;\n    } else {\n        pos.z = floor(nextPos.z + 0.5) + 0.01 * (floor(nextPos.z - floor(nextPos.z) + 0.5) - 0.5);\n    }\n    if (floor(nextPos.y) - 2.0 > floor(3.0 * sin(floor(pos.x) / 10.0) + 4.0 * sin(floor(pos.z) / 10.0))) {\n        pos.y = nextPos.y;\n        if (floor(nextPos.y) - 3.0 > floor(3.0 * sin(floor(pos.x) / 10.0) + 4.0 * sin(floor(pos.z) / 10.0)))\n        \taffectedByGravity = 1.0;\n    } else {\n        vel.y = 0.0;\n        affectedByGravity = 0.0;\n        pos.y = floor(nextPos.y + 0.5);\n    }\n    \n    if (fragCoord.xy == vec2(0.5, 0.5)) {\n        fragColor.xyz = pos;\n    }\n    if (fragCoord.xy == vec2(1.5, 0.5)) {\n        fragColor = iMouse;\n    }\n    if (fragCoord.xy == vec2(2.5, 0.5)) {\n        fragColor.xy = rot;\n    }\n    if (fragCoord.xy == vec2(3.5, 0.5)) {\n        fragColor.xyz = vel;\n    }\n    if (fragCoord.xy == vec2(3.5, 0.5)) {\n        fragColor.w = affectedByGravity;\n    }\n    \n    \n    \n}\n\n\n\n\n\nbool getKey(int key) {\n    return (texture(iChannel1, vec2((float(key) + 0.5) / 256.0, 1.0 / 6.0)).x > 0.0);\n}","name":"Buf A","description":"","type":"buffer"}]}