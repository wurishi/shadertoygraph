{"ver":"0.1","info":{"id":"MdKXzy","date":"1465222647","viewed":177,"name":"Mirrorception","username":"bit2shift","description":"I was bored.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","mirror"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const int STEPS = 128;\nconst float EPSY = 0.001;\nconst int REFLECTIONS = 2;\nconst float FOV = 90.0;\n\nfloat cube(vec3 p, vec3 s)\n{\n    return length(max(abs(p) - s, 0.0));\n}\n\nfloat sphere(vec3 p)\n{\n    p += vec3(cos(iTime), 0, sin(iTime));\n    return (length(p) - 2.0);\n}\n\nfloat map(vec3 p)\n{\n    return min(\n        min(\n        \tmin(\n                cube(p - vec3(16, 0, 0), vec3(8)),\n                cube(p + vec3(16, 0, 0), vec3(8))\n            ),\n            min(\n                cube(p - vec3(0, 0, 16), vec3(8)),\n                cube(p + vec3(0, 0, 16), vec3(8))\n            )\n        ),\n        min(\n            min(\n                cube(p - vec3(0, 16, 0), vec3(8)),\n                cube(p + vec3(0, 16, 0), vec3(8))\n            ),\n            sphere(p)\n        )\n    );\n}\n\nfloat diff(vec3 p, vec3 h)\n{\n    return (map(p + h) - map(p - h)) / (2.0 * length(h));\n}\n\nvec3 norm(vec3 p)\n{\n    mat3 e = mat3(EPSY);\n    float x = diff(p, e[0]);\n    float y = diff(p, e[1]);\n    float z = diff(p, e[2]);\n    return normalize(vec3(x, y, z));\n}\n\nstruct ray\n{\n    vec3 origin;\n    vec3 direction;\n};\n\nvec3 march(ray r)\n{\n    int count = 0;\n    for(int i = 0; i < STEPS; i++)\n    {\n        float dist = map(r.origin);\n        if(dist < EPSY)\n        {\n            if(count++ == REFLECTIONS)\n                break;\n            \n            r.direction = reflect(r.direction, norm(r.origin));\n            dist += EPSY;\n        }\n        r.origin += (r.direction * dist);\n    }\n    return r.origin;\n}\n\nmat3 rotX(float angle)\n{\n    float cs = cos(radians(angle));\n    float sn = sin(radians(angle));\n    \n    vec3 c0 = vec3(1,   0,  0);\n    vec3 c1 = vec3(0,  cs, sn);\n    vec3 c2 = vec3(0, -sn, cs);\n    return mat3(c0, c1, c2);\n}\n\nmat3 rotY(float angle)\n{\n    float cs = cos(radians(angle));\n    float sn = sin(radians(angle));\n    \n    vec3 c0 = vec3(cs, 0, -sn);\n    vec3 c1 = vec3( 0, 1,   0);\n    vec3 c2 = vec3(sn, 0,  cs);\n    return mat3(c0, c1, c2);\n}\n\n//Unused, reference only\n/*float det(mat3 m)\n{\n    return dot(m[0], cross(m[1], m[2]));\n}\n\nmat3 inv(mat3 m)\n{\n    return mat3(cross(m[1], m[2]), cross(m[2], m[0]), cross(m[0], m[1])) / det(m);\n}*/\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = ((2.0 * fragCoord) - iResolution.xy) / min(iResolution.x, iResolution.y) * tan(radians(FOV) / 2.0);\n    vec3 uvw = normalize(vec3(uv, 1));\n    \n    mat3 rot = rotY(iMouse.x) * rotX(iMouse.y);\n    ray camera = ray(rot * vec3(0, 0, -6), rot * uvw);\n    \n    vec3 p = march(camera);\n    fragColor = texture(iChannel0, p);\n}\n","name":"Image","description":"","type":"image"}]}