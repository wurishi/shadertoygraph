{"ver":"0.1","info":{"id":"Wssfzr","date":"1587612214","viewed":63,"name":"Noise Shangru","username":"pandaleo","description":"hw9","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["cis561"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"mat3 rotateY(float rad)\n{\n    return mat3(vec3(cos(rad), 0, -sin(rad)),\n                vec3(0, 1, 0),\n                vec3(sin(rad), 0, cos(rad))\n               );\n}\nmat3 rotateZ(float rad)\n{\n    return mat3(vec3(cos(rad), -sin(rad), 0),\n                vec3(sin(rad), cos(rad), 0),\n                vec3(0, 0, 1)\n               );\n}\nmat3 rotateX(float rad)\n{\n    return mat3(vec3(1, 0, 0),\n        \t\tvec3(0, cos(rad), -sin(rad)),\n                vec3(0, sin(rad), cos(rad))\n               );\n}\nmat3 scale(float a, float b, float c)\n{\n    return mat3(vec3(a, 0, 0), vec3(0, b, 0), vec3(0, 0, c));\n}\nmat3 scale(float a)\n{\n    return scale(a, a, a);\n}\nfloat sdfBox(vec3 p, vec3 b)\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x, max(d.y, d.z)), 0.) + length(max(d, 0.));\n}\nfloat sdfSphere(vec3 p)\n{\n    return length(p) - 0.5;\n}\nfloat sdfPlane(vec3 p)\n{\n    return dot(p, vec3(0, 0, 1));\n}\nvec2 closer(vec2 a, vec2 b)\n{\n    return a.x < b.x ? a: b;\n}\nfloat deg2rad(float r)\n{\n\treturn r / 180. * 3.14159;\n}\nvec2 map(vec3 pos) // find closest object\n{\n    vec3 sphereWorld = vec3(0.3, 0.3, -0.4);\n    vec3 posSphereModel = inverse(rotateY(deg2rad(35.))) * (pos - sphereWorld); // position in sphere model space\n    vec2 sphereInfo = vec2(sdfSphere(posSphereModel), 1.);\n    \n    vec3 boxWorld = vec3(-0.35, -0.6, 0.3);\n    vec3 posBoxModel = inverse(rotateY(deg2rad(35.))) * (pos - boxWorld);\n    vec3 boxSize = vec3(0.2, 0.4, 0.2);\n    vec2 boxInfo = vec2(sdfBox(posBoxModel, boxSize), 2.);\n    \n    vec3 boxWorld2 = vec3(0.35, -0.8, 0.3);\n    vec3 posBoxModel2 = inverse(rotateY(deg2rad(60.))) * (pos - boxWorld2);\n    vec3 boxSize2 = vec3(0.22, 0.22, 0.22);\n    vec2 boxInfo2 = vec2(sdfBox(posBoxModel2, boxSize2), 8.);\n    \n    vec3 planeWorld1 = vec3(-1, 0, 0);\n    vec3 posPlaneModel1 = inverse(rotateY(3.14 / 2.)) * (pos - planeWorld1);\n    vec2 planeInfo1 = vec2(sdfPlane(posPlaneModel1), 3.);\n    \n    vec3 planeWorld2 = vec3(1, 0, 0);\n    vec3 posPlaneModel2 = inverse(rotateY(3. * 3.14 / 2.)) * (pos - planeWorld2);\n    vec2 planeInfo2 = vec2(sdfPlane(posPlaneModel2), 4.);\n    \n    vec3 planeWorld3 = vec3(0, 0, 0);\n    vec3 posPlaneModel3 = (pos - planeWorld3);\n    vec2 planeInfo3 = vec2(sdfPlane(posPlaneModel3), 5.);\n    \n    vec3 planeWorld4 = vec3(0, 1, 0);\n    vec3 posPlaneModel4 = inverse(rotateX(3. * 3.14 / 2.)) * (pos - planeWorld4);\n    vec2 planeInfo4 = vec2(sdfPlane(posPlaneModel4), 6.);\n    \n    vec3 planeWorld5 = vec3(0, -1, 0);\n    vec3 posPlaneModel5 = inverse(rotateX(3.14 / 2.)) * (pos - planeWorld5);\n    vec2 planeInfo5 = vec2(sdfPlane(posPlaneModel5), 7.);\n    \n    vec2 closest;\n    closest = closer(boxInfo, planeInfo1);\n    closest = closer(closest, planeInfo2);\n    closest = closer(closest, planeInfo3);\n    closest = closer(closest, planeInfo4);\n    closest = closer(closest, planeInfo5);\n    closest = closer(closest, boxInfo2);\n    closest = closer(closest, sphereInfo);\n    return closest;\n}\nvec2 calcIntersection(in vec3 ro, in vec3 rd){\n    float currentMinSdf = 0.002;\n    float t = 0.0; // distance from ro (ray origin)\n\tfloat resDistance = -1.;\n    float id = -1.;\n    for (int i = 0; i < 100; ++i){\n        if (currentMinSdf < 0.001 || t > 10.) break; // hit or exceed max distance\n\t   \tvec2 hitInfo = map(ro + rd * t); // hit object distance and id\n        currentMinSdf = hitInfo.x; // distance\n        t += currentMinSdf; // update current distance from ro\n        id = hitInfo.y;\n    }\n    if (t <= 10.) resDistance = t; // if in distance\n    else id = -1.; // no hit\n    return vec2(resDistance, id);\n}\nvec3 calcNormal(in vec3 pos){\n    \n\tvec3 dx = vec3(0.001, 0.0, 0.0);    \n\tvec3 dy = vec3(0.0, 0.001, 0.0);    \n\tvec3 dz = vec3(0.0, 0.0, 0.001);\n\tvec3 nor = vec3(\n\t    map(pos + dx).x - map(pos - dx).x,\n\t    map(pos + dy).x - map(pos - dy).x,\n\t    map(pos + dz).x - map(pos - dz).x\n    );\n\treturn normalize(nor);\n}\nvec2 random2(vec2 p) {\n    return fract(sin(vec2(dot(p, vec2(452.8, 872.8)),\n                          dot(p, vec2(782.2, 728.6)))) * 78238.7828);\n}\nvec3 random3(vec3 p) {\n    return fract(sin(vec3(dot(p, vec3(452.8, 872.8, 520.4)),\n                          dot(p, vec3(782.2, 728.6, 528.6)),\n                          dot(p, vec3(324.5, 135.5, 987.4)))) * 78238.7828);\n}\nfloat worley(vec2 p)\n{\n    float dist = 1.;\n    vec2 grid = floor(p);\n    vec2 deci = fract(p);\n    for(int x = -1; x <= 1; ++x)\n        for(int y = -1; y <= 1; ++y)\n        \tdist = min(dist, distance(random2(grid + vec2(x,y)) + vec2(x,y), deci));\n    return dist;\n}\nfloat noise2D( vec2 p ) {\n    return fract(sin(dot(p, vec2(127.1, 311.7))) *\n                 43758.5453);\n}\n\n\nfloat interpNoise2D(float x, float y) {\n    float intX = floor(x);\n    float fractX = fract(x);\n    float intY = floor(y);\n    float fractY = fract(y);\n\n    float v1 = noise2D(vec2(intX, intY));\n    float v2 = noise2D(vec2(intX + 1., intY));\n    float v3 = noise2D(vec2(intX, intY + 1.));\n    float v4 = noise2D(vec2(intX + 1., intY + 1.));\n\n    float i1 = mix(v1, v2, fractX);\n    float i2 = mix(v3, v4, fractX);\n    return mix(i1, i2, fractY);\n}\nfloat fbm(float x, float y) {\n    float total = 0.;\n    float persistence = 0.5f;\n    float octaves = 4.;\n\n    for(float i = 1.; i <= octaves; i++) {\n        float freq = pow(2., i);\n        float amp = pow(persistence, i);\n\n        total += interpNoise2D(x * freq,\n                               y * freq) * amp;\n    }\n    return total;\n}\nvec3 pow3(vec3 p, float n)\n{\n    float x = pow(p.x, n);\n    float y = pow(p.y, n);\n    float z = pow(p.z, n);\n    return vec3(x, y, z);\n}\nfloat surflet(vec3 p, vec3 gridPoint) {\n    vec3 t3 = abs(p - gridPoint);\n    vec3 t = vec3(1.f) - 6.f * pow3(t3, 5.f) + 15.f * pow3(t3, 4.f) - 10.f * pow3(t3, 3.f);\n    vec3 gradient = random3(gridPoint) * 2. - vec3(1,1,1);\n    vec3 diff = p - gridPoint;\n    float height = dot(diff, gradient);\n    return height * t.x * t.y;\n}\n\nfloat perlinNoise(vec3 uvw) {\n    float surfletSum = 0.f;\n    // Iterate over the four integer corners surrounding uv\n    for(int dx = 0; dx <= 1; ++dx) \n        for(int dy = 0; dy <= 1; ++dy) \n            for(int dz = 0; dz <= 1; ++dz)\n            \tsurfletSum += surflet(uvw, floor(uvw) + vec3(dx, dy, dz));\n    return surfletSum;\n}\nvec3 palette( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b * cos( 6.28318 * (c * t + d) );\n}\nvec3 palette1(float t)\n{\n    return palette(t, vec3(0.5, 0.5, 0.5), vec3(0.5, 0.5, 0.5), vec3(1.0, 1.0, 1.0), vec3(0.00, 0.33, 0.67));\n}\nvec3 render(vec2 res, in vec3 ro, in vec3 rd)\n{\n    float ambient = 0.05;\n    vec3 color = vec3(0);\n    float lightX = 0.5 * sin(iTime * 4.);\n    vec3 lightPos = vec3(lightX, 0.9, 0.8);\n    if (res.y > 0.) // id\n    {\n    \tvec3 pos = ro + rd * res.x;\n    \tvec3 norm = calcNormal(pos);\n    \tvec3 lightDir = normalize(lightPos - pos);\n        vec3 worleySeed = lightDir;\n        worleySeed.y /= 2.;\n        worleySeed.x += iTime / 10.;\n        float phi = atan(norm.y / norm.x);\n        float theta = atan(sqrt(norm.x * norm.x + norm.y * norm.y) / norm.z);\n        theta += iTime / 2.;\n        float normXSeed = norm.x * 5. + iTime / 2., normYSeed = norm.y * 5. + iTime / 2.;\n        vec3 posSeed = pos;\n        posSeed.x += iTime / 2.;\n        posSeed.y += iTime / 2.;\n        posSeed.z += iTime / 2.;\n        float match = max(0., dot(lightDir, norm) / pow(length(lightPos - pos), 0.3));\n        if (res.y == 1.) color = vec3(1, 1, 0.5) * fbm(normXSeed, normYSeed) * match + ambient;\n        else if (res.y == 2.) color = vec3(0.4, 0.4, 0.4) * perlinNoise(posSeed * 30.) * match + ambient;\n\t\telse if (res.y == 3.) color = vec3(1, 0, 0) * worley(vec2(worleySeed) * 20.) * match + ambient;\n        else if (res.y == 4.) color = vec3(0, 1, 0) * worley(vec2(worleySeed) * 20.) * match + ambient;\n\t\telse if (res.y == 5.) color = vec3(1, 1, 1) * worley(vec2(worleySeed) * 20.) * match + ambient;   \n        else if (res.y == 6.) color = vec3(0.5, 0.5, 0.5) * match + ambient;\n\t\telse if (res.y == 7.) color = vec3(1, 1, 1) * palette1(perlinNoise(posSeed * 2.)) * match + ambient;  \n\t\telse if (res.y == 8.) color = vec3(1, 1, 1) * perlinNoise(posSeed * 10.) * match + ambient;   \n    }\n    return color;\n}\nmat3 lookAt(in vec3 eye, in vec3 ref)\n{\n    vec3 front = normalize(ref - eye);\n    vec3 right = normalize(cross(front, vec3(0, 1, 0)));\n    vec3 up = normalize(cross(right, front));\n    return mat3(right, up, front);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (2. * fragCoord.xy - iResolution.xy) / iResolution.y;\n    vec3 eye = vec3(0, 0, 2), ref = vec3(0, 0, 0);\n    vec3 direction = normalize(lookAt(eye, ref) * vec3(p.xy, 1));\n    vec2 res = calcIntersection(eye, direction);\n    fragColor = vec4(render(res, eye, direction), 1);\n}","name":"Image","description":"","type":"image"}]}