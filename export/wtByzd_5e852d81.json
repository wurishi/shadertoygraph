{"ver":"0.1","info":{"id":"wtByzd","date":"1595091952","viewed":114,"name":"Anpanman with SGSSS","username":"ming","description":"Adding SG-SSS to my Anpanman shader\nas described in https://therealmjp.github.io/posts/sss-sg/","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["sss","sg","anpanman"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sf3Rn","filepath":"/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","previewfilepath":"/media/ap/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// toggle SG SSS on/off\n#define USE_SSS 1\n#define BASE_SCATTER_AMT vec3(0.08, 0.01, 0.01)\n#define APPLY_OCCL_TO_NORMAL 0\n\nfloat animationTime = 0.;\n\nstruct Material\n{\n\tvec3 albedo;\n\tfloat roughness;\n    float metallicness;\n    float bumpness;\n};\n\n#define MAT_BG 0.\n#define MAT_FACE 1.\n#define MAT_FACE_DARK 2.\n#define MAT_EYE MAT_FACE_DARK\n#define MAT_BROW MAT_FACE_DARK\n#define MAT_MOUTH 3.\n#define MAT_NOSE 4.\n#define MAT_DIMPLE 5.\n#define MAT_FLOOR 6.\n\nMaterial sceneMaterial(float m)\n{\n    Material ret;\n    ret.albedo = vec3(0.);\n    ret.metallicness = 1.;\n    ret.roughness = 0.;\n    ret.bumpness = 0.;\n    \n    if (m == MAT_FACE)\n    {\n        ret.albedo = vec3(253., 178., 127.) / 255.;\n        ret.metallicness = 0.;\n        ret.roughness = 2.0;\n    }\n    else if (m == MAT_FACE_DARK)\n    {\n        ret.albedo = 1.2 * vec3(91., 29., 33.) / 255.;\n        ret.metallicness = 0.2;\n        ret.roughness = 0.5;\n        \n    }\n    else if (m == MAT_MOUTH)\n    {\n        ret.albedo = vec3(227., 10., 23.) / 255.;\n        ret.metallicness = 0.0;\n        ret.roughness = 1.0;\n        \n    }\n    else if (m == MAT_NOSE)\n    {\n        ret.albedo = vec3(227., 10., 23.) / 255.;\n        ret.metallicness = 1.0;\n        ret.roughness = 2.0;\n    }\n    else if (m == MAT_DIMPLE)\n    {\n        ret.albedo = vec3(252., 65., 29.) / 255.;\n        ret.metallicness = 0.5;\n        ret.roughness = 1.0;\n    }\n    \n    return ret;\n}\n\n\nvec2 sceneHead(vec3 pos)\n{\n    vec2 dRet;\n    \n    float displacement = texture(iChannel0, pos.xy * 1.).r * .003;\n    \n    // face\n    float HEAD_RAD = 2.;\n    {\n        vec3 p = pos;\n        p = geoTranslate(p, vec3(0, HEAD_RAD, 0));\n        dRet.x = sdSphere(p, HEAD_RAD) + displacement;\n        dRet.y = MAT_FACE;\n    }\n    // nose\n    float NOSE_RAD = .45;\n    vec3 NOSE_POS = vec3(0., HEAD_RAD - .32, HEAD_RAD - .25);\n    \n    {\n        vec3 p = pos;\n        p = geoTranslate(p, NOSE_POS);\n        \n        float d = sdSphere(p, NOSE_RAD);\n        float m = MAT_NOSE;\n        dRet = opU(vec2(d, m), dRet);\n    }\n    \n    // left eye\n    vec2 EYE_RAD = vec2(.125, .03);\n    vec3 EYE_SCL = vec3(1., 1.2, 1.);\n    vec3 EYE_L_POS = vec3(-.5, HEAD_RAD + .2, HEAD_RAD - .07);\n    vec3 EYE_R_POS = vec3( .5, HEAD_RAD + .2, HEAD_RAD - .07);\n    {\n        vec3 p = pos;\n        p = geoTranslate(p, EYE_L_POS);\n        \n        vec3 p1 = p;\n        float d1 = sdEllipsoid(p1, EYE_SCL* EYE_RAD.x);\n        \n        vec3 p2 = geoCheapBendWithX(p, -1.2);\n        float d2 = sdCapsule(p2, vec3(-EYE_RAD.x, 0, -EYE_RAD.y), vec3(EYE_RAD.x, 0, EYE_RAD.y), EYE_RAD.y);\n        \n        float m = MAT_EYE;\n        float d = mix(d2, d1, animationTime);\n        dRet = opS(vec2(d, m), dRet);\n    }\n    // right eye\n    {\n        vec3 p = pos;\n        p = geoTranslate(p, EYE_R_POS);\n        \n        vec3 p1 = p;\n        float d1 = sdEllipsoid(p1, EYE_SCL* EYE_RAD.x);\n        \n        vec3 p2 = geoCheapBendWithX(p, -1.2);\n        float d2 = sdCapsule(p2, vec3(-EYE_RAD.x, 0, EYE_RAD.y), vec3(EYE_RAD.x, 0, -EYE_RAD.y), EYE_RAD.y);\n        \n        float m = MAT_EYE;\n        float d = mix(d2, d1, animationTime);\n        dRet = opS(vec2(d, m), dRet);\n    }\n    \n    float blowOpen = animationTime * .5 + .5;\n    \n    float BROW_LENGTH = .6;\n    float BROW_RAD = .05;\n    vec3 BROW_L_POS = vec3(-.5, HEAD_RAD + .5, HEAD_RAD - .13);\n    vec3 BROW_R_POS = vec3( .5, HEAD_RAD + .5, HEAD_RAD - .13);\n    \n    // left brow\n    {\n        vec3 p = pos;\n        p = geoTranslate(p, BROW_L_POS);\n        p = geoCheapBendWithX(p, -3. * (blowOpen * .5 + .5));\n        float d = sdCapsule(p, vec3(-BROW_LENGTH * .5, 0, -BROW_RAD), vec3(BROW_LENGTH * .5, 0, BROW_RAD), BROW_RAD);\n        float m = MAT_BROW;\n        dRet = opS(vec2(d, m), dRet);\n    }\n    \n    // right brow\n    {\n        vec3 p = pos;\n        p = geoTranslate(p, BROW_R_POS);\n        p = geoCheapBendWithX(p, -3. * (blowOpen * .5 + .5));\n        float d = sdCapsule(p, vec3(-BROW_LENGTH * .5, 0,  BROW_RAD), vec3(BROW_LENGTH * .5, 0, -BROW_RAD), BROW_RAD);\n        float m = MAT_BROW;\n        dRet = opS(vec2(d, m), dRet);\n    }\n    \n    \n    float DIMPLE_RAD = .45;\n    vec3 DIMPLE_L_POS = vec3(-.6, HEAD_RAD - .32, HEAD_RAD - .35);\n    vec3 DIMPLE_R_POS = vec3( .6, HEAD_RAD - .32, HEAD_RAD - .35);\n    \n    // left dimple\n    {\n        vec3 p = pos;\n        p = geoTranslate(p, DIMPLE_L_POS);\n        \n        float d = sdSphere(p, DIMPLE_RAD) + displacement;\n        float m = MAT_DIMPLE;\n        dRet = opU(vec2(d, m), dRet);\n    }\n    \n    // right dimple\n    {\n        vec3 p = pos;\n        p = geoTranslate(p, DIMPLE_R_POS) + displacement;\n        \n        float d = sdSphere(p, DIMPLE_RAD);\n        float m = MAT_DIMPLE;\n        dRet = opU(vec2(d, m), dRet);\n    }\n    \n    // mouth\n    float MOUTH_RAD = .07;\n    float MOUTH_LENGTH = 1.2;\n    vec3 MOUTH_POS = vec3(0, HEAD_RAD - 1., HEAD_RAD - 0.4);\n    \n   \tfloat mouthOpen = animationTime * .5 + .5;\n    {\n        vec3 p = pos;\n        p = geoTranslate(p, MOUTH_POS);\n        vec3 p1 = geoCheapBendWithX(p,  0.75);\n        vec3 beg = vec3(-MOUTH_LENGTH * .5, 0,  .13);\n        vec3 end = vec3( MOUTH_LENGTH * .5, 0, .13);\n        float d1 = sdCapsule(p1, beg, end, MOUTH_RAD);\n        float m1 = MAT_MOUTH;\n        \n        vec3 p2 = p + vec3(0., 0, -.2);\n        float d2 = sdEllipsoid(p2, vec3(.6, .3, .3));\n        float m2 = MAT_MOUTH;\n        \n        dRet = opS(mix(vec2(d2, m1), vec2(d1, m1), mouthOpen), dRet);\n    }\n    \n    return dRet;\n}\n\nvec2 scene(vec3 pos)\n{\n\tvec3 HEAD_POS = vec3(0, .0, 0);\n    vec3 HEAD_SCL = vec3(1., .98, .98);\n    vec2 dRet;\n    \n    {\n        vec3 p = pos;\n        p = geoTranslate(p, HEAD_POS);\n        p = geoScale(p, HEAD_SCL);\n     \n        dRet = sceneHead(p);\n    }\n    return dRet;\n}\n\n// calculate scene normal using forward differencing\nfloat edge = 0.0;\n\nvec3 sceneNormal( in vec3 p, float d )\n{\n\tvec3 eps = vec3(0.0001, 0.0, 0.0);\n    \n    float d1 = scene(p+eps.xyy).x, d2 = scene(p-eps.xyy).x;\n    float d3 = scene(p+eps.yxy).x, d4 = scene(p-eps.yxy).x;\n    float d5 = scene(p+eps.yyx).x, d6 = scene(p-eps.yyx).x;\n    \n    edge = abs(d-0.5*(d2+d1))+abs(d-0.5*(d4+d3))+abs(d-0.5*(d6+d5));//edge finder\n\tedge = min(1.,pow(edge,.5)*15.);\n    \n\treturn vec3(\n\t\td1 - d2,\n\t\td3 - d4,\n\t\td5 - d6\n\t);\n}\n\n\nvec3 sceneNormalCurve(in vec3 p, out float curv)\n{\n    vec2 e = vec2(-1., 1.)*0.01;   \n    float t1 = scene(p + e.yxx).x, t2 = scene(p + e.xxy).x;\n    float t3 = scene(p + e.xyx).x, t4 = scene(p + e.yyy).x;\n\n    curv = .25/e.y*(t1 + t2 + t3 + t4 - 4.0*scene(p).x);\n    return normalize(e.yxx*t1 + e.xxy*t2 + e.xyx*t3 + e.yyy*t4);\n}\n\n\n// lighting function https://www.shadertoy.com/view/4sX3R2\nvec3 sceneDiffuseLighting(vec3 nor, float occl, vec3 lig, float scattering)\n{\n    vec3 n = nor;\n    \n\t#if 1 == APPLY_OCCL_TO_NORMAL\n    n *= occl;\n\t#endif\n    \n    vec3 dif = vec3(clamp( dot( n, lig ), 0.0, 1.0 ));\n    \n    #if 1 == USE_SSS\n    vec3 ScatterAmt = BASE_SCATTER_AMT * scattering;\n    \n    ScatterAmt = 1.0 / max(ScatterAmt, 0.0001);\n    SG rKernel = MakeNormSG(lig, ScatterAmt.x);\n    SG gKernel = MakeNormSG(lig, ScatterAmt.y);\n    SG bKernel = MakeNormSG(lig, ScatterAmt.z);\n    \n    dif = vec3(SGIrradianceFitted(rKernel, n).x,\n               SGIrradianceFitted(gKernel, n).x,\n               SGIrradianceFitted(bKernel, n).x);\n    #endif\n    \n    \n\t#if 0 == APPLY_OCCL_TO_NORMAL\n    dif *= occl;\n\t#endif\n    \n    vec3 x = max(vec3(0.0), dif - 0.004);\n    dif = (x * (6.2 * x + 0.5)) / (x*(6.2*x+1.7)+0.06);\n    \n    return dif;\n    \n}\n\nfloat hash( float n )//->0:1\n{\n    return fract(sin(n)*3538.5453);\n}\n\nfloat sceneOcclusion( in vec3 p, in vec3 n, float maxDist, float falloff )\n{\n\tconst int nbIte = 6;\n    \n    float ao = 0.0;\n\t\n    for (int i=0; i<nbIte; i++)\n    {\n       float l = hash(float(i)) * maxDist;\n        vec3 rd = n * l;\n        \n        ao += (l - scene(p + rd).x) / pow(1.+l, falloff);\n    }\n\t\n    return clamp( 1.-ao/float(nbIte), 0., 1.);\n}\n\nfloat sceneSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n    // bounding volume\n    float tp = (0.8-ro.y)/rd.y; if( tp>0.0 ) tmax = min( tmax, tp );\n\n    float res = 1.0;\n    float t = mint;\n    for( int i=0; i<16; i++ )\n    {\n\t\tfloat h = scene( ro + rd*t ).x;\n        float s = clamp(8.0*h/t,0.0,1.0);\n        res = min( res, s*s*(3.0-2.0*s) );\n        t += clamp( h, 0.02, 0.10 );\n        if( res<0.005 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\n\nstruct Ray\n{\n\tvec3 org;\n\tvec3 dir;\n};\n\nconst int RAY_MARCH_STEPS = 32;\n\n\nbool raymarch(Ray ray, out vec3 hitPos, out vec2 hitInfo)\n{\n\tconst float hitThreshold = 0.001;\n\n\tbool hit = false;\n\thitPos = ray.org;\n    \n\tvec3 pos = ray.org;\n\n\tfor (int i = 0; i < RAY_MARCH_STEPS; i++)\n\t{\n\t\tvec2 s = scene(pos);\n\n\t\tif (s.x < hitThreshold)\n\t\t{\n            hit = true;\n\t\t\thitPos = pos;\n\t\t\thitInfo = s;\n\t\t\tbreak;\n\t\t}\n\t\tpos += s.x * ray.dir;\n\t}\n    \n\treturn hit;\n}\n\n\nvec4 background(Ray ray)\n{\n    vec4 c1 = vec4(.8, .9, 1., 1.);\n    vec4 c2 = vec4(1., 1., 1., 1.);\n    float t = ray.dir.y;\n    t = smoothstep(0., .8, t);\n    return mix(c1, c2, t);\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 ndcXY = fragCoord.xy / iResolution.xy;\n    ndcXY = -1.0 + 2.0 * ndcXY;\n\tndcXY.x *= iResolution.x / iResolution.y;\n    \n    float t = (.5 + sin(iTime * .5) / 32.) * PI;\n    animationTime = (sin(PI * .25 + iTime * 2.) * .5 + .5);\n\t\n    \n    // construct the ray in world space\n\tRay ray;\n    ray.org = vec3(cos(t), 0, sin(t)) * 6.0 + vec3(0., 2., 0.);\n\tvec3 ta = vec3(0., ray.org.y + .1, 0.);\n\t\n\t// camera-to-world transformation\n    mat3 ca = setCamera(ray.org, ta, 0.0);\n    \n    // ray direction\n\tray.dir = ca * normalize(vec3(ndcXY.xy, 2.0));\n\t\n\tvec3 sceneWsPos;\n    vec2 sceneInfo;\n    \n\tif (raymarch(ray, sceneWsPos, sceneInfo))\n\t{\n\t\t// our ray hit the scene, shade it with a point light\n        Material mtl = sceneMaterial(sceneInfo.y);\n        \n        vec3 lig = normalize( vec3(-0.5, 0.6, 0.6) );\n        vec3 sceneWsNrm = normalize(sceneNormal(sceneWsPos, sceneInfo.x));\n        \n        \n        float sceneOccl = sceneOcclusion(sceneWsPos, sceneWsNrm, 8.0, 0.25);\n        sceneOccl *= sceneOccl;\n        \n        float sceneShw = sceneSoftshadow(sceneWsPos, lig, 0.25, 0.5);\n        \n        vec3 col = mtl.albedo * \n            (sceneDiffuseLighting(sceneWsNrm, sceneOccl * sceneShw, lig, mtl.roughness) +\n             sceneDiffuseLighting(sceneWsNrm, sceneOccl, -lig, mtl.roughness) * 0.2\n            );\n        \n        // gamma correction\n        col = pow( col, vec3(0.4545) );\n        \n        fragColor = vec4(col, 1.);\n\t}\n\telse\n\t{\n\t\tfragColor = background(ray);\n\t}\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"float sdPlane(vec3 p, vec4 n)\n{\n\t// n must be normalized\n\treturn dot(p, n.xyz) + n.w;\n}\n\nfloat sdSphere(vec3 p, float s)\n{\n\treturn length(p)-s;\n}\n\nfloat sdEllipsoid(in vec3 p, in vec3 r)\n{\n    return (length(p/r) - 1.0) * min(min(r.x,r.y),r.z);\n}\n\nfloat udRoundBox(vec3 p, vec3 b, float r)\n{\n  return length(max(abs(p)-b,0.0))-r;\n}\n\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r)\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\nvec2 opU(vec2 d1, vec2 d2)\n{\n\treturn vec2(\n        min(d1.x, d2.x), \n        d1.x < d2.x ? d1.y : d2.y\n    );\n}\n\nvec2 opS(vec2 d1, vec2 d2)\n{\n    return vec2(\n        max(-d1.x, d2.x),\n        -d1.x > d2.x ? d1.y : d2.y\n    );\n}\n\nvec2 opI(vec2 d1, vec2 d2)\n{\n    return vec2(\n        max(d1.x, d2.x),\n        d1.x > d2.x ? d1.y : d2.y\n    );\n}\n\nfloat smin_polynomial(float a, float b, float k)\n{\n    float h = clamp(0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix(b, a, h ) - k*h*(1.0-h);\n}\n\nvec2 opBlend(vec2 d1, vec2 d2)\n{\n    return vec2(\n        smin_polynomial(d1.x, d2.x, 16.), \n        d1.x < d2.x ? d1.y : d2.y\n    );\n}\n\n\n\nfloat pow2(float v)\n{\n    return v * v;\n}\n\n\nfloat pow4(float v)\n{\n    return v * v * v * v;\n}\n\nvec3 pow4(vec3 v)\n{\n    return v * v * v * v;\n}\n\n\nvec3 geoTranslate(vec3 pos, vec3 t)\n{\n\treturn pos - t;\n}\n\nvec3 geoScale(vec3 pos, vec3 s)\n{\n    return pos * (1. / s);\n}\n\n\nvec3 geoRotateX(vec3 p, float a)\n{\n    float sa = sin(a);\n    float ca = cos(a);\n    return vec3(p.x, ca*p.y - sa*p.z, sa*p.y + ca*p.z);\n}\n\nvec3 geoRotateY(vec3 p, float a)\n{\n    float sa = sin(a);\n    float ca = cos(a);\n    return vec3(ca*p.x + sa*p.z, p.y, -sa*p.x + ca*p.z);\n}\n                \nvec3 geoCheapBendWithX(vec3 p, float amount)\n{\n    float c = cos(amount * p.x);\n    float s = sin(amount * p.x);\n    mat2  m = mat2(c,-s, s, c);\n    vec3  q = vec3(m * p.xy, p.z);\n    return q;\n}\n\nvec3 geoCheapBendWithY(vec3 p, float amount)\n{\n    float c = cos(amount * p.y);\n    float s = sin(amount * p.y);\n    mat2  m = mat2(c,-s, s, c);\n    vec3  q = vec3(m * p.xy, p.z);\n    return q;\n}\n\n#define PI 3.14159265359\n\nstruct SG\n{\n    vec3 Amplitude;\n    vec3 Axis;\n    float Sharpness;\n};\n    \nvec3 EvaluateSG(in SG sg, in vec3 dir)\n{\n    float cosAngle = dot(dir, sg.Axis);\n    return sg.Amplitude * exp(sg.Sharpness * (cosAngle - 1.0f));\n}\n\nSG SGProduct(in SG x, in SG y)\n{\n    vec3 um = (x.Sharpness * x.Axis + y.Sharpness * y.Axis) / (x.Sharpness + y.Sharpness);\n    float umLength = length(um);\n    float lm = x.Sharpness + y.Sharpness;\n \n    SG res;\n    res.Axis = um * (1.0f / umLength);\n    res.Sharpness = lm * umLength;\n    res.Amplitude = x.Amplitude * y.Amplitude * exp(lm * (umLength - 1.0f));\n \n    return res;\n}\n\nvec3 SGIntegral(in SG sg)\n{\n    float expTerm = 1.0f - exp(-2.0f * sg.Sharpness);\n    return 2.0 * PI * (sg.Amplitude / sg.Sharpness) * expTerm;\n}\n \nvec3 ApproximateSGIntegral(in SG sg)\n{\n    return 2.0 * PI * (sg.Amplitude / sg.Sharpness);\n}\n\nvec3 SGIrradianceFitted(in SG lightingLobe, in vec3 normal)\n{\n    float muDotN = dot(lightingLobe.Axis, normal);\n    float lambda = lightingLobe.Sharpness;\n \n    float c0 = 0.36f;\n    float c1 = 0.25f / c0;\n \n    float eml = exp(-lambda);\n    float em2l = eml * eml;\n    float rl = 1.0 / lambda;\n \n    float scale = 1.0f + 2.0f * em2l - rl;\n    float bias  = (eml - em2l) * rl - em2l;\n \n    float x  = sqrt(1.0f - scale);\n    float x0 = c0 * muDotN;\n    float x1 = c1 * x;\n \n    float n = x0 + x1;\n \n    float y = (abs(x0) <= x1) ? (n * n) / x : clamp(muDotN, 0.0, 1.0);\n    \n    float result = scale * y + bias; \n    return vec3(result);\n}\n\nvec3 SGIrradiancePunctual(in SG lightingLobe, in vec3 normal)\n{\n    float cosineTerm = max(0.0, dot(lightingLobe.Axis, normal));\n    return cosineTerm * 2.0f * PI * (lightingLobe.Amplitude) / lightingLobe.Sharpness;\n}\n\n\nSG MakeNormSG(vec3 LightDir, float Sharpness)\n{\n    // normalized SG\n    SG distribution;\n    distribution.Axis = LightDir;\n    distribution.Sharpness = Sharpness; // (1 / ScatterAmt.element)\n    distribution.Amplitude = vec3(distribution.Sharpness / ((2.0 * PI) * (1.0 - exp(-2.0 * distribution.Sharpness))));\n    \n    return distribution;\n}","name":"Common","description":"","type":"common"}]}