{"ver":"0.1","info":{"id":"XdKBWz","date":"1528342686","viewed":288,"name":"SDF planetoid","username":"flimshaw","description":"ain't the kind of place to raise your kids","likes":11,"published":1,"flags":0,"usePreview":0,"tags":["sdfplanet"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define STEPS 32\n#ifndef PI\n#define PI 3.141592653589793\n#endif\n\nconst float EPSILON = .01;\n\nfloat sineInOut(float t) {\n  return -0.5 * (cos(PI * t) - 1.0);\n}\n\nfloat scene(vec3 p) {\n    float s;\n    //vec4 no = texture(iChannel0, p.yx*.3+iTime*vec2(0.05, -.1));\n    s = sdSphere(p, 1.);\n\treturn s;\n}\n\n\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        scene(vec3(p.x + EPSILON, p.y, p.z)) - scene(vec3(p.x - EPSILON, p.y, p.z)),\n        scene(vec3(p.x, p.y + EPSILON, p.z)) - scene(vec3(p.x, p.y - EPSILON, p.z)),\n        scene(vec3(p.x, p.y, p.z  + EPSILON)) - scene(vec3(p.x, p.y, p.z - EPSILON))\n        ));\n}\n\n\nfloat trace(vec3 o, vec3 r) {\n    float d = 0.;\n    vec3 p;\n    for(int i = 0; i < STEPS; i++) {\n        p = o + r * d;\n        d += scene(p * .5);\n    }\n    return d;\n}\n\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    uv = uv*2.-1.;\n    \n    vec3 r = rayDirection(60., iResolution.xy*2., fragCoord);\n\n    vec3 o = vec3(0., 0., 8.);\n    \n    // distance of the object from the camera\n    float d = trace(o, r);\n    \n    vec3 p = o + r * d;\n    \n    vec3 n = estimateNormal(p);\n    \n\n    // Output to screen\n    fragColor = vec4(vec3(n.b)-(n.r+.5),1.0) * vec4(.8, .8, 1., 1.);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// Sphere\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\n// Box - unsigned - exact\nfloat udBox( vec3 p, vec3 b )\n{\n  return length(max(abs(p)-b,0.0));\n}\n\n// Round Box - unsigned - exact\nfloat udRoundBox( vec3 p, vec3 b, float r )\n{\n  return length(max(abs(p)-b,0.0))-r;\n}\n\n\n// exponential smooth min (k = 32);\nfloat smin( float a, float b, float k )\n{\n    float res = exp( -k*a ) + exp( -k*b );\n    return -log( res )/k;\n}\n\n// polynomial smooth min (k = 0.1);\nfloat smin2( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\n// power smooth min (k = 8);\nfloat smin3( float a, float b, float k )\n{\n    a = pow( a, k ); b = pow( b, k );\n    return pow( (a*b)/(a+b), 1.0/k );\n}\n\n// Box - signed - exact\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\n// Torus - signed - exact\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n// Cylinder - signed - exact\nfloat sdCylinder( vec3 p, vec3 c )\n{\n  return length(p.xz-c.xy)-c.z;\n}\n\n// Cone - signed - exact\nfloat sdCone( vec3 p, vec2 c )\n{\n    // c must be normalized\n    float q = length(p.xy);\n    return dot(c,vec2(q,p.z));\n}\n\n// Plane - signed - exact\nfloat sdPlane( vec3 p, vec4 n )\n{\n  // n must be normalized\n  return dot(p,n.xyz) + n.w;\n}\n\n// Hexagonal Prism - signed - exact\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    return max(q.z-h.y,max((q.x*0.866025+q.y*0.5),q.y)-h.x);\n}\n\n// Triangular Prism - signed - exact\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n}\n\n// Capsule / Line - signed - exact\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\n// Capped cylinder - signed - exact\nfloat sdCappedCylinder( vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n/**\n * Return a transformation matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction.\n */\nmat4 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n\tvec3 f = normalize(center - eye);\n\tvec3 s = normalize(cross(f, up));\n\tvec3 u = cross(s, f);\n\treturn mat4(\n\t\tvec4(s, 0.0),\n\t\tvec4(u, 0.0),\n\t\tvec4(-f, 0.0),\n\t\tvec4(0.0, 0.0, 0.0, 1)\n\t);\n}\n\nvec3 opScale( vec3 p, float s )\n{\n    return (p/s);\n}\n\nmat4 rotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n\n    return mat4(\n        vec4(c, 0, s, 0),\n        vec4(0, 1, 0, 0),\n        vec4(-s, 0, c, 0),\n        vec4(0, 0, 0, 1)\n    );\n}\n\nvec3 opTwist( vec3 p )\n{\n    float c = cos(20.0*p.y);\n    float s = sin(20.0*p.y);\n    mat2  m = mat2(c,-s,s,c);\n    vec3  q = vec3(m*p.xz,p.y);\n    return q;\n}\n\n// Capped Cone - signed - bound\nfloat sdCappedCone( in vec3 p, in vec3 c )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    vec2 v = vec2( c.z*c.y/c.x, -c.z );\n    vec2 w = v - q;\n    vec2 vv = vec2( dot(v,v), v.x*v.x );\n    vec2 qv = vec2( dot(v,w), v.x*w.x );\n    vec2 d = max(qv,0.0)*qv/vv;\n    return sqrt( dot(w,w) - max(d.x,d.y) ) * sign(max(q.y*v.x-q.x*v.y,w.y));\n}\n\n// Ellipsoid - signed - bound\nfloat sdEllipsoid( in vec3 p, in vec3 r )\n{\n    return (length( p/r ) - 1.0) * min(min(r.x,r.y),r.z);\n}\n\nmat4 rotationMatrix(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n                0.0,                                0.0,                                0.0,                                1.0);\n}\n\n\n\n//Union\nfloat opU( float d1, float d2 )\n{\n    return min(d1,d2);\n}\n\n//Substraction\nfloat opS( float d1, float d2 )\n{\n    return max(-d1,d2);\n}\n\n//Intersection\nfloat opI( float d1, float d2 )\n{\n    return max(d1,d2);\n}\n\nconst float coeiff = 0.25;\nconst vec3 totalSkyLight = vec3(0.3, 0.5, 1.0);\n\nvec3 mie(float dist, vec3 sunL){\n    return max(exp(-pow(dist, 0.25)) * sunL - 0.4, 0.0);\n}\n\nvec3 getSky(vec2 uv){\n\t\n\tvec2 sunPos = vec2(0.5, .5);\n    \n    float sunDistance = distance(uv, clamp(sunPos, -1.0, 1.0));\n\t\n\tfloat scatterMult = clamp(sunDistance, 0.0, 1.0);\n\tfloat sun = clamp(1.0 - smoothstep(0.01, 0.011, scatterMult), 0.0, 1.0);\n\t\n\tfloat dist = uv.y;\n\tdist = (coeiff * mix(scatterMult, 1.0, dist)) / dist;\n    \n    vec3 mieScatter = mie(sunDistance, vec3(1.0));\n\t\n\tvec3 color = dist * totalSkyLight;\n    \n    color = max(color, 0.0);\n    \n\tcolor = max(mix(pow(color, 1.0 - color),\n\tcolor / (2.0 * color + 0.5 - color),\n\tclamp(sunPos.y * 2.0, 0.0, 1.0)),0.0)\n\t+ sun + mieScatter;\n\t\n\tcolor *=  (pow(1.0 - scatterMult, 10.0) * 10.0) + 1.0;\n\t\n\tfloat underscatter = distance(sunPos.y * 0.5 + 0.5, 1.0);\n\t\n\tcolor = mix(color, vec3(0.0), clamp(underscatter, 0.0, 1.0));\n\t\n\treturn color;\t\n}","name":"Common","description":"","type":"common"}]}