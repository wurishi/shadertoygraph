{"ver":"0.1","info":{"id":"fstfDX","date":"1657339479","viewed":70,"name":"2D-Perlin","username":"nelsonkuang","description":"Play With 2D Perlin Noice","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["noise","perlin"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Mainly from: https://blog.csdn.net/candycat1992/article/details/50346469\nvec2 hash22(vec2 p) {\n  p = vec2(dot(p, vec2(127.1, 311.7)), dot(p, vec2(269.5, 183.3)));\n\n  return -1.0 + 2.0 * fract(sin(p) * 43758.5453123);\n}\n\nfloat perlinNoise(vec2 p) {\n  vec2 pi = floor(p); // 晶格的顶点\n  vec2 pf = fract(p); // 输入的一个点\n\n  // vec2 w = pf * pf * (3.0 - 2.0 * pf); // 缓和曲线是 s(t)=3t^2 − 2t^3\n  vec2 w = (6.0 * pf * pf - 15.0 * pf + 10.0) * pf * pf * pf; // 缓和曲线是 s(t)=6t^5−15t^4+10t^3 = (6 * t * t - 15 * t + 10) * t * t * t\n\n  // 找到和它相邻的那些晶格顶点\n  // “伪随机”的梯度向量\n  vec2 grad01 = hash22(pi + vec2(0.0, 0.0));\n  vec2 grad02 = hash22(pi + vec2(1.0, 0.0));\n  vec2 grad03 = hash22(pi + vec2(0.0, 1.0));\n  vec2 grad04 = hash22(pi + vec2(1.0, 1.0));\n\n  // 计算该点到各个晶格顶点的距离向量\n  vec2 d01 = pf - vec2(0.0, 0.0);\n  vec2 d02 = pf - vec2(1.0, 0.0);\n  vec2 d03 = pf - vec2(0.0, 1.0);\n  vec2 d04 = pf - vec2(1.0, 1.0);\n\n  // 距离向量分别与顶点上的梯度向量做点乘，得到2n2n个点乘结果\n  float res01 = dot(grad01, d01);\n  float res02 = dot(grad02, d02);\n  float res03 = dot(grad03, d03);\n  float res04 = dot(grad04, d04);\n\n  // 使用缓和曲线（ease curves）来计算它们的权重和\n  float res = mix(mix(res01, res02, w.x), mix(res03, res04, w.x), w.y);\n\n  return res;\n}\n\n// 单独一个 Perlin 噪声虽然也有一定用处，但是效果往往很无趣\nfloat noiseItself(vec2 p) {\n  return perlinNoise(p * 8.0);\n}\n\n// 使用了 fbm 进行叠加来形成一个分形噪声。公式如下：\n// noise(p)+1/2noise(2p)+1/4noise(4p)+...\n// 叠加了5层，并把初始化采样距离设置为4，这都是可以自定义的。这种噪声可以用来模拟石头、山脉这类物体。\nfloat noiseSum(vec2 p) {\n  float f = 0.0;\n  p = p * 4.0;\n  f += 1.0000 * perlinNoise(p);\n  p = 2.0 * p;\n  f += 0.5000 * perlinNoise(p);\n  p = 2.0 * p;\n  f += 0.2500 * perlinNoise(p);\n  p = 2.0 * p;\n  f += 0.1250 * perlinNoise(p);\n  p = 2.0 * p;\n  f += 0.0625 * perlinNoise(p);\n  p = 2.0 * p;\n\n  return f;\n}\n\n// 对噪声返回值进行了取绝对值操作\n// 由于进行了绝对值操作，因此会在0值变化处出现不连续性，形成一些尖锐的效果。通过合适的颜色叠加，我们可以用这种噪声来模拟火焰、云朵这些物体。Perlin把这个公式称为turbulence（湍流？），因为它看起来挺像的。\nfloat noiseSumAbs(vec2 p) {\n  float f = 0.0;\n  p = p * 7.0;\n  f += 1.0000 * abs(perlinNoise(p));\n  p = 2.0 * p;\n  f += 0.5000 * abs(perlinNoise(p));\n  p = 2.0 * p;\n  f += 0.2500 * abs(perlinNoise(p));\n  p = 2.0 * p;\n  f += 0.1250 * abs(perlinNoise(p));\n  p = 2.0 * p;\n  f += 0.0625 * abs(perlinNoise(p));\n  p = 2.0 * p;\n\n  return f;\n}\n\n// 在之前turbulence公式的基础上使用了一个关于表面x分量的正弦函数\n// sin(x+|noise(p)|+1/2|noise(2p)|+1/4|noise(4p)|+...)\n// 我们可以通过改变x分量前面的系数来控制条纹的疏密\nfloat noiseSumAbsSin(vec2 p) {\n  float f = 0.0;\n  p = p * 7.;\n  f += 1.0000 * abs(perlinNoise(p));\n  p = 2.0 * p;\n  f += 0.5000 * abs(perlinNoise(p));\n  p = 2.0 * p;\n  f += 0.2500 * abs(perlinNoise(p));\n  p = 2.0 * p;\n  f += 0.1250 * abs(perlinNoise(p));\n  p = 2.0 * p;\n  f += 0.0625 * abs(perlinNoise(p));\n  p = 2.0 * p;\n  f = sin(f + p.x / 32.0);\n\n  return f;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 uv = fragCoord / iResolution.xy; // <0, 1>\n  // uv -= 0.5; // <-0.5,0.5>\n  uv.x *= iResolution.x / iResolution.y; // fix aspect ratio\n  uv.x += iTime * 0.1;\n\n  // float res = noiseItself(uv);\n\n  float res = noiseSum(uv);\n\n  // float res = noiseSumAbs(uv);\n\n  // float res = noiseSumAbsSin(uv);\n\n  fragColor = vec4(vec3(res), 1.0);\n}","name":"Image","description":"","type":"image"}]}