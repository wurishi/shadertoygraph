{"ver":"0.1","info":{"id":"3dtXDj","date":"1573407712","viewed":132,"name":"WaveTail","username":"FreddyDoll","description":"Toying around with wake waves","likes":5,"published":1,"flags":32,"usePreview":0,"tags":["waves","simulation","boat"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Raymarching from: https://www.shadertoy.com/view/4dt3zn\n#define PI 3.141592\n\n#define FAR 30.\n\nfloat heightmap(vec2 pos)\n{\n\tvec4 fragColor = texture(iChannel0,pos);\n    return fragColor.r*0.1; //Position\n    //fragColor.g *= 5.0; //Velocity\n    //fragColor.b *= 10.0; //Acceleration\n}\n\nfloat speedmap(vec2 pos)\n{\n\tvec4 fragColor = texture(iChannel0,pos);\n    return fragColor.g*0.1; //Position\n}\n\nfloat map(vec3 p)\n{\n    return p.z-heightmap(p.xy);\n}\n\n// Standard raymarching routine.\nfloat trace(vec3 ro, vec3 rd)\n{\n    float t = 0., d;\n    for (int i = 0; i < 96; i++)\n    {\n        d = map(ro + rd*t);\n        // Using the hacky \"abs,\" trick, for more accuracy. \n        if(abs(d)<.001 || t>FAR) break;        \n        t += d*.2;  // Using more accuracy, in the first pass.\n    }\n    return t;\n}\n\n// Tetrahedral normal, to save a couple of \"map\" calls. Courtesy of IQ.\nvec3 getNormal( in vec3 p )\n{\n    // Note the slightly increased sampling distance, to alleviate\n    // artifacts due to hit point inaccuracies.\n    vec2 e = vec2(.0025, -.0025); \n    return normalize(\n        e.xyy * map(p + e.xyy) + \n        e.yyx * map(p + e.yyx) + \n        e.yxy * map(p + e.yxy) + \n        e.xxx * map(p + e.xxx));\n}\n\nvec3 getObjectColor(vec3 p){\n    \n    vec3 col = vec3(.5,.2,.7);\n    \n    col += vec3(speedmap(p.xy))*1000.;\n  \n    return col;\n}\n\n// Using the hit point, unit direction ray, etc, to color the \n// scene. Diffuse, specular, falloff, etc. It's all pretty \n// standard stuff.\nvec3 doColor(in vec3 sp, in vec3 rd, in vec3 sn, in vec3 lp, float t){\n    \n    vec3 ld = lp-sp; // Light direction vector.\n    float lDist = max(length(ld), .001); // Light to surface distance.\n    ld /= lDist; // Normalizing the light vector.\n    \n    // Attenuating the light, based on distance.\n    float atten = 1. / (1. + lDist*.2 + lDist*lDist*.1);\n    \n    // Standard diffuse term.\n    float diff = max(dot(sn, ld), 0.);\n    // Standard specualr term.\n    float spec = pow(max( dot( reflect(-ld, sn), -rd ), 0.), 8.);\n    spec/=abs(speedmap(sp.xy))*10000.;\n    \n    // Coloring the object. You could set it to a single color, to\n    // make things simpler, if you wanted.\n    vec3 objCol = getObjectColor(sp);\n    \n    // Combining the above terms to produce the final scene color.\n    vec3 sceneCol = (objCol*(diff + .15) + vec3(.6, .3, .2)*spec*2.) * atten;\n    \n    \n    // Fog factor -- based on the distance from the camera.\n    float fogF = smoothstep(0., .95, t/FAR);\n    //\n    // Applying the background fog. Just black, in this case, but you could\n    // render sky, etc, as well.\n    sceneCol = mix(sceneCol, vec3(0), fogF); \n\n    \n    // Return the color. Performed once every pass... of which there are\n    // only two, in this particular instance.\n    return sceneCol;\n    \n}\n\nmat3 rotationMatrix(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat3(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n    // Screen coordinates.\n\tvec2 uv = (fragCoord.xy - iResolution.xy*.5) / iResolution.y;\n    \n    // Unit direction ray.\n    vec3 rd = normalize(vec3(uv, 2.));\n    \n    rd = rotationMatrix(vec3(1.,0.,0.),-PI/2.0-0.5)*rd;\n    rd = rotationMatrix(vec3(0.,0.,1.),PI/2.+0.2)*rd;\n\n    \n    // Ray origin. Doubling as the surface position, in this particular example.\n    // I hope that doesn't confuse anyone.\n    vec3 ro = vec3(1.2,.35, .4);\n    \n    // Light position. Set in the vicinity the ray origin.\n    vec3 lp = ro + vec3(-2.5, 1., 0);\n    \n    \n    // FIRST PASS.\n    \n    float t = trace(ro, rd);\n    \n   \n    \n    // Advancing the ray origin, \"ro,\" to the new hit point.\n    ro += rd*t;\n    \n    // Retrieving the normal at the hit point.\n    vec3 sn = getNormal(ro);\n    \n    // Retrieving the color at the hit point, which is now \"ro.\" I agree, reusing \n    // the ray origin to describe the surface hit point is kind of confusing. The reason \n    // we do it is because the reflective ray will begin from the hit point in the \n    // direction of the reflected ray. Thus the new ray origin will be the hit point. \n    // See \"traceRef\" below.\n    vec3 sceneColor = doColor(ro, rd, sn, lp, t);\n        \n            \n    \n   \n\n    // Clamping the scene color, performing some rough gamma correction (the \"sqrt\" bit), then \n    // presenting it to the screen.\n\tfragColor = vec4(sqrt(clamp(sceneColor, 0., 1.)), 1);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define PI 3.141592\n#define SQRT2 1.4142135\n\n//Field properties\nconst float stiffness = 0.1;\nconst float damping = 0.99;\n\n//for all emitter types\nconst float frequency = 100.;\nconst float amplitude = .1;\n\nconst float verSpeed = 2.;\n\nfloat extractPosition(vec2 uv)\n{\n    return texture(iChannel0,uv).x;\n}\n\n\nfloat Emitter(vec2 uv)\n{\n    uv.x*=4.;\n    vec2 pos = vec2(sin(iTime*1.5)*0.1+2., (iResolution.y - 100.)/iResolution.y);\n    \n    return length(pos-uv);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    vec2 uv = fragCoord/iResolution.xy;\n    uv.y +=  verSpeed/iResolution.y;\n\tfloat stepx = 1.0/iResolution.x;\n\tfloat stepy = 1.0/iResolution.y;\n    float aspect = iResolution.x/iResolution.y;\n    \n    vec3 val = texture(iChannel0,uv).rgb;\n    \n    //neigbour difference\n    float diff = (0.5-val.x)*0.02;\n    diff+=extractPosition(uv+vec2(stepx,0.))-val.x;\n    diff+=extractPosition(uv+vec2(0,stepy))-val.x;\n    diff+=extractPosition(uv+vec2(-stepx,0.))-val.x;\n    diff+=extractPosition(uv+vec2(0,-stepy))-val.x;\n    \n    diff+=(extractPosition(uv+vec2(stepx,stepy))-val.x) / SQRT2;\n    diff+=(extractPosition(uv+vec2(-stepx,stepy))-val.x) / SQRT2;\n    diff+=(extractPosition(uv+vec2(stepx,-stepy))-val.x) / SQRT2;\n    diff+=(extractPosition(uv+vec2(-stepx,-stepy))-val.x) / SQRT2;\n    \n    //integration\n    val.z = diff*stiffness;\n    val.y += val.z;\n    val.y *= damping;\n    val.x += val.y;\n    fragColor = vec4(val,1);\n    \n    //Mouse\n    vec2 p = fragCoord.xy / iResolution.xx;\n    vec4 m = iMouse / iResolution.xxxx;\n    \n    \n    float emmitterR = .005;\n    \n    if(Emitter(uv)<20./iResolution.y)\n        fragColor = vec4(0.5,amplitude*sin(iTime*frequency),0.0,1.0);\n        //fragColor = vec4(0.0,.3,0.0,1.0);\n        \n    if(m.z>0.0 && length( m.xy- p ) < emmitterR)\n        fragColor = vec4(0.5,amplitude*sin(iTime*frequency),0.0,1.0);\n    \n    if(iResolution.y-fragCoord.y <2.)\n        fragColor = vec4(0.5,0.02*sin(iTime*2.),0.0,1.0);\n    \n    if(iTime < 0.2)\n        fragColor = vec4(0.5,0.,0.,1.);\n        \n}","name":"Buffer A","description":"","type":"buffer"}]}