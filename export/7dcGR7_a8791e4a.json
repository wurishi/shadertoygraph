{"ver":"0.1","info":{"id":"7dcGR7","date":"1629375342","viewed":89,"name":"shadow caster","username":"Aalex3984","description":"a shadow caster","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["shadow","light","shadowcaster"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define LIGHT_LENGTH 3\n#define EDGES_LENGTH 4\n\n// the power of the distance :\n// 1 : less dazzling \n// 2 : realitic\n// 3 and more : too dazzling\n#define DIST_POW 1.\n\n// math\n#define PI 3.141592\n#define kInvPi 1. / PI\n\n// the light structure, containe every light data\nstruct Light{\n    vec2 pos;\n    vec4 color;\n    float radius;\n    float intensity;\n};\n\nLight lights[LIGHT_LENGTH] = Light[LIGHT_LENGTH](\n    Light(vec2(1, 0.5), vec4(1., 0, 0, 1), 0.04, 1.),\n    Light(vec2(1, 0.9), vec4(1., 0.5, 0, 0.5), 0.3, 0.5),\n    Light(vec2(0.2, 1), vec4(0, 1, 1, 1), 0.3, 0.5)\n);\n\n// edges\n\nstruct Edge{\n    vec2 start;\n    vec2 end;\n};\n\nEdge edges[EDGES_LENGTH] = Edge[EDGES_LENGTH](\n    Edge(vec2(0.5, 0.5), vec2(0.5, 0.7)),\n    Edge(vec2(0.5, 0.7), vec2(0.7, 0.7)),\n    Edge(vec2(0.7, 0.7), vec2(0.7, 0.5)),\n    Edge(vec2(0.7, 0.5), vec2(0.5, 0.5))\n);\n\n\nbool ccw(vec2 A, vec2 B, vec2 C){\n    return (C.y-A.y) * (B.x-A.x) > (B.y-A.y) * (C.x-A.x);\n}\n\nbool intersect(vec2 A, vec2 B, vec2 C, vec2 D){\n    return (ccw(A,C,D) != ccw(B,C,D) && ccw(A,B,C) != ccw(A,B,D));\n}\n\nbool intersect_edge(vec2 start, vec2 end, Edge edge){\n    return intersect(start, end, edge.start, edge.end);\n}\n\nbool interect_egdes(vec2 start, vec2 end){\n    for (int i=0; i<edges.length(); i++){\n        if (intersect_edge(start, end, edges[i])){\n            return false;\n        }\n    }\n    return true;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord){\n\n    \n    lights[0].pos = iMouse.xy / iResolution.xy;\n    lights[0].pos.x *= (iResolution.x / iResolution.y);\n    \n    lights[1].pos.x = cos(iTime) / 2. + 1.;\n    lights[2].pos.y = sin(iTime) / 3. + 0.5;\n\n    \n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv.x *= (iResolution.x / iResolution.y);\n    \n    vec4 rgb = vec4(0);\n    \n    for (int i=0; i<lights.length(); i++){\n        float d = pow(length(uv - lights[i].pos), DIST_POW);\n        if (interect_egdes(lights[i].pos, uv)){\n            rgb += lights[i].color * lights[i].radius / d * lights[i].intensity / 3.;\n        }\n        \n    }\n    \n    fragColor = rgb;\n}","name":"Image","description":"","type":"image"}]}