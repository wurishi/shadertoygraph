{"ver":"0.1","info":{"id":"7tBcRG","date":"1649853508","viewed":137,"name":"Pacman of the apocalypse","username":"tomansion","description":"wakawakawakawakawakawakawakawakawakawakawakawakawakawakawakawakawakawakawakawakawakawakawakawakawakawakawakawakawakawakawakawakawakawakawakawakawakawakawakawakawakawakawakawakawakawakawakawakawakawakawakawakawakawakawakawakawakawakawakawakawakawakawakawak","likes":5,"published":1,"flags":48,"usePreview":0,"tags":["game","retro","pacman","arcade"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec2 uv;\nvec4 col;\n#define PACMAN_RADIUS 80.\n#define PACMAN_COLOR vec4(1.0, 1.0, 0.0, 1.0)\n#define TOP_TUNNEL_TOP_LEFT_Y 360.\n#define TUNNEL_BORDER_SIZE 20.\n\n\n/// GUI\nconst vec4 bitShL = vec4(16777216.0, 65536.0, 256.0, 1.0);\nconst vec4 bitShR = vec4(1.0/16777216.0, 1.0/65536.0, 1.0/256.0, 1.0);\nfloat unpackFloat( in vec4 val ){\n    float m = 1.0;\n    if(val.r>=256.){ val.r-=256.; m=-1.0; } \n    return dot(val, bitShL)/1000.*m;\n}\nvec4 readPixel(vec2 address) { return texture(iChannel0, (floor(address)+0.5) / iChannelResolution[0].xy); }\nfloat readFloat(vec2 address){ return unpackFloat(readPixel(address));}\n\n// SHAPES\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat dot2( in vec3 v ) { return dot(v,v); }\nfloat ndot( in vec2 a, in vec2 b ) { return a.x*b.x - a.y*b.y; }\n\n\nfloat floattingValue(float frequency, float amplitude) {\n    return (sin(iTime * frequency) + 1.) * amplitude;\n}\nbool timeGate(float frequency, float gateTol) {\n    return sin(iTime * frequency) > gateTol;\n}\n\nbool sdCircle(vec2 pos, float radius )\n{\n  return distance(uv, pos) <= radius;\n}\n\nbool udTriangle(vec2 _a, vec2 _b, vec2 _c)\n{\n  vec3 a = vec3(_a, 0);\n  vec3 b = vec3(_b, 0);\n  vec3 c = vec3(_c, 0);\n  vec3 p = vec3(uv, 0);\n\n  vec3 ba = b - a; vec3 pa = p - a;\n  vec3 cb = c - b; vec3 pb = p - b;\n  vec3 ac = a - c; vec3 pc = p - c;\n  vec3 nor = cross( ba, ac );\n\n  return sqrt(\n    (sign(dot(cross(ba,nor),pa)) +\n     sign(dot(cross(cb,nor),pb)) +\n     sign(dot(cross(ac,nor),pc))<2.0)\n     ?\n     min( min(\n     dot2(ba*clamp(dot(ba,pa)/dot2(ba),0.0,1.0)-pa),\n     dot2(cb*clamp(dot(cb,pb)/dot2(cb),0.0,1.0)-pb) ),\n     dot2(ac*clamp(dot(ac,pc)/dot2(ac),0.0,1.0)-pc) )\n     :\n     dot(nor,pa)*dot(nor,pa)/dot2(nor) ) <= 0.0;\n}\n\nbool sdEllipse(vec2 pos, in vec2 ab )\n{\n    vec2 p = abs(uv - pos);\n    if( p.x > p.y ) {p=p.yx;ab=ab.yx;}\n    float l = ab.y*ab.y - ab.x*ab.x;\n    float m = ab.x*p.x/l;      float m2 = m*m;\n    float n = ab.y*p.y/l;      float n2 = n*n;\n    float c = (m2+n2-1.0)/3.0; float c3 = c*c*c;\n    float q = c3 + m2*n2*2.0;\n    float d = c3 + m2*n2;\n    float g = m + m*n2;\n    float co;\n    if( d<0.0 )\n    {\n        float h = acos(q/c3)/3.0;\n        float s = cos(h);\n        float t = sin(h)*sqrt(3.0);\n        float rx = sqrt( -c*(s + t + 2.0) + m2 );\n        float ry = sqrt( -c*(s - t + 2.0) + m2 );\n        co = (ry+sign(l)*rx+abs(g)/(rx*ry)- m)/2.0;\n    }\n    else\n    {\n        float h = 2.0*m*n*sqrt( d );\n        float s = sign(q+h)*pow(abs(q+h), 1.0/3.0);\n        float u = sign(q-h)*pow(abs(q-h), 1.0/3.0);\n        float rx = -s - u - c*4.0 + 2.0*m2;\n        float ry = (s - u)*sqrt(3.0);\n        float rm = sqrt( rx*rx + ry*ry );\n        co = (ry/sqrt(rm-rx)+2.0*g/rm-m)/2.0;\n    }\n    vec2 r = ab * vec2(co, sqrt(1.0-co*co));\n    return length(r-p) * sign(p.y-r.y) <= 0.;\n}\n\nbool sdRect(vec2 pos, vec2 size) {\n    return (\n        uv.x >= pos.x &&\n        uv.x <= pos.x + size.x &&\n        uv.y >= pos.y &&\n        uv.y <= pos.y + size.y);\n}\n\nbool intersectOp(bool a, bool b) {\n    return a && b;\n}\n\nbool unionOp(bool a, bool b) {\n    return a || b;\n}\n\nbool substractOp(bool a, bool b) {\n    return a && ! b;\n}\n\n// =================\n\nvoid drawPacMan(vec2 pos) {\n    float mouthHeight = abs(sin(iTime * readFloat(vec2(5.0, 0.0))) * 100.);\n\n    if (substractOp(\n        sdCircle(pos, PACMAN_RADIUS),\n        udTriangle(pos, pos + vec2(150,mouthHeight), pos + vec2(150,-mouthHeight)))\n    ) col = PACMAN_COLOR;\n}\n\nvoid drawGhost(vec2 pos, vec4 color) {\n    float ghostRadius = PACMAN_RADIUS * 0.6;\n\n    // Waves\n    if (uv.y + ghostRadius + 20. > sin((uv.x / 15.) - color.x * 10. + iTime * 4.0) * 10. + pos.y &&\n        uv.x > pos.x - ghostRadius &&\n        uv.x < pos.x + ghostRadius &&\n        uv.y < pos.y) col = color;\n\n    // Body\n    if (sdCircle(pos, ghostRadius)) col = color;\n\n    // Eyes\n    pos.y += floattingValue(5., 3.0);\n\n    float eyesSize = 15.;\n    bool scared = timeGate(1., 0.95 - color.x);\n    if (scared) eyesSize += 5. + floattingValue(5., 2.0);\n\n    if (unionOp(\n        sdEllipse(pos + vec2(30,0), vec2(10, eyesSize)),\n        sdEllipse(pos + vec2(0,0), vec2(10, eyesSize))\n    )) col = vec4(1.);\n\n    // Pupils\n    pos.y -= floattingValue(5., 1.5) - 1.0;\n    if (scared) pos.x -= 10.;\n\n    if (unionOp(\n        sdEllipse(pos + vec2(35,0), vec2(5, 6)),\n        sdEllipse(pos + vec2(5,0), vec2(5, 6))\n    )) col = vec4(0., 0., 0., 1.);\n}\n\nvoid drawBackground() {\n    vec4 wallColor = vec4(87., 88, 255., 255.) / 255.;\n\n    if (unionOp(\n        sdRect(vec2(0., TOP_TUNNEL_TOP_LEFT_Y), vec2(iResolution.x, TUNNEL_BORDER_SIZE)),\n        sdRect(vec2(0., 80.), vec2(iResolution.x, TUNNEL_BORDER_SIZE))\n    )) col = wallColor;\n}\n\nvoid drawBalls(vec2 pacman) {\n    float freq = 200.;\n    float offset = 100.;\n    float radius = 25.;\n    float pointApparitionDist = 300.;\n    vec2 ballCenter = vec2(floor(uv.x / freq) * freq + offset, pacman.y);\n    float pointDistance = pacman.x - ballCenter.x;\n\n    vec4 noColor = vec4(0.);\n\n    \n    if (sdCircle(ballCenter, radius)) {\n        if (ballCenter.x + radius > pacman.x ) {\n            col = PACMAN_COLOR;\n        } else if (pointDistance > pointApparitionDist)  {\n            col = PACMAN_COLOR;\n        }\n    }\n\n}\n\n// ======\n\nvec2 getPacmanPos(float offsetPx) {\n    float time = iTime * 300. * readFloat(vec2(6.0, 0.0)) - offsetPx;\n    return vec2(mod(700.0 + time, float(iResolution.x + 2.0 * PACMAN_RADIUS)) - PACMAN_RADIUS, 225);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord )\n{\n    uv = fragCoord;\n\n    vec2 pacmanPos = getPacmanPos(0.);\n    drawBalls(pacmanPos);\n    drawPacMan(pacmanPos);\n    drawGhost(getPacmanPos(300.) + vec2(0., 12. * floattingValue(5., 1.)), vec4(.0,1.0,1.0,1.0));\n    drawGhost(getPacmanPos(500.) + vec2(0., -12. * floattingValue(5., 1.)), vec4(1.0,0.0,0.0,1.0));\n    drawBackground();\n\n    fragColor = col;\n\n\n    vec4 gui = texture(iChannel0,fragCoord.xy/iResolution.xy);\n    if (gui.a > 0.0) fragColor = gui;\n    vec4 text = texture(iChannel1,fragCoord.xy/iResolution.xy);\n    if (text.a > 0.) fragColor = text;\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//////////////////////////////\n//   Read Write             //\n//////////////////////////////\nconst vec4 bitShL = vec4(16777216.0, 65536.0, 256.0, 1.0);\nconst vec4 bitShR = vec4(1.0/16777216.0, 1.0/65536.0, 1.0/256.0, 1.0);\n// only positive in range 0-1\nvec4 packNormal( const in float value ){\n    vec4 res = fract( value*bitShL );\n\tres.yzw -= res.xyz/256.0;\n\treturn res;\n}\nfloat unpackNormal( const in vec4 value ){ return dot( value, bitShR );}\n\n// only positive int\nvec4 packInt(int val){\n    vec4 res = floor(float(val)*bitShR);\n    res.yzw -= res.xyz*256.0;\n    return res;\n}\nfloat unpackInt( const in vec4 value ){ return dot(value, bitShL);}\n// +-2147483 with 3 digit float precigion\nvec4 packFloat( const in float val ){\n   bool negative = sign(val)==-1.;\n   vec4 res = floor(abs(val)*1000.0* bitShR);\n   res.gba -= res.rgb*256.0;\n   if(negative) res.r+=256.;\n   return res;\n}\nfloat unpackFloat( in vec4 val ){\n    float m = 1.0;\n    if(val.r>=256.){ val.r-=256.; m=-1.0; }   \n    return dot(val, bitShL)/1000.*m;\n}\n\n\nbool isCell(in vec2 p, in vec2 a) { return floor(p) == a;}\nvoid savePixel(vec4 val, vec2 address, inout vec4 col, vec2 px){ if(isCell(px, address)) col=val;}\nvec4 readPixel(vec2 address) { return texture(iChannel0, (floor(address)+0.5) / iChannelResolution[0].xy); }\nvoid saveInt(int val, vec2 address, inout vec4 col, vec2 p){if(isCell(p, address)) col= packInt(val);}\nfloat readInt(vec2 address){ return unpackInt(readPixel(address));}\nvoid saveIntVec2(vec2 val, float id, inout vec4 col, vec2 p){\n    saveInt(int(val.x), vec2(id,0.0), col, p);        \n    saveInt(int(val.y), vec2(id,1.0), col, p);\n}\nvoid saveFloat(float val, vec2 address, inout vec4 col, vec2 px){ if(isCell(px, address)) col= packFloat(val);}\nfloat readFloat(vec2 address){ return unpackFloat(readPixel(address));}\n\n////// Constants ////////////////////////////////////////////////////////////////////////\nconst float PI    = 3.14159265358979323846;\nconst float SQRT2 = 1.41421356237309504880;\n\n////// 2D Ttransformations ///////////////////////////////////////////////////////////////\nvec2 translate(vec2 p, vec2 t){\treturn p - t;}\nvec2 scale(vec2 p, float s){ return p * mat2(s, 0, 0, s);}\nvec2 rotate(vec2 p, float a){return p * mat2(cos(a), -sin(a), sin(a), cos(a));}\nvec2 rotateCCW(vec2 p, float a){\treturn p * mat2(cos(a), sin(a), -sin(a), cos(a));}\n\n////// 2D Matrix Ttransformations /////////////////////////////////////////////////////////\nmat3 rotate(float r){float c = cos(r), s = sin(r); return mat3(c,-s,0,  s,c,0,  0,0,1);}\nmat3 scale(float s){ return mat3(s,0,0, 0,s,0, 0,0,1);}\nmat3 translate(vec2 p) { return mat3(1,0,p.x, 0,1,p.y, 0,0,1);}\nmat3 skew(float r) { return mat3(1,tan(r),0, 0,1,0, 0,0,1);}\nmat3 skewVert(float r) { return mat3(1,0,0, tan(r),1,0, 0,0,1);}\nmat3 inverse2x3(mat3 m){\n      float a=m[0][0], b=m[0][1], c=m[0][2], d=m[1][0], e=m[1][1], f=m[1][2], t=a*e-b*d;\n      return mat3(e/t, -b/t, (f*b-c*e)/t, -d/t, a/t, (-f*a+c*d)/t, 0, 0, 1);\n}\nvec2 transform(vec2 p, mat3 m){ return (vec3(p,1)*m).xy;}\n////// Distance field functions //////////////////////////////////////////////////////////\n\nfloat dfBox(vec2 p, vec2 size) {vec2 d = abs(p)-size; return max(d.x, d.y);}\nfloat dfBox(vec2 p, vec4 b) {vec2 d = abs(-b.xy-b.zw*.5 + p) - b.zw*.5; return max(d.x, d.y);}\nfloat dfRoundedBox(vec2 p, vec2 size, float radius){size -= vec2(radius);vec2 d = abs(p) - size; return min(max(d.x, d.y), 0.0) + length(max(d, 0.0)) - radius;}\nfloat dfBoxRounded(vec2 p, vec4 b, float radius){ vec2 size = b.zw*.5-vec2(radius); vec2 d = abs(-b.xy-b.zw*.5 + p)-size;  return min(max(d.x, d.y), 0.0) + length(max(d, 0.0)) - radius;}\n\nfloat dfCircle(vec2 p, float radius){\t\n    return length(p) - radius;\n}\nfloat dfLine(in vec2 p, in vec2 a, in vec2 b){\n    vec2 pa = p - a, ba = b - a;\n\tfloat h = clamp(dot(pa,ba) / dot(ba,ba), 0., 1.);\t\n\treturn length(pa - ba * h);\n}\n\n////// UI /////////////////////////////////////////////////////////////////////////////////\nfloat extract_bit(float n, float b){ return mod(floor(n/exp2(floor(b))),2.0);}\nfloat extract_decimal(float n, float index){ return mod(n/pow(10.0, index),10.0);}\nfloat drawDigit(int n, vec2 p){ p=floor(p);\n    int i = n==0?0x69996:n==1?0x62227:n==2?0xE168F:n==3?0xE161E:n==4?0x99711:n==5?0xF8E1E:\n    n==6?0x68E96:n==7?0xF1244:n==8?0x69696:n==9?0x69716:n==10?0x00700:n==11?0x00004:0xFFFFF;\n    return extract_bit(float(i), mod(p.y,5.0) * 4.0 + 3.0-p.x);\n}\nfloat drawFloat(in float val, in float fractPrecision, in vec2 p, vec2 location, int zoom){\n    p-=location; p/= float(zoom);\n    float n = floor(p.x / 5.0); //current char index \n    p.x -= n*5.; //move origin\n    if(p.y<0.||p.y>5.||n<0.||n>8.||p.x<0.||p.x>4.) return 0.; //out of digit bounds\n    if(sign(val)<0.0){if(n==0.) return drawDigit(10, p);n-=1.; val=abs(val);}  //draw minus sign \n    float intCount = floor(val)==0.0 ? 1.0 : floor(log(val)/2.302585) +1.;//calculate int part length\n    float count = intCount + fractPrecision; //totla number of digits to print \n    if(fractPrecision > 0.){val *= pow(10.,fractPrecision);}  // move decimal point \n    if(intCount <= n){if(intCount == n) return drawDigit(11, p); n-=1.0;}  //draw dot  \n    if(count <= n)  return 0.0; //no need to draw more\n    return drawDigit(int(extract_decimal(val, count-n-1.)), p); //draw digit   \n}\nfloat drawVec2(in vec2 val, in float fractPrecision, in vec2 p, vec2 location, int zoom){\n    float r =drawFloat(val.y,fractPrecision, p, location, zoom);\n    r+=drawFloat(val.x,fractPrecision, p, location+vec2(0,6*zoom), zoom);\n    return r;\n}\n\n//////////////////////////////////////////////////////////////////////////////\n\nconst vec2 activeUIAddress = vec2(0,4);\n\n\nfloat slider(in float id, in vec4 conf, in vec2 loc, in vec2 sp, inout vec4 col, inout float ui){ \n    float val = readFloat(vec2(id,0));//read saved value \n    vec4 data = readPixel(vec2(id,3));\n    float activeUIID = readInt(activeUIAddress);    \n    float slui = dfBoxRounded(floor(sp), vec4(loc,124,20), 5.0);\n    slui = max(-slui-2.0, slui );    \n    if(data.x==0.){ //set default value\n        val = conf.x; data.x=.05;\n    \tsaveFloat(val, vec2(id,0), col, sp);\n    }if(iMouse.z <= 0.){//on mouse up\n        data.g = 0.;//stop drag this point\n        savePixel(vec4(0), activeUIAddress, col, sp);//unlock other controlls\n    }else if(dfBox(iMouse.xy, vec4(loc, 120, 20))<2. && activeUIID==0.0){//on press\n        data.g = .05;//start drag this point\n        saveInt(int(id),activeUIAddress, col, sp);//lock other controlls\n    }else if(data.g>0.0 && activeUIID==id){//on mouse drag\n        float distanceFromLeftEdege = clamp(iMouse.x, loc.x, loc.x+120.0)-loc.x;\n        val = mix(conf.y, conf.z, distanceFromLeftEdege/120.0);\n        val = floor(val/conf.w) * conf.w;        \n    \tsaveFloat(val, vec2(id,0), col, sp);\n    }\n        \n    slui = min(slui, dfBoxRounded(floor(sp), vec4(loc+vec2(2,2),120.0*(val-conf.y)/(conf.z-conf.y),16), 3.0) );\n    \n    ui = min(ui, -drawFloat(val, 2.0, sp, loc+vec2(128,8), 1)); //val   \n    //ui = min(ui, -drawFloat(conf.y, 2.0, sp, loc+vec2(0,24), 1)); //from   \n    //ui = min(ui, -drawFloat(conf.z, 2.0, sp, loc+vec2(80,24), 1));  //to   \n    //ui = min(ui, -drawFloat(conf.w, 2.0, sp, loc+vec2(50,-10), 1)); //step    \n    ui = min(ui, slui);     \n    savePixel(data, vec2(id,3), col, sp);     \n    return val;    \n}\n\n\n////// Masks for drawing /////////////////////////////////////////////////////////////////\n\nfloat hardFill(float d){return step(0.0, -d);}\nfloat fill(in float d, in float softness, in float offset){\n    return clamp((offset +softness*.5 - d)/softness, 0.0, 1.0);\n}\nfloat simpleFill(float d){return clamp(-d, 0.0, 1.0);}\nfloat sharpFill(in float d){return clamp(.5-d, 0.0, 1.0);} //same as fill(d, 1.0, 0.0)\nfloat stroke(in float d, in float softness, in float offset, in float width){ \n   d = abs(d-offset);\n   return clamp((width/2.0 +softness*.5 - d)/softness, 0.0, 1.0);\n}\n\n//////////////////////////////////////////////////////////////////////////////////////////////\n//////////////////////////////////////////////////////////////////////////////////////////////\n\nvoid mainScene(inout vec4 col, in vec2 sp ){\n    //ui elements\n    float ui = 0.;\n    //                      id     default min max step    coords \n    float softness = slider(5.0, vec4(10, 5, 20, .25), vec2(125, 20), sp, col, ui);\n    float offset = slider(6.0, vec4(1., 0., 3., .25), vec2(125, 40), sp, col, ui);\n    // float width = slider(7.0, vec4(2.5, 0, 10, .25), vec2(20, 160), sp, col, ui);\n    \n    ///////////////// output /////////////////\n\n    col = mix(col, vec4(1., 0.6, 0.1, 1.0), simpleFill(ui));\n    \n}\n\n\nvoid mainImage( out vec4 o, in vec2 p ){ \n    o = p.y <= 5.? texture(iChannel0,p.xy/iResolution.xy) : vec4(0);  //data for next frame\n    mainScene(o, p);   \n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[{"id":"XsXGR8","channel":0}],"code":"#define DOWN_SCALE 1.0\n\n#define MAX_INT_DIGITS 4\n\n#define CHAR_SIZE vec2(8, 12)\n#define CHAR_SPACING vec2(8, 12)\n\n#define STRWIDTH(c) (c * CHAR_SPACING.x)\n#define STRHEIGHT(c) (c * CHAR_SPACING.y)\n\n#define NORMAL 0\n#define INVERT 1\n#define UNDERLINE 2\n\nint TEXT_MODE = NORMAL;\n\n/*\n--------\n-###----\n##-##---\n##-##---\n-###----\n#####-#-\n##-####-\n##--##--\n##-###--\n-###-##-\n--------\n--------\n\n00000000\n01110000\n11011000\n11011000\n01110000\n11111010\n11011110\n11001100\n11011100\n01110110\n00000000\n00000000\n\n//Broken up into 4 8x3 (24 bit) chunks for each component of the vec4.\n//Hexadecimal is being used to reduce clutter in the code but decimal still works.\n\n00000000\n01110000 -> 00000000 01110000 11011000 -> 0x0070D8\n11011000\n\n11011000\n01110000 -> 11011000 01110000 11111010 -> 0xD870FA\n11111010\n\n11011110\n11001100 -> 11011110 11001100 11011100 -> 0xDECCDC\n11011100\n\n01110110\n00000000 -> 01110110 00000000 00000000 -> 0x760000\n00000000\n\nvec4(0x0070D8,0xD870FA,0xDECCDC,0x760000)\n*/\n\n//Automatically generated from the 8x12 font sheet here:\n//http://www.massmind.org/techref/datafile/charset/extractor/charset_extractor.htm\n\nvec4 ch_spc = vec4(0x000000,0x000000,0x000000,0x000000);\nvec4 ch_exc = vec4(0x003078,0x787830,0x300030,0x300000);\nvec4 ch_quo = vec4(0x006666,0x662400,0x000000,0x000000);\nvec4 ch_hsh = vec4(0x006C6C,0xFE6C6C,0x6CFE6C,0x6C0000);\nvec4 ch_dol = vec4(0x30307C,0xC0C078,0x0C0CF8,0x303000);\nvec4 ch_pct = vec4(0x000000,0xC4CC18,0x3060CC,0x8C0000);\nvec4 ch_amp = vec4(0x0070D8,0xD870FA,0xDECCDC,0x760000);\nvec4 ch_apo = vec4(0x003030,0x306000,0x000000,0x000000);\nvec4 ch_lbr = vec4(0x000C18,0x306060,0x603018,0x0C0000);\nvec4 ch_rbr = vec4(0x006030,0x180C0C,0x0C1830,0x600000);\nvec4 ch_ast = vec4(0x000000,0x663CFF,0x3C6600,0x000000);\nvec4 ch_crs = vec4(0x000000,0x18187E,0x181800,0x000000);\nvec4 ch_com = vec4(0x000000,0x000000,0x000038,0x386000);\nvec4 ch_dsh = vec4(0x000000,0x0000FE,0x000000,0x000000);\nvec4 ch_per = vec4(0x000000,0x000000,0x000038,0x380000);\nvec4 ch_lsl = vec4(0x000002,0x060C18,0x3060C0,0x800000);\nvec4 ch_0 = vec4(0x007CC6,0xD6D6D6,0xD6D6C6,0x7C0000);\nvec4 ch_1 = vec4(0x001030,0xF03030,0x303030,0xFC0000);\nvec4 ch_2 = vec4(0x0078CC,0xCC0C18,0x3060CC,0xFC0000);\nvec4 ch_3 = vec4(0x0078CC,0x0C0C38,0x0C0CCC,0x780000);\nvec4 ch_4 = vec4(0x000C1C,0x3C6CCC,0xFE0C0C,0x1E0000);\nvec4 ch_5 = vec4(0x00FCC0,0xC0C0F8,0x0C0CCC,0x780000);\nvec4 ch_6 = vec4(0x003860,0xC0C0F8,0xCCCCCC,0x780000);\nvec4 ch_7 = vec4(0x00FEC6,0xC6060C,0x183030,0x300000);\nvec4 ch_8 = vec4(0x0078CC,0xCCEC78,0xDCCCCC,0x780000);\nvec4 ch_9 = vec4(0x0078CC,0xCCCC7C,0x181830,0x700000);\nvec4 ch_col = vec4(0x000000,0x383800,0x003838,0x000000);\nvec4 ch_scl = vec4(0x000000,0x383800,0x003838,0x183000);\nvec4 ch_les = vec4(0x000C18,0x3060C0,0x603018,0x0C0000);\nvec4 ch_equ = vec4(0x000000,0x007E00,0x7E0000,0x000000);\nvec4 ch_grt = vec4(0x006030,0x180C06,0x0C1830,0x600000);\nvec4 ch_que = vec4(0x0078CC,0x0C1830,0x300030,0x300000);\nvec4 ch_ats = vec4(0x007CC6,0xC6DEDE,0xDEC0C0,0x7C0000);\nvec4 ch_A = vec4(0x003078,0xCCCCCC,0xFCCCCC,0xCC0000);\nvec4 ch_B = vec4(0x00FC66,0x66667C,0x666666,0xFC0000);\nvec4 ch_C = vec4(0x003C66,0xC6C0C0,0xC0C666,0x3C0000);\nvec4 ch_D = vec4(0x00F86C,0x666666,0x66666C,0xF80000);\nvec4 ch_E = vec4(0x00FE62,0x60647C,0x646062,0xFE0000);\nvec4 ch_F = vec4(0x00FE66,0x62647C,0x646060,0xF00000);\nvec4 ch_G = vec4(0x003C66,0xC6C0C0,0xCEC666,0x3E0000);\nvec4 ch_H = vec4(0x00CCCC,0xCCCCFC,0xCCCCCC,0xCC0000);\nvec4 ch_I = vec4(0x007830,0x303030,0x303030,0x780000);\nvec4 ch_J = vec4(0x001E0C,0x0C0C0C,0xCCCCCC,0x780000);\nvec4 ch_K = vec4(0x00E666,0x6C6C78,0x6C6C66,0xE60000);\nvec4 ch_L = vec4(0x00F060,0x606060,0x626666,0xFE0000);\nvec4 ch_M = vec4(0x00C6EE,0xFEFED6,0xC6C6C6,0xC60000);\nvec4 ch_N = vec4(0x00C6C6,0xE6F6FE,0xDECEC6,0xC60000);\nvec4 ch_O = vec4(0x00386C,0xC6C6C6,0xC6C66C,0x380000);\nvec4 ch_P = vec4(0x00FC66,0x66667C,0x606060,0xF00000);\nvec4 ch_Q = vec4(0x00386C,0xC6C6C6,0xCEDE7C,0x0C1E00);\nvec4 ch_R = vec4(0x00FC66,0x66667C,0x6C6666,0xE60000);\nvec4 ch_S = vec4(0x0078CC,0xCCC070,0x18CCCC,0x780000);\nvec4 ch_T = vec4(0x00FCB4,0x303030,0x303030,0x780000);\nvec4 ch_U = vec4(0x00CCCC,0xCCCCCC,0xCCCCCC,0x780000);\nvec4 ch_V = vec4(0x00CCCC,0xCCCCCC,0xCCCC78,0x300000);\nvec4 ch_W = vec4(0x00C6C6,0xC6C6D6,0xD66C6C,0x6C0000);\nvec4 ch_X = vec4(0x00CCCC,0xCC7830,0x78CCCC,0xCC0000);\nvec4 ch_Y = vec4(0x00CCCC,0xCCCC78,0x303030,0x780000);\nvec4 ch_Z = vec4(0x00FECE,0x981830,0x6062C6,0xFE0000);\nvec4 ch_lsb = vec4(0x003C30,0x303030,0x303030,0x3C0000);\nvec4 ch_rsl = vec4(0x000080,0xC06030,0x180C06,0x020000);\nvec4 ch_rsb = vec4(0x003C0C,0x0C0C0C,0x0C0C0C,0x3C0000);\nvec4 ch_pow = vec4(0x10386C,0xC60000,0x000000,0x000000);\nvec4 ch_usc = vec4(0x000000,0x000000,0x000000,0x00FF00);\nvec4 ch_a = vec4(0x000000,0x00780C,0x7CCCCC,0x760000);\nvec4 ch_b = vec4(0x00E060,0x607C66,0x666666,0xDC0000);\nvec4 ch_c = vec4(0x000000,0x0078CC,0xC0C0CC,0x780000);\nvec4 ch_d = vec4(0x001C0C,0x0C7CCC,0xCCCCCC,0x760000);\nvec4 ch_e = vec4(0x000000,0x0078CC,0xFCC0CC,0x780000);\nvec4 ch_f = vec4(0x00386C,0x6060F8,0x606060,0xF00000);\nvec4 ch_g = vec4(0x000000,0x0076CC,0xCCCC7C,0x0CCC78);\nvec4 ch_h = vec4(0x00E060,0x606C76,0x666666,0xE60000);\nvec4 ch_i = vec4(0x001818,0x007818,0x181818,0x7E0000);\nvec4 ch_j = vec4(0x000C0C,0x003C0C,0x0C0C0C,0xCCCC78);\nvec4 ch_k = vec4(0x00E060,0x60666C,0x786C66,0xE60000);\nvec4 ch_l = vec4(0x007818,0x181818,0x181818,0x7E0000);\nvec4 ch_m = vec4(0x000000,0x00FCD6,0xD6D6D6,0xC60000);\nvec4 ch_n = vec4(0x000000,0x00F8CC,0xCCCCCC,0xCC0000);\nvec4 ch_o = vec4(0x000000,0x0078CC,0xCCCCCC,0x780000);\nvec4 ch_p = vec4(0x000000,0x00DC66,0x666666,0x7C60F0);\nvec4 ch_q = vec4(0x000000,0x0076CC,0xCCCCCC,0x7C0C1E);\nvec4 ch_r = vec4(0x000000,0x00EC6E,0x766060,0xF00000);\nvec4 ch_s = vec4(0x000000,0x0078CC,0x6018CC,0x780000);\nvec4 ch_t = vec4(0x000020,0x60FC60,0x60606C,0x380000);\nvec4 ch_u = vec4(0x000000,0x00CCCC,0xCCCCCC,0x760000);\nvec4 ch_v = vec4(0x000000,0x00CCCC,0xCCCC78,0x300000);\nvec4 ch_w = vec4(0x000000,0x00C6C6,0xD6D66C,0x6C0000);\nvec4 ch_x = vec4(0x000000,0x00C66C,0x38386C,0xC60000);\nvec4 ch_y = vec4(0x000000,0x006666,0x66663C,0x0C18F0);\nvec4 ch_z = vec4(0x000000,0x00FC8C,0x1860C4,0xFC0000);\nvec4 ch_lpa = vec4(0x001C30,0x3060C0,0x603030,0x1C0000);\nvec4 ch_bar = vec4(0x001818,0x181800,0x181818,0x180000);\nvec4 ch_rpa = vec4(0x00E030,0x30180C,0x183030,0xE00000);\nvec4 ch_tid = vec4(0x0073DA,0xCE0000,0x000000,0x000000);\nvec4 ch_lar = vec4(0x000000,0x10386C,0xC6C6FE,0x000000);\n\nvec2 res = vec2(0);\nvec2 print_pos = vec2(0);\n\n//Extracts bit b from the given number.\n//Shifts bits right (num / 2^bit) then ANDs the result with 1 (mod(result,2.0)).\nfloat extract_bit(float n, float b)\n{\n    b = clamp(b,-1.0,24.0);\nreturn floor(mod(floor(n / pow(2.0,floor(b))),2.0)); \n}\n\n//Returns the pixel at uv in the given bit-packed sprite.\nfloat sprite(vec4 spr, vec2 size, vec2 uv)\n{\n    uv = floor(uv);\n\n    //Calculate the bit to extract (x + y * width) (flipped on x-axis)\n    float bit = (size.x-uv.x-1.0) + uv.y * size.x;\n\n    //Clipping bound to remove garbage outside the sprite's boundaries.\n    bool bounds = all(greaterThanEqual(uv,vec2(0))) && all(lessThan(uv,size));\n\n    float pixels = 0.0;\n    pixels += extract_bit(spr.x, bit - 72.0);\n    pixels += extract_bit(spr.y, bit - 48.0);\n    pixels += extract_bit(spr.z, bit - 24.0);\n    pixels += extract_bit(spr.w, bit - 00.0);\n\n    return bounds ? pixels : 0.0;\n}\n\n//Prints a character and moves the print position forward by 1 character width.\nfloat char(vec4 ch, vec2 uv)\n{\n    if( TEXT_MODE == INVERT )\n    {\n      //Inverts all of the bits in the character.\n      ch = pow(2.0,24.0)-1.0-ch;\n    }\n    if( TEXT_MODE == UNDERLINE )\n    {\n      //Makes the bottom 8 bits all 1.\n      //Shifts the bottom chunk right 8 bits to drop the lowest 8 bits,\n      //then shifts it left 8 bits and adds 255 (binary 11111111).\n      ch.w = floor(ch.w/256.0)*256.0 + 255.0; \n    }\n\n    float px = sprite(ch, CHAR_SIZE, uv - print_pos);\n    print_pos.x += CHAR_SPACING.x;\n    return px;\n}\n\n\n//Returns the digit sprite for the given number.\nvec4 get_digit(float d)\n{\n    d = floor(d);\n\n    if(d == 0.0) return ch_0;\n    if(d == 1.0) return ch_1;\n    if(d == 2.0) return ch_2;\n    if(d == 3.0) return ch_3;\n    if(d == 4.0) return ch_4;\n    if(d == 5.0) return ch_5;\n    if(d == 6.0) return ch_6;\n    if(d == 7.0) return ch_7;\n    if(d == 8.0) return ch_8;\n    if(d == 9.0) return ch_9;\n    return vec4(0.0);\n}\n\n//Prints out the given number starting at pos.\nfloat print_number(float number, vec2 uv)\n{\n    float result = 0.0;\n\nfor(int i = 3;i >= -1;i--)\n    {\n        float digit = mod( number / pow(10.0, float(i)) , 10.0);\n\n        if(i == -1) //Add a decimal point.\n        {\n            result += char(ch_per,uv);\n        }\n\n        if(abs(number) > pow(10.0, float(i)) || i == 0) //Clip off leading zeros.\n        {\n        result += char(get_digit(digit),uv);\n        }\n    } \n    return result;\n}\n\nfloat print_integer(float number, int zeros, vec2 uv)\n{\n    float result = 0.0;\n\nfor(int i = MAX_INT_DIGITS;i >= 0;i--)\n    {\n        float digit = mod( number / pow(10.0, float(i)) , 10.0);\n\n        if(abs(number) > pow(10.0, float(i)) || zeros > i  || i == 0) //Clip off leading zeros.\n        {\n        result += char(get_digit(digit),uv);\n        }\n    } \n    return result;\n}\n\nfloat text(vec2 uv)\n{\n    float col = 0.0;\n\n    vec2 center = res/2.0;\n\n    float hour = floor(iDate.w/60.0/60.0);\n    float minute = floor(mod(iDate.w/60.0,60.0));\n    float second = floor(mod(iDate.w,60.0));\n\n    // Speed\n\n    print_pos = vec2(15., 44.);\n\n    col += char(ch_S,uv);\n    col += char(ch_p,uv);\n    col += char(ch_e,uv);\n    col += char(ch_e,uv);\n    col += char(ch_d,uv);\n    col += char(ch_col, uv);\n\n    // Mouth Speed\n\n    print_pos = vec2(15., 24.);\n\n    col += char(ch_M,uv);\n    col += char(ch_o,uv);\n    col += char(ch_u,uv);\n    col += char(ch_t,uv);\n    col += char(ch_h,uv);\n    col += char(ch_spc,uv);\n    col += char(ch_s,uv);\n    col += char(ch_p,uv);\n    col += char(ch_e,uv);\n    col += char(ch_e,uv);\n    col += char(ch_d,uv);\n    col += char(ch_col, uv);\n\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    res = iResolution.xy / DOWN_SCALE;\n    vec2 uv = fragCoord.xy / DOWN_SCALE;\nvec2 duv = floor(fragCoord.xy / DOWN_SCALE);\n\nfloat pixel = text(duv);\n\n    if (pixel > 0.) {\n        fragColor = vec4(vec3(1., 0.6, 0.1), 1.0);\n    } else {\n        fragColor = vec4(0.);\n    }\n}","name":"Buffer B","description":"","type":"buffer"}]}