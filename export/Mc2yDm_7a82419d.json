{"ver":"0.1","info":{"id":"Mc2yDm","date":"1722450860","viewed":31,"name":"Rotation of line","username":"dsd","description":"Rotation of line between two points with multisampling","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["line","rotation","multisampling"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define AR (16./9.)\n\nvec3 bg_col;\n\nvec2 nx(vec2 v) {\n    return vec2(v.x*AR, v.y);\n}\n\nvec2 get_norm_point(vec2 p1, vec2 p2, vec2 nuv) {\n    vec2 pp = p2 - p1;\n    vec2 upp = normalize(pp);\n    vec2 uvp = nuv - p1;\n    float len_po = dot(upp, uvp);\n    return p1 + upp*len_po;\n}\n    \nbool is_in_line(vec2 o, float thick, vec2 nuv) {\n    float len_uvo = length(nuv - o);\n    return (len_uvo <= thick/2.);\n}\n\nbool is_between_points(vec2 p1, vec2 p2, vec2 o) {\n    float len_pp = length(p2 - p1);\n    return (length(o - p1) < len_pp && length(p2 - o) < len_pp);\n}\n\nvec2 rot(vec2 c, vec2 p, float f) {\n    mat2 r_mat = mat2(cos(f), -sin(f), sin(f), cos(f));\n    return r_mat*(p - c) + c;\n}\n\nvec3 get_col(vec2 nuv) {\n\n    vec3 p_col = vec3(1., 0., 1.);\n    float rad = .02;\n    vec2 c = vec2(.5);\n    vec2 p = vec2(.7);\n    c = nx(c);\n    p = nx(p);\n    \n    p = rot(c, p, iTime/2.);\n    \n    float thick = .013;\n    vec3 ln_col = vec3(0., 1., 0.);\n    \n    vec2 o = get_norm_point(c, p, nuv);\n    \n    if (length(nuv - c) < rad\n        || length(nuv - p) < rad)\n      return p_col; \n    else if (is_in_line(o, thick, nuv) && is_between_points(c, p, o))\n      return ln_col;\n    else\n      return bg_col;\n}\n\nvoid mainImage(out vec4 Clr, in vec2 Crd) {\n    vec2 uv = Crd/iResolution.xy;\n    bg_col = vec3(uv.x);\n    vec2 nuv = nx(uv);\n    \n    float pix_sz = 1./(0.5*iResolution.x);\n    int divider = 11;\n    int num_slices = divider*divider;\n    float fr_step = pix_sz / float(divider*2);\n    float start_offset = pix_sz/2. + fr_step;\n    \n    vec2 sub_uv = nuv - start_offset;\n    vec3 col = vec3(0.);\n    \n    for (int i = 0; i < divider; i++) {\n\t\tfor (int j = 0; j < divider; j++) {\n\t\t\tcol += get_col(sub_uv) / float (num_slices);\n\t\t\tsub_uv.y += fr_step;\n\t\t}\n\t\tsub_uv = vec2(sub_uv.x + fr_step, nuv.y - start_offset);\n\t}\n    \n    Clr = vec4(col, 1.);\n}\n","name":"Image","description":"","type":"image"}]}