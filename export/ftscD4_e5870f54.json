{"ver":"0.1","info":{"id":"ftscD4","date":"1649407774","viewed":64,"name":"Project_massa_alexis","username":"alexis_massa","description":"3D","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["yes"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14159265359\n\n#define CENTER_POS vec3(0.) // center position\n#define CAMERA_POS vec3(0., 0., 2.) // camera position \n#define LIGHT_SOURCE vec3(0., -10., 5.) // sun position \n\n#define MIN_DIST .01 // Minimal dist\n#define MAX_DIST 30. // Maximal dist\n\n#define EPS .01 // when dist < EPS = we touched an object\n\n\nstruct Ray {\n    vec3 o; // Origin\n    vec3 d; // Direction\n};\n\nstruct Surface {\n    float d; // Distance\n    vec3 c; // Color\n};\n\n// random\nfloat rand(float co) { return fract(sin(co*(91.3458)) * 47453.5453); }\nfloat rand(vec2 co){ return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453); }\nfloat rand(vec3 co){ return rand(co.xy+rand(co.z)); }\n\n// Rotation vector around the X axis.\nvec3 rotateX(in vec3 p, float a) {\n    float c = cos(a);\n    float s = sin(a);\n    return vec3(p.x,p.y*c-p.z*s, p.y*s+p.z*c);\n}\n\n// Rotation vector around the Y axis.\nvec3 rotateY(in vec3 p, float a) {\n    float c = cos(a);\n    float s = sin(a);\n    return vec3(p.x*c-p.z*s,p.y, p.x*s+p.z*c);\n}\n\n// Rotation vector around the Z axis.\nvec3 rotateZ(in vec3 p, float a) {\n    float c = cos(a);\n    float s = sin(a);\n    return vec3(p.x*c-p.y*s, p.x*s+p.y*c, p.z);\n}\n\n// rotate vector p by vector r\nvec3 rotate(in vec3 p, in vec3 r){\n    return rotateX(rotateY(rotateZ(p,r.z),r.y),r.x);\n}\n\n// translate of d on X\nvec3 translateX(in vec3 p, float d){\n    return vec3(p.x+d,p.y,p.z);\n}\n\n// translate of d on Y\nvec3 translateY(in vec3 p, float d){\n    return vec3(p.x,p.y+d,p.z);\n}\n\n// translate of d on Z\nvec3 translateZ(in vec3 p, float d){\n    return vec3(p.x,p.y,p.z+d);\n}\n\n// translate vector p of d\nvec3 translate(in vec3 p, in vec3 d){\n    return translateX(translateY(translateZ(p, d.z),d.y),d.x);\n}\n\n\n//smooth union of d1 and d2 with k delta\n// volé ici : https://iquilezles.org/articles/distfunctions\nSurface opSmoothUnion( Surface d1, Surface d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2.d-d1.d)/k, 0.0, 1.0 );\n    return Surface(mix( d2.d, d1.d, h ) - k*h*(1.0-h),\n        mix( d2.c, d1.c, h ) - k*h*(1.0-h)\n    );    \n}\n\n//union of d1 and d2\n// adapté de : https://iquilezles.org/articles/distfunctions\nSurface opUnion( Surface s1, Surface s2 ) { \n    Surface s = Surface(min(s1.d,s2.d),vec3(0.)); \n    if(s1.d<s2.d)\n        s.c = s1.c;\n    else\n        s.c = s2.c;\n    return s;\n}\n\n\n//substraction of d1 and d2\n// adapté de : https://iquilezles.org/articles/distfunctions\nSurface opSubtraction( Surface s1, Surface s2 ) { return Surface(max(-s1.d,s2.d),max(-s1.c,s2.c)); }\n\n\n// distance sphere\n// volé ici : https://iquilezles.org/articles/distfunctions\nfloat sdSphere(in vec3 p, float r) {\n    return length(p)-r;\n}\n\n// sphere + color\nSurface sphere(vec3 p, float r, vec3 col){\n    return Surface(sdSphere(p, r), col);\n}\n\n// distance ring / DONUT (Torus)\n// volé ici : https://iquilezles.org/articles/distfunctions\nfloat sdRing( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n// ring + color\nSurface ring(vec3 p, vec2 t, vec3 col){\n    return Surface(sdRing(p, t), col);\n}\n\n// Cone\n// volé ici : https://iquilezles.org/articles/distfunctions\nfloat sdCone( vec3 p, vec2 c, float h )\n{\n  float q = length(p.xz);\n  return max(dot(c.xy,vec2(q,p.y)),-h-p.y);\n}\n\n// cone + color\nSurface cone(vec3 p, vec2 c, float h, vec3 col){\n    return Surface(sdCone(p, c, h), col);\n}\n\n// rounded cone\n// volé ici : https://iquilezles.org/articles/distfunctions\nfloat sdRoundCone( vec3 p, float r1, float r2, float h )\n{\n  // sampling independent computations (only depend on shape)\n  float b = (r1-r2)/h;\n  float a = sqrt(1.0-b*b);\n\n  // sampling dependant computations\n  vec2 q = vec2( length(p.xz), p.y );\n  float k = dot(q,vec2(-b,a));\n  if( k<0.0 ) return length(q) - r1;\n  if( k>a*h ) return length(q-vec2(0.0,h)) - r2;\n  return dot(q, vec2(a,b) ) - r1;\n}\n\n// rounded cone + color\nSurface roundCone(vec3 p, float r1, float r2, float h, vec3 col){\n    return Surface(sdRoundCone( p, r1, r2, h ), col);\n}\n\n// box\n// volé ici : https://iquilezles.org/articles/distfunctions\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n// box + color\nSurface box(vec3 p, vec3 b, vec3 col){ return Surface(sdBox(p, b), col); }\n\n// SCENE\nSurface sdScene(vec3 p){\n    vec3 t = p*5.;\n    float edit = sin(t.z*.9)*cos(t.x*.7)*cos(t.y*.8)*.08; // sphere mofifier\n    \n    // Sphere\n    Surface sphere1 = sphere(p, 1., vec3(.5,1.,.6));\n    sphere1.d = sphere1.d + edit;\n    //cut\n    Surface b1 = box(rotate(p, vec3(PI/2.)), vec3(2.,2.,.2), vec3(1.));\n    \n    Surface cut = opSubtraction(b1, sphere1);\n\n    // inside sphere\n    Surface sphere2 = sphere(p, .95, vec3(.2));\n    \n    Surface spheres = opUnion(cut, sphere2);\n\n    p=rotate(p,vec3(iTime, 0., 0.));\n    p=rotate(p,vec3(PI/4.,PI/2.,0.));\n\n    // Cone\n    float size = 1.;\n    vec3 cCenter1 = p-vec3(0.,.5,0.);\n    vec3 cCenter2 = rotate(p-vec3(0.1,-.51,0.), vec3(PI,0.32,0.));\n    vec3 cCenter5 = rotate(p-vec3(0.01,.63,0.), vec3(PI*.342,0.,0.));\n    vec3 cCenter3 = rotate(p-vec3(0.04,0.02,-.5), vec3(PI/2.1,0.,0.));\n    vec3 cCenter6 = rotate(p-vec3(0.02,-.63,0.), vec3(PI/.63,0.,0.));\n    vec3 cCenter4 = rotate(p-vec3(0.04,0.1,.5), vec3(PI*1.522,0.,0.));\n\n      \n    // cones\n    Surface rc1 = roundCone(cCenter1,  .4, .1, .6,  vec3(.9,1.,.62)); // mountain\n    Surface rc2 = roundCone(cCenter2,  .55, .05, .6,  vec3(.8,.8,.63)); // mountain\n    Surface rc3 = roundCone(cCenter3,  .6, .11, .6,  vec3(.78,1.,.66)); // mountain\n    Surface rc4 = roundCone(cCenter4,  .5, .09, .6,  vec3(.85,.99,.76)); // mountain\n    Surface rc5 = roundCone(cCenter5,  .3, .13, .6,  vec3(.98,.8,.65)); // mountain\n    Surface rc6 = roundCone(cCenter6,  .1, .1, .6,  vec3(.83,.9,.6)); // mountain\n    \n    Surface rcs = opSmoothUnion(opSmoothUnion(opSmoothUnion(opSmoothUnion(opSmoothUnion(rc1, rc2, .5), rc3, .5), rc4, .5),rc5, .5), rc6, .5);\n    \n    // Ring\n    // vec3 oT = rotate(p,vec3(iTime,0.,0.));\n    // Surface ring = ring(oT, vec2(abs(cos(iTime)*2.)+2., .5), vec3(.5,1.,.6));\n    \n    // Scene\n    Surface scene = opSmoothUnion(spheres, rcs, .1);\n    //return r;\n    return scene;\n}\n\n\nvec3 normale(in vec3 p){\n    float e = .01;\n    float dx = sdScene(vec3(p.x+e,p.y,p.z)).d-sdScene(vec3(p.x-e,p.y,p.z)).d;\n    float dy = sdScene(vec3(p.x,p.y+e,p.z)).d-sdScene(vec3(p.x,p.y-e,p.z)).d;\n    float dz = sdScene(vec3(p.x,p.y,p.z+e)).d-sdScene(vec3(p.x,p.y,p.z-e)).d;\n    return normalize(vec3(dx,dy,dz));\n}\n\nvec3 shade(in Surface surf, in Ray ray) {\n    // tous les vecteurs nécessaires au shading\n    vec3 p = ray.o+ray.d*surf.d;\n\n    vec3 n = normale(p);\n    vec3 l = normalize(LIGHT_SOURCE);\n    vec3 v = ray.d;\n    vec3 r = reflect(l,n);\n    \n    // parametres du materiau\n    vec3 kd = surf.c;\n    vec3 ks = vec3(0.);\n    float s = 20.;\n    \n    // coeficients diffus et spéculaires\n    float diff = max(dot(n,l),0.);\n    float spec = pow(max(dot(r,v),0.),s);\n    \n    return kd*diff + ks*spec;\n}\n\n//ray march\nSurface rayMarch(Ray r){\n   \n    float t = MIN_DIST; // initialize t\n    \n    for(int i = 0;t<MAX_DIST;++i) { // until we reach MAX_DIST :\n        Surface s = sdScene(r.o+r.d*t); // point to ray direction\n        if(s.d < EPS){ // if we hit something : color \n            s.d = t;\n            return  s;\n        }\n        t += s.d;\n    }\n   return Surface(MAX_DIST,vec3(1.)); // return default\n}\n\nRay generateRay(in vec2 p){\n    // p in [-1, 1]^2\n\n\n    vec3 ut = vec3(0,1,0); // temporary up vector\n\n    vec3 v = normalize(CENTER_POS-CAMERA_POS); // vector view \n    vec3 r = normalize(cross(v, ut)); // vector right\n    vec3 u = cross(v,r); // vector up\n    \n    float alpha = 45.; // angle in degrees\n    alpha = (alpha/360.)*2.*PI; // angle in radians\n\n    float D = 1./tan(alpha/2.); // Distance to screen from camera\n    \n    vec3 d = normalize(r*p.x+u*p.y+v*D);\n    \n    return Ray(CAMERA_POS, d); // ray\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates\n    vec2 uv = (2.*fragCoord - iResolution.xy) / iResolution.y;\n    \n    Ray r = generateRay(uv);\n    \n    Surface surface = rayMarch(r);\n    surface.c = shade(surface, r);\n\n    vec3 col = surface.c;\n    if(surface.d < MAX_DIST)\n        col = shade(surface, r);\n    else // background\n        col = vec3(0.5,0.7,0.8); // oscillates light and dark : -(cos(iTime*.5)*.5+.5)\n        \n    // Output to screen\n    fragColor = vec4(col,1.0);\n\n}","name":"Image","description":"","type":"image"}]}