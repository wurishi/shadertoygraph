{"ver":"0.1","info":{"id":"WsKGWh","date":"1607857333","viewed":67,"name":"Raymarch shit laptop","username":"Soulztorm","description":"kek","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raymarch"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI \t3.14159265\n#define PI2 6.28318530\n#define PI2INV 0.159154943\n\n#define STEPSCALE 0.99\n#define MAX_STEPS 60.\n#define MAX_STEPS_SHADOW 1.\n#define MAX_DIST 10.\n#define SURF_DIST .001\n\n#define n(a) (0.5 - 0.5 * a)\n\n//float time = fGlobalTime / 60.;\n#define time2 iTime\n\nvec3 cp, cr;\n\nvec4 sdSphere(in vec3 p, in float d, in vec3 col){\n return vec4(col, length(p) -d);   \n}\nvec4 sdTorus(in vec3 p, in float d, in float t, in vec3 col){\n return vec4(col, length(vec2(length(p.xz) - d, p.y)) - t);   \n}\nvec4 sdBox( vec3 p, vec3 b, vec3 col ){\n  vec3 d = abs(p) - b;\n  float ds = length(max(d,0.0)) + min(max(d.x,max(d.y,d.z)),0.0); // remove this line for an only partially signed sdf \n  return vec4(col, ds);\n} \nvec4 sdBoxRounded(vec3 p, vec3 b, float roundness, vec3 col){\n  vec4 d = sdBox(p,b,col);\n  d.w -= roundness;\n  return d;\n}\n\nfloat sminSq( in float a, in float b, float k) { float h = max( k - abs(a-b), 0.0); return min(a,b) - h*h /(k*4.0);}\nvec4 smin( in vec4 a, in vec4 b, float k) {k = max(k,0.005); return vec4(mix(a.rgb, b.rgb, clamp((a.w - sminSq(a.w, b.w, 2.))- (b.w-a.w)*(1.0/k), 0.,1.)), sminSq(a.w,b.w,k));}\nvec4 minn(in vec4 a, in vec4 b){ return vec4((a.w < b.w) ? a.rgb : b.rgb, min(a.w,b.w));}\n\nvec3 opRep(vec3 p, vec3 r){ return mod(p, r) - r*0.5;}\nvec3 opRepFloor(vec3 p, vec3 r){ vec3 f = (p/r) + 0.5*(1.-r);    return vec3(int(f.x), int(f.y), int(f.z));}\n\nmat2 rot(float a){float c = cos(a); float s = sin(a); return mat2(c,-s,s,c);}\nvec2 moda(vec2 p, float rep, float off) { vec2 inter = vec2(atan(p.y,p.x), length(p.xy)); inter.x /= PI2;  inter.x = (fract(inter.x*rep+0.5)-0.5)/rep;  inter.x *= PI2;\n  return rot(off) * vec2(cos(inter.x),sin(inter.x))*inter.y;}\n\nvec4 map (vec3 p){   \n    vec4 d;\n    \n    if (length(p) < 5.)\n    {\n    \n  vec4 d1 = sdSphere(p - vec3(0.7,0,0), 0.9, vec3(0.5,0.1,0));\n  vec4 d2 = sdSphere(p - vec3(-0.7,0,0), 0.9, vec3(0.1,0.1,0.5));\n  \n  vec3 boxPos = p - vec3(sin(time2*0.5)*2.,0.8,0);\n  vec4 b = sdBoxRounded(boxPos, vec3(0.5), 0.1, vec3(1,1,0));\n  \n  vec3 torusP = boxPos; torusP.xy *= rot(sin(-time2*0.5)* sin(time2)*PI2 * cos(1.5*sin(time2*2.)));\n  vec4 torus = sdTorus(torusP, 0.7, 0.2, vec3(0.3,0.8,0));\n  \n  torusP.xy *= rot(PI*0.5);\n  vec4 torus2 = sdTorus(torusP, 0.7, 0.2, vec3(0.3,0.8,0));\n  \n  torus = smin(torus, torus2, 0.03);\n  \n    b = smin(b,torus,0.15);\n  d = smin(d1,d2,0.1);\n  d = smin(d, b, n(sin(time2*3.)));\n    }\n    else\n        d = vec4(1,1,1,length(p));\n\n  \n  // floor\n  float checkerScale = 4.;\n  d = minn(d, vec4(1. - 0.8*vec3( step(0., sin(p.x*checkerScale) * sin(p.z*checkerScale))), p.y+0.5));\n  return d;  \n}\n\nvec3 getNormal(in vec3 p) {\n vec2 e = vec2(0, SURF_DIST); \n  return normalize(map(p).w - vec3(map(p - e.yxx).w,  map(p - e.xyx).w, map(p - e.xxy).w));\n}\n\nfloat softshadow( in vec3 ro, in vec3 rd,in float mint,in float maxt, float k)\n{\n    float res = 1.0;\n    float stepDist = maxt / MAX_STEPS_SHADOW;\n    float t = mint;\n   \n    for(int i = 0; i < 10000; i++)\n    {\n        float h = map(ro + rd*t).w;  \n        if( h<SURF_DIST)\n            return 0.0;\n        res = min( res, k*h/t );\n        t += min(h, stepDist*2.);\n        if (t >= maxt)\n\t\t\tbreak;\n    }\n    return res;\n}\n\nfloat ao(vec3 ro, vec3 rd, float range, float strength)\n{\n    float totao = 0.;\n    float sca = 1.;\n    for (int aoi = 0; aoi < 5; aoi++)\n    {\n        float hr = SURF_DIST + range*SURF_DIST * float(aoi * aoi);\n        vec3 aopos = ro + rd * hr;\n        vec4 d = map(aopos); float dd = d.w;\n        float ao = clamp(-(dd - hr), 0.0, 1.0);\n        totao += ao * sca;\n        sca *= 0.75;\n    }\n    const float aoCoef = 0.2;\n    totao = pow(1.0 - clamp(aoCoef * totao, 0.0, 1.0), strength);\n    return totao;\n}\n\nvec3 getLightSpecShadow(vec3 p, vec3 lightPos, vec3 n, float shininess) { \n  vec3 op = (p + n * 2. * SURF_DIST);\n  vec4 d = map(op);\n  \n  vec3 l = normalize( lightPos - p);\n  float ll = length(lightPos - p);\n  vec3 nl = normalize(lightPos - op);\n  vec3 r = normalize(-reflect(l,n));\n\n  float diffuse = clamp(max(dot(n,l), 0.), 0., 1.); \n  float specular = clamp(pow(max(dot(r,-cr),0.0),shininess), 0.0, 1.0); \n  float shadow = softshadow(op, nl, SURF_DIST, ll, 16.);\n\n  return vec3(diffuse, specular, shadow);\n}\n\nfloat pulse(float t, float lengthP1, float valP1, float lengthP2,float valP2){\n  \n  float totalLength = lengthP1 + lengthP2;\n  float modT = mod(t, totalLength);\n  \n  if (modT < lengthP1){\n     return valP1 * sin((modT / lengthP1) * PI * 0.5);\n  }\n  else\n  {\n     return valP2 * sin(((modT - lengthP1) / lengthP2) * PI * 0.5);\n  }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n      // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    uv -= 0.5;\n  \n  uv.x *= iResolution.x / iResolution.y; \n  //time2 = mod(time2,200.);\n  \n    cp = vec3(0,2,-5);\n    cr = normalize( vec3(uv,0.6) );\n  \n  \n    cp.xz *= rot(PI);\n    cr.xz *= rot(PI);\n  \n    cr.yz *= rot(-0.5);\n  \n    float r = 0.;\n    vec3 p = cp;\n    vec4 d = vec4(0.);\n     \n  float stepDist = MAX_DIST / MAX_STEPS;\n  float dist = 0.;\n\n    float ii;\n    for (float i = 0.0; i < MAX_STEPS; i++){\n        ii = i;\n        d = map(p);\n        dist += d.w * STEPSCALE; //min(d.w, stepDist*.25); \n        p = cp + cr*dist;\n        \n        if (d.w > MAX_DIST || d.w < SURF_DIST){\n          break;\n        }\n    }\n    \n    // Done raycasting\n    float zDepth = p.z-cp.z;\n    vec3 n = getNormal(p);\n    \n    float iterGlow = ii / (MAX_STEPS);\n    vec3 col = vec3(0);\n    \n    // Light\n    vec3 lightPos = vec3(0,5,0);//vec3(5*sin(time2),10,5*cos(time2)); \n    float lightBrightness = 1.;\n    float lightRange = 15.;\n    float lightPow = 2.;\n    // Light Falloff\n    float attn = clamp(pow(lightBrightness*(1. - smoothstep(0., lightRange, length(lightPos - p))), lightPow),0.,1.);\n    \n    vec3 specCol = vec3(0.4,0.4,1);\n    \n    // Get diffuse specular and shadow\n    vec3 lightSpecShadow = getLightSpecShadow(p, lightPos, n, 100.);\n    float diff = max(0.04, lightSpecShadow.x * lightSpecShadow.z);\n    //float AO = ao(p, n, 20., 30.);\nfloat AO = 1.;\n    // Final color\n\t  col = AO * attn * (d.rgb * diff + specCol * lightSpecShadow.y);\n\n    //col = vec3(lightSpecShadow.x);\n    // gammacorrect\n    col = pow(col, vec3(0.4545));\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}