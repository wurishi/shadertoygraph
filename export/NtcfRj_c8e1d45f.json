{"ver":"0.1","info":{"id":"NtcfRj","date":"1663316094","viewed":219,"name":"Double Goraud Glenz Vector","username":"swiety","description":"Goraud Glenz Vector by Swiety","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["demoscene","vector","glenz","goraud"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float zcur = 0.0;\n\n\nvec2 InsideTrian(float x1, float y1, float z1, float x2, float y2, float z2, float x3, float y3, float z3, float xp, float yp) {\n\n float tmp;\n float curz;\n \n \n if (y1>y3) {\n  tmp=y3;\n  y3=y1;\n  y1=tmp;\n   \n  tmp=x3;\n  x3=x1;\n  x1=tmp;\n  \n  tmp=z3;\n  z3=z1;\n  z1=tmp; \n   \n  }\n  \n  if (y1>y2) {\n  tmp=y2;\n  y2=y1;\n  y1=tmp;\n   \n  tmp=x2;\n  x2=x1;\n  x1=tmp;\n  \n  tmp=z2;\n  z2=z1;\n  z1=tmp; \n  \n  } \n    \n  if (y2>y3) {\n  tmp=y2;\n  y2=y3;\n  y3=tmp;\n  \n  tmp=x2;\n  x2=x3;\n  x3=tmp;\n  \n  tmp=z2;\n  z2=z3;\n  z3=tmp; \n  }\n  \n  if ((yp<y1)||(yp>y3)) return vec2(0.0,0.0);\n\n// yp is beetween y1 a y3\n\n float       xw1 = x1+((x3-x1)/(y3-y1))*(yp-y1);\n float       dz1 = z1+((z3-z1)/(y3-y1))*(yp-y1);\n \n float xw2,dz2;\n\n if (yp>y2)  { xw2 = x2+((x3-x2)/(y3-y2))*(yp-y2);\n               dz2 = z2+((z3-z2)/(y3-y2))*(yp-y2);\n             }\n \n else        { xw2 = x1+((x2-x1)/(y2-y1))*(yp-y1);\n               dz2 = z1+((z2-z1)/(y2-y1))*(yp-y1);\n             }\n \n curz = dz1 + (dz2-dz1)/(xw2-xw1)*(xp-xw1);\n  \n return vec2(float(((xw1<=xw2) && (xw1<=xp)&&(xw2>=xp))||((xw1>xw2) && (xw2<=xp)&&(xw1>=xp))),curz); \n }\n\nvec3 rotateX(float angle, float x, float y, float z)\n{\n    float c = cos(angle);\n    float s = sin(angle);\n    return vec3(x,(s*z-c*y),(s*y+z*c));\n}\n\nvec3 rotateY(float angle, float x, float y, float z)\n{\n    float c = cos(angle);\n    float s = sin(angle);\n    return vec3((s*z+c*x),y,(s*x-z*c));\n}\n\nvec3 rotateZ(float angle, float x, float y, float z)\n{\n    float c = cos(angle);\n    float s = sin(angle);\n    return vec3((x*s+y*c),(s*y-c*x),z);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n vec2 calculatedvertex[30];\n vec3 verttable[15];\n float ztable[30];\n \n\n verttable[0] = vec3(-1.0,-1.0,1.0);\n verttable[1] = vec3(1.0,-1.0,1.0);\n verttable[2] = vec3(1.0,1.0,1.0);\n verttable[3] = vec3(-1.0,1.0,1.0);\n\n verttable[4] = vec3(-1.0,-1.0,-1.0);\n verttable[5] = vec3(1.0,-1.0,-1.0);\n verttable[6] = vec3(1.0,1.0,-1.0);\n verttable[7] = vec3(-1.0,1.0,-1.0);\n\n verttable[8] = vec3(0.0,0.0,1.0);\n verttable[9] = vec3(0.0,0.0,-1.0);\n verttable[10] = vec3(1.0,0.0,0.0);\n verttable[11] = vec3(-1.0,0.0,0.0);\n verttable[12] = vec3(0.0,-1.0,0.0);\n verttable[13] = vec3(0.0,1.0,0.0);\n \nint sk1[24] = int[24] (\n  4,5,4,0,\n  6,7,6,2,\n  0,7,4,7,\n  1,5,5,6,\n  0,2,2,0,\n  4,6,6,4); \n \nint sk2[24] = int[24] (\n  0,1,5,1,\n  2,3,7,3,\n  3,4,0,3,\n  2,6,1,2,\n  1,3,1,3,\n  5,7,5,7);\n \nint sk3[24] = int[24] (\n 12,12,12,12,\n 13,13,13,13,\n 11,11,11,11,\n 10,10,10,10,\n 8,8,8,8,\n 9,9,9,9);\n\n\n // Normalized pixel coordinates (from 0 to 1)\n \n  vec2 uv = fragCoord/iResolution.xy-0.5;\n\n  uv.x*= iResolution.x/iResolution.y;\n\n //  uv.x = floor(uv.x *160.)/160.;\n //  uv.y=  floor(uv.y *113.)/113.;\n\n\n//    uv.x = floor(uv.x *80.)/80.;\n//    uv.y=  floor(uv.y *56.)/56.;\n\n\n\n  float d=0.9; // distance\n  float squaresize = 0.8;\n  float halfsquare = squaresize/2.;\n  \n  float Realtime = float(iFrame);\n  \n  //Realtime = Realtime + uv.y*19.; //+uv.x*10.;\n  \n  float angleX = Realtime*0.018;\n  float angleY = Realtime*-0.037;\n  float angleZ = Realtime*0.01;\n  \n  \n  vec3 col = vec3(0.0,0.0,0.0);\n  vec3 triancol;\n\n  float addx = sin(iTime*2.1)*0.35;\n  float addy = sin(-iTime*3.0)*0.062;\n\n\n\n\n float Zdistance = 0.48-sin(iTime*1.4)*0.65-cos(iTime*2.3)*0.65;\n \n float mixfactor =smoothstep(0.0,1.0,clamp(length(vec2(uv.x+addx,uv.y+addy))*2.2-0.7,0.0,1.0));\n \n \n if (Zdistance>=0.2) Zdistance = mix(0.2,Zdistance,mixfactor);\n \n \n float x = uv.x+uv.x/((1.+Zdistance/d)*squaresize);\n float y = uv.y+uv.y /((1.+Zdistance/d)*squaresize);\n\n \n float a= mod (addx+x , squaresize);\n float b= mod (addy+y, squaresize);\n \n float halfsquarex = squaresize/2.;\n float halfsquarey = squaresize/2.;\n \n\n if ((a<=halfsquarex) && (b<=halfsquarey) || (a>=halfsquarex) && (b>=halfsquarey)){\n col = vec3(0.0,1.0,0.0)*clamp(Zdistance+0.15,0.1,1.1);\n }\n else col = vec3(0.17,0.17,0.17)*clamp(Zdistance+0.05,0.0,1.1); \n\n\n// rotate & perspective calc\n\n float scale = 0.24;\n\n for (int rep=0 ; rep<=1 ; ++rep){\n\n    for (int licz=0 ; licz<=13 ; ++licz){\n\n    vec3 rotxyz = verttable[licz]*scale;\n \n    rotxyz = rotateX(angleX,rotxyz.x,rotxyz.y,rotxyz.z);\n    rotxyz = rotateY(angleY,rotxyz.x,rotxyz.y,rotxyz.z);\n    rotxyz = rotateZ(angleZ,rotxyz.x,rotxyz.y,rotxyz.z);\n\n    rotxyz.x = rotxyz.x/(1.+rotxyz.z/d);\n    rotxyz.y = rotxyz.y/(1.+rotxyz.z/d);\n\n    calculatedvertex[licz+14*rep]=0.0-vec2(addx+rotxyz.x,addy+rotxyz.y);\n    ztable[licz+14*rep] = rotxyz.z;\n\n  }\n   scale = scale-0.09;\n   \n   angleX = angleX+sin(iTime*1.2)*0.4;\n   \n   angleY = angleY-sin(iTime*2.2)*0.4;\n   angleZ = angleZ-sin(iTime*2.9)*0.4;\n   \n }\n \n \n \nvec2 trn;\n\n// draw back vector part\n\n for (int face=0 ; face<=23 ; ++face){\n \n   if (ztable[sk3[face]]>-0.072) {\n   vec2 pos1 = calculatedvertex[sk1[face]];\n   vec2 pos2 = calculatedvertex[sk2[face]];\n   vec2 pos3 = calculatedvertex[sk3[face]];\n  \n   trn = (InsideTrian(pos1.x,pos1.y,ztable[sk1[face]],pos2.x,pos2.y,ztable[sk2[face]],pos3.x,pos3.y,ztable[sk3[face]], uv.x , uv.y));\n  \n   if  (trn.x==1.) { \n   \n   if ((face&0x2)==0) col=vec3(0.1,0.15,1.0)*(0.8-trn.y); \n   else col=vec3(0.0,0.1,0.6)*(0.8-trn.y);\n   \n   }\n  }\n }  \n \nfloat zpoint = 0.029;  \n \n for (int face=0 ; face<=23 ; ++face){\n \n   if (ztable[sk3[face]+14]>-zpoint) {\n   vec2 pos1 = calculatedvertex[sk1[face]+14];\n   vec2 pos2 = calculatedvertex[sk2[face]+14];\n   vec2 pos3 = calculatedvertex[sk3[face]+14];\n  \n   trn = (InsideTrian(pos1.x,pos1.y,ztable[sk1[face]+14],pos2.x,pos2.y,ztable[sk2[face]+14],pos3.x,pos3.y,ztable[sk3[face]+14], uv.x , uv.y));\n  \n   if  (trn.x==1.) { \n   \n   if ((face&0x2)==0) col=vec3(1.0,0.15,0.1)*(0.8-trn.y); \n   else col=vec3(0.6,0.1,0.0)*(0.8-trn.y);\n   \n   }\n  }\n } \n\n\n\n// draw front vector part\n \n triancol=vec3(1.0,1.0,1.0);\n \n for (int face=0 ; face<=23 ; ++face){\n \n   if (ztable[sk3[face]+14]<-zpoint) {\n   vec2 pos1 = calculatedvertex[sk1[face]+14];\n   vec2 pos2 = calculatedvertex[sk2[face]+14];\n   vec2 pos3 = calculatedvertex[sk3[face]+14];\n  trn = (InsideTrian(pos1.x,pos1.y,ztable[sk1[face]+14],pos2.x,pos2.y,ztable[sk2[face]+14],pos3.x,pos3.y,ztable[sk3[face]+14], uv.x , uv.y));\n  \n   if ((trn.x==1.)&&(face&0x2)==0) col = vec3(0.22-trn.y)*1.9 ; //triancol;\n   }\n }  \n \n \n \n \n \n \n for (int face=0 ; face<=23 ; ++face){\n \n   if (ztable[sk3[face]]<-0.072) {\n   vec2 pos1 = calculatedvertex[sk1[face]];\n   vec2 pos2 = calculatedvertex[sk2[face]];\n   vec2 pos3 = calculatedvertex[sk3[face]];\n  trn = (InsideTrian(pos1.x,pos1.y,ztable[sk1[face]],pos2.x,pos2.y,ztable[sk2[face]],pos3.x,pos3.y,ztable[sk3[face]], uv.x , uv.y));\n  \n  if ((trn.x==1.)&&(face&0x2)==0) col = vec3(0.22-trn.y)*1.9 ; //triancol;\n   }\n } \n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n\n","name":"Image","description":"","type":"image"}]}