{"ver":"0.1","info":{"id":"43BGWD","date":"1715385646","viewed":23,"name":"AK FYP5: Twisting Cube Tower","username":"AKHC","description":"Another raymarching test that experimented with distortion functions for shapes, as well as figuring out how to erase noise from a coloured background and keep it a solid colour. Uses box frame SDF https://iquilezles.org/articles/distfunctions/","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 palette( in float t)\n{\n    vec3 a = vec3(1.668, 0.500, 0.500);\n    vec3 b = vec3(0.500, 0.500, 0.500);\n    vec3 c = vec3(3.138, 1.000, 1.000);\n    vec3 d = vec3(0.000, 0.333, 0.667);\n    \n    //return vec3(t);\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nvec3 palette2( in float t)\n{\n    vec3 a = vec3(0.474, 0.744, 0.696);\n    vec3 b = vec3(0.014, 0.756, 0.955);\n    vec3 c = vec3(1.042, 0.456, 1.232);\n    vec3 d = vec3(2.026, 3.344, 4.003);\n    \n    //return vec3(t);\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nvec3 rotateVector(vec3 v, vec3 axis, float angle) {\n    return v * cos(angle) +\n           cross(axis, v) * sin(angle) +\n           axis * dot(axis, v) * (1.0 - cos(angle));\n}\n\nmat2 rot2D(float angle)\n{\n    float s = sin(angle);\n    float c = cos(angle);\n    return mat2(c, -s, s, c);\n}\n\nfloat smin( float a, float b, float k )\n{\n    k *= 4.0;\n    float h = max( k-abs(a-b), 0.0 )/k;\n    return min( a, b ) - h*h*k*(1.0/4.0);\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n\nfloat sdBoxFrame( vec3 p, vec3 b, float e )\n{\n       p = abs(p  )-b;\n  vec3 q = abs(p+e)-e;\n  return min(min(\n      length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n      length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n      length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\n\n\n\n//distance to scene function\nfloat map(vec3 p, vec3 move)\n{\n    float scale = 4.;\n\n\n    vec3 q = p; //input point copy\n    \n    q.y = fract(p.y) - 0.5;//repeat on y axis\n\n\n    //SRT (TRS)\n\n    vec3 torusXform = rotateVector(q, vec3(0, 0, 1), cos(iTime * 2.));\n\n    float torus = sdTorus(torusXform * 2.5, vec2(1.1, 0.2)) / 2.5;\n\n    //vec3 cubeXform = rotateVector(p * scale, normalize(vec3(1, 0, 1)), sin(iTime)) + move;\n    //vec3 cubeXform = rotateVector(q * 3., normalize(vec3(1, 0, 1)), sin(iTime) * 5.) + move;\n    vec3 cubeXform = rotateVector(q, normalize(vec3(1, 0, 1)), sin(iTime) * 5.);\n    //space needs to be scaled down so it fits within the repitition space(?)\n    float cube = sdBox(cubeXform * 5., vec3(0.5, 0.5, 0.5)) / 5.; //dividing by scale removes artifacts. scaling distorts metrics in scene(?)\n\n\n    //float boxFrame = sdBoxFrame(q, vec3(0.5, 0.5, 0.5), 0.02 * sin(iTime*3.) + 0.03);\n    \n    \n    //TWIST\n    \n    \n    //float k = sin(iTime * 2.) * 1.5; // or some other amount\n    float k = sin(iTime * 2.) * 1.5; // or some other amount\n    float c = cos(k*p.y);\n    float s = sin(k*p.y);\n    mat2  m = mat2(c,-s,s,c);\n    vec3  q2 = vec3(m*q.xz,q.y);\n    //q2.y += iTime;\n    //float boxFrame = sdBoxFrame(q2, vec3(0.5, 0.5, 0.5), (sin(iTime * 10.) + 2.) / 30.);\n    float boxFrame = sdBoxFrame(q2, vec3(0.5, 0.5, 0.5), (2.) / 30.);\n    \n    \n    \n    \n    \n    \n    \n\n    float sphere = sdSphere(p, 0.6);\n\n    //float ground = p.y + 0.75;\n    \n\n    //float un = smin(ground, smin(cube, torus, 0.3), 0.1);\n    float un = smin(cube, torus, 0.1);\n    return boxFrame;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord * 2. - iResolution.xy) / iResolution.y;\n    vec2 m = (iMouse.xy * 2. - iResolution.xy) / iResolution.y;\n\n    //Initialisation\n    //define ray origin at z -3 in world \n    vec3 ro = vec3(0, 0, -3);\n    //field of view\n    float fov = 0.5;\n    //ray direction\n    vec3 rd = normalize(vec3(uv * fov, 1)); //uses uv to determine direction for each pixel\n    //keeps track of distance travelled by ray across the world\n    float t = 0.;\n    vec3 col = vec3(0);\n\n    vec3 translation = vec3(sin(iTime) * 5., cos(iTime) * .2, 0);\n\n    //vertical cam rotation\n    ro.yz *= rot2D(-m.y);\n    rd.yz *= rot2D(-m.y);\n\n    //horizontal cam rotation\n    ro.xz *= rot2D(-m.x);\n    rd.xz *= rot2D(-m.x);\n    \n    \n\n    //Raymarching\n    //current position along ray\n    for(int i = 0; i < 200; i++)\n    {\n        vec3 p = ro + rd * t;   //marches ray: ray origin + the direction\n        float d = map(p, translation);   //get distance to closest point from p\n        t += d; //assigns distance travelled to total distance\n        \n        if(d < 0.001f) break;   //stop if ray gets too close to object\n        if(t > 1000.) break; //stop if ray goes too far\n\n    }\n\n    //col = vec3(t * .08); //sets colour to 'depth buffer'\n    if(t > 1000.) t = 1000.;\n    //t must be clamped so palette doesn't return noisy value\n    col = palette2(t * .08); //sets colour to 'depth buffer'\n\n    fragColor = vec4(col, 1);\n}","name":"Image","description":"","type":"image"}]}