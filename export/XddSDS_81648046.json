{"ver":"0.1","info":{"id":"XddSDS","date":"1461243845","viewed":178,"name":"Alien Egg","username":"Draedrus","description":"I wanted to apply the iq's primitives to do some weirdly scene involving an alien egg. So I designed in paper my scene and tried to put it to life. I had great problems from the walls, I had something else in mind. The floor, egg looks like my paperwork","likes":3,"published":1,"flags":32,"usePreview":0,"tags":["raymarching","transparency","refraction","alien","egg"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define NUM_STEPS 120\n#define CAMDIST 20.0\n#define ROOMSIZE 21.0\n#define CAMROTSPEED 0.4\n#define LIGHTSPEED 0.0\n#define FAR 200.0\n#define NEAR 0.002\n\n#define LIGHTPOS vec3(15.0, 5.0, 0.0)\n#define CAMPOS vec3(5.0, 5.0, -5.0)\n#define EGGPOS vec3(0.0, 3.0, 0.0)\n#define CREEPCOLOR vec3(0.00, 0.00, 0.00)\n#define THINGCOLOR vec3(0.05, 0.05, 0.01)\n#define EGGCOLOR vec3(0.05, 0.15, 0.05)\n#define CREEPDIFFUSE 0.5\n#define CREEPSPECULAR 0.5\n#define EGGOPACITY 0.5\n#define EFFREFRACTIND 1.1\n\n//#define NEWWALLS\n\n#define ROTX(P, A) P*mat3(1.0, 0.0, 0.0, 0.0, cos(A), -sin(A), 0.0, sin(A), cos(A))\n#define ROTY(P, A) P*mat3(cos(A), 0.0, -sin(A), 0.0, 1.0, 0.0, sin(A), 0.0, cos(A))\n#define ROTZ(P, A) P*mat3(cos(A), -sin(A), 0.0, sin(A), cos(A), 0.0, 0.0, 0.0, 1.0)\n\nstruct Light {\n    vec3 o;\n    vec3 d;\n    vec4 diffuseColor;\n    float attenuation;\n\tfloat shininess;\n};\n\nLight _light = Light(\n    vec3(0.0, 0.0, 0.0),\n    vec3(0.0, 0.0, 0.0),\n    vec4(1.0, 1.0, 0.3, 1.0),\n    10.0,\n    3.0);\n\n\n/*******************\n * TOOLS\n *******************/\nvec3 RotXV3(in vec3 P, float A)\n{\n    float cA = cos(A), sA = sin(A);\n    return P*mat3(1.0, 0.0, 0.0, 0.0, cA, -sA, 0.0, sA, cA);\n}\nvec3 RotYV3(in vec3 P, float A)\n{\n    float cA = cos(A), sA = sin(A);\n    return P*mat3(cA, 0.0, -sA, 0.0, 1.0, 0.0, sA, 0.0, cA);\n}\nvec3 RotZV3(in vec3 P, float A)\n{\n    float cA = cos(A), sA = sin(A);\n    return P*mat3(cA, -sA, 0.0, sA, cA, 0.0, 0.0, 0.0, 1.0);\n}\n\n\n/*******************\n * NOISES\n *******************/\n\nfloat hash2D(vec2 x) {\n    float h = dot(x, vec2(42.69, 51.42));\n\treturn fract(sin(h)*50403.43434);   \n}\n\nfloat hash3D(vec3 x) {\n    float h = dot(x, vec3(42.69, 51.42, 34.405));\n\treturn fract(sin(h)*50403.43434);   \n}\n\n/*******************\n * VORONOI + CELLS LIMITS\n *******************/\n\nfloat voronoi(vec2 uv) {\n    vec2 fl = floor(uv);\n    vec2 fr = fract(uv);\n    float res = 1.0;\n    for( int j=-1; j<=1; j++ ) {\n        for( int i=-1; i<=1; i++ ) {\n            vec2 p = vec2(i, j);\n            float h = hash2D(fl+p);\n            vec2 vp = p-fr+h;\n            float d = dot(vp, vp);\n            \n            res +=1.0/pow(d, 8.0);\n        }\n    }\n    return pow( 1.0/res, 1.0/16.0 );\n}\n\nfloat voronoi3D(vec3 uv) {\n    vec3 fl = floor(uv);\n    vec3 fr = fract(uv);\n    float res = 1.0;\n    for(int k=-1;k<=1;k++)\n    for( int j=-1; j<=1; j++ ) {\n        for( int i=-1; i<=1; i++ ) {\n            vec3 p = vec3(i, j, k);\n            float h = hash3D(fl+p);\n            vec3 vp = p-fr+h;\n            float d = dot(vp, vp);\n            \n            res +=1.0/pow(d, 8.0);\n        }\n    }\n    return pow( 1.0/res, 1.0/16.0 );\n}\n\n/*******************\n * PRIMITIVES\n *******************/\nfloat sdPlane( vec3 p )\n{\n\treturn p.y;\n}\n\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    return max(q.z-h.y,max((q.x*0.866025+q.y*0.5),q.y)-h.x);\n}\n\nfloat sdSphere(vec3 pos, float radius)\n{\n    return length(pos) - radius;\n}\n\nfloat sdCone( vec3 p, vec2 c )\n{\n    // c must be normalized\n    float q = length(p.xy);\n    return dot(c,vec2(q,p.z));\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) +\n         length(max(d,0.0));\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\n// polynomial smooth min (k = 0.1);\nfloat polsmin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\n// polynomial smooth min (k = 0.1);\nfloat polsmax( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, 1.0-h ) - k*h*(1.0-h);\n}\n\n/*******************\n * OP\n *******************/\n\nfloat opU( float d1, float d2 )\n{\n    return min(d1,d2);\n}\n\nfloat opS( float d1, float d2 )\n{\n    return max(-d1,d2);\n}\n\nfloat opI( float d1, float d2 )\n{\n    return max(d1,d2);\n}\n\n\n/*******************\n * FLOOR\n *******************/\n\nfloat mapHole(vec3 p) {\n    float s = sdSphere(p-vec3(0.0, 0.0, 0.0), 4.0);\n    return s * fract(p.y*0.5);\n}\n\nfloat mapFloor(vec3 p) {\n    #define FREQ_RAINURES 5.0\n    #define AMP_RAINURES 0.2\n    p.y += 7.0;\n    float p1 = sdPlane(p);\n    float angle = atan(p.z, p.x);\n    float h = sin(angle*10.0)*0.8-0.0;\n    h = min(h, sin(length(p.xz)*FREQ_RAINURES)*AMP_RAINURES-0.0);\n    float d1 = mapHole(p);\n    float res = max( -d1, h);\n    d1 = sdBox(p-vec3(0.0, -4.0, 0.0), vec3(6.8, 6.8, 6.8));\n    return p1+polsmin(res, d1, 4.0);\n}\n\n/*******************\n * WALLS\n *******************/\n\n#ifdef NEWWALLS\nfloat opDisplaceWallsHorizontal( vec3 p, float s)\n{\n    return s+sin(atan(p.z, p.x)*10.0)*(ROOMSIZE*0.05);\n}\n\nfloat opDisplaceWallsVertical( vec3 p, float s )\n{\n    return s+sin(p.y)*0.5;\n}\n\nfloat mapWalls(vec3 p ) {\n    float s = sdSphere(p, ROOMSIZE*1.8);//+-voronoi3D(p);\n    return polsmax(opDisplaceWallsHorizontal(p, s), opDisplaceWallsVertical(p, s), 1.1);\n}\n/*float mapWalls(vec3 p)\n{\n    float angle = atan(p.z, p.x);\n    float d1 = sdSphere(p, ROOMSIZE);\n    float d2 = (sin(angle*10.0)+1.0)*0.05;\n    float d3 = sin(p.y*8.0)*0.05;\n    return p.y-min(min(d1, d2), d3);\n}*/\n#else\nfloat mapWalls( vec3 p )\n{\n    float angle = atan(p.z, p.x);\n    float d1 = sdSphere(p, ROOMSIZE);\n    float d2 = (sin(angle*10.0)+1.0)*0.2;//((sin(angle*8.0)+1.0)*0.5)*0.1;\n    float d3 = sin(p.y*2.0)*0.1;\n    return max(max(-d1, d2), d3);//polsmax(max(-d1, d2), d3, 0.3);//d2+d3;\n}\n#endif\n\n/*******************\n * The thing that hangs the egg\n *******************/\n#define map_thing_t 4.71\n#if 1\nfloat mapThing( vec3 p)\n{\n    float T = -voronoi3D(p);\n    return T + sdCapsule(p, vec3(0.0, 20.0, 0.0), vec3(0.0, -20.0, 0.0), 1.0);\n    return T+sdCone(p, vec2(2.0, 0.1));\n}\n#else\nfloat mapThing( vec3 p)\n{\n    mat3 rotX = mat3(\n        1.0, 0.0, 0.0,\n        0.0, cos(map_thing_t), -sin(map_thing_t),\n        0.0, sin(map_thing_t), cos(map_thing_t));\n    p = p*rotX;\n    float T = -voronoi3D(p+vec3(0.0, iTime, 0.0));\n    return T+sdCone(p, vec2(1.0, 0.1));\n}\n#endif\n\n/*******************\n * WEBS\n *******************/\n\nfloat mapWeb( vec3 p, float t, float tb)\n{\n    /*float t = 3.14/4.0;\n    float tb = 3.14;*/\n    float ct = cos(t);\n    float st = sin(t);\n    float ctb = cos(20.0*tb);\n    float stb = sin(20.0*tb);\n    p.y -= 5.0;\n    mat2 b = mat2(ctb, -stb,stb, ctb);\n    p.xy = p.xy*b;\n    p =p*mat3(\n        1.0, 0.0, 0.0,\n        0.0, ct, -st,\n        0.0, st, ct);\n    return sdCapsule(p, vec3(0.0, 20.0, 0.0), vec3(0.0, 00.0, 0.0), 0.3);\n}\n\n\n/*******************\n * Egg\n *******************/\n\nfloat mapEgg( vec3 p)\n{\n    float eggD = sdSphere(p, 4.0);\n    return (eggD+voronoi3D(p)*(0.3+sin(iTime*5.0)*0.1));\n}\n\n/*******************\n * MAP\n *******************/\n\n/**\n * (Distance, Type) with Type =\n * 0.0 == Floor\n * 1.0 == Walls\n * 2.0 == The thing will hang the egg\n * 3.0 == Egg\n **/\n\nvec2 map(vec3 p) {\n    float D = 0.0, T = 0.0;\n    // floor & walls\n    float fl = mapFloor(p);\n    float w = mapWalls(p);\n    #ifdef NEWWALLS\n    D = min(fl, -w);\n    #else\n    D = polsmin(fl, w, 1.0);\n    #endif\n    T = fl==D?0.0:1.0;\n    // the hanger one\n    float d3 = mapThing(p);\n    D = polsmin(D, d3, 0.2);\n    T = d3==D?2.0:T;\n    // webs\n    float d4 = mapWeb(p, 0.785398, 3.141592);\n    D = polsmin(D, d4, 0.2);\n    T = d4==D?2.0:T;\n    d4 = mapWeb(p - vec3(0.0, 4.0, 0.0), -0.785398, -0.987993/*-3.141592*/);\n    D = polsmin(D, d4, 0.2);\n    T = d4==D?2.0:T;\n    // the egg\n    float d5 = mapEgg(p-EGGPOS);\n    D = polsmin(D, d5, 1.1);\n    T = d5==D?3.0:T;\n    return vec2(D, T);\n}\n\nvec3 mapNormal(vec3 pt, float e) {\n    vec3 normal;\n    normal.y = map(pt).x;    \n    normal.x = map(vec3(pt.x+e,pt.y,pt.z)).x - normal.y;\n    normal.z = map(vec3(pt.x,pt.y,pt.z+e)).x - normal.y;\n    normal.y = e;\n    return normalize(normal);\n}\n\n/*********************\n * RAYMARCHING\n *********************/\n\nvec2 raymarch(vec3 ro, vec3 rd, in float tmin, in float tmax) {\n    vec2 m = vec2(-1.0, -1.0);\n    vec2 res = vec2(tmin, -1.0);\n    res.x = tmin;\n\tfor( int i=0; i<NUM_STEPS; i++ )\n\t{\n        m = map(ro + res.x*rd);\n\t\tif( m.x<tmin || res.x>tmax ) break;\n\t\tres.x += m.x;\n        res.y = m.y;\n\t}\n    if( res.x>tmax ) res.y=-1.0;\n\treturn res;\n}\n\n/**********************\n * CAMERA SETUP\n **********************/\n\n// the camera construction method is inspired by the one from IQ\nmat3 setCamera( in vec3 origin, in vec3 target, vec3 viewUp )\n{\n\tvec3 cw = normalize(target-origin);\n\tvec3 cu = normalize( cross(cw,viewUp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid camPos(float t, in vec3 rdi, in vec3 roi, out vec3 ro, out vec3 rd) {\n    ro = roi;\n\trd = normalize(RotYV3(rdi, t));\n}\n\n/******************\n * LIGHT SETUP\n ******************/\n\nfloat softshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n\tfloat res = 1.0;\n    float t = mint;\n    for( int i=0; i<16; i++ )\n    {\n\t\tfloat h = map( ro + rd*t ).x;\n        res = min( res, 8.0*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( h<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n\n}\n\nfloat shadow(in vec3 ro, in vec3 rd, in float tmin, in float tmax) {\n    float t = tmin;\n    for( int i=0; i<10; ++i )\n    {\n\t\tfloat h = map( ro + rd*t ).x;\n        if( h<tmin || t>tmax) break;\n        t+=h;//float(i)/30.0;\n    }\n    return clamp(1.0-(tmax-t)/(tmax-tmin), 0.0, 1.0);\n}\n\nvoid lightPos(float t, out vec3 lPos) {\n    lPos = RotYV3(lPos, t);\n}\n\n/*******************\n * MAIN\n *******************/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    vec2 pixel = -1.0 + 2.0*uv;// vec2(iResolution.x*0.6, iResolution.y);\n\tpixel.x *= iResolution.x/iResolution.y;\n    \n    vec2 mv = -1.0 + 2.0*iMouse.xy/iResolution.xy+vec2(1.0, 0.0);\n    float Time = mod(iTime*CAMROTSPEED, 360.0);\n    pixel.x *= 0.6;\n\n    vec3 eggPos = EGGPOS;\n    \n    vec3 ro = CAMPOS;\n    vec3 rd = vec3(pixel, 1.0);\n\tvec3 lPos = LIGHTPOS;\n    ro.x = eggPos.x+cos(Time*CAMROTSPEED)*CAMDIST;\n    ro.z = eggPos.z+sin(Time*CAMROTSPEED)*CAMDIST;\n    rd = normalize(rd);\n    mat3 ca = setCamera(ro, EGGPOS, vec3(0.0, 1.0, 0.0));\n    rd = ca*normalize(vec3(pixel.xy, 2.0));\n    lightPos(Time*LIGHTSPEED, lPos);\n    \n    vec2 rm = raymarch(ro, rd, NEAR, FAR);\n    float t = rm.x;\n    vec3 p = ro+rd*t;\n    vec3 n = normalize(mapNormal(p, 0.001));\n    vec3 l = normalize(p - lPos);\n    \n    _light.o = lPos;\n     _light.d = l;\n    \n    vec3 color = vec3(0.0, 0.0, 0.0);\n    //float depthFactor = (FAR-t)/(FAR-NEAR);\n\n\t//float sf = softshadow(ro, rd, NEAR, FAR);\n    #ifdef LIGHTSPOT\n    float lDiffuse = _light.attenuation/pow(length(p - lPos), 2.0);\n    #else\n    float lDiffuse = max(0.0, dot(n, -l))*_light.attenuation/(length(p - lPos));\n    #endif\n    \n    // shadowing\n    if(t>NEAR && t<FAR && rm.y==0.0) { // Floor\n        #ifdef LIGHTSPOT\n        float lSpec = pow(max(0.0, dot(rd, reflect(l, n))), _light.shininess);\n        #else\n        float lSpec = pow(max(0.0, dot(rd, reflect(l, n))), _light.shininess);\n        #endif\n        color = CREEPCOLOR+lDiffuse*CREEPDIFFUSE+lSpec*CREEPSPECULAR;\n        p+=vec3(0.0, lPos.y, 0.0);\n        color *= vec3(shadow(p, -l, NEAR, 20.5));\n    }\n    if(t>NEAR && t<FAR && rm.y==1.0) { // walls\n        #ifdef LIGHTSPOT\n        float lSpec = pow(max(0.0, dot(rd, reflect(l, n))), _light.shininess);\n        #else\n        float lSpec = pow(max(0.0, dot(rd, reflect(l, n))), _light.shininess);\n        #endif\n        color = CREEPCOLOR+lDiffuse*CREEPDIFFUSE+lSpec*CREEPSPECULAR;\n        //color *= vec3(shadow(p, -l, NEAR, 0.5));\n    }\n    if(t>NEAR && t<FAR && rm.y==2.0) { // thing\n        float v = voronoi3D(p*8.0);\n        color = THINGCOLOR*v+lDiffuse;\n    }\n    if(t>NEAR && t<FAR && rm.y==3.0) { // egg\n        uv = refract(vec3(uv, 1.0), -abs(n), EFFREFRACTIND).xy;\n        float v = voronoi3D(p*3.0);\n        color = mix(\n            EGGCOLOR*v+lDiffuse,\n            texture(iChannel0, uv).rgb,\n            EGGOPACITY);\n    }\n    //color*=depthFactor;\n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define NUM_STEPS 180\n#define CAMDIST 20.0\n#define CAMROTSPEED 0.4\n#define LIGHTSPEED -0.4\n#define FAR 50.0\n#define NEAR 0.002\n#define OCTAVES_PERLIN 8\n#define ANIMATE\n\n#define LIGHTPOS vec3(5.0, 5.0, 0.0)\n#define CAMPOS vec3(5.0, 5.0, -5.0)\n#define EGGPOS vec3(0.0, 3.0, 0.0)\n#define CREEPCOLOR vec3(0.05, 0.05, 0.05)\n#define THINGCOLOR vec3(0.15, 0.15, 0.05)\n#define EGGCOLOR vec3(0.05, 0.15, 0.05)\n#define ALIENCOLOR vec3(0.05, 0.1, 0.05)\n#define CREEPSCALE 2.0\n\n#define ROTX(P, A) P*mat3(1.0, 0.0, 0.0, 0.0, cos(A), -sin(A), 0.0, sin(A), cos(A))\n#define ROTY(P, A) P*mat3(cos(A), 0.0, -sin(A), 0.0, 1.0, 0.0, sin(A), 0.0, cos(A))\n#define ROTZ(P, A) P*mat3(cos(A), -sin(A), 0.0, sin(A), cos(A), 0.0, 0.0, 0.0, 1.0)\n\nstruct Light {\n    vec3 o;\n    vec3 d;\n    vec4 diffuseColor;\n    float shininess;\n\tfloat power;\n};\n\nLight _light = Light(\n    vec3(0.0, 0.0, 0.0),\n    vec3(0.0, 0.0, 0.0),\n    vec4(1.0, 1.0, 0.3, 1.0),\n    2.0,\n    2.0);\n\n/*******************\n * TOOLS\n *******************/\nvec3 RotXV3(in vec3 P, float A)\n{\n    float cA = cos(A), sA = sin(A);\n    return P*mat3(1.0, 0.0, 0.0, 0.0, cA, -sA, 0.0, sA, cA);\n}\nvec3 RotYV3(in vec3 P, float A)\n{\n    float cA = cos(A), sA = sin(A);\n    return P*mat3(cA, 0.0, -sA, 0.0, 1.0, 0.0, sA, 0.0, cA);\n}\nvec3 RotZV3(in vec3 P, float A)\n{\n    float cA = cos(A), sA = sin(A);\n    return P*mat3(cA, -sA, 0.0, sA, cA, 0.0, 0.0, 0.0, 1.0);\n}\n\n/*******************\n * NOISES\n *******************/\n\nfloat hash3D(vec3 x) {\n    float h = dot(x, vec3(42.69, 51.42, 34.405));\n\treturn fract(sin(h)*50403.43434);   \n}\n\n/*******************\n * VORONOI + CELLS LIMITS\n *******************/\n\nfloat voronoi3D(vec3 uv) {\n    vec3 fl = floor(uv);\n    vec3 fr = fract(uv);\n    float res = 1.0;\n    for(int k=-1;k<=1;k++)\n    for( int j=-1; j<=1; j++ ) {\n        for( int i=-1; i<=1; i++ ) {\n            vec3 p = vec3(i, j, k);\n            float h = hash3D(fl+p);\n            vec3 vp = p-fr+h;\n            float d = dot(vp, vp);\n            \n            res +=1.0/pow(d, 8.0);\n        }\n    }\n    return pow( 1.0/res, 1.0/16.0 );\n}\n\n\n/*******************\n * PRIMITIVES\n *******************/\nfloat sdPlane( vec3 p )\n{\n\treturn p.y;\n}\n\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    return max(q.z-h.y,max((q.x*0.866025+q.y*0.5),q.y)-h.x);\n}\n\nfloat sdSphere(vec3 pos, float radius)\n{\n    return length(pos) - radius;\n}\n\nfloat sdCone( vec3 p, vec2 c )\n{\n    // c must be normalized\n    float q = length(p.xy);\n    return dot(c,vec2(q,p.z));\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) +\n         length(max(d,0.0));\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\n// polynomial smooth min (k = 0.1);\nfloat polsmin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\n// polynomial smooth min (k = 0.1);\nfloat polsmax( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, 1.0-h ) - k*h*(1.0-h);\n}\n\n/*******************\n * OP\n *******************/\n\nfloat opU( float d1, float d2 )\n{\n    return min(d1,d2);\n}\n\nfloat opS( float d1, float d2 )\n{\n    return max(-d1,d2);\n}\n\nfloat opI( float d1, float d2 )\n{\n    return max(d1,d2);\n}\n\nvec3 opTwist( vec3 p )\n{\n    float c = cos(20.0*p.y);\n    float s = sin(20.0*p.y);\n    mat2  m = mat2(c,-s,s,c);\n    return vec3(m*p.xz,p.y);\n}\n\n\n/*******************\n * FLOOR\n *******************/\n\nfloat mapHole(vec3 p, float angle) {\n    float s = sdSphere(p-vec3(0.0, 0.0, 0.0), 4.0);\n    return s * fract(p.y*0.5);\n}\n\nfloat mapFloor(vec3 p) {\n    p.y += 7.0;\n    float p1 = sdPlane(p);\n    float angle = atan(p.z, p.x);\n    float h = sin(angle*10.0)*0.8-0.0;\n    h = min(h, sin(length(p.xz)*10.0)*0.3-0.0);\n    float d1 = mapHole(p, angle);\n    float res = max( -d1, h);\n    d1 = sdBox(p-vec3(0.0, -4.0, 0.0), vec3(6.8, 6.8, 6.8));\n    return p1+polsmin(res, d1, 4.0);\n}\n\n/*******************\n * WALLS\n *******************/\n\nfloat mapWalls( vec3 p )\n{\n    float angle = atan(p.z, p.x);\n    float d1 = sdSphere(p, CAMDIST*1.4);\n    float d2 = ((sin(angle*8.0)+1.0)*0.5)*0.5;\n    float d3 = sin(p.y*1.0)*0.1;\n    return polsmax(max(-d1, d2), d3, 0.3);//d2+d3;\n}\n\n/*******************\n * The thing that hangs the egg\n *******************/\n\nfloat mapThing( vec3 p)\n{\n    p = RotXV3(p, 4.71);\n    float T = -voronoi3D(p);\n    return T+sdCone(p, vec2(1.0, 0.1));\n}\n\n/*******************\n * Egg\n *******************/\n\nfloat mapAlien( vec3 p)\n{\n    float c = cos(2.0*p.y+2.0);\n    float s = sin(2.0*p.y+2.0);\n    mat2  m = mat2(c,-s,s,c);\n    p = vec3(m*p.xz,p.y);\n    p = RotXV3(p, -0.785);\n    float alienD = sdCapsule(p, vec3(0.0, 3.0, 0.0), vec3(0.0, -2.0, 0.0), 0.4);\n    float alienHead = sdSphere(p+vec3(0.0, 2.0, 0.0), 0.8);\n    return opU(alienHead, alienD);\n}\n\n/*******************\n * MAP\n *******************/\n\n/**\n * (Distance, Type) with Type =\n * 0.0 == Floor\n * 1.0 == Walls\n * 2.0 == The thing will hang the egg\n * 3.0 == Alien\n **/\n\nvec2 map(vec3 p) {\n    float D = 0.0, T = 0.0;\n    // floor & walls\n    /*float fl = mapFloor(p);\n    float w = mapWalls(p);\n    D = polsmin(fl, w, 1.0);\n    T = fl==D?0.0:1.0;*/\n    // the hanger one\n    /*float d3 = mapThing(p);\n    D = min(D, d3);\n    T = d3==D?2.0:T;*/\n    // alien\n    float d4 = mapAlien(p-EGGPOS);\n    /*D = min(D, d4);\n    T = d4==D?3.0:T;*/\n   \tD = d4;\n    T = 3.0;\n    return vec2(D, T);\n}\n\nvec3 mapNormal(vec3 pt, float e) {\n    vec3 normal;\n    normal.y = map(pt).x;    \n    normal.x = map(vec3(pt.x+e,pt.y,pt.z)).x - normal.y;\n    normal.z = map(vec3(pt.x,pt.y,pt.z+e)).x - normal.y;\n    normal.y = e;\n    return normalize(normal);\n}\n\n/*********************\n * RAYMARCHING\n *********************/\n\nvec2 raymarch(vec3 ro, vec3 rd, in float tmin, in float tmax) {\n    vec2 m = vec2(-1.0, -1.0);\n    vec2 res = vec2(tmin, -1.0);\n    res.x = tmin;\n\tfor( int i=0; i<NUM_STEPS; i++ )\n\t{\n        m = map(ro + res.x*rd);\n\t\tif( m.x<tmin || res.x>tmax ) break;\n\t\tres.x += m.x;\n        res.y = m.y;\n\t}\n    if( res.x>tmax ) res.y=-1.0;\n\treturn res;\n}\n\n/**********************\n * CAMERA SETUP\n **********************/\n\n// the camera construction method is inspired by the one from IQ\nmat3 setCamera( in vec3 origin, in vec3 target, vec3 viewUp )\n{\n\tvec3 cw = normalize(target-origin);\n\tvec3 cu = normalize( cross(cw,viewUp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid camPos(float t, in vec3 rdi, in vec3 roi, out vec3 ro, out vec3 rd) {\n    ro = roi;\n\trd = normalize(RotYV3(rdi, t));\n}\n\n/******************\n * LIGHT SETUP\n ******************/\n\nfloat softshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n\tfloat res = 1.0;\n    float t = mint;\n    for( int i=0; i<16; i++ )\n    {\n\t\tfloat h = map( ro + rd*t ).x;\n        res = min( res, 8.0*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( h<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n\n}\n\nvoid lightPos(float t, out vec3 lPos) {\n    lPos = RotYV3(lPos, t);\n}\n\n/*******************\n * MAIN\n *******************/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 pixel = -1.0 + 2.0*fragCoord.xy /iResolution.xy;// vec2(iResolution.x*0.6, iResolution.y);\n\tpixel.x *= iResolution.x/iResolution.y;\n    \n    vec2 mv = -1.0 + 2.0*iMouse.xy/iResolution.xy+vec2(1.0, 0.0);\n    float Time = mod(iTime*CAMROTSPEED, 360.0);\n    pixel.x *= 0.6;\n\n    vec3 eggPos = EGGPOS;\n    \n    vec3 ro = CAMPOS;\n    vec3 rd = vec3(pixel, 1.0);\n\tvec3 lPos = LIGHTPOS;\n    ro.x = eggPos.x+cos(Time*CAMROTSPEED)*CAMDIST;\n    ro.z = eggPos.z+sin(Time*CAMROTSPEED)*CAMDIST;\n    rd = normalize(rd);\n    mat3 ca = setCamera(ro, EGGPOS, vec3(0.0, 1.0, 0.0));\n    rd = ca*normalize(vec3(pixel.xy, 2.0));\n    lightPos(Time*LIGHTSPEED, lPos);\n    \n    vec2 rm = raymarch(ro, rd, NEAR, FAR);\n    float t = rm.x;\n    vec3 p = ro+rd*t;\n    vec3 n = normalize(mapNormal(p, 0.001));\n    vec3 l = normalize(eggPos - lPos);\n    \n    _light.o = lPos;\n     _light.d = l;\n    \n    \n    vec3 color = vec3(0.0, 0.0, 0.0);\n    //float depthFactor = (FAR-t)/(FAR-NEAR);\n\n\n\t//float sf = softshadow(ro, rd, NEAR, FAR);\n    \n    /*if(t>NEAR && t<FAR && rm.y==0.0) { // Floor\n    \tcolor = CREEPCOLOR+depthFactor*max(0.0, dot(n, -l));\n    }\n    if(t>NEAR && t<FAR && rm.y==1.0) { // walls\n    \tcolor = CREEPCOLOR+depthFactor*max(0.0, dot(n, -l));\n    }\n    if(t>NEAR && t<FAR && rm.y==2.0) { // thing\n    \tcolor = THINGCOLOR+depthFactor*max(0.0, dot(n, -l));\n    }*/\n    if(t>NEAR && t<FAR && rm.y==3.0) { // alien\n    \tcolor = ALIENCOLOR+max(0.0, dot(n, -l));\n    }\n    fragColor = vec4(color, 1.0);\n}","name":"Buffer A","description":"","type":"buffer"}]}