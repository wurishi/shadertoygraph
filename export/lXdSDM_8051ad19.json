{"ver":"0.1","info":{"id":"lXdSDM","date":"1719164284","viewed":49,"name":"Pixel Art Planets 2","username":"ArchaicVirus","description":"Procedural planets with infinite color variations, including dithering and a simple lighting model. Much faster than v1 (on mobile at least) but less artistic control of palette colors.","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["procedural","pixel","space","planet","dithering","art"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define INTERVAL 5.0\n#define PIXEL_SIZE 4.0\n#define DITHER_STRENGTH 0.095\n#define ENABLE_CLOUDS true\n\n// https://iquilezles.org/articles/palettes/\nvec3 palette(float t, vec3 a, vec3 b, vec3 c, vec3 d) {\n    return a + b * cos(6.28318 * (c * t + d));\n}\n\nstruct ColorScheme {\n    vec3 color1;\n    vec3 color2;\n    vec3 color3;\n    vec3 color4;\n    vec3 color5;\n    vec3 color6;\n    vec3 color7;\n    float seed;\n    vec3 atmosphereColor;\n};\n\nvec3 getColor(float n, ColorScheme scheme) {\n    if(n > 0.85)\n        return scheme.color7;\n    else if(n > 0.70)\n        return scheme.color6;\n    else if(n > 0.55)\n        return scheme.color5;\n    else if(n > 0.40)\n        return scheme.color4;\n    else if(n > 0.25)\n        return scheme.color3;\n    else if(n > 0.15)\n        return scheme.color2;\n    else\n        return scheme.color1;\n}\n\nfloat hash(float n, float seed) {\n    return fract(sin(n + seed) * 53738.14534123);\n}\n\nfloat noise(vec2 p, float seed) {\n    vec2 ip = floor(p);\n    vec2 u = fract(p);\n    u = u * u * (3.0 - 2.0 * u);\n\n    return mix(mix(hash(ip.x + ip.y * 57.0, seed), hash(ip.x + 1.0 + ip.y * 57.0, seed), u.x), mix(hash(ip.x + (ip.y + 1.0) * 57.0, seed), hash(ip.x + 1.0 + (ip.y + 1.0) * 57.0, seed), u.x), u.y);\n}\n\nColorScheme getProceduralColorScheme(float seed) {\n    vec3 a = vec3(noise(vec2(seed, 1.0), seed), noise(vec2(seed, 2.0), seed), noise(vec2(seed, 3.0), seed)) * 1.5;\n    vec3 b = vec3(noise(vec2(seed, 4.0), seed), noise(vec2(seed, 5.0), seed), noise(vec2(seed, 6.0), seed)) * 1.5;\n    vec3 c = vec3(noise(vec2(seed, 7.0), seed), noise(vec2(seed, 8.0), seed), noise(vec2(seed, 9.0), seed)) * 1.5;\n    vec3 d = vec3(noise(vec2(seed, 10.0), seed), noise(vec2(seed, 11.0), seed), noise(vec2(seed, 12.0), seed)) * 0.75;\n\n    return ColorScheme(palette(0.1, a, b, c, d), palette(0.2, a, b, c, d), palette(0.4, a, b, c, d), palette(0.6, a, b, c, d), palette(0.8, a, b, c, d), palette(1.0, a, b, c, d), palette(1.2, a, b, c, d), fract(seed * 0.1) * 1000.0, palette(1.5, a, b, c, d));\n}\n\nvec3 rotate(vec3 p, float angle) {\n    float s = sin(angle);\n    float c = cos(angle);\n    return vec3(c * p.x - s * p.z, p.y, s * p.x + c * p.z);\n}\n\nfloat layeredNoise(vec3 p, float amplitude, float frequency, float persistence, int octaves, float seed) {\n    float n = 0.0;\n    for(int i = 0; i < octaves; i++) {\n        n += noise(p.xy * frequency, seed) * amplitude;\n        amplitude *= persistence;\n        frequency *= 2.0;\n        p = rotate(p, 45.0);\n    }\n    return n;\n}\n\nfloat sphere(vec3 ro, vec3 rd, float radius) {\n    float b = dot(ro, rd);\n    float c = dot(ro, ro) - radius * radius;\n    float h = b * b - c;\n    if(h < 0.0)\n        return -1.0;\n    return -b - sqrt(h);\n}\n\nvec3 colorBanding(float n, ColorScheme scheme) {\n    vec3 color = vec3(0);\n    if(n > 0.92)\n        return scheme.color7;\n    else if(n > 0.80)\n        color = scheme.color6;\n    else if(n > 0.68)\n        color = scheme.color5;\n    else if(n > 0.53)\n        color = scheme.color4;\n    else if(n > 0.37)\n        color = scheme.color3;\n    else if(n > 0.21)\n        color = scheme.color2;\n    else\n        color = scheme.color1;\n    return color;\n}\n\nconst mat4 bayerMatrix = mat4(0.0 / 16.0, 8.0 / 16.0, 2.0 / 16.0, 10.0 / 16.0, 12.0 / 16.0, 4.0 / 16.0, 14.0 / 16.0, 6.0 / 16.0, 3.0 / 16.0, 11.0 / 16.0, 1.0 / 16.0, 9.0 / 16.0, 15.0 / 16.0, 7.0 / 16.0, 13.0 / 16.0, 5.0 / 16.0);\n\nvec3 applyDithering(float noiseValue, vec2 uv, ColorScheme scheme) {\n    int x = int(mod(uv.x, 4.0));\n    int y = int(mod(uv.y, 4.0));\n    float threshold = bayerMatrix[x][y];\n    noiseValue += threshold * DITHER_STRENGTH;\n    return colorBanding(noiseValue, scheme);\n}\n\nvec3 applyLighting(vec3 color, vec3 normal, vec3 lightDir) {\n    float diffuse = max(dot(normal, lightDir), 0.0);\n    return color * diffuse;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (floor(fragCoord / PIXEL_SIZE) * PIXEL_SIZE - iResolution.xy * 0.5) / iResolution.y;\n\n    float intervalNumber = floor((5.0 + iTime) / INTERVAL);\n    ColorScheme scheme = getProceduralColorScheme(intervalNumber);\n\n    vec3 ro_planet = vec3(0.0, 0.0, 2.3);\n    vec3 ro_clouds = vec3(0.0, 0.0, 2.25);\n    vec3 rd = normalize(vec3(uv, -1.0));\n    float t_planet = sphere(ro_planet, rd, 1.0);\n    float t_clouds = sphere(ro_clouds, rd, 1.0);\n    if(t_clouds < 0.0) {\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n    } else {\n        vec3 pos = ro_planet + t_planet * rd;\n        vec3 norm = normalize(pos);\n\n        pos = rotate(pos, iTime * 0.15);\n        vec3 rotatedNorm = normalize(rotate(norm, iTime * 0.15));\n\n        float noiseValue = layeredNoise(rotatedNorm * 3.1415, 0.75, 1.0, 0.5, 8, scheme.seed);\n\n        vec3 color;\n        if(t_planet < 0.0) {\n            color = vec3(0.0);\n        } else {\n            color = applyDithering(noiseValue, fragCoord.xy / PIXEL_SIZE, scheme);\n        }\n\n        vec3 lightDir = normalize(vec3(1.0, 0.5, 1.0));\n        color = applyLighting(color, norm, lightDir);\n        if(ENABLE_CLOUDS) {\n            vec3 pos2 = ro_clouds + t_clouds * rd;\n            vec3 rotatedNorm2 = normalize(rotate(pos2, iTime * 0.5));\n            vec3 norm2 = normalize(pos2);\n\n            float noiseValue2 = layeredNoise(rotatedNorm2 * 3.311, 1.0, 1.0, 0.5, 4, scheme.seed);\n            float noiseValueFinal = pow(noiseValue2, 1.05) - 1.0;\n            vec3 color2 = vec3(noiseValueFinal);\n\n            color2 = applyDithering(noiseValue2, fragCoord.xy / PIXEL_SIZE, scheme);\n            color2 = applyLighting(color2, norm2, lightDir);\n\n            fragColor = vec4(mix(color, (color2 * 0.16) * scheme.atmosphereColor, noiseValue2 * 0.45) + color, 1.0);\n        } else {\n            fragColor = vec4(color, 1.0);\n        }\n\n    }\n}\n","name":"Image","description":"","type":"image"}]}