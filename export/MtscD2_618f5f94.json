{"ver":"0.1","info":{"id":"MtscD2","date":"1506540089","viewed":502,"name":"Fog Sphere","username":"TinyTexel","description":"single-scattering ray-marching through a foggy fog sphere\nsupports cross-eye stereo rendering via #define RENDER_STEREO\ncamera controls via mouse + shift key\nlight controls via WASD + arrow keys","likes":17,"published":1,"flags":48,"usePreview":0,"tags":["noise","volume"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdXGzn","filepath":"/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","previewfilepath":"/media/ap/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdX3Rr","filepath":"/media/a/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin","previewfilepath":"/media/ap/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin","type":"volume","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Lincense: CC0 (https://creativecommons.org/publicdomain/zero/1.0/)\n\n/*\nsingle-scattering ray-marching through a foggy fog sphere\nsupports cross-eye stereo rendering via #define RENDER_STEREO\ncamera controls via mouse + shift key\nlight controls via WASD + arrow keys\n\ncode is a bit of a mess sry\n\npossible optimizations:\n- equi-angular sampling (distribute samples according to local point light intensity)\n- intersect homogeneous parts analytically so discontinuities dont mess with sampling quali\n\nTODO: replace deprecated texture stacking approach with prober 3D noise lookup\n*/\n\n\n#if 0\n\t#define ANIMATE_CAMERA\n\t#define ANIMATE_LIGHT\n\t#define ANIMATE_LIGHTCOL\n#endif\n\n// limit resolution in full-screen:\n// #define MAX_RESOLUTION vec2(1280., 720.)\n\n// cross-eye stereo:\n//#define RENDER_STEREO\n\n#define USE_DITHERING\n#define ANIMATE_DITHERING\n\n\n// at high+stable frame rates this improves dithering quality:\n//#define NEGATE_DITHERING_NOISE_ON_EVERY_SECOND_FRAME\n\n#define MAKE_VOLUME_PARTS_HOMOGENEOUS\n\n\n\n///////////////////////////////////////////////////////////////////////////\n//=======================================================================//\n\n#define Frame float(iFrame)\n#define Time iTime\n//#define PixelCount iResolution.xy\n#define OUT\n\nvec2 AngToVec(float ang)\n{\t\n\treturn vec2(cos(ang), sin(ang));\n}\n\n\nvec3 AngToVec(vec2 ang)\n{\n    float sinPhi   = sin(ang.x);\n    float cosPhi   = cos(ang.x);\n    float sinTheta = sin(ang.y);\n    float cosTheta = cos(ang.y);    \n\n    return vec3(cosPhi * cosTheta, \n                         sinTheta, \n                sinPhi * cosTheta); \n}\n\n\nfloat SqrLen(float v) {return v * v;}\nfloat SqrLen(vec2  v) {return dot(v, v);}\nfloat SqrLen(vec3  v) {return dot(v, v);}\nfloat SqrLen(vec4  v) {return dot(v, v);}\n\nfloat GammaEncode(float x) {return pow(x, 1.0 / 2.2);}\nvec2 GammaEncode(vec2 x) {return pow(x, vec2(1.0 / 2.2));}\nvec3 GammaEncode(vec3 x) {return pow(x, vec3(1.0 / 2.2));}\nvec4 GammaEncode(vec4 x) {return pow(x, vec4(1.0 / 2.2));}\n\n#define FUNC4_FLOAT(f)\t\t\t\t\t\t\t\\\nvec2 f(vec2 v) {return vec2(f(v.x ), f(v.y ));}\t\\\nvec3 f(vec3 v) {return vec3(f(v.xy), f(v.z ));}\t\\\nvec4 f(vec4 v) {return vec4(f(v.xy), f(v.zw));}\t\\\n\n#define FUNC4_UINT(f)\t\t\t\t\t\t\t\t\\\nuvec2 f(uvec2 v) {return uvec2(f(v.x ), f(v.y ));}\t\\\nuvec3 f(uvec3 v) {return uvec3(f(v.xy), f(v.z ));}\t\\\nuvec4 f(uvec4 v) {return uvec4(f(v.xy), f(v.zw));}\t\\\n    \n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//=============================================================================================================================================//\n// \"Hash without Sine\"        | https://www.shadertoy.com/view/4djSRW \n//  Created by David Hoskins  | \n//  used under CC BY-SA 4.0   | https://creativecommons.org/licenses/by-sa/4.0/             \n//  reformatted from original |              \n//---------------------------------------------------------------------------------------------------------------------------------------------//\n\n// Use this for integer stepped ranges, ie Value-Noise/Perlin noise functions.\n#define HASHSCALE1 .1031\n#define HASHSCALE3 vec3(.1031, .1030, .0973)\n#define HASHSCALE4 vec4(1031, .1030, .0973, .1099)\n\nfloat Hash11I(float p ){vec3 p3 = fract(vec3(p     ) * HASHSCALE1); p3 += dot(p3, p3.yzx  + 19.19); return fract((p3.x    + p3.y   ) * p3.z   );}\nfloat Hash12I(vec2  p ){vec3 p3 = fract(vec3(p.xyx ) * HASHSCALE1); p3 += dot(p3, p3.yzx  + 19.19); return fract((p3.x    + p3.y   ) * p3.z   );}\nfloat Hash13I(vec3  p3){     p3 = fract(    (p3    ) * HASHSCALE1); p3 += dot(p3, p3.yzx  + 19.19); return fract((p3.x    + p3.y   ) * p3.z   );}\nvec2  Hash21I(float p ){vec3 p3 = fract(vec3(p     ) * HASHSCALE3); p3 += dot(p3, p3.yzx  + 19.19); return fract((p3.xx   + p3.yz  ) * p3.zy  );}\nvec2  Hash22I(vec2  p ){vec3 p3 = fract(vec3(p.xyx ) * HASHSCALE3); p3 += dot(p3, p3.yzx  + 19.19); return fract((p3.xx   + p3.yz  ) * p3.zy  );}\nvec2  Hash23I(vec3  p3){     p3 = fract(    (p3    ) * HASHSCALE3); p3 += dot(p3, p3.yzx  + 19.19); return fract((p3.xx   + p3.yz  ) * p3.zy  );}\nvec3  Hash31I(float p ){vec3 p3 = fract(vec3(p     ) * HASHSCALE3); p3 += dot(p3, p3.yzx  + 19.19); return fract((p3.xxy  + p3.yzz ) * p3.zyx );}\nvec3  Hash32I(vec2  p ){vec3 p3 = fract(vec3(p.xyx ) * HASHSCALE3); p3 += dot(p3, p3.yxz  + 19.19); return fract((p3.xxy  + p3.yzz ) * p3.zyx );}\nvec3  Hash33I(vec3  p3){     p3 = fract(    (p3    ) * HASHSCALE3); p3 += dot(p3, p3.yxz  + 19.19); return fract((p3.xxy  + p3.yxx ) * p3.zyx );}\nvec4  Hash41I(float p ){vec4 p4 = fract(vec4(p     ) * HASHSCALE4); p4 += dot(p4, p4.wzxy + 19.19); return fract((p4.xxyz + p4.yzzw) * p4.zywx);}\nvec4  Hash42I(vec2  p ){vec4 p4 = fract(vec4(p.xyxy) * HASHSCALE4); p4 += dot(p4, p4.wzxy + 19.19); return fract((p4.xxyz + p4.yzzw) * p4.zywx);}\nvec4  Hash43I(vec3  p ){vec4 p4 = fract(vec4(p.xyzx) * HASHSCALE4); p4 += dot(p4, p4.wzxy + 19.19); return fract((p4.xxyz + p4.yzzw) * p4.zywx);}\nvec4  Hash44I(vec4  p4){     p4 = fract(    (p4    ) * HASHSCALE4); p4 += dot(p4, p4.wzxy + 19.19); return fract((p4.xxyz + p4.yzzw) * p4.zywx);}\n \n#undef HASHSCALE1\n#undef HASHSCALE3\n#undef HASHSCALE4\n\n//---------------------------------------------------------------------------------------------------------------------------------------------//\n\n// For smaller input rangers like audio tick or 0-1 UVs use these...\n#define HASHSCALE1 443.8975\n#define HASHSCALE3 vec3(443.897, 441.423, 437.195)\n#define HASHSCALE4 vec4(443.897, 441.423, 437.195, 444.129)\n\nfloat Hash11F(float p ){vec3 p3 = fract(vec3(p     ) * HASHSCALE1); p3 += dot(p3, p3.yzx  + 19.19); return fract((p3.x    + p3.y   ) * p3.z   );}\nfloat Hash12F(vec2  p ){vec3 p3 = fract(vec3(p.xyx ) * HASHSCALE1); p3 += dot(p3, p3.yzx  + 19.19); return fract((p3.x    + p3.y   ) * p3.z   );}\nfloat Hash13F(vec3  p3){     p3 = fract(    (p3    ) * HASHSCALE1); p3 += dot(p3, p3.yzx  + 19.19); return fract((p3.x    + p3.y   ) * p3.z   );}\nvec2  Hash21F(float p ){vec3 p3 = fract(vec3(p     ) * HASHSCALE3); p3 += dot(p3, p3.yzx  + 19.19); return fract((p3.xx   + p3.yz  ) * p3.zy  );}\nvec2  Hash22F(vec2  p ){vec3 p3 = fract(vec3(p.xyx ) * HASHSCALE3); p3 += dot(p3, p3.yzx  + 19.19); return fract((p3.xx   + p3.yz  ) * p3.zy  );}\nvec2  Hash23F(vec3  p3){     p3 = fract(    (p3    ) * HASHSCALE3); p3 += dot(p3, p3.yzx  + 19.19); return fract((p3.xx   + p3.yz  ) * p3.zy  );}\nvec3  Hash31F(float p ){vec3 p3 = fract(vec3(p     ) * HASHSCALE3); p3 += dot(p3, p3.yzx  + 19.19); return fract((p3.xxy  + p3.yzz ) * p3.zyx );}\nvec3  Hash32F(vec2  p ){vec3 p3 = fract(vec3(p.xyx ) * HASHSCALE3); p3 += dot(p3, p3.yxz  + 19.19); return fract((p3.xxy  + p3.yzz ) * p3.zyx );}\nvec3  Hash33F(vec3  p3){     p3 = fract(    (p3    ) * HASHSCALE3); p3 += dot(p3, p3.yxz  + 19.19); return fract((p3.xxy  + p3.yxx ) * p3.zyx );}\nvec4  Hash41F(float p ){vec4 p4 = fract(vec4(p     ) * HASHSCALE4); p4 += dot(p4, p4.wzxy + 19.19); return fract((p4.xxyz + p4.yzzw) * p4.zywx);}\nvec4  Hash42F(vec2  p ){vec4 p4 = fract(vec4(p.xyxy) * HASHSCALE4); p4 += dot(p4, p4.wzxy + 19.19); return fract((p4.xxyz + p4.yzzw) * p4.zywx);}\nvec4  Hash43F(vec3  p ){vec4 p4 = fract(vec4(p.xyzx) * HASHSCALE4); p4 += dot(p4, p4.wzxy + 19.19); return fract((p4.xxyz + p4.yzzw) * p4.zywx);}\nvec4  Hash44F(vec4  p4){     p4 = fract(    (p4    ) * HASHSCALE4); p4 += dot(p4, p4.wzxy + 19.19); return fract((p4.xxyz + p4.yzzw) * p4.zywx);}\n\n#undef HASHSCALE1\n#undef HASHSCALE3\n#undef HASHSCALE4\n\n//=============================================================================================================================================//\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n\nstruct Cam\n{\n\tvec3 Front, Right, Up;\n\tfloat Aspect;\n\tfloat AxisLen;\t\n};\n\nCam NewCam(vec2 ang, float fov, float aspect)\n{\n    Cam cam;\n\n    float sinPhi   = sin(ang.x);\n    float cosPhi   = cos(ang.x);\n    float sinTheta = sin(ang.y);\n    float cosTheta = cos(ang.y);    \n\n    cam.Front = vec3(cosPhi * cosTheta, \n                              sinTheta, \n                     sinPhi * cosTheta);\n\n    cam.Right = vec3(-sinPhi, 0.0, cosPhi);\n    cam.Up    = cross(cam.Right, cam.Front);\n\n    cam.Aspect = aspect;\n    cam.AxisLen = aspect * tan(Pi05 - fov * 0.5);\n\n    return cam;\n}\n\n// tc [-1..1]\nvec3 NewRay(Cam cam, vec2 tc)\n{\n    tc.x *= cam.Aspect;\n\n    vec3 imgPos = cam.Front * cam.AxisLen + (cam.Right * tc.x + cam.Up * tc.y);\n    \n    vec3 dir = normalize(imgPos);\n\n    return dir;\n}\n\n\n/*\nIN:\n\trp\t\t: ray start position\n\trd\t\t: ray direction (normalized)\n\t\n\tcp\t\t: cube position\n\tcth\t\t: cube thickness (cth = 0.5 -> unit cube)\n\t\nOUT:\n\tt\t\t: distances to intersection points (negative if in backwards direction)\n\nEXAMPLE:\t\n\tvec2 t;\n\tfloat hit = Intersect_Ray_Cube(pos, dir, vec3(0.0), vec3(0.5), OUT t);\n*/\nfloat Intersect_Ray_Cube(\nvec3 rp, vec3 rd, \nvec3 cp, vec3 cth, \nout vec2 t)\n{\t\n\trp -= cp;\n\t\n\tvec3 m = 1.0 / -rd;\n\tvec3 o = If(lessThan(rd, vec3(0.0)), -cth, cth);\n\t\n\tvec3 uf = (rp + o) * m;\n\tvec3 ub = (rp - o) * m;\n\t\n\tt.x = max(uf.x, max(uf.y, uf.z));\n\tt.y = min(ub.x, min(ub.y, ub.z));\n\t\n\t// if(ray start == inside cube) \n\tif(t.x < 0.0 && t.y > 0.0) {t.xy = t.yx;  return 1.0;}\n\t\n\treturn t.y < t.x ? 0.0 : (t.x > 0.0 ? 1.0 : -1.0);\n}\n\n/*\n[...]\n\nOUT:\n\tn0 : normal for t.x\n\tn1 : normal for t.y\n\nEXAMPLE:\t\n\tvec2 t; vec3 n0, n1;\n\tfloat hit = Intersect_Ray_Cube(pos, dir, vec3(0.0), vec3(0.5), OUT t, n0, n1);\n*/\nfloat Intersect_Ray_Cube(\nvec3 rp, vec3 rd, \nvec3 cp, vec3 cth, \nout vec2 t, out vec3 n0, out vec3 n1)\n{\t\n\trp -= cp;\n\t\n\tvec3 m = 1.0 / -rd;\n    vec3 os = If(lessThan(rd, vec3(0.0)), vec3(1.0), vec3(-1.0));\n    //vec3 os = sign(-rd);\n\tvec3 o = -cth * os;\n\t\n    \n\tvec3 uf = (rp + o) * m;\n\tvec3 ub = (rp - o) * m;\n\t\n\t//t.x = max(uf.x, max(uf.y, uf.z));\n\t//t.y = min(ub.x, min(ub.y, ub.z));\n\t\n    if(uf.x > uf.y) {t.x = uf.x; n0 = vec3(os.x, 0.0, 0.0);} else \n                    {t.x = uf.y; n0 = vec3(0.0, os.y, 0.0);}\n    if(uf.z > t.x ) {t.x = uf.z; n0 = vec3(0.0, 0.0, os.z);}\n    \n    if(ub.x < ub.y) {t.y = ub.x; n1 = vec3(os.x, 0.0, 0.0);} else \n                    {t.y = ub.y; n1 = vec3(0.0, os.y, 0.0);}\n    if(ub.z < t.y ) {t.y = ub.z; n1 = vec3(0.0, 0.0, os.z);}\n    \n    \n\t// if(ray start == inside cube) \n\tif(t.x < 0.0 && t.y > 0.0) \n    {\n        t.xy = t.yx;  \n        \n        vec3 n00 = n0;\n        n0 = n1;\n        n1 = n00;\n        \n        return 1.0;\n    }\n\t\n\treturn t.y < t.x ? 0.0 : (t.x > 0.0 ? 1.0 : -1.0);\n}\n\n/*\nIN:\n\trp\t\t: ray start position\n\trd\t\t: ray direction (normalized)\n\t\n\tsp2\t\t: sphere position\n\tsr2\t\t: sphere radius squared\n\t\nOUT:\n\tt\t\t: distances to intersection points (negative if in backwards direction)\n\nEXAMPLE:\t\n\tvec2 t;\n\tfloat hit = Intersect_Ray_Sphere(pos, dir, vec3(0.0), 1.0, OUT t);\n*/\nfloat Intersect_Ray_Sphere(\nvec3 rp, vec3 rd, \nvec3 sp, float sr2, \nout vec2 t)\n{\t\n\trp -= sp;\n\t\n\tfloat a = dot(rd, rd);\n\tfloat b = 2.0 * dot(rp, rd);\n\tfloat c = dot(rp, rp) - sr2;\n\t\n\tfloat D = b*b - 4.0*a*c;\n\t\n\tif(D < 0.0) return 0.0;\n\t\n\tfloat sqrtD = sqrt(D);\n\t// t = (-b + (c < 0.0 ? sqrtD : -sqrtD)) / a * 0.5;\n\tt = (-b + vec2(-sqrtD, sqrtD)) / a * 0.5;\n\t\n\t// if(start == inside) ...\n\tif(c < 0.0) t.xy = t.yx;\n\n\t// t.x > 0.0 || start == inside ? infront : behind\n\treturn t.x > 0.0 || c < 0.0 ? 1.0 : -1.0;\n}\n\nvec2 CmplxMul(vec2 c0, vec2 c1)\n{\n    return vec2(c0.x*c1.x - c0.y*c1.y, c0.y*c1.x + c0.x*c1.y);\n}\n\nvec2 CmplxMul(vec2 c0, float ang)\n{\n    vec2 c1 = vec2(cos(ang), sin(ang));\n    \n    return vec2(c0.x*c1.x - c0.y*c1.y, c0.y*c1.x + c0.x*c1.y);\n}\n\nfloat lerp(float a, float b, float l) {return a + (b - a) * l;}\nvec2  lerp(vec2  a, vec2  b, vec2  l) {return a + (b - a) * l;}\nvec3  lerp(vec3  a, vec3  b, vec3  l) {return a + (b - a) * l;}\nvec4  lerp(vec4  a, vec4  b, vec4  l) {return a + (b - a) * l;}\n\n\nfloat SCurveC1(float x) {return x*x*(3.-2.*x);}\nFUNC4_FLOAT(SCurveC1)\n\nfloat SCurveC2(float x){ return ((x * 6.0 - 15.0) * x + 10.0) * x*x*x;}\nFUNC4_FLOAT(SCurveC2)\n\n    \n/////////////////////////////////////////////////////////////////////////////////////////////////////\n//=================================================================================================//\n\nfloat VNoise(vec3 p, float aniS, float aniP)\n{\n    vec3 ip = floor(p);\n    vec3 fp = p - ip;\n    \n    fp = SCurveC1(fp);\n    p = ip + fp;\n    \n    const float texDim = 64.0;\n    const vec2 prime = vec2(53.0, 41.0);// primes < texDim\n    \n    const float txlDim = 1.0 / texDim;\n    const vec2 pmul = prime * txlDim;\n    const float o0 = 0.5 * txlDim;\n    const vec2 o1 = (prime + 0.5) * txlDim;\n\n    vec2 tex = p.xz * txlDim + ip.y * pmul;\n\n    vec4 n0 = textureLod(iChannel2, tex + o0, 0.0);\n\tvec4 n1 = textureLod(iChannel2, tex + o1, 0.0);\n    \n    //float l0 = textureLod(iChannel1, (p.xz + ip.y         * prime + 0.5) * txlDim, 0.0).x;\n\t//float l1 = textureLod(iChannel1, (p.xz + (ip.y + 1.0) * prime + 0.5) * txlDim, 0.0).x;\n    \n    \n    vec4 n = mix(n0, n1, fp.y);\n    \n    float r = n.z;\n    r = lerp(n.z, n.w, sin(Time * aniS + n.y*Pi2 + aniP)*.5+.5);\n    \n    return r * 2.0 - 1.0;\n}\n\n\nvec3 VNoise3(vec3 p, vec3 aniS)\n{\n    vec3 ip = floor(p);\n    vec3 fp = p - ip;\n    \n    fp = SCurveC1(fp);\n    p = ip + fp;\n    \n    const float texDim = 64.0;\n    const vec2 prime = vec2(53.0, 41.0);// primes < texDim\n    \n    const float txlDim = 1.0 / texDim;\n    const vec2 pmul = prime * txlDim;\n    const float o0 = 0.5 * txlDim;\n    const vec2 o1 = (prime + 0.5) * txlDim;\n\n    vec2 tex = p.xz * txlDim + ip.y * pmul;\n\n    vec4 n0 = textureLod(iChannel2, tex + o0, 0.0);\n\tvec4 n1 = textureLod(iChannel2, tex + o1, 0.0);\n    \n    //float l0 = textureLod(iChannel1, (p.xz + ip.y         * prime + 0.5) * txlDim, 0.0).x;\n\t//float l1 = textureLod(iChannel1, (p.xz + (ip.y + 1.0) * prime + 0.5) * txlDim, 0.0).x;\n    \n    vec4 n = mix(n0, n1, fp.y);\n    \n    //float r = n.z;\n    vec3 r = lerp(n.xyz, n.zwx, sin(Time * aniS + n.wzy*Pi2)*.5+.5);\n\n    return r * 2.0 - 1.0;\n}\n\nvec4 VNoise4(vec3 p, vec4 aniS)\n{\n    vec3 ip = floor(p);\n    vec3 fp = p - ip;\n    \n    #if 1\n    fp = SCurveC1(fp);\n    p = ip + fp;\n    #endif\n    \n   #if 1\n    const float texDim = 64.0;\n    const vec2 prime = vec2(53.0, 41.0);// primes < texDim\n    \n    const float txlDim = 1.0 / texDim;\n    const vec2 pmul = prime * txlDim;\n    const float o0 = 0.5 * txlDim;\n    const vec2 o1 = (prime + 0.5) * txlDim;\n\n    vec2 tex = p.xz * txlDim + ip.y * pmul;\n\n    vec4 n0 = textureLod(iChannel2, tex + o0, 0.0);\n\tvec4 n1 = textureLod(iChannel2, tex + o1, 0.0);\n    \n    //float l0 = textureLod(iChannel1, (p.xz + ip.y         * prime + 0.5) * txlDim, 0.0).x;\n\t//float l1 = textureLod(iChannel1, (p.xz + (ip.y + 1.0) * prime + 0.5) * txlDim, 0.0).x;\n    \n    vec4 n = mix(n0, n1, fp.y);\n   #else\n    vec4 n = textureLod(iChannel1, p / 32.0, 0.0);// y looks worse?\n    n *= mix(n, vec4(1.0), 0.5);\n   #endif\n    //float r = n.z;\n    //vec4 r = lerp(n.xyzw, n.zwxy, sin(Time * aniS + n.yzwx*Pi2)*.5+.5);\n    //vec4 r = lerp(n.xyzw, n.zxwy, sin(Time * aniS + n.wzyx*Pi2)*.5+.5);\n    vec4 r = lerp(n.xyzw, 1.0-n.wzyx, sin(Time * aniS + n.zxwy*Pi2)*.5+.5);\n   \n    return r * 2.0 - 1.0;\n}\n//=================================================================================================//\n/////////////////////////////////////////////////////////////////////////////////////////////////////\n\n\nfloat Fbm(vec3 p, vec3 off)\n{\n    const float count = 4.0;\n\n    const float ang = Pi * (3.0 - sqrt(5.0));\n    const vec2 rot = vec2(cos(ang), sin(ang));\n    \n    float res = 0.0;\n    float accu_w = 0.0;\n    float w = 1.0;\n    float aniS = 0.8;\n    float aniP = 0.0;\n    \n    for(float i = 0.0; i < count; ++i)\n    {\n        float v = VNoise(p, aniS, aniP);\n        \n        res += v * w;\n        \n        accu_w += w;\n        \n        aniS *= 1.7;\n        aniP += ang;\n        w *= 0.51;\n        p *= 2.2;\n        p.xy = CmplxMul(p.xy, rot);\n        p = p.yzx;\n        p += off;\n    }\n    \n    res /= accu_w;\n    \n    return res;\n}\n\nvec3 Fbm2(vec3 p, vec3 off)\n{\n    const float count = 4.0;\n\n    const float ang = Pi * (3.0 - sqrt(5.0));\n    const vec2 rot = vec2(cos(ang), sin(ang));\n    \n    vec3 res = vec3(0.0);\n    float accu_w = 0.0;\n    float w = 1.0;\n    float aniS = .9;\n    \n    for(float i = 0.0; i < count; ++i)\n    {\n        vec3 v = VNoise3(p, vec3(0.9, 1.0, 1.1) * aniS);\n        \n        res += v * w;\n        \n        accu_w += w;\n        \n        aniS *= 1.8;        \n        w *= 0.51;\n        p *= 2.2;\n        p.xy = CmplxMul(p.xy, rot);\n        p = p.yzx;\n        p += off;\n    }\n    \n    res /= accu_w;\n    \n    return res;\n}\n\nvec4 Fbm3(vec3 p, vec3 off)\n{\n    const float count = 4.0;\n\n    const float ang = Pi * (3.0 - sqrt(5.0));\n    const vec2 rot = vec2(cos(ang), sin(ang));\n    \n    vec4 res = vec4(0.0);\n    \n    float accu_w = 0.0;\n    float w = 1.0;\n    float aniS = 1.2;\n    \n    #if 1\n    p += ((VNoise4(p.yzx+vec3(0.,1.,0.)*Time*0., vec4(0.8, 0.9, 1.1, 1.2) * aniS).yzx) - 0.5) * 0.3;\n    p.xy = CmplxMul(p.xy, rot);\n    p = p.yzx;\n    p += off;\n    #endif\n    \n    for(float i = 0.0; i < count; ++i)\n    {\n        #if 0\n        p.x -= Time * w * 0.3; \n        #endif\n        \n        vec4 v = VNoise4(p, vec4(0.8, 0.9, 1.1, 1.2) * aniS);\n        //v.yz = abs(v.yz) - 0.5;\n        \n        res += v * w; \n        accu_w += w;\n        \n\n        #if 1\n        vec3 po = v.yzw;\n        #else\n        vec3 po = res.yzw;\n        #endif\n        \n        #if 0\n        p += (abs(po) - 0.5) * 0.5;\n        #else\n        p += (po) * 0.5;\n\t\t#endif\n        \n        //res.yz = res.zy;\n        res = res.yzwx;\n        \n        aniS *= 1.9;        \n        w *= 0.5;\n        p *= 2.2;\n        p.xy = CmplxMul(p.xy, rot);\n        p = p.yzx;\n        p += off;\n    }\n    \n    res /= accu_w;\n    \n    return res;\n}\n\nvec4 Fbm32(vec3 p, vec3 off)\n{\n    const float count = 4.0;\n\n    const float ang = Pi * (3.0 - sqrt(5.0));\n    const vec2 rot = vec2(cos(ang), sin(ang));\n    \n    vec4 res = vec4(0.0);\n    \n    float accu_w = 0.0;\n    vec2 w = vec2(1.0);\n    float aniS = 1.2;\n    \n    #if 1\n    res.yzw = VNoise4(p, vec4(0.8, 0.9, 1.1, 1.2) * aniS).wyz * 0.5;\n    p.xy = CmplxMul(p.xy, rot);\n    p = p.yzx;\n    p += off;\n    #endif\n    \n    for(float i = 0.0; i < count; ++i)\n    {\n        #if 1\n        vec3 p2 = p + ((res.yzw*res.zwy) - 0.)*4.0;\n        #else\n        vec3 p2 = p + (abs(res.yzw) - 0.5)*2.5;\n        #endif\n        \n        p2.z -= Time * 0.2;//*(i+1.0);\n        \n        vec4 v = VNoise4(p2, vec4(0.8, 0.9, 1.1, 1.2) * aniS);\n        \n        w.y *= 0.7;\n        \n        res += v * w.xyyy; \n        accu_w += w.x;\n        \n        //res.yz = res.zy;\n        res = res.xwyz;\n        \n        aniS *= 1.9;        \n        w.x *= 0.5;\n        p *= 2.4;\n        p.xy = CmplxMul(p.xy, rot);\n        p = p.yzx;\n        p += off;\n    }\n    \n    res /= accu_w;\n    \n    return res;\n}\n\n\nfloat EvalNoise(vec3 p)\n{\n    float n = VNoise(p*8.0, 2.0, 0.0);\n    n = Fbm(p * 2.0, vec3(0.0));\n\n    n = n*.5+.5;\n    \n    p *= 1.4;\n    \n    vec3 o;\n    \n    #if 0\n    \n    o.x = Fbm(vec3(CmplxMul(p.zy, Pi*0.23), p.x) + vec3(0.45, 0.13, 0.11), vec3(0.37, 0.53, 0.18));\n    o.y = Fbm(vec3(CmplxMul(p.yx, Pi*0.77), p.z) + vec3(0.32, 0.87, 0.83), vec3(0.78, 0.14, 0.55));    \n    o.z = Fbm(vec3(CmplxMul(p.xz, Pi*0.54), p.y) + vec3(0.84, 0.16, 0.28), vec3(0.63, 0.97, 0.22));\n        \n    o = (abs(o)*2.0-1.0) * 0.5;\n    n = Fbm(p + o * 1.4, vec3(0.49, 0.91, 0.36));\n    \n    #elif 0\n    \n    o = Fbm2(vec3(CmplxMul(p.xz, Pi*0.54), p.y) + vec3(0.84, 0.16, 0.28), vec3(0.63, 0.97, 0.22));    \n        \n    o = (abs(o)*2.0-1.0) * 0.5;\n    n = Fbm(p + o * 1.4, vec3(0.49, 0.91, 0.36));\n    \n    #else\n    \n    n = Fbm32(p*1.4, vec3(0.49, 0.91, 0.36)).x;\n    \n    #endif\n\n    \n    n = n*.5+.5;\n    \n    #if 1\n    //n = clamp01(n * 1.1);\n    //n=SCurveC1(n);\n    n=SCurveC2(n);\n    n=SCurveC2(n);\n    n=SCurveC2(n);\n    //n*=n;\n    //n*=n;    \n    #endif\n    \n    return n;\n}\n\nfloat SchlickPdf(float cosTheta, float k)\n{\t\n\tfloat t0 = 1.0 - k*k;\n\tfloat t1 = 1.0 - k * cosTheta;\n\t\n\treturn t0 / (t1*t1);\n\t// return t0 / max(1.0e-4, t1*t1);\n}\n\nvoid LenDir(vec3 vec, out float len, out vec3 dir)\n{\n    float lenSqr = dot(vec, vec);\n    \n    float lenRcp = inversesqrt(lenSqr);\n    \n    len = lenSqr * lenRcp;\n    \n    dir = vec * lenRcp;\n}\n\nvoid LenDir(vec3 vec, out float lenSqr, out float len, out vec3 dir)//[WIP] fix nan\n{\n    lenSqr = dot(vec, vec);\n    \n    float lenRcp = inversesqrt(lenSqr);\n    \n    len = lenSqr * lenRcp;\n    \n    dir = vec * lenRcp;\n}\n\n\nfloat EvalSceneCol(\n    vec3 rp, vec3 rd, vec3 light, float noff, bool right)\n{\n    float col = 0.0;\n\n        vec2 t; vec3 n; vec3 a;\n        float hit = Intersect_Ray_Sphere(rp, rd, vec3(0.0), 1.0, OUT t);\n\n\n        if(hit > 0.0)// SPHERE ----------------------------------------------------------------------\n        {\n            t.y = max(0.0, t.y);\n            t.xy = vec2(min(t.x, t.y), max(t.x, t.y));\n\n            vec3 p = rp + rd * t.x; \n\n            const float count = 16.0;\n            const float stepS = 1.0 / (count - .0);\n\n            float o_max = 0.02;// maximal scattering coefficient\n            float sliceTh = (t.y - t.x) / count;\n            float oc = 0.0;\n            float r = 0.0;\n\n            for(float i = 0.0; i < count; ++i)\n            {\n                vec3 p = rp + rd * lerp(t.x, t.y, (i+0.5+noff) * stepS);\t\t\t\t\n                \n \t\t\t\tfloat n = 1.0;\n                n = EvalNoise(p);\n                \n                #ifdef MAKE_VOLUME_PARTS_HOMOGENEOUS\n                n = dot(p,p)>0.9 || p.y<-0.5 ? 1.0 : n;\n\t\t\t\t#endif\n                \n                float o = o_max;\n                o *= n;\n\n                // integrate scattering prob density along light path seg assuming const o\n                // dp = Integrate[o Exp[-(oc + o x)], {x, 0, sliceTh}]\n                float dp = exp(-oc) - exp(-oc - o * sliceTh);\n                \n                vec3 lVec = light*0.9 - p;\n                \n                float lSqrLen, lLen; vec3 lDir;\n                LenDir(lVec, OUT lSqrLen, lLen, lDir);\n                \n                #if 0\n                // march towards light; doesnt improve quali here\n                float ocL = 0.0;\n                float sliceThL = lLen / count;\n                \n                for(float j = 0.0; j < count; ++j)\n                {\n                    vec3 pL = p + lDir * (j+0.5+noff) * sliceThL;\n                    \n                    float n = 1.0;\n                \tn = EvalNoise(pL);\n                    \n                    #ifdef MAKE_VOLUME_PARTS_HOMOGENEOUS\n                    n = dot(pL, pL)>0.9 || pL.y<-0.5 ? 1.0 : n;\n                    #endif\n                    \n                    ocL += n * o_max * sliceThL;\n                }               \n                #else\n                float ocL = o_max * 0.5;\n                #endif\n                \n                float l = exp(-lLen * ocL);\n                l /= lSqrLen;\n                l *= SchlickPdf(dot(rd, lDir), 0.6);\n\n                r += dp*l*8.0;\n                \n                oc += o * sliceTh;\n            }\n\n            //r /= count;\n            //r *= t.y - t.x;\n\n            col = r;\n        }\n        else\n        {\n            col = 0.0;           \n        }\n\n    return col;\n}\n\nvec3 Hue_to_RGB(float hue)\n{\n    float H6 = hue * 6.0;\n    \n\tfloat R =       abs(H6 - 3.0) - 1.0;\n\tfloat G = 2.0 - abs(H6 - 2.0);\n\tfloat B = 2.0 - abs(H6 - 4.0);\n    \n\treturn clamp(vec3(R, G, B), 0.0, 1.0);\n}\n\nvec3 HSV_to_RGB(vec3 hsv)\n{\n    return (Hue_to_RGB(hsv.x) * hsv.y + vec3(1.0 - hsv.y)) * hsv.z;\n}\n\n// s [-1..1]\nfloat Sample_Triangle(float s) \n{ \n    float v = 1.0 - sqrt(1.0 - abs(s));// NEEDS '1.0 - abs(s)' instead of just 'abs(s)', breaks correlation of bnoise otherwise\n    \n    return s < 0.0 ? -v : v; \n}\n\n\nvoid mainImage( out vec4 outCol, in vec2 uv0 )\n{\n    vec3 col = vec3(0.0);\n        \n    vec2 uv = uv0.xy - 0.5;\n    \n    vec2 PixelCount = iResolution.xy;  \n    bool right = false;\n    \n    #ifdef MAX_RESOLUTION\n    const vec2 maxRes = MAX_RESOLUTION;\n    uv -= max(vec2(0.), PixelCount - maxRes) * 0.5;\n    \n    if(uv.x < 0.0 || uv.x > maxRes.x || uv.y < 0.0 || uv.y > maxRes.y) {outCol = vec4(0.0); return;}\n    \n    PixelCount = min(PixelCount, maxRes);\n    #endif\n    \n    #ifdef RENDER_STEREO\n    PixelCount *= vec2(0.5, 1.0);\n    \n    right = uv.x >= PixelCount.x;\n    if(right) uv.x -= PixelCount.x;\n    #endif\n    \n    #ifdef USE_DITHERING\n    #ifdef ANIMATE_DITHERING\n    vec2 noiseOff = Hash21I(float(iFrame));\n    #endif\n    \n    #if 1\n    \n        #if 0\n        int n = iFrame/1;\n        vec2 off = fract(vec2(n*12664745, n*9560333)/16777216.0) * 1024.0;\n        //n = (iFrame * 7) % 9; off = vec2((n) % 3, (n) / 3);\n        //n = (iFrame * 17) % 25; off = vec2((n) % 5, (n) / 5);    \n        //n = (iFrame * 13) % 49; off = vec2((n) % 7, (n) / 7);\n\n        uv0 += floor(off);\n        #endif\n    \n    float v = texelFetch(iChannel3, ivec2(uv0) % 1024, 0).x;\n    \n  //  v = fract(52.9829189*fract(0.06711056*uv0.x + 0.00583715*uv0.y));\n  //  v = fract(uv0.x*0.7548776662 + uv0.y*0.56984029);\n//    if(v>0.5)v*=2.0;else v=2.0-2.0*v;\n    \n        #if 1\n        v = v * (255.0/256.0);//[0..1] -> [0..1)  \n        float o = float(iFrame & 255);// animated over time\n        float gr = 0.61803398875;\n        //gr = sqrt(1.0 / 5.0);\n        //gr = 0.5;\n        //gr = 0.5 - 0.5/256.0;\n        v = fract(v + (gr * o));\n        v = (v > 0.5 ? 1.0 - v : v) * 2.0;\n        #endif\n    \n    float noise = v * 2.0 - 1.0;\n    //if(iFrame%2==1)noise=-noise;\n    noise = Sample_Triangle(noise);\n    #else\n    float noise = textureLod(iChannel1, (uv0)/iResolution.xy + noiseOff, 0.0).x;\n\t#endif\n    \n    #else\n    float noise = 0.0;\n    #endif\n    \n    #ifdef NEGATE_DITHERING_NOISE_ON_EVERY_SECOND_FRAME\n    if(fract(Frame * 0.5) == 0.0) noise = -noise;    \n    #endif\n    \n    #if 0\n    outCol=vec4(noise*0.5+0.5);return;// show noise\n    #endif\n    \n    vec4 mouseAccu = texelFetch(iChannel0, ivec2(1, 0), 0); \n    vec4 wasdAccu  = texelFetch(iChannel0, ivec2(2, 0), 0); \n    \n    #if 0\n    // debug iResolutionLast\n    vec4 iResolutionLast= texelFetch(iChannel0, ivec2(3, 0), 0);\n    \n    if(iResolutionLast.z == 0.0 && iResolutionLast.w == 0.0) {outCol = vec4(0.1); return;}\n    #endif\n    \n    vec2 lightAng = vec2(Pi * 0.0, Pi * 0.5);\n    lightAng.x += (wasdAccu.y - wasdAccu.w) * 0.06; \n    lightAng.y += (wasdAccu.x - wasdAccu.z) * 0.04;    \n    \n    #ifdef ANIMATE_LIGHT\n    lightAng.x += Time * 0.57;\n    lightAng.y += Time * 0.39;\n    #endif\n    \n    vec3 light = AngToVec(lightAng);\n    \n    vec2 ang = vec2(0.0, 0.1);\n    ang += mouseAccu.xy * 0.008;\n    \n    #ifdef ANIMATE_CAMERA\n    ang.x += Time * 0.3;\n    //ang.y -= (sin(Time-Pi05)*.5+.5) * 0.2;\n    #endif\n    \n    Cam cam = NewCam(ang, Pi * 0.33, PixelCount.x / PixelCount.y);\n    vec3 cpos = -cam.Front * .0;\n    #ifdef RENDER_STEREO\n    cpos = -cam.Front * (exp2(1.25 + mouseAccu.w * 0.02));\n    #else\n    cpos = -cam.Front * (exp2(1.8 + mouseAccu.w * 0.02));\n    #endif\n    \n    #ifdef RENDER_STEREO\n    cpos += 0.2 * cam.Right * (right ? -1.0 : 1.0);\n    //if(right) noise = -noise;\n    #endif\n    \n    vec2 tex = uv.xy / PixelCount;\n    vec2 tex21 = tex * 2.0 - vec2(1.0);\n             \n    vec3 rd = NewRay(cam, tex21);\n\n    col = vec3(EvalSceneCol(cpos, rd, light*0.9, noise, right));    \n\n    #ifdef ANIMATE_LIGHTCOL\n    col *= HSV_to_RGB(vec3(fract(0.6 - Time*0.02), 0.5, 1.0))*1.5;\n    #else\n    col *= vec3(0.5, 0.7, 1.0)*1.5;\n    #endif\n    \n\t#if 0\n    col = mix(col, 1.0 - exp2(-col * 1.5), 0.75);\n    #endif\n    \n    col = Tonemap_ACESFitted(col);\n    \n    //noise = textureLod(iChannel1, (uv0)/iResolution.xy+0.5, 0.0).x;\n    //col.rgb = vec3(noise);\n    //if(col.x > 1.0) col = vec3(1.0, 0.0, 1.0);\n    //if(col.x >\n    //col = vec3(noise);\n\toutCol = vec4(sRGB_EOTF(clamp01(col)), 1.0);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\n/*\ncamera controls via mouse + shift key\n*/\n\n#define KEY_LEFT  37\n#define KEY_UP    38\n#define KEY_RIGHT 39\n#define KEY_DOWN  40\n\n#define KEY_SHIFT 0x10\n#define KEY_A 0x41\n#define KEY_D 0x44\n#define KEY_S 0x53\n#define KEY_W 0x57\n\n#define KeyboardC iChannel1\n\nfloat ReadKey(int keyCode) {return texelFetch(KeyboardC, ivec2(keyCode, 0), 0).x;}\n\n\nvoid mainImage( out vec4 col, in vec2 uv0 )\n{  \n    col = vec4(0.0);\n    \n    vec2 uv = uv0 - 0.5;\n    \n    \n    vec4 iMouseLast     = texelFetch(iChannel0, ivec2(0, 0), 0);\n    vec4 iMouseAccuLast = texelFetch(iChannel0, ivec2(1, 0), 0);\n    vec4 wasdAccuLast   = texelFetch(iChannel0, ivec2(2, 0), 0);\n    vec4 iResolutionLast= texelFetch(iChannel0, ivec2(3, 0), 0);\n    \n\n    bool shift = ReadKey(KEY_SHIFT) != 0.0;\n    \n    float kW = ReadKey(KEY_W);\n    float kA = ReadKey(KEY_A);\n    float kS = ReadKey(KEY_S);\n    float kD = ReadKey(KEY_D);\n    \n    float left  = ReadKey(KEY_LEFT);\n    float right = ReadKey(KEY_RIGHT);\n    float up    = ReadKey(KEY_UP);\n    float down  = ReadKey(KEY_DOWN);\n    \n    vec4 wasdAccu = wasdAccuLast + vec4(kW, kA, kS, kD);\n         wasdAccu += vec4(up, left, down, right);  \n    \n    vec2 mouseDelta = iMouse.xy - iMouseLast.xy;\n    \n    bool cond0 = iMouse.z > 0.0 && iMouseLast.z > 0.0;\n    vec2 mouseDelta2 = cond0 && !shift ? mouseDelta.xy : vec2(0.0);\n    vec2 mouseDelta3 = cond0 &&  shift ? mouseDelta.xy : vec2(0.0);\n    \n    vec2 iMouseAccu1 = iMouseAccuLast.xy + mouseDelta2;\n    vec2 iMouseAccu2 = iMouseAccuLast.zw + mouseDelta3;\n    \n    \n    iResolutionLast.w = iResolutionLast.z;\n    \n    if(iResolution.x != iResolutionLast.x || iResolution.y != iResolutionLast.y)\n    iResolutionLast.z = 1.0;\n    else\n    iResolutionLast.z = 0.0;\n    \n    iResolutionLast.xy = iResolution.xy;\n    \n    \n    if(uv.x == 0.0 && uv.y == 0.0) col = iMouse;  \n    if(uv.x == 1.0 && uv.y == 0.0) col = vec4(iMouseAccu1, iMouseAccu2);\n    if(uv.x == 2.0 && uv.y == 0.0) col = wasdAccu;\n    if(uv.x == 3.0 && uv.y == 0.0) col = iResolutionLast;\n    \n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// deprecated code (Image pass now uses proper blue noise)\n\n// BAKES DITHERING NOISE TO BUFFER B \n// BLUISH NOISE: https://www.shadertoy.com/view/MdffRN\n\n\n\n#define FUNC4_UINT(f)\t\t\t\t\t\t\t\t\\\nuvec2 f(uvec2 v) {return uvec2(f(v.x ), f(v.y ));}\t\\\nuvec3 f(uvec3 v) {return uvec3(f(v.xy), f(v.z ));}\t\\\nuvec4 f(uvec4 v) {return uvec4(f(v.xy), f(v.zw));}\t\\\n    \n\n// single iteration of Bob Jenkins' One-At-A-Time hashing algorithm:\n//  http://www.burtleburtle.net/bob/hash/doobs.html\n// suggested by Spatial on stackoverflow:\n//  http://stackoverflow.com/questions/4200224/random-noise-functions-for-glsl\nuint BJXorShift(uint x) \n{\n    x += x << 10u;\n    x ^= x >>  6u;\n    x += x <<  3u;\n    x ^= x >> 11u;\n    x += x << 15u;\n\t\n    return x;\n}\n\nFUNC4_UINT(BJXorShift)    \n    \n\n// xor-shift algorithm by George Marsaglia\n//  https://www.thecodingforums.com/threads/re-rngs-a-super-kiss.704080/\n// suggested by Nathan Reed:\n//  http://www.reedbeta.com/blog/quick-and-easy-gpu-random-numbers-in-d3d11/\nuint GMXorShift(uint x)\n{\n    x ^= x << 13u;\n    x ^= x >> 17u;\n    x ^= x <<  5u;\n    \n    return x;\n}\n\nFUNC4_UINT(GMXorShift) \n    \n// hashing algorithm by Thomas Wang \n//  http://www.burtleburtle.net/bob/hash/integer.html\n// suggested by Nathan Reed:\n//  http://www.reedbeta.com/blog/quick-and-easy-gpu-random-numbers-in-d3d11/\nuint WangHash(uint x)\n{\n    x  = (x ^ 61u) ^ (x >> 16u);\n    x *= 9u;\n    x ^= x >> 4u;\n    x *= 0x27d4eb2du;\n    x ^= x >> 15u;\n    \n    return x;\n}\n\nFUNC4_UINT(WangHash) \n    \n//#define Hash BJXorShift\n#define Hash WangHash\n//#define Hash GMXorShift\n\n// \"floatConstruct\"          | renamed to \"ConstructFloat\" here \n// By so-user Spatial        | http://stackoverflow.com/questions/4200224/random-noise-functions-for-glsl\n// used under CC BY-SA 3.0   | https://creativecommons.org/licenses/by-sa/3.0/             \n// reformatted and changed from original to extend interval from [0..1) to [-1..1) \n//-----------------------------------------------------------------------------------------\n// Constructs a float within interval [-1..1) using the low 23 bits + msb of an uint.\n// All zeroes yields -1.0, all ones yields the next smallest representable value below 1.0. \nfloat ConstructFloat(uint m) \n{\n\tfloat flt = uintBitsToFloat(m & 0x007FFFFFu | 0x3F800000u);// [1..2)\n    float sub = (m >> 31u) == 0u ? 2.0 : 1.0;\n    \n    return flt - sub;// [-1..1)             \n}\n\nvec2 ConstructFloat(uvec2 m) { return vec2(ConstructFloat(m.x), ConstructFloat(m.y)); }\nvec3 ConstructFloat(uvec3 m) { return vec3(ConstructFloat(m.xy), ConstructFloat(m.z)); }\nvec4 ConstructFloat(uvec4 m) { return vec4(ConstructFloat(m.xyz), ConstructFloat(m.w)); }\n\n\nuint Hash(uint  v, uint  r) { return Hash(v ^ r); }\nuint Hash(uvec2 v, uvec2 r) { return Hash(Hash(v.x , r.x ) ^ (v.y ^ r.y)); }\nuint Hash(uvec3 v, uvec3 r) { return Hash(Hash(v.xy, r.xy) ^ (v.z ^ r.z)); }\nuint Hash(uvec4 v, uvec4 r) { return Hash(Hash(v.xy, r.xy) ^ Hash(v.zw, r.zw)); }\n\n// Pseudo-random float value in interval [-1:1).\nfloat Hash(float v, uint  r) { return ConstructFloat(Hash(floatBitsToUint(v), r)); }\nfloat Hash(vec2  v, uvec2 r) { return ConstructFloat(Hash(floatBitsToUint(v), r)); }\nfloat Hash(vec3  v, uvec3 r) { return ConstructFloat(Hash(floatBitsToUint(v), r)); }\nfloat Hash(vec4  v, uvec4 r) { return ConstructFloat(Hash(floatBitsToUint(v), r)); }\n\n\nfloat HashFlt(uint   v, uint  r) { return ConstructFloat(Hash(v, r)); }\nfloat HashFlt(uvec2  v, uvec2 r) { return ConstructFloat(Hash(v, r)); }\nfloat HashFlt(uvec3  v, uvec3 r) { return ConstructFloat(Hash(v, r)); }\nfloat HashFlt(uvec4  v, uvec4 r) { return ConstructFloat(Hash(v, r)); }\n\nuint HashUInt(float v, uint  r) { return Hash(floatBitsToUint(v), r); }\nuint HashUInt(vec2  v, uvec2 r) { return Hash(floatBitsToUint(v), r); }\nuint HashUInt(vec3  v, uvec3 r) { return Hash(floatBitsToUint(v), r); }\nuint HashUInt(vec4  v, uvec4 r) { return Hash(floatBitsToUint(v), r); }\n\n\n\n///////////////////////////////////////////////////////////////////////////\n//=======================================================================//\n\n// shoulder of the ground truth s-curve\nfloat SCurveU_Sh(float x)\n{\n    float a = x < 0.25 ?   0.0        :\n              x < 0.5  ? - 1.0 / 60.0 :\n              x < 0.75 ?  47.0 / 60.0 :\n                         -49.0 / 15.0 ;\n    \n    float b = x < 0.25 ?   2.0        :\n              x < 0.5  ?   7.0 /  3.0 :\n              x < 0.75 ? -17.0 /  3.0 :\n                          64.0 /  3.0 ; \n\n    float c = x < 0.25 ?   0.0        :\n              x < 0.5  ? - 8.0 /  3.0 :\n              x < 0.75 ?  88.0 /  3.0 :\n                         -128.0/  3.0 ; \n\n    float d = x < 0.25 ?   0.0        :\n              x < 0.5  ?  32.0 /  3.0 :\n              x < 0.75 ? -160.0/  3.0 :\n                          128.0/  3.0 ; \n    \n    float e = x < 0.25 ?   0.0        :\n              x < 0.5  ? -64.0 /  3.0 :\n              x < 0.75 ?  128.0/  3.0 :\n                         -64.0 /  3.0 ;    \n    \n    float f = x < 0.25 ? -64.0 / 15.0 :\n              x < 0.5  ?  64.0 /  5.0 :\n              x < 0.75 ? -64.0 /  5.0 :\n                          64.0 / 15.0 ;  \n    \n    float r = a + x*(b + x*(c + x*(d + x*(e + x*f))));   \n    \n    return r;\n}\n\n// ground truth s-curve [-1..1]\nfloat SCurveU(float x)\n{\n   float s = x < 0.0 ? -1.0 : 1.0;\n    \n   return SCurveU_Sh(abs(x)) * s;\n}\n\n// ground truth s-curve [0..1]\nfloat SCurveU01(float x)\n{\n    return SCurveU(x * 2.0 - 1.0) * 0.5 + 0.5;\n}\n\n\n\nfloat SCurveU2_Sh(float x)\n{\n    float a, b, c, d, e, f, g, h;\n    \n    if(x < 1.0/6.0)\n    {\n        a = 0.; b = 2.; c = 0.; d = 0.; e = 0.; f = 0.; g = 0.; h =-648.0/35.0;\n    }else\n    if(x < 1.0/3.0)\n    {\n        a =-1.0/2520.0; b =121.0/60.; c =-3./10.; d =3.; e =-18.; f =324./5.; g =-648./5.; h =648./7.; \n    }else\n    if(x < 0.5)\n    {\n        a =319./2520.; b =-13./20.; c =237./10.; d =-117.; e =342.; f =-2916./5.; g =2592./5.; h =-1296./7.; \n    }else        \n    if(x < 2.0/3.0)\n    {\n        a =-6971./2520.; b =797./20.; c =-2193./10.; d =693.; e =-1278.; f =6804./5.; g =-3888./5.; h =1296./7.; \n    }else        \n    if(x < 5.0/6.0)\n    {\n        a =33989./2520.; b =-7849./60.; c =5487./10.; d =-1227.; e =1602.; f =-6156./5.; g =2592./5.; h =-648./7.; \n    }\n    else        \n    {\n        a =-613./35.; b =648./5.; c =-1944./5.; d =648.; e =-648.; f =1944./5.; g =-648./5.; h =648./35.;\n    }\n    \n    return a + x*(b + x*(c + x*(d + x*(e + x*(f + x*(g + x*h)))))); \n}\n\nfloat SCurveU2(float x)\n{\n   float s = x < 0.0 ? -1.0 : 1.0;\n    \n   return SCurveU2_Sh(abs(x)) * s;\n}\n\nfloat SCurveU201(float x)\n{\n    return SCurveU2(x * 2.0 - 1.0) * 0.5 + 0.5;\n}\n\n\n\nfloat Noise(vec2 uv, uvec2 seed)\n{       \n    uv = uv * vec2(0.97617, 1.38559) + vec2(0.93792, 0.77608);// diffusion\n    \n    return Hash(uv, seed);  \n}\n\nfloat BNoise(vec2 uv, uvec2 seed)\n{\n    float v  = Noise(uv, seed);\n    \n    float v0 = Noise(uv + vec2(-1.0, 0.0), seed);\n    float v1 = Noise(uv + vec2( 1.0, 0.0), seed);\n    float v2 = Noise(uv + vec2( 0.0,-1.0), seed);\n    float v3 = Noise(uv + vec2( 0.0, 1.0), seed);\n      \n    float vf = (v0+v1+v2+v3) * 0.125 + v * -0.5;    \n    \n    vf = SCurveU(vf);\n    \n    return vf;// return v to get white noise for comparison \n}\n\n\nfloat Noise(vec2 uv, float time, uvec3 seed)\n{       \n    uv = uv * vec2(0.97617, 1.38559) + vec2(0.93792, 0.77608);// diffusion\n    time = time * 1.17739 + 0.62852;\n    \n    return Hash(vec3(uv, time), seed);  \n}\n\nfloat BNoise(vec2 uv, float time, uvec3 seed)\n{\n    #if 0\n    time = mod(time, 3.0);\n    #endif\n    \n    float v  = Noise(uv, time, seed);\n    \n    float v0 = Noise(uv + vec2(-1.0, 0.0), time, seed);\n    float v1 = Noise(uv + vec2( 1.0, 0.0), time, seed);\n    float v2 = Noise(uv + vec2( 0.0,-1.0), time, seed);\n    float v3 = Noise(uv + vec2( 0.0, 1.0), time, seed);\n      \n    float vf = (v0+v1+v2+v3) * 0.125 + v * -0.5;    \n    \n    vf = SCurveU(vf);\n    \n    return vf;// return v to get white noise for comparison \n}\n\n\nfloat Noise(vec3 uvw, uvec3 seed)\n{    \n    uvw = uvw * vec3(0.97617, 1.38559, 1.17739) + vec3(0.93792, 0.77608, 0.62852);// diffusion\n    \n    return Hash(uvw, seed);  \n}\n\nfloat BNoise(vec3 uvw, uvec3 seed)\n{\n    float v  = Noise(uvw, seed);\n    \n    float v0 = Noise(uvw + vec3(-1.0, 0.0, 0.0), seed);\n    float v1 = Noise(uvw + vec3( 1.0, 0.0, 0.0), seed);\n    float v2 = Noise(uvw + vec3( 0.0,-1.0, 0.0), seed);\n    float v3 = Noise(uvw + vec3( 0.0, 1.0, 0.0), seed);\n    float v4 = Noise(uvw + vec3( 0.0, 1.0,-1.0), seed);\n    float v5 = Noise(uvw + vec3( 0.0, 1.0, 1.0), seed);\n    \n      \n    float vf = (v0+v1+v2+v3+v4+v5) / 12.0 + v * -0.5;    \n    \n    vf = SCurveU2(vf);\n    \n    return vf;// return v to get white noise for comparison \n}\n\n//=======================================================================//\n///////////////////////////////////////////////////////////////////////////\n\nfloat SCurveE(float x)\n{\n    if(x < 0.0)\n    {\n        x += 1.0;\n        x *= x;\n        x -= 1.0;\n    }\n    else\n    {\n        x = 1.0 - x;\n        x *= x;\n        x = 1.0 - x;               \n    }\n    \n    return x;\n}\n\n// s [-1..1]\nfloat Sample_Triangle(float s) \n{ \n    float v = 1.0 - sqrt(1.0 - abs(s));// NEEDS '1.0 - abs(s)' instead of just 'abs(s)', breaks correlation of bnoise otherwise\n    \n    return s < 0.0 ? -v : v; \n}\n\n\nvoid mainImage( out vec4 outCol, in vec2 uv0 )\n{\n    #if 1\n    // pre-bake (2 frames to fill ping-pong buffer)\n    vec4 iResolutionLast= texelFetch(iChannel0, ivec2(3, 0), 0);\n    \n    if(iResolutionLast.z == 0.0 && iResolutionLast.w == 0.0) {discard;}\n    #endif\n    \n    vec2 uv = uv0 - 0.5;\n    \n    uvec3 seed0 = uvec3(0xC66A87BCu, 0x8D9E427Bu, 0xE1AF7EB4u);\n    uvec3 seed1 = uvec3(0xB4F2102Du, 0x3414E943u, 0xBC6183AAu);    \n          \n    \n    #if 0\n    \n    float noise = (BNoise(uv, seed0.xy) + \n                   BNoise(uv, seed1.xy)) * 0.5;\n        \n    #elif 1\n    \n    float noise = Sample_Triangle(BNoise(uv, seed0.xy));\n    \n    #elif 0\n    \n    float frame = float(iFrame);\n    \n    float noise1 = BNoise(uv, frame, seed0);\n    float noise2 = BNoise(uv, frame, seed1);\n    \n    float noise = (noise1 + noise2) * 0.5;\n    \n    #elif 0\n    \n    //high-pass filter in time domain (kinda works when used with time = mod(time, 3.0);)\n    float frame = float(iFrame);\n\n    float noise1 = BNoise(uv, frame, seed0);\n    \n    float noise2 = SCurveE((BNoise(uv, frame-1.0, seed0) + \n                            BNoise(uv, frame+1.0, seed0)) * 0.5);\n    \n    float noise = (-noise1 + noise2) * 0.5;\n\n    #endif\n    \n\n\toutCol = vec4(noise, 0., 0., 0.);\n}\n\n","name":"Buffer B","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define rsqrt inversesqrt\n#define clamp01(x) clamp(x, 0.0, 1.0)\n#define If(cond, resT, resF) mix(resF, resT, cond)\n\nconst float Pi = 3.14159265359;\nconst float Pi2 = Pi * 2.0;\nconst float RcpPi = 1.0 / Pi;\nconst float Pi05 = Pi * 0.5;\n\nfloat Pow2(float x) {return x*x;}\nfloat Pow3(float x) {return x*x*x;}\nfloat Pow4(float x) {return Pow2(Pow2(x));}\n\nfloat sRGB_EOTF(float c)\n{\n    return c > 0.0031308 ? pow(c, 1.0/2.4) * 1.055 - 0.055 : c * 12.92;\n}\n\nfloat sRGB_InvEOTF(float c)\n{\n    return c > 0.04045 ? pow(c / 1.055 + 0.055/1.055, 2.4) : c / 12.92;\n}\n\nvec3 sRGB_EOTF(vec3 rgb)\n{\n    return If(greaterThan(rgb, vec3(0.0031308)), pow(rgb, vec3(1.0/2.4)) * 1.055 - 0.055, rgb * 12.92);\n}\n\nvec3 sRGB_InvEOTF(vec3 rgb)\n{\n    return If(greaterThan(rgb, vec3(0.04045)), pow(rgb / 1.055 + 0.055/1.055, vec3(2.4)), rgb / 12.92);\n}\n\n\n// ACES fit by Stephen Hill (@self_shadow)\n// https://github.com/TheRealMJP/BakingLab/blob/master/BakingLab/ACES.hlsl \n\n// sRGB => XYZ => D65_2_D60 => AP1\nconst mat3 sRGBtoAP1 = mat3\n(\n\t0.613097, 0.339523, 0.047379,\n\t0.070194, 0.916354, 0.013452,\n\t0.020616, 0.109570, 0.869815\n);\n\n// AP1 => RRT_SAT\nconst mat3 RRT_SAT = mat3\n(\n\t0.970889, 0.026963, 0.002148,\n\t0.010889, 0.986963, 0.002148,\n\t0.010889, 0.026963, 0.962148\n);\n\n\n// sRGB => XYZ => D65_2_D60 => AP1 => RRT_SAT\nconst mat3 ACESInputMat = mat3\n(\n    0.59719, 0.35458, 0.04823,\n    0.07600, 0.90834, 0.01566,\n    0.02840, 0.13383, 0.83777\n);\n\n// ODT_SAT => XYZ => D60_2_D65 => sRGB\nconst mat3 ACESOutputMat = mat3\n(\n     1.60475, -0.53108, -0.07367,\n    -0.10208,  1.10813, -0.00605,\n    -0.00327, -0.07276,  1.07602\n);\n\nvec3 RRTAndODTFit(vec3 x)\n{\n    vec3 a = (x            + 0.0245786) * x;\n    vec3 b = (x * 0.983729 + 0.4329510) * x + 0.238081;\n    \n    return a / b;\n}\n\n\nvec3 ToneTF0(vec3 x)\n{\n    vec3 a = (x            + 0.0509184) * x;\n    vec3 b = (x * 0.973854 + 0.7190130) * x + 0.0778594;\n    \n    return a / b;\n}\n\nvec3 ToneTF1(vec3 x)\n{\n    vec3 a = (x          + 0.0961727) * x;\n    vec3 b = (x * 0.9797 + 0.6157480) * x + 0.213717;\n    \n    return a / b;\n}\n\nvec3 ToneTF2(vec3 x)\n{\n    vec3 a = (x            + 0.0822192) * x;\n    vec3 b = (x * 0.983521 + 0.5001330) * x + 0.274064;\n    \n    return a / b;\n}\n\n\nvec3 Tonemap_ACESFitted(vec3 srgb)\n{\n    vec3 color = srgb * ACESInputMat;\n   \n   #if 1\n    color = ToneTF0(color);\n   #else\n    color = RRTAndODTFit(color);\n   #endif\n    \n    color = color * ACESOutputMat;\n\n    return color;\n}\n\nvec3 Tonemap_ACESFitted2(vec3 acescg)\n{\n    vec3 color = acescg * RRT_SAT;\n    \n   #if 1\n    color = ToneTF2(color); \n   #elif 1\n    color = RRTAndODTFit(color);\n   #elif 1\n    color = ToneMapFilmicALU(color);\n   #endif\n    \n    color = color * ACESOutputMat;\n    //color = ToneMapFilmicALU(color);\n\n    return color;\n}","name":"Common","description":"","type":"common"}]}