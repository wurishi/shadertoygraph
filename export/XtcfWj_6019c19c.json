{"ver":"0.1","info":{"id":"XtcfWj","date":"1540985131","viewed":140,"name":"Water under purple moving moon","username":"wazoowazoo","description":"This is a very simple water shader simulating reflection and refraction. It can still be optimized. I hope you will like it !","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["refraction","water"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.141592654\n#define PREC 0.001 // derivative precision, to small (< 0.00001) deteriors quality & performance\n#define SIZE vec2(40,30) // function size/precision\n#define WATER vec4(0.21, 0.4, 0.81, 1) // water color, no use yet ...\n#define CAMERA vec3(0.5, 0.5, 1) // camera position, direction is always [0, 0, -1]\n\nstruct Light\n{\n  vec3 pos;\n  vec4 color;\n};\n\n//\tClassic Perlin 2D Noise\n//\tby Stefan Gustavson\n//\nvec2 fade(vec2 t) {return t*t*t*(t*(t*6.0-15.0)+10.0);}\n\nvec4 permute(vec4 x) {return mod(((x*34.0)+1.0)*x, 289.0);}\n\nfloat cnoise(vec2 P) {\n  vec4 Pi = floor(P.xyxy) + vec4(0.0, 0.0, 1.0, 1.0);\n  vec4 Pf = fract(P.xyxy) - vec4(0.0, 0.0, 1.0, 1.0);\n  Pi = mod(Pi, 289.0); // To avoid truncation effects in permutation\n  vec4 ix = Pi.xzxz;\n  vec4 iy = Pi.yyww;\n  vec4 fx = Pf.xzxz;\n  vec4 fy = Pf.yyww;\n  vec4 i = permute(permute(ix) + iy);\n  vec4 gx = 2.0 * fract(i * 0.0243902439) - 1.0; // 1/41 = 0.024...\n  vec4 gy = abs(gx) - 0.5;\n  vec4 tx = floor(gx + 0.5);\n  gx = gx - tx;\n  vec2 g00 = vec2(gx.x,gy.x);\n  vec2 g10 = vec2(gx.y,gy.y);\n  vec2 g01 = vec2(gx.z,gy.z);\n  vec2 g11 = vec2(gx.w,gy.w);\n  vec4 norm = 1.79284291400159 - 0.85373472095314 * vec4(dot(g00, g00), dot(g01, g01), dot(g10, g10), dot(g11, g11));\n  g00 *= norm.x;\n  g01 *= norm.y;\n  g10 *= norm.z;\n  g11 *= norm.w;\n  float n00 = dot(g00, vec2(fx.x, fy.x));\n  float n10 = dot(g10, vec2(fx.y, fy.y));\n  float n01 = dot(g01, vec2(fx.z, fy.z));\n  float n11 = dot(g11, vec2(fx.w, fy.w));\n  vec2 fade_xy = fade(Pf.xy);\n  vec2 n_x = mix(vec2(n00, n01), vec2(n10, n11), fade_xy.x);\n  float n_xy = mix(n_x.x, n_x.y, fade_xy.y);\n  return 2.3 * n_xy;\n}\n// End of Stefan Gustavson's code\n\nfloat func(vec2 coords, float offset, float mult) {\n  //return (cnoise(coords + vec2(offset)) + 1.0) / 3.0 * mult;\n  return ((cnoise(coords + vec2(offset)) + 1.0) / 2.0 + (cnoise(coords * vec2(8.0) + vec2(offset) * vec2(8.0))) / 80.0) * mult +\n      (cos(0.1 * PI * coords.x) * sin(0.3 * PI * coords.y)) * sin(offset) / 5.0;\n}\n\nfloat xDerivative(vec2 coords, float offset, float mult) {\n  return (func(coords + vec2(PREC, 0), offset, mult) - func(coords - vec2(PREC, 0), offset, mult))/((coords.x + PREC) - (coords.x - PREC));\n}\n\nfloat yDerivative(vec2 coords, float offset, float mult) {\n  return (func(coords + vec2(0, PREC), offset, mult) - func(coords - vec2(0, PREC), offset, mult))/((coords.y + PREC) - (coords.y - PREC));\n}\n\nfloat mult = 0.3;\nLight LIGHT = Light(vec3(1, 0.5, 1), vec4(1, 0, 1, 1)); // light position & color\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  LIGHT.pos.x = (cos(iTime) + 1.0) / 2.0;\n    \n  vec2 texCoords = fragCoord / iResolution.xy;\n  float waveHeight = func(texCoords * SIZE, iTime, mult);\n\n  // calculating derivatives\n  float xDerivative = xDerivative(texCoords * SIZE, iTime, mult);\n  float yDerivative = yDerivative(texCoords * SIZE, iTime, mult);\n\n  // reflection calculation\n  vec3 surfaceNormal = normalize(vec3(\n    -xDerivative,\n    -yDerivative,\n    1\n  ));\n  vec3 lightVect = normalize(vec3(\n    texCoords.x - LIGHT.pos.x,\n    texCoords.y - LIGHT.pos.y,\n    waveHeight - LIGHT.pos.z\n  ));\n  vec3 cameraVect = normalize(vec3(\n    CAMERA.x - texCoords.x,\n    CAMERA.y - texCoords.y,\n    CAMERA.z - waveHeight\n  ));\n\n  // refraction offset\n  vec3 refraction = normalize(refract(cameraVect, surfaceNormal, 1.3));\n\n  vec2 off;\n  off.x = refraction.x * waveHeight / SIZE.x;\n  off.y = refraction.y * waveHeight / SIZE.y;\n\n  // computing final color\n  vec4 finalColor;\n  vec2 fTrans = texCoords + off;\n\n  float reflectionAmount = 0.0;\n\n  if (fTrans.x < 0.0 || fTrans.x > 1.0 || fTrans.y < 0.0 || fTrans.y > 1.0) {\n    //if it gets out of bounds\n    finalColor = vec4(0);\n  } else {\n    if (distance(normalize(reflect(lightVect, surfaceNormal)), cameraVect) <= 0.2) {\n      reflectionAmount = pow(dot(cameraVect, surfaceNormal), 10.0);//very simplified Fresnel effect\n    }\n    finalColor = (texture(iChannel0, fTrans) * WATER * (1.0 - reflectionAmount)) + (LIGHT.color * reflectionAmount);\n  }\n\n  fragColor = finalColor;\n}","name":"Image","description":"","type":"image"}]}