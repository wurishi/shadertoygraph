{"ver":"0.1","info":{"id":"7sjGDm","date":"1619539875","viewed":254,"name":"Not ants","username":"kabacis","description":"Initially was supposed to be something like ant or slime mold simulation with particle steering based on trails. Couldn't get it quite right but result is still somewhat visually appealing. Takes ~10-20 seconds to stabilize.\nB -> particles\nA -> trails\n","likes":8,"published":1,"flags":32,"usePreview":0,"tags":["simulation","particles","multipass"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float randv(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nconst float scale = 1.0;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 c0 = texelFetch(iChannel0, ivec2(fragCoord * scale), 0);\n    vec4 c1 = texelFetch(iChannel1, ivec2(fragCoord * scale), 0);\n//    c0.z = randv(fragCoord);\n\n    // Output to screen\n    //fragColor = vec4(c0.x * 1.0, 1.0*log(c1.x)*0.5, 0.0, 1.0);\n    //fragColor = vec4(c0.x * 1.0, c1.x*0.1, 0.0, 1.0);\n    fragColor = vec4(c0.x * 0.35, c1.x*0.1, 1.0*log(c1.x-2.0)*0.5, 1.0);\n    //fragColor = vec4(c0.x > 0.5, 0, c0.x < 0.5, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// x - particle presence/amount\n// y - angle\n// z, w - movement error for Bresenham's like movement at arbitrary angle\nfloat randv(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\n\nvec4 getv2(ivec2 p)\n{\n    ivec2 r2 = ivec2(iResolution.xy);\n    if (p.x < 0) {\n        p.x += r2.x;\n    }\n    if (p.y < 0) {\n        p.y += r2.y;\n    }\n    if (p.x >= r2.x) {\n        p.x -= r2.x;\n    }\n    if (p.y >= r2.y) {\n        p.y -= r2.y;\n    }\n    return texelFetch( iChannel0, p, 0 );\n}\n\nvec4 getvb(ivec2 p)\n{\n    ivec2 r2 = ivec2(iResolution.xy);\n    if (p.x < 0) {\n        p.x += r2.x;\n    }\n    if (p.y < 0) {\n        p.y += r2.y;\n    }\n    if (p.x >= r2.x) {\n        p.x -= r2.x;\n    }\n    if (p.y >= r2.y) {\n        p.y -= r2.y;\n    }\n    return texelFetch( iChannel1, p, 0 );\n}\n\n\n\nvec4 pack(vec4 v) {\n    return vec4(v.xy, v.zw);\n}\n\nvec4 unpack(vec4 v) {\n    return vec4(v.xy, v.zw);\n}\n\nconst float kold = 1.0;\nconst float kscent = 0.185;\nconst float ksc2 = 0.060;\nconst float krn = 0.000000005252;\nconst float pi=3.1415;\nconst float pi2=2.0 * pi;\nconst float optsc = 2280.0;\nconst float prefs = 2.0;\nconst float initialFill = 0.90;\n\nvec2 addScent(vec2 old, vec2 d, vec2 front, float k) {\n    old += d * (1.0+0.00*dot(d, front)) * k;\n    return old;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 p = ivec2(fragCoord);\n    vec2 d[4] = vec2[4](\n        vec2(0.0, 1.0),\n        vec2(0.0, -1.0),\n        vec2(1.0, 0.0),\n        vec2(-1.0, 0.0)\n    ); \n    int spd = 1;\n    vec4 av[5] = vec4[5](\n        getvb(p + ivec2(0, 1)),\n        getvb(p + ivec2(0, -1)),\n        getvb(p + ivec2(1, 0)),\n        getvb(p + ivec2(-1, 0)),\n        getvb(p + ivec2(0, 0))\n    ); \n\n    vec2 sumDir = vec2(0);\n    float totalw = 0.0;\n    vec2 olds = vec2(0);\n    for (int i=0; i<4; i++) {\n        vec2 gof = vec2(cos(av[i].y), sin(av[i].y));\n        vec2 vs = 1.0*av[i].zw + gof;\n        \n        float proj = dot(vs, -d[i]);\n        if (av[i].x < prefs) {\n            if  (proj > 0.0 && proj > length(vs + d[i] * proj)) {\n                sumDir += gof * av[i].x;\n                totalw += av[i].x;\n                olds += av[i].x * (vs + d[i]);\n            }\n        } else {\n            float other = length(vs + d[i] * proj);\n            if (proj > 0.0 ) {\n                float ph = (proj) / (other + proj);\n                sumDir += ph * gof * av[i].x;\n                totalw += ph * av[i].x;\n                olds += ph * av[i].x * (vs + d[i]);\n            }\n            /*float ph = max(0.0, dot(gof, -d[i]));// * 0.61;\n            float other = vs + d[i] * proj)\n            sumDir += ph * gof * av[i].x;\n            totalw += ph * av[i].x;\n            olds += ph * av[i].x * (vs + d[i]);*/\n        }\n    }\n    olds /= max(0.01, totalw);\n    if (length(olds) > 2.0 || dot(olds, sumDir) < 0.0) {\n        olds = vec2(0);\n    }\n   \n    sumDir = normalize(sumDir);\n    \n    const float md = 3.4;\n    /*vec2 d2[4] = vec2[4](\n        vec2(0.0, 1.0),\n        vec2(0.0, -1.0),\n        vec2(1.0, 0.0),\n        vec2(-1.0, 0.0)    ); \n    */\n    /*vec2 d2[4] = vec2[4](\n        vec2(1.0, 1.0),\n        vec2(1.0, -1.0),\n        vec2(-1.0, 1.0),\n        vec2(-1.0, -1.0)\n    );*/\n    vec2 d2[4] = vec2[4](\n        sumDir, -sumDir, vec2(sumDir.y, -sumDir.x), -vec2(sumDir.y, -sumDir.x)\n    ); \n    vec4 sc[5] = vec4[5](\n        getv2(p + ivec2(d2[0]*md)),\n        getv2(p + ivec2(d2[1]*md)),\n        getv2(p + ivec2(d2[2]*md)),\n        getv2(p + ivec2(d2[3]*md)),\n        getv2(p + ivec2(0, 0))\n    ); \n    \n    \n    vec2 scd = vec2(0, 0);\n    float tsc = 0.0;\n    for (int i=0; i<4; i++) {\n        float ef = (1.0 + dot(d2[i], sumDir));\n        scd += d2[i] * sc[i].x * ef; //(optsc-abs(-optsc+sc[i].x)) * ef;\n        tsc += sc[i].x * ef;\n    }\n    \n    float drsc = atan(scd.y, scd.x);\n    \n\n    float dra = atan(sumDir.y, sumDir.x);\n    dra += (randv(fragCoord*0.2 + vec2(iTime*10.0, 0.)) -0.5) * krn;\n  \n    \n    float df = mod((drsc-dra), pi2);\n    if (df > pi) { \n        df -= pi2;\n    }\n    if (df < -pi) { \n        df += pi2;\n    }\n    dra += ksc2 * min((pow(2.0, tsc)-1.0), 4.0) * clamp(df, -kscent, kscent);\n    /*dra += (randv(fragCoord + vec2(iTime, 0.)) -0.5) * krn;\n    dra -= 0.000;*/\n    \n    \n    \n    \n    if (iFrame == 0) {\n            float a = randv(fragCoord) * pi2;\n            float amount = (randv(fragCoord + vec2(10, 0)) > initialFill) ? 1.0 : 0.0;\n            fragColor = pack(vec4(amount, a, 0, 0));\n    } else {\n       \n        \n      \n        vec2 drr = vec2(cos(dra), sin(dra));\n        //drr = dr;\n        fragColor = pack(vec4(totalw, dra, olds.xy));\n    }\n    \n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Trails\nfloat randv(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvec4 getv2(ivec2 p)\n{\n    ivec2 r2 = ivec2(iResolution.xy);\n    if (p.x < 0) {\n        p.x += r2.x;\n    }\n    if (p.y < 0) {\n        p.y += r2.y;\n    }\n    if (p.x >= r2.x) {\n        p.x -= r2.x;\n    }\n    if (p.y >= r2.y) {\n        p.y -= r2.y;\n    }\n    return texelFetch( iChannel0, p, 0 );\n}\n\nvec4 getvb(ivec2 p)\n{\n    ivec2 r2 = ivec2(iResolution.xy);\n    if (p.x < 0) {\n        p.x += r2.x;\n    }\n    if (p.y < 0) {\n        p.y += r2.y;\n    }\n    if (p.x >= r2.x) {\n        p.x -= r2.x;\n    }\n    if (p.y >= r2.y) {\n        p.y -= r2.y;\n    }\n    return texelFetch( iChannel1, p, 0 );\n}\n\nconst float kold = 1.0;\nconst float kscent = 0.885;\nconst float ksc2 = 0.120;\nconst float pi=3.1415;\nconst float pi2=2.0 * pi;\nconst float scentDecay = 0.995;\nconst float scexpand = 0.022;\nconst float scadd = 0.2;\n\nvec2 addScent(vec2 old, vec2 d, vec2 front, float k) {\n    old += d * (1.0+0.00*dot(d, front)) * k;\n    return old;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 p = ivec2(fragCoord);\n    vec2 d[4] = vec2[4](\n        vec2(0.0, 1.0),\n        vec2(0.0, -1.0),\n        vec2(1.0, 0.0),\n        vec2(-1.0, 0.0)\n    ); \n    vec4 av[5] = vec4[5](\n        getvb(p + ivec2(0, 1)),\n        getvb(p + ivec2(0, -1)),\n        getvb(p + ivec2(1, 0)),\n        getvb(p + ivec2(-1, 0)),\n        getvb(p + ivec2(0, 0))\n    ); \n    vec4 scv[5] = vec4[5](\n        getv2(p + ivec2(0, 1)),\n        getv2(p + ivec2(0, -1)),\n        getv2(p + ivec2(1, 0)),\n        getv2(p + ivec2(-1, 0)),\n        getv2(p + ivec2(0, 0))\n    ); \n    \n\n    \n    \n    if (iFrame == 0) {\n            fragColor = vec4(0);\n    } else {\n        float sc = scv[4].x;\n        float sc2 = 0.0;\n        sc2 += scv[0].x+scv[1].x+scv[2].x+scv[3].x;\n        sc = (1.0 - scexpand) * sc + scexpand * 0.25 * sc2;\n        \n        sc = sc * scentDecay + scadd * min(av[4].x, 9999999.0);\n        \n        /*if (length(fragCoord - vec2(10.0)) < 5.0) {\n            sc = max(sc, 40.0);\n        }*/\n        \n        //drr = dr;\n        fragColor = vec4(sc, 0.0, 0.0, 0.0);\n    }\n    \n}","name":"Buffer A","description":"","type":"buffer"}]}