{"ver":"0.1","info":{"id":"lcyyWd","date":"1732740175","viewed":33,"name":"Triangle Rendered As Voxels","username":"capslpop","description":"Triangles to voxels","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["voxels"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float thick = 1.0;\n\nvec2 rotate2d(vec2 v, float a) {\n\tfloat sinA = sin(a);\n\tfloat cosA = cos(a);\n\treturn vec2(v.x * cosA - v.y * sinA, v.y * cosA + v.x * sinA);\t\n}\n\nvec3 computeNormal(vec3 v0, vec3 v1, vec3 v2) {\n    vec3 edge1 = v1 - v0;\n    vec3 edge2 = v2 - v0;\n    vec3 normal = normalize(cross(edge1, edge2));\n    return normal;\n}\n\nvec3 pointAwayFromLine(vec3 v0, vec3 v1, vec3 point) {\n    // Compute the direction of the line\n    vec3 lineDir = normalize(v1 - v0);\n    \n    // Compute the vector from the line to the reference point\n    vec3 toPoint = point - v0;\n    \n    // Project the vector onto the line\n    vec3 projection = dot(toPoint, lineDir) * lineDir;\n    \n    // Compute the perpendicular vector from the line to the point\n    vec3 perp = toPoint - projection;\n    \n    // Return the normalized perpendicular vector\n    return normalize(perp);\n}\n\nvec4 intersectTriangle(vec3 rayOrigin, vec3 rayDir, vec3 v0, vec3 v1, vec3 v2) {\n    // Triangle edges\n    vec3 edge1 = v1 - v0;\n    vec3 edge2 = v2 - v0;\n\n    // Compute determinant\n    vec3 h = cross(rayDir, edge2);\n    float a = dot(edge1, h);\n\n    // If determinant is near zero, the ray is parallel to the triangle\n    if (abs(a) < 1e-6) return vec4(0.0, 0.0, 0.0, 999.0);\n\n    float f = 1.0 / a;\n    vec3 s = rayOrigin - v0;\n    float u = f * dot(s, h);\n\n    // Check if the intersection is outside the triangle\n    if (u < 0.0 || u > 1.0) return vec4(0.0, 0.0, 0.0, 999.0);\n\n    vec3 q = cross(s, edge1);\n    float v = f * dot(rayDir, q);\n\n    // Check if the intersection is outside the triangle\n    if (v < 0.0 || u + v > 1.0) return vec4(0.0, 0.0, 0.0, 999.0);\n\n    // Compute distance t along the ray\n    float t = f * dot(edge2, q);\n\n    // If t is negative, the intersection is behind the ray's origin\n    if (t < 0.0) return vec4(0.0, 0.0, 0.0, 999.0);\n\n    // Calculate intersection position\n    return vec4(rayOrigin + rayDir * t, t);\n}\n\nvec4 thickTriangle(vec3 rayPos, vec3 rayDir, vec3 v0, vec3 v1, vec3 v2)\n{\n    vec3 norm = computeNormal(v0, v1, v2);\n\n    float thickness = thick;\n    \n    v0 += pointAwayFromLine(v1, v2, v0);\n    v1 += pointAwayFromLine(v0, v2, v1);\n    v2 += pointAwayFromLine(v0, v1, v2);\n    \n    v0 = v0 - norm * thickness;\n    v1 = v1 - norm * thickness;\n    v2 = v2 - norm * thickness;\n        \n    vec3 v3 = v0 + norm * thickness * 2.0;\n    vec3 v4 = v1 + norm * thickness * 2.0;\n    vec3 v5 = v2 + norm * thickness * 2.0;\n    \n    vec4 pos_t = intersectTriangle(rayPos, rayDir, v0, v1, v2);\n    vec4 temp = intersectTriangle(rayPos, rayDir, v3, v4, v5);\n    if (temp.a < pos_t.a) pos_t = temp;\n    \n    // quad 1\n    temp = intersectTriangle(rayPos, rayDir, v0, v3, v1);\n    if (temp.a < pos_t.a) pos_t = temp;\n    temp = intersectTriangle(rayPos, rayDir, v1, v4, v3);\n    if (temp.a < pos_t.a) pos_t = temp;\n    \n    // quad 2\n    temp = intersectTriangle(rayPos, rayDir, v1, v4, v2);\n    if (temp.a < pos_t.a) pos_t = temp;\n    temp = intersectTriangle(rayPos, rayDir, v2, v5, v4);\n    if (temp.a < pos_t.a) pos_t = temp;\n    \n    // quad 3\n    temp = intersectTriangle(rayPos, rayDir, v0, v3, v2);\n    if (temp.a < pos_t.a) pos_t = temp;\n    temp = intersectTriangle(rayPos, rayDir, v2, v5, v3);\n    if (temp.a < pos_t.a) pos_t = temp;\n    \n    return pos_t;\n}\n\n// Function to compute the signed distance from a point to a plane\nfloat signedDistanceToPlane(vec3 point, vec3 p0, vec3 p1, vec3 p2) {\n    vec3 normal = computeNormal(p0, p1, p2);  // Compute normal of the triangle\n    return dot(point - p0, normal);  // Signed distance from point to the plane\n}\n/*\nbool isInThickTrangle(vec3 pos, vec3 v0, vec3 v1, vec3 v2)\n{\n    if (abs(signedDistanceToPlane(pos, v0, v1, v2)) < thick / 2.0) return true;\n    return false;\n}\n*/\n\nbool isInThickTriangle(vec3 pos, vec3 v0, vec3 v1, vec3 v2) {\n    // Compute the normal of the triangle\n    vec3 normal = computeNormal(v0, v1, v2);\n    \n    // Compute the signed distance from the point to the triangle's plane\n    float dist = dot(pos - v0, normal);\n\n    // If the point is outside the thickness range, return false\n    if (abs(dist) > thick / 2.0) return false;\n\n    // Project the point onto the triangle's plane\n    vec3 projectedPos = pos - dist * normal;\n\n    // Check if the projected position lies within the 2D triangle\n    vec3 edge0 = v1 - v0;\n    vec3 edge1 = v2 - v1;\n    vec3 edge2 = v0 - v2;\n    vec3 c0 = projectedPos - v0;\n    vec3 c1 = projectedPos - v1;\n    vec3 c2 = projectedPos - v2;\n\n    // Test if the point lies inside the triangle using cross products\n    if (dot(normal, cross(edge0, c0)) >= 0.0 &&\n        dot(normal, cross(edge1, c1)) >= 0.0 &&\n        dot(normal, cross(edge2, c2)) >= 0.0) {\n        return true;\n    }\n\n    return false;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float spinPos = (iMouse.y/iResolution.y) * 25.0;\n    vec2 screenPos = (fragCoord.xy / iResolution.xy) * 2.0 - 1.0;\n\tvec3 cameraDir = vec3(0.0, 0.0, 0.8);\n\tvec3 cameraPlaneU = vec3(1.0, 0.0, 0.0);\n\tvec3 cameraPlaneV = vec3(0.0, 1.0, 0.0) * iResolution.y / iResolution.x;\n\tvec3 rayDir = normalize(cameraDir + screenPos.x * cameraPlaneU + screenPos.y * cameraPlaneV);\n\tvec3 rayPos = vec3(0.0, 5.0, -spinPos);\n\trayPos.xz = rotate2d(rayPos.xz, (iMouse.x/iResolution.x)*10.0);\n\trayDir.xz = rotate2d(rayDir.xz, (iMouse.x/iResolution.x)*10.0);\n    \n    vec3 v0 = vec3(20.0*sin(iTime), 0.0, 0.0);\n    vec3 v1 = vec3(0.0, 20.0*cos(iTime*0.5), 0.0);\n    vec3 v2 = vec3(0.0, 0.0, 20.0*sin(iTime*0.75));\n    //vec3 v0 = vec3(20.0, 0.0, 0.0);\n    //vec3 v1 = vec3(0.0, 20.0, 0.0);\n    //vec3 v2 = vec3(0.0, 0.0, 20.0);\n    \n    vec3 v3 = vec3(20.0*sin(iTime), 0.0, 0.0);\n    vec3 v4 = vec3(0.0, 20.0*cos(iTime*0.5), 0.0);\n    vec3 v5 = vec3(20.0*cos(iTime), 20.0*cos(iTime), 20.0*cos(iTime));\n    \n    \n    bool first = true;\n    vec4 pos_t = thickTriangle(rayPos, rayDir, v0, v1, v2);\n    vec4 temp = thickTriangle(rayPos, rayDir, v3, v4, v5);\n    if (temp.a < pos_t.a)\n    {\n        first = false;\n        pos_t = temp;\n    }\n    \n    \n    //vec4 pos_t = intersectTriangle(rayPos, rayDir, v0, v1, v2);\n    \n    if (pos_t.a < 999.0)\n    {\n        \n        vec3 mapPos = floor(rayPos); //floor(pos_t.xyz);\n        vec3 deltaDist = abs(1.0 / rayDir);\n        vec3 rayStep = sign(rayDir);\n        vec3 sideDist = (sign(rayDir) * (vec3(mapPos) - rayPos) + (sign(rayDir) * 0.5) + 0.5) * deltaDist;\n        vec3 mask;\n        \n        for (int i = 0; i < 100; i++) \n        {\n            if (isInThickTriangle(mapPos + 0.5, v0, v1, v2) || isInThickTriangle(mapPos + 0.5, v3, v4, v5))\n            {\n                break;\n            }\n                \n            if (i == 99)\n            {\n                fragColor = vec4(0.180,0.204,0.239,1.0); // + vec4(0.639,0.600,0.600,0.);\n                return;\n            }\n            mask = vec3(lessThanEqual(sideDist.xyz, min(sideDist.yzx, sideDist.zxy)));\t\t\n            sideDist += mask * deltaDist;\n            mapPos += mask * rayStep;\n        }\n        \n        float total_length = min(sideDist.x, min(sideDist.y, sideDist.z));\n    \n        fragColor = vec4(1.0, 1.0, 1.0, 1.0) * 4.0 / distance(rayPos, mapPos);        \n        return;\n    }\n    \n    fragColor = vec4(0.180,0.204,0.239,1.0);\n}","name":"Image","description":"","type":"image"}]}