{"ver":"0.1","info":{"id":"lXK3DD","date":"1717686132","viewed":59,"name":"Background Removal with Ghosting","username":"MajorCallisto","description":"Using a simple greenscreen, removes the background, inverts, pulls a channel and blurs the image to create a ghost effect. With cubemap for fun and ripples.","likes":2,"published":1,"flags":32,"usePreview":0,"tags":["transparent","background","removal"],"hasliked":0,"parentid":"Ws3cWj","parentname":"Background Removal"},"renderpass":[{"inputs":[{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*Screen Buffer against Background*/\n\nfloat edgeFilterQuickestA(sampler2D tex, vec2 uv) {\n    vec3 color = texture(tex, uv).rgb;\n    return distance(dFdy(color),dFdx(color));// * length(color);\n}\n\nfloat edgeFilterSlower(sampler2D tex, vec2 uv) {\n\tvec4 n = texture(tex, uv+vec2(0,1)/iResolution.xy);\n    vec4 e = texture(tex, uv+vec2(1,0)/iResolution.xy);\n    vec4 s = texture(tex, uv+vec2(0,-1)/iResolution.xy);\n    vec4 w = texture(tex, uv+vec2(-1,0)/iResolution.xy);\n    \n    vec4 dy = (n - s)*.5;\n    vec4 dx = (e - w)*.5;\n    \n    vec4 edge = sqrt(dx*dx + dy*dy);\n    return edge.x;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n    vec4 foreground = texture(iChannel1, uv);\n    \n    \n    vec2 uvCube = 2.5 * (fragCoord.xy - 0.5 * iResolution.xy) / iResolution.xx;\n    float rotX = (iMouse.x / iResolution.x) * 2.0 * 3.14;\n    float rotY = (iMouse.y / iResolution.y) * 3.14;\n    \n    vec3 camO = vec3(cos(rotX), cos(rotY), sin(rotX));\n    vec3 camD = normalize(vec3(0)-camO);\n    vec3 camR = normalize(cross(camD, vec3(0, 1, 0)));\n    vec3 camU = cross(camR,camD);\n   \tvec3 dir =  normalize(uvCube.x * camR + uvCube.y * camU + camD);\n    vec4 background = texture(iChannel0, dir);\n    \n    //Ripple Data\n    vec4 data = texture(iChannel2, uv);\n    \n    // Sunlight glint\n    vec3 normal = normalize(vec3(-data.z, 0.2, -data.w));\n    \n    background += vec4(1) * pow(max(0.0, dot(normal, normalize(vec3(-3, 10, 3)))), 60.0);\n    \n    vec3 color = background.rgb;\n    vec4 finalColor = vec4(color, 1.0);\n\n    float isEdge = 0.0;\n    isEdge = edgeFilterSlower(iChannel3, uv);\n    vec4 edgeForeground = texture(iChannel3, uv) * isEdge;\n    vec4 contrastForeground = contrastMatrix( 1.0 ) * foreground;\n        \n    //finalColor = vec4 (screen(contrastForeground.rgb, background.rgb), 1.0) ;\n    \n    \n    finalColor = vec4 (screen(screen(edgeForeground.rgb, contrastForeground.rgb), background.rgb), 1.0) ;\n    \n    fragColor = finalColor;\n\t\n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XdfGRr","filepath":"/media/a/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm","previewfilepath":"/media/ap/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm","type":"video","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"bool isgreen(in vec3 color) {\n    return 0.6 * color.g > color.r && 0.6 * color.g > color.b;\n}\n\nconst vec4 channelFilters[4] = vec4[4](\n\tvec4(1.0, 0.0, 0.0, 0.0),\n\tvec4(0.0, 1.0, 0.0, 0.0),\n\tvec4(0.0, 0.0, 1.0, 0.0),\n\tvec4(0.0, 0.0, 0.0, 1.0)\n);\nfloat getChannel(int channel, sampler2D tex, vec2 uv)\n{\n    vec4 newTex = vec4(1.) -texture(tex, uv);\n    return dot(newTex, channelFilters[channel]);\n}\n\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n    vec4 foreground = texture(iChannel0, uv);\n    vec4 finalColor = vec4(vec3(0,0,0), 1.0);\n    \n    float channel = getChannel(channelTarget, iChannel0, uv);\n    \n    if (!isgreen(foreground.rgb)) {\n        finalColor = vec4(vec3(channel),1.0);\n    }\n    \n    fragColor = finalColor;\n\t\n}\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"//from https://www.shadertoy.com/view/lsBfRc\n\nvec3 makeBloom(float lod, vec2 offset, vec2 bCoord){\n\n    \n    vec2 pixelSize = 1.0 / vec2(iResolution.x, iResolution.y);\n\n    offset += pixelSize;\n\n    float lodFactor = exp2(lod);\n\n    vec3 bloom = vec3(0.0);\n    vec2 scale = lodFactor * pixelSize;\n\n    vec2 coord = (bCoord.xy-offset)*lodFactor;\n    float totalWeight = 0.0;\n\n    if (any(greaterThanEqual(abs(coord - 0.5), scale + 0.5)))\n        return vec3(0.0);\n\n    for (int i = -5; i < 5; i++) {\n        for (int j = -5; j < 5; j++) {\n\n            float wg = pow(1.0-length(vec2(i,j)) * 0.125,6.0);\n\n            bloom = pow(texture(iChannel0,vec2(i,j) * scale + lodFactor * pixelSize + coord, lod).rgb,vec3(2.2))*wg + bloom;\n            totalWeight += wg;\n\n        }\n    }\n\n    bloom /= totalWeight;\n\n    return bloom;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    \n\tvec3 blur = makeBloom(2.,vec2(0.0,0.0), uv);\n\t\tblur += makeBloom(3.,vec2(0.3,0.0), uv);\n\t\tblur += makeBloom(4.,vec2(0.0,0.3), uv);\n\t\tblur += makeBloom(5.,vec2(0.1,0.3), uv);\n\t\tblur += makeBloom(6.,vec2(0.2,0.3), uv);\n\n    fragColor = vec4(pow(blur, vec3(1.0 / 2.2)),1.0);\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"//from https://www.shadertoy.com/view/lsBfRc\n\n#define colorRange 2.0\n\nvec3 customToneMap (vec3 c){\n    float l = dot(c, vec3(0.2126, 0.25, 0.0722));\n    \n    vec3 tc = c / (c + 1.0);\n\n    return mix(c / (l + 1.0), tc, tc);\n}\n\nvec3 bloomTile(float lod, vec2 offset, vec2 uv){\n    return texture(iChannel1, uv * exp2(-lod) + offset).rgb;\n}\n\nvec3 getBloom(vec2 uv){\n\n    vec3 blur = vec3(0.0);\n\n    blur = pow(bloomTile(2., vec2(0.0,0.0), uv),vec3(2.2))       \t   \t+ blur;\n    blur = pow(bloomTile(3., vec2(0.3,0.0), uv),vec3(2.2)) * 1.1        + blur;\n    blur = pow(bloomTile(4., vec2(0.0,0.3), uv),vec3(2.2)) * 1.2        + blur;\n    blur = pow(bloomTile(5., vec2(0.1,0.3), uv),vec3(2.2)) * 1.3 \t   \t+ blur;\n    blur = pow(bloomTile(6., vec2(0.2,0.3), uv),vec3(2.2)) * 1.4 \t   \t+ blur;\n\n    return blur * colorRange;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    vec3 color = texture(iChannel2, uv).rgb;\n    color = pow(color, vec3(2.2));\n    color += pow(getBloom(uv), vec3(2.2));\n    color = pow(color, vec3(1.0 / 2.2));\n    \n    \n    color = customToneMap(color);\n    \n\tfragColor = vec4(color,1.0);\n}","name":"Buffer C","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"\n#define SCREEN int(iTime)&1\n\nmat4 contrastMatrix( float contrast )\n{\n\tfloat t = ( 1.0 - contrast ) / 2.0;\n    \n    return mat4( contrast, 0, 0, 0,\n                 0, contrast, 0, 0,\n                 0, 0, contrast, 0,\n                 t, t, t, 1 );\n\n}\n//Screen\nvec3 screen(vec3 base, vec3 bl_layer){\n    //return base + bl_layer - base * bl_layer;\n    return max(min(1.0-((1.0-base)*(1.0-bl_layer)),1.0), 0.0);\n}\nvec3 lighten(vec3 base, vec3 blend){\n    return max(base, blend);\n}\n\nint channelTarget = 0;","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"// Make this a smaller number for a smaller timestep.\n// Don't make it bigger than 1.4 or the universe will explode.\nconst float delta = 1.0;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if (iFrame == 0) {fragColor = vec4(0); return;}\n    \n    \n    \n    float pressure = texelFetch(iChannel0, ivec2(fragCoord), 0).x;\n    float pVel = texelFetch(iChannel0, ivec2(fragCoord), 0).y;\n\n    float p_right = texelFetch(iChannel0, ivec2(fragCoord) + ivec2(1, 0), 0).x;\n    float p_left = texelFetch(iChannel0, ivec2(fragCoord) + ivec2(-1, 0), 0).x;\n    float p_up = texelFetch(iChannel0, ivec2(fragCoord) + ivec2(0, 1), 0).x;\n    float p_down = texelFetch(iChannel0, ivec2(fragCoord) + ivec2(0, -1), 0).x;\n    \n    // Change values so the screen boundaries aren't fixed.\n    if (fragCoord.x == 0.5) p_left = p_right;\n    if (fragCoord.x == iResolution.x - 0.5) p_right = p_left;\n\tif (fragCoord.y == 0.5) p_down = p_up;\n    if (fragCoord.y == iResolution.y - 0.5) p_up = p_down;\n\n    // Apply horizontal wave function\n    pVel += delta * (-2.0 * pressure + p_right + p_left) / 4.0;\n    // Apply vertical wave function (these could just as easily have been one line)\n    pVel += delta * (-2.0 * pressure + p_up + p_down) / 4.0;\n    \n    // Change pressure by pressure velocity\n    pressure += delta * pVel;\n    \n    // \"Spring\" motion. This makes the waves look more like water waves and less like sound waves.\n    pVel -= 0.005 * delta * pressure;\n    \n    // Velocity damping so things eventually calm down\n    pVel *= 1.0 - 0.002 * delta;\n    \n    // Pressure damping to prevent it from building up forever.\n    pressure *= 0.999;\n    \n    //x = pressure. y = pressure velocity. Z and W = X and Y gradient\n    fragColor.xyzw = vec4(pressure, pVel, (p_right - p_left) / 2.0, (p_up - p_down) / 2.0);\n    \n    \n    if (iMouse.z > 1.0) {\n        float dist = distance(fragCoord, iMouse.xy);\n        if (dist <= 20.0) {\n            fragColor.x += 1.0 - dist / 20.0;\n        }\n    }\n}","name":"Buffer D","description":"","type":"buffer"}]}