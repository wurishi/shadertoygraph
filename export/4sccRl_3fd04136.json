{"ver":"0.1","info":{"id":"4sccRl","date":"1519910771","viewed":442,"name":"N-Planar Texturing","username":"pastasfuture","description":"Extend tri-planar texturing to N directions, using spherical super-gaussians as radial basis function for plane falloff.\nStochastically importance sample a single plane per pixel, using the CDF of the plane falloff functions.\nFeed results to basic TAA.","likes":1,"published":1,"flags":32,"usePreview":0,"tags":["triplanar","texturing","sphericalgaussians"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = fragCoord / iResolution.xy;\n    fragColor = texture(iChannel0, uv);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","previewfilepath":"/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Currently supported options are: {3, 4, 5, 7, 9, 12}\n#define NUM_PLANES 9\n\n#if NUM_PLANES == 3\n#define LOBE_SHARPNESS 128.0\n#define SUPER_GAUSSIAN_SHARPNESS 4.0\n\n#define LOBE_MEAN_0 vec3(0.0, 0.0, 1.0)\n#define LOBE_TANGENT_0 vec3(1.0, 0.0, 0.0)\n#define LOBE_BITANGENT_0 vec3(0.0, 1.0, 0.0)\n#define LOBE_SCALE_0 vec2(0.6666667, 0.6666667)\n#define LOBE_BIAS_0 vec2(-0.6666667, -0.6666667)\n#define LOBE_MEAN_1 vec3(1.0, 0.0, 0.0)\n#define LOBE_TANGENT_1 vec3(0.0, 0.0, 1.0)\n#define LOBE_BITANGENT_1 vec3(0.0, 1.0, 0.0)\n#define LOBE_SCALE_1 vec2(0.8000000, 0.7619048)\n#define LOBE_BIAS_1 vec2(-0.6545455, -0.6446886)\n#define LOBE_MEAN_2 vec3(0.0, 1.0, 0.0)\n#define LOBE_TANGENT_2 vec3(1.0, 0.0, 0.0)\n#define LOBE_BITANGENT_2 vec3(0.0, 0.0, 1.0)\n#define LOBE_SCALE_2 vec2(0.9333333, 0.8571429)\n#define LOBE_BIAS_2 vec2(-0.5939394, -0.5934066)\n\n#elif NUM_PLANES == 4\n#define LOBE_SHARPNESS 256.0\n#define SUPER_GAUSSIAN_SHARPNESS 4.0\n// http://neilsloane.com/sphdesigns/dim3/des.3.8.3.txt\n// Normalized eight corners of a box.\n#define LOBE_MEAN_0 vec3(0.5773503, 0.5773503, 0.5773503)\n#define LOBE_TANGENT_0 vec3(0.8164966, -0.4082483, -0.4082483)\n#define LOBE_BITANGENT_0 vec3(0.0000000, 0.7071068, -0.7071068)\n#define LOBE_SCALE_0 vec2(0.6666667, 0.6666667)\n#define LOBE_BIAS_0 vec2(-0.6666667, -0.6666667)\n#define LOBE_MEAN_1 vec3(0.5773503, 0.5773503, -0.5773503)\n#define LOBE_TANGENT_1 vec3(-0.4082483, 0.8164966, 0.4082483)\n#define LOBE_BITANGENT_1 vec3(0.7071068, -0.0000000, 0.7071068)\n#define LOBE_SCALE_1 vec2(0.8888889, 0.8000000)\n#define LOBE_BIAS_1 vec2(-0.6349206, -0.6545455)\n#define LOBE_MEAN_2 vec3(0.5773503, -0.5773503, 0.5773503)\n#define LOBE_TANGENT_2 vec3(0.7071068, 0.7071068, -0.0000000)\n#define LOBE_BITANGENT_2 vec3(-0.4082483, 0.4082483, 0.8164966)\n#define LOBE_SCALE_2 vec2(1.1111111, 0.9333333)\n#define LOBE_BIAS_2 vec2(-0.4761905, -0.5939394)\n#define LOBE_MEAN_3 vec3(0.5773503, -0.5773503, -0.5773503)\n#define LOBE_TANGENT_3 vec3(-0.4082483, 0.4082483, -0.8164966)\n#define LOBE_BITANGENT_3 vec3(0.7071068, 0.7071068, 0.0000000)\n#define LOBE_SCALE_3 vec2(0.7407407, 1.0666667)\n#define LOBE_BIAS_3 vec2(-0.1058201, -0.4848485)\n\n#elif NUM_PLANES == 5\n#define LOBE_SHARPNESS 1024.0\n#define SUPER_GAUSSIAN_SHARPNESS 4.0\n#define LOBE_MEAN_0 vec3(0.6723958, -0.0532802, 0.7382717)\n#define LOBE_TANGENT_0 vec3(-0.7359648, 0.0583174, 0.6745035)\n#define LOBE_BITANGENT_0 vec3(-0.0789918, -0.9968753, 0.0000000)\n#define LOBE_SCALE_0 vec2(0.6666667, 0.6666667)\n#define LOBE_BIAS_0 vec2(-0.6666667, -0.6666667)\n#define LOBE_MEAN_1 vec3(-0.5360147, -0.3968489, 0.7451169)\n#define LOBE_TANGENT_1 vec3(0.4592135, 0.6035573, 0.6517987)\n#define LOBE_BITANGENT_1 vec3(-0.7083864, 0.6915414, -0.1412772)\n#define LOBE_SCALE_1 vec2(0.8000000, 0.7619048)\n#define LOBE_BIAS_1 vec2(-0.6545455, -0.6446886)\n#define LOBE_MEAN_2 vec3(0.3001091, 0.9429356, 0.1442462)\n#define LOBE_TANGENT_2 vec3(-0.2278777, -0.0759699, 0.9707215)\n#define LOBE_BITANGENT_2 vec3(0.9262863, -0.3241929, 0.1920748)\n#define LOBE_SCALE_2 vec2(0.9333333, 0.8571429)\n#define LOBE_BIAS_2 vec2(-0.5939394, -0.5934066)\n#define LOBE_MEAN_3 vec3(-0.8394018, 0.5429587, 0.0245042)\n#define LOBE_TANGENT_3 vec3(0.3763832, 0.5481721, 0.7468889)\n#define LOBE_BITANGENT_3 vec3(0.3920973, 0.6361629, -0.6644972)\n#define LOBE_SCALE_3 vec2(1.0666667, 0.9523810)\n#define LOBE_BIAS_3 vec2(-0.4848485, -0.5128205)\n#define LOBE_MEAN_4 vec3(0.2855793, -0.9583211, 0.0080751)\n#define LOBE_TANGENT_4 vec3(0.0516162, 0.0237943, 0.9983835)\n#define LOBE_BITANGENT_4 vec3(-0.9569641, -0.2847008, 0.0562601)\n#define LOBE_SCALE_4 vec2(1.2000000, 1.0476190)\n#define LOBE_BIAS_4 vec2(-0.3272727, -0.4029304)\n\n#elif NUM_PLANES == 7\n#define LOBE_SHARPNESS 1024.0\n#define SUPER_GAUSSIAN_SHARPNESS 3.0\n#define LOBE_MEAN_0 vec3(-0.2939334, -0.0904107, 0.9515404)\n#define LOBE_TANGENT_0 vec3(0.9094887, 0.2797487, 0.3075239)\n#define LOBE_BITANGENT_0 vec3(-0.2939957, 0.9558068, 0.0000000)\n#define LOBE_SCALE_0 vec2(0.6666667, 0.6666667)\n#define LOBE_BIAS_0 vec2(-0.6666667, -0.6666667)\n#define LOBE_MEAN_1 vec3(0.4465774, -0.6971748, 0.5608172)\n#define LOBE_TANGENT_1 vec3(0.1235793, 0.6688430, 0.7330602)\n#define LOBE_BITANGENT_1 vec3(-0.8861697, -0.2580627, 0.3848465)\n#define LOBE_SCALE_1 vec2(0.8000000, 0.7619048)\n#define LOBE_BIAS_1 vec2(-0.6545455, -0.6446886)\n#define LOBE_MEAN_2 vec3(0.2912946, 0.8432108, 0.4518219)\n#define LOBE_TANGENT_2 vec3(-0.3632973, -0.3394123, 0.8676488)\n#define LOBE_BITANGENT_2 vec3(0.8849647, -0.4168870, 0.2074672)\n#define LOBE_SCALE_2 vec2(0.9333333, 0.8571429)\n#define LOBE_BIAS_2 vec2(-0.5939394, -0.5934066)\n#define LOBE_MEAN_3 vec3(-0.6155473, 0.7855870, 0.0628865)\n#define LOBE_TANGENT_3 vec3(0.5983613, 0.4139302, 0.6860216)\n#define LOBE_BITANGENT_3 vec3(0.5128990, 0.4599075, -0.7248584)\n#define LOBE_SCALE_3 vec2(1.0666667, 0.9523810)\n#define LOBE_BIAS_3 vec2(-0.4848485, -0.5128205)\n#define LOBE_MEAN_4 vec3(-0.9776108, -0.1515252, 0.1460045)\n#define LOBE_TANGENT_4 vec3(0.1250328, 0.1397815, 0.9822565)\n#define LOBE_BITANGENT_4 vec3(-0.1692453, 0.9785199, -0.1177063)\n#define LOBE_SCALE_4 vec2(1.2000000, 1.0476190)\n#define LOBE_BIAS_4 vec2(-0.3272727, -0.4029304)\n#define LOBE_MEAN_5 vec3(0.9638974, 0.2630393, 0.0413781)\n#define LOBE_TANGENT_5 vec3(-0.1764276, 0.5145094, 0.8391384)\n#define LOBE_BITANGENT_5 vec3(0.1994370, -0.8161436, 0.5423417)\n#define LOBE_SCALE_5 vec2(0.6933333, 1.1428571)\n#define LOBE_BIAS_5 vec2(-0.0630303, -0.2637363)\n#define LOBE_MEAN_6 vec3(-0.3762255, -0.9233750, 0.0763743)\n#define LOBE_TANGENT_6 vec3(0.1962452, 0.0011443, 0.9805542)\n#define LOBE_BITANGENT_6 vec3(-0.9055066, 0.3838975, 0.1807774)\n#define LOBE_SCALE_6 vec2(0.8266667, 1.2380952)\n#define LOBE_BIAS_6 vec2(0.0751515, -0.0952381)\n\n#elif NUM_PLANES == 9\n#define LOBE_SHARPNESS 1024.0\n#define SUPER_GAUSSIAN_SHARPNESS 3.0\n#define LOBE_MEAN_0 vec3(0.8921280, -0.0763307, 0.4452877)\n#define LOBE_TANGENT_0 vec3(-0.4436668, 0.0379602, 0.8953875)\n#define LOBE_BITANGENT_0 vec3(-0.0852488, -0.9963597, 0.0000000)\n#define LOBE_SCALE_0 vec2(0.6666667, 0.6666667)\n#define LOBE_BIAS_0 vec2(-0.6666667, -0.6666667)\n#define LOBE_MEAN_1 vec3(-0.2304218, -0.1925489, 0.9538505)\n#define LOBE_TANGENT_1 vec3(0.5598809, 0.7754927, 0.2917952)\n#define LOBE_BITANGENT_1 vec3(-0.7958889, 0.6012787, -0.0708860)\n#define LOBE_SCALE_1 vec2(0.8000000, 0.7619048)\n#define LOBE_BIAS_1 vec2(-0.6545455, -0.6446886)\n#define LOBE_MEAN_2 vec3(0.2934790, 0.5464926, 0.7843570)\n#define LOBE_TANGENT_2 vec3(-0.6874436, -0.4495075, 0.5704071)\n#define LOBE_BITANGENT_2 vec3(0.6642977, -0.7066037, 0.2437618)\n#define LOBE_SCALE_2 vec2(0.9333333, 0.8571429)\n#define LOBE_BIAS_2 vec2(-0.5939394, -0.5934066)\n#define LOBE_MEAN_3 vec3(-0.1923462, -0.8972263, 0.3974768)\n#define LOBE_TANGENT_3 vec3(0.6886440, 0.1651502, 0.7060417)\n#define LOBE_BITANGENT_3 vec3(-0.6991226, 0.4095245, 0.5861035)\n#define LOBE_SCALE_3 vec2(1.0666667, 0.9523810)\n#define LOBE_BIAS_3 vec2(-0.4848485, -0.5128205)\n#define LOBE_MEAN_4 vec3(-0.7961057, 0.5109007, 0.3243397)\n#define LOBE_TANGENT_4 vec3(0.3378293, -0.0694665, 0.9386404)\n#define LOBE_BITANGENT_4 vec3(0.5020828, 0.8568284, -0.1172946)\n#define LOBE_SCALE_4 vec2(1.2000000, 1.0476190)\n#define LOBE_BIAS_4 vec2(-0.3272727, -0.4029304)\n#define LOBE_MEAN_5 vec3(-0.8797986, -0.3768859, 0.2896747)\n#define LOBE_TANGENT_5 vec3(-0.0488818, 0.6778991, 0.7335280)\n#define LOBE_BITANGENT_5 vec3(-0.4728266, 0.6311971, -0.6148376)\n#define LOBE_SCALE_5 vec2(0.6933333, 1.1428571)\n#define LOBE_BIAS_5 vec2(-0.0630303, -0.2637363)\n#define LOBE_MEAN_6 vec3(-0.1173819, 0.9911501, 0.0619915)\n#define LOBE_TANGENT_6 vec3(0.3296735, -0.0199920, 0.9438833)\n#define LOBE_BITANGENT_6 vec3(0.9367694, 0.1312318, -0.3244093)\n#define LOBE_SCALE_6 vec2(0.8266667, 1.2380952)\n#define LOBE_BIAS_6 vec2(0.0751515, -0.0952381)\n#define LOBE_MEAN_7 vec3(0.7176761, 0.6952657, 0.0393286)\n#define LOBE_TANGENT_7 vec3(-0.6010423, 0.5899144, 0.5392117)\n#define LOBE_BITANGENT_7 vec3(0.3516948, -0.4106175, 0.8412515)\n#define LOBE_SCALE_7 vec2(0.9600000, 0.6802721)\n#define LOBE_BIAS_7 vec2(0.2618182, 0.0523286)\n#define LOBE_MEAN_8 vec3(0.5961722, -0.8014357, 0.0477449)\n#define LOBE_TANGENT_8 vec3(-0.0560523, 0.0177750, 0.9982696)\n#define LOBE_BITANGENT_8 vec3(-0.8008975, -0.5978168, -0.0343254)\n#define LOBE_SCALE_8 vec2(1.0933333, 0.7755102)\n#define LOBE_BIAS_8 vec2(0.4969697, 0.1789639)\n\n#elif NUM_PLANES == 12\n#define LOBE_SHARPNESS 512.0\n#define SUPER_GAUSSIAN_SHARPNESS 2.0\n#define LOBE_MEAN_0 vec3(0.0709467, 0.0973711, 0.9927162)\n#define LOBE_TANGENT_0 vec3(-0.5845948, -0.8023306, 0.1204764)\n#define LOBE_BITANGENT_0 vec3(0.8082175, -0.5888841, 0.0000000)\n#define LOBE_SCALE_0 vec2(0.6666667, 0.6666667)\n#define LOBE_BIAS_0 vec2(-0.6666667, -0.6666667)\n#define LOBE_MEAN_1 vec3(-0.8151573, 0.5531495, 0.1718840)\n#define LOBE_TANGENT_1 vec3(0.4074697, 0.3366940, 0.8488849)\n#define LOBE_BITANGENT_1 vec3(0.4116880, 0.7620123, -0.4998502)\n#define LOBE_SCALE_1 vec2(0.8000000, 0.7619048)\n#define LOBE_BIAS_1 vec2(-0.6545455, -0.6446886)\n#define LOBE_MEAN_2 vec3(0.4835712, 0.6268180, 0.6109485)\n#define LOBE_TANGENT_2 vec3(-0.6004234, -0.2703388, 0.7526013)\n#define LOBE_BITANGENT_2 vec3(0.6369071, -0.7307641, 0.2456282)\n#define LOBE_SCALE_2 vec2(0.9333333, 0.8571429)\n#define LOBE_BIAS_2 vec2(-0.5939394, -0.5934066)\n#define LOBE_MEAN_3 vec3(0.7558441, -0.1839139, 0.6283911)\n#define LOBE_TANGENT_3 vec3(0.0545173, 0.9740848, 0.2195148)\n#define LOBE_BITANGENT_3 vec3(-0.6524780, -0.1316608, 0.7462827)\n#define LOBE_SCALE_3 vec2(1.0666667, 0.9523810)\n#define LOBE_BIAS_3 vec2(-0.4848485, -0.5128205)\n#define LOBE_MEAN_4 vec3(0.0972720, -0.6403507, 0.7618984)\n#define LOBE_TANGENT_4 vec3(-0.0604427, 0.7603148, 0.6467365)\n#define LOBE_BITANGENT_4 vec3(-0.9934208, -0.1089605, 0.0352529)\n#define LOBE_SCALE_4 vec2(1.2000000, 1.0476190)\n#define LOBE_BIAS_4 vec2(-0.3272727, -0.4029304)\n#define LOBE_MEAN_5 vec3(-0.8807539, -0.4279420, 0.2028255)\n#define LOBE_TANGENT_5 vec3(-0.1307290, 0.6313477, 0.7644017)\n#define LOBE_BITANGENT_5 vec3(-0.4551730, 0.6467346, -0.6120064)\n#define LOBE_SCALE_5 vec2(0.6933333, 1.1428571)\n#define LOBE_BIAS_5 vec2(-0.0630303, -0.2637363)\n#define LOBE_MEAN_6 vec3(-0.0767857, 0.9959504, 0.0467636)\n#define LOBE_TANGENT_6 vec3(0.3184030, -0.0199520, 0.9477455)\n#define LOBE_BITANGENT_6 vec3(0.9448405, 0.0876629, -0.3155815)\n#define LOBE_SCALE_6 vec2(0.8266667, 1.2380952)\n#define LOBE_BIAS_6 vec2(0.0751515, -0.0952381)\n#define LOBE_MEAN_7 vec3(0.4316853, -0.8912654, 0.1389023)\n#define LOBE_TANGENT_7 vec3(0.2784513, 0.2781389, 0.9192952)\n#define LOBE_BITANGENT_7 vec3(-0.8579701, -0.3581687, 0.3682424)\n#define LOBE_SCALE_7 vec2(0.9600000, 0.6802721)\n#define LOBE_BIAS_7 vec2(0.2618182, 0.0523286)\n#define LOBE_MEAN_8 vec3(-0.2786951, 0.6758545, 0.6823121)\n#define LOBE_TANGENT_8 vec3(0.1988109, -0.6544700, 0.7294815)\n#define LOBE_BITANGENT_8 vec3(0.9395761, 0.3389540, 0.0480304)\n#define LOBE_SCALE_8 vec2(1.0933333, 0.7755102)\n#define LOBE_BIAS_8 vec2(0.4969697, 0.1789639)\n#define LOBE_MEAN_9 vec3(0.9521607, 0.2992973, 0.0617343)\n#define LOBE_TANGENT_9 vec3(-0.0188366, -0.1441477, 0.9893769)\n#define LOBE_BITANGENT_9 vec3(0.3050167, -0.9432087, -0.1316140)\n#define LOBE_SCALE_9 vec2(1.2266667, 0.8707483)\n#define LOBE_BIAS_9 vec2(0.7806061, 0.3349032)\n#define LOBE_MEAN_10 vec3(-0.3485078, -0.9256514, 0.1473491)\n#define LOBE_TANGENT_10 vec3(0.0659006, 0.1326175, 0.9889741)\n#define LOBE_BITANGENT_10 vec3(-0.9349863, 0.3543756, 0.0147828)\n#define LOBE_SCALE_10 vec2(0.7200000, 0.9659864)\n#define LOBE_BIAS_10 vec2(0.5890909, 0.5201465)\n#define LOBE_MEAN_11 vec3(-0.6093276, -0.0961056, 0.7870728)\n#define LOBE_TANGENT_11 vec3(-0.0881305, 0.9946858, 0.0532283)\n#define LOBE_BITANGENT_11 vec3(-0.7880057, -0.0369317, -0.6145593)\n#define LOBE_SCALE_11 vec2(0.8533333, 1.0612245)\n#define LOBE_BIAS_11 vec2(-0.8392287, 0.7346939)\n#endif\n\nvec2 uvFromBasis(const in vec3 lobeMean, \n                 const in vec3 lobeTangent, \n                 const in vec3 lobeBitangent,\n                 const in vec2 lobeScale,\n                 const in vec2 lobeBias,\n                 const in vec3 positionWorldSpace) {\n\tvec3 positionLobeSpace = positionWorldSpace * mat3(lobeTangent, lobeBitangent, lobeMean);\n\n\treturn positionLobeSpace.xy * lobeScale + lobeBias;\n}\n\n// source: SIMD / GPU Friendly Branchless Binary Search\n// https://blog.demofox.org/2017/06/20/simd-gpu-friendly-branchless-binary-search/\nint binarySearch3(float needle, const float haystack[3])\n{\n    // non perfect power of 2.  use min() to keep it from going out of bounds.\n    int res = 0;\n    int testIndex = 0;\n    \n    // Test index is 2, so is within range.\n    testIndex = res + 2;\n    res = (haystack[testIndex] <= needle) ? testIndex : res;\n    \n    // Test index is at most 3, so could be out of range.\n    // Use min() to make sure the index stays in range.\n    testIndex = min(res + 1, 2);\n    res = (haystack[testIndex] <= needle) ? testIndex : res;\n    \n    return res;\n}\n\nint binarySearch4(float needle, const float haystack[4])\n{\n    int res = (haystack[2] <= needle) ? 2 : 0;\n    res += (haystack[res + 1] <= needle) ? 1 : 0;\n    return res;\n}\n\nint binarySearch5(float needle, const float haystack[5])\n{\n    // Non perfect power of 2.  use min() to keep it from going out of bounds.\n    int res = 0;\n    int testIndex = 0;\n    \n    // Test index is 4, so is within range.\n    testIndex = res + 4;\n    res = (haystack[testIndex] <= needle) ? testIndex : res;\n \n    // Test index is at most 6, so could be out of range.\n    // Use min() to make sure the index stays in range.\n    testIndex = min(res + 2, 5);\n    res = (haystack[testIndex] <= needle) ? testIndex : res;\n    \n    // Test index is at most 6, so could be out of range.\n    // Use min() to make sure the index stays in range.\n    testIndex = min(res + 1, 5);\n    res = (haystack[testIndex] <= needle) ? testIndex : res;\n      \n    return res;\n}\n\nint binarySearch7(float needle, const float haystack[7])\n{\n    // Non perfect power of 2.  use min() to keep it from going out of bounds.\n    int res = 0;\n    int testIndex = 0;\n    \n    // Test index is 4, so is within range.\n    testIndex = res + 4;\n    res = (haystack[testIndex] <= needle) ? testIndex : res;\n \n    // Test index is at most 6, so could be out of range.\n    // Use min() to make sure the index stays in range.\n    testIndex = min(res + 2, 7);\n    res = (haystack[testIndex] <= needle) ? testIndex : res;\n    \n    // Test index is at most 6, so could be out of range.\n    // Use min() to make sure the index stays in range.\n    testIndex = min(res + 1, 7);\n    res = (haystack[testIndex] <= needle) ? testIndex : res;\n      \n    return res;\n}\n\nint binarySearch9(float needle, const float haystack[9])\n{\n    // Non perfect power of 2.  use min() to keep it from going out of bounds.\n    int res = 0;\n    int testIndex = 0;\n    \n    // Test index is 8, so is within range.\n    testIndex = res + 8;\n    res = (haystack[testIndex] <= needle) ? testIndex : res;\n \n    // Test index is at most 12, so could be out of range.\n    // Use min() to make sure the index stays in range.\n    testIndex = min(res + 4, 9);\n    res = (haystack[testIndex] <= needle) ? testIndex : res;\n    \n    // Test index is at most 10, so could be out of range.\n    // Use min() to make sure the index stays in range.\n    testIndex = min(res + 2, 9);\n    res = (haystack[testIndex] <= needle) ? testIndex : res;\n    \n    // Test index is at most 10, so could be out of range.\n    // Use min() to make sure the index stays in range.\n    testIndex = min(res + 1, 9);\n    res = (haystack[testIndex] <= needle) ? testIndex : res;\n  \n    return res;\n}\n\nint binarySearch12(float needle, const float haystack[12])\n{\n    // Non perfect power of 2.  use min() to keep it from going out of bounds.\n    int res = 0;\n    int testIndex = 0;\n    \n    // Test index is 8, so is within range.\n    testIndex = res + 8;\n    res = (haystack[testIndex] <= needle) ? testIndex : res;\n \n    // Test index is at most 12, so could be out of range.\n    // Use min() to make sure the index stays in range.\n    testIndex = min(res + 4, 11);\n    res = (haystack[testIndex] <= needle) ? testIndex : res;\n    \n    // Test index is at most 13, so could be out of range.\n    // Use min() to make sure the index stays in range.\n    testIndex = min(res + 2, 11);\n    res = (haystack[testIndex] <= needle) ? testIndex : res;\n    \n    // Test index is at most 12, so could be out of range.\n    // Use min() to make sure the index stays in range.\n    testIndex = min(res + 1, 11);\n    res = (haystack[testIndex] <= needle) ? testIndex : res;\n  \n    return res;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uvScreenSpace = (fragCoord.xy) / iResolution.xy;\n    \n    const float SPHERE_RADIUS = 0.75;\n    const float SPHERE_RADIUS_2 = SPHERE_RADIUS * SPHERE_RADIUS;\n    const float SPHERE_RADIUS_INVERSE = 1.0 / SPHERE_RADIUS;\n    \n    // Camera is orthographic.\n    float aspect = iResolution.x / iResolution.y;\n    vec2 positionScreenSpace = vec2(\n    \t(uvScreenSpace.x * 2.0 - 1.0) * aspect,\n        (uvScreenSpace.y * 2.0 - 1.0)\n    );\n    \n    if (dot(positionScreenSpace, positionScreenSpace) > SPHERE_RADIUS_2) {\n        // Render background color.\n    \tfragColor = vec4(vec3(0.25), 1.0);\n        return;\n    }\n    \n    // Reconstruct normal.\n    vec3 normalViewSpace;\n    normalViewSpace.xz = positionScreenSpace * SPHERE_RADIUS_INVERSE;\n    normalViewSpace.y = -sqrt(1.0 - dot(normalViewSpace.xz, normalViewSpace.xz));\n    \n    // Transform normal from view to world space, as if camera is\n    // rotating about the Z plane, and tilted slightly downward.\n    float cameraThetaWorldSpace = (iMouse.x / iResolution.x) * -PI * 2.0 - PI;\n    float cameraPhiWorldSpace = PI * (iMouse.y / iResolution.y - 0.5);// * sin(iTime * 2.0);\n    vec3 n = normalViewSpace;\n    \n    // Euler rotation about the X axis.\n    n = vec3(\n    \tn.x,\n        cos(cameraPhiWorldSpace) * n.y - sin(cameraPhiWorldSpace) * n.z,\n        sin(cameraPhiWorldSpace) * n.y + cos(cameraPhiWorldSpace) * n.z\n    );\n    \n    // Euler rotation about the Z axis.\n    n = vec3(\n        cos(cameraThetaWorldSpace) * n.x - sin(cameraThetaWorldSpace) * n.y,\n        sin(cameraThetaWorldSpace) * n.x + cos(cameraThetaWorldSpace) * n.y,\n    \tn.z\n    );\n\n    vec3 normalWorldSpace = n;\n    vec3 positionWorldSpace = normalWorldSpace * SPHERE_RADIUS;\n    \n    vec3 col;\n    \n    // Compute lobe weights.\n    float nDotM0 = 1.0 - abs(dot(LOBE_MEAN_0, normalWorldSpace));\n    float nDotM1 = 1.0 - abs(dot(LOBE_MEAN_1, normalWorldSpace));\n    float nDotM2 = 1.0 - abs(dot(LOBE_MEAN_2, normalWorldSpace));\n    float lobeWeight0 = exp2(-LOBE_SHARPNESS * pow(nDotM0, SUPER_GAUSSIAN_SHARPNESS));\n    float lobeWeight1 = exp2(-LOBE_SHARPNESS * pow(nDotM1, SUPER_GAUSSIAN_SHARPNESS));\n    float lobeWeight2 = exp2(-LOBE_SHARPNESS * pow(nDotM2, SUPER_GAUSSIAN_SHARPNESS));\n\n    #if NUM_PLANES >= 4\n    float nDotM3 = 1.0 - abs(dot(LOBE_MEAN_3, normalWorldSpace));\n    float lobeWeight3 = exp2(-LOBE_SHARPNESS * pow(nDotM3, SUPER_GAUSSIAN_SHARPNESS));\n    #endif\n    #if NUM_PLANES >= 5\n    float nDotM4 = 1.0 - abs(dot(LOBE_MEAN_4, normalWorldSpace));\n    float lobeWeight4 = exp2(-LOBE_SHARPNESS * pow(nDotM4, SUPER_GAUSSIAN_SHARPNESS));\n    #endif\n    #if NUM_PLANES >= 7\n    float nDotM5 = 1.0 - abs(dot(LOBE_MEAN_5, normalWorldSpace));\n\tfloat nDotM6 = 1.0 - abs(dot(LOBE_MEAN_6, normalWorldSpace));\n    float lobeWeight5 = exp2(-LOBE_SHARPNESS * pow(nDotM5, SUPER_GAUSSIAN_SHARPNESS));\n    float lobeWeight6 = exp2(-LOBE_SHARPNESS * pow(nDotM6, SUPER_GAUSSIAN_SHARPNESS));\n    #endif\n    #if NUM_PLANES >= 9\n    float nDotM7 = 1.0 - abs(dot(LOBE_MEAN_7, normalWorldSpace));\n\tfloat nDotM8 = 1.0 - abs(dot(LOBE_MEAN_8, normalWorldSpace));\n    float lobeWeight7 = exp2(-LOBE_SHARPNESS * pow(nDotM7, SUPER_GAUSSIAN_SHARPNESS));\n    float lobeWeight8 = exp2(-LOBE_SHARPNESS * pow(nDotM8, SUPER_GAUSSIAN_SHARPNESS));\n    #endif\n    #if NUM_PLANES >= 12\n    float nDotM9 = 1.0 - abs(dot(LOBE_MEAN_9, normalWorldSpace));\n\tfloat nDotM10 = 1.0 - abs(dot(LOBE_MEAN_10, normalWorldSpace));\n   \tfloat nDotM11 = 1.0 - abs(dot(LOBE_MEAN_11, normalWorldSpace));\n    float lobeWeight9 = exp2(-LOBE_SHARPNESS * pow(nDotM9, SUPER_GAUSSIAN_SHARPNESS));\n    float lobeWeight10 = exp2(-LOBE_SHARPNESS * pow(nDotM10, SUPER_GAUSSIAN_SHARPNESS));\n    float lobeWeight11 = exp2(-LOBE_SHARPNESS * pow(nDotM11, SUPER_GAUSSIAN_SHARPNESS));\n    #endif\n    \n    float cdf[NUM_PLANES];\n    cdf[0] = 0.0;\n    cdf[1] = lobeWeight0;\n    cdf[2] = lobeWeight1 + cdf[1];\n    #if NUM_PLANES >= 4\n    cdf[3] = lobeWeight2 + cdf[2];\n    #endif\n    #if NUM_PLANES >= 5\n    cdf[4] = lobeWeight3 + cdf[3];\n    #endif\n    #if NUM_PLANES >= 7\n    cdf[5] = lobeWeight4 + cdf[4];\n    cdf[6] = lobeWeight5 + cdf[5];\n    #endif\n    #if NUM_PLANES >= 9\n    cdf[7] = lobeWeight6 + cdf[6];\n    cdf[8] = lobeWeight7 + cdf[7];\n    #endif\n    #if NUM_PLANES >= 12\n    cdf[9] = lobeWeight8 + cdf[8];\n    cdf[10] = lobeWeight9 + cdf[9];\n    cdf[11] = lobeWeight10 + cdf[10];\n    #endif\n    \n    #if NUM_PLANES == 3\n    float lobeWeightSum = cdf[NUM_PLANES - 1] + lobeWeight2;\n    #elif NUM_PLANES == 4\n    float lobeWeightSum = cdf[NUM_PLANES - 1] + lobeWeight3;\n    #elif NUM_PLANES == 5\n    float lobeWeightSum = cdf[NUM_PLANES - 1] + lobeWeight4;\n    #elif NUM_PLANES == 7\n    float lobeWeightSum = cdf[NUM_PLANES - 1] + lobeWeight6;\n    #elif NUM_PLANES == 9\n    float lobeWeightSum = cdf[NUM_PLANES - 1] + lobeWeight8;\n    #elif NUM_PLANES == 12\n    float lobeWeightSum = cdf[NUM_PLANES - 1] + lobeWeight11;\n    #endif\n    \n    float lobeWeightNormalization = 1.0 / lobeWeightSum;\n        \n#if DISPLAY == DISPLAY_STOCHASTIC\n    float random = hashMcguire(fragCoord.xy + vec2(iTime, 0.0));\n    float randomCdf = random * lobeWeightSum;\n    #if NUM_PLANES == 3\n    int lobeIndex = binarySearch3(randomCdf, cdf);\n    #elif NUM_PLANES == 4\n    int lobeIndex = binarySearch4(randomCdf, cdf);\n    #elif NUM_PLANES == 5\n    int lobeIndex = binarySearch5(randomCdf, cdf);\n    #elif NUM_PLANES == 7\n    int lobeIndex = binarySearch7(randomCdf, cdf);\n    #elif NUM_PLANES == 9\n    int lobeIndex = binarySearch9(randomCdf, cdf);\n    #elif NUM_PLANES == 12\n    int lobeIndex = binarySearch12(randomCdf, cdf);\n    #endif\n    \n    const vec3 lobesMeans[NUM_PLANES] = vec3[NUM_PLANES](\n        LOBE_MEAN_0\n\t\t, LOBE_MEAN_1\n\t\t, LOBE_MEAN_2\n        #if NUM_PLANES >= 4\n\t\t, LOBE_MEAN_3\n        #endif\n        #if NUM_PLANES >= 5\n\t\t, LOBE_MEAN_4\n        #endif\n        #if NUM_PLANES >= 7\n        , LOBE_MEAN_5\n        , LOBE_MEAN_6\n        #endif\n        #if NUM_PLANES >= 9\n        , LOBE_MEAN_7\n        , LOBE_MEAN_8\n        #endif\n        #if NUM_PLANES >= 12\n        , LOBE_MEAN_9\n        , LOBE_MEAN_10\n        , LOBE_MEAN_11\n        #endif\n    );\n    \n    const vec3 lobesTangents[NUM_PLANES] = vec3[NUM_PLANES](\n        LOBE_TANGENT_0\n\t\t, LOBE_TANGENT_1\n\t\t, LOBE_TANGENT_2\n        #if NUM_PLANES >= 4\n\t\t, LOBE_TANGENT_3\n        #endif\n        #if NUM_PLANES >= 5\n\t\t, LOBE_TANGENT_4\n        #endif\n        #if NUM_PLANES >= 7\n        , LOBE_TANGENT_5\n        , LOBE_TANGENT_6\n        #endif\n        #if NUM_PLANES >= 9\n        , LOBE_TANGENT_7\n        , LOBE_TANGENT_8\n        #endif\n        #if NUM_PLANES >= 12\n        , LOBE_TANGENT_9\n        , LOBE_TANGENT_10\n        , LOBE_TANGENT_11\n        #endif\n    );\n    \n    const vec3 lobesBitangents[NUM_PLANES] = vec3[NUM_PLANES](\n    \tLOBE_BITANGENT_0\n    \t, LOBE_BITANGENT_1\n    \t, LOBE_BITANGENT_2\n        #if NUM_PLANES >= 4\n    \t, LOBE_BITANGENT_3\n        #endif\n        #if NUM_PLANES >= 5\n    \t, LOBE_BITANGENT_4\n        #endif\n        #if NUM_PLANES >= 7\n        , LOBE_BITANGENT_5\n        , LOBE_BITANGENT_6\n        #endif\n        #if NUM_PLANES >= 9\n        , LOBE_BITANGENT_7\n        , LOBE_BITANGENT_8\n        #endif\n        #if NUM_PLANES >= 12\n        , LOBE_BITANGENT_9\n        , LOBE_BITANGENT_10\n        , LOBE_BITANGENT_11\n        #endif\n    );\n    \n    const vec2 lobesScales[NUM_PLANES] = vec2[NUM_PLANES](\n      LOBE_SCALE_0\n      , LOBE_SCALE_1\n      , LOBE_SCALE_2\n      #if NUM_PLANES >= 4\n      , LOBE_SCALE_3\n      #endif\n      #if NUM_PLANES >= 5\n      , LOBE_SCALE_4\n      #endif\n      #if NUM_PLANES >= 7\n      , LOBE_SCALE_5\n      , LOBE_SCALE_6\n      #endif\n      #if NUM_PLANES >= 9\n      , LOBE_SCALE_7\n      , LOBE_SCALE_8\n      #endif\n      #if NUM_PLANES >= 12\n      , LOBE_SCALE_9\n      , LOBE_SCALE_10\n      , LOBE_SCALE_11\n      #endif\n    );\n    \n    const vec2 lobesBiases[NUM_PLANES] = vec2[NUM_PLANES](\n      LOBE_BIAS_0\n      , LOBE_BIAS_1\n      , LOBE_BIAS_2\n      #if NUM_PLANES >= 4\n      , LOBE_BIAS_3\n      #endif\n      #if NUM_PLANES >= 5\n      , LOBE_BIAS_4\n      #endif\n      #if NUM_PLANES >= 7\n      , LOBE_BIAS_5\n      , LOBE_BIAS_6\n      #endif\n      #if NUM_PLANES >= 9\n      , LOBE_BIAS_7\n      , LOBE_BIAS_8\n      #endif\n      #if NUM_PLANES >= 12\n      , LOBE_BIAS_9\n      , LOBE_BIAS_10\n      , LOBE_BIAS_11\n      #endif\n    );\n    \n\tvec2 lobeUv = uvFromBasis(lobesMeans[lobeIndex], \n                              lobesTangents[lobeIndex], \n                              lobesBitangents[lobeIndex],\n                              lobesScales[lobeIndex],\n                              lobesBiases[lobeIndex],\n                              positionWorldSpace);\n\n    // To support mip-mapped filtering, we need to manually compute our texture gradient,\n    // because due to per-pixel dither, our 2x2 neighborhood may not sample from the same\n    // plane.\n    vec3 positionWorldSpaceDfdx = dFdx(positionWorldSpace);\n    vec3 positionWorldSpaceDfdy = dFdy(positionWorldSpace);\n    vec3 positionWorldSpaceSampleX = positionWorldSpace + positionWorldSpaceDfdx;\n    vec3 positionWorldSpaceSampleY = positionWorldSpace + positionWorldSpaceDfdy;\n    vec2 lobeUvSampleX = uvFromBasis(lobesMeans[lobeIndex], \n                                     lobesTangents[lobeIndex],\n                                     lobesBitangents[lobeIndex],\n                                     lobesScales[lobeIndex],\n                                     lobesBiases[lobeIndex],\n                                     positionWorldSpaceSampleX);\n    vec2 lobeUvSampleY = uvFromBasis(lobesMeans[lobeIndex], \n                                     lobesTangents[lobeIndex],\n                                     lobesBitangents[lobeIndex],\n                                     lobesScales[lobeIndex],\n                                     lobesBiases[lobeIndex],\n                                     positionWorldSpaceSampleY);\n    vec2 lobeUvGradX = lobeUvSampleX - lobeUv;\n    vec2 lobeUvGradY = lobeUvSampleY - lobeUv;\n    vec3 lobeAlbedo = rgbFromSrgb(textureGrad(iChannel0, lobeUv, lobeUvGradX, lobeUvGradY).rgb);\n    col = lobeAlbedo;\n#endif\n\n#if DISPLAY == DISPLAY_GROUND_TRUTH\n\tvec2 lobeUv0 = uvFromBasis(LOBE_MEAN_0, LOBE_TANGENT_0, LOBE_BITANGENT_0, LOBE_SCALE_0, LOBE_BIAS_0, positionWorldSpace);\n    vec2 lobeUv1 = uvFromBasis(LOBE_MEAN_1, LOBE_TANGENT_1, LOBE_BITANGENT_1, LOBE_SCALE_1, LOBE_BIAS_1, positionWorldSpace);\n    vec2 lobeUv2 = uvFromBasis(LOBE_MEAN_2, LOBE_TANGENT_2, LOBE_BITANGENT_2, LOBE_SCALE_2, LOBE_BIAS_2, positionWorldSpace); \n#if NUM_PLANES >= 4\n    vec2 lobeUv3 = uvFromBasis(LOBE_MEAN_3, LOBE_TANGENT_3, LOBE_BITANGENT_3, LOBE_SCALE_3, LOBE_BIAS_3, positionWorldSpace);\n#endif\n#if NUM_PLANES >= 5\n    vec2 lobeUv4 = uvFromBasis(LOBE_MEAN_4, LOBE_TANGENT_4, LOBE_BITANGENT_4, LOBE_SCALE_4, LOBE_BIAS_4, positionWorldSpace);\n#endif\n#if NUM_PLANES >= 7\n    vec2 lobeUv5 = uvFromBasis(LOBE_MEAN_5, LOBE_TANGENT_5, LOBE_BITANGENT_5, LOBE_SCALE_5, LOBE_BIAS_5, positionWorldSpace);\n    vec2 lobeUv6 = uvFromBasis(LOBE_MEAN_6, LOBE_TANGENT_6, LOBE_BITANGENT_6, LOBE_SCALE_6, LOBE_BIAS_6, positionWorldSpace);\n#endif\n#if NUM_PLANES >= 9\n    vec2 lobeUv7 = uvFromBasis(LOBE_MEAN_7, LOBE_TANGENT_7, LOBE_BITANGENT_7, LOBE_SCALE_7, LOBE_BIAS_7, positionWorldSpace);\n    vec2 lobeUv8 = uvFromBasis(LOBE_MEAN_8, LOBE_TANGENT_8, LOBE_BITANGENT_8, LOBE_SCALE_8, LOBE_BIAS_8, positionWorldSpace);\n#endif\n#if NUM_PLANES >= 12\n    vec2 lobeUv9 = uvFromBasis(LOBE_MEAN_9, LOBE_TANGENT_9, LOBE_BITANGENT_9, LOBE_SCALE_9, LOBE_BIAS_9, positionWorldSpace);\n    vec2 lobeUv10 = uvFromBasis(LOBE_MEAN_10, LOBE_TANGENT_10, LOBE_BITANGENT_10, LOBE_SCALE_10, LOBE_BIAS_10, positionWorldSpace);\n    vec2 lobeUv11 = uvFromBasis(LOBE_MEAN_11, LOBE_TANGENT_11, LOBE_BITANGENT_11, LOBE_SCALE_11, LOBE_BIAS_11, positionWorldSpace);\n#endif\n    \n    vec3 lobeAlbedo0 = rgbFromSrgb(texture(iChannel0, lobeUv0).rgb);\n    vec3 lobeAlbedo1 = rgbFromSrgb(texture(iChannel0, lobeUv1).rgb);\n    vec3 lobeAlbedo2 = rgbFromSrgb(texture(iChannel0, lobeUv2).rgb);\n#if NUM_PLANES >= 4\n    vec3 lobeAlbedo3 = rgbFromSrgb(texture(iChannel0, lobeUv3).rgb);\n#endif\n#if NUM_PLANES >= 5\n    vec3 lobeAlbedo4 = rgbFromSrgb(texture(iChannel0, lobeUv4).rgb);\n#endif\n#if NUM_PLANES >= 7\n    vec3 lobeAlbedo5 = rgbFromSrgb(texture(iChannel0, lobeUv5).rgb);\n    vec3 lobeAlbedo6 = rgbFromSrgb(texture(iChannel0, lobeUv6).rgb);\n#endif\n#if NUM_PLANES >= 9\n    vec3 lobeAlbedo7 = rgbFromSrgb(texture(iChannel0, lobeUv7).rgb);\n    vec3 lobeAlbedo8 = rgbFromSrgb(texture(iChannel0, lobeUv8).rgb);\n#endif\n#if NUM_PLANES >= 12\n    vec3 lobeAlbedo9 = rgbFromSrgb(texture(iChannel0, lobeUv9).rgb);\n    vec3 lobeAlbedo10 = rgbFromSrgb(texture(iChannel0, lobeUv10).rgb);\n    vec3 lobeAlbedo11 = rgbFromSrgb(texture(iChannel0, lobeUv11).rgb);\n#endif\n    \n    col = lobeAlbedo0 * lobeWeight0\n        + lobeAlbedo1 * lobeWeight1\n        + lobeAlbedo2 * lobeWeight2\n#if NUM_PLANES >= 4\n\t\t+ lobeAlbedo3 * lobeWeight3\n#endif\n#if NUM_PLANES >= 5\n\t\t+ lobeAlbedo4 * lobeWeight4\n#endif\n#if NUM_PLANES >= 7\n\t\t+ lobeAlbedo5 * lobeWeight5\n        + lobeAlbedo6 * lobeWeight6\n#endif\n#if NUM_PLANES >= 9\n\t\t+ lobeAlbedo7 * lobeWeight7\n        + lobeAlbedo8 * lobeWeight8\n#endif\n#if NUM_PLANES >= 12\n\t\t+ lobeAlbedo9 * lobeWeight9\n        + lobeAlbedo10 * lobeWeight10\n        + lobeAlbedo11 * lobeWeight11\n#endif\n\t;\n\n    col *= lobeWeightNormalization;\n#endif\n\n    col = clamp(col, vec3(0.0), vec3(1.0));    \n    col = srgbFromRgb(col);\n\n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}","name":"Buf A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define PI 3.1415926\n#define DISPLAY_GROUND_TRUTH 0\n#define DISPLAY_STOCHASTIC 1\n#define DISPLAY DISPLAY_STOCHASTIC\n\nfloat rgbFromSrgbScalar(const in float value) {\n\treturn value <= 0.04045 ? (value * 0.07739938) : pow(value * 0.94786730 + 0.052132701, 2.4);\n}\n\nvec3 rgbFromSrgb(const in vec3 color) {\n    return vec3(\n        rgbFromSrgbScalar(color.r),\n        rgbFromSrgbScalar(color.g),\n        rgbFromSrgbScalar(color.b)\n    );\n}\n\nfloat srgbFromRgbScalar(const in float value) {\n  return value <= 0.0031308 ? (value * 12.92) : (pow(value, 1.0 / 2.4) * 1.055 - 0.055);\n}\n\nvec3 srgbFromRgb(const in vec3 color) {\n  return vec3(\n  srgbFromRgbScalar(color.r),\n  srgbFromRgbScalar(color.g),\n  srgbFromRgbScalar(color.b)\n  );\n}\n\nvec3 ycocgFromRgb(const in vec3 rgbColor) {\n  float g = rgbColor.g * 0.5;\n  float rb = rgbColor.r + rgbColor.b;\n\n  vec3 ycocg;\n  ycocg.x = rb * 0.25 + g;\n  ycocg.y = 0.5 * (rgbColor.r - rgbColor.b);\n  ycocg.z = rb * -0.25 + g;\n\n  return ycocg;\n}\n\nvec3 rgbFromYcocg(const in vec3 ycocgColor) {\n  vec3 rgbColor;\n  float xz = ycocgColor.x - ycocgColor.z;\n\n  rgbColor.r = xz + ycocgColor.y;\n  rgbColor.g = ycocgColor.x + ycocgColor.z;\n  rgbColor.b = xz - ycocgColor.y;\n\n  return rgbColor;\n}\n\nfloat hashShaderToy(const in vec2 n) {\n  return fract(sin(dot(n.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n// graphics.cs.williams.edu/dropbox/hashed-alpha-paper.pdf\nfloat hashMcguire(const in vec2 n) {\n  return fract(1.0e4 * sin(1.70 * n.x + 0.1 * n.y)\n    * (0.1 + abs(sin(13.0 * n.y + n.x)))\n  );\n}\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// TAA\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uvCurrent = fragCoord / iResolution.xy;\n    \n    #if DISPLAY == DISPLAY_STOCHASTIC\n    vec4 sampleCurrent = texture(iChannel0, uvCurrent);\n    vec4 samplePrevious = texture(iChannel1, uvCurrent);\n    \n    vec2 uvN = (fragCoord + vec2(0.0, 1.0)) / iResolution.xy;\n    vec2 uvS = (fragCoord + vec2(0.0, -1.0)) / iResolution.xy;\n    vec2 uvW = (fragCoord + vec2(-1.0, 0.0)) / iResolution.xy;\n    vec2 uvE = (fragCoord + vec2(1.0, 0.0)) / iResolution.xy;\n    vec2 uvNW = (fragCoord + vec2(-1.0, 1.0)) / iResolution.xy;\n    vec2 uvNE = (fragCoord + vec2(1.0, 1.0)) / iResolution.xy;\n    vec2 uvSW = (fragCoord + vec2(-1.0, -1.0)) / iResolution.xy;\n    vec2 uvSE = (fragCoord + vec2(1.0, -1.0)) / iResolution.xy;\n    \n    vec4 sampleCurrentN = texture(iChannel0, uvN);\n    vec4 sampleCurrentS = texture(iChannel0, uvS);\n    vec4 sampleCurrentW = texture(iChannel0, uvW);\n    vec4 sampleCurrentE = texture(iChannel0, uvE);\n    vec4 sampleCurrentNW = texture(iChannel0, uvNW);\n    vec4 sampleCurrentNE = texture(iChannel0, uvNE);\n    vec4 sampleCurrentSW = texture(iChannel0, uvSW);\n    vec4 sampleCurrentSE = texture(iChannel0, uvSE);\n    \n    sampleCurrent.rgb = rgbFromSrgb(sampleCurrent.rgb);\n    sampleCurrentN.rgb = rgbFromSrgb(sampleCurrentN.rgb);\n    sampleCurrentS.rgb = rgbFromSrgb(sampleCurrentS.rgb);\n    sampleCurrentW.rgb = rgbFromSrgb(sampleCurrentW.rgb);\n    sampleCurrentE.rgb = rgbFromSrgb(sampleCurrentE.rgb);\n    sampleCurrentNW.rgb = rgbFromSrgb(sampleCurrentNW.rgb);\n    sampleCurrentNE.rgb = rgbFromSrgb(sampleCurrentNE.rgb);\n    sampleCurrentSW.rgb = rgbFromSrgb(sampleCurrentSW.rgb);\n    sampleCurrentSE.rgb = rgbFromSrgb(sampleCurrentSE.rgb);\n    \n    sampleCurrent.xyz = ycocgFromRgb(sampleCurrent.rgb);\n    sampleCurrentN.xyz = ycocgFromRgb(sampleCurrentN.rgb);\n    sampleCurrentS.xyz = ycocgFromRgb(sampleCurrentS.rgb);\n    sampleCurrentW.xyz = ycocgFromRgb(sampleCurrentW.rgb);\n    sampleCurrentE.xyz = ycocgFromRgb(sampleCurrentE.rgb);\n    sampleCurrentNW.xyz = ycocgFromRgb(sampleCurrentNW.rgb);\n    sampleCurrentNE.xyz = ycocgFromRgb(sampleCurrentNE.rgb);\n    sampleCurrentSW.xyz = ycocgFromRgb(sampleCurrentSW.rgb);\n    sampleCurrentSE.xyz = ycocgFromRgb(sampleCurrentSE.rgb);\n    \n    vec3 sampleCurrentMin = \n        min(\n            min(\n                min(\n                    min(sampleCurrent.xyz, sampleCurrentN.xyz),\n                    min(sampleCurrentS.xyz, sampleCurrentW.xyz)\n                ),\n                min(\n                    min(sampleCurrentE.xyz, sampleCurrentNW.xyz),\n                    min(sampleCurrentNE.xyz, sampleCurrentSW.xyz)\n                )\n            ),\n            sampleCurrentSE.xyz\n        );\n    \n\tvec3 sampleCurrentMax = \n        max(\n            max(\n                max(\n                    max(sampleCurrent.xyz, sampleCurrentN.xyz),\n                    max(sampleCurrentS.xyz, sampleCurrentW.xyz)\n                ),\n                max(\n                    max(sampleCurrentE.xyz, sampleCurrentNW.xyz),\n                    max(sampleCurrentNE.xyz, sampleCurrentSW.xyz)\n                )\n            ),\n            sampleCurrentSE.xyz\n        );\n\n    samplePrevious.rgb = rgbFromSrgb(samplePrevious.rgb);\n    samplePrevious.xyz = ycocgFromRgb(samplePrevious.rgb);\n    \n    samplePrevious.xyz = clamp(samplePrevious.xyz, sampleCurrentMin, sampleCurrentMax);\n    fragColor = mix(sampleCurrent, samplePrevious, 0.94);\n    \n    fragColor.rgb = rgbFromYcocg(fragColor.xyz);\n    fragColor.rgb = srgbFromRgb(fragColor.rgb);\n    #else\n    fragColor = texture(iChannel0, uvCurrent);\n    #endif\n\n}","name":"Buf B","description":"","type":"buffer"}]}