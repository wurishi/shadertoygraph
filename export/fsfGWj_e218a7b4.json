{"ver":"0.1","info":{"id":"fsfGWj","date":"1616699492","viewed":101,"name":"Projet Synthèse d'Images // QUIN","username":"quinthomas","description":"Rendu du projet de Synthèse d'Images","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["raytracing","raycasting"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//QUIN Thomas ING3 VISUAL\n//Rendu du projet Synthèse d'Images\n\n//Fonctionnalités présentes : \n// - Raytracing étendu\n// - Antialiasing\n// - Lumières multiples\n// - Motion blur\n\n//##############################################################################################\n\n//PARAMETERS\n//##############################################################################################\n//Material Structure\nstruct Material\n{\n    float Ka;\t// ambiant coefficient\n    float Kd;\t// diffuse coefficient\n    float Ks;\t// specular coefficient\n    float Kn;\t// specular power coefficient\n};\n\n//Structure which represents shade informations\nstruct ShadeInfo\n{\n    vec3 shadeCol;\n    float Ks;\n};\n\n//Structure which represents light informations\nstruct LightInfo\n{\n    vec3 pos;\n    vec3 col;\n    float power;\n};\n    \n//Maximum number of bounce allowed for a ray    \nconst int MAX_NB_BOUNCES = 5;\n\n//Camera parameters\nvec3 cameraPos = vec3(6,4,-5);\nconst vec3 cameraTarget = vec3(3,1,-8);\nconst float cameraFovY = 80.0;\n\n//Sphere parameters\nvec3 spherePos = cameraTarget + vec3(0,1,2);\nconst float sphereRadius = 1.0;\nconst vec3 sphereCol = vec3(0,0,1);\nconst Material sphereMat = Material(0.2/*Ka*/,0.7/*Kd*/,1.0/*Ks*/,50.0/*Kn*/);\nconst int sphereId = 1;\n\n//Light parameters\nconst vec3 ambiantCol = vec3(0,0,1);\n\n//Light 1\nconst vec3 light1Col = vec3(1,1,1);\nvec3 light1Pos = vec3(8,10,-12);\nconst float light1Pow = 0.8;\n\n//Light 2\nconst vec3 light2Col = vec3(1,1,0.5);\nvec3 light2Pos = vec3(3,10,1);\nconst float light2Pow = 0.5;\n\n//You can edit this value, but have to create more parameters for each light you add\nconst int NB_LIGHTS = 2;\n\nLightInfo lights[NB_LIGHTS];\n\n//Sky parameters\nconst vec3 skyCol = vec3(0);\nconst int skyId = 0;\n\n//Plane parameters\nconst vec3 planePos = vec3(0, 0.1, 0);\nconst vec3 planeNormal = vec3(0,1.0,0);\nconst vec3 planeCol1 = vec3(1.0);\nconst vec3 planeCol2 = vec3(0.4);\nconst Material planeMat = Material(0.2/*Ka*/,1.0/*Kd*/,0.2/*Ks*/,5.0/*Kn*/);\nconst int planeId = 2;\n\n//Antialiasing constant, you are free to edit this value, this may have a impact on the antialiasing visual effect\nconst int ANTIALIASING = 5;\n\n//Motion blur constants\nconst int MOTION_BLUR = 5;\nconst float MOTION_BLUR_TIME = 0.0; // Useless\n\nfloat FLT_MAX = 9999999.9;\n\n//##############################################################################################\n\n// METHODS & CODE\n\n//##############################################################################################\n\n//Cast ray on sphere\nfloat raySphere(vec3 rayPos, vec3 rayDir, vec3 spherePos, float sphereRadius, out vec3 intersecS, out vec3 normalS)\n{    \n    vec3 diff = rayPos - spherePos;\n    \n    float a = dot(rayDir,rayDir);\n    float b = 2.0 * dot(diff,rayDir);\n    float c = dot(diff,diff) - sphereRadius * sphereRadius;\n    \n    float di = b*b - 4.0*a*c;\n    \n    if(di >= 0.0)\n    {\n        float sdi = sqrt(di);\n        float den = 1.0 / (2.0 * a);\n        float t1 = (-b - sdi) * den;\n        float t2 = (-b + sdi) * den;\n        \n        intersecS = rayPos + t1 * rayDir;\n        normalS = normalize(intersecS - spherePos);\n        \n        return t1;\n    }\n    \n    return -1.;\n}\n\n//----------------------------------------------------------------------------------------------\n\n//Cast ray on plane\nfloat rayPlane(vec3 rayPos, vec3 rayDir, vec3 planePos, vec3 planeNormal, out vec3 intersecPt, out vec3 normal)\n{\n    if(dot(rayDir,planeNormal)!=0.0)\n    {\n        float t = dot(planePos - rayPos,planeNormal)/dot(rayDir,planeNormal);\n        \n        intersecPt = rayPos + t * rayDir;\n        normal = planeNormal;\n        \n        return t;\n    }\n    return -1.0;\n}\n\n//----------------------------------------------------------------------------------------------\n\n//Cast ray and find the nearest intersection object\nfloat computeNearestIntersection(vec3 rayPos, vec3 rayDir, out int objectId, out vec3 intersecI, out vec3 normalI){\n    float minDist  = FLT_MAX;\n          objectId = skyId;\n    \n    //If it's a sphere\n    vec3 intersecS, normalS;\n    float distS = raySphere(rayPos, rayDir, spherePos, sphereRadius, intersecS, normalS);\n    if ((distS > 0.0) && (distS < minDist))\n    {\n        objectId  =  sphereId;\n        minDist   =     distS;\n        intersecI = intersecS;\n          normalI =   normalS;\n    }\n    \n    //If it's the plane\n    vec3 intersecP, normalP;\n    float distP =  rayPlane(rayPos, rayDir,  planePos,  planeNormal, intersecP, normalP);\n    if ((distP > 0.0) && (distP < minDist))\n    {\n        objectId  =   planeId;\n        minDist   =     distP;\n\t    intersecI = intersecP;\n    \t  normalI =   normalP;\n    }\n\n    if (objectId == skyId)\n        minDist = -1.0;\n    \n    return minDist;\n}\n\n//----------------------------------------------------------------------------------------------\n\n//Get the sphere color\nvec3 getSphereColorAtPoint(vec3 pt){\n    return sphereCol;\n}\n\n//----------------------------------------------------------------------------------------------\n\n//Get the plane color\nvec3 getPlaneColorAtPoint(vec3 pt){\n    return mod(floor(pt.x * 0.5) + floor(pt.z * 0.5), 2.0) < 1.0  ? planeCol1 : planeCol2;\n}\n\n\n//----------------------------------------------------------------------------------------------\n\n\n//Get the color of the object at the point\nvec3 getObjectColorAtPoint(int objectId, vec3 pt, out Material objectMat){\n   if (objectId == sphereId)\n    {\n        objectMat = sphereMat;\n        return getSphereColorAtPoint(pt);\n    }\n    else if (objectId == planeId)\n    {\n        objectMat = planeMat;\n        return getPlaneColorAtPoint(pt);\n    }\n        \n    return skyCol;\n}\n\n\n//----------------------------------------------------------------------------------------------\n\n//Throw ray from camera\nvoid computeCameraRayFromPixel(in vec2 pixCoord, out vec3 rayPos, out vec3 rayDir)\n{\n    rayPos = cameraPos;\n    \n    float f = 1./tan(radians(cameraFovY)/2.);\n    \n    vec3 PT = cameraTarget - cameraPos;\n    vec3 cz = normalize(PT);\n    \n    vec3 PO = f*cz;\n    \n    vec3 cyT = vec3(0,-1.,0);\n    vec3 cxT = cross(cyT,cz);\n    \n    vec3 cx = normalize(cxT);\n    \n    vec3 cy = cross(cz,cx);\n    \n    vec3 OS = pixCoord.x * cx - pixCoord.y * cy;\n    \n    rayDir = normalize(PO+OS);\n}\n\n//----------------------------------------------------------------------------------------------\n\n//Get the factor of shadow at the point\nfloat getShadowFactorAtPoint(vec3 I, vec3 N, Material objectMat, vec3 L, float Ldist)\n{\n    I += 0.001*N;\n    int objId;\n    vec3 intersecS, normalS;\n    float d = computeNearestIntersection(I,L,objId,intersecS,normalS);\n    return (d<=0.0 || d>=Ldist)?1.0:objectMat.Ka;\n}\n\n//----------------------------------------------------------------------------------------------\n\n//Phong Shading\nvec3 computePhongShading(vec3 sphereCol, Material sphereMat,float shadowFactor, vec3 normal, vec3 L, vec3 R, vec3 V, LightInfo light)\n{\n    vec3 A = sphereMat.Ka * ambiantCol / float(NB_LIGHTS);\n    vec3 D = sphereMat.Kd * sphereCol * light.col * light.power * max(dot(L,normal),0.0);\n    vec3 S = sphereMat.Ks * light.col * light.power  * pow(max(dot(R,V),0.0),sphereMat.Kn);\n    return A+shadowFactor*D+shadowFactor*S;\n}\n\n\n//----------------------------------------------------------------------------------------------\n\n//Throw ray at pixel coords\nvec3 RaytraceAtPixelCoord(vec2 pixCoord)\n{\n    vec3 rayPos, rayDir;\n    computeCameraRayFromPixel(pixCoord, rayPos, rayDir);\n    \n    ShadeInfo infos[MAX_NB_BOUNCES];\n    int nbBounces = 0;\n    do\n    {\n        int objectId;\n        vec3 intersecI, normalI;\n        float distI = computeNearestIntersection(rayPos,rayDir,objectId,intersecI,normalI);\n        \n        if(distI <= 0.0)\n        {\n            infos[nbBounces].shadeCol = skyCol;\n            infos[nbBounces].Ks = 0.0;\n            break;\n        }\n        \n        \n    \tvec3 V = -rayDir;\n        Material objMat;\n    \tvec3 col = getObjectColorAtPoint(objectId, intersecI, objMat);\n        \n        vec3 c = vec3(0.);\n        \n        for(int i=0;i<NB_LIGHTS;i++)\n        {\n    \t\tvec3 L = normalize(lights[i].pos - intersecI);\n    \t\tvec3 R = normalize(2.0*dot(normalI,L)*normalI - L);\n        \n        \tfloat Ldist = distance(intersecI,lights[i].pos);\n        \n        \tfloat shadowFactor = getShadowFactorAtPoint(intersecI, normalI, objMat, L, Ldist);\n        \n    \t\t//Phong shading to get the color of the surface point\n    \t\tc += computePhongShading(col, objMat, shadowFactor, normalI, L, R, V, lights[i]);\n        }\n        \n        \n        infos[nbBounces].shadeCol = c;\n        infos[nbBounces].Ks = objMat.Ks;\n        \n        rayPos = intersecI + 0.001*normalI;\n        rayDir = normalize(2.0*dot(normalI,V)*normalI - V);\n        \n        nbBounces++;\n        \n    }while(nbBounces < MAX_NB_BOUNCES);\n    \n    vec3 resCol = vec3(0);\n    \n   \tdo\n    {\n        resCol = infos[nbBounces].shadeCol + infos[nbBounces].Ks * resCol;\n        nbBounces--;\n    }while(nbBounces >= 0);\n    \n    return resCol;\n}\n\n//----------------------------------------------------------------------------------------------\n\n//Make noise (antialiasing)\nvec2 noise2(vec2 location, vec2 delta){\n    const vec2 c = vec2(12.9898, 78.233);\n    const float m = 43758.5453;\n    return vec2(\n        fract(sin(dot(location + delta, c))*m),\n        fract(sin(dot(location + vec2(delta.y, delta.x), c))*m)\n        );\n}\n\n//----------------------------------------------------------------------------------------------\n\n//Animate the scene\nvoid updateScene(float time)\n{  \n    cameraPos.xz = vec2(cos(time), sin(time)) * 4.0f;\n    light1Pos = vec3(cos(0.5 * time + 1.0), 2.0f, sin(0.5 * time + 1.0)) * 3.0f;\n    light2Pos = vec3(cos(0.5 * time), 2.0f, sin(0.5 * time)) * 2.0f;\n}\n\n//##############################################################################################\n\n//MAIN CODE\n\n//##############################################################################################\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time = iTime;\n    \n    //updateScene(time);\n    \n    //Edit this value to change the noise\n    float delta = 0.01;\n    \n    \n    \n    //Apply change of coordinates from pixel\n    fragCoord = (2. * fragCoord - iResolution.xy) / iResolution.y;;\n    \n    vec3 resCol;\n    for(int j=0 ;j<MOTION_BLUR;j++){\n        \n        //Modifying update time to have a difference between images\n        float time_blur = time + float(j) * iTimeDelta / float(MOTION_BLUR);\n        updateScene(time_blur* /*Up this value to have a better view point on motion blur*/4.0);\n        \n        lights[0].pos = light1Pos;\n        lights[0].col = light1Col;\n        lights[0].power = light1Pow;\n        lights[1].pos = light2Pos;\n        lights[1].col = light2Col;\n        lights[1].power = light2Pow;\n    \n        for (int i=0; i<ANTIALIASING; i++) \n        {\n            vec2 aa = noise2(fragCoord, vec2(delta)) / iResolution.xy;\n            resCol += RaytraceAtPixelCoord(fragCoord + aa);\n        }\n    }\n    resCol /= float(ANTIALIASING * MOTION_BLUR);\n\n    fragColor = vec4(resCol,1);\n}","name":"Image","description":"","type":"image"}]}