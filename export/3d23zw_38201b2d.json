{"ver":"0.1","info":{"id":"3d23zw","date":"1548447786","viewed":105,"name":"Moving Quadrangle","username":"karolina_obszynska","description":"Shader tworzy czworokąt, który ograniczony jest przez funkcje wyznaczane między sąsiednimi wierzchołkami w ruchu. Każdy z wierzchołków czworokąta porusza się po torze, który jest okręgiem. Wierzchołki poruszają się z różną prędkością.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["circles","time","function","motion","move","quadrangle"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Definiowanie stałej wartości, stała pkts jako stała, ciągła ilość wierzchołków, która wynosi 4, która będzie używana do definiowania tablic\nconst int pkts = 4;\nfloat r = 50.0;\n\n//Tworzenie fukcji zawierającej informacje czy dany piksel o przekazanych koordynatach zawiera się między bokami powstałymi na wierzchołkach\nbool zawiera(vec2 pixelcoord, vec2 polot[pkts]){\n    int is = 1;\n    float distx[pkts];\n    float disty[pkts];\n    //prawy bok i lewostronne ograniczenie koordynaty x\n    distx[0] = polot[0].x-polot[1].x;\n    disty[0] = polot[0].y-polot[1].y;\n    if (pixelcoord.x > (pixelcoord.y - polot[0].y)/disty[0]*distx[0]+polot[0].x) is=0;\n    //lewy bok i prawostronne ograniczenie koordynaty x\n    distx[2] = polot[2].x-polot[3].x;\n    disty[2] = polot[2].y-polot[3].y;\n    if (pixelcoord.x < (pixelcoord.y - polot[2].y)/disty[2]*distx[2]+polot[2].x) is=0;\n    //dolny bok i odgórne ograniczenie koordynaty y\n    distx[1] = polot[1].x-polot[2].x;\n    disty[1] = polot[1].y-polot[2].y;\n    if (pixelcoord.y < (pixelcoord.x - polot[1].x)/distx[1]*disty[1]+polot[1].y) is=0;\n    //górny bok i oddolne ograniczenie koordynaty y\n    distx[3] = polot[3].x-polot[0].x;\n    disty[3] = polot[3].y-polot[0].y;\n    if (pixelcoord.y > (pixelcoord.x - polot[3].x)/distx[3]*disty[3]+polot[3].y) is=0;\n    \n    //Zwracanie logicznej wartości całkowitej zmiennej\n    return bool(is);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //Przeniesienie punktu (0,0) na środek ekranu\n    vec2 zero = iResolution.xy/2.0;\n    //Definicja środków okręgów\n    vec2 punkt[pkts];\n     punkt[0] = zero + vec2(100.0, 100.0);\n     punkt[1] = zero + vec2(100.0, -100.0);\n     punkt[2] = zero + vec2(-100.0, -100.0);\n     punkt[3] = zero + vec2(-100.0, 100.0);\n    //polot jest to zmienna zawierająca pozycje wierzchołków\n    vec2 polot[pkts];\n    //Definiowanie kolorów\n    vec3 col1 = vec3(0.1, 0.2, 0.9);\n    vec3 col2 = vec3(0.0, 1.0, 0.0);\n    vec3 col3 = vec3(0.0, 0.0, 0.0);\n    vec3 col4 = vec3(0.8, 0.1, 0.1);\n    vec3 col5 = vec3(0.6, 0.6, 0.6);\n    vec3 pixel;\n    //Domyślne zamalowanie tła\n    pixel = col1;\n    \n    \n    //Wyrysowanie torór ruchu wierzchołków\n    for (int i=1; i<=pkts; i++)\n    {\n        float len = length(fragCoord - punkt[i-1]);\n        if (len < 5.0 ){\n            pixel=col2;\n        }\n        if (len > (r-1.0) && len < (r+1.0)) {pixel = col3;}\n    }\n    \n    //Wyrysowanie wierzchołków\n    for (int i=1; i<=pkts; i++)\n    {\n        polot[i-1].x = punkt[i-1].x-sin(iTime/float(i)*2.0)*r;\n        polot[i-1].y = punkt[i-1].y-cos(iTime/float(i)*2.0)*r;\n        float len=length(fragCoord - polot[i-1]);\n        if (len < 5.0) {pixel = col4;}\n    }\n    \n    //Sprawdzenie, czy piksel należy do czworokąta\n    if (zawiera(fragCoord, polot)) {pixel = col5;}\n    \n    //Rysowanie\n    fragColor = vec4(pixel, 1.0);\n}","name":"Image","description":"","type":"image"}]}