{"ver":"0.1","info":{"id":"4sKBW3","date":"1530799801","viewed":586,"name":"Ray marching practice 5","username":"lnae","description":"More glowing flowers","likes":23,"published":1,"flags":0,"usePreview":0,"tags":["3d","raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define STEPS 150.\n#define PI 3.14159\n#define EPS 0.0001\n#define EPSN 0.001\n\nmat2 rot(float a){\n\treturn mat2(cos(a), -sin(a), sin(a), cos(a));\n}\n\nfloat distSphere(vec3 pos, float r){\n\treturn length(pos) - r;\n}\n\nfloat distScene(in vec3 pos, out float colorVariation){\n    \n    pos.yz = rot(0.6) * pos.yz;\n    pos.xz = rot(0.6 + 0.3 * sin(0.5 * iTime)) * pos.xz;\n\tpos.y += 0.3;\n    \n    //repeat\n    vec2 q = floor((pos.xz - 0.75) / 1.5);\n    pos.xz = mod(pos.xz - 0.75, 1.5) - .75;\n    \n    float angle = atan(pos.z, pos.x);\n    float radius = length(pos.xz);\n    \n    //repeat petals around y\n    float div = 2. * PI / 8.;\n    float a = mod(angle, div) - 0.5 * div;\n    \n    //pointy petal\n    float r = radius + 0.25 * abs(a);\n    vec3 p = pos;\n    p.x = r * cos(a);\n    p.z = r * sin(a);\n    \n    p.z *= 2.;\n    p.x *= 0.8;\n    p.xy = rot(0.9 - sin(2. * sin(0.75 * iTime + 1.3 * (q.x + 0.5 * q.y))) * .75 * r) * p.xy;\n    p.y *= 10.;\n    float r2 = length(p.xz) + 0.25 * abs(a);\n    colorVariation = -0.3 * smoothstep(0., 0.2, abs(r2 - sin(4. * abs(2. * r2 - 0.5))));\n    float minDist = distSphere(p + vec3(-0.3, 0., 0.), 0.3);\n    \n    //sphere\n    float dist = distSphere(pos - vec3(0., 0.15, 0.), 0.05) + 0.005 * sin(8. * angle);\n    if(dist < minDist) colorVariation = .15;\n    minDist = min(minDist, dist);\n    \n    //floor\n    p = pos;\n    r = abs(smoothstep(0., 1., fract(radius * 3.5)) - 0.5);\n    float k = 4.;\n    float offset = sin( 0.5 * iTime);\n    float deform = abs( r - cos(k * angle) + offset);\n    deform = min(deform, abs( - r - cos(k * (angle + PI)) + offset));\n    deform = min(deform, abs( r - cos(k * (angle + PI / 4.)) + offset));\n    deform = min(deform, abs( - r - cos(k * (angle + 3. * PI / 4.)) + offset));\n    deform = 0.01 * (smoothstep(0., 0.15, deform) - smoothstep(0.15, 0.4, deform));\n    dist = 7.5 * (pos.y + deform);\n    if(dist < minDist) colorVariation = -.2;\n    minDist = min(minDist, dist);\n    \n    return 0.1 * minDist;\n}\n\nvec3 getNormal(vec3 p){\n    float c;\n\treturn normalize(vec3(distScene(p + vec3(EPSN, 0., 0.), c) - distScene(p - vec3(EPSN, 0., 0.), c),\n                          distScene(p + vec3(0., EPSN, 0.), c) - distScene(p - vec3(0., EPSN, 0.), c),\n                          distScene(p + vec3(0., 0., EPSN), c) - distScene(p - vec3(0., 0., EPSN), c)));\n}\n\nvec3 render(vec2 uv){\n    \n    //background\n\tvec3 col = vec3(0.2, 0.2, 0.2);\n    \n    vec3 eye = vec3(0., 0., 5.);\n    vec3 ray = normalize(vec3(uv, 3.) - eye);\n    \n    //raymarch\n    float step, dist, colorVariation;\n    bool hit = false;\n    vec3 pos = eye;\n    \n    for(step = 0.; step < STEPS; step++){\n    \tdist = distScene(pos, colorVariation);\n        if(abs(dist) < EPS){\n            hit = true;\n        \tbreak;\n        }\n        pos += ray * dist;\n    }\n    \n    vec3 normal = getNormal(pos);\n    \n    //color\n    if(hit) col = vec3(step / STEPS, 0.33, 0.66) + 0.25 * normal + colorVariation;\n    \n\treturn col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.x;\n    vec3 col = render(uv);\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}