{"ver":"0.1","info":{"id":"DlsGWH","date":"1671695304","viewed":157,"name":"Snow Sweep","username":"4LT","description":"Something wintry","likes":11,"published":1,"flags":0,"usePreview":0,"tags":["snowglobe"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float tau = 2. * acos(-1.);\n\nconst vec3 forward = vec3(0., 0., 1.);\nconst vec3 up = vec3(0., 1., 0.);\nconst vec3 right = vec3(-1., 0., 0.);\nconst vec3 cam = vec3(0., 0., -2.0);\nconst vec3 sph = vec3(0., 0., 0.);\n\nconst float ptCt = 200.;\nconst float speed = 1.;\n\nfloat t;\n\nfloat dist(vec3 rayDir) {\n    float minDist = 99999.;\n    for (float i = 0.; i < ptCt; i++) {\n        float iNorm = i / ptCt;\n        \n        vec4 denoms = vec4(0.243453, 0.4234345, 0.2357797, 0.165777341);\n        vec2 rand = mod(iNorm * vec2(1.3236574234, 0.934556756345), denoms.xy) / denoms.xy;\n        rand = mod(rand.yx, denoms.zw)/denoms.zw;\n        rand = mod(rand, denoms.xz)/denoms.xz;\n        rand = mod(rand.yx, denoms.yw)/denoms.yw;\n        \n        float phi = acos(1. - fract(rand.x + t/4.) * 2.);\n        float theta = rand.y * tau + t * (rand.x + iNorm + 2.)/4.;\n        \n        float horz = sin(phi);\n        vec3 iPos = vec3(horz * cos(theta), cos(phi), horz * sin(theta)) + sph;\n        \n        float iDist = length(rayDir * dot(rayDir, iPos - cam) + cam - iPos);\n        minDist = min(iDist, minDist);\n    }\n    \n    return minDist;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    t = iTime * speed;\n    vec2 uv = (fragCoord/iResolution.xy * 2. - 1.);\n    uv.x*= iResolution.x / iResolution.y;\n    vec3 rayDir = normalize(uv.x * right + uv.y * up + forward);\n    \n    float d = dist(rayDir);\n    if (d < 0.02) {\n        fragColor = vec4(1., 1., 1., 1.);\n    } else {\n        fragColor = vec4(0., 0., 0., 1.);\n    }\n}","name":"Image","description":"","type":"image"}]}