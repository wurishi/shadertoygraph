{"ver":"0.1","info":{"id":"lldXzX","date":"1480967075","viewed":105,"name":"Bryan's Sun","username":"bsugiarto","description":"Sun","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["sun"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdfGRn","filepath":"/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","previewfilepath":"/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/* Bryan Sugiarto Sun */\n\n/* PI constant */\nconst float MATH_PI = float( 3.14159265359 );\n\n/* this is the visibility of light based on  */\nfloat VisibilityTerm( float roughness, float ndotv, float ndotl )\n{\n    float m2    = roughness * roughness;\n    float visV  = ndotl * sqrt( ndotv * ( ndotv - ndotv * m2 ) + m2 );\n    float visL  = ndotv * sqrt( ndotl * ( ndotl - ndotl * m2 ) + m2 );\n    return 0.5 / max( visV + visL, 0.00001 );\n}\n\n/* this is the diffuse lighting from light */\nfloat DistributionTerm( float roughness, float ndoth )\n{\n    float m2    = roughness * roughness;\n    float d     = ( ndoth * m2 - ndoth ) * ndoth + 1.0;\n    return m2 / ( d * d * MATH_PI );\n}\n\n/* \nfresnel is the light reflected from refrecation\nhttp://www.graphics.cornell.edu/~westin/misc/fresnel.html\n*/\nvec3 FresnelTerm( vec3 specularColor, float vdoth )\n{\n    vec3 fresnel = clamp( 50.0 * specularColor.y, 0.0, 1.0 ) * specularColor + ( 1.0 - specularColor ) * pow( ( 1.0 - vdoth ), 5.0 );\n    return fresnel;\n}\n\n\n/* this light specular term is calculated by this function  */\nvec3 LightSpecular( vec3 normal, vec3 viewDir, vec3 lightDir, vec3 lightColor, float roughness, vec3 specularColor )\n{\n    vec3 halfVec = normalize( viewDir + lightDir );\n\n    float vdoth = clamp( dot( viewDir,  halfVec  ), 0.0, 1.0 );\n    float ndoth = clamp( dot( normal,   halfVec  ), 0.0, 1.0 );\n    float ndotv = clamp( dot( normal,   viewDir  ), 0.0, 1.0 );\n    float ndotl = clamp( dot( normal,   lightDir ), 0.0, 1.0 );\n    \n    vec3    f = FresnelTerm( specularColor, vdoth );\n    float   d = DistributionTerm( roughness, ndoth );\n    float   v = VisibilityTerm( roughness, ndotv, ndotl );\n    \n    vec3 specular;\n    specular = lightColor * f * ( d * v * MATH_PI * ndotl );\n    return specular;\n}\n\n\n/* these two functions return > 0 if there is a point*/ \nfloat Sphere( vec3 p, float s )\n{\n    return length( p ) - s;\n}\nfloat Scene( vec3 p, mat3 localToWorld )\n{\n    p = p * localToWorld;\n    \n    /* create a spere with radius 1 at p */\n    float a = Sphere( p, 1.0 );\n    return a;\n}\n\n/* this returns a float of whether the ray hits the object \n-1  = it doesn't it\nro = ray origin\nrd = ray direction\nlocalToWorld = transformations\n*/\nfloat CastRay( in vec3 ro, in vec3 rd, mat3 localToWorld )\n{\n    const float maxd = 5.0;\n    \n    float h = 0.5;\n    float t = 0.0;\n   \n    for ( int i = 0; i < 50; ++i )\n    {\n        if ( h < 0.001 || t > maxd ) \n        {\n            break;\n        }\n        \n        h = Scene( ro + rd * t, localToWorld );\n        t += h;\n    }\n\n    if ( t > maxd )\n    {\n        t = -1.0;\n    }\n    \n    return t;\n}\n\n/* Creates a vector of the scene's normal value */\nvec3 SceneNormal( in vec3 pos, mat3 localToWorld )\n{\n    vec3 eps = vec3( 0.001, 0.0, 0.0 );\n    vec3 nor = vec3(\n        Scene( pos + eps.xyy, localToWorld ) - Scene( pos - eps.xyy, localToWorld ),\n        Scene( pos + eps.yxy, localToWorld ) - Scene( pos - eps.yxy, localToWorld ),\n        Scene( pos + eps.yyx, localToWorld ) - Scene( pos - eps.yyx, localToWorld ) );\n    return normalize( -nor );\n}\n\n/* main function */\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 q = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * q;\n    p.x *= iResolution.x / iResolution.y;\n\n    vec3 rayOrigin  = vec3( 0.0, -0.28, -3.5 );\n    vec3 rayDir     = normalize( vec3( p.x, p.y, 2.0 ) );\n    \n\n    /* rotation */\n    float theta = -0.5 * MATH_PI ;\n    mat3 rotX = mat3(\n        vec3( cos( theta ), sin( theta ), 0.0 ),\n        vec3( -sin( theta ), cos( theta ), 0.0 ),\n        vec3( 0.0, 0.0, 1.0 )\n        );    \n    \n    vec2 mo = iMouse.xy / iResolution.xy;    \n    float phi = 0.25 * MATH_PI + 2.0 * iTime + 10.0 * mo.x;    \n    mat3 rotY = mat3(\n        vec3( 1.0, 0.0, 0.0 ),\n        vec3( 0.0, cos( phi ), sin( phi ) ),\n        vec3( 0.0, -sin( phi ), cos( phi ) )\n        );\n    mat3 localToWorld = rotX * rotY;    \n\n\n    vec3 color = texture( iChannel1, q ).yyy * 0.3;\n    \n    /* cast ray and see if it hits */\n    float t = CastRay( rayOrigin, rayDir, localToWorld );\n    if ( t > 0.0 )\n    {\n        /* t = z value */\n        vec3 pos = rayOrigin + t * rayDir;\n        vec3 normal = SceneNormal( pos, localToWorld );\n        vec3 lightDir = normalize( vec3( 0.5, 0.3, 1.0 ) );\n        vec3 lightColor = vec3( 1.6 );\n        \n        /* get position of \"hit\" */\n        vec3 posLS = pos * localToWorld;\n        vec3 nrmLS = normal * localToWorld;\n        vec2 uvX = posLS.yz;\n        vec2 uvY = posLS.xz;\n        vec2 uvZ = posLS.xy;\n\n        /* load texure based on hit position*/\n        vec3 textureX = texture( iChannel0, uvX ).xyz;\n        vec3 textureY = texture( iChannel0, uvY ).xyz;\n        vec3 textureZ = texture( iChannel0, uvZ ).xyz;\n        vec3 weights = max( abs( nrmLS ), 0.00001 );\n        weights /= weights.x + weights.y + weights.z;\n        vec3 texture = textureX * weights.x + textureY * weights.y + textureZ * weights.z;\n        texture = vec3(1., .4, .3) + texture;\n       \n\n        /* add difuse lightning */\n        vec3 diffuseColor = texture ;\n        diffuseColor *= diffuseColor * vec3( 0.94, 0.72, 0.47 ) * 1.5;\n        vec3 specularColor =  vec3( 0.04 ) ;\n        float roughness =  0.6 ;\n        vec3 diffuse = lightColor * clamp( dot( normal, lightDir ), 0.0, 1.0 );\n        color = diffuseColor * ( diffuse + 0.2 );\n        color += LightSpecular( normal, rayDir, lightDir, lightColor, roughness, specularColor );\n    }\n    \n    fragColor = vec4( color, 1.0 );\n}\n\n","name":"Image","description":"","type":"image"}]}