{"ver":"0.1","info":{"id":"MdcXW2","date":"1461613589","viewed":186,"name":"thumbsup","username":"Tapped","description":"Share whenever you feel that the like button on Facebook is too dull :thumbsup:","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["like","thumb","facebook","thumbsup"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float eps = 0.01;\n\nfloat sdCappedCylinder(in vec3 p, in vec2 h)\n{\n\tvec2 d = abs(vec2(length(p.xz),p.y)) - h;\n \treturn min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdCapsule(in vec3 p, in vec3 a, in vec3 b, in float r )\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\nfloat udRoundBox(in vec3 p, in vec3 b, in float r)\n{\n \treturn length(max(abs(p)-b,0.0))-r;\n}\n\nvec3 rotateZ(in vec3 p, float a)\n{\n    vec3 r;\n    r.x = p.x*cos(a) + p.y*sin(a);\n    r.y = p.x*sin(a) - p.y*cos(a);\n    r.z = p.z;\n    return r;\n}\n\nvec3 rotateY(in vec3 p, float a)\n{\n    vec3 r;\n    r.x = p.x*cos(a) + p.z*sin(a);\n    r.z = p.x*sin(a) - p.z*cos(a);\n    r.y = p.y;\n    return r;\n}\n\nvec2 trace(in vec3 p)\n{    \n    p = rotateY(p, iTime*1.8);\n    float mat = 1.;\n    float base = sdCappedCylinder(rotateZ(p-vec3(-1.0,0,0), 3.14 * 0.5), vec2(1,0.5));\n    float oY = 0.7;\n    float thumb = min(sdCapsule(p, vec3(0.5,oY,0), vec3(0.7,0.7 + oY,0), 0.35),\n                      sdCapsule(p, vec3(0.7,0.7 + oY,0), vec3(0.65,1.0 + oY,0), 0.35));\n    float otherFingers = udRoundBox(p-vec3(1,0,0), vec3(0.2, 0.3, 0.2), 0.65);//length(p - vec3(0.5, 0, 0)) - 0.81;\n    float fingers = min(min(sdCappedCylinder(rotateZ(p, 3.14 * 0.5), vec2(0.8,0.5)), thumb)\n                        , otherFingers);\n    \n    if(fingers < base)\n        mat = 2.;\n    \n    return vec2(min(fingers, base), mat);\n}\n\nvec3 calcNormal(in vec3 p)\n{\n    vec3 e = vec3(eps*10.,0,0);\n    vec3 n;\n    n.x = trace(p+e.xyz).x-trace(p-e.xyz).x;\n    n.y = trace(p+e.yxz).x-trace(p-e.yxz).x;\n    n.z = trace(p+e.yzx).x-trace(p-e.yzx).x;\n    return normalize(n);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = vec2((fragCoord.x - iResolution.x *.5) / iResolution.y, \n                   (fragCoord.y - iResolution.y *.5) / iResolution.y);\n    \n    vec3 rP = vec3(0,0.4,6.);\n    vec3 rD = normalize(vec3(uv, -1));\n    \n    vec3 bgColor = vec3(0.4,0.36,0.4-0.05*uv.y)*(1.0-0.25*length(uv*2.));\n    vec3 color = bgColor;\n    float t = 0.;\n    for(int i = 0;i < 36;++i)\n    {\n        vec3 p = rP + rD * t;\n        vec2 d = trace(p);\n        if(d.x < eps)\n        {\n            vec3 n = calcNormal(p);\n            if(d.y == 1.)\n            \tcolor = vec3(0.3,0.3,0.9); \n            else\n                color = vec3(1.0,1.0,1.0);\n            \n            color *= 2. * max(dot(n, vec3(0.33)), 0.) + 0.1;\n            break;\n        }\n        \n        t += d.x;\n    }\n    \n\tfragColor = vec4(color,1);//vec4(uv,0.5+0.5*sin(iTime),1.0);\n}","name":"Image","description":"","type":"image"}]}