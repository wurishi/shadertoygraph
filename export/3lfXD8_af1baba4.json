{"ver":"0.1","info":{"id":"3lfXD8","date":"1562663831","viewed":652,"name":"Shiny Disco Balls!","username":"peet","description":"Wanted to write a basic raytracer, Got carried away! Watch with some tunes on ;-)\nI'm sure there's a couple of issues in the maths, but the result is nice enough :) \nI nicked Klems update function for the perlin noise sphere positioning. Cheers Klems!","likes":12,"published":1,"flags":0,"usePreview":1,"tags":["raytracing","volumetric","shadows","reflections","lights","refections"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sXGRn","filepath":"/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","previewfilepath":"/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"///////////////////////////////////////////////////////////////////////////////////\n// When you're coding its ALWAYS the weekend :) ///////////////////////////////////\n///////////////////////////////////////////////////////////////////////////////////\n\n#define NO_INTERSECTION 100000.0\n#define AMBIENT 0.0\n#define EPSILON 0.0001\n#define TEXTURESCALE 0.125\n#define SPECULAR_POWER 25.0\n#define SPECULAR_AMOUNT 1.0\n#define MSAA 1.0\n#define ITERATIONS 4\n#define HURRY_UP 1.5\n\n#define VOLUME_STEP 0.2\t//// SET THIS TO 0.3 OR HIGHER FOR BETTER PERFORMANCE /////\n\n///////////////////////////////////////////////////////////////////////////////////\n\n#define DISCO_LIGHTS\n#define LIGHT_COLOUR_CHANGE\n#define MODULATE_PLANE_REFLECTANCE\n#define VOLUMETRIC_LIGHTING\n\n///////////////////////////////////////////////////////////////////////////////////\n\nstruct Ray {\n    vec3 origin;\n    vec3 direction;\n};\n\nstruct Sphere {\n    vec3 origin;\n    float radius;\n    vec3 colour;\n    float reflectiveness;\n};\n\nstruct Plane {\n    vec3 origin;\n    vec3 normal;\n    vec3 binormal;\n    vec3 binormal2;\n    float reflectiveness;\n};\n    \nstruct Light {\n    vec3 pos;\n    vec3 colour;\n};\n    \nstruct Result {\n    vec3 pos;\n    vec3 normal;\n    float t;\n    vec3 colour;\n    float reflectiveness;\n    vec3 ray;\n};\n\n///////////////////////////////////////////////////////////////////////////////////\n\nconst int g_numlights=3;\nLight g_lights[g_numlights];\n\nconst int g_numplanes=2;\nPlane g_planes[g_numplanes];\n\nconst int g_numspheres=7;\nSphere g_spheres[g_numspheres];\n\n///////////////////////////////////////////////////////////////////////////////////\n    \nfloat blerp(float x, float y0, float y1, float y2, float y3) {\n\tfloat a = y3 - y2 - y0 + y1;\n\tfloat b = y0 - y1 - a;\n\tfloat c = y2 - y0;\n\tfloat d = y1;\n\treturn a * x * x * x + b * x * x + c * x + d;\n}\n\nfloat rand(vec2 co){\n  return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat perlin(float x, float h) {\n\tfloat a = floor(x);\n\treturn blerp(mod(x, 1.0),\n\t\trand(vec2(a-1.0, h)), rand(vec2(a-0.0, h)),\n\t\trand(vec2(a+1.0, h)), rand(vec2(a+2.0, h)));\n}\n\n///////////////////////////////////////////////////////////////////////////////////\n\nResult hit_sphere(Ray ray, Sphere sphere)\n{\n    Result result = Result(vec3(0.0, 0.0, 0.0), vec3(0.0, 0.0, 0.0), NO_INTERSECTION, sphere.colour, sphere.reflectiveness, ray.direction);\n    vec3 oc = ray.origin - sphere.origin;\n    float a = dot(ray.direction, ray.direction);\n    float b = 2.0 * dot(oc, ray.direction);\n    float c = dot(oc,oc) - sphere.radius*sphere.radius;\n    float discriminant = b*b - 4.0*a*c;\n    if(discriminant < 0.0){\n        return result;\n    }\n    else{\n        float sqrtdsc = sqrt(discriminant);\n\t\tfloat t1 = (-b - sqrtdsc) / (2.0 * a);\n\t\tfloat t2 = (-b + sqrtdsc) / (2.0 * a);        \n        if (t2<0.0) \n            return result;\n        else if (t1>0.0)\n            result.t=t1;\n        else \n            result.t=t2;\n        \n        result.pos = ray.origin + (ray.direction*result.t);\n        result.normal = result.pos - sphere.origin;\n        result.normal = normalize(result.normal);\n        return result;      \n\t}\n}\n\n///////////////////////////////////////////////////////////////////////////////////\n\nResult hit_plane(Ray ray, Plane plane) \n{\n    Result result = Result(vec3(0.0, 0.0, 0.0), vec3(0.0, 0.0, 0.0), NO_INTERSECTION, vec3(1.0, 1.0, 1.0), plane.reflectiveness, ray.direction);\n    if (dot(plane.normal, ray.direction) >= 0.0) \n    {\n        return result;\n    }\n\n    float t = (dot(plane.normal, plane.origin) - dot(plane.normal, ray.origin)) / dot(plane.normal, ray.direction);\n    if (t<0.0)\n    {\n    \treturn result;    \n    }\n    \n    vec3 inter = ray.origin + ray.direction*t;    \n    result.t = t;\n    result.pos = inter;\n    result.normal = plane.normal;\n    \n    // sample the texture in the returned colour\n    vec2 tex;\n    tex.x = dot((result.pos - plane.origin), plane.binormal)*TEXTURESCALE;\n    tex.y = dot((result.pos - plane.origin), plane.binormal2)*TEXTURESCALE;\n    result.colour = texture(iChannel0, tex).xyz * texture(iChannel0, tex).xyz;\t// make it mor 'gaudy' ;-)\n    \n    return result;\n}\n\n///////////////////////////////////////////////////////////////////////////////////\n// ray-world query, returning intersection point, normal, surface colour\n\nResult raycast(Ray ray)\n{\n    Result bestresult = Result(vec3(0.0, 0.0, 0.0), vec3(0.0, 0.0, 0.0), NO_INTERSECTION, vec3(1.0, 1.0, 1.0), 0.0, ray.direction);    \n    \n    for (int i=0; i<g_numspheres; i++)\n    {\n        Result res = hit_sphere(ray, g_spheres[i]);    \n        if (res.t < bestresult.t)\n            bestresult=res;    \n    }\n    for (int i=0; i<g_numplanes; i++)\n    {\n    \tResult res = hit_plane(ray, g_planes[i]);    \n        if (res.t < bestresult.t)\n            bestresult=res;    \n    }\n    return bestresult;\n}\n\n///////////////////////////////////////////////////////////////////////////////////\n// returns the RGB lighting at a given point\n\nvec3 lighting(Result castresult)\n{\n    // light definition\n    vec3 colour = vec3(0.0, 0.0, 0.0);\n                \n    for (int i=0; i<g_numlights; i++)\n    {\n        // evaluate the point light\n        vec3 lightdir = castresult.pos - g_lights[i].pos;\n        lightdir = normalize(lightdir);\n        float brightness = dot(castresult.normal, -lightdir);\n\n        if (brightness>0.0)\n        {        \n            // cast a ray to the lightsource\n            Ray shadowray;\n            shadowray.origin = castresult.pos + castresult.normal*EPSILON;\n            shadowray.direction = g_lights[i].pos - castresult.pos;\t// no need to normalize this\n            Result shadowresult = raycast(shadowray);\n            if ((shadowresult.t == NO_INTERSECTION) || (shadowresult.t > 1.0f) || (shadowresult.t < 0.0f))\n            {\n//                vec3 reflectedlight = reflect(lightdir, castresult.normal);\n//                float specular = dot(castresult.ray, -reflectedlight);\n                \n                float specular = pow(brightness, SPECULAR_POWER) * SPECULAR_AMOUNT;\n                colour += (brightness*g_lights[i].colour*castresult.colour) + (specular*g_lights[i].colour);\n            }        \n        }\n    }\n    return colour;\n}\n\n///////////////////////////////////////////////////////////////////////////////////\n// returns the colour at the intersection point, or AMBIENT\n\nvec3 raytrace(Ray inputray)\n{    \n    Ray ray=inputray;\n    vec3 outputcolour = vec3(AMBIENT, AMBIENT, AMBIENT);\n    float rayweight = 1.0;\n    \n    for (int i=0; i<ITERATIONS; i++)\n    {\n        vec3 colour = vec3(0.0, 0.0, 0.0);\n        Result result = raycast(ray);\n\n        if (result.t == NO_INTERSECTION)\n        {\n            // no intersection at this stage, return the accumulated colour so far\n            vec3 colour = vec3(AMBIENT, AMBIENT, AMBIENT);\n            outputcolour = (outputcolour*(1.0-rayweight)) + (colour*rayweight);\n            return outputcolour;\n        }\n        else\n        {                        \n            colour=lighting(result);\n            colour.xyz = max(colour, AMBIENT);            \n            outputcolour = (outputcolour*(1.0-rayweight)) + (colour*rayweight);\n\n            if (result.reflectiveness>0.0)\n            {\n                Ray reflectray;\n                reflectray.origin = result.pos + result.normal*EPSILON;\n                reflectray.direction = reflect(ray.direction, result.normal);\n                ray = reflectray;\n                rayweight = rayweight * result.reflectiveness;\n                if (rayweight < 0.1)\n                {\n                    return outputcolour;\n                }\n            }      \n            else\n            {\n            \treturn outputcolour;    \n            }\n        }\n    }\n    \n    outputcolour.xyz = max(outputcolour, AMBIENT);\n    return outputcolour;\n}\n\n///////////////////////////////////////////////////////////////////////////////////\n\nvoid setupscene()\n{\n    float pri=1.0f;\n    float sec=0.4;\n    float ter=0.2;\n\n#ifdef LIGHT_COLOUR_CHANGE    \n    pri=1.0;\n    sec=0.4 + sin(iTime*1.0)*0.4;\n    ter=0.2 + sin(iTime*2.0)*0.2;\n    \n    pri*=2.0f;\n    sec*=2.0f;\n    ter*=2.0f;\n#endif //LIGHT_COLOUR_CHANGE    \n    \n    g_lights[0].colour = vec3(sec, ter, pri);\n    g_lights[1].colour = vec3(ter, pri, sec);\n    g_lights[2].colour = vec3(pri, ter, sec);    \n\n#ifdef DISCO_LIGHTS    \n    g_lights[0].colour *= 0.4 + perlin(iTime*8.0, 1.0)*0.5;\n    g_lights[1].colour *= 0.4 + perlin(iTime*7.0, 1.27)*0.5;\n    g_lights[2].colour *= 0.4 + perlin(iTime*5.0, 1.72)*0.5;\n#endif //DISCO_LIGHTS    \n    \n\tfor (int i=0; i<g_numlights; i++)\n    {\n\t\tfloat h = float(i)*4.0;\n\t\tfloat x = perlin(iTime*0.212, h+1.0)*8.0 - 4.0;\n\t\tfloat y = perlin(iTime*0.341, h+2.0)*4.0 - 2.0;\n\t\tfloat z = 4.0+perlin(iTime*0.193, h+3.0)*4.0;\n\t\tg_lights[i].pos = vec3(x, y, z+2.0);\n\t}   \n    \n    // scene definition\n    g_planes[0] = Plane(vec3(0.0, -3, 0.0), vec3(0.0, 1.0, 0.0), vec3(1.0, 0.0, 0.0), vec3(0.0, 0.0, 1.0), 0.25);    \n    g_planes[1] = Plane(vec3(0.0, +3, 0.0), vec3(0.0, -1.0, 0.0), vec3(1.0, 0.0, 0.0), vec3(0.0, 0.0, 1.0), 0.0);    \n\n#ifdef MODULATE_PLANE_REFLECTANCE    \n    // animate the plane reflectiveness - this has a surprising side-effect :)\n    g_planes[0].reflectiveness = 0.5 + 0.5*sin(iTime);\n    g_planes[1].reflectiveness = 0.5 + 0.5*sin(iTime);\n#endif //MODULATE_PLANE_REFLECTANCE    \n    \n    g_spheres[0] = Sphere(vec3(0.0, 0.0, 0.0), 1.0, vec3(1.0, 0.2, 0.2), 0.75);\n    g_spheres[1] = Sphere(vec3(0.0, 0.0, 0.0), 1.0, vec3(0.2, 1.0, 0.2), 0.75);\n    g_spheres[2] = Sphere(vec3(0.0, 0.0, 0.0), 1.0, vec3(0.2, 0.2, 1.0), 0.75);\n    g_spheres[3] = Sphere(vec3(0.0, 0.0, 0.0), 1.0, vec3(1.0, 1.0, 0.2), 0.75);\n    g_spheres[4] = Sphere(vec3(0.0, 0.0, 0.0), 1.0, vec3(0.2, 1.0, 1.0), 0.75);\n    g_spheres[5] = Sphere(vec3(0.0, 0.0, 0.0), 1.0, vec3(1.0, 0.2, 1.0), 0.75);\n    g_spheres[6] = Sphere(vec3(0.0, 0.0, 0.0), 1.0, vec3(1.0, 1.0, 1.0), 0.75);\n//    g_spheres[7] = Sphere(vec3(0.0, 0.0, 0.0), 1.0, vec3(0.5, 0.5, 0.5), 0.75);\n                \n\tfor (int i=0; i<g_numspheres; i++)\n    {\n\t\tfloat h = float(i)*4.0;\n\t\tfloat size = \t\tperlin(HURRY_UP*iTime*0.251, h+4.0)*1.0 + 0.85;\n\t\tfloat x    = \t\tperlin(HURRY_UP*iTime*0.212, h+1.0)*20.0-10.0;\n\t\tfloat y    = \t\tperlin(HURRY_UP*iTime*0.341, h+2.0)*20.0-10.0;\n\t\tfloat z    = 35.0 + perlin(HURRY_UP*iTime*0.193, h+3.0)*20.0-10.0;\n\t\tg_spheres[i].origin = vec3(x*0.4, y*0.25, z*0.25-1.0);\n        g_spheres[i].radius=size;\n\t}            \n}\n\n///////////////////////////////////////////////////////////////////////////////////\n// 'volumetric' light rendering\n\nvec3 volumelights( Ray ray )\n{   \n    float castdistance=10.0;\n    float caststep=VOLUME_STEP;\n    float castscale=castdistance/caststep;\n\n    Result occlusionresult = raycast(ray); \n    castdistance = min(occlusionresult.t, castdistance);\n                \n    vec3 colour = vec3(0.0, 0.0, 0.0);            \n    for (float t=1.0; t<castdistance; t+=caststep)\n    {\n        vec3 pos = ray.origin + ray.direction*t;\n        \n        for (int i=0; i<g_numlights; i++)\n        {\n            vec3 deltapos = g_lights[i].pos-pos;\n            float d2=length(deltapos);\n\n            Ray shadowray;\n            shadowray.origin = pos;\n            shadowray.direction = deltapos;\n            Result shadowresult = raycast(shadowray);\n            if (d2<8.0)\n            {\n                if (shadowresult.t<0.0 || shadowresult.t>1.0)            \n                    colour.xyz += g_lights[i].colour/(d2*castscale);\n            }                                \n        }\n    }\n    \n    return colour;\n}\n\n///////////////////////////////////////////////////////////////////////////////////\n// main loop, iterate over the pixels, doing MSAA\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n\tsetupscene();\n    \n    fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n    float factor = 1.0/(MSAA*MSAA);\n    \n    for (float x=0.0; x<MSAA; x++)\n    {\n        for (float y=0.0; y<MSAA; y++)\n        {\n            vec2 uv = fragCoord.xy / iResolution.xy * 2.0 - 1.0;\n            uv.y *= iResolution.y / iResolution.x;\n\n            uv.x += (1.0/(iResolution.x*MSAA))*x;\n            uv.y += (1.0/(iResolution.y*MSAA))*y;\n            \n            Ray ray;\n            ray.origin = vec3(0.0, 0.0, 0.0);\n            ray.direction = uv.xyx;\n            ray.direction.z = 1.0;\n            ray.direction = normalize(ray.direction);\n\n            fragColor.xyz += raytrace(ray)*factor;\n        }        \n    }\n    \n    vec2 uv = fragCoord.xy / iResolution.xy * 2.0 - 1.0;\n    uv.y *= iResolution.y / iResolution.x;\n    Ray ray;\n    ray.origin = vec3(0.0, 0.0, 0.0);\n    ray.direction = uv.xyx;\n    ray.direction.z = 1.0;\n    ray.direction = normalize(ray.direction);\n    \n#ifdef VOLUMETRIC_LIGHTING    \n    fragColor.xyz += volumelights(ray);\n#endif //VOLUMETRIC_LIGHTING\n}\n\n///////////////////////////////////////////////////////////////////////////////////\n","name":"Image","description":"","type":"image"}]}