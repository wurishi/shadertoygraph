{"ver":"0.1","info":{"id":"3sKSzW","date":"1575285150","viewed":208,"name":"20191112_Serial Signal","username":"FMS_Cat","description":"ha","likes":3,"published":1,"flags":32,"usePreview":0,"tags":["posteffect"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord / iResolution.xy;\n    vec4 tex = texture( iChannel0, uv * VHSRESO / iResolution.xy );\n    fragColor = vec4( tex.xyz, 1.0 );\n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord / VHSRESO;\n    \n    float y = 0.0;\n    vec2 cbcr = vec2( 0.0 );\n    \n    float invDecodeIter = 1.0 / float( DECODE_ITER );\n    vec2 sampleOffset = vec2( 1.0, 0.0 ) / CHROMA_FREQ * DECODE_PERIOD * invDecodeIter;\n    for ( int i = -DECODE_ITER / 2; i < DECODE_ITER / 2; i ++ ) {\n        vec2 uvt = uv - float( i ) * sampleOffset;\n        float tex = 0.0;\n        if ( isValidUv( uvt ) ) {\n\t        tex = invDecodeIter * texture( iChannel0, uvt * VHSRESO / iResolution.xy ).x;\n        }\n        y += tex;\n        float phase = TAU * ( CHROMA_FREQ * uvt.x + CHROMA_SCANLINE_OFFSET * uvt.y );\n        cbcr += tex * vec2( cos( phase ), sin( phase ) );\n    }\n\n    vec3 col = YCBCR_TO_RGB * vec3(\n        saturate( ( 1.0 + KNOB_CONTRAST ) * ( linearstep( CHROMA_AMP, 1.0 - CHROMA_AMP, y ) + KNOB_BRIGHTNESS - 0.5 ) + 0.5 ),\n        PI * cbcr / CHROMA_AMP + vec2( 0.0, KNOB_CHROMA )\n    );\n    fragColor = vec4( col, 1.0 );\n}\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":1,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord / VHSRESO;\n    if ( !isValidUv( uv ) ) { discard; }\n\n    vec4 randomVector = texture( iChannel1, vec2( fractSin( iTime ) ) );\n\n    vec4 noise = texture( iChannel1, uv * VHSRESO / NOISERESO + vec2( fractSin( randomVector.x ) ) );\n    \n    vec2 uvHnoise = vec2( 0.02, 1.0 ) * VHSRESO / NOISERESO * vec2( uv.x + fractSin( uv.y ), uv.y );\n    vec4 hnoise = texture( iChannel1, uvHnoise + fractSin( randomVector.y ) );\n\n    vec2 uvOffsyncNoise = vec2( 0.0, NOISE_OFFSYNCFREQ ) * VHSRESO / NOISERESO * vec2( uv.x + fractSin( uv.y ), uv.y );\n    vec4 offsyncNoise = texture( iChannel1, uvOffsyncNoise - NOISE_OFFSYNCSPEED * iTime );\n    float offsyncAmp = ( offsyncNoise.y - 0.5 ) * linearstep( 1.0 - NOISE_OFFSYNC, 1.0, offsyncNoise.x );\n    \n    uv.x += ( hnoise.y - 0.5 ) * linearstep( 1.0 - NOISE_CLUTCH, 1.0, hnoise.x );\n\n    float phase = TAU * ( CHROMA_FREQ * uv.x + CHROMA_SCANLINE_OFFSET * uv.y );\n\n    uv.x += offsyncAmp;\n    phase += CHROMA_FREQ * 0.2 * offsyncAmp;\n\n    float switching = linearstep( 0.01, 0.0, uv.y );\n    uv.x += mix( 0.9, 1.0, randomVector.x ) * NOISE_SWITCHING * switching;\n    \n    vec4 tex = saturate( texture( iChannel0, uv ) );\n    vec3 ycbcr = RGB_TO_YCBCR * tex.xyz;\n    \n    // chroma signal will be filtered using LPF, this time we're gonna use cheap LPF\n    ycbcr.yz *= 0.2;\n    float invLpfIter = 1.0 / float( LPF_ITER );\n    for ( int i = 1; i < LPF_ITER; i ++ ) {\n        vec2 uvt = uv - vec2( invLpfIter * LPF_WIDTH * float( i ), 0.0 );\n        vec4 tex;\n        if ( isValidUv( uvt ) ) {\n        \ttex = saturate( texture( iChannel0, uvt ) );\n        }\n        ycbcr.yz += invLpfIter * ( RGB_TO_YCBCR * tex.xyz ).yz;\n    }\n    \n    float signal = ycbcr.x; // y as base level\n    signal = mix( CHROMA_AMP, 1.0 - CHROMA_AMP, signal );\n    signal += CHROMA_AMP * ( 1.0 - linearstep( 0.0, 0.1, abs( offsyncAmp ) ) ) * (\n        ycbcr.y * cos( phase ) +\n        ycbcr.z * sin( phase )\n    ); // cb as cosine of subcarrier\n    \n    signal += NOISE_STATIC * ( fractSin( noise.x ) - 0.5 );\n    signal += abs( offsyncAmp ) * smoothstep( 0.7, 0.8, hnoise.z );\n\n    fragColor = vec4( signal, 0.0, 0.0, 1.0 );\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"XdfGRr","filepath":"/media/a/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm","previewfilepath":"/media/ap/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm","type":"video","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord / iResolution.xy;\n    vec4 tex = texture( iChannel0, uv );\n    fragColor = vec4( tex.xyz, 1.0 );\n}\n","name":"Buffer C","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define NOISE_STATIC 0.1\n#define NOISE_SWITCHING 0.1\n#define NOISE_CLUTCH 0.01\n#define NOISE_OFFSYNC 0.01\n#define NOISE_OFFSYNCSPEED 0.05\n#define NOISE_OFFSYNCFREQ 0.05\n\n#define KNOB_BRIGHTNESS 0.0\n#define KNOB_CONTRAST 0.0\n#define KNOB_CHROMA 0.0\n\n#define LPF_ITER 10\n#define LPF_WIDTH 0.04\n#define DECODE_ITER 10\n#define DECODE_PERIOD 2.0\n#define NOISERESO 256.0\n#define VHSRESO ( min( iResolution.xy, vec2( 640.0, 240.0 ) ) )\n#define CHROMA_AMP 0.4\n#define CHROMA_FREQ 227.5\n#define CHROMA_SCANLINE_OFFSET 120.0\n\n#define PI 3.14159265359\n#define TAU 6.28318530718\n#define RGB_TO_YCBCR mat3( 0.299, -0.168736, 0.5, 0.587, -0.331264, -0.418688, 0.114, 0.5, -0.081312 )\n#define YCBCR_TO_RGB mat3( 1.0, 1.0, 1.0, 0.0, -0.344136, 1.772, 1.402, -0.714136, 0.0 )\n#define saturate(i) clamp( i, 0.0, 1.0 )\n#define linearstep(a,b,t) saturate( ( ( t ) - ( a ) ) / ( ( b ) - ( a ) ) )\n#define lofi(i,d) ( floor( i / d ) * d )\n\nbool isValidUv( in vec2 uv ) {\n    return 0.0 <= uv.x && uv.x <= 1.0 && 0.0 <= uv.y && uv.y <= 1.0;\n}\n\nfloat fractSin( float x ) {\n    return fract( 127.461 * sin( 228.671 * x ) );\n}\n","name":"Common","description":"","type":"common"}]}