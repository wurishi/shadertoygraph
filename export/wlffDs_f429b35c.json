{"ver":"0.1","info":{"id":"wlffDs","date":"1598057281","viewed":137,"name":"raymarching with MIS","username":"0x4015","description":"Simple raymarching based path-tracer with MIS.\nThe left half  : MIS on (converges reflection of the sphere light quickly)\nThe right half : MIS off\nMouse : camera control","likes":11,"published":1,"flags":32,"usePreview":0,"tags":["pathtracer"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 mouse = iMouse.xy / iResolution.xy;\n\tif (iMouse.zw == vec2(0)) mouse = vec2(0.5);\n\n    vec3 col = texture(iChannel0, uv).xyz;\n    if (abs(uv.x - 0.5) < 0.002) col *= 0.25;\n    fragColor = vec4(pow(abs(col), vec3(1.0/2.2)), 1.0);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//\n// Simple raymarching based path-tracer with MIS.\n//\n// The left half  : MIS on (converges reflection of the sphere light quickly)\n// The right half : MIS off\n//\n// Mouse : camera control\n//\n\n//-----------------------------------------------------------------------------\n\n#define\tNUM_RAY_MARCHING_ITERATIONS\t0x100\n#define\tDISTANCE_MIN\t\t\t\t1e-4\n#define\tT_MAX\t\t\t\t\t\t100.0\n#define\tEPS_ESTIMATE_NORMAL\t\t\t0.001\n#define\tEPS_AVOID_SELF_INTERSECT\t0.001\n#define EPS_AVOID_NAN_INF\t\t\t0.000001\n#define EPS_MIN_THROUGHPUT\t\t\t0.0001\n\n#define PI\t\t\t\t\t3.14159265359\n#define GOLDEN_RATIO_PHI1\t1.61803398874989484820\n#define GOLDEN_RATIO_PHI2\t1.32471795724474602596\n#define GOLDEN_RATIO_PHI3\t1.22074408460575947536\n#define GOLDEN_RATIO_PHI4\t1.16730397826141862883\n\nvec2 g_uv;\t\t// update in mainImage().\nvec2 g_mouse;\t// update in mainImage().\n\n//-----------------------------------------------------------------------------\n// random generators\n\n#define FIXED_POINT_ONE 0x10000\nint g_phi2FractSinSeed = 0;\nfloat Phi2FractSin(vec2 uv) {\n\tg_phi2FractSinSeed++;\n\tint a1 = int(float(FIXED_POINT_ONE) / GOLDEN_RATIO_PHI2);\n\tint a2 = int(float(FIXED_POINT_ONE) / (GOLDEN_RATIO_PHI2 * GOLDEN_RATIO_PHI2));\n\tvec2 offset = vec2(ivec2(a1, a2) * g_phi2FractSinSeed & (FIXED_POINT_ONE - 1)) / float(FIXED_POINT_ONE);\n\treturn fract(sin(dot(uv + offset, vec2(12.9898, 78.233))) * 43758.5453);\n}\nfloat Rand() {\n\treturn Phi2FractSin(g_uv + fract(iTime));\n}\n\n//-----------------------------------------------------------------------------\n// utilities\n\nstruct Material {\n\tfloat reflectance;\n\tfloat metallic;\n\tfloat perceptualRoughness;\n\tvec3 baseColor;\n\tvec3 emittance;\n};\n\n#define saturate(x) clamp(x, 0.0, 1.0)\n\nfloat pow5(float x) {\n\treturn x*x*x*x*x;\n}\n\nfloat ToLuminance(vec3 linearColor) {\n\treturn dot(vec3(0.2126, 0.7152, 0.0722), linearColor);\n}\n\n/*\n\tBased on branchlessONB\n\t\thttp://jcgt.org/published/0006/01/01/\n\tModified to right-handed coodinate.\n*/\nmat3 OrthoNormalBasis(vec3 axisZ) {\n\tfloat s = axisZ.z < 0.0 ? 1.0 : -1.0;\n\tfloat a = 1.0 / (axisZ.z - s);\n\tfloat b = axisZ.x * axisZ.y * a;\n\tvec3 axisY = vec3(1.0 + s * axisZ.x * axisZ.x * a, s * b, s * axisZ.x);\n\tvec3 axisX = vec3(b, s + axisZ.y * axisZ.y * a, axisZ.y);\n\treturn mat3(axisX, axisY, axisZ);\n}\n\nfloat MisWeight(float pdf0, float pdf1) {\n\treturn (pdf0 * pdf0) / (pdf0 * pdf0 + pdf1 * pdf1);\n}\n\n//-----------------------------------------------------------------------------\n// sampling\n\nfloat GGXAlphaFromPerceptualRoughness(float perceptualRoughness){\n\treturn perceptualRoughness * perceptualRoughness;\n}\n\nfloat D_GGX(float NoH, float alpha) {\n\tfloat a = NoH * alpha;\n\tfloat k = alpha / (1.0 - NoH * NoH + a * a);\n\treturn k * k * (1.0 / PI);\n}\n\nfloat V_SmithGGXCorrelated(float NoV, float NoL, float alpha) {\n\tfloat a2 = alpha * alpha;\n\tfloat GGXV = NoL * sqrt(NoV * NoV * (1.0 - a2) + a2);\n\tfloat GGXL = NoV * sqrt(NoL * NoL * (1.0 - a2) + a2);\n\treturn 0.5 / max(EPS_AVOID_NAN_INF, GGXV + GGXL);\n}\n\nvec3 ImportanceSampleLambert(vec2 u, vec3 N) {\n\tfloat phi = 2.0 * PI * u.x;\n\tfloat cosTheta = sqrt(max(0.0/* avoid NaN */, u.y));\n\tfloat sinTheta = sqrt(max(0.0/* avoid NaN */, 1.0 - cosTheta * cosTheta));\n\tvec3 L = vec3(sinTheta * cos(phi), sinTheta * sin(phi), cosTheta);\n\treturn OrthoNormalBasis(N) * L;\n}\nfloat EvaluatePDFForImportanceSampleLambert(vec3 N, vec3 L) {\n\tfloat NoL = saturate(dot(N, L));\n\treturn NoL / PI;\n}\n\n/*\n\tSampling the GGX Distribution of Visible Normals By Eric Heitz\n\t\thttp://jcgt.org/published/0007/04/01/\n*/\n// Input Ve: view direction\n// Input alpha_x, alpha_y: roughness parameters\n// Input U1, U2: uniform random numbers\n// Output Ne: normal sampled with PDF D_Ve(Ne) = G1(Ve) * max(0, dot(Ve, Ne)) * D(Ne) / Ve.z\nvec3 SampleGGXVNDF(vec3 Ve, float alpha_x, float alpha_y, float U1/*theta*/, float U2/*phi*/) {\n\t// Section 3.2: transforming the view direction to the hemisphere configuration\n\tvec3 Vh = normalize(vec3(alpha_x * Ve.x, alpha_y * Ve.y, Ve.z));\n\t// Section 4.1: orthonormal basis (with special case if cross product is zero)\n\tfloat lensq = Vh.x * Vh.x + Vh.y * Vh.y;\n\tvec3 T1 = lensq > 0.0 ? vec3(-Vh.y, Vh.x, 0) * inversesqrt(lensq) : vec3(1,0,0);\n\tvec3 T2 = cross(Vh, T1);\n\t// Section 4.2: parameterization of the projected area\n\tfloat r = sqrt(U1);\t\n\tfloat phi = 2.0 * PI * U2;\n\tfloat t1 = r * cos(phi);\n\tfloat t2 = r * sin(phi);\n\tfloat s = 0.5 * (1.0 + Vh.z);\n\tt2 = (1.0 - s)*sqrt(1.0 - t1*t1) + s*t2;\n\t// Section 4.3: reprojection onto hemisphere\n\tvec3 Nh = t1*T1 + t2*T2 + sqrt(max(0.0, 1.0 - t1*t1 - t2*t2))*Vh;\n\t// Section 3.4: transforming the normal back to the ellipsoid configuration\n\tvec3 Ne = normalize(vec3(alpha_x * Nh.x, alpha_y * Nh.y, max(0.0, Nh.z)));\t\n\treturn Ne;\n}\n\nvec3 ImportanceSampleGGXVNDF(vec2 u, float alpha, vec3 V, vec3 N) {\n\tmat3 ONB = OrthoNormalBasis(N);\n\tvec3 VInONB = transpose(ONB) * V;\n\tvec3 HInONB = SampleGGXVNDF(VInONB, alpha, alpha, u.y/* theta */, u.x/* phi */);\n\treturn ONB * HInONB;\n}\nfloat EvaluatePDFForImportanceSampleGGXVNDF(Material material, vec3 N, vec3 H, vec3 V) {\n\tfloat alpha = GGXAlphaFromPerceptualRoughness(material.perceptualRoughness);\n\tfloat NoV = saturate(dot(N, V));\n\tfloat NoH = saturate(dot(N, H));\n\tfloat Vis1 = V_SmithGGXCorrelated(NoV, 1.0, alpha);\n\tfloat D = D_GGX(NoH, alpha);\n\t/*\n\t\tpdf\n\t\t=\tG1(Ve) * max(0, dot(Ve, Ne)) * D(Ne) / Ve.z * (1.0 / (4 * LoH))\n\n\t\t=\tG1 * LoH * D / NoV * (1.0 / (4 * LoH))\n\n\t\t\t G1 * D\n\t\t=\t---------\n\t\t\t 4 * NoV\n\t\t\t\t\t\t\t\t\t\t\tG1 = Vis1 * 4 * NoV\n\t\t\t Vis1 * 4 * NoV * D\n\t\t=\t--------------------\n\t\t\t      4 * NoV\n\n\t\t=\t Vis1 * D\n\t*/\n\treturn Vis1 * D;\n}\n\n/*\n\tBased on \"Veach 1997 Fig 9.4\" Created by mplanck.\n\t\thttps://www.shadertoy.com/view/lsV3zV\n*/\nvec3 UniformSampleCone(vec2 u, vec3 N, float cosThetaMax) {\n\tfloat phi = 2.0 * PI * u.x;\n\tfloat cosTheta = mix(1.0, cosThetaMax, u.y);\n\tfloat sinTheta = sqrt(max(0.0/* avoid NaN */, 1.0 - cosTheta * cosTheta));\n\tvec3 L = vec3(sinTheta * cos(phi), sinTheta * sin(phi), cosTheta);\n\treturn OrthoNormalBasis(N) * L;\n}\nfloat EvaluatePDFForUniformSampleCone(float cosTheta){\n\t/*\n\t\tThe solid angle of the cone\n\t\thttps://en.wikipedia.org/wiki/Solid_angle\n\t*/\n\tfloat solidAngle = 2.0 * PI * (1.0 - cosTheta);\n\treturn 1.0 / solidAngle;\n}\nvec3 SampleSphereLight(vec2 u, vec3 P, vec3 N, vec3 spherePosition, float radius, out float outPDF) {\n\tvec3 diff = spherePosition - P;\n\t// theta = half-angle of the cone\n\tfloat sinTheta2 = radius * radius / dot(diff, diff);\n\tfloat cosTheta2 = 1.0 - sinTheta2;\n\tfloat cosTheta = sqrt(max(0.0/* avoid NaN */, cosTheta2));\n\tvec3 sampleDir = UniformSampleCone(u, normalize(diff), cosTheta);\n\toutPDF = (dot(sampleDir, N) > 0.0)? EvaluatePDFForUniformSampleCone(cosTheta): 0.0;\n\treturn sampleDir;\n}\n\n//-----------------------------------------------------------------------------\n// BRDF\n\nvec3 F_SchlickVec3(vec3 f0, float f90, float u) {\n\treturn f0 + (f90 - f0) * pow5(max(0.0/* avoid NaN */, 1.0 - u));\n}\nfloat F_Schlick(float f0, float f90, float u) {\n\treturn f0 + (f90 - f0) * pow5(max(0.0/* avoid NaN */, 1.0 - u));\n}\n\n/*\n\tMoving Frostbite to Physically Based Rendering 3.0\tp.11\tListing 1:\n\t\thttps://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf\n*/\nfloat RenormalizedDisneyDiffuse(float NoV, float NoL, float LoH, float perceptualRoughness)\n{\n\tfloat energyBias = mix(0.0, 0.5, perceptualRoughness);\n\tfloat energyFactor = mix(1.0, 1.0 / 1.51, perceptualRoughness);\n\tfloat fd90 = energyBias + 2.0 * LoH * LoH * perceptualRoughness;\n\tfloat f0 = 1.0;\n\tfloat lightScatter = F_Schlick(f0, fd90, NoL);\n\tfloat viewScatter = F_Schlick(f0, fd90, NoV);\n\treturn lightScatter * viewScatter * energyFactor;\n}\n\nvec3 DiffuseBRDF(Material material, vec3 N, vec3 V, vec3 L) {\n\tfloat NoV = abs(dot(N, V));\n\tvec3 H = normalize(V + L);\n\tfloat LoH = saturate(dot(L, H));\n\tfloat NoL = saturate(dot(N, L));\n\tfloat frDisneyDiffuse = RenormalizedDisneyDiffuse(NoV, NoL, LoH, material.perceptualRoughness);\n\treturn material.baseColor * frDisneyDiffuse / PI;\n}\n\nvec3 DiffuseBRDF_divPDF_mulNoL(Material material, vec3 N, vec3 V, vec3 L) {\n\tfloat NoV = abs(dot(N, V));\n\tvec3 H = normalize(V + L);\n\tfloat LoH = saturate(dot(L, H));\n\tfloat NoL = saturate(dot(N, L));\n\tfloat frDisneyDiffuse = RenormalizedDisneyDiffuse(NoV, NoL, LoH, material.perceptualRoughness);\n\t/*\n\t\t\t   BaseColor\n\t\tBRDF = --------- * RenormalizedDisneyDiffuse\n\t\t\t\t  PI\n\n\t\tpdf = NoL / PI\n\n\t\tBRDF / pdf * NoL\n\t\t\t\t\t\t\t\t\t\t BaseColor     PI\n\t\t=\tRenormalizedDisneyDiffuse * ----------- * ----- * NoL\n\t\t\t\t\t\t\t\t\t\t\tPI         NoL\n\n\t\t=\tRenormalizedDisneyDiffuse * BaseColor\n\t*/\n\treturn frDisneyDiffuse * material.baseColor;\n}\n\nvec3 SpecularF0FromMaterial(Material material) {\n\treturn mix(\n\t\tvec3(0.16 * material.reflectance * material.reflectance),\n\t\tmaterial.baseColor,\n\t\tmaterial.metallic\n\t);\n}\n\nvec3 SpecularBRDF(Material material, vec3 N, vec3 H, vec3 V, vec3 L) {\n\tfloat VoH = saturate(dot(V, H));\n\tfloat NoV = saturate(dot(N, V));\n\tfloat NoL = saturate(dot(N, L));\n\tfloat NoH = saturate(dot(N, H));\n\n\tfloat alpha = GGXAlphaFromPerceptualRoughness(material.perceptualRoughness);\n\tfloat D = D_GGX(NoH, alpha);\n\n\tvec3 f0 = SpecularF0FromMaterial(material);\n\tfloat f90 = 1.0;\n\tvec3 F = F_SchlickVec3(f0, f90, VoH);\n\n\tfloat Vis = V_SmithGGXCorrelated(NoV, NoL, alpha);\n\treturn D * Vis * F;\n}\n\nvec3 SpecularBRDF_divPDF_mulNoL(Material material, vec3 N, vec3 H, vec3 V, vec3 L) {\n\tfloat VoH = saturate(dot(V, H));\n\tfloat NoV = saturate(dot(N, V));\n\tfloat NoL = saturate(dot(N, L));\n\tfloat NoH = saturate(dot(N, H));\n\n\tfloat alpha = GGXAlphaFromPerceptualRoughness(material.perceptualRoughness);\n\tfloat D = D_GGX(NoH, alpha);\n\n\tvec3 f0 = SpecularF0FromMaterial(material);\n\tfloat f90 = 1.0;\n\tvec3 F = F_SchlickVec3(f0, f90, VoH);\n\n\tfloat Vis  = V_SmithGGXCorrelated(NoV, NoL, alpha);\n\tfloat Vis1 = V_SmithGGXCorrelated(NoV, 1.0, alpha);\n\n\t/*\n\t\tMicrofacet specular BRDF = D * Vis * F\n\n\t\tpdf = Vis1 * D\n\n\t\tBRDF / pdf * NoL\n\t\t=\tD * Vis * F / pdf * NoL\n\n\t\t\t D * Vis * F\n\t\t=\t------------- * NoL\n\t\t\t  Vis1 * D\n\n\t\t\t Vis * F\n\t\t=\t--------- * NoL\n\t\t\t  Vis1\n\t*/\n\treturn F * Vis * NoL / max(Vis1, EPS_AVOID_NAN_INF);\n}\n\nvec3 SampleBRDF_divPDF_mulNoL(\n\tvec2 uSpecular,\n\tvec2 uDiffuse,\n\tfloat u,\n\tMaterial material,\n\tvec3 N,\n\tvec3 V,\n\tout vec3 outSampleDir,\n\tout float outPDF\n) {\n\tfloat alpha = GGXAlphaFromPerceptualRoughness(material.perceptualRoughness);\n\n\t// specular\n\tvec3 proposalSpecularTerm;\n\tvec3 proposalSpecularL;\n\tfloat proposalSpecularPDF;\n\t{\n\t\tvec3 H = ImportanceSampleGGXVNDF(uSpecular, alpha, V, N);\n\t\tvec3 L = -reflect(V, H);\n\t\tproposalSpecularL = L;\n\t\tproposalSpecularPDF = EvaluatePDFForImportanceSampleGGXVNDF(material, N, H, V);\n\t\tproposalSpecularTerm = SpecularBRDF_divPDF_mulNoL(material, N, H, V, L);\n\t}\n\n\t// diffuse\n\tvec3 proposalDiffuseTerm;\n\tvec3 proposalDiffuseL;\n\tfloat proposalDiffusePDF;\n\t{\n\t\tvec3 L = ImportanceSampleLambert(uDiffuse, N);\n\t\tproposalDiffuseL = L;\n\t\tproposalDiffusePDF = EvaluatePDFForImportanceSampleLambert(N, L);\n\t\tproposalDiffuseTerm = DiffuseBRDF_divPDF_mulNoL(material, N, V, L);\n\t}\n\n\t// Apply metallic.\n\tproposalDiffuseTerm *= 1.0 - material.metallic;\n\n\t// The probability of selecting the specular.\n\tfloat diffuseWeight  = ToLuminance(proposalDiffuseTerm);\n\tfloat specularWeight = ToLuminance(proposalSpecularTerm);\n\tfloat threshold = specularWeight / max(diffuseWeight + specularWeight, EPS_AVOID_NAN_INF);\n\n\t// Select diffuse or specular.\n\tvec3 color;\n\tif (u < threshold) {\n\t\toutSampleDir = proposalSpecularL;\n\t\toutPDF = proposalSpecularPDF;\n\t\tcolor = proposalSpecularTerm / threshold;\n\t} else {\n\t\toutSampleDir = proposalDiffuseL;\n\t\toutPDF = proposalDiffusePDF;\n\t\tcolor = proposalDiffuseTerm / (1.0 - threshold);\n\t}\n\n\treturn color;\n}\n\nvec3 EvaluateBRDF(\n\tfloat u,\n\tMaterial material,\n\tvec3 N,\n\tvec3 V,\n\tvec3 L,\n\tout float outPDF\n) {\n\tfloat alpha = GGXAlphaFromPerceptualRoughness(material.perceptualRoughness);\n\tvec3 H = normalize(L + V);\n\n\t// specular\n\tfloat proposalSpecularPDF = EvaluatePDFForImportanceSampleGGXVNDF(material, N, H, V);\n\tvec3 proposalSpecularBRDF = SpecularBRDF(material, N, H, V, L);\n\n\t// diffuse\n\tfloat proposalDiffusePDF = EvaluatePDFForImportanceSampleLambert(N, L);\n\tvec3 proposalDiffuseBRDF = DiffuseBRDF(material, N, V, L);\n\n\t// Apply metallic.\n\tproposalDiffuseBRDF *= 1.0 - material.metallic;\n\n\t// The probability of selecting the specular.\n\tfloat diffuseWeight  = ToLuminance(proposalDiffuseBRDF);\n\tfloat specularWeight = ToLuminance(proposalSpecularBRDF);\n\tfloat threshold = specularWeight / max(diffuseWeight + specularWeight, EPS_AVOID_NAN_INF);\n\n#if 1\n\t// Select diffuse or specular.\n\toutPDF = (u < threshold)? proposalSpecularPDF: proposalDiffusePDF;\n#else\n\t// This is NOT correct.\n\toutPDF = mix(proposalDiffusePDF, proposalSpecularPDF, threshold);\n#endif\n\treturn proposalDiffuseBRDF + proposalSpecularBRDF;\n}\n\n//-----------------------------------------------------------------------------\n// scene and materials\n\n#define ID_SKY\t\t\t0\n#define ID_GROUND\t\t1\n#define ID_MENGER\t\t2\n#define ID_SPHERE_LIGHT\t3\n#define ID_OTHERS\t\t4\n\nvec3 g_sphereLightPosition = vec3(0.8, 1.2, 0.0);\nfloat g_sphereLightRadius = 1.2;\nvec3 g_lightEmittance = vec3(2.0);\n\nfloat MengerSpongeDistance(vec3 position, int n) {\n\tvec3 u = vec3(1.0, 3.0, 3.0);\n\tvec3 c = position * 0.5 + 0.5;\n\tvec3 v = abs(c - 0.5) - 0.5;\n\tfloat m = u.x;\n\tfloat r = max(v.x, max(v.y, v.z));\n\tfor (int i = 0; i < n; i++) {\n\t\tm *= u.y;\n\t\tv = (0.5 - abs(mod(c * m, u.z) - 1.5));\n\t\tr = max(r, min(max(v.x, v.z), min(max(v.x, v.y), max(v.y, v.z))) / m);\n\t}\n\treturn r * 2.0;\n}\n\nvec2 EstimateSceneDistanceAndMaterialId(vec3 position) {\n\tfloat dSky = -length(position) + T_MAX;\n\tfloat dMenger = MengerSpongeDistance(position * 0.2, 3) * 5.0 + 0.0025;\n\tfloat dGround = position.y;\n\tfloat dSphereLight = length(g_sphereLightPosition - position) - g_sphereLightRadius;\n\tfloat d = min(min(min(dSky, dMenger), dGround), dSphereLight);\n\tint id = ID_OTHERS;\n\tif (d == dSky) id = ID_SKY;\n\tif (d == dMenger) id = ID_MENGER;\n\tif (d == dGround) id = ID_GROUND;\n\tif (d == dSphereLight) id = ID_SPHERE_LIGHT;\n\treturn vec2(d, float(id));\n}\n\nMaterial MaterialFromId(int id, vec3 position, vec3 normal) {\n\tMaterial material;\n\tif (id == ID_GROUND) {\n\t\tivec3 tmp = ivec3(position * 300.0);\n\t\tmaterial.perceptualRoughness\t= float((tmp.x ^ tmp.y ^ tmp.z) & 255) / 255.0 * 0.5;\n\t\tmaterial.metallic\t\t\t\t= 0.0;\n\t\tmaterial.baseColor\t\t\t\t= vec3(0.25, 0.15, 0.2);\n\t\tmaterial.emittance\t\t\t\t= vec3(0);\n\t} else\n\tif (id == ID_MENGER) {\n\t\tivec3 tmp = ivec3(position * 300.0);\n\t\tmaterial.perceptualRoughness\t= float((tmp.x ^ tmp.y ^ tmp.z) & 255) / 255.0 * 0.5;\n\t\tmaterial.metallic\t\t\t\t= 1.0;\n\t\tmaterial.baseColor\t\t\t\t= vec3(0.9, 0.6, 0.3);\n\t\tmaterial.emittance\t\t\t\t= vec3(0);\n\t} else\n\tif (id == ID_SPHERE_LIGHT) {\n\t\tfloat dMenger = MengerSpongeDistance(normal, 4);\n\t\tmaterial.perceptualRoughness\t= 0.1;\n\t\tmaterial.metallic\t\t\t\t= 0.0;\n\t\tmaterial.baseColor\t\t\t\t= vec3(0.5);\n\t\tmaterial.emittance\t\t\t\t= vec3(vec3(1.0, 0.3, 1.0) / (sin(fract(dMenger * 30.0) * 2.0 * PI) * 0.5 + 0.7));\n\t} else {\n\t\t// ID_OTHERS\n\t\tmaterial.perceptualRoughness\t= 1.0;\n\t\tmaterial.metallic\t\t\t\t= 0.0;\n\t\tmaterial.baseColor\t\t\t\t= vec3(1);\n\t\tmaterial.emittance\t\t\t\t= vec3(0);\n\t}\n\tmaterial.perceptualRoughness = max(0.02/* avoid NaN */, material.perceptualRoughness);\n\treturn material;\n}\n\nvec3 EstimateSceneNormal(vec3 position) {\n\tvec2 eps = vec2(EPS_ESTIMATE_NORMAL, 0);\n\treturn\n\t\tnormalize(\n\t\t\tvec3(\n\t\t\t\tEstimateSceneDistanceAndMaterialId(position + eps.xyy).x - EstimateSceneDistanceAndMaterialId(position - eps.xyy).x,\n\t\t\t\tEstimateSceneDistanceAndMaterialId(position + eps.yxy).x - EstimateSceneDistanceAndMaterialId(position - eps.yxy).x,\n\t\t\t\tEstimateSceneDistanceAndMaterialId(position + eps.yyx).x - EstimateSceneDistanceAndMaterialId(position - eps.yyx).x\n\t\t\t)\n\t\t)\n\t;\n}\n\n//-----------------------------------------------------------------------------\n// rendering\n\nvec3 SkyColor(vec3 dir) {\n\tvec3 upperColor = vec3(1.0, 1.0, 4.0);\n\tvec3 lowerColor = vec3(0.12, 0.08, 0.04);\n\tvec3 hemisphereLight = mix(lowerColor, upperColor, smoothstep(-0.05, 0.2, dir.y));\n\tivec3 tmp = ivec3(dir * 50.0);\n\tvec3 xorPattern = vec3(float((tmp.x ^ tmp.y ^ tmp.z) & 255) / 255.0);\n\treturn xorPattern * hemisphereLight;\n}\n\nvec3 Render(vec3 rayOrg, vec3 rayDir) {\n\tvec3 radiance = vec3(0);\n\tvec3 throughput = vec3(1);\n\tvec3 prevNormal = vec3(0);\n\tvec3 prevRayDir = vec3(0);\n\tMaterial prevMaterial;\n\n\tfloat nextMisWeight = 1.0;\n\n\tbool useMIS = (g_uv.x < 0.5);\n\tfloat lightPDF = 0.0;\n\tbool nee = false;\n\n\tfloat t = 0.0;\n\tint bounce = 0;\n\tfor (int i = 0; i < NUM_RAY_MARCHING_ITERATIONS; ++i) {\n\t\tvec3 position = rayOrg + rayDir * t;\n\t\tvec2 distAndMaterialId = EstimateSceneDistanceAndMaterialId(position);\n\t\tfloat d = distAndMaterialId.x;\n\n\t\tif (abs(d) < (t * 5.0 + 1.0) * DISTANCE_MIN) {\n\t\t\tvec3 normal = EstimateSceneNormal(position);\n\t\t\tint materialId = int(distAndMaterialId.y);\n\t\t\tMaterial material = MaterialFromId(materialId, position, normal);\n\n\t\t\tif (nee == false) {\n\t\t\t\tif (materialId == ID_SKY) {\n\t\t\t\t\tradiance += throughput * SkyColor(rayDir);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (materialId == ID_SPHERE_LIGHT) {\n\t\t\t\t\tradiance += material.emittance * throughput * nextMisWeight;\n\t\t\t\t}\n\n\t\t\t\trayOrg = position + normal * EPS_AVOID_SELF_INTERSECT;\n\t\t\t\tprevNormal = normal;\n\t\t\t\tprevRayDir = rayDir;\n\t\t\t\tprevMaterial = material;\n\t\t\t\trayDir = SampleSphereLight(\n\t\t\t\t\t/* vec2 u */\t\t\t\tvec2(Rand(), Rand()),\n\t\t\t\t\t/* vec3 P */\t\t\t\trayOrg,\n\t\t\t\t\t/* vec3 N */\t\t\t\tnormal,\n\t\t\t\t\t/* vec3 spherePosition */\tg_sphereLightPosition,\n\t\t\t\t\t/* float radius */\t\t\tg_sphereLightRadius,\n\t\t\t\t\t/* out float outPDF */\t\tlightPDF\n\t\t\t\t);\n\t\t\t\tnee = true;\n\t\t\t} else {\n\t\t\t\tif (useMIS) {\n\t\t\t\t\tif (lightPDF > 0.0) {\n\t\t\t\t\t\tif (materialId == ID_SPHERE_LIGHT) {\n\t\t\t\t\t\t\tfloat brdfPDF;\n\t\t\t\t\t\t\tvec3 BRDF = EvaluateBRDF(\n\t\t\t\t\t\t\t\t/* float u */\t\t\t\tRand(),\n\t\t\t\t\t\t\t\t/* Material material */\t\tprevMaterial,\n\t\t\t\t\t\t\t\t/* vec3 N */\t\t\t\tprevNormal,\n\t\t\t\t\t\t\t\t/* vec3 V */\t\t\t\t-prevRayDir,\n\t\t\t\t\t\t\t\t/* vec3 L */\t\t\t\trayDir,\n\t\t\t\t\t\t\t\t/* out float outPDF */\t\tbrdfPDF\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tfloat misWeight = MisWeight(lightPDF, brdfPDF);\n\t\t\t\t\t\t\tfloat NoL = saturate(dot(prevNormal, rayDir));\n\t\t\t\t\t\t\tradiance += throughput * material.emittance * BRDF / lightPDF * NoL * misWeight;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tfloat brdfPDF;\n\t\t\t\tvec3 BRDF_divPDF_mulNoL = SampleBRDF_divPDF_mulNoL(\n\t\t\t\t\t/* vec2 uSpecular */\t\tvec2(Rand(), Rand()),\n\t\t\t\t\t/* vec2 uDiffuse */\t\t\tvec2(Rand(), Rand()),\n\t\t\t\t\t/* float u */\t\t\t\tRand(),\n\t\t\t\t\t/* Material material */\t\tprevMaterial,\n\t\t\t\t\t/* vec3 N */\t\t\t\tprevNormal,\n\t\t\t\t\t/* vec3 V */\t\t\t\t-prevRayDir,\n\t\t\t\t\t/* out vec3 outSampleDir */\trayDir,\n\t\t\t\t\t/* out float outPDF */\t\tbrdfPDF\n\t\t\t\t);\n\t\t\t\tthroughput *= BRDF_divPDF_mulNoL;\n\t\t\t\tif (ToLuminance(throughput) < EPS_MIN_THROUGHPUT) break;\n\t\t\t\tnextMisWeight = (useMIS)? MisWeight(brdfPDF, lightPDF): 1.0;\n\n\t\t\t\tbounce++;\n\t\t\t\tnee = false;\n\t\t\t}\n\t\t\tt = 0.0;\n\t\t\td = 0.0;\n\t\t}\n\t\tt += d;\n\t}\n\n\treturn radiance;\n}\n\n//-----------------------------------------------------------------------------\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\tg_uv = gl_FragCoord.xy / vec2(iResolution);\n\tg_mouse = iMouse.xy / iResolution.xy;\n\tif (iMouse.zw == vec2(0)) g_mouse = vec2(0.3, 0.5);\n\n\tvec3 cameraPosition\t= mix(vec3(-0.5, 0.1, -9.0), vec3(-0.5, 0.1, 9.0), g_mouse.x);\n\tvec3 cameraTarget = g_sphereLightPosition + vec3(0.0, (g_mouse.y - 0.5) * 8.0, 0.0);\n\n\tvec3 cameraAxisZ\t= normalize(cameraPosition - cameraTarget);\n\tvec3 cameraAxisY\t= vec3(0, 1, 0);\n\tvec3 cameraAxisX\t= normalize(cross(cameraAxisY, cameraAxisZ));\n\tcameraAxisY\t\t\t= cross(cameraAxisZ, cameraAxisX);\n\n\tfloat tanFovY\t\t= 0.6;\n\tvec2 jitter\t\t\t= vec2(Rand(), Rand()) * 2.0 - 1.0;\n\tvec3 rayDirInCamera\t= normalize(vec3((fragCoord * 2.0 - vec2(iResolution) + jitter) / iResolution.y * tanFovY, -1.0));\n\tvec3 rayDir\t\t\t= mat3(cameraAxisX, cameraAxisY, cameraAxisZ) * rayDirInCamera;\n\tvec3 rayOrg\t\t\t= cameraPosition;\n\tvec3 color\t\t\t= vec3(0);\n\n\tint numSamples = 2;\n\tfor (int i = 0; i < numSamples; i++) {\n\t\tcolor += Render(rayOrg, rayDir);\n\t}\n\tcolor /= float(numSamples);\n\n\tvec4 persistentParams = texelFetch(iChannel0, ivec2(0, 0), 0);\n\tfloat accFrameCount = persistentParams.x;\n\tif (iMouse.z > 0.0) accFrameCount = 0.0f;\n\n\tfloat minEmaWeight = 0.0;\n\tvec3 prevColor = texture(iChannel0, g_uv).rgb;\n\tcolor = mix(prevColor, color, vec3(max(1.0 / (accFrameCount + 1.0), minEmaWeight)));\n\tif (any(isnan(color)) || any(isinf(color))) {color = vec3(0, 1, 0);/* error pixel */}\n\n\tif (ivec2(gl_FragCoord.xy) == ivec2(0, 0)) {\n\t\tpersistentParams.x = accFrameCount + 1.0;\n\t\tfragColor = persistentParams;\n\t} else {\n\t\tfragColor = vec4(color, 1.0);\n\t}\n}\n","name":"Buffer A","description":"","type":"buffer"}]}