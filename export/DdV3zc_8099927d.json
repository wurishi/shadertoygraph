{"ver":"0.1","info":{"id":"DdV3zc","date":"1678889786","viewed":68,"name":"GPT-4 wrote this code","username":"shyuriken","description":"\"Write a GLSL code that can be copied and pasted into the Image pane of shadertoy.com to display a video of a red 3D sphere gradually changing into a green 3D cube!\"","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["ai","gpt4"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Define pi for calculations\nconst float PI = 3.14159265359;\n\n// Signed distance function for a sphere\nfloat sphereSDF(vec3 p, float r) {\n    return length(p) - r;\n}\n\n// Signed distance function for a box\nfloat boxSDF(vec3 p, vec3 b) {\n    vec3 d = abs(p) - b;\n    return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));\n}\n\n// Scene function that blends sphere and box based on the transition parameter\nfloat sceneSDF(vec3 p, float t) {\n    float sphereDist = sphereSDF(p, 1.0);\n    float boxDist = boxSDF(p, vec3(1.0));\n    return mix(sphereDist, boxDist, t);\n}\n\n// Ray marching\nvec3 rayMarch(vec3 ro, vec3 rd, float t) {\n    float tMin = 0.1;\n    float tMax = 100.0;\n    float dist;\n\n    for (int i = 0; i < 64; ++i) {\n        vec3 p = ro + rd * tMin;\n        dist = sceneSDF(p, t);\n        if (dist < 0.001 || tMin > tMax) break;\n        tMin += dist;\n    }\n\n    if (tMin > tMax) return vec3(0.0);\n\n    return vec3(tMin);\n}\n\n// Calculate normal\nvec3 normal(vec3 p, float t) {\n    vec2 e = vec2(0.001, 0.0);\n    return normalize(vec3(\n        sceneSDF(p + e.xyy, t) - sceneSDF(p - e.xyy, t),\n        sceneSDF(p + e.yxy, t) - sceneSDF(p - e.yxy, t),\n        sceneSDF(p + e.yyx, t) - sceneSDF(p - e.yyx, t)\n    ));\n}\n\n// Main function\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n    float time = mod(iTime, 4.0) / 4.0;\n\n    // Camera and ray setup\n    vec3 ro = vec3(0.0, 0.0, 4.0);\n    vec3 rd = normalize(vec3(uv, -1.0));\n\n    // Ray march the scene\n    vec3 p = rayMarch(ro, rd, time);\n\n    if (p == vec3(0.0)) {\n        fragColor = vec4(0.0);\n        return;\n    }\n\n    // Calculate the normal and surface color\n    vec3 n = normal(p, time);\n    vec3 col = mix(vec3(1.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0), time);\n\n    // Simple lighting\n    vec3 lightDir = normalize(vec3(1.0, 1.0, 1.0));\n    //float diff = clamp(dot(n, light\n    float diff = clamp(dot(n, lightDir), 0.1, 1.0);\n\n    // Apply lighting to the color\n    col *= diff;\n\n    fragColor = vec4(col, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}