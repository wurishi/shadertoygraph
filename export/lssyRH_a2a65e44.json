{"ver":"0.1","info":{"id":"lssyRH","date":"1487107085","viewed":409,"name":"Spinning Circle Grid","username":"SalikSyed","description":"Just a test","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["circles"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define N 10\n#define M 5\n#define K 24\n#define M_PI 3.1415926535897932384626433832795\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float aspectRatio = iResolution.x / iResolution.y;\n\n    float h = 1.0;\n    float w = aspectRatio;\n\n    vec2 uv = vec2(fragCoord.x / iResolution.x * aspectRatio, fragCoord.y / iResolution.y); \n\n    float radius = 0.01;\n    float orbitR = 0.02;\n    float orbiterRadius = 0.005;\n    float centerRadius = 0.002;\n    float encloseR = 2.0 * orbitR;\n    float encloserRadius = 0.002;\n    float spacingX = (w / (float(N) + 1.0));\n    float spacingY = h / (float(M) + 1.0);\n    float x = 0.0;\n    float y = 0.0;\n    vec4 totalLight = vec4(0.0, 0.0, 0.0, 1.0);\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < M; j++) { \n            // compute the center of the diagram\n            vec2 center = vec2(spacingX * (float(i) + 1.0), spacingY * (float(j) + 1.0));\n            x =  center.x + orbitR * cos(iTime );\n            y =  center.y + orbitR * sin(iTime );\n            vec2 bulb = vec2(x,y);\n            if (length(uv - center) > encloserRadius + encloseR) {\n                continue;\n            } else if (length(uv - center) < centerRadius) {\n                // frag intersects white center marker                   \n                fragColor = vec4(1.0);\n                return;               \n            } else if (length(uv - bulb) < radius) {\n                // intersects rotating \"light\"\n                fragColor = vec4(uv,0.5+0.5*sin(iTime),1.0);\n                return;\n            } else {\n                // intersects one of the enclosing 24 cylinders\n                for(int k = 0; k < K; k++) {\n                    float theta = M_PI * 2.0 * float(k)/ float(K);\n                    x = center.x + cos(theta) * encloseR;\n                    y = center.y + sin(theta) * encloseR;\n                    vec2 encloser = vec2(x,y);\n                    if (length(uv - encloser) < encloserRadius) {\n                        fragColor = vec4(uv,0.5+0.5*sin(iTime),1.0);\n                    \treturn;\n                    }\n                }   \n            }\n        }\n    }\n\tfragColor = vec4(0.0);\n\n}","name":"Image","description":"","type":"image"}]}