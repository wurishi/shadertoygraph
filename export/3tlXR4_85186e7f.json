{"ver":"0.1","info":{"id":"3tlXR4","date":"1562336274","viewed":696,"name":"Jigsaw Pattern","username":"fizzer","description":"I was inspired by [url=https://www.shadertoy.com/view/XdGBDW]this[/url] awesome shader by Shane to try a simpler jigsaw pattern without needing to loop through neighbouring pieces, and which allows fast random sampling. Hold LMB to \"reveal\" the structure.","likes":25,"published":1,"flags":0,"usePreview":0,"tags":["pattern","jigsaw"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","previewfilepath":"/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define AA 3\n\n// Constants\nconst float pi = 3.14159265358979323;\nconst float th = pi / 4.;\nconst mat2 m = mat2(cos(th), sin(th), -sin(th), cos(th));\nconst float rs2 = 1. / sqrt(2.);\n\n// polynomial smooth min\n// from iq: https://iquilezles.org/articles/smin\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\n// Jigsaw pattern function, returns random piece colour in RGB and SDF in A.\nvec4 jigsaw(vec2 uv)\n{\n    vec2 uv2 = m * (uv - .5) * rs2 * 2.;\n    \n    vec2 c = floor(uv), f = uv - c - .5;\n    vec2 c2 = floor(uv2), f2 = uv2 - c2;\n    \n    bool flip = texelFetch(iChannel0, ivec2(c2) & 255, 0).r > .5;\n    \n    vec2 mdir = step(abs(f).yx, abs(f)) * sign(f);\n\n    vec2 f2b = m * (f2 - .5);\n    \n    if(mod(c2.x + c2.y, 2.) > .5)\n        f2b = vec2(-f2b.y, f2b.x);\n\n    // SDF\n    float d = smin(flip ? -f2b.y : f2b.y, length(f2b - vec2(0, flip ? -.1 : .1)) - .25, 1. / 32.);\n\n    if(mod(c2.x, 2.) < .5 != flip != mod(c.x + c.y, 2.) > .5)\n        d = -d;\n    \n    if(d < 0.)\n    \tc += mdir;\n    \n    return vec4(texelFetch(iChannel1, ivec2(c) & 255, 0).rgb, abs(d));\n}\n\nfloat hmap(float h)\n{\n    return sqrt(smoothstep(0., .07, h));\n}\n\nvoid render( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy * 2. - 1.;\n\tuv.x *= iResolution.x / iResolution.y;\n    \n    uv *= 3.;\n\n    float th = sin(iTime / 10.);\n    \n    // Animation\n    uv = mat2(cos(th), sin(th), -sin(th), cos(th)) * uv;\n    uv *= 1. + .1 * sin(iTime);\n    uv.y += cos(iTime / 6.) * 3.;\n    \n    vec2 e = vec2(1e-3, 0);\n    \n    vec4 jig0 = jigsaw(uv);\n    \n    // Extract gradient for shading\n    float h0 = hmap(jigsaw(uv + e.xy).a);\n    float h1 = hmap(jigsaw(uv - e.xy).a);\n    float h2 = hmap(jigsaw(uv + e.yx).a);\n    float h3 = hmap(jigsaw(uv - e.yx).a);\n    \n    vec3 n = normalize(vec3(h0 - h1, e.x * 8., h3 - h2));\n        \n    vec3 col;\n    vec2 tuv = uv;\n    \n    if(jig0.b > .5)\n        tuv = tuv.yx;\n\n    // Shading\n    col = .05 + .95 * textureLod(iChannel2, jig0.rg, 0.).rgb;\n    vec3 w = textureLod(iChannel3, tuv / 2. + jig0.rg, 1.).rrr;\n    col *= smoothstep(-.1, 1., w);\n    \n    // Increase saturation\n    float b = dot(col, vec3(1. / 3.));\n    col = vec3(b) + (col - b) * 2.;\n    \n    fragColor.rgb = col * (.5 + .5 * dot(n, normalize(vec3(1)))) *\n        \t\tmix(.1, 1., smoothstep(0., .04, abs(jig0.a)));\n    \n    fragColor.rgb += pow(w.x, 2.) * pow(clamp(dot(n, normalize(vec3(1))), 0., 1.), 16.) * 1.;    \n    \n    if(iMouse.z > .5)\n    {\n        // Pattern structure visualisation\n        fragColor.rgb /= 2.;\n        float mask0 = step(min(fract(uv.x), fract(uv.y)), .03);\n    \tvec2 uv2 = m * (uv - .5) * rs2 * 2.;\n        float mask1 = step(min(fract(uv2.x), fract(uv2.y)), .03 / rs2);\n        fragColor.rgb = mix(fragColor.rgb, vec3(1, .2, 0), step(jig0.a, .02));\n        fragColor.rgb = mix(fragColor.rgb, vec3(1, 1, 0), mask1);\n        fragColor.rgb = mix(fragColor.rgb, vec3(0, .5, 1), mask0);\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor.a = 1.;\n    fragColor.rgb = vec3(0);\n    \n    // Anti-aliasing loop\n    for(int y = 0; y < AA; ++y)\n        for(int x = 0; x < AA; ++x)\n        {\n            vec4 rc;\n            render(rc, fragCoord + vec2(x, y) / float(AA));\n            fragColor.rgb += clamp(rc.rgb, 0., 1.);\n        }\n    \n    fragColor.rgb /= float(AA * AA);\n\n    fragColor.rgb = fragColor.rgb / (fragColor.rgb + 1.)  * 2.5;\n    \n    fragColor.rgb = pow(clamp(fragColor.rgb, 0., 1.), vec3(1. / 2.2));\n}","name":"Image","description":"","type":"image"}]}