{"ver":"0.1","info":{"id":"WdsSzN","date":"1550792909","viewed":146,"name":"RT Soft Shadows","username":"AdrianPi","description":"Soft shadows. Pretty slow but nice results.","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["raytracing","softwhadows"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n\nThis is public domain. Do what you please with it :)\n\n*/\n\n\nstruct ray_t\n{\n    vec3 pos;\n    vec3 dir;\n    int level;\n    vec4 contrib;\n};\n    \nstruct hit_t\n{\n    float t;\n    vec3 pos;\n    vec3 normal;\n    int prim;\n    int mat;\n};\n    \nconst int STANDARD_MATERIAL = 1;\nconst int CHECKER_MATERIAL = 2;\nconst int STARS_MATERIAL = 6;\n    \nstruct material_t\n{\n    int type;\n    int flags;\n    int attrib0;\n    int attrib1;\n    vec4 ambient;\n    vec4 diffuse;\n    vec4 specular;\n    vec4 emission;\n    vec4 reflection;\n    vec4 transparent;\n};\n    \nconst int SPHERE_PRIMITIVE = 1;\nconst int PLANE_PRIMITIVE = 2;\nconst int RING_PRIMITIVE = 3;\n\nstruct primitive_t\n{\n    int type;\n    int mat;\n    vec3 v0;\n    vec3 v1;\n    vec3 v2;\n};\n    \nconst float PI = 3.1415926535897932384626433832795;\nconst float INFINITE = 1e6;\nconst float EPSILON = 1e-6;\nconst float EPSILON4 = 1e-4;\n\nvec3 viewFrom = vec3(0,-1,1);\nvec3 viewAt = vec3(0,0,-1);\nvec3 viewUp = vec3(0,0,1);\nfloat viewFov = 45.0;\n\nvec3 viewDir;\nvec3 viewRight;\nfloat viewTan;\nfloat aspect = 1.33;\nconst int oversample = 1;\n\nconst vec4 skyColor = vec4(0,0.25,0.75,1);\nconst vec4 horizonColor = vec4(0.5,0.5,1,1);\n\nconst float fogNear = 10.;\nconst float fogFar = 50.;\nconst float fogDenom = 1. / (fogFar - fogNear);\nconst vec4 fogColor = horizonColor;\n\nconst material_t material0 = material_t(STANDARD_MATERIAL,\n                                   0,0,0, \n                                   vec4(1,0.8,0,1), \n                                   vec4(1,0.8,0,1), \n                                   vec4(1,1,1,100), \n                                   vec4(0,0,0,0), \n                                   vec4(0,0,0,0),\n                                   vec4(0,0,0,0));\n\nconst material_t material1 = material_t(STANDARD_MATERIAL,\n                                   0,0,0, \n                                   vec4(.25,0,1,1), \n                                   vec4(.25,0,1,1), \n                                   vec4(0.5,0.5,0.5,30), \n                                   vec4(0,0,0,0), \n                                   vec4(0,0,0,0), \n                                   vec4(0,0,0,0));\n\nconst material_t material2 = material_t(\n    \t\t\t\t\t\t\t   STARS_MATERIAL,\n    \t\t\t\t\t\t\t   0,0,1, \n                                   vec4(0.5,0.5,0.5,0), \n                                   vec4(0.001,0.001,0.001,0), \n                                   vec4(0,0,0,0), \n                                   vec4(0,0,0,0), \n                                   vec4(0,0,0,0), \n                                   vec4(0,0,0,0));\n\nconst material_t material3 = material_t(\n    \t\t\t\t\t\t\t   STANDARD_MATERIAL,\n    \t\t\t\t\t\t\t   0,0,0, \n                                   vec4(0,0,0,1), \n                                   vec4(0,0,0,1), \n                                   vec4(1,1,1,50), \n                                   vec4(0,0,0,0), \n                                   vec4(0.2,0.2,0.2,0), \n                                   vec4(0.6,0.6,0.6,1.24));\n\nconst material_t material4 = material_t(\n    \t\t\t\t\t\t\t   STANDARD_MATERIAL,\n    \t\t\t\t\t\t\t   0,0,0, \n                                   vec4(0.3,0.3,0.3,1), \n                                   vec4(0.3,0.3,0.3,1), \n                                   vec4(1,1,1,50), \n                                   vec4(0,0,0,0), \n                                   vec4(0.6,0.6,0.6,0), \n                                   vec4(0,0,0,0));\n\nconst material_t material5 = material_t(\n    \t\t\t\t\t\t\t   STANDARD_MATERIAL,\n    \t\t\t\t\t\t\t   0,0,0, \n                                   vec4(0,0,1,1), \n                                   vec4(0,0,1,1), \n                                   vec4(1,1,1,60), \n                                   vec4(0,0,0,0), \n                                   vec4(0,0,0,0), \n                                   vec4(0,0,0,0));\n\nconst material_t material6 = material_t(\n    \t\t\t\t\t\t\t   STANDARD_MATERIAL,\n    \t\t\t\t\t\t\t   0,0,0, \n                                   vec4(0,0,0,1), \n                                   vec4(0,0,0,1), \n                                   vec4(0.5,0.5,0.5,30), \n                                   vec4(0,0,0,0), \n                                   vec4(0.01,0.01,0.01,0), \n                                   vec4(1,0.1,0.1,1.54));\n\nmaterial_t materials[7] = material_t[7](material0, material1, material2, material3, material4, material5, material6);\n\n\nconst primitive_t _floor = primitive_t(PLANE_PRIMITIVE, 2, vec3(0, 0, -3), vec3(0, 0, 1), vec3(0,0,0));\nconst primitive_t _sphere = primitive_t(SPHERE_PRIMITIVE, 3, vec3(0, 0, -1), vec3(2, 0, 0), vec3(0,0,0));\nconst primitive_t _sphere2 = primitive_t(SPHERE_PRIMITIVE, 4, vec3(4, 2, -1.5), vec3(1.5, 0, 0), vec3(0,0,0));\nconst primitive_t _sphere3 = primitive_t(SPHERE_PRIMITIVE, 5, vec3(-4, -3, -2), vec3(1, 0, 0), vec3(0,0,0));\nconst primitive_t _sphere4 = primitive_t(SPHERE_PRIMITIVE, 6, vec3(-2, 4, -1.8), vec3(1.2, 0, 0), vec3(0,0,0));\n\nconst int NUM_PRIMS = 5;\n\nprimitive_t prims[NUM_PRIMS] = primitive_t[NUM_PRIMS](_floor, _sphere, _sphere2, _sphere3, _sphere4);\n\nray_t primary_ray(float fx, float fy)\n{\n    ray_t ray;\n    ray.pos = viewFrom;\n    ray.dir = normalize(viewDir + viewRight * fx  * aspect + viewUp * fy);\n    ray.contrib = vec4(1,1,1,1);\n    return ray;\n}\n\nvec4 background(ray_t ray)\n{\n\tfloat t = 1.0 - ray.dir.z * ray.dir.z;\n    t = pow(t, 60.0);\n    return skyColor * (1.0-t) + horizonColor * t;\n}\n\nbool hit_sphere(int i, ray_t ray, inout hit_t hit)\n{\n    vec3 center = prims[i].v0;\n    float radius = prims[i].v1.x;\n    \n    vec3 q = ray.pos - center;\n    float a = dot(ray.dir, ray.dir);\n    float b = 2.0 * dot(q, ray.dir);\n    float c = dot(q,q) - radius * radius;\n    float d = b * b - 4.0 * a * c;\n    if(d > EPSILON)\n    {\n        float t0 = (-b - sqrt(d)) / (2.0 * a);\n        float t1 = (-b + sqrt(d)) / (2.0 * a);\n\n        float t = INFINITE;\n        \n        if(t1 > EPSILON && t1 < t0)\n        {\n            t = t1;\n        }\n        else            \n        {\n            t = t0;\n        }\n        \n        if(t < EPSILON)\n        {\n            t = INFINITE;\n        }\n        \n        if(t != INFINITE)\n        {\n            hit.t = t;\n            hit.pos = ray.pos + ray.dir * hit.t;\n            hit.normal = normalize(hit.pos - center);\n            hit.mat = prims[i].mat;\n            return true;\n        }\n    }\n    return false;\n}\n\nbool hit_plane(int i, ray_t ray, inout hit_t hit)\n{\n    vec3 p0 = prims[i].v0;\n    vec3 normal = prims[i].v1;\n        \n    float d = dot(normal, ray.dir);\n    if(d > EPSILON || d < -EPSILON)\n    {\n        vec3 q = p0 - ray.pos;\n        float t = dot(q, normal) / d;\n        if(t > EPSILON)\n        {\n            hit.t = t;\n        \thit.pos = ray.pos + ray.dir * t;\n        \thit.normal = normal;\n        \thit.mat = prims[i].mat;\n        \treturn true;\n        }\n    }\n    return false;\n}\n\n/*bool hit_ring(vec3 p0, vec3 normal, float r1, float r2, int mat, ray_t ray, inout hit_t hit)\n{\n    float d = dot(normal, ray.dir);\n    if(d > EPSILON || d < -EPSILON)\n    {\n        vec3 q = p0 - ray.pos;\n        float t = dot(q, normal) / d;\n        if(t > EPSILON)\n        {\n            vec3 p = ray.pos + ray.dir * t;\n            vec3 r = p - p0;\n            float e = dot(r, r);\n            if(e < r1*r1 && e > r2*r2)\n            {\n                hit.t = t;\n                hit.pos = p;\n                hit.normal = normal;\n                hit.mat = mat;\n                return true;\n            }\n        }\n    }\n    return false;\n}*/\n\nvec4 ambientLight = vec4(0.2, 0.2, 0.1, 1);\n//vec3 lightDirection = normalize(vec3(1,1,-1));\nvec3 lightPosition = vec3(-10,-10,10);\n\nray_t rayQueue[16];\nint rayHead = 0;\nint rayTail = 0;\n\nvoid enqueueRay(ray_t ray)\n{\n    if((rayTail+1) % 16 != rayHead)\n    {\n        rayQueue[rayTail] = ray;\n        rayTail++;\n        rayTail %= 16;\n    }\n}\n\nbool dequeueRay(inout ray_t ray)\n{\n    if(rayHead != rayTail)\n    {\n        ray = rayQueue[rayHead];\n        rayHead++;\n        rayHead %= 16;\n        return true;\n    }\n    return false;\n}\n\nvoid resetRayQueue()\n{\n    rayHead = rayTail = 0;\n}\n\nvoid intersect(ray_t ray, inout hit_t hit);\n\nconst int SS_QUALITY = 8;\nconst int SS_SIZE = SS_QUALITY*SS_QUALITY;\nconst float SS_SCALE = 2. / float(SS_QUALITY-1);\nconst float SS_LIGHT_RADIUS = 0.75;\n\nvec4 shadowIntersect(ray_t ray, inout hit_t hit)\n{\n    vec4 color = vec4(1);\n    hit.t = INFINITE;\n    \n#pragma unroll 1\n    \n    for(int i = 0; i < NUM_PRIMS; i++)\n    {\n    \thit_t h;\n        int type = prims[i].type;\n        bool result = false;\n        \n        switch(type)\n        {\n        case PLANE_PRIMITIVE:\n            //result = hit_plane(prims[i].v0, prims[i].v1, prims[i].mat, ray, h);\n            result = hit_plane(i, ray, h);\n            break;\n        case SPHERE_PRIMITIVE:\n            //result = hit_sphere(prims[i].v0, prims[i].v1.x,  prims[i].mat, ray, h);            \n            result = hit_sphere(i, ray, h);\n            break;\n        /*case RING_PRIMITIVE:\n            result = hit_ring(prims[i].v0, prims[i].v1, prims[i].v2.x, prims[i].v2.y, prims[i].mat, ray, h);\n            break;*/\n        }\n        \n        if(result && h.t > EPSILON)\n        {\n            hit = h;\n            hit.prim = i;\n            if(materials[hit.mat].transparent == vec4(0))\n            {\n             \tcolor = vec4(0);\n                break;\n            }\n            else\n            {\n                // poor-guy caustics\n                float c = pow(-dot(ray.dir, hit.normal), 200.);\n                color *= mix(materials[hit.mat].transparent, vec4(1., 1., 1., 1), c*c) * c * 4.;\n                ////color *= materials[hit.mat].transparent * dot(ray.dir, -hit.normal);\n            }\n        }\n    }\n    return color;\n}\n\nvec4 shade_standard(ray_t ray, hit_t hit)\n{\n    if(ray.level >= 4)\n        return vec4(0,0,0,0);\n    \n    vec4 color = materials[hit.mat].ambient * ambientLight;\n    \n    vec3 rawLightDir = hit.pos - lightPosition;\n    vec3 lightDirection = normalize(rawLightDir);\n    \n    ray_t sray;\n    sray.pos = hit.pos - lightDirection * EPSILON;\n    \n    vec3 u = cross(lightDirection, vec3(0,0,1));\n    vec3 v = normalize(cross(u, lightDirection));\n    u = cross(lightDirection, v);\n                       \n    float shadow = 0.;\n    vec4 shadowColor = vec4(0);\n    float w = 0.;\n    if(SS_QUALITY > 1)\n    {\n        for(int i = 0; i < SS_SIZE; i++)\n        {\n            sray.dir = -rawLightDir;\n\n            int iu = i % SS_QUALITY;\n            int iv = i / SS_QUALITY;\n            float fu = (float(iu) * SS_SCALE) - 1.;\n            float fv = (float(iv) * SS_SCALE) - 1.;\n            sray.dir += (fu * u + fv * v) * SS_LIGHT_RADIUS;\n            sray.dir = normalize(sray.dir);\n            hit_t h;\n            vec4 scolor = shadowIntersect(sray, h);\n            float fw =(fu*fu+fv*fv);\n            shadowColor += scolor;\n            if(h.t != INFINITE)\n            {            \n                shadow += fw;\n            }\n            w += fw;\n        }\n    }\n    else        \n    {\n        sray.dir = -lightDirection;\n        hit_t h;\n        vec4 scolor = shadowIntersect(sray, h);\n        shadowColor = scolor;\n        if(h.t != INFINITE)\n        {            \n        \tshadow = 1.;\n        }\n        w = 1.;\n    }\n    w = 1. / w;\n    shadow *= w;\n    //shadow = 1. - shadow;\n    if(shadow <= 1.)\n    {\n        shadowColor *= w;\n        float d = dot(-lightDirection, hit.normal);\n        d = clamp(d, 0.0, 1.0);\n        color += materials[hit.mat].diffuse * shadowColor * d;\n        vec3 r = reflect(ray.dir, hit.normal);\n        float s = dot(-lightDirection, r);\n        s = clamp(s, 0.0, 1.0);\n        s = pow(s, materials[hit.mat].specular.a);\n        color.rgb += materials[hit.mat].specular.rgb * shadowColor.rgb * s;\n    }\n    \n    color.rgb += materials[hit.mat].emission.rgb;\n    \n    vec3 refl = materials[hit.mat].reflection.rgb;\n    if(dot(refl, refl) > 0.0)\n    {\n        ray_t rray;\n        vec3 r = reflect(ray.dir, hit.normal);\n        rray.pos = hit.pos + r * 0.001;\n        rray.dir = r;\n        rray.level = ray.level + 1;\n        rray.contrib = vec4(refl, 1) * ray.contrib;\n        enqueueRay(rray);\n    }\n    \n    vec3 trans = materials[hit.mat].transparent.rgb;\n    if(dot(trans, trans) > 0.0)\n    {\n        float ior = materials[hit.mat].transparent.a;\n        if(dot(ray.dir, hit.normal) < 0.0)\n            ior = 1.0 / ior;\n        \n        ray_t rray;\n        rray.pos = hit.pos + ray.dir * 0.001;\n        rray.dir = refract(ray.dir, hit.normal, ior);\n        rray.level = ray.level + 1;\n        rray.contrib = vec4(trans, 1) * ray.contrib;\n        enqueueRay(rray);\n    }\n    \n    return color;\n}\n\n/*vec4 shade_checker(ray_t ray, hit_t hit)\n{\n    vec3 p = hit.pos * materials[hit.mat].ambient.xyz\n        + materials[hit.mat].diffuse.xyz;\n\n    int ix = int(floor(p.x)) & 0x01;\n    int iy = int(floor(p.y)) & 0x01;\n    int iz = int(floor(p.z)) & 0x01;\n\n    hit.mat = ((ix ^ iy ^ iz) == 0) ? materials[hit.mat].attrib0 : materials[hit.mat].attrib1;\n\n    return shade_standard(ray, hit);\n}*/\n\nconst int POINTS = 5;\nconst float ANGLE = PI*2./float(POINTS);\n\nvec4 shade_stars(ray_t ray, hit_t hit)\n{\n    vec3 p = hit.pos * materials[hit.mat].ambient.xyz\n        + materials[hit.mat].diffuse.xyz;\n\n    vec3 p2 = mod(p, vec3(1.));\n    p2.x += floor(p2.y) * 0.5;\n\n    p2 *= 2.;\n    p2 -= 1.;\n            \n    float acc = 0.;\n    \n    float a = ANGLE;    \n    \n    for(int i = 0; i < POINTS; i++)\n    {\n        vec2 sc = vec2(sin(a), cos(a));\n    \tfloat test = dot(sc, p2.xy-sc*0.25);\n    \tacc += test > 0. ? 0.5 : 0.;\n        a += ANGLE;\n    }\n    \n    hit.mat = (acc < 1.) ?  materials[hit.mat].attrib0 : materials[hit.mat].attrib1;\n\n    return shade_standard(ray, hit);\n}\n\nvec4 shade(ray_t ray, hit_t hit)\n{\n    vec4 color;\n    \n    if(hit.t != INFINITE)\n    {    \n        int type = materials[hit.mat].type;\n\n        if(type == STANDARD_MATERIAL)\n        {\n            color = shade_standard(ray, hit);\n        }\n        /*else if(type == CHECKER_MATERIAL) \n        {\n            color = shade_checker(ray, hit);\n        }*/\n        else if(type == STARS_MATERIAL)\n        {\n            color = shade_stars(ray, hit);\n        }\n        \n        // fog\n\t\tif(ray.level != 0)\n        {\n        \tfloat f = (hit.t - fogNear) * fogDenom;\n        \tf = clamp(f, 0.0, 1.0);\n        \tcolor = mix(color, fogColor, f);\n        }\n    }\n    else\n    {\n        color = background(ray);\n    }\n    \n    return color * ray.contrib;\n}\n\nvoid intersect(ray_t ray, inout hit_t hit)\n{\n\thit.t = INFINITE;\n\n#pragma unroll 1\n    \n    for(int i = 0; i < NUM_PRIMS; i++)\n    {\n    \thit_t h;\n        int type = prims[i].type;\n        bool result = false;\n        \n        switch(type)\n        {\n        case PLANE_PRIMITIVE:\n            //result = hit_plane(prims[i].v0, prims[i].v1, prims[i].mat, ray, h);\n            result = hit_plane(i, ray, h);\n            break;\n        case SPHERE_PRIMITIVE:\n            //result = hit_sphere(prims[i].v0, prims[i].v1.x,  prims[i].mat, ray, h);            \n            result = hit_sphere(i, ray, h);\n            break;\n        /*case RING_PRIMITIVE:\n            result = hit_ring(prims[i].v0, prims[i].v1, prims[i].v2.x, prims[i].v2.y, prims[i].mat, ray, h);\n            break;*/\n        }\n        \n        if(result && h.t < hit.t)\n        {\n            hit = h;\n            hit.prim = i;\n        }\n    }    \n}\n\nvec4 raytrace(ray_t ray)\n{\n    hit_t hit;\n    \n    intersect(ray, hit);\n    \n    vec4 color = shade(ray, hit);\n    color.w = hit.t;\n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    viewFrom = vec3(sin(iTime*.5)*14.0, -cos(iTime*.5)*14.0, 2. + sin(iTime*1.5)*3.);\n    \n    \n    aspect = iResolution.x / iResolution.y;\n    viewTan = tan(((viewFov/180.0)*PI)/2.0);    \n    vec2 uv = fragCoord/iResolution.xy * vec2(2,2) - vec2(1,1);\n    uv *= viewTan;\n    viewDir = normalize(viewAt-viewFrom);\n\tviewRight = cross(viewDir, viewUp);\n    viewUp = cross(viewRight, viewDir);\n    \n    \n    float ovs = float(oversample);\n    vec4 color = vec4(0,0,0,0);\n    float sx = 1.0 / (ovs * iResolution.x);\n    float sy = 1.0 / (ovs * iResolution.y);       \n    \n    float fog = 0.;\n\n#pragma unroll 1\n\n    for(int i = 0; i < oversample; i++)\n    {\n#pragma unroll 1\n        \n        for(int j = 0; j < oversample; j++)\n        {\n    \t\tray_t ray = primary_ray(uv.x + float(i) * sx, uv.y + float(j) * sy);\n            resetRayQueue();\n            enqueueRay(ray);\n            \n            float t = 0.;\n            \n            while(dequeueRay(ray))\n            {\n\t    \t\tvec4 col = raytrace(ray);\n                if(ray.level == 0 && (col.w != INFINITE || ray.dir.z*ray.dir.z < EPSILON4))\n                {\n                    t = col.w;\n                    float f = (t - fogNear) * fogDenom;\n                \tf = clamp(f, 0.0, 1.0);\n                \tfog += f;\n                }\n                color += col;\n            }\n        }\n    }\n    \n    float ovsInv = 1. / (ovs*ovs);\n    color *= ovsInv;\n    fog *= ovsInv;\n    color = (mix(color, horizonColor, fog));\n    fragColor = color;\n}","name":"Image","description":"","type":"image"}]}