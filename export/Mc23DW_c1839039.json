{"ver":"0.1","info":{"id":"Mc23DW","date":"1704248492","viewed":42,"name":"DEPTH_BOKEH","username":"vemodalen","description":"0 for image 1 for protect 2 for depth","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["bokeh"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define GOLDEN_ANGLE 2.3999632\n#define ITERATIONS 1000\n#define HIGHLIGHT_BOOST 1.1\n#define DISTORTION_ANAMORPHIC\t0.0;\n#define DISTORTION_BARREL\t\t0.7;\n\nmat2 rot = mat2(cos(GOLDEN_ANGLE), sin(GOLDEN_ANGLE), -sin(GOLDEN_ANGLE), cos(GOLDEN_ANGLE));\nuniform sampler2D texture0;\nuniform sampler2D texture1;\nuniform sampler2D texture2;\nuniform float width;\nuniform float height;\nuniform float aspectRatio; // 定义纵横比uniform\n\n// Helpers-----------------------------------------------------------------------------------\nvec2 rotate(vec2 vector, float angle)\n{\n    float s = sin(angle);\n    float c = cos(angle);\n\n    return vec2(c*vector.x-s*vector.y, s*vector.x+c*vector.y);\n}\nmat2 rotMatrix(float angle)\n{\n    return mat2(cos(angle), sin(angle),\n                    -sin(angle), cos(angle));\n}\n// Additions by SolarLiner ------------------------------------------------------------------\nvec2 GetDistOffset(vec2 uv, vec2 pxoffset)\n{\n    vec2 tocenter = uv.xy-vec2(0.5,0.5);\n    vec3 prep = normalize(vec3(tocenter.y, -tocenter.x, 0.0));\n\n    float angle = length(tocenter.xy)*2.221*DISTORTION_BARREL;\n    vec3 oldoffset = vec3(pxoffset,0.0);\n    float anam = 1.0-DISTORTION_ANAMORPHIC; // Prevents a strange syntax error\n    oldoffset.x *= anam;\n\n    vec3 rotated = oldoffset * cos(angle) + cross(prep, oldoffset) * sin(angle) + prep * dot(prep, oldoffset) * (1.0-cos(angle));\n\n    return rotated.xy;\n}\n\nvec4 Bokeh(sampler2D tex,sampler2D tex1,sampler2D tex2, vec2 uv, float radius){\n    vec4 color;\n    float r = 1.;\n    vec2 vangle = vec2(0.0,radius*.01 / sqrt(float(ITERATIONS)));\n    float weight;\n    float bright_factor;\n    float gamma = 1.;\n    bool cateye = false;\n    vec2 p ; // sample point\n\n    vec2 depth_uv = uv;\n    vec4 depth = texture(tex2, depth_uv);\n    float scale = depth.x;\n\n    weight = texture(tex1, depth_uv).x;\n    if(weight<0.06)\n    {\n        gamma=1.;\n    }\n\n    vec4 tmp = pow(texture(tex, depth_uv), vec4(gamma));\n    float count = 0.06;\n    tmp = tmp*count;\n\n        for (int j = 0; j < ITERATIONS; j++)\n    {\n        // sample point\n        r += 1. / r;\n        vangle = rot * vangle;\n        if(cateye)\n            p = uv + GetDistOffset(uv,  (r-1.)*vangle)*scale;\n        else\n            p = uv + (r-1.) * vangle *scale;\n\n         // 增加距离中心远的采样点的权重\n        vec4 subsample  = texture(tex, p); /// ... Sample the image// .\n\n        // area protect\n        weight = texture(tex1, p).x;\n        if(weight<0.06)\n        {\n            continue;\n        }\n\n         // Calculate the average intensity of the accumulated color\n        float intensity = dot(subsample.rgb, vec3(0.299, 0.587, 0.114));\n\n         // Highlight Boosting and Saturation\n        // 保留颜色，调整亮度权重\n        if (intensity > 0.95) {\n            subsample.rgb *= HIGHLIGHT_BOOST;\n//            subsample.rgb += 0.1 * vec3(intensity,intensity,intensity);\n            weight *= 4.; // 增强高亮部分的权重\n        } else if (intensity > 0.7) {\n            weight *= 1.;\n        } else {\n            weight *= 2.;\n        }\n\n//        tmp += subsample * weight; // 直接累加原始颜色\n        // Modify color for warmer tone\n//        subsample.rgb = vec3(subsample.r * 1.05, subsample.g * 1.0, subsample.b * 0.9);\n\n        tmp += pow(subsample, vec4(gamma))*weight;\n\n        count +=weight;\n   }\n         vec4 color1 = pow(tmp/count, vec4(1.0/gamma));\n//    vec4 color1 = tmp / count; // 不再使用gamma纠正\n         color.rgb = color1.rgb;\n         return color;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy; //... with correct aspect ratio\n    \n    float time = mod(iTime*.2 +.25, 3.0);\n    \n\tfloat rad = (.8 - .8*cos(time * 6.283));\n  \n    if (iMouse.w >= 1.0)\n    {\n    \trad = (iMouse.x/iResolution.x)*3.0;\n\n    }   \n     vec4 color = vec4(Bokeh(iChannel0,iChannel1,iChannel2, uv, 1.4));\n     fragColor = color;\n\n\n}","name":"Image","description":"","type":"image"}]}