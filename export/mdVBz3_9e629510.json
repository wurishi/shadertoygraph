{"ver":"0.1","info":{"id":"mdVBz3","date":"1698486602","viewed":32,"name":"Fork Temple of  gest 089","username":"gest","description":"Somewhere in the ocean; use the mouse to investigate.\n\nOriginal https://www.shadertoy.com/view/Mll3W4\nI have a weak video card. I simplify everything I can","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","reflection","architecture"],"hasliked":0,"parentid":"Mll3W4","parentname":"Temple of the Waves"},"renderpass":[{"inputs":[],"outputs":[],"code":"//Original https://www.shadertoy.com/view/Mll3W4\n\n#define SHADERTOY\n//#define SUPER_GRAPHIC_CARD\n\n#ifdef SHADERTOY\n    #define main() mainImage( out vec4 fragColor, in vec2 fragCoord )\n    #define u_canvas iResolution\n    #define u_mouse iMouse\n    #define u_time iTime\n    #define gl_FragCoord fragCoord\n    #define gl_FragColor fragColor\n\t#define texture2D texture\n\t#define u_texture0 iChannel0\n\t#define u_texture1 iChannel1\n#endif\n\n#ifdef SUPER_GRAPHIC_CARD\n\t#define HARD_WATER\n\t#define HARD_BASE\n\t#define HARD_CLOUD\n\t#define HARD_NOISE\n#endif\n\nvec4 Hashv4f (float p) {\n\tconst vec4 cHashA4 = vec4 (0., 1., 57., 58.);\n\tconst float cHashM = 43758.54;\n  \treturn fract (sin (p + cHashA4) * cHashM);\n}\n\nvec4 Hashv4v3 (vec3 p) {\n\tconst vec3 cHashVA3 = vec3 (37.1, 61.7, 12.4);\n\tconst float cHashM = 43758.54;\n\tconst vec3 e = vec3 (1., 0., 0.);\n\treturn fract (sin (vec4 (dot (p + e.yyy, cHashVA3), dot (p + e.xyy, cHashVA3),\n\t \tdot (p + e.yxy, cHashVA3), dot (p + e.xxy, cHashVA3))) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p) {\n\tconst vec3 cHashA3 = vec3 (1., 57., 113.);\n\tvec2 i = floor (p);\n\tvec2 f = fract (p);\n\tf = f * f * (3. - 2. * f);\n\tvec4 t = Hashv4f (dot (i, cHashA3.xy));\n\treturn mix (mix (t.x, t.y, f.x), mix (t.z, t.w, f.x), f.y);\n}\n\nfloat Noisefv3a (vec3 p) {\n\tvec3 i = floor (p);  \n\tvec3 f = fract (p);\n\tf *= f * (3. - 2. * f);\n\tvec4 t1 = Hashv4v3 (i);\n\tvec4 t2 = Hashv4v3 (i + vec3 (0., 0., 1.));\n\treturn mix (mix (mix (t1.x, t1.y, f.x), mix (t1.z, t1.w, f.x), f.y),\n\t\t\t  mix (mix (t2.x, t2.y, f.x), mix (t2.z, t2.w, f.x), f.y), f.z);\n}\n\nfloat Fbmn (vec3 p, vec3 n) {\n\tvec3 s = vec3 (0.);\n\tfloat a = 1.;\n\t#ifdef HARD_NOISE\n\t\tconst int iters = 5;\n\t#else\n\t\tconst int iters = 1;\n\t#endif\n\tfor (int i = 0; i < 1; i ++) {\n\t\ts += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n\t\ta *= 0.5;\n\t\tp *= 2.;\n\t}\n\treturn dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f) {\n\tvec3 e = vec3 (0.2, 0., 0.);\n\tfloat s = Fbmn (p, n);\n\tvec3 g = vec3 (Fbmn (p + e.xyy, n) - s,\n\t \tFbmn (p + e.yxy, n) - s, Fbmn (p + e.yyx, n) - s);\n\treturn normalize (n + f * (g - n * dot (n, g)));\n}\n\nfloat PrBoxDf (vec3 p, vec3 b) {\n\t#if 0\n\t\tvec3 d = abs (p) - b;\n\t\treturn min (max (d.x, max (d.y, d.z)), 0.) + length (max (d, 0.));\n\t#else\n\t\tp = abs (p) - b;\n\t\treturn max (p.x, max (p.y, p.z));\n\t#endif\n}\n\nconst vec3 sunDir = normalize (vec3 (0.8, 1., -0.8));\n\nfloat tCur;\n\n#define FAR 150.\n#define ID_NONE -1.\n\n#define ID_WATER 0.\n#define ID_BASE_W 10.\n#define ID_BASE 11.\n#define ID_COL 12.\n#define ID_COL_END 13.\n#define ID_TOP 14.\n#define ID_ALTR 15.\n#define ID_BALL 16.\n\n\nfloat WaveHt (vec3 p) {\n\tconst mat2 qRot = mat2 (1.6, -1.2, 1.2, 1.6);\n\tfloat wFreq = 0.25, wAmp = 0.25, pRough = 5., ht = 0.;\n\tvec3 waterDisp = 0.2 * tCur * vec3 (-1., 0., 1.);\n\tvec2 q2 = p.xz + waterDisp.xz;\n\t#ifdef HARD_WATER\n\t\tconst int iters = 5;\n\t#else\n\t\tconst int iters = 2;\n\t#endif\n\tfor (int j = 0; j < iters; j ++) {\n\t\tvec2 t2 = 1.1 * tCur * vec2 (1., -1.);\n\t\tvec4 t4 = vec4 (q2 + t2.xx, q2 + t2.yy) * wFreq;\n\t\tt2 = vec2 (Noisefv2 (t4.xy), Noisefv2 (t4.zw));\n\t\tt4 += 2. * vec4 (t2.xx, t2.yy) - 1.;\n\t\tvec4 ta4 = abs (sin (t4));\n\t\tvec4 v4 = (1. - ta4) * (ta4 + abs (cos (t4)));\n\t\tvec2 v2 = pow (1. - sqrt (v4.xz * v4.yw), vec2 (pRough));\n\t\tht += (v2.x + v2.y) * wAmp;\n\t\tq2 *= qRot;  wFreq *= 2.;  wAmp *= 0.25;\n\t\tpRough = 0.8 * pRough + 0.2;\n\t}\n\treturn ht;\n}\n\nvec3 mapNormal_water (vec3 p, float eps) {\n\tvec2 e = vec2 (eps, 0.);\n  \tfloat ht = WaveHt (p);\n \treturn normalize (vec3 (ht - WaveHt (p + e.xyy), e.x, ht - WaveHt (p + e.yyx)));\n}\n\nObject WATER (vec3 p) {\n\t\n\tObject object = Object(FAR, ID_WATER, p);\n\t{\n\t\t#ifdef HARD_WATER\n\t\t\tobject.distance = TF_BEFORE(p.y, WaveHt(p));\n\t\t#else\n\t\t\tobject.distance = TF_BEFORE(p.y, 0.);\n\t\t#endif\n\t}\n\t\n\treturn object;\n}\n\nObject BUILD (vec3 p) {\n\tvec3 q;\n\tfloat d, dd;\n\n\tObject object = Object(FAR, ID_NONE, p);\n\t\n\tTF_TRANSLATE(p.y, 0.5);\n\t\n\tObject BASE_W = Object(FAR, ID_BASE_W, p);\n\t{\n\t\tq = p;\n\t\tTF_TRANSLATE(q.y, -0.2);\n\t\td = PrBoxDf(q, vec3 (8.6, 0.301, 10.6));\n\t\tBASE_W.distance = d;\n\t\tBASE_W.position = q;\n\t}\n\tobject = OR(object, BASE_W);\n\t\n\tObject BASE = Object(FAR, ID_BASE, p);\n\t{\n\t\tTF_TRANSLATE(q.y, 0.35);\n\t\td = PrBoxDf (q, vec3 (8.4, 0.101, 10.4));\n\t\tTF_TRANSLATE(q.y, 0.15);\n\t\tfloat d1 = TF_BOX (q, vec3 (8.2, 0.101, 10.2));\n\t\tBASE.distance = min (d, d1);\n\t\tBASE.position = q;\n\t}\n\tobject = OR(object, BASE);\n\t\n\tObject TOP = Object(FAR, ID_TOP, p);\n\t{\n\t\tTF_TRANSLATE(q.y, 5.52);\n\t\td = PrBoxDf (q, vec3 (7.55, 0.05, 9.55));\n\t\tfloat d_cut =  PrBoxDf (q, vec3 (4.45, 0.4, 6.45));\n\t\td = max (d, - d_cut);\n\t\t\n\t\tTF_REPLICA(q.xz, 2.);\n\t\td_cut = PrBoxDf (q, vec3 (0.45, 0.4, 0.45));\n\t\td = max (d, - d_cut);\n\t\t\n\t\tTOP.distance = d;\n\t\tTOP.position = q;\n\t}\n\tobject = OR(object, TOP);\n\n\tObject COL = Object(FAR, ID_COL, p);\n\t{\n\t\tq = p; \n\t\tTF_TRANSLATE(q.y, 3.1);\n\t\td = PrBoxDf (q, vec3 (8., 5., 10.));\n\t\tfloat d_cut = PrBoxDf (q, vec3 (4., 5., 6.));\n\t\tdd = max (d, - d_cut);\n\t\t \n\t\tq = p; \n\t\tTF_TRANSLATE(q.xz, 1.);\n\t\tTF_REPLICA(q.xz, 2.);\n\t\tTF_TRANSLATE(q.y, 3.1);\n\t\tfloat wr = q.y / 2.5;\n\t\tfloat d1 = TF_BALL(q.xz, 0.3 * (1.05 - 0.05 * wr * wr));\n\t\tfloat d1_between = TF_BETWEEN(q.y, 2.55);\n\t\td1 = max(d1, d1_between);\n\t\td = max (dd, d1);\n\t\t\n\t\tCOL.distance = d;\n\t\tCOL.position = q;\n\t}\n\tobject = OR(object, COL);\n\t\n\tObject COL_END = Object(FAR, ID_COL_END, p);\n\t{\n\t\tq = p;\n\t\tTF_TRANSLATE(q.xz, 1.);\n\t\tTF_REPLICA(q.xz, 2.);\n\t\t\n\t\tTF_TRANSLATE(q.y, 3.1);\n\t\tTF_MIRROR(q.y, 2.5);\n\t\tfloat d1 = TF_BALL(q.xz, 0.4);\n\t\tfloat d1_between = TF_BETWEEN(q.y, 0.07);\n\t\td = max(d1, d1_between);\n\t\t\n\t\tTF_TRANSLATE(q.y, 0.14);\n\t\td1 = PrBoxDf (q, vec3 (0.5, 0.07, 0.5));\n\t\td = min (d, d1);\n\t\t\n\t\td = max (d, dd);\n\t\tCOL_END.distance = d;\n\t\tCOL_END.position = q;\n\t}\n\tobject = OR(object, COL_END);\n\t\n\tObject ALTR = Object(FAR, ID_ALTR, p);\n\t{\n\t\tq = p;\n\t\tTF_TRANSLATE(q.y, 0.4);\n\t\tfloat d1 = TF_BALL(q.xz, 1.1);\n\t\tfloat d1_between = TF_BETWEEN(q.y, 0.2);\n\t\td = max(d1, d1_between);\n\t\t\n\t\tq = p;  \n\t\tTF_TRANSLATE(q.y, 1.);\n\t\tTF_MIRROR(q.xz, 0.4);\n\t\td1 = TF_BALL(q.xz, 0.15);\n\t\td1_between = TF_BETWEEN(q.y, 0.8);\n\t\td1 = max(d1, d1_between);\n\t\t\n\t\td = min (d, d1);\n\t\tALTR.distance = d;\n\t\tALTR.position = q;\n\t}\n\tobject = OR(object, ALTR);\n\t\n\tObject BALL = Object(FAR, ID_BALL, p);\n\t{\n\t\tq = p;  \n\t\tTF_TRANSLATE(q.y, 2.9);\n\t\td = TF_BALL (q, 1.5);\n\t\tBALL.distance = d;\n\t\tBALL.position = q;\n\t}\n\tobject = OR(object, BALL);\n\t\n\tobject.distance *= 0.95;\n\t\n\treturn object;\n}\n\nfloat map (vec3 p, inout Object object) {\n\tvec3 q;\n\tfloat d;\n\t\n\tobject = Object(FAR, ID_NONE, p);\n\t\n\tobject = OR(object, WATER(p));\n\tobject = OR(object, BUILD(p));\n\n\treturn object.distance;\n}\n\nfloat map ( in vec3 p ) {\n\tObject object;\n\treturn map (p, object);\n}\n\nvec3 mapNormal (vec3 p, float eps) {\n\tvec2 e = vec2 (eps, -eps);\n\tvec4 v = vec4 (\n\t\tmap (p + e.xxx), \n\t\tmap (p + e.xyy),\n\t \tmap (p + e.yxy), \n\t\tmap (p + e.yyx)\n\t);\n\treturn normalize (vec3 (v.x - v.y - v.z - v.w) + 2. * v.yzw);\n}\n\nfloat rayMarch(inout Ray ray) {\n\tray.distance = ray.near;\n\tfloat steps;\n\tfor (float i = 0.; i < 200.; ++i) {\n\t\tray.position = ray.origin + ray.direction * ray.distance;\n\t\tray.object.distance = map(ray.position, ray.object);\n\t\tray.hit = ray.object.distance < ray.epsilon;\n\t\tif (ray.hit) break;\n\t\tray.distance += ray.object.distance*ray.swing;\n\t\tif (ray.distance>ray.far) break;\n\t\tsteps = i + 1.;\n\t\tif (steps>ray.steps) break;\n\t}\n\treturn steps;\n}\n\nfloat softShadow( Ray ray, float k ) {\n\tfloat shade = 1.0;\n\tray.distance = ray.near;    \n\tfloat steps = 1.;\n\tfor ( int i = 0; i < 50; i++ ) {\n\t\tray.position = ray.origin + ray.direction * ray.distance;\n\t\tray.object.distance = map(ray.position);\n\t\tshade = min( shade, smoothstep( 0.0, 1.0, k * ray.object.distance / ray.distance)); \n\t\tray.hit = ray.object.distance < ray.epsilon;\n\t\tif (ray.hit) break;\n\t\tray.distance += min( ray.object.distance, ray.far / ray.steps * 2. ); \n\t\tif (ray.distance > ray.far ) break; \n\t\tsteps++;\n\t\tif (steps>ray.steps) break;\n\t}\n\treturn min( max( shade, 0.0 ) + 0.5, 1.0 ); \n}\n\nvec3 ObjCol (Ray ray) {\n\tvec3 col;\n\tvec3 p = ray.object.position;\n\tfloat sn = Noisefv3a (110. * p);\n\tif (ray.object.id == ID_BASE ||ray.object.id == ID_TOP) {\n\t\tcol = vec3 (0.7, 0.7, 0.6);\n\t} else if (ray.object.id == ID_BASE_W) {\n\t\tcol = mix (vec3 (0.7, 0.7, 0.6), vec3 (0.1, 0.4, 0.3) * sn, clamp (0.6 - 2. * p.y, 0., 1.));\n\t} else if (ray.object.id == ID_COL || ray.object.id == ID_COL_END) {\n\t\tcol = vec3 (0.6, 0.7, 0.5);\n\t} else if (ray.object.id == ID_ALTR) {\n\t\tcol = vec3 (0.6, 0.5, 0.2);\n\t}\n\tcol *= 0.7 + 0.3 * sn;\n\treturn col;\n}\n\nvec3 SkyCol (vec3 ro, vec3 rd) {\n\tconst vec3 sbCol = vec3 (0.2, 0.3, 0.55);\n\tvec3 col = sbCol + 0.25 * pow (1. - max (rd.y, 0.), 8.);\n\tfloat sd = max (dot (rd, sunDir), 0.);\n\tcol += 0.35 * pow (sd, 6.) + 0.65 * min (pow (sd, 256.), 0.3);\n\t//Облака\n\trd.y = abs (rd.y);\n\tvec3 cloudDisp = 1.5 * tCur * vec3 (1., 0., -1.);\n\tro += cloudDisp;\n\tvec2 p = 0.1 * (rd.xz * (50. - ro.y) / rd.y + ro.xz);\n\tfloat w = 0.8;\n\tfloat f = 0.;\n\t\n\t#ifdef HARD_CLOUD\n\t\tconst int iters = 4;\n\t#else\n\t\tconst int iters = 1;\n\t#endif\n\t\n\tfor (int j = 0; j < iters; j++) {\n\t\tf += w * Noisefv2 (p);\n\t\tw *= 0.5;\n\t\tp *= 2.;\n\t}\n\tcol = mix (col, vec3 (0.85), clamp (0.8 * f * rd.y + 0.1, 0., 1.));\n\treturn col;\n}\n\nvec3 lighting(Ray ray, vec3 lightDir, vec3 mColor) {\n\tRay ray1 = ray;\n\t{\n\t\tray1.origin \t= ray.position;\n\t\tray1.direction \t= lightDir;\n\t\tray1.steps \t\t= 50.;\n\t}\n\tfloat sh = softShadow (ray1, 20.);\n\t\n\tfloat diff = max (dot (ray.normal, lightDir), 0.);\n\tfloat back = max (dot (ray.normal, - normalize (vec3 (lightDir.x, 0., lightDir.z))), 0.);\n\tfloat spec = pow (max (0., dot (lightDir, reflect (ray.direction, ray.normal))), 64.);\n\treturn mColor * ( 0.2 + 0.2 *back + diff * 0.8 * sh)  +  sh * 0.3 * spec;\n}\n\nvec3 getNormal(Ray ray) {\n\tif (ray.object.id == ID_WATER) {\n\t\t#ifdef HARD_WATER\n\t\t\tray.normal =  mapNormal (ray.position, 0.001);\n\t\t#else\n\t\t\tray.normal = mapNormal_water (ray.position, 0.01);\n\t\t#endif\n\t} else {\n\t\tray.normal =  mapNormal (ray.position, 0.001);\n\t}\n\tvec3 p = ray.object.position;;\n\tif (ray.object.id == ID_COL) {\n\t\t#if 0\n\t\t\tfloat a = 0.5 - mod (12. * (atan (p.x, p.z) / (2. * PI) + 0.5), 1.);\n\t\t\tTF_ROTATE(ray.normal.xz, -0.15 * PI * sin (PI * a));\n\t\t#else\n\t\t\tTF_REPLICA_ANGLE(p.xz, 12., 0.);\n\t\t\tTF_ROTATE(ray.normal.xz, 0.5 * PI * p.x/length(p.xz));\n\t\t#endif\n\t}\n\t#ifdef HARD_BASE\n\t\tif (ray.object.id == ID_BASE || ray.object.id == ID_BASE_W) {\n\t\t\tray.normal = VaryNf (10. * p, ray.normal, 1.);\n\t\t} else {\n\t\t\tray.normal = VaryNf (20. * p, ray.normal, 0.5);\n\t\t}\n\t#endif\n\t\n\treturn ray.normal;\n}\n\nvec3 ShowScene (Ray ray) {\n\tvec3 col;\n\tfloat refl = 1.;\n\tbool waterRefl = false;\n\t\n\tfor (int i=0; i<2; i++) {\n\t\trayMarch (ray);\n\t\t\n\t\tif (ray.object.id == ID_BALL || ray.object.id == ID_WATER) {\n\t\t\tray.normal = getNormal(ray);\n\t\t\tif (ray.object.id == ID_WATER) waterRefl = true;\n\t\t\trefl *= 0.8;\n\t\t\t\n\t\t\tray.origin \t\t= ray.position;\n\t\t\tray.direction \t= reflect (ray.direction, ray.normal);\n\t\t\tray.steps \t\t= 50.;\n\t\t\t\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tbreak;\n\t}\n\n\tif (ray.distance < ray.far && !(ray.object.id == ID_WATER || ray.object.id == ID_BALL)) {\n\t\tray.normal = getNormal(ray);\n\n\t\tvec3 mColor = ObjCol (ray);\n\t\t\n\t\tcol = lighting(ray, sunDir, mColor);\n\t} else {\n\t\tcol = SkyCol (ray.origin, ray.direction);\n\t}\n\tcol *= refl;\n\n\t//Тонировка воды\n\tif (waterRefl) {\n\t\tcol = mix (\n\t\t\tvec3 (0, 0.07, 0.08), \n\t\t\t0.5*col,\n\t\t\t0.8 * pow (1. - abs (dot (ray.direction, ray.normal)), 4.)\n\t\t);\n\t}\n\n\treturn col;\n}\n\nvoid main() {\n\tfloat aspect = u_canvas.x / u_canvas.y;\n\tvec2 uv = 2. * gl_FragCoord.xy / u_canvas.xy - 1.;\n\t\n\ttCur = u_time;\n\t\n\tvec2 mouse = u_mouse.xy / u_canvas.xy - 0.5;\n\tif (mouse.xy==vec2(0)) mouse.xy = vec2(0.5);\n\t\n\tfloat dist = u_mouse.z==0. ? 2. + 13.*(1.-cos(tCur*0.5)) : max (2., 17. - 30. * mouse.y);\n\tfloat an = u_mouse.z==0. ? 0.5 * tCur : 2.2 * PI * mouse.x;\n\n\tCamera cam;\n\t{\n\t\tcam.fov     = 45.;\n\t\tcam.aspect  = aspect;\n\t\tcam.origin  = vec3 (dist, 5., dist);\n\t\tTF_ROTATE(cam.origin.xz, an);\n\t\tcam.target  = vec3 (0., 3., 0.);\n\t\tcam.up \t\t= vec3(0,1,0);\n\t}\n\t\n\tRay ray = lookAt(uv, cam);\n\t{\n\t\tray.near \t= 0.01;\n\t\tray.far  \t= FAR;\n\t\tray.epsilon = 0.001;\n\t\tray.swing\t= 1.;\n\t\tray.steps \t= 150.;\n\n\t}\n\t\n\tvec3 col = ShowScene (ray);\n\n\tcol = sqrt (col);\n\t\t\n\tgl_FragColor = vec4 (col, 1.);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"const float PI = radians(180.);\n//Камера\nstruct Camera {\n\t//Задаваемые параметры\n\tfloat fov, aspect;\n\tvec3  origin, target, up;\n\t//Расчетные параметры\n\tfloat factor;\n\tvec3  forward, right, position, coord;\n};\n\n//Параметры объекта\nstruct Object {\n\tfloat   distance;\t//Последнее приближение к объекту сцены\n\tfloat \tid;\t\t\t//id найденого объека сцены\n\tvec3 position;\n};\n\n//Луч\nstruct Ray {\n\t//Задаваемые параметры\n\tvec3  origin;\t\t//Начало луча\n\tvec3  direction;\t//Направление луча\n\tfloat near;\t\t\t//Минимальное расстояние от камеры (начало сцены)\n\tfloat far;\t\t\t//Максивальное расстояние от камеры (конец сцены)\n\tfloat epsilon;\t\t//Точность обнаружения поверхности\n\tfloat steps;\t\t//Максимальное число итераций\n\tfloat swing;\n\t//Вычисляемые параметры\n\tfloat distance; \t//Расстояние до объекта сцены от ray.origin в направлении ray.direction\n\tvec3  position; \t//Точка поверхности\n\tvec3  normal;\t\t//Нормаль в точке поверхности\n\tbool  hit;\t\t\t//Флаг нахождения точки поверхности с заданной точностью\n\tObject object;\t\t//Параметры объекта (можно формировать непосредственно в карте расстояний)\n};\n//Формирование луча камеры\nRay lookAt (in vec2 uv, inout Camera cam) {\n\t//Расчетные характеристики камеры\n\tcam.factor \t\t= 1.0/tan(radians(cam.fov/2.));\n\tcam.forward \t= normalize(cam.target-cam.origin); \n\tcam.right \t\t= normalize(cross(cam.forward, cam.up));\n\tcam.up \t\t\t= cross(cam.right, cam.forward);\n\tcam.position \t= cam.origin + cam.factor * cam.forward;\n\tcam.coord \t\t= cam.position + uv.x * cam.right * cam.aspect + uv.y * cam.up;\n\t//Формирование луча\n\tRay ray;\n\t{\n\t\tray.origin \t\t= cam.origin;\n\t\tray.direction \t= normalize(cam.coord - cam.origin);\n\t\t//Умолчания\n\t\tray.near\t\t= 0.01;\n\t\tray.far\t\t\t= 100.;\n\t\tray.epsilon\t\t= 0.001;\n\t\tray.swing\t\t= 1.0;\n\t\tray.steps\t\t= 200.;\n\t}\n\treturn ray;\n}\n\n//-------------------функции трансформации и позиционирования объектов сцены\n//Допустимая ошибка (для удаления артефактов)\n#define EPS 0.001\n//Функция расстояния до фигуры со скругленными ребрами (объединение и сглаживание с увеличением на R)\n//float d - сглаживание фигуры\n//vec2 d - объединение и сглаживание двух фигур\n//vec3 d - объединение и сглаживание трех фигур\n//vec4 d - объединение и сглаживание четырех фигур\n#define TF_ROUND(d, R) length(max(d, 0.)) - R\n//Функция расстояния до бокса (p vec3) или прямоугольника (p vec2) со скругленными ребрами\n//Функция расстояния до капсулы, если два размера 0\n#define TF_BOX_ROUND(p, S, R) TF_ROUND(abs(p)-S, R)\n//Функция расстояния до бокса (p vec3) или прямоугольника (p vec2)\n#define TF_BOX(p, S) TF_ROUND(abs(p) - S, EPS)\n//Функция расстояния до шара (p vec3) или круга (p vec2)\n#define TF_BALL(p, R) TF_ROUND(abs(p), R)\n//Функция расстояния до пространства ДО p1\n#define TF_BEFORE(p, p1) TF_ROUND(p - p1, 0.0)\n//Функция расстояния до пространства ПОСЛЕ p1\n#define TF_AFTER(p, p1) TF_ROUND(-p + p1, 0.0)\n//Функция расстояния до симметричного пространства МЕЖДУ -p1 и +p1\n#define TF_BETWEEN(p, p1) TF_ROUND(abs(p) - p1, 0.0)\n//Функция расстояния до несимметричного пространства МЕЖДУ p1 и p2\n#define TF_BETWEEN2(p, p1, p2) TF_ROUND( abs(p - 0.5*(p1+p2)) - 0.5*(p2-p1), 0.0)\n//Перемещение пространства p (float p...vec4 p)\n#define TF_TRANSLATE(p, d) p -= d;\n//Вращение пространства p (vec2 p)\n#if 0\n\t#define TF_ROTATE(p, a) p = mat2(cos(a), sin(a), -sin(a), cos(a)) * p\n#else\n\t#define TF_ROTATE(p, a) p = p.xy * cos (a) * vec2 (1., 1.) + p.yx * sin (a) * vec2 (-1., 1.)\n#endif\n//Отражение пространства p (float p...vec4 p)\n#define TF_MIRROR(p, d) p = abs(p) - d\n//Разбиение пространства на повторяющиеся. Возвращает id центра ячейки\n//float p - пространство 1D\n//vec2 p - пространство 2D\n//vec3 p - пространство 3D\n#define TF_REPLICA(p, d) \\\n\tfloor(p/d + 0.5);\\\n\tp = mod(p + 0.5*d, d) - 0.5*d\n//Разбиение пространства на повторяющиеся в диапазоне id от ida до idb включительно. Возвращает id центра ячейки\n#define TF_REPLICA_LIMIT(p, d, ida, idb) \\\n\tfloor(p/d + 0.5);\\\n\tp = p-d*clamp(floor(p/d + 0.5), ida, idb)\n//Разбиение пространства на повторяющиеся сектора в плоскости vec2 p. Возвращает id сектора\t\n#if 0\n\t#define TF_REPLICA_ANGLE(p, n, off) \\\n\t\tfloor(mod(atan(p.x, p.y) + PI /n + off, 2.*PI)/(2.* PI /n));\\\n\t\tfloat _p_ = mod(atan(p.x, p.y) + PI /n + off, 2.* PI /n) - PI /n;\\\n\t\tp = length(p.xy) * vec2(sin(_p_),cos(_p_))\n#else\n\t#define TF_REPLICA_ANGLE(p, n, off) \\\n\t\tfloor(mod(atan(p.x, p.y) + PI /n + off, 2.*PI)/(2.* PI /n));\\\n\t\tTF_ROTATE(p.xy, -off);\\\n\t\tTF_ROTATE(p.xy, (2.* PI /n) * floor ((atan (p.x, p.y)  + PI /n )/(2.* PI /n)) )\n#endif\t\n\t\n\t\n//-------------------Функции сочетания расстояний до объектов сцены\n//Сложение / Объединение / ИЛИ\nfloat OR(float distA, float distB) {\n\treturn mix(distA, distB, step(distB, distA)); //if (distB<distA) return distB; return distA;\n}\n//Умножение / Пересечение / И\nfloat AND(float distA, float distB) {\n\treturn mix(distA, distB, step(distA, distB)); //if (distB>distA) return distB; return distA;\n}\n// Минимальная функция сглаживания. Есть бесчисленное множество статей, но IQ объясняет это лучше всего здесь:\n// http://iquilezles.org/www/articles/smin/smin.htm\n//Гладкое сложение / Объединение / ИЛИ (k==0 без)\nfloat OR( float distA, float distB, float k ) {\n\tfloat h = clamp( 0.5 + 0.5*(distB-distA)/k, 0., 1. );\n\treturn mix( distB, distA, h ) - k*h*(1.-h);\n}\n//Гладкое умножение / Пересечение / И (k==0 без)\nfloat AND( float distA, float distB, float k ) {\n\tfloat h = clamp( 0.5 - 0.5*(distB-distA)/k, 0., 1. );\n\treturn mix( distB, distA, h ) + k*h*(1.-h);\n}\n//Исключение / НЕ\nfloat NOT(float dist) {\n\treturn -dist;\n}\n//-------------------Функции сочетания объектов сцены\n//Сложение / Объединение / ИЛИ\nObject OR(Object objectA, Object objectB) {\n\tif (objectB.distance<objectA.distance) return objectB;\n\treturn objectA;\n}\nObject OR(Object objectA, Object objectB, float k) {\n\tObject object = objectA;\n\tif (objectB.distance<objectA.distance) object = objectB;\n\tif (k!=0.) object.distance = OR(objectA.distance, objectB.distance, k);\n\treturn object;\n}\n\n//Умножение / Пересечение / И\nObject AND(Object objectA, Object objectB) {\n\tif (objectB.distance>objectA.distance) return objectB;\n\treturn objectA;\n}\nObject AND(Object objectA, Object objectB, float k) {\n\tObject object = objectA;\n\tif (objectB.distance>objectA.distance) object = objectB;\n\tif (k!=0.) object.distance = AND(objectA.distance, objectB.distance, k);\n\treturn object;\n}\n//Исключение / НЕ\nObject NOT(Object object) {\n\tobject.distance = -object.distance;\n\treturn object;\n}\n\n\n","name":"Common","description":"","type":"common"}]}