{"ver":"0.1","info":{"id":"3tVcDt","date":"1611986105","viewed":277,"name":"Noise Generation Illustration","username":"wind_flows","description":"To Illustrate Different Kinds of Noise's Generation Algorithm","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["noise","perlin","curl","worley","value","etc"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // split screen into two halves and keep xy same size\n    vec2 uv = (-iResolution.xy + 2.0*fragCoord) / iResolution.y;\n\n    //get different noises\n    //vec3 noise = valueNoise(uv * 16.0);\n    //vec3 noise = whiteNoise(uv);\n    vec3 noise = perlin2DNoise(uv * 8.0, true);\n    //vec4 noise = simplexNoise(uv * 8.0);\n    //vec3 noise = vec3(Worley2D(uv * 4.0, true));\n    //vec3 noise = vec3(Worley3D(uv, 4.0, 2.0, 2.0, false));\n    //vec3 noise = vec3(Worley2DFBM(uv* 2.0, 3, true));\n    //vec4 noise = SimplexFBM(uv*8.0, 7);\n    //vec3 noise = Perlin2DFBM(uv*8.0, false, 0, 1);\n    //vec2 noise = curlNoise(uv * 8.0, false, 0, 3);\n    //vec3 noise = curlNoiseVisulize(uv, 1.0);\n    //vec3 col = noise;\n    //vec3 col = vec3(noise.xy, 0.0);\n    vec3 col = 0.5 + 0.5 * ((uv.x > 0.0) ? vec3(noise.yz, 0.0) : noise.xxx);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"\n//2d in, 1d out\nfloat hash2d(vec2 uv)\n{\n    uv  = 50.0 * fract(uv * 0.3183099 + vec2(0.71, 0.113));\n    return -1.0 + 2.0 * fract(uv.x * uv.y * (uv.x + uv.y));\n}\n\n//https://thebookofshaders.com/10/\n//2d in, 1d out\nfloat hash2dsin(vec2 uv)\n{\n    float randomNum = dot(uv.xy,vec2(12.9898,78.233));\n    return fract(sin(randomNum)*43758.5453123);\n}\n\n//2d in, 2d out\nvec2 hash2d2(in vec2 uv)\n{\n    const vec2 k = vec2( 0.3183099, 0.3678794 );\n    uv = uv * k + k.yx;\n    return -1.0 + 2.0 * fract( 16.0 * k * fract( uv.x * uv.y*(uv.x+uv.y)) );\n}\n\n//3d in, 3d out\nvec3 hash3d3(vec3 pos)\n{\n\tpos = vec3(dot(pos, vec3(127.1, 311.7,  74.7)), \n\t\t\t  dot(pos, vec3(269.5, 183.3, 246.1)), \n\t\t\t  dot(pos, vec3(113.5, 271.9, 124.6)));\n\n\treturn  - 1.0 + 2.0 * fract(sin(pos) * 43758.5453123);\n}\n\n\n// return value noise (in x) and its derivatives (in yz)\n// https://www.shadertoy.com/view/4dXBRH\nvec3 valueNoise(vec2 uv)\n{\n\t//int position used for random number generation\n    vec2 intPos = floor( uv );\n\t\n\t//frac position used for interpolation\n    vec2 fracPos = fract( uv );\n\t\n\t//get the interpolation weights(u) and weights derivatives(du)\n#if 1\n    // quintic interpolation\n    vec2 u = fracPos * fracPos * fracPos * (fracPos *( fracPos * 6.0 - 15.0) + 10.0);\n    vec2 du = 30.0 * fracPos * fracPos * (fracPos * (fracPos - 2.0) + 1.0);\n#else\n    // cubic interpolation\n    vec2 u = fracPos * fracPos * (3.0 - 2.0 * fracPos);\n    vec2 du = 6.0 * fracPos *( 1.0 - fracPos);\n#endif    \n    \n\t//generate 4 different random value on 4 neighbor vertices\n    float va = hash2d( intPos + vec2(0.0, 0.0) );\n    float vb = hash2d( intPos + vec2(1.0, 0.0) );\n    float vc = hash2d( intPos + vec2(0.0, 1.0) );\n    float vd = hash2d( intPos + vec2(1.0, 1.0) );\n    \n    float k0 = va;\n    float k1 = vb - va;//horizontal\n    float k2 = vc - va;//vertical\n    float k4 = va - vb - vc + vd;\n\t\n\t//mix(mix(va, vb, u.x), mix(vc, vd, u.x), u.y);\n\tfloat value = k0 + k1 * u.x + k2 * u.y + k4 * u.x * u.y;\n\t\n\t//vec2(d value / du.xy)\n\tvec2 derivative = du * (u.yx * k4 + vec2(k1, k2));\n    return vec3(value, derivative); \n}\n\n// return gradient noise (in x) and its derivatives (in yz)\n//  https://www.shadertoy.com/view/XdXBRH\nvec3 perlin2DNoise(in vec2 uv, bool revert)\n{\n    vec2 i = floor(uv);\n    vec2 f = fract(uv);\n\n#if 1\n    // quintic interpolation\n    vec2 u = f * f * f * (f * (f * 6.0 - 15.0)+10.0);\n    vec2 du = 30.0 * f * f * (f * (f - 2.0)+1.0);\n#else\n    // cubic interpolation\n    vec2 u = f * f * (3.0 - 2.0 * f);\n    vec2 du = 6.0 * f * (1.0 - f);\n#endif    \n    \n\t//random gradients\n    vec2 ga = hash2d2(i + vec2(0.0,0.0));\n    vec2 gb = hash2d2(i + vec2(1.0,0.0));\n    vec2 gc = hash2d2(i + vec2(0.0,1.0));\n    vec2 gd = hash2d2(i + vec2(1.0,1.0));\n    \n\t//random values by random gradients\n    float va = dot(ga, f - vec2(0.0,0.0));\n    float vb = dot(gb, f - vec2(1.0,0.0));\n    float vc = dot(gc, f - vec2(0.0,1.0));\n    float vd = dot(gd, f - vec2(1.0,1.0));\n\n\t//mix(mix(va, vb, u.x), mix(vc, vd, u.x), u.y);\n\tfloat value = va + u.x * (vb - va) + u.y * (vc - va) + u.x * u.y * (va - vb - vc + vd);\n\t\n\t//mix(mix(ga, gb, u.x), mix(gc, gd, u.x), u.y);\n\tvec2 derivatives = ga + u.x * (gb - ga) + u.y * (gc - ga) + u.x * u.y * (ga - gb - gc +gd) + du * (u.yx * (va - vb - vc + vd) + vec2(vb,vc) - va);\n\t\n    if(revert)\n        value = 1.0 - 2.0 * value;\n        \n    return vec3(value, derivatives);\n}\n\n\nvec3 Perlin2DFBM(in vec2 uv, bool revert, int startOctave, int octave)\n{\n    vec3 noise = vec3(0.0);\n    float frequency = 1.0;\n    float amplitude = 1.0;\n    for(int i = 0; i < startOctave + octave; i++)\n    {\n        if(i >= startOctave)          \n            noise += perlin2DNoise(uv * frequency, revert) * amplitude;\n        frequency *= 2.0;\n        amplitude *= 0.5;\n    }\n    return noise;\n}\n\n\n// return value noise (in x) and its derivatives (in yzw)\n// https://www.shadertoy.com/view/4dffRH\nvec4 perlinNoise3D(in vec3 pos)\n{\n    // grid\n    vec3 i = floor(pos);\n    vec3 w = fract(pos);\n    \n    #if 1\n    // quintic interpolant\n    vec3 u = w * w * w * (w * (w * 6.0 - 15.0) + 10.0);\n    vec3 du = 30.0 * w * w * (w * (w - 2.0) + 1.0);\n    #else\n    // cubic interpolant\n    vec3 u = w * w * (3.0 - 2.0 * w);\n    vec3 du = 6.0 * w * (1.0 - w);\n    #endif    \n    \n    // gradients\n    vec3 ga = hash3d3(i + vec3(0.0, 0.0, 0.0));\n    vec3 gb = hash3d3(i + vec3(1.0, 0.0, 0.0));\n    vec3 gc = hash3d3(i + vec3(0.0, 1.0, 0.0));\n    vec3 gd = hash3d3(i + vec3(1.0, 1.0, 0.0));\n    vec3 ge = hash3d3(i + vec3(0.0, 0.0, 1.0));\n\tvec3 gf = hash3d3(i + vec3(1.0, 0.0, 1.0));\n    vec3 gg = hash3d3(i + vec3(0.0, 1.0, 1.0));\n    vec3 gh = hash3d3(i + vec3(1.0, 1.0, 1.0));\n    \n    // projections\n    float va = dot(ga,  w - vec3(0.0, 0.0, 0.0));\n    float vb = dot(gb,  w - vec3(1.0, 0.0, 0.0));\n    float vc = dot(gc,  w - vec3(0.0, 1.0, 0.0));\n    float vd = dot(gd,  w - vec3(1.0, 1.0, 0.0));\n    float ve = dot(ge,  w - vec3(0.0, 0.0, 1.0));\n    float vf = dot(gf,  w - vec3(1.0, 0.0, 1.0));\n    float vg = dot(gg,  w - vec3(0.0, 1.0, 1.0));\n    float vh = dot(gh,  w - vec3(1.0, 1.0, 1.0));\n\t\n    // interpolations\n    return vec4(va + u.x * (vb - va) + u.y * (vc - va) + u.z * (ve - va) + u.x * u.y * (va - vb - vc + vd) + u.y * u.z * (va - vc - ve + vg) + u.z * u.x * (va - vb - ve + vf) + ( - va + vb + vc - vd + ve - vf - vg + vh) * u.x * u.y * u.z,     // value\n                 ga + u.x * (gb - ga) + u.y * (gc - ga) + u.z * (ge - ga) + u.x * u.y * (ga - gb - gc + gd) + u.y * u.z * (ga - gc - ge + gg) + u.z * u.x * (ga - gb - ge + gf) + ( - ga + gb + gc - gd + ge - gf - gg + gh) * u.x * u.y * u.z +   // derivatives\n                 du * (vec3(vb, vc, ve) - va + u.yzx * vec3(va - vb - vc + vd, va - vc - ve + vg, va - vb - ve + vf) + u.zxy * vec3(va - vb - ve + vf, va - vb - vc + vd, va - vc - ve + vg) + u.yzx * u.zxy * ( - va + vb + vc - vd + ve - vf - vg + vh)));\n}\n\n// uv lies in triangle space\nvec4 simplexNoise(in vec2 uv)\n{\n\t//transform from triangle to quad\n    const float K1 = 0.366025404; // (sqrt(3)-1)/2;\n\t//transform from quad to triangle\n    const float K2 = 0.211324865; // (3 - sqrt(3))/6;\n\n\t//Find the rectangle vertex\n\tvec2  quadIntPos = floor(uv + (uv.x + uv.y)*K1);\n\t//relative coorindates from origin vertex A\n    vec2  vecFromA = uv - quadIntPos + (quadIntPos.x + quadIntPos.y)*K2;\n    //1 if x > y, else 0\n    float IsLeftHalf = step(vecFromA.y,vecFromA.x); \n    vec2  quadVertexOffset = vec2(IsLeftHalf,1.0 - IsLeftHalf);\n\t//vecFromA - (quadVertexOffset + (quadVertexOffset.x + quadVertexOffset.y ) * K2)\n    vec2  vecFromB = vecFromA - quadVertexOffset + K2;\n\t//vecFromA - (vec(1, 1) + (1 + 1 ) * K2)\n\tvec2  vecFromC = vecFromA - 1.0 + 2.0 * K2;\n    vec3  falloff = max(0.5 - vec3(dot(vecFromA,vecFromA), dot(vecFromB,vecFromB), dot(vecFromC,vecFromC)), 0.0);\n\tvec2 ga = hash2d2(quadIntPos + 0.0);\n\tvec2 gb = hash2d2(quadIntPos + quadVertexOffset);\n\tvec2 gc = hash2d2(quadIntPos + 1.0);\n\tvec3 simplexGradient = vec3(dot(vecFromA,ga), dot(vecFromB,gb), dot(vecFromC, gc));\n\tvec3  n = falloff * falloff * falloff * falloff * simplexGradient;\n\t//blend all vertices' contribution\n    return vec4(dot(n, vec3(70.0)), n);\n}\n\nvec4 SimplexFBM(in vec2 uv, int octave)\n{\n    vec4 noise = vec4(0.0);\n    float frequency = 1.0;\n    float amplitude = 1.0;\n    for(int i = 0; i < octave; i++)\n    {\n        noise += simplexNoise(uv * frequency) * amplitude;\n        frequency *= 2.0;\n        amplitude *= 0.5;\n    }\n    return noise;\n}\n\n\nfloat Worley2D(vec2 uv, bool revert)\n{\n    float Dist = 16.0;\n    vec2 intPos = floor(uv);\n    vec2 fracPos = fract(uv);\n    //search range\n    const int Range = 2;\n    for(int X = -Range; X <= Range; X++)\n\t{\n\t\tfor(int Y = -Range; Y <= Range; Y++)\n\t\t{\n\t\t\tfloat D = distance(hash2d2(intPos + vec2(X,Y)) + vec2(X,Y), fracPos);\n            // take the feature point with the minimal distance\n\t\t\tDist = min(Dist,D);\n\t\t}\n\t}\n    //use the distance as output\n    if(revert)\n        return 1.0 - 2.0 * Dist;\n    else\n        return Dist;\n}\n\n\nfloat Worley3D(vec2 uv, float Cell, float nRows, float nCols, bool revert)\n{\n    vec2 PlaneUV = fract(uv);\n    vec2 SliceIndex = floor(uv);\n    float fSliceIndex = SliceIndex.x + SliceIndex.y * nCols;\n    float w = fSliceIndex / (nRows * nCols);\n    vec3 uvw = vec3(PlaneUV.x, PlaneUV.y, w) * Cell;\n    \n    float Dist = 65.0;\n    vec3 intPos = floor(uvw);\n    vec3 fracPos = fract(uvw);\n    //search range\n    const int Range = 2;\n    for(int X = -Range; X <= Range; X++)\n\t{\n\t\tfor(int Y = -Range; Y <= Range; Y++)\n\t\t{\n            for(int Z = -Range; Z <= Range; Z++)\n\t\t\t{\n                vec3 CellIndex = intPos + vec3(X,Y,Z);\n                //To Make Noise Successive In All Dirctions\n                CellIndex = fract((CellIndex + float(Cell)) / Cell)*Cell;\n                float D = distance(hash3d3(CellIndex) + vec3(X,Y,Z), fracPos);\n                // take the feature point with the minimal distance\n                Dist = min(Dist,D);\n            }\n\t\t}\n\t}\n    //use the distance as output\n    if(revert)\n        return 1.0 - 2.0 * Dist;\n    else\n        return Dist;\n}\n\nfloat Worley2DFBM(vec2 uv, int octave, bool revert)\n{\n    float noise = 0.0;\n    float frequency = 1.0;\n    float amplitude = 1.0;\n    for(int i = 0; i < octave; i++)\n    {\n        noise += Worley2D(uv * frequency, revert) * amplitude;\n        frequency *= 2.0;\n        amplitude *= 0.5;\n    }\n    return noise;\n}\n\n\nvec3 whiteNoise(vec2 uv)\n{\n    return vec3(hash2dsin(uv));\n}\n\n//http://platforma-kooperativa.org/media/uploads/curl_noise_slides.pdf\nvec2 curlNoise(vec2 uv, bool revertPerlin, int startOctave, int accumOctaves)\n{\n\tfloat eps = 0.00001;\n\tfloat x = uv.x;\n\tfloat y = uv.y;\n\t//Find rate of change in X direction\n\tfloat n1 = Perlin2DFBM(vec2(x, y + eps), revertPerlin, startOctave, accumOctaves).x;\n\tfloat n2 = Perlin2DFBM(vec2(x, y - eps), revertPerlin, startOctave, accumOctaves).x;\n\t//Average to find approximate derivative\n\tfloat a = (n1 - n2)/(2.0 * eps);\n\n\t//Find rate of change in Y direction\n\tfloat n3 = Perlin2DFBM(vec2(x + eps, y), revertPerlin, startOctave, accumOctaves).x;\n\tfloat n4 = Perlin2DFBM(vec2(x - eps, y), revertPerlin, startOctave, accumOctaves).x;\n\t//Average to find approximate derivative\n\tfloat b = (n3 - n4)/(2.0 * eps);\n\n\t//Curl\n\treturn vec2(a, -b);\n}\n\n\nconst float arrowLen = .25;\n\nfloat arrowSegment(in vec2 uv, in vec2 startPoint, in vec2 endPoint, float arrowDensity) //from iq\n{\n\tvec2 curPixVec = uv - startPoint;\n\tvec2 arrowLine = endPoint - startPoint;\n\tfloat projLen = clamp(dot(curPixVec, arrowLine) / dot(arrowLine,arrowLine), 0.0, 1.0);\n\t// cur pixel offset from arrow line\n\treturn length(curPixVec - arrowLine*projLen) * 20.0 * arrowDensity;\n}\n\n//https://www.shadertoy.com/view/4tfSRj\nfloat fieldVisulizer(in vec2 uv, bool revertPerlin, int startOctave, int accumOctaves, float frequency)\n{\n    float arrowDensity = 20.0 / frequency;\n\t//step signal with span = 1.0/arrowDensity\n    vec2 stepUV = floor(uv * arrowDensity) / arrowDensity + 0.5 / arrowDensity;\n\t//force vector\n    vec2 vector = curlNoise(stepUV, revertPerlin, startOctave, accumOctaves);\n    float arrowLen = pow(length(vector), 0.5) * (arrowLen / arrowDensity);\n    vec2 visVector = normalize(vector) * arrowLen;\n\t//arrow main part\n    float rz = arrowSegment(uv, stepUV, stepUV + visVector, arrowDensity);\n    vec2 perpendicularVec = (vec2(-visVector.y,visVector.x));\n\t//arrow left element\n    rz = min(rz, arrowSegment(uv, stepUV+visVector, stepUV + visVector * 0.65 + perpendicularVec * 0.3, arrowDensity));\n\t//arrow right element\n    return clamp(min(rz, arrowSegment(uv, stepUV + visVector, stepUV + visVector * 0.65 - perpendicularVec * 0.3, arrowDensity)), 0.0, 1.0);\n}\n\nvec3 curlNoiseVisulize(in vec2 uv, float frequency)\n{\n    uv *= frequency;\n    \n    bool revertPerlin = false;\n    int startOctave = 0;\n    int accumOctaves = 7;\n    float perlinNoise = Perlin2DFBM(uv, revertPerlin, startOctave, accumOctaves).x;\n    vec2 field = curlNoise(uv, revertPerlin, startOctave, accumOctaves);\n    vec3 col = sin(vec3(-0.3, 0.1, 0.5) + field.x - field.y) * 0.65 + 0.35;\n    col = mix(col, vec3(field.x, -field.x, field.y), smoothstep(0.75, 1.0, sin(0.4))) * 0.85;\n    float fviz = fieldVisulizer(uv, revertPerlin, startOctave, accumOctaves, frequency);\n    col = max(col, 1.0 - fviz * vec3(1.0));\n    col = vec3(field, 1.0 - fviz * vec3(1.0));\n    col = vec3(max(perlinNoise, 1.0 - fviz));\n    return col;\n}\n","name":"Common","description":"","type":"common"}]}