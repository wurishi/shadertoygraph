{"ver":"0.1","info":{"id":"Dsj3Dc","date":"1668596019","viewed":404,"name":"VHS_Effect","username":"Piotr_Mrozik","description":"VHS effect shader- recruitment task 11.2022, Piotr Mrozik\n","likes":9,"published":1,"flags":0,"usePreview":1,"tags":["vhs"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sX3Rn","filepath":"/media/a/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv","previewfilepath":"/media/ap/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv","type":"video","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float bendscale = 1.4;\nconst float noiseIntensity = 0.0088;\n\nconst float colorOffsetIntensity = 1.3;\n\n// Get Pseudo Random value for given coord.\nfloat Random(vec2 co, float intensity){\n    return intensity * fract(sin(iTime* dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvec3 LoadTextureWithFilter (sampler2D tex, vec2 UV)\n{\n    vec2 fragCoord = UV*iResolution.xy ;\n\n    // This offest for chromatic abberation effect is totaly fake, however it looks sufficient, and connecting aberration with lense distortion will be much more expensive.\n    vec2 rOffset = vec2(-0.001,-0.0005);\n    vec2 bOffset = vec2(0.001,0.001);\n\n    float sharpenFactor =1.5;\n    // Sharpen matrix:\n    //    [0,1,0]\n    //    [1,-4,1]\n    //    [0,1,0]\n\n\n    // Applying Kernel effect on each channel looks terrible, but I'm not sure if I'm allowed to use multipass.\n    // Normally I would render image with aberration into the separate buffer, and after that, use kernel filter on the buffer.\n    // Similar case is with some Gaussian Blur BEFORE sharpen mask. However I see no way to do it conveniently without separate texture buffer.\n\n    float upR = texture (tex, (fragCoord + vec2 (0, 1) + rOffset)/iResolution.xy).r;\n    float upG = texture (tex, (fragCoord + vec2 (0, 1))/iResolution.xy).g;\n    float upB = texture (tex, (fragCoord + vec2 (0, 1) + bOffset)/iResolution.xy).b;\n\n    float leftR = texture (tex, (fragCoord + vec2 (-1, 0) + rOffset)/iResolution.xy).r;\n    float leftG = texture (tex, (fragCoord + vec2 (-1, 0))/iResolution.xy).g;\n    float leftB = texture (tex, (fragCoord + vec2 (-1, 0) + bOffset)/iResolution.xy).b;\n\n    float centerR = texture (tex, fragCoord/iResolution.xy + rOffset).r;\n    float centerG = texture (tex, fragCoord/iResolution.xy).g;\n    float centerB = texture (tex, fragCoord/iResolution.xy + bOffset).b;\n\n    float rightR = texture (tex, (fragCoord + vec2 (1, 0) + rOffset)/iResolution.xy).r;\n    float rightG = texture (tex, (fragCoord + vec2 (1, 0))/iResolution.xy).g;\n    float rightB = texture (tex, (fragCoord + vec2 (1, 0) + bOffset)/iResolution.xy).b;\n\n    float downR = texture (tex, (fragCoord + vec2 (0, -1) + rOffset)/iResolution.xy).r;\n    float downG = texture (tex, (fragCoord + vec2 (0, -1))/iResolution.xy).g;\n    float downB = texture (tex, (fragCoord + vec2 (0, -1) + bOffset)/iResolution.xy).b;\n\n    // Return edge detection\n    return (1.0 + 4.0*sharpenFactor)*vec3(centerR, centerG, centerB) -\n        sharpenFactor*(vec3(upR, upG, upB) + vec3(leftR, leftG, leftB) + vec3(rightR, rightG, rightB) + vec3(downR, downG, downB));\n}\n\n\n// Get font UV coords from screen coords\nvec2 FontFromScreen(in vec2 tpos, in float fontSize, in vec2 charPos)\n{\n    return (tpos/fontSize + charPos + 0.5)/16.0;\n}\n\nint IntToAscii(in int x)\n{\n    return x + 48;\n}\n\nvec3 DrawCharacterOnScreen(in vec2 fragCoord, in int characterID, in vec2 letterPositionOnScreen, in float fontSize)\n{\n    vec2 letterPosition = (fragCoord - iResolution.xy * letterPositionOnScreen);\n\n     // Character offset  within font texture\n    vec2 charPosition = vec2(ivec2(characterID%16, 15-characterID/16));\n\n    // Get uv in font texture\n    vec2 uv = FontFromScreen(letterPosition, fontSize, charPosition);\n\n    float rLetter = 1.0-texture(iChannel1, uv).x;\n    float gLetter = 1.0-texture(iChannel1, uv+0.002).x;\n    float bLetter = 1.0-texture(iChannel1, uv-0.002).x;\n\n    vec3 letter = vec3(rLetter, gLetter, bLetter);\n    // Mask choosen letter\n    vec2 box = abs(letterPosition) - 0.5*fontSize;\n\n    float rBoxValue = step(rLetter, max(box.x, box.y));\n    float gBoxValue = step(gLetter, max(box.x, box.y));\n    float bBoxValue = step(bLetter, max(box.x, box.y));\n\n    return ((vec3(1.0)-vec3(rBoxValue,gBoxValue,bBoxValue))*(vec3(1.0)-vec3(rLetter,gLetter ,bLetter)));\n}\n\nvec2 screenDistort(vec2 uv)\n{\n\tuv -= vec2(.5,.5);\n\tuv = uv*bendscale*(1./1.2+2.*uv.x*uv.x*uv.y*uv.y);\n\tuv += vec2(.5,.5);\n\n\treturn uv;\n}\n\nvec2 scale2D(vec2 uv, vec2 scale)\n{\n    mat2 scaleMatrix =  mat2(scale.x,0.0,\n                            0.0, scale.y);\n\n    return uv*scaleMatrix;\n}\n\nvec3 DrawAllLetters(inout vec3 color, in vec2 UV)\n{\n    float fontSize = 0.1 * iResolution.y;\n    float blink = step(0.5,(sin(5.0 * iTime) + 1.0) / 2.0);\n    vec3 currentLetter;\n    vec2 fragCoord = UV*iResolution.xy ;\n\n    //---------------------------------Draw all characters---------------------------------\n\n    //Draw *REC\n    currentLetter = DrawCharacterOnScreen(fragCoord, 3, vec2(0.1, 0.85), fontSize);\n    color+=(currentLetter * blink * vec3(1.0,0.0,0.0));\n\n    currentLetter = DrawCharacterOnScreen(fragCoord, 82, vec2(0.13, 0.85), fontSize);\n    color+=(currentLetter);\n\n    currentLetter = DrawCharacterOnScreen(fragCoord, 69, vec2(0.16, 0.85), fontSize);\n    color+=(currentLetter);\n\n    currentLetter = DrawCharacterOnScreen(fragCoord, 67, vec2(0.19, 0.85), fontSize);\n    color+=(currentLetter);\n\n    //Draw current day\n    float day = iDate.z;\n    int daySecond = int(mod(day,10.0));\n    int dayFirst = (int(day) - daySecond) / 10;\n\n    currentLetter = DrawCharacterOnScreen(fragCoord, IntToAscii(dayFirst), vec2(0.1, 0.1), fontSize);\n    color+=(currentLetter);\n\n    currentLetter = DrawCharacterOnScreen(fragCoord, IntToAscii(daySecond), vec2(0.13, 0.1), fontSize);\n    color+=(currentLetter);\n\n    currentLetter = DrawCharacterOnScreen(fragCoord, 46, vec2(0.15, 0.1), fontSize);\n    color+=(currentLetter);\n\n    //Draw current month   (This +1 is some strange bug on shadertoy site. I suppose they have wrong month in the system. :) )\n    float month = iDate.y + 1.0;\n    int monthSecond = int(mod(floor(month + 0.1),10.0));\n    int monthFirst = (int(month)-monthSecond)/10;\n\n    currentLetter = DrawCharacterOnScreen(fragCoord, IntToAscii(monthFirst), vec2(0.17, 0.1), fontSize);\n    color+=(currentLetter);\n\n    currentLetter = DrawCharacterOnScreen(fragCoord, IntToAscii(monthSecond), vec2(0.20, 0.1), fontSize);\n    color+=(currentLetter);\n\n    //CurrentTime\n    float hour = (iDate.w / 3600.0);\n    int hourSecond = int(mod(hour,10.0));\n    int hourFirst = (int(hour) - hourSecond) / 10;\n\n    float minute = (mod(iDate.w / 60.0, 60.0));\n    int minuteSecond = int(mod(minute,10.0));\n    int minuteFirst = (int(minute) - minuteSecond) / 10;\n\n    currentLetter = DrawCharacterOnScreen(fragCoord, IntToAscii(hourFirst), vec2(0.7, 0.1), fontSize);\n    color+=(currentLetter);\n\n    currentLetter = DrawCharacterOnScreen(fragCoord, IntToAscii(hourSecond), vec2(0.73, 0.1), fontSize);\n    color+=(currentLetter);\n\n    currentLetter = DrawCharacterOnScreen(fragCoord, 58, vec2(0.75, 0.1), fontSize);\n    color+=(currentLetter);\n\n\n    currentLetter = DrawCharacterOnScreen(fragCoord, IntToAscii(minuteFirst), vec2(0.77, 0.1), fontSize);\n    color+=(currentLetter);\n\n    currentLetter = DrawCharacterOnScreen(fragCoord, IntToAscii(minuteSecond), vec2(0.8, 0.1), fontSize);\n    color+=(currentLetter);\n\n    currentLetter = DrawCharacterOnScreen(fragCoord, 58, vec2(0.825, 0.1), fontSize);\n    color+=(currentLetter);\n\n\n    float second = (mod(iDate.w, 60.0));\n    int secondSecond = int(mod(second,10.0));\n    int secondFirst = (int(second) - secondSecond) / 10;\n\n    currentLetter = DrawCharacterOnScreen(fragCoord, IntToAscii(secondFirst), vec2(0.85, 0.1), fontSize);\n    color+=(currentLetter);\n\n    currentLetter = DrawCharacterOnScreen(fragCoord, IntToAscii(secondSecond), vec2(0.88, 0.1), fontSize);\n    color+=(currentLetter);\n\n    return color;\n}\n\nfloat box(vec2 st, vec2 size, float _smoothEdges)\n{\n    size = vec2(0.5) - size*0.5;\n    vec2 aa = vec2(_smoothEdges*0.5);\n    vec2 uv = smoothstep(size,size+aa,st);\n    uv *= smoothstep(size,size+aa,vec2(1.0)-st);\n    return uv.x*uv.y;\n}\n\nfloat horizontalBar(float pos, float uvY, float offset)\n{\n    float barRange = 0.05;\n    float edge0 = (pos - barRange);\n    float edge1 = (pos + barRange);\n\n    float x = smoothstep(edge0, pos, uvY) * offset;\n    x -= smoothstep(pos, edge1, uvY) * offset;\n    return x;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 UV = fragCoord/iResolution.xy;\n    vec3 pixelColor = vec3(0.0,0.0,1.0);\n\n    // Add some fake lense distortion.\n    UV=screenDistort(UV);\n    UV=scale2D(UV, vec2(0.85));\n    UV+=vec2(0.075,0.075);\n\n    const float offsetIntensity = 0.001;\n\n    //Add some weavy horizontal noise for uv\n    for (float i = 0.0; i < 1.0; i += 0.1)\n    {\n       float d = mod(iTime * i, 1.7);\n       float o = sin(1.0 - tan(iTime * 0.24 * i));\n       o *= offsetIntensity;\n       UV.x += horizontalBar(d, UV.y, o);\n    }\n\n    // Load video texture and imidietly apply sharpen Kernel filer, and fake chromatic aberration.\n    pixelColor = LoadTextureWithFilter (iChannel0, UV);\n   \n    // Draw all the letters on \"camera visier\"\n    pixelColor = DrawAllLetters(pixelColor, UV);\n\n    // Black everything what is outside lens distortion and smooth sharp black edges\n    pixelColor*=box(UV,vec2(1.0),0.1);\n\n    // Give a little R0B tint\n    pixelColor+=vec3(0.03,0.0,0.05);\n\n    // Put some white nosie on top of everything.\n    pixelColor+=0.08;\n    pixelColor-= Random(UV, 0.08);\n\n\n    // Commented original video\n    // fragColor =  texture (iChannel0, fragCoord/iResolution.xy).rgba; \n    fragColor=vec4(pixelColor, 1.0);\n}","name":"Image","description":"","type":"image"}]}