{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"#define PLANE 1000.0\n#define PI 3.141593\n#define LOOPS 128.0\n#define LIGHTLOOPS 128.0\n#define L1 1\n#define L2 2\n#define SPEED 5.0\n\nstruct light \n{\n    vec3 pos;\n    vec3 color;\n    float intensity;\n    float dist;\n};\n    \nstruct ball\n{\n    vec3 pos;\n    vec3 color;\n    float r;\n};\n    \nstruct hitInfo\n{\n    vec4 info;\n    int type;\n};\n    \nlight light1 = light(vec3(0,0,-20.0), vec3(1,1,1), 200.0, 1.0);\nlight light2 = light(vec3(0,-20,40.0), vec3(1,1,1), 1.0, 5.0);\nball ball1 = ball(vec3(0,10,0), vec3(1,0,0), 10.0);\n    \nvec4 Rball(vec3 point, vec3 pos, float r, vec3 color) {\n    return vec4(1,1,0,distance(point, pos)-r);\n}\n\nvec4 Rplane(vec3 point) {\n    return vec4(0,sin(point.z)+sin(point.x),0, point.y+6.0);\n}\n\nfloat map(in vec3 p) {\n    float d = Rplane(p).w;\n    d = min(d, Rball(p,p - vec3(0.0, 0.25, 0.0), 0.25, vec3(1,0,0)).w);\n    return d;\n}\n\nvec3 calcNormal(vec3 p) {\n\tvec3 e = vec3(0.001, 0.0, 0.0);\n    vec3 nor = vec3(\n        map(p + e.xyy) - map(p - e.xyy),\n        map(p + e.yxy) - map(p - e.yxy),\n        map(p + e.yyx) - map(p - e.yyx)\n    );\n    return normalize(nor);\n}\n\nhitInfo DE(vec3 point) { //distance estimation\n    //return vec4(1,0,0,distance(point, vec3(0,0,3))-20.0);\n    vec4 ball1d = Rball(point, ball1.pos, ball1.r, ball1.color);\n    vec4 plane1d = Rplane(point);\n    if(plane1d.w<ball1d.w){return hitInfo(plane1d, 1);}\n    return hitInfo(ball1d, 2);\n}\n\n\nvec3 getNormal(vec3 point, int type) { //calculating normal every step is expensive, so...\n    if(type == 1) {return vec3(0,1,0);}\n    if(type == 2) {return normalize(point - ball1.pos);}\n    return vec3(0,0,0);\n}\n\nlight closestLight(vec3 point) {\n    return light1;\n    if(distance(point, light1.pos)<distance(point, light2.pos)){return light1;}\n    return light2;\n}\n\nfloat traceToLight(vec3 pos, vec3 normal, light l) {\n    vec3 point = pos;\n    float dis = 0.1;\n    for(float i = 0.0; i<LIGHTLOOPS; ++i) {\n        point += normalize(l.pos-point)*dis;\n        hitInfo castInfo = DE(point);\n        dis = castInfo.info.w;\n        if(dis<0.0001){return 0.0;}\n    }\n    float light = (dot(normal,normalize(l.pos-pos)));\n    return clamp(light/(pow(distance(l.pos, pos), 2.0))*light1.intensity, 0.,1.);\n}\n\nvec3 createCast(vec3 origo, vec3 tgt, vec3 up, vec2 plane, float fov) {\n    vec3 az = normalize(tgt - origo);\n    vec3 ax = normalize(cross(az, up));\n    vec3 ay = cross(ax, az);\n    \n    vec3 point = tgt + fov * length(tgt-origo) * (plane.x * ax + plane.y * ay);\n    return normalize(point-origo);\n}\n\nvec4 casty(vec3 start, vec3 dir) {\n    vec3 point = start;\n    dir = normalize(dir);\n    for(float i = 0.0; i<LOOPS; ++i) {\n        hitInfo castInfo = DE(point);\n        float dis = castInfo.info.w;\n        if(dis<0.1) {\n            float light = traceToLight(point, getNormal(point, castInfo.type), closestLight(point));\n            return vec4(castInfo.info.xyz*light+castInfo.info.xyz*0.0,1);\n        }\n        point += dir*dis;\n    }\n    return vec4(0,0,0,0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 campos = vec3(sin(iTime)*50.,sin(iTime)*10.+10.,-50.*cos(iTime));\n    light1.pos = vec3(-5.,40., -10.);\n    light2.pos = vec3(20.*cos(iTime*SPEED-3.0), 30, 20);\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec4 color = casty(campos, createCast(campos, vec3(0,0,0), vec3(0,1,0), (fragCoord.xy - 0.5 * iResolution.xy) / iResolution.y, 1.0));\n\tfragColor = color+vec4(0.,0.0,0.0,0.0);\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"4dsXWj","date":"1406937823","viewed":189,"name":"alertBall","username":"Kilves","description":"Wow, It got rly nice.","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","ball"],"hasliked":0,"parentid":"","parentname":""}}