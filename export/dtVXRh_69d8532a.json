{"ver":"0.1","info":{"id":"dtVXRh","date":"1685979333","viewed":217,"name":"Lesovoi-Kulikov algorithm","username":"aleklesovoi","description":"Lateral chromatic aberration based on the article https://alekseilesovoi.blogspot.com/2023/07/physically-based-chromatic-aberration.html","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["chromaticaberration"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdfGRr","filepath":"/media/a/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm","previewfilepath":"/media/ap/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm","type":"video","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define CHROMATIC_ABERRATION 1\n\n// This Chromatic Aberration is based on my article https://alekseilesovoi.blogspot.com/2023/07/physically-based-chromatic-aberration.html\n#define SAMPLE_COUNT 25\n#define FALLOFF 5.0\n#define BLUR 2.0\n#define STEP_MULTIPLIER 2.0\n\nfloat saturate(float x)\n{\n    return max(0.0, min(1.0, x));\n}\n\nfloat GetRedWeight(float x)\n{\n    return saturate(-22.0314700 + \n    0.0693593543 * x -\n    0.0000511503626 * x * x);\n}\n\nfloat GetGreenWeight(float x)\n{\n    return saturate(-26.1677272 + \n    0.101045545 * x -\n    0.0000936790526 * x * x);\n}\n\nfloat GetBlueWeight(float x)\n{\n    return saturate(-36.8549961 + \n    0.170626277 * x -\n    0.000191770102 * x * x);\n}\n\nvec3 ChromaticAberration(vec2 uv)\n{\n    float distanceStrength = pow(length(uv - 0.5), FALLOFF);\n    vec2 direction = normalize(uv - 0.5);\n    vec2 velocity = direction * BLUR * distanceStrength;\n    \n    vec2 totalOffset = velocity * STEP_MULTIPLIER;\n    vec2 offsetDecrement = totalOffset / float(SAMPLE_COUNT);\n\n    // Optimization: don't process pixels which won't include any other pixel's information\n    // aka if we will sample only the pixel itself, it will still have the same color without aberration artifact\n    bool isNotAberrated = abs(totalOffset.x * iResolution.x) < 1.0 && abs(totalOffset.y * iResolution.y) < 1.0;\n    if (isNotAberrated || SAMPLE_COUNT < 2)\n    {\n        return texture(iChannel0, uv ).rgb;\n    }\n\n    vec3 accumulator = vec3(0);\n    vec2 offset = vec2(0);\n    vec3 WeightSum = vec3(0);\n    vec3 Weight = vec3(0);\n    vec3 color;\n    float waveLength;\n\n    for (int i = 0; i < SAMPLE_COUNT; i++)\n    {\n        waveLength = mix(780.0, 380.0, float(i) / (float(SAMPLE_COUNT) - 1.0));\n        Weight.r = GetRedWeight(waveLength);\n        Weight.g = GetGreenWeight(waveLength);\n        Weight.b = GetBlueWeight(waveLength);\n        \n        offset -= offsetDecrement;\n\n        color = texture(iChannel0, uv + offset).rgb;\n        accumulator.rgb += color.rgb * Weight.rgb; \n\n        WeightSum.rgb += Weight.rgb;\n    }\n\n    return accumulator.rgb / WeightSum.rgb;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n#if CHROMATIC_ABERRATION\n    vec3 col = ChromaticAberration(uv);\n#else\n    vec3 col = texture(iChannel0, uv).rgb;\n#endif\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}