{"ver":"0.1","info":{"id":"7sfcW4","date":"1642087311","viewed":328,"name":"Harris Corner Detector","username":"mintyLemon","description":"Computes simple thresholded harris corners of iChannel0 and draws circles around them.\n\nBuffer A - cornerness\nBuffer B - non-maximum suppression\nImage   - video and circles","likes":17,"published":1,"flags":32,"usePreview":0,"tags":["camera","harris","detector","feature"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sX3Rn","filepath":"/media/a/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv","previewfilepath":"/media/ap/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv","type":"video","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float circleRes = .2;\n\nbool is_corner(vec2 p) {\n    vec2 uv = p / iResolution.xy;\n    return texture(iChannel2, uv).w > 0.;\n}\n\nfloat circle(vec2 p, float radius) {\n\n    for (float a = 0.; a < 6.283; a += circleRes) {\n        vec2 center_loc = p + radius * vec2(cos(a), sin(a));\n        if (is_corner(center_loc)) {\n            return 1.;\n        }\n    }\n    \n    return 0.; \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec4 camera = vec4(texture(iChannel1, uv).xyz, 1.);\n    vec4 circleColor = vec4(1., 0., 0., 0.);\n    float is_circle = circle(fragCoord, 10.);\n    \n    fragColor = mix(camera, circleColor, is_circle);\n    //fragColor = vec4(texture(iChannel1, uv).w, 0., 0., 1.);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4sX3Rn","filepath":"/media/a/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv","previewfilepath":"/media/ap/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv","type":"video","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"mat2 ZEROS_M2 = mat2(0, 0, 0, 0);\n                     \nfloat threshold = 40.;\nint patch_size = 3;\n\nfloat lookup(vec2 p, float dx, float dy)\n{\n    vec2 uv = (p.xy + vec2(dx, dy)) / iResolution.xy;\n    vec4 c = texture(iChannel0, uv.xy);\n    return length(c.xyz);\n}\n\nfloat sobelX(vec2 p) {\n    float gx = 0.0;\n    gx += -1.0 * lookup(p, -1.0, -1.0);\n    gx += -2.0 * lookup(p, -1.0,  0.0);\n    gx += -1.0 * lookup(p, -1.0,  1.0);\n    gx +=  1.0 * lookup(p,  1.0, -1.0);\n    gx +=  2.0 * lookup(p,  1.0,  0.0);\n    gx +=  1.0 * lookup(p,  1.0,  1.0);\n    \n    return gx;\n}\n\nfloat sobelY(vec2 p) {\n    float gy = 0.0;\n    gy += -1.0 * lookup(p, -1.0, -1.0);\n    gy += -2.0 * lookup(p,  0.0, -1.0);\n    gy += -1.0 * lookup(p,  1.0, -1.0);\n    gy +=  1.0 * lookup(p, -1.0,  1.0);\n    gy +=  2.0 * lookup(p,  0.0,  1.0);\n    gy +=  1.0 * lookup(p,  1.0,  1.0);\n    \n    return gy;\n}\n\n\n\nmat2 momentMat(vec2 xy, int size)\n{\n    mat2 M = ZEROS_M2;\n    \n    for (int u = -size; u <= size; u++)\n    {\n        for (int v = -size; v <= size; v++)\n        {\n            float Ix = sobelX(xy + vec2(u,v));\n            float Iy = sobelY(xy + vec2(u,v));\n            \n            M[0][0] += Ix * Ix;\n            M[0][1] += Ix * Iy;\n            M[1][1] += Iy * Iy;\n        }\n    }\n    \n    M[1][0] = M[0][1];\n    \n    return M;\n}\n\nfloat cornerness(vec2 uv, int size, float lambda)\n{\n    mat2 M = momentMat(uv, size);\n    \n    float det = (M[0][0] * M[1][1]) - (M[1][0] * M[0][1]);\n    float trace = (M[0][0] + M[1][1]);\n    \n    float r = det - lambda * trace * trace;\n        \n    if (r > threshold) {\n        return r;\n    } else {\n        return 0.;\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    float r = cornerness(fragCoord, patch_size, .1);\n    // Time varying pixel color\n    vec4 camera = texture(iChannel0, uv);\n    \n    fragColor = vec4(camera.xyz, r);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4sX3Rn","filepath":"/media/a/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv","previewfilepath":"/media/ap/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv","type":"video","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"vec2 uv(vec2 p) {\n    return p / iResolution.xy;\n}\n\nfloat localMaximum(vec2 p, int patch_size) {\n    float pixel_value = texture(iChannel1, uv(p)).w;\n    \n    for(int x = -patch_size; x <= patch_size; x++) {\n        for(int y = -patch_size; y <= patch_size; y++) {\n            vec2 p_coord = p + vec2(x, y);\n            if (texture(iChannel1, uv(p_coord)).w > pixel_value) {\n                return 0.;\n            }\n        }\n    }\n    \n    return pixel_value;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    fragColor = vec4(0.0,0.0,0.,localMaximum(fragCoord, 10));\n}","name":"Buffer B","description":"","type":"buffer"}]}