{"ver":"0.1","info":{"id":"7dy3Ry","date":"1631730008","viewed":100,"name":"Hue Shift + Noise","username":"deerfeeder","description":"github goodies","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["functions"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// https://gist.github.com/mairod/a75e7b44f68110e1576d77419d608786\nvec3 hueShift( vec3 color, float hueAdjust ){\n\n    const vec3  kRGBToYPrime = vec3 (0.299, 0.587, 0.114);\n    const vec3  kRGBToI      = vec3 (0.596, -0.275, -0.321);\n    const vec3  kRGBToQ      = vec3 (0.212, -0.523, 0.311);\n\n    const vec3  kYIQToR     = vec3 (1.0, 0.956, 0.621);\n    const vec3  kYIQToG     = vec3 (1.0, -0.272, -0.647);\n    const vec3  kYIQToB     = vec3 (1.0, -1.107, 1.704);\n\n    float   YPrime  = dot (color, kRGBToYPrime);\n    float   I       = dot (color, kRGBToI);\n    float   Q       = dot (color, kRGBToQ);\n    float   hue     = atan (Q, I);\n    float   chroma  = sqrt (I * I + Q * Q);\n\n    hue += hueAdjust;\n\n    Q = chroma * sin (hue);\n    I = chroma * cos (hue);\n\n    vec3    yIQ   = vec3 (YPrime, I, Q);\n\n    return vec3( dot (yIQ, kYIQToR), dot (yIQ, kYIQToG), dot (yIQ, kYIQToB) );\n\n}\nfloat n( vec2 P )\n{\n    //  https://github.com/BrianSharpe/Wombat/blob/master/Perlin2D.glsl\n\n    // establish our grid cell and unit position\n    vec2 Pi = floor(P);\n    vec4 Pf_Pfmin1 = P.xyxy - vec4( Pi, Pi + 1.0 );\n\n    // calculate the hash\n    vec4 Pt = vec4( Pi.xy, Pi.xy + 1.0 );\n    Pt = Pt - floor(Pt * ( 1.0 / 71.0 )) * 71.0;\n    Pt += vec2( 26.0, 161.0 ).xyxy;\n    Pt *= Pt;\n    Pt = Pt.xzxz * Pt.yyww;\n    vec4 hash_x = fract( Pt * ( 1.0 / 951.135664 ) );\n    vec4 hash_y = fract( Pt * ( 1.0 / 642.949883 ) );\n\n    // calculate the gradient results\n    vec4 grad_x = hash_x - 0.49999;\n    vec4 grad_y = hash_y - 0.49999;\n    vec4 grad_results = inversesqrt( grad_x * grad_x + grad_y * grad_y ) * ( grad_x * Pf_Pfmin1.xzxz + grad_y * Pf_Pfmin1.yyww );\n\n    // Classic Perlin Interpolation\n    grad_results *= 1.4142135623730950488016887242097;  // scale things to a strict -1.0->1.0 range  *= 1.0/sqrt(0.5)\n    vec2 blend = Pf_Pfmin1.xy * Pf_Pfmin1.xy * Pf_Pfmin1.xy * (Pf_Pfmin1.xy * (Pf_Pfmin1.xy * 6.0 - 15.0) + 10.0);\n    vec4 blend2 = vec4( blend, vec2( 1.0 - blend ) );\n    return dot( grad_results, blend2.zxzx * blend2.wwyy );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n   \n    // Time varying pixel color\n    float  swave = sin(iTime*0.1);\n    float  cwave = cos(iTime*0.02);\n    float  r = n(uv.xx*(iTime*0.01)*swave*cwave*100.0)*n(uv*10.0);\n    r += n(vec2(tanh(uv.x)))*0.5;\n    r = smoothstep(r, 0.03,0.42);\n\n    // Output to screen\n    fragColor = vec4(hueShift(vec3(1.0-r*0.1,0.5+(1.0+r)*0.2,0.8),sin(iTime*0.1)*3.14),1.0);\n}","name":"Image","description":"","type":"image"}]}