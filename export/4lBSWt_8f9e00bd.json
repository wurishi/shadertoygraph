{"ver":"0.1","info":{"id":"4lBSWt","date":"1447360296","viewed":151,"name":"quadrangle structure","username":"Equations","description":"It's a simple thing to draw in reallife, so I thought I'd be able to get it done here too.\nEnjoy!\nAlso modify the speed to your liking","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["quadranglerotation"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[],"code":"#define PI 3.14159265359\n#define maxDist 1000000.0\n\n//global variables and constants\n#define lineWidth 0.003\n#define amount 48.0\nfloat delta  = 2.0 * PI / amount;\nfloat rotationSpeed(){\n    return 2.0 * iTime;\n}\nvec2 centre1 = vec2(-0.4, 0.1),\n\tcentre2 = vec2(0.4, -0.1);\n\n//basic functions\nfloat toAngle(vec2 ray){\n\treturn atan(ray.y, ray.x);\n}\nvec2 toCartesian(float angle){\n\treturn vec2(cos(angle), sin(angle));\n}\nfloat getWidth(vec2 rayDir, vec2 rightRay){\n    //normalizes the ray, if you were wondering, and compares it to rightRay\n    return length(rayDir - rightRay * dot(rayDir, rightRay) / dot(rightRay, rightRay));\n}\nfloat modify(float arg){\n    //fixing and making some quadrangles white\n    if(arg > amount / 2.0) arg = amount - arg;\n    \n    return mod(arg, 2.0) == 0.0 ? 0.0 : arg + 1.0;\n}\n\nvec2 castRayToEdge(vec2 rayOrg, vec2 rayDir){\n    //casting ray to edge of screen\n    float dist_topBot, dist_leftRight;\n    //topBot\n    if(rayDir.y != 0.0) \n        dist_topBot = (sign(rayDir.y) - rayOrg.y) / rayDir.y;\n    else dist_topBot = maxDist;\n    //rightLeft    \n    if(rayDir.x != 0.0)\n        dist_leftRight = (sign(rayDir.x) * iResolution.x / iResolution.y - rayOrg.x) / rayDir.x;\n    else dist_leftRight = maxDist;\n    \n    return rayOrg + min(dist_topBot, dist_leftRight) * rayDir;\n}\n\nfloat floorToGlobal(float alpha){\n\treturn floor((rotationSpeed() - alpha) / delta);\n}\n\nfloat alphaToNextRay(float alpha){\n    return mod(rotationSpeed() - alpha, delta);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = -1.0  + 2.0 * fragCoord.xy / iResolution.xy;\n    uv.x *= iResolution.x / iResolution.y; float color = 1.0;\n    \n    //vars for calculation:\n    float angle1 = toAngle(castRayToEdge(centre1, uv - centre1)), \n        angle2 = toAngle(castRayToEdge(centre2, uv - centre2));\n    \n    //coloring the lines\n    if(getWidth(uv - centre1, castRayToEdge(vec2(0.0), toCartesian(angle1 + alphaToNextRay(angle1))) - centre1) < lineWidth) color = 0.0;\n    if(getWidth(uv - centre2, castRayToEdge(vec2(0.0), toCartesian(angle2 + alphaToNextRay(angle2))) - centre2) < lineWidth) color = 0.0;\n    \n    //coloring the squares\n    color -= 1.5 * modify(abs(floorToGlobal(angle1) - floorToGlobal(angle2))) / amount;\n    fragColor = vec4(color);\n}","name":"Image","description":"","type":"image"}]}