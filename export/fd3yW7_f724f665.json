{"ver":"0.1","info":{"id":"fd3yW7","date":"1653697207","viewed":179,"name":"Warning Forked from Re Cypher","username":"snolot","description":"Audio reactive version of https://www.shadertoy.com/view/MlsGRS by  @dila,  rewired for clubber. \n","likes":9,"published":1,"flags":0,"usePreview":0,"tags":["block","world","ass","clubber"],"hasliked":0,"parentid":"MlGSzW","parentname":"Re Cypher"},"renderpass":[{"inputs":[{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// The following block is needed for Clubber integration\n#ifndef CLUBBER\nvec4 iMusic[4];\nconst float iTransition = 1.0;\n#define CLUBBER_R len * 0.3\n#define CLUBBER_G len * 0.3\n#define CLUBBER_B len * 0.3\n#define CLUBBER_A 0.0\n#endif\n// Clubber end\n\n#define PI 3.14159\n\n\nstruct RayHit {\n    float dist;\n    int objectId;\n};\n\n// ****************************************************\n// *********************  Utils  **********************\n// ****************************************************\n\nmat2 rotMat(float angle) {\n    float s = sin(angle);\n    float c = cos(angle);\n\n    return mat2(c, -s, s, c);\n}\n\nRayHit Union(RayHit hit1, RayHit hit2) {\n    if (hit1.dist < hit2.dist) {\n        return hit1;\n    } else {\n        return hit2;\n    }\n}\n\nRayHit Substruction(RayHit hit1, RayHit hit2) {\n    if (-hit1.dist > hit2.dist) {\n        return RayHit(-hit1.dist, hit1.objectId);\n    } else {\n        return hit2;\n    }\n}\n\nRayHit Intersection(RayHit hit1, RayHit hit2) {\n    if (hit1.dist > hit2.dist) {\n        return hit1;\n    } else {\n        return hit2;\n    }\n}\n\nmat3 xrot(float t)\n{\n    return mat3(1.0, 0.0, 0.0,\n                0.0, cos(t), -sin(t),\n                0.0, sin(t), cos(t));\n}\n\nmat3 yrot(float t)\n{\n    return mat3(cos(t), 0.0, -sin(t),\n                0.0, 1.0, 0.0,\n                sin(t), 0.0, cos(t));\n}\n\nmat3 zrot(float t)\n{\n    return mat3(cos(t), -sin(t), 0.0,\n                sin(t), cos(t), 0.0,\n                0.0, 0.0, 1.0);\n}\n\nfloat sdBoxFrame( vec3 p, vec3 b, float e )\n{\n       p = abs(p  )-b;\n  vec3 q = abs(p+e)-e;\n  return min(min(\n      length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n      length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n      length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) +\n         length(max(d,0.0));\n}\n\nvec3 mp;\n\nRayHit map(vec3 pos)\n{\n    float speed = 1.0;\n    vec3 grid = floor(pos);\n    vec3 gmod = mod(grid, 3.);\n    vec3 rmod = mod(grid, 4.0) - 2.0;\n    float j = iTime * speed + (CLUBBER_A);\n    float tm = fract(j);\n    rmod *= (cos(tm*PI)-1.0);\n    \n    float g = floor(mod(j,2.0));\n    if (g==0.0){\n        if (gmod.y*gmod.x==1.0) {\n            pos.z += rmod.x*rmod.y*0.5;\n        }\n    } else if (g==1.0){\n        if (gmod.y*gmod.z==1.0) {\n            pos.x += rmod.y;\n        }\n    } else if (g==2.0){\n        if (gmod.z==0.0) {\n            pos.y += rmod.z*rmod.x*0.5;\n        }\n    }\n        \n    grid = floor(pos);\n    pos = pos - grid;\n    pos = pos * 2.0 - 1.0;\n    \n    mp = pos;\n    \n    float len = 0.9;\n    \n\tvec3 sc = mix(vec3(0.5), vec3(0.96), vec3(CLUBBER_R,CLUBBER_G,CLUBBER_B));\n    RayHit d1 = RayHit( sdBoxFrame(pos, sc, .04), 1);\n    \n    vec3 pp = pos;\n    pp *= yrot(iTime * 5.);\n    \n       \n    RayHit d2 = RayHit(sdBox(pp ,vec3(sc*.5)),2);\n    RayHit d3;\n    \n    //d2 = vec2(max(d1.x, d2.x),2.);\n    RayHit d = Union(d1, d2);\n   \n    bool skip = false;\n    \n \n    if (mod(grid.x,2.0)==0.0 && mod(grid.y,2.0)==0.0) {\n        skip = true;\n    }\n\n    if (mod(grid.x,2.0)==0.0 && mod(grid.z,2.0)==0.0) {\n        skip = true;\n    }\n\n    if (mod(grid.y,2.0)==0.0 && mod(grid.z,2.0)==1.0) {\n        skip = true;\n    }\n\t\n    if (skip) {\n        d.dist = 100.0;\n        vec3 off = vec3(2.0,0.0,0.0);\n        for (int i = 0; i < 3; ++i) {\n            RayHit a = RayHit(sdBoxFrame(pos + off,vec3(sc),.04), 3);\n            RayHit b = RayHit(sdBoxFrame(pos - off,vec3(sc),.04), 3);\n            \n            d = Substruction(d3,Union(a,b));\n            \n            off = off.zxy;\n        }\n        d.dist *= 0.5 *(sc.x+sc.y +sc.z) * 0.33 ;\n    } else {\n        d.dist *= 0.8 * (sc.x+sc.y +sc.z) * 0.33;  \n    }\n    \n   return d;//Substruction(d, RayHit(sdBox(pos ,vec3(5.)),3));\n}\n\nvec3 surfaceNormal(vec3 pos) {\n \tvec3 delta = vec3(0.01, 0.0, 0.0);\n    vec3 normal;\n    normal.x = map(pos + delta.xyz).dist - map(pos - delta.xyz).dist;\n    normal.y = map(pos + delta.yxz).dist - map(pos - delta.yxz).dist;\n    normal.z = map(pos + delta.zyx).dist - map(pos - delta.zyx).dist;\n    return normalize(normal);\n}\n\nfloat aoc(vec3 origin, vec3 ray)\n{\n    float delta = 0.05;\n    const int samples = 8;\n    float r = 0.0;\n    for (int i = 1; i <= samples; ++i) {\n        float t = delta * float(i);\n     \tvec3 pos = origin + ray * t;\n        RayHit rtn = map(pos);\n        float dist = rtn.dist;\n        float len = abs(t - dist);\n        r += len * pow(2.0, -float(i));\n    }\n    return r;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n\tvec3 eye = normalize(vec3(uv, 1.0 - dot(uv,uv) * 0.33));\n    vec3 origin = vec3(0.0);\n    \n    eye = eye * yrot(iTime) * xrot(iTime);\n    \n    float speed = 0.5;\n    \n    float j = iTime * speed + CLUBBER_A;\n    \n    float f = fract(j);\n    float g = 1.0 - f;\n    f = f*f * g + (1.0-g*g) * f;\n    f = f * 2.0 - 1.0;\n\tfloat a = floor(j) + f * floor(mod(j,2.0));\n    float b = floor(j) + f * floor(mod(j+1.0,2.0));\n    \n    origin.x += 0.5 + a;\n    origin.y += 0.5;\n    origin.z += 0.5 + b;\n    \n    float t = 0.0;\n    float d = 0.0;\n    RayHit rtn;\n    \n    for (int i = 0; i < 32; ++i){\n        vec3 pos = origin + eye * t;\n        rtn = map(pos);\n        d = rtn.dist;\n        t += d;\n    }\n    \n    vec3 cc = vec3(1., .23, .249)*step(.5,fract((mp.x + mp.y + mp.z)*5.));\n    \n    if(rtn.objectId > 1){\n        cc = vec3(1., .681, .049)*step(.5,fract((mp.x + mp.y + mp.z)*5.));;\n    \n    }\n     if(rtn.objectId > 2){\n         cc = vec3(0., .681, .49)*step(.5,fract((mp.x + mp.y + mp.z)*5.));;\n     }\n    \n    vec3 worldPos = origin + eye * t;\n    \n    vec3 norm = surfaceNormal(worldPos);\n    \n    float prod = max(0.0, dot(norm, -eye));\n    \n    float amb = aoc(worldPos, -eye);\n    \n    vec3 ref = reflect(eye, norm);\n    \n    vec3 spec = vec3(0.0);//texture(iChannel0, ref).xyz;\n    \n    prod = pow(1.0 - prod, 2.0);\n    \n    vec3 col = vec3(1.);\n    \n        \n    spec *= col;\n    \n    col = mix(col, spec, prod);\n    \n    float shade = pow(max(1.0 - amb, 0.0), 4.0);\n    \n    float fog = 1.0 / (1.0 + t * t * 0.2) * shade;\n    \n    vec3 final = col;\n    \n    final = mix(final, vec3(1.0), fog);\n    \n    fog = 1.0 / (1.0 + t * t * 0.1);\n    \n\tfragColor = vec4(final*cc*fog,0.0);\n}","name":"Image","description":"","type":"image"}]}