{"ver":"0.1","info":{"id":"sdVyRz","date":"1654359661","viewed":50,"name":"Final Project - FINAL SUBMIT","username":"brando23","description":"crying 2.0","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["procedural","3d","raymarching","sdf","animation"],"hasliked":0,"parentid":"ssVcRR","parentname":"b + e = c9"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//==================================== constants =========================================\n#define TERRAIN 1\n#define FIRE    2\n#define WATER   3\n#define SKY     4\n#define EYE     4\n#define EPSILON 1e-4\n#define DUCK_YELLOW 5\n#define DUCK_ORANGE 6\n#define DUCK_SCALE .5\n#define DUCK_ROTATION -10.\n\n//MODEL CONSTANTS FOR SIZE & POSITION\n#define SCALE_F  .15\n#define modelY   8.7\n#define modelX   .1\n#define modelZ   8.0\n\n\n//COLORS\n#define BLACK  vec3(0.0)\n#define RED    vec3(1.0, 0.0, 0.0)\n#define ORANGE vec3(1.0,.6,0.)\n#define BLUE   vec3(0.,0.,1.0)\n#define WHITE  vec3(1.0,1.0,1.0)\n\n//-----------------------------------------------------------------------------------------\n//-------------------------------- get ray when given camera and uv coordinates PA5   ------\n//-----------------------------------------------------------------------------------------\nray getray(camera cam, vec2 uv){\n    return ray(cam.origin,normalize( uv.x * cam.u + uv.y * cam.v + 1.5 * cam.w ));\n}\n\n\n//-----------------------------------------------------------------------------------------\n//---------     return pos of ray after an increment by some value in r.direction     ------\n//-----------------------------------------------------------------------------------------\nvec3 rayAt(ray r, float t){\n    return r.ori + t * r.dir;\n}\n\n//-----------------------------------------------------------------------------------------\n//---------     returns the float of the entire model of our creature    ---------------------\n//                  Brandon's\n//-----------------------------------------------------------------------------------------\nfloat model(in vec3 pos, float y, float x, float z ){\n\n\n    //code for the head \n    vec3 h = pos - vec3(x ,y ,z + .2) * SCALE_F;\n    float head = sdSphere(h, .45 * SCALE_F);\n\n    \n    \n    //main body of the creature\n    float torsoY = .8;\n    float t1 = sdSphere(pos - vec3(x,y - .1, z - .2) * SCALE_F, 0.03* SCALE_F);\n    float t2 = sdSphere(pos - vec3(x-.1,y - .1,z - 1.0) * SCALE_F, 0.03* SCALE_F);\n    float t3 = sdSphere(pos - vec3(x-.2,y- .1,z - 2.0) * SCALE_F, 0.03* SCALE_F);\n    \n    \n    //move down for legs, \n    y -= 1.1;\n    \n    //each of the lgs\n    float l1 = sdSphere(pos - vec3(x-.8,y, z- 1.9) * SCALE_F, 0.1* SCALE_F);\n    float l2 = sdSphere(pos - vec3(x+.6,y, z-1.9) * SCALE_F, 0.15* SCALE_F);\n    float l3 = sdSphere(pos - vec3(x-.8,y, z-.2)* SCALE_F, 0.16* SCALE_F);\n    float l4 = sdSphere(pos - vec3(x+.6,y, z-.2) * SCALE_F, 0.13* SCALE_F);\n    \n    //union of torso\n    float torso = opSmoothUnion(t1, t2, 2.5* SCALE_F);\n    torso = opSmoothUnion(torso, t3, 2.5 * SCALE_F) ;\n    torso = opSmoothUnion(head,torso,.2* SCALE_F);\n    \n    \n    //tail y location \n    y += 1.2;\n    \n    //individual tail sections, combinations of spheres\n    float tail = sdSphere(pos - vec3(x,y,z -2.2)* SCALE_F, .05* SCALE_F);\n    float tail2 = sdSphere(pos - vec3(x,y + .2, z -2.5)* SCALE_F, .03* SCALE_F);\n    float tail3 = sdSphere(pos - vec3(x,y + .4,z -2.8)* SCALE_F, .03* SCALE_F);\n    float tail4 = sdSphere(pos - vec3(x,y + .6,z -3.) *SCALE_F, .01* SCALE_F) ;\n    \n    //union of tail parts\n    tail = opSmoothUnion(tail,tail2,.6 * SCALE_F);\n    tail = opSmoothUnion(tail,tail3,.5 * SCALE_F);\n    tail = opSmoothUnion(tail,tail4,.2 * SCALE_F) ;\n    \n\n//   unify the body \n    tail = opRound(tail,0.1* SCALE_F);\n    torso = opSmoothUnion(tail,torso,.15* SCALE_F);\n    \n    float d = opSmoothUnion(torso, l1, 1. * SCALE_F);\n    d = opSmoothUnion(d, l2, 1.* SCALE_F);\n    d = opSmoothUnion(d, l3, 1.* SCALE_F);\n    d = opSmoothUnion(d, l4, 1.* SCALE_F);\n    \n//------------------------------------\n    \n    //modify the y of the sphere of tail end to go upwards\n    vec3 current = pos - vec3(x,y + .7,z -3.1)* SCALE_F;\n    if (current.y > .1* SCALE_F){\n        current.y *= .5* SCALE_F * cos(iTime * 4.);\n        current.y = clamp(current.y, .065* SCALE_F,1.* SCALE_F);\n    }\n    \n    //--------------------------------\n    //         the creature - adding the tail\n    //--------------------------------\n    float tailEnd = sdSphere(current , .05* SCALE_F);\n    d = opSmoothUnion(d, tailEnd, .99* SCALE_F);\n\n    return d;\n}\n\n//-----------------------------------------------------------------------------------------\n//---------     a duck for the ponds hehe - just the body                            ------\n//-----------------------------------------------------------------------------------------\nfloat duck_body(in vec3 pos){\n\n    \n    //============================ actually constructing the duck bod here ============\n    float duck;\n    \n    //-------------- head and neck -------------\n    float head = sdSphere(pos, .50 * DUCK_SCALE);\n    float neck = sdSphere(pos + vec3(0.4, 0.7, 0.0) * DUCK_SCALE, 0.65* DUCK_SCALE);\n\n    duck = opSmoothUnion(head, neck, .15 * DUCK_SCALE);\n    \n    //--------------      butt          ---------\n    float butt = sdSphere(pos + vec3(0.9, 0.6, 0.0)* DUCK_SCALE, 0.45* DUCK_SCALE);\n    duck = opSmoothUnion(duck, butt, .55* DUCK_SCALE);\n    \n    \n    //-------------- tail           -------------\n    float tail = sdSphere(pos + vec3(1.2, 0.3, 0.0)* DUCK_SCALE, 0.15* DUCK_SCALE);\n    duck = opSmoothUnion(duck, tail, .55* DUCK_SCALE);\n    \n    \n    //-------------- animated wings  -------------\n    float y_pos = pos.y + 0.5 * DUCK_SCALE + 0.2*(sin(iTime*3.0) * DUCK_SCALE);\n    \n    float l_wing = sdSphere(pos + vec3(0.3, y_pos, 1.0)* DUCK_SCALE, 0.25* DUCK_SCALE);\n    duck = opSmoothUnion(duck, l_wing, .55* DUCK_SCALE);\n    \n    float r_wing = sdSphere(pos + vec3(0.3, y_pos, -1.0)* DUCK_SCALE, 0.25* DUCK_SCALE);\n    duck = opSmoothUnion(duck, r_wing, .55 * DUCK_SCALE);\n    \n    \n    //-------------- finally the duck :) -------------\n    return duck;\n}\n\n//-----------------------------------------------------------------------------------------\n//---------     just the duck beak.                                   ---------------------\n//-----------------------------------------------------------------------------------------\n\nfloat duck_beak(in vec3 pos) {\n    \n\n    //------- constructing the beak --------------------\n    float beak;\n    float top_beak = sdSphere(pos + vec3(-.5, -1.2, 0.0) * DUCK_SCALE, 0.05 * DUCK_SCALE);\n    float lower_beak = sdSphere(pos + vec3(-.6, -1.2, 0.0)* DUCK_SCALE, 0.05) * DUCK_SCALE;\n    beak = opSmoothUnion(top_beak, lower_beak, 0.2* DUCK_SCALE);\n\n    \n    return beak;\n\n}\n\n\n\n//-----------------------------------------------------------------------------------------\n//---------     fractal brownian motion                                --------------------\n//-----------------------------------------------------------------------------------------\n// https://www.shadertoy.com/view/4slGD4\n// - dave hoskins\n\n// basic noise function used from link above\n\nfloat noise(in vec2 XY)\n{\n    return sin(XY.x)+cos(XY.y);\n}\n\n\n// taken From Dave_Hoskins https://www.shadertoy.com/user/Dave_Hoskins \n//but modified by Emilie \nfloat fbm(in vec2 uv)\n{\n    //this function generates the terrain height\n    uv /= 3.5;\n    float value = 0.1;\n    float amplitude = 1.;\n    float freq = 1.;\n    \n    // for each amplitude\n    for (int i = 0; i < 8; i++)\n    {\n        value = max(value,value+(.25-abs(noise(uv * freq)-.8) * amplitude));\n        amplitude *= .37;\n        freq *= 2.05;\n        \n        uv = uv.yx;\n    }\n    \n    return value*2.0-2.0;\n}\n\n\n// Like earlier fmb but modified heavily by Emilie to simulate water\nfloat fbmWater(in vec2 uv)\n{\n    //this function generates the terrain height\n    uv /= .1;\n    float value = .01;\n    float amplitude = .01;\n    float freq = 1.;\n   \n    for (int i = 0; i < 8; i++){\n        \n        value = max(value,value+(.25-abs(noise(uv * freq)+0.99) * amplitude));\n       \n        amplitude *= .17 + (0.1 * (sin(iTime*1.3)));\n       \n        freq *= 5.05;\n       \n        uv = uv.yx;\n    }\n   \n    return value*2.0-2.0;\n}\n\n//-----------------------------------------------------------------------------------------\n//---------     Emilie's terrain func                       --------------------\n//-----------------------------------------------------------------------------------------\n\nfloat my_terrain(in vec3 pos) {\n\n    float flr = pos.y - (fbm(vec2(pos.x + 18.6, pos.z)));\n    \n    if (flr < -0.05){\n    \n        pos.xz += iTime;\n    }\n    return flr;\n}\n\n//-----------------------------------------------------------------------------------------\n//---------     sdf sea                                                --------------------\n//-----------------------------------------------------------------------------------------\n// this function was modifed/inspired from: https://www.shadertoy.com/view/tsVcWt\n// this scene in a cup but we wanted/were inspired by the waves\n//  by Emilie \nfloat sdSea(vec3 p) {\n\n\tvec2 af = vec2(1);\n    mat2 r = rotate(23.23);\n    \n\tfloat t = iTime * .4,\n    \n\t      wave = noise(p.x);\n          \n\tfor (int i = 0; i < 8; i++) {\n    \n\t\twave += (1. - abs(sin((p.x + t) * af.y))) * af.x;\n\t\tp.xz *= r;\n\t\taf *= vec2(.5, 1.64);\n\t}\n\n\treturn wave - .2;\n}\n\n//-----------------------------------------------------------------------------------------\n//---------    personal water with modified fbm water function         --------------------\n//             Emilie \n//-----------------------------------------------------------------------------------------\nfloat my_water(in vec3 pos) {\n    float water = pos.y + 1.1 - (fbmWater(vec2(pos.x, pos.z)));\n    return water;\n\n}\n\n\n//-----------------------------------------------------------------------------------------\n//---------     returns all of the sdf scene values with an out mat    --------------------\n//              Brandon\n//-----------------------------------------------------------------------------------------\nfloat map( in vec3 pos, out material mat ){\n    \n    //--------------------------------\n    //         the floor \n    //--------------------------------\n    float flr = my_terrain(pos);\n\n    //--------------------------------\n    //         the water\n    //--------------------------------\n    float water =  my_water(pos);\n    \n    //--------------------------------\n    //         the creature body\n    //--------------------------------\n    \n    float creature = model(pos, modelY, modelX, modelZ) - sin(iTime)*SCALE_F * .004;\n    //--------------------------------\n    //         the creatures eyes\n    //--------------------------------\n    float eye1 = sdSphere(pos - vec3(modelX + .2, modelY ,modelZ + .6) * SCALE_F , .05* SCALE_F);\n    float eye2 = sdSphere(pos - vec3(modelX - .2, modelY, modelZ + .6)* SCALE_F , .05* SCALE_F);\n    \n    \n    //=================================== DUCK EMILIE =========================================\n    \n    //--------- rotation of duck ---------------\n    vec3 duck_pos = pos;\n    duck_pos -= vec3(0.0, 1.2, 0.0) * DUCK_SCALE;\n    \n    duck_pos += vec3(1.5, -0.8, 0.0);\n    \n    float theta = DUCK_ROTATION * 3.14 / 180.0;\n    duck_pos.xz *= rotate(theta);\n    \n    //--------------------------------\n    //         the duck body\n    //--------------------------------\n    float duck_body = duck_body(duck_pos) ;\n    \n    //--------------------------------\n    //         the duck beak\n    //--------------------------------\n    float beak = duck_beak(pos - vec3(-1.5,.8,-.0));\n    float duck = opSmoothUnion(duck_body, beak, .3 * DUCK_SCALE);\n    \n    //float duck;\n    //--------------------------------\n    //         the duck eyes\n    //--------------------------------\n\n    \n    float d_eye1 = sdSphere(pos - vec3(-1.3,1.5,.1) , .05 * DUCK_SCALE);\n    float d_eye2 = sdSphere(pos - vec3(-1.25,1.5,-0.05) , .05 * DUCK_SCALE);\n    \n  \n    //--------------------------------\n    //         find closest object hit by ray\n    //--------------------------------\n    float m = min(flr, water);\n    m = min(m,creature);\n    m = min(m, eye1);\n    m = min(m, eye2);\n    m = min(m, duck_body);\n    m = min(m, beak);\n    m = min(m, d_eye1);\n    m = min(m, d_eye2);\n\n    \n    //--------------------------------\n    //         set our material accordingly \n    //--------------------------------\n    if (m == flr) mat.type = TERRAIN;\n    if (m == water) mat.type = WATER;\n    if (m == eye1 || m == eye2 ) mat.type = EYE;\n    if (m == d_eye1 || m == d_eye2 ) mat.type = EYE;\n    if (m == creature) mat.type = FIRE;\n    if (m == duck_body)mat.type = DUCK_YELLOW;\n    if (m == beak) mat.type = DUCK_ORANGE;\n    \n    else mat.type == SKY;\n\n    return m;\n}\n\n//-----------------------------------------------------------------------------------------\n//---------     calc normals from previous coding assignments (PA6)   ---------------------\n//-----------------------------------------------------------------------------------------\nvec3 calcNormal(in vec3 pos ){\n    material m;\n    vec3 x = vec3(EPSILON,0.0,0.0);\n    vec3 y = vec3(0.0,EPSILON,0.0);\n    vec3 z = vec3(0.0,0.0,EPSILON);\n    return normalize(vec3(map(pos + x,m ) - map(pos-x, m), \n                          map(pos + y,m) - map(pos-y,m ),\n                          map(pos + z,m ) - map(pos-z, m)));\n}\n\n//-----------------------------------------------------------------------------------------\n//---------     cast ray function with takes in a ray and outputs a mat   -----------------\n//                   ---------     based off PA5  -----------------\n//-----------------------------------------------------------------------------------------\nfloat castRay(in ray r, out material m){\n\n    \n    float t = 0.0;\n   \n    // the more iterations the better resolution it will be, but can be heavy to process\n    for (int i = 0; i < 150; i ++){\n    \n        // moving the ray along by using the origin and adding incrementally t times the rays direction\n        vec3 pos = rayAt(r, t);\n        \n        \n        // did we hit something in our scene using the function map \n        float h = map(pos, m);\n        \n        // if hit something, we return what we found at t\n        if (h < EPSILON) return t;\n        \n        // else we keep going\n        t +=h;\n        \n        //past max distance\n        if (t > 20.0) {\n            \n            t = 0.0;\n            return t;\n        }\n    }\n    return t;\n}\n\n\n//-----------------------------------------------------------------------------------------\n//---------     returns a camera given by lookat vec3 and up vec3   -------------------------\n//-----------------------------------------------------------------------------------------\ncamera makeCam(vec3 lookfrom, vec3 lookat, vec3 vup){\n    camera cam;\n    cam.origin = lookfrom;\n    cam.w = normalize(lookat - lookfrom);\n    cam.u = normalize(cross(cam.w, vup));\n    cam.v = normalize(cross(cam.u,cam.w));\n    return cam;\n}\n\n//-----------------------------------------------------------------------------------------\n//---------     returns a camera givena lookat vec3 and up vec3   -------------------------\n//-----------------------------------------------------------------------------------------\nvec3 computerColor(float t, inout vec3 col, material m, in vec3 pos, vec2 uv){\n  \n    //------------------------------\n    // get the normal from the pos\n    //------------------------------\n    vec3 nor = calcNormal(pos);\n    \n    \n    //-----------------------------\n    // Light direction \n    //----------------------------\n    vec3 sun_dir = vec3(0.9 ,0.4,0.5);\n    vec3 l = normalize(sun_dir);\n    float sun_dif = clamp ( dot ( nor, sun_dir), 0.0, 1.0);\n    \n    //-----------------------------\n    // calculate shadow   \n    //----------------------------\n    ray shadow_ray = ray(pos+nor*0.001, sun_dir);\n    float sun_shadow;\n    \n    //-----------------------------\n    // diffused and bounced lighting  \n    //----------------------------\n    float sky_dif = clamp ( dot ( nor, vec3(0.0, 1.0, 0.0)), 0.0, 1.0);\n    float bounce_dif = clamp ( dot ( nor, vec3(0.0, -1.0, 0.0)), 0.0, 1.0);\n   \n\n    // if we have hit something \n    if (t > 0.0){\n\n    //-----------------------------------------------------------------------------------------\n    //----------------------  FIRE.                          ----------------------------------\n    //-----------------------------------------------------------------------------------------\n\n        if (m.type == FIRE){\n        \n/*    The bare structure is based off this toon shader https://www.shadertoy.com/view/3t2yWz\n      but Brandon came up with his own version \n      idea is having a mix of 2 colors that are multiplied by noise which moves upward\n*/\n\n        //noise values using snoise func from class\n        float base = 1.0 - uv.y * .9;\n        //first noise goes upward \n        float up1 = snoise(uv * 3.0 + vec2(0.,iTime * 2.0)) ;\n        //alsgo goes upward but with a small shift to be brighter\n        float up2 = (2.8- .3 * SCALE_F) + snoise(uv * 6.0 + vec2(0.,-iTime))   ;\n\n        \n        vec3 col1 = up1 * RED; //red noise\n        vec3 col2 = up2 * ORANGE; //orange noise\n        \n        col = mix(col1,col2, base);\n        \n        //make redder and adjusting color \n        col *= RED * col + (vec3(1.) - col) ;\n        //https://www.youtube.com/watch?v=owwnUcmO3Lw&t=1s&ab_channel=eleonora\n        //this tutorial on shading gave us helpful tip on dividing the diffuse  and to have \n        //toonier look \n        \n        //col too intense and mult by light reduced that \n        col *= sun_dif/.23 * l ;\n        \n        }\n        \n    //-----------------------------------------------------------------------------------------\n    //----------------------  TERRAIN.                         ----------------------------------\n    //-----------------------------------------------------------------------------------------\n        else if (m.type == TERRAIN){\n        \n            //-----------------------------\n            // emilie lighting -\n            // source: inigo Live coding happy jumping - link (https://www.youtube.com/watch?v=Cfe5UQ-1L9Q&t=9211s&ab_channel=InigoQuilez)\n                //  we took from inigo the concept of casting shadows, but we used our own cast Ray function from PA6\n                // we used our own values but also learned how to mix the sun diffuse, sun shadow, and even a bounce light from \n                // inigos first hour portion in the link above - ie our code and inigo's very similiar in structure\n            //-----------------------------\n            //___________________________ shadow calc ___________________\n\n            sun_shadow = step( castRay(shadow_ray, m), 0.0 );\n            // ______________________________ color blending on the sphere ___________________\n            vec3 matt = vec3(0.3);\n\n            col = matt * vec3(3.0, 3.7, 3.5) * sun_dif * sun_shadow;\n            col += matt * vec3(0.0, 0.2, 0.4) * sky_dif;\n\n            //_______________________________ bounce light __________________________________\n            col += matt * vec3(0.1, 0.4, 0.4) * bounce_dif;\n\n            //_______________________________ color grading _________________________________\n            \n            if(nor.y < 0.25){\n                col *= vec3(1., .5, .5);\n            } else if (nor.y < 0.85){\n                col *= vec3(0.1, .5, 0.1);\n            } else if (nor.y < .90){\n                col *= mix(vec3(1., 1., 1.), vec3(0.1, .5, 0.1), pow(col, vec3(.3)));\n            }\n            else{\n                col *= vec3(.8);\n            }\n        }\n        \n        \n    //-----------------------------------------------------------------------------------------\n    //----------------------  EYES                          -----------------------------\n    //-----------------------------------------------------------------------------------------\n        else if (m.type == EYE){\n            col = BLACK;\n        }\n        \n    //-----------------------------------------------------------------------------------------\n    //----------------------  duck yellow                        -----------------------------\n    //-----------------------------------------------------------------------------------------\n        else if (m.type == DUCK_YELLOW){\n        \n             col = vec3(1.0, 1.0, 0.0);\n             \n            //-----------------------------\n            // emilie lighting -\n            // source: inigo Live coding happy jumping - link (https://www.youtube.com/watch?v=Cfe5UQ-1L9Q&t=9211s&ab_channel=InigoQuilez)\n                //  we took from inigo the concept of casting shadows, but we used our own cast Ray function from PA6\n                // we used our own values but also learned how to mix the sun diffuse, sun shadow, and even a bounce light from \n                // inigos first hour portion in the link above - ie our code and inigo's very similiar in structor\n            //-----------------------------\n            //___________________________ sun and sky colors ON the sphere ___________________\n\n            sun_shadow = step( castRay(shadow_ray, m), 0.0 );\n\n\n            // ______________________________ color blending on the sphere ___________________\n            vec3 matt = vec3(0.3);\n\n            col = matt * vec3(2.0, 2.0, 0.0) * sun_dif * sun_shadow;\n            col += matt * vec3(1.0, 1.0, 0.0) * sky_dif;\n\n            //_______________________________ bounce light __________________________________\n            col += matt * vec3(0.1, 0.1, 0.1) * bounce_dif;\n        }\n        \n    //-----------------------------------------------------------------------------------------\n    //----------------------  duck orange                         -----------------------------\n    //-----------------------------------------------------------------------------------------\n        else if (m.type == DUCK_ORANGE){\n        \n            //-----------------------------\n            // emilie lighting -\n            // source: inigo Live coding happy jumping - link (https://www.youtube.com/watch?v=Cfe5UQ-1L9Q&t=9211s&ab_channel=InigoQuilez)\n                //  we took from inigo the concept of casting shadows, but we used our own cast Ray function from PA6\n                // we used our own values but also learned how to mix the sun diffuse, sun shadow, and even a bounce light from \n                // inigos first hour portion in the link above - ie our code and inigo's very similiar in structor\n            //-----------------------------\n            //___________________________ sun and sky colors ON the sphere ___________________\n\n            sun_shadow = step( castRay(shadow_ray, m), 0.0 );\n\n            // ______________________________ color blending on the sphere ___________________\n            vec3 matt = vec3(0.3);\n\n            col = matt * vec3(2.0, 0.0, 0.0) * sun_dif * sun_shadow;\n            col += matt * vec3(1.0, 1.0, 0.0) * sky_dif;\n\n            //_______________________________ bounce light __________________________________\n            col += matt * vec3(0.1, 0.1, 0.1) * bounce_dif;\n        }\n\n    //-----------------------------------------------------------------------------------------\n    //----------------------  water                        ------------------------------------\n    //-----------------------------------------------------------------------------------------\n        else if (m.type == WATER){\n       \n            //-----------------------------\n            // emilie lighting -\n            // source: inigo Live coding happy jumping - link (https://www.youtube.com/watch?v=Cfe5UQ-1L9Q&t=9211s&ab_channel=InigoQuilez)\n                //  we took from inigo the concept of casting shadows, but we used our own cast Ray function from PA6\n                // we used our own values but also learned how to mix the sun diffuse, sun shadow, and even a bounce light from \n                // inigos first hour portion in the link above - ie our code and inigo's very similiar in structor\n            //-----------------------------\n            //___________________________ shadow calc ___________________\n            \n            sun_shadow = step( castRay(shadow_ray, m), 0.01 );\n            // ______________________________ color blending on the sphere ___________________\n            vec3 matt = vec3(0.0, 0.1, 0.3);\n\n            col = matt / (sun_shadow + vec3(1.0, 1.0, 0.0));\n            col += matt * vec3(0.0, 0.01, 0.05);\n        }\n        \n    }\n    \n    \n    \n    return col;\n}\n\n\n//=========================================================================================\n//-----------------------------------------------------------------------------------------\n//---------     where the main magic happens and everything comes together  ---------------\n//-----------------------------------------------------------------------------------------\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\n    //-----------------------------------------------------------------------------------------\n    //---------     uv cord from frag coord, center                             ---------------\n    //-----------------------------------------------------------------------------------------\n    //-----------------------------------------------------------------------------------------\n    vec2 uv = (2.0 * fragCoord - iResolution.xy)/iResolution.y;\n    //-----------------------------------------------------------------------------------------\n    \n\n    //-----------------------------------------------------------------------------------------\n    //---------     constructing the camera                                   ---------------\n    //-----------------------------------------------------------------------------------------\n    //-----------------------------------------------------------------------------------------\n    vec3 lookfrom = vec3(.2, 1.5,2.0);\n    vec3 lookat = vec3(0.0, 0.9,0.);\n    vec3 vup = vec3(0,1,0);\n\n    camera cam = makeCam(lookfrom, lookat, vup); \n\n\n\n    //-----------------------------------------------------------------------------------------\n    //                        step 1 - construct the ray from the camera and frag coord\n    //-----------------------------------------------------------------------------------------\n    ray r = getray(cam, uv);\n   \n    //-----------------------------------------------------------------------------------------\n    //                                   sky color w clouds i.e. default col\n    //-----------------------------------------------------------------------------------------\n    vec3 col = vec3(fractal_sum(uv * 5. + vec2(iTime * .3,0.0), 8.));\n    col = mix(WHITE, BLUE, col);\n\n    //-----------------------------------------------------------------------------------------\n    //                         step 2 - cast ray, keep track of the material\n    //-----------------------------------------------------------------------------------------\n    material m;\n    float t = castRay(r, m);\n    \n    //-----------------------------------------------------------------------------------------\n    //                         step 3 - construct position from camera\n    //                                 look at plus where we hit the obj (or didnt hit and return sky mat hehe )\n    //-----------------------------------------------------------------------------------------\n    vec3 pos = lookfrom + t * r.dir;\n\n\n    //-----------------------------------------------------------------------------------------\n    //                         step 4 - final compute the color\n    //-----------------------------------------------------------------------------------------\n    col = computerColor(t, col, m, pos, uv);\n\n\n    //-----------------------------------------------------------------------------------------\n    //                         step 4 - gamma correction \n    //-----------------------------------------------------------------------------------------\n    col = pow(col,vec3(1.0/2.4));\n    fragColor = vec4(col, 1.);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"\n//====================================  mat struct PA6=========================================\nstruct material{\n    vec3 color;\n    int type;\n};\n\n//====================================  camera struct PA6 =========================================\nstruct camera{\n    vec3 origin;\n    vec3 w;\n    vec3 u;\n    vec3 v;\n};\n\n//==================================== ray struct  PA5=========================================\n// ray struct which we implementend in PA5\nstruct ray {\n    vec3 ori;\n    vec3 dir;\n};\n\n//====================================  sd sphere PA5  =========================================\nfloat sdSphere(vec3 p, float r)\n{\n \treturn length(p) - r;\n}\n\n//====================================  round function PA5  =========================================\nfloat opRound(float d, float iso)\n{\n    // TODO\n    return d -iso;\n}\n\n//====================================  smooth union PA5 =========================================\nfloat opSmoothUnion(float d1, float d2, float k)\n{\n    float h = max(k - abs(d1-d2),0.0);\n    return min(d1,d2) - (h*h)/( 4.0* k); \n}\n\n\n\n\n//-----------------------------------------------------------------------------------------\n//-----------------------------------------------------------------------------------------\n//-----------------------------------------------------------------------------------------\n//-----------------------------------------------------------------------------------------\n//-----------------------------------------------------------------------------------------\n//-----------------------------------------------------------------------------------------\n\n// Copyright © 2022 Wojciech Jarosz\n// Based off of Andrew Kensler's blog: http://eastfarthing.com/blog/2015-04-21-noise/\n\n\n// map fragment coordinates to world coordinates\n\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n\n\nfloat falloff(float t)\n{\n    float t2 = clamp(0.0, 1.0, abs(t));\n\n    return 1.0 - smoothstep(0.0, 1.0, t2);\n}\n\nfloat bump(vec2 p, vec2 center)\n{\n    vec2 offset = p - center;\n    \n    float b = falloff(offset.x) * falloff(offset.y);\n    \n    float v = 2.*hash12(center) - 1.;\n    return v * b;\n}\n\n\n// signed noise\n// return value in [-1,1]\nfloat snoise(vec2 p)\n{\n    float result = 0.;\n    \n    vec2 ll = floor(p);\n    \n    result += bump(p, ll + vec2(0., 0.0));\n    result += bump(p, ll + vec2(1., 0.0));\n    result += bump(p, ll + vec2(1., 1.0));\n    result += bump(p, ll + vec2(0., 1.0));\n    return result;\n}\n\n\nfloat fractal_sum(vec2 p, float octaves){\n\n    float v = 0.0;\n    float w = 1.0;\n    \n    for (float i = 0.; i < octaves; ++i, p *=3., w *=.25)\n        v += w * snoise(p);\n\n    return v;\n}\n\n//-----------------------------------------------------------------------------------------\n//-----------------------------------------------------------------------------------------\n//-----------------------------------------------------------------------------------------\n//-----------------------------------------------------------------------------------------\n\n// Thanks Shane - https://www.shadertoy.com/view/lstGRB\nfloat noise(vec3 p) {\n\tconst vec3 s = vec3(7, 157, 113);\n\tvec3 ip = floor(p);\n\tvec4 h = vec4(0, s.yz, s.y + s.z) + dot(ip, s);\n\tp -= ip;\n\th = mix(fract(sin(h) * 43758.545), fract(sin(h + s.x) * 43758.545), p.x);\n\th.xy = mix(h.xz, h.yw, p.y);\n\treturn mix(h.x, h.y, p.z);\n}\n\nfloat noise(float n) {\n\tfloat flr = floor(n);\n\tvec2 rndRange = fract(sin(vec2(flr, flr + 1.) * 12.9898) * 43758.545);\n\treturn mix(rndRange.x, rndRange.y, fract(n));\n}\n\nmat2 rotate(float theta) {\n\n    float a = sin(theta);\n    float b = cos(theta);\n    return mat2(b, -a,\n                a, b);\n}","name":"Common","description":"","type":"common"}]}