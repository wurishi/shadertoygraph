{"ver":"0.1","info":{"id":"Xl3SR7","date":"1478614859","viewed":253,"name":"SphereRayMarch","username":"mmostajab","description":"ray marching of a simple sphere\n\nIt also supports virtual reality.","likes":1,"published":1,"flags":1,"usePreview":0,"tags":["raycasting","vr"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec4 back_color(in vec2 fragCoord2d){\n    int n = int(fragCoord2d.x / 10.0 + fragCoord2d.y / 10.0);\n    if(n - 2 * (n / 2) == 0)\n        return vec4(1.0);\n    return vec4(0.0);\n}\n\nbool intersect_sphere(in vec3 worldSphereCenter, in float radius, in vec3 rayOrigin, in vec3 rayDir, inout vec3 normal){\n    \n    vec3 sphereCenter = worldSphereCenter - rayOrigin;\n    \n    float a = length(rayDir) * length(rayDir);\n\tfloat bPrime = -dot(sphereCenter, rayDir);\n\tfloat c = length(sphereCenter) * length(sphereCenter) - radius * radius;\n\tfloat deltaPrime  = bPrime * bPrime - a * c;\n\n\tif(deltaPrime >= 0.0){\n\t\tfloat t = -bPrime - sqrt(deltaPrime);\n\t\tvec3 intersect_point = t * rayDir;\n\t\tnormal = normalize(intersect_point - sphereCenter);\n\n        return true;\n\t} \n    \n    return false;\n    \n}\n\nbool intersect_backgroundPlane(in vec3 worldPlaneCenter, in vec3 worldPlaneNormal, in vec3 rayOrigin, in vec3 rayDir, inout vec3 normal, inout vec3 checker_color) {\n   float t = dot(worldPlaneNormal, worldPlaneCenter - rayOrigin) / dot(worldPlaneNormal, rayDir);\n    if(t >= 0.0){\n        normal = worldPlaneNormal;\n        float distToPlaneCenter = length(worldPlaneCenter - rayOrigin + t * rayDir);\n        int randColorBand = int(distToPlaneCenter);\n        if(randColorBand - 2 * (randColorBand / 2) == 0){\n            checker_color = vec3(1, 1, 1);\n        } else {\n            checker_color = vec3(0, 0, 0);\n        }\n        return true;\n    } else {\n        return false;\n    }\n}\n\nvoid createScene(in vec3 rayOrigin, in vec3 rayDir, out vec4 fragColor){\n    const vec3 objColor = vec3(0.5, 0.2, 0.4);\n    const vec3 lightDir = normalize(vec3(1, 1, 1));\n    \n    float animLength = 6.14;\n    float t = iTime - float(int(iTime / animLength)) * animLength;\n    \n    const float radius = 100.0;\n    vec3 sphereCenter = vec3(iResolution.xy / 2.0 + vec2(0.0, 100.0 * sin(t)), -50.0);\n    \n    \n    vec3 normal = vec3(1.0);\n    \n    vec3 output_color;\n    \n    if(intersect_sphere(sphereCenter, radius, rayOrigin, rayDir, normal)){\n        fragColor = vec4(objColor * dot(normal, lightDir), 1.0);\n    }\n    else if(intersect_backgroundPlane(vec3(iResolution.xy / 2.0, -50.0), vec3(0, 0, 1), rayOrigin, rayDir, normal, output_color)){\n        fragColor = vec4(output_color, 1.0);\n    }\n\t//else fragColor = back_color(fragCoord2d);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord2d )\n{\n    // Playing around with the mouse button.\n    if(length(fragCoord2d - iMouse.xy) < 10.0){\n        fragColor = vec4(1, 0, 0, 1);\n        return;\n    }\n    \n    const float viewPlaneDistance = 200.0;\n    vec3 rayOrigin = vec3(iResolution.xy / 2.0, 200.0);\n    vec3 fragCoord = vec3(fragCoord2d, rayOrigin.z - viewPlaneDistance);\n    vec3 rayDir = normalize(fragCoord - rayOrigin);\n    \n    \n    createScene(rayOrigin, rayDir, fragColor);\n\n    \n}\n\nvoid mainVR( out vec4 fragColor, in vec2 fragCoord2d, in vec3 fragRayOri, in vec3 fragRayDir )\n{\n    float animLength = 6.14;\n    float t = iTime - float(int(iTime / animLength)) * animLength;\n    \n    const vec3 objColor = vec3(0.5, 0.2, 0.4);\n    const vec3 lightDir = normalize(vec3(4, 2, 2));\n    const float viewPlaneDistance = 40.0;\n    \n    createScene(fragRayOri, fragRayDir, fragColor);\n}","name":"Image","description":"","type":"image"}]}