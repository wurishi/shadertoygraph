{"ver":"0.1","info":{"id":"wdlczj","date":"1585187846","viewed":64,"name":"raymarcher-testing-quick","username":"vizaxo","description":"raymarcher","likes":1,"published":1,"flags":32,"usePreview":0,"tags":["raytracing","raymarching","sdf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\t\n    fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    //return;\n    #ifdef PERSIST\n        fragColor /= float(iFrame);\n    #endif\n    fragColor = fromLinear(fragColor);\n    \n    \n}\n\n//TODO\n// Check sphere sampling for diffuse materials is correct\n// Better RNG (from texture?)\n// Better handling of buffer (e.g. moving, animation, etc.)\n//   Could even detect what's moved from last frame?\n// Keyboard and mouse input?\n// Play with more interesting geometry\n// Dynamically figure out how many rays to trace based on speed?","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"struct ray {\n    vec3 ro;\n    vec3 rd;\n    float wavelength;\n};\n    \n#define LIGHT 0u\n#define MIRROR 1u\n#define DIFFUSE 2u\n#define TRANSPARENT 3u\n\n#define WHITE 0u\n#define BLACK 1u\n#define RED 2u\n#define GREEN 3u\n#define BLUE 4u\n#define YELLOW 5u\n\nstruct mat {\n    uint color;\n    uint type;\n};\n    \nstruct matDist {\n    float d;\n    mat m;\n};        \n\nstruct hit {\n    ray r;\n    mat m;\n    bool inside;\n};\n    \nstruct mbHit {\n\tbool didHit;\n    hit h;\n};\n\n#define PERSIST\n#ifdef PERSIST\nfloat epsilon = 0.0001;\nuint rpp =5u;\nint maxIters = 100;\nuint maxBounces = 10u;\n#else\nfloat epsilon = 0.01;\nuint rpp = 1000u;\nint maxIters = 50;\nuint maxBounces = 10u;\n#endif\n\n/*\n//from https://amindforeverprogramming.blogspot.com/2013/07/random-floats-in-glsl-330.html\nuint hash( uint x ) {\n    x += ( x << 10u );\n    x ^= ( x >>  6u );\n    x += ( x <<  3u );\n    x ^= ( x >> 11u );\n    x += ( x << 15u );\n    return x;\n}\n\nfloat fhashBad(float x) {\n    return uintBitsToFloat(hash(floatBitsToUint(x)));\n}\n\nfloat fhash(float x) {\n    return uintBitsToFloat(hash(floatBitsToUint(x)));\n}\n\nfloat getRand( float f ) {\n    const uint mantissaMask = 0x007FFFFFu;\n    const uint one          = 0x3F800000u;\n   \n    uint h = hash( floatBitsToUint( f ) );\n    h &= mantissaMask;\n    h |= one;\n        \n    float  r2 = uintBitsToFloat( h );\n   \n    return r2 - 1.0;\n}*/\n\nfloat pi = 3.14159265358979;\nfloat tau = 6.2831853;\n\n\n\n// Converts a color from linear light gamma to sRGB gamma\n// from https://gamedev.stackexchange.com/a/148088\nvec4 fromLinear(vec4 linearRGB)\n{\n    bvec4 cutoff = lessThan(linearRGB, vec4(0.0031308));\n    vec4 higher = vec4(1.055)*pow(linearRGB, vec4(1.0/2.4)) - vec4(0.055);\n    vec4 lower = linearRGB * vec4(12.92);\n\n    return mix(higher, lower, cutoff);\n}\n// Converts a color from sRGB gamma to linear light gamma\nvec4 toLinear(vec4 sRGB)\n{\n    bvec4 cutoff = lessThan(sRGB, vec4(0.04045));\n    vec4 higher = pow((sRGB + vec4(0.055))/vec4(1.055), vec4(2.4));\n    vec4 lower = sRGB/vec4(12.92);\n\n    return mix(higher, lower, cutoff);\n}\n\n\n\n\nvec3 cie_1964(float lambda) {\n    switch(int(lambda)/10) {\n        case 36: vec3(0.000000122200, 0.000000013398, 0.000000535027);\n        case 37: return vec3(0.000005958600, 0.000000651100, 0.000026143700);\n        case 38: return vec3(0.000159952000, 0.000017364000, 0.000704776000);\n        case 39: return vec3(0.002361600000, 0.000253400000, 0.010482200000);\n        case 40: return vec3(0.019109700000, 0.002004400000, 0.086010900000);\n        case 41: return vec3(0.084736000000, 0.008756000000, 0.389366000000);\n        case 42: return vec3(0.204492000000, 0.021391000000, 0.972542000000);\n        case 43: return vec3(0.314679000000, 0.038676000000, 1.553480000000);\n        case 44: return vec3(0.383734000000, 0.062077000000, 1.967280000000);\n        case 45: return vec3(0.370702000000, 0.089456000000, 1.994800000000);\n        case 46: return vec3(0.302273000000, 0.128201000000, 1.745370000000);\n        case 47: return vec3(0.195618000000, 0.185190000000, 1.317560000000);\n        case 48: return vec3(0.080507000000, 0.253589000000, 0.772125000000);\n        case 49: return vec3(0.016172000000, 0.339133000000, 0.415254000000);\n        case 50: return vec3(0.003816000000, 0.460777000000, 0.218502000000);\n        case 51: return vec3(0.037465000000, 0.606741000000, 0.112044000000);\n        case 52: return vec3(0.117749000000, 0.761757000000, 0.060709000000);\n        case 53: return vec3(0.236491000000, 0.875211000000, 0.030451000000);\n        case 54: return vec3(0.376772000000, 0.961988000000, 0.013676000000);\n        case 55: return vec3(0.529826000000, 0.991761000000, 0.003988000000);\n        case 56: return vec3(0.705224000000, 0.997340000000, 0.000000000000);\n        case 57: return vec3(0.878655000000, 0.955552000000, 0.000000000000);\n        case 58: return vec3(1.014160000000, 0.868934000000, 0.000000000000);\n        case 59: return vec3(1.118520000000, 0.777405000000, 0.000000000000);\n        case 60: return vec3(1.123990000000, 0.658341000000, 0.000000000000);\n        case 61: return vec3(1.030480000000, 0.527963000000, 0.000000000000);\n        case 62: return vec3(0.856297000000, 0.398057000000, 0.000000000000);\n        case 63: return vec3(0.647467000000, 0.283493000000, 0.000000000000);\n        case 64: return vec3(0.431567000000, 0.179828000000, 0.000000000000);\n        case 65: return vec3(0.268329000000, 0.107633000000, 0.000000000000);\n        case 66: return vec3(0.152568000000, 0.060281000000, 0.000000000000);\n        case 67: return vec3(0.081260600000, 0.031800400000, 0.000000000000);\n        case 68: return vec3(0.040850800000, 0.015905100000, 0.000000000000);\n        case 69: return vec3(0.019941300000, 0.007748800000, 0.000000000000);\n        case 70: return vec3(0.009576880000, 0.003717740000, 0.000000000000);\n        case 71: return vec3(0.004552630000, 0.001768470000, 0.000000000000);\n        case 72: return vec3(0.002174960000, 0.000846190000, 0.000000000000);\n        case 73: return vec3(0.001044760000, 0.000407410000, 0.000000000000);\n        case 74: return vec3(0.000508258000, 0.000198730000, 0.000000000000);\n        case 75: return vec3(0.000250969000, 0.000098428000, 0.000000000000);\n        case 76: return vec3(0.000126390000, 0.000049737000, 0.000000000000);\n        case 77: return vec3(0.000064525800, 0.000025486000, 0.000000000000);\n        case 78: return vec3(0.000033411700, 0.000013249000, 0.000000000000);\n        case 79: return vec3(0.000017611500, 0.000007012800, 0.000000000000);\n        case 80: return vec3(0.000009413630, 0.000003764730, 0.000000000000);\n        case 81: return vec3(0.000005093470, 0.000002046130, 0.000000000000);\n        case 82: return vec3(0.000002795310, 0.000001128090, 0.000000000000);\n        case 83: return vec3(0.000001553140, 0.000000629700, 0.000000000000);\n        default: return vec3(0.0);\n    }\n}\n\n\n\nvec3 wavelengthToRGB(float lambda) {\n    vec3 xyz = cie_1964(lambda);\n    float x = xyz.x;\n    float y = xyz.y;\n    float z = xyz.z;\n    \n    vec3 rgb;\n    rgb.r =  3.2404542*x - 1.5371385*y - 0.4985314*z;\n\trgb.g = -0.9692660*x + 1.8760108*y + 0.0415560*z;\n\trgb.b =  0.0556434*x - 0.2040259*y + 1.0572252*z;\n    return rgb;\n}\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":1,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#ifdef PERSIST\n#define ANIMATE 400.0\n#endif\n\nuint maxOffset = 7u;\n\nfloat getRand(uint a, uint offset) {\n    a *= maxOffset;\n    a += offset;\n    return texelFetch(iChannel1, ivec2(a%1021u, (a/1019u) % 1024u), 0).r;\n}\n\nvec3 sampleSphere(uint seed) {\n    float u1 = getRand(seed, 0u);\n    float u2 = getRand(seed, 1u);\n    float r = sqrt(1. - u1*u1);\n    float phi = tau * u2;\n    return vec3(cos(phi) * r, sin(phi) * r, 2. * u1);\n}\n\nvec3 sampleHemisphere(vec3 normal, uint seed) {\n    vec3 v = sampleSphere(seed);\n    if (dot(normal, v) < 0.)\n        return -v;\n    else\n        return v;\n}\n\n\nmatDist unionSDF(matDist a, matDist b) {\n    if (a.d < b.d) {\n        return a;\n    } else {\n        return b;\n    }\n}\n\nmatDist intersectSDF(matDist a, matDist b) {\n    if (a.d > b.d) {\n        return a;\n    } else {\n        return b;\n    }\n}\n\nmat4 rotationMatrix(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n                0.0,                                0.0,                                0.0,                                1.0);\n}\n\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    const float k = sqrt(3.0);\n    h.x *= 0.5*k;\n    p.xy /= h.x;\n    p.x = abs(p.x) - 1.0;\n    p.y = p.y + 1.0/k;\n    if( p.x+k*p.y>0.0 ) p.xy=vec2(p.x-k*p.y,-k*p.x-p.y)/2.0;\n    p.x -= clamp( p.x, -2.0, 0.0 );\n    float d1 = length(p.xy)*sign(-p.y)*h.x;\n    float d2 = abs(p.z)-h.y;\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n}\n\nmatDist sdf(vec3 p) {\n    matDist floor = matDist(p.y + 1.0, mat(WHITE, DIFFUSE));\n    matDist ceil = matDist(-p.y + 3.0, mat(WHITE, LIGHT));\n    matDist right = matDist(p.x + 6.0, mat(WHITE, DIFFUSE));\n    matDist left = matDist(-p.x + 6.0, mat(GREEN, DIFFUSE));\n    matDist back = matDist(-p.z + 6.0, mat(YELLOW, DIFFUSE));\n    matDist front = matDist(p.z + 6.0, mat(BLACK, DIFFUSE));\n    matDist walls = unionSDF(unionSDF(floor, ceil), unionSDF(unionSDF(left, right), unionSDF(back, front)));\n\n\tmat4 prismRotate = rotationMatrix(vec3(0.0,0.0,1.0), -0.5);\n    matDist prism = matDist(sdTriPrism((prismRotate * vec4((p - vec3(0.0, -0.4, 0.0)), 1.0)).xyz, vec2(0.6,1.0)), mat(WHITE, TRANSPARENT));\n\n    //matDist objs = unionSDF(unionSDF(bigSphere, mirrorSphere), unionSDF(redSphere, prism));\n    matDist objs = prism;\n    return unionSDF(walls, objs);\n}\n\nvec3 getNorm(vec3 ro) {\n    return normalize(vec3(\n        sdf(vec3(ro.x + epsilon, ro.yz)).d \n        \t- sdf(vec3(ro.x - epsilon, ro.yz)).d,\n        sdf(vec3(ro.x, ro.y + epsilon, ro.z)).d\n            - sdf(vec3(ro.x, ro.y - epsilon, ro.z)).d,\n        sdf(vec3(ro.xy, ro.z + epsilon)).d\n            - sdf(vec3(ro.xy, ro.z - epsilon)).d));\n}\n\nmbHit march(ray r) {    \n    int iters = maxIters;\n    while (iters-- > 0) {\n        matDist o = sdf(r.ro);\n        float d = o.d;\n        if (abs(d) < epsilon) {\n            // Hit\n            return mbHit(true, hit(r, o.m, d < 0.));\n        } else {\n            // Keep marching\n            r.ro = r.ro + r.rd*abs(d);\n        }\n    }\n    // No hit\n    return mbHit(false, hit(r, mat(BLACK, DIFFUSE), false));\n}\n\nfloat schlick(float n1, float n2, float cosTheta) {\n    float tmp = (n1-n2)/(n1+n2);\n    float r0 = tmp*tmp;\n    return r0 + (1.0-r0) * pow(1.0-cosTheta, 5.0);\n}\n\nfloat getIntensity(uint color, float wavelength) {\n    vec3 rgb = wavelengthToRGB(wavelength);\n    switch (color) {\n        case BLACK: return 0.0;\n        case WHITE: return 1.0;\n        case RED: return rgb.r + 0.05*rgb.b + 0.05*rgb.g;\n        case GREEN: return rgb.g + 0.05*rgb.b + 0.1*rgb.r;\n        case BLUE: return rgb.b + 0.05*rgb.r + 0.1*rgb.g;\n        case YELLOW: return rgb.g + 0.05*rgb.b + 0.5*rgb.r;\n        default: return 0.0;\n    }\n}\n\n// Cauchy's equation\nfloat getRI(float wavelength) {\n    float a = 1.4580;\n    float b = 0.00354;\n    return a + b / (wavelength*wavelength);\n}\n\nfloat trace(uint seed, ray r) {\n    uint bounces = maxBounces;\n    mbHit mh;\n\tfloat intensity = 1.0;\n    while (bounces-- > 0u) {\n        mh = march(r);\n    \tif (mh.didHit) {\n            hit h = mh.h;\n            \n            mat m = h.m;\n            r.ro = h.r.ro;\n            vec3 norm = getNorm(h.r.ro);\n            if (dot(norm, r.rd) > 0.0) {\n                norm *= -1.0;\n            }\n            float attenuation;\n            \n            switch(m.type) {\n            case LIGHT:\n                intensity *= 5.0*getIntensity(m.color, r.wavelength);\n                return intensity;\n            case DIFFUSE:\n            \tr.rd = sampleHemisphere(norm, seed+bounces);\n                break;\n            case MIRROR:\n                r.rd = reflect(r.rd, norm);\n                break;\n            case TRANSPARENT:\n                float n1, n2;\n                if (h.inside) {\n                \tn1 = getRI(r.wavelength);\n                \tn2 = 1.0;\n                } else {\n                    n1 = 1.0;\n                    n2 = getRI(r.wavelength);\n                }\n                \n                float u1 = getRand(seed, 2u);\n                float pReflect = schlick(n1, n2,-(dot(norm, r.rd)));\n                if (u1 < pReflect) {\n                \tr.rd = reflect(r.rd, norm);\n                } else {\n                \tr.rd = refract(r.rd, norm, n1/n2);\n                }\n                break;\n            }\n            r.ro += r.rd*10.0*epsilon;\n            attenuation = abs(dot(r.rd, norm));\n            intensity *= getIntensity(m.color, r.wavelength) * attenuation;\n\n    \t} else {\n            // No hit\n\t\t\treturn 0.0;\n        }\n    }\n    // Exceeded number of bounces\n    return 0.0;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    //if (iTime < 1.0) {return;}\n    //vec3 camPos = vec3(5.0*sin(float(iFrame)/60.),1.5,5.0*cos(float(iFrame)/60.));\n    //vec3 camPos = vec3(-5.0, 0.5, -4);\n    vec3 camPos = vec3(-5.0*sin(ANIMATE / 200.0), 0.5, 5.0*cos(ANIMATE / 200.0));\n    vec3 lookAt = vec3(0,0.0,0);\n    vec3 camDir = normalize(lookAt - camPos);\n    vec3 camLeft = cross(camDir, vec3(0,1,0));\n    vec3 camUp = cross(camDir, camLeft);\n\n    vec2 filmSize = vec2(0.15, 0.15* iResolution.y/iResolution.x);\n    vec3 filmCentre = camPos + camDir*0.1;\n    \n    vec3 outColor = vec3(0);\n    \n    uvec2 res = uvec2(iResolution);\n    uint x = uint(fragCoord.x);\n    uint y = uint(fragCoord.y);\n    uint baseRayId = uint(iFrame)*rpp*res.x*res.y + y*res.x*rpp + x*rpp;\n\n    for (uint i = 0u; i < rpp; i++) {\n\t\tuint rayId = uint(maxBounces) * (baseRayId + i);\n        vec2 jitteredFragCoord = fragCoord + (vec2(getRand(rayId, 4u), getRand(rayId, 5u)-0.5));\n        // Normalised screen coordinates (-0.5 to 0.5)\n        vec2 uv = jitteredFragCoord / iResolution.xy - 0.5;\n\n        vec3 filmPos = filmCentre + filmSize.x*camLeft*uv.x + filmSize.y*camUp*-1.*uv.y;\n        \n        float u = getRand(rayId, 6u);\n        float wavelength = mix(380.0, 700.0, u);\n    \tray r = ray(filmPos, normalize(filmPos - camPos), wavelength);\n\n        outColor += wavelengthToRGB(wavelength) * trace(rayId, r);\n    }\n    //uint i = 3u;\n    //uint rayId = (uint(iFrame)*uint(iResolution.x*iResolution.y) + uint(fragCoord.y)*uint(iResolution.x) + uint(fragCoord.x))*rpp + i;\n\n    // Persistent buffer storing sum of all rays fired\n    #ifdef PERSIST\n    \tvec4 prevColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n        fragColor.rgb = prevColor.rgb + outColor/float(rpp);\n    \t//fragColor = vec4(getRand(rayId, 0u), getRand(rayId, 1u), getRand(rayId, 2u), getRand(rayId, 3u));\n    #else\n        fragColor.rgb = outColor/float(rpp);\n    #endif\n}\n","name":"Buffer A","description":"","type":"buffer"}]}