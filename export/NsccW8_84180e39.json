{"ver":"0.1","info":{"id":"NsccW8","date":"1653339792","viewed":88,"name":"cloud-ish","username":"axelduch","description":"Open to any technical improvements!","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["cloud","volumetricraymarcher"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS 200\n#define SURF_THRESHOLD 0.005f\n#define MAX_DIST 150.f\n#define EPSILON 0.01f\n\nconst mat3 m3  = mat3( 0.00,  0.80,  0.60,\n                      -0.80,  0.36, -0.48,\n                      -0.60, -0.48,  0.64 );\nvec3 sky = vec3(.2, .4, 1.);\n\n// Taken from Inigo Quilez's Rainforest ShaderToy:\n// https://www.shadertoy.com/view/4ttSWf\nfloat hash1( float n )\n{\n    return fract( n*17.0*fract( n*0.3183099 ) );\n}\n\n// Taken from Inigo Quilez's Rainforest ShaderToy:\n// https://www.shadertoy.com/view/4ttSWf\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 w = fract(x);\n    \n    vec3 u = w*w*w*(w*(w*6.0-15.0)+10.0);\n    \n    float n = p.x + 317.0*p.y + 157.0*p.z;\n    \n    float a = hash1(n+0.0);\n    float b = hash1(n+1.0);\n    float c = hash1(n+317.0);\n    float d = hash1(n+318.0);\n    float e = hash1(n+157.0);\n    float f = hash1(n+158.0);\n    float g = hash1(n+474.0);\n    float h = hash1(n+475.0);\n\n    float k0 =   a;\n    float k1 =   b - a;\n    float k2 =   c - a;\n    float k3 =   e - a;\n    float k4 =   a - b - c + d;\n    float k5 =   a - c - e + g;\n    float k6 =   a - b - e + f;\n    float k7 = - a + b + c - d + e - f - g + h;\n\n    return -1.0+2.0*(k0 + k1*u.x + k2*u.y + k3*u.z + k4*u.x*u.y + k5*u.y*u.z + k6*u.z*u.x + k7*u.x*u.y*u.z);\n}\n\n// Taken from Inigo Quilez's Rainforest ShaderToy:\n// https://www.shadertoy.com/view/4ttSWf\nfloat fbm_4( in vec3 x )\n{\n    float f = 2.0;\n    float s = 0.5;\n    float a = 0.0;\n    float b = 0.5;\n    int frame = int(iTime * 100.);\n    for( int i=min(0, frame); i<4; i++ )\n    {\n        float n = noise(x);\n        a += b*n;\n        b *= s;\n        x = f*m3*x;\n    }\n    return a;\n}\n\n// Calculates amount of light absorbed through a volume\nfloat BeerLambert(float absorptionCoefficient, float distanceTraveled) {\n    return exp(-absorptionCoefficient * distanceTraveled);\n}\n\n\nfloat sdSphere( vec3 p, vec3 origin, float s ) {\n  return length(p - origin)-s;\n}\n\n\nfloat sdSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); \n}\n\n\nfloat dist_field(vec3 p) {\n    vec3 fbmCoord = (p + 2.0 * vec3(iTime*.3, 0.0, iTime*.7)) / 1.8f;\n    float sdfValue = sdSphere(p, vec3(-16.0 + cos(iTime) * 4., 2.0 + 20.0 * sin(iTime *.6), -1), 15.6);\n    sdfValue = sdSmoothUnion(sdfValue,sdSphere(p, vec3(cos(iTime) * 8.0, 16.0 + 1.0 * cos(iTime*.05), 3), 5.6), 30.0f);\n    sdfValue = sdSmoothUnion(sdfValue, sdSphere(p, vec3(10.0 * sin(iTime*.6), 3.0, 0), 8.0), 3.0) + 7.0 * fbm_4(fbmCoord / 3.2);\n    return max(p.y-100., sdfValue);\n}\n\n\nfloat ray_march(vec3 ro, vec3 rd) {\n    float dist = 0.f;\n    \n    for (int i = 0; i < MAX_STEPS; i++) {\n        vec3 p = ro + rd * dist;\n        float _dist = dist_field(p);\n        \n        dist += _dist;\n        if (_dist < SURF_THRESHOLD || dist > MAX_DIST) break;\n    }\n    \n    return dist;\n}\n\n\nvec3 get_normal(vec3 p) {\n    float d = dist_field(p);\n    vec2 e = vec2(EPSILON, 0.);\n    vec3 n = vec3(\n        d - dist_field(p - e.xyy),\n        d - dist_field(p - e.yxy),\n        d - dist_field(p - e.yyx)\n    );\n    \n    return normalize(n);\n}\n\n\nvec3 get_light(vec3 light_pos, vec3 p, vec3 rd) {\n    vec3 l = normalize(light_pos - p);\n    \n    float opacity_remaining = 1.0f;\n    float prev_opacity_remaining;\n    float volume_depth = 0.0f;\n    vec3 color = sky;\n    \n    for (int i = 0; i < 13; i++) {\n        volume_depth += 0.9f;\n        \n        if (volume_depth > 800.) break;\n        vec3 pos = p + rd * volume_depth;\n        bool is_in_volume = dist_field(pos) < 0.0f;\n        \n        if (is_in_volume) {\n            prev_opacity_remaining = opacity_remaining;\n            opacity_remaining *= BeerLambert(.0002, volume_depth);\n            color = (prev_opacity_remaining - opacity_remaining) + vec3(.059) * length(light_pos - p);\n        }\n    }\n    return color;\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    vec3 col = vec3(0.7);\n    vec3 ro = vec3(0, 7, -45);\n    vec3 rd = normalize(vec3(uv, 1));\n    float d = ray_march(ro, rd);\n    vec3 p = ro + rd * d;\n    \n    vec3 light_pos = vec3(.3 * cos(iTime*.33) - .25, 0., -2. + sin(iTime*.33) * 10.);\n    vec3 light = get_light(light_pos, p, rd);\n\n    float light_dist = length(vec3(uv, light_pos.z) - light_pos) - .01;\n    \n    if (light_dist <= light_pos.z * .005) {\n        col = vec3(1.);\n    } else if (d <= MAX_DIST) {\n        col *= light;\n    } else {\n        col *= sky - pow(light_dist, 2.);\n    }\n    \n    \n    col = pow(col, vec3(.4545));\n\n    fragColor = vec4(col, .1);\n}","name":"Image","description":"","type":"image"}]}