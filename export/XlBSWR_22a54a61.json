{"ver":"0.1","info":{"id":"XlBSWR","date":"1442948600","viewed":1198,"name":"CheapOcclusionAndNormals","username":"FatumR","description":"The reworked version of this shader: https://www.shadertoy.com/view/MsBXWy\nThe main idea is to use derivative of noise function.\nRun in Fullscreen to avoid sepia blinking.","likes":9,"published":1,"flags":0,"usePreview":0,"tags":["procedural","3d","raymarching","fractal","terrain","fullscreen","derivative"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGRn","filepath":"/media/a/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg","previewfilepath":"/media/ap/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define OCTAVES  8\n\n#define MAX_STEPS  32\n#define THRESHOLD .01\n\nconst float fogDensity = 0.25;\n\nfloat rand(vec2 co){\n   return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat rand2(vec2 co){\n   return fract(cos(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat interFunc1(float t) {\n   return t * t * (3. - 2. * t);\n}\n\nfloat interFunc2(float t) {\n    return (6.* t * t - 15. * t + 10.) * t * t * t;\n}\n\n\nfloat valueNoiseSimple(vec2 vl, out vec4 der) {\n   const vec2 minStep = vec2(1., 0. );\n\n   vec2 grid = floor(vl);\n\n    float s = rand2(grid);\n    float t = rand2(grid + minStep);\n    float u = rand2(grid + minStep.yx);\n    float v = rand2(grid + minStep.xx);\n    \n    float fractX = fract(vl.x);\n    float x1 = interFunc2(fractX);\n    \n    float fractY = fract(vl.y);\n    float y = interFunc2(fractY);\n    \n    float k3 = s - t - u + v;\n    float k2 = t - s;\n    float k1 = u - s;\n    \n    float interpY = s + k2 * x1  + k1 * y + k3 * x1 * y;\n    \n    /* Inspired by https://iquilezles.org/articles/morenoise */\n    \n    der.z = (k2 + k3 * y) * (120.0 * fractX * fractX - 180.0 * fractX + 60.) * fractX;\n    der.w = (k1 + k3 * x1) * (120.0 * fractY * fractY - 180.0 * fractY + 60.) * fractY;\n    \n    der.x = (k2 + k3 * y) * (30.0 * fractX * fractX - 60.0 * fractX + 30.) * fractX * fractX;\n    der.y = (k1 + k3 * x1) * (30.0 * fractY * fractY - 60.0 * fractY + 30.) * fractY * fractY;\n    \n    return interpY;//s + k2 * x1  + k1 * y + k3 * x1 * y;\n}\n\nfloat fractalNoise(vec2 vl, out vec4 der) {\n    float persistance = 2.;\n    float amplitude = 1.2;\n    float rez = 0.0;\n    vec2 p = vl;\n    vec4 temp;\n    float norm = 0.;\n    der = vec4(0.);\n    for (int i = 0; i < OCTAVES + 2; i++) {\n        norm += amplitude;\n        rez += amplitude * valueNoiseSimple(p, temp);\n        // to use as normals, we need to take into account whole length,\n        // we can either normalize vector here or don't apply the amplitude\n        der += temp;\n        amplitude /= persistance;\n        p *= persistance;\n    }\n    return rez / norm;\n}\n\nfloat scene(vec3 a, out vec4 der) {\n   float zVal = fractalNoise(vec2(a.x- 5., a.z ), der);\n   \n   der.zw = -sin(zVal) * der.zw / 4.;\n   der.xy = cos(zVal) * der.xy / 2.;\n   \n   return a.y + 0.2 + sin(zVal * 1.5);\n}\n\nfloat valueNoiseSimpleLow(vec2 vl) {\n\n   const vec2 helper = vec2(0., 1.);\n    vec2 interp = smoothstep(vec2(0.), vec2(1.), fract(vl));\n    vec2 grid = floor(vl);\n\n    return mix(mix(rand2(grid + helper.xx),\n                   rand2(grid + helper.yx),\n                   interp.x),\n               mix(rand2(grid + helper.xy),\n                   rand2(grid + helper.yy),\n                   interp.x),\n               interp.y);\n}\n\nfloat fractalNoiseLow(vec2 vl) {\n    float persistance = 2.;\n    float amplitude = 1.2;\n    float rez = 0.0;\n    vec2 p = vl;\n    float norm = 0.0;\n    for (int i = 0; i < OCTAVES - 3; i++) {\n        norm += amplitude;\n        rez += amplitude * valueNoiseSimpleLow(p);\n        amplitude /= persistance;\n        p *= persistance;\n    }\n    return rez / norm;\n}\n\nfloat sceneLow(vec3 a) {\n   float zVal = fractalNoiseLow(vec2(a.x- 5., a.z ));  \n   return a.y + 0.2 + sin(zVal * 1.5);\n}\n\n\nfloat trace(vec3 O, vec3 D, out float hill) {\n    float L = 0.;\n    float d = 0.;\n    \n    for (int i = 0; i < MAX_STEPS; ++i) {\n        d = sceneLow(O + D*L);\n        L += d * clamp(L * .6, 0.45, .8);\n        \n        if (d < THRESHOLD*L)\n            break;\n    }\n    \n    hill = d;\n    return L;\n}\n\n/* Based on https://iquilezles.org/articles/rmshadows */\nfloat shadow(vec3 O, vec3 D) {\n    float shaded = 1.;\n    \n    float L = 0.;\n    float d = 0.;\n    \n    for (int i = 1; i < MAX_STEPS / 3; ++i) {\n        d = sceneLow(O + D*L);\n        L += d * clamp(L * .6, 0.45, .8);\n        \n        if (d < THRESHOLD*L)\n            return 0.;\n        \n        shaded = min(shaded, 2. * d / L);\n    }\n    \n    return shaded;\n}\n\n// Cheap occlusion, based on second derivative\nfloat occlusion2(vec4 der) {\n    return pow(clamp(-(der.w + der.z)*0.5, -.5, .5) + .5, 2.);\n}\n\nvec3 enlight(vec3 p, vec3 normal, vec3 eye, vec3 lightPos, vec4 der) {\n    vec3 dir = lightPos - p;\n    vec3 eyeDir = eye - p;\n    vec3 I = normalize(dir);\n    vec3 color = texture(iChannel0, p.xz *.5 + .5).rgb;\n    \n    vec3 ambient = color * 0.75;\n    vec3 diffuse = max(dot(normal, I), 0.) * color.rgb;\n\n    diffuse = clamp(diffuse, 0., 1.) * 0.75;\n\n    vec3 refl = normalize(-reflect(I, normal));\n    float spec = max(dot(refl, normalize(eyeDir)), 0.);\n    \n    spec = pow(spec, .3 * 60.);\n    spec = clamp(spec, 0., 1.);\n    \n    vec3 Ispec = spec * vec3(1.0, 1.0, .9);\n    \n    float shade = 1.0;//shadow(p + vec3(0., 0.008, 0.), lightPos);\n    \n    return (Ispec + diffuse) * shade + ambient * occlusion2(der);\n    //return vec3(occlusion2(der));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 temp;\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 centered_uv = uv * 2. - 1.;\n    centered_uv.x *= iResolution.x / iResolution.y;\n    \n    vec2 sunPos = vec2(.845 * iResolution.x / iResolution.y, .2);\n\n    float timeOffset = iTime / 5.;\n    \n    vec3 O = vec3(0., 0.1, 1. - timeOffset);\n    float h = scene(O, temp) * 0.65;\n    O.y -= h;\n    \n    vec3 D = normalize(vec3(centered_uv, -1.0)); //fov\n\n    float hill;\n    float path = trace(O, D, hill);\n    vec3 coord = O + path * D;\n\n    vec3 resColor;\n    vec3 skyBlueColor = vec3(0.529411765, 0.807843137, 0.980392157); \n    vec3 sunColor = vec3(1.0, 1.0, .975);\n    vec3 sunGalo = vec3(.7, .7, .5);\n\n    // Background color\n    vec3 bgColor = mix(vec3(1.), skyBlueColor, clamp(centered_uv.y, 0., 1.));\n    float sunDst = length(centered_uv - sunPos) ;\n    float sunFluctuation = valueNoiseSimple(centered_uv - sunPos + timeOffset, temp);\n    sunFluctuation = clamp(sunFluctuation * .25, 0.1, .2);\n    \n    float galoVal= exp(-pow(sunDst * 0.35, 1.15));\n    float val  = clamp(1. / (sunDst *110.5), 0., 1.);\n    \n    bgColor = mix(bgColor, sunColor*val + (galoVal + sunFluctuation) * sunGalo, galoVal + .5);\n    \n    if (hill >= 0.5) {\n        float cloudCeil = centered_uv.y * .5 - .085;\n        vec2 cloudCoord = centered_uv / cloudCeil;\n        cloudCoord.y += timeOffset / 4.;\n        cloudCoord.x /= pow(iResolution.x / iResolution.y, 3.5);\n        float cloudNoise = 1. * fractalNoiseLow(cloudCoord + 3.5);\n        resColor = (bgColor + clamp(cloudNoise, 0., 1.) );\n        resColor = mix(bgColor, resColor, clamp(cloudCeil, 0., 1.));\n    } else {\n        vec3 lightPos = vec3(5., 3. -h, -2. - timeOffset);\n        vec4 der;\n        scene(coord, der);\n        // Cheap normal, based on first derivative\n        vec3 normal = normalize(vec3(der.x, 1., der.y ));\n        \n        resColor = enlight(coord, normal, O, lightPos, der);\n    \n\n    \tfloat fogFactor = exp(-pow(abs(fogDensity * (coord.z - 1.75 + timeOffset)), 3.0));\n    \tfogFactor = clamp(fogFactor, 0.0, 1.0);\n    \tresColor = mix(bgColor, resColor, fogFactor);\n    }\n\n    fragColor = vec4(resColor, 1.);\n}","name":"Image","description":"","type":"image"}]}