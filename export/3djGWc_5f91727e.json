{"ver":"0.1","info":{"id":"3djGWc","date":"1550156552","viewed":89,"name":"Pulsating peanut","username":"TronJeremy","description":"first attempt to follow Wong's raymarching tutorial :)","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["hello","world"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define RAYSTEPS 255\n#define MINDISTANCE 0.0\n#define MAXDISTANCE 64.0\n#define EPSILON 0.0001\n\n// IOW, list here all primitives/deformation functions that you will need later when composing the scene\nfloat sphereSDF(vec3 p, float radius)\n{\n    return length(p)-radius;\n}\n\nfloat intersectSDF(float distA, float distB) {\n    return max(distA, distB);\n}\n\n// here you compose the scene together using the above functions\nfloat scene(vec3 p)\n{    \n    return intersectSDF(sphereSDF(p, 1.0),sphereSDF(p+vec3(cos(iTime*0.25), sin(iTime), 0.0), 1.0));\n}\n\nfloat bounce(vec3 eye, vec3 marchingDirection, float start, float end) \n{\n    float depth = start;\n    for (int i = 0; i < RAYSTEPS; i++) \n    {\n        float dist = scene(eye + depth * marchingDirection);\n        if (dist < EPSILON) return depth;        \n        depth += dist;\n        if (depth >= end) return end;        \n    }\n    return end;\n}\n\nvec3 rayDirection(float fov, vec2 size, vec2 fragCoord)\n{\n    vec2 xy = fragCoord - size/2.0;\n    float z = size.y / tan(radians(fov)/2.0);\n    return normalize(vec3(xy,-z));\n}\n\nvec3 estimateNormal(vec3 p)\n{\n    return normalize(vec3(\n        scene(vec3(p.x + EPSILON, p.y, p.z)) - scene(vec3(p.x - EPSILON, p.y, p.z)),\n        scene(vec3(p.x, p.y + EPSILON, p.z)) - scene(vec3(p.x, p.y - EPSILON, p.z)),\n        scene(vec3(p.x, p.y, p.z  + EPSILON)) - scene(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec3 eye = vec3(0.0, 0.0, 5.0);\n    vec3 direction = rayDirection(45.0, iResolution.xy, fragCoord);\n    float distance = bounce(eye, direction, MINDISTANCE, MAXDISTANCE);\n    if (distance > MAXDISTANCE - EPSILON)\n    {\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n        return;\n    }    \n    vec3 p = eye + distance * direction;    \n    fragColor = vec4(vec3(estimateNormal(p)), 1.0);\n}\n\n","name":"Image","description":"","type":"image"}]}