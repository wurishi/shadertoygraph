{"ver":"0.1","info":{"id":"tlG3D1","date":"1578800230","viewed":77,"name":"3d ray-sphere intersection","username":"16807","description":"Distance field to a cone. Click the screen to rotate.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raycasting","cone","analytic","minimal"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define IN(T) in T\n#define INOUT(T) inout T\n#define OUT(T) out T\n#define CONST(T) const T\n#define VAR(T) T\n#define FUNC(T) T\n\n#define BIG 1e10\n#define PI 3.1415926\n\n\n\n// 3D FUNCTIONS RETURNING MULTIPLE INTERSECTIONS / CLOSEST APPROACHES\nFUNC(bool) try_distances_along_3d_line_intersecting_sphere(IN(vec3) A0, IN(vec3) A, IN(vec3) B0, IN(float) r, OUT(float) entrance, OUT(float) exit){\n    float xz = dot(B0-A0, A);\n    float z  = length(A0+A*xz - B0);\n    float y2  = r*r-z*z;\n    float dxr = sqrt(max(y2, 1e-10));\n    entrance = xz - dxr;\n    exit     = xz + dxr;\n    return y2 > 0.;\n}\n\n\nmat4 get_rotation_matrix(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n                0.0,                                0.0,                                0.0,                                1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    mat4  projection_matrix_inverse = (mat4(0.5,0,0,0,0,0.3,0,0,0,0,0,-50,0,0,-1,50));\n    mat4  view_matrix_inverse = (get_rotation_matrix(vec3(0,1,0), iMouse.x * -0.01 + 0.1*iTime) * mat4(0.707, 0, 0.707, 0, 0.235, 0.942, -0.235, 0, -0.666, 0.333, 0.666, 0, -4, 2, 4, 1));\n    float reference_distance = 0.5f;//6.367e6;\n    \n    \n    vec2  screenspace    = fragCoord/iResolution.xy;\n    vec2  clipspace      = 2.0 * screenspace - 1.0;\n    vec3  view_direction = normalize(view_matrix_inverse * projection_matrix_inverse * vec4(clipspace, 1, 1)).xyz;\n    vec3  view_origin    = view_matrix_inverse[3].xyz * reference_distance;\n    \n    vec3 A0 = view_origin;\n    vec3 A = view_direction; \n    vec3 B0 = vec3(0,0,0);\n    vec3 B = vec3(1,0,0);\n    float h = 0.5f;\n    float r = 0.5f;\n    \n    float a_in, a_out; bool a_hits = try_distances_along_3d_line_intersecting_sphere(A0,A, vec3(0.5,0,0), 0.5f, a_in, a_out);\n    \n    \n    \n    vec3  color = vec3(0);\n    if (a_hits)\n    {\n        color = vec3(a_in/4.f);\n    }\n    \n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}