{"ver":"0.1","info":{"id":"fljfDG","date":"1652705769","viewed":268,"name":"Metallic Wave 1","username":"denosya","description":"Cube/Symmetry training","likes":11,"published":1,"flags":0,"usePreview":0,"tags":["personnaltoolbox"],"hasliked":0,"parentid":"NlBcDR","parentname":"Metallic Wave 2"},"renderpass":[{"inputs":[{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float CELL_SIZE = 2.;\n\nvec3 cellTransform(vec3 p) {\n\n   float cellSize = CELL_SIZE + 0.05 + sin(iTime*0.25);\n\n   vec3 cell = clamp(round(p / cellSize), -3., +3.);\n   return p - cell * cellSize;\n}\n\nfloat map(in vec3 m) {\n\n    float a = 0.5;\n    float corner = a * 0.41;\n    \n    return length(max(abs(cellTransform(m)) - a, 0.)) - corner;\n}\n\nbool rayMarching(in vec3 ro, in vec3 rd, out vec3 m) {\n    \n    float md = 1.0;\n   \n    while(md < 100.) {       \n    \n        m = ro + rd * md;    \n        \n    \tfloat dist = map(m);\n        \n        if(dist < 0.01) {\n            return true;\n        }\n\n        md += dist;\n    }\n    \n\treturn false;    \n}\n\nvec3 computeNormal(in vec3 pos)\n{\n\tvec3 eps = vec3( 0.01, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t     map(pos+eps.xyy) - map(pos-eps.xyy),\n\t     map(pos+eps.yxy) - map(pos-eps.yxy),\n\t     map(pos+eps.yyx) - map(pos-eps.yyx));\n\treturn normalize(nor);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 m;\n    vec2 uv = (fragCoord - iResolution.xy * 0.5) / iResolution.y;\n\n    float anim = iTime * 0.5;\n    float cosa = cos(anim);\n    float sina = sin(anim);    \n\n    mat3 rot = mat3(vec3(cosa, 0., sina), vec3(0., 1., 0.), vec3(-sina, 0., cosa));\n\n    vec3 camera = vec3(0, 0.5 + 1.5*sin(iTime*0.25), -10. + 1.5*sin(iTime*0.25));\n    \n    vec3 ro = camera;\n    vec3 rd\t= normalize(vec3(uv.xy, 1.));\n\n    ro = rot * ro;\n    rd = rot * rd;\n\n    if(rayMarching(ro, rd, m)) {\n        vec3 normal = computeNormal(m);\n        vec3 refl = reflect(rd, normal);\n        \n        if(rayMarching(m, refl, m)) {\n            normal = computeNormal(m);\n            refl = reflect(refl, normal);\n            fragColor = texture(iChannel0, refl) * 0.5;              \n        }\n        else {\n            fragColor = texture(iChannel0, refl);  \n        }\n    }\n    else {\n       fragColor = texture(iChannel0, rd) * 0.5;  \n    }\n}\n    \n    \n","name":"Image","description":"","type":"image"}]}