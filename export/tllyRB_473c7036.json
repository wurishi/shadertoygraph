{"ver":"0.1","info":{"id":"tllyRB","date":"1592472476","viewed":97,"name":"Basic : Kernel Aproximation","username":"Gijs","description":"Red is the true function. Blue are the sampled points. Cyan is the kernel.  Green is the approximated function using the kernel and the samples. Notice then when the kernel is too small w.r.t. the samples the approximation becomes bumpy and faulty.","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["fhbadfd"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14159265\n\nconst float ZOOM = 3.5;\nconst float SAMPLE_DOMAIN_LEFT = -2.;\nconst float SAMPLE_DOMAIN_RIGHT = 2.;\nconst int   SAMPLES = 17;\n#define h (sin(iTime)*.3+0.4)\n\nfloat kernel(float d){\n    return exp(-(d*d)/(h*h))/(sqrt(PI)*h);\n}\n\nfloat kernel_derivative(float d){\n  \treturn -2.*d*kernel(d)/(h*h);\n}\n\n//distance to plot of the kernel\nfloat dist_to_kernel_plot(vec2 p){\n    return abs(kernel(p.x)-p.y)/sqrt(1.+pow(kernel_derivative(p.x),2.));\n}\n\nfloat function(float x){\n\treturn sin(x*1.*PI);///(1.+x*x);   \n}\n\n//central difference aproximation of the derivative\nfloat derivative(float x){\n    return (function(x+1e-5)-function(x-1e-5))/2e-5;\n}\n\n//distance to plot of function\nfloat dist_to_function_plot(vec2 p){\n    return abs(function(p.x)-p.y)/sqrt(1.+pow(derivative(p.x),2.));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord*2.-iResolution.xy)/iResolution.x*ZOOM;\n\tfloat eps = 1.5/iResolution.x*ZOOM;\n    float domain_length = SAMPLE_DOMAIN_RIGHT-SAMPLE_DOMAIN_LEFT;\n        \n    vec2 samples[SAMPLES];\n    float sample_width = domain_length/float(SAMPLES-1);\n    for(int s=0; s<SAMPLES; s++){\n        samples[s].x = mix(SAMPLE_DOMAIN_LEFT, SAMPLE_DOMAIN_RIGHT, float(s)/float(SAMPLES-1));\n    \tsamples[s].y = function(samples[s].x);   \n    }\n    \n    vec3 col = vec3(0);\n    \n    float aproximation = 0.;\n    for(int s=0; s<SAMPLES; s++){\n        float delta = uv.x - samples[s].x;\n        float difference = abs(delta);           \n    \taproximation += samples[s].y * kernel(difference) * sample_width;\n    }\n    \n    float aproximation_derivative = 0.;\n    for(int s=0; s<SAMPLES; s++){\n        float delta = uv.x - samples[s].x;\n        float difference = abs(delta);\n    \taproximation_derivative += samples[s].y * kernel_derivative(difference) * sample_width * sign(delta);\n    }\n    \n    //drawing\n    float dist, edge;\n    \n    //draw axis\n    dist = min(abs(uv.x),abs(uv.y));\n    edge = smoothstep(eps*2.,eps,dist);\n    col = mix(col, vec3(1., 1., 1.), edge*.5);\n    \n    //draw kernel\n    dist = dist_to_kernel_plot(uv);\n    edge = smoothstep(eps*3.,eps,dist);\n    col = mix(col, vec3(.5, 1., 1.), edge*.5);\n  \n    //draw function\n    dist = dist_to_function_plot(uv);\n    edge = smoothstep(eps*3.,eps,dist);\n    col = mix(col, vec3(1,.5,.5), edge*.5);\n    \n    //draw sample points\n    for(int s=0; s<SAMPLES; s++){\n        float dist = distance(uv,samples[s]) - .02;\n        float edge = smoothstep(eps*3.,eps,dist);\n        col = mix(col, vec3(.5,.5,1.), edge*.7);\n    }\n   \t\n    //draw aproximation\n    dist = abs(aproximation-uv.y)/sqrt(1.+pow(aproximation_derivative,2.));\n    edge = smoothstep(eps*3.,eps,dist);\n    col = mix(col, vec3(.5,1.,.5), edge*.7);\n               \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}