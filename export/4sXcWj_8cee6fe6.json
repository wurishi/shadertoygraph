{"ver":"0.1","info":{"id":"4sXcWj","date":"1489806340","viewed":781,"name":"Menger Sponge Reloaded","username":"1vx_437312114","description":"Menger sponge with point rotation.","likes":23,"published":1,"flags":0,"usePreview":0,"tags":["procedural","3d","raymarching","fractal","distancefield","menger","sponge","mengersponge"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Based on https://www.shadertoy.com/view/4sX3Rn\n// created by inigo quilez - iq\n// (see https://iquilezles.org/articles/menger for details)\n//\n// For an explanation of how to archieve realistic looking outdoor lighting take a look at\n// another excellent article of iq:\n//\n// https://iquilezles.org/articles/outdoorslighting\n//\n// and for raymarching in general the classic article \"rendering worlds with two triangles\"\n//\n// https://iquilezles.org/www/material/nvscene2008/nvscene2008.htm\n//\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n// Thanks to iq for the great tutorials, for shadertoy and everything else\n\n\n#define point_rotation true\n\n\n// globals (are bad, i know, but make life sometimes easier :-) )\nfloat dr;\n\n//Fractal\nconst int   NUM_ITERATIONS  = 5;\nconst float SCALE           = 3.0; \n      vec3  OFFSET          = vec3(1.0, 1.0, 1.0);\n\t  mat3  m               = mat3(1,0,0,0,1,0,0,0,1);//Initialized in main function\n\n\n// background color function, computes skycolor based on ray direction (used, if the ray hits nothing)\nvec3 skyColor(vec3 rd)\n{\n    vec3 sunDir = vec3(0.0, -1.0, 0.0);\n    vec3 sunColor = vec3(1.6, 1.8, 2.2);\n\n    float sunAmount = max(dot(rd, sunDir), 0.0);\n    float v = pow(1.0 - max(rd.y, 0.0), 6.0);\n    vec3 sky = mix(vec3(0.1, 0.2, 0.3), vec3(0.32, 0.32, 0.32), v);\n\n    sky += sunColor * sunAmount * sunAmount * 0.25 + sunColor * min(pow(sunAmount, 800.0) * 1.5, 0.3);\n\n\n    return clamp(sky, vec3(0.0, 0.0, 0.0), vec3(1.0, 1.0, 1.0));\n}\n\n\nfloat map(vec3 p)\n{\n\tfloat orbit = 1e20;\n    \n    for(int n = 0; n < NUM_ITERATIONS; n++) \n    {\n\t\tif(point_rotation)\n\t\t{\n\t\t\tfloat factor = 3.14159265 * 2.0 * (sin(iTime * 0.01));   \n    \n\t\t\tfloat si = sin(factor);\n\t\t\tfloat co = cos(factor);   \n\t\t\t\n\t\t\tmat3 xrot = mat3(\n\t\t\t\t 1.0,   0.0,  0.0,\n\t\t\t\t 0.0,    co,   si,\n\t\t\t\t 0.0,   -si,   co\n\t\t\t);\n\t\t\t\n\t\t\tmat3 yrot = mat3(\n\t\t\t\t   co,  0.0,  -si,\n\t\t\t\t  0.0,  1.0,  0.0,\n\t\t\t\t   si,  0.0,  co\n\t\t\t);\n\t\t\t\n\t\t\tmat3 zrot = mat3(\n\t\t\t\t   co,   si, 0.0,\n\t\t\t\t  -si,   co, 0.0,\n\t\t\t\t  0.0,  0.0, 1.0\n\t\t\t);\n\t\t\t\n\t\t\tp = p * xrot * yrot * zrot;\n\t\t}\n\t\t\n    \tp = abs(p);\n        \n    \tif(p.x < p.y)\tp.xy = p.yx;\n    \tif(p.x < p.z) \tp.xz = p.zx;\n    \tif(p.y < p.z) \tp.zy = p.yz;\t \n        \n    \tp.z -=  0.5 * OFFSET.z * (SCALE - 1.0) / SCALE;\n    \tp.z  = -abs(p.z);\n    \tp.z +=  0.5 * OFFSET.z * (SCALE - 1.0) / SCALE;\n        \n        p *= m;\n        \n   \t\tp   *= SCALE;  \n\t\tp.x -= OFFSET.x * (SCALE - 1.0);\n\t\tp.y -= OFFSET.y * (SCALE - 1.0);\n        \n        orbit = min(orbit, length(p));\n    }\n    \n    //distance to a cube\n    vec3 d = abs(p) - vec3(1.0, 1.0, 1.0);\n    float dis = min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));\n    \n    //back to real scale\n    dis *= pow(SCALE, float(-NUM_ITERATIONS));\n    \n    dr = orbit;\n    \n    return dis;\n}\n\n\n// raymarching with distance field\nfloat intersect( in vec3 ro, in vec3 rd)\n{\n    const int maxStepCount = 256;\t// maximum no. of steps to march\n    const float tMax = 100.0;\t\t// maximum distance to march\n    const float epsilon = 0.0003;\t// determines precision (smaller values for more details\n    \t\t\t\t\t\t\t\t// and more noise due to holes from precision problems)\n\n\tfloat t = 0.0;\n\n    // march!\n    for(int i = 0; i < maxStepCount; i++)\n    {\n        // march forward along the ray, compute point p on ray for this step\n        vec3 p = ro + rd * t;\n\n        // get distance to nearest surface from distance field\n        float distance = map(p);\n\n        // if we're already marched too far (t > tMax),\n        // or we're close enough (less than epsilon) to the surface (we have \"hit\" it)\n        if ((t > tMax) || (distance < epsilon))\n            break;\n\n        // march further along the ray with the maximal distance possible,\n        // which is distance to the closest surface from the actual position\n        // taken from the signed distance field describing the mandelbulb\n        // this ensures, that we haven't gone too far, so that we are not already inside the mandelbulb\n        t += distance;\n    }\n\n    // if we're not exceeded the maximum marching distance, return ray parameter t for\n    // computating the hit surface position\n    if( t < tMax )\n   \t\treturn t;\n    else\n        return -1.0;\t// we missed it, signal this with -1.0\n}\n\n\n// cheap distance field soft shadow computation\n// (see iq article \"free penumbra shadows for raymarching distance fields\":\n// https://iquilezles.org/articles/rmshadows)\nfloat softShadow(vec3 surfacePoint, vec3 lightDir)\n{\n    vec3 origin = surfacePoint + 0.001 * lightDir;\n\n    vec3 ro = origin;\n    vec3 rd = lightDir;\n\n\n    const float k = 2.0; // 8.0\n    float res = 1.0;\n\tfloat t = 0.0;\n\n    for (int i = 0; i < 100; i++)\n    {\n        float h = map(ro + rd * t);\n\n        if (h < 0.0001)\n            return 0.0;\n\n        if (t > 100.0)\n            break;\n\n        res = min(res, k * h / t);\n        t += h;\n    }\n\n    return res;\n}\n\n\n// numerically approximate normal via discrete gradient computation (first order)\nvec3 computeNormal(vec3 surfacePoint)\n{\n    const float epsilon =  0.001;\n\n    vec3 epsX = vec3(epsilon, 0.0, 0.0);\n    vec3 epsY = vec3(0.0, epsilon, 0.0);\n    vec3 epsZ = vec3(0.0, 0.0, epsilon);\n\n    float dx = map(surfacePoint + epsX) - map(surfacePoint - epsX);\n    float dy = map(surfacePoint + epsY) - map(surfacePoint - epsY);\n    float dz = map(surfacePoint + epsZ) - map(surfacePoint - epsZ);\n\n    vec3 n = normalize(vec3(dx, dy, dz));\n\n    return n;\n}\n\n\n// cheap distance field ambient occlusion computation\nfloat computeAO(vec3 surfacePoint, vec3 normal)\n{\n    const float k = 5.0;\n    const float delta = 0.005;\n\n    float sum = 0.0;\n\n    for(float i = 0.0; i < 10.0; i+=1.0)\n    {\n        float factor = 1.0 / pow(2.0, i);\n        vec3 samplePoint = surfacePoint + normal * i * delta;\n\n        sum += factor * (i * delta - map(samplePoint));\n    }\n\n    return 1.0 - k * sum;\n}\n\n\n// compute fragment color by raymarching the whole scene, given 2D coords\nvec3 raymarch(vec2 point)\n{\n    // scene parameters\n    const vec3 cameraLookAt = vec3(0.0, 0.1, 0.0);\n\n    const vec3 light1 = vec3(  0.577, 0.577, -0.577 );\n\tconst vec3 light2 = vec3( -0.707, 0.000,  0.707 );\n\n\tconst float fov = 1.2;\t// change for bigger field of view\n\n\n    // compute aspect ratio 'corrected' pixel position\n    float aspectRatio = iResolution.x / iResolution.y;\n    vec2 xy = -1.0 + 2.0 * point.xy / iResolution.xy;\n\n    vec2 s = xy * vec2(aspectRatio, 1.0);\n\n\n    // slow down time ...\n    float time = iTime * 0.5;\n\n\t// some iq magic for camera movement ...  (time dependent camera radius and rotations)\n\tfloat r = 2.3 + 0.1  * cos(0.29 * time);\n    vec3  ro = vec3( r * cos(0.33 * time), 0.8 * r * sin(0.37 * time), r * sin(0.31 * time) ); // ray origin\n\tfloat cr = 0.5 * cos(0.1 * time);\n\tvec3 cp = vec3(sin(cr), cos(cr), 0.0);\n\n    // compute orthonormal camera basis\n    vec3 cameraDir = normalize(cameraLookAt - ro);\n\tvec3 cameraRight = normalize(cross(cameraDir, cp));\n\tvec3 cameraUp = normalize(cross(cameraRight, cameraDir));\n\n    // compute ray direction for perspective camera\n\tvec3 rd = normalize( s.x  * cameraUp + s.y * cameraRight + fov * cameraDir );\n\n\n\tvec3 col;\n\tvec3 tra;\n\n    // intersect ray (ray origin (ro), ray direction (rd) with scene,\n    // get ray parameter t for determining hit surface point\n    float t = intersect(ro, rd);\n\t\t\n\t\t\n    // nothing hit -> background color based on ray direction\n    if( t < 0.0 )\n        col = skyColor(rd);\n\telse\n\t{\n        // hit at t, compute position, normal, reflection, usw. (see links above)\n\t\tvec3 pos = ro + t * rd;\n        vec3 nor = computeNormal(pos);\n        vec3 hal = normalize( light1 - rd);\n        vec3 ref = reflect( rd, nor );\n\n        // for using resoluts of orbit traps for color\n\t\tfloat trc = 0.1 * log(dr);\n\n        // position based color for 'colorful' coloration :-)\n        tra = vec3(trc, trc, 0) * abs(pos);\n\n\n        col = vec3(0.7, 0.2, 0.2);\n\t\tcol = mix( col, vec3(1.0, 0.5, 0.2), sqrt(tra.y) );\n\t\tcol = mix( col, vec3(1.0, 1.0, 1.0), tra.x );\n\n        // compute diffuse components from both lights\n\t\tfloat dif1 = clamp( dot( light1, nor ), 0.0, 1.0 );\n\t\tfloat dif2 = clamp( 0.5 + 0.5*dot( light2, nor ), 0.0, 1.0 );\n\n        // add other lighting components (ambient occlusion, softshadows, specular)\n        // see iq article (https://iquilezles.org/articles/outdoorslighting)\n        float occ =  0.05 * computeAO(pos, nor);\n        float sha = softShadow(pos, light1);\n        float fre = 0.04 + 0.96 * pow( clamp(1.0 - dot(-rd, nor), 0.0, 1.0), 5.0 );\n        float spe = pow( clamp(dot(nor, hal),0.0, 1.0), 12.0 ) * dif1 * fre * 8.0;\n\n        // some color magic\n        // 'good artists copy, great artists steal'. for the original see: \n        // https://www.shadertoy.com/view/ltfSWn\n\t\tvec3 lin  = 1.5 * vec3(0.15, 0.20, 0.23) * (0.7 + 0.3 * nor.y) * (0.2 + 0.8 * occ);\n\t\t     lin += 3.5 * vec3(1.00, 0.90, 0.60) * dif1 * sha;\n\t\t     lin += 4.1 * vec3(0.14, 0.14, 0.14) * dif2 * occ;\n             lin += 2.0 * vec3(1.00, 1.00, 1.00) * spe * sha * occ;\n             lin += 2.0 * vec3(0.20, 0.30, 0.40) * (0.02 + 0.98 * occ);\n             lin += 2.0 * vec3(0.8, 0.9, 1.0) * smoothstep( 0.0, 1.0, ref.y ) * occ;\n\n\t\tcol *= lin;\n        col += spe * 1.0 * occ * sha;\n\t}\n\n\n    // cheap gamma correction (for gamma = 1.0 / 2.0, close to 'official' lcd screen gamma = 1.0 / 2.2)\n\tcol = sqrt( col );\n\n\n\treturn col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 color;\n\n\t// single sample for speed\n\tcolor = raymarch(fragCoord.xy);\n\t\t\n\n\tfragColor = vec4( color, 1.0 );\n}\n","name":"Image","description":"","type":"image"}]}