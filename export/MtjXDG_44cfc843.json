{"ver":"0.1","info":{"id":"MtjXDG","date":"1446252557","viewed":167,"name":"Inside a cylinder","username":"meshula","description":"Inside a cylinder","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["cylinder"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[],"code":"\nmat3 rotationMatrix(vec3 axis, float angle)\n{\n    // the usual method, copied from\n    // http://www.neilmendoza.com/glsl-rotation-about-an-arbitrary-axis/\n    //\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat3(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c);\n}\n\nmat3 createCameraYPR(float cameraYaw, float cameraPitch, float cameraRoll )\n{\n    vec3 forward = -normalize(vec3(sin(cameraYaw), sin(cameraPitch), cos(cameraYaw)));\n\tvec3 up = vec3(0.0, 1.0, 0.0);\n\tvec3 cameraRight = normalize( cross(forward, up) );\n\tvec3 cameraUp = normalize( cross(cameraRight, forward) );\n    return rotationMatrix(forward, cameraRoll) * mat3( cameraRight, cameraUp, forward);\n}\n\nvec4 traceCylinder(vec3 rayDirection)\n{\n    float radius = 0.5;\n    float zmax = 1.0;\n    float zmin = -1.0; // cylinder length is 2, centered on origin\n    \n    vec3 eye = vec3(0.0, 0.2, 0.0);\n \n    float a = dot(rayDirection.xy, rayDirection.xy);\n    float b = -2.0 * dot(eye.xy, rayDirection.xy);\n    float c = dot(eye.xy, eye.xy) - radius * radius;\n\n    float t = b*b - 4.0 * a*c;\n    vec3 intersection;\n    bool cap = true;\n    \n    if (abs(a) > 0.0)\n    {\n        float t1 = (b + sqrt(t)) / (2.0 * a);\n        float t2 = (b - sqrt(t)) / (2.0 * a);\n        if (t1 > t2)\n        {\n            float temp = t1;\n            t1 = t2;\n            t2 = temp;\n        }\n        if (t1 > 0.0 && t2 > 0.0)\n        {\n\t        float z1 = eye.z + t1 * rayDirection.z;\n    \t    float z2 = eye.z + t2 * rayDirection.z;\n        \n        \tif (z1 > zmin && zmax > z2)\n        \t{\n            \tcap = false;\n                intersection = eye + t1 * rayDirection;\n        \t}\n        }\n        else if (t1 > 0.0)\n        {\n\t        float z1 = eye.z + t1 * rayDirection.z;\n        \n        \tif (z1 > zmin && zmax > z1)\n        \t{\n            \tcap = false;\n                intersection = eye + t1 * rayDirection;\n        \t}\n        }\n        else\n        {\n\t        float z1 = eye.z + t2 * rayDirection.z;\n        \n        \tif (z1 > zmin && zmax > z1)\n        \t{\n            \tcap = false;\n                intersection = eye + t2 * rayDirection;\n        \t}\n        }\n    }\n        \n    float pi = 3.1415926;\n    float two_pi = 2.0 * pi;\n\n    if (cap)\n    {\n        // since the cylinder is canonically at the origin\n        if (rayDirection.z > 0.0)\n        {\n            // intersect ray with +z cap\n            //t = -(dot(eye, capNormal + d) / (dot(rayDirection, capNormal);\n            t = -(-eye.z + zmax) / -rayDirection.z;\n            intersection = eye + t * rayDirection;\n\t        float angle = atan(intersection.y, intersection.x);\n    \t    angle = mod(angle + two_pi, two_pi) / two_pi;\n            float radius = dot(intersection.xy, intersection.xy);\n        \treturn vec4(mod(angle * 16.0, 1.0) * 2.0 * radius, 0, 0, 1);\n        }\n        // intersect ray with -z cap\n        //t = -(dot(eye, capNormal + d) / (dot(rayDirection, capNormal);\n        t = -(eye.z + zmax) / rayDirection.z;\n        intersection = eye + t * rayDirection;\n        float angle = atan(intersection.y, intersection.x);\n        angle = mod(angle + two_pi, two_pi) / two_pi;\n        float radius = dot(intersection.xy, intersection.xy);\n       \treturn vec4(mod(angle * 16.0, 1.0) * 2.0 * radius, 0, 0, 1);\n    }\n    else\n    {        \n        // cylinder\n        float angle = atan(intersection.y, intersection.x);\n        angle = mod(angle + two_pi, two_pi) / two_pi;\n        return vec4(mod(angle * 16.0, 1.0), 0, 0, 1);\n    }\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (-iResolution.xy + 2.0*fragCoord.xy)/ iResolution.y;\n    vec2 m = iMouse.xy/iResolution.xy;\n    mat3 cameraMatrix = createCameraYPR(4.0*m.x, 2.0*(m.y-0.5), 0.0);\n    vec3 rayDirection = cameraMatrix * normalize( vec3(p.xy, 1.77));\n    \n    fragColor = traceCylinder(rayDirection);\n}\n","name":"","description":"","type":"image"}]}