{"ver":"0.1","info":{"id":"ts2XWd","date":"1555711120","viewed":267,"name":"3d framebuffer","username":"khlorghaal","description":"The UnHoly Grail of WebGL.","likes":4,"published":1,"flags":32,"usePreview":0,"tags":["3d","framebuffer","buffer","packing","data","structure"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Copyright 2019 khlorghaal GNU GPLv3 https://www.gnu.org/licenses/gpl.txt\n\n//see end of common for packing functions\n//ignore erroneous errors\n\nfloat f(ivec3 p){\n\tint w= cubetex_width();\n    float fw= float(w);\n    //return fw/2.-len(vec3(cubetex_pack(cubetex_unpack(p+w/2)))-fw/2.);\n\t//bufferless function inversion test\n\tp+= w/2;\n    return cubetex_sample(iChannel0, p).x;\n}\nvec4 samp(ivec3 p){\n\treturn vec4(f(p));\n}\n\nvoid reflact(inout vec3 v, inout vec3 N){\n\tv= refract(v,-N, .6);//refraction\n    //v= reflect(v,N);//reflection\n}\nvec4 img(vec2 uv){\n    INIT;\n    //return vec4(float(cubetex_width())-uv.x*64.);//test cubewidth\n    //return vec4( vec3(cube_pack(ivec2(res*vec2(uv)))) / float(cubetex_width()),  1. );//test packing\n    \n    vec2 uvn= nmaps(uv);\n    uvn.x*= asp;\n    vec2 t_rot= vec2(time*.08,0.);\n    vec2 camangle= t_rot-mouse_ang*2.*vec2(1.,0.)+vec2(0.,PI/5.);\n    ray r= look_orbit(uvn, camangle,-mouse.y*128.+64.);\n    \n\tconst float MIN_D= .5;\n    float t=MIN_D;\n    vec3 p= r.c + r.a*t;//position\n    vec3 v= r.a;//march velocity\n    vec4 a= BLACK;//accumulator\n\tvec3 N= vec3(ETA);//normal\n\tfloat b= 0.;//bounce number\t\n    bool psld= false;//preivous cube was solid\n\tvec4 trns;//transmittance, refraction multiplier\n\tconst int MAX_I= 256;\n    for(int i=0; i<MAX_I; i++){\n\t\tivec3 g= ivec3(p);\n        vec4 s= samp(g);\n        bool csld= maxv(s)>0.;//current cube is solid\n        if(csld){//hit\n            if(!psld){//entering cube\n                b++;//increment bounces\n\n                //brdf\n                //vec4 l= vec4(0., nmapu(N.gb)*.75, 1.);\n                vec4 l= vec4(.75);\n                const float REFLECTION= .8;\n                float loss= pow(REFLECTION,b);//of each previous\n                //trns*= l;\n                a+= l*loss;\n\t\t\t\t\n\t\t\t\treflact(v, N);\n            }\n            psld= true;\n        }\n        else{\n            if(psld){//exiting cube\n                //N= -N;\n                reflact(v, N);\n            }\n            psld= false;\n        }\n        \n        //cube marching\n        vec3 sv= sign(v);\n        vec3 enf= floor(p);\n        vec3 enc= ceil(p);\n        vec3 en= lerp(enf, enc, nmapu(sv));//next edges\n        \n\t\tvec3 dp= en-p;//delta position to each next-edge\n\t\tdp+= sv*ETA*t;//pad over the edge slightly\n\t\tvec3 edt= dp/v;//time to each edge\n\t\tfloat dt= minv(edt);//time to soonest edge\n\t\tt+= dt;\n        p+= v*dt;//march\n\n\t\tN= floor(p)-enf;//normal\n\n\t\t/*//assertions\n        if(     dt<=0.\n           ||edt.x<=0.\n\t\t   ||edt.y<=0.\n\t\t   ||edt.z<=0.\n\t\t) return RED;\n        //if(abs(len(N)-1.)>.1) return YELLOW;\n\t\t*/\n    }\n\n\tfloat fog= sat(log(t*(.0005)));\n    vec4 col= lerp(a, WHITE*.85, fog);\n    col= srgb(col);\n    return col;\n}\n\n#ifdef SHADERTOY\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) { fragColor=img(fragCoord/iResolution.xy); }\n#endif\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"//Khlor's header\n//Copyright 2018 GNU GPLv3 https://www.gnu.org/licenses/gpl.txt\n//https://github.com/khlorghaal/glslheader/blob/master/header\n\n//vec4 img(vec2 uv){}\n\n//Define-Switches\n#define SHADERTOY\n#define GLES\n\n//hack from https://www.shadertoy.com/view/3ll3RH by ttg\nfloat _iTime= 1.;\nvec3 _iResolution= vec3(1.);\n#define INIT {_iTime=iTime; _iResolution=iResolution;}\n#define iTime _iTime\n#define iResolution _iResolution\n\n//Consts\n#define PI  3.14159265359\n#define TAU (PI*2.)\n#define PHI 1.61803399\n#define deg2rad 0.01745329251\n#define SQRT2 (sqrt(2.))\n#define BIG 1e8\n#define ETA 1e-5\n#define eqf(a,b) ( abs((a)-(b))<ETA )\n\n//Aliases\n#define fc (gl_FragCoord.xy)\n#define res (iResolution.xy)\n#define ires ivec2(iResolution.xy)\n#define aspect (res.x/res.y)\n#define asp aspect\n#define aspinv (1./aspect)\n#define vec1 float\n#define ivec1 int\n#define uvec1 uint\n#define len length\n#define lerp mix\n#define norm normalize\n#define sat saturate\n#define sats saturate_signed\n#define smooth(x) smoothstep(0.,1.,x)\n#define time float(iTime)\n#define mouse ((iMouse.xy-res/2.)/(res*2.))\n#define mouse_ang (mouse*TAU)\n#define tex texture\n\n\n//vectorization macros\n//I dont use these since I don't trust the optimizer to inline the lambda\n//also multiline edit is easy\n#define VECTORIZE_UNARY_FLOAT(f) \\\nvec2 f(vec2 a){ return vec2(f(a.x),f(a.y)); } \\\nvec3 f(vec3 a){ return vec3(f(a.x),f(a.y),f(a.z)); } \\\nvec4 f(vec4 a){ return vec4(f(a.x),f(a.y),f(a.z),f(a.w)); }\n#define VECTORIZE_BINARY_FLOAT(f) \\\nvec2 f(vec2 a, vec2 b){ return vec2(f(a.x,b.x),f(a.y,b.y)); } \\\nvec3 f(vec3 a, vec3 b){ return vec3(f(a.x,b.x),f(a.y,b.y),f(a.z,b.z)); } \\\nvec4 f(vec4 a, vec4 b){ return vec4(f(a.x,b.x),f(a.y,b.y),f(a.z,b.z),f(a.w,b.w)); }\n#define VECTORIZE_UNARY_INT(f) \\\nivec2 f(ivec2 a){ return ivec2(f(a.x),f(a.y)); } \\\nivec3 f(ivec3 a){ return ivec3(f(a.x),f(a.y),f(a.z)); } \\\nivec4 f(ivec4 a){ return ivec4(f(a.x),f(a.y),f(a.z),f(a.w)); }\n#define VECTORIZE_BINARY_INT(f) \\\nivec2 f(ivec2 a, ivec2 b){ return ivec2(f(a.x,b.x),f(a.y,b.y)); } \\\nivec3 f(ivec3 a, ivec3 b){ return ivec3(f(a.x,b.x),f(a.y,b.y),f(a.z,b.z)); } \\\nivec4 f(ivec4 a, ivec4 b){ return ivec4(f(a.x,b.x),f(a.y,b.y),f(a.z,b.z),f(a.w,b.w)); }\n/* example\nfloat accumulate(float x){ return acc+= x; }\nVECTORIZE_UNARY_FLOAT(accumulate);\nAn impure function is a weird but valid example\n*/\n#define VECTORIZE_SCALAR_ARG(f) \\\nvec2 f(vec2 x, vec1 y){ return _f(x,vec2(y));} \\\nvec3 f(vec3 x, vec1 y){ return _f(x,vec3(y));} \\\nvec4 f(vec4 x, vec1 y){ return _f(x,vec4(y));}\n\n\nvec4   srgb(vec4 c){ return pow(c,vec4(   2.2)); }\nvec4 unsrgb(vec4 c){ return pow(c,vec4(1./2.2)); }\nvec4 texsrgb(sampler2D s,   vec2 uv){ return unsrgb(texture(s,uv)); }\nvec4 texsrgb(samplerCube s, vec3  r){ return unsrgb(texture(s, r)); }\n\n\nvec2 mods(vec2 x, vec1 y){ return mod(x,vec2(y));}\nvec3 mods(vec3 x, vec1 y){ return mod(x,vec3(y));}\nvec4 mods(vec4 x, vec1 y){ return mod(x,vec4(y));}\n\nvec2 pows(vec2 x, vec1 y){ return pow(x,vec2(y));}\nvec3 pows(vec3 x, vec1 y){ return pow(x,vec3(y));}\nvec4 pows(vec4 x, vec1 y){ return pow(x,vec4(y));}\n\n\n vec2 clamps( vec2 x,  vec1 min,  vec1 max){ return clamp(x,  vec2(min), vec2(max));}\n vec3 clamps( vec3 x,  vec1 min,  vec1 max){ return clamp(x,  vec3(min), vec3(max));}\n vec4 clamps( vec4 x,  vec1 min,  vec1 max){ return clamp(x,  vec4(min), vec4(max));}\nivec2 clamps(ivec2 x, ivec1 min, ivec1 max){ return clamp(x, ivec2(min),ivec2(max));}\nivec3 clamps(ivec3 x, ivec1 min, ivec1 max){ return clamp(x, ivec3(min),ivec3(max));}\nivec4 clamps(ivec4 x, ivec1 min, ivec1 max){ return clamp(x, ivec4(min),ivec4(max));}\n\n vec2 mins( vec2 v,  vec1 s){ return min(v,  vec2(s));}\n vec3 mins( vec3 v,  vec1 s){ return min(v,  vec3(s));}\n vec4 mins( vec4 v,  vec1 s){ return min(v,  vec4(s));}\n vec2 maxs( vec2 v,  vec1 s){ return max(v,  vec2(s));}\n vec3 maxs( vec3 v,  vec1 s){ return max(v,  vec3(s));}\n vec4 maxs( vec4 v,  vec1 s){ return max(v,  vec4(s));}\n vec2 mins( vec1 s,  vec2 v){ return min(v,  vec2(s));}\n vec3 mins( vec1 s,  vec3 v){ return min(v,  vec3(s));}\n vec4 mins( vec1 s,  vec4 v){ return min(v,  vec4(s));}\n vec2 maxs( vec1 s,  vec2 v){ return max(v,  vec2(s));}\n vec3 maxs( vec1 s,  vec3 v){ return max(v,  vec3(s));}\n vec4 maxs( vec1 s,  vec4 v){ return max(v,  vec4(s));}\nivec2 mins(ivec2 v, ivec1 s){ return min(v, ivec2(s));}\nivec3 mins(ivec3 v, ivec1 s){ return min(v, ivec3(s));}\nivec4 mins(ivec4 v, ivec1 s){ return min(v, ivec4(s));}\nivec2 maxs(ivec2 v, ivec1 s){ return max(v, ivec2(s));}\nivec3 maxs(ivec3 v, ivec1 s){ return max(v, ivec3(s));}\nivec4 maxs(ivec4 v, ivec1 s){ return max(v, ivec4(s));}\nivec2 mins(ivec1 s, ivec2 v){ return min(v, ivec2(s));}\nivec3 mins(ivec1 s, ivec3 v){ return min(v, ivec3(s));}\nivec4 mins(ivec1 s, ivec4 v){ return min(v, ivec4(s));}\nivec2 maxs(ivec1 s, ivec2 v){ return max(v, ivec2(s));}\nivec3 maxs(ivec1 s, ivec3 v){ return max(v, ivec3(s));}\nivec4 maxs(ivec1 s, ivec4 v){ return max(v, ivec4(s));}\n\nfloat maxv( vec2 a){ return                 max(a.x,a.y)  ;}\nfloat maxv( vec3 a){ return         max(a.z,max(a.x,a.y)) ;}\nfloat maxv( vec4 a){ return max(a.w,max(a.z,max(a.x,a.y)));}\nfloat minv( vec2 a){ return                 min(a.x,a.y)  ;}\nfloat minv( vec3 a){ return         min(a.z,min(a.x,a.y)) ;}\nfloat minv( vec4 a){ return min(a.w,min(a.z,min(a.x,a.y)));}\n  int maxv(ivec2 a){ return                 max(a.x,a.y)  ;}\n  int maxv(ivec3 a){ return         max(a.z,max(a.x,a.y)) ;}\n  int maxv(ivec4 a){ return max(a.w,max(a.z,max(a.x,a.y)));}\n  int minv(ivec2 a){ return                 min(a.x,a.y)  ;}\n  int minv(ivec3 a){ return         min(a.z,min(a.x,a.y)) ;}\n  int minv(ivec4 a){ return min(a.w,min(a.z,min(a.x,a.y)));}\n\n//normalized map to signed\n//[ 0,1]->[-1,1]\nvec1 nmaps(vec1 x){ return x*2.-1.; }\nvec2 nmaps(vec2 x){ return x*2.-1.; }\nvec3 nmaps(vec3 x){ return x*2.-1.; }\nvec4 nmaps(vec4 x){ return x*2.-1.; }\n//normalized map to unsigned\n//[-1,1]->[ 0,1]\nvec1 nmapu(vec1 x){ return x*.5+.5; }\nvec2 nmapu(vec2 x){ return x*.5+.5; }\nvec3 nmapu(vec3 x){ return x*.5+.5; }\nvec4 nmapu(vec4 x){ return x*.5+.5; }\n\n//[0,1]\nfloat saw(float x){ return mod(x,1.); }\nfloat tri(float x){ return abs( mod(x,2.) -1.); }\n  int tri(int x, int a){ return abs( abs(x%(a*2))-a ); }\n\nfloat sum ( vec2 v){ return dot(v,vec2(1));}\nfloat sum ( vec3 v){ return dot(v,vec3(1));}\nfloat sum ( vec4 v){ return dot(v,vec4(1));}\n  int sum (ivec2 v){ return v.x+v.y;}\n  int sum (ivec3 v){ return v.x+v.y+v.z;}\n  int sum (ivec4 v){ return v.x+v.y+v.z+v.w;}\nfloat prod( vec2 v){ return v.x*v.y;}\nfloat prod( vec3 v){ return v.x*v.y*v.z;}\nfloat prod( vec4 v){ return v.x*v.y*v.z*v.w;}\n  int prod(ivec2 v){ return v.x*v.y;}\n  int prod(ivec3 v){ return v.x*v.y*v.z;}\n  int prod(ivec4 v){ return v.x*v.y*v.z*v.w;}\n\n#define sqrtabs(x) sqrt(abs(x))\n#define powabs(x,p) pow(abs(x),p)\n\nvec1 saturate(vec1 x){ return clamp (x, 0.,1.);}\nvec2 saturate(vec2 x){ return clamps(x, 0.,1.);}\nvec3 saturate(vec3 x){ return clamps(x, 0.,1.);}\nvec4 saturate(vec4 x){ return clamps(x, 0.,1.);}\n#define lerpsat(a,b,x) lerp(a,b,saturate(x))\n\nvec1 saturate_signed(vec1 x){ return clamp (x, -1.,1.);}\nvec2 saturate_signed(vec2 x){ return clamps(x, -1.,1.);}\nvec3 saturate_signed(vec3 x){ return clamps(x, -1.,1.);}\nvec4 saturate_signed(vec4 x){ return clamps(x, -1.,1.);}\n\n#define smoother(x) (x*x*x * (x*(x*6.-15.)+10.) )\n\n\nfloat pow2i(int x){ return float(1<<x); }\n\n//nearest power of\nint npo2(float x){ return int(log2(x)); }\nint npo3(float x){ return int(log(x)/log(3.)); }\n\nfloat angle(vec2 v){ return atan(v.y,v.x); }\nvec1 angn(vec1 t){ return t-ceil(t/TAU-.5)*TAU; }\nvec2 angn(vec2 t){ return t-ceil(t/TAU-.5)*TAU; }\n\nbool real(vec1 x){ return !( isnan(x)||isinf(x) ); }\nbool real(vec2 x){ return real(prod(x)); }\nbool real(vec3 x){ return real(prod(x)); }\nbool real(vec4 x){ return real(prod(x)); }\n\nvec1 rationalize(vec1 x){ return real(x)? x:0.; }\n\n#define count(_n) for(int n=0; n!=_n; n++)\n\n//im not sure if this is linear or srgb, or if that even matters much\n#define LUMVEC vec3(0.2126, 0.7152, 0.0722)\nfloat lum(vec3 c){ return dot(c,vec3(LUMVEC)); }\n\n#define BLACK  vec4(0.,0.,0.,0.)\n#define RED    vec4(1.,0.,0.,0.)\n#define GREEN  vec4(0.,1.,0.,0.)\n#define BLUE   vec4(0.,0.,1.,0.)\n#define YELLOW vec4(1.,1.,0.,0.)\n#define CYAN   vec4(0.,1.,1.,0.)\n#define PURPLE vec4(1.,0.,1.,0.)\n#define WHITE  vec4(1.,1.,1.,0.)\n\n#define INT_MAX     0x7FFFFFFF\n#define INT_HALFMAX 0x00010000\n#define INT_MAXF     float(INT_MAX)\n#define INT_HALFMAXF float(INT_HALFMAX)\nvec1 unfix16(vec1 x){ return vec1(x)/INT_HALFMAXF; }\nvec2 unfix16(vec2 x){ return vec2(x)/INT_HALFMAXF; }\nvec3 unfix16(vec3 x){ return vec3(x)/INT_HALFMAXF; }\nvec4 unfix16(vec4 x){ return vec4(x)/INT_HALFMAXF; }\nivec1 fixed16(vec1 x){ return ivec1(INT_HALFMAXF*x); }\nivec2 fixed16(vec2 x){ return ivec2(INT_HALFMAXF*x); }\nivec3 fixed16(vec3 x){ return ivec3(INT_HALFMAXF*x); }\nivec4 fixed16(vec4 x){ return ivec4(INT_HALFMAXF*x); }\n\nivec4 hash(ivec4 x){\n\tx= ((x>>16)^x)*0x45d9f3b;\n\tx= ((x>>16)^x)*0x45d9f3b;\n\t//x=  (x>>16)^x;\n    return x;\n}\n//[-max,+max]->[0,1]\nvec1 hashf(vec1 x){ return abs(vec1(hash(ivec4(fixed16(x),0.,0.,0.)).x  ))/INT_MAXF; }\nvec2 hashf(vec2 x){ return abs(vec2(hash(ivec4(fixed16(x),0.,0.   )).xy ))/INT_MAXF; }\nvec3 hashf(vec3 x){ return abs(vec3(hash(ivec4(fixed16(x),0.      )).xyz))/INT_MAXF; }\nvec4 hashf(vec4 x){ return abs(vec4(hash(ivec4(fixed16(x)         ))    ))/INT_MAXF; }\n\n#define R2A vec2(.99231, .9933)\n#define R2B vec2(.99111, .9945)\n#define R3A vec3(.99312, .98313, .9846)\n#define R3B vec3(.99111, .98414, .9935)\n#define R4A vec4(.99412, .99343, .99565, .99473)\n#define R4B vec4(.99612, .99836, .99387, .99376)\nvec1 rand (vec1 x){ return hashf(x);   }\nvec2 rand (vec2 x){ return hashf(x*hashf(x+x.yx)); }\nvec3 rand (vec3 x){ return hashf(x*1.e2*hashf(R3A+x+x.yzx+x.zxy)); }\nvec4 rand (vec4 x){ return hashf(x*hashf(x+x.yzwx+x.zwxy+x.wxyz)); }\nvec1 rand1(vec2 x){ return hashf(dot(x*R2A-R2B,-x*R2B+R2A)/x.x);  }\nvec1 rand1(vec3 x){ return hashf(dot(x+R3A-R3B,-x+R3B+R3A));  }\nvec1 rand1(vec4 x){ return hashf(dot(x+R4A-R4B,-x+R4B+R4A));  }\nvec2 rand2(vec1 x){ return hashf(x+R2A);   }\nvec3 rand3(vec1 x){ return hashf(x+R3A);   }\nfloat vnse(vec1 x){ return lerp(rand(floor(x)),rand(ceil(x)),fract(x)); }\nfloat vnse(vec2 p){\n\tvec2 fr= fract(p);\n\tvec2 f= floor(p);\n\tvec2 c= ceil(p);\n\tfloat nn= rand1(vec2(f.x,f.y));\n\tfloat np= rand1(vec2(f.x,c.y));\n\tfloat pn= rand1(vec2(c.x,f.y));\n\tfloat pp= rand1(vec2(c.x,c.y));\n\tvec4 v= vec4(nn,np,pn,pp);\n\tvec2 lx= lerp(v.xy,v.zw, fr.xx);\n\treturn lerp( lx.x,lx.y, fr.y );\n}\nfloat vnse(vec3 p){\n\tvec3 fr= fract(p);\n\tvec3 f= floor(p);\n\tvec3 c= ceil(p);\n\tfloat nnn= rand1(vec3(f.x,f.y,f.z));\n\tfloat nnp= rand1(vec3(f.x,f.y,c.z));\n\tfloat npn= rand1(vec3(f.x,c.y,f.z));\n\tfloat npp= rand1(vec3(f.x,c.y,c.z));\n\tfloat pnn= rand1(vec3(c.x,f.y,f.z));\n\tfloat pnp= rand1(vec3(c.x,f.y,c.z));\n\tfloat ppn= rand1(vec3(c.x,c.y,f.z));\n\tfloat ppp= rand1(vec3(c.x,c.y,c.z));\n\tvec4 zn= vec4(\n\t\tnnn,\n\t\tnpn,\n\t\tpnn,\n\t\tppn\n\t);\n\tvec4 zp= vec4(\n\t\tnnp,\n\t\tnpp,\n\t\tpnp,\n\t\tppp\n\t);\n\tvec4 lx= lerp(zn,zp, fr.zzzz);\n\tvec2 ly= lerp(lx.xz, lx.yw, fr.yy);\n\treturn lerp(ly.x,ly.y, fr.x);\n}\n\nfloat perlin(vec3 p){\n\tvec3 fr= fract(p);\n\tvec3 frn= fr-1.;\n\tvec3 f= floor(p);\n\tvec3 c= ceil(p);\n\tvec3 nnn= nmaps(rand(vec3(f.x,f.y,f.z)));\n\tvec3 nnp= nmaps(rand(vec3(f.x,f.y,c.z)));\n\tvec3 npn= nmaps(rand(vec3(f.x,c.y,f.z)));\n\tvec3 npp= nmaps(rand(vec3(f.x,c.y,c.z)));\n\tvec3 pnn= nmaps(rand(vec3(c.x,f.y,f.z)));\n\tvec3 pnp= nmaps(rand(vec3(c.x,f.y,c.z)));\n\tvec3 ppn= nmaps(rand(vec3(c.x,c.y,f.z)));\n\tvec3 ppp= nmaps(rand(vec3(c.x,c.y,c.z)));\n\tfloat d_nnn= dot(nnn, vec3(fr .x, fr .y, fr .z));\n\tfloat d_nnp= dot(nnp, vec3(fr .x, fr .y, frn.z));\n\tfloat d_npn= dot(npn, vec3(fr .x, frn.y, fr .z));\n\tfloat d_npp= dot(npp, vec3(fr .x, frn.y, frn.z));\n\tfloat d_pnn= dot(pnn, vec3(frn.x, fr .y, fr .z));\n\tfloat d_pnp= dot(pnp, vec3(frn.x, fr .y, frn.z));\n\tfloat d_ppn= dot(ppn, vec3(frn.x, frn.y, fr .z));\n\tfloat d_ppp= dot(ppp, vec3(frn.x, frn.y, frn.z));\n\tvec4 zn= vec4(\n\t\td_nnn,\n\t\td_npn,\n\t\td_pnn,\n\t\td_ppn\n\t);\n\tvec4 zp= vec4(\n\t\td_nnp,\n\t\td_npp,\n\t\td_pnp,\n\t\td_ppp\n\t);\n\tvec4 lx= lerp(zn,zp, smooth(fr.zzzz));\n\tvec2 ly= lerp(lx.xz, lx.yw, smooth(fr.yy));\n\treturn nmapu(lerp(ly.x,ly.y, smooth(fr.x)));\n}\n\nfloat worley(vec3 c){\n    float acc= 1.;\n    vec3 cfl= floor(c);\n    vec3 cfr= fract(c);\n    for(int i=-1; i<=1; i++){\n    for(int j=-1; j<=1; j++){\n    for(int k=-1; k<=1; k++){\n        vec3 g= vec3(i,j,k)+cfl;\n        vec3 p= rand(g)+g;\n        float l= len(p-c);\n        acc= min(acc,l);\n    }}}\n\treturn acc;\n}\n\n#define dFdxy(x) (vec2(dFdx(x),dFdy(x)))\n#define grad2(f,x) \\\n\t((vec2( \\\n    \tf(x+vec2(ETA,0)), \\\n\t\tf(x+vec2(0,ETA)) \\\n\t  )-f(x))/ETA)\n#define grad3(f,f0,x) \\\n\t((vec3( \\\n    \tf(x+vec3(ETA,0,0)), \\\n\t\tf(x+vec3(0,ETA,0)), \\\n\t\tf(x+vec3(0,0,ETA)) \\\n\t  )-f(x))/ETA)\n\n#define gradnorm2(f,x)  \\\n\tnorm(vec3(grad2(f,x),1.))\n#define gradnorm3(f,x)  \\\n\tnorm(grad3(f,x))\n\nmat2 rot2d(float t){\n    float c= cos(t);\n    float s= sin(t);\n    return mat2(\n        c,-s,\n        s, c\n    );\n    \n}\nmat3 rotx(float t){\n    float c= cos(t);\n    float s= sin(t);\n    \n    return mat3(\n        1, 0, 0,\n        0, c,-s,\n        0, s, c\n    );\n}\nmat3 roty(float t){\n    float c= cos(t);\n    float s= sin(t);\n    \n    return mat3(\n         c,0,s,\n         0,1,0,\n    \t-s,0,c\n    );\n}\nmat3 rotz(float t){\n    float c= cos(t);\n    float s= sin(t);\n    \n    return mat3(\n        c,-s,0,\n        s, c,0,\n    \t0, 0,1\n    );\n}\n\n//azimuth, inclination\nvec3 azincl(vec2 a){\n    a.x+= PI/2.;\n    vec2 s= sin(a);//sin theta, sin phi\n    vec2 c= cos(a);//cos theta, cos phi\n    vec3 ret= vec3(c.x,s);\n    ret.xy*= c.y;\n    return ret;\n}\n\nstruct ray{\n\tvec3 a;\n    vec3 c;\n};\n\n#define FOV 80.\n#define FOV_S tan(deg2rad*.5*FOV)\n#define NEAR .0\n\nray look_persp(vec2 uvn, vec2 a){\n\tray o;\n    o.a= norm( roty(a.x) * rotx(-a.y) * vec3(uvn*FOV_S,1.));\n    o.c= o.a*NEAR;\n    return o;\n}\nray look_orbit(vec2 uvn, vec2 a, float d){\n    ray o;\n    mat3x3 mat= roty(a.x) * rotx(-a.y);\n    o.a= norm( mat * vec3(uvn*FOV_S,1.));\n    o.c= mat[2]*-d + o.a*NEAR;\n\treturn o;\n}\n\nint doti(ivec2 a, ivec2 b){ return a.x*b.x + a.y*b.y; }\nint doti(ivec3 a, ivec3 b){ return a.x*b.x + a.y*b.y + a.z*b.z; }\nint doti(ivec4 a, ivec4 b){ return a.x*b.x + a.y*b.y + a.z*b.z + a.w*b.w; }\n\n//hacky\nint sqrti(int x){return int(sqrt(float(x)));}\nint cbrti(int x){return int( pow(float(x),1./3.));}\n\n\n\n#ifdef SHADERTOY\n//rip from https://www.shadertoy.com/view/llySRh\n#define KEY_LEFT   37\n#define KEY_UP     38\n#define KEY_RIGHT  39  \n#define KEY_DOWN   40   \n#define KEY_PGUP   33  \n#define KEY_PGDOWN 34  \n#define KEY_END    35  \n#define KEY_HOME   36\n#define KEY_SPACE  32\n#define keyToggle(ascii)  ( texelFetch(iChannel3,ivec2(ascii,2),0).x > 0.)\n#define keyDown(ascii)    ( texelFetch(iChannel3,ivec2(ascii,0),0).x > 0.)\n#define keyClick(ascii)   ( texelFetch(iChannel3,ivec2(ascii,1),0).x > 0.)\n#endif\n\n\n\n/*3d texture hacks\nconvert spatial position into index, then index into N-spatial position\nthis artocity is for evading inconvenient storage dimensions\n\ncompletely trashes cache spatial coherence, as the price of no proper compute.\nif someone wanted to be hardcore they could attempt mapping 3d proximity into 2d.*/\n\n//the biggest cube that w*h texels fits\nint cubetex_width(){\n    return int(pow(res.x*res.y, 1./3.));\n}\n\n//cubecoord->texcoord; use for reading\nivec2 cubetex_unpack(ivec3 e){\n\tint cw= cubetex_width();\n\te= clamps(e, 0, cw);//assert\n\tint xw= ires.x;\n\tint i= e.x+(e.y+e.z*cw)*cw;//1d position\n    return ivec2(i%xw, i/xw);\n}\n//texcoordd->cubecoord; use for writing\n//assert(cube_pack(cube_unpack(p))==p);\nivec3 cubetex_pack(ivec2 e){\n\tint cw= cubetex_width();\n\te= clamp(e, ivec2(0), ires);//assert\n\tint xw= ires.x;\n\tint i= e.x+e.y*xw;\n    return ivec3(i%cw, (i/cw)%cw, i/(cw*cw));\n}\nvec4 cubetex_sample(sampler2D ch, ivec3 p){\n    //no interpolation unless you want to stare into the glitchvoid\n    \n\treturn texelFetch(ch, cubetex_unpack(p), 0);\n}\n\n\n#undef iTime\n#undef iResolution","name":"Common","description":"","type":"common"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"vec4 img(vec2 uv){\n    INIT;\n\tivec3 p= cubetex_pack(ivec2(uv*res));\n    int w= cubetex_width();\n    p-= w/2;\n\tfloat l= float(w/2)-len(vec3(p));\n\treturn vec4(l);\n}\n\n#ifdef SHADERTOY\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) { fragColor=img(fragCoord/iResolution.xy); }\n#endif\n","name":"Buffer A","description":"","type":"buffer"}]}