{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[{"channel":0,"type":"buffer","id":"4dXGR8","filepath":"/media/previz/buffer00.png","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    // Simply display Buffer A\n    fragColor = texture(iChannel0, uv);\n}","name":"Image","description":"","type":"image"},{"outputs":[{"channel":0,"id":"4dXGR8"}],"inputs":[{"channel":0,"type":"buffer","id":"4dXGR8","filepath":"/media/previz/buffer00.png","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"code":"\n\n#ifdef GL_ES\nprecision highp float;\n#endif\n\n\n// Shadertoy uniforms\n//uniform vec3      iResolution; // Viewport resolution (pixels)\n//uniform float     iTime;       // Shader playback time (seconds)\n//uniform int       iFrame;      // Current frame index (0-based)\n//uniform float     iChannelTime[4];\n//uniform vec4      iMouse;\n//uniform sampler2D iChannel0;   // Used for accumulation\n// iChannel1, iChannel2, etc. could be used for other data if needed.\n\n// --------------------------------------------------------\n// Random Utilities\n// --------------------------------------------------------\nfloat hash12(vec2 p) {\n    const float HASHSCALE1 = 443.8975;\n    return fract(sin(dot(p, vec2(12.9898, 78.233))) * HASHSCALE1);\n}\n\nfloat rand(inout vec2 seed) {\n    float r = hash12(seed);\n    // Shift seed for next usage\n    seed += vec2(1.2345, 2.6789);\n    return r;\n}\n\n// --------------------------------------------------------\n// Ray & Hit structures\n// --------------------------------------------------------\nstruct Ray {\n    vec3 origin;\n    vec3 dir;\n};\n\nstruct Hit {\n    float t;\n    vec3 normal;\n    vec3 color;\n    bool hit;\n};\n\n// --------------------------------------------------------\n// Cornell Box Bounds and Configuration\n// --------------------------------------------------------\nconst float BOX_MIN_Y = 0.0;    // Floor\nconst float BOX_MAX_Y = 1.7;    // Ceiling\nconst float BOX_MIN_X = -1.0;   // Left\nconst float BOX_MAX_X =  1.0;   // Right\nconst float BOX_MIN_Z =  0.0;   // Back wall\nconst float BOX_MAX_Z =  1.7;   // front direction (towards camera)\nconst float Light_Intensity=6.0;\n\nbool isLightArea(vec3 p) {\n    // Light region on the ceiling\n    // Positions: x in [-0.2, 0.2], z in [0.8, 1.2], y = BOX_MAX_Y\n    if( abs(p.y - BOX_MAX_Y) < 0.001 &&\n        p.x > -0.2 && p.x < 0.2 &&\n        p.z > 0.8  && p.z < 1.2 ) {\n        return true;\n    }\n    return false;\n}\n\n// --------------------------------------------------------\n// Plane Intersection\n// --------------------------------------------------------\nbool intersectPlane(in Ray ray, in float p, in vec3 n, out float t) {\n    float denom = dot(ray.dir, n);\n    if(abs(denom) < 1e-6) {\n        t = -1.0;\n        return false;\n    }\n    float dist = (p - dot(ray.origin, n)) / denom;\n    if(dist > 0.0) {\n        t = dist;\n        return true;\n    }\n    return false;\n}\n\n// --------------------------------------------------------\n// Axis-Aligned Box Intersection (for interior boxes)\n// --------------------------------------------------------\n// Each box is defined by two corners (minCorner, maxCorner).\nbool intersectAABB(Ray ray, vec3 minB, vec3 maxB, out float t, out vec3 normal) {\n    // We do a “slab” intersection test\n    vec3 invDir = 1.0 / ray.dir;\n    vec3 t0 = (minB - ray.origin) * invDir;\n    vec3 t1 = (maxB - ray.origin) * invDir;\n    \n    // We must ensure t0 <= t1 component-wise\n    vec3 tmin = min(t0, t1);\n    vec3 tmax = max(t0, t1);\n\n    // near/far are the intersection intervals\n    float nearT = max(max(tmin.x, tmin.y), tmin.z);\n    float farT  = min(min(tmax.x, tmax.y), tmax.z);\n\n    if(farT < 0.0 || nearT > farT) {\n        t = -1.0;\n        normal = vec3(0.0);\n        return false;\n    }\n\n    t = nearT;\n    if(t < 0.0) {\n        t = farT;\n    }\n    if(t < 0.0) {\n        normal = vec3(0.0);\n        return false;\n    }\n\n    // To get the normal, we see which axis is “dominant” at nearT\n    vec3 hitPos = ray.origin + t * ray.dir;\n    // We'll see if we are hitting near any of the 6 faces\n    // We'll check with a small epsilon which face is closest\n    const float eps = 0.001;\n    if(abs(hitPos.x - minB.x) < eps) { normal = vec3(-1, 0, 0); }\n    else if(abs(hitPos.x - maxB.x) < eps) { normal = vec3( 1, 0, 0); }\n    else if(abs(hitPos.y - minB.y) < eps) { normal = vec3(0, -1, 0); }\n    else if(abs(hitPos.y - maxB.y) < eps) { normal = vec3(0,  1, 0); }\n    else if(abs(hitPos.z - minB.z) < eps) { normal = vec3(0, 0, -1); }\n    else if(abs(hitPos.z - maxB.z) < eps) { normal = vec3(0, 0,  1); }\n    else { normal = vec3(0.0, 1.0, 0.0); } // fallback\n\n    return true;\n}\n\n// --------------------------------------------------------\n// Cornell Box + Interior Geometry Intersection\n// --------------------------------------------------------\nHit intersectScene(Ray ray) {\n    Hit hit;\n    hit.t = 1e20;\n    hit.hit = false;\n    hit.normal = vec3(0.0);\n    hit.color = vec3(0.0);\n\n    // 1) Intersect Cornell Box walls (planes)\n\n    // floor\n    {\n        float tPlane;\n        if(intersectPlane(ray, BOX_MIN_Y, vec3(0,1,0), tPlane)) {\n            if(tPlane < hit.t) {\n                vec3 p = ray.origin + tPlane * ray.dir;\n                if(p.x >= BOX_MIN_X && p.x <= BOX_MAX_X &&\n                   p.z >= BOX_MIN_Z && p.z <= BOX_MAX_Z ) {\n                    hit.t = tPlane;\n                    hit.hit = true;\n                    hit.normal = vec3(0,1,0);\n                    hit.color = vec3(1.0); // White\n                }\n            }\n        }\n    }\n\n    // ceiling\n    {\n        float tPlane;\n        if(intersectPlane(ray, BOX_MAX_Y, vec3(0,1,0), tPlane)) {\n            if(tPlane < hit.t) {\n                vec3 p = ray.origin + tPlane * ray.dir;\n                if(p.x >= BOX_MIN_X && p.x <= BOX_MAX_X &&\n                   p.z >= BOX_MIN_Z && p.z <= BOX_MAX_Z ) {\n                    hit.t = tPlane;\n                    hit.hit = true;\n                    hit.normal = vec3(0,-1,0);\n                    hit.color = vec3(1.0); // White\n                }\n            }\n        }\n    }\n\n    // back wall\n    {\n        float tPlane;\n        if(intersectPlane(ray, BOX_MIN_Z, vec3(0,0,1), tPlane)) {\n            if(tPlane < hit.t) {\n                vec3 p = ray.origin + tPlane * ray.dir;\n                if(p.x >= BOX_MIN_X && p.x <= BOX_MAX_X &&\n                   p.y >= BOX_MIN_Y && p.y <= BOX_MAX_Y ) {\n                    hit.t = tPlane;\n                    hit.hit = true;\n                    hit.normal = vec3(0,0,1);\n                    hit.color = vec3(1.0); // White\n                }\n            }\n        }\n    }\n\n    // left wall\n    {\n        float tPlane;\n        if(intersectPlane(ray, BOX_MIN_X, vec3(1,0,0), tPlane)) {\n            if(tPlane < hit.t) {\n                vec3 p = ray.origin + tPlane * ray.dir;\n                if(p.y >= BOX_MIN_Y && p.y <= BOX_MAX_Y &&\n                   p.z >= BOX_MIN_Z && p.z <= BOX_MAX_Z ) {\n                    hit.t = tPlane;\n                    hit.hit = true;\n                    hit.normal = vec3(1,0,0);\n                    hit.color = vec3(0.9, 0.0, 0.0); // Red\n                }\n            }\n        }\n    }\n\n    // right wall\n    {\n        float tPlane;\n        if(intersectPlane(ray, BOX_MAX_X, vec3(1,0,0), tPlane)) {\n            if(tPlane < hit.t) {\n                vec3 p = ray.origin + tPlane * ray.dir;\n                if(p.y >= BOX_MIN_Y && p.y <= BOX_MAX_Y &&\n                   p.z >= BOX_MIN_Z && p.z <= BOX_MAX_Z ) {\n                    hit.t = tPlane;\n                    hit.hit = true;\n                    hit.normal = vec3(-1,0,0);\n                    hit.color = vec3(0.0, 0.9, 0.0); // Green\n                }\n            }\n        }\n    }\n\n    // 2) Intersect the interior boxes\n    //    Let’s define two boxes:\n    //       - A short wide box (centered around x=-0.35, z=1.25)\n    //       - A tall narrow box (centered around x= 0.3,  z=0.9)\n\n    // short wide box\n    {\n        vec3 minB = vec3(-0.5, 0.0, 1.1);\n        vec3 maxB = vec3(-0.2, 0.6, 1.4);\n        float tBox; \n        vec3 nBox;\n        if(intersectAABB(ray, minB, maxB, tBox, nBox)) {\n            if(tBox < hit.t) {\n                hit.t = tBox;\n                hit.hit = true;\n                hit.normal = nBox;\n                hit.color = vec3(0.85); // Light grey\n            }\n        }\n    }\n\n    // tall narrow box\n    {\n        vec3 minB = vec3( 0.15, 0.0, 0.7);\n        vec3 maxB = vec3( 0.40, 0.9, 1.0);\n        float tBox; \n        vec3 nBox;\n        if(intersectAABB(ray, minB, maxB, tBox, nBox)) {\n            if(tBox < hit.t) {\n                hit.t = tBox;\n                hit.hit = true;\n                hit.normal = nBox;\n                hit.color = vec3(0.7); // Mid grey\n            }\n        }\n    }\n\n    return hit;\n}\n\n// --------------------------------------------------------\n// Sample Light (Next-Event Estimation)\n// --------------------------------------------------------\nvec3 sampleLight(vec3 pos, vec3 normal, inout vec2 seed) {\n    // Random point on the area light\n    float rx = mix(-0.2, 0.2, rand(seed));\n    float rz = mix( 0.8, 1.2, rand(seed));\n    vec3 lightPos = vec3(rx, BOX_MAX_Y, rz);\n\n    vec3 dirToLight = lightPos - pos;\n    float distToLight = length(dirToLight);\n    dirToLight = normalize(dirToLight);\n\n    // Shadow check\n    Ray shadowRay;\n    shadowRay.origin = pos + normal * 0.001;\n    shadowRay.dir = dirToLight;\n    Hit h = intersectScene(shadowRay);\n\n    // If we intersect something before the light region, we’re in shadow\n    if(h.hit && h.t < distToLight - 0.001) {\n        return vec3(0.0);\n    }\n\n    // Light intensity and geometry factor\n    float intensity =Light_Intensity;\n    float cosTheta = max(dot(dirToLight, normal), 0.0);\n    float falloff = cosTheta / (distToLight * distToLight);\n    float lightArea = (0.2 - (-0.2)) * (1.2 - 0.8); // 0.4 * 0.4 = 0.16\n\n    return vec3(1.0) * intensity * falloff * lightArea; // white light\n}\n\n// --------------------------------------------------------\n// Cosine-weighted hemisphere sampling for indirect bounces\n// --------------------------------------------------------\nvec3 cosineSampleHemisphere(vec3 normal, inout vec2 seed) {\n    float r1 = rand(seed);\n    float r2 = rand(seed);\n\n    float phi = 2.0 * 3.14159265 * r1;\n    float r   = sqrt(r2);\n    float x   = r * cos(phi);\n    float y   = r * sin(phi);\n    float z   = sqrt(1.0 - r2);\n\n    // Create local basis\n    vec3 u = normalize(cross(abs(normal.y) < 0.999 ? vec3(0,1,0) : vec3(1,0,0), normal));\n    vec3 v = cross(normal, u);\n\n    return normalize(x*u + y*v + z*normal);\n}\n\n// --------------------------------------------------------\n// Recursively trace path\n// --------------------------------------------------------\nvec3 tracePath5(Ray ray, inout vec2 seed, int depth) {\n    if(depth <= 0) {\n        return vec3(0.0);\n    }\n\n    Hit h = intersectScene(ray);\n    if(!h.hit) {\n        // Ray missed everything, return black\n        return vec3(0.0);\n    }\n\n    // If we hit the light\n    vec3 hitPos = ray.origin + h.t * ray.dir;\n    if(isLightArea(hitPos)) {\n        // Emissive (bright) region\n        return vec3(Light_Intensity);\n    }\n\n    vec3 normal = normalize(h.normal);\n    vec3 baseColor = h.color; \n\n    // 1) Direct lighting from the area light\n    vec3 directLight = sampleLight(hitPos, normal, seed);\n\n    // 2) Indirect lighting (one more bounce)\n    //    We sample a direction in the hemisphere\n    //    and trace recursively\n    vec3 bounceDir = cosineSampleHemisphere(normal, seed);\n    Ray bounceRay;\n    bounceRay.origin = hitPos + normal * 0.001;\n    bounceRay.dir = bounceDir;\n\n   // vec3 indirect = tracePath4(bounceRay, seed, depth - 1);\n\n    // Combine them (diffuse Lambertian reflection)\n    vec3 color = baseColor * (directLight);\n\n    return color;\n}\nvec3 tracePath4(Ray ray, inout vec2 seed, int depth) {\n    if(depth <= 0) {\n        return vec3(0.0);\n    }\n\n    Hit h = intersectScene(ray);\n    if(!h.hit) {\n        // Ray missed everything, return black\n        return vec3(0.0);\n    }\n\n    // If we hit the light\n    vec3 hitPos = ray.origin + h.t * ray.dir;\n    if(isLightArea(hitPos)) {\n        // Emissive (bright) region\n        return vec3(Light_Intensity);\n    }\n\n    vec3 normal = normalize(h.normal);\n    vec3 baseColor = h.color; \n\n    // 1) Direct lighting from the area light\n    vec3 directLight = sampleLight(hitPos, normal, seed);\n\n    // 2) Indirect lighting (one more bounce)\n    //    We sample a direction in the hemisphere\n    //    and trace recursively\n    vec3 bounceDir = cosineSampleHemisphere(normal, seed);\n    Ray bounceRay;\n    bounceRay.origin = hitPos + normal * 0.001;\n    bounceRay.dir = bounceDir;\n\n    vec3 indirect = tracePath5(bounceRay, seed, depth - 1);\n\n    // Combine them (diffuse Lambertian reflection)\n    vec3 color = baseColor * (directLight+indirect);\n\n    return color;\n}\nvec3 tracePath3(Ray ray, inout vec2 seed, int depth) {\n    if(depth <= 0) {\n        return vec3(0.0);\n    }\n\n    Hit h = intersectScene(ray);\n    if(!h.hit) {\n        // Ray missed everything, return black\n        return vec3(0.0);\n    }\n\n    // If we hit the light\n    vec3 hitPos = ray.origin + h.t * ray.dir;\n    if(isLightArea(hitPos)) {\n        // Emissive (bright) region\n        return vec3(Light_Intensity);\n    }\n\n    vec3 normal = normalize(h.normal);\n    vec3 baseColor = h.color; \n\n    // 1) Direct lighting from the area light\n    vec3 directLight = sampleLight(hitPos, normal, seed);\n\n    // 2) Indirect lighting (one more bounce)\n    //    We sample a direction in the hemisphere\n    //    and trace recursively\n    vec3 bounceDir = cosineSampleHemisphere(normal, seed);\n    Ray bounceRay;\n    bounceRay.origin = hitPos + normal * 0.001;\n    bounceRay.dir = bounceDir;\n\n    vec3 indirect = tracePath4(bounceRay, seed, depth - 1);\n\n    // Combine them (diffuse Lambertian reflection)\n    vec3 color = baseColor * (directLight+indirect);\n\n    return color;\n}\nvec3 tracePath2(Ray ray, inout vec2 seed, int depth) {\n    if(depth <= 0) {\n        return vec3(0.0);\n    }\n\n    Hit h = intersectScene(ray);\n    if(!h.hit) {\n        // Ray missed everything, return black\n        return vec3(0.0);\n    }\n\n    // If we hit the light\n    vec3 hitPos = ray.origin + h.t * ray.dir;\n    if(isLightArea(hitPos)) {\n        // Emissive (bright) region\n        return vec3(Light_Intensity);\n    }\n\n    vec3 normal = normalize(h.normal);\n    vec3 baseColor = h.color; \n\n    // 1) Direct lighting from the area light\n    vec3 directLight = sampleLight(hitPos, normal, seed);\n\n    // 2) Indirect lighting (one more bounce)\n    //    We sample a direction in the hemisphere\n    //    and trace recursively\n    vec3 bounceDir = cosineSampleHemisphere(normal, seed);\n    Ray bounceRay;\n    bounceRay.origin = hitPos + normal * 0.001;\n    bounceRay.dir = bounceDir;\n\n    vec3 indirect = tracePath3(bounceRay, seed, depth - 1);\n\n    // Combine them (diffuse Lambertian reflection)\n    vec3 color = baseColor * (directLight + indirect);\n\n    return color;\n}\nvec3 tracePath1(Ray ray, inout vec2 seed, int depth) {\n    if(depth <= 0) {\n        return vec3(0.0);\n    }\n\n    Hit h = intersectScene(ray);\n    if(!h.hit) {\n        // Ray missed everything, return black\n        return vec3(0.0);\n    }\n\n    // If we hit the light\n    vec3 hitPos = ray.origin + h.t * ray.dir;\n    if(isLightArea(hitPos)) {\n        // Emissive (bright) region\n        return vec3(Light_Intensity);\n    }\n\n    vec3 normal = normalize(h.normal);\n    vec3 baseColor = h.color; \n\n    // 1) Direct lighting from the area light\n    vec3 directLight = sampleLight(hitPos, normal, seed);\n\n    // 2) Indirect lighting (one more bounce)\n    //    We sample a direction in the hemisphere\n    //    and trace recursively\n    vec3 bounceDir = cosineSampleHemisphere(normal, seed);\n    Ray bounceRay;\n    bounceRay.origin = hitPos + normal * 0.001;\n    bounceRay.dir = bounceDir;\n\n    vec3 indirect = tracePath2(bounceRay, seed, depth - 1);\n\n    // Combine them (diffuse Lambertian reflection)\n    vec3 color = baseColor * (directLight + indirect);\n\n    return color;\n}\n\n// --------------------------------------------------------\n// Main Shadertoy entry\n// --------------------------------------------------------\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n\n    // Simple camera\n    vec3 camOrigin = vec3(0.0, 0.8, 3.0);\n    vec3 camTarget = vec3(0.0, 0.7, 0.0);\n    vec3 camDir = normalize(camTarget - camOrigin);\n    vec3 worldUp = vec3(0.0, 1.0, 0.0);\n    vec3 camRight = normalize(cross(camDir, worldUp));\n    vec3 camUp    = cross(camRight, camDir);\n\n    float fov = 1.1;\n    vec3 rayDir = normalize(camDir + uv.x * camRight * fov + uv.y * camUp * fov);\n\n    Ray ray;\n    ray.origin = camOrigin;\n    ray.dir = rayDir;\n\n    // Random seed: incorporate iFrame & fragment coordinate \n    vec2 seed = vec2(fragCoord.x + float(iFrame)*0.5, fragCoord.y - float(iFrame)*0.7);\n\n    // Increase bounce depth for better GI, watch performance\n    int maxDepth = 5;\n    vec3 newSample = tracePath1(ray, seed, maxDepth);\n\n    // Accumulate results over frames\n    // --------------------------------------------------------\n    // Retrieve previous color from feedback buffer (iChannel0).\n    // Make sure iChannel0 is set to \"buffer feedback\" with float32 in Shadertoy settings.\n    vec3 oldColor =texture(iChannel0, fragCoord / iResolution.xy).rgb;\n    oldColor= pow(oldColor, vec3(2.2));//reverse Gamma correct\n    // We do an exponential moving average:\n    // alpha is the blend factor for the new sample vs. old color\n    // you might use e.g. alpha = 1.0 / float(iFrame+1) for uniform accumulation\n    // or pick something smaller for stable accumulation.\n    float alpha =1.0 / float(iFrame + 1);\n    // Alternatively: float alpha = 0.1; // slower accumulation each frame\n\n    vec3 accumulatedColor = mix(oldColor, newSample, alpha);\n\n    // Gamma correct\n    vec3 finalColor = pow(accumulatedColor, vec3(1.0 / 2.2));\n    fragColor=vec4(finalColor,1);\n    \n}","name":"Buffer A","description":"","type":"buffer"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":true,"mFlagMusicStream":false},"info":{"id":"XXtcD4","date":"1735195997","viewed":127,"name":"TestRayTracing FromOpenAI o1 pro","username":"BookSun","description":"This code is from Open AI o1 pro:https://chatgpt.com/share/676bfaa8-23b0-8007-9dce-993cc3b6797b\nThe original code can't be run here.\nI made a few fixes to make it able to run on Shadertoy. But the main framework and algorithms are unchanged.","likes":3,"published":1,"flags":32,"usePreview":0,"tags":["pathtracing","ai"],"hasliked":0,"parentid":"","parentname":""}}