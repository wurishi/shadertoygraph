{"ver":"0.1","info":{"id":"l3yXRc","date":"1720270127","viewed":65,"name":"Checkerboard/UV grid patttern","username":"Dimitar","description":"This is my take on creating an Anti-Aliased checkerboard pattern. Although in a 2D square won't be that useful on the 3D inspector/viewer program I develop its really noticeable and nice.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["checkerboard","gridpattern","uvgird"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// How this grid works:\n/* The approach I took to make this grid was mainly to use the modulo operator/function.\n* First, I scaled the grid and made it range: [0, CHECKERBOARD_SCALE].\n* Using mod(uv, 2), I remapped every value from a range of [0:2].\n* This allowed me to separate the squares into odd and even, or greater than 1 or less than 1.\n* (This is easier to visualize using graphing tools like Graphtoy or Desmos).\n* Now, the only thing left was to color the values greater than 1 with one color and the others with a different color.\n* However, a more careful reader might notice that this won't hold true for both axes.\n* We want to color a square color 'A' when x < 1 and y > 1, or when x > 1 and y < 1.\n\n* (Again, this is easier to understand if you look at a graph. I suggest the Desmos graphing website\n* since it allows you to create functions dependent on both x and y. \n* Here is my graph: https://www.desmos.com/calculator/izfvntclbc. If the link doesn't work, you can just \n* open the website and type y = mod(x,2) and x = mod(y,2))\n\n* Using if statements for per-pixel checks is a big no-no in GLSL, so we can leverage the power of\n* the step, min, and max functions. \n* 'float isCubeWhiteColUpperRight = step(2., step(1., uv.x) + 1. - step(1., uv.y));'\n* What this line does is check if both conditions 'when x > 1 and y < 1' are met.\n* Note that we invert the one for the y, meaning when the step function returns 1, we want the result to be 0.\n* The same is done for the other condition ('when x < 1 and y > 1').\n* After this, we use the max function as a way to mimic the 'or' operator ('||')â€”if one of them is 1, we want to \n* get that one.\n\n* The last part is the anti-aliasing (AA) or smoothing along the edges.\n* The first time I tried smoothstep, but it wasn't\n* promising. The problem is that smoothstep smooths between two values, and I wanted the opposite.\n* I wanted something \n* like a bell curve that starts low, goes to a max, and ends low. This really sounds like a quadratic formula:\n* y = x^2. So I opted to use the quadratic formula; however, one problem I noticed is that it smoothed only\n* on the right side and not the left. This was because our values are in the range [0,2] (from the mod function), \n* and to use the quadratic formula result as a smooth step, I wanted it to reach 1.\n* But when 2 is our max, it goes beyond one and loses the smoothness. The solution for this was to remap\n* the values again, this time to the range [0:1] using the fract function. Now, this didn't fix the issue alone \n* since we have two ([0:1] and [1:2]) squares and now we have only one. I needed to remap them again to be able\n* to mirror the result of the smoothing on both squares. To achieve this, I remapped them to the range [-1:1], \n* and used the abs function to flip the -1 quadrant, meaning the smoothing of [0:1] will hold true/the same for [-1:0].\n* The last thing we have to do is invert the quadratic formula result, since a quadratic formula with a positive\n* a value (y = a*x^2 ...) means that the parabola goes from infinity to 0 and from 0 to infinity. We want\n* it to go from 0 to infinity and from infinity back to zero (we are just flipping it, nothing too complex).\n* We do this for both x and y, and we use the mix function as a union operation for both x AA and y AA. Then\n* we use the mix function again for blending the two colors.\n* Here is the link from graph toy of the smoothing function:\nhttps://graphtoy.com/?f1(x,t)=mod(x,2)&v1=true&f2(x,t)=1%20-%20pow(abs(fract(mod(x,2))*2.%20-1.),16.)&v2=true&f3(x,t)=&v3=false&f4(x,t)=&v4=false&f5(x,t)=&v5=false&f6(x,t)=&v6=false&grid=1&coords=-2.5492230109115135,1.3021103419701718,3.4583232801334027\n\n* First, thanks for reading my explanation. I hope it didn't confuse you.\n* Second, this is not necessarily the best approach; there might be better ones, \n* and there are some bugs with this one too, but I wanted to challenge myself to do it. \n* As always, I would appreciate any feedback and improvements.\n* Have a nice day :).\n*/\n\nfloat CHECKERBOARD_SCALE  = 5.,\n        SMOOTHNESS_FACTOR = 30.;\n\nvec3 GrayCol = vec3(.412),\n    WhiteCol = vec3(1);\n    \nvec3 ModAproach(vec2 uv);\n\n//The FabriceNeyret2 suggested version\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   /* vec2 uv = ( 2.*fragCoord - iResolution.xy ) / iResolution.y\n             * mod(iTime+4.,10.);*/\n    vec2 uv = ( 2.*fragCoord - iResolution.xy ) / iResolution.y;\n    vec2 uv0 = uv;\n    \n    uv = sin(uv*3.14);\n    float v = uv.x*uv.y;\n    v = clamp( .5+.5* v/fwidth(v) ,0.,1. );\n    \n\tfragColor = vec4( mix( GrayCol, WhiteCol, v) , 1 );\n    \n    //fragColor = vec4(ModAproach(uv0),1);\n    \n    fragColor = pow(fragColor,vec4(1./2.2));\n}\nvec3 ModAproach(vec2 uv)\n{\n    \n    const float smoothnessControl = .4;\n    uv *= 3.;\n    uv = abs(mod(uv - vec2(0,1),2.)-1.);   \n     \n    float smoothX = smoothstep(0.5,3./iResolution.y+smoothnessControl,uv.x);\n    float smoothY = smoothstep(0.5,3./iResolution.y+smoothnessControl, uv.y); \n         \n    return mix( GrayCol, WhiteCol,min(smoothX, smoothY));\n\n}\n//The original version of the shader.\nvec3 PreviousVersion(in vec2 uv)\n{\n    \n    vec3 FinalColor = vec3(0.0);\n\n\tfloat isCubeWhiteColUpperRight = step(2.,step(1.,uv.x)+1. - step(1.,uv.y));\n\n\tfloat isCubeWhiteColLowerLeft = step(2.,1. - step(1.,uv.x) + step(1.,uv.y));\n\n\tfloat isCubeWhiteCol = max(isCubeWhiteColUpperRight, isCubeWhiteColLowerLeft);\n\t\n\tfloat mixFactor = isCubeWhiteCol*min(\n    (1. - pow(abs(fract(uv.x)*2. -1.),SMOOTHNESS_FACTOR)),\n\t(1. - pow(abs(fract(uv.y)*2. -1.),SMOOTHNESS_FACTOR)));\n\n\tFinalColor = mix(WhiteCol,GrayCol,mixFactor);\n    \n    return FinalColor;\n}\n\n","name":"Image","description":"","type":"image"}]}