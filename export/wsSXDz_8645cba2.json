{"ver":"0.1","info":{"id":"wsSXDz","date":"1553438625","viewed":217,"name":"Colorful Tiles","username":"OliverSchaff","description":"I tried to reproduce the look of this shader: https://www.shadertoy.com/view/lssGR7","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["warp","valuenoise","tiles"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.1415927\n#define numOfTilesY 5.0\n\n// Hash without Sine\n// Creative Commons Attribution-ShareAlike 4.0 International Public License\n// Created by David Hoskins.\n// https://www.shadertoy.com/view/4djSRW\n#define HASHSCALE3 vec3(.1031, .1030, .0973)\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * HASHSCALE3);\n    p3 += dot(p3, p3.yzx+19.19);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n// Value Noise by Inigo Quilez - iq/2013\n// https://www.shadertoy.com/view/lsf3WH\nfloat vnoise(vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    vec2 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( dot( hash22(i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ),\n                     dot( hash22(i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\n                mix( dot( hash22(i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ),\n                     dot( hash22(i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);\n}\n\nvec3 hsvToRgb(float h, float s, float v) \n{\n    return v* (1. + s * ( cos(2.*PI * (h + vec3(3,2,1)/3.) ) - .5));\n}\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 R = iResolution.xy,\n    // prepare uv to be tiled later\n        uv = numOfTilesY * U/R.y;\n\t\n    // aa is for antialiasing\n    // noise adds a distortion to the uv plane\n    float aa = numOfTilesY * 1.5 / min(R.x, R.y),\n       noise = 2.*PI* vnoise(.5*uv + .05*iTime);\n    // add noise \n    uv += .15 * vec2(cos(noise), sin(noise));\n    \n    // tile the uv plane\n    // fuv is the coordinate within each tile\n    // iuv is the index of the tile\n    // cshift is used for shifting the color effects, depending on tile index\n    // c is the white grid\n    vec2 fuv = fract(uv) - .5,\n         iuv = floor(uv),\n      cshift = .1*hash22(iuv*10.),\n           c = smoothstep( .48-aa, .51, abs(fuv) );\n    \n    // the effect looks better when applied after a 45° rotation\n    // rotate the fuv plane of each tile by 45°\n    fuv *= mat2(1,1,-1,1)/sqrt(2.);\n    \n    // time is distorted with the position within the tile\n    // this adds the curvature on the colored segments\n    // h,s,v are hue saturation and value of the color in the tile\n    // first h,s,v are set to values that depend on position and time\n    float time = -.2*iTime + 2.*length(fuv),\n          h = length(2.*fuv.x+cshift) + length(2.*fuv.y)        + time,\n          s = length(2.*fuv.x)        + length(1.*fuv.y+cshift) + 2.*time,\n          v = length(1.*fuv.x-cshift) + length(1.*fuv.y+cshift) + time;\n\n    // generate a color based on the value-noise of the h,s,v values defined above\n    // plus vary the hue with time\n    // then add the white grid that was defined above\n    O.rgb = hsvToRgb( 2.*vnoise(.6*h+5.*iuv) +sin(.5*iTime),\n                      3.*vnoise(.4*s+3.*iuv) +.2,\n                      2.*vnoise(   v+   iuv) +.6)\n            + c.x + c.y;\n}","name":"Image","description":"","type":"image"}]}