{"ver":"0.1","info":{"id":"wd3XRl","date":"1572585317","viewed":92,"name":"Training 02 (Copo)","username":"coposuke","description":"Training 2","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["training"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nfloat sdBox(vec3 pos, vec3 size)\n{\n    vec3 diff = abs(pos) - size;\n    return length(max(diff, 0.0)) + min(max(diff.x, max(diff.y, diff.z)), 0.0);\n}\n\nfloat sdOctahedron( vec3 p, float s)\n{\n  \tp = abs(p);\n  \treturn (p.x+p.y+p.z-s)*0.57735027;\n}\n\nfloat map(in vec3 rayPos, in vec3 rayDir)\n{\n    // distance at current grid.\n    vec3 currentLocalPos = fract(rayPos);\n    vec3 currentGrid = floor(rayPos);\n    float currentHash = step(fbm(currentGrid * 0.1), 0.35);\n\n    // jitter position\n    float balance = sin(rayPos.z * 0.1) * 0.5 + 0.5;\n    vec3 seed = vec3(int(currentGrid.x), int(currentGrid.y), int(currentGrid.z));\n    vec3 randPos = vec3(rand(seed.xz), rand(seed.zy), rand(seed.zx)) * balance;\n\n    // object distance.\n    vec3 objBaseRayPos = abs(currentLocalPos - randPos * 0.25) - 0.5;\n    objBaseRayPos = objBaseRayPos * rotate(hash(seed.x) * PI * balance, normalize(randPos));\n    float objDistance = mix(sdBox(objBaseRayPos, vec3(0.225)), sdOctahedron(objBaseRayPos, 0.25), balance);\n\n    // distance to next grid.\n    float nextLength = 0.0;\n    vec3 nextOver = fract(rayPos + rayDir);\n    vec3 nextCross = 1.0 - nextOver;\n    nextCross = mix(nextCross, 1.0 - nextCross, step(sign(rayDir), vec3(0.0)));\n\n    vec3 nextCrossLength = abs(nextCross / rayDir);\n\tnextLength = min(nextCrossLength.x, min(nextCrossLength.y, nextCrossLength.z));\n    nextLength = clamp(nextLength, 0.0, 1.0);\n    nextLength += 1e-4;\n\n    // if currentzis blank, then advance to next grid.\n    return currentHash <= 0.0 ? nextLength : objDistance;\n}\n\nvec4 raymarch(in vec3 camPos, in vec3 camRay)\n{\n    float dist = 0.0;\n    vec3 rayPos = camPos;\n    float hit = 0.0;\n    \n    for(int i=0 ; i<200; ++i)\n    {\n        rayPos += camRay * dist;\n        dist = map(rayPos, camRay);  \n        \n        if(dist < 1e-4)\n        {\n            hit = 1.0;\n            break;\n        }\n    }\n    \n\treturn vec4(rayPos, hit);\n}\n\nvec3 computeNormal(in vec3 pos, in vec3 dir)\n{\n    const float EPSILON = 1.0e-4;\n    return normalize(vec3(\n        map(vec3(pos.x + EPSILON, pos.y, pos.z), dir) - map(vec3(pos.x - EPSILON, pos.y, pos.z), dir),\n        map(vec3(pos.x, pos.y + EPSILON, pos.z), dir) - map(vec3(pos.x, pos.y - EPSILON, pos.z), dir),\n        map(vec3(pos.x, pos.y, pos.z + EPSILON), dir) - map(vec3(pos.x, pos.y, pos.z - EPSILON), dir)\n    ));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n\t\n    vec3 camPos = vec3(sin(iTime * 0.5) * 10.0, 0.0, fract(iTime * 0.01) * 1000.0); // float precision.\n    mat3 camMat = rotate(-cos(iTime * 0.5) * 0.5, vec3(0,0,1));\n    float camLength = 2.0;\n    vec3 camRay = camMat * normalize(vec3(uv, camLength));\n    \n    vec4 result = raymarch(camPos, camRay);\n    vec3 resPos = result.xyz;\n    vec3 resNormal = computeNormal(resPos - camRay * 1e-4, camRay);\n    float resDistance = distance(camPos, resPos);\n    vec3 diffuse = vec3(1) * result.w * (1.0 - clamp(resDistance / 100.0, 0.0, 1.0));\n    \n    vec3 lightDir = normalize(-vec3(0.5,-1,0.8));\n    float light = clamp(dot(lightDir, resNormal), 0.3, 1.0);\n    \n    fragColor = vec4(diffuse * light, 1);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define PI      3.14159265357989\n#define PI_2    6.28318530715978\n#define PI_HALF 1.57079632678994\nconst mat3 m = mat3(0.00, 1.60, 1.20, -1.60, 0.72, -0.96, -1.20, -0.96, 1.28);\n\n\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat hash( float n )\n{\n    return fract(sin(n)*43758.5453);\n}\n\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\n    f = f*f*(3.0-2.0*f);\n\n    float n = p.x + p.y*57.0 + 113.0*p.z;\n\n    float res = mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                        mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\n                    mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                        mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\n    return res;\n}\n\nfloat fbm( vec3 p )\n{\n    float f;\n    f  = 0.5000*noise( p ); p = m*p*2.02;\n    f += 0.2500*noise( p ); p = m*p*2.03;\n    f += 0.12500*noise( p ); p = m*p*2.01;\n    f += 0.06250*noise( p );\n    return f;\n}\n\nmat3 rotate(float angle, vec3 axis)\n{\n    vec3 a = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float r = 1.0 - c;\n    mat3 m = mat3(\n        a.x * a.x * r + c,\n        a.y * a.x * r + a.z * s,\n        a.z * a.x * r - a.y * s,\n        a.x * a.y * r - a.z * s,\n        a.y * a.y * r + c,\n        a.z * a.y * r + a.x * s,\n        a.x * a.z * r + a.y * s,\n        a.y * a.z * r - a.x * s,\n        a.z * a.z * r + c\n    );\n    return m;\n}\n","name":"Common","description":"","type":"common"}]}