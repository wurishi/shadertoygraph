{"ver":"0.1","info":{"id":"7lscW7","date":"1648139250","viewed":39,"name":"PIZZA TIME","username":"Aurore_B","description":"Bon app√©tit!","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["atipartiel"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float Union(float d1, float d2){ return min(d1,d2); }\nfloat Sub(float d1, float d2){ return max(-d1,d2);}\n\nfloat SUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\nmat2 rot(float a){\n     float c = cos(a) , s = sin(a);\n     return mat2(c,-s, s, c);\n}\n\nvec3 palette( float t, vec3 a, vec3 b, vec3 c, vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nvec2 opU2(vec2 d1, vec2 d2){\n    return (d1.x < d2.x) ? d1 : d2;\n}\n\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat sdCappedCylinder( vec3 p, float h, float r )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nvec2 map(vec3 pos){\n    float t = iTime;\n    //torus\n    //gestion de la rotation\n    pos.yz *= rot(3.14/2.);\n    \n    //rotation sur elle meme\n    pos.xz *= rot(3.14/1.9 + t*0.45);\n    \n    //CROUTE\n    vec2 torus = vec2(sdTorus(vec3(pos.x, pos.yz), vec2(0.9,0.08)),0.0);\n    vec2 c =  torus;\n    \n    //PATE\n    vec2 base = vec2(sdCappedCylinder(pos+vec3(0.,-.1,0.), 0.9,0.01),1.0);\n    c = opU2(base, c);\n    \n    //PEPPERONI    \n     float fac1 = 3.;\n     float fac2 = 1.6; //1.6\n     float fac3 = 1.4; //1.4\n     float fac4 = 1.8; //1.7\n\n     c = opU2(vec2(sdCappedCylinder(pos+vec3(0.,.03+max(sin(t*2.)/fac2,0.0),-0.52), 0.1,0.01),2.0), c);\n     c = opU2(vec2(sdCappedCylinder(pos+vec3(0.36,.03+max(sin(t*2.)/fac4,0.),0.0), 0.11,0.01),2.0), c);\n     c = opU2(vec2(sdCappedCylinder(pos+vec3(-0.2,.03+max(sin(t*2.)/fac3,0.),0.42), 0.1,0.01),2.0), c);\n     c = opU2(vec2(sdCappedCylinder(pos+vec3(-0.3,.03+max(sin(t*2.)/fac2,0.),-0.27), 0.12,0.01),2.0), c);\n     c = opU2(vec2(sdCappedCylinder(pos+vec3(0.0,.03+max(sin(t*2.)/fac4,0.),0.06), 0.09,0.01),2.0), c);\n     \n     c = opU2(vec2(sdCappedCylinder(pos+vec3(0.4,.03+max(sin(t*2.)/fac3,0.),-0.36), 0.06,0.01),2.0), c);\n     c = opU2(vec2(sdCappedCylinder(pos+vec3(-0.51,.03+max(sin(t*2.)/fac3,0.),0.13), 0.07,0.01),2.0), c);\n     c = opU2(vec2(sdCappedCylinder(pos+vec3(0.32,.03+max(sin(t*2.)/fac2,0.),0.46), 0.075,0.01),2.0), c);\n     \n\n     \n     float savex = pos.x;\n     float savey = pos.y;\n     float savez = pos.z;\n     //FROMAGE POUR JOJONATHAN\n     pos.x += sin(pos.z*13.)/15.;\n     pos.z += sin(savex*13.)/16.;\n     vec2 from = vec2(sdCappedCylinder(pos+vec3(0.0,.01+ max(sin(t*2.)/fac1,0.),.0), 0.7,0.00001),3.);\n     //from *= sin(t).xy;\n     \n     c = opU2(from, c);\n     pos = vec3(savex, savey,savez);\n        \n    return c;\n    \n}\n\n\nvec3 GetNormal(vec3 pos){\n    float v = map(pos).x;\n    vec2 e = vec2(.001,.0);\n    return normalize(vec3( map(pos+e.xyy).x, map(pos+e.yxy).x, map(pos+e.yyx).x) - v);\n}\n\n\n//ro = rayon origine et rd = rayon direction\nvec2 CastRay( vec3 ro, vec3 rd){\n    \n    float contact = .0;\n    \n    for(int i= 0; i < 64; i++){\n        \n        vec2 ray = map(ro+ rd * contact);\n        \n        if(ray.x<(0.00001*contact))\n        {\n            return vec2(contact, ray.y);\n        }\n        contact += ray.x;\n    }\n    \n    return vec2(-1.,0.);\n}\n\nvec3 render(vec3 ro, vec3 rd){\n    \n    vec2 contact = CastRay(ro, rd);\n    vec3 nor = GetNormal(ro + rd * contact.x);\n    \n    \n    vec3 lightDir = vec3(1.,1.0,1.);\n    \n    float lambert = dot(nor, lightDir);\n    \n    \n    vec3 col = vec3(0.0);\n    \n    if (contact.x == -1.)\n    {\n        col = vec3(0.,0.6,0.75);\n    }\n    else\n    {\n            \n        if (contact.y == 0.)\n        {\n            col = vec3(0.859,0.635,0.29);\n        }\n        else\n        {\n\n             if (contact.y == 1.)\n            {\n                col = vec3(0.882,0.137,0.04);\n            }\n            else\n            {\n                 if (contact.y == 2.)\n                {\n                    col = vec3(0.808,0.,0.);\n                }\n                else\n                {\n                    col = vec3(1.0,0.98,0.541);\n                }\n            \n            \n            }\n           \n        }\n        \n    float toon = step(lambert,.2);\n    col *= (1.-toon)*.5+0.5;\n\n    }\n    return col;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized and centred pixel coordinates (from 0 to 1)\n    vec2 uv =2.*fragCoord/iResolution.xy-1.;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    float t = iTime;\n    \n    //cam ou elle est et ou elle regarde (ici le centre)\n    \n    //CAM PAS ANIM\n    vec3 cameraPos =  vec3(0.8,-2.8,1.6);\n    //CAM ANIM\n    //vec3 cameraPos =  vec3(0.9*cos(t)-2.*sin(t),-0.9*sin(t)-2.*cos(t),2.);\n    \n    vec3 cameraTar = vec3(0.,0.1,0.);\n    \n    //ligne directive\n    vec3 forward = normalize(cameraTar - cameraPos);\n    \n    //cross = prend la perpendiculaire\n    vec3 right = normalize(cross(vec3(0.0,-1.,0.0), forward));\n    vec3 up =  normalize(cross(right, forward));\n    vec3 viewDir = normalize(uv.x * right + uv.y * up + 2.*forward);\n    \n    \n    vec3 c = render(cameraPos, viewDir);\n\n    // Output to screen\n    fragColor = vec4(c,1.);\n}\n","name":"Image","description":"","type":"image"}]}