{"ver":"0.1","info":{"id":"XXfGWf","date":"1708062165","viewed":168,"name":"June's Normal Sphere","username":"jyn","description":"Still working on this. Click to tweak the light. Study project and texture sandbox. It's a normal mapped sphere with generated textures, lighting, and shadows. Trying to practice the basics and build up the look.","likes":8,"published":1,"flags":32,"usePreview":0,"tags":["sphere","planet","textured"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/* June's Normal Sphere\n** ======================\n*** Buffers A and B create the textures.\n*** A: rgb (albedo) a (water mask),\n*** B: rg (normal) b (roughness) a (height, unused),\n*** and the main function here uses them to shade a sphere.\n*** (the shading isn't actually PBR, but I like it.)\n*** todo: clouds, maybe, parallax occlusion,\n***       albedo is weird, improve light position calculation\n*** 24 02 16 edit:\n        fixed tiling; shading better thanks to spalmer\n        major fixes to shadow implementation (negative normal)\n        simplify textures, fix mouse vector, visual tweaks\n*/\n\n#define DEBUG_VIEW\n//#define VIEW_TILING\n\n// This creates an anti-aliased circular coverage mask.\n// see LadyHavoc's original: https://www.shadertoy.com/view/M3fGDB\nfloat LHCircle(vec2 fragCoord) {\n    float radius = iResolution.y * 0.5;\n    vec2 center = iResolution.xy * 0.5;\n    vec2 pos = floor(fragCoord + vec2(0.5));\n    vec2 rel = (pos - center);\n    float v = (1.0 + radius - dot(rel, rel) / radius);\n    return clamp(v * 0.5, 0.0, 1.0);\n}\n\n// Reoriented Normal Mapping Blending\n// see https://www.shadertoy.com/view/4t2SzR\nvec3 normalBlend(vec3 n1, vec3 n2)\n{\n\tn1 = n1 * vec3( 2,  2, 2) + vec3(-1, -1,  0);\n    n2 = n2 * vec3(-2, -2, 2) + vec3( 1,  1, -1);\n    return n1 * dot(n1, n2) / n1.z - n2;\n}\n\n// This is used to rotate UV spaces.\nvec2 rotate(vec2 v, float a) {\n\tfloat s = sin(a);\n\tfloat c = cos(a);\n\tmat2 m = mat2(c, s, -s, c);\n\treturn m * v;\n}\n\n// This generates a grid.\n// See Pristine Grid by bgolus. https://www.shadertoy.com/view/mdVfWw\nfloat pristineGrid( in vec2 uv, vec2 lineWidth)\n{\n    vec2 ddx = dFdx(uv);\n    vec2 ddy = dFdy(uv);\n    vec2 uvDeriv = vec2(length(vec2(ddx.x, ddy.x)), length(vec2(ddx.y, ddy.y)));\n    bvec2 invertLine = bvec2(lineWidth.x > 0.5, lineWidth.y > 0.5);\n    vec2 targetWidth = vec2(\n      invertLine.x ? 1.0 - lineWidth.x : lineWidth.x,\n      invertLine.y ? 1.0 - lineWidth.y : lineWidth.y\n      );\n    vec2 drawWidth = clamp(targetWidth, uvDeriv, vec2(0.5));\n    vec2 lineAA = uvDeriv * 1.5;\n    vec2 gridUV = abs(fract(uv) * 2.0 - 1.0);\n    gridUV.x = invertLine.x ? gridUV.x : 1.0 - gridUV.x;\n    gridUV.y = invertLine.y ? gridUV.y : 1.0 - gridUV.y;\n    vec2 grid2 = smoothstep(drawWidth + lineAA, drawWidth - lineAA, gridUV);\n\n    grid2 *= clamp(targetWidth / drawWidth, 0.0, 1.0);\n    grid2 = mix(grid2, targetWidth, clamp(uvDeriv * 2.0 - 1.0, 0.0, 1.0));\n    grid2.x = invertLine.x ? 1.0 - grid2.x : grid2.x;\n    grid2.y = invertLine.y ? 1.0 - grid2.y : grid2.y;\n    \n    return mix(grid2.x, 1.0, grid2.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time = iTime * 0.5;\n    \n    // mask between sphere and background\n    float mask = LHCircle(fragCoord);\n    \n    // creates the normals of a sphere in the center of the screen.\n    // referencing Zavie's beautiful https://www.shadertoy.com/view/XsfXDr\n    float ratio = iResolution.x / iResolution.y;\n\tvec2 uv = vec2(ratio, 1.0) * (2.0 * fragCoord.xy / iResolution.xy - 1.0);\n    vec3 n = vec3(uv, sqrt(1.0 - clamp(dot(uv, uv), 0.0, 1.0)));\n    vec3 sphere = n;\n    \n    /* spherical mapping, referencing this paper\n    *** https://people.computing.clemson.edu/~dhouse/courses/405/notes/texture-maps.pdf\n    *** formulas listed therein for posterity:\n    \n        θ = tan−1(−z/x)\n            θ = atan2(-(z - cz ), x - cx);\n            u = (θ + π) / 2 π;\n        φ = cos−1(−y/r)\n            φ = acos(-(y - cy ) / r);\n            v = φ / π;\n            \n    *** below, zeroes retained for clarity\n    */\n    \n    #define PI 3.1415926535897932385\n    #define TAU 2.0 * PI\n    float nx = n.x;\n    float ny = n.y;\n    float nz = n.z;\n    float c = 0.0;\n    float r = 1.0;\n    \n    float theta = atan((c - nx), -(nz - c));\n    float u = (theta + PI) / (2.0 * PI);\n    float phi = acos(-((ny - c) / r));\n    float v = phi / PI;\n    \n    vec2 tex_uv = vec2(u + time * 0.05, v - 0.5 * abs(cos(time * 0.15)));\n    vec3 albedo_sample = texture(iChannel0, tex_uv).rgb;\n    vec3 normal_sample = texture(iChannel1, tex_uv).rgb;\n    float roughness_sample = normal_sample.b;\n    normal_sample.b = sqrt(1.0 - pow(normal_sample.r, 2.0) - pow(normal_sample.g, 2.0)); // reconstruct blue channel\n    //normal_sample = srgbToLinear(normal_sample);\n    \n    \n    // calculate basic lighting. mouse input changes orbit center around the subject.\n    vec2 center = (iMouse.xy / iResolution.xy) - (iResolution.xy / 2.0) / iResolution.xy;\n    float light_max_dist = 12.0;\n    //float light_z = 12.0;\n    float light_z = -12.0 * sin(fract(center.x + 0.75) * TAU) * 0.25 + 0.25;\n    vec3 light_pos = normalize(vec3(\n        center.x * light_max_dist,\n        center.y * light_max_dist * 2.0,\n        light_z));\n    light_pos = normalize(light_pos);\n    \n    n = n * 0.5 + 0.5;\n    //n = srgbToLinear(n);\n    //n = linearToSrgb(n);\n    \n    normal_sample = normal_sample * 0.5 + 0.5;\n    //normal_sample = srgbToLinear(normal_sample);\n    //normal_sample = linearToSrgb(normal_sample);\n    \n    vec3 normal = normalBlend(n, normal_sample);\n    //normal = normal * 0.5 + 0.5;\n    \n    /* Lighting\n    *** the lights produce fill and specular highlights.\n    */\n    \n    // Simple lighting calculations.\n    // adapted from robobo1221's https://www.shadertoy.com/view/MsBcRK\n    \n    // sun, backlighting, and ambient lighting\n    float light_intensity = 1.0;\n    vec3 albedo = albedo_sample;\n    vec3 light_color = vec3(0.600,0.757,0.945);\n\t\n    // clamping dot(normal, light) to discard normals opposing the light\n    float sun_ndl = clamp(dot(normal, light_pos), 0.0, 1.0);\n    vec3 sun = light_color * sun_ndl;\n    sun = clamp(sun, 0.0, 1.0);\n    \n    //vec3 lighting = mix(albedo, albedo * combined_light, 1.0 - combined_light);\n    //vec3 lighting = clamp(sun, 0.0, 1.0);\n    //lighting = combined_light;\n    \n    //lighting = clamp(sun, 0.0, 1.0);\n    //lighting = backlight;\n    \n    \n    \n    /* Fake specular highlight\n    *** see http://learnwebgl.brown37.net/09_lights/lights_specular.html\n    ***\n        R = N + P\n        R = n*dot_product(n,-L) + (L + N)\n        R = n*dot_product(n,-L) + (L + n*dot_product(n,-L))\n        R = 2*n*dot_product(n,-L) + L\n    */\n    \n    // imaginary spherical coordinates\n    vec3 surface_pos = -normal * 2.0;\n\n    // causes interference that makes the waves interesting\n    float specular_intensity = (1.0 - roughness_sample);\n    float shininess = 30.0 * specular_intensity;\n    \n    vec3 to_light;\n    vec3 vertex_normal;\n    vec3 reflection;\n    vec3 to_camera;\n    float cos_angle;\n    vec3 specular;\n\n    // Calculate a vector from the fragment location to the light source\n    to_light = light_pos - surface_pos;\n    to_light = normalize( to_light );\n\n    // The vertex's normal vector is being interpolated across the primitive\n    // which can make it un-normalized. So normalize the vertex's normal vector.\n    vertex_normal = normalize( normal );\n\n    // Calculate the reflection vector\n    float ref_ndl = dot(vertex_normal, to_light);\n    reflection = 2.0 * ref_ndl * vertex_normal - to_light;\n\n    // Calculate a vector from the fragment location to the camera.\n    // The camera is at the origin, so negating the vertex location gives the vector\n    to_camera = -1.0 * surface_pos + vec3(0.0, 0.0, 2.0);\n\n    // Calculate the cosine of the angle between the reflection vector\n    // and the vector going to the camera.\n    reflection = normalize( reflection );\n    to_camera = normalize( to_camera );\n    cos_angle = dot(reflection, to_camera);\n    cos_angle = clamp(cos_angle, 0.0, 1.0);\n    cos_angle = pow(cos_angle, shininess);\n\n    // If this fragment gets a specular reflection, use the light's color,\n    // otherwise use the objects's color\n    specular = light_color * cos_angle * specular_intensity;\n    //object_color = lighting * albedo;\n    \n    // rim lighting via fresnel\n    vec3 view = vec3(0.0, 0.0, 1.0);\n    float fresnel_power = 4.0;\n\tfloat fresnel = pow((1.0 - clamp(dot(normalize(normal), normalize(view)), 0.0, 1.0)), fresnel_power);\n    vec3 rim = vec3(fresnel) * pow(sun, vec3(1.2));\n    \n    //lighting = clamp(specular_color + rim + lighting, 0.0, 1.0);\n    \n    \n    \n    /* Normal Map Shadows\n    *** adapted from https://www.shadertoy.com/view/7lBBR3\n    *** and http://enbdev.com/NormalMappingShadows.pdf\n    */\n    \n    #define iSampleCount\t\t\t4\n    #define SampleCount\t\t\t\t(float(iSampleCount))\n    #define HeightScale\t\t\t\t2.0\n    #define ShadowHardness\t\t\t0.8\n    #define ShadowLength\t\t\t0.8\n    \n    float samplecount = SampleCount;\n\tfloat invsamplecount = 1.0 / samplecount;\n\tfloat hardness = HeightScale * ShadowHardness;\n    float st = invsamplecount * ShadowLength;\n\tvec2 dir = light_pos.xy * HeightScale;\n\n\t// randomization\n\tvec2 noise = fract(fragCoord.xy * 0.5);\n\tnoise.x = (noise.x*0.5 + noise.y)*(1.0/1.5 - 0.25);\n    \n\tfloat pos = st * noise.x;\n\tfloat slope = -sun.r;\n\tfloat maxslope = 0.0;\n\tfloat shadow = 0.0;\n    vec3 screen_normal = -normal * 0.5 + 0.5;\n\tfor (int i=0; i<iSampleCount; i++)\n\t{\n\t\tvec3 tmpNormal = screen_normal;\n\t\ttmpNormal = tmpNormal * 2.0 - 1.0;\n\n\t\tfloat tmpLighting = dot(light_pos, tmpNormal);\n\n\t\tfloat shadowed = -tmpLighting;\n\n\t\tslope += shadowed;\n\n\t\tif (slope > 0.0) //cheap, but not correct, suitable for hard shadow with early exit\n\t\t{\n\t\t\tshadow += hardness * (1.0-pos);\n\t\t}\n\t\tmaxslope = max(maxslope, slope);\n\n\t\tpos += st;\n\t}\n\tshadow = clamp(1.0 - shadow * invsamplecount, 0.0, 1.0);\n    \n    \n    \n    /* ~ the display option zone ~\n    ***\n    *** lines to tweak in order to preview\n    *** different textures in different states.\n    */\n    \n    float bkl_ndl = clamp(dot(-normal, light_pos), 0.0, 1.0);\n    vec3 bkl_color = vec3(0.929,0.200,0.231) * (0.2 + abs(sin(time)));\n    vec3 backlight = bkl_color * bkl_ndl;\n    \n    //backlight = pow(backlight, vec3(2.0));\n    specular = pow(specular, vec3(0.1));\n    vec3 lighting = (\n           1.0 * sun\n         + 1.8 * backlight\n         + 2.0 * rim\n         + 1.5 * specular)\n        * 1.0\n        - shadow * 0.8;\n        \n    sphere = albedo * lighting;\n    //sphere = specular;\n    \n    // for below; which normal to show; neither? blended\n    //normal = n;\n    //normal = normal_sample;\n    \n    // show normal\n    //sphere = linearToSrgb(normalize(normal));\n    \n    \n    /*\n    *** end option zone\n    */\n    \n    \n    \n#ifdef DEBUG_VIEW\n    /** Previews of textures with some aesthetic enhancements to the scene.\n    */\n\n    // bg grid\n    float bg_value = 0.4;\n    vec2 m = 0.1 * (iMouse.xy / iResolution.y);\n    time = iTime * 0.1;\n    float zoomrate = 0.5;\n    vec2 grid_uv = uv * 0.5;\n    float rot_a = time * 0.1;\n    grid_uv = rotate(grid_uv, rot_a);\n    grid_uv -= rotate(vec2(zoomrate, zoomrate * 0.5), rot_a);\n    grid_uv += rotate(m + vec2(-0.25, -0.5), rot_a);\n    float grid1 = pristineGrid(grid_uv * 4., vec2(0.01));\n    float grid2 = pristineGrid(grid_uv / 1., vec2(0.02));\n    float grid = grid1 + grid2 + bg_value;\n    float dot_c = 4.0;\n    vec2 dot_uv = grid_uv + vec2(0.05);\n    float dotted = max(0.2, min(0.8, fract(dot_uv.x * dot_c) + fract(dot_uv.y * dot_c)));\n    dotted = smoothstep(0.445, 0.6, dotted);\n    dotted = clamp(pow(dotted, 0.01), bg_value, 1.0);\n    float center_fade = pow(distance(uv, vec2(0.0)) * 0.5, 1.5);\n    grid *= dotted * center_fade;\n    \n    // gather texture previews for background\n    vec2 tex_slice_uv = fragCoord / iChannelResolution[0].xy;\n    vec4 alb_rough = texture(iChannel0, tex_slice_uv);\n    vec3 albedo_tex = alb_rough.rgb;\n    vec3 normal_tex = texture(iChannel1, tex_slice_uv).rgb;\n    normal_tex = linearToSrgb(normal_tex);\n    uv = fragCoord.xy / iResolution.xy;\n    float cut = uv.x + uv.y * 0.1;\n    vec3 sheets =\n        cut < 0.12\n                ? (cut < 0.07\n                    ? normal_tex : albedo_tex)\n                : vec3(grid * 0.7, grid * 0.5, grid * 0.5);\n\n    \n    vec3 composite = mask > 0.0 ? mix(sphere, sheets, 1.0 - mask) : mix(sheets, sphere, mask);\n    fragColor = vec4(composite, 1);\n#else\n    fragColor = vec4(sphere * mask, 1);\n#endif\n\n#ifdef VIEW_TILING\n    fragColor = texture(iChannel0, (fragCoord.xy / iChannelResolution[0].xy) * 2.0);\n#endif\n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// tiling albedo with roughness on alpha\n\nvec3 sharpSample(int step_fc, sampler2D tex, vec2 uv, vec2 screen)\n{\n    // sharpen texture, referencing https://www.shadertoy.com/view/lslGRr\n    vec2 st = float(step_fc) / screen;\n\tvec3 texA = texture( tex, uv + vec2(-st.x, -st.y) * 1.5 ).rgb;\n\tvec3 texB = texture( tex, uv + vec2( st.x, -st.y) * 1.5 ).rgb;\n\tvec3 texC = texture( tex, uv + vec2(-st.x,  st.y) * 1.5 ).rgb;\n\tvec3 texD = texture( tex, uv + vec2( st.x,  st.y) * 1.5 ).rgb;\n    vec3 around = 0.25 * (texA + texB + texC + texD);\n\tvec3 center  = texture( tex, uv ).rgb;\n\tfloat sharpness = 1.0;\n\treturn center + (center - around) * sharpness;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 screen = iResolution.xy;\n    vec2 uv = fragCoord / screen;\n    float time = iTime * 0.1;\n    //time = 100.0;\n    \n    // multiple samples to blend edges for tiling\n    int sharpen_step = 1;\n    vec2 primary_scale = vec2(1.0, 1.0);\n    vec2 blend_uv = uv * primary_scale + vec2(0.0, -uv.x * primary_scale);\n    vec3 albedo = sharpSample(sharpen_step, iChannel0, blend_uv, screen).rrr;\n    blend_uv = vec2(\n          ((iChannelResolution[0].x - blend_uv.x * iChannelResolution[0].x)\n             / iChannelResolution[0].x\n           ),\n            blend_uv.y\n        );\n    albedo += sharpSample(sharpen_step, iChannel0, blend_uv, screen).rrr;\n    blend_uv = vec2(blend_uv.x, 1.0 + blend_uv.y);\n    blend_uv = vec2(\n            blend_uv.x,\n          ((iChannelResolution[0].y - blend_uv.y * iChannelResolution[0].y)\n             / iChannelResolution[0].y\n           )\n        );\n    albedo += albedo + (sharpSample(sharpen_step, iChannel0, blend_uv, screen).rrr - albedo);\n    albedo /= 4.0; // intentional; keeps rising sealevel from clipping mountaintops\n    albedo = pow(albedo, vec3(1.2));\n    \n    // detail texture (mostly noticeable on peaks)\n    //albedo += -0.1 * albedo * texture(iChannel0, uv * primary_scale * 64.0).rgb;\n    \n    // rebalance shades\n    albedo = vec3(\n        albedo.r * 1.0,\n        albedo.g * 0.88,\n        albedo.b * 0.95\n    );\n    \n    // raising the min looks like puddles. hence forests and oceans.\n    float wave_amount = 1.0;\n    float wave_speed = 2.0;\n    float wave_anim = abs(sin(time * wave_speed) * 0.25);\n    float sealevel = wave_anim;\n    //sealevel = clamp(sealevel, 0.0, 1.0);\n    \n    float forest_mask = smoothstep(sealevel, sealevel + 0.1, albedo.r);\n    float shore_mask = smoothstep(sealevel, sealevel + 0.15, albedo.r);\n    float ocean_mask = smoothstep(sealevel - 0.05, sealevel + 0.1, albedo.r);\n    vec3 ocean_color = vec3(0.600,0.757,0.945);\n    \n    // detail texture for blending\n    sharpen_step = 1;\n    wave_anim *= 1.0 - ocean_mask;\n    //wave_anim += abs(sin(time * wave_speed));\n    vec2 detail_scale = vec2(0.5, 0.5);\n    blend_uv = detail_scale * -uv + wave_anim;\n    vec3 detail = sharpSample(sharpen_step, iChannel0, blend_uv * 2.0, screen).rgb;\n    blend_uv = detail_scale * vec2(1.0 - uv.x, uv.y) + -wave_anim;\n    detail += sharpSample(sharpen_step, iChannel0, blend_uv * 2.0, screen).rgb;\n    blend_uv = detail_scale * -vec2(uv.x, 1.0 - uv.y) + -wave_anim;\n    detail += sharpSample(sharpen_step, iChannel0, blend_uv * 2.0, screen).rgb;\n    detail /= 3.0;\n    detail = vec3(\n        detail.r * 0.4,\n        detail.r * 0.9,\n        detail.r * 0.6\n    );\n    detail *= 1.0;\n    \n    // detail's detail texture (mostly noticeable in valleys)\n    //detail += (0.35 - detail) * sharpSample(2, iChannel0, uv * primary_scale * 32.0).rgb;\n    \n    \n    float detail_average = (detail.r + detail.g + detail.b) / 3.0;\n    albedo = mix(detail, albedo, forest_mask * pow(albedo, vec3(0.1)));\n    albedo = mix(albedo + sealevel, ocean_color * detail_average, clamp(1.0 - ocean_mask * shore_mask, 0.0, 1.0));\n    \n    // levels adjustment\n    //albedo = pow(albedo, vec3(0.4));\n    //albedo = clamp(albedo, 0.0, 1.0);\n    \n    // send it on\n    fragColor = vec4(albedo, ocean_mask);\n}\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// albedo to normal map conversion\n// adapted from https://www.shadertoy.com/view/MsScRt\n\nfloat getHeight(sampler2D tex, vec2 uv) {\n    vec3 c = texture(tex, uv).rgb;\n    c = srgbToLinear(c);\n    float average = clamp((c.r + c.g + c.b) / 3.0, 0.0, 1.0);\n    return average;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float scale = 0.7;\n    vec2 resolution = iChannelResolution[0].xy;\n    vec2 uv = fragCoord / resolution;\n    \n    vec2 st = 1.5 / resolution; // step\n    float height = getHeight(iChannel0, uv);\n\n    vec2 dxy = height - vec2(\n        getHeight(iChannel0, uv + vec2(st.x, 0.)),\n        getHeight(iChannel0, uv + vec2(0., st.y))\n    );\n    \n    vec3 normal = normalize(vec3(dxy * scale / st, 1.0));\n    //normal = linearToSrgb(normal);\n    \n    float ocean_mask = texture(iChannel0, uv).a;\n    float roughness = ocean_mask - 0.02;\n    \n    fragColor = vec4(normal.rg, roughness, height);\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"// Conversions between linear and sRGB, used for normal maps.\n// adapted from Mozilla's implementations.\nvec3 srgbToLinear(vec3 color) {\n    vec3 c1 = color / 12.92;\n    vec3 c2 = pow(color / 1.055 + vec3(0.055 / 1.055), vec3(2.4));\n    float lb = 0.04045;\n    return (color.r <= lb &&\n            color.g <= lb && \n            color.b <= lb ) ? c1 : c2;\n}\nvec3 linearToSrgb(vec3 color) {\n    vec3 c1 = color * 12.92;\n    vec3 c2 = vec3(1.055) * pow(color, vec3(1.0 / 2.4)) - vec3(0.055);\n    float lb = 0.0031308;\n    return (color.r <= lb &&\n            color.g <= lb && \n            color.b <= lb ) ? c1 : c2;\n}\n","name":"Common","description":"","type":"common"}]}