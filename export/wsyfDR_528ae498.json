{"ver":"0.1","info":{"id":"wsyfDR","date":"1606901956","viewed":66,"name":"scene315","username":"geranyan","description":"first project ","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["1"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float FAR_INF = 1e10;\nconst float EPS = 1e-3;\nconst float PI = 3.14159265359;\nvec2 Hash2(uint n) \n{\n\tn = (n << 13U) ^ n;\n    n = n * (n * n * 15731U + 789221U) + 1376312589U;\n    uvec2 k = n * uvec2(n,n*16807U);\n    return vec2( k & uvec2(0x7fffffffU))/float(0x7fffffff);\n}\n\n\n\nfloat rand (vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))*\n        43758.5453123);\n}\n\nvec3 rand3(vec3 st) {\n    \n \treturn normalize(vec3(Hash2(uint(st.x)), rand(st.yz)));    \n    \n}\n\nfloat sph(in vec3 pos, in vec3 cen, in float r){\n\treturn length(pos - cen) - r; \n}\n\nfloat plane(in vec3 pos, in float r){\n\n\treturn pos.y - (-r);\n}\n\nvec2 mmax(in vec2 a, in vec2 b){\n\t\n\treturn a.x > b.x ? a: b;\n}\n\nvec2 mmin(in vec2 a, in vec2 b){\n\t\n\treturn a.x < b.x ? a: b;\n}\n\nfloat smin( float d1, float d2, float k ) {\n\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    \n    return mix( d2, d1, h ) - k*h*(1.0-h); \n    \n}\n\nfloat smax( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); \n}\n\nfloat sint( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.0-h); \n}\n\nfloat Oct(vec3 pos, vec3 cen){\n    float s = 0.5;\n    pos = abs(pos - cen);\n    return (pos.x+pos.y+pos.z-s)*0.57735027;\n}\nfloat box( vec3 pos, vec3 center, vec3 size, float corner )\n{\n    return length( max( abs( pos-center )-size, 0.0 ) )-corner;\n}\n\nfloat sdNotTrivialMorph(in vec3 pos){\n    float k = 0.1;//abs(sin(iTime/100.0));\n    float disp = sin(5.0*pos.x) * sin(5.0*pos.y) * sin(5.0*pos.z) * 0.15;\n    \n    float f1 = sph(pos, vec3(0.5*sin(iTime) + 2.5*sin(iTime/3.0),2.0 + abs(sin(iTime)) -1.0, 0.5*cos(iTime)+2.5*cos(iTime/3.0)), 0.5); \n    \n    float f2 = sph(pos, vec3(2.5*sin(iTime/3.0)   ,2.5-1.0,   2.5*cos(iTime/3.0)), 0.7); \n    float f3 = sph(pos, vec3(0.5*sin(iTime) + 2.5*sin(iTime/3.0),0.5*cos(iTime)+2.5 -1.0,2.5*cos(iTime/3.0)), 0.5);\n    float f4 = Oct(pos, vec3(2.5*sin(iTime/2.0)   ,2.5-1.0,   2.5*cos(iTime/2.0) ));\n    \n    \n    float res = smin(f1 +sin(disp), f2+cos(disp), k); \n    res = smin(res, f3+disp, k);\n    res = smin(res, f4 +0.1*disp, k);\n    return res; \n    \n}\n\nfloat CSGSD(in vec3 pos){\n    \n    float k = 0.5; \n    \n    float f1 = Oct(pos, vec3(4.0 * sin(iTime), 2.0 * abs(cos(iTime)), 4.0*cos(iTime)) );\n    float f2 = sph(pos, vec3(4.0 * sin(iTime), 2.0 *  abs(cos(iTime)),4.0* cos(iTime)), 1.0 * abs(sin(iTime)) );\n    float f3 = box(pos, vec3(4.0 * sin(iTime), 2.0 * abs(cos(iTime)), 4.0*cos(iTime)), vec3(0.5), 0.0);\n    \n    return smin(f1, smax(f2, f3, k), k);\n\n}\nvec2 map(in vec3 pos){\n    \n    //float disp = \n\tvec2 d = vec2(sph(pos, vec3(0.0), 1.5), 1.0);\n    vec2 d1 = vec2(sph(pos, vec3(-3.0*sin(iTime), 0.3-0.31-sin(iTime*5.0), 3.0*cos(iTime)), 0.5), 2.0);\n    vec2 d2 = vec2 (plane(pos, 1.5), 3.0);\n    vec2 d3 = vec2(sph(pos, vec3(3.0*cos(iTime), -1.0, 3.0*sin(iTime)), 0.50),4.0);\n    \n    \n    vec2 d5 = vec2(sdNotTrivialMorph(pos), 6.0);\n    \n    //vec2 d5 = vec2(sph(pos, vec3(-0.5, 0.0, 5.0), 1.5), 6.0);\n    vec2 res = mmin(mmin(d, mmin(d1,d2)), d3);\n    \n    \n    \n    vec2 d6 = vec2(CSGSD(pos), 7.0);\n    res = mmin(res, d5);\n    res = mmin(res, d6);\n    return res;\n}\n\n\nvec2 ray_cast(in vec3 ro, in vec3 rd){\n\n\tfloat t = 0.0; \n    float d = 0.0; \n    float absSum = 1.0;\n    for(int i = 0; i < 1000; i++){\n    \tvec2 pos = map(ro + t* rd); \n        \n        if(pos.x < 0.001){\n        \t\n        \tpos.x = t; \n           \t\n            return pos;\n        } \n        \n        if(pos.x > 200.0){\n        \tbreak;\n        }\n        \n        t += pos.x*0.5;\n    }\n    \n    return vec2(-1.0);\n}\nvec3 normal(in vec3 pos){\n\n\tconst vec3 eps = vec3(0.001, 0.0, 0.0);\n    \n    \n    \n    float grad_x = map(pos + eps.xyy).x - map(pos - eps.xyy).x;\n    float grad_y = map(pos + eps.yxy).x - map(pos - eps.yxy).x;\n    float grad_z = map(pos + eps.yyx).x - map(pos - eps.yyx).x;\n    \n    \n    \n    return normalize(vec3(grad_x, grad_y, grad_z));\n\n\n\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float h = 0.01 + 0.12*float(i)/4.0;\n        float d = map( pos + h*nor ).x;\n        occ += (h-d)*sca;\n        sca *= 0.95;\n        if( occ>0.35 ) break;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 ) * (0.5+0.5*nor.y);\n}\n\n\nfloat checkers( in vec3 p ) {\n    vec3 s = sign(fract(p*0.5)-0.6);\n    return 0.5 - 0.5*s.x*s.y*s.z;\n}\n\nfloat diffuse_light(in vec3 pos, in vec3 cen){\n    \n\tvec3 nor = normal(pos);\n    vec3 dir_to_light = normalize(cen-pos);\n    float diff_intens = dot(nor, dir_to_light);\n    \n    return diff_intens;\n\n}\nfloat phong_light(in vec3 pos, in vec3 cen, in vec3 ro, in float k){\n\t\n    float specPower = k;\n    vec3 n = normal(pos);\n    vec3 l = normalize(cen-pos);\n    vec3 v = normalize(ro-pos);\n    vec3 r = reflect(v, n);\n    float phong_light = pow ( max ( dot ( l, r ), 0.0 ), specPower );\n    return phong_light;\n\n}\nfloat fog(in vec3 pos) {\n\t\n    float ans = 1.0;\n    if(abs(pos.x) > 10.0) ans *= 1.0 / (pos.x*pos.x*0.01);\n    //if(abs(pos.y) > 10.0) ans *= 1.0 / (pos.y*pos.y*0.01);\n    if(abs(pos.z) > 10.0 ) ans *= 1.0 / (pos.z*pos.z*0.01);\n    \n    return ans;\n\n}\n\n\nfloat shadow(vec3 pos, vec3 lightpos){\n\tvec3 rd = normalize(lightpos-pos);\n    float res = 1.0;\n    float t = 0.0;\n    \n    for (float i = 0.0; i < 1000.0; i++)\n    {\n\t\tvec2 h = map(pos + rd * t);\n        res = min(res, 15.0 * h.x / t);\n        t += h.x;\n        \n        if ((res < 0.000001 || t > 3200.0)) break;\n        \n    }\n    \n    return clamp(res, 0.0, 1.0);\n    \n}\n\nfloat BeerLambert(float absorptionCoefficient, float distanceTraveled) {\n    return exp(-absorptionCoefficient * distanceTraveled);\n}\n\nfloat volume_dist(in vec3 pos){\n    vec3 volume_pos = vec3(0.0, 1.5, 0.0); \n    \n    float volume_rad = 9.0*abs(sin(iTime)); \n    \n    return length(pos - volume_pos) - volume_rad;\n    \n}\nfloat fogDensity(vec3 currentPos, float sdf) {\n    \n    vec3 SPHERE_POS = vec3(0.0, 1.5, 0.0);\n    vec3 localCurrentPos = currentPos - SPHERE_POS;\n    vec2 rotate1 = vec2(cos(iTime), -sin(iTime));\n    vec2 rotate2 = vec2(sin(iTime), cos(iTime));\n    localCurrentPos.xz = vec2(dot(rotate1, localCurrentPos.xz), dot(rotate2, localCurrentPos.xz));\n    float density = rand(localCurrentPos.xz);\n    return min(density, -sdf);\n}\nvec4 volFog(in vec3 ro, in vec3 rd) {\n    \n    const float march_size = 0.1; \n    const int max_steps = 100; \n    \n    \n    \n    float absorption = 0.2;\n    float opacity = 1.0;\n    vec3 fogEffect = vec3(0.0);\n    for(int i = 0; i < max_steps; i++){\n        \n        vec3 cur_pos = ro + rd * march_size * float(i); \n        \n        if(volume_dist(cur_pos) < 0.0) {\n            float prevOpacity = opacity;\n            opacity *= BeerLambert(absorption * fogDensity(cur_pos, volume_dist(cur_pos)), march_size); \n            float abss = prevOpacity - opacity;\n            \n            fogEffect += vec3(abss);\n        }\n    \n    }\n    \n    return vec4(fogEffect, opacity);\n\n}\n\nvec3 mirror(in vec3 opos, in vec3 ord) {\n    \n    \n    vec3 n = normal(opos);\n    vec3 ro = opos;\n    vec3 rd = n;\n    int max_step =1;\n    vec3 lp = vec3(5.0, 5.0,0.0);\n    vec3 col =vec3(1.0,1.0,1.0);\n    for(int i=0; i < max_step; i++){\n        vec2 h = ray_cast(ro+0.1*n, reflect(-ro, n));\n\n\n        if(h.x > -1.0) {\n            vec3 pos = ro + h.x *rd;\n         \n            if(h.y == 2.0){\n                col = vec3(0.0, 0.0, 1.0) * calcAO(pos, normal(pos));\n                col *= shadow(pos, lp);\n                col *= 2.0;\n                \n            }\n\n\n            if(h.y == 3.0) {\n\n                col = vec3(0.7, 0.7, 0.7) * calcAO(pos, normal(pos));\n                \n\n                col += checkers(pos);\n                col *= mix(col, vec3(0.9), 20.0);\n                col *= shadow(pos, lp);\n\n            }\n            if(h.y == 4.0) {\n\n                col = vec3(1.0,0.0,0.0) * calcAO(pos, normal(pos));\n                col *= shadow(pos, lp);\n                col *= 1.5;\n\n\n\n            }\n            \n            if(h.y == 6.0) {\n                col = vec3(1.0,0.0,0.7) * calcAO(pos, normal(pos));\n                col *= shadow(pos, lp);\n                col += phong_light(pos, -lp, ro, 2000.0);\n            }\n            if(h.y == 7.0) {\n                col = vec3(0.0,1.0,0.7) * calcAO(pos, normal(pos));\n                col *= shadow(pos, lp);\n                col += phong_light(pos, -lp, ro, 2000.0);\n                \n            }\n            //col *= 2.0;\n            \n\n            \n            //col = vec3(h.y,0,0);\n        }else {\n             col = vec3(0.7, 1.0, 1.5)*exp(-rd.y);\n    }\n    }\n    \n    \n    return col;\n    \n    \n    \n}\nvec4 render(in vec3 ro, in vec3 rd){\n    \n    vec2 h = ray_cast(ro, rd);\n    vec3 lp = vec3(5.0, 5.0,0.0);\n    vec3 mp = vec3(0.0);\n    vec3 col = vec3(1.0,1.0,1.0);\n    float z = 1000000.0;\n    if(h.x > -1.0){\n        vec3 pos = ro + h.x * rd;\n        \n        if(h.y == 1.0){\n        \tcol *= calcAO(pos, normal(pos));;\n            \n           \n            \n            \n           \n            col *= mirror(pos, rd); \n            col *= shadow(pos, lp) + 0.4;\n            \n        }\n    \t\t\n    \t\n        if(h.y == 2.0){\n        \tcol = vec3(0.0, 0.0, 1.0) * calcAO(pos, normal(pos));\n            col *= shadow(pos, lp);\n            //float d = h.z; \n            //float s = d / 1.0;\n            //s = s / (1.0 + s); \n            \n           // col = (1.0 - s) * col + s * vec3(0.7);\n        }\n        \n        \n        if(h.y == 3.0) {\n        \t\n            col = vec3(0.7, 0.7, 0.7) * calcAO(pos, normal(pos));\n            \n            col += checkers(pos);\n            col *= mix(col, vec3(0.9), 20.0);\n            col *= shadow(pos, lp);\n        \t\n        }\n        if(h.y == 4.0) {\n        \t\n            col = vec3(1.0,0.0,0.0) * calcAO(pos, normal(pos)); \n        \tcol *= shadow(pos, lp);\n            \n            \n        \t\n        }\n        if(h.y == 5.0){\n        \tif(rand(vec2(rd.x, rd.y)) > 0.0 )\n\t\t\t\tcol = mix(col, vec3(0.0, 0.0, 0.0), 1.2);  \n        \t\n        \n        }\n        if(h.y == 6.0) {\n            col = vec3(1.0,0.0,0.7) * calcAO(pos, normal(pos)); \n        \tcol *= shadow(pos, lp);\n            col += phong_light(pos, -lp, ro, 200.0);\n        \n        }\n        if(h.y == 7.0) {\n                col = vec3(0.0,1.0,0.7) * calcAO(pos, normal(pos));\n                col *= shadow(pos, lp);\n                col += phong_light(pos, -lp, ro, 2000.0);\n                \n        }\n        \n        \n        z = pos.z;\n        //col *= fog(pos);\n        \n        \n    } else {\n        col = vec3(0.7, 1.0, 1.5)*exp(-rd.y);\n    }\n    \n    return vec4(col,h.x);\n\n\n}\n\nstruct Quad {\n    vec3 pos[4];\n    vec3 color;\n    vec3 normal;\n};\n\nfloat ray_triangle_intersection(Quad q, vec3 origin, vec3 dir) {\n    // dot(origin + dir * d - t.pos[0], t.normal) == 0\n    // dot(origin - t.pos[0], t.normal) + dot(dir, t.normal) * d == 0\n    // d = dot(t.pos[0] - origin, t.normal) / dot(dir, t.normal);\n    float normalViewAngle = dot(dir, q.normal);\n    if (abs(normalViewAngle) < EPS)\n        return FAR_INF;\n    float d = dot(q.pos[0] - origin, q.normal) / normalViewAngle;\n    if (d < 0.0)\n        return FAR_INF;\n    vec3 hitPos = origin + dir * d;\n    vec3 edges[4] = vec3[4](\n        q.pos[1] - q.pos[0],\n        q.pos[2] - q.pos[1],\n        q.pos[3] - q.pos[2],\n        q.pos[0] - q.pos[3]\n    );\n    float square = length(cross(edges[0], edges[1])) + length(cross(edges[2], edges[3]));\n    vec3 toHitVecs[4] = vec3[4](\n        hitPos - q.pos[0],\n        hitPos - q.pos[1],\n        hitPos - q.pos[2],\n        hitPos - q.pos[3]\n    );\n    float testSq[4] = float[4](\n        length(cross(toHitVecs[0], edges[0])),\n        length(cross(toHitVecs[1], edges[1])),\n        length(cross(toHitVecs[2], edges[2])),\n        length(cross(toHitVecs[3], edges[3]))\n    );\n    if (abs(square - testSq[0] - testSq[1] - testSq[2] - testSq[3]) < EPS)\n        return d;\n    return FAR_INF;\n}\n\n\nfloat pow2(float x) { return x * x; }\n\nvec3 getLightSpecular(Quad light, vec3 worldPos, vec3 viewVec, vec3 normal, float specFactor) {\n    vec3 r = reflect(viewVec, normal);\n    float sp = 0.0;\n    for (int i = 0; i < 4; ++i) {\n        vec3 vi = normalize(light.pos[i] - worldPos);\n        vec3 vi1 = normalize(light.pos[(i + 1) % 4] - worldPos);\n        vec3 ni = -normalize(cross(vi, vi1));\n        vec3 ti = normalize(cross(vi, ni));\n        float c;\n        float delta;\n        {\n            float a = max(dot(vi, r), 1e-9);\n            float b = max(dot(ti, r), 1e-9);\n            c = sqrt(a * a + b * b);\n            delta = atan(b / a);\n        }\n        float Imin = 0.0;\n        float Imax = (pow(c, specFactor + 2.0) - 1.0) / (pow2(c) - 1.0);\n        float xw = PI / 3.0 * sqrt(1.0 - pow2(c - c / float(specFactor)));\n        float cosxw = cos(xw);\n        float fxw = c * cosxw;\n        float Ixw = (pow(fxw, specFactor + 2.0) - fxw) / (pow2(fxw) - 1.0);\n        float yw = (Ixw - Imin) / (Imax - Imin);\n        float a = (1.0 - yw - 4.0 * pow2(xw / PI)) / yw / pow2(xw);\n        float Pmax = 1.0 / (1.0 + a * pow2(0.0));\n        float Pmin = 1.0 / (1.0 + a * pow2(PI / 2.0));\n        float s = (Imax - Imin) / (Pmax - Pmin);\n        float t = Imin - s * Pmin;\n        float Phi = acos(dot(vi, vi1));\n        float sqrt_a = sqrt(a);\n        float F = s / sqrt_a * (\n            atan(sqrt_a * (Phi - delta)) - atan(-sqrt_a * delta)\n        ) + t * Phi;\n        float l = F * dot(ni, r);\n        sp += max(l, 0.0);\n\t}\n    return light.color * sp;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.0 * fragCoord - iResolution.xy)/iResolution.y;\n    vec3 col = vec3(0.0);\n   \n    \n    \n    float an = 10.0 * iMouse.x/iResolution.x;\n    \n    vec3 ro = vec3(4.0*cos(an)*1.5, 1.0, 4.0*sin(an) * 1.5);\n    Quad light;\n    vec2 lightsPos[3];\n    for (int i = 0; i < 3; ++i) {\n        lightsPos[i] = vec2(sin(float(i) * 2.0 * PI / 3.0 + iTime) + 1.0, cos(float(i) * 2.0 * PI / 3.0 + iTime)) * 0.5;\n    }\n    light.pos = vec3[4](\n        vec3(-4.0, 1.0 + lightsPos[0].x, lightsPos[0].y),\n        vec3(-4.0, 1.5 + lightsPos[0].x, lightsPos[0].y),\n        vec3( 4.0, 1.5 + lightsPos[0].x, lightsPos[0].y),\n        vec3( 4.0, 1.0 + lightsPos[0].x, lightsPos[0].y)\n    );\n    float flagLerp = sin(iTime) * 0.5 + 0.5;\n    light.color = mix(vec3(1, 0, 0), vec3(1, 1, 0), flagLerp);\n    light.normal = vec3(0, 0, -1);\n    \n    //Анти алисинг\n    int AA = 1;\n    for(int i = 0; i < AA; i++) {\n    \n    \n        float x =  mod(float(i), float(AA));\n        float y = mod(float(i / AA), float(AA));\n        \n        \n        vec2 jitter = (Hash2(uint(i)) + vec2(x, y)) / float(AA);\n        \n        uv =  (2.0 * fragCoord + 2.0*jitter - iResolution.xy) / iResolution.x;\n        \n        vec3 ta = vec3(0.0); // target for camera\n\n\n        vec3 ww = normalize(ta - ro);\n        vec3 uu = normalize( cross(ww, vec3(0,1,0)));\n        vec3 vv = normalize( cross(uu, ww));\n\n\n\n        vec3 rd = normalize(uv.x*uu + uv.y*vv + ww);\n        vec4 r = render(ro, rd); \n        col += r.xyz;  \n        float t = 0.0; \n        vec3 lc = vec3(0.0);\n        float d = ray_triangle_intersection(light, ro, rd);\n        bool lightIntersect = false;\n       \n        if (d < t) {\n            lc = light.color;\n            t = d;\n            lightIntersect = true;\n        }\n        if(lightIntersect) \n            col *= lc;\n        vec3 cur_pos = ro + r.w * rd; \n        vec4 vFog = volFog(ro, rd);\n        //col = mix(vFog.xyz,col, vFog.w);\n    } \n    col /= float(AA);\n    fragColor = vec4(col, 1.0);\n}\n\n\n\n\n\n\n\n","name":"Image","description":"","type":"image"}]}