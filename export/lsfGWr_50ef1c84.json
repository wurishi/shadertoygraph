{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"// recursive tetrahedra\n// sgreen 8/2011\n// based on:\n// http://blog.hvidtfeldts.net/index.php/2011/08/distance-estimated-3d-fractals-iii-folding-space/\n\n// transforms\nvec3 rotateX(vec3 p, float a)\n{\n    float sa = sin(a);\n    float ca = cos(a);\n    vec3 r;\n    r.x = p.x;\n    r.y = ca*p.y - sa*p.z;\n    r.z = sa*p.y + ca*p.z;\n    return r;\n}\n\nvec3 rotateY(vec3 p, float a)\n{\n    float sa = sin(a);\n    float ca = cos(a);\n    vec3 r;\n    r.x = ca*p.x + sa*p.z;\n    r.y = p.y;\n    r.z = -sa*p.x + ca*p.z;\n    return r;\n}\n\nfloat tet(vec3 z)\n{\n     const int iterations = 10;\n     const float scale = 2.0;\n\n     vec3 a1 = vec3(1,1,1);\n     vec3 a2 = vec3(-1,-1,1);\n     vec3 a3 = vec3(1,-1,-1);\n     vec3 a4 = vec3(-1,1,-1);\n     vec3 c;\n     float dist, d;\n     int i = 0;\n     for(int n=0; n < iterations; n++) {\n          c = a1; dist = length(z-a1);\n          d = length(z-a2); if (d < dist) { c = a2; dist=d; }\n          d = length(z-a3); if (d < dist) { c = a3; dist=d; }\n          d = length(z-a4); if (d < dist) { c = a4; dist=d; }\n          z = scale*z-c*(scale-1.0);\n          i++;\n     }\n\n     return (length(z)-2.0) * pow(scale, float(-i));\n}\n\n// optimized version using folds\nfloat tet2(vec3 z)\n{\n    const int iterations = 11;\n    const float scale = 2.0;\n\n    int i = 0;\n    for(int n = 0; n < iterations; n++) {\n       if(z.x+z.y<0.0) z.xy = -z.yx; // fold 1\n       if(z.x+z.z<0.0) z.xz = -z.zx; // fold 2\n       if(z.y+z.z<0.0) z.yz = -z.zy; // fold 3\n       z = z*scale - (scale-1.0);\n       i++;\n    }\n    return length(z) * pow(scale, -float(i));\n}\n\n// distance to scene\nfloat scene(vec3 p)\n{\n    p = mod(p + vec3(1.0), 2.0) - vec3(1.0);\t// repeat\n    return tet2(p);\n}\n\n// calculate scene normal\nvec3 sceneNormal( vec3 pos )\n{\n    float eps = 0.001;\n    vec3 n;\n\tfloat d = scene(pos);\n    n.x = scene( vec3(pos.x+eps, pos.y, pos.z) ) - d;\n    n.y = scene( vec3(pos.x, pos.y+eps, pos.z) ) - d;\n    n.z = scene( vec3(pos.x, pos.y, pos.z+eps) ) - d;\n    return normalize(n);\n}\n\n// ambient occlusion approximation\nfloat ambientOcclusion(vec3 p, vec3 n)\n{\n    const int steps = 3;\n    const float delta = 0.5;\n\n    float a = 0.0;\n    float weight = 1.0;\n    for(int i=1; i<=steps; i++) {\n        float d = (float(i) / float(steps)) * delta; \n        a += weight*(d - scene(p + n*d));\n        weight *= 0.5;\n    }\n    return clamp(1.0 - a, 0.0, 1.0);\n}\n\n// lighting\nvec3 shade(vec3 pos, vec3 n, vec3 eyePos)\n{\n    vec3 l = vec3(0.0, 1.0, 0.0);\n    float diff = dot(n, l);\n    diff = 0.5+0.5*diff;\n\n    float ao = ambientOcclusion(pos, n);\n\n    return vec3(diff*ao);\n\t//return vec3(diff);\n}\n\n// trace ray using sphere tracing\nvec3 trace(vec3 ro, vec3 rd, out bool hit)\n{\n    const int maxSteps = 64;\n    float hitThreshold = 0.001;\n    hit = false;\n    vec3 pos = ro;\n\n\tfloat td = 0.0;\n    for(int i=0; i<maxSteps; i++)\n    {\n\t\tif (!hit) {\n\t\t\tfloat d = scene(pos);\n\t\t\td *= 0.5;\n\t\t\tif (abs(d) < hitThreshold) {\n\t\t\t\thit = true;\n\t\t\t\t//break;\n\t\t\t}\n\t\t\tpos += d*rd;\n\t\t\t//td += d;\n\t\t\t//hitThreshold *= 1.05;\n\t\t\t//hitThreshold = td * 0.005;\n\t\t}\n    }\n    return pos;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 pixel = (fragCoord.xy / iResolution.xy)*2.0-1.0;\n\n    // compute ray origin and direction\n    float asp = iResolution.x / iResolution.y;\n    vec3 rd = vec3(asp*pixel.x, pixel.y, -2.0);\n\n    // fish-eye\n    rd.z = -sqrt(2.0 - dot(rd.xy, rd.xy));\n    rd = normalize(rd);\n\n    // move camera\n    //vec3 ro = vec3(0.0, 0.0, 1.5);\n    vec3 ro = vec3(iTime*0.25, 0.3, iTime*0.25);\n\t\t\n    float ay = iTime*0.17;\n    float ax = sin(iTime*0.1)*0.25;\n\t\n    rd = rotateY(rd, ay);\n    rd = rotateX(rd, ax);\n\n    // trace ray\n    bool hit;\n    vec3 pos = trace(ro, rd, hit);\n\n\tconst vec3 fogColor = vec3(0.1, 0.3, 0.4);\n    vec3 rgb = fogColor;\n    if(hit)\n    {\n        // calc normal\n        vec3 n = sceneNormal(pos);\n        // shade\n        rgb = shade(pos, n, ro);\n\n        // fog\n        float dist = length(pos - ro)*0.2;\n        float fog = exp(-dist*dist);\n\t\trgb = mix(fogColor, rgb, clamp(fog, 0.0, 1.0));\n        //rgb *= fog;\n    }\n\n    fragColor=vec4(rgb, 1.0);\n}\n","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"lsfGWr","date":"1367340892","viewed":440,"name":"tet","username":"simesgreen","description":"messing around with fractals","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["fractal","distancefield","tetrahedron"],"hasliked":0,"parentid":"","parentname":""}}