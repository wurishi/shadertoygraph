{"ver":"0.1","info":{"id":"fsyBz3","date":"1660016421","viewed":226,"name":"Beehive_","username":"LucasR","description":"Trying to implement some of the things I learned from iq's live coding of \"Happy jumping\"","likes":14,"published":1,"flags":40,"usePreview":0,"tags":["raymarching","bee","nature"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Huge thanks to iq (IÃ±igo Quilez) for putting so much info online for free!\n\n// This shader is inspired in his \"Happy jumping\" shader:\n// https://www.shadertoy.com/view/3lsSzf\n\n// And many of the techniques applied here were explained in his (great) stream:\n// https://www.youtube.com/watch?v=Cfe5UQ-1L9Q\n\n\n// I added antialiasing, motion blur and depth of field based on iq's shaders \"Happy Jumping\" and \"Ladybug\",\n// the MB didn't quite work with the DoF, I'll look into that in the future.\n\n// AA and MB are controlled at the top of Buffer A, they are turned off (set to 0) by default\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 q = fragCoord / iResolution.xy;\n    \n    // dof -- source: https://www.shadertoy.com/view/4tByz3\n    const float focus = 2.; // 1.7\n    \n    vec4 acc = vec4(0.0);\n    const int N = 8; // 12\n\tfor( int j=-N; j<=N; j++ )\n    for( int i=-N; i<=N; i++ )\n    {\n        vec2 off = vec2(float(i),float(j));\n        \n        vec4 tmp = texture( iChannel0, q + off/vec2(800.0,450.0) );\n        \n        float depth = tmp.w;\n        \n        vec3  color = tmp.xyz;\n        \n        float coc = 5.0*abs(depth-focus)/depth;\n        \n        if( dot(off,off) < (coc*coc) ){\n            float w = 1.0/(coc*coc);\n            acc += vec4(color*w,w);\n        }\n    }\n    \n    vec3 col = acc.xyz / acc.w;\n    col *= 0.8 + 0.3*sqrt( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y) ); // vignetting\n    \n    fragColor = vec4(col*1.05, 1.);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// set AA to 2 for antialiasing and motion blur, set it to 0 if the shader is too slow\n\n#define AA 0\n#define ZERO (min(iFrame,0))\n\n#define PI 3.1415926\n\nvec3 rotX(vec3 p, float theta){ // Rotation matrix around the X axis\n    float c = cos(theta);\n    float s = sin(theta);\n    p.yz = mat2(c,-s,s,c)*p.yz;\n    return p;\n}\n\nvec3 rotY(vec3 p, float theta){ // Rotation matrix around the Y axis\n    float c = cos(theta);\n    float s = sin(theta);\n    p.xz = mat2(c,-s,s,c)*p.xz;\n    return p;\n}\n\n/*vec2 smin( vec2 a, vec2 b, float k ){\n    float h = clamp( 0.5+0.5*(b.x-a.x)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat smin( float a, float b, float k ){\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}*/\n\nvec2 vmin(vec2 a, vec2 b){ // regular min() compares all components, I don't want to compare material IDs\n    return a.x < b.x ? a : b;\n}\n\nvec2 smin( vec2 a, vec2 b, float k ){\n    float h = max( k-abs(a.x-b.x), 0.0 )/k;\n    return vmin( a, b ) - h*h*k*(1.0/4.0);\n}\n\nfloat smin( float a, float b, float k ){\n    float h = max( k-abs(a-b), 0.0 )/k;\n    return min( a, b ) - h*h*k*(1.0/4.0);\n}\n\nfloat sdSphere( vec3 p, float s ){\n  return length(p)-s;\n}\n\nfloat sdEllipsoid( in vec3 p, in vec3 r ){ // approximated\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r ){\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\n\nfloat sdVerticalCapsule( vec3 p, float h, float r ){\n  p.y -= clamp( p.y, 0.0, h );\n  return length( p ) - r;\n}\n\nfloat sdRoundCone( vec3 p, float r1, float r2, float h ){\n  // sampling independent computations (only depend on shape)\n  float b = (r1-r2)/h;\n  float a = sqrt(1.0-b*b);\n\n  // sampling dependant computations\n  vec2 q = vec2( length(p.xz), p.y );\n  float k = dot(q,vec2(-b,a));\n  if( k<0.0 ) return length(q) - r1;\n  if( k>a*h ) return length(q-vec2(0.0,h)) - r2;\n  return dot(q, vec2(a,b) ) - r1;\n}\n\nfloat sdCylinder( vec3 p, vec3 c ){\n  return length(p.xz-c.xy)-c.z;\n}\n\nvec2 map(in vec3 pos, in float time){ // signed distance in m.x and material ID in m.y\n    \n    // bee\n    vec3 beePos = vec3(-.7, -.5, 0.);\n    \n    vec3 q = pos-beePos;\n    q.z = -q.z;\n    \n    \n    vec2 bee = vec2(sdSphere(q, 0.15), 1.0); // thorax\n    \n    // make bounding volume\n    float beeBV = sdCapsule(q, vec3(.0, -.1, -.13), vec3(.0, -.15, .3), .348);\n    beeBV = min(beeBV, sdSphere(q-vec3(0., .2, .26), .6));\n    \n    float cm = cos(time); // for subtle movement of head and legs\n    float sm = cos(time);\n    if(beeBV < 1.245){ // bounding volume check. I'm not sure why I had to inflate it here, it looked ok before\n        q -= vec3(sm, cm, 0.)*0.007;\n        bee = smin(bee, vec2(sdSphere(q-vec3(0., -.05, -.2), 0.15), 1.0), 0.01); // head\n        // nose looking thing -- I'm not an entomologist lol\n        bee = smin(bee, vec2(sdRoundCone(q+vec3(0., .15, .3), .05, .08, .1), 1.), 0.05);\n        // eyes\n        vec3 pe = q;\n        pe.x = abs(pe.x);\n        float eyeAng = -.4; // eyes angle\n        float c = cos(eyeAng);\n        float s = sin(eyeAng);\n        pe.xy = mat2(c, s, -s, c)*pe.xy;\n        vec2 eye = vec2(sdEllipsoid(pe-vec3(0.08, -.05, -.32), vec3(.01, .05, .01)), 2.0);\n        eye = smin(eye, vec2(sdSphere(pe-vec3(0.08, -.02, -.32), 0.02), 2.0), 0.1);\n        bee = smin(bee, eye, 0.03);\n        // abdomen\n        vec3 r = q-vec3(0., -.05, 0.3);\n        /*float abAng = -0.1*PI; // abdomen angle\n        c = cos(abAng);\n        s = sin(abAng);\n        r.yz = mat2(c, s, -s, c)*r.yz;*/\n        r.yz = mat2(532, -165, 165, 532)/557.*r.yz; // Pythagorean triple trick for rotations (see iq stream)\n        vec2 abdomen = vec2(sdEllipsoid(r, vec3(.15, .15, .3)), 1.);\n        bee = smin(bee, abdomen, 0.1);\n        // legs\n            vec3 qeg = r; // q legs\n            qeg.x = abs(qeg.x)+.05;\n            qeg.z += .3;\n            // front legs\n            vec3 la = vec3(.15, -.02, -.05);\n            vec3 lb = vec3(.23, -.2, -.08)+vec3(cm, sm, 0.)*0.01;\n            vec3 lc = vec3(.25, -.3, -.08)+vec3(sm, cm, 0.)*0.008;\n            vec2 leg = vec2(sdCapsule(qeg, la, lb, 0.01), 3.0);\n            leg.x = min(leg.x, sdCapsule(qeg, lb, lc, 0.007));\n            leg.x = min(leg.x, sdCapsule(qeg, lc, vec3(.27, -.32, -.1)+vec3(0., sm, cm)*0.008, 0.004));\n            // center legs\n            la = vec3(.15, .0, .05);\n            lb = vec3(.28, -.2, .05)+vec3(0., cm, cos(1.5*time))*0.02;\n            lc = vec3(.3, -.28, .05)+vec3(sm, 0., sm)*0.007;\n            leg.x = min(leg.x, sdCapsule(qeg, la, lb, 0.01));\n            leg.x = min(leg.x, sdCapsule(qeg, lb, lc, 0.007));\n            leg.x = min(leg.x, sdCapsule(qeg, lc, vec3(.32, -.32, .04)+vec3(sm, sm, 0.)*0.01, 0.004));\n            // back legs\n            vec3 lt = vec3(.0, .0, .2);\n            la += lt;\n            lb += lt-vec3(sin(0.51*time)*0.005, sm*0.02, 0.);\n            lc += lt-vec3(sm*0.015+0.01, 0., 0.);\n            leg.x = min(leg.x, sdCapsule(qeg, la, lb, 0.012));\n            leg.x = min(leg.x, sdCapsule(qeg, lb, lc, 0.009));\n            leg.x = min(leg.x, sdCapsule(qeg, lc, vec3(.32, -.32, .04)+lt-vec3(0., 0., sm*0.01), 0.005));\n\n            bee = vmin(bee, leg);\n        // antennae\n        vec3 a = vec3(.01, -.06, -.37); // the values are kind of weird because of the domain rotation\n        vec3 b = vec3(.06, -.07, -.42);\n        vec2 ant = vec2(sdCapsule(pe, a, b, 0.008), 3.0);\n        ant.x = min(ant.x, sdCapsule(pe, b, vec3(.1, -.25, -.4), 0.005));\n        bee = vmin(bee, ant);\n        // wings\n        vec3 pw = q;\n        pw.x = abs(pw.x);\n        pw.y -= .1;\n        float wan = .5+.5*sin(40.*time);\n        c = cos(wan);\n        s = sin(wan);\n        pw.xy = mat2(c, s, -s, c)*pw.xy;\n        a = vec3(.0, .0, .0);\n        b = vec3(.1, .5, .1);\n        vec3 wc = vec3(.15, .6, .3);\n        float win = sdCapsule(pw, a, b, 0.002);\n        win = min(win, sdCapsule(pw, b, wc, 0.002));\n        win = min(win, sdCapsule(pw, wc, vec3(0.), 0.002));\n        bee = vmin(bee, vec2(win, 3.0));\n    }\n    vec2 m = bee;\n    \n    float BV = sdCylinder(pos-vec3(0.5, .0, -4.), vec3(2.));\n    if(BV < 0.55){\n        // more (low res) bees\n        bee = vec2(sdSphere(pos-vec3(1.2+sm*.05, -.5+cm*.02, -2.2), 0.06), 1.0);\n        bee.x = min(bee.x, sdSphere(pos+vec3(-1.4+cm*.02, .9+sm*.005, 2.8+cm*.02), 0.06));\n        m = vmin(m, bee);\n\n        // tree\n        float tr = 0.3; // trunk radius\n        tr += 0.003*sin(pos.y*15.);\n        pos -= vec3(2.4, -2., -1.5);\n        float th = atan(pos.z/pos.x); // polar angle with origin moved to tree axis\n        tr += 0.008*cos((th+sin(pos.y)*0.2)*15.);\n        m = vmin(m, vec2(sdVerticalCapsule(pos, 3., tr), 5.0)); // trunk\n        // leaves\n        tr += sin(pos.y*10.)*.05;\n        float le = sdSphere(pos-vec3(.2, 4., -.5), 2.-tr);\n        le = smin(le, sdSphere(pos-vec3(-1.5, 4., -.5), .5-tr*0.5), .1);\n        le = smin(le, sdSphere(pos-vec3(.2, 2.5, 0.), .5), .2);\n        m = vmin(m, vec2(le, 4.0));\n\n        // beehive\n        \n        /*float an = .1;\n        float c = cos(an);\n        float s = sin(an);\n        pos.xy = mat2(c, -s, s, c)*pos.xy;*/\n        pos.xy = mat2(612, -35, 35, 612)/613.*pos.xy; // Pythagorean triple trick for rotations (see iq stream)\n        float br = .03*sin(25.*pos.y);\n        float bh = sdEllipsoid(pos+vec3(.4, -2., .35), vec3(.45+br, .6, .45+br));\n        m = vmin(m, vec2(bh, 6.0));\n    }\n    \n    // floor\n    q.y = q.y-sin(q.x*.1-.5)-sin(q.z*.4)+2.5-q.x*.1;\n    m = vmin(m, vec2(q.y, 4.0));\n    \n    // grass\n    if(q.y < 1.5){\n        vec2 id = floor((pos.xz+0.25)*2.);\n        float fid = id.x*11.1 + id.y*31.7;\n        q.xz = mod(q.xz, .5)-.25;\n        q.y += 0.1*sin(11.7*fid)+.15;\n        q.xz += 0.1*sin(12.*fid);\n        float rad = q.y*.15; // make them thicker at the top\n        m = smin(m, vec2(sdVerticalCapsule(q, .6, rad), 4.0), 0.1);\n        //m = vmin(m, vec2(sdVerticalCapsule(q, .6, rad), 4.0));\n    }\n    \n    return m;\n}\n\nvec2 castRay( in vec3 ro, in vec3 rd, float time ){\n    vec2 res = vec2(-1.0, -1.0);\n    float tmin = 1.5;\n    float tmax = 27.5;\n    \n    float t = tmin;\n    for(int i=ZERO; i<128 && t<tmax; i++){\n        vec2 h = map( ro+rd*t, time );\n        //if( h.x < 0.001 ){\n        if( abs(h.x)<(0.001*t) ){\n            res = vec2(t, h.y);\n            break;\n        }\n        t += h.x;\n    }\n    return res;\n}\n\n// change between 0 and 1 to test different normal calculation functions\n#if 1\nvec3 calcNormal(vec3 q, float time){ // gscene3 from https://www.shadertoy.com/view/NscXR4\n    float h = 0.001;\n\tvec3 n = vec3(0);\n\tfor (int i = ZERO; i < 4; ++i) {\n\t\tvec3 e = vec3((ivec3(i+3, i, i+i)&2) - 1);\n\t\tn += map(q + e * h, time).x * e;\n\t}\n\treturn normalize(n);\n}\n#else\nvec3 calcNormal(vec3 p, float time){\n  vec2 e = vec2(1.0, -1.0) * 0.0005;\n  return normalize(\n    e.xyy * map(p + e.xyy, time).x +\n    e.yyx * map(p + e.yyx, time).x +\n    e.yxy * map(p + e.yxy, time).x +\n    e.xxx * map(p + e.xxx, time).x);\n}\n#endif\n\nfloat softShadow(vec3 ro, vec3 rd, float mint, float maxt, float time){\n// source: https://www.shadertoy.com/view/ltyXD3\n    float res = 1.0;\n    float t = mint;\n    \n    for(int i = ZERO; i < 16; i++) {\n        float h = map(ro + rd * t, time).x;\n        res = min(res, 8.0*h/t);\n        t += clamp(h, 0.02, 0.10);\n        if(h < 0.001 || t > maxt) break;\n    }\n    \n    return clamp( res, 0.0, 1.0 );\n}\n\nvec4 render( in vec3 ro, in vec3 rd, float time ){ // rgb and distance (for DoF)\n    vec3 col = vec3(0.5, 0.8, 0.9) - max(rd.y,0.0)*0.75;\n    vec2 res = castRay(ro, rd, time);\n    vec3 pos = ro+res.x*rd;\n    vec3 n = calcNormal(pos, time);\n    \n    vec3 sunDir = normalize(vec3(0.2, 0.3, 0.1));\n    vec3 sunCol = vec3(1.2, 1.1, 0.8);\n    vec3 grassCol = vec3(0.05, 0.25, 0.1);\n    float spe = 1.;\n    \n    float sunDif = clamp(dot(n, sunDir), 0.0, 1.0);\n    if(res.y > 0.5){ // not sky\n        col = vec3(0.8, 0.7, 0.25); // bee's body\n        col *= pos.z < .09 ? .05+clamp(sin(pos.z*20.), 0., 1.) : 1.; // stripes\n        if((1.5 < res.y) && (res.y < 2.5)){ // bee's eyes\n            col = vec3(0.01);\n            float RV = clamp(dot(reflect(sunDir, n), rd), 0., 1.);\n            spe = pow(RV, 5.)*3.5;\n        }else if((2.5 < res.y) && (res.y < 3.5)){ // legs, antennae and wings\n            col = vec3(0.013);\n        }else if((3.5 < res.y) && (res.y < 4.5)){ // leaves and grass\n            col = vec3(0.1, 0.55, 0.2) + 0.1*sin(pos.x*.2) + 0.1*sin(pos.y);\n        }else if(4.5 < res.y){ // bark (5.0) and beehve (6.0)\n            col = vec3(.5, .4, .2);\n        }\n        \n        float topOcc = softShadow(pos, vec3(0., 1., 0.), 0.02, 1., time);\n        vec3 lin = vec3(0.0);\n        lin += sunDif*sunCol*spe*softShadow(pos, sunDir, 0.02, .5, time); // Sun\n        lin += (0.05+0.95*clamp(n.y, 0.0, 1.0))*vec3(0.2, 0.2, 0.9)*topOcc; // sky\n        \n        lin += (0.05+0.95*clamp(-n.y, 0.0, 1.0))*grassCol * 0.5;\n        float treeLight = dot(n, normalize(vec3(.5, 1., .2)));\n        lin += grassCol*(1.-topOcc)*clamp(treeLight, 0., 1.)*0.2; // light leak from tree\n        col = col*lin;\n    }else if(pos.y > 0.2) col = vec3(0.1, 0.55, 0.2)*.7; // \"fix\" holes in the floor\n    return vec4(col, res.x);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec4 tot = vec4(0.);\n#if AA > 1\n    for( int m=ZERO; m<AA; m++ )\n    for( int n=ZERO; n<AA; n++ )\n    {\n    vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n    vec2 uv = ((fragCoord+o) - .5 * iResolution.xy) / iResolution.y;\n    \n    // motion blur -- from iq's stream (link at the top of Image tab)\n    float mb = 0.;//float(m*AA+n)/float(AA*AA); // this didn't look right with the DoF\n    float md = texelFetch(iChannel0, ivec2(fragCoord)&1023, 0).x;\n    mb += (md-.5)/float(AA*AA-1);\n    float time = iTime - 0.020833*mb;\n#else\n    vec2 uv = (fragCoord - .5 * iResolution.xy) / iResolution.y;\n    float time = iTime;\n#endif\n    vec3 ro = vec3(0., 0., 2.);\n    vec3 rd = normalize(vec3(uv, -1.));\n    \n    if(iMouse.z > 0.){ // if LMB is being pressed\n        vec2 mouse = (iMouse.xy - .5 * iResolution.xy) / iResolution.y;\n        rd = rotY(rotX(rd, mouse.y), mouse.x); // rotate the camera with the mouse\n    }\n    \n    vec4 col = render(ro, rd, time);\n    col.rgb = pow(col.rgb, vec3(0.4545)); // gamma correction\n    tot += col;\n#if AA > 1\n    }\n    tot /= float(AA*AA);\n#endif\n    \n    fragColor = tot;\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"vec2 mainSound( int samp, float time )\n{\n     return vec2( 0.01*fract(30.*sin(6.2831*50.*time)) );\n}","name":"Sound","description":"","type":"sound"}]}