{"ver":"0.1","info":{"id":"DtKXWw","date":"1686154842","viewed":81,"name":"fieldplay","username":"MartinRGB","description":"a simple filow field,forked from https://www.shadertoy.com/view/MdGBWG,also dont forget this great repo:https://github.com/anvaka/fieldplay","likes":5,"published":1,"flags":32,"usePreview":0,"tags":["fieldflow"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    vec3 old = texture(iChannel0,fragCoord/iResolution.xy).xyz;\n    // Output to screen\n    fragColor = vec4(old,1.);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define MAPRES vec2(64,64);\n#define PI 3.1415926535897932384626433832795\n#define HALFPI 1.57079632679\n\n// Hash Part\n#define ITERATIONS 4\n\n\n// *** Change these to suit your range of random numbers..\n\n// *** Use this for integer stepped ranges, ie Value-Noise/Perlin noise functions.\n#define HASHSCALE1 .1031\n#define HASHSCALE3 vec3(.1031, .1030, .0973)\n#define HASHSCALE4 vec4(.1031, .1030, .0973, .1099)\n\n// For smaller input rangers like audio tick or 0-1 UVs use these...\n//#define HASHSCALE1 443.8975\n//#define HASHSCALE3 vec3(443.897, 441.423, 437.195)\n//#define HASHSCALE4 vec3(443.897, 441.423, 437.195, 444.129)\n\n\n\n//----------------------------------------------------------------------------------------\n//  1 out, 1 in...\nfloat hash11(float p)\n{\n    vec3 p3  = fract(vec3(p) * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//----------------------------------------------------------------------------------------\n//  1 out, 2 in...\nfloat hash12(vec2 p)\n{\n    vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//----------------------------------------------------------------------------------------\n//  1 out, 3 in...\nfloat hash13(vec3 p3)\n{\n    p3  = fract(p3 * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//----------------------------------------------------------------------------------------\n//  2 out, 1 in...\nvec2 hash21(float p)\n{\n    vec3 p3 = fract(vec3(p) * HASHSCALE3);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n//----------------------------------------------------------------------------------------\n///  2 out, 2 in...\nvec2 hash22(vec2 p)\n{\n    vec3 p3 = fract(vec3(p.xyx) * HASHSCALE3);\n    p3 += dot(p3, p3.yzx+19.19);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n//----------------------------------------------------------------------------------------\n///  2 out, 3 in...\nvec2 hash23(vec3 p3)\n{\n        p3 = fract(p3 * HASHSCALE3);\n    p3 += dot(p3, p3.yzx+19.19);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\n//----------------------------------------------------------------------------------------\n//  3 out, 1 in...\nvec3 hash31(float p)\n{\n   vec3 p3 = fract(vec3(p) * HASHSCALE3);\n   p3 += dot(p3, p3.yzx+19.19);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\n\n//----------------------------------------------------------------------------------------\n///  3 out, 2 in...\nvec3 hash32(vec2 p)\n{\n    vec3 p3 = fract(vec3(p.xyx) * HASHSCALE3);\n    p3 += dot(p3, p3.yxz+19.19);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\n//----------------------------------------------------------------------------------------\n///  3 out, 3 in...\nvec3 hash33(vec3 p3)\n{\n    p3 = fract(p3 * HASHSCALE3);\n    p3 += dot(p3, p3.yxz+19.19);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n\n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 1 in...\nvec4 hash41(float p)\n{\n    vec4 p4 = fract(vec4(p) * HASHSCALE4);\n    p4 += dot(p4, p4.wzxy+19.19);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n    \n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 2 in...\nvec4 hash42(vec2 p)\n{\n    vec4 p4 = fract(vec4(p.xyxy) * HASHSCALE4);\n    p4 += dot(p4, p4.wzxy+19.19);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n\n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 3 in...\nvec4 hash43(vec3 p)\n{\n    vec4 p4 = fract(vec4(p.xyzx)  * HASHSCALE4);\n    p4 += dot(p4, p4.wzxy+19.19);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 4 in...\nvec4 hash44(vec4 p4)\n{\n        p4 = fract(p4  * HASHSCALE4);\n    p4 += dot(p4, p4.wzxy+19.19);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"vec2 get_velocity(in vec2 p){\n    p = p * vec2(iResolution.x,iResolution.y)/MAPRES;\n    vec2 v = vec2(0.);\n    //==================== write your code here ==================\n    v.x=sin(p.x);\n    v.y=cos(p.y);\n    //============================================================\n    return v;\n}\n\nvec2 field(vec2 fragCoord) {\n    //I.   generate a staggered grid,\n    //     caculation in simulation will use centred difference\n    //     centred difference is  a more accurate approximation\n    //II.  readStoredPosition, get particles' position from texture => p\n    //III. generate random position => p = p + noise\n    //IV.  get the velocity\n    //V.   newPosition = position + velcotiy;\n    \n    for(int i = -1; i <= 1; i++) {\n        for(int j = -1; j <= 1; j++) {\n            //this loop function generate a grid\n            //get 9 point from center of fragCoord coordinate\n            vec2 uv = (fragCoord + vec2(i,j)) / iResolution.xy; \n            vec2 p = texture(iChannel0, fract(uv)).xy;\n            if(p == vec2(0)) {\n                // if there is noise point in this coordniate,the particle will exist,or return vec2(0.);\n                if (hash13(vec3(fragCoord + vec2(i,j), iFrame)) > 1e-4) continue;\n                // in fact,the random hash value did not affect the final efx.\n                p = fragCoord + vec2(i,j) + hash21(float(iFrame)) - 0.5; // add particle\n                \n            } else if (hash13(vec3(fragCoord + vec2(i,j), iFrame)) < 8e-3) {\n                continue; // remove particle\n            }\n            vec2 v = get_velocity((uv*2. - vec2(0.5,0.5*iResolution.x/iResolution.y)));\n            p = p + v; //newPosition\n            p.x = mod(p.x, iResolution.x);\n\n            // this means,control the pariticle in the grid\n            if(abs(p.x - fragCoord.x) < 0.5 && abs(p.y - fragCoord.y) < 0.5)\n                return p;\n        }\n    }\n    \n    return vec2(0.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    vec2 fragC = fragCoord;\n    fragColor.xy = field(fragC);\n    //mix the current frame and previous frame\n    fragColor.z = 0.995 * texture(iChannel0, fragCoord/iResolution.xy).z;\n    if (fragColor.x > 0.) fragColor.z = 1.;\n\n}","name":"Buffer A","description":"","type":"buffer"}]}