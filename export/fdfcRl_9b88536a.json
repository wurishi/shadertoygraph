{"ver":"0.1","info":{"id":"fdfcRl","date":"1642491182","viewed":90,"name":"Big sillie","username":"panna_pudi","description":"oh duh","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["girl"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 CAM;\nconst vec3 FACE_DIR = vec3(0., 0., -1.);\nconst float T_MAX = 4.;\n\nconst float PI = acos(-1.);\nconst float TAU = 2. * PI;\n\n#define sat(x) clamp(x, 0., 1.)\n#define AAstep(x0, x) clamp((x - x0) / (2. * 2. / pc.resolution.y), 0., 1.)\n\nfloat hash21(vec2 coord){\n    return fract(sin(dot(coord.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nmat2 rot(float a) {\n    float c = cos(a) , s = sin(a);\n    return mat2(c,-s,s,c);\n}\n\nvec3 erot(vec3 p, vec3 ax, float a) {\n    return mix(dot(ax, p) * ax, p, cos(a)) + cross(ax, p) * sin(a);\n}\n\nvec2 _min(vec2 a, vec2 b) {\n    if (a.x < b.x)\n        return a;\n    return b;\n}\n\nfloat sd_sphere(in vec3 p, in float r) {\n    return length(p) - r;\n}\n\nfloat sd_circle(in vec2 p, in float r) {\n    return length(p) - r;\n}\n\nfloat sd_rounded_cylinder(vec3 p, float radius, float roundness, float h) {\n    vec2 d = vec2(length(p.xz) - 2.0 * radius + roundness, abs(p.y) - h);\n    return min(max(d.x, d.y), 0.0) + length(max(d, 0.0)) - roundness;\n}\n\nfloat sd_segment(in vec2 p, in vec2 a, in vec2 b) {\n    vec2 pa = p - a, ba = b - a;\n    float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    return length(pa - ba * h);\n}\n\nfloat sd_arc(in vec2 p, in vec2 sc, in float ra, float rb) {\n    // sc is the sin/cos of the arc's aperture\n    p.x = abs(p.x);\n    return ((sc.y * p.x > sc.x * p.y) ? length(p - sc * ra)\n                                      : abs(length(p) - ra)) - rb;\n}\n\nfloat smin(float a, float b, float k) {\n    float h = max(k - abs(a - b), 0.0) / k;\n    return min(a, b) - h * h * k * (1.0 / 4.0);\n}\n\nfloat smax(float a, float b, float k) {\n    return log(exp(k * a) + exp(k * b)) / k;\n}\n\nfloat sd_ellipse(vec3 p, vec3 r) {\n    float k0 = length(p / r);\n    float k1 = length(p / (r * r));\n    return k0 * (k0 - 1.0) / k1;\n}\n\nmat3 get_cam(vec3 eye, vec3 at) {\n    vec3 zaxis = normalize(at - eye);\n    vec3 xaxis = normalize(cross(zaxis, vec3(0., 1., 0.)));\n    vec3 yaxis = cross(xaxis, zaxis);\n    return mat3(xaxis, yaxis, zaxis);\n}\n\nfloat sdRoundedCylinder(vec3 p, float ra, float rb, float h) {\n    vec2 d = vec2(length(p.xz) - 2.0 * ra + rb, abs(p.y) - h);\n    return min(max(d.x, d.y), 0.0) + length(max(d, 0.0)) - rb;\n}\n#define sabs(x, k) sqrt((x) * (x) + k)\nfloat piggy_snout(vec3 p) {\n    vec3 po = p;\n    po.yz *= rot(PI / 2.);\n    float base =\n        sdRoundedCylinder(po, 0.03 + sabs(po.x, 0.001) * 0.2 - p.y * 0.3, 0.01, 0.05);\n    vec3 pe = vec3(abs(p.x), p.yz);\n    pe += vec3(-0.06, 0.08, 0.05);\n    float noseholes = length(pe) - 0.036;\n    /* base = smax(base.x, -noseholes, 0.03); */\n    // base = max(base.x, -noseholes);\n    return base;\n}\n\nvec3 turn_to_cam(vec3 p) {\n    return erot(p, normalize(cross(CAM, FACE_DIR)), acos(dot(CAM, FACE_DIR)));\n}\n\nfloat hair(vec3 p) {\n    float roundness = 0.5;\n    float length = 1.0;\n    vec3 q = p + vec3(0., 0.94, -0.06);\n    float radius = 0.24 + smoothstep(0.07, -1.5, (q.y - 1.0) * .2);\n    float hair = sd_rounded_cylinder(q, radius, roundness, length);\n    hair = max(hair,\n         -sd_rounded_cylinder(q - vec3(0., -0.1, -0.1), radius, roundness, length));\n    hair = max(hair, -q.y - 0.7);\n\n    q = p + vec3(0., 0.17, 0.0);\n    float tresses = min(hair, abs(sd_rounded_cylinder(q, 0.219, 0.4, 0.30)) - 0.010);\n    tresses = max(tresses, sd_sphere(q - vec3(0.0, 0.35, -0.70), 0.78));\n    float inner = sd_ellipse(q - vec3(0.0, 0.4, 0.00), vec3(0.36, 1.25, 0.9));\n    tresses = smax(tresses, -inner, 100.0);\n    hair = min(hair, tresses);\n\n    q = p - vec3(0., 0.03, 0.01);\n    float ringlet = sd_ellipse(q, vec3(0.45, 0.5, 0.4) + 0.01);\n    ringlet = abs(ringlet) - 0.015;\n    ringlet = max(ringlet, sd_sphere(q + vec3(0.42, -0.46, 0.0), 0.7));\n    ringlet = max(ringlet, -sd_sphere(q + vec3(0.2, 0.0, 0.09), 0.4));\n    hair = min(hair, ringlet);\n\n    return hair;\n}\n\nfloat mat_id = -1.;\nfloat map(vec3 p){\n    float time = iTime;\n\n    vec2 d = vec2(1e9, -1.);\n\n    vec3 q = p;\n    q = turn_to_cam(q);\n    float head = sd_ellipse(q, vec3(0.45, 0.5, 0.4));\n\n    float hair = hair(q);\n\n    float nose = sd_sphere(q - vec3(0.0, 0.0, -0.4), 0.1);\n    float scale = 2.;\n    nose = piggy_snout((q - vec3(0.0, 0.0, -0.4)) * scale) / scale;\n\n    q = p + vec3(0., 1.25, 0.0);\n    q.xz *= rot(sin(time) * smoothstep(-0.5, 1.0, q.y));\n    q *= vec3(1., 1., 2.);\n    float body = sd_rounded_cylinder(q, 0.20, 0.16, 0.42);\n    float holes = length(vec2(abs(q.x), q.y) - vec2(0.41, 0.48)) - 0.15;\n    float shirt = max(sd_rounded_cylinder(q, 0.21, 0.16, 0.42), -holes);\n    float neck = sd_rounded_cylinder(p + vec3(0., 0.6, 0.), 0.04, 0.06, 0.08);\n    body = smin(body, neck, 0.20);\n\n    d = _min(d, vec2(head, 0));\n    d = _min(d, vec2(body, 0));\n    d = _min(d, vec2(hair, 1));\n    d = _min(d,vec2(shirt, 2));\n    // d = _min(d, vec2(nose, 3));\n\n    /* d = vec2(nose, 0.); */\n\n    mat_id = d.y;\n    return d.x;\n}\n\nvec3 get_norm(vec3 p) {\n    mat3 k = mat3(p,p,p) - mat3(0.001);\n    return normalize(vec3(map(p)) - vec3(map(k[0]), map(k[1]), map(k[2])));\n}\n\nfloat trace(vec3 ro, vec3 rd, float t_min, float t_max) {\n    float rng = hash21(rd.xy);\n    float t = t_min;\n    for (int i = 0; i < 100; ++i) {\n        vec3 p = ro + rd * t;\n        float d = map(p);\n        if (abs(d) < 0.001) break;\n        t += d;\n        if (t > t_max) break;\n    }\n    return t;\n}\n\nvec3 sky(vec3 rd){\n    vec3 col = vec3(0.);\n    col += mix(0.12 * vec3(0.15, 0.1, 1.0), 0.1 * vec3(0.85, 0.9, 1.0),\n               0.5 + 0.5 * normalize(rd).y);\n    col += smoothstep(0.2, 1.5, dot(rd, normalize(vec3(0., -1., 0.)))) * 1.1 *\n           vec3(0.67843, 0.67451, 0.709);\n    col += smoothstep(.2, 1.0, dot(rd, normalize(vec3(10, 1, 1)))) * 0.1 *\n           vec3(0.3647, 0.2902, 0.63137);\n\n    return col;\n}\n\n#define lofi(x, k) floor((x) * (k)) / (k)\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // vec2 uv = (in_uv + -0.5) * 2.0 * vec2(pc.resolution.x / pc.resolution.y, 1);\n    float aspect = iResolution.x / iResolution.y;\n    vec2 uv = (fragCoord/iResolution.xy * 2. - 1.)\n            * vec2(aspect, 1.);\n    /* uv = lofi(uv, 1. / .006); */\n    float time = iTime * 0.3 - PI / 2.;\n\n    vec3 ro = vec3(0., 0., -1.5);\n    float a = (time * 5.) - PI / 2.;\n    //ro = 1.5 * vec3(cos(a), 0.1, sin(a));\n    CAM = normalize(ro);\n    vec3 target = vec3(0., 0., 0.);\n    mat3 cam = get_cam(ro, target);\n    vec3 rd = cam * normalize(vec3(uv, 1.));\n\n    vec3 col = sky(rd) * 0.2;\n    float t = trace(ro, rd, 1.1, T_MAX);\n\n    vec3 light_pos = vec3(4., 1., -4.);\n\n    if (mat_id >= 0. && t < T_MAX) {\n        vec3 pos = ro + t * rd;\n        vec3 nor = get_norm(pos);\n\n        vec3 albedo = vec3(0.);\n        float alpha = 1.;\n        float intensity = 1.;\n        // skin\n        if (mat_id == 0.) {\n            /* albedo = vec3(249, 223, 224) / 255.; */\n            albedo = vec3(0.96, 0.67, 0.5);\n            albedo = vec3(0.96, 0.47, 0.4);\n            intensity = 0.;\n\n            vec2 phead = turn_to_cam(pos).xy;\n\n            vec2 p = phead;\n            p -= vec2(-0.015, 0.12);\n            p.x = abs(p.x);\n            p -= vec2(0.2, 0.);\n            float blicks = sd_circle(p, 0.01);\n\n            phead.x = abs(phead.x);\n\n            vec2 q = phead - vec2(0.0, -0.2); q *= rot(PI);\n            float smile = sd_arc(q, vec2(1, 0), .1,\n                                 mix(-.1, .05, smoothstep(1., 0., q.x + .43)));\n\n            float eyes = sd_segment(phead, vec2(0.2, 0.0), vec2(0.2, 0.15)) - 0.01;\n            float blush = sd_circle(phead * vec2(0.5, 1.) - vec2(0.15, -.1), 0.015);\n            float brows = sd_segment(phead, vec2(0.18, 0.24), vec2(0.22, 0.23)) - 0.012;\n\n            albedo = mix(albedo, vec3(0., 0., 0.), smoothstep(.01, .0, eyes));\n            albedo = mix(albedo, vec3(247., 164., 164.) / 255. * 1.5, smoothstep(.01, .0, blush));\n            albedo = mix(albedo, vec3(0., 0., 0.), smoothstep(.01, .0, smile));\n            albedo = mix(albedo, vec3(236, 209, 61) / 255. / 2., smoothstep(.01, .0, brows));\n            albedo = mix(albedo, vec3(1., 1., 1.), smoothstep(.01, .0, blicks));\n        }\n        // hair\n        if (mat_id == 1.) {\n            albedo = vec3(0.915, .786, .260);\n            albedo = vec3(236, 209, 61) / 255.;\n            /* albedo = vec3(0.985, .946, .210); */\n            alpha = 8.;\n            intensity = 6.;\n        }\n        // shirt\n        if (mat_id == 2.) {\n            albedo = vec3(1.);\n        }\n        // nose\n        if (mat_id == 3.) {\n            albedo = vec3(.8, 0., 0.);\n        }\n        albedo *= 1.;\n\n        vec3 light_dir = normalize(light_pos - pos);\n        float shade = dot(light_dir, nor) * 0.5;\n        shade = mix(max(shade, 0.), shade * 0.5 + 0.5, 0.05);\n\n        float spec = clamp(dot(reflect(light_dir, nor), rd), 0., 1.);\n        spec = pow(spec, alpha) * intensity;\n\n        float fre = mix(0.003, 8., pow(1. - dot(-rd, nor), 10.));\n\n        col = albedo * (.2 + shade);\n        col += vec3(0.915, .786, .860) * spec * 0.5;\n        /* col *= (1. - fre); */\n    }\n\n    col = pow(col, vec3(.2545));\n    fragColor = vec4(col, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}