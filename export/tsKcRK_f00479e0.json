{"ver":"0.1","info":{"id":"tsKcRK","date":"1603275260","viewed":107,"name":"Noob shader, smile, test","username":"Bzikarius","description":"My very first shader here.\nmade mostly with tutorial https://www.youtube.com/watch?v=u5HAYVHsasc\nWell commented for learning purposes","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["simple","noob","learning","easy","commented"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/* \nfunction draws circle on UV, with center at pos, radius r\nand smooth edge with blur-wide. grad is gradient size\n*/\nfloat Circle (vec2 uv, vec2 pos, float r, float blur, float grad)\n{\n    \n    float d = length(uv-pos);// shifts from UV center to circle`s center\n    float smd=blur/2.; //halves blur to add both sides (in/out)\n    float c = smoothstep(r+smd, r-smd, d); //makes circle with smooth edge\n\n    if (grad>=0.01){ // adding circular gradient\n        \n        c -= smoothstep(r-grad, r, d)/4.; //darken border\n        c += smoothstep(r, r-grad/8., d)/8.; // lighten center\n    \n    }\n    \n    clamp (c,0.,1.); //prevents values out of range.\n    return c; //returns value/brightness\n}\n\n\n\n\n\n\n//function draws smile\nfloat smile (vec2 uv, vec2 pos, float blur, float size)\n{\n    uv-=pos; //move to position\n   \tuv /= size; //scale\n    blur /= size; //scale blur\n    float grad = .3; //gradient size\n    float mask = Circle(uv, vec2(0.), .4 , blur, grad); // gradient\n    grad=0.; //gradient off\n    float maskG= Circle(uv, vec2(0.), .4 , blur, grad); // main circle\n\t\n    float ed=.18; //eyes shift from center\n    float eh=.09; // eyes height\n    float er=.1; // eyes min radius\n\tfloat add_er=.06; // eyes additional radius\n    \n    float pulse = pow(((1.+sin(float(iTime*5.)))/2.),3.);//pulsing float\n\n    er = er + add_er*pulse;//dynamic eyes\n     //er = er+add_er; //static eyes\n    \n    //mirrored eye, substracted from big circle\n    float sn = 1.; \n    for (int i=1;i<=2;i++){\n        mask -= Circle(vec2(uv.x, uv.y),vec2(sn*ed,eh), er , blur, grad);\n        sn*=-1.;\n    }\n\n    //mouth is substraction of one circle from another\n    //bigger circle is streched a little along X and smaller is squished\n    float mouth = Circle(vec2(uv.x*1.3,uv.y), vec2(0. , 0.055), .34 , blur, grad); //smaller\n    mouth -= Circle(vec2(uv.x*.6,uv.y), vec2(0.,0.28), .4 , blur, grad);//bigger\n    mouth = clamp(mouth, 0. , 1.); //cutting off negative values.\n\n    // substracting mouth from face and multiplying white mask to yello.\n   \treturn mask-mouth;\n\n}\n\n\n\n\n//main, outputs pixels colored as fragcolor on cordinades of screen\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 iR = iResolution.xy; //shorten name\n    vec2 uv = fragCoord/iR.xy; // normalize cordinates to range [0;0]—[1;1]\n\n   \n    uv -= .5; // shifts UV-zeropoint to center of screen\n    uv.x *= iR.x/iR.y; //corrects x, with aspect of screen\n\n    float blur = 3.5/max(iR.x,iR.y); // smooth edge width in real pixels\n\n    float image = 0.; //empty mask\n\tvec2 pos = vec2 (0.);\n    float size =0.41+.05*(1.+sin(iTime)); //size multiplier\n\tfloat coff = 0.42; //offset from center\n    float fi = 0.; // to use i as float\n    float rotor = iTime/8.; //rotation\n\n    for (int i=1; i<7; i++){ // spam some smiles\n\n        fi=float(i);\n       \n    \n        \n        //position of each smile on the circle\n        pos.y = coff*sin(fi*1.048+rotor);\n        pos.x = coff*cos(fi*1.048+rotor);\n        \n        // adding mask, keeping range 0—1\n        image=max(image, smile(uv, pos, blur, size));\n    }\n    \n   \n    //coloring mask\n    vec3 col=vec3 (1., 0.8 , 0.)*image;\n\n    // Output to screen\n    fragColor = vec4(col , 1);\n}","name":"Image","description":"","type":"image"}]}