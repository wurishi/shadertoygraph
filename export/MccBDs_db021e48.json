{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[{"channel":0,"type":"cubemap","id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"}}],"code":"#define PI 3.1415927\n/*\n\t@geofftnz\n\n    Playing around with some simple raytracing, using a stack to implement recursion.\n    \n    The string of lights is fake: They're not actually casting light into the scene, but \n    instead are contributing to each ray segment based on a distance function.\n    \n*/\n#define NLIGHTS 32\n#define FPS_GRAPH\n\n// use a different colour space for rendering\n#define USE_XYZ\n\nconst float gamma = 2.2;\n\n// global screen split for colourspace conversion\nbool use_colour_space = true;\n\n//------------------------------------------------------------------------------\n// Colour space transform\n//------------------------------------------------------------------------------\n\n#ifdef USE_XYZ\n/*\n// https://en.wikipedia.org/wiki/Academy_Color_Encoding_System#Converting_ACES2065-1_RGB_values_to_CIE_XYZ_values\nvec3 RGBtoXYZ(vec3 col)\n{\n    const mat3 x = mat3(\n        \tvec3(0.9525523959,0.3439664498,0.0),\n        \tvec3(0,0.7281660966,0.0),\n        \tvec3(0.0000936786,-0.0721325464,1.0088251844)\n        );\n    return x * col;\n}\n\nvec3 XYZtoRGB(vec3 col)\n{\n    const mat3 x = mat3(\n        \tvec3(1.0498110175,-0.4959030231,0.0),\n        \tvec3(0.0,1.3733130458,0.0),\n        \tvec3(-0.0000974845,0.0982400361,0.9912520182)\n        );\n    return x * col;\n}*/\n\n/*\nOKLab functions\n@xdrz\nhttps://www.shadertoy.com/view/X3Gfzd\n*/\nfloat cbrt(float f) {\n    return pow(f, 0.333333);\n}\n\nvec3 RGBtoXYZ(vec3 c) \n{\n    if (!use_colour_space) return c;\n\n\tfloat l = 0.4122214708 * c.r + 0.5363325363 * c.g + 0.0514459929 * c.b;\n\tfloat m = 0.2119034982 * c.r + 0.6806995451 * c.g + 0.1073969566 * c.b;\n\tfloat s = 0.0883024619 * c.r + 0.2817188376 * c.g + 0.6299787005 * c.b;\n\n    float l_ = cbrt(l);\n    float m_ = cbrt(m);\n    float s_ = cbrt(s);\n\n    vec3 res;\n\tres.x = 0.2104542553*l_ + 0.7936177850*m_ - 0.0040720468*s_;\n\tres.y = 1.9779984951*l_ - 2.4285922050*m_ + 0.4505937099*s_;\n\tres.z = 0.0259040371*l_ + 0.7827717662*m_ - 0.8086757660*s_;\n\t\n\treturn res;\n}\n\nvec3 XYZtoRGB(vec3 color) \n{\n    if (!use_colour_space) return color;\n\n\tfloat l_ = color.x + 0.3963377774 * color.y + 0.2158037573 * color.z;\n    float m_ = color.x - 0.1055613458 * color.y - 0.0638541728 * color.z;\n    float s_ = color.x - 0.0894841775 * color.y - 1.2914855480 * color.z;\n\n    float l = l_*l_*l_;\n    float m = m_*m_*m_;\n    float s = s_*s_*s_;\n\n    vec3 res;\n\tres.r =  4.0767416621 * l - 3.3077115913 * m + 0.2309699292 * s;\n\tres.g = -1.2684380046 * l + 2.6097574011 * m - 0.3413193965 * s;\n\tres.b = -0.0041960863 * l - 0.7034186147 * m + 1.7076147010 * s;\n\n    return res;\n}\n\n#else\nvec3 RGBtoXYZ(vec3 col){ return col; }\nvec3 XYZtoRGB(vec3 col){ return col; }\n#endif\n\n\n\n\nfloat pointRayDistance(vec3 ro, vec3 rd, vec3 p)\n{\n\tvec3 u = p-ro;\n\tfloat cosvu = dot(rd,u);\n\t//if (cosvu<0.0) return -1.0; //length(p-ro);\n    if (cosvu<0.0) return length(p-ro);\n\tvec3 puv = rd * (cosvu / length(rd));\n\tvec3 qq = ro + puv;\n\treturn length(p-qq);\n}\n\nfloat pointRayDistance(vec3 ro, vec3 rd, float rlen, vec3 p)\n{\n\tvec3 u = p-ro;\n\tfloat cosvu = dot(rd,u);\n\n    if (cosvu<=0.0) return length(p-ro);\n    if (cosvu>=rlen) return length(p-(ro+rd*rlen));\n    \n\tvec3 puv = rd * (cosvu / length(rd));\n\tvec3 qq = ro + puv;\n\treturn length(p-qq);\n}\n\n// MATERIAL =============================================================================\n// null material\n#define M_NONE 0x0000u\n\n// pure reflector\n#define M_REFLECT 0x0001u\n\n// fresnel reflector\n#define M_FRESNELREFLECT 0x0002u\n\n// refractor\n#define M_REFRACT 0x0004u\n\n// diffuse\n#define M_DIFFUSE 0x0008u\n\n// absorbing media\n#define M_ABSORB 0x0010u\n\nstruct Material\n{\n    uint flags;    // material flags (M_*)\n    float ior;     // index of refraction of material being entered.\n    vec3 col;      // material-dependent colour.\n};\nMaterial nullMaterial = Material(M_NONE,1.0,vec3(0.0));\n\nMaterial mGlass = Material(M_FRESNELREFLECT | M_REFRACT, 1.5, vec3(0.99));\n\nMaterial mAir = Material(M_REFRACT,1.0,vec3(1.0));\n\nMaterial mMirror = Material(M_REFLECT,1.0,vec3(1.0));\n\nMaterial mDiamond = Material(M_FRESNELREFLECT | M_REFRACT,1.9,vec3(0.95));\n\n\n// RAY =============================================================================\nstruct Ray\n{\n    vec3 ro;   // ray origin\n    vec3 rd;   // ray direction\n    vec3 att;  // accumulated attentuation factor\n    Material material; // current media\n};\n\n// STACK =============================================================================\n\n#define RAY_STACK_SIZE 32\nRay rayStack[RAY_STACK_SIZE];\nint rayStackPointer = 0;\n\nbool pushRay(Ray frame)\n{\n    if (rayStackPointer >= RAY_STACK_SIZE) return false;  // rayStack full\n    \n    rayStack[rayStackPointer++] = frame;\n   \n    return true;\n}\n\nbool canPopRay()\n{\n    return rayStackPointer > 0;\n}\n\nRay popRay()\n{\n    if (rayStackPointer <= 0) // rayStack empty\n    {\n        return Ray(vec3(0.0), vec3(0.0), vec3(1.0),nullMaterial);\n    }\n    rayStackPointer--;\n    return rayStack[rayStackPointer];\n}\n\n// INTERSECTIONS =============================================================================\n\nstruct RayIntersection\n{\n    float t;       // distance along ray of hit, or -1 if miss.\n    vec3 nor;      // surface normal at intersection\n    Material material; // material of surface hit\n    int id;        // id of hit object\n};\n\nRayIntersection rayMiss = RayIntersection(-1.0,vec3(1.0,0.0,0.0),Material(M_NONE,1.0,vec3(1.0)),0);\n\n// intersect ray ro+rd with sphere sph\nRayIntersection rtSphere(Ray ray, in vec4 sph, in Material m, in Material mOutside, in int id){\n\n    RayIntersection res;\n    res.t = -1.0;\n    res.nor = vec3(0.0);\n    res.material = nullMaterial;\n    res.id = -1;\n    \n    // sphere intersection\n\tfloat r = sph.w; //radius\n\tvec3 oc = ray.ro - sph.xyz; //origin = position sphere\n\tfloat b = 2.0*dot(oc,ray.rd);\n\tfloat c = dot(oc,oc)-r*r;\n\tfloat h = b*b - 4.0*c;\n    \n    // at least one of the intersection points is along the ray.\n\tif (h >= 0.0)\n    {\n        float hsqrt = sqrt(h);\n        \n        res.t = (-b - hsqrt) / 2.0;\n        res.id = id;\n                \n        // incoming hit to sphere\n        if (res.t >= 0.0)\n        {\n            res.nor = normalize(ray.ro + ray.rd * res.t - sph.xyz);\n            res.material = m;\n        }\n        else\n        {\n            // back-side hit.\n            \n            res.t = (-b + hsqrt) / 2.0;\n            res.nor = -normalize(ray.ro + ray.rd * res.t - sph.xyz);\n            res.material = mOutside;\n        }\n    }\n    return res;\n}\n\n\n\nvec3 environment_linear_rgb(vec3 rd)\n{\n    //return texture(iChannel0,rd).rgb;\n    return pow(texture(iChannel0,rd).rgb, vec3(gamma));\n    //return vec3(0.0);\n}\nvec3 environment(vec3 rd)\n{\n    return RGBtoXYZ(environment_linear_rgb(rd));\n}\n\nvec3 rayLights(in vec3 ro, in vec3 rd, in float dlimit)\n{\n    vec3 c = vec3(0.0);\n    vec3 l_accum = vec3(0.0);\n    vec3 lcol = normalize(vec3(0.1,0.7,1.5));\n    \n    mat4 rot = rotationMatrix(vec3(sin(iTime * 0.7),sin(iTime * 0.07),cos(iTime * 0.6)),0.15);\n    \n    // background hit\n    if (dlimit >= 1e6){\n        l_accum = environment_linear_rgb(rd);\n    }\n\n    float r = 1.05;\n    float light_brightness = 4.0;\n    \n    // determine closest distance between ray and light\n    \n    for (int i=0;i<NLIGHTS;i++)\n    {\n        float ii = (float(i) * 0.02) + iTime*0.01;\n        ii *= 2.0 * PI;\n        vec3 lpos = vec3(sin(ii) * r, cos(ii) * r, sin(ii*1.7) * r);\n        \n        // closest ray-light distance\n        float d = pointRayDistance(ro, rd, dlimit, lpos);\n        \n        if (d >= 0.0)\n        {        \n            l_accum += ((lcol * 0.7 + vec3(0.1)) * light_brightness / (1.0 + d*d*2000.));\n        }\n        \n        lcol = ((rot * vec4(lcol - vec3(0.5),1.0)).xyz + vec3(0.5)) * 0.7;\n    }\n    \n    //c+= RGBtoXYZ(l_accum);\n    \n    return RGBtoXYZ(l_accum);\n}\n\n\n\n\nvec3 strace(Ray ray);\n\n// \"Recursive\" raytrace using a rayStack\nvec3 stacktrace(vec3 ro, vec3 rd)\n{\n\n    rayStackPointer = 0;\n    \n    // accumulated colour to return\n    vec3 col = vec3(0.0); \n    \n    // ray attenuation modifier\n    vec3 att = vec3(1.0);\n    \n    // push initial ray to rayStack\n    pushRay(Ray(ro,rd,vec3(1.0),mAir));\n    \n    int rayCount = 0;\n    int stackDepth = rayStackPointer; \n\n    // loop while our rayStack has items\n    while(canPopRay() && rayCount < 100)\n    {\n        stackDepth = max(stackDepth,rayStackPointer);\n        Ray ray = popRay();\n        rayCount++;\n        \n        col += strace(ray);\n    }\n    \n    // ray depth vis\n    //col = vec3(0.0);   \n    //col.r = float(rayCount) * 0.01;\n    //col.g = float(stackDepth) / float(RAY_STACK_SIZE);\n    \n    return col;\n}\n\nRayIntersection closest(RayIntersection a, RayIntersection b)\n{\n    if (b.t > 0.0 && (a.t < 0.0 || b.t < a.t)) return b;\n    return a;\n}\n\nRayIntersection sceneIntersect(Ray ray)\n{\n    RayIntersection hit = rayMiss;\n    RayIntersection test;\n    \n    // intersect with scene objects and pick the closest.\n    \n    // large sphere\n    hit = closest(hit, rtSphere(ray, vec4(0.0,0.0,0.0,0.75), mGlass, mAir, 1));\n    \n    // hollow sphere inside large sphere\n    //hit = closest(hit, rtSphere(ray, vec4(0.0,0.0,0.0,0.73), mAir, mGlass, 10));\n    \n    // orbiting spheres\n    for (int i = 0; i < 6; i++)\n    {\n        float ii = (float(i) * 2.0 * PI) / 6.0;\n        ii += iTime * 0.2;\n        \n        vec4 sph2;\n        sph2.w = 0.3;\n        float sph2r = 0.75 + sph2.w + 0.002;\n\n        sph2.x = sin(ii) * sph2r;\n        sph2.y = sin(ii*0.3) * cos(ii*0.13) * sph2r;\n        sph2.z = cos(ii) * sph2r;\n        \n        hit = closest(hit, rtSphere(ray, sph2, mMirror, mAir, 2+i));\n        \n    }\n    \n    return hit;\n}\n\n// trace an individual ray and compute light contribution.\n// pushes additional rays to the stack for reflections/refractions etc...\nvec3 strace(Ray ray)\n{\n    vec3 col = vec3(0.0);\n    vec3 absorb = vec3(1.0);\n    float epsilon = 1e-5; // a very small amount to avoid self-intersection of reflection/refraction rays.\n    \n    // If we've attenuated this ray too far, then early-exit.\n    // This reduces the number of rays cast for reflection\n    if (dot(ray.att,ray.att) < 1e-4) return vec3(0.0,0.0,0.0);\n\n    // intersect the scene\n    RayIntersection hit = sceneIntersect(ray);\n\n    // hit something?\n    if (hit.t >= 0.0)\n    {\n        vec3 hitpos = ray.ro + ray.rd * hit.t;\n        \n        // add lights between ray origin and hit\n        col += rayLights(ray.ro, ray.rd, hit.t);\n        \n        // process material\n        \n        // Current material is an absorber\n        if ((ray.material.flags & M_ABSORB) > 0u)\n        {\n            // vec3 col, float dist, vec3 Kr, float f\n            //ray.att = absorb(ray.att, hit.t, ray.material.col, 0.5);\n            //absorb = pow(ray.material.col, vec3(1.0 + (hit.t * 4.0)));\n            absorb = pow(ray.material.col,vec3(1.0+hit.t*10.));\n            ray.att *= absorb;\n        }\n        \n        \n        // Refractive material (entering or leaving).\n        // - dimming due to dispersion of rays\n        // - deflect ray and trace\n        if ((hit.material.flags & M_REFRACT) > 0u)\n        {\n            float disp = computeRayDispersion(ray.rd, hit.nor, hit.material.ior);\n            \n            //col.r = disp * 8.;  // visualise dispersion\n            \n            vec3 internalAbsorb = vec3(1.0 - disp);\n            //internalAbsorb *= absorb;\n\n            // The spawned ray is behind the surface, so we switch the material to the hit material.\n            pushRay(Ray(hitpos - hit.nor*epsilon, refract(ray.rd, hit.nor, ray.material.ior / hit.material.ior), ray.att * internalAbsorb, hit.material));\n        }\n        \n        // Fresnel-reflective material.\n        if ((hit.material.flags & M_FRESNELREFLECT) > 0u)\n        {\n            float reflAmount = FresnelReflectAmount(ray.material.ior,hit.material.ior,hit.nor,ray.rd); // calculate Fresnel\n            \n            // we keep the same material since we're reflecting off the surface, not passing through it.\n            pushRay(Ray(hitpos + hit.nor*epsilon, reflect(ray.rd, hit.nor),ray.att * vec3(reflAmount), ray.material));\n        }\n        \n        // Purely-reflective material.\n        if ((hit.material.flags & M_REFLECT) > 0u)\n        {\n            float reflAmount = 1.0;\n            \n            // we keep the same material since we're reflecting off the surface, not passing through it.\n            pushRay(Ray(hitpos + hit.nor*epsilon, reflect(ray.rd, hit.nor),ray.att * vec3(reflAmount), ray.material));\n        }\n\n    }\n    else\n    {\n        // ray missed\n        col += rayLights(ray.ro,ray.rd,1e6);\n    }\n    \n    return col * ray.att;// * absorb;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    //uv are the pixel coordinates, from 0 to 1\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    //use_colour_space = uv.y < 0.5;\n\n\tvec2 p = fragCoord.xy/iResolution.xy;\n\tp = -1.0 + 2.0*p;\n\tp.x *= iResolution.x/iResolution.y;\n\n    vec3 mse = iMouse.xyz;\n    if (mse.z <= 0.0){  // default view\n        mse.x = iResolution.x * 0.5;\n        mse.y = iResolution.y * 0.5;\n    }\n\n    // turn mouse into spherical coords\n\tvec2 nMouse = (mse.xy / iResolution.xy)* PI;\n\tfloat th = nMouse.y; \n\tfloat ph = -nMouse.x * 2.0;\n    \n    vec3 ro;\n    float camdist = 2.0;\n\tro.x = sin(th) * cos(ph) * camdist;\n\tro.z = sin(th) * sin(ph) * camdist;\n\tro.y = cos(th) * camdist;\n\n\tvec3 lookAt = vec3(0.0);\n\tvec3 front = normalize(lookAt - ro);\n\tvec3 left = normalize(cross(vec3(0,1,0), front));\n\tvec3 up = normalize(cross(front, left));\n\tvec3 rd0 = normalize(front*1.5 + left*p.x + up*p.y); // rect vector\n\n    vec3 col = vec3(0.0);\n    \n    // intersect with scene\n    col = stacktrace(ro,rd0);\n\t\n    col = XYZtoRGB(col);\n\n    // reinhardt HDR tonemapping\n\t//float whitelevel = 1.0;\n\t//col = (col  * (vec3(1.0) + (col / (whitelevel * whitelevel))  ) ) / (vec3(1.0) + col);\t\n    \n\n    // gamma\t\n\tcol = pow(col,vec3(1.0/gamma));\n    \n    // fps graph\n    #ifdef FPS_GRAPH\n    if (fragCoord.y < 4.)\n    {    \n        float fps = 1./iTimeDelta;\n        float posFPS = fragCoord.x * 0.5;\n    \n        if (posFPS < fps)\n        {\n            if (posFPS > 120.)\n            {\n                col = vec3(0.,1.,1.);\n            }\n            else if (posFPS > 60.)\n            {\n                col = vec3(0.,1.,0.);\n            }\n            else if (posFPS > 30.)\n            {\n                col = vec3(1.,1.,0.);\n            }\n            else \n            {\n                col = vec3(1.,0.,0.);\n            }\n            \n            if (fract(posFPS/10.)<0.05)\n            {\n                col *= 0.9;\n            }\n        }\n    }\n    #endif\n\t\n\tfragColor = vec4(col,1.0);\n\t\n}\n","name":"Image","description":"","type":"image"},{"outputs":[],"inputs":[],"code":"float rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat rand(vec3 co){\n    return fract(sin(dot(co.xyz ,vec3(12.9898,78.233,47.985))) * 43758.5453);\n}\n\n// credit: iq/rgba\nfloat hash( float n )\n{\n    return fract(sin(n)*43758.5453);\n}\n\n// credit: iq/rgba\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    float n = p.x + p.y*57.0 + 113.0*p.z;\n    float res = mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                        mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\n                    mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                        mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\n    return res;\n}\n\n\nfloat fbm(in vec3 x)\n{\n\tfloat i = 1.0;\n\t\n\tfloat n = noise(x * i) / i; i *= 2.0;\n\tn+= noise(x * i) / i; i *= 2.0;\n\tn+= noise(x * i) / i; i *= 2.0;\n\tn+= noise(x * i) / i; i *= 2.0;\n\tn+= noise(x * i) / i; i *= 2.0;\n    n+= noise(x * i) / i; i *= 2.0;\n\n\treturn n;\n}\n\n// exponential absorbtion - @pyalot http://codeflow.org/entries/2011/apr/13/advanced-webgl-part-2-sky-rendering/\nvec3 absorb(vec3 col, float dist, vec3 Kr, float f)\n{\n    return col * (vec3(1.0) - pow(Kr, vec3(f / max(dist,0.0000000001))));\n}\n\n//============================================================\n// credit: demofox https://www.shadertoy.com/view/4tyXDR\n#define OBJECT_REFLECTIVITY 0.0 // How reflective the object is. regardless of fresnel.\nfloat FresnelReflectAmount (float n1, float n2, vec3 normal, vec3 incident)\n{\n    // Schlick aproximation\n    float r0 = (n1-n2) / (n1+n2);\n    r0 *= r0;\n    float cosX = -dot(normal, incident);\n    if (n1 > n2)\n    {\n        float n = n1/n2;\n        float sinT2 = n*n*(1.0-cosX*cosX);\n        // Total internal reflection\n        if (sinT2 > 1.0)\n            return 1.0;\n        cosX = sqrt(1.0-sinT2);\n    }\n    float x = 1.0-cosX;\n    float ret = r0+(1.0-r0)*x*x*x*x*x;\n\n    // adjust reflect multiplier for object reflectivity\n    ret = (OBJECT_REFLECTIVITY + (1.0-OBJECT_REFLECTIVITY) * ret);\n    return ret;\n}\n\nmat4 rotationMatrix(vec3 axis, float angle) {\n    // Ensure axis is normalized\n    axis = normalize(axis);\n    \n    // Sine and cosine of the angle\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    // Rotation matrix calculation using Rodrigues' rotation formula\n    return mat4(\n        vec4(\n            oc * axis.x * axis.x + c,\n            oc * axis.x * axis.y - axis.z * s,\n            oc * axis.x * axis.z + axis.y * s,\n            0.0\n        ),\n        vec4(\n            oc * axis.x * axis.y + axis.z * s,\n            oc * axis.y * axis.y + c,\n            oc * axis.y * axis.z - axis.x * s,\n            0.0\n        ),\n        vec4(\n            oc * axis.x * axis.z - axis.y * s,\n            oc * axis.y * axis.z + axis.x * s,\n            oc * axis.z * axis.z + c,\n            0.0\n        ),\n        vec4(0.0, 0.0, 0.0, 1.0)\n    );\n}\n\n\n// Credit: https://claude.ai/chat/f83e94c0-06f6-4ca4-868f-fa27b2c47567\n// Function to compute ray dispersion through a sphere\nfloat computeRayDispersion(\n    vec3 rd,      // Ray direction\n    vec3 nor,     // Surface normal\n    float ior     // Index of refraction\n) \n{\n    // Compute incident angle\n    float cosIncident = abs(dot(rd, nor));\n    \n    // Compute refraction angle using Snell's law\n    // sin(theta1) / sin(theta2) = n2 / n1\n    // Where n1 is the refractive index of the first medium (typically air = 1.0)\n    // and n2 is the refractive index of the sphere material\n    float n1 = 1.0;  // Air\n    float n2 = ior;  // Material's index of refraction\n    \n    // Compute sin of refraction angle using Snell's law\n    float sinRefraction = (n1 / n2) * sqrt(1.0 - cosIncident * cosIncident);\n    \n    // Check for total internal reflection\n    if (sinRefraction > 1.0) {\n        // Total internal reflection occurs\n        return 0.0;\n    }\n    \n    // Compute cosine of refraction angle\n    float cosRefraction = sqrt(1.0 - sinRefraction * sinRefraction);\n    \n    // Compute dispersion (angular spread of rays)\n    // This is approximated by the difference between incident and refraction angles\n    float dispersionAngle = abs(acos(cosIncident) - acos(cosRefraction));\n    \n    // Optional: Add chromatic aberration effect\n    // Different wavelengths have slightly different refractive indices\n    // We'll use a simple approximation\n    float wavelengthDispersion = 0.02 * (n2 - n1);\n    \n    // Combine angle-based and wavelength-based dispersion\n    float totalDispersion = dispersionAngle + wavelengthDispersion;\n    \n    // Normalize and scale dispersion for more intuitive values\n    return totalDispersion / (0.5 * 3.14159);\n}\n","name":"Common","description":"","type":"common"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"MccBDs","date":"1733822772","viewed":90,"name":"lights and mirrors 2","username":"bloodnok","description":"Good old basic ray-tracing. Fake lights.\n\nMouse to rotate.","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["raytracing","refraction","recursion"],"hasliked":0,"parentid":"4ctBzl","parentname":"lights and mirrors"}}