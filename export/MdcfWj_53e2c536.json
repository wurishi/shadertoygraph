{"ver":"0.1","info":{"id":"MdcfWj","date":"1526775820","viewed":159,"name":"Accelerated raymarching concept","username":"rory618","description":"Typically we only sample the sdf at points along the ray, but nearby points may provide more information. If the circle/sphere of empty space intersects the ray, you may march forward. Is the extra computation worth it? Is there a better way to get grad?","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["2d","raymarching","visualization"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void lineSegment(inout vec4 fragColor, vec2 z, vec2 a, vec2 b, vec4 c,  float w){\n    \n    z -= a; b -= a;                        // go to A referential\n    float q = dot(z, b) / dot(b, b) ;      // projection of P on line AB: normalized ordinate\n    b *= clamp(q, 0., 1.);                 // point on segment AB closest to P \n\n    \n    fragColor =mix(fragColor,vec4(c.xyz,1) ,c.w* clamp(w-length( z - b),0.,1.));\n}\n\nvoid circle(inout vec4 fragColor, vec2 z, vec2 a, float r, vec4 c,  float w){\n    \n    fragColor =mix(fragColor,vec4(c.xyz,1) ,c.w* clamp(w-abs(length(z-a)-r),0.,1.));\n}\n\nfloat map(vec2 z){\n    //Edges of the screen and center circle\n    return min(abs(length(z-iResolution.xy/2.)-100.),min(min(z.x,z.y),min(iResolution.x-z.x,iResolution.y-z.y)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    int it = 17;\n    \n    fragColor = vec4(1);\n    float l = 0.;\n    vec2 z = iMouse.zw;\n    vec2 d = normalize(iMouse.xy-iMouse.zw);\n    if(iMouse.z<=0.){\n        z = (.5+.5*sin(iTime*vec2(.031,.042)))*iResolution.xy;\n        d = normalize(sin(iTime*vec2(.064,.077)));\n    }\n    //Do normal raymarching in green\n    for(int i = 0; i < it; i++){\n        float d0 = map(z+l*d);\n     \tcircle(fragColor,fragCoord,z+l*d,d0,vec4(0,1,0,1),1.);\n        l += d0;\n            \n        lineSegment(fragColor,fragCoord,z,z+d*l,vec4(0,1,0,1),1.);\n    }\n     l = 0.;\n    //Accelerated raymarching in red\n    for(int i = 0; i < it; i++){\n        float d0 = map(z+l*d);\n        \n        //Estimate gradient of sdf numerically\n        float d1 = map(z+l*d+vec2(1e-2,0));\n        float d2 = map(z+l*d+vec2(0,1e-2));\n        \n        vec2 grad = normalize(vec2(d1-d0,d2-d0));\n        float x = -d0/dot(grad,d);\n        \n     \tfloat y = x/2./dot(grad,d);\n        float h = sqrt(y*y-x*x/4.);\n        \n        //To select a good additional point to sample the sdf at, assume we are nearby a flat surface and use the gradient to compute\n        //exactly where the ray would intersect the approximate surface. Then sample far enough away from that surface that you can\n        //expect the circle to also intersect the current location, so as to not have any gaps where small objects could get skipped over.\n        \n        //For rays moving away from a nearby surface I'll have to come up with a different way of choosing a point.\n        //Probably something along the lines of keeping track of a running estimate of how far away from the ray we shoud sample\n        //in order to still be able to march forward with the resulting information.\n        vec2 c = z+(l+x)*d-y*grad;\n        float p = map(c);\n        if(p>h){\n            float x0 = sqrt(p*p-h*h);\n            float a = x/2.-x0;\n            float b = x/2.+x0;\n            if(a<=d0 && x > 0. && d0<b){\n                l += b;\n                circle(fragColor,fragCoord,c,p,vec4(1,0,0,.4),2.);\n            } else {\n                circle(fragColor,fragCoord,z+l*d,d0,vec4(1,0,0,.4),2.);\n                l += d0;\n            }\n        } else {\n            circle(fragColor,fragCoord,z+l*d,d0,vec4(1,0,0,.4),2.);\n            l += d0;\n        }\n     \t\n            \n        lineSegment(fragColor,fragCoord,z,z+d*l,vec4(1,0,0,.4),2.);\n    }\n    circle(fragColor,fragCoord,iResolution.xy/2.,100.,vec4(1,0,1,.9),2.);\n}","name":"Image","description":"","type":"image"}]}