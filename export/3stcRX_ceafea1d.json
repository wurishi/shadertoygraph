{"ver":"0.1","info":{"id":"3stcRX","date":"1601409154","viewed":386,"name":"GameBoy Emulator","username":"mbeytekin","description":"Simple Gameboy dot screen emulator","likes":16,"published":1,"flags":32,"usePreview":0,"tags":["pixel","gameboy","lcd"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float shadowdistance=0.;\nfloat shadowsize=8.;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n\tvec4 LCDDisp=texture(iChannel0,uv);\n\n    \n   \n    vec2 radius = vec2(shadowsize);\n    // Calculate the value at the corners so that the matrix can be easily inverted\n    float max = sqrt(radius.x * radius.x + radius.y * radius.y);\n    // Define the variable which will hold the blured values\n    vec3 blur = vec3(0.0);\n\n    // Define the variable which will be used to normalize the image\n    float sum = 0.0;\n    // The kernel is dynamically created based on the bluring radius\n\n    for(float u = -radius.x; u<=radius.x; u++){\n        for(float v = -radius.y; v<=radius.y; v++){\n            // The pixel weight used by the kernel is defined as: the distance from the kernel origin (0,0)\n            // to the current kernel position, subtracted from the maximum possible distance. This leads\n            // to a gradient from 0% relative weight on the edges to 100% relative weight at the origin of the kernel\n            float weight = max - sqrt(u * u + v * v);\n            // The weight is then exponentialized which seams to sleightly maintain more of the origianl detail\n            //weight = pow(weight, 2.0);\n            // The weight is then multiplied by the texture being sampled and added to the overall blurred values\n            blur += weight * texture( iChannel0, uv + (vec2(u-shadowdistance, v+shadowdistance)/iResolution.xy)).xyz;\n            // The weight is then added for normalizing purposes\n            sum += weight;\n        }\n    }\n    // Finally the blurred image is normalized\n    blur /= sum;\n        fragColor = min(LCDDisp,vec4(blur , 1.0));\n  \n\n       \n       // fragColor = (LCDDisp);\n \n    \n    // Output to screen\n    \n   // fragColor.rgb=blur;\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XdfGRr","filepath":"/media/a/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm","previewfilepath":"/media/ap/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm","type":"video","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\t\n\tfloat gamma=0.9;\n    int invert=0;\n\tconst vec2 pixelSize = vec2(6.0,6.);\n\tconst float subpixel=1.;\n   \tconst int pixeldistance=1;\n\n\nfloat poffsetX=0.; \nfloat poffsetY=0.;\n\n\n\n\n//CIE L*a*b* (CIELAB, L* for lightness, a* from green to red, b* from blue to yellow)\n//Source: https://gist.github.com/mattatz/44f081cac87e2f7c8980 (HLSL)\nvec3 rgb2xyz(vec3 c){\n\tvec3 tmp=vec3(\n\t\t(c.r>.04045)?pow((c.r+.055)/1.055,2.4):c.r/12.92,\n\t\t(c.g>.04045)?pow((c.g+.055)/1.055,2.4):c.g/12.92,\n\t\t(c.b>.04045)?pow((c.b+.055)/1.055,2.4):c.b/12.92\n\t);\n\tmat3 mat=mat3(\n\t\t.4124,.3576,.1805,\n\t\t.2126,.7152,.0722,\n\t\t.0193,.1192,.9505\n\t);\n\treturn 100.*(tmp*mat);\n}\nvec3 xyz2lab(vec3 c){\n\tvec3 n=c/vec3(95.047,100.,108.883),\n\t     v=vec3(\n\t\t(n.x>.008856)?pow(n.x,1./3.):(7.787*n.x)+(16./116.),\n\t\t(n.y>.008856)?pow(n.y,1./3.):(7.787*n.y)+(16./116.),\n\t\t(n.z>.008856)?pow(n.z,1./3.):(7.787*n.z)+(16./116.)\n\t);\n\treturn vec3((116.*v.y)-16.,500.*(v.x-v.y),200.*(v.y-v.z));\n}\nvec3 rgb2lab(vec3 c){\n\tvec3 lab=xyz2lab(rgb2xyz(c));\n\treturn vec3(lab.x/100.,.5+.5*(lab.y/127.),.5+.5*(lab.z/127.));\n}\nvec3 lab2xyz(vec3 c){\n\tfloat fy=(c.x+16.)/116.,\n\t      fx=c.y/500.+fy,\n\t      fz=fy-c.z/200.;\n\treturn vec3(\n\t\t 95.047*((fx>.206897)?fx*fx*fx:(fx-16./116.)/7.787),\n\t\t100.   *((fy>.206897)?fy*fy*fy:(fy-16./116.)/7.787),\n\t\t108.883*((fz>.206897)?fz*fz*fz:(fz-16./116.)/7.787)\n\t);\n}\nvec3 xyz2rgb(vec3 c){\n\tmat3 mat=mat3(\n\t\t3.2406,-1.5372,-.4986,\n\t\t-.9689, 1.8758, .0415,\n\t\t .0557, -.2040,1.0570\n\t);\n\tvec3 v=(c/100.0)*mat,\n\t     r=vec3(\n\t\t(v.r>.0031308)?((1.055*pow(v.r,(1./2.4)))-.055):12.92*v.r,\n\t\t(v.g>.0031308)?((1.055*pow(v.g,(1./2.4)))-.055):12.92*v.g,\n\t\t(v.b>.0031308)?((1.055*pow(v.b,(1./2.4)))-.055):12.92*v.b\n\t);\n\treturn r;\n}\nvec3 lab2rgb(vec3 c){return xyz2rgb(lab2xyz(vec3(100.*c.x,2.*127.*(c.y-.5),2.*127.*(c.z-.5))));}\n\n\n\n\nvec3 findnearestcolor(vec3 color)\n{\n    \n    vec3 col[4];\n\tcol[0]=vec3(24./255., 74./255., 2./255.);\n    col[1]=vec3(44./255.,85./255.,2./255.);\n    col[2]=vec3(82./255., 111./255., 2./255.);\n    col[3]=vec3(136./255., 151./255., 3./255.);\n\n \tfloat _min=10000.;\n    vec3 res=color;\n    vec3 ccol;\n    for (int a=0;a<4;a++)\n    {\n        ccol=rgb2lab(col[a]);\n        if (distance(color,ccol)<_min)\n        {\n            _min=distance(color,ccol);\n            res=ccol;\n            \n        }\n            \n        \n        \n        \n    }\n    \n   return res; \n    \n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n     vec3 c;\n    vec2 uv = fragCoord/iResolution.xy;\n\n\n    vec3 src = texture(iChannel0, uv).rgb;\n   \n\tvec3 sum;\n  \n\n\n          c=texture(iChannel0, (fragCoord-mod(fragCoord,pixelSize)+vec2(poffsetX,poffsetY))/iResolution.xy).rgb;\n    if (invert==1) {c.rgb=1.-c.rgb;}\n             \n\n        \n   sum=lab2rgb(findnearestcolor(rgb2lab(pow(c,vec3(1./gamma)))));\n             \t\n\n    \n    \n\n     fragColor.rgb=sum;\n\n    if (mod(fragCoord.x,float(pixelSize/subpixel))<float(pixeldistance))\n    {\n  fragColor.rgb=vec3(151./255., 161./255., 2./255.);\n        \n    }\n     if (mod(fragCoord.y,float(pixelSize/subpixel))<float(pixeldistance))\n    {\n   fragColor.rgb=vec3(151./255., 161./255., 2./255.);\n        \n    }\n    \n    \n\n\n}","name":"Buffer A","description":"","type":"buffer"}]}