{"ver":"0.1","info":{"id":"XsffWr","date":"1495629764","viewed":244,"name":"LineAO","username":"Geolm","description":"Use line integral to compute capsule ao. inspired by https://labs.unity.com/article/linear-light-shading-linearly-transformed-cosines\n\nLast update : 2018-11-28, compute capsule cap using the nearest point on the segment and a sphere AO","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["ao"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define AO_DISTANCE (1.0)\n#define AO_STEPS_COUNT (6)\n#define AO_RAYCOUNT (512)\n#define PI (3.14159265359)\n#define PI_3 (1.0472)\n#define PI_6 (PI / 6.0)\n#define PI_8 (0.7853981 * 0.5)\n#define TWOPI (6.283185307)\n#define CAPSULE_RADIUS (0.09)\n\n//#define VS_CAPSULEAO\n\n\nvec2 hash2( float n ) { return fract(sin(vec2(n,n+1.0))*vec2(43758.5453123,22578.1459123)); }\n\nvec4 hash4( vec2 p ) { return fract(sin(vec4( 1.0+dot(p,vec2(37.0,17.0)), \n                                              2.0+dot(p,vec2(11.0,47.0)),\n                                              3.0+dot(p,vec2(41.0,29.0)),\n                                              4.0+dot(p,vec2(23.0,31.0))))*103.0); }\n\nvec3 mul(mat3 m, vec3 v)\n{\n    return m * v;\n}\n\n// intersect capsule\nfloat capIntersect( in vec3 ro, in vec3 rd, in vec3 pa, in vec3 pb, in float r )\n{\n    vec3  ba = pb - pa;\n    vec3  oa = ro - pa;\n\n    float baba = dot(ba,ba);\n    float bard = dot(ba,rd);\n    float baoa = dot(ba,oa);\n    float rdoa = dot(rd,oa);\n    float oaoa = dot(oa,oa);\n\n    float a = baba      - bard*bard;\n    float b = baba*rdoa - baoa*bard;\n    float c = baba*oaoa - baoa*baoa - r*r*baba;\n    float h = b*b - a*c;\n    if( h>=0.0 )\n    {\n        float t = (-b-sqrt(h))/a;\n\n        float y = baoa + t*bard;\n        \n        // body\n        if( y>0.0 && y<baba ) return t;\n\n        // caps\n        vec3 oc = (y<=0.0) ? oa : ro - pb;\n        b = dot(rd,oc);\n        c = dot(oc,oc) - r*r;\n        h = b*b - c;\n        if( h>0.0 )\n        {\n            return -b - sqrt(h);\n        }\n    }\n    return -1.0;\n}\n\nfloat sdPlane( vec3 p )\n{\n\treturn p.y;\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n\tvec3 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h ) - r;\n}\n\nfloat sdCylinder( vec3 p, vec3 c )\n{\n  return length(p.xz-c.xy)-c.z;\n}\n\nvec2 opUnion( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nfloat iPlane( in vec3 ro, in vec3 rd )\n{\n    return (-1.0 - ro.y)/rd.y;\n}\n\nvec2 map(in vec3 pos)\n{\n    vec2 dm = vec2(10000.0, -1.0);\n    \n    dm = vec2(sdPlane(pos), 1.0);\n    \n    for(int i=0; i<4; ++i)\n    {\n        float fi = float(i);     \n        \n        float x = float(i - ((i/4)*4));\n        float y = float(i/4) * 1.0;    \t\n        \n        dm = opUnion( dm, vec2(sdCapsule(pos,vec3(x - 2.25,y+1.25 + sin(iTime + fi),-0.5), \n                                             vec3(x - 0.75,y+1.25 + cos(iTime + fi), 1.0),\n                                         0.1 + CAPSULE_RADIUS * fi), 4.0 ));\n    }       \n       \n    return dm;\n}\n\nvec2 castRay( in vec3 ro, in vec3 rd )\n{\n    float tmin = 0.01;\n    float tmax = 20.0;\n\n\tfloat precis = 0.002;\n    float t = tmin;\n    float m = -1.0;\n    for( int i=0; i<50; i++ )\n    {\n\t    vec2 res = map( ro+rd*t );\n        if( res.x<precis || t>tmax ) break;\n        t += res.x;\n\t    m = res.y;\n    }\n\n    if( t>tmax ) m=-1.0;\n    return vec2( t, m );\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n\tvec3 eps = vec3( 0.001, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t    map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n\t    map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n\t    map(pos+eps.yyx).x - map(pos-eps.yyx).x );\n\treturn normalize(nor);\n}\n\nfloat raytracedAO(in vec3 pos, in vec3 normal, in vec4 random, in float maxDistance)\n{\n    vec3  ru  = normalize( cross( normal, vec3(0.0,1.0,1.0) ) );\n    vec3  rv  = normalize( cross( ru, normal ) );    \n\n    float occ = 0.0;\n    for( int i=0; i<AO_RAYCOUNT; i++ )\n    {\n        vec2  aa = hash2( random.x + float(i)*203.1 );\n        float ra = sqrt(aa.y);\n        float rx = ra*cos(6.2831*aa.x); \n        float ry = ra*sin(6.2831*aa.x);\n        float rz = sqrt( 1.0-aa.y );\n        vec3  dir = vec3( rx*ru + ry*rv + rz*normal );      \n\n        for(int u=0; u<4; ++u)\n        {\n            float fi = float(u);     \n        \n            float x = float(u - ((u/4)*4));\n            float y = float(u/4) * 1.0;    \t\n                \n            float distance = capIntersect(pos, normalize(dir), vec3(x - 2.25,y+1.25 + sin(iTime + fi),-0.5), \n                                             vec3(x - 0.75,y+1.25 + cos(iTime + fi), 1.0),\n                                         0.1 + CAPSULE_RADIUS * fi);\n                                         \n            if (distance > 0.01)                           \n            {\n                occ+= 1.0;\n                break;\n            }\n        }                \n    }\n    occ /= float(AO_RAYCOUNT);\n    \n    return clamp(1.0 - occ, 0.0, 1.0);\n}\n\n\n// https://www.shadertoy.com/view/lsjXDc\nfloat acosFast( float y )\n{\n    float x = abs( clamp(y,-1.0,1.0) );\n    float z = (-0.168577*x + 1.56723) * sqrt(1.0 - x);\n    return mix( 0.5*3.1415927, z, sign(y) );\n}\n\nvec3 closestPointOnLine(in vec3 a, in vec3 b, in vec3 point)\n{\n    vec3 ab = b - a;\n    float t = dot(point-a, ab) / dot(ab, ab);\n    return a + t * ab;\n}\n\nvec3 closestPointOnSegment(in vec3 a, in vec3 b, in vec3 point)\n{\n    vec3 ab = b - a;\n    float t = dot(point-a, ab) / dot(ab, ab);\n    return a + clamp(t, 0.0, 1.0) * ab;\n}    \n\nfloat Fpo(float d, float l)\n{\n    return l/(d*(d*d + l*l)) + atan(l/d)/(d*d);\n}\n\nfloat Fwt(float d, float l)\n{\n    return l*l/(d*(d*d + l*l));\n}\n\nfloat I_diffuse_line(vec3 p1, vec3 p2)\n{\n    // tangent\n    vec3 wt = normalize(p2 - p1);\n\n    // clamping\n    if (p1.z <= 0.0 && p2.z <= 0.0) return 0.0;\n    if (p1.z < 0.0) p1 = (+p1*p2.z - p2*p1.z) / (+p2.z - p1.z);\n    if (p2.z < 0.0) p2 = (-p1*p2.z + p2*p1.z) / (-p2.z + p1.z);\n\n    // parameterization\n    float l1 = dot(p1, wt);\n    float l2 = dot(p2, wt);\n\n    // shading point orthonormal projection on the line\n    vec3 po = p1 - l1*wt;\n\n    // distance to line\n    float d = length(po);\n\n    // integral\n    float I = (Fpo(d, l2) - Fpo(d, l1)) * po.z +\n              (Fwt(d, l2) - Fwt(d, l1)) * wt.z;\n    return I/PI;\n}\n\nfloat sphereAO(in vec3 spherePosition, in float radius, in vec3 point, in vec3 normal)\n{\n    vec3 sphereUnormL = spherePosition - point;\n    vec3 sphereL = normalize ( sphereUnormL );\n    float sqrSphereDistance = dot ( sphereUnormL , sphereUnormL );\n    \n    float sphereOcc = clamp(dot(sphereL, normal), 0.0, 1.0) *\n           ((radius * radius)/sqrSphereDistance);\n    \n    return sphereOcc;\n}\n\nfloat lineAO(in vec3 a, in vec3 b, float radius, in vec3 point, in vec3 normal)\n{\n\t // no ambient occlusion if we're in the capsule\n    if (sdCapsule(point, a, b, radius) < 0.0)\n        return 1.0;    \t\n    \n    vec3  T1  = normalize( cross( normal, vec3(0.0,1.0,1.0) ) );\n    vec3  T2  = normalize( cross( T1, normal ) );    \n    mat3 toObjectSpace = transpose(mat3(T1, T2, normal));\n    \n    \n    vec3 p1 = mul(toObjectSpace, a-point);\n    vec3 p2 = mul(toObjectSpace, b-point);\n    \n    float occ = radius * I_diffuse_line(p1, p2);\n    \n    vec3 spherePosition = closestPointOnSegment(a, b, point);\n    \n    // hack: AO of the hemisphere ~= sphereAO / 2\n    occ += sphereAO(spherePosition, radius, point, normal) / 2.0;    \n    \n    return 1.0 - min(1.0, occ);\n}\n\n\n\nfloat analyticalLineAO(in vec3 point, in vec3 normal)\n{\n    float occ = 1.0;\n    \n    for(int i=0; i<4; ++i)\n    {\n        float fi = float(i);\n        float x = float(i - ((i/4)*4));\n        float y = float(i/4) * 1.0;    \t\n        \n        occ *= lineAO(vec3(x - 2.25,y+1.25 + sin(iTime + fi),-0.5), \n                         vec3(x - 0.75,y+1.25 + cos(iTime + fi), 1.0),\n                         0.1 + CAPSULE_RADIUS * fi, point, normal);\n    }\n    \n    return occ;    \n}\n\n\n// sky\nvec3 getSkyColor(vec3 e) {\n    e.y = max(e.y,0.0);\n    vec3 ret;\n    ret.x = pow(1.0-e.y,2.0);\n    ret.y = 1.0-e.y;\n    ret.z = 0.6+(1.0-e.y)*0.4;\n    return ret;\n}\n\nvec3 render( in vec3 ro, in vec3 rd, in vec4 random, in vec2 CSCoord)\n{ \n    float split = (2.0*iMouse.x-iResolution.x) / iResolution.y;\n    if( iMouse.z<0.001 ) split=0.0;\n   \n    vec3 col = vec3(0.8, 0.9, 1.0);\n    vec3 albedo = vec3(0.0, 0.0, 0.0);\n    vec3 light = normalize( vec3(-0.6, 0.7, -0.5) );\n    vec2 res = castRay(ro,rd);\n    float t = res.x;\n\tfloat m = res.y;\n    if( m>-0.5 )\n    {               \n        vec3 pos = ro + t*rd;\n        vec3 normal = calcNormal( pos );\n       \n       \n        vec3 skyColor = clamp(normal.y, 0.0, 1.0)*getSkyColor(normal);\n                           \n        float t1 = iPlane( ro, rd );\n        float ao = 0.0;\n    \tif( CSCoord.x>split )            \n        \tao = analyticalLineAO(pos, normal);\n        #ifdef VS_CAPSULEAO\n       \telse             \n        \tao = analyticalCapsuleAO(pos, normal);\n        #else\n\t\telse             \n        \tao = raytracedAO(pos, normal, random, 100.0);\n        #endif\n        \n        col = vec3(ao);          \n    }   \n    else\n        col = getSkyColor(rd);\n    \n    return col;\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float split = (2.0*iMouse.x-iResolution.x) / iResolution.y;\n    if( iMouse.z<0.001 ) split=0.0;\n\tvec2 q = fragCoord.xy/iResolution.xy;\n    vec2 p = -1.0+2.0*q;\n\tp.x *= iResolution.x/iResolution.y;    \n\t\t \n\tfloat time = 15.0 + iTime;\n    \n    vec4 random = texture( iChannel0, (fragCoord.xy)/iChannelResolution[0].xy, -99.0  ).xzyw;\n\n\t// camera\t\n\tvec3 ro = vec3( 5.0*cos(0.1*time + 6.0), 2.0, 5.0*sin(0.1*time + 6.0) );\n\tvec3 ta = vec3( 0.5, 0.0, 0.0);\n\t\n\t// camera-to-world transformation\n    mat3 ca = setCamera( ro, ta, 0.0 );\n    \n    // ray direction\n\tvec3 rd = ca * normalize( vec3(p.xy,2.0) );\n    \n\t// render\t\n    vec3 col = render( ro, rd, random, p);\n    \n    float e = 2.0/iResolution.y;\n    col *= smoothstep( 0.0, 2.0*e, abs(p.x - split) );\n\t\n\n    fragColor=vec4( col, 1.0 );\n}","name":"Image","description":"","type":"image"}]}