{"ver":"0.1","info":{"id":"4ctBz8","date":"1732878388","viewed":44,"name":"Cellular \"noise\" demo (2D)","username":"stegu","description":"Demonstration of an updated \"cellular\" function of mine. I made a first version of this in 2011, but with GPU capabilities and shader compilers having evolved a lot, vectorizing code by hand like I did back then is now an exercise in futility.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["voronoi","worley","cellular"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-iResolution.xy*0.5)/min(iResolution.x, iResolution.y);\n\n    vec2 F;\n    vec2 P1;\n    float ID1;\n    vec3 col;\n    \n    F = cellular(uv*8.0, abs(cos(iTime*2.0)), P1, ID1);\n\n    if(uv.x < sin(iTime)) {\n         // Use dot(P1,P1) instead of F.x*F.x, just for demo\n        col = vec3(1.0-2.0*dot(P1,P1));\n    }\n    else {\n        // The classic \"Voronoi\" pattern, with color to make use of ID1\n        col = vec3(sqrt(F.y-F.x));\n        col *= vec3((mod(ID1,41.0)+24.0)/64.0, 1.0 - ID1/512.0, 0.0);\n    }\n\n    fragColor = vec4(col,1.0);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// Cellular noise (\"Worley noise\") in 2D.\n// Version 2024-11-29, by Stefan Gustavson.\n// Published under the CC-BY-SA 4.0 license:\n// https://creativecommons.org/licenses/by-sa/4.0/\n\n// Cellular noise, returning F1 and F2 in a vec2,\n// the offset from P to the nearest point P1\n// in an \"out\" parameter vec2 P1, and the hashed\n// Voronoi cell ID in an \"out\" parameter float ID1.\n// 3x3 search window for good F1 and F2 values.\n//\n// Explicit loops, compact code that's easy to read.\n// Not *quite* as fast as a vectorized version, but\n// on modern platforms the difference is marginal.\n//\nfloat permute289(float x) {\n  return mod((34.0 * x + 10.0) * x, 289.0);\n}\nvec2 cellular(vec2 P, float jitter, out vec2 P1, out float ID1) {\n    jitter = clamp(jitter,0.0,1.0);\n    vec2 P0 = floor(P);\n\tvec2 Pi = mod(P0, 289.0);\n\tvec2 Pf = P0-P; // Vector from P to closest unjittered grid point P0\n\tfloat px, pxy;\n\tfloat d, d1, d2;\n\tfloat ox, oy, dx, dy;\n\td1 = d2 = 8.0; // Init to distances larger than any actual outcome\n\tfor(float ix = -1.0; ix <=1.0; ix++) {\n\t\tpx = permute289(Pi.x + ix);\n\t\tfor(float iy = -1.0; iy <= 1.0; iy++) {\n\t\t\tpxy = permute289(px + Pi.y + iy);\n\t\t\tox = fract(pxy/7.0) - 0.5;\n\t\t\toy = mod(floor(pxy/7.0), 7.0)/7.0 - 0.5;\n\t\t\tdx = Pf.x + ix + jitter*ox + 0.5;\n\t\t\tdy = Pf.y + iy + jitter*oy + 0.5;\n\t\t\td = dx*dx + dy*dy; // Distance from P to Pn, squared\n            // d could replace either d1 or d2, handle both cases\n\t\t\td2 = (d <= d1 ? d1 : (d<= d2 ? d : d2));\n\t\t\tP1 = (d <= d1 ? vec2(dx,dy) : P1);\n\t\t\tID1 = (d <= d1 ? pxy : ID1);\n\t\t\td1 = (d <= d1 ? d : d1);\n\t\t}\n\t}\n\treturn(sqrt(vec2(d1, d2)));\n}\n\n// Permutation polynomial: (34x^2 + 10x) mod 289\nvec3 permute289(vec3 x) {\n  return mod((34.0 * x + 10.0) * x, 289.0);\n}\n\n// Cellular noise, returning F1 and F2 in a vec2.\n// Standard 3x3 search window for good F1 and F2 values.\nvec2 cellular_optimized(vec2 P) {\n\n#define K 0.142857142857 // 1/7\n#define Ko 0.428571428571 // 3/7\n#define jitter 1.0 // Less gives a more regular pattern\n\n    vec2 P0 = floor(P);\n\tvec2 Pi = mod(P0, 289.0);\n \tvec2 Pf = fract(P);\n\tvec3 oi = vec3(-1.0, 0.0, 1.0);\n\tvec3 of = vec3(-0.5, 0.5, 1.5);\n\tvec3 px = permute289(Pi.x + oi);\n\tvec3 p1i = permute289(px.x + Pi.y + oi); // p11, p12, p13\n\tvec3 ox1 = fract(p1i*K) - Ko;\n\tvec3 oy1 = mod(floor(p1i*K), 7.0)*K - Ko;\n\tvec3 dx1 = Pf.x + 0.5 + jitter*ox1;\n\tvec3 dy1 = Pf.y - of + jitter*oy1;\n\tvec3 d1 = dx1 * dx1 + dy1 * dy1; // d11, d12 and d13, squared\n\tvec3 p2i = permute289(px.y + Pi.y + oi); // p21, p22, p23\n\tvec3 ox2 = fract(p2i*K) - Ko;\n\tvec3 oy2 = mod(floor(p2i*K), 7.0)*K - Ko;\n\tvec3 dx2 = Pf.x - 0.5 + jitter*ox2;\n\tvec3 dy2 = Pf.y - of + jitter*oy2;\n\tvec3 d2 = dx2 * dx2 + dy2 * dy2; // d21, d22 and d23, squared\n\tvec3 p3i = permute289(px.z + Pi.y + oi); // p31, p32, p33\n\tvec3 ox3 = fract(p3i*K) - Ko;\n\tvec3 oy3 = mod(floor(p3i*K), 7.0)*K - Ko;\n\tvec3 dx3 = Pf.x - 1.5 + jitter*ox3;\n\tvec3 dy3 = Pf.y - of + jitter*oy3;\n\tvec3 d3 = dx3 * dx3 + dy3 * dy3; // d31, d32 and d33, squared\n\n    // Select the two smallest distances (F1, F2)\n\t// by 8 + 7 comparisons (a partial swap sort)\n\td1.xy = (d1.x < d1.y ? d1.xy : d1.yx);\n\td1.xz = (d1.x < d1.z ? d1.xz : d1.zx);\n\td2.xy = (d2.x < d2.y ? d2.xy : d2.yx);\n\td2.xz = (d2.x < d2.z ? d2.xz : d2.zx);\n\td3.xy = (d3.x < d3.y ? d3.xy : d3.yx);\n\td3.xz = (d3.x < d3.z ? d3.xz : d3.zx);\n\tvec3 d1a = vec3(d1.x, d2.x, d3.x); // Candidates for first place\n\td1a.xy = (d1a.x < d1a.y ? d1a.xy : d1a.yx);\n\td1a.xz = (d1a.x < d1a.z ? d1a.xz : d1a.zx);\n\t// Find second closest point\n\td1.yz = (d1.y < d1.z ? d1.yz : d1.zy);\n\td2.yz = (d2.y < d2.z ? d2.yz : d2.zy);\n\td3.yz = (d3.y < d3.z ? d3.yz : d3.zy);\n\td1a.yz = (d1a.y < d1a.z ? d1a.yz : d1a.zy);\n\tvec4 d2a = vec4(d1a.y, d1.y, d2.y, d3.y);\n\td2a.xy = (d2a.x < d2a.y ? d2a.xy : d2a.yx);\n\td2a.xz = (d2a.x < d2a.z ? d2a.xz : d2a.zx);\n\td2a.xw = (d2a.x < d2a.w ? d2a.xw : d2a.wx);\n\treturn sqrt(vec2(d1a.x, d2a.x));\n}\n\n// Cellular noise, returning F1 and F2 in a vec2,\n// the offset from P to the nearest point P1\n// in an \"out\" parameter vec2 P1, and the hashed\n// Voronoi cell ID in an \"out\" parameter float ID1.\n// 3x3 search window for good F1 and F2 values.\nvec2 cellular_optimized(vec2 P, out vec2 P1, out float ID1) {\n\n#define K 0.142857142857 // 1/7\n#define Ko 0.428571428571 // 3/7\n\n    vec2 P0 = floor(P);\n\tvec2 Pi = mod(P0, 289.0);\n \tvec2 Pf = fract(P);\n\tvec3 oi = vec3(-1.0, 0.0, 1.0);\n\tvec3 of = vec3(-0.5, 0.5, 1.5);\n\tvec3 px = permute289(Pi.x + oi);\n\tvec3 p1i = permute289(px.x + Pi.y + oi); // p11, p12, p13\n\tvec3 ox1 = fract(p1i*K) - Ko;\n\tvec3 oy1 = mod(floor(p1i*K), 7.0)*K - Ko;\n\tvec3 dx1 = Pf.x + 0.5 + jitter*ox1;\n\tvec3 dy1 = Pf.y - of + jitter*oy1;\n\tvec3 d1 = dx1 * dx1 + dy1 * dy1; // d11, d12 and d13, squared\n\tvec3 p2i = permute289(px.y + Pi.y + oi); // p21, p22, p23\n\tvec3 ox2 = fract(p2i*K) - Ko;\n\tvec3 oy2 = mod(floor(p2i*K), 7.0)*K - Ko;\n\tvec3 dx2 = Pf.x - 0.5 + jitter*ox2;\n\tvec3 dy2 = Pf.y - of + jitter*oy2;\n\tvec3 d2 = dx2 * dx2 + dy2 * dy2; // d21, d22 and d23, squared\n\tvec3 p3i = permute289(px.z + Pi.y + oi); // p31, p32, p33\n\tvec3 ox3 = fract(p3i*K) - Ko;\n\tvec3 oy3 = mod(floor(p3i*K), 7.0)*K - Ko;\n\tvec3 dx3 = Pf.x - 1.5 + jitter*ox3;\n\tvec3 dy3 = Pf.y - of + jitter*oy3;\n\tvec3 d3 = dx3 * dx3 + dy3 * dy3; // d31, d32 and d33, squared\n\n    // Sort out the two smallest distances (F1, F2)\n\t// *and* keep track of the position and hash value\n\t// of the nearest point.\n    // This is a lot of code, but it executes fast. Apparently, the\n    // compiler cleverly re-uses the repeated conditions for the selections,\n    // and might even combine three lines into one \"select\" instruction.\n    // I'm *so* glad I timed this before I did the vectorization myself.\n\tID1 = (d1.x < d1.y ? p1i.x : p1i.y); // ID1, P1 are \"out\" parameters\n\tP1 = (d1.x < d1.y ? vec2(dx1.x, dy1.x) : vec2(dx1.y, dy1.y));\n\td1.xy = (d1.x < d1.y ? d1.xy : d1.yx);\n    ID1 = (d1.x < d1.z ? ID1 : p1i.z);\n\tP1 = (d1.x < d1.z ? P1 : vec2(dx1.z, dy1.z));\n\td1.xz = (d1.x < d1.z ? d1.xz : d1.zx);\n    float ID2 = (d2.x < d2.y ? p2i.x : p2i.y);\n\tvec2 P2 = (d2.x < d2.y ? vec2(dx2.x, dy2.x) : vec2(dx2.y, dy2.y));\n\td2.xy = (d2.x < d2.y ? d2.xy : d2.yx);\n\tID2 = (d2.x < d2.z ? ID2 : p2i.z);\n\tP2 = (d2.x < d2.z ? P2 : vec2(dx2.z, dy2.z));\n\td2.xz = (d2.x < d2.z ? d2.xz : d2.zx);\n\tfloat ID3 = (d3.x < d3.y ? p3i.x : p3i.y);\n\tvec2 P3 = (d3.x < d3.y ? vec2(dx3.x, dy3.x) : vec2(dx3.y, dy3.y));\n\td3.xy = (d3.x < d3.y ? d3.xy : d3.yx);\n\tID3 = (d3.x < d3.z ? ID3 : p3i.z);\n\tP3 = (d3.x < d3.z ? P3 : vec2(dx3.z, dy3.z));\n\td3.xz = (d3.x < d3.z ? d3.xz : d3.zx);\n\tvec3 d1a = vec3(d1.x, d2.x, d3.x); // Candidates for first place\n\tID1 = (d1a.x < d1a.y ? ID1 : ID2);\n\tP1 = (d1a.x < d1a.y ? P1 : P2);\n\td1a.xy = (d1a.x < d1a.y ? d1a.xy : d1a.yx);\n\tID1 = (d1a.x < d1a.z ? ID1 : ID3);\n\tP1 = (d1a.x < d1a.z ? P1 : P3);\n\td1a.xz = (d1a.x < d1a.z ? d1a.xz : d1a.zx);\n\t// Find second closest point (distance only)\n\td1.yz = (d1.y < d1.z ? d1.yz : d1.zy);\n\td2.yz = (d2.y < d2.z ? d2.yz : d2.zy);\n\td3.yz = (d3.y < d3.z ? d3.yz : d3.zy);\n\td1a.yz = (d1a.y < d1a.z ? d1a.yz : d1a.zy);\n\tvec4 d2a = vec4(d1a.y, d1.y, d2.y, d3.y);\n\td2a.xy = (d2a.x < d2a.y ? d2a.xy : d2a.yx);\n\td2a.xz = (d2a.x < d2a.z ? d2a.xz : d2a.zx);\n\td2a.xw = (d2a.x < d2a.w ? d2a.xw : d2a.wx);\n\n    return sqrt(vec2(d1a.x, d2a.x));\n}\n#undef jitter\n","name":"Common","description":"","type":"common"}]}