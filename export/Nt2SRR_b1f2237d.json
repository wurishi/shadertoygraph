{"ver":"0.1","info":{"id":"Nt2SRR","date":"1626928629","viewed":115,"name":"Mandelbrot plotter","username":"falconXYZ","description":"Mandelbrot plotter","likes":0,"published":1,"flags":48,"usePreview":0,"tags":["fractal","mandelbrot"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Arrow Keys to move\n//Plus & Minus Keys to zoom in\n//Space Key to reset zoom\n//Because of the limitations of float, the zoom is not infinite\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv.x *= 3.5;\n    uv.x -= 2.5;\n    \n    uv.y *= 2.0;\n    uv.y -= 1.0;\n    \n    vec2 offset = texelFetch( iChannel0, ivec2(0,0), 0 ).xy;\n   // uv += offset;\n    \n    float zoom = texelFetch( iChannel1, ivec2(0,0), 0).x;\n   // uv -= offset;\n    uv *= zoom;\n    uv += offset;\n    \n    \n    float x0 = uv.x;\n    float y0 = uv.y;\n    float x = 0.0;\n    float y = 0.0;\n    float iteration = 0.0;\n    float max_iteration = 80.0 / pow(zoom, 0.2);\n    while (x*x + y*y <= 2.0*2.0 && iteration < max_iteration) {\n        float xtemp = x*x - y*y + x0;\n        y = 2.0*x*y + y0;\n        x = xtemp;\n        iteration = iteration + 1.0;\n    }\n    \n    //if (iteration/max_iteration < 0.5)\n      //  fragColor = vec4(iteration/max_iteration,iteration/max_iteration,0.0,1.0);\n    //else\n        fragColor = vec4(0.0,iteration/max_iteration,0.0,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Numbers are based on JavaScript key codes: https://keycode.info/\nconst int KEY_LEFT  = 37;\nconst int KEY_UP    = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN  = 40;\n\nvec2 handleKeyboard(vec2 offset) {\n    float velocity = 1. / 100.; // This will cause offset to change by 0.01 each time an arrow key is pressed\n    \n    // texelFetch(iChannel1, ivec2(KEY, 0), 0).x will return a value of one if key is pressed, zero if not pressed\n    vec2 left = texelFetch(iChannel1, ivec2(KEY_LEFT, 0), 0).x * vec2(-1, 0);\n    vec2 up = texelFetch(iChannel1, ivec2(KEY_UP,0), 0).x * vec2(0, 1);\n    vec2 right = texelFetch(iChannel1, ivec2(KEY_RIGHT, 0), 0).x * vec2(1, 0);\n    vec2 down = texelFetch(iChannel1, ivec2(KEY_DOWN, 0), 0).x * vec2(0, -1);\n    \n    float zoom = texelFetch( iChannel2, ivec2(0,0), 0).x;\n\n    \n    offset += (left + up + right + down) * velocity * zoom;\n\n    return offset;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Return the offset value from the last frame (zero if it's first frame)\n    vec2 offset = texelFetch( iChannel0, ivec2(0, 0), 0).xy;\n    \n    // Pass in the offset of the last frame and return a new offset based on keyboard input\n    offset = handleKeyboard(offset);\n\n    // Store offset in the XY values of every pixel value and pass this data to the \"Image\" shader and the next frame of Buffer A\n    fragColor = vec4(offset, 0, 0);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// Numbers are based on JavaScript key codes: https://keycode.info/\nconst int KEY_PLUS  = 187;\nconst int KEY_MINUS = 189;\nconst int KEY_SPACE = 32;\n\nfloat handleKeyboard(float offset) {\n    float velocity = 1. / 100.; // This will cause offset to change by 0.01 each time an arrow key is pressed\n    \n    // texelFetch(iChannel1, ivec2(KEY, 0), 0).x will return a value of one if key is pressed, zero if not pressed\n    vec2 zin = texelFetch(iChannel1, ivec2(KEY_PLUS, 0), 0).x * vec2(-1, 0);\n    vec2 zout = texelFetch(iChannel1, ivec2(KEY_MINUS,0), 0).x * vec2(1, 0);\n    \n    offset *= 1.0 + (zin.x + zout.x) * velocity;\n    \n    vec2 space = texelFetch(iChannel1, ivec2(KEY_SPACE,0), 0).x * vec2(1, 0);\n    \n    if (space.x == 1.0)\n        offset = 1.0;\n\n    return offset;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Return the offset value from the last frame (zero if it's first frame)\n    float offset;\n    if (iFrame>5)\n        offset = texelFetch( iChannel0, ivec2(0, 0), 0).x;\n    else\n        offset = 1.0;\n    \n    // Pass in the offset of the last frame and return a new offset based on keyboard input\n    offset = handleKeyboard(offset);\n\n    // Store offset in the XY values of every pixel value and pass this data to the \"Image\" shader and the next frame of Buffer A\n    fragColor = vec4(offset, 0, 0, 0);\n}","name":"Buffer B","description":"","type":"buffer"}]}