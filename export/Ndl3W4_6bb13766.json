{"ver":"0.1","info":{"id":"Ndl3W4","date":"1663792914","viewed":114,"name":"Chosen Smoke","username":"Chosen","description":"Trying to make smoke (Unfinished)","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["simplex","smoke"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// https://en.wikipedia.org/wiki/Diamond-square_algorithm\n\n\n// Dave Hoskins - Hash without Sine\n// https://www.shadertoy.com/view/4djSRW\n//#define hash22(v) hash22d(v)\nvec2 hash22d(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n#define hash22(v) hash22i(v)\nvec2 hash22i( vec2 p ) // replace this by something better\n{\n\tp = vec2( dot(p,vec2(127.1,311.7)), dot(p,vec2(269.5,183.3)) );\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\n// Hash Functions for GPU Rendering\n// https://www.shadertoy.com/view/XlGcRh\n//#define hash22(v) (vec2(pcg3d(uvec3(int(v * 100000.), 1u, 1u)).xy) / 1000000.)\nuvec2 pcg2d(uvec2 v)\n{\n    v = v * 1664525u + 1013904223u;\n\n    v.x += v.y * 1664525u;\n    v.y += v.x * 1664525u;\n\n    v = v ^ (v>>16u);\n\n    v.x += v.y * 1664525u;\n    v.y += v.x * 1664525u;\n\n    v = v ^ (v>>16u);\n\n    return v;\n}\n\nuvec3 pcg3d(uvec3 v) {\n\n    v = v * 1664525u + 1013904223u;\n\n    v.x += v.y*v.z;\n    v.y += v.z*v.x;\n    v.z += v.x*v.y;\n\n    v ^= v >> 16u;\n\n    v.x += v.y*v.z;\n    v.y += v.z*v.x;\n    v.z += v.x*v.y;\n\n     return v;\n}\n\nuint lowbias32(uint x)\n{\n    x ^= x >> 16;\n    x *= 0x7feb352dU;\n    x ^= x >> 15;\n    x *= 0x846ca68bU;\n    x ^= x >> 16;\n    return x;\n}\n\n// clean 2D hash\n//#define hash22(x) bestHash(x)\n#define hashi(x)   lowbias32(x)\n//#define hashi(x)   triple32(x) \n#define hash(x)  ( float( hashi(x) ) / float( 0xffffffffU ) )\nvec2 bestHash(vec2 x) {\n    uvec2 V = uvec2(x);\n    float h = hash( V.x + hashi(V.y) ); // clean 2D hash\n  //float h = hash( V.x + (V.y<<16) );  // 2D hash (should be ok too )\n    return vec2(h);\n}\n// nikat - 3d simplex noise\n// https://www.shadertoy.com/view/XsX3zB\n\n// Inigo Quilez - Noise - simplex - 2D \n// https://www.shadertoy.com/view/Msf3WH\nfloat noise( in vec2 p )\n{\n    const float K1 = 0.366025404; // (sqrt(3)-1)/2;\n    const float K2 = 0.211324865; // (3-sqrt(3))/6;\n\n\tvec2  i = floor( p + (p.x+p.y)*K1 );\n    vec2  a = p - i + (i.x+i.y)*K2;\n    float m = step(a.y,a.x); \n    vec2  o = vec2(m,1.0-m);\n    vec2  b = a - o + K2;\n\tvec2  c = a - 1.0 + 2.0*K2;\n    vec3  h = max( 0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\n\tvec3  n = h*h*h*h*vec3( dot(a,hash22(i+0.0)), dot(b,hash22(i+o)), dot(c,hash22(i+1.0)));\n    return dot( n, vec3(70.0) );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 p = fragCoord.xy / iResolution.xy;\n\tvec2 uv = 5.* p*vec2(iResolution.x/iResolution.y,1.0);\n    uv -= vec2(2.5);\n\n    float f = 0.;\n//    mat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );\n    mat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );\n    m *= .1 * (10. - iTime);\n    vec2 ouv = uv;\n    f  = 0.5000*noise( uv ); uv = m*uv;\n    f += 0.2500*noise( uv ); uv = m*uv;\n    f += 0.1250*noise( uv ); uv = m*uv;\n    f += 0.0625*noise( uv ); uv = m*uv;\n\tf = 0.5 + 0.5*f;\n    f *= smoothstep(2.5, 0., length(ouv));\n    //step(.2, length(uv));\n    \n    fragColor = vec4(vec3(f),1.0);\n}","name":"Image","description":"","type":"image"}]}