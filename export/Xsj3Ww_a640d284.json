{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"#define PI\t\t\t\t\t3.14159265359\n#define PIH \t\t\t\t(PI/2.0)\n#define PIQ \t\t\t\t(PI/4.0)\n#define PI2 \t\t\t\t(PI*2.0)\n#define MARCH_SCALE\t\t\t0.65\n#define MARCH_STEPS\t\t\t72\n#define PRECISION\t\t\t0.001\n#define GLOW_SPHERE_SIZE\t0.1\n#define LIGHT_COLOR\t\t\tvec3(1.0, 0.9, 0.6)*1.6\n\nfloat GetTime()\t\t\t\t\t\t\t\t\t{return iTime * 0.1;}\nvec3 GetRayDir(vec2 inTC, vec2 inAspectRatio)\t{return normalize(vec3((-0.5 + inTC)*1.2 * inAspectRatio, 1.0));}\nmat3 RotX(float a)\t\t\t\t\t\t\t\t{float s = sin(a); float c = cos(a); return mat3(1,0,0,0,c,s,0,-s,c);}\nmat3 RotY(float a)\t\t\t\t\t\t\t\t{float s = sin(a); float c = cos(a); return mat3(c,0,-s,0,1,0,s,0,c);}\nmat3 tm(mat3 m)\n{\n\treturn mat3(\n\t\tm[0][0], m[1][0], m[2][0],\n\t\tm[0][1], m[1][1], m[2][1],\n\t\tm[0][2], m[1][2], m[2][2]\n\t);\n}\n\n\n// Any fraction  in range of (0.0, 0.5] will suffice. 1.0/3.0 = 6 instantiations\nvec3 InstantiateRotY(vec3 p, float inPiFrac)\n{\n\tfloat rad\t\t= mod(atan(p.x, p.z) +  PIH*inPiFrac, PI*inPiFrac) - PIH*inPiFrac;\n\tp.xz\t\t\t= vec2(sin(rad), cos(rad)) * length(p.xz);\n\treturn p;\n}\n\n\nfloat Ground(vec3 p)\n{\n\treturn length(p.y-0.01);\n}\n\n\nfloat GlowSphere(vec3 p)\n{\n\tp.y -= 2.0;\n\treturn length(p) - GLOW_SPHERE_SIZE;\n}\n\nfloat Leaf(vec3 p, float offset)\n{\n\tp.y = clamp(p.y, 0.0, 2.5); // set range\n\tp.z -= offset*0.95 - 0.03;\t// offset\n\tp.y\t= mod(p.y, 0.1)-0.05;\t// repeat\n\tp.z -= abs(p.y + 0.05)*1.2; // stretch\n\t\n\treturn length(p) - 0.02;\n}\n\nfloat Branch(vec3 p, float rnd)\n{\n\tfloat hMax\t\t= 2.5;\n\tfloat hScalePos\t= clamp(p.y / hMax, 0.0, 1.0);\n\tfloat h\t\t\t= abs(p.y-hMax*0.5) - hMax*0.5;\n\t\n\tp.x\t\t\t\t+= 0.12;\n\t// Bend-Rotate Body\n\tp\t\t\t\t= RotY(hScalePos * PI * 1.5) * p;\n\t\n\t// Stretch\n\tfloat animS\t\t= mix(0.1, 1.0, sin(rnd * 123.1211)*0.5+0.5);\n\tfloat anim\t\t=  -sin(hScalePos * PI*4.0 + GetTime()*PI*animS ) * 0.1 * pow(hScalePos, 8.0);\n\tp.x\t\t\t\t+= sin(hScalePos * PI * 0.8) * hScalePos + anim;\n\t\n\t// Twist\n\tp\t\t\t\t= RotY(pow(hScalePos, 3.0) * PI2*2.0) * p;\n\t\n\t// Y - axis rotate-instantiation\n\tp\t\t\t\t= InstantiateRotY(p, 1.0/3.0);\n\t\t\n\tfloat wl\t\t= mix(0.2, 0.004, hScalePos);\n\tfloat branch \t= max(max(p.x-wl, p.z-wl), h);\n\tfloat leaf\t\t= Leaf(p, wl);\n\treturn min(branch, leaf);\n}\n\nfloat Branches(vec3 p)\n{\n\tfloat depthCurr\t= 1000.0;\n\tdepthCurr = min(depthCurr, Branch(p, 1.0));\n\tdepthCurr = min(depthCurr, Branch(RotY(PI2 * (1.0/3.0)) * p, 2.0));\n\tdepthCurr = min(depthCurr, Branch(RotY(PI2 * (2.0/3.0)) * p, 3.0));\n\treturn depthCurr;\n}\n\n\n#define OBJ(inOBJ, inMatID) depthPrev=depthCurr; depthCurr=min(depthCurr, inOBJ); if(depthCurr < depthPrev) matID = inMatID;\nvec2 Scene(vec3 p)\n{\n\tfloat depthCurr\t= 1000.0;\n\tfloat depthPrev\t= 1000.0;\n\tfloat matID\t\t= -1.0;\n\t\t\n\tOBJ(Ground(p), 0.0);\n\tOBJ(Branches(p), 1.0);\n\t\t\n\treturn vec2(depthCurr, matID);\n}\n\nfloat SceneGlow(vec3 p)\n{\t\t\n\treturn GlowSphere(p);\n}\n\nvec3 GasMat(vec3 p, float lightDist)\n{\n\tfloat dist\t= clamp(length(p.xz) * 0.3333, 0.0, 1.0);\n\tfloat fade\t= pow(1.0 / (1.0 + lightDist), 2.0) * 3.0;\n\treturn  mix(vec3(0.8, 1.0, 0.2), vec3(1.0, 0.5, 0.25), dist) * fade;\n}\n\nvec3 GetMaterial(vec3 ro, vec3 rd, vec3 p, vec3 n, vec2 res, vec3 inBackgroundColor)\n{\n\tvec3 color\t\t\t= inBackgroundColor;\n\tvec3 lightPos\t\t= vec3(0.0, 2.0, 0.0);\n\tvec3 lightDir\t\t= lightPos-p;\n\tfloat lightDist\t\t= length(lightDir);\n\tlightDir\t\t\t= lightDir / lightDist;\n\tfloat directLight\t= dot(n, lightDir);\n\t\t\n\tif(res.y == 0.0)\n\t{\n\t\tcolor\t\t\t\t= GasMat(p, lightDist);\n\t}\n\t\n\tif(res.y == 1.0)\n\t{\n\t\t// \"sss\"\n\t\tfloat sss\t\t\t= mix( pow(directLight*0.5 + 0.5, 2.1), clamp(1.0-directLight, 0.0, 1.0), 0.4);\n\t\tcolor\t\t\t\t=vec3(0.8, 0.6, 0.5) * sss * pow(1.0 / (1.0 + max(lightDist, 0.0)), 1.6) * 0.5;\n\t\t\n\t\tfloat lightFacing\t= pow(max(directLight, 0.0), 2.0);\n\t\tcolor\t\t\t\t+= vec3(0.6,0.7,0.45) * lightFacing * pow(1.0 / (1.0 + max(lightDist, 0.0)), 4.0) * 1.5;\n\t\t\n\t\t// Fade into the ground \"gas\"\n\t\tcolor\t\t\t\t= mix(GasMat(p, lightDist), color * LIGHT_COLOR, clamp(p.y, 0.0, 1.0));\n\t}\n\t\n\treturn color;\n}\n\nvec2 March(vec3 p, vec3 o)\n{\n\tvec2 r\t\t= vec2(1000.0, -1.0);\n\tfloat z\t\t= 0.0;\n\tfloat matID\t= -1.0;\n\t\n\tfor(int i=0; i<MARCH_STEPS; i++)\n\t{\n\t\tr = Scene(p + o*z);\n\t\tif(r.x < PRECISION)\n\t\t\tcontinue;\n\t\tz\t\t+=r.x*MARCH_SCALE;\n\t\tmatID\t= r.y;\n\t}\n\n\t\n\treturn vec2(z, matID);\n}\n\n\nvec2 GlowMarch(vec3 p, vec3 o)\n{\n\tfloat d\t\t= 1000.0;\n\tfloat z\t\t= 0.0;\n\tfloat acc\t= 0.0;\n\t\n\tfor(int i=0; i<15; i++)\n\t{\n\t\td\t= SceneGlow(p + o*z);\n\t\tacc\t+= max(1.0 - d, 0.0);\n\t\tz\t+= max(0.0, d);\n\t}\n\t\n\treturn vec2(acc / 16.0, z);\n}\n\nvec3 DistFieldNormal(vec3 p)\n{\t\n\tvec3 n;\n\tvec2 dn = vec2(0.01, 0.0);\n\tn.x\t= Scene(p + dn.xyy).x - Scene(p - dn.xyy).x;\n\tn.y\t= Scene(p + dn.yxy).x - Scene(p - dn.yxy).x;\n\tn.z\t= Scene(p + dn.yyx).x - Scene(p - dn.yyx).x;\n\treturn normalize(n);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\t\n\t// Construct simple ray\n\tvec2 aspect\t\t= vec2(iResolution.x/iResolution.y, 1.0);\n\tvec3 ro\t\t\t= vec3(0, 1.2, -3);\n\tvec3 rd\t\t\t= GetRayDir(uv, aspect);\n\t\n\t\n\t// Transform camera orientation\n\tmat3 ymat\t\t= RotY(PI2 * GetTime()*-0.03);\n\tmat3 xmat\t\t= RotX(PI2 * 0.10);\n\tmat3 mat\t\t= ymat * xmat;\n\t\n\tro\t\t\t\t= mat * ro;\n\trd\t\t\t\t= mat * rd;\n\t\t\n\t// Background color\n\tvec3 color\t\t= vec3(0.0, 0.0, 0.0);\n\t\n\tvec2 res\t\t\t= March(ro, rd);\n\tvec3 p;\n\tvec3 n;\n\tif(res.x > 0.0)\n\t{\n\t\tp\t\t= ro + rd*res.x;\n\t\tn\t\t= DistFieldNormal(p);\n\t\tcolor\t= GetMaterial(ro, rd, p, n, res, color);\n\t}\n\n\tvec2 gres\t= GlowMarch(ro, rd);\n\tfloat glowi\t= 1.0;\n\tif(res.y == 1.0)\n\t{\n\t\tfloat v = (tm(ymat) * p).z;\n\t\tglowi = smoothstep(0.0, 0.5, max(v, 0.0));\n\t}\n\t\t\t\n\tcolor\t\t+=gres.x * glowi * LIGHT_COLOR;\n\t\t\n\tfragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"Xsj3Ww","date":"1389286982","viewed":3602,"name":"LightThorn","username":"Vlad86","description":"Learned how to rotate-instantiate with atan() and mod(), used to create hexagonal cylinder + \"leafs/thorns\" on each side.\nThe glow is very hacky, the occlusion is faked with xy-depth comparison.","likes":64,"published":1,"flags":0,"usePreview":0,"tags":["3d","thorn","rotateinstantiate"],"hasliked":0,"parentid":"","parentname":""}}