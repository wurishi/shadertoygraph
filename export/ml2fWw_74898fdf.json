{"ver":"0.1","info":{"id":"ml2fWw","date":"1694207796","viewed":11,"name":"silly little box","username":"fennylol","description":"he sort of returned to form. in a way he is once again a box.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["box"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xdf3Rn","filepath":"/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm","previewfilepath":"/media/ap/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm","type":"video","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdXGzn","filepath":"/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","previewfilepath":"/media/ap/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//from https://iquilezles.org/articles/distfunctions/\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat sdOctahedron( vec3 p, float s )\n{\n  p = abs(p);\n  float m = p.x+p.y+p.z-s;\n  vec3 q;\n       if( 3.0*p.x < m ) q = p.xyz;\n  else if( 3.0*p.y < m ) q = p.yzx;\n  else if( 3.0*p.z < m ) q = p.zxy;\n  else return m*0.57735027;\n    \n  float k = clamp(0.5*(q.z-q.y+s),0.0,s); \n  return length(vec3(q.x,q.y-s+k,q.z-k)); \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //rotation matrices\n    float sy = sin(iTime);\n    float cy = cos(iTime);\n    float sx = sin(iTime / 2.0);\n    float cx = cos(iTime / 2.0);\n    mat3 rotX = mat3(\n        1.0, 0.0, 0.0,\n        0.0, cx,   sx,\n        0.0, -sx,  cx\n      );\n     \n     mat3 rotY = mat3(\n        cy, 0.0, -sy,\n        0.0, 1.0, 0.0,\n        sy, 0.0,  cy\n      );\n     \n     mat3 rotZ = mat3(\n        -cy,   -sy, 0.0,\n        sy,  -cy, 0.0, \n        0.0, 0.0, 1.0\n      ); \n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord/iResolution.xy);\n\n    // generate background \n    float rX = min(cos(iTime*0.5 + fragCoord.x/75.0), 0.4);\n    float gX = min(cos(iTime     + fragCoord.x/200.0), 0.6);\n    float bX = min(cos(iTime*1.5 - fragCoord.x/150.0), 0.8);\n    \n    float rY = min(cos(iTime*0.5 + fragCoord.y/220.0), 0.4);\n    float gY = min(cos(iTime     - fragCoord.y/300.0), 0.6);\n    float bY = min(cos(iTime*1.5 - fragCoord.y/100.0), 0.8);\n    \n    float r = max(rX, rY);\n    float g = max(gX, gY);\n    float b = max(bX, bY);\n    \n    vec3 col = vec3(r, g, b);\n    vec2 move = vec2(uv.x/10.0 + sin(iTime/30.0), uv.y/10.0 - cos(iTime/45.0));\n    col = mix(col,vec3(texture(iChannel0, move).rrr), 0.3);\n    \n    //define orthographic ray triplet\n    vec3 rayPt = vec3(uv.xy, 0);\n    vec3 rayPtdx = vec3(uv.x + 0.00001, uv.y,           0);\n    vec3 rayPtdy = vec3(uv.x,           uv.y + 0.00001, 0);\n    vec3 rayDir = vec3(0,0,1);\n    \n    float t = 0.0;\n    float tdx = 0.0;\n    float tdy = 0.0;\n    float tSphere = 0.0;\n    float tdxSphere = 0.0;\n    float tdySphere = 0.0;\n     \n    //define the cone\n    vec3 conePos = vec3(0.5,0.5,5.0);\n    vec2 coneC = vec2(0.707,0.707);\n    float coneH = 0.3;\n    \n    // define octahedron\n    vec3 ocPos = vec3(0.5, 0.5, 5.0);\n    float ocSize = 0.25;\n    \n    // define sphere\n    vec3 spherePos  = vec3(0.5, 0.5, 5.0);\n    float sphereSize = 0.12;\n    \n    //define lighting\n    vec3 lightDir = vec3(-0.1,-0.3,0.5);\n    vec3 objCol = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    //vec3(0.0,0.6,0.8);\n    \n    for(int i = 0; i < 20; i++){\n        //calculate a point 5 units along the ray\n        vec3 pos = rayPt + rayDir * t;    \n        vec3 posdx = rayPtdx + rayDir * tdx; \n        vec3 posdy = rayPtdy + rayDir * tdy;\n        \n        vec3 posSphere = rayPt + rayDir * tSphere;    \n        vec3 posdxSphere = rayPtdx + rayDir * tdxSphere; \n        vec3 posdySphere = rayPtdy + rayDir * tdySphere;\n        \n        // calculate distance to octahedron\n        float dist   = sdOctahedron(rotX*rotZ*(pos   - ocPos), ocSize);\n        float distdx = sdOctahedron(rotX*rotZ*(posdx - ocPos), ocSize);\n        float distdy = sdOctahedron(rotX*rotZ*(posdy - ocPos), ocSize);\n        \n        // calculate distance to sphere\n        float distSphere   = sdSphere(rotX*rotZ*(posSphere   - spherePos), sphereSize);\n        float distdxSphere = sdSphere(rotX*rotZ*(posdxSphere - spherePos), sphereSize);\n        float distdySphere = sdSphere(rotX*rotZ*(posdySphere - spherePos), sphereSize);\n        \n        // color appropriately\n        if(dist < 0.001 && distdx < 0.001 && distdy < 0.001){\n            col = objCol*dot(-lightDir,normalize(cross(posdy - pos, posdx - pos)));\n            \n            if(distSphere < 0.0005 && distdxSphere < 0.0005 && distdySphere < 0.0005){\n                col = 0.8*(1.0-col);\n            } \n        } \n        \n        t += dist;\n        tdx += distdx;\n        tdy += distdy;\n        \n        tSphere += distSphere;\n        tdxSphere += distdxSphere;\n        tdySphere += distdySphere;\n    }\n\n    // add britney spears\n    col = mix(col,vec3(texture(iChannel1, uv.xy).rrr), 0.05);\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}