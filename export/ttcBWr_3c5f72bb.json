{"ver":"0.1","info":{"id":"ttcBWr","date":"1612511427","viewed":209,"name":"Disney vs Deadmau5","username":"lumic","description":"Morphs between Mickey Mouse and Deadmau5\nBased on https://www.shadertoy.com/view/XsyGRW\nPlease excuse the messy code.","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["2d","sdf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// 0 = Distance Field Display\n// 1 = Raymarched Edges\n// 2 = Resulting Solid\n#define DISPLAY 0\n\nconst float PI = 3.14159265359;\n\nvec2 squareFrame(vec2 screenSize, vec2 coord) {\n  vec2 position = 2.0 * (coord.xy / screenSize.xy) - 1.0;\n  position.x *= screenSize.x / screenSize.y;\n  return position;\n}\n\nvec3 palette(float t, vec3 a, vec3 b, vec3 c, vec3 d) {\n  return a + b * cos(6.28318 * (c * t + d));\n}\n\n\nfloat circle(vec2 p, float r) {\n  return length(p) - r;\n}\n\nvec3 draw_line(float d, float thickness) {\n  const float aa = 3.0;\n  return vec3(smoothstep(0.0, aa / iResolution.y, max(0.0, abs(d) - thickness)));\n}\n\nvec3 draw_line(float d) {\n  return draw_line(d, 0.0025);\n}\n\nfloat draw_solid(float d) {\n  return smoothstep(0.0, 3.0 / iResolution.y, max(0.0, d));\n}\n\nvec3 draw_distance(float d, vec2 p) {\n  float t = clamp(d * 0.85, 0.0, 1.0);\n  vec3 grad = mix(vec3(1, 0.8, 0.5), vec3(0.3, 0.8, 1), t);\n\n  float d0 = abs(1.0 - draw_line(mod(d + 0.1, 0.2) - 0.1).x);\n  float d1 = abs(1.0 - draw_line(mod(d + 0.025, 0.05) - 0.025).x);\n  float d2 = abs(1.0 - draw_line(d).x);\n  vec3 rim = vec3(max(d2 * 0.85, max(d0 * 0.25, d1 * 0.06125)));\n\n  grad -= rim;\n  grad -= mix(vec3(0.05, 0.35, 0.35), vec3(0.0), draw_solid(d));\n\n  return grad;\n}\n\nfloat ellipse( in vec2 p, in vec2 ab )\n{\n    p = abs(p); if( p.x > p.y ) {p=p.yx;ab=ab.yx;}\n    float l = ab.y*ab.y - ab.x*ab.x;\n    float m = ab.x*p.x/l;      float m2 = m*m; \n    float n = ab.y*p.y/l;      float n2 = n*n; \n    float c = (m2+n2-1.0)/3.0; float c3 = c*c*c;\n    float q = c3 + m2*n2*2.0;\n    float d = c3 + m2*n2;\n    float g = m + m*n2;\n    float co;\n    if( d<0.0 )\n    {\n        float h = acos(q/c3)/3.0;\n        float s = cos(h);\n        float t = sin(h)*sqrt(3.0);\n        float rx = sqrt( -c*(s + t + 2.0) + m2 );\n        float ry = sqrt( -c*(s - t + 2.0) + m2 );\n        co = (ry+sign(l)*rx+abs(g)/(rx*ry)- m)/2.0;\n    }\n    else\n    {\n        float h = 2.0*m*n*sqrt( d );\n        float s = sign(q+h)*pow(abs(q+h), 1.0/3.0);\n        float u = sign(q-h)*pow(abs(q-h), 1.0/3.0);\n        float rx = -s - u - c*4.0 + 2.0*m2;\n        float ry = (s - u)*sqrt(3.0);\n        float rm = sqrt( rx*rx + ry*ry );\n        co = (ry/sqrt(rm-rx)+2.0*g/rm-m)/2.0;\n    }\n    vec2 r = ab * vec2(co, sqrt(1.0-co*co));\n    return length(r-p) * sign(p.y-r.y);\n}\n\nfloat box( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nvec2 rotate(vec2 p, float deg) {\n    float r = length(p);\n    float angle = atan(p.y, p.x);\n    float radians = angle + deg / 360.0 * (2.0 * PI);\n    return vec2(r * cos(radians), r * sin(radians));\n}\n\n\nfloat combine( float d1, float d2 ) { return min(d1,d2); }\nfloat difference( float d1, float d2 ) { return max(d1,-d2); }\nfloat intersect( float d1, float d2 ) { return max(d1,d2); }\n\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\nfloat opSmoothSubtraction( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); }\n\nfloat opSmoothIntersection( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.0-h); }\n\nfloat mixer() {\n    return (sin(iTime * 1.5) + 1.0) * 0.5;\n}\n\nfloat ear(vec2 p, float angle, float scale, vec2 e) {\n    return ellipse(rotate(p * scale, -angle), e);\n}\n\nfloat mickey(vec2 p) {\n    float d = circle(p, 0.5);\n    d = min(d, ear(p - vec2(0.5, 0.5), 120.0, 1.1,  vec2(0.4, 0.35)));\n    d = min(d, ear(p - vec2(-0.5, 0.5), -120.0, 1.1, vec2(0.4, 0.35)));\n    return d;\n}\n\nfloat eye(vec2 p, float angle, float t) {\n    float d = 2.0;\n    vec2 pr = rotate(p, angle);\n    return opSmoothIntersection(        \n        circle(pr * d, 0.25 * t),\n        circle(pr * d - vec2(0, 0.25), 0.35 * t), 0.05);\n}\n\n// t = 0 : disney, t = 1 : deadmau5\nfloat deadmau5(vec2 p, float t) {\n    float headSize = mix(0.5, 0.45, t);\n    float face = circle(p, headSize);\n\n    float earAngle = mix(60.0, 40.0, t); \n    vec2 ellipseAB = mix(vec2(0.35, 0.4), vec2(0.4, 0.3), t);\n    float earInvScale = mix(1.1, 0.94, t);\n    \n    face = combine(face, ear(p - vec2(0.5, 0.5), earAngle, earInvScale, ellipseAB));\n    face = combine(face, ear(p - vec2(-0.5, 0.5), -earAngle, earInvScale, ellipseAB));\n    \n    float fullmouth = circle(p, 0.3 + 0.1 * t);\n    float mouth = difference(fullmouth, circle(p - vec2(0, 10.0 - (1.0 - t) * 1.0), 10.0));\n    face = difference(face, mouth);\n    \n    face = difference(face, eye(p - vec2(0.21, 0.21), 45.0, t));\n    face = difference(face, eye(p - vec2(-0.21, 0.21), -45.0, t));\n    \n    return face;\n    //return ear(p - vec2(0.5, 0.5), 15.0);\n}\n\nfloat scene(vec2 p) {\n    // return mix(deadmau5(p), mickey(p), mixer());\n    return deadmau5(p - vec2(0.0, -0.15), mixer());\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  float t = 0.0f;\n  vec2 uv = squareFrame(iResolution.xy, fragCoord);\n  float d;\n  vec3 col;\n  vec2 ro = vec2(iMouse.xy / iResolution.xy) * 2.0 - 1.0;\n  ro.x *= squareFrame(iResolution.xy, iResolution.xy).x;\n\n  vec2 rd = normalize(-ro);\n\n  d = scene(uv);\n\n  #if DISPLAY == 0\n    col = vec3(draw_distance(d, uv.xy));\n  #endif\n  #if DISPLAY == 1\n    col += 1.0 - vec3(draw_line(d));\n    col = 1. - col;\n  #endif\n  #if DISPLAY == 2\n    col = vec3(draw_solid(d));\n  #endif\n\n  fragColor.rgb = col;\n  fragColor.a   = 1.0;\n}","name":"Image","description":"","type":"image"}]}