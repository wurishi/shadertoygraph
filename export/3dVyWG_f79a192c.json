{"ver":"0.1","info":{"id":"3dVyWG","date":"1603642631","viewed":111,"name":"raymachtutor","username":"geranyan","description":"pass","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["comma"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nfloat sdElipsoid(in vec3 pos, vec3 rad){\n\nfloat k0 = length(pos/rad);\nfloat k1 = length(pos/rad/rad);\n\n    return k0* (k0-1.0)/k1;\n}\n\nfloat smin(float a, float b, float k){\n\nfloat h = max(k - abs(a-b), 0.0);\nreturn min(a,b) - h*h/(k * 4.0);\n}\nfloat sdGuy(in vec3 pos){\n\nfloat t = 0.5; //fract(iTime);\n\nfloat y = 4.0*t*(1.0 - t);\n\nfloat dy = 4.0*(1.0 - 2.0*t);\n\nvec2 u = normalize(vec2(1.0, -dy));\n\nvec2 v = vec2(dy, 1.0);\n\nvec3 cen = vec3(0.0, 0.0, 0.0);\n\nfloat sy = 0.5 + 0.5*y;\n\nfloat sz = 1.0/sy;\n\nvec3 rad = vec3(0.25, 0.25*sy, 0.25*sz);\n\nvec3 q = pos - cen;\n\n//q.yz = vec2(dot(u, q.yz), dot(v, q.yz));\n\nfloat d = sdElipsoid(q,rad);\n\nvec3 h = q - vec3(0.0, 0.28, 0.0);\n\nfloat d2 = sdElipsoid(h, vec3(0.2));\n\nd = smin(d, d2, 0.15);\nreturn d;\n\n\n}\nfloat map(in vec3 pos){\n\nfloat d1 = sdGuy(pos);\n\nfloat d2 = pos.y - (-0.25);\n\n\nreturn min(d1, d2); // объединение\n}\n\nvec3 calcNormal(in vec3 pos){\n\nvec2 e = vec2(0.0001, 0.0);\nreturn normalize( vec3(map(pos + e.xyy)-map(pos - e.xyy),\nmap(pos + e.yxy)-map(pos - e.yxy),\nmap(pos + e.yyx)-map(pos - e.yyx) ) );\n}\n\nfloat rayMarch(in vec3 ro, in vec3 rd){\nfloat t = 0.0;\n//ray march loop\nfor(int i = 0; i < 100; i++) {\n\nvec3 pos = ro + t * rd;\n\n\nfloat h = map(pos);\nif(h < 0.001){\nbreak;\n}\nt += h;\nif(t >20.0){\nbreak;\n}\n\n}\nif(t > 20.0){\nt = -1.0;\n}\n\nreturn t;\n\n}\n\n\nvec4 galaxy(vec2 dir){\n\tvec2 pos = vec2(dir.x,dir.y-0.5);\n\tfloat t =  iTime*0.1;\n\tfloat si = sin(t);\n\tfloat co = cos(t);\n\tmat2 ma = mat2(co, si, -si, co);\n    \n    \n    float v1, v2, v3;\n\tv1 = v2 = v3 = 0.0;\n\t\n\tfloat s = 1.0;\n\tfor (int i = 0; i < 90; i++)\n\t{\n\t\tvec3 p = s * vec3(pos, 1.0);\n\t\tp.xy *= ma;\n\t\tp += vec3(.22, .3, s - 1.5 - sin( .13) * .1);\n\t\tfor (int i = 0; i < 8; i++)\tp = abs(p) / dot(p,p) -0.665;\n\t\tv1 += dot(p,p) * .0015 * (1.8 + sin(length(pos.xy ) + .5  ));\n\t\tv2 += dot(p,p) * .0013 * (1.5 + sin(length(pos.xy) + 1.2 ));\n\t\tv3 += length(p.xy*10.) * .0003;\n\t\ts  += 0.020;\n\t}\n    float len = length(pos);\n\tv1 *= smoothstep(.7, .0, len);\n\tv2 *= smoothstep(.5, .0, len);\n\tv3 *= smoothstep(.9, .0, len);\n\t\n\tvec3 col = vec3( v3 * (1.5 + sin(iTime * .2) * .4),\n\t\t\t\t\t(v1 + v3) * .3,\n\t\t\t\t\t v2) + smoothstep(0.2, .0, len) * .85 + smoothstep(.0, .6, v3) * .3;\n\t\n\treturn vec4(min(pow(abs(col), vec3(1.2)), 1.0), 1.0) ;\n\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\nvec2 p = (2.0 * fragCoord - iResolution.xy)/iResolution.y; //получаем пиксель\n\nfloat an = 10.0 * iMouse.x/iResolution.x;\n\n\nvec3 ro = vec3(2.0*sin(an), 0.2, 2.0* cos(an)); //положение камеры\n\n\n\nvec3 ta = vec3(0.0, 0.75, 0.0); // target for camera\n\n\nvec3 ww = normalize(ta - ro);\nvec3 uu = normalize( cross(ww, vec3(0,1,0)));\nvec3 vv = normalize( cross(uu, ww));\n\n\n\nvec3 rd = normalize(p.x*uu + p.y*vv + 1.5*ww); //-1.5 - глубина\n\n\n\n\n\n\n\nvec3 col = vec3(0.0001, 0.001, 0.01); //градиент на небе(оно не может быть однородным везде)\n\ncol = mix (col, vec3(0.0,0.0, 0.06), exp(-10.0*rd.y)); // линия горизонта\n\nfloat t = rayMarch(ro, rd);\n\nif(t > 0.0){\n\nvec3 pos = ro + t * rd;\nvec3 nor = calcNormal(pos);\n\nvec3 mate = vec3(0.18);\n\nvec3 sun_dir = normalize(vec3(0.8, 0.4, 0.2) );\nfloat sun_dif = clamp( dot (nor, sun_dir), 0.0, 0.1);\nfloat sun_shadow = step(rayMarch(pos + 0.001*nor, sun_dir),0.0);\nfloat sky_dif = clamp( 0.5 + dot (nor, vec3(0.0,1.0,0.0)), 0.0, 1.0); //0.5 + чтобы сдеелать более мягкую растушевку\nfloat bounce_dif = clamp( 0.5 + dot (nor, vec3(0.0,-1.0,0.0)), 0.0, 1.0); // тот же свет что и от неба только снизу координата -1\n\n    \n\n\n    \n    \n    \ncol = mate * vec3(7.0, 4.5, 3.0) * sun_dif * sun_shadow;\n\ncol += mate * vec3(0.5, 0.8, 0.9) * sky_dif;\n\ncol += mate * vec3(0.7, 0.3, 0.2) * bounce_dif;\n\n\n}\n\ncol = pow(col, vec3(0.4545));\n    \nvec4 galaxy_dir = galaxy(p);\n\nfragColor = vec4(col,1.0) +galaxy_dir ;\n}","name":"Image","description":"","type":"image"}]}