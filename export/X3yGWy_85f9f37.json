{"ver":"0.1","info":{"id":"X3yGWy","date":"1718127513","viewed":64,"name":"warping tubes","username":"milesd","description":"was trying to make pipes from mario then got some cool warping going on. lots of help from chatgpt. optional pixelation factor on line 87","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["warping","truchet","green","tubes"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// ShaderToy code\n// Quarter torus SDF\nfloat quarterTorus(vec3 p, vec3 center, float radius, float thickness, int quadrant) {\n    // Adjust position relative to the center\n    p -= center;\n\n    // Rotate position to align with the correct quadrant\n    if (quadrant == 0) {\n        p.xy = vec2(p.x, p.y);\n    } else if (quadrant == 1) {\n        p.xy = vec2(-p.y, p.x);\n    } else if (quadrant == 2) {\n        p.xy = vec2(-p.x, -p.y);\n    } else if (quadrant == 3) {\n        p.xy = vec2(p.y, -p.x);\n    }\n\n    // Calculate distance to the quarter torus\n    p.x = abs(p.x);\n    vec2 q = vec2(length(p.xy) - radius, p.z);\n    return length(q) - thickness;\n}\n\n// Smooth minimum function\nfloat smin(float a, float b, float k) {\n    float h = max(k - abs(a - b), 0.0) / k;\n    return min(a, b) - h * h * h * k * (1.0 / 6.0);\n}\n\n// Scene SDF\nfloat map(vec3 p) {\n    // Truchet tile size and parameters\n    float tileSize = 1.0;\n    float radius = 0.5;\n    float thickness = 0.3 + 0.2*sin(iTime*1.5);\n\n    // Apply vertical scrolling to the pattern\n    p.y += iTime * -0.5;\n\n    // Tile position and random seed\n    vec2 tilePos = floor(p.xy / tileSize);\n    vec3 tileUV = mod(p, tileSize) - 0.5 * tileSize;\n    float randSeed = sin(dot(tilePos, vec2(12.9898, 78.233))) * 43758.5453;\n    randSeed = fract(randSeed);\n\n    // Determine tile type based on random seed\n    int tileType = int(floor(randSeed * 2.0));\n\n    // Calculate distance to the quarter torus in the current tile\n    float d = 100.0;\n    if (tileType == 0) {\n        d = smin(quarterTorus(tileUV, vec3(0.5, 0.5, 0.0), radius, thickness, 0), \n                 quarterTorus(tileUV, vec3(-0.5, -0.5, 0.0), radius, thickness, 2), 0.1);\n    } else {\n        d = smin(quarterTorus(tileUV, vec3(-0.5, 0.5, 0.0), radius, thickness, 1), \n                 quarterTorus(tileUV, vec3(0.5, -0.5, 0.0), radius, thickness, 3), 0.1);\n    }\n\n    return d;\n}\n\n// Calculate normal from SDF\nvec3 calculateNormal(vec3 p) {\n    float epsilon = 0.001;\n    vec2 h = vec2(epsilon, 0);\n    return normalize(vec3(\n        map(p + h.xyy) - map(p - h.xyy),\n        map(p + h.yxy) - map(p - h.yxy),\n        map(p + h.yyx) - map(p - h.yyx)\n    ));\n}\n\n// Raymarching function\nfloat raymarch(vec3 ro, vec3 rd) {\n    float t = 0.0;\n    for (int i = 0; i < 100; i++) {\n        vec3 p = ro + t * rd;\n        float d = map(p);\n        if (d < 0.001) break;\n        t += d * 0.1;\n    }\n    return t;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Define pixelation factor\n    float pixelation = 1.0;\n\n    // Apply pixelation\n    vec2 pixelatedCoord = floor(fragCoord / pixelation) * pixelation;\n    \n\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = pixelatedCoord / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n\n        // Apply rotation\n    float angle = iTime * 0.05; // Rotation speed\n    mat2 rotation = mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n    uv = rotation * uv;\n\n    uv *= 2.0+0.1*sin(iTime);\n    \n\n    // zoom speed\n    float zoomSpeed = 0.0;\n    // Camera and ray setup\n    vec3 ro = vec3(uv, 0.43 +0.07*sin(2.0+iTime*1.5) + zoomSpeed*iTime);  // Move the camera further away\n    vec3 rd = normalize(vec3(uv, -1.5));  // Adjust ray direction for better perspective\n\n    // Raymarching\n    float t = raymarch(ro, rd);\n\n    // Compute the color based on the distance\n    vec3 col = vec3(0.0);\n\n    if (t < 10.5) {\n        vec3 p = ro + t * rd;\n        vec3 normal = calculateNormal(p);\n        vec3 lightDir = normalize(vec3(0.5, 0.5, -1.0));\n        float diff = max(dot(normal, lightDir), 0.0);\n        col = vec3(0.0, 1.0, 0.0) * diff;  // green color with lighting\n    }\n\n    // Output color\n    fragColor = vec4(col, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}