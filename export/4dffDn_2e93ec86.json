{"ver":"0.1","info":{"id":"4dffDn","date":"1670419049","viewed":49,"name":"Boldo's Raymarching Test 2","username":"boldo","description":"Experimenting with raymarching","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","ao","city"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float udRoundBox( vec3 p, vec3 b, float r )\n{\n  return length(max(abs(p)-b,0.0))-r;\n}\n\nvec2 udBox( vec3 p, vec3 b, float material )\n{\n  return vec2(length(max(abs(p)-b,0.0)), material);\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat sdCylinder( vec2 p, vec3 c )\n{\n  return length(p.xy-c.xy)-c.z;\n}\n\nfloat sdPlane( vec3 p )\n{\n\treturn p.y;\n}\n\nfloat opS( float d1, float d2 )\n{\n    return max(-d1,d2);\n}\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n    return (d1.x < d2.x) ? d1 : d2;\n}\n\n// polynomial smooth min (k = 0.1);\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nvec2 primitive( in vec3 pos )\n{    \n    //vec2 res = vec2(sdPlane(pos), 0.0);\n    //res = opU(res, udBox(pos, vec3(0.5,0.5,0.2), 0.5));\n\tvec2 res = vec2(sdSphere(pos, 1.0), 0.0);\n    return res;\n    \n}\n\nvec2 opRep( vec3 p, vec3 c )\n{\n    vec3 q = mod(p,c)-0.5*c;\n    return primitive( q );\n}\n\nvec2 map(in vec3 pos)\n{\n    //return opRep(pos, vec3(6,6,6));\n    return primitive(pos - vec3(-2,-1,2));\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    return normalize( e.xyy*map( pos + e.xyy ).x + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx ).x + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy ).x + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx ).x );\t\n}\n\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos ).x;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 mo = iMouse.xy/iResolution.xy;\n\tfloat time = 15.0 + iTime;\n    vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n    \n    // camera\t\n    //vec3 ro = vec3( -0.5+3.5*cos(0.1*time + 6.0*mo.x), 1.0 + 2.0*mo.y, 0.5 + 4.0*sin(0.1*time + 6.0*mo.x) );\n    vec3 ro = vec3( -0.5+3.5*cos(6.0*mo.x), 1.0 + 2.0*mo.y, 0.5 + 4.0*sin(6.0*mo.x) );\n    vec3 ta = vec3( -0.5, -0.4, 0.5 );\n    // camera-to-world transformation\n    mat3 ca = setCamera( ro, ta, 0.0 );\n    // ray direction\n    vec3 rd = ca * normalize( vec3(p.xy,3.0) );\n\t\n    vec4 color = vec4(0.0); // Sky color\n    color = vec4(0.7, 0.9, 1.0, 1.0) +rd.y*0.8;\n\tvec3  light = normalize( vec3(-0.4, 0.7, -0.6) );\n    \n    float t = 0.0;    \n    for(int i = 0; i < 64; ++i)\n    {\n        vec3 p = ro + rd * t;\n        float d = map(p).x;\n        if(d < 0.0008 * t)\n        {\n            vec3 normal = calcNormal( p );\n            //float occ = calcAO( p, normal );\n            //float dif = clamp( dot( normal, light ), 0.0, 1.0 );\n            //float amb = clamp( 0.5+0.5*normal.y, 0.0, 1.0 );\n            \n            //float lin = (dif + amb) / 2.0 * occ;\n            //lin = occ;\n            \n            color = vec4(cross(normal, vec3(sin(iTime *0.05),cos(iTime),0.0)) ,1.0); // Sphere color\n            \n            break;\n        } \n        else if (d > 20.0)\n        {\n            break;\n        }\n\n        t += d;\n    }\n\n    fragColor = color;\n}","name":"Image","description":"","type":"image"}]}