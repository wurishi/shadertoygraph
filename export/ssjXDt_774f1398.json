{"ver":"0.1","info":{"id":"ssjXDt","date":"1621526958","viewed":980,"name":"Migration breakdown","username":"skaplun","description":"Original shader  - https://www.shadertoy.com/view/Nd2XzK\nOriginal animation - https://twitter.com/owendeery/status/1390031346115006464\nText-guided version - https://twitter.com/sskaplun/status/1395414555795337227","likes":41,"published":1,"flags":32,"usePreview":0,"tags":["3d","raymarch","sdf","tutorial","animation","breakdown"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// just a edges here\n\n#define STEP .1\n\nconst mat3 scharrKernelX = mat3( 3.0,  10.0,  3.0,\n\t\t\t\t\t\t\t\t 0.0,   0.0,  0.0,\n\t\t\t\t\t\t\t\t-3.0, -10.0, -3.0);\n\nconst mat3 scharrKernelY = mat3(3.0, 0.0, -3.0,\n\t\t\t\t\t\t\t\t10.0, 0.0, -10.0,\n\t\t\t\t\t\t\t\t3.0, 0.0, -3.0);\n\nfloat convolve(mat3 kernel, mat3 image) {\n\tfloat result = 0.0;\n\tfor (int i = 0; i < 3; i++) {\n\t\tfor (int j = 0; j < 3; j++) {\n\t\t\tresult += kernel[i][j]*image[i][j];\n\t\t}\n\t}\n\treturn result;\n}\n\nfloat edge(float stepx, float stepy, vec2 center, mat3 kernelX, mat3 kernelY){\n\tmat3 image = mat3(length(texture(iChannel0,center + vec2(-stepx,stepy)).rgb),\n\t\t\t\t\t  length(texture(iChannel0,center + vec2(0,stepy)).rgb),\n\t\t\t\t\t  length(texture(iChannel0,center + vec2(stepx,stepy)).rgb),\n\t\t\t\t\t  length(texture(iChannel0,center + vec2(-stepx,0)).rgb),\n\t\t\t\t\t  length(texture(iChannel0,center).rgb),\n\t\t\t\t\t  length(texture(iChannel0,center + vec2(stepx,0)).rgb),\n\t\t\t\t\t  length(texture(iChannel0,center + vec2(-stepx,-stepy)).rgb),\n\t\t\t\t\t  length(texture(iChannel0,center + vec2(0,-stepy)).rgb),\n\t\t\t\t\t  length(texture(iChannel0,center + vec2(stepx,-stepy)).rgb));\n \tvec2 result;\n\tresult.x = convolve(kernelX, image);\n\tresult.y = convolve(kernelY, image);\n\t\n    return smoothstep(.05, .075, length(result)) * .33;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tvec4 color = texture(iChannel0, uv.xy);\n    fragColor = color;\n    \n    fragColor *= max(getInvNormalizedBAP(getBreakdownAnimationPhase(mod(iTime, 23.)), float(AP_OUTLINE)),\n                    (1. - edge(STEP/iResolution[0], STEP/iResolution[1], uv, scharrKernelX, scharrKernelY)));\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define MIN_FLOAT 1e-6\n#define MAX_FLOAT 1e6\n#define EPS 1e-3\n#define PHI  1.618034     // root of x^2 = x+1, golden ratio \n#define PHI2 1.324717957  // root of x^3 = x+1, generalization of golden ratio\n#define hash2(X)  fract( dot( X, 1./ vec2( PHI2, PHI2*PHI2 ) ) )\n\nstruct Ray{vec3 origin, direction;};\nstruct Sphere{vec3 origin; float rad;};\nstruct Bird{Sphere boundingSphere; float id;};\n\n// some globals\nfloat TIME;\nconst float PI = acos(-1.);\nconst float HPI = PI * .5;\nconst float QPI = PI * .25;\nconst vec3 ORANGE = vec3(1.,.6,.3);\nconst vec3 BLUE = vec3(.4,.9,1.);\nconst int BIRDS_COUNT = 8;\nBird birds[BIRDS_COUNT] = Bird[BIRDS_COUNT](\n    Bird(Sphere(vec3( 0., 1., 6.), 3.), 1.),\n    Bird(Sphere(vec3( 3., -2., 0.), 2.), 2.),\n    Bird(Sphere(vec3(23., 4., 3.), 2.), 3.),\n    Bird(Sphere(vec3(-6., 2., -2.), 2.), 11.),\n    Bird(Sphere(vec3( -8., .5, 5.), 3.), 18.),\n    Bird(Sphere(vec3( 3., -3., 4.), 2.), 26.),\n    Bird(Sphere(vec3(-3., 1., 6.), 2.), 33.),\n    Bird(Sphere(vec3(-6., 0., 8.), 2.), 35.)\n);\n\nvec3 caches[BIRDS_COUNT];\nvec3 caches2[BIRDS_COUNT];\nvec2 cashes3[BIRDS_COUNT];\n\nbool sphere_hit(const in Sphere sphere, const in Ray inray) {\n    vec3 oc = inray.origin - sphere.origin;\n    float a = dot(inray.direction, inray.direction);\n    float b = dot(oc, inray.direction);\n    float c = dot(oc, oc) - sphere.rad*sphere.rad;\n    float discriminant = b*b - a*c;\n    return discriminant > 0.;\n}\n\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\n//by iq\n\nvec2 hash( in vec2 x )  // replace this by something better\n{\n    const vec2 k = vec2( 0.3183099, 0.3678794 );\n    x = x*k + k.yx;\n    return -1.0 + 2.0*fract( 16.0 * k*fract( x.x*x.y*(x.x+x.y)) );\n}\n\n\n// return gradient noise (in x) and its derivatives (in yz)\nvec3 noised( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\n#if 1\n    // quintic interpolation\n    vec2 u = f*f*f*(f*(f*6.0-15.0)+10.0);\n    vec2 du = 30.0*f*f*(f*(f-2.0)+1.0);\n#else\n    // cubic interpolation\n    vec2 u = f*f*(3.0-2.0*f);\n    vec2 du = 6.0*f*(1.0-f);\n#endif    \n    \n    vec2 ga = hash( i + vec2(0.0,0.0) );\n    vec2 gb = hash( i + vec2(1.0,0.0) );\n    vec2 gc = hash( i + vec2(0.0,1.0) );\n    vec2 gd = hash( i + vec2(1.0,1.0) );\n    \n    float va = dot( ga, f - vec2(0.0,0.0) );\n    float vb = dot( gb, f - vec2(1.0,0.0) );\n    float vc = dot( gc, f - vec2(0.0,1.0) );\n    float vd = dot( gd, f - vec2(1.0,1.0) );\n\n    return vec3( va + u.x*(vb-va) + u.y*(vc-va) + u.x*u.y*(va-vb-vc+vd),   // value\n                 ga + u.x*(gb-ga) + u.y*(gc-ga) + u.x*u.y*(ga-gb-gc+gd) +  // derivatives\n                 du * (u.yx*(va-vb-vc+vd) + vec2(vb,vc) - va));\n}\n\nfloat sdPlane(vec3 p, vec3 n, float h ) {\n  return dot(p,n) + h;\n}\n\nfloat sdCylinder( vec3 p, vec2 h )\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nvec3 hsv2rgb(vec3 c) {\n  // Íñigo Quílez\n  // https://www.shadertoy.com/view/MsS3Wc\n  vec3 rgb = clamp(abs(mod(c.x*6.+vec3(0.,4.,2.),6.)-3.)-1.,0.,1.);\n  rgb = rgb * rgb * (3. - 2. * rgb);\n  return c.z * mix(vec3(1.), rgb, c.y);\n}\n\n\nvec2 min2(vec2 a, vec2 b){\n    return (a.x <= b.x) ? a : b;\n}\n\nvec2 max2(vec2 a, vec2 b){\n    return (a.x >= b.x) ? a : b;\n}\n\n#define MARCH(name, geometry)\\\nvec2 name(const in Ray ray, float start, float end) {\\\n    float depth = start;\\\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\\\n        vec2 dist = geometry(ray.origin + depth * ray.direction, ray);\\\n        if (dist.x < EPS)\\\n            return vec2(depth, dist.y);\\\n        depth += dist.x;\\\n        if (depth >= end)\\\n            break;\\\n    }\\\n    return vec2(-1.);\\\n}\n\n#define NORMAL(name, geometry)\\\nvec3 name(vec3 pos, const in Ray ray){ \\\n    vec2 e = vec2(1.0,-1.0)*0.5773*EPS; \\\n    return normalize( e.xyy*geometry( pos + e.xyy, ray ).x + \\\n\t\t\t\t\t  e.yyx*geometry( pos + e.yyx, ray ).x + \\\n\t\t\t\t\t  e.yxy*geometry( pos + e.yxy, ray ).x + \\\n\t\t\t\t\t  e.xxx*geometry( pos + e.xxx, ray ).x );\\\n}\n\n\n//\n\nstruct BreakdownAnimationPhase{\n\tfloat id;\n    float phase; \n};\n\n#define AP_SHAPE_SPHERE_GROW 0\n#define AP_SHAPE_SPHERE_CUT_TOP 1\n#define AP_SHAPE_SPHERE_CUT_BOTTOM 2\n#define AP_SHAPE_SPHERE_CUT_FRONT 3\n#define AP_SHAPE_SPHERE_CUT_BACK 4\n#define AP_SHAPE_WING_GROW 5\n#define AP_SHAPE_WING_CUT_TOP_BOTTOM 6\n#define AP_SHAPE_WING_CUT_FRONT 7\n#define AP_SHAPE_WING_CUT_BACK 8\n\n#define AP_ANIMATE_HEIGHT 9\n#define AP_ANIMATE_PITCH 10\n#define AP_ANIMATE_ROLL 11\n#define AP_ANIMATE_WINGS 12\n\n#define AP_ALL_BIRDS 13\n#define AP_BIRDS_SPREAD 14\n#define AP_BIRDS_COLORIZE 15\n#define AP_BG 16\n#define AP_OUTLINE 17\n#define AP_HOLD 18\n#define AP_FLY_AWAY 19\n\nconst int PHASES_COUNT = 20;\nconst float PHASES_DURATIONS[PHASES_COUNT] = float[PHASES_COUNT]\n    (1., 2., 3., 4., 5., 6., 7., 8., 9., 1., 11., 13., 14., 15., 16., 17., 18., 19., 22., 23.);\nfloat apPhasesStates[PHASES_COUNT];\nfloat apPhasesInvStates[PHASES_COUNT];\nBreakdownAnimationPhase bap;\nBreakdownAnimationPhase getBreakdownAnimationPhase(float time){\n\ttime = mod(time, PHASES_DURATIONS[PHASES_COUNT - 1]);\n    \n    int id = 0;\n    for(int i=1; i<=PHASES_COUNT; i++){\n        if(time < PHASES_DURATIONS[i-1]){\n        \tid = i-1;\n            break;\n        }\n    }\n    float phase = (time - (id == 0 ? 0. : PHASES_DURATIONS[id-1]))\n        \t\t/ (PHASES_DURATIONS[id] - (id == 0 ? 0. : PHASES_DURATIONS[id-1]));\n    \n    return BreakdownAnimationPhase(float(id), phase);\n}\n\nfloat getNormalizedBAP(BreakdownAnimationPhase bas, float id){\n\tif(id == bas.id)\n        return bas.phase;\n    else\n        return step(id, bas.id);\n}\n\nfloat getInvNormalizedBAP(BreakdownAnimationPhase bas, float id){\n\tif(id == bas.id)\n        return 1.-bas.phase;\n    else\n        return step(bas.id, id);\n}\n\nRay getViewRay(vec2 iResolution, vec2 fragCoord){\n    vec3 lookAt = vec3(25. * apPhasesStates[AP_BIRDS_SPREAD], 0., 0.);\n    float rad = 50. + 50. * apPhasesStates[AP_ANIMATE_HEIGHT];\n    float ang = (QPI * pow(apPhasesStates[AP_SHAPE_SPHERE_CUT_TOP], 2.5))\n              + (-QPI * apPhasesStates[AP_SHAPE_SPHERE_CUT_FRONT])\n              + (HPI * pow(apPhasesStates[AP_ANIMATE_ROLL], 8.))\n              + (-HPI * apPhasesStates[AP_ANIMATE_WINGS]);\n    vec3 eye = vec3(rad * sin(ang),\n                    30. * apPhasesInvStates[AP_SHAPE_SPHERE_CUT_TOP]\n                   +30. * apPhasesStates[AP_SHAPE_WING_CUT_TOP_BOTTOM],\n                    rad * cos(ang));\n    \n    vec2 offset = vec2(0.);//vec2(iResolution.x * .15, 0.);\n    vec3 viewDir = rayDirection(45., iResolution.xy, fragCoord + offset);\n    vec3 worldDir = viewMatrix(eye, lookAt, vec3(0., 1., 0.)) * viewDir;\n    \n    return Ray(eye, worldDir);\n}","name":"Common","description":"","type":"common"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"vec3 bg(vec2 guv){\n    vec3 res = mix(ORANGE, BLUE, pow(guv.y, 1. + noised(vec2(guv.x * 2., iTime)).x));\n    \n    for(float i=-1.; i<2.; i++){\n        float amp = 3. + i * .5;\n        float hoff = TIME * amp;\n        \n        float a = i * .25;\n        vec2 scale = vec2(3. + 2. * abs(i), 100. + 100. * abs(i));\n        vec2 uv = (guv * mat2(cos(a), -sin(a), sin(a), cos(a)))\n                * scale;\n        uv += vec2(hoff, sin(uv.x * amp - hoff) * amp);\n        \n        float h = hash2(floor(uv));\n        float c = hash2(floor(uv) * (121.3 + i * 32.));\n        \n        float mixVal = step(distance(.5, h), .0025);\n        mixVal *= step(apPhasesInvStates[AP_BG], guv.x)\n                * step(guv.x, apPhasesInvStates[AP_FLY_AWAY]);\n        \n        res = mix(res, mix(ORANGE * (.9 + i*.1), BLUE * (.9 + i*.1), c), mixVal);\n    }\n    return res;\n}\n\nfloat bird(const in Bird bird, vec3 p, float angV, float angH, float speed){\n    {\n        vec3 pos = p - bird.boundingSphere.origin;\n        pos.xy *= mat2(cos(angV), -sin(angV), sin(angV), cos(angV));\n        pos.yz *= mat2(cos(angH * 2.), -sin(angH * 2.), sin(angH * 2.), cos(angH * 2.));\n        pos.xz *= mat2(cos(angH), -sin(angH), sin(angH), cos(angH));\n    \n        pos = vec3(pos.xy, abs(pos.z));\n        float res = length(pos) - bird.boundingSphere.rad * apPhasesStates[AP_SHAPE_SPHERE_GROW];\n        float rad = bird.boundingSphere.rad;\n        res = max(res, sdPlane(pos, normalize(vec3(0., 1., .5)), -rad * max(.125, apPhasesInvStates[AP_SHAPE_SPHERE_CUT_TOP])));\n        res = max(res, sdPlane(pos, normalize(vec3(0., -1., 1.)), -rad * max(.125, apPhasesInvStates[AP_SHAPE_SPHERE_CUT_BOTTOM])));\n        res = max(res, sdPlane(pos - vec3(rad * .5, 0., 0.), normalize(vec3(1., 1., 1.5)), -rad * max(.15, apPhasesInvStates[AP_SHAPE_SPHERE_CUT_FRONT])));\n        res = max(res, sdPlane(pos + vec3(rad * .5, 0., 0.), normalize(vec3(-.5, -1.5, 1.5)), -apPhasesInvStates[AP_SHAPE_SPHERE_CUT_BACK] * 5.));\n        \n        if(int(bap.id) >= AP_SHAPE_WING_GROW){\n            vec3 wpos = pos;\n            \n            wpos.z -= rad * .2;\n            float a = sin(TIME * .75 * speed) * .5;\n            wpos.yz *= mat2(cos(a), -sin(a), sin(a), cos(a));\n            wpos.z += rad * .2;\n            \n            float wing = length(pos) - bird.boundingSphere.rad * apPhasesStates[AP_SHAPE_WING_GROW];\n            wing = max(wing, sdPlane(wpos, normalize(vec3(0., 1., 0.)), -rad * max(.035, apPhasesInvStates[AP_SHAPE_WING_CUT_TOP_BOTTOM])));\n            wing = max(wing, sdPlane(wpos, normalize(vec3(0., -1., 0.)), rad * min(.01, .1 - apPhasesInvStates[AP_SHAPE_WING_CUT_TOP_BOTTOM])));\n            wing = max(wing, sdPlane(pos, normalize(vec3(1., 0., 1.25)), -rad * max(.44, apPhasesInvStates[AP_SHAPE_WING_CUT_FRONT])));\n            wing = max(wing, sdPlane(wpos, normalize(vec3(-1., 0., -.5)), rad * min(.05, .1 - apPhasesInvStates[AP_SHAPE_WING_CUT_BACK])));\n            //wing = max(wing, sdPlane(pos, normalize(vec3(0., 0., -1.)), rad * .2));\n            res = min(wing, res);\n        }\n        \n        return res;\n    }\n}\n\nvec2 world(vec3 pos, const in Ray ray){\n    vec2 res = vec2(MAX_FLOAT);\n    //if(false)\n    {\n        Bird curb = birds[0];\n        curb.boundingSphere.rad += 2.5 * apPhasesInvStates[AP_ALL_BIRDS];\n        vec3 noise = caches[0];\n        vec3 noise2 = caches2[0];\n        vec2 h = cashes3[0];\n        \n        curb.boundingSphere.origin.x += 100. * apPhasesStates[AP_FLY_AWAY];\n        curb.boundingSphere.origin.y += noise.x * 40. * h.y * apPhasesStates[AP_ANIMATE_HEIGHT];\n        curb.boundingSphere.origin.z += noise2.x * 25. * apPhasesStates[AP_ANIMATE_ROLL];\n        if(sphere_hit(curb.boundingSphere, ray))\n            res = min2(res, vec2(bird(curb, pos, -noise.z * h.y * .4 * apPhasesStates[AP_ANIMATE_PITCH], -noise2.z * .4 * apPhasesStates[AP_ANIMATE_ROLL], noise.z * 5.* apPhasesStates[AP_ANIMATE_WINGS]), 0.));\n    }\n    \n    if(int(bap.id) >= AP_ALL_BIRDS)\n    {\n        float timePerBird = 1./float(BIRDS_COUNT);\n        float curAnimationPhase = apPhasesStates[AP_ALL_BIRDS];\n        for(int i=min(iFrame, 1); i<BIRDS_COUNT; i++){\n            vec3 noise = caches[i];\n            vec3 noise2 = caches2[i];\n            vec2 h = cashes3[i];\n\n            Bird curb = birds[i];\n            curb.boundingSphere.rad *= smoothstep(timePerBird * float(i), timePerBird * float(i+1), curAnimationPhase);\n            curb.boundingSphere.origin.x += h.y * 20. * apPhasesStates[AP_BIRDS_SPREAD]\n                                          + 100. * apPhasesStates[AP_FLY_AWAY];\n            curb.boundingSphere.origin.y += noise.x * 40. * h.y;\n            curb.boundingSphere.origin.z += noise2.x * 25.;\n\n            if(sphere_hit(curb.boundingSphere, ray))\n                res = min2(res, vec2(bird(curb, pos, -noise.z * h.y * .4, -noise2.z * .4, noise.z * 5.), i));\n        }\n    }\n    return res;\n}\n\nconst float CUTOFF_PLANES_THICKNESS = .015;\nfloat plane(vec3 pos, vec3 nrm, float dist){\n    return max(-sdPlane(pos, nrm, -dist + CUTOFF_PLANES_THICKNESS),\n               -sdPlane(pos, nrm * -1., dist + CUTOFF_PLANES_THICKNESS));\n}\n\nvec2 cutoffPlanes(vec3 p, const in Ray ray){\n    vec3 pos = p - birds[0].boundingSphere.origin;\n    float rad = birds[0].boundingSphere.rad + 2.5;\n    pos.z = abs(pos.z);\n    \n    float vc = sdCylinder(pos, vec2(10., 25.));\n    float hc = sdCylinder(pos.yxz, vec2(5., 25.));\n    float a = smoothstep(.5, .35, distance(.5, bap.phase));\n    int bapid = int(bap.id);\n    if(bapid == AP_SHAPE_SPHERE_CUT_TOP)\n        return vec2(max(vc, plane(pos, normalize(vec3(0., 1., .5)), max(1.5, apPhasesInvStates[AP_SHAPE_SPHERE_CUT_TOP] * 8.))), a);\n    else if(bapid == AP_SHAPE_SPHERE_CUT_BOTTOM)\n        return vec2(max(vc, plane(pos, normalize(vec3(0., -1., 1.)), max(1.5, apPhasesInvStates[AP_SHAPE_SPHERE_CUT_BOTTOM] * 8.))), a);\n    else if(bapid == AP_SHAPE_SPHERE_CUT_FRONT)\n        return vec2(max(hc, plane(pos, normalize(vec3(1., 1., 1.5)), max(2.5, (apPhasesInvStates[AP_SHAPE_SPHERE_CUT_FRONT] + 1.) * 3.))), a);\n    else if(bapid == AP_SHAPE_SPHERE_CUT_BACK){\n        float hc = sdCylinder(pos.yxz, vec2(1., 25.));\n        return vec2(max(hc, plane(pos, normalize(vec3(-.5, -1.5, 1.5)), max(.5, (apPhasesInvStates[AP_SHAPE_SPHERE_CUT_BACK] + .5) * 3.))), a);\n    }else if(bapid == AP_SHAPE_WING_CUT_TOP_BOTTOM){\n        float r = min(max(vc, plane(pos, normalize(vec3(0., 1., 0.)), max(1.5, apPhasesInvStates[AP_SHAPE_WING_CUT_TOP_BOTTOM] * 8.))),\n                      max(vc, plane(pos, normalize(vec3(0., -1., 0.)), max(1.5, apPhasesInvStates[AP_SHAPE_WING_CUT_TOP_BOTTOM] * 8.))));\n        return vec2(r, a);\n    }else if(bapid == AP_SHAPE_WING_CUT_FRONT)\n        return vec2(max(hc, plane(pos, normalize(vec3(1., 0., 1.25)), max(2.5, (apPhasesInvStates[AP_SHAPE_WING_CUT_FRONT] + 1.) * 3.))), a);\n    else if(bapid == AP_SHAPE_WING_CUT_BACK)\n        return vec2(max(hc, plane(pos, normalize(vec3(-1., 0., -.5)), max(.5, (apPhasesInvStates[AP_SHAPE_WING_CUT_BACK] + .6) * 3.))), a);\n    \n    return vec2(MAX_FLOAT);\n}\n\nconst int MAX_MARCHING_STEPS = 64;\nMARCH(march_geometry, world)\nMARCH(march_cutoff_planes, cutoffPlanes)\n\nNORMAL(geometryNormal, world)\nNORMAL(cutoffPlanesgeometryNormal, cutoffPlanes)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    TIME = mod(iTime, 23.);\n    bap = getBreakdownAnimationPhase(TIME);\n    \n    for(int i = min(iFrame, 0); i<PHASES_COUNT; i++){\n        apPhasesStates[i] = getNormalizedBAP(bap, float(i));\n        apPhasesInvStates[i] = 1. - apPhasesStates[i];\n    }\n    \n    for(int i=min(iFrame,0); i<BIRDS_COUNT; i++){\n        caches[i] = noised(vec2(birds[i].id, TIME));\n        caches2[i] = noised(vec2(birds[i].id + 47., TIME));\n        cashes3[i] = 1. - hash(vec2(birds[i].id, 21.));\n    }\n    \n    fragColor = vec4(bg(fragCoord.xy/iResolution.xy), 1.);\n    Ray r = getViewRay(iResolution.xy, fragCoord);\n    vec2 hit = march_geometry(r, 0., 1000.);\n    if(hit.x >= 0.) {\n        vec3 nrm = geometryNormal(r.origin + r.direction * hit.x, r);\n        float d = dot(nrm, vec3(0., 1., 0.));\n        float v = (hit.y/float(BIRDS_COUNT) - .5);\n        vec3 clr = mix(vec3(.8), hsv2rgb(vec3(.55 + v * .05, .5 + v * .25, .6 + v * .25)), step(d, 0.));\n        fragColor.rgb = mix(nrm, clr, apPhasesStates[AP_BIRDS_COLORIZE]);\n    }\n    \n    if(int(bap.id) > AP_SHAPE_SPHERE_GROW && int(bap.id) <= AP_SHAPE_WING_CUT_BACK)\n    {\n        vec2 planesHit = march_cutoff_planes(r, 0., (hit.x >= 0.)?hit.x:1000.);\n        if(planesHit.x >= 0.) {\n            vec3 nrm = cutoffPlanesgeometryNormal(r.origin + r.direction * planesHit.x, r);\n            fragColor.rgb = mix(fragColor.rgb, nrm, .25 * planesHit.y);\n        }\n    }\n}","name":"Buffer A","description":"","type":"buffer"}]}