{"ver":"0.1","info":{"id":"l3lBR2","date":"1728657543","viewed":218,"name":"Dancing Helix (sound)","username":"me_123","description":"4 helixes dancing in harmony to music in a twisted tunnel with spores. ","likes":10,"published":3,"flags":8,"usePreview":0,"tags":["3d","raymarching","sound","music","truchet","helix","dance","sexy","supertunnel"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.141592653\nfloat t, tunnelSize;\nvec3 innerTransform(in vec3 p) {\n    p.zx *= mat2(cos(p.y*0.1), -sin(p.y*0.1), sin(p.y*0.1), cos(p.y*0.1));\n    return p;\n}\nvec3 wallTransform(in vec3 p) { //rotate plain\n    p.zx *= mat2(cos(p.y*0.02), -sin(p.y*0.02), sin(p.y*0.02), cos(p.y*0.02));\n    return p;\n}\nvec3 merror(in vec3 p) { //4 from one\n    p.zx = abs(p.zx)-2.0;\n    return p;\n}\nvec3 outerTransform(in vec3 p) { //transform line to helix\n    float theta = p.y*0.5;\n    p.zx *= mat2(cos(theta), -sin(theta), sin(theta), cos(theta));\n    return p;\n}\nvec3 transform(in vec3 p) { //transform most outer helix\n    p.xz-=vec2(sin(t*2.0*PI*2.0*0.5), 0.5);\n    return p;\n}\nfloat sdf(in vec3 p) { //distance to tunnel and dancing helixes\n    vec3 pp = wallTransform(p);\n    p = innerTransform(p);\n    p = merror(p);\n    p = outerTransform(p);\n    p = transform(p);\n    float spirals = length(p.xz);\n    float d = min(spirals-0.5, tunnelSize-max(abs(pp.x*0.0), abs(pp.z)));\n    pp.y = mod(pp.y, 4.0)-2.0;\n    pp.x = mod(pp.x, 2.0)-1.0;\n    pp.xz = abs(pp.xz);\n    pp.z -= tunnelSize;\n    \n    d = min(d, max(max(abs(pp.x), abs(pp.y)), abs(pp.z))-0.5);\n    return d;\n}\nvec3 normal(in vec3 p) { //approximate surface normal (unit vector pointing away from surface)\n    const float eps = 0.001;\n    float s0 = sdf(p);\n    return vec3(\n        sdf(p+vec3(0, 0, eps))-s0, // d/dx\n        sdf(p+vec3(0, eps, 0))-s0, // d/dy\n        sdf(p+vec3(eps, 0, 0))-s0  // d/dz\n    )/eps;\n}\nfloat noise(in vec2 p) { //find smooth noise\n    vec2 fp = floor(p);\n    vec2 ffp = 0.5-0.5*cos(PI*fract(p)); //smoothen\n    return mix(mix(hash12(fp+vec2(0,0)), hash12(fp+vec2(1,0)), ffp.x),\n               mix(hash12(fp+vec2(0,1)), hash12(fp+vec2(1,1)), ffp.x), ffp.y); //combine noise going in 4 directions into smooth noise\n}\nvec3 getColor(in vec3 ro, in vec3 rd) {\n    float dist = 0.0;\n    vec3 color = vec3(0);\n    for (int i = 1000; i--!= 0;) {\n        float s = sdf(ro+rd*dist);\n        if (s < .1) {\n            vec3 p = ro+rd*dist,\n                 wt =wallTransform(p);\n            bool isShape = abs(wt.z) < tunnelSize-0.6, //find shape\n                 isLight = !isShape && abs(wt.z) < tunnelSize-0.1; //find things on wall\n            if (isLight) {\n                vec2 lightPos = vec2(fract(wt.xy*.5+vec2(0, .5)))-.5;\n                float ld = max(abs(lightPos.x), abs(lightPos.y))*5.;\n                color = vec3(sin(ld*vec3(5, 6, 7))*0.5+0.5);\n            }\n            else if (isShape) color = vec3(sin(vec3(10., 11., 12.)*(dot(normal(p), normalize(vec3(1, 2, 3)))*0.5+0.5)));\n            else {\n                float n = 0.0, scale = 1.0;\n                wt.xy *= 0.25;\n                for (int i = 6; i--!=0; scale *= .5, wt.xy *= 2.0) n += noise(wt.xy)*scale;\n                color = vec3(sin(.8*n*vec3(5, 6, 7)+iTime)*.5+.5);\n            };\n            break;\n        }\n        dist += s;\n        if (dist > min(t*50., 1000.)) break; //clip distance\n    }\n    const float freq = 5.;\n    float ho = 0.0;\n    float sd = sign(rd.y)*freq;\n    float offset = floor(ro.y/freq)*freq+(sd+freq)*0.5;\n    for (int i = 50; i--!=0;) { //find amount of pink stuff\n        float plainDist = -(ro.y-offset)/rd.y;\n        \n        vec2 rn = hash21(offset);\n        \n        if (plainDist > dist) break;\n        offset += sd;\n        float weight = pow(sin(t*PI*0.25+rn.x*100.)*0.5+0.5, 50.0);\n        if (weight < 0.001) continue;\n        vec2 p = ro.xz + rd.xz*plainDist + offset*100.;\n        p.y += t*10.*rn.x;\n        vec2 cell = floor(p);\n        vec2 cellPos = fract(p)-0.5;\n        float rnd = hash12(cell);\n        float s = sign(rnd -0.5);\n        float dist = (min(abs(length(cellPos-vec2(0.5, s*0.5))-0.5), abs(length(cellPos+vec2(0.5, s*0.5))-0.5)))-(noise(p)*0.25 + noise(p*0.5)*0.5)*0.25;\n        ho += weight*clamp(-dist*5., 0.0, 1.0)*(1.-exp(-plainDist*0.1));\n    }\n    return vec3(0.25, 0.5, 1)*ho+vec3(color*exp(-dist*0.03));\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord.xy-iResolution.xy*0.5)/iResolution.y;\n    t = iTime;\n    if (iTime > endTime) { //outro\n        int num = min(int(floor(iTime))-int(endTime), 5);\n        float cell = fract(iTime);\n        float theta = iTime;\n        mat2 m = mat2(cos(theta), -sin(theta), sin(theta), cos(theta));\n        \n        vec2 uv0 = uv;\n        vec2 uv1 = uv;\n        for (int i = 0; i < num; i++) {\n            uv *= 2.0;\n            uv = abs(uv)-0.5;\n            uv.xy = vec2(min(uv.x, uv.y)+0.5, max(uv.y, uv.x)-0.5);\n            uv *= m;\n            if (i == num-1) uv0 = uv;\n            if (i == num-2) uv1 = uv;\n        }\n        uv0 *= pow(2., -float(num));\n        uv1 *= pow(2., -float(num-1));\n        uv = mix(uv1, uv0, cell);\n    }\n    //uv *= 2.0;\n    float s = mod(t, 20.);\n    if (s < 5.0) { //transform time and screen space\n        float transition = 0.5-0.5*cos((s/5.0)*PI);\n        float theta = transition*PI*2.0;\n        \n        //f(0) = 0.0;\n        //f(0.5) = k;\n        //f(1) = 0.0;\n        //f(x) = -(x-0.5)^2 * k + 0.25*k\n        float k = 20.;\n        float ss = -(transition-0.5)*(transition-0.5) * k + 0.25*k + 1.0;//1.-pow(1.-transition, 4.0);//(1.-transition);//abs(transition-0.5);\n        uv *= mat2(cos(theta), -sin(theta), sin(theta), cos(theta));\n        uv *= ss;\n    }\n    tunnelSize = mod(floor(t*1.)+floor(t*2.0), 6.0)+5.0;\n    vec3 ro = vec3(0, t*20.0, sin(t*PI)); //ray origin\n    vec3 rd;\n    if (iMouse.z > 0.0) {\n        vec2 angle = (iMouse.yx/iResolution.yx-.5)*PI;\n        vec3 at = vec3( //find vector camera is pointed to\n            sin(angle.y),\n            cos(angle.x)*cos(angle.y), \n            sin(angle.x)*cos(angle.y)\n        );\n        vec3 xPlain = vec3(normalize(vec2(at.y, -at.x)), 0);\n        vec3 yPlain = cross(xPlain, at);\n        rd = normalize(vec3(at + xPlain*uv.x + yPlain*uv.y)); //ray direction\n    } else rd = normalize(vec3(uv.x, 1.0, uv.y));\n    vec2 gridPos = fract(uv*20.)-0.5;\n    float dist = max(abs(gridPos.x), abs(gridPos.y));\n    float size = pow(abs(uv.x), 2.0)*0.5+noise(uv*4.0+t)*0.1;\n    float gridFac = clamp(-(dist-size)/20.*iResolution.y, 0.0, 1.0);\n    fragColor = vec4(mix(getColor(ro, rd), sin((uv.y*2.+t)*vec3(3, 2, 1))*0.5+0.5, gridFac*0.25), 1.0); //get color of ray\n    if (iTime > endTime+4.0) {\n        float d = iTime-endTime-4.0;\n    }\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define endTime 42.5\n//Hashes Lay Heare...\n//Thanks to David Hoskins\n\n\n// Creative Commons Attribution-ShareAlike 4.0 International Public License\n// Created by David Hoskins. May 2018\n\n\n#define UI0 1597334673U\n#define UI1 3812015801U\n#define UI2 uvec2(UI0, UI1)\n#define UI3 uvec3(UI0, UI1, 2798796415U)\n#define UI4 uvec4(UI3, 1979697957U)\n#define UIF (1.0 / float(0xffffffffU))\n\n// The labeling refers to the number of values - hash(out)(in)...\n//---------------------------------------------------------------------------------------------------------------\nfloat hash11(uint q)\n{\n\tuvec2 n = q * UI2;\n\tq = (n.x ^ n.y) * UI0;\n\treturn float(q) * UIF;\n}\n\nfloat hash11(float p)\n{\n\tuvec2 n = uint(int(p)) * UI2;\n\tuint q = (n.x ^ n.y) * UI0;\n\treturn float(q) * UIF;\n}\n\n//---------------------------------------------------------------------------------------------------------------\nfloat hash12(uvec2 q)\n{\n\tq *= UI2;\n\tuint n = (q.x ^ q.y) * UI0;\n\treturn float(n) * UIF;\n}\n\nfloat hash12(vec2 p)\n{\n\tuvec2 q = uvec2(ivec2(p)) * UI2;\n\tuint n = (q.x ^ q.y) * UI0;\n\treturn float(n) * UIF;\n}\n\n//---------------------------------------------------------------------------------------------------------------\nfloat hash13(uvec3 q)\n{\n\tq *= UI3;\n\tuint n = (q.x ^ q.y ^ q.z) * UI0;\n\treturn float(n) * UIF;\n}\n\nfloat hash13(vec3 p)\n{\n\tuvec3 q = uvec3(ivec3(p)) * UI3;\n\tuint n = (q.x ^ q.y ^ q.z) * UI0;\n\treturn float(n) * UIF;\n}\n\n//---------------------------------------------------------------------------------------------------------------\nfloat hash14(uvec4 q)\n{\n\tq *= UI4;\n\tuint n = (q.x ^ q.y ^ q.z ^ q.w) * UI0;\n\treturn float(n) * UIF;\n}\n\nfloat hash14(vec4 p)\n{\n\tuvec4 q = uvec4(ivec4(p)) * UI4;\n\tuint n = (q.x ^ q.y ^ q.z ^ q.w) * UI0;\n\treturn float(n) * UIF;\n}\n\n//---------------------------------------------------------------------------------------------------------------\nvec2 hash21(uint q)\n{\n\tuvec2 n = q * UI2;\n\tn = (n.x ^ n.y) * UI2;\n\treturn vec2(n) * UIF;\n}\n\nvec2 hash21(float p)\n{\n\tuvec2 n = uint(int(p)) * UI2;\n\tn = (n.x ^ n.y) * UI2;\n\treturn vec2(n) * UIF;\n}\n\n//---------------------------------------------------------------------------------------------------------------\nvec2 hash22(uvec2 q)\n{\n\tq *= UI2;\n\tq = (q.x ^ q.y) * UI2;\n\treturn vec2(q) * UIF;\n}\n\nvec2 hash22(vec2 p)\n{\n\tuvec2 q = uvec2(ivec2(p))*UI2;\n\tq = (q.x ^ q.y) * UI2;\n\treturn vec2(q) * UIF;\n}\n\n//---------------------------------------------------------------------------------------------------------------\nvec2 hash23(uvec3 q)\n{\n\tq *= UI3;\n\tuvec2 n = (q.x ^ q.y ^ q.z) * UI2;\n\treturn vec2(n) * UIF;\n}\n\nvec2 hash23(vec3 p)\n{\n\tuvec3 q = uvec3(ivec3(p)) * UI3;\n\tuvec2 n = (q.x ^ q.y ^ q.z) * UI2;\n\n\treturn vec2(n) * UIF;\n}\n\n//---------------------------------------------------------------------------------------------------------------\nvec3 hash31(uint q)\n{\n\tuvec3 n = q * UI3;\n\tn = (n.x ^ n.y ^ n.z) * UI3;\n\treturn vec3(n) * UIF;\n}\nvec3 hash31(float p)\n{\n\n\tuvec3 n = uint(int(p)) * UI3;\n\tn = (n.x ^ n.y ^ n.z) * UI3;\n\treturn vec3(n) * UIF;\n}\n\n//---------------------------------------------------------------------------------------------------------------\nvec3 hash32(uvec2 q)\n{\n\tuvec3 n = q.xyx * UI3;\n\tn = (n.x ^ n.y ^n.z) * UI3;\n\treturn vec3(n) * UIF;\n}\n\nvec3 hash32(vec2 q)\n{\n\tuvec3 n = uvec3(ivec3(q.xyx)) * UI3;\n\tn = (n.x ^ n.y ^ n.z) * UI3;\n\treturn vec3(n) * UIF;\n}\n\n//---------------------------------------------------------------------------------------------------------------\nvec3 hash33(uvec3 q)\n{\n\tq *= UI3;\n\tq = (q.x ^ q.y ^ q.z)*UI3;\n\treturn vec3(q) * UIF;\n}\n\nvec3 hash33(vec3 p)\n{\n\tuvec3 q = uvec3(ivec3(p)) * UI3;\n\tq = (q.x ^ q.y ^ q.z)*UI3;\n\treturn vec3(q) * UIF;\n}\n\n//---------------------------------------------------------------------------------------------------------------\nvec4 hash44(uvec4 q)\n{\n\tq *= UI4;\n\tq = (q.x ^ q.y ^ q.z ^ q.w)*UI4;\n\treturn vec4(q) * UIF;\n}\n\nvec3 hash44(vec4 p)\n{\n\tuvec4 q = uvec4(ivec4(p)) * UI4;\n\tq = (q.x ^ q.y ^ q.z ^ q.w)*UI4;\n\treturn vec3(q) * UIF;\n}\n\n","name":"Common","description":"","type":"common"},{"inputs":[],"outputs":[],"code":"float globalTime;\nfloat sound(in float time) { //make good sounds\n    float ending = tanh((endTime-globalTime)*10.)*0.5+0.5;//sin(globalTime)/(0.01+abs(sin(globalTime)))*0.5+0.5;//asin(sin(time));//1.-exp(-globalTime*0.1);\n    float master = tanh((endTime+2.0-globalTime)*0.5)*0.5+0.5;//smoothstep(0.01, globalTime, 12.);\n    return (\n    ending*sin(6.2831*(300.0+20.*mod(floor(time*0.5), 2.0))*time)*exp(-1.5*fract(time*2.0))+\n    ending*sin(6.2831*220.0*time)*exp(-3.0*fract(time*2.0+0.5)) + \n    (0.25+0.5*pow(fract(time*0.5), 2.0))*fract(sin(6.283*100.*(8.0+mod(floor(time*8.)+floor(time*2.0), 3.0))*time)*2.0)*0.5 + \n    ending*(0.5+0.5*fract(time+0.151235))*fract((100.*(mod(floor(time*4.)+floor(time*8.0), 6.0))*time)*2.0)*0.5\n   )*0.5*master;\n}\nfloat s(in float time) {\n    float s;\n    globalTime = time;\n    float k = 2.0;\n    if (mod(floor(time), 10.0) < 2.0) k = fract(time*2.0)*2.0;\n    s += (sound(time*0.5)*k+sound(time+floor(time*0.5+0.5)*0.25))*0.5;\n    return s;\n}\nvec2 mainSound( int samp, float time )\n{\n    float v = 0.0;\n    for (float i = 0.0; i < 1.0; i += 0.01) {\n        v += s(time+i*0.0005)*i*i;\n    }\n    return vec2(clamp(v/30., -1.0, 1.0));\n}","name":"Sound","description":"","type":"sound"}]}