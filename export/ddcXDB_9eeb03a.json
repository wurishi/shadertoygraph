{"ver":"0.1","info":{"id":"ddcXDB","date":"1680370273","viewed":144,"name":"Mouse SirenSDF","username":"snolot","description":"Test to create a mouse.\n\nUse Blackle Mori Siren NN example:https://www.shadertoy.com/view/wtVyWK \nThe shading come from pronce example: https://www.shadertoy.com/view/ttjyRc","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["sdf","fur","neuralnetwork"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//CC0 1.0 Universal https://creativecommons.org/publicdomain/zero/1.0/\n//To the extent possible under law, Blackle Mori has waived all copyright and related or neighboring rights to this work.\n\n//like the last few shaders I've published, this is a neural network experiment.\n//this time, the neural network reproduces an SDF given the x,y,z coordinates\n//using siren networks with skip connections: https://vsitzmann.github.io/siren/\n\n#define R(x) fract(sin(dot(x,vec2(12.9898, 78.233))) * 43758.5453)\n\n// global parameters\nfloat HAIR_LENGTH = 20.0;\nfloat TOUSLE = 0.15;\nfloat BORDER = 1.5;\n\n#define PI 3.14159265\n\n// https://www.shadertoy.com/view/4dS3Wd\nfloat noise (vec2 st)\n{\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    // Four corners in 2D of a tile\n    float a = R(i);\n    float b = R((i + vec2(1.0, 0.0)));\n    float c = R((i + vec2(0.0, 1.0)));\n    float d = R((i + vec2(1.0, 1.0)));\n\n    // Smooth Interpolation\n    vec2 u = smoothstep(0.,1.,f);\n\n    // Mix 4 coorners percentages\n    return (mix(a, b, u.x) +\n            (c - a) * u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y) * 2.0 - 1.0;\n}\n\n//https://thebookofshaders.com/13/\nfloat fbm(vec2 x)\n{\n\tfloat v = 0.0;\n\tfloat a = 0.5;\n\tvec2 shift = vec2(100);\n    mat2 rot = mat2(cos(0.5), sin(0.5), -sin(0.5), cos(0.50));\n\tfor (int i = 0; i < 5; ++i) {\n\t\tv += a * noise(x);\n\t\tx = rot * x * 2.0 + shift;\n\t\ta *= 0.5;\n\t}\n\treturn v;\n}\n\n// generate a hair patch, which is essentially just some fbm noise \n// stretched along one axis based on the rotation value a.\n// to mimic tousling of the hair a random offset is added to the \n// rotation. the hair length is derived from the actual stretch\nfloat hairpatch(vec2 u, vec2 o, float a)\n{\n    a += sin(R(o) * 5.0) * TOUSLE;\n    vec2 d = vec2(1.0 / HAIR_LENGTH, .5);\n\tfloat s = sin(a); float c = cos(a);\n    mat2 m = mat2(c, -s, s, c);\n    u=m*u;\n  \n    float h = (fbm((u + o) * d * 70.0) + 1.0) / 2.0;\n     \n    h = smoothstep(0.0, 2.2, h);\n\n    return max(0.0, 1.0 - min(1.0, 1.0 - h));\n}\n\n// as the hair is organized in patches, each patch has some\n// smooth falloff since patches are blended together dynamically\nfloat hair(vec2 u, vec2 d, float w, float a)\n{\n    float hr = 0.0;\n    u *= w * 4.0;\n    u += d;\n    vec2 hp = fract(u) - vec2(0.5);\n   \tfloat h = hairpatch(hp, floor(u), a);\n    return pow(h * max(1.-length(hp) * BORDER, 0.0),1.0 / 3.0);\n}\n\n// mix 9 hair patches together in order to simulate an overlapping effect\nfloat hairtexture(vec2 uv, float scale, float angle)\n{\n    vec2 offsets[9] = vec2[9](vec2(0.), vec2(.5), vec2(-.5),\n                              vec2(.5,0.), vec2(-.5,0.),\n                              vec2(0.,.5), vec2(0.,-.5),\n                              vec2(.5,-.5), vec2(-.5,.5));\n\n    float f = 0.0;\n\n    for(int i = 0; i < 9; i++)\n    {\n        f = max(f, hair(uv, offsets[i], scale, angle));\n    } \n    \n    return smoothstep(0.0, 1.0, f);\n}\n\nvec3 hyena(vec2 uv)\n{\n    HAIR_LENGTH = 20.0;\n\tTOUSLE = 0.15;\n\tBORDER = 1.5;\n    \n    float angle = (fbm(uv) + 2.0) * PI;\n    float f = hairtexture(uv, 1.0f, angle);\n    \n    // apply color look and use fbm to create darker patches\n    vec3 col = mix(vec3(0.4, 0.3, 0.25) * f * mix(2.0, 4.0, fbm(uv * 8.0)), vec3(1.0), pow(f, 4.0));\n    \n    return col;\n}\n\nvec3 erot(vec3 p, vec3 ax, float ro) {\n    return mix(dot(p,ax)*ax,p,cos(ro))+sin(ro)*cross(ax,p);\n}\n\nfloat scene(vec3 p) {\n   \n    //sdf is undefined outside the unit sphere, uncomment to witness the abominations\n    if (length(p) > 1.) {\n        return length(p)-.8;\n    }\n    // symetry\n    p.y =abs(p.y);\n    // remove seam\n    p.y = sqrt(p.y * p.y + 0.001);\n    \n    //neural networks can be really compact... when they want to be\n      vec4 f0_0=sin(p.y*vec4(-3.33,1.55,-3.05,4.41)+p.z*vec4(-.83,-4.50,-4.15,-1.18)+p.x*vec4(-3.22,.17,.59,2.82)+vec4(-10.98,11.00,-3.69,5.55));\n    vec4 f0_1=sin(p.y*vec4(-1.83,1.46,-.56,3.05)+p.z*vec4(1.98,-1.13,-.85,-5.23)+p.x*vec4(.95,1.63,-6.12,-1.45)+vec4(-1.63,9.81,-.92,-1.55));\n    vec4 f0_2=sin(p.y*vec4(-.57,-.83,6.97,-1.88)+p.z*vec4(-1.38,-3.00,1.28,4.34)+p.x*vec4(1.78,-2.64,1.73,-4.02)+vec4(-1.30,1.21,-13.84,-12.52));\n    vec4 f0_3=sin(p.y*vec4(-6.48,2.95,-4.39,1.45)+p.z*vec4(-5.71,1.05,-5.30,1.61)+p.x*vec4(2.95,.28,-3.58,-6.67)+vec4(11.99,-4.56,-9.18,10.74));\n    vec4 f1_0=sin(mat4(-.09,.33,.56,-.31,.53,-.61,.49,-.20,.28,.00,-.85,.56,-.17,.17,.27,.27)*f0_0+\n    mat4(-.40,.45,-.40,-.71,-.36,.35,1.53,.51,-.38,.13,-.03,-.82,-.65,-.05,-.17,-.10)*f0_1+\n    mat4(.27,-.07,-.13,1.07,.32,.15,.68,.78,.07,.31,.14,-.18,.15,.01,-.06,-.24)*f0_2+\n    mat4(.03,-.17,.28,.02,-.28,-.50,.46,.91,.14,-.13,.04,.07,.09,.21,-.06,-.03)*f0_3+\n    vec4(-1.08,.36,-1.58,2.06))/1.0+f0_0;\n    vec4 f1_1=sin(mat4(-.39,-.63,-.34,-.16,.48,.03,-1.03,-.05,.23,.22,.09,.47,.15,-.30,-.20,-.62)*f0_0+\n    mat4(.80,-.13,.43,.68,-1.20,-.50,.42,.08,-.30,-.06,.63,-.13,-.61,.29,.25,.21)*f0_1+\n    mat4(.25,.54,.52,.16,.58,.04,-.21,.15,.41,-.57,.10,-.02,-.12,.07,-.12,.15)*f0_2+\n    mat4(-.15,-.15,-.02,-.06,-.41,.41,-.09,.38,.13,-.03,.05,.20,-.00,-.16,.12,.26)*f0_3+\n    vec4(2.14,1.28,3.92,4.90))/1.0+f0_1;\n    vec4 f1_2=sin(mat4(-.27,.16,.34,-.20,-.39,-.21,.50,.17,-.13,-.04,-.55,.36,-.02,-.49,.66,.45)*f0_0+\n    mat4(-1.14,.15,.48,.25,.05,-1.50,-.23,.56,-.14,-.43,.07,.09,-.11,-.11,.16,.04)*f0_1+\n    mat4(-.16,-1.41,-.25,-.06,.48,-.79,.02,-.21,.01,-.16,.22,.48,-.04,.05,.25,-.19)*f0_2+\n    mat4(-.04,.17,-.03,-.14,.07,.28,.06,-.76,-.03,-.17,-.25,.26,-.03,.59,.11,.18)*f0_3+\n    vec4(-4.25,1.12,-1.26,6.47))/1.0+f0_2;\n    vec4 f1_3=sin(mat4(-.77,.22,-.18,-.01,.43,-.08,-.10,.19,.23,.22,.17,-.40,-.26,.28,.56,.17)*f0_0+\n    mat4(.39,.59,.66,.63,.05,.06,.34,.06,-.25,.14,-1.03,.08,-.06,.12,.28,-.09)*f0_1+\n    mat4(.09,.04,.92,.41,-.91,-.25,.18,.04,.15,-.10,-.12,.07,.30,.16,-.59,-.12)*f0_2+\n    mat4(.10,-.29,-.06,.06,-.45,-.47,-.26,-.55,.23,.24,.09,-.03,-.27,.45,.32,.56)*f0_3+\n    vec4(2.40,3.06,-2.29,-2.39))/1.0+f0_3;\n    vec4 f2_0=sin(mat4(1.14,.01,-.76,-.07,-.35,1.76,.82,.11,.33,.29,.02,-.24,-.61,.35,-.17,.75)*f1_0+\n    mat4(-.83,.51,-.80,-.46,.44,.88,-.49,-.39,-.52,-.28,.97,-.53,.73,-.15,-.23,.43)*f1_1+\n    mat4(-1.09,-.15,.37,-.08,-.34,.55,-.61,.06,-.47,-.14,-.39,.06,1.01,.13,-.09,-.51)*f1_2+\n    mat4(-.02,.09,-.19,-.18,.88,.88,-.40,-.09,-.12,.49,.25,.45,-.28,.36,.28,.21)*f1_3+\n    vec4(-3.66,3.57,.95,-1.89))/1.4+f1_0;\n    vec4 f2_1=sin(mat4(1.20,.36,-.04,-.15,.84,.68,-.01,.56,.10,-.50,-.87,-.09,-.11,-.15,.67,.61)*f1_0+\n    mat4(-.12,.84,-.42,.26,1.15,-.18,-.62,-.24,.36,.71,-.39,-.22,.09,.35,-.05,-.09)*f1_1+\n    mat4(.93,.44,.11,.55,.29,-.04,.10,.30,-.41,-.32,-.14,.19,.06,.32,-.52,-.21)*f1_2+\n    mat4(-.10,-.02,-.02,-.25,.22,.65,-.53,-.21,.30,-.44,-.13,.19,-.12,-.08,-.77,-.60)*f1_3+\n    vec4(-1.21,2.88,2.61,3.48))/1.4+f1_1;\n    vec4 f2_2=sin(mat4(-.20,.92,.58,.75,.57,1.55,1.87,.08,.61,-.48,-.39,-.69,-.56,.01,.28,-.36)*f1_0+\n    mat4(-.31,.30,-.09,.09,.12,-.15,.14,.04,-.07,-.44,-1.25,-.01,-.49,.59,-.17,-.91)*f1_1+\n    mat4(.88,.32,.08,.83,-.57,.06,.12,-.17,-.22,-.44,-.11,-.85,.34,.49,.30,.53)*f1_2+\n    mat4(.21,.50,.15,-.25,-.01,.76,.23,.22,.22,.05,.35,-.04,.79,.87,-.84,.37)*f1_3+\n    vec4(5.85,3.37,-2.17,-.02))/1.4+f1_2;\n    vec4 f2_3=sin(mat4(.35,.04,-.79,.40,-.39,1.45,.34,-.61,.11,.03,-.54,-.04,.83,-.03,-.31,-.03)*f1_0+\n    mat4(.49,-.02,.35,.03,.52,-.38,-.99,.54,.60,.28,-.64,.27,1.19,-.44,.04,.20)*f1_1+\n    mat4(-.50,-.22,.75,-.39,-.19,.08,.26,-.20,.88,-.13,-.72,.28,-1.24,.12,.52,.26)*f1_2+\n    mat4(.24,.39,.20,-.19,-.49,-.02,.47,.03,.63,.24,.29,-.08,.75,.12,-.18,.34)*f1_3+\n    vec4(-3.59,3.98,-3.50,-6.89))/1.4+f1_3;\n    \n    float d =  dot(f2_0,vec4(-.03,.07,.02,-.06))+\n            dot(f2_1,vec4(-.03,-.03,-.06,-.07))+\n            dot(f2_2,vec4(.06,-.04,-.05,.05))+\n            dot(f2_3,vec4(.03,-.07,-.04,-.13))+0.191;\n            \n    vec3 p2 = p;\n   \n    //d = min(d, length(p)-.4);\n    \n    return d;\n}\n\nvec3 norm(vec3 p) {\n    mat3 k = mat3(p,p,p)-mat3(0.001);\n    return normalize(scene(p) - vec3(scene(k[0]),scene(k[1]),scene(k[2])));\n}\n\n\nvec3 triplanarE(vec3 p, vec3 n){\n    \n    n = max(abs(n) - .2, 0.001);\n    n /= dot(n, vec3(1));\n    vec3 tx = hyena(p.zy).xyz;\n    vec3 ty = hyena(p.xz).xyz;\n    vec3 tz = hyena(p.xy).xyz;\n    \n    // Textures are stored in sRGB (I think), so you have to convert them to linear space \n    // (squaring is a rough approximation) prior to working with them... or something like that. :)\n    // Once the final color value is gamma corrected, you should see correct looking colors.\n    return tx*tx*n.x + ty*ty*n.y + tz*tz*n.z;\n}\n/*\nfloat PRE = 0.01;\nvec3 normal(vec3 p)\n{\n \tvec3 P = vec3(-4, 4, 0) * PRE;\n\n \tvec3 N = normalize(scene(p+P.xyy)*P.xyy+scene(p+P.yxy)*P.yxy+\n                  scene(p+P.yyx)*P.yyx+scene(p+P.xxx)*P.xxx);\n    \n    vec3 B = vec3(triplanarE(p+P.xzz,N).r,triplanarE(p+P.zxz,N).r,\n                  triplanarE(p+P.zzx,N).r)-triplanarE(p,N).r;\n    B = (B-N*dot(B,N));\n    return normalize(N+B*8.0);\n}\n\n\n*/\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    vec2 mouse = (iMouse.xy-0.5*iResolution.xy)/iResolution.y;\n\n    vec3 cam = normalize(vec3(1.5,uv));\n    vec3 init = vec3(-3.,0,0);\n    \n    float yrot = 0.5;\n    float zrot = iTime*.32;\n    if (iMouse.z > 0.) {\n        yrot += -4.*mouse.y;\n        zrot = 4.*mouse.x;\n    }\n    cam = erot(cam, vec3(0,1,0), yrot);\n    init = erot(init, vec3(0,1,0), yrot);\n    cam = erot(cam, vec3(0,0,1), zrot);\n    init = erot(init, vec3(0,0,1), zrot);\n    \n    vec3 p = init;\n    bool hit = false;\n    for (int i = 0; i < 150 && !hit; i++) {\n        float dist = scene(p);\n        hit = dist*dist < 1e-6;\n        p+=dist*cam;\n        if (distance(p,init)>5.) break;\n    }\n    vec3 n = norm(p);\n    \n    //don't ask how I stumbled on this texture\n    vec3 nz = p - erot(p, vec3(1), 2.) + erot(p, vec3(1), 4.);\n    vec3 r = reflect(cam,nz);\n    //float spec = length(sin(r*3.5+sin(nz*120.)*.15)*.4+.6)/sqrt(3.);\n    //spec *= smoothstep(-.3,.2,scene(p+r*.2));\n    //vec3 col = vec3(.1,.1,.12)*spec + pow(spec,8.);*/\n    float bgdot = length(sin(cam*8.)*.4+.6)/2.;\n    vec3 bg = vec3(.1,.1,.11) * bgdot + pow(bgdot, 10.);\n   \n    vec3 lightdir = normalize(vec3(1));\n    \n    float ao = smoothstep(-.5,2.,scene(p+nz*2.))*.9+.1;\n    float ss = smoothstep(-1.,1.,scene(p+lightdir));\n    float spec = length(sin(r*3.)*0.2+0.8)/sqrt(3.);\n    float diff = length(sin(nz*2.)*0.5+0.5)/sqrt(3.);\n    \n    float fres = 1.-abs(dot(nz,cam))*.99;\n    \n    vec3 col = ao*mix(ss,diff,.5)* triplanarE(p * 1.25, n) +pow(spec,25.)*fres*.2;\n    \n    /*if(p.x > .68) \n        col *= .3;*/\n        \n    col = mix(col,vec3(dot(col, vec3(.5, .5, .5))), .5);\n    \n    fragColor.xyz = hit ? col : bg;\n    fragColor = smoothstep(-.02,1.05,sqrt(fragColor)) * (1.- dot(uv,uv)*.5);\n}","name":"Image","description":"","type":"image"}]}