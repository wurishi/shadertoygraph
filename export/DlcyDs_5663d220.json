{"ver":"0.1","info":{"id":"DlcyDs","date":"1699803304","viewed":35,"name":"task08","username":"Kirillog","description":"hw","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["hw"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n// sphere with center in (0, 0, 0)\nfloat sdSphere(vec3 p, float r)\n{\n    return length(p) - r;\n}\n\n// XZ plane\nfloat sdPlane(vec3 p)\n{\n    return p.y;\n}\n\n// косинус который пропускает некоторые периоды, удобно чтобы махать ручкой не все время\nfloat lazycos(float angle)\n{\n    int nsleep = 10;\n\n    int iperiod = int(angle / 6.28318530718) % nsleep;\n    if (iperiod < 3) {\n        return cos(angle);\n    }\n\n    return 1.0;\n}\n\nfloat smin( float a, float b, float k )\n{\n    float h = max( k-abs(a-b), 0.0 )/k;\n    return min( a, b ) - h*h*k*(1.0/4.0);\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\n\nfloat sdHand(vec3 p)\n{\n    p.x = -p.x;\n    return sdCapsule(p, vec3(0.2, 0.5, -0.7), vec3(0.375, 0.3 + (-lazycos(10.0 * iTime) + 1.0) / 16.0, -0.6), 0.05);\n}\n\nfloat symHand(vec3 p)\n{\n    return sdCapsule(p, vec3(0.2, 0.5, -0.7), vec3(0.375, 0.3, -0.6), 0.05);\n}\n\nfloat sdHands(vec3 p)\n{\n    return min(sdHand(p), symHand(p));\n}\n\nfloat sdLeg(vec3 p)\n{\n    return sdCapsule(p, vec3(0.1, 0.1, -0.7), vec3(0.1, -0.04, -0.7), 0.05);\n}\n\nfloat symLeg(vec3 p)\n{\n    p.x = abs(p.x);\n    return sdLeg(p);\n}\n\nfloat sdLegs(vec3 p)\n{\n    return min(sdLeg(p), symLeg(p));\n}\n\n// возможно, для конструирования тела пригодятся какие-то примитивы из набора https://iquilezles.org/articles/distfunctions/\n// способ сделать гладкий переход между примитивами: https://iquilezles.org/articles/smin/\nvec4 sdBody(vec3 p)\n{\n    float d = 1e10;\n\n    d = smin(sdSphere((p - vec3(0.0, 0.35, -0.7)), 0.35),\n             sdSphere((p - vec3(0.0, 0.7, -0.7)), 0.2),\n             0.35);\n    d = smin(d,\n             sdHands(p),\n             0.01);\n\n    d = smin(d,\n             sdLegs(p),\n             0.01);\n\n    // return distance and color\n    return vec4(d, vec3(0.0, 1.0, 0.0));\n}\n\nvec4 sdEyeBall(vec3 p)\n{\n    return vec4(sdSphere(p - vec3(0.0, 0.6, -0.475), 0.2), vec3(1.0, 1.0, 1.0));\n}\n\nvec4 sdEyeIris(vec3 p)\n{\n    return vec4(sdSphere(p - vec3(0.0, 0.6, -0.4), 0.15), vec3(0.67578125, 0.84375, 1.0));\n}\n\nvec4 sdEyePupil(vec3 p)\n{\n    return vec4(sdSphere(p - vec3(0.0, 0.6, -0.3), 0.075), vec3(0.0, 0.0, 0.0));\n\n}\n\nvec4 sdEye(vec3 p)\n{\n    vec4 res = sdEyeBall(p);\n\n    vec4 eyeIris = sdEyeIris(p);\n\n    if (eyeIris.x < res.x) {\n        res = eyeIris;\n    }\n\n    vec4 eyePupil = sdEyePupil(p);\n\n    if (eyePupil.x < res.x) {\n        res = eyePupil;\n    }\n\n\n    return res;\n}\n\nvec4 sdMonster(vec3 p)\n{\n    // при рисовании сложного объекта из нескольких SDF, удобно на верхнем уровне\n    // модифицировать p, чтобы двигать объект как целое\n    p -= vec3(0.0, 0.08, 0.0);\n\n    vec4 res = sdBody(p);\n\n    vec4 eye = sdEye(p);\n    if (eye.x < res.x) {\n        res = eye;\n    }\n\n    return res;\n}\n\n\nvec4 sdTotal(vec3 p)\n{\n    vec4 res = sdMonster(p);\n\n\n    float dist = sdPlane(p);\n    if (dist < res.x) {\n        res = vec4(dist, vec3(1.0, 0.0, 0.0));\n    }\n\n    return res;\n}\n\n// see https://iquilezles.org/articles/normalsSDF/\nvec3 calcNormal( in vec3 p ) // for function f(p)\n{\n    const float eps = 0.0001; // or some other value\n    const vec2 h = vec2(eps,0);\n    return normalize( vec3(sdTotal(p+h.xyy).x - sdTotal(p-h.xyy).x,\n                           sdTotal(p+h.yxy).x - sdTotal(p-h.yxy).x,\n                           sdTotal(p+h.yyx).x - sdTotal(p-h.yyx).x ) );\n}\n\n\nvec4 raycast(vec3 ray_origin, vec3 ray_direction)\n{\n\n    float EPS = 1e-3;\n\n\n    // p = ray_origin + t * ray_direction;\n\n    float t = 0.0;\n\n    for (int iter = 0; iter < 200; ++iter) {\n        vec4 res = sdTotal(ray_origin + t*ray_direction);\n        t += res.x;\n        if (res.x < EPS) {\n            return vec4(t, res.yzw);\n        }\n    }\n\n    return vec4(1e10, vec3(0.0, 0.0, 0.0));\n}\n\n\nfloat shading(vec3 p, vec3 light_source, vec3 normal)\n{\n\n    vec3 light_dir = normalize(light_source - p);\n\n    float shading = dot(light_dir, normal);\n\n    return clamp(shading, 0.5, 1.0);\n\n}\n\n// phong model, see https://en.wikibooks.org/wiki/GLSL_Programming/GLUT/Specular_Highlights\nfloat specular(vec3 p, vec3 light_source, vec3 N, vec3 camera_center, float shinyness)\n{\n    vec3 L = normalize(p - light_source);\n    vec3 R = reflect(L, N);\n\n    vec3 V = normalize(camera_center - p);\n\n    return pow(max(dot(R, V), 0.0), shinyness);\n}\n\n\nfloat castShadow(vec3 p, vec3 light_source)\n{\n\n    vec3 light_dir = p - light_source;\n\n    float target_dist = length(light_dir);\n\n\n    if (raycast(light_source, normalize(light_dir)).x + 0.001 < target_dist) {\n        return 0.5;\n    }\n\n    return 1.0;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.y;\n\n    vec2 wh = vec2(iResolution.x / iResolution.y, 1.0);\n\n\n    vec3 ray_origin = vec3(0.0, 0.5, 1.0);\n    vec3 ray_direction = normalize(vec3(uv - 0.5*wh, -1.0));\n\n\n    vec4 res = raycast(ray_origin, ray_direction);\n\n\n\n    vec3 col = res.yzw;\n\n\n    vec3 surface_point = ray_origin + res.x*ray_direction;\n    vec3 normal = calcNormal(surface_point);\n\n    vec3 light_source = vec3(1.0 + 2.5*sin(iTime), 10.0, 10.0);\n\n    float shad = shading(surface_point, light_source, normal);\n    shad = min(shad, castShadow(surface_point, light_source));\n    col *= shad;\n\n    float spec = specular(surface_point, light_source, normal, ray_origin, 30.0);\n    col += vec3(1.0, 1.0, 1.0) * spec;\n\n\n\n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}