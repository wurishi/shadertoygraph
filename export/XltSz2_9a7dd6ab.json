{"ver":"0.1","info":{"id":"XltSz2","date":"1480699749","viewed":263,"name":"Gold Relic","username":"zackpudil","description":"A kali fractal with a shane style kali bump map. Use mouse to look around.","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","kali","shane"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGRn","filepath":"/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","previewfilepath":"/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define BUMP_MAPPING\n\nfloat time() { return iTime; }\n\nvec3 texcube(sampler2D s, vec3 p, vec3 n) {\n    vec3 m = pow(abs(n), vec3(10.0));\n    \n    vec3 x = texture(s, p.yz).rgb;\n    vec3 y = texture(s, p.xz).rgb;\n    vec3 z = texture(s, p.xy).rgb;\n    \n    return (m.x*x + m.y*y + m.z*z)/(m.x + m.y + m.z);\n}\n\nvec3 texbump(sampler2D s, vec3 p, vec3 n) {\n    vec3 gs = vec3(0.21, 0.72, 0.07);\n    vec2 e = vec2(0.001, 0.0);\n    \n    float f = dot(gs, texcube(s, p, n));\n    vec3 g = (vec3(\n        dot(gs, texcube(s, p - e.xyy, n)),\n        dot(gs, texcube(s, p - e.yxy, n)),\n        dot(gs, texcube(s, p - e.yyx, n))) - f)/e.x;\n    \n    g -= n*dot(g, n);\n    \n    return g;\n}\n\nfloat surf(vec3 p) {\n\tp = abs(0.5 - fract(p*0.5));\n\n\tvec3 c = vec3(2);\n\tfloat es = 0.0, l = 0.0;\n\n\tfor(int i = 0; i < 7; i++) {\n\t\tp = abs(p + c) - abs(p - c) - p;\n\t\tp /= clamp(dot(p, p), 0.15, 1.0);\n\t\tp = -1.5*p + c;\n\n\t\tif(mod(float(i), 2.0) < 1.0) {\n\t\t\tfloat pl = l;\n\t\t\tl = length(p);\n\t\t\tes += exp(-1.0/abs(l - pl));\n\t\t}\n\t}\n    \n    return es;\n}\n\nvec3 surfbump(vec3 p, vec3 n) {\n    vec2 e = vec2(0.025, 0.0);\n    \n    vec3 g = (vec3(\n        surf(p - e.xyy),\n        surf(p - e.yxy),\n        surf(p - e.yyx)) - surf(p))/e.x;\n    \n    g -= n*dot(g,n);\n    return g;\n}\n\nmat2 rotate(float a) {\n    float s = sin(a);\n    float c = cos(a);\n    \n    return mat2(c, s, -s, c);\n}\n\nvec2 path(float z) {\n    return vec2(8.0*cos(0.1*z), 0.0);\n}\n\nvec2 de(vec3 p) {\n    vec3 op = p;\n    vec2 pa = path(p.z);\n    \n    p.xy += pa;\n    p.x = abs(p.x) - 3.5;\n    p.z = mod(p.z + 3.5, 7.0) - 3.5;\n    \n    vec4 q = vec4(p, 1);\n    q.xyz -= 1.0;\n    \n    for(int i = 0; i < 3; i++) {\n        q.xyz = abs(q.xyz + 1.0) - 1.0;\n        q /= clamp(dot(q.xyz, q.xyz), 0.5, 1.0);\n        q *= 1.2;\n        \n        if(i < 2) q.zy *= rotate(-0.5);\n    }\n    \n    vec2 o = vec2((length(q.xz) - 1.5)/q.w, 1.0);\n    \n    vec2 tun = abs(op.xy + pa)*vec2(0.2, 0.3);\n    vec2 f = vec2(1.0 - max(tun.x, tun.y), 0.0);\n    \n\treturn o.x < f.x ? o : f;\n}\n\nvec2 trace(vec3 ro, vec3 rd, float mx) {\n    float t = 0.0;\n   \tfloat m = 0.0;\n    for(int i = 0; i < 200; i++) {\n        vec2 d = de(ro + rd*t);\n        if(d.x < 0.001 || t >= mx) break;\n        t += d.x*0.5;\n        m = d.y;\n    }\n    return vec2(t, m);\n}\n\nvec3 normal(vec3 p) {\n    vec2 e = vec2(0.001, 0.0);\n    vec3 n = normalize(vec3(\n        de(p + e.xyy).x - de(p - e.xyy).x,\n        de(p + e.yxy).x - de(p - e.yxy).x,\n        de(p + e.yyx).x - de(p - e.yyx).x\n\t));\n    \n    vec3 b1, b2;\n\n    #ifdef BUMP_MAPPING\n    vec2 i = de(p);\n    if(i.y == 1.0) b1 = surfbump(p, n);\n    else b2 = texbump(iChannel1, 0.1*p, n);\n    #endif\n\t\n    return normalize(n + 0.02*b1 + 0.05*b2);\n}\n\nfloat ao(vec3 p, vec3 n) {\n    float o = 0.0, s = 0.005;\n    for(int i = 0; i < 15; i++) {\n        float d = de(p + n*s).x;\n        o += (s - d);\n        s += s/float(i + 1);\n    }\n    return 1.0 - clamp(o, 0.0, 1.0);\n}\n\nvec3 render(vec3 ro, vec3 rd) {\n    vec3 col = vec3(0);\n    \n    vec2 t = trace(ro, rd, 50.0);\n    if(t.x < 50.0) {\n        vec3 pos = ro + rd*t.x;\n        vec3 nor = normal(pos);\n        vec3 ref = normalize(reflect(rd, nor));\n        \n        vec3 key = vec3(0, 1, time()*0.8);\n        \n        float occ = ao(pos, nor);\n        float dom = step(2.0, trace(pos + nor*0.005, ref, 2.0).x);\n\n        \n        col = vec3(0.2)*occ;\n        col += 1.5*pow(clamp(dot(-rd, ref), 0.0, 1.0), 2.0)*occ;        \n\t\tcol += clamp(1.0 + dot(rd, nor), 0.0, 1.0)*dom;\n        \n        if(t.y == 1.0) {\n        \tcol *= texcube(iChannel0, pos, nor)*vec3(2.0, 1.7, 1.0);\n        } else {\n            \n            col *= texcube(iChannel1, 0.1*pos, nor);\n        }\n    }\n    \n    col = mix(col, vec3(0), 1.0 - exp(-0.2*t.x));\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n    vec2 mo = (-iResolution.xy + 2.0*iMouse.xy)/iResolution.y;\n    float at = time()*0.8;\n    \n    vec3 ro = vec3(0.0, 1.0, at);\n    ro.xy -= path(ro.z);\n    \n    vec3 la = vec3(2.0*mo.x, 1.0 + 2.0*mo.y, at + 1.0);\n    la.xy -= path(la.z);\n    \n    vec3 ww = normalize(la-ro);\n    vec3 uu = normalize(cross(vec3(0, 1, 0), ww));\n    vec3 vv = normalize(cross(ww, uu));\n    vec3 rd = normalize(uv.x*uu + uv.y*vv + 1.97*ww);\n    \n    vec3 col = render(ro, rd);\n    \n    col = 1.0 - exp(-0.45*col);\n    col = pow(abs(col), vec3(1.0/2.2));\n    \n\tfragColor = vec4(col, 1);\n}","name":"Image","description":"","type":"image"}]}