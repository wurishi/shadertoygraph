{"ver":"0.1","info":{"id":"ldyGWK","date":"1456627443","viewed":388,"name":"Raytrace Collab v3.1","username":"polkm","description":"Third version of a collaborative project between @Alleycatsphinx and @pollkem. RIP FPS edition","likes":11,"published":1,"flags":32,"usePreview":0,"tags":["distancefields","raytrace"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Screen space effects\n\nvec4 bigSample(vec2 uv, float offScale)\n{\n    vec2 off = vec2(.5, 1.5) / iResolution.xy * offScale;\n\tvec4 col = texture(iChannel0, uv);\n    col += texture(iChannel0, uv + off);\n    col += texture(iChannel0, uv - off);\n    col += texture(iChannel0, uv + off.yx);\n    col += texture(iChannel0, uv - off.yx);\n    return col / 5.0;\n}\n\nfloat focusDepth()\n{\n\treturn bigSample(vec2(0.5, 0.5), 30.0).a;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    vec4 col = texture(iChannel0, uv);\n    vec4 blur = bigSample(uv, 1.0);\n    \n    col = mix(col, blur, abs(col.a - focusDepth()) * 1.0);\n    \n    // Gamma correction\n    col.rgb = pow(col.rgb, vec3(0.4545));\n    \n\tfragColor = vec4(col.rgb, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4sf3Rn","filepath":"/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","previewfilepath":"/media/ap/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"const mat2 m2 = mat2(0.8,-0.6,0.6,0.8);\n\nfloat hash(float n)\n{\n    return fract(sin(n)*753.5453123);\n}\nfloat noise(vec3 x)\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f * f * (3.0 - 2.0 * f);\n\t\n    float n = p.x + p.y*157.0 + 113.0*p.z;\n    return mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                   mix( hash(n+157.0), hash(n+158.0),f.x),f.y),\n               mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                   mix( hash(n+270.0), hash(n+271.0),f.x),f.y),f.z);\n}\n\nfloat fbm(vec3 co, float freq)\n{\n    float amp = 0.55;\n    float sum = 0.0;\n    for (int i = 0; i < 8; i++) {\n        sum += noise(co * freq) * amp;\n        freq *= 2.0;\n        amp *= 0.5;\n    }\n\n    return clamp(sum, 0.0, 1.0);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float t = iTime * 1.0;\n    \n    vec2 fbmi = iResolution.xy * vec2(fbm(vec3(fragCoord, 34254.0 + t), 0.003), fbm(vec3(fragCoord, 2345.0 + t), 0.003));\n    \n    float h = pow(fbm(vec3(fbmi * 0.5, 0.), 0.1), 1.0) * 255.0 * 255.0 / 4.0;\n    \n    fragColor = vec4(mod(h / 255.0, 1.0), mod(floor(h / 255.0) / 255.0, 1.0), 0.0, 1.0);\n    \n}","name":"Buf A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// ro, rd is ray origin and ray direction\n\nconst vec3 sunDir = normalize(vec3(-0.2, 0.1, -0.5));\nconst float waterHeight = -300.0;\n\nconst float tmin = 0.1;\nconst float tmax = 8000.0;\n\n// Colors\nconst vec4 daySkyColor = vec4(0.3, .55, 0.76, 1.0);\nconst vec4 nightSkyColor = vec4(0.04, .06, 0.08, 1.0);\nconst vec4 horizonColor = vec4(0.7, 0.75, 0.8, 1.0);\n\nconst vec4 dirtColor = vec4(0.55, .5, 0.3, 1.0);\n\nconst vec4 waterColor = vec4(0.15, 0.22, 0.30, 1.0);\n\nfloat bound(float angle)\n{\n\treturn max(angle, .00392156);\n}\n\nfloat fold(in float x)\n{\n\treturn bound(abs(fract(x)-.5));\n}\n\nvec3 fold(in vec3 p)\n{\n\treturn vec3(fold(p.x), fold(p.y), fold(p.z));\n}\n\nfloat origami(in vec3 position)\n{\n\tfloat amplitude = .5;\t\n    float frequency\t= 2.;\n\tfloat result\t= 0.;\n\tfor(int i = 0; i < 4; i++)\n\t{\n        position \t+= fold(position + fold(position).yzx).zxy;\n        position \t*= frequency;\n        position\t+= .0125;\n        result\t\t+= length(position)*amplitude;\n\t\tamplitude \t*= .5;\n\t}\n\treturn result;\n}\n\n// Height map\nfloat terrain(vec2 x)\n{\n    vec2 uv = vec2(0.5, 0.5) + (x / iResolution.xy / 20.0);\n    if (uv.x < 0.0 || uv.y < 0.0 || uv.x > 1.0 || uv.y > 1.0)\n        return 0.0;\n    vec4 d \t\t\t= texture(iChannel0, uv);\n    float size \t\t= 256.0;\n    return (d.r * size + d.g * size * size) / 50.0;\n    //return 0.0;\n}\n\n\nfloat distTerrain(vec3 pos)\n{\n    float heightmap \t= terrain(pos.xz);\t\n  \n    float volume \t\t= origami(vec3(pos.x - heightmap * 8., pos.y - heightmap * 8., pos.z)*.00035);   \n \t\n    volume\t\t\t\t*= 128.;\n    heightmap\t\t\t*= 1.0;\n    \n    return pos.y - heightmap + volume;\n}\n\nfloat traceTerrain(vec3 ro, vec3 rd)\n{\n    float t \t= tmin;\n    bool h \t\t= false;\n    for (int i = 0; i < 256; i++) \n    {\n\t\tif(!h)//confusingly faster this way, at least on my machine\n        {\n        \tvec3 pos \t= ro + t * rd;\n\n        \tfloat dist \t= distTerrain(pos);\n\t\t\tt \t\t\t= t + dist * .2;\n\t        h \t\t\t= dist < (0.005 * t) || t > tmax;;\n        }\n    }\n    return t;\n}\n\n// Rendering\n\nfloat shadow(const in vec3 position, const in vec3 direction)\n{\n\tfloat exposure \t= 1.0;\n\tfloat penumbra \t= 5.95;\n\tfloat umbra\t\t= .005;\n\t\n    \tfor(int i = 1; i < 12; ++i)\n    \t{\n\t\tfloat range\t= max(0., distTerrain(position + direction * penumbra));\n\t\t\n\t\tif ( range < umbra) return umbra;\n\t\t\n\t\texposure \t= min( exposure, 3. * range / penumbra);\n\t\tpenumbra \t+= range;\n\t}\n\t\n\treturn clamp(exposure, 0., 1.);\n}\n\nvec3 renderSky(vec3 ro, vec3 rd)\n{\n    float sundot = clamp(dot(rd, sunDir), 0.0, 1.0);\n    // sky\n    float dayNight = clamp(sunDir.y * 2.0, 0.0, 1.0);\n    vec3 col = mix(nightSkyColor, daySkyColor, dayNight).rgb * (1.0 - 0.8 * rd.y) * 0.9;\n\n    // stars\n    // vec2 stco = floor(vec2(atan(rd.z / rd.x), rd.y * 2) * SC * 1.0 / 3.0) * 3.0;\n    // color += clamp(pow(step(0.999, noised(stco).x), 1) * (1 - (dayNight + 0.8)), 0, 1);\n\n    // horizon\n    col = mix(col, horizonColor.rgb, pow(1.0 - max(rd.y, 0.0), 8.0));\n    \n    // sun\n    float sun = 0.0;\n    if (sundot > 0.9995) {\n        sun = 1.0;\n    }\n    col += 0.5 * vec3(1.0, 0.7, 0.4) * sun;\n    col += 0.25 * vec3(1.0, 0.7, 0.4) * pow(sundot, 5.0);\n    col += 0.25 * vec3(1.0, 0.8, 0.6) * pow(sundot, 64.0);\n    col += 0.6 * vec3(1.0, 0.8, 0.6) * pow(sundot, 1028.0);\n\n\treturn col;\n}\n\nvec3 hsv(in float h, in float s, in float v){\n    return mix(vec3(1.),clamp((abs(fract(h+vec3(3.,2.,1.)/3.)*6.-3.)-1.),0.,1.),s)*v;\n}\n\n\nvec3 tetraNormal(const in vec3 position, const in float epsilon)\n{\n\tvec2 offset = vec2(epsilon, -epsilon);\n\tvec4 simplex = vec4(0.);\n\tsimplex.x = distTerrain(position + offset.xyy);\n\tsimplex.y = distTerrain(position + offset.yyx);\n\tsimplex.z = distTerrain(position + offset.yxy );\n\tsimplex.w = distTerrain(position + offset.xxx);\n\t\n\tvec3 normal = offset.xyy * simplex.x + offset.yyx * simplex.y + offset.yxy * simplex.z + offset.xxx * simplex.w;\n\treturn normalize(normal);\n}\n\nvec3 terrainNormal(vec3 pos, float t) // (thanks iq again)\n{\n    vec2 eps = vec2(0.001 * t, 0.0);\n    return normalize(vec3(\n        terrain(pos.xz - eps.xy) - terrain(pos.xz + eps.xy), \n        2.0 * eps.x,\n        terrain(pos.xz - eps.yx) - terrain(pos.xz + eps.yx)\n    ));\n}\n\nvec3 zonal_harmonic(vec3 normal, vec3 light_direction)\n{\n    vec3 light\t\t\t= vec3(0.);   \n\tvec4 n4\t\t\t\t= vec4(normalize(normal+light_direction), 1.);\n    \n    //offsets for direction and spread of red, green and blue\n    vec4 red\t\t\t= vec4(  0.7,  .9,  0.4,  0.4);\n    vec4 green\t\t\t= vec4(  0.4,  .6,  -.1,  0.1);\n    vec4 blue\t\t\t= vec4(  0.2,  .35,  -.4,  -.2);   \n\n    light.r \t\t\t= dot(  red, n4); \n\tlight.g \t\t\t= dot(green, n4);\n\tlight.b \t\t\t= dot( blue, n4);\n    \n    return light;\n}\n\nvec3 applyLighting(vec3 col, vec3 pos, vec3 norm, vec3 rd, float t)\n{\n    vec3 light_color \t= zonal_harmonic(norm, sunDir);\n\n    float shadows\t\t= shadow(pos+sunDir, sunDir);\n\n\tfloat sundot\t\t= dot(norm, sunDir);\n    float incidence\t\t= max(0., sundot);\n    col \t\t\t\t= .25 * col * shadows + col * light_color * incidence;\n    col \t\t\t\t*= shadows*light_color*.45+.55;\n    \n    // fog\n    vec3 fogColor = horizonColor.rgb * clamp((1.0 - 0.8 * rd.y) * 0.9, 0.5, 1.0);\n    float fo = 1.0-exp(-0.000000008 * t * t);\n    //float dist = length(pos - iCameraPos);\n    vec3 fco = 0.7 * fogColor + 0.1 * vec3(1.0, 0.8, 0.5) * pow(clamp(sundot, 0.5, 1.0), 4.0);\n    col = mix(col, fco, fo);\n\n    \n    return col;\n}\n\nvec3 renderTerrain(vec3 ro, vec3 rd, float t)\n{\n    vec3 pos \t\t\t= ro + rd * t;\n    vec3 norm \t\t\t= tetraNormal(pos, t*.00125);\n    norm\t\t\t\t= (norm);\n    \n    float upward_face\t= clamp(pow(norm.y, .5), 0., 1.);\n  \n    vec3 col \t\t\t= dirtColor.rgb;\n\n    vec3 stripes\t\t= hsv(1.-length(norm.xz)*4.+pos.y*.1*norm.y*.125, .4, 1.);\n    col\t\t\t\t\t= mix(col, stripes, 1.-upward_face);\n    \n    norm\t\t\t\t= normalize(norm + terrainNormal(pos, t));\n    \n    col = applyLighting(col, pos, norm, rd, t);\n    \n    return col;\n}\n\nvec4 renderOpaque(vec3 ro, vec3 rd)\n{\n    vec3 col = vec3(1, 1, 1);\n\n    float terrainT = traceTerrain(ro, rd);\n\n    if (terrainT > tmax)\n        col = renderSky(ro, rd);\n    else\n        col = renderTerrain(ro, rd, terrainT);\n    \n    return vec4(col, terrainT);\n}\n\nfloat distWater(vec3 p)\n{\n    return p.y - waterHeight;\n}\n\nfloat traceWater(vec3 ro, vec3 rd)\n{\n    float t \t= tmin;\n    bool h \t\t= false;\n    for (int i = 0; i < 128; i++) \n    {\n        if(!h)//confusingly faster this way, at least on my machine\n        {\n            vec3 pos \t= ro + t * rd;\n            float dist \t= distWater(pos);\n            t \t\t\t= t + dist * 0.2;\n            h \t\t\t= dist < (0.005 * t) || t > tmax;\n        }\n    }\n    return t;\n}\n\nvec3 renderWater(vec3 ro, vec3 rd, float t, vec4 transCol)\n{\n    vec3 col = waterColor.rgb;\n    vec3 pos \t\t\t= ro + rd * t;\n    vec3 norm \t\t\t= vec3(0., 1., 0.);\n    \n    vec3 floorPos = pos + transCol.w * rd;\n    //float depth = (1.0 - clamp((waterHeight - floorPos.y) / 2000.0, 0.0, 1.0));\n    float depth = clamp(1.0 - (transCol.w - t) / 200.0, 0.0, 1.0);\n    \n    col = applyLighting(col, pos, norm, rd, t);\n\n    col = mix(col, transCol.rgb, depth);\n\n    // vec4 refractCol = renderReflect(pos, refract(rd, norm, 1.0 / waterETA));\n    // col = mix(col, refractCol.rgb, 0.5 * depth);\n\n    vec4 reflectCol = renderOpaque(pos, reflect(rd, norm));\n    col = mix(col, reflectCol.rgb, 0.2);\n    \n    return col;\n}\n\nvec4 render(vec3 ro, vec3 rd)\n{\n \tvec4 col = renderOpaque(ro, rd);\n    \n    float waterT = traceWater(ro, rd);\n    if (waterT < col.w && waterT < tmax)\n        col = vec4(renderWater(ro, rd, waterT, col), waterT);\n    \n    return col;\n}\n\n// Camera\nvec3 cameraPos()\n{\n//    float theta = iTime * .0125;\n    float theta = (8.*atan(1.)) * iMouse.x/iResolution.x * 2.0 + 1.5;\n    float dist = 1.0 + abs(iMouse.y/iResolution.y - 0.5) * 5.;\n\tvec3 pos\t= vec3(cos(theta), .0, sin(theta)) * dist;\n    \n    pos.y += 0.0 + iMouse.y/iResolution.y * 1.0;\n    \n    return pos;\n}\n\nvec3 cameraDir()\n{\n \treturn normalize(vec3(0.0, 0.0, 0.0) - cameraPos());   \n}\n\nmat3 buildViewMatrix(vec3 ro, vec3 ta, float cr)\n{\n    vec3 cw = normalize(ta - ro);\n    vec3 cp = vec3(sin(cr), cos(cr), 0.0);\n    vec3 cu = normalize(cross(cw, cp));\n    vec3 cv = normalize(cross(cu, cw));\n    return mat3(cu, cv, cw);\n}\n\nvec3 buildRayDirection(vec2 xy, mat3 view)\n{\n    vec2 s = xy * vec2(iResolution.x / iResolution.y, 1.0);\n    return view * normalize(vec3(s.xy, 2.0));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    vec3 ro = 1100.0 * cameraPos();\n    vec3 ta = ro + 1100.0 * cameraDir();\n    //ro.y = max(ro.y, max(terrain(ro.xz), waterHeight + 10.0) + 1.0);\n    float cr = 0.01;\n\n    mat3 view = buildViewMatrix(ro, ta, cr);\n\n    vec2 xy = -1.0 + 2.0 * fragCoord.xy / iResolution.xy;\n\n    // Camera ray\n    vec3 rd = buildRayDirection(xy, view);\n\n    vec4 col = render(ro, rd);\n\n    \n\tfragColor = vec4(col.rgb, col.w / tmax);\n}","name":"Buf B","description":"","type":"buffer"}]}