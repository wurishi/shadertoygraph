{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"#ifdef GL_ES\nprecision highp float;\n#endif\n\n//credits: mad thanks to iq for lots of stuff, and also the glsl sandbox editor\n//(I just dont get math unless I can see the pictures nice and big)\n//Also thanks for the optimized tree fold/mirror/rotate whatevs code - not sure where it came from =(\n\n#define phi .003\n#define farplane 4.\n//#define modulus //extend the farplane for this\n#define pi 4.*atan(1.)\n#define sin45deg sqrt(2.)/2.\n\n#define time iTime\n#define mouse iMouse\n#define resolution iResolution\n\nstruct ray{\n\tvec3 o, p, d, c;\n\tfloat l;\n};\n\nstruct light{\n\tvec3 p, d, c;\n};\n    \nstruct mat{\n\tvec3  dc, sc;\n\tfloat r, i;\n};\n\nstruct env{\n\tvec3  l;\n\tfloat f;\n};\n    \nfloat \tsphere(vec3 rp, vec3 sp, float r);\nfloat   capsule( vec3 p, vec3 a, vec3 b, float r );\n\nfloat \tmap(vec3 p);\nvec3 \tderivate(vec3 p);\nray \ttrace(ray r);\n\nvec3    shade(ray r, light l, mat m, env e, vec3 n);\nfloat   fresnel(float i, float ndv);\nfloat   geometry(float r, float ndl, float ndv, float hdn, float hdv, float hdl);\nfloat   distribution(float r, float ndh);\nfloat   shadow(vec3 p, vec3 d, float ndl);\nfloat   occlusion(vec3 p, vec3 n);\n\nvec3    harmonic(in vec4 n);\n\nint material = 1;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 uv = fragCoord.xy/resolution.xy;\n\tuv      = uv * 2. - 1.;\n\tuv.x \t*= resolution.x/resolution.y;\n\t\n\tray r;\n\tr.d = normalize(vec3(uv, 1.5));\n    r.d.y+=.15;\n    r.o = vec3(-.65, 1.1, -2.65);\n\tr.p = vec3(0.);\n    r.c = vec3(0.0);\n    \n      \n    float m = (mouse.x/resolution.x-.5)*6.28;\n    mat2 rot = mat2(cos(m), sin(m), -sin(m), cos(m));\n    #ifdef modulus\n       r.d.xz *= rot;\n    #endif\n    \n\tr = trace(r);\n\n    vec3 n = derivate(r.p);\n\t\n    env e;\n    e.f = length(r.c);\n    \n\tif(r.l < farplane){\n\t\tlight l;\n        l.p = vec3(16., 13., -3.);\n\t\t#ifndef modulus\n\t\t\tl.p.xz*=rot;\n        #endif \n\t\t\n        l.c = vec3(.8, .8, .75);\n\t\tl.d\t= normalize(l.p-r.p);\n        \n        e.l = harmonic(vec4(n, 1.))+e.f;\n        r.c = e.f+e.l*.005;\n        \n        mat m;\n        if(material == 0)\n        {\n            vec3 c0 = vec3(.85, .5, .4);\n            vec3 c1 = vec3(.45, .5, .1);\n            float b = clamp(.25+r.p.y*.125, 0., 1.);\n            m.dc = mix(c0, c1, b);\n            m.sc = vec3(.75);\n            m.r = .65;\n            m.i = 12.32;\n\n        }\n        else if(material == 1)\n        {\n            vec3 c0 = vec3(.4, .76, .51);\n            vec3 c1 = vec3(.6, .8, .3);\n            float b = clamp(1.-length(r.p)*.25, 0., 1.);\n            m.dc = mix(c0, c1, b);\n            m.sc = vec3(.75, .75, .85);\n            m.r = .9132;\n            m.i = 8.32;\n        }\n        else if(material == 2)\n        {\n            vec3 c0 = vec3(.24, .6, .2);\n            vec3 c1 = vec3(.6, .8, .3);\n            float b = clamp(1.-length(r.p)*.25, 0., 1.);\n            m.dc = mix(c0, c1, b);\n            m.sc = vec3(.75, .75, .85);\n            m.r = .7132;\n            m.i = 15.32;\n        }\n\t\t\n        r.c = shade(r, l, m, e, n);\n        r.c += e.f * .95 * r.c;\n\t}else\n    {\n\t\tr.p.xz *= rot; //h4x\n        e.l = harmonic(vec4(normalize(r.p), 1.));\n        r.c += e.l;\n    }\n\t\n\tfragColor = vec4(r.c, 1.);\n}\n\nfloat sphere(vec3 rp, vec3 sp, float r){\n\treturn length(rp - sp)-r;\t\t\n}\n\nfloat capsule( vec3 p, vec3 a, vec3 b, float r )\n{\n\tvec3 pa = p - a;\n\tvec3 ba = b - a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\t\n\treturn length( pa - ba*h ) - r;\n}\n\nvec3 foldY(vec3 P, float n)\n{\n\tfloat r = length(P.xz);\n\tfloat a = atan(P.z, P.x);\n\tfloat c = 3.14159265358979 / n;\n\n\ta = mod(a, 2.0 * c) - c; \n\n\tP.x = r * cos(a);\n\tP.z = r * sin(a);\n\n\treturn P;\n}\n\n// Optimized case for 4 repetitions\nvec3 foldY4(vec3 p)\n{\n\tp.xz = vec2(p.x + p.z, p.z - p.x) * sin45deg;\n\tp.xz = abs(p.x) > abs(p.z) ? p.xz * sign(p.x) : vec2(p.z,-p.x) * sign(p.z);\n\treturn p;\n}\n\nvec3 rotateZ(vec3 p, float a)\n{\n\tfloat c = cos(a);\n\tfloat s = sin(a);\n\n\treturn vec3(c * p.x - s * p.y, s * p.x + c * p.y, p.z);\n}\n\nfloat tree(float a, float p, vec2 uv){\n    float t;\n\tt = fract(uv.y*p) + .5;\n\tt *= a;\n    return t;\n}  \n\nfloat cylinder(vec3 p, vec3 c, float h, float r)\n{\n    p -= c;\n\n\treturn max(abs(p.y) - 0.5 * h, length(p.xz) - r);\n}\n\nfloat map(vec3 p)\n{ \n    vec3  o = p; //origin\n    vec3 np = p;\n    \n    #ifdef modulus\n        o.xz    = mod(o.xz, 7.)-3.5;\n    #endif\n    \n    np = vec3(p.x-p.z-.4, p.y, p.z-p.x+.015);\n    float lp = length(16.*(p+p.x+p.z)-vec3(0., 13., 0.));\n    \n    vec4 n = vec4(1.); //removed noise\n  \n   o +=  .05 * n.xyz * (2. - max(1., 5.-p.y));\n\n//  vec2 m = mouse;\n    vec2 m = vec2(.95, .65);\n    \n    float r = m.y;                                 //rotation\n//  float r = sin45deg;\n    \n    float w = m.x*.2/length(o+vec3(0., .3+r, 0.)); //branch width\n\n    float f = 1.;\n    float a = (cos(2.*time+p.z+p.y-sin(p.x+time*.15)*.13*n.x)-.5)*.0051;\n    float t = 999.;                                //tree\n    for (int i = 0; i < 7; i++)\n\t{\n        t = min(t, cylinder(o, vec3(0.0), r+1., w)/f);\n\t\to = 1.5 * o + a;                            //length change across iterations\n\t\tf = 1.4 * f;                                //thickness change across iterations\n\t\to = foldY4(o);                              //branching\n        //o = foldY(o, abs(r/2.));\n\t\to = rotateZ(o,r+a*.25);\n\n\t\to.x -= -r;                                  //rotate\n\t\to.y -= .5+r;                                //translate and rotate\n    }\n    \n    t += .005;                                      //additioal thickness adjustment\n\t\n    float l = length(o*vec3(4., 1., 9.)+a);         //leaves\n\tl *= .00785;\n    \n    material = t < l ? 0 : 1;\n    \n    t = min(t, l);\n    float g = p.y+(n.w+n.z)*.05;\n    p.xz = mod(o.xz*.025-p.xz+a*2.+p.y*.05, .05)-.025;\n    g = min(g, cylinder(p, vec3(0.0), n.x*.325+n.w, .01-.01*n.x));\n   \n    t = min(t, g);\n\n    material = t < g ? material : 2;\n   \n    return min(t,g);\n}\n\n//precision adj via hoskins (you rock dude)\nray trace(ray r){\n\tfloat precis = phi;\n    float h\t\t = precis*.2;\n    float t\t\t = .01;\n\tfloat res\t = 32.;\n\tbool hit\t = false;\n    float f      = .0;\n\t\n    for( int i = 0; i < 128; i++ )\n    {\n      \tif (!hit && t < farplane)\n\t\t{\n            r.p = r.o + r.d * t;\n\t\t\th = map(r.p);\n\t\t\tif (h < precis)\n\t\t\t{\n\t\t\t\tres = t;\n\t\t\t\thit = true;\n\t\t\t}\n\t\t\tt += h * .8;\n\t\t\tprecis *= 1.03;\n            f += .01/abs(t-h); \n\t\t}\n    }\n    r.c += f;\n    r.l = res;\n    return r;\n}\n\nvec3 derivate(vec3 p){\n\tvec3 n;\n\tvec2 d = vec2(0., .01);\n\tn.x = map(p+d.yxx)-map(p-d.yxx);\n\tn.y = map(p+d.xyx)-map(p-d.xyx);\n\tn.z = map(p+d.xxy)-map(p-d.xxy);\n    return normalize(n);\n}\n\n//via florian hoenig\nfloat smoothmin(float a, float b, float k)\n{\n\treturn -(log(exp(k*-a)+exp(k*-b))/k);\n}\n\n//physically based lighting model largely from Simon Brown - http://www.sjbrown.co.uk/ \nvec3 shade(ray r, light l, mat m, env e, vec3 n){\n\tfloat ll    = distance(r.p, l.p);\n\n\tm.r \t\t= clamp(m.r, 0.02,  1.);\n\tm.i \t\t= clamp(m.i, 1., 20.);    \t\t\t\t\n\t\n\tvec3 v    =  normalize(r.o-r.p);\n\tvec3 h\t  =  normalize(v + l.d); \n\n\tfloat ndl = dot(n, l.d);\n\tfloat ndv = dot(n, v);\n\n\tfloat hdn = dot(h, n);\n\tfloat hdv = dot(h, v);\n\tfloat hdl = dot(h, l.d);\n\n\tfloat fr = fresnel(m.i, ndl);\n\tfloat g  = geometry(m.r, ndl, ndv, hdn, hdv, hdl);\n\tfloat ds = distribution(m.r, hdn);\n\tfloat nf = 1.-fr;\n\n\tndl = max(ndl, 0.0);\n\tndv = max(ndv, 0.0);\n\tfloat brdf =  fr * g * ds / (4. * ndl * ndv);\n\n\tfloat ss  \t= shadow(r.p, l.d, ndl);\n\tfloat oc  \t= occlusion(r.p, n);\n\n\tvec3 c; \n\tc  = m.dc * e.l + ndl * nf * m.dc * l.c * oc;\n\tc += brdf * m.sc;\n\tc *= ss * l.c * oc;\n\n\treturn c;\n}\n\nfloat fresnel(float i, float ndv)\n{   \n\ti = (1.33 - i)/(1.33 + i);\n\ti *= i;\n\treturn i + (1.-i) * pow(1.-max(ndv, 0.), 5.);\n}\n\nfloat geometry(float r, float ndl, float ndv, float hdn, float hdv, float hdl)\n{\n\t//cook torrence\n\t//return min(min(2. * hdn * max(ndv, 0.) / hdv, 2. * hdn * max(ndl, 0.) / hdv), 1.);\n\n\t//schlick\n\tndl = max(ndl, 0.);\n\tndv = max(ndv, 0.);\n\tfloat k= r * sqrt(2./pi);\n\tfloat one_minus_k= 1. -k;\n\treturn ( ndl / (ndl * one_minus_k + k) ) * ( ndv / (ndv * one_minus_k + k) );\n}\n\nfloat distribution(float r, float ndh)\n{  \n\t//blinn phong\n\t//\tfloat m= 2./(r*r) - 2.;\n\t//\treturn (m+2.) * pow(max(ndh, 0.0), m) / tau;\n\n\t//beckman\n    float m_Sq= r * r;\n\tfloat NdotH_Sq= max(ndh, 0.0);\n\tNdotH_Sq= NdotH_Sq * NdotH_Sq;\n\treturn exp( (NdotH_Sq - 1.0)/(m_Sq*NdotH_Sq) )/ (3.14159265 * m_Sq * NdotH_Sq * NdotH_Sq);\n}\n\n//via peter pike sloan\nvec3 harmonic(in vec4 n){ \t\n  \n\tvec3 l1, l2, l3;\n    \n    vec4 c[7];\n\tc[0] = vec4(0.2, .47, .2, 0.25);\n\tc[1] = vec4(0.2, .33, .2, 0.25);\n\tc[2] = vec4(0.0,-.13, -.1,0.15);\n\tc[3] = vec4(0.1, -.1, 0.1, 0.0);\n\tc[4] = vec4(0.1,-0.1, 0.1, 0.0);\n\tc[5] = vec4(0.2, 0.2, 0.2, 0.0);\n\tc[6] = vec4(0.0, 0.0, 0.0, 0.0);\n    \n\tl1.r = dot(c[0], n);\n\tl1.g = dot(c[1], n);\n\tl1.b = dot(c[2], n);\n\t\n\tvec4 m2 = n.xyzz * n.yzzx;\n\tl2.r = dot(c[3], m2);\n\tl2.g = dot(c[4], m2);\n\tl2.b = dot(c[5], m2);\n\t\n\tfloat m3 = n.x*n.x - n.y*n.y;\n\tl3 = c[6].xyz * m3;\n    \t\n\tvec3 sh = vec3(l1 + l2 + l3);\n\t\n\treturn clamp(sh, 0., 1.);\n}\n\n#define odist \t.5\t\n#define obias \t.05\t\n#define omin \t.2\t\n#define oiter    5\t\n\nfloat occlusion(vec3 p, vec3 n)\n{\n    float d = odist;\n\tfloat oc = 0.0;\n    for( int i=0; i<oiter; i++ )\n    {\n        float hr  = .01 + obias*float(i);\n        vec3  op  = n * hr + p;\n        float l   = map(op);\n        oc \t\t += -(l-hr)*d;\n        d\t   \t *= 0.75;\n    }\n    return clamp( 1. - 4.*oc, omin, 1. );\n}\n\n#define sblend\t 5.\n#define sproj\t.25 \n#define smax\t.8  \n#define smin\t.25  \n#define siter    16\n\nfloat shadow(vec3 p, vec3 d, float ndl)\n{\n\tfloat t = .15;\n\tfloat k = 32.;\n\tfloat s = .5+ndl;\n    for( int i=0; i < siter; i++ )\n    {\n    \tfloat u = map(p + d * t);\n    \ts = smoothmin(s, k * u / t, sblend);\n        k -= .5;\n        t += max(0.1, sproj);\n    }\n\treturn clamp(s,smin,1.0);\n}\n\t\n","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"Xd2GDy","date":"1393011148","viewed":1201,"name":"Tree in Grass","username":"alleycatsphinx","description":"It's a tree! This is ancient =)","likes":35,"published":1,"flags":0,"usePreview":0,"tags":["grass","tree","physicallybasedshading"],"hasliked":0,"parentid":"","parentname":""}}