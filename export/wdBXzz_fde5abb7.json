{"ver":"0.1","info":{"id":"wdBXzz","date":"1552676618","viewed":69,"name":"Kurakin_Mashgraph_312","username":"sheogarat1488","description":"t-1000","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define max_steps 100\n#define max_dist 100.\n#define surface_dist .01\n//все фигуры взяты с distfunctions.htm\n//5 различных типа примитвов - тор, капсула, сфера, гексагональная призма и коробка\n//5 объектов - один анимирован\n//2 источника света\n\nfloat sdBox(vec3 p, vec3 b)//первый аргумент сдвиг, остальные размеры\n{\n  return length(max(abs(p) - b, 0.));\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    return max(q.z - h.y, max((q.x*0.866025 + q.y*0.5), q.y) - h.x);\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r)\n{\n    vec3 pa = p - a;\n    vec3 ba = b - a;\n    float t = clamp(dot(pa,ba) / dot(ba,ba), 0., 1.); //нормализация путем / потом сужение t \n    return length(pa - ba*t) - r; //t - суть шаги\n}\n\nfloat sdTorus(vec3 p, vec2 t)\n{\n  vec2 q = vec2(length(p.xz) - t.x, p.y);\n  return length(q) - t.y;\n}\n\nfloat opS(float d1, float d2)//вычитание фигур\n{\n    return max(-d1, d2);\n}\n\n\n\n\nfloat GetDist (vec3 p) \n{\n    float dP = p.y; //planedistance - пока плоская поверхность\n    float hd = sdHexPrism(p - vec3(2, 1.5, 6), vec2 (0.3, 0.2));\n    float cd = sdCapsule(p, vec3(0, 1, 6), vec3 (1, 2, 6), .2);\n    float bd = sdBox(p - vec3(-3, .75, 6), vec3(.75));\n    float sd = sdSphere(p - vec3(-3, .75, 6), 1.); \n    float td = sdTorus(p - vec3(0, 0.5,6), vec2(1.5, .2)); //когда вычитаем - передвигаем тор\n  \t\n    float bd1 = sdBox(p - vec3(4, .75, 6), vec3(.75));\n    float sd1 = sdSphere(p - vec3(4, .75, 6), 1.); \n    float e = mix(sd1, bd1, sin(iTime) * .9); //анимированный объект\n    \n    float c = opS(sd, bd);//использование конструктивной сплошной геометрии\n    float d = min(cd, dP);\n    d = min(d, td);\n    d = min(d, hd);\n    d = min(d, c);\n    d = min(d, e);\n    return d;\n}\n\nfloat RayMarch (vec3 ro, vec3 rd) \n{\n\tfloat dO = 0.; //dO - расстояние от глаза\n\tfor (int i = 0; i < max_steps; i++) //не хотим слишком близко приближаться\n    {\n        vec3 p = ro + dO * rd; //p - текущее положение марша\n        float dS = GetDist(p);\n        dO = dO + dS;\n        if (dS < surface_dist || dO > max_dist) //на случай если мы вообще не видим объект или достигли желаемой точности\n        \tbreak;\n    }\n    return dO;\n}\n\nvec3 GetNormal (vec3 p)\n{\n    float d = GetDist(p);\n    vec2 e = vec2(.01, .0);\n    vec3 n = vec3(\n        d - GetDist(p - e.xyy),\n        d - GetDist(p - e.yxy),\n        d - GetDist(p - e.yyx)); //e.xyy =def= vec3(.01, 0, 0)\n    return normalize(n);\n}\n\nfloat GetLight (vec3 p) //на вход точка, ля которой хотим найти тень\n{\n    vec3 lightPos = vec3(0, 5, 6); //позиция первого источника\n    lightPos.xz = lightPos.xz + vec2(sin(iTime), cos(iTime)) * 6.;//движение лампочки \n    vec3 l = normalize(lightPos - p); //вектор света\n    vec3 n = GetNormal(p);\n    float dif = clamp(dot(n, l), 0., 1.); //clamp сжимает первое между 2 и 3 параметрами\n    float d = RayMarch(p + n * surface_dist * 2., l); //чуть отодвигаем от поверхности - иначе нууу все темное\n    if (d < length(lightPos - p)) //проверяем в тени ли мы\n    \tdif = dif * .1;\n    return dif;\n}\n\nfloat GetLight1 (vec3 p) \n{\n    vec3 lightPos = vec3(3, 5, -6); \n    vec3 l = normalize(lightPos - p); //вектор света\n    vec3 n = GetNormal(p);\n    float dif = clamp(dot(n, l), 0., 1.);  \n    float d = RayMarch(p + n * surface_dist * 2., l); \n    if (d < length(lightPos - p)) \n    \tdif = dif * .1;\n    return dif;\n}\n\nvec3 R(vec2 uv, vec3 p, vec3 l, float z) //взято из ролика на ютубе, я сделал только поворот\n{\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = p+f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i-p);\n    return d;\n}\n\nmat2 Rot(float a) \n{\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\tvec2 m = iMouse.xy/iResolution.xy; //даем возможность управления мышкой\n\n    vec3 col = vec3(0);\n    \n    vec3 ro = vec3(5, 4, 3); //Задаем камеру, это координаты глаза\n    ro.yz *= Rot(-m.y);\n    ro.xz *= Rot(-m.x * 5.); //ускоряем потому что камера збрасывается\n\tvec3 rd = R(uv, ro, vec3(0,0,0), .7); //это ray direction = куда мы смотрим, вектор нормализован в функции R\n    \n  \n    float d = RayMarch(ro, rd); //from ray origin to ray dir\n    vec3 p = ro + rd * d;\n    \n    float dif = GetLight(p) + GetLight1(p);//diffused lightning\n    col = vec3(dif);\n\n    fragColor = vec4(col,1.0);     \n}","name":"Image","description":"","type":"image"}]}