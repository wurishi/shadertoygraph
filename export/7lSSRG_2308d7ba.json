{"ver":"0.1","info":{"id":"7lSSRG","date":"1627909888","viewed":91,"name":"Plane (Max Norm Distance)","username":"TheTurk","description":"Maximum norm distance function for a plane.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["distancefield","sdf","distance","plane","linfinity","maximumnorm"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/* \nTo compute the maximum norm distance between a point p and a \nprimitive we need to find the size of the smallest \naxis-aligned cube (compared to the size of the smallest \nsphere under Euclidian norm) centered at p that touches the \nsurface of the primitive. There are usually three cases that \nneed to be handled depending on whether the point that \ntouches the surface of the primitive lies on a corner, edge \nor face of the cube. In the case of a plane the point \nclosest to the primitive always lies on a corner of the \ncube. \n*/\n\nfloat plane(vec3 position, vec3 planeNormal, float planeDistance) {\n    float d = dot(position, planeNormal) + planeDistance;\n    return d / dot(planeNormal, sign(planeNormal));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 position = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n    \n    vec3 planeNormal = vec3(cos(iTime), sin(iTime), 0.0);\n    float planeDistance = 0.0; // distance from plane to origin\n    float d = plane(vec3(position, 0.0), planeNormal, planeDistance);\n    \n    // same colorization that Inigo Quilez uses in his shaders\n    vec3 color = vec3(1.0, 0.9, 1.0) + sign(d) * vec3(-0.3, 0.4, 0.3); // base color\n    color *= 1.0 - exp(-4.0 * abs(d)); // gradient\n\tcolor *= 0.8 + 0.2 * cos(140.0 * d); // ripples\n    color = mix(color, vec3(1.0), 1.0 - smoothstep(0.0, 3.0, (abs(d) - 0.001) * iResolution.y)); // outline\n\tfragColor = vec4(color,1.0);\n} ","name":"Image","description":"","type":"image"}]}