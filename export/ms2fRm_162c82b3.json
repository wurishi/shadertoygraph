{"ver":"0.1","info":{"id":"ms2fRm","date":"1689576087","viewed":179,"name":"Ever rising/lowering tone","username":"ersh","description":"To the infinity...\n\nThis shader demonstrated the generation of infinitely rising and/or lowering tone.\nFeel free to play with parameters in the \"Common\" tab.","likes":3,"published":3,"flags":8,"usePreview":0,"tags":["sound"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//////////////////////////////////////////////////\n// Go and play with parameters in the COMMON tab.\n//////////////////////////////////////////////////\n\n#define TONEWIDTH (1./400.)\n\nvec3 hsv2rgb(vec3 c) {\n  c = vec3(c.x, clamp(c.yz, 0.0, 1.0));\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // The main purpose of this thing is to always keep time\n    // within a sensible range for sin()\n    float time = timesawtooth(iTime, TIMEPERIOD, TIMETRANS);\n\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 col = 0.5 + 0.5*cos(time+uv.xyx+vec3(0,2,4));\n    fragColor = vec4(col, 1.0);\n    if (fragCoord.x > 5. && fragCoord.y > 5. && fragCoord.x < iResolution.x-5. && fragCoord.y < iResolution.y-5.) {\n        fragColor.rgb *= envMid(uv.x, uv.y);\n    }\n\n    float t = mod(time, RANGE);                        // time = [0 .. RANGE]\n    float tf = t / RANGE;                              // time = [0 .. 1]\n    float tfe = (exp2(tf) - 1.) / (exp2(RANGE) - 1.);  // exp time = [0..1]\n    float tfe1 = tfe + 1.;                             // exp time = [1..2]\n\n    fragColor.rgb *= smoothstep(0.3, 0., 0.5-abs(fract(uv.x - tf)-0.5));\n\n    if (abs(octf(PEAKOCTAVE) - uv.y) <= 1./iResolution.y || abs(octf(PEAKOCTAVE) - uv.x) <= 1./iResolution.x) fragColor += vec4(0.3);\n\n    for (float i = floor(OCTAVEMIN); i < ceil(OCTAVEMAX); i++) {\n        if (abs(octf(i) - uv.x) <= 1./iResolution.x) fragColor.g += 0.4;\n    }\n    for (float i = floor(OCTAVEMIN); i < ceil(OCTAVEMAX); i+=STEP) {\n        vec2 d = vec2(abs(octf(tf+i) - uv.x), envMid(uv.x, octf(PEAKOCTAVE)));\n        if (uv.y <= d.y) fragColor.rg += vec2(d.y*0.4  *  smoothstep(3./iResolution.x, 0., d.x - TONEWIDTH));\n    }\n\n    //if (abs(octf(tf) - uv.x) <= 1./iResolution.x) fragColor.rgb += vec3(0.4);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// Speed, octaves per sec\n#define SPD           0.06\n\n// Peak volume at this octave (-3 ... 5)\n#define PEAKOCTAVE    0.8\n\n// Number of tones per octave (1 .. 10)\n#define TONES_PER_OCTAVE  1.\n\n// Dynamic range, dB\n#define DYNRANGE_DB   40.\n\n// Ramp-up / ramp down oscillation period, seconds\n#define TIMEPERIOD    150.\n\n// Transition time between up/down / startup time, seconds\n#define TIMETRANS     1.5\n\n// Min hearable frequency, HZ - should be slightly above the hearable\n#define FREQMIN       50.\n\n// Max hearable frequency, HZ - should be slightly below the hearable\n#define FREQMAX       12000.\n\n// Rumbling effect by modulation with this freq, HZ (can comment out)\n#define MODULATE_BY   65.\n\n// Tone goes first up, then down  (comment out for down-up)\n#define UPDOWN\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfloat note2freq(float note) { return 440. * exp2((-10.)/12.) * exp2(note/12.); }\nfloat octave2freq(float note) { return 440. * exp2((-10.)/12.) * exp2(note); }\n#define OCTAVEMIN   log2(FREQMIN / 440. / exp2((-10.)/12.))\n#define OCTAVEMAX   log2(FREQMAX / 440. / exp2((-10.)/12.))\n//float sinhz(float x) { return sin(6.28318530718 * x); }                         // sin\nfloat sinhz(float x) { return abs(fract(x-0.25)-0.5)*4.-1.; }                   // triangle\n//float sinhz(float x) { return fract(x)*2.-1.; }                                 // saw\n//float sinhz(float x) { return sign(fract(x)-0.5); }                             // square\n//float sinhz(float x) { return smoothstep(-1.,1.,sin(x*6.28318530718))*2.-1.; }  // smoothsquare 1\n//float sinhz(float x) { return smoothstep(0.+0.15,0.5-0.15,abs(fract(x)-0.5))*2.-1.; }  // smoothsquare 2\n\n// Sine for modulation\nfloat sinhz_mod(float x) { return sin(6.28318530718 * x); }\n\n// Envelope:\n//   https://graphtoy.com/?f1(x,t)=sin(3.14159265359%20*%20x)&v1=true&f2(x,t)=smoothstep(0,1,x)&v2=true&f3(x,t)=sin(3.14159265359%20*%20smoothstep(0,1,x))&v3=true&f4(x,t)=smoothstep(0,1,smoothstep(0,1,x))&v4=true&f5(x,t)=sin(3.14159265359%20*%20smoothstep(0,1,smoothstep(0,1,x)))&v5=true&f6(x,t)=pow(sin(3.14159265359%20*%20x),%204)&v6=true&grid=1&coords=0.5,0.5,0.6666666666666666\n// * https://graphtoy.com/?f1(x,t)=sin(3.14159265359*x)&v1=true&f2(x,t)=&v2=false&f3(x,t)=&v3=false&f4(x,t)=4*(x-x*x)&v4=true&f5(x,t)=&v5=false&f6(x,t)=&v6=false&grid=2&coords=0.5,0.5,0.6666666666666666\n//float envelope(float x) { return sin(3.14159265359 * x); }\n//float envelope(float x) { return sin(3.14159265359 * smoothstep(0., 1., x)); }\n//float envelope(float x) { return sin(3.14159265359 * x); }\n//float envelope(float x) { return pow(4. * (x - x*x), 0.7); }\nfloat _envelope(float x) { return 4. * (x - x*x); }\nfloat envelope(float x) { return 1. - pow(1. - _envelope(x), 1.5); }\n\n// Skew:\n//   https://graphtoy.com/?f1(x,t)=sin(3.14159265359%20*%20x)&v1=true&f2(x,t)=pow(x,%202)&v2=false&f3(x,t)=pow(x,%200.4)&v3=true&f4(x,t)=sin(3.14159265359%20*%20pow(x,%202))&v4=false&f5(x,t)=sin(3.14159265359%20*%20pow(x,%200.4))&v5=true&f6(x,t)=sin(3.14159265359%20*%20(1-pow(1-x,%200.4)))&v6=true&grid=1&coords=0.5,0.5,0.6666666666666666\n//   https://graphtoy.com/?f1(x,t)=sin(3.14159265359*x)&v1=true&f2(x,t)=4*(x-x*x)&v2=true&f3(x,t)=pow(x,0.4)&v3=true&f4(x,t)=f2(pow(x,2))&v4=false&f5(x,t)=f2(pow(x,0.4))&v5=true&f6(x,t)=f2(1-pow(1-x,0.4))&v6=true&grid=2&coords=0.5,0.5,0.6666666666666666\n//   https://graphtoy.com/?f1(x,t)=pow(pow(x*2-1,2)-1,2)&v1=true&f2(x,t)=pow(x,1/0.4)&v2=false&f3(x,t)=pow(pow(pow(x,1/0.4)*2-1,2)-1,2)&v3=true&f4(x,t)=pow(pow((1-pow(1-x,1/0.4))*2-1,2)-1,2)&v4=true&f5(x,t)=&v5=false&f6(x,t)=&v6=false&grid=1&coords=0.5,0.5,0.6666666666666666\n// * https://graphtoy.com/?f1(x,t)=4*(x-x*x)&v1=true&f2(x,t)=pow(x,0.5)&v2=false&f3(x,t)=pow(1-x,0.5)&v3=false&f4(x,t)=&v4=false&f5(x,t)=f1(f2(x))&v5=true&f6(x,t)=f1(f3(x))&v6=true&grid=2&coords=0.5,0.5,0.6666666666666666\nfloat _skewf(float x, float n) { return pow(clamp(x, 0., 1.), n); }\nfloat _skew1(float x, float mid) { return _skewf(x, log(0.5)/log(mid)); }\nfloat skew(float x, float mid) { return mid <= 0.5 ? _skew1(x, mid) : _skew1(1. - x, 1. - mid); }\n//float skew(float x, float mid) { return _skew1(x, 0.5-abs(fract(mid)-0.5)); }\n\nfloat envMid(float x, float mid) { return envelope(skew(x, mid)); }\n\nfloat db2amp(float x) { return pow(10., (x-1.)*DYNRANGE_DB/20.); }\n\nfloat octf(float n) { return clamp((n - OCTAVEMIN)/(OCTAVEMAX - OCTAVEMIN), 0., 1.); }\n\n// Skew:\n//   https://graphtoy.com/?f1(x,t)=pow(x,%200.25)&v1=true&f2(x,t)=0.5&v2=true&f3(x,t)=log(0.5)/log(x)&v3=true&f4(x,t)=&v4=false&f5(x,t)=&v5=false&f6(x,t)=&v6=false&grid=2&coords=0.5,0.5,0.6666666666666666\n\n// https://www.shadertoy.com/view/tlcfRn\nfloat sabs(float x, float k) { return sqrt(x * x + k * k); }\n// Better smooth abs functions with smooth 1st derivative and converging to linear: https://graphtoy.com/?f1(x,t)=mix(x,3,clamp(-x+3,0,3)/3/2)&v1=false&f2(x,t)=f1(abs(x))&v2=true&f3(x,t)=sqrt(x*x%20+%203*3)&v3=true&f4(x,t)=log(exp(x)+exp(3))%20+%20log(exp(-x)+exp(3))%20-%203&v4=true&f5(x,t)=&v5=false&f6(x,t)=&v6=false&grid=1&coords=2.2601521561494273,5.57995368872829,23.26586969184914\n//float ssabs(float x, float k) { return mix(x, k, clamp(-x + k, 0. , k)/k/2.); }\n//float ssabs(float x, float k) { return x >= k? x : -sqrt(k*k/(0.7071067812*0.7071067812)-x*x)+k*2.; }\n//float ssabs(float x, float k) { return log(exp(x)+exp(k))+log(exp(-x)+exp(k))-k; }\nfloat ssabs(float x, float k) { return x > k*10. ? x : log(exp(x)+exp(k))+log(exp(-x)+exp(k))-k; }\n\nfloat sawtooth(float x, float len) { return abs(mod(x, len*2.) - len); }\n//float ssawtooth(float x, float len) { return sinhz(x/len)/2. + 0.5; }\nfloat ssawtooth(float x, float len, float trans) {\n    // https://graphtoy.com/?f1(x,t)=sqrt(x%20*%20x%20+%20.1%20*%20.1)&v1=true&f2(x,t)=mod(x,%2010)-5&v2=false&f3(x,t)=f1(f2(x))&v3=false&f4(x,t)=5-f3(x+5)&v4=false&f5(x,t)=0.5%20-%20cos(x*6.28318530718/10)/2&v5=false&f6(x,t)=mix(f4(x),%20f3(x),%20f5(x))&v6=true&grid=1&coords=1.5548003398470707,2.9056924384027223,9.91735537190086\n    float len2 = len/2.;\n    x += len2;\n    float ssaw_bot = sabs(mod(x, len) - len2, trans);\n    float ssaw_top = len2 - sabs(mod(x + len2, len) - len2, trans);\n    float mixk = 0.5 - cos(x*6.28318530718/len)/2.;\n    return mix(ssaw_top, ssaw_bot, mixk);\n}\n\nfloat timesawtooth(float x, float len, float trans) {\n    // https://graphtoy.com/?f1(x,t)=sqrt(x*x+.3*.3)&v1=false&f2(x,t)=exp(1/(5-x)/5)+4&v2=false&f3(x,t)=clamp(mod(x,5)-(5-0.3),%200,%201)&v3=false&f4(x,t)=&v4=false&f5(x,t)=mix(f1(x),%20f2(x),%20f3(x))&v5=false&f6(x,t)=f5(abs(mod(x+5,10)-5))&v6=true&grid=1&coords=2.314344811316915,2.631207494963487,14.446274591184533\n    float len2 = len/2.;\n#ifndef UPDOWN\n    x += len2;\n#endif\n    x = abs(mod(x + len2, len) - len2);\n    float smoothlow = ssabs(x, trans); // sabs(x, trans);\n    float xtrans = x - len2 + trans;\n    if (xtrans <= 0.) return smoothlow;\n    float mixk = clamp(xtrans, 0., trans) / trans;\n    // https://graphtoy.com/?f1(x,t)=tan(tan(x/3%20*%20atan(atan(100./3))))*3%20+%205%20-%203&v1=true&f2(x,t)=f1(3)&v2=true&f3(x,t)=&v3=false&f4(x,t)=&v4=false&f5(x,t)=&v5=false&f6(x,t)=&v6=false&grid=1&coords=-1.1158959084603164,1.2951708211315938,8.154545393121996\n    float peak = tan(tan(xtrans/trans * atan(atan(10.))))*trans + len2 - trans;\n    return mix(smoothlow, peak, mixk);\n}\n\n#define RANGE   (1./SPD)\n#define STEP    (1./TONES_PER_OCTAVE)\n","name":"Common","description":"","type":"common"},{"inputs":[],"outputs":[],"code":"vec2 mainSound( int samp, float time )\n{\n    time = timesawtooth(time, TIMEPERIOD, TIMETRANS);\n\n    float t = mod(time, RANGE);                        // time = [0 .. RANGE]\n    float tf = t / RANGE;                              // time = [0 .. 1]\n    // https://graphtoy.com/?f1(x,t)=&v1=false&f2(x,t)=exp(x*log(2))&v2=true&f3(x,t)=pow(2,%20x*log(2))&v3=true&f4(x,t)=(exp(x*log(2))-1)%20/%203&v4=true&f5(x,t)=((exp(x*log(2))-1)%20/%203)%20+%201&v5=true&f6(x,t)=&v6=false&grid=1&coords=0.7276582190451031,1.6451697223764041,3.8041556081466807\n    float tfe = (exp2(tf) - 1.) / (exp2(RANGE) - 1.);  // exp time = [0..1]\n    float tfe1 = tfe + 1.;                             // exp time = [1..2]\n\n    float v = 0.;\n\n    float iter = floor(time / RANGE);\n    for (float i = floor(OCTAVEMIN); i < ceil(OCTAVEMAX); i+=STEP) {\n        float f = octave2freq(tf+i);\n        if (f < FREQMIN || f > FREQMAX) continue;\n        v += sinhz(f*(t + i*RANGE)) * db2amp(envMid(octf(tf+i), octf(PEAKOCTAVE)));\n    }\n\n#ifdef MODULATE_BY\n    v *= abs(sinhz_mod(MODULATE_BY / 2. * time));\n#endif\n\n    return vec2(v/(OCTAVEMAX - OCTAVEMIN)*STEP);\n}\n\n","name":"Sound","description":"","type":"sound"}]}