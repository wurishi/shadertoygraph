{"ver":"0.1","info":{"id":"lsVSRh","date":"1464083737","viewed":908,"name":"Cognac bottle","username":"TambakoJaguar","description":"I just wanted to create a Cognac bottle with contents. Sadly, I had to remove stuff like the glass so that it won't crash in Chrome :(\nFeel free to reactive them on lines 10 to 26. You can use the mouse to rotate around the scene.","likes":21,"published":1,"flags":0,"usePreview":1,"tags":["reflection","mouse","refraction","glass","liquid","stone","bottle","plate","cognac"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3Rr","filepath":"/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","previewfilepath":"/media/ap/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n\"Cognac bottle\" by Emmanuel Keller aka Tambako - May 2016\nLicense Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\nContact: tamby@tambako.ch\n*/\n\n#define pi 3.14159265359\n\n// Switches, you can play with them!\n//#define bumped_glass\n#define show_label\n//#define bottle_ticks\n//#define bottle_inset\n\n#define specular\n#define reflections\n//#define ambocc\n#define show_table\n// Please comment the next line if you still need to drive today\n#define show_cognac\n#define show_neck\n//#define show_plug\n//#define show_glass\n#define show_plate\n//#define antialias\n//#define dev_mode\n#define soft_min_max\n\nstruct Lamp\n{\n  \tvec3 position;\n  \tvec3 color;\n  \tfloat intensity;\n  \tfloat attenuation;\n};\n    \nstruct TransMat\n{\n    vec3 col_vol;\n    vec3 col_dif;\n    vec3 col_fil;\n    vec3 col_dev;\n    float specint;\n    float specshin;\n};\n\nstruct RenderData\n{\n  \tvec3 col;\n  \tvec3 pos;\n  \tvec3 norm;\n  \tint objnr;\n};\n   \n// Every object of the scene has its ID\n#define SKY_OBJ        0\n#define TABLE_OBJ      1\n#define BOTTLE_OBJ     2\n#define GLASS_OBJ      3\n#define COGNAC_OBJ     4\n#define PLATE_OBJ      5\n#define LABEL_OBJ      6\n#define NECK_OBJ       7\n#define PLUG_OBJ       8\n\nLamp lamps[2];\n\n// Campera options\nvec3 campos = vec3(0., -0.4, 10.);\nvec3 camtarget = vec3(0., 0.3, 0.);\nvec3 camdir = vec3(0., 0., 0.);\n#ifdef dev_mode\nfloat fov = 7.;\n#else\nfloat fov = 4.;\n//float fov = 15.;\n#endif\nfloat angle = 0.;\nfloat angle2 = 0.;\n\nconst vec3 glassPos = vec3(-1.8, 0.53, -0.55);\nconst vec3 plugPos = vec3(0.02, -1.655, 0.03);\n\n// Ambient light\nconst vec3 ambientColor = vec3(0.3);\nconst float ambientint = 0.06;\n\n// Color options\nconst vec3 plateColor = vec3(0.55);\n\n// Shading options\nconst float specint_table = 0.22;\nconst float specshin_table  = 15.;\nconst float specint_plate = 0.25;\nconst float specshin_plate = 7.;\nconst float specint_label = 0.22;\nconst float specshin_label  = 15.;\nconst float aoint = 0.5;\n\n// Tracing options\nconst float normdelta = 0.001;\nconst float maxdist = 40.;\n#ifdef show_glass\nconst int nbref = 9;\n#else\nconst int nbref = 5;\n#endif\nconst float glass_ior = 1.47;\nconst float cognac_ior = 1.3;\nconst float plateRf = 0.78;\n\n// Other perameters\nconst float bumpfactor = 0.45;\nconst float stoneSize = 0.5;\nconst float plateSize = 1.45;\nconst float plateThickness = 0.03;\n\n// Antialias. Change from 1 to 2 or more AT YOUR OWN RISK! It may CRASH your browser while compiling!\nconst float aawidth = 0.8;\nconst int aasamples = 2;\n\nfloat aaindex = 0.;\nbool traceGlass = true;\n\nTransMat glassMat;\nTransMat cognacMat;\nTransMat plugMat;\n\nvoid init()\n{\n    lamps[0] = Lamp(vec3(-5., 3., -5.), vec3(1., 1., 1.), 1.8, 0.01);\n    lamps[1] = Lamp(vec3(1.5, 4., 2.), vec3(1., 1., 1.), 1.3, 0.01);\n    \n    glassMat = TransMat(vec3(0.95, 0.98, 0.96),\n                        vec3(0.01, 0.02, 0.025),\n                        vec3(1., 1., 1.),\n                        vec3(0.3, 0.5, 0.9),\n                        0.4,\n                        45.);\n    cognacMat = TransMat(vec3(0.98, 0.94, 0.75),\n                         vec3(0.05, 0.02, 0.01),\n                         vec3(1., 1., 1.),\n                         vec3(0.85, 0.55, 0.3),\n                         0.4,\n                         45.);\n    plugMat = TransMat(vec3(0.94, 0.91, 0.92),\n                       vec3(0.10, 0.09, 0.08),\n                       vec3(1., 1., 1.),\n                       vec3(0.1, 0.9, 0.3),\n                       0.4,\n                       45.);\n}\n\n#ifdef soft_min_max\nfloat SoftMaximum(float x, float y, float fact)\n{\n    x*= fact;\n    y*= fact;\n    \n\tfloat maximum = max(x, y);\n\tfloat minimum = min(x, y);\n\treturn (maximum + log(1.0 + exp(minimum - maximum)))/fact;\n}\n\n// From https://iquilezles.org/articles/smin\nfloat smin( float a, float b, float k )\n{\n    float res = exp( -k*a ) + exp( -k*b );\n    return -log( res )/k;\n}\n#else\n// From https://www.shadertoy.com/view/4s3XD2\nfloat smin (float a, float b, float r)\n{\n  r*=0.0005;\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b, a, h) - r * h * (1. - h);\n}\n\nfloat SoftMaximum (float a, float b, float r)\n{\n  return - smin (- a, - b, r);\n}\n#endif\n\n// Union operation from iq\nvec2 opU(vec2 d1, vec2 d2)\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nvec2 rotateVec(vec2 vect, float angle)\n{\n    vec2 rv;\n    rv.x = vect.x*cos(angle) - vect.y*sin(angle);\n    rv.y = vect.x*sin(angle) + vect.y*cos(angle);\n    return rv;\n}\n\nvec3 rotateVec2(vec3 posr)\n{\n    posr = vec3(posr.x, posr.y*cos(angle2) + posr.z*sin(angle2), posr.y*sin(angle2) - posr.z*cos(angle2));\n    posr = vec3(posr.x*cos(angle) + posr.z*sin(angle), posr.y, posr.x*sin(angle) - posr.z*cos(angle)); \n    \n    return posr;\n}\n\n// 1D hash function\nfloat hash(float n)\n{\n    return fract(sin(n)*753.5453123);\n}\n\n// 3D hash function\nvec3 hash3( vec3 n ){\n\treturn fract(vec3(sin(n.x)*3538.5453, sin(n.y)*2753.8256, sin(n.z)*5296.3728));\n}\n\n// From https://www.shadertoy.com/view/4sfGzS\nfloat noise(vec3 x)\n{\n    //x.x = mod(x.x, 0.4);\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    float n = p.x + p.y*157.0 + 113.0*p.z;\n    return mix(mix(mix(hash(n+  0.0), hash(n+  1.0),f.x),\n                   mix(hash(n+157.0), hash(n+158.0),f.x),f.y),\n               mix(mix(hash(n+113.0), hash(n+114.0),f.x),\n                   mix(hash(n+270.0), hash(n+271.0),f.x),f.y),f.z);\n}\n\nconst mat3 m = mat3( 0.00,  0.80,  0.60,\n                    -0.80,  0.36, -0.48,\n                    -0.60, -0.48,  0.64 );\n\n// From https://www.shadertoy.com/view/Xds3zN\nfloat sdCylinder(vec3 p, vec2 h)\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\nfloat sdCone( in vec3 p, in vec3 c )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    float d1 = -q.y-c.z;\n    float d2 = max( dot(q,c.xy), q.y);\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n}\n\nfloat getBottleBump(vec3 pos)\n{\n\treturn 0.035*noise(normalize(pos)*1.8)*smoothstep(-0.5, 0.1, pos.y)*smoothstep(0.3, 0.7, length(pos.xz));   \n}\nfloat map_bottle_int(vec3 pos)\n{\n    const float th = 0.045;\n\n    #ifdef bumped_glass\n    pos+= getBottleBump(pos);\n    #endif\n    \n    vec3 pos2 = pos;\n    float p = 1. - 4.8*pow(smoothstep(0.47, 1.74, pos.y), 1.3);\n    pos2.xz/=(1. + 0.16*pos.y*p);\n    vec3 pos3 = pos;\n    pos3.y-= 0.74;\n    pos3.y*= 1.65;\n    vec3 pos4 = pos;\n    pos4.y-= 2.1;\n    pos4.xz*=(1. + 0.3*pos4.y);\n    vec3 pos6 = pos;\n    pos6.y+= 1.64;\n    pos6.y*= 0.38;\n    vec3 pos8 = pos.zxy + vec3(1.15, 0, -0.7);\n\n    pos-= vec3(0., th, 0.);\n    \n    float df = sdCylinder(pos2, vec2(0.83 - th, 1.35));\n    df = smin(sdCylinder(pos4, vec2(0.2 - th*0.75, 0.93)), df, 5.);\n    df = SoftMaximum(df, -pos.y - 0.55 + th, 20.);\n    df = SoftMaximum(df, -length(pos6) + 0.56 + th*0.9 - 0.5*pos.y*pos.y*pos.y, 60.);\n    #ifdef bottle_inset\n    df = SoftMaximum(df, -sdCylinder(pos8, vec2(0.76, 1.)), 8.);\n    #endif\n    \n    return df; \n}\n\nfloat map_bottle_ext(vec3 pos)\n{\n    #ifdef bumped_glass\n    pos+= getBottleBump(pos);\n    #endif\n    \n    vec3 pos2 = pos;\n    float p = 1. - 4.4*pow(smoothstep(0.5, 1.75, pos.y), 1.3);\n    pos2.xz/=(1. + 0.16*pos.y*p);\n    vec3 pos3 = pos;\n    pos3.y-= 0.73;\n    pos3.y*= 1.6;\n    vec3 pos4 = pos;\n    pos4.y-= 2.1;\n    pos4.xz*=(1. + 0.3*pos4.y);\n    vec3 pos5 = pos;\n    pos5.y-= 2.82;\n    vec3 pos6 = pos;\n    pos6.y+= 1.55;\n    pos6.y*= 0.39;\n    vec3 pos7 = pos;\n    pos7+= vec3(0., -1., -0.8);\n    pos7.yz = rotateVec(pos7.yz, -pi*0.3);\n    vec3 pos8 = pos.zxy + vec3(1.15, 0, -0.7);\n    \n    float df = sdCylinder(pos2, vec2(0.83, 1.35));\n    df = smin(sdCylinder(pos4, vec2(0.2, 0.93)), df, 5.);\n    df = smin(sdCylinder(pos5, vec2(0.2, 0.088)), df, 27.);\n    df = SoftMaximum(df, -pos.y - 0.57, 10.);\n    df = SoftMaximum(df, -length(pos6) + 0.55 - 0.5*pos.y*pos.y*pos.y, 18.);\n    #ifdef bottle_inset\n    df = SoftMaximum(df, -sdCylinder(pos8, vec2(0.72, 1.)), 8.);\n    #endif\n    \n    #ifdef show_label \n    df = smin(df, sdCylinder(pos7, vec2(0.18, 0.02)), 35.);\n    df = SoftMaximum(df, -sdCylinder(pos7 + vec3(0., -0.025, 0.), vec2(0.15, 0.03)), 80.);\n    #endif\n    \n    #ifdef bottle_ticks\n    float a = atan(pos.x, pos.z);\n    float l = length(pos.xz);\n    float d = 1.1*smoothstep(0.53, 0.6, l)*smoothstep(0.67, 0.61, l);\n    df-= 0.01*d*smoothstep(1. - d, 1., sin(85.*a))*(pos.y>0.?0.:1.);\n    #endif\n    \n    return df; \n}\n\nfloat map_bottle(vec3 pos)\n{\n    if (!traceGlass)\n        return 10.;\n    pos = rotateVec2(pos);\n    pos+= vec3(0.02, 0.56, 0.03);\n    pos*= 1.25;\n    \n    float intb = map_bottle_int(pos);\n    float extb = map_bottle_ext(pos);\n    float df = max(extb, -intb);\n    df = SoftMaximum(df, pos.y - 2.98, 120.);\n\n    #ifdef dev_mode\n    df = max(df, -pos.x);\n    #endif\n    \n    return df;\n}\n\nfloat map_glass_int(vec3 pos)\n{\n    float s1 = length(pos*vec3(1., 0.95, 1.) + vec3(0., -0.1, 0.)) - 0.3;\n    s1 = mix(s1, length(pos.xz) - 0.34 + pos.y*0.3, smoothstep(-0.15, 0.28, pos.y));\n    float dt = 0.004 * smoothstep(0.368, 0.38, pos.y);\n    float s2 = s1 + 0.005 + dt + 0.05*smoothstep(-0.02, -0.33, pos.y);\n    \n    return s2;\n}\n\nfloat getGlassBump(vec3 pos)\n{\n\treturn 0.007*noise(normalize(pos)*2.1)*smoothstep(0.1, 0.2, length(pos));   \n}\nfloat map_glass(vec3 pos)\n{\n    #ifdef show_glass\n    pos = rotateVec2(pos);\n    pos+= glassPos;\n\n    #ifdef bumped_glass\n    pos+= getGlassBump(pos);\n    #endif\n    \n    #ifdef show_plate\n    pos.y-= -0.153 + plateThickness*2.;\n    #endif\n    \n    pos*= 0.88;\n    \n    vec3 pos2 = pos + vec3(0., 0.37, 0.);\n    vec3 pos3 = pos + vec3(0., 0.388, 0.);\n    vec3 pos4 = pos + vec3(0., 0.73, 0.);\n    vec3 pos5 = pos + vec3(0., 0.34, 0.);\n    \n    float s1 = length(pos*vec3(1., 0.95, 1.) + vec3(0., -0.1, 0.)) - 0.3;\n    s1 = mix(s1, length(pos.xz) - 0.34 + pos.y*0.3, smoothstep(-0.15, 0.28, pos.y));\n    float dt = 0.004 * smoothstep(0.368, 0.38, pos.y);\n    s1-= dt;\n    float s2 = map_glass_int(pos);\n    \n    float df = max(s1, -s2);\n    df = SoftMaximum(df, pos.y - 0.39, 80.);\n    \n    float gsd = 0.04*(0.45 + 6.*pos.y*pos.y);\n    df = smin(df, sdCylinder(pos2, vec2(gsd, 0.14)), 27.);\n    float gfd = 0.19 - clamp(4.*pos2.y, -0.1, 0.5);\n    df = smin(df, sdCylinder(pos3, vec2(gfd, 0.07)), 15.);\n    df = SoftMaximum(df, -pos2.y - 0.15, 9.);\n    df = smin(df, sdCylinder(pos5, vec2(0.07, 0.01)), 70.);\n    df = SoftMaximum(df, -length(pos4) + 0.33, 28.);  \n    \n    #ifdef dev_mode\n    df = max(df, pos.z);\n    #endif \n    \n    return df;\n    #else\n    return 10.;\n    #endif\n}\n\nvec3 label_pos(vec3 pos)\n{\n    pos+= vec3(0.03, -0.235, -0.632);\n    pos.yz = rotateVec(pos.yz, -pi*0.3);\n    return pos;\n}\n\nfloat map_label(vec3 pos)\n{\n    #ifdef show_label\n    pos = rotateVec2(pos);\n    pos = label_pos(pos);\n\n    float df = sdCylinder(pos, vec2(0.11, 0.0028));\n    \n    #ifdef dev_mode\n    df = max(df, -pos.x);\n    #endif\n    \n    return df;\n    #else\n    return 10.;\n    #endif\n}\n\nfloat map_neck(vec3 pos)\n{\n    #ifdef show_neck\n    pos = rotateVec2(pos);\n \n    pos+= vec3(0.018, -1.36, 0.03);\n    vec3 pos5 = pos;\n    pos5.y-= 0.335;\n    pos.xz*=(1. + 0.35*pos.y);\n    \n    float c1 = sdCylinder(pos, vec2(0.155, 0.4));\n    c1 = smin(sdCylinder(pos5, vec2(0.136, 0.053)), c1, 17.);\n    float c2 = sdCylinder(pos, vec2(0.15, 0.42));\n    c2 = smin(sdCylinder(pos5, vec2(0.136, 0.053)), c2, 17.);\n    float df = max(c1, -c2);\n \n    #ifdef dev_mode\n    df = max(df, -pos.x);\n    #endif   \n    \n    return df;\n    #else\n    return 10.;\n    #endif\n}\n\nfloat map_plug(vec3 pos)\n{\n    #ifdef show_plug\n    pos = rotateVec2(pos);\n    pos+= plugPos;\n    \n    vec3 pos2 = pos - vec3(0., 0.32, 0.);\n    vec3 pos3 = pos - vec3(0., 0.51, 0.);\n    vec3 pos4 = (pos - vec3(0., 0.71, 0.))*vec3(1., 1.15, 1.);\n    \n    float df = sdCone(pos*vec3(1., -1, 1.), vec3(0.8,0.45,0.27));\n    df = SoftMaximum(df, -pos.y + 0.02, 50.);\n    df = smin(df, sdCylinder(pos2, vec2(0.16, 0.04)), 170.);\n    df = smin(df, sdCylinder(pos3, vec2(0.05, 0.08)), 20.8);\n    \n    float tp = length(pos4) - 0.17;\n    float a = atan(pos.x, pos.z);\n    tp = SoftMaximum(tp, length(pos.xz) - 0.16*(1. - 0.15*abs(sin(a*5.))), 60.);\n    df = smin(df, tp, 45.);\n    \n    #ifdef dev_mode\n    //df = max(df, -pos.x);\n    #endif     \n    \n    return df;\n    \n    #else\n    return 10.;\n    #endif\n}\n\nfloat map_cognac(vec3 pos)\n{\n    #ifdef show_cognac\n    if (!traceGlass)\n        return 10.;\n    \n    #ifdef show_glass\n    vec3 pos2 = (pos + glassPos)*0.88;\n\n    #ifdef bumped_glass\n    pos2+= getGlassBump(pos2);\n    #endif\n    #ifdef show_plate\n    pos2.y-= -0.153 + plateThickness*2.;\n    #endif\n    \n    float gc = map_glass_int(pos2);\n    float be2 = 1./(pow(abs(gc - 0.01), 2.5));\n    gc = max(gc, pos2.y - 0.03 - clamp(0.0000002*be2, 0., 0.026)) + 0.015;\n    #endif\n    \n    pos = rotateVec2(pos);\n    pos+= vec3(0.02, 0.56, 0.03);\n    pos*= 1.25;\n    \n    float lev = 0.35; //iTime*0.01;\n    float intb = map_bottle_int(pos);\n    float be = 1./(0.000015 + pow(abs(intb), 2.5));\n    float df = max(intb, pos.y + 0.48 - clamp(0., 1., lev)*3.15 - clamp(0.0000004*be, 0., 0.05));\n\n    #ifdef show_glass\n    df = min(gc, df);\n    #endif\n    \n    #ifdef dev_mode\n    df = max(df, pos2.z);\n    #endif \n    return df;\n    #else\n    return 10.;\n    #endif\n}\n\nfloat map_plate(vec3 pos)\n{\n    #ifdef show_plate\n    pos = rotateVec2(pos);\n    pos.y+= 1.07 + plateThickness;\n\n    float a = atan(pos.x, pos.z)/(2.*pi);\n    float c = pow(abs(smoothstep(-0.02, 1.02, fract(a*6.)) - 0.5), 8.);\n    pos.xz/= 1.1 - 23.*c*smoothstep(0.45, 0.58, length(pos.xz)/plateSize) - 0.06*smoothstep(1.3, 2.5, 1. + sin((a + 0.125)*12.*pi));\n    float l = length(pos.xz)/plateSize;\n    pos.y-= 0.13*smoothstep(0.58, 0.75, l);\n    pos.y-= 0.05*smoothstep(0.7, 1.1, l);\n    pos.y-= 0.07*smoothstep(-1., 0.6, cos(l*3.));\n    pos.y/= (1. + 0.45*smoothstep(0.96, 1.02, l));\n    float df = sdCylinder(pos, vec2(plateSize*1.1, plateThickness*1.03));\n    df = SoftMaximum(df, sdCylinder(pos, vec2(plateSize, plateThickness*2.)), 55.);\n    #ifdef dev_mode\n    df = max(df, -pos.x);\n    #endif   \n    return df;\n    #else\n    return 10.;\n    #endif\n}\n\nfloat map_table(vec3 pos)\n{\n    #ifdef show_table\n    pos = rotateVec2(pos);\n    #ifdef show_plate\n    pos.y+= 1.233 + plateThickness*2.;\n    #else\n    pos.y+= 1.201;\n    #endif\n    \n    float df = sdCylinder(pos, vec2(7., 0.2));\n    \n    #ifdef dev_mode\n    df = max(df, -pos.x);\n    #endif\n    \n    return df;\n    \n    #else\n    return 10.;\n    #endif\n}\n\nvec2 map(vec3 pos, bool inside)\n{\n    float bottle = map_bottle(pos);\n    float cognac = map_cognac(pos);\n    float glass = map_glass(pos);\n    float plug = map_plug(pos);\n    vec2 res = opU(vec2(bottle, BOTTLE_OBJ), vec2(cognac, COGNAC_OBJ));\n    res = opU(res, vec2(glass, GLASS_OBJ));\n    res = opU(res, vec2(plug, PLUG_OBJ));\n    if (inside)\n        res.x = -res.x; \n    \n    float table = map_table(pos);\n    float plate = map_plate(pos);\n    float label = map_label(pos);\n    float neck = map_neck(pos);\n\n    res = opU(res, vec2(table, TABLE_OBJ));\n    res = opU(res, vec2(plate, PLATE_OBJ));\n    res = opU(res, vec2(label, LABEL_OBJ));\n    res = opU(res, vec2(neck, NECK_OBJ));\n\n    return res;\n}\n\n// Main tracing function\nvec2 trace(vec3 cam, vec3 ray, float maxdist, bool inside) \n{\n    float t = inside?0.12:0.01;\n    float objnr = 0.;\n    vec3 pos;\n    float dist;\n    float dist2;\n    \n  \tfor (int i = 0; i < 110; ++i)\n    {\n    \tpos = ray*t + cam;\n        vec2 res = map(pos, inside);\n        dist = res.x;\n        if (dist>maxdist || abs(dist)<0.002)\n            break;\n        t+= dist*(0.35 + 0.004*float(i));\n        objnr = abs(res.y);\n  \t}\n  \treturn vec2(t, objnr);\n}\n\n// From https://www.shadertoy.com/view/MstGDM\n// Here the texture maping is only used for the normal, not the raymarching, so it's a kind of bump mapping. Much faster\nvec3 getNormal(vec3 pos, float e, bool inside)\n{  \n    vec2 q = vec2(0, e);\n    return normalize(vec3(map(pos + q.yxx, inside).x - map(pos - q.yxx, inside).x,\n                          map(pos + q.xyx, inside).x - map(pos - q.xyx, inside).x,\n                          map(pos + q.xxy, inside).x - map(pos - q.xxy, inside).x));\n}\n\n// Gets the color of the sky\nvec3 sky_color(vec3 ray)\n{ \n    return vec3(0.06, 0.12, 0.06) + 1.1*mix(texture(iChannel1, ray).rgb, texture(iChannel1, ray).rrr, 0.4);\n    //return vec3(1.);\n}\n\nvec3 getGlassColor(vec3 pos)\n{\n    #ifdef dev_mode\n    return glassMat.col_dev;\n    #else\n    return glassMat.col_dif;\n    #endif\n}\n\nvec3 getCognacColor(vec3 pos)\n{\n    #ifdef dev_mode\n    return cognacMat.col_dev;\n    #else\n    return cognacMat.col_dif;\n    #endif\n}\n\nvec3 getPlugColor(vec3 pos)\n{\n    #ifdef dev_mode\n    return plugMat.col_dev;\n    #else\n    return plugMat.col_dif;\n    #endif\n}\n\nvec3 getTableColor(vec3 pos)\n{\n    vec2 p1 = stoneSize*pos.xz + vec2(8., 8.) + 0.05*noise(pos*1.8);\n    vec3 t1 = texture(iChannel0, p1).xyz;\n    vec2 p2 = 1.35*p1 + vec2(0.4, -0.3) + 0.3*noise(pos*1.2);\n    vec3 t2 = texture(iChannel0, p2).xyz;\n    vec2 p3 = 1.55*p1 + vec2(0.2, 0.5);\n    vec3 t3 = texture(iChannel0, p3).xyz;\n    return mix(0.8*mix(t1, mix(t2, t3, noise(pos*3.)), noise(pos*1.2)), vec3(0.35), 0.15);\n}\n\nvec3 getLabelColor(vec3 pos)\n{\n    pos = rotateVec2(pos);\n    pos = label_pos(pos);\n    \n    float l = length(pos.xz);\n    float a = atan(pos.x, pos.z);\n    \n    vec3 c1 = mix(vec3(0.3, 0.2, 0.15), vec3(1.1, 0.1, 0.05), pos.z*6. + 1.1);\n    vec3 c2 = mix(vec3(0.35, 0.9, 1.1), vec3(0.1, 0.2, 0.7), pos.z*10. - 0.23);\n    vec3 col = mix(c1, c2, smoothstep(0.77, 0.76, abs(a)));\n    col = mix(col, vec3(1.2, 0.95, 0.22), smoothstep(0.087, 0.089, l));\n    col = mix(col, vec3(0.), smoothstep(0.105, 0.107, l));\n    col = mix(col, mix(col, vec3(1.2), 0.85), smoothstep(0.0, -0.001, pos.y));\n    \n    return col;\n}\n\nvec3 getNeckColor(vec3 pos)\n{\n    pos+= vec3(0.018, -1.36, 0.03);\n    float a = atan(pos.x, pos.z);\n    \n    vec3 col = mix(vec3(0.16, 0.22, 0.22), vec3(0.6, 0.22, 0.22), smoothstep(0.15, -0.25, pos.y));\n    float p = 5.5;\n    float t = min(min(abs(fract(p*pos.y + 3.*a/pi + 0.24)), abs(fract(-p*pos.y + 3.*a/pi))), 8.*pos.y + 3.18);\n    col = mix(col, vec3(0.), 0.65*smoothstep(0.18, 0.16, t));\n    col = mix(col, vec3(1.15, 0.97, 0.4), smoothstep(0.09, 0.08, t));\n    return col;\n}\n\nvec3 getPlateColor(vec3 pos)\n{\n    float a = atan(pos.x, pos.z)/(2.*pi);\n    float c = pow(abs(smoothstep(-0.02, 1.02, fract(a*6.)) - 0.5), 8.);\n    pos.xz/= 1.1 - 23.*c - 0.06*smoothstep(1.3, 2.5, 1. + sin((a + 0.125)*12.*pi));\n    float l = length(pos.xz)/plateSize;\n    \n    vec3 col = plateColor - 0.15 + 0.2*l;\n    col-= 0.1*smoothstep(0.54, 0.61, l)*smoothstep(0.67, 0.61, l);\n    col-= 0.1*smoothstep(0.63, 0.71, l)*smoothstep(0.78, 0.71, l);\n    col-= 0.18*smoothstep(0.9, 1.01, l);\n    col-= 0.6*smoothstep(0.04, 0.18, 22.*c*smoothstep(0.4, 0.7, l));\n    \n    col+= 0.12*noise(pos*5.3);\n    col = pow(col, vec3(1, 0.9, 0.8));\n    \n    return col;\n}\n    \n// Combines the colors\nvec3 getColor(vec3 norm, vec3 pos, int objnr, vec3 ray)\n{\n   pos = rotateVec2(pos);\n   return ((objnr==BOTTLE_OBJ || objnr==GLASS_OBJ)?getGlassColor(pos):\n          (objnr==TABLE_OBJ?getTableColor(pos):\n          (objnr==PLATE_OBJ?getPlateColor(pos):\n          (objnr==COGNAC_OBJ?getCognacColor(pos):\n          (objnr==LABEL_OBJ?getLabelColor(pos):\n          (objnr==NECK_OBJ?getNeckColor(pos):\n          (objnr==PLUG_OBJ?getPlugColor(pos):\n           getGlassColor(pos))))))));\n}\n\n// From https://www.shadertoy.com/view/Xds3zN\nfloat calcAO(in vec3 pos, in vec3 nor)\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for(int i=0; i<6; i++)\n    {\n        float hr = 0.01 + 0.12*float(i)/9.0;\n        vec3 aopos =  nor*hr + pos;\n        float dd = map(aopos, false).x;\n        occ+= -(dd - hr)*sca;\n        sca*= 0.85;\n    }\n    occ = 2.*smoothstep(0.06, 0.5, occ);\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n\n// Fresnel reflectance factor through Schlick's approximation: https://en.wikipedia.org/wiki/Schlick's_approximation\nfloat fresnel(vec3 ray, vec3 norm, float n2)\n{\n   float n1 = 1.; // air\n   float angle = acos(-dot(ray, norm));\n   float r0 = dot((n1-n2)/(n1+n2), (n1-n2)/(n1+n2));\n   float r = r0 + (1. - r0)*pow(1. - cos(angle), 5.);\n   return clamp(r, 0., 0.8);\n}\n\n// Shading of the objects pro lamp\nvec3 lampShading(Lamp lamp, vec3 norm, vec3 pos, vec3 ocol, int objnr, int lampnr)\n{   \n    vec3 pl = normalize(lamp.position - pos);\n    float dlp = distance(lamp.position, pos);\n    vec3 pli = pl/pow(1. + lamp.attenuation*dlp, 2.);\n    float dnp = dot(norm, pli);\n      \n    // Diffuse shading\n    vec3 col;\n    if (objnr==PLATE_OBJ)\n        col = ocol*lamp.color*lamp.intensity*smoothstep(-0.1, 1., sign(dnp)*pow(abs(dnp), 1.8));\n    else\n        col = ocol*lamp.color*lamp.intensity*smoothstep(-0.1, 1., dnp);\n    \n    // Specular shading\n    #ifdef specular\n    float specint;\n    float specshin;\n    if (objnr==BOTTLE_OBJ || objnr==GLASS_OBJ)\n    {\n        specint = glassMat.specint;\n        specshin = glassMat.specshin;       \n    }\n    if (objnr==COGNAC_OBJ)\n    {\n        specint = cognacMat.specint;\n        specshin = cognacMat.specshin;       \n    }\n    if (objnr==PLUG_OBJ)\n    {\n        specint = plugMat.specint;\n        specshin = plugMat.specshin;       \n    }\n    if (objnr==TABLE_OBJ)\n    {\n        specint = specint_table;\n        specshin = specshin_table;       \n    }\n    if (objnr==PLATE_OBJ)\n    {\n        specint = specint_plate;\n        specshin = specshin_plate;       \n    }\n    if (objnr==LABEL_OBJ || objnr==NECK_OBJ)\n    {\n        specint = specint_label;\n        specshin = specshin_label;       \n    }\n\n    //if (dot(norm, lamp.position - pos) > 0.0)\n        col+= lamp.color*lamp.intensity*specint*pow(max(0.0, dot(reflect(pl, norm), normalize(pos - campos))), specshin);\n    #endif\n    \n    return col;\n}\n\n// Shading of the objects over all lamps\nvec3 lampsShading(vec3 norm, vec3 pos, vec3 ocol, int objnr)\n{\n    vec3 col = vec3(0.);\n    for (int l=0; l<2; l++) // lamps.length()\n        col+= lampShading(lamps[l], norm, pos, ocol, objnr, l);\n    \n    return col;\n}\n\n// From https://www.shadertoy.com/view/lsSXzD, modified\nvec3 GetCameraRayDir(vec2 vWindow, vec3 vCameraDir, float fov)\n{\n\tvec3 vForward = normalize(vCameraDir);\n\tvec3 vRight = normalize(cross(vec3(0.0, 1.0, 0.0), vForward));\n\tvec3 vUp = normalize(cross(vForward, vRight));\n    \n\tvec3 vDir = normalize(vWindow.x * vRight + vWindow.y * vUp + vForward * fov);\n\n\treturn vDir;\n}\n\n// Sets the position of the camera with the mouse and calculates its direction\nvoid setCamera()\n{\n   vec2 iMouse2;\n   if (iMouse.x==0. && iMouse.y==0.)\n      iMouse2 = iResolution.xy*vec2(0.52, 0.65);\n   else\n      iMouse2 = iMouse.xy;\n   \n   campos = vec3(10.*cos(6.*iMouse2.x/iResolution.x)*(1. - 0.5*iMouse2.y/iResolution.y),\n                 15.*(iMouse2.y/iResolution.y),\n                 10.*sin(6.*iMouse2.x/iResolution.x)*(1. - 0.5*iMouse2.y/iResolution.y));\n   #ifdef dev_mode\n   camtarget = -glassPos; //vec3(0., -1.3*iMouse2.y/iResolution.y + 2.2, 0.);\n   #else\n   camtarget = vec3(0., -1.3*iMouse2.y/iResolution.y + 0.6, 0.); //vec3(0., -1.3*iMouse2.y/iResolution.y + 2.2, 0.);\n   #endif\n   camdir = camtarget - campos;   \n}\n\n// Tracing and rendering a ray\nRenderData trace0(vec3 tpos, vec3 ray, float maxdist, bool inside)\n{\n    vec2 tr = trace(tpos, ray, maxdist, inside);\n    float tx = tr.x;\n    int objnr = int(tr.y);\n    vec3 col;\n    vec3 pos = tpos + tx*ray;\n    vec3 norm;\n    \n    if (tx<maxdist*0.95)\n    {\n        norm = getNormal(pos, normdelta, inside);\n        col = getColor(norm, pos, objnr, ray);\n      \n        // Shading\n        col = ambientColor*ambientint + lampsShading(norm, pos, col, objnr);\n        \n        // Ambient occlusion\n        #ifdef ambocc\n        col*= 1. - aoint + aoint*vec3(calcAO(pos, norm));\n        //col = vec3(calcAO(pos, norm));\n        #endif\n    }\n    else\n    {\n        objnr = SKY_OBJ;\n        col = vec3(0.);\n    }\n    return RenderData(col, pos, norm, objnr);\n}\n\nvec3 getGlassAbsColor(float dist, vec3 color)\n{\n    return pow(color, vec3(0.3 + pow(dist*10., 1.6)));\n}\n\n// Main render function with reflections and refractions\nvec4 render(vec2 fragCoord)\n{   \n  \tvec2 uv = fragCoord.xy / iResolution.xy; \n  \tuv = uv*2.0 - 1.0;\n  \tuv.x*= iResolution.x / iResolution.y;\n\n  \tvec3 ray0 = GetCameraRayDir(uv, camdir, fov);\n    vec3 ray = ray0;\n  \tRenderData traceinf0 = trace0(campos, ray, maxdist, false);\n    RenderData traceinf = traceinf0;\n  \tvec3 col = traceinf.col;\n    vec3 col0 = col;\n    vec3 cols = vec3(0.);\n  \tbool inside = false;\n  \tfloat cior = glass_ior;\n  \tvec3 glassf = vec3(1.);\n    vec3 refray;\n    int oObjNr = traceinf.objnr;\n    \n    col = col0;\n    traceinf = traceinf0;\n    ray = ray0;\n    glassf = vec3(1.);\n\n    for (int i=0; i<nbref; i++)\n    {\n        #ifndef dev_mode\n        #ifdef reflections\n        if (traceinf.objnr==TABLE_OBJ || traceinf.objnr==PLATE_OBJ || traceinf.objnr==GLASS_OBJ || traceinf.objnr==BOTTLE_OBJ || traceinf.objnr==COGNAC_OBJ || traceinf.objnr==PLUG_OBJ)\n        {\t               \n            refray = reflect(ray, traceinf.norm);\n\n            RenderData traceinf_ref = trace0(traceinf.pos, refray, 20., inside);\n            float rf = traceinf.objnr==PLATE_OBJ?plateRf:\n            fresnel(ray, traceinf.norm, (traceinf.objnr==GLASS_OBJ || traceinf.objnr==BOTTLE_OBJ || traceinf.objnr==PLUG_OBJ)?glass_ior*1.1:(traceinf.objnr==COGNAC_OBJ?cognac_ior:3.));\n            //if (i==5) return vec4(rf);\n            if (traceinf.objnr==TABLE_OBJ || traceinf.objnr==PLATE_OBJ)\n            {\n                glassf*= rf;\n                col*= (1.- rf);\n                col+= clamp(glassf*traceinf_ref.col, 0., 1.);\n                ray = refray;\n                traceinf = traceinf_ref;\n            }\n            else\n            {\n                col+= clamp(glassf*traceinf_ref.col*rf, 0., 1.);\n                glassf*= (1.- rf*0.65);\n            }\n        }\n        #endif\n        if (traceinf.objnr==GLASS_OBJ || traceinf.objnr==BOTTLE_OBJ || traceinf.objnr==COGNAC_OBJ || traceinf.objnr==PLUG_OBJ)\n        {\n            if (traceinf.objnr==BOTTLE_OBJ || traceinf.objnr==GLASS_OBJ || traceinf.objnr==PLUG_OBJ)\n                cior = inside?1./glass_ior:glass_ior;\n            if (traceinf.objnr==COGNAC_OBJ)\n                cior = inside?1./cognac_ior:cognac_ior;\n            vec3 ray_r = refract(ray, traceinf.norm, 1./cior);\n            if (length(ray_r)!=0.)\n                inside = !inside;\n            else\n                ray_r = reflect(ray, traceinf.norm);            \n\n            vec3 pos = traceinf.pos;\n\n            traceinf = trace0(pos, ray_r, 20., inside);\n            if (inside)\n                glassf*= getGlassAbsColor(distance(pos, traceinf.pos), traceinf.objnr==COGNAC_OBJ?cognacMat.col_vol:(traceinf.objnr==PLUG_OBJ?plugMat.col_vol:glassMat.col_vol));\n            glassf*= traceinf.objnr==COGNAC_OBJ?cognacMat.col_fil:(traceinf.objnr==PLUG_OBJ?plugMat.col_fil:glassMat.col_fil);\n            \n            col+= clamp(traceinf.col*glassf, 0., 1.);\n\n            ray = ray_r;\n\n        }\n        #endif\n        if (traceinf.objnr==SKY_OBJ)\n        {\n            col+= sky_color(ray)*glassf;\n            break;\n        }\n        oObjNr = traceinf.objnr;\n    }\n    //return vec4(1., 0.7, 1., 0.);\n  \treturn vec4(col, 1.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{   \n    init();\n    setCamera();\n    \n    // Antialiasing.\n    #ifdef antialias\n    vec4 vs = vec4(0.);\n    for (int j=0;j<aasamples ;j++)\n    {\n       float oy = float(j)*aawidth/max(float(aasamples-1), 1.);\n       for (int i=0;i<aasamples ;i++)\n       {\n          float ox = float(i)*aawidth/max(float(aasamples-1), 1.);\n          vs+= render(fragCoord + vec2(ox, oy));\n       }\n    }\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    fragColor = vs/vec4(aasamples*aasamples);\n    #else\n    fragColor = render(fragCoord);\n    #endif\n}","name":"Image","description":"","type":"image"}]}