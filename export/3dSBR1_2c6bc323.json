{"ver":"0.1","info":{"id":"3dSBR1","date":"1589528053","viewed":262,"name":"Interactive Monte Carlo Pt.1","username":"fluxatron","description":"Pt2: https://www.shadertoy.com/view/tdSfzD\n\nAn attempt to accumulate GI with a unbiased Monte Carlo RT.\nThis has many bugs in the noise and sampling. This was just what I could get done in an hour or so.\n\nBased on Ray Tracing books by Peter Shirley","likes":8,"published":1,"flags":32,"usePreview":0,"tags":["raytracing","interactive","montecarlo","unbiased"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nfloat DecodeFrame()\n{\n    return texelFetch(iChannel0, ivec2(0,0), 0).r;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float frame = DecodeFrame();\n    \n    vec2 uv = fragCoord/iResolution.xy; // Normalized pixel coordinates (from 0 to 1)\n    vec3 col = texture(iChannel0, uv).rgb / float(frame+1.); // divide accumulation buffer by num frames. +1 is so first frame shows a sample\n    \n    col = pow(col, vec3(0.4545)); // gamma 1/2.2\n    fragColor = vec4(col, 1.);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define MAX_BOUNCES 5\n\n\n#define BIG_FLOAT 9999999.\n#define PI 3.1415926\n#define TAU 6.2831853\n\n// TYPES //////////////////////////////////////////////////////////////////////////////////\n\nstruct Sphere\n{\n    vec3 Center;\n    float Radius;\n};\nstruct Ray \n{\n    vec3 Origin;\n    vec3 Dir;\n};\nstruct Hit \n{\n    vec3 Pos; // point in space\n    vec3 Normal; // normal of hit surface\n    float LengthAlongRay; // length along ray of hit\n   //bool IsFrontFace; // whether we hit the outside or inside of the surface\n};\n\n\n// HELPERS //////////////////////////////\n    \n    \n// hash - https://www.shadertoy.com/view/XlXcW4\nconst uint k = 1103515245U;  // GLIB C\nvec3 Hash(uvec3 x)\n{\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    \n    return vec3(x)*(1.0/float(0xffffffffU));\n}\n\nvec3 RandomUnitVector(uvec3 seeds) \n{\n    vec3 hash = Hash(seeds);\n\n    float a = hash.x*TAU;     //  0 to TAU\n    float z = hash.y*2. - 1.; // -1 to 1\n    float r = sqrt(1. - z*z);\n    return vec3(r*cos(a), r*sin(a), z);\n}\n\nvec3 RandomInUnitSphere(uvec3 seeds)\n{\n    vec3 hash = Hash(seeds);\n    \n    float theta = hash.x * TAU;\n    float v = hash.y;\n    float r = pow(hash.z, 0.333333);\n    \n    float phi = acos((2.*v)-1.);\n    float sinphi = sin(phi);\n    \n    vec3 p;\n    p.x = r * sinphi * cos(theta);\n    p.y = r * sinphi * sin(theta);\n    p.z = r * cos(phi); \n    \n    return p;\n}\n\nfloat Noise1D( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\tvec2 rg = textureLod( iChannel0, (uv+ 0.5)/256.0, 0. ).yx;\n\treturn mix( rg.x, rg.y, f.z );\n}\n                 \nmat3 ViewMatrix(vec3 eye, vec3 target, float yaw)\n{\n\tvec3 yawVec = vec3(sin(yaw), cos(yaw), 0.);\n\tvec3 w = normalize(eye-target); // right handed TODO Change all math to left handed? \n\tvec3 u = normalize(cross(w,yawVec));\n\tvec3 v = normalize(cross(u,w));\n    return mat3(u, v, w);\n}\n                 \n// SHAPES /////////////////////////////////////////////////////////////////////////////////\n\nbool HitSphere(Sphere sph, Ray ray, float tMin, float tMax, inout Hit hit)\n{\n    vec3 oc = ray.Origin - sph.Center;\n    \n    float a = dot(ray.Dir, ray.Dir);\n    float half_b = dot(oc, ray.Dir);\n    float c = dot(oc, oc) - sph.Radius*sph.Radius;\n    float discriminant = half_b*half_b - a*c;\n    \n    \n    if (discriminant > 0.) \n    {\n        float root = sqrt(discriminant);\n        float temp = (-half_b - root)/a;\n       \n        if (temp > tMin && temp < tMax) \n        {\n            hit.LengthAlongRay = temp;\n            hit.Pos = ray.Origin + ray.Dir*temp;\n            \n            //vec3 outwardNormal = (hit.Pos - sph.Center) / sph.Radius;\n            //hit.IsFrontFace = dot(outwardNormal, ray.Dir) < 0.;\n            //hit.Normal = hit.IsFrontFace ? outwardNormal : -outwardNormal;\n            hit.Normal = normalize(hit.Pos - sph.Center);// / sph.Radius;\n        \treturn true;\n        }\n        \n        temp = (-half_b + root)/a;\n        if (temp > tMin && temp < tMax)\n        { \n            hit.LengthAlongRay = temp;\n            hit.Pos = ray.Origin + ray.Dir*temp;\n            \n            //vec3 outwardNormal = (hit.Pos - sph.Center) / sph.Radius;\n            //hit.IsFrontFace = dot(outwardNormal, ray.Dir) < 0.;\n            //hit.Normal = hit.IsFrontFace ? outwardNormal : -outwardNormal;\n            hit.Normal = normalize(hit.Pos - sph.Center);// / sph.Radius;\n        \treturn true;\n        }\n    }\n    \n    return false;\n}\n\n\n// SCENE /////////////////////////////////////////////////////////////////////////////////\n\nbool FindClosestHit(Ray ray, inout Hit hit)\n{\n    float tMin = 0.0001;\n    float tMax = BIG_FLOAT;\n    Hit tempHit;\n    \n    bool hitAnything = false;\n    float closestSoFar = tMax;\n    \n    \n    // Sphere test\n    {\n        Sphere sph;\n        sph.Center = vec3(0,0,0);\n        sph.Radius = .5;\n        if (HitSphere(sph, ray, tMin, closestSoFar, tempHit))\n        {\n\t\t\thitAnything = true;\n            closestSoFar = tempHit.LengthAlongRay;\n            hit = tempHit;\n        }\n    }\n    \n    \n    // Sphere2 test\n    {\n        Sphere sph;\n        sph.Center = vec3(-1.2,0,0);\n        sph.Radius = .5;\n        if (HitSphere(sph, ray, tMin, closestSoFar, tempHit))\n        {\n\t\t\thitAnything = true;\n            closestSoFar = tempHit.LengthAlongRay;\n            hit = tempHit;\n        }\n    }\n    \n    // Sphere2 test\n    {\n        Sphere sph;\n        sph.Center = vec3(1.2,0,0);\n        sph.Radius = .5;\n        if (HitSphere(sph, ray, tMin, closestSoFar, tempHit))\n        {\n\t\t\thitAnything = true;\n            closestSoFar = tempHit.LengthAlongRay;\n            hit = tempHit;\n        }\n    }\n    \n    // Ground sphere\n    {\n        Sphere sph;\n        sph.Center = vec3(0,-100.5,0);\n        sph.Radius = 100.;\n        if (HitSphere(sph, ray, tMin, closestSoFar, tempHit))\n        {\n\t\t\thitAnything = true;\n            closestSoFar = hit.LengthAlongRay;\n            hit = tempHit;\n        }\n    }\n    \n    return hitAnything;\n}\n\nvec3 Color(Ray ray, vec2 uv, int sampleId)\n{\n\tvec3 col = vec3(0);\n    Hit hit;\n\n    \n    for (int bounce = 0; bounce < MAX_BOUNCES; bounce++)\n    {\n\t\tif (FindClosestHit(ray, hit))\n        {\n            // Update the ray for next bounch\n        \tray.Origin = hit.Pos + hit.Normal * 0.001; // Slightly off the hit surface\n        \tray.Dir = hit.Normal + RandomUnitVector(uvec3(uv*float(sampleId*3*bounce*7), iFrame));            \n        }\n        else\n        {\n            float power = 1. / pow(2., float(bounce)); // 0.5, 0.25, 0.125, etc...\n            //col += power * hit.Col\n                \n            // Sky colour and leave\n            col = power * mix(vec3(1.), vec3(.5,.7,1.), 0.5*uv.y + .5);\n            break;\n        }\n    }\n    \n    return col;\n}\n\nvec4 EncodeFrame(float frame)\n{\n    return vec4(frame,0,0,0);\n}\nfloat DecodeFrame()\n{\n    return texelFetch(iChannel0, ivec2(0,0), 0).r;\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    float aspect = iResolution.x / iResolution.y;\n    vec2 uv = (2.*(fragCoord) - iResolution.xy) / iResolution.yy; // -(aspect,1) -> (aspect,1)\n    vec2 uvNorm = (fragCoord) / iResolution.xy;                   //       (0,0) -> (1,1)\n\tvec2 m = (2.*iMouse.xy - iResolution.xy) / iResolution.yy;   // -(aspect,1) -> (aspect,1)\n    \n    // Camera ray\n    Ray ray;\n    {\n\t\t// Define ray vector in the image plane\n        vec2 pixelOffset = Hash(uvec3(fragCoord, iFrame)).xy / iResolution.xy; // random pixel offset within a pixel\n        float fovFactor = 2.;\n        float zoom = 3.;\n        float horizontal = fovFactor*aspect;\n        float vertical = fovFactor;\n        vec3 lowerLeftCorner = -vec3(horizontal/2., vertical/2., zoom);\n        vec3 lensRay = normalize(lowerLeftCorner + vec3((uvNorm.x+pixelOffset.x)*horizontal, (uvNorm.y+pixelOffset.x)*vertical, 0.));\n\n\n        float camDist = 4.;\n        ray.Origin = camDist * vec3(-sin(m.x*PI), smoothstep(0.,2.,clamp(2.*m.y + 1.,0.,2.)), -cos(m.x*PI));\n        ray.Dir = ViewMatrix(ray.Origin, vec3(0), 0.) * lensRay;\n    }\n  \n \n    \n    // Track accumulated frames\n    if (ivec2(fragCoord) == ivec2(0,0))\n    {\n        float frame = DecodeFrame();\n        frame+= 1.;\n        \n         // Get mouse state\n    \tbool mousePressed = iMouse.z > 0.0;\n        if (mousePressed)\n        {\n        \tframe = 0.;\n        }\n        \n        fragColor = EncodeFrame(frame);\n        return;\n    }\n    \n       \n    vec3 col = texture(iChannel0, fragCoord/iResolution.xy).xyz;\n    if(iFrame == 0 || DecodeFrame() < 1.) \n    {\n    \tcol = vec3(0,0,0);\n    }\n    \n    \n    int spp = 1; // BUG: spp > 1 puts a black rectangle shadow in bottom left *shrug*\n    vec3 tmp;\n    for (int sampleId = 0; sampleId < spp; sampleId++)\n    {\n    \ttmp += Color(ray, uv, sampleId);\n    }\n    tmp /= float(spp);\n    col += tmp;\n    fragColor = vec4(col, 1.0);\n}\n","name":"Buffer A","description":"","type":"buffer"}]}