{"ver":"0.1","info":{"id":"fslBD7","date":"1644950022","viewed":169,"name":"Ray-tracing demo","username":"DungyBug","description":"Simple ray-tracing demo","likes":5,"published":1,"flags":32,"usePreview":0,"tags":["raytracing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\nTaken from GLSL sandbox: https://glslsandbox.com/e#79276.11\n*/\n\nprecision highp float;\n\n// CIE XYZ color space to RGB\nvec3 xyz2rgb(vec3 xyz) {\n    mat3 coefs = mat3(\n         3.2404542, -1.5371385, -0.4985314,\n        -0.9692660,  1.8760108,  0.0415560,\n         0.0556434, -0.2040259,  1.0572252\n    );\n    \n    return transpose(coefs) * xyz;\n}\n\n// ACES color space to CIE XYZ\nvec3 aces2xyz(vec3 aces) {\n    mat3 coefs = mat3(\n        0.9525523959, 0.0000000000,  0.0000936786,\n        0.3439664498, 0.7281660966, -0.0721325464,\n        0.0000000000, 0.0000000000,  1.0088251844\n    );\n    \n    return transpose(coefs) * aces;\n}\n\nvec3 filmicLog(vec3 color) {\n    return vec3(\n        log(color.r + 1.0),\n        log(color.g + 1.0),\n        log(color.b + 1.0)\n    );\n}\n\nvec3 colorFilter(vec3 color, float gamma, float lightness) {\n    // Convert ACES color space to RGB\n    vec3 xyz = aces2xyz(filmicLog(color));\n    vec3 rgb = xyz2rgb(xyz);\n    \n    // Convert color to F-Log\n    rgb = filmicLog(rgb);\n    \n    // Apply gamma\n    rgb = vec3(\n        pow(rgb.r, gamma),\n        pow(rgb.g, gamma),\n        pow(rgb.b, gamma)\n    );\n    \n    rgb *= lightness;\n    \n    return rgb;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec4 color = texture(iChannel0, fragCoord / iResolution.xy);\n\n\tfragColor = vec4( colorFilter(color.rgb / color.a, 0.9, 1.25), 1.0 );\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"/*\nTaken from GLSL sandbox: https://glslsandbox.com/e#79276.11\n*/\n\nprecision highp float;\n\n// For aperture\n#define f 0.2\n\n// Ray tracing settings\n#define MAX_RAY_REFLECTIONS\t\t6\n#define SAMPLES\t\t\t\t\t8\n\n// Camera settings\n#define F_STOP\t\tf/1.8\n#define GAMMA\t\t0.9\n#define LIGHTNESS\t1.25\n#define TIME        13.0\n\n// In order to reduce count of texture calls, we just sample noise texture once and use it as seed for non-textural random ( func rand2 )\nfloat randomSeed;\n\n/*\n*************************************************\n*                    RANDOM                     *\n*************************************************\n*/\n\nfloat rand(vec2 n) { \n\treturn texture(iChannel0, vec2(mod(abs(n.x), 256.0) / 256.0 + fract(n.x), mod(abs(n.y), 256.0) / 256.0 + fract(n.y)) * 0.5).r;\n}\n\nfloat rand(float n) {\n    return texture(iChannel0, vec2(mod(abs(n), 256.0) / 256.0, mod(abs(n) * 4925.0, 256.0) / 256.0 + fract(n)) * 0.5).r;\n}\n\nfloat rand2(vec2 n) { \n\treturn fract(sin(dot(n + randomSeed * 6275.0, vec2(12.9898, 4.1414))) * 43758.5453);\n}\n\nfloat rand2(float n) { \n\treturn fract(sin(dot(vec2(n + randomSeed * 8473.0), vec2(12.9898, 4.1414))) * 43758.5453);\n}\n\nfloat noise(vec2 p){\n\tvec2 ip = floor(p);\n\tvec2 u = fract(p);\n\tu = u*u*(3.0-2.0*u);\n\t\n\tfloat res = mix(\n\t\tmix(rand2(ip),rand2(ip+vec2(1.0,0.0)),u.x),\n\t\tmix(rand2(ip+vec2(0.0,1.0)),rand2(ip+vec2(1.0,1.0)),u.x),u.y);\n\treturn res*res;\n}\n\n/*\n*************************************************\n*                   TEXTURES                    *\n*************************************************\n*/\n\nvec3 woodenTexture(vec2 uv) {\n\t// Base wooden color\n\tvec3 color = vec3(0.6352941176470588, 0.3607843137254902, 0.1450980392156863);\n\t\n\t// Wooden pattern\n\tvec2 p = uv;\n\tp.x += sin(uv.x * 9.0) * 0.5 + 0.2358;\n\tp.x += sin(uv.y * 9.0) * 0.25 - 0.15274;\n\tp.y += cos(dot(uv, uv)) * 0.25 + 0.5882;\n\tp.y += sin(dot(uv, uv)) * 0.625 - 0.9275;\n\tp.x *= cos(uv.x);\n\tp.y *= sin(uv.y);\n\t\n\t// distortion\n\tp.x *= noise(uv * 7.0) * 0.5 + 0.5;\n\tp.x *= noise(uv * 31.0) * 0.25 + 0.875;\n\tp.x *= noise(uv * 204.0) * 0.125 + 0.9375;\n\tp.x *= noise(uv * 2957.0) * 0.0625 + 0.96875;\n\tp = sqrt(abs(p));\n\tcolor *= pow(clamp(abs(cos(dot(p, p) / (length(uv * 2.0) + 1.0) * 25.48285) / length(p)), 0.0, 2.0), 0.1857);\n\t\n\treturn color;\n}\n\n/*\n***********************************************\n*             TRANSFORM FUNCTIONS             *\n***********************************************\n*/\n\nmat2 rotate(float angle) {\n\tfloat s = sin(angle);\n\tfloat c = cos(angle);\n\t\n\treturn mat2(c, s, -s, c);\n}\n\n/*\n*************************************************************************\n*                   RAY-SURFACE INTERSECTION FUNCTIONS                  *\n*************************************************************************\n|                                                                       |\n| https://iquilezles.org/articles/intersectors |\n\\_______________________________________________________________________/\n*/\n\n/*\n***********************************************\n*                   SPHERE                    *\n***********************************************\n*/\n\nvec2 sphIntersect( in vec3 ro, in vec3 rd, in vec3 ce, float ra )\n{\n    vec3 oc = ro - ce;\n    float b = dot( oc, rd );\n    float c = dot( oc, oc ) - ra*ra;\n    float h = b*b - c;\n    if( h<0.0 ) return vec2(-1.0); // no intersection\n    h = sqrt( h );\n    return vec2( -b-h, -b+h );\n}\n\n/*\n***********************************************\n*                   PLANE                     *\n***********************************************\n*/\n\nfloat plaIntersect( in vec3 ro, in vec3 rd, in vec4 p )\n{\n    return -(dot(ro,p.xyz)+p.w)/dot(rd,p.xyz);\n}\n/*\nCasts ray to scene and returns it's color\norigin \t\t- ray origin\ndirection\t- ray angles ( from -0.5 to 0.5 )\nfocus\t\t- where to focus at ( length )\naperture\t- aperture size, or how out-of-focuse objects will be diffused\nseed\t\t- random seed\n*/\nvec3 castRay(in vec3 origin, in vec3 direction, in float focus, in float aperture, in float seed, in vec2 coord) {\n\tvec2 position = ( coord.xy - iResolution.xy * .5 ) / min(iResolution.x, iResolution.y);\n\tvec3 color = vec3(1.0);\n\t// Ray direction and origin calculations\n\tvec3 diffuse = (vec3(\n\t\trand2(position.x + 2.0 + (position.y + 2.0) * iResolution.x + fract(iTime) * 52.5 - seed),\n\t\trand2(position.x + 2.0 + (position.y + 2.0) * iResolution.y + fract(iTime) * 62.5 + 2.0 - seed),\n\t\trand2(position.y + 2.0 + (position.x + 2.0) * iResolution.x + fract(iTime) * 60.5 + 4.0 - seed)\n\t) - 0.5) * aperture;\n\t\t\n\tvec3 rd = normalize(vec3(direction + vec3(diffuse / focus)));\n\tvec3 ro = origin - diffuse;\n\t\n\tfor(int i = 0; i < MAX_RAY_REFLECTIONS; i++) {\n\t\t// Initialize with sky color\n\t\tvec3 currentColor = vec3(0.6392156862745098, 0.796078431372549, 0.9411764705882353);\n\t\t\n\t\t// Intersected object characteristics\n\t\tvec3 normal = vec3(0.0);\n\t\tfloat depth = 100.0;\n\t\t\n\t\t// Objects\n\t\tfloat plane = plaIntersect(ro, rd, vec4(0.0, 1.0, 0.0, 0.0));\n\t\tfloat plane2 = plaIntersect(ro, rd, vec4(1.0, 0.0, 0.0, 5.5));\n\t\tfloat plane3 = plaIntersect(ro, rd, vec4(-1.0, 0.0, 0.0, 5.5));\n\t\tfloat sphere = sphIntersect(ro, rd, vec3(.5, .5, 3.5), .5).x;\n\t\tfloat light = sphIntersect(ro, rd, vec3(sin(TIME * 2.0), 0.75 - cos(TIME * 4.0) * 0.25, 5.0), .5).x;\n\t\tfloat lamp = sphIntersect(ro, rd, vec3(sin(TIME) * 0.5 + 0.5, abs(cos(TIME * 5.5) * 0.4) + .1, 2.75), .1).x;\n        \n        // Calculate diffuse vector once, instead of calculating it for sphere, for example, and then realize that this sphere is actually\n        // overlaps by wall and calculate the same value once more time\n        vec3 diffuse;\n        \n        // But first we need to check for ray intersection with world\n        if((plane > 0.0 && plane < depth) || (plane2 > 0.0 && plane2 < depth) || (plane3 > 0.0 && plane3 < depth) || (sphere > 0.0 && sphere < depth)) {\n            diffuse = (vec3(\n\t\t\t\trand(position * 4837.0 + vec2(fract(iTime * 8.0 - .538752363), fract(iTime * 5.0 - .84729843756)) * 525.0 - seed),\n\t\t\t\trand(position * 4837.0 + vec2(fract(iTime * 8.0 - .647224357), fract(iTime * 5.0 - .72436473245)) * 625.0 - seed),\n\t\t\t\t-rand(position * 4837.0 + vec2(fract(iTime * 8.0 - .234657245), fract(iTime * 5.0 - .9834587276)) * 625.0 - seed)\n\t\t\t) - 0.5);\n        }\n\t\t\n\t\tif(plane > 0.0 && plane < depth) {\n\t\t\tdepth = plane;\n\t\t\tcurrentColor = woodenTexture((rd * plane + ro).zx * 10.0 - 2.0);\n            float diffuseChance = rand2(position.y + 2.0 + (position.x + 2.0) * iResolution.x + fract(iTime) * 625.0 + rand2(float(i)) * 86.0 + 6.0 - seed);\n\t\t\tvec3 diff = diffuse;\n            \n            if(diffuseChance < dot(vec3(0.0, 1.0, 0.0), -rd))\n                diff *= 0.2;\n            \n\t\t\tnormal = normalize(vec3(diff.x, 1.0 + diff.z, diff.y));\n\t\t}\n\t\t\n\t\tif(plane2 > 0.0 && plane2 < depth) {\n\t\t\tdepth = plane2;\n\t\t\tcurrentColor = vec3(1.0, 0.1, 0.01) / 0.9;\n\t\t\tvec3 diff = diffuse * (floor(rand2(position.y + 2.0 + (position.x + 2.0) * iResolution.x + fract(iTime) * 625.0 + rand2(float(i)) * 86.0 + 6.0 - seed) * 3.0) * 0.6 + .4);\n\t\t\tnormal = normalize(vec3(1.0 + diff.z, diff.x, diff.y));\n\t\t}\n\t\t\n\t\tif(plane3 > 0.0 && plane3 < depth) {\n\t\t\tdepth = plane3;\n\t\t\tcurrentColor = vec3(0.01, 0.1, 1.0) / 0.9;\n\t\t\tvec3 diff = diffuse * (floor(rand2(position.y + 2.0 + (position.x + 2.0) * iResolution.x + fract(iTime) * 625.0 + rand2(float(i)) * 86.0 + 6.0 - seed) * 3.0) * 0.6 + .4);\n\t\t\tnormal = normalize(vec3(-1.0 - diff.z, diff.x, diff.y));\n\t\t}\n\t\t\n\t\tif(sphere > 0.0 && sphere < depth) {\n\t\t\tdepth = sphere;\n\t\t\tvec3 pos = sphere * rd + ro;\n\t\t\tnormal = normalize(pos - vec3(.5, .5, 3.5));\n\t\t\tcurrentColor = vec3(0.7);\n\t\t}\n\t\t\n\t\tif(light > 0.0 && light < depth) {\n\t\t\tcolor *= 15.0;\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tif(lamp > 0.0 && lamp < depth) {\n\t\t\tcolor *= vec3(1.0, 0.8, 0.5) * 2.0;\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tif(depth == 100.0) {\n\t\t\tcolor *= currentColor;\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\t// Reflect ray\n\t\tro = depth * rd + ro;\n\t\trd = normalize(reflect(rd, normal));\n\t\tro += rd * 0.001; // Move a bit in reflected direction to prevent hitting object, from which we've just reflected\n\t\t\n\t\tcolor *= currentColor * 0.9;\n\t\t\n\t\t// If color is so dark, that it's close to absolute black, we can just stop tracing ray as next iterations won't affect color so much\n\t\tif(color.r + color.g + color.b < 0.3) {\n\t\t\tcolor /= 3.;\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\treturn color;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tfloat focalLength = 1.0;\n\tvec2 position = (( fragCoord - iResolution.xy * .5 ) / min(iResolution.x, iResolution.y)) / focalLength;\n\tmat2 rotation = rotate(TIME * 0.1);\n\tvec3 color = vec3(0.0);\n\tvec3 origin = vec3(-1.0, 0.5, -5.0);\n\torigin.xz *= rotation;\n\torigin.z += 2.5;\n\t\n\tvec3 direction = vec3(position, 1.0);\n\tdirection.xz *= rotation;\n\t\n\tfor(int i = 0; i < SAMPLES; i++) {\n        randomSeed = texture(iChannel0, position * 2345.0 + vec2(fract(iTime * 83.0 - .499367823456) * 7275.0, fract(iTime * 44.0 - .93287462756) * 7275.0)).r;\n\t\tcolor += castRay(origin, direction, distance(origin, vec3(.5, .5, 3.5)), F_STOP, float(i), fragCoord);\n\t}\n\t\n\tcolor /= float(SAMPLES);\n    \n    vec4 previous = texture(iChannel1, fragCoord / iResolution.xy);\n    // vec4 previous = vec4(0.0);\n\n\tfragColor = vec4( color + previous.rgb, previous.a + 1.0 );\n}","name":"Buffer A","description":"","type":"buffer"}]}