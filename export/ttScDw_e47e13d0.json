{"ver":"0.1","info":{"id":"ttScDw","date":"1594497975","viewed":114,"name":"Texturing a Quad (kinda)","username":"MarvelousBilly","description":"The title describes it, I do 4 projections onto the edges of *two triangles* from the collision point, take the distances from the projected points and collision point, and do some simple math (line 98) to get the normalized relative position","likes":1,"published":1,"flags":48,"usePreview":0,"tags":["mouse","texture","keyboard","quad"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":0,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 a = vec3(-1., 2., 0.); \nvec3 b = vec3(1., 2., 0.);\nvec3 c = vec3(1., 0., 0.);\nvec3 d = vec3(-1., 0., 0.);\n\nfloat vectorProjection(vec3 A, vec3 B, vec3 C){\n\tvec3 AB = B - A;\n\tvec3 AC = C-A;\n\tvec3 dir = normalize(AB);\n\tfloat dis = dot(AC,dir);\n\tif(dis < 0.){ dis = 0.; }\n\tif(dis > distance(A,B)){ dis = distance(A,B); }\n\treturn distance(A + (dir*dis),C);\n}\n\nfloat dot2( in vec3 v ) { return dot(v,v); }\n\nfloat udTriangle( vec3 p, vec3 a, vec3 b, vec3 c )\n{\n  vec3 ba = b - a; vec3 pa = p - a;\n  vec3 cb = c - b; vec3 pb = p - b;\n  vec3 ac = a - c; vec3 pc = p - c;\n  vec3 nor = cross( ba, ac );\n\n  return sqrt(\n    (sign(dot(cross(ba,nor),pa)) +\n     sign(dot(cross(cb,nor),pb)) +\n     sign(dot(cross(ac,nor),pc))<2.0)\n     ?\n     min( min(\n     dot2(ba*clamp(dot(ba,pa)/dot2(ba),0.0,1.0)-pa),\n     dot2(cb*clamp(dot(cb,pb)/dot2(cb),0.0,1.0)-pb) ),\n     dot2(ac*clamp(dot(ac,pc)/dot2(ac),0.0,1.0)-pc) )\n     :\n     dot(nor,pa)*dot(nor,pa)/dot2(nor) );\n}\n\nfloat udQuad( vec3 p, vec3 a, vec3 b, vec3 c, vec3 d )\n{\n  vec3 ba = b - a; vec3 pa = p - a;\n  vec3 cb = c - b; vec3 pb = p - b;\n  vec3 dc = d - c; vec3 pc = p - c;\n  vec3 ad = a - d; vec3 pd = p - d;\n  vec3 nor = cross( ba, ad );\n\n  return sqrt(\n    (sign(dot(cross(ba,nor),pa)) +\n     sign(dot(cross(cb,nor),pb)) +\n     sign(dot(cross(dc,nor),pc)) +\n     sign(dot(cross(ad,nor),pd))<3.0)\n     ?\n     min( min( min(\n     dot2(ba*clamp(dot(ba,pa)/dot2(ba),0.0,1.0)-pa),\n     dot2(cb*clamp(dot(cb,pb)/dot2(cb),0.0,1.0)-pb) ),\n     dot2(dc*clamp(dot(dc,pc)/dot2(dc),0.0,1.0)-pc) ),\n     dot2(ad*clamp(dot(ad,pd)/dot2(ad),0.0,1.0)-pd) )\n     :\n     dot(nor,pa)*dot(nor,pa)/dot2(nor) );\n}\n\nfloat map(vec3 p){\n\t//return min(udTriangle(p, a, b, c), udTriangle(p,a,c,d));   \n    return udQuad(p, a, b, c,d);\n}\n\n\nvec3 raymarch(vec3 ro, vec3 rd, float minD, float maxD){ //ray from camera to direction (extended into infinity)\n    for(float i = 0.3; i < maxD;){ //i = length of ray\n        vec3 p = ro + i * rd;\n    \tfloat h = map(p); //smallest distance from all objects to point\n    \tif(h < minD){\n\t\t\treturn p; //successfully hit something at point \"point\"\n        }\n        i += h;\n    }\n    return ro;\n} //travel along a ray taking steps only as large as the map function above returns\n\nvec4 texPlane(vec3 p, vec3 ta, vec3 tb, vec3 tc, vec3 td, sampler2D tex){\n\t//recUV the relative position of p to the quad's coordinates.\n    float A = vectorProjection(ta, td, p);\n    float B = vectorProjection(tb, tc, p);\n    float C = vectorProjection(ta, tb, p);\n    float D = vectorProjection(td, tc, p);\n\tvec2 recUV = vec2(A / (A+B), D / (D+C));\n\n\treturn texture(iChannel0, recUV);\n}\n\nmat3 rotmat(vec3 axis, float angle){\n\taxis = normalize(axis);\n\tfloat s = sin(angle);\n\tfloat c = cos(angle);\n\tfloat oc = 1.0 - c;\n\treturn mat3(oc * axis.x * axis.x + c, oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s, \n\toc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s, \n\toc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c);\n} //rotate a matrix\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    a.x *= sin(iTime) +1.2;\n    b.x *= sin(iTime) +1.2;\n    \n\tvec2 uv = fragCoord - (iResolution.xy/2.);\n\tvec2 uv2 = fragCoord / iResolution.xy ;\n    vec2 Mouse = texelFetch(iChannel1, ivec2(2,0), 0).xy; //get the mouse position in pixels to the normalized value from 0 to 1\n    float fovDeg = 70.;\n    float fovDis = (iResolution.y / 2.) / tan(fovDeg/2.);\n    vec3 col = vec3(0.1);\n\tvec3 cam = vec3(0.,0.,-10.);\n    vec3 dir = normalize(rotmat(vec3(0.0, -1.0, 0.0), 3.0 * (Mouse.x * 2.0 - 1.0)) * rotmat(vec3(1.0, 0.0, 0.0), 1.5 * (Mouse.y * 2.0 - 1.0)) * vec3(uv.x,uv.y, fovDis) + cam); //rotate the direction you look\n    cam += vec3(texelFetch(iChannel1, ivec2(0, 0), 0));\n\n    vec3 p = raymarch(cam, dir, 0.0005, 500.);\n    if(p != cam){\n        col = texPlane(p, a, b, c, d, iChannel0).xyz;\n    }\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define key(ascii)   (texelFetch(iChannel1,ivec2(ascii,0),0).x > 0.)\n\nvoid prevMouse(out vec4 fragColor) {//mouse position\n    vec4 v = vec4(iMouse.xy/iChannelResolution[0].xy,1.,0.);  //normalized mouse position\n    fragColor = v; //update value stored (mouse position normalized)\n}\n\nvoid initPos(out vec4 fragColor){\n\tvec4 val = vec4(0.,1.,7.,1.); //set the inital position when starting script\n    fragColor = val;\n}\n\nvoid initVal(out vec4 fragColor){\n    vec4 val = vec4(0.5,0.5,0.,0.); //set the inital mouse position when starting script\n    fragColor = val;\n}\n\nvoid deltaMouse(out vec4 fragColor) {\n    vec4 val = texelFetch(iChannel0, ivec2(2,0), 0);\n    //grab current delta mouse position\n    vec4 oldMouse = texelFetch(iChannel0, ivec2(1,0), 0);\n    //grab previous mouse position (last frame)\n    if(iMouse.z > 0.5 && val.w >= 0.5){ //if mouse was not pressed on prev frame, do not update delta\n        //this means it only changes when the mouse is down and does not jump position.\n        vec2 deltaM = (iMouse.xy/iChannelResolution[0].xy)-oldMouse.xy;\n        //set delta to be the change in mouse positions between frames\n    \tval.xy+=deltaM;\n        //add the delta to val\n    }\n    if(val.x >= 1.){\n    \tval.x = 0.;   \n    }\n    if(val.y >= 1.){\n    \tval.y = 0.;   \n    } //allows for full rotations\n    val.w = iMouse.z; //update click state\n    fragColor = val;\n}\n\nmat3 rotmat(vec3 axis, float angle){\n\taxis = normalize(axis);\n\tfloat s = sin(angle);\n\tfloat c = cos(angle);\n\tfloat oc = 1.0 - c;\n\treturn mat3(oc * axis.x * axis.x + c, oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s, \n\toc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s, \n\toc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c);\n} //rotate a matrix\n\nvoid position(out vec4 fragColor){ //allows for movement\n    vec4 val = texelFetch(iChannel0, ivec2(0, 0), 0); //res is the middle of the screen??\n    \n    vec2 Mouse = texelFetch(iChannel0, ivec2(0, 0)+ivec2(2,0), 0).xy;\n    mat3 dir = rotmat(vec3(0.0, -1.0, 0.0), 3.0 * (Mouse.x * 2.0 - 1.0)) * rotmat(vec3(1.0, 0.0, 0.0), 1.5 * (Mouse.y * 2.0 - 1.0));\n    \n    float speed = 0.1; //units per frame\n    if(key(16)){\n    \tspeed*=2.; //if press shift, go faster\n    }\n    if(key(87)){\n    \tval.xyz+=dir[2]*speed; //forward/back\n    }\n    if(key(83)){\n    \tval.xyz-=dir[2]*speed;\n    }\n    if(key(68)){\n    \tval.xyz+=dir[0]*speed; //left/right strafing   \n    }\n    if(key(65)){\n    \tval.xyz-=dir[0]*speed;   \n    }\n\n \tfragColor = val; \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    if(iFrame == 0){\n        if (ivec2(fragCoord.xy) == ivec2(0, 0)) {\n            initPos(fragColor); //set inital position\n        }\n        if (ivec2(fragCoord.xy) == ivec2(2, 0)){\n    \t\tinitVal(fragColor); //set inital view direction\n        }\n    }\n    else{\n        if (ivec2(fragCoord.xy) == ivec2(0, 0)) {\n            position(fragColor); //update position\n        }\n        if (ivec2(fragCoord.xy) == ivec2(1, 0)) {\n            prevMouse(fragColor); //update mouse position\n        }\n        if (ivec2(fragCoord.xy) == ivec2(2, 0)) {\n            deltaMouse(fragColor);\n        }\n    }\n}","name":"Buffer A","description":"","type":"buffer"}]}