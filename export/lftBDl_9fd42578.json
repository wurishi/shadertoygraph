{"ver":"0.1","info":{"id":"lftBDl","date":"1733656796","viewed":122,"name":"Free Group","username":"katayu","description":"The Cayley graph of the free group F_2 embedded in the Poincar√©'s disk.","likes":4,"published":3,"flags":0,"usePreview":0,"tags":["fractal","hyperbolic","cantor","free"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Improved version with better antialiasing and performance\n\nconst float PI = 3.14159265359;\nconst vec3 COLOR1 = vec3(0.12, 0.47, 0.71);  // Blue\nconst vec3 COLOR2 = vec3(1.0, 0.5, 0.05);    // Orange\nconst int MAX_DEPTH = 10;\nconst int BASE_DEPTH = 5;\n\nconst float SCALE = 2.0;\nconst float WIDTH = 0.008;\n\n/*\nFns for transform\n*/\n\n\nfloat wave(float iTime){\n    // wave function controlling transform\n    float s = (cos(iTime * 0.5)+1.0);\n    return SCALE*pow(s,2.0);\n    \n}\nfloat zoom(float iTime){\n    return (1.0+wave(iTime));    \n}\n\n\nmat2 rotate2d(float angle) {\n    float s = sin(angle);\n    float c = cos(angle);\n    return mat2(c, -s, s, c);\n}\n\n\nvec2 transform(vec2 uv) {    \n    // Rotation\n    //float angle = iTime * 0.25;\n    float angle = 0.0;\n    mat2 rot = rotate2d(angle);\n    //vec2 target = vec2(1.0, 0.0);\n    vec2 target = vec2(cos(-0.75*PI), sin(-0.75*PI));\n    \n    // Apply transformations\n    uv = rot * ((uv + wave(iTime)*target) / zoom(iTime));\n    \n    return uv;\n}\n\n/*\n\nDrawing Args\n*/\n\n\nvec2 normal(vec2 A) {\n    return vec2(A.y, -A.x);\n}\n\nvec3 getOrthogonalCircle(vec2 A, vec2 B) {\n    vec2 N = normal(A);\n    float t = (1.0 - dot(A, B)) / dot(B, N);\n    vec2 center = A + t * N;\n    return vec3(center, abs(t));\n}\n\n// Modified to return a smooth distance rather than a bool\nfloat getArcDistance(vec2 point, vec2 center, vec2 A, vec2 B) {\n    vec2 toPoint = point - center;\n    float angle = atan(toPoint.y, toPoint.x);\n    float startAngle = atan(A.y - center.y, A.x - center.x);\n    float endAngle = atan(B.y - center.y, B.x - center.x);\n    \n    vec2 centerToA = A - center;\n    vec2 centerToB = B - center;\n    bool reverseArc = (centerToA.x * centerToB.y - centerToA.y * centerToB.x) < 0.0;\n    \n    if (reverseArc) {\n        float temp = startAngle;\n        startAngle = endAngle;\n        endAngle = temp;\n    }\n    \n    if (endAngle < startAngle) endAngle += 2.0 * PI;\n    if (angle < startAngle) angle += 2.0 * PI;\n    \n    // Calculate angular distance to arc edges\n    float angDist = min(abs(angle - startAngle), abs(angle - endAngle));\n    if (angle >= startAngle && angle <= endAngle) {\n        angDist = 0.0;\n    }\n    \n    return angDist;\n}\n\n\nfloat drawArc(vec2 uv, vec2 A, vec2 B, float depth) {\n    vec3 circle = getOrthogonalCircle(A, B);\n    vec2 center = circle.xy;\n    float radius = circle.z;\n    \n    // Calculate radial distance\n    float radialDist = abs(length(uv - center) - radius);\n    \n    // Calculate angular distance\n    float angularDist = getArcDistance(uv, center, A, B);\n    \n    // Combine distances for smooth edge\n    float dist = max(radialDist, angularDist * radius);\n\n    \n    // Pixel-width dependent smoothing\n    //float pixelWidth=0.0;\n    //float pixelWidth = 1.0 / min(iResolution.x, iResolution.y);\n    float lineWidth = WIDTH / (1.0 + depth * 0.2)/zoom(iTime);\n    return smoothstep(  lineWidth,0.0, dist);\n}\n\n\n\n\n\n// Optimized function to check if an arc might be visible\n/*\nbool isArcVisible(vec2 A, vec2 B, vec2 viewCenter, float viewRadius) {\n    vec3 circle = getOrthogonalCircle(A, B);\n    vec2 center = circle.xy;\n    float radius = circle.z;\n    \n    // Simple visibility test based on distance to view center\n    float dist = length(center - viewCenter);\n    return dist <= viewRadius + radius;\n}\n*/\n\nfloat drawLine(vec2 uv, vec2 start, vec2 end, float width) {\n    vec2 dir = end - start;\n    vec2 perp = normalize(vec2(-dir.y, dir.x));\n    vec2 pos = uv - start;\n    float proj = dot(pos, dir) / dot(dir, dir);\n    float dist = abs(dot(pos, perp));\n    \n    float pixelWidth = 1.0 / min(iResolution.x, iResolution.y);\n    return proj >= 0.0 && proj <= 1.0 ? \n           smoothstep(width, 0.0, dist) : \n           0.0;\n}\n\n\n\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n    vec2 transformed_uv = transform(uv);\n    //vec2 transformed_uv = uv;\n    \n    // Calculate view bounds for culling\n    float viewRadius = 1.1;  // Slightly larger than unit circle\n    vec2 viewCenter = vec2(0.0);\n    \n    vec3 color = vec3(1.0);\n    \n    float linewidth = WIDTH/zoom(iTime);\n    \n    // Draw coordinate axes with transformed coordinates\n    float horizontalLine = drawLine(transformed_uv, vec2(cos(PI/4.0), sin(PI/4.0)), vec2(cos(PI/4.0+PI), sin(PI/4.0+PI)) , linewidth);\n    float verticalLine = drawLine(transformed_uv, vec2(cos(-PI/4.0), sin(-PI/4.0)), vec2(cos(-PI/4.0-PI), sin(-PI/4.0-PI)), linewidth);\n    color = mix(color, COLOR2, horizontalLine);\n    color = mix(color, COLOR1, verticalLine);\n    \n    //int max_depth = int(float(MAX_DEPTH)*(sin(iTime*0.5)+1.0)*0.5)+2;\n    //max_depth = min(MAX_DEPTH, max_depth);\n    int max_depth = int(round(float(BASE_DEPTH)*zoom(iTime)));\n    \n    max_depth  = min(max_depth, MAX_DEPTH);\n\n    vec2 toPoint = transformed_uv - viewCenter;\n    float angle_uv = atan(toPoint.y, toPoint.x);\n\n\n    /* ***************\n    Draw depth levels \n    ***************** */\n    // The case of depth = 0\n    // normalize angle as 0 < eta < 4\n    float eta = 2.0*(angle_uv + PI )/ PI;\n    float n = floor(eta);\n    float m = 2.0;\n    float diff = PI / (3.0 * m);\n    float baseAngle = float(n)*PI/2.0 - PI + PI/4.0;\n    \n    vec2 A = vec2(cos(baseAngle - diff), sin(baseAngle - diff));\n    vec2 B = vec2(cos(baseAngle + diff), sin(baseAngle + diff));\n    int depth = 0;\n    float arc = drawArc(transformed_uv, A, B, float(depth));\n\n    float colorIdx = mod(float(n),2.0);\n    vec3 arcColor =  (colorIdx == 0.0) ? COLOR1 : COLOR2;\n    color = mix(color, arcColor, arc);\n\n    // The cases of depth > 0\n    for (int depth = 1; depth < max_depth; depth++) {\n        // Ternary expansion\n        // We can detemine unique n (= The index of the hittable arc in the level) \n        eta = (eta-n)*3.0;\n        n = floor(eta);        \n        m *= 3.0;\n        diff = PI / (3.0 * m);\n        \n        baseAngle = baseAngle + (float(n)-1.0)*PI/m;\n        A = vec2(cos(baseAngle - diff), sin(baseAngle - diff));\n        B = vec2(cos(baseAngle + diff), sin(baseAngle + diff));\n        arc = drawArc(transformed_uv, A, B, float(depth));\n        \n        // Flip arcColor based on parent's color    \n        colorIdx = mod(float(n)+1.0-colorIdx, 2.0);\n        arcColor = (colorIdx == 0.0) ? COLOR1 : COLOR2;        \n        color = mix(color, arcColor, arc);\n        \n    }\n    \n    //float unitCircle = smoothstep(0.005, 0.0, abs(length(transformed_uv) - 1.0));\n    //color = mix(color, vec3(0.0), unitCircle);\n    \n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}