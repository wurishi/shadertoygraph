{"ver":"0.1","info":{"id":"XtdXR4","date":"1478451403","viewed":230,"name":"IFS experimenting","username":"deadmanswitch","description":"Experimenting","likes":11,"published":1,"flags":0,"usePreview":0,"tags":["fractal","experiment","ifs"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// tetrahedron: https://www.shadertoy.com/view/ltVGzy\n\n#define FOV 60.0\n\n#define MAX_STEP   48\n#define MAX_STEP_F 48.0\n\n// constants\nconst float infinity = 1.0/0.000000001;\nconst float PI = asin(1.0)*2.0;\n\n\n// min/max vec\nfloat max4(in vec4 v4) {\n    return max( max(v4.x, v4.y), max(v4.z, v4.w) );\n}\n\nfloat min4(in vec4 v4) {\n    return min( min(v4.x, v4.y), min(v4.z, v4.w) );\n}\n\n// rotations\nvec3 rotateX(in vec3 vec, in float rad) {\n    \n    return vec3(\n        vec[0],\n        vec[1]*cos(rad) - vec[2]*sin(rad),\n        vec[1]*sin(rad) + vec[2]*cos(rad)\n    );\n        \n}\n\nvec3 rotateY(in vec3 vec, in float rad) {\n    \n    return vec3(\n        vec[2]*sin(rad) + vec[0]*cos(rad),\n        vec[1],\n        vec[2]*cos(rad) - vec[0]*sin(rad)\n    );\n}\n\nvec3 rotateZ(in vec3 vec, in float rad) {\n    \n    return vec3(\n        vec[0]*cos(rad) - vec[1]*sin(rad),\n        vec[0]*sin(rad) + vec[1]*cos(rad),\n        vec[2]\n    );\n}\n\n// return the vector closest to `p`\nvec3 closestTo(in vec3 p, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n    \n    vec4 ll = vec4(\n    \tdistance(a,p),\n        distance(b,p),\n        distance(c,p),\n        distance(d,p)\n    );\n    \n    float sh = min4(ll);\n    \n    vec4 eq = vec4(notEqual(ll, vec4(sh)));\n    \n    return mix(a, mix( b, mix(c, d, eq.z ), eq.y ), eq.x );\n    \n}\n\n// points\nconst vec3 point0 = vec3( 0.0,                 1.0,                 0.0);\nconst vec3 point1 = vec3( 0.9428090453147888, -0.3333333432674408,  0.0);\nconst vec3 point2 = vec3(-0.4714045226573944, -0.3333333432674408, -0.8164966106414795);\nconst vec3 point3 = vec3(-0.4714045226573944, -0.3333333432674408,  0.8164966106414795);\n\nconst mat2 foldb = mat2(0.7071067690849304, -0.7071067690849304, 0.7071067690849304, 0.7071067690849304);\nconst mat2 foldi = mat2(0.7071067690849304, 0.7071067690849304, -0.7071067690849304, 0.7071067690849304);\n\nvoid fold(inout vec2 vec) {\n    vec = (abs(vec*foldb))*foldi;\n}\n\n// the distance estimator function\nconst int STEPS = 16;\nfloat DE(in vec3 pos) {\n    \n    // rotation\n    float rot = (iTime*0.25*0.25)*PI*2.0;\n    pos = rotateY(pos, rot);\n    \n    // steps\n    vec3 p = pos;\n    for(int i=0; i<STEPS; i++) {\n        \n        fold(p.xy);\n        p = rotateY(p,  0.2+cos(iTime)*0.1);\n        fold(pos.xz);\n        p = rotateZ(p, -0.6-cos(iTime)*0.1);\n        \n        // scale the current point, and find the closest point vertex\n        p *= 2.0;\n        p = p-closestTo(p, point0, point1, point2, point3);\n        \n    }\n    \n    // calculate the distance to the last found tetrahedron ( for STEPS=0 -> tet(pos, 1.0) )\n    return length(p)/exp2(float(STEPS));\n    \n}\n\nconst vec3 shadowColor = vec3(0.05, 0.0, 0.05);\nconst vec3 backColor = vec3(0.2, 0.2, 0.5);\nconst vec3 tetColor = vec3(0.2, 0.75, 0.25);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    // camera\n\tvec2 view = fragCoord.xy / iResolution.xy * 2.0 - 1.0;\n    \n    float aspect = iResolution.x/iResolution.y;\n    float a = tan(FOV * (PI/180.0) / 2.0);\n    vec2 ab = vec2(a * aspect, a);\n    \n    // the start point, and the direction of the ray\n    vec3 dir = normalize(vec3(ab*view, -1.0));\n    vec3 point = vec3(0.0, 0.0, 1.2+sin(iTime*0.25)*0.5);\n    \n    // ray-march\n    float closest = infinity;\n\n    for(int i = 0; i<MAX_STEP; i++) {\n\n        vec3 pos = point;\n\n        float dist = DE(pos);\n\n        if(dist < 0.001) {\n            fragColor = vec4(mix(\n                tetColor,\n                shadowColor,\n                sqrt(float(i)/MAX_STEP_F)\n            ), 1.0);\n            return;\n        }\n\n        closest = min(closest, dist);\n\t\t\n        // cannot take a full step :( ( *0.75 )\n        point += dir*dist*0.75;\n\n    }\n\n    fragColor = vec4(mix(\n        shadowColor,\n        backColor,\n        sqrt(clamp(closest/0.5, 0.0, 1.0))\n    ), 1.0);\n    \n}","name":"Image","description":"","type":"image"}]}