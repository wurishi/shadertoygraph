{"ver":"0.1","info":{"id":"4ssBR2","date":"1497022145","viewed":120,"name":"MadWall","username":"c0de4","description":"ABAREKABE.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n\n// thanks to: @h_doxas https://wgld.org/\n//\n// rotate, twist, smoothMin, distance func, ray marching\n\n\n// thanks to: Inigo Quilez https://iquilezles.org/\n// \n// noise\n\n// wrote: @c0de4 \n\nvec3 hsv(float h, float s, float v){\n  vec4 t = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(vec3(h) + t.xyz) * 6.0 - vec3(t.w));\n  return v * mix(vec3(t.x), clamp(p - vec3(t.x), 0.0, 1.0), s);\n}\n\nconst vec3 lightDir = vec3(0.577, 0.577, 0.577);\n\nvec3 rotate(vec3 p, float angle, vec3 axis){\n    vec3 a = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float r = 1.0 - c;\n    mat3 m = mat3(\n        a.x * a.x + a.x * r + c,\n        a.y * a.x * r - a.z * s,\n        a.z * a.x * r - a.y * s,\n        a.x * a.y * r + a.z * s,\n        a.y * a.y * r + c,\n        a.z * a.y * r + a.x * s,\n        a.x * a.z * r + a.y * s,\n        a.y * a.z * r - a.x * s,\n        a.z * a.z * r + c\n    );\n    return m * p;\n}\n\nvec3 twistX(vec3 p, float power){\n    float s = sin(power * p.y);\n    float c = cos(power * p.y);\n    mat3 m = mat3(\n        1.0, 0.0, 0.0,\n        0.0, c, s,\n        0.0, -s,   c\n    );\n    return m * p;\n}\n\nvec3 twistY(vec3 p, float power){\n    float s = sin(power * p.y);\n    float c = cos(power * p.y);\n    mat3 m = mat3(\n          c, 0.0,  -s,\n        0.0, 1.0, 0.0,\n          s, 0.0,   c\n    );\n    return m * p;\n}\n\n\nfloat random (in vec2 st) { \n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233))) \n                * 43758.5453123);\n}\n\n// The MIT License\n// Copyright Â© 2013 Inigo Quilez\nfloat noise( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n    \n    vec2 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( random( i + vec2(0.0,0.0) ), \n                     random( i + vec2(1.0,0.0) ), u.x),\n                mix( random( i + vec2(0.0,1.0) ), \n                     random( i + vec2(1.0,1.0) ), u.x), u.y);\n}\n\n// smoothing min\nfloat smoothMin(float d1, float d2, float k){\n    float h = exp(-k * d1) + exp(-k * d2 * d1);\n    return -log(h) / k;\n}\n\n// torus\nfloat torus(vec3 p, vec2 r){\n    float a = -.3 * cos(iTime + p.z * p.y * p.x) * noise(vec2(p.xz+iTime));\n    vec2 d = vec2(length(p.xy) + a + noise(vec2(a, iTime)) - r.x, p.z);\n    return length(d * p.z) - r.x + noise(vec2(r.x+iTime*.1));\n}\n\n// sphere\nfloat sphere( vec3 p, float r )\n{\n  return length(mod(p, .1))-r;\n}\n\nfloat box( vec3 p )\n{\n  return length(max(abs(p)-vec3(1.),0.0));\n}\n\n// distance function\nfloat distFunc(vec3 p){\n  float a = cos(iTime + noise(vec2(p.z, iTime))) + sin(iTime + p.z);\n  float b = sin(iTime - p.x) + noise(vec2(iTime));\n  \n    vec3 q = rotate(twistX(twistX(p+b, 1.2 + cos(iTime)), 1.1 + sin(iTime)), radians(iTime * 100.), vec3(1.0, 0., 0.));\n\n    float d1 = torus(p+q*.2, vec2(.6, .1));\n    float d2 = sphere(p + q*-.1*cos(iTime), 1.);\n    float c = smoothMin(d1, d2+noise(vec2(d1)), 16.);\n    return c + sqrt(mod(c - mod(c - d2 * noise(vec2(iTime*.1)*.1), 4.) * .1, 2.) * .1);\n\n}\n\nvec3 genNormal(vec3 p){\n    float d = 0.1;\n    return normalize(vec3(\n        distFunc(p + vec3(  d, 0.0, 0.0)) - distFunc(p + vec3( -d, 0.0, 0.0)),\n        distFunc(p + vec3(0.0,   d, 0.0)) - distFunc(p + vec3(0.0,  -d, 0.0)),\n        distFunc(p + vec3(0.0, 0.0,   d)) - distFunc(p + vec3(0.0, 0.0,  -d))\n    ));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // fragment position\n    vec2 p = (gl_FragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n    \n    // camera and ray\n    vec3 cPos = vec3(0., 0., -1.8);\n    vec3 cDir = vec3(cos(iTime*.5)*.5 - .5, sin(iTime*.5)*.5, -1. + cos(iTime*.5)*.5);\n    vec3 cUp  = vec3(0.0, 1.0, 0.0);\n    vec3 cSide = cross(cDir, cUp);\n    float targetDepth = 1.1;\n    vec3 ray = normalize(cSide * p.x + cUp * p.y + cDir * targetDepth);\n    \n    // marching loop\n    float tmp, dist;\n    tmp = 0.0;\n    vec3 dPos = cPos;\n    for(int i = 0; i < 16; i++){\n        dist = distFunc(dPos);\n        tmp += dist;\n        dPos = cPos - cos(iTime*.1)*.4 + tmp * ray * .75;\n    }\n    \n    // hit check\n    vec3 color;\n    if(abs(dist) < .1){\n        vec3 normal = genNormal(dPos);\n        float diff = clamp(dot(lightDir, normal), 0.1, 1.0);\n        color = vec3(cos(iTime)*.5, .5+sin(iTime*.2)*.2, .8) * hsv(diff*.5, .2, 1.);\n    }else{\n        color = vec3(0.0);\n    }\n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}