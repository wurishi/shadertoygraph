{"ver":"0.1","info":{"id":"Xf33D7","date":"1711762832","viewed":191,"name":"FM Polyrhythm","username":"MrHAX00","description":"Got bored and kept coming across polyrhythm videos on youtube and couldn't resist the urge to make something myself!","likes":12,"published":1,"flags":8,"usePreview":0,"tags":["fm","fmsynthesis","polyrhythm"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xsf3Rr","filepath":"/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","previewfilepath":"/media/ap/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float BiSmoothStep(float Center, float Distance, float UpperBlur, float LowerBlur, float Value)\n{\n    float Sum = smoothstep(Center - Distance - LowerBlur, Center - Distance, Value);\n    Sum *= smoothstep(Center + Distance + UpperBlur, Center + Distance, Value);\n    \n    return Sum;\n}\n\nconst float NoteSize = 1. / NoteCount;\nfloat SliderSDF(vec2 Point, float NoteSlider, float NoteTime)\n{\n    float NoteLowerBlur = pow(1. - NoteTime, 7.) * .2;\n    float NoteUpperBlur = pow(NoteTime, 7.) * .2;\n    \n    vec2 MinVec = vec2(-NoteSize * NoteSpacing, NoteSlider -.5 + NoteSize * NoteRoundness - NoteLowerBlur);\n    vec2 MaxVec = vec2(NoteSize * NoteSpacing, NoteSlider -.5 - NoteSize * NoteRoundness + .1 + NoteUpperBlur);\n    \n    Point.x = mod(Point.x, NoteSize) - NoteSize * .5;\n    return length(clamp(Point, MinVec, MaxVec) - Point) - NoteSize * NoteRoundness;\n}\n\nvec4 DrawSliders(vec2 uv)\n{\n    float NoteIndex = NoteCount - floor((uv.x + .5) * NoteCount) - 1.;\n    float NoteSpan = 5. + NoteIndex * NoteSpanDelta;\n    float NoteTime = fract((iTime + LoopOffset * 180.) / NoteSpan);\n    \n    float NoteSlider = pow(1. - (cos(NoteTime * pi * 2.) * .5 + .5), .375) * .9;\n    \n    float Note = SliderSDF(uv, NoteSlider, NoteTime);\n    float NoteColor = smoothstep(max(pow(1. - NoteTime, 30.) * .05, .001), 0., Note);\n    NoteColor *= smoothstep(NoteSlider -.5 + NoteSize * NoteRoundness + .2, NoteSlider -.5 + NoteSize * NoteRoundness + .1, uv.y);\n    NoteColor *= smoothstep(NoteSlider -.5 + NoteSize * NoteRoundness - .1, NoteSlider -.5 + NoteSize * NoteRoundness, uv.y);\n    \n    return vec4(hash31(NoteIndex + floor((iTime + LoopOffset * 180.) / NoteSpan) * .23) * .8 + .2, NoteColor * .8);\n}\n\nvec3 DrawBG(vec2 uv)\n{\n    float NoteIndex = NoteCount - floor((uv.x + .5) * NoteCount) - 1.;\n    float NoteSpan = 5. + NoteIndex * NoteSpanDelta;\n    float NoteTime = fract((iTime + LoopOffset * 180.) / NoteSpan);\n    \n    float BGMix = BiSmoothStep(.5, pow(1. - NoteTime, 2.) * .35, .001, .001, fract(uv.x * NoteCount));\n    BGMix += BiSmoothStep(.5, .05 - NoteTime, .5, .5, fract(uv.x * NoteCount) - cos(uv.y * pi * 10. - iTime * pi) * (.25 - pow(1. - NoteTime, 10.)));\n    \n    vec3 BGRowColor = hash31(NoteIndex + floor((iTime + LoopOffset * 180.) / NoteSpan) * .23);\n    vec3 BG = mix(BGRowColor * .1 + pow(1. - NoteTime, 15.), BGRowColor * .3 + pow(1. - NoteTime, 3.), BGMix);\n    float BGTransparency = pow(1. - NoteTime, 10.) * pow(.5 - uv.y, pow(1. - NoteTime, 80.) * 15.);\n    BG = mix(texelFetch(iChannel0, ivec2(abs(uv * 4.) * 512.), 0).xyz * .08, BG, BGTransparency);\n    \n    return BG;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - iResolution.xy * .5) / iResolution.y;\n    vec4 Sliders = DrawSliders(uv);\n    vec3 BG = DrawBG(uv);\n    \n    vec3 Sum = mix(BG, Sliders.xyz, Sliders.w);\n    \n    Sum = mix(BG * .05 + .1, Sum, BiSmoothStep(0., .5, .0001, .0001, uv.x));\n    fragColor = vec4(Sum, 1.);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define C  16.35\n#define CS 17.32\n#define D  18.35\n#define DS 19.45\n#define E  20.60\n#define F  21.83\n#define FS 23.12\n#define G  24.50\n#define GS 25.96\n#define A  27.50\n#define AS 29.14\n#define B  30.87\n\n#define Octave(Octave) pow(2., Octave)\n\nfloat[] Notes = float[](\n    FS * Octave(1.),\n    GS * Octave(1.),\n    AS * Octave(1.),\n    CS * Octave(2.),\n    \n    FS * Octave(2.),\n    GS * Octave(2.),\n    AS * Octave(2.),\n    CS * Octave(3.),\n    \n    FS * Octave(3.),\n    GS * Octave(3.),\n    AS * Octave(3.),\n    CS * Octave(4.),\n    \n    FS * Octave(4.),\n    GS * Octave(4.),\n    AS * Octave(4.),\n    CS * Octave(5.)\n);\n\nfloat FMInstrument(float Time, float Freq)\n{\n    Time *= pi * 2. * Freq;\n    \n    //1 <- 3 2 <- 4o\n    \n    float FeedbackAmount = max(1. - pow(Time * 2., .3), 0.);\n    \n    float Mod1 = cos(Time * 2.) * pi * .5;\n    float Mod2 = cos(Time + cos(Time) * pi * .5 * FeedbackAmount) * pi * .5;\n    \n    float Carrier1 = cos(Time * 2. + Mod1);\n    float Carrier2 = cos(Time * 2.0075 + Mod2);\n    \n    return (Carrier1 + Carrier2) * .3;\n}\n\nvec2 mainSound( int samp, float time )\n{\n    time += LoopOffset * 180.;\n    \n    float Sum = 0.;\n    for (int i = 0; i < Notes.length(); i++) {\n        float NoteSpan = 5. + float(i) * NoteSpanDelta;\n        float NoteTime = mod(time, NoteSpan);\n        \n        float Note = FMInstrument(NoteTime, Notes[i]);\n        Note *= max(1. - pow(NoteTime / NoteSpan, .3), 0.);\n        \n        Sum += Note;\n    }\n    \n    return vec2(Sum / float(Notes.length()));\n}","name":"Sound","description":"","type":"sound"},{"inputs":[],"outputs":[],"code":"#define pi 3.14159\n\n#define NoteSpanDelta .025\n// use this to go past 180 seconds\n#define LoopOffset 0.\n\n// used for visualising only\n#define NoteCount 16.\n#define NoteRoundness .2\n#define NoteSpacing .1\n\n// from https://www.shadertoy.com/view/4djSRW\nvec3 hash31(float p)\n{\n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}","name":"Common","description":"","type":"common"}]}