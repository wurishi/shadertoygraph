{"ver":"0.1","info":{"id":"7sfXz4","date":"1618658600","viewed":111,"name":"ray tracing cube","username":"vsha96","description":"Basic ray tracing for task 2 in the course MSU_CMC_CG2021\n\nin BufferA, you can change CAMERA_POS\n\nhere is a glass cube interspersed with mirror and diamond spheres","likes":3,"published":1,"flags":32,"usePreview":0,"tags":["raytracing","reflection","ray","refraction","cube","sphere","plane","ambientocclusion","cylinder","trace","cmc","msu"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Output to screen\n    fragColor = texture(iChannel0, uv) / float(iFrame + 1);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dX3Rn","filepath":"/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg","previewfilepath":"/media/ap/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//\n// @vsha96\n// https://github.com/vsha96\n//\n\n//\n// constants\n//\n\nconst vec3 CAMERA_POS = vec3(0.5, 1.2, -6);\n//const vec3 CAMERA_POS = vec3(-2, 0.8, -5); // good pos\n//const vec3 CAMERA_POS = vec3(-2, 2.4, -3); // another good pos\n//const vec3 CAMERA_POS = vec3(-4, 0.8, -10);\n\nconst int MAX_REFLECTIONS = 20; // affects the render time\n\nconst float NOISE_FACTOR = 1e-5; // to remove anomalies when reflect\nconst float INF = 1e10;\n\n// material type\nconst int EMISSION = 0;\nconst int DIFFUSION = 1;\nconst int REFLECTION = 2;\nconst int REFRACTION = 3;\n\nconst float AIR_N = 1.0;\nconst float GLASS_N = 1.5;\nconst float DIAMOND_N = 2.5;\nfloat GLASS_R = (AIR_N - GLASS_N)*(AIR_N - GLASS_N)/(AIR_N + GLASS_N)/(AIR_N + GLASS_N);\nfloat DIAMOND_R = (DIAMOND_N - GLASS_N)*(DIAMOND_N - GLASS_N)/(DIAMOND_N + GLASS_N)/(DIAMOND_N + GLASS_N);\n\nvec3 randDir; // random vector for soft shadows\n\n//\n// objects\n//\n\nstruct sphere {\n    vec3 pos;\n    float radius;\n    vec3 color;\n    int material;\n    float n; // factor of refraction\n};\n\nstruct cube {\n    vec3 pos;\n    float size;\n    vec3 color;\n    int material;\n    float n; // factor of refraction\n};\n\nconst sphere LIGHT1 = sphere(vec3(-3, 0.5, 5), 0.5, vec3(1, 1, 1), EMISSION, GLASS_N);\nconst sphere LIGHT2 = sphere(vec3(1, 0.5, -2), 0.25, vec3(0.5, 0.2, 1)*1.5, EMISSION, GLASS_N);\n\nconst cube CUBE1 = cube(vec3(0, 0, 0), 1.0, vec3(1), REFRACTION, GLASS_N);\n\n// spheres inside CUBE1\nconst float SPH_Daxis = 0.3;\n\nconst sphere SPH1 = sphere(vec3(SPH_Daxis, -SPH_Daxis, -SPH_Daxis), 0.07, vec3(0), REFRACTION, DIAMOND_N);\nconst sphere SPH2 = sphere(vec3(-SPH_Daxis, SPH_Daxis, -SPH_Daxis), 0.07, vec3(0), REFRACTION, DIAMOND_N);\nconst sphere SPH3 = sphere(vec3(SPH_Daxis, SPH_Daxis, SPH_Daxis), 0.07, vec3(0), REFRACTION, DIAMOND_N);\n                                \nconst sphere SPH4 = sphere(vec3(-SPH_Daxis, -SPH_Daxis, -SPH_Daxis), 0.07, vec3(0), REFLECTION, 0.0);\nconst sphere SPH5 = sphere(vec3(SPH_Daxis, SPH_Daxis, -SPH_Daxis), 0.07, vec3(0), REFLECTION, 0.0);\nconst sphere SPH6 = sphere(vec3(SPH_Daxis, -SPH_Daxis, SPH_Daxis), 0.07, vec3(0), REFLECTION, 0.0);\nconst sphere SPH7 = sphere(vec3(-SPH_Daxis, SPH_Daxis, SPH_Daxis), 0.07, vec3(0), REFLECTION, 0.0);\nconst sphere SPH8 = sphere(vec3(-SPH_Daxis, -SPH_Daxis, SPH_Daxis), 0.07, vec3(0), REFLECTION, 0.0);\n\n// cube inside CUBE1 with refraction\n//const cube CUBE2 = cube(vec3(0, 0, 0), 0.3, vec3(1), REFRACTION, DIAMOND_N);\n\n// refractive sphere inside CUBE1\nconst sphere rSPH = sphere(vec3(0), 0.3, vec3(0), REFRACTION, DIAMOND_N);\n\n// ===================\n// ==== FUNCTIONS ====\n// ===================\n\n//\n// trace an object\n//\n\n// fixed horizontal plane (actually it is circle due the second condition inside)\nfloat tracePlane(vec3 pos, vec3 dir, out vec3 normal) {\n    float planeY = -0.8;\n    \n    float t = (planeY - pos.y) / dir.y;\n    if (t <= 0.0)\n        return INF;\n    \n    vec3 worldPos = t * dir + pos;\n    if (dot(worldPos.xz, worldPos.xz) >= 60.0)\n        return INF;\n       \n    normal = vec3(0, 1, 0);\n    return t;\n}\n\nfloat traceCylinder(vec3 pos, vec3 dir, out vec3 normal) {\n    float planeY = -0.5;\n    float radius = 0.5;\n    \n    float t = (planeY - pos.y) / dir.y;\n    if (t <= 0.0) {\n        return INF;\n    }\n    vec3 worldPos = t * dir + pos;\n    if (dot(worldPos.xz, worldPos.xz) < radius) {\n        normal = vec3(0, 1, 0);\n        return t;\n    }\n    \n    float a = dot(dir.xz, dir.xz);\n    float b = dot(pos.xz, dir.xz);\n    float c = dot(pos.xz, pos.xz) - radius;\n    float D = b * b - a * c;\n    if (D < 0.0) {\n        return INF;\n    }\n    t = (-b - sqrt(D)) / a;\n    if (t > 0.0) {\n        worldPos = t * dir + pos;\n        if (worldPos.y <= planeY) {\n            normal = normalize(vec3(worldPos.x, 0, worldPos.z));\n            return t;\n        }\n    }\n    t = (-b + sqrt(D)) / a;\n    if (t < 0.0) {\n        return INF;\n    }\n    worldPos = t * dir + pos;\n    if (worldPos.y <= planeY) {\n        normal = normalize(vec3(worldPos.x, 0, worldPos.z));\n        return t;\n    }\n    return INF;\n}\n\nfloat traceSphere(vec3 pos, vec3 dir, sphere l, out vec3 normal) {\n    float b = dot(pos, dir);\n    float D = b*b - dot(pos, pos) +  l.radius*l.radius;\n    if (D < 0.0)\n        return INF;\n        \n    // near point\n    float t = -b - sqrt(D);\n    if (t > 0.0) {\n        normal = normalize(pos + t*dir);\n        return t;\n    }\n    \n    // far point\n    t = -b + sqrt(D);\n    if (t > 0.0) {\n        normal = normalize(pos + t*dir);\n        return t;\n    }\n    \n    return INF;\n}\n\nfloat traceCube(vec3 pos, vec3 dir, cube c, out vec3 normal) {\n    vec3 m = 1.0/dir;\n    vec3 n = m*(pos);\n    vec3 k = abs(m)*vec3(c.size/2.0);\n\t\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\n\tfloat tN = max( max( t1.x, t1.y ), t1.z );\n\tfloat tF = min( min( t2.x, t2.y ), t2.z );\n\t\n\tif( tN > tF || tF < 0.) return INF;\n    \n    float t = tN < 0.0 ? tF : tN;\n    if (t < INF && t > 0.0) {\n        float dist = t;\n\t\tnormal = -sign(dir)*step(t1.yzx,t1.xyz)*step(t1.zxy,t1.xyz);\n\t    return dist;\n    } else {\n        return INF;\n    }\n}\n\n//\n// support functions for ray\n//\n\nbool isOccluded(vec3 pos, vec3 target) {\n    vec3 dir = target - pos;\n    float dist = length(dir);\n    dir = dir/dist;\n    \n    vec3 tNorm;\n    float cube1T = traceCube(pos, dir, CUBE1, tNorm);\n    if (cube1T < dist)\n        return true;\n        \n    float cylT = traceCylinder(pos, dir, tNorm);\n    return (cylT < dist);\n}\n\nvec3 computeLight(vec3 pos, vec3 color, vec3 normal) {\n    // light sources\n    vec3 toLight1 = LIGHT1.pos - pos;\n    float distSq1 = dot(toLight1, toLight1);\n    float att1 = isOccluded(pos, LIGHT1.pos + randDir*LIGHT1.radius) ? 0.0 : 20.0 / distSq1;\n    vec3 toLight2 = LIGHT2.pos - pos;\n    float distSq2 = dot(toLight2, toLight2);\n    float att2 = isOccluded(pos, LIGHT2.pos + randDir*LIGHT2.radius) ? 0.0 : 10.0 / distSq2;\n    \n    // compute the color\n    return color * (\n        max(0.0, dot(normal, normalize(toLight1))) * att1 * LIGHT1.color\n        + max(0.0, dot(normal, normalize(toLight2))) * att2 * LIGHT2.color\n        + texture(iChannel1, normal).rgb * 0.1\n    );\n}\n\nvec3 refraction(vec3 v, vec3 normal, float n1, float n2) {\n    if (dot(v, normal) < 0.0) {\n        normal = -normal;\n    }\n    float cosA = dot(v, normal);\n    float sinA = sqrt(1.0 - cosA * cosA);\n    vec3 tang = normalize(v - cosA * normal);\n    float sinB = sinA / n2 * n1;\n    float cosB = sqrt(1.0 - sinB * sinB);\n    return sinB * tang + cosB * normal;\n}\n\nfloat rand(float frame)\n{\n    return fract(sin( dot(vec3(frame), vec3(12.9898,78.233,45.5432) )) * 43758.5453);\n}\n\n// ==============\n// ==== MAIN ====\n// ==============\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // random vector for partial reflection and anti-aliasing\n    vec3 randVals = vec3(rand(float(iFrame)), rand(float(iFrame + 5)), rand(float(iFrame + 15)));\n    randDir = normalize(randVals - 0.5);\n    \n    vec2 uv = (fragCoord - iResolution.xy * 0.5 + (randVals.xy - 0.5)*1.0) / iResolution.x;\n    fragColor = vec4(0, 0, 0, 0);\n    \n    // init camera\n    vec3 front = normalize(-CAMERA_POS);\n    vec3 up = vec3(0, 1, 0);\n    vec3 right = normalize(cross(front, up));\n    up = normalize(cross(right, front));\n    float n1 = AIR_N;\n    \n    // viewVector for each pixel\n    vec3 viewVec = normalize(front + right * uv.x + up * uv.y);\n    \n    // needed variables for refraction\n    vec3 curPos = CAMERA_POS;\n    vec3 curDir = viewVec; // direction of ray\n    vec3 colorMult = vec3(1, 1, 1);\n    float nEnter = AIR_N;\n    \n    for (int i=0; i<MAX_REFLECTIONS; i++) {\n        float t = INF;\n        int materialType;\n        vec3 color;\n        vec3 normal;\n        vec3 tNorm;\n        \n        //\n        // trace objects\n        //\n        \n        float planeT = tracePlane(curPos, curDir, tNorm); \n        if (planeT < t) {\n            t = planeT;\n            materialType = DIFFUSION;\n            vec3 worldPos = t * curDir + curPos;\n            color = texture(iChannel0, worldPos.xz * 0.4).rgb;\n            normal = tNorm;\n            if (randVals.y * 1.2 < 0.05) {\n                materialType = REFLECTION;\n            }\n        }\n        \n        float cylT = traceCylinder(curPos, curDir, tNorm); \n        if (cylT < t) {\n            t = cylT;\n            materialType = DIFFUSION;\n            vec3 worldPos = t * curDir + curPos;\n            color = texture(iChannel2, worldPos.xz * worldPos.y).rgb;\n            normal = tNorm;\n        }\n        \n        float light1T = traceSphere(curPos - LIGHT1.pos, curDir, LIGHT1, tNorm);\n        if (light1T < t) {\n            t = light1T;\n            materialType = LIGHT1.material;\n            color = LIGHT1.color;\n            normal = tNorm;\n        }\n        \n        float light2T = traceSphere(curPos - LIGHT2.pos, curDir, LIGHT2, tNorm);\n        if (light2T < t) {\n            t = light2T;\n            materialType = LIGHT2.material;\n            color = LIGHT2.color;\n            normal = tNorm;\n        }\n        \n        // CUBE1\n        float cube1T = traceCube(curPos - CUBE1.pos, curDir, CUBE1, tNorm);\n        if (cube1T < t) {\n            t = cube1T;\n            normal = tNorm;\n            if (randVals.x * 0.3 < GLASS_R) {\n                materialType = REFLECTION;\n            } else {\n                materialType = CUBE1.material;\n                if (materialType == REFRACTION) {\n                    //color = vec3(1, 1, 1);\n                    if (dot(curDir, normal) > 0.0) {\n                        nEnter = AIR_N;\n                    } else {\n                        nEnter = CUBE1.n;\n                    }\n                }\n            }\n            \n        }\n        \n        // refractive CUBE2 inside CUBE1\n        /*\n        float cube2T = traceCube((curPos - CUBE2.pos), curDir, CUBE2, tNorm);\n        if (cube2T < t) {\n            t = cube2T;\n            normal = tNorm;\n            if (randVals.x*0.8 < DIAMOND_R) {\n                materialType = REFLECTION;\n            } else {\n                materialType = CUBE2.material;\n                colorMult *= vec3(1, 0.8, 0.85);\n                if (dot(curDir, normal) > 0.0) {\n                    nEnter = CUBE1.n; // it is inside the cube\n                } else {\n                    nEnter = CUBE2.n;\n                }\n            }\n        }\n        */\n        \n        // refractive sphere inside CUBE1\n        float sphT = traceSphere(curPos - rSPH.pos, curDir, rSPH, tNorm);\n        if (sphT < t) {\n            t = sphT;\n            normal = tNorm;\n            if (randVals.x*0.8 < DIAMOND_R) {\n                materialType = REFLECTION;\n            } else {\n                materialType = rSPH.material;\n                colorMult *= vec3(0.75, 0.75, 1);\n                if (dot(curDir, normal) > 0.0) {\n                    nEnter = CUBE1.n; // it is inside the cube1\n                } else {\n                    nEnter = rSPH.n;\n                }\n            }\n        }\n        \n        // spheres inside CUBE1\n        \n        float sph1T = traceSphere(curPos - SPH1.pos, curDir, SPH1, tNorm);\n        if (sph1T < t) {\n            t = sph1T;\n            normal = tNorm;\n            if (randVals.x*0.8 < DIAMOND_R) {\n                materialType = REFLECTION;\n            } else {\n                materialType = SPH1.material;\n                colorMult *= vec3(1, 0.75, 0.75);\n                if (dot(curDir, normal) > 0.0) {\n                    nEnter = CUBE1.n; // it is inside the cube1\n                } else {\n                    nEnter = SPH1.n;\n                }\n            }\n        }\n        \n        float sph2T = traceSphere(curPos - SPH2.pos, curDir, SPH2, tNorm);\n        if (sph2T < t) {\n            t = sph2T;\n            normal = tNorm;\n            if (randVals.x*0.8 < DIAMOND_R) {\n                materialType = REFLECTION;\n            } else {\n                materialType = SPH2.material;\n                colorMult *= vec3(0.75, 1, 0.75);\n                if (dot(curDir, normal) > 0.0) {\n                    nEnter = CUBE1.n; // it is inside the cube1\n                } else {\n                    nEnter = SPH2.n;\n                }\n            }\n        }\n        \n        float sph3T = traceSphere(curPos - SPH3.pos, curDir, SPH3, tNorm);\n        if (sph3T < t) {\n            t = sph3T;\n            normal = tNorm;\n            if (randVals.x*0.8 < DIAMOND_R) {\n                materialType = REFLECTION;\n            } else {\n                materialType = SPH3.material;\n                colorMult *= vec3(1, 1, 0.5);\n                if (dot(curDir, normal) > 0.0) {\n                    nEnter = CUBE1.n; // it is inside the cube1\n                } else {\n                    nEnter = SPH3.n;\n                }\n            }\n        }\n        \n        float sph4T = traceSphere(curPos - SPH4.pos, curDir, SPH4, tNorm);\n        if (sph4T < t) {\n            t = sph4T;\n            materialType = SPH4.material;\n            normal = tNorm;\n        }\n        \n        float sph5T = traceSphere(curPos - SPH5.pos, curDir, SPH5, tNorm);\n        if (sph5T < t) {\n            t = sph5T;\n            materialType = SPH5.material;\n            normal = tNorm;\n        }\n        \n        float sph6T = traceSphere(curPos - SPH6.pos, curDir, SPH6, tNorm);\n        if (sph6T < t) {\n            t = sph6T;\n            materialType = SPH6.material;\n            normal = tNorm;\n        }\n        \n        float sph7T = traceSphere(curPos - SPH7.pos, curDir, SPH7, tNorm);\n        if (sph7T < t) {\n            t = sph7T;\n            materialType = SPH7.material;\n            normal = tNorm;\n        }\n        \n        float sph8T = traceSphere(curPos - SPH8.pos, curDir, SPH8, tNorm);\n        if (sph8T < t) {\n            t = sph8T;\n            materialType = SPH8.material;\n            normal = tNorm;\n        }\n        \n        // there is a trace\n        //   fill the pixel with color\n        if (t != INF) {\n            vec3 worldPos = t * curDir + curPos;\n            fragColor = texture(iChannel0, worldPos.xz);\n            if (materialType == EMISSION) {\n                fragColor.rgb = color * colorMult;\n                break;\n            } else if (materialType == DIFFUSION) {\n                fragColor.rgb = computeLight(worldPos, color, normal) * colorMult;\n                break;\n            } else if (materialType == REFLECTION) {\n                curDir = reflect(curDir, normal);\n                curPos = worldPos + curDir * NOISE_FACTOR;\n            } else if (materialType == REFRACTION) {\n                curDir = refraction(curDir, normal, n1, nEnter);\n                curPos = worldPos + curDir * NOISE_FACTOR;\n                // change factors\n                n1 = nEnter;\n                //fragColor.rgb = normal;\n                //break;\n            }\n            \n        } else {\n            fragColor.rgb = texture(iChannel1, curDir).rgb * colorMult;\n        }\n        \n    }\n    \n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    fragColor = texture(iChannel0, uv) + texture(iChannel1, uv);\n}","name":"Buffer B","description":"","type":"buffer"}]}