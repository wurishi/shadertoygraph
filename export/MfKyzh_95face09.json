{"ver":"0.1","info":{"id":"MfKyzh","date":"1731506246","viewed":53,"name":"Here Comes The Sun...","username":"MackFitz","description":"Having fun with line segments & planes to express that I miss the sun. Also tweaking smoothmin/max for some funky effects: the sun's eyes & subtly animated smile","likes":9,"published":1,"flags":0,"usePreview":0,"tags":["interactive","animation","smoothmin","smoothmax","linesegment"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14159265359\n#define RES iResolution\n#define PT iMouse\n#define smin smoothmin\n#define smax smoothmax\n#define wmax weirdmax\n\n// Signed distance function for a 3D line segment\nfloat sdSphere(in vec3 p, in vec3 center, float radius) {\n  return length(p - center) - radius;\n}\n\nfloat sdRay(in vec3 p, in vec3 a) {\n  vec3 b = vec3(0.);\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp(dot(pa, ba) / dot(ba, ba), 0., 1.);\n  return length(pa - ba * h);\n}\n\nfloat sdSeg(in vec3 p, in vec3 a, in vec3 b) {\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp(dot(pa, ba) / dot(ba, ba), 0., 1.);\n  return length(pa - ba * h);\n}\n\nfloat sdPlane(vec3 p, vec3 n, float d) {\n// n is the normal of the plane, d is the distance from the origin\nreturn dot(p, n) + d;\n}\n\nfloat sdHollowCylinder(vec3 p, float r, float h, float yClamp) {\n  vec2 d = vec2(length(p.xy) - r, p.z);\n  float circle = length(max(d, 0.0)) - min(max(d.x, d.y), 0.0),\n        zPlanes = max(0., -1.),\n        distYClamp = p.y + yClamp;\n  return max(max(circle, zPlanes), distYClamp);\n}\n\nfloat smoothmin(float d1, float d2, float k) {\n  float h = max(k - abs(d1 - d2), 0.) / k;\n  return min(d1, d2) - h * h * k * (1. / 4.);\n}\n\nfloat smoothmax(float d1, float d2, float k) {\n    float h = max(k - abs(d1 - d2), 0.) / k;\n    return max(d1, d2) + h * h * k * (1. / 4.);\n}\n\nfloat weirdmax(float d1, float d2, float k) {\n    float h = max(k - abs(d1 - d2), 0.) / k;\n    return max(d1, d2) + h * h * k * (1. / 3.);\n}\n\nfloat map(vec3 p) {\n  float spike = .035 + .01*cos(iTime*3.),\n        rAngle = 0.,\n        lineset = 1.,\n        sides = 24.,\n        r = .1;\n  vec3 resetP = p, a = vec3(0.);\n  p.xy/=2.;\n\n  for (float i=0.;i<sides;i++) {\n    rAngle = PI/sides*2.*i;\n    a = vec3(cos(rAngle)*(r+spike), sin(rAngle)*(r+spike),0.);\n    float line = sdRay(p, a); // 0.05 is the half-width of the line\n    lineset = min(line, lineset);\n  }\n  \n  float face = sdSphere(p, vec3(0.), r),\n        eyePair = 1.,\n        dirs[2] = float[2](1., -1.);\n  for (int i = 0; i < 2; i++) {\n    float dir = dirs[i];\n    vec3 eA = vec3(.04*dir,.03,0.), eB = eA;\n    eB.z = -1.;\n    float eye = sdSeg(p, eA, eB) - .005;\n    eyePair = smin(eyePair, eye, .05);\n  }\n\n// Combine the distances to create the flat cutoff\n  float smile = sdHollowCylinder(p, .075, .1, .01+.015*cos(iTime/2.5));\n\n  p = resetP;\n\n  return smax(\n          wmax(smin(face,lineset,spike), -eyePair, .05),\n          -smile,\n          .01 \n          );\n}\n\nvec3 norm(vec3 p) {\n  float h = 1e-3;\n  vec2 k = vec2(-1, 1);\n  return normalize(\n    k.xyy * map(p + k.xyy * h) +\n    k.yxy * map(p + k.yxy * h) +\n    k.yyx * map(p + k.yyx * h) +\n    k.xxx * map(p + k.xxx * h)\n  );\n}\n\nfloat raymarch(inout vec3 p, vec3 rd) {\n  float dd = 0.0;\n  for (float i = 0.0; i < 100.0; i++) {\n    float d = map(p);\n    if (d < 1e-3 || dd > 5.) break;\n    p += rd * d;\n    dd += d;\n  }\n  return dd;\n}\n\nvec3 render(vec3 p, vec3 rd) {\n  float d = raymarch(p, rd);\n  vec3 col = vec3(0);\n\n  if (d < 5.) {\n    vec3 n = norm(p),\n         lp = vec3(-1, 2, -5),\n         l = normalize(lp - p);\n    float diffuse = clamp(dot(l, n), 0., 1.),\n          reflective = clamp(dot(reflect(rd, n), l), .0, 1.0);\n    col += diffuse + pow(reflective, 8.); // that last number defines the size of light: the smaller, the greater it is\n    col = mix(col, vec3(1.5,.5,-.75), .5);\n  } else {\n    col = vec3(0.,.5,.8);\n  }\n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 uv = (fragCoord.xy - .5 * RES.xy) / RES.y;\n\n  float angleX = PT.z > 0. ? (PT.x / RES.x * 2. - 1.)*PI/5. + PI : PI + .5*cos(iTime/2.),\n        angleY = PT.z > 0. ? (PT.y / RES.y * 2. - 1.)*PI/-5.: 0.,\n        camR = .66;  // Rotate around the x- and y-axis based on mouse position\n\n  vec3 target = vec3(0.0); // Center of the cube\n\n  vec3 ro = vec3(\n    sin(angleX)*cos(angleY),\n    sin(angleY),\n    cos(angleX)*cos(angleY)\n    )*camR;\n\n  // Calculate the ray direction\n  vec3 fwd = normalize(target - ro), // fwd direction\n      right = normalize(cross(vec3(0., 1., 0.), fwd)), // Right direction\n      up = cross(fwd, right), // Up direction\n      rd = normalize(fwd + uv.x * right + uv.y * up); // Ray direction\n\n  float t = 0.0; // Total distance travelled\n\n  uv.x -=.3*cos(iTime/2.);\n\n  vec3 p = ro, col = render(ro, rd),\n       tint = vec3(.5,1.25 - abs(length(uv)*1.75),0);\n  fragColor = vec4(mix(col, tint,.33), 1);\n}\n","name":"Image","description":"","type":"image"}]}