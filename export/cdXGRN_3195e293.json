{"ver":"0.1","info":{"id":"cdXGRN","date":"1668609226","viewed":49,"name":"Analytical raycast","username":"danielsturk","description":"first raycast. did it analytically, like ray-aabb (aka ray-box) intersection","likes":1,"published":1,"flags":32,"usePreview":0,"tags":["raycast"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    int confidence;\n    vec3 light = decode(texture(iChannel1, fragCoord / iResolution.xy), confidence);\n    fragColor = vec4(tonemap(light), 1.);\n}\n\n/*\nmaybe i should store confidence in just 1 pixel\n*/","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define saturate(x) clamp(x, 0., 1.)\n\nconst int numPillars = 6;\nconst float pillarWidth = .5;\nconst float pillarGap = .2;\nconst float relPillarWidth = pillarWidth / (pillarWidth + pillarGap);\nconst float pillarsMin = (float(numPillars) * pillarWidth + float(numPillars - 1) * pillarGap) / 2.;\nconst float pillarHeight = 2.;\n\nconst float borderWidth = pillarHeight;\n\nconst float uvFloorSize = .5;\nconst float uvPillarsSize = 1. - uvFloorSize;\n\nfloat oldRand(float x) {\n    //return .5 + .5 * sin(x * x * 14.2345678 + 13.5678901);\n    float y = x;\n    y = y * 5.5215126221 + .6123541255;\n    y = fract(y) * (x * 4.6214215621 + .9621412541);\n    y = y * 5.5215126221 + .7123251262;\n    return fract(y);\n}\n\nfloat rand(float x, float seed) {\n    return oldRand(oldRand(x) + seed);\n}\n\nfloat getHeight(ivec2 pos) {\n    float seed = 12.;\n    float h = rand(rand(seed, float(pos.x)), float(pos.y));\n    return pillarHeight * h;\n}\n\nvec2 toUv(vec3 pos, vec3 hitN) {\n    if(pos.y < .001) {\n        vec2 uv = .5 + pos.xz * (1. / ((pillarsMin + borderWidth) * 2.));\n        uv = clamp(uv, vec2(.01), vec2(.99));\n        uv *= uvFloorSize;\n        return uv;\n    }\n    ivec2 pillarPos = ivec2((pos.xz + pillarsMin + pillarGap * .5) / (pillarWidth + pillarGap));\n    int pillarIndex = pillarPos.x + pillarPos.y * numPillars;\n    vec2 uvMin = vec2(\n        float(pillarIndex) * (1. / float(numPillars * numPillars)),\n        uvFloorSize\n    );\n    if(hitN == vec3(0,1,0)) {\n        \n    }\n}\n\nvoid fromUv(vec2 uv, out vec3 pos, out vec3 normal) {\n    if(uv.x < uvFloorSize && uv.y < uvFloorSize) {\n        uv /= uvFloorSize;\n        normal = vec3(0,1,0);\n        pos = (vec3(uv.x, 0, uv.y) - .5) * (pillarsMin + borderWidth) * 2.;\n        return;\n    }\n    uv.y -= uvFloorSize;\n    uv.y *= (1. / uvPillarsSize);\n\n    if(uv.y < 0.) return;\n    \n    uv.x *= float(numPillars * numPillars);\n    int pillarIndex = int(uv.x);\n    \n    ivec2 pillarIndex2;\n    pillarIndex2.y = pillarIndex / numPillars;\n    pillarIndex2.x = pillarIndex - pillarIndex2.y * numPillars;\n    uv.x -= float(pillarIndex);\n    \n    float height = getHeight(pillarIndex2);\n    vec2 pillarMin = -pillarsMin + vec2(pillarIndex2) * (pillarWidth + pillarGap);\n    \n    if(uv.y < .2) { // top of pillar\n        uv.y *= 5.;\n        pos = vec3(pillarMin.x + uv.x * pillarWidth, height, pillarMin.y + uv.y * pillarWidth);\n        normal = vec3(0,1,0);\n        return;\n    }\n    uv -= .2;\n    \n}\n\n#define PI 3.14159265359\n\nmat4 rotMat(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n                0.0,                                0.0,                                0.0,                                1.0);\n}\n\nmat2 rotMat2(float angle)\n{\n    float s = sin(angle);\n    float c = cos(angle);\n    \n    return mat2(1, 0, 0, 1);\n}\n\nvec3 mulPos(mat4 mat, vec3 pos) {\n\tvec4 result = mat * vec4(pos, 1.);\n    return result.xyz / result.w;\n}\n\nvec3 mulDir(mat4 mat, vec3 pos) {\n\tvec4 result = mat * vec4(pos, 0.);\n    return result.xyz;\n}\n\n//\n\nstruct Surf {\n    vec3 pos;\n    vec3 normal;\n    vec3 color;\n    float roughness;\n    bool emissive;\n};\n\nstruct Ray {\n\tvec3 o;\n    vec3 d;\n    float len;\n};\n    \nstruct Plane {\n    vec3 normal;\n    float d;\n};\n\n//\n\nvoid mulRay(mat4 mat, inout Ray r) {\n    r.o = mulPos(mat, r.o);\n    r.d = mulDir(mat, r.d);\n}\n\nbool raycastPlane(Ray r, vec3 n, vec3 o, out vec3 hit, out float dist) {\n    float d = dot(r.d, n);\n    if(d > 0.) return false;\n    float hitDist = dot(n, (o - r.o)) / d;\n    if(hitDist <= 0.) return false;\n    if(hitDist > r.len) return false;\n    hit = r.o + r.d * hitDist;\n    dist = hitDist;\n    return true;\n}\n\nbool raycastPillars(inout Ray r, out Surf surf) {\n    vec3 hitPos;\n    float outDist;\n    bool hitSomething = false;\n    \n    for(int axis = 0; axis < 3; axis += 2) {\n        for(int i = 0; i < numPillars; i++) {\n            vec3 planePos = vec3(\n                0, 0, -pillarsMin + float(i) * (pillarWidth + pillarGap)\n            );\n            vec3 planeDir = vec3(0,0,-1);\n            if(axis == 2) {\n                planePos.xz = planePos.zx;\n                planeDir.xz = planeDir.zx;\n            }\n            planePos.xz *= sign(r.d.xz);\n            planeDir.xz *= sign(r.d.xz);\n            vec3 n = planeDir;\n            \n            if(!raycastPlane(r, planeDir, planePos, hitPos, outDist)) continue;\n            float u = hitPos[axis] + pillarsMin;\n            u /= (pillarWidth + pillarGap);\n            float ui = floor(u);\n            int ui_i = int(ui);\n            if(ui_i < 0 || ui_i >= numPillars) continue;\n            if(u - ui > relPillarWidth) continue;\n            \n            ivec2 pos = ivec2((hitPos.xz + vec2(pillarsMin)) / (pillarWidth + pillarGap) + vec2(.001));\n            float height = getHeight(pos);\n            if(hitPos.y > height) {\n                vec3 hitPos2;\n                float outDist2;\n                vec3 topPlanePos = vec3(\n                    0,\n                    height,\n                    0\n                );\n                \n                if(!raycastPlane(r, vec3(0,1,0), topPlanePos, hitPos2, outDist2)) continue;\n                vec2 pillarMin = vec2(-pillarsMin) + vec2(pos) * (pillarWidth + pillarGap);\n                vec2 pillarMax = pillarMin + vec2(pillarWidth);\n                if(hitPos2.x < pillarMin.x || hitPos2.z < pillarMin.y || hitPos2.x > pillarMax.x || hitPos2.z > pillarMax.y) continue;\n                hitPos = hitPos2;\n                outDist = outDist2;\n                n = vec3(0,1,0);\n            } else {\n                /*const float WallThickness = .05;\n                if(\n                    hitPos.y < height - WallThickness && hitPos.y > max(WallThickness, height - (pillarWidth - WallThickness)) // there's 2 WallThickness at the end here that cancel out\n                ) {\n                    float pillarCenter = -pillarsMin + float(pos.x) * (pillarWidth + pillarGap) + pillarWidth * .5;\n                    if (abs(hitPos.x - pillarCenter) < (pillarWidth * .5 - WallThickness)) continue;\n                }*/\n            }\n\n/*\n            float v = 1. - hitPos.y / 2.;\n            v *= v;\n            v *= v;\n            v *= .7;\n            v = 1. - v;\n*/\n            float seed = rand(float(pos.x), 5.2);\n            seed = rand(float(pos.y), seed);\n            surf.color = vec3(rand(0., seed), rand(1., seed), rand(2., seed));\n            r.len = outDist;\n            surf.normal = n;\n            surf.pos = hitPos;\n            surf.roughness = fract(float(pos.x) * .25 + float(pos.y) * .5 + .501);\n            surf.emissive = pos.x == pos.y;\n            if(false && pos.x == 5 - pos.y) {\n                surf.color = vec3(1);\n                surf.roughness = 0.;\n            }\n            hitSomething = true;\n            \n            // TODO: EARLY EXIT\n        }\n    }\n    \n    return hitSomething;\n}\n\nbool raycastInside(Ray r, inout Surf surf, float pillarHeight) {\nsurf.pos.x += .5;\nsurf.normal *= -1.;\n    return true;\n    \n    vec2 pillarIndex = round((r.o.xz + pillarsMin - pillarWidth * .5) / (pillarWidth + pillarGap));\n    vec2 pillarCenter = pillarWidth * .5 + pillarIndex * (pillarWidth + pillarGap);\n    vec3 walls = vec3(vec2(pillarCenter), 0) \n        + sign(r.d) * vec3(vec2(pillarWidth * .5), pillarHeight);\n    vec3 dists = (walls - r.o) / r.d;\n    int axis;\n    if(dists.x < dists.y) {\n        if(dists.x < dists.z) axis = 0;\n        else if(dists.x < dists.z) axis = 2;\n    } else {\n        if(dists.y < dists.z) axis = 1;\n        else if(dists.x < dists.z) axis = 2;\n    }\n    surf.normal = vec3(0);\n    surf.normal[axis] = -sign(r.d[axis]);\n    surf.pos = r.o + r.d * min(min(dists.x, dists.y), dists.z);\n    return true;\n}\n\nbool raycast(Ray r, out Surf surf) {\n    vec3 hitPos;\n    float outDist;\n    \n    bool hitSomething = false;\n    \n    hitSomething = hitSomething || raycastPillars(r, surf);\n    \n    // floor\n    if(raycastPlane(r, vec3(0,1,0), vec3(0), hitPos, outDist)) {\n        surf.color = vec3(.5);\n        hitSomething = true;\n        surf.normal = vec3(0,1,0);\n        surf.pos = hitPos;\n        surf.roughness = 1.;\n        surf.emissive = false;\n    }\n    return hitSomething;\n}\n\nvec3 ImportanceSampleGGX( vec2 uv, mat3 vecSpace, float Roughness )\n{\n    float a = Roughness * Roughness;\n    float Phi = 2.0 * PI * uv.x;\n    float CosTheta = sqrt( (1.0 - uv.y) / ( 1.0 + (a*a - 1.0) * uv.y ) );\n    float SinTheta = sqrt( 1.0 - CosTheta * CosTheta );\n    return vecSpace * vec3(SinTheta * cos( Phi ), SinTheta * sin( Phi ), CosTheta);\n}\n\nvec3 ImportanceSampleGGX( vec2 uv, mat3 vecSpace )\n{\n    float Phi = 2.0 * PI * uv.x;\n    float CosTheta = sqrt( uv.y );\n    float SinTheta = sqrt( 1.0 - CosTheta * CosTheta );\n    return vecSpace * vec3(SinTheta * cos( Phi ), SinTheta * sin( Phi ), CosTheta);\n}\n\nmat3 matrixFromVector(vec3 n) {\n    vec3 b1 = normalize(cross(n, vec3(1, 1, 1)));\n    vec3 b2 = normalize(cross(n, b1));\n    return mat3(b1, b2, n);\n}\n\nvec4 encode(vec3 light, int confidence) {\n    float highest = ceil(max(max(light.r, light.g), light.b));\n    if(highest <= 0.) light = vec3(0.);\n    else {\n        highest = min(highest, 15.);\n        light /= highest;\n    }\n    float a = highest;\n    a += min(float(confidence), 15.) * 16.;\n    return saturate(vec4(light, a / 255.));\n}\n\nvec3 decode(vec4 texel, out int confidence) {\n    float a = round(texel.a * 255.);\n    confidence = int(a / 16.);\n    float highest = a - float(confidence * 16);\n    return highest * texel.rgb;\n}\n\nvec3 tonemap(vec3 c) {\n    float lum = dot(c, vec3(.2, .7, .1));\n    float up = max(max(c.r, c.b), c.g);\n    c = c / (1. + vec3(up));\n    lum *= .05;\n    c = mix(c, vec3(1.), lum / (1. + lum));\n    return c;\n}\n\n/*\nvec3 tonemap2(vec3 c) {\n    float lum = dot(c, vec3(.2, .7, .1));\n    float x = c.x - lum;\n    float y = c.y - lum;\n    vec3 data = vec3(x, y, lum);\n    data *= (1. / (lum + 1.));\n    vec3 rgb;\n    lum = data.z;\n    rgb.r = lum.r + lum;\n    rgb.g = lum.g + lum;\n    rgb.b = \n    return sqrt(rgb);\n}\n*/","name":"Common","description":"","type":"common"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"const vec3 skyLight = vec3(3.2);\n\nvec3 lightCast(Ray r, float seed) {\n    vec3 color = vec3(.5);\n    \n    bool inside = false;\n    for(int i = 0; i < 10; i++) {\n        Surf surf;\n        bool result = inside ? raycastInside(r, surf, 2.) : raycast(r, surf);\n        if(!result) {\n            return color * skyLight;\n        }\n        \n        seed = rand(float(i), seed);\n\n        bool transmissive = false;//surf.roughness < .5;\n        if(transmissive) {\n            r.d = refract(r.d, surf.normal, inside ? 2. : .5);\n            inside = !inside;\n        } else {\n            r.d = mix(reflect(r.d, surf.normal), surf.normal, surf.roughness * surf.roughness);\n        }\n        r.d = normalize(r.d);\n        vec2 seed2 = vec2(rand(seed, 11.88715612), rand(seed, 612.12421613612));\n        r.d = ImportanceSampleGGX(seed2, matrixFromVector(r.d), surf.roughness);\n        r.d = normalize(r.d);\n\n        r.o = surf.pos;\n        r.o += surf.normal * .001;\n        r.len = 1000.;\n        Ray shadowRay;\n        shadowRay.d = normalize(vec3(1,1,-1));\n        shadowRay.o = r.o;\n        shadowRay.len = 1000.;\n        Surf shadowSurf;\n        bool shadowResult = raycast(shadowRay, shadowSurf);\n        if(!shadowResult) color += vec3(.5);\n        \n        color *= surf.color; // texture(iChannel0, toUv(shadowHitPos, shadowHitN)).rgb;\n        if(surf.emissive) {\n            //return color * 5.;\n        }\n    }\n    return vec3(0.0);\n}\n\nvec3 raycast(Ray r, float seed) {\n    return lightCast(r, seed);\n}\n\nvec3 computePixel(vec2 screenPos, float seed) {\n    vec2 ang = iMouse.xy / iResolution.xy;\n    ang = ang * vec2(-5., .7) - .8; // artistic choice of initial angle\n    \n    vec2 offset = vec2(rand(seed, 15.6121), rand(seed, 71.1)) - .5;\n\n    const float cameraZDist = 6.;\n    const float distToFocalPoint = cameraZDist - 1.5;\n    float blur = .05;\n\n    Ray r;\n    r.d = vec3((vec2(screenPos)), 1.);\n    r.d.xy += offset * blur;\n    r.d = normalize(r.d);\n    r.len = 100.;\n    mat4 mat = rotMat(vec3(0,1,0), ang.x);\n    r.d = mulDir(rotMat(vec3(1,0,0), ang.y), r.d);\n    r.d = mulDir(mat, r.d);\n    r.o = vec3(-offset * blur * distToFocalPoint, -cameraZDist);\n    r.o = mulPos(rotMat(vec3(1,0,0), ang.y), r.o);\n    r.o = mulPos(mat, r.o);\n    \n    return raycast(r, seed);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float sharedSeed = rand(iTime * 100., 0.);\n    float seed = rand(rand(sharedSeed, fragCoord.y), fragCoord.x);\n    \n    vec2 screenPos = fragCoord / iResolution.xy;\n    screenPos -= .5;\n    screenPos.x *= iResolution.x / iResolution.y;\n    \n    vec2 offset = vec2(rand(sharedSeed, 1.), rand(sharedSeed, 2.)) - .5;\n    \n    int confidence;\n    vec3 newColor = computePixel(screenPos + (offset / iResolution.xy), seed);\n    vec3 oldColor = decode(texture(iChannel1, fragCoord / iResolution.xy), confidence);\n    confidence++;\n    if(confidence >= 15) confidence = 200;\n    if(iMouse.z > 0.) confidence = 1;\n    float alpha = 1. / float(confidence);\n    vec4 final = encode(mix(oldColor, newColor, alpha), confidence);\n    fragColor = final;\n}\n\nvoid mainImage2( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = texture(iChannel0, fragCoord / iResolution.xy);\n}","name":"Buffer B","description":"","type":"buffer"}]}