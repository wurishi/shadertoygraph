{"ver":"0.1","info":{"id":"3tjfDV","date":"1600056934","viewed":183,"name":"UnigineTestTask","username":"hlopeth","description":"Implement simple realization of bump mapping, ambient occlusion, PBR, shadows and soft shadows.","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["bumpmappingambientocclutionpbrshadow"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define USE_BUMP_MAPPING 1\n#define PBR 1\n#define USE_SHADOW 1\n#define SOFT_SHADOW 1\n#define AO 1\n\nfloat PI = 3.14159265359;\n\nfloat uvMultiply = 2.0;\nfloat bumpScale = 35.0;\n\nfloat metalness = 0.0;\nfloat roughness = 0.4;\nvec3 albedo = vec3(1.0);\nvec3 lightColor = vec3(1.0, 0.7, 0.56);\n\nfloat getHeight(sampler2D channel, vec2 offset) {\n\treturn bumpScale * texture(channel, uvMultiply * offset / iResolution.xy).r;\n}\n\n\nfloat calcShadow(vec3 lightPos, vec3 pos) {\n    vec3 lightDir = normalize(lightPos - pos);\n    vec3 currPos = pos + lightDir * 0.005; // avoid self-shadow\n    float baseHeight = texture(iChannel0, uvMultiply * (pos.xy + 0.5)).r;\n    \n    float stapSize = 0.05;\n    int step = 0;\n    int maxStep = 30;\n    float heights[3] = float[3](0.0, 0.0, 0.0);\n    while(distance(currPos, lightPos) > 0.01 && step < maxStep) {\n        step += 1;\n        currPos += lightDir * 0.01;\n        heights[2] = heights[1];\n        heights[1] = heights[0];\n        heights[0] = texture(iChannel0, uvMultiply * (currPos.xy + 0.5)).r;\n        if(heights[0] - currPos.z > baseHeight) {\n            #if SOFT_SHADOW\n            float shadow = float(step) / float(maxStep);\n            #else\n            float shadow = 0.0; \n            #endif\n            \n            return clamp(shadow, 0.3, 1.0);\n        }\n    }\n    return 1.0;      \n}\n\nfloat calcAmbientOcclision(vec2 fragCoord) {\n    float baseSample = getHeight(iChannel0, fragCoord);\n    int samples = 2;\n    float occlusion = 0.0;\n    for(int i = -samples; i < samples; i++) {\n    \tfor(int j = -samples; j < samples; j++) {\n            float currSample = getHeight(iChannel0, fragCoord + vec2(i,j));\n        \tocclusion += (currSample >= baseSample ? 1.0 : 0.0);  \n        }\n    }\n    occlusion = 1.0 - occlusion / float(samples * samples * 4);\n\treturn occlusion;\n}\n\nfloat DistributionGGX(vec3 N, vec3 H, float roughness)\n{\n    float a      = roughness*roughness;\n    float a2     = a*a;\n    float NdotH  = max(dot(N, H), 0.0);\n    float NdotH2 = NdotH*NdotH;\n\t\n    float num   = a2;\n    float denom = (NdotH2 * (a2 - 1.0) + 1.0);\n    denom = PI * denom * denom;\n\t\n    return num / denom;\n}\n\nfloat GeometrySchlickGGX(float NdotV, float roughness)\n{\n    float r = (roughness + 1.0);\n    float k = (r*r) / 8.0;\n\n    float num   = NdotV;\n    float denom = NdotV * (1.0 - k) + k;\n\t\n    return num / denom;\n}\n\nfloat GeometrySmith(vec3 N, vec3 V, vec3 L, float roughness)\n{\n    float NdotV = max(dot(N, V), 0.0);\n    float NdotL = max(dot(N, L), 0.0);\n    float ggx2  = GeometrySchlickGGX(NdotV, roughness);\n    float ggx1  = GeometrySchlickGGX(NdotL, roughness);\n\t\n    return ggx1 * ggx2;\n}\n\nvec3 FresnelSchlick(float cosTheta, vec3 F0)\n{\n    return F0 + (1.0 - F0) * pow(1.0 - cosTheta, 5.0);\n}   \n\nvec3 claclLightBRDF(vec3 lightPos, vec3 viewDir, vec3 pos, vec3 normal) {\n    vec3 lightDir = lightPos - pos;\n    float distance = length(lightDir);\n    distance = distance * distance;\n    lightDir = normalize(lightDir);\n    vec3 h = normalize(lightDir + viewDir);\n    float attenuation = 1.0 / distance;\n    vec3 radiance = lightColor * attenuation;\n    float cosTheta = max(0.0, dot(h, viewDir));\n    float NdotL = max(dot(normal, lightDir), 0.0);\n    \n    \n\tvec3 F0 = mix(vec3(0.04), albedo, metalness);\n    vec3 F = FresnelSchlick(cosTheta,F0);\n    float D = DistributionGGX(normal, h, roughness);\n    float G = GeometrySmith(normal, viewDir, lightDir, roughness);\n    float denominator = 4.0 * max(dot(normal, viewDir), 0.0) * NdotL + 0.001;\n    vec3 specular = (D * G * F) / denominator;\n    \n    vec3 kS = F;\n    vec3 kD = (vec3(1.0) - kS) * (1.0 - metalness);\n    \n    vec3 Lo = (kD * albedo / PI + specular) * radiance * NdotL;\n    \n    vec3 ambient = 0.2 * lightColor * albedo;\n    vec3 color = ambient + Lo;\n        \n    return color;\n}\n\n\nfloat calcDiffuse(vec3 lightDir, vec3 normal) {\n\treturn max(dot(normal, lightDir), 0.0); \n}\n\nfloat calcSpecular(vec3 lightDir, vec3 viewDir, vec3 normal) {\n    vec3 h = normalize(lightDir + viewDir);\n    float spec = dot(normal, h);\n\treturn pow(max(spec, 0.0), 16.0);\n}\n\n//blinn-phong light\nvec3 calcLight(vec3 lightPos, vec3 viewDir, vec3 pos, vec3 normal) {\n    vec3 lightDir = lightPos - pos;\n    float distance = length(lightDir);\n    distance = distance * distance;\n    lightDir = normalize(lightDir);\n    vec3 h = normalize(lightDir + viewDir);\n    float attenuation = 1.0 / distance;\n    float diffuse = calcDiffuse(lightDir, normal);\n    float specular = calcSpecular(lightDir, viewDir, normal);\n    \n    float ambient = 0.5;\n        \n    return lightColor * attenuation * (diffuse * specular + ambient);\n}\n\nvec3 getNormal(vec2 fragCoord) {\n    float height = getHeight(iChannel0, fragCoord.xy);\n    float upHeight = getHeight(iChannel0, fragCoord.xy + vec2(0,-1));\n\tfloat rightHeight = getHeight(iChannel0,fragCoord.xy + vec2(1,0));\n    \n    return normalize(vec3(height - upHeight, height - rightHeight, 1.0));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    vec3 lightPos = vec3((iMouse.xy/iResolution.xy - 0.5), 0.5);\n    vec3 fragPos = vec3((fragCoord/iResolution.xy - 0.5), 0.0);\n           \n    #if USE_BUMP_MAPPING\n    vec3 normal = getNormal(fragCoord);\n    #else\n    vec3 normal = vec3(0.0, 0.0, 1.0);\n    #endif\n    \n    vec3 viewDir = normalize(vec3(0.0, 0.0, 1.0) - fragPos);\n    vec3 lightDir = normalize(lightPos - fragPos);\n    #if PBR\n    vec3 light = claclLightBRDF(lightPos, viewDir, fragPos, normal);    \n    #else\n    vec3 light = calcLight(lightPos, viewDir, fragPos, normal);\n    #endif\n    \n    #if AO\n    float occlusion = calcAmbientOcclision(fragCoord);\n    #else\n    float occlusion = 1.0;\n    #endif\n    \n    #if USE_SHADOW\n    //Donâ€™t compute shadows for objects not facing the light source\n    float shadow = dot(lightDir, normal) > 0.0? calcShadow(lightPos, fragPos): 1.0;\n    #else\n    float shadow = 1.0;\n    #endif    \n           \n    fragColor = vec4(light * occlusion * shadow, 1.0);\n}","name":"Image","description":"","type":"image"}]}