{"ver":"0.1","info":{"id":"M3d3W2","date":"1717046869","viewed":67,"name":"Looping Poly Mirrors with Sphere","username":"Borthralla","description":"Added Sphere in the middle of the Polyhedra. Use the mouse to move around.\nYou can change the last number of the PQR to 3 or 4, but the sphere will leak out of the shape.","likes":1,"published":1,"flags":32,"usePreview":0,"tags":["3d","mirror","reflect","polyhedra","wythoff"],"hasliked":0,"parentid":"XXdGDH","parentname":"Mirror Looping w/ Mouse Control"},"renderpass":[{"inputs":[{"id":"4sXGRn","filepath":"/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","previewfilepath":"/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\nWythoff reflective polyhedra, code adapted from\n\n    https://www.shadertoy.com/view/tlX3WH\n\nI basically rewrote the polyhera construction and raytracing part there,\nand kept the rendering part untouched.\n\nThe code should look simpler now?\n\nTo play with:\n\n1. Change pqr and truncation_type to see other polyhedron.\n2. use 'INSIDE_VIEW' to view from the inside.\n3. use 'DUAL' to view the dual polyhera.\n   pqr=(2, 3, 4) and truncation_type=(0, 0, 1) will give the\n   rhombic dodecahedron that tiles the whole inner space.\n*/\n#define PI                3.141592654\n#define L2(x)             dot(x, x)\n#define EDGE_THICKNESS    0.025\n#define MAX_TRACE_STEPS   128\n#define MAX_RAY_BOUNCES   12\n#define EPSILON           1e-4\n#define FAR               20.\n#define min3(x, y, z)     (min(x, min(y, z)))\n#define max3(x, y, z)     (max(x, max(y, z)))\n\n\n//#define INSIDE_VIEW\n\n//#define DUAL\n\nconst vec3 pqr = vec3(2, 3, 5);   // (2, 3, 4), (2, 3, 5)\nvec3 truncation_type = vec3(0, 1, 0);\n\nconst float size = 1.35;  // polyhera size\nconst float sphere_size = .6; // sphere size\n\nmat3 M;  // normals of reflection mirrors\nmat3 T;  // three vertices of the fundamental triangle  \nvec3 v0; // initial vertex\n\nmat3 rotateX(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(1, 0, 0),\n        vec3(0, c, -s),\n        vec3(0, s, c)\n    );\n}\n\nmat3 rotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, 0, s),\n        vec3(0, 1, 0),\n        vec3(-s, 0, c)\n    );\n}\n\nvoid init() {\n    vec3 c = cos(PI / pqr);\n    float sp = sin(PI / pqr.x);\n    vec3 m1 = vec3(1, 0, 0);\n    vec3 m2 = vec3(-c.x, sp, 0);\n    float x3 = -c.z;\n    float y3 = -(c.y + c.x*c.z)/sp;\n    float z3 = sqrt(1.0 - x3*x3 - y3*y3);\n    vec3 m3 = vec3(x3, y3, z3);\n    M = mat3(m1, m2, m3);\n    T[0] = normalize(cross(m2, m3));\n    T[1] = normalize(cross(m3, m1));\n    T[2] = normalize(cross(m1, m2));\n    truncation_type.x =0.5*sin(iTime*1.5)+0.5;\n    truncation_type.y=0.5*sin(iTime*0.8)+0.5;\n    truncation_type.z =0.5*sin(iTime*0.3)+0.5;\n    v0 = normalize(truncation_type * inverse(M)) * size;\n#ifdef DUAL\n    #define proj(p, n)  (length(p - dot(p, n) * n))\n    float scale = min3(proj(v0, m1), proj(v0, m2), proj(v0, m3));\n    v0 /= scale;\n#endif\n}\n\nvec3 fold(vec3 p) {\n    for (int i = 0; i < 5; i++)\n    for (int j = 0; j < 3; j++) {\n        p -= 2. * min(dot(p, M[j]), 0.) * M[j];\n    }\n    return p;\n}\n\nfloat dSegment(vec3 p, vec3 a, vec3 b) {\n  vec3 pa = p - a;\n  vec3 ba = b - a;\n  float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n  float d = length(pa - ba * h);\n  return d;\n}\n\nvec3 distEdges(vec3 p) {\n    p = fold(p);\n#ifdef DUAL\n\tvec3 ed = vec3(1e5);\n    vec3 a = T[0] / dot(T[0], v0) * size;\n    vec3 b = T[1] / dot(T[1], v0) * size;\n    vec3 c = T[2] / dot(T[2], v0) * size;\n\tif(bool(truncation_type.x))\n        ed.x = dSegment(p, b, c);\n\tif(bool(truncation_type.y))\n        ed.y = dSegment(p, c, a) ;\n\tif(bool(truncation_type.z))\n        ed.z = dSegment(p, a, b);\n\treturn ed;\n#else\n    p -= v0;\n    vec3 ed;\n    for (int i = 0; i < 3; i++) {\n        ed[i] = L2(p - min(0., dot(p, M[i])) * M[i]);\n    }\n\treturn sqrt(ed);\n#endif\n}\n\nfloat map(vec3 p) {\n    vec3 pf = fold(p);\n#ifdef DUAL\n    return dot(pf, v0) - size;\n#else\n    pf -= v0;\n    float m = max(dot(pf, T[0]), max(dot(pf, T[1]), dot(pf, T[2])));\n    m = max(m, sphere_size - length(p));\n    return m;\n#endif\n}\n\nfloat trace(vec3 pos, vec3 rd, bool outside) {\n    float t = 0.0;\n    float sgn = outside ? 1.0 : -1.0;\n    for (int i = 0; i < MAX_TRACE_STEPS; i++) {\n        float d = map(pos + t * rd);\n        if (abs(d) < EPSILON)\n            return t;\n        if (t > FAR)\n            break;\n        t += sgn * d  * 0.9;\n    }\n    return FAR;\n}\n\nvec4 wallColor(vec3 dir, vec3 nor, vec3 eds) {\n    float d = min3(eds.x, eds.y, eds.z);\n    \n    // Texturing of walls\n    vec3 albedo = texture(iChannel1, vec2(eds.xy * 2.0)).rgb;\n    albedo = pow(albedo, vec3(2.2)) * 0.5;\n    \n    // Simple diffuse lighting\n    float lighting = 0.2 + max(dot(nor, vec3(0.8, 0.5, 0.0)), 0.0);\n    \n    if (dot(dir, nor) < 0.0) {\n        // Outer walls, just add a black line to hide seams\n        float f = clamp(d * 1000.0 - 3.0, 0.0, 1.0);\n        albedo = mix(vec3(0.01), albedo, f);\n        return vec4(albedo * lighting, f);\n    } else {\n        // Inner walls, add fancy lights\n        float m = max3(eds.x, eds.y, eds.z);\n        vec2 a = fract(vec2(d, m) * 40.6) - 0.5;\n        float b = 1.0 - sqrt(dot(a, a));\n        b = 0.2 / (dot(a, a) + 0.2);\n        \n        float lightShape = 1.0 - clamp(d * 100.0 - 2.0, 0.0, 1.0);\n        lightShape *= b;\n        \n        vec3 emissive = vec3(3.5, 1.8, 1.0);\n        return vec4(mix(albedo * lighting, emissive, lightShape), 0.0);\n    }\n\treturn vec4(1.0);\n}\n\n\nmat3 camera_matrix(vec3 eye, vec3 lookat, vec3 up) {\n    vec3 forward = normalize(lookat - eye);\n    vec3 right = normalize(cross(forward, up));\n    up = normalize(cross(right, forward));\n    return mat3(right, up, -forward);\n}\n\nvec3 get_normal( in vec3 pos ) {\n    vec3 eps = vec3(0.001,0.0,0.0);\n\treturn normalize( vec3(\n           map(pos+eps.xyy) - map(pos-eps.xyy),\n           map(pos+eps.yxy) - map(pos-eps.yxy),\n           map(pos+eps.yyx) - map(pos-eps.yyx) ) );\n}\n\nvec3 background(vec3 dir) {\n\tvec3 col = vec3(0.);\n    col = pow(col, vec3(2.2));\n    float origLuma = dot(col, vec3(0.2126, 0.7152, 0.0722)) * 0.7;\n    return 2.5 * col / (1.0 - origLuma);\n}\n\nvec3 drawRay(vec3 pos, vec3 rd) {\n    vec3 color = vec3(0.0);\n#ifndef INSIDE_VIEW\n    float t = trace(pos, rd, true);\n    if (t == FAR) {\n    \treturn background(rd);\n    }\n    pos = pos + t * rd;\n    vec3 nor = get_normal(pos);\n    vec3 reflDir = reflect(rd, nor);\n    vec3 bgColor = pow(background(reflDir), vec3(1.0));\n    float fresnel = 0.04 + 0.96 * pow(1.0 - max(dot(rd, -nor), 0.0), 5.0);\n    color += bgColor * fresnel;\n    vec3 eds = distEdges(pos);\n    float d = min3(eds.x, eds.y, eds.z);\n    if (d < EDGE_THICKNESS) {\n        vec4 wc = wallColor(rd, nor, eds);\n    \treturn color * wc.a + wc.rgb;\n    }\n#endif\n    vec3 transmittance = vec3(1.0);\n    for (int i = 0; i < MAX_RAY_BOUNCES; i++) {\n        float t = trace(pos, rd, false);\n        pos = pos + t * rd;\n        vec3 eds = distEdges(pos);\n        vec3 nor = get_normal(pos);\n    \tfloat d = min3(eds.x, eds.y, eds.z);\n        if (d < EDGE_THICKNESS) {\n        \treturn color + transmittance * wallColor(rd, nor, eds).rgb;\n        }\n        rd = reflect(rd, nor);\n        pos += rd * 0.005;\n        transmittance *= vec3(0.4, 0.7, 0.7);\n    }\n    \n    return color;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    init();\n    vec2 uv = (fragCoord.xy - iResolution.xy*0.5) / iResolution.y;\n    vec4 state = texelFetch( iChannel2, ivec2(0, 0), 0);\n    vec2 move = state.xy * .01; // vec2(.65, 0);\n\n#ifdef INSIDE_VIEW\n    float radius = 0.1;\n#else\n    float radius = 3.0;\n#endif\n    vec3 eye = radius * vec3(\n        cos(move.x)*cos(move.y),\n        sin(move.y),\n        sin(move.x)*cos(move.y)\n    );\n    \n    \n    vec3 lookat = vec3(0);\n    vec3 up = vec3(0, 1, 0);\n    vec3 forward = normalize(lookat - eye);\n    vec3 right = normalize(cross(forward, up));\n    up = normalize(cross(right, forward));\n    vec3 ray = normalize(uv.x*right + uv.y*up + forward * 1.0);\n    vec3 color = drawRay(eye, ray);\n    color = color / (color * 0.5 + 0.5);\n    color = pow(color, vec3(1.0 / 2.2));\n\n    fragColor = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 click_pos = iMouse.zw;\n    vec2 mouse_pos = iMouse.xy;\n    vec4 state = texelFetch( iChannel0, ivec2(0, 0), 0);\n    \n    if (distance(click_pos, mouse_pos) > 5.) {\n        //Update pitch and yaw based on last mouse\n        float diff_x = mouse_pos.x - state.z;\n        float diff_y = mouse_pos.y - state.w;\n        state.x = mod(state.x + diff_x, 628.);\n        state.y = clamp(state.y - diff_y, -150., 150.);\n    }\n    state.z = mouse_pos.x;\n    state.w = mouse_pos.y;\n    fragColor = state;\n}","name":"Buffer A","description":"","type":"buffer"}]}