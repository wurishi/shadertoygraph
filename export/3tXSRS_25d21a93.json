{"ver":"0.1","info":{"id":"3tXSRS","date":"1563476846","viewed":321,"name":"Attracting funnel","username":"TambakoJaguar","description":"After a long time not being here, I wanted to program something I've seen on an animated GIF here. I could learn and experiment a few things more. What do you think, even nothing is perfect for now..\nUse the mouse to move around.\n","likes":14,"published":1,"flags":0,"usePreview":0,"tags":["balls","pattern","polar","hole","hyperbola","funnel","attracting","absorbing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n\"Attracting funnel\" by Emmanuel Keller aka Tambako - July 2019\nLicense Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\nContact: tamby@tambako.ch\n*/\n\n#define pi 3.141593\n\n// The defines to switch on and off some features\n#define specular\n#define pattern\n//#define bump\n#define balls\n//#define ball_reflection\n#define shadow\n//#define motion_blur\n//#define test_mode\n\nstruct Lamp\n{\n  vec3 position;\n  vec3 color;\n  float intensity;\n  float attenuation;\n};\n\nstruct RenderData\n{\n  vec3 col;\n  vec3 pos;\n  vec3 norm;\n  float objnr;\n};\n    \nLamp lamps[3];\n\n#define HOLE_OBJ      1\n#define BALL_OBJ      2\n\n// Campera options\nvec3 campos = vec3(0.5, -0.4, 10.);\nvec3 camtarget = vec3(0., 0., 0.);\nvec3 camdir;\nfloat fov = 5.8;\nfloat angle;\nfloat angle2;\nfloat time2;\n\nconst float normdelta = 0.0001;\nconst float maxdist = 60.;\n\nconst vec3 ball_color = vec3(1., 0.1, 0.1);\nconst float ballR = 0.3;\n\nconst vec3 ambientColor = vec3(0.3);\nconst float ambientint = 0.12;\nconst vec3 speccolor = vec3(0.95, 0.97, 1.);\n\nconst float specint_hole = 0.047;\nconst float specshin_hole = 23.;\nconst float specint_ball = 0.18;\nconst float specshin_ball = 30.;\n\nconst float shi = 0.84;\nconst float shf = 0.4;\n\nconst float bottom = 7.5;\nconst float txtSpeed = 1.7;\nconst float cdif = 0.012;\nconst float holeWidth = 0.5;\nconst float pati = 0.33;\nconst float bumpHeight = 0.015;\nconst float mbLength = 0.01;\n\nvec3 posr;\n\n// Antialias. Change from 1 to 2 or more AT YOUR OWN RISK! It may CRASH your browser while compiling!\nconst float aawidth = 0.8;\n#ifdef motion_blur\nconst int aasamples = 4;\n#else\nconst int aasamples = 1;\n#endif\n\n// Union operation from iq\nvec2 opU(vec2 d1, vec2 d2)\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nvec2 rotateVec(vec2 vect, float angle)\n{\n    vec2 rv;\n    rv.x = vect.x*cos(angle) + vect.y*sin(angle);\n    rv.y = vect.x*sin(angle) - vect.y*cos(angle);\n    return rv;\n}\n\nfloat hash(vec3 p)\n{\n    p  = fract( p*0.3183099+.1 );\n\tp *= 17.0;\n    return fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\n}\n\nfloat polarNoise0(vec3 x)\n{   \n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    return mix(mix(mix( hash(p+vec3(0,0,0)), \n                        hash(p+vec3(1,0,0)),f.x),\n                   mix( hash(p+vec3(0,1,0)), \n                        hash(p+vec3(1,1,0)),f.x),f.y),\n               mix(mix( hash(p+vec3(0,0,1)), \n                        hash(p+vec3(1,0,1)),f.x),\n                   mix( hash(p+vec3(0,1,1)), \n                        hash(p+vec3(1,1,1)),f.x),f.y),f.z);\n}\n\nconst mat3 m = mat3( 0.00,  0.80,  0.60,\n                    -0.80,  0.36, -0.48,\n                    -0.60, -0.48,  0.64 );\n\nfloat polarNoise(vec3 pos1)\n{\n    vec3 q = 8.0*pos1;\n    float f = 0.0;\n    f  = 0.5000*polarNoise0(q); q = m*q*2.;\n    f += 0.2500*polarNoise0(q); q = m*q*2.;\n    f += 0.1250*polarNoise0(q); q = m*q*2.;\n    f += 0.0625*polarNoise0(q); q = m*q*2.;\n    \n    return f;\n}\n\nfloat polarNoise2(vec3 pos)\n{\n    float a = 2.*atan(pos.y, pos.x);\n    vec3 pos1 = vec3(pos.z, length(pos.yx) + time2*txtSpeed, a);\n    vec3 pos2 = vec3(pos.z, length(pos.yx) + time2*txtSpeed, a+12.57);    \n    \n    float f1 = polarNoise(pos1);\n    float f2 = polarNoise(pos2);\n    float f = mix(f1, f2, smoothstep(-5., -6.285, a));\n    \n    f = smoothstep(0.01, 0.2, f)-smoothstep(0.2, 0.52, f)+smoothstep(0.45, 0.63, f);\n    f = 0.8-pati+f*pati;\n    \n    return f;\n}\n\nfloat polarNoiseN(vec3 pos1)\n{\n    vec3 q = 8.0*pos1;\n    float f = 0.0;\n    f  = 0.5000*polarNoise0(q); q = m*q*2.;\n    f += 0.2500*polarNoise0(q); q = m*q*2.;\n    \n    return f;\n}\n\nfloat polarNoise2N(vec3 pos)\n{\n    float a = 2.*atan(pos.y, pos.x);\n    vec3 pos1 = vec3(pos.z, length(pos.yx) + iTime*txtSpeed, a);\n    vec3 pos2 = vec3(pos.z, length(pos.yx) + iTime*txtSpeed, a+12.57);    \n    \n    float f1 = polarNoiseN(pos1);\n    float f2 = polarNoiseN(pos2);\n    float f = mix(f1, f2, smoothstep(-5., -6.285, a));\n    \n    //f = smoothstep(0.01, 0.2, f)-smoothstep(0.2, 0.52, f)+smoothstep(0.45, 0.63, f);\n    \n    return f;\n}\n\nfloat map_ball(vec3 pos, vec3 ballPos, float ballR)\n{   \n    float d = length(pos-ballPos) - ballR;\n    \n    return d;\n}\n\nfloat holeFunct(vec2 pos, float holeWidth)\n{\n    float f1 = min(0.6/(max(length(pos)-holeWidth, 0.)), bottom);\n    float f2 = 4.*min(0.6/(max(length(pos)+holeWidth*0.5, 0.)), bottom);\n    \n    //return min(f1, f2);\n    return f1;\n}\n\nfloat map_hole(vec3 pos, bool hasBump)\n{  \n    #ifdef bump\n    if (hasBump)\n    {\n       vec3 pos2 = vec3(pos.yx, 0.);\n       pos.z+= bumpHeight*polarNoise2N(pos2);\n    }\n    #endif     \n    \n    float d = pos.z + holeFunct(pos.yx, holeWidth);\n    #ifdef test_mode\n    d = max(d, -pos.y);\n    #endif\n    \n    return d;\n}\n\nvec3 getBallPos(float offset)\n{  \n    float ii = mod(time2*txtSpeed + offset, 19.8);\n    float ii2 = offset + floor((time2 - offset)/(19.8*txtSpeed));\n    vec3 hv = vec3(15.5*ii2, 22.4*ii2, 71.9*ii2);\n    float ballX = -15. + ii -4.8*smoothstep(13., 20.8, ii);\n    float ballZ = -holeFunct(vec2(ballX, 0.), holeWidth);\n    \n    float hf2 = -holeFunct(vec2(ballX+0.01, 0.), holeWidth);\n    vec2 df = ballR*normalize(vec2(hf2-ballZ, 0.01));\n    ballX-= df.x;\n    ballZ+= df.y;\n    \n    #ifdef test_mode\n    vec3 ballPos = vec3(ballX, 0., ballZ);\n    #else\n    float ballAngle = -pow(abs(0.9/(ballX+0.28)), 2.2) + hash(hv)*2.*pi;\n    vec2 ballPos0 = rotateVec(vec2(ballX, 0), ballAngle);   \n    vec3 ballPos = vec3(ballPos0.x, ballPos0.y, ballZ);\n    #endif\n    \n    return ballPos;\n}\n\nfloat map_balls(vec3 pos)\n{\n    float ball1 = map_ball(pos, getBallPos(0.), ballR);\n    float ball2 = map_ball(pos, getBallPos(3.3), ballR);\n    float ball3 = map_ball(pos, getBallPos(6.6), ballR);\n    float ball4 = map_ball(pos, getBallPos(9.9), ballR);\n    float ball5 = map_ball(pos, getBallPos(13.2), ballR);\n    \n    float b = min(min(min(min(ball1, ball2), ball3), ball4), ball5);\n    \n    #ifdef test_mode\n    b = max(b, -pos.y);\n    #endif\n    \n    return b;\n}\n\nvec2 map(vec3 pos, bool hasBump)\n{\n    vec2 res;\n    \n    float hole = map_hole(pos, hasBump);\n    \n    #ifdef balls\n    float ballss = map_balls(pos);\n    res = opU(vec2(hole, HOLE_OBJ), vec2(ballss, BALL_OBJ));\n    #else\n    res = vec2(hole, HOLE_OBJ);\n    #endif\n    \n    return res;\n}\n\nvec2 trace(vec3 cam, vec3 ray, float maxdist) \n{\n    float t = 1.8;\n    vec3 pos;\n    float dist;\n    float objnr = 0.;\n    \n  \tfor (int i = 0; i < 70; ++i)\n    {\n    \tpos = ray*t + cam;\n    \tvec2 res = map(pos, false);\n        dist = res.x;\n        if (dist>maxdist || abs(dist)<0.0001)\n            break;\n        t+= dist*(0.85-float(i)*0.0122);\n        objnr = abs(res.y);\n  \t}\n        \n  \treturn vec2(t, objnr);\n}\n\nvec3 getNormal(vec3 pos, float e)\n{\n    vec2 q = vec2(0, e);\n    vec3 norm = normalize(vec3(map(pos + q.yxx, true).x - map(pos - q.yxx, true).x,\n                          map(pos + q.xyx, true).x - map(pos - q.xyx, true).x,\n                          map(pos + q.xxy, true).x - map(pos - q.xxy.x, true)));\n    return norm;\n}\n\nvec3 obj_color(vec3 norm, vec3 pos, float objnr)\n{\n    vec3 colo;\n    \n    if (int(objnr)==BALL_OBJ)\n       colo = ball_color;\n    else\n    {\n       #ifdef test_mode\n       colo = vec3(0.7);\n       #else\n       #ifdef pattern\n       vec3 posr = vec3(pos.yx, cdif);\n       vec3 posg = vec3(pos.yx, 0.);\n       vec3 posb = vec3(pos.yx, -cdif);\n       //colo = vec3(polarNoise2(posg));\n       colo = vec3(polarNoise2(posr), polarNoise2(posg), polarNoise2(posb));\n       #else\n       colo = vec3(0.7);\n       #endif\n       #endif\n    }\n    \n    colo*= smoothstep(bottom, bottom*0.25, -pos.z);\n    colo*= smoothstep(maxdist*0.3, maxdist*0.1, length(pos.yx));\n\n    return colo;\n}\n\n// From https://www.shadertoy.com/view/Xds3zN;\nfloat softshadow(vec3 ro, vec3 rd, float mint, float tmax)\n{\n\tfloat res = 1.0;\n    float t = mint;\n    for(int i=0; i<25; i++)\n    {\n    \tfloat h = map(ro + rd*t, false).x;\n        res = min(res, 4.5*h/t);\n        t += clamp(h, 0.01, 0.12);\n        if( h<0.001 || t>tmax ) break;\n    }\n    return smoothstep(0.0, 0.8, res);\n}\n\nvec3 lampShading(Lamp lamp, vec3 norm, vec3 pos, vec3 ocol, float objnr)\n{\n    vec3 pl = normalize(lamp.position - pos);\n    float dlp = distance(lamp.position, pos);\n    vec3 pli = pl/pow(1. + lamp.attenuation*dlp, 2.);\n    vec3 nlcol = normalize(lamp.color);\n    float dnp = dot(norm, pli);\n      \n    // Diffuse shading\n    vec3 col = ocol*nlcol*lamp.intensity*smoothstep(-0.1, 1., dnp);\n    //col+= 0.6*nlcol*lamp.intensity*smoothstep(0.15, 0.9, dnp);\n    \n    // Specular shading\n    #ifdef specular\n    float specint = int(objnr)==HOLE_OBJ?specint_hole:specint_ball;\n    float specshin = int(objnr)==HOLE_OBJ?specshin_hole:specshin_ball;\n    \n    if (dot(norm, lamp.position - pos) > 0.0)\n        col+= speccolor*nlcol*lamp.intensity*specint*pow(max(0.0, dot(reflect(pl, norm), normalize(pos - campos))), specshin)*smoothstep(bottom, 0., -pos.z);\n    #endif\n    \n    // Softshadow\n    #ifdef shadow\n    //if (int(objnr)==HOLE_OBJ)\n       col*= shi*softshadow(pos, normalize(lamp.position - pos), shf, 6.) + 1. - shi;\n    #endif    \n    \n    return col;\n}\n\nvec3 lampsShading(vec3 norm, vec3 pos, vec3 ocol, float objnr)\n{\n    vec3 col = vec3(0.);\n    for (int l=0; l<3; l++) // lamps.length()\n        col+= lampShading(lamps[l], norm, pos, ocol, objnr);\n    \n    return col;\n}\n\n// From https://www.shadertoy.com/view/lsSXzD, modified\nvec3 GetCameraRayDir(vec2 vWindow, vec3 vCameraDir, float fov)\n{\n\tvec3 vForward = normalize(vCameraDir);\n\tvec3 vRight = normalize(cross(vec3(0.0, 1.0, 0.0), vForward));\n\tvec3 vUp = normalize(cross(vForward, vRight));\n    \n\tvec3 vDir = normalize(vWindow.x * vRight + vWindow.y * vUp + vForward * fov);\n\n\treturn vDir;\n}\n\n// Sets the position of the camera with the mouse and calculates its direction\nvoid setCamera()\n{\n   vec2 iMouse2;\n   if (iMouse.x==0. && iMouse.y==0.)\n      iMouse2 = iResolution.xy*vec2(0.52, 0.65);\n   else\n      iMouse2 = iMouse.xy;\n    \n   campos = vec3(3.5 + 10.*cos(1.3 + 1.3*iMouse2.x/iResolution.x)*(1. - 0.0*iMouse2.y/iResolution.y),\n                 -13. + 12.*(iMouse2.y/iResolution.y),\n                 -5.5 + 10.*sin(1.3 + 1.3*iMouse2.x/iResolution.x)*(1. + 0.6*iMouse2.y/iResolution.y));\n   camtarget = vec3(0., -3.2 + 2.8*iMouse2.y/iResolution.y + 0.1, 1.);\n    \n   #ifdef test_mode\n   campos.z-= 1.5;\n   camtarget.z-= 1.5;\n   fov = 4.;\n   #endif\n    \n   camdir = camtarget - campos;   \n}\n\nRenderData trace0(vec3 tpos, vec3 ray)\n{\n  vec2 t = trace(tpos, ray, maxdist);\n  float tx = t.x;\n  vec3 col;\n  float objnr = t.y;\n    \n  vec3 pos = tpos + tx*ray;\n  vec3 norm;\n  if (tx<maxdist*0.65)\n  {\n      norm = getNormal(pos, normdelta);\n\n      // Coloring\n      col = obj_color(norm, pos, objnr);\n      \n      // Shading\n      col = ambientColor*ambientint + lampsShading(norm, pos, col, objnr);\n  }\n  return RenderData(col, pos, norm, objnr);\n}\n\n// Fresnel reflectance factor through Schlick's approximation: https://en.wikipedia.org/wiki/Schlick's_approximation\nfloat fresnel(vec3 ray, vec3 norm, float n2)\n{\n   float n1 = 1.; // air\n   float angle = acos(-dot(ray, norm));\n   float r0 = dot((n1-n2)/(n1+n2), (n1-n2)/(n1+n2));\n   float r = r0 + (1. - r0)*pow(1. - cos(angle), 5.);\n   return clamp(r, 0., 0.8);\n}\n\nvec4 render(vec2 fragCoord)\n{\n  lamps[0] = Lamp(vec3(7., -8., 3.5), vec3(1.0, 1.0, 1.0), 11.2, 0.1);\n  lamps[1] = Lamp(vec3(-14., 2.5, 29.), vec3(0.7, 0.82, 1.0), 7.0, 0.1);\n  lamps[2] = Lamp(vec3(1., 0., 1.2), vec3(1.0, 0.6, 0.4), 0.6, 0.1);\n    \n  vec2 uv = fragCoord.xy / iResolution.xy; \n  uv = uv*2.0 - 1.0;\n  uv.x*= iResolution.x / iResolution.y;\n\n  vec3 ray = GetCameraRayDir(uv, camdir, fov);\n    \n  RenderData traceinf = trace0(campos, ray);\n  vec3 col = traceinf.col;\n    \n  #ifdef ball_reflection\n  if (int(traceinf.objnr)==BALL_OBJ)\n  {\n     vec3 refray;\n     float rf = 1.;\n     refray = reflect(ray, traceinf.norm);\n\n     RenderData traceinf_ref = trace0(traceinf.pos, refray);\n     rf = 0.75*fresnel(ray, traceinf.norm, 2.5)*smoothstep(bottom, 0., -traceinf.pos.z);\n\n     col = mix(col, traceinf_ref.col, rf);    \n  }\n  #endif\n    \n  return vec4(col, 1.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    setCamera();\n    \n    // Antialiasing\n    vec4 orv;\n    vec4 vs = vec4(0.);\n    for (int j=0;j<aasamples ;j++)\n    {\n       float oy = float(j)*aawidth/max(float(aasamples-1), 1.);\n       for (int i=0;i<aasamples ;i++)\n       {\n          #ifdef motion_blur\n          //time2 = iTime + mbLength*hash(vec3(iTime*20.) + vec3(fragCoord*6., (i+aasamples*j)*5));\n          time2 = iTime + mbLength*float(j*aasamples+i)/float(aasamples*aasamples);\n          #else\n          time2 = iTime;\n          #endif\n           \n          float ox = float(i)*aawidth/max(float(aasamples-1), 1.);\n          vec4 rv = render(fragCoord + vec2(ox, oy));\n          vs+= rv;        \n       }\n    }\n    fragColor = vs/vec4(aasamples*aasamples);    \n}","name":"Image","description":"","type":"image"}]}