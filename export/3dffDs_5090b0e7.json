{"ver":"0.1","info":{"id":"3dffDs","date":"1589261370","viewed":79,"name":"cis561_Final Project ","username":"sireesha98","description":"CIS 561 \nPenumbra, SDF, subsurface\nUncomment SUB_SURFACE_ON to see the effect \nUncomment MOVE_SUN to move the light around the scene ","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["project"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"///---------------///\n/// All Constants ///\n///---------------///\nconst vec3 lightPos = vec3(0., 7.1, 0.);\n\nconst float FOVY = 3.141569 * 0.25;\nconst int RAY_STEPS = 256;\nconst float HALF_PI = 3.14159 * 0.5;\n\nconst float FOCAL_LENGTH = 20.;\nconst float FOCAL_RANGE = 16.0;\nconst int AO_SAMPLES = 256;\nconst float AO_DIST = 0.15;\nconst float FIVETAP_K = 2.0;\n\n//#define SUB_SURFACE_ON\n//#define MOVE_SUN\n\n// Toggle this to affect how easily the subsurface glow propagates through an object\n#define ATTENUATION 1\n\n// The larger the DISTORTION, the smaller the glow\nconst float DISTORTION = 0.2;\n// The higher GLOW is, the smaller the glow of the subsurface scattering\nconst float GLOW = 4.0;\n// The higher the BSSRDF_SCALE, the brighter the scattered light\nconst float BSSRDF_SCALE = 5.0;\n// Boost the shadowed areas in the subsurface glow with this\nconst float AMBIENT = 0.0;\n\n\n#define ANTIALIASING 1\n#define DOF; //No DOF in this project \n//#define NO_DOF; //Don't forget to comment BLUR in Image \n\n// The higher the value, the smaller the penumbra\nconst float SHADOW_HARDNESS = 6.0;\n\n// 0 for penumbra shadows, 1 for hard shadows\n#define HARD_SHADOW 0\n\n\n#define PI 3.14159265359\n\n//Set Color palatte :\n//https://iquilezles.org/articles/palettes\n\nconst vec3 a = vec3(0.5, 0.5, 0.5);\nconst vec3 b = vec3(0.5, 0.5, 0.5);\nconst vec3 c = vec3(2.0, 1.0, 1.0);\nconst vec3 d = vec3(0.5, 0.2, 0.25);\n\nvec3 colorPalette(float t) \n{\n    return a + b * cos(6.28 * (t * c + d));\n}\n\n///------------///\n/// Structures ///\n///------------///\n\nstruct Intersection {\n    float t;\n    vec3 color;\n    vec3 p;\n    int object; // Assign every object in our scene a unique ID int\n};\n\nstruct Ray {\n    vec3 origin;\n    vec3 dir; \n    \n};\n  \n///--------------------///\n/// Local Space Matrix ///\n///--------------------///\n    \n// Returns the inverse trasnformation matrix for the given t,r and s components \nmat4 inverseTransform(vec3 scale, vec3 rDeg, vec3 trans) {\n    \n    // convert from degrees to radians\n    vec3 rotate = vec3(radians(rDeg.x), radians(rDeg.y), radians(rDeg.z));\n    \n    mat4 r_x;\n    r_x[0] = vec4(1., 0., 0., 0.);\n    r_x[1] = vec4(0., cos(rotate.x), sin(rotate.x), 0.);\n    r_x[2] = vec4(0., -sin(rotate.x), cos(rotate.x), 0.);\n    r_x[3] = vec4(0., 0., 0., 1.);\n                                    \n                                    \n    mat4 r_y;\n    r_y[0] = vec4(cos(rotate.y), 0., -sin(rotate.y), 0.);\n    r_y[1] = vec4(0., 1, 0., 0.);\n    r_y[2] = vec4(sin(rotate.y), 0., cos(rotate.y), 0.);\n    r_y[3] = vec4(0., 0., 0., 1.);\n\n    mat4 r_z;\n    r_z[0] = vec4(cos(rotate.z), sin(rotate.z), 0., 0.);\n    r_z[1] = vec4(-sin(rotate.z), cos(rotate.z), 0., 0.);\n    r_z[2] = vec4(0., 0., 1., 0.);\n    r_z[3] = vec4(0., 0., 0., 1.);\n\n    mat4 r = r_x * r_y * r_z;\n    \n    // creating worldTransform matrix\n    mat4 t;\n    t[0] = vec4(1., 0., 0., 0.);\n    t[1] = vec4(0., 1., 0., 0.);\n    t[2] = vec4(0., 0., 1., 0.);\n    t[3] = vec4(trans.x, trans.y, trans.z, 1.);\n    \n    mat4 s;\n    s[0] = vec4(scale.x, 0., 0., 0.);\n    s[1] = vec4(0., scale.y, 0., 0.);\n    s[2] = vec4(0., 0., scale.z, 0.);\n    s[3] = vec4(0., 0., 0., 1.);\n\n    mat4 worldTrans = t * r * s;\n    \n    return inverse(worldTrans);\n}\n\n///--------------------///\n/// Rotation Functions ///\n///--------------------///\n\nvec3 rotateX(in vec3 p, float a) {\n\tfloat c = cos(a); float s = sin(a);\n\treturn vec3(p.x, c * p.y - s * p.z, s * p.y + c * p.z);\n}\n\nvec3 rotateY(vec3 p, float a) {\n\tfloat c = cos(a); float s = sin(a);\n\treturn vec3(c * p.x + s * p.z, p.y, -s * p.x + c * p.z);\n}\n\nvec3 rotateZ(vec3 p, float a) {\n\tfloat c = cos(a); float s = sin(a);\n\treturn vec3(c * p.x - s * p.y, s * p.x + c * p.y, p.z);\n}\n\n///-----------------///\n/// Noise Functions /// \n///-----------------///\n\nfloat random1( vec3 p ) {\n    return fract(sin((dot(p, vec3(127.1,\n                                  311.7,\n                                  191.999)))) *         \n                 43758.5453);\n}\n\nvec2 random2(vec3 p) {\n    return fract(sin(vec2(p.x, p.x + 1.0)) * vec2(43758.5453123, 22578.1459123));\n}\n\n\nvec3 random3( vec3 p ) {\n    return fract(sin(vec3(dot(p,vec3(127.1, 311.7, 191.999)),\n                          dot(p,vec3(269.5, 183.3, 765.54)),\n                          dot(p, vec3(420.69, 631.2,109.21))))\n                 *43758.5453);\n}\n\n//3D Worley Noise \nfloat WorleyNoise3D(vec3 p) {\n    // Tile the space\n    vec3 pointInt = floor(p);\n    vec3 pointFract = fract(p);\n\n    float minDist = 1.0; // Minimum distance initialized to max.\n\n    // Search all neighboring cells and this cell for their point\n    for(int z = -1; z <= 1; z++)\n    {\n        for(int y = -1; y <= 1; y++)\n        {\n            for(int x = -1; x <= 1; x++)\n            {\n                vec3 neighbor = vec3(float(x), float(y), float(z));\n\n                // Random point inside current neighboring cell\n                vec3 point = random3(pointInt + neighbor);\n\n                // Animate the point\n                point = 0.5 + 0.5 * sin(iTime * 0.01 + 6.2831 * point); // 0 to 1 range\n\n                // Compute the distance b/t the point and the fragment\n                // Store the min dist thus far\n                vec3 diff = neighbor + point - pointFract;\n                float dist = length(diff);\n                minDist = min(minDist, dist);\n            }\n        }\n    }\n    return minDist;\n}\n\n///---------------------///\n/// Coordinate Systems  ///\n///---------------------///\n\n// Returns a Coorinate system given one of the vectors \nvoid CoordinateSystem(in vec3 v1, out vec3 v2, out vec3 v3) {\n    if (abs(v1.x) > abs(v1.y))\n            v2 = vec3(-v1.z, 0.0, v1.x) / sqrt(v1.x * v1.x + v1.z * v1.z);\n        else\n            v2 = vec3(0.0, v1.z, -v1.y) / sqrt(v1.y * v1.y + v1.z * v1.z);\n        v3 = cross(v1, v2);\n}\n\nvec3 WorleyTangentSpaceNormal(vec3 pos) {\n    vec3 epsilon = vec3(0.0, 0.001, 0.0);\n    return normalize( vec3( WorleyNoise3D(pos + epsilon.yxx) - WorleyNoise3D(pos - epsilon.yxx),\n                            WorleyNoise3D(pos + epsilon.xyx) - WorleyNoise3D(pos - epsilon.xyx),\n                            WorleyNoise3D(pos + epsilon.xxy) - WorleyNoise3D(pos - epsilon.xxy)));\n\n}\n\nmat3 TangentToWorld(vec3 nor) {\n\tvec3 tangent, bitangent;\n    CoordinateSystem(nor, tangent, bitangent);\n    return mat3(tangent, bitangent, nor);\n}\n\n///----------///\n/// ALL SDFs ///\n///----------///\n    \n// SDF of a sphere - done\nfloat sphere(vec3 p, float r, vec3 c) {\n    return distance(p, c) - r;\n}\n\n\nfloat plane( vec3 p, vec4 n )\n{\n  // n must be normalized\n  return dot(p,n.xyz) + n.w;\n}\t\n\n//SDF of a Cube - done\nfloat cube(vec3 p, vec3 s, vec3 r, vec3 t) \n{\n    //Local space of the cube \n    mat4 inverseTrans = inverseTransform(s, r, t);\n    vec4 tempP = inverseTrans * vec4(p, 1.f);\n    p = vec3(tempP.x, tempP.y, tempP.z);\n    \n    vec3 q = abs(p) - vec3(0.5, 0.5, 0.5);\n  \treturn length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat box(vec3 p, vec3 b)\n{\n  return length(max(abs(p) - b, 0.0));\n}\n\n//done \n\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    const float k = sqrt(3.0);\n    h.x *= 0.5*k;\n    p.xy /= h.x;\n    p.x = abs(p.x) - 1.0;\n    p.y = p.y + 1.0/k;\n    if( p.x+k*p.y>0.0 ) p.xy=vec2(p.x-k*p.y,-k*p.x-p.y)/2.0;\n    p.x -= clamp( p.x, -2.0, 0.0 );\n    float d1 = length(p.xy)*sign(-p.y)*h.x;\n    float d2 = abs(p.z)-h.y;\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n}\nfloat sdTriPrism_Ra( vec3 p, vec2 h )\n{\n    p = rotateY(p, -140.);\n    const float k = sqrt(3.0);\n    h.x *= 0.5*k;\n    p.xy /= h.x;\n    p.x = abs(p.x) - 1.0;\n    p.y = p.y + 1.0/k;\n    if( p.x+k*p.y>0.0 ) p.xy=vec2(p.x-k*p.y,-k*p.x-p.y)/2.0;\n    p.x -= clamp( p.x, -2.0, 0.0 );\n    float d1 = length(p.xy)*sign(-p.y)*h.x;\n    float d2 = abs(p.z)-h.y;\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n}\nfloat sdTriPrism_Rb( vec3 p, vec2 h )\n{\n    p = rotateY(p, 45.);\n    const float k = sqrt(3.0);\n    h.x *= 0.5*k;\n    p.xy /= h.x;\n    p.x = abs(p.x) - 1.0;\n    p.y = p.y + 1.0/k;\n    if( p.x+k*p.y>0.0 ) p.xy=vec2(p.x-k*p.y,-k*p.x-p.y)/2.0;\n    p.x -= clamp( p.x, -2.0, 0.0 );\n    float d1 = length(p.xy)*sign(-p.y)*h.x;\n    float d2 = abs(p.z)-h.y;\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n}\n\n//to do\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n    return length( vec2(length(p.xz)-t.x,p.y) )-t.y;\n}\n\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n\n    const vec3 k = vec3(-0.8660254, 0.5, 0.57735);\n    p = abs(p);\n    p.xy -= 2.0*min(dot(k.xy, p.xy), 0.0)*k.xy;\n    vec2 d = vec2(\n       length(p.xy - vec2(clamp(p.x, -k.z*h.x, k.z*h.x), h.x))*sign(p.y - h.x),\n       p.z-h.y );\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdRoundCone( in vec3 p, in float r1, float r2, float h )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    \n    float b = (r1-r2)/h;\n    float a = sqrt(1.0-b*b);\n    float k = dot(q,vec2(-b,a));\n    \n    if( k < 0.0 ) return length(q) - r1;\n    if( k > a*h ) return length(q-vec2(0.0,h)) - r2;\n        \n    return dot(q, vec2(a,b) ) - r1;\n}\n\nfloat sdCone( in vec3 p, in vec2 c, float h )\n{\n    vec2 q = h*vec2(c.x,-c.y)/c.y;\n    vec2 w = vec2( length(p.xz), p.y );\n    \n\tvec2 a = w - q*clamp( dot(w,q)/dot(q,q), 0.0, 1.0 );\n    vec2 b = w - q*vec2( clamp( w.x/q.x, 0.0, 1.0 ), 1.0 );\n    float k = sign( q.y );\n    float d = min(dot( a, a ),dot(b, b));\n    float s = max( k*(w.x*q.y-w.y*q.x),k*(w.y-q.y)  );\n\treturn sqrt(d)*sign(s);\n}\n\nfloat sdOctahedron(vec3 p, float s)\n{\n    p = abs(p);\n    float m = p.x + p.y + p.z - s;\n\n    // exact distance\n    #if 0\n    vec3 o = min(3.0*p - m, 0.0);\n    o = max(6.0*p - m*2.0 - o*3.0 + (o.x+o.y+o.z), 0.0);\n    return length(p - s*o/(o.x+o.y+o.z));\n    #endif\n    \n    // exact distance\n    #if 1\n \tvec3 q;\n         if( 3.0*p.x < m ) q = p.xyz;\n    else if( 3.0*p.y < m ) q = p.yzx;\n    else if( 3.0*p.z < m ) q = p.zxy;\n    else return m*0.57735027;\n    float k = clamp(0.5*(q.z-q.y+s),0.0,s); \n    return length(vec3(q.x,q.y-s+k,q.z-k)); \n    #endif\n    \n    // bound, not exact\n    #if 0\n\treturn m*0.57735027;\n    #endif\n}\n\nfloat sdPyramid( in vec3 p, in float h )\n{\n    float m2 = h*h + 0.25;\n    \n    // symmetry\n    p.xz = abs(p.xz);\n    p.xz = (p.z>p.x) ? p.zx : p.xz;\n    p.xz -= 0.5;\n\t\n    // project into face plane (2D)\n    vec3 q = vec3( p.z, h*p.y - 0.5*p.x, h*p.x + 0.5*p.y);\n   \n    float s = max(-q.x,0.0);\n    float t = clamp( (q.y-0.5*p.z)/(m2+0.25), 0.0, 1.0 );\n    \n    float a = m2*(q.x+s)*(q.x+s) + q.y*q.y;\n\tfloat b = m2*(q.x+0.5*t)*(q.x+0.5*t) + (q.y-m2*t)*(q.y-m2*t);\n    \n    float d2 = min(q.y,-q.x*m2-q.y*0.5) > 0.0 ? 0.0 : min(a,b);\n    \n    // recover 3D and scale, and add sign\n    return sqrt( (d2+q.z*q.z)/m2 ) * sign(max(q.z,-p.y));;\n}\n\n//Cylinder \nfloat sdCylinder( vec3 p, vec2 h )\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdCylinder(vec3 p, vec3 a, vec3 b, float r)\n{\n    vec3 pa = p - a;\n    vec3 ba = b - a;\n    float baba = dot(ba,ba);\n    float paba = dot(pa,ba);\n\n    float x = length(pa*baba-ba*paba) - r*baba;\n    float y = abs(paba-baba*0.5)-baba*0.5;\n    float x2 = x*x;\n    float y2 = y*y*baba;\n    float d = (max(x,y)<0.0)?-min(x2,y2):(((x>0.0)?x2:0.0)+((y>0.0)?y2:0.0));\n    return sign(d)*sqrt(abs(d))/baba;\n}\n\n\n///--------------------------///\n/// Scene SDFs and their IDs ///\n///--------------------------///\n\nfloat opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1.x : d2.x;\n}\n\n//Trees \n#define TREE_SPHERE_SDF_1 sphere(pos, 1.6, vec3(1.0, 1.5, 6.0)) //middle \n#define TREE_SPHERE_1 1\n#define TREE_SPHERE_SDF_2 sphere(pos, 1.9, vec3(-10.0, 1.5, 1.0)) //right\n#define TREE_SPHERE_2 2\n#define TREE_SPHERE_SDF_3 sphere(pos, 1.6, vec3(14.0, 1.5, 2.0)) //left\n#define TREE_SPHERE_3 12\n#define TREE_BASE_1 16\n#define TREE_BASE_1_SDF sdCylinder(pos-vec3(1.0, -0.5, 6.0), vec2(0.25,1.5))\n#define TREE_BASE_2 17\n#define TREE_BASE_2_SDF sdCylinder(pos-vec3(-10.0, -0.5, 1.0), vec2(0.25,1.5))\n#define TREE_BASE_3 18\n#define TREE_BASE_3_SDF sdCylinder(pos-vec3(14.0, -0.5, 2.0), vec2(0.25,1.5))\n\n//Houses \n#define HOUSE_CUBE_SDF_1 cube(pos, vec3(2.4, 3.5, 3.85), vec3(0., 30., 0.), vec3(-6., -0.25, 4.))\n#define HOUSE_CUBE_SDF_2 cube(pos, vec3(4., 4., 4.), vec3(0., -80., 0.), vec3(8., 0., 6.))\n#define HOUSE_CUBE_1 3\n#define HOUSE_CUBE_2 4\n#define HOUSE_TRI_PRISM_SDF_1 sdTriPrism_Ra( pos-vec3(8.0, 3.15, 6.0), vec2(2.25,2.05) )\n#define HOUSE_TRI_PRISM_SDF_2 sdTriPrism_Rb( pos-vec3(-6.0, 2.85, 4.0), vec2(2.45,1.25) )\n#define HOUSE_TRI_PRISM_1 5\n#define HOUSE_TRI_PRISM_2 6\n\n//Bushes \n#define BUSH_OCTA_SDF_1 sdOctahedron( pos-vec3(7.5, -1.25, 1.5), 0.95 )\n#define BUSH_OCTA_1 7\n#define BUSH_OCTA_SDF_2 sdOctahedron( pos-vec3(6.5, -1.25, 1.5), 0.95 )\n#define BUSH_OCTA_2 8\n#define BUSH_OCTA_SDF_3 sdOctahedron( pos-vec3(5.5, -1.25, 1.5), 0.95 )\n#define BUSH_OCTA_3 9\n#define BUSH_TRI_PRISM_SDF_1 sdTriPrism( pos-vec3(-9.0, -2., 2.0), vec2(0.5,0.35) )\n#define BUSH_TRI_PRISM_1 10\n#define BUSH_TRI_PRISM_SDF_2 sdTriPrism( pos-vec3(-8.5, -2., 2.0), vec2(0.5,0.35) )\n#define BUSH_TRI_PRISM_2 11\n\n//Tower \n#define TOWER_BOTTOM_SDF sdCylinder(pos-vec3(5.0,0.30,-4.0), vec2(0.3,2.2)) //width and height \n#define TOWER_BOTTOM 15\n#define TOWER_TOP_SDF  sdCylinder(pos-vec3(5.0,2.30,-4.0), vec2(1.2,1.0)) \n#define TOWER_TOP 13\n#define TOWER_CONE_SDF sdCone(pos - vec3(5.0,5.,-4.0), vec2(0.6,0.8), 1.8)\n#define TOWER_CONE 14 \n\n//Pine Tree \n#define PINE_1_SDF sdPyramid( pos-vec3(0.0,-1.75,-2.0), 2.5 )\n#define PINE_2_SDF sdPyramid( pos-vec3(0.0,-1.,-2.0), 2. )\n#define PINE_3_SDF sdPyramid( pos-vec3(0.0,-0.25,-2.0), 1.5 )\n#define PINE_1 19\n#define PINE_2 20\n#define PINE_3 21 \n\n//GIRL \n#define GIRL_HEAD_SDF sphere(pos, 0.4, vec3(-3.0, -0.2, 2.0))\n#define GIRL_HEAD  22\n#define GIRL_TOP_SDF sphere(pos, 0.35, vec3(-3.0, -0.8, 2.0))\n#define GIRL_TOP 23\n#define GIRL_BOTTOM_SDF sdCone(pos - vec3(-3.0, -0.95, 2.0), vec2(0.6,0.8), 1.4)\n#define GIRL_BOTTOM 24\n\n\n#define TORUS_SDF sdTorus(pos-vec3( 4.5,0.25, 4.0), vec2(1.60, .5))\n//#define OCTA_SDF sdOctahedron( pos-vec3(8., 0., 2.), 2.35 )\n\n///-----------------///\n/// Scene Functions ///\n///-----------------///\n\nvoid sceneMap3D(vec3 pos, out float t, out int obj) {    \n    //Shapes \n    //Trees \n    t = TREE_SPHERE_SDF_1;\n    obj = TREE_SPHERE_1;\n    vec2 res = vec2( 1e10, 0.0 );\n    float t2;\n\n    if((t2 = TREE_SPHERE_SDF_2 ) < t) {\n        t = t2;\n        obj = TREE_SPHERE_2;\n    }\n    if((t2 = TREE_SPHERE_SDF_3 ) < t) {\n        t = t2;\n        obj = TREE_SPHERE_3;\n    }\n    //Houses \n    if((t2 = HOUSE_CUBE_SDF_1) < t) {\n        t = t2;\n        obj = HOUSE_CUBE_1;\n    }\n    if((t2 = HOUSE_CUBE_SDF_2) < t) {\n        t = t2;\n        obj = HOUSE_CUBE_2;\n    }    \n    if((t2 = HOUSE_TRI_PRISM_SDF_1) < t) {\n        t = t2;\n        obj = HOUSE_TRI_PRISM_1;\n    }\n   if((t2 = HOUSE_TRI_PRISM_SDF_2) < t) {\n        t = t2;\n        obj = HOUSE_TRI_PRISM_2;\n    }\n    //Bushes \n    if((t2 = BUSH_OCTA_SDF_1 ) < t) {\n        t = t2;\n        obj = BUSH_OCTA_1;\n    }\n    if((t2 = BUSH_OCTA_SDF_2) < t) {\n        t = t2;\n        obj = BUSH_OCTA_2;\n    }\n    if((t2 = BUSH_OCTA_SDF_3) < t) {\n        t = t2;\n        obj = BUSH_OCTA_3;\n    }\n   if((t2 = BUSH_TRI_PRISM_SDF_1) < t) {\n        t = t2;\n        obj = BUSH_TRI_PRISM_1;\n    }\n       if((t2 = BUSH_TRI_PRISM_SDF_2) < t) {\n        t = t2;\n        obj = BUSH_TRI_PRISM_2;\n    }\n    //Tower  \n    if((t2 = TOWER_BOTTOM_SDF ) < t) {\n        t = t2;\n        obj = TOWER_BOTTOM;\n    }\n    if((t2 = TOWER_TOP_SDF) < t) {\n        t = t2;\n        obj = TOWER_TOP;\n    }\n    if((t2 = TOWER_CONE_SDF) < t) {\n        t = t2;\n        obj = TOWER_CONE;\n    }\n    \n    //Tree Bases \n    if((t2 = TREE_BASE_1_SDF ) < t) {\n        t = t2;\n        obj = TREE_BASE_1;\n    }\n    if((t2 = TREE_BASE_2_SDF ) < t) {\n        t = t2;\n        obj = TREE_BASE_2;\n    }\n    if((t2 = TREE_BASE_3_SDF ) < t) {\n        t = t2;\n        obj = TREE_BASE_3;\n    }\n    \n    //Pine Trees \n    if((t2 = PINE_1_SDF ) < t) {\n        t = t2;\n        obj = PINE_1;\n    }\n    if((t2 = PINE_2_SDF ) < t) {\n        t = t2;\n        obj = PINE_2;\n    }\n    if((t2 = PINE_3_SDF ) < t) {\n        t = t2;\n        obj = PINE_3;\n    }\n    \n    //Girl      \n     if((t2 = GIRL_HEAD_SDF ) < t) {\n        t = t2;\n        obj = GIRL_HEAD;\n    }\n    if((t2 = GIRL_TOP_SDF ) < t) {\n        t = t2;\n        obj = GIRL_TOP;\n    }\n    if((t2 = GIRL_BOTTOM_SDF ) < t) {\n        t = t2;\n        obj = GIRL_BOTTOM;\n    }\n        \n    //Ground \n    if((t2 = box(pos + vec3(0.0, 3.0, 0.0), vec3(50.0, 1.0, 50.0))) < t) {\n        t = t2;\n        obj = 0;\n    }\n\n}\n\n\nfloat sceneMap3D(vec3 pos) {\n    \n    float t = TREE_SPHERE_SDF_1;\n    \n    t = min(t, TREE_SPHERE_SDF_2);\n    t = min(t, TREE_SPHERE_SDF_3);\n    \n    t = min(t, HOUSE_CUBE_SDF_1);\n    t = min(t, HOUSE_CUBE_SDF_2);    \n    t = min(t, HOUSE_TRI_PRISM_SDF_1);\n    t = min(t, HOUSE_TRI_PRISM_SDF_2);\n    \n    t = min(t, BUSH_OCTA_SDF_1);\n    t = min(t, BUSH_OCTA_SDF_2);\n    t = min(t, BUSH_OCTA_SDF_3);\n    t = min(t, BUSH_TRI_PRISM_SDF_1);\n    t = min(t, BUSH_TRI_PRISM_SDF_2);\n    \n    t = min(t, TOWER_BOTTOM_SDF);\n    t = min(t, TOWER_TOP_SDF);\n    t = min(t, TOWER_CONE_SDF);\n    \n    t = min(t, TREE_BASE_1_SDF);\n    t = min(t, TREE_BASE_2_SDF);\n    t = min(t, TREE_BASE_3_SDF);\n    \n    t = min(t, PINE_1_SDF);\n    t = min(t, PINE_2_SDF);\n    t = min(t, PINE_3_SDF);\n    \n    t = min(t, GIRL_BOTTOM_SDF);\n    t = min(t, GIRL_TOP_SDF);\n    t = min(t, GIRL_HEAD_SDF);\n    \n    \n    t = min(t, box(pos + vec3(0.0, 3.0, 0.0), vec3(50.0, 1.0, 50.0)));\n    return t;\n}\n\nvec3 computeNormal(vec3 pos) {\n    vec3 epsilon = vec3(0.0, 0.001, 0.0);\n    return normalize( vec3( sceneMap3D(pos + epsilon.yxx) - sceneMap3D(pos - epsilon.yxx),\n                            sceneMap3D(pos + epsilon.xyx) - sceneMap3D(pos - epsilon.xyx),\n                            sceneMap3D(pos + epsilon.xxy) - sceneMap3D(pos - epsilon.xxy)));\n}\n\nvoid rayMarch(vec3 origin, vec3 dir, out float t, out int hitObj) {\n    t = 0.001;\n    for(int i = 0; i < RAY_STEPS; ++i) {\n     if( t > 45.0) \n         { break; }\n        vec3 pos = origin + t * dir;\n    \tfloat m;\n        sceneMap3D(pos, m, hitObj);\n        if(m < 0.01) {\n            return;\n        }\n        t += m;\n    }\n    t = -1.0;\n    hitObj = -1;\n}\n\n\n///------------------SHADOWS, AO and SUBSURFACE----------------------///\n\n\nfloat hardShadow(vec3 dir, vec3 origin, float min_t) {\n    float t = min_t;\n    for(int i = 0; i < RAY_STEPS; ++i) {\n        float m = sceneMap3D(origin + t * dir);\n        if(m < 0.0001) {\n            return 0.0;\n        }\n        t += m;\n    }\n    return 1.0;\n}\n\nfloat softShadow(vec3 dir, vec3 origin, float min_t, float k) {\n    float res = 1.0;\n    float t = min_t;\n    for(int i = 0; i < RAY_STEPS; ++i) {\n         if( t > 45.0) \n         { break; }\n        float m = sceneMap3D(origin + t * dir);\n        if(m < 0.0001) {\n            return 0.0;\n        }\n        res = min(res, k * m / t);\n        t += m;\n    }\n    return res;\n}\n\nfloat shadow(vec3 dir, vec3 origin, float min_t) {\n    #if HARD_SHADOW\n    return hardShadow(dir, origin, min_t);\n    #else\n    return softShadow(dir, origin, min_t, SHADOW_HARDNESS);\n    #endif\n}\n\nfloat subsurface(vec3 lightDir, vec3 normal, vec3 viewVec, float thickness) {\n    vec3 scatteredLightDir = lightDir + normal * DISTORTION;\n    float lightReachingEye = pow(clamp(dot(viewVec, -scatteredLightDir), 0.0, 1.0), GLOW) * BSSRDF_SCALE;\n    float attenuation = 1.0;\n    #if ATTENUATION\n    attenuation = max(0.0, dot(normal, lightDir) + dot(viewVec, -lightDir));\n    #endif\n\tfloat totalLight = attenuation * (lightReachingEye + AMBIENT) * thickness;\n    return totalLight;\n}\n\n///-----------------------------------------///\n\nvec3 computeMaterial(int hitObj, vec3 p, vec3 n, vec3 light, vec3 view) \n{\n    float thick = 0.5f;\n    float t;\n    switch(hitObj) {        \n            \n    \n        //Subsurface         \n        case TREE_SPHERE_1:\n        case TREE_SPHERE_2:\n        case TREE_SPHERE_3:\n        case BUSH_OCTA_1:\n        case BUSH_OCTA_2:\n        case BUSH_OCTA_3:\n        case BUSH_TRI_PRISM_1: \n        case BUSH_TRI_PRISM_2:\n        case PINE_1 :\n        case PINE_2:\n        case PINE_3:\n        #ifdef SUB_SURFACE_ON\n        vec3 color = vec3(0.0, 1.0, 0.0) * vec3(0.4, 0.8, 0.3) * max(0.0, dot(n, light)) * shadow(light, p, 0.1);\n        return color + vec3(0.0, 1.0, 0.0) * subsurface(light, n, view, thick) * vec3(1.0, 0.88, 0.7);\n        break;\n        #else\n        return vec3(0.3, 0.8, 0.0);\n        break;\n        #endif\n        \n        case HOUSE_CUBE_1:\n        case HOUSE_CUBE_2:\n        case TOWER_BOTTOM:\n        case TOWER_TOP:\n        return vec3(1.0, 1.0, 1.0);\n        break;\n        \n        case HOUSE_TRI_PRISM_1:\n        case HOUSE_TRI_PRISM_2:\n        case TOWER_CONE:\n        return vec3(0.87, 0.47, 0.05);\n        break;\n        \n        case GIRL_HEAD:\n        #ifdef SUB_SURFACE_ON\n        color = vec3(0.9, 0.9, 0.850) * vec3(1., 1., 1.) * max(0.0, dot(n, light)) * shadow(light, p, 0.1);\n        return color + vec3(0.9, 0.9, 0.850) * subsurface(light, n, view, thick) * vec3(1.0, 0.88, 0.7);\n        break;\n        #else\n        return vec3(0.9, 0.9, 0.85);\n        break;\n        #endif\n              \n        case GIRL_TOP:\n        case GIRL_BOTTOM:\n        #ifdef SUB_SURFACE_ON\n        color = vec3(0.65, 0.09, 0.55) * vec3(0.55, 0.03, 0.25) * max(0.0, dot(n, light)) * shadow(light, p, 0.1);\n        return color + vec3(0.65, 0.09, 0.55) * subsurface(light, n, view, thick) * vec3(1.0, 0.88, 0.7);\n        break;\n        #else\n        return vec3(0.65, 0.09, 0.55);\n        break;\n        #endif       \n        \n        case TREE_BASE_1:\n        case TREE_BASE_2:\n        case TREE_BASE_3:\n        return vec3(0.8, 0.5, 0.4); //Brown \n        break;\n        \n        case 0:\n        //t = floor(mod(0.5 * (sin(p.x) + sin(p.z)), 1.0));\n        //return mix(vec3(0.1), vec3(0.5), t);\n        //return vec3(0.45, 0.75, 0.54);\n        return vec3(0.8, 0.8, 0.6);\n        //return mix(vec3(0.8, 0.8, 0.6), vec3(0.6, 0.6, 0.2), t);\n        break;\n\n        case -1:\n        // Background\n        return vec3(1., 1., 1.);\n        break;\n    }\n    return vec3(1., 1., 1.);\n}\n\n\n//Takes a ray in the scene and returns an intersection \nIntersection sceneIntersection(Ray ray) \n{\n    //To be set \n    float t;\n    int hitObj;\n    \n    //RayMarch will set t and object hit by raymarching using SDFs \n    rayMarch(ray.origin, ray.dir, t, hitObj);\n\n    //Intersection point in our scene \n    vec3 isect_point = ray.origin + t * ray.dir;\n    \n    //Normal at POI  \n    vec3 nor = computeNormal(isect_point);\n    #ifdef SUB_SURFACE_ON\n    vec3 lightDir = rotateZ(vec3(6.0, 5.0, -1.0), sin(iTime) * 0.7);\n    #else\n    vec3 lightDir = normalize(lightPos - isect_point);\n    #endif\n    \n    //Compute Material returns color at the POI \n    vec3 material = computeMaterial(hitObj, isect_point, nor, lightDir, \n                                        normalize(ray.origin - isect_point));\n    \n\n    #ifdef MOVE_SUN\n    vec3 warmDir = rotateY(normalize(vec3(1.0, 1.0, 1.0)),  sin(iTime * 0.5));\n    vec3 coolDir = rotateY(normalize(vec3(-1.0, 0.0, -1.0)), sin(iTime * 0.5));\n    #else\n    vec3 warmDir = rotateY(normalize(vec3(1.0, 1.0, 1.0)),  90.);\n    vec3 coolDir = rotateY(normalize(vec3(-1.0, 0.0, -1.0)), 90.);\n    #endif    \n\n    float warmDot = max(0.0, dot(nor, warmDir));\n    float coolDot = max(0.0, dot(nor, coolDir));\n\n    vec3 overallColor = warmDot * vec3(1.0, 0.88, 0.7) * shadow(warmDir, isect_point, 0.1);\n    overallColor += coolDot * vec3(0.05, 0.2, 0.5);\n    overallColor *= material;\n    overallColor = clamp(overallColor + vec3(0.05, 0.1, 0.15), 0.0, 1.0);\n    \n    vec3 sdfColor = overallColor;\n \n    return Intersection(t, sdfColor, isect_point, hitObj);\n}\n\n// Returns direction of ray\nRay rayCast(vec3 eye, vec3 ref, vec2 ndc) \n{\n    vec3 F = ref - eye;\n    vec3 R = normalize(cross(F, vec3(0,1,0)));\n    vec3 U = normalize(cross(R, F));\n    \n    vec3 V = U * length(F) * tan(FOVY * 0.5);\n    vec3 H = R * length(F) * tan(FOVY * 0.5) * float(iResolution.x) / iResolution.y;\n    \n    vec3 p = ref + ndc.x * H + ndc.y * V;\n    \n    return Ray(eye, normalize(p - eye));\n}\n\n///---------------///\n/// Main Function ///\n///---------------///\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    //Anti aliasing    \n    if(ANTIALIASING == 1)\n    {  \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    // [-1, 1]\n    vec2 uv2 = 2.0 * uv - vec2(1.0);\n    \n    Intersection aaIsects[4];\n    //Camera's eye and reference points \n\n    vec3 eye = vec3(-4, 6., -16.);\n    vec3 ref = vec3(0, 3.5, 0);\n    int idx = 0;\n    for(float i = 0.0; i < 1.0; i += 0.5) {\n        for(float j = 0.0; j < 1.0; j += 0.5) {\n            vec2 ndc = uv2 + vec2(i, j) / iResolution.xy;\n            Ray ray = rayCast(eye, ref, ndc);\n            aaIsects[idx++] = sceneIntersection(ray);\n        }\n    }\n        \n    vec3 avgColor = vec3(0.0);\n    for(int i = 0; i < 4; ++i) {\n        avgColor += aaIsects[i].color;\n    }\n        \n    avgColor *= 0.25;\n    \n    #ifdef DOF\n    float distAlongCamZ = abs(dot(normalize(ref - eye), (aaIsects[0].p - eye)));\n    float dofZ = min(1.0, abs(distAlongCamZ - FOCAL_LENGTH) / FOCAL_RANGE);\n    dofZ = pow(dofZ, 0.5);\n\n    fragColor = vec4(avgColor * step(0.0, aaIsects[0].t), dofZ);\n    float fogT = smoothstep(50.0, 100.0, distance(aaIsects[0].p, eye));\n    fragColor.rgb = mix(fragColor.rgb, vec3(0.0), fogT);\n    #endif \n    \n   #ifdef NO_DOF \n        fragColor = vec4(avgColor.rgb, 1.);\n    #endif\n    \n    }\n    else //No Anti aliasing\n    {\n        // Normalized pixel coordinates (from 0 to 1)\n        vec2 uv = fragCoord / iResolution.xy;\n        // Convert to range [-1, 1]\n        uv = uv * 2.0 - vec2(1.0, 1.0);\n\n        //Camera's eye and reference points \n        vec3 eye = vec3(0, 3.5, -15.);\n        vec3 ref = vec3(0, 2.5, 0);\n        \n\n        //Ray cast returns a ray in the camera's direction to the reference point \n        Ray ray = rayCast(eye, ref, uv);\n\n        //Scene Intersection \n        Intersection isect = sceneIntersection(ray);\n        vec3 avgColor = isect.color;\n    \n        #ifdef DOF\n            float distAlongCamZ = abs(dot(normalize(ref - eye), (isect.p - eye)));\n            float dofZ = min(1.0, abs(distAlongCamZ - FOCAL_LENGTH) / FOCAL_RANGE);\n            dofZ = pow(dofZ, 0.5);\n            fragColor = vec4(avgColor * step(0.0, isect.t), dofZ);\n            float fogT = smoothstep(50.0, 100.0, distance(isect.p , eye));\n            fragColor.rgb = mix(fragColor.rgb, vec3(0.0), fogT);\n        #endif \n\n       #ifdef NO_DOF \n            fragColor = vec4(avgColor.rgb, 1.);\n        #endif\n    }\n}","name":"Image","description":"","type":"image"}]}