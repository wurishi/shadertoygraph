{"ver":"0.1","info":{"id":"MdtyRN","date":"1518124612","viewed":181,"name":"tri-colored cube gif","username":"wpchop","description":"Recreating a gif for CIS566.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["orthographic"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.141592653589\nconst int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float EPSILON = 0.0001;\nconst vec3 GREEN = vec3(170.0/255.0, 217.0/255.0,197.0/255.0);\nconst vec3 PINK = vec3(231.0/255.0, 81.0/255.0, 129.0/255.0);\nconst vec3 PURPLE = vec3(81.0/255.0,66.0/255.0, 95.0/255.0);\n\n/**\n * Rotation matrix around the Y axis.\n */\nmat3 rotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, 0, s),\n        vec3(0, 1, 0),\n        vec3(-s, 0, c)\n    );\n}\n\n/**\n * Rotation matrix around the Z axis.\n */\nmat3 rotateZ(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, -s, 0),\n        vec3(s, c, 0),\n        vec3(0, 0, 1)\n    );\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sceneSDF(vec3 samplePoint, float theta, float thetaZ) {\n    mat3 rotate = rotateY(radians(theta));\n    mat3 rotateZ = rotateZ(radians(thetaZ));\n    return sdBox(rotateZ * rotate * samplePoint, vec3(0.55));\n}\n\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start,\n                                float end, float theta, float thetaZ) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        vec3 samplePt = vec3(eye + depth * marchingDirection);\n        float dist = sceneSDF(samplePt, theta, thetaZ);\n        if (dist < EPSILON) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n\n\n// theta is rotation around Y, z is rotation around z\nvec3 estimateNormal(vec3 p, float theta, float z) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z), theta, z) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z), theta, z),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z), theta, z) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z), theta, z),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON), theta, z) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON), theta, z)\n    ));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    float aspect = iResolution.x/iResolution.y;\n    \n    // Transform to NDC\n    vec2 srcPt = uv * 2.0 - 1.0; \n    float sx = srcPt.x;\n\tfloat sy = srcPt.y;\n    srcPt.x *= aspect;\n    \n    ////////////////////// Camera stuff\n    // camera position\n\tvec3 c_pos = vec3(8.0, 8.0, 8.0);\n    // camera target\n    vec3 c_targ = vec3(0.0, 0.0, 0.0);\n    // camera direction\n    vec3 c_dir = normalize(c_targ - c_pos);\n    // camera right\n    vec3 c_right = vec3(1.0,0.0,-1.0);\n    // camera up\n    vec3 c_up = cross( c_right, c_dir);\n    \n    // compute the ray direction\n    vec3 r_dir = normalize(c_dir);\n\n    // THE CAMERA EYE\n    vec3 eye = c_pos + c_right * sx * aspect + c_up * sy;\n        \n    mat2 rot1;\n    float theta = - PI / 6.0;\n\n    float cosTheta, sinTheta;\n    cosTheta = cos(theta);\n    sinTheta = sin(theta);\n    rot1[0][0] = cosTheta;\n    rot1[0][1] = -sinTheta;\n    rot1[1][0] = sinTheta;\n    rot1[1][1] = cosTheta;\n    \n    float time = mod(iTime,3.5);\n    \n   \tfloat dist = shortestDistanceToSurface(eye, r_dir, MIN_DIST, MAX_DIST, 0.0, 0.0);\n    \n    float step = 0.5;\n    if (time < step) {\n        // rotate colors clockwise\n        // Green goes from left to top\n        mat2 rot;\n        float scale = 2.0 * PI / 3.0 / step;\n        theta = - time * scale - PI/6.0;\n\n        cosTheta, sinTheta;\n        cosTheta = cos(theta);\n        sinTheta = sin(theta);\n        rot[0][0] = cosTheta;\n        rot[0][1] = -sinTheta;\n        rot[1][0] = sinTheta;\n        rot[1][1] = cosTheta;\n        \n        vec2 sPtRot = rot * srcPt;\n    \n  \t\tfloat angle = 1.0 - (atan(sPtRot.y, sPtRot.x) / 6.28 + 0.5);\n    \n        if (angle < 0.3333333) {\n         \tfragColor = vec4(PURPLE, 1.0);\n        } else if (angle < 0.6666666) {\n         \tfragColor = vec4(PINK, 1.0);   \n        } else {\n            fragColor = vec4(GREEN, 1.0);\n        }\n        \n\t\tfloat dist = shortestDistanceToSurface(eye, r_dir, MIN_DIST, MAX_DIST, 0.0,0.0);\n\n        if (dist > MAX_DIST - EPSILON) {\n            // Didn't hit anything\n            fragColor = vec4(250.0/255.0, 250.0/255.0, 250.0/ 255.0, 1.0);\n            return;\n        }\n        \n        return;        \n    } else if (time < step * 2.0) {\n        // keeps cube with green on top for a bit\n        vec2 sPtRot = rot1 * srcPt;\n    \n  \t\tfloat angle = 1.0 - (atan(sPtRot.y, sPtRot.x) / 6.28 + 0.5);\n    \n        if (angle < 0.3333333) {\n         \tfragColor = vec4(GREEN, 1.0);\n        } else if (angle < 0.6666666) {\n         \tfragColor = vec4(PURPLE, 1.0);   \n        } else {\n            fragColor = vec4(PINK, 1.0);\n        }\n        \n        \n        float dist = shortestDistanceToSurface(eye, r_dir, MIN_DIST, MAX_DIST, 0.0,0.0);\n\n        if (dist > MAX_DIST - EPSILON) {\n            // Didn't hit anything\n            fragColor = vec4(250.0/255.0, 250.0/255.0, 250.0/ 255.0, 1.0);\n            return;\n        }\n        \n        return;   \n    } else if (time < step * 3.0) {\n        // TODO!!!!!\n        // rotate cube about y axis\n        \n        float thetaY = - (time - step * 2.0) * 90.0 / step;\n        \n       \tfloat dist = shortestDistanceToSurface(eye, r_dir, MIN_DIST, MAX_DIST, thetaY, 0.0);\n        if (dist > MAX_DIST - EPSILON) {\n            // Didn't hit anything\n            fragColor = vec4(250.0/255.0, 250.0/255.0, 250.0/ 255.0, 1.0);\n            return;\n        }\n        \n        float dist2 = shortestDistanceToSurface(eye, c_dir, MIN_DIST, MAX_DIST, thetaY, 0.0);\n        \n        vec3 p = eye + c_dir * dist2;\n    \tvec3 normal = (estimateNormal(p, thetaY, 0.0));\n        float pink = normal.x - normal.z;\n        float purple = normal.z - normal.x;\n        \n        vec3 color = GREEN;\n        if (normal.y > 0.0) {\n            fragColor = vec4(color, 1.0);\n         \treturn;   \n        }\n        if (thetaY > -45.0) {\n            if (purple > 0.0) {\n             \tcolor = PINK;   \n            } else {\n             \tcolor = PURPLE;   \n            }\n        } else {\n            if (purple > 0.0) {\n             \tcolor = PURPLE; \n            } else {\n             \tcolor = PINK;   \n            }\n        }\n        \n       \tfragColor = vec4(color, 1.0);\n        return;\n    } else if (time < step * 3.5 ) {\n        // keeps cube with green on top, pink and then purple        \n        vec2 sPtRot = rot1 * srcPt;\n    \n  \t\tfloat angle = 1.0 - (atan(sPtRot.y, sPtRot.x) / 6.28 + 0.5);\n    \n        if (angle < 0.3333333) {\n         \tfragColor = vec4(GREEN, 1.0);\n        } else if (angle < 0.6666666) {\n         \tfragColor = vec4(PINK, 1.0);   \n        } else {\n            fragColor = vec4(PURPLE, 1.0);\n        }\n        \n        float dist = shortestDistanceToSurface(eye, r_dir, MIN_DIST, MAX_DIST, 0.0, 0.0);\n\n        if (dist > MAX_DIST - EPSILON) {\n            // Didn't hit anything\n            fragColor = vec4(250.0/255.0, 250.0/255.0, 250.0/ 255.0, 1.0);\n            return;\n        }\n        return;   \n    } else if ( time < step * 4.5) {\n        // SPIN COLORS COUNTER CLOCKWISE!!\n      \tmat2 rot;\n        float scale = 2.0 * PI / 3.0 / step;\n        theta = (time  - step * 3.5) * scale - PI/6.0;\n\n        cosTheta, sinTheta;\n        cosTheta = cos(theta);\n        sinTheta = sin(theta);\n        rot[0][0] = cosTheta;\n        rot[0][1] = -sinTheta;\n        rot[1][0] = sinTheta;\n        rot[1][1] = cosTheta;\n        \n        vec2 sPtRot = rot * srcPt;\n    \n  \t\tfloat angle = 1.0 - (atan(sPtRot.y, sPtRot.x) / 6.28 + 0.5);\n    \n        if (angle < 0.3333333) {\n         \tfragColor = vec4(GREEN, 1.0);\n        } else if (angle < 0.6666666) {\n         \tfragColor = vec4(PINK, 1.0);   \n        } else {\n            fragColor = vec4(PURPLE, 1.0);\n        }\n        \n\t\tfloat dist = shortestDistanceToSurface(eye, r_dir, MIN_DIST, MAX_DIST, 0.0, 0.0);\n\n        if (dist > MAX_DIST - EPSILON) {\n            // Didn't hit anything\n            fragColor = vec4(250.0/255.0, 250.0/255.0, 250.0/ 255.0, 1.0);\n            return;\n        }\n        \n        return;        \n             \n    } else if (time < step * 5.0) {\n        // keeps cube with pink on top, purple and then pink\n        vec2 sPtRot = rot1 * srcPt;\n    \n  \t\tfloat angle = 1.0 - (atan(sPtRot.y, sPtRot.x) / 6.28 + 0.5);\n    \n        if (angle < 0.3333333) {\n         \tfragColor = vec4(PINK, 1.0);\n        } else if (angle < 0.6666666) {\n         \tfragColor = vec4(PURPLE, 1.0);   \n        } else {\n            fragColor = vec4(GREEN, 1.0);\n        }\n        \n        float dist = shortestDistanceToSurface(eye, r_dir, MIN_DIST, MAX_DIST, 0.0, 0.0);\n\n        if (dist > MAX_DIST - EPSILON) {\n            // Didn't hit anything\n            fragColor = vec4(250.0/255.0, 250.0/255.0, 250.0/ 255.0, 1.0);\n            return;\n        }\n        return;  \n    } else if (time < step * 6.0) {\n        // ROTATE Z\n        \n        float thetaZ = (time - step * 5.0) * 90.0 / step;\n        \n       \tfloat dist = shortestDistanceToSurface(eye, r_dir, MIN_DIST, MAX_DIST, 0.0, thetaZ);\n        if (dist > MAX_DIST - EPSILON) {\n            // Didn't hit anything\n            fragColor = vec4(250.0/255.0, 250.0/255.0, 250.0/ 255.0, 1.0);\n            return;\n        }\n        \n        float dist2 = shortestDistanceToSurface(eye, c_dir, MIN_DIST, MAX_DIST, 0.0, thetaZ);\n        \n        vec3 p = eye + c_dir * dist2;\n    \tvec3 normal = (estimateNormal(p, 0.0, thetaZ));\n        float pink = normal.x - normal.y;\n        float purple = normal.y - normal.x;\n        \n        vec3 color = GREEN;\n        if (normal.z > 0.0) {\n            fragColor = vec4(color, 1.0);\n         \treturn;   \n        }\n        if (thetaZ < 45.0) {\n            if (purple > 0.0) {\n             \tcolor = PINK;   \n            } else {\n             \tcolor = PURPLE;   \n            }\n        } else {\n            if (purple > 0.0) {\n             \tcolor = PURPLE; \n            } else {\n             \tcolor = PINK;   \n            }\n        }\n        \n       \tfragColor = vec4(color, 1.0);\n        return;\n        \n    } else {\n        // keeps cube with green on top, pink and then purple\n        vec2 sPtRot = rot1 * srcPt;\n    \n  \t\tfloat angle = 1.0 - (atan(sPtRot.y, sPtRot.x) / 6.28 + 0.5);\n    \n        if (angle < 0.3333333) {\n         \tfragColor = vec4(PURPLE, 1.0);\n        } else if (angle < 0.6666666) {\n         \tfragColor = vec4(PINK, 1.0);   \n        } else {\n            fragColor = vec4(GREEN, 1.0);\n        }\n        \n        float dist = shortestDistanceToSurface(eye, r_dir, MIN_DIST, MAX_DIST, 0.0, 0.0);\n\n        if (dist > MAX_DIST - EPSILON) {\n            // Didn't hit anything\n            fragColor = vec4(250.0/255.0, 250.0/255.0, 250.0/ 255.0, 1.0);\n            return;\n        }\n        return;  \n    }\n    \n    vec3 p = c_pos + c_dir * dist;\n    vec3 normal = estimateNormal(p, 0.0, 0.0);\n    \n    // Time varying pixel color\n    // vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    \n    vec3 color = normal.x * PINK + normal.y * PURPLE + normal.z * GREEN;\n\n    // Output to screen\n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}