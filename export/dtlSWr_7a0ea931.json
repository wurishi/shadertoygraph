{"ver":"0.1","info":{"id":"dtlSWr","date":"1674609059","viewed":120,"name":"Inside the Hypersphere","username":"zsrail","description":"This is a scene from inside the hypersphere (S^3). It may look like the red ball is moving back and forth, but it is actually constantly moving towards you in a \"straight line\" (a geodesic). The light from the white ball gives clues that this is the case.","likes":2,"published":1,"flags":48,"usePreview":0,"tags":["raymarching","geometry","spherical","hypersphere","s3"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float signed_dist(vec4 pos);\nvec4 march(vec4 pos, vec4 dir, float dist);\nvec3 phong(vec4 pos, vec4 ray_dir, float dist_traveled);\n\nconst float epsilon = 0.0001;\nconst float pi = 3.141592653589;\nconst float right_angle = 1.570796326794;\n\nvec4 position;\nvec4 facing;\nvec4 up;\nvec4 right;\n\n//vec3 grid_color = vec3(0.5,0.1,0.8);\n\n//vec4 ground_center;\n//float ground_radius = 1.5;\n//vec3 ground_color = vec3(0.5,0.1,0.8);\n\nfloat tube_radius = pi/4.0 + 0.01;\nvec4 tube_center = vec4(0,0,0,1);\nvec4 tube_dir = vec4(0,0,1,0);\nvec3 tube_color1 = vec3(0.9,0.1,0.5);\nvec3 tube_color2 = vec3(0.2,0.1,0.6);\n\n\nvec4 window_center1;\nvec4 window_center2;\nvec4 window_center3;\nconst vec4 window_dir1 = vec4(1.0,0.0,0.0,0.0);\nconst vec4 window_dir2 = vec4(0.5*sqrt(2.0),0.5*sqrt(2.0),0.0,0.0);\nconst vec4 window_dir3 = vec4(-0.5*sqrt(2.0),0.5*sqrt(2.0),0.0,0.0);\n\nvec4 ball_center = vec4(0.0, 0.0, 1.0, 0.0);\nfloat ball_radius = 0.4;\nvec3 ball_color = vec3(1.0,0.1,0.1);\n\nvec4 light_center = normalize(vec4(0.0,-0.5,0.866,0.0));\nfloat light_radius = 0.05;\nvec3 light_color = vec3(1,1,1);\nfloat base_light_intensity = 3.0;\n\nbool near_light = false;\nvec3 nearest_color;\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    position = texelFetch(iChannel0, ivec2(0,0), 0);\n    facing = texelFetch(iChannel0, ivec2(1,0), 0);\n    up = texelFetch(iChannel0, ivec2(2,0), 0);\n    right = texelFetch(iChannel0, ivec2(3,0), 0);\n\n    vec2 uv = 3.0*(fragCoord-0.5*iResolution.xy)/iResolution.x;\n    vec4 march_pos = position;\n    vec4 ray_dir = normalize(facing + uv.x*right + uv.y*up); //vec4(uv, facing.zw));\n    \n    //ground_center = march(focal_point, vec4(0.0,-1.0,0.0,0.0), 1.6);\n    ball_center = vec4(0.0, 0.0, cos(0.5*iTime), sin(0.5*iTime));\n    window_center1 = march(tube_center, tube_dir, 1.0);\n    window_center2 = march(tube_center, tube_dir, 2.0);\n    \n    float sd = signed_dist(march_pos);\n    float dist_traveled = 0.0;\n    \n    if(sd < 0.0)\n        fragColor = vec4(0,0,0,1);\n    else\n    {\n    \n        for(int i=1;i<300;i++)\n        {\n            dist_traveled += sd;\n            march_pos = march(position, ray_dir, dist_traveled);\n            sd = signed_dist(march_pos);\n            \n            if(sd < epsilon || dist_traveled >= 6.3)\n                break;\n        }\n\n\n        vec3 col = vec3(0);\n        if(sd < epsilon)\n            col = phong(march_pos, ray_dir, dist_traveled);\n\n        // Output to screen\n        fragColor = vec4(col,1.0);\n    }\n}\n\nvec4 sd_grad(vec4 pos)\n{\n    float delta = 0.0001;\n    vec4 grad = vec4(0,0,0,0);\n    \n    float sd = signed_dist(pos);\n    \n    grad.x = (signed_dist(pos+vec4(delta,0.0,0.0,0.0))-sd)/delta;\n    grad.y = (signed_dist(pos+vec4(0.0,delta,0.0,0.0))-sd)/delta;\n    grad.z = (signed_dist(pos+vec4(0.0,0.0,delta,0.0))-sd)/delta;\n    grad.w = (signed_dist(pos+vec4(0.0,0.0,0.0,delta))-sd)/delta;\n    \n    return grad;\n}\n\nvec4 project(vec4 base, vec4 v)\n{\n    vec4 normal_component = dot(v, base)*base;\n    return v - normal_component;\n}\n\nvec4 dir_vec(vec4 initial_point, vec4 final_point)\n{\n    vec4 diff = final_point - initial_point;\n    return normalize(project(initial_point, diff));\n}\n\nfloat dist(vec4 P, vec4 Q)\n{\n    return acos(dot(P, Q));\n}\n\nfloat fog(float dist)\n{\n    float K = 6.283;\n    return exp(-0.5*dist);\n    //return 1.-min(dist/K, 1.);\n}\n\nvec3 phong(vec4 pos, vec4 ray_dir, float dist_traveled)\n{\n    float k_amb = 0.1;\n    float k_diff = 0.45;\n    float k_spect = 0.45;\n    float alpha = 15.;\n    \n    vec3 color = nearest_color;\n    \n    vec4 N = normalize(project(pos, sd_grad(pos)));\n    if(near_light)\n        N = -N;\n    \n    vec4 V = normalize(sin(dist_traveled)*position-cos(dist_traveled)*ray_dir);\n    vec4 L1 = dir_vec(pos, light_center);\n    vec4 L2 = -L1;\n    vec4 R1 = reflect(-L1, N);\n    vec4 R2 = -R1;\n    \n    float short_dist = dist(pos,light_center);\n    float long_dist = 6.283-short_dist;\n    float sin_short_dist = sin(short_dist);\n    float sin_long_dist = sin(long_dist);\n    float I_L1 = base_light_intensity/(sin_short_dist*sin_short_dist);\n    float I_L2 = base_light_intensity/(sin_long_dist*sin_long_dist);\n    \n    vec3 col1 = (k_diff*max(0.,dot(L1,N))+k_spect*pow(max(0.,dot(R1,V)),alpha))*light_color*color;\n    vec3 col2 = (k_diff*max(0.,dot(L2,N))+k_spect*pow(max(0.,dot(R2,V)),alpha))*light_color*color;\n    vec3 avg = (I_L1*col1+I_L2*col2);\n    \n    return fog(dist_traveled)*(k_amb*color + avg);\n    \n}\n\nvec4 march(vec4 pos, vec4 dir, float dist)\n{\n    return cos(dist)*pos+sin(dist)*dir;\n}\n\nfloat sphere_sd(vec4 pos, vec4 center, float radius)\n{\n    return dist(pos, center)-radius;\n}\n\nvec4 qmult(vec4 a, vec4 b)\n{\n    vec4 prod = vec4(0.0);\n    prod.x = a.x*b.x-a.y*b.y-a.z*b.z-a.w*b.w;\n    prod.y = a.x*b.y+a.y*b.x+a.z*b.w-a.w*b.z;\n    prod.z = a.x*b.z+a.z*b.x-a.y*b.w+a.w*b.y;\n    prod.w = a.x*b.w+a.w*b.x+a.y*b.z-a.z*b.y;\n    \n    return prod;\n}\n\nvec4 mod_quaternion(vec4 p)\n{\n    vec4 mags = abs(p);\n    int max_mag = 0;\n    float inv_sign = 1.0;\n    for(int i=1;i<4;i++)\n    {\n        if(mags[i] > mags[max_mag])\n        {\n            max_mag = i;\n            inv_sign = -1.0;\n        }\n    }\n    \n    inv_sign *= sign(p[max_mag]);\n    \n    switch(max_mag)\n    {\n        case 0: return inv_sign*p;\n        case 1: return inv_sign*vec4(-p.y,p.x,-p.w,p.z);\n        case 2: return inv_sign*vec4(-p.z,p.w,p.x,-p.y);\n        case 3: return inv_sign*vec4(-p.w,-p.z,p.y,p.x);\n    }\n    \n    //vec4 inv = vec4(0.0);\n    //inv[max_mag] = inv_sign*sign(p[max_mag]);\n    \n    //return qmult(inv, p);\n}\n\nfloat quaternion_sd2(vec4 pos)\n{\n    vec4 fcoords = mod_quaternion(pos);\n    return -sphere_sd(fcoords, vec4(1.0,0.0,0.0,0.0), 0.9);\n}\n\nfloat quaternion_sd(vec4 pos)\n{\n    float sd = -1.0/0.0;\n    float tile_radius = 0.9;\n    \n    for(int i=0;i<4;i++)\n    {\n        vec4 top = vec4(0.0);\n        top[i] = 1.0;\n        float top_sd = sphere_sd(pos, top, tile_radius);\n        \n        vec4 bottom = vec4(0.0);\n        bottom[i] = -1.0;\n        float bottom_sd = sphere_sd(pos, bottom, tile_radius);\n        \n        sd = max(sd, -min(top_sd, bottom_sd)); \n    }\n    \n    return sd;\n}\n\nfloat cylinder_sd(vec4 pos, vec4 center, vec4 dir, float radius)\n{\n    vec4 normal = pos - dot(pos,center)*center - dot(pos, dir)*dir;\n    return asin(length(normal)) - radius;\n}\n\nfloat cylinder_sd2(vec4 pos, float radius)\n{\n    return asin(sqrt(pos.x*pos.x+pos.y*pos.y)) - radius;\n}\n\nfloat oval_cylinder_sd(vec4 pos, float radius)\n{\n    return asin(sqrt(0.25*pos.x*pos.x+0.75*pos.y*pos.y)) - 0.5*radius;\n}\n\nfloat framed_cylinder_sd(vec4 pos, vec4 center, vec4 dir, float radius, float thickness)\n{\n    thickness = max(thickness, 0.0001);\n    vec4 normal = pos - dot(pos,center)*center - dot(pos, dir)*dir;\n    float r = asin(length(normal));\n    float core = r - radius + 2.0*thickness;\n    float frame = abs(r - radius) - thickness;\n    \n    return min(core,frame);\n}\n\nfloat tube_sd(vec4 pos, float radius)\n{\n    float inner = -cylinder_sd(pos, tube_center, tube_dir, radius);\n    float outer = -cylinder_sd(pos, tube_center, tube_dir, radius + 0.05);\n    float shell = max(inner, -outer);\n    \n    float window1 = framed_cylinder_sd(pos, window_center1, window_dir1, 0.25*radius, 0.02*abs(sin(iTime)));\n    float window2 = framed_cylinder_sd(pos, window_center1, window_dir2, 0.25*radius, 0.02*abs(sin(iTime)));\n    float window3 = framed_cylinder_sd(pos, window_center1, window_dir3, 0.25*radius, 0.02*abs(sin(iTime)));\n    float window4 = framed_cylinder_sd(pos, window_center2, window_dir1, 0.15*radius, 0.015*abs(sin(iTime)));\n    float window5 = framed_cylinder_sd(pos, window_center2, window_dir2, 0.15*radius, 0.015*abs(sin(iTime)));\n    float window6 = framed_cylinder_sd(pos, window_center2, window_dir3, 0.15*radius, 0.015*abs(sin(iTime)));\n    \n    float window = min(window1,min(window2,min(window3,min(window4,min(window5,window6)))));\n    \n    //return window;\n    return max(shell,-window);\n    //float oval = -oval_cylinder_sd(pos, radius);\n    //return max(shell, oval);\n}\n\nfloat signed_dist(vec4 pos)\n{\n    //float grid_sd = quaternion_sd2(pos);\n    //float ground_sd = sphere_sd(pos, ground_center, ground_radius);\n    float tube = tube_sd(pos, tube_radius);\n    float ball = sphere_sd(pos, ball_center, ball_radius);\n    float light = sphere_sd(pos, light_center, light_radius);\n    \n    float sd;\n    if(light < tube && light < ball)\n    {\n        near_light = true;\n        nearest_color = light_color;\n        sd = light;\n    }\n    else if(tube < ball)\n    {\n        near_light = false;\n        nearest_color = mix(tube_color1, tube_color2, clamp(0.5*dist(pos, tube_center),0.0,1.0));\n        sd = tube;\n    }\n    else\n    {\n        near_light = false;\n        nearest_color = ball_color;\n        sd = ball;\n    }\n    \n    return sd;\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"const int KEY_LEFT  = 37;\nconst int KEY_UP    = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN  = 40;\n\nconst float pi = 3.141592653589;\nconst float height = pi/4.0;\n\nvec4 iposition = vec4(0,sin(height),0,cos(height));\nvec4 ifacing = vec4(1,0,1,0)/sqrt(2.);\nvec4 iup = vec4(0,cos(height),0,-sin(height));\nvec4 iright = vec4(1,0,-1,0)/sqrt(2.);\n\nfloat step_dist = 0.01;\nfloat turn_rate = 0.01;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    if (1.0 == texelFetch(iChannel2, ivec2(0,0), 0).x)\n    {\n        iposition = texelFetch(iChannel0, ivec2(0,0), 0);\n        ifacing   = texelFetch(iChannel0, ivec2(1,0), 0);\n        iup       = texelFetch(iChannel0, ivec2(2,0), 0);\n        iright    = texelFetch(iChannel0, ivec2(3,0), 0);\n    }\n    \n    float turn_left = texelFetch(iChannel1, ivec2(KEY_LEFT,0), 0).x;\n    float turn_right = texelFetch(iChannel1, ivec2(KEY_RIGHT,0), 0).x;\n    float theta = turn_rate*(turn_right-turn_left);\n    \n    vec4 facing = normalize(cos(theta)*ifacing+sin(theta)*iright);\n    vec4 right = normalize(-sin(theta)*ifacing+cos(theta)*iright);\n    \n    float tilt_up = texelFetch(iChannel1, ivec2(KEY_UP,0), 0).x;\n    float tilt_down = texelFetch(iChannel1, ivec2(KEY_DOWN,0), 0).x;\n    float phi = turn_rate*(tilt_up-tilt_down);\n    \n    vec4 up = normalize(-sin(phi)*facing+cos(phi)*iup);\n    facing = normalize(cos(phi)*facing+sin(phi)*iup);\n    \n    vec4 position =  cos(step_dist)*iposition + sin(step_dist)*facing;\n    facing        = -sin(step_dist)*iposition + cos(step_dist)*facing;\n    \n    mat4 m = mat4(position,facing,up,right);\n\n    fragColor = m[int(fragCoord.x)];\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[{"id":"XsXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(1.0,1.0,1.0,1.0);\n}","name":"Buffer B","description":"","type":"buffer"}]}