{"ver":"0.1","info":{"id":"lsXBDl","date":"1498749295","viewed":139,"name":"Homework - Blinnphong Ligthning","username":"MillhausVKodi","description":"Blinnphong ","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["blinnphong"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// TODO If you want to change from central to intermediate differences, do it here by commenting/uncommenting\n// the corresponding define\n#define USE_CENTRAL\n//#define USE_INTERMEDIATE\n\n// first three coordinates: position\n// w-component: radius\nconst vec4 sphere1 = vec4(0, 0, 0, 1);\nconst vec4 sphere2 = vec4(1, 1, 1, 1.5);\nconst vec4 sphere3 = vec4(1, 0, 3, 0.5);\n\n// density of objects\nconst float s1Dens = 0.015;\nconst float s2Dens = 0.02;\nconst float s3Dens = 0.03;\n\n// bounding box\nconst vec3 bbMin = vec3(-1.5, -1.5, -1.5);\nconst vec3 bbMax = vec3(2.5, 2.5, 3.5);\n\n// additional camera parameters\nconst float fovy = 45.0;\nconst float zNear = 0.1;\n\n// light direction\nconst vec3 lightDir = vec3(1.0, -1.0, -1.0);\n\nconst vec4 lightColor = vec4(1);\nconst vec4 specularColor = vec4(1);\nconst float ka = 0.5;  // ambient contribution\nconst float kd = 0.5;  // diffuse contribution\nconst float ks = 0.7;  // specular contribution\nconst float exponent = 50.0;  // specular exponent (shininess)\n\n// number of maximum raycasting samples per ray\nconst int sampleNum = 256;\n\n// width of one voxel\nconst float voxelWidth = 1.0 / 64.0;\n\n// epsilon for comparisons\nconst float EPS = 0.000001;\n\n/**\n *\tReturns whether a given point is inside a given sphere.\n *  \n * \t@param point The point that is tested against the sphere.\n * \t@param sphere The sphere parameters. xyz = position, w = radius\n *\t@return True, when the point is inside the sphere, false otherwise\n */\nbool isInSphere(vec3 point, vec4 sphere)\n{\n    vec3 spherePos = sphere.xyz;\n    \n    if(length(point - spherePos) <= sphere.w)\n        return true;\n    else\n        return false;\n}\n\n/**\n *\tReturns whether a given point is inside a given cube.\n *  \n * \t@param point The point that is tested against the cube.\n * \t@param cube The cube parameters. xyz = position, w = half of the cube width\n *\t@return True, when the point is inside the cube, false otherwise\n */\nbool isInCube(vec3 point, vec4 cube)\n{\n\tvec3 dist = abs(point.xyz - cube.xyz);\n    \n    if(all(lessThan(dist, vec3(cube.w))))\n        return true;\n    else return false;\n}\n\n/**\n *\tSamples the volume texture at a given position.\n *\n *\t@param volumeCoord The position one wants to retrieve the sample of (in world coordinates).\n *\t@return The sample value at the given position.\n */\nfloat sampleVolume(vec3 volumeCoord)\n{\n    bool in1 = isInCube(volumeCoord, sphere1);\n    bool in2 = isInCube(volumeCoord, sphere2);\n    bool in3 = isInSphere(volumeCoord, sphere3);\n    \n    float result = 0.0;\n    \n    if(in1)\n    \tresult += s1Dens;\n    \n    if(in2)\n        result += s2Dens;\n    \n    if(in3)\n        result += s3Dens;\n    \n    return result;\n}\n\n/**\n *\tEvaluates the transfer function for a given sample value\n * \t\n *\t@param value The sample value\n *\t@return The color for the given sample value\n */\nvec4 transferFunction(float value)\n{\n    if(value > EPS)\n    {\n    \tif(value > s1Dens + EPS)\n        {\n        \tif(value > s2Dens + EPS)\n            {   \n            \tif(value > s1Dens + s2Dens + EPS)\n                {\n                \treturn vec4(0, 0, 0, 1.0);\n                }\n                return vec4(1, 0, 0, 1.0);\n            }\n            return vec4(0, 1, 0,1.0);\n        }\n        return vec4(0, 0, 1, 1.0);\n    }\n    return vec4(0);\n}\n\n/**\n *\tIntersects a ray with the bounding box and returs the intersection points\n * \t\n * \t@param rayOrig The origin of the ray\n * \t@param rayDir The direction of the ray\n *  @param tNear OUT: The distance from the ray origin to the first intersection point\n *\t@param tFar OUT: The distance from the ray origin to the second intersection point\n *\t@return True if the ray intersects the bounding box, false otherwise.\n */\nbool intersectBoundingBox(vec3 rayOrig, vec3 rayDir, out float tNear, out float tFar)\n{\n\tvec3 invR = vec3(1.0) / rayDir;\n    vec3 tbot = invR * (bbMin - rayOrig);\n    vec3 ttop = invR * (bbMax - rayOrig);\n    \n    vec3 tmin = min(ttop, tbot);\n    vec3 tmax = max(ttop, tbot);\n    \n    float largestTMin = max(max(tmin.x, tmin.y), max(tmin.x, tmin.z));\n    float smallestTMax = min(min(tmax.x, tmax.y), min(tmax.x, tmax.z));\n    \n    tNear = largestTMin;\n    tFar = smallestTMax;\n    \n    return (smallestTMax > largestTMin);\n}\n\n/**\n *\tReturns the gradient at a given position using central differences\n *\t@param pos The postion from which the gradient should be determined\n *\t@return The gradient at pos.\n */\nvec3 gradientCentral(vec3 pos)\n{\n\tvec3 result;\n\tfloat offsetVal = voxelWidth;\n    \n    float valuexm1 = sampleVolume(pos+vec3(-offsetVal,0,0));\n    float valueym1 = sampleVolume(pos+vec3(0,-offsetVal,0));\n    float valuezm1 = sampleVolume(pos+vec3(0,0,-offsetVal));\n    \n    float valuex1 = sampleVolume(pos+vec3(offsetVal,0,0));\n    float valuey1 = sampleVolume(pos+vec3(0,offsetVal,0));\n    float valuez1 = sampleVolume(pos+vec3(0,0,offsetVal));\n    \n    result.x = (valuex1 - valuexm1)/2.0;\n    result.y = (valuey1 - valueym1)/2.0;\n    result.z = (valuez1 - valuezm1)/2.0;\n    return result;\n}\n\n/**\n *\tReturns the gradient at a given position using intermediate differences\n *\n *\t@param pos The postion from which the gradient should be determined\n *\t@return The gradient at pos.\n */\nvec3 gradientIntermediate(vec3 pos)\n{\n\t\n\tvec3 result;\n\t\n    float offsetVal = voxelWidth;\n    \n    float value0 = sampleVolume(pos);\n    float valuex1 = sampleVolume(pos+vec3(offsetVal,0,0));\n    float valuey1 = sampleVolume(pos+vec3(0,offsetVal,0));\n    float valuez1 = sampleVolume(pos+vec3(0,0,offsetVal));\n    \n    result.x = valuex1 - value0;\n    result.y = valuey1 - value0;\n    result.z = valuez1 - value0;\n    \n    return result;\n}\n\n/**\n *\tComputes the color of the lit surface of an object, using a global\n *\tdirectional light source.\n *\n *\t@param objColor The emission color of the object.\n *\t@param normal The surface normal at the position that should be lit.\n *\t@param eyeDir The direction from the surface to the camera position.\n *\t@return The color of the lit surface\n */\nvec4 lighting(vec4 objColor, vec3 normal, vec3 eyeDir)\n{\n    //normal = normalize(normal);\n    \n    vec3 l = lightDir*vec3(-1.0);\n    \n   \tfloat lambertian = max(dot(normalize(l),normal), 0.0);\n\n    \n    vec3 h  = normalize(eyeDir + l);\n    \n    \n    vec4 ambient = ka * lightColor;\n    vec4 diffuse = kd * lightColor * max(lambertian, 0.0);\n    vec4 specular= ks * lightColor * specularColor * pow(max( dot(normal, h) , 0.0 ), exponent);\n    \n\n    \n\tvec4 iOut = ambient + diffuse + specular;\n    \n    vec4 color = objColor*iOut ;\n    \n    color.w = objColor.w;\n    \n\n    return color;\n    \n\t\n    \n}\n\n/**\n *\tMain Function: \n *  Computes the color for the given fragment.\n *\n *\t@param fragColor OUT: The color of the pixel / fragment.\n *\t@param fragCoord The coordinate of the fragment in screen space\n */\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    float aspect = iResolution.x / iResolution.y;\n    \n    /******************** compute camera parameters ********************/\n    \n    // camera movement  \n    float camSpeed = 0.5;\n    vec3 camPos = 7.0 * vec3(cos(iTime*camSpeed), 0.5, sin(iTime*camSpeed));\n    vec3 camDir = -normalize(camPos);\n    vec3 camUp = vec3(0.0, 1.0, 0.0);\n    vec3 camRight = normalize(cross(camDir, camUp));\n    camUp = normalize(cross(camRight, camDir));\n    \n    /************ compute ray direction (OpenGL style) *****************/\n    vec2 myUV = 2.0 * uv - 1.0;\n    float fovx = 2.0 * atan(tan(fovy / 2.0) * aspect);\n    \n    vec3 uL = (tan(fovx*0.5)*zNear) * (-camRight) + (tan(fovy*0.5) * zNear) * camUp + camDir * zNear + camPos;\n    vec3 lL = (tan(fovx*0.5)*zNear) * (-camRight) + (tan(fovy*0.5) * zNear) * (-camUp) + camDir * zNear + camPos;\n    vec3 uR = (tan(fovx*0.5)*zNear) * camRight + (tan(fovy*0.5) * zNear) * camUp + camDir * zNear + camPos;\n    vec3 lR = (tan(fovx*0.5)*zNear) * camRight + (tan(fovy*0.5) * zNear) * (-camUp) + camDir * zNear + camPos;\n    \n    vec3 targetL = mix(lL, uL, uv.y);\n    vec3 targetR = mix(lR, uR, uv.y);\n    vec3 target = mix(targetL, targetR, uv.x);\n    \n    vec3 rayDir = normalize(target - camPos);\n    \n    /******************* test against bounding box ********************/\n    float tNear, tFar;\n    bool hit = intersectBoundingBox(camPos, rayDir, tNear, tFar);\n       vec4 background = vec4(1.0);\n    if(tNear < 0.0)\n        tNear = 0.0;\n    \n    if(!hit)\n    {\n        fragColor = background;\n        return;\n    }\n    \n    vec3 pos = camPos + rayDir * tNear;\n    float tstep = (bbMax.x - bbMin.x) / float(sampleNum);\n    vec4 finalColor = vec4(0);\n    vec3 finalGradient = vec3(0);\n    \n    /******************** main raycasting loop *******************/\n    for(int i = 0; i < sampleNum; i++)\n    {\n        if(finalColor.a > 0.99)\n            break; // early ray termination!\n    \tpos += tstep * rayDir;\n        float sampleValue = sampleVolume(pos);\n        vec4 color = transferFunction(sampleValue);\n\n        \n        #ifdef USE_INTERMEDIATE\n        vec3 grad = gradientIntermediate(pos);\n        #else\n        #ifdef USE_CENTRAL\n        vec3 grad = gradientCentral(pos);\n        #else\n        vec3 grad = vec3(0);\n        #endif // USE_CENTRAL\n        #endif // USE_INTERMEDIATE\n        \n    \n   \t /****************** lighting ********************************/  \n        {\n           finalGradient = grad;\n        }\n        color = lighting(color, -normalize(finalGradient), -rayDir);\n        // blending with pre-multiplied color!\n        color.rgb *= color.a;\n        finalColor += color * (1.0 - finalColor.w);\n    }\n    fragColor = finalColor * finalColor.a + (1.0 - finalColor.a) * background;\n}","name":"Image","description":"","type":"image"}]}