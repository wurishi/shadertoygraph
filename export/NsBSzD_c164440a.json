{"ver":"0.1","info":{"id":"NsBSzD","date":"1619715433","viewed":168,"name":"Raymarching Scene Starter","username":"indiana_dev","description":"A great place to start creating 3D raymarched scenes !\nImplements a free camera controlled by the mouse and the keyboard. \n\nAWSD / ZQSD / Arrows to move the camera\nDrag & Drop to rotate the camera","likes":5,"published":1,"flags":48,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float EPSILON = 0.01;\nconst float MAX_DIST = 1000.;\nconst int MAX_MARCHING_STEPS = 1000;\n\n\n// DATA FUNCTIONS\n\nvec3 getData(float ID) {\n    return texelFetch(iChannel0, ivec2(ID, 0.5), 0).xyz;\n}\n\nvec4 getData4(float ID) {\n    return texelFetch(iChannel0, ivec2(ID, 0.5), 0);\n}\n\nmat4 getViewMatrix() {\n    return mat4(\n        getData4(CAM_VIEW_MAT_ID),\n        getData4(CAM_VIEW_MAT_ID+1.),\n        getData4(CAM_VIEW_MAT_ID+2.),\n        getData4(CAM_VIEW_MAT_ID+3.)\n    );\n}\n\n// DISTANCE FUNCTIONS\n\nfloat fRepeatedSphere(vec3 p, float r) {\n    vec3 c = vec3(10.);\n    vec3 q = mod(p+0.5*c,c)-0.5*c;\n\treturn length(q) - r;\n}\n\n// SCENE\n\nfloat sceneSDF(vec3 p) {\n    return fRepeatedSphere(p, 1.);\n}\n\n// RAYMARCH FUNCTIONS\n\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\nvec2 shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        vec3 point = eye + depth * marchingDirection;\n        float dist = min(point.y, sceneSDF(point));\n\n        if (point.y < EPSILON) {\n            return vec2(depth, 1.);\n        }\n        \n        if (dist < EPSILON) {\n\t\t\treturn vec2(depth, 0.);\n        }\n        \n        depth += dist;\n        if (depth >= end) {\n            return vec2(end, -2.);\n        }\n    }\n    return vec2(end, -1.);\n}\n\n// LIGHTING FUNCTIONS\n\n\n// Estimate the normal of the surface nearest to a point p\nvec3 getNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n// Calculate light using the Blinn-Phong model\nvec3 calculateLight(vec3 p, vec3 color, vec3 camPos) {\n    float k_a = 0.1; // Ambient intensity\n    float k_d = 1.0; // Diffuse intensity\n    float k_s = 0.5; // Specular intensity\n    float shininess = 64.; // Specular shininess\n    \n    vec3 lightPos = vec3(5.);\n    \n    // Ambient\n    vec3 ambientCol = color * k_a;\n    \n    // Diffuse\n    vec3 surfaceNormal = getNormal(p);\n    vec3 lightDirection = normalize(lightPos - p);\n    float diffuse = dot(surfaceNormal, lightDirection)*.5+.5;\n    vec3 diffuseCol = color * k_d * diffuse;\n    \n    // Specular\n    vec3 viewDirection = normalize(camPos - p);\n    vec3 halfwayDirection = normalize(viewDirection + lightDirection);\n    float specular = dot(surfaceNormal, halfwayDirection)*.5+.5;\n    specular = pow(specular, shininess);\n    vec3 specularCol = vec3(1.) * specular * k_s;\n    \n    return ambientCol + diffuseCol + specularCol;\n}\n\n/* Draw isolines on the plane surface\n *\n * distToScene: the distance from the hit point to the scene excluding the plane\n * distToPoint: the distance from the camera to the hit point\n * frequency: the frequency of the isolines\n * thickness: the thickness of the isolines\n * smoothness: the range that will be used in smoothstep to smooth the border of the isolines\n * minDistance: the minimum distance at which the lines should appear\n * maxDistance: the maximum distance at which the lines should appear \n */\nvec3 createIsolines(float distToScene, float distToPoint, float frequency, float thickness, float smoothness, float minDistance, float maxDistance) {\n    float fade = distToPoint < minDistance ? smoothstep(minDistance, 0., distToPoint) : smoothstep(minDistance, maxDistance, distToPoint);\n    float c = 0.5+0.5*sin(distToScene*frequency);\n\n    vec3 colStart = vec3(0.57, 0., 0.75);\n    vec3 colMid = vec3(255./255., 216./255., 101./255.);\n    vec3 colEnd = vec3(0.97);\n    float end1 = 10.;\n    float end2 = 20.;\n\n    vec3 base = distToScene < end1 ? mix(colStart, colMid, smoothstep(0., end1, distToScene)) : mix(colMid, colEnd, clamp(0., end2, smoothstep(0., end2, distToScene - end1)));\n            \n    vec3 col;\n    thickness *= max(1.0, 0.25*distToPoint);\n    col = mix(col, base, smoothstep(thickness, thickness + smoothness, c));\n    col = mix(col, base, fade);\n\n    return col;\n}\n\n\n// MAIN\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    mat4 viewMatrix = getViewMatrix();\n    vec3 camPos = getData(CAM_POS_ID);\n\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 viewDir = rayDirection(60., iResolution.xy, fragCoord);\n    vec3 worldDir = (viewMatrix * vec4(viewDir, 0.)).xyz;\n    \n    vec2 result = shortestDistanceToSurface(camPos, worldDir, 0., MAX_DIST);\n    float dist = result.x;\n    float type = result.y;\n    vec3 p = camPos + dist * worldDir;\n    \n    // Didn't hit anything\n    if (type < 0.) {\n        fragColor = vec4(.2, .2, .2, 1.);\n\t\treturn;\n    }\n    \n    // Hit floor plane\n    if (type == 1.) {\n        float dstToScene = sceneSDF(p);\n        vec3 col = createIsolines(dstToScene, dist, 1., 0.001, 0.01, 80., 2000.);\n        col *= createIsolines(dstToScene, dist, 10., 0.001, 0.01, 20., 80.);\n        col *= createIsolines(dstToScene, dist, 100., 0.001, 0.01, 0., 20.);\n        \n        fragColor = vec4(col,1.);\n        return;\n    }\n    \n    // Hit object\n    vec3 baseColor = clamp(p / 100., 0., 1.);\n    vec3 color = calculateLight(p, baseColor, camPos);\n    \n    fragColor = vec4(color, 1.);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"const int KEY_LEFT  = 37;\nconst int KEY_UP    = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN  = 40;\n\nconst int KEY_W = 87;\nconst int KEY_A = 65;\nconst int KEY_S = 83;\nconst int KEY_D = 68;\n\nconst int KEY_Z = 90;\nconst int KEY_Q = 81;\n\nbool isKeyPressed(int KEY_ID) {\n    return texelFetch(iChannel0, ivec2(KEY_ID, 0), 0).x == 1.;\n}\n\nvec3 getData(float ID) {\n    return texelFetch(iChannel1, ivec2(ID, 0.5), 0).xyz;\n}\n\nvec4 getData4(float ID) {\n    return texelFetch(iChannel1, ivec2(ID, 0.5), 0);\n}\n\nmat4 lookAt(vec3 eye, vec3 at, vec3 up) {\n    vec3 v = normalize(at - eye);  // view direction vector\n    vec3 n = normalize(cross(v, up)); // perpendicular vector\n    vec3 u = normalize(cross(n, v)); // \"new\" up vector\n    v = -v;\n\n    mat4 result = mat4(\n        n[0], n[1], n[2], -dot(n, eye),\n        u[0], u[1], u[2], -dot(u, eye),\n        v[0], v[1], v[2], -dot(v, eye),\n        0.0,  0.0,  0.0,  1.0\n    );\n\n    return result;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    vec4 outValue = vec4(0., 0., 0., 1.);\n    \n    // Camera Position\n    if (fragCoord == vec2(CAM_POS_ID, 0.5)) {\n        bool upPressed = isKeyPressed(KEY_UP) || isKeyPressed(KEY_W) || isKeyPressed(KEY_Z);\n        bool leftPressed = isKeyPressed(KEY_LEFT) || isKeyPressed(KEY_A) || isKeyPressed(KEY_Q);\n        bool downPressed = isKeyPressed(KEY_DOWN) || isKeyPressed(KEY_S);\n        bool rightPressed = isKeyPressed(KEY_RIGHT) || isKeyPressed(KEY_D);\n        vec3 camPos = getData(CAM_POS_ID);\n        vec3 front = getData(CAM_FRONT_ID);\n        vec3 right = getData(CAM_RIGHT_ID);\n        \n        if (upPressed) camPos += front * CAM_SPEED;\n        else if (downPressed) camPos -= front * CAM_SPEED;\n        if (leftPressed) camPos -= right * CAM_SPEED;\n        else if (rightPressed) camPos += right * CAM_SPEED;\n        \n        if (iFrame < 5) camPos = vec3(0., 4., 10.);\n        outValue.xyz = camPos;\n    } \n    \n    // Camera Rotation\n    if (fragCoord == vec2(CAM_ROT_ID, 0.5)) {\n        vec3 camRot = getData(CAM_ROT_ID);\n        vec4 mouseData = getData4(MOUSE_DATA_ID);\n        \n        camRot.xy += mouseData.zw * MOUSE_SENSITIVITY;\n        \n        if (iFrame < 5) camRot = vec3(-1.57, 0.1, 0.);\n        outValue.xyz = camRot;\n    }\n    \n    // Camera Front Vector\n    if (fragCoord == vec2(CAM_FRONT_ID, 0.5)) {\n        vec3 camRot = getData(CAM_ROT_ID);\n        vec3 front = normalize(vec3(\n            cos(camRot.y) * cos(camRot.x),\n            sin(camRot.y),\n            cos(camRot.y) * sin(camRot.x)\n        ));\n        \n        outValue.xyz = front;\n    }\n    \n    // Camera Right Vector\n    if (fragCoord == vec2(CAM_RIGHT_ID, 0.5)) {\n        vec3 front = getData(CAM_FRONT_ID);\n        vec3 right = normalize(cross(front, vec3(0., 1., 0.)));\n        \n        outValue.xyz = right;\n    }\n    \n    // Camera View Matrix\n    if (fragCoord.x >= CAM_VIEW_MAT_ID && \n        fragCoord.x < CAM_VIEW_MAT_ID + 4. &&\n        fragCoord.y == 0.5) {\n        int rowIndex = int(fragCoord.x - CAM_VIEW_MAT_ID);\n        vec3 camPos = getData(CAM_POS_ID);\n        vec3 front = getData(CAM_FRONT_ID);\n        vec3 up = vec3(0., 1., 0.);\n        \n        mat4 viewMatrix = lookAt(camPos, camPos + front, up);\n        \n        outValue = viewMatrix[rowIndex];\n    }\n    \n    // Mouse\n    if (fragCoord == vec2(MOUSE_DATA_ID, 0.5)) {\n        vec4 lastMouseData = getData4(MOUSE_DATA_ID);\n        vec2 mouseData = iMouse.xy / iResolution.xy;\n        bool clicLastFrame = getData(MOUSE_CLIC_ID).x == 1.;\n        \n        outValue.xy = mouseData;\n\n        if (iMouse.z > 0. && clicLastFrame) {\n            vec2 diff = mouseData - lastMouseData.xy;\n            outValue.zw = diff;\n        } else {\n            outValue.zw = vec2(0.);\n        }\n    }\n    if (fragCoord == vec2(MOUSE_CLIC_ID, 0.5)) {\n        outValue.x = iMouse.z > 0. ? 1. : 0.;\n    }\n             \n    fragColor = outValue;\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"// Settings\nconst float CAM_SPEED = 1.3;\nconst float MOUSE_SENSITIVITY = 1.2;\n\n// Buffer Data IDs\nconst float CAM_POS_ID = 0.5;\nconst float CAM_FRONT_ID = 1.5;\nconst float CAM_RIGHT_ID = 2.5;\nconst float CAM_ROT_ID = 3.5;\nconst float CAM_VIEW_MAT_ID = 4.5;\nconst float MOUSE_DATA_ID = 8.5; //x,y: last mouse coordinates | z,w: camera rotation offset\nconst float MOUSE_CLIC_ID = 9.5; //x: clicked last frame (1.0) or not (0.0)","name":"Common","description":"","type":"common"}]}