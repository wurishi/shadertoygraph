{"ver":"0.1","info":{"id":"DsyfWd","date":"1698757446","viewed":178,"name":"Test159","username":"LluisV","description":"test","likes":15,"published":1,"flags":32,"usePreview":0,"tags":["test"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n#define SHOW_NOISE 0\n#define SRGB 0\n#define BLEND_MODE 1\n#define SPEED 2.0\n#define INTENSITY 0.045\n#define MEAN 0.0\n#define VARIANCE 0.5\n\nvec3 channel_mix(vec3 a, vec3 b, vec3 w) {\n    return vec3(mix(a.r, b.r, w.r), mix(a.g, b.g, w.g), mix(a.b, b.b, w.b));\n}\n\nfloat gaussian(float z, float u, float o) {\n    return (1.0 / (o * sqrt(2.0 * 3.1415))) * exp(-(((z - u) * (z - u)) / (2.0 * (o * o))));\n}\n\nvec3 madd(vec3 a, vec3 b, float w) {\n    return a + a * b * w;\n}\n\nvec3 screen(vec3 a, vec3 b, float w) {\n    return mix(a, vec3(1.0) - (vec3(1.0) - a) * (vec3(1.0) - b), w);\n}\n\nvec3 overlay(vec3 a, vec3 b, float w) {\n    return mix(a, channel_mix(\n        2.0 * a * b,\n        vec3(1.0) - 2.0 * (vec3(1.0) - a) * (vec3(1.0) - b),\n        step(vec3(0.5), a)\n    ), w);\n}\n\nvec3 soft_light(vec3 a, vec3 b, float w) {\n    return mix(a, pow(a, pow(vec3(2.0), 2.0 * (vec3(0.5) - b))), w);\n}\n\nvoid mainImage(out vec4 color, vec2 coord) {\n\n\n    vec2 uv = coord / iResolution.xy;\n    uv += vec2(0.83, 0.2); // Subtract an offset to move the image to the top left\n    uv *= vec2(.5, .5); // Scale the image by a factor of 2 in both x and y directions\n\n    color = texture(iChannel0, uv).rgba + texture(iChannel1, uv).rgba;\n\n    vec2 ps = vec2(1.0) / iResolution.xy;\n\n    #if SRGB\n    color = pow(color, vec4(2.2));\n    #endif\n    \n    float t = iTime * float(SPEED);\n    float seed = dot(uv, vec2(12.9898, 78.233));\n    float noise = fract(sin(seed) * 43758.5453 + t);\n    noise = gaussian(noise, float(MEAN), float(VARIANCE) * float(VARIANCE));\n    \n    #if SHOW_NOISE\n    color = vec4(noise);\n    #else    \n    float w = float(INTENSITY);\n\n    vec3 grain = vec3(noise) * (1.0 - color.rgb);\n    \n    #if BLEND_MODE == 0\n    color.rgb += grain * w;\n    #elif BLEND_MODE == 1\n    color.rgb = screen(color.rgb, grain, w);\n    #elif BLEND_MODE == 2\n    color.rgb = overlay(color.rgb, grain, w);\n    #elif BLEND_MODE == 3\n    color.rgb = soft_light(color.rgb, grain, w);\n    #elif BLEND_MODE == 4\n    color.rgb = max(color.rgb, grain * w);\n    #endif\n        \n    #if SRGB\n    color = pow(color, vec4(1.0 / 2.2));\n    #endif\n    #endif\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\n// noise from https://www.shadertoy.com/view/4sc3z2\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031,.11369,.13787));\n    p3 += dot(p3, p3.yxz+19.19);\n    return -1.0 + 2.0 * fract(vec3(p3.x+p3.y, p3.x+p3.z, p3.y+p3.z)*p3.zyx);\n}\nfloat snoise3(vec3 p)\n{\n    const float K1 = 0.333333333;\n    const float K2 = 0.166666667;\n    \n    vec3 i = floor(p + (p.x + p.y + p.z) * K1);\n    vec3 d0 = p - (i - (i.x + i.y + i.z) * K2);\n    \n    vec3 e = step(vec3(0.0), d0 - d0.yzx);\n\tvec3 i1 = e * (1.0 - e.zxy);\n\tvec3 i2 = 1.0 - e.zxy * (1.0 - e);\n    \n    vec3 d1 = d0 - (i1 - K2);\n    vec3 d2 = d0 - (i2 - K1);\n    vec3 d3 = d0 - 0.5;\n    \n    vec4 h = max(0.6 - vec4(dot(d0, d0), dot(d1, d1), dot(d2, d2), dot(d3, d3)), 0.0);\n    vec4 n = h * h * h * h * vec4(dot(d0, hash33(i)), dot(d1, hash33(i + i1)), dot(d2, hash33(i + i2)), dot(d3, hash33(i + 1.0)));\n    \n    return dot(vec4(31.316), n);\n}\n\nvec4 extractAlpha(vec3 colorIn)\n{\n    vec4 colorOut;\n    float maxValue = min(max(max(colorIn.r, colorIn.g), colorIn.b), 1.0);\n    if (maxValue > 1e-5)\n    {\n        colorOut.rgb = colorIn.rgb * (1.0 / maxValue);\n        colorOut.a = maxValue;\n    }\n    else\n    {\n        colorOut = vec4(0.0);\n    }\n    return colorOut;\n}\n\n#define BG_COLOR vec3(0)\n#define time iTime*.15\nconst vec3 color1 = vec3(0.00611765, 0.00262745, 0.00996078);\nconst vec3 color2 = vec3(0.00298039, 0.00760784, 0.00913725);\nconst vec3 color3 = vec3(0.0062745, 0.0078431, 0.00600000);\nconst float innerRadius = 0.6;\nconst float noiseScale = 0.65;\n\nfloat light1(float intensity, float attenuation, float dist)\n{\n    return intensity / (1.0 + dist * attenuation);\n}\nfloat light2(float intensity, float attenuation, float dist)\n{\n    return intensity / (1.0 + dist * dist * attenuation);\n}\n\nvoid draw( out vec4 _FragColor, in vec2 vUv )\n{\n    vec2 uv = vUv;\n    float ang = atan(uv.y, uv.x);\n    float len = length(uv);\n    float v0, v1, v2, v3, cl;\n    float r0, d0, n0;\n    float r, d;\n    \n    // ring\n    n0 = snoise3( vec3(uv * noiseScale, time * 0.5) ) * 0.5 + 0.5;\n    r0 = mix(mix(innerRadius, 1.0, 0.4), mix(innerRadius, 1.0, 0.6), n0);\n    d0 = distance(uv, r0 / len * uv);\n    v0 = light1(1.0, 10.0, d0);\n    v0 *= smoothstep(r0 * 1.05, r0, len);\n    cl = cos(ang + time * 2.0) * 0.5 + 0.5;\n    \n    // high light\n    float a = -0.7 + iMouse.y / iResolution.y;\n    vec2 pos = vec2(cos(a), sin(a)) * r0;\n    d = distance(uv, pos);\n    v1 = light2(1.3, 25.0, d);\n    v1 *= light1(1.0, 30.0 , d0);\n    \n    // back decay\n    v2 = smoothstep(1.0, mix(innerRadius, 1.0, n0 * 0.5), len);\n    \n    // hole\n    v3 = smoothstep(innerRadius, mix(innerRadius, 1.0, 0.5), len);\n    \n    // color\n    vec3 c = mix(color1, color2, cl);\n    vec3 col = mix(color1, color2, cl);\n    col = mix(color3, col, v0);\n    col = (col + v1) * v2 * v3;\n    col.rgb = clamp(col.rgb, 0.0, 1.0);\n    \n    //gl_FragColor = extractAlpha(col);\n    _FragColor = extractAlpha(col);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord*2.-iResolution.xy)/iResolution.y;\n    \n    vec4 col;\n    draw(col, uv);\n\n    vec3 bg = BG_COLOR;\n\n    fragColor.rgb = mix(bg, col.rgb, col.a); //normal blend\n}\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"XdX3Rr","filepath":"/media/a/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin","previewfilepath":"/media/ap/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin","type":"volume","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"const float pi = 3.14159265358979323;\nconst float th = pi * 3. / 8.;\nconst float sc = 1. / cos(th);\n\nvec2 intersectSphere(vec3 ro, vec3 rd, vec3 org, float rad)\n{\n    ro -= org;\n    float a = dot(rd, rd);\n    float b = 2. * dot(rd, ro);\n    float c = dot(ro, ro) - rad * rad;\n    float desc = b * b - 4. * a * c;\n    if (desc < 0.)\n        return vec2(1, 0);\n\tdesc = sqrt(desc);\n    return vec2(-b - desc, -b + desc) / (2. * a);\n}\n\nmat3 rotX(float a)\n{\n    return mat3(1., 0., 0., 0., cos(a), sin(a), 0., -sin(a), cos(a));\n}\n\nmat3 rotY(float a)\n{\n    return mat3(cos(a), 0., sin(a), 0., 1., 0., -sin(a), 0., cos(a));\n}\n\nmat3 rotZ(float a)\n{\n    return mat3(cos(a), sin(a), 0., -sin(a), cos(a), 0., 0., 0., 1.);\n}\n\nvec3 env(vec3 d)\n{\n    return vec3(.0);\n}\n\n#define time iTime*.15\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy * 2. - 1.;\n    uv.x *= iResolution.x / iResolution.y;\n\n    vec3 ro = vec3(0, 0, 4.5), rd = normalize(vec3(uv, -4));\n\n    float radius = 0.87;\n    vec2 t = intersectSphere(ro, rd, vec3(0), radius);\n\n    if(t.x > t.y)\n    {\n        fragColor.rgb = env(rd);\n    }\n    else\n    {\n        vec3 rp = ro + rd * t.x;\n        vec3 rn = normalize(rp);\n\n        vec3 c = vec3(0);\n        float wsum = 0.;\n        \n        float saturation = 0.1;\n\n        rp = rotY(time / 8.) * rp;\n        for(int i = 0; i < 35; ++i)\n        {\n            vec3 d = normalize(textureLod(iChannel0, rp * .2, 0.).rgb - .5);\n            d = rotZ(time * .3) * d;\n            vec3 n = normalize(rp);\n            d -= n * dot(n, d);\n            rp += d * .011;\n            float w = 1.;\n            vec3 s;\n            s = vec3(textureLod(iChannel0, rp * 1., 0.).a) * vec3(.3, 1., .7);\n            s += vec3(textureLod(iChannel0, rp.zyx * 2.5, 0.).a) * vec3(1., .3, .7);\n            c += s * w;\n            wsum += w;\n\n            rp = rotY(-.004) * rp;\n        }\n\n        rp = ro + rd * t.x;\n        rp = rotY(time / 10.) * rp;\n        for(int i = 0; i < 35; ++i)\n        {\n            vec3 d = normalize(textureLod(iChannel0, rp * .1, 0.).bgr - .5);\n            d = rotZ(time * -.05) * d;\n            vec3 n = normalize(rp);\n            d -= n * dot(n, d);\n            rp += d * .011;\n            float w = .4;\n            vec3 s;\n            s = vec3(pow(textureLod(iChannel0, rp * 3., 0.).a, 2.)) * vec3(.3, 1., .7).bgr;\n            c += s * w;\n            wsum += w;\n        }\n\n        rp = ro + rd * t.x;\n        rp = rotY(time / 12.) * rp;\n        for(int i = 0; i < 35; ++i)\n        {\n            vec3 d = normalize(textureLod(iChannel0, rp * .1, 0.).brg - .5);\n            d = rotY(time * -1.) * d;\n            vec3 n = normalize(rp);\n            d -= n * dot(n, d);\n            rp += d * .01;\n            float w = .2;\n            vec3 s;\n            s = vec3(pow(textureLod(iChannel0, rp * .5, 0.).a, 2.)) * vec3(0, 0, 1.);\n            c += s * w;\n            wsum += w;\n        }\n\n        c /= wsum;\n\n        vec3 ld = normalize(vec3(1, -1, -.8));\n\n        c -= dot(c, vec3(1. / 3.)) * .7;\n        c *= 4.5;\n\n        c *= .5 + .5 * dot(rn, ld);\n\n        vec3 refl = normalize(reflect(rd, rn));\n        vec3 spec = vec3(pow(max(0., dot(refl, ld)), 8.)) * 0.1 + env(refl);\n        spec += .5 * (1. - smoothstep(.25, .35, abs(refl.z))) *\n            (1. - smoothstep(.8, .92, abs(refl.x))) * step(0., refl.y);\n        spec += textureLod(iChannel1, refl, 4.).rgb * .2;\n        c = mix(c, spec, .1 + pow(max(0., 1. - dot(rn, -rd)), 3.) * .8);\n\n        fragColor.rgb = c;\n    }\n\n    float gray = dot(fragColor.rgb, vec3(0.299, 0.587, 0.114));\n    fragColor.rgb = vec3(gray);\n\n    fragColor.rgb *= 1.6;\n\n    fragColor.rgb = pow(clamp(fragColor.rgb, 0., 1.), vec3(5.0));\n}\n","name":"Buffer B","description":"","type":"buffer"}]}