{"ver":"0.1","info":{"id":"XX2cWR","date":"1727146154","viewed":34,"name":"Hexagon jumping","username":"Elsio","description":"jump","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["triangle","jump"],"hasliked":0,"parentid":"XXjyWR","parentname":"Triangle jumping"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define t iTime\n//#define t -PI/6.\n//#define t PI/6.\n#define PI acos(-1.)\n#define TAU (2. * PI)\n#define TRAU 3. * PI / 2.\n#define r iResolution.xy\n\nvec2 hexa(vec2 p) {\n    float d = atan(p.y, p.x),\n          k = 6.; // hexagon\n    \n    d = cos((mod(k * (d + t) + PI, TAU) - PI) / k);\n    return vec2(\n               smoothstep(9. / r.y, 0., abs(length(p) - 1.)), \n               smoothstep(0., 9. / r.y, \n                   sqrt(3.) / 2. - d * length(p))); // cos(pi/6) = sqrt(3.) / 2.\n}\n\nvoid mainImage(out vec4 o, vec2 u) {\n    o *= 0.;\n    u = 4. * (u - r / 2.) / r.y;\n    u.y += 1.;\n    \n    o.bg += hexa(u);\n    \n    float h = 1.5, // ??\n          g = 3. / PI;\n          \n    // 3  //  u.y -= cos((mod(t * 3. + 3. * PI / 2., TAU) - PI) / 3.)  *  2.;\n    // 4  //  u.y -= cos((mod(t * 4.               , TAU) - PI) / 4.)  *  2.;\n    \n    //u.y -= cos((mod(t * 6. + PI, TAU) - PI) / 6.)  *  2.;\n    //u.y -= cos(fract(t * g + .5) * 2. * PI / 6. - PI / 6.)  *  2.;\n    //u.y -= cos( fract(t * g + .5) / g - 1. / (g*2.)) * 2.;\n\n    \n    u.y -= cos(fract(t * g + .5) * h - h / 2.) + 1.;\n    \n    \n    u.y = -u.y;\n    o.rg += hexa(u);\n}\n\n\n\n\n/*    \n     // 252ch @fabrice version\n     \n     // muito interessante essa capacidade de enxergar e explorar a simetria\n     // mas eu acho que o código ficou um pouco mais confuso do que já era\n     // e a intenção desse código é tentar enxergar uma generalização\n     //     para movimentar outros polígonos e formatos\n\nvoid mainImage(out vec4 o, vec2 u) {\n    vec2 r = iResolution.xy,\n         p = 2. * (u + u - r) / r.y;\n    \n    float PI = 3.14, l,\n          k = PI / 6.,\n          d = cos(\n                  (\n                      fract(iTime * 3. / PI + .5) - .5\n                  ) * 1.5 \n                  \n              ) * .5 + .5;\n        \n    p.y = abs(p.y + 1. - d) - d;\n    l = length(p);\n    \n    o = -vec4(\n             abs(l - 1.), \n             cos(\n                 mod(\n                     atan(p.y, p.x) + iTime + k,\n                     k + k\n                 ) - k\n             ) * l - .866, \n             1, 0\n         ) * r.y / 9. + 1.;  \n}\n\n*/","name":"Image","description":"","type":"image"}]}