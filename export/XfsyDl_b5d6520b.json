{"ver":"0.1","info":{"id":"XfsyDl","date":"1721781600","viewed":24,"name":"practice raymarch27462094650947","username":"vsi","description":"jfs22 helped\nsecond attempt at raymarching","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["raymarch"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float focal_length=1.0;\nconst int maxsteps=500;\nconst float maxdist=500.0;\nconst float epsilon=0.001;\nconst float ambient=0.3;\nvec3 spherepos=vec3(0.0);\nbool shine;\nvec3 color=vec3(0.2,0.1,0.2);\nfloat sphere(vec3 pos,vec3 spherepos,float radius){\n    float sdf=distance(pos,spherepos)-radius;\n    return(sdf);\n}\nfloat plane(vec3 pos, float height) {\n    return pos.y-height;\n}\nfloat scene(vec3 pos){\n    float sdf=plane(pos,-0.8);\n    spherepos=vec3(0,0,0);\n    color=vec3(0.0,0.8,0.8);\n    shine=false;\n    float temp=sdf;\n    temp=sdf;\n    if(sphere(pos,vec3(-0.5,-0.5,2.0),0.5)<temp){\n       sdf=sphere(pos, vec3(-0.5,-0.5,2.0),0.5);\n       color=vec3(0.8,0.5,0.0);\n       spherepos=pos-vec3(-0.5,-0.5,2.0);\n       shine=false;\n    }\n    temp=sdf;\n    if(sphere(pos, vec3(1.0,-0.5,2.0),0.6)<temp){\n       sdf=sphere(pos, vec3(1.0,-0.5,2.0),0.6);\n       color=vec3(0.0,0.8,0.8);\n       spherepos=pos-vec3(0.0,0.8,0.8);\n       shine=true;\n    }\n    temp=sdf;\n    if(sphere(pos,vec3(0.0,-0.5,2.0),0.7)<temp){\n       sdf=sphere(pos,vec3(0.0,-0.5,2.0),0.7);\n       color=vec3(0.2,0.8,0.5);\n       spherepos=pos-vec3(0.0,-0.5,2.0);\n       shine=true;\n    }\n    return(sdf);\n}\nvec3 normals(vec3 point) {\n    vec2 temp = vec2(epsilon, -epsilon);\n    return normalize(temp.xyy*scene(point+temp.xyy)+\n    temp.yyx*scene(point+temp.yyx)+\n    temp.yxy*scene(point+temp.yxy)+\n    temp.xxx*scene(point+temp.xxx));\n}\n\n\nfloat raymarch(inout vec3 rayorigin, vec3 raydir){\n      float sdf=0.0;\n      vec3 pos=rayorigin;\n      float raylength=0.0;\n      for (int loop=0; loop<maxsteps && sdf<maxdist; loop++){\n          sdf=scene(pos);\n          if (sdf<epsilon){\n              break;\n          }\n          raylength+=0.5*sdf;\n          pos=raylength*raydir+rayorigin;\n          //raydir=raydir-2.0*dot(raydir,normals(rayorigin))*normals(rayorigin);\n      }\n      rayorigin=raylength*raydir+rayorigin;\n      return sdf;\n}\n\nfloat shadow(inout vec3 rayorigin, vec3 raydir){\n      float sdf=0.0;\n      vec3 pos=rayorigin;\n      float raylength=0.0;\n      bool check=false;\n      float res=1.0;\n      float soft=0.0;\n      for (int loop=0; loop<maxsteps && sdf<maxdist; loop++){\n          sdf=scene(pos);\n          if (sdf>epsilon){\n              check=true;\n          } else if(sdf<epsilon && check){\n                 return 0.0;\n                 break;\n          \n          }\n          raylength+=0.5*sdf;\n          pos=raylength*raydir+rayorigin;\n          res = min( res, 10.8*sdf/soft);\n          soft += sdf;\n      }\n      return res;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 pos=vec3(0.0);\n    vec3 light=normalize(vec3(iMouse.x*6.0/iResolution.x-3.0,iMouse.y*6.0/iResolution.y,-2));\n    float gleam;\n    vec3 col=vec3(1.0,0.8,0.6);\n    vec2 uv = (2.0*fragCoord-iResolution.xy)/iResolution.x;\n    vec3 rayorigin=vec3(0.0,0.0,-3.0);\n    vec3 raydir=normalize(vec3(uv,focal_length));\n    float sdf=raymarch(rayorigin,raydir);\n    vec3 sphere=spherepos;\n    float add=0.0;\n    if (sdf<epsilon){\n        col=color;\n    if(shine){\n     add=pow(max(dot(normals(spherepos),normalize(light+raydir)),0.0),1.0);\n    }\n    gleam+=max((1.0-ambient)*dot(light,normals(rayorigin))*shadow(rayorigin,light),0.0)+ambient;\n    col+=add;\n    col*=gleam;\n\n    }\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}