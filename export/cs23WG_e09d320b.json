{"ver":"0.1","info":{"id":"cs23WG","date":"1668079354","viewed":96,"name":"ray marching 2022/11/10","username":"1393323447","description":"A simple shader using ray marching.\nThanks for these series: https://www.youtube.com/playlist?list=PLGmrMu-IwbgtMxMiV3x4IrHPlPmg7FD-P","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["3d"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS 100\n#define MAX_DIS  (100.)\n#define SURFACE_DIS (.01)\n\nconst int MAT_BALL = 0;\nconst int MAT_GROUND = 1;\n\nfloat SdSphere(vec3 p) {\n    // the center point of sphere and the radiu\n    vec4 s = vec4(0., 1., 6., 1.);\n    return length(p - s.xyz) - s.w;\n}\n\nfloat GetDist(vec3 p) {\n    // distance to ground\n    float dg = p.y;\n    float ds = SdSphere(p);\n    float dis = min(ds, dg);\n    return dis;\n}\n\nint GetMat(vec3 p) {\n    // distance to ground\n    float dg = p.y;\n    float ds = SdSphere(p);\n    float dis = min(ds, dg);\n    if (ds < dg) {\n        return MAT_BALL;\n    } else {\n        return MAT_GROUND;\n    }\n}\n\nvec3 GetNormal(vec3 p) {\n    vec2 e = vec2(.01, 0.);\n    vec3 n = GetDist(p) - vec3(\n        GetDist(p - e.xyy),\n        GetDist(p - e.yxy),\n        GetDist(p - e.yyx)\n    );\n\n    return normalize(n);\n}\n\nfloat RayMatch(vec3 ro, vec3 rd) {\n    float d = 0.;\n\n    for (int i = 0; i < MAX_STEPS; i++) {\n        vec3 p = ro + d * rd;\n        float dis = GetDist(p);\n        d += dis;\n        if (d > MAX_DIS || abs(dis) < SURFACE_DIS) {\n            break;\n        }\n    }\n\n    return d;\n}\n\n// return a light with color\nvec3 GetLight(vec3 ro, vec3 rd) {\n    float t = iTime;\n    \n    vec3 col = texture(iChannel0, rd).rgb;\n    // closest distance to the sence\n    float dis = RayMatch(ro, rd);\n    \n    if (dis < MAX_DIS) {\n        // hit point\n        vec3 p = ro + dis * rd;\n        vec3 pl = vec3(0. + sin(t), 5., 6. + cos(t) * 2.);\n        // light vector\n        vec3 l = normalize(pl - p);\n        vec3 n = GetNormal(p);\n        vec3 r = reflect(rd, n);\n        vec3 ref = texture(iChannel0, r).rgb;\n\n        // add shadow\n        float dl = RayMatch(p + n * SURFACE_DIS * 2., l);\n        float ds = length(pl - p);\n        float light = 0.;\n        if (ds <= dl) {\n            // not in shadow\n            light = clamp(dot(n, l), 0., 1.);\n        }\n        \n        int mat = GetMat(p);\n        switch(mat) {\n        case MAT_BALL:\n            col = ref;\n            break;\n        case MAT_GROUND:\n            break;\n        default:\n            break;\n        }\n    }\n\n    return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    float t = iTime;\n    // camera\n    vec3 ro = vec3(0. + 3. * sin(t), 1., 6. -3. * cos(t));\n    vec3 lookat = vec3(0., 1., 6.);\n    vec3 f = normalize(lookat - ro);\n    vec3 r = normalize(cross(vec3(0., 1., 0.), f));\n    vec3 up = cross(f, r);\n    float zoom = clamp(.8 * sin(t), .3, 1.);\n    vec3 c = ro + f * zoom;\n    vec3 i = c + uv.x * r + uv.y * up;\n    vec3 rd = i - ro;\n    \n    \n    vec3 light = GetLight(ro, rd);\n\n    // gamma correction\n    vec3 col = pow(light, vec3(.4545));\n\n    fragColor = vec4(col, 1.);\n}\n","name":"Image","description":"","type":"image"}]}