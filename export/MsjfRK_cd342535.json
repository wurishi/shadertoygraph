{"ver":"0.1","info":{"id":"MsjfRK","date":"1501495497","viewed":351,"name":"[SH17C] Doppler Play","username":"eliemichel","description":"Play with Doppler effect on light.\n\nControls: Mouse click & slide\n\nNB: Though drop shots should are theoretically possible to augment wavelength, it is actually tricky to do here... Stay tunned I'll update if I find a better way of interacting with light!","likes":6,"published":1,"flags":32,"usePreview":0,"tags":["wave","educational"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Copyright (c) 2017 - Élie Michel\n// License: CC BY 3.0\n// Please credit even if you are just re-using the particle system.\n\n// Sync with 'Buf A' and 'Buf B' buffers\nconst float dt = 0.001;\n\nmat3 particleSpaceMatrix(vec2 origin, vec2 velocity) {\n    vec3 O = vec3(origin, 1.);\n    vec3 X = normalize(vec3(velocity, 0.));\n    vec3 Y = cross(vec3(0., 0., 1.), X);\n    return mat3(X, Y, O);\n}\nconst float celerity = 1200.0;\n\nvec4 data(int addr) {\n    int h = int(iResolution.y);\n    ivec2 v = ivec2(addr / h, addr % h);\n    return textureLod(iChannel0, (vec2(v) + vec2(0.5, 0.5))/iResolution.xy, 0.0);\n}\n\nstruct Header {\n    vec2 mouse;\n    vec2 oldMouse;\n    int nbParticles;\n};\nconst int sizeofHeader = 2;\nHeader getHeader() {\n    vec4 d0 = data(0);\n    vec4 d1 = data(1);\n    return Header(d0.xy, d0.zw, int(d1.x));\n}\n\nstruct Particle {\n    vec4 color;\n    vec2 position;\n    vec2 velocity;\n    float wavelength;\n    float phi;\n    float lastHit;  // Time since last collision\n};\nconst int sizeofParticle = 4;\nconst int colorField = 0;\nconst int posVelField = 1;\nconst int wavelengthField = 2;\nParticle getParticle(int index) {\n    int offset = sizeofHeader + index * sizeofParticle;\n    vec4 color = data(offset + colorField);\n    vec4 posVel = data(offset + posVelField);\n    vec4 wavelengthPhi = data(offset + wavelengthField);\n    return Particle(color, posVel.xy, posVel.zw, wavelengthPhi.x, wavelengthPhi.y, wavelengthPhi.z);\n}\nvec2 particleHeadPosition(Particle particle, float time) {\n    mat3 M = particleSpaceMatrix(particle.position, particle.velocity);\n    float omega = 2.0 * 3.1415 * celerity / particle.wavelength;\n    float l = sin(omega * time + particle.phi) * 0.02;\n    return M[2].xy - l * M[1].xy;\n}\n\nvec2 getMouse() {\n    vec2 mouse = iMouse.xy;\n    if (length(mouse) <= 0.0001) {\n        mouse = vec2(0.3 + sin(5.0 * iTime) * 0.1, 0.3) * iResolution.y;\n    }\n    return mouse;\n}\n//\n\nvoid plotAxis(inout vec4 fragColor, vec2 basis) {\n    float ax;\n    ax = smoothstep(0., 1., abs(basis.y) * iResolution.y);\n    fragColor = mix(vec4(1., 0., 0., 1.), fragColor, ax);\n    ax = smoothstep(0., 1., abs(basis.x) * iResolution.y);\n    fragColor = mix(vec4(0., 1., 0., 1.), fragColor, ax);\n}\n\nconst float period = 2.5;\nconst float omega = 100.0;\nconst float A = 0.01;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv0 = fragCoord.xy / iResolution.xy;\n\tvec2 uv = fragCoord.xy / iResolution.y;\n\tfragColor = vec4(uv,0.5+0.5*sin(iTime),1.0);\n    fragColor = vec4(0.0);\n    \n    vec2 xy;\n\n    float t = iTime * 0.3;\n    float st = t - round(t/period)*period;\n    float s0 = st - 0.5, s1 = st;\n    float s = xy.x;\n    \n    Header header = getHeader();\n    for (int i = 0 ; i < header.nbParticles ; ++i) {\n        Particle particle = getParticle(i);\n        vec2 p = particleHeadPosition(particle, iTime);\n        vec4 c = mix(vec4(1.0), particle.color, length(uv - p) * 100.0);\n        fragColor += mix(c, vec4(0.0), min(1.0, length(uv - p) * 100.0));\n    }\n    \n    fragColor += texture(iChannel1, uv0);\n    \n    //plotAxis(fragColor, xy);\n    plotAxis(fragColor, uv-getMouse().xy/iResolution.y);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Copyright (c) 2017 - Élie Michel\n// License: CC BY 3.0\n// Please credit even if you are just re-using the particle system.\n\n// Sync with 'Image' buffer\nconst float dt = 0.001;\n\nmat3 particleSpaceMatrix(vec2 origin, vec2 velocity) {\n    vec3 O = vec3(origin, 1.);\n    vec3 X = normalize(vec3(velocity, 0.));\n    vec3 Y = cross(vec3(0., 0., 1.), X);\n    return mat3(X, Y, O);\n}\nconst float celerity = 1200.0;\n\nvec4 data(int addr) {\n    int h = int(iResolution.y);\n    ivec2 v = ivec2(addr / h, addr % h);\n    return textureLod(iChannel0, (vec2(v) + vec2(0.5, 0.5))/iResolution.xy, 0.0);\n}\n\nstruct Header {\n    vec2 mouse;\n    vec2 oldMouse;\n    int nbParticles;\n};\nconst int sizeofHeader = 2;\nHeader getHeader() {\n    vec4 d0 = data(0);\n    vec4 d1 = data(1);\n    return Header(d0.xy, d0.zw, int(d1.x));\n}\n\nstruct Particle {\n    vec4 color;\n    vec2 position;\n    vec2 velocity;\n    float wavelength;\n    float phi;\n    float lastHit;  // Time since last collision\n};\nconst int sizeofParticle = 4;\nconst int colorField = 0;\nconst int posVelField = 1;\nconst int wavelengthField = 2;\nParticle getParticle(int index) {\n    int offset = sizeofHeader + index * sizeofParticle;\n    vec4 color = data(offset + colorField);\n    vec4 posVel = data(offset + posVelField);\n    vec4 wavelengthPhi = data(offset + wavelengthField);\n    return Particle(color, posVel.xy, posVel.zw, wavelengthPhi.x, wavelengthPhi.y, wavelengthPhi.z);\n}\nvec2 particleHeadPosition(Particle particle, float time) {\n    mat3 M = particleSpaceMatrix(particle.position, particle.velocity);\n    float omega = 2.0 * 3.1415 * celerity / particle.wavelength;\n    float l = sin(omega * time + particle.phi) * 0.02;\n    return M[2].xy - l * M[1].xy;\n}\n\nvec2 getMouse() {\n    vec2 mouse = iMouse.xy;\n    if (length(mouse) <= 0.0001) {\n        mouse = vec2(0.3 + sin(5.0 * iTime) * 0.1, 0.3) * iResolution.y;\n    }\n    return mouse;\n}\n//\n\n// Inspired by http://www.noah.org/wiki/Wavelength_to_RGB_in_Python\nvec3 colorFromWavelength(float wavelength) {\n    const float gamma = 0.8;\n    float r, g, b;\n    if (wavelength >= 380. && wavelength <= 440.) {\n        float attenuation = .3 + .7 * (wavelength - 380.) / (440. - 380.);\n        r = pow((-(wavelength - 440.) / (440. - 380.)) * attenuation, gamma);\n        g = 0.;\n        b = pow(1.0 * attenuation, gamma);\n    } else if (wavelength >= 440. && wavelength <= 490.) {\n        r = 0.;\n        g = pow((wavelength - 440.) / (490. - 440.), gamma);\n        b = 1.;\n    } else if (wavelength >= 490. && wavelength <= 510.) {\n        r = 0.;\n        g = 1.;\n        b = pow(-(wavelength - 510.) / (510. - 490.), gamma);\n    } else if (wavelength >= 510. && wavelength <= 580.) {\n        r = pow((wavelength - 510.) / (580. - 510.), gamma);\n        g = 1.;\n        b = 0.;\n    } else if (wavelength >= 580. && wavelength <= 645.) {\n        r = 1.;\n        g = pow(-(wavelength - 645.) / (645. - 580.), gamma);\n        b = 0.;\n    } else if (wavelength >= 645. && wavelength <= 750.) {\n        float attenuation = .3 + .7 * (750. - wavelength) / (750. - 645.);\n        r = pow(1. * attenuation, gamma);\n        g = 0.;\n        b = 0.;\n    } else {\n        r = 1.;\n        g = 1.;\n        b = 1.;\n    }\n    return vec3(r, g, b);\n}\n\nvoid writeHeader(out vec4 fragColor, in int addr) {\n    switch (addr) {\n    case 0:\n    {\n        Header header = getHeader();\n        vec2 mouse = getMouse();\n        vec2 oldMouse = header.mouse;\n        fragColor = vec4(mouse, oldMouse);\n        break;\n    }\n    case 1:\n        fragColor = vec4(30.0);\n        break;\n    }\n}\n\nvoid updateParticle(inout Particle particle, int particleId) {\n    bool init = iTime < 0.1;\n    //init = true;\n    \n    vec2 velocity = particle.velocity;\n    vec2 position = particle.position + dt * velocity;\n    vec2 headPosition = particleHeadPosition(particle, iTime);\n    float wavelength = particle.wavelength;\n    float phi = particle.phi;\n    float lastHit = particle.lastHit;\n\n    // Out-of-bounds reset\n    if ((position.x < 0.0 && velocity.x < 0.0)\n        || (position.x > iResolution.x/iResolution.y && velocity.x > 0.0)\n        || (position.y < 0.0 && velocity.y < 0.0)\n        || (position.y > 1.0 && velocity.y > 1.0)) {\n        init = true;\n    }\n    if (init) {\n        velocity = vec2(-1.0, -0.5) * 4.0;\n        position = vec2(0.9 + float(particleId) * 0.1, 1.1);\n        wavelength = 700.0;  // nm\n        phi = float(particleId);\n        lastHit = 9999.0;\n        \n        wavelength = 450.0 + 90.0 * float(particleId % 3);\n        float theta = 3.1415 * (0.15 + 0.1 * float(particleId % 3));\n        vec2 offset = (0.1 - 0.005 * float(particleId)) * vec2(-sin(theta), cos(theta));\n        position = vec2(1.0, 1.0) + 0.5 * vec2(cos(theta), sin(theta)) + offset;\n        velocity = -vec2(cos(theta), sin(theta)) * celerity / 300.0;\n        \n        if (iTime < 0.1) {\n            position = vec2(0.5);\n        }\n    }\n    \n    if (lastHit >= 0.) {\n        lastHit += 1.0;\n    }\n    \n    vec2 mouse = getMouse();\n    \n    // Collision detection\n    if (!init && lastHit > 20.0 && headPosition.x < mouse.x/iResolution.y) {\n        Header header = getHeader();\n        vec2 deltaMouse = (header.oldMouse.xy - mouse.xy)/iResolution.y;\n        \n        if (velocity.x <= 0.0) {\n            position = particleHeadPosition(particle, iTime) + dt * velocity;\n            //velocity *= (1.0 - deltaMouse.x * 1.0);\n            //velocity.x -= deltaMouse.x * 10.0;\n            velocity.x = -velocity.x;\n            wavelength = clamp(wavelength + deltaMouse.x * 2000.0, 380., 750.);\n            //wavelength = 9999.0;\n            float omega = 2.0 * 3.1415 * celerity / wavelength;\n            phi = -omega * iTime;\n            //phi += 3.1415;\n            //lastHit = 0.0;\n        }\n        \n        position.x = mouse.x/iResolution.y;\n    }\n    \n    // Write\n    //particle.color = vec4(1.0, 0.5, float(particleId) * 0.2, 1.0);\n    particle.color = vec4(colorFromWavelength(wavelength), 1.0);\n    particle.position = position;\n    particle.velocity = velocity;\n    particle.wavelength = wavelength;\n    particle.phi = phi;\n    particle.lastHit = lastHit;\n}\n\nvoid writeParticle(out vec4 fragColor, in int addr) {\n    // Frag coord in particle/field space\n    int field = addr % sizeofParticle;\n    int particleId = addr / sizeofParticle;\n    \n    // Load particle info\n    Particle particle = getParticle(particleId);\n        \n    // Update all fields (It's required to update all fields even though we\n    // only write some of them in a given fragment because for instance\n    // wavelength needs to be aware of the changes of velocity/position.)\n    updateParticle(particle, particleId);\n    \n    switch (field) {\n    case colorField:\n        fragColor = particle.color;\n        break;\n    case posVelField:\n        fragColor = vec4(particle.position, particle.velocity);\n        break;\n    case wavelengthField:\n        fragColor = vec4(particle.wavelength, particle.phi, particle.lastHit, 0.0);\n        break;\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 st = ivec2(fragCoord);\n    int addr = st.x * int(iResolution.y) + st.y;\n    \n    if (addr < sizeofHeader) {\n        writeHeader(fragColor, addr);\n    } else {\n        addr -= sizeofHeader;\n        writeParticle(fragColor, addr);\n    }\n}","name":"Buf A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// Copyright (c) 2017 - Élie Michel\n// License: CC BY 3.0\n// Please credit even if you are just re-using the particle system.\n\n// Sync with 'Image' buffer\nconst float dt = 0.001;\n\nmat3 particleSpaceMatrix(vec2 origin, vec2 velocity) {\n    vec3 O = vec3(origin, 1.);\n    vec3 X = normalize(vec3(velocity, 0.));\n    vec3 Y = cross(vec3(0., 0., 1.), X);\n    return mat3(X, Y, O);\n}\nconst float celerity = 1200.0;\n\nvec4 data(int addr) {\n    int h = int(iResolution.y);\n    ivec2 v = ivec2(addr / h, addr % h);\n    return textureLod(iChannel0, (vec2(v) + vec2(0.5, 0.5))/iResolution.xy, 0.0);\n}\n\nstruct Header {\n    vec2 mouse;\n    vec2 oldMouse;\n    int nbParticles;\n};\nconst int sizeofHeader = 2;\nHeader getHeader() {\n    vec4 d0 = data(0);\n    vec4 d1 = data(1);\n    return Header(d0.xy, d0.zw, int(d1.x));\n}\n\nstruct Particle {\n    vec4 color;\n    vec2 position;\n    vec2 velocity;\n    float wavelength;\n    float phi;\n    float lastHit;  // Time since last collision\n};\nconst int sizeofParticle = 4;\nconst int colorField = 0;\nconst int posVelField = 1;\nconst int wavelengthField = 2;\nParticle getParticle(int index) {\n    int offset = sizeofHeader + index * sizeofParticle;\n    vec4 color = data(offset + colorField);\n    vec4 posVel = data(offset + posVelField);\n    vec4 wavelengthPhi = data(offset + wavelengthField);\n    return Particle(color, posVel.xy, posVel.zw, wavelengthPhi.x, wavelengthPhi.y, wavelengthPhi.z);\n}\nvec2 particleHeadPosition(Particle particle, float time) {\n    mat3 M = particleSpaceMatrix(particle.position, particle.velocity);\n    float omega = 2.0 * 3.1415 * celerity / particle.wavelength;\n    float l = sin(omega * time + particle.phi) * 0.02;\n    return M[2].xy - l * M[1].xy;\n}\n\nvec2 getMouse() {\n    vec2 mouse = iMouse.xy;\n    if (length(mouse) <= 0.0001) {\n        mouse = vec2(0.3 + sin(5.0 * iTime) * 0.1, 0.3) * iResolution.y;\n    }\n    return mouse;\n}\n//\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv0 = fragCoord.xy / iResolution.xy;\n    vec2 uv = fragCoord.xy / iResolution.y;\n    fragColor = texture(iChannel1, uv0) * 0.98;\n    \n    Header header = getHeader();\n    for (int i = 0 ; i < header.nbParticles ; ++i) {\n        Particle particle = getParticle(i);\n        vec2 p = particleHeadPosition(particle, iTime);\n        fragColor += mix(particle.color, vec4(0.0), min(1.0, length(uv - p) * 200.0));\n    }\n}","name":"Buf B","description":"","type":"buffer"}]}