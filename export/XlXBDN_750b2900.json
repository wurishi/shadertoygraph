{"ver":"0.1","info":{"id":"XlXBDN","date":"1511868263","viewed":139,"name":"try camera and z test,texture","username":"cailuming","description":"test for camera and sphere intersection, visibility","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["sphere","camera"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sXGzn","filepath":"/media/a/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3","previewfilepath":"/media/ap/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3","type":"music","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.1415926\nstruct Sphere{\n    vec3 center;\n    vec3 color;\n    vec3 surP;\n    vec3 norm;\n    float radius;\n    float nl;\n};\n\nstruct Ray{\n    vec3 origin;\n    vec3 dir;\n};\n\n\nfloat disToSphere(vec3 p,vec3 hitP){\n   return 3./length(p-hitP);\n}\n\nvec3 sphereTex(vec3 p,vec3 center,int type){\n    //texture type \n    if(type==0){\n       return vec3(sin(iTime+20.*dot(normalize(p-center),vec3(1.,cos(iTime),0))));\n    }else if(type==1){\n       return vec3(cos(iTime+2.*dot(normalize(p-center),vec3(0,1.,1))));\n    }else if(type==2){\n       return vec3(sin(iTime+5.*dot(normalize(p-center),vec3(1,cos(iTime),0))));\n    }\n}\n\n\n/* \n   sphere intersect from wiki,basically \n*/\nvoid IntersectSphere(Ray ray,out Sphere sphere,vec3 lightPos,int id){\n\n   vec3 r1 = ray.origin-sphere.center;\n   \n   float dt=dot(ray.dir,r1);\n   float root=pow(dt,2.)-pow(length(r1),2.)+pow(sphere.radius,2.);\n   \n   if(root>=0.){\n      sphere.surP=ray.origin+(-dt-sqrt(root))*ray.dir;\n      sphere.norm=normalize(sphere.surP-sphere.center);\n      sphere.nl=dot(sphere.norm,normalize(lightPos-sphere.surP));\n      sphere.nl=clamp(sphere.nl+pow(sphere.nl,9.),0.,3.);\n      sphere.color*=sphere.nl*sphereTex(sphere.surP,sphere.center,id); \n   }\n}\n \n \n// the god light\nvoid drawLight(out vec3 col,vec3 center,Ray ray,vec3 color,vec3 refP){\n    float strength=0.;\n    float strength1=0.;\n    float disToCenter=length(ray.origin-center);\n    vec3 p;\n    //ray marching to calculate the sun color,and do the Z test at the same time\n    for(int i=0;i<50;i++){\n       p=ray.origin+ray.dir*(float(i)/50.)*disToCenter;\n       if(p.z<refP.z){\n          strength+=disToSphere(p,center);\n          strength1+=sin(5.*atan((p-center).y,(p-center).x)+iTime);\n       }\n    }\n    \n    strength=pow(abs(strength)/50.,8.);\n    strength1=clamp(pow(abs(strength1)/60.,8.),0.,1.);\n    col+= vec3(strength1);\n    \n    col+=vec3(strength)*color;\n}\n\n// draw all the sphere including the visibility test \nvec3 drawSphere(Ray ray,vec2 uv,vec3 lightPos,vec3 lightColor){\n   Sphere sphere[3];\n   sphere[0].center=vec3(8.*cos(iTime),0.,11.0+5.*sin(iTime));\n   sphere[0].color=vec3(0.8*cos(iTime),0.8*sin(iTime),0.5);\n   sphere[0].surP=vec3(10000);\n   sphere[0].norm=vec3(0);\n   sphere[0].nl=0.;   \n   sphere[0].radius=1.0;\n    \n   sphere[1].center=vec3(12.*cos(iTime+PI*2./3.),0.,11.0+5.*sin(iTime+PI*2./3.));\n   sphere[1].color=vec3(0.8*sin(iTime),1,0);\n   sphere[1].surP=vec3(10000);\n   sphere[1].norm=vec3(0);\n   sphere[1].nl=0.;  \n   sphere[1].radius=1.0;\n    \n   sphere[2].center=vec3(10.*cos(iTime+PI/3.),0,11.0+5.*sin(iTime+PI/3.));\n   sphere[2].color=vec3(0.8*sin(iTime)+0.3,cos(iTime)+0.4,1);\n   sphere[2].surP=vec3(10000);\n   sphere[2].norm=vec3(0);\n   sphere[2].nl=0.;  \n   sphere[2].radius=1.0;\n   \n    \n   \n   // make the reference point large enough\n   vec3 refP=vec3(10000);\n   vec3 col =vec3(0);\n   vec3 center =vec3(0);\n  \n   // make the sphere intersect which is cheap than the ray marching\n   for(int i=0;i<3;i++){\n       IntersectSphere(ray,sphere[i],lightPos,int(mod(float(i),3.)));\n       if(sphere[i].surP.z<refP.z){\n          refP=sphere[i].surP;\n          col=sphere[i].color;\n       }\n   }\n    \n   if(lightPos.z<refP.z){\n       drawLight(col,lightPos,ray,lightColor,refP);\n   } \n    \n   return col*lightColor;\n}\n \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    float aspect=iResolution.x/iResolution.y;\n    float freq=texture(iChannel0,vec2(0.0,0)).y;\n    uv.x*= aspect;\n    \n    vec4 uvw = vec4(uv*2.-vec2(aspect,1),0,1);\n    vec3 eyePos = vec3(sin(iTime)*0.5,-0.4,-1.+0.5*cos(iTime*0.1));\n    vec3 camUp = vec3(0,1,0);\n    vec3 camRight = vec3(1,0,0);\n    vec3 camLook = vec3(0,1,1);\n    \n    vec3 lightPos =vec3(0,freq-0.6,7);\n    \n    vec3 col =vec3(0);\n    \n    Ray ray=Ray(eyePos,normalize(uvw.xyz-eyePos));\n    \n  \n    col+= drawSphere(ray,uvw.xy,lightPos,vec3(0.1*cos(iTime)+1.,0.1*sin(iTime)+1.,0.5));\n    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}