{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[{"channel":0,"type":"keyboard","id":"4dXGRr","filepath":"/presets/tex00.jpg","sampler":{"filter":"nearest","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"}}],"code":"// Number Printing - @P_Malin\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\nconst float kCharBlank = 12.0;\nconst float kCharMinus = 11.0;\nconst float kCharDecimalPoint = 10.0;\n\nfloat k1=0.0;\nfloat k2=0.0;\nfloat k3=0.0;\n\nfloat InRect(const in vec2 vUV, const in vec4 vRect)\n{\n\tvec2 vTestMin = step(vRect.xy, vUV.xy);\n\tvec2 vTestMax = step(vUV.xy, vRect.zw);\t\n\tvec2 vTest = vTestMin * vTestMax;\n\treturn vTest.x * vTest.y;\n}\n\nfloat SampleDigit(const in float fDigit, const in vec2 vUV)\n{\n\tconst float x0 = 0.0 / 4.0;\n\tconst float x1 = 1.0 / 4.0;\n\tconst float x2 = 2.0 / 4.0;\n\tconst float x3 = 3.0 / 4.0;\n\tconst float x4 = 4.0 / 4.0;\n\t\n\tconst float y0 = 0.0 / 5.0;\n\tconst float y1 = 1.0 / 5.0;\n\tconst float y2 = 2.0 / 5.0;\n\tconst float y3 = 3.0 / 5.0;\n\tconst float y4 = 4.0 / 5.0;\n\tconst float y5 = 5.0 / 5.0;\n\n\t// In this version each digit is made of up to 3 rectangles which we XOR together to get the result\n\t\n\tvec4 vRect0 = vec4(0.0);\n\tvec4 vRect1 = vec4(0.0);\n\tvec4 vRect2 = vec4(0.0);\n\t\t\n\tif(fDigit < 0.5) // 0\n\t{\n\t\tvRect0 = vec4(x0, y0, x3, y5); vRect1 = vec4(x1, y1, x2, y4);\n\t}\n\telse if(fDigit < 1.5) // 1\n\t{\n\t\tvRect0 = vec4(x1, y0, x2, y5); vRect1 = vec4(x0, y0, x0, y0);\n\t}\n\telse if(fDigit < 2.5) // 2\n\t{\n\t\tvRect0 = vec4(x0, y0, x3, y5); vRect1 = vec4(x0, y3, x2, y4); vRect2 = vec4(x1, y1, x3, y2);\n\t}\n\telse if(fDigit < 3.5) // 3\n\t{\n\t\tvRect0 = vec4(x0, y0, x3, y5); vRect1 = vec4(x0, y3, x2, y4); vRect2 = vec4(x0, y1, x2, y2);\n\t}\n\telse if(fDigit < 4.5) // 4\n\t{\n\t\tvRect0 = vec4(x0, y1, x2, y5); vRect1 = vec4(x1, y2, x2, y5); vRect2 = vec4(x2, y0, x3, y3);\n\t}\n\telse if(fDigit < 5.5) // 5\n\t{\n\t\tvRect0 = vec4(x0, y0, x3, y5); vRect1 = vec4(x1, y3, x3, y4); vRect2 = vec4(x0, y1, x2, y2);\n\t}\n\telse if(fDigit < 6.5) // 6\n\t{\n\t\tvRect0 = vec4(x0, y0, x3, y5); vRect1 = vec4(x1, y3, x3, y4); vRect2 = vec4(x1, y1, x2, y2);\n\t}\n\telse if(fDigit < 7.5) // 7\n\t{\n\t\tvRect0 = vec4(x0, y0, x3, y5); vRect1 = vec4(x0, y0, x2, y4);\n\t}\n\telse if(fDigit < 8.5) // 8\n\t{\n\t\tvRect0 = vec4(x0, y0, x3, y5); vRect1 = vec4(x1, y1, x2, y2); vRect2 = vec4(x1, y3, x2, y4);\n\t}\n\telse if(fDigit < 9.5) // 9\n\t{\n\t\tvRect0 = vec4(x0, y0, x3, y5); vRect1 = vec4(x1, y3, x2, y4); vRect2 = vec4(x0, y1, x2, y2);\n\t}\n\telse if(fDigit < 10.5) // '.'\n\t{\n\t\tvRect0 = vec4(x1, y0, x2, y1);\n\t}\n\telse if(fDigit < 11.5) // '-'\n\t{\n\t\tvRect0 = vec4(x0, y2, x3, y3);\n\t}\t\n\t\n\tfloat fResult = InRect(vUV, vRect0) + InRect(vUV, vRect1) + InRect(vUV, vRect2);\n\t\n\treturn mod(fResult, 2.0);\n}\n\n\nfloat PrintValue(const in vec2 vStringCharCoords, const in float fValue, const in float fMaxDigits, const in float fDecimalPlaces)\n{\n\tfloat fAbsValue = abs(fValue);\n\t\n\tfloat fStringCharIndex = floor(vStringCharCoords.x);\n\t\n\tfloat fLog10Value = log2(fAbsValue) / log2(10.0);\n\tfloat fBiggestDigitIndex = max(floor(fLog10Value), 0.0);\n\t\n\t// This is the character we are going to display for this pixel\n\tfloat fDigitCharacter = kCharBlank;\n\t\n\tfloat fDigitIndex = fMaxDigits - fStringCharIndex;\n\tif(fDigitIndex > (-fDecimalPlaces - 1.5))\n\t{\n\t\tif(fDigitIndex > fBiggestDigitIndex)\n\t\t{\n\t\t\tif(fValue < 0.0)\n\t\t\t{\n\t\t\t\tif(fDigitIndex < (fBiggestDigitIndex+1.5))\n\t\t\t\t{\n\t\t\t\t\tfDigitCharacter = kCharMinus;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\t\t\n\t\t\tif(fDigitIndex == -1.0)\n\t\t\t{\n\t\t\t\tif(fDecimalPlaces > 0.0)\n\t\t\t\t{\n\t\t\t\t\tfDigitCharacter = kCharDecimalPoint;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif(fDigitIndex < 0.0)\n\t\t\t\t{\n\t\t\t\t\t// move along one to account for .\n\t\t\t\t\tfDigitIndex += 1.0;\n\t\t\t\t}\n\n\t\t\t\tfloat fDigitValue = (fAbsValue / (pow(10.0, fDigitIndex)));\n\n\t\t\t\t// This is inaccurate - I think because I treat each digit independently\n\t\t\t\t// The value 2.0 gets printed as 2.09 :/\n\t\t\t\t//fDigitCharacter = mod(floor(fDigitValue), 10.0);\n\t\t\t\tfDigitCharacter = mod(floor(0.0001+fDigitValue), 10.0); // fix from iq\n\t\t\t}\t\t\n\t\t}\n\t}\n\n\tvec2 vCharPos = vec2(fract(vStringCharCoords.x), vStringCharCoords.y);\n\n\treturn SampleDigit(fDigitCharacter, vCharPos);\t\n}\n\nfloat PrintValue(const in vec2 fragCoord, const in vec2 vPixelCoords, const in vec2 vFontSize, const in float fValue, const in float fMaxDigits, const in float fDecimalPlaces)\n{\n\treturn PrintValue((fragCoord.xy - vPixelCoords) / vFontSize, fValue, fMaxDigits, fDecimalPlaces);\n}\n\nfloat c(float x) {\n    return (x+1.0)/2.0;\n}\n\nfloat d(float x) {\n    return 2.0*x-1.0;\n}\n\nfloat ntsf(float x,float k) {\n    return (x-x*k)/(k-abs(x)*2.0*k+1.0);\n}\n\nfloat ntsf3(float x,float k1,float k2,float k3) {\n    return d(ntsf(c(ntsf(d(ntsf(c(x),k1)),k2)),k3));\n}\n\nfloat GetCurve(float x)\n{\n    float s = sin(6.2831*440.0*x/50.0)*1.0 + sin(6.2831*523.25*x/50.0)*1.0 + sin(6.2831*659.25*x/50.0)*1.0;\n\treturn ntsf3(s/3.0,k1,k2,k3);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 vColour = vec3(0.0);\n    \n    k1++;\n\n\t// Multiples of 4x5 work best\n\tvec2 vFontSize = vec2(8.0, 15.0);\n   \t\t\n\t// Plot Mouse Pos\n\tfloat fDistToPointB = length( vec2(iMouse.x, iMouse.y) - fragCoord.xy) - 4.0;\n//\tvColour = mix(vColour, vec3(0.0, 1.0, 0.0), (1.0 - clamp(fDistToPointB, 0.0, 1.0)));\n\t\n\n    float fDigits = 1.0;\n\tfloat fDecimalPlaces = 2.0;\n\t\n\t// Print Shader Time\n\tvec2 vPixelCoord1 = vec2(96.0, 5.0);\n\tfloat fValue1 = iTime;\n\tfDigits = 6.0;\n\tfloat fIsDigit1 = PrintValue(fragCoord, vPixelCoord1, vFontSize, fValue1, fDigits, fDecimalPlaces);\n//\tvColour = mix( vColour, vec3(0.0, 1.0, 1.0), fIsDigit1);\n\n    \n\tif(iMouse.x > 0.0)\n\t{\n\t\t// Print Mouse X\n\t\tvec2 vPixelCoord2 = vec2(0,5);\n\t\tfloat fValue2 = iMouse.x / iResolution.x;\n\t\tfDigits = 1.0;\n\t\tfDecimalPlaces = 3.0;\n\t\tfloat fIsDigit2 = PrintValue(fragCoord, vPixelCoord2, vFontSize, fValue2, fDigits, fDecimalPlaces);\n//\t\tvColour = mix( vColour, vec3(0.0, 1.0, 0.0), fIsDigit2);\n\t\t\n\t\t// Print Mouse Y\n\t\tvec2 vPixelCoord3 = vec2(0.0, 25);\n\t\tfloat fValue3 = iMouse.x / iResolution.y;\n\t\tfDigits = 1.0;\n\t\tfloat fIsDigit3 = PrintValue(fragCoord, vPixelCoord3, vFontSize, fValue3, fDigits, fDecimalPlaces);\n//\t\tvColour = mix( vColour, vec3(0.0, 1.0, 0.0), fIsDigit3);\n        \n       k1 = (2.0*iMouse.x / iResolution.x)-1.0;\n       k3 = (2.0*iMouse.y / iResolution.y)-1.0;\n    }\n    \n    k1=sin(2.0*iTime/5.0)*1.0;\n    k2=sin(2.0*iTime/7.0)*1.0;\n    k3=sin(2.0*iTime/11.0)*1.0;\n    \n        // Print Constants\n\tvPixelCoord1 = vec2(96.0, 65.0);\n\tfValue1 = k1;\n\tfDigits = 6.0;\n\tfIsDigit1 = PrintValue(fragCoord, vPixelCoord1, vFontSize, fValue1, fDigits, fDecimalPlaces);\n\tvColour = mix( vColour, vec3(0.0, 1.0, 1.0), fIsDigit1);\n\n    // Print Constants\n\tvPixelCoord1 = vec2(96.0, 45.0);\n\tfValue1 = k2;\n\tfDigits = 6.0;\n\tfIsDigit1 = PrintValue(fragCoord, vPixelCoord1, vFontSize, fValue1, fDigits, fDecimalPlaces);\n\tvColour = mix( vColour, vec3(0.0, 1.0, 1.0), fIsDigit1);\n\n    // Print Constants\n\tvPixelCoord1 = vec2(96.0, 25.0);\n\tfValue1 = k3;\n\tfDigits = 6.0;\n\tfIsDigit1 = PrintValue(fragCoord, vPixelCoord1, vFontSize, fValue1, fDigits, fDecimalPlaces);\n\tvColour = mix( vColour, vec3(0.0, 1.0, 1.0), fIsDigit1);\n\n     \t// Draw Sin Wave\n\t// See the comment from iq or this page\n\t// https://iquilezles.org/articles/distance\n\tfloat fCurveX = fragCoord.x / iResolution.x;\n\tfloat fSinY = (GetCurve(fCurveX) * 0.25 + 0.5) * iResolution.y;\n\tfloat fDistanceToCurve = abs(fSinY - fragCoord.y) / 1.0;//sqrt(1.0+fSinYdX*fSinYdX);\n\tfloat fSetPixel = fDistanceToCurve - 1.0; // Add more thickness\n\tvColour = mix(vec3(1.0, 0.0, 0.0), vColour, clamp(fSetPixel, 0.0, 1.0));\t\n\n\t\n\tfragColor = vec4(vColour,1.0);\n}","name":"Image","description":"","type":"image"},{"outputs":[],"inputs":[],"code":"float k1=0.28;\nfloat k2=0.52;\nfloat k3=0.33;\n\nfloat c(float x) {\n    return (x+1.0)/2.0;\n}\n\nfloat d(float x) {\n    return 2.0*x-1.0;\n}\n\nfloat ntsf(float x,float k) {\n    return (x-x*k)/(k-abs(x)*2.0*k+1.0);\n}\n\nfloat ntsf3(float x,float k1,float k2,float k3) {\n    return d(ntsf(c(ntsf(d(ntsf(c(x),k1)),k2)),k3));\n}\n\nvec2 mainSound( in int samp,float time)\n{\n    k1=sin(2.0*time/5.0)*1.0;\n    k2=sin(2.0*time/7.0)*1.0;\n    k3=sin(2.0*time/11.0)*1.0;\n    float s = sin(6.2831*440.0*time)*1.0 + sin(6.2831*523.25*time)*1.0 + sin(6.2831*659.25*time)*1.0;\n    return vec2( ntsf3(s/3.0, k1,k2,k3 ));\n}","name":"Sound","description":"","type":"sound"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":true,"mFlagKeyboard":true,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"MsSSRW","date":"1409417574","viewed":290,"name":"NTSF Distortion","username":"dndn1011","description":"Audio signal modified by 3 stage NTSF chain. Audio is three pure sine waves playing a chord of A minor.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["audiofilter"],"hasliked":0,"parentid":"","parentname":""}}