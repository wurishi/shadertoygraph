{"ver":"0.1","info":{"id":"Xl2BRw","date":"1515053117","viewed":242,"name":"Rainbow Starscape","username":"mjolnir","description":"Rainbow music visualizer based on a \"make one that looks like this\" request from a 9 year old.","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["distancefield","visualization","rainbow"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sXGzn","filepath":"/media/a/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3","previewfilepath":"/media/ap/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3","type":"music","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define XMIN -16.0\n#define XMAX 16.0\n#define YMIN -9.0\n#define YMAX 9.0\n#define CENTER vec2(0.0, 0.0)\n\n#define ITERATIONS 7\n#define SPEED 0.025\n\n#define PI 3.14159265359\n#define TWOPI 6.28318530718\n#define SIDES 3.0\n#define RADIUS 50.0 + audio * 250.0\n#define STROBES (SIDES*2.0)\n#define MINBRIGHT 0.00\n\nvec3 hsv_to_rgb(float h, float s, float v)\n{\n\tfloat c = v * s;\n\th = mod((h * 6.0), 6.0);\n\tfloat x = c * (1.0 - abs(mod(h, 2.0) - 1.0));\n\tvec3 color;\n\n\tif (0.0 <= h && h < 1.0) {\n\t\tcolor = vec3(c, x, 0.0);\n\t} else if (1.0 <= h && h < 2.0) {\n\t\tcolor = vec3(x, c, 0.0);\n\t} else if (2.0 <= h && h < 3.0) {\n\t\tcolor = vec3(0.0, c, x);\n\t} else if (3.0 <= h && h < 4.0) {\n\t\tcolor = vec3(0.0, x, c);\n\t} else if (4.0 <= h && h < 5.0) {\n\t\tcolor = vec3(x, 0.0, c);\n\t} else if (5.0 <= h && h < 6.0) {\n\t\tcolor = vec3(c, 0.0, x);\n\t} else {\n\t\tcolor = vec3(0.0, 0.0, 0.0);\n\t}\n\n\tcolor.rgb += v - c;\n\n\treturn color;\n}\n\nfloat polyDist(vec2 cartesian, vec2 polar, float theta, float sides, float radius)\n{\n    \n    float thetaDiv = TWOPI / sides;\n    \n    float pi0 = floor((polar.y - theta) / thetaDiv);\n    \n    \n    float theta0 = pi0 * thetaDiv + theta;\n    float theta1 = (pi0 + 1.0) * thetaDiv + theta;\n    \n    vec2 p0 = CENTER + vec2(cos(theta0) * radius, sin(theta0) * radius);\n    vec2 p1 = CENTER + vec2(cos(theta1) * radius, sin(theta1) * radius);\n    \n    \n    vec2 pR = cartesian - p0;\n    vec2 pS = p1 - p0;\n    \n    vec2 projRS = pS * dot(pR, pS) / dot(pS, pS);\n    \n    return distance(projRS, pR);\n}\n\nfloat star(vec2 cartesian, vec2 polar, float theta, float sides, float r, int i)\n{\n\tfloat radius = r * pow(cos(PI/3.0), float(i));\n    \n    return min(polyDist(cartesian, polar, theta, sides, radius),\n               polyDist(cartesian, polar, theta+PI, sides, radius));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    vec2 cartesian = (uv.xy - vec2(0.5)) / vec2(0.5);\n    cartesian.x *= (XMAX - XMIN);\n    cartesian.y *= (YMAX - YMIN);\n    cartesian.xy += CENTER;\n    \n    vec2 polar = vec2(length(cartesian), atan(-cartesian.y, -cartesian.x) + PI);\n    \n    float strobemod = 1.0 / STROBES;\n    float strobe = mod(polar.y / TWOPI - iTime * SPEED, strobemod) - strobemod / 2.0;\n    strobe = abs(strobe) * 2.0;\n    \n    float audio = texture(iChannel0,vec2(strobe,.25)).x;\n    \n    float dist = 1000000.0;\n    \n    \n    for (int i = 0; i < ITERATIONS; ++i)\n    {\n        float direction = mod(float(i), 2.0) == 0.0 ? 1.0 : -1.0;\n        float distortion = texture(iChannel0, vec2(float(i) / float(ITERATIONS-1), 0.25)).x;\n        \n        dist = min(dist, star(cartesian, polar, iTime * float(i+1) * SPEED * direction, SIDES, RADIUS * (1.0 + distortion / 10.0), i));\n    }\n                     \n    \n    fragColor.xyz = vec3(dist * 10.0);\n    //fragColor.xyz = vec3(length(projRS + p0) / 10.0); // cool?\n    \n    fragColor = vec4(hsv_to_rgb((dist * 1.0 + iTime) / 10.0, 1.0, audio + MINBRIGHT), 0.0);\n    fragColor = pow(fragColor, vec4(2.2));\n}\n    ","name":"Image","description":"","type":"image"}]}