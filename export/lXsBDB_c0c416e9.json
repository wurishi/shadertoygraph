{"ver":"0.1","info":{"id":"lXsBDB","date":"1728887250","viewed":34,"name":"ðŸŒŒ 5D Equirectangular Grid","username":"gllama","description":"Just playing around on sunday to assuage some higher dimensional curiosity","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["3d","grid","sdf","projection","spherical","equirectangular","3dgrid"],"hasliked":0,"parentid":"MXsfWB","parentname":"5D Equirectangular Grid"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// ðŸŒŒ 5D Equirectangular Grid\n// License CC0-1.0\n\n// It's actually pretty easy to start bumping SDFs into higher dimensions\n// This is an odd projection of a 5D grid \n// This function converts 2D UV to spherical 3D XYZ position\n\nvec3 uvTo3D(vec2 uv) {\n    float theta = uv.x * 2.0 * 3.14159265359; // Longitude\n    float phi = uv.y * 3.14159265359;         // Latitude\n    float x = sin(phi) * cos(theta);\n    float y = sin(phi) * sin(theta);\n    float z = cos(phi);\n    return vec3(x, y, z);\n}\n\n// This function maps 3D XYZ coordinates to a point on a 4-sphere in 5D\nvec4 map3DTo5D(vec3 p, out float v) {\n    // Three angles: Î¸, Ï†, Ïˆ\n    float theta = atan(p.y, p.x);            // Azimuthal angle (longitude-like)\n    float phi = acos(p.z / length(p));       // Polar angle (latitude-like)\n    float psi = length(p);                   // Additional angle for 4-sphere\n    float chi = atan(p.z, p.x);              // New angle for 5D\n\n    // Convert to 5D coordinates (using vec4 and float for the 5th dimension)\n    float x = cos(theta) * cos(psi);\n    float y = sin(theta) * cos(psi);\n    float z = cos(phi) * sin(psi);\n    float w = sin(phi) * sin(psi);\n    v = sin(chi);                            // 5th dimension (scalar)\n\n    return vec4(x, y, z, w);\n}\n\n// Signed distance function for a 5D grid\nfloat sdfLine(vec4 p, float v) {\n    float radius = .04;\n    float closestXLine = length(vec3(round(p.yzw) - p.yzw)) - radius;\n    float closestYLine = length(vec3(round(p.xzw) - p.xzw)) - radius;\n    float closestZLine = length(vec3(round(p.xyw) - p.xyw)) - radius;\n    float closestWLine = length(vec3(round(p.xyz) - p.xyz)) - radius;\n    float closestVLine = abs(round(v) - v) - radius;  // 5th dimension distance\n    return min(min(closestXLine, closestYLine), min(min(closestZLine, closestWLine), closestVLine));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    fragColor = vec4(0.);\n\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord / iResolution.xy;\n\n    // Convert 2D UV to 3D XYZ position for equirectangular mapping\n    vec3 pos3D = uvTo3D(uv) * sin(iTime * 0.5) * 3.1415926;\n    pos3D.y += 0.5;\n    pos3D.x += 0.5;\n    pos3D.z += 0.;\n\n    // Map the 3D position to a 5D point on the 4-sphere\n    float v;\n    vec4 pos4D = map3DTo5D(pos3D, v);\n    pos4D.w /= iTime;\n\n    const float MINIMUM_HIT_DISTANCE = 0.02;\n    const int NUMBER_OF_STEPS = 50;\n    float total_distance_traveled = 0.;\n    float distance_to_closest;\n    for (int i = 0; i < NUMBER_OF_STEPS; ++i) {\n        // Only raymarching in 3D\n        vec4 current_position = pos4D + total_distance_traveled * normalize(vec4(pos3D, 1.0));  // Traverse 5D space\n        distance_to_closest = sdfLine(current_position, v);\n        \n        if (distance_to_closest < MINIMUM_HIT_DISTANCE) {\n            //fragColor = vec4(1.0); // White when a grid line is hit\n            break;\n        }\n        \n        total_distance_traveled += distance_to_closest;\n    }\n     fragColor.rgb += 10.0*vec3(smoothstep(0.02, 0.01,distance_to_closest));\n         fragColor.rgb += pow(.2/distance_to_closest, 1.3)*vec3(.2,.01,.4);\n\n}\n","name":"Image","description":"","type":"image"}]}