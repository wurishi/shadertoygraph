{"ver":"0.1","info":{"id":"7sKfR1","date":"1657804643","viewed":248,"name":"Semi-Numeric Cubic Bezier SDF","username":"Envy24","description":"https://www.desmos.com/calculator/5yqnm37ffx //!\nFormulas for factoring: https://www.desmos.com/calculator/uh9mtw2wiw\n\nOther implementations:\nhttps://www.shadertoy.com/view/4sXyDr\nhttps://www.shadertoy.com/view/4sKyzW\nhttps://www.shadertoy.com/view/7lsBW2","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["sdf","bezier","bezier","distance","complex","cubic","newton","quintic","segment","parametric","metric","raphson","l2","numeric","regula","falsi"],"hasliked":0,"parentid":"NdtBz7","parentname":"Another Numeric Cubic Bezier SDF"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define R                           iResolution\n#define TO_CENTERED_NDC(SC)       ( ((SC)+(SC)-R.xy) / R.y )         // in range x=[-AR; AR], y=[-1.0; 1.0]\n#define NZMX                      ( (iMouse.x+iMouse.x-R.x) / R.x )  // in range [-1.0; 1.0]\n#define NZMY                      ( (iMouse.y+iMouse.y-R.y) / R.y )  // in range [-1.0; 1.0]\n#define LMB_IS_HOLD               ( iMouse.z > 0.0 )\n#define FIELD_SCALE                 3.0\n#define INITIALLY_FAR               9e30\n\nfloat L2(vec2 B, vec2 E)\n{\n    return length(E-B);\n}\n\n//#define P(t) (P0*(1.-t)*(1.-t)*(1.-t)+3.*P1*t*(1.-t)*(1.-t)+3.*P2*t*t*(1.-t)+P3*t*t*t)\n#define P(t) (P0 + t*(C + t*(B + t*A)))\n/*\n    First two roots will be find numerically, other three analytically.\n*/\nfloat cubicBezierSegmentSDF_L2(\n    vec2 NDC,\n    vec2 P0,\n    vec2 P1,\n    vec2 P2,\n    vec2 P3)\n{\n    vec2 A =   -P0+3.*P1-3.*P2+P3,\n         B = 3.*P0-6.*P1+3.*P2,\n         C =      -3.*P0+3.*P1,\n         D =          P0-NDC;\n    \n    float coef[6] = float[6](\n          3. * dot(A, A),\n          5. * dot(A, B),\n          2. * (2.*dot(A,C) + dot(B,B)),\n          3. * (dot(A,D)    + dot(B,C)),\n               (2.*dot(B,D) + dot(C,C)),\n               dot(C,D)\n    );\n      \n    float minSqDist = INITIALLY_FAR;\n      \n    /* This divisions lets rewrite \n        ax^5+bx^4+cx^3+dx^2+ex+f = f+x(e+x(d+x(c+x(b+x*a))))\n    as   x^5+Ax^4+Bx^3+Cx^2+Dx+E = E+x(D+x(C+x(B+x(A+x))))      -1 mult op */\n    float invA = 1.0 / coef[0];\n    coef[0] = 1.0;   coef[1] *= invA; coef[2] *= invA;\n    coef[3] *= invA; coef[4] *= invA; coef[5] *= invA;\n\n    // Find first root.\n    float t = findQuinticRootBisection(-6., 5.1, coef);\n\n    vec2 diff = vec2(P(clamp(t, 0., 1.))) - NDC;\n    minSqDist = min(minSqDist, dot(diff, diff));\n    \n    // Factorize to form (x-r0)(axxxx+bxxx+cxx+dx+e)\n    float coef_[5] = float[5](\n        coef[0],\n        coef[1] + t*coef[0],\n        coef[2] + t*(coef[1] + t*coef[0]),\n        coef[3] + t*(coef[2] + t*(coef[1] + t*coef[0])),\n        coef[4] + t*(coef[3] + t*(coef[2] + t*(coef[1] + coef[0]*t)))\n    );\n    vec2 roots[4];\n    \n    // Find other four roots (one numerically).\n    int num = solve4n(roots, coef_);\n\n    for (int r = 0; r < num; ++r)\n    {\n        diff = vec2(P(clamp(roots[r].x, 0., 1.))) - NDC;\n        minSqDist = min(minSqDist, dot(diff, diff));\n    }\n    \n    float R = sinOSC(0.0, 0.3, iTime);\n    return sqrt(minSqDist) - R;\n}\n\n/* https://www.shadertoy.com/view/ddfGz2 */\nvec3 colorize_field(float dist, vec3 color)\n{    \n    float F = 30., freq = F*dist, aa = 1./F, C = 0.7, amp = 0.2, width = F*0.01, //0.3\n          waves_sdf = C + amp*smoothstep(8./iResolution.y, 0., (width+cos(freq)) * aa),\n          exp_raise = 1. - exp(-4.*abs(dist));\n        \n    color = 1.0 - sign(dist) * color; // Change color if dist is negative. \n    color *= exp_raise;               // Attenuate color around edges.     \n    color *= waves_sdf;               // Add waves.\n    \n    return mix(color, vec3(1), smoothstep(8./iResolution.y, 0., abs(dist)) );\n}\n\nvec3 add_metric_circle(\n    vec2 NDC,\n    vec2 P0,\n    vec2 P1,\n    vec2 P2,\n    vec2 P3,\n    vec3 color)\n{\n    float unit = 7.0 / R.y;\n\n    vec2 M = \n        LMB_IS_HOLD ?\n            TO_CENTERED_NDC(iMouse.xy) * FIELD_SCALE :\n            rotateAroundZ(vec2(1, 0), iTime * 0.5) * 1.0;\n            //vec2(0);\n    \n    // Add point\n    color = mix(color, vec3(1.0, 1.0, 0.0), smoothstep(unit, 0.0, length(NDC - M) - 0.008));\n\n    float dist_form_point_to_box_edge = L2(NDC, M) - abs(cubicBezierSegmentSDF_L2(M, P0, P1, P2, P3));\n    float outline = abs(dist_form_point_to_box_edge);\n    \n    // Add metric circle\n    return mix(color, vec3(1.0, 1.0, 0.0), smoothstep(unit, 0.0, outline));\n}\n/* IQ coloring scheme */\n\nvoid mainImage( out vec4 O, in vec2 SC )\n{\n    float offs = sinOSC(-0.5, 0.5, iTime * 0.5);\n    vec2 NDC = TO_CENTERED_NDC(SC) * FIELD_SCALE;\n    \n    vec2 P0 = vec2(2.0, 0.0) * 0.65; \n    vec2 P1 = vec2(8.0, -3.0);\n    vec2 P2 = vec2(-3.0, 6.0);\n    vec2 P3 = vec2(-2.0, 0.0) * 0.65;\n    \n    P0 = rotateAroundZ(P0, iTime * 0.1) + vec2(2.*offs, -offs);\n    P1 = rotateAroundZ(P1, iTime * 0.9) + vec2(-12.*offs, 0.0);\n    P2 = rotateAroundZ(P2, iTime * 0.9) + vec2(-8.*offs, 3.*offs);\n    P3 = rotateAroundZ(P3, iTime * 0.1) + vec2(-offs*offs, offs);\n        \n    float minDist = cubicBezierSegmentSDF_L2(NDC, P0, P1, P2, P3);\n    \n    // Blending.\n    vec3 color = colorize_field(minDist, vec3(0.1, 0.4, 0.7));\n    color = add_metric_circle(NDC, P0, P1, P2, P3, color);\n\n    O = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"/* Returns sine modulated value in range [min, max]. */\nfloat sinOSC(in float min, in float max, in float T)\n{\n    float v = (sin(T) + 1.0) * 0.5; // map T to [0.0, 1.0];\n    return min + v * (max - min);   // map T to [min, max];\n}\n\nvec2 rotateAroundZ(vec2 p, float a)\n{\n    float s = sin(a);\n    float c = cos(a);\n\n    return vec2(\n        p.x * c - p.y * s,\n        p.y * c + p.x * s);\n}\n\n/*\n    Returns number of real roots.\n*/\nint solveQuadraticForReal(\n    inout vec2[2] roots,\n    in float[3] coefs)\n{\n    float discriminant = coefs[1] * coefs[1] - 4.0 * coefs[0] * coefs[2];\n    float INVa = 1.0 / (2. * coefs[0]);\n    float SQRT = sqrt(discriminant);\n\n    roots[0].x = (SQRT - coefs[1]) * INVa;  roots[0].y = 0.0;\n    roots[1].x = (-coefs[1] - SQRT) * INVa; roots[1].y = 0.0;\n\n    return \n        discriminant < 0.0 ? // No real roots?\n        0 : 2;\n}\n\n/*\n    Return value:\n        0 - no roots when A==0, B==0, C==0;\n        1 - one real, two complex roots;\n        2 - three real roots, but root[1] == root[2];\n        3 - three real roots.\n*/\nint solveCubicForReal(\n    inout vec2[3] roots,\n    in float[4] coef)\n{\n    const float oneThird = 0.33333333333333331;\n    const float TAU = 6.2831853071795862;\n\n    float inv = 1.0 / coef[0],\n          a = coef[1] * inv, b = coef[2] * inv, c = coef[3] * inv,\n          Q = (a * a - 3.0 * b) / 9.0,\n          R = ((2.0 * a * a - 9.0 * b) * a + 27.0 * c) / 54.0,\n          S = Q * Q * Q - R * R;\n\n    if (S > 0.0)\n    {\n        float phi = oneThird * acos(R / sqrt(Q * Q * Q));\n        float Re = -2.0 * sqrt(Q);\n\n        roots[0].x = Re * cos(phi) - a * oneThird;\n        roots[0].y = 0.0;\n        roots[1].x = Re * cos(phi + TAU * oneThird) - a * oneThird;\n        roots[1].y = 0.0;\n        roots[2].x = Re * cos(phi - TAU * oneThird) - a * oneThird;\n        roots[2].y = 0.0;\n\n        return 3;\n    }\n\n    if (S < 0.0 && Q > 0.0)\n    {\n        float phi = oneThird * acosh(abs(R) / sqrt(Q * Q * Q));\n        float signR = R < 0.0 ? -1.0 : 1.0;\n\n        roots[0].x = -2.0 * signR * sqrt(Q) * cosh(phi) - a * oneThird; roots[0].y = 0.0;\n\n        return 1;\n    }\n\n    if (S < 0.0 && Q < 0.0)\n    {\n        float phi = oneThird * asinh(abs(R) / sqrt(abs(Q * Q * Q)));\n        float signR = R < 0.0 ? -1.0 : 1.0;\n\n        roots[0].x = -2.0 * signR * sqrt(abs(Q)) * sinh(phi) - a * oneThird; roots[0].y = 0.0;\n\n        return 1;\n    }\n    \n    if (Q == 0.0)\n    {\n        roots[0].x = -pow(c - a * a * a / 27.0, oneThird) - a * oneThird; roots[0].y = 0.0;\n\n        return 1;\n    }\n\n    float signR = R < 0.0 ? -1.0 : 1.0;\n    float Re = signR * sqrt(Q);\n\n    roots[0].x = -2.0 * Re - a * oneThird;\n    roots[0].y = 0.0;\n    roots[1].x = Re - a * oneThird;\n    roots[1].y = 0.0;\n    roots[2] = roots[1];\n\n    return 2;\n}\n\n/* Numeric solvers. */\nfloat findQuarticRootNewtonRaphson(\n    float x, float b, float c, float d, float e)\n{\n    const float tolerance = 1e-7; /* Desired precision. */\n    const float EPSILON = 1e-14;  /* Treshold for infinitly small values. */\n    \n    float dfdx = ((4.0 * x + 3.0 * b) * x + 2.0 * c) * x + d;\n    bool quit = abs(dfdx) <= EPSILON;\n    \n    for (int i = 0; (i < 7) && (quit == false); ++i)//7\n    {\n        float f = (((x + b) * x + c) * x + d) * x + e;\n        x -= f / dfdx;          \n        dfdx = ((4.0 * x + 3.0 * b) * x + 2.0 * c) * x + d;\n        quit = (abs(f) <= tolerance) || (abs(dfdx) <= EPSILON);\n    }\n\n    return x;\n}\nfloat findQuarticRootRegulaFalsi(\n    float xl, float xr, float b, float c, float d, float e)\n{\n    const float tolerance = 1e-7; /* Desired presicion. */\n    const float EPSILON = 1e-14;  /* Treshold for infinitely small values. */\n\n    float X[2] = float[2]( xl, xr );\n    float F[2] = float[2](\n        (((xl + b) * xl + c) * xl + d) * xl + e,  // f(xl)\n        (((xr + b) * xr + c) * xr + d) * xr + e); // f(xr)\n        \n    bool quit = abs(F[1] - F[0]) <= EPSILON;\n\n    for (int i = 0; (i < 8) && (quit == false); ++i)//8\n    {\n        float x = (X[0] * F[1] - X[1] * F[0]) / (F[1] - F[0]);\n        float f = (((x + b) * x + c) * x + d) * x + e;\n    \n        int w_idx = int(abs(f - F[0]) < abs(f - F[1]));\n\n        F[w_idx] = f; X[w_idx] = x;\n\n        quit = (abs(f) <= tolerance) || (abs(F[1] - F[0]) <= EPSILON);\n    }\n\n    return X[0] + (X[1] - X[0]) * 0.5;\n}\nfloat findQuinticRootBisection(\n    float xl,\n    float xr,\n    float c[6])\n{\n    const float tolerance = 1e-7; /* Desired precision */\n\n    float X[2] = float[2]( xl, xr );\n    float F[2] = float[2](\n        c[5] + xl * (c[4] + xl * (c[3] + xl * (c[2] + xl * (c[1] + xl)))),  // f(xl)\n        c[5] + xr * (c[4] + xr * (c[3] + xr * (c[2] + xr * (c[1] + xr))))); // f(xr)\n    float f = 0.5;\n\n    for (int i = 0; (i < 16) && (abs(f) > tolerance); ++i)//16\n    {\n        // Make step of bisection method.\n        float x = X[0] + (X[1] - X[0]) * 0.5;\n        float f = c[5] + x * (c[4] + x * (c[3] + x * (c[2] + x * (c[1] + x))));\n\n        // Pick new range.\n        int w_idx = int(sign(F[0]) != sign(f));       \n        F[w_idx] = f; X[w_idx] = x;\n    }\n\n    return X[0] + (X[1] - X[0]) * 0.5;\n}\n/* Numeric solvers. */\n\n/*  Ugly and unstable.\n    Returns number of real roots.       \n*/\nint solve4n(\n    inout vec2[4] roots,\n    in float[5] coef)\n{\n    // Quartic equation?\n    if (coef[0] != 0.0)\n    {           \n        // Find first root.\n        float x = findQuarticRootRegulaFalsi(-10., 1., coef[1], coef[2], coef[3], coef[4]);\n              x = findQuarticRootNewtonRaphson(x, coef[1], coef[2], coef[3], coef[4]);\n\n        // No real roots?\n        if ( abs((((x + coef[1]) * x + coef[2]) * x + coef[3]) * x + coef[4]) > 1e-4 ) \n        { \n            x = findQuarticRootRegulaFalsi(-1., 10., coef[1], coef[2], coef[3], coef[4]);\n            x = findQuarticRootNewtonRaphson(x, coef[1], coef[2], coef[3], coef[4]);\n                  \n            // Still no real roots?\n            if ( abs((((x + coef[1]) * x + coef[2]) * x + coef[3]) * x + coef[4]) > 1e-4 ) { return 0; }\n        }\n\n        // Convert equation to form: (x-r0)(axxx+bxx+cx+d)=0\n        vec2 roots_[3];\n        float coef_[4] = float[4](\n            coef[0],\n            coef[1] + x * coef[0],\n            coef[2] + x * (coef[1] + x * coef[0]),\n            coef[3] + x * (coef[2] + x * (coef[1] + x * coef[0]))\n        );\n\n        int num = solveCubicForReal(roots_, coef_);\n\n        roots[0].x = x; roots[1] = roots_[0]; roots[2] = roots_[1]; roots[3] = roots_[2];\n\n        return num + 1;\n    }\n    \n    // Cubic equation?\n    if (coef[1] != 0.0)\n    {\n        vec2 roots_[3];\n        float coef_[4] = float[4](\n            coef[1], coef[2], coef[3], coef[4]\n        );\n\n        int num = solveCubicForReal(roots_, coef_);\n\n        roots[0] = roots_[0]; roots[1] = roots_[1]; roots[2] = roots_[2];\n        \n        return num;\n    }\n    \n    // Quadratic equation?\n    if (coef[2] != 0.0)\n    {\n        vec2 roots_[2];\n        float coef_[3] = float[3](\n            coef[2], coef[3], coef[4]\n        );\n\n        int num = solveQuadraticForReal(roots_, coef_);\n\n        roots[0] = roots_[0]; roots[1] = roots_[1];\n        \n        return num;\n    }\n\n    // Linear equation?\n    if (coef[3] != 0.0)\n    {\n        // Solve linear equation.\n        roots[0].x = -coef[4]/coef[3]; roots[0].y = 0.0;\n\n        return 1;\n    }\n\n    return 0;\n}","name":"Common","description":"","type":"common"}]}