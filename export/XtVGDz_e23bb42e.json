{"ver":"0.1","info":{"id":"XtVGDz","date":"1474209353","viewed":397,"name":"Super Radial Spectrogram","username":"ttoinou","description":"Upgraded from https://www.shadertoy.com/view/XtKGzm","likes":10,"published":1,"flags":112,"usePreview":0,"tags":["fft","spectrum","music","radial","audio","memory","temporal"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define dx iMouse.x/iResolution.x\n#define dy iMouse.y/iResolution.y\n\n#define PI (3.14159265359)\n#define TWOPI (3.14159265359*2.0)\n#define temporalSpeed 6.0\n\n#define sound iChannel0\n#define to01(x) clamp(x,0.0,1.0)\n\nfloat min_channel(vec3 v)\n{\n\tfloat t = (v.x<v.y) ? v.x : v.y;\n\tt = (t<v.z) ? t : v.z;\n\treturn t;\n}\n\nfloat max_channel(vec3 v)\n{\n\tfloat t = (v.x>v.y) ? v.x : v.y;\n\tt = (t>v.z) ? t : v.z;\n\treturn t;\n}\n\nvec3 rgb_to_hsv(vec3 RGB)\n{\n\tvec3 HSV = vec3(0,0,0);\n\tfloat minVal = min_channel(RGB);\n\tfloat maxVal = max_channel(RGB);\n\tfloat delta = maxVal - minVal; //Delta RGB value \n\tHSV.z = maxVal;\n\t// If gray, leave H & S at zero\n\tif (delta != 0.0) { \n\t\tHSV.y = delta / maxVal;\n\t\tvec3 delRGB;\n\t\tdelRGB = ( ( vec3(maxVal) - RGB ) / 6.0 + ( delta / 2.0 ) ) / delta;\n\t\tif      ( RGB.x == maxVal ) HSV.x = delRGB.z - delRGB.y;\n\t\telse if ( RGB.y == maxVal ) HSV.x = 1.0/3.0 + delRGB.x - delRGB.z;\n\t\telse if ( RGB.z == maxVal ) HSV.x = 2.0/3.0 + delRGB.y - delRGB.x;\n\t\tif ( HSV.x < 0.0 ) { HSV.x += 1.0; }\n\t\tif ( HSV.x > 1.0 ) { HSV.x -= 1.0; }\n\t}\n\treturn (HSV);\n}\nvec3 hsv_to_rgb(vec3 HSV)\n{\n\tvec3 RGB = HSV.zzz;\n\tif ( HSV.y != 0.0 ) {\n\t\tfloat var_h = HSV.x * 6.0;\n\t\tfloat var_i = floor(var_h); // Or ... var_i = floor( var_h )\n\t\tfloat var_1 = HSV.z * (1.0 - HSV.y);\n\t\tfloat var_2 = HSV.z * (1.0 - HSV.y * (var_h-var_i));\n\t\tfloat var_3 = HSV.z * (1.0 - HSV.y * (1.0-(var_h-var_i)));\n\t\tif      (var_i == 0.0) { RGB = vec3(HSV.z, var_3, var_1); }\n\t\telse if (var_i == 1.0) { RGB = vec3(var_2, HSV.z, var_1); }\n\t\telse if (var_i == 2.0) { RGB = vec3(var_1, HSV.z, var_3); }\n\t\telse if (var_i == 3.0) { RGB = vec3(var_1, var_2, HSV.z); }\n\t\telse if (var_i == 4.0) { RGB = vec3(var_3, var_1, HSV.z); }\n\t\telse                 { RGB = vec3(HSV.z, var_1, var_2); }\n\t}\n\treturn (RGB);\n}\n\n\n#define fftMin 0.1\n#define fftH 2.0\n\nfloat fftmul(float i){\n    return i*fftH*(i*fftH+0.8)*1.5 + 0.1;\n}\n\nfloat lum(float k){\n    return k;\n    return sqrt(k);\n}\n\nfloat spectr(float k){\n    return 2.0*abs(k*k*k);\n    return k;\n    return 1.2*k*k;\n}\n\nvec4 fft(float freq,float time){\n    return texture(sound,vec2(freq,time));\n}\n\n#define sqr(x) (x*x)\n\nfloat repeat(float x,float y){\n    x = mod(x,2.0*y);\n    if( x > y ){\n        x = 2.0*y - x;\n    }\n    //return x;\n    return mod(x+y,y);\n}\n\nvec4 bar(vec2 uv){\n    float mul = fftmul( uv.y );\n    vec4 fft1 = fft(uv.x,0.0);\n    \n\treturn vec4(\n        mul*float(fft1.r - fftMin > fftH*uv.y),\n        mul*float(fft1.g - fftMin > fftH*uv.y) ,\n        mul*float(fft1.b - fftMin > fftH*uv.y) ,\n        1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    float minCoord = min(iResolution.x,iResolution.y);\n    float maxCoord = max(iResolution.x,iResolution.y);\n\tfloat freq = uv.x;\n    \n        \n\tfragColor = bar(uv);\n\tfragColor += bar(vec2(1.0) - uv);\n    \n    // see spectrogram\n    vec2 v = (fragCoord - iResolution.xy / 2.0) / maxCoord * 1.0;\n    freq = repeat(atan(v.y,v.x)/PI*2.0,1.0);\n    //float time = 0.0;\n    float time = sqr(v.x)+sqr(v.y);//+freq*dx;\n    //float time = uv.y/temporalSpeed;\n    \n    vec4 fft2 = fft(freq,time);\n    fft2.rgb = rgb_to_hsv(fft2.rgb);\n    \n    time /= 8.0;\n    fft2.r = mod(fft2.r + abs( fft(freq,0.0).g - 0.3 )*0.2,1.0);\n    fft2.g *= pow( abs( 6.0*( fft(0.1,time).b - 0.4 ) / 0.6 ) , 1.5);\n    fft2.rgb = hsv_to_rgb(fft2.rgb);\n    \n    fragColor.r = lum(fragColor.r+spectr(fft2.r));\n    fragColor.g = lum(fragColor.g+spectr(fft2.g));\n    fragColor.b = lum(fragColor.b+spectr(fft2.b));\n    \n    \n    //fragColor = texture(iChannel0,uv);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XtsSD4","filepath":"https://soundcloud.com/bigmamashouse/rave-sickness-acid-caterpilar-stig","previewfilepath":"https://soundcloud.com/bigmamashouse/rave-sickness-acid-caterpilar-stig","type":"musicstream","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define dx iMouse.x/iResolution.x\n#define dy iMouse.y/iResolution.y\n\n#define buffer iChannel0\n#define sound  iChannel1\n#define soundRes iChannelResolution[1]\n#define step 1.0/iResolution.y\n\n// fft Options\n#define inputSound iChannel0\n#define fftWidth \t\t1.0\t\t\t// width of fft texture (why not 512.0 ?! )\n\n#define fftSmooth \t\t1.3\t\t\t// smoothness coeff\n#define fftPreamp\t\t0.65\t\t// pre amp before dynamic\n#define fftBoost  \t\t0.14\t\t// dynamic amp\n#define fftAmp\t\t\t0.7\t\t\t// pre amp before dynamic\n#define fftMinBass \t\t0.00196 \t// 1.0/512.0\n#define noiseLevel      0.05\n\n#define fftRadiusR\t\t8.0/512.0\n#define fftRadiusG\t\t8.0/512.0*4.0\n#define fftRadiusB\t\t8.0/512.0*4.0*4.0\n#define fftSamplesR \t8 // number of iteration for fft sampling, increases quality !\n#define fftSamplesG \t8*4\n#define fftSamplesB \t8*4*4\n#define fftGBGain       1.1\n\n#define to01(x) clamp(x,0.0,1.0)\n\nfloat remapIntensity(float f, float i){\n  // noise level\n  i = to01( (i - noiseLevel) / (1.0 - noiseLevel) );\n  float k = f-1.0;\n  // preamp, x2 for trebles -> x1 for bass\n  //i *= ( 2.0 - 1.0*k*k ) * fftPreamp;\n  //i *= ( 3.0 - 1.5*k*k ) * fftPreamp;\n  i *= ( 3.0 - 1.6*k*k ) * fftPreamp;\n  // more dynamic\n  i *= (i+fftBoost);\n  // limiter\n  return i*fftAmp;\n  // limiter, kills dynamic when too loud\n  //return 1.0 - 1.0 / ( i*4.0 + 1.0 );\n}\n\nfloat remapFreq(float freq){\n // linear scale\n //return clamp(freq,fftMinBass,1.0);\n // log scale\n return clamp(to01(- log(1.0-freq/2.0 + fftMinBass*8.0)),fftMinBass,1.0);\n}\n\nfloat fftR(float f){\n    float sum = 0.0;\n    float val = 0.0;\n    float coeff = 0.0;\n    float k = 0.0;\n    for( int i = 0; i < fftSamplesR ; i++ ){\n        k = float(i)/float(fftSamplesR-1)-0.5;\n        coeff = exp(-k*k/(fftSmooth*fftSmooth)*2.0);\n\t\tval += texture(sound, vec2( remapFreq(f + k * fftRadiusR)*fftWidth, 0.0) ).r * coeff;\n        sum += coeff;\n    }\n    return remapIntensity(f,val/sum);\n}\n\nfloat fftG(float f){\n    float sum = 0.0;\n    float val = 0.0;\n    float coeff = 0.0;\n    float k = 0.0;\n    for( int i = 0; i < fftSamplesG ; i++ ){\n        k = float(i)/float(fftSamplesG-1)-0.5;\n        coeff = exp(-k*k/(fftSmooth*fftSmooth)*2.0);\n\t\tval += texture(sound, vec2( remapFreq(f + k * fftRadiusG)*fftWidth, 0.0) ).r * coeff;\n        sum += coeff;\n    }\n    return remapIntensity(f,val/sum)*fftGBGain;\n}\n\nfloat fftB(float f){\n    float sum = 0.0;\n    float val = 0.0;\n    float coeff = 0.0;\n    float k = 0.0;\n    for( int i = 0; i < fftSamplesB ; i++ ){\n        k = float(i)/float(fftSamplesB-1)-0.5;\n        coeff = exp(-k*k/(fftSmooth*fftSmooth)*2.0);\n\t\tval += texture(sound, vec2( remapFreq(f + k * fftRadiusB)*fftWidth, 0.0) ).r * coeff;\n        sum += coeff;\n    }\n    return remapIntensity(f,val/sum)*fftGBGain*fftGBGain;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\n   \t// black by default\n    fragColor = vec4(0.0,0.0,0.0,1.0);\n    \n    float k = texture( iChannel2, vec2(82.5/256.0,0.0) ).x;\n\n     // key R => Reset\n    if( abs(k) < 0.1 ){\n        // store current fft\n        if( fragCoord.y <= 1.0 ){\n            \n            float freq = uv.x;\n            float i1,i2,i3;\n\n            i1 = fftR(freq);\n            i2 = fftG(freq);\n            i3 = fftB(freq);\n\n            fragColor = vec4(i1,i2,i3,1.0);\n            \n        // store previous fft\n        } else if( fragCoord.y < iResolution.y - 1.0 ) {\n            fragColor=texture(buffer,vec2(uv.x,uv.y - step));\n        }\n    }\n}","name":"Buffer A","description":"","type":"buffer"}]}