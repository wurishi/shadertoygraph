{"ver":"0.1","info":{"id":"wlyGRW","date":"1578421880","viewed":118,"name":"Deffered Ray-Traced Rendering","username":"statsuuu","description":"Shader that uses ray tracing techniques to create display buffers used for deferred rendering and post-processing.","likes":1,"published":1,"flags":32,"usePreview":0,"tags":["raytracing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_DISTANCE 100.\n\n// 0 for PROCESSED, 1 for DEPTH, 2 for INPUT\nconst int BUFFER_TYPE = 0;\n\nconst float offset = 1.0 / 300.0;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    float depth = (texture(iChannel0, uv).r * MAX_DISTANCE);\n    \n    vec2 offsets[9] = vec2[](\n        vec2(-offset,  offset), // top-left\n        vec2( 0.0f,    offset), // top-center\n        vec2( offset,  offset), // top-right\n        vec2(-offset,  0.0f),   // center-left\n        vec2( 0.0f,    0.0f),   // center-center\n        vec2( offset,  0.0f),   // center-right\n        vec2(-offset, -offset), // bottom-left\n        vec2( 0.0f,   -offset), // bottom-center\n        vec2( offset, -offset)  // bottom-right    \n    );\n\n    float kernel[9] = float[](\n        1.0 / 16., 2.0 / 16., 1.0 / 16.,\n        2.0 / 16., 4.0 / 16., 2.0 / 16.,\n        1.0 / 16., 2.0 / 16., 1.0 / 16.  \n\t);\n    \n    vec3 sampleTex[9];\n    for(int i = 0; i < 9; i++)\n    {\n        sampleTex[i] = vec3(texture(iChannel1, uv + offsets[i] * ((depth * depth) / 8000.)));\n\n    }\n    vec3 col = vec3(0.0);\n    for(int i = 0; i < 9; i++)\n        col += sampleTex[i] * kernel[i];\n    \n    fragColor = vec4(col, 1.0);\n    if (BUFFER_TYPE == 1) fragColor = vec4(texture(iChannel0, uv));\n    if (BUFFER_TYPE == 2) fragColor = vec4(texture(iChannel1, uv));\n\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// THIS IS THE BUFFER FOR COLOUR OUTPUT\n\n#define NUM_SPHERES 2\n#define NUM_LIGHTS 1\n#define MAX_DISTANCE 100.\n#define LINEAR_ATTENUATION 0.7\n#define MAX_STEPS 50\n\nconst int DEPTH_BUFFER = 1;\nconst int NORMAL_BUFFER = 0;\nconst int COLOUR_BUFFER = 0;\n\nconst float num_iterations = 1.;\nconst float offset = 0.001;\nconst float blend = 1.;\n\nstruct sphere\n{\n\tvec3 pos;\n    float r;\n};\n    \nstruct raycast\n{\n  \tvec3 ro;\n    vec3 rd;\n};\n    \nstruct raycast_hit\n{\n    bool is_hit;\n    float t;\n    vec3 pos;\n    vec3 normal;\n};\n    \nstruct light\n{\n\tsphere s;\n    vec3 colour;\n};\n\nstruct plane\n{\n\tvec3 pos;\n    vec3 normal;\n};\n    \n// ground plane\nplane ground;\n\n// object spheres\nsphere spheres[NUM_SPHERES];\nlight lights[NUM_LIGHTS];\n\n// set up the scene with objects\nvoid set_scene()\n{\n    spheres[0].pos = vec3(-1. + sin(iTime), 0., -9.);\n    spheres[0].r = 1.;\n    \n    spheres[1].pos = vec3(3, 0, -5. - sin(iTime / 2.) * 7.);\n    spheres[1].r = 1.2;\n    \n    lights[0].s.pos = vec3(-3, 0., -13);\n    lights[0].s.r = 2.;\n    lights[0].colour = vec3(0.6, .6, 1.0);\n    \n    ground.pos = vec3(0, -2., 0);\n    ground.normal = normalize(vec3(0, 1, 0));\n}\n\n// intersect a sphere with a ray\nraycast_hit intersect_sphere(raycast r, sphere s)\n{\n    raycast_hit hit;\n    hit.is_hit = false;\n    hit.t = MAX_DISTANCE;\n    hit.pos = vec3(0.);\n    hit.normal = vec3(0.);\n    \n\tvec3 target_dir = r.ro - s.pos;\n    // quadratic solution\n    float A = 1.;\n    float B = dot(target_dir, r.rd) * 2.;\n    float C = dot(target_dir, target_dir) - pow(s.r, 2.);\n    float rooted = pow(B, 2.) - 4. * A * C;\n    \n    // only if non-imaginary solutions exist\n    if (rooted >= 0.)\n    {\n        hit.is_hit = true;\n   \t\thit.t = (-B - sqrt(rooted)) / (2. * A);\n        hit.pos = r.ro + r.rd * hit.t;\n        hit.normal = normalize(hit.pos - s.pos);\n        if (hit.t > MAX_DISTANCE)\n        {\n            hit.is_hit = false;\n            hit.t = MAX_DISTANCE;\n        }\n    }\n    \n    return hit;\n}\n\n// intersect ray with plane\nraycast_hit intersect_plane(raycast r, plane p)\n{\n    raycast_hit hit;\n    hit.is_hit = false;\n    hit.t = MAX_DISTANCE;\n    hit.pos = vec3(MAX_DISTANCE);\n    hit.normal = vec3(0.); \n    \n    float div = dot(r.rd, p.normal);\n    if (div < 0.)\n    {\n        hit.is_hit = true;\n        hit.normal = p.normal;\n        hit.t = dot(p.pos - r.ro, p.normal) / div;\n        hit.pos = r.ro + r.rd * hit.t;\n        if (hit.t > MAX_DISTANCE)\n        {\n            hit.is_hit = false;\n            hit.t = MAX_DISTANCE;\n        }\n    }\n    \n    return hit;\n}\n\n// intersect all objects in the scene\nraycast_hit intersect(raycast ray)\n{\n\traycast_hit hit;\n    hit.t = MAX_DISTANCE;\n    for (int i = 0; i < NUM_SPHERES; i++)\n    {\n        raycast_hit hit2 = intersect_sphere(ray, spheres[i]);\n        if (hit2.is_hit == true && hit2.t < hit.t)\n        {\n            hit.t = hit2.t;\n            hit.normal = hit2.normal;\n            hit.pos = hit2.pos;\n            hit.is_hit = true;\n        }\n    }\n    \n    raycast_hit hit2 = intersect_plane(ray, ground);\n    if (hit2.is_hit == true && hit2.t < hit.t)\n    {\n        hit.t = hit2.t;\n        hit.normal = hit2.normal;\n        hit.pos = hit2.pos;\n        hit.is_hit = true;\n    }\n    return hit;\n}\n\n\n// taken from https://raytracing.github.io/books/RayTracingInOneWeekend.html\nvec3 color(raycast r)\n{\n    if (DEPTH_BUFFER == 1) return vec3(1.);\n    if (COLOUR_BUFFER == 1) return vec3(0.);\n    if (NORMAL_BUFFER == 1)\n    {\n        return vec3(0.);\n        float t = 0.;\n        vec3 unit_direction = normalize(r.rd);\n        t = 0.5*(unit_direction.y + 1.0);\n        return (1.0-t)*vec3(1.0, 1.0, 1.0) + t*vec3(0.5, 0.7, 1.0);\n    }\n    return vec3(0.);\n}\n\n\nfloat RayMarch(raycast ray)\n{\n\tfloat d = distance(ray.ro, lights[0].s.pos);\n    float t = 0.5;\n    for (int i = 0; i < MAX_STEPS; i++)\n    {\n        vec3 r = ray.ro + ray.rd * t;\n        float d2 = distance(lights[0].s.pos, r);\n        if (d2 > d) break;\n        d = d2;\n        t+=0.5;\n    }\n    return d;\n}\n\nvec3 calculate_lighting(vec3 direction, raycast_hit hit)\n{\n    vec3 colour = vec3(hit.normal);\n    raycast ray;\n    ray.rd = reflect(direction, hit.normal);\n    ray.ro = hit.pos + ray.rd * 0.002;\n    \n    raycast_hit light_hit = intersect_sphere(ray, lights[0].s);\n    \n    if (light_hit.t > 0.)\n    {\n        colour = lights[0].colour * (1. / light_hit.t);\n    }\n    \n    vec3 dir = normalize(lights[0].s.pos - hit.pos);\n    float dotted = clamp(dot(hit.normal, dir), 0.0, 1.0);\n    float d = hit.t / distance(hit.pos, lights[0].s.pos);\n    \n    colour = (lights[0].colour * dotted + 0.01) / (d * LINEAR_ATTENUATION);\n    \n    float ld = RayMarch(ray);\n    \n    colour = mix(colour, lights[0].colour * (1. / ld), 0.3);\n    \n    \n    float dist_from_light = distance(lights[0].s.pos, hit.pos);\n    \n    raycast newRay;\n    newRay.rd = normalize(lights[0].s.pos - hit.pos);\n    newRay.ro = hit.pos + newRay.rd * 0.002;\n    raycast_hit newHit = intersect(newRay);\n    \n    if (newHit.t > 0. && dist_from_light > newHit.t)\n    {\n    \tcolour *= 0.1f;   \n    }\n    \n    if (NORMAL_BUFFER == 1) { colour = hit.normal; }\n    if (DEPTH_BUFFER == 1) { colour = vec3(hit.t / MAX_DISTANCE); }\n    if (COLOUR_BUFFER == 1)\n    {\n    \tif (dotted > 0.)\n        {\n        \tcolour = lights[0].colour;   \n        }\n    }\n\n    return colour;\n}\n\nvec3 update_colour(vec3 col, raycast ray)\n{\n    raycast_hit hit = intersect(ray);\n    float t = hit.t;\n    if (hit.is_hit && hit.t < MAX_DISTANCE)\n    {\n        col = mix(col, calculate_lighting(ray.rd, hit), blend);\n    }\n    return col;\n    \n    while(hit.t != 0. && t < MAX_DISTANCE)\n    {\n        t += hit.t;\n        ray.ro = hit.pos;\n        ray.rd = normalize(reflect(ray.rd, hit.normal));\n        raycast_hit newHit = intersect(ray);\n        if (newHit.t > 0.)\n        {\n            hit = newHit;   \n        }\n        else\n            break;\n    }\n\n    if (t > 0.)\n    {\n        col = mix(col, calculate_lighting(ray.rd, hit), blend);\n    }\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 ratio = vec2(16., 9.);\n    vec2 coord = vec2((uv.xy - 0.5) * 2.) * ratio;\n    \n    set_scene();\n    \n    raycast ray;\n    ray.ro = vec3(0, 0, -15);\n    ray.rd = normalize(vec3(coord, 0) - ray.ro);\n    \n    vec3 col = vec3(color(ray));\n    \n    float offset_amount = offset / num_iterations;\n\n    ray.rd = normalize(vec3(coord.x - offset, coord.y, 0) - ray.ro);\n    for (float i = 0.; i < num_iterations; i+=1.)\n    {\n    \tcol = update_colour(col, ray);\n        ray.rd = normalize(vec3(coord.x - offset + i * offset_amount, coord.y, 0) - ray.ro);\n    }\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// THIS IS THE BUFFER FOR COLOUR OUTPUT\n\n#define NUM_SPHERES 2\n#define NUM_LIGHTS 1\n#define MAX_DISTANCE 100.\n#define LINEAR_ATTENUATION 0.7\n#define MAX_STEPS 50\n\nconst int DEPTH_BUFFER = 0;\nconst int NORMAL_BUFFER = 0;\nconst int COLOUR_BUFFER = 0;\n\nconst float num_iterations = 1.;\nconst float offset = 0.001;\nconst float blend = 1.;\n\nstruct sphere\n{\n\tvec3 pos;\n    float r;\n};\n    \nstruct raycast\n{\n  \tvec3 ro;\n    vec3 rd;\n};\n    \nstruct raycast_hit\n{\n    bool is_hit;\n    float t;\n    vec3 pos;\n    vec3 normal;\n};\n    \nstruct light\n{\n\tsphere s;\n    vec3 colour;\n};\n\nstruct plane\n{\n\tvec3 pos;\n    vec3 normal;\n};\nstruct triangle\n{\n    vec3 v0, v1, v2;\n};\n\n// ground plane\nplane ground;\n\n// object spheres\nsphere spheres[NUM_SPHERES];\nlight lights[NUM_LIGHTS];\n\n// set up the scene with objects\nvoid set_scene()\n{\n    spheres[0].pos = vec3(-1. + sin(iTime), 0., -9.);\n    spheres[0].r = 1.;\n    \n    spheres[1].pos = vec3(3, 0, -5. - sin(iTime / 2.) * 7.);\n    spheres[1].r = 1.2;\n    \n    lights[0].s.pos = vec3(-3, 0., -13);\n    lights[0].s.r = 2.;\n    lights[0].colour = vec3(0.6, .6, 1.0);\n    \n    ground.pos = vec3(0, -2., 0);\n    ground.normal = normalize(vec3(0, 1, 0));\n\n}\n\n// intersect a sphere with a ray\nraycast_hit intersect_sphere(raycast r, sphere s)\n{\n    raycast_hit hit;\n    hit.is_hit = false;\n    hit.t = MAX_DISTANCE;\n    hit.pos = vec3(0.);\n    hit.normal = vec3(0.);\n    \n\tvec3 target_dir = r.ro - s.pos;\n    // quadratic solution\n    float A = 1.;\n    float B = dot(target_dir, r.rd) * 2.;\n    float C = dot(target_dir, target_dir) - pow(s.r, 2.);\n    float rooted = pow(B, 2.) - 4. * A * C;\n    \n    // only if non-imaginary solutions exist\n    if (rooted >= 0.)\n    {\n        hit.is_hit = true;\n   \t\thit.t = (-B - sqrt(rooted)) / (2. * A);\n        hit.pos = r.ro + r.rd * hit.t;\n        hit.normal = normalize(hit.pos - s.pos);\n        if (hit.t > MAX_DISTANCE)\n        {\n            hit.is_hit = false;\n            hit.t = MAX_DISTANCE;\n        }\n    }\n    \n    return hit;\n}\n\n// intersect ray with plane\nraycast_hit intersect_plane(raycast r, plane p)\n{\n    raycast_hit hit;\n    hit.is_hit = false;\n    hit.t = MAX_DISTANCE;\n    hit.pos = vec3(MAX_DISTANCE);\n    hit.normal = vec3(0.); \n    \n    float div = dot(r.rd, p.normal);\n    if (div < 0.)\n    {\n        hit.is_hit = true;\n        hit.normal = p.normal;\n        hit.t = dot(p.pos - r.ro, p.normal) / div;\n        hit.pos = r.ro + r.rd * hit.t;\n        if (hit.t > MAX_DISTANCE)\n        {\n            hit.is_hit = false;\n            hit.t = MAX_DISTANCE;\n        }\n    }\n    \n    return hit;\n}\n\n// intersect all objects in the scene\nraycast_hit intersect(raycast ray)\n{\n\traycast_hit hit;\n    hit.t = MAX_DISTANCE;\n    for (int i = 0; i < NUM_SPHERES; i++)\n    {\n        raycast_hit hit2 = intersect_sphere(ray, spheres[i]);\n        if (hit2.is_hit == true && hit2.t < hit.t)\n        {\n            hit.t = hit2.t;\n            hit.normal = hit2.normal;\n            hit.pos = hit2.pos;\n            hit.is_hit = true;\n        }\n    }\n    \n    raycast_hit hit2 = intersect_plane(ray, ground);\n    if (hit2.is_hit == true && hit2.t < hit.t)\n    {\n        hit.t = hit2.t;\n        hit.normal = hit2.normal;\n        hit.pos = hit2.pos;\n        hit.is_hit = true;\n    }\n    return hit;\n}\n\n\n// taken from https://raytracing.github.io/books/RayTracingInOneWeekend.html\nvec3 color(raycast r)\n{\n    if (DEPTH_BUFFER == 1) return vec3(1.);\n    if (COLOUR_BUFFER == 1) return vec3(0.);\n    if (NORMAL_BUFFER == 1)\n    {\n        return vec3(0.);\n        float t = 0.;\n        vec3 unit_direction = normalize(r.rd);\n        t = 0.5*(unit_direction.y + 1.0);\n        return (1.0-t)*vec3(1.0, 1.0, 1.0) + t*vec3(0.5, 0.7, 1.0);\n    }\n    return vec3(0.);\n}\n\n\nfloat RayMarch(raycast ray)\n{\n\tfloat d = distance(ray.ro, lights[0].s.pos);\n    float t = 0.5;\n    for (int i = 0; i < MAX_STEPS; i++)\n    {\n        vec3 r = ray.ro + ray.rd * t;\n        float d2 = distance(lights[0].s.pos, r);\n        if (d2 > d) break;\n        d = d2;\n        t+=0.5;\n    }\n    return d;\n}\n\nvec3 calculate_lighting(vec3 direction, raycast_hit hit)\n{\n    vec3 colour = vec3(hit.normal);\n    raycast ray;\n    ray.rd = reflect(direction, hit.normal);\n    ray.ro = hit.pos + ray.rd * 0.002;\n    \n    raycast_hit light_hit = intersect_sphere(ray, lights[0].s);\n    \n    if (light_hit.t > 0.)\n    {\n        colour = lights[0].colour * (1. / light_hit.t);\n    }\n    \n    vec3 dir = normalize(lights[0].s.pos - hit.pos);\n    float dotted = clamp(dot(hit.normal, dir), 0.0, 1.0);\n    float d = hit.t / distance(hit.pos, lights[0].s.pos);\n    \n    colour = (lights[0].colour * dotted + 0.01) / (d * LINEAR_ATTENUATION);\n    \n    float ld = RayMarch(ray);\n    \n    colour = mix(colour, lights[0].colour * (1. / ld), 0.3);\n    \n    \n    float dist_from_light = distance(lights[0].s.pos, hit.pos);\n    \n    raycast newRay;\n    newRay.rd = normalize(lights[0].s.pos - hit.pos);\n    newRay.ro = hit.pos + newRay.rd * 0.002;\n    raycast_hit newHit = intersect(newRay);\n    \n    if (newHit.t > 0. && dist_from_light > newHit.t)\n    {\n    \tcolour *= 0.1f;   \n    }\n    \n    if (NORMAL_BUFFER == 1) { colour = hit.normal; }\n    if (DEPTH_BUFFER == 1) { colour = vec3(hit.t / MAX_DISTANCE); }\n    if (COLOUR_BUFFER == 1)\n    {\n    \tif (dotted > 0.)\n        {\n        \tcolour = lights[0].colour;   \n        }\n    }\n\n    return colour;\n}\n\nvec3 update_colour(vec3 col, raycast ray)\n{\n    raycast_hit hit = intersect(ray);\n    float t = hit.t;\n    if (hit.is_hit && hit.t < MAX_DISTANCE)\n    {\n        col = mix(col, calculate_lighting(ray.rd, hit), blend);\n    }\n    return col;\n    \n    while(hit.t != 0. && t < MAX_DISTANCE)\n    {\n        t += hit.t;\n        ray.ro = hit.pos;\n        ray.rd = normalize(reflect(ray.rd, hit.normal));\n        raycast_hit newHit = intersect(ray);\n        if (newHit.t > 0.)\n        {\n            hit = newHit;   \n        }\n        else\n            break;\n    }\n\n    if (t > 0.)\n    {\n        col = mix(col, calculate_lighting(ray.rd, hit), blend);\n    }\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 ratio = vec2(16., 9.);\n    vec2 coord = vec2((uv.xy - 0.5) * 2.) * ratio;\n    \n    set_scene();\n    \n    raycast ray;\n    ray.ro = vec3(0, 0, -15);\n    ray.rd = normalize(vec3(coord, 0) - ray.ro);\n    \n    vec3 col = vec3(color(ray));\n    \n    float offset_amount = offset / num_iterations;\n\n    ray.rd = normalize(vec3(coord.x - offset, coord.y, 0) - ray.ro);\n    for (float i = 0.; i < num_iterations; i+=1.)\n    {\n    \tcol = update_colour(col, ray);\n        ray.rd = normalize(vec3(coord.x - offset + i * offset_amount, coord.y, 0) - ray.ro);\n    }\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Buffer B","description":"","type":"buffer"}]}