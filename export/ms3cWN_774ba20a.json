{"ver":"0.1","info":{"id":"ms3cWN","date":"1695087675","viewed":76,"name":"Shape growth","username":"stb","description":"Not sure what the method is called, but each pixel holds positional + other data. A pixel evaluates its neighbors and overwrites itself based on relative function values.\n\nMouse to move light, and 'r' to reset. Vars in common tab to change some things.","likes":12,"published":1,"flags":48,"usePreview":0,"tags":["2d","shading","distance","bump","field","shapes","rotation","position","crystal","attribute","stored"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n    Shape growth\n    \n    September 2023 stb\n    \n    Each pixel holds data for its position, rotation and a generic 'offset' value. These\n    are used to reconstruct a shape function (which is like a signed distance function but\n    less strict). Each pixel evalutes its neighbors to determine if it should be unchanged,\n    or be overwritten by a neighbor. Data is changed over time to cause random growth.\n    \n    Changes:\n        * fixed issue with shapes not being evaluated properly when off-center or assymetrical\n        * added light motion when mouse hasn't been clicked\n        * added SeedDensity definition to common tab\n        * various slight adjustments\n        * adjusted shading and added a proximity pattern to deepen the crevices\n    \n    Changes 2:\n        * changed to a better shading scheme\n*/\n\nfloat map (vec2 uv, vec2 p) {\n    vec2 pos = texture(iChannel0, uv).rg;\n    float rot = texture(iChannel0, uv).b;\n    float off = texture(iChannel0, uv).a;\n    \n    return .25 * (1.-shape(p-pos, rot, off, res.y));\n}\n\nfloat de(vec2 uv, vec3 p) {\n    return (p.z - map(uv, p.xy)) / res.y / .004;\n}\n\nvec3 getNorm(vec2 uv, vec3 p) {\n    vec3 o = 4. * vec3(-1., 0., 1.) / res.y;\n    return\n        normalize(\n            vec3(\n                de(uv, p-o.xyy) - de(uv, p-o.zyy),\n                de(uv, p-o.yxy) - de(uv, p-o.yzy),\n                //de(uv, p-o.yyz) - de(uv, p-o.yyx)\n                2.*o.x\n            )\n        );\n}\n\n/*vec3 getNorm(vec2 uv, vec2 p) {\n    vec3 o = 1.5 * vec3(-1., 0., 1.) / res.y;\n    return\n        normalize(\n            vec3(\n                map(uv, p-o.xy) - map(uv, p-o.zy),\n                map(uv, p-o.yx) - map(uv, p-o.yz),\n                -1./res.y\n            )\n        );\n}*/\n\n// proximity pattern\nfloat getProx(vec2 uv, vec2 p, float amt) {\n    vec3 o = amt * vec3(-1., 0., 1.) / res.y * 300.;\n    return\n        (\n            (\n                map(uv, p) +\n                map(uv, p-o.xy) +\n                map(uv, p-o.zy) +\n                map(uv, p-o.yx) +\n                map(uv, p-o.yz)\n            ) / 5.\n            -map(uv, p)\n        ) * .3 / amt + 1.;\n}\n\nvoid mainImage(out vec4 fo, in vec2 fc) {\n    vec2 uv = fc.xy / res;\n    vec2 p = (fc.xy-res/2.) / res.y;\n    \n    vec3 rpos = vec3(p, -10.);\n    vec3 rdir = vec3(0., 0., 1.);\n    vec3 rhit = vec3(rpos.xy, -map(uv, rpos.xy));\n    \n    // mouse position\n    vec2 m = 1. * (iMouse.xy-res/2.) / res.y;\n    \n    // output rgb value\n    vec3 rgb;\n    \n    // light position\n    vec3 lpos = vec3(m, -1.) - rhit;\n    if(iMouse.w>0.)\n        lpos = .65 * vec3(sin(.7*iTime), cos(.7*iTime), -1.5) - rhit;\n    \n    // light color\n    vec3 lcol = 4.*  vec3(3., 2.7, 2.3);\n    \n    // light distance\n    float ldist = pow(length(lpos), 2.);\n    \n    // normal\n    vec3 norm = getNorm(uv, rhit);\n    \n    // diffuse\n    float brilliance = 1.;\n    vec3 diff = .05 * vec3(.9, .8, .7) * pow(max(0., 1.-dot(-normalize(lpos), norm)), brilliance) / ldist;\n    \n    // reflection vector\n    vec3 refl = normalize(reflect(-normalize(lpos), norm));\n    \n    // specular hightlight\n    float spec = .1 * pow(clamp(.6*(1.-dot(refl, rdir)), 0., 1.), 128.) / ldist;\n    \n    // initial color\n    rgb = vec3(1., .8, .7);\n    \n    // mix in proximity\n    //rgb += .5*(vec3(getProx(uv, p, .01)) - .75);\n    \n    // apply diffuse\n    rgb *= diff * lcol;\n    \n    // colorize based of offset\n    rgb *= mix(vec3(1.), texture(iChannel1, vec2(texture(iChannel0, uv).b/10., 0.)).rgb, .5);\n    \n    // multiply by distance\n    //rgb *= 4.*(map(uv, p)-.2);\n    \n    // add specular\n    float aoi = 1.1 - dot(vec3(0,0,-1), norm);\n    rgb += lcol * spec * aoi;\n    \n    \n    //rgb = vec3(map(uv, p));\n    \n    // output\n    fo = vec4(rgb, 1.);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// hash without sine: https://www.shadertoy.com/view/4djSRW\n#define MOD3 vec3(443.8975, 397.2973, 491.1871) // uv range\nfloat hash12(vec2 p) {\n\tvec3 p3  = fract(vec3(p.xyx) * MOD3);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\nvec2 hash22(vec2 p) {\n\tvec3 p3 = fract(vec3(p.xyx) * MOD3);\n    p3 += dot(p3, p3.yzx+19.19);\n    return fract(vec2((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y));\n}\n\n// a time-based, pseudo-random float\nfloat trand(vec2 p){ return hash12(mod(p+iDate.w/10., 100.));}\n\n// texture definition\n#define tx(o) texture( iChannel0, uv+o/res )\n\nvoid mainImage( out vec4 fo, in vec2 fc ) {\n\tvec2 uv = fc / res;\n    vec2 p = (fc.xy-res/2.) / res.y;\n    vec3 o = vec3(-1., 0., 1.);\n    \n    // sample directions\n    // s[7] s[4] s[8]\n\t// s[1] s[0] s[2]\n\t// s[5] s[3] s[6]\n    \n    vec4 s[9];\n    \n    s[0] = tx(o.yy);\n    \n    s[1] = tx(o.xy);\n    s[2] = tx(o.zy);\n    s[3] = tx(o.yx);\n    s[4] = tx(o.yz);\n    \n    s[5] = tx(o.xx);\n    s[6] = tx(o.xz);\n    s[7] = tx(o.zx);\n    s[8] = tx(o.zz);\n    \n    // position vector\n    vec2 pos;\n    \n    // rotation, size\n    float rot, off;\n    \n    // first frame or when 'r' is pressed\n    if(iFrame==0 || texture(iChannel1, vec2(82.5/256., .2)).r>0.) {\n        // save pixel position\n        if(trand(p)<SeedDensity && trand(-p)<.1)\n            pos = p;\n            \n        // otherwise, set pixel to a high distance\n        else\n            pos = vec2(8.);\n        \n        // default rotation\n        rot = 6.28 * trand(p+8.341);\n        \n        // default offset\n        off = trand(p+1.492);\n    }\n    \n    // all other frames\n    else{\n    \n        // this cell's position\n        pos = s[0].rg;\n        rot = s[0].b;\n        off = s[0].a;\n        \n        // save position\n        vec2 opos = pos;\n        \n        // loop through neighbors\n        float lpos;\n        for(int i=1; i<9; i++) {\n        \n            // attempt to round things out by randomly bailing out on corner samples\n            if(i>4 && trand(p+2.34) < .9)\n                break;\n            \n            // sample neighboring position\n            vec2 ipos = s[i].rg;\n            float irot = s[i].b;\n            float ioff = s[i].a;\n\n            // compare distance-to-pos with distance-to-ipos\n            // ...and rewrite pos when the latter is less than the former\n            if(shape(p-ipos, irot, ioff, res.y) < shape(p-pos, rot, off, res.y)) {\n                pos = ipos;\n                rot = irot;\n                off = ioff;\n            }\n        }\n        \n        // if original position's length is more than 9.\n        if(length(opos) > 10.) {\n        \n            // randomize position\n            pos += PosV * (.5-hash22(mod(uv+iDate.w/10., 100.))) / res.y;\n            \n            // randomize rotation\n            if(trand(7.213-p)<.05)\n                rot += RotV * (.5-trand(mod(p+iDate.w/10.-2.73, 100.)));\n                \n            // randomize offset\n            off = clamp(off-OffV*trand(mod(p-iDate.w/10., 100.)), 0., 1.);\n        }\n        \n    }\n    \n    // output\n\tfo = vec4(pos, rot, off);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define SeedDensity .0003 // number of initial seeds\n#define PosV 1.10 // random position multiplier\n#define RotV 0.010 // random rotation multiplier\n#define OffV 0.001 // random offset multiplier\n\n#define res iResolution.xy\n#define scale (res.y/400.)\n\nfloat s, c;\n#define rotate(p, a) mat2(c=cos(a), s=-sin(a), -s, c) * p\n\n// this can be anything resembling an sdf\nfloat shape (in vec2 p, float rot, float off, float resy) {\n    p *= resy;\n    p /= 20.;\n    p = rotate(p, rot);\n    float f;\n    \n    f = max(abs(p.x)-off, abs(p.y));\n    f = smoothstep(0.1, 1., f);\n    \n    f -= .25 * off;\n    \n    f = min(.5, f-.8*off);\n    \n    return f;\n}","name":"Common","description":"","type":"common"}]}