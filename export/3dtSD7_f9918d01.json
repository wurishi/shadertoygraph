{"ver":"0.1","info":{"id":"3dtSD7","date":"1572170261","viewed":1192,"name":"turbulent fluid jet","username":"micahbro","description":"Euler equation simulated by vorticity particle advection (crudely approximating a very high Reynolds number). Options for some other variants included. One of my first attempts at computing with a shader. ","likes":32,"published":1,"flags":32,"usePreview":0,"tags":["fluid","particles","turbulence","vorticity"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n    // Screen coordinates.\n\tvec2 uv = (fragCoord.xy - iResolution.xy*.5) / iResolution.y;\n    \n    ivec2 ifc = ivec2(round(fragCoord)); \n    \n    // direct image flow visualization (but w/heavy spurious numerical diffusion)\n    vec3 sceneColor = vec3(texture(iChannel2, fragCoord / iResolution.xy));\n    \n    \n\tfragColor = vec4(clamp(sceneColor, 0., 1.), 1);    \n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Vorticity particles\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n    // Set to false for a simpler simuation of a circular Kelvin-Helmhotz shear instability.\n    bool jet = true;\n    \n    \n    // Screen coordinates.\n\tvec2 uv = (fragCoord.xy - iResolution.xy*.5) / iResolution.y;\n    float aspect = float(iResolution.x) / float(iResolution.y);\n    \n    if (iFrame < 10 && !jet) {\n        vec3 sceneColor;\n        float initpack = 1.0;\n        float stagger = trunc(fragCoord.y / 4.) / iResolution.y;\n        if (false) {\n            // linear shear (classic K-H) \n\t\t\tsceneColor = vec3((uv[0] + stagger) / initpack + 0.05*0., -0, 0.05);\n        } else {\n            // rotational shear\n        \tfloat coord = 2.*3.14159 * (uv[0] + stagger) / initpack / aspect * 1.004;\n        \tfloat circrad = 0.4;\n\t\t\tsceneColor = vec3(sin(coord)*circrad, cos(coord)*circrad, -0.05); \n        }\n\n        \n\t\tfragColor = vec4(sceneColor, 1);\n    } else {\n\t    ivec2 ifc = ivec2(round(fragCoord)); \n\t    vec4 puvc = texelFetch(iChannel0, ifc, 0);\n        \n        vec2 pxy = vec2(puvc) * iResolution.y + iResolution.xy*.5;\n        ivec2 ipxy = ivec2(round(pxy));\n\t    vec2 uvipxy = (vec2(ipxy) - iResolution.xy*.5) / iResolution.y;\n\n\t    vec2 vxvy = vec2(texture(iChannel1, pxy / vec2(iResolution)));\n        \n        float dt = 0.0001 ; // iTimeDelta * 0.01;\n        \n        \n        fragColor = puvc + dt * vec4(vxvy, 0, 0);\n        \n        // Wrap the particles around if they manage to get out (not entirely physical)\n        aspect = 1./1.0 * .99 * aspect;\n        float aspy = .99;\n        if (fragColor[0] > aspect * .5) fragColor[0] -= aspect;\n        if (fragColor[0] <= -aspect * .5) fragColor[0] += aspect;\n        if (fragColor[1] > aspy * .5) fragColor[1] -= aspy;\n        if (fragColor[1] <= -aspy * .5) fragColor[1] += aspy;\n\n        if (abs(fragCoord.x + fragCoord.y / iResolution.y * 20. - iMouse.x) < 1.0 && iMouse[2] > 0.) {\n\t\t\tvec2 muv = (vec2(iMouse) - iResolution.xy*.5) / iResolution.y;\n            fragColor = vec4(muv, fragColor[2], fragColor[3]); \n        \n        }        \n    }\n\n    if (jet) {\n        vec3 sceneColor;\n        float stagger = trunc(fragCoord.y / 4.) / iResolution.y;\n        \n        if (iFrame == int(round((aspect*.5 + uv[0] + stagger) * 100.))) {\n            \n            if (int(round(mod(fragCoord.x / 2., 2.))) == 0) {\n                fragColor = vec4(aspect*.49, -0.1, .2, 1); \n            } else {\n                fragColor = vec4(aspect*.49, 0.1, -.2, 1); \n            }\n        }\n    }\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// Velocity\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n    // No-flux boundary conditions:\n    // (set these to true to keep the flow boxed in -- computationally expensive, tho)\n    bool boxx = true;\n    bool boxy = true;\n\n    \n    // Screen coordinates.\n\tvec2 uv = (fragCoord.xy - iResolution.xy*.5) / iResolution.y;\n    \n    vec2 vxvy = vec2(0.0);        \n    \n    float aspect = 1./1.0 *  .99/.98 * .98 * float(iResolution.x) / float(iResolution.y);\n    float aspy = .98;\n    float rfac = 0.05; // divergence fudge factor for approximate no flux\n    \n   \tint subsamp = 2;\n    int n = int(iResolution.x) / subsamp - 1; // / 2.);\n    int nv = 3; \n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < nv; j++) {\n        \n        vec4 puvc = texelFetch(iChannel1, ivec2(i * subsamp, j * subsamp), 0);\n        vec2 puv = vec2(puvc); //vec2(puvc[0], puvc[1]);\n        \n        vec2 duv = uv - puv;\n        float d2 = dot(duv, duv);\n        \n        if (sqrt(d2) > 0.01) {\n        \tvxvy += puvc[2] * vec2(-duv[1], duv[0]) / d2;\n        }\n        \n\n        if (boxy) {\n            \n            float qinv = -puvc[2];\n            vec2 pinv = vec2(puv[0], aspy - puv[1]);\n        \t\n            duv = uv - pinv;\n        \td2 = dot(duv, duv);\n            \n            if (sqrt(d2) > 0.01) {\n                vxvy += qinv * (vec2(-duv[1], duv[0]) + sign(qinv) * duv * rfac) / d2;\n            }\n                        \n        }\n\n\n        if (boxy) {\n            \n            float qinv = -puvc[2];\n            vec2 pinv = vec2(puv[0], -aspy - puv[1]);\n        \t\n            duv = uv - pinv;\n        \td2 = dot(duv, duv);\n            \n            if (sqrt(d2) > 0.01) {\n                vxvy += qinv * (vec2(-duv[1], duv[0]) + sign(qinv) * duv * rfac) / d2;\n            }\n                        \n        }        \n\n    \n        if (boxx) {\n            \n            float qinv = -puvc[2];\n            vec2 pinv = vec2(aspect - puv[0], puv[1]);\n        \t\n            duv = uv - pinv;\n        \td2 = dot(duv, duv);\n            \n            if (sqrt(d2) > 0.01) {\n                vxvy += qinv * (vec2(-duv[1], duv[0]) + sign(qinv) * duv * rfac) / d2;\n            }\n                        \n        }      \n\n        if (boxx) {\n            \n            float qinv = -puvc[2];\n            vec2 pinv = vec2(-aspect - puv[0], puv[1]);\n        \t\n            duv = uv - pinv;\n        \td2 = dot(duv, duv);\n            \n            if (sqrt(d2) > 0.01) {\n                vxvy += qinv * (vec2(-duv[1], duv[0]) + sign(qinv) * duv * rfac) / d2;\n            }                        \n        }\n      }\n    }\n\n    \n    fragColor = vec4(vxvy, 0., 1.);\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"// Advection flow tracking\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n    // Screen coordinates.\n\tvec2 uv = (fragCoord.xy - iResolution.xy*.5) / iResolution.y;\n    float aspect = float(iResolution.x) / float(iResolution.y);\n    \n    float dt = 0.0001 ;\n    \n\n    if (iFrame < 10) {\n        // inverse displacement map (but with numerical diffusion spuriously smoothing the map)\n        fragColor = vec4(uv, 0, 0);        \n    } else {\n        ivec2 ifc = ivec2(round(fragCoord)); \n\n        vec2 vxvy = vec2(texture(iChannel0, fragCoord / vec2(iResolution)));\n\n        vec2 newFragCoord = fragCoord - dt * vxvy * vec2(iResolution);\n\n        fragColor = texture(iChannel1, newFragCoord / vec2(iResolution));\n    }\n}","name":"Buffer C","description":"","type":"buffer"}]}