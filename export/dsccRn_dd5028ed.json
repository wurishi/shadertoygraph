{"ver":"0.1","info":{"id":"dsccRn","date":"1694657327","viewed":17,"name":"Shader Assignment 1b","username":"JoshM","description":"hw\n","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["thing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sf3Rn","filepath":"/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","previewfilepath":"/media/ap/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//from https://iquilezles.org/articles/distfunctions/\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nmat3 RotateX(float theta)\n{\n    float s = sin(theta);\n    float c = cos(theta);\n    return mat3(\n        1.0, 0.0, 0.0,\n        0.0, c,   s,\n        0.0, -s,  c\n    );\n}\n\nmat3 RotateY(float theta)\n{\n    float s = sin(theta);\n    float c = cos(theta);\n    return mat3(\n        c,   0.0, s,\n        0.0, 1.0, 0.0,\n        -s,  0.0, c\n    );\n}\n\nmat3 RotateZ(float theta)\n{\n    float s = sin(theta);\n    float c = cos(theta);\n    return mat3(\n        c,   s, 0.0,\n        -s,  c, 0.0, \n        0.0, 0.0, 1.0\n    ); \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Animated Background\n    \n    vec2 step = floor(uv*10.0)/10.0;\n    float changeRate = fract(sin(dot(step.xy ,vec2(13.0,78.0))) * 43758.0);\n    vec3 col = 0.1 + 0.1*cos(changeRate*iTime) * vec3(2,4,0);\n    \n    //create a ray!\n    //assume orthographic projection\n    vec3 rayPt = vec3(uv.xy, 0);\n    vec3 rayPtdx = vec3(uv.x + 0.00001, uv.y, 0);\n    vec3 rayPtdy = vec3(uv.x, uv.y + 0.00001, 0);\n    vec3 rayDir = vec3(0,0,1);\n    float t = 0.0, tdx = 0.0, tdy = 0.0; //ray parameter\n    \n    //define the sphere and capped torus properties\n    vec3 Sphere1Pos = vec3(0.5,0.5,5.0);\n    float Sphere1Size = .1;\n    \n    vec3 Torus1Pos = vec3(0.5,0.5,5.0);\n    vec2 Torus1Props = vec2(0.1,0.05);\n    vec3 Torus2Pos = vec3(0.5,0.5,5.0);\n    vec2 Torus2Props = vec2(0.1,0.05);\n    vec3 Torus3Pos = vec3(0.5,0.5,5.0);\n    vec2 Torus3Props = vec2(0.1,0.05);\n    \n    \n    for(int i = 0; i < 20; i++){\n        //calculate a point 5 units along the ray\n        vec3 pos = rayPt + rayDir * t;    \n        vec3 posdx = rayPtdx + rayDir * tdx;\n        vec3 posdy = rayPtdy + rayDir * tdy;\n        \n        //Draws the complex shape\n        float dist = min(\n                         min(\n                             sdSphere(pos-Sphere1Pos, Sphere1Size),\n                             sdTorus(RotateX(iTime)*(pos-Torus1Pos), Torus1Props.xy)),\n                         min(\n                             sdTorus(RotateZ(iTime)*(pos-Torus2Pos), Torus2Props),\n                             sdTorus(RotateY(iTime)*(pos-Torus3Pos), Torus3Props)));\n                \n        float distdx = min(\n                         min(\n                             sdSphere(posdx-Sphere1Pos, Sphere1Size),\n                             sdTorus(RotateX(iTime)*(posdx-Torus1Pos), Torus1Props.xy)),\n                         min(\n                             sdTorus(RotateZ(iTime)*(posdx-Torus2Pos), Torus2Props),\n                             sdTorus(RotateY(iTime)*(posdx-Torus3Pos), Torus3Props)));\n        \n        float distdy = min(\n                         min(\n                             sdSphere(posdy-Sphere1Pos, Sphere1Size),\n                             sdTorus(RotateX(iTime)*(posdy-Torus1Pos), Torus1Props.xy)),\n                         min(\n                             sdTorus(RotateZ(iTime)*(posdy-Torus2Pos), Torus2Props),\n                             sdTorus(RotateY(iTime)*(posdy-Torus3Pos), Torus3Props)));\n        \n        if(dist < 0.001  && distdx < 0.001 && distdy < 0.001){\n        \n            vec3 lightDir = rayDir;\n            \n            vec2 step = floor(uv*25.0)/25.0;\n            float changeRate = fract(sin(dot(step.xy ,vec2(13.0,78.0))) * 43758.0);\n            vec3 shapeCol = 0.1 + 0.1*cos(changeRate*iTime) * vec3(4,0,4);\n            shapeCol = vec3(1.0) - shapeCol;\n            \n            //output color = surfacecolor * dot (-Light Direction, surface normal)\n            col = shapeCol*dot(-lightDir, normalize(cross(posdy - pos, posdx - pos)));\n                     \n            break;\n        } \n                \n        t = t + dist;\n        tdx = tdx + distdx;\n        tdy = tdy + distdy;\n        \n    }\n    \n    vec3 noise = mix(texture(iChannel0, uv.xy).rrr,\n                     texture(iChannel1, uv.xy).rrr * (vec3(1) - vec3(sin(iTime))), 0.5);\n    \n    col = mix(col,noise, 0.5);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}