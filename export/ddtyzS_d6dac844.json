{"ver":"0.1","info":{"id":"ddtyzS","date":"1697378864","viewed":62,"name":"Raytraced shadows from heightmap","username":"alint","description":"Raytraced soft shadows from heightmap, can click and drag to control the light position, not optimized.","likes":5,"published":1,"flags":32,"usePreview":0,"tags":["shadows","raytraced"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define HeightImage iChannel1\n\nfloat normpdf(in float x, in float sigma)\n{\n\treturn 0.39894*exp(-0.5*x*x/(sigma*sigma))/sigma;\n}\n\nfloat normpdf3(in vec3 v, in float sigma)\n{\n\treturn 0.39894*exp(-0.5*dot(v,v)/(sigma*sigma))/sigma;\n}\n\nvec2 grayscaleSobel(sampler2D tex, vec2 uv, float spread)\n{\n    vec3 offset = vec3(1.0 / vec2(textureSize(tex, 0)), 0.0) * spread;\n    vec2 grad = vec2(0.0);\n    grad.x -= texture(tex, uv - offset.xy).r * 1.0;\n    grad.x -= texture(tex, uv - offset.xz).r * 2.0;\n    grad.x -= texture(tex, uv + offset.xy * vec2(-1.0, 1.0)).r * 1.0;\n    grad.x += texture(tex, uv + offset.xy * vec2(1.0, -1.0)).r * 1.0;\n    grad.x += texture(tex, uv + offset.xz).r * 2.0;\n    grad.x += texture(tex, uv + offset.xy).r * 1.0;\n    grad.y -= texture(tex, uv - offset.xy).r * 1.0;\n    grad.y -= texture(tex, uv - offset.zy).r * 2.0;\n    grad.y -= texture(tex, uv + offset.xy * vec2(1.0, -1.0)).r * 1.0;\n    grad.y += texture(tex, uv + offset.xy * vec2(-1.0, 1.0)).r * 1.0;\n    grad.y += texture(tex, uv + offset.zy).r * 2.0;\n    grad.y += texture(tex, uv + offset.xy).r * 1.0;\n    return grad;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 final_colour = vec3(0.0);\n    {\n        // using bilaterial blur by mrharicot: https://www.shadertoy.com/view/4dfGDH\n        #define SIGMA 20.0\n        #define BSIGMA 0.6\n        #define MSIZE 15\n\n        // bilaterial blur to the shadows\n        vec2 p = vec2(0.0, 1.0)-(fragCoord.xy / iResolution.y);\n        float c = texture(iChannel0, p).r;\n        //declare stuff\n        const int kSize = (MSIZE-1)/2;\n        float kernel[MSIZE];\n      \n        //create the 1-D kernel\n        float Z = 0.0;\n        for (int j = 0; j <= kSize; ++j)\n        {\n            kernel[kSize+j] = kernel[kSize-j] = normpdf(float(j), SIGMA);\n        }\n        \n        vec3 cc;\n        float factor;\n        float bZ = 1.0/normpdf(0.0, BSIGMA);\n        //read out the texels\n        for (int i=-kSize; i <= kSize; ++i)\n        {\n            for (int j=-kSize; j <= kSize; ++j)\n            {\n                cc = texture(iChannel0, p + vec2(float(i),float(j)) / iResolution.y).rrr;\n                factor = normpdf3(cc-c, BSIGMA)*bZ*kernel[kSize+j]*kernel[kSize+i];\n                Z += factor;\n                final_colour += factor*cc;\n\n            }\n        }\n        final_colour = final_colour / Z + 0.35;\n        //final_colour = vec3(c) + 0.35;\n    }\n    //final_colour = vec3(1.);\n    \n    vec2 uv = fragCoord / iResolution.y;\n    vec3 normal = vec3(grayscaleSobel(HeightImage, uv, 1.0) * vec2(1, 1), 0.5);\n    normal = normalize(normal);    \n    {\n        vec3 lightDir = texture(iChannel0, vec2(0.5)).yzw * 2. - 1.;\n               \n        float height = texture(HeightImage, uv).r;\n        final_colour *= vec3(max(dot(normal, lightDir), 0.0)) * mix(1.0, 0.6, step(0.001, height));\n    }\n    \n    fragColor = vec4(pow(final_colour, vec3(1.0/2.2)), 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\nuint ihash1D(uint q)\n{\n    // hash by Hugo Elias, Integer Hash - I, 2017\n    q = (q << 13u) ^ q;\n    return q * (q * q * 15731u + 789221u) + 1376312589u;\n}\nuvec4 ihash1D(uvec4 q)\n{\n    // hash by Hugo Elias, Integer Hash - I, 2017\n    q = (q << 13u) ^ q;\n    return q * (q * q * 15731u + 789221u) + 1376312589u;\n}\n\nvec2 betterHash2D(vec2 x)\n{\n    uvec2 q = uvec2(x);\n    uint h0 = ihash1D(ihash1D(q.x) + q.y);\n    uint h1 = h0 * 1933247u + ~h0 ^ 230123u;\n    return vec2(h0, h1)  * (1.0 / float(0xffffffffu));\n}\n\n\nfloat hash1D(vec2 x)\n{\n    // hash by Inigo Quilez, Integer Hash - III, 2017\n    uvec2 q = uvec2(x * 65536.0);\n    q = 1103515245u * ((q >> 1u) ^ q.yx);\n    uint n = 1103515245u * (q.x ^ (q.y >> 3u));\n    return float(n) * (1.0 / float(0xffffffffu));\n}\n\nfloat sdfLens(vec2 p, float width, float height)\n{\n    float d = 1.0 / width - width / 4.0;\n    float r = width / 2.0 + d;\n    \n    p = abs(p);\n\n    float b = sqrt(r * r - d * d);\n    vec4 par = p.xyxy - vec4(0.0, b, -d, 0.0);\n    return (par.y * d > p.x * b) ? length(par.xy) : length(par.zw) - r;\n}\n\nvec3 tileWeave(vec2 pos, vec2 scale, float count, float width, float smoothness)\n{\n    vec2 i = floor(pos * scale);    \n    float c = mod(i.x + i.y, 2.0);\n    \n    vec2 p = fract(pos.st * scale);\n    p = mix(p.st, p.ts, c);\n    p = fract(p * vec2(count, 1.0));\n    \n    // Vesica SDF based on Inigo Quilez\n    width *= 2.0;\n    p = p * 2.0 - 1.0;\n    float d = sdfLens(p, width, 1.0);\n    vec2 grad = vec2(dFdx(d), dFdy(d));\n\n    float s = 1.0 - smoothstep(0.0, dot(abs(grad), vec2(1.0)) + smoothness, -d);\n    return vec3(s , normalize(grad) * smoothstep(1.0, 0.99, s) * smoothstep(0.0, 0.01, s)); \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    float r = .35;\n    float count = 3.0;\n    float d = length( fract(uv  * count) - 0.5) - r;\n    float random = hash1D(floor(floor(uv  * count)));\n    d *= step(0., -d);\n    d = abs(d)/r;\n    \n    float current = mod(iTime * 0.5, 4.);\n    if (current < 1. || current > 3. || false)\n        d = (1.-tileWeave(uv, vec2(4.), 2., 0.4, 0.4).x);\n    else if (current < 2.)\n        d = min(d / 0.6, 1.0) * smoothstep(0.6, 0.3, d) * min(random + 0.3, 1.0);\n    else\n        // hemisphere\n        d = -d * (d-2.);\n    \n    fragColor = vec4(d,0.0,1.0,1.0);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":2,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"#define M_PI 3.14162\n#define HeightImage iChannel0\n    \nfloat radicalInverse_VdC(uint bits) \n{\n    bits = (bits << 16u) | (bits >> 16u);\n    bits = ((bits & 0x55555555u) << 1u) | ((bits & 0xAAAAAAAAu) >> 1u);\n    bits = ((bits & 0x33333333u) << 2u) | ((bits & 0xCCCCCCCCu) >> 2u);\n    bits = ((bits & 0x0F0F0F0Fu) << 4u) | ((bits & 0xF0F0F0F0u) >> 4u);\n    bits = ((bits & 0x00FF00FFu) << 8u) | ((bits & 0xFF00FF00u) >> 8u);\n    return float(bits) * 2.3283064365386963e-10; // / 0x100000000\n}\n\nvec2 hammersley(uint i, uint N)\n{\n    return vec2(float(i)/float(N), radicalInverse_VdC(i));\n}  \n\nvec3 computeRandomLightDir(const uint sampleIndex, uint sampleCount, vec2 jitter, const in vec3 LightDirecton, const in vec2 LightSize)\n{\n    // rectangular light\n    vec2 shapeCoordinate = fract(hammersley(sampleIndex, sampleCount) + jitter) * 2.0 - 1.0;\n    shapeCoordinate *= LightSize;\n    \n    vec3 right = cross(vec3(0, 0, 1), LightDirecton);\n    return LightDirecton + right * shapeCoordinate.x + cross(LightDirecton, right) * shapeCoordinate.y;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 texelSize = vec2(1.0 / iResolution.xy);\n \n    vec3 lightPos = iMouse.z > 0.0 ? vec3(iMouse.xy / iResolution.xy * 2. - 1., 1.2) : vec3(vec2(cos(iTime* 1.2), sin(iTime)), 0.1 + 10. * pow(abs(sin(iTime* 0.5 + 30.)), 1.5));\n    lightPos.xy *= -1.;\n    vec2 lightSize = vec2(0.15, 0.3) * 0.9;\n    float shadowLength = 1.0;\n    float heightScale = 1.0;\n    float attentuationStrength = 1.0;\n    const uint raySampleCount = 5u;\n    const float maxHeight = 1.0;\n\n    vec3 lightDir = vec3(lightPos.xy * 0.5, 0.0);\n    lightDir.z = (1.0 - length(lightDir.xy) * 2.0);\n    lightDir.z = max(0.001, max(lightDir.z, lightSize.y) * lightPos.z);\n    lightDir = normalize(lightDir);\n    float shadowLengthSqr = shadowLength * shadowLength;\n    \n    vec2 viewportRatio = vec2(max(texelSize.x, texelSize.y) / min(texelSize.x, texelSize.y), 1.0);\n    vec2 invViewportRatio = 1.0 / (iResolution.x < iResolution.y ? viewportRatio.yx : viewportRatio);\n\n    vec2 rayJitter = texture(iChannel2, uv).xy;\n    const float rayOriginBias = 1e-6;\n    vec3 rayOrigin = vec3(uv * viewportRatio, textureLod(HeightImage, uv, 0.0).r * heightScale + rayOriginBias);    \n    float rayStepSize = min(texelSize.x, texelSize.y) * 4.0;\n    \n    float shadow = 0.0;\n    for (uint i = 0u; i < raySampleCount; i++)\n    {\n        vec3 rayDirection = computeRandomLightDir(i, raySampleCount, rayJitter, lightDir, lightSize);\n\n        vec3 rayPosition = rayOrigin;\n        bool isShadow = false;\n        while(rayPosition.z <= maxHeight)\n        {\n            rayPosition += rayDirection * rayStepSize;\n\n            // could reduce raymarch steps by using hi-z/maximum mipmap algorithm\n            float currentHeight = textureLod(HeightImage, rayPosition.xy * invViewportRatio, 0.0).r * heightScale;\n            // exit if intersection\n            if (rayPosition.z <= currentHeight)\n            {\n                isShadow = true;\n                break;\n            }\n\n            // exit if exceeds maximum distance\n            vec3 d = rayPosition - rayOrigin;\n            if (dot(d, d) >= shadowLengthSqr)\n                break;\n        }\n        \n        float attenuation = 1.0 - length(rayPosition - rayOrigin) / shadowLength;\n        shadow += 1.0 - float(isShadow) * mix(1.0, attenuation, attentuationStrength);\n    }\n    shadow /= float(raySampleCount);\n    shadow = min(shadow, 1.0);\n\n    fragColor = vec4(shadow, lightDir * 0.5 + 0.5);\n}","name":"Buffer B","description":"","type":"buffer"}]}