{"ver":"0.1","info":{"id":"MsXfRH","date":"1495163325","viewed":2429,"name":"Towers of Life","username":"Polygon","description":"A visualization of Conway's Game of Life where each generation is stacked on top of the previous one to form crazy structures.\nPress ENTER to reset.\nYou can now make it repeat forever!","likes":99,"published":1,"flags":48,"usePreview":0,"tags":["voxels","life","cellularautomata"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/* /* /* /* /* /* /* /* /* /* /* /* /* /* /* /* /* /* /* /* /* /* /* /* /* /* /* /* /* /* /* /* \n\n\tTowers of Life  -  By Polygon\n\n\tI'm really happy to finally have this in a presentable state! I would say it's my most\n\tclever and complex toy yet (not sayimg much, I know, but someday I'll get there.)\n\n\tIt's based off of this really cool video:  https://www.youtube.com/watch?v=iiEQg-SHY1g\n\n\n\t*****************************************************************************\n\t*   If it reaches a resting state, press ENTER to reset it.\t\t\t\t\t*\n\t*\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t*\n\t*   You can move the camera with the mouse.\t\t\t\t\t\t\t\t\t*\n\t*\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t*\n\t*   Drag the mouse to the top of the screen to see a regular 2d rendering.\t*\n\t*****************************************************************************\n\n\n\tRight now the game wraps around - if a cell is on the edge of the game board, it will\n\twrap around to the other side of the board while checking for living cells. I might\n\tadd an option to disable this in the future.\n\n/* /* /* /* /* /* /* /* /* /* /* /* /* /* /* /* /* /* /* /* /* /* /* /* /* /* /* /* /* /* /* /*/\n\n\n\n//Width and length of rendered area. If you change them, I recommend you also change them in Buf A.\n#define width 64\n#define height 64\n\n//Change this to 1 if you want it to go on forever, rather than be confined in a box.\n#define REPEAT 0\n\n//Distance of 224 ensures that nothing will be missed if the width and height are both 64.\n//To ensure nothing will be missed, set DISTANCE to width + height + 96. Anything bigger than that will have no improvement.\n#define DISTANCE 224\n\n#define FOV 100.0\n\n//Don't mess with these.\n#define pi 3.14159265\n#define d2r 0.0174533\n\n//Un-comment the next line for a smoother look but lower framerate.\n// #define ANTIALIAS\n\nbool check(vec3 pos);\nvoid render (vec2 i, inout vec4 o);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord) {\n    \n    #ifdef ANTIALIAS\n    vec4 buf;\n    render(fragCoord + vec2(.25, .25), buf);\n    fragColor += buf;\n    render(fragCoord + vec2(-.25, .25), buf);\n    fragColor += buf;\n    render(fragCoord + vec2(-.25, -.25), buf);\n    fragColor += buf;\n    render(fragCoord + vec2(.25, -.25), buf);\n    fragColor += buf;\n    fragColor /= 4.;\n    \n    #else\n    render(fragCoord, fragColor);\n    \n    #endif\n}\n\nvoid render(vec2 i, inout vec4 o) {\n    vec2 uv = i.xy / iResolution.xy;\n    vec2 uvM = iMouse.xy / iResolution.xy;\n    \n    float maxRes = max(iResolution.x, iResolution.y);\n    \n    vec2 s = i.xy / maxRes - vec2(0.5 * iResolution.x / maxRes, 0.5 * iResolution.y / maxRes);\n    \n    vec2 rot = vec2(iTime / 3. + pi,\n               0.6 + 0.75 * sin(iTime / 4.));\n    vec3 pos = vec3(float(width) * sin(iTime / 3.) * cos(rot.y) + float(width) / 2.,\n               -0.707 * float(width) * sin(rot.y),\n               float(height) * cos(iTime / 3.) * cos(rot.y) + float(height) / 2.);\n    \n    if (iMouse.z > 0.0) {\n        rot = vec2(6.5 * (uvM.x - .5),\n               -pi / 6. + (pi / 2. + pi / 6.) * min(uvM.y / .8, 1.));\n        rot.x *= smoothstep(.95, .8, uvM.y * (0.5 + 0.5 * sign(iMouse.z)));\n    \tpos = vec3(float(width) * -sin(rot.x) * cos(rot.y) + float(width) / 2.,\n               -1.0 / (tan(d2r * FOV / 2.)) * max(float(height) * iResolution.x / iResolution.y, float(width)) / 2.0 * sin(rot.y),\n               float(height) * -cos(rot.x) * cos(rot.y) + float(height) / 2.);\n    }\n    \n    //pos.y += float(texelFetch(iChannel1, ivec2(0), 0).y != 1.0) *\n    //    texelFetch(iChannel1, ivec2(0), 0).z * (texelFetch(iChannel1, ivec2(0), 0).x - iTime + texelFetch(iChannel1, ivec2(0), 0).w)\n    //    * smoothstep(.95, .8, uvM.y * (0.5 + 0.5 * sign(iMouse.z)));\n    \n    //Direction of ray\n    vec3 d = vec3(2.0 * s.x * tan(d2r * FOV / 2.0), -2.0 * s.y * tan(d2r * FOV / 2.0), 1.0);\n    d = normalize(d);\n    \n    //Rotations of screen\n    d = vec3(d.x, d.y * cos(rot.y) + d.z * sin(rot.y), d.z * cos(rot.y) - d.y * sin(rot.y));\n    d = vec3(d.x * cos(rot.x) + d.z * sin(rot.x), d.y, d.z * cos(rot.x) - d.x * sin(rot.x));\n    \n    \n    //0 = x, 1 = y, 2 = z\n    int directionHit;\n    \n    vec4 sky = vec4(0.5 - 0.5 * sin(d.y), 0.7 - 0.3 * sin(d.y),1.0,0.0);\n    o = sky - smoothstep(.8, .95, uvM.y * (0.5 + 0.5 * sign(iMouse.z)));\n    \n    #if REPEAT == 0\n    vec3 bounderies = vec3(width, 96., height) * (0.5 - 0.5 * sign(d));\n    vec3 t = (bounderies - pos) / d;\n    \n    vec3 mask = vec3(greaterThanEqual(t.xyz, max(t.yzx, t.zxy)));\n    vec3 nextPlane = (1. - mask) * (floor(pos + d * dot(t, mask)) + 0.5 + 0.5 * sign(d))   +   mask * bounderies;\n    #else\n    vec3 nextPlane;\n    if (pos.y > 0.)\n        nextPlane = floor(pos) + 0.5 + 0.5 * sign(d);\n    else {\n        float t = -pos.y / d.y;\n        if (t < 0.)\n            return;\n        nextPlane = floor(pos + d * t) + .5 + .5 * sign(d);\n        nextPlane.y = 0.;\n    }\n    #endif\n    \n    \n    \n    \n    for (int j = 0; j < DISTANCE; j++) {\n        \n        vec3 distToNext;\n        distToNext = (nextPlane - pos) / d;\n        \n        vec3 mask = vec3(lessThanEqual(distToNext.xyz, min(distToNext.yzx, distToNext.zxy)));\n        \n\n        nextPlane += sign(d)*mask;\n        directionHit = int(dot(mask,vec3(0.0,1.0,2.0)));\n        \n        #if REPEAT == 0\n        if (nextPlane.x > float(width) || nextPlane.x < 0.0\n           || nextPlane.y > 96. || nextPlane.y < 0.0\n           || nextPlane.z > float(height) || nextPlane.z < 0.0)\n            break;\n        #else\n        if (nextPlane.y > 96. || nextPlane.y < 0.)\n            break;\n        #endif\n        \n        #if REPEAT == 0\n        if (check((nextPlane - 0.5 - 0.5 * sign(d)).xzy)) {\n        #else\n        if (check(vec3(mod((nextPlane - 0.5 - 0.5 * sign(d)).xz, vec2(width, height)), (nextPlane - 0.5 - 0.5 * sign(d)).y ))) {\n        #endif\n            vec3 endPos = pos + d * distToNext;\n            \n            o = vec4(1.0,0.2,1.0,1.0) * 0.8 + dot(mask, vec3(0.13333333, 0.2, 0.06666666)) * dot(sign(d),mask);\n\n            float dist = distance(pos, endPos);\n            o.xyz /= (dist * dist / float(width) / float(height) + 1.0);\n            \n            o = (sky * max(0., endPos.y - 48.) + o * (48. - max(0., endPos.y - 48.))) / 48.;\n            \n            #if REPEAT == 0\n            o -= smoothstep(.8, .95, uvM.y * (0.5 + 0.5 * sign(iMouse.z)));\n            \n            if (endPos.y == 0.0 && directionHit == 1) {\n                o = vec4(1., 0.6, 1., 1.) + vec4(smoothstep(.8, .95, uvM.y * (0.5 + 0.5 * sign(iMouse.z))));\n            }\n            \n            #else\n            float multiplier = ((endPos.x - pos.x) * (endPos.x - pos.x) + (endPos.z - pos.z) * (endPos.z - pos.z)) / 4. / float(width + height) / float(width + height);\n            o = o * (1. - min(multiplier, 1.)) + sky * min(multiplier, 1.);\n            o -= smoothstep(.8, .95, uvM.y * (0.5 + 0.5 * sign(iMouse.z)));\n            \n            if (endPos.y == 0.0 && directionHit == 1) {\n                o = vec4(1., 0.6, 1., 1.) * (1. - min(multiplier, 1.)) + sky * min(multiplier, 1.) + vec4(smoothstep(.8, .95, uvM.y * (0.5 + 0.5 * sign(iMouse.z))));\n            }\n            #endif\n            \n        \tbreak;\n     \t}\n    }\n}\n\n\nbool check(vec3 pos) {\n    int b = 1 << (int(pos.z) % 24);\n    vec4 mask = vec4(lessThan(pos.zzz, vec3(24.,48.,72.)),1.0);\n    mask.yzw -= mask.xyz;\n    int xy = int(dot(mask,texelFetch(iChannel0, ivec2(pos.xy),0)));\n    \n    return ((xy & b) == b);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//This buffer runs the game and saves the past 96 states.\n\n\n//Width and height of the area of the \"game board\"\n//I suggest matching them with the width and height of Image.\n#define width 64\n#define height 64\n\n//Chance of a cell being alive at start. Kinda complicated to explain the specifics.\n#define INITIAL_CHANCE 1.15\n\nfloat rand(vec2 co);\nbool check(vec3 pos);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec4 col = ivec4(texelFetch(iChannel0, ivec2(fragCoord), 0));\n    \n    if (texelFetch(iChannel2, ivec2(0), 0).y == 1.0) {\n        int neighbors = 0;\n        if (check(vec3(mod(fragCoord + vec2(-1., -1.), vec2(width, height)), 0.0))) neighbors++;\n        if (check(vec3(mod(fragCoord + vec2(-1., 0.), vec2(width, height)), 0.0))) neighbors++;\n        if (check(vec3(mod(fragCoord + vec2(-1., 1.), vec2(width, height)), 0.0))) neighbors++;\n        if (check(vec3(mod(fragCoord + vec2(0., -1.), vec2(width, height)), 0.0))) neighbors++;\n        if (check(vec3(mod(fragCoord + vec2(0., 1.), vec2(width, height)), 0.0))) neighbors++;\n        if (check(vec3(mod(fragCoord + vec2(1., -1.), vec2(width, height)), 0.0))) neighbors++;\n        if (check(vec3(mod(fragCoord + vec2(1., 0.), vec2(width, height)), 0.0))) neighbors++;\n        if (check(vec3(mod(fragCoord + vec2(1., 1.), vec2(width, height)), 0.0))) neighbors++;\n\n        if ((col.w & (1 << 23)) == (1 << 23)) {\n            col.w -= (1 << 23);\n        }\n\n        col.w = col.w << 1;\n\n        if ((col.z & (1 << 23)) == (1 << 23)) {\n            col.z -= (1 << 23);\n            col.w++;\n        }\n\n        col.z = col.z << 1;\n\n        if ((col.y & (1 << 23)) == (1 << 23)) {\n            col.y -= (1 << 23);\n            col.z++;\n        }\n\n        col.y = col.y << 1;\n\n        if ((col.x & (1 << 23)) == (1 << 23)) {\n            col.x -= (1 << 23);\n            col.y++;\n        }\n\n        col.x = col.x << 1;\n\n        if ((check(vec3(fragCoord, 0.0)) && neighbors > 1 && neighbors < 4) || (!check(vec3(fragCoord, 0.0)) && neighbors == 3)) {\n            col.x ++;\n        }\n    }\n    \n    fragColor = vec4(col);\n    \n    if (iFrame == 0 || texelFetch(iChannel1, ivec2(13, 1), 0).x == 1.0) {\n        fragColor.x = sign(floor(INITIAL_CHANCE * rand(fragCoord)));\n        fragColor.yzw = vec3(0);\n    }\n}\n\nbool check(vec3 pos) {\n    int xy = int(texelFetch(iChannel0, ivec2(pos.xy), 0).x);\n    return ((xy & 1) == 1);\n}\n\n\n\n\nfloat rand(vec2 co) {\n   \t//\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t    ###########################\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453 * mod(iDate.w, 100.) / 100.);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"//This buffer keeps track of how fast the game runs, and handles restarting.\n\n\n//Ticks per second. If it is higher than your framerate, it will just run at your framerate.\n//The game will slowly accelerate until it meets that speed for effect.\n#define speed 20.\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float next = texelFetch(iChannel0, ivec2(0),0).x;\n    float startTime = texelFetch(iChannel0, ivec2(0),0).w;\n    \n    if (iFrame == 0 || texelFetch(iChannel1, ivec2(13, 1), 0).x == 1.0) {\n        next = 1.;\n        startTime = (iFrame == 0) ? 0.0 : iTime;\n    }\n    \n    if (iTime - startTime >= next) {\n        fragColor.y = 1.0;\n        next += 1.0 / min(float(speed), iTime - startTime);\n    }\n    fragColor.x = next;\n    fragColor.z = min(float(speed), iTime - startTime);\n    fragColor.w = startTime;\n}","name":"Buffer B","description":"","type":"buffer"}]}