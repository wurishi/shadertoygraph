{"ver":"0.1","info":{"id":"l33Gz2","date":"1716745754","viewed":86,"name":"procedural bubble noise","username":"Neervana","description":"Voronoi-like shader, I did not look up any code (just the idea of randomly generating points and taking the distance), \n\nThank to FabriceNeyret2 for the fixes!","likes":1,"published":3,"flags":0,"usePreview":0,"tags":["noise","random","shader"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n#define POINTS 32.0\n#define SEED 42.0\n\n#define BUBBLE_AROUND\n\n#ifdef BUBBLE_AROUND\n#define T (iTime / 1000.0)\n#else\n#define T 0.0\n#endif\n\n\nfloat noise1d(float n){\n    return fract(cos(n*89.42 + SEED + T)*343.42);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.y;\n    float res_scale = iResolution.x / iResolution.y;\n    \n    \n    float min_dist = 1.0;\n    \n    for(float i = 0.0; i <= POINTS; ++i) {\n        vec2 point = vec2(\n             noise1d(i) * res_scale,\n            (noise1d(i + 0.1) * res_scale)\n        );\n        min_dist = min(min_dist, distance(point, uv));\n    }\n   \n    fragColor = vec4( 1.-sqrt(POINTS)*min_dist );\n\n\n}","name":"Image","description":"","type":"image"}]}