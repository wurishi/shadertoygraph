{"ver":"0.1","info":{"id":"DtccWS","date":"1699563125","viewed":19,"name":"Smooth Sphere","username":"lothrosl","description":"Spinning shaded sphere","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["shading"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Sphere (p-pos)^2 = r^2\nstruct Sphere {\nvec3 pos;\nfloat r;\n};\n// implicit plane equation n*p-D=0\nstruct Plane {\nvec3 n;\nfloat D;\n};\nstruct AreaLight {\nvec3 forward;\nvec3 right;\nvec3 up;\n// middle of light\nvec3 pos;\n// physical size of light\nvec2 size;\n};\n// World objects and lights\nSphere sphere_0 = Sphere(vec3(0.0,0.0,0.4),0.5);\nPlane plane_0 = Plane(vec3(0.0,0.0,0.1),0.0);\nAreaLight light = AreaLight(vec3(0,0,-1), vec3(0,1,0), vec3(1,0,0),\nvec3(5,0,5), vec2(3,3));\nvec3 ambient = vec3(0.1, 0.1, 0.1);\nvec3 checkerTex(vec2 coord) {\nfloat total = floor(coord.x) + floor(coord.y);\nbool isEven = mod(total, 2.0) == 0.0;\nreturn (isEven)?vec3(1.):vec3(0.);\n}\n// test ray against a sphere\nfloat sphere(in Sphere sph, in vec3 ro, in vec3 rd) {\nfloat t = -1.0;\nro -= sph.pos;\nfloat r = sph.r;\nfloat b = dot(ro, rd);\nfloat c = dot(ro, ro) - r * r;\nfloat h = b * b - c;\nif (h >= 0.0)\nt = (-b - sqrt(h));\nif (t < 0.0)\nt = (-b + sqrt(h));\nreturn t;\n}\n// test ray against xy plane\nfloat plane(in Plane p, in vec3 ro, in vec3 rd) {\nreturn (p.D - dot(ro, p.n)) / dot(rd, p.n);\n}\n// shoot the ray into the world\nvec2 shoot(in vec3 ro, in vec3 rd) {\nfloat t = 1000.0; // initially set result to be very far\nvec2 res = vec2(t, 0.0f);\nfloat s = sphere(sphere_0,ro, rd);\nif (s > 0.0) {\nt = s;\nres.y = 1.0; // sphere is category 1.0\n}\nfloat p = plane(plane_0, ro, rd);\nif (p > 0.0 && p < t) {\nt = p;\nres.y = 2.0; //plane is category 2.0\n}\n// This is the distance along the ray\nres.x = t;\nreturn res;\n}\n// Returns the phong equation for a given direction to a camera,\n// direction to a light, and normal for a surface\nvec3 phongEquation(vec3 camera_dir, vec3 light_dir, vec3 normal ) {\nvec3 R = reflect(-camera_dir, normal);\nvec3 out_color;\nout_color = 0.4*max(0.0,dot(normal, light_dir))*vec3(1.0);\nout_color += 0.1*pow(max(0.0,dot(light_dir, R)),10.)*vec3(10.0);\nout_color += ambient;\nreturn out_color;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n// screen uv in (-1, 1)\nvec2 uv = fragCoord.xy / iResolution.xy * 2.0 - 1.0;\n// Rays from camera\n// depth from optical center to image plane\nfloat d = 2.0;\nvec3 ray_origin = vec3(cos(iTime * -0.2) * d,\nsin(iTime * -0.2) * d, 0.5);\nvec3 target = vec3(0.0, 0.0, 0.6);\nvec3 up = vec3(0.0,0.0,1.0);\nvec3 cam_forward = normalize(target - ray_origin);\nvec3 cam_right = normalize(cross(cam_forward, up));\nvec3 cam_up = normalize(cross(cam_forward, cam_right));\nvec3 ray_direction = normalize(uv.x * (iResolution.x / iResolution.y)\n* cam_right - uv.y * cam_up + 2.0 * cam_forward);\n// shoot the ray\nvec2 res = shoot(ray_origin, ray_direction);\n// background\nvec3 point = ray_origin + res.x * ray_direction;\nvec3 color;\n// objects\n if (res.x > 0.0 && res.x < 1000.0) {\n        // sphere is y=1.0\n         if (res.y == 1.) {\n            vec3 lightColor = vec3(0.0);\n\n            // TODO - Average contributions from the three vectors of AreaLight\n            vec3 lightDir1 = normalize(light.pos - point - 0.6 * light.size.x * light.right - 0.6 * light.size.y * light.up);\n            vec3 lightDir2 = normalize(light.pos - point + 0.6 * light.size.x * light.right - 0.6 * light.size.y * light.up);\n            vec3 lightDir3 = normalize(light.pos - point - 0.6 * light.size.x * light.right + 0.6 * light.size.y * light.up);\n            \n            lightColor += phongEquation(-ray_direction, lightDir1, normalize(point - sphere_0.pos));\n            lightColor += phongEquation(-ray_direction, lightDir2, normalize(point - sphere_0.pos));\n            lightColor += phongEquation(-ray_direction, lightDir3, normalize(point - sphere_0.pos));\n\n            color += lightColor / 3.0;  // Average over the three vectors\n        }\n        // Plane is y category = 2.0\n        else if (res.y == 2.) {\n            // TODO - Average full area of light\n            // See AreaLight struct above\n            vec3 lightColor = vec3(0.0);\n\n            // TODO - Average contributions from the three vectors of AreaLight\n            vec3 lightDir1 = normalize(light.pos - point - 0.5 * light.size.x * light.right - 0.5 * light.size.y * light.up);\n            vec3 lightDir2 = normalize(light.pos - point + 0.5 * light.size.x * light.right - 0.5 * light.size.y * light.up);\n            vec3 lightDir3 = normalize(light.pos - point - 0.5 * light.size.x * light.right + 0.5 * light.size.y * light.up);\n            \n            // check for shadow\n            if (shoot(point + vec3(0.0, 0.0, 0.01), lightDir1).y > 0.0f) {\n                color += 2.0 * checkerTex(point.xy * 5.0) / res.x * ambient;\n            } else {\n                color += 0.5 * 2.0 * checkerTex(point.xy * 5.0) / res.x * phongEquation(-ray_direction, lightDir1, vec3(0.0, 0.0, 1.0));  // Make the plane darker (multiply by 0.5)\n            }\n\n            if (shoot(point + vec3(0.0, 0.0, 0.01), lightDir2).y > 0.0f) {\n                color += 2.0 * checkerTex(point.xy * 5.0) / res.x * ambient;\n            } else {\n                color += 0.5 * 2.0 * checkerTex(point.xy * 5.0) / res.x * phongEquation(-ray_direction, lightDir2, vec3(0.0, 0.0, 1.0));  // Make the plane darker (multiply by 0.5)\n            }\n\n            if (shoot(point + vec3(0.0, 0.0, 0.01), lightDir3).y > 0.0f) {\n                color += 2.0 * checkerTex(point.xy * 5.0) / res.x * ambient;\n            } else {\n                color += 0.5 * 2.0 * checkerTex(point.xy * 5.0) / res.x * phongEquation(-ray_direction, lightDir3, vec3(0.0, 0.0, 1.0));  // Make the plane darker (multiply by 0.5)\n            }\n        }\n    }\n\n    // output\n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}