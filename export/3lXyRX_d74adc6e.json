{"ver":"0.1","info":{"id":"3lXyRX","date":"1592559627","viewed":210,"name":"Smooth min demo","username":"positivepig","description":"smooth min demo","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","sdf","smoothmin","union"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAXSTEP 100\n#define MAXDIST 250.\n#define ESPI 1e-4\n\nstruct Ray{\n    vec3 origin;\n    vec3 direction;\n};\n\nfloat intersectSDF(float distA, float distB){\n    return max(distA, distB);\n}\n\nfloat smooth_min(float distA, float distB, float k){\n    float h = clamp(0.5 + 0.5 * (distA - distB)/k, 0.0, 1.0);\n    return mix(distA, distB, h) - k*h*(1.0-h);\n}\n\nfloat unionSDF(float distA, float distB){\n    return min(distA, distB);\n}\n\nfloat differenceSDF(float distA, float distB){\n    return max(distA, -distB);\n}\n\nfloat sphereSDF(vec3 p){\n    return length(p) - 1.;\n}\n\nfloat cubeSDF(vec3 p){\n    vec3 q = abs(p) - vec3(1., 1., 1.);\n    float outside = length(max(q, 0.));\n    float inside = min(max(q.x, max(q.y, q.z)), 0.);\n    return outside + inside;\n}\n\nfloat sceneSDF(vec3 p){\n    return smooth_min(\n        sphereSDF(p - vec3(.5, 0.0, 0.0)),\n        sphereSDF(p + vec3(.5, 0.0, 0.0)), 0.2\n        \n    );\n}\n\nvec3 getNormal(vec3 p){\n    vec2 e = vec2(ESPI, 0.0);\n    return normalize(vec3(\n        sceneSDF(p + e.xyy) - sceneSDF(p - e.xyy),\n        sceneSDF(p + e.yxy) - sceneSDF(p - e.yxy),\n        sceneSDF(p + e.yyx) - sceneSDF(p - e.yyx)\n    ));\n}\n\nmat3 getMatrix(vec3 origin, vec3 ta){\n    vec3 cw = normalize(ta - origin);\n    vec3 cu = normalize(cross(vec3(0.,1.,0.), cw));\n    vec3 cv = normalize(cross(cw, cu));\n    return mat3(cu, cv, cw);\n}\n\nfloat raymarch(Ray ray, float maxdist){\n    float dist = 0.0;\n    for(int i = 0; i < MAXSTEP; ++i){\n        vec3 p = ray.origin + dist * ray.direction;\n        float r = sceneSDF(p);\n        if(r < ESPI) return dist;\n        dist += r;\n        if(dist >= MAXDIST) return MAXDIST;\n    }\n    return MAXDIST;\n}\n\nvec3 render(vec3 k_a, vec3 k_d, vec3 k_s, vec3 p, float shininess, Ray ray){\n    vec3 lightpos = vec3(0.5, 1.5, -1.5);\n    vec3 lightintensity = vec3(1.0, 1.0, 1.0);\n    vec3 L = normalize(lightpos - p);\n    vec3 V = normalize(-ray.direction);\n    vec3 N = getNormal(p);\n    vec3 R = normalize(reflect(-L, N));\n    vec3 H = normalize(L+V);\n    float LdotN = clamp(dot(L, N), 0.0, 1.0);\n    float RdotV = clamp(dot(R, V), 0.0, 1.0);\n    float HdotN = clamp(dot(H, N), 0.0, 1.0);\n    vec3 c_ambient = k_d * k_a;\n    float atten = 2.0 / dot(lightpos - p, lightpos - p);\n    vec3 c_diffuse = lightintensity * k_d * atten * LdotN;\n    vec3 c_specular = lightintensity * k_s * pow(HdotN, shininess);\n    return c_ambient + c_diffuse + c_specular;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec2 uv = (2. * fragCoord - iResolution.xy) / iResolution.y;\n    vec2 mouse = iMouse.xy / iResolution.xy;\n    vec3 origin = vec3(0., 2., 3);\n    vec3 ta = vec3(0., 0., 0.);\n   // vec3 origin = ta + vec3(4.*cos(0.2*iTime - 8.*mouse.x), 0.5 + mouse.y*3., 4.*sin(0.2*iTime - 8.*mouse.x));\n    mat3 m = getMatrix(origin, ta);\n    vec3 direction = m * normalize(vec3(uv, 2.5));\n    Ray ray = Ray(origin, direction);\n    float dist = raymarch(ray, MAXDIST);\n    if(dist > MAXDIST - ESPI){\n        fragColor = vec4(0.);\n        return;\n    }\n    vec3 p = origin + direction * dist;\n    vec3 k_a = vec3(0.5, 0.5, 0.5);\n    vec3 k_d = vec3(0.75, 0.65, 0.33);\n    vec3 k_s = vec3(1.0, 1.0, 1.0);\n    float shininess = 64.;\n    vec3 col = render(k_a, k_d, k_s, p, shininess, ray);\n    fragColor = vec4(col, 1.0);\n}\n\n\n\n","name":"Image","description":"","type":"image"}]}