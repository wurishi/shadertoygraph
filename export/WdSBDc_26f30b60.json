{"ver":"0.1","info":{"id":"WdSBDc","date":"1590943696","viewed":158,"name":"textured icosahedron frame","username":"darkfox","description":"icosahedron.","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["noise","polyhedron"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// rayMarching reference: https://www.shadertoy.com/view/XtXGRS\n// folding reference: https://www.shadertoy.com/view/XlX3zB\n\n// constant.\n#define pi 3.14159\n// palette.\nconst vec3 black = vec3(0.2);\nconst vec3 skyblue = vec3(0.1, 0.65, 0.9);\nconst vec3 silver = vec3(0.5);\nconst vec3 gold = vec3(0.85, 0.67, 0.14);\n// for folding.\nconst vec3 nc5 = vec3(-0.5, -0.809017, 0.309017);\nconst vec3 pab5 = vec3(0.0, 0.0, 0.809017);\nconst vec3 pbc5 = vec3(0.5, 0.0, 0.809017);\nconst vec3 pca5 = vec3(0.0, 0.269672, 0.706011);\nconst vec3 nab5 = vec3(0.0, 0.0, 1.0);\nconst vec3 nbc5 = vec3(0.525731, 0.0, 0.850651);\nconst vec3 nca5 = vec3(0.0, 0.356822, 0.934172);\n// for noise.\nconst vec2 u_10 = vec2(1.0, 0.0);\nconst vec2 u_01 = vec2(0.0, 1.0);\nconst vec2 u_11 = vec2(1.0, 1.0);\nconst vec3 r_vec_30 = vec3(127.1, 311.7, 251.9);\nconst vec3 r_vec_31 = vec3(269.5, 183.3, 314.3);\nconst vec3 r_vec_32 = vec3(419.2, 371.9, 218.4);\nconst vec3 u_100 = vec3(1.0, 0.0, 0.0);\nconst vec3 u_010 = vec3(0.0, 1.0, 0.0);\nconst vec3 u_001 = vec3(0.0, 0.0, 1.0);\nconst vec3 u_110 = vec3(1.0, 1.0, 0.0);\nconst vec3 u_101 = vec3(1.0, 0.0, 1.0);\nconst vec3 u_011 = vec3(0.0, 1.0, 1.0);\nconst vec3 u_111 = vec3(1.0, 1.0, 1.0);\nconst float r_coeff = 43758.5453123;\nconst int octaves = 6;\n// hsb to rgb.\nvec3 getRGB(float h, float s, float b){\n  vec3 c = vec3(h, s, b);\n  vec3 rgb = clamp(abs(mod(c.x * 6.0 + vec3(0.0, 4.0, 2.0), 6.0) - 3.0) - 1.0, 0.0, 1.0);\n  rgb = rgb * rgb * (3.0 - 2.0 * rgb);\n  return c.z * mix(vec3(1.0), rgb, c.y);\n}\n// rotation.\nvec2 rotate(vec2 p, float t){\n  return p * cos(t) + vec2(-p.y, p.x) * sin(t);\n}\n// x axis rotation.\nvec3 rotateX(vec3 p, float t){\n  p.yz = rotate(p.yz, t);\n  return p;\n}\n// y axis rotation.\nvec3 rotateY(vec3 p, float t){\n  p.zx = rotate(p.zx, t);\n  return p;\n}\n// z axis rotation.\nvec3 rotateZ(vec3 p, float t){\n  p.xy = rotate(p.xy, t);\n  return p;\n}\n// fold H3 with counting.\nint foldH3Count(inout vec3 p){\n  int n = 0;\n  float _dot;\n  for(int i = 0; i < 5; i++){\n    if(p.x < 0.0){ p.x = -p.x; n++; }\n    if(p.y < 0.0){ p.y = -p.y; n++; }\n    _dot = dot(p, nc5);\n    if(_dot < 0.0){ p -= 2.0 * _dot * nc5; n++; }\n  }\n  return n;\n}\nvec3 getP5(vec3 u){\n  return u.x * pab5 + u.y * pbc5 + u.z * pca5;\n}\nvec3 getP5(float u1, float u2, float u3){\n  return u1 * pab5 + u2 * pbc5 + u3 * pca5;\n}\n// 3D random vector.(-1.0～1.0)\nvec3 random3(vec3 st){\n  vec3 v;\n  v.x = sin(dot(st, r_vec_30)) * r_coeff;\n  v.y = sin(dot(st, r_vec_31)) * r_coeff;\n  v.z = sin(dot(st, r_vec_32)) * r_coeff;\n  return -1.0 + 2.0 * fract(v); // normalize to -1.0～1.0\n}\n// simplex noise.\nfloat snoise3(vec3 st){\n  vec3 p = st + (st.x + st.y + st.z) / 3.0;\n  vec3 f = fract(p);\n  vec3 i = floor(p);\n  vec3 g0, g1, g2, g3;\n  vec4 wt;\n  g0 = i;\n  g3 = i + u_111;\n  if(f.x >= f.y && f.x >= f.z){\n    g1 = i + u_100;\n    g2 = i + (f.y >= f.z ? u_110 : u_101);\n    wt = (f.y >= f.z ? vec4(1.0 - f.x, f.x - f.y, f.y - f.z, f.z) : vec4(1.0 - f.x, f.x - f.z, f.z - f.y, f.y));\n  }else if(f.y >= f.x && f.y >= f.z){\n    g1 = i + u_010;\n    g2 = i + (f.x >= f.z ? u_110 : u_011);\n    wt = (f.x >= f.z ? vec4(1.0 - f.y, f.y - f.x, f.x - f.z, f.z) : vec4(1.0 - f.y, f.y - f.z, f.z - f.x, f.x));\n  }else{\n    g1 = i + u_001;\n    g2 = i + (f.x >= f.y ? u_101 : u_011);\n    wt = (f.x >= f.y ? vec4(1.0 - f.z, f.z - f.x, f.x - f.y, f.y) : vec4(1.0 - f.z, f.z - f.y, f.y - f.x, f.x));\n  }\n  float value = 0.0;\n  wt = wt * wt * wt * (wt * (wt * 6.0 - 15.0) + 10.0);\n  value += wt.x * dot(p - g0, random3(g0));\n  value += wt.y * dot(p - g1, random3(g1));\n  value += wt.z * dot(p - g2, random3(g2));\n  value += wt.w * dot(p - g3, random3(g3));\n  return value;\n}\n// fbm.\nfloat fbm(vec3 st){\n  float value = 0.0;\n  float amplitude = 0.5;\n  for(int i = 0; i < octaves; i++){\n    value += amplitude * snoise3(st);\n    st *= 2.0;\n    amplitude *= 0.5;\n  }\n  return value;\n}\n// sphere.\nfloat sphere(vec3 p, float r){\n  return length(p) - r;\n}\n// bar. (n:direction, r:radius)\nfloat bar(vec3 p, vec3 n, float r){\n  return length(p - dot(p, n) * n) - r;\n}\n// half open bar.\nfloat halfBar(vec3 p, vec3 n, float r){\n  return length(p - min(0.0, dot(p, n)) * n) - r;\n}\n// update distance.\n// 0:min, union.\n// 1:max, intersection.\n// 2:minus min, difference.\nvoid updateDist(inout vec3 color, inout float dist, vec3 c, float d, int modeId){\n  if(d < dist && modeId == 0){ color = c; dist = d; }\n  if(d > dist && modeId == 1){ color = c; dist = d; }\n  if(-d > dist && modeId == 2){ color = c; dist = -d; }\n}\n// map function.\nvec4 map(vec3 p){\n  vec3 color = black;\n  float t = 1e20;\n  int n = foldH3Count(p);\n  float t1 = max(dot(p - pbc5 * 2.2, nca5), dot(p - pbc5 * 2.0, -nca5));\n  updateDist(color, t, getRGB(float(n) / 15.0, 1.0, 1.0), t1, 0);\n  vec3 guide = getP5(0.0, 0.9, 0.1) * 2.1;\n  vec3 v = normalize(cross(pab5 - pbc5, nca5));\n  updateDist(color, t, silver, dot(p - guide, v), 1);\n  updateDist(color, t, gold, max(dot(p - getP5(0.0, 0.1, 0.9) * 2.1, pbc5 - pca5 + nca5 * 0.1), dot(p - getP5(0.0, 0.05, 0.95) * 2.1, pbc5 - pca5 - nca5 * 0.1)), 0);\n  updateDist(color, t, skyblue, sphere(p, 1.0), 0);\n  return vec4(color, t);\n}\n// normal vector.\nvec3 calcNormal(vec3 p){\n  const vec2 eps = vec2(0.0001, 0.0);\n  // mathematical procedure.\n  vec3 n;\n  n.x = map(p + eps.xyy).w - map(p - eps.xyy).w;\n  n.y = map(p + eps.yxy).w - map(p - eps.yxy).w;\n  n.z = map(p + eps.yyx).w - map(p - eps.yyx).w;\n  return normalize(n);\n}\n// ray marching.\nfloat march(vec3 ray, vec3 camera){\n  const float maxd = 20.0; // searching limit.\n  const float precis = 0.001; // precision.\n  const int ITERATION = 64; // iteration limit.\n  float h = precis * 2.0; // heuristics.\n\n  float t = 0.0; // current distance.\n\n  float result = -1.0;\n  for(int i = 0; i < ITERATION; i++){\n    if(h < precis || t > maxd){ break; }\n    // adding heuristics value.\n    h = map(camera + t * ray).w;\n    t += h;\n  }\n  // if t < maxd, it means success(h < precis).\n  if(t < maxd){ result = t; }\n  return result;\n}\n// camera move.\nvoid transform(inout vec3 p){\n  p = rotateX(p, pi * iTime * 0.3);\n  p = rotateY(p, pi * iTime * 0.15);\n}\n// circles.\nvoid drawSeigaiha(inout vec3 color, in vec2 p, float r, int n){\n  float d = length(p);\n  if(d > r){ return; }\n  float s = mod(floor(d * 2.0 * float(n) / r), 2.0);\n  color = getRGB(0.65, s * 0.4, 1.0);\n}\n// SEIGAI_HA.\nvec3 getSeigaihaColor(in vec2 p, float scale){\n  p *= scale;\n  vec2 q = (mat2(1.0, 1.0, -sqrt(3.0), sqrt(3.0)) / 3.0) * p;\n  vec2 i = floor(q);\n  vec2 f = fract(q);\n  vec2 e1 = vec2(sqrt(3.0) * 0.5, -0.5);\n  vec2 e2 = vec2(sqrt(3.0) * 0.5, 0.5);\n  // p update.\n  p = f.x * e1 + f.y * e2;\n  vec2 ul = vec2(0.0);\n  vec2 ur = e1 + e2;\n  vec2 ct = e1;\n  vec2 dl = e1 - e2;\n  vec2 dr = 2.0 * e1;\n  // step1: draw seigaiha upper.\n  // step2: draw seigaiha middle.\n  // step3: draw seigaiha lower.\n  vec3 color = vec3(f.x, f.y, 1.0);\n  drawSeigaiha(color, p - ul, 1.0, 4);\n  drawSeigaiha(color, p - ur, 1.0, 4);\n  drawSeigaiha(color, p - ct, 1.0, 4);\n  drawSeigaiha(color, p - dl, 1.0, 4);\n  drawSeigaiha(color, p - dr, 1.0, 4);\n  return color;\n}\n// background.\nvec3 getBackground(vec2 p){\n  p += vec2(iTime, 0.1 * sin(iTime * pi));\n  return getSeigaihaColor(p, 6.0);\n}\n// main.\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n  vec2 p = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n  vec3 color;\n  // ray vector.\n  vec3 ray = normalize(vec3(p, -1.8));\n  // camera position.\n  vec3 camera = vec3(0.0, 0.0, 4.5);\n  // light vector.\n  vec3 light = normalize(vec3(0.5, 0.8, 3.0));\n  // camera rotation.\n  transform(ray);\n  transform(camera);\n  transform(light);\n  color = getBackground(p);\n  // get ray marching result.\n  float t = march(ray, camera);\n  // if t > -0.001, it means success. if not, background color.\n  if(t > -0.001){\n    vec3 pos = camera + t * ray;\n    vec3 n = calcNormal(pos);\n    // lighting.\n    float diff = clamp((dot(n, light) + 0.5) * 0.7, 0.3, 1.0);\n    vec3 baseColor = map(pos).xyz;\n    baseColor *= diff;\n    float nValue = 0.5 + 0.5 * fbm(pos + vec3(0.0, 0.0, iTime));\n    vec3 mainColor = baseColor + (vec3(0.9) - baseColor) * smoothstep(0.44, 0.56, nValue);\n    // fadeout.\n    color = mix(mainColor, color, tanh(t * 0.02));\n  }\n  fragColor = vec4(color, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}