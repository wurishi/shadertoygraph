{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"// Formant Synthesizer\n//\n// Wouter van Nifterick, 15 august 2014\n//\n// 15 aug 2014\n//\n// Graphics taken from https://www.shadertoy.com/view/XdXGRB by David Hoskins\n// Just something to look at, while your graphics card talks to you :)\n\n#define font_size 15. \n#define font_spacing .08\n#define STROKEWIDTH 0.05\n#define PI 3.14159265359\n\n#define A_ vec2(0.,0.)\n#define B_ vec2(1.,0.)\n#define C_ vec2(2.,0.)\n#define E_ vec2(1.,1.)\n#define G_ vec2(0.,2.)\n#define H_ vec2(1.,2.)\n#define I_ vec2(2.,2.)\n#define J_ vec2(0.,3.)\n#define K_ vec2(1.,3.)\n#define L_ vec2(2.,3.)\n#define M_ vec2(0.,4.)\n#define N_ vec2(1.,4.)\n#define O_ vec2(2.,4.)\n#define S_ vec2(0.,6.)\n#define T_ vec2(1.,6.)\n#define U_ vec2(2.0,6.)\n\n#define A(p) t(G_,I_,p) + t(I_,O_,p) + t(O_,M_, p) + t(M_,J_,p) + t(J_,L_,p)\n#define D(p) t(C_,O_,p) + t(O_,M_,p) + t(M_,G_,p) + t(G_,I_,p)\n#define E(p) t(O_,M_,p) + t(M_,G_,p) + t(G_,I_,p) + t(I_,L_,p) + t(L_,J_,p)\n#define H(p) t(A_,M_,p) + t(G_,I_,p) + t(I_,O_,p) \n#define O(p) t(G_,I_,p) + t(I_,O_,p) + t(O_,M_, p) + t(M_,G_,p)\n#define R(p) t(M_,G_,p) + t(G_,I_,p)\n#define S(p) t(I_,G_,p) + t(G_,J_,p) + t(J_,L_,p) + t(L_,O_,p) + t(O_,M_,p)\n#define T(p) t(B_,N_,p) + t(N_,O_,p) + t(G_,I_,p)\n#define Y(p) t(G_,M_,p) + t(M_,O_,p) + t(I_,U_,p) + t(U_,S_,p)\n#define STOP(p) t(N_,N_,p)\n\t\nvec2 caret_origin = vec2(2.0, .7);\nvec2 caret;\nfloat sp = 1.4; // speed\n\n\n//-----------------------------------------------------------------------------------\nfloat minimum_distance(vec2 v, vec2 w, vec2 p)\n{\t// Return minimum distance between line segment vw and point p\n  \tfloat l2 = (v.x - w.x)*(v.x - w.x) + (v.y - w.y)*(v.y - w.y); //length_squared(v, w);  // i.e. |w-v|^2 -  avoid a sqrt\n  \tif (l2 == 0.0) {\n\t\treturn distance(p, v);   // v == w case\n\t}\n\t\n\t// Consider the line extending the segment, parameterized as v + t (w - v).\n  \t// We find projection of point p onto the line.  It falls where t = [(p-v) . (w-v)] / |w-v|^2\n  \tfloat t = dot(p - v, w - v) / l2;\n  \tif(t < 0.0) {\n\t\t// Beyond the 'v' end of the segment\n\t\treturn distance(p, v);\n\t} else if (t > 1.0) {\n\t\treturn distance(p, w);  // Beyond the 'w' end of the segment\n\t}\n  \tvec2 projection = v + t * (w - v);  // Projection falls on the segment\n\treturn distance(p, projection);\n}\n\n//-----------------------------------------------------------------------------------\nfloat textColor(vec2 from, vec2 to, vec2 p)\n{\n\tp *= font_size;\n\tfloat inkNess = 0., nearLine, corner;\n\tnearLine = minimum_distance(from,to,p); // basic distance from segment, thanks http://glsl.heroku.com/e#6140.0\n\tinkNess += smoothstep(0., 1. , 1.- 14.*(nearLine - STROKEWIDTH)); // ugly still\n\tinkNess += smoothstep(0., 2.5, 1.- (nearLine  + 5. * STROKEWIDTH)); // glow\n\treturn inkNess;\n}\n\n//-----------------------------------------------------------------------------------\nvec2 grid(vec2 letterspace) \n{\n\treturn ( vec2( (letterspace.x / 2.) * .65 , 1.0-((letterspace.y / 2.) * .95) ));\n}\n\n//-----------------------------------------------------------------------------------\nfloat count = 0.0;\nfloat t(vec2 from, vec2 to, vec2 p) \n{\n\tcount++;\n\tif (count > mod(1.+iTime,sp)*30.0) return 0.0;\n\treturn textColor(grid(from), grid(to), p);\n}\n\n//-----------------------------------------------------------------------------------\nvec2 r(vec2 fragCoord)\n{\n\tvec2 pos = fragCoord.xy/iResolution.xy;\n\tpos.y -= caret.y;\n\tpos.x -= font_spacing*caret.x;\n\treturn pos;\n}\n\n//-----------------------------------------------------------------------------------\nvoid add()\n{\n\tcaret.x += 1.0;\n}\n\n//-----------------------------------------------------------------------------------\n\n//-----------------------------------------------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat d = 0.;\n\tvec3 col = vec3(0);\n\t\n\tcaret = caret_origin;\n    \n    \n\n\t// the quick brown fox jumps over the lazy dog...\n\td += S(r(fragCoord)); add(); \n    d += H(r(fragCoord)); add(); \n    d += A(r(fragCoord)); add(); \n    d += D(r(fragCoord)); add(); \n    d += E(r(fragCoord)); add(); \n    d += R(r(fragCoord)); add(); \n    d += T(r(fragCoord)); add(); \n    d += O(r(fragCoord)); add(); \n    d += Y(r(fragCoord)); add(); \n        \n\t// d = clamp(d* (.75+sin(fragCoord.x*PI*.5-time*4.3)*.5), 0.0, 1.0);\n    \n\n    d *= clamp(mod(1.+iTime,sp)+0.5,0.3,1.0);\n    d = clamp(d,0.,1.);\n    d = 1.5*d - iTime*0.15;\n      \n    col += vec3(d*.5, d*.85, d);\n\tvec2 xy = fragCoord.xy / iResolution.xy;\n\tfragColor = vec4( col, 1.0 );\n}\n","name":"Image","description":"","type":"image"},{"outputs":[],"inputs":[],"code":"// Formant Synthesizer\n//\n// Wouter van Nifterick, 15 august 2014\n//\n// 15 aug 2014\n\n#define PI 3.1415926535897932384626433832795\n#define PI2 PI*2.0\n\nfloat formant(float pitch, float freq, float time)\n{   \n    time = mod( time, PI / pitch);    \n    return sin((2.0 * PI) * freq * time);\n\n}\n\n\nfloat getSample(float pitch, vec4 f, float time)\n{\n  return (\n    formant(pitch,f.x, time) * 1.00+\n    formant(pitch,f.y, time) * 0.96+\n    formant(pitch,f.z, time) * 0.90+\n    formant(pitch,f.w, time) * 0.85\n  ) * .25;\n}\n\nstruct Frame\n{\n  float time;\n  vec4 formants;\n};\n  \nvec2 mainSound( in int smp,float time)\n{    \n    float sp = 1.4; // speed\n    float t = mod(time, sp);\n    float pitch = 250.0 + sin(time * 1.6) * 10.; // fundamental freq\n   \n    Frame frames[63];\n    frames[ 0] = Frame(0.046, vec4(2358.,2820.0,3844.0,4854.0));\n    frames[ 1] = Frame(0.055, vec4(2246.,2846.0,3964.0,4898.0));\n    frames[ 2] = Frame(0.064, vec4(2202.,2628.0,3786.0,4482.0));\n    frames[ 3] = Frame(0.073, vec4(1969.,2568.0,3815.0,4668.0));\n    frames[ 4] = Frame(0.082, vec4(1944.,2499.0,3620.0,4708.0));\n    frames[ 5] = Frame(0.091, vec4(2046.,2537.0,3420.0,4696.0));\n    frames[ 6] = Frame(0.100, vec4(2449.,2700.0,3883.0,4773.0));\n    frames[ 7] = Frame(0.109, vec4(2185.,2636.0,3839.0,4846.0));\n    frames[ 8] = Frame(0.118, vec4(2025.,2672.0,3585.0,4685.0));\n    frames[ 9] = Frame(0.127, vec4(2259.,2705.0,3193.0,4501.0));\n    frames[10] = Frame(0.136, vec4(2251.,2628.0,3488.0,4610.0));\n    frames[11] = Frame(0.154, vec4(2110.,2680.0,3322.0,4603.0));\n    frames[12] = Frame(0.163, vec4( 714.,2168.0,2987.0,4354.0));\n    frames[13] = Frame(0.172, vec4( 678.,2048.0,2877.0,3544.0));\n    frames[14] = Frame(0.181, vec4( 664.,1965.0,2510.0,3473.0));\n    frames[15] = Frame(0.199, vec4( 659.,1867.0,2450.0,3474.0));\n    frames[16] = Frame(0.244, vec4( 596.,1836.0,2482.0,3419.0));\n    frames[17] = Frame(0.271, vec4( 491.,1992.0,2579.0,3438.0));\n    frames[18] = Frame(0.280, vec4( 451.,2059.0,2622.0,3446.0));\n    frames[19] = Frame(0.334, vec4( 341.,2114.0,2739.0,3505.0));\n    frames[20] = Frame(0.343, vec4( 327.,2096.0,2799.0,3561.0));\n    frames[21] = Frame(0.352, vec4( 265.,1876.0,2904.0,3706.0));\n    frames[22] = Frame(0.361, vec4( 263.,1681.0,2969.0,3937.0));\n    frames[23] = Frame(0.388, vec4( 254.,1828.0,3149.0,4153.0));\n    frames[24] = Frame(0.397, vec4( 290.,1859.0,3234.0,4100.0));\n    frames[25] = Frame(0.406, vec4( 320.,1867.0,3106.0,4013.0));\n    frames[26] = Frame(0.415, vec4( 340.,1823.0,3044.0,4028.0));\n    frames[27] = Frame(0.424, vec4( 365.,1626.0,2994.0,3937.0));\n    frames[28] = Frame(0.433, vec4( 467.,1586.0,2767.0,3420.0));\n    frames[29] = Frame(0.442, vec4( 480.,1548.0,2570.0,3364.0));\n    frames[30] = Frame(0.451, vec4( 497.,1509.0,2462.0,3307.0));\n    frames[31] = Frame(0.559, vec4( 565.,1456.0,2508.0,3433.0));\n    frames[32] = Frame(0.568, vec4( 614.,1484.0,2705.0,3569.0));\n    frames[33] = Frame(0.577, vec4( 614.,1488.0,2511.0,3517.0));\n    frames[34] = Frame(0.586, vec4( 800.,1459.0,2786.0,5437.0));\n    frames[35] = Frame(0.604, vec4(1267.,2153.0,3075.0,4030.0));\n    frames[36] = Frame(0.613, vec4(1458.,2456.0,3438.0,4313.0));\n    frames[37] = Frame(0.622, vec4(1319.,2342.0,3386.0,4337.0));\n    frames[38] = Frame(0.631, vec4(1181.,2238.0,3311.0,4216.0));\n    frames[39] = Frame(0.640, vec4(1151.,2229.0,3417.0,4407.0));\n    frames[40] = Frame(0.649, vec4(1089.,2217.0,3435.0,4328.0));\n    frames[41] = Frame(0.658, vec4(1010.,2418.0,3451.0,3979.0));\n    frames[42] = Frame(0.667, vec4(1183.,2601.0,3922.0,4878.0));\n    frames[43] = Frame(0.676, vec4(1271.,2505.0,2803.0,3966.0));\n    frames[44] = Frame(0.685, vec4( 739.,2109.0,3046.0,3919.0));\n    frames[45] = Frame(0.694, vec4( 708.,1298.0,2695.0,3944.0));\n    frames[46] = Frame(0.703, vec4( 491., 883.0,2741.0,3620.0));\n    frames[47] = Frame(0.712, vec4( 585., 941.0,2721.0,3140.0));\n    frames[48] = Frame(0.757, vec4( 708.,2723.0,3042.0,3951.0));\n    frames[49] = Frame(0.766, vec4( 242., 714.0,2712.0,3053.0));\n    frames[50] = Frame(0.775, vec4( 518., 718.0,2705.0,3051.0));\n    frames[51] = Frame(0.793, vec4( 593., 771.0,2674.0,3059.0));\n    frames[52] = Frame(0.829, vec4( 522., 822.0,2620.0,3074.0));\n    frames[53] = Frame(0.838, vec4( 567., 880.0,2596.0,3079.0));\n    frames[54] = Frame(0.847, vec4( 541., 975.0,2532.0,3091.0));\n    frames[55] = Frame(0.856, vec4( 540.,1044.0,2484.0,3108.0));\n    frames[56] = Frame(0.874, vec4( 519.,1167.0,2403.0,3142.0));\n    frames[57] = Frame(0.892, vec4( 492.,1309.0,2312.0,3160.0));\n    frames[58] = Frame(0.910, vec4( 476.,1467.0,2239.0,3180.0));\n    frames[59] = Frame(0.928, vec4( 438.,1720.0,2226.0,3229.0));\n    frames[60] = Frame(0.946, vec4( 406.,1920.0,2250.0,3307.0));\n    frames[61] = Frame(0.982, vec4( 350.,1973.0,2374.0,3390.0));\n    frames[62] = Frame(1.000, vec4( 322.,2031.0,2474.0,3430.0));\n\n    float samp = 0.0;\n    \n    Frame v,w;\n    vec4 n = frames[0].formants;\n    vec4 k;\n    for(int i=1;i<62;i++)\n    {\n        float nt = frames[i+1].time;\n        float pt = frames[i-1].time;\n        if(t > frames[i].time * sp)\n        {\n            k = frames[i].formants;\n            samp = getSample(pitch,k,t);\n            n = k;\n        }\n    }\n\n    #define a(tm,amp) if(t>tm*sp) intensity=amp;\n    // adjust overall intensity curve\n    float intensity;        \n    a( .000, .3); \n    a( .040, .9); \n    a( .358, .1);\n    a( .403, .9); \n    a( .572, .1); \n    a( .633, .9);\n    \n    samp *= intensity;\n    \n    return vec2( samp );\n}","name":"Sound","description":"","type":"sound"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":true,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"XdXXWl","date":"1408113078","viewed":739,"name":"Formant Synthesis","username":"WouterVanNifterick","description":"It says \"ShaderToy\" :) Very basic version. To make it sound better, it still needs a correctly synced phase, filtered consonants, and a parametrized bandwidth, skirt and level per formant. ","likes":27,"published":1,"flags":8,"usePreview":0,"tags":["audio","speech","formant","formants","voice","vocal"],"hasliked":0,"parentid":"","parentname":""}}