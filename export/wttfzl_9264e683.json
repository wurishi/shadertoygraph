{"ver":"0.1","info":{"id":"wttfzl","date":"1613336474","viewed":60,"name":"[RGR] Ray marching 2D","username":"deeplo","description":"ray marching","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define S             smoothstep\n\n#define EPSILON 0.0001\n\n#define BG_COLOR      vec3(0.01,0.01,0.01)\n\n#define MAX_DISTANCE  100000.0\n#define MAX_RM_STEPS  512\n#define MIN_DISTANCE  0.00001\n\n#define SPHERE_CENTER1 vec2(0.66,-0.33)\n#define SPHERE_CENTER2 vec2(-0.66,-0.66)\n#define SPHERE_CENTER3 vec2(-0.15,0.5)\n#define SPHERE_RADIUS1 0.050\n#define SPHERE_RADIUS2 0.250\n#define SPHERE_RADIUS3 0.125\n\n#define BOX_CENTER  vec2(0,-0.2)\n#define BOX_SIZE    vec2(0.3,0.1)\n#define BOX_ANGLE   3.14159/4.0\n#define BOX_CENTER2 vec2(0.35,0.33)\n#define BOX_SIZE2   vec2(0.1,0.4)\n#define BOX_ANGLE2  -3.15159/10.0\n\n#define LIGHT_POWER 2.0\n\nmat2 Rot(float a){\n    float c = cos(a);\n    float s = sin(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat GetDistSphere(vec2 position, vec2 center, float radius){\n    // Init distance\n    float d = MAX_DISTANCE;\n    // Set origin on the sphere center\n    position -= center;\n    // compute length\n    d = length(position) - radius;\n    // Return distance\n    return d;\n}\n\nfloat GetDistAABB(vec2 position, vec2 center, vec2 size, float angle){\n    // Init distance\n    float d = MAX_DISTANCE;\n    // Set origin on the box center\n    position -= center;\n    // CHange origin according to box angle\n    position *= Rot(angle);\n    // compute length\n    d = length(max(abs(position)-size,vec2(0)));\n    // Return distance\n    return d;\n}\n\nfloat RayMarching(vec2 rayOrigin, vec2 rayDirection){\n    // Init distance\n    float marchDist = 0.0;\n    float dMin = MAX_DISTANCE;\n    // Ray Marching Loop\n    for(int i=0; i<MAX_RM_STEPS && dMin>MIN_DISTANCE && marchDist<MAX_DISTANCE;i++){\n        // Set the next marching point (origin + direction * distance)\n        vec2 p = rayOrigin + rayDirection * marchDist;        \n        // Get minimum distance to spheres, from the computed position\n        float dMin1 = GetDistSphere(p, SPHERE_CENTER1, SPHERE_RADIUS1);\n        float dMin2 = GetDistSphere(p, SPHERE_CENTER2, SPHERE_RADIUS2);\n        float dMin3 = GetDistSphere(p, SPHERE_CENTER3, SPHERE_RADIUS3);\n        // Get minimum distance to box\n        float dMin4 = GetDistAABB(p, BOX_CENTER, BOX_SIZE, BOX_ANGLE);\n        float dMin5 = GetDistAABB(p, BOX_CENTER2, BOX_SIZE2, BOX_ANGLE2);\n        // get minimum from all the minimum\n        dMin = dMin1;\n        dMin = min(dMin,dMin2);\n        dMin = min(dMin,dMin3);\n        dMin = min(dMin,dMin4);\n        dMin = min(dMin,dMin5);\n        // Increase total distance\n        dMin *= 0.5;\n        marchDist += dMin;\n    }\n    // Return distance\n    return marchDist;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Get coords normallized according to Y resolution. Screen displays uv between -1/+1  \n    vec2 uv = (2.0*fragCoord/iResolution.xy)-1.0;\n\n    // Background color\n    vec3 bg = BG_COLOR*uv.x;\n    vec4 col = vec4(bg,1.0);\n\n    // Ray origin (mouse position)\n    vec2 M = iMouse.xy;\n    bool autoAnim = (M == vec2(0));\n    // Normalize mouse position\n    M = (2.0*M/iResolution.xy)-1.0;\n    \n    // Auto anim\n    if(autoAnim){\n        M  = vec2(0.55*cos(iTime),0.8*sin(iTime));\n        M += vec2(0.10,0.1);\n    }\n    vec2 rayOrigin = M;\n\n    // Ray direction\n    vec2 rayDirection = uv-rayOrigin;\n    float fading = length(rayDirection);\n    fading  = S(LIGHT_POWER,0.0,fading);\n    fading *= fading;\n\n    // Ray marching mask\n    float marchDist = RayMarching(rayOrigin,rayDirection);\n    float c = S(1.0-EPSILON,1.0,marchDist);\n\n    // distance mask\n    float K = -(c-S(-0.5,0.5,length(rayDirection)*0.5));\n    K = 1.0-S(0.15,1.0,K);\n    c = K;\n\n    // Light color\n    vec3 lightColor = vec3(abs(sin(iTime*0.1287))*0.5+0.5,\n                           abs(sin(iTime*0.5687))*0.5+0.5,\n                           abs(sin(iTime*0.3154))*0.5+0.5);\n    col.rgb += lightColor*c*fading;\n\n    // Draw Sphere obstacles\n    float d0 = length(uv-SPHERE_CENTER1);\n    float cS = S(SPHERE_RADIUS1+EPSILON, SPHERE_RADIUS1, d0);\n    d0 = length(uv-SPHERE_CENTER2);\n    cS += S(SPHERE_RADIUS2+EPSILON, SPHERE_RADIUS2, d0);\n    d0 = length(uv-SPHERE_CENTER3);\n    cS += S(SPHERE_RADIUS3+EPSILON, SPHERE_RADIUS3, d0);    \n    // Draw Box obstacles\n    d0 = length(max(abs((uv-BOX_CENTER)*Rot(BOX_ANGLE))-BOX_SIZE,vec2(0)));\n    cS += S(EPSILON, 0.0, d0);\n    d0 = length(max(abs((uv-BOX_CENTER2)*Rot(BOX_ANGLE2))-BOX_SIZE2,vec2(0)));\n    cS += S(EPSILON, 0.0, d0);\n    \n    cS *= c*fading;\n    col.rgb += vec3(cS);    \n\n    // Draw mouse pointer\n    float lightDist  = length(uv-M);\n    float lightAlpha = S(0.05,-0.001,lightDist); \n    col.rgb += lightColor * vec3(lightAlpha);\n\n    // Output\n    fragColor = col;    \n}\n\n","name":"Image","description":"","type":"image"}]}