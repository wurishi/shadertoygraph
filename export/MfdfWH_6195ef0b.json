{"ver":"0.1","info":{"id":"MfdfWH","date":"1733064302","viewed":87,"name":"My First Pathtracing #うろうろシェーダー","username":"SainaKey","description":"My First Pathtracing","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["pathtracing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//ref:https://www.docswell.com/s/toutou/5J48NV-2024-11-17-155608#p1\n\n#define SAMPLES 64\n#define MAXDEPTH 4\n\n#define PI 3.14159265359\n#define DIFF 0\n#define SPEC 1\n#define NUM_SPHERES 9\n\nvec3 seedVec3 = vec3(0.);\n\n#define C_HASH 0x11451919u\n\nvec3 hash33(vec3 p){\n  uvec3 x = floatBitsToUint(p);\n  x = C_HASH * ((x << 8u)^x.yzx);\n  x = C_HASH * ((x << 8u)^x.yzx);\n  x = C_HASH * ((x << 8u)^x.yzx);\n  return vec3(x) / float(-1u);\n}\n\nvec3 random3(){\n  seedVec3 = hash33(seedVec3);\n  return seedVec3;\n}\n\nstruct Ray {vec3 o, d;};\n\n//Modeling Scene\nstruct Sphere{\n  float r;\n  vec3 p,e,c;\n  int refl;\n  };\n  \n\nSphere spheres[NUM_SPHERES];\nvoid initSpheres() {\n  vec2 uv = vec2(gl_FragCoord.x / iResolution.x, gl_FragCoord.y / iResolution.y);\n\tuv -= 0.5;\n\tuv /= vec2(iResolution.y / iResolution.x, 1);\n\n  spheres[0] = Sphere(1e5, vec3(-1e5+1.,40.8,81.6), vec3(0.), vec3(.75,.25,.25), DIFF);//left red wall\n  spheres[1] = Sphere(1e5, vec3(1e5+99.,40.8,81.6), vec3(0.), vec3(.25,.25,.75), DIFF);//right blue wall\n  spheres[2] = Sphere(1e5, vec3(50., 40.8, -1e5),\t\t  vec3(0.),  vec3(.75,.75,.75), DIFF);//back white wall\n  spheres[3] = Sphere(1e5, vec3(100000., 40.8,  1e5+150.),vec3(0.),  vec3(.75), DIFF); // front white wall \n  spheres[4] = Sphere(1e5, vec3(50., -1e5, 81.6),\t\t  vec3(0.),  vec3(1.), SPEC);  // cyan floor \n  spheres[5] = Sphere(1e5, vec3(50.,  1e5+81.6, 81.6),vec3(0.),  vec3(.75,.75,.25), DIFF); // yellow ceiling\n  spheres[6] = Sphere(16.5, vec3(27 , 36.5 , 60. + tan(iTime) * 10. ), \t  vec3(0.),  vec3(1.), SPEC); // left ball\n  spheres[7] = Sphere(16.5, vec3(73., 16.5, 78. ), \t  vec3(0.),  vec3(.1 , .4, .9), DIFF); // right ball\n  spheres[8] = Sphere(600., vec3(50. + cos(iTime)*20., 681.03, 81.6 + sin(iTime)*30.),\tvec3(17.), vec3(0.), DIFF); // ceiling light\n  }\n    \n//Collision detection\nfloat intersect(Sphere s, Ray r){\n  vec3 op = s.p - r.o;\n  float epsilon = 1e-3;\n  float t1 = dot(op,r.d);\n  float det = t1 * t1 - dot(op,op) + s.r * s.r;\n  if(det < 0.){\n    return 0.;\n    }\n    else{\n      det = sqrt(det);\n      }\n      \n  return (t1 = t1 -det) > epsilon ? t1 : 0.;\n  }\n  \nint intersect(Ray r,out float t,out Sphere s,int avoid){\n  int id = -1;\n  t = 1e5;\n  s = spheres[0];\n  for(int i=0; i< NUM_SPHERES; ++i){\n    Sphere S = spheres[i];\n    float d = intersect(S,r);\n    if(i!=avoid && d!=0. && d<t) {t = d; id = i; s=S;}\n    }\n    return id;\n  }\n      \n\nvec3 jitter(vec3 n, float r1 , float r2){\n  vec3 ez = normalize(n);\n  vec3 ex = normalize(cross(ez.yzx,ez));\n  vec3 ey = normalize(cross(ez,ex));\n  float u = sqrt(r2) * cos(2.*PI * r1);\n  float v = sqrt(r2) * sin(2.*PI * r1);\n  float w = sqrt(1.-r2);\n  return u*ex + v*ey + w*ez;\n  }\n\n//Rendering Equation\nvec3 radiance(Ray r){\n  vec3 acc = vec3(0.);\n  vec3 mask = vec3(1.);\n  int id = -1;\n  for(int depth = 0; depth < MAXDEPTH; ++depth){\n    float t;\n    Sphere obj;\n    if((id = intersect(r,t,obj,id)) < 0) break;\n    vec3 x = t * r.d + r.o;\n    vec3 n = normalize(x - obj.p);\n    \n    if(obj.refl == DIFF){\n      vec3 d;\n      d = jitter(n,random3().x,random3().x);\n      acc += mask * obj.e;\n      mask *= obj.c/PI;\n      r = Ray(x,d);\n      }else if(obj.refl == SPEC){\n        acc += mask * obj.e;\n        mask *= obj.c;\n        r = Ray(x,reflect(r.d,n));\n        }\n    }\n    return acc;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  \n  initSpheres();\n  \n  vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n\tuv -= 0.5;\n\tuv /= vec2(iResolution.y / iResolution.x, 1);\n\n  \n  vec3 camPos = vec3(50.+sin(iTime)*30.0,50.+(cos(iTime))*30.,320.-exp(sin(iTime))*30.0 );\n  vec3 cz = normalize(vec3(50.,50.,100.) - camPos);\n  vec3 cx = vec3(0,1,0);\n  vec3 cy = normalize(cross(cx,cz));\n  cy = vec3(0,1,0);\n  cx = cross(cz,cy);\n  vec3 rayDir;\n  rayDir= (uv.x * cx + uv.y * cy) + cz;\n  \n  seedVec3 = vec3(fragCoord.xy,iTime);\n  vec3 color = vec3(0);\n  for(int i=0; i<SAMPLES; ++i)\n  {\n    color += radiance(Ray(camPos,normalize(rayDir)));\n  }\n  \n  vec4 accum = texture(iChannel0,fragCoord.xy / iResolution.xy);\n  float samples = accum.a + float(SAMPLES);\n  color = (accum.rgb * accum.a + color)/samples;\n  \n  color = pow(color,vec3(0.4545));//gammma correction\n  \n  fragColor = vec4(color,samples);\n}","name":"Image","description":"","type":"image"}]}