{"ver":"0.1","info":{"id":"MsVXzK","date":"1466020370","viewed":2173,"name":"Tunnel with lamps","username":"TambakoJaguar","description":"I had quite much fun with this one. I tried to work with new stuff. The volumic sampling of the fog on the water wasn't that bad, but the geometry of the tunnel was quite tiring, because I didn't know how to map a parametric curve, so I used a cheap trick","likes":49,"published":1,"flags":0,"usePreview":1,"tags":["tunnel","refraction","water","fog","tube","speed","volumic","lamps","travel"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n\"Tunnel with lamps\" by Emmanuel Keller aka Tambako - June 2016\nLicense Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\nContact: tamby@tambako.ch\n*/\n\n#define pi 3.14159265359\n\n// Switches, you can play with them!\n#define specular\n#define reflections\n//#define antialias\n\n#define show_water\n//#define debug_water\n#define show_lamps\n#define lamps_blink\n#define dirty_tube\n#define show_fog\n\n// Lamp structure\nstruct Lamp\n{\n  \tvec3 position;\n  \tvec3 color;\n  \tfloat intensity;\n  \tfloat attenuation;\n};\n    \n// Directional lamp structure\nstruct DirLamp\n{\n  vec3 direction;\n  vec3 color;\n  float intensity;\n};\n\nstruct RenderData\n{\n  \tvec3 col;\n  \tvec3 pos;\n  \tvec3 norm;\n  \tint objnr;\n};\n    \nstruct TransMat\n{\n    vec3 col_vol;\n    vec3 col_dif;\n    vec3 col_fil;\n    vec3 col_dev;\n    float specint;\n    float specshin;\n    float ior;\n};\n    \n// Every object of the scene has its ID\n#define TUNNEL_OBJ     1\n#define WATER_OBJ      2\n#define LAMPS_OBJ      3\n\nDirLamp lamps[4];\n\n// Campera options\nvec3 campos = vec3(0., 0., 0.);\nvec3 camtarget = vec3(0., 0., 0.);\nvec3 camdir = vec3(0., 0., -1.);\nconst float camSpeed = 2.7;\nconst float camPosY = 0.04;\nfloat fov = 2.8;\n\n// Ambient light\nconst vec3 ambientColor = vec3(0.3);\nconst float ambientint = 0.2;\n\n// Color options\nconst vec3 tunnelColor = vec3(0.9, 0.6, 0.28);\nconst vec3 tunnelColor2 = vec3(0.26, 0.42, 0.28);\nconst vec3 lampColor = vec3(1., 0.9, 0.4);\n\n// Shading options\nconst float specint = 0.8;\nconst float specshin  = 125.;\nconst float aoint = 0.4;\n\n// Tracing options\nconst float normdelta = 0.001;\nconst float maxdist = 280.;\n\n// Antialias. Change from 1 to 2 or more AT YOUR OWN RISK! It may CRASH your browser while compiling!\nconst float aawidth = 0.8;\nconst int aasamples = 2;\n\n// Tunnel options\nconst float tubeRadius = 0.22;\nconst float dz = 0.01;\nconst float tsf = 4.5;\nconst float ltr0 = 0.9;\n\n// Water options\nconst float waterLevel = 0.22;\nconst float wavesLev = 0.004;\nconst float wavesFreq = 18.;\n\n// Fog options\nconst float fogDens0 = 5.5;\nconst vec3 fogColor0 = vec3(0.6, 0.62, 0.67);\nconst vec3 fogColorT = vec3(1.12, 0.51, 1.37);\nconst float fogFreq = 15.;\n\nfloat aaIndex = 0.;\nbool traceWater = true;\nTransMat waterMat;\n\n// X (left-right) Deviation of the tunnel curve in function of Z\nfloat tunnel_curve(float z)\n{\n    float fz = 0.4;\n    float c1 = 0.5*sin(z*0.1*fz) + 0.3*sin(z*0.18*fz) + 0.2*sin(z*0.47*fz);\n    float c2 = 4.*(smoothstep(0.1, 1.0, c1) - smoothstep(-0.1, -1., c1));\n    return c2;\n}\n\n// Y (height) Deviation of the tunnel curve in function of Z\nfloat tunnel_curve_y(float z)\n{\n    float fz = 0.2;\n    float c1 = 0.7*sin(z*0.114*fz) + 0.3*sin(z*0.144*fz);\n    float c2 = 0.25*smoothstep(0.8, 1.0, c1) - 0.78*smoothstep(-0.844, -0.944, c1);\n    return c2;\n}\n\n// Derivate of the X tunnel curve\nfloat dev_tunnel_curve(float z)\n{\n    float v1 = tunnel_curve(z - dz*0.5); \n    float v2 = tunnel_curve(z + dz*0.5);\n    return (v2-v1)/dz;\n}\n\nvoid init()\n{\n    lamps[0] = DirLamp(vec3(-2., 1., -5.), vec3(0.4, 0.5, 1.), 1.2);   // Blue ambient 1\n    lamps[1] = DirLamp(vec3(0., -3., 0.), vec3(0.5, 0.57, 1.), 1.);  // Blue ambient 2\n    lamps[2] = DirLamp(vec3(2., -1., 5.), vec3(1., 0.85, 0.75), 0.8);  // Left lamps\n    lamps[3] = DirLamp(vec3(2., -1., 5.), vec3(1., 0.85, 0.75), 0.8);  // Right lamps\n\n    waterMat = TransMat(vec3(0.92, 0.94, 0.95),\n                        vec3(0.01, 0.02, 0.02),\n                        vec3(1.),\n                        vec3(0.2, 0.3, 0.8),\n                        0.4,\n                        45.,\n                        1.32);\n    \n   \tvec2 iMouse2;\n   \tif (iMouse.x==0. && iMouse.y==0.)\n      \tiMouse2 = vec2(0.5, 0.5);\n   \telse\n      \tiMouse2 = iMouse.xy/iResolution.xy; \n    \n    const float cdz = 1.;\n    float cz = iTime*camSpeed;\n    float tc = tunnel_curve(cz - cdz);\n    float tc2 = tunnel_curve(cz + cdz);\n    float tcy = tunnel_curve_y(cz - cdz);\n    float tcy2 = tunnel_curve_y(cz + cdz);\n    campos = vec3(tc, tcy + camPosY, cz - cdz);\n    camtarget = vec3(tc2 + (iMouse2.x - 0.5), tcy2 + (iMouse2.y - 0.5), cz + cdz);\n    camdir = camtarget - campos;\n}\n\n// Union operation from iq\nvec2 opU(vec2 d1, vec2 d2)\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nvec2 rotateVec(vec2 vect, float angle)\n{\n    vec2 rv;\n    rv.x = vect.x*cos(angle) - vect.y*sin(angle);\n    rv.y = vect.x*sin(angle) + vect.y*cos(angle);\n    return rv;\n}\n\n// 1D hash function\nfloat hash(float n)\n{\n    return fract(sin(n)*753.5453123);\n}\n\n// From https://www.shadertoy.com/view/4sfGzS\nfloat noise(vec3 x)\n{\n    //x.x = mod(x.x, 0.4);\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    float n = p.x + p.y*157.0 + 113.0*p.z;\n    return mix(mix(mix(hash(n +   0.0), hash(n +   1.0),f.x),\n                   mix(hash(n + 157.0), hash(n + 158.0),f.x),f.y),\n               mix(mix(hash(n + 113.0), hash(n + 114.0),f.x),\n                   mix(hash(n + 270.0), hash(n + 271.0),f.x),f.y),f.z);\n}\n\n// This function knows when the water in the tunnel is toxic...\nfloat getToxicZone(vec3 pos)\n{\n\treturn smoothstep(87., 102., mod(pos.z, 400.))*smoothstep(155., 135., mod(pos.z, 400.));\n}\n\n// Mapping function of the tunnel\nfloat map_tunnel(vec3 pos)\n{\n    float tc = tunnel_curve(pos.z);\n    float dc = dev_tunnel_curve(pos.z);\n    pos.x-= tc;\n    float zz = pos.z;\n    pos.z = 0.;\n    float a = atan(dc);\n    pos.xz = rotateVec (pos.xz, a*0.5);\n    pos.z = zz;\n    \n    pos.y-= tunnel_curve_y(pos.z);\n    \n    float tdf = (1. + 0.00007/(1.0011 + cos(tsf*pos.z)));\n    float df = -length(pos.xy) + tubeRadius*tdf;\n    //df = max(df, pos.y);\n\n    return df;\n}\n\nfloat ltr = ltr0;\nvec3 lmppos = vec3(0.);\n// Mapping function of the lamps\nfloat map_lamps(vec3 pos)\n{\n    float tc = tunnel_curve(pos.z);\n    float dc = dev_tunnel_curve(pos.z);\n    pos.x-= tc;\n    float zz = pos.z;\n    pos.z = 0.;\n    float a = atan(dc);\n    pos.xz = rotateVec (pos.xz, a);\n    pos.z = zz;\n    \n    pos.y-= tunnel_curve_y(pos.z);\n    lmppos = pos;\n    a = atan(pos.x, pos.y);\n    float tsf2 = tsf/(2.*pi);\n    pos.z+= tsf2;\n    ltr = 0.9;\n    ltr+= 2.*(1. - smoothstep(0.6, 0.65, a)*smoothstep(0.95, 0.9, a))*\n         (1. - smoothstep(-0.6, -0.65, a)*smoothstep(-0.95, -0.9, a));\n    \n    ltr+= 0.3*(1. - smoothstep(0.42, 0.58, abs(pos.z - floor(pos.z*tsf2 + 0.5)/tsf2)));\n    float df = -length(pos.xy) + tubeRadius*ltr;\n    return df;\n}\n\n// Mapping function of the water\nfloat map_water(vec3 pos)\n{\n    float h = (pos.y/tubeRadius + 1.)/2.;\n    h+= wavesLev*(noise(pos*wavesFreq + iTime*vec3(0., 0.7, 0.3)) - 0.5);\n    return h - waterLevel;   \n}\n\n// Main mapping function\nvec2 map(vec3 pos)\n{\n    float tunnel = map_tunnel(pos);\n    vec2 res = vec2(tunnel, TUNNEL_OBJ);\n    #ifdef show_water\n    float water = map_water(pos);\n    if (traceWater)\n       res = opU(res, vec2(water, WATER_OBJ));\n    #endif\n    float lamps = map_lamps(pos);\n    #ifdef show_lamps\n    res = opU(res, vec2(lamps, LAMPS_OBJ));\n    #endif\n\n    return res;\n}\n\n// Main tracing function\nvec2 trace(vec3 cam, vec3 ray, float maxdist) \n{\n    float t = traceWater?0.01:0.17;\n    float objnr = 0.;\n    vec3 pos;\n    float dist;\n    float dist2;\n    \n  \tfor (int i = 0; i < 85; ++i)\n    {\n    \tpos = ray*t + cam;\n        vec2 res = map(pos);\n        dist = res.x;\n        if (dist>maxdist || abs(dist)<0.001)\n            break;\n        t+= dist*(1. - 0.0018*float(i));\n        objnr = abs(res.y);\n  \t}\n  \treturn vec2(t, objnr);\n}\n\n// From https://www.shadertoy.com/view/MstGDM\n// Here the texture maping is only used for the normal, not the raymarching, so it's a kind of bump mapping. Much faster\nvec3 getNormal(vec3 pos, float e)\n{  \n    vec2 q = vec2(0, e);\n    return normalize(vec3(map(pos + q.yxx).x - map(pos - q.yxx).x,\n                          map(pos + q.xyx).x - map(pos - q.xyx).x,\n                          map(pos + q.xxy).x - map(pos - q.xxy).x));\n}\n\n// Gets the position of left or right lamp in function of the position (depending on the current section)\nvec3 getLampPos(vec3 pos, bool left)\n{\n    vec3 lpos;\n    float tsf2 = tsf/(2.*pi);\n    lpos.z = floor(pos.z*tsf2 + 0.5)/tsf2;\n    lpos.y = 0.7*tubeRadius + tunnel_curve_y(pos.z);\n    float tc = tunnel_curve(pos.z);\n    if (left)\n        lpos.x = tc + 0.5*tubeRadius;\n    else\n        lpos.x = tc - 0.5*tubeRadius;\n    \n    return lpos;\n}\n\n// Gets how a lamp blinks in fimctopm of the time\nfloat getLampBlink(float t, float th)\n{\n    float lb = 0.3*sin(t*5.86) + 0.25*sin(t*8.57) + 0.25*sin(t*17.54) + 0.2*sin(t*21.62);\n    return smoothstep(th+0.02, th, lb);\n}\n\n// Gets how a lamp blinks in fimctopm of the time and its index and the current position\nfloat getLampBlink2(float t, float lnr, vec3 pos)\n{\n    float lb = 1.;\n    float h = hash(lnr);\n    float tz = getToxicZone(pos);\n    if (h>0.96 - tz)\n    {\n      \tif (hash(lnr*8.54)>0.8)\n            lb = 0.;\n        else\n        \tlb = getLampBlink(t + lnr*5., -0.1 + 0.4*hash(lnr*43.5));\n    }\n    if (h>1.37 - tz)\n        lb = 0.;\n    return lb;\n}\n\n// Gets the position of the \"dirtyness\" at the bottom of the tunnel\nfloat getTunnelHT(vec3 pos)\n{\n    float h = (pos.y/tubeRadius + 1.)/2.;\n    return smoothstep(waterLevel + 0.07, waterLevel + 0.03, h) - \n      0.19*smoothstep(waterLevel + 0.05, waterLevel - 0.01, h);\n}\n\n// Gets the color of the tunnel\nvec3 getTunnelColor(vec3 pos)\n{\n    #ifdef dirty_tube\n    pos+= 0.006*(noise(pos*45.) - 0.5);\n    return mix(tunnelColor, tunnelColor2, 0.65*getTunnelHT(pos)*(1. + 0.25*noise(pos*35.)));\n    #else\n    return tunnelColor;    \n    #endif    \n}\n\n// Gets the color of the water\nvec3 getWaterColor(vec3 pos)\n{\n    #ifdef debug_water\n    return waterMat.col_dev;\n    #else\n    return waterMat.col_dif;\n    #endif\n}\n\n// Gets the color of the lamps\nvec3 getLampsColor(vec3 pos)\n{\n    vec3 lamppos = getLampPos(pos, true);\n    float lnr = 15.*(2. + (abs(pos.x-lamppos.x)>0.1?1.:0.)) + lamppos.z/tsf;\n    float lb =  getLampBlink2(iTime, lnr, pos);\n    return mix(lampColor, vec3(0.22 + lb + 0.05*sin(pos.y*2100.)), smoothstep(ltr0*1.05, ltr0, ltr));\n}\n\n// Combines the colors\nvec3 getColor(vec3 norm, vec3 pos, int objnr, vec3 ray)\n{\n   return objnr==TUNNEL_OBJ?getTunnelColor(pos):\n         (objnr==LAMPS_OBJ?getLampsColor(pos):\n         (objnr==WATER_OBJ?getWaterColor(pos):vec3(0.)));\n}\n\n#ifdef show_fog\n// Repartition of the fog in function of the position\nfloat getFogDensity(vec3 pos)\n{\n    float h = (pos.y/tubeRadius + 1.)/2.;\n    float dens = smoothstep(waterLevel + 0.04, waterLevel + 0.06, h)*\n                 smoothstep(waterLevel + 0.3 + 0.2*pow(noise(pos*0.6), 3.), waterLevel + 0.1, h);\n    dens*= clamp(0.15*noise(pos*0.8) + 1.65*noise(pos*fogFreq + iTime*vec3(0.04, 0.23, -0.14)) - 0.3, 0., 1.);\n    return dens;\n}\n\n// Color of the fog in function of the position\nvec3 getFogColor(vec3 pos)\n{\n    vec3 lampposl = getLampPos(pos, false);\n    vec3 lampposr = getLampPos(pos, true);\n    \n    float lnrl = 45. + lampposl.z/tsf;\n    float lbl = getLampBlink2(iTime, lnrl, pos);\n    float lnrr = 30. + lampposr.z/tsf;\n    float lbr = getLampBlink2(iTime, lnrr, pos);\n    \n    float lfl = lbl*0.17/pow(0.33 + distance(lampposl, pos), 2.);\n    float lfr = lbr*0.17/pow(0.33 + distance(lampposr, pos), 2.);\n    float lf = 0.9 + lfl + lfr;\n    \n    vec3 fogColor = fogColor0;\n    //float h = (pos.y/tubeRadius + 1.)/2.;\n    //vec3 fogColor = mix(fogColor0, vec3(1.2, 0., 0.), smoothstep(waterLevel + 0.14, waterLevel + 0.16, h));\n    \n    return lf*mix(fogColor, fogColorT, clamp(1.1*getToxicZone(pos) - 0.1, 0., 1.)); \n}\n\n// Gets the fog density and color along the ray\nvec4 getFogDensColor(vec3 campos, vec3 pos, float l0, float sl0, float lf, float jitter)\n{\n  \tvec3 currPos = campos;\n    vec3 ray = normalize(pos - campos);\n    float tl = distance(campos, pos);\n    if (tl<l0)\n        return vec4(0.);\n    float totl = l0;\n    float sl = sl0;\n    float totDens = 0.;\n    vec3 totCol = vec3(0.);\n    int i2 = 0;\n    for (int i = 0; i < 80; ++i)\n    {   \n        float j = i<20?sl0/sl*jitter*(hash(13.5*aaIndex + iTime + 54.3*float(i) + 65.3*currPos.x + 28.*currPos.y + 34.*currPos.z) - 0.5):0.;\n        totl+= sl*(1. + j);\n        currPos = campos + ray*totl;\n        float dens = getFogDensity(currPos)*pow(sl, 0.4);\n        totDens+= dens;\n        totCol+= getFogColor(currPos)*dens;\n        i2 = i;\n        if (totl>=tl)          \n            break;\n        sl*=lf;\n    }\n    float tz = getToxicZone(pos);\n    return vec4(totCol/(totDens+0.001), clamp(fogDens0*totDens*(1. - 0.12*tz)/float(i2), 0., 1.));\n}\n#endif\n\n// Combines the scene color with the fog\nvec3 combineFog(vec3 col, vec4 fogDensColor)\n{\n   return mix(col, fogDensColor.rgb, fogDensColor.a) + 0.34*fogDensColor.rgb*fogDensColor.a;\n}\n\n// Fresnel reflectance factor through Schlick's approximation: https://en.wikipedia.org/wiki/Schlick's_approximation\nfloat fresnel(vec3 ray, vec3 norm, float n2)\n{\n   float n1 = 1.; // air\n   float angle = acos(-dot(ray, norm));\n   float r0 = dot((n1 - n2)/(n1 + n2), (n1 - n2)/(n1 + n2));\n   float r = r0 + (1. - r0)*pow(1. - cos(angle), 5.);\n   return clamp(r, 0., 0.9);\n}\n\n// Shading of the objects pro lamp\nvec3 lampShading(DirLamp lamp, vec3 norm, vec3 pos, vec3 ocol, int objnr, int lampnr)\n{\n\tvec3 pl;\n    float li;\n    vec3 col;\n    \n    // Special shading for the lamps which are regularly attached in the tunnel\n    if (lampnr>1)\n    {\n        vec3 lamppos = getLampPos(pos, lampnr==2);\n        pl = normalize(lamppos - pos);\n        float lb;\n        float lnr = float(15*lampnr) + lamppos.z/tsf;\n        #ifdef lamps_blink\n        lb = getLampBlink2(iTime, lnr, pos);\n        #else\n        lb = 1.;\n        #endif\n\n        li = lb*lamp.intensity*(0.05 + 0.8/pow(0.7 + distance(lamppos*vec3(1., 1., .6), pos*vec3(1., 1., .6)), 2.));\n        \n        float a = atan(lmppos.x, lmppos.y);\n        if (lampnr==2)\n          \tli*= smoothstep(0.62, 0.35, a) + smoothstep(0.9, 1.15, a);\n        else\n          \tli*= smoothstep(-0.62, -0.35, a) + smoothstep(-0.9, -1.15, a);\n        // Diffuse shading\n        #ifdef show_lamps\n        col = ocol*lamp.color*mix(li*(clamp(dot(norm, pl), 0., 1.)), 1., smoothstep(ltr0*1.05, ltr0, ltr));\n        #else\n        col = ocol*lamp.color*li*(clamp(dot(norm, pl), 0., 1.));\n        #endif\n    }\n    else\n    {\n        pl = normalize(lamp.direction);\n        li = lamp.intensity;\n        float laf;\n        if (objnr==WATER_OBJ)\n            laf = mix(clamp(dot(norm, pl), 0., 1.), 1., getToxicZone(pos));\n        else\n            laf = clamp(dot(norm, pl), 0., 1.);\n        // Diffuse shading\n        vec3 lc = mix(lamp.color, vec3(0.6, 1., 0.8), getToxicZone(pos));\n        col = ocol*lc*li*laf;\n    }\n    \n    // Specular shading\n    #ifdef specular\n    float specint2 = specint*(1. - getTunnelHT(pos));\n    //if (dot(norm, lamp.direction) > 0.0)\n        col+= lamp.color*li*specint2*pow(max(0.0, dot(reflect(pl, norm), normalize(pos - campos))), specshin);\n    #endif\n    \n    return col;\n}\n\n// Shading of the objects over all lamps\nvec3 lampsShading(vec3 norm, vec3 pos, vec3 ocol, int objnr)\n{\n    vec3 col = vec3(0.);\n    for (int l=0; l<4; l++) // lamps.length()\n        col+= lampShading(lamps[l], norm, pos, ocol, objnr, l);\n    \n    return col;\n}\n\n// From https://www.shadertoy.com/view/lsSXzD, modified\nvec3 GetCameraRayDir(vec2 vWindow, vec3 vCameraDir, float fov)\n{\n\tvec3 vForward = normalize(vCameraDir);\n\tvec3 vRight = normalize(cross(vec3(0.0, 1.0, 0.0), vForward));\n\tvec3 vUp = normalize(cross(vForward, vRight));\n    \n\tvec3 vDir = normalize(vWindow.x * vRight + vWindow.y * vUp + vForward * fov);\n\n\treturn vDir;\n}\n\n// Tracing and rendering a ray\nRenderData trace0(vec3 tpos, vec3 ray, float maxdist)\n{\n    vec2 tr = trace(tpos, ray, maxdist);\n    float tx = tr.x;\n    int objnr = int(tr.y);\n    vec3 col;\n    vec3 pos = tpos + tx*ray;\n    vec3 norm;\n\n    if (tx<maxdist*0.95)\n    {\n        norm = getNormal(pos, normdelta);\n        col = getColor(norm, pos, objnr, ray);\n      \n        // Shading\n        col = ambientColor*ambientint + lampsShading(norm, pos, col, objnr);\n    }\n    else\n    {\n        col = vec3(0.);\n    }\n    return RenderData(col, pos, norm, objnr);\n}\n\n// Gets the turbidence of transparent material in function of the thickness and basic absorption color\nvec3 getGlassAbsColor(float dist, vec3 color)\n{\n    return pow(color, vec3(5. + pow(dist*25., 2.3)));\n}\n\n// Main render function with reflections and refractions\nvec4 render(vec2 fragCoord)\n{   \n  \tvec2 uv = fragCoord.xy / iResolution.xy; \n  \tuv = uv*2.0 - 1.0;\n  \tuv.x*= iResolution.x / iResolution.y;\n\n  \tvec3 ray0 = GetCameraRayDir(uv, camdir, fov);\n    vec3 ray = ray0;\n  \tRenderData traceinf = trace0(campos, ray, maxdist);\n  \tvec3 col = traceinf.col;\n    vec3 pos0 = traceinf.pos;\n    vec3 refray;\n    int oObjNr = traceinf.objnr;\n    vec3 pos;\n    \n    vec3 glassf = vec3(1.);\n\n    #ifndef debug_water\n    #ifdef reflections\n    if (traceinf.objnr==WATER_OBJ)\n    {\t\n        refray = reflect(ray, traceinf.norm);\n        RenderData traceinf_ref = trace0(traceinf.pos, refray, 20.);\n        float rf = 0.9*fresnel(ray, traceinf.norm, waterMat.ior);\n        glassf*= (1. - rf);\n        col = mix(col, traceinf_ref.col, rf);\n    }\n    #endif\n    if (traceinf.objnr==WATER_OBJ)\n    {\n        vec3 ray_r = refract(ray, traceinf.norm, 1./waterMat.ior);           \n        traceWater = false;\n        pos = traceinf.pos;\n        traceinf = trace0(pos, ray_r, 10.);   \n        traceWater = true;\n        glassf*= getGlassAbsColor(distance(pos, traceinf.pos), \n                                  mix(waterMat.col_vol, vec3(0.72, 1.05, 0.78), getToxicZone(pos)));\n        glassf*= waterMat.col_fil;\n\n        col+= clamp(traceinf.col*glassf, 0., 1.);\n    }\n    #endif\n    \n    // Combines the fog\n    #ifdef show_fog\n    vec4 fogDensColor = getFogDensColor(campos, pos0, 0.05, 0.008, 1.05, 1.1);\n    col = combineFog(col, fogDensColor);\n    #endif\n\n    return vec4(col, 1.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{   \n    init();\n    \n    // Antialiasing\n    #ifdef antialias\n    vec4 vs = vec4(0.);\n    aaIndex = 0.;\n    for (int j=0;j<aasamples ;j++)\n    {\n       float oy = float(j)*aawidth/max(float(aasamples-1), 1.);\n       for (int i=0;i<aasamples ;i++)\n       {\n          float ox = float(i)*aawidth/max(float(aasamples-1), 1.);\n          vs+= render(fragCoord + vec2(ox, oy));\n          aaIndex++;\n       }\n    }\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    fragColor = vs/vec4(aasamples*aasamples);\n    #else\n    fragColor = render(fragCoord);\n    #endif\n}","name":"Image","description":"","type":"image"}]}