{"ver":"0.1","info":{"id":"Xff3Wl","date":"1703706935","viewed":61,"name":"Weird ball but path traced","username":"FrederickAmpsUp","description":"Decided to path trace an SDF, just a little experiment.","likes":0,"published":1,"flags":32,"usePreview":0,"tags":["raytracing","dls"],"hasliked":0,"parentid":"4fXGWM","parentname":"DLS path tracing"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//#define SHOW_FIREFLIES\n\nvec4 de_firefly(sampler2D tex, vec2 uv) {\n    vec4 this_col = texture(tex, uv);\n    \n    vec4 surrounding_avg;\n    \n    vec2 t_size = vec2(textureSize(tex, 0));\n    surrounding_avg += texture(tex, uv + vec2(-1, 1)/t_size);\n    surrounding_avg += texture(tex, uv + vec2( 0, 1)/t_size);\n    surrounding_avg += texture(tex, uv + vec2( 1, 1)/t_size);\n    surrounding_avg += texture(tex, uv + vec2(-1, 0)/t_size);\n    surrounding_avg += texture(tex, uv + vec2( 1, 0)/t_size);\n    surrounding_avg += texture(tex, uv + vec2(-1,-1)/t_size);\n    surrounding_avg += texture(tex, uv + vec2( 0,-1)/t_size);\n    surrounding_avg += texture(tex, uv + vec2( 1,-1)/t_size);\n    surrounding_avg /= 8.0;\n    \n    float local_variance = texture(iChannel2, uv).x; // variance map\n    float outside_variance = length(surrounding_avg - this_col);\n#ifdef SHOW_FIREFLIES\n    return vec4(outside_variance - local_variance - 2.0);\n#endif\n    return mix(this_col, surrounding_avg, clamp(outside_variance - local_variance - 2.0, 0.0, 1.0));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    // Output to screen\n    vec4 col = de_firefly(iChannel1, uv);\n    //col = texture(iChannel1, uv);\n#ifndef SHOW_FIREFLIES\n    col.xyz = flim(col.xyz, 0.0);\n#endif\n    \n    fragColor = col;\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define N_BOUNCES 5\n#define N_SAMPLES  5 // Number of samples (at 50% variance)\n#define SAMPLE_VAR 0 // Variation in samplerate (in either direction)\n                     // This is set to 0 as, on my old GPU, it causes huge framerate drops.\n// Uncomment to disable Direct Light Sampling\n//#define NO_DLS\n\n#define PI 3.14159265\n\nstruct Material {\n    vec3    color;\n    vec3 emission;\n    \n    float roughness;\n};\n\nstruct Ray {\n    vec3    origin;\n    vec3 direction;\n};\n\nstruct HitInfo {\n    bool hit;\n    \n    vec3 position;\n    vec3   normal;\n    \n    float dst;\n    \n    Material mat;\n};\n#define MISS HitInfo(false, vec3(0), vec3(0), 0.0, Material(vec3(0), vec3(0), 0.0))\n\nfloat seed;\nfloat rand(vec2 co){\n    return fract(sin(dot(co*(seed+1.0), vec2(12.9898, 78.233))) * 43758.5453);\n}\nfloat rand(vec3 co) {\n    return sqrt(rand(co.xy)*rand(co.yz));\n}\n\nfloat hash( float n ) {\n    return fract(sin(n)*43758.5453);\n}\n\nfloat lerp(float a, float b, float k) { return mix(a,b,k); }\n\nfloat noise( vec3 x ) {\n    // The noise function returns a value in the range -1.0f -> 1.0f\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\n    f = f*f*(3.0-2.0*f);\n    float n = p.x + p.y*57.0 + 113.0*p.z;\n\n    return lerp(lerp(lerp( hash(n+0.0), hash(n+1.0),f.x),\n        lerp( hash(n+57.0), hash(n+58.0),f.x),f.y),\n        lerp(lerp( hash(n+113.0), hash(n+114.0),f.x),\n        lerp( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\n}\nfloat noise(float x) {\n    return noise(vec3(x, 0.0, 0.0));\n}\n\nvec3 in_unit_sphere(vec3 co) {\n    vec3 p;\n    do {\n        p = vec3(rand(co), rand(co*2.0), rand(co*3.0)) * 2.0 - 1.0;\n    } while(dot(p,p) > 1.0);\n    return p;\n}\nvec3 in_hemisphere(vec3 co, vec3 norm) {\n    vec3 unit = normalize(in_unit_sphere(co));\n    float dotValue = dot(unit, norm);\n    return unit * sign(dotValue);\n}\n\nvec3 woodColor(vec3 p) {\n    // Wood texture parameters\n    float frequency = 5.0;\n    float lacunarity = 2.0;\n    float persistence = 0.5;\n    int octaves = 5;\n\n    // Initial color\n    vec3 color = vec3(0.545, 0.271, 0.075); // Brown color\n\n    // Generate wood texture using Perlin noise\n    for (int i = 0; i < octaves; i++) {\n        float woodNoise = noise(p * frequency * vec3(1.0, 1.0, 0.1));\n        color += woodNoise * vec3(0.15, 0.1, 0.05); // Modulate color based on noise\n        frequency *= lacunarity;\n        p *= lacunarity;\n    }\n\n    // Adjust color intensity\n    color = clamp(color, 0.0, 1.0);\n\n    return color;\n}\n\nfloat sdSphere(in vec3 p, in vec3 c, in float r) {\n    return length(p-c)-r;\n}\nfloat sdBox( vec3 p, vec3 b ) {\n    vec3 q = abs(p) - b;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nvec3 rotateY(in vec3 p, in float t) {\n    float cosT = cos(t), sinT = sin(t);\n    return vec3(p.x * cosT - p.z * sinT, p.y, p.x * sinT + p.z * cosT);\n}\nvec3 translate(in vec3 p, in vec3 t) {\n    return p-t;\n}\nvec3 repeatX(in vec3 p, in float size) {\n    return vec3(p.x - size*round(p.x/size), p.yz);\n}\nvec3 repeatY(in vec3 p, in float size) {\n    return vec3(p.x, p.y - size*round(p.y/size), p.z);\n}\nvec3 repeatZ(in vec3 p, in float size) {\n    return vec3(p.xy, p.z- size*round(p.z/size));\n}\n\nfloat smin(float a, float b, float k) {\n    return 0.5 * ((a + b) - sqrt((a-b)*(a-b)+k));\n}\nfloat smax(float a, float b, float k) {\n    return -smin(-a, -b, k);\n}\n\nRay camera(vec2 ndc) {\n    Ray cam; \n    cam.origin    = vec3(0.0, 0.5, -1.5);\n    cam.direction = normalize(vec3(ndc, 1.0));\n    cam.direction = rotateY(cam.direction.yxz, 0.1).yxz;\n    \n    return cam;\n}\n\n// Scene SDF\nfloat map(in vec3 p, out Material mat) {\n    mat.color = vec3(0.61, 0.55, 0.16);\n    mat.emission = vec3(0.0);\n    mat.roughness = 0.2;\n    \n    float dist;\n    dist = sdSphere(p, vec3(0,0,0), 1.0);\n    vec3 pRot0 = rotateY(p,             p.y * 2.0);\n    vec3 pRot1 = rotateY(p, 0.25 * PI + p.y * 2.0);\n    vec3 pRot2 = rotateY(p, 0.5  * PI + p.y * 2.0);\n    vec3 pRot3 = rotateY(p, 0.75 * PI + p.y * 2.0);\n    \n    #define CUTOUT_WIDTH 0.1\n\n    dist = smax(dist, -sdBox(pRot0, vec3(CUTOUT_WIDTH, 1.0, 1.0)), 0.001);\n    dist = smax(dist, -sdBox(pRot1, vec3(CUTOUT_WIDTH, 1.0, 1.0)), 0.001);\n    dist = smax(dist, -sdBox(pRot2, vec3(CUTOUT_WIDTH, 1.0, 1.0)), 0.001);\n    dist = smax(dist, -sdBox(pRot3, vec3(CUTOUT_WIDTH, 1.0, 1.0)), 0.001);\n\n    \n    float dstInner = sdSphere(p, vec3(0), 0.95);\n    if (dstInner < dist) {\n        mat.emission = vec3(20.0);\n        mat.roughness = 1.0;\n        mat.color = vec3(0.0);\n        dist = dstInner;\n    }\n    \n    if (p.y + 1.0 < dist) {\n        mat.emission = vec3(0.0);\n        mat.color = woodColor(p);\n        mat.roughness = 0.9;\n        dist = p.y + 1.0;\n    }\n    \n    return dist;\n}\n\nHitInfo intersect_scene(Ray r) {\n    vec3 pos;\n    Material mat;\n    float t = 0.0;\n    for (int stp = 0; stp < 256; ++stp) {\n        pos = r.origin + r.direction * t;\n        float scene = map(pos, mat);\n        \n        if (scene < 0.001 || scene > 1000.0) break;\n        t += scene;\n    }\n    \n    if (t > 999.9) return MISS;\n    \n    HitInfo hit;\n    hit.hit = true;\n    hit.position = pos;\n    hit.dst = t;\n    hit.mat = mat;\n    \n    float epsilon = 0.001;\n    \n    hit.normal = normalize(vec3(\n            map(pos + vec3(epsilon, 0, 0), mat) - map(pos - vec3(epsilon, 0, 0), mat),\n            map(pos + vec3(0, epsilon, 0), mat) - map(pos - vec3(0, epsilon, 0), mat),\n            map(pos + vec3(0, 0, epsilon), mat) - map(pos - vec3(0, 0, epsilon), mat)\n        ));\n        \n    return hit;\n}\n\nvec3 sky_color(vec3 _) { return vec3(0.0, 0.0, 0.0); }\n#define LIGHT_POS vec3(3.0, 5.0, -3.0)\n#define LIGHT_RADIUS 1.0\n#define LIGHT_COLOR vec3(1.0, 1.0, 1.0)\n#define LIGHT_STRENGTH 300.0\n\nvec3 trace(Ray r) {\n    vec3 color = vec3(1);\n    vec3 light = vec3(0);\n    \n    for (int bounce = 0; bounce < N_BOUNCES; ++bounce) {\n        HitInfo intersect = intersect_scene(r);\n        if (!intersect.hit || length(color) < 0.01) {\n            light += color * sky_color(r.direction);\n            break;\n        }\n        \n        Material mat = intersect.mat;\n\n        // Direct Light Sampling (DLS)\n        vec3 light_pos = LIGHT_POS + normalize(in_unit_sphere(intersect.position*4.0)) * LIGHT_RADIUS;\n        vec3 dir_to_light = normalize(light_pos - intersect.position);\n        \n        float diffuse_strength = max(0.0, dot(intersect.normal, dir_to_light));\n        float refl_strength = float(dot(normalize(reflect(r.direction, intersect.normal)), dir_to_light) > 0.99);\n        float dl_strength = mix(refl_strength, diffuse_strength, clamp(mat.roughness, 0.0, 1.0)); \n        \n        vec3 direct_lighting = vec3(dl_strength) * LIGHT_COLOR;\n        direct_lighting *= LIGHT_STRENGTH / pow(distance(intersect.position, light_pos), 2.0);\n        Ray r_shadow = Ray(intersect.position + intersect.normal * 0.001, dir_to_light);\n        HitInfo shadow = intersect_scene(r_shadow);\n        bool shadowed = true;\n        if (!shadow.hit) shadowed = false;\n        else {\n            if (shadow.dst > distance(light_pos, intersect.position)) shadowed = false;\n            if (distance(shadow.position, LIGHT_POS) <= LIGHT_RADIUS+0.01) shadowed = false;\n        }\n        direct_lighting *= float(!shadowed);\n        \n#ifndef NO_DLS\n        // DLS is really bright without this correction\n        #define DLS_BRIGHTNESS (0.125)\n        light += color * direct_lighting * mat.color * DLS_BRIGHTNESS;\n        light += color * mat.emission * (DLS_BRIGHTNESS*2.0);\n#else\n        light += color * mat.emission;\n#endif\n        \n        color *= mat.color;\n        \n        r.origin = intersect.position + intersect.normal * .001;\n        vec3 diffuse_dir = normalize(normalize(in_unit_sphere(intersect.position)) + intersect.normal);\n        vec3 refl_dir = reflect(r.direction, intersect.normal);\n        r.direction = mix(refl_dir, diffuse_dir, mat.roughness);\n    }\n    \n    return light;  \n}\n\nfloat greyscale(vec4 color) {\n    float luminance = dot(color.rgb, vec3(0.299, 0.587, 0.114));\n    return luminance;\n}\n\n#define flim(x,y) flim_transform(iChannel0,x,y)\n\n/***********************************\n\nflim - Filmic Color Transform\n\nInput Color Space:   Linear BT.709 I-D65\nOutput Color Space:  sRGB 2.2\n\nShadertoy Unit:\n  Common\n\nDescription:\n  Experimental port of flim for GLSL/Shadertoy\n  matching flim v1.1.0.\n  The common unit contains most of the code, and\n  receives gamut extension matrices from a buffer.\n\nAuthor:\n  Bean (beans_please on Shadertoy)\n  Minified by 01000001\n\nOriginal Repo:\n  https://github.com/bean-mhm/flim\n\nOriginal Shader:\n  https://www.shadertoy.com/view/dd2yDz\n\n***********************************/\n\n// Parameters\n\nconst float pe = 4.3; const vec3 fpff = vec3(1); const float fpffs = 0.;\nconst float egr = 1.05; const float egg = 1.12; const float egb = 1.045;\nconst float grr = .5; const float ggr = 2.; const float gbr = .1;\nconst float grm = 1.; const float ggm = 1.; const float gbm = 1.; const float flsi = -10.;\nconst float flsa = 22.; const float fsx = .44; const float fsy = .28;\nconst float fssx = .591; const float fssy = .779; const float fe = 6.;\nconst float fd = 5.; const vec3 pb = vec3(1); const float pfe = 6.;\nconst float pfd = 27.5; const float bp = -1.; const vec3 pff = vec3(1);\nconst float pffs = 0.; const float ms = 1.02;\nfloat wrap(float i, float s, float e){return s + mod(i - s, e - s);}\nvec3 lerp(vec3 a, vec3 b, float t){return a + t * (b - a);}\nfloat mrc(float i, float is, float ie, float os, float oe){\n    float t = clamp((i - is) / (ie - is), 0., 1.);\n    float v = os + t * (oe - os);\n    return v; }\nvec3 rth(vec3 rgb){\n    float ca, ci, h, s, v, cd;\n    vec3 c;\n    ca = max(rgb[0], max(rgb[1], rgb[2]));\n    ci = min(rgb[0], min(rgb[1], rgb[2]));\n    cd = ca - ci;\n    v = ca;\n    if (ca != 0.) s = cd / ca;\n    else s = 0.0; h = 0.0;\n    if (s == 0.) h = 0.0; \n    else{\n        c = (vec3(ca) - rgb.xyz) / cd;\n\n        if (rgb.x == ca) h = c[2] - c[1];\n        else if (rgb.y == ca) h = 2.+ c[0] - c[2];\n        else h = 4.+ c[1] - c[0];\n        h /= 6.0;\n        if (h < 0.) h += 1.0; }\n    return vec3(h, s, v); }\nvec3 htr(vec3 hsv){\n    float i, f, p, q, t, h, s, v;\n    vec3 rgb;\n    h = hsv[0];\n    s = hsv[1];\n    v = hsv[2];\n    if (s == 0.) rgb = vec3(v, v, v);\n    else {\n        if (h == 1.) h = 0.0;\n        h *= 6.0;\n        i = floor(h);\n        f = h - i;\n        rgb = vec3(f, f, f);\n        p = v * (1.- s);\n        q = v * (1.- (s * f));\n        t = v * (1.- (s * (1.- f)));\n        if (i == 0.) rgb = vec3(v, t, p);\n        else if (i == 1.) rgb = vec3(q, v, p);\n        else if (i == 2.) rgb = vec3(p, v, t);\n        else if (i == 3.) rgb = vec3(p, q, v);\n        else if (i == 4.) rgb = vec3(t, p, v);\n        else rgb = vec3(v, p, q); }\n    return rgb; }\nvec3 bhs(vec3 col, float hue, float sat, float value){\n    vec3 hsv = rth(col);\n    hsv[0] = fract(hsv[0] + hue + 0.5);\n    hsv[1] = clamp(hsv[1] * sat, 0., 1.);\n    hsv[2] = hsv[2] * value;\n    return htr(hsv); }\nfloat rgb_avg(vec3 i){\n    return (i.x + i.y + i.z) / 3.0; }\nfloat rgb_sum(vec3 i){\n    return i.x + i.y + i.z; }\nfloat rgb_max(vec3 i){\n    return max(max(i.x, i.y), i.z); }\nfloat rgb_min(vec3 i){\n    return min(min(i.x, i.y), i.z); }\nvec3 uo(vec3 i, float bp, float wp){\n    float mono = rgb_avg(i);\n    float mono2 = mrc(mono, bp / 1000., 1.- (wp / 1000.), 0., 1.);\n    return i * (mono2 / mono); }\n// https://www.desmos.com/calculator/khkztixyeu\nfloat ss(float i, float tx, float ty, float sx, float sy){\n    i = clamp(i, 0., 1.);\n    tx = clamp(tx, 0., 1.);\n    ty = clamp(ty, 0., 1.);\n    sx = clamp(sx, 0., 1.);\n    sy = clamp(sy, 0., 1.);\n    float slope = (sy - ty) / (sx - tx);\n    if (i < tx){\n        float toe_pow = slope * tx / ty;\n        return ty * pow(i / tx, toe_pow); }\n    if (i < sx){\n        float intercept = ty - (slope * tx);\n        return slope * i + intercept; }\n    float shoulder_pow = -slope / (((sx - 1.) / pow(1.- sx, 2.)) * (1.- sy));\n    return (1.- pow(1.- (i - sx) / (1.- sx), shoulder_pow)) * (1.- sy) + sy; }\nfloat dmf(float mono, float max_density){\n    float offset = pow(2., flsi);\n    float fac = mrc(log2(mono + offset), flsi, flsa, 0., 1.);\n    fac = ss(fac, fsx, fsy, fssx, fssy);\n    fac *= max_density;\n    fac = pow(2., -fac);\n    return clamp(fac, 0., 1.); }\nvec3 cl(vec3 i, vec3 sensitivity_tone, vec3 dye_tone, float max_density){\n    vec3 sensitivity_tone_norm = sensitivity_tone / rgb_sum(sensitivity_tone);\n    vec3 dye_tone_norm = dye_tone / rgb_max(dye_tone);\n    float mono = dot(i, sensitivity_tone_norm);\n    float mixFac = dmf(mono, max_density);\n    return lerp(dye_tone_norm, vec3(1.), mixFac); }\nvec3 rgbd(vec3 i, float e, float max_density){\n    i *= pow(2., e);\n    vec3 result = cl(i, vec3(0, 0, 1), vec3(1, 1, 0), max_density);\n    result *= cl(i, vec3(0, 1, 0), vec3(1, 0, 1), max_density);\n    result *= cl(i, vec3(1, 0, 0), vec3(0, 1, 1), max_density);\n    return result; }\nvec3 emr(float ph, float s, float r, float m){\n    vec3 result = htr(vec3(wrap(ph + (r / 360.), 0., 1.), 1./ s, 1.));\n    result /= rgb_sum(result);\n    result *= m;\n    return result; }\nmat3 gem(float rs,float gs,float bs,float rr,float gr, float br, float rm, float gm, float bm){\n    mat3 m;\n    m[0] = emr(0., rs, rr, rm);\n    m[1] = emr(1./ 3., gs, gr, gm);\n    m[2] = emr(2./ 3., bs, br, bm);\n    return m; }\nvec3 nap(vec3 i, vec3 bex){\n    i = rgbd(i, fe, fd);\n    i *= bex;\n    i = rgbd(i, pfe, pfd);\n    return i; }\nbool flm(sampler2D mc, out mat3 em, out mat3 emi){\n    const float valid_w = 2.0;\n    vec4 row;\n    row = texelFetch(mc, ivec2(0, 0), 0);\n    if (row.w != valid_w)\n        return false;\n    em[0] = row.xyz;\n\n    row = texelFetch(mc, ivec2(1, 0), 0);\n    if (row.w != valid_w)\n        return false;\n    em[1] = row.xyz;\n\n    row = texelFetch(mc, ivec2(2, 0), 0);\n    if (row.w != valid_w)\n        return false;\n    em[2] = row.xyz;\n    row = texelFetch(mc, ivec2(3, 0), 0);\n    if (row.w != valid_w)\n        return false;\n    emi[0] = row.xyz;\n\n    row = texelFetch(mc, ivec2(4, 0), 0);\n    if (row.w != valid_w)\n        return false;\n    emi[1] = row.xyz;\n\n    row = texelFetch(mc, ivec2(5, 0), 0);\n    if (row.w != valid_w)\n        return false;\n    emi[2] = row.xyz;\n    return true; }\nvec3 flim_transform(sampler2D mc, vec3 i, float e){\n    i = max(i, 0.);\n    i *= pow(2., pe + e);\n    i = min(i, 5000.);\n    mat3 em, emi;\n    if (!flm(mc, em, emi)){ return vec3(1, 0, 1); }\n    vec3 bex = pb * em;\n    const float big = 10000000.0;\n    vec3 white_cap = nap(vec3(big, big, big), bex);\n    i = lerp(i, i * fpff, fpffs);\n    i *= em;\n    i = nap(i, bex);\n    i *= emi;\n    i = max(i, 0.);\n    i /= white_cap;\n    if (bp == -1.){\n        vec3 black_cap = nap(vec3(0.), bex);\n        black_cap /= white_cap;\n        i = uo(i, rgb_avg(black_cap) * 1000., 0.);\n    }else{ i = uo(i, bp, 0.); }\n    i = lerp(i, i * pff, pffs);\n    i = clamp(i, 0., 1.);\n    float mono = rgb_avg(i);\n    float mixFac = (mono < 0.5) ? mrc(mono, 0.05, 0.5, 0., 1.) : mrc(mono, 0.5, 0.95, 1., 0.);\n    i = lerp(i, bhs(i, 0.5, ms, 1.), mixFac);\n    i = clamp(i, 0., 1.);\n    i = pow(i, vec3(1./ 2.2));\n    return i; }\n\n/***********************************\n\nEnd of flim's implementation for Shadertoy Unit: Common\n\n***********************************/\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Progressive rendering pipeline\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 ndc = uv * 2.0 - 1.0;\n    ndc.x *= iResolution.x / iResolution.y;\n    \n    Ray cam = camera(ndc);\n    \n        // Concentrate more samples in noisier areas\n    int nSamples = N_SAMPLES;\n    float variance = texture(iChannel1, uv).x; // Variance map (last frame)\n    variance = variance * 2.0 - 1.0;\n    variance *= float(SAMPLE_VAR);\n    nSamples += int(variance);\n    nSamples = max(1, nSamples);\n    \n    vec3 col;\n    for (int i = 0; i < nSamples; ++i) {\n        seed = float(i+nSamples*iFrame);\n        Ray cam_jitter = Ray(cam.origin + 0.005*in_unit_sphere(cam.direction), cam.direction);\n        col += trace(cam_jitter);\n    }\n    col /= float(nSamples);\n\n    // Output to screen\n    fragColor = mix(texture(iChannel0, uv), vec4(col, 1.0), 1.0 / float(iFrame+1));\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"/***********************************\n\nflim - Filmic Color Transform\n\nInput Color Space:   Linear BT.709 I-D65\nOutput Color Space:  sRGB 2.2\n\nShadertoy Unit:\n  Buffer X\n\nDescription:\n  Experimental port of flim for GLSL/Shadertoy\n  matching flim v1.1.0.\n  The buffer unit performs a one-time calculation\n  of flim's gamut extension matrices.\n\nAuthor:\n  Bean (beans_please on Shadertoy)\n  Minified by 01000001\n\nOriginal Repo:\n  https://github.com/bean-mhm/flim\n\nOriginal Shader:\n  https://www.shadertoy.com/view/dd2yDz\n\n***********************************/\n\n// NOTE:\n// iChannel0 must be set to this buffer (self-feeding).\n\nvoid mainImage(out vec4 O, in vec2 U){\n    const float w = 2.0;\n    if (ivec2(U).x > 5 || ivec2(U).y > 0)\n        return;\n    vec4 p = texelFetch(iChannel0, ivec2(U), 0);\n    O = p;\n    bool n = (p.w != w) || (iTime == 0.0) || (iFrame < 1);\n    if (!n)\n        return;\n    mat3 e = gem(egr,egg,egb,grr,ggr,gbr,grm,ggm,gbm);\n    mat3 ei = inverse(e);\n    if (ivec2(U) == ivec2(0, 0)) {\n        O = vec4(e[0], w);\n    } if (ivec2(U) == ivec2(1, 0)) {\n        O = vec4(e[1], w);\n    } if (ivec2(U) == ivec2(2, 0)) {\n        O = vec4(e[2], w);\n    }\n    if (ivec2(U) == ivec2(3, 0)) {\n        O = vec4(ei[0], w);\n    } if (ivec2(U) == ivec2(4, 0)) {\n        O = vec4(ei[1], w);\n    } if (ivec2(U) == ivec2(5, 0)) {\n        O = vec4(ei[2], w);\n    }}\n\n/***********************************\n\nEnd of flim's implementation for Shadertoy Unit: Buffer X\n\n***********************************/\n","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"float variance(vec2 uv, sampler2D tex) {\n    // Number of samples in each dimension\n    const int numSamples = 2;\n\n    // Calculate the mean\n    float mean = 0.0;\n    for (int i = -numSamples; i <= numSamples; ++i) {\n        for (int j = -numSamples; j <= numSamples; ++j) {\n            vec2 offset = vec2(float(i), float(j)) / float(textureSize(tex, 0));\n            mean += greyscale(texture(tex, uv + offset));\n        }\n    }\n    mean /= float((2 * numSamples + 1) * (2 * numSamples + 1));\n\n    // Calculate the variance\n    float variance = 0.0;\n    for (int i = -numSamples; i <= numSamples; ++i) {\n        for (int j = -numSamples; j <= numSamples; ++j) {\n            vec2 offset = vec2(float(i), float(j)) / float(textureSize(tex, 0));\n            float value = greyscale(texture(tex, uv + offset));\n            variance += (value - mean) * (value - mean);\n        }\n    }\n    variance /= float((2 * numSamples + 1) * (2 * numSamples + 1));\n\n    return variance;\n}\n\n\n// Variance map\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    fragColor = vec4(variance(uv, iChannel0), 0.0,0.0,1.0);\n}","name":"Buffer C","description":"","type":"buffer"}]}