{"ver":"0.1","info":{"id":"llycW1","date":"1536102673","viewed":1906,"name":"Storm !","username":"hamtarodeluxe","description":"Tried to light some raymarched volume. Dit not follow any precise formula but my feeling for the transmission computation, so code might look unusual for that :)","likes":59,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","volume","cloud","lighting","sky","smoke","storm"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sfGRr","filepath":"/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin","previewfilepath":"/media/ap/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin","type":"volume","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n#define PI 3.14159265359\n#define maxDist 10.\n#define nStep 30\n#define nStepLight 3\n\nfloat saturate(float i)\n{\n    return clamp(i,0.,1.);\n}\nfloat hash( float n ) {\n    return fract(sin(n)*43758.5453);\n}\n\nfloat hashi( uint n ) \n{\n    // integer hash copied from Hugo Elias\n\tn = (n << 13U) ^ n;\n    n = n * (n * n * 15731U + 789221U) + 1376312589U;\n    return float( n & uvec3(0x7fffffffU))/float(0x7fffffff);\n}\nfloat noise(float p){\n\tfloat fl = floor(p);\n  \tfloat fc = fract(p);\n\treturn mix(hash(fl), hash(fl + 1.0), fc);\n}\n\nfloat noise (vec3 x)\n{\n    //smoothing distance to texel\n    x*=32.;\n    x += 0.5;\n    \n    vec3 i = floor(x);\n    vec3 f = fract(x);\n    f = f*f*f*(f*(f*6.0-15.0)+10.0);\n\tx = f+i;    \n    x-=0.5;\n    \n    return texture( iChannel0, x/32.0 ).x;\n}\n\n// Created by inigo quilez - iq/2013\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\nconst mat3 m = mat3( 0.00,  0.80,  0.60,\n           \t\t    -0.80,  0.36, -0.48,\n             \t\t-0.60, -0.48,  0.64 );\n\n\nfloat fbm( vec3 p ) { // in [0,1]\n    float f;\n    f  = 0.5000*noise( p ); p = m*p*2.02;\n    f += 0.2500*noise( p ); p = m*p*2.03;\n    f += 0.1250*noise( p ); p = m*p*2.01;\n    f += 0.0625*noise( p ); p = m*p*2.04;\n    f += 0.03125*noise( p );\n    \n    return f;\n}\n// --- End of: Created by inigo quilez --------------------\n\n\nvec3 camera (vec2 ndc, vec3 camPos, float f, vec3 lookAt)\n{\n    vec3 forward = normalize(lookAt - camPos);\n    vec3 right = cross(vec3(0.,1,0.), forward);\n    vec3 up = normalize(cross (forward, right));\n   \tright = normalize(cross (up, forward));\n    \n    vec3 rd = up * ndc.y + right * ndc.x + f*forward;\n    \n\treturn rd;\n}\n\nfloat map (vec3 p)\n{\n    float v;\n\tvec3 location =p;\n    \n \tp= p*0.009;\n    \n\tv = fbm (p);\n   \n    v =  (noise(iTime*0.0025+p+0.15*(vec3(v,v,v)))) ;\n   \n    float d =  saturate((1.-(length(location)/9.)));\n  \t\n    v=v*d-0.1;\n    \n    return 1.3*saturate(v);\n}\n\nfloat lightMarch(vec3 ro, vec3 lightPos)\n{\n    vec3 rd = lightPos-ro;\n    float d = length (rd);\n    rd = rd/d;\n    float t = 0.;\n    float stepLength = d/ float(nStepLight);\n    float densitySum = 0.;\n    float sampleNoise;\n    int i = 0;\n    for (; i < nStepLight; i++)\n    {\n    \tsampleNoise = map ( ro + t * rd);\n       \n        densitySum += sampleNoise;\n        \n        t += stepLength;\n    }\n    \n    return exp(- d * (densitySum / float(i)));\n}\n\nvec3 calculateLight(vec3 samplePos, vec3 lightPos, vec3 lightColor, float lightStr)\n{\n        float sampleLight = lightMarch (samplePos, lightPos);\n        float distToLight = length(lightPos-samplePos)+1.;\n        vec3 light = lightColor * lightStr * (1./(distToLight*distToLight)) * sampleLight;\n\n    \treturn light;\n}\n\nvec3 march(vec3 ro, vec3 rd, float dither, float var)\n{\n    float value = 0.;\n    float t = dither;\n    float densitySum = 0.;\n\n    float stepLength = maxDist / float(nStep);\n    vec3 color = vec3(0.01,0.02,0.05)*1.;\n    for (int i = 0; i < nStep; i++)\n    {\n        \n        vec3 samplePos = ro + t * rd ; \n    \tfloat sampleNoise = map (samplePos);\n        densitySum += sampleNoise;\n    \t\n        //light1\n        vec3 lightPos1 = vec3 (-18,1.8,0);         \n        vec3 light1 = calculateLight(samplePos, lightPos1, vec3 (0.6,0.25,0.15), 250.);\n \t\t\n        //light2\n        vec3 lightPos2 = vec3 (0.,0.,-15.);\n        vec3 light2 = calculateLight(samplePos, lightPos2, vec3 (0.1 ,0.2,0.6), 200.);\n     \t\n        //light3\n        float n = 1. * (noise(0.7*samplePos.y)-0.5)- 0.2*samplePos.y;\n        vec3 lightPos3 = vec3 (n,samplePos.y,10.*(hash(floor(0.1*iTime))-0.5));     \n        float storm =  mix (1.2,0., sign(fract(-0.1+0.1*iTime)-0.15 )) * noise (20.*iTime);\n        vec3 light3 = calculateLight(samplePos, lightPos3, vec3 (1.,1.,1.), storm);\n\n        vec3 ambientColor = vec3 (.0,0.025,0.025);\n        \n        color += exp(- t*(densitySum/float(i+1)))  * sampleNoise * (ambientColor + light1 + light2 + light3);\n        \n        t +=  stepLength * var;\n    }\n    \n   \n    return color;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 ndc = uv * 2. - 1.;\n    ndc.x *=iResolution.x/iResolution.y;\n  \n    vec2 mouse = iMouse.xy/iResolution.xy;\n      \n    vec3 lookAt = vec3(0.);\n    \n    float distanceToCenter =  (sin(0.1*iTime)*0.5 + 1.) *3. +3.;\n   \tvec3 cameraPos = vec3  (distanceToCenter*cos(0.15*iTime), 0., distanceToCenter*sin(00.15*iTime));\n    //cameraPos = vec3 (10.*mouse.y*cos(mouse.x*2.*PI), 0., 10.*mouse.y*sin(2.*PI*mouse.x ));\n\n    vec3 rd = camera(ndc, cameraPos, 1.0,lookAt);\n    float var = length(rd)/1.0; //to get constant z in samples\n    rd = normalize (rd);\n    \n   \tfloat dither = 0.5*hashi(uint(fragCoord.x+iResolution.x*fragCoord.y)+uint(iResolution.x*iResolution.y)*uint(iFrame));//Updated with iFrame dimension\n\n    vec3 col = march(cameraPos, rd, dither,var);\n\t//col.x= smoothstep(0.0,1.0,col.x);\n    //col.y= smoothstep(0.0,1.0,col.y);\n    //col.z= smoothstep(0.0,1.0,col.z);\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}