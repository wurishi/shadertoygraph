{"ver":"0.1","info":{"id":"7llGzX","date":"1622561034","viewed":310,"name":"Ambient cubemap","username":"stduhpf","description":"Using a cubemap for ambient diffuse lighting.","likes":2,"published":1,"flags":32,"usePreview":0,"tags":["cubemap","ambient","montecarlo","ibl"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dX3Rr","filepath":"/media/a//media/previz/cubemap00.png","previewfilepath":"/media/ap//media/previz/cubemap00.png","type":"cubemap","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":3,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define maxp(a) max(max(a.x,a.y),a.z)\n#define minp(a) min(min(a.x,a.y),a.z)\nvec4 cubitsct(float r ,vec3 o, vec3 rd)\n{\n    vec3 a=-(o-r)/rd;\n    vec3 b=-(o+r)/rd;\n    vec3 aa=min(a,b);\n    vec3 bb= max(a,b);\n    float d = maxp(aa);\n    vec3 p = rd*d+o;\n\treturn vec4(sign(p)*step((p=abs(p)).yzx,p.xyz)*step(p.zxy,p.xyz),d*sign(minp(bb)-d));\n}\n\nvec2 intersectSphere(vec3 ro, vec3 rd, vec3 c,float r){\n    vec3 origin = ro-c;\n    float demi_b = dot(rd,origin);\n    float moins_c = r*r-dot(origin,origin);\n    float quart_delta = demi_b*demi_b+moins_c;\n    return (moins_c>0. || demi_b<0. && quart_delta>0.)?-demi_b+vec2(-1,1)*sqrt(quart_delta):vec2(-1);\n}\n\nvec4 sphereNormal(vec3 ro, vec3 rd, vec3 c,float r){\n    float d = intersectSphere(ro,rd,c,r).x;\n    return vec4(normalize(ro+d*rd-c),d);\n}\n\nvec2 sphereToPlane(vec3 p){\n    vec2 uv = vec2(atan(p.y,p.x),atan(length(p.xy),p.z));\n    uv/=vec2(1.,.5)*TAU;\n    return fract(uv+1.);\n}\n\nfloat getBump(vec3 p){\n    float t = iTime*.0;\n    float c = cos(t),s = sin(t);\n    p.xz *= mat2(c,s,-s,c);\n\n    const float bump_h = .025;\n    const float t_scale = 1.;\n    vec3 pp = normalize(p*p*p*p);\n    return length(p)-bump_h*\n    (texture(iChannel3,p.xy*t_scale*sign(p.z)).r*(pp.z)+texture(iChannel3,p.zx*t_scale*sign(p.y)).r*(pp.y)\n    +texture(iChannel3,p.yz*t_scale*sign(p.x)).r*(pp.x));\n}\n\nvec3 bumpGrad(vec3 p){\n    p = normalize(p);\n    vec2 e = vec2(0,0.0005);\n    p-=.25*e.y;\n    return (vec3(getBump(p+e.yxx),getBump(p+e.xyx),getBump(p+e.xxy))-getBump(p))/e.y; \n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy; \n    vec2 mse =(iMouse.xy-.5*iResolution.xy)/360.*vec2(2.,.5*3.1415);\n    if(iMouse.xy==vec2(0))\n        mse*=0.;\n    mat3 rdroty = mat3(1,0,0,0,cos(mse.y),sin(mse.y),0,-sin(mse.y),cos(mse.y));\n    mat3 rdrotx = mat3(cos(mse.x),0,sin(mse.x),0,1,0,-sin(mse.x),0,cos(mse.x));\n    mat3 rot = rdroty*rdrotx;\n    \n    float d = 1.;\n    \n    vec3 ro = vec3(0,0,-d)*rot;\n    vec3 projPos = (vec3(2.*fragCoord-iResolution.xy,iResolution.y*d)+ro)*rot;\n    \n    vec3 rd = normalize(projPos-ro);\n    vec3 col = HLG(srgbToLinear(texture(iChannel1,(rd)).rgb));\n\n    /*vec4 cube = cubitsct(.5,ro,rd);\n    \n    if(cube.a>0.){\n        col = texture(iChannel0,cube.xyz).rgb;\n    }\n    */\n    vec4 sphere = sphereNormal(ro,rd,vec3(0),.5);\n        \n    vec3 albedo =  vec3(.82);\n    \n    if(sphere.a>0.){\n        vec3 n = normalize(bumpGrad(sphere.xyz));\n        col = uv.x<.5 ? texture(iChannel0,n,1.5).rgb*albedo : \n            texture(iChannel2,sphereToPlane(n)).rgb*albedo;\n        //col = mix( texture(iChannel0,reflect(rd,n)).rgb, col,mix(1.,pow(dot(-n,rd),5.),.25)); //make it glossy\n    }\n    \n    \n        \n    // Output\n    \n    // Output to screen\n    fragColor = vec4(linearToSRGB(col),1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dX3Rr","filepath":"/media/a//media/previz/cubemap00.png","previewfilepath":"/media/ap//media/previz/cubemap00.png","type":"cubemap","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":2,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dX3Rr","channel":0}],"code":"// stochastic \"convolution\" (Monte-carlo with importance sampling) of the cubemap with the dot product of the direction\n// the result matches the lambertian diffuse of a surface with rayDir as normal vector\n\n\n// IMPORTANT: if you change the input cubemap, make sure to set the filtering back to \"linear\" or \"nearest\"\n\nvec2 hash(float p)\n{\n\tvec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\n/*\nvec3 cosineDirection( float seed, vec3 nor) //importance sampling on an hemisphere with density proportionnal to the cosine of the angle to the center line\n{\n    //compute TBN space\n    vec3 tc = vec3( 1.0+nor.z-nor.xy*nor.xy, -nor.x*nor.y)/(1.0+nor.z);\n    vec3 uu = vec3( tc.x, tc.z, -nor.x );\n    vec3 vv = vec3( tc.z, tc.y, -nor.y );\n    \n    //generate non-uniform random direction\n    vec2 uv = hash(seed);\n    float a =  TAU* uv.x;\n    \n    return  sqrt(uv.y)*(cos(a)*uu + sin(a)*vv) + sqrt(1.0-uv.y)*nor;\n}\n*/\n\n// http://www.amietia.com/lambertnotangent.html\nvec3 cosineDirection(float seed,vec3 normal)\n{\n    vec2 uv = hash(seed);\n    float theta = TAU * uv.x;\n    uv.y = 2. *uv.y - 1.;\n    vec3 spherePoint = vec3(sqrt(1.0 - uv.y * uv.y) * vec2(cos(theta), sin(theta)), uv.y);\n    normal*=1.+6e-8; //to avoid zero length result\n    \n    /*\n    //computing the inverse length before the addition, just for fun, I think it's not even faster than using normalize()\n    const float k = inversesqrt(2./(1.+12e-8));\n    float il = k*inversesqrt(1.+dot(normal,spherePoint));\n    */\n    \n    return (normal + spherePoint); //warning: unnormalized output (shouldn't be a problem for sampling a cubemap) multiply by il if needed\n}\n\nvoid mainCubemap( out vec4 fragColor, in vec2 fragCoord, in vec3 rayOri, in vec3 rayDir )\n{\n\n    vec3 col = texture(iChannel1,rayDir).rgb;\n    \n    //removing the noise texture can make the lookups faster( less divergence), but it might looks bad if the cubemp is too detailed\n    vec3 samp = \n    HLG(srgbToLinear(texture(iChannel0,cosineDirection(iTime+16.*texture(iChannel2,fragCoord/iChannelResolution[2].xy)[iFrame%4],rayDir)).rgb));\n    {//optionnal second sample\n    samp += \n    HLG(srgbToLinear(texture(iChannel0,cosineDirection(iTime-16.*texture(iChannel2,fragCoord/iChannelResolution[2].xy)[(iFrame+2)%4],rayDir)).rgb));\n    samp*=.5;\n    }\n    \n    // I use exponential rolling-average, but in this case, a true average would be better, since the cubemap doesn't change\n    // and the buffers are unclamped.\n    // I still use this because it can react to changes of the cubemap, which can be usefull for procedural skyboxes for example\n    col = mix(col,samp,max(1./float(iFrame+1),.025));\n    // Output to cubemap\n    fragColor = vec4(col,1.0);\n}","name":"Cube A","description":"","type":"cubemap"},{"inputs":[],"outputs":[],"code":"//Image-Based lighting requires linear values to look correct, so these transformations are important.\nconst float TAU = 2.*acos(-1.);\n\n\nvec3 linearToSRGB(vec3 linear){\n    return mix(\n        linear * 12.92,\n        pow(linear, vec3(1./2.4) ) * 1.055 - .055,\n        step( .0031308, linear )\n    );\n}\n\nvec3 srgbToLinear(vec3 srgb){\n    return mix(\n        srgb / 12.92,\n        pow(.947867 * srgb + .0521327, vec3(2.4) ),\n        step( .04045, srgb )\n    );\n}\n\n\nvec3 HLG(vec3 lin){\n    lin*=255./256.;\n    float lum = dot(lin,vec3(0.2126,.7152,.0722));\n    float l = lum;\n    l = (sqrt(-log(1.-l*l)));\n    if(isnan(l))l=lum;\n    if(lum<.2)l=lum;\n    return lin*l/lum*256./255.;\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":2,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// stochastic \"convolution\" (Monte-carlo with importance sampling) of the cubemap with the dot product of the direction\n// the result matches the lambertian diffuse of a surface with rayDir as normal vector\n\nvec2 hash(float p)\n{\n\tvec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\n/*\nvec3 cosineDirection( float seed, vec3 nor) //importance sampling on an hemisphere with density proportionnal to the cosine of the angle to the center line\n{\n    //compute TBN space\n    vec3 tc = vec3( 1.0+nor.z-nor.xy*nor.xy, -nor.x*nor.y)/(1.0+nor.z);\n    vec3 uu = vec3( tc.x, tc.z, -nor.x );\n    vec3 vv = vec3( tc.z, tc.y, -nor.y );\n    \n    //generate non-uniform random direction\n    vec2 uv = hash(seed);\n    float a =  TAU* uv.x;\n    \n    return  sqrt(uv.y)*(cos(a)*uu + sin(a)*vv) + sqrt(1.0-uv.y)*nor;\n}\n*/\n\n// http://www.amietia.com/lambertnotangent.html\nvec3 cosineDirection(float seed,vec3 normal)\n{\n    vec2 uv = hash(seed);\n    float theta = TAU * uv.x;\n    uv.y = 2. *uv.y - 1.;\n    vec3 spherePoint = vec3(sqrt(1.0 - uv.y * uv.y) * vec2(cos(theta), sin(theta)), uv.y);\n    normal*=1.+6e-8; //to avoid zero length result\n    \n    /*\n    //computing the inverse length before the addition, just for fun, I think it's not even faster than using normalize()\n    const float k = inversesqrt(2./(1.+12e-8));\n    float il = k*inversesqrt(1.+dot(normal,spherePoint));\n    */\n    \n    return (normal + spherePoint); //warning: unnormalized output (shouldn't be a problem for sampling a cubemap) multiply by il if needed\n}\n\nvec3 planeToSphere(vec2 uv){\n    uv*=vec2(1.,.5)*TAU;\n    return vec3(cos(uv.x)*sin(uv.y),sin(uv.x)*sin(uv.y),cos(uv.y));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 rayDir = planeToSphere(fragCoord/iResolution.xy);\n    vec3 col = texture(iChannel1,fragCoord/iResolution.xy).rgb;\n    \n    //removing the noise texture can make the lookups faster( less divergence), but it might looks bad if the cubemp is too detailed\n    vec3 samp = \n    HLG(srgbToLinear(\n        texture(iChannel0,\n            cosineDirection(iTime+16.*texture(iChannel2,fragCoord/iChannelResolution[2].xy)[iFrame%4],rayDir)\n            ).rgb\n        ));\n    {//optionnal second sample\n    samp += \n    HLG(srgbToLinear(\n        texture(iChannel0,\n            cosineDirection(iTime-16.*texture(iChannel2,fragCoord/iChannelResolution[2].xy)[(iFrame+2)%4],rayDir)\n        ).rgb\n    ));\n    samp*=.5;\n    }\n        \n    // I use exponential rolling-average, but in this case, a true average would be better, since the cubemap doesn't change\n    // and the buffers are unclamped.\n    // I still use this because it can react to changes of the cubemap, which can be usefull for procedural skyboxes for example\n    col = mix(col,samp,max(1./float(iFrame+1),0.001953125));\n    // Output to cubemap\n    \n    //col = texture(iChannel0,rayDir).rgb;\n    fragColor = vec4(col,1.0);\n}","name":"Buffer A","description":"","type":"buffer"}]}