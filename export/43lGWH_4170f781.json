{"ver":"0.1","info":{"id":"43lGWH","date":"1707406905","viewed":51,"name":"A 4-phase cycle of bricks","username":"toriikyuu","description":"every square of 4 bricks rotates clockwise every cycle, which takes 4 turns\n\nI made it when I was going through The Book Of Shaders\nAnd suddenly got an idea for a cycle like this","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["loop"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float PI = 3.1415926535;\n\nvec2 brickTile_old(vec2 _st, float _zoom, out vec2 type){\n    _st *= _zoom;\n    \n    float t = fract(iTime/4.);\n    float shift = fract(sin(t*PI*2.+PI/2.));\n    float in_shift = 1. - shift;\n    \n    float phase = step(1., t);\n    phase += step(0.75, t);\n    phase += step(0.5, t);\n    phase += step(0.25, t);\n    \n\n    // Here is where the offset is happening\n    vec2 even = step(1., mod(_st,2.0))*2. - 1.;\n    type = even;\n    even *= step(2., phase)*2.-1.;\n    float h = mod(phase, 2.);\n    float v = 1. - h;\n    vec2 direction = vec2(h, v);\n    _st += even.yx * direction * shift;\n    \n    type = step(1., mod(_st,2.));//step(1., mod(_st,2.0));\n\n    return fract(_st);\n}\n\nvec2 brickTile(vec2 _st, float _zoom, out vec2 type){\n    _st *= _zoom;\n    \n    float t = fract(iTime/10.);\n    float shift = fract(t*4.);\n    float phase = step(1., t);\n    phase += step(0.75, t);\n    phase += step(0.5, t);\n    phase += step(0.25, t);\n    \n\n    // Here is where the offset is happening\n    vec2 even = step(1., mod(_st,2.0))*2. - 1.;\n    float h = - mod(phase, 2.);\n    float v = 1. + h;\n    vec2 direction = vec2(h, v);\n    vec2 start;\n    start.x = step(2.,phase);\n    start.y = step(2.,mod(phase+1., 4.));\n    _st += even.yx * (start + shift * direction);\n    \n    type = step(1., mod(_st,2.0));\n\n    return fract(_st);\n}\n\nfloat box(vec2 _st, vec2 _size){\n    _size = vec2(0.5)-_size*0.5;\n    vec2 uv = smoothstep(_size,_size+vec2(1e-4),_st);\n    uv *= smoothstep(_size,_size+vec2(1e-4),vec2(1.0)-_st);\n    return uv.x*uv.y;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec2 st = gl_FragCoord.xy/iResolution.xy;\n    vec3 color = vec3(1.0);\n\n    // Modern metric brick of 215mm x 102.5mm x 65mm\n    // http://www.jaharrison.me.uk/Brickwork/Sizes.html\n    // st /= vec2(2.15,0.65)/1.5;\n\n    // Apply the brick tiling\n    vec2 type;\n    st = brickTile(st,4.288, type);\n\n    color *= vec3(box(st,vec2(0.740,0.780)));\n\n    // Uncomment to see the space coordinates\n    color *= vec3(type/2.+0.5, type.y);\n\n    fragColor = vec4(color, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}