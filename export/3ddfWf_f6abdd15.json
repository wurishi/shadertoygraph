{"ver":"0.1","info":{"id":"3ddfWf","date":"1606151267","viewed":112,"name":"Wobbly Cloth","username":"me_123","description":"This Shader uses raymarching. it has defocus blur and antialiasing. ","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float max_steps = 100.;\nfloat e = 0.001;\nfloat max_dist = 100.;\nfloat sphere(in vec3 p, in float r) {\n    return length(p)-r;\n}\nfloat hash(vec2 p) {\n    p = 50.*fract(p*0.3183099);\n    return fract(p.x*p.y*(p.x+p.y));\n}\nfloat cyl( vec3 p, float h, float r ) {\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\nfloat box( vec3 p, vec3 b )\n{\n  float br = 0.11;\n  b-=(br*1.);\n  vec3 q = abs(p) - b;\n  float bo = (length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0))-br;\n  bo += length(sin(p*10.))/200.;\n  return bo;\n}\nfloat Amin(float[25] m) {\n    float op = 10000.0;\n    for (int i = 0; i < 25; i += 1) {\n        op = min(op, m[i]);\n    }\n    return op;\n}\nvec3 rep( in vec3 p, in vec3 c)\n{\n    vec3 q = mod(p+0.5*c,c)-0.5*c;\n    float r = length(sin((p/2.)+iTime))+length(sin((p/10.)+(iTime/2.)));\n    float offset = r*((length(p)/10.)+0.1);\n    q.y = p.y+offset-0.5;;\n    return q;\n}\nfloat SDF(in vec3 p) {\n    vec3 sp = vec3(1.0, 2.0, 5.0);\n    float plain = p.y;\n    float objects[25];\n    float c = 1.0;\n    vec3 pp = rep(p, vec3(1.0));\n    objects[0] = box(pp, vec3(0.5, 0.5, 0.5));\n    objects[1] = sphere(p-vec3(0.0, 1.0, -3.0), 0.5);\n    return objects[0];\n}\n\nvec3 getNormal(vec3 p) {\n    float d = SDF(p);\n    vec2 e = vec2(.01, 0.0);\n    vec3 n = d-vec3(\n    \tSDF(p-e.xyy),\n    \tSDF(p-e.yxy),\n    \tSDF(p-e.yyx)\n    );\n    return normalize(n);\n}\nvec3 tex(vec3 p) {\n    vec3 c = vec3(\n    \tfloat(length(sin(p.xz*3.1)) > 0.7*((sin(iTime)+2.)/3.)),\n    \tfloat(length(sin(p.xz*6.2)) > 0.9*((sin(iTime/2.)+2.)/3.)),\n    \tfloat(length(sin(p.xz*9.3)) > 0.4*((sin(iTime/4.)+2.)/3.))\n    )\n        ;\n\treturn vec3(c);\n}\nvec4 ray(vec3 ro, vec3 rd) {\n    float d0 = 0.0;\n    vec3 roo = ro;\n    vec3 rdd = rd;\n    float steps = 0.0; \n    vec3 c = vec3(0);\n    for (float i = 0.0; i < max_steps; i += 1.0) {\n        steps += 1.0;\n        vec3 p = roo + rdd*d0;\n        float ds = SDF(p);\n        d0 += ds;\n        if (ds<e||ds>max_dist) {\n            break;\n        };\n       \tc = p;\n    }\n    \n    return vec4(vec3(c), d0);\n}\nfloat samples = 5.;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tfloat size = iResolution.x;\n    vec3 color = vec3(0.0);\n    \n    for (int i = 0; i < int(samples); i += 1) {\n    \tvec2 uv = ((fragCoord-.5*size)/size);\n        vec3 ro = vec3(0.0, 2.0, (sin(iTime/10.)*5.)-10.);\n        vec3 rd = normalize(vec3(uv.x, uv.y, 1.0));\n     \tvec4 r = ray(ro, rd);\n        float d = r.w;\n        uv.x += (hash(uv+float(i))/(iResolution.x))*(d-10.);\n        uv.y += (hash(uv+float(i))/(iResolution.y))*(d-10.);\n        rd = normalize(vec3(uv.x, uv.y, 1.0));\n     \tr = ray(ro, rd);\n        d = r.w;\n        vec3 p = ro + rd*d;\n        vec3 norm = getNormal(p);\n        vec3 col = ((tex(r.xyz)+(dot(norm, normalize(vec3(-1. , 10., -1)))))/5.)/(length(p)/1.);\n        if (d >= max_dist) {\n            col = vec3(0);\n        }\n        col *= vec3(1.8, 1.8, 1.9);\n        color += clamp(sqrt(col)/1.5, 0.02, 0.9)-0.02;\n    }\n    fragColor = vec4((color/samples), 1.0);\n}","name":"Image","description":"","type":"image"}]}