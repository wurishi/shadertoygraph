{"ver":"0.1","info":{"id":"MtcBzf","date":"1540453729","viewed":147,"name":"semistructured","username":"cardinalsine","description":"Attempted to create a pseudorandom noise algorithm somewhat inspired by Perlin noise. I can't say it's on par with Perlin noise, but I think it's visually interesting.","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["abstract"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14159265359\n#define PHI 1.61803398875\n\n// time (uniform)\n#define u_t iTime\n// resolution (uniform)\n#define u_res iResolution\n\nfloat sinStep(float x, float w) {\n    float y = (x+(1./w)*sin(w*x));\n    return y;\n}\n\nfloat fibonacciHash(float x) {\n    return mod((1./PHI)*x,1.);\n}\n\nfloat cosInterp(float x, float p0, float p1) {\n    return p0+(p1-p0)*0.5*(1.-cos(PI*fract(x)));\n}\n\nfloat linInterp(float x, float p0, float p1) {\n    return p0+(p1-p0)*fract(x);\n}\n\nfloat distanceDet(vec2 p) {\n    float d0 = distance(vec2(-1.,1.), p.xy),\n    \t  d1 = distance(vec2(1.,1.), p.xy),\n    \t  d2 = distance(vec2(-1.,1.), p.xy),\n          d3 = distance(vec2(-1.,-1.), p.xy);\n\t\n    mat2 m0 = mat2(d0, d1,\n                   d2, d3);\n    \n    return determinant(m0);\n}\n\nfloat fHashNoiseF(float x) {\n    // integer part of coordinates\n    float x_i = floor(x);\n    \n    // hash\n    float x0 = fibonacciHash(x_i),\n    \t  x1 = fibonacciHash(x_i+1.);\n    \n    float fx = cosInterp(x, x0, x1);\n    return fx;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from -1 to 1)\n    vec2 uv = (-1.+2.*(fragCoord/u_res.xy))*(u_res.xy/u_res.xx);\n    \n    float r = distance(vec2(0.0),uv.xy);\n    float theta = atan(uv.y/uv.x);\n\t\n    float x_co = fHashNoiseF(8.*(distanceDet(uv.xy-2.))+4.*sinStep(u_t/8.,PI));\n    float y_co = fHashNoiseF(8.*(distanceDet(uv.yx-2.))+4.*sinStep(u_t/8.+0.5,PI));\n    \n    float sum = 0.;\n    float a = 0.;\n    vec3 col = vec3(0.);\n    for(float i = 1.; i < 128.; i++) {\n        a = exp2(-(i-1.)*0.5);\n        sum += a;\n        col += a*cos(i*PI*cos(PI*(2.*r-u_t/4.+0.5*(x_co+y_co)*(1.+exp2(-6.+(r*r))*vec3(0.,0.5,1.)))));\n    }\n    col = 0.5*(1.+col)/sum;\n \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}