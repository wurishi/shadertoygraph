{"ver":"0.1","info":{"id":"MfjcWd","date":"1723229614","viewed":62,"name":"{Poincaré Disk}","username":"inverse_transpose","description":"Just continuing my study and practice of Poincaré disk rendering.","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["poincaredisk"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n * I'm continuing my study and practice of rendering Poincaré disks. They are extremely beautiful\n * and I've found myself enchanted by them, so I'm determined to learn this well. I have, once again,\n * used Shane's code to do this (https://www.shadertoy.com/view/WlBczG). I removed a lot of parts just\n * to keep it simpler for myself to aid in my learning. There is some aliasing near the edge of the unit\n * circle, which is very likely the result of having moved some line(s) of code from Shane's shader that\n * dealt with that.\n *\n * This code is also more concise and efficient thanks to Fabrice Neyret who corrected my last attempt\n * here https://www.shadertoy.com/view/4fBcWG.\n *\n * One thing I noticed that was having taken the code for rendering the lines, etc, and taken the rest\n * of the code from my first attempt above, it wasn't working correctly and it turns out the rotation\n * function isn't exactly the same as the one below (compare it with the clever version from Fabrice\n * in the one above) in terms of its result (the lines did not meet one another as they were shorter\n * and slightly warped).\n */\n\n#define WHITE_VERSION\n\nmat2 rot(in float t) { float c = cos(t); float s = sin(t); return mat2(c, -s, s, c); }\n\nfloat N\t= 3.,\n      Q = 8.,\n     PI\t= 3.14159265,\n    TAU = 6.28318531;\n     \nfloat circle(vec2 p, float w)\n{\n    float d = length(p),\n         dd = fwidth(d);\n    return smoothstep( dd, -dd, abs(d-1.) - .5*w );\n}\n\n// IQ's standard box function.\nfloat sBox(in vec2 p, in vec2 b){\n   \n    vec2 d = abs(p) - b;\n    return min(max(d.x, d.y), 0.) + length(max(d, 0.));\n}\n\n// This is Shane's function.\nfloat lBox(vec2 p, vec2 a, vec2 b, float ew){\n    \n    float ang = atan(b.y - a.y, b.x - a.x);\n    p = rot(ang)*(p - mix(a, b, .5));\n\n    vec2 l = vec2(length(b - a), ew);\n    return sBox(p, (l + ew)/2.) ;\n}\n\n// This is Shane's function.\nvec2 transform(vec2 p, vec3 circ)\n{\n    float ia = (floor(atan(p.x, p.y)/TAU*float(N)) + .5)/float(N);\n    vec2 vert = rot(ia*TAU)*vec2(0, circ.x);\n   \n    float rSq = circ.y*circ.y;\n    \n    vec2 pc = p - vert;\n    float lSq = dot(pc, pc);\n    \n    if(lSq<rSq){\n         \n        p = pc*rSq/lSq + vert; \n    }\n\n    return p;\n}\n\nvoid mainImage(out vec4 O, vec2 u)\n{\n    vec2 R = iResolution.xy,\n         U = 1.1* ( 2.*u - R) / R.y,\n         p = U,\n\n    m = ( 2.*iMouse.xy - R ) / R.y , A = abs(m);\n    \n    \n    // Mouse inversion.\n    if( length(m) < 1e-3 ) m += 1e-3; \n    if( max(A.x,A.y) > .98*.7071 ) m *= .98;\n    float k = 1. / dot(m, m);\n    vec2 invCtr = k * m, \n         q = p - invCtr;\n    p = q * (k-1.) / dot(q,q) + invCtr;\n    p.x = -p.x; \n  \n  \n    // Rotation.\n    p *= rot(iTime/12.);\n\n\n    // Compute distance information.\n    float a = sin(PI/N), b = cos(PI/Q),\n\t     d2 = cos(PI/N + PI/Q) / a,\n\t     r2 = 1./(b*b/a/a - 1.);\n\tvec3 domInfo = sqrt(max(vec3(1. + r2, r2, d2*d2*r2), 0.));\n    \n    \n    if (length(p)>1.0)\n        p /= dot(p, p);\n\n    for (int i; i<24; i++)\n        p = transform(p, domInfo);\n\n    float ln = 1e5, ln2 = 1e5, pnt = 1e5;\n\n    vec2 v0 = vec2(0, domInfo.z), m0;\n    int iN = int(N);\n    \n    // Iterate the vertices of the fundamental polygon and obtain\n    // the minimum distances to each line we wish to render, each\n    // midpoint, and each vertex.\n    for (float i = .0; i < N; ++i)\n    {\n        m0 = (rot(PI/float(N))*v0)*(domInfo.x - domInfo.y)/domInfo.z;\n         \n        // Center to vertex distances. \n        ln = min(ln, lBox(p, vec2(0), v0, .008));\n        // Center to edge mid point distances. \n        ln2 = min(ln2, lBox(p, vec2(0), m0, .007));\n        \n        // Vertex points.\n        pnt = min(pnt, length(p - v0));\n \n        // Rotating to the next vertex point.\n        v0 = rot(TAU/float(N))*v0;\n    }\n\n    float ssf = (2. - smoothstep(0., .25, abs(length(U) - 1.) - .25));\n    float sf = 2./R.y*ssf;\n    \n#ifdef WHITE_VERSION\n    vec3 mc = vec3(1);\n#else\n    vec3 mc = vec3(.15);\n#endif\n        \n    vec3 c;\n    \n    float pat = smoothstep(0., .25, abs(fract(ln2*60. - .5) - .5)*2. -.25);\n\n    vec3 bg = mix(vec3(1.0, 0.5, 0.8), vec3(0.2, 0.8, 0.7), .65);\n    \n    float ratio = TAU / N;\n\n    switch (int(floor(mod(atan(p.x, p.y), TAU) / ratio)))\n    {\n    case 0:\n        bg = vec3(0.2, 0.6, 0.5);//mix(vec3(1.0, 0.35, 0.8), vec3(0.2, 0.8, 0.7), .35);\n        break;\n    case 1:\n        bg = vec3(0.2, 0.4, 0.35);//mix(vec3(1.0, 0.5, 0.8), vec3(0.2, 0.8, 0.7), .175);\n        break;\n    case 2:\n        bg = vec3(0.2, 0.415, 0.51);//mix(vec3(1.0, 0.5, 0.8), vec3(0.2, 0.8, 0.7), .65);\n        break;\n    }\n    \n    c = min(bg*(pat*.2 + .9), 1.0);\n    \n    // Render the boxes.\n    c = mix(c, mc, 1. - smoothstep(0., sf, .1-ln));\n    \n    // Render the lines.\n    c = mix(c, mc, 1. - smoothstep(0., sf, ln));\n\n    c = mix(c, bg*.25, smoothstep(pnt, -pnt, (pnt - .02)/fwidth(pnt)));\n    c = mix(c, vec3(1), smoothstep(pnt, -pnt, (pnt - .009)/fwidth(pnt)));\n    \n    if (length(U)>1.0)\n        c = mix(c, vec3(1), .8);\n\n    c = mix(c, mc, circle(U, .125));\n    c = mix(c, vec3(.85), circle(U, .025));\n    O = vec4(pow(c, vec3(1./1.4)), 1.0);\n}\n","name":"Image","description":"","type":"image"}]}