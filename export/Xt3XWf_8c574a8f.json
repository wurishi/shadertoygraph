{"ver":"0.1","info":{"id":"Xt3XWf","date":"1481738681","viewed":510,"name":"Font demo","username":"gigatron","description":"Quick font demo test ; sorry no time to add fx maybe later (IQ cube :)) , Char map code from Master of glsl : Fabrice \nit become MAD !! all done !","likes":6,"published":1,"flags":64,"usePreview":0,"tags":["demo","font"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdfGRn","filepath":"/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","previewfilepath":"/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Xdf3zn","filepath":"/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png","previewfilepath":"/media/ap/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png","type":"texture","channel":2,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sj3WW","filepath":"https://soundcloud.com/serdarkaraman/serdar-karaman-dark-times-1991","previewfilepath":"https://soundcloud.com/serdarkaraman/serdar-karaman-dark-times-1991","type":"musicstream","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// --- access to the image of ascii code c from Fabrice \nvec4 char(vec2 pos, float c) {\n    pos = clamp(pos,0.,1.);  // would be more efficient to exit if out.\n\n    vec4 tx= texture( iChannel0, pos/16. + fract( floor(vec2(c, 15.999-c/16.)) / 16. ) )*2. ;\n    vec4 ty= texture( iChannel0, pos/16.012 + fract( floor(vec2(c, 15.999-c/16.012)) / 16.012 ) )/3.0 ;\n  \n    vec4 tz= texture( iChannel3,pos);\n    \n    return  vec4((tx+ty)/(tz*3.0));\n    // possible variants: (but better separated in an upper function) \n    //     - inout pos and include pos.x -= .5 + linefeed mechanism\n    //     - flag for bold and italic \n}\n\n\n// Created by inigo quilez - iq/2013\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// a perspective correct triangle rasterizer, in a shader!! :D\n// 2D\nvec2 rotation(in float angle,in vec2 position,in vec2 center)\n{\n    //Function seen from https://www.shadertoy.com/view/XlsGWf\n    float rot = radians(angle);\n    mat2 rotation = mat2(cos(rot), -sin(rot), sin(rot), cos(rot));\n    return vec2((position-center)*rotation);\n}\n\nmat4 setRotation( float x, float y, float z )\n{\n    float a = sin(x); float b = cos(x); \n    float c = sin(y); float d = cos(y); \n    float e = sin(z); float f = cos(z); \n\n    float ac = a*c;\n    float bc = b*c;\n\n    return mat4( d*f,      d*e,       -c, 0.0,\n                 ac*f-b*e, ac*e+b*f, a*d, 0.0,\n                 bc*f+a*e, bc*e-a*f, b*d, 0.0,\n                 0.0,      0.0,      0.0, 1.0 );\n}\n\nmat4 setTranslation( float x, float y, float z )\n{\n    return mat4( 1.0, 0.0, 0.0, 0.0,\n\t\t\t\t 0.0, 1.0, 0.0, 0.0,\n\t\t\t\t 0.0, 0.0, 1.0, 0.0,\n\t\t\t\t x,     y,   z, 1.0 );\n}\n\nstruct Triangle\n{\n    vec3 a; vec2 aUV;\n    vec3 b; vec2 bUV;\n    vec3 c; vec2 cUV;\n    vec3 n;\n};\n\n\nTriangle triangles[14];\n\nvoid createCube( void )\n{\n    vec3 verts[8];\n\n    verts[0] = vec3( -1.0, -1.0, -1.0 );\n    verts[1] = vec3( -1.0, -1.0,  1.0 );\n    verts[2] = vec3( -1.0,  1.0, -1.0 );\n    verts[3] = vec3( -1.0,  1.0,  1.0 );\n    verts[4] = vec3(  1.0, -1.0, -1.0 );\n    verts[5] = vec3(  1.0, -1.0,  1.0 );\n    verts[6] = vec3(  1.0,  1.0, -1.0 );\n    verts[7] = vec3(  1.0,  1.0,  1.0 );\n\n    triangles[0].a = verts[1]; triangles[0].aUV = vec2(0.0,0.0);\n    triangles[0].b = verts[5]; triangles[0].bUV = vec2(1.0,0.0);\n    triangles[0].c = verts[7]; triangles[0].cUV = vec2(1.0,1.0);\n    triangles[0].n = vec3( 0.0, 0.0, 1.0 );\n    triangles[1].a = verts[1]; triangles[1].aUV = vec2(0.0,0.0),\n    triangles[1].b = verts[7]; triangles[1].bUV = vec2(1.0,1.0),\n    triangles[1].c = verts[3]; triangles[1].cUV = vec2(0.0,1.0),\n    triangles[1].n = vec3( 0.0, 0.0, 1.0 );\n\n    triangles[2].a = verts[5]; triangles[2].aUV = vec2(0.0,0.0);\n    triangles[2].b = verts[4]; triangles[2].bUV = vec2(1.0,0.0);\n    triangles[2].c = verts[6]; triangles[2].cUV = vec2(1.0,1.0);\n    triangles[2].n = vec3( 1.0, 0.0, 0.0 );\n    triangles[3].a = verts[5]; triangles[3].aUV = vec2(0.0,0.0);\n    triangles[3].b = verts[6]; triangles[3].bUV = vec2(1.0,1.0);\n    triangles[3].c = verts[7]; triangles[3].cUV = vec2(0.0,1.0);\n    triangles[3].n = vec3( 1.0, 0.0, 0.0 );\n\n    triangles[4].a = verts[3]; triangles[4].aUV = vec2(0.0,0.0);\n    triangles[4].b = verts[7]; triangles[4].bUV = vec2(1.0,0.0);\n    triangles[4].c = verts[6];;triangles[4].cUV = vec2(1.0,1.0);\n    triangles[4].n = vec3( 0.0, 1.0, 0.0 );\n    triangles[5].a = verts[3]; triangles[5].aUV = vec2(0.0,0.0);\n    triangles[5].b = verts[6]; triangles[5].bUV = vec2(1.0,1.0);\n    triangles[5].c = verts[2]; triangles[5].cUV = vec2(0.0,1.0);\n    triangles[5].n = vec3( 0.0, 1.0, 0.0 );\n\n    triangles[6].a = verts[0]; triangles[6].aUV = vec2(1.0,0.0);\n    triangles[6].b = verts[6]; triangles[6].bUV = vec2(0.0,1.0);\n    triangles[6].c = verts[4]; triangles[6].cUV = vec2(0.0,0.0);\n    triangles[6].n = vec3( 0.0, 0.0, -1.0 );\n    triangles[7].a = verts[0]; triangles[7].aUV = vec2(1.0,0.0);\n    triangles[7].b = verts[2]; triangles[7].bUV = vec2(1.0,1.0);\n    triangles[7].c = verts[6]; triangles[7].cUV = vec2(0.0,1.0);\n    triangles[7].n = vec3( 0.0, 0.0, -1.0 );\n\n    triangles[8].a = verts[1]; triangles[8].aUV = vec2(1.0,0.0);\n    triangles[8].b = verts[2]; triangles[8].bUV = vec2(0.0,1.0);\n    triangles[8].c = verts[0]; triangles[8].cUV = vec2(0.0,0.0);\n    triangles[8].n = vec3( -1.0, 0.0, 0.0 );\n    triangles[9].a = verts[1]; triangles[9].aUV = vec2(1.0,0.0);\n    triangles[9].b = verts[3]; triangles[9].bUV = vec2(1.0,1.0);\n    triangles[9].c = verts[2]; triangles[9].cUV = vec2(0.0,1.0);\n    triangles[9].n = vec3( -1.0, 0.0, 0.0 );\n\n    triangles[10].a = verts[1]; triangles[10].aUV = vec2(0.0,0.0);\n    triangles[10].b = verts[0]; triangles[10].bUV = vec2(0.0,1.0);\n    triangles[10].c = verts[4]; triangles[10].cUV = vec2(1.0,1.0);\n    triangles[10].n = vec3( 0.0, -1.0, 0.0 );\n    triangles[11].a = verts[1]; triangles[11].aUV = vec2(0.0,0.0);\n    triangles[11].b = verts[4]; triangles[11].bUV = vec2(1.0,1.0);\n    triangles[11].c = verts[5]; triangles[11].cUV = vec2(1.0,0.0);\n    triangles[11].n = vec3( 0.0, -1.0, 0.0 );\n}\n\nfloat crosse( vec2 a, vec2 b )\n{\n    return a.x*b.y - a.y*b.x;\n}\n\nvec3 lig = normalize( vec3( 0.3,0.7,0.5) );\n\nvec3 pixelShader( in vec3 nor, in vec2 uv, in float z, in vec3 wnor )\n{\n    float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n    float brdf = 0.5 + 0.8*dif;\n    brdf *= 6.0*exp( -0.5*abs(z) );\n\t\t\t\n\tvec3 mate = texture( iChannel2, uv ).xyz * abs(wnor.x) + \n\t\t        texture( iChannel2, uv ).xyz * abs(wnor.y) + \n\t\t        texture( iChannel2, uv ).xyz * abs(wnor.z);\n\t\n    vec3 col = brdf * mate;\t\n\t\n    return sqrt( col );\n}\n\n\nvoid mainImage( out vec4 fragColor,  vec2 fragCoord )\n{\n    vec2 uv= fragCoord.xy/iResolution.xy;\n    uv.x *= iResolution.x/iResolution.y;;\n    \n    float tcube=iTime; \n   \n        vec2 q=uv;\n    \n    mat4 mdv = setTranslation(-10.0+clamp( tcube*3.,-5.,10.0), 0.5, -5.0 ) * \n\t\t       setRotation( 0.6, 0.0,  0.0 ) * \n\t\t       setRotation( 3.1*sin(0.8*tcube), 2.1*sin(0.8*tcube), 0.7*sin(0.8*tcube) );\n\n    // clamp rulez \n    \n    if(tcube>7.0) mdv = setTranslation( 0.0,-0.5+ 2.5*abs(sin(tcube))-0.9, -5.0 ) * \n\t\t       \t\t\tsetRotation( 0.6, 0.0,  0.0 ) * \n\t\t       \t\t\tsetRotation( 6.1*sin(0.8*tcube), 0.6*cos(0.8*tcube), 0.7*sin(0.8*tcube) );\n   \n    if(tcube>15.0) mdv = setTranslation( -0.5+ 4.5*sin(tcube)-0.5,-0.5+ 2.5*abs(sin(tcube))-0.9, -2.0-3.*abs(sin(tcube))-0.5 )  \n\t\t       \t\t\t * \n\t\t       \t\t\tsetRotation( 6.1*sin(0.8*tcube), 2.1*sin(0.8*tcube), 0.7*sin(0.8*tcube) );\n   \n    \n    if(tcube>25.0) mdv += setTranslation( -0.5+ 4.5*sin(tcube)-0.5,-0.5+ 2.5*abs(sin(tcube))-0.9, -2.0-3.*abs(sin(tcube))-0.5 )  \n\t\t       \t\t\t* \n\t\t       \t\t\tsetRotation( 6.1*sin(0.8*tcube), -5., 0.7*sin(0.8*tcube) );\n    \n    // you can manipulate timeline exactly in MC68000 Amiga Demo to make infinite fx !\n    \n    vec2 px = (-iResolution.xy + 2.0*fragCoord) / iResolution.y;\n\n   \n    \n    createCube();\n    \n    \n        \n    \n     vec3 color = vec3( 0.0, 0.0, 0.0 );\n\n    // clear zbuffer\n    float mindist = -1000000.0;\n\n    // render 12 triangles\n    for( int i=0; i<14; i++ )\n    {\n        // transform to eye space\n        vec3 ep0 = (mdv * vec4(triangles[i].a,1.0)).xyz;\n        vec3 ep1 = (mdv * vec4(triangles[i].b,1.0)).xyz;\n        vec3 ep2 = (mdv * vec4(triangles[i].c,1.0)).xyz;\n        vec3 nor = (mdv * vec4(triangles[i].n,0.0)).xyz;\n\n        // transform to clip space\n        float w0 = 1.0/ep0.z;\n        float w1 = 1.0/ep1.z;\n        float w2 = 1.0/ep2.z;\n\n        vec2 cp0 = 2.0*ep0.xy * -w0;\n        vec2 cp1 = 2.0*ep1.xy * -w1;\n        vec2 cp2 = 2.0*ep2.xy * -w2;\n\n        // fetch vertex attributes, and divide by z\n        vec2 u0 = triangles[i].aUV * w0;\n        vec2 u1 = triangles[i].bUV * w1;\n        vec2 u2 = triangles[i].cUV * w2;\n\n        //-----------------------------------\n        // rasterize\n        //-----------------------------------\n\n        // calculate areas for subtriangles\n        vec3 di = vec3( crosse( cp1 - cp0, px - cp0 ), \n\t\t\t\t\t    crosse( cp2 - cp1, px - cp1 ), \n\t\t\t\t\t    crosse( cp0 - cp2, px - cp2 ) );\n\t\t\n        // if all positive, point is inside triangle\n        if( all(greaterThan(di,vec3(0.0))) )\n        {\n            // calc barycentric coordinates\n            vec3 ba = di.yzx / (di.x+di.y+di.z);\n\n            // barycentric interpolation of attributes and 1/z\n            float iz = ba.x*w0 + ba.y*w1 + ba.z*w2;\n            vec2  uv = ba.x*u0 + ba.y*u1 + ba.z*u2;\n\n            // recover interpolated attributes\n            float z = 1.0/iz;\n            uv *= z;\n\n\t\t\t// depth (-1/z) buffer test\n\t\t\tif( z>mindist )\n\t\t\t{\n\t\t\t\tmindist = z;\n\n\t\t\t\t// perform lighting/shading\n\t\t\t\tcolor = pixelShader( nor, uv, z, triangles[i].n );\n\t\t\t}\n        }\n    }\n\n    fragColor += vec4(color,1.0);\n    \n    \n\tfloat time=iTime*1.0;\n\tvec2 uvp = (fragCoord.xy / iResolution.xx-0.5)*8.0;\n     \n\tfloat i0=1.0;\n\tfloat i1=1.0;\n\tfloat i2=1.0;\n\tfloat i4=0.0;\n\tfor(int s=0;s<7;s++)\n\t{\n\t\tvec2 r;\n\t\tr=vec2(cos(uvp.y*i0-i4+time/i1),sin(uvp.x*i0-i4+time/i1))/i2;\n        r+=vec2(-r.y,r.x)*0.3;\n\t\tuvp.xy+=r;\n        \n\t\ti0*=1.93;\n\t\ti1*=1.15;\n\t\ti2*=1.7;\n\t\ti4+=0.05+0.1*time*i1;\n\t}\n    float r=sin(uvp.x-time)*0.5+0.5;\n    float b=sin(uvp.y+time)*0.5+0.5;\n    float g=sin((uvp.x+uvp.y+sin(time*0.5))*0.5)*0.5+0.5;\n\tfragColor += vec4(r,g,b,1.0)/3.0;\n    \n    \n    \n    \n    \n   float t =mod(1.+iTime*20.,180.0);\n\n  q *= 3.0;\n  q.x -=.2;\n  q.y -=.8;  \n\n  if(t>110.) q.y -=0.8-(t/30.)+2.80;     \n    \n  fragColor += char(q-vec2(max(4.2-t,-.2),0.5),83.) .x;      q.x-=.5;\n  \n  fragColor += char(q-vec2(max(4.2-(t-5.),-.2),0.5),72.) .x; q.x-=.5;\n  \n  fragColor += char(q-vec2(max(4.2-(t-10.),-.2),0.5),65.) .x; q.x-=.5;\n    \n  fragColor += char(q-vec2(max(4.2-(t-15.),-.2),0.5),68.) .x; q.x-=.5;\n    \n  fragColor += char(q-vec2(max(4.2-(t-20.),-.2),0.5),69.) .x; q.x-=.5;\n    \n  fragColor += char(q-vec2(max(4.2-(t-25.),-.2),0.5),82.) .x; q.x-=.5;   \n  \n  fragColor += char(q-vec2(max(4.2-(t-30.),-.2),0.5),84.) .x; q.x-=.5; \n    \n  fragColor += char(q-vec2(max(4.2-(t-35.),-.2),0.5),79.) .x; q.x-=.5; \n  \n  fragColor += char(q-vec2(max(4.2-(t-40.),-.2),0.5),89.) .x; q.x-=.5;  \n  \n  \n    \n  float tc=iTime;  \n  if(t>48.) fragColor *= vec4(0.5+0.5*sin(tc*1.2),0.5+0.5*sin(tc*1.4),0.5+0.5*sin(tc*1.8),1.0);\n  \n   \n\n   \n    \n}","name":"Image","description":"","type":"image"}]}