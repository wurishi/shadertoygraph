{"ver":"0.1","info":{"id":"wtsyzf","date":"1592722576","viewed":56,"name":"Final Comps for school","username":"sbrown2","description":"this is just where I'm hosting my final project. It's a path tracer, please feel free to leave comments or help. I appreciate it.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["no"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define pi 3.14159265359\n#define epsi .0001\n#define MAX_T 1000.\nstruct ray {\n\tvec4 origin;\n    vec4 direction;\n};\n    \nstruct pointlight{\n\tvec4 origin;\n    vec3 intensity;\n};\n    \nstruct material{\n\tvec3 color;\n    float specular;\n    float diffuse;\n    float shiny;\n    float ambient;\n};\nstruct sphere{\t \n    vec4 center;\n    mat4 transform;\n    material material;\n};\nstruct intersection{\t \n    float t;\n    sphere object;\n    \n};\nstruct world {\n\tpointlight lightsource;\n    sphere[10] objects;\n};\n    \nvec4 point(float x, float y, float z){return vec4(x,y,z,1.);} \n\nvec4 vector(float x, float y, float z){return vec4(x,y,z,0.);}\n\n\nmat4 rotate(float x,float y,float z){\n\treturn mat4(1,0,0,0,\n                0,cos(x),-sin(x),0,\n                0,sin(x),cos(x),0,\n                0,0,0,1)*mat4(cos(y),0,sin(y),0,\n                              0,1,0,0,\n                              -sin(y),0,cos(y),0,\n                              0,0,0,1)*mat4(cos(z),-sin(z),0,0,\n                                            sin(z),cos(z),0,0,\n                                            0,0,1,0,\n                                            0,0,0,1);\n}\n\nmat4 shearing(float xy,float xz, float yx, float yz, float zx, float zy){\n\treturn mat4(1,xy,xz,0,\n                yx,1,yz,0,\n                zx,zy,1,0,\n                0,0,0,1);\n}\n\nmat4 scaling(float x,float y, float z){\n\treturn mat4(x,0,0,0,\n                0,y,0,0,\n                0,0,z,0,\n                0,0,0,1);\n}\nmat4 translation(float x,float y, float z){\n\treturn mat4(1,0,0,x,\n                0,1,0,y,\n                0,0,1,z,\n                0,0,0,1);\n}\n//takes ray and parameter and returns POINT at parameter\nvec4 position(ray r,float t){\n    vec4 p = r.origin+(t*r.direction);\n\treturn point(p.x,p.y,p.z);\n}\n\nray transform(ray r, mat4 m){\n    return ray(r.origin*m,r.direction*m);\n}\n\nvoid swap(int x, int y, inout intersection array[20]){\n\tintersection temp = array[x];\n    array[x] = array[y];\n    array[y] = temp;\n\n}\n//returns vec2(t1, t2) for the intersection of the ray with sphere\n//if there are no intersections return MAX_T+1\nvoid intersect(ray r, sphere s, inout intersection array[2]){\n    r = transform(r,inverse(s.transform));\n    vec4 s2r = r.origin-point(0.,0.,0.);\n    \n    \n    float a = dot(r.direction,r.direction);\n    float b = 2.*dot(r.direction,s2r);\n    float c = dot(s2r,s2r)-1.;\n    \n    float d = b*b - (4.*a*c);\n    if(d<0.){\n        intersection i1;\n    \tintersection i2;\n        float t1 = MAX_T+1.;\n        float t2 = MAX_T+1.;\n        i1.t = clamp(t1,0.,MAX_T);\n        i1.object = s;\n        i2.t = clamp(t2,0.,MAX_T);\n        i2.object = s;\n        array[0] = i1;\n        array[1] = i2;\n    }\n    \n    float sqd = sqrt(d);\n    \n    intersection i1;\n    intersection i2;\n    float t1 = (-b-sqd)/(2.*a);\n    float t2 = (-b+sqd)/(2.*a);\n    \n    i1.t = t1;\n    i1.object = s;\n    i2.t = t2;\n    i2.object = s;\n    array[0] = i1;\n    array[1] = i2;\n    ;}\n\nvoid intersect_world(ray r, world w, inout intersection array[20]){\n    //for each object in the scene\n    for(int x = 0; x<w.objects.length();x++){\n        \n        //get its intersections\n        intersection this_shape_intersections[2]; \n    \tintersect(r, w.objects[x], this_shape_intersections);\n        \n        //add intersection objects to total intersections list\n        array[2*x] = this_shape_intersections[0];\n        array[2*x+1] = this_shape_intersections[1];\n    }\n    \n    //sort total intersection list by t values\n    \n}\n\n        \nvec4 normal_at(sphere s, vec4 p){\n    vec4 obj_point = p*inverse(s.transform);\n    vec4 obj_norm = obj_point - point(0.,0.,0.);\n    vec4 world_norm = obj_norm*transpose(inverse(s.transform));\n    world_norm.w = 0.;\n    \n    \n\treturn normalize(world_norm);\n\n}\n\nvec4 norm_at(sphere s, vec4 p){\n\treturn p-point(0.,0.,0.);\n}\n\nvec3 lighting(material material,pointlight light,vec4 point,vec4 eyev,vec4 normalv){\n\tvec3 effective_color = material.color*light.intensity;\n    \n    vec4 lightv = normalize(light.origin-point);\n    \n    vec3 ambient = effective_color*material.ambient;\n    float light_dot_normal = clamp(dot(lightv,normalv),0.,1.);\n    \n    float seen = float(light_dot_normal>0.);\n    \n    vec3 diffuse = vec3(0.);\n    vec3 specular = vec3(0.);\n    \n    \n    diffuse = material.diffuse*effective_color*light_dot_normal;\n    vec4 reflectv = reflect(-lightv,normalv);\n    \n    float reflect_d_eye = clamp(dot(reflectv,eyev),0.,1.);\n    float light_reflected = float(reflect_d_eye > 0.);\n\n    float factor = pow(reflect_d_eye, material.shiny);\n    specular = factor*material.specular*light.intensity;\n    \n    \n    return clamp(ambient+(diffuse*seen)+(specular*light_reflected),0.,1.);\n}\n\nvec3 hit(intersection intersections, ray r, pointlight light){\n    if(intersections.t >=0. && intersections.t <=MAX_T){\n    vec4 point = position(r,intersections.t);\n    vec4 normal = normal_at(intersections.object,point);\n    vec4 eye = -r.direction;\n    \n    return lighting(intersections.object.material,light,point,eye,normal);\n        \n    }\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv-=.5;\n\tuv.x *= iResolution.x/iResolution.y;\n    vec3 col = vec3(0.);\n\t\n    //cast ray\n    vec4 origin = point(0.,0.,-5.);\n    vec4 direction = normalize(vector(uv.x,uv.y,1.));\n    \n    ray r;\n    r.origin = origin;\n    r.direction = direction;\n\t\n    //create world of spheres\n    sphere s;\n    s.transform = mat4(1.);\n    material mat;\n    mat.color = vec3(1.,0.,0.);\n    mat.ambient = .1;\n    mat.diffuse = .9;\n    mat.specular = .9;\n    mat.shiny = 200.;\n    s.material = mat;\n    sphere s2 = s;\n    s2.transform = translation(1.,0.,0.);\n    s2.material.specular = .5;\n    s2.material.color = vec3(0.,0.,1.);\n    sphere s3;\n    s3 = s2;\n    s3.material.color = vec3(.7,1.,1.);\n    s3.transform = mat4(1.);\n    s3.transform*=scaling(10.,.01,10.);\n    s3.transform*=translation(0.,-1.,0.);\n    s3.material.color = vec3(.5,.2,1.);\n    sphere s4 = s3;\n    s4.transform*=rotate(pi/2.,0.,0.)*translation(0.,0.,5.);\n    s4.material.color = vec3(1.,.2,.2);\n    sphere s5 = s4;\n    s5.transform=scaling(.1,5.,5.);\n    s5.transform*=translation(2.,0.,0.);\n\ts5.material.color = vec3(1.,.5,.1);\n    intersection intersections[2];\n   \tintersection all_intersections[20];\n    \n\n    sphere scene[5];    \n    scene[0] = s;\n    scene[1] = s2;\n    scene[2] = s3;\n    scene[3] = s4;\n    scene[4] = s5;\n    //create the light\n    pointlight light;\n    light.origin = point(-10.,10.,-10.);\n    light.intensity = vec3(1.);\n    \n    //loop through object array and intersect with each object\n    //if we need to do scene level manipulation we cant\n    intersection closest;\n    closest.t = MAX_T+MAX_T;\n    \n    for(int x = 0; x<scene.length();x++){\n    intersect(r,scene[x],intersections);\n    if(intersections[0].t<closest.t){closest = intersections[0];}\n    \n    col=hit(closest,r,light);\n    }\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}