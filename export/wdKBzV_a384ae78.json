{"ver":"0.1","info":{"id":"wdKBzV","date":"1607566276","viewed":102,"name":"loops","username":"alice","description":"just some circles, working my way through the Book of Shaders\n\nif the code doesn't look right, it's because i wrote it for glslViewer and made it run in shadertoy after the fact (and because i'm learning)","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["2d"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.1415926538\n\n#define shadertoy\n\n#ifndef shadertoy\n#define fragColor gl_FragColor\n#define fragCoord gl_FragCoord\n#define iResolution u_resolution\n#define iMouse u_mouse\n#define iTime u_time\n#endif\n\nuniform vec2 u_resolution;\nuniform vec2 u_mouse;\nuniform float u_time;\n\nmat2 rotate2d(float a) {\n    return mat2(\n            cos(a), -sin(a),\n            sin(a),  cos(a)\n            );\n}\n\nmat2 scale(float n) {\n    return mat2(\n            1./n, 0,\n            0, 1./n\n            );\n}\n\nfloat rand1(vec2 i){\n    return fract(sin(dot(i.xy ,vec2(15.736564920423735,87.35522147781187))) * 43758.5453);\n}\n\nfloat rand2(vec2 i){\n    return fract(sin(dot(i.xy ,vec2(40.76490260423632,57.86582884666819))) * 43758.5453);\n}\n\nfloat rand3(vec2 i){\n    return fract(sin(dot(i.xy ,vec2(14.23444733758451,30.335051567295135))) * 43758.5453);\n}\n\nfloat rand4(vec2 i){\n    return fract(sin(dot(i.xy ,vec2(42.30172930474168,11.00981003611844))) * 43758.5453);\n}\n\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nfloat circle(vec2 c, float r) {\n    float t = 0.18;\n    float circle = (1.-smoothstep(r*0.99, r*1.01, length(c))) * (smoothstep(r*0.89-t, r*1.01-t, length(c)));\n    float halo = pow((1.-length(c))*r*2., 2.);\n    return clamp(circle + halo, 0., 1.);\n}\n\nfloat radius(vec2 gs, float t) {\n    float frequencyMultiplier = rand4(gs) * 1.5 + 0.5;\n    return 0.25 + sin(fract(t*frequencyMultiplier + rand4(gs))*2.*PI)*0.10;\n}\n\nvec3 fgcolor(vec2 gs, float t) {\n    float hue = fract(rand1(gs)*1000.)/4. + 0.7;\n    //hue += fract(t/100.)*2.*PI;\n    float sat = rand3(gs) * 0.5 + 0.5;\n    //return vec3(0);\n    return rand4(gs) > 0.2 ? hsv2rgb(vec3(hue,sat,1.)) : vec3(0);\n}\n\nfloat timesin(float t, float multiplier) {\n    return sin(fract(t*multiplier) * 2.*PI);\n}\n\nvec3 bgcolor(vec2 gs, float t) {\n    float hue = fract(rand2(gs)*1000.)/8. + 0.5;\n    //hue += fract(t/100.)*2.*PI;\n    float lightup = smoothstep(0.25, 0.3, radius(gs,t));\n    float biome = pow(timesin(gs.y, 0.005)*0.5+0.5, 3.);\n    return hsv2rgb(vec3(\n                hue,\n                1.-lightup*0.2,\n                biome*0.4 + rand3(gs)*0.1 + (lightup*(0.3*biome + 0.1))\n                ));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    float time = iTime/2.;\n    float pitch = 60.;\n    vec2 middle = iResolution.xy/2.;\n\n    float weirdness = timesin(time, 0.1) * 0.;\n    float angle = timesin(time, 0.05)/2.;\n    vec2 tc = fragCoord.xy; // transformed coordinates\n    tc -= middle;\n    tc *= rotate2d(angle*mix(1., length(tc/100.)*0.1, weirdness));\n    tc.y *= mix(1., sin(tc.x/40.)*5., weirdness);\n    tc *= scale(timesin(time, .0123) * 0.5 + 1.);\n    tc += middle;\n    tc += vec2(0., time*600.);\n\n    vec2 gs = floor(tc/pitch); // grid square\n    vec2 gc = mod(tc, pitch); // coordinate within the current grid square\n    vec2 nc = gc / pitch;\n    fragColor = vec4(\n            mix(bgcolor(gs, time), fgcolor(gs, time), circle(nc-vec2(.5), radius(gs, time))),\n            1.\n            );\n}\n\n#ifndef shadertoy\nvoid main() {\n    mainImage(fragColor, fragCoord.xy);\n}\n#endif\n","name":"Image","description":"","type":"image"}]}