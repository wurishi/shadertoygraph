{"ver":"0.1","info":{"id":"Xcsfz4","date":"1723462797","viewed":73,"name":"mixed 2D and 3D lighting effects","username":"bitshifter","description":"for each pixel:\nthe scene is raytraced in 3D and gets basic shading effects\nthen light is transformed to 2D where we add the screen effects","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["raytrace"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//#version 300 es\n\n// option to toggle 2D lighting effects\n#define ENABLE_LIGHT2D 1 // disable(0) enable(1)\n\n//#define MIN_DISTANCE 0.00001\n#define MAX_DISTANCE 1.0e+30\n\nstruct Plane {\n  vec3 origin;\n  vec3 normal;\n  vec3 color;\n};\n\nstruct Sphere {\n  float radius;\n  vec3 origin;\n  vec3 color;\n};\n\nstruct AABox {\n  vec3 min;\n  vec3 max;\n  vec3 color;\n};\n\nstruct Intersection {\n  float t;\n  vec3 point;\n  vec3 normal;\n  vec3 color;\n};\n\n// from: https://gist.github.com/Shtille/1f98c649abeeb7a18c5a56696546d3cf\nvec3 normalAtPointOnAABB (AABox aabox, vec3 point) {\n  float eps = -0.001;\n  vec3 hs = (aabox.max - aabox.min) * 0.5;\n  vec3 cb = (aabox.min + aabox.max) * 0.5;\n  vec3 vp = point - cb;\n  return normalize( sign(vp) * step(eps, abs(vp) - hs) );\n}\n\n// from: https://jcgt.org/published/0007/03/04/paper.pdf\nIntersection intersectAABB (vec3 rayOrg, vec3 rayDir, AABox aabox, Intersection info) {\n  vec3 invDir = 1.0 / rayDir;\n  vec3 rMin = (aabox.min - rayOrg) * invDir;\n  vec3 rMax = (aabox.max - rayOrg) * invDir;\n  vec3 vMin = min(rMin,rMax);\n  vec3 vMax = max(rMin,rMax);\n  float tMin = max(vMin.x,max(vMin.y,vMin.z));\n  float tMax = min(vMax.x,min(vMax.y,vMax.z));\n  if (tMax < 0.0) return info; // box is behind\n  if (tMin > tMax) return info; // never intersects\n//float t = (tMin < 0.0) ? tMax : tMin; // tMin<0=inside\n  float t = tMin;\n  if ((t > 0.0) && (t < info.t)) {\n    info.t = t;\n    info.point = rayOrg + rayDir * t;\n    info.normal = normalAtPointOnAABB(aabox, info.point);\n    info.color = aabox.color;\n  }\n  return info;\n}\n\nIntersection intersectSphere (vec3 rayOrg, vec3 rayDir, Sphere sphere, Intersection info) {\n  vec3 v = sphere.origin - rayOrg;\n  float b = dot(v,rayDir);\n  float d = b * b - dot(v,v) + sphere.radius * sphere.radius;\n  if (d < 0.0) return info;\n  float root = sqrt(d);\n  float t = b - root; // tmin\n//if (t < 0.0) t = b + root; // tmax\n  if ((t > 0.0) && (t < info.t)) {\n    info.t = t;\n    info.point = rayOrg + rayDir * t;\n    info.normal = normalize(info.point - sphere.origin);\n    info.color = sphere.color;\n  }\n  return info;\n}\n\nIntersection intersectPlane (vec3 rayOrg, vec3 rayDir, Plane plane, Intersection info) {\n  float c = dot(rayDir, plane.normal);\n  if (c >= 0.0) return info;\n  float d = dot(plane.origin, plane.normal);\n  float t = -(dot(rayOrg, plane.normal) - d) / c;\n  if ((t > 0.0) && (t < info.t)) {\n    info.t = t;\n    info.point = rayOrg + rayDir * t;\n    info.normal = plane.normal;\n    // 1x1 checker pattern\n    float m = abs(floor(info.point.x) + floor(info.point.z));\n    info.color = plane.color * (mod(m,2.0) < 1.0 ? 0.5 : 1.0);\n  }\n  return info;\n}\n\nIntersection intersectScene (vec3 rayOrg, vec3 rayDir)\n{\n  Intersection info;\n  info.t = MAX_DISTANCE;\n//info.point = vec3(...);\n//info.normal = vec3(...);\n  info.color = vec3(0.0, 0.0, 0.0); // black background\n\n  Plane plane = Plane(\n    vec3(0.0,0.0,0.0), // origin\n    vec3(0.0,1.0,0.0), // normal\n    vec3(1.0,1.0,1.0)); // color\n\n  Sphere sphere = Sphere(\n    0.5, // radius\n    vec3(0.0,0.5,0.0), // origin\n    vec3(1.0,1.0,1.0)); // color\n\n  AABox aabox = AABox(\n    vec3(-1.5,0.0,0.5), // min\n    vec3(-0.5,2.0,1.5), // max\n    vec3(1.0,1.0,1.0)); // color\n\n  info = intersectPlane(rayOrg,rayDir,plane,info);\n    \n  info = intersectSphere(rayOrg,rayDir,sphere,info);\n\n  info = intersectAABB(rayOrg,rayDir,aabox,info);\n\n  return info;\n}\n\n\n// matrix operations adapted from:\n// https://www.shadertoy.com/view/ltyXWh\nmat4 translate (vec3 t) {\n  return mat4(\n    vec4(1.0,0.0,0.0,0.0),\n    vec4(0.0,1.0,0.0,0.0),\n    vec4(0.0,0.0,1.0,0.0),\n    vec4(t.x,t.y,t.z,1.0));\n}\n\nmat4 scale (vec3 s) {\n  return mat4(\n    vec4(s.x,0.0,0.0,0.0),\n    vec4(0.0,s.y,0.0,0.0),\n    vec4(0.0,0.0,s.z,0.0),\n    vec4(0.0,0.0,0.0,1.0));\n}\n\nmat4 ortho (float l, float r, float b, float t, float n, float f) {\n  return scale(vec3(2.0/(r-l),2.0/(t-b),2.0/(f-n))) * \n     translate(vec3(-(l+r)/2.0,-(t+b)/2.0,-(f+n)/2.0));\n}\n\nmat4 projection (float n, float f) {\n  return mat4(\n    vec4(n,0.0,0.0,0.0),\n    vec4(0.0,n,0.0,0.0),\n    vec4(0.0,0.0,n+f,1.0),\n    vec4(0.0,0.0,-f*n,0.0));\n}\n\nmat4 perspective (float fov, float aspect, float n, float f) {\n  float l = tan(fov * 0.5) * n;\n  float b = l / aspect;\n  return ortho(-l,l,-b,b,n,f) * projection(n,f) * scale(vec3(1.0,1.0,-1.0));\n}\n\nmat4 lookAt (vec3 eye, vec3 center, vec3 up) {\n  vec3 z = normalize(eye-center);\n  vec3 x = normalize(cross(up,z));\n  vec3 y = normalize(cross(z,x));\n  mat4 m = mat4(\n    vec4(x.x,y.x,z.x,0.0),\n    vec4(x.y,y.y,z.y,0.0),\n    vec4(x.z,y.z,z.z,0.0),\n    vec4(0.0,0.0,0.0,1.0));\n  return m * translate(-eye);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n  vec3 lightColor = vec3(1.0, 0.5, 0.1);\n  // 3D light values\n  float lightPower = 10.0;\n  float lightSpeed = 1.0 * iTime;\n  float lightAngle = mod(lightSpeed, 2.0 * 3.14);\n  vec3 lightOrg = vec3(\n    8.0 * sin(lightAngle),\n    2.0,\n    8.0 * cos(lightAngle)\n  );\n\n  float aspect = iResolution.x / iResolution.y;\n  mat4 projMatrix = perspective(radians(90.0),aspect,0.001,1000.0);\n\n  vec3 rayOrg = vec3(2.0,2.0,15.0);\n  vec3 target = vec3(0.0,0.0,0.0);\n  mat4 viewMatrix = lookAt(rayOrg,target,vec3(0.0,1.0,0.0));\n\n  vec2 ndcPixel = fragCoord.xy / iResolution.xy * 2.0 - 1.0; // [-1..1]\n  vec4 viewDir = inverse(projMatrix) * vec4(ndcPixel, -1.0, 1.0); // view space\n  viewDir.w = 0.0; // project to infinity\n  vec3 rayDir = normalize((inverse(viewMatrix) * viewDir).xyz); // world space\n\n  Intersection info = intersectScene(rayOrg,rayDir);\n\n  if (info.t < MAX_DISTANCE)\n  {\n    //\n    // 3D lighting effects\n    //\n\n    vec3 shadowOrg = info.point;\n    vec3 shadowDir = lightOrg - shadowOrg;\n    float shadowLen2 = dot(shadowDir,shadowDir);\n    float shadowLen = sqrt(shadowLen2);\n    shadowDir /= shadowLen; // normalize\n\n    Intersection shadowInfo = intersectScene(shadowOrg,shadowDir);\n\n    float direct = (shadowInfo.t > shadowLen) ? 1.0 : 0.0;\n    float lambertian = max(0.0, dot(info.normal, shadowDir));\n    float attenuation = lightPower / shadowLen2;\n    float shaders = min(1.0, direct * lambertian * attenuation);\n\n    vec3 shadedColor = lightColor * info.color * shaders;\n    vec3 tonedColor = pow(shadedColor, vec3(1.0 / 2.2));\n\n    info.color = tonedColor;\n  }\n\n#if ENABLE_LIGHT2D\n\n  //\n  // transform 3D light into 2D\n  //\n\n  // world space\n  vec4 lightOrg2D = vec4(lightOrg, 1.0);\n  // view space\n  lightOrg2D = viewMatrix * lightOrg2D;\n  // clip space\n  lightOrg2D = projMatrix * lightOrg2D;\n  // NDC screen space [-1..1]\n  lightOrg2D.xyz /= lightOrg2D.w;\n  // normalized screen space [0..1]\n  lightOrg2D.xy = (lightOrg2D.xy + 1.0) * 0.5;\n  // viewport relative screen space [0..resolution-1]\n  lightOrg2D.xy = lightOrg2D.xy * iResolution.xy - 1.0;\n\n  //\n  // 2D lighting effect\n  //\n\n  float lightSize2D = iResolution.y * 0.25; // scale by screen size\n  lightSize2D /= distance(lightOrg, rayOrg); // scale by view distance\n  float lightDist2D = distance(lightOrg2D.xy, fragCoord.xy);\n  vec3 shadedColor = lightColor * lightSize2D / lightDist2D;\n  vec3 tonedColor = pow(shadedColor, vec3(1.0 / 2.2));\n\n  // combine 3D and 2D color effects (averaged)\n  info.color = min((info.color + tonedColor) * 0.5, vec3(1.0));\n\n#endif // ENABLE_LIGHT2D\n\n  fragColor = vec4(info.color, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}