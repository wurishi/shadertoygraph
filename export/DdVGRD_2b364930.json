{"ver":"0.1","info":{"id":"DdVGRD","date":"1678269561","viewed":177,"name":"Music Sync Effect","username":"adiprk","description":"Cool effect with music sync (:","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["musicpattern"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sXGRr","filepath":"/media/a/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3","previewfilepath":"/media/ap/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3","type":"music","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define S(a, b, t) smoothstep(a, b, t)\n\nfloat Circle(vec2 uv, vec2 pos, float radius, float blur) {\n    float dist = length(uv - pos);\n    float circle = S(radius, radius - blur, dist);\n    return circle;\n}\n\n// Get a pseudo random number\nfloat randNum(vec2 p) {\n    p = fract(p * vec2(142.215, 501.253));\n    p += dot(p, p + 23.45);\n    return fract(p.x * p.y);\n}\n\n// Get the position of a circle given cell id\nvec2 getCirclePos(vec2 id) {\n    float randNum1 = fract(randNum(id));\n    float randNum2 = fract(randNum(id+100.));\n    \n    vec2 pos = vec2(sin(iTime * randNum1), cos(iTime * randNum2)) * 0.4;\n    return pos;\n}\n\n// Get distance of a point to a line\nfloat PointLineDist(vec2 p, vec2 a, vec2 b) {\n    vec2 pa = p-a;\n    vec2 ba = b-a;\n    float t = clamp(dot(pa, ba) / dot(ba, ba), 0., 1.);\n    return length(pa - ba*t);\n}\n\n// Draw a line which fades if it is too long\nfloat DrawLine(vec2 p, vec2 a, vec2 b) {\n    float dist = PointLineDist(p, a, b);\n    float l = S(0.03, 0.01, dist);\n    \n    l *= S(1.2, 0.8, length(b-a));\n    \n    return l;\n}\n\n// Create a layer of circles connected with lines\nvec3 CreateLayer(vec2 uv) {\n    // Initialize color\n    vec3 color = vec3(0);\n    \n    // Grid value and id\n    vec2 gv = fract(uv) - 0.5;\n    vec2 id = floor(uv);\n    \n    // Get circle\n    vec2 circlePos = getCirclePos(id);\n    float circle = Circle(gv, circlePos, 0.1, 0.01);\n    color = vec3(circle);\n    \n    // Draw grid\n    //if (gv.x > 0.49 || gv.y > 0.49 || gv.x < -0.49 || gv.y < -0.49) {\n    //    color = vec3(1., 0., 0.);\n    //}\n    \n    // Add neighbouring cells in grid into a positions array\n    vec2 positions[9];\n    int i = 0;\n    for (float y = -1.; y <= 1.; y++) {\n        for (float x = -1.; x <= 1.; x++) {\n            //float index = (y + 1.) * 3. + (x + 1.));\n            positions[i] = getCirclePos(vec2(id.x+x, id.y+y));\n            positions[i].x += x;\n            positions[i].y += y;\n            i++;\n        }\n    }\n        \n    // Draw line from middle cell to all neighbouring cells\n    for (int i = 0; i < 9; i++) {\n        float line = DrawLine(gv, positions[4], positions[i]);\n        color += line;\n    }\n    \n    // Draw line between the top, bottom, left, and right neighbouring cells\n    color += DrawLine(gv, positions[1], positions[3]);\n    color += DrawLine(gv, positions[3], positions[7]);\n    color += DrawLine(gv, positions[7], positions[5]);\n    color += DrawLine(gv, positions[1], positions[5]);\n    \n    // Return final color\n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord.xy-.5*iResolution.xy) / iResolution.y;\n    \n    // Initialize color\n    vec3 color = vec3(0);\n    \n    // Get audio data\n    float fft = texelFetch(iChannel0, ivec2(0.7, 0), 0).x;\n    \n    // Calculate simulation time\n    float t = (iTime * 0.1) + (0.05 * fft);\n    \n    // Rotate uvs by time\n    float rotAng = cos(t) * 3.;\n    float c = cos(rotAng);\n    float s = sin(rotAng);\n    mat2 rot = mat2(c, -s, s, c);\n    \n    uv *= rot;\n    \n    // Draw four layers of circles and lines\n    for (float i = 0.; i < 1.; i += 1. / 4.) {\n        // Get different z for each layer\n        float z = fract(i + t);\n        \n        // Get size of the layer, big number = smaller circles\n        float layerSize = mix(10., 0.5, z);\n        \n        // Get how much the layer should be faded\n        float fadeIn = S(0., 0.5, z);\n        float fadeOut = S(0.95, 0.75, z);\n\n        // Add layer to color\n        color += CreateLayer(uv * layerSize + i * 20.) * fadeIn * fadeOut;\n    }\n    \n    // Multiply color by a base color to give everything a gradient\n    vec3 baseColor = sin(vec3(0.234, 0.345, 0.456) * t * 5. * ((uv.x+t)/20.)) * 0.4 + 0.6;\n    color *= baseColor;\n    \n    // Set frag color to the final color\n    fragColor = vec4(color, 1);\n}","name":"Image","description":"","type":"image"}]}