{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"#define SPEED\t\t 0.5\n#define BALLS   \t 5\n#define SQRADIUS     10.0\n#define BOUNCES \t 2\n#define EYE_DIST     0.9\n#define Z_FAR\t\t 1000.0\n#define SELF_COLOUR\t 0.5\n#define MELT_AMOUNT\t 0.5\n#define SUN_DIFFUSE\t 0.4\n#define SUN_SPECULAR 0.2\n#define SUN_SHININESS 20.0\n#define FLOOR_AMOUNT 0.7\n\nconst vec3 Bgnd = vec3 (0.05, 0.20, 0.33);\nconst vec3 Sun = vec3 (1.0, 2.0, -2.0)/3.0;  // normalized!\nconst vec3 Floor = vec3 (0.0, -1.0, 0.0);  // ditto!\n\nstruct Ball\n{\n    vec3 M;\n    vec3 C;\n} B[BALLS];\n\nvoid setup (float t)\n{\n    for (int i = 0; i < BALLS; i++)\n    {\n        float fi = float (i);\n        B[i].M.x = 10.0 * sin (0.91*fi + t);\n        B[i].M.y =  5.0 * cos (1.42*fi + t);\n        B[i].M.z = 12.5 + 7.5*sin (2.73*fi + t);\n\n        int mi = int (mod (float (i), float (3)));  // %?\n        if (     mi == 0) B[i].C = vec3 (0.8, 0.0, 0.0);\n        else if (mi == 1) B[i].C = vec3 (0.0, 0.5, 0.0);\n        else              B[i].C = vec3 (0.0, 0.0, 0.9);\n    }\n}\n\nbool ray (vec3 P, vec3 D, out vec3 Q, out vec3 N, out vec3 C)\n{\n    float a = dot (D, D);\n    float p = dot (P, P);\n    vec3 hitM;\n    \n    Q.z = Z_FAR;\n\n    for (int i = 0; i < BALLS; i++)\n    {\n        vec3 M = B[i].M;  // faster? slower?\n        float b = 2.0 * dot (D, (P - M));\n        float c = dot (M, M) - 2.0*dot (M, P) + p - SQRADIUS;\n        float s = b*b - 4.0*a*c;\n\n        if (s >= 0.0)\n        {\n            s = sqrt (s);\n            \n\t        float t1 = (-b + s) / (2.0*a);\n\t        float t2 = (-b - s) / (2.0*a);\n            \n            float z1 = P.z + t1*D.z;\n            float z2 = P.z + t2*D.z;\n            \n            if (z1 < Q.z || z2 < Q.z)\n            {\n                if (z1 < z2)\n                {\n                    Q.x = P.x + t1*D.x;\n                    Q.y = P.y + t1*D.y;\n                    Q.z = z1;\n                }\n                else\n                {\n                    Q.x = P.x + t2*D.x;\n                    Q.y = P.y + t2*D.y;\n                    Q.z = z2;\n                }\n                C = B[i].C;\n                hitM = M;\n            }\n        }\n    }\n    \n    if (Q.z < Z_FAR)\n    {\n        N = Q - hitM;\n        N.x += MELT_AMOUNT*sin (Q.x);\n        N.y += MELT_AMOUNT*sin (Q.y);\n        N.z += MELT_AMOUNT*sin (Q.z);\n        N = normalize (N);\n        return true;\n    }\n    \n    return false;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 P = vec3 (\n        2.0*(fragCoord.x / iResolution.x - 0.5),\n        2.0*(fragCoord.y / iResolution.y - 0.5)*(iResolution.y / iResolution.x),\n        0.0);\n\n    vec3 D = vec3 (P.xy, EYE_DIST);\n    vec3 Q, N;\n\n    vec3 colour;\n    vec3 mixed = vec3 (0.0, 0.0, 0.0);\n    float mx = 1.0;\n\n    setup (iTime*SPEED);\n\n    for (int i = 0; i <= BOUNCES; i++)\n    {\n        if (ray (P, D, Q, N, colour))\n        {\n            float d = dot (N, Sun);\n            \n            if (d > 0.0) \n            { \n                colour += SUN_DIFFUSE * d;\n                colour += SUN_SPECULAR * pow (d, SUN_SHININESS);\n            }\n            \n            d = FLOOR_AMOUNT * dot (N, Floor);\n            if (d > 0.0) colour.g = max (colour.g, d);\n            \n            mixed = mix (mixed, colour, mx);\n            mx *= SELF_COLOUR;\n            P = Q;\n            D = N;\n        } else break;\n    }\n    \n    fragColor = vec4 (mix (mixed, Bgnd, mx), 1.0);\n}\n","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"llsGD7","date":"1422695615","viewed":156,"name":"Simply Trace It","username":"digorydoo","description":"(void *) 0","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raytracingballs"],"hasliked":0,"parentid":"","parentname":""}}