{"ver":"0.1","info":{"id":"wdjczV","date":"1587019970","viewed":138,"name":"Shape Tracer","username":"mjolnir","description":"Trace the paths of the sum of two sets of rotation shapes. Inspired by this: https://i.redd.it/zr7tet9mdfl01.gif","likes":3,"published":1,"flags":32,"usePreview":0,"tags":["shapes","geometry","trace"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float vis0()\n{\n    float t = mod(iTime, VIS_MAX);\n    \n    return max(fade(VIS_0, VIS_1, t), fade(VIS_4, VIS_ABMAX, t));    \n}\n\nfloat vis1()\n{\n    float t = mod(iTime, VIS_MAX);\n    return max(fade(VIS_2, VIS_3, t), fade(VIS_5, VIS_ABMAX, t));\n}\n\nfloat vis2()\n{\n    float t = mod(iTime, VIS_MAX);\n    return (1.0 - ENABLE_TRACE)*fade(VIS_6, VIS_MAX, t) + ENABLE_TRACE;\n}\n\nfloat drawLine(vec2 a, vec2 b, vec2 p)\n{\n    vec2 v = b-a;\n    vec2 w = p-a;\n    \n    float t = dot(v,w)/dot(v,v);\n    \n    float d = 0.0;\n    if (0.0 <= t && t <= 1.0)\n    {\n        d = (LN_SIZE-distance(v*t,w))/LN_SIZE;\n    }\n    \n    return d;\n}\n\nvec3 hsv_to_rgb(float h, float s, float v)\n{\n\tfloat c = v * s;\n\th = mod((h * 6.0), 6.0);\n\tfloat x = c * (1.0 - abs(mod(h, 2.0) - 1.0));\n\tvec3 color;\n\n\tif (0.0 <= h && h < 1.0) {\n\t\tcolor = vec3(c, x, 0.0);\n\t} else if (1.0 <= h && h < 2.0) {\n\t\tcolor = vec3(x, c, 0.0);\n\t} else if (2.0 <= h && h < 3.0) {\n\t\tcolor = vec3(0.0, c, x);\n\t} else if (3.0 <= h && h < 4.0) {\n\t\tcolor = vec3(0.0, x, c);\n\t} else if (4.0 <= h && h < 5.0) {\n\t\tcolor = vec3(x, 0.0, c);\n\t} else if (5.0 <= h && h < 6.0) {\n\t\tcolor = vec3(c, 0.0, x);\n\t} else {\n\t\tcolor = vec3(0.0, 0.0, 0.0);\n\t}\n\n\tcolor.rgb += v - c;\n\n\treturn color;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.y;\n    vec2 pos = uv-vec2(.5*iResolution.x/iResolution.y,0.5);\n    vec2 rawUv = fragCoord/iResolution.xy;\n    \n    vec3 color = vec3(0.0);\n    \n    color = max(color, vec3(texture(iChannel1, rawUv).x)*.6);\n    \n    for (int i0 = 0; i0 < PTS_0; ++i0)\n    {\n        for (int i1 = 0; i1 < PTS_1; ++i1)\n        {\n            vec2 pt = texelFetch(iChannel0, ivec2(i0, i1), 0).xy;\n            //color = max(color, vec3(0, drawDot(pt, pos), 0));\n            \n            vec2 p = vec2(0);\n            vec3 lncolor = vec3(0.0);\n            float ln = 0.;\n            \n            p = texelFetch(iChannel0, ivec2(i0, (i1 + 1) % PTS_1), 0).xy;\n            ln = drawLine(pt, p, pos) * vis0();\n            lncolor = mix(vec3(ln, 0, ln), ln*hsv_to_rgb(iTime+uv.y,1.0,1.0), PRIDE_MODE);\n            color = max(color, lncolor);\n            \n            p = texelFetch(iChannel0, ivec2((i0 + 1) % PTS_0, i1), 0).xy;\n            ln = drawLine(pt, p, pos) * vis1();\n            lncolor = mix(vec3(0, ln, ln), ln*(vec3(1.0)-hsv_to_rgb(iTime-uv.y,1.0,1.0)), PRIDE_MODE);\n            color = max(color, lncolor);\n        }\n        \n    }\n    \n    color = max(color, texture(iChannel2, rawUv).x*hsv_to_rgb(atan(pos.x, pos.y)/TAU + length(pos)*3.f + iTime, 1.0, 0.85)*.5*vis2());\n    \n    fragColor = vec4(1.0-vec3(color),1.0);\n    \n    fragColor *= fragColor;\n    fragColor = vec4(1.0) - fragColor;\n    \n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 px = ivec2(floor(fragCoord));\n    if (all(lessThan(px, ivec2(PTS_0,PTS_1))))\n    {\n    \t\n        float t0 = TAU/float(PTS_0)*float(px.x)+ROT_0;\n        vec2 c0 = vec2(cos(t0)*RAD_0, sin(t0)*RAD_0);\n\n        float t1 = TAU/float(PTS_1)*float(px.y)+ROT_1;\n        vec2 c1 = vec2(cos(t1)*RAD_1, sin(t1)*RAD_1);\n\n        vec2 pt = c0+c1;\n        \n        fragColor = vec4(pt, vec2(0.0));\n    }\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define PT_SIZE (6.0/iResolution.x)\n#define PT_SIZE_SQ (PT_SIZE*PT_SIZE)\n\n#define TRACE_SIZE (1.5/iResolution.x)\n#define TRACE_SIZE_SQ (TRACE_SIZE*TRACE_SIZE)\n\n#define LN_SIZE (2.0/iResolution.x)\n\n#define PI 3.14159265359\n#define TAU (2.0*PI)\n\n#define ROT_RATE 1.25\n#define ROT_G 0.0\n\n\n// Change to 0.0 if you just want some dots\n#define ENABLE_VIS 1.0\n\n#define ENABLE_TRACE 0.0\n\n#define PRIDE_MODE 1.0\n\n// Restart after changing these or your trace will be wrong\n\n// Change PTS_0 to any number >= 1\n#define PTS_0 5\n#define RAD_0 (sin(iTime) / 2.0)\n#define ROT_0 ((ROT_G+iTime/float(PTS_0))*ROT_RATE)\n\n// Change PTS_1 to any number >= 1\n#define PTS_1 7\n#define RAD_1 0.275\n#define ROT_1 ((ROT_G-iTime*2.0/float(PTS_1))*ROT_RATE)\n\n#define VIS_0 1.0  // Time to shape 1\n#define VIS_1 4.0  // Time to end shape 1\n#define VIS_2 5.0  // Time to shape 2\n#define VIS_3 8.0  // Time to end shape 2\n#define VIS_4 9.0  // Time to show shape 1 again\n#define VIS_5 10.0 // Time to show shape 2 again\n#define VIS_ABMAX 16.0 // Time to end both shapes\n#define VIS_6 14.0 // Time to show trace\n#define VIS_MAX 25.0 // Time to end\n\nfloat fade(float a, float b, float t)\n{\n    float r = (t - a) / (b - a);\n    if (0.0 <= r && r <= 1.0)\n    {\n        return sin(r*PI) * ENABLE_VIS;\n    }\n    return 0.0;\n}\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"\nfloat drawDot(vec2 a, vec2 b)\n{\n    return (PT_SIZE_SQ-dot(a-b,a-b))/PT_SIZE_SQ;\n}\n\nfloat drawTrace(vec2 a, vec2 b)\n{\n    return (TRACE_SIZE_SQ-dot(a-b,a-b))/TRACE_SIZE_SQ;\n}\n\nfloat drawLine(vec2 a, vec2 b, vec2 p)\n{\n    vec2 v = b-a;\n    vec2 w = p-a;\n    \n    float t = dot(v,w)/dot(v,v);\n    \n    float d = 0.0;\n    if (0.0 <= t && t <= 1.0)\n    {\n        d = (LN_SIZE-distance(v*t,w))/LN_SIZE;\n    }\n    \n    return d;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.y;\n    vec2 pos = uv-vec2(.5*iResolution.x/iResolution.y,0.5);\n    \n    vec3 color = vec3(0.0);\n    \n    for (int i0 = 0; i0 < PTS_0; ++i0)\n    {\n        for (int i1 = 0; i1 < PTS_1; ++i1)\n        {\n            vec2 pt = texelFetch(iChannel0, ivec2(i0, i1), 0).xy;\n            color = max(color, vec3(drawDot(pt, pos), drawTrace(pt, pos), 0));\n            // could really do the lines here too, but whatever\n        }\n    }\n    \n    fragColor.xyz = color.xyz;\n    \n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    fragColor = vec4(min(texture(iChannel0, uv).y + texture(iChannel1, uv).z,1.0));\n}","name":"Buffer C","description":"","type":"buffer"}]}