{"ver":"0.1","info":{"id":"dtycWD","date":"1704143635","viewed":76,"name":"Path Tracer v2","username":"Mik0","description":"A better path tracer than the first version. Change scene in the objects() function.","likes":1,"published":1,"flags":0,"usePreview":1,"tags":["raytracing","pathtracing","cycles","photorealistic"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float halfPi = acos(0.0);\nconst float pi = acos(0.0)*2.0;\nconst float convert = halfPi/90.0;\nconst float PHI = (1.0+sqrt(5.0))*0.5;\n\nstruct material\n{\n    vec3 color;\n    float roughness;\n    bool emissive;\n    float emissionStrength;\n    float metallic;\n};\n\nstruct hitInfo\n{\n    bool hit;\n    float dist;\n    vec3 hitPos;\n    vec3 normal;\n    material material;\n};\n\nstruct ray\n{\n    vec3 origin;\n    vec3 dir;\n    hitInfo hitInfo;\n};\n\nray cam(vec3 pos, vec2 turn, float zoom, vec2 uv)\n{\n    vec3 forward = vec3(sin((turn.x)*convert)*cos((turn.y)*convert), cos((turn.x)*convert)*cos((turn.y)*convert), sin((turn.y)*convert));\n    vec3 right = vec3(sin((turn.x+90.0)*convert), cos((turn.x+90.0)*convert), 0);\n    vec3 up = vec3(sin((turn.x)*convert)*cos((turn.y+90.0)*convert), cos((turn.x)*convert)*cos((turn.y+90.0)*convert), sin((turn.y+90.0)*convert));\n    vec3 p = (forward*zoom)+(right*uv.x)+(up*uv.y);\n    return ray(pos, normalize(p), hitInfo(false, 9999999., vec3(0), normalize(p), material(vec3(0), 0.0, false, 0.0, 0.0)));\n}\n\nvoid sphere(inout ray ray, vec3 ce, float ra, material mat)\n{\n    vec3 oc = ray.origin - ce;\n    float b = dot( oc, ray.dir );\n    float c = dot( oc, oc ) - ra*ra;\n    float h = b*b - c;\n    if(h>=0.0)\n    {\n        h = sqrt(h);\n        float intersect = -b-h;\n        if(intersect>0.0 && intersect<ray.hitInfo.dist)\n        {\n            vec3 intersection = ray.origin+(ray.dir*intersect);\n            ray.hitInfo = hitInfo(true, intersect, intersection, normalize(intersection-ce), mat);\n        }\n    }\n}\n\nvoid triangle(inout ray ray, in vec3 v0, in vec3 v1, in vec3 v2, material mat)\n{\n    vec3 v1v0 = v1-v0;\n    vec3 v2v0 = v2-v0;\n    vec3 rov0 = ray.origin-v0;\n    vec3 n = cross(v1v0, v2v0);\n    vec3 q = cross(rov0, ray.dir);\n    float d = 1.0/dot(ray.dir, n);\n    float u = d*dot(-q, v2v0);\n    float v = d*dot(q, v1v0);\n    float t = d*dot(-n, rov0);\n    if(u >= 0.0 && v >= 0.0 && (u+v) <= 1.0 && t>0.0 && t<ray.hitInfo.dist)\n    {\n        vec3 normal = normalize(n);\n        if(dot(normal, ray.dir)>0.0){normal*=-1.0;}\n        ray.hitInfo = hitInfo(true, t, ray.origin+(ray.dir*t), normal, mat);\n    }\n}\n\nvoid sky(inout ray ray)\n{\n    if(ray.hitInfo.hit==false)\n    {\n        ray.hitInfo.material.color = vec3(dot(ray.dir, vec3(sin((iMouse.x/iResolution.x*360.0)*convert)*cos((iMouse.y/iResolution.y*(-180.0)+90.0)*convert), cos((iMouse.x/iResolution.x*360.0)*convert)*cos((iMouse.y/iResolution.y*(-180.0)+90.0)*convert), sin((iMouse.y/iResolution.y*(-180.0)+90.0)*convert)))>0.95)*6.0;\n        //ray.hitInfo.material.color = texture(iChannel0, ray.dir.yzx).xyz*texture(iChannel0, ray.dir.yzx).zxy*texture(iChannel0, ray.dir.yzx).yzx*10.0;\n        //ray.hitInfo.material.color = vec3(clamp(ray.dir.z, 0.0, 1.0))*2.0;\n    }\n}\n\nvoid objects(inout ray ray)\n{\n    ray.hitInfo.dist = 9999999.;\n    triangle(ray, vec3(-50, -50, -1), vec3(-50, 50, -1), vec3(50, -50, -1), material(vec3(1, 1, 1), 0.05, false, 0.0, 0.0));\n    triangle(ray, vec3(50, 50, -1), vec3(50, -50, -1), vec3(-50, 50, -1), material(vec3(1, 1, 1), 0.05, false, 0.0, 0.0));\n    sphere(ray, vec3(-1.0, cos(iTime*pi*0.5), 0), 1.0, material(vec3(0.9, 0.2, 0.2), 1.0, false, 0.0, 0.0));\n    sphere(ray, vec3(1.0, cos(iTime*pi*0.5+pi), 0), 1.0, material(vec3(1, 1, 1), 0.0, false, 0.0, 1.0));\n    //sphere(ray, vec3(0.0, 0.0, -3.0), 1.0, material(vec3(1.0, 1.0, 1.0), 1.0, true, 25.0));\n}\n\nvec3 hemisphere(vec3 normal, vec2 uv, float seed)\n{\n    int points = 40962;\n    int i = int(rand(vec3(uv.x, uv.y, seed))*float(points));\n    float dist = float(i)/float(points);\n    float angle = float(i)*pi*PHI;\n    vec3 p = vec3(sin(acos(1.0-(2.0*dist)))*cos(angle), sin(acos(1.0-(2.0*dist)))*sin(angle), 1.0-(2.0*dist));\n    //if(dot(p, normal)<0.0){p = -p;}\n    return normalize(p+normal);\n}\n\nfloat lerp(float a, float b, float t)\n{\n    return (a*(1.0-t))+(b*t);\n}\n\nvec2 lerp(vec2 a, vec2 b, float t)\n{\n    return (a*(1.0-t))+(b*t);\n}\n\nvec3 lerp(vec3 a, vec3 b, float t)\n{\n    return (a*(1.0-t))+(b*t);\n}\n\nfloat fresnel(float cosTheta, float n1, float n2)\n{\n    float R0 = (n1-n2)/(n1+n2);\n    R0*=R0;\n    return R0 + ((1.0-R0)*pow(1.0-cosTheta, 5.0));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    \n    int iters = 512;\n    int bounces = 8;\n    vec3 finalCol = vec3(0);\n    vec3 col;\n    for(int iter = 0; iter<iters; iter++)\n    {\n        vec2 uv = (fragCoord+vec2(rand((fragCoord.x+float(iter))*0.01)-0.5, rand((fragCoord.y+float(iter))*0.01)-0.5))/(iResolution.xy);\n        uv-=0.5;\n        uv.x*=iResolution.x/iResolution.y;\n        ray ray = cam(vec3(0, -5, 1), vec2(0, 0), 0.5, uv);\n        col = vec3(1);\n        float limit = 1.0;\n        for(int i = 0; i<bounces; i++)\n        {\n            ray.hitInfo.hit = false;\n            objects(ray);\n            sky(ray);\n            \n            float roughness;\n            \n            if(ray.hitInfo.hit)\n            {\n                if(rand(vec3(uv.x, uv.y, float(i+iter)*0.98173624))>(1.0-ray.hitInfo.material.metallic)*fresnel(-dot(ray.hitInfo.normal, ray.dir), 1.0, 1.45))\n                {\n                    roughness = lerp(1.0, ray.hitInfo.material.roughness, ray.hitInfo.material.metallic);\n                }\n                else\n                {\n                    roughness = ray.hitInfo.material.roughness;\n                    ray.hitInfo.material.color = lerp(vec3(1.0), ray.hitInfo.material.color, ray.hitInfo.material.roughness);\n                }\n            }\n        \n            col *= vec3(ray.hitInfo.material.color)*float(i+1<bounces);\n            if(!ray.hitInfo.hit)\n            {\n                break;\n            }\n            if(ray.hitInfo.material.emissive)\n            {\n                col *= ray.hitInfo.material.emissionStrength;\n                break;\n            }\n            ray.origin = ray.hitInfo.hitPos+(ray.hitInfo.normal*0.00001);\n            \n            \n            \n            ray.dir = lerp(reflect(ray.dir, ray.hitInfo.normal), hemisphere(ray.hitInfo.normal, uv, float(i+iter)*0.98173624), roughness);\n        }\n        finalCol += col;\n    }\n    \n    vec3 c = finalCol/float(iters);\n    \n    float gamma = 1.2;\n    c.x = pow(c.x, 1.0/gamma);\n    c.y = pow(c.y, 1.0/gamma);\n    c.z = pow(c.z, 1.0/gamma);\n    \n    // Output to screen\n    fragColor = vec4(c/(c+1.0),1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"float rand(float co) { return fract(sin(co*(91.3458)) * 473.55653); }\nfloat rand(vec2 co){ return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 458.5453); }\nfloat rand(vec3 co){ return rand(co.xy+rand(co.z)); }","name":"Common","description":"","type":"common"}]}