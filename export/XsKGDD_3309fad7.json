{"ver":"0.1","info":{"id":"XsKGDD","date":"1454536152","viewed":127,"name":"RT -fnieto -jgan","username":"Wicpar","description":"the RT project\n","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raytracer"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define FOV 90\n\nstruct camera\n{\n    vec3 pos;\n    vec3 ray;\n    vec3 light;\n};\n\nstruct material\n{\n    vec3 color;\n    float gloss;\n   \tfloat metal;\n};\n    \nstruct sphere\n{\n\tvec3 pos;\n    float rad;\n    material mat;\n};\n    \nstruct plane\n{\n    float height;\n    vec3 normal;\n};\n    \nstruct RayResult\n{\n    float t;\n    material mat;\n    vec3 normal;\n};\n   \nstruct cube\n{\n\tfloat rad;\n    vec3 pos;\n    material mat;\n};\n    \nconst int SPHERENUM = 3;\nconst int CUBENUM = 3;\n\nsphere sp[SPHERENUM];\ncube cu[CUBENUM];\nmaterial plastic;\n\nfloat time = iTime;\n\nint iter = 0;\n\nvoid init()\n{\n    plastic.color = vec3(0, 0.9, 0);\n    plastic.metal = 0.1;\n    plastic.gloss = 0.9;\n    for (int i = 0; i < SPHERENUM; ++i)\n    {\n    \tsp[i].pos = vec3(float(i) * 2. - 2., sin(time) -1., 0);\n        sp[i].rad = 1.;\n    \tsp[i].mat = plastic;\n    }\n    for (int i = 0; i < CUBENUM; ++i)\n    {\n    \tcu[i].pos = vec3(float(i) * 3. - float(CUBENUM),  sin(time), 3.);\n        cu[i].rad = 1.;\n    \tcu[i].mat = plastic;\n    }\n}\n\nfloat seed = 0.;\nfloat rand(float f) { \n    return fract(sin(++seed * f)*43758.5453123); \n}\nvec3 light(){\n    return normalize(vec3(sin(time), 0.3, cos(time)));\n}\n\nvec3 background(vec3 rd)\n{\n\tfloat sun = max(0.0, dot(rd, light()));\n\tfloat sky = max(0.0, dot(rd, vec3(0.0, 1.0, 0.0)));\n\tfloat ground = max(0.0, -dot(rd, vec3(0.0, 1.0, 0.0)));\n\treturn \n\t\t(pow(sun, 256.0)+0.2*pow(sun, 2.0))*vec3(2.0, 1.6, 1.0) +\n\t\tpow(ground, 0.5)*vec3(0.4, 0.3, 0.2) +\n\t\tpow(sky, 1.0)*vec3(0.5, 0.6, 0.7);\n}\n\nRayResult spherecol(camera cam, sphere sp)\n{\n    RayResult res;\n    \n\tvec3 rc = cam.pos-sp.pos;\n\tfloat c = dot(rc, rc) - (sp.rad*sp.rad);\n\tfloat b = dot(cam.ray, rc);\n\tfloat d = b*b - c;\n\tfloat t = -b - sqrt(abs(d));\n\tfloat st = step(0.0, min(t,d));\n\tres.t =  mix(-1.0, t, st);\n    res.mat = sp.mat;\n    res.normal = -normalize(sp.pos - (cam.pos+cam.ray*t));\n    return res;\n}\n\nRayResult cubecol(camera cam, cube cu)\n{\n    RayResult res;\n    \n    vec3 tmin = ((cu.pos + cu.rad * sign(cam.ray) * -1.) - cam.pos) / cam.ray;\n    vec3 tmax = ((cu.pos + cu.rad * sign(cam.ray)) - cam.pos) / cam.ray;\n    float mi = max(max(tmin.x, tmin.y), tmin.z);\n    float ma = min(min(tmax.x, tmax.y), tmax.z);\n    res.t = (min(mi, ma) >= 0. ? min(mi, ma) : max(mi, ma));\n    if (ma < mi)\n        res.t = -1.;\n    res.mat = cu.mat;\n    res.normal = normalize(vec3(float(mi == tmax.x)-float(mi == tmin.x),float(mi == tmax.y) -float(mi == tmin.y),float(mi == tmax.z) -float(mi == tmin.z)));\n    return res;\n}\n\nvec3 makeColor2(RayResult r, camera cam)\n{\n    if (r.t < 0.)\n        return background( cam.ray);\n    cam.pos += (r.t - 0.001) * cam.ray;\n    cam.ray = reflect(cam.ray, r.normal);\n    float tomix = (dot(r.normal, cam.ray) * ( 1. - r.mat.metal));\n    vec3 li = cam.light;\n    cam.light = reflect(cam.light, r.normal);\n    return mix(mix(background(cam.ray), vec3(0), 1.- (r.mat.gloss) * dot(li, r.normal)) + (1. - r.mat.gloss)/2. , r.mat.color , tomix);\n}\n\nRayResult rayTrace2(camera cam)\n{\n    RayResult r;\n    \n    r.t = -1.;\n    if (iter > 4)\n        return r;\n    else\n        iter++;\n    for (int i = 0; i < SPHERENUM; ++i)\n    {\n        RayResult new;\n        new = spherecol(cam, sp[i]);\n        if (new.t > 0. && (new.t <= r.t || r.t == -1.))\n            r = new;\n    }\n    for (int i = 0; i < CUBENUM; ++i)\n    {\n        RayResult new;\n        new = cubecol(cam, cu[i]);\n        if (new.t > 0. && (new.t <= r.t || r.t == -1.))\n            r = new;\n    }\n    return r;\n}\n\nvec3 makeColor(RayResult r, camera cam)\n{\n    if (r.t < 0.)\n        return background(cam.ray);\n    cam.pos += (r.t - 0.001) * cam.ray;\n    cam.ray = reflect(cam.ray, r.normal);\n    float tomix = (dot(r.normal, cam.ray) * ( 1. - r.mat.metal));\n    vec3 li = cam.light;\n    cam.light = reflect(cam.light, r.normal);\n    return mix(mix(makeColor2(rayTrace2(cam), cam), vec3(0), 1. - (r.mat.gloss) * dot(li, r.normal)) + (1. - r.mat.gloss)/2. , r.mat.color , tomix);\n}\n\n\nRayResult rayTrace(camera cam)\n{\n    RayResult r;\n    \n    r.t = -1.;\n    if (iter > 4)\n        return r;\n    else\n        iter++;\n    for (int i = 0; i < SPHERENUM; ++i)\n    {\n        RayResult new;\n        new = spherecol(cam, sp[i]);\n        if (new.t > 0. && (new.t <= r.t || r.t == -1.))\n            r = new;\n    }\n    for (int i = 0; i < CUBENUM; ++i)\n    {\n        RayResult new;\n        new = cubecol(cam, cu[i]);\n        if (new.t > 0. && (new.t <= r.t || r.t == -1.))\n            r = new;\n    }\n    return r;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    camera \tcam;\n    \n    cam.pos = vec3(0, 2., -5);\n\tvec2 uv = (-1.0 + 2.0 * fragCoord.xy / iResolution.xy) * vec2(iResolution.x/iResolution.y, 1.0);\n\tcam.ray = normalize(vec3(uv, 1.0));\n    cam.light = light();\n    init();\n\tfragColor = vec4(makeColor(rayTrace(cam), cam), 1.0 );\n}","name":"Image","description":"","type":"image"}]}