{"ver":"0.1","info":{"id":"XcSfR1","date":"1724626346","viewed":83,"name":"La Machine_ (sound)","username":"athibaul","description":"A fun chiptune. Make sure you activate the sound, and rewind to the beginning for synchronization.","likes":24,"published":1,"flags":8,"usePreview":0,"tags":["sound","music","electro","synthesis","fonts","glyphs","harpsichord"],"hasliked":0,"parentid":"4cjfzz","parentname":"La Machine"},"renderpass":[{"inputs":[{"id":"4df3Rr","filepath":"/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","previewfilepath":"/media/ap/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nfloat alchemicalSymbol( vec2 p, vec4 type )\n{\n    // Just making up some imaginary symbols\n    // Inspired by stuff like:\n    // https://en.wikipedia.org/wiki/Alchemical_symbol\n    // https://en.wikipedia.org/wiki/Astrological_symbols\n    \n    // Orientation\n    if(type.w < 0.5)\n        p.y = -p.y;\n    \n    vec2 chargeCenter = vec2(0);\n    float d = 100.;\n    \n    float nBase = 4.5;\n    float nCharge = 4.;\n    float nAdj = 4.;\n    type.xyz *= vec3(1.2*nBase, 2.0*nCharge, 2.0*nAdj);\n    \n    if(type.z < nAdj && type.x < nBase) \n        // If we have a base and adjunction, shift the symbol\n    \tp -= vec2(0., 0.618);\n    if(type.x >= nBase)\n    {\n        // If we have no base, make sure we have a charge (most of the time)\n        // and no adjunction\n        type.y *= 0.6;\n        type.z = nAdj;\n    }\n    \n    // Base symbol\n    if(type.x < 1.)\n    {\n        // Circle\n        d = min(d, abs(length(p) - 1.0));\n    }\n    else if(type.x < 2.)\n    {\n        // Triangle\n        vec2 q = p;\n        if(fract(type.x) >= 0.5)\n        {\n            // Down triangle\n            chargeCenter = vec2(0, 1./3.);\n            q = -p+chargeCenter;\n        }\n        else\n        {\n            // Up triangle\n        \tchargeCenter = vec2(0, -1./3.);\n            q = p-chargeCenter;\n        }\n        q.x = abs(q.x);\n        vec2 q2 = reflect(q, vec2(1./2., sqrt(3.)/2.));\n        q = q2.y < q.y ? q2 : q;\n        \n        q.y += 2./3.;\n        d = min(d, length(max(abs(q)-vec2(2./sqrt(3.),0.), 0.)));\n    }\n    else if(type.x < 3.)\n    {\n        // Diamond\n        vec2 q = abs(p);\n        q = sqrt(0.5) * vec2(q.x+q.y, q.x-q.y);\n        q.x -= sqrt(.5);\n        d = min(d, length(max(abs(q)-vec2(0.,sqrt(.5)), 0.)));\n    }\n    else if(type.x < 4.)\n    {\n        // Moon\n        float orientation = floor(3.0*(type.x-3.));\n        vec2 q = p;\n        if(orientation < 1.)\n        {\n            q = p.yx;\n            chargeCenter += vec2(0.5*0.618, 0.);\n        }\n        else if(orientation < 2.)\n        {\n            q = p;\n        \tchargeCenter += vec2(0., 0.5*0.618);\n        }\n        else\n        {\n            q = -p.yx;\n            chargeCenter += vec2(-0.5*0.618, 0.);\n        }\n        vec2 tip = vec2(0.618,sqrt(1.-0.618*0.618));\n        q = vec2(abs(q.x), q.y);\n        float d1 = (-q.x*tip.y+q.y*tip.x > 0.) ? length(q-tip) : abs(length(q) - 1.0);\n        d = min(d, d1);\n        q -= vec2(0., 0.5*0.618);\n        tip -= vec2(0., 0.5*0.618);\n        d1 = (-q.x*tip.y+q.y*tip.x > 0.) ? length(q-tip) : abs(length(q) - length(tip));\n        d = min(d, d1);\n    }\n    else if(type.x < 4.5)\n    {\n        // 4. \"Ascending/descending node\" - Omega\n        vec2 q = p;\n        float r0 = 1.1;\n        float w1 = 0.6;\n        float r1 = 0.5*0.618;\n        vec2 tip = r0*vec2(w1,sqrt(1.-w1*w1));\n        float orientation = (type.x < 4.5) ? 1.0 : -1.0;\n        chargeCenter = vec2(0,-(1.0-r0+r1)*orientation);\n        vec2 q0 = vec2(q.x, q.y*orientation+(1.0-r0+r1));\n        q = vec2(abs(q0.x), q0.y);\n        bool b = (-q.x*tip.y+q.y*tip.x > 0.);\n        float d1 = b ? length(q-tip) : abs(length(q) - r0);\n        d1 = abs(d1 - r1);\n        vec2 tip2 = tip * (r0+r1)/r0;\n        //d1 = max(d1, length(q-tip2));\n        \n        float l = length(q);\n        if(l > 1. && !b)\n        {\n            d1 = min(l-(1.-r1), length(q - tip2));\n        }\n        \n        d = min(d, d1);\n    }\n    \n    // Charge layered onto the symbol\n    if(type.y < 1.)\n    {\n        // Horizontal stroke\n        p.xy = type.x < nBase ? p.xy : p.yx;\n        d = min(d, length(max(abs(p)-vec2(1.,0.), 0.)));\n    } \n\telse if(type.y < 2.)\n    {\n        // \"Sun\" dot\n        d = min(d, length(p-chargeCenter)-0.15);\n    }\n    else if(type.y < 3.)\n    {\n        // \"Sextile\" / asterisk\n        vec2 q = abs(p - chargeCenter).yx;\n        vec2 q2 = reflect(q, vec2(-0.5, sqrt(3.)/2.));\n        q = (q2.y < q.y) ? q2 : q;\n        d = min(d, length(max(abs(q) - vec2(0.618*0.5,0), 0.)));\n    }\n    else if(type.y < 4.)\n    {\n        // Small triangle\n        vec2 q = (p-chargeCenter)*sign(fract(type.y)-0.5);\n        q.x = abs(q.x);\n        vec2 q2 = reflect(q, vec2(1./2., sqrt(3.)/2.));\n        q = q2.y < q.y ? q2 : q;\n    \t// When applicable, make it a triforce\n        float size = (1.5 < type.x && type.x < 2.0) ? 1. : 0.5;\n        q.y += size/3.;\n        d = min(d, length(max(abs(q)-vec2(size/sqrt(3.),0.), 0.)));\n    }\n    \n    // Adjonction below the symbol\n    vec2 q = p - vec2(0,-1.618);\n    if(type.z < 1.)\n    {\n        // \"Venus\" cross\n        q = abs(q);\n        q.xy = q.x < q.y ? q.xy : q.yx;\n        d = min(d, length(max(abs(q)-vec2(0.,0.618), 0.)));\n    }\n    else if(type.z < 2.)\n    {\n        // \"Mars\" arrow\n        q.x = abs(q.x);\n        d = min(d, length(max(abs(q)-vec2(0.,0.618),0.)));\n        q.y += 0.618;\n        q.xy = sqrt(0.5) * vec2(q.x+q.y, q.x-q.y);\n        q.x -= 0.5*0.618;\n        d = min(d, length(max(abs(q)-vec2(0.5*0.618,0.),0.)));\n    }\n    else if(type.z < 3.)\n    {\n        // \"Mercury\" wings\n        q = vec2(abs(q.x), -q.y);\n        vec2 tip = 0.618*vec2(0.618,sqrt(1.-0.618*0.618));\n        float d1 = (-q.x*tip.y+q.y*tip.x > 0.) ? length(q-tip) : abs(length(q) - length(tip));\n        d = min(d, d1);\n    }\n    else if(type.z < 4.)\n    {\n        // Double underline, 'cause why not?\n        q = abs(q) - vec2(0, 0.618*1./3.);\n        d = min(d, length(max(abs(q) - vec2(0.618,0.), 0.)));\n    }\n    return d;\n}\n\n\nvec2 scale = vec2(0.66*4.0, 4.5);\n\nfloat symbols(vec2 uv, float blur, bool blink)\n{\n    vec2 idx = round(uv/scale);\n    vec2 uv_c = scale*idx;\n    vec2 p = uv - uv_c;\n    \n    float d = alchemicalSymbol(p, hash42(uv_c));\n    \n    // Add horizontal lines\n    d = min(d, abs(abs(p.y) - 0.5*scale.y + 0.2));\n    float thickness = 0.08;\n    \n    // Antialias\n    float dth = max(0.7*length(fwidth(uv)), blur);\n    float x = smoothstep(thickness+dth,thickness-dth, d);\n    \n    if(blink) {\n        // Modify transparency to light rows of letters alternately\n        float off = rand(idx.y);\n        float sgn = 1. - 2. * mod(idx.y,2.);\n        float f = fract(off + sgn * uv.x/scale.x / 16. - 0.5 *iTime);\n        float alpha2 = f * smoothstep(1.0,0.98,f);\n        x *= alpha2;\n    }\n    return x;\n}\n\n\nvec3 scene1(vec2 uv) {\n    // letters in stone\n    float z = 1. + 0.2*uv.y;\n    uv *= z;\n    float th = 0.1 * sin(0.5 * iTime);\n    uv *= mat2(cos(th), sin(th), -sin(th), cos(th));\n    uv.x -= 0.2 * iTime;\n    float symb = symbols(10.*uv, 0.0, false);\n    vec3 col = texture(iChannel0, uv * 0.3).rgb;\n    col *= 1. - 0.5*symb;\n    return col;\n}\n\nvec3 visuArpeggio(float t, vec2 uvs, float alpha, float alpha2, float background) {\n    // Arpeggio pattern: vertical rows of 3 symbols (blueish)\n    vec3 col = vec3(0);\n    vec3 colArp = vec3(0.9,0.9,1);\n    vec3 colArp2 = vec3(0.6,0.9,1);\n    vec2 rectSize = vec2(23,5);\n\n    float it = floor(t / 2.);\n    float t2 = mod(t,2.);\n    float i = mod(floor(t2 * 8.), 3.);\n    float arp0 = floor(t2 / 0.375);\n\n    vec2 arpOrig = round((hash21(3. * arp0 + 30.*it) - 0.5) * rectSize) - vec2(0,1);\n    //float visArp = (arpOrig.y <= idx.y && idx.y <= arpOrig.y + i && idx.x == arpOrig.x) ? 1. : 0.;\n    float visArp = smoothstep(arpOrig.y - 1., arpOrig.y, uvs.y)\n                * smoothstep(arpOrig.y+i+1., arpOrig.y+i, uvs.y)\n                * smoothstep(arpOrig.x-1.5, arpOrig.x, uvs.x)\n                * smoothstep(arpOrig.x+1.5, arpOrig.x, uvs.x);\n    visArp += background;\n    col = mix(col, colArp2, alpha2 * visArp);\n    col = mix(col, colArp, alpha * visArp);\n    return col;\n    \n}\n\nfloat bassEnvelope(float t) {\n    t = max(t,0.);\n    t = mod(t,2.);\n    t = mod(t,1.75);\n    t = mod(t,0.375);\n    return exp(-5.*t);\n}\n\nvec3 blinkStripes(float t, float alpha, float alpha2, vec2 idx, vec2 uvs) {\n    // Make letters blink on horizontal stripes, orange\n    vec3 col0 = vec3(1,0.5,0.1);\n    vec3 col1 = vec3(1,0.1,0.1);\n    vec3 col = vec3(0);\n    float slice = 8.*t + 4. * idx.y - uvs.x - 28.;\n    slice = max(slice, 0.);\n    slice = mod(slice, 32.);\n    float vis = smoothstep(0.,0.1,slice) * smoothstep(16.,0.,slice);\n    col = mix(col, col1, alpha2 * vis);\n    col = mix(col, col0, alpha * vis);\n    return col;\n}\n\nvec3 scene2(vec2 coo, float t) {\n    // One fixed plane of letters\n    float dist = 20.*smoothstep(64.,62.,t);\n    vec2 uv = coo * dist;\n    vec2 uvs = uv/scale;\n    vec2 idx = round(uvs);\n    vec3 col = vec3(0);\n    float z = 2.0;\n    float i = 0.0;\n    float alpha  = symbols(uv, 0.0, false);\n    float alpha2 = symbols(uv, 0.5, false);\n    \n    col = blinkStripes(t-16., alpha, alpha2, idx, uvs);\n    \n    if(t > 32.) {\n        float background = 0.05;\n        background *= smoothstep(16.,20.,t);\n        if(t > 48.) background += bassEnvelope(t) * 0.15;\n        col += visuArpeggio(t, uvs, alpha, alpha2, background);\n    }\n    if(t > 48.) {\n        col += visuArpeggio(t - 16., uvs, alpha, alpha2, 0.);\n        col += visuArpeggio(t + 16., uvs, alpha, alpha2, 0.);\n        col += visuArpeggio(t + 32., uvs, alpha, alpha2, 0.);\n    }\n    \n    return col;\n}\n\nfloat whistleEnv(float t) {\n    float env;\n    t = max(t,0.);\n    t = mod(t,16.);\n    float c = floor(t * .25);\n    t = mod(t,4.);\n    float modamp = 0.5 + smoothstep(0.,1.,t) * step(t,3.) * 3.;\n    float modsig = modamp * sin(TAU*6.*t);\n\n    // Envelope\n    env = smoothstep(2.7,2.5,t) + smoothstep(3.,3.3,t);\n    vec3 d = (c == 0.) ? vec3(0.5,3.7,4.0) :\n             (c == 3.) ? vec3(0.5,2.7,3.0) :\n                         vec3(0.5,3.7,4.0);\n    env *= smoothstep(0.,d.x,t) * smoothstep(d.z,d.y,t);\n    env *= 1. + 0.02 * modsig;\n    return env;\n}\n\n\nvec3 scene3(vec2 uv, float to) {\n    float t = to;\n    float t_warped = t + sqr(max(t - 80., 0.) * 0.8);\n    float t1 = floor(t / 4.) + 1000. * floor(mod(t,4.)/3.);\n    // parallax blinking letters + overlaid single symbol\n    vec2 uv0 = uv;\n    float z = 1. + 0.2*uv.y;\n    uv *= z;\n    float th = 0.1 * sin(t);\n    uv *= mat2(cos(th), sin(th), -sin(th), cos(th));\n    vec2 uv1 = uv;\n    uv.x -= 0.5 * t_warped;\n    uv1.x -= 0.5 * 4. * fract(t/4.) - ((mod(t,4.) > 3.) ? 1. : 0.);\n    uv *= 20.;\n    \n    vec2 uvs = uv/scale;\n    vec2 idx = round(uvs);\n    float alpha = symbols(uv, 0.0, false);\n    float alpha2 = symbols(uv, 0.5, false);\n    //vec3 col = texture(iChannel0, uv * 0.3).rgb;\n    vec3 col = blinkStripes(t_warped, alpha, alpha2, idx, uvs);\n    col += blinkStripes(t_warped, alpha, alpha2, idx, uvs * vec2(-1,1));\n    //col *= 1. - 0.5*symb;\n    \n    //float blur = 0.;\n    // Foreground: single green symbol\n    \n    float sharpness = whistleEnv(t);\n    float blur = (1. - sharpness)*(1.-sharpness);\n    float d = alchemicalSymbol(uv1 * 5., hash41(t1));\n    float fg = smoothstep(0.08 + blur,0.07 - blur, d) * sharpness;\n    float fg2 = smoothstep(0.4 + blur,0.05 - blur, d) * sharpness * 0.5;\n    if(to < 96.) {\n        col = mix(col, vec3(0.5,1.,0.5), fg2);\n        col = mix(col, vec3(0.8,1.,0.9), fg);\n    }\n    \n    return col;\n}\n\nvec3 scene4(vec2 coo, float t) {\n    // Four walls with symbols on each side\n    vec3 col = vec3(0);\n    float th = t * 0.5;\n    coo *= mat2(cos(th), sin(th), -sin(th), cos(th));\n    coo = abs(coo) * 0.3;\n    coo.xy = coo.xy + vec2(1,-1) * coo.yx;\n    float z = 1. / coo.x;\n    vec2 uv = 2.5*scale.y * vec2(z + 10.*t,coo.y*z);\n    float alpha = symbols(uv, 0.0, true);\n    float alpha2 = symbols(uv, 0.5, true);\n    vec2 idx = round(uv / scale);\n    \n    //col = (mod(idx.y,2.)==0. && t > 112.) ? (vec3(1,.5,.1) * alpha + vec3(1.,.5,.1) * alpha2) :\n    col = vec3(1) * alpha + vec3(.5,.8,1.) * alpha2;\n    // Add reflections\n    col *= smoothstep(30.,10.,z);\n    \n    return col;\n}\n\nvec3 scene4b(vec2 coo, float t) {\n    // Four walls with symbols on each side\n    vec3 col = vec3(0);\n    float th = t * 0.5;\n    coo *= mat2(cos(th), sin(th), -sin(th), cos(th));\n    vec2 sgn = sign(coo);\n    coo = abs(coo) * 0.3;\n    coo.xy = coo.xy + vec2(1,-1) * coo.yx;\n    float z = 1. / coo.x;\n    float z0 = 10.*t;\n    vec2 uv = 2.5*scale.y * vec2(z + z0,coo.y*z);\n    float alpha = symbols(uv, 0.0, false);\n    float alpha2 = symbols(uv, 0.5, false);\n    vec2 uvs = uv / scale;\n    vec2 idx = round(uvs);\n    \n    float slice = 8.*t + 4. * idx.y * sgn.y * sgn.x - uvs.x - 28.;\n    slice += sgn.x > 0. ? 20. : 0.;\n    slice += sgn.y > 0. ? 20. : 0.;\n    slice = mod(slice, 40.);\n    float vis = smoothstep(0.,0.1,slice) * (0.5*smoothstep(40.,0.,slice) + 0.6*smoothstep(8.,0.,slice));\n    vis += 0.2 * bassEnvelope(t);\n    vis += smoothstep(152.,156.,t);\n    \n    col = (mod(idx.y,2.)==0.) ? (vec3(1,.5,.1) * alpha + vec3(1.,.5,.1) * alpha2) : vec3(1) * alpha + vec3(.5,.8,1.) * alpha2;\n    col *= vis * smoothstep(30.,10.,z);\n    \n    // Additionally, a single stripe going at the same speed as us\n    float zWhistle = 3.5*smoothstep(0.,0.5,whistleEnv(t));\n    float vis2 = (idx.y == 1.) ? smoothstep(zWhistle+0.1,zWhistle, z) * step(0.,sgn.x)*step(0.,sgn.y) : 0.;\n    col += vec3(0.5,1.,0.5) *alpha2*vis2;\n    col += vec3(0.8,1.,0.9) *alpha*vis2;\n    \n    return col;\n}\n\n\n\nvec3 scene5(vec2 coo, float t) {\n    // Simulate zooming through planes of falling random letters\n    float z0 = fract(0.5*t);\n    float i0 = floor(0.5*t);\n    vec3 col0 = vec3(1,0.5,0.1);\n    vec3 col1 = vec3(1,0.1,0.1);\n    vec3 col = vec3(0);\n    for(float znext = 5.; znext > 0.; znext--) {\n        float z = znext - z0;\n        float i = znext + i0;\n        float alpha  = symbols(15.*coo * z + vec2(30,1)*i, max(0., 0.5-sqrt(z)), true);\n        float alpha2 = symbols(15.*coo * z + vec2(30,1)*i, 0.5, true);\n        float vis = smoothstep(5.,1.,z) * (0.5 + bassEnvelope(t));\n        col = mix(col, col1, alpha2 * vis);\n        col = mix(col, col0, alpha * vis);\n    }\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.*fragCoord-iResolution.xy)/iResolution.y;\n\n    float t = iTime - 2. + t0;\n    if(t < 16.) {\n        fragColor = vec4(scene1(uv), 1) * smoothstep(0.,2.,iTime) * smoothstep(16.,14.,t);\n    } else if (t < 64.) {\n        fragColor = vec4(scene2(uv, t), 1);\n    } else if (t < 96.){\n        fragColor = vec4(scene3(uv, t), 1);\n    } else if (t < 112.) {\n        fragColor = vec4(scene4(uv, t), 1);\n    } else if (t < 128.) {\n        fragColor = vec4(scene5(uv, t), 1);\n    } else if (t < 156.) {\n        fragColor = vec4(scene4b(uv,t), 1);\n    } else {\n        fragColor = vec4(scene1(uv) * smoothstep(164.,160.,t), 1);\n    }\n}\n\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"\n\nconst float bpm = 120.;\nconst float bps = bpm/60.; // beats per second\nconst float beatdur = 1./bps; // beat duration\n\n\nfloat softclip(float x) {\n    return x<-1.?-1.:x>1.?1.:1.5*(1.-x*x/3.)*x;\n}\nfloat varsaw(float p, float formant) {\n    // Sawtooth wave with smoothing\n    float x = mod(p,1.);\n    return (x - 0.5) * softclip(formant*x*(1.-x));\n}\nfloat midi2hz(float n) {\n    return 440.*exp2((n-69.)/12.);\n}\nvec2 pan(float x) {\n    return vec2(1.-x, 1.+x);\n}\n\nfloat curve(float x, float a, float b, float curvature)\n{\n    // When x is on the a-side, outputs 0\n    // When x is on the b-side, outputs 1\n    // When x is between a and b, interpolates.\n    // curvature = 0 -> linear interpolation\n    // Negative curvature gives lower values, positive gives higher values.\n    x = (x-a)/(b-a);\n    x = clamp(x, 0., 1.);\n    return pow(x, exp(-curvature));\n}\n\n\n\nfloat noise(float s){\n    // Noise is sampled at every integer s\n    // If s = t*f, the resulting signal is close to a white noise\n    // with a sharp cutoff at frequency f.\n    \n    // For some reason float(int(x)+1) is sometimes not the same as floor(x)+1.,\n    // and the former produces fewer artifacts?\n    int si = int(floor(s));\n    float sf = fract(s);\n    sf = sf*sf*(3.-2.*sf); // smoothstep(0,1,sf)\n    return mix(rand(float(si)), rand(float(si+1)), sf) * 2. - 1.;\n}\n\nfloat coloredNoise(float t, float fc, float df)\n{\n    // Noise peak centered around frequency fc\n    // containing frequencies between fc-df and fc+df\n    \n    // Assumes fc is an integer, to avoid problems with sin(large number).\n    \n    // Modulate df-wide noise by an fc-frequency sinusoid\n    return sin(TAU*fract(fc*t))*noise(t*df);\n}\n\nvec2 coloredNoise2(float t, float fc, float df)\n{\n    // Noise peak centered around frequency fc\n    // containing frequencies between fc-df and fc+df\n    \n    // Assumes fc is an integer, to avoid problems with sin(large number).\n    \n    // Modulate df-wide noise by an fc-frequency sinusoid\n    return sin(TAU*fract(fc*t))*vec2(noise(t*df),noise(-1000.-t*df));\n}\n\nfloat sweep(float t, float dur)\n{\n    // Exponential sweep from 20kHz to 20Hz in \"dur\" seconds\n    // Running freq: 20000*exp(-t/dt)\n    // freq=20 at t=dur  ==>  20 = 20000*exp(-dur/dt)\n    //                   ==>  exp(-dur/dt) = 1/1000\n    //                   ==>  -dur/dt = log(1/1000)\n    //                   ==>  dt = dur/log(1000)\n    float dt = dur/log(1e3);\n    float intfreq = 20000.*exp(-t/dt)*dt;\n    float phase = TAU*fract(intfreq);\n    float sig = sin(phase);\n    float env = step(0., t) * smoothstep(dur, 0.7*dur, t);\n    return sig*env*0.1;\n}\nfloat triBipolar(float x)\n{\n    // Triangle wave going from -1 to +1, starting at zero, 4-periodic.\n    return 1. - abs(2.-mod(x+1.,4.));\n}\n\nfloat harpNote(float f, float t) {\n    // Harpsichord note, based on variable sawtooth wave\n    t = max(t,0.);\n    float d = sqrt(f/440.); // varying duration and timbre\n    float env = smoothstep(0.,0.001,t);\n    return varsaw(f*t, 50./d*exp(-30.*d*t) + 10./d* exp(-2.*d*t)) * exp(-2.*d*t) * env;\n}\n\nvec2 harpRiff(float t) {\n    // Harpsichord riffs, pattern is determined by code\n    vec2 sig = vec2(0);\n    t = max(t,0.);\n    t = mod(t,16.);\n    float c = floor(t*0.25);\n    float n0 = 64.-round(1.8*floor(t*.25));\n    // offbeat bass note\n    float tb = mod(t-.125,16.);\n    float nb = 64.-round(1.8*floor(tb*.25));\n    sig += harpNote(midi2hz(nb), mod(tb,.25));\n    // upper melody\n    t = mod(t,4.);\n    for(float i=0.; i<16.;i++) {\n        // up/down scales\n        float j = mod(i,8.);\n        j = min(j,8.-j);\n        j = (i==15.)?0.:j;\n        float sc = (c==0.)?1.8:1.7; // major/minor\n        float off = (c==2.)?0.28:0.0; // offset in the scale\n        float n = n0 + 12. - round(sc*j-off);\n        n = (c==3. && i >= 11.) ? 69. + round(1.7*(i-11.)) : n; // end of last phrase\n        float p = (n - 70.) * 0.05;\n        sig += harpNote(midi2hz(n), t - i*0.25) * pan(p);\n    }\n    return sig;\n}\n\nvec2 harpVerb(float t){\n    vec2 sig = vec2(0);\n    sig += 0.1 * harpRiff(t);\n    // Spatialization\n    sig.x += 0.05 * harpRiff(t-0.05).y;\n    sig.y += 0.05 * harpRiff(t-0.04).x;\n    return sig;\n}\n\nvec2 bassNote(float f, float t, float dur) {\n    // Heavy bass, frequency modulation-based\n    vec2 sig = vec2(0);\n    float p = mod(f*t,1.);\n    vec2 p2 = mod((f+vec2(.5,-.5))*t,1.);\n    float env = smoothstep(0.,0.005,t) * smoothstep(dur,dur-0.01,t);\n    sig += sin(TAU*p + (1. + 2.*exp(-5.*t)) * sin(TAU*p));\n    sig += sin(2.*TAU*p2 + 4.*exp(-2.*t)*sin(TAU*p2.yx)) * exp(-3.*t);\n    \n    // Attack\n    t = round(t * 2000.) / 2000.; // distort by quantizing time\n    p2 = mod((f+vec2(.5,-.5))*t,1.);\n    sig += sin(TAU*p2.yx + (10. + 20.*exp(-15.*t) + 50.*exp(-300.*t))*sin(TAU*p)) * exp(-10.*t) * 0.1;\n    \n    return sig * env;\n}\n\nvec2 bassLine(float t) {\n    vec2 sig = vec2(0);\n    t = max(t,0.);\n    t = mod(t,16.);\n    float c = floor(t*0.25);\n    float n = 69. - 36. - round(1.8*c);\n    t = mod(t,2.);\n    float dur = (t < 1.5) ? .5*.75 : .25;\n    t = mod(t,dur);\n    sig += bassNote(midi2hz(n), t, dur);\n    return sig;\n}\n\nvec2 subbassLine(float t) {\n    vec2 sig = vec2(0);\n    t = max(t,0.);\n    t = mod(t,16.);\n    float c = floor(t*0.25);\n    t = mod(t,4.);\n    float n = 69. - 36. - round(1.8*c);\n    float f = midi2hz(n);\n    //vec2 f2 = f + vec2(-0.5,0.5);\n    t = round(t*8000.)/8000.; // lower samplerate\n    sig += sin(TAU*f*t + 0.1 * sin(TAU*t));\n    sig = round(sig * 16.) / 16.; // quantization noise\n    //sig += sin(TAU*2.*f*t + sin(TAU*f*t)) * 0.5;\n    float env = smoothstep(0.,0.01,t) * smoothstep(4.,3.99,t);\n    return sig * env;\n}\n\nvec2 padNote(float f, float t, float dur) {\n    vec2 p2 = mod((f+vec2(1,-1))*t, 1.);\n    vec2 sig = sin(TAU*p2 + sin(TAU*p2.yx));\n    sig = round(10.*sig) / 10.; // add quantization noise\n    float env = smoothstep(0.,0.1,t) * smoothstep(dur,dur-.5,t); //min(1.,exp(-5.*(t-(dur-1.))));\n    env *= 0.5 + 0.5 * smoothstep(0.,2.,t);\n    return sig * env;\n}\n\nvec2 padChord(vec4 nn, float t, float dur) {\n    vec2 sig = vec2(0);\n    sig += padNote(midi2hz(nn.x), t, dur) * pan(-0.8);\n    sig += padNote(midi2hz(nn.y), t, dur) * pan( 0.8);\n    sig += padNote(midi2hz(nn.z), t, dur) * pan(-0.4);\n    sig += padNote(midi2hz(nn.w), t, dur) * pan( 0.4);\n    return sig;\n}\n\nvec2 padLine(float t) {\n    t = max(t,0.);\n    t = mod(t,16.);\n    float c = floor(t*0.25);\n    vec4 chord = (c==0.) ? vec4(57,59,60,64) :\n                 (c==1.) ? vec4(55,57,59,64) :\n                 (c==2.) ? vec4(53,55,57,64) :\n                           vec4(52,56,59,62);\n    vec2 sig = padChord(chord, mod(t,4.), 4.);\n    return sig;\n}\n\nvec2 padVerb(float t) {\n    return padLine(t) + 0.5 * padLine(t - 0.5).yx;\n}\n\n\nfloat arpNote(float f, float t) {\n    // Basic .25 square wave\n    float p = mod(f*t, 1.);\n    return (p < .25) ? 1. : -0.33; // no DC offset\n}\n\nfloat arp1(float t, float off, float transp) {\n    // Looping 3-note arpeggios\n    t = max(t,0.);\n    t = mod(t,16.);\n    float c = floor(t * .25);\n    float n = 57.-round(1.8*c) + transp;\n    t = mod(t,2.);\n    float i = mod(floor(t * 8.), 3.) + off;\n    n += (i == 0.) ? 0. :\n         (i == 1. && c == 0.) ? 3.:\n         (i == 1.) ? 4. : \n         (i == 2.) ? 7. :\n         12.;\n    return arpNote(midi2hz(n), t);\n}\n\nfloat rampIntegral(float x)\n{\n    // Integral of clamp(x,0.,1.).\n    // Used to calculate phase with portamento\n    return (x<=0.) ? 0. : (x < 1.) ? x*x*0.5 : x-0.5;\n}\n\nfloat phasePortamento(float t, float f1, float f2, float t1, float t2)\n{\n    // Integral of frequency of a note with portamento\n    // Transition lasts from t1 to t2, with initial frequency f1 and final frequency f2.\n    // freq(t) = f1 for t < t1\n    // ... = f2 for t > t2\n    // ... = linear interpolation in between\n    \n    \n    // Change of variable : x = (t-t1)/(t2-t1).\n    // dt = (t2-t1)*dx\n    // int freq(t) dt = int freq(t(x)) * (t2-t1) dx\n    // ... = int (f1 + saturate(x)*(f2-f1)) * (t2-t1) dx\n    // ... = f1*t + rampIntegral(x)*(t2-t1).\n    \n    float phase = rampIntegral((t-t1)/(t2-t1)) * (f2-f1) * (t2-t1) + f1*t;\n    phase = mod(phase, 1.);\n    return phase;\n}\n\nfloat whistle(float t) {\n    t = max(t,0.);\n    t = mod(t,16.);\n    float c = floor(t * .25);\n    t = mod(t,4.);\n    vec3 n = (c == 0.) ? vec3(84,88,83) :\n             (c == 1.) ? vec3(83,86,81) :\n             (c == 2.) ? vec3(81,84,83) :\n                         vec3(83, 0, 0);\n    // Pitch glide + vibrato\n    float p = (t < 3.) ? midi2hz(n.x) * t : phasePortamento(t, midi2hz(n.y), midi2hz(n.z), 3.6, 4.);\n    float modamp = 0.5 + smoothstep(0.,1.,t) * step(t,3.) * 3.;\n    float modsig = modamp * sin(TAU*6.*t);\n    float sig = sin(TAU*p + modsig);\n    \n    // Envelope\n    float env = smoothstep(2.6,2.5,t) + smoothstep(3.,3.1,t);\n    vec3 d = (c == 0.) ? vec3(0.1,3.9,4.0) :\n             (c == 3.) ? vec3(0.05,2.9,3.0) :\n                         vec3(0.05,3.995,4.0);\n    env *= smoothstep(0.,d.x,t) * smoothstep(d.z,d.y,t);\n    env *= 1. + 0.02 * modsig;\n    sig *= env;\n    sig += 0.03 * (sig*sig) * (1.+sig); // add some harmonics\n    return sig;\n}\n\nvec2 whistleVerb(float t) {\n    vec2 sig = whistle(t) * pan(-0.5);\n    sig += whistle(t-0.03) * pan(0.5) * 0.3;\n    sig.x += whistle(t-0.25) * 0.15;\n    sig.y += whistle(t-0.5) * 0.15;\n    return sig;\n}\n\nvec2 arp3Verb(float t) {\n    vec2 sig = vec2(0);\n    sig += arp1(t,0.,24.05) * pan(cos(6.*t));\n    sig += arp1(t-0.14,0.,24.10) * pan(cos(6.*t+1.));;\n    sig += arp1(t,1.,24.15) * pan(cos(6.*t+2.));;\n    sig += arp1(t-0.13,1.,24.20) * pan(cos(6.*t+3.));;\n    return sig;\n}\n\nvec2 tomDrum(float te, float f0, float df)\n{\n    float spd = 5.;\n    // Instantaneous frequency\n    float ifreq = f0 + df*exp(-te*spd);\n    // Integrate to obtain\n    float phase = f0*te + df/spd * (1.-exp(-te*spd));\n    \n    float env = smoothstep(0.,0.0005,te) * curve(te, 0.35, 0.0, -1.3);\n    float noiseEnv = smoothstep(0.,0.0005,te) * curve(te, 0.8, 0.0, -2.) * (1. + 5.*curve(te, 0.022,0.0,0.));\n    vec2 sig = vec2(0);\n    \n    sig += triBipolar(4.*phase) * env * 0.15;\n    vec2 noise = (coloredNoise2(te, 1000., 20000.) + coloredNoise2(te, 4500., 6000.));\n    \n    sig += (noise.xx + noise.yy)*0.7 * noiseEnv * 0.03;\n    sig /= 1. + abs(sig);\n    sig += noise.yx * smoothstep(0.,0.05,te) * curve(te, 2.0, 0.0, -2.5) * 0.02; // Fake echo\n    \n    return sig;\n}\n\nvec2 riser(float t, float f0, float f1, float dt) {\n    // instantaneous frequency: f0 * exp(log(f1/f0) * t/dt)\n    // f(t) = f0 * exp(a*t)\n    float a = log(f1/f0)/dt;\n    vec2 p = (f0 + vec2(-1,1)) * exp(a*t) / a;\n    float env = smoothstep(0.,0.01,t) * smoothstep(dt, dt-0.01, t);\n    vec2 sig = 6.*sin(TAU*p);\n    return sin(sig * env) * pan(sin(0.02*p.x));\n}\n\n\n\nvec2 crashCymbal(float t, float atk)\n{\n    float reson = sin(TAU*429.*t + 5.*sin(TAU*1120.*t) + 5.*sin(TAU*1812.*t));\n    vec2 sig = coloredNoise2(t, 7150., 10000.) + 0.1*reson*smoothstep(0.,0.05,t);\n    float env = curve(t, 15.0, 0.0,-3.) * curve(t, 0.0, 0.08, 1.);\n    env *= (1. + smoothstep(0.02,0.0,t) * 2.);\n    env *= (1. - smoothstep(0.0,0.05,t)*smoothstep(0.5,0.0,t) * 0.5);\n    env *= smoothstep(0., atk, t);\n    return sig * env * 0.2;\n}\n\n\nvec2 crashCymbalVerb(float t)\n{\n    vec2 sig = crashCymbal(t, 0.);\n    sig += crashCymbal(t-0.75*beatdur, 0.05).yx * 0.5;\n    sig += crashCymbal(t-1.50*beatdur, 0.10).xy * 0.25;\n    return sig;\n}\n\n\nvec2 tomFill(float t)\n{\n    if(t > 2.) return vec2(0);\n    t = max(t,0.25);\n    float te = mod(t-0.25, 0.75*beatdur);\n    te = (t > 1.5) ? min(te, mod(t, 0.375)) : te;\n    float num = floor(t / (0.75*beatdur));\n    float f0i = 0.;\n    float dfi = (200. - 20.*num)*2.;\n    \n    vec2 sig = vec2(0);\n    sig += tomDrum(te, f0i, dfi);\n    \n    return sig;\n}\n\n\n\nvec2 kick(float t) {\n    t = max(t,0.);\n    t = min(t,2.);\n    float p = 20. * exp(-3.*t);\n    float noi = noise(10000.*t) * (exp(-40.*t) + 3.*exp(-200.*t)) * 0.03;\n    vec2 sig = vec2(0);\n    sig += softclip(sin(TAU*p+noi) * (exp(-20.*t) + exp(-5.*t)));\n    sig += softclip(3. * sin(TAU*2.*p) * (exp(-40.*t) + exp(-10.*t))) * 0.1;\n    return sig;\n}\n\nvec2 kickPattern(float t) {\n    t = max(t,0.);\n    t = mod(t,2.);\n    float dur = (t < 1.5) ? .375 : .25;\n    t = mod(t,dur);\n    return kick(t);\n}\n\nvec2 kickPattern2(float t) {\n    t = max(t,0.);\n    t = mod(t,.5);\n    return kick(t);\n}\n\nvec2 whiteNoiseRiser(float t, float dt) {\n    t = max(0.,t);\n    t = min(t,dt);\n    float env = exp(-10.*(dt-t)/dt) * smoothstep(dt,dt-0.001,t);\n    return coloredNoise(t,6000.,20000.) * env * vec2(1);\n}\n\n\nvec2 fullSong(float t) {\n    vec2 sig = vec2(0);\n    \n    // Intro\n    sig += padVerb(t) * 0.02 * smoothstep(0.,2.,t) * smoothstep(4.,2.,t);\n    \n    t -= 2.;\n    float t1 = mod(t,2.);\n    float dur = (t1<1.5)?.5*.75 : .25;\n    t1 = mod(t1, dur);\n    float pumping = smoothstep(0.,0.02,t1) * smoothstep(0.375,0.0,t1);\n    float pumping2 = smoothstep(0.,0.02,mod(t,.5)) * smoothstep(0.5,0.0,mod(t,.5));\n    pumping = (96. < t && t < 128.) ? pumping : \n             (128. < t && t < 156.) ? pumping2 :\n                                      1.;\n    \n    // Pad\n    if(t < 16. || 32. < t && t < 62. || 80. < t && t < 94. || 128. < t && t < 160.) {\n        float fadeout = 0.9 * smoothstep(0.,0.01,159.-t) + 0.1 * smoothstep(0.,0.1,159.25-t);\n        sig += padVerb(t) * 0.015 * (1.-.3*pumping) * fadeout;\n    }\n    \n    // Whistling\n    if(t < 16. || 64. < t && t < 96. || 128. < t && t < 160.)\n        sig += whistleVerb(t) * 0.03 * (1.-.3*pumping);\n    \n    // Harpsichord\n    if(16. < t && t < 94. || 96. < t && t < 156.)\n        sig += harpVerb(t) * (1. - .3 * pumping);\n    \n    // Chiptune arpeggios\n    if(16. < t && t < 64. || 96. < t && t < 156.)\n        sig += arp1(t,0.,0.) * 0.025 * (1.-.3*pumping) * pan(-0.5);\n    if(32. < t && t < 62. || 80. < t && t < 94. || 96. < t && t < 156.)\n        sig += arp1(t,1.,0.) * 0.025 * (1.-.3*pumping) * pan(0.5);\n    if(64. < t && t < 94. || 96. < t && t < 156.) {\n        sig += arp1(t,0.,12.05) * 0.01 * (1.-.3*pumping) * pan(1.);\n        sig += arp1(t,1.,12.05) * 0.01 * (1.-.3*pumping) * pan(-1.);\n    }\n    if(112. < t && t < 156.) {\n        sig += arp3Verb(t) * 0.006 * (1.-.5*pumping);\n    }\n    \n    // Bass\n    if(48. < t && t < 62. || 64. < t && t < 94. || 96. < t && t < 156.)\n        sig += bassLine(t - 48.) * 0.15 * (1. - 0.5 * pumping);\n    \n    \n    // Subbass\n    if(32. < t && t < 62. || 96. < t && t < 156.)\n        sig += subbassLine(t) * 0.2 * (1. - pumping);\n    \n    // Percussion\n    sig += tomFill(t - 94.) * 0.7;\n    sig += tomFill(t - 126.) * 0.7;\n    sig += crashCymbalVerb(t - 96.) * 0.2;\n    sig += crashCymbalVerb(t - 128.) * 0.2;\n    \n    if(128. < t && t < 156.)\n        sig += kickPattern2(t) * 0.2;\n    \n    // Transitions\n    sig += riser(t - 80., 220., 880.*2., 14.) * 0.01;\n    sig += riser(t - 141., 880., 220., 15.) * 0.012 * (1. - 0.2*pumping);\n    sig += whiteNoiseRiser(t - 148., 8.) * 0.1 * (1. - 0.3*pumping);\n    \n    \n    return sig;\n}\n\nvec2 mainSound( int samp, float t )\n{\n    //return fullSong(t + 2. + 152. - 4.);\n    //return arp3Verb(t) * 0.007;\n    //return subbassLine(t) * 0.2;\n    return fullSong(t + t0);\n    //return kickPattern2(t) * 0.3;\n    //return whiteNoiseRiser(t, 4.) * 0.1;\n}","name":"Sound","description":"","type":"sound"},{"inputs":[],"outputs":[],"code":"#define t0 0.\n#define TAU (2.*3.1415926)\n\n#define sqr(x) (x)*(x)\n\nvec2 hash22(vec2 p)\n{\n    // Hash function by Dave Hoskins\n    // https://www.shadertoy.com/view/4djSRW\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\nvec2 hash21(float p)\n{\n\tvec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nfloat rand(float p)\n{\n    // Hash function by Dave Hoskins\n    // https://www.shadertoy.com/view/4djSRW\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n#define T0(ip) texelFetch(iChannel2, ivec2(mod(ip,256.)), 0).r\n#define rgb(r,g,b) pow(vec3(r,g,b)/255., vec3(2.2))\n\n// Hash functions by Dave Hoskins\n// https://www.shadertoy.com/view/4djSRW\n\nvec4 hash42(vec2 p)\n{\n\tvec4 p4 = fract(vec4(p.xyxy) * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n\n}\n\nvec4 hash41(float p)\n{\n\tvec4 p4 = fract(vec4(p) * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n    \n}","name":"Common","description":"","type":"common"}]}