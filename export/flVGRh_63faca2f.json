{"ver":"0.1","info":{"id":"flVGRh","date":"1637869844","viewed":115,"name":"Ball of lights","username":"TotallyReal","description":"An attempt to visualize the rays of light escaping from some carved spheres.","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["raysoflight"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Increase for better quality of light.\nconst int DUST = 128;\n\n// The color of the rays of light. \nconst vec3 LIGHT_COLOR = vec3(1.6, 1.6, 1.);\n\n// ----------------------------- spheres -----------------------------\n\nconst vec3 BLACK = vec3(0.);\nconst vec3 WHITE = vec3(1.);\n\nstruct Sphere {\n\tfloat r;\t\n    vec3 color;\n};\n\nconst int N = 3;\n\nconst Sphere spheres[N] = Sphere[N](\n    Sphere(30.,    vec3(0.3, 0.0, 0.0)), \n    Sphere(20.,    vec3(0.0, 0.3, 0.1)) ,\n    Sphere(10.,    vec3(0.05, 0.1, 0.25))\n);\n\nconst float minValue = 0.5; // The lower this is, the fuller are the spheres (the components are larger).\nconst float details = 2.5;  // The higher this is, the more components each sphere will have. \n\n// Just a very simple noise function, used to create the components on each sphere.\nfloat snoise3d(vec3 v) {\n    float t = (v.x+2.)*v.y+v.z*v.z*1.4+((cos(v.x*0.42-v.z*1.3)+sin(v.y*0.5-5.*v.x))*cos(v.z+v.y*2.));\n    return t - floor(t);\n}\n\n\n\n\n// ----------------------------- ray hit -----------------------------\n\nconst float MAX_DIST = 1000000000.;\n\nstruct HitInfo {\n    vec3 hitPoint;\n    vec3 normal;\n    float dist;\n    \n    vec3 color;\n};\n\nconst HitInfo NO_HIT = HitInfo(vec3(0.), vec3(0.), MAX_DIST, BLACK);\n\n\nmat3 rotateZ(float angle){\n    return mat3(\n        cos(angle),  sin(angle), 0.,\n        -sin(angle), cos(angle), 0.,\n        0., 0., 1.);\n}\n\n/**\n * Given the origin and direction of the ray, check if it hits the given sphere.\n */\nHitInfo sphereHit(Sphere sphere, float angle, vec3 origin, vec3 direction){\n    float dist = MAX_DIST;\n    // |origin + t*direction|^2 = r^2\n    // |origin|^2 +2t<direction,origin> + t^2 |direction|^2 = r^2\n    vec3 v = origin;                     \n    float a = dot(direction, direction);         \n    float b = 2.*dot(direction,v);               \n    float c = dot(v,v)-sphere.r*sphere.r;                      \n    // solve a*t^2 + b*t + c = 0\n    float disc = b*b-4.*a*c;\n    if (disc<0.)\n        return NO_HIT; // no intersection with the sphere\n        \n    dist = (-b - sqrt(disc))/(2.*a);\n    vec3 hitPoint = (origin + dist*direction);\n    \n    // Use the noise function to decide whether this part of the sphere exists.\n    float x = snoise3d(details*rotateZ(angle)*hitPoint/100.);\n    if (x>minValue)    \n        return HitInfo(hitPoint, normalize(hitPoint), dist, sphere.color);\n        \n    // Didn't hit the \"front\" part of the sphere. Check the back part.\n    dist = (-b + sqrt(disc))/(2.*a);\n    hitPoint = (origin + dist*direction);\n    x = snoise3d(details*rotateZ(angle)*hitPoint/100.);\n    if (x>minValue)  \n        // note that the back part should have more light that the front part.\n        return HitInfo(hitPoint, normalize(hitPoint), dist, sphere.color*1.3); \n        \n    return NO_HIT; // no intersection with the sphere       \n}\n\n\n/**\n * Given the origin and direction of the ray, check if it hits one of the spheres.\n */\nHitInfo sceneHit(vec3 origin, vec3 direction){\n\n    HitInfo info = NO_HIT;\n    float dist = MAX_DIST;\n    for (int i=0; i<N; i++){\n        HitInfo sphereInfo = sphereHit(spheres[i], float(i+1)*iTime/3., origin, direction);\n        if (sphereInfo.dist<dist){\n            info = sphereInfo;\n            dist = sphereInfo.dist;\n        }\n    }\n    \n    return info;\n}\n\n\n\n// ----------------------------- ray color -----------------------------\n\n// Check if there is a line of sight from the given position to the origin.\nbool lineSightToOrigin(vec3 position){\n    HitInfo lightInfo = sceneHit(position, -normalize(position));\n    float len = length(position);\n    return (lightInfo.dist>len);\n}\n\nvec3 rayColor(vec3 origin, vec3 direction){\n\n    // Check if the ray hits one of the spheres.\n    HitInfo info = sceneHit(origin, direction);\n    vec3 color = info.color;\n    \n    // Add the light as if it hits \"dust\" in the way.\n    float dist = min(info.dist, 500.);\n    for (int i=0; i<DUST; i++){\n        vec3 location = origin+dist*(float(1+i)/float(1+DUST))*direction;\n        if (lineSightToOrigin(location))\n            color += LIGHT_COLOR/float(DUST);\n    }\n    return color;\n    \n}\n\n\n// ----------------------------- main -----------------------------\n\nvoid updateCamera(out vec3 origin, out vec3 forward, out vec3 right, out vec3 up){\n    //origin = 100. *vec3(cos(iTime),sin(iTime),0.);\n    origin = 100. *vec3(1.,0.,0.);\n    \n    forward = -origin/100.;\n    right = vec3(forward.y, -forward.x , 0.);\n    up = vec3(0., 0., 1.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 origin, forward, right, up;\n    updateCamera(origin, forward, right, up);\n    \n    \n    vec2 uv = (fragCoord-iResolution.xy/2.)/iResolution.y;\n    \n    vec3 direction = normalize(forward + uv.x*right + uv.y*up);\n    \n    vec3 color = rayColor(origin, direction);\n\n    // Output to screen\n    fragColor = vec4(color ,1.0);\n    \n}","name":"Image","description":"","type":"image"}]}