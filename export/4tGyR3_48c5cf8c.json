{"ver":"0.1","info":{"id":"4tGyR3","date":"1537092608","viewed":162,"name":"try cube volumetric","username":"cailuming","description":"just try to make cube volumetric","likes":5,"published":1,"flags":32,"usePreview":0,"tags":["cubevolumetric"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 cuv = fragCoord/iResolution.xy-vec2(0.5);\n    cuv.x*=iResolution.x/iResolution.y;\n    vec2 uvstep = 1.0/iResolution.xy;\n    \n  \n    vec3 col = vec3(0);\n    vec3 tcol = texture(iChannel0,uv).xyz;\n   \n    \n    col+= texture(iChannel0,uv+vec2(uvstep.x*0.0,0)).xyz*0.1;\n    col+= texture(iChannel0,uv+vec2(uvstep.x*1.0,0)).xyz*0.25;\n    col+= texture(iChannel0,uv+vec2(uvstep.x*2.0,0)).xyz*0.3;\n    col+= texture(iChannel0,uv+vec2(uvstep.x*3.0,0)).xyz*0.25;\n    col+= texture(iChannel0,uv+vec2(uvstep.x*4.0,0)).xyz*0.1;\n    \n    col+= texture(iChannel0,uv+vec2(0,uvstep.y*0.0)).xyz*0.1;\n    col+= texture(iChannel0,uv+vec2(0,uvstep.y*1.0)).xyz*0.25;\n    col+= texture(iChannel0,uv+vec2(0,uvstep.y*2.0)).xyz*0.3;\n    col+= texture(iChannel0,uv+vec2(0,uvstep.y*3.0)).xyz*0.25;\n    col+= texture(iChannel0,uv+vec2(0,uvstep.y*4.0)).xyz*0.1;\n    \n   \n    fragColor = vec4(col/2.0,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4sXGRr","filepath":"/media/a/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3","previewfilepath":"/media/ap/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3","type":"music","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define FAR 64\n#define PI  3.1415926\n\nstruct Ray{\n  vec3 o;\n  vec3 d;\n};\n    \nmat2 rot2D(float arc){\n  float c = cos(arc);\n  float s = sin(arc);\n  return mat2(c,s,-s,c);\n}\n\nvoid setCamera(inout Ray r,vec3 eye,vec3 dir,vec2 uv){\n    vec3 look = normalize(dir-eye);\n    vec3 right = normalize(cross(vec3(0,1,0),look));\n    vec3 up    = normalize(cross(look,right));\n    \n    r.o = eye;\n    r.d = normalize(uv.x*right+uv.y*up+look);\n   \n}\n\nvoid cmp(vec2 a,inout vec2 r){\n    r=r.x<a.x?r:a;\n}\n\nvec2 sphere(vec3 p,vec3 c){\n    p-=c;\n\n    p.xz*=rot2D(-iTime);\n    p.xy*=rot2D(iTime);\n\n    float v = length(abs(p))-1.3;\n            \n    return vec2(v,0);\n}\n\nvec2 ring(vec3 p,vec3 c){\n    p-=c;\n    p.xz*=rot2D(PI*0.5);\n    p.xy*=rot2D(PI*0.5);\n    p.zy*=rot2D(iTime);\n    \n    \n    float v = 0.0;\n    float r =2.5;\n     \n    float arc = atan(p.z,p.x);\n    float arc1 = atan(p.y,p.x);\n    \n    vec3 f = vec3(r*cos(arc),clamp(p.y,0.1,2.0),r*sin(arc));\n    vec3 off = p-f;\n    v = length(off)-1.0;\n    v+=sin(p.x*5.0)*sin(p.y*5.0)*sin(p.z*5.0)*.6;\n    \n    return vec2(v,1);\n}\n\n\nvec2 dice(vec3 p,vec3 c){\n    p-=c;\n    \n    float mdr = 5.0;\n    //p.xz=mod(p.xz,mdr);\n    //p.xz-=mdr*0.5;\n    \n    p.xz*=rot2D(iTime);\n     \n    vec3 f = vec3(clamp(p.x,-1.0,1.0),clamp(p.y,-1.0,1.0),clamp(p.z,-1.,1.0));\n    \n    float v = length(p-f)-0.5;\n    //v+=sin(p.x*10.0)*sin(p.y*10.0)*sin(p.z*10.0)*(0.05+sin(iTime)*0.05);\n    return vec2(v,1);\n}\n\nvec2 ground(vec3 p,vec3 c){\n    p-=c;\n    \n    float v = length(vec3(0,p.y+1.0+sin(p.x)*sin(p.y)*sin(p.z)*0.2,0));\n    return vec2(v,0);\n}\n\n\nvec2 map(vec3 p){\n  vec2 res = vec2(100);\n  cmp(sphere(p,vec3(13,1,30)),res);\n  \n  cmp(ground(p,vec3(0,-1,0)),res);\n  \n  return res;\n}\n\nvoid rayHit(Ray r,inout vec2 res){\n    float t =0.0;\n    \n    for (int i =0;i<FAR;i++){\n        res=map(r.o+t*r.d);\n        if(res.x<=0.0001){\n             break;\n        }\n        t+=res.x;\n    } \n    res=vec2(t,res.y);\n}\n\nvec3 getNormal(vec3 p,float t){\n  vec2 e = vec2(1,0)*0.001*t;\n  float m = map(p).x;\n  return normalize(\n     vec3(\n         map(p+e.xyy).x-m,\n         map(p+e.yxy).x-m,\n         map(p+e.yyx).x-m\n     )\n  );\n    \n}\n \n                          \nvoid doShading(Ray r,vec2 res,vec3 lp,inout vec3 col,vec2 cuv,float lds){\n  vec3 p   = r.o+res.x*r.d;\n  vec3 n   = getNormal(p,res.x);\n  vec3 ld  = normalize(lp-p);\n  vec3 rd  = reflect(-ld,n);\n  vec3 ed  = normalize(r.o-p);\n  vec3 sky = vec3(0.5,0.6,0.7);\n  \n  float nl = smoothstep(-1.0,1.0,dot(n,ld));\n  float rl = smoothstep(-1.0,1.0,dot(rd,ed));\n \n  if(res.y==0.0){\n  \n      col = mix(col,vec3(1.0,0.8,0.4)*(nl+pow(rl,60.0))*(lds+0.2),lds);\n      col =smoothstep(0.,1.0,col);\n      col.x = pow(col.x,0.6);\n       \n  }\n    \n  col=mix(col,vec3(nl),0.5);  \n  col =mix(col,sky*(lds),1.-exp(-res.x*res.x*0.001));\n  \n  /////////////////////////////////the star\n  cuv.y-=0.35;  \n  cuv.x+=0.4;  \n    \n  cuv*=5.0;\n  float v =0.0;;\n  float v1 =0.1/abs(dot(cuv,vec2(0,1)));\n  float lv = smoothstep(-0.0,1.0,lds);  \n  v =0.1*lv/length(cuv);\n  v*=pow(v1,0.2+0.1*lv);\n  \n  col+=v;  \n  \n}  \n\n// cube volumetric test\nvoid drawVolumetric(Ray r,vec3 lp,float lds,inout vec3 col){\n    float t =0.0;\n    vec2 res = vec2(0);\n    float ssv = texture(iChannel0,vec2(0,0)).x;\n    vec3 c =vec3(7.0*cos(iTime),-2.0+ssv*3.0,6.*sin(iTime)+10.);\n    vec3 tp = vec3(0);\n    \n    float v =1.2;\n    \n    float den = 0.1;\n     \n    for (int i =0;i<54;i++){\n        tp = r.o+t*r.d,c;\n        res=dice(tp,c);\n        \n        if(abs(res.x)<=0.5){\n           den+=exp(-(abs(0.8*sin(res.x*0.4)))*t); \n        }else if(t>=20.0){\n           break;\n        }\n        \n        if(t<=0.0){\n           t+=res.x;\n        }else{\n           t+=0.05;\n        }\n        \n    }\n    float dsv = pow(den/40.,1.0);\n    vec3 col1  = vec3(0.8,0.6,1.2);\n    vec3 col2  = vec3(0.5,0.2,0.3);\n     \n    col1 = mix(col1,col2,lds);\n    col = mix(col,col1*v,dsv);\n    \n     \n}\n   \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 cuv = uv-vec2(0.5);\n    float as = iResolution.x/iResolution.y;\n    cuv.x*=as;\n    \n    vec3 eye = vec3(0,2,-5);\n    vec3 dir = vec3(0,0,1);\n    vec3 lp  = vec3(-10,4,50.0);\n    vec2 sv  = vec2(0);\n    vec3 col = vec3(0);\n    float lds = smoothstep(-1.0,1.0,cos(iTime));\n    \n    Ray r;\n\n    setCamera(r,eye,dir,cuv);\n    \n    rayHit(r,sv);\n \n    doShading(r,sv,lp,col,cuv,lds);\n    \n    drawVolumetric(r,lp,lds,col);\n    \n    col = smoothstep(0.3,1.0,col);\n    col.x = pow(col.x,1.2);\n    col.y = pow(col.y,0.7);\n    col.z = pow(col.z,0.8);\n    \n    fragColor = vec4(col,1.0);\n}","name":"Buffer A","description":"","type":"buffer"}]}