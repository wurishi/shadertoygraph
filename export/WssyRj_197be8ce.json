{"ver":"0.1","info":{"id":"WssyRj","date":"1589200450","viewed":149,"name":"blackhole-v4.0","username":"feefi","description":"test","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["blackhole"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n float torus_sdf( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat sphere_sdf(vec3 pos,float r)\n{\n    return length(pos) - r;\n}\nconst float  bh_r = 10.;\nfloat blackhole(vec3 pos)\n{\n    //return sdBox(pos-center,vec3(10.3,10.3,10.3));\n    return sphere_sdf(pos,bh_r);\n}\n\n\nmat2 Rot(float a) {\n    float s = sin(a), c = cos(a);\n    \n    return mat2(c, -s, s, c);\n}\n\nvec2 N22(vec2 id)\n{\n    id = id*vec2(123.1,456.2);\n    id += dot(id,id);\n    return fract(sin(id)*vec2(5.123,123.3));\n}\nfloat N21(vec2 id)\n{\n    id = id*vec2(227.1,125.2);\n    return fract(sin(dot(id,id))*215.3);\n}\nvec2 rPos(vec2 id)\n{\n    return  N22(id) -.5;\n}\nvec3 star(vec2 uv,vec2 id)\n{\n    float l = length(uv);\n    //float l = max(abs(uv.x),abs(uv.y));\n    float center = 0.035/l;\n    float st = center  ;\n\n    float N = N21(id);\n    float Size = N*2.;\n    vec3 color = sin(vec3(0.2,0.5,0.7)*fract(N*73.1)*15.)*0.5+0.5;\n    return st * N * smoothstep(1.,0.,l) * color*vec3(1.0,0.7,Size);\n}\nvec3 starLayer(vec2 uv,float i)\n{\n    vec2 id = floor(uv);\n    uv = fract(uv)-0.5;\n\n    vec3 col = vec3(0.);\n    \n    for(float x = -1.;x<=1.;++x){\n        for(float y = -1.;y<=1.;++y){\n            vec2 nid = id + vec2(x,y);\n            vec2 rpos = rPos(nid+i+1.);   \n            vec2 nuv = uv + rpos - vec2(x,y);         \n            vec3 st = star(nuv,nid);           \n            col += st*fract(cos((i+1.)*100.)*23.1)*2.5;\n        }\n    }\n\n    return col;\n}\n\n//noise texture \nfloat hash(float x){ return fract(sin(x)*152754.742);}\nfloat hash(vec2 x){ return hash(x.x + hash(x.y));}\n\nfloat value(vec2 p, float f) //value noise\n{\n    float bl = hash(floor(p*f + vec2(0.,0.)));\n    float br = hash(floor(p*f + vec2(1.,0.)));\n    float tl = hash(floor(p*f + vec2(0.,1.)));\n    float tr = hash(floor(p*f + vec2(1.,1.)));\n    \n    vec2 fr = fract(p*f);    \n    fr = (3. - 2.*fr)*fr*fr;    \n    float b = mix(bl, br, fr.x);    \n    float t = mix(tl, tr, fr.x);\n    return  mix(b,t, fr.y);\n}\n\n\n\n\n\n\nconst int N = 380;\nconst float Pi = 3.1415926;\nconst vec3 bhp = vec3(0.0,-25.,100);\nvec3 ray_marching(vec3 pos,vec3 dir)\n{\n    vec3 hitpos = pos;\n    float dt=0.2;\n    float hitbh = .0;\n    float hittor = .0;\n    vec3 speed = dir;\n    vec3 torCol = vec3(0.0);\n    vec3 center = bhp+30.5*vec3(sin(0.7*iTime),sin(.5*iTime),0);\n    vec3 glowColor = vec3(0.);\n    for(int i = 0;i<N;++i)\n    {\n        //s = v * t; if hit then break\n        hitpos += speed * dt * (1.0 - hitbh);\n        //blackhole, dectect if photon captured by blackhole\n        float d = blackhole(hitpos-center);\n        hitbh = smoothstep(3.,-3.,d);\n        \n        //disk\n                //rot \n        float rotangle = Pi/18.0;\n        mat3 torRot = mat3(\n            vec3(cos(rotangle),-sin(rotangle),0),\n            vec3(sin(rotangle),cos(rotangle),0),\n            vec3(0,0,1)\n        );\n        vec3 torpos = (torRot*(hitpos-center)) * vec3(1.0,42.,1.02);\n        float tor = torus_sdf(torpos,vec2(35.0,52))/20.;\n\n            //float rc = step(12.,length(p.xz));\n            \n            //col += rc*1000.*;\n        vec3 uvPos = hitpos-center;\n        float v = smoothstep(0.,1.,length(uvPos.xz)/118.);\n        float u = atan(uvPos.z,uvPos.x)/Pi *v -iTime*0.1;\n        \n        vec2 toruv = vec2(u,v)*vec2(2.3,3.1);\n\n        float fadeTor = max(0.,pow(v-0.1,2.));\n        vec3 c1 = vec3(0.9,0.35,0.1);\n        vec3 c2 = vec3(1.0,0.6,0.4);\n        vec3 mainColor = vec3(1.)*mix(c2,c1,fadeTor);\n        float torTex = value(toruv,30.);\n        \n        float hitRange =0.1;\n        float ch = smoothstep(.1,-.5,tor);\n        //if(tor<=hitRange){\n            vec3 c = mainColor  ;\n            c *= max(0.,torTex);\n            c *= 20.8/pow(length(uvPos) - 0. ,1.5);\n            //torCol +=  5.*sin(21.*v)*value(vec2(u,v)* vec2(1.,1.),30.)*vec3(0.8,0.5,0.05)/glow ;\n            //break;\n        //smooth between disk and blackhole\n        //step(d,0.01)\n        float bds = smoothstep(0.,3.,d);\n            torCol += c * ch * (1.0-hitbh) * bds;\n        //}\n        \n        vec3 bhv = torRot*(hitpos-center); \n        //jets \n        float t = iTime;\n        float jet = (0.5*sin(t+sin(t+sin(t+sin(t*2.))))+0.5) ;\n        jet = smoothstep(0.5,0.6,jet);\n        jet = 300.*jet;\n        vec3 jetColor = mix(vec3(0.3,0.3,0.6),vec3(0.6,0.3,0.3),smoothstep(0.,50., abs(bhv.y)));\n        torCol += jetColor \n            * .7/dot(bhv.xz,bhv.xz)*(1.0-hitbh)* step(0.8,1.-hitbh) //jet \n            * smoothstep(jet,0., abs(bhv.y)); //animation\n        \n        //glow\n        \n        glowColor += ( vec3(1.0,0.9,0.7) * (1./dot(bhv,bhv))*1.5)  * (1.0-hitbh);\n        hittor = max(hittor,ch);\n       \n        //photon move forward \n        vec3 b = center-hitpos;\n        float G = (10.5+0.*sin(iTime*1.0));\n        //F = G*(M*m/R^2); a = F/m\n        float l = length(b);\n        float a = G/(l*l);\n        //v = v0+at;\n        speed += a * normalize(b);\n        \n\n    }\n    \n    vec3 bg = starLayer(hitpos.xy/25.0,5.) * (1.0-hitbh)*(1.);\n    vec3 col = bg*0.09 + torCol;\n\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 st = fragCoord.xy/iResolution.xy;\n    st = st * 2.0 - 1.0;  \n    st.x = iResolution.x/iResolution.y*st.x;\n    float angle = iMouse.y/iResolution.y - 0.5;\n    mat2 rot = Rot(Pi/6.);\n    \n    float zoom = 3.;\n    vec3 ro = vec3(0.,85.,-1.0);\n    ro.yz -= bhp.yz;\n    ro.yz = rot * ro.yz;\n    ro.yz += bhp.yz;\n    vec3 lookat = bhp;\n    vec3 f = normalize(lookat - ro);\n    vec3 r = cross(vec3(0,1,0),f);\n    vec3 u = cross(f,r);\n    vec3 sd = ro + f * zoom + st.x * r + st.y * u;\n    vec3 rd = sd - ro;\n    \n    vec3 color = ray_marching(ro, rd);\n    fragColor = vec4(color,1.0);\n}\n","name":"Image","description":"","type":"image"}]}