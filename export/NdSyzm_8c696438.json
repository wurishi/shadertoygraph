{"ver":"0.1","info":{"id":"NdSyzm","date":"1643248032","viewed":144,"name":"Accelerated ray marching","username":"LucasR","description":"Iteration count of traditional ray marching (left of mouse) and accelerated ray marching (right of mouse). Darker is better. Based on https://www.researchgate.net/publication/329152815_Accelerating_Sphere_Tracing","likes":9,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","optimization","acceleratedraymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// You can click on the screen to move the division\n\n// At the bottom of the code you can uncomment the last line to see there's\n// no difference in the calculated distances.\n\n// You can also play with the relaxation constant omega (w)\n\nconst int MAX_MARCHING_STEPS = 128;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.;\nconst float PRECISION = 0.001;\nconst float infty = 9999999.;\n\nstruct surf{ // surface\n    float sd; // signed distance\n    int mat; // material ID\n    int iter; // number of iterations taken\n};\n\nsurf minSurf(surf s1, surf s2){\n    if(s2.sd < s1.sd) return s2;\n    return s1;\n}\n\n// ***** SDF definitions *****\n\nfloat sdSphere(vec3 p, float r, vec3 offset){\n    return length(p - offset) - r;\n}\n\nfloat sdPlane(vec3 p, vec3 n, float h){\n    return dot(p, n) + h; // n must be normalized\n}\n\nfloat sdBox(vec3 p, vec3 b, vec3 offset){\n    p = p - offset;\n    vec3 q = abs(p) - b;\n    float d = length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n    return d;\n}\n\n// ***** end SDF definitions *****\n\nsurf sdScene(vec3 p){\n    surf scene = surf(sdPlane(p, vec3(0., 1., 0.), 2.5), 1, 0);\n    scene = minSurf(scene, surf(sdSphere(p, .5, vec3(-.8, 0., 0.)), 2, 0));\n    scene = minSurf(scene, surf(sdBox(p, vec3(1.), vec3(1.5, 0., -3.)), 3, 0));\n    return scene;\n}\n\nsurf rayMarch(vec3 ro, vec3 rd, float start, float end){ // traditional implementation\n    float depth = start;\n    surf co; // closest object\n    \n    for(int i = 0; i < MAX_MARCHING_STEPS; i++){\n        co = sdScene(ro + depth*rd);\n        depth += co.sd;\n        co.iter = i;\n        if(co.sd < PRECISION || depth > end) break;\n    }\n    co.sd = depth;\n    if(depth > end) co.sd = end;\n    return co;\n}\n\nsurf accRayMarch(vec3 ro, vec3 rd, float start, float end, float w){ // accelerated ray marching\n    float rp = 0.; // previous r -- r_{i-1}\n    float ri = 0.;\n    float rn = infty; // next r -- r_{i+1}\n    float d = 0.;\n    float t = start;\n    vec3 p = ro;\n    surf co; // closest object\n    \n    for(int i = 0; i < MAX_MARCHING_STEPS; i++){\n        co = sdScene(p+(t+d)*rd);\n        rn = co.sd;\n        if(d > ri+rn){\n            d = ri;\n            co = sdScene(p+(t+d)*rd);\n            rn = co.sd;\n        }\n        t += d;\n        rp = ri;\n        ri = rn;\n        d = ri + w*ri*(d-rp+ri)/(d+rp-ri);\n        co.iter = i;\n        if(rn < PRECISION || t > end) break;\n    }\n    co.sd = t;\n    if(t > end) co.sd = end;\n    return co;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec2 uv = (fragCoord - .5 * iResolution.xy) / iResolution.y;\n    \n    float w = .6; // omega, relaxation constant\n    \n    vec3 ro = vec3(0., 0., 3.);\n    vec3 rd = normalize(vec3(uv, -1.));\n    surf co;\n    vec2 mouse = (iMouse.xy - .5 * iResolution.xy) / iResolution.y;\n    float div = 0.;\n    if(iMouse.z > 0.) div = mouse.x;\n    if(div > uv.x) co = rayMarch(ro, rd, MIN_DIST, MAX_DIST);\n    else co = accRayMarch(ro, rd, MIN_DIST, MAX_DIST, w);\n    \n    vec3 col = vec3(float(co.iter)/float(MAX_MARCHING_STEPS)); // number of iterations (darker is better)\n    //col = vec3(log(co.sd)/10.); // distance (should be the same on both sides)\n    \n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}