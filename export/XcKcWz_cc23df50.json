{"ver":"0.1","info":{"id":"XcKcWz","date":"1731780522","viewed":26,"name":"3d MetaSpheres","username":"I_m_not_here","description":"Trying some 3D meta spheres","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["metaballs"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float iTime2 = iTime + 50.;\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec2 oldUV = uv;\n    uv = uv*2. - vec2(1.);\n    uv.x *= iResolution.x/iResolution.y;\n    oldUV.x *=  iResolution.x/iResolution.y;\n    \n    \n    Sphere[] spheres = Sphere[] (Sphere(vec3(sin(iTime2/2.),cos(iTime2/4.),2),0.3, vec4(0.2,0.5,0.8,1)),\n    Sphere(vec3(sin(iTime2/5.+1.)*0.3,sin(iTime2/4.+2.)*0.1,3),0.8, vec4(1,0.5,0.2,1)),\n    Sphere(vec3(sin(iTime2/3.+4.),sin(iTime2/2.+3.),sin(iTime2/5.)+3.),0.2, vec4(0.7,1.9,0.4,1)),\n    Sphere(vec3(cos(iTime2/7.+5.),sin(iTime2/3.+1.),cos(iTime2/2.+2.)+2.),0.4, vec4(0.7,0.4,1.9,1)),\n    Sphere(vec3(sin(iTime2/2.+2.),cos(iTime2/4.+6.),sin(iTime2+2.)*0.5+2.),0.4, vec4(1.9,0.1,0.3,1)));\n    \n    \n    float t = iTime2/10.;\n    float camDistance = 4.5;\n    if (iMouse[2] > 0.)\n    {\n        t-=iMouse[0]/iResolution.x * 6.283 + 3.1415;\n        camDistance *= iMouse[1]/iResolution.y * 3.;\n    }\n    \n    vec2 AAsizes = vec2(2./iResolution.x,2./iResolution.y);\n    vec3 color = RunRay(uv + vec2(AAsizes.x,AAsizes.y), spheres, t, oldUV, iTime2, camDistance);\n    color += RunRay(uv + vec2( AAsizes.x,-AAsizes.y), spheres, t, oldUV, iTime2, camDistance);\n    color += RunRay(uv + vec2(-AAsizes.x,-AAsizes.y), spheres, t, oldUV, iTime2, camDistance);\n    color += RunRay(uv + vec2(-AAsizes.x, AAsizes.y), spheres, t, oldUV, iTime2, camDistance);\n    \n    fragColor = vec4(color/4.,1);\n    \n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define DOSPACEDEFORMATION\n\nstruct Sphere {\n    vec3 pos;\n    float radius;\n    vec4 color;\n};\n\nfloat SDF(Sphere sphere, vec3 pos){\n    return length(pos-sphere.pos)-sphere.radius;\n}\n\nfloat smin(float a, float b, float k) {\n    float h = clamp(0.5 + 0.5*(a-b)/k, 0.0, 1.0);\n    return mix(a, b, h) - k*h*(1.0-h);\n}\n\nvec3 GetColor(Sphere[5] spheres, vec3 pos)\n{\n    vec4 color = vec4(1);\n    float weight = 0.000001;\n    for (int j = 0; j < 5; j++)\n    {\n        float current_weight = 1./(length(spheres[j].pos - pos)*500.+1.);\n        color = (color * weight + spheres[j].color * current_weight)/(weight + current_weight);\n        weight += current_weight;\n    }\n    return color.rgb;\n}\nvec3 GetTrueColor(Sphere[5] spheres, vec3 pos)\n{\n    vec4 color = vec4(1);\n    float weight = 0.000001;\n    for (int j = 0; j < 5; j++)\n    {\n        float current_weight = 1./((length(spheres[j].pos - pos)-spheres[j].radius/2.)*500.+1.);\n        color = (color * weight + spheres[j].color * current_weight)/(weight + current_weight);\n        weight += current_weight;\n    }\n    return color.rgb;\n}\nvec3 GetLitColor(Sphere[5] spheres, vec3 pos)\n{\n    vec4 color = vec4(0);\n    for (int j = 0; j < 5; j++)\n    {\n        float weight = 1./(pow(length(spheres[j].pos - pos),8.)+1.);\n        color += spheres[j].color * weight;\n    }\n    return color.rgb;\n}\nvec3 GetRayPos(vec2 uv, float degree, vec3 focusPoint, float camDistance)\n{\n    return focusPoint + vec3(cos(degree),0,sin(degree))*-camDistance;\n}\nvec3 GetRayDir(vec2 uv, float degree)\n{\n    float FOVfactor = 0.6;\n    vec3 canvasPoint = vec3(sin(degree),0,cos(degree)) + vec3(uv.x * FOVfactor * cos(degree),uv.y * FOVfactor,uv.x * FOVfactor * sin(-degree));\n    return normalize(canvasPoint);\n\n}\nvec3 BackgroundColor(vec3 rayDir)\n{\n    float yaw = (atan(rayDir.z/rayDir.x)+3.1415/2.) * 2.;\n    float pitch = (atan(rayDir.y)+3.1415/2.) * 2.;\n    float y = sin(90.*yaw);\n    float p = sin(90.*pitch);\n    float brightness = 0.2 + 0.01*(pow(abs(y),1./20.)*sign(y)) + 0.1 + 0.01*(pow(abs(p),1./20.)*sign(p));\n    return vec3(0.5 / brightness,0.3 * brightness,0.8 * brightness * brightness);\n}\n\n\nstruct Circle { \n    float radius; \n    vec2 center; \n}; \n\n\nfloat SDF2(Circle circle, vec2 pos)\n{\n    float dist = 0.019/(abs(length(pos-circle.center)-circle.radius)+0.01);\n    if (dist < 0.01){\n    return 0.;\n    }\n    return dist;\n}\n\nvec3 ChaosBackground(vec2 uv, float iTime)\n{\n    float mixFactor =  sin(iTime*2.)*0.5 + 0.5;\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    \n    //uv *= floor(abs(sin(iTime)*3.0))+1.0;\n    vec2 oldUV = uv;\n    //uv = fract(uv);\n    float factor = 1.0f;\n    \n    Circle circle1 = Circle( mod(iTime, 3.5)/1.1, vec2(0.5, 0.8));\n    Circle circle2 = Circle(mod(iTime, 3.5)/1.2, vec2(1, 0.2));\n    Circle circle3 = Circle(mod(iTime, 3.5)/1.3, vec2(-0.5, 0.4));\n    \n    Circle circle4 = Circle( mod(iTime + 1.75, 3.5)/1.1, vec2(0, 0));\n    Circle circle5 = Circle(mod(iTime + 1.75, 3.5)/1.2, vec2(1, 0.3));\n    Circle circle6 = Circle(mod(iTime + 1.75, 3.5)/1.3, vec2(-0.5, -0.3));\n    \n    Circle circle7 = Circle( mod(iTime + 1., 5.)/1.1, vec2(-0.1, 0));\n    Circle circle8 = Circle(mod(iTime + 1., 5.)/1.5, vec2(0.3, 0.2));\n    Circle circle9 = Circle(mod(iTime + 1., 5.)/1.6, vec2(0.4, -0.2));\n    // Time varying pixel color\n    vec3 col1 = vec3(0,0,0);\n    \n    for (float i = 0.0; i < 6.0; i++){\n        float val = pow(0.5,i);\n        col1 += vec3(0.8,0.5,0.1f) *(SDF2(circle1, uv)+SDF2(circle2, uv)+SDF2(circle3, uv)\n                     +SDF2(circle4, uv)+SDF2(circle5, uv)+SDF2(circle6, uv)\n                     +SDF2(circle7, uv)+SDF2(circle8, uv)+SDF2(circle9, uv)) * val;\n        uv*=2.0;\n        uv -= vec2(factor);\n        uv = fract(uv);\n        for (float j = 0.; j < 1.+abs(floor(uv.x/val)) + abs(floor(uv.y/val)); j++)\n        {\n            uv.xy = uv.yx;\n            uv.x *= -1.0;\n        }\n        \n        factor*=2.0;\n    }\n    uv = oldUV;\n    vec3 col2 = vec3(0,0,0);\n    for (float i = 0.0; i < 6.0; i++){\n\n        col2 += vec3(0.8,0.3,0.2f) *(SDF2(circle1, uv)+SDF2(circle2, uv)+SDF2(circle3, uv)\n                     +SDF2(circle4, uv)+SDF2(circle5, uv)+SDF2(circle6, uv)\n                     +SDF2(circle7, uv)+SDF2(circle8, uv)+SDF2(circle9, uv)) * pow(0.5,i);\n        uv*=2.0;\n        uv -= vec2(factor);\n        uv = fract(uv);\n        uv.xy = uv.yx;\n        uv.x *= -1.0;\n        uv.x = uv.y;\n        factor*=2.0;\n    }\n    \n    \n    // Output to screen\n    return -vec3(0.2,0.2,0.2) + col1 * mixFactor + col2 * (1.-mixFactor);\n}\nfloat RealSDF(Sphere[5] spheres, vec3 rayPos, float iTime)\n{\n#ifdef DOSPACEDEFORMATION\n    rayPos.y += 0.2 * (sin(rayPos.z*4.)+sin(rayPos.x*4.));\n#endif\n\n#define ZERO min(iTime,0.) // non-constant zero\n\n    float dist = SDF(spheres[0], rayPos);\n    for (int j = 1; j < 5; j++){\n        dist = smin(dist,SDF(spheres[j], rayPos),0.4 + ZERO);\n    }\n    return dist;\n}\nvec3 GetNormal(Sphere[5] spheres, vec3 rayPos, float iTime)\n{\n#define ZERO min(iTime,0.) // non-constant zero\n    float eps = 0.0001;\n    vec2 h = vec2(eps, ZERO);\n    return normalize(vec3(RealSDF(spheres,rayPos + h.xyy, iTime) - RealSDF(spheres,rayPos - h.xyy, iTime),\n                RealSDF(spheres,rayPos + h.yxy, iTime) - RealSDF(spheres,rayPos - h.yxy, iTime),\n                RealSDF(spheres,rayPos + h.yyx, iTime) - RealSDF(spheres,rayPos - h.yyx, iTime)));\n}\n\n\nvec3 RunRay(vec2 uv, Sphere[5] spheres, float degree, vec2 oldUV,float iTime, float camDistance)\n{\n    vec3 focusPoint = vec3(0,0,3);\n    float lowestDist = 100000.;\n    vec3 rayPos = GetRayPos(uv, degree, focusPoint, camDistance);\n    vec3 rayDir = GetRayDir(uv, -degree-3.1415*1.5);\n    \n    for (float i = 0.0; i < 20.0; i++)\n    {\n        float dist = RealSDF(spheres, rayPos, iTime);\n        lowestDist = smin(lowestDist, dist,0.05);\n        rayPos += rayDir * dist;\n        \n        if (dist < 0.04)\n        {\n            vec3 normal = GetNormal(spheres, rayPos, iTime);\n            return GetColor(spheres, rayPos) * (0.9 + vec3(1,0.5,0.1)*0.1*max(0.,dot(normal, vec3(-1,1,0.001))));\n        }\n        \n    }\n    return BackgroundColor(rayDir)+vec3(1./(lowestDist+1.))*0.75 + vec3(0.3,0.2,0.1);\n}\n\n","name":"Common","description":"","type":"common"}]}