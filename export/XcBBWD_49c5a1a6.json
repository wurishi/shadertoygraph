{"ver":"0.1","info":{"id":"XcBBWD","date":"1724904343","viewed":18,"name":"scuffed raymarcher","username":"MountainLabs","description":"Scuffed raymarcher","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"int MAX_STEPS = 250; // march at most 250 times\nfloat MAX_DIST = 20.0; // don't continue if depth if larger than 20\nfloat MIN_HIT_DIST = 0.00001; // hit depth threshold\nfloat fov = 45.0;\nvec3 cameraPos = vec3(0.0, 0.0, 5.0);\nvec3 front = vec3(0.0, 0.0, -1.0);\nvec3 up = vec3(0.0, 1.0, 0.0);\nfloat globalAmbient = 0.1; // how strong is the ambient lightning\nfloat globalDiffuse = 1.0; // how strong is the diffuse lightning\nfloat globalSpecular = 1.0; // how strong is the specular lightning\nfloat globalSpecularExponent = 64.0; // how focused is the shiny spot\nvec3 lightPos = vec3(-2.0, 5.0, 3.0); // position of the light source\nvec3 lightColor = vec3(0.9, 0.9, 0.68); // color of the light source\nvec3 ambientColor = vec3(1.0, 1.0, 1.0); // ambient color\n\n\n//temp\nfloat smooth_max(float a, float b, float k){\n\treturn log(exp(k * a)+ exp(k*b)) / k;\n\t\n}\n\n//float smooth_min(float a, float b, float k){\n\t//return -smooth_max(-a,-b,k);\n\t\n//}\n\nfloat smooth_min(float distA, float distB, float k){\n    float h = clamp(0.5 + 0.5 * (distA - distB)/k, 0.0, 1.0);\n    return mix(distA, distB, h) - k*h*(1.0-h);\n}\n\n\nfloat sdSphere( vec3 p, vec3 c, float r )\n{\n    return length(p - c) - r;\n}\n\nfloat sdBox( vec3 p, vec3 b)\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n\nfloat sdf(vec3 pos)\n{\n\tfloat bs = 15.0;\n\t\n\tvec3 coolpos = vec3(pos.x, pos.y, pos.z);\n\tvec3 evencoolerpos = vec3(pos.x, pos.y + (sin(iTime) / 1.0), pos.z);\n\tvec3 coolsize = vec3(0.1);\n\t\n    return smooth_min(smooth_min(sdSphere(coolpos, vec3(0,0,0), 0.1), sdBox(evencoolerpos, coolsize), 0.1), sdBox(pos + vec3(0, 0.3, 0), vec3(1000, 0.1, 1000)), 2.0);\n\t\n}\n\n\n\nvec3 estimateNormal(vec3 p) {\n\tfloat DERIVATIVE_STEP = 0.0001;\n    return normalize(vec3(\n        sdf(vec3(p.x + DERIVATIVE_STEP, p.y, p.z)) - sdf(vec3(p.x - DERIVATIVE_STEP, p.y, p.z)),\n        sdf(vec3(p.x, p.y + DERIVATIVE_STEP, p.z)) - sdf(vec3(p.x, p.y - DERIVATIVE_STEP, p.z)),\n        sdf(vec3(p.x, p.y, p.z  + DERIVATIVE_STEP)) - sdf(vec3(p.x, p.y, p.z - DERIVATIVE_STEP))\n    ));\n}\nvec3 blinnPhong(vec3 position, // hit point\n                vec3 lightPosition, // position of the light source\n                vec3 ambientCol, // ambient color\n                vec3 lightCol, // light source color\n                float ambientCoeff, // scale ambient contribution\n                float diffuseCoeff, // scale diffuse contribution\n                float specularCoeff, // scale specular contribution\n                float specularExponent // how focused should the shiny spot be\n)\n{\n    vec3 normal = estimateNormal(position);\n    vec3 toEye = normalize(cameraPos - position);\n    vec3 toLight = normalize(lightPosition - position);\n    vec3 reflection = reflect(-toLight, normal);\n     \n    vec3 ambientFactor = ambientCol * ambientCoeff;\n    vec3 diffuseFactor = diffuseCoeff * lightCol * max(0.0, dot(normal, toLight));\n    vec3 specularFactor = lightCol * pow(max(0.0, dot(toEye, reflection)), specularExponent)\n                     * specularCoeff;\n     \n    return ambientFactor + diffuseFactor + specularFactor;\n}\n\nvec3 raymarch(vec3 rayDir)\n{\n    vec3 hitColor = vec3(1.0, 1.0, 1.0);\n    vec3 missColor = vec3(0.0, 0.5,0.9);\n\tvec3 glowColor = vec3(0.0, 1.0, 0.1);\n\t\n\tfloat closest;\n\tfloat steps;\n\n    float depth = 0.0;\n    for (int i=0; depth<MAX_DIST && i<MAX_STEPS; ++i, ++steps)\n    {\n        vec3 pos = cameraPos + rayDir * depth;\n        float dist = sdf(pos);\n\t\tif (dist < closest) {\n\t\t\tclosest = dist;\n\t\t}\n        if (dist < MIN_HIT_DIST) {\n\t\t\treturn blinnPhong(pos, lightPos, ambientColor, lightColor,globalAmbient, globalDiffuse, globalSpecular, globalSpecularExponent);\n\t\t}\n        depth += dist;\n    }\n\t\n\treturn missColor;\n\t\n    \n}\n\n\n\n\nvec3 getRayDirection(vec2 resolution, vec2 uv)\n{\n    float aspect = resolution.x / resolution.y;\n    float fov2 = radians(fov) / 2.0;\n \n    // convert coordinates from [0, 1] to [-1, 1]\n    // and invert y axis to flow from bottom to top\n    vec2 screenCoord = (uv - 0.5) * 2.0;\n    screenCoord.x *= aspect;\n    screenCoord.y = -screenCoord.y;\n \n    // contibutions of the up and right vectors\n    vec2 offsets = screenCoord * tan(fov2);\n     \n    // compute 3 orthogonal unit vectors\n    vec3 rayFront = normalize(front);\n    vec3 rayRight = cross(rayFront, normalize(up));\n    vec3 rayUp = cross(rayRight, rayFront);\n    vec3 rayDir = rayFront + rayRight * offsets.x + rayUp * offsets.y;\n \n    return normalize(rayDir);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 resolution = fragCoord/iResolution.xy;\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 rayDir = getRayDirection(resolution, uv);\n    vec3 raymarchColor = raymarch(rayDir);\n    fragColor = vec4(raymarchColor, 1.0);\n\n    // Output to screen\n}","name":"Image","description":"","type":"image"}]}