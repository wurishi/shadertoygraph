{"ver":"0.1","info":{"id":"7lySR1","date":"1640156827","viewed":47,"name":"Basic scene","username":"constantince","description":"Basic ray march scene with shadow.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raymarch"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAXSTEP     100\n#define END         50.0\n#define START       0.0\n#define PRECISION   0.01\n#define PI          3.1415926535\n// ray origin\nconst vec3 rayOrigin = vec3(20., 6.0, 20.);\n\nstruct Material {\n    vec3 aCol;\n    vec3 dCol;\n    vec3 sCol;\n    float shiness;\n};\n\nstruct Thing {\n    int id;\n    float dis;\n    Material m;\n};\n\nmat3 rotate3dX(float theta) {\n   return mat3(\n       vec3(1.0, 0.0, 0.0),\n       vec3(0.0, cos(theta), -sin(theta)),\n       vec3(0.0, sin(theta), cos(theta))\n   );\n}\n\nMaterial sdSphere() {\n    return Material(\n        0.8 * vec3(0.7, 0.7, 0.7),\n        0.6 * vec3(0.7, 0.7, 0.7),\n        0.6 * vec3(0, 0, 0),\n        100.0\n    );\n}\n\nMaterial sdMesh() {\n    Material mesh = sdSphere();\n    return mesh;\n}\n\nMaterial sdFloor(vec3 p) {\n    return Material(\n        vec3(1.6),\n        vec3(0.3),\n        vec3(0.0),\n        0.0\n    );\n}\n\n\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n  vec3 q = abs(p);\n  return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n}\n\n\nfloat sdSolidAngle(vec3 p, vec2 c, float ra)\n{\n  // c is the sin/cos of the angle\n  vec2 q = vec2( length(p.xz), p.y );\n  float l = length(q) - ra;\n  float m = length(q - c*clamp(dot(q,c),0.0,ra) );\n  return max(l,m*sign(c.y*q.x-c.x*q.y));\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n\nThing createSphere(vec3 p, vec3 offset, float radius, Material m, int id) {\n    return Thing(\n        id,\n        length(p - offset) - radius,\n        m\n    );\n}\n\nThing createFloor(vec3 p, vec3 n, float h, Material m, int id) {\n    p.y += .1;\n    return Thing(\n        id,\n        sdBox(p, vec3(10., 0.01, 10.)),\n        m\n    );\n}\n\nThing createRoundBox(vec3 p, vec3 b, float r, int id, Material m) {\n    vec3 q = abs(p) - b;\n    return Thing(id, length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r, m);\n}\n\n\nThing createTorus(vec3 p, vec2 t, int id, Material m) {\n    vec2 q = vec2(length(p.xz)-t.x,p.y);\n    return Thing(id, length(q)-t.y, m);\n}\n\nThing createCapsule(vec3 p, float h, float r, int id, Material m) {\n  p.x += sin(iTime * 0.5) * 2.0;\n  p.y -= clamp( p.y, 0.0, h );\n  return Thing(id, length( p ) - r, m);\n}\n\nThing createTriPrism(vec3 p, vec2 h, int id, Material m) {\n    return Thing(id, sdTriPrism(p, h), m);\n}\n\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); \n}\n\nThing combine(Thing obj1, Thing obj2) {\n   return Thing(obj1.id, opSmoothUnion(obj1.dis, obj2.dis, .00), sdMesh());\n}\n\n\n// all objects together;\nThing scene(vec3 p){\n    Material mesh = sdMesh();\n    Thing sphere = createSphere(p, vec3(0.0, 1.3, 0.0), 1.3, mesh, 1);\n    Thing floors = createFloor(p, normalize(vec3(.1)), 10., sdFloor(p), 2);\n    Thing roundbox = createRoundBox(p - vec3(2.0, 1., 4.0), vec3(.5, 1., 2.0), 0.2, 3, mesh);\n    Thing torus = createTorus(p - vec3(-2.0, 0.15, 3.0), vec2(1.5, 0.3), 4, mesh);\n    Thing capsule = createCapsule(p - vec3(-.01, 0.15, 6.0), 2., .3, 5, mesh);\n    Thing triprism = createTriPrism(p -vec3(-2.5, .5, 7.0), vec2(1., .9), 6, mesh);\n    Thing Mesh = combine(sphere, floors);\n    \n    Mesh = combine(Mesh, roundbox);\n    Mesh = combine(Mesh, torus);\n    Mesh = combine(Mesh, capsule);\n    Mesh = combine(Mesh, triprism);\n    \n    return Mesh;\n    \n}\n\n// ray march algorithm\nThing rayMarch(vec3 ro, vec3 rd) {\n\n    float depth = START;\n    Thing tar;\n    for(int i = 0; i < MAXSTEP; i++) {\n        vec3 p = ro + rd * depth;\n        tar = scene(p);\n        depth += tar.dis;\n        if( depth < PRECISION || depth > END) break;\n    }\n\n    return Thing(0, depth, tar.m);\n}\n\n// camera matrix\nmat3 camera(vec3 ro, vec3 lp) {\n    \n    vec3 camera_direction = normalize(lp - ro);\n    vec3 camera_right = normalize(cross(camera_direction, vec3(0.0, 1.0, 0.0)));\n    vec3 camera_up = normalize(cross(camera_direction, camera_right));\n    return mat3(\n        camera_right,\n        -camera_up,\n        -camera_direction\n    );\n\n}\n// a-d-s reflection model\nvec3 phong(vec3 rd, vec3 ld, vec3 normal, Material m, float diff) {\n    vec3 ambient = m.aCol;\n    \n    // diffuse color;\n    float fDot = clamp(dot(ld, normal), 0.0, 1.0);\n    vec3 diffuse = fDot * diff * m.dCol;\n    \n    // reflect\n    vec3 ref = reflect(ld, normal);\n    float sDot = clamp(dot(ref, -rd),0.0, 1.0);\n    vec3 specular = pow(sDot, m.shiness) * m.sCol;\n    \n    \n    return ambient + diffuse + specular;\n}\n\n// calculate the normal\nvec3 calcNormal(vec3 p) {\n    vec2 e = vec2(1.0, -1.0) * .0005; // epsilon\n    return normalize(\n      e.xyy * scene(p + e.xyy).dis +\n      e.yyx * scene(p + e.yyx).dis +\n      e.yxy * scene(p + e.yxy).dis +\n      e.xxx * scene(p + e.xxx).dis);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord.xy - .5 * iResolution.xy)  /iResolution.y;\n\n    // ray origin\n    vec3 ro = rayOrigin;\n    \n    ro.x *= sin(iTime * 0.1);\n    ro.z *= cos(iTime * 0.1);\n    // look point\n    vec3 lp = vec3(0.0);\n    // ray direction\n    vec3 rd = camera(ro, lp) * normalize(vec3(uv, -1));\n    // original color\n    vec3 color;\n    Thing T = rayMarch(ro, rd);\n    \n    \n    if(T.dis > END) { // ray miss objects\n       color = vec3(0.);\n    } else {// ray hit objects\n       vec3 p = ro + rd * T.dis;\n       vec3 ls = vec3(5., 6.0, 15.3);\n       vec3 ld = normalize(ls - p);\n       vec3 normal = normalize(calcNormal(p));\n       \n       \n       vec3 shadowRayOrigin = p + normal * PRECISION * 2.;\n       float shadowLength = rayMarch(shadowRayOrigin, ld).dis;\n       float diff = 1.0;\n       if(shadowLength < length(ls - shadowRayOrigin)) {\n           diff = 0.0;\n       } \n       color = phong(rd, ld, normal, T.m, diff);\n    }\n   // fog\n   color = mix(color, vec3(0.2), 1.0 - exp(-0.00005 * T.dis * T.dis * T.dis));\n    \n    // Output to screen\n    fragColor = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"}]}