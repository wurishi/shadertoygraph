{"ver":"0.1","info":{"id":"ctBfRW","date":"1693792468","viewed":47,"name":"Motion_Noise","username":"DJX","description":"test_Noise","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["noise"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec2 direction = vec2(1.0, 1.0);\nfloat speed = 5.0;\n\nfloat rand(vec2 uv){\n    return fract(sin(dot(uv, vec2(12.985489, 5.889))) * 155894.);\n}\n\nfloat noise(vec2 uv){\n    vec2 i_uv = floor(uv);  //取整数\n    vec2 d_uv = fract(uv);  //取小数\n    d_uv = d_uv*d_uv*(3.-2.*d_uv); //smoothstep\n    \n    float shade_x0 = mix(rand(i_uv), rand(i_uv + vec2(1.,0.)), d_uv.x);\n    float shade_x1 = mix(rand(i_uv+vec2(0., 1.)), rand(i_uv + vec2(1.,1.)), d_uv.x);\n    float shade = mix(shade_x0, shade_x1, d_uv.y);\n    \n    return shade * shade;\n    \n}\n\nfloat motion_noise(vec2 uv, float s, vec2 direction, float speed){\n    float shade;\n    shade = noise(uv + iTime * direction * speed * s) * max(0., cos(iTime));\n    shade += 0.5 * noise(uv) * max(0., cos(iTime));\n    \n    float addition_wave = noise(uv + direction * speed * s * 1.5 * sin(iTime));\n    \n    shade += addition_wave * max(0., cos(iTime));\n    \n    return shade * .4;\n}\n\nfloat recursive_noise(vec2 uv, vec2 direction, float speed){\n    float shade = motion_noise(uv, 0.3, direction, speed);\n    shade = motion_noise(uv + shade, 0.2, direction, speed);\n    shade = motion_noise(uv + shade, 0.5, direction, speed);\n    \n    return shade;\n}\n\n\n// 点到线距离算法  公式为 ((A*x0 + B*y0 + C) / √(A*A+B*B) )的绝对值\nfloat distance_p2c(float a, float b, float c, vec2 p0){\n    return abs(a*p0.x + b*p0.y +c)/sqrt(pow(a, 2.0) + pow(b, 2.0));\n}\n\nfloat draw_block(vec2 uv, vec2 direction, float speed){\n    vec2 reference_point = vec2(0.5, 0.5);\n    vec2 uv2ref = uv - reference_point;\n    vec2 reference_direction = vec2(1.0, direction.y / direction.x);\n    float diff = dot(uv2ref, reference_direction);\n    if (diff >= 0.0) return 1.0 - distance_p2c(direction.x/direction.y, 1.0, -0.5-0.5*direction.x/direction.y, uv);\n    else return 1.0; \n\n}\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    float scale = 10.0;\n\n    // Time varying pixel color \n    //vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    //vec3 col = vec3(noise(uv * vec2(10., 1.) + vec2(iTime, 0.)));\n    vec3 col = vec3(recursive_noise(uv * vec2(scale), direction, speed));\n    col = col * vec3(draw_block(uv+sin(iTime), direction, speed));\n    \n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}