{"ver":"0.1","info":{"id":"DsycRd","date":"1696602694","viewed":70,"name":"Lenia (soft_clip DLC)","username":"26apastor","description":"Lenia but, I used soft_clip function instead of clamp.\n(Very unstable !!)\nI encourage you to reset the time over and over until you get interesting results. (So the creatures donâ€™t overgrow the screen)","likes":3,"published":1,"flags":32,"usePreview":0,"tags":["function","automata","life","cellular","continuous","artificial","lenia","dlc"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    fragColor = texture(iChannel0, uv).gbrr;\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"const float nop        = 0.0;\nconst int inop         = 0;\nconst ivec4 iv0        = ivec4(0);\nconst ivec4 iv1        = ivec4(1);\nconst ivec4 iv2        = ivec4(2);\n\n\nconst mat4 rmu = mat4(vec4(0.5), vec4(0.5), vec4(0.5), vec4(0.5));\nconst mat4 rsigma = mat4(vec4(0.15), vec4(0.15), vec4(0.15), vec4(0.15));\n\nconst float max_radius = 13.0;\nconst float noise_base = 0.145;\nconst float T          = 2.0;\nconst mat4 beta0   = mat4(1.0,    1.0,    1.0,       1.0,    1.0,    1.0,    1.0,    1.0,    1.0,    1.0,   1.0,    1.0,    1.0,    1.0 / 4.0, 1.0,        nop);\nconst mat4 beta1   = mat4(0.0,    nop,    1.0 / 4.0, nop,    nop,    nop,    nop,    0.0,    0.0,    nop,   nop,    1.0,    nop,    1.0,       1.0 / 12.0, nop);\nconst mat4 beta2   = mat4(nop,    nop,    nop,       nop,    nop,    nop,    nop,    nop,    nop,    nop,   nop,    nop,    nop,    0.0,       nop,        nop);\nconst mat4 betaLen = mat4(2.0,    1.0,    2.0,       1.0,    1.0,    1.0,    1.0,    2.0,    2.0,    1.0,   1.0,    2.0,    1.0,    3.0,       2.0,        nop);\nconst mat4 mu      = mat4(0.362,  0.257,  0.247,     0.199,  0.288,  0.26,   0.108,  0.597,  0.476,  0.481, 0.343,  0.197,  0.247,  0.393,     0.179,      nop);\nconst mat4 sigma   = mat4(0.0404, 0.1469, 0.0245,    0.0575, 0.0699, 0.0346, 0.0786, 0.1136, 0.1894, 0.143, 0.0914, 0.0732, 0.1089, 0.1117,    0.0906,     nop);\nconst mat4 eta     = mat4(0.17,   0.41,   0.72,      0.24,   0.34,   0.74,   0.5,    0.18,   0.35,   0.53,  0.17,   0.55,   0.2,    0.42,      0.23,       nop);\nconst mat4 rho     = mat4(0.57,   0.5,    0.8,       0.91,   0.67,   1.0,    0.89,   0.55,   0.59,   0.98,  0.62,   0.57,   0.6,    0.78,      0.84,       nop);\nconst mat4 c0      = mat4(0,      0,      0,         1,      1,      1,      2,      2,      2,      0,     0,      1,      1,      2,         2,         inop);\nconst mat4 c1      = mat4(0,      0,      0,         1,      1,      1,      2,      2,      2,      1,     2,      0,      2,      0,         1,         inop);\n\nvec3 soft_clip(vec3 x) {\n    return clamp(tanh(2.0 * x - 1.0) / 2.0 + 0.5, 0.0, 1.0);\n}\n\nmat4 gaussian_bell(mat4 sum, mat4 m, mat4 s) {\n    mat4 p = -matrixCompMult((sum - m) / s, (sum - m) / s) / 2.0;\n    return mat4(exp(p[0]), exp(p[1]), exp(p[2]), exp(p[3]));\n}\n\nfloat getGrowthDest(mat4 growth, ivec4 channel) {\n    return dot(growth[0], vec4(equal(ivec4(c1[0]), channel))) + \n           dot(growth[1], vec4(equal(ivec4(c1[1]), channel))) + \n           dot(growth[2], vec4(equal(ivec4(c1[2]), channel))) + \n           dot(growth[3], vec4(equal(ivec4(c1[3]), channel)));\n}\n\nvec4 getRGB(vec3 v, ivec4 srcv)\n{\n    return v.r * vec4(equal(srcv, iv0)) + v.g * vec4(equal(srcv, iv1)) + v.b * vec4(equal(srcv, iv2));\n}\n\nmat4 getCell(vec2 xy)\n{\n    xy = mod(xy / iResolution.xy, 1.);\n    vec3 cell = texture(iChannel0, xy).rgb;\n    return mat4(getRGB(cell, ivec4(c0[0])), \n                getRGB(cell, ivec4(c0[1])), \n                getRGB(cell, ivec4(c0[2])), \n                getRGB(cell, ivec4(c0[3]))\n           );\n}\n\nmat4 getWeight(float dist, mat4 rho) {\n    mat4 Br = betaLen / rho * dist;\n    ivec4 Br0 = ivec4(Br[0]), Br1 = ivec4(Br[1]), Br2 = ivec4(Br[2]), Br3 = ivec4(Br[3]);\n    mat4 radius = mat4(\n            beta0[0] * vec4(equal(Br0, iv0)) + beta1[0] * vec4(equal(Br0, iv1)) + beta2[0] * vec4(equal(Br0, iv2)), \n            beta0[1] * vec4(equal(Br1, iv0)) + beta1[1] * vec4(equal(Br1, iv1)) + beta2[1] * vec4(equal(Br1, iv2)), \n            beta0[2] * vec4(equal(Br2, iv0)) + beta1[2] * vec4(equal(Br2, iv1)) + beta2[2] * vec4(equal(Br2, iv2)), \n            beta0[3] * vec4(equal(Br3, iv0)) + beta1[3] * vec4(equal(Br3, iv1)) + beta2[3] * vec4(equal(Br3, iv2))\n         ); \n    mat4 Br_mod = mat4(mod(Br[0], 1.0), mod(Br[1], 1.0), mod(Br[2], 1.0), mod(Br[3], 1.0));\n    return matrixCompMult(radius, gaussian_bell(Br_mod, rmu, rsigma));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    mat4 sum = mat4(0.0), total = mat4(0.0);\n    mat4 weight = getWeight(0.0, rho);\n    mat4 cell = getCell(fragCoord); sum += matrixCompMult(cell, weight); total += weight;\n    \n    for(float x = 1.0; x <= max_radius; x++) {\n        float R = x / max_radius;\n        weight = getWeight(R, rho);\n        cell = getCell(fragCoord + vec2(x, 0));   sum += matrixCompMult(cell, weight); total += weight;\n        cell = getCell(fragCoord + vec2(-x, 0));  sum += matrixCompMult(cell, weight); total += weight;\n        cell = getCell(fragCoord + vec2(0, x));  sum += matrixCompMult(cell, weight); total += weight;\n        cell = getCell(fragCoord + vec2(0, -x)); sum += matrixCompMult(cell, weight); total += weight;   \n    }\n\n    for(float x = 1.0; x <= max_radius; x++) {\n        for(float y = 1.0; y <= max_radius; y++) {\n            float R = sqrt(x * x + y * y) / max_radius;\n            if (R <= 1.0) {\n                weight = getWeight(R, rho);\n                cell = getCell(fragCoord + vec2(x, y));   sum += matrixCompMult(cell, weight); total += weight;\n                cell = getCell(fragCoord + vec2(-x, y));  sum += matrixCompMult(cell, weight); total += weight;\n                cell = getCell(fragCoord + vec2(x, -y));  sum += matrixCompMult(cell, weight); total += weight;\n                cell = getCell(fragCoord + vec2(-x, -y)); sum += matrixCompMult(cell, weight); total += weight;\n                \n            }\n        }\n    }\n    \n    sum /= total;\n    \n    mat4 g = matrixCompMult(eta, gaussian_bell(sum, mu, sigma) * 2.0 - 1.0);\n    vec3 rgb_growth = vec3(getGrowthDest(g, iv0), getGrowthDest(g, iv1), getGrowthDest(g, iv2));\n    vec3 previous_cell = texture(iChannel0, uv).rgb;\n    vec3 rgb = soft_clip(previous_cell + rgb_growth / T);\n    \n    if (iFrame < 1) {\n        rgb.r = noise_base + noise(fragCoord/max_radius + mod(iDate.w,1.)*44.5);\n        rgb.g = noise_base + noise(fragCoord/max_radius + mod(iDate.w,1.)*100.0);\n        rgb.b = noise_base + noise(fragCoord/max_radius + mod(iDate.w,1.)*155.5);\n    }\n    if (iMouse.z > 0.) {\n        float d = length((fragCoord.xy - iMouse.xy) / iResolution.xx);\n        if (d <= max_radius/iResolution.x) {\n        \trgb.r = 0.3 + noise(fragCoord/max_radius + mod(iDate.w,1.)*44.5);\n            rgb.g = 0.3 + noise(fragCoord/max_radius + mod(iDate.w,1.)*100.0);\n            rgb.b = 0.3 + noise(fragCoord/max_radius + mod(iDate.w,1.)*155.5);\n        }\n    }\n    \n    fragColor = vec4(rgb, 1.0);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"/*Chakazul's use of this hash function is genius and all credits to him in his implementation of lenia: https://www.shadertoy.com/user/Chakazul\n*/\n\n// Noise simplex 2D by iq - https://www.shadertoy.com/view/Msf3WH\n\nvec2 hash( vec2 p )\n{\n\tp = vec2( dot(p,vec2(127.1,311.7)), dot(p,vec2(269.5,183.3)) );\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\nfloat noise( in vec2 p )\n{\n    const float K1 = 0.366025404; // (sqrt(3)-1)/2;\n    const float K2 = 0.211324865; // (3-sqrt(3))/6;\n\n\tvec2  i = floor( p + (p.x+p.y)*K1 );\n    vec2  a = p - i + (i.x+i.y)*K2;\n    float m = step(a.y,a.x); \n    vec2  o = vec2(m,1.0-m);\n    vec2  b = a - o + K2;\n\tvec2  c = a - 1.0 + 2.0*K2;\n    vec3  h = max( 0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\n\tvec3  n = h*h*h*h*vec3( dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0)));\n    return dot( n, vec3(70.0) );\n}","name":"Common","description":"","type":"common"}]}