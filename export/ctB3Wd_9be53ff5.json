{"ver":"0.1","info":{"id":"ctB3Wd","date":"1674087597","viewed":85,"name":"Ray-marched PBR stuff","username":"ianertson","description":"Ray-marched PBR","likes":4,"published":1,"flags":48,"usePreview":0,"tags":["3d","raymarching","ray","pbr"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 tonemap(vec3 col) {\n    vec3 x = col;\n    vec3 vio = vec3(0.607843, 0.149019, 0.713725);\n    float dotVio = clamp(dot(col, vio), 0.0, 1.0);\n    \n    x = clamp(\n        (x * (2.51 * x + 0.03)) /\n        (x * (2.23 * x + 1.0392) + 0.98),\n    0.0, 1.0);\n   \n    x = saturate(x, dotVio);\n    x = mix(x, pow(x, vec3(2.0)), 0.3491*pow(dotVio, 2.0));\n    x += luma(x)/6.28;\n    x = clamp(x+(x/6.28), 0.0, 1.0);\n    \n    return pow(x, vec3(0.5125));\n}\n\nvec3 getCol(vec2 uv) {\n    vec2 texel = 1.0 / vec2(textureSize(iChannel0, 0).xy);\n    vec3 center = texture(iChannel0, uv).rgb;\n    vec3 left = texture(iChannel0, uv+(texel*vec2(-1.0, 0.0))).rgb;\n    vec3 right = texture(iChannel0, uv+(texel*vec2(1.0, 0.0))).rgb;\n    vec3 up = texture(iChannel0, uv+(texel*vec2(0.0, 1.0))).rgb;\n    vec3 down = texture(iChannel0, uv+(texel*vec2(0.0, -1.0))).rgb;\n    \n    return (center + left + right + up + down) / 5.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    vec3 col = getCol(uv);\n    fragColor = vec4(tonemap(col), 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define STEPS 86\n#define FAR 300.0\n#define NEAR 0.001\n#define M_PI 3.14159265359\n#define T (iTime*0.45)\n#define OCCLUSION 0.96\n\nvec2 rot2D(vec2 p, float angle) {\n  angle = radians(angle);\n  float s = sin(angle);\n  float c = cos(angle);\n  return p * mat2(c, s, -s, c);\n}\n\nmat4 rotationX(float angle) {\n  float c = cos(angle);\n  float s = sin(angle);\n  return mat4(vec4(1, 0, 0, 0), vec4(0, c, -s, 0), vec4(0, s, c, 0),\n              vec4(0, 0, 0, 1));\n}\n\nmat4 rotationY(float angle) {\n  float c = cos(angle);\n  float s = sin(angle);\n  return mat4(vec4(c, 0, s, 0), vec4(0, 1, 0, 0), vec4(-s, 0, c, 0),\n              vec4(0, 0, 0, 1));\n}\n\nmat4 rotationZ(float angle) {\n  float c = cos(angle);\n  float s = sin(angle);\n  return mat4(vec4(c, -s, 0, 0), vec4(s, c, 0, 0), vec4(0, 0, 1, 0),\n              vec4(0, 0, 0, 1));\n}\n\nvec3 rotate3D(vec3 vertex, vec3 center, vec3 axis, float angle, bool inv, inout mat4 matrix) {\n  matrix = (rotationX(angle * axis.x) * rotationY(angle * axis.y) * rotationZ(angle * axis.z));\n  matrix = inv ? inverse(matrix) : matrix;\n  return (matrix * vec4(vertex - center, 1.0)).xyz + center;\n}\n\n\nvec3 controller(vec3 dir, vec4 c, vec2 res) {\n    vec2 m = ((c.xy == vec2(0.) ? vec2(.5) : (c.xy / res.xy)) * 2. - 1.) * vec2(360.,90.);\n    dir.yz = rot2D(dir.yz, m.y);\n    dir.xz = rot2D(dir.xz, m.x);\n    return normalize(dir);\n}\n\nstruct Plane {\n    vec3 pos;\n    vec3 normal;\n};\n\nstruct Sphere {\n    vec3 pos;\n    float radius;\n    float rand;\n};\n\nstruct Box {\n    vec3 pos;\n    vec3 size;\n};\n\n\nstruct Light {\n    vec3 pos;\n    float strength;\n    vec3 color;\n};\n\n\n#define SHAPE_UNDEFINED 0\n#define SHAPE_PLANE 1\n#define SHAPE_SPHERE 2\n#define SHAPE_BOX 3\n\nstruct Shape {\n    Plane plane;\n    Sphere sphere;\n    Box box;\n    vec4 rotation;\n    float uvScale;\n    int type;\n    int id;\n    vec3 color;\n    float roughnessFactor;\n};\n\n#define SHAPE_CAP 8\n#define LIGHT_CAP 8\n\nstruct Scene {\n    Shape shapes[SHAPE_CAP];\n    Light lights[LIGHT_CAP];\n    int nr_shapes;\n    int nr_lights;\n};\n\nLight sceneAddLight(inout Scene scene, Light light) {\n    scene.lights[scene.nr_lights++] = light;\n    return light;\n}\n\nShape sceneAddSphere(inout Scene scene, Sphere sphere, vec4 rotation, float uvScale, vec3 color, float roughnessFactor) {\n    scene.shapes[scene.nr_shapes].sphere = sphere;\n    scene.shapes[scene.nr_shapes].type = SHAPE_SPHERE;\n    scene.shapes[scene.nr_shapes].id = scene.nr_shapes;\n    scene.shapes[scene.nr_shapes].uvScale = uvScale;\n    scene.shapes[scene.nr_shapes].color = color;\n    scene.shapes[scene.nr_shapes].roughnessFactor = roughnessFactor;\n    scene.shapes[scene.nr_shapes].rotation = rotation;\n    int idx = scene.nr_shapes++;\n    return scene.shapes[idx];\n}\n\nShape sceneAddPlane(inout Scene scene, Plane plane, vec4 rotation, float uvScale, vec3 color, float roughnessFactor) {\n    scene.shapes[scene.nr_shapes].plane = plane;\n    scene.shapes[scene.nr_shapes].type = SHAPE_PLANE;\n    scene.shapes[scene.nr_shapes].id = scene.nr_shapes;\n    scene.shapes[scene.nr_shapes].uvScale = uvScale;\n    scene.shapes[scene.nr_shapes].color = color;\n    scene.shapes[scene.nr_shapes].roughnessFactor = roughnessFactor;\n    scene.shapes[scene.nr_shapes].rotation = rotation;\n    int idx = scene.nr_shapes++;\n    return scene.shapes[idx];\n}\n\nShape sceneAddBox(inout Scene scene, Box box, vec4 rotation, float uvScale, vec3 color, float roughnessFactor) {\n    scene.shapes[scene.nr_shapes].box = box;\n    scene.shapes[scene.nr_shapes].type = SHAPE_BOX;\n    scene.shapes[scene.nr_shapes].id = scene.nr_shapes;\n    scene.shapes[scene.nr_shapes].uvScale = uvScale;\n    scene.shapes[scene.nr_shapes].color = color;\n    scene.shapes[scene.nr_shapes].roughnessFactor = roughnessFactor;\n    scene.shapes[scene.nr_shapes].rotation = rotation;\n    int idx = scene.nr_shapes++;\n    return scene.shapes[idx];\n}\n\n\nstruct Data {\n    vec3 point;\n    vec3 normal;\n    vec2 uv;\n    float dist;\n    Shape shape;\n};\n\nfloat luma(vec3 color) {\n  return dot(color, vec3(0.299, 0.587, 0.114));\n}\n\nfloat notzero(float v) {\n  return (abs(v) <= 0.0 ? 0.001 : v);\n}\nfloat DistributionGGX(vec3 N, vec3 H, float roughness)\n{\n    float a = roughness*roughness;\n    float a2 = a*a;\n    float NdotH = max(dot(N, H), 0.0);\n    float NdotH2 = NdotH*NdotH;\n\n    float nom   = a2;\n    float denom = (NdotH2 * (a2 - 1.0) + 1.0);\n    denom = M_PI * denom * denom;\n\n    return nom / notzero(max( denom, 0.000001 ));\n}\n\nvec3 fresnelSchlickRoughness(float cosTheta, vec3 F0, float roughness) {\n  return F0 + (max(vec3(1.0 - roughness), F0) - F0) *\n                  pow(max(1.0 - cosTheta, 0.0), 5.0);\n}\nvec3 EnvBRDFApprox(vec3 specularColor, float roughness, float ndotv) {\n  const vec4 c0 = vec4(-1, -0.0275, -0.572, 0.022);\n  const vec4 c1 = vec4(1, 0.0425, 1.04, -0.04);\n  vec4 r = roughness * c0 + c1;\n  float a004 = min(r.x * r.x, exp2(-9.28 * ndotv)) * r.x + r.y;\n  vec2 AB = vec2(-1.04, 1.04) * a004 + r.zw;\n  return specularColor * AB.x + AB.y;\n}\nvec3 fresnelSchlick(float cosTheta, vec3 F0)\n{\n    return F0 + (1.0 - F0) * pow(1.0 - cosTheta, 5.0);\n}\nfloat microfacetDistribution(float roughness, float NdotH)\n{\n    float roughnessSq = roughness * roughness;\n    float f = (NdotH * roughnessSq - NdotH) * NdotH + 1.0;\n    return roughnessSq / notzero((M_PI * f * f) + 0.00001);\n}\nfloat GeometrySchlickGGX(float NdotV, float k)\n{\n    float nom   = NdotV;\n    float denom = NdotV * (1.0 - k) + k;\n\n    return nom / notzero(denom);\n}\nfloat GeometrySmith(vec3 N, vec3 V, vec3 L, float k)\n{\n    float NdotV = max(dot(N, V), 0.0);\n    float NdotL = max(dot(N, L), 0.0);\n    float ggx1 = GeometrySchlickGGX(NdotV, k);\n    float ggx2 = GeometrySchlickGGX(NdotL, k);\n\n    return ggx1 * ggx2;\n}\nfloat goldness(vec3 color) {\n    vec3 gold = vec3(1.0, 0.8, 0.4);\n    float distance = length(color - gold);\n    return 1.0 - distance;\n}\n\nfloat grayness(vec3 color) {\n  float luminance = dot(vec3(0.2126, 0.7152, 0.0722), color);\n  float gray = (luminance + color.r + color.g + color.b) / 3.0;\n  return abs(luminance - gray);\n}\n\nfloat copperness(vec3 color) {\n    vec3 copper = vec3(0.9, 0.6, 0.4);\n    float distance = length(color - copper);\n    return 1.0 - distance;\n}\n\nmat3 camera(vec3 cameraPos, vec3 lookAtPoint) {\n\tvec3 cd = lookAtPoint;\n\tvec3 cr = normalize(cross(vec3(0, 1, 0), cd));\n\tvec3 cu = normalize(cross(cd, cr));\n\t\n\treturn mat3(-cr, cu, -cd);\n}\n\nvec3 getBackground(samplerCube tex, vec3 origin, vec3 dir) {\n    return texture(tex, camera(origin, dir) * vec3(0.0, 0.0, -1.0)).rgb;\n}\n\n\nvec3 extractBump(sampler2D tex, vec2 uv, vec3 normal) {\n    vec3 color = texture(tex, uv).rgb;\n    vec2 texelSize = 1.0 / vec2(textureSize(tex, 0)).xy;\n    vec3 dx = texture(tex, uv + vec2(texelSize.x, 0)).rgb - color;\n    vec3 dy = texture(tex, uv + vec2(0, texelSize.y)).rgb - color;\n    float l = (abs(dy.r - dx.r) + abs(dx.g - dy.g)) / 2.0;\n    vec3 n = normalize(vec3(dy.r - dx.r, dx.g - dy.g, 0.033*0.6));\n    return mix(normal, normalize(normal+n), 0.6);\n}\n\nfloat extractRough(vec3 color, vec2 uv, sampler2D tex) {\n    float avg = pow((color.r + color.g + color.b) / 3.0, 2.0);\n    float a = max(0.0001, 1.0 - avg);\n    vec2 tsize = vec2(textureSize(tex, 0).xy);\n    vec2 texel = 1.0 / tsize;\n    vec3 left = texture(tex, uv+(texel*vec2(-1.0, 0.0))).rgb;\n    vec3 right = texture(tex, uv+(texel*vec2(-1.0, 0.0))).rgb;\n    vec3 up = texture(tex, uv+(texel*vec2(0.0, 1.0))).rgb;\n    vec3 down = texture(tex, uv+(texel*vec2(0.0, -1.0))).rgb;\n    vec3 avgAround = (left+right+up+down) / 4.0;\n    float r = (a+(distance(color, avgAround)*3.0));\n    r *= max(0.001, 1.0 - pow(0.99*luma(color), 2.0));\n    return max(0.0004, smoothstep(0.0, 1.0, r));\n}\n\nfloat extractMetallic(vec3 color) {\n    float gold = goldness(color);\n    float copper = copperness(color);\n    float gray = grayness(color);\n    return pow((gold + copper + gray) / 3.0, 2.0);\n}\nvec3 extractSpec(vec3 color) {\n    float gold = goldness(color);\n    float copper = copperness(color);\n    float gray = grayness(color);\n    vec3 goldColor = vec3(1.0, 0.8, 0.4);\n    vec3 copperColor = vec3(0.9, 0.6, 0.4);\n    vec3 grayColor = vec3(0.2126, 0.7152, 0.0722);\n    vec3 spec = ((goldColor * gold) + (copperColor * copper) + (grayColor * gray)) / 3.0;\n    spec += (((vec3(1.0) - color) / M_PI) + luma(color)) / (M_PI*2.0);\n    return smoothstep(0.0, 1.0, pow(spec, vec3(2.1)));\n}\nvec3 aces(vec3 x) {\n  const float a = 2.51;\n  const float b = 0.03;\n  const float c = 2.43;\n  const float d = 0.59;\n  const float e = 0.14;\n  return clamp((x * (a * x + b)) / (x * (c * x + d) + e), 0.0, 1.0);\n}\nvec3 reinhard2(vec3 x) {\n  const float L_white = 4.0;\n\n  return (x * (1.0 + x / (L_white * L_white))) / (1.0 + x);\n}\nvec3 gammaCorrect(vec3 color, float gamma) {\n  return pow(color, vec3(1.0 / gamma));\n}\n\nvec3 colorCorrect(vec3 color, float gamma) {\n  color =  max(color, vec3(0.0));\n\n  color  = mix(reinhard2(color), aces(color), 0.16);\n\n  // filmic\n  //color /= max(color, vec3(0.0001)) + vec3(1.0);\n\n  color = pow(color, vec3(1.0 / gamma));\n\n  return color;\n}\n\nvec3 saturate(vec3 color, float amnt) {\n  float l = color.r * 0.2 + color.g * 0.7 + color.b * 0.1;\n  vec3 gray = vec3(l,l,l);\n  vec3 diff = color.rgb - gray.rgb;\n  diff *= (1.0 + amnt);\n  vec3 saturated = clamp(gray + diff,0.0,1.0);\n  return mix(color, saturated, clamp(amnt, 0.0, 1.0));\n}\n\n\nvec3 PBR(\n    vec3 ro,\n    vec3 rd,\n    Data data,\n    Light light,\n    vec3 env,\n    vec3 normal,\n    sampler2D tex,\n    vec3 baseColor,\n    float roughnessFactor\n) {\n  vec3 albedo = texture(tex, data.uv).rgb;\n  vec3 diffuse = (albedo*baseColor) / M_PI;\n  \n  vec3 col = vec3(0.0);\n  float metallic = extractMetallic(albedo);\n  float roughness = extractRough(albedo, data.uv, tex) * roughnessFactor;\n  diffuse = mix(diffuse, env, float(roughnessFactor < 0.993) * max(0.0, 1.0 - roughness));\n  vec3 spec = extractSpec(albedo);\n  vec3 f0 = mix(vec3(0.04), diffuse, smoothstep(0.0, 1.0, metallic*2.0));\n  vec3 viewdir = normalize(ro - data.point);\n  vec3 reflection_dir = normalize(reflect(viewdir, normal) * -1.);\n  //vec3 env = texture(envtex, reflection_dir).rgb;\n  float NdotV = abs(dot(normal, viewdir)) + 0.000001;\n  vec3 envBRDF = EnvBRDFApprox(spec/M_PI, pow(roughness, 2.0), NdotV);\n  vec3 F = fresnelSchlickRoughness(NdotV, f0, roughness);\n  vec3 indirectSpecular = env * (F * envBRDF.x + envBRDF.y);\n  col += indirectSpecular;\n  float glossy = max(0.0, 1.0 - (roughness*1.1));\n  \n  // light\n  vec3 L = normalize(data.point - light.pos);\n  vec3 H = normalize(L + viewdir);\n  float HdotV = clamp(dot(H, viewdir),0.000001, 1.0);\n  float NdotH = clamp(dot(normal, H), 0.000001, 1.0);\n  float NdotL = max(0.0, dot(normal, L));\n  float dist = abs(distance(data.point, light.pos));\n  float att = NdotL*max(0.000001, (pow(light.strength, 2.0) / max(0.0001, pow(dist, 2.0))));\n\n  vec3 light_reflect_dir = reflect(-L, normal);\n  float VdotR = max(dot(viewdir, light_reflect_dir), 0.0);\n  float specFres = (glossy * pow(VdotR, 64.0)) / M_PI;\n  vec3 fresnel = fresnelSchlick(HdotV, f0);\n  float D = microfacetDistribution(roughness, NdotH);\n  float S = DistributionGGX(normal, H, roughness);\n  float G = GeometrySmith(normal, viewdir, L, roughness);\n  float Fsd = (4.0 * NdotV * NdotL);\n  vec3 specularity = ((fresnel * S * G * D) / notzero(Fsd)) / M_PI;\n  vec3 kd = (vec3(1.0) - specularity) * (1.0 - metallic);\n  col += (kd * diffuse + specularity + specFres) * ((light.color * att));\n  return max(vec3(0.0), col);\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// taken from https://www.shadertoy.com/view/ldGGzV\n\n#define MOVE_SPEED 10.\n#define PI 3.14159\n\nconst float KEY_W = 87.5 / 256.0;\nconst float KEY_A = 65.5 / 256.0;\nconst float KEY_S = 83.5 / 256.0;\nconst float KEY_D = 68.5 / 256.0;\nconst float KEY_SHIFT = 16.5 / 256.;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 pos = texture(iChannel1, vec2(0.)).xyz;\n    if(iFrame <= 16 || iMouse.z <= 0.001) pos = vec3(0.,0., 0.0);\n    \n    float mx = iMouse.z <= 0.0001 ? 0. : ((iMouse.x / iResolution.x) * 2. - 1.) * 360.;\n    float speed = MOVE_SPEED * iTimeDelta;\n    \n    speed *= 1. + 2. * texture(iChannel0,vec2(KEY_SHIFT,0.)).r;\n\n    speed *= 2.0;\n    \n    float forwardBackward =\n\ttexture(iChannel0, vec2(KEY_W, 0.)).r -\n\ttexture(iChannel0, vec2(KEY_S, 0.)).r;\n\n\tfloat leftRight =\n\ttexture(iChannel0, vec2(KEY_A, 0.)).r -\n\ttexture(iChannel0, vec2(KEY_D, 0.)).r;\n\n\tfloat s = sin(radians(mx));\n\tfloat c = cos(radians(mx));\n\n\tpos.x += speed * (forwardBackward * s - leftRight * c);\n\tpos.z += speed * (forwardBackward * c + leftRight * s);\n    \n    fragColor = vec4(pos, 0.);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"XdX3Rr","filepath":"/media/a/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin","previewfilepath":"/media/ap/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin","type":"volume","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"mat4 getRotation(Shape shape, vec3 p, vec3 center) {\n    mat4 m;\n    rotate3D(p, center, shape.rotation.xyz, shape.rotation.w, false, m);\n    return m;\n}\n\nfloat getDistBox(Box box, vec3 p) {\n\n   \n    \n    p -= box.pos;\n    p = abs(p)-box.size;\n    \n\treturn length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.);\n}\n\nfloat getDistPlane(Plane plane, vec3 p) {\n    return length((plane.pos)+(p * plane.normal));\n}\n\nvec2 getUvPlane(Plane plane, vec3 p) {\n    vec3 k = p/FAR;\n    return (k.xz+k.y);\n}\n\nvec2 getUvBox(Shape shape, vec3 p, vec3 normal) {\n    Box box = shape.box;\n    mat4 rot;\n    p -= box.pos;\n    \n    rotate3D(p, box.pos-(box.size*0.5), shape.rotation.xyz, shape.rotation.w, false, rot);\n    p = (rot * vec4(p, 1.0)).xyz;\n    vec3 k = (p) / box.size;\n    \n   // normal = normalize((rot * vec4(normal, 1.0)).xyz);\n    \n    return (k.xy+k.z);\n}\n\nvec2 getUvSphere(Sphere sphere, vec3 p) {\n    float u = atan(p.x, -p.z) / (2. * M_PI) + .5;\n    float v = p.y * .5 + .5;\n    return vec2(u, v);\n}\n\nvec2 getUv(Data data, vec3 p) {\n    switch (data.shape.type) {\n        case SHAPE_SPHERE: return getUvSphere(data.shape.sphere, data.normal); break;\n        case SHAPE_PLANE: return getUvPlane(data.shape.plane, p); break;\n        case SHAPE_BOX: return getUvBox(data.shape, p, data.normal); break;\n        default: return normalize(p.xy); break;\n    }\n    \n    return normalize(p.xy);\n}\n\nfloat getDistSphere(Sphere sphere, vec3 p) {\n    if (sphere.rand > 0.001) {\n        vec3 op = p + vec3(cos(T+0.001512), sin(T+4.2916), sin(T-3.2915));\n        vec3 n1 = texture(iChannel2, op*0.01).xyz;\n        vec3 n2 = texture(iChannel2, n1*0.5).xyz;\n        vec3 n3 = texture(iChannel2, (n2*op)*0.01).xyz;\n        vec3 n4 = texture(iChannel2, 0.01*(n1*n2*n3)).xyz;\n        \n        \n        vec3 n = reflect(n3, cross(n4-n1, n2+n3));\n        n -= refract(n, n4, 0.34561)*2.0;\n        \n        n = (n + n1 + n2 + n3 + n4) / 5.0;\n        \n        n = pow(n, vec3(2.0));\n        \n        p += n*0.9;\n     \n    }\n    return length(sphere.pos - p) - sphere.radius;\n}\n\nfloat getDistShape(in Shape shape, vec3 p) {\n\n    switch (shape.type) {\n        case SHAPE_SPHERE: return getDistSphere(shape.sphere, p); break;\n        case SHAPE_PLANE: return getDistPlane(shape.plane, p); break;\n        case SHAPE_BOX: {\n        \n            mat4 rot = getRotation(shape, shape.box.pos, shape.box.pos-(shape.box.size*0.5));\n            shape.box.pos = (rot * vec4(shape.box.pos, 1.0)).xyz;\n            p = (rot * vec4(p, 1.0)).xyz;\n            return getDistBox(shape.box, p);\n        }break;\n        default: return FAR; break;\n    }\n    \n    return FAR;\n}\n\nfloat getDist(in Scene scene, vec3 p, inout Shape shape, int skip_id) {\n\n    if (scene.nr_shapes <= 0) return FAR;\n    \n    float minDist = FAR;\n    shape = scene.shapes[0];\n    \n    for (int i = 0; i < scene.nr_shapes; i++) {\n        float next = getDistShape(scene.shapes[i], p);\n        if (next < minDist && scene.shapes[i].id != skip_id) {\n            minDist = next;\n            shape = scene.shapes[i];\n        }\n        \n    }\n    \n    return minDist;\n}\n\nvec3 getNormal(in Scene scene, vec3 p) {\n    vec2 e = vec2(0.1, 0.0);\n    Shape shape;\n    return normalize(getDist(scene, p, shape, -1) - vec3(\n        getDist(scene, p + e.xyy, shape, -1),\n        getDist(scene, p + e.yxy, shape, -1),\n        getDist(scene, p + e.yyx, shape, -1)\n    ));\n}\n\n\n\nbool march(in Scene scene, vec3 ro, vec3 rd, inout Data data, int skip_id) {\n    float dist = data.dist;\n    for (int i = 0; i < STEPS; i++) {\n        vec3 p = ro+(rd*dist);\n        float next = getDist(scene, p, data.shape, skip_id);\n        dist += next;\n        \n        if (next <= NEAR || next >= FAR) break;\n    }\n    \n    vec3 point = ro+(rd*dist);\n    data.point = point;\n    data.dist = dist;\n    data.normal = getNormal(scene, point);\n    data.uv = getUv(data, data.point) * data.shape.uvScale;\n    \n    vec3 bump = extractBump(iChannel0, data.uv, data.normal);\n    data.normal = mix(data.normal, normalize(data.normal + bump), data.shape.roughnessFactor*0.3);\n    if (data.shape.type == SHAPE_PLANE) data.normal *= data.shape.plane.normal;\n    return dist < FAR && data.shape.type != SHAPE_UNDEFINED && data.shape.id != skip_id;\n}\n\nvec3 renderReflection(in Scene scene, vec3 ro, vec3 rd, int skip_id) {\n    vec3 col = vec3(0.0);\n    float dist = 0.0;\n    vec3 p = vec3(0.0);\n    \n    Data data;\n    data.dist = 0.0;\n   \n    \n    if (march(scene, ro, rd, data, skip_id)) {\n        float occlusion = 0.0;\n        \n        Data ocData;\n        ocData.dist = 0.0;\n        Light light = scene.lights[0];\n        vec3 ocDir = normalize(data.point - light.pos);\n        if (march(scene, light.pos - (ocDir*2.0), ocDir, ocData, data.shape.id)) {\n            float AO = 1.0 * max(0.0, length(data.point - light.pos) / ocData.dist);\n            \n            occlusion = smoothstep(FAR, NEAR, pow(ocData.dist, 1.7));\n            occlusion *= OCCLUSION;\n            occlusion = mix(occlusion, AO, 0.5);\n    \n        }\n        \n      vec3 viewdir = normalize(ro - data.point);\n      vec3 reflection_dir = normalize(reflect(viewdir, data.normal) * -1.);\n      vec3 env = texture(iChannel1, reflection_dir).rgb;\n        \n        col = PBR(\n            ro,\n            rd,\n            data,\n            scene.lights[0],\n            env,\n            data.normal,\n            iChannel0,\n            data.shape.color,\n            data.shape.roughnessFactor\n        );\n        \n        col *= max(0.001, 1.0 - occlusion);\n        \n        \n        \n    } else {\n        col += texture(iChannel1, rd).xyz;\n    }\n    \n    return col;\n}\n\nvec3 render(in Scene scene, vec3 ro, vec3 rd) {\n    vec3 col = vec3(0.0);\n    float dist = 0.0;\n    vec3 p = vec3(0.0);\n    \n    Data data;\n    data.dist = 0.0;\n    int skip_id = -1;\n    \n    if (march(scene, ro, rd, data, skip_id)) {\n        float occlusion = 0.0;\n        \n        Data ocData;\n        ocData.dist = 0.0;\n        Light light = scene.lights[0];\n        vec3 ocDir = normalize(data.point - light.pos);\n        if (march(scene, (light.pos+(data.normal*0.001)) - (ocDir*0.001), ocDir, ocData, data.shape.id)) {\n           // float ldist = distance(data.point, light.pos);\n           // float pdist = distance(data.point, ocData.point);\n            occlusion = smoothstep(FAR, NEAR, pow(ocData.dist, 1.7));\n            occlusion *= OCCLUSION;\n           // occlusion *= 1.0;\n        }\n        \n      vec3 viewdir = normalize(ro - data.point);\n      vec3 reflection_dir = normalize(reflect(viewdir, data.normal) * -1.);\n      vec3 env = renderReflection(scene, data.point, reflection_dir, data.shape.id);//texture(iChannel1, reflection_dir).rgb;\n        \n        col = PBR(\n            ro,\n            rd,\n            data,\n            scene.lights[0],\n            env,\n            data.normal,\n            iChannel0,\n            data.shape.color,\n            data.shape.roughnessFactor\n        );\n        \n        col *= max(0.001, 1.0 - occlusion);\n        \n        \n        \n    } else {\n         col += texture(iChannel1, rd).xyz;\n    }\n    \n //   float depth = data.dist / FAR;\n    \n    \n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fc )\n{\n    vec2 uv = (fc-0.5*iResolution.xy)/iResolution.y;\n    vec3 col = vec3(0.0);\n    \n\n    \n    \n    vec3 ro = vec3(0.0, 0.0, 0.0);\n    vec3 rd = normalize(vec3(uv.xy, 1.0));\n    \n    if (iMouse.z > 0.01 && iMouse.x > 10.0) {\n        rd = controller(rd, iMouse, iResolution.xy);\n        ro += texture(iChannel3, vec2(0.0)).xyz;\n    }\n    \n    Scene scene;\n    scene.nr_lights = 0;\n    scene.nr_shapes = 0;\n    \n    sceneAddLight(scene, Light(\n        vec3(4.0, 8.0, -4.5),\n        32.0,\n        vec3(1.0)\n    ));\n    \n    sceneAddPlane(scene, Plane(\n        vec3(0.0, 10.0, 0.0),\n        vec3(0.0, 1.0, 0.0)\n    ), vec4(0.0), 16.0, vec3(1.0), 1.0);\n    \n    \n    /*\n    sceneAddPlane(scene, Plane(\n        vec3(0.0, 0.0, 48.0),\n        vec3(0.0, 0.0, -1.0)\n    ), vec4(0.0), 16.0, vec3(1.0), 1.0);\n    */\n    \n    sceneAddSphere(scene, Sphere(\n        vec3(0.0, 0.0, 9.0) + vec3(cos(T), sin(T), sin(T+3.14)*3.14),\n        1.0,\n        1.0\n    ), vec4(0.0), 1.0, vec3(1.0), 1.0);\n    \n    sceneAddBox(scene, Box(\n        vec3(7.0, 0.0, 16.0),\n        vec3(2.0)\n    ), vec4(0.1, 1.0, 0.5, T), 0.5, vec3(0.0, 0.9, 0.9), 0.99);\n    \n    sceneAddSphere(scene, Sphere(\n        vec3(-5.0, 2.0, 9.0),\n        2.0,\n        0.0\n    ), vec4(0.0), 1.0, vec3(1.0, 0.5, 1.0), 0.5);\n    \n    col = render(scene, ro, rd);\n  //  col = aces(col);\n  //  col = pow(col, vec3(0.5125));\n    \n    fragColor = vec4(col, 1.0);\n}","name":"Buffer C","description":"","type":"buffer"},{"inputs":[{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"float cdiff(vec3 a, vec3 b, float scalar, float th) {\n    float la = luma(a);\n    float lb = luma(b);\n    float d1 = pow(max(0.0, (la - lb)), 1.8 + (th*0.1));\n    float d2 = pow(abs(distance(a, b)), 5.0 + (th*0.5));\n    float k = pow((d1+d2)/2.0, 0.5 + th);\n    return smoothstep(0.0, 1.0, k*(scalar+th));\n}\n\nfloat edge(sampler2D tex, vec2 uv, float radius, float threshold, float scalar) {\n    vec2 s = vec2(textureSize(tex, 0).xy);\n    vec2 texel = radius / s;\n    vec3 right = textureLod(tex, uv + vec2(1.0, 0.0)*texel, 0.0).rgb;\n    vec3 down = textureLod(tex, uv + vec2(0.0, -1.0)*texel, 0.0).rgb;\n    vec3 corner = textureLod(tex, uv + vec2(1.0, -1.0)*texel, 0.0).rgb;\n    \n\n    float diffRightDown = cdiff(right, down, scalar, threshold);\n    float diffRightCorner = cdiff(right, corner, scalar, threshold);\n    float diffDownCorner = cdiff(down, corner, scalar, threshold);\n    \n    return clamp(smoothstep(0.0, 1.0, (1.0 / max(1.0, threshold*1.6))*(diffRightDown + diffRightCorner + diffDownCorner)), 0.0, 1.0);\n}\n\nvec3 blur(sampler2D tex, vec2 uv) {\n    const int filterSize = 4;\n    const int halfFilterSize = filterSize / 2;\n\n    const int start = -halfFilterSize;\n    const int end = -halfFilterSize + filterSize;\n    \n    vec2 texel = 1.0 / vec2(textureSize(tex, 0).xy);\n    vec3 avg = vec3(0.0);\n    int count = 0;\n\n    for(int x = start; x < end; ++x)\n    {\n        for(int y = start; y <= end; ++y)\n        {\n          avg += texture(tex, uv+(texel*vec2(x, y))).rgb;\n          count++;\n        }\n    }\n    \n    avg /= float(count);\n    return avg;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    vec3 next = texture(iChannel0, uv).xyz;\n    vec3 old = texture(iChannel1, uv).xyz;\n    \n    vec3 col = next;\n    \n    if (iFrame > 4) {\n       float e = clamp(2.0*max(0.001, edge(iChannel0, uv, 1.0, 0.33, 999.0)), 0.0, 1.0);\n       vec3 blurred = blur(iChannel0, uv);\n       next = mix(next, blurred, e);\n       vec3 sm = mix(old, next, 0.2);\n       sm = mix(sm, max(old, next), e*0.25);\n       col = mix(col, sm, e);\n    }\n    \n    fragColor = vec4(col, 1.0);\n}","name":"Buffer D","description":"","type":"buffer"}]}