{"ver":"0.1","info":{"id":"4tGSRz","date":"1482465468","viewed":377,"name":"ExteriorAlgebraNotebook2D","username":"jjcoolkl","description":"An interactive notebook showing how exterior algebra can be used to elegantly solve some types of geometry problems.","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["math","algebra","clipping"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"///////////////////////////////////////////////////////////////////////////////\n//\n// 12/22/2016\n//\n// INTRO:\n//\n// This is an interactive tutorial of using exterior (or Grassmann) algebra to\n// solve geometry problems in an elegant way.  The intent is to introduce the \n// concepts of exterior algebra in the simpest possible context (2D projective\n// geometry) and to focus on practical, hands-on application instead of \n// theory.  I first learned about the wedge product in a differential geometry \n// class in college, but I didn't really 'get' how it worked until many years later.\n// My goal with this post is to pique the interest of others so that they realize\n// these mathematical tools exist, and want to pursue them further.\n//\n// If you are interested in learning more of the theory I would recommend\n// the excellent GDC talk by Eric Lengyel [1] as a next step before jumping into\n// a more general algebra text.\n//\n// This is intended to be read as an interactive blog post (or maybe a Mathematica\n// notebook).  To get started, jump down to STEP1 below!\n// \n// [1] Lengyel, Eric. 'Fundamentals of Grassmann Algebra' GDC 2012. \n//      http://www.terathon.com/gdc12_lengyel.pdf\n//\n// DISCLAIMER: \n//\n// I am not an expert in abstract algebra and would welcome (constructive) criticism!  \n// It is likely I have made mistakes or missed the best way to explain a concept. Let \n// me know in the comments or on Twitter!\n//\n// John Kloetzli, Jr\n//\n// Twitter: @jjcoolkl\n//\n///////////////////////////////////////////////////////////////////////////////\n\n#define WHITE vec3(1,1,1)\n#define BLACK vec3(0,0,0)\n#define RED vec3(1,0,0)\n#define GREEN vec3(0,1,0)\n#define BLUE vec3(0,0,1)\n\n///////////////////////////////////////////////////////////////////////////////\n// Definitions of the Point2D and Line2D structures.\nstruct Point2D\n{\n    float x, y, w;\n};\nstruct Line2D\n{\n    float x, y, w;\n};\n    \nLine2D BuildLine( vec2 N, float D )\n{\n    N = normalize(N);\n  \treturn Line2D( N.x, N.y, D );\n}\n\n///////////////////////////////////////////////////////////////////////////////\n// Operations on Point2D and Line2D\nfloat DistancePointLine( Point2D l, Line2D r )\n{\n    return l.x*r.x + l.y*r.y + l.w*r.w;\n}\nLine2D UnionPointPoint( Point2D l, Point2D r )\n{\n    return Line2D( l.y*r.w - l.w*r.y, l.w*r.x - l.x*r.w, l.x*r.y - l.y*r.x);\n}\nPoint2D IntersectLineLine( Line2D l, Line2D r )\n{\n    return Point2D( l.y*r.w - l.w*r.y, l.w*r.x - l.x*r.w, l.x*r.y - l.y*r.x );\n}\n\n///////////////////////////////////////////////////////////////////////////////\n// Viewport and drawing functions\nvec2 ViewMin;\nvec2 ViewMax;\nvec2 ViewSpan;\n\nPoint2D Pixel;\n\nvec3 OutColor = vec3(1,1,1);\nvoid Blend( vec3 Color, float Alpha )\n{\n    Alpha = clamp( Alpha, 0.0, 1.0 );\n    OutColor = OutColor * (1.0 - Alpha) + Color * Alpha;\n}\n\nLine2D DrawLine( Line2D L, vec3 Color, bool bDrawOrientation )\n{ \n    float Alpha = 0.0;\n    float SignedDistance = DistancePointLine( Pixel, L );\n    {\n        float Width = 4.0;\n    \tAlpha = max( Alpha, 1.0 - clamp( abs( SignedDistance ) * (iResolution.x * 0.5 / Width), 0.0, 1.0 ) );\n    }\n    \n    if( bDrawOrientation && SignedDistance > 0.0 )\n    {\n        float Width = 2.0;\n        Line2D O = Line2D( L.y, -L.x, 0.0 );\n        float Distance = abs( DistancePointLine( Pixel, O ) );\n        Alpha = max( Alpha, 1.0 - clamp( Distance * (iResolution.x * 0.5 / Width), 0.0, 1.0 ) );\n    }\n    \n    Blend( Color, Alpha );\n    \n    return L;\n}\nLine2D DrawLine( Line2D L, vec3 Color )\n{\n    return DrawLine( L, Color, false );\n}\n\nPoint2D DrawPoint( Point2D P, vec3 Color )\n{\n    float Width = 4.5;\n    vec2 Diff = vec2( Pixel.x - (P.x/P.w), Pixel.y - (P.y/P.w) );\n    float Alpha = 1.0 - clamp( (length( Diff ) * (iResolution.x / Width)) - Width, 0.0, 1.0 );\n    Blend( Color, Alpha );\n    \n    return P;\n}\n\n///////////////////////////////////////////////////////////////////////////////\n// STEP1: Points and Lines\n//\n// In this demo we are using 3D Exterior algebra to describe 2D space by using homogeneous \n// coordinates.  This means that every 2D point is represented by a 3-vector [x,y,w], where \n// the final Euclidian point is [x/w, y/w].  If this doesn't sound familiar you should\n// probably stop here and find a tutorial.\n//\n// 3D exterior algebra defines two non-scalar objects: 3-Vectors, which corresond to 2D Points\n// under projection, and 3-BiVectors, which correspond to lines under projection.\n///////////////////////////////////////////////////////////////////////////////\nvoid DrawStep1()\n{\n    //return; //Uncomment to disable this step.\n    \n    // A 3-vector is a point represented as a linear combination of 3 basis vectors. The basis \n    // vectors are typically defined as:\n    // v1 = [1,0,0]\n    // v2 = [0,1,0] and\n    // v3 = [0,0,1]\n    //\n    // We call our 3-vector struct 'Point2D'in order to emphasize that we are using it to represent\n    // a 2D projected point.  The first two components (x and y) define the point on the 2D plane if we\n    // have w = 1.\n    \n    //Draw the 2D basis vectors.\n    DrawPoint( Point2D( 1.0, 0.0, 1.0 ), BLUE );\n    DrawPoint( Point2D( 0.0, 1.0, 1.0 ), GREEN ); \n    \n    //Draw a few other points\n    DrawPoint( Point2D( 0.2, .65, 1.0 ), RED );\n    DrawPoint( Point2D(-0.5,-0.65, 1.0 ), RED + BLUE );\n    \n    \n    // A 3-bivector is also represented as a linear combination of 3 basis objects, but in\n    // this case the basis objects are bivectors.  They are:\n    // b1 = v2^v3\n    // b2 = v3^v1 and\n    // b3 = v1^v2\n    //\n    // Each bivector basis is defined by two of the vector basis objects multiplied by the special \n    // 'wedge' product denoted by the '^'.  Just like a 3-vector represents a 1-dimensional object\n    // in 3D (projected to a 2D point) a 3-bivector represents a 2-dimensional object in 3D \n    // (projected to a 1-dimensional line in 2D).  We are going to call our 3-bivector 'Line2D' \n    // to emphasize this fact.\n    \n    // There is also a geometric interpretation of the components of Line2D: The first two (x,y) \n    // form a normalized 2D vector perpendicular to the line, while the third component w is the \n    // distance along that vector from the origin to the line.\n    \n    // Diagonal line through the origin\n    Line2D L = BuildLine( vec2(1.0, 1.0), 0.0 );\n\tDrawLine( L, RED );\n    \n    // The same line, but shifted .5 along the normal\n    //DrawLine( BuildLine( vec2(1.0, 1.0), 0.5 ), GREEN );\n    \n    // Wait, why did the line shift that direction? Lines also have *orientation*.  They split the \n    // 2D plane into a positive half and a negative half.  The third component of the line will \n    // shift it towards the *negative* direction in whatever orientation it has.  \n    \n    // Let's shift the same line by -0.5, this time showing the orientation by drawing a \n    // perpendicular line on the positive side.\n    //DrawLine( BuildLine( vec2(1.0, 1.0), -0.5 ), GREEN, true );\n    \n    // Finally, we can change the orientation by negating the normal vector.\n    \n    //DrawLine( BuildLine( vec2(0.1, -0.5), -0.5 ), BLUE, true );\n    //DrawLine( BuildLine(-vec2(0.1, -0.5), 0.1 ), RED + GREEN, true );\n}\n\n///////////////////////////////////////////////////////////////////////////////\n// STEP2: Union and Intersection\n//\n// Remember the wedge product (^) from above?  It turns out that you can represent\n// a lot of useful geometric transforms with the wedge and symmetric anti-wedge products.\n///////////////////////////////////////////////////////////////////////////////\nvoid DrawStep2()\n{\n    return; //comment me out to begin step 2 (You may want to uncomment the return statement \n    // from the previous step to keep things getting too busy)\n    \n    // We saw how to construct a line from a normal and 'shift' distance, but you can also\n    // construct a line from any two points by computing their union with the wedge product.\n    Point2D P1 = DrawPoint( Point2D( -.2, .4, 1.0 ), RED );\n    Point2D P2 = DrawPoint( Point2D( .6, -.2, 1.0 ), RED );\n        \n    Line2D L1 = DrawLine( UnionPointPoint(P1, P2), BLUE );\n    \n    // If you look at the definition of UnionPointPoint() above, you will see it looks *very* \n    // similar to the cross product. In fact, there is only one difference between the wedge\n    // product of two 3-vectors and their cross product: The result of the wedge product is\n    // a 3-bivector, while the result of a cross-product is still a 3-vector.  This is actually\n    // a pretty important distinction.\n    \n    // The cross product has to do with *orthogonality*. The resulting 3-vector is orthogonal to \n    // both of the input vectors.  This is very useful, but has several rather confusing byproducts.  \n    // First, this orthogonality only makes sense in 3D space.  If you are in 2D or 4D you need \n    // an *implicit* conversion to 3D before you can apply the cross product, and another implicit \n    // conversion back to use the result.  More seriously, the resulting 3-vector has a special \n    // 'magic' property: if you want to transform it by a matrix, you need to use the \n    // *inverse transpose* matrix from the one that you would use to transform points.  The \n    // cross-product returns a 'special' 3-vector that isn't *quite* like a normal 3-vector.\n    \n    // The wedge product, on the other hand, looks at things from the perspective of *area*\n    // (or union of the two 3-vectors).  This generalizes quite nicely: in 3D projective space (the one \n    // we usually use in computer graphics) the wedge product of two points is a line, and the \n    // wedge product of three points (or a point and a line) is a plane.  The special rule\n    // about transformation make sense as well: 3-bivectors *always* transform by the inverse \n    // transpose matrix from 3-vectors.  Instead of a 'magic' rule we have a very concrete one.\n    \n    // Some people argue that this distinction is pedantic, and that any reasonable person\n    // can be expected to keep track of the special rules around cross products.  There is \n    // some truth to this, and trying to be too picky about math details can be a lot of \n    // effort with very little benefit.  Use the cross product if what you need is the cross\n    // product.  However, if you find yourself going through mental gymnastics in order to \n    // apply the cross-product, you may want to back up a bit and figure out exactly what\n    // mathematical spaces you are actually dealing with.  Implicitly moving between spaces\n    // has been the source of many subtle graphics bugs.\n    \n    \n    \n    // The wedge product has a symmetric counterpart called (surprisingly) the 'anti-wedge' product \n    // (or regressive product).  If the wedge product allows us to union objects, then the\n    // anti-wedge product allows us to *intersect* objects.  Lo and Behold, the anti-wedge of two \n    // Line2D objects gives us the Point2D where they intersect.\n    \n    //Line2D L2 = DrawLine( BuildLine( vec2( -.1, 0.02 ), .1 ), GREEN );\n    //DrawPoint( IntersectLineLine( L1, L2 ), BLACK );\n    \n    // If you look up the definition of IntersectLineLine() you will notice that is looks just like\n    // the definition of UnionPointPoint().  When I said the anti-wedge product was symmetric\n    // to the wedge product, I wasn't kidding.  The difference is that the anti-wedge product\n    // acts on *bivectors* the same way the wedge product acts on *vectors*.  In some very real\n    // sense bivectors represent -negative- space in the same way vectors represent positive space.\n    // I would be lying if I said I understood exactly how this works.\n    \n    // Just like the wedge product generalizes the concept of union, the anti-wedge product \n    // generalizes the concept of intersection.  In 3D projective space, the anti-wedge of two\n    // planes is the line where they intersect, the anti-wedge of three planes is the point where\n    // they intersect, and the anti-wedge of a line and a plane is the point where the line \n    // intersects the plane.\n}\n\n///////////////////////////////////////////////////////////////////////////////\n// STEP3: Clipping\n//\n///////////////////////////////////////////////////////////////////////////////\nvoid DrawStep3()\n{\n\treturn;   \n    \n    // We can also take the wedge product of a 3-vector and a 3-bivector (which results\n    // in a scalar).  In our 2D projective example this corresponds to the minimal signed distance \n    // from the point to the line.  Since this is signed distance, we can use it to easily detect\n    // whether a point is on the positive or negative side of the line.\n    \n \tLine2D L1 = DrawLine( BuildLine( vec2( 0.4, 0.1 ), 1.0 ), BLUE, true );\n    Line2D L2 = DrawLine( BuildLine( vec2( -0.1, 0.3 ), 0.5 ), RED, true );\n    Line2D L3 = DrawLine( BuildLine( vec2( -0.2, -0.6 ), 0.5 ), RED, true );\n    \n    float MinDist = DistancePointLine( Pixel, L1 );\n    MinDist = min( MinDist, DistancePointLine( Pixel, L2 ) );\n    MinDist = min( MinDist, DistancePointLine( Pixel, L3 ) );\n    if( MinDist > 0.0 )\n    {\n        Blend( BLACK, .3 );\n    }\n    \n    // As you would expect with exterior algebra, the real power here is that this generalizes to\n    // higher dimensions.  In fact, the traditional 4D clipping plane widely used in computer graphics \n    // is the analog of the clipping lines in this example.\n    \n    // In my experience as a graphics programmer, clipping is an area where the exterior algebra\n    // approach is particularly useful.  The ability to easily union and intersect geometry makes \n    // the job of building clipping planes for complex situations much easier than if you needed\n    // to represent everything with vectors alone.  I don't recommend using the ideas of exterior\n    // algebra to solve every problem, but it is a useful tool to have in the toolbox.\n    \n    // fin\n}\n\n\n///////////////////////////////////////////////////////////////////////////////\n// Main function and grid rendering\nvoid DrawGrid()\n{   \n    float FineScale = 4.0;\n    float FineWeight = 2.0;\n    \n    float CoarseScale = 1.0;\n    float CoarseWeight = 4.0;\n    \n    vec2 P = vec2(Pixel.x, Pixel.y);\n\n    vec2 FineNorm = iResolution.xy / (ViewSpan * FineScale * FineWeight);\n    vec2 FineGrid = FineNorm * abs( 1.0 - 2.0 * fract(P * FineScale ) ) - FineNorm + 1.0;\n    Blend( vec3(0.6,0.6,0.6), max( FineGrid.x, FineGrid.y) );\n    \n    vec2 CoarseNorm = iResolution.xy / (ViewSpan * CoarseScale * CoarseWeight);\n    vec2 CoarseGrid = CoarseNorm * abs( 1.0 - 2.0 * fract(P * CoarseScale ) ) - CoarseNorm + 1.0;\n    Blend( vec3(0.0,0.0,0.0), max( CoarseGrid.x, CoarseGrid.y) );\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ViewSpan = vec2( 2.0 * iResolution.x / iResolution.y, 2.0 );\n    ViewMin = -ViewSpan * 0.5;\n    ViewMax = +ViewSpan * 0.5;\n    \n\tvec2 v = (fragCoord.xy / iResolution.xy) * ViewSpan + ViewMin;\n    Pixel = Point2D( v.x, v.y, 1.0 );\n    \n    DrawGrid();\n    \n    DrawPoint( Point2D( 0.0, 0.0, 1.0 ), BLACK );\n    \n\tDrawStep1();\n    DrawStep2();\n    DrawStep3();\n    \n    fragColor = vec4( OutColor, 1.0 );\n}","name":"Image","description":"","type":"image"}]}