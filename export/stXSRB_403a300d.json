{"ver":"0.1","info":{"id":"stXSRB","date":"1625939466","viewed":146,"name":"A Mandelbulb Candy","username":"playbyan1453","description":"Updated with new mouse controls","likes":7,"published":1,"flags":32,"usePreview":0,"tags":["fractal","mandelbulb","candy"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define tmax 1e1\n#define steps 1024\n#define tmin 1e-4\n#define detail 1.0\n\nfloat sphereSDF(vec3 p, float r) {\n    return length(p) - r;\n}\n\nfloat cubeSDF(vec3 p, vec3 s) {\n    vec3 q = abs(p) - s;\n    return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);\n}\n\nfloat torusSDF(vec3 p, vec2 t) {\n    return length(vec2(length(p.xz) - t.x, p.y)) - t.y;\n}\n\nfloat mandelbulbSDF(vec3 p, float power, out float t) {\n    vec3 z = p;\n    float r = 0.0;\n    float dz = 1.0;\n    t = 1.0;\n    for(int i = 0; i < 2; i++) {\n        dz = power * pow(r, (power - 1.0) * 0.5) * dz + 1.0;\n        float th = power * acos(clamp(z.z / r, -1.0, 1.0));\n        float ph = power * atan(z.y, z.x);\n        z = p + pow(r, power) * vec3(sin(th) * cos(ph), sin(ph) * sin(th), cos(th));\n        r = length(z);\n        if(r > 2.0) break;\n    }\n    t = length(sin((z - p) * 2.0));\n    return 0.8 * log(r) * sqrt(r) / dz;\n}\n\nfloat map(vec3 p, out int mat, out float t) {\n    float b = length(p) - 1.5;\n    if(b > 0.1) return b; // bounding volume will increase the peformance a little\n\n    float a = mandelbulbSDF(p, 6.0+sin(iTime/2.0)*3.0, t);\n    float d = a;\n    if(d == a) mat = 0;\n\n    return d;\n}\n\nvec3 normal(vec3 p, float ep) {\n    vec2 h = vec2( 1,-1)*ep;\n    float tmp;\n    int i;\n    return normalize(h.xyy*map(p + h.xyy, i, tmp)+\n                     h.yyx*map(p + h.yyx, i, tmp)+\n                     h.yxy*map(p + h.yxy, i, tmp)+\n                     h.xxx*map(p + h.xxx, i, tmp));\n}\n\nfloat adDist(float t, float fov, float de) {\n    float d = de / fov; // Lower more detail\n    return max(t / max(iResolution.x, iResolution.y) * d + tmin, tmin);\n}\n\nfloat raymarch(vec3 ro, vec3 rd, float fov, out int mat, out float f) {\n    float t = 0.0;\n    int id;\n    for(int i = 0; i < steps; i++) {\n        float d = map(ro + rd * t, id, f);\n        t += d;\n        if(abs(d) < adDist(t, fov, detail)) {\n            mat = id;\n            break;\n        }\n        if(t > tmax) {\n            mat = -1;\n            break;\n        }\n    }\n    return t;\n}\n\nmat3 cam(vec3 at, vec3 ro) {\n    vec3 z = normalize(at - ro);\n    vec3 x = normalize(cross(vec3(0, 1, 0), z));\n    vec3 y = cross(z, x);\n    return mat3(x, y, z);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord.xy-0.5*iResolution.xy)/max(iResolution.x, iResolution.y);\n    vec3 at = vec3(0, 0, 0);\n    vec3 ro = texelFetch(iChannel0, ivec2(0.5, 1.5), 0).xyz;\n    mat3 ca = cam(at, ro);\n    float fov = 1.0;\n    vec3 rd = ca * normalize(vec3(uv, fov));\n    \n    int mat = -1;\n    float trap;\n    float t = raymarch(ro, rd, fov, mat, trap);\n    vec3 p = ro + rd * t;\n\n    vec3 environment = vec3(0.4, 0.7, 0.8);\n    vec3 col = environment;\n    vec3 albedo = vec3(0);\n    vec3 spc = vec3(0);\n    float hardness = 0.0;\n    if(t < tmax) {\n        if(mat == 0) {\n            float ab = min(abs(max(trap + 0.5, 0.5) * 2.0 - 1.0), 1.0);\n            float bc = min(abs(max(trap     , 0.5) * 2.0 - 1.0), 1.0);\n            albedo = vec3(mix(mix(vec3(1, 0, 0), vec3(0, 1, 0), ab), vec3(0, 0, 1), bc));\n            albedo = pow(albedo, vec3(2.2));\n            spc = vec3(0.5);\n            hardness = 10.0;\n        }\n        vec3 lig = normalize(vec3(3, 5, -6));\n        float fi = adDist(t, fov, detail);\n        vec3 nor = normal(p, fi);\n        float dif = max(0.0, dot(nor, lig))*2.0;\n        float spc = pow(max(0.0, dot(normalize(lig-rd), nor)), 25.0);\n        spc *= mix(spc, dif, max(0.0, dot(nor, -rd))*0.6+0.4);\n        col = mix(spc*vec3(1), (dif+environment)*albedo, max(0.0, dot(nor, -rd))*0.6+0.4); // simple material system that im implementing on my old raytracer\n    }\n    if(mat == -1) col = environment; // sometime material on infinite plane results on black line\n    col = tanh(pow(col, vec3(0.5)));\n\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Mouse By Alro : https://www.shadertoy.com/view/7dVGzz\n#define eps 1e-4\n\nvec3 erot(vec3 p, vec3 ax, float ro) {\n    return mix(dot(p,ax)*ax,p,cos(ro))+sin(ro)*cross(ax,p);\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n    // Work with just the first four pixels.\n    if((fragCoord.x == 0.5) && (fragCoord.y < 4.0)) {\n        vec4 oldMouse = texelFetch(iChannel0, ivec2(0.5), 0);\n        vec4 mouse = iMouse / iResolution.xyxy; \n        vec4 newMouse = vec4(0);\n        float mouseDownLastFrame = texelFetch(iChannel0, ivec2(0.5, 3.5), 0).x;\n        \n        // If mouse button is down and was down last frame\n        if(iMouse.z > 0.0 && mouseDownLastFrame > 0.0) {\n            // Difference between mouse position last frame and now.\n            vec2 mouseMove = mouse.xy - oldMouse.zw;\n            newMouse = vec4(oldMouse.xy + vec2(6.2831853, 3.1415927) * mouseMove, mouse.xy);\n        } else {\n            newMouse = vec4(oldMouse.xy, mouse.xy);\n        }\n        newMouse.x = mod(newMouse.x, 6.2831853);\n        newMouse.y = clamp(newMouse.y,-1.5707963 + eps, 1.5707963 - eps);\n\n        // Store mouse data in the first pixel of Buffer A.\n        if(fragCoord == vec2(0.5, 0.5)) {\n            // Set value at first frames\n            if(iFrame < 0) {\n                newMouse = vec4(0);\n            }\n            fragColor = newMouse;\n        }\n\n        // Store camera position in the second pixel of Buffer A.\n        if(fragCoord == vec2(0.5, 1.5)) {\n            // Set camera position from mouse information.\n            vec2 mouse_rotation = newMouse.xy;\n            vec2 yawpitch = vec2(mouse_rotation.x, -mouse_rotation.y);\n            \n            vec3 cameraPos = vec3(0, 0,-6);\n            cameraPos = erot(cameraPos, vec3(1, 0, 0), yawpitch.y);\n            cameraPos = erot(cameraPos, vec3(0, 1, 0), yawpitch.x);\n            \n            fragColor = vec4(cameraPos, 1.0);\n        }\n        \n        // Store resolution change data in the third pixel of Buffer A.\n        if(fragCoord == vec2(0.5, 2.5)) {\n            float resolutionChangeFlag = 0.0;\n            // The resolution last frame.\n            vec2 oldResolution = texelFetch(iChannel0, ivec2(0.5, 2.5), 0).yz;\n            \n            if(iResolution.xy != oldResolution) {\n            \tresolutionChangeFlag = 1.0;\n            }\n        \tfragColor = vec4(resolutionChangeFlag, iResolution.xy, 1.0);\n        }\n           \n        // Store whether the mouse button is down in the fourth pixel of Buffer A\n        if(fragCoord == vec2(0.5, 3.5)) {\n            if(iMouse.z > 0.0) {\n            \tfragColor = vec4(vec3(1), 1.0);\n            } else {\n            \tfragColor = vec4(vec3(0), 1.0);\n            }\n        }\n    }\n}","name":"Buffer A","description":"","type":"buffer"}]}