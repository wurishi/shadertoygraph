{"ver":"0.1","info":{"id":"4fGGWG","date":"1714229624","viewed":412,"name":"Arrest","username":"panna_pudi","description":".","likes":27,"published":1,"flags":32,"usePreview":1,"tags":["repetition","raytrace","mis"],"hasliked":0,"parentid":"dt3yzN","parentname":"Arrest (dev spherical rect)"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Power by Pudi\n// Email: krems.pudi@gmail.com\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n// I couldn't make it without these shaders:\n//\n// Sampling Spherical Rectangle by koiava\n// https://www.shadertoy.com/view/ltsyzl\n// https://www.solidangle.com/research/egsr2013_spherical_rectangle.pdf\n//\n// Walking trip by athibaul\n// https://www.shadertoy.com/view/td3cW7\n// \n// RayTracing Domain Repetition by kastorp\n// https://www.shadertoy.com/view/NlycW1\n\nvec3 pmove() {\n    return vec3(25., 0., 1.2);\n}\n\nfloat map(vec3 p) {\n    p -= pmove();\n    \n#ifdef REPJ\n    float t = iTime * 0.75;\n#else\n    float t = 2.;\n#endif\n\n    float d = 1e9;\n    \n    float s = 2.;\n\n    d = prisoner(p / s, t) * s;\n\n    t += step(p.y, 0.) * 0.75;\n    p = vec3(p.x, sabs(p.y, 0.006) - 0.9 * s, p.z);\n\n    d = min(d, man(p / s, t) * s);\n\n    return d;\n}\n\nfloat softshadow( in vec3 ro, in vec3 rd, float mint, float maxt, float w ){\n    float res = 1.0;\n    float t = mint;\n    for( int i=min(iFrame, 0); i<35 && t<maxt; i++ )\n    {\n        float h = map(ro + t*rd);\n        res = min( res, h/(w*t) );\n        t += clamp(h, 0.005, 0.50);\n        if( res<-1.0 || t>maxt ) break;\n    }\n    res = max(res,-1.0);\n    return res;\n    // return 0.25*(1.0+res)*(1.0+res)*(2.0-res);\n}\n\nvec3 linear_to_srgb(vec3 col) {\n    return mix(1.055 * pow(col, vec3(1.0 / 2.4)) - 0.055,\n               col * 12.92,\n               lessThan(col, vec3(0.0031308)));\n}\n\nfloat mink_dist(vec3 x, vec3 y, float p) {\n    vec3 d = x - y;\n    vec3 metric = pow(abs(d), vec3(p));\n\n    return clamp(pow(metric.x + metric.y + metric.z, 1. / p), 0., 1.);\n}\n\nfloat voronoise(vec3 p) {\n    float d = 1e9;\n    float m = 0.;\n    vec3 i, v;\n    for (i.z = -1.; i.z <= 1.; i.z++) {\n        for (i.y = -1.; i.y <= 1.; i.y++) {\n            for (i.x = -1.; i.x <= 1.; i.x++) {\n                v = i - fract(p) + hash33(floor(p) + i);\n                m = mink_dist(v, vec3(0.), .4);\n                d = min(d, m);\n            }\n        }\n    }\n    return d;\n}\n\nfloat noise(in vec2 x) {\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n    f = f * f * (3.0 - 2.0 * f);\n    // f *= f * f * (f * (f * 6. - 15.) + 10.);\n\n    float a = hash21(p + vec2(0, 0));\n    float b = hash21(p + vec2(1, 0));\n    float c = hash21(p + vec2(0, 1));\n    float d = hash21(p + vec2(1, 1));\n    return mix(mix(a, b, f.x), mix(c, d, f.x), f.y);\n}\n\nmat2 rot45 = mat2(0.707, -0.707, 0.707, 0.707);\n\n\nfloat fbm(vec2 st, float n) {\n    st *= 3.;\n\n    float s = .5;\n    float ret = 0.;\n    for (float i = min(0., float(iFrame)); i < n; i++) {\n        ret += noise(st) * s;\n        st *= 2.5, s /= 2.;\n        st *= rot45;\n        st.y += iTime * 0.05;\n    }\n    return ret;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord / iResolution.xy;\n    vec4 tunnel = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    \n    vec3 color = tunnel.rgb;\n    if (abs(uv.y) > .447) { color = vec3(0., 0., 0.); }\n    \n    vec3 ro = vec3(.0, -8.0, 6.);\n    vec3 lo = ro + vec3(0, 1, 0);\n    vec2 m = vec2(0.5);\n    float ax = -m.x * TWO_PI - PI * 1.35;\n    float ay = m.y * PI - PI * 0.55;\n\n    ro -= lo;\n    ro.zy *= rot(ay);\n    ro.yx *= rot(ax);\n    ro += lo;\n\n    vec3 cam = ro;\n    mat3 cmat = get_cam(ro, lo);\n\n    float focal_dist = 1.3;\n    vec3 rd = normalize(cmat * vec3(uv, focal_dist));\n    \n    vec3 pos;// = ro + rd * tunnel.w;\n    float plane = (-1.15 - ro.z) / rd.z;\n    if (plane > 0.) {\n        pos = ro + rd * plane;\n    }\n    //vec2 t = trace(ro, rd);\n    //if (t.y > 0. && t.x < plane) {\n    //    pos = ro + rd * t.x;\n    // //   color = vec3(0.85);\n    //}\n    \n    float shadow_mask = sd_plane(uv, normalize(vec2(.522, -1.)), 0.13);\n    //shadow_mask = min(shadow_mask, sd_plane(uv, normalize(vec2(-1., .44)), -0.53));\n    shadow_mask = min(shadow_mask, sd_plane(uv, normalize(vec2(-1., .64)), -0.4));\n    shadow_mask = min(shadow_mask, sd_plane(uv, normalize(vec2(-1., .7)), -0.6));\n    shadow_mask = min(shadow_mask, -.08 - uv.y);\n    if (AAstep(shadow_mask) < 0.5 ) {\n        vec3 light_pos = vec3(55., 0., 3.8);\n        vec3 light_dir = normalize(light_pos - pos);\n        float shad = softshadow(pos - rd * 0.3, light_dir, 0., 20., 0.09);\n        color *= clamp(shad, 0., 1.);\n    }\n    \n    vec2 p = uv - vec2(-0.275, -0.56);\n    p *= rot(-1.);\n    p *= vec2(1., .35);\n    float skymask = length(p) - 0.11;\n    color = mix(color, vec3(-0.01), smoothstep(.2, -0., skymask));\n    \n    vec2 starPos = uv;\n#ifdef REPJ\n    starPos += vec2(0.7, 0.5) * iTime * 0.01;\n#endif\n    float stars = 1. - voronoise(vec3(starPos * 20., 10.));\n    vec3 starColor = stars * vec3(1.0,1.0,0.82) * 2.;\n        \n    color = mix(color, starColor, smoothstep(.1, -0.1, skymask)); \n    //color += fbm(uv, 6.) *vec3(0.1, 0.7, 1.) * 0.1* smoothstep(.15, -0.05, skymask);\n    //color += fbm(uv, 3.) *vec3(0.7, 0.1, 1.) * 0.08* smoothstep(.125, -0., skymask);\n    \n    \n    fragColor = vec4(linear_to_srgb(color), 1);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define REPJ\n#define SRECT\n\nconst float PI = acos(-1.0);\nconst float INV_PI = 1. / PI;\nconst float TWO_PI = 2. * PI;\nconst float FOUR_PI = 4. * PI;\n\nconst int BOUNCES = 4;\n\nconst float NO_HIT = 1e10;\nconst float EPS = 0.0001;\n\nconst float CLAMP_VALUE = 5.;\n\nconst float TUNNEL_LEN = 5000.;\nconst int LIGHT_LEFT_ID = 0;\nconst int LIGHT_RIGHT_ID = 1;\nconst vec3 LIGHT_LEFT_POS = vec3(15., 7., -1.4);\nconst vec3 LIGHT_RIGHT_POS = vec3(15., -6.8, -2.);\nconst vec3 LIGHT_SIZE = vec3(TUNNEL_LEN, 2., 0.001);\n\nstruct Light {\n    vec3 pos;\n    vec3 size;\n    vec3 color;\n    vec3 intensity;\n};\n\nconst int LIGHT_COUNT = 2;\nLight LIGHTS[LIGHT_COUNT] = Light[](\n    Light(\n        LIGHT_LEFT_POS,\n        LIGHT_SIZE,\n        vec3(1., 0.5, 1.) * 2.,\n        vec3(10.)\n    ),\n    Light(\n        LIGHT_RIGHT_POS,\n        LIGHT_SIZE,\n        vec3(1., 0.5, 1.) * 1.,\n        vec3(10.)\n    )\n);\n\nLight get_light(in int obj_id) {\n    return LIGHTS[obj_id];\n}\n\nbool is_light(in int obj_id) {\n    return obj_id == LIGHT_LEFT_ID || obj_id == LIGHT_RIGHT_ID;\n}\n\nvec3 light_radiance(Light light) {\n    return light.color * light.intensity;\n}\n\nstruct BrdfSamplingResult {\n\tvec3 w;\n    float pdf;\n    vec3 f;\n    bool isDelta;\n};\n    \nstruct Ray {\n    vec3 origin;\n    vec3 direction;\n};\n\nRay ray_rotate_yz(Ray ray, float a) {\n    Ray r; vec3 ro = ray.origin; vec3 rd = ray.direction;\n    float c = cos(a), s = sin(a);\n    r.origin = vec3(ro.x, c * ro.y - s * ro.z, s * ro.y + c * ro.z);\n    r.direction = vec3(rd.x, c * rd.y - s * rd.z, s * rd.y + c * rd.z);\n    return r;\n}\n\nRay ray_move(Ray ray, vec3 off) {\n    return Ray(ray.origin - off, ray.direction);\n}\n\nconst int BSDF_DIFFUSE = 0;\nconst int BSDF_MIRROR = 1;\nconst int BSDF_PLASTIC = 2;\nconst int BSDF_LIGHT = 3;\n\nstruct Material {\n    vec3 color;\n    vec3 emissive;\n    int bsdf;\n    float roughness;\n};\n\nstruct HitInfo {\n    float t;\n    vec3 normal;\n    int obj_id;\n};\n\nstruct its {\n    float t;    // dist\n    vec3 norm;  // normal\n};\n\nstruct Span {\n    its a;  // distance and normal at entry\n    its b;  // distance and normal at exit\n};\nconst Span EmptySpan = Span(its(1e20, vec3(0)), its(-1e20, vec3(0)));\nbool isEmpty(Span i) {\n    return i.b.t < i.a.t;\n}\n\nSpan Inter(Span a, Span b) {\n   bvec4 cp = bvec4(a.a.t<b.a.t,a.a.t<b.b.t,a.b.t<b.a.t,a.b.t<b.b.t); \n   // if(b.a.t==NOHIT || a.a.t==NOHIT) return span(NO_its,NO_its);\n   \n   if(cp.x && cp.z) return EmptySpan;\n   else if(cp.x && !cp.z && cp.w)  return Span(b.a,a.b);\n   else if(cp.x && !cp.z && !cp.w) return b;\n   else if(!cp.x && cp.y &&  cp.w) return a;\n   else if(!cp.x && cp.y &&  !cp.w) return Span(a.a,b.b);\n   else return EmptySpan;\n}\n\nSpan Sub(Span a, Span b) {\n   bvec4 cp = bvec4(a.a.t<b.a.t,a.a.t<b.b.t,a.b.t<b.a.t,a.b.t<b.b.t); \n   // if(a.a.t==NOHIT) return span(NO_its,NO_its);\n   // else if(b.a.t==NOHIT) return a;        \n   if     (cp.x && cp.z) return a;\n   else if(cp.x && !cp.z && cp.w)  return Span(a.a,b.a);\n   else if(cp.x && !cp.z && !cp.w && b.a.t>0.) return Span(a.a,b.a); \n   else if(cp.x && !cp.z && !cp.w && b.a.t<0.) return Span(b.b,a.b); //+ secondary span =  span(b.b,a.b)\n   else if(!cp.x && cp.y && cp.w) return EmptySpan;\n   else if(!cp.x && cp.y && !cp.w) return Span(b.b,a.b);\n   else return a; \n}\n\nSpan Union(Span a, Span b) {\n   bvec4 cp = bvec4(a.a.t<b.a.t,a.a.t<b.b.t,a.b.t<b.a.t,a.b.t<b.b.t); \n   if(b.a.t==1e20) return a;\n   else if(a.a.t==1e20) return b;   \n   else if(cp.x  && cp.z  && a.b.t>0.) return a;\n   else if(cp.x  && cp.z  && a.b.t<0.) return b;\n   else if(cp.x  && !cp.z && cp.w) return Span(a.a,b.b);\n   else if(cp.x  && !cp.z && !cp.w) return a;\n   else if(!cp.x && cp.y  && cp.w) return b;\n   else if(!cp.x && cp.y  && !cp.w) return Span(b.a,a.b);\n   else if(!cp.x && !cp.y  && a.b.t>0.) return b;\n   else /*if(!cp.x && !cp.y  && a.b.t<0.) */ return a;   \n}\n\n// just solve for t, |ro+t*d|² = r²\nSpan isphere(in vec3 ro, in vec3 rd, float r) {\n    float b = dot(ro, rd);\n    float c = dot(ro, ro) - r * r;\n    float h = b * b - c;\n    if (h < 0.0) {\n        return EmptySpan;\n    }\n    h = sqrt(h);\n    float ta = -b - h;\n    vec3 na = (ro + ta * rd) / r;\n    float tb = -b + h;\n    vec3 nb = (ro + tb * rd) / r;\n    return Span(its(ta, na), its(tb, nb));\n}\n\n//  plane with thickness h\nSpan iPlane(in vec3 ro, in vec3 rd, in vec3 n, float h) {\n    float d1 = -dot(ro, n) / dot(rd, n), d2 = -(dot(ro - h * n, n)) / dot(rd, n);\n    vec3 u = normalize(cross(n, vec3(0, 0, 1))), v = normalize(cross(u, n));\n    vec3 oNor = n;\n    if (d1 < d2) {\n        return Span(its(d1, -oNor), its(d2, oNor));\n    }\n    return Span(its(d2, oNor), its(d1, -oNor));\n}\n\nSpan icylinder(in Ray ray, in vec3 ca, float cr) {\n    vec3 ro = ray.origin; vec3 rd = ray.direction;\n    float card = dot(ca, rd);\n    float caoc = dot(ca, ro);\n    float a = 1.0 - card * card;\n    float b = dot(ro, rd) - caoc * card;\n    float c = dot(ro, ro) - caoc * caoc - cr * cr;\n    float h = b * b - a * c;\n    if (h < 0.0)\n        return EmptySpan;\n    h = sqrt(h);\n    vec2 t = vec2(-b - h, -b + h) / a;\n    vec2 d = vec2(dot(ro + t.x * rd, ca), dot(ro + t.y * rd, ca));\n    vec3 nN = normalize(ro + t.x * rd - d.x * ca),\n         nF = normalize(ro + t.y * rd - d.y * ca);\n    its iN = its(t.x, nN);\n    its iF = its(t.y, nF);\n    return Span(iN, iF);\n}\n\nSpan ibox(in vec3 ro, in vec3 rd, in vec3 size) {\n    vec3 m = 1.0 / rd;\n    vec3 k = sign(rd) * size;\n    vec3 t1 = (-ro - k) * m;\n    vec3 t2 = (-ro + k) * m;\n    float tN = max(max(t1.x, t1.y), t1.z);\n    float tF = min(min(t2.x, t2.y), t2.z);\n    if (tN > tF || tF < 0.0)\n        return EmptySpan;\n    return Span(its(tN, -sign(rd) * step(vec3(tN), t1)),\n                its(tF, -sign(rd) * step(t2, vec3(tF))));\n}\n\nbool resolve(inout HitInfo hit, Span span, int obj_id) {\n    bool advanced = false;\n    its closest= span.a;\n    if (closest.t < 0.) { closest = span.b; }\n    if (closest.t < hit.t) {\n        advanced = true;\n        hit.normal = closest.norm;\n        hit.t = closest.t;\n        hit.obj_id = obj_id;\n    }\n    return advanced;\n}\n\nmat3 get_cam(vec3 ro, vec3 lo) {\n    vec3 cw = normalize(lo - ro);\n    vec3 cu = normalize(cross(cw, vec3(0, 0, 1)));\n    vec3 cv = cross(cu, cw);\n\n    return mat3(cu, cv, cw);\n}\n\nvec3 get_cam_proj(vec2 uv, inout vec3 eye, vec3 target) {\n    vec3 cw = normalize(target - eye);\n    vec3 cu = normalize(cross(cw, vec3(0., 0., 1.)));\n    vec3 cv = cross(cu, cw);\n    // return normalize(cw + cu * uv.x + cv * uv.y);\n    float fov = acos(dot(cw, normalize(cu * uv.x)));\n    float screen_size = 10.0 / (2.0 * tan(abs(fov) / 2.0));\n\n    float perspective = 0.3;\n    vec3 proj = cu * uv.x + cv * uv.y;\n    vec3 virtscreen = eye + cw + proj * screen_size;\n    eye = eye + proj * (0.7 + 0.2 * perspective) * screen_size;\n    return normalize(virtscreen - eye);\n}\n\nfloat saturate(float x) { return clamp(x, 0., 1.); }\nvec2 saturate(vec2 x) { return clamp(x, vec2(0), vec2(1)); }\nvec3 saturate(vec3 x) { return clamp(x, vec3(0), vec3(1)); }\n\nfloat luminance(vec3 c) { return dot(c, vec3(0.2126, 0.7152, 0.0722)); }\n\nmat2 rot(float a) {\n    float c = cos(a), s = sin(a);\n    return mat2(c, s, -s, c);\n}\n\n// Spectrum palette, iq https://www.shadertoy.com/view/ll2GD3\nvec3 palette(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n    return a + b * cos(6.28318 * (c * t + d));\n}\n\nvec3 spectrum(float n) {\n    return 1. - palette(n, vec3(0.5, 0.5, 0.5),\n                           vec3(0.5, 0.5, 0.5),\n                           vec3(2.0, 1.0, 0.0),\n                           vec3(0.5, 0.2,0.25));\n}\n\nvec3 purble_yellow(float x) {\n    vec3 phase = vec3(0.70, 0.24, 0.75);\n    vec3 amp = vec3(0.59, 0.41, 0.52);\n    vec3 freq = vec3(0.88, 0.95, 0.87);\n    vec3 offset = vec3(0.85, 0.22, 0.16);\n\n    phase *= TWO_PI;\n    x *= TWO_PI;\n    //return 0.5 + offset + amp * 0.5 * cos(x * freq + phase);\n    return 0.5 + vec3(offset.r + amp.r * 0.5 * cos(x * freq.r + phase.r),\n                      offset.g + amp.g * 0.5 * cos(x * freq.g + phase.g),\n                      offset.b + amp.b * 0.5 * cos(x * freq.b + phase.b));\n}\n\n\n#define coprimes vec2(2, 3)\nvec2 halton(vec2 s) {\n    vec4 a = vec4(1, 1, 0, 0);\n    while (s.x > 0. && s.y > 0.) {\n        a.xy = a.xy / coprimes;\n        a.zw += a.xy * mod(vec2(s), coprimes);\n        s = floor(s / coprimes);\n    }\n    return a.zw;\n}\n\n// RNG\nuint SEED = 111425u;\nvoid init_seed(vec2 coord, int frame) {\n    SEED = uint(coord.x) * 1321u +\n           uint(coord.y) * 4123u +\n           uint(frame) * 4123u * 4123u;\n}\n\nuint hash_u(uint _a) {\n    uint a = _a;\n    a ^= a >> 16;\n    a *= 0x7feb352du;\n    a ^= a >> 15;\n    a *= 0x846ca68bu;\n    a ^= a >> 16;\n    return a; \n}\n\nfloat hashf(){ \n    uint s = hash_u(SEED); SEED = s; \n    return (float( s ) / float(0xffffffffu)); \n}\nvec2 hash2(){ return vec2(hashf(), hashf()); }\nvec3 hash3(){ return vec3(hashf(), hashf(), hashf()); }\nvec4 hash4(){ return vec4(hashf(), hashf(), hashf(), hashf()); }\n\nfloat hash11(float p) {\n    p = fract(p * .1252);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\nvec2 hash12(float p) {\n\tvec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nfloat hash21(vec2 p) {\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec3 hash33(vec3 p3) {\n    p3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz + 33.33);\n    return fract((p3.xxy + p3.yxx) * p3.zyx);\n}\n\nfloat tnoise(vec2 co) {\n    co.y += co.x / 2.;\n    vec2 p = floor(co);\n    if (fract(co.x) < fract(co.y)) {\n        p += .5;\n    }\n    return hash21(p);\n}\n\nfloat smooth_hill(float x, float off, float width, float gap) {\n    x -= off;\n    float start = width, end = width + max(0., gap);\n    return smoothstep(-end, -start, x) - smoothstep(start, end, x);\n}\n\nfloat sd_plane(vec2 uv, vec2 n, float w) {\n    return dot(uv, n) - w;\n}\n\nfloat sd_line(vec2 p, vec2 a, vec2 b) {\n    vec2 pa = p - a, ba = b - a;\n    float k = dot(pa, ba) / dot(ba, ba);\n    return distance(p, mix(a, b, clamp(k, 0., 1.)));\n}\n\nfloat AAstep(float thre, float val) {\n    return smoothstep(-.5, .5, (val - thre) / min(0.03, fwidth(val - thre)));\n}\nfloat AAstep(float val) {\n    return AAstep(val, 0.);\n}\n\nfloat gain(float x, float d) {\n    // Modified gain function, for x between -1 and 1\n    // k<1. makes the output stay around zero more,\n    // k>1. makes the output stay around +-1 more.\n    return (1. - pow(1. - abs(x), d)) * sign(x);\n}\n\n#define smix(a, b, x) mix(a, b, 0.5 + 0.5 * (x))\n// #define BARE_BONES\n#ifdef BARE_BONES\n#define smin(a, b, k) min(a, b)\n#define smax(a, b, k) max(a, b)\n#else\nfloat smin(float a, float b, float k) {\n    float h = clamp(1. - abs((b - a) / k), 0., 2.);\n    return min(a, b) - k * 0.25 * h * h * step(-1., -h);\n}\nfloat smax(float a, float b, float k) {\n    float h = clamp(1. - abs((b - a) / k), 0., 2.);\n    return max(a, b) + k * 0.25 * h * h * step(-1., -h);\n}\n#endif\n\nfloat sabs(float x, float k) {\n    return sqrt(x * x + k);\n}\n\nfloat sd_box(vec3 p, vec3 h) {\n    p = abs(p) - h;\n    return length(max(p, 0.)) + min(max(max(p.x, p.y), p.z), 0.);\n}\n\nfloat sdRoundCone(in vec3 p, in float r1, float r2, float h) {\n    vec2 q = vec2(length(p.xz), p.y);\n\n    float b = (r1 - r2) / h;\n    float a = sqrt(1.0 - b * b);\n    float k = dot(q, vec2(-b, a));\n\n    if (k < 0.0)\n        return length(q) - r1;\n    if (k > a * h)\n        return length(q - vec2(0.0, h)) - r2;\n\n    return dot(q, vec2(a, b)) - r1;\n}\nfloat sdVerticalCapsule(vec3 p, float h, float r) {\n    p.z -= clamp(p.z, 0.0, h);\n    return length(p) - r;\n}\n\nfloat dot2(vec2 x) {\n    return dot(x, x);\n}\nfloat dot2(vec3 x) {\n    return dot(x, x);\n}\nfloat sdRoundCone(vec3 p, vec3 a, vec3 b, float r1, float r2) {\n    // sampling independent computations (only depend on shape)\n    vec3 ba = b - a;\n    float l2 = dot(ba, ba);\n    float rr = r1 - r2;\n    float a2 = l2 - rr * rr;\n    float il2 = 1.0 / l2;\n\n    // sampling dependant computations\n    vec3 pa = p - a;\n    float y = dot(pa, ba);\n    float z = y - l2;\n    float x2 = dot2(pa * l2 - ba * y);\n    float y2 = y * y * l2;\n    float z2 = z * z * l2;\n\n    // single square root!\n    float k = sign(rr) * rr * rr * x2;\n    if (sign(z) * a2 * z2 > k)\n        return sqrt(x2 + z2) * il2 - r2;\n    if (sign(y) * a2 * y2 < k)\n        return sqrt(x2 + y2) * il2 - r1;\n    return (sqrt(x2 * a2 * il2) + y * rr) * il2 - r1;\n}\n\nvec3 get_shoulder(float t) {\n    return vec3(-0.02 + 0.01 * sin(PI * t + PI / 4.), -0.08,\n                0.15);  // Rocking shoulder\n}\n\nfloat half_body(vec3 p, float t) {\n    p.y *= -1.;\n    float d = 1e9;\n\n    // torso\n    vec3 hip = vec3(-0.01 - 0.02 * sin(PI * t), -0.095, -0.27);  // Rocking hip\n    d = sdRoundCone(p, vec3(0.02, -0.07, -0.1), hip, 0.08, 0.10);\n    float srad = 0.1 * smoothstep(0., 0.1, 0.095 - 0.5 * p.x);\n    vec3 shoulder = get_shoulder(t);\n    d = smin(d,\n             sdRoundCone(p, vec3(0.02, -0.07, -0.02), shoulder, 0.085, 0.125),\n             srad);\n\n    // Femur\n    float th2M = TWO_PI / 11., th2m = -TWO_PI * 13. / 360.;  // Min/max angles\n    float th2 =\n        smix(th2M, th2m, sin(PI * t));  // Femur oscillation is sinusoidal\n    float femurL = 0.46;\n    vec3 q = p - hip;\n    q.xz *= rot(th2);\n    q.yz *= rot(0.02);  // Femur points \"inwards\" a bit\n    q.z += femurL;\n    d = smin(d, sdRoundCone(q.xzy, 0.06, 0.095, 0.4), 0.03);\n\n    // Tibia\n    float th1M = -0.01, th1m = -TWO_PI / 6.;\n    // Tibia oscillation is... complicated.\n    // It is delayed by PI/4 relative to the femur, and stays around\n    // extreme values more.\n    float th1 = mix(th1M, th1m, pow(0.5 + 0.5 * sin(PI * t - TWO_PI / 4.), 2.));\n    float tibiaL = 0.355;\n    q.y += 0.005;\n    q.xz *= mat2(cos(th1), sin(th1), -sin(th1), cos(th1));\n    q.yz *= rot(-0.05);\n    q.z += tibiaL;\n    d = smin(d, sdRoundCone(q.xzy, 0.041, 0.055, 0.31), 0.02);\n\n    // Foot\n    float th0set = -th1 - th2;\n    // When lifted, it is first pointing \"down\" a lot,\n    // then pointing \"up\" a bit.\n    float th0relax = 0.5 * th1 + 0.1;\n    // Mix them based on whether the foot is on the ground.\n    float th0 = smix(th0set, th0relax, gain(sin(PI * t - TWO_PI / 3.), 3.0));\n    q.xz *= mat2(cos(th0), sin(th0), -sin(th0), cos(th0));\n    q.z += 0.065;\n    q.x -= 0.05;\n    vec3 foot = vec3(0.105, 0.03, -0.0025);\n    d = smin(d, sd_box(q, foot) - 0.02, 0.1);\n\n    return d;\n}\n\nfloat step_displacement(float t) {\n    return 0.03 * sin(TWO_PI * t + PI / 6.);\n}\n\nfloat man(vec3 p, float t) {\n    float d = 1e9;\n    // Vertical bobbing of the whole body\n    p.z -= step_displacement(t);\n\n    bool right = p.y < 0.;\n    float srad = smoothstep(0., 1., 10.0 * (0.3 + p.z) + 3. * p.x) * 0.1 + 0.01;\n    d = smin(half_body(p, t), half_body(vec3(p.x, -p.y, p.z), t + 1.), srad);\n\n    vec3 shoulder = get_shoulder(t);\n    vec3 q = p - vec3(-0.03 + shoulder.x, 0.19, 0.215);\n    if (!right) {\n        // Upper arm\n        float uarmL = 0.305;\n        float th3 = 0.3 * sin(PI * t);  // Oscillates opposite of the femur\n        q.xz *= mat2(cos(th3), sin(th3), -sin(th3), cos(th3));\n        q.yz *= rot(0.25);\n        q.z += uarmL;\n        srad = clamp(0.8 * (p.z - 0.16) - 0.3 * (p.x + 0.05), 0., 0.1);\n        d = smin(d, sdRoundCone(q.xzy, 0.045, 0.07, uarmL), srad);\n\n        // Lower arm\n        float larmL = 0.254;\n        float th4 =\n            0.15 + 0.15 * sin(PI * t - PI / 6.);  // Delayed w.r.t. upper arm\n        q.xz *= rot(th4);\n        q.yz *= rot(0.015);\n        q.z += larmL;\n        d = smin(d, sdRoundCone(q.xzy, 0.03, 0.045, 0.21), 0.02);\n\n        // Hand\n        float phi5 = PI / 6.;\n        q.xz *=\n            rot(0.1 + 0.1 * sin(PI * t - PI / 4.));  // Delayed still a bit more\n        q.xy *= rot(phi5);\n        q.z += 0.08;\n        q.y += 0.008;\n        d = smin(d, sd_box(q, vec3(0.04, 0.02, 0.08) - 0.02) - 0.025, 0.0);\n        // d = smin(d,\n        //          sdRoundCone(q, vec3(0.02, 0.005, 0.06), vec3(0.05, -0.04,\n        //          -0.03),\n        //                      0.025, 0.01),\n        //          srad);\n    } else {\n        // Left Upper arm\n        float t2 = t + 1.;\n        shoulder = get_shoulder(t2);\n        q = p - vec3(-0.03 + shoulder.x, -0.19, 0.215);\n        float uarmL = 0.305;\n        // th3 = 0.3 * sin(PI * t2);  // Oscillates opposite of the femur\n        // q.xz *= mat2(cos(th3), sin(th3), -sin(th3), cos(th3));\n        q.yz *= rot(-0.35);\n        q.xz *= rot(-0.4);\n        q.z += uarmL;\n        srad = clamp(0.8 * (p.z - 0.16) - 0.3 * (p.x + 0.05), 0., 0.1);\n        d = smin(d, sdRoundCone(q.xzy, 0.045, 0.07, uarmL), srad);\n\n        // Lower arm\n        float larmL = 0.254;\n        float th4 =\n            0.15 + 0.15 * sin(PI * t2 - PI / 6.);  // Delayed w.r.t. upper arm\n        // q.xz *= rot(-th4);\n        q.yz *= rot(0.15);\n        q.xz *= rot(1.2);\n        q.z += larmL;\n        d = smin(d, sdRoundCone(q.xzy, 0.03, 0.045, 0.21), 0.02);\n\n        // Hand\n        float phi5 = PI / 6.;\n        q.xz *=\n            rot(0.7 + 0.1 * sin(PI * t - PI / 4.));  // Delayed still a bit more\n        q.xy *= rot(-phi5);\n        q.yz *= rot(-0.4);\n        q.z += 0.08;\n        q.y += 0.008;\n        d = smin(d, sd_box(q, vec3(0.04, 0.02, 0.08) - 0.02) - 0.025, 0.0);\n        // d = smin(d,\n        //          sdRoundCone(q, vec3(0.02, 0.005, 0.06),\n        //                      vec3(0.05, 0.04, -0.03), 0.025, 0.01),\n        //          srad);\n    }\n\n    // Neck\n    d = smin(\n        d,\n        sdRoundCone(p, vec3(-0.04, 0., 0.275), vec3(0.0, 0., 0.38), 0.06, 0.06),\n        0.05);\n\n    // Head\n    q = p;\n    q.z -= 0.35;\n    q.z += 0.35;\n    q = vec3(q.x, abs(q.y), q.z);\n    float d2 = smin(\n        sdRoundCone(q, vec3(0., 0., 0.50), vec3(0.08, 0.0, 0.38), 0.1, 0.04),\n        length(q - vec3(0.02, 0.035, 0.45)) - 0.05, 0.04);\n\n    d = smin(d, d2, 0.05);\n\n    return d;\n}\n\nfloat prisoner(vec3 p, float t) {\n    float d = 1e9;\n\n    // Head\n    vec3 q = p;\n    q.z -= 0.5 * (step_displacement(t) + step_displacement(t + 0.75));\n    q.xz -= vec2(-0.23, -0.65);\n    q.xz *= rot(-0.9);\n    q = vec3(q.x, abs(q.y), q.z);\n    float d2 = smin(\n        sdRoundCone(q, vec3(0., 0., 0.50), vec3(0.08, 0.0, 0.38), 0.12, 0.06),\n        length(q - vec3(0.02, 0.035, 0.45)) - 0.07, 0.04);\n    d = smin(d, d2, 0.05);\n\n    // Neck\n    vec3 np = p;\n    np -= vec3(-0.0, -0.0, -0.5);\n    np.xz *= rot(-0.35);\n    float neck = sdVerticalCapsule(np, .1, 0.04);\n    d = smin(d, neck, 0.07);\n\n    // Upper arm\n    vec3 up = p;\n    if (p.y > 0.) {\n        up.z -= step_displacement(t) * 0.5;\n    } else {\n        up.z -= step_displacement(t + 0.75) * 0.5;\n    }\n\n    up = vec3((up.x), abs(up.y), up.z);\n    up -= vec3(0.025, 0.3, -0.5);\n\n    float uarmL = 0.305;\n    up.yz *= rot(0.9);\n    up.xy *= rot(-0.3);\n    float upper_arm = sdRoundCone(up, 0.07, 0.045, uarmL);\n\n    // Lower arm\n    vec3 lp = p;\n    if (p.y > 0.) {\n        lp.z -= step_displacement(t);\n    } else {\n        lp.z -= step_displacement(t + 0.75);\n    }\n    lp = vec3((lp.x), abs(lp.y), lp.z);\n    lp -= vec3(-0.025, 0.62, -0.5);\n\n    lp.yz *= rot(1.9);\n    lp.xy *= rot(-0.4);\n    float lower_arm = sdRoundCone(lp, 0.03, 0.045, 0.21);\n\n    d = min(d, upper_arm);\n    d = min(d, lower_arm);\n\n    // Torso\n    vec3 tp = p - vec3(-0.0, 0., -0.6);\n    tp.z -=\n        0.5 * 0.03 * (sin(TWO_PI * t + PI / 6.) + sin(TWO_PI * (t + 0.75) + PI / 6.));\n\n    tp.xz *= rot(-0.65);\n    float h = 0.14 * smoothstep(-0.5, 0., tp.z);\n    tp.y = tp.y - clamp(tp.y, -h, h);\n    tp.yz *= rot(-PI / 2.);\n    float torso = sdRoundCone(tp, 0.15, 0.1, 0.2);\n    d = smin(d, torso, 0.07);\n\n    // Hips\n    vec3 hp = p - vec3(-0.15, 0., -0.81);\n    hp.z -=\n        0.5 * 0.03 * (sin(TWO_PI * t + PI / 6.) + sin(TWO_PI * (t + 0.75) + PI / 6.));\n\n    hp.xz *= rot(-0.95);\n    float hh = 0.11 * smoothstep(0.74, -0.3, hp.z);\n    hp.y = hp.y - clamp(hp.y, -hh, hh);\n    hp.yz *= rot(-PI / 2.);\n    float hips = sdRoundCone(hp, 0.08, 0.11, 0.13);\n    d = min(d, hips);\n\n    // Legs\n    vec3 gp = p - vec3(-0.56, -0.06, -1.32);\n    gp.y = abs(gp.y) - 0.18;\n    gp.xz *= rot(-0.35);\n    gp.yz *= rot(PI / 2. + 0.15);\n    d = smin(d, sdRoundCone(gp, 0.07, 0.09, 0.35), 0.13);\n\n    return d;\n}\n\nvec3 pmove(float t) {\n    float x = 25.;\n#ifdef REPJ\n    x += t * 1.1;\n#endif\n    return vec3(x, 0., 1.2);\n}\n\nfloat map(vec3 p, float tt) {\n    p -= pmove(tt);\n    \n#ifdef REPJ\n    float t = tt * 0.75;\n#else\n    float t = 2.;\n#endif\n\n    float d = 1e9;\n    \n    float s = 2.;\n\n    d = prisoner(p / s, t) * s;\n\n    t += step(p.y, 0.) * 0.75;\n    p = vec3(p.x, sabs(p.y, 0.006) - 0.9 * s, p.z);\n\n    d = min(d, man(p / s, t) * s);\n\n    return d;\n}\n\nvec3 get_norm(vec3 p, float sdf, float t) {\n    mat3 k = mat3(p, p, p) - mat3(0.0001);\n    return normalize(sdf - vec3(map(k[0], t), map(k[1], t), map(k[2], t)));\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"vec3 trace(vec3 ro, vec3 rd, float time) {\n    Span bb = ibox(ro - pmove(time), rd, vec3(.7, 1.35, 1.2) * 2.);\n    if (isEmpty(bb)) {\n        return vec3(-1.);\n    }\n    float t = 0.;\n    for (int i = min(0, iFrame); i < 100; ++i) {\n        float d = map(ro + rd * t, time);\n        if (d < 0.001) {\n            return vec3(t, 1., d);\n        }\n        t += d;\n        if (t > 100.) {\n            break;\n        }\n    }\n    return vec3(-1.);\n}\n\nfloat cut_box(vec2 p, vec2 h) {\n    p = abs(p) - h;\n    float corners = dot(p, vec2(0.95, 1.)) + 0.5;\n    return max(length(max(p, 0.)) + min(max(p.x, p.y), 0.), corners);\n}\n\nfloat wind(vec2 p, vec2 h, float xi) {\n    vec2 pp = abs(p) - h;\n    float corners = dot(pp, normalize(vec2(1., 0.79))) + h.y / 3.;\n    float big = length(max(pp, 0.)) + min(max(pp.x, pp.y), 0.);\n\n    vec2 wh = h * vec2(0.2, 0.7);\n    float smol =\n        cut_box(p - vec2(h.x - wh.x * 1.2, h.y - wh.y * 0.24) * sign(xi), wh);\n    return max(min(big, smol), corners);\n}\n\nfloat window(vec2 uv, vec2 wh, float id) {\n    float ha = hash11(id + 15.);\n    float si = sign(hash11(ha) - 0.5);\n\n    float box_height = 0.25 * wh.y;\n    float w = 0.25 + 0.35 * wh.x * si * ha;\n    float width = wh.y * (0.35 + ha * 0.40);\n\n    float width2 = wh.y * (0.25 + hash11(width) * 0.50);\n    float w2 = 0.1 * si + 0.3 * wh.x * si * hash11(w);\n\n    vec2 nl = normalize(vec2(1., 1. * si));\n    float planel = dot(uv, nl) - w;\n    vec2 offl = clamp(planel, -width, width) * nl;\n    float dcutl = abs(planel) - width;\n\n    vec2 nr = normalize(vec2(1., 1. * -si));\n    float planer = dot(uv, nr) - -w2;\n    vec2 offr = clamp(planer, -width2, width2) * nr;\n    float dcutr = abs(planer) - width2;\n\n    float d = max(-max(dcutl, dcutr),\n                  wind(uv - offl - offr, vec2(wh.x * 0.7, box_height), si));\n\n    return d;\n}\n\nvec2 window_normal(vec2 p, vec2 wh, float id) {\n    const vec2 e = vec2(0.5, 0.);\n    return normalize(window(p, wh, id) -\n                     vec2(window(p - e.xy, wh, id), window(p - e.yx, wh, id)));\n}\n\nHitInfo world_hit(Ray ray, bool people) {\n    HitInfo hit = HitInfo(NO_HIT, vec3(0), -1);\n\n    float catwalk_width = 3.;\n    vec3 catwalk = vec3(0., 0., -4.0);\n\n    float side_width = 0.25;\n    vec3 side_left = vec3(0., catwalk_width + side_width, -3.5);\n    vec3 side_right = vec3(0., -(catwalk_width + side_width), -3.5);\n\n    Span b = ibox(ray.origin - catwalk, ray.direction,\n                  vec3(TUNNEL_LEN, catwalk_width, 3.));\n    resolve(hit, b, 2);\n    b = ibox(ray.origin - side_left, ray.direction,\n             vec3(TUNNEL_LEN, side_width, 3.));\n    resolve(hit, b, 3);\n    b = ibox(ray.origin - side_right, ray.direction,\n             vec3(TUNNEL_LEN, side_width, 3.));\n    resolve(hit, b, 3);\n\n    float tunnel_radius = 11.;\n    float section_len = 90.;\n    float gap = 0.98;\n    Span cyl = icylinder(ray, vec3(1, 0, 0), tunnel_radius + 2.5);\n    Span inner = icylinder(ray, vec3(1, 0, 0), tunnel_radius);\n    cyl = Sub(cyl, inner);\n    Span ceiling = ibox(ray.origin - vec3(0., 0., 12.), ray.direction,\n                        vec3(TUNNEL_LEN, 11., 4.));\n    cyl = Union(cyl, ceiling);\n    \n    float window_depth = 0.1;\n    float wall_width = 3.;\n    mat2 skew = rot(1.835);\n    \n    Ray wray = ray;\n    wray.origin -= vec3(-0., 10.9, 2.8);\n    wray.origin.yz *= skew;\n    wray.direction.yz *= skew;\n    \n    if (cyl.a.t < hit.t) {\n        float x = cyl.a.t > 0. ? ray.origin.x + ray.direction.x * cyl.a.t\n                               : ray.origin.x;\n        float id = round(x / section_len) * section_len - section_len / 2.;\n\n        for (int i = 0; i < 2; ++i) {\n            vec3 off = vec3(id, 0., 0.);\n            Span cut = iPlane(ray.origin - off, ray.direction,\n                              normalize(vec3(1, 0, .0)), gap * section_len);\n            vec3 p = ray.origin + hit.t * ray.direction;\n            if (resolve(hit, Inter(cyl, cut), 4) && p.y > 0.) {\n                vec3 pos = wray.origin +\n                           wray.direction * hit.t;  // + hit.normal * EPS;\n                pos -= off;\n                pos.x -= section_len / 2.;\n                pos.y -= 1.;\n\n                vec2 wh = vec2(section_len / 1.6, wall_width);\n                float d = window(pos.xy, wh, id);\n                if (d < .0001) {\n                    if (abs(d) < 0.19) {\n                        vec2 nor = window_normal(pos.xy, wh, id) * 0.5 + 0.5;\n                        vec3 normal = vec3(nor.x, 0.0, nor.y);\n                        normal.yz *= skew;\n                        hit.obj_id = 4;\n                        hit.normal = normal;\n                    } else {\n                        hit.obj_id = 6;\n                        hit.t += window_depth / dot(hit.normal, wray.direction);\n                    }\n                }\n            }\n\n\n            id += sign(ray.direction.x) * section_len;\n        }\n    }\n    \n    if (people) {\n        vec3 man = trace(ray.origin, ray.direction, iTime);\n        if (man.y > 0. && man.x < hit.t) {\n            vec3 pos = ray.origin + ray.direction * man.x;\n            hit.normal = get_norm(pos, man.z, iTime);\n            hit.t = man.x;\n            hit.obj_id = 7;\n        }\n    }\n\n    resolve(hit,\n            ibox(ray.origin - LIGHT_LEFT_POS, ray.direction, LIGHTS[0].size),\n            LIGHT_LEFT_ID);\n    resolve(hit,\n            ibox(ray.origin - LIGHT_RIGHT_POS, ray.direction, LIGHTS[1].size),\n            LIGHT_RIGHT_ID);\n\n    return hit;\n}\n\nMaterial get_material(in HitInfo hit, in vec3 pos) {\n    Material mat = Material(vec3(1., 0., 1.), vec3(0), BSDF_DIFFUSE, 1.0);\n    switch (hit.obj_id) {\n        // Light\n        case LIGHT_LEFT_ID: {\n            mat.bsdf = BSDF_LIGHT;\n            mat.color = LIGHTS[LIGHT_LEFT_ID].color;\n            mat.emissive = LIGHTS[LIGHT_LEFT_ID].intensity;\n            break;\n        }\n        case LIGHT_RIGHT_ID: {\n            mat.bsdf = BSDF_LIGHT;\n            mat.color = LIGHTS[LIGHT_RIGHT_ID].color;\n            mat.emissive = LIGHTS[LIGHT_RIGHT_ID].intensity;\n            break;\n        }\n        // Catwalk\n        case 2: {\n            mat.bsdf = BSDF_DIFFUSE;\n            vec2 p = pos.xy * rot(PI / 5.);\n            mat.color = mix(vec3(1., 0., 1.), spectrum(p.x * .015),\n                            exp(-hit.t * 0.015));\n            break;\n        }\n        // Short box\n        case 3: {\n            mat.bsdf = BSDF_DIFFUSE;\n            mat.color = vec3(1.);\n            break;\n        }\n        // Tunnel\n        case 4: {\n            mat.bsdf = BSDF_DIFFUSE;\n            vec2 uv = vec2(pos.x, atan(pos.y, pos.z) * TWO_PI);\n            mat.color = vec3(1., 1., 1.);\n            float n = tnoise(uv);\n            mat.color = vec3(sin(n * 7. + n * TWO_PI) * 0.5 + 0.5) * 0.5 + 0.5;\n            //mat.color = spectrum(sin(n * 7. + n * TWO_PI) * 0.5 + 0.5);\n            mat.color = mix(mat.color, vec3(1.), smooth_hill(pos.y, 0., 7., 5.));\n            break;\n        }\n        // Walls\n        case 5: {\n            mat.bsdf = BSDF_DIFFUSE;\n            mat.color = vec3(1.);\n            break;\n        }\n        // Window\n        case 6: {\n            mat.bsdf = BSDF_PLASTIC;\n            mat.color = vec3(0., 0., 1.);\n            break;\n        }\n        // People\n        case 7: {\n            mat.bsdf = BSDF_DIFFUSE;\n            mat.color = vec3(0.0);\n        }\n        default:\n            break;\n    }\n    return mat;\n}\n\nfloat schlick_fresnel(in float Rs, float cosTheta) {\n    return Rs + pow(1.0 - cosTheta, 5.) * (1. - Rs);\n}\n\nvec3 mtl_eval(Material mtl, in vec3 Ng, in vec3 E, in vec3 L) {\n    if (mtl.bsdf == BSDF_DIFFUSE) {\n        return vec3(INV_PI) * mtl.color;\n    } else if (mtl.bsdf == BSDF_MIRROR) {\n        return vec3(0.0);\n    }\n\n    float f = max(schlick_fresnel(0.1, L.z), schlick_fresnel(0.1, E.z));\n    return (1.0 - f) * vec3(INV_PI) * mtl.color;\n}\n\nmat3 mat3inverse(in mat3 m) {\n#if 0\n    return inverse(m);\t//webGL 2.0\n#else\n    return mat3(vec3(m[0][0], m[1][0], m[2][0]),\n                vec3(m[0][1], m[1][1], m[2][1]),\n                vec3(m[0][2], m[1][2], m[2][2]));\n#endif\n}\n\nvec3 spherical_to_cartesian(in float rho, in float phi, in float theta) {\n    float sinTheta = sin(theta);\n    return vec3(sinTheta * cos(phi), sinTheta * sin(phi), cos(theta)) * rho;\n}\n\nvec3 sample_cos_hemisphere(in float Xi1, in float Xi2) {\n    float theta = acos(sqrt(1.0 - Xi1));\n    float phi = TWO_PI * Xi2;\n\n    return spherical_to_cartesian(1.0, phi, theta);\n}\n\nbool same_hemisphere(in vec3 n, in vec3 a, in vec3 b) {\n    return ((dot(n, a) * dot(n, b)) > 0.0);\n}\n\n// taken from: https://www.shadertoy.com/view/4sSSW3\nvoid basis(in vec3 n, out vec3 f, out vec3 r) {\n    if (n.z < -0.999999) {\n        f = vec3(0, -1, 0);\n        r = vec3(-1, 0, 0);\n    } else {\n        float a = 1. / (1. + n.z);\n        float b = -n.x * n.y * a;\n        f = vec3(1. - n.x * n.x * a, b, -n.x);\n        r = vec3(b, 1. - n.y * n.y * a, -n.y);\n    }\n}\n\nmat3 mat3_from_normal(in vec3 n) {\n    vec3 x;\n    vec3 y;\n    basis(n, x, y);\n    return mat3(x, y, n);\n}\n\nstruct LightSamplingRecord {\n    vec3 w;\n    float d;\n    float pdf;\n};\n\nfloat mis_weight(float pdfA, float pdfB) {\n#if 1\n    // Balance heuristic\n    return pdfA / (pdfA + pdfB);\n#else\n    // Power heuristic\n    return pdfA * pdfA / (pdfA * pdfA + pdfB * pdfB);\n#endif\n}\n\n// Converting PDF between from Area to Solid angle\nfloat PdfAtoW(float aPdfA, float aDist2, float aCosThere) {\n    return abs(aCosThere) == 0.0 ? 0.0 : aPdfA * aDist2 / abs(aCosThere);\n}\n\nstruct SphQuad {\n    vec3 o, x, y, z;        // local reference system ’R’\n    float z0, z0sq;         //\n    float x0, y0, y0sq;     // rectangle coords in ’R’\n    float x1, y1, y1sq;     //\n    float b0, b1, b0sq, k;  // misc precomputed constants\n    float S;                // solid angle of ’Q’\n};\n\nvoid SphQuadInit(vec3 s, vec3 ex, vec3 ey, vec3 o, out SphQuad squad) {\n    squad.o = o;\n    float exl = length(ex), eyl = length(ey);\n    // compute local reference system ’R’\n    squad.x = ex / exl;\n    squad.y = ey / eyl;\n    squad.z = cross(squad.x, squad.y);\n    // compute rectangle coords in local reference system\n    vec3 d = s - o;\n    squad.z0 = dot(d, squad.z);\n    // flip ’z’ to make it point against ’Q’\n    if (squad.z0 > 0.) {\n        squad.z *= -1.;\n        squad.z0 *= -1.;\n    }\n    squad.z0sq = squad.z0 * squad.z0;\n    squad.x0 = dot(d, squad.x);\n    squad.y0 = dot(d, squad.y);\n    squad.x1 = squad.x0 + exl;\n    squad.y1 = squad.y0 + eyl;\n    squad.y0sq = squad.y0 * squad.y0;\n    squad.y1sq = squad.y1 * squad.y1;\n    // create vectors to four vertices\n    vec3 v00 = vec3(squad.x0, squad.y0, squad.z0);\n    vec3 v01 = vec3(squad.x0, squad.y1, squad.z0);\n    vec3 v10 = vec3(squad.x1, squad.y0, squad.z0);\n    vec3 v11 = vec3(squad.x1, squad.y1, squad.z0);\n    // compute normals to edges\n    vec3 n0 = normalize(cross(v00, v10));\n    vec3 n1 = normalize(cross(v10, v11));\n    vec3 n2 = normalize(cross(v11, v01));\n    vec3 n3 = normalize(cross(v01, v00));\n    // compute internal angles (gamma_i)\n    float g0 = acos(-dot(n0, n1));\n    float g1 = acos(-dot(n1, n2));\n    float g2 = acos(-dot(n2, n3));\n    float g3 = acos(-dot(n3, n0));\n    // compute predefined constants\n    squad.b0 = n0.z;\n    squad.b1 = n2.z;\n    squad.b0sq = squad.b0 * squad.b0;\n    squad.k = 2. * PI - g2 - g3;\n    // compute solid angle from internal angles\n    squad.S = g0 + g1 - squad.k;\n}\n\nvoid SphQuadSample(in vec3 x,\n                   SphQuad squad,\n                   float u,\n                   float v,\n                   out LightSamplingRecord sampleRec) {\n    // 1. compute ’cu’\n    float au = u * squad.S + squad.k;\n    float fu = (cos(au) * squad.b0 - squad.b1) / sin(au);\n    float cu = 1. / sqrt(fu * fu + squad.b0sq) * (fu > 0. ? +1. : -1.);\n    cu = clamp(cu, -1., 1.);  // avoid NaNs\n    // 2. compute ’xu’\n    float xu = -(cu * squad.z0) / sqrt(1. - cu * cu);\n    xu = clamp(xu, squad.x0, squad.x1);  // avoid Infs\n    // 3. compute ’yv’\n    float d = sqrt(xu * xu + squad.z0sq);\n    float h0 = squad.y0 / sqrt(d * d + squad.y0sq);\n    float h1 = squad.y1 / sqrt(d * d + squad.y1sq);\n    float hv = h0 + v * (h1 - h0), hv2 = hv * hv;\n    float yv = (hv2 < 1. - EPS) ? (hv * d) / sqrt(1. - hv2) : squad.y1;\n    // 4. transform (xu,yv,z0) to world coords\n\n    vec3 p = (squad.o + xu * squad.x + yv * squad.y + squad.z0 * squad.z);\n    sampleRec.w = p - x;\n    sampleRec.d = length(sampleRec.w);\n    sampleRec.w = normalize(sampleRec.w);\n    sampleRec.pdf = 1. / squad.S;\n}\n\nfloat effective_len = 50.;\n#define CDF_SIZE 3\nvec3 sample_light_source2(in vec3 x,\n                          in vec3 n,\n                          in Light light,\n                          float Xi1,\n                          float Xi2,\n                          out LightSamplingRecord sampleRec) {\n    light.pos.x = x.x;\n    light.size.x = effective_len;\n    vec3 s = light.pos - vec3(1., 0., 0.) * light.size.x * 0.5 -\n             vec3(0., 1., 0.) * light.size.y * 0.5;\n    vec3 ex = vec3(light.size.x, 0., 0.);\n    vec3 ey = vec3(0., light.size.y, 0.);\n\n    n.yz *= rot(PI);\n\n    SphQuad squad;\n    SphQuadInit(s, ex, ey, x, squad);\n\n    // if (abs(dot(n, vec3(0., 0., 1.))) < EPS) { return vec3(1., 0., 1.); }\n\n    LightSamplingRecord w[CDF_SIZE];\n    float ww[CDF_SIZE];\n    const float strata = 1.0 / float(CDF_SIZE);\n    for (int i = 0; i < CDF_SIZE; i++) {\n        float xi = strata * (float(i) + hashf());\n        SphQuadSample(x, squad, xi, hashf(), w[i]);\n        ww[i] = (i == 0) ? 0.0 : ww[i - 1];\n        ww[i] += max(0.0, dot(w[i].w, n));\n    }\n    float a = Xi1 * ww[CDF_SIZE - 1];\n    for (int i = 0; i < CDF_SIZE; i++) {\n        if (ww[i] > a) {\n            sampleRec = w[i];\n            sampleRec.pdf *=\n                (ww[i] - ((i == 0) ? 0.0 : ww[i - 1])) / ww[CDF_SIZE - 1];\n            sampleRec.pdf *= float(CDF_SIZE);\n            break;\n        }\n    }\n\n    // sampleRec.w.yz *= rot(-PI);\n\n    return light_radiance(light);\n}\n\nvec3 sample_light_source(in vec3 x,\n                         in Light light,\n                         in vec2 xi,\n                         out LightSamplingRecord sampleRec) {\n    light.size.x = effective_len;\n    vec2 minp = vec2(x.x, light.pos.y) - light.size.xy;\n    vec2 maxp = vec2(x.x, light.pos.y) + light.size.xy;\n    vec2 size = maxp - minp;\n    vec3 pos = vec3(mix(minp, maxp, xi), light.pos.z);\n    vec3 normal = vec3(0.0, 0.0, 1.0);\n\n    float pdfA = 1.0 / (size.x * size.y);\n    sampleRec.w = pos - x;\n    sampleRec.d = length(sampleRec.w);\n    sampleRec.w = normalize(sampleRec.w);\n    float cosAtLight = dot(normal, -sampleRec.w);\n    vec3 L = cosAtLight > 0.0 ? light_radiance(light) : vec3(0.0);\n    sampleRec.pdf = PdfAtoW(pdfA, sampleRec.d * sampleRec.d, cosAtLight);\n\n    return L * 0.3;\n}\n\nfloat sample_light_source_pdf(in vec3 x,\n                              in Light light,\n                              in vec3 wi,\n                              float d,\n                              float cosAtLight) {\n    float pdfA = 1.0 / (effective_len * light.size.y);\n    return PdfAtoW(pdfA, d * d, cosAtLight);\n}\n\nfloat sample_light_source_pdf2(in vec3 x,\n                               vec3 ns,\n                               in Light light,\n                               in vec3 wi,\n                               float d,\n                               float cosAtLight) {\n    light.pos.x = x.x;\n    light.size.x = effective_len;\n    vec3 s = light.pos - vec3(1., 0., 0.) * light.size.x * 0.5 -\n             vec3(0., 1., 0.) * light.size.y * 0.5;\n    vec3 ex = vec3(light.size.x, 0., 0.);\n    vec3 ey = vec3(0., light.size.y, 0.);\n\n    SphQuad squad;\n    SphQuadInit(s, ex, ey, x, squad);\n    return 1. / squad.S;\n}\n\nBrdfSamplingResult sample_diffuse(in vec2 xi) {\n    BrdfSamplingResult res;\n    res.isDelta = false;\n    res.w = sample_cos_hemisphere(xi.x, xi.y);\n    res.pdf = INV_PI * res.w.z;\n    res.f = vec3(INV_PI);\n    return res;\n}\n\nBrdfSamplingResult sample_specular(in vec3 E) {\n    BrdfSamplingResult res;\n    res.isDelta = true;\n    res.w = reflect(-E, vec3(0.0, 0.0, 1.0));\n    res.pdf = 1.0;\n    res.f = vec3(1.0);\n    return res;\n}\n\nBrdfSamplingResult mtl_sample(Material mtl, in vec3 Ng, in vec3 E, in vec2 xi) {\n    BrdfSamplingResult res;\n    res.isDelta = false;\n\n    if (mtl.bsdf == BSDF_DIFFUSE) {\n        res = sample_diffuse(xi);\n        res.f *= mtl.color;\n    } else if (mtl.bsdf == BSDF_MIRROR) {\n        res = sample_specular(E);\n    } else {\n        float f = schlick_fresnel(0.1, E.z);\n        float p = f;\n        if (xi.x < p) {\n            res = sample_specular(E);\n            res.pdf *= p;\n            res.f *= f;\n        } else {\n            xi.x = clamp(xi.x / p, 0.0, 1.0);\n            res = sample_diffuse(xi);\n            res.pdf *= 1.0 - p;\n            res.f *= mtl.color * (1.0 - f);\n        }\n    }\n\n    if (!same_hemisphere(Ng, E, res.w)) {\n        res.pdf = 0.0;\n    }\n\n    return res;\n}\n\nbool is_light_visible(Ray shadowRay) {\n    HitInfo hit = world_hit(shadowRay, false);\n    return is_light(hit.obj_id);\n}\n\nfloat mtl_pdf(Material mtl, in vec3 Ng, in vec3 E, in vec3 L) {\n    if (!same_hemisphere(Ng, E, L)) {\n        return 0.0;\n    } else {\n        if (mtl.bsdf == BSDF_DIFFUSE) {\n            return abs(L.z) * INV_PI;\n        } else if (mtl.bsdf == BSDF_MIRROR) {\n            return 0.0;\n        } else {\n            float diff_pdf = abs(L.z) * INV_PI;\n            float f = min(schlick_fresnel(0.1, L.z), schlick_fresnel(0.1, E.z));\n            return diff_pdf * (1.0 - f);\n        }\n    }\n}\n\nfloat light_choosing_pdf(in vec3 pos, in int light_id) {\n    vec3 to_left = LIGHTS[0].pos - pos;\n    float l = 1. / dot(to_left, to_left);\n\n    vec3 to_right = LIGHTS[1].pos - pos;\n    float r = 1. / dot(to_right, to_right);\n\n    if (light_id == LIGHT_LEFT_ID) {\n        return 1. - r / (r + l);\n    }\n    if (light_id == LIGHT_RIGHT_ID) {\n        return 1. - l / (r + l);\n    }\n    return 0.;\n}\n\nint choose_best_light(in vec3 pos, in float xi, out float pdf) {\n    vec3 to_left = LIGHTS[0].pos - pos;\n    float l = 1. / dot(to_left, to_left);\n\n    vec3 to_right = LIGHTS[1].pos - pos;\n    float r = 1. / dot(to_right, to_right);\n\n    float lcdf = l / (l + r);\n    if (xi < lcdf) {\n        pdf = lcdf;\n        return LIGHT_LEFT_ID;\n    } else {\n        pdf = 1. - lcdf;\n        return LIGHT_RIGHT_ID;\n    }\n}\n\nvec3 sample_bsdf(in vec3 pos,\n                 in mat3 trans,\n                 in mat3 inv_trans,\n                 in vec3 ng,\n                 in vec3 wi,\n                 in Material mtl,\n                 out BrdfSamplingResult brdfres,\n                 out bool hitRes,\n                 out HitInfo hit) {\n    vec3 Lo = vec3(0.0);\n\n    brdfres = mtl_sample(mtl, ng, wi, hash2());\n\n    // Continue if sampled direction is under surface\n    if ((dot(brdfres.f, brdfres.f) > 0.0) && (brdfres.pdf > 0.0)) {\n        Ray shadowRay = Ray(pos + (trans * ng) * EPS, trans * brdfres.w);\n\n        float cosAtLight = 1.0;\n        float distanceToLight = -1.0;\n        vec3 Li = vec3(0.0);\n\n        Light light;\n        {\n            hit = world_hit(shadowRay, false);\n            if (hit.t <= NO_HIT) {\n                if (is_light(hit.obj_id)) {\n                    distanceToLight = hit.t;\n                    light = get_light(hit.obj_id);\n                    cosAtLight = dot(hit.normal, -shadowRay.direction);\n                    if (cosAtLight > 0.0) {\n                        Li = light_radiance(light);\n                    }\n                } else {\n                    hitRes = true;\n                }\n            } else {\n                hitRes = false;\n            }\n        }\n\n        if (distanceToLight > 0.0) {\n            if (cosAtLight > 0.0) {\n                vec3 contribution =\n                    (Li * brdfres.f * brdfres.w.z) / brdfres.pdf;\n\n                if (!brdfres.isDelta) {\n#ifdef SRECT\n                    float lightPdfW = sample_light_source_pdf2(\n                        pos, ng, light, shadowRay.direction, distanceToLight,\n                        cosAtLight);\n#else\n                    float lightPdfW =\n                        sample_light_source_pdf(pos, light, shadowRay.direction,\n                                                distanceToLight, cosAtLight);\n#endif\n                    lightPdfW *= light_choosing_pdf(pos, hit.obj_id);\n\n                    contribution *= mis_weight(brdfres.pdf, lightPdfW);\n                }\n\n                Lo += contribution;\n            }\n        }\n    }\n\n    return Lo;\n}\n\nvec3 salmple_light(in vec3 x,\n                   in mat3 trans,\n                   in mat3 inv_trans,\n                   in vec3 ng,\n                   in vec3 lwi,\n                   in Material mtl) {\n    vec3 Lo = vec3(0.0);  // outgoing radiance\n\n    float light_picking_pdf = 1.0;\n    int light_id = choose_best_light(x, hashf(), light_picking_pdf);\n    Light light = get_light(light_id);\n\n    vec3 lwo;\n    float light_pdfw, light_dist;\n\n    LightSamplingRecord rec = LightSamplingRecord(vec3(0.), 0., 0.);\n#ifdef SRECT\n    vec3 Li = sample_light_source2(x, ng, light, hashf(), hashf(), rec);\n#else\n    vec3 Li = sample_light_source(x, light, hash2(), rec);\n#endif\n    lwo = inv_trans * rec.w;\n    light_pdfw = rec.pdf;\n    light_dist = rec.d;\n    light_pdfw *= light_picking_pdf;\n\n    float dotNWo = lwo.z;\n\n    if ((dotNWo > 0.0) && (light_pdfw > EPS)) {\n        vec3 fr = mtl_eval(mtl, ng, lwi, lwo);\n        if (dot(fr, fr) > 0.0) {\n            Ray shadowRay = Ray(x, rec.w);\n            if (is_light_visible(shadowRay)) {\n                vec3 contribution = (Li * fr * dotNWo) / light_pdfw;\n\n                if (mtl.bsdf != BSDF_MIRROR) {\n                    float brdfPdfW = mtl_pdf(mtl, ng, lwi, lwo);\n                    contribution *= mis_weight(light_pdfw, brdfPdfW);\n                }\n\n                Lo += contribution;\n            }\n        }\n    }\n\n    return Lo;\n}\n\nHitInfo FIRST_HIT;\nvec3 radiance(in Ray r, in vec2 xi1, in vec2 xi2, float sl) {\n    Ray ray = r;\n    bool hit_result;\n    vec3 emission = vec3(0.);\n\n    vec3 path_weight = vec3(1.);\n    HitInfo event = world_hit(ray, true);\n    HitInfo next_event = HitInfo(NO_HIT, vec3(0), -1);\n    FIRST_HIT = event;\n\n    if (event.t >= NO_HIT) {\n        emission = vec3(1., 1., 1.) * 30.;\n    } else {\n        if (is_light(event.obj_id)) {\n            Light light = get_light(event.obj_id);\n            float cos_at_light = dot(event.normal, -ray.direction);\n            if (cos_at_light > 0.) {\n                emission = light_radiance(light);\n            }\n        }\n    }\n    \n    if (event.obj_id == 7) {\n        vec3 norm = event.normal;\n        vec3 light_dir = normalize(vec3(0.15, -0.35, 0.));\n        float ndotl = max(dot(light_dir, norm), 0.0);\n        return mix(vec3(-0.1), vec3(2.), ndotl);\n    }\n\n    vec3 direct = vec3(0.);\n    vec3 indirect = vec3(0.);\n\n    for (int i = 0; i < BOUNCES; ++i) {\n        if (is_light(event.obj_id)) {\n            break;\n        }\n\n        vec3 wi = -ray.direction;\n        if (dot(wi, event.normal) < 0.0) {\n            event.normal *= -1.0;\n        }\n        vec3 pos = ray.origin + ray.direction * event.t + event.normal * 0.01;\n\n        Material mtl = get_material(event, pos);\n\n        vec3 ng = event.normal;\n        mat3 trans = mat3_from_normal(event.normal);\n        mat3 inv_trans = mat3inverse(trans);\n        vec3 wi_local = inv_trans * wi;\n        vec3 ng_local = inv_trans * ng;\n        vec3 ns = event.normal;  // frame*ns;\n\n        if (wi_local.z < 0.) {\n            break;\n        }\n\n        BrdfSamplingResult brdf_res;\n        vec3 direct_light = vec3(0.);\n        direct_light +=\n            salmple_light(pos, trans, inv_trans, ng_local, wi_local, mtl);\n        direct_light += sample_bsdf(pos, trans, inv_trans, ng_local, wi_local,\n                                    mtl, brdf_res, hit_result, next_event);\n\n        if (path_weight.x > 1.0 && path_weight.y > 1.0 && path_weight.z > 1.0) {\n            break;\n        }\n\n        if (i == 0) {\n            direct += direct_light * path_weight;\n\n            vec3 extinction = exp(-(event.t) * 0.0025 * vec3(1.));\n            vec3 fog_color = vec3(249, 166, 32) / 255. * 2.5;\n            fog_color = vec3(1.);\n            direct = direct * extinction + fog_color * (1. - extinction);\n        } else {\n            indirect += direct_light * path_weight;\n        }\n\n        if (!hit_result || brdf_res.w.z < 0.0) {\n            break;\n        }\n        if (brdf_res.pdf == 0.0) {\n            break;\n        }\n        path_weight *= brdf_res.f * brdf_res.w.z / brdf_res.pdf;\n\n        // Update values for next iteration\n        ray = Ray(pos, trans * brdf_res.w);\n        event = next_event;\n    }\n\n    indirect = vec3(min(indirect, vec3(CLAMP_VALUE)));\n\n    return emission + direct + indirect;\n}\n\nvec2 randomInUnitDisk() {\n    vec2 h = hash2() * vec2(1,6.28318530718);\n    float phi = h.y;\n    float r = sqrt(h.x);\n\treturn r*vec2(sin(phi),cos(phi));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    init_seed(fragCoord, iFrame);\n\n    vec2 jitter = halton(vec2(13, 23) * float(iFrame + 1));\n    vec2 ndc = ((fragCoord + jitter) - 0.5 * iResolution.xy) / iResolution.y;\n    vec2 uv = fragCoord / iResolution.xy;\n\n    vec3 ro = vec3(.0, -8.0, 6.);\n#ifdef REPJ\n    float t = iTime * 1.1;\n    ro.x += t;\n#endif\n    vec3 lo = ro + vec3(0, 1, 0);\n\n    vec4 m = texelFetch(iChannel0, ivec2(0, 0), 0);\n    if (iFrame < 2) {\n        m = vec4(0.5, 0.5, 0, 0);\n    }\n\n    if (int(fragCoord.x) == 0 && int(fragCoord.y) == 0) {\n        if (iFrame < 2) {\n            fragColor = vec4(0.5, 0.5, 0, 0);\n        } else {\n            vec2 mn = iMouse.xy / iResolution.xy;\n            fragColor = vec4(m);\n            if (iMouse.z > 0.0) {\n                if (fragColor.zw != vec2(0))\n                    fragColor.xy += (mn - m.zw);\n                fragColor.zw = mn;\n            } else {\n                fragColor.zw = vec2(0);\n            }\n        }\n        return;\n    }\n    //m.xy = vec2(0.5);\n    float ax = -m.x * TWO_PI - PI * 1.35;\n    float ay = m.y * PI - PI * 0.55;\n\n    ro -= lo;\n    ro.zy *= rot(ay);\n    ro.yx *= rot(ax);\n    ro += lo;\n\n    vec3 cam = ro;\n    mat3 cmat = get_cam(ro, lo);\n    vec3 rr;\n\n    float focal_dist = 1.3;\n    vec3 rd = normalize(cmat * vec3(ndc, focal_dist));\n\n#ifndef REPJ\n    // DOF\n    vec3 fp = ro + rd * 25.;\n    ro = ro + cmat * vec3(randomInUnitDisk(), 0.)*.2;\n    rd = normalize(fp - ro);\n#endif\n\n    if (abs(ndc.y) > .45) {\n        ivec2 q = ivec2(fragCoord);\n        vec4 c = vec4(0., 0., 0., 15.);\n        if (q.y == 0 && q.x > 0 && q.x < 4) {\n            // Camera matrix in lower left three pixels, for next frame.\n            if (q.x == 1)\n                c = vec4(cmat[0], -dot(cmat[0], cam));\n            else if (q.x == 2)\n                c = vec4(cmat[1], -dot(cmat[1], cam));\n            else if (q.x == 3)\n                c = vec4(cmat[2], -dot(cmat[2], cam));\n        }\n        fragColor = c;\n        return;\n    }\n\n    vec3 xi = hash3();\n    Ray ray = Ray(ro, rd);\n    vec3 color = radiance(ray, xi.xy, xi.xy, xi.z);\n    HitInfo hit = FIRST_HIT;\n    if (color != color) { // sorry for that\n        color = vec3(0.);\n    }\n    \n    vec3 fog_color = vec3(25.0); float b = 0.00005;\n    color = color*exp(-hit.t*b) + fog_color*(1.0-exp(-hit.t*b));\n\n#ifdef REPJ\n    vec3 pos = ray.origin + ray.direction * hit.t + hit.normal * EPS;\n\n    ivec2 q = ivec2(fragCoord);\n\n    // Fetch previous camera matrix from the bottom left three pixels.\n    mat3x4 old_cam = mat3x4(texelFetch(iChannel0, ivec2(1, 0), 0),\n                            texelFetch(iChannel0, ivec2(2, 0), 0),\n                            texelFetch(iChannel0, ivec2(3, 0), 0));\n    // World space point.\n    vec4 wpos = vec4(pos, 1.);\n    // Convert to camera space (note inverse multiply).\n    vec3 cpos = wpos * old_cam;\n    // Convert to NDC space (project).\n    vec2 npos = (focal_dist * 2.) * cpos.xy / cpos.z - jitter / iResolution.y;\n    // Convert to screen space.\n    vec2 spos = .5 + .5 * npos * vec2(iResolution.y / iResolution.x, 1);\n    // Convert to raster space.\n    vec2 rpos = spos * iResolution.xy - jitter;\n    // Read color+depth from this point's previous screen location.\n    vec4 ocolt = texelFetch(iChannel0, ivec2(rpos), 0);\n    // vec4 ocolt = texture( iChannel0, (spos));\n    if (iFrame > 0 && (hit.t < NO_HIT || true)) {\n        // Tonemap before averaging so pixels are weighted equally\n        color = color / (1. + luminance(color));\n\n        // Blend with history (it's an IIR low pas filter really).\n        color = mix(ocolt.xyz, color, 1. / 12.);\n    }\n\n    fragColor = vec4(color, hit.t);\n\n    if (q.y == 0 && q.x > 0 && q.x < 4) {\n        // Camera matrix in lower left three pixels, for next frame.\n        if (q.x == 1)\n            fragColor = vec4(cmat[0], -dot(cmat[0], cam));\n        else if (q.x == 2)\n            fragColor = vec4(cmat[1], -dot(cmat[1], cam));\n        else if (q.x == 3)\n            fragColor = vec4(cmat[2], -dot(cmat[2], cam));\n    }\n#else\n    color = color / (1. + luminance(color));\n\n    vec4 prevColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n\n    float blend = iFrame == 0 || m.zw != vec2(0)\n                      ? 1.0\n                      : 1.0 / (1.0 + (1.0 / prevColor.a));\n\n    fragColor = vec4(mix(prevColor.rgb, color, blend), blend);\n#endif\n    //fragColor = vec4(color, hit.t);\n}","name":"Buffer A","description":"","type":"buffer"}]}