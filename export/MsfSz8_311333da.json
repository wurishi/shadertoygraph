{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"// --- Noises\n// See https://www.shadertoy.com/view/4dfXzH for explanations\n\n// Approximation of the standard deviation of Perlin's noise\n\n#define sigma .175 \n#define size 12.\n#define PI 3.14159265359\n\n// --- noise functions from https://www.shadertoy.com/view/XdXGW8 \n//     & https://www.shadertoy.com/view/lsf3WH\n// Created by inigo quilez - iq/2013\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\n\nvec2 hash( vec2 p ) {  \t\t\t\t\t\t// rand in [-1,1]\n\tp = vec2( dot(p,vec2(127.1,311.7)),\n\t\t\t  dot(p,vec2(269.5,183.3)) );\n\treturn -1. + 2.*fract(sin(p+3.)*53758.5453123);\n}\n\nfloat noise( in vec2 p ) {\n    vec2 i = floor(p), f = fract(p);\n\tvec2 u = f*f*f*(6.*f*f - 15.*f + 10.);\n;\n    return mix( mix( dot( hash( i + vec2(0.,0.) ), f - vec2(0.,0.) ), \n                     dot( hash( i + vec2(1.,0.) ), f - vec2(1.,0.) ), u.x),\n                mix( dot( hash( i + vec2(0.,1.) ), f - vec2(0.,1.) ), \n                     dot( hash( i + vec2(1.,1.) ), f - vec2(1.,1.) ), u.x), u.y);\n}\n/*\n\nfloat hash( vec2 p )\n{\n\tfloat h = dot(p,vec2(127.1,311.7));\n\t\n    return -1.0 + 2.0*fract(sin(h)*43758.5453123);\n}\n\nfloat noise( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n\tvec2 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( hash( i + vec2(0.0,0.0) ), \n                     hash( i + vec2(1.0,0.0) ), u.x),\n                mix( hash( i + vec2(0.0,1.0) ), \n                     hash( i + vec2(1.0,1.0) ), u.x), u.y);\n}\n*/\n\n// Error function approximation for x > 0\nfloat erf(float x) {\n\tfloat a1 =  0.278393;\n\tfloat a2 =  0.230389;\n\tfloat a3 =  0.000972;\n\tfloat a4 =  0.078108;\n\tfloat denom = 1. + (a1 + (a2+(a3+a4*x)*x)*x)*x;\n\treturn 1.-1./(pow(denom,4.));\n}\n\nfloat erfinv(float x) {\n\tfloat a = 0.147;\n\treturn x/abs(x)*sqrt(sqrt((2./(PI*a)+log(1.-x*x)/a)-log(1.-x*x)/a)-2./(PI*a)+log(1.-x*x)/2.);\n}\n\nfloat cauchiDistribution(float x) {\n\tfloat a = 0.09;\n\tfloat cauchi = tan(PI*(x-1./2.))*a;\n\treturn clamp(cauchi, -1., 1.);\n}\n\nfloat exponentialDistribution(float x) {\n\tfloat lambda = 2.;\n\treturn -1.-log((x+1.)/2.)/lambda;\n}\n\n// histogram gives more or less the sum of two gaussian curves\nfloat peaks(float x) {\n\tfloat res;\t\n\tif (x <= 0.) {\n\t\tres = tan(PI*(x+0.5)/2.)*0.5-0.5;\n\t} else {\n\t\tres = tan(PI*(x-0.5)/2.)*0.5+0.5;\n\t}\n\treturn res;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    float nbscales = floor((iMouse.x/iResolution.x)*5.) +1.;\n    \n\tvec2 p = fragCoord.xy / iResolution.xy;\n\tvec2 uv = p*vec2(iResolution.x/iResolution.y,1.0);\n\tfloat res = 1.;\n\tfloat angle = 2.;\n\tmat2 m = 2.*mat2(cos(angle),sin(angle),-sin(angle),cos(angle));\n\tfloat ampl = 1.;\n\t\n\tfor (float i = 0.; i < 5.; i++) {\n\t\tif (i < nbscales) {\n\t\t\t\n\t\t\t// Perlin's noise\n\t\t\tfloat pN = noise(uv*size);\n\t\t\t\n\t\t\t// Multiplicative\n\t\t\tif (p.x<0.2 && p.y > 0.5) {\n\t\t\t\tres *= 1.+pN;\n\t\t\t} else if (p.x<0.4  && p.y > 0.5) {\n\t\t\t\t// Normalized noise\n\t\t\t\tfloat nN = (pN > 0.) ? erf(pN/sqrt(2.)/sigma) : -erf(-pN/sqrt(2.)/sigma);\n\t\t\t\tres *= 1.+nN;\n\t\t\t} else if (p.x<0.6  && p.y > 0.5) {\n\t\t\t\tfloat nN = (pN > 0.) ? erf(pN/sqrt(2.)/sigma) : -erf(-pN/sqrt(2.)/sigma);\n\t\t\t\tres *= 1.+cauchiDistribution(nN/2.+0.5);\n\t\t\t} else if (p.x<0.8  && p.y > 0.5) {\n\t\t\t\tfloat nN = (pN > 0.) ? erf(pN/sqrt(2.)/sigma) : -erf(-pN/sqrt(2.)/sigma);\n\t\t\t\tres *= 1.+exponentialDistribution(nN);\n\t\t\t} else if (p.y > 0.5) {\n\t\t\t\tfloat nN = (pN > 0.) ? erf(pN/sqrt(2.)/sigma) : -erf(-pN/sqrt(2.)/sigma);\n\t\t\t\tres *= 1.+peaks(nN);\n\t\t\t\t\n\t\t\t// Additive\n\t\t\t} else if (p.x<0.2 && p.y < 0.49) {\n\t\t\t\tres += pN*ampl;\n\t\t\t} else if (p.x<0.4 && p.y < 0.49){\n\t\t\t\t// Normalized noise\n\t\t\t\tfloat nN = (pN > 0.) ? erf(pN/sqrt(2.)/sigma) : -erf(-pN/sqrt(2.)/sigma);\n\t\t\t\tres += nN*ampl;\n\t\t\t} else if (p.x<0.6 && p.y < 0.49){\n\t\t\t\tfloat nN = (pN > 0.) ? erf(pN/sqrt(2.)/sigma) : -erf(-pN/sqrt(2.)/sigma);\n\t\t\t\tres += cauchiDistribution(nN/2.+0.5)*ampl;\n\t\t\t} else if (p.x<0.8 && p.y < 0.49){\n\t\t\t\tfloat nN = (pN > 0.) ? erf(pN/sqrt(2.)/sigma) : -erf(-pN/sqrt(2.)/sigma);\n\t\t\t\tres += exponentialDistribution(nN)*ampl;\n\t\t\t} else if (p.y < 0.49){\n\t\t\t\tfloat nN = (pN > 0.) ? erf(pN/sqrt(2.)/sigma) : -erf(-pN/sqrt(2.)/sigma);\n\t\t\t\tres += peaks(nN)*ampl;\n\t\t\t}\n\t\t\tuv = m*uv;\n\t\t\tampl /= 2.;\n\t\t}\n\t}\n\tfragColor.xyz =  vec3(res/2.);\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"MsfSz8","date":"1396522250","viewed":428,"name":"Modified Noises","username":"LoubetG","description":"Modified Perlin noises with control of the distribution functions. Moving the mouse add low frequencies.\nPerlin Noise | Normalized noise | Cauchi | Exponential | 2 Peaks\nSee https://www.shadertoy.com/view/4dfXzH","likes":10,"published":1,"flags":0,"usePreview":0,"tags":["procedural","2d","noise","perlin","distribution"],"hasliked":0,"parentid":"","parentname":""}}