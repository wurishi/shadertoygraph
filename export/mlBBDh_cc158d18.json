{"ver":"0.1","info":{"id":"mlBBDh","date":"1694148378","viewed":107,"name":"Old-style automatic exposure","username":"hasenpfote","description":"This is an implementation using an old-style automatic exposure algorithm.\n- Auto Exposure (Using Mipmap)\n- Bloom (Using Mipmap)\n- Filmic Tonemapping\nYou can change your viewing direction by dragging the mouse.\n[Space] Toggle Bloom ON/OFF.","likes":8,"published":1,"flags":48,"usePreview":0,"tags":["mipmap","tonemapping","filmic","exposure"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nvec4 load_state(in int id){\n    return load_state(iChannel1, int(iResolution.y), id);\n}\n\n/**\n * ACES Filmic Tone Mapping Curve\n * https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/\n */\nvec3 ACESFilm(in vec3 x){\n    return clamp((x*(2.51*x+0.03))/(x*(2.43*x+0.59)+0.14), 0., 1.);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec2 uv = fragCoord / iResolution.xy;\n    vec3 color = texture(iChannel0, uv).rgb;\n    vec4 state = load_state(SID_EXPOSURE);\n#ifndef DEBUG_BLOOM\n    float exposure = state.x;\n    color *= exposure;\n    //color = 1.8 * ACESFilm(color);\n    color = ACESFilm(color);\n#endif\n#ifdef DEBUG_DISPLAY\n    if(uv.x > 0.9 && uv.y > 0.9){\n        color = vec3(state.y); // average luminance\n    }\n#endif\n\n    fragColor = vec4(linear_to_srgb(color), 1.);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"\n#define DEBUG_DISPLAY\n//#define DEBUG_BLOOM\n\n#define SID_EXPOSURE 0\n#define SID_BLOOM    1\n\nconst float PI = 3.1415926535897932384626433832795;\n\nconst int KEYCODE_SPACE = 32;\n\n//==============================================================================\n\nfloat srgb_to_linear(in float x){\n    return x <= 0.04045 ? x / 12.92 : pow((x + 0.055) / 1.055, 2.4);\n}\n\nvec3 srgb_to_linear(in vec3 color){\n    return vec3(srgb_to_linear(color.r), srgb_to_linear(color.g), srgb_to_linear(color.b));\n}\n\nfloat linear_to_srgb(in float x){\n    return x <= 0.0031308 ? 12.92 * x : 1.055 * pow(x, 1./2.4) - 0.055;\n}\n\nvec3 linear_to_srgb(in vec3 color){\n    return vec3(linear_to_srgb(color.r), linear_to_srgb(color.g), linear_to_srgb(color.b));\n}\n\n//==============================================================================\n\nivec2 state_id_to_pos(in int num_rows, in int id){\n    return ivec2(id % num_rows, id / num_rows);\n}\n\nvec4 load_state(in sampler2D ch, in int num_rows, in int id){\n    return texelFetch(ch, state_id_to_pos(num_rows, id), 0);\n}\n\n//==============================================================================\n\nfloat luminance(vec3 color){\n\treturn dot(color, vec3(0.2126, 0.7152, 0.0722));\n}\n\nint get_num_mipmap_levels(in vec2 resolution){\n    return int(floor(log2(max(resolution.x, resolution.y)))) + 1;\n}\n\nmat2 rot(in float angle){\n    float c = cos(angle);\n    float s = sin(angle);\n    return mat2(c, -s, s, c);\n}\n\nvec3 calc_camera_dir(in vec2 uv, in vec2 mouse_uv){\n    vec3 dir = vec3(uv.x, uv.y, 2.);\n\n    if(mouse_uv == vec2(0.)){\n        return dir;\n    }\n\n    vec2 m_ndc = 2. * mouse_uv - 1.;\n    vec2 ang = m_ndc * vec2(PI, 0.5 * PI);\n    dir.yz = rot(ang.y) * dir.yz;\n    dir.xz = rot(ang.x) * dir.xz;\n\n    return dir;\n}\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"/**\n * In this pass, various states are loaded and stored.\n */\n\nconst float INITIALIZATION_DELAY = 0.05;\n\nconst float KEY_VALUE = 0.18;\nconst float ADAPTATION_SPEED = 0.01;\n\nint state_pos_to_id(in ivec2 pos){\n    return int(iResolution.y) * pos.y + pos.x;\n}\n\nbool can_store_state(in int id, in ivec2 pos){\n    return state_id_to_pos(int(iResolution.y), id) == pos;\n}\n\nvec4 load_state(in int id){\n    return load_state(iChannel0, int(iResolution.y), id);\n}\n\nbool is_key_pressed(int code){\n    return texelFetch(iChannel1, ivec2(code, 1), 0).x > 0.;\n}\n\nfloat calc_exposure(in float avg_luminance){\n    avg_luminance = max(avg_luminance, 0.00001);\n    return max(KEY_VALUE / avg_luminance, 0.00001);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    ivec2 pos = ivec2(fragCoord);\n    vec4 state;\n\n    if(can_store_state(SID_EXPOSURE, pos)){\n        state = load_state(SID_EXPOSURE);\n        if(iTime > INITIALIZATION_DELAY){\n            // To enable mipmapping, set the \"Filter\" option to \"mipmap\" in the sampler configuration.\n            float lod = float(get_num_mipmap_levels(iResolution.xy) - 1);\n            float l_avg = exp(textureLod(iChannel2, vec2(0.), lod).a);\n            float exposure = calc_exposure(l_avg);\n            state.x = mix(state.x, exposure, ADAPTATION_SPEED);\n            state.y = l_avg;\n        }else{\n            state = vec4(1., 0., 0., 0.);\n        }\n    }else if(can_store_state(SID_BLOOM, pos)){\n        state = load_state(SID_BLOOM);\n        if(iTime > INITIALIZATION_DELAY){\n            if(is_key_pressed(KEYCODE_SPACE)){\n                state.x = int(state.x) == 0 ? 1. : 0.;\n            }\n        }else{\n            state = vec4(0., 0., 0., 0.);\n        }\n    }else{\n        discard;\n    }\n\n    fragColor = state;\n}\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"/**\n * In this pass, high luminance is extracted for bloom.\n */\n\nconst float BLOOM_THRESHOLD = 0.95;\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec2 uv = (2. * fragCoord - iResolution.xy) / iResolution.y;\n    vec2 mouse_uv = iMouse.xy / iResolution.xy;\n    vec3 dir = calc_camera_dir(uv, mouse_uv);\n    vec3 color = srgb_to_linear(texture(iChannel0, dir).rgb);\n\n    if(luminance(color) < BLOOM_THRESHOLD){\n        color = vec3(0.);\n    }\n\n    fragColor = vec4(color, 1.);\n}\n","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"/**\n * In this pass, the scene is created, and logarithmic luminance is stored in the output alpha channel.\n * The output alpha channel at the 1x1 mipmap level becomes the average value.\n */\n\nvec4 load_state(in int id){\n    return load_state(iChannel2, int(iResolution.y), id);\n}\n\nfloat gauss(in float x, in float scale){\n    return exp(- scale * x * x);\n}\n\nvec3 blur(in vec2 pos){\n    vec3 color = vec3(0.);\n    int num_levels = get_num_mipmap_levels(iResolution.xy) / 2;\n    float weight;\n    float weight_sum = 0.;\n    for(int i = 0; i < num_levels; i++){\n        float weight = gauss(log2(float(num_levels-i)), 0.5);        \n        // To enable mipmapping, set the \"Filter\" option to \"mipmap\" in the sampler configuration.\n        color += weight * textureLod(iChannel1, pos / iResolution.xy, float(i)).rgb;\n        weight_sum += weight;\n    }\n    return color / weight_sum;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec2 uv = (2. * fragCoord - iResolution.xy) / iResolution.y;\n    vec2 mouse_uv = iMouse.xy / iResolution.xy;\n    vec3 dir = calc_camera_dir(uv, mouse_uv);\n#ifdef DEBUG_BLOOM\n    vec3 color = vec3(0.);\n#else\n    vec3 color = srgb_to_linear(texture(iChannel0, dir).rgb);\n#endif\n    if(load_state(SID_BLOOM).x > 0.){\n        color += blur(fragCoord);\n    }\n\n    float lum = log(0.00001 + luminance(color));\n\n    fragColor = vec4(color, lum);\n}\n","name":"Buffer C","description":"","type":"buffer"}]}