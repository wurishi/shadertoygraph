{"ver":"0.1","info":{"id":"MsKBD3","date":"1533612154","viewed":187,"name":"Raytracing_Study_1","username":"codeonwort","description":"First raytracing test","likes":1,"published":1,"flags":32,"usePreview":0,"tags":["raytracing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sf3Rn","filepath":"/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","previewfilepath":"/media/ap/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n/* -----------------------------------------\n\t\t\t\t\tdebug\n------------------------------------------ */\n#define SHOW_HORIZON_CALC_ERROR\t   0\n#define TEST_SUPERQUADRIC          1\n\n/* -----------------------------------------\n\t\t\t\tconfiguration\n------------------------------------------ */\n#define ANTI_ALIASING              1 // Super sampling\n#define ANIMATE_CAMERA             0\n#define ANIMATE_BLUE_SPHERE        1\n#define LIGHT_FOLLOWS_CAMERA       0\n#define ROTATE_PITCH_BY_MOUSE_Y    1\n\n// 0: cubemap, 1: noise simulation\n#define SIMULATE_SKY               1\n\n/* -----------------------------------------\n\t\t\t\t  constants\n------------------------------------------ */\n#define FOV_Y            75.0\n#define CAMERA_ORIGIN    vec3(0.0, 5.0, 50.0)\n#define LOOK_AT          vec3(0.0, 30.0, 0.0)\n\n#define COLOR_RED        vec3(1.0, 0.0, 0.0)\n#define COLOR_BLUE       vec3(0.0, 0.0, 1.0)\n\n/* -----------------------------------------\n\t\t\t\tprogram code\n------------------------------------------ */\n\n#if TEST_SUPERQUADRIC\nSuperquadric sphere = Superquadric(3.0, 3.0, 3.0, 16.0);\n#else\nSphere sphere = Sphere(\n    vec3(0.0, 15.0, 0.0),\n    10.0,\n    COLOR_RED);\n#endif\n\nSphere sphere2 = Sphere(\n    vec3(-0.2, 16.0, 20.0),\n    2.0,\n    COLOR_BLUE);\n\nPlane plane = Plane(\n    vec3(0.0, -15.0, 0.0), // center\n    vec3(0.0, 1.0, 0.0)); // normal\n\nSphere sphere_sky = Sphere(\n    vec3(0.0, -450.0, 0.0),\n    600.0,\n    COLOR_BLUE);\n\nSun sun = Sun( vec3(0.0, 1.0, 1.0), 10.0 );\n\nfloat noise(vec3 p)\n{\n    vec2 uv = p.xz;\n    uv.x += 0.2 * sin(p.y);\n    uv.y += 0.2 * cos(p.y);\n    uv.x += iTime * 0.01;\n    return texture(iChannel1, uv).r;\n}\n\nfloat fbm(vec3 x)\n{\n    float amp = 0.5;\n    float freq = 2.0;\n    float y = 0.0;\n    \n    for(int i = 0; i < 5; ++i)\n    {\n    \ty += amp * noise(x);\n    \tx *= freq;\n    \tamp *= 0.6;\n    }\n    y = clamp(y, 0.0, 1.0);\n    \n    return y;\n}\n\n////////////////////////////////////////////////////////////////\n// Volume scattering\n// 1. absorption\n// 2. emission\n// 3. out-scattering\nfloat calcTransmittance(vec3 startPoint, vec3 rayDir)\n{\n    const int   LOOP_STEPS  =  64;\n    const float RAY_LENGTH  =  5.0;\n    const float RAY_STEP    =  RAY_LENGTH / float(LOOP_STEPS);\n    \n    float T = 1.0; // transmittance\n    vec3  P = startPoint;\n    \n    float Tsum = 0.0;\n    \n    float coeff = 0.0;\n    \n    for(int i = 0; i < LOOP_STEPS; ++i)\n    {\n        float density = fbm(P);\n        \n        if(density > 0.0)\n        {\n            T *= 1.0 - (RAY_STEP * density);\n            Tsum += T;\n            \n            if(T <= 0.01)\n            {\n                break;\n            }\n        }\n        \n        P += rayDir * RAY_STEP;\n    }\n    \n    T = exp(-T);\n    \n    return Tsum;\n}\n\n// I don't understand yet how the hell cloud rendering works,\n// so figuring it out step by step...\n// https://www.shadertoy.com/view/lss3zr\n// L : sun direction\nvec3 calcSky(Ray eye, vec2 uv, vec3 L, vec3 cameraForward)\n{\n    const int   STEPS       =  64;\n    const int   LIGHT_STEPS =  6;\n    const float eye_step    =  5.0 / float(STEPS);\n    const float light_step  =  5.0 / float(LIGHT_STEPS);\n    const float absorption  =  90.0;\n    \n    // P = hit point between eye and atmosphere\n    float t = hitTest(eye, sphere_sky);\n    vec3 P = eye.origin + t * eye.direction;\n    \n    // scale P by random logic\n    float some_random_scaling = 0.2;\n    float r = sphere_sky.radius;\n    float h = sphere_sky.center.y;\n    float w = 1.0 / sqrt(r*r - h*h);\n    P *= w * some_random_scaling;\n    \n    // radiance coming from sky to eye\n    vec3 color = vec3(0.0, 0.0, 0.0);\n    \n#define TEST_CLOUD 0\n    \n#if TEST_CLOUD\n    // TODO: physically correct volume scattering\n    float T = calcTransmittance(P, eye.direction);\n    color = T * vec3(1.0) * 0.04;\n#endif\n    \n#if TEST_CLOUD == 0\n    float T = 1.0; // transmittance\n    \n    for(int i = 0; i < STEPS; ++i)\n    {\n        float density = fbm(P);\n        \n        if(density > 0.0)\n        {\n            float temp = density / float(STEPS);\n            \n            T *= 1.0 - temp * absorption;\n            if(T <= 0.01)\n            {\n                break;\n            }\n            \n            float Tl = 1.0;\n            for(int j = 0; j < LIGHT_STEPS; ++j)\n            {\n                float dl = fbm(P + (-L) * float(j) * light_step);\n                if(dl > 0.0)\n                {\n                    Tl *= 1.0 - dl * absorption / float(STEPS);\n                }\n                if(Tl <= 0.01)\n                {\n                    break;\n                }\n            }\n            \n            // what physical meaning they do have on it #*!*&@^!*&@^!@\n            color += vec3(1.0, 1.0, 1.0) * 250.0 * temp * T;\n            color += vec3(0.7, 0.3, 0.0) * density * (1.0 - Tl);\n        }\n        P += eye.direction * eye_step;\n    }\n#endif\n    \n    // WTF logic\n    // not accurate, but can't derive the right one.\n    // this is correct on my paper calculation :((((( what's wrong\n    float horizon_v = 0.5;\n    {\n        float H = 0.5;\n        float alpha = radians(0.5 * FOV_Y);\n        vec3 v = normalize(vec3(cameraForward.x, 0.0, cameraForward.z));\n        float beta = acos(dot(v, cameraForward));\n        float h = sign(cameraForward.y) * H * tan(beta) / tan(alpha);\n        horizon_v = (0.5 - h);\n    }\n    \n    const vec3 dim = vec3(0.1, 0.2, 0.8);\n    if(uv.y <= horizon_v)\n    {\n#if SHOW_HORIZON_CALC_ERROR\n        color = vec3(1.0, 0.0, 0.0);\n#else\n        color = dim;\n#endif\n    }\n    else\n    {\n        color = mix(dim, color, 1.0 / (1.0 - horizon_v) * (uv.y - horizon_v));\n    }\n    \n    return color;\n}\n\nvec3 scene(vec2 uv, vec3 L)\n{\n    L = -L;\n    \n    vec3 P = vec3(uv - 0.5, 0.0);\n    P.x *= iResolution.x / iResolution.y;\n    P.z = -(0.5 / tan(radians(FOV_Y / 2.0)));\n    vec3 ray_forward = normalize(P);\n    \n    vec3 cameraOrigin = CAMERA_ORIGIN;\n#if ANIMATE_CAMERA\n    cameraOrigin.y += 2.0 * (1.0 + sin(iTime));\n    float k = 0.2 * iTime;\n#else\n    float k = 0.0;\n#endif\n    cameraOrigin = rotateY(cameraOrigin, k);\n    \n    vec3 lookAt = LOOK_AT;\n#if ROTATE_PITCH_BY_MOUSE_Y\n    float mouseX = 1.0 - 2.0 * (iMouse.x / iResolution.x);\n    float mouseY = 1.0 - 2.0 * (iMouse.y / iResolution.y);\n    lookAt.x -= mouseX * 100.0;\n    lookAt.y -= mouseY * cameraOrigin.y * 10.0;\n#endif\n    \n    vec3 camera_forward  =  normalize(lookAt - cameraOrigin);\n    vec3 camera_up       =  vec3(0.0, 1.0, 0.0);\n    vec3 camera_right    =  cross(camera_forward, camera_up);\n    camera_up = cross(camera_right, camera_forward);\n    mat3 camera_transform = mat3(camera_right, camera_up, -camera_forward);\n    \n#if LIGHT_FOLLOWS_CAMERA\n    L = camera_transform * L;\n#endif\n    \n    ray_forward = camera_transform * ray_forward;\n    \n    Ray ray;\n    ray.origin = cameraOrigin;\n    ray.direction = ray_forward;\n    \n    float t = hitTest(ray, sphere);\n    float t2 = hitTest(ray, sphere2);\n    float t3 = hitTest(ray, plane);\n    \n    bool both    = t >= 0.0 && t2 >= 0.0;\n    bool only_t  = t >= 0.0 && t2 < 0.0;\n    bool only_t2 = t < 0.0  && t2 >= 0.0;\n    \n    vec3 result = vec3(0.0);\n    \n    if(t >= 0.0 || t2 >= 0.0)\n    {\n        vec3 P, N;\n        \n        if((both && t < t2) || only_t)\n        {\n            // red sphere\n            P = t * ray.direction + ray.origin; // hit point\n#if TEST_SUPERQUADRIC\n            N.x = sphere.r * pow(abs(P.x/sphere.size), sphere.r - 1.0) * sign(P.x);\n            N.y = sphere.s * pow(abs(P.y/sphere.size), sphere.s - 1.0) * sign(P.y);\n            N.z = sphere.t * pow(abs(P.z/sphere.size), sphere.t - 1.0) * sign(P.z);\n            N = normalize(N);\n            MaterialAttributes superquadricMaterial = MaterialAttributes(vec3(0.04), vec3(1.0,0.0,0.0), 64.0);\n            result = shading_phong(superquadricMaterial, ray, P, N, L);\n#else\n            N = normalize(P - sphere.center);\n        \tresult = shading_sphere_phong(sphere, ray, P, N, L);\n#endif\n            \n            // Calculate indirect light transport\n            Ray indirect;\n            indirect.origin = P;\n            \n            // reflection from plane\n            indirect.direction = N;\n            t = hitTest(indirect, plane);\n            if(t > 0.0)\n            {\n                P = t * indirect.direction + indirect.origin;\n                vec3 planeColor = shading_plane_albedo(plane, P, vec3(1.0, 0.0, 0.0));\n                planeColor *= 1.0 / (1.0 + 0.02 * t);\n                result += 0.8 * planeColor;\n            }\n            \n            // reflection from blue sphere\n            indirect.direction = N;\n            t = hitTest(indirect, sphere2);\n            if (t > 0.0)\n            {\n            \tP = t * indirect.direction + indirect.origin;\n            \tvec3 color2 = sphere2.albedo;\n                result += 0.75 * color2;\n            }\n            \n            // shadow\n            indirect.direction = L;\n            t = hitTest(indirect, sphere2);\n            if(t > 0.0)\n            {\n                P = t * indirect.direction + indirect.origin;\n        \t\tN = normalize(P - sphere2.center);\n                result *= 0.2;\n            }\n        }\n        else if((both && t > t2) || only_t2)\n        {\n            // blue sphere\n            P = t2 * ray.direction + ray.origin; // hit point\n        \tN = normalize(P - sphere2.center);\n        \tresult = shading_sphere_phong(sphere2, ray, P, N, L);\n        }\n    }\n    else if(t3 >= 0.0)\n    {\n        // plane\n        P = t3 * ray.direction + ray.origin; // hit point\n        vec3 planeColor = shading_plane_albedo(plane, P, vec3(1.0, 0.0, 0.0));\n        \n        float D = length(P - cameraOrigin);\n        planeColor *= 1.0 / (0.001 + 0.02 * D);\n        \n        result = planeColor;\n    }\n    else\n    {\n\n#if SIMULATE_SKY == 0\n        vec3 env = vec3(uv - 0.5, 0.0);\n        env.z = -0.5;\n    \tenv = normalize(env);\n        env = camera_transform * env;\n        result = texture(iChannel0, env).rgb;\n        \n#elif SIMULATE_SKY == 1\n        ray.origin = cameraOrigin;\n    \tray.direction = ray_forward;\n        result = calcSky(ray, uv, -L, camera_forward);\n        \n#endif\n        \n    }\n    \n    return result;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // update scene\n#if ANIMATE_BLUE_SPHERE\n    sphere2.center.x = 5.0 * sin(iTime / 1.0);\n#endif\n    \n    float mouseX = 1.0 - 2.0 * (iMouse.x / iResolution.x);\n    float mouseY = 1.0 - 2.0 * (iMouse.y / iResolution.y);\n    \n    // render scene\n    vec2 uv = fragCoord / iResolution.xy;\n    //vec3 L = normalize(vec3(mouseX, mouseY, -1.0));\n    vec3 L = normalize(vec3(0.0, 0.0, -1.0));\n    \n#if ANTI_ALIASING\n    vec4 finalColor = vec4(0.0, 0.0, 0.0, 1.0);\n    for(int dx = -1; dx <= 1; ++dx)\n    {\n        for(int dy = -1; dy <= 1; ++dy)\n        {\n            vec2 dudv = 0.5 / iResolution.xy;\n            finalColor.rgb += scene(uv + vec2(dx,dy) * dudv, L);\n        }\n    }\n    finalColor.rgb /= 9.0;\n    fragColor = finalColor;\n#else\n    fragColor = vec4(scene(uv, L), 1.0);\n#endif\n    \n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define FLT_MAX          3.402823466e+38\n#define PI               3.141592\n\n// plane grid size\n#define gridX 4.0\n#define gridY 4.0\n\n/*\n#define MATERIAL_ID_NONE      0\n#define MATERIAL_ID_SPHERE    1\n#define MATERIAL_ID_PLANE     2\n#define MATERIAL_ID_SKY       3\n*/\n\n/* -----------------------------------------\n\t\t\t\t\tstruct\n------------------------------------------ */\n\nstruct MaterialAttributes {\n    vec3 ambient;\n    vec3 albedo;\n    float specularExponent;\n};\n\nstruct HitResult {\n    float t;          // location = ray_origin + t * ray_direction;\n    vec3 location;\n    vec3 normal;\n    uint materialID;\n};\n\nstruct Sphere {\n    vec3 center;\n    float radius;\n    vec3 albedo;\n};\n\n// |x|^r + |y|^s + |z|^t = 1\nstruct Superquadric {\n    float r;\n    float s;\n    float t;\n    float size;\n};\n\nstruct Ray {\n    vec3 origin;\n    vec3 direction;\n};\n\nstruct Plane {\n    vec3 center;\n    vec3 normal;\n};\n    \nstruct Sun {\n\tvec3 direction;\n    float radius;\n};\n\n/* -----------------------------------------\n\t\t\t\t\tray math\n------------------------------------------ */\n\n// No time to solve a closed form today. Let's ray march for now :p\nfloat hitTest(Ray R, Superquadric S) {\n    const int maxStep = 128;\n    const float tStep = 0.5; // uniformly step forward\n    const float startT = 0.05;\n    \n    float resultT = -1.0;\n    float t = startT;\n    for(int step = 0; step < maxStep; step++) {\n        t += tStep;\n        vec3 p = abs(R.origin + t * R.direction);\n        float det = pow(p.x/S.size, S.r) + pow(p.y/S.size, S.s) + pow(p.z/S.size, S.t);\n        if (det <= 1.0) {\n            resultT = t;\n            break;\n        }\n    }\n    return resultT;\n}\n    \nfloat hitTest(Ray R, Sphere S) {\n    // att + 2bt + c = 0\n    vec3 oc = R.origin - S.center;\n    float a = dot(R.direction, R.direction);\n    float b = dot(R.direction, oc);\n    float c = dot(oc, oc) - (S.radius * S.radius);\n    \n    // no intersection\n    float det = b*b - a*c;\n    if(det < 0.0) {\n        return -FLT_MAX;\n    }\n    det = sqrt(det);\n    \n    float t = (-b - det) / a;\n    if(t < 0.0) {\n        t = (-b + det) / a;\n    }\n    if(t < 0.0) {\n        return -FLT_MAX;\n    }\n    return t;\n}\n\nfloat hitTest(Ray R, Plane P) {\n    float num = dot(P.center - R.origin, P.normal);\n    float denom = dot(R.direction, P.normal);\n    return num / denom;\n}\n\nvec3 rotateY(vec3 v, float t) {\n    vec3 u = v;\n    float temp = u.x;\n    u.x = u.x * cos(t) + u.z * sin(t);\n    u.z = -temp * sin(t) + u.z * cos(t);\n    return u;\n}\n\n/* -----------------------------------------\n\t\t\t\t\tlighting\n------------------------------------------ */\n\nvec3 shading_phong(MaterialAttributes material, Ray ray, vec3 P, vec3 N, vec3 L) {\n    vec3 ambient = material.ambient;\n    vec3 albedo = material.albedo;\n    float specularExponent = material.specularExponent;\n\n    float cosTheta = max(dot(N, L), 0.0);\n    vec3 diffuse = albedo * cosTheta;\n\n    vec3 R = reflect(L, N);\n    cosTheta = max(dot(R, ray.direction), 0.0);\n    vec3 specular = vec3(1.0) * pow(cosTheta, specularExponent);\n    \n    return ambient + diffuse + specular;\n}\n\nvec3 shading_sphere_phong(Sphere sphere, Ray ray, vec3 P, vec3 N, vec3 L) {\n    MaterialAttributes material = MaterialAttributes(vec3(0.04), sphere.albedo, 32.0);\n    return shading_phong(material, ray, P, N, L);\n}\n\nvec3 shading_plane_albedo(Plane P, vec3 location, vec3 T) {\n    vec3 delta = location - P.center;\n    location = location - P.normal * dot(delta, P.normal);\n    delta = location - P.center;\n    vec3 B = cross(P.normal, T);\n    float dx = dot(delta, T);\n    float dy = dot(delta, B);\n    dx = mod(dx, gridX * 2.0);\n    dy = mod(dy, gridY * 2.0);\n    bool bx = dx <= gridX;\n    bool by = dy <= gridY;\n    if(bx ^^ by) {\n        return vec3(1.0);\n    }\n    return vec3(0.0);\n}\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\nvec3 renderSun( vec2 uv )\n{\n    vec2 p = (uv - 0.5) * 2.0;\n    float d = max(0.0, length(p)); // distance to center\n    \n    vec3 orange = vec3(1.0, 0.6, 0.3);\n    \n    vec3 color = orange * sqrt(1.0 - d);\n    color += pow(1.0 - d, 2.0) * vec3(1.0);\n    \n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if(iFrame == 0)\n    {\n        vec2 uv = fragCoord / iResolution.xy;\n        fragColor = vec4(renderSun(uv), 1.0);\n    }\n}","name":"Buffer A","description":"","type":"buffer"}]}