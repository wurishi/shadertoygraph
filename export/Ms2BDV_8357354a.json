{"ver":"0.1","info":{"id":"Ms2BDV","date":"1502359474","viewed":271,"name":"Sky study over the ocean","username":"Draedrus","description":"Sunset over the ocean\n\nuse the mouse horizontally to turn the camera and vertically to switch the hour.","likes":0,"published":1,"flags":32,"usePreview":0,"tags":["clouds","ocean","atmosphere","fresnel","mie","reyleigh"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/***********************************************************************\n * author: pierre.plans@gmail.com\n ***********************************************************************/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 u = fragCoord.xy/iResolution.xy;\n    #if 1\n    float e = 1.2/iResolution.x;\n    fragColor += texture(iChannel0, u+vec2(-e, -e));\n    fragColor += texture(iChannel0, u+vec2(e, -e));\n    fragColor += texture(iChannel0, u+vec2(-e, e));\n    fragColor += texture(iChannel0, u+vec2(e, e));\n    fragColor *= .25;\n    #else\n    fragColor = texture(iChannel0, u);\n    #endif\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"\n\n/**\n * RENDERING OPTION GLOBALS\n **/\n\n#define USE_SKY\n#define USE_TEXTURE_MAP\n\n// HDR sky parameters\n#define SCALE_HEIGHT\t\t 8000.0\n#define SUNDIST \t149597870700.0\n#define EARTHRADIUS\t\t\t 6360e3\n#define CLOUDSTART\t\t \t6385e3\n#define CLOUDEND\t\t \t6395e3\n#define ATMOSPHERERADIUS \t6420e3\n#define SUNINTENSITY\t\t 15.0\n#define SUNRADIUS \t  695700000.0\n#define MOONRADIUS \t\t1737400.0\n#define EARTHPOS vec3(0.0, 0.0, 0.0)\n\n#define SKY_BETA_MIE vec3(21e-7)\n#define SKY_BETA_RAY vec3(5.5e-6, 13.0e-6, 22.4e-6)\n// 1200.\n#define SKY_MIE_HEIGHT 1200.\n\n#define CLOUDS_FIXED_POS\n//#define CLOUDS_RAYMARCH_MIE\n\n#define SUNPOS normalize(vec3(0.0, 1.0, 0.0))*149597870700.0\n#define MOONPOS normalize(vec3(1.0, 0.5, 0.7))*384467700.0\n\n#define NEAR 0.002\n#define FAR 200.0\n\n#define CAMDIST 8.0\n#define CAMROTSPEED 0.2\n#define CAMPOS vec3(0.0, 1.0, -4.0)\n#define CAMDEPTH 1.\n#define TARGETPOS vec3(0.0, 3.0, 0.0)\n\n#define TARGETSIZE 2.5\n\n#define TARGETDENSITYSCALE 0.1\n#define TARGETDENSITYLOWHEIGHT 1.\n#define TARGETDENSITYHIGHHEIGHT 2.\n\n#define SEA_WAVES 6\n#define SEA_SPEED 4.2\n#define SEA_CHOP 2.\n#define SEA_AMP 8.\n\n#define OCTAVES 4\n\n/*******************\n * TOOLS\n *******************/\n\nvec3 RotXV3(in vec3 P, float A)\n{\n    float cA = cos(A), sA = sin(A);\n    return P*mat3(1.0, 0.0, 0.0, 0.0, cA, -sA, 0.0, sA, cA);\n}\nvec3 RotYV3(in vec3 P, float A)\n{\n    float cA = cos(A), sA = sin(A);\n    return P*mat3(cA, 0.0, -sA, 0.0, 1.0, 0.0, sA, 0.0, cA);\n}\n\nfloat IntersectSphere(vec3 ro, vec3 rd, vec3 sc, float sr) {\n    vec3 Z = ro-sc;\n    float B = 2.0 * dot(rd, Z);\n    float C = Z.x*Z.x+Z.y*Z.y+Z.z*Z.z-sr*sr;\n    float D = B*B - 4.0*C;\n    float d = -1.0;\n    if(D>=0.0) {\n        d = (.5*-B+(C>0.?-sqrt(D):sqrt(D)));\n    }\n    return d;\n}\n\n/********************\n * NOISES\n ********************/\n\n/** HASH **/\n\nvec2 rot(vec2 X, float a)\n{\n \tfloat s = sin(a); float c = cos(a);\n    return mat2(c, -s, s, c)*X;\n}\n\nfloat hash(vec2 uv)\n{\n \tvec2 suv = sin(uv);\n    suv = rot(suv, uv.x);\n    return fract(mix(suv.x*13.13032942, suv.y*12.01293203924, dot(uv, suv)));\n}\n\nfloat custom_perlin_hash(vec2 uv)\n{\n \tvec2 lower\t= floor(uv);\n    vec2 frac \t= fract(uv);\n    vec2 f = frac*frac*(3.0-2.0*frac);\n    \n    return mix(\n        \tmix(hash(lower+vec2(0.0, 0.0)), hash(lower+vec2(1.0, 0.0)), f.x),\n        \tmix(hash(lower+vec2(0.0, 1.0)), hash(lower+vec2(1.0, 1.0)), f.x),\n        \tf.y);\n}\n\nfloat fbm_hash(vec2 uv)\n{\n    float total = 0.0;\n    total += 0.5000*custom_perlin_hash(uv); uv*=2.001;\n    total += 0.2500*custom_perlin_hash(uv); uv*=2.003;\n    total += 0.1250*custom_perlin_hash(uv); uv*=2.002;\n    total += 0.0625*custom_perlin_hash(uv); uv*=2.001;\n    return clamp(total, 0.0, 1.0);\n}\n\nfloat hash1D(float x)\n{\n\treturn fract(((x+124.2394943)*134.400594)*((x+7.13571113)*1.13497));\n}\n\nfloat hash2D(vec2 x)\n{\n    x = fract(x*1024.137849567);\n    float r = dot(x, x.yx + 1.2094838975);\n    //return fract((x.x+x.y)*r);\n\treturn fract(sin(dot(x, vec2(13.454, -13.405)))*123.3043);\n}\n\nfloat hash3D(vec3 x)\n{\n    x = fract(x*1024.7849567);\n    float r = dot(x, x.yxz + 1.2094838975);\n    return fract(x.x*x.y+x.z*r);\n\treturn fract(dot(x, vec3(1.714955, 1.8624294, 1.40594))*1.196524959451);    \n}\n\nfloat voronoi2D(vec2 uv) {\n    vec2 fl = floor(uv);\n    vec2 fr = fract(uv);\n    float res = 1.0;\n    for( int j=-1; j<=1; j++ ) {\n        for( int i=-1; i<=1; i++ ) {\n            vec2 p = vec2(i, j);\n            float h = hash2D(fl+p);\n            vec2 vp = p-fr+h;\n            float d = dot(vp, vp);\n            \n            res +=1.0/pow(d, 32.0); // 8\n        }\n    }\n    return pow( 1.0/res, 1.0/16.0 );\n}\n\nfloat voronoi3D(vec3 uv) {\n    vec3 fl = floor(uv);\n    vec3 fr = fract(uv);\n    float res = 1.0;\n    for(int k=-1;k<=1;k++)\n    for( int j=-1; j<=1; j++ ) {\n        for( int i=-1; i<=1; i++ ) {\n            vec3 p = vec3(i, j, k);\n            float h = hash3D(fl+p);\n            vec3 vp = p-fr+h;\n            float d = dot(vp, vp);\n            \n            res +=1.0/pow(d, 16.0);\n        }\n    }\n    return pow( 1.0/res, 1.0/16.0 );\n}\n\nfloat noise3D(vec3 x) {\n    vec3 p = floor(x);\n    vec3 n = fract(x);\n    vec3 f = n*n*(3.0-2.0*n);\n    float winx = 1.0;\n    float winy = 1.0;\n    float winz = 1.0;\n    \n    return mix(\n        \tmix(\n                mix(hash3D(p)     \t\t\t\t  , hash3D(p+vec3(winx, 0.0, 0.0)), f.x),\n                mix(hash3D(p+vec3(0.0, winy, 0.0)), hash3D(p+vec3(winx, winy, 0.0)), f.x),\n                f.y),\n        \tmix(\n                mix(hash3D(p+vec3(0.0, 0.0, winz)), hash3D(p+vec3(winx, 0.0, winz)), f.x),\n                mix(hash3D(p+vec3(0.0, winy, winz)), hash3D(p+vec3(winx, winy, winz)), f.x),\n                f.y),\n        \tf.z);\n}\n\nfloat fbm3D(vec3 p, float seed) {\n    float total = 0.0;\n    #ifdef USE_ANIMATECLOUDS\n    \tp.y += seed*CLOUDSPEED;\n    #endif\n    total  = 0.5000* noise3D(p); p = p*2.0;\n    total += 0.2500* noise3D(p); p = p*2.0;\n    total += 0.1250* noise3D(p); p = p*2.0;\n    total += 0.0625* noise3D(p); p = p*2.0;\n    return total;\n}\n\n// the camera construction method is inspired by the one from IQ\nmat3 setCamera( in vec3 origin, in vec3 target, vec3 viewUp )\n{\n\tvec3 cw = normalize(target-origin);\n\tvec3 cu = normalize( cross(cw,viewUp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid camPos(float t, in vec3 rdi, in vec3 roi, out vec3 ro, out vec3 rd) {\n    mat3 rotX = mat3(\n        1.0, 0.0, 0.0,\n        0.0, cos(t), -sin(t),\n        0.0, sin(t), cos(t));\n    mat3 rotY = mat3(\n        cos(t), 0.0, sin(t),\n        0.0, 1.0, 0.0,\n        -sin(t), 0.0, cos(t));\n    mat3 rotZ = mat3(\n        cos(t), sin(t), 0.0,\n        -sin(t), cos(t), 0.0,\n    \t0.0, 0.0, 1.0);\n    \n    ro = roi;\n\trd = normalize(rdi*rotY);\n}\n\nmat3 GetCamera(in vec2 pixel, in vec3 T, inout vec3 outRO, out vec3 outRD, out vec3 outRDO)\n{\n    mat3 ca = setCamera(outRO, T, vec3(0.0, 1.0, 0.0));\n    outRDO = normalize(vec3(pixel.xy, CAMDEPTH));\n    outRD = ca*outRDO;\n  \n    return ca;\n}\n\nfloat IntersectSphere(vec3 ro, vec3 rd, vec3 sc, float sr, out float tmin, out float tmax) {\n    vec3 Z = ro-sc;\n    float B = 2.0 * dot(rd, Z);\n  \n    float C = Z.x*Z.x+Z.y*Z.y+Z.z*Z.z-sr*sr;\n    float D = B*B - 4.0*C;\n    float d = -1.0;\n    if(D>=0.0) {\n        if(C==0.0) {\n            tmin = -B/2.0;\n            tmax = -1.;\n            d = 0.0;\n        }else{\n            tmin = (-B-sqrt(D))/2.0;\n            tmax = (-B+sqrt(D))/2.0;\n            d = 1.0;\n        }\n    }\n    return d;\n}\n\n// From http://www.scratchapixel.com/old/lessons/3d-advanced-lessons/simulating-the-colors-of-the-sky/atmospheric-scattering/\nvec3 getSkyLight(vec3 ro, vec3 rd, vec3 Lpos, vec3 betaR, vec3 betaM, out vec3 miecolor, float _hm)\n{\n    #define ERR vec3(1., 0., 0.)\n    vec3 L = normalize(Lpos-ro);\n    float tmin = -1.0;\n    float tmax = -1.0;\n    float d = IntersectSphere(ro, rd, EARTHPOS, ATMOSPHERERADIUS, tmin, tmax);\n    float temin = -1., temax = -1.;\n    float de = IntersectSphere(ro, rd, EARTHPOS, EARTHRADIUS, temin, temax);\n    \n    tmin = max(0., min(temin<0.?tmin:temin, tmin));\n    tmax = min(tmax, temin<0.?tmax:temin);\n    \n    //tmax = max(1., min(max(0., temin), tmax));\n  \n    float RdotL = dot(rd, L);\n    float tCurrent = tmin;\n    float segL = (tmax-tCurrent)/16.0;\n     \n    float g = 0.76; // 0.76\n    float g2 = g*g;\n    float hr = 7994.0; // 7994\n    float hm = _hm;//800.0; // 1200\n    // Rayleigh\n    vec3 sumR = vec3(0.0);\n    float phaseR = 3.0/(16.0*3.14)*(1.0+RdotL*RdotL);\n    //vec3 betaR = vec3(5.5e-6, 13.0e-6, 22.4e-6);\n    float opticalDepthR = 0.0;\n    // Mie\n    vec3 sumM = vec3(0.0);\n    //float phaseM = 3.0/(8.0*3.14)*((1.0-g*g)+(1.0+RdotL*RdotL))/((2.0+g*g)+pow(1.0+g*g-2.0*g*RdotL, 1.5));\n    // correction thanks to from http://http.developer.nvidia.com/GPUGems2/gpugems2_chapter16.html\n    // my implementation has an error with the first terms in the equation\n    float phaseM = (\n        \t\t\t(3.0*(1.0-g2))/\n        \t\t\t(2.0*(2.0+g2))\n        \t\t\t)*\n        \t\t\t(\n                        (1.0+RdotL*RdotL)/\n                        pow(1.0+g2-2.0*g*RdotL, 1.5)\n                    );\n    //vec3 betaM = vec3(21e-6);\n    float opticalDepthM = 0.0;\n    for (int i = 0; i < 16; ++i)\n    {\n        vec3 X = ro+rd*(tCurrent+0.5*segL);\n        float h = length(X) - EARTHRADIUS;\n        float _hr = exp(-h/hr)*segL;\n        float _hm = exp(-h/hm)*segL;\n        opticalDepthR += _hr;\n        opticalDepthM += _hm;\n        vec3 lRay = L;//normalize((SUNDIST*L)-X);\n        float tlmin = 0.0;\n        float tlmax = 0.0;\n        float tlemin, tlemax;\n        vec3 Ll = normalize(Lpos-X);\n        float dl = IntersectSphere(X, Ll, EARTHPOS, ATMOSPHERERADIUS, tlmin, tlmax);\n    \t//float dle = IntersectSphere(ro, rd, EARTHPOS, EARTHRADIUS, tlemin, tlemax);\n    \n        //tlmax = min(tlmax, tlemin);\n        //tlmin = min(tlmin, tlemin);\n        \n        float tCurrentLight = 0.;//max(0., tlmin);\n        float segLLight = (tlmax-tCurrentLight)/8.0;\n        tCurrentLight = max(0., tlmin);\n        segLLight = (tlmax-tCurrentLight)/8.;\n        float opticalDepthLightR = 0.0;\n        float opticalDepthLightM = 0.0;\n        bool ended = true;\n        for (int j = 0; j < 8; ++j)\n        {\n            vec3 samplePositionLight = X+L*(tCurrentLight + 0.5 * segLLight);\n            float hLight = length(samplePositionLight) - EARTHRADIUS;\n            if (hLight < 0.0)\n            {\n                ended = false;\n                break;\n            }\n            opticalDepthLightR += exp(-hLight / hr) * segLLight;\n            opticalDepthLightM += exp(-hLight / hm) * segLLight;\n            tCurrentLight += segLLight;\n        }\n        if (ended)\n        {\n            vec3 tau = betaR * (opticalDepthR + opticalDepthLightR) + betaM * 1.1 * (opticalDepthM + opticalDepthLightM);\n            vec3 attenuation = vec3(exp(-tau.x), exp(-tau.y), exp(-tau.z));\n            sumR += _hr * attenuation;\n            sumM += _hm * attenuation;\n        }\n        tCurrent += segL;\n    }\n    miecolor = SUNINTENSITY * sumM * phaseM;\n    return SUNINTENSITY * (sumR * phaseR * betaR + sumM * phaseM * betaM);\n}\n\nvec3 getSun(vec3 V, vec3 L, vec3 lColor, vec3 mieColor)\n{\n    float VoL = 0.1+dot(-V, L);\n    VoL = max(0., VoL*VoL-0.215);\n    return pow(VoL, 1024.)*lColor*mieColor;\n}\n\nvoid Store(in vec4 what, vec2 currentCoord, vec2 coord, inout vec4 where)\n{\n    if(abs(currentCoord.x-coord.x)<0.5 && abs(currentCoord.y-coord.y)<0.5)\n    \twhere = what;\n}\n\nvec4 Read(sampler2D buffer, ivec2 coord)\n{\n    return texelFetch(buffer, coord, 0);\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4sfGRn","filepath":"/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","previewfilepath":"/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"/***********************************************************************\n * author: pierre.plans@gmail.com\n ***********************************************************************/\n\n#define TIME (iTime+1.0)*0.5\n\n#define saturate(X) clamp(X, 0.0, 1.0)\n\n#define PI 3.1415\n#define _2PI 3.2830\n\n#define RAYMARCHING_NUM_STEPS 1\n\n//vec3 lPos = TARGETPOS;\nvec3 lPos = vec3(0.0, 0.0, 10.0);\nvec3 lColor = vec3(1., 1., 1.);\n\n/************************\n * RENDERING\n ************************/\n\n// https://www.shadertoy.com/view/lstSRS\nvec3 tonemapping(vec3 color)\n{\n    //Tonemapping and color grading\n    color = pow(color, vec3(1.5));\n    color = color / (1.0 + color);\n    color = pow(color, vec3(1.0 / 1.5));\n\n    \n    color = mix(color, color * color * (3.0 - 2.0 * color), vec3(1.0));\n    color = pow(color, vec3(1.3, 1.20, 1.0));    \n\n\tcolor = clamp(color * 1.01, 0.0, 1.0);\n    \n    color = pow(color, vec3(0.7 / 2.2));\n    return color;\n}\n\nfloat phaseHenyeyGreenstein(float g, float cosTeta)\n{\n    return (1.-g*g)/(4.*3.14*pow(1.+g*g-2.*g*cosTeta, 1.5))\n        //+g*(1.+cosTeta)*.5 // from http://www.csroc.org.tw/journal/JOC25-3/JOC25-3-2.pdf\n        ;\n}\n\nfloat heightSignal(float a, float x, float h)\n{\n    return (x-a)*(x-a-h)*(-4./(h*h));\n}\n\nfloat remap01(float x, float _oldmin, float _oldmax)\n{\n \treturn clamp((x-_oldmin)/(_oldmax-_oldmin), .0, 1.);\n}\n\nfloat density(vec3 P, vec3 c)\n{\n    #ifdef USE_TEXTURE_MAP\n    \t#if !defined(CLOUDS_FIXED_POS)\n    \tP.xz -= 1e3*iTime;\n    \t#endif\n    \tfloat f = 0.5/(CLOUDEND-CLOUDSTART);\n    \n    \tfloat Tpart = iTime*.1;\n    \n    \tfloat nPy = (length(P-EARTHPOS)-CLOUDSTART)/(CLOUDEND-CLOUDSTART);\n\n    \tfloat details = remap01(fbm3D(8.*f*P+4.*Tpart, 0.), .0, 0.4);\n    \tfloat details2 = remap01(fbm3D(10.*f*P+4.*Tpart, 0.), .0, 0.4);\n    \n    \tfloat base = texture(iChannel1, .08*(P.xz+Tpart)*f).r;\n    \tfloat base2 = remap01(pow(base, 2.), .01, 1.0);\n    \n    \tbase2 = remap01(base2, .1, 1.0);\n    \n        float mainForm = 2.*remap01(voronoi3D(4.*f*P), 0.0, 1.0);\n    \n    \tfloat HS = clamp(nPy*nPy*heightSignal(.0, nPy, (base2+2.+sin(Tpart))*base2), 0., 1.);\n    \n        float den = (base2*(1.-mainForm*details2)-clamp(.4*(1.-mainForm)*details, 0., 1.))*HS;\n    #else\n        float f = 1.;\n        float mainForm = max(0.0, (1.-voronoi3D(1.*f*P)));\n        float mainForm2 = max(0.0, (1.-voronoi3D(4.*f*P)));\n        float den = (mainForm+mainForm2*fbm3Dsimple(10.*f*P));\n        den *= max(0., heightSignal(1.5, P.y, 3.5));\n    #endif\n\treturn clamp(TARGETDENSITYSCALE * den, 0., 1.);\n}\n\nfloat BeersPowder(float den, float dist, float extinction)\n{\n    float b = exp(-den*dist*extinction);\n    //return b;\n    float p = (1.-b);\n    return b*p;\n}\n\nvec4 raymarchGas(vec3 ro, vec3 rd,\n                  in float tmin, in float tmax,\n                  in vec2 uv,\n                  in vec3 Lp,\n                  in vec3 Lcolor,\n                  out float blendAlpha)\n{\n    if(tmax<0. || tmin<0.) return vec4(1., 0., 0., 0.);\n    float maxTargetTravel = tmax-tmin;\n    float cStep = 0.08;\n    float vStep = maxTargetTravel*cStep;\n    vec3 totalRadiance = vec3(0.);\n    float Tr = 1.;\n    float screenShift = 1.0*hash2D(rd.xy+fract(iTime));\n    tmin -= vStep*screenShift;\n    float d = tmin;\n    #if defined(USE_SKY) && defined(CLOUDS_RAYMARCH_MIE)\n    vec3 miec;\n    vec3 Pa = ro+rd*tmax;\n    Lcolor = getSkyLight(Pa, RotXV3(normalize(Lp-Pa), 90.*(-1.+2.*hash2D(10.*uv+fract(iTime)))), Lp, SKY_BETA_RAY, SKY_BETA_MIE, miec, SKY_MIE_HEIGHT);\n    Lcolor = miec;\n    #endif\n    for(d=tmin; d<tmax; d+=vStep)\n\t{\n        vec3 P = ro+rd*d;        \n        vec3 L = normalize(Lp-P);\n        // map\n        #ifdef USE_TEXTURE_MAP\n        float map = 1.;\n        #else\n        float map = max(0., length(P-TARGETPOS)); // not 1-x, magic\n        #endif\n        // density\n        float den = map*density(P, TARGETPOS);\n        if(den>0.)\n        {\n            float sumLuminance = 0.;\n            float transmittance = 1.;\n            float phase = 0.;\n            {\n            \tfloat mu = dot(rd, L);\n                float cosAngle = 0., g = 0.;\n                cosAngle = mu; g = mix(-.30, .50, .5);//.5*(1.+cosAngle));\n                phase = mix(phaseHenyeyGreenstein(-.2, mu), phaseHenyeyGreenstein(.8, mu), .5);\n            }\n            sumLuminance += phase * transmittance;\n            float accDensity = 0., accLength = 0.;\n            #ifdef USE_TEXTURE_MAP\n            float stepL = (CLOUDEND-CLOUDSTART)*0.01;\n            #else\n            float stepL = 0.1;\n            #endif\n            for(int i = 0;i < 4; ++i)\n            {\n                vec3 Pl = P+L*float(i)*stepL;\n        \t\t#ifdef USE_TEXTURE_MAP\n                \tfloat lmap = 1.0;\n                #else\n                \tfloat lmap = max(0., TARGETSIZE-length(Pl-TARGETPOS))/TARGETSIZE;\n                #endif\n                float det = lmap*density(Pl, TARGETPOS);\n\n                #ifdef USE_TEXTURE_MAP\n                transmittance *= BeersPowder(det, stepL, 1.);\n                #else\n                transmittance *= exp(-det*float(i)*stepL);\n                accDensity += det;\n                accLength += float(i)*stepL;\n                #endif\n                stepL *= 1.6;\n                if(transmittance<=0.05) break;\n            }\n            #ifdef USE_TEXTURE_MAP\n            // Use computed transmittance for the shadowing, then overwrite it to compute the proper\n            // transmittance\n            sumLuminance = phase * SUNINTENSITY * transmittance;\n            //\n            transmittance = BeersPowder(den, vStep, 1.);\n            #else\n            sumLuminance = phase * SUNINTENSITY * exp(-accDensity*accLength);\n            #endif\n            float nPy = length(P-EARTHPOS);\n            float amb = mix(0.05, 0.2, remap01(nPy, CLOUDSTART, CLOUDEND));\n            vec3 radiance = (amb + sumLuminance*Lcolor)*den;\n            // scattering\n            totalRadiance += Tr * (radiance-transmittance*radiance) / den;\n            Tr *= transmittance;\n            if(Tr<=0.05) break;\n            vStep = maxTargetTravel*cStep*.5;\n        }\n        else\n           vStep = maxTargetTravel*cStep;\n\t}\n    {\n        vec3 Pmax = ro+rd*(tmax-screenShift);\n        float mu = dot(rd, normalize(Lp-Pmax));\n        //d = 1.;\n        float phase = 0.;\n        {\n            float cosAngle = 0., g = 0.;\n            cosAngle = mu; g = mix(-.30, .50, 0.5);\n            phase = phaseHenyeyGreenstein(g, cosAngle);\n        }\n        vec2 P2d = 0.5*(Pmax.xz/Pmax.y);\n        P2d.y = 1.-P2d.y;\n        float tex = remap01(texture(iChannel3, 100.1*P2d\n    \t#if !defined(CLOUDS_FIXED_POS)\n                                    +.001*iTime\n    \t#endif\n                                   ).r, .4, 1.);\n        tex = pow(tex, 1.);\n        float mainForm = clamp(tex*tex*(3.-2.*tex), 0., 1.);\n        float den = max(0., mainForm-.2*fbm_hash(20.*P2d+iTime));\n        if(den>0.)\n        {\n            float transmittance = BeersPowder(den, 2., 1.);\n            float lum = phase * transmittance;\n            vec3 radiance = (0.08+lum*Lcolor)*den;\n            totalRadiance += Tr * (radiance-transmittance*radiance) / den;\n            Tr *= transmittance;\n        }\n    }   \n    float rdy = remap01(tmin, 1e5, 6e5);\n    rdy = 1.-(exp(-8.*rdy));\n    \n    blendAlpha = clamp(rdy, 0., 1.);\n\treturn vec4(Tr, totalRadiance);\n}\n\n// SEA\n\nfloat waves(vec3 p, vec3 up, float t)\n{\n    float steepness = SEA_CHOP;\n    float speed = SEA_SPEED;\n    float waveDiv = 1.;\n    float depth = length(p);\n    vec2 wind = vec2(1., 0.);\n    float amp = SEA_AMP;\n    for(int i = 0; i < SEA_WAVES; ++i)\n    {\n        depth += amp*pow(fbm_hash(p.xz+wind*speed*t), steepness);\n        depth += amp*pow(fbm_hash(p.xz-wind*speed*t), steepness);\n        \n        speed *= 0.6;\n        steepness = mix(steepness, 1., .2);\n        amp *= 1.8;\n        #ifdef WINDROLL_PER_WAVE\n        wind = mat2(0.4, 0.8, -0.7, 0.2)*wind;\n        #endif\n    }\n    return depth;\n}\n\nfloat mapSea(vec3 P, vec3 up)\n{\n    P-=EARTHPOS;\n    float b = length(P)-EARTHRADIUS;\n\n    b += waves(0.001*P, up, iTime);\n    \n    return b;\n}\n\nvec3 normalSea(vec3 P, vec3 up, vec3 tgt, float e)\n{\n \tvec3 n;\n    vec3 t1 = cross(up, tgt);\n    n.y = mapSea(P+up*e, up);\n    n.x = mapSea(P+t1*e, up) - n.y;\n    n.z = mapSea(P+tgt*e, up) - n.y;\n    n.y = e;\n    n = up*n.y + t1*n.x + tgt*n.z;\n    return normalize(n);\n}\n\nfloat Fresnel_Schlick(float n1, float n2, float NdotV)\n{\n    float R0 = (n1-n2)/(n1+n2);\n    R0 *= R0;\n    float OMNdotV4 = 1.-NdotV; OMNdotV4 *= OMNdotV4; OMNdotV4 *= OMNdotV4;\n    return R0+(1.0-R0)*(1.0-NdotV)*OMNdotV4;\n}\n\n\n// https://hal.inria.fr/inria-00443630v2/document\n// began exploring this, but may simplify a lot\nvec3 procU(vec2 c, vec3 v, vec3 tx, vec3 ty, vec3 N)\n{\n    vec3 f = normalize(vec3(-c.x, 1., -c.y));\n    f = f.x*tx+f.y*N+f.z*ty;\n    vec3 r = 2.*dot(f, v)*f-v;\n    return r; // we won't sample a texture here, we'll raymarch the sky\n}\n\nfloat erfc(float t)\n{\n \treturn (2./PI)*exp(-t*t);\n}\nfloat alpha(float a)\n{\n    float sqrtPI = sqrt(PI);\n \treturn (exp(-a*a)-a*sqrtPI*erfc(a))/(2.*a*sqrtPI);\n}\nfloat oceanLightingSun(vec3 V, vec3 L, vec3 N, vec3 tx, vec3 ty, float ox, float oy)\n{\n    // override N\n    if (dot(V, N) < 0.0) {\n        N = reflect(N, V); // reflects backfacing normals\n    }\n\n    vec3 H = normalize(V+L);\n    vec3 Ns = vec3(0., 1., 0.);\n    vec2 ChiH = -vec2(dot(H, tx), dot(H, ty))/dot(H, N);\n    float VoN = dot(V, N);\n    float LoN = dot(L, N);\n    float HoN = dot(H, N);\n    float cosTetaV = dot(V, Ns);\n    float cosTetaL = dot(L, Ns);\n    float tetaV = acos(cosTetaV);\n    float tetaL = acos(cosTetaL);\n    float phiV = atan(dot(V, ty), dot(V, tx));\n    float phiL = atan(dot(L, ty), dot(L, tx));\n    float cosPhiV = cos(phiV);\n    float sinPhiV = sin(phiV);\n    float cosPhiL = cos(phiL);\n    float sinPhiL = sin(phiL);\n    \n    // paper interpretation\n    // float mu_v = pow(2.*(ox*ox*cosPhiV*cosPhiV+oy*oy*sinPhiV*sinPhiV)*tan(tetaV),-0.5);\n    // float mu_l = pow(2.*(ox*ox*cosPhiL*cosPhiL+oy*oy*sinPhiL*sinPhiL)*tan(tetaL),-0.5);\n    // paper source\n    float mu_v = cosPhiV/sqrt((1.-cosPhiV*cosPhiV)*(2.*ox*ox));\n    float mu_l = cosPhiL/sqrt((1.-cosPhiL*cosPhiL)*(2.*oy*oy));\n    \n    float F = 0.033+0.967*pow(1.-dot(V,H), 5.);//Fresnel_Schlick(1.033, 1., dot(V, H));\n    \n    float P = exp(-.5*((ChiH.x*ChiH.x/ox*ox)+(ChiH.y*ChiH.y/oy*oy)))/(2.*PI*sqrt(ox*oy));\n    \n    // paper interpretation\n    //float res = 4.*pow(dot(H,N), 4.)*max(0., cosTetaV)\n    //    *(1.+max(0., alpha(mu_v))+max(0., alpha(mu_l)));\n    // res = (P*F)/res;\n    // paper source\n    float res = F * P / (\n        (1.0 + max(0., alpha(mu_l)) + max(0., alpha(mu_v)))\n                              * max(0., VoN) * HoN*HoN * HoN*HoN * 4.0);\n    return res;\n}\n\nvec3 oceanLighting(vec3 V, vec3 rd, vec3 L, vec3 N, vec3 tx, vec3 ty, float ox, float oy)\n{\n    vec3 H = normalize(V+L);\n    vec2 ChiH = -vec2(dot(H, tx), dot(H, ty))/dot(H, N);\n    float VoN = dot(rd, N);\n    float LoN = dot(L, N);\n    float tetaV = atan(dot(V, ty), dot(V, tx));\n    float tetaL = atan(dot(L, ty), dot(L, tx));\n    float cosTetaV = cos(tetaV);\n    float sinTetaV = sin(tetaV);\n    float mu_v = pow(ox*ox*cosTetaV*cosTetaV+oy*oy*sinTetaV*sinTetaV,0.5);\n    \n    float F = Fresnel_Schlick(1.033, 1., cosTetaV);\n    //float R = (1.033-1.)/(1.044+1.); R = R*R;\n    //float FtetaV = R+(1.-R)*pow((1.-cosTetaV)*(1.-cosTetaV)*(1.-cosTetaV)*(1.-cosTetaV)*(1.-cosTetaV), -2.69*oy)/(1.+22.7*pow(mu_v, 1.5));\n    \n    vec3 u0 = procU(vec2(0., 0.), -V, tx, ty, N);\n    float e = 0.001;\n    vec3 dUx = 2.*ox*(procU(vec2(e, 0.), -V, tx, ty, N)-u0)/e;\n    vec3 dUy = 2.*oy*(procU(vec2(0., e), -V, tx, ty, N)-u0)/e;\n   \n    float qvn = max(0., dot(rd, L))/(cosTetaV*(1.+max(0., mu_v)));\n    \n    vec3 IrradianceSun = vec3(max(0., (qvn*F)/(4.*pow(dot(H,N), 4.))));\n    \n    return IrradianceSun;\n}\n\nvec3 oceanLighting(vec3 ro, vec3 rd, vec3 Lo, vec3 P, vec3 N, vec3 tx, vec3 ty)\n{\n    vec3 V = -rd;\n    vec3 L = normalize(Lo-P);\n    vec3 H = normalize(rd+L);\n    float VoL = dot(-V, L);\n    float ox = hash3D(tx), oy = hash3D(ty);\n    vec3 mieColor;\n    vec3 rrd = reflect(rd, vec3(0., 1., 0.));\n    vec3 skycolor = getSkyLight(P, rrd, Lo, SKY_BETA_RAY, SKY_BETA_MIE, mieColor, SKY_MIE_HEIGHT);\n    vec3 suncolor = getSun(-rrd, L, vec3(1.), mieColor);\n    //skycolor += suncolor;\n    float phiV = atan(dot(V, ty), dot(V, tx));\n    float phiL = atan(dot(L, ty), dot(L, tx));\n    float cosPhiV = cos(phiV);\n    float sinPhiV = sin(phiV);\n    float cosPhiL = cos(phiL);\n    float sinPhiL = sin(phiL);\n    float micro_v = pow(ox*ox*cosPhiV*cosPhiV+oy*oy*sinPhiV*sinPhiV,0.5);\n    float F = //Fresnel_Schlick(1.033, 1., dot(V, N));\n        0.03+0.967*pow(1.-dot(V, N), 5.*exp(-2.69*micro_v))/(1.+22.6*pow(micro_v, 1.5));\n    \n    vec3 IrradianceSun = mieColor*VoL*oceanLightingSun(V, L, N, tx, ty, ox, oy);//mieColor*F/(4.*pow(dot(H, N), 4.));\n    vec3 IrradianceSky = F*skycolor;\n    vec3 IrradianceSea = (1.-F)*.33*vec3(0.02, 0.25, 0.45);\n    \n    return VoL>0.?IrradianceSun:0.+\n        IrradianceSky +\n        IrradianceSea;\n}\n\nvec4 raymarchSea(vec3 ro, vec3 rd, vec3 up, vec3 fwd, in mat3 cam,\n                  in float tmin, in float tmax,\n                  in vec3 Lo,\n                  in vec3 Lcolor)\n{\n    if(tmax<0. || tmin<0.) return vec4(1., 0., 0., 0.);\n    float maxTargetTravel = tmax-tmin;\n    float cStep = 0.08;\n    float vStep = maxTargetTravel*cStep;\n\n    float t = 0.;\n    if((length(ro+rd*tmin-EARTHPOS)-EARTHRADIUS)<tmin)\n        return vec4(1., 0., 0., 1.);\n    for(int i = 0;i<60;++i)\n    {\n        vec3 p = ro+rd*t;\n        float depth = mapSea(p, up);\n        if(depth<tmin || t>tmax) break;\n        t += 0.5*depth;\n    }\n\n    float rdy = clamp((tmax-t)/(tmax-tmin), 0., 1.);\n    \n    rdy = exp(-10.*(t-tmin)/(tmax-tmin));\n    \n    vec4 c = vec4(1., 0., 0., clamp(rdy*rdy, 0., 1.));\n    \n    // lighting\n    #if 1\n    vec3 Pw = ro+rd*t;\n    vec3 Nw = normalSea(Pw, up, fwd, 0.01);\n    vec3 Lw = normalize(Lo-Pw);\n    #if 0\n    float tsmin = -1.0, tsmax = -1.0;\n    float de = IntersectSphere(\n        ro, rd, Lp, SUNRADIUS,\n        tsmin, tsmax);\n    vec3 H = normalize(-rd+normalize((ro+rd*tsmin)-Pw));\n    #else\n    vec3 H = normalize(-rd+Lw);\n    #endif\n    float NoL = dot(Nw, Lw);\n    float NoV = dot(Nw, -rd);\n    \n    float HoN = max(0., dot(H, Nw));\n    float F = clamp(Fresnel_Schlick(1., 1.033, NoV), 0., 1.);\n    \n    vec3 diffuse = mix(vec3(0.02, 0.25, 0.45), vec3(0.46, 0.71, 0.76), F);\n    \n    c.rgb = SUNINTENSITY * (\n        diffuse*max(0., NoL)\n        + diffuse*.2*max(0., dot(Nw, up))\n        + Lcolor * pow(max(0., HoN), 64.)\n        );\n    c.a *= F;\n    #else\n        vec3 Pw = ro+rd*t;\n        vec3 Nw = normalSea(Pw, up, fwd, 0.01);\n    \tc.rgb = oceanLighting(ro, rd, Lo, Pw, Nw, fwd, cross(fwd, up));\n    //vec3 pouet;\n    //c.rgb = getSkyLight(Pw, reflect(rd, vec3(0., 1., 0.)), Lo, SKY_BETA_RAY, SKY_BETA_MIE, pouet, SKY_MIE_HEIGHT);\n    #endif\n    \n\treturn c;\n}\n\nvec3 rendering(vec3 ro, vec3 rd, vec2 uv, vec2 muv, mat3 cam)\n{\n    float T = 0.2*iTime;\n    vec3 color = vec3(0.0);\n    \n    #ifdef USE_TEXTURE_MAP\n    vec3 ero = ro+vec3(0.0, EARTHRADIUS+0.01*(ATMOSPHERERADIUS-EARTHRADIUS), 0.0);\n    vec3 cro = ero;\n    vec3 aro = ero;\n    lPos = vec3(0.0, sin(muv.y*2.), cos(2.0*muv.y))*SUNDIST;\n    vec3 elPos = lPos;\n    #else\n    vec3 ero = ro;\n    vec3 cro = ero+vec3(0.0, EARTHRADIUS, 0.0);\n    vec3 aro = ero+vec3(0.0, EARTHRADIUS+0.10*(ATMOSPHERERADIUS-EARTHRADIUS), 0.0);\n    lPos = vec3(0.0, sin(muv.y), cos(2.0*muv.y))*10.;\n    vec3 elPos = SUNDIST*normalize(lPos-ro);\n    #endif\n    \n    float tmin = -1.0, tmax = -1.0;\n    float d = IntersectSphere(\n        ero, rd,\n        #ifdef USE_TEXTURE_MAP\n        EARTHPOS, CLOUDEND,\n        #else\n        TARGETPOS,TARGETSIZE+2.5,\n        #endif\n        tmin, tmax);\n    vec3 mieColor = vec3(1.0);\n    #ifdef USE_TEXTURE_MAP\n    float tmmin = -1.0, tmmax = -1.0;\n    float dm = IntersectSphere(\n        ero, rd,\n        EARTHPOS, CLOUDSTART,\n        tmmin, tmmax);\n    tmin = max(0.01, min(max(tmax, tmin), max(tmmin, tmmax)));\n    tmax = max(max(tmax, tmin), max(tmmin, tmmax));\n    float tmp = max(tmin, tmax);\n    tmin = max(0.001, min(tmin, tmax));\n    tmax = tmp;\n    #endif\n    \n    #ifdef USE_SKY\n    vec3 skycolor = getSkyLight(aro, rd, elPos, SKY_BETA_RAY, SKY_BETA_MIE, mieColor, SKY_MIE_HEIGHT);\n    \n    float temin = -1.0, temax = -1.0;\n    float de = IntersectSphere(\n        cro, rd, EARTHPOS, EARTHRADIUS,\n        temin, temax);\n    color += vec3(0.05, 0.125, .2)*((de==0.)?1.:0.);\n    float tetmp = max(temax, temin);\n    temin = max(0.01, min(temax, temin));\n    temax = tetmp;\n    //lColor = betaR*1e6;\n    #else\n    vec3 skycolor = texture(iChannel0, rd).rgb;\n    #endif\n \tcolor += skycolor;\n    #ifdef USE_SKY\n    if(temax<0.)\n    #endif\n    {\n        #ifdef USE_TEXTURE_MAP\n        float far = tmax, near = tmin;\n        #else\n        float far = min(tmax, 50.), near = max(0.01, tmin);\n        #endif\n    \tfloat blendAlpha = 0.;\n        vec4 c = raymarchGas(ero, rd, near, far, uv, lPos, mieColor, blendAlpha);\n        \n        #ifdef USE_SKY\n    \tc.yzw = mix(c.yzw, skycolor, blendAlpha);\n        c.x = clamp(mix(c.x, 1., blendAlpha), 0., 1.);\n        #endif\n    \tcolor += getSun(-rd, normalize(lPos-ero), lColor, mieColor);\n        color = c.x*color;\n        color += (1.-blendAlpha)*c.yzw;\n    }\n    #ifdef USE_SKY\n    if(temin>0.)\n    {\n        // sea\n        float blendAlpha = 0.;\n        vec4 s = raymarchSea(cro, rd, cam*vec3(0., 1., 0.), cam*vec3(0., 0., 1.), cam, 0.01, temax, lPos, mieColor);\n\n        color += s.rgb * s.a;\n    }\n    #endif\n    \n    return tonemapping(max(vec3(0.0), color));\n}\n\nvec3 GetCameraSetup(vec2 uv, vec2 muv, inout vec3 ro, inout vec3 rd, inout mat3 m)\n{\n    vec2 pixel = -1.0 + 2.0*uv;\n    vec3 rdo;\n    \n    ro = CAMPOS;\n    rd = vec3(0.0);\n    \n    ro = RotYV3(ro, muv.x*3.14);\n    \n    m = GetCamera(pixel, TARGETPOS, ro, rd, rdo);\n    return rdo;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy /iResolution.xy;\n    vec2 muv = -1.0+2.0*(iMouse.xy/iResolution.xy);\n    \n    mat3 oc = mat3(\n        \t\tRead(iChannel2, ivec2(0, 0)).xyz,\n        \t\tRead(iChannel2, ivec2(1, 0)).xyz,\n        \t\tRead(iChannel2, ivec2(2, 0)).xyz);\n    vec4 oiMv = Read(iChannel2, ivec2(3, 0));\n    if(length(oiMv)<0.1)\n    {\n        muv = vec2(0., 0.);\n        oiMv.xy = iResolution.xy*.5;\n    }\n    \n    vec3 ro, rd;\n    mat3 cam;\n    vec3 pixels = GetCameraSetup(uv, muv, ro, rd, cam);\n    \n    vec3 color = rendering(ro, rd, uv, muv, cam);\n    \n    // repro\n    vec3 ord = rd*oc;\n    vec2 ouv = .5*(1.+CAMDEPTH*ord.xy/ord.z);\n\n    if(ouv.x>=0. && ouv.x<=1. && ouv.y>=0. && ouv.y<=1.)\n    \tcolor = mix(color, texture(iChannel2, ouv).rgb, .95);\n    fragColor = vec4(color, 1.0);\n    //fragColor.rgb = length(oc[0]-cam[0])<0.001?vec3(1.):vec3(0.);\n    Store(vec4(cam[0], 0.), fragCoord, vec2(0.5, 0.5), fragColor);\n    Store(vec4(cam[1], 0.), fragCoord, vec2(1.5, 0.5), fragColor);\n    Store(vec4(cam[2], 0.), fragCoord, vec2(2.5, 0.5), fragColor);\n    Store(iMouse, fragCoord, vec2(3.5, 0.5), fragColor);\n}","name":"Buffer A","description":"","type":"buffer"}]}