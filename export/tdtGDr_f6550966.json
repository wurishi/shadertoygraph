{"ver":"0.1","info":{"id":"tdtGDr","date":"1568261441","viewed":131,"name":"Ray Marching thing","username":"Dogemaster09","description":"just a little test i did. i followed a tutorial by The Art Of Code, you should check out his channel! https://www.youtube.com/channel/UCcAlTqd9zID6aNX3TzwxJXg","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST 0.001\n\nfloat dot2( in vec3 v ) { return dot(v,v); }\n/*float udQuad( vec3 p, vec3 a, vec3 b, vec3 c, vec3 d )\n{\n    vec3 ba = b - a; vec3 pa = p - a;\n    vec3 cb = c - b; vec3 pb = p - b;\n    vec3 dc = d - c; vec3 pc = p - c;\n    vec3 ad = a - d; vec3 pd = p - d;\n    vec3 nor = cross( ba, ad );\n\n    return sqrt(\n    (sign(dot(cross(ba,nor),pa)) +\n     sign(dot(cross(cb,nor),pb)) +\n     sign(dot(cross(dc,nor),pc)) +\n     sign(dot(cross(ad,nor),pd))<3.0)\n     ?\n     min( min( min(\n     dot2(ba*clamp(dot(ba,pa)/dot2(ba),0.0,1.0)-pa),\n     dot2(cb*clamp(dot(cb,pb)/dot2(cb),0.0,1.0)-pb) ),\n     dot2(dc*clamp(dot(dc,pc)/dot2(dc),0.0,1.0)-pc) ),\n     dot2(ad*clamp(dot(ad,pd)/dot2(ad),0.0,1.0)-pd) )\n     :\n     dot(nor,pa)*dot(nor,pa)/dot2(nor) );\n}\n*/\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r) {\n\tvec3 ab = b-a;\n    vec3 ap = p-a;\n    \n    float t = dot(ab, ap) / dot(ab, ab);\n    t = clamp(t, 0., 1.);\n    \n    vec3 c = a + t*ab;\n    return length(p-c)-r;\n}\n\nfloat sdCylinder(vec3 p, vec3 a, vec3 b, float r) {\n\tvec3 ab = b-a;\n    vec3 ap = p-a;\n    \n    float t = dot(ab, ap) / dot(ab, ab);\n    //t = clamp(t, 0., 1.);\n    \n    vec3 c = a + t*ab;\n    float x = length(p-c)-r;\n    float y = (abs(t-.5)-.5)*length(ab);\n    float e = length(max(vec2(x, y), 0.));\n    float i = min(max(x, y), 0.);\n    return e+i;\n}\n\nfloat sdTorus(vec3 p, vec2 r) {\n\tfloat x = length(p.xz)-r.x;\n    return length(vec2(x, p.y))-r.y;\n}\n\nfloat dBox (vec3 p, vec3 s) {\n\treturn length(max(abs(p)-s, 0.));\n}\n\nfloat dPlane (vec3 p, vec4 n) {\n    return dot(p,n.xyz) + n.w;\n\t//return ((p.x*p2.x)-p3.x)+((p.y*p2.y)-p3.y)+((p.z*p2.z)-p3.z);\n}\n\nfloat GetDist(vec3 p) {\n\tvec4 s = vec4(0, 1, 6, 1);\n    \n    float sphereDist = length(p-s.xyz)-s.w;\n    float pd = dPlane(p, normalize(vec4(0, 1, 0, 0)));\n    //float qd = udQuad(p, vec3(-0.7, 2, 1), vec3(-0.7, 2.4, 1), vec3(-0.8, 2.4, 1), vec3(-0.8, 2, 1));\n    //float pd = p.y2\n    float cd = sdCapsule(p, vec3(0, 1.2, 5), vec3(0, 2.6, 7), .5);\n    float td = sdTorus(p-vec3(0,.3,6), vec2(1.5, .3));\n    float bd = dBox(p-vec3(-2.5, .5, 6), vec3(.5));\n    float cyld = sdCylinder(p, vec3(0, 0.3, 3), vec3(3, 0.3, 5), .3);\n    float d = min(cd, pd);\n    d = min(d, td);\n    d = min(d, bd);\n    d = min(d, cyld);\n    //d = min(d, qd);\n    return d;\n}\n\n\n\nvec2 RayMarch(vec3 ro, vec3 rd) {\n\tfloat dO=0.;\n    float res = 1.;\n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = GetDist(p);\n        res = min(res, dS/dO);\n        dO += dS;\n        if (dO>MAX_DIST || dS<SURF_DIST) break;\n    }\n    return vec2(dO, res);\n}\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    vec2 e = vec2(.01, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    return normalize(n);\n}\n\nfloat GetLight(vec3 p) {\n\tvec3 lightPos = vec3(0, 5, 6);\n    lightPos.xz += vec2(sin(iTime), cos(iTime))*2.;\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    \n    float dif = clamp(dot(n, l), 0., 1.);\n    vec2 d = RayMarch(p+n*SURF_DIST*2., l);\n    if(d.x<length(lightPos-p)) {\n    \tdif *= .2;\n    }\n    else {\n    \t//dif = d.y;\n    }\n    return dif;\n    //return d.y;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n\n    vec3 col = vec3(0);\n    \n    vec2 mouse = iMouse.xy/iResolution.xy;\n    mouse.y = mouse.y*2.+1.;\n    mouse.x = mouse.x*2.-2.;\n    \n    vec3 ro = vec3(mouse.x,mouse.y,0);\n    vec3 rd = normalize(vec3(uv.x+.2, uv.y+-0.2, 1));\n    \n    vec2 d = RayMarch(ro, rd);\n    \n    vec3 p = ro + rd * d.x;\n    \n    float dif = GetLight(p);\n\tcol = vec3(dif);\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}