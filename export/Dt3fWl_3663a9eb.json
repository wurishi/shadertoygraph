{"ver":"0.1","info":{"id":"Dt3fWl","date":"1701704159","viewed":34,"name":"Sure, but can we fractal? 2","username":"joteakus","description":"I mean it isn't terrible right","likes":1,"published":3,"flags":32,"usePreview":0,"tags":["raytracing","raymarching","pathtracing"],"hasliked":0,"parentid":"dldBR7","parentname":"Another more better pathtracer"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"int s = 3;\n\nvec3 sample_texture(vec2 p){\n    vec4 temp = texture(iChannel0, p/iResolution.xy);\n    return temp.xyz/temp.w;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if(iFrame <= -1){\n        fragColor = postprocess(vec4(sample_texture(fragCoord), 0.));\n    }else{\n        vec3 total = vec3(0.);\n        float max_magnitude = 1.+length(vec2(s));\n        float magnitude_total = 0.;\n        for(int x = -s; x <= s; x++){\n            for(int y = -s; y <= s; y++){\n                vec3 temp = (max_magnitude-length(vec2(x, y)))*sample_texture(fragCoord+vec2(x, y));\n                magnitude_total += max_magnitude-length(vec2(x,y));\n                total += temp*length(temp)*0.02;\n            }\n        }\n        fragColor = postprocess(vec4(sample_texture(fragCoord)+total/magnitude_total, 0.)); \n    }\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"Ray ray;\n\nfloat sde;\nfloat intersect_result;\nvec2 uv;\nvec2 uv2;\nvec3 col;\nconst vec3 sky_col = vec3(0.);\n\n//settings\nconst int bounces = 2;\nconst int pass_per_frame = 1;\nconst vec3 camera = vec3(0., 0., -16.);\n\nconst bool ambient_light_enabled = true;\nconst bool use_three_light_model = false;\n\nvoid intersect(float max_len){\n    sde = inf;\n    steps = 0;\n    //ray.pos += ray.dir*eps;\n    while(sde > eps || ray.len < max_len){\n        sde = get_scene_distance(ray.pos, false);\n        if(sde > eps && ray.len < max_len){\n            ray.pos += ray.dir*sde;\n            ray.len += sde;\n        }else{\n            intersect_result = (sde <= eps) ? HIT : MISS;\n            break;\n        }\n    }\n}\n\nvec3 apply_light(vec3 light_dir, vec3 light_col, bool ambient){\n\n    vec3 n_dir = normalize(light_dir);\n    vec3 fresnel1 = (scene_surface == matte) ? scene_col : vec3(0.5);\n    \n    vec3 half_not_illegal = normalize(n_dir-ray.dir);\n    float diffuse = max(0., dot(n_dir, normal));\n    \n    float specular = 0.;//(1.-scene_roughness)*pow(clamp(dot(n_dir,reflect(ray.dir, normal)),0.,1.),10.*(1.-scene_roughness));\n    vec3  fresnel = fresnel1 + (1.-fresnel1)*pow(clamp(1.-dot(half_not_illegal,n_dir),0.,1.),50.);\n    \n    \n    float shadow_strength = 1.;\n    if(diffuse >= 0. && !ambient){\n        float d = length(light_dir);\n        Ray ray2 = ray;\n        ray.dir = n_dir;\n        ray.len = 0.;\n        intersect(d);\n        shadow_strength = (intersect_result == HIT) ? 0. : 1.;\n        ray = ray2;\n    }else{\n        shadow_strength = 1.;\n    }\n    vec3 back = vec3(0.);\n    if(scene_surface == matte){\n        back += diffuse/**shadow_strength*/*scene_col*light_col;\n        back += diffuse/**shadow_strength*/*light_col*fresnel*(1.+specular);\n    }else if(scene_surface == metal){\n        back += diffuse/**shadow_strength*/*light_col*fresnel*(1.+specular);\n    }else{\n        \n    }\n    back *= shadow_strength;\n    return back;\n\n}\n\nvec3 apply_lighting(){\n\n    vec3 temp = vec3(0.);\n    float distance_to_center = hash13(cross(ray.pos, ray.dir)*2.3+iTime*500.);\n    vec3 offset = random_equal_vec3(cross(ray.pos, ray.dir)*(iTime+500.));\n    //temp += apply_light(normalize((distance_to_center*offset+vec3(100., 1000., 0.))-ray.pos), vec3(5., 5., 2.5)); \n    //temp += apply_light(normalize(vec3(-1., 10., 0.)), vec3(1., 1., 3.)); \n    temp += apply_light((0.75*offset+vec3(0., 4.23, -4.23)-ray.pos), vec3(5., 5., 3.), false); \n    temp += apply_light((0.5*offset+camera-ray.pos), vec3(1., 1., 1.), false); \n    if(ambient_light_enabled){\n        temp += apply_light((normalize(offset)), vec3(0.5, 0.5, 0.5), true); \n    }\n    if(use_three_light_model){\n        temp += apply_light((distance_to_center*0.5*offset+vec3(-7., 9., -1.)-ray.pos), vec3(1., 1., 1.), false); \n        temp += apply_light((distance_to_center*0.5*offset+vec3(7., 9., -1.)-ray.pos), vec3(1., 1., 1.), false); \n    }\n    \n    return temp;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec3 total_color = vec3(0.);\n\n    for(int pass = 0; pass <= pass_per_frame; pass++){\n        uv = fragCoord/iResolution.xy;\n        uv2 = (uv-0.5)*2.;\n        uv2.x *= iResolution.x/iResolution.y;\n        vec2 uv_offset = (hash31(iTime*1234.5).xy/iResolution.xy)*2.;\n        vec2 uv3 = uv2+uv_offset;\n        col = vec3(0.);\n        vec3 ray_col = vec3(1.);\n        vec3 accumulated = vec3(0.);\n    \n        ray = Ray(camera, normalize(vec3(uv3, 2.)), 0.);\n        for(int i = 0; i <= bounces; i++){\n            intersect(max_t);\n            if(intersect_result == HIT){\n                get_scene_distance(ray.pos, true);\n                get_normal(ray.pos);\n                ray.pos += normal*eps;\n                //lighting goes here??? maybe???\n                vec3 scene_color2 = scene_col;\n                scene_col *= ray_col;\n                vec3 temp_col = apply_lighting();\n                ray_col *= scene_color2;\n                accumulated += temp_col;\n                //tint *= temp_col;\n                vec3 specular_dir = reflect(ray.dir, normal);\n                vec3 diffuse_dir = vec3_near(cross(ray.pos, ray.dir)*(iTime+500.), normal, 1.-scene_diffuse);\n                ray.dir = mix(specular_dir, diffuse_dir, scene_roughness);\n                ray.len = 0.;\n            }else{\n                accumulated += ray_col*vec3(0., 0., 0.);\n                break;\n            }\n        }\n    \n    \n        col = accumulated/float(bounces+1);\n        total_color += col;\n    }\n\n    vec4 total = texture(iChannel0, uv);\n    total += vec4(total_color, pass_per_frame);\n    if(iTime > 2.5){\n        fragColor = total;\n    }else{\n        fragColor = vec4(0.);\n    }\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"const float HIT = 1.;\nconst float MISS = 2.;\nconst float inf = 9999999.;\nconst float eps = 0.01;\nconst float max_t = 25.;\nconst int matte = 1;\nconst int metal = 2;\nint steps;\nfloat sde_v_1;\nfloat sde_v_2;\nvec3 normal;\n\nvec3 scene_col;\nfloat scene_diffuse;\nfloat scene_roughness;\nint scene_surface;\n\nconst float Power = 3.;\n\nvec4 postprocess(vec4 og){\n    vec4 temp = og;\n    temp *= 0.8;\n    temp = temp/(temp+1.);\n    temp = 1.1*(temp-0.5)+0.5-0.;\n    temp = pow(temp, vec4(1.5));\n    return temp;\n\n}\n\nstruct Ray{\n    vec3 pos;\n    vec3 dir;\n    float len;\n};\n\nvoid object(bool update_surface, float sde, vec3 col, float diffuse, float roughness, int surface_type){\n    if(sde <= sde_v_1){\n        sde_v_1 = sde;\n        if(update_surface){\n            scene_col = col;\n            scene_diffuse = diffuse;\n            scene_roughness = roughness;\n            scene_surface = surface_type;\n        }\n    }\n}\n\nfloat sphere(vec3 from, vec3 pos, float radius){\n    return distance(from, pos)-radius;\n}\n\nfloat plane(vec3 from, vec3 normal, float offset){\n    return(dot(normalize(normal), from)-offset);\n}\n\nfloat box(vec3 from, vec3 pos, vec3 dimensions)\n{\n  vec3 q = abs(from-pos) - dimensions;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat mandelbulb(vec3 pos, out int steps) {\n\tvec3 z = pos;\n\tfloat dr = 1.0;\n\tfloat r = 0.0;\n\tfor (int i = 0; i < 10 ; i++) {\n\t\tr = length(z);\n        steps = i;\n\t\tif (r>2.0) break;\n\t\t\n\t\t// convert to polar coordinates\n\t\tfloat theta = 0.1+acos(z.z/r);\n\t\tfloat phi = 0.78539816+atan(z.y,z.x);\n\t\tdr =  pow( r, Power-1.0)*Power*dr + 1.0;\n\t\t\n\t\t// scale and rotate the point\n\t\tfloat zr = pow( r,Power);\n\t\ttheta = theta*Power;\n\t\tphi = phi*Power;\n\t\t\n\t\t// convert back to cartesian coordinates\n\t\tz = zr*vec3(sin(theta)*cos(phi), sin(phi)*sin(theta), cos(theta));\n\t\tz+=pos;\n\t}\n\n\treturn 0.5*log(r)*r/dr;\n}\n\n\nfloat get_scene_distance(vec3 pos, bool colors){\n\n    sde_v_1 = inf;\n    object(colors,\n            mandelbulb(pos/2.5+vec3(0., 0.5, 0.), steps), \n            vec3(0.9), 0.4, 0.5, matte);\n            \n    object(colors,\n            box(pos, vec3(-5., 0., 0.), vec3(eps, 5.+eps, 5.+eps)), \n            vec3(0.1, 0.1, 0.9), 0.5, 0.5, matte);\n    object(colors,\n            box(pos, vec3(5., 0., 0.), vec3(eps, 5.+eps, 5.+eps)), \n            vec3(0.9, 0.1, 0.1), 0.5, 0.5, matte);\n    object(colors,\n            box(pos, vec3(0., -5., 0.), vec3(5.+eps, eps, 5.+eps)), \n            vec3(0.6), 0.1, 0.1, metal);\n    object(colors,\n            box(pos, vec3(0., 5., 0.), vec3(5.+eps, eps, 5.+eps)), \n            vec3(0.6), 0.1, 0.1, metal);\n    object(colors,\n            box(pos, vec3(0., 0., 5.), vec3(5.+eps, 5.+eps, eps)), \n            vec3(0.6), 0.7, 0.7, matte);\n\n    return sde_v_1;\n}\n\nvoid get_normal(vec3 pos){\n    vec2 oz = vec2(1., 0.);\n    normal = vec3(0.);\n    normal.x += get_scene_distance(pos+eps*oz.xyy, false)-get_scene_distance(pos-eps*oz.xyy, false);\n    normal.y += get_scene_distance(pos+eps*oz.yxy, false)-get_scene_distance(pos-eps*oz.yxy, false);\n    normal.z += get_scene_distance(pos+eps*oz.yyx, false)-get_scene_distance(pos-eps*oz.yyx, false);\n    normal = normalize(normal);\n}\n\nvec3 hash31(float p)\n{\n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   vec3 temp = fract((p3.xxy+p3.yzz)*p3.zyx); \n   return (temp-0.5)*2.;\n}\n\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.zyx + 31.32);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec3 random_equal_vec3(vec3 seed){\n    float azimuth = hash13(seed)*360.;\n    float polar = hash13(seed*2.5+103.)*360.;\n    vec3 temp = vec3(0.);\n    temp.x = sin(polar)*cos(azimuth);\n    temp.y = sin(polar)*sin(azimuth);\n    temp.z = cos(polar);\n    return temp;\n}\n\n\n//    normalize(hash31(abs(time*50.+100.+abs(seed.x*25.)+abs(seed.y*1234.)+abs(seed.z*100.))));\n\n\nvec3 vec3_near(vec3 seed, vec3 dir, float threshold){\n    if(threshold > 0.9){\n        return dir;\n    }else{\n        float modify = 100.;\n        vec3 temp = random_equal_vec3(seed+modify*10.);\n        while(dot(temp, dir) <= threshold){\n            modify += 0.5;\n            temp = random_equal_vec3(seed+modify*10.);\n        }\n        return temp;\n    }\n}","name":"Common","description":"","type":"common"}]}