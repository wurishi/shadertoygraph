{"ver":"0.1","info":{"id":"7tsGzX","date":"1622561517","viewed":425,"name":"hashUI32","username":"Envy24","description":"More variants in common tab.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["noise","random","hash"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/* SEE COMMON TAB FOR MORE FUNCTIONS IMPLEMENTATIONS. */\n/* \n    Returns hash in range [0; UINT32_MAX].\n*/\nuint hashUI32ForDemo(\n    uint x,\n    uint y,\n    uint enthropy0,\n    uint enthropy1,\n    uint enthropy2)\n{\n    uint value = y * enthropy2 + x;\n\n\tvalue += enthropy1;\n\tvalue *= 445593459u;\n\tvalue ^= enthropy0;\n\n    return value * value * value;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    uint enthropy0 = 0u;\n    uint enthropy1 = 0u;\n  \n    if (uv.x < 0.33) {\n        enthropy0 = uint(iTime);\n        enthropy1 = 4294967295u - uint(iTime);\n    } else if (uv.x >= 0.33 && uv.x < 0.66) {\n        enthropy0 = uint(iTime * 2.5f);\n        enthropy1 = 4294967295u - uint(iTime * 2.5f);\n    } else {\n        enthropy0 = uint(iTime * 5.0f);\n        enthropy1 = 4294967295u - uint(iTime * 5.0f);\n    }\n    \n    float gray = \n        float(\n            hashUI32ForDemo(\n                uint(fragCoord.x),\n                uint(fragCoord.y),\n                enthropy0,\n                enthropy1,\n                800u))\n            * 2.32830644e-10;\n\n    fragColor = vec4(vec3(gray),1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"/* \n    Returns hash in range [0; UINT32_MAX].\n*/\nuint uh11(uint value) // hashUI32\n{\n    // Pick some seed values.\n    const uint seed0 = 12345u;\n    const uint seed1 = 67890u;\n\n    // Calculate hash.\n\tvalue += seed1;\n\tvalue *= 445593459u;\n\tvalue ^= seed0;\n\n    return value * value * value;\n}\n// u - unsigned int\n// H - hash macro\n// 11 - 1 in, 1 out\n#define uH11(v) ( uh11(uint(v)) )\n#define uH21(v) ( uh11(uint(v.x) + uh11(uint(v.y))) )\n#define uH31(v) ( uh11(uint(v.x) + uh11(uint(v.y) + uh11(uint(v.z)))) )\n\n/* \n    Returns hash in range [0; UINT32_MAX].\n*/\nuint hashUI32(uint x, uint y)\n{\n    // Pick some enthropy source values.\n    // Try different values.\n    const uint entropy0 = 123u;\n    const uint entropy1 = 456u;\n    const uint entropy2 = 789u;\n\n    // Use linear offset method to mix coordinates.\n    uint value = y * entropy2 + x;\n\n    // Calculate hash.\n\tvalue += entropy1;\n\tvalue *= 445593459u;\n\tvalue ^= entropy0;\n\n    return value * value * value;\n}\n\n/* \n    Returns hash in range [0; UINT32_MAX].\n*/\nuint hashUI32(uint x, uint y, uint z)\n{\n    // Pick some enthropy source values.\n    // Try different values.\n    const uint entropy0 = 1200u;\n    const uint entropy1 = 4500u;\n    const uint entropy2 = 6700u;\n    const uint entropy3 = 8900u;\n\n    // Use linear offset method to mix coordinates.\n    uint value = \n        z * entropy3 * entropy2 +\n        y * entropy2 +\n        x;\n\n    // Calculate hash.\n\tvalue += entropy1;\n\tvalue *= 445593459u;\n\tvalue ^= entropy0;\n\n    return value * value * value;\n}\n\n/*  \n    Returns hash in range [0.0; 1.0].\n*/\nfloat sample1DHashUI32(uint value)\n{\n    // Pick some enthropy source values.\n    // Try different values.\n    const uint seed0 = 12345u;\n    const uint seed1 = 67890u;\n\n    // Calculate hash.\n\tvalue += seed1;\n\tvalue *= 445593459u;\n\tvalue ^= seed0;\n\n    // 1.0f / 4294967295.0f = 2.32830644e-10\n    \n    return float(value * value * value) * 2.32830644e-10;\n}\n#define fHu(v) ( sample1DHashUI32(uint(v)) )\n\n/*\n    Returns hash in range [0.0; 1.0].\n*/\nfloat fHuu(uint x, uint y)\n{\n    // Pick some seed values.\n    const uint seed0 = 123u;\n    const uint seed1 = 456u;\n    const uint seed2 = 789u;\n\n    // Use linear offset method to mix coordinates.\n    uint value = y * seed2 + x;\n\n    // Calculate hash.\n\tvalue += seed1;\n\tvalue *= 445593459u;\n\tvalue ^= seed0;\n    \n    // 1.0f / 4294967295.0f = 2.32830644e-10\n\n    return float(value * value * value) * 2.32830644e-10;\n}\n#define FHUU(P) ( fHuu(uint(P.x), uint(P.y)) )\n\n/*\n    Returns hash in range [0.0; 1.0].\n*/\nfloat fHuuu(uint x, uint y, uint z)\n{\n    // Pick some seed values.\n    const uint seed0 = 1200u;\n    const uint seed1 = 4500u;\n    const uint seed2 = 6700u;\n    const uint seed3 = 8900u;\n\n    // Use linear offset method to mix coordinates.\n    uint value = \n        z * seed3 * seed2 +\n        y * seed2 +\n        x;\n\n    // Calculate hash.\n\tvalue += seed1;\n\tvalue *= 445593459u;\n\tvalue ^= seed0;\n\n    // 1.0f / 4294967295.0f = 2.32830644e-10\n\n    return float(value * value * value) * 2.32830644e-10;\n}\n#define FHUUU(v) ( fHuuu(uint(v.x), uint(v.y), uint(v.z)) )\n\n/*\n    Returns hash in range [-1.0; 1.0].\n*/\nfloat signedSample1DHashUI32(uint value)\n{\n    // Pick some seed values.\n    const uint seed0 = 12345u;\n    const uint seed1 = 67890u;\n\n    // Calculate hash.\n\tvalue += seed1;\n\tvalue *= 445593459u;\n\tvalue ^= seed0;\n\n    // 2.0f / 4294967295.0f = 4.6566128730773926e-10\n    \n    return float(value * value * value) * 4.6566128730773926e-10 - 1.0f;\n}\n\n/*\n    Returns hash in range [-1.0; 1.0].\n*/\nfloat signedSample2DHashUI32(uint x, uint y)\n{\n    // Pick some seed values.\n    const uint seed0 = 123u;\n    const uint seed1 = 456u;\n    const uint seed2 = 789u;\n\n    // Use linear offset method to mix coordinates.\n    uint value = y * seed2 + x;\n\n    // Calculate hash.\n\tvalue += seed1;\n\tvalue *= 445593459u;\n\tvalue ^= seed0;\n    \n    // 2.0f / 4294967295.0f = 4.6566128730773926e-10\n\n    return float(value * value * value) * 4.6566128730773926e-10f - 1.0f;\n}\n#define SH2to1(P) ( signedSample2DHashUI32(uint(P.x), uint(P.y)) )\n\n/*\n    Returns hash in range [-1.0; 1.0].\n*/\nfloat signedSample3DHashUI32(uint x, uint y, uint z)\n{\n    // Pick some enthropy source values.\n    // Try different values.\n    const uint entropy0 = 1200u;\n    const uint entropy1 = 4500u;\n    const uint entropy2 = 6700u;\n    const uint entropy3 = 8900u;\n\n    // Use linear offset method to mix coordinates.\n    uint value = \n        z * entropy3 * entropy2 +\n        y * entropy2 +\n        x;\n\n    // Calculate hash.\n\tvalue += entropy1;\n\tvalue *= 445593459u;\n\tvalue ^= entropy0;\n\n    // 1.0f / 4294967295.0f = 2.32830644e-10\n\n    return float(value * value * value) * 4.6566128730773926e-10f - 1.0f;\n}\n\n/* \n    Returns random vec2([-1.0; 1.0], [-1.0; 1.0]).\n*/\nvec2 Hu2to2sf(\n    const uint x,\n    const uint y)\n{\n    // Pick some seed values.\n    const uint seed0 = 123u;\n    const uint seed1 = 456u;\n    const uint seed2 = 789u;\n\n    // Use linear offset method to mix coordinates.\n    uint value0 = y * seed2 + x;\n    uint value1 = x * seed2 + y;\n\n    // Calculate hash.\n\tvalue0 += seed1; value0 *= 445593459u; value0 ^= seed0;\n    value1 += seed1; value1 *= 445593459u; value1 ^= seed0;\n    \n    // 2.0f / 4294967295.0f = 4.6566128730773926e-10\n\n    return \n        vec2(\n            float(value0 * value0 * value0) * 4.6566128730773926e-10f - 1.0f,\n            float(value1 * value1 * value1) * 4.6566128730773926e-10f - 1.0f);\n}\n#define H2to2(P) ( Hu2to2sf(uint(P.x), uint(P.y)) )\n\n/* \n    Returns random vec3([-1.0; 1.0], [-1.0; 1.0], [-1.0; 1.0]).\n*/\nvec3 vector3HashUI32(\n    const uint x,\n    const uint y,\n    const uint z)\n{\n    // Pick some enthropy source values.\n    // Try different values.\n    const uint entropy0 = 1200u;\n    const uint entropy1 = 4500u;\n    const uint entropy2 = 6700u;\n    const uint entropy3 = 8900u;\n\n    // Use linear offset method to mix coordinates.\n    uint value0 = z * entropy3 * entropy2 + y * entropy2 + x;\n    uint value1 = y * entropy3 * entropy2 + x * entropy2 + z;\n    uint value2 = x * entropy3 * entropy2 + z * entropy2 + y;\n\n    // Calculate hash.\n\tvalue0 += entropy1; value0 *= 445593459u; value0 ^= entropy0;\n    value1 += entropy1; value1 *= 445593459u; value1 ^= entropy0;\n    value2 += entropy1; value2 *= 445593459u; value2 ^= entropy0;\n\n    // 2.0f / 4294967295.0f = 4.6566128730773926e-10\n\n    return vec3(\n        float(value0 * value0 * value0) * 4.6566128730773926e-10f - 1.0f,\n        float(value1 * value1 * value1) * 4.6566128730773926e-10f - 1.0f,\n        float(value2 * value2 * value2) * 4.6566128730773926e-10f - 1.0f);\n}\n#define H3to3(P) ( vector3HashUI32(uint(P.x), uint(P.y), uint(P.z)) )\n\n/* \n    Returns random vec3([-1.0; 1.0], [-1.0; 1.0], [-1.0; 1.0], [-1.0; 1.0]).\n*/\nvec4 vector4HashUI32(\n    const uint x,\n    const uint y,\n    const uint z,\n    const uint w)\n{\n    // Pick some enthropy source values.\n    // Try different values.\n    const uint entropy0 = 1200u;\n    const uint entropy1 = 4500u;\n    const uint entropy2 = 6700u;\n    const uint entropy3 = 8900u;\n\n    // Use linear offset method to mix coordinates.\n    uint value0 = z * entropy3 * entropy2 + y * entropy2 + x;\n    uint value1 = y * entropy3 * entropy2 + x * entropy2 + z;\n    uint value2 = x * entropy3 * entropy2 + z * entropy2 + y;\n    uint value3 = w * entropy3 * entropy2 + w * entropy2 + w;\n\n    // Calculate hash.\n\tvalue0 += entropy1; value0 *= 445593459u; value0 ^= entropy0;\n    value1 += entropy1; value1 *= 445593459u; value1 ^= entropy0;\n    value2 += entropy1; value2 *= 445593459u; value2 ^= entropy0;\n    value3 += entropy1; value3 *= 445593459u; value3 ^= entropy0;\n\n    // 2.0f / 4294967295.0f = 4.6566128730773926e-10\n\n    return vec4(\n        float(value0 * value0 * value0) * 4.6566128730773926e-10f - 1.0f,\n        float(value1 * value1 * value1) * 4.6566128730773926e-10f - 1.0f,\n        float(value2 * value2 * value2) * 4.6566128730773926e-10f - 1.0f,\n        float(value3 * value3 * value3) * 4.6566128730773926e-10f - 1.0f);\n}\n#define H4to4(P) ( vector4HashUI32(uint(P.x), uint(P.y), uint(P.z), uint(P.w)) )\n\n/* \n    Returns random vec2 sample from unit disk.\n    Non-uniform sampling.\n*/\nvec2 sampleUnitDisk2HashUI32(\n    const uint x,\n    const uint y)\n{\n    // Pick some enthropy source values.\n    // Try different values.\n    const uint entropy0 = 123u;\n    const uint entropy1 = 456u;\n    const uint entropy2 = 789u;\n\n    // Use linear offset method to mix coordinates.\n    uint value0 = y * entropy2 + x;\n    uint value1 = x * entropy2 + y;\n\n    // Calculate hash.\n\tvalue0 += entropy1; value0 *= 445593459u; value0 ^= entropy0;\n    value1 += entropy1; value1 *= 445593459u; value1 ^= entropy0;\n    \n    // (2.0f * PI) / 4294967295.0f = 1.46291812e-09\n    // 1.0f / 4294967295.0f = 2.32830644e-10 \n\n    float angle = float(value0 * value0 * value0) * 1.46291812e-09 - 3.14159274f;\n    float scale = float(value1 * value1 * value1) * 2.32830644e-10 ;\n\n    // Redistribute values by law: f(x)=1-x^2.\n    scale = 1.0 - scale * scale;\n\n    return \n        vec2(\n            cos(angle) * scale,\n            sin(angle) * scale);\n}","name":"Common","description":"","type":"common"}]}