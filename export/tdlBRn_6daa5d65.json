{"ver":"0.1","info":{"id":"tdlBRn","date":"1587612308","viewed":67,"name":"Ambient Occlusion Shangru","username":"pandaleo","description":"hw9","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["cis561"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"mat3 rotateY(float rad)\n{\n    return mat3(vec3(cos(rad), 0, -sin(rad)),\n                vec3(0, 1, 0),\n                vec3(sin(rad), 0, cos(rad))\n               );\n}\nmat3 rotateZ(float rad)\n{\n    return mat3(vec3(cos(rad), -sin(rad), 0),\n                vec3(sin(rad), cos(rad), 0),\n                vec3(0, 0, 1)\n               );\n}\nmat3 rotateX(float rad)\n{\n    return mat3(vec3(1, 0, 0),\n        \t\tvec3(0, cos(rad), -sin(rad)),\n                vec3(0, sin(rad), cos(rad))\n               );\n}\nmat3 scale(float a, float b, float c)\n{\n    return mat3(vec3(a, 0, 0), vec3(0, b, 0), vec3(0, 0, c));\n}\nmat3 scale(float a)\n{\n    return scale(a, a, a);\n}\nfloat sdfBox(vec3 p, vec3 b)\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x, max(d.y, d.z)), 0.) + length(max(d, 0.));\n}\nfloat sdfSphere(vec3 p)\n{\n    return length(p) - 0.5;\n}\nfloat sdfPlane(vec3 p)\n{\n    return dot(p, vec3(0, 0, 1));\n}\nvec2 closer(vec2 a, vec2 b)\n{\n    return a.x < b.x ? a: b;\n}\nfloat deg2rad(float r)\n{\n\treturn r / 180. * 3.14159;\n}\nvec2 map(vec3 pos) // find closest object\n{\n    vec3 sphereWorld = vec3(0.3, 0.3, -0.4);\n    vec3 posSphereModel = pos - sphereWorld; // position in sphere model space\n    vec2 sphereInfo = vec2(sdfSphere(posSphereModel), 1.);\n    \n    vec3 boxWorld = vec3(-0.35, -0.6, 0.3);\n    vec3 posBoxModel = inverse(rotateY(deg2rad(35.))) * (pos - boxWorld);\n    vec3 boxSize = vec3(0.2, 0.4, 0.2);\n    vec2 boxInfo = vec2(sdfBox(posBoxModel, boxSize), 2.);\n    \n    vec3 boxWorld2 = vec3(0.35, -0.8, 0.3);\n    vec3 posBoxModel2 = inverse(rotateY(deg2rad(60.))) * (pos - boxWorld2);\n    vec3 boxSize2 = vec3(0.22, 0.22, 0.22);\n    vec2 boxInfo2 = vec2(sdfBox(posBoxModel2, boxSize2), 8.);\n    \n    vec3 planeWorld1 = vec3(-1, 0, 0);\n    vec3 posPlaneModel1 = inverse(rotateY(3.14 / 2.)) * (pos - planeWorld1);\n    vec2 planeInfo1 = vec2(sdfPlane(posPlaneModel1), 3.);\n    \n    vec3 planeWorld2 = vec3(1, 0, 0);\n    vec3 posPlaneModel2 = inverse(rotateY(3. * 3.14 / 2.)) * (pos - planeWorld2);\n    vec2 planeInfo2 = vec2(sdfPlane(posPlaneModel2), 4.);\n    \n    vec3 planeWorld3 = vec3(0, 0, 0);\n    vec3 posPlaneModel3 = (pos - planeWorld3);\n    vec2 planeInfo3 = vec2(sdfPlane(posPlaneModel3), 5.);\n    \n    vec3 planeWorld4 = vec3(0, 1, 0);\n    vec3 posPlaneModel4 = inverse(rotateX(3. * 3.14 / 2.)) * (pos - planeWorld4);\n    vec2 planeInfo4 = vec2(sdfPlane(posPlaneModel4), 6.);\n    \n    vec3 planeWorld5 = vec3(0, -1, 0);\n    vec3 posPlaneModel5 = inverse(rotateX(3.14 / 2.)) * (pos - planeWorld5);\n    vec2 planeInfo5 = vec2(sdfPlane(posPlaneModel5), 7.);\n    \n    vec2 closest;\n    closest = closer(boxInfo, planeInfo1);\n    closest = closer(closest, planeInfo2);\n    closest = closer(closest, planeInfo3);\n    closest = closer(closest, planeInfo4);\n    closest = closer(closest, planeInfo5);\n    closest = closer(closest, boxInfo2);\n    return closest;\n}\nfloat fiveTapAO(vec3 p, vec3 n, float k) {\n    float aoSum = 0.0;\n    for(float i = 0.0; i < 5.0; ++i) {\n        float coeff = 1.0 / pow(2.0, i);\n        aoSum += coeff * (i * 0.15 - map(p + n * i * 0.15).x);\n    }\n    return 1.0 - k * aoSum;\n}\nvec2 calcIntersection(in vec3 ro, in vec3 rd){\n    float currentMinSdf = 0.002;\n    float t = 0.0; // distance from ro (ray origin)\n\tfloat resDistance = -1.;\n    float id = -1.;\n    for (int i = 0; i < 100; ++i){\n        if (currentMinSdf < 0.001 || t > 10.) break; // hit or exceed max distance\n\t   \tvec2 hitInfo = map(ro + rd * t); // hit object distance and id\n        currentMinSdf = hitInfo.x; // distance\n        t += currentMinSdf; // update current distance from ro\n        id = hitInfo.y;\n    }\n    if (t <= 10.) resDistance = t; // if in distance\n    else id = -1.; // no hit\n    return vec2(resDistance, id);\n}\nvec3 calcNormal(in vec3 pos){\n    \n\tvec3 dx = vec3(0.001, 0.0, 0.0);    \n\tvec3 dy = vec3(0.0, 0.001, 0.0);    \n\tvec3 dz = vec3(0.0, 0.0, 0.001);\n\tvec3 nor = vec3(\n\t    map(pos + dx).x - map(pos - dx).x,\n\t    map(pos + dy).x - map(pos - dy).x,\n\t    map(pos + dz).x - map(pos - dz).x\n    );\n\treturn normalize(nor);\n}\nvec3 render(vec2 res, in vec3 ro, in vec3 rd)\n{\n    float ambient = 0.05;\n    vec3 color = vec3(0);\n    float lightX = 0.5 * sin(iTime * 4.);\n    vec3 lightPos = vec3(lightX, 0.9, 0.8);\n    if (res.y > 0.) // id\n    {\n    \tvec3 pos = ro + rd * res.x;\n    \tvec3 norm = calcNormal(pos);\n    \tvec3 lightDir = normalize(lightPos - pos);\n        float match = max(0., dot(lightDir, norm) / pow(length(lightPos - pos), 0.3));\n        float ao = fiveTapAO(pos, norm, 2.);\n        if (res.y == 1.) color = ao * vec3(1., 0., 0.) * match + ambient;\n        else if (res.y == 2.) color = ao * vec3(0.4, 0.4, 0.4) * match + ambient;\n\t\telse if (res.y == 3.) color = ao * vec3(1, 0, 0) * match + ambient;\n        else if (res.y == 4.) color = ao * vec3(0, 1, 0) * match + ambient;\n\t\telse if (res.y == 5.) color = ao * vec3(1, 1, 1) * match + ambient;   \n        else if (res.y == 6.) color = ao * vec3(0.5, 0.5, 0.5) * match + ambient;\n\t\telse if (res.y == 7.) color = ao * vec3(1, 1, 1) * match + ambient;  \n\t\telse if (res.y == 8.) color = ao * vec3(1, 1, 1) * match + ambient;   \n    }\n    return color;\n}\nmat3 lookAt(in vec3 eye, in vec3 ref)\n{\n    vec3 front = normalize(ref - eye);\n    vec3 right = normalize(cross(front, vec3(0, 1, 0)));\n    vec3 up = normalize(cross(right, front));\n    return mat3(right, up, front);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (2. * fragCoord.xy - iResolution.xy) / iResolution.y;\n    vec3 eye = vec3(0, 0, 2), ref = vec3(0, 0, 0);\n    vec3 direction = normalize(lookAt(eye, ref) * vec3(p.xy, 1));\n    vec2 res = calcIntersection(eye, direction);\n    fragColor = vec4(render(res, eye, direction), 1);\n}","name":"Image","description":"","type":"image"}]}