{"ver":"0.1","info":{"id":"stVSRW","date":"1640279447","viewed":144,"name":"Happy new 2022!","username":"Shcherbakov","description":"Shader was written on stream: https://youtu.be/eRapxePOUSI","likes":7,"published":1,"flags":32,"usePreview":0,"tags":["snow"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord - iResolution.xy * 0.5) / iResolution.x;\n\n    fragColor = mix(vec4(0, 0, 0.1, 0), vec4(0.1, 0.1, 0.2, 0), fragCoord.y / iResolution.y);\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    for (int i = 0; i < 40; ++i) {\n        float phi = float(i) / 40.0 * 2.0 * 3.14159 + iTime * 0.1;\n        float r = 0.2 * cos(sin(2.5 * phi - 3.14159 * 0.25));\n        vec2 partUV = r * vec2(cos(phi), sin(phi));\n        float radius = 0.03 * (sin(phi * 10.0) * 0.25 + 0.75);\n        if (length(partUV - uv) < radius) {\n            fragColor.xyz += (i % 2 == 0 ? vec3(0.8, 0.1, 0) : vec3(0, .7, 0))\n                * pow(1.0 - length(partUV - uv) / radius, 2.0);\n        }\n    }\n\n    for (int i = 0; i < 100; ++i) {\n        float partX = sin(float(i)) * 0.7 + cos(iTime + float(i * i)) * 0.03;\n        float partY = 1.0 - fract(iTime * 0.1 + sin(float(i * i))) * 1.5;\n        vec2 partCoord = vec2(partX, partY);\n        float radius = 0.005 * cos(float(i)) + 0.015;\n        if (length(partCoord - uv) < radius) {\n            vec2 partUV = (uv - partCoord) / radius;\n            partUV = (partUV * 0.5 + 0.5);\n            fragColor += texture(iChannel1, (partUV.xy + vec2(i % 26, i * i % 15)) * 30.0 / iResolution.xy).xxxx;\n        }\n    }\n\n    float edge = 0.1 * (sin(uv.x * 4.0) * 0.5 + 0.5)\n    + 0.1 * (sin(uv.x * 8.4235 + 3.341) * 0.5 + 0.5)\n    + 0.3 * (sin(uv.x * 1.4235 + 73.341) * 0.5 + 0.5)\n    ;\n\n    if (fragCoord.y / iResolution.y < mix(0.0, edge, min(iTime * 0.001, 1.0))) {\n        fragColor = vec4(0.9);\n    }\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 coord = ivec2(fragCoord);\n    if (iFrame >= 14) {\n        fragColor.x = texelFetch(iChannel0, coord, 0).x;\n        return;\n    }\n    if (iFrame == 0) {\n        if (coord.x % 15 == 0 && coord.y < 3)\n            fragColor.x = 1.0;\n        return;\n    }\n    if (iFrame == coord.x % 15) {\n        float upRand = texelFetch(iChannel1, coord - ivec2(0, 1), 0).x;\n        float rand = texelFetch(iChannel1, coord - ivec2(0, 0), 0).x;\n        float downRand = texelFetch(iChannel1, coord + ivec2(0, 1), 0).x;\n        \n        const int WEIGHTS_COUNT = 6;\n        float weights[WEIGHTS_COUNT] = float[WEIGHTS_COUNT](\n            1.0, 1.0, 1.0, 1.0, 1.0, 1.0\n        );\n        float weightSum = 0.0;\n        for (int i = 0; i < WEIGHTS_COUNT; ++i) {\n            weightSum += weights[i];\n        }\n        for (int i = 0; i < WEIGHTS_COUNT; ++i) {\n            weights[i] /= weightSum;\n        }\n        for (int i = 1; i < WEIGHTS_COUNT; ++i) {\n            weights[i] += weights[i - 1];\n        }\n        float value = 0.0;\n        if (downRand > weights[2]) {\n            value = max(value, texelFetch(iChannel0, coord - ivec2(1, -1), 0).x);\n        }\n        if (rand > weights[0] && rand < weights[1] || rand > weights[4]) {\n            value = max(value, texelFetch(iChannel0, coord - ivec2(1, 0), 0).x);\n        }\n        if (rand > weights[1] && rand < weights[2] || rand > weights[3]) {\n            value = max(value, texelFetch(iChannel0, coord - ivec2(1, 1), 0).x);\n        }\n        \n        fragColor.x = value;\n    } else {\n        fragColor.x = texelFetch(iChannel0, coord, 0).x;\n    }\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"const float PI = 3.14159;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 coord = ivec2(fragCoord);\n    \n    int id = coord.x / 30 * 15 + coord.y / 30;\n    coord = coord % 30;\n\n    vec2 uv = (vec2(coord) - 15.0) / 30.0 * 2.0;\n    float r = length(uv);\n    float phi = atan(uv.y, uv.x) + PI;\n    \n    while (phi > PI / 3.0) {\n        phi -= PI / 3.0;\n    }\n    if (phi > PI / 6.0) {\n        phi -= PI / 6.0;\n        phi = PI / 6.0 - phi;\n    }\n    uv = vec2(cos(phi), sin(phi));\n \n    if (r > 0.9) {\n        return;\n    }\n    fragColor = texture(iChannel0, 15.0 / iResolution.xy * r * uv + vec2(float(id) * 15.0, 0) / iResolution.xy);\n}","name":"Buffer B","description":"","type":"buffer"}]}