{"ver":"0.1","info":{"id":"7s2BWz","date":"1646194002","viewed":125,"name":"Ulam Spiral (Miller-Rabin test)","username":"Envy24","description":"Version of this shader: https://www.shadertoy.com/view/ssjBRm\n\nIf LMB_IS_HOLD == false, then shader uses probabilistic Miller-Rabin Test,\notherwise shader uses Brute Force Test.\n\nhttps://en.wikipedia.org/wiki/Miller%E2%80%93Rabin_primality_test","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["spiral","primes","integer","integers","ulam"],"hasliked":0,"parentid":"ssjBRm","parentname":"Ulam Spiral"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"int sqr(int n) {\n    return n * n;\n}\n\nbool isPrimeBF(int n) {\n    switch (n)\n    {\n    case 0:\n    case 1:\n        return false;\n    case 2:\n    case 3:\n    case 5:\n    case 7:\n        return true;\n    default:\n        break;\n    }\n\n    if ((n & 1) == 0) { return false; }\n\n    int div = 3;\n    bool r = true;\n    int limit = int(sqrt(float(n)));\n\n    do \n    { \n        r = (n % div) != 0;\n        div += 2;\n    } while (r &&\n        div <= limit);\n\n    return r;\n}\n\n/*\n    Miller-Rabin test\n*/\nbool isPrimeMR(\n    uint n,\n    uint k) // number of rounds\n{\n    switch (n)\n    {\n    case 0u:\n    case 1u:\n        return false;\n    case 2u:\n    case 3u:\n    case 5u:\n    case 7u:\n        return true;\n    default:\n        break;\n    }\n\n    if ((n & 1u) == 0u) { return false; } \n\n    uint t = n - 1u;\n    uint s = 0u;\n\n    while ((t & 1u) == 0u)\n    {\n        t >>= 1;\n        ++s;\n    }\n \n    for (uint i = 0u; i < k; ++i)\n    {\n        bool quit_flag = true;\n        \n        uint a = 2u + (hashUI32(i^k^s) % (n - 4u));\n        //uint a = 2u + (uint(goldenRatioHash(float(i)*iTime) * 4294967294.0) % (n - 4u));\n\n        uint x = modPow(a, t, n);\n\n        if (x == 1u || x == (n - 1u)) { continue; }\n\n        for (uint r = 1u; r < s; ++r)\n        {\n            x = modPow(x, 2u, n);\n\n            if (x == 1u) { return false; }\n            if (x == (n - 1u))\n            {\n                quit_flag = false;\n                break;\n            }\n        }\n\n        if (quit_flag == true) { return false; }\n    }\n\n    return true;\n}\n\nvoid mainImage(out vec4 RGBA, in vec2 XY) {\n    int pixelsPerPixel = 3;\n    ivec2 IJ = ivec2(XY) / pixelsPerPixel - ivec2(iResolution.xy) / 2 / pixelsPerPixel;\n    int I = IJ.x;\n    int J = IJ.y;\n    \n    int n = 0;\n        \n    // center\n    if (I == 0 && J == 0) {\n        n = 1;\n    }\n    // squares diagonal - bottom right\n    else if (I > 0 && I == -J) {\n        n = sqr((1 - 2 * J));\n    }\n    // right region\n    else if (I > 0 && I >= abs(J)) {\n        n = sqr(2 * I - 1) + I + J;\n    }\n    // top region\n    else if (J > 0 && J >= abs(I)) {\n        n = sqr(2 * J - 1) + 3 * J - I;\n    }\n    // left region\n    else if (I < 0 && J >= I) {\n        n = sqr(-2 * I) - I - J + 1;\n    }\n    // bottom region\n    else {\n        n = sqr( - 2 * J) + I - 3 * J + 3;\n    }\n    \n    float c = \n        LMB_IS_HOLD == false ?\n            (isPrimeMR(uint(n), 3u) ? 0.0 : 1.0) :\n            (isPrimeBF(n) ? 0.0 : 1.0);\n\n    c = mix(0.15 * c, c, smoothstep(5.0, -5.0, sqrt(float(n)) - 3.0 * float(iFrame)));\n    \n    \n    RGBA = vec4(vec3(c), 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define LMB_IS_HOLD            ( iMouse.z > 0.0 )\n\nuint hashUI32(uint value)\n{\n    // Pick some enthropy source values.\n    // Try different values.\n    const uint entropy0 = 12345u;\n    const uint entropy1 = 67890u;\n\n    // Calculate hash.\n\tvalue += entropy1;\n\tvalue *= 445593459u;\n\tvalue ^= entropy0;\n\n    return value * value * value;\n}\n\nfloat goldenRatioHash(float x)\n{\n    float y = (100. + x);\n    float m = mod(1e3 * y, 11.67115450f);\n    float f = fract(m * (m * y));\n    float a = (f - m) * 6.18034029f;\n\n    return fract(a * fract(a * fract(a)));\n}\n\n/*\n    Calculates expression: (base^exponent) mod module\n*/\nuint modPow(\n    uint base,\n    uint exponent,\n    uint module)\n{\n    uint accum = 1u;\n\n    while (exponent != 0u)\n    {\n        if ((exponent & 0x01u) != 0u) { accum = (accum * base) % module; }\n\n        exponent >>= 1u;\n        base = (base * base) % module;\n    }\n\n    return accum;\n}","name":"Common","description":"","type":"common"}]}