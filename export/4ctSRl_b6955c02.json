{"ver":"0.1","info":{"id":"4ctSRl","date":"1714335837","viewed":65,"name":"Keyboard -><- mouse movements","username":"Chama_lo","description":"Moove around with arrow and mouse around this triangles\n\nLook in common for tune the camera\nCLICK on the page to see thing appear ! (need to fix it btw)","likes":2,"published":1,"flags":48,"usePreview":0,"tags":["triangleintersectionkeyboardmouse"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Parameter\n// Define an array of triangles\nconst int numTriangles = 10; // Set the number of triangles\n\n\n// Define the structure for a triangle\nstruct Triangle {\n    vec3 V1;\n    vec3 V2;\n    vec3 V3;\n};\n\n//-- -- Region random generate triangle -- --//\n\n\n// Function to generate a random float between min and max\nfloat randomFloat(float min, float max, float seed) {\n    return fract(sin(seed) * 43421.6 +iTime/2.0) * (max - min) + min;\n}\n\n// Function to generate a random vector within a given range\nvec3 randomVector(vec3 minValues, vec3 maxValues, float seed) {\n    return vec3(\n        randomFloat(minValues.x, maxValues.x, seed),\n        randomFloat(minValues.y, maxValues.y, seed + 1.0),\n        randomFloat(minValues.z, maxValues.z, seed + 2.0)\n    );\n}\n\n// Function to randomly populate the triangle array\nTriangle[numTriangles] populateTriangleArray(Triangle[numTriangles] triangles) {\n\n    for (int i = 0; i < numTriangles; i++) {\n        // Generate random vertices for the triangle within a certain range\n        vec3 vertex1 = randomVector(vec3(-5.0, -5.0, 20), vec3(5.0, 5.0, 100.0), float(i));\n        vec3 vertex2 = randomVector(vec3(-5.0, -5.0, 20), vec3(5.0, 5.0, 100.0), float(i + 1));\n        vec3 vertex3 = randomVector(vec3(-5.0, -5.0, 20), vec3(5.0, 5.0, 100.0), float(i + 2));\n        \n        // Add the triangle to the array\n        Triangle triangle;\n        triangle.V1 = vertex1;\n        triangle.V2 = vertex2;\n        triangle.V3 = vertex3;\n        \n        triangles[i] = triangle;\n    }\n    \n    return triangles;\n}\n\n//-- -- End Region generate multpiple triangle -- --//\n\n\nTriangle[numTriangles] createCube() {\n    Triangle triangles[numTriangles];\n    \n   \n    triangles[0].V1 = vec3(0.0, 0.0, 11.0);\n    triangles[0].V2 = vec3(0.0, 1.0, 10.0);\n    triangles[0].V3 = vec3(-1.0,0.0, 10.0);\n\n    triangles[2].V1 = vec3(0.0, 0.0, 11.0);\n    triangles[2].V2 = vec3(0.0, 1.0, 10.0);\n    triangles[2].V3 = vec3(1.0, 0.0, 10.0);\n\n    \n    triangles[1].V1 = vec3(2.0, 0.0, 40.0);\n    triangles[1].V2 = vec3(2.0, 1.0, 10.0);\n    triangles[1].V3 = vec3(1.0, 0.0, 10.0);\n\n\n    triangles[3].V1 = vec3(2.0, 0.0, 40.0);\n    triangles[3].V2 = vec3(2.0, 1.0, 10.0);\n    triangles[3].V3 = vec3(3.0, 0.0, 10.0);\n    \n    triangles[4].V1 = vec3(-2.0, 0.0, 40.0);\n    triangles[4].V2 = vec3(-2.0, 1.0, 0.0);\n    triangles[4].V3 = vec3(-1.0, 0.0, 0.0);\n\n\n    triangles[5].V1 = vec3(-2.0, 0.0, 40.0);\n    triangles[5].V2 = vec3(-2.0, 1.0, 0.0);\n    triangles[5].V3 = vec3(-3.0, 0.0, 0.0);\n\n    \n\n    return triangles;\n}\n\n//-- -- Region intersect triangle -- --//\n\n\n// Function to intersect a ray with a single triangle\nfloat intersectTriangle(vec3 origineRayon, vec3 directionRayon,Triangle myTriangle)\n{\n    // V1, V2, V3 are the vertices of the triangle\n    vec3 edge1 = myTriangle.V2 - myTriangle.V1;\n    vec3 edge2 = myTriangle.V3 - myTriangle.V1;\n    vec3 h = cross(directionRayon, edge2);\n    float a = dot(edge1, h);\n    \n    if (abs(a) < 0.0001) // Check if ray is parallel to the triangle\n    {\n        return 0.0;\n    }\n    \n    float f = 1.0 / a;\n    vec3 s = origineRayon - myTriangle.V1;\n    float u = f * dot(s, h);\n    \n    if (u < 0.0 || u > 1.0)\n        return 0.0;\n    \n    vec3 q = cross(s, edge1);\n    float v = f * dot(directionRayon, q);\n    \n    if (v < 0.0 || (u + v) > 1.0)\n        return 0.0;\n    \n    float t = f * dot(edge2, q);\n    \n    if (t > 0.0001) // Check if the intersection is in front of the ray origin\n        return t;\n    else\n        return 0.0;\n}\n\n\n// Function to intersect a ray with multiple triangles and find the closest intersection\nfloat intersectMultipleTriangles(vec3 origineRayon, vec3 directionRayon, Triangle[numTriangles] triangles) {\n\n    float closestDistance = 0.0;\n    \n    for (int i = 0; i < numTriangles; i++) \n    {\n        Triangle currentTriangle = triangles[i];\n        float Actualdistance = intersectTriangle(origineRayon, directionRayon, currentTriangle);\n        \n        if (Actualdistance > 0.0 && (closestDistance == 0.0 || Actualdistance < closestDistance)) {\n            closestDistance = Actualdistance;\n        }\n    }\n    \n    return closestDistance;\n}\n\n\n//-- -- End Region intersect triangle -- --//\n\n\n//get the state of pixels storred in the buffer\nvec4 getState(vec2 i){\n    return texture(iChannel0, (i + vec2(0.5)) / 128.0);\n}\n\n\nmat3 rotateX(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(1, 0, 0),\n        vec3(0, c, -s),\n        vec3(0, s, c)\n    );\n}\n\n// Rotation matrix around the Y axis.\nmat3 rotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, 0, s),\n        vec3(0, 1, 0),\n        vec3(-s, 0, c)\n    );\n}\n\n\n\n// Main function to render the scene\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) \n{\n    Triangle triangles[numTriangles];\n    vec4 outputColor= vec4 (0.0,0.0,0.0,0.0);\n\n    // Populate the triangle array with random triangles\n    \n    if(randomTriangle)\n    {\n        \n        triangles = populateTriangleArray(triangles);\n    }\n    else\n    {\n        //Populate triangle with a objects\n        triangles = createCube();\n    }\n    \n    //Calcul du ratio de l'écran\n    float ratio = iResolution.y/iResolution.x;\n    \n    //-- -- get keyboard Coordinate x 0->1 y 0->1-- --\n    \n   vec4 tex_x = getState(vec2(1., 0.));\n   vec4 tex_y = getState(vec2(2., 0.));\n    \n   float coordx = (tex_x.x-0.5)*movingSpeed;\n   float coordy = (tex_y.x-0.5)*movingSpeed;\n   \n   vec2 coord = vec2 (coordx, coordy);\n   \n   // end of coordinate\n    \n\n    //---- Mouse Handle ----//\n    vec2 MouseCorrect = vec2 (iMouse.x / iResolution.x-0.5,(iMouse.y / iResolution.y-0.5)*ratio );\n\n    \n    //---- CAMERA HANDLE ----//\n    \n    //initialise Camera Origin\n    vec3 camOrigin;\n    camOrigin.x = 0.0;\n    camOrigin.y = 0.0;\n    camOrigin.z = -fov;\n    \n    //fragCoord go from 0,0 to iResolution.x, iResolution.y\n    //fragCoord.y / iResolution.y-0.5 go from -0.5 to 0.5\n    \n    //ScreePixel vec2 (x,y)\n    // -0.5, 0,5  bord en haut à gauche  \n    // 0.5 ,-0,5  bord en bas à droite\n    vec3 ScreePixel = vec3 (fragCoord.x / iResolution.x-0.5,(fragCoord.y / iResolution.y-0.5)*ratio,0 ) ;\n    \n    \n    //Calculating movement \n    \n    ScreePixel.x = ScreePixel.x + coord.x;\n    camOrigin.x = camOrigin.x + coord.x;\n    \n    ScreePixel.z = ScreePixel.z + coord.y;\n    camOrigin.z = camOrigin.z + coord.y;\n    \n    //direction du rayon Caméra écran projeté sur l'écran\n    vec3 RayDir = vec3(ScreePixel.x-camOrigin.x, ScreePixel.y -camOrigin.y, ScreePixel.z-camOrigin.z);\n   \n    RayDir *= rotateY(MouseCorrect.x * angularSpeed);\n    \n    RayDir *= rotateX(-MouseCorrect.y * angularSpeed);\n    \n    //---- CAMERA HANDLE END-//\n\n    // Find intersection with multiple triangles\n    float distance = intersectMultipleTriangles(camOrigin, RayDir, triangles);\n    \n    // Set color based on intersection distance\n    if (distance != 0.0) {\n        fragColor = vec4( 1.0/(distance*0.5), 1.0/(distance*0.5), 1.0/(distance*0.5),0);\n    } else {\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n    }\n}\n\n\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\n\nconst float velocity  = movingPrecision;\n\nvec4 initialize(vec2 i, vec4 cur){\n    if(i.x == 0.0 && i.y == 0.0){\n        return vec4(vec3(0.0), 1.0);\n    }else if(i.x > 0.0 && i.x < 4.0 && i.y == 0.0){\n    \n        return vec4(0.5, 0.5, velocity, 0.0);\n    }\n    return cur;\n}\n\nvec4 moveUp(vec4 cur){\n    vec2 pos = cur.xy;\n    if(pos.x < 1.0)\n    {\n        pos += cur.zw;\n        \n        cur.z = velocity;\n    }\n    return vec4(pos, cur.zw);\n}\n\nvec4 moveDown(vec4 cur){\n    vec2 pos = cur.xy;\n    if( pos.x > 0.0)\n    {\n        pos -= cur.zw;\n    }\n    return vec4(pos, cur.zw);\n}\n\nvec4 getState(vec2 i){\n    return texture(iChannel0, (i + vec2(0.5)) / 128.0);\n}\n\nbool getKeyState(int keyCode, int stateType){\n    return bool(texelFetch(iChannel1, ivec2(keyCode, stateType), 0).x);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = fragCoord.xy / iResolution.xy;\n    vec2 i = floor(p * 128.0);\n    vec4 cur = getState(i);\n    \n    vec4 initFlag = getState(vec2(0.0));\n    if(initFlag.a == 0.0){\n        // initialize.\n        fragColor = initialize(i, cur);\n        return;\n    }\n    \n    \n    // move.\n    if(i.x == 1.0 && i.y == 0.0 && getKeyState(KEY_LEFT, 0)){\n        fragColor = moveDown(cur);\n        return;\n    }\n    if(i.x == 1.0 && i.y == 0.0 && getKeyState(KEY_RIGHT, 0)){\n        fragColor = moveUp(cur);\n        return;\n    }\n    \n    if(i.x == 2.0 && i.y == 0.0 && getKeyState(KEY_UP, 0)){\n        fragColor = moveUp(cur);\n        return;\n    }\n    if(i.x == 2.0 && i.y == 0.0 && getKeyState(KEY_DOWN, 0)){\n        fragColor = moveDown(cur);\n        return;\n    }\n    \n    fragColor = cur;\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"//use arrow and mouse to look around the place\nconst ivec2 ADDR_CAMERA_POSITION = ivec2(0,0);\nconst ivec2 ADDR_CAMERA_ORIENTATION = ivec2(0,1);\nconst ivec2 ADDR_CAMERA_ANG_VELOCITY = ivec2(0,2);\nconst ivec2 ADDR_CAMERA_LIN_VELOCITY = ivec2(0,3);\nconst ivec2 ADDR_MOUSE_DELTA_STATE = ivec2(0,4);\n\n//keying\nconst int KEY_LEFT  = 37;\nconst int KEY_UP    = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN  = 40;\n\n//change this parameter to fine tune the camera\n#define movingPrecision 0.0001\n#define movingSpeed 50.0\n\n#define angularSpeed 3.0\n#define fov 3.0\n\n//choose bewtin generated triangle and fixed object\n#define randomTriangle false\n\n\n//With each change please recompile the project\n//if broken restart the page (happens ofen when changing screan scale)\n\n//this thing is in project so I will work on it when I can\n//I try to implement myself shader without copy pasting completely tutoriel for 3D environement \n","name":"Common","description":"","type":"common"}]}