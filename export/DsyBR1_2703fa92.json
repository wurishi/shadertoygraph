{"ver":"0.1","info":{"id":"DsyBR1","date":"1697880893","viewed":105,"name":"Blooming trees","username":"gest","description":"no description","likes":27,"published":1,"flags":0,"usePreview":0,"tags":["raymarch","tree"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sfGRn","filepath":"/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","previewfilepath":"/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define SHADERTOY\n\n#ifdef SHADERTOY\n    #define main() mainImage( out vec4 fragColor, in vec2 fragCoord )\n    #define u_canvas iResolution\n    #define u_mouse iMouse\n    #define u_time iTime\n    #define gl_FragCoord fragCoord\n    #define gl_FragColor fragColor\n\t#define texture2D texture\n\t#define u_texture0 iChannel0\n\t#define u_texture1 iChannel1\n#endif\n\n//-------------------функции расстояний до объектов\n\nconst vec3 sunDir = normalize (vec3 (0., 0.15, 1.));\n\n#define FAR 100.\n#define ID_NONE -1.\n\n#define ID_GROUND 0.\n#define ID_WATER  1. \n#define ID_TRUNK  2. \n#define ID_BRUNCH 3. \n#define ID_FLOWER_PETALS 4.\n#define ID_FLOWER_CENTER 5.\n\nfloat random(vec2 p) {\n  return fract(sin(dot(p.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n//from https://www.shadertoy.com/view/ll2BzR\nvec2 Hashv2v2 (vec2 p) {\n\tconst float cHashM = 43758.54;\n\tconst vec2 cHashVA2 = vec2 (37., 39.);\n\treturn fract (sin (vec2 (dot (p, cHashVA2), dot (p + vec2 (1., 0.), cHashVA2))) * cHashM);\n}\nfloat Noisefv2 (vec2 p) {\n\tvec2 ip = floor (p);  \n\tvec2 fp = fract (p);\n\tfp = fp * fp * (3. - 2. * fp);\n\tvec2 t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n\treturn mix (t.x, t.y, fp.x);\n}\nfloat WaveHt (vec2 p) {\n\tmat2 qRot = mat2 (0.8, -0.6, 0.6, 0.8);//~Rot37\n\n\tvec2 q = 0.5 * p + vec2 (0., u_time);\n\tfloat h = 0.2 * sin (q.y) + 0.15 * sin (dot (q, vec2 (0.1, 1.2))) +\n\t \t0.1 * sin (dot (q, vec2 (-0.2, 1.4)));\n\th *= 0.3 * (1. - smoothstep (0.8 * FAR, FAR, length (p)));\n\tq = p;\n\tfloat wFreq = 0.5;\n\tfloat wAmp = 0.05;\n\tvec2 tw = 0.5 * u_time * vec2 (1., -1.);\n\tfor (int j = 0; j < 1; j ++) { //4\n\t\tq *= qRot;\n\t\tvec4 t4 = q.xyxy * wFreq + tw.xxyy;\n\t\tvec2 t = vec2 (Noisefv2 (t4.xy), Noisefv2 (t4.zw));\n\t\tt4 += 2. * t.xxyy - 1.;\n\t\tvec4 v4 = (1. - abs (sin (t4))) * (abs (sin (t4)) + abs (cos (t4)));\n\t\tt = 1. - sqrt (v4.xz * v4.yw);\n\t\tt *= t;\n\t\th += wAmp * dot (t, t);\n\t\twFreq *= 2.;\n\t\twAmp *= 0.5;\n\t}\n\treturn h;\n}\nvec3 mapNormal_water (vec2 p, float eps) {\n\tvec2 e = vec2 (eps, 0.);\n\treturn normalize (vec3 (\n\t\tWaveHt (p) - vec2 (WaveHt (p + e.xy), \n\t\tWaveHt (p + e.yx)), \n\t\te.x).xzy);\n}\n\n\nObject TREE(vec3 p) {\n\tvec3 q;\n\t\n\t\n\tObject object = Object(FAR, ID_NONE, p);\n\t\n\t//Ствол\n\tObject TRUNK = Object(FAR, ID_TRUNK, p);\n\t{\n\t\tq = p;\n\t\tTF_TRANSLATE(q.y, -2.);\n\t\tTRUNK.distance = TF_BOX_ROUND(q, vec3(0, 2., 0.), 0.2);\n\t\tTRUNK.position = q;\n\t}\n\tobject = OR(object, TRUNK);\n\t\n\t//Ветки\n\tObject BRUNCH = Object(FAR, ID_BRUNCH, p);\n\t{\n\t\tq = p;\n\t\t\n\t\tconst float branch_len = 3.;\n\t\tconst float brunch_radius = 0.1;\n\t\tconst float branch_angle = PI/4.;\n\t\t\n\t\tfloat L = branch_len;\n\t\tfloat R = brunch_radius;\n\t\tfor (float i = 5.; i>1.; i--) {\n\t\t\tTF_REPLICA_ANGLE(q.xz, i, 0.);\n\t\t\tTF_ROTATE(q.yz, branch_angle);\n\t\t\tBRUNCH.distance = min(BRUNCH.distance, TF_BOX_ROUND(q, vec3(0, 0., L), R));\n\t\t\t\n\t\t\tTF_TRANSLATE(q.z, L);\n\t\t\tq.yz = q.zy;\n\t\t\tL /= 2.;\n\t\t\tR -= 0.025;\n\t\t}\n\n\t\tBRUNCH.position = q;\n\t}\n\tobject = OR(object, BRUNCH);\n\t\n\t//Лепестки\n\tObject FLOWER_PETALS = Object(FAR, ID_FLOWER_PETALS, p);\n\t{\n\t\tconst float petals_count = 6.;\n\t\tconst float petals_angle = 0.1*PI;\n\t\tconst float petals_len = 0.25;\n\t\tconst float petals_width = 0.01;\t\t//0 - petals_radius\n\t\tconst float petals_thickness = -0.04; //0 - petals_radius\n\t\tconst float petals_radius = 0.05;\n\t\tq = BRUNCH.position;\n\t\tTF_REPLICA_ANGLE(q.xz, petals_count, 0.);\n\t\tTF_ROTATE(q.yz, petals_angle);\n\t\tFLOWER_PETALS.distance = TF_BOX_ROUND(q, vec3(petals_width, petals_thickness, petals_len), petals_radius);\n\t\tFLOWER_PETALS.position = q;\n\t}\n\tobject = OR(object, FLOWER_PETALS);\n\n\t//Центр\n\tObject FLOWER_CENTER = Object(FAR, ID_FLOWER_CENTER, p);\n\t{\n\t\tq = BRUNCH.position;\n\t\tFLOWER_CENTER.distance = TF_BALL(q, 0.05);\n\t\tFLOWER_CENTER.position = q;\n\t}\n\tobject = OR(object, FLOWER_CENTER);\n\t\n\treturn object;\n}\n\nObject GROUND(vec3 p) {\n\tvec3 q;\n\t\n\tObject object = Object(FAR, ID_GROUND, p);\n\t{\n\t\tq = p;\n\t\tfloat h =  clamp(texture2D(u_texture1, q.xz*0.01).r, -0.3, 0.3);\n\t\tobject.distance = TF_BEFORE(q.y, -2. - h);\n\t\tobject.position = q;\n\t}\n\t\n\treturn object;\n}\n\nObject WATER(vec3 p) {\n\tvec3 q;\n\t\n\tObject object = Object(FAR, ID_WATER, p);\n\t{\n\t\tq = p;\n\t\tobject.distance = TF_BEFORE(q.y, -2. - 0.15);\n\t\tobject.position = q;\n\t}\n\t\n\treturn object;\n}\n\nfloat map (vec3 p, inout Object object) {\n\tvec3 q;\n\t\n\tobject = Object(FAR, ID_NONE, p);\n\n\tTF_TRANSLATE(p.x, 1.0);\n\n\tobject = OR(object, GROUND(p));\n\t\n\tq = p;\n\t//Разбиваем пространство\n\tvec2 id = TF_REPLICA(q.xz, 20.);\n\t//Смещаем центр\n\tfloat rnd = random(id)*10.;\n\tvec2 rnd2 = clamp(vec2(rnd, -rnd), -3., 3.);\n\tTF_TRANSLATE(q.xz, rnd2);\n\n\tobject = OR(object, TREE(q), 0.8); //Утолщение у земли\n\n\tobject = OR(object, WATER(p));\t\n\n\treturn object.distance*0.9;\n}\n\nfloat map ( in vec3 p ) {\n\tObject object;\n\treturn map (p, object);\n}\n\nvec3 mapNormal (vec3 p, float eps) {\n\tvec2 e = vec2 (eps, -eps);\n\tvec4 v = vec4 (\n\t\tmap (p + e.xxx), \n\t\tmap (p + e.xyy), \n\t\tmap (p + e.yxy), \n\t\tmap (p + e.yyx)\n\t);\n\treturn normalize (vec3 (v.x - v.y - v.z - v.w) + 2. * v.yzw);\n}\n\nfloat rayMarch(inout Ray ray) {\n\tray.distance = ray.near;\n\tfloat steps;\n\tfor (float i = 0.; i < 200.; ++i) {\n\t\tray.position = ray.origin + ray.direction * ray.distance;\n\t\tray.object.distance = map(ray.position, ray.object);\n\t\tray.hit = ray.object.distance < ray.epsilon;\n\t\tif (ray.hit) break;\n\t\tray.distance += ray.object.distance*ray.swing;\n\t\tif (ray.distance>ray.far) break;\n\t\tsteps = i + 1.;\n\t\tif (steps>ray.steps) break;\n\t}\n\treturn steps;\n}\n\nvec3 SkyCol (vec3 ro, vec3 rd, vec3 sunDir) {\n\tfloat sd = clamp (dot(sunDir, rd), 0., 1.);\n\tvec3 skyCol = mix(vec3(1), vec3 (0.5, 0.75, 1.), rd.y+0.2);\n\tvec3 col = skyCol;\n\tcol += 0.5 * vec3 (1., 0.4, 0.2) * pow (sd, 256./2.);\n\tcol += 0.5 * vec3 (1., 0.8, 0.7) * pow (sd, 1024./2.);\n\treturn col;\n}\n\nstruct Material {\n\tvec3 color;\n\tfloat ambi;\n\tfloat diff;\n\tfloat spec;\n\tfloat shine;\n};\n\nMaterial getMaterial(Ray ray) {\n\tMaterial m = Material(vec3(1), 0.4, 0.6, 1.0, 128.);\n\tvec3 p = ray.object.position;\n\tif (ray.object.id==ID_TRUNK || ray.object.id==ID_BRUNCH) {\n\t\tm.spec = 0.2;\n\t\tm.color = texture2D(u_texture0, p.yx * 0.5).rgb;\n\t\tm.color.b *= 0.3;\n\t} else if (ray.object.id==ID_FLOWER_PETALS) {\n\t\tm.spec = 1.0;\n\t\tm.color = vec3(1,0,0);\n\t} else if (ray.object.id==ID_FLOWER_CENTER) {\n\t\tm.spec = 0.5;\n\t\tm.color = vec3(1);\n\t} else if (ray.object.id==ID_GROUND) {\n\t\tm.spec = 0.0;\n\t\tm.color = vec3(0,1,0);\n\t}\n\treturn m;\n}\n\nvec3 lighting(Ray ray, vec3 lightDir, Material m) {\n\tfloat diff = max (dot (ray.normal, lightDir), 0.);\n\tfloat spec = pow (max (dot (normalize (lightDir - ray.direction), ray.normal), 0.), m.shine);\n\treturn  m.color * (m.ambi + m.diff * diff) + m.spec * spec;\n}\n\nvoid main() {\n\tfloat aspect = u_canvas.x / u_canvas.y;\n\tvec2 uv = gl_FragCoord.xy / u_canvas.xy;\n\tuv = 2. * uv - 1.;\n\n\tvec2 mouse = u_mouse.xy/u_canvas.xy;\n\tif (mouse==vec2(0)) mouse = vec2(0.5, 0.5);\n\n\tvec3 angle = vec3(\n\t\tu_mouse.z!=0. ? -mix(-90., 90., mouse.y) : -30.*sin(u_time*0.5),\n\t\tu_mouse.z!=0. ? mix(-180.,180., mouse.x) : -10.*u_time,\n\t\t0.\n\t);\n\t//angle.x = clamp(angle.x, -90., 30.);\n\n\tCamera cam;\n\t{\n\t\tcam.fov     = 45.;\n\t\tcam.aspect  = aspect;\n\t\tcam.origin  = vec3 (0., 0.5, 10.+u_time);\n\t\tcam.target  = cam.origin + vec3(0,0,1);\n\t\tcam.up \t\t= vec3(0,1,0);\n\t}\n\t\n\tRay ray = lookAt(uv, cam);\n\t{\n\t\tray.near \t= 0.01;\n\t\tray.far  \t= FAR;\n\t\tray.epsilon = 0.001;\n\t\tray.swing\t= 1.;\n\t\tray.steps \t= 150.;\n\n\t\tTF_ROTATE(ray.direction.yz, radians(angle.x));\n\t\tTF_ROTATE(ray.direction.xz, radians(angle.y));\n\t}\n\trayMarch (ray);\n\t\n\tfloat refl = 1.;\n\n\tif (ray.distance < ray.far && ray.object.id==ID_WATER) {\n\t\tray.normal = mapNormal_water (ray.position.xz, ray.epsilon*10.);\n\t\t{\n\t\t\tray.origin \t\t= ray.position;\n\t\t\tray.direction \t= reflect (ray.direction, ray.normal);\n\t\t\tray.steps \t\t= 80.;\n\t\t}\n\t\trayMarch (ray);\n\t\trefl *= 0.8;\n\t}\n\n\tvec3 col;\n\t\n\tif (ray.distance < ray.far && ray.object.id!=ID_WATER) {\n\t\tray.normal = mapNormal (ray.position, ray.epsilon*10.);\n\n\t\t#if 1\n\t\t\tvec3 lightDir = sunDir;\n\t\t#else\n\t\t\tvec3 lightDir = -ray.direction;\n\t\t#endif\n\t\t\n\t\tMaterial m = getMaterial(ray);\n\t\tcol = lighting(ray, lightDir, m);\t\n\t} else {\n\t\tcol = SkyCol (ray.origin, ray.direction, sunDir);\n\t}\n\tcol *= refl;\n\n\t//Туман\n\tif (ray.distance<ray.far) {\n\t\tconst float fogStart = 60.;\n\t\tconst vec3 fogColor = vec3(1)*2.;\n\t\tcol = mix(col, fogColor, clamp((ray.distance-fogStart)/(ray.far-fogStart), 0., 1.));\n\t}\n\t\n\tgl_FragColor = vec4 (col, 1.);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"const float PI = radians(180.);\n//Камера\nstruct Camera {\n\t//Задаваемые параметры\n\tfloat fov, aspect;\n\tvec3  origin, target, up;\n\t//Расчетные параметры\n\tfloat factor;\n\tvec3  forward, right, position, coord;\n};\n\n//Параметры объекта\nstruct Object {\n\tfloat   distance;\t//Последнее приближение к объекту сцены\n\tfloat \tid;\t\t\t//id найденого объека сцены\n\tvec3 \tposition;\t//Позиция поверхности\n};\n\n//Луч\nstruct Ray {\n\t//Задаваемые параметры\n\tvec3  origin;\t\t//Начало луча\n\tvec3  direction;\t//Направление луча\n\tfloat near;\t\t\t//Минимальное расстояние от камеры (начало сцены)\n\tfloat far;\t\t\t//Максивальное расстояние от камеры (конец сцены)\n\tfloat epsilon;\t\t//Точность обнаружения поверхности\n\tfloat steps;\t\t//Максимальное число итераций\n\tfloat swing;\n\t//Вычисляемые параметры\n\tfloat distance; \t//Расстояние до объекта сцены от ray.origin в направлении ray.direction\n\tvec3  position; \t//Точка поверхности\n\tvec3  normal;\t\t//Нормаль в точке поверхности\n\tbool  hit;\t\t\t//Флаг нахождения точки поверхности с заданной точностью\n\tObject object;\t\t//Параметры объекта (можно формировать непосредственно в карте расстояний)\n};\n//Формирование луча камеры\nRay lookAt (in vec2 uv, inout Camera cam) {\n\t//Расчетные характеристики камеры\n\tcam.factor \t\t= 1.0/tan(radians(cam.fov/2.));\n\tcam.forward \t= normalize(cam.target-cam.origin); \n\tcam.right \t\t= normalize(cross(cam.forward, cam.up));\n\tcam.up \t\t\t= cross(cam.right, cam.forward);\n\tcam.position \t= cam.origin + cam.factor * cam.forward;\n\tcam.coord \t\t= cam.position + uv.x * cam.right * cam.aspect + uv.y * cam.up;\n\t//Формирование луча\n\tRay ray;\n\t{\n\t\tray.origin \t\t= cam.origin;\n\t\tray.direction \t= normalize(cam.coord - cam.origin);\n\t\t//Умолчания\n\t\tray.near\t\t= 0.01;\n\t\tray.far\t\t\t= 100.;\n\t\tray.epsilon\t\t= 0.001;\n\t\tray.swing\t\t= 1.0;\n\t\tray.steps\t\t= 200.;\n\t}\n\treturn ray;\n}\n\n//-------------------функции трансформации и позиционирования объектов сцены\n//Допустимая ошибка (для удаления артефактов)\n#define EPS 0.03\n//Функция расстояния до фигуры со скругленными ребрами (объединение и сглаживание с увеличением на R)\n//float d - сглаживание фигуры\n//vec2 d - объединение и сглаживание двух фигур\n//vec3 d - объединение и сглаживание трех фигур\n//vec4 d - объединение и сглаживание четырех фигур\n#define TF_ROUND(d, R) length(max(d, 0.)) - R - EPS\n//Функция расстояния до бокса (p vec3) или прямоугольника (p vec2) со скругленными ребрами\n//Функция расстояния до капсулы, если два размера 0\n#define TF_BOX_ROUND(p, S, R) TF_ROUND(abs(p)-S, R)\n//Функция расстояния до бокса (p vec3) или прямоугольника (p vec2)\n#define TF_BOX(p, S) TF_ROUND(abs(p) - S, EPS)\n//Функция расстояния до шара (p vec3) или круга (p vec2)\n#define TF_BALL(p, R) TF_ROUND(abs(p), R)\n//Функция расстояния до пространства ДО p1\n#define TF_BEFORE(p, p1) TF_ROUND(p - p1, 0.0)\n//Функция расстояния до пространства ПОСЛЕ p1\n#define TF_AFTER(p, p1) TF_ROUND(-p + p1, 0.0)\n//Функция расстояния до симметричного пространства МЕЖДУ -p1 и +p1\n#define TF_BETWEEN(p, p1) TF_ROUND(abs(p) - p1, 0.0)\n//Функция расстояния до несимметричного пространства МЕЖДУ p1 и p2\n#define TF_BETWEEN2(p, p1, p2) TF_ROUND( abs(p - 0.5*(p1+p2)) - 0.5*(p2-p1), 0.0)\n//Перемещение пространства p (float p...vec4 p)\n#define TF_TRANSLATE(p, d) p -= d;\n//Вращение пространства p (vec2 p)\n#if 0\n\t#define TF_ROTATE(p, a) p = mat2(cos(a), sin(a), -sin(a), cos(a)) * p\n#else\n\t#define TF_ROTATE(p, a) p = p.xy * cos (a) * vec2 (1., 1.) + p.yx * sin (a) * vec2 (-1., 1.)\n#endif\n//Отражение пространства p (float p...vec4 p)\n#define TF_MIRROR(p, d) p = abs(p) - d\n//Разбиение пространства на повторяющиеся. Возвращает id центра ячейки\n//float p - пространство 1D\n//vec2 p - пространство 2D\n//vec3 p - пространство 3D\n#define TF_REPLICA(p, d) \\\n\tfloor(p/d + 0.5);\\\n\tp = mod(p + 0.5*d, d) - 0.5*d\n//Разбиение пространства на повторяющиеся в диапазоне id от ida до idb включительно. Возвращает id центра ячейки\n#define TF_REPLICA_LIMIT(p, d, ida, idb) \\\n\tfloor(p/d + 0.5);\\\n\tp = p-d*clamp(floor(p/d + 0.5), ida, idb)\n//Разбиение пространства на повторяющиеся сектора в плоскости vec2 p. Возвращает id сектора\t\n#define TF_REPLICA_ANGLE(p, n, off) \\\n    floor(mod(atan(p.x, p.y) + PI /n + off, 2.*PI)/(2.* PI /n));\\\n    TF_ROTATE(p.xy, -off);\\\n    TF_ROTATE(p.xy, (2.* PI /n) * floor ((atan (p.x, p.y)  + PI /n )/(2.* PI /n)) )\n\n\t\n\t\n\t\n//-------------------Функции сочетания расстояний до объектов сцены\n//Сложение / Объединение / ИЛИ\nfloat OR(float distA, float distB) {\n\treturn mix(distA, distB, step(distB, distA)); //if (distB<distA) return distB; return distA;\n}\n//Умножение / Пересечение / И\nfloat AND(float distA, float distB) {\n\treturn mix(distA, distB, step(distA, distB)); //if (distB>distA) return distB; return distA;\n}\n// Минимальная функция сглаживания. Есть бесчисленное множество статей, но IQ объясняет это лучше всего здесь:\n// http://iquilezles.org/www/articles/smin/smin.htm\n//Гладкое сложение / Объединение / ИЛИ (k==0 без)\nfloat OR( float distA, float distB, float k ) {\n\tfloat h = clamp( 0.5 + 0.5*(distB-distA)/k, 0., 1. );\n\treturn mix( distB, distA, h ) - k*h*(1.-h);\n}\n//Гладкое умножение / Пересечение / И (k==0 без)\nfloat AND( float distA, float distB, float k ) {\n\tfloat h = clamp( 0.5 - 0.5*(distB-distA)/k, 0., 1. );\n\treturn mix( distB, distA, h ) + k*h*(1.-h);\n}\n//Исключение / НЕ\nfloat NOT(float dist) {\n\treturn -dist;\n}\n//-------------------Функции сочетания объектов сцены\n//Сложение / Объединение / ИЛИ\nObject OR(Object objectA, Object objectB) {\n\tif (objectB.distance<objectA.distance) return objectB;\n\treturn objectA;\n}\nObject OR(Object objectA, Object objectB, float k) {\n\tObject object = objectA;\n\tif (objectB.distance<objectA.distance) object = objectB;\n\tif (k!=0.) object.distance = OR(objectA.distance, objectB.distance, k);\n\treturn object;\n}\n\n//Умножение / Пересечение / И\nObject AND(Object objectA, Object objectB) {\n\tif (objectB.distance>objectA.distance) return objectB;\n\treturn objectA;\n}\nObject AND(Object objectA, Object objectB, float k) {\n\tObject object = objectA;\n\tif (objectB.distance>objectA.distance) object = objectB;\n\tif (k!=0.) object.distance = AND(objectA.distance, objectB.distance, k);\n\treturn object;\n}\n//Исключение / НЕ\nObject NOT(Object object) {\n\tobject.distance = -object.distance;\n\treturn object;\n}\n","name":"Common","description":"","type":"common"}]}