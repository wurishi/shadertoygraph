{"ver":"0.1","info":{"id":"McSXDh","date":"1706254371","viewed":62,"name":"door opens to clouds then door","username":"javelamaker","description":"defitnetly a door","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["loop","doors","looptime"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsX3Rn","filepath":"/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg","previewfilepath":"/media/ap/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14159\n\nfloat hash(float p) { p = fract(p * 0.011); p *= p + 7.5; p *= p + p; return fract(p); }\nfloat hash(vec2 p) {vec3 p3 = fract(vec3(p.xyx) * 0.13); p3 += dot(p3, p3.yzx + 3.333); return fract((p3.x + p3.y) * p3.z); }\nfloat noise(float x) { float i = floor(x); float f = fract(x); float u = f * f * (3.0 - 2.0 * f); return mix(hash(i), hash(i + 1.0), u); }\nfloat noise(vec2 x) { vec2 i = floor(x); vec2 f = fract(x); float a = hash(i); float b = hash(i + vec2(1.0, 0.0)); float c = hash(i + vec2(0.0, 1.0)); float d = hash(i + vec2(1.0, 1.0)); vec2 u = f * f * (3.0 - 2.0 * f); return mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y; }\nfloat noise(vec3 x) { const vec3 step = vec3(110, 241, 171); vec3 i = floor(x); vec3 f = fract(x); float n = dot(i, step); vec3 u = f * f * (3.0 - 2.0 * f); return mix(mix(mix( hash(n + dot(step, vec3(0, 0, 0))), hash(n + dot(step, vec3(1, 0, 0))), u.x), mix( hash(n + dot(step, vec3(0, 1, 0))), hash(n + dot(step, vec3(1, 1, 0))), u.x), u.y), mix(mix( hash(n + dot(step, vec3(0, 0, 1))), hash(n + dot(step, vec3(1, 0, 1))), u.x), mix( hash(n + dot(step, vec3(0, 1, 1))), hash(n + dot(step, vec3(1, 1, 1))), u.x), u.y), u.z); }\n\n\nfloat theta(vec2 uv)\n{\n    float t = atan(uv.x, uv.y);\n    return t;\n}\n\nfloat petal(float x)\n{\n    float result = ((2. * asin((2. * asin(sin(x))) / PI)) / PI);\n    return result;\n}\n\nfloat face(vec2 uv)\n{\nvec4 _Face = vec4(.05,1.,1.,1.);\nfloat time = iTime * 20.;\nvec4 options = vec4(2, (sin(time) + 2.5) / 2., 0, .8);\nfloat face = clamp( dot(uv, uv), .0, 1.);\nvec2 cuv = vec2(uv.x, uv.y + .3);\nfloat cheeks = clamp((uv.y - .8 + options.g / 15. + uv.y - -1.1 - options.g / 15.) - clamp(1. - step(.8, length(cuv) - sqrt((options.g * options.g) * cos(2. * theta(cuv)))), .0, 1.), .0, 1.)*2.;\n\nvec2 muv = uv * 4. - vec2(0, -3.);\nfloat upperlip = ((-sin(((muv.x - options.b) / 2.) * (muv.x - options.b) / 3.) * 2.) + ((abs(muv.x * 15.) / 5. - (abs(-muv.x) * abs(-muv.x)) / 45.) / 5.));\nfloat lowerlip = ((muv.x * muv.x) / 5. - 2.5 - sin((time) - .3) - 1.);\nfloat opening = muv.y - ((muv.x * muv.x) / 10. - 2.62) * muv.y - ((muv.x * muv.x) / 10. - 2.9 - sin(time) - 1.);\nfloat mouth = upperlip > muv.y + 1.5 && muv.y + 1.5 > lowerlip && muv.x < 3.3 && muv.x > -3.3 ? 1. - opening : 0.;\nvec2 euv = (vec2(abs(uv.x), uv.y)/1.5) + vec2(-.7, -.4);\nfloat balls = 1. - clamp(1. - dot(euv, euv), .0, 1.);\nfloat eyes = clamp(1. - dot(euv, euv) - (pow((theta(euv * 5.) * length(euv.xy) * sin(time/30.)), .9)), .0, 1.);\nvec2 nuv = vec2(uv.x, uv.y * (1. - uv.y + sin(time) / 4.));\nfloat nose = 1. - clamp(dot(nuv, nuv)*10., .0, 1.);\n\n\nvec4 red = vec4(1., .0, .0, 1.);\n\nreturn clamp(_Face.r * ((1.- length(uv)/5.)* 5.) * (((1. - (face - cheeks/2.)) + mouth/.7) * balls/2. + nose*2. + eyes/.7) * length(uv), .0, 40.);\n}\n\nmat2 rotate(float angle)\n{\n    float c = cos(angle);\n    float s = sin(angle);\n    mat2 rot = mat2(c, -s, s, c);\n    return rot;\n}\n\nfloat elastic(float t) {\nreturn sin(-13. * (t + 1.) * (PI/2.)) * pow(2., -10. * t) + 1.;\n}\n\nvec3 doorless(vec2 uv, float itime)\n{\n    float time = clamp(itime-5., 1., 10.) * clamp(itime-5., 1., 10.);\n    float wime = clamp(itime-12., 0., 2.) * clamp(itime-12., 0.,2.);\n    vec2 duv = (uv + vec2((time)/2.5,0)) * vec2(time, 1.);\n    vec2 buv = (uv + vec2((time)/2.5,0)) / vec2(time, 1.)/2.;\n    float door = step(-2., duv.x) * step(-2., -duv.x);\n    float doorside = 1. - step(-2. + (time)/5., -duv.x)/5.;\n    float ornatedesign =  clamp(length(abs(duv) - theta(sin(vec2(.6,.0) + elastic(itime/10.) + elastic(clamp(itime-5., 0., 1.))))), .0, 1.);\n    float batteries = theta(cos(duv * 9.))/5. + theta(cos(duv * 3.))/5.;\n    float doorlock = floor((theta(cos(buv * 9.))/5. + theta(cos(buv * 3.))/5.) * 3.)/3.;\n    \n    return (vec3(door > .2 && doorside < 1. ? .5+ batteries/2. : doorlock, door > .2 && doorside < 1. ? batteries : .0, door > .2 && doorside < 1. ? .2 : .4) * door) + ((1.-step(.1, ornatedesign/5.) + 1.-ornatedesign) * vec3(.8,.8,1.));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 offset = vec2(-.5,-.5);\n    vec2 size = vec2(10,5.8);\n    uv += offset;\n    uv *= size;\n    \n    float itime = fract(iTime/120.)*120.;\n    \n    float tunnel = petal((9. + (sin(itime)/30.) * (sin(itime)/30.))*theta(uv + vec2(itime))) - petal(9.*theta(uv))/10.;\n    tunnel *= tunnel;\n    \n    float time = clamp(itime-5., 1., 10.) * clamp(itime-5., 1., 10.);\n    float wime = clamp(itime-12., 0., 2.) * clamp(itime-12., 0.,2.);\n    vec2 duv = (uv + vec2((time)/2.5,0)) * vec2(time, 1.);\n    vec2 buv = (uv + vec2((time)/2.5,0)) / vec2(time, 1.)/2.;\n    float door = step(-2., duv.x) * step(-2., -duv.x);\n    float doorside = 1. - step(-2. + (time)/5., -duv.x)/5.;\n    float ornatedesign =  clamp(length(abs(duv) - theta(sin(vec2(.6,.0) + elastic(itime/10.) + elastic(clamp(itime-5., 0., 1.))))), .0, 1.);\n    float batteries = theta(cos(duv * 9.))/5. + theta(cos(duv * 3.))/5.;\n    float doorlock = floor((theta(cos(buv * 9.))/5. + theta(cos(buv * 3.))/5.) * 3.)/3.;\n    \n    vec3 doorcol = doorless(uv, itime);\n    vec3 tunnel1 = door <= .0 ? floor(((tunnel * vec3(tunnel, tunnel/2., length(uv/5.))) * ((time-1.)/10.))*4.)/4. : vec3(0);\n    vec3 tunnel2 = vec3(0);\n    float rhyme = clamp((itime-12.)/30., .0, 100.);\n    for(float i = .0; i < ((itime < 40.) ? 50. : .0); i++)\n    {\n        float j = (i + itime) * rhyme;\n        vec2 offset = vec2(elastic(sin(j)/5.), elastic(cos(j)/5.))* i/50.;\n        float urmom = ((itime* 10.)-(i*20.))/1.;\n        vec3 end = clamp((face((uv/(rhyme) + sin(j*5.) + offset )) * vec3(sin(j*6.)/1.5,asin(j*30.) + 1.,atan(j*5.)))* wime/3., clamp(length(offset)-i, 0.,1.), 4.);\n        tunnel2 = length(end) > 0. ? end * i/5. : tunnel2;\n    }\n    \n    vec3 sequence1 = length(tunnel2) > .0 ? tunnel2 : doorcol + tunnel1;\n    \n    \n    float lime = clamp(((itime-20.)*10.), 0., 1000.);\n    float petalshoot = length(uv)-petal(lime*theta(uv))/10.;\n    petalshoot *= petalshoot;\n    \n    float cloud = texture( iChannel0, uv/4. / vec2(lime/100.) + vec2(sin(uv.x)/6.), 1. ).x * texture( iChannel0, uv/100. / vec2(lime/100.), 1. ).x;\n    cloud *= cloud;\n    vec3 cloudfall = mix(vec3(1. + uv.y,1.,3.) * .5 + cloud/3., vec3(.5,.2,uv.y/10.+.5) * floor(length(sin(uv*5.+ itime)*4.)/2.), clamp(2.-cloud*4. - length(uv/4.), .0, 1.) );\n    vec3 and1 = clamp(petalshoot/lime + (length(uv / lime)), .0, 1.) < 1. ? cloudfall * 1.5 : sequence1 + (clamp(petalshoot/lime + (length(uv / lime)), .0, 1.)*lime/30.);\n    \n    float rime = clamp(itime-35., 0., 30.)/10.; \n    float cloud2 = .2 / texture(iChannel0, uv/4. - vec2(.0,itime/2.) + vec2(sin(uv.x* 2.)/4. + sin(uv.x+4.)/4. * sin(itime)), .5).x/4.;\n    //float cloud3 = texture(iChannel0, uv/((rime*6.)+4.) - vec2(itime/2., itime), .1).x/5.;\n    float cloud3 = noise(uv/((rime*6.)+4.) - vec2(itime/2., itime))/5.;\n    float cloud4 = texture(iChannel0, uv/((rime*10.)+30.) - vec2(itime/2., itime), .1).x/6.;\n    vec2 nuv = (uv*7. + vec2(itime, itime)*rime/2.);\n    vec3 sun = clamp(1.-length(nuv), .0, 1.)  * vec3(4.,3.,1.);\n    sun = clamp(asin(sun) - length(nuv)/10.,0.,1.);\n    \n    vec3 cloudfall2 = mix(vec3(texture(iChannel0, uv - vec2(sin(uv.x/10.) + itime/4.)/3.,.4).x * (uv.y + sin(uv.x)/2.), uv.y/100. + petalshoot/50., -.1), vec3((uv.y/10.)+2.,1.4,5.), cloud2 + (cloud3* cloud3 + cloud3) + cloud4) + sun;\n    vec3 opch = itime < 30. ? and1 : cloudfall2;\n    \n    float rivtex = .2 / texture(iChannel0, uv - vec2(itime* 2.,0)  + vec2((sin((uv.x* 2.)+2.)-.5)/7.)).x;\n    vec3 river = vec3(3.5,4., (rivtex * 20.) + 10.) * rivtex;\n    \n    float tree = texture(iChannel1, uv/2. + vec2(1.,1.) + vec2(sin(uv.x + itime/5.)/10.,0.), 1.).x/10. + texture(iChannel1, uv/4. + vec2(sin(uv.x + itime/5.)/10.,0.), 1.).x;\n    vec3 trees = tree * vec3(0.,1.,0.);\n    \n    vec3 riverfall = mix(river, vec3(0,.2 + ((uv.y+2.)/6.) - length(uv/10.), .2), smoothstep(sin(uv.x* 2.+ 1.)/2.,(sin(uv.x* 2.)-1.3)/2., uv.y)+ smoothstep(-sin(uv.x* 2.+ 1.)/2.,(-sin(uv.x* 2.)-1.5)/2., -uv.y));\n    \n    vec3 fullriver = (length(trees* 3.) + ((length(uv/2.)-1. / 2.) * length(uv/5.)-1. / 2.) >= 2. ? trees : riverfall) + cloud;\n    \n    vec3 poch1 = itime < 42. ? opch : fullriver;\n    \n    float sime = clamp(itime-55., 0., 5.)/2.;\n    float fime = clamp(itime-50., 0., 10.);\n    float yime = elastic(clamp(itime-60., 0., 20.) /2.) * 10.;\n    float hime = (clamp((itime-62.5)*10., 2., 100.) /2.);\n    yime *= yime/10.;\n    \n    float e = elastic(hime * 2.)+1.;\n    \n    vec2 ruv = uv * vec2(1.,sime+1.) *(petal((theta(uv)*yime)+1.)) * rotate(e + fime/5.);\n    float rivtex2 = .2 / texture(iChannel0, ruv - vec2(0,itime* 2.)  + vec2((sin((ruv.y* 2.)+2.)* (ruv.y* (sime+1.))-.5)/7.)).x;\n    vec3 river2 = vec3(3.5,4., (rivtex2 * 20.) + 10.) * rivtex2;\n    \n    float grass = clamp(texture(iChannel1, ((uv)- vec2(sin(uv.x)/10.,(-itime/1.5)))/vec2(uv.y*20.,10.)).x, 0., 1.);\n    \n    vec3 pringles = vec3(0);\n    \n    for(float i = .0; i < (itime > 0. ? 50. : .0); i++)\n    {\n        pringles += (texture(iChannel1, ((ruv)- vec2(sin(ruv.x)/10.,(-itime/1.5)))/vec2(ruv.y*20.,10.)+vec2(sin(ruv.x/ruv.y), i/20.)).x)* vec3(0,.2 + ((ruv.y+2.)/6.) - length(ruv/10.) * grass, .2);\n    }\n    pringles /= 50.;\n    \n    vec3 bgsky = mix(vec3(0.,cloud/10.,ruv.y-length(ruv/5.) * grass), river2/5., clamp(sime/5., 0., 1.));\n    \n    vec3 thirdperson = ruv.y < -0.1 ? mix(river2, vec3(0,.2 + ((ruv.y+2.)/6.) - length(ruv/10.) * grass, .2), smoothstep(sin((ruv.y + itime)* 2.+ 1.) * ruv.y,(sin((ruv.y + itime)* 2.)-1.3)* ruv.y, ruv.x)+ smoothstep(-sin((ruv.y + itime)* 2.+ 1.)* ruv.y,(-sin((ruv.y + itime)* 2.)-1.5)* ruv.y, -ruv.x)) : bgsky;\n    \n    float rays = texture( iChannel0, ruv/4. / vec2(itime+5./100.) + vec2(sin(ruv.x)/6.), 1. ).x * texture( iChannel0, ruv/100. / vec2(itime+5./100.), 1. ).x;\n    \n    vec3 river3rd = ((length(thirdperson) < 1.-sime ? pringles : clamp(thirdperson/(sime+1.),0.,3.)) + clamp(rays /2.* vec3(.5,.4,.2)*1.5 * (1.2-ruv.y) * (ruv.y/2.+1.3), 0., 1.)) * clamp(length(ruv*ruv.y), 0.-fime, 1.)+ clamp(rays /20.* vec3(.2,.2,.7)*1.5 * (1.2-uv.y) * (uv.y/2.+1.3), 0., 1.) + clamp(vec3(uv.y,uv.y,uv.y*2.)/10., .01, 1.);\n    \n    vec3 prenut = mix(poch1, river3rd, clamp(itime - 50.,0., 1.));\n    \n    float lasttime = clamp(itime-65., .0001,5.)/5.;\n    \n    //waterfall\n    float siketime = clamp(itime-70.,0., 40.);\n    vec2 fuv = uv -vec2(0.,siketime);\n    float rand = noise(fuv/((((fuv.y/5.)+15.)*siketime/10.)+1.));\n    vec3 rocks = sin(fuv.x) > fuv.y-.5 ? vec3(.2,.5,.2) * fract(length(rand*fuv+vec2(0.,.5))) * vec3(1.,1.2,1.2) : vec3(0.2+ rand*rand,uv.y/5.+ rand/10.,uv.y- rand+5.);\n    vec3 rock1 = sin(fuv.x+5.) > fuv.y-6. ? vec3(.4,.2,.2) * fract(length(rand*fuv+vec2(0.,.5))) * vec3(2.5,1.2,1.2) : vec3(0.2+ rand*rand,uv.y+ rand,uv.y- rand+5.);\n    vec3 mountains = sin(fuv.x + 5. - rand/5.) * fuv.x > fuv.y-.5 ? rock1 : rocks;\n    float rivtex3 = length(mountains) / texture(iChannel0, (fuv*(1.-length(sin(fuv.x/5.+ rand)*5.) > .2 ? length(rock1)/10. +1. : length(rock1)/2.)) - vec2(0,-itime* 2.)  + vec2((sin((fuv.y* 2.)+2.)-.5)/7.)).x;\n    \n    bool road = length(sin(fuv.x/5. + rand)*5.)  > .8 && length(rock1) > .1 || sin(fuv.x + 5. - rand/5.)* fuv.x < fuv.y-.5;\n    \n    vec3 rinkles = road ? mountains : rivtex3 * vec3(1.,1.,5.);\n    \n    vec2 rickuv = uv;\n    \n    vec3 col = mix(prenut, clamp(rinkles, 0., 4.), clamp(elastic(lasttime), 0., 5.));\n\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}