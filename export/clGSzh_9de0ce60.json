{"ver":"0.1","info":{"id":"clGSzh","date":"1686230057","viewed":181,"name":"First Shader Tutorial with Notes","username":"Miri1aj","description":"Following Tutorial from kishimisu on YouTube with slight variation","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["tutorial","first"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n//Applying operations to vectors with the same number of components uses \"vectorized\" math\n    //and does all the operations to each component simultaneously (just like numpy). For example:\n    // vec2 v1, v2;\n    // v1/v2 ----> vec2((v1.x / v2.x), (v1.y / v2.y))\n    // v1 - 0.5 -> vec2(v1.x - 0.5, v1.y - 0.5)\n    \n//\"Swizzling\" is equivalent to creating a new vec2 as follows with syntax like iResolution.xy\n    //vec2(iResolution.x, iResolution.y)\n    //Logically then you could also write iResolution.zy for the z and y components, etc...\n    \n//More examples of Swizzling syntax:\n    // v.xy ---> vec2(v.x, v.y)\n    // v.zzx --> vec3(v.z, v.z, v.x)\n    // v.zxyy -> vec4(v.z, v.x, v.y, v.y)\n    \n//In GLSL you can substitute the first two values (red and green in rgba, for example) with a vec2 like this:\n    //fragColor = vec4(uv, 0.0, 1.0)\n    //because uv contains two values so we get the correct number of arguments passed in\n    \n//Note: we can condense much of the code in the mainImage function into one line with the following steps, but I didn't:\n    // uv = (uv - 0.5) * 2.0;\n    // Which then goes to:\n    // uv = uv * 2.0 - 1.0; <--- I don't understand how that worked but that's what he did\n    // and then you could change the first line in the function to this:\n    // vec2 uv = fragCoord / iResolution.xy * 2.0 - 1.0;\n    // vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n    \n//Changing the red value to 'd' gives us a black circle in the center expanding out to red\n    //which represents the distance between each pixel and the origin of the canvas.\n    //Changing all 3 values to 'd' gives us the grayscale circle\n    \n    \n//A sine distance function is a term given to a function that takes a position in space as input and returns the distance\n    //from that position to a given shape.\n    //It's called sine because the distance is positive outside the shape, negative inside the shape, and exactly zero\n    //at the boundary of the shape\n    \n    \nvec3 palette( float t) {\n    vec3 a = vec3(-0.382, 0.588, 0.808);\n    vec3 b = vec3(-1.441, -0.460, 0.518);\n    vec3 c = vec3(0.231, 0.408, 0.088);\n    vec3 d = vec3(-1.743, -1.073, -1.073);\n    return a + b*cos(6.28318*(c*t+d) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //Normalizing x and y coords to be between 0 and 1 by dividing by the resolution of the screen\n    //iResolution is a builtin containing a vec3(x,y,z) height, width, and depth of screen (depth for 3D only)\n    //Using the .xy syntax isolates the width and height\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    //Since we normalized each axis to be 0 - 1 that means the center of our canvas will be 0.5, 0.5\n    //It's apparently easier to work with this if we change the center to be 0, 0 with the following:\n    uv = uv - 0.5;\n    //Now our center is 0,0 but our corner values consist of combinations of -0.5 and 0.5 (depending on the corner)\n    //so we can double them like so:\n    uv = uv * 2.0;\n    //Now our center is still 0,0 but our corners have -1 or 1 values in their vec2s\n    \n    //Make an adjustment to account for uneven aspect ratio (16:9 vs 1:1, for example) to avoid stretching the image\n    uv.x *= iResolution.x / iResolution.y;\n    \n     //This was created late in the tutorial to keep track of the original center of the canvas\n    vec2 uv0 = uv;\n    \n    vec3 finalColor = vec3(0.0);\n    \n    \n    //Late stage of the tutorial we are now putting all of the color code into a for loop. RIP coherence\n    for (float i = 0.0; i < 2.2; i++) {\n        //Create fractal representation of the image.\n        //First we scale the image as before, then break it into fractals, then center them\n        //Could be shortened to: uv = fract(uv * 2.0) - 0.5;\n        uv *= 1.7;\n        uv = fract(uv);\n        uv -= 0.5;\n        \n        //We can use the length function to calculate the distance between any given vector and the origin (the center of the screen)\n        float d = length(uv) * exp(length(uv0)* .5);\n\n        //This got added late in the tutorial. New vec3 with color values\n        vec3 col = palette(length(uv0) + i*.4 + iTime*.6);\n\n        //We can subtract from d to represent the sine distance function of a circle with a radius of 0.5\n        //d -= 0.5;\n\n        //We can now go back and instead apply the sine function to d to create a radial repetition of the rings\n        //d = sin(d);  <--- This ends up just looking like a dot so we can increase the frequency of the sine function\n        //to give us a repeating ring pattern.\n        //We can add the iTime constant to create an infinite moving pattern of rings\n        d = sin(d*8. + iTime)/8.;\n\n        //Given the description of the sine distance function in the notes we can assign the abs value of d to create a 'donut'\n        //Since the negative values inside the shape will turn positive as the distance from the boundary increases\n        d = abs(d);\n\n        //We can remove the fuzz of the gradient by applying a step function which will make it so that all pixels with a 'd' value\n        //less than 0.1 will be assigned the color black, and all other pixels will be white\n        //d = step(0.1, d);\n        //This creates a sharp edge on the circle, but we can smooth it with a smoothstep function like so\n        //d = smoothstep(0.0, 0.1, d);\n\n        //Now he decided to scrap the smoothstep function also and use the inverse of d which makes the screen completely white\n        //First he used 1.0 as the inverse value but we have to scale it down since our values range between 0-1\n        d = pow(0.015/d, 1.4);\n\n        //Multiply new color variable with the value of d and assign it to fragColor to make red rings\n        //col *= d;\n\n        //He changed it to this:\n        finalColor += col * d;\n    }\n\n    //Select color\n    fragColor = vec4(finalColor, 1.0);\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","name":"Image","description":"","type":"image"}]}