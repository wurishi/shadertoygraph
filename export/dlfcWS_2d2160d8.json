{"ver":"0.1","info":{"id":"dlfcWS","date":"1691096634","viewed":86,"name":"Losange","username":"edes","description":"Inspired from @kishimisu and @Algunalien","likes":4,"published":1,"flags":64,"usePreview":0,"tags":["music","audio","visualizer"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4scGW4","filepath":"https://soundcloud.com/el_estebane/harmonic-4/s-0DV9gnR0tbG?si=afdb20d3571e469583281ef0e146661d&utm_source=clipboard&utm_medium=text&utm_campaign=social_sharing","previewfilepath":"https://soundcloud.com/el_estebane/harmonic-4/s-0DV9gnR0tbG?si=afdb20d3571e469583281ef0e146661d&utm_source=clipboard&utm_medium=text&utm_campaign=social_sharing","type":"musicstream","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Assume the sound texture is 512x2, and you want to divide it into n segments\nconst int numSegments = 16;\nconst int texWidth = 512;\nconst int texHeight = 2;\nconst int segmentWidth = texWidth / numSegments;\n\n// Function to get the average value of a segment\nfloat getSegmentAverage(sampler2D tex, int segmentIndex) {\n    float sum = 0.0;\n    for (int x = segmentIndex * segmentWidth; x < (segmentIndex + 1) * segmentWidth; x++) {\n        sum += texelFetch(tex, ivec2(x, 0), 0).x; // Access the red channel (or average all channels)\n    }\n    return sum / float(segmentWidth);\n}\n\nvec3 palette( float t ) {\n    vec3 a = vec3(0.5, 0.5, 0.5);\n    vec3 b = vec3(0.5, 0.5, 0.5);\n    vec3 c = vec3(1.0, 1.0, 1.0);\n    vec3 d = vec3(0.263,0.416,0.557);\n\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nvec2 rotateUV(vec2 uv, float rotation)\n{\n    return vec2(\n        cos(rotation) * (uv.x) + sin(rotation) * (uv.y),\n        cos(rotation) * (uv.y) - sin(rotation) * (uv.x)\n    );\n}\n\nfloat ndot(vec2 a, vec2 b ) { return a.x*b.x - a.y*b.y; }\nfloat sdRhombus( in vec2 p, in vec2 b ) \n{\n    p = abs(p);\n    float h = clamp( ndot(b-2.0*p,b)/dot(b,b), -1.0, 1.0 );\n    float d = length( p-0.5*b*vec2(1.0-h,1.0+h) );\n    return d * sign( p.x*b.y + p.y*b.x - b.x*b.y );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n    \n    // Access the sound texture\n    float fftData[numSegments];\n    for (int i = 0; i < numSegments; i++) {\n        fftData[i] = getSegmentAverage(iChannel0, i);\n    }\n    \n    vec2 uv0 = uv;\n    vec3 finalColor = vec3(0.0);\n    \n    uv = rotateUV(uv,iTime*0.1);\n    \n    for (float i = 0.0; i < 2.5; i++) {\n        uv = fract(uv * 1.5 ) - 0.5;\n\n        vec2 vec = vec2(0.05, 0.05);\n        float d = sdRhombus(uv, vec) * exp(-length(uv0));\n\n        vec3 col = palette(length(uv0) * i * (fftData[2]) + iTime*0.8);\n        d = d * (pow(fftData[0]*1.2,1.2) +sin(iTime)*0.1 + cos(-iTime)*0.2);\n        d = abs(d-0.28);\n\n        d = pow(fftData[10]*0.05/d,1.1);\n\n        col.r *= fftData[0]; \n\n        finalColor += col * d ;\n    }\n    fragColor = vec4(finalColor,1.0);\n}","name":"Image","description":"","type":"image"}]}