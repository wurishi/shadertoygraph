{"ver":"0.1","info":{"id":"7sjGR1","date":"1618088566","viewed":57,"name":"Fork CG 3rd Pra 029","username":"mhmoodlan","description":"Third lesson. Move the camera with WASD and by dragging the mouse.\nInspiration: https://dribbble.com/shots/15100438-Outdated-Browser-page-visual/attachments/6832802?mode=media","likes":0,"published":1,"flags":48,"usePreview":0,"tags":["camera","postprocess","spheretracing","buffer","lesson"],"hasliked":0,"parentid":"tsXXzr","parentname":"Sphere tracing example"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    fragColor = 2.*texelFetch(iChannel0,ivec2(fragCoord),0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":2,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//This file contains the code for the scene\n\nconst float pi = 3.1415926535897932384626433832795;\n\nstruct Value {\n    float sdf;\n    int matid;\n};\n\n//\tPRIMITIVES are from\n//\thttps://iquilezles.org/articles/distfunctions\n\nValue intersect(Value v1, Value v2) {\n    Value ret = Value(0., 0);\n    if(v1.sdf > v2.sdf) {\n        ret.sdf = v1.sdf;\n        ret.matid = v1.matid;\n    } else {\n        ret.sdf = v2.sdf;\n        ret.matid = v2.matid;\n    }\n    return ret;\n}\n\nValue offset(Value v, float off) {\n    return Value(v.sdf-off, v.matid);\n}\n\nValue setDiff(Value v1, Value v2) {\n    return intersect(v1, Value(-v2.sdf, v2.matid));\n}\n\nfloat unite(float sdf1, float sdf2) {\n    return min(sdf1, sdf2);\n}\n\nValue unite(Value v1, Value v2) {\n    Value ret = Value(0., 0);\n    if(v1.sdf < v2.sdf) {\n        ret.sdf = v1.sdf;\n        ret.matid = v1.matid;\n    } else {\n        ret.sdf = v2.sdf;\n        ret.matid = v2.matid;\n    }\n    return ret;\n}\n\nValue unite(Value v1, float sdf2, int matid2) {\n    Value v2 = Value(sdf2, matid2);\n    return unite(v1, v2);\n}\n\nValue unite(float sdf1, Value v2, int matid1) {\n    Value v1 = Value(sdf1, matid1);\n    return unite(v1, v2);\n}\n\nValue sdSphere(vec3 p, float s, int matid)\n{\n\treturn Value(length(p)-s, matid);\n}\n\nValue sdBox(vec3 p, vec3 b, int matid)\n{\n\tvec3 d = abs(p) - b;\n\treturn Value(length(max(d,0.0))+min(max(d.x,max(d.y,d.z)),0.0), matid); // remove this line for an only partially signed sdf \n}\n\nValue sdRoundBox( vec3 p, vec3 b, float r, int matid)\n{\n  vec3 q = abs(p) - b;\n  return Value(length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r, matid);\n}\n\n// rotation code: https://www.shadertoy.com/view/wdtBzl\nmat2 Rot(float a)\n{\n\tfloat s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\n\nValue sdRoundedCylinder( vec3 p, float ra, float rb, float h, vec3 rotation, int matid)\n{\n\n  p.yz *= Rot(rotation.x);\t//\trotate\n  p.xz *= Rot(rotation.y);\t//\trotate\n  p.xy *= Rot(rotation.z);\n  vec2 d = vec2( length(p.xz)-2.0*ra+rb, abs(p.y) - h );\n  return Value(min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb, matid);\n}\n\n\nValue sdCappedCylinder( vec3 p, float h, float r, vec3 rotation, int matid )\n{\n  p.yz *= Rot(rotation.x);\t//\trotate\n  p.xz *= Rot(rotation.y);\t//\trotate\n  p.xy *= Rot(rotation.z);\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return Value(min(max(d.x,d.y),0.0) + length(max(d,0.0)), matid);\n}\n\nValue sdRoundCone( vec3 p, float r1, float r2, float h, int matid )\n{\n  vec2 q = vec2( length(p.xz), p.y );\n    \n  float b = (r1-r2)/h;\n  float a = sqrt(1.0-b*b);\n  float k = dot(q,vec2(-b,a));\n    \n  if( k < 0.0 ) return Value(length(q) - r1, matid);\n  if( k > a*h ) return Value(length(q-vec2(0.0,h)) - r2, matid);\n        \n  return Value(dot(q, vec2(a,b) ) - r1, matid);\n}\n\nValue sdOctahedron( vec3 p, float s, int matid)\n{\n  p = abs(p);\n  return Value((p.x+p.y+p.z-s)*0.57735027, matid);\n}\n\nValue sdTriPrism( vec3 p, vec2 h, vec3 rotation, int matid )\n{\n  p.yz *= Rot(rotation.x);\t//\trotate\n  p.xz *= Rot(rotation.y);\t//\trotate\n  p.xy *= Rot(rotation.z);\n  vec3 q = abs(p);\n  return Value(max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5), matid);\n}\n\n///SDF\n\nValue sdf(in vec3 p)\n{\n    p-=vec3(0,0,2);\n    Value rbox = sdRoundBox(p-vec3(10., 3., 0.), vec3(.1, 3, 5.), .1, 0);\n    Value rcy = sdRoundedCylinder(p-vec3(9.5, 5.+0.3*abs(sin(iTime)), 4.), .15, .05, .1, \n                                vec3(0., 0., 1.6), 6);\n    Value rcy2 = sdRoundedCylinder(p-vec3(9.5, 5.+0.3*abs(sin(iTime-.3)), 3.), .15, .05, .1, \n                                vec3(0., 0., 1.6), 3);\n    Value rcy3 = sdRoundedCylinder(p-vec3(9.5, 5.+0.3*abs(sin(iTime-.6)), 2.), .15, .05, .1, \n                                vec3(0., 0., 1.6), 4);\n    Value rbox2 = sdRoundBox(p-vec3(9.5, 5., -1.7), vec3(.07, .25, 2.5), .1, 7);\n    \n    Value rcy4 = sdRoundedCylinder(p-vec3(9.5, 5., .45), .18, 0., .5, \n                                vec3(0., 0., 1.6), 1);\n    Value rbox3 = sdBox(p-vec3(9.5, 5., .7), vec3(.3, .45, .3), 6);\n    \n    \n    Value rcy5 = sdRoundedCylinder(p-vec3(9.5, 5., -3.7), .18, 0., .5, \n                                vec3(0., 0., 1.6), 1);\n    Value rbox4 = sdBox(p-vec3(9.5, 5., -4), vec3(.3, .45, .4), 1);\n    \n    Value eye1 = sdRoundedCylinder(p-vec3(9.5, 3., 2.), .15, .05, .1, \n                                vec3(0., 0., 1.6), 1);\n                                \n    Value eye2 = sdRoundedCylinder(p-vec3(9.5, 3., -2.), .15, .05, .1, \n                                vec3(0., 0., 1.6), 1);\n                                \n    Value mouth = sdCappedCylinder(p-vec3(9.5, 2., 0.), 1., .1, vec3(0., 0., 1.6), 5);\n    Value mouthClipper1 = sdCappedCylinder(p-vec3(9.5, 2., 0.), .8, .2, vec3(0., 0., 1.6), 1);\n    Value mouthClipper2 = sdBox(p-vec3(9.5, 1.5, 0.), vec3(.3, .6, 1.3), 1);\n    \n    Value tear = sdRoundCone(p-vec3(9.5, 2., -2.), .15, .05, .3, 6);\n    \n    Value ball = sdSphere(p-vec3(9, 3., 10.), 3., 1);\n    \n    Value pyramid = sdOctahedron(p-vec3(9, -2., 10.), 5., 6);\n    \n    Value rcy6 = sdRoundedCylinder(p-vec3(9, -.5, -7.), .3, .05, .16, \n                                vec3(0., 0., 0.), 3);\n    Value rcy7 = sdRoundedCylinder(p-vec3(9, -.1, -7), .3, .05, .16, \n                                vec3(0., 0., 0.), 3);\n    Value rcy8 = sdRoundedCylinder(p-vec3(9, -.1, -8.15), .5, .05, .16, \n                                vec3(0.8, 0., 0.), 2);\n    \n    Value ret = unite(rbox, rcy);\n    ret = unite(ret, rcy2);\n    ret = unite(ret, rcy3);\n    Value ret2 = setDiff(rbox3, rcy4);\n    Value ret3 = setDiff(rbox2, ret2);\n    Value ret4 = setDiff(rbox4, rcy5);\n    Value ret5 = setDiff(ret3, ret4);\n    ret = unite(ret, ret5);\n    ret = unite(ret, eye1);\n    ret = unite(ret, eye2);\n    Value ret6 = setDiff(mouth, mouthClipper1);\n    ret6 = setDiff(ret6, mouthClipper2);\n    ret = unite(ret, ret6);\n    ret = unite(ret, tear);\n    ret = unite(ret, rcy6);\n    ret = unite(ret, rcy7);\n    ret = unite(ret, rcy8);\n    Value ret7 = offset(ball, 1.);\n    ret7 = intersect(ret7, pyramid);\n    ret = unite(ret, ret7);\n    //ret = unite(ret, sun);\n    //Value ret = unite(rbox, rcy);\n    return unite(ret, p.y+1., 2);\n}\n\n\n// This file contains the \n// ---- SPHERE TRACING ----\n\nconst vec3 BLUEGREEN = vec3(.133, 1., .424);\nconst vec3 ORANGE = vec3(1., .714, .133);\nconst vec3 YELLOW = vec3(1., 1., .133);\nconst vec3 WHITE = vec3(1., 1., 1.);\nconst vec3 primaryColor = vec3(151.,132.,196.)/255.;\nconst vec3 bgColor = vec3(215.,221.,233.)/255.;\n\nstruct Light { \n    vec3 pos;\n    vec3 color;\n    float power;\n};\n\n\nstruct Material {\n    vec3 diffuseColor;\n    float diffusePower;\n    vec3 specularColor;\n    float specularPower;\n    float roughness;\n    vec3 emission;\n    float metalness;\n};\n\nconst Material browser = Material(vec3(216.,221.,233.)/255.,\n                                .3,\n                                vec3(0.),\n                                1.,\n                                1.,\n                                vec3(0.1, 0.0, 0.0),\n                                .02);\n                            \nconst Material eye = Material(vec3(10., 15., 20.)/255.,\n                                1.,\n                                vec3(0.),\n                                .1,\n                                .1,\n                                vec3(0.1, 0.0, 0.0),\n                                .02);\n                                \nconst Material ground = Material(vec3(.1),\n                                1.,\n                                 vec3(.1),\n                                 1.,\n                                 0.01,\n                                 vec3(.1),\n                                 0.9);\nconst Material obj2 = Material(primaryColor,\n                                .5,\n                                vec3(.1),\n                                20.,\n                                .1,\n                                vec3(0.1, 0.0, 0.0),\n                                .02);\nconst Material obj3 = Material(vec3(122.,193.,182.)/255.,\n                                1.,\n                                vec3(.1),\n                                20.,\n                                .1,\n                                vec3(0.1, 0.0, 0.0),\n                                .02);\nconst Material mouth = Material(primaryColor,\n                                .3,\n                                BLUEGREEN,\n                                2.,\n                                100.,\n                                vec3(0.1, 0.0, 0.0),\n                                .02);\nconst Material tear = Material(vec3(207.,208.,219.)/255.,\n                                1.,\n                                YELLOW,\n                                1.,\n                                .1,\n                                vec3(0.1, 0.0, 0.0),\n                                .9);\nconst Material search = Material(vec3(216.,221.,233.)/255.,\n                                1.,\n                                BLUEGREEN,\n                                1.9,\n                                .1,\n                                vec3(0.1, 0.0, 0.0),\n                                .9);\nconst Material pyramid = Material(YELLOW,\n                                1.,\n                                YELLOW,\n                                1.,\n                                100.,\n                                vec3(0.1, 0.0, 0.0),\n                                .9);\nconst Material obj8 = Material(vec3(.3, 0., 0.),\n                                1.,\n                                vec3(.3),\n                                20.,\n                                .1,\n                                vec3(0.1, 0.0, 0.0),\n                                .02);\n\n                                \nMaterial[] materials = Material[] (browser, eye, ground, obj2, obj3, mouth, tear, search, pyramid, obj8); //, obj2, sun, glass, glassobj, mouth, bg);\n\nstruct Ray\n{\n\tvec3 P;\n\tfloat Tmin;\n\tvec3 V;\n\tfloat Tmax;\n};\n\nstruct TraceResult\n{\n    float T;\t\t// Distance taken on ray\n    int flags;\t\t// bit 0:   distance condition:     true if travelled to far t > t_max\n                    // bit 1:   surface condition:      true if distance to surface is small < error threshold\n                    // bit 2:   iteration condition:    true if took too many iterations\n    int material;\n};\n\nstruct SphereTraceDesc\n{\n    float epsilon;  //Stopping distance to surface\n    int maxiters;   //Maximum iteration count\n};\n\nTraceResult sphere_trace(in Ray ray, in SphereTraceDesc params)\n{\n    TraceResult ret = TraceResult(ray.Tmin, 0, 0);\n    Value d;\n    \n    int i = 0; do\n    {\n        d = sdf(ray.P+ret.T*ray.V);\n        ret.T+=d.sdf;\n        ++i;\n    } while (\n\t\tret.T < ray.Tmax &&       \t\t\t// Stay within bound box\n\t\td.sdf\t  > params.epsilon * ret.T &&\t// Stop if cone is close to surface\n\t\ti     < params.maxiters\t        \t// Stop if too many iterations\n\t);\n    \n    ret.flags =  int(ret.T >= ray.Tmax)\n              | (int(d.sdf <= params.epsilon* ret.T)  << 1)\n              | (int(i >= params.maxiters) << 2);\n    ret.material = int(d.matid);\n    return ret;\n}\n\n// ---- SHADING ---- (todo!)\n\nvec3 normal(const in vec3 p)\n{\n    const float eps=0.001;\n    vec3 plus = vec3(sdf(p+vec3(eps,0,0)).sdf,\n                     sdf(p+vec3(0,eps,0)).sdf,\n                     sdf(p+vec3(0,0,eps)).sdf);\n                     \n    vec3 minu = vec3(sdf(p-vec3(eps,0,0)).sdf,\n                     sdf(p-vec3(0,eps,0)).sdf,\n                     sdf(p-vec3(0,0,eps)).sdf);\n                     \n    return normalize(plus-minu);\n}\n\nvec3 reflection(vec3 I, vec3 N) {\n    return I - 2. * dot(I, N) * N; \n}\n\nvec4 missColor(Ray ray)\n{\n    return vec4(texture(iChannel2, ray.V).xyz,1.);\n}\nvec4 errorColor(Ray ray, float t)\n{\n    return vec4(texture(iChannel2, ray.V).xyz,1.);//vec4(1.,0.,0.,1.);\n}\n\nvec4 hitColor(Ray ray, float t, int material_id) {\n    Material material = materials[material_id];\n    \n    vec3 p = ray.P + ray.V*t;\n    vec3 n = normal(p);\n    Light light = Light(vec3(100.*cos(iTime), 100., 100.*sin(iTime)), \n                    vec3(1., 1., 1.),\n                    40.);\n    Light light2 = Light(vec3(-40., 30., 50.), \n                    vec3(195., 203., 228.)/255.,\n                    200.);\n    vec3 v = -ray.V;\n    vec3 l = normalize(light.pos - p);\n    vec3 l2 = normalize(light2.pos - p);\n    float distance_ = length(light.pos-p);\n    float distance2_ = length(light2.pos-p);\n    distance_ *= distance_;\n    distance2_ *= distance2_;\n    \n    //diffuse\n    float costheta = max(dot(n, l), 0.);\n    float costheta2 = max(dot(n, l2), 0.);\n    vec3 diffuse = material.diffuseColor*costheta*material.diffusePower;\n    vec3 diffuse2 = material.diffuseColor*costheta2*material.diffusePower;\n    \n    //specular, ref: https://en.wikipedia.org/wiki/Blinn%E2%80%93Phong_reflection_model#Fragment_shader\n    vec3 specular = vec3(0.); \n    vec3 specular2 = vec3(0.); \n    if(costheta > 0.) {\n        specular = material.specularColor;\n        vec3 h = normalize(v+l);\n        float specular_angle = clamp(dot(h, n), 0., 1.);\n        specular *= pow(specular_angle, material.roughness);\n        specular *= light.color;\n        specular *= light.power;\n        specular /= distance_;\n    }\n    \n    if(costheta2 > 0.) {\n        specular2 = material.specularColor;\n        vec3 h2 = normalize(v+l2);\n        float specular_angle2 = clamp(dot(h2, n), 0., 1.);\n        specular2 *= pow(specular_angle2, material.roughness);\n        specular2 *= light2.color;\n        specular2 *= light2.power;\n        specular2 /= distance2_;\n    }\n    \n    \n    //shadow\n    \n    Ray shadowray;\n    SphereTraceDesc params = SphereTraceDesc(0.006, 64);\n    shadowray.Tmax= 500.;\n    shadowray.Tmin=0.5;\n    shadowray.P = p + 0.02*(n+l);\n    shadowray.V = normalize(light.pos-shadowray.P);\n    TraceResult shadow_t = sphere_trace(shadowray, params);\n    \n    float shadow = 1.;\n    if(shadow_t.T < distance(light.pos, shadowray.P))\n        shadow = 0.7; // nicer than 0.\n        \n    Ray shadowray2;\n    shadowray2.Tmax= 500.;\n    shadowray2.Tmin=0.5;\n    shadowray2.P = p + 0.02*(n+l2);\n    shadowray2.V = normalize(light2.pos-shadowray2.P);\n    TraceResult shadow_t2 = sphere_trace(shadowray2, params);\n    \n    float shadow2 = 1.;\n    if(shadow_t2.T < distance(light2.pos, shadowray2.P))\n        shadow2 = 0.7; // nicer than 0.\n    \n        \n    //reflection\n    vec3 reflectionColor = vec3(0.);\n    vec3 toReflect = normalize(reflection(-l, n));\n    float refcostheta = dot(toReflect, v);\n    refcostheta = clamp(refcostheta, 0.0, 1.0);\n    \n    \n    Ray reflectionray;\n    reflectionray.Tmax= 500.;\n    reflectionray.Tmin=.5;\n    reflectionray.P = p + 0.02*(n+toReflect);\n    reflectionray.V = toReflect;\n    TraceResult reflection_t = sphere_trace(reflectionray, params);\n\n    if(bool(reflection_t.flags & 1))\n        if(material.metalness>.3)\n            reflectionColor = missColor(reflectionray).xyz;\n        else \n            reflectionColor=material.diffuseColor;\n    else if(bool(reflection_t.flags&2))\n        reflectionColor = materials[reflection_t.material].diffuseColor*\n                            materials[reflection_t.material].diffusePower;\n    else\n        reflectionColor = errorColor(reflectionray, reflection_t.T).xyz;    \n    reflectionColor*=refcostheta;\n    \n    // reflection 2\n    vec3 reflectionColor2 = vec3(0.);\n    vec3 toReflect2 = normalize(reflection(-l2, n));\n    float refcostheta2 = dot(toReflect2, v);\n    refcostheta2 = clamp(refcostheta2, 0.0, 1.0);\n    \n    Ray reflectionray2;\n    reflectionray2.Tmax= 500.;\n    reflectionray2.Tmin=.5;\n    reflectionray2.P = p + 0.02*(n+toReflect2);\n    reflectionray2.V = toReflect2;\n    TraceResult reflection_t2 = sphere_trace(reflectionray2, params);\n\n    if(bool(reflection_t2.flags & 1))\n        if(material.metalness>.3) \n            reflectionColor2 = missColor(reflectionray2).xyz; \n        else \n            reflectionColor2=material.diffuseColor;\n    else if(bool(reflection_t2.flags&2)) \n        reflectionColor2 = materials[reflection_t2.material].diffuseColor*\n                            materials[reflection_t2.material].diffusePower;\n    else\n        reflectionColor2 = errorColor(reflectionray2, reflection_t2.T).xyz;    \n    reflectionColor2*=refcostheta2;\n    \n    \n    vec3 ambient = material.emission*clamp(dot(n, v), 0., 1.);\n    vec3 color_linear = (diffuse + specular);\n    vec3 color_linear2 = (diffuse2 + specular2);\n    \n    color_linear = (1.-material.metalness)*color_linear + material.metalness*reflectionColor;\n    color_linear2 = (1.-material.metalness)*color_linear2 + material.metalness*reflectionColor2;\n    color_linear *= shadow;\n    color_linear += ambient;\n    color_linear2 *= shadow2;\n    color_linear2 += ambient;\n    return vec4(color_linear+color_linear2, 1.);\n    \n    \n}\n\n// ---- CAMERA and EVENTs ----\n// Common key codes (WASD instead of arrows)\n\nconst int KeyLeft  = 65;\nconst int KeyRight = 68;\nconst int KeyUp    = 87;\nconst int KeyDown  = 83;\n\n#define isKeyHeld(k)  (texelFetch(iChannel1, ivec2(k,0), 0).x > 0.)\n\nconst vec3 EyeStartPosition = vec3(-10., 7.,-5.);\n\nRay Camera(vec2 fragCoord, out vec3 eye, out vec2 data2)\n{\n    /*\n        We will use the first 2 pixels of the buffer to store the information we need.\n        Every pixel contains 4 channels (floats), for RGBA. We can exploit this in the following way:\n            pixel0 = (empty, cameraX, cameraY, cameraZ)\n            pixel1 = (empty, empty, U, V)\n        where \n            cameraX, cameraY and cameraZ describe the position of the camera respectively\n            U,V give the current rotation of the camera in spherical coordinates\n\t*/\n    \n    // Ray generation\n    eye = texelFetch(iChannel0, ivec2(0,0), 0).yzw+EyeStartPosition;\t\t// camera position\n    data2 = texelFetch(iChannel0, ivec2(1,0), 0).zw;\t// spherical coordinates\n    vec2 uv\t= abs(data2);\n   \t\n    if(iMouse.z>0. || data2.x >= 0.)\t//mouse held or was held last frame\n        uv += (abs(iMouse.zw)-abs(iMouse.xy))*0.01;\n    \n    vec3 w = vec3(cos(uv.x)*cos(-uv.y),\n                  \t\t\tsin(-uv.y),\n                  sin(uv.x)*cos(-uv.y));\n    vec3 u = normalize(cross(vec3(0,1,0),w));\n\tvec3 v = cross(w,u);\n    \n    vec2 px = (fragCoord/iResolution.xy*2.-1.)*1.*normalize(iResolution.xy);\n    \n    // Keyboard and mouse handling:\n\tfloat speed = 0.2;\n    if (isKeyHeld(KeyLeft )) eye -= u*speed;\n    if (isKeyHeld(KeyRight)) eye += u*speed;\n    if (isKeyHeld(KeyUp   )) eye += w*speed;\n    if (isKeyHeld(KeyDown )) eye -= w*speed;\n    \n    if(iMouse.z>=0.)\t\t//mouse held\n        data2 = abs(data2.xy);\n\telse if(data2.x >= 0.)\t//mouse released\n        data2 = -mod(uv,2.*pi);\n    \n    // Ray generation\n    return Ray(eye,\t\t\t\t\t\t\t//V\n               0.5,\t\t\t\t\t\t\t//minT\n               normalize(w+px.x*u+px.y*v),\t//P\n               500.);\t\t\t\t\t\t//maxT\n}\n\n// ---- MAIN ----\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Generate ray from pixel\n    vec3 eye; vec2 data; // this will be saved into first two pixels\n    Ray ray = Camera(fragCoord, eye, data);\n    // Set epsilon and maximum iteration\n    \n    SphereTraceDesc params = SphereTraceDesc(0.006, 64);\n    \n    // Raytrace\n    TraceResult result = sphere_trace(ray, params);\n    \n    /* //Debug\n\tfragColor=vec4(0.,0.,0.,1.); //debug\n    if(bool(result.flags & 1)) fragColor.r=1.;\n    if(bool(result.flags & 2)) fragColor.g=1.;\n    if(bool(result.flags & 4)) fragColor.b=1.;\n    */\n    if(bool(result.flags & 1))    fragColor = missColor(ray);    \n    else if(bool(result.flags&2)) fragColor = hitColor(ray, result.T, result.material);\n    else \t        \t\t\t  fragColor = errorColor(ray, result.T);\n\n\n    vec4 prev = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    fragColor = 0.3*prev + 0.7*fragColor;\n    fragColor.w = result.T;\n    vec2 uv = fragCoord/iResolution.xy;\n    float x = uv.x;\n    float y = uv.y;\n    /*if((x-.5)*(x-.5)+(y-.5)*(y-.5) > .5*.5) {\n        fragColor.xyz -= vec3(pow(2., max((max(abs(x-.5),abs(y-.5)))/.5, 0.)));\n    }*/\n\n    /*eye.x += .05*sin(iTime);\n    eye.z += .05*cos(iTime);\n    data.x += .01*sin(iTime);\n    data.y += .01*cos(iTime);*/\n\n    // First two pixels are reserved\n    if(fragCoord.x == 0.5 && fragCoord.y == 0.5) // pixel (0,0)\n        fragColor.yzw = eye-EyeStartPosition;\n    if(fragCoord.x == 1.5 && fragCoord.y == 0.5) //pixel (1,0)\n        fragColor.zw = data;\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"","name":"Common","description":"","type":"common"}]}