{"ver":"0.1","info":{"id":"lt2XDm","date":"1444469602","viewed":734,"name":"Terrain Relief","username":"gcordonnier","description":"Simple terrain from distant view with a relief enhancing shader using exagerated ambiant occlusion.\nTested on \"elevated\" map shader (https://www.shadertoy.com/view/MdX3Rr) and standart fbm.","likes":18,"published":1,"flags":16,"usePreview":0,"tags":["terrain","occlusion","distant","relief"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[],"code":"// terrain relief enhancing shader by Guillaume Cordonnier\n\n// key \"r\" stops the rotation\n// key \"a\" moves the terrain\n\nconst float box_x = 1.6; \nconst float box_y = 0.2;\n\nconst int RAY_ITER  = 30;\nconst int RAY_ITER_BW = 20;\nconst float AO_SMALL_PREC = 0.003;\nconst float AO_DIST = 0.1;\nconst int AO_RAY_ITER = 5;\nconst int NUM_RAY_AO = 8;\nconst int NOISE_OCTAVES = 7;\n\nfloat elevated(vec2 p);\nfloat fbm(vec2 p);\n\nbool terrainMoving = false;\nbool rotation = true;\n\nfloat map(vec2 p)\n{\n    if(terrainMoving)\n        p += iTime * vec2(0.1, 0.05);\n    \n    //  *** Choose the map function here ***\n    return elevated(p);\n}\n\n\nvec3 noised( in vec2 x );\n\n\nfloat elevated(vec2 p)\n{\n\tconst mat2 m2 = mat2(0.8,-0.6,0.6,0.8);\n    \n    p = p*3.0+vec2(10.0,-1.0);\n    \n    float a = 0.0;\n    float b = 1.0;\n\tvec2  d = vec2(0.0);\n    for( int i=0; i<NOISE_OCTAVES; i++ )\n    {\n        vec3 n = noised(p);\n        d += n.yz;\n        a += b*n.x/(1.0+dot(d,d));\n\t\tb *= 0.5;\n        p = m2*p*2.0;\n    }\n    return 0.1*a;\n}\n\nfloat fbm(vec2 p)\n{\n    p = p*3.0+vec2(10.0,-1.0);\n    \n    float r = 0.0;\n    float a = 1.0;\n\n    for( int i=0; i<NOISE_OCTAVES; i++ )\n    {\n        vec3 n = noised(p);\n        r+=a*n.x;\n     \ta *= 0.5;\n        p = p*2.0;\n    }\n    return 0.1*r;\n}\n\n\nvec3 noised( in vec2 x )\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n    vec2 u = f*f*(3.0-2.0*f);\n\tfloat a = texture(iChannel0,(p+vec2(0.5,0.5))/256.0,-100.0).x;\n\tfloat b = texture(iChannel0,(p+vec2(1.5,0.5))/256.0,-100.0).x;\n\tfloat c = texture(iChannel0,(p+vec2(0.5,1.5))/256.0,-100.0).x;\n\tfloat d = texture(iChannel0,(p+vec2(1.5,1.5))/256.0,-100.0).x;\n\treturn vec3(a+(b-a)*u.x+(c-a)*u.y+(a-b-c+d)*u.x*u.y,\n\t\t\t\t6.0*f*(1.0-f)*(vec2(b-a,c-a)+(a-b-c+d)*u.yx));\n}\n\nvec2 boxRay(in vec3 ro, in vec3 rd)\n{\n    vec3 i_p = (vec3(box_x, box_y, box_x) - ro ) / rd;\n    vec3 i_m = (-vec3(box_x,0.5*box_y, box_x) - ro ) / rd;\n    \n    vec3 vmin = min(i_p, i_m);\n    vec3 vmax = max(i_p, i_m);\n    \n    // min, max\n    return vec2(max(max(vmin.x, vmin.y), vmin.z),min(min(vmax.x, vmax.y), vmax.z));\n}\n\nfloat castray(in vec3 ro, in vec3 rd)\n{\n    \n    vec2 box = boxRay(ro, rd);\n    \n    if(box.x > box.y || box.y <= 0.0)\n        return -1.0;\n    \n    float mint = box.x;\n    float maxt = box.y;\n    \n    vec3 first = ro + rd*box.x;\n    \n    if(map(first.xz) > first.y)\n        return -2.0;\n    \n\n    \n    float delt = (maxt-mint) / float(RAY_ITER);\n    \n    float lh = 0.0;\n    float ly = 0.0;\n    float t = mint;\n    vec3  p;\n    for(int i = 0; i<RAY_ITER; i++)\n    {\n        t+= delt;\n        p = ro + rd*t;\n        float h = map( p.xz );\n        if( p.y < h )\n        {\n            delt = delt / float(RAY_ITER_BW);\n            for(int j = 0; j<RAY_ITER_BW; j++)\n            {\n                t-= delt;\n                p = ro + rd*t;\n        \t\th = map( p.xz );\n                if( p.y > h )\n            \t\treturn t - delt + delt*(lh-ly)/(p.y-ly-h+lh);\n                lh = h;\n        \t\tly = p.y;\n            }\n        }\n        lh = h;\n        ly = p.y;\n        \n    }\n    \n    return -1.0;\n    \n}\n\n//oat ao_t0;\nfloat ao_factor;\n/*id compute_ao_t0()\n{\n    ao_t0 = AO_DIST / pow(1.0 + AO_DT_FACTOR, float(AO_RAY_ITER-1));\n}*/\nvoid compute_ao_factor()\n{\n    ao_factor = pow(AO_DIST / AO_SMALL_PREC , 1.0/float(AO_RAY_ITER-1))-1.0;\n}\n\n// return lowest ray seeing the sky (angle proportion)\n// rd must be normalized and null in y\nfloat aoray(in vec3 ro, in vec3 rd)\n{\n    \n    float maxt = AO_DIST;\n    \n    float t = AO_SMALL_PREC;\n    vec3 d = rd; // cur highest dir\n\n    for(int i = 0; i<AO_RAY_ITER; i++)\n    {\n        vec3 p = ro + rd*t;\n        p.y = map( p.xz ); // p design the map point\n        float t_d = t/dot(rd, d); // compute dist between vertical at p and ro alog dir\n        vec3 p2 = ro+d * t_d; // and deduce point along d\n        if( p2.y < p.y )\n        {\n            d = normalize(p-ro);\n        } \n        t +=  ao_factor * t;       \n    }\n\n    return acos(d.y)/3.141593;\n    \n}\n\n\n\nfloat ao(vec3 p)\n{\n    float illum = 0.0;\n    \n    float th = 0.0;\n    float dth = float(NUM_RAY_AO) *0.1591549430; // 1 / (2pi)\n    \n    for(int i = 0; i<NUM_RAY_AO; i++)\n    {\n        illum += aoray(p, vec3(cos(th), 0.0, sin(th)));\n        th += dth;\n    }                        \n    \n    return illum / float(NUM_RAY_AO)*2.0-1.0;\n}\n    \n\n// key is javascript keycode\nbool ReadKey( int key, bool toggle )\n{\n\tfloat keyVal = texture( iChannel1, vec2( (float(key)+.5)/256.0, toggle?.75:.25 ) ).x;\n\treturn (keyVal>.5)?true:false;\n}\n\nvec3 render(in vec3 ro, in vec3 rd)\n{\n    float d = castray(ro, rd);\n    \n    if(d<-1.5) // terrain \"dress\"\n        return vec3(0.1);\n    else if(d<0.0) // background\n    {\n        return mix(vec3(0.3, 0.3, 0.3), vec3(0.2, 0.2, 0.4), gl_FragCoord.y/iResolution.y);\n    }\n    vec3 p = ro + d*rd;\n\n    //return ao(p) * mix(vec3(0.5), vec3(0.8), p.y/0.2);\n    return  mix(vec3(0.1, 0.09, 0.08), vec3(0.9, 0.8, 0.7), 0.75*ao(p) + 0.25*min(1.0, p.y/0.2)) ;\n    \n    \n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //mpute_ao_t0();\n    compute_ao_factor();\n    vec2 q = fragCoord.xy/iResolution.xy;\n    vec2 p = -1.0+2.0*q;\n\tp.x *= iResolution.x/iResolution.y;\n    vec2 mo = iMouse.xy/iResolution.xy;\n    \n    float time = 0.0;\n    \n    terrainMoving = ReadKey(65, true); // key 'a'\n    rotation = !ReadKey(82, true); // key 'r'\n    \n    if(rotation)\n        time = iTime;\n    \n\t// camera\t\n\n    vec3 ro = 0.6*vec3( 3.5*cos(0.1*time + 6.0*mo.x), 2.0 + 4.0*mo.y, 3.5*sin(0.1*time + 6.0*mo.x) );\n\tvec3 ta = vec3(0.0, -0.5, 0.0);\n\t\n\t// camera-to-world transformation\n    mat3 ca = setCamera( ro, ta, 0.0 );\n    \n    // ray direction\n\tvec3 rd = ca * normalize( vec3(p.xy,2.0) );\n    \n    vec3 col = render(ro, rd);\n    \n    col = pow( col, vec3(0.4545) );\n    \n    fragColor=vec4( col, 1.0 );\n}","name":"","description":"","type":"image"}]}