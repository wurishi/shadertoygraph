{"ver":"0.1","info":{"id":"DsBGzV","date":"1667848081","viewed":96,"name":"3 body rotational velocity law","username":"neurofuzzy","description":"3 particle system with each particle's velocity being the sum of theta hat * f(r). f(r)=-1/r^(exponent), which can be specified in program variables.","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["physics"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nconst int ntimesteps=400; //timesteps, higher = smaller dt. Computational time \\propto ntimesteps\n//if you're on a workstation change this to ntimesteps=4000, for renders ntimesteps=12000 or higher is even better.\nconst int ss=1; // supersampling. Computational time \\propto ss^2\nconst float scale=6.0; //scale, higher = more zoomed out\nconst float exponent=1.0; //F(r) \\propto -1/r^exponent.\nconst float m1=2.0,m2=3.0,m3=5.0; //\"masses\" of the bodies. Higher = stronger rotation around that particle.\n\nvec4 getFrag(float x1, float y1, float dt, int ntimesteps) {\n\n    float x3=0.0,y3=-1.0,x2=0.0,y2=1.0;\n    //float p3x=0.707,p3y=0.0,p2x=-0.707,p2y=0.0,p1x=0.0,p1y=0.0;\n    float p3x=0.0,p3y=0.0,p2x=0.0,p2y=0.0,p1x=0.0,p1y=0.0;\n    float d12=(x1-x2)*(x1-x2)+(y1-y2)*(y1-y2);\n    float d23=(x2-x3)*(x2-x3)+(y2-y3)*(y2-y3);\n    float d31=(x3-x1)*(x3-x1)+(y3-y1)*(y3-y1);\n    float m=min(d12,d31);\n    \n    for(int i=0;i<ntimesteps;i++){\n        d12=(x1-x2)*(x1-x2)+(y1-y2)*(y1-y2);\n        d23=(x2-x3)*(x2-x3)+(y2-y3)*(y2-y3);\n        d31=(x3-x1)*(x3-x1)+(y3-y1)*(y3-y1);\n        //m=max(m,max(d12,max(d23,d31)));\n        m=max(m,max(d12,max(d23,d31)));\n        //m=min(m,min(d31,d12));\n        //m=min(m,d23);\n        d12=pow(d12,-0.5*(1.0+exponent));\n        d23=pow(d23,-0.5*(1.0+exponent));\n        d31=pow(d31,-0.5*(1.0+exponent));\n        float x1n=x1,x2n=x2,x3n=x3,y1n=y1,y2n=y2,y3n=y3;\n        x1n += dt*(-m2*(y2-y1)*d12-m3*(y3-y1)*d31);\n        y1n += dt*( m2*(x2-x1)*d12+m3*(x3-x1)*d31);\n        x2n += dt*(-m3*(y3-y2)*d23-m1*(y1-y2)*d12);\n        y2n += dt*( m3*(x3-x2)*d23+m1*(x1-x2)*d12);\n        x3n += dt*(-m2*(y2-y3)*d23-m1*(y1-y3)*d31);\n        y3n += dt*( m2*(x2-x3)*d23+m1*(x1-x3)*d31);\n        x1=x1n;x2=x2n;x3=x3n;y1=y1n;y2=y2n;y3=y3n;\n        /* gravitational force\n        p1x += dt* ((x2-x1)*d12+(x3-x1)*d31);\n        p1y += dt* ((y2-y1)*d12+(y3-y1)*d31);\n        p2x += dt* ((x3-x2)*d23+(x1-x2)*d12);\n        p2y += dt* ((y3-y2)*d23+(y1-y2)*d12);\n        p3x += dt* ((x2-x3)*d23+(x1-x3)*d31);\n        p3y += dt* ((y2-y3)*d23+(y1-y3)*d31); \n        x1 += dt*p1x;\n        y1 += dt*p1y;\n        x2 += dt*p2x;\n        y2 += dt*p2y;\n        x3 += dt*p3x;\n        y3 += dt*p3y;*/\n    }\n    \n    //float h=log(m/9.0)/3.0;\n    float h=log(m/2.0)/3.0;\n    return vec4(h,h,h,1.0);;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float totaltime=iTime/3.0;\n    float dt=totaltime/float(ntimesteps);\n    \n   \tvec2 xpos = (fragCoord.xy-iResolution.xy*0.5)*2.0/iResolution.xx;\n    \n    float x1=xpos.x*scale,y1=xpos.y*scale;\n    \n    float dx=2.0*scale/(iResolution.x*float(ss));\n    \n    vec4 fragAverage=vec4(0.0,0.0,0.0,1.0);\n    \n    for(int i=0;i<ss;i++){\n        for(int j=0;j<ss;j++){\n            fragAverage+=getFrag(x1+float(i)*dx,y1+float(j)*dx,dt,ntimesteps);\n        }\n    }\n\n    fragColor = fragAverage/float(ss*ss);\n    \n}\n","name":"Image","description":"","type":"image"}]}