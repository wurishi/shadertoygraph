{"ver":"0.1","info":{"id":"lfcXzj","date":"1714148716","viewed":49,"name":"Transition_Bottom-to-Top_Rotate_","username":"timurko","description":"Transition_Bottom-to-Top_Rotate_6f_16x9","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raytrace","plane"],"hasliked":0,"parentid":"4tBBzG","parentname":"Verbose Raytrace Quad"},"renderpass":[{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define AA 0.003f // anti-aliasing\n\nfloat plane( in vec3 norm, in vec3 po, in vec3 ro, in vec3 rd ) {\n    float de = dot(norm, rd);\n    de = sign(de)*max( abs(de), 0.001);\n    return dot(norm, po-ro)/de;\n}\n\nfloat udRoundBox( vec2 p, vec2 b, float r ) {\n    return length(max(abs(p)-b+r,0.0))-r;\n}\n\nmat3 getRotationMatrix(vec3 rotation) {\n    float cx = cos(rotation.x); float sx = sin(rotation.x);\n    float cy = cos(rotation.y); float sy = sin(rotation.y);\n    float cz = cos(rotation.z); float sz = sin(rotation.z);\n    mat3 rx = mat3(1, 0, 0, 0, cx, -sx, 0, sx, cx);\n    mat3 ry = mat3(cy, 0, sy, 0, 1, 0, -sy, 0, cy);\n    mat3 rz = mat3(cz, -sz, 0, sz, cz, 0, 0, 0, 1);\n    return rz * ry * rx;\n}\n\nvec2 raytraceTexturedQuad(in vec3 rd, in float quadOriginZ, in float quadOffsetZ, in vec3 quadRotation, in vec2 quadDimensions) {\n    mat3 RotationMatrix = getRotationMatrix(quadRotation);\n    // Creating scaling matrix\n    mat3 ScaleMatrix = mat3(quadDimensions.x, 0, 0,\n                            0, quadDimensions.y, 0,\n                            0, 0, 1);\n    // Complete transformation matrix\n    mat4 transform = mat4(ScaleMatrix * RotationMatrix);\n    transform[3][3] = 1.0; // Additional element for conversion to mat4\n    \n    // Calculating the normal to the plane\n    vec3 right = vec3(transform[0].x, transform[1].x, transform[2].x);\n    vec3 up = vec3(transform[0].y, transform[1].y, transform[2].y);\n    vec3 normal = cross(right, up);\n    normal /= length(normal);\n    //\n    // Parameters for the plane\n    vec3 ro = vec3(0);\n    vec3 quadOffset = vec3(0,0, quadOffsetZ);\n    vec3 quadOrigin = vec3(0,0, quadOriginZ);\n    // Finding the hit position on the plane in space\n    float isPlane = plane(normal, quadOffset, ro, rd);\n    vec3 pos = (rd * isPlane) - quadOrigin;\n    \n    // Find the texture UV by projecting the hit point along the plane directions\n    return vec2(dot(pos, right) / dot(right, right),\n                dot(pos, up)    / dot(up,    up)) + 0.5;\n}\n\n#define fov 60.0\n#define PI 3.14159265359\n#define H_PI 1.5707963268\n\nfloat planeMask(in vec3 rd, in float quadOriginZ, in float quadOffsetZ, in vec3 quadRotation, in float aspectRatio, in float tan_half_fov) {\n    vec2 planeDimension = vec2(-aspectRatio, 1.0);\n    float quadOffsetZ_corrected = quadOffsetZ / (tan_half_fov * 2.0);\n    vec2 uv = raytraceTexturedQuad(rd, quadOriginZ, quadOffsetZ_corrected, quadRotation, planeDimension);\n\n    /// Calculate smooth transition for each axis\n    //float smoothX = smoothstep(0.5 + AA, 0.5, abs(uv.x - 0.5));\n    //float smoothY = smoothstep(0.5 + AA, 0.5, abs(uv.y - 0.5));\n\n    // Combine results for both axes\n    //float rect_mask = smoothX * smoothY;\n    \n    vec2 p = (2.0 * uv) - 1.0;\n    return 1.0f - smoothstep(0.0, AA, udRoundBox(p, vec2(1.0), 0.00f));\n}\n\nvec3 planeUV(in vec3 rd, in float quadOriginZ, in float quadOffsetZ, in vec3 quadRotation, in float aspectRatio, in float tan_half_fov, in float roundness) {\n    vec2 planeDimension = vec2(-aspectRatio, 1.0);\n    float quadOffsetZ_corrected = quadOffsetZ / (tan_half_fov * 2.0);\n    vec2 uv = raytraceTexturedQuad(rd, quadOriginZ, quadOffsetZ_corrected, quadRotation, planeDimension);\n    vec2 p = (2.0 * uv) - 1.0;\n    float mask = 1.0f - smoothstep(0.0, AA, udRoundBox(p, vec2(1.0), roundness));\n    return vec3(uv, mask);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    //Screen UV goes from 0 - 1 along each axis\n    vec2 texUV = fragCoord/iResolution.xy;\n    float aspectRatio = iResolution.x/iResolution.y;\n    \n    // Convert FOV to radians and calculate the tangent of half the angle\n    float tan_half_fov = tan(radians(fov) / 2.0);\n    \n    // Calculate screen coordinates\n    vec2 p = (2.0 * texUV) - 1.0; // Convert texUV from [0,1] to [-1,1]\n    p.x *= aspectRatio * tan_half_fov; // Account for aspect ratio and FOV for x\n    p.y *= tan_half_fov; // Account for FOV for y\n    \n    // Normalized ray direction\n    vec3 dir = normalize(vec3(p.x, p.y, 1.0)); // Vector directed along -Z\n\n    //Define the plane\n    vec3 planeRotation = vec3(cos(iTime) * 0.2, 0.0-PI, 0.0);\n    float aMask = planeMask(dir, -4.0, -0.8f, planeRotation, aspectRatio, tan_half_fov);\n    vec3 aUV = planeUV(dir, 1.0, 1.0f, planeRotation, aspectRatio, tan_half_fov, 0.08f);\n    fragColor = texture(iChannel0, aUV.xy) * aUV.z;\n    fragColor *= vec4(aMask);\n}","name":"Image","description":"","type":"image"}]}