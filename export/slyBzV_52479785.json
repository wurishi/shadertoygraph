{"ver":"0.1","info":{"id":"slyBzV","date":"1664836463","viewed":240,"name":"Decorated Mandelbrot and Julia","username":"PhDFractal","description":"Simulation of a mini-Mandelbrot using conformal transformation of Mandelbrot Set with bailout=1½×zoom. Equivalent to Julia morphing, but with said zoom and bailout.\nOne of my videos using this technique: https://www.youtube.com/watch?v=DUR-ljW5uU8.","likes":6,"published":1,"flags":16,"usePreview":0,"tags":["fractal","julia","mandelbrot","algorithm"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"////////////////////////////////////////////////////////////////////////////////\n//\n// Decorated Mandelbrot Set\n//\n// AMAZING: Julia morphing and Minijulia decoration are equivalent!\n//\n// Repeated Juliation will yield Julia morphing. When original Mandelbrot is\n// zoomed inward and we take \"bailout\"=1½×zoom, it becomes a decorated Julia Set.\n// Defines a simulation to minijulia of actual zoom. When using the Mandelbrot\n// transformation, it becomes a decorated Mandelbrot Set, simulation to minibrot.\n//\n// Julia Morphing artifact: if the filament zoom is not deep enough to take 1 color\n// (e.g. black only for minibrot), then the resulting minijulia components may\n// be colored differently according to orbit number, or the filaments may not\n// vanish at all (Siegel disk). This is more apparent in the decorated Mandelbrot\n// where in the cardioid the derivative stays, so the filaments are there forever.\n//\n// Press 'j' for Julia, and 'j' again to return. Original bailout for filaments is 4.\n//\n// Relative location is (0.259635,0.001516): 32nd Elephant Minibrot of period 33.\n//\n// Other mode location is (-1.78,1e-6): emphasizes some features will remain in the\n// minibrot, and the Julia color will change rapidly. The decorations are exact only\n// when the original zoom ends in the interior of a minibrot, or in the interior of\n// an iteration band, in which the minijulia/minibrot will be that color.\n//\n// Decorations are general for any power 3,4,5,..., although 2 provides the most details.\n//\n// Realized this as coloring algorithm in 2019 February, as transformation in 2022 September.\n// Kawahira and Kisaka 2018 already realized this mathematically for actual minibrots.\n// However, the connection to Julia morphing and using Mandelbrot map as coloring algorithm is new.\n// Source: researchgate.net/publication/324167237_Julia_sets_appear_quasiconformally_in_the_Mandelbrot_set\n// \n////////////////////////////////////////////////////////////////////////////////\n\n// Created by Fractal MathPro: https://www.youtube.com/channel/UCY-W4FvxaNRoZ8N5b-KzSZg\n// MathFractal: https://math.stackexchange.com/users/1013522/mathfractal\n// I share this piece (art and code) here in Shadertoy and through its Public API,\n// only for educational purposes. You cannot use, sell, share or host this piece\n// or modifications of it as part of your own commercial or non-commercial product\n// website or project. You cannot use, sell, share or host this piece or modifications\n// of it as part of your own commercial or non-commercial product, website or project.\n// You can share a link to it or an unmodified screenshot of it provided you attribute\n// \"by PhdFractal\".\n\nbool keypress(int code){ return texelFetch(iChannel0,ivec2(code,2),0).x != 0.0; }    //for switching modes\nvec4 rainbow(float i,float density){                                                 //rainbow palette\n    vec4 black=vec4(0.,0.,0.,1.); vec4 red=vec4(1.,0.,0.,1.); vec4 yellow=vec4(1.,1.,0.,1.);\n    vec4 green=vec4(0.,1.,0.,1.); vec4 cyan=vec4(0.,0.698,1.,1.); vec4 blue=vec4(0.,0.,1.,1.);\n    float r=(i*density+0.)-100.*floor((i*density+0.)/100.); float R=0.;\n    if(r<16.){ R=r/16.; return R*red+(1.-R)*black; }\n    else if(r>=16. && r<31.){ R=(r-16.)/15.; return R*yellow+(1.-R)*red; }\n    else if(r>=31. && r<45.){ R=(r-31.)/14.; return R*green+(1.-R)*yellow; }\n    else if(r>=45. && r<62.){ R=(r-45.)/17.; return R*cyan+(1.-R)*green; }\n    else if(r>=62. && r<78.){ R=(r-62.)/16.; return R*blue+(1.-R)*cyan; }\n    else{ R=(r-78.)/22.; return R*black+(1.-R)*blue; }\n}\nvec2 sqr(vec2 z){ return vec2(z.x*z.x-z.y*z.y,2.*z.x*z.y); }                         //square\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord)\n{\n    vec2 seed=4.*vec2(iMouse.x-.5*iResolution.x,iMouse.y-.5*iResolution.y)/iResolution.x;\n    bool julia=keypress(74); vec4 color=vec4(0.,0.,0.,1.);  //Press key 'j' for julia\n    bool mode=keypress(77);                                 //Press key 'm' to switch mode\n    float bail=0.; float zoom=0.; vec2 center=vec2(0.,0.);\n    if(!mode){ bail=3.6e5; zoom=2.4e5; center=vec2(0.259635,0.001516); }\n    else{ bail=3e2; zoom=2e2; center=vec2(-1.78,1e-6);  } //Specific minijulias\n    vec2 pix =4.*(fragCoord/iResolution.x-.5*vec2(1,iResolution.y/iResolution.x));\n    vec2 pix0=4.*(fragCoord/iResolution.x-.5*vec2(1,iResolution.y/iResolution.x));\n    \n    if(!julia){ for(int i=0; i<250; i++){ if(dot(pix,pix)<=bail){ pix=sqr(pix)+pix0; } } }\n    else{ for(int i=0; i<500; i++){ if(dot(pix,pix)<=bail){ pix=sqr(pix)+seed; } } }\n    pix=sqr(pix/zoom)+center;                 //transformation decorative\n\n    vec2 z0=vec2(0.,0.); vec2 z=vec2(0.,0.);  //iteration actual\n    for(int i=0; i<800; i++){ z=sqr(z0)+pix; if(dot(z,z)>4.){ color=rainbow(float(i),3.2); break;} else{ z0=z; } }\n    fragColor=color;\n}","name":"Image","description":"","type":"image"}]}