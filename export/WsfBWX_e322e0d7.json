{"ver":"0.1","info":{"id":"WsfBWX","date":"1589147137","viewed":667,"name":"Monte Carlo RWoS GI","username":"spalmer","description":"simple GI using emissive volumetric light sources using random walk on spheres technique\nbased on a toy by blackle, currently just mostly a scene & camera remix","likes":12,"published":1,"flags":32,"usePreview":0,"tags":["illumination","lighting"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// just gamma corrects and dithers BufferA.rgb for presentation\n// could use more denoising somehow\nvoid mainImage(out vec4 fragColor, vec2 fragCoord)\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    fragColor = vec4(sqrt(texture(iChannel0, uv).rgb) \n        + .5/256.*hash(hash(uv.x,uv.y),iTime)\n        , 1);\n}\n\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// prevent unrolling with uniform\n#define IZERO min(0,iFrame)\n\nconst float pi = acos(-1.); //3.1415927;\n\n// blackle has lots of tricks! see https://suricrasia.online/demoscene/functions/\n\n// nice hash! wack! but probably just crazy enough to work!\n\n#define FK(k) floatBitsToInt(cos(k))^floatBitsToInt(k)\n// fairly sure this hash returns *signed* values, unsure about range, actually\nfloat hash(float a, float b) {\n    int x = FK(a);int y = FK(b);\n    return float((x*x-y)*(y*y+x)-x)/2.14e9;\n}\n\nvec2 rndvec2(float seed, int i) {\n    float h1 = hash(seed, float(i));\n    float h2 = hash(h1, float(i));\n    return vec2(h1,h2);\n}\n\nvec3 rndvec3(float seed, int i) {\n    float h1 = hash(seed, float(i));\n    float h2 = hash(h1, float(i));\n    float h3 = hash(h2, float(i));\n    return vec3(h1,h2,h3);\n}\n\n// actually nice little Rodrigues' formula example, blackle!  tight.\nvec3 erot(vec3 p, vec3 ax, float ro) \n{\n    return mix(dot(ax, p) * ax, p, cos(ro)) + sin(ro) * cross(ax, p);\n}\n\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// based on a toy by blackle https://shadertoy.com/view/Wsffzl\n// which is based on a paper by Crane and Sawhney:\n// http://cs.cmu.edu/~kmcrane/Projects/MonteCarloGeometryProcessing/paper.pdf\n// also see https://wikipedia.org/wiki/Walk-on-spheres_method\n// and https://wikipedia.org/wiki/Wiener_process\n// I also was working on this over here in 2D: https://shadertoy.com/view/wdlfDB\n// but it's not quite ready, trying subsurface stuff lol\n// and maybe light transport, still trying to crawl though.\n\n#define METAL      0.\n#define SMOOTHNESS 2.\n// I don't yet understand.  tangent?  really?!\n\nconst vec3\n  csky = vec3(.2,.4,.6)*1.8\n, clite = vec3(1,1,0)*1.4\n;\n\n// a bouncing yellow ball light source\nfloat dlight(vec3 p)\n{\n    const float r = .35, h = .6;\n    float ds = length(p - vec3(1,abs(sin(iTime*.9))*h+r,-1.)) - r;\n    return max(0., ds);  \n}\n\nfloat scene(vec3 p)\n{\n    float dl = dlight(p)\n        , ds = distance(p, vec3(-1,.7,0))-.7\n        , dp = p.y;\n    return min(dl,min(ds, dp));\n}\n\nvec3 distribSphere(vec2 uv)\n{\n    uv = fract(uv);\n    uv.y = uv.y * 2. - 1.;\n    return vec3(sqrt(max(0., 1. - uv.y*uv.y))\n                * sin(vec2(.5*pi, 0) + uv.x * 2.*pi)\n                , uv.y);\n}\n\nvec3 randomOnSphere(float seed, int i, vec3 bias)\n{\n#if 1 \n    // something more uniformly distributed - if I can ever understand hash!\n    // ahh need tan for gaussian distrib but maybe I can reformulate\n    // or cube root of another hashvalue for uniform ball distribution\n    // btw my hashes are *not* truly decorrelated \n    vec2 h = rndvec2(seed, i+17); //h = h.y * 2. - 1.;\n    return normalize(\n        distribSphere(h) + bias * SMOOTHNESS\n        );\n#else\n    // the tan trick, ahh.  honestly, without normalizing, I have no idea how it works!\n    // I have a feeling it's brighter simply because quite a lot more\n    // cases wind up finding nothing due to sluggish motion due to not taking the full step it could,\n    // resulting in more iterations needed, and more failure cases treated as sky.\n    // anyway I redid it, now it's not nearly so clever as blackle's original\n    // and I'm not sure I can put it back how it was, at this point.  Hrm.\n    // but I got it to look almost the same as mine! I guess that's something.\n    vec3 rnd = rndvec3(seed,i) + rndvec3(seed,i+55) + rndvec3(seed,i+99);\n    rnd /= 3.;\n    // https://shadertoy.com/view/3djyWW\n    // also see comment by blackle, tyvm\n    return normalize((normalize(tan(rnd)) + bias * SMOOTHNESS)); // why tan?!!  blackle, why?\n#endif\n}\n\nvec3 scenecol(vec3 p) \n{\n    float r = dlight(p);\n    if (r < .005) return clite; // bright yellow/white\n    if (p.y > 3.) return csky; // sky ambient\n    return vec3(.0); // dim gray/black - non-emissive\n}\n\n// blackle's clever matrix way of writing this differential:\nvec3 normal(vec3 p)\n{\n    mat3 k = mat3(p,p,p) - mat3(0.001);\n    return normalize(scene(p) - vec3(scene(k[0]),scene(k[1]),scene(k[2])));\n}\n\n\n\n// random walk on spheres\nvec3 rwos(vec3 p, float seed, vec3 bias) \n{\n    vec3 init = p;\n    for (int i = 32+IZERO; --i >= 0; ) {\n        float dist = scene(p);\n        if (dist*dist < 1e-6) break; // at surface\n        vec3 jump = randomOnSphere(seed, i, bias);\n        p += jump * dist;\n    }\n    return scenecol(p);\n}\n\nvec2 StoQ(vec2 s)\n{\n   \tvec2 r = iResolution.xy;\n   \treturn (s - r*.5)/r.y;\n}\n\n// all this is blackle's, really, marcher,\n// main loop, everything.  I just reformatted a little so far.\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy\n    , q = StoQ(fragCoord)\n    , mouse = StoQ(iMouse.xy);\n\n    vec3 cam = normalize(vec3(q,1))\n    , init = vec3(0,0,-4);\n\n    float xrot = .25\n    , yrot = 0.; //iTime*0.3; //3.7; //\n    if (iMouse.z > 0.) {\n        xrot += 1.-2.*mouse.y; //(mouse.y * -.5 + .5);\n        yrot +=  4.*mouse.x;\n    }\n    cam  = erot(cam,  vec3(1,0,0), xrot);\n    init = erot(init, vec3(1,0,0), xrot);\n    cam  = erot(cam,  vec3(0,1,0), yrot);\n    init = erot(init, vec3(0,1,0), yrot);\n    \n    vec3 p = init;\n    bool hit = false;\n    // initial depth raymarch (along ray)\n    for (int i = 128 + IZERO; i-- > 0 && !hit; ) {\n        float dist = scene(p);\n        hit = dist*dist < 1e-6;\n        p += dist*cam;\n    }\n\n    vec3 color = vec3(0);\n    float seed = hash(iTime, hash(uv.x,uv.y));\n    // area lighting\n    if (hit) {\n        vec3 n = normal(p);\n   \t\tvec3 r = reflect(cam, n);\n    \tvec4 smp = vec4(0);\n        vec3 bias = mix(n, r, METAL) * .2;\n        int nsamp = max(4,int(2000./iResolution.y)) + IZERO;\n    \tfor (int i = nsamp; i-- > 0; ) {\n        \tfloat seed2 = hash(float(i), seed);\n        \tsmp.rgb += rwos(p + n*.01, seed2, bias).rgb;\n    \t}\n        color = smp.rgb/float(nsamp) + scenecol(p) * .6;\n    } else {\n        color = csky;\n    }\n    fragColor = vec4(color,1);\n    vec3 prev = texture(iChannel0, uv).rgb;\n    fragColor.rgb = mix(fragColor.rgb, prev\n        , exp2((iMouse.z > 0. ? -25. : -12.)*iTimeDelta));\n}\n\n","name":"Buffer A","description":"","type":"buffer"}]}