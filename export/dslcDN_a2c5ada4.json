{"ver":"0.1","info":{"id":"dslcDN","date":"1686838262","viewed":84,"name":"Offgrid","username":"joeydee","description":"Offgrid algorithm, creating irregular looking rectangles from a regular quad grid\nalgorithm by Chris Cox https://gitlab.com/chriscox/offgrid","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["rectangles","grid","offgrid"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//just experimenting ...\n//gtz joeydee\n\n\n//simple 2d sinus noise\nfloat rand(vec2 n) {\n    return fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\n\n\n//get the divider value of a grid cell\nfloat getDivider(vec2 q){\n    float b=sin(iTime)*0.5+0.5;//animate offset value\n    float r=rand(q);\n    r=r*(1.0-b*2.0)+b;\n    return r;\n}\n\n//point-to-rect transformation\n//and rect-to-grid mapping for rect color lookup\nvec4 getRectColor(vec2 p){\n    vec2 q=floor(p);\n    vec2 frac=p-q;\n    bool even=(int(q.x+q.y)%2)==0;\n    float div=getDivider(q);\n    vec2 lookup=q;\n    float div2;\n    float checker=0.0;//initial integer checkerboard\n    if(even){\n        //h divider\n        checker=0.9;\n        if(frac.y<div){//above h divider\n            div2=getDivider(floor(q+vec2(0,-0.5)));//use upper v divider\n        }\n        else{//below h divider\n            div2=getDivider(floor(q+vec2(0,1.5)));//use lower v divider\n            lookup.y+=1.0;\n        }\n        if(frac.x>div2)lookup.x+=1.0;//right of v divider\n\n    }\n    else{\n        //v divider\n        checker=1.0;\n        if(frac.x<div){//left of v divider\n            div2=getDivider(floor(q+vec2(-0.5,0)));//use left h divider\n        }\n        else{//right of v divider\n            div2=getDivider(floor(q+vec2(1.5,0)));//use right h divider\n            lookup.x+=1.0;\n        }\n        if(frac.y>div2)lookup.y+=1.0;//below h divider\n    }\n    \n    checker=(int(iTime/6.282)%2)==0?checker:1.0;//toggle checker\n    //rect color lookup\n    float r=rand(lookup*2.1);\n    float g=rand(lookup*3.5);\n    float b=rand(lookup*4.3);\n    return vec4(r*checker,g*checker,b*checker,1);//rect color + checker\n}\n\n//main\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = fragCoord/iResolution.xx*15.0;//scale\n    vec4 col=getRectColor(p);\n    fragColor=col;\n}\n\n\n","name":"Image","description":"","type":"image"}]}