{"ver":"0.1","info":{"id":"fdXfzH","date":"1644462611","viewed":190,"name":"Nodes and Lines","username":"TheHarmacist","description":"Followed a tutorial made by user BigWIng","likes":4,"published":1,"flags":64,"usePreview":0,"tags":["futuristic"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XtfSDf","filepath":"https://soundcloud.com/celldweller/pulsar?utm_source=clipboard&utm_medium=text&utm_campaign=social_sharing","previewfilepath":"https://soundcloud.com/celldweller/pulsar?utm_source=clipboard&utm_medium=text&utm_campaign=social_sharing","type":"musicstream","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define S(a, b, t) smoothstep(a,b,t)\n\nfloat DistLine(vec2 p, vec2 a, vec2 b)\n{\n    vec2 pa = p-a;\n    vec2 ba = b-a;\n    float t = clamp(dot(pa, ba)/dot(ba, ba),0.0,1.0);\n    return length(pa-ba*t);\n}\n\nfloat N21(vec2 p)\n{\n    p = fract(p*vec2(562.54, 853.12));\n    p += dot(p, p+213.85);\n    return fract(p.x*p.y);\n}\n\nvec2 N22(vec2 p)\n{\n    float n = N21(p);\n    return vec2(n, N21(p+n));\n}\n\nvec2 GetPos(vec2 id, vec2 offset)\n{\n    vec2 n = N22(id+offset)*iTime;\n    return offset+sin(n)*0.4;\n}\n\nfloat Line(vec2 p, vec2 a, vec2 b)\n{\n\n    float d = DistLine(p,a,b);\n    float m = S(0.03, 0.005, d);\n    float d2 = length(a-b);\n    m*= S(1.2,0.8,d2)*0.2 + S(0.05,0.03, abs(d2-0.75));\n    return m;\n}\n\nfloat Layer(vec2 uv)\n{\n    float m = 0.0;\n    vec2 gv = fract(uv)-0.5;\n    vec2 id = floor(uv);\n    \n    vec2 p[9];\n    int i = 0;\n    for(float y = -1.0;y<=1.0;y++)\n    {\n       for(float x=-1.0;x<=1.0;x++)\n       {\n           p[i++] = GetPos(id, vec2(x,y));\n       }\n    }\n    float t = iTime*10.0;\n    for(int i =0;i<9;i++)\n    {\n        m+= Line(gv, p[4], p[i]);\n        vec2 j = (p[i] - gv)*20.0;\n        float sparkle = 1.0/(dot(j,j));\n        m+= sparkle*(sin(t+fract(p[i].x)*10.0)*0.5+0.5);\n        \n    }\n    m+= Line(gv, p[1], p[3]);\n    m+= Line(gv, p[1], p[5]);\n    m+= Line(gv, p[7], p[3]);\n    m+= Line(gv, p[7], p[5]);\n    return m;\n    }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    \n    //float d = DistLine(uv, vec2(0), vec2(1));\n    \n    vec2 mouse = (iMouse.xy/iResolution.xy)-0.5;\n    float t = iTime*0.05;\n    float m = 0.0;\n    \n    float rotScale = 5.0;\n    float s = sin(t*rotScale);\n    float c = cos(t*rotScale);\n    //add some offset to rotScale for bobbing: 1.0-5.0)\n    \n    float gradient = uv.y;\n    mat2 rot = mat2(c,-s, s, c);\n    uv*=rot;\n    mouse*=rot;\n    \n    for(float i=0.0;i<1.0;i+=1.0/4.0)\n    {\n        float z = fract(i+t);\n        float size = mix(10.0, 0.5,z);\n        float fade =  S(0.0, 0.5, z)*S(1.0, 0.8,z); \n        m += Layer(uv*size+i*20.0-mouse)*fade;\n    }\n    \n    vec3 base = sin(t*20.0*vec3(0.235, 0.69, 0.53))*0.4+0.6;\n    vec3 col = m*base;\n    float fft = texelFetch(iChannel0, ivec2(0.0,0.0),0).x;\n    gradient*=fft*2.5;\n    col-=gradient*base;\n    //col.rg= id*0.2;\n    \n    /*if(gv.x>0.48||gv.y>0.48)\n    {\n        col=vec3(1,0,0);\n    }*/\n    \n    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}