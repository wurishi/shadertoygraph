{"ver":"0.1","info":{"id":"XdBBDV","date":"1503365849","viewed":426,"name":"Directional Light & Shadows","username":"Sheado","description":"Mouse to pan left/right.\n\nJust practicing directional lighting, shadows, and raymarching.\n","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raymarch","shadows","blinnphong","directionallight"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sX3zn","filepath":"/media/a/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png","previewfilepath":"/media/ap/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/**\n * Practicing directional light & shadows. \n * Some references I followed:\n *\thttps://learnopengl.com/#!Lighting/Basic-Lighting\n *\thttps://iquilezles.org/articles/distfunctions\n *  https://learnopengl.com/#!Advanced-Lighting/Advanced-Lighting \n */\nconst float EPSILON = 0.005;\nconst int maxSteps = 64;\nconst float PI = 3.1415926;\n\nfloat sdCone( vec3 p, vec2 c )\n{\n    // c must be normalized\n    float q = length(p.xy);\n    return dot(c,vec2(q,p.z));\n}\n\nfloat sdPlane( vec3 p )\n{\n  return p.y;\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat udBox( vec3 p, vec3 b )\n{\n  return length(max(abs(p)-b,0.0));\n}\n\nfloat sdEllipsoid( in vec3 p, in vec3 r )\n{\n    return (length( p/r ) - 1.0) * min(min(r.x,r.y),r.z);\n}\n\n/**\n * the camera\n */ \nmat3 getView(vec3 position, vec3 target)\n{\n    vec3 cameraDirection = normalize(target-position);\t// technically the reverse direction\n    vec3 up = vec3(0, 1, 0);\t\t\t\t\t\t\t// world up\n    vec3 cameraRight = normalize(cross(up, cameraDirection));\t\n    vec3 cameraUp = cross(cameraDirection, cameraRight);\n                                 \n\tmat3 view = mat3(cameraRight, cameraUp, cameraDirection);\n \treturn view;\n}\n\n\n/**\n * https://learnopengl.com/#!Getting-started/Transformations\n */\nmat4 rotate(float theta, vec3 a /*axis*/) {\n    float c = cos(theta);\n    float ic = 1. - c;\n    float s = sin(theta);\n    float is = 1. - s;\n\n    return mat4(\n        vec4(c+a.x*a.x*ic, \t\ta.x*a.y*ic-a.z*s, \ta.x*a.z*ic+a.y*s, \t0),\n        vec4(a.y*a.x*ic+a.z*s, \tc+a.y*a.y*ic, \t\ta.y*a.z*ic-a.x*s, \t0),\n        vec4(a.z*a.x*ic-a.y*s, \ta.z*a.y*ic+a.x*s, \tc+a.z*a.z*ic, \t\t0),\n        vec4(0, \t\t\t\t0, \t\t\t\t\t0,\t\t\t\t\t1)\n    );\n}\n\nfloat drawScene(vec3 p, out int id)\n{\n    vec3 position = p + vec3(-1.5,-1.,-3.+2.*sin(iTime));\n    float dt = \tsdSphere(position,.5);\n    id = 0;\n    float d;\n    \n    position = p + vec3(2.5*sin(iTime),-2.5,0.);\n    vec3 ppp = (rotate(PI*.25+.25*sin(iTime),vec3(1.,0.,0.)) * vec4(position,1.)).xyz;\n    d = sdTorus( ppp, vec2(1.,.2) );\n    if( d < dt )\n    {\n        dt = d; \n        id = 1;\n    }\n\n    position = p + vec3(3.*cos(iTime),-1.0,0.);\n    d = udBox( position,vec3(.5) );\n    if( d < dt )\n    {\n        dt = d; \n        id = 2;\n    }\n\n    position = p + vec3(2.,-.7,-2.5);\n    d = sdEllipsoid( position, vec3(.3,1.5,1.) );\n    if( d < dt )\n    {\n        dt = d; \n        id = 3;\n    }\n\n    // floor\n    position = p + vec3(0.,1,0.);\n    d = udBox( position,vec3(10.,.0,10.5) );\n\t//    d = sdPlane(position);\n    if( d < dt )\n    {\n        dt = d; \n        id = 4;\n    }\n    \n    // wall\n    position = p + vec3(0.,0.,1.7);\n    d = udBox( position,vec3(10.,10.0,0.5) );\n\t//    d = sdPlane(position);\n    if( d < dt )\n    {\n        dt = d; \n        id = 4;\n    }\n\n\n    \n\treturn dt;\n}\n\nfloat drawScene(vec3 p)\n{\tint id;\n    return drawScene(p,id);\n}\n\n\n/**\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        drawScene(vec3(p.x + EPSILON, p.y, p.z)) - drawScene(vec3(p.x - EPSILON, p.y, p.z)),\n        drawScene(vec3(p.x, p.y + EPSILON, p.z)) - drawScene(vec3(p.x, p.y - EPSILON, p.z)),\n        drawScene(vec3(p.x, p.y, p.z  + EPSILON)) - drawScene(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\nvec3 getMaterialColor(int id)\n{\n    vec3 color;\n    switch( id )\n    {\n        case 0:\n        color = vec3(1.,0.,0.);\n        break;\n        case 1:\n        color = vec3(1.,1.,0.);\n        break;\n        case 2:\n        color = vec3(1.,.0,1.);\n        break;\n        case 3:\n        color = vec3(0.,0.,1.);\n        break;\n        case 4:\n        color = vec3(0.,1.,0.);\n        break;\n    }\n    return color;\n}\n\n\n/** \n * Blinn-Phong https://learnopengl.com/#!Advanced-Lighting/Advanced-Lighting \n */ \nvec3 directionalLight(vec3 normalizedNormal, vec3 position, vec3 lightPos, vec3 viewPosition, vec3 color, float shadow)\n{\n    vec3 lightColor = vec3(1.);\n    // ambient\n    vec3 ambient = lightColor * 0.15 * color;\n    \n    vec3 lightDirection = normalize(lightPos-position);\n    vec3 viewDirection = normalize(viewPosition-position);\n\tvec3 halfwayDirection = normalize(lightDirection + viewDirection);\n    \n    // diffuse\n    float diffuseIntensity = max(dot(normalizedNormal, lightDirection),0.0);\n    vec3 diffuse = diffuseIntensity * lightColor * color;\n    \n    // specular\n    float specularStrength = .85;\n    float specularIntensity = pow(max(dot(normalizedNormal, halfwayDirection),0.0),32.);\n    //// going glossy on the specular (no color multiplication)\n    vec3 specular = specularStrength * specularIntensity * lightColor;\t\t\t\t\t\t\n    return (ambient + (diffuse + specular)*(1. - shadow));\n\n    \n}\n\nfloat directionalShadow(vec3 cameraTarget, vec3 modelPosition, vec3 p, vec3 dirLightPos)\n{\n    float shadow = 0.;\n    mat3 dirLightView = getView(dirLightPos, cameraTarget);\n    vec3 dirLightRayDirection = dirLightView * modelPosition;\n\n    float dt = 0., d = 0.;\n    // shadow depth\n    float shadowDepth = length((dirLightPos-p));\n    dirLightRayDirection = normalize(-dirLightPos+p);\n    vec3 shadowPos;\n    for( int i = 0; i < maxSteps; ++i )\n    {\n        vec3 p = dirLightPos + dirLightRayDirection*d;\n        int id;\t// id of object that is being drawn\n        dt = drawScene(p,id);\n        if( dt < EPSILON )\n        {\n            float currentShadowDepth = length((dirLightPos-p));\n            // \n            if( currentShadowDepth/shadowDepth < 1.-EPSILON)\n                shadow = 1.;\t\n            break;\n        }\n        d += dt;\n    }\n    return shadow;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    float aspect = iResolution.x/iResolution.y;\n    uv *= 2.;\n    uv -= 1.;\n    uv.x *= aspect;\n\n    // camera setup\n    vec2 mouse = iMouse.xy/iResolution.xy*2.-1.;\n    if( mouse.x == -1. )\n        mouse.x = 0.;\n    float mx = clamp(mouse.x*2.*PI,-PI*.5,PI*.5);\n    vec3 rayOrigin = vec3(7.*sin(mx), 2., 7.*cos(mx));\n    vec3 cameraTarget = vec3(0.,.0,.0);\n    mat3 view = getView(rayOrigin,cameraTarget);\n    vec3 modelPosition = normalize(vec3(uv,2.));\n    vec3 rayDirection = view * modelPosition;\n    \n    // directional light\n    vec3 dirLightPos = vec3(2.,10.,3.);\n\tmat3 dirLightView = getView(dirLightPos,cameraTarget);\n    vec3 dirLightRayDirection = dirLightView * modelPosition;\n\n    vec3 p;\n    float dt = 0., d = 0.;\n    vec3 color = texture(iChannel0,normalize(rayDirection)).xyz;//vec3(150./255.,150./255.,150./255.)*.6;\n    // shadow depth\n    float shadowDepth = 0.;\n\n    // raymarch\n    dt = 0.;\n    d = 0.;\n    for( int i = 0; i < maxSteps; ++i )\n    {\n        p = rayOrigin + rayDirection*d;\n        int id;\t// id of object that is being drawn\n        dt = drawScene(p,id);\n        if( dt < EPSILON )\n        {\n            color = getMaterialColor(id);\n            float shadow = directionalShadow(cameraTarget, modelPosition, p, dirLightPos);\n            \n            vec3 normal = normalize(estimateNormal(p));\n          \tcolor = directionalLight(normal, p, dirLightPos, rayOrigin, color, shadow);\n            break;\n        }\n        d += dt;\n    }\n\n\tfragColor = vec4(color,1.0);\n}\n","name":"Image","description":"","type":"image"}]}