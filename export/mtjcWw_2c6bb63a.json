{"ver":"0.1","info":{"id":"mtjcWw","date":"1691868833","viewed":54,"name":"Circle through 3 points","username":"Envy24","description":"Drag red point with mouse.","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["circle","3","points","through"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define SCENE_SCALE               ( 1.0 )\n#define UNIT                      ( (SCENE_SCALE*4.0) / iResolution.y  )\n#define SMAA(d)                   ( smoothstep(UNIT, 0., d) )\n\n/* https://www.shadertoy.com/view/DdsGDj */\n#define MOUSE_OFFSET ( iMouse.z > 0. ? iMouse.xy - iResolution.xy * 0.5 : vec2(0) )\nvec2 map_to_centered_ndc(in vec2 SC, in float scale, in vec2 origin, in bool mouse_drag)\n{\n    vec2 M = MOUSE_OFFSET * (mouse_drag == true ? 1. : 0.);\n    return ((2. * (SC - M) - iResolution.xy) / iResolution.y) * scale + origin;\n}\n\n// https://www.shadertoy.com/view/cdjXRG\nfloat cross_2d(vec2 L, vec2 R) { return determinant(mat2(L, R)); }\nvec2 segment_segment_intersection(vec2 P0, vec2 P1, vec2 P2, vec2 P3)\n{\n    vec2 A = P1 - P0, B = P3 - P2, C = P2 - P0;\n    float inv = 1. / cross_2d(A, B);\n    return vec2(\n        cross_2d(C, B)*inv,\n        cross_2d(C, A)*inv);\n}\n\nvoid mainImage( out vec4 O, in vec2 SC )\n{\n    vec2 NDC = map_to_centered_ndc(SC, SCENE_SCALE, vec2(0), false),\n         MP = iMouse.xy == vec2(0) ? vec2(-.78, .1) : \n                 map_to_centered_ndc(iMouse.xy, SCENE_SCALE, vec2(0), false);\n    \n    vec3 color = vec3(1);\n         color = mix( color, vec3(0.8), SMAA(cellsSDF(NDC)) );\n         color = mix( color, vec3(0), SMAA(x_axisSDF(NDC)) );\n         color = mix( color, vec3(0), SMAA(y_axisSDF(NDC)) );\n         \n    // Initial data:\n    vec2 A = MP,\n         B = vec2(0.5),\n         C = vec2(-0.5);\n         \n    // Need to find:\n    vec2 center = vec2(9e5);\n    float radius = 9e5;\n         \n    // Solution:\n    vec2 // Get length and direction\n         AtoB = B - A, \n         AtoC = C - A,\n         // Get perpendiculars (they divide AB and AC by 2 respectively).\n         perpAtoB = normalize(vec2(-AtoB.y, AtoB.x)),\n         perpAtoC = normalize(vec2(-AtoC.y, AtoC.x)),\n         // Define parametric lines:\n         mAB = A + AtoB*0.5, uAB = mAB + perpAtoB,\n         mAC = A + AtoC*0.5, uAC = mAC + perpAtoC;\n\n    // Find two parameters (or one) where lines intersects.\n    vec2 t = segment_segment_intersection(mAB, uAB, mAC, uAC);\n    // Corresponding t values:       t.x = 0    1\n    //                                         t.y = 0    1\n    \n    // Calculate circle center and radius, if possible.\n    if (abs(t.x) < 5e6)\n    {\n         center = mAB + perpAtoB*t.x;\n         radius = length(A - center);\n    }\n    else if (abs(t.y) < 5e6)\n    {\n         center = mAC + perpAtoC*t.y;\n         radius = length(A - center);\n    }\n    //else { /* No solution, because lines mAB->uAB, mAC->uAC are parallel. */ }\n    // End of solution.\n \n    // Visualization:\n    color = mix(color, vec3(1,0,0), SMAA(diskSDF(NDC, A, 0.03)));\n    color = mix(color, vec3(0,1,0), SMAA(diskSDF(NDC, B, 0.03)));\n    color = mix(color, vec3(0,0,1), SMAA(diskSDF(NDC, C, 0.03)));\n    \n    color = mix(color, vec3(1,0,1), SMAA(arrowSDF(NDC, A, B, 0.)));\n    color = mix(color, vec3(1,0,1), SMAA(arrowSDF(NDC, A, C, 0.)));\n    \n    // Perpendiculars\n    color = mix(color, vec3(0,.5,.5), SMAA(segmentSDF(NDC, mAB+perpAtoB*100., mAB-perpAtoB*100., 0.)));\n    color = mix(color, vec3(0,.5,.5), SMAA(segmentSDF(NDC, mAC+perpAtoC*100., mAC-perpAtoC*100., 0.)));\n    \n    // Find any circle?\n    if (radius != 9e5)\n    {\n        color = mix(color, vec3(.5,.5,0), SMAA(diskSDF(NDC, center, 0.03)));   \n        color = mix(color, vec3(.5,.5,0), SMAA(abs(diskSDF(NDC, center, radius))));\n    }\n\n    O = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"float y_axisSDF(vec2 NDC) { return abs(NDC.x); }\nfloat x_axisSDF(vec2 NDC) { return abs(NDC.y); }\nfloat vertical_lineSDF(vec2 NDC, float x0) { return abs(NDC.x-x0); }\nfloat horizontal_lineSDF(vec2 NDC, float y0) { return abs(NDC.y-y0); }\nfloat cellsSDF(vec2 NDC)\n{\n    //NDC *= 2.; // Finer cells\n    NDC = fract(NDC);\n    NDC = fract(min(NDC, 1. - NDC));\n    return\n        min(vertical_lineSDF(NDC, 0.), horizontal_lineSDF(NDC, 0.));\n}\nfloat diskSDF(in vec2 NDC, in vec2 C, in float r) { return length(C - NDC)-r; }\nfloat segmentSDF(in vec2 NDC, in vec2 B, in vec2 E, in float r)\n{\n    vec2 BP = NDC - B, BE = E - B;\n    return length(BP - BE * clamp(dot(BP, BE) / dot(BE, BE), 0.0, 1.0)) - r;\n}\nfloat arrowSDF(\n    in vec2 NDC,\n    in vec2 B,\n    in vec2 E,\n    in float R)\n{\n    float len = length(B-E);    \n    vec2 dir = normalize(E-B),\n         //up = cross(vec3(dir, 0.), vec3(0, 0, -1)).xy,   \n         up = vec2(-dir.y, dir.x),\n         C = E - dir * 0.0475, //      U--\n         U = C + up  * 0.030,  // B----C----E\n         D = C - up  * 0.030;  //      D--\n    \n    vec3 BARY = inverse(mat3(\n            U.x, U.y, 1.0,\n            D.x, D.y, 1.0,\n            E.x, E.y, 1.0)) * vec3(NDC.x, NDC.y, 1.0);\n    \n    float sign = \n        BARY.x >= 0.0 &&    \n        BARY.y >= 0.0 && \n        BARY.z >= 0.0 ?  // inside triangle?\n            -1. : 1.;\n    \n    float d = segmentSDF(NDC, U, D, 0.);\n          d = min(d, segmentSDF(NDC, U, E, 0.));\n          d = min(d, segmentSDF(NDC, D, E, 0.));\n          d = \n              len < 0.0475 ? \n                  d :\n                  min(d, segmentSDF(NDC, B, C, 0.));\n    \n    return sign*d-R;           \n}","name":"Common","description":"","type":"common"}]}