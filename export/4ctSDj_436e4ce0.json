{"ver":"0.1","info":{"id":"4ctSDj","date":"1714470912","viewed":44,"name":"hex prism layered fork","username":"akr51","description":"Fork of hex prism one from before but just playing around.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"XctSDj","parentname":"layered hex prisms"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n#define MAX 23.0\n#define SRF 0.01\n#define ITR 13\n\nvec3 palette(float t)\n{\n\n    vec3 a = vec3(0.75, 0.5, 0.25);\n    vec3 b = vec3(2.0, 2.5, 3.0);\n    vec3 c = vec3(2.0, 5.0, 3.0);\n    vec3 d = vec3(4.0, 3.0, 5.0);\n    return a + b * cos((c * d + t) * 3.141592 * 2.0);\n    \n\n}\n\nmat2 r2(float t)\n{\n\n    \n    float c = cos(t);\n    float s = sin(t);\n    return mat2(c, -s, s, c);\n    \n\n}\n\n\n// Thanks Inigo Quilez for the amazing resource\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n  const vec3 k = vec3(-0.8660254, 0.5, 0.57735);\n  p = abs(p);\n  p.xy -= 2.0*min(dot(k.xy, p.xy), 0.0)*k.xy;\n  vec2 d = vec2(\n       length(p.xy-vec2(clamp(p.x,-k.z*h.x,k.z*h.x), h.x))*sign(p.y-h.x),\n       p.z-h.y );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n\n\nfloat map(vec3 sp)\n{\n\n    sp.xy *= r2(iTime);\n    sp.xz *= r2(iTime);\n    return sdHexPrism(sp, vec2(0.2, 0.05));\n    \n\n}\n\n\n\nfloat mrch(vec3 ro, vec3 rd)\n{\n\n    float d0 = 0.0;\n    for (int i = 0; i < ITR; i++)\n    {\n\n        vec3 sp = ro + rd * d0;\n        float ds = map(sp);\n        \n        d0 += ds;\n        if (d0 > MAX || abs(ds) < SRF) break;\n\n    }\n    \n    \n    return d0;\n    \n\n}\n\n\n\nvec3 dir(vec2 uv, vec3 ro, vec3 fx)\n{\n\n    \n    vec3 w = normalize(fx - ro);\n    vec3 u = normalize(cross(w, vec3(0.0, 1.0, 0.0)));\n    vec3 v = normalize(cross(u, w));\n    \n    return mat3(u, v, w) * normalize(vec3(uv, 2.5));\n\n    \n}\n\n\n\nvoid mainImage(out vec4 c_out, in vec2 u)\n{\n    \n\n    vec2 rr = iResolution.xy, uv = (u + u - rr) / rr.y;\n    \n    vec3 ro = vec3(0.0, 0.0, -1.0);\n    vec3 fx = vec3(0.0, 0.0, 0.0);\n    \n    uv *= 2.0;\n    float f = sin(length(uv) * 1.0 + iTime) * 0.5 + 0.5;\n    uv *= f;\n    vec3 rd = dir(uv, ro, fx);\n   \n    float d0 = mrch(ro, rd);\n    float f0 = 0.0;\n   \n    if (d0 < MAX)\n    {\n    \n        d0 = pow(d0, 51.0) * 0.01;\n    \n    } else {\n    \n        vec3 ror = ro;\n        \n        for (float j = 0.0; j < 7.0; j += 0.2)\n        {\n        \n            d0 = mrch(ror + vec3(cos(iTime + j * 2.0), sin(iTime + j * 3.0), tan(iTime + j  * 5.0)) * (0.05 + j * 0.5), rd);\n            \n            if (d0 < MAX)\n            {\n\n                f0 += d0 * d0 * 0.01 * f;\n\n            } else {\n\n                d0 = 0.0;\n\n            }\n           \n        \n        }\n        \n    \n    }\n    float d00 = d0;\n    d0 = f0;\n    vec3 cl = palette(d00 * 13.1 + iTime * 0.4) * d0 + d00 * 0.1;\n   \n    c_out = vec4(vec3(cl), 1.0);\n    \n}\n","name":"Image","description":"","type":"image"}]}