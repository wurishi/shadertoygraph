{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[{"channel":0,"type":"texture","id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"code":"/*\n\nWritten by Alan Wolfe\nhttp://demofox.org/\nhttp://blog.demofox.org/\n\nWang tiling is a method for creating organic looking images with 2d tiles\n\nMore info on wang tiling:\nhttp://research.microsoft.com/en-us/um/people/cohen/WangFinal.pdf\nhttp://procworld.blogspot.ca/2013/01/introduction-to-wang-tiles.html\n*/\n\n// unscaled tile size\n#define TILE_SIZE 0.15\n\n// used when displaying the individual tiles\n#define TILE_PADDING 0.05\n\n// used when displaying the tile grid\n#define TILE_SCALE 1.5\n#define TILE_SCROLL vec2(0.25, 0.1)*5.0\n\nfloat SDFHorizLine( in vec2 coords, float offsetY )\n{\n    float v = offsetY-coords.y;\n    vec2  g = vec2(0.0,-1.0);\n    return abs(v)/length(g);\n}\n\nfloat SDFVertLine( in vec2 coords, float offsetX )\n{\n    float v = coords.x - offsetX;\n    vec2  g = vec2(1.0,0.0);\n    return abs(v)/length(g);\n}\n\nfloat SDFCircle( in vec2 coords, float offsetX, float offsetY, float radius )\n{\n    coords.x -= offsetX;\n    coords.y -= offsetY;\n    float v = coords.x * coords.x + coords.y * coords.y - radius;\n    vec2  g = vec2(2.0 * coords.x, 2.0 * coords.y);\n    return v/length(g); \n}\n\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nvec3 RenderTilePixelLevel1 (vec3 incolor, int leftType, int topType, int rightType, int bottomType, float percentX, float percentY)\n{\n    float col = 1.0;\n    \n    if ((leftType == 1 && percentX < 0.5) ||\n        (rightType == 1 && percentX > 0.5))\n    {\n        float newCol = smoothstep(0.0,0.05,SDFHorizLine(vec2(percentX,percentY), 0.5));\n    \tcol = min(col, newCol);\n    }\n    \n\n    if ((topType == 1 && percentY < 0.5) ||\n        (bottomType == 1 && percentY > 0.5))\n    {\n        float newCol = smoothstep(0.1,0.15,SDFVertLine(vec2(percentX,percentY),0.5));\n    \tcol = min(col, newCol);\n    }\n    \n    if (leftType != rightType || topType != bottomType)\n    {\n        float newCol = smoothstep(0.048,0.068,SDFCircle(vec2(percentX,percentY),0.5,0.5,0.001));\n    \tcol = min(col, newCol);    \n    }\n    \n    return mix(vec3(0.125,0.125,0.125),incolor,col);\n}\n\nvec3 RenderTilePixelLevel2 (vec3 incolor, int leftType, int topType, int rightType, int bottomType, float percentX, float percentY)\n{\n    float col = 1.0;\n    \n    if ((leftType == 0 && percentX < 0.75) ||\n        (rightType == 0 && percentX > 0.75))\n    {\n        float newCol = smoothstep(0.03,0.08,SDFHorizLine(vec2(percentX,percentY), 0.75));\n    \tcol = min(col, newCol);\n    }\n    \n\n    if ((topType == 1 && percentY < 0.75) ||\n        (bottomType == 1 && percentY > 0.75))\n    {\n        float newCol = smoothstep(0.0,0.05,SDFVertLine(vec2(percentX,percentY),0.75));\n    \tcol = min(col, newCol);\n    }\n    \n    if (leftType != rightType || topType != bottomType)\n    {\n        float newCol = smoothstep(0.01,0.03,SDFCircle(vec2(percentX,percentY),0.75,0.75,0.001));\n    \tcol = min(col, newCol);    \n    }\n    \n    return mix(vec3(0.125,0.125,0.5),incolor,col);\n}\n\nvec3 RenderTilePixelLevel3 (vec3 incolor, int leftType, int topType, int rightType, int bottomType, float percentX, float percentY)\n{\n    float col = 1.0;\n    \n    if ((leftType == 1 && percentX < 0.25) ||\n        (rightType == 1 && percentX > 0.25))\n    {\n        float newCol = smoothstep(0.02,0.07,SDFHorizLine(vec2(percentX,percentY), 0.25));\n    \tcol = min(col, newCol);\n    }\n    \n\n    if ((topType == 0 && percentY < 0.25) ||\n        (bottomType == 0 && percentY > 0.25))\n    {\n        float newCol = smoothstep(0.0,0.05,SDFVertLine(vec2(percentX,percentY),0.25));\n    \tcol = min(col, newCol);\n    }\n    \n    if (leftType != rightType || topType != bottomType)\n    {\n        float newCol = smoothstep(0.03,0.05,SDFCircle(vec2(percentX,percentY),0.25,0.25,0.001));\n    \tcol = min(col, newCol);    \n    }\n    \n    return mix(vec3(0.5,0.125,0.125),incolor,col);\n}\n\nvec3 RenderTilePixelLevel4 (vec3 incolor, int leftType, int topType, int rightType, int bottomType, float percentX, float percentY)\n{\n    float col = 1.0;\n    \n    if (leftType == 0 && leftType == rightType)\n    {\n        float newCol = smoothstep(0.05,0.1,SDFHorizLine(vec2(percentX,percentY), 0.5));\n    \tcol = min(col, newCol);        \n    }\n    \n    if (topType == 0 && topType == bottomType)\n    {\n        float newCol = smoothstep(0.05,0.1,SDFVertLine(vec2(percentX,percentY), 0.5));\n    \tcol = min(col, newCol);        \n    }    \n    \n    if (leftType == 0 && leftType == topType)\n    {\n        float newCol = smoothstep(0.05,0.1,abs(SDFCircle(vec2(percentX,percentY), 0.0, 0.0,0.25)));\n    \tcol = min(col, newCol);        \n    }\n    \n    if (leftType == 0 && leftType == bottomType)\n    {\n        float newCol = smoothstep(0.05,0.1,abs(SDFCircle(vec2(percentX,percentY), 0.0, 1.0,0.25)));\n    \tcol = min(col, newCol);        \n    }    \n    \n    if (rightType == 0 && rightType == topType)\n    {\n        float newCol = smoothstep(0.05,0.1,abs(SDFCircle(vec2(percentX,percentY), 1.0, 0.0,0.25)));\n    \tcol = min(col, newCol);        \n    }\n        \n    if (rightType == 0 && rightType == bottomType)\n    {\n        float newCol = smoothstep(0.05,0.1,abs(SDFCircle(vec2(percentX,percentY), 1.0, 1.0,0.25)));\n    \tcol = min(col, newCol);        \n    }    \n    \n    return mix(vec3(0.85,0.85,0.125),incolor,col);\n}\n\nvec3 RenderTilePixel (int leftType, int topType, int rightType, int bottomType, float percentX, float percentY, vec3 bgColor)\n{\n    vec3 color = bgColor;    \n    color = RenderTilePixelLevel4(color,leftType,topType,rightType,bottomType,percentX,percentY);        \n    color = RenderTilePixelLevel3(color,leftType,topType,rightType,bottomType,percentX,percentY);    \n    color = RenderTilePixelLevel2(color,leftType,topType,rightType,bottomType,percentX,percentY);    \n    color = RenderTilePixelLevel1(color,leftType,topType,rightType,bottomType,percentX,percentY);\n    return color;\n}\n\nvec3 RenderAllTiles (vec2 pixel)\n{\n    float tileX = floor(pixel.x / (TILE_SIZE + TILE_PADDING));\n    float tileY = floor(pixel.y / (TILE_SIZE + TILE_PADDING));\n        \n    if (tileX < 0.0 || tileY < 0.0 || tileX > 3.0 || tileY > 3.0)\n        return vec3(0,0,0);\n        \n    float tileOffsetX = pixel.x - tileX * (TILE_SIZE + TILE_PADDING) - TILE_PADDING;\n    float tileOffsetY = pixel.y - tileY * (TILE_SIZE + TILE_PADDING) - TILE_PADDING;\n    \n    if (tileOffsetX < 0.0 || tileOffsetY < 0.0)\n        return vec3(0,0,0);\n    \n    tileOffsetX /= TILE_SIZE;\n    tileOffsetY /= TILE_SIZE;\n    \n    float tile = tileY * 4.0 + tileX;   \n    int leftType = int(mod(tile / 8.0,2.0));\n    int topType = int(mod(tile / 4.0,2.0));\n    int rightType = int(mod(tile / 2.0,2.0));    \n    int bottomType = int(mod(tile,2.0));\n\n    return RenderTilePixel(leftType,topType,rightType,bottomType,tileOffsetX,tileOffsetY, vec3(0,1,0));\n}\n\nfloat noise( in vec2 x )\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n\tvec2 uv = p.xy + f.xy*f.xy*(3.0-2.0*f.xy);\n\treturn texture( iChannel0, (uv+118.4)/256.0, -100.0 ).x;\n}\n\nint CoinFlip (vec2 sampleAt, vec2 seed)\n{\n    return noise(sampleAt / seed) > 0.5 ? 1 : 0;\n}\n\nvec3 RenderScreen(vec2 pixel)\n{   \n    float shading = (sin(pixel.x)+1.0) / 2.0 * 0.2 + 0.8;\n    shading *= (sin(pixel.x*2.0)+1.0) / 2.0 * 0.2 + 0.8;\n    vec3 bgColor = vec3(0,1,0);\n    \n    float tileX = floor(pixel.x / TILE_SIZE);\n    float tileY = floor(pixel.y / TILE_SIZE);\n  \n  \tfloat tileOffsetX = fract(pixel.x / TILE_SIZE);\n    float tileOffsetY = fract(pixel.y / TILE_SIZE);\n    \n    // calculate our tile edges, making sure to be coherent with our neighbors!\n    int leftType   = CoinFlip(vec2(tileX-1.0,tileY    ), vec2(0.12,0.37));\n    int rightType  = CoinFlip(vec2(tileX,    tileY    ), vec2(0.12,0.37));\n\tint topType    = CoinFlip(vec2(tileX,    tileY-1.0), vec2(0.41,0.73));\n    int bottomType = CoinFlip(vec2(tileX,    tileY    ), vec2(0.41,0.73));\n\n\t// render the tile pixel!\n    return RenderTilePixel(leftType,topType,rightType,bottomType,tileOffsetX,tileOffsetY, bgColor) * shading;\n}\n    \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // calculate our pixel's location in X,Y percent of the resolution of the screen\n    // and apply the aspect ratio to get rid of distortion. Also make y = 0 be at the\n    // top of the screen and center the display\n\tvec2 pixel = fragCoord.xy / iResolution.xy;\n    pixel.y = 1.0 - pixel.y;\n    pixel.y = pixel.y - 0.5 + (TILE_SIZE + TILE_PADDING) * 2.0 + TILE_PADDING * 0.5;\n\n    float aspectRatio = iResolution.x / iResolution.y;\n    pixel.x -= 0.5;\n    pixel.x *= aspectRatio;\n    pixel.x += (TILE_SIZE + TILE_PADDING)*2.0 + TILE_PADDING * 0.5;\n    \n    vec3 color = vec3(0,0,0);\n\tif (iMouse.z > 0.0)\n    {\n    \tcolor = RenderAllTiles(pixel);\n    }\n    else\n    {\n    \tfloat scale = 0.5 + TILE_SCALE * (sin(iTime*0.33) * 0.5 + 0.5);\t\n  \t\tcolor = RenderScreen(pixel*scale + iTime * TILE_SCROLL);\n    }\n    \n    fragColor = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"XsSXzR","date":"1408123373","viewed":848,"name":"Circuit Board","username":"demofox","description":"via wang tiling and a very lame shading multiplier that varies over distance.\nRelated blog post:  https://blog.demofox.org/2014/08/13/wang-tiling/","likes":13,"published":1,"flags":0,"usePreview":0,"tags":["2d","tiling","wangtiling"],"hasliked":0,"parentid":"","parentname":""}}