{"ver":"0.1","info":{"id":"XtSyDh","date":"1508340222","viewed":460,"name":"Simple Ray Tracer - Shadow","username":"kaswan","description":"simple raytracer with shadow","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raytracing","shadow"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float checkboard(vec2 p)\n{\n    p = mod(floor(p/100.0), 2.0);\n    return mod(p.x + p.y, 2.0) < 1.0 ? 0.5 : 0.1;\n}\n\n//vec3 Light = vec3(-2.0 * cos(iTime * 2.0), 3.0, 2.0 * sin(iTime * 2.0));\nvec3 ambient = vec3(0.1, 0.1, 0.3);\nvec3 vEye = vec3(0.0, 0.0, 3.5);\n\nfloat shadow(vec3 sRay, vec3 Pos);\n\nvec3 calcLight(vec3 N, vec3 L, vec3 V, vec3 matColor)\n{\n    vec3 color;\n    \n\tvec3 Rf = reflect(-L,N);\n\n    float diffuse = max(dot(N, L), 0.0);\n    float specular = 0.0;\n    if (diffuse > 0.0) specular = pow(max(dot(Rf, V),0.0), 16.0);\n\t\t\n    color = diffuse * matColor;\n\tcolor += specular;\n    color += ambient;\n\t\n    return color;\n}\n\nvec3 plane(vec3 vRay)\n{\nvec3 Light = vec3(-2.0 * cos(iTime * 2.0), 3.0, 2.0 * sin(iTime * 2.0));\n    vec3 color;\n    vec3 N = vec3(0.0, 1.0, 0.0);\n    float D = -1.0;\n        \n\tfloat Det = dot(N, vRay); \n    if (Det < 0.0) { // Floor with chess texture\n            \n    \tfloat t = (D - dot(vEye, N)) / Det;\n        \t\n        vec3 Pos = vEye + t * vRay;\n    \tvec3 L = normalize(Light - Pos);\n    \tvec3 V = normalize(vEye - Pos);\n\t\t\t\n\t\tvec3 matColor = vec3(1.0, 1.0, 1.0);\n\t\tmatColor *= checkboard(Pos.xz * 100.0);\n        \n        color = calcLight(N, L, V, matColor);\n        vec3 sRay = L;\n        color *= shadow(sRay, Pos);\n\n\t}\n\telse { // Sky\n\t\tcolor = vec3(0.5, 0.7, 1.0); // Sky color\n\t}\n    return color;\n}\n\nvec3 sphere(vec3 vRay)\n{\n    vec3 color;\nvec3 Light = vec3(-2.0 * cos(iTime * 2.0), 3.0, 2.0 * sin(iTime * 2.0));    \n    vec3 vSphere = vec3(0.0, 0.5 * sin(iTime), -0.5);\n    float R = 1.0;\n\tvec3 vE2S = vSphere - vEye;\n\tfloat glass = 0.96;\n    \n    float A = dot(vRay, vRay);\n    float B = -2.0 * dot(vRay, vE2S);\n    float C = dot(vE2S, vE2S) - R*R;\n\n\tfloat Det = B*B - 4.0*A*C;\n    \n    vec3 matColor = vec3(1.0, 0.0, 1.0);\n\t    \n    if (Det > 0.0) { // Sphere\n    \t\n        float t = (-B - sqrt(Det)) / (2.0*A);\n        \n        vec3 Pos = vEye + t * vRay;\n        \n        vec3 N = normalize(Pos - vSphere);\n        vec3 L = normalize(Light - Pos);\n        vec3 V = normalize(vEye - Pos);\n        \n        vec3 Rf = refract(-V, N, glass);\n        //vec3 Rf = reflect(-V, N);\n        vec3 RfColor = plane(Rf);\n        \n        color = calcLight(N, L, V, matColor);\n\t\tcolor += RfColor;\n    }\n    else { // No Sphere\n\t\tcolor = plane(vRay);\n    }\n    \n    return color;\n}\n\nbool sphereCheck(vec3 sRay, vec3 Pos)\n{\n    vec3 vSphere = vec3(0.0, 0.5 * sin(iTime), 0.0);\n    float R = 1.0;\n\tvec3 vE2S = vSphere - Pos;\n    \n    float A = dot(sRay, sRay);\n    float B = -2.0 * dot(sRay, vE2S);\n    float C = dot(vE2S, vE2S) - R*R;\n\n\tfloat Det = B*B - 4.0*A*C;\n    \n    if (Det > 0.0) return true;\n    else return false;\n}\n\nfloat shadow(vec3 sRay, vec3 Pos)\n{\n \tif (sphereCheck(sRay, Pos)) return 0.4;\n    else return 1.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    float aspectRatio = iResolution.x / iResolution.y;\n    uv = 2.0 * uv - vec2(1.0, 1.0);\n    uv.x *= aspectRatio;\n    \n\tvec3 vRay = vec3(uv, 1.5) - vEye;\n    //vRay = normalize(vRay);\n    \n    vec3 color;\n    color = sphere(vRay);\n\tfragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}