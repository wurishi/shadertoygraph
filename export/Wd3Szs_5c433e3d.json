{"ver":"0.1","info":{"id":"Wd3Szs","date":"1572570153","viewed":233,"name":"Engraved","username":"azirafail","description":"more sdf font experimentation - this time combined with some raymarching experiments","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["raymarch","sdf","font"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float PI = 3.14159265359;\n\nvec4 letter(float ix, vec2 uv)\n{\n    vec2 ixOffset = vec2(mod(ix, 16.), -floor(ix/16.)) + vec2(0.5,-0.5);\n    \n    vec2 ixUv = (ixOffset + clamp(uv, -0.5,0.5))/16.;\n    \n    vec4 texD = texture(iChannel0, ixUv);\n\n    return vec4(texD.gba - 0.5, smoothstep(0.5,0.495,texD.a));\n}\n\n\nfloat noise2(vec2 uv)\n{\n    return fract(sin(uv.x * 523.) * 757. + cos(uv.y * 871.) * 721.);\n}\n\nstruct ray {\n    vec3 o, d;\n};\n\nray camera(vec3 camPos, vec3 camTarget, vec2 uv, float zoom) \n{\n    ray r;\n    r.o = camPos;\n    \n    vec3 up = vec3(0.,1.,0.);\n    \n    vec3 camFwd = normalize(camTarget - camPos);\n    \n    vec3 camRight = cross(camFwd,- up);\n    vec3 camUp = cross(camFwd, camRight);\n    \n    r.d = normalize(camFwd + uv.x * camRight / zoom + uv.y * camUp / zoom);\n    return r;\n}\n\nstruct hit {\n    float d;\n    vec2 uv;\n    vec3 n;\n    vec3 p;\n    vec3 u;\n    vec3 v;\n};\n    \nfloat MAX_DIST = 20.;\nint MAX_ITER = 300;\nfloat EPSILON = 0.005;\n\nhit dPlane(vec3 p, vec3 o, vec3 n)\n{\n    hit h;\n    h.n = n;\n    h.d = dot(p - o, n);\n    vec3 l = normalize(sign(n.x) * vec3(0.,1.,0.) + sign(n.y) * vec3(0.,0.,1.) + sign(n.z) * vec3(1.,0.,0.));\n    h.u = cross(l, n);\n    h.v = cross(h.u, n);\n    h.uv = vec2(dot(p - o, h.u), dot(p - o, h.v));\n    return h;\n}\n\n\nhit dSphere(vec3 p, vec3 o, float r)\n{\n    hit h;\n    \n    h.d = length(p - o) - r;\n    \n    h.n = normalize(p - o);\n    h.u = normalize(vec3(-h.n.z, 0., h.n.x));\n    h.v = cross(h.u, h.n);\n    h.uv = vec2(atan(h.n.x/h.n.z) / (PI/2.)-.5, 2.*atan(h.n.y/length(h.n.xz))/PI);\n    \n    return h;\n}\n\n\nhit dCappedCylinder(vec3 p, vec3 o, vec2 h)\n{\n    hit ht;\n\n      p -= o;\n    \n    if (abs(p.y)/length(p.xz) > h.y/h.x) {\n        ht.n = vec3(0.,sign(p.y), 0.);\n        ht.u = vec3(1.,0.,0.);\n        ht.v = vec3(0.,0.,1.);\n        ht.uv = p.xz;\n    }\n    else {\n        vec3 n;\n        n.xz = p.xz;\n        ht.n = normalize(n);\n        ht.u = vec3(-ht.n.z, 0.,ht.n.x);\n        ht.uv = vec2(atan(ht.n.x/ht.n.z) / (PI/2.)-.5, p.y);\n    }\n    \n      vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n      ht.d = min(max(d.x,d.y),0.0) + length(max(d,0.0));\n    \n        \n    \n      return ht;\n}\n\n\nhit shell(hit h, float t)\n{\n    h.n *= sign(h.d);\n    h.d = abs(h.d) - t / 2.;\n    return h;\n}\n\nhit expand(hit h, float t)\n{\n    h.d -= t;\n    h.n = vec3(0.);\n    return h;\n}\n\nhit u(hit a, hit b)\n{\n    hit h = a;\n    if (b.d < a.d) h = b;\n    return h;\n}\n\n\nhit i(hit a, hit b)\n{\n    hit h = a;\n    if (b.d > a.d) h = b;\n    return h;\n}\n\nhit s(hit a, hit b)\n{\n    b.d = - b.d;\n    b.n = - b.n;\n    \n    return i(a, b);\n}\n\nvec2 rot2(vec2 uv, float theta)\n{\n    return mat2(cos(theta), -sin(theta), sin(theta), cos(theta)) * uv;\n}\n\nhit dist(vec3 p)\n{\n    vec3 pn = vec3(0.,1.,1.);\n    pn.yz = rot2(pn.yz, PI / 8.);\n    \n    hit plane = shell(dPlane(p, vec3(0.,0.,0.), pn), 0.15);\n\n    vec2 tuv = vec2(-1.,1.) * (fract(plane.uv) - 0.5);\n    vec4 char = letter(floor(noise2(floor(plane.uv)) * 256.), tuv);\n    \n    \n    float edgeD = clamp(-char.b * 2., 0., .05);\n    plane.d += edgeD;\n    float edge = 0.;\n    if (edgeD < .05) edge = 1.;\n    if (edgeD <= 0.) edge = 0.;\n    edge *= 0.3;\n    plane.n = normalize(plane.n + plane.u * edge * char.r + plane.v * edge * char.g);\n   \n    pn.yz = rot2(pn.yz, PI/2.);\n    \n    hit block = shell(dPlane(p, vec3(0.,0.,0.), pn), 7.);\n    return i(plane, block);\n}\n\n\nfloat MIN_DIST = 2.;\n\nhit march(ray r)\n{\n    hit h;\n    h.d = MIN_DIST;\n    \n    int i = 0;\n    float d = MAX_DIST;\n    vec3 p = r.o;\n    \n    while (abs(h.d) < MAX_DIST && i++ < MAX_ITER) {\n        \n        p = r.o + r.d * h.d;\n        \n        hit h0 = dist(p);\n        \n        d = h0.d;\n        h.d+=d * 0.06;\n        h.uv = h0.uv;\n        h.n = h0.n;\n        h.u = h0.u;\n        h.v = h0.v;\n        \n        if (d <= EPSILON) break;\n    }\n    \n    p = r.o + r.d * h.d;\n    \n    if (length (h.n) < 0.5) {\n        vec2 offset = vec2(EPSILON,0);\n    \n        h.n = normalize(vec3(\n            dist(p + offset.xyy).d,\n            dist(p + offset.yxy).d,\n            dist(p + offset.yyx).d)\n                        - vec3(\n            dist(p - offset.xyy).d,\n            dist(p - offset.yxy).d,\n            dist(p - offset.yyx).d));\n    }\n    \n    if (d > EPSILON) {\n        h.d = 1000.;\n        h.uv = vec2(0.);\n        h.n = vec3(0.);\n        h.u = vec3(0.);\n        h.v = vec3(0.);\n    }\n    h.p = p;\n    return h;\n}\n\nstruct lighting {\n    vec3 dif, spec, ref;\n};\n\nlighting light(vec3 p, vec3 o, vec3 n)\n{\n    vec3 AMB = vec3(0.3);\n    lighting light;\n    \n    vec3 ld = vec3(0.5,1.,0.);\n    \n    vec3 rd = normalize(reflect(p - o, n));\n    \n    ray r;\n    r.o = p + n * EPSILON * 1.5; r.d = ld;\n    \n    hit h = march(r);\n    \n    if (h.d < MAX_DIST)\n    {\n        light.dif = AMB;\n        return light;\n    }\n    \n    light.dif = clamp(vec3(1.) * dot(ld, n), AMB, vec3(1.));\n    \n    light.spec = pow(clamp(dot(rd, ld),0., 1.), 10.) * vec3(1.);\n    \n    light.ref = texture(iChannel1, rd).rgb;\n    \n    return light;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized square pixel coordinates (from -0.5 to 0.5)\n    vec2 uv = (fragCoord/iResolution.xy - 0.5) * iResolution.xy/iResolution.x;\n\n    vec3 camPos = vec3(3.*sin(iTime * 0.3) - iTime,5. + 3. * cos(iTime * 0.43),5.);\n    vec3 camTarget = vec3(0. - iTime,0.,0.);\n    ray cam = camera(camPos, camTarget, uv, .5);\n    \n    hit h = march(cam);\n    \n    vec3 sam = vec3(0.25);\n    \n    vec3 col = vec3(0.);\n\n    lighting l;\n    \n    if (h.d < MAX_DIST) {\n\t    l = light(h.p, cam.o, h.n);\n    }\n    else\n    {\n        l.dif = texture(iChannel1, cam.d).rgb * 2.;\n    }\n    \n   \tcol.rgb = l.dif * sam + l.spec * 0.5 + l.ref * 0.5;\n    \n    \n    fragColor.rgb = col;\n}","name":"Image","description":"","type":"image"}]}