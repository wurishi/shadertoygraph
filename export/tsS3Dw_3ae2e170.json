{"ver":"0.1","info":{"id":"tsS3Dw","date":"1551560292","viewed":105,"name":"sun corridor","username":"lexmar","description":"corridor","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["raymarch"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float MAX_DIST = 100.0;\n\nmat3 genCamera(vec3 camP, vec3 targetP, float tilt)\n{\n    vec3 zaxis = normalize(targetP - camP);\n    vec3 up = vec3(0, 1, 0);\n    vec3 xaxis = normalize(cross(up, zaxis));\n    vec3 yaxis = normalize(cross(zaxis, xaxis));\n    return mat3(xaxis, yaxis, zaxis);\n}\n\nfloat sphereSdf(vec3 p, float radius)\n{\n    return length(p) - radius;\n}\n\nfloat worldSdf(vec3 p)\n{\n    float theta = p.z / 5.0*sin(iTime);\n    mat3 rot = mat3(vec3(cos(theta), sin(theta), 0.0), vec3(-sin(theta), cos(theta), 0.0), vec3(0.0, 0.0, 1.0));\n    p = rot*p;\n        \n    float lowPlane = -5.0;\n    float highPlane = 5.0;\n    float distToPlane = min(p.y - lowPlane, highPlane - p.y);\n    \n    return distToPlane;\n    //return length(p - vec3(3.0, 0.0, 20.0)) - 1.0;\n}\n\nvec3 worldNormal(vec3 p)\n{\n    float eps = 0.001;\n    float dx = (worldSdf(p + vec3(eps, 0, 0)) - worldSdf(p - vec3(eps, 0, 0)));\n    float dy = (worldSdf(p + vec3(0, eps, 0)) - worldSdf(p - vec3(0, eps, 0)));\n    float dz = (worldSdf(p + vec3(0, 0, eps)) - worldSdf(p - vec3(0, 0, eps)));\n    return normalize(vec3(dx, dy, dz));\n}\n\nfloat intersect(vec3 p, vec3 dir)\n{\n \tfloat t = 0.0;\n    while(t < MAX_DIST)\n    {\n        float dt = worldSdf(p);\n        if(dt < 0.001) break;\n        p = p + dt*dir;\n        t += dt;\n    }\n    \n    return t;\n}\n\nfloat random (vec2 p) {\n    return fract(sin(dot(p.xy, vec2(12.9898,78.233)))*43758.5453123);\n}\n\nfloat noise(vec2 p)\n{\n    vec2 botLeft = floor(p);\n    vec2 inside = fract(p);\n    \n    float a = random(botLeft);\n    float b = random(botLeft + vec2(1.0, 0.0));\n    float c = random(botLeft + vec2(0.0, 1.0));\n    float d = random(botLeft + vec2(1.0, 1.0));\n    \n    inside = inside * inside * (3.0 - 2.0*inside);\n    \n    float result = mix(mix(a, b, inside.x), mix(c, d, inside.x), inside.y);\n    return result;\n}   \n\n// technique from https://iquilezles.org\nfloat fbm(vec2 p, float speed)\n{\n    float amp = 0.5;\n    float v = 0.0;\n    for(int i = 0; i < 8; i++)\n    {\n        vec2 off = vec2(0.0, 0.0);\n        \n        if(int(i) % 2 == 0)\n        {\n            off = vec2(1.0, 0.0);\n        }\n        else\n        {\n            off = vec2(0.0, 1.0);\n        }\n        \n        off = speed * iTime * float(i) * off;\n        \n        vec2 np = p + off;\n        v += amp*noise(np);\n        p *= 2.0;\n        amp *= 0.5;\n    }\n    \n    return v;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = 2.0*(fragCoord.xy/iResolution.xy) - 1.0;\n    uv.x *= (iResolution.x/iResolution.y)/2.0;\n    uv.y *= 0.5;\n    \n    vec3 camP = vec3(0.0, 0.0, 0.0);\n    vec3 targetP = camP + vec3(0.0, 0.0, 1.0);\n    mat3 cameraSpaceFromUnitSpace = genCamera(camP, targetP, 0.0);\n    vec3 ray = normalize(vec3(uv, 4.0));\n    float dist = intersect(camP, ray);\n    vec3 hit = camP + dist*ray;\n    \n    if(dist < MAX_DIST) {\n        vec3 normal = worldNormal(hit);\n        float c = 5.0*dot(normal, -ray);\n        vec2 p = 0.25*hit.xy;\n        vec2 np = vec2(fbm(p, 1.0), fbm(p + vec2(3.5, 4.67), 1.0));\n        vec2 nnp = vec2(fbm(p + 4.0*np, 1.0), fbm(p + 4.0*np + vec2(6.2, 1.6), 1.0));\n        float t = fbm(np + 4.0*nnp, 1.0);\n        fragColor = 0.3*c*vec4(0.4, 0.4, 0.0, 1.0) + (hit.z/100.0)*vec4(t, t, 0.0, 1.0);\n    } else {\n        vec2 p = 1.0*hit.xy;\n        vec2 np = vec2(fbm(p, 1.0), fbm(p + vec2(3.5, 4.67), 1.0));\n        vec2 nnp = vec2(fbm(p + 4.0*np, 1.0), fbm(p + 4.0*np + vec2(6.2, 1.6), 1.0));\n        float t = fbm(np + 4.0*nnp, 1.0);\n        fragColor = vec4(2.0*t, t, 0.0, 1.0);\n    }\n}","name":"Image","description":"","type":"image"}]}