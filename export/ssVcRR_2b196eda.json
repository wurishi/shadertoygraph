{"ver":"0.1","info":{"id":"ssVcRR","date":"1654348479","viewed":81,"name":"b + e = c9","username":"EmilieWho","description":"crying 2.0","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["procedural","3d","raymarching","sdf","animation"],"hasliked":0,"parentid":"7dVcRR","parentname":"b + e = c8"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//==================================== constants =========================================\n#define pi 3.1415926535897932385\n#define TERRAIN 1\n#define FIRE 2\n#define WATER 3\n#define SKY 4\n#define LAM 3\n#define EYE 4\n#define EPSILON 1e-4\n\n//_____________________________________________________________\n\n//====================================  mat struct =========================================\nstruct material{\n    vec3 color;\n    int type;\n};\n\n//====================================  camera struct  =========================================\nstruct camera{\n    vec3 origin;\n    vec3 w;\n    vec3 u;\n    vec3 v;\n};\n\n//==================================== ray struct =========================================\n// ray struct which we implementend in PA6\nstruct ray {\n    vec3 ori;\n    vec3 dir;\n};\n\n\n//-----------------------------------------------------------------------------------------\n//-------------------------------- get ray when given camera and uv coordinates      ------\n//-----------------------------------------------------------------------------------------\nray getray(camera cam, vec2 uv){\n    return ray(cam.origin,normalize( uv.x * cam.u + uv.y * cam.v + 1.5 * cam.w ));\n}\n\n\n//-----------------------------------------------------------------------------------------\n//---------     return vec3 of r.origin + increment by some value in r.direction     ------\n//-----------------------------------------------------------------------------------------\nvec3 rayAt(ray r, float t){\n    return r.ori + t * r.dir;\n}\n\n//-----------------------------------------------------------------------------------------\n//---------     returns the float of the entire model of the being    ---------------------\n//-----------------------------------------------------------------------------------------\nfloat model(in vec3 pos){\n\n    vec3 h = pos - vec3(.1 ,.9 +  .01*sin(iTime),1.2 -.01*cos(iTime) );\n\n    float head = sdSphere(h, .45);\n    float littleFlame = sdCone(pos - vec3(.1 + .08 * sin(iTime * 3.),1.45,1.3 - .15 * cos(iTime * 3.)), vec2(1.0,.4), .3);\n    float littleFlame2 = sdCone(pos - vec3(.1 + .08 * -sin(iTime * 3.),1.45,1.3 - .15 * -cos(iTime * 3.)), vec2(1.0,.4), .3);\n    float littleFlame3 = sdCone(pos - vec3(.1 + .05 * sin(iTime * 4.),1.5,1.3 - .1 * cos(iTime * 4.)), vec2(1.0,.4), .5);\n    \n    \n    head = opSmoothUnion(head,littleFlame,.13);\n    head = opSmoothUnion(head,littleFlame2,.13);\n    head = opSmoothUnion(head,littleFlame3,.1);\n    \n    \n    float t1 = sdSphere(pos - vec3(0.1,0.8,.8), 0.03);\n    float t2 = sdSphere(pos - vec3(0.0,0.8,0.0), 0.03);\n    float t3 = sdSphere(pos - vec3(-0.1,0.8,-1.), 0.03);\n    \n    \n    float l1 = sdSphere(pos - vec3(-0.7,-.2,-.9), 0.1);\n    float l2 = sdSphere(pos - vec3(0.7,-.2,-.9), 0.15);\n    float l3 = sdSphere(pos - vec3(-0.7,-.2,.8), 0.16);\n    float l4 = sdSphere(pos - vec3(0.7,-.2,.8), 0.13);\n    \n    \n    float torso = opSmoothUnion(t1, t2, 2.5);\n    torso = opSmoothUnion(torso, t3, 2.5);\n    \n    torso = opSmoothUnion(head,torso,.2);\n    \n    \n    float tail = sdSphere(pos - vec3(.1,1.,-1.2), .05);\n    float tail2 = sdSphere(pos - vec3(.1,1.2,-1.5), .03);\n    float tail3 = sdSphere(pos - vec3(.1,1.4,-1.8), .03);\n    \n    float tail4 = sdSphere(pos - vec3(.1,1.6,-2.), .01) ;\n    \n    tail = opSmoothUnion(tail,tail2,.6);\n    tail = opSmoothUnion(tail,tail3,.5);\n    tail = opSmoothUnion(tail,tail4,.2) ;\n    \n    \n    tail = opRound(tail,0.1);\n\n    \n    torso = opSmoothUnion(tail,torso,.15);\n    \n    float d = opSmoothUnion(torso, l1, 1.);\n    d = opSmoothUnion(d, l2, 1.);\n    d = opSmoothUnion(d, l3, 1.);\n    d = opSmoothUnion(d, l4, 1.);\n\n    return d;\n}\n\n\n//-----------------------------------------------------------------------------------------\n//---------     fractal brownian motion                                --------------------\n//-----------------------------------------------------------------------------------------\n// https://www.shadertoy.com/view/4slGD4\n// - dave hoskins\n\n// to clearly state, these next two functions were indeed copy and pasted from the above link\n// but, we modified them to fit our needs \n\n// these functions create the mountains \n\nfloat noise(in vec2 uv)\n{\n    return sin(uv.x)+cos(uv.y);\n}\n\n// - fbm from dave hoskin shader link above\nfloat fbm(in vec2 uv)\n{\n    //this function generates the terrain height\n    uv /= 3.5;\n    float value = 0.1;\n    float amplitude = 1.;\n    float freq = 1.;\n    \n    for (int i = 0; i < 8; i++)\n    {\n        // From Dave_Hoskins https://www.shadertoy.com/user/Dave_Hoskins\n        value = max(value, value + (.25 - abs( noise( uv * freq ) -.8 ) * amplitude));\n        \n        amplitude *= .37;\n        \n        freq *= 2.05;\n        \n        uv = uv.yx;\n    }\n    \n    return value*2.0-2.0;\n}\n\n\n\nfloat fbmWater(in vec2 uv)\n{\n    //this function generates the terrain height\n    uv /= .1;\n    float value = .01;\n    float amplitude = .01;\n    float freq = 1.;\n    \n    for (int i = 0; i < 8; i++)\n    {\n        // From Dave_Hoskins https://www.shadertoy.com/user/Dave_Hoskins\n        value = max(value,value+(.25-abs(noise(uv * freq)+0.99) * amplitude));\n        \n        amplitude *= .17 + (0.1 * (sin(iTime*1.3)));\n        \n        freq *= 5.05;\n        \n        uv = uv.yx;\n    }\n    \n    return value*2.0-2.0;\n}\n\n\n//-----------------------------------------------------------------------------------------\n//---------     brandon and emilies terrain func                       --------------------\n//-----------------------------------------------------------------------------------------\n\nfloat my_terrain(in vec3 pos) {\n\n    float flr = pos.y - (fbm(vec2(pos.x, pos.z)));\n    \n    if (flr < -0.1){\n    \n        pos.xz += iTime;\n    }\n    return flr;\n\n\n}\n\n\n//-----------------------------------------------------------------------------------------\n//---------    personal water with modified fbm water function         --------------------\n//-----------------------------------------------------------------------------------------\nfloat my_water(in vec3 pos) {\n\n    float water = pos.y + 1.1 - (fbmWater(vec2(pos.x, pos.z)));\n    \n    return water;\n\n}\n\n\n//-----------------------------------------------------------------------------------------\n//---------     returns all of the sdf scene values with an out mat    --------------------\n//-----------------------------------------------------------------------------------------\nfloat map( in vec3 pos, out material mat ){\n    \n    //--------------------------------\n    //         the floor \n    //--------------------------------\n    float flr = my_terrain(pos);\n    \n    \n    \n    //--------------------------------\n    //         the water\n    //--------------------------------\n    float water =  my_water(pos);\n    \n    \n    //--------------------------------\n    //         the creature body\n    //--------------------------------\n    float creature = model(pos) - sin(iTime)*.004;\n    \n    \n    \n    mat.type = FIRE;\n\n\n    //--------------------------------\n    //         the creatures eyes\n    //--------------------------------\n    float eye1 = sdSphere(pos - vec3(.3,.9,1.6) , .05);\n    float eye2 = sdSphere(pos - vec3(-.1,.9,1.6) , .05);\n    \n    vec3 current = pos - vec3(.1,1.8,-2.1);\n    \n    if (current.y > .1){\n        current.y *= .5 * cos(iTime * 4.);\n        current.y = clamp(current.y, .065,1.);\n    }\n    \n    //--------------------------------\n    //         the creature - adding the tail\n    //--------------------------------\n    float tail = sdSphere(current , .05);\n    creature = opSmoothUnion(creature, tail, .99);\n    \n\n  \n    //--------------------------------\n    //         combining the floor with the creature\n    //--------------------------------\n    float m = min(flr, water);\n    \n    m = min(m,creature);\n    \n    m = min(m, eye1);\n    m = min(m, eye2);\n    m = min(m, tail);\n\n    \n    //--------------------------------\n    //         if our mat is floor, \n    //--------------------------------\n    if (m == flr) mat.type = TERRAIN;\n    \n    //--------------------------------\n    //         if our mat is water, \n    //--------------------------------\n    if (m == water) mat.type = WATER;\n    \n    //--------------------------------\n    //         if our mat is the eyeballs\n    //--------------------------------\n    if (m == eye1 || m == eye2){\n        mat.type = EYE;\n    }   \n\n    if ( m != eye1 || m != eye2 || m != water || m != flr ) {\n        mat.type == SKY;\n    \n    }\n    //--------------------------------\n    //        else our mat is the fire mwahah\n    //--------------------------------\n    return min(flr,water);\n}\n\n//-----------------------------------------------------------------------------------------\n//---------     calc normals from previous coding assignments (PA6)   ---------------------\n//-----------------------------------------------------------------------------------------\nvec3 calcNormal(in vec3 pos ){\n    material m;\n    vec3 x = vec3(EPSILON,0.0,0.0);\n    vec3 y = vec3(0.0,EPSILON,0.0);\n    vec3 z = vec3(0.0,0.0,EPSILON);\n    return normalize(vec3(map(pos + x,m ) - map(pos-x, m), \n                          map(pos + y,m) - map(pos-y,m ),\n                          map(pos + z,m ) - map(pos-z, m)));\n}\n\n//-----------------------------------------------------------------------------------------\n//---------     cast ray function with takes in a ray and outputs a mat   -----------------\n//-----------------------------------------------------------------------------------------\nfloat castRay(in ray r, out material m){\n\n    \n    float t = 0.0;\n   \n    // the more iterations the better resolution it will be, but can be heavy to process\n    for (int i = 0; i < 150; i ++){\n    \n        // moving the ray along by using the origin and adding incrementally t times the rays direction\n        vec3 pos = rayAt(r, t);\n        \n        \n        // did we hit something in our scene using the function map \n        float h = map(pos, m);\n        \n        // if hit something, we return what we found at t\n        if (h < EPSILON) return t;\n        \n        // else we keep going\n        t +=h;\n        \n        //past max distance\n        if (t > 40.0) {\n            \n            t = 0.0;\n            return t;\n        }\n    }\n    return t;\n}\n\n\n//-----------------------------------------------------------------------------------------\n//---------     returns a camera givena lookat vec3 and up vec3   -------------------------\n//-----------------------------------------------------------------------------------------\ncamera makeCam(vec3 lookfrom, vec3 lookat, vec3 vup){\n    camera cam;\n    cam.origin = lookfrom;\n    cam.w = normalize(lookat - lookfrom);\n    cam.u = normalize(cross(cam.w, vup));\n    cam.v = normalize(cross(cam.u,cam.w));\n    return cam;\n}\n\n//-----------------------------------------------------------------------------------------\n//---------     returns a camera givena lookat vec3 and up vec3   -------------------------\n//-----------------------------------------------------------------------------------------\nvec3 computerColor(float t, inout vec3 col, material m, in vec3 pos, vec2 uv){\n  \n    //------------------------------\n    // get the normal from the pos\n    //------------------------------\n    vec3 nor = calcNormal(pos);\n    \n    \n    //-----------------------------\n    // intensity of the lighting.  \n    //----------------------------\n    vec3 Lpos = vec3(0.8 ,0.4,1.2);\n    vec3 l = normalize(Lpos);\n    float intensity = max(0.0,dot(l,nor))/.23;\n   \n\n    // if we are greater than the min\n    if (t > 0.0){\n    \n    \n    \n    //-----------------------------------------------------------------------------------------\n    //----------------------  FIRE.                          ----------------------------------\n    //-----------------------------------------------------------------------------------------\n\n        if (m.type == FIRE){\n\n        float base = 1.0 - uv.y * .9;\n        float up1 = snoise(uv * 3.0 + vec2(0.,-iTime * 2.0)) ;\n        float up2 = 2.8 + snoise(uv * 6.0 + vec2(0.,-iTime)) ;\n\n        vec3 col1 = up1 * vec3(1.0,0.,0.0);\n        vec3 col2 = up2 * vec3(1.0,.6,0.);\n        \n        col = mix(col1,col2, base);\n        col *= vec3(1.0,0.,0.) * col + (vec3(1.) - col) ;\n        col *= intensity * l ;\n        \n        }\n        \n    //-----------------------------------------------------------------------------------------\n    //----------------------  TERRAIN.                         ----------------------------------\n    //-----------------------------------------------------------------------------------------\n        else if (m.type == TERRAIN){\n        \n            //-----------------------------\n            // emilie lighting \n            //-----------------------------\n            //___________________________ sun and sky colors ON the sphere ___________________\n            vec3 sun_dir = normalize(vec3(0.9, 0.4, -0.5) );\n\n            float sun_dif = clamp ( dot ( nor, sun_dir), 0.0, 1.0);\n\n            ray shadow_ray = ray(pos+nor*0.001, sun_dir);\n            float sun_shadow = step( castRay(shadow_ray, m), 0.0 );\n\n            float sky_dif = clamp ( dot ( nor, vec3(0.0, 1.0, 0.0)), 0.0, 1.0);\n\n            float bounce_dif = clamp ( dot ( nor, vec3(0.0, -1.0, 0.0)), 0.0, 1.0);\n\n            // ______________________________ color blending on the sphere ___________________\n            vec3 matt = vec3(0.3);\n\n            col = matt * vec3(3.0, 3.7, 3.5) * sun_dif * sun_shadow;\n            col += matt * vec3(0.0, 0.2, 0.4) * sky_dif;\n\n            //_______________________________ bounce light __________________________________\n            col += matt * vec3(0.1, 0.4, 0.4) * bounce_dif;\n\n            //_______________________________ color grading _________________________________\n            if(nor.y < 0.45){\n                col *= vec3(1., .5, .5);\n            } else if (nor.y < 0.75){\n                col *= vec3(0.1, .5, 0.1);\n            } else {\n                col *= vec3(.1, .1, .1);\n            }\n        }\n        \n        \n    //-----------------------------------------------------------------------------------------\n    //----------------------  BLACK EYES                          -----------------------------\n    //-----------------------------------------------------------------------------------------\n        else if (m.type == EYE){\n            col = vec3(0.0);\n        }\n        \n\n    //-----------------------------------------------------------------------------------------\n    //----------------------  water                        ------------------------------------\n    //-----------------------------------------------------------------------------------------\n        else if (m.type == WATER){\n        \n            //-----------------------------\n            // emilie lighting \n            //-----------------------------\n            //___________________________ sun and sky colors ON the sphere ___________________\n            vec3 sun_dir = normalize(vec3(0.9, 0.4, -0.5) );\n\n            float sun_dif = clamp ( dot ( nor, sun_dir), 0.0, 1.0);\n\n            ray shadow_ray = ray(pos+nor*0.001, sun_dir);\n            float sun_shadow = step( castRay(shadow_ray, m), 0.01 );\n\n\n            // ______________________________ color blending on the sphere ___________________\n            vec3 matt = vec3(0.0, 0.1, 0.3);\n\n            col = matt / (sun_shadow + vec3(1.0, 1.0, 0.0));\n            col += matt * vec3(0.0, 0.01, 0.05);\n        }\n    }\n    return col;\n}\n\n\n//=========================================================================================\n//-----------------------------------------------------------------------------------------\n//---------     where the main magic happens and everything comes together  ---------------\n//-----------------------------------------------------------------------------------------\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\n    //-----------------------------------------------------------------------------------------\n    //---------     uv cord from frag coord, center                             ---------------\n    //-----------------------------------------------------------------------------------------\n    //-----------------------------------------------------------------------------------------\n    vec2 uv = (2.0 * fragCoord - iResolution.xy)/iResolution.y;\n    //-----------------------------------------------------------------------------------------\n    \n\n    //-----------------------------------------------------------------------------------------\n    //---------     constructing the camera    w/ mouse input                   ---------------\n    //-----------------------------------------------------------------------------------------\n    //-----------------------------------------------------------------------------------------\n    float an = 10.0 * iMouse.x/iResolution.x;\n    vec3 lookfrom = vec3(4.0 * sin(an), 1,4.0*cos(an));\n    vec3 lookat = vec3(0.0, 0.9,0.);\n    vec3 vup = vec3(0,1,0);\n\n    camera cam = makeCam(lookfrom, lookat, vup); \n   \n\n   \n    //-----------------------------------------------------------------------------------------\n    //                                   material we need for raycast - curr empty\n    //-----------------------------------------------------------------------------------------\n    material m;\n\n\n    //-----------------------------------------------------------------------------------------\n    //                        step 1 - construct the ray from the camera and frag coord\n    //-----------------------------------------------------------------------------------------\n    ray r = getray(cam, uv);\n    \n   \n    //-----------------------------------------------------------------------------------------\n    //                                   default sky box color \n    //-----------------------------------------------------------------------------------------\n    \n    //--------------------------------------------------------------------\n    //     taken from pa6 - just makes a gradient for the sky\n    //------------------------------------------------------------------\n    \n    // color vars\n    vec3 white = vec3(1.0, 1.0, 1.0);\n    vec3 blue = vec3(0.4, 0.6, 0.9);\n    \n    // normalized direction\n    vec3 normalizedRay = normalize(r.dir);\n    \n    // formula for gradient\n    float temp = 0.9 * (normalizedRay.y + 1.5);\n    \n    vec3 col = (1.0 - temp) * white + temp * blue;\n    \n   \n   \n    //-----------------------------------------------------------------------------------------\n    //                         step 2 - cast ray, keep track of the material\n    //-----------------------------------------------------------------------------------------\n    float t = castRay(r, m);\n    \n    //-----------------------------------------------------------------------------------------\n    //                         step 3 - construct position from camera\n    //                                 look at plus where we hit the obj (or didnt hit and return sky mat hehe )\n    //-----------------------------------------------------------------------------------------\n    vec3 pos = lookfrom + t * r.dir;\n\n\n    //-----------------------------------------------------------------------------------------\n    //                         step 4 - final compute the color\n    //-----------------------------------------------------------------------------------------\n    col = computerColor(t, col, m, pos, uv);\n\n\n    //-----------------------------------------------------------------------------------------\n    //                         step 4 - gamma correction ?\n    //-----------------------------------------------------------------------------------------\n    col = pow(col,vec3(1.0/2.4));\n    \n   \n    //-----------------------------------------------------------------------------------------\n    //                         step 5 - return the color we found\n    //-----------------------------------------------------------------------------------------\n    fragColor = vec4(col, 1.);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"//====================================  sd cone  =========================================\nfloat sdCone( vec3 p, vec2 c, float h )\n{\n  float q = length(p.xz);\n  return max(dot(c.xy,vec2(q,p.y)),-h-p.y);\n}\n\n//====================================  sd sphere  =========================================\nfloat sdSphere(vec3 p, float r)\n{\n \treturn length(p) - r;\n}\n\n//====================================  round function  =========================================\nfloat opRound(float d, float iso)\n{\n    // TODO\n    return d - iso;\n}\n\n//====================================  smooth union  =========================================\nfloat opSmoothUnion(float d1, float d2, float k)\n{\n    // TODO\n    float h = max(k - abs(d1-d2),0.0);\n    return min(d1,d2) - (h*h)/( 4.0* k); \n}\n\n\n\n\n//-----------------------------------------------------------------------------------------\n//-----------------------------------------------------------------------------------------\n//-----------------------------------------------------------------------------------------\n//-----------------------------------------------------------------------------------------\n//-----------------------------------------------------------------------------------------\n//-----------------------------------------------------------------------------------------\n\n// Copyright Â© 2022 Wojciech Jarosz\n// Based off of Andrew Kensler's blog: http://eastfarthing.com/blog/2015-04-21-noise/\n\n\n// map fragment coordinates to world coordinates\n\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\n//----------------------------------------------------------------------------------------\n//  1 out, 2 in...\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//----------------------------------------------------------------------------------------\n//  1 out, 3 in...\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//----------------------------------------------------------------------------------------\n//  2 out, 1 in...\nvec2 hash21(float p)\n{\n\tvec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n//----------------------------------------------------------------------------------------\n///  2 out, 2 in...\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n//----------------------------------------------------------------------------------------\n///  2 out, 3 in...\nvec2 hash23(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\n//----------------------------------------------------------------------------------------\n//  3 out, 1 in...\nvec3 hash31(float p)\n{\n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\n\n//----------------------------------------------------------------------------------------\n///  3 out, 2 in...\nvec3 hash32(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\n//----------------------------------------------------------------------------------------\n///  3 out, 3 in...\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n\n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 1 in...\nvec4 hash41(float p)\n{\n\tvec4 p4 = fract(vec4(p) * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n    \n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 2 in...\nvec4 hash42(vec2 p)\n{\n\tvec4 p4 = fract(vec4(p.xyxy) * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n\n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 3 in...\nvec4 hash43(vec3 p)\n{\n\tvec4 p4 = fract(vec4(p.xyzx)  * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 4 in...\nvec4 hash44(vec4 p4)\n{\n\tp4 = fract(p4  * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\n\n\nfloat falloff(float t)\n{\n    float t2 = clamp(0.0, 1.0, abs(t));\n\n    return 1.0 - smoothstep(0.0, 1.0, t2);\n}\n\nvec2 grad(vec2 center)\n{\n    // 1D random angle\n    float angle = radians(360.*hash12(center));\n    \n    vec2 g = vec2(cos(angle), sin(angle));\n    //vec2 g = vec2(frag2World(iMouse.xy) - center);\n    return g;\n}\n\nfloat bump(vec2 p, vec2 center)\n{\n    vec2 offset = p - center;\n    \n    float b = falloff(offset.x) * falloff(offset.y);\n    \n    float v = 2.*hash12(center) - 1.;\n    return v * b;\n}\n\n\n// signed noise\n// return value in [-1,1]\nfloat snoise(vec2 p)\n{\n    float result = 0.;\n    \n    vec2 ll = floor(p);\n    \n    result += bump(p, ll + vec2(0., 0.0));\n    result += bump(p, ll + vec2(1., 0.0));\n    result += bump(p, ll + vec2(1., 1.0));\n    result += bump(p, ll + vec2(0., 1.0));\n    return result;\n}\n\n\nvec3 permute(vec3 x)\n{ \n    return mod(((x*34.0)+1.0)*x, 289.0);\n}\n\n//-----------------------------------------------------------------------------------------\n//-----------------------------------------------------------------------------------------\n//-----------------------------------------------------------------------------------------\n//-----------------------------------------------------------------------------------------\n\n","name":"Common","description":"","type":"common"}]}