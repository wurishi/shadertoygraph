{"ver":"0.1","info":{"id":"4dGXWy","date":"1466271122","viewed":634,"name":"Spherical harmonics exercise 1","username":"xchip","description":"Left side computes visibility sampling the hemisphere\nRight side, computes and encode visibility into spherical harmonics, then decodes visibility. \n\n","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["sphericalharmonicsvisibility"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Created by Raul Aguaviva - 2016\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// The point of this shader is to show the sort of artifacts that SH introduce.\n\n// The left side of the screen shows the visibility computed stochastically, \n// The right side encodes that visibility in spherical harmonics and immediately it decodes it. \n//\n// Spherical harmonics are using extensively in quantum mechanics to study the hydrogen atom. \n// did you ever wonder why the SHs use the letters 'l' and 'm'? That is because 'l' is the angular \n// momentum and 'm' is the magnetic number. All the SHs that have the same 'l' have the same angular \n// momentum (represented often with the letter 'L')\n//\n// This sample uses a fair amount of code from these samples (Thanks to IQ): \n// \t- https://www.shadertoy.com/view/4djSDy\n// \t- https://www.shadertoy.com/view/lsfXWH\n//\n// Thanks to Matt Pharr for his excellent PBR book and in special for the SH chapter.\n\n#define SAMPLECOUNT 1024\n\n// Constants, see here: http://en.wikipedia.org/wiki/Table_of_spherical_harmonics\n#define k01 0.2820947918 // sqrt(  1/PI)/2\n#define k02 0.4886025119 // sqrt(  3/PI)/2\n#define k03 1.0925484306 // sqrt( 15/PI)/2\n#define k04 0.3153915652 // sqrt(  5/PI)/4\n#define k05 0.5462742153 // sqrt( 15/PI)/4\n#define k06 0.5900435860 // sqrt( 70/PI)/8\n#define k07 2.8906114210 // sqrt(105/PI)/2\n#define k08 0.4570214810 // sqrt( 42/PI)/8\n#define k09 0.3731763300 // sqrt(  7/PI)/4\n#define k10 1.4453057110 // sqrt(105/PI)/4\n\n// Y_l_m(s), where l is the band and m the range in [-l..l] \nfloat SphericalHarmonic( in int l, in int m, in vec3 s ) \n{ \n\tvec3 n = s.zxy;\n\t\n    //----------------------------------------------------------\n    if( l==0 )          return  k01;\n    \n    //----------------------------------------------------------\n\tif( l==1 && m==-1 ) return -k02*n.y;\n    if( l==1 && m== 0 ) return  k02*n.z;\n    if( l==1 && m== 1 ) return -k02*n.x;\n    \n    //----------------------------------------------------------\n\tif( l==2 && m==-2 ) return  k03*n.x*n.y;\n    if( l==2 && m==-1 ) return -k03*n.y*n.z;\n    if( l==2 && m== 0 ) return  k04*(3.0*n.z*n.z-1.0);\n    if( l==2 && m== 1 ) return -k03*n.x*n.z;\n    if( l==2 && m== 2 ) return  k05*(n.x*n.x-n.y*n.y);\n    //----------------------------------------------------------\n    if( l==3 && m==-3 ) return -k06*n.y*(3.0*n.x*n.x-n.y*n.y);\n    if( l==3 && m==-2 ) return  k07*n.z*n.y*n.x;\n    if( l==3 && m==-1 ) return -k08*n.y*(5.0*n.z*n.z-1.0);\n    if( l==3 && m== 0 ) return  k09*n.z*(5.0*n.z*n.z-3.0);\n    if( l==3 && m== 1 ) return -k08*n.x*(5.0*n.z*n.z-1.0);\n    if( l==3 && m== 2 ) return  k10*n.z*(n.x*n.x-n.y*n.y);\n    if( l==3 && m== 3 ) return -k06*n.x*(n.x*n.x-3.0*n.y*n.y);\n    //----------------------------------------------------------\n\n\treturn 0.0;\n}\n\nstruct SphericalHarmonicsCoeffs\n{\n    float v[9];\n};\n\nvoid  SphericalHarmonicsInit(out SphericalHarmonicsCoeffs coeffs)\n{\n    for (int i = 0; i < 9; i++)\n    {\n        coeffs.v[i] = 0.;\n    }\n}\n\nvoid SphericalHarmonicsMul(float scalar, inout SphericalHarmonicsCoeffs coeffs)\n{\n    for (int i = 0; i < 9; i++)\n    {\n        coeffs.v[i] *= scalar;\n    }\n}\n\n\n\nvoid SphericalHarmonicsProject(vec3 n, float value, inout SphericalHarmonicsCoeffs coeffs)\n{\n    coeffs.v[0] += SphericalHarmonic(0,  0, n) * value;\n\n    coeffs.v[1] += SphericalHarmonic(1, -1, n) * value;\n    coeffs.v[2] += SphericalHarmonic(1,  0, n) * value;\n    coeffs.v[3] += SphericalHarmonic(1,  1, n) * value;\n\n    coeffs.v[4] += SphericalHarmonic(2, -2, n) * value;\n    coeffs.v[5] += SphericalHarmonic(2, -1, n) * value;\n    coeffs.v[6] += SphericalHarmonic(2,  0, n) * value;\n    coeffs.v[7] += SphericalHarmonic(2,  1, n) * value;\n    coeffs.v[8] += SphericalHarmonic(2,  2, n) * value;\n    \n}\n\nfloat SphericalHarmonicsEval(vec3 n, in SphericalHarmonicsCoeffs coeffs)\n{\n    float res = 0.;\n\n    res += SphericalHarmonic(0,  0, n) * coeffs.v[0];\n\n    res += SphericalHarmonic(1, -1, n) * coeffs.v[1];\n    res += SphericalHarmonic(1,  0, n) * coeffs.v[2];\n    res += SphericalHarmonic(1,  1, n) * coeffs.v[3];\n\n    res += SphericalHarmonic(2, -2, n) * coeffs.v[4];\n    res += SphericalHarmonic(2, -1, n) * coeffs.v[5];\n    res += SphericalHarmonic(2,  0, n) * coeffs.v[6];\n    res += SphericalHarmonic(2,  1, n) * coeffs.v[7];\n    res += SphericalHarmonic(2,  2, n) * coeffs.v[8];\n    \n    return res;\n}\n\n//=====================================================\n\n// Sphere intersection\nfloat sphIntersect( in vec3 ro, in vec3 rd, in vec4 sph )\n{\n\tvec3 oc = ro - sph.xyz;\n\tfloat b = dot( oc, rd );\n\tfloat c = dot( oc, oc ) - sph.w*sph.w;\n\tfloat h = b*b - c;\n\tif( h<0.0 ) return -1.0;\n\treturn -b - sqrt( h );\n}\n\nfloat iPlane( in vec3 ro, in vec3 rd )\n{\n    return (-1.0 - ro.y)/rd.y;\n}\n\nfloat Scene(in vec3 pos, in vec3 dir, out vec3 normal)\n{\n   float tmin = 1e3;\n    \n    pos+=dir*0.0001; //just to avoid self intersections\n\n   vec4 sph = vec4( cos( .5* iTime + vec3(2.0,1.0,1.0) + 0.0 )*vec3(0.,1.2,0.0), 1.0 );\n   float t2 = sphIntersect( pos, dir, sph );        \n   if( t2>0.0 && t2<tmin )\n   {\n       tmin = t2;\n       vec3 pos = pos + tmin*dir;\n       normal = normalize( pos - sph.xyz );\n   }      \n    \n   t2 = iPlane( pos, dir );\n   if( t2>0.0 && t2<tmin )\n   {\n       tmin = t2;\n       normal = vec3(0.0,1.0,0.0);\n   }    \n    \n    \n    return tmin;    \n}\n\nfloat SceneViz(in vec3 pos, in vec3 dir)\n{\n    vec3 normal;\n    float res = Scene(pos, dir, normal);\n    return res!=1e3?1.:0.;//step(0.0,res);    \n}\n\n\n//=====================================================\n\nvec2 hash2( float n ) { return fract(sin(vec2(n,n+1.0))*vec2(43758.5453123,22578.1459123)); }\n\nfloat ComputeViz(in vec3 pos, in vec3 dir)\n{\n    vec3  ru  = normalize( cross( dir, vec3(0.0,1.0,1.0) ) );\n    vec3  rv  = normalize( cross( ru, dir ) );\n\n    float occ = 0.0;\n    for( int i=0; i<SAMPLECOUNT; i++ )\n    {\n        vec2  aa = hash2( float(i)*203.1 );\n        float ra = sqrt(aa.y);\n        float rx = ra*cos(6.2831*aa.x); \n        float ry = ra*sin(6.2831*aa.x);\n        float rz = sqrt( 1.0-aa.y );\n        vec3  rdir = vec3( rx*ru + ry*rv + rz*dir );\n        \n        occ += SceneViz(pos, rdir);\n    }\n    occ /= float(SAMPLECOUNT);\n    \n    return occ;\n}\n\nvoid ComputeVizSH(in vec3 pos, in vec3 dir, out SphericalHarmonicsCoeffs coeffsVis)\n{\n    SphericalHarmonicsInit(coeffsVis);    \n    \n    vec3  ru  = normalize( cross( dir, vec3(0.0,1.0,1.0) ) );\n    vec3  rv  = normalize( cross( ru, dir ) );\n\n    for( int i=0; i<SAMPLECOUNT; i++ )\n    {\n        vec2  aa = hash2( float(i)*203.1 );\n        float ra = sqrt(aa.y);\n        float rx = ra*cos(6.2831*aa.x); \n        float ry = ra*sin(6.2831*aa.x);\n        float rz = sqrt( 1.0-aa.y );\n        vec3  rdir = vec3( rx*ru + ry*rv + rz*dir );\n        \n        float occ = SceneViz(pos, rdir);\n        if (occ>.0)\n        {\n        \tSphericalHarmonicsProject(rdir, 1., coeffsVis);\n        }\n    }\n    \n    //montecarlo stuff\n    SphericalHarmonicsMul( 2.0*( 2.0 * 3.1415)/ float(SAMPLECOUNT), coeffsVis);   \n}\n\n\n//note that when we are evaluating we need to sample the whole sphere\nfloat EvalVisibilitySH(SphericalHarmonicsCoeffs coeffsVis)\n{\n    float occ = 0.0;\n    for( int i=0; i<SAMPLECOUNT; i++ )\n    {\n        vec2  aa = hash2( float(i)*203.1 );\n        float rz = 1. - 2.*aa.y;\n        float ra = sqrt(1.-rz*rz);\n        float rx = ra*cos(6.2831*aa.x); \n        float ry = ra*sin(6.2831*aa.x);\n        \n        vec3  rdir = vec3( rx , ry , rz );\n        \n        occ += SphericalHarmonicsEval(rdir, coeffsVis);\n    }\n    occ /= float(SAMPLECOUNT);\n    \n    return occ;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (2.0*fragCoord.xy-iResolution.xy) / iResolution.y;\n    float s = (2.0*iMouse.x-iResolution.x) / iResolution.y;\n    if( iMouse.z<0.001 ) s=0.0;\n    \n\tvec3 ro = vec3(0.0, 0.0, 4.0 );\n\tvec3 rd = normalize( vec3(p,-2.0) );\n\t\n    vec3 col = vec3(0.0);\n\n    float tmin = 1e10;\n    vec3 nor = vec3(0.0,0.0,0.0);\n    float t1 = Scene( ro, rd, nor );\n    if( t1>0.0 )\n    {\n        tmin = t1;\n        vec3 pos = ro + tmin*rd;\n        \n        float occ = 0.0;\n        \n        col = vec3(1.0);\n        \n        if( p.x > s )\n        {\n            SphericalHarmonicsCoeffs vizCoeffs;\n            \n            //encode visibility function into spherical harmonics            \n            ComputeVizSH(pos, nor, vizCoeffs);\n\n            //evaluate for the normal direction\n            occ = EvalVisibilitySH(vizCoeffs);           \n        }\n        else\n        {\n            occ = ComputeViz(pos, nor);           \n        }                    \n        \n        col *= 1.0 - occ;\n    }\n\n\tcol *= exp( -0.05*tmin );\n\n    float e = 2.0/iResolution.y;\n    col *= smoothstep( 0.0, 2.0*e, abs(p.x-s) );\n    \n    //gamma, not used to make the effect more dramatic\n    col = pow( col, vec3(1.0/2.2) );\n    \n    fragColor = vec4( col, 1.0 );\n}","name":"Image","description":"","type":"image"}]}