{"ver":"0.1","info":{"id":"WdsBzr","date":"1587629145","viewed":111,"name":"Day8: 2D Gear","username":"fluxatron","description":"Built a simple gear. Nothing too exciting today.\n\nBased on iq's Sphere Gears tutorial... but in 2D.\nhttps://www.youtube.com/watch?v=sl9x19EnKng","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["learning"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// CONTROL\n#define NUM_SECTORS 12.\n\n\n// MATH CONSTANTS\n#define PI 3.1415926\n#define TAU 6.283185\n#define BIG_FLOAT 99999999.\n\n\n// TRANFORMATIONS //////////////////////////////////////////////////////////\nmat3 CreateTranslationMat(vec2 translation)\n{\n    return mat3(vec3(1,0,0), \n                vec3(0,1,0), \n                vec3(translation,1));\n}\nmat3 CreateScaleMat(vec2 scale)\n{\n    return mat3(scale.x, 0, 0,\n                0, scale.y, 0,\n                0, 0,       1);\n}\nmat3 CreateScaleMat(float scale)\n{\n    return CreateScaleMat(vec2(scale));\n}\nmat3 CreateRotationMat(float rad)\n{\n    return mat3(cos(rad), sin(rad), 0,\n               -sin(rad), cos(rad), 0,\n                0,        0,        1);\n}\nmat3 CreateAffineMat(vec2 scale, float rotation, vec2 translation)\n{\n    mat3 S = mat3(CreateScaleMat(scale));\n    mat3 R = mat3(CreateRotationMat(rotation));\n    mat3 T = CreateTranslationMat(translation);\n    return S*R*T;\n}\nmat3 CreateAffineMat(float scale, float rotation, vec2 translation)\n{\n    return CreateAffineMat(vec2(scale), rotation, translation);\n}\nmat3 Translate(mat3 m, vec2 translation)\n{\n    return m * CreateTranslationMat(translation);\n}\nmat3 Rotate(mat3 m, float rad)\n{\n    return m * CreateRotationMat(rad);\n}\nmat3 Scale(mat3 m, float scale)\n{\n    return m * CreateScaleMat(scale);\n}\nmat3 Scale(mat3 m, vec2 scale)\n{\n    return m * CreateScaleMat(scale);\n}\n\n\n// SHAPES //////////////////////////////////////////////////////////////////\nfloat sdCircle(in vec2 p, in float r)\n{\n    return length(p)-r;\n}\nfloat sdRect(in vec2 p, in vec2 r)\n{\n    return length(max(abs(p)-r, 0.0));\n}\n\n\n// SCENE ///////////////////////////////////////////////////////////////////\nvec3 map(in vec2 p, float time)\n{\n    float pAngle = atan(p.y,p.x);\n    float segAngle = TAU/NUM_SECTORS;\n    float sector = round(pAngle/segAngle);\n    \n    // Fold space to the right hand sector so we draw once but show NUM_SECTORS times\n    vec2 q = mat2(CreateRotationMat(-segAngle*sector)) * p;\n    \n    float dRect = sdRect(q-vec2(.2,0.), vec2(0.04,.015)) - 0.02;\n    float dRing = abs(sdCircle(q-vec2(.0,0.), 0.17)) - 0.03;\n    \n    \n    // Find closest\n    float d = BIG_FLOAT;\n    d = min(dRing, d);\n    d = min(dRect, d);\n    \n    return vec3(d, p);\n}\n\n\n// MAIN ////////////////////////////////////////////////////////////////////\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float aspect = iResolution.x / iResolution.y;\n    vec2 uv = (2.0*fragCoord - iResolution.xy) / iResolution.y; //(-aspect,-1) to (apsect,1)]\n    vec3 col = vec3(0);\n\t\n    \n    // View\n    mat3 V = CreateAffineMat(.4, iTime, vec2(-0.0));\n    uv = (V * vec3(uv,1.)).xy;\n    \n    \n    float dist = map(uv, iTime).x;\n    col = vec3(smoothstep(3./iResolution.x,0.0,dist));\n\t\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}