{"ver":"0.1","info":{"id":"lsdXDM","date":"1459855244","viewed":115,"name":"Juego sphere","username":"sreveloa","description":"random movement sphere screen","likes":0,"published":1,"flags":32,"usePreview":0,"tags":["3d"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define CENTRO 0.0\n#define PINCHADO_CIRCULO 1.0\n\n#define load(a) texture(iChannel0,(vec2(a + 0.5,0.0))/iResolution.xy)\n\n\nconst float eps =0.01;\n\nfloat sphere (in vec3 p, float r)\n{\n    \n    return length(p) - r;\n}\n\n    \n    float scene (in vec3 p)\n{\n    \n    return (sphere(p,1.));\n}\n\nvec3 calcNormal(in vec3 p)\n{\n    vec3 normal;\n    vec3 ep = vec3(eps,0,0);\n    normal.x=scene(p+ep.xyz)-scene(p-ep.xyz);\n    normal.y=scene(p+ep.yxz)-scene(p-ep.yxz);\n    normal.z=scene(p+ep.yzx)-scene(p-ep.yzx);\n    return normalize(normal);\n   \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = vec2((fragCoord.x - iResolution.x *.5) / iResolution.y, (fragCoord.y - iResolution.y *.5)/ iResolution.y) ;\n    \n\tvec3 finalColor = vec3(0,1,1);\n    \n//    vec3 rayStart= vec3 (1,0,4);\n    vec3 rayStart = vec3(load(CENTRO));\n    vec3 rayDir = normalize(vec3(uv,-1));\n   \n    float t = 0.0;\n    for (int i=0; i<32;++i)\n        {vec3 p = rayStart + rayDir*t;\n         float dist = scene(p);\n         if (dist<eps)\n         {\n             vec3 normal = calcNormal(p);                                \n      finalColor = vec3(1,0,1) * max(dot(normal,vec3(sin(iTime), cos(iTime),0.33)),0.);\n        }\n    \n         t += dist;\n         \n}\n         fragColor = vec4(finalColor,1.0);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define RADIUS 0.05\n\n#define CENTRO 0.0\n#define PINCHADO_CIRCULO 1.0\n#define DIRECCION 2.0\n\n#define load(a) texture(iChannel0,(vec2(a + 0.5,0.0))/iResolution.xy)\n\nfloat aleatorio(float semilla)\n{\n    return sin(iDate.w * semilla + 0.000001 * iTime);\n}\n\nvec4 calcularCentro()\n{\n\tvec3 centro;\n    if (iFrame < 5)\n    {\n        // PosiciÃ³n inicial\n        centro = vec3(0.0, 0.0, 15.0);\n    }\n    else\n    {\n        vec4 direccionActual = load(DIRECCION);\n        vec4 centroActual = load(CENTRO);\n        float numeroFrameInicial = direccionActual.w;\n        float numeroFrameRelativo = float(iFrame) - numeroFrameInicial;\n        float velocidad = 0.01;\n\n        centro = vec3(centroActual) + vec3(direccionActual) * numeroFrameRelativo * velocidad;\n\n        // LÃ­mite del eje Z\n        float limiteZmin = 5.0;\n        if (centro.z < limiteZmin)\n            centro.z = limiteZmin;\n        \n        float limiteZmax = 30.0;\n        if (centro.z > limiteZmax)\n            centro.z = limiteZmax;\n\n        // LÃ­mite del eje X\n        float limiteX = centro.z * 0.7;\n        if (abs(centro.x) > limiteX)\n            centro.x = sign(centro.x) * limiteX;\n\n        // LÃ­mite del eje Y\n        float limiteY = centro.z * 0.5;\n        if (abs(centro.y) > limiteY)\n            centro.y = sign(centro.y) * limiteY;\n\n    }\n    \n    return vec4(centro, 1.0);\n}\n\nbool pincharCirculo(vec2 center, float radius)\n{\n    if(iMouse.z>0.0)\n    {\n        vec2 p=iMouse.xy/iResolution.xy;\n        \n        if (distance(center, p) <= radius)\n        {\n            return true;\n        }\n    }\n    \n    return false;\n}\n\nvec4 calcularDireccion(vec4 direccionActual)\n{\n    if (iFrame < 2)\n    {\n        // PosiciÃ³n inicial\n        return normalize(vec4(1.0, 1.0, 0.0, 0.0));\n    }\n    else\n    {\n        vec4 centroActual = load(CENTRO);\n        if (abs(fract(float(iFrame) * 0.02)) <= 0.02)\n        {\n            vec3 dir = vec3(0.0);\n            dir.x = aleatorio(direccionActual.z * centroActual.y);\n            dir.y = aleatorio(dir.x * centroActual.z);\n            dir.z = aleatorio(dir.y * centroActual.x);\n\n            return vec4(normalize(dir), float(iFrame));\n        }\n        else\n        {\n            return direccionActual;\n        }\n    }\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Recoge el valor anterior del bÃºfer\n  \tfragColor = texture(iChannel0,fragCoord/iResolution.xy);\n    \n    // Comprueba si anteriormente se pinchÃ³ el cÃ­rculo\n    vec4 pinchadoCirculo = load(PINCHADO_CIRCULO);\n    \n    // SÃ³lo se hace algo si todavÃ­a no se ha llegado a pinchar el cÃ­rculo\n    if (pinchadoCirculo.x == 0.0)\n    {\n        // Calcula el centro del cÃ­rculo\n        vec4 center = calcularCentro();\n        \n        // Si estamos en la zona del bÃºfer donde se almacena si se ha pinchado el cÃ­rculo...\n        if (fragCoord.x > PINCHADO_CIRCULO && fragCoord.x < PINCHADO_CIRCULO + 1.0)\n        {\n            // Si se ha pinchado dentro del cÃ­rculo...\n\t        if (pincharCirculo(center.xy, RADIUS))\n            {\n                fragColor.x = 1.0;\n            }\n        }\n        // Si estamos en la zona del bÃºfer donde se almacena el centro del cÃ­rculo...\n        else if (fragCoord.x > CENTRO && fragCoord.x < CENTRO + 1.0)\n        {\n            fragColor = center;\n        }\n        else if (fragCoord.x > DIRECCION && fragCoord.x < DIRECCION + 1.0)\n        {\n            fragColor = calcularDireccion(fragColor);\n        }\n    }\n}","name":"Buf A","description":"","type":"buffer"}]}