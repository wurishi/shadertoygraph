{"ver":"0.1","info":{"id":"lc3czr","date":"1730155958","viewed":14,"name":"Lundi","username":"Djeinaba_dia","description":"shade toy modif ","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["infographie"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"struct Sphere{\n    vec3 c;// Center\n    float r;// Radius\n    int i;// Texture Id\n};\n\nstruct Box{\n    vec3 a;\n    vec3 b; //a et b points\n    //float dim; //longueur des côté de la boite\n    int i;\n};\n\nstruct Box2{\n    vec3 center;\n    float x; //dimension sur l'axe x\n    float y; //dimension sur l'axe y\n    float z; //dimension sur l'axe z\n    int i;\n};\n\n//cylindre avec axe z parallele au monde\nstruct Cylinder{\n    vec3 center;\n    float r; //rayon du cylindre\n    float h; //hauteur du cylindre\n    int i;\n};\n\nstruct Capsule{\n    vec3 c; //c est un point du sphere bas \n    vec3 p; //p est un point du sphere haut \n    float r; //r est le rayon du sphère de la capsule\n    int i;\n};\n\nstruct Plane{\n    vec3 n;// Normal\n    vec3 p;// Point\n    int i;// Texture Id\n};\n\n/*\nstruct Ellipse{\n    vec3 center;\n    vec3 a;\n    vec3 b;\n    vec3 c;\n    int i;\n};\n*/\n\nstruct Ellipse{\n    vec3 c;//Center\n    float r1;//Radius1\n    float r2;//Radius2\n    float r3;//Radius3\n    int i;\n};\n\n\nstruct Hit{\n    float t;// Intersection depth\n    vec3 n;// Normal\n    int i;// Texture Id\n};\n\nstruct Ray{\n    vec3 o;// Origin\n    vec3 d;// Direction\n};\n\nstruct Material\n{\n    vec3 d;// Diffuse\n    float spec;//specular intensity pour faire briller le matériel\n};\n\n\nstruct Light\n{\n    vec3 dir; //direction\n    vec3 diff; //color of light\n    vec3 ambiant;\n};\n\nfloat Checkers(in vec2 p)\n{\n    // Filter kernel\n    vec2 w=fwidth(p)+.001;\n    // Box box filter\n    vec2 i=2.*(abs(fract((p-.5*w)*.5)-.5)-abs(fract((p+.5*w)*.5)-.5))/w;\n    // xor pattern\n    return.5-.5*i.x*i.y;\n}\n\n// Hashing function\n// Returns a random number in [-1,1]\n// p : Vector in space\nfloat Hash(in vec3 p)  \n{\n    p  = fract( p*0.3199+0.152 );\n\tp *= 17.0;\n    return fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\n}\n\n// Procedural value noise with cubic interpolation\n// x : Point \nfloat Noise(in vec3 p)\n{\n    vec3 i = floor(p);\n    vec3 f = fract(p);\n  \n    f = f*f*(3.0-2.0*f);\n    // Could use quintic interpolation instead of cubic\n    // f = f*f*f*(f*(f*6.0-15.0)+10.0);\n\n    return mix(mix(mix( Hash(i+vec3(0,0,0)), \n                        Hash(i+vec3(1,0,0)),f.x),\n                   mix( Hash(i+vec3(0,1,0)), \n                        Hash(i+vec3(1,1,0)),f.x),f.y),\n               mix(mix( Hash(i+vec3(0,0,1)), \n                        Hash(i+vec3(1,0,1)),f.x),\n                   mix( Hash(i+vec3(0,1,1)), \n                        Hash(i+vec3(1,1,1)),f.x),f.y),f.z);\n}\n\n// Compute point on ray\nvec3 Point(Ray ray,float t)\n{\n    return ray.o+t*ray.d;\n}\n\n//a, b : vecteur de couleur\nvec3 bois(vec3 p, vec3 a, vec3 b)\n{\n    p=p+Noise(p/0.9)+7.;\n    float d=2.*length(p.xy);\n    float v=0.5*(cos(d/0.1)+1.0);\n    vec3 c=mix(a,b,v);\n    return c;\n}\n\nvec3 Axial (vec3 p) \n{\n    float r = sqrt (p.x*p.x + p.z*p.z);\n    return vec3(0.5+0.5*cos(3.1415927*r));\n}\n\nvec3 bandes(vec3 p)\n{\n    vec3 c=Axial(p);\n    return c;\n}\n\n//a, b : vecteur de couleur\nvec3 damier(vec3 p, vec3 a, vec3 b)\n{\n    int x = int(p.x);\n    int y = int(p.y);\n    int z = int(p.z);\n    if ((x+y+z)%2 == 0)\n    {\n        return a;\n    }\n    else\n    {\n        return b;\n    }\n}\n\n// Compute color\n// i : Texture index\n// p : Point\nMaterial Texture(vec3 p,int i)\n{\n    if(i==5)\n    {\n        return Material(vec3(.1,.1,.4),0.5);\n    }\n    if(i==4)\n    {\n        return Material(bandes(p),0.);\n    }\n    if(i==3)\n    {\n        return Material(damier(p,vec3(1.,0.,0.),vec3(0.,0.502,0.)),0.);\n    }\n    if(i==2)\n    {\n        return Material(bois(p,vec3(0.89, 0.64, 0.18 ),vec3(0.31, 0.16, 0.03)),0.);\n    }\n    if(i==1)\n    {\n        return Material(vec3(.8,.5,.4),0.5);\n    }\n    else if(i==0)\n    {\n        // compute checkboard\n        float f=Checkers(.5*p.xy);\n        vec3 col=vec3(.4,.5,.9)+f*vec3(.1);\n        return Material(col,1.);\n    }\n    return Material(vec3(0),0.);\n}\n\n//Sphere Capsule Intersection\nbool IntersectSphCaps(Ray ray, Sphere sph, bool upper, out Hit x){\n    vec3 oc = ray.o - sph.c;\n    float b = dot(oc, ray.d);\n    float c = dot(oc, oc) - sph.r*sph.r;\n    float discriminant = b*b-c;\n    if(discriminant > 0.0) {\n        float t = -b - sqrt(discriminant);\n        \n        if(t > 0.0) {\n           vec3 localIntersectionPoint = Point(ray,t);\n           if(upper){\n               vec3 normal = normalize(localIntersectionPoint-sph.c);\n               if(dot(normal,vec3(0,0,1)) < 0.) return false;\n               x = Hit(t, normal, sph.i);\n               return true;\n           } else {\n               vec3 normal = normalize(localIntersectionPoint-sph.c);\n               if(dot(normal,vec3(0,0,-1)) < 0.) return false;\n               x = Hit(t, normal, sph.i);\n               return true;\n           }\n        }\n    }\n    \n    return false;\n}\n\n//Capsule Intersection\nbool IntersectCapsule(Ray ray,Capsule caps,out Hit x){\n   float ocx = ray.o.x - caps.c.x;\n   float ocy = ray.o.y - caps.c.y;\n   float a = (ray.d.x*ray.d.x) + (ray.d.y*ray.d.y);\n   float b = 2.0 * ((ocx*ray.d.x)+(ocy*ray.d.y));\n   float c = (ocx*ocx) + (ocy*ocy) - (caps.r*caps.r);\n   float discriminant = b*b-4.*a*c;\n    if (discriminant > 0.0) {\n        float t = (-b - sqrt(discriminant)) / (2.0 * a);\n\n        if (t > 0.0) {\n            vec3 localIntersectionPoint = Point(ray,t);\n               if(localIntersectionPoint.z>=caps.c.z && localIntersectionPoint.z<=caps.p.z){\n                   vec3 y = caps.p - caps.c;\n                   vec3 p = caps.c + (dot(y,localIntersectionPoint-caps.c)/dot(y,y))*y;\n                   vec3 normal = normalize(localIntersectionPoint - p);\n                   x = Hit(t, normal, caps.i);\n                   return true;\n               } \n        }\n    }\n    bool ret= false;\n    float t = 1000.;\n    if(IntersectSphCaps(ray, Sphere(caps.c, caps.r, caps.i), false, x )){\n        t=x.t;\n        ret=true;\n    }\n    if(IntersectSphCaps(ray, Sphere(caps.p, caps.r, caps.i), true, x )){\n        if(t<x.t) x.t=t;\n        ret=true;\n    }\n    return ret;\n}\n\n// Sphere intersection\n// ray : The ray\n//   x : Returned intersection information\nbool IntersectSphere(Ray ray,Sphere sph,out Hit x)\n{\n    vec3 oc=ray.o-sph.c;\n    float b=dot(oc,ray.d);\n    float c=dot(oc,oc)-sph.r*sph.r;\n    float d=b*b-c;\n    if(d>0.)\n    {\n        float t=-b-sqrt(d);\n        if(t>0.)\n        {\n            vec3 p=Point(ray,t);\n            x=Hit(t,normalize(p-sph.c),sph.i);\n            \n            return true;\n        }\n    }\n    return false;\n    \n}\n\nbool IntersectCylinder(Ray r, Cylinder cyl, out Hit x)\n{\n    vec3 o = r.o;\n    vec3 d = r.d;\n    float cRadius = cyl.r;\n    //vec3 oc = o-cyl.center;\n    \n    float a = d.x*d.x + d.y*d.y;\n    float b = 2.*(d.x*o.x +d.y*o.y);\n    float c = o.x*o.x + o.y*o.y - cRadius*cRadius;\n    float delta = b*b-4.*a*c;\n    \n    if (delta>0.)\n    {\n        vec3 center = cyl.center;\n        float t1=(-b-sqrt(delta))/(2.*a);\n        float t2=(-b+sqrt(delta))/(2.*a);\n        float t = t1>t2 ? t2 : t1;\n        if(t>0.)\n        {\n            \n            vec3 p1=Point(r,t);\n            \n            vec3 pPlan;\n            if(p1.z >= center.z && p1.z <= center.z+cyl.h)\n            {\n                x=Hit(t,normalize(vec3(p1.x,p1.y,0.)),cyl.i);\n            \n                return true;\n            }\n            else\n            {\n                float t3=(center.z+cyl.h-o.z)/d.z; //pour plan du haut\n                float t4=(center.z-o.z)/d.z; //pour plan du bas\n                if(t3<t4)\n                {\n                    pPlan=Point(r,t3);\n                    if(pPlan.x*pPlan.x+pPlan.y*pPlan.y<=cRadius*cRadius)\n                    {\n                        x=Hit(t3,vec3(0.,0.,1.),cyl.i);\n                        return true;\n                    }\n                }\n                else\n                {\n                    pPlan=Point(r,t4);\n                    if(pPlan.x*pPlan.x+pPlan.y*pPlan.y<=cRadius*cRadius)\n                    {\n                        x=Hit(t4,vec3(0.,0.,-1.),cyl.i);\n                        return true;\n                    }\n                }\n            }\n            \n        }\n    }\n    \n    return false;\n}\n\nbool IntersectEllipsoid(Ray ray, Ellipse ellipse, out Hit x) {\n   \n    vec3 rad = vec3(ellipse.r1, ellipse.r2, ellipse.r3);\n    vec3 oc = ray.o - ellipse.c;\n\n    vec3 rdn = ray.d / rad;\n\n    float a = dot(rdn, rdn);\n    float b = 2.0 * dot(oc/rad, rdn);\n    float c = dot(oc/rad, oc/rad) - 1.0; \n\n    float discriminant = b * b - 4.0 * a * c;\n\n    if (discriminant > 0.0) {\n        float t1 = (-b - sqrt(discriminant)) / (2.0 * a);\n        float t2 = (-b + sqrt(discriminant)) / (2.0 * a);\n\n        float t = (t1 < t2) ? t1 : t2;\n\n        if (t > 0.0) {\n            vec3 localIntersectionPoint = Point(ray,t);\n           \n            vec3 normal = normalize((localIntersectionPoint-ellipse.c));\n            x = Hit(t, normal, ellipse.i);\n\n            return true;\n        }\n    }\n\n    return false;\n}\n\nbool IntersectBox(Ray r, Box box, out Hit x)\n{\n    vec3 o = r.o;\n    vec3 d = r.d;\n    vec3 a = box.a;\n    vec3 b = box.b;\n    \n    if(a.z>b.z)\n    {\n        float temp=a.z;\n        a.z=b.z;\n        b.z=temp;\n    }\n    \n    if(a.y>b.y)\n    {\n        float temp=a.y;\n        a.y=b.y;\n        b.y=temp;\n    }\n    \n    if(a.x>b.x)\n    {\n        float temp=a.x;\n        a.x=b.x;\n        b.x=temp;\n    }\n    \n    vec3 normal=vec3(0.);\n    \n    \n    float txmin = (a.x - o.x)/d.x;\n    float tymin = (a.y - o.y)/d.y;\n    float txmax = (b.x - o.x)/d.x;\n    float tymax = (b.y - o.y)/d.y;\n    float tzmin = (a.z - o.z)/d.z;\n    float tzmax = (b.z - o.z)/d.z;\n    \n    float txymin = max(min(txmin,txmax),min(tymin,tymax));\n    float txymax = min(max(txmin,txmax),max(tymin,tymax));\n    \n    float tmin = max(txymin,min(tzmin,tzmax));\n    float tmax = min(txymax,max(tzmin,tzmax));\n    \n    if (tmax < 0.)\n    {\n        return false;\n    }\n    \n    if (tmin > tmax)\n    {\n        return false;\n    }\n    \n    if (tmin < 0.)\n    {\n        tmin = tmax;\n    }\n    \n    vec3 p = Point(r,tmin);\n    \n    //calcul de la normale\n    if (abs(p.x-a.x)<0.01)\n    { normal = vec3(-1.,0.,0.); }\n    else if (abs(p.x-b.x)<0.00001)\n    { normal = vec3(1.,0.,0.); }\n    else if (abs(p.y-a.y)<0.00001)\n    { normal = vec3(0.,-1.,0.); }\n    else if (abs(p.y-b.y)<0.00001)\n    { normal = vec3(0.,1.,0.); }\n    else if (abs(p.z-a.z)<0.00001)\n    { normal = vec3(0.,0.,-1.); }\n    else if (abs(p.z-b.z)<0.00001)\n    { normal = vec3(0.,0.,1.); }\n    \n    x = Hit(tmin, normal,box.i);\n    return true;\n}\n\n// Plane intersection\n// ray : The ray\n//   x : Returned intersection information\nbool IntersectPlane(Ray ray,Plane pl,out Hit x)\n{\n    float t=-dot(ray.o-pl.p,pl.n)/dot(ray.d,pl.n);\n    if(t>0.)\n    {\n        \n        x=Hit(t,vec3(0,0,1),0);\n        return true;\n    }\n    return false;\n}\n\n/*************Placement***********/\n\n//Translation\nRay TranslateRay (Ray ray, vec3 translation){\n    ray.o += translation;\n    return ray;\n}\n\n/******Rotation******/\nRay RotateRay(Ray ray, float angle, float time){\n    //Créer une matrice de rotation en 3D\n    mat3 rotationMatrix3D = mat3(\n        cos(angle), -sin(angle), 0,\n        sin(angle), cos(angle), 0,\n        0, 0, 1\n    );\n    \n    //Ajuster la rotation en fonction du temps\n    mat3 timerotationMatrix = mat3(\n        cos(time), -sin(time), 0,\n        sin(time), cos(time), 0,\n        0, 0, 1\n    );\n    \n   //Combiner la rotation en fonction du temps\n   mat3 finalRotationMatrix = rotationMatrix3D * timerotationMatrix;\n   \n   //Appliquer la rotation à la direction et à l'origine du rayon\n   ray.o = finalRotationMatrix * ray.o;\n   ray.d = normalize(finalRotationMatrix * ray.d);\n   \n   return ray;\n}\n/********************/\n\n//Homothétie\nRay ScaleRay(Ray ray, vec3 scale){\n    ray.d *= scale;\n    ray.d = normalize(ray.d);\n    ray.o *= scale;\n    return ray;\n}\n\n/*************Fin Placement**********/\n\n// Scene intersection\n// ray : The ray\n//   x : Returned intersection information\nbool Intersect(Ray ray,out Hit x)\n{\n    // Spheres\n    //const Sphere sph1=Sphere(vec3(0.,0.,0.),1.,1);\n    const Sphere sph2=Sphere(vec3(4.,0.,4.),1.,1);\n    \n    const Plane pl=Plane(vec3(0.,0.,1.),vec3(0.,0.,0.),0);\n    \n    const Box box = Box(vec3(4.,1.,1.),vec3(6.,3.,3.),2);\n    \n    const Cylinder cyl = Cylinder(vec3(4.,5.,3.), 1., 2., 5);\n    \n    const Ellipse ellipse = Ellipse(vec3(-4.,1.,1.), 3., 2., 1., 1);\n    \n    const Capsule capsule = Capsule(vec3(2.,-4.,2.),vec3(2.,-4.,4.),1.,1);\n    \n    Ray rayRotated = RotateRay(ray, radians(45.0), 0.);\n    \n    x=Hit(1000.,vec3(0),-1);\n    Hit current;\n    bool ret=false;\n    /*\n    if(IntersectSphere(ray,sph1,current)&&current.t<x.t){\n        x=current;\n        ret=true;\n    }\n    */\n    \n    if(IntersectSphere(ray,sph2,current)&&current.t<x.t){\n        x=current;\n        ret=true;\n    }\n    if(IntersectPlane(ray,pl,current)&&current.t<x.t){\n        x=current;\n        ret=true;\n    }\n    if(IntersectBox(ray,box,current)&&current.t<x.t){\n        x=current;\n        ret=true;\n    }\n    \n    if(IntersectCylinder(ray,cyl,current)&&current.t<x.t){\n        x=current;\n        ret=true;\n    }\n    if(IntersectCapsule(ray,capsule,current)&&current.t<x.t){\n        x=current;\n        ret=true;\n    }\n    \n    \n    if(IntersectEllipsoid(ray,ellipse,current)&&current.t<x.t){\n        x=current;\n        ret=true;\n    }\n    \n    \n    \n    return ret;\n}\n\nvec3 Background(vec3 rd)\n{\n    return mix(vec3(.8,.8,.9),vec3(.7,.7,.8),rd.z);\n}\n\n// Camera rotation matrix\n// ro : Camera origin\n// ta : Target point\nmat3 setCamera(in vec3 ro,in vec3 ta)\n{\n    vec3 cw=normalize(ta-ro);\n    vec3 cp=vec3(0,0,1);\n    vec3 cu=-normalize(cross(cw,cp));\n    vec3 cv=-normalize(cross(cu,cw));\n    return mat3(cu,cv,cw);\n}\n\n// Apply color model\n// m : Material\n// n : normal\nvec3 Color(Material m,vec3 n, vec3 p, Light l, vec3 eyeDir)\n{\n    vec3 lightDir = normalize(l.dir);\n    vec3 lightColor = l.diff;\n    vec3 lightAmbiant = l.ambiant;\n    \n    //vec3 light=normalize(lightDir);\n    \n    Hit qqc;\n    if (!Intersect(Ray(p+n*0.01,lightDir),qqc))\n    {\n        float diff=clamp(dot(n,lightDir),0.,1.);\n        vec3 r = reflect(eyeDir,n);\n        vec3 specular = m.spec*pow(clamp(dot(r,lightDir),0.0,1.0),100.0)*lightColor;\n        vec3 col=m.d*diff+lightAmbiant+specular;\n        return col;\n    }\n    else\n    {\n        return vec3(.2,.2,.2);\n    }\n    \n    \n}\n\n// Rendering\nvec3 Shade(Ray ray)\n{\n    Light light = Light(vec3(1,1,1),vec3(1.,1.,1.),vec3(0.2,0.2,0.2));\n\n    // Intersect contains all the geo detection\n    Hit x;\n    bool idx=Intersect(ray,x);\n    \n    //Light light = (vec3(1,1,1),vec3(1.0,1.0,1.0),vec3(.2,.2,.2)\n    \n    if(idx)\n    {\n        vec3 p=Point(ray,x.t);\n        Material mat=Texture(p,x.i);\n        \n        return Color(mat,x.n,p,light,ray.d);\n    }\n    else\n    {\n        return Background(ray.d);\n    }\n    \n    return vec3(0);\n}\n\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord)\n{\n    // From uv which are the pixel coordinates in [0,1], change to [-1,1] and apply aspect ratio\n    vec2 uv=(-iResolution.xy+2.*fragCoord.xy)/iResolution.y;\n    \n    // Mouse control\n    vec2 mouse=iMouse.xy/iResolution.xy;\n    \n    // Ray origin\n    vec3 ro=12.*normalize(vec3(sin(2.*3.14*mouse.x),cos(2.*3.14*mouse.x),1.4*(mouse.y-.1)));\n    vec3 ta=vec3(0.,0.,1.5);\n    mat3 ca=setCamera(ro,ta);\n    \n    // Ray\n    vec3 rd=ca*normalize(vec3(uv.xy*tan(radians(22.5)),1.));\n    \n    // Render\n    vec3 col=Shade(Ray(ro,rd));\n    \n    fragColor=vec4(col,1.);\n}","name":"Image","description":"","type":"image"}]}