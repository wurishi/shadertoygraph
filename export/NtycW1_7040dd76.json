{"ver":"0.1","info":{"id":"NtycW1","date":"1661349071","viewed":103,"name":"Pipe Method","username":"robberyman","description":"Attempting to study the Pipe Method for shallow water simulation from\n\nhttps://trepo.tuni.fi/handle/10024/115052\n\nSection 4.5","likes":3,"published":1,"flags":32,"usePreview":1,"tags":["water","swe","sim","kellomaki"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 texel = 1.0 / iResolution.xy;\n    \n    vec4 buffer = texture(iChannel0, uv);\n    \n    vec4 right = texture(iChannel0, vec2(uv.r + texel.r, uv.g));\n    vec4 left  = texture(iChannel0, vec2(uv.r - texel.r, uv.g));\n    \n    vec4 up    = texture(iChannel0, vec2(uv.r, uv.g + texel.g));\n    vec4 down  = texture(iChannel0, vec2(uv.r, uv.g - texel.g));\n    \n    vec3 color = vec3(0.0, 0.0, 0.0);\n    \n    // Debug checks, \n    if (any(isnan(buffer))) {\n        color = vec3(0.8, 0.0, 0.8);\n    } \n    else if (any(isinf(buffer))) {\n        color = vec3(1.0, 0.0, 0.0);\n    } \n    else {\n        color = buffer.rrr;\n    }\n    \n    vec4 h = vec4(right.r, left.r, up.r, down.r) - buffer.r;\n    vec3 n = (normalize(vec3(h.r-h.g, h.b-h.a, 1.0)) + 1.0) * 0.5;\n    \n    // Draw the \"faucet\",\n    n = mix(n, vec3(0.0, 0.0, 0.0), (buffer.a > 0.0) ? 1.0 : 0.0);\n\n    // Output to screen\n    fragColor = vec4(n.rgb, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4sfGRn","filepath":"/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","previewfilepath":"/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Simulations here are attempting to implement the Pipe Method, mentioned in https://trepo.tuni.fi/handle/10024/115052\n// section 4.5\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // ∆x, is the size each pixel is in meters, meters / max(resolution)\n    // this is the simulation grid size,\n    float x = 30.0 / max(iResolution.x, iResolution.y);\n    \n    // g is gravity m/s2\n    const float g = 9.81;\n    \n    // ∆t, is the time step for the simulation,\n    const float t = 0.016;\n    \n    // Note, according to Kellomäki, there is an issue with stability\n    // \n    //   ∆x\n    //  ---- >= |u|\n    //   ∆t\n    //\n    // Where |u| is the fluid speed,\n    //\n    // see equation 3.7, page 33\n    //\n    \n    // uv coords to sample current pixel,\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    // Sample Channel 1 to initialize everything, then each frame sample this buffer.\n    vec4 buffer = (iFrame > 0) ? texture(iChannel0, uv) : vec4(texture(iChannel1, uv).r, 0.0, 0.0, 1.0);\n    \n    // Get the previously stored depth, d\n    float d = buffer.r;\n    float v = d * x * x; // volume v in m3\n    \n    // This part is only to keep adding depth, see it like a faucet, as I want to\n    // see ripples in the water this can be seen as a character moving through\n    // a shallow pond.\n    float aspect_ratio = iResolution.x / iResolution.y;\n    // Scale the uv depending on aspect ratio so distans from a point won't seem\n    // skewed.\n    vec2 nuv = (aspect_ratio < 1.0) ? uv*vec2(1.0, aspect_ratio):uv*vec2(aspect_ratio, 1.0);\n    // Get the center of the screen with same tweaked uv method\n    vec2 center = (aspect_ratio < 1.0) ? vec2(0.5, 0.5 * aspect_ratio) : vec2(0.5 * aspect_ratio, 0.5);\n    // Get the radius in uv for our \"character\"\n    float radius = 0.0025 * 0.5;\n    // Move in a spiraling patterns to and from center\n    vec2 position = vec2(cos(iTime*0.5), sin(iTime*0.5))*sin(iTime*0.314) + center;\n    float faucet = sqrt(max(radius - pow(distance(position, nuv),2.0),0.0));\n    \n    // Add the depth from our faucet\n    d += (clamp(faucet, 0.0, 1.0) > 0.0) ? 1.0 : 0.0;\n    \n    // get the uv offset to sample the neigbouring pixels in the buffer \n    vec2 texel = 1.0 / iResolution.xy;\n    \n    vec4 right = (iFrame > 0) ? texture(iChannel0, vec2(uv.r + texel.r, uv.g)) : vec4(texture(iChannel1, vec2(uv.r + texel.r, uv.g)).r, 0.0, 0.0, 1.0);\n    vec4 left  = (iFrame > 0) ? texture(iChannel0, vec2(uv.r - texel.r, uv.g)) : vec4(texture(iChannel1, vec2(uv.r - texel.r, uv.g)).r, 0.0, 0.0, 1.0);\n    \n    vec4 up    = (iFrame > 0) ? texture(iChannel0, vec2(uv.r, uv.g + texel.g)) : vec4(texture(iChannel1, vec2(uv.r, uv.g + texel.g)).r, 0.0, 0.0, 1.0);\n    vec4 down  = (iFrame > 0) ? texture(iChannel0, vec2(uv.r, uv.g - texel.g)) : vec4(texture(iChannel1, vec2(uv.r, uv.g - texel.g)).r, 0.0, 0.0, 1.0);\n    \n    // ∆h is the surface height difference between the two columns connected by the pipe.\n    // \n    // h(x + 0.5, y) = h(x + 1, y) - h(x,y)\n    // \n    // h(x,y) should be current cell depth, aka height. So all neigbour heights subtracted by current.\n    vec4 h = vec4(right.r, left.r, up.r, down.r) - d;\n    \n    // [O'Brien & Hodgins 1995]\n    // \" ... the flow at one end of a pipe must be equal in magnitude with opposite sign\n    // to flow at the other end. \"\n    //\n    // flow current->right == -right->current\n    // \n    // The current column will have information about the flow right, and up. Sampling neigbours\n    // to get the flow from left and below, but we will have to flip the sign on these values.\n    vec4 Q = vec4(buffer.g, -left.g, buffer.b, -down.b);\n    \n    // A = dx, where d is the \"upwind depth\", equation 4.5\n    vec4 A = max(vec4(right.r, left.r, up.r, down.r), vec4(d,d,d,d))*x;\n    // Another guess at upwind depth,\n    vec4 a = vec4(Q.r > 0.0 ? right.r : d, Q.g > 0.0 ? left.r : d, Q.b > 0.0 ? up.r : d, Q.a > 0.0 ? down.r : d) * x;\n    \n    // Update flow Q, as the equation 4.11 suggests on page 50.\n    Q += 0.001 * (g/x) * h * t;\n    \n    // Get the total sum of all flows, ie the total outflow from current pixel\n    float q = dot(vec4(1.0, 1.0, 1.0, 1.0), Q);\n    \n    // Between equation 4.11 updating flow, and 4.12 updating depth, the paper\n    // mentions the need for a limiting step where if the total outflow exceeds\n    // current depth, we must scale the outflow so that their total is same as\n    // depth. So when we update depth it would become exactly zero.\n    //\n    // [Mei, Decaudin, Hu 2007] sets a limiting step K for their solver. Equation (4)\n    // \n    // K = min( 1.0, depth * lx * ly / (f.l + f.r + f.t + f.b) * t )\n    //\n    // Where f is the flow in each direction, lx & ly are the simulation grid sizes in x & y\n    //\n    // So if the total volume change is bigger than the total volume, scale flow Q\n    // if (q > v) {\n    //     Q *= min(1.0, v/q*t); \n    // }\n    \n    // q = dot(vec4(1.0, 1.0, 1.0, 1.0), Q);\n\n    // Update the depth d, for current cell, equation 4.12 page 50\n    d += t * (q / (x*x));\n    \n    d = max(0.0, d);\n\n    vec3 color = vec3(d, Q.rb);\n    fragColor = vec4(color, clamp(faucet, 0.0, 1.0));\n}","name":"Buffer A","description":"","type":"buffer"}]}