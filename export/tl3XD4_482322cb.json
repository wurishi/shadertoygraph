{"ver":"0.1","info":{"id":"tl3XD4","date":"1580930328","viewed":168,"name":"Moekkistorm2020","username":"el_visio","description":"Anti-aliased 2d SDF proto","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["sdf","amiga"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI  3.1415926538\n#define TAU 6.2831853076\n#define AA_THRESHOLD 0.1\n\nfloat sdf_circle(vec2 pos, vec2 circle_pos, float circle_r) {\n\treturn length(pos - circle_pos) - circle_r;\n}\n\nfloat sdf_donut(vec2 pos, vec2 donut_pos, float donut_r, float donut_width) {\n\treturn max(sdf_circle(pos, donut_pos, donut_r + donut_width),\n              -sdf_circle(pos, donut_pos, donut_r - donut_width));    \n}\n\nfloat sdf_plane(vec2 pos, vec2 plane_pos, float angle) {\n    pos -= plane_pos;\n    return (sin(angle) * pos.y - cos(angle) * pos.x);\n}\n\nfloat sdf_arc(vec2 pos, vec2 arc_pos, float r, float width, float angle_a, float angle_b)\n{\n    float donut1 = sdf_donut(pos, arc_pos, r, 0.14);\n    float donut2 = sdf_donut(pos, arc_pos, r * 1.5, 0.15);\n    float donut3 = sdf_donut(pos, arc_pos, r * 2.0, 0.16);\n    float donut = min(min(donut1, donut2),donut3);\n\tfloat corner;\n    \n    if (mod(angle_b - angle_a, TAU) < PI) {\n        corner = min(sdf_plane(pos, arc_pos, angle_a),\n                    -sdf_plane(pos, arc_pos, angle_b));\n    } else {\n        corner = max(sdf_plane(pos, arc_pos, angle_a),\n                    -sdf_plane(pos, arc_pos, angle_b));\n    }\n    \n    corner += AA_THRESHOLD * (mod(angle_b - angle_a, TAU) / TAU);\n    \n    return max(donut, -corner);\n}\n\nfloat map_color(float in_value, float threshold) {\n\treturn clamp (in_value / threshold, 0.0, 1.0);\n}\n\nfloat get_depth(vec2 pos)\n{\n    pos *= 0.5;\n   \tvec2 delta = vec2(sin(iTime * 0.4), cos(-iTime*0.4) * 0.4) - pos;\n   \tvec2 delta2 = vec2(sin(-iTime * 1.5)*0.5, cos(-iTime*0.3)) - pos;\n    return 1.0-length(delta);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.yy;\n    vec2 orig_uv = uv;\n    \n    uv = mod(uv * 10.0, 2.0) - vec2(1.0,1.0);\n\n    vec2 pos1 = vec2(0.0,0.0);\n\n    \n    float _time = mod(iTime, TAU * 2.0);\n\n    float weight = get_depth(orig_uv);\n\n    vec3 xy_0 = vec3(orig_uv, get_depth(orig_uv));\n    vec3 xy_1 = vec3(orig_uv + vec2(0.1,0.0), get_depth(orig_uv + vec2(0.1,0.0)));\n    vec3 xy_2 = vec3(orig_uv + vec2(0.0,0.1), get_depth(orig_uv + vec2(0.0,0.1)));\n    \n    vec3 normal = cross(xy_1 - xy_0, xy_2 - xy_0);\n    \n    float angle = atan(-normal.x, -normal.y);\n    float weight_normal = weight * 0.5 + 0.5;\n    pos1 += vec2(normal.x, normal.y)*5.0;\n    float distance = sdf_arc(uv, pos1, 0.15 + 0.35 * weight, 0.6 - weight * 0.3, angle - PI * weight_normal, angle + PI * weight_normal);    \n    \n\tfloat shade = map_color(-distance, AA_THRESHOLD);\n\n    fragColor = vec4(shade, shade, 0.0,1.0);\n}\n\n","name":"Image","description":"","type":"image"}]}