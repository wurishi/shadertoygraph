{"ver":"0.1","info":{"id":"M3lSDr","date":"1710005696","viewed":62,"name":"Gothic Hilbert Curve","username":"KaleyGoode","description":"Playing with labyrinths","likes":11,"published":1,"flags":0,"usePreview":0,"tags":["space","curve","hilbert","steam","filling","steampunk","moore","punk","gothic"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/* Hilbert\nEach pair of bits in the index refers to a level position in the fractal:\n1-2\n| |\n0 3\nFor a Hilbert Curve:\nIndices 1 and 2 in non-base level don't need reflection.\nIndex 0 is reflected about x=y\nIndex 1 is reflected about x=(side-1)-y\nA Moore Curve is four Hilbert Curves arranged to put the ends together:\nThe left ones are rotated anticlockwise a quarter turn.\nThe right two are rotated clockwise a quarter turn.\n1[]2\n0[]3\n*/\n\n#define dt (float(1<<abs((int(iTime/6.)%4)-2))) // Alter the time between depths\n#define Depth    (1+ abs((int(iTime*dt)%6)-3)) // To see an individual depth for debug: #define Depth 2;// 1+abs...etc.\n#define gold (vec3(.9,.7,.3))\n\nivec2 HilbertFlip(bool negative, ivec2 point, int side) { // side  = 1<<depth\n  if(negative) point = side-1 - point; // Flip about y = -x\n  return point.yx; // Flip about y = x\n}\n\nivec2 HilbertPoint(int index, int depth) { // Returns a Hilbert point, not a pixel position\n  ivec2 point = ivec2(0);\n  for(int side=1; side<(1<<depth); side<<=1) { //   1-2  n_n\n    int right = 1 & (index >> 1);        // 2 or 3  | |  | |\n    int top   = 1 & (index ^ right);     // 1 or 2  0 3  ] [\n    if(0==top) point = HilbertFlip(0!=right, point, side);\n    point += side * ivec2(right,top); // Move if required\n    index >>= 2;\n  }\n  return point;\n}\n\nint HilbertIndex(ivec2 h, int depth) { // Pass x and y separately so they can be changed without altering the calling point\n  ivec2 point = h.yx;\n  int   index = 0;\n  for(int side=1<<depth; side>0; side>>=1) {\n    bool rx = (point.x & side) > 0;\n    bool ry = (point.y & side) > 0;\n    index += side*side * ((3 * int(rx)) ^ int(ry));\n    if(!ry) point = HilbertFlip(rx, point, side);\n  }\n  return index;\n}\n\n// Added for completion in case anyone wants to fork around and make a closed curve:\nivec2 MoorePoint(int index, int depth) {\n  ivec2 point = HilbertPoint(index, --depth); // Form a quadrant of Hilbert curve\n  index   >>= depth<<1;            // Locate it:    ___\n  int side  = 1<<depth;            //         1-2  [   ]\n  int right = 1 & (index >> 1);    // 2 or 3  | |   | |\n  int top   = 1 & (index ^ right); // 1 or 2  0 3  [_ _]\n  point     = HilbertFlip(0==right, point, side);\n  point.y   = side-1 - point.y; // Flip the Y-axis\n  point    += side * ivec2(right,top); // Move if required\n  return point;\n}\n\nint popcount(int x) { // Count the set bits\n  int count=0;\n  while(0!=x) {++count; x>>=1;}\n  return count;\n}\n\n// Find s [0,1] (ramp up either side of line from previous/next)\n//  and t [0,1] (ramp up towards previous and next)\n// 'other' is false when there is no previous and one is needed, and true when there is no next and one is needed\nvec2 st(bool other, int depth, int index, float scale, float radius, vec2 c, vec2 fragCoord) {\n  ivec2 h = HilbertPoint((other ? (index-1) : (index+1)), depth); // End-points cheat to avoid undefined orientation\n  vec2  n = radius + scale*vec2(h),\n        d = n-c; // Vector from the centre of this point to that of the other\n  float t = dot(fragCoord-c,d)/(scale*scale); // mix parameter of \n  vec2  p = c+t*d;\n  float s = distance(fragCoord,p)/radius;\n  return vec2(s,t); // [s and t are members of vec2 in first and second position]\n}\n \nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  int  square = int(min(iResolution.x,iResolution.y)),\n     maxDepth = popcount(square)-1,\n        width = 1 << maxDepth, // in pixels\n        depth = Depth,\n         side = 1 << depth, // in Hilbert coordinates/points (not pixels)\n      indices = side * side;\n  float scale = float(square)/float(side), // The side-length of each tile\n       radius = scale/2.;\n  vec2  c = radius + scale*floor(fragCoord/scale),\n        d = fragCoord-c; // dx,dy\n  float t = 1., // Parameter for the pixel's shade [0,1]\n       pt = 1., // Previous index's t\n       nt = 1., // Next index's t\n      prt = radius, // Previous index's distance from line\n      nrt = radius; // Next index's distance from line\n  ivec2 h = ivec2(fragCoord/scale);\n  int index = HilbertIndex(h, depth); // Find the index of the closest point\n  if((0<=index)&&(index < indices)) {\n    vec2  p = st(        0  !=index,depth,index,scale,radius,c,fragCoord), // From Previous (false will use index 1   for direction)\n          n = st((indices-1)==index,depth,index,scale,radius,c,fragCoord); // To Next       (true  will use indices-2 for direction)\n          t = ((p.t>n.t) ? p.t : n.t); // [0,1] of projected point from (x0,y0);\n    float s = ((p.t>n.t) ? p.s : n.s), // Distance of x,y from line (rendering this gives a single pixel wide line)\n          w = 1.-2.*t*(1.-t); // Width of goo at t [0,1]\n          t = (0.==w ? 0. : w*abs(1.-s/w)); // Vertical and Horizontal mix for Gothic Labrynth pathway\n          t = (0.==t ? 0. : 1.-s/t);        // Reduce the outer areas of steps to minimise the diagonals interfering\n        fragColor = vec4(t*gold,1.);\n  }else fragColor = vec4(.82,.82,.82,1.);\n}\n","name":"Image","description":"","type":"image"}]}