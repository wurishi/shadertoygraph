{"ver":"0.1","info":{"id":"4lBSzR","date":"1441167220","viewed":611,"name":"Realistic Sky","username":"jackdavenport","description":"A shader which emulates the transitions between day and night. Change the length of each day by changing line 2.","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["sky","night","blend","day","realistic"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xsf3Rn","filepath":"/media/a/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png","previewfilepath":"/media/ap/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png","type":"texture","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[],"code":"// The length of a day, in seconds\n#define dayLength 12.\n\n// START NOISE\n// SOURCE: http://pixelshaders.com/examples/noise.html\nfloat random(float p) {\n  return fract(sin(p)*10000.);\n}\n\nfloat noise(vec2 p) {\n  return random(p.x + p.y*10000.);\n}\n// END NOISE\n\nvec3 rgb(float r, float g, float b) {\n \n    return vec3(r / 255., g / 255., b / 255.);\n    \n}\n\nfloat sqr(float x) {\n \n    return x * x;\n    \n}\n\nfloat dist(vec2 a, vec2 b) {\n \n    float x = sqr(a.x - b.x);\n    float y = sqr(a.y - b.y);\n    return sqrt(x + y);\n    \n}\n\nvec3 duskColor(vec2 uv, float y) {\n \n\tvec3 skyBase = rgb(255., 153., 51.);\n    vec3 skyTop = rgb(153., 204., 255.);\n    \n    return mix(skyBase, skyTop, pow(y, .5));\n    \n}\n\nvec3 dawnColor(vec2 uv, float y) {\n \n    vec3 skyBase = rgb(255., 102., 0.);\n    vec3 skyTop = rgb(255., 204., 153.);\n    \n    return mix(skyBase, skyTop, pow(y, .5));\n    \n}\n\nvec3 dayColor(vec2 uv, float y) {\n \n    vec3 skyBase = rgb(153., 204., 255.);\n    vec3 skyTop = rgb(0., 102., 255.);\n    \n    return mix(skyBase, skyTop, pow(y, .5));\n    \n}\n\nvec3 nightColor(vec2 uv, float y) {\n \n    float offset = iTime / 100000.;\n    float n = noise(uv - vec2(0.,offset));\n    \n    return n > .999 ? vec3(random(n)) : vec3(0.);\n    \n}\n\nvec3 sun(vec2 uv, float time) {\n    \n    float y = uv.y;\n    float sunY = 2.;\n    sunY -= 5. * (time / 4.);\n    \n    vec2 sunPos = vec2(.2, sunY);\n    float flareSize = .2;\n    float sunFlare = max(1. - (length(sunPos - uv) / flareSize), 0.);\n    \n    float distToSun = dist(sunPos, uv);\n    float anaSize = uv.x > .3 || uv.x < .3 ? 3. : 3. * (1. - distToSun * 4.);\n    float anaFlare = distToSun > .2 ? 1. - (distToSun + .15) : 1.;\n    float anaLens = sunY > y - (flareSize / anaSize) && sunY < y + (flareSize / anaSize) ? anaFlare : 0.;\n    \n    vec3 s = vec3(1., .7, 0.) * sunFlare;\n    s += vec3(.0, .0, .4) * anaLens;\n    \n    return s;\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    float y = uv.y;\n    \n    float time = 4. * mod(iTime, dayLength) / dayLength;\n    float det = fract(time);\n    \n    vec3 dusk = duskColor(uv, y);\n    vec3 dawn = dawnColor(uv, y);\n    vec3 day = dayColor(uv, y);\n    vec3 night = nightColor(uv, y);\n    \n    if(iMouse.z > 0.) {\n        \n        time = 4. * iMouse.x / iResolution.x;\n        \n    }\n    \n    vec3 final = time < 1. ? mix(day, dusk, det)\n        \t   : time < 2. ? mix(dusk, night, det)\n               : time < 3. ? mix(night, dawn, det)\n               : \t\t\t mix(dawn, day, det);\n   \n   \tfinal += sun(uv, time); \n    fragColor = vec4(final, 1.);\n    \n}","name":"","description":"","type":"image"}]}