{"ver":"0.1","info":{"id":"XXBfDK","date":"1729936074","viewed":23,"name":"Example: SDF Combinations ","username":"ElliotPadfield","description":"This shader demonstrates combining shapes with distance functions (SDFs)â€”Uncomment lines for other combinations: Union, Subtraction, Intersection, and XOR. I am using the Common Tab Distance Line Rendering function for visualisation.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["example"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Reference: https://iquilezles.org/articles/distfunctions/\n\n// SDF for a circle\nfloat sdCircle(vec2 p, float radius) {\n    return length(p) - radius; // Distance to circle edge\n}\n\n// SDF for a box\nfloat sdBox(in vec2 p, in vec2 b) {\n    vec2 d = abs(p) - b;\n    return length(max(d, 0.0)) + min(max(d.x, d.y), 0.0); // Distance to box edge\n}\n\n// Combination operations\nfloat opUnion(float d1, float d2) {\n    return min(d1, d2);\n}\nfloat opSubtraction(float d1, float d2) {\n    return max(-d1, d2);\n}\nfloat opIntersection(float d1, float d2) {\n    return max(d1, d2);\n}\nfloat opXor(float d1, float d2) {\n    return max(min(d1, d2), -max(d1, d2));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n    // Step 1: Normalize UV coordinates with aspect ratio correction\n    // https://www.shadertoy.com/view/lf2fWw\n    vec2 R = iResolution.xy;\n    vec2 uv = (2.0 * fragCoord - R) / min(R.x, R.y); // Normalize to [-1, 1] along the shortest side\n\n    // Step 2: Define a scale value\n    float scale = 3.0; // Scale factor\n    \n    // Step 3: Define smoothing factor\n    float smoothFactor = 0.1; // Smoothing factor for combination operations\n\n    // Step 4: Define parameters for circle and box, scaled by the scale value\n    float radius = 0.2 * scale;               // Circle radius (scaled to 0.6)\n    vec2 boxSize = vec2(0.15 * scale, 0.15 * scale);  // Box dimensions (scaled to (0.45, 0.45))\n\n    // Step 5: Animate the offsets using time\n    vec2 offset1 = vec2(-0.1 * scale + 0.1 * sin(iTime), 0.0);   // Offset for first shape (circle)\n    vec2 offset2 = vec2(0.1 * scale + 0.1 * cos(iTime), 0.0);    // Offset for second shape (box)\n\n    // Step 4: Calculate SDFs for circle and box with offset\n    float distCircle = sdCircle(uv + offset2, radius);\n    float distBox = sdBox(uv + offset1, boxSize);\n\n    // Uncomment one of the following combinations to view the effect:\n    // You can swap the order (e.g., Box Union Circle instead of Circle Union Box) to see different results.\n\n    // Combination 1: Circle Union Box\n    float combinedDist = opUnion(distCircle, distBox); // Default: Circle Union Box\n\n    // Combination 2: Circle Subtraction Box\n    // combinedDist = opSubtraction(distCircle, distBox);\n\n    // Combination 3: Circle Intersection Box\n    // combinedDist = opIntersection(distCircle, distBox);\n\n    // Combination 4: Circle XOR Box\n    // combinedDist = opXor(distCircle, distBox);\n        \n    // Step 5: Render distance lines using the UV coordinates and calculated distance\n    fragColor = RenderDistanceLines(fragCoord, uv, combinedDist, iResolution.xy);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// Reference: https://www.ronja-tutorials.com/post/034-2d-sdf-basics/\n\n// Distance line properties as uniforms or parameters\nfloat _SubLines = 1.0;                // Number of sub-lines between major lines\nfloat _SubLineThickness = 0.001;       // Thickness of the sub-lines\nfloat _LineDistance = 0.1;            // Distance between major lines\nfloat _LineThickness = 0.005;          // Thickness of the major lines\nvec3 _InsideColor = vec3(0.0, 0.8, 0.3); // Rich Green\nvec3 _OutsideColor = vec3(1.0, 0.2, 0.6); // Soft Magenta\n\n// Function to render distance lines based on the given distance\nvec4 RenderDistanceLines(in vec2 fragCoord, vec2 uv, float dist, vec2 iResolution) {\n    // Step 1: Prepare resolution for anti-aliasing calculations\n    vec2 R = iResolution.xy;\n\n    // Step 2: Determine base color based on the distance to the shape\n    vec3 col = mix(_InsideColor, _OutsideColor, step(0.0, dist));\n\n    // Step 3: Calculate the distance change for anti-aliasing\n    float distanceChange = fwidth(dist) * 0.5;\n\n    // Step 4: Calculate the effect of major lines\n    float majorLineDistance = abs(fract(dist / _LineDistance + 0.5) - 0.5) * _LineDistance;\n    float majorLines = smoothstep(_LineThickness - distanceChange, _LineThickness + distanceChange, majorLineDistance);\n\n    // Step 5: Calculate the effect of sub-lines between major lines\n    float distanceBetweenSubLines = _LineDistance / _SubLines;\n    float subLineDistance = abs(fract(dist / distanceBetweenSubLines + 0.5) - 0.5) * distanceBetweenSubLines;\n    float subLines = smoothstep(_SubLineThickness - distanceChange, _SubLineThickness + distanceChange, subLineDistance);\n       \n    // Step 6: Anti-aliasing for smooth edges\n    // https://www.shadertoy.com/view/MfjBDw\n    float pix = 1.5 / min(R.x, R.y); // Pixel width (Adjusted to use min(R.x, R.y) for consistent pixel scaling)\n    float aa = smoothstep(-pix / 2., pix / 2., dist); // Adjusted smoothstep for smoother anti-aliasing transition\n\n    // Step 7: Final color with applied major and sub-line effects\n    return vec4(col * majorLines * subLines, 1.0);\n}\n","name":"Common","description":"","type":"common"}]}