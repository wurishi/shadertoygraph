{"ver":"0.1","info":{"id":"DdSGzh","date":"1667249030","viewed":95,"name":"Power series & plot","username":"ChunderFPV","description":"One of my first shaders was a Power Function Graph: https://www.shadertoy.com/view/fdlBRX\n8.5 months later and it's time for a new version.  Use the mouse to change the exponent.  S key toggles snapping.","likes":3,"published":1,"flags":16,"usePreview":0,"tags":["math","graph","plot","power","exponent"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define SCALE 2.5\n\n// --- from https://www.shadertoy.com/view/7tV3zK\nvec4 char(vec2 p, int c) {\n    vec2 dFdx = dFdx(p/16.), dFdy = dFdy(p/16.);\n    if (p.x<.0|| p.x>1. || p.y<0.|| p.y>1.) return vec4(0,0,0,1e5);\n\treturn textureGrad( iChannel1, p/16. + fract( vec2(c, 15-c/16) / 16. ), \n                        dFdx, dFdy );\n}\nvec4 pInt(vec2 p, float n, float d) { // --- display int4\n    vec4 v = vec4(0);\n    if (n < 0.) \n        v += char(p - vec2(-.5,0), 45 ),\n        n = -n;\n    for (float i = d; i>0.; i--) \n        n /=  9.999999, // 10., // for windows :-(\n        v += char(p - .5*vec2(i-1.0,0), 48+ int(fract(n)*10.) );\n    return v;\n}// ---\n\n// screen coords, value, size, num left digits, num right digits\nvec3 counter(vec2 sc, float v, float s, float l, float r)\n{\n    float numleft = min(log2(abs(v))/log2(10.0), l-1.0);\n    l = max(floor(numleft), 0.0)+1.0;\n    sc /= s; // size\n    sc += vec2((l+1.0)/2.0, 0.28); // center on decimal\n    vec3 d = vec3(0);\n    d += pInt(sc, v, l).x; // left of decimal\n    sc.x -= l/2.0;\n    d += char(sc, 46).x; // decimal point\n    sc.x -= 0.5;\n    d += pInt(sc, floor(abs(v)*pow(10.0, r)), r).x; // right of decimal\n    return d;\n}\n\nvoid mainImage(out vec4 RGBA, in vec2 XY)\n{\n    vec2 sc = SC; // screen coords\n    vec2 mc = MC; // mouse coords\n    float px = PX; // pixel radius\n    vec3 c = vec3(0); // background\n    \n    // xy grid\n    vec2 xyg = abs(fract(sc+0.5)-0.5)/fwidth(sc);\n    c += (1.0-min(min(xyg.x, xyg.y), 1.0))*0.25; // lines\n    c += 1.0-min(max(xyg.x, xyg.y), 1.0); // points\n    \n    // power series\n    float es = XYE(sc); // exponent from screen\n    c += gm(es, 0.0, 2.0, 0.75, true); // gradient map\n    if (sign(es) > 0.0) c = 1.0-c; // polarity\n    c.r *= c.r; // color\n    \n    // coords for plot\n    vec2 mtxy = (M.z > 0.0) ? mc: vec2(CS(iTime/5.0*PI)+1.0); // xy from mouse or time\n    float mte = XYE(mtxy); // exponent from mouse or time\n    float key_s = texture(iChannel0, vec2( (float(83)+0.5)/256.0, 1.0) ).x; // key s toggle\n    if (key_s > 0.0) // toggle\n        mte = (abs(mte) < 1.0) ? 1.0/round(1.0/mte): round(mte); // round to nearest int or 1/int\n    \n    // user plot\n    float eq = pow(abs(sc.x), mte); // equation for plot\n    c = mix(c, vec3(1,0,key_s), PLOT(eq-sc.y, 10.0)); // glow\n    c = mix(c, vec3(1), PLOT(eq-sc.y, 2.0)); // curve\n    \n    // user point\n    c = mix(c, vec3(1,0,0), PT(sc-mtxy, px*30.0)); // glow\n    c = mix(c, vec3(1), PT(sc-mtxy, px*7.0)); // point\n    \n    vec3 d = counter(sc-mtxy, mte, px*48.0, 4.0, 4.0); // digits\n    if (isinf(mte)) d = vec3(char((sc-mtxy)/(px*72.0)+vec2(0.5, 0.25), 153).x); // infinity symbol\n    c = mix(c, vec3(0,0.3,1), d);\n    \n    RGBA = vec4(c, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define R iResolution.xy\n#define T iTime\n#define M iMouse\n#define PI 3.14159265358979\n#define CS(a) vec2(cos(a), sin(a))\n#define SC (XY*SCALE/R.y)\n#define MC (M.xy*SCALE/R.y)\n#define PX length(fwidth(SC/1.414))\n#define PT(xy,r) max(0.0, 1.0-length(vec2(xy)/(r)))\n#define PLOT(eq,w) smoothstep(w*min(fwidth(eq), 1.0), 0.0, abs(eq))\n#define XYE(xy) log(abs(xy.y))/log(abs(xy.x))\n\n// gradient map ( equation, time, hardness, shadow, reciprocals )\nfloat gm(float eq, float t, float h, float s, bool i)\n{\n    float sg = min(abs(eq), 1.0/abs(eq)); // smooth gradient\n    float og = abs(sin(eq*PI-t)); // oscillating gradient\n    if (i) og = min(og, abs(sin(PI/eq+t))); // reciprocals\n    return pow(1.0-og, h)*pow(sg, s);\n}\n","name":"Common","description":"","type":"common"}]}