{"ver":"0.1","info":{"id":"slX3D2","date":"1622859869","viewed":445,"name":"Warped noise 3D __","username":"Envy24","description":"Source: https://iquilezles.org/articles/warp/warp.htm\nLT: value noise 3D;               MT: Perlin noise 3D;               RT: Worley noise 3D;\nLB: warped value noise 3D;   MB: Warped Perlin noise 3D;   RT: Warped Worley noise 3D;","likes":21,"published":1,"flags":0,"usePreview":1,"tags":["fractal","noise","brownian","motion","value"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/* playlist: https://www.shadertoy.com/playlist/sXfSDS */\n\n/* \n    For noise functions see COMMON\n    \n    FBM - fractal brownian motion.\n*/\n\n\nvec3 fbmV(vec3 c)\n{\n    float gray = valueNoise3D(c.x, c.y, c.z) * 0.35f;\n    gray += valueNoise3D(c.x * 2.054f, c.y * 2.354f, c.z * 2.754f) * 0.125f;\n    gray += valueNoise3D(c.x * 4.554f, c.y * 4.254f, c.z * 4.154f) * 0.025f;\n    gray += valueNoise3D(c.x * 32.554f, c.y * 32.354f, c.z * 32.430f) * 0.025f;\n    \n    return vec3(c.x + gray, c.y + gray, c.z);\n}\n\nfloat fbmV2(vec3 c)\n{\n    float gray = valueNoise3D(c.x, c.y, c.z) * 0.35f;\n    gray += valueNoise3D(c.x * 2.054f, c.y * 2.354f, c.z * 2.754f) * 0.125f;\n    gray += valueNoise3D(c.x * 4.554f, c.y * 4.254f, c.z * 4.154f) * 0.025f;\n    gray += valueNoise3D(c.x * 32.554f, c.y * 32.354f, c.z * 32.430f) * 0.025f;\n    \n    return gray;\n}\n\nvec3 fbmP(vec3 c)\n{\n    float gray = PerlinNoise3D(c.x, c.y, c.z) * 0.35f;\n    gray += PerlinNoise3D(c.x * 2.054f, c.y * 2.354f, c.z * 2.754f) * 0.125f;\n    gray += PerlinNoise3D(c.x * 4.554f, c.y * 4.254f, c.z * 4.154f) * 0.025f;\n    gray += PerlinNoise3D(c.x * 32.554f, c.y * 32.354f, c.z * 32.430f) * 0.025f;\n    \n    return vec3(c.x + gray, c.y + gray, c.z);\n}\n\nfloat fbmP2(vec3 c)\n{\n    float gray = PerlinNoise3D(c.x, c.y, c.z) * 0.35f;\n    gray += PerlinNoise3D(c.x * 2.054f, c.y * 2.354f, c.z * 2.754f) * 0.125f;\n    gray += PerlinNoise3D(c.x * 4.554f, c.y * 4.254f, c.z * 4.154f) * 0.025f;\n    gray += PerlinNoise3D(c.x * 32.554f, c.y * 32.354f, c.z * 32.430f) * 0.025f;\n    \n    return gray;\n}\n\nvec3 fbmW(vec3 c)\n{\n    float gray = WorleyNoise3D(c.x, c.y, c.z) * 0.35f;\n    gray += WorleyNoise3D(c.x * 2.054f, c.y * 2.354f, c.z * 2.754f) * 0.125f;\n    gray += WorleyNoise3D(c.x * 4.554f, c.y * 4.254f, c.z * 4.154f) * 0.025f;\n    gray += WorleyNoise3D(c.x * 32.554f, c.y * 32.354f, c.z * 32.430f) * 0.025f;\n    \n    return vec3(c.x + gray, c.y + gray, c.z);\n}\n\nfloat fbmW2(vec3 c)\n{\n    float gray = WorleyNoise3D(c.x, c.y, c.z) * 0.35f;\n    gray += WorleyNoise3D(c.x * 2.054f, c.y * 2.354f, c.z * 2.754f) * 0.125f;\n    gray += WorleyNoise3D(c.x * 4.554f, c.y * 4.254f, c.z * 4.154f) * 0.025f;\n    gray += WorleyNoise3D(c.x * 32.554f, c.y * 32.354f, c.z * 32.430f) * 0.025f;\n    \n    return gray;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    float _u = uv.x;\n    float _v = uv.y;\n    \n    uv *= 12.0;\n    \n    vec3 coords = \n        vec3(\n            uv.x,\n            uv.y,\n            uv.x + iMouse.y * 0.1f + iTime * 0.4f);\n\n    float gray = 0.0f;\n\n    if (_u < 0.33 && _v >= 0.5) { gray = fbmV2(coords);  } // LT\n    else if (_u < 0.33 && _v < 0.5) { gray = fbmV2(fbmV(fbmV(coords * 0.5) + fbmV(coords * 0.2))); } // LB\n\n    else if (_u >= 0.33 && _u < 0.66 && _v >= 0.5) { gray = fbmP2(coords); gray += 0.1f; } // MT\n    else if (_u >= 0.33 && _u < 0.66 && _v < 0.5){ gray = fbmP2(fbmP(fbmP(coords * 0.5) + fbmP(coords * 0.2))); gray += 0.1f; } // MB\n    \n    else if (_u >= 0.66 && _v >= 0.5 ) { gray = fbmW2(coords); } // RT\n    else { gray = fbmW2(fbmW(fbmW(coords * 0.5) + fbmW(coords * 0.2))); } // RB\n\n    // Output to screen\n    fragColor = vec4(vec3(gray),1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"/*\n    Returns hash in range [0.0; 1.0].\n*/\nfloat sample3DHashUI32(uint x, uint y, uint z)\n{\n    // Pick some enthropy source values.\n    // Try different values.\n    const uint enthropy0 = 1200u;\n    const uint enthropy1 = 4500u;\n    const uint enthropy2 = 6700u;\n    const uint enthropy3 = 8900u;\n\n    // Use linear offset method to mix coordinates.\n    uint value = \n        z * enthropy3 * enthropy2 +\n        y * enthropy2 +\n        x;\n\n    // Calculate hash.\n\tvalue += enthropy1;\n\tvalue *= 445593459u;\n\tvalue ^= enthropy0;\n\n    // 1.0f / 4294967295.0f = 2.32830644e-10\n\n    return float(value * value * value) * 2.32830644e-10;\n}\n\n/* \n    Returns random vec3([-1.0; 1.0], [-1.0; 1.0], [-1.0; 1.0]).\n*/\nvec3 vector3HashUI32(\n    const uint x,\n    const uint y,\n    const uint z)\n{\n    // Pick some enthropy source values.\n    // Try different values.\n    const uint enthropy0 = 1200u;\n    const uint enthropy1 = 4500u;\n    const uint enthropy2 = 6700u;\n    const uint enthropy3 = 8900u;\n\n    // Use linear offset method to mix coordinates.\n    uint value0 = z * enthropy3 * enthropy2 + y * enthropy2 + x;\n    uint value1 = y * enthropy3 * enthropy2 + x * enthropy2 + z;\n    uint value2 = x * enthropy3 * enthropy2 + z * enthropy2 + y;\n\n    // Calculate hash.\n\tvalue0 += enthropy1; value0 *= 445593459u; value0 ^= enthropy0;\n    value1 += enthropy1; value1 *= 445593459u; value1 ^= enthropy0;\n    value2 += enthropy1; value2 *= 445593459u; value2 ^= enthropy0;\n\n    // 2.0f / 4294967295.0f = 4.6566128730773926e-10\n\n    return vec3(\n        float(value0 * value0 * value0) * 4.6566128730773926e-10f - 1.0f,\n        float(value1 * value1 * value1) * 4.6566128730773926e-10f - 1.0f,\n        float(value2 * value2 * value2) * 4.6566128730773926e-10f - 1.0f);\n}\n\nfloat valueNoise3D(float u, float v, float w)\n{\n    // Fractial part.\n    float fractU = u - floor(u);\n    float fractV = v - floor(v);\n    float fractW = w - floor(w);\n\n    // Integer part.\n    u = floor(u);\n    v = floor(v);\n    w = floor(w);\n    \n    // Pseudorandom samples.\n    float sample0 = sample3DHashUI32(uint(u),       uint(v),       uint(w));\n    float sample1 = sample3DHashUI32(uint(u + 1.0), uint(v),       uint(w));\n    float sample2 = sample3DHashUI32(uint(u),       uint(v + 1.0), uint(w));\n    float sample3 = sample3DHashUI32(uint(u + 1.0), uint(v + 1.0), uint(w));\n    float sample4 = sample3DHashUI32(uint(u),       uint(v),       uint(w + 1.0));\n    float sample5 = sample3DHashUI32(uint(u + 1.0), uint(v),       uint(w + 1.0));\n    float sample6 = sample3DHashUI32(uint(u),       uint(v + 1.0), uint(w + 1.0));\n    float sample7 = sample3DHashUI32(uint(u + 1.0), uint(v + 1.0), uint(w + 1.0));\n\n    // Smoothstep.\n    float tU = fractU * fractU * (3.0 - 2.0 * fractU);\n    float tV = fractV * fractV * (3.0 - 2.0 * fractV);\n    float tW = fractW * fractW * (3.0 - 2.0 * fractW);\n\n    // Trilinear interpolation.\n    return \n        sample0 * (1.0 - tU) * (1.0 - tV) * (1.0 - tW) + \n        sample1 * tU         * (1.0 - tV) * (1.0 - tW) +\n        sample2 * (1.0 - tU) * tV         * (1.0 - tW) +\n        sample3 * tU         * tV         * (1.0 - tW) +\n        sample4 * (1.0 - tU) * (1.0 - tV) * tW + \n        sample5 * tU         * (1.0 - tV) * tW +\n        sample6 * (1.0 - tU) * tV         * tW +\n        sample7 * tU         * tV         * tW;\n}\n\nfloat PerlinNoise3D(float u, float v, float w)\n{\n    // Fractial part.\n    float fractU = u - floor(u);\n    float fractV = v - floor(v);\n    float fractW = w - floor(w);\n\n    // Integer part.\n    u = floor(u);\n    v = floor(v);\n    w = floor(w);\n\n    // Smoothstep.\n    float tU = fractU * fractU * (3.0f - 2.0f * fractU);\n    float tV = fractV * fractV * (3.0f - 2.0f * fractV);\n    float tW = fractW * fractW * (3.0f - 2.0f * fractW);\n\n    // Random gradient vectors.\n    vec3 gradient0 = vector3HashUI32(uint(u),        uint(v),        uint(w));\n    vec3 gradient1 = vector3HashUI32(uint(u + 1.0f), uint(v),        uint(w));     \n    vec3 gradient2 = vector3HashUI32(uint(u),        uint(v + 1.0f), uint(w));\n    vec3 gradient3 = vector3HashUI32(uint(u + 1.0f), uint(v + 1.0f), uint(w));\n    vec3 gradient4 = vector3HashUI32(uint(u),        uint(v),        uint(w + 1.0f));\n    vec3 gradient5 = vector3HashUI32(uint(u + 1.0f), uint(v),        uint(w + 1.0f));\n    vec3 gradient6 = vector3HashUI32(uint(u),        uint(v + 1.0f), uint(w + 1.0f));\n    vec3 gradient7 = vector3HashUI32(uint(u + 1.0f), uint(v + 1.0f), uint(w + 1.0f));\n\n    // Distance vectors.\n    vec3 distance0 = vec3(fractU,        fractV,        fractW);\n    vec3 distance1 = vec3(fractU - 1.0f, fractV,        fractW);\n    vec3 distance2 = vec3(fractU,        fractV - 1.0f, fractW);\n    vec3 distance3 = vec3(fractU - 1.0f, fractV - 1.0f, fractW);\n    vec3 distance4 = vec3(fractU,        fractV,        fractW - 1.0f);\n    vec3 distance5 = vec3(fractU - 1.0f, fractV,        fractW - 1.0f);\n    vec3 distance6 = vec3(fractU,        fractV - 1.0f, fractW - 1.0f);\n    vec3 distance7 = vec3(fractU - 1.0f, fractV - 1.0f, fractW - 1.0f);\n\n    // Dot products.\n    float dotProduct0 = gradient0.x * distance0.x + gradient0.y * distance0.y + gradient0.z * distance0.z;\n    float dotProduct1 = gradient1.x * distance1.x + gradient1.y * distance1.y + gradient1.z * distance1.z;\n    float dotProduct2 = gradient2.x * distance2.x + gradient2.y * distance2.y + gradient2.z * distance2.z;\n    float dotProduct3 = gradient3.x * distance3.x + gradient3.y * distance3.y + gradient3.z * distance3.z;\n    float dotProduct4 = gradient4.x * distance4.x + gradient4.y * distance4.y + gradient4.z * distance4.z;\n    float dotProduct5 = gradient5.x * distance5.x + gradient5.y * distance5.y + gradient5.z * distance5.z;\n    float dotProduct6 = gradient6.x * distance6.x + gradient6.y * distance6.y + gradient6.z * distance6.z;\n    float dotProduct7 = gradient7.x * distance7.x + gradient7.y * distance7.y + gradient7.z * distance7.z;\n\n    // Trilinear filter.\n    return\n        dotProduct0 * (1.0f - tU) * (1.0f - tV) * (1.0f - tW) +\n        dotProduct1 * tU          * (1.0f - tV) * (1.0f - tW) +\n        dotProduct2 * (1.0f - tU) * tV          * (1.0f - tW) +\n        dotProduct3 * tU          * tV          * (1.0f - tW) +\n        dotProduct4 * (1.0f - tU) * (1.0f - tV) * tW +\n        dotProduct5 * tU          * (1.0f - tV) * tW +\n        dotProduct6 * (1.0f - tU) * tV          * tW +\n        dotProduct7 * tU          * tV          * tW;\n}\n\nfloat WorleyNoise3D(float u, float v, float w)\n{\n    // Fractial part.\n    float fractU = u - floor(u);\n    float fractV = v - floor(v);\n    float fractW = w - floor(w);\n\n    // Integer part.\n    u = floor(u);\n    v = floor(v);\n    w = floor(w);\n\n    float minDistance = 3.40282347e+37f; // FL_MAX = 3.40282347e+38f\n\n    for (float z = -1.0f; z < 2.0f; z += 1.0f)\n    {\n        for (float y = -1.0f; y < 2.0f; y += 1.0f)\n        {\n            for (float x = -1.0f; x < 2.0f; x += 1.0f)\n            {\n                // Pseudorandom sample coordinates in corresponding cell.\n                float xSample = x + sample3DHashUI32(uint(u + x), uint(v + y), uint(w + z));\n                float ySample = y + sample3DHashUI32(uint(u + x), uint(v + y), uint(w + z));\n                float zSample = z + sample3DHashUI32(uint(u + x), uint(v + y), uint(w + z));\n\n                // Distance from pixel to pseudorandom sample.\n                //float distance = \n                    //sqrt(\n                        //(fractU - xSample) * (fractU - xSample) +\n                        //(fractV - ySample) * (fractV - ySample) +\n                        //(fractW - zSample) * (fractW - zSample));\n                        \n                float distance = \n                        (fractU - xSample) * (fractU - xSample) +\n                        (fractV - ySample) * (fractV - ySample) +\n                        (fractW - zSample) * (fractW - zSample);\n\n                // Mistance from pixel to pseudorandom sample.\n                minDistance = min(minDistance, distance);\n            }\n        }\n    }\n\n    return minDistance;\n}","name":"Common","description":"","type":"common"}]}