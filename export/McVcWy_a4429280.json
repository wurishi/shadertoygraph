{"ver":"0.1","info":{"id":"McVcWy","date":"1732351432","viewed":42,"name":"🎵 SoundCloud Fix + HLS Audio","username":"cf","description":"A new revision to my fix for SoundCloud playback on ShaderToy, now with support for HLS streams and proper artist metadata 🎉\nBackend: https://gist.github.com/cf/4a7fd6a7a3e93bdcc7c36d9685320b6f","likes":3,"published":1,"flags":64,"usePreview":0,"tags":["broken","soundcloud","fix","url","hls"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"lsVGzh","filepath":"https://soundcloud.com/gryffinofficial/sometimes-you-know-with-maia-wright","previewfilepath":"https://soundcloud.com/gryffinofficial/sometimes-you-know-with-maia-wright","type":"musicstream","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\nIt looks like the SoundCloud API finally stopped working on ShaderToy.\nBut have no fear, tunes are here, and now back with HLS support as well!\n\n--> How to fix broken SoundCloud URLs on shadertoy <--\n1. Open Developer Tools\n2. Paste the script below and enjoy the music~\n\nNote: You may have to hit the [⏮] rewind button on the audio channel to reset the player.\nAlso if you want to see how this works, check out the eval-free (but substantially longer) version:\nhttps://gist.github.com/cf/fe578edee8a63977a9f5c47e84925cf4\n*/\n\n/*\n// START SCRIPT\nfunction patchEffectPassNewTexture(oldScript){\n  const newTextureStart = oldScript.indexOf(\"EffectPass.prototype.NewTexture\");\n  const newTextureReturn = oldScript.lastIndexOf(\"return { mFailed: true };\");\n  if(newTextureStart === -1 || newTextureReturn < newTextureStart) return alert(\"could not patch EffectPass.prototype.NewTexture, HLS streams will not work\");\n  const functionBody = oldScript.substring(newTextureStart, newTextureReturn+25)+\"\\n};\";\n  eval(\n    functionBody\n      .replace(\"texture.audio = document.createElement('audio')\",\"texture.audio = document.createElement('video')\")\n      .replace(\"SC.resolve(url.mSrc,\", \"scResolvePatched(url.mSrc,texture,\")\n  );\n}\nfunction loadHLSJS() {\n  if (window._HAS_LOADED_HLS_JS) return Promise.resolve(true);\n  return new Promise((resolve) => {\n    const script = document.createElement(\"script\");\n    script.integrity = \"sha384-9v3HcdYrO3D+OPDTjZ40RXocgE4GtXVCd3/mCS62JsM93JXgI1afJVuwjFvsu6ni\";\n    script.crossOrigin = \"anonymous\";\n    script.onload = () => resolve(window._HAS_LOADED_HLS_JS = true);\n    script.src = \"https://cdn.jsdelivr.net/npm/hls.js@1.5.17/dist/hls.min.js\";\n    document.head.appendChild(script);\n  });\n}\nasync function soundCloudFix(soundCloudURL) {\n  const resp = await fetch(\"https://shadertoyschls.9z.workers.dev/sc?url=\"+encodeURIComponent(soundCloudURL));\n  const respJson = await resp.json();\n  if (respJson.protocol === \"hls\") await loadHLSJS();\n  return respJson;\n}\nfunction scResolvePatched(url, texture, _callback, onError) {\n  soundCloudFix(url).then((song) => {\n    texture.audio.crossOrigin = \"anonymous\";\n    if (song.protocol === \"hls\" && Hls.isSupported()) { \n      const hls = new Hls();\n      hls.loadSource(song.stream_url);\n      hls.attachMedia(texture.audio);\n    }else{\n      texture.audio.src = song.stream_url;\n    }\n    texture.audio.soundcloudInfo = song;\n  }).catch(onError);\n}\nfunction runFix() {\n  patchEffectPassNewTexture(\n    Array.from(document.head.getElementsByTagName(\"script\"))\n      .map((x) => x.innerHTML)\n      .filter((x) => x.indexOf(\"EffectPass.prototype.NewTexture\") !== -1)[0]\n  );\n  SC.resolve = function (url, callback, onError) { soundCloudFix(url).then(callback).catch(onError); };\n  if (gShaderID) {\n    loadShader(gShaderID);\n  }\n}\nrunFix();\n// END SCRIPT\n*/\n\n#define SAMPLE_AT(sp,w) (texture(iChannel1, vec2(floor(sp*subdiv)/subdiv, 0)).x*w)\nfloat qedForAll(vec3 p) {\n    float SCALE_QED_2D = SAMPLE_AT(0.7,0.5)-SAMPLE_AT(0.1,0.15)+0.75;\n    float d = rotatedSDBox(p, vec3(THICKNESS,0.11*SCALE_QED_2D,0.52*SCALE_QED_2D), vec3(0,-0.1335*SCALE_QED_2D,0.01*SCALE_QED_2D)*2., -0.27925268016);\n    d = min(d, rotatedSDBox(p,vec3(THICKNESS,0.09*SCALE_QED_2D,0.58*SCALE_QED_2D), vec3(0,0.1146*SCALE_QED_2D,0.005*SCALE_QED_2D)*2., 0.558505));\n    d = min(d, sdBox(p-vec3(0,0.01*SCALE_QED_2D,-0.06*SCALE_QED_2D)*2.,vec3(THICKNESS,0.26*SCALE_QED_2D,0.1*SCALE_QED_2D)));\n    d = min(d, sdBox(p-vec3(0,-0.05625*SCALE_QED_2D,0.257*SCALE_QED_2D)*2.,vec3(THICKNESS,0.1125*SCALE_QED_2D,0.04*SCALE_QED_2D)));\n    float core = sdBox(p-vec3(0,0.03*SCALE_QED_2D,0.06*SCALE_QED_2D),vec3(THICKNESS,0.6*SCALE_QED_2D,0.5*SCALE_QED_2D));\n    d = max(d, core);\n    //SCALE_QED_2D = texture(iChannel1, vec2(floor(0.9*subdiv)/subdiv, 0)).y*0.2+SCALE_QED_2D*0.75+0.25;//0.5;\n    d = min(d, tubeSDF(p.zxy, 0.78*SCALE_QED_2D, 0.99*SCALE_QED_2D, THICKNESS, 0.01));\n    return d;\n}\n\nfloat sdScene(vec3 p) {\n  return qedForAll(vec3(p.z, p.x, -p.y)*TWEEN_VALUE*0.5);\n}\n\nfloat rayMarch(vec3 ro, vec3 rd) {\n  float depth = MIN_DIST;\n\n  for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n    vec3 p = ro + depth * rd;\n    float d = sdScene(p);\n    depth += d;\n    if (d < PRECISION || depth > MAX_DIST) break;\n  }\n\n  return depth;\n}\n\nvec3 calcNormal(vec3 p) {\n    vec2 e = vec2(1.0, -1.0) * EPSILON;\n    float r = 1.;\n    return normalize(\n      e.xyy * sdScene(p + e.xyy) +\n      e.yyx * sdScene(p + e.yyx) +\n      e.yxy * sdScene(p + e.yxy) +\n      e.xxx * sdScene(p + e.xxx));\n}\n\nvec3 phong(vec3 lightDir, float lightIntensity, vec3 rd, vec3 normal) {\n  vec3 cubemapReflectionColor = texture(iChannel0, reflect(rd, normal)).rgb;\n\n  vec3 K_a = 1.5 * vec3(0.0,0.5,0.8) * cubemapReflectionColor; // Reflection\n  vec3 K_d = vec3(1);\n  vec3 K_s = vec3(1);\n  float alpha = 50.;\n\n  float diffuse = clamp(dot(lightDir, normal), 0., 1.);\n  float specular = pow(clamp(dot(reflect(lightDir, normal), -rd), 0., 1.), alpha);\n\n  return lightIntensity * (K_a + K_d * diffuse + K_s * specular);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 uv = fragCoord / iResolution.xy;\n\n    vec4 col2 = texture(iChannel1, vec2(floor(uv.x*subdiv)/subdiv, 0));\n    vec4 icol = texture(iChannel1, vec2(floor((1.0-uv.x)*subdiv)/subdiv, 0));\n\n\n\n    float sound = col2.x * height;\n    float isound = log(icol.x * height + 1.);\n    \n    fragColor = sound > uv.y || isound > 1.0-uv.y? vec4(1):vec4(0);\n    \n    float barThickness = (1.0/subdiv)*barAmount;\n    \n    fragColor = mod(uv.x, 1.0/subdiv) > barThickness?vec4(0):fragColor;//gaps\n    \n    fragColor.xyz *= mix(vec3(0.0, 1.0, 1.0), vec3(0.6, 0.0, 0.5), abs(uv.y - 0.5)*2.0);\n      \n    uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec2 mouseUV = iMouse.xy/iResolution.xy;\n    if (mouseUV == vec2(0.0)) mouseUV = vec2(0.5); // trick to center mouse on page load\n\n    vec3 lp = vec3(0);\n    vec3 ro = vec3(0, 0, 6);\n    ro.yz *= rotate2d(mix(-PI/2., PI/2., mouseUV.y));\n    ro.xz *= rotate2d(mix(-PI, PI, mouseUV.x));\n\n    vec3 rd = camera(ro, lp) * normalize(vec3(uv, -1));\n\n    vec3 col = vec3(0.);\n\n    float d = rayMarch(ro, rd);\n\n    vec3 p = ro + rd * d;\n    vec3 normal = calcNormal(p);\n\n    vec3 lightPosition1 = vec3(1, 1, 1);\n    vec3 lightDirection1 = normalize(lightPosition1 - p);\n    vec3 lightPosition2 = vec3(-8, -6, -5);\n    vec3 lightDirection2 = normalize(lightPosition2 - p);\n\n    float lightIntensity1 = 0.65;\n    float lightIntensity2 = 0.3;\n\n    vec3 sphereColor = phong(lightDirection1, lightIntensity1, rd, normal);\n    sphereColor += phong(lightDirection2, lightIntensity2, rd, normal);\n    sphereColor += fresnel(normal, rd) * 0.4;\n\n    col = mix(col, sphereColor, step(d - MAX_DIST, 0.));\n    \n    if(col.x+col.y+col.z>0.5){\n      fragColor = vec4(col, 1.0);\n    }\n      \n    \n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// Bars from https://www.shadertoy.com/view/slycD3\nconst int MAX_MARCHING_STEPS = 260;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float PRECISION = 0.0005;\nconst float EPSILON = 0.00001;\nconst float PI = 3.14159265359;\n#define speed 5.0\n\nconst float barAmount = 0.2;//relative thickness of the bars\nconst float subdiv = 80.0;//number of bars.  \n//Try setting subdiv to 800 at barAmount to 1.  Very high resolution information is revealed\n//Bar amount 0.5 and subDiv iResolution.x/2. is cool too.\n\n// frequency sweep https://soundcloud.com/audiomix/20hz-20khz-frequency-sweep\n//set bar amount to 1.0 and subDiv to width of display\n\nconst float height = 0.5;//Maxium height of the bars relative to the screeen.\n\n\n\n#define OVERSHOOT(x) tanh(x*x)*(2./exp(x*x*x)+1.)\n#define TWEEN_VALUE OVERSHOOT(2.*iTime)\n\nmat2 rot2d(float a){\n    float c = cos(a), s = sin(a);\n    return mat2(c,-s,s,c);\n}\n#define THICKNESS 0.1\nfloat tubeSDF(vec3 position, float innerRadius, float outerRadius, float halfHeight, float cornerRadius) {\n   vec2 d = vec2(length(position.xz) - (outerRadius + innerRadius) * 0.5, position.y);\n   d = abs(d) - vec2((outerRadius - innerRadius) * 0.5, halfHeight) + cornerRadius;\n   return length(max(d, 0.0)) + min(max(d.x, d.y), 0.0) - cornerRadius;\n}\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\nfloat rotatedSDBox(vec3 pIn, vec3 b, vec3 offset, float angle){\n    vec3 p=pIn-offset;\n    vec4 q = vec4(sin(-angle*0.5), 0.0, 0.0, cos(-angle*0.5)); \n    return sdBox(2.0 * cross(q.xyz, p * q.w + cross(q.xyz, p)) + p, b);   \n}\nmat2 rotate2d(float theta) {\n  float s = sin(theta), c = cos(theta);\n  return mat2(c, -s, s, c);\n}\nmat3 camera(vec3 cameraPos, vec3 lookAtPoint) {\n    vec3 cd = normalize(lookAtPoint - cameraPos);\n    vec3 cr = normalize(cross(vec3(0, 1, 0), cd));\n    vec3 cu = normalize(cross(cd, cr));\n\n    return mat3(-cr, cu, -cd);\n}\nfloat fresnel(vec3 n, vec3 rd) {\n  return pow(clamp(1. - dot(n, -rd), 0., 1.), 5.);\n}","name":"Common","description":"","type":"common"}]}