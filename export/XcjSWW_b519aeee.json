{"ver":"0.1","info":{"id":"XcjSWW","date":"1706384570","viewed":80,"name":"Help with a quartic","username":"zenzicubic","description":"This quartic solver I made is broken, does anyone know why?","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["quartic","broken","goursat"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\nQuartic solver, but with errors. Please comment if you've got any tips.\n*/\n\nstruct Hit {\n    bool hit;\n    float t;\n    vec3 pt, normal;\n};\n\nstruct Material {\n    float diffuse, specular, glossiness, reflectivity;\n};\n\n// Camera stuff\nvec3 eye;\nmat3 viewMat;\n#define FOCAL_LEN 2.5\n#define RAD_SQ 9.\n#define EPSILON 1e-5\n\n// Lighting/material\n#define AMBIENT .4\n#define INTENSITY .7\n#define LIGHT_POS vec3(10.)\nMaterial mat = Material(.5, .7, 30., .3);\n\n\n// Quadratic solver, based on Numerical Recipes in C, pg. 184\nvoid solveQuadratic(float a, float b, float c, out vec2 roots) {\n    float discr = b * b - 4. * a * c;\n    if (abs(discr) < EPSILON) {\n        // Discriminant is zero, one real root\n        roots.x = -b * .5 / a;\n    } else if (discr < 0.) {\n        // Two complex roots\n        return;\n    }\n    \n    // Two real roots\n    float q = -.5 * (b + sign(b) * sqrt(discr));\n    roots.x = q / a;\n    roots.y = c / q;\n}\n\nfloat trisect(float x) {\n    // Quilez's approximation\n    x = sqrt(.5 + .5*x);\n    return x * (x * (x * .021338 - .096562) + .575223) + .5;\n}\n\n// Cubic solver for a single real root, based on Numerical Recipes in C, pg. 184\nfloat findCubicRoot(float a, float b, float c) {\n    // Convert to depressed cubic\n    float a2 = a * a;\n    float Q = (a2 - 3. * b) / 9.;\n    float R = (2. * a2 * a - 9. * a * b + 27. * c) / 54.;\n    \n    float R2 = R * R, Q3 = Q * Q * Q;\n    a /= 3.;\n    if (R2 < Q3) {\n        // The cubic has three real roots, find one of them\n        return -2. * sqrt(Q) * trisect(R / sqrt(Q3)) - a;\n    } else { \n        // The cubic has one real root, find it\n        float A = -sign(R) * pow(abs(R) + sqrt(R2 - Q3), 1. / 3.);\n        float B = (A == 0. ? 0. : Q / A);\n        return A + B - a;\n    }\n}\n\n// Method from https://en.wikipedia.org/wiki/Quartic_equation#Quick_and_memorable_solution_from_first_principles\nvoid solveQuarticUnsafe(float a, vec4 bcde, out vec4 roots) {\n    // Convert to normal form\n    float b0 = bcde.x / a;\n    float c0 = bcde.y / a;\n    float d0 = bcde.z / a;\n    float e0 = bcde.w / a;\n    \n    // Now convert to depressed form\n    float b2 = b0 * b0;\n    float c = c0 - b2 * 0.375;\n    float d = (b0 * b2) * .125 - b0 * c0 * .5 + d0;\n    float e = -0.01171875 * b2 * b2 + b2 * c0 * .0625 - b0 * d0 * .25 + e0;\n    \n    // Solve the resolvent\n    float pp = findCubicRoot(2. * c, c * c - 4. * e, -d * d);\n    float p = sqrt(pp);\n    \n    // Compute quadratic coefficients\n    float dp = d / p;\n    float s = .5 * (c + pp + dp);\n    float q = .5 * (c + pp - dp);\n    \n    // Solve quadratics\n    solveQuadratic(1., p, q, roots.xy);\n    solveQuadratic(1., -p, s, roots.zw);\n    roots -= .25 * b0;\n}\n\nvoid solveQuartic(float a, vec4 bcde, out vec4 roots) {\n    if (abs(bcde.w) > abs(a)) {\n        solveQuarticUnsafe(bcde.w, vec4(bcde.zyx, a), roots);\n        roots = 1. / roots;\n    } else {\n        solveQuarticUnsafe(a, bcde, roots);\n    }\n}\n\nHit intersectScene(vec3 ro, vec3 rd) {\n    Hit hit;\n    hit.hit = false;\n    \n    // Solve the quartic x^4+y^4+z^4 = 1\n    vec3 ro2 = ro * ro;\n    vec3 rd2 = rd * rd;\n    float a = dot(rd2, rd2);\n    vec4 bcde = vec4(\n        4. * dot(rd2 * rd, ro),\n        6. * dot(rd2 * ro, ro), \n        4. * dot(ro2 * ro, rd),\n        dot(ro2, ro2));\n    bcde -= 2. * vec4(0.,\n        dot(rd, rd),\n        dot(rd, ro) * 2.,\n        dot(ro, ro));\n    bcde.w += 2.;\n    \n    vec4 roots;\n    solveQuartic(a, bcde, roots);\n    \n    // Test all solutions\n    float rt, t = 1000.;\n    bool root = false;\n    for (int i = 0; i < 4; i ++) {\n        rt = roots[i];\n        if (rt > 0. && rt < t) {\n            root = true;\n            t = rt;\n        }\n    }\n    if (!root) return hit;\n    \n    // Get normal\n    vec3 pt = ro + rd * t;\n    vec3 nrm = normalize(pt * pt * pt - pt);\n    nrm *= -sign(dot(rd, nrm));\n    \n    hit.hit = true;\n    hit.t = t;\n    hit.pt = pt;\n    hit.normal = nrm;\n    return hit;\n}\n\n/*\nCamera stuff.\n*/\n\nvoid setViewMat(vec3 lookAt) {\n    // OpenGL-style view matrix\n    vec3 w = normalize(lookAt - eye);\n    vec3 u = normalize(cross(w, vec3(0., 1., 0.)));\n    vec3 v = cross(u, w);\n    viewMat = mat3(u, v, -w);\n}\n\nvec3 getRayDir(vec2 p) {\n    // Get the ray direction\n    p = (2. * p - iResolution.xy) / iResolution.y;\n    vec3 d = normalize(vec3(p, -FOCAL_LEN));\n    return viewMat * d;\n}\n\n/*\nMain intersection, lighting, and coloring.\n*/\n\nfloat getLighting(Hit hit) {\n    // Simple Phong lighting\n    vec3 N = hit.normal, P = hit.pt;\n    vec3 L = normalize(LIGHT_POS - P);\n    vec3 V = normalize(eye - P);\n    vec3 R = reflect(-L, N);\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.) return 0.;\n    float contrib = mat.diffuse * dotLN;\n    \n    if (dotRV > 0.) {\n        contrib += mat.specular * pow(dotRV, mat.glossiness);\n    }\n    return contrib;\n}\n\nvec3 getColor(vec2 p) {\n    vec3 rd = getRayDir(p);\n    Hit hit = intersectScene(eye, rd);\n    if (hit.hit) {\n        // Simple lighting model\n        float brt = AMBIENT + INTENSITY * getLighting(hit);\n        \n        vec3 N = hit.normal;\n        vec3 col = brt * .5 * (1. + N);\n        vec3 refDir = reflect(rd, N);\n        return col;\n    }\n    return vec3(.1);\n}\n\nvoid mainImage(out vec4 col, vec2 pt) {\n    float t = .1 * iTime;\n    eye = 3. * vec3(2. * cos(t), 1., 2. * sin(t));\n    setViewMat(vec3(0.));\n    col = vec4(getColor(pt), 1.);\n}","name":"Image","description":"","type":"image"}]}