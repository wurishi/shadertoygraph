{"ver":"0.1","info":{"id":"Xt3BRB","date":"1541885859","viewed":70,"name":"1.Beadandó","username":"patriciabartha","description":"ufid fhaíieufh íosi","likes":2,"published":1,"flags":48,"usePreview":0,"tags":["probfss","vdfg","dfgfsdgju"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    int kernelSize = 3;\n    vec4 col = vec4(0.);\n    col = texelFetch(iChannel0, ivec2(int(fragCoord.x), fragCoord.y), 0);\n\t\n    float dist = texelFetch(iChannel0, ivec2(fragCoord.x, int(fragCoord.y)), 0).a;\n    \n    \n    for (int i=-kernelSize/2; i<=kernelSize/2; ++i)\n        for(int j=-kernelSize/2; j<=kernelSize/2; ++j)\n    {\n        if(dist != -1.){\n    \tcol = col + (1.-(1./(1.+dist)))*texelFetch(iChannel0, ivec2(int(fragCoord.x)+i, int(fragCoord.y)+j), 0);\n    \t}\n        \n    }\n    \n    if(dist != -1.){\n    col = col / (float(kernelSize*kernelSize)*(1.-(1./(1.+dist))));\n    }\n        \n    // Output to screen\n    fragColor = col;\n    \n}\n\n    ","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// Common key codes (WASD instead of arrows)\n\nconst int KeyLeft  = 65;\nconst int KeyRight = 68;\nconst int KeyUp    = 87;\nconst int KeyDown  = 83;\n\n/*\n\tA set of #define-s for camera and mouse handling\n\t\n\tWe will use the first 2 pixels of the buffer to store the information we need.\n\tEvery pixel contains 4 channels (floats), for RGBA. We can exploit this in the following way:\n\t\n\t\tpixel0 = (cameraX, cameraY, cameraZ)\n\t\tpixel1 = (U, V, mouseX, mouseY)\n\n\twhere \n\t\tcameraX, cameraY and cameraZ describe the position of the camera respectively\n\t\tU,V give the current rotation of the camera in spherical coordinates\n\t\t(mouseX, mouseY) is the position of the mouse while the left button is held\n*/\n\nvec4 px0, px1;\n\n#define loadPx0() px0 = texelFetch(iChannel0, ivec2(0,0), 0);\n#define loadPx1() px1 = texelFetch(iChannel0, ivec2(1,0), 0);\n\n#define pixel0 (fragCoord.x <1. && fragCoord.y <1.)\n#define pixel1 (fragCoord.x >=1.&& fragCoord.x <2. && fragCoord.y <1.)\n\n#define getCameraX() (px0.x)\n#define getCameraY() (px0.y)\n#define getCameraZ() (px0.z)\n\n#define setCameraX(p) if (pixel0) fragColor.x = p;\n#define setCameraY(p) if (pixel0) fragColor.y = p;\n#define setCameraZ(p) if (pixel0) fragColor.z = p;\n                   \n#define getU() (px1.x)\n#define getV() (px1.y)\n\n#define setU(p)       if (pixel1) fragColor.x = p;\n#define setV(p)       if (pixel1) fragColor.y = p;\n\n#define setMouseInit(p) if (pixel1) fragColor.zw = p;\n#define mouseInitPos()  (px1.zw)\n\n#define isKeyHeld(k)  (texelFetch(iChannel1, ivec2(k,0), 0).x > 0.)\n\n\n// Rotation matrices\nmat3 rotateX(float a)\n{\n    float c = cos(a);\n    float s = sin(a);\n    return mat3(\n    \t1, 0, 0,\n        0, c, s,\n        0, -s, c\n    );\n}\n\nmat3 rotateY(float a)\n{\n    float c = cos(a);\n    float s = sin(a);\n    return mat3(\n    \tc, 0, s,\n        0, 1, 0,\n        -s, 0, c\n    );\n}\n\nmat3 rotateZ(float a)\n{\n    float c = cos(a);\n    float s = sin(a);\n    return mat3(\n        c, s, 0,\n        -s, c, 0,\n        0, 0, 1\n    );\n}\n\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":2,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"struct ray_t {\n    vec3 start;\n    vec3 direction;\n};\n    \nvec3 lightpos= vec3(-4,7,3);\n\nconst float pi = 3.1415926535897932384626433832795;\n\n// Arbitrarily small value\nfloat eps = 0.005;\n\nfloat sdSphere(in vec3 p, in vec3 c, in float r)  \n{\n    return distance(c, p) - r;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sdCappedCylinder( vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdplane(in vec3 p, in vec3 q, in vec3 n)\n{\n    return dot(p-q,n);\n}\n\n\nfloat intersectSDF(in vec3 p, in float s1, in float s2) {\n    \n    return max(s1, s2);\n}\n\nfloat unionSDF(in vec3 p, in float s1, in float s2) {\n    \n   \n    return min(s1, s2);\n}\n\nfloat differenceSDF(in vec3 p, in float s1, in float s2) {\n    \n    \n    return max(s1, -s2);\n}\n\n\nfloat SDF(in vec3 p){\n\t\n    //\n    float plane = sdplane(p, vec3(0,-1,0), vec3(0,1,0));\n    \n    //\n    float dCylinder1 =  sdCappedCylinder(p, vec2(0.7,1.5));\n    float dCylinder2 =  sdCappedCylinder((mat4(vec4(1,0,0,0),vec4(0,0,1,0), vec4(0,-1,0,0),  vec4(0,0,0,1))*vec4(p,1)).xyz, vec2(0.7,1.5));\n    float dCylinder3 =  sdCappedCylinder((mat4(vec4(1,0,0,0),vec4(0,0,1,0), vec4(0,-1,0,0),  vec4(0,0,0,1))*mat4(vec4(0,0,-1,0),vec4(0,1,0,0), vec4(1,0,0,0),  vec4(0,0,0,1))*vec4(p,1)).xyz, vec2(0.7,1.5));\n    \n    //\n    float cube = sdBox(p, vec3(1,1,1));\n    float sphere = sdSphere(p, vec3(0,0,0), 1.35);\n    \n    float unio = unionSDF(p,unionSDF(p,dCylinder1, dCylinder2), dCylinder3);\n\tfloat inters = intersectSDF(p, cube, sphere);\n    float difference = differenceSDF(p, inters, unio);\n    \n    return unionSDF(p, difference, plane );\n    \n}\n\n\n// Surface normal to spheres[idx] on pos\n\nvec3 normal(const in vec3 p)\n{\n    vec3 plus = vec3(SDF(p+vec3(eps,0,0)),SDF(p+vec3(0,eps,0)),SDF(p+vec3(0,0,eps)));\n    vec3 minu = vec3(SDF(p-vec3(eps,0,0)),SDF(p-vec3(0,eps,0)),SDF(p-vec3(0,0,eps)));\n    return normalize(plus-minu);\n}\n\nvec2 map(vec3 p) {\n    \n    vec3 ret = (vec3(0,50,0)-p)/(40.*p.y)+vec3(0.4,0,0.5);\n    return ret.xz;\n}\n\nfloat shadow(in vec3 pos, in vec3 toLight, in vec3 nor)\n{\n    const int maxIter = 64;\n    float t = 0.1;\n    float lastd;\n    float res = 1.;\n    \n    \n    for(int i = 0; i < maxIter; i++)\n    {\n        lastd = SDF(pos + t * toLight);\n    \tt += lastd;\n        if (lastd < eps)\n        {\n            res = 0.25;\n            break;\n        }\n    }\n    \n    return res;\n}\n\nfloat Cook(vec3 H, vec3 V, vec3 N, vec3 L){\n    \n\t\tfloat NdotH = max(0., dot(N, H));\n\t\tfloat NdotV = max(0., dot(N, V));\n\t\tfloat VdotH = max(0., dot(L, H));\n    \tfloat NdotL = max(0., dot(N, L));\n\n\t\t// Fresnel reflectance\n    \tfloat F0 = 0.8;\n\t\tfloat F = pow(1.0 - VdotH, 5.0);\n\t\tF *= (1.0 - F0);\n\t\tF += F0;\n\n    \tfloat roughness = 0.5;\n\t\t// Microfacet distribution by Beckmann\n\t\tfloat m_squared = roughness * roughness;\n\t\tfloat r1 = 1.0 / (4.0 * m_squared * pow(NdotH, 4.0));\n\t\tfloat r2 = (NdotH * NdotH - 1.0) / (m_squared * NdotH * NdotH);\n\t\tfloat D = r1 * exp(r2);\n\n\t\t// Geometric shadowing\n\t\tfloat two_NdotH = 2.0 * NdotH;\n\t\tfloat g1 = (two_NdotH * NdotV) / VdotH;\n\t\tfloat g2 = (two_NdotH * NdotL) / VdotH;\n\t\tfloat G = min(1.0, min(g1, g2));\n\n\t\tfloat Rs = (F * D * G) / (4.0 * NdotL * NdotV);\n    \treturn Rs;\n}\n\nvec4 sphereTrace(const in ray_t ray)\n{\n    // Color to be returned\n    vec4 col;\n    \n    // Current step on the ray\n\tfloat t = 0.;\n    \n    // Length of the distance calculated at the last iteration\n    float lastd;\n    \n    // # of iterations\n    const int maxIter = 64;\n    \n    // Index of the object (if found) where the iteration stops\n    int idx;\n    \n    \n    for (int i=0; i<maxIter; i++) {\n        lastd = SDF(ray.start + t*ray.direction);\n    \tt += lastd;\n        if (lastd < eps) break;\n    }\n    \n    vec3 pos=ray.start + t*ray.direction;\n    vec3 nor=normal(pos);\n    vec3 tolight = normalize(lightpos-pos);\n    \n    float di = max(dot(tolight, nor), 0.0);\n    vec3 diffuse = texture(iChannel3, map(normalize(pos))).xyz * di* shadow(pos, tolight, nor);\n    \n    //float di = max(dot(tolight,nor),0.0);\n    //vec3 diffuse = vec3(0.3)*di;\n \n    vec3 specular = vec3(0);\n    if(di>0.0)\n    {\n        vec3 toeye = normalize(vec3(0,0,-6)-pos);\n        vec3 halfangle = normalize(toeye + tolight);\n    \tspecular = vec3(1,0,0)*Cook(halfangle, toeye, nor, tolight);//*pow(dot(halfangle, nor),100.0);\n    }\n    \n    \n    \n    \n    if (lastd < eps) \n        // The color will be the surface normal at the point\n        col =  vec4(diffuse+specular, t);//texture (iChannel3, nor).xyz;\n    \t//col =  diffuse + specular + texture(iChannel3, normalize(nor.xy)).xyz;\n    else \n        // Background\n        col = vec4(texture (iChannel2, ray.direction).xyz, -1.);\n    \n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    \n    // Load the pixels(texels) in which we store camera information\n    loadPx0();\n    loadPx1();\n    \n    vec3 cameraPos = vec3(getCameraX(), getCameraY(), getCameraZ());\n    vec2 cameraRot = vec2(getU(), getV());\n    mat3 cameraRotMat = rotateY(cameraRot.y)*rotateX(cameraRot.x);\n\n    // Normalized pixel coordinates (from -1 to 1)\n    vec2 uv = fragCoord/iResolution.xy*2. + vec2(-1.,-1.);\n\n    float angleX = pi/2.;\n    float angleY = angleX * iResolution.y / iResolution.x;\n    float x = (uv.x) * angleX;\n    float y = (uv.y) * angleY;\n\n\n    ray_t ray;\n    ray.direction = normalize(cameraRotMat*vec3(x, y, 1));\n    ray.start = cameraPos;// + ray.direction * 5.;\n\n    \n    vec3 col = texture(iChannel2, ray.direction).xyz;\n    fragColor = sphereTrace(ray);\n    //fragColor = vec4( col, 1.f );\n    \n    \n    \n    // Keyboard and mouse handling:  \n    const float v = 0.3;\n    vec3 rightDir = cameraRotMat*vec3(v, 0, 0);\n    vec3 zoomDir  = cameraRotMat*vec3(0, 0, v);\n    if (isKeyHeld(KeyLeft )) cameraPos -= rightDir;\n    if (isKeyHeld(KeyRight)) cameraPos += rightDir;\n    if (isKeyHeld(KeyUp   )) cameraPos += zoomDir;\n    if (isKeyHeld(KeyDown )) cameraPos -= zoomDir;\n    \n    setCameraX(cameraPos.x);\n    setCameraY(cameraPos.y);\n    setCameraZ(cameraPos.z);\n        \n    vec2 mouseInit = mouseInitPos();\n    if (mouseInit.x > 0.) {\n        const float camV = 0.03;\n        setU(cameraRot.x + sign(mouseInit.y-iMouse.y)*camV);\n        setV(cameraRot.y + sign(mouseInit.x-iMouse.x)*camV);\n        setMouseInit(iMouse.xy);\n    }\n    else {\n    \tsetU(cameraRot.x);\n        setV(cameraRot.y);\n    \tsetMouseInit(iMouse.zw);\n    }\n    \n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[{"id":"XsXGR8","channel":0}],"code":"#define MAX_ITER 500\n\nfloat fJulia(vec2 z, vec2 c){\n    \n    float l = 0.;\n    for(float i=0.;i<float(MAX_ITER);i++) {\n        if (z.x*z.x + z.y*z.y > 4.) {\n        \treturn l;\n            break;\t\n        }\n        z = vec2(z.x*z.x-(z.y*z.y), 2.*z.x*z.y)+c;\n        l+=1.;\n    }\n    return l - log(log(length(z))/log(256.))/log(2.0);\n\n}\n\nvec3 juliaColor(float n)\t{  \n    \n    if (n == float(MAX_ITER)){\n    \treturn vec3(0.,1.,1.); \n    }\n    \n    const int size = 7;\n    vec3 colors[size] = vec3[size](vec3(0.,1.,1.), vec3(1.,0.,1.), vec3(0.,0.,1.), vec3(0.,1.,0.), vec3(1.,1.,0.), vec3(1.,0.5,0.), vec3(0.,0.,0.)) ;\n    \n    float j = float(size) * n * 2./ float(MAX_ITER);\n    \n    return colors[int(floor(j))] + (j - floor(j))\n        * (colors[int(ceil(j))] - colors[int(floor(j))]);\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 z = 2.*((2.*fragCoord - iResolution.xy)/iResolution.x);\n    vec2 c = (2.*vec2(55,110) - iResolution.xy)/iResolution.x;\n    \n    float fjul = fJulia(z, c);\n    fragColor = vec4(juliaColor(fjul),1.);\n}","name":"Buffer B","description":"","type":"buffer"}]}