{"ver":"0.1","info":{"id":"stKcDW","date":"1663334309","viewed":345,"name":"2D Character Controller","username":"TheTurk","description":"Move: W, A, S, D or arrow keys\nJump: Space\nGenerates a mesh from the underlying distance field, so that collisions work with any distance field even if it is not exact.","likes":19,"published":1,"flags":48,"usePreview":0,"tags":["2d","game","collision","sdf","keyboard","physics","jump","character","move","movement","controller","wasd","platformer"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec4 read(ivec2 offset) {\n    return texelFetch(iChannel1, offset, 0);\n}\n\nfloat grid(vec2 position) {\n    vec2 d = abs(fract(position + 0.5) - 0.5);\n    return min(d.x, d.y);\n} \n\nconst ivec2 directions[2] = ivec2[2](\n    ivec2(-1, 0),\n    ivec2(0, -1)\n);\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 position = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n\n    vec2 characterPosition = read(bufferOffsetCharacterPosition).xy;\n    vec2 cameraPosition = read(bufferOffsetCameraPosition).xy;\n    vec4 programState = read(bufferOffsetProgramState);\n\n    position += cameraPosition;\n    float d1 = sdf(programState, position);\n    \n    vec3 color = mix(vec3(0.88, 0.68, 0.6), vec3(0.7, 0.75, 0.85), clamp(d1 * 0.85, 0.0, 1.0));\n    color -= mix(vec3(0.03, 0.21, 0.21), vec3(0.0), smoothstep(0.0, 3.0, d1 * iResolution.y));\n    color -= (1.0 - smoothstep(0.0, 3.0, (abs(d1) - 0.0025) * iResolution.y)) * 0.85;  \n\n    float d2 = length(position - (characterPosition + vec2(0.0, colliderRadius))) - colliderRadius;\n    color = mix(color, vec3(1.0, 0.0, 0.0), 1.0 - smoothstep(0.0, 3.0, d2 * iResolution.y));\n   \n    for (int j = 1; j < int(gridSize); j++) {\n        for (int i = 1; i < int(gridSize); i++) {\n            vec4 cell1 = texelFetch(iChannel0, ivec2(i, j), 0);\n            int edgeMask = int(cell1.w);\n            if (edgeMask == 0) {\n                continue;\n            }\n            for (int edge = 0; edge < 2; edge++) {\n                if ((edgeMask & (1 << edge)) > 0) {\n                    vec4 cell2 = texelFetch(iChannel0, ivec2(i, j) + directions[edge], 0);\n                    float d1 = disk(position - cell1.xy, 0.025);\n                    color = mix(color, vec3(1.0, 0.0, 0.0), 1.0 - smoothstep(0.0, 3.0, d1 * iResolution.y));\n                    float d2 = disk(position - cell2.xy, 0.025);\n                    color = mix(color, vec3(1.0, 0.0, 0.0), 1.0 - smoothstep(0.0, 3.0, d2 * iResolution.y));\n                    float d3 = segment(position, cell1.xy, cell2.xy); \n                    color = mix(color, vec3(1.0, 0.0, 0.0), 1.0 - smoothstep(0.0, 3.0, (d3 - 0.003) * iResolution.y));\n                } \n            }\n        }\n    }\n    \n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"float PI = 3.141592;\n\nconst float gridSize = 16.0;\nconst float halfGridSize = 8.0;\nconst float cellSize = 1.0 / 16.0;\n\nconst ivec2 bufferOffsetCharacterPosition = ivec2(0, 0);\nconst ivec2 bufferOffsetCharacterVelocity = ivec2(0, 1);\nconst ivec2 bufferOffsetCameraPosition = ivec2(0, 2);\nconst ivec2 bufferOffsetProgramState = ivec2(0, 3);\nconst ivec2 bufferOffsetLastMouseState = ivec2(0, 4);\nconst ivec2 bufferOffsetActivationTime = ivec2(0, 5);\n\nfloat colliderRadius = 0.2;\n\nfloat box(vec2 position, vec2 halfSize, float cornerRadius) {\n   position = abs(position) - halfSize + cornerRadius;\n   return length(max(position, 0.0)) + min(max(position.x, position.y), 0.0) - cornerRadius;\n}\n\nfloat disk(vec2 position, float radius) {\n    return length(position) - radius;\n}\n\nfloat segment(vec2 position, vec2 start, vec2 end) {\n    position = position - start;\n    end = end - start;\n    float height = clamp(dot(position, end) / dot(end, end), 0.0, 1.0);\n    return length(position - end * height);\n}\n\nfloat smoothMax(float distance1, float distance2, float k) {\n\tvec2 u = max(vec2(k + distance1, k + distance2), vec2(0.0));\n\treturn min(-k, max(distance1, distance2)) + length(u);\n}\n\n// https://www.shadertoy.com/view/3tyBzV\nfloat secret(vec2 position) {\n    position.x = abs(position.x);\n    if (position.y + position.x > 1.0) {\n        vec2 d = position - vec2(0.25,0.75);\n        return sqrt(dot(d, d)) - sqrt(2.0) / 4.0;\n    }\n    vec2 d1 = position - vec2(0.0, 1.0);\n    vec2 d2 = position - 0.5 * max(position.x + position.y,0.0);\n    return sqrt(min(dot(d1, d1), dot(d2, d2))) * sign(position.x - position.y);\n}\n\nfloat sdf(vec4 programState, vec2 position) {\n    position.x -= -0.6; \n\n    // left \n    float box1 = box(position - vec2(-15.0, -0.4), vec2(2.0, 1.0), 0.05);\n    float scene = box1;    \n    float box2 = box(position - vec2(-10.0, -1.0), vec2(3.0, 0.4), 0.05);\n    scene = min(scene, box2);\n    float box3 = box(position - vec2(-5.0, -0.4), vec2(2.0, 1.0 * 1.0), 0.05);\n    scene = min(scene, box3);\n    // middle\n    float box4 = box(position - vec2(0.0, -1.1), vec2(3.0, 0.4), 0.05);\n    scene = min(scene, box4);\n    // right\n    float box5 = box(position - vec2(5.0, -0.4), vec2(2.0, 1.0), 0.05);\n    scene = min(scene, box5);\n    float box6 = box(position - vec2(10.0, -1.0), vec2(3.0, 0.4), 0.05);\n    scene = min(scene, box6);\n    float aid = box(position - vec2(7.2, -0.4), vec2(0.2, 0.2) , 0.05);\n    scene = min(scene, aid);\n    float box7 = box(position - vec2(15.0, -0.4), vec2(2.0, 1.0), 0.05);\n    scene = min(scene, box7);\n    \n    float box8 = box(position - vec2(-0.15, 0.2), vec2(0.8, 0.2), 0.05);\n    scene = min(scene, box8);\n    float box9 = box(position - vec2(2.0, 0.2), vec2(0.2, 0.2), 0.05);\n    scene = min(scene, box9);\n    \n    position -= vec2(-10.0, -1.12);\n    position.y += cos(programState.y) * 0.7;\n    float d = secret(position);\n    scene = min(scene, d);\n    return scene;\n\n  /*\n    float height = sin((position.x + 3.0) * 0.2) * 0.4;\n    float scene = position.y - height;\n    float disk = disk(position - vec2(0.0, 0.1), 1.0);\n    scene = smoothMax(scene, -disk, 1.0);\n    return scene;\n    */\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"vec4 read(ivec2 offset) {\n    return texelFetch(iChannel0, offset, 0);\n}\n\nconst vec2 vertices[4] = vec2[4](\n    vec2(0.0, 0.0), // bottom left\n    vec2(1.0, 0.0), // bottom right\n    vec2(0.0, 1.0), // top left\n    vec2(1.0, 1.0)  // top right\n);\n\nconst int edges[8] = int[8](\n    0, 2, // left\n    0, 1, // bottom\n    2, 3, // top\n    1, 3  // right\n);\n    \nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    if (!(fragCoord.x < gridSize && fragCoord.y < gridSize)) {\n        discard;\n    }\n    \n    vec2 characterPosition = read(bufferOffsetCharacterPosition).xy + vec2(0.0, colliderRadius);\n    vec2 position = floor(fragCoord) - halfGridSize;\n    vec2 meshPosition = round(characterPosition / cellSize) * cellSize;\n    vec4 programState = read(bufferOffsetProgramState);\n\n    float values[4];\n    for (int i = 0; i < 4; i++) {\n        values[i] = sdf(programState, (position + vertices[i]) * cellSize + meshPosition); \n    }\n    \n    int edgeMask = 0;\n    vec2 intersection = vec2(0.0);\n    float intersectionCount = 0.0;\n    int j = 0;\n    for (int i = 0; i < 8; i += 2) {\n        float value1 = values[edges[i]]; \n        float value2 = values[edges[i + 1]];\n        if (value1 < 0.0 != value2 < 0.0) {\n            vec2 vertex1 = vertices[edges[i]]; \n            vec2 vertex2 = vertices[edges[i + 1]];\n            vec2 vertex3 = vertex1 - value1 / (value2 - value1) * (vertex2 - vertex1);\n            intersection += vertex3;\n            intersectionCount += 1.0;\n            edgeMask |= 1 << j;\n        }\n        j += 1;\n    }\n    intersection = (position + intersection / intersectionCount) * cellSize + meshPosition;\n    fragColor = vec4(intersection.x, intersection.y, 0.0, edgeMask);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"bool keyIsPressed(int key) {\n\treturn texelFetch(iChannel3, ivec2(key, 0), 0).x > 0.0;\n}\n\nbool keyIsToggled(int key) {\n\treturn texelFetch(iChannel3, ivec2(key, 2), 0).x > 0.0;\n}\n\nbool checkBufferOffset(vec2 fragCoord, ivec2 offset) {\n    return int(fragCoord.x) == offset.x && int(fragCoord.y) == offset.y;\n}\n\nvoid write(vec4 value, ivec2 offset, inout vec4 fragColor, vec2 fragCoord) {\n    if (checkBufferOffset(fragCoord, offset)) {\n        fragColor = value;\n    }\n}\n\nvec4 read(ivec2 offset) {\n    return texelFetch(iChannel1, offset, 0);\n}\n\nconst ivec2 directions[2] = ivec2[2](\n    ivec2(-1, 0),\n    ivec2(0, -1)\n);\n\nstruct Camera {\n    vec2 position;\n};\n\nstruct Character {\n    vec2 position;\n    vec2 velocity;\n};\n\nstruct Hit {\n    float t;\n    float fraction;\n};\n\nbool raycast(vec4 programState, vec2 rayOrigin, vec2 rayDirection, float maximumDistance, inout Hit hit) {\n    float t = 0.0;\n    int stepCount = 16;\n    for (int i = 0; i < stepCount; i++) {\n        vec2 currentPosition = rayOrigin + rayDirection * t;\n        float d = sdf(programState, currentPosition);\n        if (d < 0.001) {\n            hit.t = t;\n            hit.fraction = t / maximumDistance;\n            return true;\n        }\n        t += d * 0.5;\n        if (t > maximumDistance) {\n            return false;\n        }\n    }\n    hit.t = t;\n    hit.fraction = t / maximumDistance;\n    return true;\n}\n\nbool raycast(vec4 programState, vec2 from, vec2 to, inout Hit hit) {\n    float maximumDistance = length(to - from);\n    vec2 rayDirection = normalize(to - from);\n    return raycast(programState, from, rayDirection, maximumDistance, hit);\n}\n\nstruct Contact {\n    vec2 normal;\n    float penetrationDistance;\n};\n\nbool contactTest(vec2 center, float radius, vec2 segmentStart, vec2 segmentEnd, inout Contact contact) {\n    center = center - segmentStart;\n    segmentEnd = segmentEnd - segmentStart;\n    float height = clamp(dot(center, segmentEnd) / dot(segmentEnd, segmentEnd), 0.0, 1.0);\n    vec2 normal = center - segmentEnd * height;\n    float d = length(normal);\n    if (d < radius) {\n        contact.normal = normal / d;\n        contact.penetrationDistance = abs(d - radius);\n        return true;\n    }\n    return false;\n}\n\nbool contactTest(vec2 center, float radius, inout Contact contact) {  \n    contact.penetrationDistance = -1.0;\n    bool success = false;   \n    for (int j = 1; j < int(gridSize); j++) {\n        for (int i = 1; i < int(gridSize); i++) {\n            vec4 cell1 = texelFetch(iChannel0, ivec2(i, j), 0);\n            int edgeMask = int(cell1.w);\n            if (edgeMask == 0) {\n                continue;\n            }\n            for (int edge = 0; edge < 2; edge++) {\n                if ((edgeMask & (1 << edge)) > 0) {\n                    vec4 cell2 = texelFetch(iChannel0, ivec2(i, j) + directions[edge], 0);\n                    Contact currentContact;\n                    if (contactTest(center, radius, cell1.xy, cell2.xy, currentContact)) {\n                        if (currentContact.penetrationDistance > contact.penetrationDistance) {\n                            contact = currentContact;\n                            success = true;\n                        }\n                    }\n                }\n            }\n        }\n    }\n    return success;\n}\n\nvoid update(inout Character character, inout Camera camera, vec4 programState, float deltaTime) {\n    bool leftPressed = keyIsPressed(65) || keyIsPressed(37);\n    bool rightPressed = keyIsPressed(68) || keyIsPressed(39);\n    bool upPressed = keyIsPressed(87) || keyIsPressed(38);\n    bool downPressed = keyIsPressed(83) || keyIsPressed(40);\n    bool spacePressed = keyIsPressed(32);\n    float xAxis = (leftPressed ? -1.0 : 0.0) + (rightPressed ? 1.0 : 0.0);\n    float yAxis = (upPressed ? 1.0 : 0.0) + (downPressed ? -1.0 : 0.0);\n   \n    bool isFlying = keyIsToggled(70);\n    if (isFlying) {\n        float flyingSpeed = 3.0;\n        character.velocity = vec2(xAxis, yAxis) * flyingSpeed;    \n        character.position += character.velocity * deltaTime;\n    } else {\n        float walkSpeed = 3.0;\n        vec2 up = vec2(0.0, 1.0);\n\n        Contact contact;\n        bool touchesGround = contactTest(character.position + vec2(0.0, colliderRadius) + vec2(0.0, -0.05), colliderRadius, contact);\n     \n        Hit hit;\n        float groundClearance = 1.0;\n        if (raycast(programState, character.position, character.position + vec2(0.0, -1.0), hit)) {\n            groundClearance = hit.t;\n        }\n   \n        if (touchesGround && groundClearance < 0.2) {\n            float speed = length(character.velocity);\n            if (speed > 0.0001) {\n                float friction = 15.0;\n                float minimumSpeed = 0.5; // minimum speed for friction calculation\n                float newSpeed = max(speed - max(speed, minimumSpeed) * friction * deltaTime, 0.0);\n                character.velocity *= newSpeed / speed;\n            }\n            vec2 verticalVelocity = dot(character.velocity, up) * up;\n            vec2 horizontalVelocity = character.velocity - verticalVelocity;\n            vec2 impulse = vec2(xAxis, 0.0) * 20.0 * walkSpeed;\n            horizontalVelocity += impulse * deltaTime; \n            if (length(horizontalVelocity) > walkSpeed) { // limit horizontal speed to walk speed\n                horizontalVelocity = normalize(horizontalVelocity) * walkSpeed; \n            }\n            character.velocity = horizontalVelocity + verticalVelocity;\n        } else {\n            vec2 verticalVelocity = dot(character.velocity, up) * up;\n            vec2 horizontalVelocity = character.velocity - verticalVelocity;\n            vec2 impulse = vec2(xAxis, 0.0) * 5.0 * walkSpeed;\n            horizontalVelocity += impulse * deltaTime;  \n            if (length(horizontalVelocity) > walkSpeed) { // limit horizontal speed to walk speed\n                horizontalVelocity = normalize(horizontalVelocity) * walkSpeed; \n            }\n            character.velocity = horizontalVelocity + verticalVelocity;\n        }\n        \n        float gravity = 15.0;\n        character.velocity += (-up * gravity) * deltaTime; \n  \n        if (spacePressed) {\n            if (groundClearance < 0.1) {\n                vec2 verticalVelocity = dot(character.velocity, up) * up;\n                character.velocity -= verticalVelocity;\n                character.velocity += up * 5.0; \n            }\n        }\n  \n        int stepCount = 10;\n        float stepSize =  deltaTime / float(stepCount);\n        for (int i = 0; i < stepCount; i++) { \n            character.position += character.velocity * stepSize;\n            vec2 center = character.position + vec2(0.0, colliderRadius);\n            Contact contact;\n            if (contactTest(center, colliderRadius, contact)) {\n                 character.position += contact.normal * (contact.penetrationDistance + 0.001);\n                 vec2 perpendicularVelocity = dot(character.velocity, contact.normal) * contact.normal;\n                 character.velocity -= perpendicularVelocity;\n            }\n        }\n    }\n    \n    camera.position = mix(camera.position, vec2(character.position.x, 0.0), 0.2);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    if (!(fragCoord.x < 1.0 && fragCoord.y < 8.0)) {\n        discard;\n    }\n    \n    Character character;\n    character.position = read(bufferOffsetCharacterPosition).xy;\n    character.velocity = read(bufferOffsetCharacterVelocity).xy;\n    Camera camera;\n    camera.position = read(bufferOffsetCameraPosition).xy;\n    vec4 programState = read(bufferOffsetProgramState);\n    if (programState.x == 0.0) {\n        programState.x = 1.0;\n        character.position.y = -0.5;\n    }\n    vec4 lastMouseState = read(bufferOffsetLastMouseState);\n    vec4 currentMouseState = iMouse;\n    \n    float deltaTime = 1.0 / 60.0;\n    \n    update(character, camera, programState, deltaTime);\n    \n    if (character.position.x > (-13.0 - 0.6) && character.position.x < (-7.0 - 0.6)) {\n        programState.y = min(programState.y + 0.01, PI);\n    }\n     \n    write(vec4(character.position, 0.0, 0.0), bufferOffsetCharacterPosition, fragColor, fragCoord);\n    write(vec4(character.velocity, 0.0, 0.0), bufferOffsetCharacterVelocity, fragColor, fragCoord);\n    write(vec4(camera.position, 0.0, 0.0), bufferOffsetCameraPosition, fragColor, fragCoord);\n    write(programState, bufferOffsetProgramState, fragColor, fragCoord);\n    write(currentMouseState, bufferOffsetLastMouseState, fragColor, fragCoord);\n}","name":"Buffer B","description":"","type":"buffer"}]}