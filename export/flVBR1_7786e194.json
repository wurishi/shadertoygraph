{"ver":"0.1","info":{"id":"flVBR1","date":"1664053120","viewed":406,"name":"Sierpinski 3D variations","username":"flo72","description":"This is a variation of the 3D Sierpinski fractal. Uncomment the two lines in the mainImage function if you want to explore the parameter space with the mouse cursor. ","likes":13,"published":1,"flags":0,"usePreview":0,"tags":["tetrahedron","3dfractal","sierpinskigasket"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .01\n#define MAX_ITER 30\n#define PI 3.1415926538\n#define TWO_PI 6.28318530718\n\nfloat alpha; \nfloat beta; \nfloat colorind;\n\nvoid rotateY(inout vec3 p, float alpha){\n\tfloat px=p.x;\n    float c=cos(alpha);\n    float s=sin(alpha);\n    \n \tp.x=c*px-s*p.z;\n    p.z=s*px+c*p.z;\n}\n\nvoid rotateX(inout vec3 p, float alpha){\n\tfloat py=p.y;\n    float c=cos(alpha);\n    float s=sin(alpha);\n    \n \tp.y=c*py-s*p.z;\n    p.z=s*py+c*p.z;\n}\n\nfloat sdMenger(vec3 p){\n    float scale=2.;\n    float rr=0.;\n    colorind=0.;\n    int n=0;\n    while(n<MAX_ITER){\n        rotateY(p,alpha);\n        rotateX(p,beta);\n       \n        p=abs(p);\n        if(p.y > p.x) p.yx = p.xy;\n        if(p.z > p.y) p.zy = p.yz;\n        \n        vec3 q=p-vec3(1);\n        p *=scale;\n       \n        if(p.z > .5*(scale-1.)){\n             p =p- vec3(1,1,1)*(scale-1.);\n             colorind++;\n        }\n        else {\n            p =p- vec3(1,1,0)*(scale-1.);\n        }\n        \n        n++;\n    }\n    return length(p) * pow(scale, -float(n));\n}\n\nfloat sdTetra(vec3 p)\n{\n    int n = 0;\n    float scale=1.3;\n    colorind=0.;\n    while (n < MAX_ITER) {\n        rotateY(p,alpha); \n        rotateX(p,beta);\n        \n        if(p.x+p.y<0.) p.xy = -p.yx; \n        if(p.x+p.z<0.) p.xz = -p.zx; \n        if(p.y+p.z<0.) {\n            p.zy = -p.yz;\n            colorind++;\n        } \n        p = p*scale - vec3(1,1,1)*(scale-1.);\n        n++;\n    }\n    return (length(p) ) * pow(scale, -float(n));\n}\n\nfloat getDist(vec3 p){\n    return sdTetra(p);\n}\n\nfloat RayMarch(vec3 ro,vec3 rd){\n    float dO=0.;\n    \n    for(int i=0; i<MAX_STEPS; i++){\n     vec3 p=ro+rd*dO;\n        float dS=getDist(p);\n        dO +=dS;\n        if(dO > MAX_DIST || dS< SURF_DIST) break;        \n    }\n    return dO;\n}\n    \nvec3 GetNormal(vec3 p){\n\tfloat d=getDist(p);\n    vec2 e=vec2(SURF_DIST*.5,0);\n    \n    vec3 n= d-vec3(\n        getDist(p-e.xyy),\n        getDist(p-e.yxy),\n        getDist(p-e.yyx));   \n\treturn normalize(n);\n}\n\nfloat shadow( in vec3 ro, in vec3 rd, float mint, float maxt, float k )\n{\n    float res = 1.0;\n    for( float t=mint; t<maxt; )\n    {\n        float h = getDist(ro + rd*t);\n        if( h<0.001 )\n            return 0.0;\n        res = min( res, k*h/t );\n        t += h;\n    }\n    return res;\n}\n\nvec3 render(in vec3 ro, in vec3 rd){\n     \n\tfloat d=RayMarch(ro,rd);   \n    vec3 p= ro+rd*d;   \n   \n    //light\n    vec3 lightPos =vec3(10,20,-20);\n    vec3 l=normalize(lightPos-p);\n    vec3 n=GetNormal(p);\n    float cosphi=dot(n,l);\n    vec3 v=normalize(-l+2.*cosphi*n);\n    \n    //color\n    float t=clamp(pow(colorind/float(MAX_ITER),1.5),0.,1.);  \n    vec3 col=mix(vec3(1.0,0.55,0.0),vec3(1.),t);\n    \n    //reflection\n    float po=15.;\n    float amb=0.1;\n    t=pow(clamp(dot(v,-rd),0.,1.),po);\n    col = (1.-t)*(amb+(1.-amb)*cosphi)*col+t*vec3(1.);\n         \n    //shadow\n    t=shadow(p,l,SURF_DIST*2.,MAX_DIST,4.);\n    col *=t;   \n    \n    //fog\n    t=pow(min(d/MAX_DIST,1.),2.);\n    col=(1.-t)*col+t*vec3(.5,.7,.9);\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time=iTime+155.+2.*(iMouse.x-.5*iResolution.x)/iResolution.x*PI;\n    alpha=-PI+mod(time*.1,TWO_PI);\n    beta=-PI+mod(time/TWO_PI*.1,TWO_PI);\n    \n    // alpha=(iMouse.x-.5*iResolution.x)/iResolution.x*3.14; \n    // beta=(iMouse.y-.5*iResolution.y)/iResolution.y*3.14;\n\n    \n    vec3 ro = vec3(0,0,-4);\n    \n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y; \n    vec3 rd = normalize(vec3(uv.x, uv.y,1)); \n\n\tvec3 col=render(ro,rd);\n    \n    fragColor = vec4(col,1.0);   \n}\n","name":"Image","description":"","type":"image"}]}