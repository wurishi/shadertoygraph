{"ver":"0.1","info":{"id":"4f3cWM","date":"1730711038","viewed":138,"name":"mandala colorful","username":"nayk","description":"source https://www.shadertoy.com/view/lftcD4","likes":3,"published":3,"flags":0,"usePreview":0,"tags":["fractal","tiling","circular","source"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define R(p,a,r)mix(a*dot(p,a),p,cos(r))+sin(r)*cross(p,a)\n#define H(h)(cos((h)*6.3+vec3(0,23,21))*.5+.5)\nconst vec2 U = vec2( 2.*sqrt(3.), 0. );\nconst vec2 V = vec2( sqrt(3.), 3. );\nfloat PI = acos(0.) * 2.;\n\nmat2 rot( float a ) { return mat2( cos(a), sin(a), -sin(a), cos(a) ); }\nvec2 rot( vec2 p, float a, vec2 c )\n{\n    return rot( a ) * ( p - c ) + c;\n}\n\nfloat udTiling( vec2 p, float radius, float theta )\n{\n    // map p to base parallelogram (in UV coordinates)\n    vec2 q = fract( inverse( ( mat2( U, V ) ) ) * p );\n        \n    // map p to base triangle (in UV coordinates)\n    if ( dot( q, vec2( 1., 1. ) ) >= 1. )\n        q = 1. - q;\n    \n    // map to back to orthogonal coordinates\n    vec2 P = mat2( U, V ) * q;\n    \n    // split triangle in 3 kites and map P to the base kite\n    if ( dot( q, vec2( 2., 1. ) ) >= 1. && q.x > q.y )\n        P = rot( P, -2.*PI/3., (U+V)/3. );\n    else if ( dot( q, vec2( 1., 2. ) ) >= 1. )\n        P = rot( P, 2.*PI/3., (U+V)/3. );    \n                     \n    // calculate the center of one arc\n    vec2 CIRCLE_CENTER_OFFSET = rot( -1.*PI/3. ) * ( (U+V)/3. - V + rot( theta ) * vec2( radius, 0. ) );\n            \n    // find distances to each arc/ring\n    float d0 = abs( distance( P, U + CIRCLE_CENTER_OFFSET ) ) - radius;\n    float d1 = abs( distance( P, U + rot( PI/3. ) * CIRCLE_CENTER_OFFSET ) ) - radius;\n    float d2 = abs( distance( P, V + rot( 2.*PI/3. ) * CIRCLE_CENTER_OFFSET ) ) - radius;\n    float d3 = abs( distance( P, V + rot( 1.*PI/3. ) * CIRCLE_CENTER_OFFSET ) ) - radius;    \n    // small fix for the three-way intersection: \n    float d3_b = abs( distance( rot( P, 4.*PI/3., (U+V)/3. ), V + rot( 1.*PI/3. ) * CIRCLE_CENTER_OFFSET ) ) - radius;\n    // fix when radius is large\n    float d2_b = abs( distance( rot( -PI/3. ) * P, V + rot( 2.*PI/3. ) * CIRCLE_CENTER_OFFSET ) ) - radius;\n    \n    // calculate SDF (UDF)\n    float d = 99.;\n    d = min( d, abs( d0 ) );      \n    if ( d2 > 0. )\n        d = min( d, abs( d1 ) );\n    d = min( d, abs( d2 ) );\n    d = min( d, abs( d3 ) );\n    if ( d3 > 0. )\n        d = min( d, abs( d3_b ) );\n    \n    d = min( d, abs( d2_b ) );\n    \n    return d;\n}\n#define rotation(angle) mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n\nfloat TAU = 2.*3.14159;\n\n// Thanks IQ\nfloat eqTri( in vec2 p, in float r )\n{\n    const float k = sqrt(3.0);\n    p.x = abs(p.x) - r;\n    p.y = p.y + r/k;\n    if( p.x+k*p.y>0.0 ) p = vec2(p.x-k*p.y,-k*p.x-p.y)/2.0;\n    p.x -= clamp( p.x, -2.0*r, 0.0 );\n    return -length(p)*sign(p.y);\n}\n\nvoid mainImage(out vec4 O, vec2 C)\n{\n    O=vec4(0);\n     vec2 p3 = (C*2.-iResolution.xy)/iResolution.y; \n  \n    p3 *= 7.;\n    \n    vec2 uv = ( C - .5 * iResolution.xy ) / iResolution.y;\n         \n  \n   vec3 col = vec3(0.);\n   float t = fract(.1 * iTime);\n   uv *= rotation(3. * TAU * (.3 - clamp(length(uv),0.,.3)));\n   float s = -1.;\n   for(float i = 0.; i < 3.; i++){\n     float rad = .4 / pow(2.,i) * (.9 - .2 * i);\n     \n     uv *= rotation(-2. * s * (i + 1.) * TAU * t);\n     float tri = eqTri(uv, rad);\n     s *= -1.;\n     col += .004 / abs(tri);\n   }\n  p3.xy*=mat2(cos(iTime),sin(iTime),-sin(iTime),  cos(iTime));\n  \n    float radius = 1.45 + sin(iTime)* .9;\n    float theta = 1.8 + cos(iTime) * .3;\n    float d= udTiling( p3, radius, theta );\n    \n \n    vec3 p,q,r=iResolution,\n    d3=normalize(vec3((C*2.-r.xy)/r.y,1));  \n    for(float i=0.,a,s,e,g=0.;\n        ++i<70.;\n        O.xyz+=mix(vec3(1),H(g*.1),.8)*1./e/8e3\n    )\n    {\n        p=g*d3*d;\n    \n        p.xy+=uv;\n       p.xy*=mat2(cos(iTime),sin(iTime),-sin(iTime),  cos(iTime));\n        a=30.;\n        p=mod(p-a,a*2.)-a;\n        s=2.;\n        for(int i=0;i++<8;){\n            p=.3-abs(p);\n            p.x<p.z?p=p.zyx:p;\n            p.z<p.y?p=p.xzy:p;\n            s*=e=1.7+sin(iTime*.001)*.1;\n            p=abs(p)*e-\n                vec3(\n                    5.+sin(iTime*.3+.5*sin(iTime*.3))*3.,\n                    120,\n                    8.+cos(iTime*.5)*5.\n                 )*d;\n         }\n         g+=e=length(p.yzzz)/s;\n    }\n}","name":"Image","description":"","type":"image"}]}