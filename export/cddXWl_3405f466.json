{"ver":"0.1","info":{"id":"cddXWl","date":"1682261822","viewed":325,"name":"The Crystal Plains","username":"Hyeve","description":"Mhm... There's a lack of.. visibility here, that I dislike, but it's done for now.","likes":17,"published":1,"flags":32,"usePreview":0,"tags":["3d","raymarching","transparency","reflections","crystal"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//See the common tab for fps control.\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = texture(iChannel0, fragCoord / iResolution.xy);\n}\n\n//why has the preview image not regenerated yet :(","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"float time; //Global time, usually modulo'd to loop ever few minutes\n\nstruct obj_data {\n\n    int skips; //Number of surfaces to skip rendering after initial hit (for transparent objects)\n\n    float refraction; //Index of refraction for transparent objects - set negative to do reflection\n    float alpha; //Alpha of the object. 1 = opaque / matt, 0 = invisible / perfect mirror\n\n    vec3 color; //Base colour for the object\n    \n    vec3 glow; //Glow accumulated over all objects\n    \n    vec3 normals; //Normal rotation to create normal mapped effects\n    \n    vec4 lighting; //Light position & ambient brightness\n    \n    vec2 subsurf; //Subsurface distance and intensity\n    \n    vec4 specular; //Specular highlights & fresnel\n    \n    vec2 occlusion; //AO / Shadow intensity\n    \n    vec4 tone_huesat; //Tonemapping hue/sat data\n    \n    vec4 tone_value; //Tonemapping value data\n}\n\n\nobj = obj_data(\n    1, //Skips (Skip once)\n    1.0, //Refraction (None)\n    1.0, //Alpha (Opaque)\n    vec3(1), //Color (White)\n    vec3(0), //Glow (None)\n    vec3(0), //Normal Offset (None)\n    vec4(0,0,-100,0.), //Lighting data (Position 0, 0, -100, Ambient 0)\n    vec2(1.5,0.), //Subsurf (1.5 distance, 0 intensity)\n    vec4(1,3,0,0), //Specular data (Intensity 1, Sharpness 3, No AO, No Shadows)\n    vec2(0,0),\n    vec4(1.,0.,1.,0.), //Tonemap hue/sat data (No hue shift, no sat shift)\n    vec4(1.,1.,0.,999.) //Tonemap value data (Full contrast, Full brightness, No boost, No quantization)\n    ); //Default object properties\n\n\nfloat crys(vec3 pos, float seed, float iters, float scale) {\n\n    vec3 pos_a = pos;\n\n    obj.glow += exp(-length(pos) * 1.5) * vec3(0.5,0.2,0.5);\n\n    for(float i = 0.; i < iters; i++) {\n    \n        pos.y = abs(pos.y)-1. * scale;\n        pos = rotate(pos, vec3(0.5+i,0.+i,0.75-i) + seed);\n        pos.z = abs(pos.z)-1. * scale;\n        pos.x += i;\n        pos.x -= i;\n    }\n    pos.y = abs(pos.y)-1.;\n    pos = rotate(pos, vec3(0.75,0.,0.75));\n    \n    return sdf_box(pos, vec3(1. * scale));    \n}\n\n//Complete scene SDF. Also sets object data\nfloat scene(vec3 pos)\n{\t\t\n    \n    pos.y -= pow(max(pos.z,0.)*0.1,2.)*0.2;\n    \n    vec3 orig_pos = pos;\n\n    pos.z += time;\n    \n    float ground = pos.y + 5. - pow(abs(pos.x), 1.9)*0.005;\n    \n    float triwave = wave_tri(pos.x*0.5+pos.z*0.5+time*0.1) + wave_tri(pos.x*0.4-pos.z*0.5) + wave_tri(pos.z*0.3-time*0.1) + wave_tri(pos.x*0.4-time*0.1);\n    float coltri = (wave_tri(pos.x*0.1+pos.z*0.2+time*0.5) + wave_tri(pos.x*0.2-pos.z*0.1-time*0.5))*0.5+0.5;\n    vec3 color = mix(vec3(0.4, 0.9, 1.0), vec3(1.0, 0.5, 0.8), coltri); \n    ground += (triwave*0.4);\n    \n    float scene_dist = ground;\n    \n    pos = orig_pos;\n\n   \n    \n    //pos = rotate(pos, vec3(0.2*time,0.1*time,0.3*time));   \n    \n    pos += vec3(0.,0.,-20.);\n    pos.x = abs(pos.x) - 40.;\n    pos.z+=time;\n    pos.z = repeat_inf(pos.z, 40.);\n    \n\n    float crys_base = crys(pos, 8., 5., 3.);\n    float spike_size = 16. - pos.y*0.8; \n\n   \n  \n    float spike_base = sdf_box(pos, vec3(spike_size, 20., spike_size));\n    \n    obj.glow += exp(-length(pos-vec3(0,10,0))) * 5. * color;\n    \n    //float spike_base = sdf_box(pos, vec3(2.));\n    \n    float spire = abs(mix(spike_base, crys_base, 0.3))-0.001;\n    \n    \n    \n    obj.glow += exp(-spire * 0.1) * color * 0.003;\n    \n    scene_dist = min(scene_dist, spire * 0.5);\n    \n    pos = orig_pos;\n    float xid = floor(pos.x / 20.);\n    pos.x += 10.;\n    pos.x = repeat_inf(pos.x, 20.);\n    pos.y += 5. - length(orig_pos.x)*0.05;\n    pos.z += time;\n    float zid = floor((pos.z-7.) / 30.);\n    pos.z = repeat_inf(pos.z, 15.);\n    float shash = hash11(xid*0.123+zid*0.623);\n    float shape = noise(zid+xid+0.5489123) < -0.1 ? abs(sdf_box(pos, vec3(10)))+1. : abs(crys(pos, 5.+xid+zid*50., shash > 0.1 ? 1. : 2., 2.)) - 0.001;\n\n    scene_dist = min(scene_dist, shape);\n    \n    \n    //Update object data\n    \n    obj.refraction = scene_dist == ground ? -1. : 1.1;\n   \n    obj.color = color;\n        \n    obj.alpha = scene_dist == ground ? 0.9 : 0.4;\n        \n    obj.specular = vec4(0.5,3.,0.,0.);\n        \n    obj.occlusion = vec2(0.5, 0.);\n        \n    obj.normals = vec3(0,0,0);\n        \n    obj.lighting = vec4(000, 400, 600, 0.);\n        \n    obj.subsurf = vec2(1.5,1.);\n        \n    obj.skips = 1;\n        \n    obj.tone_value = vec4(0.3,0.8,0.2, 999);\n        \n    obj.tone_huesat = vec4(3., 0.1, 2.5, 0.6);\n\n\treturn scene_dist;\n}\n\n//Calculates the normal for any position (Usually the hit/intersection/surface position)\nvec3 calc_normal(vec3 pos) {\n    mat3 k = mat3(pos, pos, pos) - mat3(.001);\n    return normalize(scene(pos) - vec3(scene(k[0]), scene(k[1]), scene(k[2])));\n}\n\n\n//Raymarches the scene and computes:\n//X - Distance raymarched\n//Y - Min surface distance detected\nvec2 raymarch(vec3 ray_origin, vec3 ray_dir, float surf_dist, float max_dist, int max_steps) {\n    float current_dist = 0.;\n    float min_dist = max_dist;\n    float scene_dist = 0.;\n    \n    for(int i = 0; i < max_steps; i++) {\n        scene_dist = scene(ray_origin + ray_dir * current_dist);\n        current_dist += scene_dist;\n        \n        if(scene_dist < min_dist && current_dist < max_dist) min_dist = scene_dist;\n        if(scene_dist < surf_dist || scene_dist > max_dist) break;\n    }\n    \n    return vec2(current_dist, min_dist);\n}\n  \n \nvec4 calc_color(obj_data hit, vec3 hit_pos, vec3 hit_norm, vec3 adj_norm, vec3 ray_dir, vec2 uv, float total_dist, bool is_bg)\n{\n\n    vec3 background_col = vec3(0.494,0.725,0.980) + pow(length(uv.xy)*1.1,8.) * 0.5;\n    vec3 background_reflected = vec3(0.494,0.725,0.980) + pow(length(ray_dir.xy)*1.4,8.);\n    \n    background_col *= max(max(background_col.r,max(background_col.g,background_col.b)),1.);\n    \n    //Color is defaulted to background\n    vec4 color = vec4(background_reflected, 1.);\n\n  \n    if(is_bg) {\n        //background_col += hit.glow;\n        return vec4(background_col, 1.);\n    }\n  \n\n    color.a = hit.alpha;\n   \n   \n    //Basic point light\n    vec3 light_dir = normalize(hit_pos - hit.lighting.xyz);\n    float diffuse = max(dot(adj_norm, -light_dir), hit.lighting.w);\n          \n    //Subsurface lighting - NOT ALWAYS CORRECT ON TRANSPARENT / ONIONED OBJECTS\n    if(hit.subsurf.x > 0.) {\n        float subsurf = min(scene(hit_pos - light_dir * hit.subsurf.x) / hit.subsurf.x, hit.subsurf.y);\n        diffuse = max(diffuse, subsurf);\n    }\n\n\n      \n    //Custom specular lighting based on a cross product\n    vec3 light_cross = cross(ray_dir + light_dir, adj_norm); \n    float specular = pow(max(1. - length(light_cross), 0.), hit.specular.y) * hit.specular.x;\n    \n    //Fresnel factor\n    float fresnel = max(pow(1. - abs(dot(ray_dir, -adj_norm)), 3.), 1e-4);\n    //fresnel = min(fresnel, 1. - subsurf);\n\n    \n    //Fog factor\n    float fog = exp( -pow(0.01 * total_dist, 5.));\n    \n    //Occlusion factor\n    float occlusion = 0.;\n    \n    \n    if(hit.occlusion.x > 0.) {\n        //Calculate AO\n        float dist = raymarch(hit_pos + hit_norm * 0.005, hit_norm, 1e-3, 24., 12).x;            \n        occlusion += (1. - pow(clamp(dist / 24., 0., 1.), 0.1)) * hit.occlusion.x;\n    }\n    \n    \n    if(hit.occlusion.y > 0.) {\n        //Calculate shadows\n    \n        float dist = raymarch(hit_pos + hit_norm * 0.05, -light_dir, 1e-3, 64., 128).y;\n        dist /= 0.05;\n        occlusion += max(pow(1. - clamp(dist, 0., 1.), 1.5), 0.) * hit.occlusion.y;\n    }\n\n    \n    //Darken value by occlusion\n    hit.tone_value.y -= occlusion;\n    \n    //Base color = object color + some fresnel highlight\n    vec3 base_col = mix(hit.color, color.rgb, fresnel);\n    \n    //Base value = diffuse mixed towards background based on fresnel, maxed to ambient brightness\n    float base_value = max(mix(diffuse, luma(background_col), fresnel), hit.lighting.w);\n    \n    //Tonemap & handle specular\n    color.rgb = recolor(vec4(base_col, base_value), hit.tone_huesat, hit.tone_value + specular * max(1. - occlusion, 0.));\n    \n    //Add glow\n    color.rgb += hit.glow;\n    \n    //Expand any HDR values\n    color.rgb *= max(max(color.r, max(color.g, color.b)), 1.);\n    \n    //Mix towards background for fogging\n    color.rgb = mix(background_col, color.rgb, fog); \n    \n    return color;\n}\n\n\n\nvec4 render(vec2 frag, vec2 res, float real_time)\n{\n  \n    vec2 uv = (frag.xy - .5 * res.xy) / res.y; //0,0 Centred and square aspect ratio UV coords\n    time = mod(real_time, 100.); //Set global time\n    \n   \n    //Setup camera\n    vec3 ray_origin = vec3(0,0,-10);\n    vec3 ray_dir = normalize(vec3(uv, 1));\n    \n    \n    //Setup variables\n    int skip_count = 0;\n    float total_dist = 0.;\n    vec4 final_color = vec4(0);\n    \n    //Transparency / Reflection iterations\n    for(int i = 0; i < 12; i++)\n    {\n\t  \t//Raymarch surface\n        float dist = raymarch(ray_origin, ray_dir, 1e-4, 128., 512).x;\n        vec3 hit_pos = ray_origin + ray_dir * dist;\n        total_dist += dist;\n        \n        obj_data hit = obj;\n        \n        //Calc normals\n        vec3 norm = calc_normal(hit_pos);\n        vec3 adj_norm = rotate(norm, hit.normals);\n        adj_norm = dot(adj_norm, -ray_dir) > 0. ? adj_norm : reflect(adj_norm, ray_dir);\n        \n        \n        //Attempt to refract or reflect\n        float refraction = i % 2 == 0 ? 1. / hit.refraction : hit.refraction;\n        vec3 new_ray = refract(ray_dir, adj_norm, refraction);\n        if(hit.refraction < 0. || length(new_ray) == 0.) new_ray = reflect(ray_dir, adj_norm);\n       \n        //Calculate surface color\n        vec4 color = calc_color(hit, hit_pos, norm, adj_norm, ray_dir, uv,  total_dist, dist > 128.);\n        \n        //Update ray\n        ray_origin = hit_pos - norm * (hit.refraction < 0. ? -0.01 : 0.01 );\n        ray_dir=new_ray;\n    \n        //Alpha blend if not skipping this surface\n\t  \tif(skip_count < 1) final_color += vec4(color.rgb * color.a, color.a) * (1. - final_color.a);\n\t  \tif(final_color.a >= 1.) break;\n        \n        //Reset or decrement skip count if needed\n        skip_count = skip_count == 0 ? hit.refraction < 0. ? 0 : hit.skips : skip_count - 1;\n    }\n    \n    \n    final_color /= final_color.a; //Fix any < 1. alphas\n\t  \n    final_color *= 1. - pow(length(uv), 5.) * 0.8; //Global vignette \n    \n    return pow(final_color, vec4(0.9)); //Slight gamma correction\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //Artifical FPS limiter\n    if(mod(float(iFrame), 60. / FPS) < 1. || iFrame < 5)\n        fragColor = render(fragCoord.xy,iResolution.xy,iTime);\n    else\n        fragColor = texture(iChannel0, fragCoord / iResolution.xy);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"//fps control for performance. Assumes the refresh rate of your monitor is 60hz\n//(120hz monitor set to 30 here will actually run at 60fps)\n#define FPS 30.\n\n\n\n\n//Consts\n\n#define pi 3.1415926535\n#define degs_to_rads 0.01745329\n\n\n\n//\"Generic\" functions\n\n//Rotation matrix for an angle in radians\n#define angle(a) mat2(cos(a), sin(a), -sin(a), cos(a))\n\n//Min by X component - for combined distance/ID sdfs\n#define vector_min(a, b) (a.x < b.x ? a : b)\n\n//Splits a value into hard-edge segments. B = steps per 1 unit\n#define quantize(value, steps) (floor((value)*(steps))/(steps))\n\n//Repeats a range with a given spacing a particular number of times\n#define repeat(value, space, min, max) (value - space*clamp(round(value / space), -min, max))\n\n//Repeats a range with a given spacing an infinite number of times\n#define repeat_inf(value, space) (value - space*round(value / space))\n\n//Maths\nfloat hash11(float value) {\n    return fract(sin((value) * 12.9898) * 43758.5453123);\n}\n\n//Two hashes smoothed together\nfloat noise(float value) {\n    float i = floor(value), f = fract(value);\n    return mix(hash11(i) * f, hash11(i + 1.) * (f - 1.),f * f * (3. - 2. * f));\n}\n\n//\"Sharpens\" a 0-1 value by powing both ends\nfloat sharpen(float value, float scale) {\n    return 1.-pow(1.-pow(value, scale), scale * 2.);\n}\n\nfloat fbm_sine(float pos, float intensity, int iters, float offset)\n{    \n    vec2 g = vec2(2, exp2(-intensity));\n\tvec3 f = vec3(1, 1, 0);\n\tpos -= offset * .5;\n    for(int i = 0; i < iters; i++) {\n        f = vec3(f.xy * g, f.z + f.y * sin(f.x * pos + offset));\n    }\n    return f.z;\n}\n\nfloat wave_saw(float value) {\n    return mod(value, 2.);\n}\n\n//Is this a good way to calculate a triangle wave? No idea, but it works, so...\nfloat wave_tri(float value) {\n    return wave_saw(value*sign(mod(value, 2.)-1.)) - 1.5; \n}\n\n\nvec3 rotate(vec3 a, vec3 r) {\n    a.zy *= angle(r.x);\n    a.xz *= angle(r.y);\n    a.yx *= angle(r.z);\n    return a;\n}\n\n\nvec3 rgb_to_hsv(vec3 col) {\n    vec4 k = vec4(0., -1./3., 2./3., -1.),\n    p = mix(vec4(col.bg, k.wz), vec4(col.gb, k.xy), step(col.b, col.g)),\n    q = mix(vec4(p.xyw, col.r), vec4(col.r, p.yzx), step(p.x, col.r));\n    \n    float d = q.x - min(q.w, q.y);\n    \n    return vec3(abs(q.z + (q.w - q.y) / (6. * d)), d / (q.x), q.x);\n}\n\n\nvec3 hsv_to_rgb(vec3 col) {\n    vec4 k = vec4(1., 2./3., 1./3., 3.);\n    vec3 p = abs(fract(col.xxx + k.xyz) * 6. - k.www);\n    return col.z * mix(k.xxx, clamp(p - k.xxx, 0., 1.), col.y);\n}\n\nfloat luma(vec3 col) {\n    return col.r * 0.2126 + col.g * 0.7152 + col.b * 0.0722;\n}\n\nvec2 to_radial(vec2 xy) {\n    return vec2(length(xy), atan(xy.x,xy.y));\n}\n\nvec2 from_radial(vec2 ra) {\n    return vec2(sin(ra.y), cos(ra.y)) * ra.x;\n}\n\n\n//My tonemapping function. Does a pass through HSV and back to adjust hue, sat, & value\n\n//Hue/Sat params:\n//XY = Hue shift by value, X = exponent, Y = strength\n//ZW = Sat shift by value, Z = exponent, W = strength\n\n//Value params:\n//X = Contrast (value exponent)\n//Y = Intensity (value multiplier)\n//Z = Brightness (value gain)\n//W = Quantization (Number of colour steps)\n\nvec3 recolor(vec4 base, vec4 hs_params, vec4 v_params) {\n\n  vec3 r = rgb_to_hsv(base.rgb);\n  \n  r.z=quantize(pow(max(base.w*r.z+v_params.z,0.),v_params.x)*v_params.y,v_params.w);\n  \n  r.x+=pow(1.-min(r.z*0.5,1.),hs_params.x)*hs_params.y*(r.x>.19&&r.x<.69?1.:-1.);\n  \n  r.y+=pow(1.-min(r.z*0.5,1.),hs_params.z)*hs_params.w;r.y*=2.-r.z;\n  \n  return hsv_to_rgb(r);\n  \n  \n}\n\nvec3 bezier(vec3 a, vec3 b, vec3 c, float v) {\n    return mix(mix(a, b, v), mix(b, c, v), v);\n}\n\nvec3 bezier(vec3 a, vec3 b, vec3 c, vec3 d, float v) {\n    return mix(bezier(a, b, c, v),bezier(b, c, d, v), v);\n}\n\nvec3 bezier(vec3 a, vec3 b, vec3 c, vec3 d, vec3 e, float v) {\n    return mix(bezier(a, b, c, d, v),bezier(b, c, d, e, v), v);\n}\n\nfloat bezier(float a, float b, float c, float v) {\n    return mix(mix(a, b, v), mix(b, c, v), v);\n}\n\nfloat bezier(float a, float b, float c, float d, float v) {\n    return mix(bezier(a, b, c, v),bezier(b, c, d, v), v);\n}\n\nfloat bezier(float a, float b, float c, float d, float e, float v) {\n    return mix(bezier(a, b, c, d, v),bezier(b, c, d, e, v), v);\n}\n\n\n//Custom refraction that ignores total internal reflection\n//Not at all physically realistic, but looks better for shaders.\nvec3 refract_abs(vec3 incident, vec3 normal, float refraction) {\n   float ndi = dot(normal, incident);\n   float k = 1. - pow(refraction, 2.) * (1. - pow(ndi,2.));\n   k = max(abs(k),1e-4);  //Negative K would be TIR\n   return refraction * incident - (refraction * ndi + sqrt(k)) * normal;\n}\n\n\n//Quantization with a smoothed boundary between values.\nfloat smooth_quantize(float value, float steps, float smoothing, float sharpness) {\n    float l = floor(value * steps) / steps,\n    h = ceil(value * steps) / steps, \n    s = (h - l),\n    m = l + s * .5;\n    return mix(l, h, pow(smoothstep(m - smoothing * s,m + smoothing * s, value), sharpness));\n}\n\nvec3 smooth_quantize(vec3 value, float steps, float smoothing, float sharpness) {\n    vec3 l = floor(value * steps) / steps,\n    h = ceil(value * steps) / steps, \n    s = (h - l),\n    m = l + s * .5;\n    return mix(l, h, pow(smoothstep(m - smoothing * s,m + smoothing * s, value), vec3(sharpness)));\n}\n\n\n//Clamps a 0-1 range around..?\nfloat snip(float v, float w, float a) {\n    return clamp(v - (a - w / 2.), 0., w) * (1. / w);\n}\n\n\n\n//SDF Maths\n\n//IQ's smooth min for SDFs\nfloat smooth_min(float a, float b, float smoothing) {\n    float h = clamp(.5 + .5 * (b - a) / smoothing, 0., 1.);\n    return mix(b, a, h) - smoothing * h * (1. - h);\n}\n\n\n//Range dividing for better and more dynamic domain repetition\nvec2 divide(vec2 range, float pos, float axis, inout float id) {\n    float z = range.x + range.y * pos;\n    if(z < axis) {\n        range.y = range.x + range.y - z;\n        range.x = z;\n        id += 1.;\n    }\n    else {\n        range.y = z - range.x;\n        id *= 1.5;\n    }\n    \n    return range;\n}\n\n//Generates a sharp impulse designed for use as a normal offset to create an indent/bump line\nfloat normal_edge(vec2 vs, vec2 mm) {\n    return mix(mix(mm.x, mm.y, smoothstep(.5 - vs.y, .5 + vs.y, vs.x)),0., abs(vs.x - .5) * 2.);\n}\n\n\n\n//3D Shapes\n\nfloat sdf_box(vec3 pos, vec3 size) {\n    vec3 q = abs(pos) - size;\n    return min(max(q.x, max(q.y, q.z)), 0.) + length(max(q, 0.));\n}\n\nfloat sdf_cylinder(vec3 pos, vec2 size) {\n    vec2 w = vec2(length(pos.xy) - size.x, abs(pos.z) - size.y);\n    return min(max(w.x, w.y), 0.) + length(max(w, 0.));\n}\n\nfloat sdf_torus(vec3 pos, vec2 size) {\n    return length(vec2(length(pos.xz) - size.x, pos.y)) - size.y;\n}\n\nfloat sdf_gyroid(vec3 pos, vec3 size) {\n    return abs(dot(sin(pos * size.x), cos((pos * size.y).zxy)) - size.z) / max(size.x, size.y) * 1.8;\n}\n\n\n//Params = offset for fbm A, offset for fbm B, and scaling\nfloat sdf_fluid(vec3 pos, vec3 params)\n{\n\tfloat v = pos.y;\n\tv -= fbm_sine(pos.z * .5, 1., 3, params.x)*params.z+.5;\n\tv -= fbm_sine(pos.x * .5, 1., 3, params.y)*params.z+.5;\n\treturn v;\n}\n\n\n//4D Shapes\n\nfloat sdf_hyper_cube(vec4 pos, vec4 size) {\n    vec4 q = abs(pos) - size;\n    return min(max(q.x, max(q.y, max(q.z, q.w))), 0.) + length(max(q, 0.));\n}\n\n\nfloat sdf_hyper_gyroid(vec4 pos, vec3 size) {\n    return abs(dot(sin(pos * size.x), cos((pos * size.y).zxyw)) - size.z) / max(size.x, size.y) * 1.8;\n}\n\n","name":"Common","description":"","type":"common"}]}