{"ver":"0.1","info":{"id":"tdKfRz","date":"1606473033","viewed":167,"name":"Nebulae","username":"AzazelN28","description":"Nebula","likes":12,"published":1,"flags":0,"usePreview":0,"tags":["raymarch","nebula"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Fork of \"Playing marble\" by guil. https://shadertoy.com/view/MtX3Ws\n// 2020-12-01 10:46\n\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// Created by S. Guillitte 2015\nfloat zoom = 1.;\n\n/*\nvec2 csqr( vec2 a ) {\n  return vec2( a.x * a.x - a.y * a.y, 2. * a.x * a.y  );\n}\n*/\n\nvec2 csqr( vec2 a ) {\n  return vec2(\n      a.x * a.x + a.y * a.y,\n      2. * a.x * a.y\n  );\n}\n\nmat2 rot(float a) {\n  return mat2(\n    cos(a),\n    sin(a),\n   -sin(a),\n    cos(a)\n  );\t\n}\n\nfloat sdSphere( vec3 p, float s ) //from iq\n{\n  return length(p) - s;\n}\n\nfloat map(in vec3 p) {\n  float res = 0.;\n    \n  vec3 c = p;\n  for (int i = 0; i < 10; ++i) {\n    p =.8 * abs(p) / dot(p,p) -.8;\n    p.yz = csqr(p.yz) + 0.02 * vec2(\n      cos(iTime * 0.081),\n      sin(iTime * 0.0331)\n    ); // Animate swirl\n    // p=p.zxy;\n    res += exp2(-29. * abs(dot(p, c)));\n  }\n  return res/2.;\n}\n\n\n\nvec3 raymarch( in vec3 ro, vec3 rd, float sRadius )\n{\n    \n    float t = sRadius;\n    // float dt = .02;\n    float dt = .2 - .111*sin(iTime*.1+20.);//animated\n    vec3 col= vec3(0.);\n    float c = 0.;\n    \n    for( int i=0; i<128; i++ )\n\t{\n        t += dt * exp2(-1. * c);\n        \n        vec3 pos = ro + t * rd;\n        \n        float r = sdSphere(pos, .5);\n        // c = map(ro+t*rd)*(1.1 - smoothstep(0.0,1.,r));\n        c = map(ro + t * rd); \n        \n        vec3 base_color = vec3(c, c * c, c * c * c);\n        col = .99 * col+ .08 * base_color;\n    }    \n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat time = iTime;\n    vec2 q = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * q;\n    p.x *= iResolution.x/iResolution.y;\n    vec2 m = vec2(0.);\n\tm = iMouse.xy/iResolution.xy*3.14;\n    //m-=.5;\n\n    // camera\n\n    vec3 ro = zoom*vec3(4.);\n    \n    ro.yz *= rot(m.y+ 0.013*time+30.);\n    ro.xz *= rot(m.x+ 0.02*time);\n    \n    vec3 ta = vec3( 0.0 , 0.0, 0.0 );\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    vec3 rd = normalize( p.x*uu + p.y*vv + 4.0*ww );\n    \n\t// raymarch\n    vec3 col = raymarch(ro,rd, 2.5);\n\n\t// shade\n    \n    // col =  .75 *(log(1.+col));\n    col = clamp(col,0.,1.);\n    fragColor = vec4( col, 1.0 );\n\n}\n","name":"Image","description":"","type":"image"}]}