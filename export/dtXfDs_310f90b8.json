{"ver":"0.1","info":{"id":"dtXfDs","date":"1693600206","viewed":96,"name":"simple integer noise","username":"twixuss","description":"that's it :)","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["noise","simple","random","integer","uint"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Change noise frequency with mouse x\n\n// Simple randomizer that works pretty well.\n// There is a cool property used to randomize the bits:\n\n// Suppose you have a sequence that contains all integers in range [0; 2**32)\n// If you multiply each number in this sequence by an odd number, you will get another\n// sequence. Because uint can hold only 32 bits of information, the overflowed bits will be discarded,\n// effectively performing a modulo by 2**32 automatically. The cool thing is that there is no duplicates\n// in the resulting sequence. In fact the integers it contains will be the same as in initial sequence,\n// just ordered differently.\n\n// You can do this multiple times to further shuffle the bits, just insert some\n// xor's with random number between multiplications.\n\n// Here I do 4 multiplications and 4 xors, which I find good enough. With less, noticeable patterns\n// appear more frequently. Try modifying this and seeing for yourself!\n\n// There's one minor problem with this noise: lower bits appear less random.\n// For example at first bit for every odd input number rand will always return an even one.\n// So don't generate random booleans with %2 using this :^)\n\nuint rand(uint x) {\n    const uint k = 3282017729u; // random odd number\n    x = x*k^k;\n    x = x*k^k;\n    x = x*k^k;\n    x = x*k^k;\n    return x;\n}\n\n// Linearly converts from uint in range [0;2**32) to float in range [0,1) by\n// directly setting mantissa bits.\nfloat u2f(uint x) {\n    x >>= 9;\n    //x &= 0x007fffffu;\n    x |= 0x3f800000u;\n    return uintBitsToFloat(x) - 1.0;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float scaleFactor = pow(2.0, iMouse.x/iResolution.x*11.0) * 0.1;\n    fragCoord *= scaleFactor;\n    \n    if (fragCoord.y > 65536. || fragCoord.x > 65536.) {\n        fragColor = vec4(1,0,1,0);\n        return;\n    }\n    \n    uint x = uint(fragCoord.y) * 65536u + uint(fragCoord.x);\n    \n    x = rand(x);\n    \n    fragColor = vec4(u2f(x));\n}\n","name":"Image","description":"","type":"image"}]}