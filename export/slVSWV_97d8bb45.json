{"ver":"0.1","info":{"id":"slVSWV","date":"1641394073","viewed":101,"name":"Implicit curves rasterization 2","username":"Envy24","description":"Solution for problem in this shader: https://www.shadertoy.com/view/slVXWV\n\nOther solutions:\nhttps://www.shadertoy.com/view/7lVXDK\nhttps://www.shadertoy.com/view/stKXWc","likes":1,"published":1,"flags":32,"usePreview":0,"tags":["curves","function","plot","implicit","rasterization"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define R                       iResolution\n#define AR                    ( R.x / R.y )                      // Aspect ratio (AR > 1.0).\n#define TEX0(x)               ( texture(iChannel0, x) )\n#define TEX_COORDS(SC)        ( (SC) / (R.xy) )                  // in range x=[0.0; 1.0], y=[0.0; 1.0]\n#define NMY                   ( iMouse.y / R.y )                 // in range [0.0; 1.0]\n#define LMB_IS_HOLD           ( iMouse.z > 0.0 )\n\n/* \n    Compares signs of floats.\n    \n    Returns:\n        0 if floats have same signs;\n        1 if floats have different signs.\n*/\nbool compareSignsNE(float l, float r)\n{\n    l = l >= 0.0 ? 1.0 : -1.0;\n    r = r >= 0.0 ? 1.0 : -1.0;\n    \n    return l != r;\n    //OR return sign(l) != sign(r);\n}\n\n/* NO AA *\nvoid mainImage( out vec4 O, in vec2 SC )\n{\n    float CENTER = TEX0(TEX_COORDS(SC)).r;\n    float RIGHT  = TEX0(TEX_COORDS(SC + vec2(1.0, 0.0))).r;\n    float LEFT   = TEX0(TEX_COORDS(SC + vec2(-1.0, 0.0))).r;\n    float TOP    = TEX0(TEX_COORDS(SC + vec2(0.0, 1.0))).r;\n    float BOTTOM = TEX0(TEX_COORDS(SC + vec2(0.0, -1.0))).r;\n\n    bool isVisible = \n        compareSignsNE(CENTER, RIGHT) ||\n        compareSignsNE(CENTER, LEFT) ||\n        compareSignsNE(CENTER, TOP) ||\n        compareSignsNE(CENTER, BOTTOM);\n\n    // Only 2 quantization levels.\n\n    O = vec4(!isVisible);\n}\n/**/\n\n/* WITH AA *\nvoid mainImage( out vec4 O, in vec2 SC )\n{\n    float CENTER = TEX0(TEX_COORDS(SC)).r;\n    float RIGHT  = TEX0(TEX_COORDS(SC + vec2(1.0, 0.0))).r;\n    float LEFT   = TEX0(TEX_COORDS(SC + vec2(-1.0, 0.0))).r;\n    float TOP    = TEX0(TEX_COORDS(SC + vec2(0.0, 1.0))).r;\n    float BOTTOM = TEX0(TEX_COORDS(SC + vec2(0.0, -1.0))).r;\n    float TR     = TEX0(TEX_COORDS(SC + vec2(1.0, 1.0))).r;\n    float TL     = TEX0(TEX_COORDS(SC + vec2(-1.0, 1.0))).r;\n    float BR     = TEX0(TEX_COORDS(SC + vec2(1.0, -1.0))).r;\n    float BL     = TEX0(TEX_COORDS(SC + vec2(-1.0, -1.0))).r;\n\n    int count = \n        int(compareSignsNE(CENTER, RIGHT)) +\n        int(compareSignsNE(CENTER, LEFT)) +\n        int(compareSignsNE(CENTER, TOP)) +\n        int(compareSignsNE(CENTER, BOTTOM)) + \n        int(compareSignsNE(CENTER, TR)) + \n        int(compareSignsNE(CENTER, TL)) + \n        int(compareSignsNE(CENTER, BR)) +\n        int(compareSignsNE(CENTER, BL));\n        \n    // Only 8 quantization levels (more neighbors, more quantization levels - better anti-aliasing).\n\n    float intensity = \n        count != 0 ?\n            smoothstep(0.0, 1.4, 1.0 - float(count) * (0.125 + 0.05)) :\n            1.0;\n            \n    O = vec4(intensity, intensity, intensity, 1.0);\n}\n/**/\n\n/* WITH better AA */\nvoid mainImage( out vec4 O, in vec2 SC )\n{\n    float CENTER = TEX0(TEX_COORDS(SC)).r;\n\n    int count = -1;    // -1 because compareSignsNE(CENTER, TEX0(TEX_COORDS(SC + vec2(0.0, 0.0))).r) always true.\n    float order = 4.0;\n    float max_count = (order+1.)*(order+1.);\n    float thickness = 0.3;\n\n    for (float y = -order; y <= order; y += 1.0)\n    {\n        for (float x = -order; x <= order; x += 1.0)\n        {\n            count += \n                int(compareSignsNE(\n                    CENTER,\n                    TEX0(TEX_COORDS(SC + vec2(x, y) * thickness)).r));\n        }\n    }\n  \n    float intensity = smoothstep(max_count, 0., float(count)/2.0);  \n    vec3 color = mix(vec3(1), vec3(0), 1.-intensity);\n\n    O = vec4(color, 1.0);\n}\n/**/","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"float dsm_rpow(float x, float y) {\n    if (x >= 0.0) return pow(x,y);\n    else {\n        float m = mod(y, 2.0);\n        if (m == 0.0) return pow(-x, y);\n        else if (m == 1.0) return -pow(-x, y);\n        else return pow(x, y);\n    }    \n}\n\nfloat glesmos_f0(float x, float y) { return (((((0.8)*(dsm_rpow((tanh(((1.4)*(sin(((5.0)*(sqrt(((dsm_rpow(x,(2.0)))+(dsm_rpow(y,(2.0)))))))))))),(4.0))))+(dsm_rpow((sin(((atan(y,x))+((2.0)*(sqrt(((dsm_rpow(x,(2.0)))+(dsm_rpow(y,(2.0)))))))))),(2.0))))-(0.7))+((0.1)/((dsm_rpow(x,(2.0)))+(dsm_rpow(y,(2.0))))));}\n\n\nfloat f(float x, float y)\n{\n    return glesmos_f0(x, y);\n}\n\n/* xRange=[-1.0; 1.0] yRange=[-1.0; 1.0] */\nfloat unit_circle( float x, float y )\n{\n    return x*x + y*y - 1.0;\n}\n\n/* source: https://www.desmos.com/calculator/pi5ofejgt0?lang=ru\n   xRange=[-2.0; 2.0] yRange=[-2.0; 2.0]    */\nfloat heart_curve(float x, float y)\n{\n    float term = x*x + y*y - 1.0;\n    return term * term * term - x*x * y*y*y;\n}\n\n/* xRange=[-1.5; 1.5] yRange=[-1.5; 2.0] */\nfloat heart_curve2(float x, float y)\n{\n    float term = y - pow(x * x, 1.0 / 3.0);\n    return x * x + term * term - 1.0;\n}\n\n/* source: https://mathworld.wolfram.com/DevilsCurve.html\n   xRange=[-2.0; 2.0] yRange=[-2.0; 2.0]     */\nfloat devil_curve(float x, float y)\n{\n    return y * y * (y * y - 1.0) - x * x * (x * x - 2.0);\n}\n\n/* source: https://mathworld.wolfram.com/DevilsCurve.html \n   xRange=[-12.5; 12.5] yRange=[-12.5; 12.5]     */\nfloat electric_motor_curve(float x, float y)\n{\n    return y * y * (y * y - 100.0) - x * x * (x * x - 96.0);\n}\n\n/* xRange=[-2.0; 2.0] yRange=[-2.0; 2.0] */\nfloat random_curve_0000(float x, float y)\n{\n    return sin(x*x + y*y)-y*y;\n}\n\n/* xRange=[-4.0; 4.0] yRange=[-4.0; 4.0] */\nfloat random_curve_0001(float x, float y)\n{\n    float xx = x * x;\n\n    return xx * sin(xx + xx) - y*y;\n}\n\n/* xRange=[-2.0; 2.0] yRange=[-2.0; 2.0] */\nfloat random_curve_0002(float x, float y)\n{\n    return x * x * sin(32.0 * (x - y)) * tan(x + y) - y * y * y;\n}\n\n/* source: https://www.desmos.com/calculator/pi5ofejgt0?lang=ru\n   xRange=[-40.0; 40.0] yRange=[-40.0; 40.0]    */\nfloat random_curve_0003(float x, float y)\n{\n    return x * x * x + y * y - 6.0 * x * y;\n}\n\n/* xRange=[-10.0; 10.0] yRange=[-10.0; 10.0] */\nfloat random_curve_0004(float x, float y)\n{\n    return sin(0.5 * (x*x - y*y)) + cos(0.5 * (y*y - x*x));\n}\n\n/* xRange=[-10.0; 10.0] yRange=[-10.0; 10.0] */\nfloat random_curve_0005(float x, float y)\n{\n    return (x*x - y*y*y) -(y*y - x*x*x)*(y*y - x*x*x);\n}","name":"Common","description":"","type":"common"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define R                       iResolution\n#define AR                    ( R.x / R.y )                      // Aspect ratio (AR > 1.0).\n#define NZMY                  ( (iMouse.y+iMouse.y-R.y) / R.y )  // in range [-1.0; 1.0]\n#define LMB_IS_HOLD           ( iMouse.z > 0.0 )\n\n#define XMIN     -4.0\n#define XMAX     4.0\n#define YMIN     -4.0\n#define YMAX     4.0\n\n//#define FUNCTION unit_circle          \n//#define FUNCTION heart_curve\n//#define FUNCTION heart_curve2\n//#define FUNCTION devil_curve\n//#define FUNCTION electric_motor_curve\n#define FUNCTION f\n\n//#define FUNCTION random_curve_0001\n\nvoid mainImage( out vec4 O, in vec2 SC )\n{\n    float xStep = (XMAX - XMIN) / (R.x - 1.0);\n    float yStep = (YMAX - YMIN) / (R.y - 1.0);\n\n    float modulation = \n        LMB_IS_HOLD == true ?\n            NZMY :\n            0.0;\n    \n    float dist = \n        modulation + FUNCTION(\n            (XMIN + floor(SC.x) * xStep) * AR,\n            YMIN + floor(SC.y) * yStep);\n\n    O = vec4(dist);\n    //O = vec4(fract(dist)-0.5);\n}","name":"Buffer A","description":"","type":"buffer"}]}