{"ver":"0.1","info":{"id":"DstBWX","date":"1697702274","viewed":131,"name":"Flow field experiment","username":"sinnwrig","description":"Forked from davidar's Wind flow map shader found here: https://www.shadertoy.com/view/4sKBz3\nCompressed to use a single buffer instead of three- ends up using 9 more redundant hashes because of it.\nAdded comments to try to explain the process.","likes":13,"published":1,"flags":32,"usePreview":1,"tags":["map","flow","field","vector","wind","streamline"],"hasliked":0,"parentid":"4sKBz3","parentname":"Wind flow map"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage(out vec4 fragColor, in vec2 fragCoord) \n{\n    vec3 fade = texture(iChannel0, fragCoord / iResolution.xy).xyz;\n    fragColor.xyz = mix(vec3(0.9), vec3(0.05), fade.z);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Original shader by davidar at https://www.shadertoy.com/view/4sKBz3\n// Modified to use a single buffer and simplex noise\n// WebGL version at https://sinnwrig.github.io\n\n// Particle distribution\n#define DISTRIBUTION 0.0006\n// Global particle density\n#define DENSITY 0.008\n\n// u/s at which trails fade\n#define FADE_POW 2.0\n// Noise sample scale\n#define NOISE_SCALE 2.0\n\n// Particle size - Larger size will make particles coagulate, smaller size causes particles to dissapear.\n#define PART_SIZE 0.5\n#define SPEED 1.0\n\n// Use a square distance check for particles. Gives a rounder look at larger particle sizes\n//#define SQR_DIST\n\n\n\nvec2 getFlow(vec2 position)\n{\n    // Height determines scale;\n    position /= iResolution.y;\n\n    return normalNoise(position, NOISE_SCALE, 354.459).xy * 0.3;\n}\n\n\nfloat rand(vec2 p)\n{ \n    // After around ten million frames hash starts to break down, so mod it back.\n    float frameMod = mod(float(iFrame), 1000000.0);\n\n    return hash13(vec3(p, frameMod));\n}\n\n\n\n// Returns the position of a particle in the pixel, and 0 if there are none\nvec2 sampleParticle(vec2 fragCoord) \n{\n    // Kill random pixels to lower global density\n    if (rand(fragCoord) < DENSITY) \n        return vec2(0);\n        \n    // Kernel needs to be big enough to handle particles that shift more than one unit\n    const int kernSize = int(ceil(SPEED));\n\n    // Sample neighboring pixels to check if this pixel will have a particle in it\n    for (int x = -kernSize; x <= kernSize; x++) \n    {\n        for (int y = -kernSize; y <= kernSize; y++) \n        {\n            // Get UV coordinates with offset\n            vec2 offsetCoords = fragCoord + vec2(x, y);\n            vec2 uv = offsetCoords / iResolution.xy;\n\n            // Sample particle buffer\n            vec2 fragment = texture(iChannel0, uv).xy;\n\n            // Is the particle uninitialized?\n            if (fragment == vec2(0))\n            {\n                // Probability of initializing\n                if (rand(uv) < DISTRIBUTION) \n                {\n                    fragment = offsetCoords; // Initialize particle at position \n                }\n                else \n                {\n                    continue; // Don't initialize particle- skip iteration\n                }\n            }\n\n            // Move particle with flow\n            fragment += getFlow(offsetCoords) * SPEED;\n\n        #ifdef SQR_DIST\n            // Square distance check gives rounder particles at larger sizes\n            vec2 vec = fragment.xy - fragCoord.xy;\n            float distSqr = dot(vec, vec);\n                \n            // If the particle is close enough to pixel, use it\n            if (distSqr < PART_SIZE * PART_SIZE)\n            {\n                return fragment;\n            }\n        #else\n            // Original rectangle distance check\n            // If the particle is close enough to pixel, use it\n            if (abs(fragment.x - fragCoord.x) < PART_SIZE && abs(fragment.y - fragCoord.y) < PART_SIZE) \n            {\n                return fragment;\n            }\n        #endif\n        }\n    }\n\n    // No particle nearby\n    return vec2(0);\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) \n{\n    vec2 particle = sampleParticle(fragCoord);\n    \n    float fade = texture(iChannel0, fragCoord / iResolution.xy).z;\n    fade -= (FADE_POW * iTimeDelta);\n\n    fragColor.xyz = vec3(particle, fade);\n\n    // If there is a particle, reset fade\n    if (particle != vec2(0.0))\n    {\n        fragColor.z = 1.0;\n    }\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"// Hash without Sine\n// Original at https://www.shadertoy.com/view/4djSRW\n// Creative Commons Attribution-ShareAlike 4.0 International Public License\n// Created by David Hoskins.\n\n//  1 out, 3 in...\nfloat hash13(vec3 p3)\n{\n    p3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//  2 out, 1 in...\nvec2 hash21(float p)\n{\n    vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.xx + p3.yz) * p3.zy);\n\n}\n\n\n// https://www.shadertoy.com/view/XsX3zB\n// by Nikita Miropolskiy\n\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289((x * 34.0 + 10.0) * x); }\n\n// Simplex noise in the range [-1, 1]\nfloat snoise(vec2 v)\n{\n    const vec4 C = vec4(\n        0.211324865405187, // (3.0-sqrt(3.0))/6.0\n        0.366025403784439, // 0.5*(sqrt(3.0)-1.0)\n        -0.577350269189626, // -1.0 + 2.0 * C.x\n        0.024390243902439); // 1.0 / 41.0\n    \n    // First corner\n    vec2 i = floor(v + dot(v, C.yy));\n    vec2 x0 = v - i + dot(i, C.xx);\n\n    // Other corners\n    vec2 i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n    vec4 x12 = x0.xyxy + C.xxzz;\n    x12.xy -= i1;\n\n    // Permutations\n    i = mod289(i); // Avoid truncation effects in permutation\n    vec3 p = permute(permute(i.y + vec3(0.0, i1.y, 1.0 )) + i.x + vec3(0.0, i1.x, 1.0));\n    vec3 m = max(0.5 - vec3(dot(x0, x0), dot(x12.xy, x12.xy), dot(x12.zw, x12.zw)), 0.0);\n    m = m * m * m;\n\n    // Gradients: 41 points uniformly over a line, mapped onto a diamond.\n    // The ring size 17 * 17 = 289 is close to a multiple of 41 (41 * 7 = 287)\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n\n    // Normalise gradients implicitly by scaling m\n    // Approximation of: m *= inversesqrt(a0 * a0 + h * h);\n    m *= 1.79284291400159 - 0.85373472095314 * (a0 * a0 + h * h);\n\n    // Compute final noise value at P\n    vec3 g = vec3(a0.x * x0.x  + h.x * x0.y, a0.yz * x12.xz + h.yz * x12.yw);\n    return 130.0 * dot(m, g);\n}\n\n\nvec2 normalNoise(vec2 st, float zoom, float hashSeed)\n{\n\tst *= zoom;\n    vec2 hash = hash21(hashSeed);\n\n\treturn normalize(vec2(snoise(st - hash.x), snoise(st + hash.y)));\n}\n","name":"Common","description":"","type":"common"}]}