{"ver":"0.1","info":{"id":"WdjGWz","date":"1548618444","viewed":322,"name":"The Keeper","username":"Flopine","description":"Sunday mood! A quick draft shader :) Hope you'll enjoy it.\nThe animation is looping after 50 seconds.","likes":15,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","modeling","glow"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Code by Flopine\n// Thanks to wsmind, leon, XT95, lsdlive, lamogui, Coyhot and Alkama for teaching me\n// Thanks LJ for giving me the love of shadercoding :3\n\n// Cookie Collective rulz\n\n#define ITER 64.\n#define PI 3.141592\n#define anim mod(iTime*10., 500.)\n\nfloat hash(vec3 p)\n{\n    p  = fract( p*0.3183099+.1 );\n\tp *= 17.0;\n    return fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\n}\n\nmat2 rot (float a)\n{return mat2 (cos(a),sin(a),-sin(a),cos(a));}\n\nvec2 moda (vec2 p, float per)\n{\n    float a = atan(p.y, p.x);\n    float l = length(p);\n    a = mod(a-per/2., per)-per/2.;\n    return vec2(cos(a), sin(a))*l;\n}\n\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nvec3 rep3d (inout vec3 p, float per)\n{\n    vec3 id = floor((p-per/2.)/per);\n    p = mod(p-per/2., per)-per/2.;\n    return id;\n}\n\nfloat half_sphe (vec3 p, float r)\n{\n    float d = max(length(p)-r, abs(p.y-r/2.)-r/2.);\n    return d ;\n}\n\nfloat cyl (vec3 p, float r, float h)\n{return max(length(p.xy)-r,abs(p.z)-h);}\n\nfloat g1 = 0.;\nfloat od (vec3 p, float q)\n{\n\tp.yz *= rot(iTime);\n    float d = dot(p, normalize(sign(p)))-q;\n    g1 += 0.1/(0.1+d*d);\n    return d;\n}\n\nfloat tentacle (vec3 p)\n{\n    float o = od (vec3(p.x, p.y-12., p.z), 2.);\n    p.xz *= rot(p.y*0.15);\n    p.xz = moda(p.xz, PI/4.);\n    p.x -= 5.;\n    float t = cyl(p.xzy, 0.5+p.y*0.02, 20.);\n    float d =  min(t, o);\n    return d;\n}\n\nfloat g2 = 0.;\nfloat bodies (vec3 p)\n{\n    p.y -= 5.;\n    p.xz += sin(p.y*0.4+iTime);\n    float hs = max(-half_sphe(vec3(p.x, p.y+1., p.z), 5.),half_sphe(p, 7.));\n    p.y += 20.;\n    float t = tentacle(p);\n    float d = smin(hs, t, 1.5);\n    g2 += 0.1/(0.1+d*d);\n    return d;\n    \n}\n\nfloat bubulle (vec3 p)\n{\n    p.y += iTime*0.6;\n    vec3 id = rep3d(p, 10.);\n    p.xy *= rot(iTime*0.1*hash(id));\n    p += sin(iTime*hash(id));\n    return length(p)-.2;\n}\n\nfloat SDF (vec3 p)\n{\n    p.y -= anim*1.2;\n    float b = bubulle(p);\n    p.xz *= rot(iTime*0.5);\n    return min(bodies(p), b);\n\n}\n\nvec3 norms (vec3 p)\n{\n    vec2 eps = vec2(0.1,0.);\n    return normalize(vec3(SDF(p+eps.xyy)-SDF(p-eps.xyy),\n                          SDF(p+eps.yxy)-SDF(p-eps.yxy),\n                          SDF(p+eps.yyx)-SDF(p-eps.yyx)\n    \t\t\t\t\t)\n                    );\n}\n\nfloat lighting(vec3 n, vec3 l)\n{return dot (n, normalize(l))*0.5+0.5;}\n\n\nvec3 get_cam (vec3 eye, vec3 tar, vec2 uv, float fov)\n{\n    vec3 forward = normalize(tar-eye);\n    vec3 left = normalize(cross(vec3(0.,1.,0.), forward));\n    vec3 up = normalize(cross(forward, left));\n    return normalize(forward*fov + left*uv.x + up * uv.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 q = fragCoord/iResolution.xy;\n    vec2 uv = 2.*(q)-1.;\n\tuv.x *= iResolution.x/iResolution.y;\n    uv += texture(iChannel0, uv+iTime*0.4).rg*length(uv*0.5)*0.1;\n    \n    vec3 ro = vec3(5.,3.+anim, -20.); vec3 p = ro;\n    vec3 target = vec3(0., -6.+anim*1.2, 0.);\n    vec3 rd = get_cam(ro,target, uv, 1.);\n        \n    bool hit = false;\n    vec3 col = vec3(0.);\n    float shad = 0.;\n    \n    for (float i=0.; i<ITER; i++)\n    {\n        float d = SDF(p);\n        if (d<0.001)\n        {\n            hit = true;\n            shad = i/ITER;\n            break;\n        }\n        p += d*rd*0.4;\n    }\n    \n    if (hit)\n    {\n        vec3 n = norms(p);\n        col = mix(vec3(0.1,0.5,0.9), vec3(1.),lighting(n, vec3(2.,10.,-20.)));\n    }\n    \n    // glow\n\tcol += g1 * vec3(1.,0.7, 0.1);\n\tcol += g2*vec3(uv.y,0.1,uv.y+2.)*0.2*clamp(sin(iTime), 0., 1.);\n    \n    // fog\n    float t = length(ro-p); \n    col = mix(col, vec3(0.,0.08,0.2),1.-exp(-0.001*t*t));\n    \n    // vignetting from iq\n    col *= 0.5 + 0.5*pow(16.0*q.x*q.y*(1.0 - q.x)*(1.0 - q.y), 2.);\n    \n    // gamma correct\n    col = sqrt(col);\n\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}