{"ver":"0.1","info":{"id":"XttyzX","date":"1534094260","viewed":474,"name":"Desert Pillars","username":"szpro","description":"Pillars in the desert world. \nShader created by Szpro & Maszkutron \nUse mouse to rotate and arrows to move camera\n","likes":8,"published":1,"flags":48,"usePreview":0,"tags":["raymarch","clouds","space","fog","orange","column","bloom","desert","death","pillar"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n/*\n\tGausian blur vertical pass + bloom mix with raymarch\n*/\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // vertical gaussain blur pass\n\tfloat texelSize = 1.0 / iResolution.y;\n    vec2 uv = fragCoord / iResolution.xy;\n    vec3 bloomColor = GaussianBlur(iChannel1, uv, vec2(0.0, texelSize));\n    \n    // sampling ray-marched image\n    vec4 raymarchResult = texture(iChannel0, fragCoord/iResolution.xy);\n    \n    // combining colors\n    vec3 color = raymarchResult.rgb + bloomColor * bloomIntensity;\n    \n    // ret\n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// raymarch variables\nint Steps = 80;\nfloat MaxDistance = 50.0;\nfloat DistanceHitThreshold = 0.0002;\nfloat MapDistanceAccuracy = 1.0;\n\n// bloom settings\nfloat bloomIntensity = 0.2;\nconst float bloomThreshold = 0.2;\nconst int guassianBlurSamples = 5;\nconst float gaussianBlurWeights[5] = float[] (0.227027, 0.1945946, 0.1216216, 0.054054, 0.016216);\n\n// ==================================================================\n// math functions\n#define PI 3.1415926536f\nfloat Mod(float a, float b)\n{\n    return a - b * floor(a / b);\n}\n\nfloat TriFrac(float x)\n{\n    return abs(fract(x) - .5);\n}\n\n// this is very lazy way of implementing gaussian passes\nvec3 GaussianBlur(sampler2D image, vec2 centerPixelUV, vec2 uvStep)\n{\n    vec3 ret = texture(image, centerPixelUV).rgb * gaussianBlurWeights[0];\n    for(int i = 1; i < guassianBlurSamples; ++i)\n    {\n        vec2 offset = uvStep * float(i);\n        ret += texture(image, centerPixelUV + offset).rgb * gaussianBlurWeights[i];\n        ret += texture(image, centerPixelUV - offset).rgb * gaussianBlurWeights[i];\n    }\n\treturn ret;\n}\n\nvec3 HeightToNormal(vec3 right, vec3 left, vec3 top, vec3 bottom, float sharpness)\n{\n    float z1 = (length(right) - length(left))* sharpness;\n    float z2 = (length(top) - length(bottom)) * sharpness;\n    \n    return cross(vec3(1.0, 0.0, z1), vec3(0.0, 1.0, z2));\n}\n\nvec3 HieghtToNormal(sampler2D image, vec2 point, vec2 texelSize, float sharpness)\n{\n    float right = length(texture(image, point + vec2(texelSize.x, 0.0)).rgb);\n    float left = length(texture(image, point - vec2(texelSize.x, 0.0)).rgb);\n    float top = length(texture(image, point + vec2(0.0, texelSize.y)).rgb);\n    float bottom = length(texture(image, point - vec2(0.0, texelSize.y)).rgb);\n    \n    float z1 = (right - left)* sharpness;\n    float z2 = (top - bottom) * sharpness;\n    \n    return cross(vec3(1.0, 0.0, z1), vec3(0.0, 1.0, z2));\n}\n\n// ==================================================================\n// random functions\nfloat RandomValue(float n)\n{\n    return fract(sin(n) * 43758.5453123);\n}\n\nfloat GridRandomIdXZ(vec3 position, vec2 mod)\n{\n    float seed = floor(position.x / mod.x) + floor(position.z / mod.y) * 1001.0;\n    return RandomValue(seed);\n}\n\nvec2 GridRandomId2XZ(vec3 position, vec2 mod)\n{\n    float seed1 = floor(position.x / mod.x) + floor(position.z / mod.y) * 1001.0;\n    float seed2 = floor(position.x / mod.x) * 1001.0 + floor(position.z / mod.y) * 999.0;\n    return vec2(RandomValue(seed1), RandomValue(seed2));\n}\n// ==================================================================\n// few of functions below, reference : https://www.shadertoy.com/view/Xls3D2\n// noise functions\nfloat Rand(vec2 c)\n{\n    return fract(sin(dot(c.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat PseudoPerlinNoise(vec2 p)\n{\n    float unit = 5.0;\n    vec2 ij = floor(p / unit);\n    vec2 xy = (mod(p,unit)) / unit;\n    //xy = 3.*xy*xy-2.*xy*xy*xy;\n    xy = .5*(1. - cos(PI*xy));\n    float a = Rand((ij + vec2(0.,0.)));\n    float b = Rand((ij + vec2(1.,0.)));\n    float c = Rand((ij + vec2(0.,1.)));\n    float d = Rand((ij + vec2(1.,1.)));\n    float x1 = mix(a, b, xy.x);\n    float x2 = mix(c, d, xy.x);\n    return mix(x1, x2, xy.y);\n}\n\nvec3 Triangle3(vec3 position)\n{\n    return vec3(TriFrac(position.z + TriFrac(position.y)),\n                  TriFrac(position.z + TriFrac(position.x)), TriFrac(position.y + TriFrac(position.x)));\n}\n\nfloat TriangleNoise3dSimplified(vec3 position, float multiplier)\n{\n    float z = 1.4;\n    float rz = 0.0f;\n    vec3 bp = position;\n    vec3 dg = Triangle3(bp*multiplier);\n    for (float i = 0.; i <= 2.; i++)\n    {\n        position += (dg);\n\n        bp *= 2.;\n        z *= 1.5;\n        position *= 1.3;\n\n        rz += (TriFrac(position.z + TriFrac(position.x + TriFrac(position.y)))) / z;\n        bp += 0.14;\n    }\n    return rz;\n}\n\nvec4 QuadTric(vec4 position)\n{\n    return abs(fract(position.yzwx + position.wzxy) - .5);\n}\n\nfloat QuadNoise3d(vec3 position, float wValue)\n{\n    float z = 1.4;\n    vec4 p = vec4(position, wValue);\n    float rz = 0.;\n    vec4 bp = p;\n    for (float i = 0.; i <= 2.; i++)\n    {\n        vec4 dg = QuadTric(bp);\n        p += (dg);\n\n        z *= 1.5;\n        p *= 1.3;\n\n        rz += (TriFrac(p.z + TriFrac(p.w + TriFrac(p.y + TriFrac(p.x))))) / z;\n\n        bp = bp.yxzw * 2.0 + .14;\n    }\n    return rz;\n}\n\n// ==================================================================\n// reference to IQ : https://iquilezles.org/articles/distfunctions\n// distance funcions\n\nvec3 RepeatX(vec3 position, float repeatOffset)\n{\n    vec3 changedPosition = position;\n    changedPosition.x = Mod(changedPosition.x, repeatOffset) - 0.5f * repeatOffset;\n    return changedPosition;\n}\n\nvec3 RepeatZ(vec3 position, float repeatOffset)\n{\n    vec3 changedPosition = position;\n    changedPosition.z = Mod(changedPosition.z, repeatOffset) - 0.5f * repeatOffset;\n    return changedPosition;\n}\n\nvec3 RepeatXZ(vec3 position, vec2 repeatOffset)\n{\n    vec3 result = RepeatX(position, repeatOffset.x);\n    result = RepeatZ(result, repeatOffset.y);\n    return result;\n}\n\nfloat FiniteCylinder(vec3 position, vec2 size)\n{\n    vec2 d = abs((vec2(length(position.xz), position.y))) - size;\n    return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\n// reference to IQ : https://iquilezles.org/articles/smin\nfloat PolynomialSmoothMinimum(float distance1, float distance2, float smoothness)\n{\n    float h = clamp(0.5f + 0.5f * (distance2 - distance1) / smoothness, 0.0f, 1.0f);\n    return mix(distance2, distance1, h) - smoothness * h * (1.0 - h);\n}\n\n// ==================================================================\n// texturing\n// returns texture sample using triplanar projection\nvec3 TexTriPlanar(vec3 surfacePosition, vec3 surfaceNormal, sampler2D textureTop, sampler2D textureSide, sampler2D textureFront)\n{\n    surfaceNormal = abs(surfaceNormal);\n    surfaceNormal /= (surfaceNormal.x + surfaceNormal.y + surfaceNormal.z);\n    vec2 uvX = surfacePosition.zy;\n    vec2 uvY = surfacePosition.xz;\n    vec2 uvZ = surfacePosition.xy;\n    vec4 sideColor = texture(textureSide, uvX) * surfaceNormal.x;\n    vec4 topColor = texture(textureTop, uvY) * surfaceNormal.y;\n    vec4 frontColor = texture(textureFront, uvZ)  * surfaceNormal.z;\n    return (sideColor + topColor + frontColor).rgb;\n}\n\n// ==================================================================\n// lighting\nstruct PhongLightParams\n{\n    vec3 diffuseColor;\n    float diffuseIntensity;\n\n    vec3 specularColor;\n    float specularPower;\n    float specularIntensity;\n};\n\n// phong-model base directional light\nvec3 PhongDirectionalLight(vec3 surfaceNormal, vec3 rayDirection, vec3 lightDirection, PhongLightParams phongParams)\n{\n    float diffuse = max(dot(surfaceNormal, lightDirection), 0.0);\n    float specularDot = dot(reflect(-lightDirection, surfaceNormal), -rayDirection);\n    float specular = pow(max(specularDot, 0.0), phongParams.specularPower);\n    vec3 sceneColor = (phongParams.diffuseColor*(diffuse + phongParams.diffuseIntensity) + phongParams.specularColor*specular*phongParams.specularIntensity);\n    return sceneColor;\n}\n\n// ==================================================================\n// reference : https://www.shadertoy.com/view/lssGRM\n// postprocessing\nvec3 ApplyFog(vec3 surfaceColor, vec3 fogColor, float distance, float intensity)\n{\n    float fogAmount = 1.0 - exp(-distance * intensity);\n    return mix(surfaceColor, fogColor, fogAmount);\n}\n\nvec3 ApplyFog(\tvec3  surfaceColor,      // original color of the pixel\n                vec3 atmosphereColor,\n                vec3 lightColor,\n                float distance, // camera to point distance\n                vec3  rayDir,   // camera to point vector\n                vec3  sunDir,\n                float intensity)  // sun light direction\n{\n    float fogAmount = 1.0 - exp(-distance * intensity);\n    float sunAmount = max(dot(rayDir, sunDir), 0.0);\n    vec3  fogColor = mix(atmosphereColor, // bluish\n                            lightColor, // yellowish\n                            pow(sunAmount, 8.0));\n    return mix(surfaceColor, fogColor, fogAmount);\n}\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"/*\n\tUser input buffer\n*/\n\n// [A]=65 ... [Z]=90, [0]=48 ... [9]=57, [space]=32, [<]=37, [^]=38, [>]=39, [v]=40\n#define KEY_LEFT 0.146484375\n#define KEY_RIGHT 0.154296875\n#define KEY_DOWN 0.158203125\n#define KEY_UP 0.150390625\n\n//change velocity per frame:\n#define ACCEL .02\n#define BRAKE .9;\n\nconst vec2 mouseSens = vec2(-.6, 1.); //mouse sensivity, change signs to invert axis \n\nfloat getKey(float key) {return texture(iChannel1, vec2(key, .25)).x;}\n\nvec4 getVar(int key) {return texture(iChannel0, vec2(.05 + float(key), .5)/iResolution.xy);}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    if (fragCoord.y > .9) discard;\n    int idx=int(fragCoord.x);\n    if (idx <= 1) // orientation\n    {\n        fragColor = getVar(0);\n        fragColor.xy += (float(fragColor.w>.0) - float(iMouse.z>.0 && idx==0)) * \n                        (iMouse.yx/iResolution.yx - .5) * mouseSens;\n        vec4 cr = fragColor*6.28318530718;\n        if (idx == 0) fragColor.w = iMouse.z; \n        else fragColor = vec4(cos(cr.x), cos(cr.y), sin(cr.x), sin(cr.y));\n    }\n    else if (idx == 2) // velocity\n    {\n        vec4 camV = getVar(idx--);\n        vec4 tm = getVar(idx);\n        camV.xyz += ACCEL * (\n          \t\t\t(getKey(KEY_UP) - getKey(KEY_DOWN)) * vec3(tm.x*tm.w, -tm.z, tm.x*tm.y) +\n          \t\t\t(getKey(KEY_RIGHT) - getKey(KEY_LEFT)) * vec3(tm.y, 0, -tm.w) );\n        fragColor = camV * BRAKE;\n    }\n    else if (idx == 3) fragColor = getVar(idx--) + getVar(idx); // position\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4sfGRn","filepath":"/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","previewfilepath":"/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsX3Rn","filepath":"/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg","previewfilepath":"/media/ap/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4df3Rr","filepath":"/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","previewfilepath":"/media/ap/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"/*\n\tRaymarch result buffer\n*/\n\n// colors\nvec4 _MainLightSourceColor\t= vec4(255.0/255.0, 255.0/255.0, 255.0/255.0, 255.0/255.0);\nvec4 _FarHorizontColor\t\t= vec4(238.0/255.0, 158.0/255.0, 16.0/255.0, 255.0/255.0);\nvec4 _DustColor \t\t\t= vec4(255.0/255.0, 160.0/255.0, 73.0/255.0, 255.0/255.0);\nvec4 _CloudsColor \t\t\t= vec4(255.0/255.0, 251.0/255.0, 229.0/255.0, 255.0/255.0);\n\nvec3 Map(vec3 position)\n{\n    // some map variables\n    vec2  separation = vec2(5,5); \n    vec3 basePosition = position;\n    float randomId = GridRandomIdXZ(position, separation);\n\n\n    // floor\n    vec2 offset = vec2(1000.0, 1000.0);\n    vec2  noisePosition = abs(offset + position.xz);\n    float p0 = PseudoPerlinNoise(noisePosition*1.1);\n    float p1 = PseudoPerlinNoise(noisePosition*6.0);\n    float perlin = min(p0, p1);\n    float plane = position.y - perlin;\n\n    // base cylinder\n    position = RepeatXZ(position, separation);\n\n    float noise = TriangleNoise3dSimplified(position/3.5, 3.0);\n    float column = FiniteCylinder(position, vec2(0.33 + length(noise)/5.0, 8.0));\t\n\n    float result = PolynomialSmoothMinimum(column, plane, 0.9f);\n\n    return vec3(result, max(p0-perlin, p1-perlin),column - plane);\n}\n\n// ==================================================================\n// shadows\nfloat SoftShadowsSimplified(vec3 surfacePosition, vec3 lightDirection, float minMapDistance, float maxMapDistance)\n{\n    float res = 1.0;\n    float t = minMapDistance;\n    float ph = 1e10; // big, such that y = 0 on the first iteration\n\n    for (int i = 0; i<32; i++)\n    {\n        float h = Map(surfacePosition + lightDirection * t).x;\n        res = min(res, 10.0*h / t);\n        t += h;\n        if (res<0.001 || t>maxMapDistance) break;\n    }\n    return clamp(res, 0.0, 1.0);\n}\n\n// ==================================================================\n// normals\n\n// reference IQ (don't remember exact link)\nvec3 GetTetrahedralNormalMapX(vec3 position)\n{\n    // offset used to increase sampling distance, to prevent artifacts\n    // of floating point inaccuracies\n    vec2  offset = vec2(0.0035, -0.0035);\n    return normalize(\n        offset.xyy * Map(position + offset.xyy).x +\n        offset.yyx * Map(position + offset.yyx).x +\n        offset.yxy * Map(position + offset.yxy).x +\n        offset.xxx * Map(position + offset.xxx).x);\n}\n\nfloat FogMap(vec3 position)\n{\n    position.xz -= iTime * 2. + sin(position.z * 0.3f);\n    position.y -= iTime * 1.5;\n    float n1 = TriangleNoise3dSimplified(position * 0.008f + 0.1f, 3.0)-0.1f;\n    float n2 = TriangleNoise3dSimplified(position * 0.1f,3.0);\n    return (max(n1,0.0f) * n2)* 0.3f;\n}\n\n// reference : https://www.shadertoy.com/view/Xls3D2\nvec3 AddClouds(vec3 spaceColor, vec3 rayDirection)\n{\n    rayDirection.y = max(rayDirection.y, 0.0);\n    float ele = rayDirection.y;\n    float v = (200.0)/rayDirection.y;\n\n    rayDirection.y = v;\n    rayDirection.xz = rayDirection.xz * v - iTime * 15.;\n    rayDirection.xz *= .0004;\n\n    float f = QuadNoise3d(rayDirection.xzz*3., iTime / 50.) * QuadNoise3d(rayDirection.zxx*1.3, iTime / 30.0f) * 2.5f;\n    f = f*pow(ele, .5)*2.;\n    f = clamp(f-.15, 0.01, 1.0);\n\n    return  mix(spaceColor, _CloudsColor.rgb,f );\n}\n\nvec4 Trace(vec3 rayOrigin, vec3 rayDirection)\n{\n    float rayPointDistance = 0.0f;\n    float mapDistance = 0.0f;\n    vec3 rayMarchPosition = vec3(0.0,0.0,0.0);\n    float fogDrift = 0.0f;\n    vec3 lastMapResult;\n\n    for (int i = 0; i < Steps; i++)\n    {\n        rayMarchPosition = rayOrigin + rayDirection * rayPointDistance;\n        lastMapResult = Map(rayMarchPosition);\n        mapDistance = lastMapResult.x;\n        if (abs(mapDistance) < DistanceHitThreshold || rayPointDistance > MaxDistance)\n            break;\n\n        fogDrift += FogMap(rayMarchPosition);\n        rayPointDistance += mapDistance * MapDistanceAccuracy;\n\n    }\n\n    return vec4(rayPointDistance, min(fogDrift, 1.0), lastMapResult.yz);\n}\n\nvec3 GetSpaceColor(vec3 worldPosition, vec3 rayDirection, vec3 lightPosition)\n{\n    // main green light\n    vec3 directionToMainLightPosition = normalize(lightPosition - worldPosition);\n    float mainLightAmount = max( dot( rayDirection, directionToMainLightPosition), 0.0 );\n\n    // small 2 planets - still green light\n    vec3 directionToSmallPlanet1 = normalize(vec3(lightPosition.x - 150.0,lightPosition.y,\n        lightPosition.z + 80.0) - worldPosition);\n    float lightStarAmount1 = max( dot( rayDirection, directionToSmallPlanet1), 0.0 );\n\n    // movement of second planet\n    float radius = 250.0f;\n    float angle = iTime / 8.0f;\n    vec3 directionToSmallPlanet2 = normalize(vec3(lightPosition.x + cos(angle) * radius,lightPosition.y, lightPosition.z + sin(angle) * radius) - worldPosition);\n    float lightStarAmount2 = max( dot( rayDirection, directionToSmallPlanet2), 0.0 );\n\n    // horizon color blending\n    float v = pow(1.0-max(rayDirection.y,0.0),2.);\n    vec3 sky = mix(vec3(.0,0.01,.04), _FarHorizontColor.rgb, v);\n\n    // small 2 planets color\n    sky = sky + _MainLightSourceColor.rgb * 0.75f * min(pow(lightStarAmount1, 6000.0), .75); \n    sky = sky + _MainLightSourceColor.rgb * 0.55f * min(pow(lightStarAmount2, 80000.0), .5); \n\n    // main light source\n    sky = sky + _MainLightSourceColor.rgb * mainLightAmount * mainLightAmount * .25;\n    sky = sky + _MainLightSourceColor.rgb * min(pow(mainLightAmount, 900.0), .7); \n    \n    return clamp(sky, 0.0, 1.0);\n}\n\nvec3 DoColor(vec3 surfacePosition,vec3 worldPosition ,vec3 rayDirection, \n    vec3 normal, vec3 lightPosition, vec4 traceData)\n{\n    float fogDrift = traceData.y;\n\n    float randomId = GridRandomIdXZ(surfacePosition, vec2(5,5));\n    \n    // some randomness testing\n    vec3 objCol = vec3(1.0, 1.0, 1.0);\n\n    //objCol.rg *= GridRandomId2XZ(surfacePosition, vec2(5,5)); // WORKS WITH SURFACE POSITION\n    //objCol.b *= randomId;\n    // postprocess variables\n    vec3 fogColor = _FarHorizontColor.rgb;\n    float fogIntensity = 0.0375f;\n\n    // horizon calculation\n    float surfaceDistance = traceData.x;// distance(surfacePosition, worldPosition);\n    float lightDistance = distance(lightPosition, worldPosition);\n\n    // space color\n    float distanceNormalized = surfaceDistance / MaxDistance;\n    if ( distanceNormalized >= 0.9f )\n    {\n        // main space color\n        vec3 spaceColor = GetSpaceColor(worldPosition, rayDirection, lightPosition);\n        // adding clouds to spaceColor\n        spaceColor = AddClouds(spaceColor, rayDirection);\n        // apply fog to space color\n        vec3 foggedSpaceColor = ApplyFog(spaceColor, fogColor, lightDistance, fogIntensity);\n        // some blending between space color and fogged space color\n        vec3 finalSpaceColor =  mix(spaceColor, foggedSpaceColor, 0.35f);\n        \n        // blowing dust \n        vec3 foggedDustSpaceColor = mix(finalSpaceColor, _DustColor.rgb, fogDrift);\n\n        // rayDirection.y / 6.0f is to prevent weird dust above  columns\n        return mix(finalSpaceColor, foggedDustSpaceColor , rayDirection.y / 6.0f);\n    }\n    else\n    {\n        vec3 baseNormal = normal;\n        float planeColumnDistance = traceData.w;\n\n        // calculating floor texturing\t\t\t\t\t\n        float pMax = traceData.z;\n        float v = clamp(1.0 - pMax * 4.0,0.0,1.0);\t\t\t\t\t\t\n            \n        vec3 c2 = TexTriPlanar(surfacePosition/2.0, normal, iChannel0, iChannel0, iChannel0);\n        vec3 c1 = TexTriPlanar(surfacePosition/3.0, normal, iChannel1, iChannel1, iChannel1);\n\n        vec3 normal1 = 0.3 * TexTriPlanar(surfacePosition/2.0, normal, iChannel2, iChannel2, iChannel2);\n        normal = normal + mix(normal1, normal1*2.0, v);\n        objCol = mix(c1,c2, v);\n        \n        // calculating column texturing\n        if(planeColumnDistance <= 0.0f)\n        {\n            normal = baseNormal + normal1; \n            //objCol = mix(objCol,c1, clamp(surfacePosition.y,0,1));\n        }\n    }\n\n    // ============================================================================================================\n    // lighting\n\n    // main light\n    PhongLightParams lightParams = PhongLightParams(\n        objCol.rgb, 1.0,\n        _MainLightSourceColor.rgb, 3.5, 0.03\n    );\n\n    // applying light\n    vec3 lightDirection = normalize(lightPosition);\n    vec3 col = PhongDirectionalLight(normal, rayDirection, lightDirection, lightParams);\n\n    // ============================================================================================================\n    // postprocess\n    // ============================================================================================================\n\n    // ============================================================================================================\n    // apply shadows\n    float shadow = SoftShadowsSimplified(surfacePosition, lightDirection, 0.1, 25.0);\n    vec3 shadowed = col * shadow;\n    col = mix(col, shadowed, 0.5);\n\n    // ============================================================================================================\n    // blowing dust \n    col = mix(col, _DustColor.rgb, fogDrift);\n\n    // ============================================================================================================\n    // we apply fog to dust color too, to have better blending\n    col.rgb = ApplyFog(\n        col.rgb, fogColor.rgb, _MainLightSourceColor.rgb,\n        surfaceDistance, rayDirection, normalize(lightPosition-surfacePosition),\n        fogIntensity\n    );\n\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    const float FOV = 3.14159/3.;\n\n\t// Tempally: Next 5 lines add free flight from Buf A:\n    vec3 rd = normalize(vec3( (fragCoord.xy*2. - iResolution.xy)/iResolution.x, FOV )); \n    vec4 tm = texture( iChannel3, vec2(1.5,.5)/iResolution.xy); \n    rd.zy = rd.zy * tm.x + rd.yz * vec2(tm.z, -tm.z);\n    rd.xz = rd.xz * tm.y + rd.zx * vec2(tm.w, -tm.w);\n\tvec3 ro = texture( iChannel3, vec2(3.5,.5)/iResolution.xy).xyz + vec3(0,2,0);\n    \n    //.x is distance, .y is fog drift\n    vec4 trace4 = Trace(ro, rd);\n    \n    vec3 hitPoint = ro + rd * trace4.x;\n\n    vec3 normal = GetTetrahedralNormalMapX(hitPoint);\n    vec4 col = vec4(DoColor(hitPoint, ro, rd, normal, vec3(1000,1000,500), trace4),1.0f);\n\n    fragColor = col;\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"/*\n\tBloom pass\n*/\n\n// calculates color brightness\n// Photometric/digital ITU BT.709:\nfloat CalculateBrightness(vec3 color)\n{\n    return color.r * 0.2126 + color.g * 0.7152 + color.b * 0.0722;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 color = texture(iChannel0, fragCoord / iResolution.xy).rgb;\n    if(CalculateBrightness(color) > bloomThreshold)\n    \tfragColor = vec4(color, 1.0);\n   \telse fragColor = vec4(0.0,  0.0, 0.0, 1.0);\n}","name":"Buffer C","description":"","type":"buffer"},{"inputs":[{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"/*\n\tGausian blur horizontal pass\n*/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float texelSize = 1.0 / iResolution.x;\n    vec2 uv = fragCoord / iResolution.xy;\n    fragColor = vec4(GaussianBlur(iChannel0, uv, vec2(texelSize, 0.0)), 1.0);\n}","name":"Buffer D","description":"","type":"buffer"}]}