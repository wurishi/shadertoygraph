{"ver":"0.1","info":{"id":"43jSzD","date":"1712173461","viewed":75,"name":"AdvancedGraphicsProgramming_UPC","username":"Alejandromo125","description":"3DGraphics rendering ","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["upc"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_DISTANCE 1000.0\n#define MIN_DISTANCE 0.001\n#define PI 3.1416\n\nfloat hash(vec2 p) { return fract(1e4 * sin(17.0 * p.x + p.y * 0.1) * (0.1 + abs(sin(p.y * 13.0 + p.x)))); }\n\nfloat noise(vec2 uv)\n{\n    vec2 i = floor(uv);\n\t  vec2 f = fract(uv);\n    \n  \tfloat a = hash(i);\n\t  float b = hash(i + vec2(1.0, 0.0));\n\t  float c = hash(i + vec2(0.0, 1.0));\n\t  float d = hash(i + vec2(1.0, 1.0));\n    \n    vec2 u = f * f * (3.0 - 2.0 * f);\n\t  return mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y;\n}\n\nfloat fbm(vec2 uv)\n{\n    float value = 0.0;\n    float amplitude = 0.5;\n    vec2 shift = vec2(100.0);\n    \n    mat2 rot = mat2(cos(0.5), sin(0.5), -sin(0.5), cos(0.5));\n    \n    for (int i = 0; i < 8; ++i)\n    {\n        value += amplitude * noise(uv);\n        uv = rot * uv * 2.0 + shift;\n        amplitude *= 0.5;\n    }\n    \n    return value;\n}\n\nstruct Camera\n{\n    vec3 position;\n    vec3 direction;\n    vec3 lookAt;\n    float zoom;\n};\n\nstruct Light\n{\n    vec3 direction;\n    float ambient;\n};\n\nstruct Material\n{\n    vec3 color;      \n    float diffuse;   \n    float specular;  \n    float shininess; \n    float R0;        \n    float IOR;       \n};\n\nstruct Plane\n{\n    float height;\n    Material material;\n};\n\nstruct Sphere\n{\n    vec3 position;\n    float radius;\n    Material material;\n};\n\nstruct Ray\n{\n    vec3 direction;\n    vec3 origin;\n};\n\nstruct Hit              \n{\n    float t;            \n    vec3 p;             \n    vec3 normal;        \n    Material material;  \n};\n\nCamera camera;\nLight light;\nPlane plane;\nSphere sphereArray[6];\n\nvoid FloorIntersection(Ray ray, inout Hit hit)\n{\n    float trigger = (plane.height - ray.origin.y) / ray.direction.y;\n    if (trigger < hit.t && trigger > MIN_DISTANCE)\n    {        \n        hit.t = trigger;\n        hit.p = ray.origin + trigger * ray.direction;;\n        hit.normal = vec3(0, 1, 0);\n        hit.material = plane.material;\n        \n        float tile = mod(floor(mod(hit.p.x, 2.)) + floor(mod(hit.p.z, 2.)), 2.);\n        hit.material.color = vec3(tile);  \n        \n        if(ray.direction == camera.direction)\n        {\n       \n           hit.material.color = mix(vec3(tile), vec3(0), hit.t/100.);\n        }\n    }\n}\n\nvoid SphereIntersection(Ray ray, Sphere sphere, inout Hit hit, bool inside)\n{\n    vec3 OriginalCoordinate = sphere.position - ray.origin;\n    float trigger1 = dot(OriginalCoordinate, ray.direction);\n    \n    if (trigger1 > MIN_DISTANCE)\n    {\n        vec3 k = ray.origin + trigger1 * ray.direction;\n        float length1 = length(k - sphere.position);\n        float length2 = sqrt(sphere.radius * sphere.radius - length1 * length1);\n        float trigger = trigger1 - length2;\n        \n        if (inside)\n        {\n            trigger = trigger1 + length2;\n        }\n        if (trigger < hit.t && length1 <= sphere.radius)\n        {\n            hit.t = trigger;\n            hit.p = ray.origin + trigger * ray.direction;\n            hit.normal = normalize(hit.p - sphere.position);\n            hit.material = sphere.material;\n        }\n    }\n}\n\nbool CheckIntersections(Ray ray, inout Hit hit, bool inside)\n{\n    hit.t = MAX_DISTANCE;\n    \n    FloorIntersection(ray, hit);\n    \n    for (int i = 0; i < sphereArray.length(); ++i)\n    {\n        SphereIntersection(ray, sphereArray[i], hit, inside);\n    }\n    \n    return hit.t < MAX_DISTANCE;\n}\n\nfloat Fresnel(vec3 direction, Hit hit)\n{\n    float theta = 1. - dot(hit.normal, -direction);\n    float fresnel = pow(clamp(theta, 0., 1.), 5.);\n    fresnel *= 1. - hit.material.R0;\n    \n    if (hit.t < MAX_DISTANCE)\n        return fresnel + hit.material.R0;\n    \n    return 0.;\n}\n\n\nvec3 Color(Ray ray)\n{\n    Hit hit;\n    bool intersects = CheckIntersections(ray, hit, false);\n    \n    //Draw sky\n    if (!intersects)\n    {\n        vec3 white = vec3(0.9, 0.9, 1);\n        vec3 blue = vec3(0.2, 0.5, 1);\n        vec3 skyColor = mix(white, blue, ray.direction.y);\n        float t = (ray.origin.y + 40.) / ray.direction.y;\n        vec3 p = ray.origin + t * ray.direction;\n        float value = fbm(vec2(p.x * 0.04 / 2.5, p.z * 0.09));\n        return mix(white, skyColor, value * 2.5);\n    }\n    else //Draw world\n    {\n        vec3 ambient = light.ambient * hit.material.color;\n\n        Hit shadowHit;\n        if (CheckIntersections(Ray(light.direction, hit.p + hit.normal * MIN_DISTANCE), shadowHit, false))\n        {\n\n            return ambient;\n        }\n        float diffuseCoef = dot(light.direction, hit.normal);\n        vec3 diffuse = hit.material.diffuse * max(diffuseCoef, 0.) * hit.material.color;\n\n        float shininessCoef = max(dot(ray.direction, reflect(light.direction, hit.normal)), 0.);\n        shininessCoef = pow(shininessCoef, hit.material.shininess);\n        vec3 specular = hit.material.specular * shininessCoef * hit.material.color;\n\n        return ambient + diffuse + specular;\n    }\n}\n\n\nmat2 Rotate(float a)\n{\n    float sinus = sin(a);\n    float cosinus = cos(a);\n    return mat2(cosinus, -sinus, sinus, cosinus);\n}\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    //Readjustment of uv coords\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv * 2.0 - vec2(1.0);\n    uv.x *= iResolution.x / iResolution.y;\n    \n    //Creation of materials\n    Material materialArray[7];\n    materialArray[0] = Material(vec3(0.2, 0.2, 0.2), 0.80, 1.00, 05.0, 0.01, 0.0);\n    materialArray[1] = Material(vec3(0.9, 0.5, 0.2), 0.70, 0.70, 20.0, 0.00, 0.0);\n    materialArray[2] = Material(vec3(0.2, 0.2, 0.3), 0.75, 3.90, 30.0, 0.07, 0.0);\n    materialArray[3] = Material(vec3(0.2, 0.2, 0.9), 0.30, 3.90, 30.0, 0.10, 0.0);\n    materialArray[4] = Material(vec3(1.0, 1.0, 1.0), 0.50, 0.50, 10.0, 0.05, 1.0);\n    materialArray[5] = Material(vec3(1.0, 1.0, 1.0), 0.50, 0.50, 10.0, 0.05, 0.3);\n    \n    //Creation of elements (plane,spheres,lights and camera)\n    plane.height = -0.3;\n    plane.material = materialArray[0];\n    \n    sphereArray[0] = Sphere(vec3(0.00, 0.40, 0.00), 0.25, materialArray[1]);\n    sphereArray[1] = Sphere(vec3(1.00, 0.20, -1.00), 0.25, materialArray[2]);\n    sphereArray[2] = Sphere(vec3(1.00, 0.00, 0.00), 0.25, materialArray[3]);\n    sphereArray[3] = Sphere(vec3(0.00, 0.01, 1.00), 0.25, materialArray[4]);\n    sphereArray[4] = Sphere(vec3(-1.00, 0.70, 2.00), 0.25, materialArray[5]);\n    \n    light.direction = normalize(vec3(0.0, 2.0, 1.2));\n    light.ambient = 0.1;\n    \n    vec2 mouse = iMouse.xy / iResolution.xy;\n    camera.position = vec3(0, 0, -5);\n    camera.position.yz *= Rotate(-mouse.y * PI + 1.0);\n    camera.position.xz *= Rotate(-mouse.x * PI * 2.0); \n    camera.zoom = 2.5;\n    camera.lookAt = vec3(0, 1.0, 0);\n    \n    vec3 col = vec3(0);\n    \n    //AntiAliasing and color generation\n    \n    for (int AntiAliasing = 0; AntiAliasing < 16; ++AntiAliasing)\n    {\n        vec2 displace = uv + float(AntiAliasing) * vec2(dFdx(uv.x), dFdy(uv.y)) / 16.0;\n        vec3 camZ  = normalize(camera.lookAt - camera.position);\n        vec3 camX  = normalize(cross(vec3(0, 1, 0), camZ));\n        vec3 camY  = cross(camZ, camX);\n        \n        vec3 c = camera.position + camZ * camera.zoom;\n        vec3 i = c + displace.x * camX + displace.y * camY;\n        camera.direction = normalize(i - camera.position);\n        Ray mainRay = Ray(camera.direction, camera.position);\n        Hit drawingHit;\n        bool rayIntersects = CheckIntersections(mainRay, drawingHit, false);\n        \n        \n        vec3 colorDirect = Color(mainRay);\n        //Reflection calculations\n        if (drawingHit.material.IOR != 0.)\n        {\n            vec3 refractionInDir = normalize(refract(camera.direction, drawingHit.normal, drawingHit.material.IOR));\n            Ray enterRay = Ray(refractionInDir, drawingHit.p - drawingHit.normal * MIN_DISTANCE);\n            Hit enterHit;\n            bool enterIntersects = CheckIntersections(enterRay, enterHit, true);\n            vec3 refractionOutDir = normalize(refract(refractionInDir, -enterHit.normal, 1.0 / drawingHit.material.IOR));\n            Ray refractionRay = Ray(refractionOutDir, enterHit.p + enterHit.normal * MIN_DISTANCE);\n            colorDirect = Color(refractionRay);\n        }\n        //Color direct calculation\n        if (drawingHit.material.R0 == 0.)\n        {\n            col += colorDirect;\n        }\n        \n        vec3 reflectionDir = normalize(reflect(camera.direction, drawingHit.normal));\n        vec3 reflectionColor = Color(Ray(reflectionDir, drawingHit.p + drawingHit.normal * MIN_DISTANCE));\n        float fresnelFactor = Fresnel(camera.direction, drawingHit);\n\n        //Mix of color,reflection and fresnel in order to generate the full view\n        col += mix(colorDirect, reflectionColor, fresnelFactor);\n    }\n    \n    col = col / 16.;\n    fragColor = vec4(col, 1);\n}\n","name":"Image","description":"","type":"image"}]}