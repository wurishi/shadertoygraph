{"ver":"0.1","info":{"id":"XcKSWw","date":"1715268369","viewed":97,"name":"Conditional Flow Matching WIP","username":"chronos","description":"Conditional Flow Matching WIP\nUsing Conditional Optimal Transport flow.","likes":11,"published":1,"flags":32,"usePreview":0,"tags":["generative","flow","diffusion","equation","pde","differential","matching","conditional","transport","ode","probability","optimal","iadb"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n/*\n    Conditional Flow Matching by chronos\n    --------------------------------------------------------------\n    \n    Work In Progress version.\n    \n    Here I try to experiment with a method for generative distribution sampling\n    based on flow matching.\n    More specifically based on Conditional Optimal Transport Flow Matching.\n    \n    The \"optimal transport\" refers to the analytical optimal transport of a standard normal distribution\n    for the conditional flow.\n    \n    The resulting flow is marginalized (integrated) over the conditional flows.\n    \n    Note that the resulting flow is NOT an optimal transport flow!\n    \n    self link: https://www.shadertoy.com/view/XcKSWw\n    \n    \n    \n    \n    Based on :\n    Flow Matching: Simplifying and Generalizing Diffusion Models | Yaron Lipman\n    https://www.youtube.com/watch?v=5ZSwYogAxYg\n\n    \"FLOW MATCHING FOR GENERATIVE MODELING\"\n    Yaron Lipman (1,2), Ricky T. Q. Chen (1) Heli Ben-Hamu (2) Maximilian Nickel1 Matt Le (1)\n    1 : Meta AI (FAIR) 2 : Weizmann Institute of Science\n    https://arxiv.org/abs/2210.02747\n    https://arxiv.org/pdf/2210.02747\n*/\n\n/*\n     Notation:\n    -----------------------------------------------------------------\n    PSI = conditional flow\n    v_t = vector field at time t\n    p = probability  / source distribution\n    q = target distribution\n    xt = flow distribution point at time t\n    x0 = source distribution point\n    x1 = target distribution point\n\n    ODE\n    Speed of trajectory = derivative of x_t = v_t ( x_t )\n\n    Continuity Equation PDE\n    derivative of p_t = -div(p_t v_t)\n\n    Change of probability wrt time, at a fixed point, namely\n    the flux of ingoing and outgoing probability\n\n    Marginal path:\n    p_t(x) = integral of p_t(x|x_1) q(x1) dx1\n\n    u_t(x) = integral of u_t(x|x_1) p_t(x|x1) q(x1) / p_t(x) dx1\n\n    Conditional Optimal Transport paths example:\n\n    p_t(x | x1) = Normal(t*x_1, (1.-t)^2 I)\n\n    u_t(x | x1) = (x1 - x) / (1.-t)\n\n    PSI_t (x0 | x1) = (1.-t) * x0 + t*x1\n\n\n    ----------------------------------------------------\n\n    for COT paths and uniform constant target q, marginal paths become\n\n    p_t(x) = integral of Normal(t*x_1, (1.-t)^2 I) dx1\n\n    u_t(x) = integral of (x1 - x) / (1.-t) Normal(t*x_1, (1.-t)^2 I) / p_t(x) dx1\n\n    or:\n\n        u_t(x) = \n\n            integral of   (x1 - x) / (1.-t) Normal(t*x_1, (1.-t)^2 I)   dx1\n            -----------------------------------------------------------\n                    integral of   Normal(t*x_1, (1.-t)^2 I)   dx1\n\n\n*/\n\nvec4 draw_target_shape(vec4 fragColor, vec2 fragCoord)\n{\n    vec2 uv = pixel_to_uv(fragCoord, iResolution.xy);\n#if SCENE == 4\n    float sdf1 = circle_sdf(uv, circle_center1, circle_radius1);\n    float sdf2 = circle_sdf(uv, circle_center1, circle_radius1*.5);\n    float sdf3 = circle_sdf(uv, circle_center2, circle_radius2);\n    float sdf4 = circle_sdf(uv, circle_center2, circle_radius2*.5);\n    float alpha1 = min(sdf1, sdf3);\n    float alpha2 = min(sdf2, sdf4);\n    alpha1 = smoothstep( 2./iResolution.y, 0., abs(alpha1) );\n    alpha2 = smoothstep( 2./iResolution.y, 0., abs(alpha2) );\n    float alpha = max(alpha1, alpha2);\n    return mix(fragColor, vec4(1), alpha);\n#else\n    float sdf1 = circle_sdf(uv, circle_center1, circle_radius1);\n    float sdf2 = circle_sdf(uv, circle_center2, circle_radius2);\n    float alpha1 = abs(sdf1);\n    float alpha2 = abs(sdf2);\n    float alpha = min(alpha1, alpha2);\n#endif\n    return mix(fragColor, vec4(1), smoothstep( 2./iResolution.y, 0., alpha ) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float scale = 1.;\n    vec2 uv = scale * (2. * fragCoord-iResolution.xy)/iResolution.y;\n    vec2 mouse = scale * (2. * iMouse.xy-iResolution.xy)/iResolution.y;\n    float ps = scale * 2. / iResolution.y;\n    \n    vec3 color = vec3(0);\n\n    vec2 grid_id = floor(uv*4.)/4.;\n    vec2 grid_uv = fract(uv*4.);\n    \n    float arrow_scale = 0.125;   \n    \n    const int num_samples = 500;\n    float time = clamp(iTime / time_scale, 0., .99);\n    \n    float T = floor(time);\n    float t = fract(time);\n    float p_t = 0.;\n    vec2 u_t = vec2(0);\n    for(int i = 0; i < num_samples; i++)\n    {\n        vec2 Hash = hash2( vec2(T, i));\n        vec2 source_sample = sample_source_distribution(Hash)*scale;\n        vec2 target_sample = sample_target_distribution(Hash)*scale;\n\n        vec2 x0 = source_sample;\n        vec2 x1 = target_sample;\n        \n        vec2 x = uv;\n\n        // p_t(x | x1) = Normal(t*x1, (1.-t)^2 I)\n        float p_t_cond = normal_dist(t * x1, (1.-t)*(1.-t)*mat2(1.), uv);\n\n        // u_t(x | x1) = (x1 - x) / (1.-t)\n        vec2 u_t_cond = (x1 - x) / (1.-t);\n        \n        u_t += u_t_cond * p_t_cond;\n\n        // PSI_t (x0 | x1) = (1.-t) * x0 + t*x1\n        /*\n        vec2 PSI = mix(x0, x1, t);\n\n        float thickness = 0.01;\n        vec2 a = .5 + (target_sample - (grid_id + 0.5/4.) ) / (1.-t) * arrow_scale;\n        vec2 b = .5 - (target_sample - (grid_id + 0.5/4.) ) / (1.-t) * arrow_scale;\n        float dist = seg(a, b, grid_uv);\n        float alpha = smoothstep(thickness+ps, thickness-ps, dist);\n        color = mix(color, vec3(0.5), alpha/float(num_samples));\n        color = mix(color, vec3(0.5), smoothstep(0.01+ps, 0.01-ps, length(PSI-uv)));\n        */\n        \n        p_t += p_t_cond;\n        \n        \n    }\n    \n    //p_t /= float(num_samples);\n    //u_t /= float(num_samples);\n    //u_t /= max(p_t, 1e-6);\n    \n    // In this order the divisions by num_samples cancels out in u_t\n    //u_t /= max(p_t, 1e-6);\n    p_t /= float(num_samples);\n    \n    color += p_t * vec3(0.15, 0.3, 0.7);\n    //color += dir_to_color(u_t) * .025;\n        \n    color += texture(iChannel1, fragCoord/iResolution.xy).rgb;\n    \n    vec4 target_shape = draw_target_shape(vec4(color, 1.), fragCoord);\n    color = target_shape.rgb;\n    \n    color = pow(color, vec3(1./2.2));\n    fragColor = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"\nconst int num_particles = 200;\n\nconst float PI = 3.14159265;\n\nconst float time_scale = 8.;\nconst float frame_rate = 60.;\n\n// Shape parameters\n\n#define SCENE 4\n\n#if SCENE == 0\n\n// Two discs aside\nconst float circle_radius1 = .25; \nconst float circle_radius2 = .25; \nvec2 circle_center1 = vec2(1.25, .1 );\nvec2 circle_center2 = vec2(1.05, .65 );\n\n#elif SCENE == 1\n\n// Two discs colinear\nconst float circle_radius1 = .25; \nconst float circle_radius2 = .25; \nvec2 circle_center1 = vec2(1.3, .55 );\nvec2 circle_center2 = vec2(.7, .2 );\n\n#elif SCENE == 2\n\n// Annulus\nconst float circle_radius1 = .5; \nconst float circle_radius2 = .25; \nvec2 circle_center1 = vec2(1., .4 );\nvec2 circle_center2 = vec2(1., .4 );\n\n#elif SCENE == 3\n\n// Two discs overlapping\nconst float circle_radius1 = .45; \nconst float circle_radius2 = .45; \nvec2 circle_center1 = vec2(1.25, .1 );\nvec2 circle_center2 = vec2(1.05, .5 );\n\n#elif SCENE == 4\n\n// Two annuluses overlapping (annuli? annulodes? :D)\nconst float circle_radius1 = .35; \nconst float circle_radius2 = .35; \nvec2 circle_center1 = vec2(1.275, .05 );\nvec2 circle_center2 = vec2(1.00, .5 );\n\n#else\n\n#endif\n   \nconst float radius = .50;              // disc( (c,c), r ) to square [0,2r]Â²\nvec2 box_center = vec2(-.75, -.45 );\n\n\n// Gamma / sRGB\n\nconst float GAMMA = 2.2;\n\nvec4 gamma_correct( vec3 color )\n{\n    return vec4(pow(clamp(color, 0., 1.), vec3(1./GAMMA)), 1.);\n}\n\n// Noise functions\n\nuint hash(uint x, uint y)\n{\n    y ^= y >> 13;\n    y ^= y << 17;\n    y ^= y >> 5;\n    y *= 0x2545F491u;\n\n    x ^= y;\n    x ^= x >> 13;\n    x ^= x << 17;\n    x ^= x >> 5;\n    x *= 0x4F6CDD1Du;\n    \n    return x;\n}\n\nfloat hash(vec2 uv)\n{\n    uint x = floatBitsToUint(uv.x) | 1u;\n    uint y = floatBitsToUint(uv.y);\n    \n    y ^= y >> 13;\n    y ^= y << 17;\n    y ^= y >> 5;\n    y *= 0x2545F491u;\n\n    x ^= y;\n    x ^= x >> 13;\n    x ^= x << 17;\n    x ^= x >> 5;\n    x *= 0x4F6CDD1Du;\n    \n    uint z = ((x>>9) & 0x007FFFFFu) | (0xFF800000u & floatBitsToUint(.5));\n    \n    return 2. * uintBitsToFloat(z) - 1.;\n}\n\nvec2 hash2(vec2 uv)\n{\n    float x = hash(uv);\n    float y = hash(uv + vec2(x, 0.));\n    return vec2(x,y);\n}\n\n// SDF functions\n\nfloat circle_sdf(vec2 p, vec2 circle_center, float circle_radius) { return length(p - circle_center) - circle_radius; }\n\nfloat square_sdf(vec2 p, vec2 square_center, float box_radius)\n{ \n    vec2 f = abs(p-square_center) - box_radius;\n    return (f.x >= 0. && f.y >= 0.) ? length(f) : max(f.x, f.y);\n}\n\n// Pixel and UV helper functions\nvec2 pixel_to_uv(vec2 fragCoord, vec2 iResolution) { return (2. * fragCoord.xy - iResolution.xy) / iResolution.y; }\nvec2 uv_to_pixel(vec2 uv, vec2 iResolution) { return 0.5 * (uv.xy * iResolution.y + iResolution.xy); }\nvec2 uncentered_to_centered_uv(vec2 uncentered_uv, vec2 iResolution) { return 2.*(uncentered_uv-.5) * vec2(iResolution.x / iResolution.y, 1.); }\nvec2 centered_to_uncentered_uv(vec2 centered_uv, vec2 iResolution) { return .5*(centered_uv / vec2(iResolution.x / iResolution.y, 1.)+1.); }\n\n// Distribution functions\n\n// float source_distribution_pdf(vec2 x) { return 1.; } // Unused for now\n// float target_distribution_pdf(vec2 x) { return 1.; } // Unused for now\n\nvec2 sample_source_distribution(vec2 hash)\n{   \n    //return (2.*radius * hash) + (box_center-radius);\n    \n    float U0 = hash.x;//(vec3(0., float(i), iFrame));\n    float U1 = hash.y;//(vec3(1., float(i), iFrame));\n        \n    return sqrt(\n            -2. * log(U0)\n        ) * vec2(cos(2. * PI * U1), sin(2.*PI*U1));\n}\n\nvec2 sample_target_distribution(vec2 hash)\n{\n#if SCENE == 2\n    float angle = 2.* PI * hash.y;\n    float radius = sqrt(hash.x*(circle_radius1*circle_radius1-circle_radius2*circle_radius2)+circle_radius2*circle_radius2);\n    return circle_center1 + radius * sqrt(hash.x) * vec2(cos(angle), sin(angle));   \n    \n#elif SCENE == 4\n\n    int circle_idx = int(hash.x > .5);\n    vec2 circle_center = circle_idx == 0 ? circle_center1 : circle_center2;\n    float circle_radius = circle_idx == 0 ? circle_radius1 : circle_radius2;\n    \n    float R1 = circle_radius;\n    float R2 = circle_radius * .5;\n    \n    float rnd = 2. * hash.x - float(circle_idx == 1); \n    float R = sqrt(rnd*(R1*R1 - R2*R2) + R2*R2);\n    \n    float angle = 2.* PI * hash.y;\n    return circle_center + R * vec2(cos(angle), sin(angle));\n    \n#else\n    int circle_idx = int(hash.x > .5);\n    vec2 circle_center = circle_idx == 0 ? circle_center1 : circle_center2;\n    float circle_radius = circle_idx == 0 ? circle_radius1 : circle_radius2;\n    float angle = 2.* PI * hash.y;\n    return circle_center + circle_radius * sqrt(hash.x) * vec2(cos(angle), sin(angle));\n#endif\n}\n\nbool is_inside_source_distribution(vec2 position)\n{\n    return square_sdf(position, box_center, radius) < 0.;\n}\n\nbool is_inside_target_distribution(vec2 position)\n{\n#if SCENE == 2 \n    return \n        circle_sdf(position, circle_center1, circle_radius1) < 0.\n        &&\n        circle_sdf(position, circle_center2, circle_radius2) > 0.\n        ;\n    \n#elif SCENE == 4        \n       return \n       (\n        circle_sdf(position, circle_center1, circle_radius1) < 0.\n        &&\n        circle_sdf(position, circle_center1, circle_radius1*.5) > 0.\n       )\n       ||\n       (\n        circle_sdf(position, circle_center2, circle_radius2) < 0.\n        &&\n        circle_sdf(position, circle_center2, circle_radius2*.5) > 0.\n       )\n        ; \n#else\n      return \n        circle_sdf(position, circle_center1, circle_radius1) < 0.\n        ||\n        circle_sdf(position, circle_center2, circle_radius2) < 0.\n        ;  \n#endif\n}\n\n\n\n/// New in this shader:\n\n\nfloat normal_dist(vec2 mean, mat2 cov, vec2 p)\n{\n    p -= mean;\n    \n    return exp(-.5*dot(p, inverse(cov)*p)) / (2. * PI * sqrt(determinant(cov)) );\n}\n\nvec3 dir_to_color(vec2 dir)\n{\n    vec2 st = normalize(dir);\n    return tanh(length(dir)) * vec3(st, sqrt(max(1.-dot(st,st), 0.)))* .5 + .5;\n}\n\nfloat seg(vec2 a, vec2 b, vec2 p)\n{\n    b-=a; p-=a;\n    return length(clamp(dot(p, b)/dot(b,b), 0., 1.) * b -p);\n}\n\n\nvec3 get_flow(vec2 x, float time)\n{\n    const int num_samples = 500;\n    float T = floor(time);\n    float t = fract(time);\n    float p_t = 0.;\n    vec2  u_t = vec2(0);\n    \n    mat2 covariance = (1.-t)*(1.-t)*mat2(1.); \n    \n    for(int i = 0; i < num_samples; i++)\n    {\n        vec2 Hash = hash2( vec2(T, i));\n        vec2 source_sample = sample_source_distribution(Hash);\n        vec2 target_sample = sample_target_distribution(Hash);\n\n        vec2 x0 = source_sample;\n        vec2 x1 = target_sample;\n\n        // p_t(x | x1) = Normal(t*x1, (1.-t)^2 I)\n        float p_t_cond = normal_dist(t * x1, covariance, x);\n\n        // u_t(x | x1) = (x1 - x) / (1.-t)\n        vec2 u_t_cond = (x1 - x) / (1.-t);\n        \n        u_t += u_t_cond * p_t_cond;\n\n        // PSI_t (x0 | x1) = (1.-t) * x0 + t*x1\n        vec2 PSI = mix(x0, x1, t);\n\n        p_t += p_t_cond;\n    }\n    \n    //p_t /= float(num_samples);\n    //u_t /= float(num_samples);\n    //u_t /= max(p_t, 1e-6);\n    \n    // In this order the divisions by num_samples cancels out in u_t\n    u_t /= max(p_t, 1e-6);\n    p_t /= float(num_samples);\n    \n    return vec3(u_t, p_t);\n}\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"/*\n// based on :\n// Flow Matching: Simplifying and Generalizing Diffusion Models | Yaron Lipman\n// https://www.youtube.com/watch?v=5ZSwYogAxYg\n\n// PSI = conditional flow\n// v_t = vector field at time t\n// p = probability  / source distribution\n// q = target distribution\n// xt = flow distribution point at time t\n// x0 = source distribution point\n// x1 = target distribution point\n\n// bookmark timestamp: https://youtu.be/5ZSwYogAxYg?t=2198\n\n// ODE\n// Speed of trajectory = derivative of x_t = v_t ( x_t )\n\n\n// Continuity Equation PDE\n// derivative of p_t = -div(p_t v_t)\n\n// Change of probability wrt time, at a fixed point, namely\n// the flux of ingoing and outgoing probability\n\n// Marginal path\n// p_t(x) = integral of p_t(x|x_1) q(x1) dx1\n\n// u_t(x) = integral of u_t(x|x_1) p_t(x|x1) q(x1) / p_t(x) dx1\n\n// Conditional Optimal Transport paths example:\n\n// p_t(x | x1) = Normal(t*x_1, (1.-t)^2 I)\n\n// u_t(x | x1) = (x1 - x) / (1.-t)\n\n// PSI_t (x0 | x1) = (1.-t) * x0 + t*x1\n\n\n// ----------------------------------------------------\n\nfor COT paths and uniform constant target q, marginal paths become\n\np_t(x) = integral of Normal(t*x_1, (1.-t)^2 I) dx1\n\nu_t(x) = integral of (x1 - x) / (1.-t) Normal(t*x_1, (1.-t)^2 I) / p_t(x) dx1\n\nor:\n\n    u_t(x) = \n    \n        integral of   (x1 - x) / (1.-t) Normal(t*x_1, (1.-t)^2 I)   dx1\n        -----------------------------------------------------------\n                integral of   Normal(t*x_1, (1.-t)^2 I)   dx1\n\n\n*/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float scale = 1.;\n    vec2 uv = scale * (2. * fragCoord-iResolution.xy)/iResolution.y;\n    \n    float time = clamp(iTime / time_scale, 0., 1.);\n    \n    vec3 color = vec3(0);\n\n    vec2 particle_pos = texelFetch(iChannel0, ivec2(fragCoord), 0).rg;\n\n    if(time < 1.)\n    {\n        if(iFrame == 0)\n        {\n            particle_pos = sample_source_distribution(hash2(fragCoord));\n        }\n        else\n        {\n            particle_pos += get_flow(particle_pos, time).xy / (frame_rate*time_scale);\n        }\n    }\n    \n    fragColor = vec4(particle_pos, 0, 1.0);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float scale = 1.;\n    vec2 uv = scale * (2. * fragCoord-iResolution.xy)/iResolution.y;\n    vec2 mouse = scale * (2. * iMouse.xy-iResolution.xy)/iResolution.y;\n    float ps = scale * 2. / iResolution.y;\n    \n    vec3 color = vec3(0);\n    \n    vec3 prev_color = texture(iChannel1, fragCoord/iResolution.xy).rgb;\n    \n    float time = clamp(iTime / time_scale, 0., 1.);\n    if(time < 1.)\n    {\n        for(int i = 0; i < num_particles; i++)\n        {\n\n            vec2 particle_pos = texelFetch(iChannel0, ivec2(i,0), 0).rg;\n            color += 0.05 * smoothstep(0.01, 0.0001, length(particle_pos-uv));\n\n        }\n        prev_color *= .99;\n    }\n    color += prev_color;\n    \n    fragColor = vec4(color,1.0);\n}","name":"Buffer B","description":"","type":"buffer"}]}