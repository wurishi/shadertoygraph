{"ver":"0.1","info":{"id":"wssSRj","date":"1552245251","viewed":84,"name":"Mashgraf_01","username":"aorlova","description":"Основная часть","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["k"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"struct Ray \n{\n    vec3 origin;\n    vec3 dir;  \n};\n\nstruct Light \n{\n    vec3 color;\n    vec3 dir;     \n};\n    \nstruct Material \n{\n    vec3 color;\n    float diffuse;\n    float specular;\n};\n\nstruct Intersect \n{\n    float len;\n    vec3 nl;  \n    Material materl;\n};\n\nstruct Sphere \n{\n    float radius;\n    vec3 pos;    \n    Material materl;\n};\n\nstruct Cone\n{\n\tfloat cosa;\t   \n    float height;\n    vec3 tippos;\n    vec3 axis;\n    Material materl;\n};\n    \nstruct Box \n{\n    vec3 tmin;\n    vec3 tmax;\n    Material materl;\n};\n    \nstruct Plane \n{\n    vec3 nl;\n    Material materl;\n};\n\n \n//////////////////////////////////////////////////\n    \nconst float eps = 0.001;\n\nconst float pi = 3.141519;\n\nconst int Const = 1500;\n\nconst vec3 ambient = vec3(0.2, 0.2, 0.5) * 20.0;\nconst Intersect miss = Intersect(0.0, vec3(0.0),\n                                 Material(vec3(0.3), 0.0, 0.0));\n\n//////////////////////////////////////////////////\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\n\nvec3 Axis(out vec3 axis)\n{\n    float pi2 = 2.0 * pi;\n    float sina = sqrt(0.0);\n    float cosa = sqrt(1.0);\n    vec3 ax = vec3(cos(pi2) * sina, cosa, sin(pi2) * sina);\n    axis = normalize(mix(ax, ax, 100.0));\n    return axis;\n}\n\nIntersect intersect(Ray ray, Sphere sphere) \n{\n    vec3 oc = sphere.pos - ray.origin;\n    float l = dot(ray.dir, oc);\n    float det = pow(l, 2.0) - dot(oc, oc) + pow(sphere.radius, 2.0);\n    if (det < 0.0) \n    {\n        return miss;\n    }\n    float len = l - sqrt(det);\n    if (len < 0.0) \n    {\n        len = l + sqrt(det);\n    }\n    if (len < 0.0)\n    {\n        return miss;\n    }\n    \n    vec3 normal = (ray.origin + len*ray.dir - sphere.pos) / sphere.radius;\n    \n    return Intersect(len, \n                     normal,\n                     sphere.materl);\n}\n\nIntersect intersect(Ray ray, Box box, out vec3 normal)\n{\n    vec3 boxCenter = (box.tmin+box.tmax)*0.5;\n\tvec3 roo = ray.origin - boxCenter;\n    vec3 boxSize = (box.tmax - box.tmin)*0.5;\n    \n    vec3 m = 1.0/ray.dir;\n    vec3 n = m*roo;   \n    vec3 k = abs(m)*boxSize;\n\t\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n\t\n    if( tN > tF)\n    {\n        return miss;\n    }\n    if(tF < 0.0) \n    {\n        return miss;\n    }\n    \n    normal = -sign(ray.dir)*step(t1.yzx,t1.xyz)*step(t1.zxy,t1.xyz);\n    \n    vec3 d = abs(boxCenter) - boxSize;\n    float len = min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n    \n    return Intersect(len, \n                     normal, \n                     box.materl);\n}\n\nIntersect intersect(Ray ray, Plane plane) \n{\n    float len = -dot(ray.origin, plane.nl) / dot(ray.dir, plane.nl);\n    if (len < 2.0) \n        return miss;\n    return Intersect(len,\n                     plane.nl,\n                     plane.materl);\n}\n\nIntersect intersect(Ray ray, Cone cone)\n{\n    vec3 co = ray.origin - cone.tippos;\n    \n    float a = dot(ray.dir, cone.axis) * dot(ray.dir, cone.axis)\n        - cone.cosa * cone.cosa;\n    float b = 2.0 * (dot(ray.dir, cone.axis) * dot(co, cone.axis)\n                     - dot(ray.dir, co) * cone.cosa * cone.cosa);\n    float c = dot(co, cone.axis) * dot(co, cone.axis) \n        - dot(co, co) * cone.cosa * cone.cosa;\n    \n    float det = b*b - 4.0*a*c;\n    if (det < 0.0)\n    {\n        return miss;\n    }\n\n    det = sqrt(det);\n    \n    float t1 = (-b - det) / (2.0 * a);\n    float t2 = (-b + det) / (2.0 * a);\n\n    float len = t1;\n    if (len < 0.0 || t2 > 0.0 && t2 < len)\n    {\n        len = t2;\n    }\n    if (len < 0.0)\n    {\n        return miss;\n    }\n\n    vec3 cp = ray.origin + len*ray.dir - cone.tippos;\n    float len1 = dot(cp, cone.axis);\n    if (len1 < 0.0 || len1 > cone.height)\n    {\n        return miss;\n    }\n\n    vec3 normal = normalize(cp * dot(cone.axis, cp) / dot(cp, cp) - cone.axis);\n      \n    return Intersect(len,\n                     normal,\n                     cone.materl);\n}\n\n\n\nIntersect trace(Ray ray) \n{\n    \n    const int pieces_spheres = 4;\n    Sphere spheres[pieces_spheres];\n    \n    const int pieces_boxes = 2;\n    Box boxes[pieces_boxes];\n    \n    const int pieces_cones = 1;\n    Cone cones[pieces_cones];\n    \n    //-----------------------------------------\n    \n    spheres[0].radius = 2.0;\n    spheres[0].pos = vec3(-3.5, 3.5, -2.5);\n    spheres[0].materl = Material(vec3(0.0, 1.0, 0.35), 1.0, 0.0);\n    \n    spheres[1].radius = 3.0;\n    spheres[1].pos = vec3( 3.0, 3.0, -4.0);// + 2.0*cos(iTime));\n    spheres[1].materl = Material(vec3(0.0, 0.2, 1.0), 0.0, 0.7);\n  \n    spheres[2].radius = 1.0;\n    spheres[2].pos = vec3(-1.0, 1.0, 6.0);\n    spheres[2].materl = Material(vec3(0.002, 0.0050, 0.5), 0.5, 0.15);\n    \n    spheres[3].radius = 1.65;\n    spheres[3].pos = vec3(-2.0, 8.0, -4.0);\n    spheres[3].materl = Material(vec3(0.8, 0.8, 0.45), 1.0, 1.0);\n    \n    //----------------------------------------- \n    \n    boxes[0].tmin = vec3(1.5, 0.0, 4.5);\n    boxes[0].tmax = vec3(3.0, 0.7, 6.0);\n    boxes[0].materl = Material(vec3(1.0, 0.0, 0.0), 0.7, 0.4);\n    \n    boxes[1].tmin = vec3(-7.7,0.4,-0.2);\n    boxes[1].tmax = vec3(-4.5,4.2,2.5);\n    boxes[1].materl = Material(vec3(0.3915, 0.00125, 0.326), 0.47, 0.0);\n    \n    //----------------------------------------\n    vec3 ax = vec3(0.0);\n    \n    cones[0].cosa = 0.97;\n    cones[0].height = 5.0;\n    cones[0].tippos = vec3(6.0, 5.0, 2.0);\n    cones[0].axis = -Axis(ax);\n    cones[0].materl = Material(vec3(0.0, 0.505, 0.55), 0.6, 0.78);\n   \n    //----------------------------------------\n\n    Intersect intersection = miss;\n    Intersect plane = intersect(ray,\n                                Plane(vec3(0, 1, 0), \n                                Material(vec3(0.25, 0.2, 0.4),\n                                1.0, 0.004))); \n    \n                  \n    if (plane.materl.diffuse > 0.0)\n    { \n        intersection = plane; \n    }\n    if (plane.materl.specular > 0.0)\n    {\n        intersection = plane;\n    }\n  \n \n    for (int i = 0; i < pieces_spheres; i++) \n    {\n        Intersect sphere = intersect(ray, spheres[i]);\n        if (sphere.materl.diffuse > 0.0)\n        {\n            intersection = sphere;\n            \n        }\n        if (sphere.materl.specular > 0.0)\n        {\n            intersection = sphere;\n           \n        }\n            \n    }\n  \n    vec3 normal = vec3(0.0);  \n    for (int i = 0; i < pieces_boxes; i++) \n    {\n        Intersect box = intersect(ray, boxes[i], normal);\n        if (box.materl.diffuse > 0.0)\n        {\n            intersection = box;\n            \n        }\n        if (box.materl.specular > 0.0)\n        {\n            intersection = box;\n           \n        }\n            \n    }\n \n    for (int i = 0; i < pieces_cones; i++) \n    {\n        Intersect cones = intersect(ray, cones[i]);\n        if (cones.materl.diffuse > 0.0)\n        {\n            intersection = cones;\n            \n        }\n        if (cones.materl.specular > 0.0)\n        {\n            intersection = cones;\n           \n        }\n            \n    }\n\n    return intersection;\n}\n \n\nvec3 radiance(Ray ray) \n{\n    const int pieces_lights = 3;\n    Light lights[pieces_lights];\n    \n    lights[0].color = vec3(1.0, 1.0, 1.0) * 145.0;\n    lights[0].dir = normalize(vec3(-1.0, 4.5, 8.0));\n        \n    lights[1].color = vec3(1.0) * 150.0;\n    lights[1].dir = normalize(vec3(-0.4, 0.75, 0.1));\n    \n    lights[2].color = vec3(1.0) * 200.0;\n    lights[2].dir = normalize(vec3(0.4, 0.75, 0.1));\n    \n    \n    \n\n    vec3 color = vec3(0.0), fresnel = vec3(0.0);\n    vec3 mask = vec3(1.0);\n    for (int i = 0; i <= Const; ++i) \n    {\n        Intersect hit = trace(ray);\n        if (hit.materl.diffuse > 0.0 || hit.materl.specular > 0.0)\n        {\n            vec3 r0 = hit.materl.color.rgb * hit.materl.specular;\n            float hv = clamp(dot(hit.nl, -ray.dir), 0.0, 1.0);\n            fresnel = r0 + (1.0 - r0) * pow(1.0 - hv, 7.0);\n            mask *= fresnel;\n            if (trace(Ray(ray.origin + hit.len * ray.dir + eps *\n                          lights[0].dir, lights[0].dir)) == miss) \n            {\n                color += min(max(dot(hit.nl, lights[0].dir), 0.0), 1.0) \n                       * lights[0].color\n                       * hit.materl.color.rgb * hit.materl.diffuse\n                       * (1.0 - fresnel) * mask / fresnel;\n            }\n            if (trace(Ray(ray.origin + hit.len * ray.dir + eps *\n                          lights[1].dir, lights[1].dir)) == miss) \n            {\n                color += min(max(dot(hit.nl, lights[1].dir), 0.0), 1.0) \n                       * lights[1].color\n                       * hit.materl.color.rgb * hit.materl.diffuse\n                       * (1.0 - fresnel) * mask / fresnel;\n            }\n            if (trace(Ray(ray.origin + hit.len * ray.dir + eps *\n                          lights[2].dir, lights[2].dir)) == miss) \n            {\n                color += min(max(dot(hit.nl, lights[2].dir), 0.0), 1.0)\n                      * lights[2].color\n                      * hit.materl.color.rgb * hit.materl.diffuse\n                      *(1.0 - fresnel) * mask / fresnel;\n                    \n            }\n            vec3 reflection = reflect(ray.dir, hit.nl);\n            ray = Ray(ray.origin + hit.len * ray.dir + eps *\n                      reflection, reflection);\n        }\n        else \n        {\n            vec3 sptlight1 = vec3(1e3)\n                * pow(abs(dot(ray.dir, lights[0].dir)), 800.0);\n            vec3 sptlight2 = vec3(1e4) \n                * pow(abs(dot(ray.dir, lights[1].dir)), 500.0);\n            vec3 sptlight3 = vec3(1e4) \n                * pow(abs(dot(ray.dir, lights[2].dir)), 400.0);\n            vec3 sptlight = sptlight1 + sptlight2 + sptlight3;\n            color += mask * (ambient + sptlight); \n            \n            break;\n        }\n    }\n\n    \n    return color;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) \n{\n    vec2 xy    = fragCoord.xy / iResolution.xy - vec2(0.5);\n    xy.x *= iResolution.x / iResolution.y;\n    \n    Ray ray = Ray(vec3(0.0, 2.5, 12.0), normalize(vec3(xy.x, xy.y, -1.0)));\n    fragColor = vec4(pow(radiance(ray) * 0.0075, vec3(0.4)), 1.0);\n   \n}\n","name":"Image","description":"","type":"image"}]}