{"ver":"0.1","info":{"id":"ddB3RK","date":"1668293021","viewed":121,"name":"Magnetic Pendulum Sim","username":"zenzicubic","description":"A magnetic pendulum sim","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["physics","pendulum","art"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAXT 20.\n#define MAGS 3\n#define dt 0.01\n\n#define H 0.25\n#define G 0.2\n#define MU 0.1\n\nvec2[] mags = vec2[](\n    vec2(1, 0),\n    vec2(-0.5, 0.866),\n    vec2(-0.5, -0.866));\n\nvec3[] cols = vec3[](\n    vec3(0.702,0.247,0.384),\n    vec3(0.953,0.776,0.467),\n    vec3(0.047,0.039,0.243));\n\nint getClosestVal(vec2 p)\n{\n    float v, m = distance(p, mags[0]);\n    int i = 0;\n    for (int j = 0; j < MAGS; j ++)\n    {\n        v = distance(p, mags[j]);\n        if (v < m)\n        {\n            m = v;\n            i = j;\n        }\n    }\n    return i;\n}\n\nvec3 test(vec2 p)\n{\n    vec2 v = vec2(0.);\n    vec2 vN = vec2(0.);\n    vec2 vP = vec2(0.);\n    vec2 aP = vec2(0.);\n    vec2 a = vec2(0.);\n    \n    vec2 aN, r;\n    float d;\n    float t=0.;\n    while (t < min(iTime, MAXT))\n    {\n        p += v*dt + (dt * dt / 6.)*((4.*a)-aP);\n\n        // calculate force from magnets\n        aN = vec2(0.);\n        for (int n = 0; n < MAGS; n ++)\n        {\n            r = mags[n] - p;\n            d = dot(r, r);\n            aN += r / pow(H * H + d, 1.5);\n        }\n        aN -= (G*p + MU*v);\n        \n        // integrate\n        v += (dt/6.)*((2.*aN) + (5.*a) - aP);\n        aP = a;\n        a = aN;\n        t +=dt;\n    }\n    \n    int i = getClosestVal(p);\n    return cols[i];\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (6. * fragCoord - 3. * iResolution.xy) / iResolution.y;\n    fragColor = vec4(test(uv),1.0);\n}","name":"Image","description":"","type":"image"}]}