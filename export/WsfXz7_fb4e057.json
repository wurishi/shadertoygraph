{"ver":"0.1","info":{"id":"WsfXz7","date":"1550821500","viewed":89,"name":"Diving Seabirds","username":"teraspora","description":"A bunch of sine waves as usual!","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["birds"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.1415922653589793234\n#define PHI 1.6180339887 \n#define SQ2 1.4142135623\n/*\nShader: Diving Seabirds\nAuthor: John Lynch\nDate: February 2019\n*/\n\nfloat a = 1.9;\n\nvec3 black = vec3(0.);\nvec3 white = vec3(1.);\nvec3 orange = vec3(1., 0.8, 0.1);\nvec3 dark_blue = vec3(0.01, 0.0, 0.2);\n\nvec3 colour1 = vec3(.9, .3, .2);\nvec3 colour2 = vec3(.0, .7, .8);\nvec3 colour3 = vec3(.8, .5, .1);\nvec3 colour4 = vec3(.8, .3, .7);\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    float t = iTime / 7.;\n\tfloat a = 1.9;\n    float phi = t;\n\n    float scale = 1.4;\n    vec3 col;\n    vec2 asp = vec2(iResolution.x / iResolution.y, 1.);\n    vec2 uv = gl_FragCoord.xy / iResolution.yy - asp * .5;\n    float amp = 0.04;\n    float freq = 5.;\n    float freqx = floor(3. + 32. * nsin(t / 24.)); \n    \n    uv = sqd(uv) + uv * 3.;\n    \n    uv /= scale;\n    uv.y = -uv.y;\n    float uvy = uv.y;\n\t// make waves\n    uv.y += 0.15 * cos(16. * (uv.x + 0.1 * sin(t / 5.)))  + 0.04 * cos(12. * uv.x);\n    uv.x += 0.15 * cos(16. * uvy)   + 0.02 * cos(12. * uvy);    \n\n    col = mix(vec3(.2, .9, .6), vec3(.9, .3, .2), nsin(pow(length(uv), exp2(1. * nsin(t / 4.) * length(uv))))) / 2.;\n    float cdelta = mod(t, 15.) / 15.;\n    col = changeHue(col, fract(hue(col) + cdelta)); \n    \n    float birds = 0.;\n    for (int i = 0; i < 6; i++) {\t// make 6 birds with differing orbits\n        vec2 offset = gn2(vec2(float(i) * 91., 1049. / (float(i) + 100.)), float(float(i) * 103.61)) * asp - asp / 2.;\n        if (mod(float(i), 2.) < .5) {\n            offset += vec2(sin(t  / 2. * (float(i) + 1.)), cos(t / 3. * (float(i) + 1.)));      // Ellipse[-ish]\n        }\n        else if (mod(float(i), 3.) < 0.5) {\n            offset = vec2(polar(a * sin(2. * phi), phi)) * asp * 0.67 * nsin(mod(t / 8., 240.));     // Quadrifolium\n        }\n        else if (mod(float(i), 5.) < 0.5) {\n            offset = 0.5 * vec2(3. * cos(phi) - cos(3. * phi), 3. * sin(phi) + sin(3. * phi)) * asp * 0.67 * nsin(mod(t / 2., 240.));     // Astroid\n        }\n        else {\n            offset = clamp(vec2(a * sin(phi), a * sin(phi) * cos(phi)) * asp * 0.75 * nsin(mod(t / 24., 640.)), vec2(0.1), vec2(2.0));     // Gerono lemniscate\n        }\n\n        float yb = yawingBird(uv + offset, clamp(4. * rand2(vec2(float(i) * 37., 2051. / (float(i) + 89.))).x * nsin(t * float(i) * 2.), 0.4, 2.));\n        \n        birds += yb;\n    }\n    col *= birds * 3.;\n    \n    if (length(col) < .9) {\n        col = dark_blue;\t// night sky\n        // waves, vegetation etc.\n        if (uv.y > .1 + 0.06 * sin((t + mod((uv.x + sin(t / 5.)) * 6. , 0.4)) * 5.) && uv.y < 1.2 + 0.23 * sin((t / 4. + mod(uv.x * 9. , 0.2)) * 7.)) \n            col = mix(orange, dark_blue, (uv.y - .2 + 0.01 * sin(t / 5. * uv.x)) * 1.);\n    }\n    cdelta = mod(t, 9.1) / 9.1;\n    if (col != dark_blue) col = changeHue(col, fract(hue(col) + cdelta)); \n    col *= 1.;\n    if (length(col) > 1.25) col = 0.5 + 0.5 * cos(iTime + uv.yxy + vec3(2, 0,4));\n    col = saturate(col);\n    col *= borderRadius(fragCoord.xy, iResolution.xy, length(iResolution.xy) * 0.166);\n    fragColor = vec4(col,1.0);\n}  ","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define PI 3.1415922653589793234\n#define PHI 1.6180339887 \n#define SQ2 1.4142135623\n// Gold Noise Â©2015 dcerisano@standard3d.com\nfloat gold_noise(in vec2 coord, in float seed) {\n    return fract(tan(distance(coord * (seed + PHI), vec2(PHI, PI))) * SQ2);\n}\n\nvec2 gn2(in vec2 v, in float seed) {\n    return vec2(gold_noise(v, seed), gold_noise(v.yx, seed));\n}\n\n// Some functions adapted from Github - \n// https://github.com/tobspr/GLSL-Color-Spaces/blob/master/ColorSpaces.inc.glsl\nvec3 hue2rgb(float hue)\n{\n    float R = abs(hue * 6. - 3.) - 1.;\n    float G = 2. - abs(hue * 6. - 2.);\n    float B = 2. - abs(hue * 6. - 4.);\n    return clamp(vec3(R,G,B), 0., 1.);\n}\n\n// Converts a value from linear RGB to HCV (Hue, Chroma, Value)\nvec3 rgb2hcv(vec3 rgb) {\n    // Based on work by Sam Hocevar and Emil Persson\n    vec4 P = (rgb.g < rgb.b) ? vec4(rgb.bg, -1.0, 2.0/3.0) : vec4(rgb.gb, 0.0, -1.0/3.0);\n    vec4 Q = (rgb.r < P.x) ? vec4(P.xyw, rgb.r) : vec4(rgb.r, P.yzx);\n    float C = Q.x - min(Q.w, Q.y);\n    float H = abs((Q.w - Q.y) / (6. * C + 1.e-10) + Q.z);\n    return vec3(H, C, Q.x);\n}\n\n// Converts from HSL to linear RGB\nvec3 hsl2rgb(vec3 hsl) {\n    vec3 rgb = hue2rgb(hsl.x);\n    float C = (1. - abs(2. * hsl.z - 1.)) * hsl.y;\n    return (rgb - 0.5) * C + hsl.z;\n}\n\n// Converts from linear rgb to HSL\nvec3 rgb2hsl(vec3 rgb) {\n    vec3 HCV = rgb2hcv(rgb);\n    float L = HCV.z - HCV.y * 0.5;\n    float S = HCV.y / (1. - abs(L * 2. - 1.) + 1.e-10);\n    return vec3(HCV.x, S, L);\n}\n\n// Colour fns.:\nfloat hue(vec3 col) {\n    return rgb2hsl(col).s;\n}\n\nvec3 changeHue(vec3 col, float newHue) {\n    vec3 colHSL = rgb2hsl(col);\n    colHSL.s = newHue;\n    return hsl2rgb(colHSL);\n}\n    \nfloat lightness(vec3 col) {\n    return rgb2hsl(col).b;\n}\n\nvec3 changeLightness(vec3 col, float newLightness) {\n    vec3 colHSL = rgb2hsl(col);\n    colHSL.p = newLightness;\n    return hsl2rgb(colHSL);\n}\n    \nvec3 saturate(vec3 col) {\n    vec3 colHSL = rgb2hsl(col);\n    colHSL.t = 1.0;\n    return hsl2rgb(colHSL);    \n}\n\n// vec2 nmouse() {\n//    return iMouse.xy / iResolution.xy;\n// }\n\nfloat om(float x) {     // one minus x\n    return 1. - x;\n}\n\nvec3 om(vec3 v) {       // one minus v\n    return 1. - v;\n}\n\nfloat op(float x) {     // one plus x \n    return 1. + x;\n}\n\n// Normalised trig fns.:\nfloat nsin(float x) {\n    return op(sin(x)) * 0.5;\n}\n\nfloat ncos(float x) {\n    return op(cos(x)) * 0.5;\n}\n\nfloat arg(vec2 z) {\n    return atan(z.y, z.x);\n}\n\nvec2 polar(float r, float phi) {\n    return vec2(r * cos(phi), r * sin(phi));\n}\n\nvec2 times(vec2 v, vec2 w) {\n    return vec2(v.x * w.x - v.y * w.y, v.x * w.y + v.y * w.x);\n}\n\nvec2 rotate(vec2 v, float phi) {\n    return times(v, polar(1.0, phi)) ;\n}\n\nvec2 trt(vec2 v, vec2 offset, float phi) {\n    return rotate(v - offset, phi) + offset;\n}\n\nfloat sec(float theta) {\n    return 1. / cos(theta);\n}\n\nfloat iden(float x) {\n    return x;\n}\n\nfloat discus(vec2 v, float offset, float r) {\n    vec2 voff = vec2(0.0, offset); \n    float d = step(length(v - voff), r) * step(length(v + voff), r) * step(length(v - voff - 0.06), r) * step(length(v + voff + 0.06), r);\n    return d;\n}\n\nfloat bird(vec2 v) {\n    return discus(v + vec2(0.25, 0.0), 0.28, 0.4) + discus(v - vec2(0.25, 0.0), 0.28, 0.4) + step(length(v), 0.09) \n     - step(length(v), 0.02);\n}\n\nfloat yawingBird(vec2 v, float phi) {\n    return bird(rotate(v, phi));\n} \n\n// from IQ:\nvec2 rand2( vec2 p ) {\n    return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\nfloat borderRadius(vec2 v, vec2 res, float size) {\n    // Multiply this by the colour; note, uses global vars/uniforms; could modify to take a general vector and resolution as args.\n    float p = 1. - step(v.x, size) * step(v.y, size) * step(size, distance(v.xy, vec2(size)));\n    vec2 u = vec2(v.x, res.y - v.y);\n    p *= 1. - step(u.x, size) * step(u.y, size) * step(size, distance(u.xy, vec2(size)));\n    u = vec2(res.x - v.x, v.y);\n    p *= 1. - step(u.x, size) * step(u.y, size) * step(size, distance(u.xy, vec2(size)));\n    u = vec2(res.x - v.x, res.y - v.y);\n    p *= 1. - step(u.x, size) * step(u.y, size) * step(size, distance(u.xy, vec2(size)));\n    return p;\n}\n\n\nvec2 sqd(vec2 z) {\n    return times(z, z);\n}\n\nhighp vec2 f0(vec2 z, vec2 w) {\n    return sqd(z) + w;\n}\n","name":"Common","description":"","type":"common"}]}