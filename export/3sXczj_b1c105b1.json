{"ver":"0.1","info":{"id":"3sXczj","date":"1585219194","viewed":227,"name":"Triangles - amhall","username":"amhall","description":"My rendition of a cool fractal my friend drew. See the TODOs in the code to try texture background mode or speed up performance.","likes":9,"published":1,"flags":0,"usePreview":0,"tags":["2d","fractal","triangles"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Created by Anthony Hall, March - July 2020\n// The background can be replaced by a sampled texture which is pretty neat - \n// see getBackgroundColor\n\n// Reducing supersampling is the best way to improve performance\n// Disabling the rendering of the secondary triangles (line 57)\n// also speeds things up quite a bit\n\nconst float pi = radians(180.0);\nconst float twoPi = 2.0 * pi;\nconst float sqrt3 = sqrt(3.0);\n\nconst int SUPERSAMPLE = 2; // Decrease to speed things up, increase to reduce aliasing\nconst float increment = 1.0 / float(SUPERSAMPLE);\nconst float offset = increment / 2.0 - 0.5;\n\n// Primary triangles are the big ones that recurse on the whole scene\n// Secondary triangles are the accessory ones that recurse just on themselves and glow\n// This distinction and the large amount of globals they need lead to some long names\n\nconst float borderWidth = 0.0022;\n\n// Parameters for primary recursion\nconst int maxIterations = 12; // This does not include iterations that are skipped when it zooms in\nfloat scalePerIteration; // set in mainImage\nfloat anglePerIteration; // set in mainImage\nfloat zoom; // set in mainImage\n\n// This is how long it takes to complete a cycle\n// for the zoom amount per iteration\n// The overall zoom takes twice as long as this\nfloat secondsPerIteration = 30.0;\n\n// Primary triangle geometry\nconst float primaryLength = 0.72; // side length\nconst float primaryRadius = 0.7; // radius of triangle center from origin\n\n// The angle offset that the first triangle will be\n// Other triangles are 120 degrees apart\nconst float primaryAngleOffset = 30.0;\n\nconst vec2[] triangleCenters = vec2[](\n\tvec2(0.0, 0.0),\n    \n\tprimaryRadius * vec2(\n        cos(radians(primaryAngleOffset)),\n        sin(radians(primaryAngleOffset))),\n    \n\tprimaryRadius * vec2(\n        cos(radians(primaryAngleOffset + 120.0)),\n        sin(radians(primaryAngleOffset + 120.0))),\n    \n\tprimaryRadius * vec2(\n        cos(radians(primaryAngleOffset + 240.0)),\n\t\tsin(radians(primaryAngleOffset + 240.0))));\n\n// Parameters for secondary recursion\nconst bool renderSecondaryTriangles = true; // TODO Set to false to only render primary triangles - this greatly speeds up rendering\nconst int secondaryIterations = 3; // Iterations of the secondary triangle\nconst float secondaryShrinkage = 1.0 / float(secondaryIterations); // The linear shrinkage per iteration\n\nconst float secondaryLength = 0.25;\nconst float secondaryRadius = 0.82;\nconst float secondaryMirrorOffset = secondaryLength * 0.8;\n\n// Angle offset that the first secondary triangle will be\nconst float secondaryAngleOffset = 90.0;\n\nvec2[] secondaryTriangleCenters = vec2[](\n    secondaryRadius * vec2(\n        cos(radians(secondaryAngleOffset)),\n\t\tsin(radians(secondaryAngleOffset))),\n\n    secondaryRadius * vec2(\n        cos(radians(secondaryAngleOffset + 120.0)),\n    \tsin(radians(secondaryAngleOffset + 120.0))),\n\n\tsecondaryRadius * vec2(\n        cos(radians(secondaryAngleOffset + 240.0)),\n\t\tsin(radians(secondaryAngleOffset + 240.0))));\n\n\n// Oscillates between min and max based on some function of time\n// Starts at min when time is 0\nfloat oscillate(float min, float max, float time) {\n\tfloat halfInterval = (max - min) / 2.0;\n\tfloat middle = min + halfInterval;\n\treturn middle - halfInterval * cos(time);\n}\n\n// Returns 2D rotation matrix of angle in degrees\nmat2 getRotationMatrix(float degrees) {\n    float rads = radians(degrees);\n    vec2 cs = vec2(cos(rads), sin(rads));\n\treturn mat2(cs.x, -cs.y,\n                cs.y, cs.x);\n}\n\n// Thanks for all the distance functions iq\n// Modified to support rotated triangles\nfloat sdEquilateralTriangle(vec2 point, vec2 center, float angle, float sideLength)\n{\n    float radius = sideLength/2.0;\n    point = point - center;\n    if (angle != 0.0) {\n     \tpoint = getRotationMatrix(angle) * point;   \n    }\n    const float k = sqrt3;\n\n    point.x = abs(point.x) - radius;\n    point.y = point.y + radius/k;\n    \n    if (point.x + k*point.y > 0.0)\n        point = vec2(point.x - k*point.y, -k*point.x - point.y) / 2.0;\n    \n    point.x -= clamp( point.x, -2.0*radius, 0.0 );\n    return -length(point)*sign(point.y);\n}\n\n// Get the background color as a radial pattern multiplied by a base color\nvec3 getBackgroundColor(vec2 point, int level)\n{    \n    // TODO - Texture Mode\n    // Sample a texture instead of the regular background\n    // This is way cooler using a picture of space. To use that,\n    // run the following line of code in your browser's javascript console,\n    // or replace the image URL with your own:\n    \n    // gShaderToy.SetTexture(0, {mSrc:'https://images.pexels.com/photos/110854/pexels-photo-110854.jpeg?auto=compress&cs=tinysrgb&dpr=1', mType:'texture', mID:1, mSampler:{ filter: 'linear', wrap: 'repeat', vflip:'true', srgb:'false', internal:'byte' }});\n    \n    // Append */ to the following line to use texture mode:\n    /* \n    float aspect = iChannelResolution[0].x / iChannelResolution[0].y;\n    \n    // Add some simple wavy distortion\n    vec2 distort = sin(point * 4.8);\n    point += 0.075 * distort * distort;\n    \n    // This basically makes it so that the texture scale cycles on [0.33, 0.53] based on the zoom per iteration\n    // and moves the texture a little bit\n    vec2 uv = (0.33 + 0.2*(scalePerIteration - 1.55)/3.55) * vec2(point.x/aspect, point.y) - 0.5 + iTime/90.0;\n    \n    // The following lines reflect adjacent textures\n    uv = mod(uv, 2.0);\n    uv = 1.0 - abs(uv - 1.0);\n    \n    return texture(iChannel0, uv).xyz; /**/\n    \n    // Original - Calculate base color as blue becoming bright purple/orange as recursion happens\n    // vec3 baseColor = vec3(float(level) * 0.35, float(level) * 0.15, 0.9);\n\n    // Oscillation-based version\n    vec3 baseColor = vec3(\n        oscillate(0.0, 0.8, float(level) * 1.1) + float(level) / float(maxIterations) / 3.0,\n        oscillate(0.0, 0.5, float(level) * 0.8) + float(level) / float(maxIterations) / 3.0,\n        oscillate(0.9, 0.0, float(level) * 0.5) + float(level) / float(maxIterations) / 1.5);\n    \n\tfloat angle = atan(point.y, point.x);\n    float distance = distance(point, vec2(0.0));\n    float angleIntensity = (sin(9.0*angle) / 4.0) + 0.75;\n    float distanceIntensity = (cos(10.0 * distance) / 4.0) + 0.75;\n    return baseColor * distanceIntensity * angleIntensity;\n}\n\n// Get rainbow color of screen the same way a default shadertoy does\nvec3 getRainbowColor(vec2 point) {\n    return 0.5 + 0.5*cos(iTime+point.xyx+vec3(0,2,4));\n}\n\n// Gets the intensity of a primary triangle glow, clamped from 0 to 1\nfloat getPrimaryGlowIntensity(float distanceFromTriangle, float distanceFromCenter)\n{\n    // First, set center distance to start at the edge\n    distanceFromCenter -= primaryLength / (2.0 * sqrt3);\n    // Get a shape between triangle and circle distance, then calculate some function that falls off\n    float interpolatedDistance = mix(distanceFromTriangle, distanceFromCenter, 0.2);\n    float falloff = 1.0 / (interpolatedDistance * 50.0 + 1.0) - 0.08;\n    return  clamp(falloff, 0.0, 1.0);\n}\n\n// Gets the intensity of a secondary triangle glow, clamped from 0 to 1\nfloat getSecondaryGlowIntensity(float distanceFromTriangle, float distanceFromCenter, int recursionLevel)\n{\n    // First, set center distance to start at the edge\n    distanceFromCenter -= secondaryLength / (2.0 * sqrt3);\n    \n    // Scale distances to make glow intensity oscillate\n    float scale = oscillate(0.5, 1.5, 0.5*pi*(iTime + 2.0*float(recursionLevel)/float(secondaryIterations - 1)));\n    \n    distanceFromTriangle /= scale;\n    distanceFromCenter /= scale;\n    \n    // Get a shape between triangle and circle distance, then calculate some function that falls off\n    float interpolatedDistance = mix(distanceFromTriangle, distanceFromCenter, 0.2);\n    float falloff = 1.0 / (interpolatedDistance * 150.0 + 1.0) - 0.1;\n    return  clamp(falloff, 0.0, 1.0);\n}\n\n// Calculates the new coordinate if we are inside a main triangle\nvec2 recurseOnMainTriangle(vec2 point, mat2 rotationMatrix, int triangleIndex)\n{\n    return scalePerIteration * rotationMatrix * (point - triangleCenters[triangleIndex]);\n}\n\n// Calculates the new coordinate if we are inside a secondary triangle\nvec2 recurseOnSecondaryTriangle(vec2 originalPoint, vec2 center, int recursionLevel)\n{\n    // Scale linearly based on level\n    float scale = (1.0 - float(recursionLevel + 1) * secondaryShrinkage);\n    return (originalPoint - center) / scale + center;\n}\n\n// For skipping iterations when zoomed in\nconst float inscribeRadius = primaryLength / 2.0 / sqrt3 - borderWidth;\n\n// Main algorithm - computes color at point, with rotation matrix passed to save computations\nvec3 getColor(vec2 coord, mat2 rotationMatrix)\n{ \t\n    // Point to recurse on\n    vec2 point = coord;\n    \n    // If the point is close to the center, advance the start level to save computation\n    float exponent = 0.5 * log(inscribeRadius * inscribeRadius / dot(point, point)) / log(scalePerIteration);\n    float start = max(ceil(exponent), 0.0);\n    \n    point = getRotationMatrix(anglePerIteration * start) * point * pow(scalePerIteration, start);\n    \n    // Recurse a few levels deep, keep track of level for color calculation\n    vec3 result;\n    for (int level = int(start); level < maxIterations + int(start); level++)\n    {\n        // Calculate background with pattern and some rainbow action\n        vec3 background = getBackgroundColor(point, level);\n        vec3 rainbow = getRainbowColor(point);\n        \n        // Reset result at beginning of recursion\n        result = mix(background, rainbow, 0.25);\n        \n        int insideTriangleIndex = -1; // Index of the triangle we are inside - -1 if outside all triangles\n        \n        // Iterate over each main triangle\n        for (int i = 0; i < triangleCenters.length(); i++) {\n            vec2 center = triangleCenters[i];\n            \n            float distanceFromCenter = distance(point, center);\n            // Optimize - stop calculations for this triangle if we are far from it\n            if(distanceFromCenter > 0.8) \n                continue;\n            \n            float distanceFromTriangle = sdEquilateralTriangle(point, center, 0.0, primaryLength);\n            \n            // Break to recurse on this triangle if inside \n            if(distanceFromTriangle < 0.0)\n            {\n                // Add border to triangle\n                if(distanceFromTriangle > -borderWidth)\n                    return vec3(1.0);\n                \n                insideTriangleIndex = i;\n                break;\n            }\n            \n            // Add glow to result color\n            float glowIntensity = getPrimaryGlowIntensity(distanceFromTriangle, distanceFromCenter);\n            result += vec3(glowIntensity);\n        }\n        \n        // If inside a triangle, set up and perform recursion\n        if (insideTriangleIndex >= 0) {\n        \tpoint = recurseOnMainTriangle(point, rotationMatrix, insideTriangleIndex);\n            continue;\n        }\n        \n        // Otherwise, render secondary triangles, then break recursion\n        if (renderSecondaryTriangles) {\n            for (int i = 0; i < secondaryTriangleCenters.length(); i++)\n            {\n                vec2 center = secondaryTriangleCenters[i];\n\n                // Store original point, because recursion will calculate from the original point\n                // rather than the previous iteration's point\n                vec2 originalPoint = point;\n\n                // Render mirror copies\n                for(int mirror = 0; mirror < 2; mirror++)\n                {\n                    // Reset point to originalPoint for each mirror copy\n                    point = originalPoint;\n\n                    for (int secondaryLevel = 0; secondaryLevel < secondaryIterations; secondaryLevel++)\n                    {\n                        // Optimize - abort rendering if we are too far away\n                        float distanceFromCenter = distance(point, center);\n                        if(distanceFromCenter > 0.3)\n                            break;\n\n                        float distanceFromTriangle = sdEquilateralTriangle(point, center, 60.0 * float(mirror), secondaryLength); // Add 60 degrees on mirror\n\n                        // We are inside triangle\n                        if(distanceFromTriangle < 0.0)\n                        {\n                            // Add border to triangle\n                            if(distanceFromTriangle > -borderWidth)\n                                return vec3(1.0);\n\n                            // Reset result\n                            result = 0.5 * getRainbowColor(point);\n\n                            // Set up recursion\n                            point = recurseOnSecondaryTriangle(originalPoint, center, secondaryLevel);\n                            continue;\n                        }\n\n                        // Add glow and break recursion if outside triangle\n                        float glowIntensity = getSecondaryGlowIntensity(distanceFromTriangle, distanceFromCenter, secondaryLevel);\n\n                        result += vec3(glowIntensity);\n                        break;\n                    }\n                    // Subtract offset of second triangle\n                    vec2 offset = secondaryMirrorOffset * normalize(center);\n                    center -= offset;\n                }\n            }\n        }\n        break; // Break from primary triangle recursion (because we are outside a primary triangle)\n    }\n    return result;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Smaller screen dimension will have coordinates on [-1, 1]\n    float minDimension = min(iResolution.x, iResolution.y);\n    \n    // Set up angle, scale, and zoom\n    scalePerIteration = oscillate(1.55, 5.0, iTime * twoPi / secondsPerIteration);\n    zoom = exp(oscillate(0.0, 10.0, iTime * pi / secondsPerIteration));\n    anglePerIteration = iTime * 20.0 / secondsPerIteration;\n    \n    // Angle/Zoom defaults overwritten by mouse x/y respectively if clicked\n    if (iMouse.z > 0.0)\n    {\n        vec2 mouse = min(iMouse.xy, iResolution.xy); // so changing resolution doesn't waz it\n        anglePerIteration = -60.0 * (2.0 * mouse.x - iResolution.x) / iResolution.x;\n        scalePerIteration = mix(1.55, 5.0, pow(exp2(mouse.y / iResolution.y) - 1.0, 1.5));\n    }\n    mat2 rotationMatrix = getRotationMatrix(anglePerIteration);\n    \n    // Supersample by accumulating color of all samples\n    vec3 color = vec3(0.0);\n    \n    for(int j = 0; j < SUPERSAMPLE; j++) {\n        for(int i = 0; i < SUPERSAMPLE; i++)\n        {\n            vec2 screenCoord = fragCoord + offset + increment * vec2(float(i), float(j));\n            vec2 coord = 2.0 * (screenCoord - iResolution.xy/2.0) / minDimension;\n\n            // Zoom and rotate\n            coord = rotationMatrix * coord / zoom;\n\n            color += getColor(coord, rotationMatrix);\n        }\n    }\n    color /= float(SUPERSAMPLE * SUPERSAMPLE);\n\n    // Output to screen\n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}