{"ver":"0.1","info":{"id":"tds3RM","date":"1545570823","viewed":182,"name":"Chinese flag","username":"marshmallow","description":"Each star is made of 2 big yellow triangles and 2 small red triangles. Each small triangle overlapses a big yellow one. After resizing, translating and rotating, we can make 4 small stars.\nIt is far from being optimised, but well, it works :D","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["flag","stars","chinese","china"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float areaTriangle(vec2 A, vec2 B, vec2 C)\n{\n \treturn abs((A.x*(B.y - C.y) + B.x*(C.y - A.y) + C.x*(A.y - B.y)) / 2.0);\n}\n\n/* Calculate areas of sub triangles to check if the point is inside */\nbool isInsideMatTriangle(mat3x2 triangle, vec2 point)\n{\n    vec2 A = triangle[0];\n    vec2 B = triangle[1];\n    vec2 C = triangle[2];\n    float areapoint = areaTriangle(A, B, point) + \n                      areaTriangle(point, B, C) + \n                      areaTriangle(A, point, C);\n    float realarea  = areaTriangle(A, B, C);\n    return abs(areapoint - realarea) < 0.00001;\n}\n\n\nbool isInGivenStar(mat3x2 bigTriangle1, mat3x2 bigTriangle2,\n                   mat3x2 smallTriangle1, mat3x2 smallTriangle2,\n                   vec2 resize, float rotate, vec2 translate,\n                   vec2 point)\n{   \n    /* First create a transformation matrix, based on rotation and\n     * resizing */\n    mat2 rotation = mat2(cos(rotate), sin(rotate),\n                        -sin(rotate), cos(rotate));\n    \n    mat2 resizemat = mat2(resize.x, 0,\n                          0, resize.y);\n    mat2 transform = rotation * resizemat;\n    \n    /* Apply the transformation to all the triangles composing a star */\n    bigTriangle1   = transform * bigTriangle1;\n    smallTriangle1 = transform * smallTriangle1;\n    bigTriangle2   = transform * bigTriangle2;\n    smallTriangle2 = transform * smallTriangle2;\n        \n    /* Transalte the star */\n    bigTriangle1[0] += translate;\n    bigTriangle1[1] += translate;\n    bigTriangle1[2] += translate;\n\n    bigTriangle2[0] += translate;\n    bigTriangle2[1] += translate;\n    bigTriangle2[2] += translate;\n\n    smallTriangle1[0] += translate;\n    smallTriangle1[1] += translate;\n    smallTriangle1[2] += translate;\n\n    smallTriangle2[0] += translate;\n    smallTriangle2[1] += translate;\n    smallTriangle2[2] += translate;\n    \n    /* Check whether the given point is inside the star or not */\n    return (isInsideMatTriangle(bigTriangle1,  point)\n        && !isInsideMatTriangle(smallTriangle1, point))\n        ||\n           (isInsideMatTriangle(bigTriangle2, point)\n        && !isInsideMatTriangle(smallTriangle2, point));    \n}\n   \nconst vec2 UNIT_SIZE = vec2(0.0333, 0.05);\n\n/* Returns true if the given point is inside the big star */\nbool isInStar(vec2 point)\n{    \n    /* The big star is composed of two big triangles to which we substract\n     * two small red triangles (located at the bottom of each).\n     * The following coordinated give a star centered on (0,0). */\n    mat3x2 bigTriangle1 = mat3x2(vec2(-0.05994, -0.12),\n                                 vec2(0, 0.15),\n                                 vec2(0.05994, -0.12));\n    \n    mat3x2 smallTriangle1 = mat3x2(vec2(-0.05994, -0.12),\n                                   vec2(0, -0.065),\n                                   vec2(0.05994, -0.12));\n    \n    mat3x2 bigTriangle2 = mat3x2(vec2(0.05994, -0.12),\n                                 vec2(-0.09324, 0.045),\n                                 vec2(0.09324, 0.045));\n        \n    mat3x2 smallTriangle2 = mat3x2(vec2(0.05994, -0.12),\n                                   vec2(0.03663, -0.02),\n                                   vec2(0.09324, 0.045));\n    \n    return\n         /* Check whether the given point is in the big star */\n         isInGivenStar(bigTriangle1, bigTriangle2,\n                       smallTriangle1, smallTriangle2,\n              \t\t   /* No scaling on this star */\n                       vec2(1., 1.),\n                       /* No rotation either */\n                       0.,\n                       /* The center of the star is located on (5,5)\n                        * in the upper-left part of the screen */\n                       vec2(5.0, 5.0) * UNIT_SIZE,\n                       point)\n        \n        /* First small star (starting from the top) */\n        || isInGivenStar(bigTriangle1, bigTriangle2,\n                       smallTriangle1, smallTriangle2,\n                       /* Rescale the star. The deformation is not the same\n                        * for x and y, else, the rotation will deform the star */\n                       vec2(0.3333, 0.222),\n                       /* Perform a rotation of PI/3 */\n                       1.047,\n                       vec2(10., 8.) * UNIT_SIZE,\n                       point)\n        /* Second small star */\n        || isInGivenStar(bigTriangle1, bigTriangle2,\n                       smallTriangle1, smallTriangle2,\n                       vec2(0.3333, 0.222),\n                       /* Perform a rotation of PI/6 */\n                       0.52,\n                       vec2(12., 6.) * UNIT_SIZE,\n                       point)\n        || isInGivenStar(bigTriangle1, bigTriangle2,\n                       smallTriangle1, smallTriangle2,\n                       vec2(0.3333, 0.222), 0.0, vec2(12., 3.) * UNIT_SIZE,\n                       point)\n\t\t|| isInGivenStar(bigTriangle1, bigTriangle2,\n                       smallTriangle1, smallTriangle2,\n                       vec2(0.3333, 0.222),\n                       /* Perform a rotation of -PI/6 */  \n                       -0.52,\n                       vec2(10., 1.) * UNIT_SIZE,\n                       point);\n}\n\n/* This function is here for doing less calculation, and so,\n * optimize FPS */\nbool needsCalculation(vec2 point)\n{\n    vec2 subpoint = point / UNIT_SIZE;\n    \n        /* Check if it is possible that the point is inside\n         * the big star */\n    return (subpoint.x >= 2.0 && subpoint.x <= 8.0 &&\n            subpoint.y >= 2.0 && subpoint.y <= 8.0)\n        \n        /* Check if it is possible that the point is inside 2 of\n         * the small stars (most left ones) */\n        || (subpoint.x >= 9.0 && subpoint.x <= 11.0 &&\n             ( \n               (subpoint.y >= 0.0 && subpoint.y <= 2.0) ||\n               (subpoint.y >= 7.0 && subpoint.y <= 9.0)\n             )\n           )\n        \n        /* Check if it is possible that the point is inside 2 of\n         * the other small stars (most right ones) */\n        || (subpoint.x >= 11.0 && subpoint.x <= 13.0 &&\n             (\n               (subpoint.y >= 2.0  && subpoint.y <= 4.0) ||\n               (subpoint.y >= 5.0  && subpoint.y <= 7.0)\n             )\n            );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv.y -= 0.5;\n    \n    vec4 red    = vec4(0.87058, 0.16078, 0.06274, 1.0);\n    vec4 yellow = vec4(1.0, 0.87058, 0.0, 1.0);\n    \n    // Chinese flag is split in 4 parts, only the upper-left one is used\n    // This part is itself divided in 15*10 small squares\n    if (needsCalculation(uv) && isInStar(uv))\n\t    fragColor = yellow;\n    else\n        fragColor = red;\n}","name":"Image","description":"","type":"image"}]}