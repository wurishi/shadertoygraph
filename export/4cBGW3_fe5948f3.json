{"ver":"0.1","info":{"id":"4cBGW3","date":"1704762769","viewed":111,"name":"[phreax] Caterpillar","username":"phreax","description":"Raymarching experiments","likes":4,"published":1,"flags":64,"usePreview":0,"tags":["rayarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dX3zn","filepath":"/media/a/550a8cce1bf403869fde66dddf6028dd171f1852f4a704a465e1b80d23955663.png","previewfilepath":"/media/ap/550a8cce1bf403869fde66dddf6028dd171f1852f4a704a465e1b80d23955663.png","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"lsc3Rs","filepath":"https://soundcloud.com/shayke-k/bluetech-koinonea","previewfilepath":"https://soundcloud.com/shayke-k/bluetech-koinonea","type":"musicstream","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.141592\n#define TAU PI*2.\n\n#define BPM 100.\n#define BEATS (BPM/16.)\n#define iTime iChannelTime[1]\n\n#define SIN(x) (.5+.5*sin(x))\n\nfloat tt;\n\nconst highp float NOISE_GRANULARITY = 0.5/255.0;\n\nhighp float random(highp vec2 coords) {\n   return fract(sin(dot(coords.xy, vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat curve(float t, float d) {\n  float off = .25;\n  t = ((t-off)/d);\n  return mix(floor(t), floor(t)+1., pow(smoothstep(0.,1.,fract(t)), 20.));\n}\n\nfloat box(vec3 p, vec3 r) {\n\tvec3 q = abs(p) - r;\n    return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);\n}\n\nmat2 rot(float a) { return mat2(cos(a), sin(a), -sin(a), cos(a));}\n\n\n// kaleidoscopic function\nvec3 kalei(vec3 p) {\n  float w = 1.;\n  p = abs(p) -.2;\n \n  \n  for(float i=0.; i < 4.; i++) {\n        float t1 = .2+.5+SIN(i+.1*iTime) + SIN(.05*iTime)*.4;\n        p.xy *= rot(.25+.5*SIN(i+iTime*.2));\n        \n         p.yz *= rot(.6-.4*SIN(iTime*.5));\n        //p -= 0.05;\n      \n        p.x -= 0.23;\n        p.y -= 0.2;\n        p.z -= 0.1;\n        \n        p = abs(p);\n \n    }\n    p /= w;\n    return p;\n}\n\nfloat cyl( vec3 p, float r, float h )\n{\n\n  vec2 d = abs(vec2(length(p.yz),p.x)) - vec2(r,h);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n    \nfloat rep(inout float x, float s) {\n    float id = floor(x/s);\n    x = mod(x, s) - s/2.;\n    return id;\n}\n\nfloat matID;\nfloat instIDn;\nfloat instID;\n\nfloat spiral(vec3 p, float off) {\n    \n    //p.x = abs(p.x)-1.5;\n      p = kalei(p);\n    // Step 1: Transform to polar coordinates\n    float angle = atan(p.z, p.x);\n    float radius = length(p.xz);\n\n    float angleO = angle;\n\n    float numBoxes = 100.;\n    float circleRadius = 2.+.7*off;\n    // Step 2: Apply domain repetition on the angle\n    float angleRepeat = 2.0 * PI / numBoxes;\n    float id = floor(angle/angleRepeat);\n    angle = mod(angle, angleRepeat) - 0.5 * angleRepeat;\n    \n    \n    p.y += sin(p.x*.5+.2*tt+off)*2.;\n    p.z += cos(p.x*.5+.2*tt+off)*2.;\n\n\n    // Step 3: Map back to Cartesian coordinates\n    p = vec3(radius * cos(angle), p.y, radius * sin(angle)) - vec3(circleRadius, 0.0, 0.0);\n    // p = kalei(p);\n\n    p.xz = p.zx;\n    \n    instIDn = id;\n\n    return cyl(p, .04+.7*SIN(id*.3+tt*2.+off)+.2*SIN(id*.1+1.5*tt+off), .07)-.02;\n}\n\n\nfloat hash11(float x) {\n\treturn fract(sin(5137765.44*x)*345.63);\n}\n\n\nfloat octah( vec3 p, float s) {\n  p = abs(p);\n  return (p.x+p.y+p.z-s)*0.57735027;\n}\n\nfloat _angle;\n\nvec3 circularPattern(vec3 p, float circleRadius, float numBoxes, float off, int direction, out float id) {\n    // Transform coordinates based on the direction\n    vec2 pp;\n    if (direction == 0) { // x\n        pp = p.yz;\n    } else if (direction == 1) { // y\n        pp = p.xz;\n    } else { // 'z' or default\n        pp = p.xy;\n    }\n\n    // Convert to polar coordinates\n    float angle = atan(pp.y, pp.x);\n    float radius = length(p);\n\n    _angle = angle;\n    // Apply domain repetition on the angle\n    float angleRepeat = 2.0 * PI / numBoxes;\n    id = floor((angle)/angleRepeat);\n    angle = mod(angle, angleRepeat) - 0.5 * angleRepeat;\n    \n\n    // Map back to Cartesian coordinates\n    pp = vec2(radius * cos(angle), radius * sin(angle)) - vec2(circleRadius, 0.0);\n\n    if (direction == 0) {\n        p = vec3(p.x, pp.x, pp.y);\n    } else if (direction == 1) {\n        p = vec3(pp.x, p.y, pp.y);\n    } else { // 'z' or default\n        p = vec3(pp.x, pp.y, p.z);\n    }\n    return p;\n}\n\nfloat orbit(vec3 p) {\n    \n    float angle = atan(p.y, p.x);\n    float radius = length(p.xy);\n    float id, id1, id2;\n\n   \n    p.xz *= rot(.05*iTime);\n    p = circularPattern(p*vec3(1, .8, 1), 5., 10., iTime*.1, 1, id1);\n   \n    p.xz *= rot(.5*PI);\n\n    p.xz = p.zx;\n    \n    p.xy *= rot(-0.4*iTime);\n    p = circularPattern(p, 3., 20., iTime*.5, 2, id2);\n    p.y /= 1.1;\n    id = instIDn = 2.*id1+id2;\n    p.xz *= rot(1.*iTime+4.*sin(id));\n    \n    float s = .04 + .3*SIN(id*0.9);\n    \n    \n    return (octah(p, s)-0.04)*.5;\n}\n\n\nfloat rectSin(float x) {\n    return smoothstep(0., 1., sin(x));\n}\n\nfloat map(vec3 p) {\n    \n   // p.xz *= rot(iTime*0.5);\n    \n    p.xz *= rot(-PI*curve(iTime-.4, BEATS));\n    float o = orbit(p);\n    float instIDo = instIDn; \n    float s1 = spiral(p, .0);\n        float instID1 = instIDn;\n    float s2 = spiral(p, 2.);\n        float instID2 = instIDn;\n    \n    matID = s1 < s2 ? 0. : 1.;\n    instID = s1 < s2 ? instID1 : instID2;\n\n    float d = min(s1, s2);\n    \n    if(o < d) {\n        matID = 2.;\n        instID = instIDo;\n    }\n\n\n    return min(d*.4, o);\n \n}\n\nfloat calcAO(vec3 p, vec3 n)\n{\n\tfloat sca = 2.0, occ = 0.0;\n    for( int i=0; i<5; i++ ){\n    \n        float hr = 0.01 + float(i)*0.5/4.0;        \n        float dd = map(n * hr + p);\n        occ += (hr - dd)*sca;\n        sca *= 0.7;\n    }\n    return clamp( 1.0 - occ, 0.0, 1.0 );    \n}\n\n\nvec3 invGamma(vec3 col) {\n    return pow(col, vec3(2.2));\n}\n\nvec3 gamma(vec3 col) {\n    return pow(col, vec3(1./2.2));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.x;\n    \n    //uv = uv.yx;\n    tt = iTime;\n    tt = tt*1.2+ 6.*curve(tt+BEATS*1.-.4, 3.*BEATS/8.);\n    vec3 ro = vec3(0, 0., -10. - SIN(1.*iTime-BEATS/2.)*5.),\n         rd = normalize(vec3(uv, .5)),\n         lp = vec3(0., 1., -6.);\n    \n    vec3 col;\n    float i, t, d = 0.1;\n    float matIDt = 0.;\n    float instIDt = 0.;\n\n    vec3 p = ro;\n    \n    for(i=0.; i<200.; i++) {\n    \n          \n        d = map(p);\n        matIDt = matID;\n        instIDt = instID;\n        if(d < 0.001 || t > 100.) break;\n        \t\n        p += rd*d;\n        t += d;\n    }\n    \n    vec2 e = vec2(0.0035, -0.0035);\n    \n    vec3 objColor = vec3(0.918,0.969,0.984);\n    vec3 al1 = vec3(0.067,0.773,0.690);\n    vec3 al2 = vec3(1.000,0.584,0.000);\n    al1 = al2 = objColor;\n       \n    vec3 al1_ = vec3(0.220,0.941,0.859);\n           \n    al1 = vec3(0.231,0.808,0.769);\n    al1_ = objColor;\n    vec3 al2_ = vec3(0.624,0.118,0.965);\n    \n    float ringMod =  float(mod(instIDt, 4.)<1.);\n   \n    vec3 al = mix(mix(al1, al1_, ringMod), mix(al2, al2_, ringMod), matIDt);\n    \n \n    float isRing = matIDt <= 1.? 1. : 0.;\n    if(isRing < 1.) {\n        al = objColor;\n        al = mix(al, al1_, rectSin(iTime+instIDt)*float(mod(instIDt, 3.)<1.));\n        al = mix(al, al2_, rectSin(.5*iTime+instIDt)*float(mod(instIDt+.5, 4.)>=3.));\n    }\n\n    \n    vec3 bg = vec3(0.722,0.820,0.859);\n    \n    if(d < 0.001) {\n        vec3 n = normalize( e.xyy*map(p+e.xyy) + e.yyx*map(p+e.yyx) +\n                            e.yxy*map(p+e.yxy) + e.xxx*map(p+e.xxx));\n        \n        vec3 l = normalize(lp-p);\n        float dif = max(dot(n, l), .0);\n        float spe = pow(max(dot(reflect(-rd, n), -l), .0), 40.);\n        float sss = smoothstep(0., 1., map(p+l*.4))/.4;        \n        \n        //al = mix(al, al-vec3(0.106,0.090,0.208) , ringMod*isRing);\n        \n        col =  al*mix(1., spe+.9*(dif+1.5*sss), .4);\n                  \n        float ao = calcAO(p, n);\n\n        col = mix(col, col*(1.-ao), .4);\n\n        rd = reflect(rd, n);\n\n        vec3 refl = texture(iChannel0, rd).rgb;\n\n        refl = invGamma(refl);\n\n        col = mix(1.5*col, .7*refl, .2*(isRing));\n        col = mix(col, col*(1.+.3*SIN(iTime*2.)) , ringMod);\n  \n\n    } else {\n        col += bg*mix(.1, 1., (1.-pow(dot(uv, uv), .8)));\n    }\n    \n    col += mix(-NOISE_GRANULARITY, NOISE_GRANULARITY, random(uv)); // dithering\n\n    // Output to screen\n    fragColor = vec4(col, 1.);\n}","name":"Image","description":"","type":"image"}]}