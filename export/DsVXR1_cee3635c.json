{"ver":"0.1","info":{"id":"DsVXR1","date":"1680721587","viewed":66,"name":"Lantern","username":"Antiz","description":"My first shader !","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["light3d"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float PRECISION = 0.001;\nconst float EPSILON = 0.0005;\nconst float PI = 3.14159265359;\n\n\n// Rotate around a circular path\nmat2 rotate2d(float theta) {\n  float s = sin(theta), c = cos(theta);\n  return mat2(c, -s, s, c);\n}\n\n// Rotation matrix around the X axis.\nmat3 rotateX(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(1, 0, 0),\n        vec3(0, c, -s),\n        vec3(0, s, c)\n    );\n}\n\n// Rotation matrix around the Y axis.\nmat3 rotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, 0, s),\n        vec3(0, 1, 0),\n        vec3(-s, 0, c)\n    );\n}\n\n// Rotation matrix around the Z axis.\nmat3 rotateZ(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, -s, 0),\n        vec3(s, c, 0),\n        vec3(0, 0, 1)\n    );\n}\n\n// Identity matrix.\nmat3 identity() {\n    return mat3(\n        vec3(1, 0, 0),\n        vec3(0, 1, 0),\n        vec3(0, 0, 1)\n    );\n}\n\n\nfloat sdSphere(vec3 p, float r )\n{\n  return length(p) - r;\n}\n\n\nstruct Material {\n  vec3 ambientColor ; // k_a * i_a\n  vec3 diffuseColor; // k_d * i_d\n  vec3 specularColor; // k_s * i_s\n  float alpha;\n  float fresnel; // shininess\n};\n\nstruct Surface {\n  int id; // id of object\n  float sd; // signed distance\n  Material mat;\n};\n\n//SDF\nfloat sdBoxFrame(vec3 p, vec3 b, float e,  mat3 transform)\n{\n    p = p * transform;\n  p = (abs(p)-b);\n  vec3 q = abs(p+e)-e ;\n  return min(min(\n      length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n      length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n      length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0)) ;\n}\n\nfloat sdBox( vec3 p, vec3 b, mat3 transform)\n{\n    p = p * transform;\n  vec3 q = abs(p) - b;\n  return  length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdCappedTorus(in vec3 p, in vec2 sc, in float ra, in float rb, mat3 transform)\n{\n    p = p * transform;\n  p.x = abs(p.x);\n  float k = (sc.y*p.x>sc.x*p.y) ? dot(p.xy,sc) : length(p.xy);\n  return sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;\n}\n\nfloat sdCappedCylinder( vec3 p, float h, float r, mat3 transform)\n{\n  p = p * transform;\n  vec2 d = abs(vec2(length(p.xz ),p.y)) - vec2(r,h);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0)) ;\n}\n\nfloat sdEllipsoid( vec3 p, vec3 r, mat3 transform)\n{\n    p = p * transform;\n  float k0 = length(p/r);\n  float k1 = length(p/(r*r));\n  return k0*(k0-1.0)/k1;\n}\n//--------------------\n\n\n\nMaterial red() {\n  vec3 aCol = 0.4 * vec3(0.4, 0., 0.);\n  vec3 dCol = 0.5 * vec3(0.7);\n  vec3 sCol = 0.6 * vec3(1, 1, 1);\n  float a = 5.;\n\n  return Material(aCol, dCol, sCol, a, 0.0);\n}\n\nMaterial dark() {\n    ///0 pour du noire\n  vec3 aCol = 0.0 * vec3(0.7, 0.5, 0);\n  vec3 dCol = 0.1 * vec3(0.7, 0.7, 0);\n  vec3 sCol = 0.6 * vec3(1, 1, 1);\n  float a = 2.;\n\n  return Material(aCol, dCol, sCol, a, 0.0);\n}\n\nMaterial dark2() {\n    ///0 pour du noire\n  vec3 aCol = 0.0 * vec3(0.7, 0.5, 0);\n  vec3 dCol = 0.1 * vec3(0.7, 0.7, 0);\n  vec3 sCol = 0.6 * vec3(1, 1, 1);\n  float a = 2.;\n\n  return Material(aCol, dCol, sCol, a, 0.0);\n}\n\nMaterial white() {\n    ///0 pour du noire\n  vec3 aCol = 0.4 * vec3(0.9, 0.9, 1);\n  vec3 dCol = 0.1 * vec3(0.7, 0.7, 0);\n  vec3 sCol = 0.6 * vec3(1, 1, 1);\n  float a = 2.;\n\n  return Material(aCol, dCol, sCol, a, 0.0);\n}\n\nMaterial orangeFlame() {\n    ///0 pour du noire\n  vec3 aCol = 0.9 * vec3(1, 0.5, 0);\n  vec3 dCol = 0.4 * vec3(0.7);\n  vec3 sCol = 0.1 * vec3(1, 1, 1);\n  float a = 5.;\n\n  return Material(aCol, dCol, sCol, a, 0.0);\n}\n\nMaterial checkerboard(vec3 p) {\n  vec3 aCol = vec3(1. + 0.7*mod(floor(p.x) + floor(p.z), 2.0)) * 0.3;\n  vec3 dCol = vec3(0.3);\n  vec3 sCol = vec3(0);\n  float a = 1.;\n\n  return Material(aCol, dCol, sCol, a, 0.0);\n}\n\nSurface opUnion(Surface obj1, Surface obj2) {\n  if (obj2.sd < obj1.sd) return obj2;\n  return obj1;\n}\n\nSurface scene(vec3 p) {\n\n  //floor\n  Surface sFloor = Surface(0, p.y + 2., dark2());\n    //Box\n    Surface box =  Surface(1,sdBoxFrame(p -vec3(.0,.06,.0), vec3 (0.3,0.5,0.3), 0.025, identity()), dark());\n    //Bottom\n    Surface bot = Surface(1,sdBox(p -vec3(.0,-.45,.0), vec3(.4, .02, .4), identity()), red());\n    //Top\n    float h = .04;\n    Surface c1 = Surface(1,sdBox( p - vec3(.0,.6,.0), vec3(.35, h, .35), identity()), dark());\n    Surface c2 = Surface(1,sdBox( p - vec3(.0,.67,.0), vec3(.3, h, .3), identity()), dark());\n    Surface c3 = Surface(1,sdBox( p - vec3(.0,.74,.0), vec3(.25, h, .25), identity()), dark());\n    Surface c4 = Surface(1,sdBox( p - vec3(.0,.81,.0), vec3(.2, h, .2), identity()), dark());\n    Surface c5 = Surface(1,sdBox( p -  vec3(.0,.94,.0), vec3(.15, .09, .15), identity()), dark());\n\n    //ring head\n    float an = 2.5*(0.5+0.5*sin(4.1*1.1+3.0));\n    vec2 c = vec2(sin(an),cos(an));\n    Surface r = Surface(1,sdCappedTorus(p - vec3(0., 1.1, 0.), c, 0.25, 0.03, identity()), red());\n\n\n    //candle\n    Surface candle = Surface(2,sdCappedCylinder(p - vec3(0., -0.2, 0.), 0.25, 0.08, identity()), white());\n    //flame\n    vec3 tp = p;\n    tp.x = tp.x + 0.01 * sin(tp.y * 20. + iTime * 2.);\n    Surface flame = Surface(3,sdEllipsoid((tp- vec3(0.,0.13,0.)) , vec3(0.03,0.08,.03), identity()), orangeFlame());\n    \n    Surface co = opUnion(sFloor, box); // closest object\n    co = opUnion(co, bot);\n    co = opUnion(co, c1);\n    co = opUnion(co, c2);\n    co = opUnion(co, c3);\n    co = opUnion(co, c4);\n    co = opUnion(co, c5);\n    co = opUnion(co, r);\n    co = opUnion(co, candle);\n    co = opUnion(co, flame);\n\n    return co;\n}\n\nSurface rayMarch(vec3 ro, vec3 rd) {\n  float depth = MIN_DIST;\n  Surface co;\n\n  for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n    vec3 p = ro + depth * rd;\n    co = scene(p);\n    depth += co.sd;\n    if (co.sd < PRECISION || depth > MAX_DIST) break;\n  }\n  \n  co.sd = depth;\n\n  return co;\n}\n\nvec3 calcNormal(vec3 p) {\n    vec2 e = vec2(1.0, -1.0) * 0.0005;\n    return normalize(\n      e.xyy * scene(p + e.xyy).sd +\n      e.yyx * scene(p + e.yyx).sd +\n      e.yxy * scene(p + e.yxy).sd +\n      e.xxx * scene(p + e.xxx).sd);\n}\n\nmat3 camera(vec3 cameraPos, vec3 lookAtPoint) {\n\tvec3 cd = normalize(lookAtPoint - cameraPos); // camera direction\n\tvec3 cr = normalize(cross(vec3(0, 1, 0), cd)); // camera right\n\tvec3 cu = normalize(cross(cd, cr)); // camera up\n\t\n\treturn mat3(-cr, cu, -cd);\n}\n\nvec3 phong(vec3 lightDir, vec3 normal, vec3 rd, Material mat, float fresnel) {\n  // ambient\n  vec3 ambient = mat.ambientColor + fresnel;\n    vec3 rimColor = vec3(1., 0, 0);\n\n  // diffuse\n  float dotLN = clamp(dot(lightDir, normal), 0., 1.);\n  float d = length(normal);\n  float bloom = 0.01 / d;\n  bloom = clamp(bloom, 0., 1.);\n  vec3 diffuse = mat.diffuseColor * dotLN  * rimColor ;\n  diffuse += bloom;\n\n  // specular\n  float dotRV = clamp(dot(reflect(lightDir, normal), -rd), 0., 1.);\n  vec3 specular = mat.specularColor * pow(dotRV, mat.alpha);\n\n  return ambient + diffuse + specular;\n}\n\n\n//Noise\n\nfloat hash13(vec3 p) {\n    return fract(sin(dot(p,vec3(12.9898,78.233,45.5432)))*43758.5453123);\n}\n\nfloat vnoise(in vec3 x) {\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\n    return mix(\n                mix(mix(hash13(p+vec3(0.,0.,0.)),hash13(p+vec3(1.,0.,0.)),f.x),\n                      mix(hash13(p+vec3(0.,1.,0.)),hash13(p+vec3(1.,1.,0.)),f.x),f.y),\n                mix(mix(hash13(p+vec3(0.,0.,1.)),hash13(p+vec3(1.,0.,1.)),f.x),\n                      mix(hash13(p+vec3(0.,1.,1.)),hash13(p+vec3(1.,1.,1.)),f.x),f.y),f.z);\n}\n\nfloat fnoise(in vec3 p,in float amplitude,in float frequency,in float persistence, in int nboctaves) {\n    float a = amplitude;\n    float f = frequency;\n    float n = 0.0;\n\n    for(int i=0;i<nboctaves;++i) {\n        n = n+a*vnoise(p*f);\n        f = f*2.;\n        a = a*persistence;\n    }\n    \n    return n;\n}\n\n\nvec3 texColor(in vec3 p,in vec3 c) {\n    vec3 t = (p+iTime)*4.;\n    float d = fnoise(t,1.,0.1,0.9,3);\n\n    d = d;\n    return vec3(d,0.,1.-d);\n}\n\nvec3 shade(in Surface s, vec3 o, vec3 r) {\n    //vec3 n = normalAt(s,r);\n    vec3 p = vec3(o + r * s.sd);\n    vec3 n = calcNormal(p);\n    vec3 l = normalize(vec3(1.,1.,-1.));\n    //vec3 v = -r.d;\n    vec3 v = -r;\n    vec3 e = reflect(-l,n);\n    \n    vec3 Kd = texColor(p,s.mat.ambientColor);\n    vec3 Ks = vec3(1.);\n    vec3 Ka = vec3(0.);\n    float sh = 50.;\n    \n    float diff = max(dot(n,l),0.);\n    float spec = pow(max(dot(e,v),0.),sh);\n    \n    return Ka + Kd*diff + Ks*spec;\n}\n\n \n//---------------\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec2 mouseUV = iMouse.xy/iResolution.xy; // Range: <0, 1>\n\n \n\n  vec3 backgroundColor =  vec3(0,0,0);//mix(vec3(1, .341, .2), vec3(0, 1, 1), uv.y) * 1.6;\n  vec3 col = vec3(0);\n\n  vec3 lp = vec3(0, 0.3,0); // lookat point (aka camera target)\n  vec3 ro = vec3(0, 0, 5);\n\n  float cameraRadius = 0.5;\n  ro.yz = ro.yz * cameraRadius * rotate2d(mix(PI/2., -2., mouseUV.y));\n  ro.xz = ro.xz * rotate2d(mix(-PI, PI, mouseUV.x)) + vec2(lp.x, lp.z);\n \n  vec3 rd = camera(ro, lp) * normalize(vec3(uv, -1)); // ray direction\n  Surface co = rayMarch(ro, rd); // closest object\n  \n  if (co.sd > MAX_DIST) {\n    col = backgroundColor;\n  } else {\n      vec3 p = ro + rd * co.sd; // point on surface found by ray marching\n      vec3 normal = calcNormal(p); // surface normal\n\n      // light #1\n      vec3 lightPosition1 = vec3(-8, -6, -5);\n      vec3 lightDirection1 = normalize(lightPosition1 - p);\n      float lightIntensity1 = 0.9;\n      \n      // light #2\n      vec3 lightPosition2 = vec3(0, -3, 1);\n      vec3 lightDirection2 = normalize(lightPosition2 - p);\n      float lightIntensity2 = 0.5;\n      vec3 tp = p;\n    tp.x = tp.x + 0.04 * sin(tp.y * 20. + iTime * 20.);\n      //vec3 lightCandle = normalize((p- vec3(0.,0.13,0.)));\n      vec3 lightCandle = normalize(tp- vec3(0.,0.13,0.));\n\n\n  \n      col = lightIntensity1 * phong(lightCandle, normal, rd, co.mat, 0.0 );\n\n   \n      if(co.id >= 3){\n        float fresnel = pow(clamp(1. - dot(normal, -rd), 0., 2.), 1.);\n        col = lightIntensity1 * phong(lightCandle, normal, rd, co.mat, fresnel );\n        \n    \n      }\n  }\n\n\n  fragColor = vec4(col, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}