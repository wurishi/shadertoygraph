{"ver":"0.1","info":{"id":"7slfRf","date":"1645177381","viewed":75,"name":"R&D: Lighting","username":"LouiG","description":"Lighting d'object","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["basics"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Shading : Romain Lopez-Rostain & Eric Galin\n\nconst float view = 5000.0;  // View distance\nconst float Epsilon = 0.01; // Marching epsilon\n\n// Iterations\nconst int Steps = 256;\n\nfloat falloff(in float dist, in float radius)\n{\n    return pow(1.0-pow(dist/radius, 2.0), 3.0);\n}\n\nfloat Distance_to_sphere(in vec3 point, in vec3 center, in float radius, in float energy)\n{\n    float dist = energy * falloff(length(point - center), radius);//length(point - center) - radius; //distance(point, center)-radius; Fonction de ShaderToy\n    return dist; // TODO\n}\n\nfloat Blend(in float dist1, in float dist2)\n{\n    return dist1 + dist2;\n}\n\nfloat Objects(in vec3 p)\n{\n    vec4 MiddleSphere = vec4(0., 0., 0., 500.);\n    vec4 SecondSphere = vec4(800., 800., 0., 400.);\n    float energy = 500.0;\n    \n    float distTotal = Blend(Distance_to_sphere(p, MiddleSphere.xyz, MiddleSphere.w, energy), Distance_to_sphere(p, SecondSphere.xyz, SecondSphere.w, energy));\n    \n    return distTotal;\n}\n\n\n// Sphere tracing\n// ro, rd : Ray origin and direction\n// t : Intersection depth\n// i : Iteration count\nbool Intersect(in vec3 ro, in vec3 rd, out float t)\n{\n    t = 0.0;\n\tfor(int i=0; i<Steps; i++ )\n\t{\n        vec3 p = ro + t*rd;\n\t\tfloat h = Objects(p);//min(\n            //Distance_to_sphere(p, vec3(0., 0., 0.), 500., energy),\n            //Distance_to_sphere(p, vec3(800., 800., 0.), 400., energy)\n        //);\n        \n        // 1 cm precision at 1 meter range, reduce precision as we move forward\n\t\tif( abs(h)<(Epsilon*t)  ) return true;\n        if( t>view ) { return false; }\n\t\t// Empirical Lipschitz constant with level of detail (the further, the larger steps)\n        t += max(Epsilon,h*sqrt(1.0+8.0*t/view)/8.);\n\t}\n\n\treturn false;\n}\n\n// Rendering \n// ro, rd : Ray origin and direction\nvec4 Render( in vec3 ro, in vec3 rd)\n{\n    // Light direction\n    vec3 light1 = normalize( vec3(-0.8*cos(iTime),-0.3*sin(iTime),0.4) );\n    float light1_strength = 0.8;\n    vec3 light1_color = vec3(0.25,0.25,0.15);\n    \n    vec4 MiddleSphere = vec4(0., 0., 0., 500.);\n    vec4 SecondSphere = vec4(800., 800., 0., 400.);\n    \n\tvec3 col;\n    float t; // la longueur du rayon parcourue avant intersection\n    vec3 n;\n    \n    if (Intersect( ro, rd, t)) {\n        // Le point est ici\n        vec3 p = ro + rd * t;\n        \n        // Calculer la normale /!\\ normalisée /!\\\n        // Si on est plus proche de la première sphère :\n        if (Objects(p) < Objects(p))//Distance_to_sphere(p, MiddleSphere.xyz, MiddleSphere.w, energy) < Distance_to_sphere(p, SecondSphere.xyz, SecondSphere.w, energy)) // TODO\n        {\n            n = normalize(p - MiddleSphere.xyz); // TODO\n        }\n        else // On est plus proche de la seconde\n        {\n            n = normalize(p - SecondSphere.xyz); // TODO\n        }\n            \n        // Pseudo diffuse lighting\n        float dif = pow((1. + dot(light1, n))/2., 2.); // TODO\n        //col += dif * light1_strength * light1_color;\n        \n        // Brouillard de lointain (Distance modification)\n        float fog = exp(-pow(0.0005*t,1.5));\n        col += fog * vec3(0.4, 0.35, 0.35);\n        \n        //To reemove\n        //col += vec3(1,1,1);\n        \n        // material color (ambient lighting)\n        col += vec3(0.4, 0.05, 0.);\n    }\n    else\n        col = vec3(0., 0., 0.);\n    \n    return vec4(col, 1.);\n}\n\nmat3 moveCamera(float time, out vec3 ro)\n{\n\t// Origin\n    ro =  vec3(2000.0*cos(iMouse.x*0.01), 2000.0*sin(iMouse.x*0.01),1000.0) ;\n\t\n    // Target\n    vec3 ta = vec3(0.0 ,0.0, 0.0);\n    \n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(0.0, 0.0, 1.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvec2 RayDirection(in vec2 pixel)\n{\n   // Pixel coordinates\n   return (-iResolution.xy + 2.0*pixel)/iResolution.y;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   // Time as function of the position of the mouse\n    float time = iTime*0.25 + 4.0*iMouse.x/iResolution.x;\n\n    // Camera transform\n    vec3 ro; \n    mat3 cam = moveCamera( time, ro);\n    \n    // Pixel coordinates\n    vec2 p = RayDirection(fragCoord);\n   \n    // Camera ray    \n    vec3 rd = cam * normalize(vec3(p,3.0));\n    \n    // Render\n    vec4 res = Render( ro, rd);\n     \n    fragColor = vec4( res.xyz, 0.0 );\n}","name":"Image","description":"","type":"image"}]}