{"ver":"0.1","info":{"id":"td3XRr","date":"1574495960","viewed":265,"name":"Cda_Test025_Tdh6.glsl","username":"Cephalopodium","description":"Tdh Part6 Tdh Rain on Window Shader from YT tutorial (The Art of Code )","likes":9,"published":1,"flags":0,"usePreview":0,"tags":["tutorial","glass","rain","window","nightdrive"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Title: Cda_Test025_Tdh6.glsl\n// Tag: Glass, rain, window, night-drive, tutorial\n// Desc: Tdh Part6 Tdh Rain on Window Shader from YT tutorial (The Art of Code )\n// Tutorial by Martijn Steinruken aka BigWings 2017\n// uncomment DROP_DEBUG for clarity regarding render buffer not used \n// if weak device comment #define HIGH_QUALITY \n// Music https://SoundCloud.com/zefora/cheyah Mr Bill - Cheyah (Zefora's Digital Rain Mix)\n// 33:00 100q% Thru video The Drive Home - Part 6 of 6 - Rain on Window\n\n/* Logistic fn() eg. Try y=2/(1+pow(E,-6.*(x-0.5))), replacing values with vars \ngives y=maxY/(1+pow(E,-slope*(x - xMidPoint))). Eg #2 for y range 0 to 1, \nwith 3 xy coords (-1,0), (0,0.5) and (1,1) : Use yMax=1, slope ~= 6, xMidPoint = 0; \nAlso yMax=1, slope ~=12, xMidPoint =0: gives coords (-0.5,0) and (0,0.5) and (0.5,1) */\n\n#define S(x,y,z) smoothstep(x,y,z)\n#define B(a,b,edge,t) S(a-edge,a+edge,t)*S(b+edge,b-edge,t)\n#define sat(x) clamp(x,0.,1.)\n#define streetLightCol vec3(1.,.7,.3)\n#define headLightCol vec3(.8,.8,1.)\n#define tailLightCol vec3(1.,.1,.1)\n#define HIGH_QUALITY \n#define CAM_SHAKE 1.\n#define LANE_BIAS .5\n#define RAIN\n// #define DROP_DEBUG\n#define E 2.7182818\n\n/* vec3 ro,rd; */\n\n// Basically fract(sin(t*largeA)*largeB) gives pseudo rnd()\nfloat N(float t) { \n  return fract(sin(t*10234.324)*123423.23512); \n} \n// returns a random colour given a time value \nvec4 N14(float t) { \n  return fract(sin(t*vec4(123.,1024.,3456.,9564.))*vec4(6547.,345.,8799.,1564.)); \n} \n\n/* CDA different rnd() fns */\nfloat NR(float t) { \n  return fract(sin(t*8234.324)*623423.352); \n} \nfloat NG(float t) { \n  return fract(sin(t*11034.324)*134423.232); \n} \nfloat NB(float t) { \n  return fract(sin(t*9234.324)*273423.517); \n} \n\nfloat logistic(float x,float maxY,float slope,float xMidPoint) {\n   return maxY/(1.+pow(E,-slope*(x - xMidPoint)));\n}\n\n// This is my first structure, Note \";\" after \"}\"\nstruct ray {\n    vec3 o,d; // Def ray with 2 origin and direction vec3's\n};\n    \nray CameraSetup(vec2 uv,vec3 camPos,vec3 la,float zoom) {\n  ray a;                             // define ray \n  a.o = camPos;                      // ray origin set to camera \n  vec3 f = normalize(la-camPos);     // forward \n/* Cross product z of vectors x & y is orthogonal/normal to plane xy with a direction\n   given by the right hand rule.(Eg. Thumb is z vector point out of screen ). */\n  vec3 r = cross(vec3(0,1,0),f);     // right (Cross product)\n  vec3 u = cross(f,r);               // up \n  vec3 c = a.o + f * zoom;           // screen centre\n  vec3 i = c + uv.x * r + uv.y * u;  // intersection pt\n  a.d = normalize(i - a.o);          // ray direction \n  return a;\n}\n\n/* Dot product of 2 vectors a & b with angle c between them is a scalar value, actually \n   the √(a • a) = |a| (the magnitude of vector a). Given P=(a,b) & Q=(c,d) with angle \n   @ between them, then P • Q is ac + bd. The dot product of two normalised vectors,\n   a • b = cos(c), or generally |a||b|cos(c), so to find the angle between them \n   use c= arccos((a • b)/(|a|*|b|)). \n   When vectors are at 90° the • product = 0 as when normalised it represents the \n   amount of a going in direction b, its like projection a onto b,. If c>90° a•b will \n    be -ve indicating opposing directions (or forces) */\n\nvec3 ClosestPt(ray r,vec3 p) {\n    return r.o + max(0.,dot(p-r.o,r.d)) * r.d;\n}\n\nfloat DistRay(ray r, vec3 p) {\n    return length(p-ClosestPt(r,p));\n}\n\n// Bokeh Japanese term that describes out of focus highlights \nfloat Bokeh(ray r, vec3 p, float size, float blur, float pf,float pe, float ssMin ) {   \n    float d = DistRay(r,p);              // define direction\n//  size *= length(p);      // pe=pf=1. stops pts from getting smaller in distance\n    size *= pow(length(p*pf),pe);  // CDA Let's pts enlarge pf=p factor & pe=p exponent         \n    float c = S(size,size*(1.-blur),d);     // define circle around pt p\n    c *= mix(.6,1.,S(size*ssMin,size,d));   // brighten Circumf. when>.8 of radius\n   return c;\n}\n\nvec3 PlaneLights(ray r, float t) {\n    t = -t*10.;  // reverse light direction & increase speed\n    // need to make lights appear alternately from each side \n    float side = step(r.d.x,0.); //*2.+1.;   // if r.d.x -ve side=0 else side =1\n    r.d.x = abs(r.d.x);                  // mirror horizontally to get left side\n//    r.d.y = abs(r.d.y);            //CDA  mirror vertically to get road reflected pts\n    float s = 1./20.;\n    float m = 0.;\n    for (float i=0.;i<1.;i+=s) {\n      float n = N(i);             // *side;\n      if (n>.015) continue; // skip to next plane for 60% of virtual cars \n      for (float q=i;q<i+.25;q+=1./100.) { \n        float ti = fract(t+q+side*s*.5);     // +side*s*.5 shifts lights by half step\n        vec3 p = vec3(2.,2.,100.-(ti*100.));  // def pt,fract resets posn, \n        \n        m += Bokeh(r,p,.01,.1,1.,1.,.88)*pow(ti+(q/50.),5.); // Def Circle,*ti^3 causes dist. fade.  \n   //   m += Bokeh(r,p,.0125,.1,6260.,0.257,.88)*pow(ti+(q/100.),20.); // CDA test lights enlarging A\n   //   m += Bokeh(r,p,.0125,.1,8.,0.65,.88)*pow(ti+(q/100.),20.);    // CDA test lights enlarging B */\n      }\n      float ti = fract(t+side*s*.5); // @ t+side \n      vec3 p = vec3(2.,2.,100.-(ti*100.));  // ti*ti*ti*ti*ti\n   // m += Bokeh(r,p,.015,.1,1.,1.,.88)*pow(ti,10.); // Def Circle,*ti^3 causes dist. fade.   \n      m += Bokeh(r,p,.0125,.1,1.,1.,.88)*ti*3.95;//*ti\n    }\n    return vec3(.3,.3,.99) * m;           // define color jet blue \n}\n\nvec3 StreetLights(ray r, float t) {\n    // need to make lights appear alternately from each side \n    float side = step(r.d.x,0.);         // if r.d.x -ve side=0 else side =1\n    r.d.x = abs(r.d.x);                  // mirror horizontally to get left side\n//    r.d.y = abs(r.d.y);            //CDA  mirror vertically to get road reflected pts\n    float s = 1./10.;\n    float m = 0.;\n    for (float i=0.;i<1.;i+=s) {\n      float ti = fract(t+i+side*s*.5);     // +side*s*.5 shifts lights by half step\n      vec3 p = vec3(2.,2.,100.-(ti*100.));  // def pt,fract resets posn, \n\n      m += Bokeh(r,p,.05,.1,1.,1.,.88)*ti*ti*ti; // Def Circle,*ti^3 causes dist. fade\n/*    m += Bokeh(r,p,.05,.1,6260.,0.257,.88)*ti*ti*ti; // CDA test lights enlarging A\n      m += Bokeh(r,p,.05,.1,8.,0.65,.88)*ti*ti*ti;    // CDA test lights enlarging B */\n    }\n    return vec3 (1.,.7,.3) * m;             // define color sodium lamp\n}\n\nvec3 EnvLights(ray r, float t) {\n    // need to make lights appear alternately from each side \n    float side = step(r.d.x,0.);         // if r.d.x -ve side=0 else side =1\n    r.d.x = abs(r.d.x);                  // mirror horizontally to get left side\n//   r.d.y = abs(r.d.y);            //CDA  mirror vertically to get road reflected pts\n    float s = 1./10.;\n    vec3 c = vec3(0.);       // can't use mask for different colors,so accumulate c\n    for (float i=0.;i<1.;i+=s) {\n      float ti = fract(t+i+side*s*.5);     // +side*s*.5 shifts lights by half step.    \n      vec4 n = N14(i+side*100.);      // Generate random locations based on i & side\n\n      float fade = ti*ti*ti*2.69;                // *ti^3 causes distance fade\n\n      float occlusion = sin(ti*6.28*10.*n.x)*.5+.5;  // 10 * TWO_PI revolutions\n      fade *= occlusion;\n      float x = mix(2.5,10.,n.x);          // x location beyond road \n      float y = mix(0.1,1.5,n.y);          // y locn. from just above ground to 1.5 \n\n      vec3 p = vec3(x,y,50.-(ti*50.));     // def pt,fract resets posn, \n\n      vec3 col = n.wzy;                    // get random color, (blueness ~= height);\n      float envLightSize=NR(sin(i))/40.+.025;     // CDA set light size range .025 to .05\n      c += Bokeh(r,p,envLightSize,.1,1.,1.,.88)*fade*col; // Def Circle\n/*    c += Bokeh(r,p,envLightSize,.1,6260.,0.257,.88)*fade*col; // CDA test lights enlarging A\n      c += Bokeh(r,p,envLightSize,.1,8.,0.65,.88)*fade*col;    // CDA test lights enlarging B */\n    }\n    return c;             //  color\n}\n\nvec3 HeadLights(ray r, float t) {\n    t *=2.;                  // Oncoming traffic twice as frequent as streetlights\n    r.d.x = -r.d.x;          // UK Fix !\n    float w1 = .25;          // Define width of a car\n    float w2 = w1 * 1.2;     // Define width of a car headlight\n\n    float s = 1./30.;        // Car frequency = 30 per sec \n    float m = 0.;            // Mask\n    vec3 bulb;               // CDA defined outside loop mutant car bulb \n\n    for (float i=0.;i<1.;i+=s) {\n      float n = N(i);            // for each car get rnd between 0 and 1\n      if (n>.1) continue;        // skip to next car for 90% of virtual cars \n      bulb = vec3(.9,.9,1.);     // CDA set normal bulb color\n      /* doesn't work as NR(i) fixed only evaluated at compile time ? \n      if (NR(i)<.02) {                    // CDA Probability of mutant bulb \n         bulb = vec3(NR(i),NG(i),NB(i));  // CDA set random bulb color\n      } */\n      float ti = fract(t+i);     // fract() resets Position\n      float z = 100.-(ti*100.);  // Dist along road \n        \n      float fade = ti*ti*ti*ti*ti;  // ti^5 causes dist. fade as light recedes\n      float focus = S(.9,1.,ti); // Step into focus while Dist between .8 and 1.\n      float size = mix(.05,.03,focus);             // reduce size when in focus\n      // defn of pt \"p\" moved inside Bokeh parameters ,\n      m += Bokeh(r,vec3(-1.-w1,.15,z),size,.1,1.,1.,.8)*fade; // Def Circle 1a\n      m += Bokeh(r,vec3(-1.+w1,.15,z),size,.1,1.,1.,.8)*fade; // Def Circle 2a\n      m += Bokeh(r,vec3(-1.-w2,.15,z),size,.1,1.,1.,.8)*fade; // Def Circle 1b\n      m += Bokeh(r,vec3(-1.+w2,.15,z),size,.1,1.,1.,.8)*fade; // Def Circle 2b\n\n/*    m += Bokeh(r,vec3(-1.-w1,.15,z),size,.1,2260.,0.257,.8)*fade; // CDA Circle 1a\n      m += Bokeh(r,vec3(-1.+w1,.15,z),size,.1,2260.,0.257,.8)*fade; // CDA Circle 2a \n      m += Bokeh(r,vec3(-1.-w2,.15,z),size,.1,2260.,0.257,.8)*fade; // CDA Circle 1b\n      m += Bokeh(r,vec3(-1.+w2,.15,z),size,.1,2260.,0.257,.8)*fade; // CDA Circle 2b */\n\n      float ref = 0.;  // define faint road reflection. Note .9 blur\n      ref += Bokeh(r,vec3(-1.-w2,-.15,z),size*3.,.9,1.,1.,.8)*fade; // Def reflection 1\n      ref += Bokeh(r,vec3(-1.+w2,-.15,z),size*3.,.9,1.,1.,.8)*fade; // Def reflection 2\n \n/*    ref += Bokeh(r,vec3(-1.-w2,.15,z),size*3.,.1,2260.,0.257,.8)*fade; // CDA ref 1\n      ref += Bokeh(r,vec3(-1.+w2,.15,z),size*3.,.1,2260.,0.257,.8)*fade; // CDA ref2 */\n\n      m += ref * focus;                            // Add reflection when in focus \n    }\n // return vec3(.9,.9,1.) * m;              // define color blue-white\n    return bulb * m;                        // CDA define bulb color mostly blue-white\n}\n\nvec3 TailLights(ray r, float t) {\n    t /=4.;                  // Overtaken traffic ¼ as frequent as streetlights\n    r.d.x = -r.d.x;          // UK Fix !\n    float w1 = .25;          // Define width of a car\n    float w2 = w1 * 1.2;     // Define width of a car headlight\n\n    float s = 1./15.;        // Car frequency = 15 per sec \n    float m = 0.;            // Mask\n    vec3 bulb;               // CDA defined outside loop - mutant car bulb \n\n    for (float i=0.;i<1.;i+=s) {\n      float n = N(i);            // for each car get rnd between 0 and 1\n      if (n>.5) continue;        // skip to next car for 50% of virtual cars \n      bulb = vec3(1.,.15,.025);    // CDA set normal bulb color RED was (1.,.1,.1)             \n/* Trick : reducing blue from .1 to .03 gives orange blinker eg. Original (1.,.1,.03) - \n  Orange = -25% Green -75% Blue. From Red's Brightness .1 -> .075g .025b, \n  or try .2 -> 0.15g 0.05b halfway = .1125g .0375b */\n\n      /* doesn't work as NR(i) etc fixed, only evaluated at compile time ? \n      if (NR(i)<.02) {                    // CDA Probability of mutant bulb \n         bulb = vec3(NR(i),NG(i),NB(i));  // CDA set random bulb color\n      } */\n      float lane = step(.25,n);  // returns 0 or 1 (as n range is now 0 to .5)\n      float ti = fract(t+i);     // fract resets posn,\n      float z = 100.-(ti*100.);  // dist along road \n      float fade = pow(ti,5.);   // ti^5 causes dist. fade as light recedes\n   //   float fade = ti*ti*ti*ti*ti;  // Not using pow(ti,5) reintroduces BUG\n      float focus = S(.9,1.,ti); // Step into focus while Dist between .9 and 1.\n      float size = mix(.05,.03,focus);      // reduce size when in focus\n      float laneshift = S(1.,.96,ti);       // 1 if far away 0 if close \n      float x = 1.5-(lane*laneshift);       // car position (was -1. for headlights)\n      float tmp3=7.*(lane-.00000001);       // BUG Fix requires var & *..01 Only lane 2\n      float blink = step(0.,sin(t*1000.))*tmp3*step(.796,ti);  // Blinker, off in dist @ .796 was .96\n      // defn of pt \"p\" is now vec3() moved inside Bokeh parameters ,\n      m += Bokeh(r,vec3(x-w1,.15,z),size,.1,1.,1.,.8)*fade; // Def Circle 1a\n      m += Bokeh(r,vec3(x+w1,.15,z),size,.1,1.,1.,.8)*fade; // Def Circle 2a\n      m += Bokeh(r,vec3(x-w2,.15,z),size,.1,1.,1.,.8)*fade; // Def Circle 1b\n      m += Bokeh(r,vec3(x+w2,.15,z),size,.1,1.,1.,.8)*fade*(1.+blink); // Def Circle 2b\n\n/*    m += Bokeh(r,vec3(x-w1,.15,z),size,.1,2260.,0.257,.8)*fade; // CDA Circle 1a\n      m += Bokeh(r,vec3(x+w1,.15,z),size,.1,2260.,0.257,.8)*fade; // CDA Circle 2a \n      m += Bokeh(r,vec3(x-w2,.15,z),size,.1,2260.,0.257,.8)*fade; // CDA Circle 1b\n      m += Bokeh(r,vec3(x+w2,.15,z),size,.1,2260.,0.257,.8)*fade*(1.+blink); // CDA Circle 2b */\n\n      float ref = 0.;  // define faint road reflection. Note .9 blur\n      ref += Bokeh(r,vec3(x-w2,-.15,z),size*3.01,.9,1.,1.,.8)*fade; // Def refl 1 BUG Fixed with 3.01\n    //  blink *= 0.0;  // BUG prevented .1 being used\n      float tmp4=(blink-.0000001)*.1;   // Reduce glare by 90%\n      ref += Bokeh(r,vec3(x+w2,-.15,z),size*3.,.9,1.,1.,.8)*fade*(1.+tmp4); // blink);\n      // Def refl2 & blink - Bug *1.0000001 but * 1.00000001 OK\n/*    ref += Bokeh(r,vec3(x-w2,.15,z),size*3.,.1,2260.,0.257,.8)*fade; // CDA Ref1\n      ref += Bokeh(r,vec3(x+w2,.15,z),size*3.,.1,2260.,0.257,.8)*fade; // CDA Ref2 */\n\n      m += ref * focus;                            // Add reflection when in focus \n    }\n // return vec3(1.,.1,.1) * m;              // define color red\n    return bulb * m;                        // CDA define bulb color mostly Red\n}\n\nvec2 Rain(vec2 uv, float t) {   \n//  vec2 st=uv*10.;     // #1 Rasta flag as ¼'s G,Y,R,Black clockwise from TopLeft\n//  vec2 st=fract(uv*10.);     // #2 makes grid boxes 10 high\n  t *= 40.;               // increase speed of droplets\n    \n  vec2 a = vec2(3.,1.);   // #3 makes boxes 3 * taller \n  vec2 st=uv*a;           // \n    \n  vec2 id=floor(st);\n  st.y +=t*.22;           // Makes entire fame move down, .22 tweak cancels up motion\n  float n = fract(sin(id.x*716.34)*768.34); // noise \n  st.y += n;              // pseudo random #\n  uv.y += n;              //     offsets drops vertically from centre of box \n//  st.x +=n;  // CDA\n//  uv.x +=sin(n*.8*t/19.); // pow(n*.6,2.);   // CDA offsets drops horizontally from centre of box \n\n\n  id = floor(st);      // make box id \n  st = fract(st)-.5;   // #3 within each box uv coords from (0,0) to (1,1),\n                       // #3 -.5 moves origins to centers \n\n  t += fract(sin(id.x*716.34+id.y*1453.7)*768.34)*6.283; // rnd # Time * TWO_PI to \n                     // gives phase difference . \n    \n  float y =-sin(t+sin(t+sin(t)*.5))*.43; // #3 Adds control of vertical posn. of drop \n   // Above modification approximates a saw tooth wave, up quick down slow \n  vec2 p1 = vec2(0.,y);        // #3 .43 above is tweak to prevent drop overlapping its box \n  vec2 o1 = (st-p1)/a;    // #5 define offset 1 \n  float d = length(o1);   // #3 distance to droplet ,/a fixes ellipses \n\n  float m1 = S(.07,.0,d);     // #3 mask for droplet (yellow on black,only RG cols used!)\n\n  vec2 o2 = (fract(uv*a.x*vec2(1.,2.))-.5)/vec2(1.,2.); // #4 Trail of smaller drops,  \n                           // fract=per box,-.5=centred,fn*vec2)/vec2 = more cells  \n  d = length(o2); // dist to drops, \n\n  float m2 = S(.3*(.5-st.y),.0,d)*S(-.1,.1,st.y-p1.y); // #4 mask for smaller droplets \n                              // (.5-st.y) shrinks, * S() prevents trail below drop \n\n//  if (st.x>.46||st.y>.49) m1=1.;    // Debug #3 show vertical & horizontal yellow lines\n \n  return vec2(m1*o1*20.+m2*o2*10.);        // #1& #2 was(st), #3 m1, #4 m\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv-=.5;                             // moves origin from bottom left to centre\n    uv.x*=iResolution.x/iResolution.y;  // turn ellipse to circle using aspect ratio\n\n    vec2 m = iMouse.xy/iResolution.xy;  // defines m from Mouse to mirror uv.xy coords\n    float t = iTime * (.01+ m.x/5.);   // m.x allows mouse control of playback speed. \n                                       // fixed mouse by adding brackets\n\n    vec3 camPos = vec3(0.6,.2,0);       // camera x position was 0 (now fast lane UK)\n    vec3 la     = vec3(0.6,.2,1);       // look at vec [CDA .9 not .5 4 close overtake]\n//  uv.y += logistic(uv.x,.235,19.,-0.25)*1.0-.23;       // CDA distorted heights \n\n    float rainScale=5.;               // sets drop size, was 3., wee =15. big=.85\n    vec2 rainDistort = Rain(uv*rainScale,t)*.5;    // Add Rain layer 1\n    rainScale=7.;\n    rainDistort += Rain(uv*rainScale,t)*.5;        // Add Rain layer 2\n    \n    uv.x += sin(uv.y*70.)*.005;      // add horizontal wave distortion to scene \n    uv.y += sin(uv.x*117.)*.003;     // add vertical   wave distortion to scene \n\n    ray r = CameraSetup(uv-rainDistort*.5,camPos,la,2.);    // get ray from cam to la\n\n    vec3 col = StreetLights(r,t);\n    col += HeadLights(r,t);\n    col += TailLights(r,t);\n    col += EnvLights(r,t);\n    \n    if (t-float(int(t))>.9) col += PlaneLights(r,t);  // allow 1 in 10 planes to show\n    \n    col += (r.d.y+.25)*vec3(.32,.1,.75);   // add sky gradient\n //   col = vec3(rainDistort,0.);\n\n    // Output to screen\n    fragColor = vec4(vec3(col),1.0);     // draw it\n\n}","name":"Image","description":"","type":"image"}]}