{"ver":"0.1","info":{"id":"WlXczN","date":"1591530968","viewed":182,"name":"Sphere Kerning","username":"spalmer","description":"a fork of [url=https://shadertoy.com/view/tdsfR4]Fly Camera[/url] with the original complicated (for a camera template toy) tiled sphere scene, which is a fine example of how to do raymarching on simple sparsely kerned objects","likes":0,"published":1,"flags":48,"usePreview":0,"tags":["collision","raymarch","sphere","camera","tiling","fly","kerning"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// fork of Fly Camera https://shadertoy.com/view/tdsfR4\n// which preserves the original sparse FCC lattice tiled sphere scene\n\nconst float\n  fogdensity = .005\n;\n\nvec3 Render(vec3 ro, vec3 rd)\n{\n    vec3 mr = March(ro, rd, 1.04, 128 + IZERO);\n    float t = mr.x // trace depth to first hit\n        , hd; // distance at hit point\n    int m = int(mr.y);\n    vec3 hp = ro + rd * t\n    , n = SceneNormal(hp, .004, hd)\n    , albedo = Material(m)\n    , light = Light(m, hp, n, -rd)\n    , c = vec3(1);\n    c *= albedo;\n    c *= light;\n    vec3 csky = vec3(.81,.91,.99);\n    c = mix(csky, c, exp2(-fogdensity * t)); // simple fog Beer's law\n    //c *= vec3(mix(exp2(-.2 * t), 1., .2)); // DEBUG black depth fog\n    //c *= rd * .5 + .5; // DEBUG ray dir\n    //c *= n * .5 + .5; // DEBUG hit normal\n    return c;\n}\n\nvec3 Render(vec2 p)\n{\n    State state;\n    vec2 R = iResolution.xy;\n    ivec2 i = ivec2(p);\n    LoadState(state, BufA, ivec2(R));\n    vec2 q = (p + p - R) / R.y;\n    mat3 view = Camera(state.eyeaim);\n    // fovy hardcoded at 60\n    vec3 rv = vec3(q, 2.); // ray dir in view space\n    vec3 rd = normalize(view * rv);\n    vec3 ro = state.eyepos;\n    return Render(ro, rd);\n}\n\nfloat Dither(vec2 p)\n{\n    return sin(dot(p, vec2(1./23., 1./23./17.)) * 23456.);\n}\n\nvoid mainImage(out vec4 o, vec2 p)\n{\n\tvec3 c = Render(p);\n    c = pow(c, vec3(.4545));\n    c += .6 / 256. * Dither(p);\n    o = vec4(c, 1);\n}\n\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// camera fixed if neither is enabled\n#define COLLISION 1\n\n#define BufA iChannel0\n#define ResA iChannelResolution[0].xy\n#define IZERO min(iFrame, 0)\n\nconst float tau = 2. * acos(-1.); //6.28318531; //\n\n// cos,sin of full turns angle\nvec2 spin(float r)\n{\n    return sin((r + vec2(.25, 0)) * tau);\n}\n\nmat2 mrot(vec2 cs)\n{\n\treturn mat2(cs.x,-cs.y\n              , cs.y, cs.x);\n}\n\nvoid rot(inout float a, inout float b, mat2 m)\n{\n    vec2 r = m * vec2(a, b); a = r.x; b = r.y;\n}\n\nvoid rot(inout vec2 a, inout vec2 b, mat2 m)\n{\n    rot(a.x, b.x, m);\n\trot(a.y, b.y, m);\n}\n\nvoid rot(inout vec3 a, inout vec3 b, mat2 m)\n{\n    rot(a.x, b.x, m);\n\trot(a.y, b.y, m);\n    rot(a.z, b.z, m);\n}\n\n// given two fractions azimuth and elevation,\n// return orthonormal camera to world matrix\nmat3 Camera(vec2 uv)\n{\n    mat3 m = mat3(1);\n    rot(m[0], m[2], mrot(spin(-1.*uv.x)));\n    rot(m[1], m[2], mrot(spin(.25 - .5*uv.y)));\n    return m; \n}\n\nvec4 fetch(sampler2D ch, ivec2 p)\n{\n\treturn texelFetch(ch, p, 0);\n}\n\nstruct State\n{\n    ivec2 resolution;\n    vec3 eyepos;\n    vec3 eyevel;\n    vec2 eyeaim;\n};\n\nconst int\n  slotResolution = 0 // zw unused\n, slotEyePosAz   = 1\n, slotEyeVelEl   = 2\n, slotCount      = 3\n;\n// stuffed azimuth and elevation of aim into w components\n// of position and velocity, respectively\n\n// cache to and from state structure\nvoid LoadState(out State state, sampler2D A, ivec2 R)\n{\n\tvec4[slotCount] data; // at least temporarily\n\tfor (int i = slotCount; i-- > 0; )\n        data[i] = fetch(A, R-1-ivec2(i,0));\n    state.resolution = ivec2(data[slotResolution].xy);\n    state.eyepos = data[slotEyePosAz].xyz;\n    state.eyevel = data[slotEyeVelEl].xyz;\n    state.eyeaim = vec2(data[slotEyePosAz].w\n                       ,data[slotEyeVelEl].w);\n}\n\n// only needed in Buffer A\n// but it mirrors LoadState\nvoid SaveState(inout vec4 c, State state, ivec2 p)\n{\n    ivec2 R = state.resolution;\n    if (p.y == R.y - 1) switch (R.x - 1 - p.x) {\n      case slotResolution:\n        c.xy = vec2(R);\n        break;\n      case slotEyePosAz:\n        c = vec4(state.eyepos, state.eyeaim.x);\n        break;\n      case slotEyeVelEl:\n        c = vec4(state.eyevel, state.eyeaim.y);\n        break;\n      default:\n        break;\n    }\n}\n\n// material ids\nconst int\n  mSky  = 0\n, mGray = 1\n, mRed  = 2\n;\n\n// compute material (albedo for now) from id\nvec3 Material(int i)\n{\n    vec3 a;\n    switch (i) {\n      default:\n      case mSky:  a = vec3(0); break;\n      case mGray: a = vec3(.5); break;\n      case mRed:  a = vec3(1,0,0); break;\n    }\n    return a;\n}\n\nvec3 Light(int m, vec3 p, vec3 n, vec3 v)\n{\n    return mix(n.y, 1., .5) * vec3(1);\n}\n\nconst float voxtile = 8.;\nconst vec3 voxorg = vec3(0,2,0);\n\nvec3 voxpos(ivec3 i)\n{\n//    i.x += (i.x^i.y^i.z)&1; // ensure using a valid id\n    return vec3(i) * voxtile + voxorg;\n}\n     \n// given world space position, return closest voxel id\nivec3 voxid(vec3 p)\n{\n    p -= voxorg;\n    p /= voxtile;\n    ivec3 i = ivec3(round(p)); //floor(p + .5)); //\n  #if 1\n    // can disable rhombic dodecahedron voronoi cell tiling (diamonds in 2D)\n    if (((i.x^i.y^i.z)&1) != 0) {\n        vec3 d = p - vec3(i);\n        vec3 a = abs(d);\n        if (a.x > max(a.y, a.z)) i.x += int(sign(d.x));\n        else if (a.y > a.z)      i.y += int(sign(d.y));\n        else                     i.z += int(sign(d.z));\n    }\n   #endif\n    return i;\n}\n\nbool isVoxel(ivec3 i)\n{\n    return i.y >= 0 && i.y <= 1;\n}\n\nivec3 voxstorage(ivec3 i)\n{\n    i.x >>= 1;\n    return i;\n}\n\n// returns (distance, material)\n// FIXME converting material back&forth between float&int unnecessarily\n// but would require a custom struct or out args\nvec2 Scene(vec3 p)\n{\n    float tile = voxtile\n    , scale = 2. //1.6*.5*tile //sqrt(2.)*.5*tile //.5 // object radius\n    ;\n    ivec3 i = voxid(p);\n    vec3 q = p - voxpos(i);\n    float l = length(q)\n    , s = .7*.5*tile // cell \"radius\"\n    , db = l - scale // ball at lattice points\n    , dp = p.y; // ground plane +Y\n    // guess we're attempting to estimate the distance\n    // to the next cell, plus the distance from there\n    // to that cell's object, which also depends on the\n    // cell size, so I guess it makes sense.\n    db = max(db, p.y-tile*4.+.5); // intersect tiled balls with a slab - hacky way\n    return db < dp\n    \t? vec2(db, mRed)\n        : vec2(dp, mGray);\n}\n    // FIXME Was a good idea, but it no longer works, if it ever did :(\n    // it's only getting to the next cell, not to the next ball\n    // need to estimate which cell is the closest and measure distance to that!\n    //if (!isVoxel(i)) // no object in this cell?\n    //    db = clamp(tile-l-scale, 0.01, tile); //clamp(2.*s-l-scale, 0.01, s); //.5*tile+scale-db; // estimate distance to nearest neighbor cell\n\n// TODO originally I had this in here when I\n// was tiling the spheres with simple cubic lattice,\n// but after I discovered the FCC tiling method, and\n// I copied it into Rhombic Dodecahedron Voxels,\n// which wound up being published way earlier than this,\n// the code here disappeared around when I upgraded the lattice to\n// FCC, and somehow this clever bit of code almost got lost.\n// It needs a home to show it off:  But here may not be the best place.\n// I just don't want to lose it again!\n/*\n\tvec3 p ...; float tile = 2.; ivec3 i = ivec3(floor(p/tile));\n    if (((i.x^i.y^i.z)&1) != 0) {\n        vec3 d = p - .5*tile;\n        vec3 a = abs(d);\n        d = sign(d);\n        if (a.x > a.y && a.x > a.z) d.yz = vec2(0.); // x max\n        else if (a.y > a.z) d.xz = vec2(0.); // y max\n        else d.xy = vec2(0.); // z largest component\n    \tp -= d * tile; // snap to closest neighbor cell\n    }\n*/\n\n// FIXME should loop using IZERO to limit compile time bloat with complex scene\nvec3 SceneNormal(vec3 p, float h, out float d)\n{\n    vec3 n = vec3(\n          Scene(p + vec3(h,0,0)).x\n        , Scene(p + vec3(0,h,0)).x\n        , Scene(p + vec3(0,0,h)).x\n      ) - (d = Scene(p).x);\n    if (dot(n,n) < 1e-7) n = vec3(0,1,0);\n    else n = normalize(n);\n    return n;\n}\n\n// returns (distance, material, nearestmissdistance)\nvec3 March(vec3 ro, vec3 rd, float rate, int iters)\n{\n    vec3 c = vec3(3.4e38, mSky, 3.4e38);\n    int i = iters;\n    float t = 0.;\n    const float thresh = 3e-3;\n    while (i-- > 0) {\n        vec2 h = Scene(ro + rd * t);\n        float d = h.x;\n        t += d * rate;\n        if (abs(d) < abs(c.z)) {\n            c.yz = h.yx; \n        \tif (abs(d) < thresh) {\n        \t    c.yz = h.yx;\n        \t    break;\n        \t}\n        }\n    }\n    int m = int(c.y);\n    if (abs(c.z) > thresh * 2.) m = mSky;\n    const float dmax = 1e4; //8.5e4; //9e3; //\n    if (m == mSky) // HACK different rescue\n        if (rd.y >= 0. && ro.y > 0.)\n            t = dmax;\n        else \n            m = mGray;\n    c.y = float(m);\n    c.x = clamp(t, 0., dmax);\n    return c;\n}\n\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define Kbd  iChannel3\n\nconst float \n  eyeradius = .25\n, eyespeed = 10.\n, eyespin = 2.    // spin rate per mouse uv\n, eyesmooth = .05 // just a little is plenty\n;\n\nstruct Inputs\n{\n    vec3 move;\n    vec2 mouse;\n    bool button;\n    float dt; // delta time seconds\n    // debug features TODO\n};\n    \nconst int // http://keycode.info\n  KEY_SPACE = 32\n, KEY_SHIFT = 16\n, KEY_C     = 67\n// https://wikipedia.org/wiki/Arrow_keys#WASD_keys\n, KEY_W     = 87\n, KEY_A     = 65\n, KEY_S     = 83\n, KEY_D     = 68\n// in DVORAK it's ,AOE, in AZERTY it's ZQSD\n, KEY_Z     = 90\n, KEY_Q     = 81\n, KEY_O     = 79\n, KEY_E     = 69\n, KEY_G     = 71\n, KEY_COMMA = 188\n, KEY_LEFT  = 37 // arrow keys\n, KEY_RIGHT = 39\n, KEY_UP    = 38\n, KEY_DOWN  = 40\n, KEY_PGUP  = 33\n, KEY_PGDN  = 34\n// key bindings to local directions\n#if 0\n    // arrows\n, KEY_LF    = KEY_LEFT\n, KEY_RT    = KEY_RIGHT\n, KEY_FW    = KEY_UP\n, KEY_BW    = KEY_DOWN\n#elif 0\n    // AZERTY ZQSD\n, KEY_FW    = KEY_Z\n, KEY_LF    = KEY_Q\n, KEY_BW    = KEY_S\n, KEY_RT    = KEY_D\n#elif 0\n    // DVORAK ,AOE\n, KEY_FW    = KEY_COMMA\n, KEY_LF    = KEY_A\n, KEY_BW    = KEY_O\n, KEY_RT    = KEY_E\n#else\n    // QWERTY\n, KEY_FW    = KEY_W\n, KEY_LF    = KEY_A\n, KEY_BW    = KEY_S\n, KEY_RT    = KEY_D\n#endif\n, KEY_UW    = KEY_SPACE // up - maybe PgUp/Dn?\n, KEY_DW    = KEY_C     // down - anything but control!\n//, KEY_F     = 70\n//, KEY_R     = 82\n//, KEY_V     = 86\n//, KEY_X     = 88\n//, KEY_TAB   = 9\n;\n\nfloat key(int vk)\n{\n    return step(.5, texelFetch(Kbd, ivec2(vk, 0), 0).x);\n}\n\nbool option(int vk)\n{\n    return .5 <= texelFetch(Kbd, ivec2(vk,2), 0).x;\n}\n\nvoid LoadInputs(out Inputs inp)\n{\n    inp.button = iMouse.z >= 0.;\n    inp.mouse = iMouse.xy;\n    if (iMouse.xyz == vec3(0)) // icon? //dot(iMouse,iMouse) < 1e-3) //\n        inp.mouse.y = iResolution.y*.5; // don't look at ground\n    inp.move =\n      vec3(key(KEY_RT) - key(KEY_LF)\n         , key(KEY_UW) - key(KEY_DW)\n         , key(KEY_FW) - key(KEY_BW))\n    + vec3(key(KEY_RIGHT) - key(KEY_LEFT)\n         , key(KEY_PGUP ) - key(KEY_PGDN)\n         , key(KEY_UP   ) - key(KEY_DOWN)) // arrows alternate controls\n      ;\n    inp.dt = iTimeDelta;\n}\n\nvec3 CollideSphere(vec3 pos, float radius)\n{\n    float d;\n    vec3 n = SceneNormal(pos, radius, d);\n    pos -= n * min(0., d - radius * .7); // collision\n    n = SceneNormal(pos, radius, d);\n    pos -= n * min(0., d - radius * .9); // again!\n    n = SceneNormal(pos, radius, d);\n    pos -= n * min(0., d - radius); // again! helps with getting stuck in crevices\n    pos.y = max(pos.y, radius); // HACK prevent going beneath ground plane just in case\n    return pos;\n}\n\nvoid MoveCamera(inout State state, Inputs inp) \n{\n    vec2 oa = state.eyeaim;\n    mat3 view = Camera(oa);\n    float d, spd = eyespeed, dt = inp.dt;\n    if (key(KEY_SHIFT) > .5) spd *= 4.; // just test key directly, it doesn't need to be state\n    vec3 op = state.eyepos\n    , move = inp.move * dt * spd \n    , p = op\n    ;\n\tp += view * move;\n    #if COLLISION\n    p = CollideSphere(p, eyeradius);\n    #endif\n    state.eyepos = p;\n    state.eyevel = (p - op) / max(1e-7, dt);\n    float evl2 = dot(state.eyevel, state.eyevel);\n    state.eyevel *= isnan(evl2) ? 0. : evl2 > 1e4 ? .5 : 1.;\n}\n\nvoid TurnCamera(inout State state, Inputs inp) \n{\n    vec2 R = vec2(state.resolution) //iResolution.xy\n    , oa = state.eyeaim\n    , a = inp.mouse / R; //iMouse.xy / R;\n    a.x = fract(a.x * eyespin);\n    a.y = clamp(a.y, 0., 1.);\n    if (abs(a.x - oa.x) > .5)\n        oa.x += sign(a.x - oa.x); // put on side of nearest wrapped angle\n    a = mix(a, oa, exp2(-inp.dt / eyesmooth)); // smooth interpolate\n    state.eyeaim = a;\n}\n\nvoid Update(inout State state, ivec2 R, bool init)\n{\n    Inputs inp;\n    LoadInputs(inp);\n    if (state.resolution != R) { // resized?\n        init = true; state.resolution = R; \n    }\n    if (init) { // if zeroes aren't good enough\n        state.eyepos = vec3(0,4.,-5);\n        state.eyeaim = vec2(0.,.5);\n    } else { // update state\n\t    MoveCamera(state, inp);\n\t    TurnCamera(state, inp);\n    }\n}\n\nvoid mainImage(out vec4 o, vec2 p)\n{\n    bool init = iFrame == 0;\n    ivec2 R = ivec2(iResolution)\n    , i = ivec2(p);\n    vec4 c = init\n        ? vec4(0,0,0,1)\n     \t: fetch(BufA, i);\n    State state;\n    LoadState(state, BufA, R);\n    Update(state, R, init);\n    SaveState(c, state, i);\n    o = c;\n}\n\n// want to reserve space in Buffer A for data pixels\n// but don't want to use row 0 since it makes sharing\n// buffer with other code more awkward;\n// however Common tab has no access to iResolution or iChannelResolution\n// and GLES here does not have reliable textureSize for the sampler\n// my solution is to measure these offsets *backward* from R = \n// ivec2(iResolution), so slotResolution actually goes at R-1\n// slotCamPos goes at R - 1 - ivec2(1,0) etc.\n// One problem with putting it here is that it then becomes\n// extremely reliant on the window size not changing,\n// and requires reinitialization on every resize.\n// putting it at 0,0 the other way handles it more gracefully, but\n// at expense of putting a fudge factor in any other buffer access!\n\n","name":"Buffer A","description":"","type":"buffer"}]}