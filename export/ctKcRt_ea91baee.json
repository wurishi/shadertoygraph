{"ver":"0.1","info":{"id":"ctKcRt","date":"1700667584","viewed":135,"name":"20231121_glidephase","username":"0b5vr","description":"test of glidephase function\n\nbass, lead, chord have glides\n","likes":11,"published":1,"flags":40,"usePreview":0,"tags":["audio","synth"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// ** Music shader code is in \"Common\" tab **\n\nconst float SQRT2 = sqrt( 2.0 );\nconst float INV_SQRT2 = 1.0 / SQRT2;\n\nfloat plot( vec2 p ) {\n  int MAX_SAMPLES = min( 1024, int( iResolution.x ) );\n  float d = 2.0 / iResolution.y;\n  \n  float sum = 0.0;\n  for ( int i = 0; i < MAX_SAMPLES; i ++ ) {\n    vec2 s = texelFetch( iChannel0, ivec2( i, 0 ), 0 ).xy * mat2( -0.5, 0.5, 0.5, 0.5 );\n    float r = length( p - s );\n    sum += smoothstep( d, 0.0, r - 0.003 );\n  }\n  return sum;\n}\n\nfloat bgPattern( vec2 p ) {\n  float d = 2.0 / iResolution.y;\n\n  float rect = 0.0;\n  rect += smoothstep( 2.0 * d, 0.0, abs( p.x + p.y ) ) * smoothstep( 2.0 * d, 0.0, abs( p.x - p.y ) - 0.95 );\n  rect += smoothstep( 2.0 * d, 0.0, abs( p.x - p.y ) ) * smoothstep( 2.0 * d, 0.0, abs( p.x + p.y ) - 0.95 );\n  rect += smoothstep( 2.0 * d, 0.0, abs( abs( p.x + p.y ) - 1.0 ) ) * smoothstep( 2.0 * d, 0.0, abs( p.x - p.y ) - 1.0 );\n  rect += smoothstep( 2.0 * d, 0.0, abs( abs( p.x - p.y ) - 1.0 ) ) * smoothstep( 2.0 * d, 0.0, abs( p.x + p.y ) - 1.0 );\n  rect += smoothstep( 2.0 * d, 0.0, abs( p.x ) ) * smoothstep( d, 0.0, abs( p.y ) - 0.95 );\n  return min( rect, 1.0 );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 uv = fragCoord / iResolution.xy;\n  vec2 p = 2.0 * uv - 1.0;\n  p.x *= iResolution.x / iResolution.y;\n  \n  float shape = 0.0;\n  \n  shape += plot( p );\n  shape += 0.1 * bgPattern( p );\n\n  fragColor = vec4( vec3( shape ), 1.0 );\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  if ( fragCoord.y > 1.0 ) {\n    fragColor = vec4( 0.0 );\n  } else {\n    vec2 s = mainAudio( int( SAMPLES_PER_SEC * iTime - fragCoord.x ) );\n\n    fragColor = vec4( s, 0.0, 1.0 );\n  }\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define BPM 140.0\n#define SAMPLES_PER_SEC iSampleRate\n#define SAMPLES_PER_STEP int(iSampleRate * 15.0 / BPM)\n#define STEP2TIME (float(SAMPLES_PER_STEP) / SAMPLES_PER_SEC)\n\n#define TRANSPOSE 4.0\n\n#define saturate(x) clamp(x, 0., 1.)\n#define repeat(i, n) for (int i = 0; i < n; i++)\n\nconst float LN2 = log(2.0);\nconst float TAU = acos(-1.0) * 2.0;\n\nuvec3 hash3u(uvec3 x) {\n  const uint k = 1103515245u;\n  x = ((x >> 8U) ^ x.yzx) * k;\n  x = ((x >> 8U) ^ x.yzx) * k;\n  x = ((x >> 8U) ^ x.yzx) * k;\n  return x;\n}\n\nvec3 hash3f(vec3 v) {\n  uvec3 x = floatBitsToUint(v);\n  return vec3(hash3u(x)) / float(-1u);\n}\n\nvec2 cis(float t) {\n  return vec2(cos(t), sin(t));\n}\n\nmat2 rotate2D(float x) {\n  vec2 v = cis(x);\n  return mat2(v.x, v.y, -v.y, v.x);\n}\n\nvec2 boxMuller(vec2 xi) {\n  float r = sqrt(-2.0 * log(xi.x));\n  float t = xi.y;\n  return r * cis(TAU * t);\n}\n\nfloat p2f(float p) {\n  return exp2((p - 69.0) / 12.0) * 440.0;\n}\n\nfloat cheapFilterSaw(float phase, float k) {\n  float wave = fract(phase);\n  float c = smoothstep(1.0, 0.0, wave / k);\n  return (wave + c) * 2.0 - 1.0 - k;\n}\n\nvec2 cheapFilterSaw(vec2 phase, float k) {\n  vec2 wave = fract(phase);\n  vec2 c = smoothstep(1.0, 0.0, wave / k);\n  return (wave + c) * 2.0 - 1.0 - k;\n}\n\nfloat glidephase(float t, float t1, float p0, float p1) {\n  if (p0 == p1) {\n    return t * p2f(p1);\n  }\n\n  float m0 = (p0 - 69.0) / 12.0;\n  float m1 = (p1 - 69.0) / 12.0;\n  float b = (m1 - m0) / t1;\n\n  return (\n    + p2f(p0) * (pow(2.0, b * min(t, t1)) - 1.0) / b / LN2\n    + max(0.0, t - t1) * p2f(p1)\n  );\n}\n\nvec2 shotgun(float t, float spread, float snap, float fm) {\n  vec2 sum = vec2(0.0);\n\n  repeat(i, 64) {\n    vec3 dice = hash3f(vec3(i + 1));\n\n    vec2 partial = exp2(spread * dice.xy);\n    partial = mix(partial, floor(partial + 0.5), snap);\n\n    sum += sin(TAU * t * partial + fm * sin(TAU * t * partial));\n  }\n\n  return sum / 64.0;\n}\n\nmat3 orthBas(vec3 z) {\n  z = normalize(z);\n  vec3 x = normalize(cross(vec3(0, 1, 0), z));\n  vec3 y = cross(z, x);\n  return mat3(x, y, z);\n}\n\nvec3 cyclicNoise(vec3 p, float pump) {\n  vec4 sum = vec4(0);\n  mat3 rot = orthBas(vec3(2, -3, 1));\n\n  repeat(i, 5) {\n    p *= rot;\n    p += sin(p.zxy);\n    sum += vec4(cross(cos(p), sin(p.yzx)), 1);\n    sum *= pump;\n    p *= 2.;\n  }\n\n  return sum.xyz / sum.w;\n}\n\nivec4 seq16(int seq, int frame, int sps) {\n  int st = frame / sps;\n  int rotated = ((seq >> (15 - st)) | (seq << (st + 1))) & 0xffff;\n\n  int prevStepBehind = int(log2(float(rotated & -rotated)));\n  int prevStep = st - prevStepBehind;\n  int nextStepForward = 16 - int(floor(log2(float(rotated))));\n  int nextStep = st + nextStepForward;\n\n  return ivec4(\n    prevStep,\n    frame - sps * prevStep,\n    nextStep,\n    sps * nextStep - frame\n  );\n}\n\nvec2 mainAudio(int frame) {\n  vec4 time = vec4((frame) % (SAMPLES_PER_STEP * ivec4(1, 4, 16, 256))) / SAMPLES_PER_SEC;\n  float bars = float(frame) / SAMPLES_PER_SEC / 16.0 / STEP2TIME;\n\n  vec2 dest = vec2(0);\n  float sidechain;\n\n  { // kick\n    ivec4 seq = seq16(0x8200, frame % (16 * SAMPLES_PER_STEP), SAMPLES_PER_STEP);\n    float t = float(seq.y) / SAMPLES_PER_SEC;\n    float q = float(seq.w) / SAMPLES_PER_SEC;\n    sidechain = 0.2 + 0.8 * smoothstep(0.0, 0.4, t) * smoothstep(0.0, 0.001, q);\n\n    float env = smoothstep(0.0, 0.001, q) * smoothstep(0.3, 0.1, t);\n\n    float wave = sin(\n      270.0 * t\n      - 30.0 * exp(-t * 20.0)\n      - 20.0 * exp(-t * 60.0)\n      - 10.0 * exp(-t * 500.0)\n    );\n    dest += 0.6 * tanh(2.0 * env * wave);\n  }\n\n  { // bass\n    const int steps[] = int[](0, 6, 26, 32, 54, 58, 64);\n    const int notes[] = int[](-2, 0, 12, 15, 8, 7, -2);\n\n    int st = frame / SAMPLES_PER_STEP % 64;\n    int i = 0;\n    for (i = 0; i < 7; i++) {\n      if (st < steps[i]) {\n        break;\n      }\n    }\n\n    int f = frame % (SAMPLES_PER_STEP * 64) - SAMPLES_PER_STEP * steps[i - 1];\n    float t = float(f) / SAMPLES_PER_SEC;\n    float l = float(steps[i] - steps[i - 1]) * STEP2TIME;\n    float q = l - t;\n\n    float env = smoothstep(0.0, 0.001, t) * smoothstep(0.0, 0.01, q);\n    float fmenv = exp(-8.0 * t);\n\n    float p0 = 24.0 + TRANSPOSE + float(notes[i - 1]);\n    float p1 = 24.0 + TRANSPOSE + float(notes[i]);\n\n    // sub bass\n    float phase = glidephase(t, 2.0 * STEP2TIME, p0, p1);\n    float wave = sin(TAU * phase);\n    dest += 0.2 * sidechain * tanh(2.0 * env * wave);\n\n    // unison\n    repeat(iUnison, 4) {\n      vec3 dice = hash3f(vec3(iUnison, 4, 4));\n      vec2 dicen = boxMuller(dice.xy);\n\n      vec2 phaseu = phase * exp2(0.03 * dicen.xy) + dice.xy;\n      vec2 wave = cheapFilterSaw(phaseu, 0.04);\n      dest += 0.1 * sidechain * tanh(2.0 * env * wave);\n    }\n  }\n\n  { // hihat\n    float t = time.x;\n    float st = float(frame / SAMPLES_PER_STEP % 16);\n\n    float vel = fract(st * 0.2 + 0.62);\n    float env = exp(-exp2(6.0 - 3.0 * vel) * t);\n    vec2 wave = shotgun(6000.0 * t, 2.0, 0.0, 0.5);\n    dest += 0.2 * env * sidechain * tanh(8.0 * wave);\n  }\n\n  { // clap\n    ivec4 seq =\n        seq16(0x0820, frame % (16 * SAMPLES_PER_STEP), SAMPLES_PER_STEP);\n    float t = float(seq.y) / SAMPLES_PER_SEC;\n    float q = float(seq.w) / SAMPLES_PER_SEC;\n\n    float env = mix(\n      exp(-26.0 * t),\n      exp(-200.0 * mod(t, 0.013)),\n      exp(-80.0 * max(0.0, t - 0.02))\n    );\n\n    vec2 wave = cyclicNoise(vec3(4.0 * cis(900.0 * t), 1940.0 * t), 1.5).xy;\n\n    dest += 0.15 * tanh(20.0 * env * wave);\n  }\n\n  { // shaker\n    float t = time.x;\n    float st = float(frame / SAMPLES_PER_STEP % 16);\n\n    float vel = fract(st * 0.41 + 0.62);\n    float env = smoothstep(0.0, 0.02, t) * exp(-exp2(6.0 - 3.0 * vel) * t);\n    vec2 wave = cyclicNoise(vec3(cis(600.0 * t), exp2(10.0 + 3.0 * vel) * t), 0.8).xy;\n    dest += 0.15 * env * sidechain * tanh(2.0 * wave);\n  }\n\n  { // crash\n    float t = time.w;\n\n    float env = mix(exp(-t), exp(-10.0 * t), 0.7);\n    vec2 wave = shotgun(3800.0 * t, 2.0, 0.0, 3.0);\n    dest += 0.3 * env * sidechain * tanh(8.0 * wave);\n  }\n\n  { // glide lead\n    const int N_NOTES = 16;\n    int notes[N_NOTES] = int[](\n      0, 7, 14, 7,\n      15, 22, 7, 26,\n      0, 22, 17, 19,\n      7, 14, 15, 7\n    );\n\n    repeat(iStep, N_NOTES) {\n      float l = STEP2TIME;\n      int f = (frame + SAMPLES_PER_STEP * (N_NOTES - iStep)) % (N_NOTES * SAMPLES_PER_STEP);\n      float t = float(f) / SAMPLES_PER_SEC;\n\n      float p0 = 60.0 + TRANSPOSE + float(notes[max(0, iStep - 1) % N_NOTES]);\n      float p1 = 60.0 + TRANSPOSE + float(notes[iStep]);\n      float phase = glidephase(t, 0.02, p0, p1);\n\n      float delayDecay = exp(-5.0 * t);\n      f = f % (3 * SAMPLES_PER_STEP);\n      t = float(f) / SAMPLES_PER_SEC;\n      float q = l - t;\n\n      float env = smoothstep(0.0, 0.001, t) * mix(0.2, 1.0, smoothstep(0.0, 0.01, q));\n      float filt = 1.0 - 1.0 * exp(-2.0 * t);\n\n      vec2 sum = vec2(0.0);\n\n      repeat(iUnison, 4) {\n        vec3 dice = hash3f(vec3(iUnison, 1, 12));\n        vec2 dicen = boxMuller(dice.xy);\n\n        vec2 phaseu = phase * exp2(0.01 * dicen.xy - float(iUnison % 2)) + dice.xy;\n        vec2 wave = cheapFilterSaw(phaseu, filt);\n        sum += 0.1 * sidechain * delayDecay * env * wave;\n      }\n\n      dest += sum * rotate2D(float(iStep));\n    }\n  }\n\n  { // chord\n    int chords[16] = int[](\n      0, 3, 7, 10, 17, 19, 24, 26, // Im\n      -4, 0, 3, 7, 10, 12, 17, 22  // VIb\n    );\n\n    int f = frame % (32 * SAMPLES_PER_STEP);\n    float t = float(f) / SAMPLES_PER_SEC;\n    float q = 32.0 * SAMPLES_PER_SEC - t;\n\n    float env = smoothstep(0.0, 0.001, t) * smoothstep(0.0, 0.01, q);\n\n    vec2 sum = vec2(0.0);\n\n    ivec4 seq = seq16(0x9627, frame % (16 * SAMPLES_PER_STEP), SAMPLES_PER_STEP);\n    float seqt = float(seq.y) / SAMPLES_PER_SEC;\n    float curve = seq.x >= 14\n      ? exp(-6.0 * mod(seqt, 0.5 * STEP2TIME))\n      : exp(-2.0 * seqt);\n    float radius = mix(0.1, 0.4, curve);\n    float pers = exp2(mix(2.0, -1.0, curve));\n\n    repeat(iUnison, 64) {\n      vec3 dice = hash3f(vec3(iUnison, 7, 7));\n      vec2 dicen = boxMuller(dice.xy);\n\n      int prog = 8 * (frame / 32 / SAMPLES_PER_STEP);\n      float p0 = 48.0 + TRANSPOSE + float(chords[iUnison % 8 + max(0, prog - 8) % 16]);\n      float p1 = 48.0 + TRANSPOSE + float(chords[iUnison % 8 + prog % 16]);\n\n      float phase = glidephase(t, 8.0 * STEP2TIME, p0, p1) + dice.x;\n      phase *= exp(0.01 * dicen.x);\n\n      vec2 wave = cyclicNoise(vec3(radius * cis(TAU * phase), 8.0), pers).xy;\n      sum += 0.04 * env * wave * rotate2D(float(iUnison));\n    }\n\n    dest += sum;\n  }\n\n  return tanh(dest);\n}\n","name":"Common","description":"","type":"common"},{"inputs":[],"outputs":[],"code":"vec2 mainSound( int samp, float _time ) {\n  return mainAudio( samp );\n}\n","name":"Sound","description":"","type":"sound"}]}