{"ver":"0.1","info":{"id":"l3lfzB","date":"1728587099","viewed":95,"name":"Apollonian_Lighted","username":"kosalos","description":"second surface detection colored by orbit trapping","likes":3,"published":3,"flags":0,"usePreview":0,"tags":["raymarching","3dfractal"],"hasliked":0,"parentid":"M3sBWN","parentname":"Apollonian_Sliced"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float foam = 0.064;\nfloat foam2 = 1.07;\nfloat mult = 0.499;\nvec3 camera = vec3( -6.46559999, -7.33265000, -7.73873000);\nvec3 aim = vec3(0.76312483, -0.08013050, -0.64126405);\nfloat ostrength = 0.36;\nfloat ocycle = 0.;\nvec4 orbit2 = vec4( 0.38347405, 1.86336986, -0.01788503, -2.71105793);\nvec4 orbit3 = vec4(0.87534959, 1.04847687, 0.03234359, 0.00505466);\nvec3 orbit4 = vec3(-2.19183836, 1.41098694, 1.56200985);\nvec3 phongColor =  vec3(0.21999000, 0.30000000, 0.31999000);\nvec3 phongPosition = vec3(7.00000000, -20.00000000, 20.000);\nvec3 phongParam = vec3(0.,10.,5.99);\nvec4 spotLightParam = vec4(0.62,2.26,-2.05,1.32);\nvec3 spotLightColor = vec3(1.,0.44,0.);\n\nvec3 direction;\nvec3 normal;\nvec3 position;\nvec3 color;\nfloat depth;\nint iter;\nvec4 orbitTrap;\n\n// --------------------------------------------------------\n\nfloat DE(vec3 pos) {\n    float t = foam2 + 0.25 * cos(mult * (pos.z - pos.x));\n    float k,scale = 1.0;\n    orbitTrap = vec4(10000.0);\n\n    for(int s=0; s < 4; ++s) {\n        pos = -1.0 + 2.0 * fract(0.5 * pos + 0.5);\n        pos -= sign(pos) * foam;\n\n        k = t / dot(pos,pos);     \n        pos *= k;\n        scale *= k;\n\n        vec3 ot = pos - orbit4;\n        orbitTrap = min(orbitTrap, vec4(abs(ot), dot(ot,ot)));\n    }\n\n    float d1 = sqrt(min(min(dot(pos.xy,pos.xy), dot(pos.yz,pos.yz)), dot(pos.zx,pos.zx))) - 0.02;\n    return 0.5 * min(d1,abs(pos.y)) / scale;\n}\n\n// --------------------------------------------------------\n// https://iquilezles.org/articles/normalsSDF\nvoid calcNormal() {\n    float d0 = DE(position);\n    const vec2 epsilon = vec2(.00001,0);\n    vec3 d1 = vec3(\n        DE(position-epsilon.xyy),\n        DE(position-epsilon.yxy),\n        DE(position-epsilon.yyx));\n    normal = normalize(d0 - d1);\n}\n\n// --------------------------------------------------------\n\nvoid setDirection(vec2 U) {\n    vec3 viewVector = normalize(aim);//-qcamera);\n    vec3 sideVector = vec3(0.,1.,0.);\n    sideVector = cross(sideVector,viewVector);\n    sideVector = normalize(sideVector);\n    vec3 topVector = viewVector;\n    topVector = cross(topVector,sideVector);\n    \n    vec2 vPos = (U - iResolution.xy * 0.5)/iResolution.y;\n    direction = normalize(viewVector + vPos.x * sideVector + vPos.y * topVector);\n}\n\n// --------------------------------------------------------\n\nvec3 generateColor(float weight,float x) {\n\tif(weight == 0.0) return vec3(0.0);\n\n\tx = cos(x);\n\tfloat r = (1.0-x)*(1.0-x);\n\tfloat g = x*x;\n\tfloat b = 2.0*(1.0-x)*x;\n\treturn vec3(r,g,b);\n}\n\nvec3 orbitTrapCycle(float cycle,vec3 c, float s) {\n    float ss = s * cycle;\n    return vec3(0.5) + 0.5 * vec3( cos(ss + c.x), cos(ss + c.y), cos(ss + c.z));\n}\n\nvec3 getOrbitColor() {\n    vec3 orbitColor;\n    \n    if (ocycle > 0.0) {\n        orbitColor =\n        orbitTrapCycle(ocycle,generateColor(orbit2.x,orbit2.y), orbitTrap.x) * orbit2.x * orbitTrap.x +\n        orbitTrapCycle(ocycle,generateColor(orbit2.z,orbit2.w), orbitTrap.y) * orbit2.z * orbitTrap.y +\n        orbitTrapCycle(ocycle,generateColor(orbit3.x,orbit3.y), orbitTrap.z) * orbit3.x * orbitTrap.z +\n        orbitTrapCycle(ocycle,generateColor(orbit3.z,orbit3.w), orbitTrap.w) * orbit3.z * orbitTrap.w;\n    } else {\n        orbitColor =\n        \tgenerateColor(orbit2.x,orbit2.y) * orbit2.x * orbitTrap.x +\n        \tgenerateColor(orbit2.z,orbit2.w) * orbit2.z * orbitTrap.y +\n        \tgenerateColor(orbit3.x,orbit3.y) * orbit3.x * orbitTrap.z +\n        \tgenerateColor(orbit3.z,orbit3.w) * orbit3.z * orbitTrap.w;\n    }\n    \n    return orbitColor;\n}\n\n// --------------------------------------------------------\n\nvoid phongLight() {\n\tvec3 L = normalize(phongPosition - position);\n\tfloat dotLN = dot(L, normal);\n\tif (dotLN < 0.) return;\n\t\t\n\tfloat t1 = phongParam.x * dotLN;\n\tvec3 V = normalize(camera - position);\n\tvec3 R = normalize(reflect(-L, normal));\n\tfloat dotRV = dot(R, V);\n\n\tif (dotRV < 0.0)\n\t\tcolor += vec3(phongColor * t1);\n\n\tfloat t2 = phongParam.y * pow(abs(dotRV), phongParam.z);\n\tcolor += phongColor * (t1 + t2);\n}\n\n// --------------------------------------------------------\n\nconst float PI = acos(-1.);\n\nvoid spotLight() { \n\tfloat a1 = spotLightParam.y * PI;\n\tfloat a2 = spotLightParam.z * PI * 0.5;\n\tfloat s1 = sin(a1);\n\tvec3 spotDir = vec3(a1*s1,a2*s1, cos(a1));\n\tspotDir = normalize(spotDir);\n\tvec3 halfVector = normalize(spotDir - direction);\n\n\tfloat nDotL = max(0., dot(normal, spotDir));\n\tfloat hDotN = max(0., dot(normal, halfVector));\n\n    vec3 c = spotLightColor * spotLightParam.x;\n    float sexp = spotLightParam.w;\n\n\tcolor += c * ((sexp + 2.) / 2.) * pow(hDotN, sexp) \n\t\t* (sexp + (1. - sexp) * pow(1. - hDotN, 5.)) * nDotL * spotLightParam.x;\n}\n\n// --------------------------------------------------------\n\nvoid ambient() { \n    const float amb = 0.1369;\n    float dim = 0.05 + (0.5 + sin(iTime * 0.1) * 0.5) * 0.05;\n    const float contrast = 0.8;\n    color = vec3(amb) + vec3(1. - float(iter) * dim);\n        \n    if(ostrength > 0.0) {\n        vec3 oColor = getOrbitColor();\n        color = mix(color, oColor, ostrength);\n    }\n\n    phongLight();\n    spotLight();\n    color = vec3(0.5) + (color - vec3(0.5)) * contrast; \n}\n\n// --------------------------------------------------------\nconst float MIN_DIST = 0.02;\nconst float MAX_DIST = 12.0;\nconst float EP = 0.00001;\n\nvoid rayMarch() {\n\tfloat distance;\n\tposition = camera;\n\titer = 0;\n\tdepth = MIN_DIST;\n    \n    orbitTrap = vec4(10000.);\n\t\n\tfor(int i = 0;i < 100;++i) {\n\t\tdistance = DE(position);\n        if(abs(distance) < EP || depth > MAX_DIST) break;\n        iter += 1;\n\t\t\n        depth += distance;\n        position += direction * distance;\n    }\n}\n\n// --------------------------------------------------------\n\n#define animate(v,v1,v2,speed) v = mix(v1,v2,0.5 + sin(iTime * speed) * 0.5)\n#define animate2(v,base,delta,speed) v = mix(base-delta,base+delta,0.5 + sin(iTime * speed) * 0.5)\n    \nvoid mainImage(out vec4 O, vec2 U) {\n\n    animate2(foam,0.06, 0.03, 0.1);\n    animate2(foam2,1.0,0.35,  0.15);\n    animate2(mult,0.5,0.015,   0.3);\n\n    animate(camera.x,-6.5,-5.5,   0.035);\n    animate(camera.y,-7.7,-7.,   0.04);\n    animate(camera.z,-7.7,-7.,   0.045);\n    animate(aim.x,-1.,1.,   0.035);\n    animate(aim.y,-1.,1.,   0.04);\n    animate(aim.z,-1.,1.,   0.05);\n \n    animate2(spotLightParam.y,2.26,0.5,0.3);\n    animate2(spotLightParam.z,-2.,0.5,0.35);\n    animate2(spotLightParam.w,1.3,0.5,0.4);\n    animate2(phongParam.x,1.44,0.5,0.3);\n    animate2(phongParam.y,3.,1.,0.35);\n    animate2(phongParam.z,7.,3.,0.4);\n\n    animate(ostrength,0.,0.8,0.1);\n    animate(ocycle,0.,4.,0.18);\n    animate(orbit2.x,-1.,1.,0.011);  // X wt,color\n    animate(orbit2.y,-3.,3.,0.013);\n    animate(orbit2.z,-1.,1.,0.015);  // Y wt,color\n    animate(orbit2.w,-3.,3.,0.017);\n    animate(orbit3.x,-1.,1.,0.019);  // Z wt,color\n    animate(orbit3.y,-3.,3.,0.021);\n    animate(orbit4.x,-3.,3.,0.23);  // center\n    animate(orbit4.y,-3.,3.,0.25);\n    animate(orbit4.z,-3.,3.,0.27);\n\n    setDirection(U);\n\trayMarch();\n    \n    O.xyz = vec3(0.);\n\tif(depth > MAX_DIST) return;  \n    calcNormal();\n    ambient();\n\n  \n    O.xyz = color;\n}\n\n","name":"Image","description":"","type":"image"}]}