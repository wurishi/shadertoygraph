{"ver":"0.1","info":{"id":"DsyGzw","date":"1678456929","viewed":226,"name":"Charge interaction in 3d","username":"Oman395","description":"Got bored in physics class, decided to try and render the way charges interact in 3d. IDK, I thought it was pretty interesting, and it looks cool :D","likes":9,"published":1,"flags":0,"usePreview":0,"tags":["physics","electron","proton","charge"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 uvN = (uv - 0.5) * 2.0;\n    uv.x *= iResolution.x / iResolution.y;\n    uvN.x *= iResolution.x / iResolution.y;\n    vec2 mouse = iMouse.xy / iResolution.xy;\n    mouse = (mouse - 0.5) * 2.0;\n    mouse.x *= iResolution.x / iResolution.y;\n    vec3 pos = camPos(iTime, mouse);\n    vec2 dir = camDir(iTime, mouse);\n    vec3 rayDir = normalize(vec3(uvN, FOCUS));\n    rayDir = rotate(rayDir, dir);\n    vec2 s = sampleRay(pos, rayDir);\n    \n    vec3 marched = march(pos, rayDir);\n    if(distance(marched, pos) < D_MAX) {\n        fragColor = vec4(1);\n    }\n    else fragColor = vec4(s.r, 0, s.g, 1);\n    // fragColor = vec4(s.r, 0, s.g, 1);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// The way I wrote the code that renders the \"cloud\" is a bit weird when the values are accurate,\n// so if this isn't defined, the falloff curve will be 1/(x^2+1), rather than 1/(x^2).\n// #define ACCURATE\n\nconst vec4 charges[] = vec4[](\n    vec4(-1,0,0,-1),\n    vec4(1,0,0,1)\n);\nconst float CHARGE_RAD = 0.1;\nconst vec3 CAM = vec3(0, 0, -4);\nconst float PI = 3.14159265;\nconst float FOCUS = 1.0;\nconst int sampleCount = 64;\nconst float sampleDist = 0.2;\nconst int M_MAX = 32;\nconst float D_MIN = 0.01;\nconst float D_MAX = 12.0;\n\nvec3 rotate(vec3 vec, vec2 angles) {\n    angles = angles.yx;\n    vec = vec3(\n        vec.x,\n        vec.y * cos(angles.x) - vec.z * sin(angles.x),\n        vec.y * sin(angles.x) + vec.z * cos(angles.x)\n    );\n    vec = vec3(\n        vec.x * cos(angles.y) + vec.z * sin(angles.y),\n        vec.y,\n        -vec.x * sin(angles.y) + vec.z * cos(angles.y)\n    );\n    return vec;\n}\n\nvec3 camPos(float iTimse, vec2 iMouse) {\n    return rotate(CAM, iMouse * vec2(PI, -PI));\n}\n\nvec2 camDir(float iTime, vec2 iMouse) {\n    return iMouse * vec2(PI, -PI);\n}\n\nfloat sample3D(vec3 pos) {\n    float acc = 0.0;\n    for(int i = 0; i < charges.length(); i++) {\n        acc += charges[i].a / (1.0 + pow(distance(pos, charges[i].xyz), 2.0));\n    }\n    #ifndef ACCURATE\n    acc = 1.0 / (1.0 + abs(acc)) * sign(acc);\n    #endif\n    return acc;\n}\n\nfloat adScene(vec3 pos) {\n    float d = D_MAX;\n    for(int i = 0; i < charges.length(); i++) {\n        d = min(d, distance(pos, charges[i].xyz));\n    }\n    return d;\n}\n\nfloat sdScene(vec3 pos) {\n    return adScene(pos) - CHARGE_RAD;\n}\n\nvec3 march(vec3 pos, vec3 dir) {\n    for(int i = 0; i < M_MAX; i++) {\n        float d = sdScene(pos);\n        if(d < D_MIN || d > D_MAX) return pos;\n        pos += dir * d;\n    }\n    return pos;\n}\n\nvec2 sampleRay(vec3 pos, vec3 dir) {\n    vec2 acc = vec2(0);\n    int cnt = 0;\n    for(int i = 0; i < sampleCount; i++) {\n        float s = sample3D(pos);\n        #ifndef ACCURATE\n        s = (1.0 - abs(s)) * sign(s);\n        #endif\n        float amntCurrent = (acc.r + acc.g) / 2.0;\n        s *= 1.0 - amntCurrent;\n        if(s < 0.0) acc.g -= s * sampleDist;\n        else acc.r += s * sampleDist;\n        pos += dir * sampleDist;\n    }\n    return acc;\n}","name":"Common","description":"","type":"common"}]}