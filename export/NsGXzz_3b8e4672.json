{"ver":"0.1","info":{"id":"NsGXzz","date":"1634231880","viewed":92,"name":"Material fit","username":"OneManBand","description":"none","likes":1,"published":1,"flags":32,"usePreview":0,"tags":["brdf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 data = texelFetch( iChannel1, ivec2(fragCoord), 0 );\n    vec3 col = data.xyz/data.w;\n\n    // tonemap\n    //col = col*1.4/(1.0+col);\n    \n    // gamma\n    //col = pow( col, vec3(0.4545) );\n    \n    // vignetting\n    //vec2 uv = fragCoord / iResolution.xy;\n    //col *= 0.5 + 0.5*pow( 16.0*uv.x*uv.y*(1.0-uv.x)*(1.0-uv.y), 0.1 );\n    \n    fragColor = vec4( col, 1.0 );\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Reset time after changing this flag.\n#define FURNACE_TEST 0\n\n\nconst float   pif = 3.1416;\n\nstruct ray3f {\n    vec3  o;\n    vec3  d;\n    float tmax;\n    float tmin;\n};\n\nray3f make_ray(vec3 o, vec3 d) {\n    ray3f ray;\n    ray.o    = o;\n    ray.d    = d;\n    ray.tmax = 9999.0;\n    ray.tmin = 0.001;\n    return ray;\n}\n\nstruct material_point {\n    int   type;\n    float roughness;\n};\n\nint intersect_sphere(in ray3f ray, in vec3 p, float r, out float dist) {\n    // compute parameters\n    float a = dot(ray.d, ray.d);\n    float b = 2.0 * dot(ray.o - p, ray.d);\n    float c = dot(ray.o - p, ray.o - p) - r * r;\n\n    // check discriminant\n    float dis = b * b - 4.0 * a * c;\n    if (dis < 0.0) return 0;\n\n    // compute ray parameter for first intersection\n    float t = (-b - sqrt(dis)) / (2.0 * a);\n\n    // exit if not within bounds\n    if (t > ray.tmax) return 0;\n\n    // try other ray parameter (ray origin may be inside the sphere)\n    if (t < ray.tmin) t = (-b + sqrt(dis)) / (2.0 * a);\n    if (t < ray.tmin) return 0;\n\n    dist = t;\n    return 1;\n}\n\n#define num_sphere_centers 15\nvec3  sphere_centers[num_sphere_centers];\nfloat sphere_radius = 0.2;\n\nint intersect_scene(in ray3f ray, out vec3 position, out vec3 normal,\n                    out material_point material) {\n    int   sphere_index = -1;\n    float dist         = 0.0;\n    for (int i = 0; i < num_sphere_centers; i++) {\n        int hit = intersect_sphere(ray, sphere_centers[i], sphere_radius, dist);\n        if (hit > 0) {\n            ray.tmax     = dist;\n            sphere_index = i;\n        }\n    }\n    if (sphere_index == -1) return 0;\n\n    position           = ray.d * dist + ray.o;\n    normal             = normalize(position - sphere_centers[sphere_index]);\n    material.roughness = float(sphere_index) / float(num_sphere_centers);\n    material.type      = 0;\n    return 1;\n}\n\nvec3 eval_light(vec3 incoming) {\n    vec3 radiance;\n    #if FURNACE_TEST\n        radiance = vec3(0.5);\n    #else\n        radiance = texture(iChannel0, incoming).xyz;\n    #endif\n    // radiance = pow(radiance, vec3(2.2));\n    return radiance;\n}\n\nint hash(int n) {\n    n = (n << 13) ^ n;\n    return n * (n * n * 15731 + 789221) + 1376312589;\n}\nint   seed = 0;\nfloat rand(void) {\n    seed = seed * 0x343fd + 0x269ec3;\n    return float((seed >> 16) & 32767) / 32767.0;\n}\n\nmat3 mat_fromz(in vec3 v) {\n    // https://graphics.pixar.com/library/OrthonormalB/paper.pdf\n    vec3 z = normalize(v);\n    // auto sign = copysignf(1.0f, z.z);\n    float sign = (z.z >= 0.0) ? 1.0 : -1.0;\n    float a    = -1.0 / (sign + z.z);\n    float b    = z.x * z.y * a;\n    vec3  x    = vec3(1.0 + sign * z.x * z.x * a, sign * b, -sign * z.x);\n    vec3  y    = vec3(b, sign + z.y * z.y * a, -z.y);\n    return mat3(x, y, z);\n}\n\nmat3 lookat_frame(in vec3 eye, in vec3 center) {\n  const vec3 up = vec3(0.0, 1.0, 0.0);\n  vec3 w = normalize(eye - center);\n  vec3 u = normalize(cross(up, w));\n  vec3 v = normalize(cross(w, u));\n  return mat3(u, v, w);\n}\n\nvec3 sample_sphere(vec2 ruv) {\n  float z   = 2.0 * ruv.y - 1.0;\n  float r   = sqrt(clamp(1.0 - z * z, 0.0f, 1.0f));\n  float phi = 2.0 * pif * ruv.x;\n  return vec3(r * cos(phi), r * sin(phi), z);\n}\n\nvec3 sample_direction(vec3 normal, vec3 outgoing, material_point material, out float pdf) {\n    vec3 incoming = sample_sphere(vec2(rand(), rand()));\n    pdf = 1.0 / (2.0 * pif);\n    if(dot(incoming, normal) < 0.0) incoming = -incoming; \n    return incoming;\n}\n\nvec3 diffuse_brdf(in vec3 normal, in vec3 incoming) {\n    return vec3(1.0) / pif;\n}\n\nvec3 eval_brdf(in vec3 normal, in vec3 incoming, in vec3 outgoing, in material_point material) {\n    if(material.type == 0) return diffuse_brdf(normal, incoming);\n    return vec3(0.0, 1.0, 1.0);\n}\n\nvec3 shade(in vec3 normal, in material_point material) {\n    vec3 outgoing = vec3(0, 0, 1);\n    float pdf = 1.0;\n    vec3 incoming = sample_direction(normal, outgoing, material, pdf);\n    vec3 Li = eval_light(incoming);\n    vec3 brdf = eval_brdf(normal, incoming, outgoing, material);\n    float cos = max(dot(incoming, normal), 0.0);\n    return Li * brdf * cos / pdf;\n}\n \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    sphere_centers[0] = vec3(-1.0, 0.0, 0.0);\n    sphere_centers[1] = vec3(-0.5, 0.0, 0.0);\n    sphere_centers[2] = vec3(+0.0, 0.0, 0.0);\n    sphere_centers[3] = vec3(+0.5, 0.0, 0.0);\n    sphere_centers[4] = vec3(+1.0, 0.0, 0.0);\n    sphere_centers[5] = vec3(-1.0, 0.5, 0.0);\n    sphere_centers[6] = vec3(-0.5, 0.5, 0.0);\n    sphere_centers[7] = vec3(+0.0, 0.5, 0.0);\n    sphere_centers[8] = vec3(+0.5, 0.5, 0.0);\n    sphere_centers[9] = vec3(+1.0, 0.5, 0.0);\n    sphere_centers[10]= vec3(-1.0,-0.5, 0.0);\n    sphere_centers[11]= vec3(-0.5,-0.5, 0.0);\n    sphere_centers[12]= vec3(+0.0,-0.5, 0.0);\n    sphere_centers[13]= vec3(+0.5,-0.5, 0.0);\n    sphere_centers[14]= vec3(+1.0,-0.5, 0.0);\n\n    vec2 uv = fragCoord / iResolution.xy;\n    uv -= vec2(0.5); uv *= 2.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    seed = hash(int(99999.0 * iTime + 1.0) ^ hash(int(fragCoord.x)) ^ hash(int(fragCoord.y)));\n\n    fragColor.xyz = vec3(0);\n\n    ray3f ray = make_ray(vec3(uv.xy, 1), vec3(0, 0, -1));\n   \n   #if 0\n    //float angle = iMouse.x < iResolution.x ? 2.0 * pif * ((iMouse.x / iResolution.x) - 0.5) : 0.0;\n    float angle = iTime;\n    vec3 from = vec3(sin(angle), 0.0, cos(angle));\n    vec3 to = vec3(0);\n    ray.o = lookat_frame(from, to) * ray.o + from;\n    ray.d = lookat_frame(from, to) * ray.d;\n   #endif\n   \n    vec3           position, normal;\n    material_point material;\n\n    int hit = intersect_scene(ray, position, normal, material);\n    vec3 radiance = vec3(0.0);\n    if (hit > 0) {\n        radiance = shade(normal, material);\n    }\n    else {\n        radiance = eval_light(ray.o);\n    }\n    // radiance = pow(radiance, vec3(1.0 / 2.2));\n\n    vec4 data = texture( iChannel1, fragCoord/iResolution.xy );\n    if( iFrame==0 ) data = vec4(0.0);\n    data += vec4(radiance, 1.0);\n\n    fragColor = data;\n}\n","name":"Buffer A","description":"","type":"buffer"}]}