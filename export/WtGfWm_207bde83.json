{"ver":"0.1","info":{"id":"WtGfWm","date":"1614756675","viewed":94,"name":"N-Sided Pyramid","username":"sahemera","description":"Attempt at N-sided pyramid. I'm unsatisfied that the height of the pyramid seems to change depending on the number of sides but I don't understand where that is coming from. If you have the time and understand why I would appreciate a pointer!","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","sdf","pyramid"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST 0.01\n#define TAU 6.283185\n\n\n//Returns distance from point to a plane defined by its origin and its normal\n//Credit goes to decrooks\nfloat  plane(vec3 p, vec3 origin, vec3 normal){ \n    return dot(p - origin,normal);   \n}\n\n//First assemble a 4-sided pyramid\nfloat pyramid(vec3 p, float d) {\n    float dn =1.0/sqrt(4.0);\n    //The tetrahedran is the intersection of four planes:\n    float sd1 = plane(p,vec3(d,0.,0.), vec3(dn,dn,0.)) ;\n    float sd3 = plane(p,vec3(0.,0.,d), vec3(0,dn,dn)) ;\n    float sd2 = plane(p,vec3(-d,0.,0.), vec3(-dn,dn,0.)) ;\n    float sd4 = plane(p,vec3(0.,0.,-d), vec3(0,dn,-dn)) ;\n\n    float sd5 = plane(p,vec3(0.,-d,0.), vec3(0,-1,0)) ;\n\n    return max(max(sd1,sd2),max(sd3,max(sd5,sd4)));\n}\n\n//Generalized n-sided pyramid. \nfloat nPyramid(vec3 p, float d, int sides) {\n    float sidesf = float(sides);\n    float dn = 1.0/sqrt(3.0 + 1.0);\n    float sdf = plane(p,vec3(0.,-d,0.), vec3(0,-1,0));\n    \n    \n    //Use points around a circle in the center of the pyramid to define the planes\n    float arcAdd = TAU / sidesf;\n    \n    //The 3-sided pyramid is much bigger than the other pyramids\n    //because we're defining by planes instead of vertices,\n    //so attempt to scale the size so that the size hopefully\n    //remains the saaame or close enough between numbers of sides\n    //d *= cos(arcAdd/2.);\n    \n    //Intersect planes until we have the pyramid\n    for(int side = 0; side < sides; side++)\n    {\n        float az = arcAdd*float(side);\n        float sdn = plane(p,vec3(d*cos(az),0,d*sin(az)), vec3(dn*cos(az),dn,dn*sin(az)));\n        \n        ////max intersects shapes\n        sdf = max(sdf, sdn);\n    }\n\n    return sdf;\n}\n\n\n\nfloat GetDist(vec3 p) {\n    float time = iTime;\n    \n    float planeDist = p.y+0.3;\n    float planeDist2 = p.y+0.5;\n    \n    float tetra = nPyramid(p - vec3(0.,2.,0.), 1., 3 + int(mod(time*2.16,8.)));\n\n    //Return whichever distance is closer\n    float d = max(planeDist,sin(p.x*p.x/5. - time + sqrt(p.z*p.z  ))*cos(p.z + p.x + time/4.)/4.);\n    d = min(d, planeDist2);\n    d = min(d,tetra);\n    \n    return d;\n}\n\n\n//Move from the rayOrigin in the rayDistance until we collide with the scene or fly off into INF\n//RayMarch is also called Sphere Tracing because when we get the distance from each position as\n//we march along the array, that distance creates an arc or sphere around the position that defines\n//how much we will step on the next iteration.\nfloat RayMarch(vec3 rayOrigin, vec3 rayDistance)\n{\n    float distanceOrigin = 0.02;\n    \n    for(int i = 0; i < MAX_STEPS; i++)\n    {\n        //Get next point\n        vec3 p = rayOrigin + rayDistance*distanceOrigin;\n        \n        //Get distance from new point to the scene\n        float dS  = GetDist(p);\n        \n        //Add distance from new point to total distance from origin\n        distanceOrigin += dS;\n        \n        //If we have marched too far or if we are sufficiently close to scene, we're done marching\n        if(distanceOrigin > MAX_DIST || dS < SURF_DIST) break;\n    }\n    return distanceOrigin;\n}\n\n/***Gets the normal of a point to the nearest part of the scene defined by GetDist*/\nvec3 GetNormal_Generic(vec3 p) {\n    \n    vec2 epsilon = vec2(0.01, 0);\n    \n    //Get the distance from scene to the point\n    float d = GetDist(p);\n    \n    //Get the slope by subtracting nearby points from the point and normalizing their direction\n    vec3 n = vec3(\n        d - GetDist(p - epsilon.xyy), //*.xyy and xyx are called a \"swizzle\", just makes it faster to write\n        d - GetDist(p - epsilon.yxy),\n        d - GetDist(p - epsilon.yyx));\n        \n    return normalize(n);\n}\n\n\n//Diffuse light algorithm is defined as the dot product of a normal vector and a light vector\nfloat GetLight_Diffuse(vec3 p) {\n    vec3 lightPos = vec3(0, 5, 6); //arbitrary position in space\n    \n    lightPos.xz += vec2(2.*sin(4.0*iTime), 2.*cos(4.0*iTime));\n    \n    //Ray from the found scene position to the light position, normalized to [0,1]\n    vec3 lightRay = normalize(lightPos-p);\n    vec3 normalRay = GetNormal_Generic(p);\n    \n    //Dot product returns [-1:1], so cap negative numbers to 0\n    float dif = clamp(dot(normalRay, lightRay), 0.0, 1.0);\n    return dif;\n}\n\n\n//Diffuse light algorithm is defined as the dot product of a normal vector and a light vector\nfloat GetLight_Diffuse_WithShadows(vec3 p, vec3 lightPos) {\n    \n    //Ray from the found scene position to the light position, normalized to [0,1]\n    vec3 lightRay = normalize(lightPos-p);\n    vec3 normalRay = GetNormal_Generic(p);\n    \n    //Dot product returns [-1:1], so.. \"clamp\" it\n    float dif = clamp(dot(normalRay, lightRay), 0.0, 1.0);\n    \n    float ldif = length(lightPos - p);\n    \n    //Let's say we are rendering a point on the plane in the shadow of the sphere.\n    //Ray march from this point in the direction of the light to see if we collide\n    //with more scenery. If we do, reduce the diffuse lighting.\n    //\n    //Because 'p' was an output to RayMarch already, p already collides with the scene.\n    //So move p a little bit away using the normal we already found.\n    float d = RayMarch(p + normalRay*SURF_DIST, lightRay);\n    if(d < ldif) dif*= max(abs(d)/ldif,0.1);\n    \n    return dif;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time = iTime;\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord - 0.5*iResolution.xy) /iResolution.y;\n\n    vec3 col = vec3(0, 0.007, 0.02);\n    vec3 rayOrigin;\n    vec3 rayDirection;\n    if( mod(time,19.) < 8.5)\n    {\n        rayOrigin = vec3(-0.16 , 10. + 1.*sin(time/2.),-0.2);\n        rayDirection = normalize(vec3(uv.x, -1.0, uv.y));\n    }\n    else\n    {\n        rayOrigin = vec3(-3. + 0.3*sin(time/4.),2.7, 8.2 + 0.26*cos(time/4.));\n        rayDirection = normalize(vec3(uv.x + 0.25, uv.y - 0.1, -1.));\n    }\n\n    float d = RayMarch(rayOrigin, rayDirection);\n    vec3 p = rayOrigin + rayDirection * d;\n    \n    //White light\n    vec3 lightPos = vec3(0, 7, 4);\n    lightPos.xz += vec2(0., cos(2.0*time)/2.);\n    float light = GetLight_Diffuse_WithShadows(p, lightPos);\n    col = col + vec3(light)*0.9;\n    \n    //Blue light\n    lightPos = vec3(18, 5, -13);\n    lightPos.xz += vec2(0.,  0.5);\n    light = GetLight_Diffuse_WithShadows(p, lightPos);\n    col = col + vec3(0.,light*0.01,light)/8.;\n    \n    //Light underneath\n    lightPos = vec3(0, 1., 0);\n    lightPos.xz += vec2(0., cos(2.0*time));\n    light = GetLight_Diffuse_WithShadows(p, lightPos);\n    col = col + pow(sin(time/5.),4.)*vec3(light,light/1.2,0.0) / 1.3;\n    \n    // Output to screen\n    float screenGamma = 2.0;\n    vec3 colorGammaCorrected = pow(col, vec3(1.0/screenGamma));\n\tfragColor = vec4(colorGammaCorrected,1.0);\n}\n","name":"Image","description":"","type":"image"}]}