{"ver":"0.1","info":{"id":"tlKfRz","date":"1613805216","viewed":308,"name":"Somebody Else's Paradise","username":"wecall","description":"An infinitely-scrolling terrain generator, pieced together from the work of others.  It's not original, but it's pretty and relaxing to watch.\nTry playing with the WATER_LEVEL on line 47.  1.5 is a nice alternative experience.","likes":15,"published":1,"flags":0,"usePreview":0,"tags":["procedural","waves","water","proceduralterrain","infinite","scrolling","paradise","terrainwater"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Meanwhile, in somebody eles's paradise...\n//      (A Long Way from Bugtown (c))\n//\n// Bugtown copyright Matt Howarth\n// https://en.wikipedia.org/wiki/Matt_Howarth\n//\n// Literary references aside, this is just an infinitely-scrolling\n// procedural landscape, pieced together from various recipes\n// found on ShaderToy. Unwitting contributors include:\n//\n//    Inigo Quilez (iq) [because how could it not?] \n//    Terrain lighting and shading (first pass)\n//    Simplex Noise generator\n//    https://iquilezles.org/index.html\n//    https://www.shadertoy.com/view/MdX3Rr//\n//  \n//    frankenburgh, for height-field generation and water effects\n//    Terrain lighting and shadows (second pass)\n//    https://www.shadertoy.com/view/lsBSWm//  \n//  \n//    Red Blob Games, for helpful blog posts\n//    https://www.redblobgames.com/maps/terrain-from-noise/\n//\n// I think that's everybody, but I may have missed someone.\n// If so, it was purely unintentional.\n//\n// As shaders go, this one's kind of garbage; full\n// of magic constants that are all tweaked *just so*\n// to get these results. It's a GPU hog, too.\n// But it's purty, and relaxing to watch, so enjoy.\n\n//================ INPUTS =========================================\n\nvec3 resolution;\nvec2 rngOffset;\nfloat time;\nvec2 iFragCoord;\n\n\n// Begin\n\n// ===========  START TERRAIN ================\n\n#define GLOBAL_Y vec3(0.0, 1.0, 0.0)\n#define C(r, g, b) vec3(r/256.0, g/256.0, b/256.0)\n\nconst float WATER_LEVEL = 1.11; // Water level (range: 0.0 - 2.0)\n\nconst vec3 OCEAN_DEEP                 = C(  0.,  48., 143.);\nconst vec3 OCEAN_SHALLOW              = C( 63., 224., 208.);\nconst vec3 OCEAN                      = C(255., 255., 255.);\nconst vec3 BEACH                      = C(212., 212., 232.);\nconst vec3 SCORCHED                   = C( 63.,  62.,  77.);\nconst vec3 BARE                       = C(142.,  70.,   3.);\nconst vec3 TUNDRA                     = C(115., 129.,  45.);\nconst vec3 SNOW                       = C(242., 244., 247.);\nconst vec3 TEMPERATE_DESERT           = C(152., 152.,  84.);\nconst vec3 TAIGA                      = C( 50.,  73.,  12.);\nconst vec3 SHRUBLAND                  = C( 87.,  97.,  71.);\nconst vec3 GRASSLAND                  = C( 93., 128.,  36.);\nconst vec3 TEMPERATE_DECIDUOUS_FOREST = C( 71., 102.,  22.);\nconst vec3 TEMPERATE_RAIN_FOREST      = C( 63.,  93.,  27.);\nconst vec3 SUBTROPICAL_DESERT         = C(197., 170., 107.);\nconst vec3 TROPICAL_SEASONAL_FOREST   = C(110., 149.,  28.);\nconst vec3 TROPICAL_RAIN_FOREST       = C( 86., 126.,   0.);         \n\nconst vec3 CRAZY_LAND  = C(255., 0., 255.);\n\n#define SC 250.0\n\nvec2 hash( vec2 p ) // replace this by something better\n{\n\tp = vec2( dot(p,vec2(127.1,311.7)), dot(p,vec2(269.5,183.3)) );\n\t\n\treturn -1.0 + 2.0 * fract(sin(p) * 43758.5453123);\n}\n\nfloat noiseSimplex(vec2 p)\n{\n    const float K1 = 0.366025404; // (sqrt(3)-1)/2;\n    const float K2 = 0.211324865; // (3-sqrt(3))/6;\n\n\tvec2  i = floor( p + (p.x+p.y)*K1 );\n    vec2  a = p - i + (i.x+i.y)*K2;\n    float m = step(a.y,a.x); \n    vec2  o = vec2(m,1.0-m);\n    vec2  b = a - o + K2;\n\tvec2  c = a - 1.0 + 2.0*K2;\n    vec3  h = max( 0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\n\tvec3  n = h*h*h*h*vec3( dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0)));\n\t\n    return dot( n, vec3(70.0) );\n}\n\nfloat noise(vec2 p) { return noiseSimplex(p); }\nfloat noise1(float nx, float ny) { return noise(vec2(nx, ny)) / 2.0 + 0.5; }\nfloat noise2(float nx, float ny) { return noise(vec2(ny, nx)) / 2.0 + 0.5; }\n\nvec3 biome(float e, float m) \n{\t\t\n\tif (e < 0.0125 / 8.0) return BEACH;\n\t\n\tif (e > 1.5) \n\t{\n\t  if (m < 0.1) return SCORCHED;\n\t  if (m < 0.2) return BARE;\n\t  if (m < 0.5) return TUNDRA;\n\t  \n\t  return SNOW;\n\t}\n\t\n\tif (e > 0.6)\n\t{\n\t  if (m < 0.33) return TEMPERATE_DESERT;\n\t  if (m < 0.66) return SHRUBLAND;\n\t  \n\t  return TAIGA;\n\t}\n\t\n\n\tif (e > 0.3) \n\t{\n\t  if (m < 0.16) return TEMPERATE_DESERT;\n\t  if (m < 0.50) return GRASSLAND;\n\t  if (m < 0.83) return TEMPERATE_DECIDUOUS_FOREST;\n\t  \n\t  return TEMPERATE_RAIN_FOREST;\n\t}\n\t\t\n\tif (m < 0.16) return SUBTROPICAL_DESERT;\n\tif (m < 0.33) return GRASSLAND;\n\tif (m < 0.66) return TROPICAL_SEASONAL_FOREST;\n    \n\treturn TROPICAL_RAIN_FOREST;\n}\n\n#define VECTOR_AVERAGE(v1, v2) ((v1 + v2) * 0.5);\n\n\nvec2 terrain(vec2 uv)\n{\t\n\tfloat ny = uv.y;\n\tfloat nx = uv.x;\n\n\tfloat e = (  (5.00 * noise1(  1.0 * nx,   1.0 * ny))\n\t           + (3.00 * noise1(  2.0 * nx,   2.0 * ny))\n\t           + (1.50 * noise1(  4.0 * nx,   4.0 * ny))\n\t           + (0.35 * noise1(  8.0 * nx,   8.0 * ny))\n\t           + (0.10 * noise1( 16.0 * nx,  16.0 * ny))\n\t           + (0.01 * noise1( 32.0 * nx,  32.0 * ny))\n\t           + (0.01 * noise1( 64.0 * nx,  64.0 * ny))\n\t           + (0.01 * noise1(128.0 * nx, 128.0 * ny))\n\t           + (0.01 * noise1(256.0 * nx, 256.0 * ny))\n\t           + (0.01 * noise1(512.0 * nx, 512.0 * ny)));\n\t \n\te /= (5.00 + 3.00 + 1.50 + 0.35 + 0.10 + 0.01 + 0.01 + 0.01 + 0.01 + 0.01);\n\te = pow(e, 2.5); // 0.62 is \"exp\"\n\t \n\tfloat m = (  (1.00 * noise2(  1.0 * nx,   1.0 * ny))\n\t           + (0.75 * noise2(  2.0 * nx,   2.0 * ny))\n\t           + (0.33 * noise2(  4.0 * nx,   4.0 * ny))\n\t           + (0.33 * noise2(  8.0 * nx,   8.0 * ny))\n\t           + (0.33 * noise2( 16.0 * nx,  16.0 * ny))\n\t           + (0.50 * noise2( 32.0 * nx,  32.0 * ny))\n\t           + (0.40 * noise1( 64.0 * nx,  64.0 * ny))\n\t           + (2.00 * noise1(128.0 * nx, 128.0 * ny))\n\t           + (0.05 * noise1(256.0 * nx, 256.0 * ny))\n\t           + (0.05 * noise1(512.0 * nx, 512.0 * ny)));\n  \n\tm /= (1.00 + 0.75 + 0.33 + 0.33 + 0.33 + 0.50 + 0.40 + 2.00 + 0.05 + 0.05);\n\t\n\te = (e * 1.5) -0.2; //- 0.4; // - 0.2;\n\tm = (m * 1.5) -0.2; //- 0.4; // - 0.2;\n\t\n\treturn vec2(e, m);\n}\n\n\nfloat terrainHeight(vec2 uv)\n{\n\treturn terrain(uv).x;\n}\n\nfloat terrainColor(vec2 uv)\n{\n\treturn terrain(uv).y;\n}\n\n\nvec3 calcNormal(vec3 pos, float t )\n{\n    const float worldStep = 1.0 / 4.0;\n\n\tfloat uvStep = (1.0 / resolution.x);\n\tvec2 eps = vec2((worldStep * t), 0.0);\n\tfloat run = ((2.0 * eps.x) * uvStep);\n\n    return normalize(vec3(terrainHeight(pos.xy - eps.yx) - terrainHeight(pos.xy + eps.yx),\n                          terrainHeight(pos.xy - eps.xy) - terrainHeight(pos.xy + eps.xy),\n\t\t\t\t\t\t  run));\n}\n\nfloat softShadow(vec3 ro, vec3 rd )\n{\n    float res = 1.0;\n    float t = 0.001;\n\t\n\tfor(int i = 0; i < 80; i++)\n\t{\n\t    vec3  p = ro + t * rd;\n        float h = p.y - terrainHeight( p.xz );\n\t\t\n\t\tres = min( res, 16.0 * h / t );\n\t\tt += h;\n\t\t\n\t\tif( res<0.001 || p.y > (SC * 200.0) ) break;\n\t}\n\t\n\treturn clamp( res, 0.0, 1.0 );\n}\n\n// ===========  END TERRAIN ================\n\n// ===================== START SEA ==========================\n\nconst float water_softlight_fact   =  15.;                // range [1..200] (should be << smaller than glossy-fact)\nconst float water_glossylight_fact = 120.;                // range [1..200]\nconst float particle_amount        =  70.;\nvec3 watercolor              = OCEAN_SHALLOW;       // vec3(0.43, 0.60, 0.66); // 'transparent' low-water color (RGB)\nvec3 watercolor2             = OCEAN_DEEP * 0.25;   // vec3(0.06, 0.07, 0.11); // deep-water color (RGB, should be darker than the low-water color)\nvec3 water_specularcolor     = vec3(1.3, 1.3, 0.9); // specular Color (RGB) of the water-highlights\n  \nconst float ws = 0.25; \nconst float coast2water_fadedepth  = 0.0;        // 0.2;\nconst float large_waveheight       = 0.50 * ws;  // change to adjust the \"heavy\" waves\nconst float large_wavesize         = 4.   * ws;  // factor to adjust the large wave size\nconst float small_waveheight       =  .6  * ws;  // change to adjust the small random waves\nconst float small_wavesize         =  .5  * ws;  // factor to ajust the small wave size\n\nvec3 light = vec3(0.0, -0.0, 2.8);\n\n\n// calculate random value\nfloat seaHash( float n )\n{\n    return fract(sin(n)*43758.5453123);\n}\n\n// 2d noise function\nfloat seaNoise(vec2 x)\n{\n  vec2 p  = floor(x);\n  vec2 f  = smoothstep(0.0, 1.0, fract(x));\n  float n = p.x + p.y*57.0;\n  \n  return mix(mix(seaHash(n+  0.0),\n                 seaHash(n+  1.0),f.x),\n                 mix( seaHash(n+ 57.0), seaHash(n+ 58.0),f.x),f.y);\n}\n\nfloat height_map( vec2 p )\n{\n\t mat2 m = mat2( 0.9563*1.4,  -0.2924*1.4,  0.2924*1.4,  0.9563*1.4 );\n\t \n\t p = p*6.;\n\t \n\t float \n\t f  = 0.6000*seaNoise( p );  p = m * p * 1.10;\n\t f += 0.2500*seaNoise( p );  p = m * p * 1.32;\n\t f += 0.1666*seaNoise( p );  p = m * p * 1.11;\n\t f += 0.0834*seaNoise( p );  p = m * p * 1.12;\n\t f += 0.0634*seaNoise( p );  p = m * p * 1.13;\n\t f += 0.0444*seaNoise( p );  p = m * p * 1.14;\n\t f += 0.0274*seaNoise( p );  p = m * p * 1.15;\n\t f += 0.0134*seaNoise( p );  p = m * p * 1.16;\n\t f += 0.0104*seaNoise( p );  p = m * p * 1.17;\n\t f += 0.0084*seaNoise( p );  p = m * p * 1.18;\n\t f += 0.0064*seaNoise( p );\n\t\n\t return clamp(f*2.0, 0., 10.);\n}\n\nconst mat2 m = mat2( 0.72, -1.60,  1.60,  0.72 );\n\nfloat water_map( vec2 p, float height )\n{\n\tvec2 p2 = p*large_wavesize;\n\tvec2 shift1 = 0.001*vec2( time*160.0*2.0, time*120.0*2.0 );\n\tvec2 shift2 = 0.001*vec2( time*190.0*2.0, -time*130.0*2.0 );\n\t\n\t// coarse crossing 'ocean' waves...\n\tfloat f = 0.6000*seaNoise( p );\n\t\n\tf += 0.2500*seaNoise( p*m );\n\tf += 0.1666*seaNoise( p*m*m );\n\t\n\tfloat wave = sin(p2.x * 0.622 + p2.y * 0.622 + shift2.x * 4.269) * large_waveheight * f * height * height;\n\t\n\tp *= small_wavesize;\n\tf = 0.;\n\t\n\tfloat amp = 1.0, s = .5;\n\t\n\tfor (int i=0; i<9; i++)\n\t{ \n\t\tp = m*p*.947; \n\t\tf -= amp*abs(sin((seaNoise( p+shift1*s )-.5)*2.));\n\t\tamp = amp*.59; s*=-1.329; \n\t}\n \n\treturn wave+f*small_waveheight;\n}\n\nfloat nautic(vec2 p)\n{\n\tp *= 18.;\n\t\n\tfloat f = 0.;\n\tfloat amp = 1.0, s = .5;\n\t\n\tfor (int i = 0; i < 3; i++)\n\t{ \n\t\tp = m * p * 1.2; \n\t\tf += amp * abs(smoothstep(0., 1., seaNoise(p + time * s )) -.5); \n\t\tamp = amp*.5;\n\t\ts*=-1.227; \n\t}\n\t  \n\treturn pow(1.-f, 5.);\n}\n\nfloat particles(vec2 p)\n{\n\tp *= 100.0; //200.;\n\t\n\tfloat f = 0.;\n\tfloat amp = 1.0, s = 1.5;\n\t\n\tfor (int i = 0; i < 3; i++)\n\t{\n\t\tp = m * p * 1.2; \n\t\tf += amp*seaNoise(p + time * s );\n\t\tamp = amp*.5; \n\t\ts*= -1.227; \n\t}\n\t\n\treturn pow(f*.35, 7.)*particle_amount;\n}\n\n\nfloat test_shadow(vec2 xy, float height)\n{\n    vec3 r0 = vec3(xy, height);\n    vec3 rd = normalize( light - r0 );\n    \n    float hit = 1.0;\n    float t   = 0.001;\n\t\n    for (int j=1; j<25; j++)\n    {\n        vec3 p = r0 + t*rd;\n        float h = height_map( p.xy );\n        float height_diff = p.z - h;\n\t\t\n        if (height_diff<0.0)\n        {\n            return 0.0;\n        }\n\t\t\n        t += 0.01+height_diff*.02;\n        hit = min(hit, 2.*height_diff/t); // soft shaddow   \n    }\n\t\n    return hit;\n}\n\nvec3 CalcTerrain(vec2 uv, float height, bool isOcean)\n{\n    const float altitude = 3.0;\n\n    vec2  fragCoord = iFragCoord;\n\tvec3 col = biome(height - WATER_LEVEL, terrainColor(fragCoord));\n\t\n    vec2 eps = vec2(0.0001, 0.0);\n\tvec3 ro = vec3(fragCoord, altitude);\n\tvec3 rd = vec3(0.0, 0.0, -1.0);\n\tfloat t = (altitude - height);\n\tvec3 pos = (ro + (t * rd));\n    float h1 = height_map(uv-eps.yx);\n    float h2 = height_map(uv+eps.yx);\n    float h3 = height_map(uv-eps.xy);\n    float h4 = height_map(uv+eps.xy);\n\t\n\tconst float hscale = 0.0125;\n    vec3 nor = -normalize(vec3((h3-h4), (h1-h2), hscale));\n\t\t\t\n\tvec3 ref = reflect(rd, nor);\n\tvec3 lightSun = normalize(light);  //normalize(vec3(-0.8, 0.4, -0.3));\n\t\n\tfloat fre = (1.0 - clamp(1.0 + dot(rd, nor), 0.0, 1.0)); // Why are my normals backwards? Because of your weird coordinate transforms. You have the camera at positive z, with negative z being \"into\" the screen, which is back-asswards. but hich is necessitated by the fact that you oriented your height field on the x/y plane instead of the y/z plane like a normal person.\n\t\n\t// light\n\t\n\tvec3 ambientLightColor = vec3(.55, .55, .5); // blue-white sky\n\tfloat ambientLightIntensity = 2.5;\n\tvec3 sunColor = vec3(1);  // this is a yellow light, which is suitable for the current sun location and gives a flat, yellow light.\n\t\n\tvec3 hal = normalize(lightSun - rd);\n\tfloat ambientNormal = clamp(0.5 + 0.5 * nor.y, 0.0, 1.0);\n\tfloat diffuseNormal = clamp(dot(lightSun, nor), 0.0, 1.0);\n\tfloat bac = clamp( 0.2 + 0.8 * dot(normalize(vec3(-lightSun.x, 0.0, lightSun.z )), nor), 0.0, 1.0);  // backlight?\n\tfloat sh = 1.0; \n\t\n\tif( diffuseNormal >= 0.0001 ) sh = softShadow((pos + lightSun * SC * 0.05), lightSun);\n\t\n\tvec3 lin  = vec3(0.0);\n\tfloat s = 0.1;\n\t\n\tlin += diffuseNormal * sunColor * 1.3 * vec3(sh, sh * sh * 0.5 + 0.5 * sh, sh * sh * 0.8 + 0.2 * sh);\n\tlin += (ambientNormal * ambientLightColor * ambientLightIntensity);\n\tlin += bac * vec3(0.40, 0.50, 0.60);  // Backlight color adjustment?  Why?\n\tcol *= lin * 2.0;  \n\t\n\tcol += (0.7 + 0.3 * s) * (0.04 + 0.96 * pow(clamp(1.0 + dot(hal, rd),0.0, 1.0), 5.0))\n\t     * vec3(7.0, 5.0, 3.0) * diffuseNormal * sh\n\t\t * pow(clamp(dot(nor, hal), 0.0, 1.0), 16.0);\n\t\n\tcol += s * 0.65 * pow(fre, 4.0) * vec3(0.3, 0.5, 0.6) * smoothstep(0.0, 0.6, ref.y);\n    float terrainshade = test_shadow(uv, height);\n    col = mix(col*.25, col, terrainshade);\n\n\treturn col;\n}\n\nvec3 CalcSea(vec2 uv, float height)\n{\n  vec3 col = OCEAN;\n  vec2 eps = vec2(0.25, 0.0);\n  float h1 = height_map(uv-eps.yx);\n  float h2 = height_map(uv+eps.yx);\n  float h3 = height_map(uv-eps.xy);\n  float h4 = height_map(uv+eps.xy);\n  const float ss = 0.2;\n  vec3 norm = normalize(vec3((h3-h4), (h1-h2), 1.0 *ss));\n  vec3 r0 = vec3(uv, height);\n  vec3 rd = normalize(light - r0);\n  float grad = abs(dot(norm, rd));\n\n  col *= grad+pow(grad, 8.0);\n  \n  float terrainshade = test_shadow(uv, height);\n  \n  col = mix(col*.25, col, terrainshade);\n\n  return col;\n}\n\nvec3 renderSea(vec2 uv, vec2 ruv, vec3 light)\n{\n\tuv = vec2(uv.x, ruv.y);\n\t\n    float deepwater_fadedepth = 0.5 + coast2water_fadedepth;\n    float height = height_map( uv );\n\t\n    vec3 col;\n    \n    float waveheight = clamp(WATER_LEVEL*3.-1.5, 0., 1.);\n    float level = WATER_LEVEL + .2*water_map(uv*15. + vec2(time*.1), waveheight);\n\t\n    if (height > level)\n    {\n        col = CalcTerrain(uv, height, false);\n    }\n    else\n    {\n        vec2 dif = vec2(.0, .01);\n        vec2 pos = uv*15. + vec2(time*.01);\n        float h1 = water_map(pos-dif,waveheight);\n        float h2 = water_map(pos+dif,waveheight);\n        float h3 = water_map(pos-dif.yx,waveheight);\n        float h4 = water_map(pos+dif.yx,waveheight);\n        vec3 normwater = normalize(vec3(h3-h4, h1-h2, .125)); // norm-vector of the 'bumpy' water-plane\n\t\t\n        uv += normwater.xy*.002*(level-height);\n        \n        col = CalcSea(uv, height);\n\t\t\n        float coastfade = clamp((level-height)/coast2water_fadedepth, 0., 1.);\n        float coastfade2= clamp((level-height)/deepwater_fadedepth, 0., 1.);\n        float intensity = col.r*.2126+col.g*.7152+col.b*.0722;\n\t\t\n        watercolor = mix(watercolor*intensity, watercolor2, smoothstep(0., 1., coastfade2));\n\n        vec3 r0 = vec3(uv, WATER_LEVEL);\n        vec3 rd = normalize( light - r0 );                      // ray-direction to the light from water-position\n        float grad     = dot(normwater, rd);                    // dot-product of norm-vector and light-direction\n        float specular = pow(grad, water_softlight_fact);       // used for soft highlights                          \n        float specular2= pow(grad, water_glossylight_fact);     // used for glossy highlights\n        float gradpos  = dot(vec3(0., 0., 1.), rd);\n        float specular1= smoothstep(0., 1., pow(gradpos, 5.));  // used for diffusity (some darker corona around light's specular reflections...)                          \n        float watershade  = test_shadow( uv, level );\n        watercolor *= 2.2+watershade;\n   \t\twatercolor += (.2+.8*watershade) * ((grad-1.0)*.5+specular) * .25;\n   \t\twatercolor /= (1.+specular1*1.25);\n   \t\twatercolor += watershade*specular2*water_specularcolor;\n\t\t\n\t\tfloat nautics = nautic(uv);\n\t\tfloat partics = particles(uv);\n\t\t\n        watercolor += watershade*coastfade*(1.-coastfade2)*(vec3(.5, .6, .7)*nautic(uv)+vec3(1., 1., 1.)*particles(uv));\n        col = mix(col, watercolor, coastfade);\n\t\t\n\t\tfloat hd = (height / WATER_LEVEL) * 0.75;\n\t\tfloat hh = hd * hd;\n\t\tfloat hh2 = hh;\n    }\n    \n\treturn col;\n}\n\n// ================== END SEA ====================\n\nvec4 render(vec2 fragCoord)\n{\n    vec2 iFragCoord = vec2(fragCoord.x, iResolution.y - fragCoord.y);\n\n    rngOffset = floor(vec2(0.0, iTime) * 40.0 + 0.5);\n\t\n    vec2 uv = (-iResolution.xy + 2.0 * iFragCoord) / iResolution.x;\n    vec2 ruv = (-iResolution.xy + 2.0 * (iFragCoord - rngOffset)) / iResolution.x;\n    \n    light = vec3(0.0, -50.0, 3.5);\n    light.y = ((-iResolution.xy + 2.0 * (light.y - rngOffset)) / iResolution.x).y;\n\t\n\tvec3 col = renderSea(uv, ruv, light);\n\t\t\n\treturn vec4(col, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord)\n{\n    time = (iTime * 0.125);\n    resolution = iResolution;\n    \n    fragColor = render(fragCoord.xy);\n}","name":"Image","description":"","type":"image"}]}