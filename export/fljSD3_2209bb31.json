{"ver":"0.1","info":{"id":"fljSD3","date":"1628773861","viewed":152,"name":"Springs-Mass Oscillation v1.0","username":"anchung_chen","description":"Simple Spring + Mass Oscillation","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["helix","spring","coil"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sfGzn","filepath":"/media/a/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png","previewfilepath":"/media/ap/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//\n// some reference code from \n// https://www.shadertoy.com/view/slBSzt\n// https://www.shadertoy.com/view/7lBSWy\n//\n\nconst int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 200.0;\nconst float PRECISION = 0.001;\nconst float EPSILON = 0.0005;\nconst float PI = 3.14159265359;\nconst float TWO_PI = (3.14159265359*2.0);\n\n\nmat3 rotateX(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(1, 0, 0),\n        vec3(0, c, -s),\n        vec3(0, s, c)\n    );\n}\n\nmat3 rotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, 0, s),\n        vec3(0, 1, 0),\n        vec3(-s, 0, c)\n    );\n}\n\nmat3 rotateZ(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, -s, 0),\n        vec3(s, c, 0),\n        vec3(0, 0, 1)\n    );\n}\n\n\nfloat TriangleFunction(float x, float y)  // output range +- y*0.5 with center at x=0\n{\n    return abs(mod(x-y*0.5,y*2.0)-y)-y*0.5;\n}\n\n\n//////////////////////////////////////////////////////\nfloat sdCircle(vec2 p, float r) {\n    return length(p) - r;\n}\n\nfloat sdSphere( vec3 p, float R)\n{\n  return length(p)-R;\n}\n\nfloat sdBox( vec3 p, vec3 b)\n{\n  vec3 q = abs(p) - b;\n  //float d = length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n  float d = max(q.x,max(q.y,q.z));  // intersection operator\n  return d;\n}\n\n// vertical Cylinder, by intersection operator\nfloat sdCylinder( vec3 p0, vec2 h)\n{\n    vec3 p = p0;\n    //vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n    //float distance = min(max(d.x,d.y),0.0) + length(max(d,0.0));\n    float distance = length(p.xz) - h.x;       // inifinite length\n    distance = max(max(distance, p.y-h.y), -p.y); // two intersection operator\n    return distance;\n}\n\n// Spring Distance function, by \nfloat sdSpring(vec3 p, float Radius, float radius, float height, float turns ) {\n    float pitch = height/turns;  \n    \n    // p.xz of Spring cylinder\n    vec2 np = normalize(p.xz)*Radius; \n    \n    // closest Point On Spring Cylinder\n    vec3 pc = vec3(np.x, clamp(p.y, -height*0.5, height*0.5), np.y); \n    \n    // closest distance to Spring cylinder, p to pc\n    float distanceToCylinder = distance(p, pc); \n\n    // distance, pc to Spring Coil center\n\tfloat pcToSpring = p.y + atan(p.z, p.x)*pitch/TWO_PI;  // atan() range -PI to PI\n    \n    float distanceToSpring = TriangleFunction(pcToSpring, pitch); \n    // so 'close distance to Spring center for p' is length(vec2(distanceToCylinder, distanceToSpring)\n    // we could construct springCoords with origin at Spring Coil center to calculate closest distance. \n    vec2 springCoords = vec2(distanceToCylinder, distanceToSpring); \n    \n    return sdCircle(springCoords, radius); // circle shape of spings\n}\n\n//// SPRING + mount + Load ////\nfloat scene(vec3 p) {\n    float dist0 = sdCylinder( p-vec3(0,2.0,0), vec2(2.5, 0.2));\n    \n    float height = sin(iTime)+3.0;\n    p.y -=  2. - height*0.5;\n    float dist1 = sdSpring(p, 0.25, 0.05,  height, 8.0) ; //  Radius, radius, height, turns\n\n    p.y +=  height*0.5;\n    //float dist2 = sdBox( p-vec3(0,-0.5,0), vec3(0.5, 0.5, 0.5));\n    float dist2 = sdSphere( p-vec3(0,-0.5,0),  0.75);\n     \n    return min(dist2,min(dist0, dist1));\n}\n\nfloat rayMarch(vec3 ro, vec3 rd) {\n  float depth = MIN_DIST;\n  float d; // distance ray has travelled\n\n  for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n    vec3 p = ro + depth * rd;\n    d = scene(p);\n    depth += d;\n    if (abs(d) < PRECISION || depth > MAX_DIST) break;\n  }\n\n  return depth;\n}\n\n\nvec3 getNormal(vec3 p) {\n\tfloat d = scene(p);\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        scene(p-e.xyy),\n        scene(p-e.yxy),\n        scene(p-e.yyx));\n    \n    return normalize(n);\n}\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i);\n    return d;\n}\n\n    \n//////////////////////////////////////////////////////////////////\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //vec2 mouse = (iMouse.xy-.5*iResolution.xy)/iResolution.y;\n    vec2 dmouse = (iMouse.xy-abs(iMouse.zw))/iResolution.y;  // delta mouse movement of drag\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n    vec3 origin = vec3(0, 0, -8); // ray origin that represents camera position\n    vec3 dir = normalize(vec3(uv, 1)); // ray direction\n\n    dir *= rotateY(dmouse.x*TWO_PI)*rotateX(-dmouse.y*PI);\n    origin *= rotateY(dmouse.x*TWO_PI)*rotateX(-dmouse.y*PI);\n    \n    //vec3 dir = GetRayDir(uv, origin, vec3(0), 1.);\n    \n    vec3 col = texture(iChannel0, dir).rgb;\n    float dist = rayMarch(origin, dir); // signed distance value to closest object\n    if (dist < MAX_DIST) {              // ray  hit anything\n        vec3 p = origin + dir * dist;   // point discovered from ray marching\n        vec3 normal = getNormal(p);     // surface normal\n        vec3 rflct = reflect(dir, normal);\n        vec3 ref = texture(iChannel0, rflct).rgb;\n        col = 1.5*ref;\n    } \n    \n    col= pow(col, vec3(.4545));\t// gamma correction\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}