{"ver":"0.1","info":{"id":"lc3yRr","date":"1730315400","viewed":171,"name":"The power of power of sine","username":"Miolith","description":"I just like this formula I wanted to make a shader about it","likes":6,"published":1,"flags":32,"usePreview":0,"tags":["raymarching","sine","spikes","tiles","gui","bumps","goosebumps"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":1,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Showing the cool bumps you can generate with sin(x)^k\n//\n// Font rendering by kishimisu : https://www.shadertoy.com/view/43t3WX\n\nmakeStrF(printK)   _k __ _EQ __ _num_ __ _endNum\nmakeStr (printFormula) _LBR _0 _DOT _5 _ADD _0 _DOT _5 _MUL _s _i _n _LPR _x _RPR _RBR _end\nmakeStr(printExponent) _k _end\n\n\n#define TIME_OFFSET 20.0\n#define TIME (iTime + TIME_OFFSET)\n\nconst int SUN_COLOR_INDEX = 0;\nconst int GROUND_INDEX = 1;\n\n// positive sine\nfloat psin(float x)\n{\n    return 0.5 + 0.5 * sin(x);\n}\n\nfloat getK()\n{\n    return texelFetch(iChannel0, ivec2(0,0), 0).x;\n}\n\nObj sun(vec3 pos)\n{\n    float k = getK();\n    \n    float waves = 0.035\n                 * (pow(psin(pos.x * 40.0), k)\n                 * pow(psin(pos.y * 40.0), k)\n                 * pow(psin(pos.z * 40.0), k));\n    \n    float waves2 = 0.035\n                * pow(psin(atan(pos.y,pos.x) * 40.0), k)\n                * pow(psin(pos.z * 40.0), k);\n                 \n    float lerp_factor = smoothstep(-0.2, 0.2, sin(TIME*0.8));\n    \n    float radius = 1.0 + mix(waves, waves2, lerp_factor);\n             \n    float dist = sphereSdf(pos, radius);\n        \n    return Obj(SUN_COLOR_INDEX, dist, pos);\n}\n\nObj ground(vec3 pos)\n{\n    float k = getK();\n    float dist = pos.y + 2.0 - 0.1*pow(psin(pos.x*10.), k) * pow(psin(pos.z*10.), k);\n    return Obj(GROUND_INDEX, dist, pos);\n}\n\nObj scene(vec3 ray_pos)\n{\n    return closestObject(\n            sun(ray_pos), \n            ground(ray_pos));\n}\n\n\n// ************** COLORIZE ************** //\n\nvec3 sunColor(vec3 relative_pos)\n{\n    return vec3(1.000,0.494,0.220);;\n}\n\nvec3 groundColor(vec3 pos)\n{\n    return vec3(0.471,0.149,0.149);\n}\n\nvec3 colorize(Obj obj)\n{\n    vec3 col = vec3(0.0);\n    \n    switch(obj.color_index)\n    {\n        case SUN_COLOR_INDEX: col = sunColor(obj.relative_pos); break;\n        case GROUND_INDEX: col = groundColor(obj.relative_pos); break;\n        \n        default: col = vec3(0.0); break;\n    }\n    \n    return col;\n}\n\n// ************** END COLORIZE ************** //\n\n\n#define ZERO (min(iFrame,0)) // non-constant zero\n\nvec3 calcNormal( in vec3 pos )\n{\n    const float h = 0.0001;\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*scene(pos+e*h).dist;\n    }\n    return normalize(n);\n}\n\n\n\nvec3 background(vec2 uv)\n{\n    return vec3(0.659,0.914,1.000);\n}\n\nvec3 displayGui(vec2 fragCoord, vec3 backgroundColor)\n{\n    float k = getK();\n\n    vec2 uvFont = fragCoord / min(iResolution.y, iResolution.x);\n    vec2 uv = uvFont; uv.y = 1.0 - uv.y;\n    \n    vec2 m = iMouse.xy / min(iResolution.y, iResolution.x);\n    m.y = 1.0 - m.y;\n    const vec3 color = vec3(1.0);\n    const vec3 cursorColor = vec3(0.239,0.239,0.239);\n    float h = 0.0;\n    float dist = sdfGui(uv, h);\n    \n    const float thickness = 0.03;\n    \n    vec3 slider = mix(backgroundColor, cursorColor, smoothstep(0.002, 0.0, dist - 0.01));\n    \n    h = (k - LOWEST_K) / K_RANGE;\n    float cursorDist = distance(GUI_START + h * GUI_LINE, uv);\n    vec3 cursor = mix(slider, cursorColor, smoothstep(0.002, 0.0, cursorDist - thickness));\n    \n    cursor -= vec3(0.9,0.5,0.1) * printK(uvFont - vec2(0.1,0.93), k, 2);\n    cursor -= vec3(0.9) * printFormula( (uvFont - vec2(0.05,0.45)));\n    cursor -= vec3(0.9,0.5,0.1) * printExponent( (uvFont - vec2(0.55,0.48)) * 1.15);\n    \n    vec2 uvGraph = uvFont*40.;\n    uvGraph.y -= 27.;\n    uvGraph.y *= 0.8;\n    if (uvGraph.x < 23. && uvGraph.x > 1.)\n    {\n        float graph = smoothstep(0.2, 0.0, abs(uvGraph.y - pow(psin(uvGraph.x - iTime), k)));\n        cursor = mix(cursor, vec3(1,0,0), graph);\n    }\n    \n    return cursor;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / min(iResolution.y, iResolution.x);\n    vec2 m = (iMouse.xy * 2.0 - iResolution.xy) / min(iResolution.y, iResolution.x);\n    \n    if (iMouse.x <= 0.0 && iMouse.y <= 0.0)\n        m = vec2(0.0, 0.0);\n        \n    vec3 col = background(uv);\n    \n    vec3 ray_origin = vec3(0.0, 0.0, -4.0);\n    \n    vec2 start_xy = uv;\n    vec3 ray_dir = normalize(vec3(start_xy, 1.5));\n    \n    ray_origin.xz *= rotation(iTime*0.05);\n    ray_dir.xz *= rotation(iTime*0.05);\n    \n    float t = 0.0;\n    vec3 ray_pos = ray_origin;\n    \n    Obj object;\n    \n    const float MAX_DIST = 10.0;\n    const int MAX_ITER = 132;\n    \n    for (int i = 0; i < MAX_ITER; i++)\n    {\n        ray_pos = ray_origin + ray_dir * t;\n\n        object = scene(ray_pos);\n        \n        t += object.dist * 0.5;\n        \n        if (t > MAX_DIST || object.dist < 0.001) break;\n    }\n    \n\n    vec3 color = colorize(object);\n    \n    vec3 sun_light = vec3(1.000,0.686,0.141);\n\n    if (t < MAX_DIST)\n    {\n        vec3 normal = calcNormal(ray_pos);\n        \n        const vec3 lightPos = normalize(vec3(1,1,-0.5));\n        \n        float lightContrib = max(dot(normal, lightPos), 0.0);\n        col = color * lightContrib;\n        col += color *0.1;\n    } \n    \n    col = pow(col, vec3(0.45));\n    \n    col = displayGui(fragCoord, col);\n    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"/*** Settings ***/\n\n#define FONT_TEXTURE iChannel1 // Set to the iChannel containing the alphabet texture\n\n#define FONT_SPACING 2.        // Horizontal character spacing [1 - 2.5]\n\n// Special characters\n#define __    32,\n#define _EX   33, // \" ! \"\n#define _DBQ  34, // \" \" \"\n#define _NUM  35, // \" # \"\n#define _DOL  36, // \" $ \"\n#define _PER  37, // \" % \"\n#define _AMP  38, // \" & \"\n#define _QT   39, // \" ' \"\n#define _LPR  40, // \" ( \"\n#define _RPR  41, // \" ) \"\n#define _MUL  42, // \" * \"\n#define _ADD  43, // \" + \"\n#define _COM  44, // \" , \"\n#define _SUB  45, // \" - \"\n#define _DOT  46, // \" . \"\n#define _DIV  47, // \" / \"\n#define _COL  58, // \" : \"\n#define _SEM  59, // \" ; \"\n#define _LES  60, // \" < \"\n#define _EQ   61, // \" = \"\n#define _GE   62, // \" > \"\n#define _QUE  63, // \" ? \"\n#define _AT   64, // \" @ \"\n#define _LBR  91, // \" [ \"\n#define _ANTI 92, // \" \\ \"\n#define _RBR  93, // \" ] \"\n#define _UN   95, // \" _ \"\n\n// Digits\n#define _0 48,\n#define _1 49,\n#define _2 50,\n#define _3 51,\n#define _4 52,\n#define _5 53,\n#define _6 54,\n#define _7 55,\n#define _8 56,\n#define _9 57,\n// Uppercase\n#define _A 65,\n#define _B 66,\n#define _C 67,\n#define _D 68,\n#define _E 69,\n#define _F 70,\n#define _G 71,\n#define _H 72,\n#define _I 73,\n#define _J 74,\n#define _K 75,\n#define _L 76,\n#define _M 77,\n#define _N 78,\n#define _O 79,\n#define _P 80,\n#define _Q 81,\n#define _R 82,\n#define _S 83,\n#define _T 84,\n#define _U 85,\n#define _V 86,\n#define _W 87,\n#define _X 88,\n#define _Y 89,\n#define _Z 90,\n// Lowercase\n#define _a 97,\n#define _b 98,\n#define _c 99,\n#define _d 100,\n#define _e 101,\n#define _f 102,\n#define _g 103,\n#define _h 104,\n#define _i 105,\n#define _j 106,\n#define _k 107,\n#define _l 108,\n#define _m 109,\n#define _n 110,\n#define _o 111,\n#define _p 112,\n#define _q 113,\n#define _r 114,\n#define _s 115,\n#define _t 116,\n#define _u 117,\n#define _v 118,\n#define _w 119,\n#define _x 120,\n#define _y 121,\n#define _z 122,\n\n// ======  utils  ======\n\n#define print_char(i) \\\n    texture(FONT_TEXTURE, u + vec2(float(i)-float(x)/FONT_SPACING + FONT_SPACING/8., 15-(i)/16) / 16.).r\n\n// ======  makeStr()  ======\n\n// Function start\n#define makeStr(func_name)                               \\\n    float func_name(vec2 u) {                            \\\n        if (u.x < 0. || abs(u.y - .03) > .03) return 0.; \\\n        const int[] str = int[](                         \\\n\n// Function end\n#define _end  0);                                        \\\n    int x = int(u.x * 16. * FONT_SPACING);               \\\n    if (x >= str.length()-1) return 0.;                  \\\n    return print_char(str[x]);                           \\\n}\n\n#define log10(x) int(ceil(.4342944819 * log(x + x*1e-5)))\n#define _num_ 0); const int[] str2 = int[]( \n\n// makeStrFloat() start\n#define makeStrF(func_name)                              \\\n    float func_name(vec2 u, float num, int dec) {        \\\n        if (u.x < 0. || abs(u.y - .03) > .03) return 0.; \\\n        const int[] str1 = int[](\n\n// makeStrInt() start\n#define makeStrI(func_name)                              \\\n    float func_name(vec2 u, int num_i) {                 \\\n        if (u.x < 0. || abs(u.y - .03) > .03) return 0.; \\\n        float num = float(num_i);                        \\\n        const int dec = -1;                              \\\n        const int[] str1 = int[](\n\n// makeStrFloat & makeStrInt end\n#define _endNum  0);                            \\\n    const int l1 = str1.length() - 1;           \\\n    int x = int(u.x * 16. * FONT_SPACING);      \\\n    if (x < l1) return print_char(str1[x]);     \\\n    int neg = 0;                                \\\n    if (num < 0.) {                             \\\n        if (x == l1) return print_char(45);     \\\n        num = abs(num);                         \\\n        neg = 1;                                \\\n    }                                           \\\n    int pre = neg + max(1, log10(num));         \\\n    int s2 = l1 + pre + dec + 1;                \\\n    if (x >= s2) {                              \\\n        if (x >= s2+str2.length()-1) return 0.; \\\n        int n2 = str2[x - s2];                  \\\n        return print_char(n2);                  \\\n    }                                           \\\n    float d = float(l1 + pre - x);              \\\n    if (d == 0.) return print_char(46);         \\\n    d = pow(10., d < 0.  ? ++d : d);            \\\n    int n = 48 + int(10.*fract(num/.999999/d)); \\\n    return print_char(n);                       \\\n}\n\nstruct Obj\n{\n    int color_index;\n    float dist;\n    vec3 relative_pos;\n};\n\nmat2x2 rotation(float angle)\n{\n    float c = cos(angle);\n    float s = sin(angle);\n    return mat2(\n        c, -s,\n        s, c\n    );\n}\n\nconst vec2 GUI_START = vec2(0.1, 0.1);\nconst vec2 GUI_END = vec2(0.4, 0.1);\nconst vec2 GUI_LINE = GUI_END - GUI_START;\n    \nconst float LOWEST_K = 0.12;\nconst float K_RANGE = 5.; \n\nfloat sdfGui(vec2 uv, out float h)\n{\n    vec2 s_p = uv - GUI_START;\n    vec2 line = GUI_END - GUI_START;\n    \n    h = clamp(dot(s_p, line) / dot(line, line), 0.0, 1.0);\n    \n    return distance(uv, GUI_START + line * h);\n}\n\n\nObj closestObject(in Obj obj1, in Obj obj2)\n{\n    // You can't use ternary operators on struct...\n    // return (obj1.dist < obj2.dist) ? obj1 : obj2;\n    \n    if (obj1.dist < obj2.dist)\n        return obj1;\n    return obj2;\n}\n\nfloat sphereSdf(vec3 pos, float radius)\n{\n    return length(pos) - radius;\n}","name":"Common","description":"","type":"common"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// GUI Backend\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if (fragCoord.x != 0.5 || fragCoord.y != 0.5)\n    {\n        discard;\n    }\n\n    vec2 uv = fragCoord / min(iResolution.y, iResolution.x);\n    vec2 m = iMouse.xy / min(iResolution.y, iResolution.x);\n    \n    float h = 0.0;\n    \n    if (iFrame > 1)\n    {\n        uv.y = 1.0 - uv.y;\n        m.y = 1.0 - m.y;\n        vec3 color = vec3(1.0);\n    \n        float dist = sdfGui(m, h);\n        \n        if (dist > 0.1)\n        {\n            discard;\n        }\n    }\n\n    \n    fragColor = vec4(LOWEST_K + h * K_RANGE, vec3(0));\n}","name":"Buffer A","description":"","type":"buffer"}]}