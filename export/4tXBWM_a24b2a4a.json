{"ver":"0.1","info":{"id":"4tXBWM","date":"1512063711","viewed":1286,"name":"infinicube","username":"laserdog","description":"just more experimentation with raymarching. super basic stuff","likes":10,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","noob"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define pi  3.14159\n#define tau 6.28318\n#define t iTime\n\n#define p0 0.5, 0.5, 0.5,  0.5, 0.5, 0.5,  1.0, 1.0, 1.0,  0.0, 0.33, 0.67\t\n    \n// source: https://iquilezles.org/articles/palettes\n// cosine based palette, 4 vec3 params\nvec3 palette( in float t, in float a0, in float a1, in float a2, in float b0, in float b1, in float b2,\n              in float c0, in float c1, in float c2,in float d0, in float d1, in float d2)\n{\n    return vec3(a0,a1,a2) + vec3(b0,b1,b2)*cos( tau*(vec3(c0,c1,c2)*t+vec3(d0,d1,d2)) );\n}\n\nconst float epsilon = .0001;\n\nvec3 rotateZ(vec3 p, float rads) {\n    return mat3(vec3(cos(rads), sin(rads), 0.), vec3(-sin(rads), cos(rads), 0.), vec3(0., 0., 1.)) * p;\n}\n\n// IQ distance functions\nfloat roundBoxSDF(vec3 p, vec3 size, float r)\n{\n\treturn length(max(abs(p) - size, 0.0))-r;\n}\n\nfloat opRep(vec3 p, vec3 c)\n{\n\tvec3 q = mod(p, c) - .5 * c;\n    return roundBoxSDF(q, vec3(.15), .1);\n}\n\nfloat sceneSDF(vec3 p)\n{\n    return opRep(p, vec3(1.));\n}\n\nvec3 gradient(vec3 p)\n{\n    vec3 dx = vec3(epsilon, 0., 0.);\n    vec3 dy = vec3(0., epsilon, 0.);\n    vec3 dz = vec3(0., 0., epsilon);\n    return normalize(vec3(\n    \tsceneSDF(p + dx) - sceneSDF(p - dx),\n        sceneSDF(p + dy) - sceneSDF(p - dy),\n        sceneSDF(p + dz) - sceneSDF(p - dz)\n    ));\n}\n\nvec3 phong(vec3 p, vec3 eye, vec3[1] lights, vec3 color)\n{\n    const vec3 specularColor = vec3(1.);\n    const float ambientStrength = .5;\n    \n    vec3 norm = gradient(p);\n    vec3 col = vec3(0.);\n    vec3 view = normalize(eye - p);\n    \n    for (int i = 0; i < lights.length(); i++)\n    {\n        float kd = dot(lights[i], norm);\n        vec3 reflection = reflect(normalize(p - lights[i]), norm);\n        float ks = pow(max(dot(view, reflection), 0.), 16.);\n        \n        col += color * kd + ks * specularColor;\n    }\n    \n    return col + color * ambientStrength;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (2. * fragCoord - iResolution.xy) / iResolution.y;\n\tfragColor = vec4(0.);\n    vec3 ray = normalize(vec3(uv, -1.));\n    vec3 eye = vec3(sin(iTime), sin(iTime), -iTime * 3.);\n    vec3[1] lights;\n    lights[0] = vec3(1., 2., 5.);\n    \n    vec3 pos = eye;\n    \n    float dist = 0.;\n    for (float i = 0.; i < 70.; i++)\n    {\n    \tdist = sceneSDF(rotateZ(pos, iTime));\n        pos += ray * dist;\n    }\n    \n    if (dist < epsilon) {\n        pos = rotateZ(pos, iTime);\n        float colorIndex = floor(pos.x) + floor(pos.y) + floor(pos.z);\n        colorIndex *= .2;\n        colorIndex += iTime;\n        \n        // https://www.shadertoy.com/view/MdXGDr\n\t\tfloat fogFact = clamp(exp(-distance(eye, pos) * 0.3), 0.0, 1.0);\n        \n    \tfragColor.rgb = fogFact * phong(pos, eye, lights, .5 * palette(colorIndex, p0));\n    }\n}","name":"Image","description":"","type":"image"}]}