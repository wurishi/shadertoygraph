{"ver":"0.1","info":{"id":"3tXBWj","date":"1597688586","viewed":326,"name":"Perlin Hills","username":"BlockMaster","description":"A simple 2D landscape created using Perlin noise.","likes":21,"published":1,"flags":0,"usePreview":0,"tags":["perlin","parallax","landscape","tree","mountain","hill"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/// A simple 2D landscape created using Perlin noise.\n/// Plus some strange-looking trees. :)\n\n//Set the Tree Colours\nvec3 branchColour;\nvec3 leafColour;\n\n//USEFUL FUNCTIONS//\n//RNG Returning a Float (0. to 1.)\nfloat randomValue(vec2 uv)\n{\n    return fract(sin(dot(uv.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n//RNG Returning a Vec2 (0. to 1.)\nvec2 randomVector(vec2 uv)\n{\n    vec3 a = fract(uv.xyx * vec3(123.34, 234.34, 345.65));\n    a += dot(a, a + 34.45);\n    return fract(vec2(a.x * a.y, a.y * a.z));\n}\n\n//RNG Returning a Diagonal Vec2 (4 Directions)\nvec2 randomLimitedVector(vec2 uv)\n{\n    vec2 randomVector = randomVector(uv);\n    return vec2(round(randomVector.x) * 2. - 1.,\n                round(randomVector.y) * 2. - 1.);\n}\n\n//Map\nfloat map(float value, float currentMin, float currentMax, float targetMin, float targetMax)\n{\n    return targetMin + (targetMax - targetMin) * ((value - currentMin) / (currentMax - currentMin));\n}\n\n//Smootherstep\nfloat smootherstep(float value)\n{\n    return 6.0 * pow(value, 5.) - 15. * pow(value, 4.) + 10. * pow(value, 3.);\n}\n\nvec2 lengthdir(vec2 basePoint, float direction, float lngth)\n{\n    return basePoint + vec2(cos(direction) * lngth, sin(direction) * lngth);\n}\n\n//RGB to HSV Converter (Not My Code)\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n\n//DRAW FUNCTIONS//\n//Draw a Line\nvoid drawLine(vec2 uv, vec2 point1, vec2 point2, float thickness, float blur, inout float value)\n{\n    //Get Sides of a Triangle\n    float a = distance(uv, point2);\n    float b = distance(uv, point1);\n    float c = distance(point1, point2);\n    \n    //Calculate Point's Distance from the Line\n    float distanceFromLine = sqrt(abs(pow(a, 2.) - pow((pow(a, 2.) - pow(b, 2.) + pow(c, 2.)) / (2. * c), 2.)));\n    \n\t//Get Pixel's Value\n    float pixelValue = smoothstep(thickness + blur, thickness, distanceFromLine);\n    pixelValue *= smoothstep(thickness + blur, thickness, a + b - c);\n    value = mix(value, 1., pixelValue);\n}\n\n//Draw a Disk\nvoid drawDisk(vec2 uv, vec2 position, float radius, float blur, vec3 colour, inout vec3 value)\n{\n    float pixelValue = smoothstep(radius + blur, radius, distance(position, uv));\n    value = mix(value, colour, pixelValue);\n}\n\n//Draw a Disk with Return Value\nfloat diskValue(vec2 uv, vec2 position, float radius, float blur)\n{\n    return smoothstep(radius + blur, radius, distance(position, uv));\n}\n\n//Draw a Branch (Less Computationally Expensive drawLine)\nvoid drawBranch(vec2 uv, vec2 point1, vec2 point2, float thickness, float blur, vec3 colour, inout vec3 value)\n{\n    //Get Sides of a Triangle\n    float a = distance(uv, point2);\n    float b = distance(uv, point1);\n    float c = distance(point1, point2);\n    \n    //Calculate Point's Distance from the Line\n    float distanceFromLine = sqrt(abs(pow(a, 2.) - pow((pow(a, 2.) - pow(b, 2.) + pow(c, 2.)) / (2. * c), 2.)));\n    \n\t//Get Pixel's Value\n    float pixelValue = smoothstep(thickness + blur, thickness, distanceFromLine);\n    pixelValue *= float(a + b < c + thickness + blur);\n    value = mix(value, colour, pixelValue);\n}\n\n//Draw a Tree\nvoid drawTree(vec2 uv, vec2 basePoint, int branches, int iterations, float size, vec3 branchColour, vec3 leafColour, inout vec3 value)\n{\n    //Draw the Trunk\n    drawBranch(uv, basePoint, vec2(basePoint.x, basePoint.y + size), 0.003, 0.001, branchColour, value);\n    \n    //Draw the Branches\n    for (int i = 0; i < branches; i ++)\n    {\n        //Set Branch Properties\n        float randomFactor = map(randomValue(vec2(basePoint.y) * float(i)), 0., 1., 0.3, 1.);\n        float branchLength = size;\n        float branchAngle = 50.;\n        float branchThickness = 0.0015;\n        \n        //Set Previous && Current Branch Position\n        vec2 currentBranch;\n        vec2 previousBranch = lengthdir(basePoint, radians(90.), \n                                        distance(basePoint, vec2(basePoint.x, basePoint.y + size)) * randomFactor);\n        for (int j = 0; j < iterations; j ++)\n        {\n            //Change the Branch Properties\n            randomFactor = map(randomValue(vec2(previousBranch.y)), 0., 1., 0.5, 1.);\n            branchLength *= 0.8 * randomFactor;\n            branchAngle -= 15. * randomFactor;\n            branchThickness -= 0.00025;\n            \n            float angleSign = sign(float(mod(float(j) + float(i), 2.) == 0.) - 0.5);\n            float currentAngle = radians(90. + branchAngle * angleSign);\n            float currentLength = branchLength * randomFactor;\n            \n            //Set Current Branch Position for Draw\n\t\t\tcurrentBranch = lengthdir(previousBranch, currentAngle, branchLength);\n            drawBranch(uv, previousBranch, currentBranch, branchThickness, 0.001, branchColour, value);\n            drawDisk(uv, currentBranch, 1. / (currentBranch.y - basePoint.y) * size * 0.03, 0.0001, leafColour, value);\n            //drawDisk(uv, currentBranch, (currentBranch.y - basePoint.y) * 0.15, 0.0001, leafColour, value);\n            \n            //Set Current Branch Position for the Next Iteration\n            currentBranch = lengthdir(previousBranch, currentAngle, currentLength);\n            previousBranch = currentBranch;\n        }\n    }\n}\n\n//Perlin Noise\nfloat perlinNoise(vec2 uv, float frequency, int octaves, float lacunarity, float persistence)\n{\n    float amplitude = 1.;\n    float pixelValue = 0.;\n    float maxValue = 0.;\t//used to normalize the final value\n    \n    for (int octave = 0; octave < octaves; octave ++)\n    {\n        //Get Pixel's Position Within the Cell && Cell's Position Within the Grid\n        vec2 pixelPosition = fract(uv * frequency);\n        vec2 cellPosition = floor(uv * frequency);\n\n        //Get Gradient Vectors of the Cell's Points\n        vec2 gradientVector1 = randomLimitedVector(cellPosition);\n        vec2 gradientVector2 = randomLimitedVector(vec2(cellPosition.x + 1., cellPosition.y));\n        vec2 gradientVector3 = randomLimitedVector(vec2(cellPosition.x, cellPosition.y + 1.));\n        vec2 gradientVector4 = randomLimitedVector(vec2(cellPosition.x + 1., cellPosition.y + 1.));\n\n        //Calculate Distance Vectors from the Cell's Points to the Pixel\n        vec2 distanceVector1 = vec2(pixelPosition.x, - pixelPosition.y);\n        vec2 distanceVector2 = vec2(- (1. - pixelPosition.x), - pixelPosition.y);\n        vec2 distanceVector3 = vec2(pixelPosition.x, 1. - pixelPosition.y);\n        vec2 distanceVector4 = vec2(- (1. - pixelPosition.x), 1. - pixelPosition.y);\n\n        //Calculate Dot Product of the Gradient && Distance Vectors\n        float dotProduct1 = dot(gradientVector1, distanceVector1);\n        float dotProduct2 = dot(gradientVector2, distanceVector2);\n        float dotProduct3 = dot(gradientVector3, distanceVector3);\n        float dotProduct4 = dot(gradientVector4, distanceVector4);\n\n        //Apply Smootherstep Function on the Pixel Position for Interpolation\n        vec2 pixelPositionSmoothed = vec2(smootherstep(pixelPosition.x), smootherstep(pixelPosition.y));\n\n        //Interpolate Between the Dot Products\n        float interpolation1 = mix(dotProduct1, dotProduct2, pixelPositionSmoothed.x);\n        float interpolation2 = mix(dotProduct3, dotProduct4, pixelPositionSmoothed.x);\n        float interpolation3 = mix(interpolation1, interpolation2, pixelPositionSmoothed.y);\n        \n        pixelValue += (interpolation3 * 0.5 + 0.5) * amplitude;\n        maxValue += amplitude;\n        amplitude *= persistence;\n        frequency *= lacunarity;\n    }\n    return pixelValue / maxValue;\n}\n\n//Draw a Hill\nvoid drawHill(vec2 uv, vec3 colour, float blur, float speed, float flatness, float xOffset, float yOffset, bool drawTrees, inout vec3 value, float frequency, int octaves, float lacunarity, float persistence)\n{\n    float noiseValue = perlinNoise(vec2(uv.x + xOffset + iTime * speed, 0.5), frequency, octaves, lacunarity, persistence) * flatness;\n    float pixelValue = smoothstep(noiseValue, noiseValue - blur, uv.y - yOffset);\n    value = mix(value, colour, pixelValue);\n    \n    if (drawTrees && uv.y < 0.8)\n    {\n        float treeX = floor(uv.x + xOffset + iTime * speed);\n        treeX += map(randomValue(vec2(treeX)), 0., 1., 0.12, 0.88);\n        float treeY = perlinNoise(vec2(treeX, 0.5), frequency, octaves, lacunarity, persistence) * flatness;\n        drawTree(uv, vec2(treeX - xOffset - iTime * speed, treeY + yOffset - randomValue(vec2(treeX)) * 0.02), 4, 4, 0.17, branchColour, leafColour, value);\n    }\n}\n\n//Draw Fog\nvoid drawFog(vec2 uv, vec2 yBorders, float speed, float density, float contrast, float frequency, int octaves, float lacunarity, float persistence, inout vec3 value)\n{\n    //Get the Noise Value\n    float noiseValue = perlinNoise(vec2(uv.x * 0.8 + iTime * speed, uv.y), frequency, octaves, lacunarity, persistence);\n    \n    //Create Gradient Masks\n    float densityGradient = smoothstep(yBorders.y + 0.6, yBorders.y, uv.y);\n    float whiteGradient = smoothstep(yBorders.x + 0.3, yBorders.x - 0.2, uv.y) * 0.3 * density;\n    \n    //Adjust the Value\n    noiseValue = smoothstep(0.2, 0.7, noiseValue) * densityGradient * 0.75 * density + whiteGradient;\n    noiseValue = clamp(map(noiseValue, 0., 1., 0. - contrast, 1.1) * densityGradient, 0., 1.);\n    value = mix(value, vec3(noiseValue + 0.2), noiseValue);\n    //value = vec3(noiseValue);\n}\n\n\n//MAIN//\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    //Remap the fragCoord\n    vec2 uv = fragCoord / iResolution.y;\n    float aspectRatio = iResolution.y / iResolution.x;\n    \n    //Set the Colours\n    vec3 skyColour1 = hsv2rgb(vec3(216. / 360., 17. / 100., 100. / 100.));\n    vec3 skyColour2 = hsv2rgb(vec3(37. / 360., 34. / 100., 92. / 100.));\n    \n    vec3 hillColour1 = hsv2rgb(vec3(200. / 360., 16. / 100., 59. / 100.));\n    vec3 hillColour2 = hsv2rgb(vec3(15. / 360., 6. / 100., 30. / 100.));\n    vec3 hillColour3 = hsv2rgb(vec3(194. / 360., 35. / 100., 28. / 100.));\n    \n    branchColour = hsv2rgb(vec3(30. / 360., 35. / 100., 40. / 100.));\n    leafColour = hsv2rgb(vec3(144. / 360., 50. / 100., 45. / 100.));\n    \n    vec3 sunColour = vec3(45. / 360., 0. / 100., 100. / 100.);\t//in HSV model\n    vec2 sunPosition = vec2(1.3, 0.7);\n    \n    //Set the Background Colour\n    vec3 colourValue = mix(skyColour2, skyColour1, uv.y);\n    \n    //Draw the Sun\n    sunColour.y = diskValue(uv, vec2(sunPosition.x, sunPosition.y - 0.15), 0.2, 0.8) * 0.4;\n    colourValue *= hsv2rgb(sunColour);\n    colourValue += diskValue(uv, vec2(sunPosition.x, sunPosition.y - 0.15), 0.1, 0.8) * 0.3;\n    drawDisk(uv, sunPosition, 0.02, 0.005, vec3(1., 1., 1.), colourValue);\n    \n    //Draw the Hills && Fog\n    drawHill(uv, hillColour1, 0.002, 0.1, 1., 6.8, 0.15, false, colourValue, 3., 6, 2., 0.5);\n    drawFog(uv, vec2(0.35, 0.5), 0.12, 1., 0., 1.3, 6, 2., 0.5, colourValue);\n    drawHill(uv, hillColour2, 0.002, 0.2, 0.8, 2.0, 0.05, false, colourValue, 2., 5, 2., 0.5);\n    drawFog(uv, vec2(0.25, 0.3), 0.25, 0.6, 0., 1.4, 6, 2., 0.5, colourValue);\n    drawHill(uv, hillColour3, 0.002, 0.5, 0.6, 4.0, - 0.05, true, colourValue, 0.9, 5, 1.9, 0.45);\n    drawFog(uv, vec2(- 0.3, 0.2), 0.6, 0.4, 0., 1., 5, 2., 0.5, colourValue);\n    \n    //Find Out Wheter the Hills Are Overlaping the Sun\n    float hillNoiseValue = perlinNoise(vec2(sunPosition.x + 6.8 + iTime * 0.1, 0.5), 3., 6, 2., 0.5);\n    float sunIntensity = smoothstep(hillNoiseValue - 0.03, hillNoiseValue + 0.03, sunPosition.y - 0.15);\n    \n    //Draw the Sun Glow\n    sunColour.y = diskValue(uv, sunPosition, 0.2, 0.8) * 0.3 * sunIntensity;\n\tcolourValue *= hsv2rgb(sunColour);\n    colourValue += diskValue(uv, sunPosition, 0.3, 0.8) * 0.1 * sunIntensity;\n    colourValue += diskValue(uv, sunPosition, 0.05, 0.5) * 0.15 * sunIntensity;\n    colourValue += diskValue(uv, sunPosition, 0.01, 0.3) * 0.2 * sunIntensity;\n    colourValue += hsv2rgb(sunColour) * 0.1 * sunIntensity;\n    float highlight = smoothstep(1., 0.7, (colourValue.r + colourValue.g + colourValue.b) / 3.);\n    \n    //Make the Scene Darker\n    colourValue -= ((1. - sunIntensity) * 0.1) * highlight;\n    colourValue -= (1. - diskValue(uv, vec2(0.89, 0.5), 0.4, 1.7)) * 0.3;\n    \n    //Set the fragColor\n    fragColor = vec4(colourValue, 1.);\n}","name":"Image","description":"","type":"image"}]}