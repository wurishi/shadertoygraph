{"ver":"0.1","info":{"id":"3scfzs","date":"1605744366","viewed":72,"name":"ps_Koch'sCurve","username":"p_schneider","description":"This shader targets to achieve a mathematical render of Koch's Curve, a fractal defined by a rule of\ngeometrical substitution, wich results in a snow-flake-shaped fractal. It is also known as Koch's Snow\nFlake.","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["fractals","kochscurve"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\nThis documentation refers to the GitHub Repo: https://github.com/pedrotrschneider/shader-fractals\n\n(PT - Br) Documentação em português começa na linha 8.\n(En) English documentation starts on line 30.\n\n(PT - Br)\nDocumentação em português:\nEste é um shader voltado para a renderização matemática da Curva de Koch, um fractal definido por uma\nregra de substituição geométrica que resulta em uma estrutura semelhante à de um floco de neve. Também\né conhecido por Floco de Neve de Koch.\n\nPara a construção desse shader foram utilizadas diversas fontes:\n- The Art of Code: https://www.youtube.com/channel/UCcAlTqd9zID6aNX3TzwxJXg\n- The Coding Train: https://www.youtube.com/channel/UCvjgXvBlbQiydffZU7m1_aw\n- Sebastian Lague: https://www.youtube.com/user/Cercopithecan\n\nEste shader está sob a licença MIT.\nCheque \"License.txt\" para detalhes sobre a licensa.\n\nInstruções para compilar:\n- Entre no site https://www.shadertoy.com\n- No canto superior direito, clique em \"new\". Você será redirecionado para uma página com uma caixa\nde texto onde voce pode escrever e uma tela.\n- Apague todo o conteúdo da caixa de texto.\n- Copie este código e cole-o diretamente na ciaxa de texto.\n- Se nada mudar, aperte \"alt\" + \"enter\" e o shader deve compilar.\n\n(En)\nEnglish documentation:\nThis shader targets to achieve a mathematical render of Koch's Curve, a fractal defined by a rule of\ngeometrical substitution, wich results in a snow-flake-shaped fractal. It is also known as Koch's Snow\nFlake.\n\nFor the creation of this shader, several resources were used:\n- The Art of Code: https://www.youtube.com/channel/UCcAlTqd9zID6aNX3TzwxJXg\n- The Coding Train: https://www.youtube.com/channel/UCvjgXvBlbQiydffZU7m1_aw\n- Sebastian Lague: https://www.youtube.com/user/Cercopithecan\n\nThis shader in under the MIT license.\nRefer to \"LICENSE.txt\" for the details of the license.\n\nInstructions to compile:\n- Follow this url: https://www.shadertoy.com.\n- On the upper right portion of the screen, click on the \"new\" button. You will be redirected to a page\nwith a text box you can write on and a screen.\n- Delete all the text on the text box.\n- Copy this code and paste it on the text box.\n- If nothing happnes, press \"alt\" + \"enter\" and the shader should compile.\n*/\n\n#define PI 3.141592653589793238\n\n// Returns a normalized directoin based on an angle\nvec2 polarToCartesian (float angle) {\n  return vec2 (sin (angle), cos (angle));\n}\n\n// Reflects the UV based on a relfection line centered in the point p with a given angle\nvec2 ref (vec2 uv, vec2 p, float angle) {\n  vec2 dir = polarToCartesian (angle); // Direction of the reflection line\n  return uv - dir * min (dot (uv - p, dir), 0.0) * 2.0; // Returns the reflected uv coordinate\n}\n\n// Folds the 2d space to generate the fractal and returns the distance to it\nfloat kochsCurve (inout vec2 uv, int recursionCount) {\n  float scale = 1.25; // Scale of the UV\n  uv *= scale; // Scales the UV to make the fractal fit on the screen\n\n  // This is here so that the first image is a straight line in the center\n  if (recursionCount >= 0) {\n    uv.y -= sqrt (3.0) / 6.0; // Translates the Y coordinate up\n    uv.x = abs (uv.x); // Makes a reflection line in the Y axis\n    uv = ref (uv, vec2 (0.5, 0), 11.0 / 6.0 * PI); // Makes a reflection line to form a triangle\n    uv.x += 0.5; // Translates the X coordinate to the center of the line\n  }\n\n  for (int i = 0; i < recursionCount; ++i) {\n    uv.x -= 0.5; // Translates the X coordinate\n    scale *= 3.0; // Increases the scale for each recursion loop\n    uv *= 3.0; // Scales down the shape\n    uv.x = abs (uv.x); // Creates a reflection line in the Y axis\n    uv.x -= 0.5; // Translates the X corrdinate\n    uv = ref (uv, vec2 (0, 0), (2.0 / 3.0) * PI); // Creates an angled reflection line to form the triangle\n  }\n\n  uv.x = abs (uv.x); // Creates a reflection line in the Y axis\n  float d = length (uv - vec2 (min (uv.x, 1.0), 0.0)) / scale; // Calculates distance to the fractal\n  uv /= scale; // Resets the scaling in the uv\n  return d; // Returns the distance\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord) {\n  vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y; // Centers the UV coordinates on the center of the canvas\n  vec3 col = vec3 (0); // Color to be drawn on screen\n\n  // Bending the world\n  int recursionCount = -1 + int (mod (iTime, 14.0) * 0.5); // Number of iterations for the fractal\n  float d = kochsCurve (uv, recursionCount); // Distance from the fractal\n\n  // Drawing the fractal\n  float lineSmoothness = 4.0 / iResolution.y; // Smoothness / thickness of the line (higher number = smoother / thicker, lower numbers = sharper / thinner)\n  col.r += smoothstep (lineSmoothness, 0.0, d) * 0.5;\n\n  // Drawing the axis\n  lineSmoothness = 1.0 / iResolution.y; // Descreases line smoothness for sharper / thinner lines\n  col.rb += smoothstep (lineSmoothness, 0.0, length (uv.y)); // x axis\n  col.bg += smoothstep (lineSmoothness, 0.0, length (uv.x)); // y axis\n\n  fragColor = vec4 (col, 1.0); // Outputs the color fo the pixel to the screen\n}","name":"Image","description":"","type":"image"}]}