{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[],"code":"float aastep(float a, float x) {\n    float w = 0.7*fwidth(x-a);\n    return smoothstep(-w, w, x-a);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized coordinates (-1 to 1 along shortest axis)\n    vec2 uv = 2.0 * (fragCoord - 0.5*iResolution.xy);\n    uv = uv / min(iResolution.x, iResolution.y);\n    \n    // These are constants that can be computed at compile time\n    const float twoPI = 6.283185307;\n    const float c15 = cos(twoPI/5.0);\n    const float s15 = sin(twoPI/5.0);\n\n#if 0\n    // Easy code, with one unecessary matrix multiplication\n    // and with the extra baggage of computing both x and y\n    const mat2 R5 = mat2(c15, -s15, s15, c15);\n    vec2 uvrot = uv;\n    float outside = 0.0; // Point is outside this many lines\n    for(float i = 0.0; i < 5.0; i++) {\n        outside += aastep(0.2, uvrot.y); // Increment if outside\n        uvrot = R5*uvrot; // Unnecessary in the last iteration\n    }\n#else\n    // Optimized code, computing only what we need at runtime\n    // and using less than half as many multiplications. This kind of\n    // algorithm-level optimization is not (yet) handled automatically\n    // by shader compilers.\n    const float c25 = cos(2.0*twoPI/5.0);\n    const float s25 = sin(2.0*twoPI/5.0);\n    const float c35 = c25;  //cos(3.0*twoPI/5.0);\n    const float s35 = -s25; // sin(3.0*twoPI/5.0);\n    const float c45 = c15;  // cos(4.0*twoPI/5.0);\n    const float s45 = -s15; // sin(4.0*twoPI/5.0);\n    float outside = 0.0;\n    outside += aastep(0.2, uv.y);\n    outside += aastep(0.2, dot(vec2(s15, c15), uv));\n    outside += aastep(0.2, dot(vec2(s25, c25), uv));\n    outside += aastep(0.2, dot(vec2(s35, c35), uv));\n    outside += aastep(0.2, dot(vec2(s45, c45), uv));\n#endif\n\n    vec3 col = vec3(0.0,0.3,0.8); // Blue background\n    float circle = aastep(0.9, length(uv));\n    col = mix(vec3(1.0,1.0,0.0), col, circle); // Yellow circle\n\n    float star = clamp(outside-1.0, 0.0, 1.0);\n    col = mix(vec3(1.0,0.0,0.0), col, star); // Red star\n\n    // Comment out this line to see only the final pattern\n    col = mix(vec3((outside-circle)/3.0), col, aastep(uv.y, cos(iTime)));\n\n    fragColor = vec4(col,1.0);\n}\n","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"lfGfWw","date":"1734089344","viewed":42,"name":"Pixar Star pattern","username":"stegu","description":"My recreation (for a book I'm writing) of the famous pattern on the ball in \"Luxo Jr\", which has made cameo appearances in many Pixar productions since. Now with proper anti-aliasing, contrary to the classic example in \"The Renderman Companion\".","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["star","ball","pixar"],"hasliked":0,"parentid":"","parentname":""}}