{"ver":"0.1","info":{"id":"3dBBRz","date":"1589349764","viewed":88,"name":"Environment Dome","username":"stanlo","description":"hello","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["dome","pig","pigdome"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 \tcameraPivot \t= vec3(0.0, -0.5, 0);\nfloat \tdomeRadius \t\t= 10.0;\t// Convenience value that rescales other parameters\nfloat \tcameraDistance \t= 2.5;\t// [-domeRadius, domeRadius]\nfloat \tfloorHeight \t= -1.5;\t// [-domeRadius, domeRadius]\nfloat \tsmoothFactor \t= 0.4;\t// [0.0, 1.0]\nfloat \tcameraRadius \t= 0.1;\t// Hack, should incorporate fov and determine bounds\n\n\nconst float PI = 3.1;\n\nvec2 getCenteredUv(vec2 coord) {\n    vec2 uv  \t\t\t\t= coord / iResolution.xy;\n    vec2 aspectCorrection\t= vec2(1, iResolution.y / iResolution.x);\n    vec2 centeredUv\t\t\t= uv * 2.0 - 1.0;\n    return centeredUv * aspectCorrection;\n}\n\n// https://iquilezles.org/articles/smin\nfloat smin( float a, float b, float k )\n{\n    float h = max( k-abs(a-b), 0.0 )/k;\n    return min( a, b ) - h*h*h*k*(1.0/6.0);\n}\n\n// https://iquilezles.org/articles/boxfunctions\nvec4 iBox( in vec3 ro, in vec3 rd, vec3 translation, in vec3 rad ) {\n    // convert from ray to box space\n\tvec3 rdd = (vec4(rd,0.0)).xyz;\n\tvec3 roo = (vec4(ro - translation,1.0)).xyz;\n\n\t// ray-box intersection in box space\n    vec3 m = 1.0/rdd;\n    vec3 n = m*roo;\n    vec3 k = abs(m)*rad;\n\t\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\n\tfloat tN = max( max( t1.x, t1.y ), t1.z );\n\tfloat tF = min( min( t2.x, t2.y ), t2.z );\n\t\n\tif( tN > tF || tF < 0.0) return vec4(-1.0);\n\n\tvec3 nor = -sign(rdd)*step(t1.yzx,t1.xyz)*step(t1.zxy,t1.xyz);\n\n    // convert to ray space\n\t\n\tnor = (vec4(nor,0.0)).xyz;\n\n\treturn vec4( tN, nor );\n}\n\nfloat intersectSphereInternal(vec3 rayPosition, vec3 rayDirection, float radius) {\n    float b = dot(rayPosition, rayDirection);\n    float c = dot(rayPosition, rayPosition) - radius*radius;\n    float h = sqrt(b*b - c);\n    return -b + h;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 \tuv \t\t\t\t= getCenteredUv(fragCoord);\n    vec2 \tmouseUv\t\t\t= getCenteredUv(iMouse.xy);\n    \n    if (length(iMouse) <= 1.) {\n        mouseUv = vec2(0.0);\n    }\n    \n    \n    vec3 \tviewDirection \t= normalize(vec3(uv, -2.0 / tan(75.0 / 180.0 * PI)));\n    float \tcameraAzimuth \t= -2.0 * PI * mouseUv.x;\n    float \tcameraPitch \t= 1.0 * PI * mouseUv.y;\n    vec3 \tcameraForward \t= vec3(-sin(cameraAzimuth) * cos(cameraPitch), sin(cameraPitch), -cos(cameraAzimuth) * cos(cameraPitch));\n    vec3 \tcameraSide \t\t= vec3(cos(cameraAzimuth), 0, -sin(cameraAzimuth));\n    vec3 \tcameraUp \t\t= cross(cameraSide, cameraForward);\n    mat3 \tworldFromView \t= mat3(cameraSide, cameraUp, -cameraForward);\n    \n    vec3 worldDirection = worldFromView * viewDirection;\n    vec3 cameraPosition = cameraPivot - cameraForward * cameraDistance;\n    cameraPosition.y = max(cameraPosition.y, floorHeight + cameraRadius);\n\n    float sphereTime = intersectSphereInternal(cameraPosition, worldDirection, domeRadius);\n    float floorTime = (cameraPosition.y - floorHeight) / -worldDirection.y;\n    float domeTime = sphereTime;\n    if (floorTime > 0.0) {\n        domeTime = smin(sphereTime, floorTime, smoothFactor * domeRadius);\n    }\n    vec3 domePoint = cameraPosition + domeTime * worldDirection;\n    fragColor = texture(iChannel0, vec3(domePoint));\n\n    \n    vec4 boxIntersection = iBox(cameraPosition, worldDirection, vec3(0, -1.0, 0), vec3(0.5));\n    if (boxIntersection.x > 0.0) {\n        fragColor.xyz = vec3(1.0, 0.75, 1.0) * pow(dot(boxIntersection.yzw, -worldDirection), 1.0 / 4.0);\n    }\n}","name":"Image","description":"","type":"image"}]}