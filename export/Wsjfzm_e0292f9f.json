{"ver":"0.1","info":{"id":"Wsjfzm","date":"1589814042","viewed":91,"name":"I dont understand shaders","username":"Anderkent","description":"Performing the `(bary.z * v1.Uv  + bary.x * v2.Uv + bary.y * v3.Uv)` calculation outside the conditionals somehow changes the output, even though nothing is mutated (?). How?\n\nremove the && false comment in line 217 to verify (it'll optimize out the calc)","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["rasterizer","mesh"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","previewfilepath":"/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n\n#define BACKFACE_CULL true\n#define TEXTURED true\n\n\nstruct Vertex\n{\n    vec4 Pos;\n    vec2 Uv;\n};\n\n\n// Test a position against a triangle and return\n// the non-perspective-correct barycentric coordinates in the triangle\n// Vertex z and w values are ignored.\nvec2 BaryTri2D ( vec2 pos, Vertex v1, Vertex v2, Vertex v3 )\n{\n    vec2 posv1 = pos - vec2(v1.Pos);\n    \n    vec2 v21 = vec2(v2.Pos) - vec2(v1.Pos);\n    vec2 v31 = vec2(v3.Pos) - vec2(v1.Pos);\n    \n    float scale = v21.x * v31.y - v21.y * v31.x;\n    if ( BACKFACE_CULL && ( scale < 0.0 ) )\n    {\n        return vec2 ( -1.0, -1.0 );\n    }\n    \n    float rscale = 1.0 / scale;\n    float baryi = ( posv1.x * v31.y - posv1.y * v31.x ) * rscale;   \n    float baryj = ( posv1.x * v21.y - posv1.y * v21.x ) * -rscale;\n    \n    return vec2 ( baryi, baryj );\n}\n\n\n// Test a position against a triangle and return\n// the perspective-correct barycentric coordinates in the triangle\n// Note the z value in the vertex is ignored, it's the w that matters.\nvec2 BaryTri3D ( vec2 pos, Vertex v1, Vertex v2, Vertex v3 )\n{\n    vec2 posv1 = pos - vec2(v1.Pos);\n    \n    vec2 v21 = vec2(v2.Pos) - vec2(v1.Pos);\n    vec2 v31 = vec2(v3.Pos) - vec2(v1.Pos);\n    \n    float scale = v21.x * v31.y - v21.y * v31.x;\n    if ( BACKFACE_CULL && ( scale < 0.0 ) )\n    {\n        return vec2 ( -1.0, -1.0 );\n    }\n\n    float rscale = 1.0 / scale;\n    float baryi = ( posv1.x * v31.y - posv1.y * v31.x ) * rscale;\n    float baryj = ( posv1.x * v21.y - posv1.y * v21.x ) * -rscale;\n    \n    // Now interpolate the canonical coordinates (0,0,1,v1.w), (1,0,1,v2.w) and (0,1,1,v3.w)\n    // with perspective correction\n    // So we project all three by their respective w:\n    // (0,0,v1.w) -> (0,     0,     1/v1.w)\n    // (1,0,v2.w) -> (1/v2.w,0,     1/v2.w)\n    // (0,1,v3.w) -> (0,     1/v3.w,1/v3.w)\n    // Then interpolate those values linearly to produce (nx,ny,nw),\n    // then divide by nw again.\n    vec3 recipw = vec3 ( 1.0/v1.Pos.w, 1.0/v2.Pos.w, 1.0/v3.Pos.w );\n    \n    float baryk = 1.0 - baryi - baryj;\n    float newi = recipw.y * baryi;\n    float newj = recipw.z * baryj;\n    //float neww = recipw.x * baryk + recipw.y * baryi + recipw.z * baryj;\n    float neww = recipw.x * baryk + newi + newj;\n    \n    // ...and project back.\n    float rneww = 1.0/neww;\n    float perspi = newi * rneww;\n    float perspj = newj * rneww;\n        \n    return vec2 ( perspi, perspj );\n}\n\nconst int GridW = 5;\nconst int GridH = 5;\nconst int NumVerts = GridH*GridW*2;\nconst int NumTris = (GridH-1)*(GridW-1)*2*2;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // NDC (-1 to +1)\n    vec2 uv = -1.0 + 2.0f * (fragCoord/iResolution.xy);\n    \n    float wobble = float(iTime);\n    \n    // Create the mesh. This would of course be done offline.\n    Vertex Verts[NumVerts];\n    for ( int w = 0; w < GridW; w++ )\n    {\n        for ( int h = 0; h < GridH; h++ )\n        {\n            Vertex Vert0, Vert1;\n            Vert0.Pos.x = float(w - GridW/2);\n            Vert0.Pos.y = float(h - GridH/2);\n            float wf = -2.0 + float(w);\n            float hf = -3.0 + float(h);\n            float d = sqrt(wf*wf + hf*hf);\n            Vert0.Pos.z = 0.3 * cos (d * 2.0 + wobble);\n            Vert0.Pos.w = 1.0f;\n            Vert0.Uv.x = float(w) / float(GridW-1);\n            Vert0.Uv.y = float(h) / float(GridH-1);\n            \n            Vert1.Pos = Vert0.Pos;\n            Vert1.Pos.z += 1.0f;\n            Vert1.Uv = Vert0.Uv;\n            \n            int Index = (w*GridH+h)*2;\n            Verts[Index+0] = Vert0;\n            Verts[Index+1] = Vert1;\n        }\n    }\n\n    int Indices0[NumTris];\n    int Indices1[NumTris];\n    int Indices2[NumTris];\n    for ( int w = 0; w < GridW-1; w++ )\n    {\n        for ( int h = 0; h < GridH-1; h++ )\n        {\n            int VertIndex = (w*GridH+h)*2;\n            int TriIndex = (w + (GridH-1)*h) * 2 * 2;\n            Indices0[TriIndex+0] = VertIndex  ;\n            Indices1[TriIndex+0] = VertIndex  +GridH*2;\n\t\t\tIndices2[TriIndex+0] = VertIndex  +2;\n            Indices0[TriIndex+1] = VertIndex+1;\n            Indices2[TriIndex+1] = VertIndex+1+GridH*2;\n\t\t\tIndices1[TriIndex+1] = VertIndex+1+2;\n            \n            Indices2[TriIndex+2] = VertIndex  +GridH*2;\n            Indices0[TriIndex+2] = VertIndex  +GridH*2+2;\n\t\t\tIndices1[TriIndex+2] = VertIndex  +2;\n            Indices1[TriIndex+3] = VertIndex+1+GridH*2;\n            Indices0[TriIndex+3] = VertIndex+1+GridH*2+2;\n\t\t\tIndices2[TriIndex+3] = VertIndex+1+2;\n        }\n    }\n    \n    float hfov = 0.6;\n    float vfov = hfov * iResolution.y / iResolution.x;\n    float zfar = 10.0f;\n    float znear = 1.0f;\n    float q = zfar/(zfar-znear);\n    \n    mat4 ProjMat;\n    ProjMat[0] = vec4 ( 1.0/hfov, 0.0f, 0.0f, 0.5f );\n    ProjMat[1] = vec4 ( 0.0f, 1.0/vfov, 0.0f, 0.5f );\n    ProjMat[2] = vec4 ( 0.0f, 0.0f, q, 1.0f );\n    ProjMat[3] = vec4 ( 0.0f, 0.0f, -q*znear, 0.0f );\n    \n    \n    mat4 TotalMat;\n    mat4 ObjMat1;\n    mat4 ObjMat2;\n    \n    float a1 = iMouse.x * 0.01;\n    float a2 = iMouse.y * 0.01;\n    float zdist = 8.0;\n    ObjMat1[0] = vec4 ( cos(a1),  sin(a1), 0.0, 0.0 );\n    ObjMat1[1] = vec4 ( sin(a1), -cos(a1), 0.0, 0.0 );\n    ObjMat1[2] = vec4 ( 0.0,          0.0, 1.0, 0.0 );\n    ObjMat1[3] = vec4 ( 0.0,          0.0, 0.0, 1.0 );\n    ObjMat2[0] = vec4 ( 1.0, 0.0,          0.0, 0.0 );\n    ObjMat2[1] = vec4 ( 0.0, cos(a2),  sin(a2), 0.0 );\n    ObjMat2[2] = vec4 ( 0.0, sin(a2), -cos(a2), zdist );\n    ObjMat2[3] = vec4 ( 0.0, 0.0,          0.0, 1.0 );\n    \n    TotalMat = ObjMat1 * ObjMat2;\n    TotalMat = TotalMat * ProjMat;\n\n    // Background colour\n    vec3 col;\n    col.xy = uv.xy;\n    col.z = 0.0;\n\n    Vertex ScreenVert[NumVerts];\n    for ( int VertNum = 0; VertNum < NumVerts; VertNum++ )\n    {\n        vec4 Pos = Verts[VertNum].Pos;\n        \n        vec4 ScrPos = Pos * TotalMat;\n        float rw = 1.0/ScrPos.w;\n        ScrPos.x *= rw;\n        ScrPos.y *= rw;\n        ScrPos.z *= rw;\n        \n        ScreenVert[VertNum].Pos = ScrPos;\n        ScreenVert[VertNum].Uv = Verts[VertNum].Uv;\n    }\n    \n    float NearestZ = 10000.0f;\n    for ( int TriNum = 0; TriNum < NumTris; TriNum++ )\n    {\n        Vertex v1 = ScreenVert[Indices0[TriNum]];\n        Vertex v2 = ScreenVert[Indices1[TriNum]];\n        Vertex v3 = ScreenVert[Indices2[TriNum]];\n        vec3 bary;\n        bary.xy = BaryTri3D ( uv, v1, v2, v3 );\n        bary.z = 1.0 - bary.x - bary.y;\n\n        // You need to do the UV coord generation outside all the conditionals,\n        // otherwise you don't get good gradients at the edges.\n        // HOWEVER - what actually happens is the compiler spots you only *use* the UV\n        // values inside the conditionals and drags the calculation inside,\n        // which then breaks the gradients! So to stop this, I added a totally\n        // spurious test of the UV coords to the barycentric test.\n\n        if ((bary.z * v1.Uv  + bary.x * v2.Uv + bary.y * v3.Uv).x + \n             (bary.z * v1.Uv  + bary.x * v2.Uv + bary.y * v3.Uv).y < -10.0\n            // && false\n           ) {\n            col.xy = bary.xy;\n            col.z = sqrt(-1.0);\n        }\n\n        \n        if ( ( bary.x >= 0.0 ) &&\n             ( bary.y >= 0.0 ) &&\n             ( bary.z >= 0.0 ) )\n        {\n            vec2 uv = bary.z * v1.Uv + bary.x * v2.Uv + bary.y * v3.Uv;\n            // Interpolate Z\n            // Note this is linear Z, not the strange Z that most rasteriser use\n            // In this case, that's fine.\n            float Z = bary.z * v1.Pos.z + bary.x * v2.Pos.z + bary.y * v3.Pos.z;\n            if ( NearestZ > Z )\n            {\n                NearestZ = Z;\n            \n                if ( TEXTURED )\n                {\n                    vec4 tex = texture ( iChannel0, uv );\n                    col.xyz = tex.xyz;\n                }\n                else\n                {\n                    col.xy = bary.xy;\n                    col.z = 1.0;\n                    if ( fract ( bary.x * 4.0 ) < 0.05 ) { col.z = 0.0; }\n                    if ( fract ( bary.y * 4.0 ) < 0.05 ) { col.z = 0.0; }\n                }\n            }\n        }\n    }\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n","name":"Image","description":"","type":"image"}]}