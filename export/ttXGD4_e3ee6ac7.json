{"ver":"0.1","info":{"id":"ttXGD4","date":"1556317041","viewed":372,"name":"[TWITCH] Pit of the beast","username":"Flopine","description":"I did this shader during a stream on Twitch here: https://www.twitch/flopine\nThe purpose was to recreate the effect I did  in 25 minutes during the quaterfinals of the revision shader showdown, but by improving it and building more stuff upon it.","likes":22,"published":1,"flags":0,"usePreview":0,"tags":["3d","raymarching","hexagons","twitch"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Code by Flopine\n// Thanks to wsmind, leon, XT95, lsdlive, lamogui, Coyhot, Alkama and YX for teaching me\n// Thanks LJ for giving me the love of shadercoding :3\n\n// Cookie Collective rulz\n\n#define time iTime\n\nvec2 hr = vec2(1., sqrt(3.));\nfloat detail = 5.;\nfloat PI = 3.141593;\n\nfloat rand (vec2 st)\n{return fract(sin(dot(vec2(2.45,3.45), st))*11.44);}\n\nfloat stmin (float a, float b, float k, float n)\n{\n    float st = k/n;\n    float u = b-k;\n    return min(min(a,b), 0.5*(u+a+abs(mod(u-a+st,2.*st)-st)));\n}\n\nmat2 rot(float a)\n{return mat2(cos(a),sin(a),-sin(a),cos(a));}\n\nvoid moda(inout vec2 p, float rep)\n{\n    float per = 2.*PI/rep;\n    float a = atan(p.y,p.x);\n    float l = length(p);\n    a = mod(a-per*0.5, per)-per*0.5;\n    p = vec2(cos(a),sin(a))*l;\n}\n\nvec4 hg (vec2 uv)\n{\n    uv *= detail;\n\n    vec2 ga = mod(uv, hr)-hr*0.5;\n    vec2 gb = mod(uv - hr*0.5, hr)-hr*0.5;\n    vec2 guv = dot(ga,ga) < dot(gb,gb) ? ga : gb;\n\n    vec2 gid = uv-guv;\n\n    vec2 uu = abs(guv);\n    guv.y = .5 - max(uu.x, dot(uu, normalize(hr)));\n\n    return vec4(guv,gid);\n}\n\nvec2 hid;\nfloat dm (vec2 uv)\n{\n    vec4 hxs = hg(uv);\n    hid = hxs.zw;\n    return smoothstep(0.05,0.06-sin(time)*0.1+0.1,hxs.y) * sin(length(hid)-time);\n}\n\nfloat box (vec3 p, vec3 c)\n{\n    vec3 q = abs(p)-c;\n    return min(0.,max(q.x,max(q.y,q.z))) + length(max(q,0.));\n}\n\nfloat cyl (vec3 p, float r, float h)\n{ return max(length(p.xy)-r, abs(p.z)-h); }   \n\nfloat od (vec3 p, float d)\n{return dot(p, normalize(sign(p)))-d;}\n\nfloat room (vec3 p)\n{\n    p.y -=3.5;\n    float b = -box(p, vec3(10.,4.,10.));\n\n    float c = 1e10;\n    float aoffset = 0.;\n    float offset = 0.;\n    for (int i=0; i<3; i++)\n    {\n        p.xz *= rot(PI/(4.+aoffset));\n        moda(p.xz, 5.);\n        p.x -= 2.+offset;\n        c = min(c, cyl(p.xzy, 0.25, 10.));\n\n        aoffset += 2.;\n        offset ++;\n    }\n\n\n    return stmin(b, c, 0.3, 4.);\n}\n\nfloat pit (vec3 p)\n{\n    float c = cyl(p.xzy, 2.,5.);\n    return max(abs(c)-0.14, p.y-.7);\n}\n\nfloat g1 = 0.;\nfloat water (vec3 p)\n{\n    vec3 pp = p;\n    p.y += .3;\n    p.y += dm(p.xz)*0.07;\n    float d = max(abs(p.y)-.8,cyl(pp.xzy, 2.,5.));  \n    g1 += 0.01/(0.01+d*d);\n    return d;\n} \n\nfloat g2 = 0.;\nfloat monster (vec3 p)\n{\n    vec3 pp = p;\n    p.y -= .8+sin(time)*0.1;\n    float o = od(p, 0.3);\n\n    p = pp;\n    p.xz*=rot(sin(p.y-time));\n    moda(p.xz, 6.);\n    p.x -= 1.;\n    float c = cyl(p.xzy, 0.3-p.y*0.1, 5.);\n\n    float d =  min(c,o);\n    g2 += 0.01/(0.01+d*d);\n    return d;\n}\n\nfloat SDF (vec3 p)\n{\n    float m = monster(p);\n    float r = room(p);\n    float w = water(p);\n    float well = pit(p);\n    float d = min(m,min(stmin(r, well, .5, 5.),w));\n\n    return d;\n}\n\nvec3 getnormal(vec3 p)\n{\n    vec2 eps = vec2(0.01,0.);\n    //return normalize(SDF(p)-vec3(SDF(p-eps.xyy), SDF(p-eps.yxy),SDF(p-eps.yyx)));\n    return normalize(vec3(SDF(p+eps.xyy)-SDF(p-eps.xyy),\n                          SDF(p+eps.yxy)-SDF(p-eps.yxy),\n                          SDF(p+eps.yyx)-SDF(p-eps.yyx)\n                         )\n                    );\n}\n\n\nfloat dir_lighting (vec3 n, vec3 l)\n{return dot(n, normalize(l)) * 0.5 + 0.5;}\n\n\nvec3 getcam (vec3 ro, vec3 tar, vec2 uv)\n{\n    vec3 f = normalize(tar-ro);\n    vec3 l = normalize(cross(vec3(0.,1.,0.),f));\n    vec3 u = cross(f,l);\n    return normalize(f + l*uv.x + u*uv.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n    uv -= 0.5;\n    uv /= vec2(iResolution.y / iResolution.x, 1);\n    \n    vec3 col = vec3(0.);\n    vec3 ro = vec3(4.*cos(time*0.5),2.5,-4.*sin(-time*0.5)); vec3 p = ro;\n    vec3 rd = normalize(vec3(uv,1.));\n    rd = getcam(ro, vec3(0.,0.5,0.), uv);\n    float shad = 0.;\n    bool hit = false;\n\n    for (float i=0.; i<100.; i++)\n    {\n        float d = SDF(p);\n        if (d<0.001)\n        {\n            hit = true;\n            shad = i/100.;\n            break;\n        }     \n        p += d*rd*0.8;\n    }\n    float t = length(ro-p);\n    if (hit)\n    {\n        vec3 l = vec3(8., 1., 3.);\n        vec3 n = getnormal(p);\n        col = mix(vec3(0.3,0.,0.2), vec3(0.5,0.7,0.8), dir_lighting(n, l));\n\n        col += vec3(rand(hid),0.3,1.)*g1*0.3;\n        col -= g2*0.2;\n    }\n\n    else col = vec3(0.);\n\n    col = mix(col, vec3(0.1,0.15,0.2), 1.-exp(-0.04*t*t));\n    fragColor = vec4(col, 1.);\n}","name":"Image","description":"","type":"image"}]}