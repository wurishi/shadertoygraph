{"ver":"0.1","info":{"id":"Wty3Rh","date":"1578197732","viewed":362,"name":"Path tracing + Physics","username":"Tara","description":"This is unfinished.\n\nControls:\n   Mouse click & drag = look\n   WASD, CTRL, Space = Move\n\nTODO:\n- Add temporal reprojection.\n- Make spheres grabbable.\n- Improve physics.\n\n2022.03.16: Added various small improvements (tone mapping, RNG, performance, grafx).","likes":12,"published":1,"flags":48,"usePreview":0,"tags":["raytracing","pathtracing","physics"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Renders the buffer with the final image to the screen.\n\n// Channel0 = Buffer D (rendered scene)\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec4 scene_color = texelFetch(iChannel0, ivec2(fragCoord.xy), 0);\n    //fragColor.rgb = tonemap(scene_color.rgb);\n    fragColor.rgb = ACESFitted(scene_color.rgb);\n    //fragColor.rgb = ACESFilm(scene_color.rgb);\n    \n    fragColor.rgb = to_gamma_space(fragColor.rgb);\n    //fragColor.rgb *= 0.5;\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":3,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":2,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"// Renders the image to a buffer so we can average it.\n\n//sampler2D iChannel0;\n\n// Channel0 = Buffer B (camera attributes)\n// Channel1 = Buffer A (sphere attributes)\n// Channel2 = Blue noise texture\n// Channel3 = Buffer D (rendered image [feedback loop])\n\n\n\n\nconst vec2 inverse_texture_noise_dimensions = vec2(1.0 / 1024.0);\n\n#define TEMPORAL_ACCUMULATION\n  \n/*\nvec4 sphere_list[3] = vec4[3](\t// XYZ = position, Z = radius\n    vec4(2.0, 0.0, 5.0, 0.5),\n    vec4(0.0, 0.0, 5.0, 1.0),\n    vec4(-2.0, 0.0, 5.0, 0.25)\n);\n*/\n\nstruct RAY\n{\n    vec3 origin;\n    vec3 direction;\n};\n\n\nstruct SPHERE\n{\n    vec3 position;\n    vec3 color;\n    vec3 radiance;\n    float roughness;\n    float radius;\n};\n\n\nint rng_seed = 1;\t// TODO: Initialize properly!\n\nfloat rng_seed_halton = 0.0;\n\n// \"index\" must be rounded to the nearest integer.\nvec2 haltonf(float index)\n{\n\t// Source: \"Using Blue Noise for Ray Traced Soft Shadows\" - Alaon Wolfe, NVIDIA\n\t// https://www.springerprofessional.de/en/using-blue-noise-for-ray-traced-soft-shadows/19538270\n\t\n    const vec2 coprimes = vec2(2.0, 3.0);\n    vec2 s = vec2(index);\n\tvec4 a = vec4(1.0, 1.0, 0.0, 0.0);\n    while((s.x > 0.0)&&(s.y > 0.0))\n    {\n        a.xy = a.xy / coprimes;\n        a.zw += a.xy * mod(s, coprimes);\n        s = floor(s / coprimes);\n    }\n    return(a.zw);\n}\n\nvec3 get_noise_halton(float seed)\n{\n\t// This essentially gives us a random different blue noise texture region per sample.\n\tfloat halton_index = 1.0 + seed;\n\t\n#ifdef TEMPORAL_ACCUMULATION\n\thalton_index += float(iFrame) * float(samples_per_pixel) * float(max_bounces_per_pixel);\n#endif\n\t\n\tvec2 texture_coordinate = gl_FragCoord.xy * inverse_texture_noise_dimensions;\n\ttexture_coordinate += haltonf(halton_index);\n\n    // Must use nearest filtering!\n\treturn(texture(iChannel2, texture_coordinate).rgb);\n}\n\nvec3 rand_3d(void)\n{\n    vec3 n = get_noise_halton(rng_seed_halton).xyz;\n    rng_seed_halton += 1.0;\n    return(n);\n}\n\nvec2 rand_2d(void)\n{\n    vec2 n = get_noise_halton(rng_seed_halton).xy;\n    rng_seed_halton += 1.0;\n    return(n);\n}\n    \nfloat rand(void)\n{\n    float n = get_noise_halton(rng_seed_halton).r;\n    rng_seed_halton += 1.0;\n    return(n);\n    \n    \n    rng_seed = (rng_seed * 48271) % 2147483647;\n    return(float(rng_seed) / 2147483647.0);\n}\n\n\n// Source: https://gamedev.stackexchange.com/questions/96459/fast-ray-sphere-collision-code\nbool intersects_sphere(RAY ray, vec3 sphere_position, float sphere_radius, out float t)\n{\n    vec3 s = ray.origin;\n    vec3 d = ray.direction;\n    vec3 c = sphere_position;\n    float r = sphere_radius;\n    \n\t// Calculate ray start's offset from the sphere center\n    vec3 p = s - c;\n\n    float rSquared = r * r;\n    float p_d = dot(p, d);\n\n    // The sphere is behind or surrounding the start point.\n    if(p_d > 0.0 || dot(p, p) < rSquared)\n    {\n        return(false);\n    }\n\n    // Flatten p into the plane passing through c perpendicular to the ray.\n    // This gives the closest approach of the ray to the center.\n    vec3 a = p - p_d * d;\n\n    float aSquared = dot(a, a);\n\n    // Closest approach is outside the sphere.\n    if(aSquared > rSquared)\n    {\n        return(false);\n    }\n\n    // Calculate distance from plane where ray enters/exits the sphere.    \n    float h = sqrt(rSquared - aSquared);\n\n    // Calculate intersection point relative to sphere center.\n    vec3 i = a - h * d;\n\n    vec3 intersection = c + i;\n    //vec3 normal = i / r;\n    // We've taken a shortcut here to avoid a second square root.\n    // Note numerical errors can make the normal have length slightly different from 1.\n    // If you need higher precision, you may need to perform a conventional normalization.\n\n    t = distance(intersection, ray.origin);\t// TODO: Optimize!\t// Simply return the point of intersection instead?\n    //return (intersection, normal); \n    return(true); \n}\n\nstruct RAY_TRACE_RESULT\n{\n    float t;\n    int intersected_sphere_index;\n    bool intersection_found;\n};\n\nvec4 get_sphere_attribute(int sphere_index, int attribute_index)\n{\n    return(texelFetch(iChannel1, ivec2(sphere_index, attribute_index), 0));\n}\n\nRAY_TRACE_RESULT intersect_ray_with_world(RAY ray)\n{\n    RAY_TRACE_RESULT result;\n    result.intersected_sphere_index = -1;\n    result.t = 99999.9;\n    \n    for(int sphere_index=0; sphere_index<SPHERE_COUNT; ++sphere_index)\n    {\n        vec4 sphere_position_and_radius = get_sphere_attribute(sphere_index, SPHERE_POSITION_AND_RADIUS_COORDINATE);\n       \n        float t;\n        if(intersects_sphere(ray, sphere_position_and_radius.xyz, sphere_position_and_radius.w, t)&&\n           (t < result.t))\n        {\n            result.intersected_sphere_index = sphere_index;\n            result.t = t;\n        }\n   \t}\n\n    result.intersection_found = (result.intersected_sphere_index >= 0);\n    \n    return(result);\n}\n    \n//Source: https://stackoverflow.com/a/15048260\n/*\nReturns a random point of a sphere, evenly distributed over the sphere.\nThe sphere is centered at (x0,y0,z0) with the passed in radius.\nThe returned point is returned as a three element array [x,y,z]. \n*/\nvec3 randomSpherePoint(void)\n{\n    vec2 rng = rand_2d();\n\n   float u = rng.x;\n   float v = rng.y;\n   float theta = 2.0 * PI * u;\n   float phi = acos(2.0 * v - 1.0);\n   float x = sin(phi) * cos(theta);\n   float y = sin(phi) * sin(theta);\n   float z = cos(phi);\n   return(vec3(x,y,z));\n}\n    \n// TODO: STABILITY: Use a different implementation\n// Depending on the RNG this might never exit, unless we can the iteration count.\nvec3 get_next_in_sphere(void)\n{\n    // Implementation based on this article: https://karthikkaranth.me/blog/generating-random-points-in-a-sphere/\n    // TODO: Could implement min and max radius support like here: https://stackoverflow.com/questions/47472123/sample-uniformly-in-a-multidimensional-ring-without-rejection\n\n    int i = 0;\n    vec3 p;\n    \n    const int max_iterations = 3;\n\n    // Keep generating random points in a half unit cube till\n    // the random point is contained within a half unit sphere:\n    do\n    {\n        //p.x = rand() - 0.5;\n        //p.y = rand() - 0.5;\n        //p.z = rand() - 0.5;\n        p = rand_3d() - 0.5;\n\n    } while(dot(p, p) > 0.25 && ++i <= max_iterations);\n\n    return(normalize(p));\n}\n\n\nvec3 get_random_vector_in_hemisphere(vec3 normal)\n{\n\tvec3 vector = normalize(randomSpherePoint());\n\t//vec3 vector = get_next_in_sphere();\n    if(dot(vector, normal) < 0.0)\n    {\n        vector = -vector; \n    }\n    \n    return(vector);\n}\n\n// TODO: This is shit!\nvec3 get_random_vector_in_hemisphere2(vec3 vector)\n{\n\tfloat f1 = rand();\n\tfloat f2 = rand();\n\t// find an orthonormal basis\n\tvec3 up = normalize(vector);\n\t//vec3 u = ( up.x > 0.99 || up.x < -0.99 ? vec3(0,1,0) : vec3(1,0,0) );\t// Causes strange errors on the spheres...\n\tvec3 u = ( up.x >= 0.999999 || up.x <= -0.999999 ? vec3(0.0, 1.0, 0.0) : vec3(1.0, 0.0, 0.0) );\t// Causes strange errors on the spheres...\n\t\n\t/*\n\tvec3 u;\n\tif(up.x > 0.99 || up.x < -0.99)\n\t{\n\t\tu = vec3(0,1,0);\n\t}\n\telse\n\t{\n\t\tu = vec3(1,0,0);\n\t}\n\t*/\n\tvec3 v = cross(up, u);\t//up.Cross( u );\n\tu = cross(v, up);\t//u = v.Cross( up );\n    \n    const float pi = 3.1415926535897932384626433832795;\n\n\treturn (sqrt(f1)*cos(2.0f*pi*f2))*u + (sqrt(f1)*sin(2.0f*pi*f2))*v + (sqrt(1.0f - f1))*up;\n}\n    \nfloat fresnel;\n\nvec3 perform_raymarching(RAY ray, bool is_diffuse_ray)\n{\n    vec4 flux = vec4(0.0);\n    vec4 mask = vec4(1.0);\n    \n    for(int bounce_count=0; bounce_count<max_bounces_per_pixel; ++bounce_count)\n    {\n        /*\n    \tfor(int j=0; j<sphere_list.length(); ++j)\n        {\n            // TODO: Use squared distance!\n            if(distance(point_on_ray, sphere_list[j].xyz) < sphere_list[j].w)\n            {\n                fragColor *= vec4(0.5, 1.0, 0.25, 1.0);\n                break;\n            }\n    \t}\n        */\n\n        RAY_TRACE_RESULT result = intersect_ray_with_world(ray);\n        if(!result.intersection_found)\n        {\n            break;\n        }\n        \n        int sphere_index = result.intersected_sphere_index;\n        vec3 point_of_intersection = ray.origin + ray.direction * result.t;\n\n        vec4 sphere_position_and_radius = get_sphere_attribute(sphere_index, SPHERE_POSITION_AND_RADIUS_COORDINATE);\n        vec4 sphere_color = get_sphere_attribute(sphere_index, SPHERE_COLOR_COORDINATE);\n        vec4 sphere_material = get_sphere_attribute(sphere_index, SPHERE_MATERIAL_COORDINATE);\n\n        SPHERE sphere;\n        sphere.position = sphere_position_and_radius.xyz;\n        sphere.radius = sphere_position_and_radius.w;\n        sphere.color = sphere_color.rgb;\n        sphere.roughness = sphere_color.a;\n\n        vec3 n_surface_normal = normalize(point_of_intersection - sphere.position);\n\n\n        if(sphere_index == 3 || sphere_index > 10 && sphere_index <= 12)\n        {\n            // TODO: Implement this as a sphere attribute:\n            vec4 sphere_radiance = vec4(25.0, 22.0, 20.0, 0.0) * 0.5;\t// TODO: Must depend on dot product!\n\n            if(sphere_index == 12)\n            {\n                sphere_radiance = vec4(100.0, 1.0, 100.0, 0.0);\n            }\n\n            if(sphere_index == 3)\n            {\n                sphere_radiance = vec4(50.0, 40.0, 30.0, 0.0) * 0.3;\n            }\n\n            flux += mask * sphere_radiance;\n        }\n\n        vec3 n_random_hemisphere_vector = get_random_vector_in_hemisphere(n_surface_normal);\n        /*\n        if(dot(n_surface_normal, n_random_hemisphere_vector) < 0.0)\n        {\n            ray.direction = get_random_vector_in_hemisphere(n_surface_normal);\n        }\n        */\n        \n        if(bounce_count == 0)\n        {\n            // TODO: This is very incorrect:\n            //fresnel = max(dot(n_surface_normal, -ray.direction), 0.0) * (sphere.roughness * 0.5 + 0.5);\n            fresnel = max(dot(n_surface_normal, -ray.direction), 0.0);\n            fresnel = mix(fresnel, 1.0, sphere.roughness); // Lerp fresnel to 1.0 (100% diffuse) for rough surfaces.\n            \n            if(sphere_material.y >= 0.5) // If metallic:\n            {\n                fresnel = 0.0;\n            }\n        }\n\n        // Calculate a new ray starting from the point of intersection:\n        if(is_diffuse_ray)\n        {\n            if(sphere_material.y < 0.5) // If not metallic:\n            {\n                mask *= sphere_color;\n            }\n\n            ray.direction = n_random_hemisphere_vector;\n            \n            \n            float lambert_term = max(dot(n_surface_normal, ray.direction), 0.0);\n            mask *= lambert_term;\n        }\n        else // Is specular ray:\n        {\n            if(sphere_material.y >= 0.5) // If metallic:\n            {\n                mask *= sphere_color;\n            }\n            \n            vec3 n_reflection = reflect(ray.direction, n_surface_normal);\n            ray.direction = mix(n_reflection, n_random_hemisphere_vector, sphere.roughness); \n            ray.direction = normalize(ray.direction);\n            \n            float specular_term = max(dot(n_reflection, ray.direction), 0.0);\n            mask *= specular_term;\n        }\n\n        // Adjust the ray position for accuracy:\n        ray.origin = point_of_intersection + n_surface_normal * 0.001;\n        \n        // Stop ray marching if this path doesn't contribute much anymore:\n        if(dot(mask, mask) < 0.1 * 0.1)\n        {\n            break;\n        }\n    }\t\n    \n    return(flux.rgb);\n\treturn(ray.origin + ray.direction);\n    return(vec3(0.0));\n}     \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\t\n    //fragColor = texelFetch(iChannel2, ivec2(fragCoord.xy), 0);\n    //return;\n    \n    // Old:\n    rng_seed = 1 + int(iResolution.x * fragCoord.y + fragCoord.x) * 17;\t// Unique number for each pixel\n    rng_seed += iFrame % 1000 * 13;\n    \n    // Initialize using blue noise texture:\n    //rng_seed = 1 + int(texelFetch(iChannel2, ivec2(fragCoord.xy), 0).x * 255.0);\n    rng_seed = 1 + int(texture(iChannel2, uv).x * 1024.0);\n    \n    rng_seed += iFrame * samples_per_pixel * max_bounces_per_pixel * 2;\n    \n\t//fragColor = texture(iChannel0, uv);\n    //fragColor = texelFetch( iChannel1, ivec2(KEY_LEFT,0), 0 ).xxxx;\n    //fragColor = texelFetch( iChannel2, ivec2(KEY_LEFT,0), 0 ).xyzw;\n    //fragColor = texture(iChannel2, uv);\n    \n    \n    vec3 camera_position = texelFetch(iChannel0, CAMERA_POSITION_COORDINATE, 0).xyz;\n    vec3 camera_rotation = texelFetch(iChannel0, CAMERA_ROTATION_COORDINATE, 0).xyz;\n    \n    mat3 view_matrix = calculate_view_matrix(camera_position, camera_rotation);\n    \n\tfloat aspect_ratio = iResolution.x / iResolution.y;\n    \n    RAY ray;\n    ray.origin = camera_position;\n    //ray.direction = normalize(view_matrix * vec3(uv * 2.0 - vec2(1.0), 1.0));\n    vec3 direction_os = vec3(uv * 1.5 - vec2(0.75), 1.0);\n    direction_os.x *= aspect_ratio;\n    ray.direction = normalize(view_matrix * direction_os);\n    ray.direction = normalize(ray.direction);\n    \n    \n    // Diffuse: ////////////////////////\n    vec3 diffuse = vec3(0.0);\n    for(int i=0; i<samples_per_pixel; ++i)\n    {\n    \tdiffuse += perform_raymarching(ray, true);\n\t}\n    diffuse /= float(samples_per_pixel);\n    \n    // Specular: ////////////////////////\n    vec3 specular = vec3(0.0);\n    for(int i=0; i<samples_per_pixel; ++i)\n    {\n    \tspecular += perform_raymarching(ray, false);\n\t}\n    specular /= float(samples_per_pixel);\n    \n    \n    \n    \n    fragColor.rgb = mix(specular, diffuse, fresnel);\n    fragColor.a = 1.0;\n    \n    // Debug code:\n    //fragColor.rgb = camera_position + ray.direction;\n    \n    vec4 previous_fragColor = texelFetch(iChannel3, ivec2(fragCoord.xy), 0);\n    fragColor = mix(fragColor, previous_fragColor, averaging_factor);\n    \n}","name":"Buffer D","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"/*\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    fragColor = texelFetch(iChannel1, ivec2(fragCoord.xy), 0);\n}\n*/\n\n\n//(#define iChannel0 iChannel1\n\n\n// Channel0 = Buffer C\n// Channel1 = Buffer A\n\n// This pass/buffer is used to update the spheres.\n\n\n//const int SPHERE_ATTRIBUTE_INDEX = 0;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0,0.0,0.0,0.0);\n    \n    //fragColor = texelFetch(iChannel1, ivec2(fragCoord.xy), 0);\n    //return;\n    \n    int sphere_index = int(fragCoord.x);\t// TODO: Round?\n    int sphere_attribute_index = int(fragCoord.y - 0.5);\t// TODO: Round?\n    \n    vec4 sphere_position_and_radius = texelFetch(iChannel0, ivec2(sphere_index, SPHERE_POSITION_AND_RADIUS_COORDINATE), 0);\n    vec3 sphere_previous_position = texelFetch(iChannel1, ivec2(sphere_index, SPHERE_POSITION_AND_RADIUS_COORDINATE), 0).xyz;\n           \n    vec3 sphere_position = sphere_position_and_radius.xyz;\n    float sphere_radius = sphere_position_and_radius.w;\n    /*\n    vec4 sphere_color = texelFetch(iChannel0, ivec2(sphere_index, SPHERE_COLOR_COORDINATE), 0);\n    vec4 sphere_material = texelFetch(iChannel0, ivec2(sphere_index, SPHERE_MATERIAL_COORDINATE), 0);\n    vec4 sphere_velocity = texelFetch(iChannel0, ivec2(sphere_index, SPHERE_VELOCITY_COORDINATE), 0);\n    */\n    vec4 sphere_color = vec4(0.0);\n    vec4 sphere_velocity = vec4(0.0);\n    \n    // Initialize simulation:\n    if(iFrame < 2)\n    {\n        vec4 sphere_material = vec4(1.0, 0.0, 0.0, 0.0);\n    \n        sphere_position_and_radius = vec4(float(sphere_index) * 3.0, 2.0, 5.0,\n                                          0.5 + abs(sin(iTime * 1.0 + float(sphere_attribute_index))));\n        \n        sphere_velocity.xyz = vec3(sin(float(sphere_attribute_index) * 13.0),\n                                   sin(float(sphere_attribute_index) * 21.0),\n                                   sin(float(sphere_attribute_index) * 13.0)) * 0.1;\n        \n        \n        if(sphere_index == 0)\t// -X wall:\n        {\n            sphere_position_and_radius = vec4(-105.0, 0.0, 0.0, 100.0);\n            sphere_velocity = vec4(0.0);\n            sphere_color = vec4(0.1, 1.0, 1.0, 0.1);\n            sphere_material = vec4(sphere_color.w, 0.0, 0.0, 0.0);\n        }  \n        else if(sphere_index == 1)\t// +X wall:\n        {\n            sphere_position_and_radius = vec4(105.0, 0.0, 0.0, 100.0);\n            sphere_velocity = vec4(0.0);\n            sphere_color = vec4(1.0, 0.1, 0.1, 0.75);\n            sphere_material = vec4(sphere_color.w, 0.0, 0.0, 0.0);\n        }  \n        else if(sphere_index == 2)\t// -Y wall:\n        {\n            sphere_position_and_radius = vec4(0.0, -105.0, 0.0, 100.0);\n            sphere_velocity = vec4(0.0);\n            sphere_color = vec4(1.0, 1.0, 1.0, 1.0);\n            sphere_material = vec4(sphere_color.w, 0.0, 0.0, 0.0);\n        }  \n        else if(sphere_index == 3)\t// +Y wall:\n        {\n            sphere_position_and_radius = vec4(0.0, 105.0, 0.0, 100.0);\n            sphere_velocity = vec4(0.0);\n            sphere_color = vec4(1.0, 1.0, 1.0, 1.0);\n            sphere_material = vec4(sphere_color.w, 0.0, 0.0, 0.0);\n        } \n        else if(sphere_index == 4)\t// -Z wall:\n        {\n            sphere_position_and_radius = vec4(0.0, 0.0, -105.0, 100.0);\n            sphere_velocity = vec4(0.0);\n            sphere_color = vec4(0.1, 1.0, 0.1, 0.75);\n            sphere_material = vec4(sphere_color.w, 0.0, 0.0, 0.0);\n        }  \n        else if(sphere_index == 5)\t// +Z wall:\n        {\n            sphere_position_and_radius = vec4(0.0, 0.0, 105.0, 100.0);\n            sphere_velocity = vec4(0.0);\n            sphere_color = vec4(0.1, 0.1, 1.0, 0.75);\n            sphere_material = vec4(sphere_color.w, 0.0, 0.0, 0.0);\n        }\n        else\n        {\n            sphere_position_and_radius = vec4(mod(float(sphere_index), 3.0) * 2.0 - 3.0 + mod(float(sphere_index), 4.0) * 0.1,\n                                              mod(float(sphere_index / 3), 3.0) * 2.0 + mod(float(sphere_index), 4.0) * 0.1,\n                                              mod(float(sphere_index / 9), 3.0) * 2.0 + mod(float(sphere_index), 4.0) * 0.1,\n                                              0.75);\n            sphere_velocity = vec4(0.0);\n            sphere_color = vec4(1.0, 1.0, 1.0, 1.0);\n            \n            sphere_material.y = step(sin(float(sphere_index) * 23.0), 0.5);\n            \n            sphere_color = vec4(1.0, 0.0, 0.0, 1.0);// TODO: Why does this do nothing?\n            \n            if(sphere_index > 45)\n            {\n                sphere_material.y = 1.0;\n            }\n        }\n\n        if(sphere_attribute_index == SPHERE_MATERIAL_COORDINATE)\n        {\n            fragColor = sphere_material;\n            return;\n        }\n    }    \n    else\n    {\n        if(sphere_attribute_index == SPHERE_MATERIAL_COORDINATE)\n        {\n            discard;\n        }\n    }\n    \n    if(sphere_index <= 5)\n    {\n        if(iFrame >= 2)\n        {\n            discard;\n        }\n            \n        if(sphere_attribute_index == SPHERE_POSITION_AND_RADIUS_COORDINATE)\n        {\n            fragColor = sphere_position_and_radius;\n        }\n        else if(sphere_attribute_index == SPHERE_VELOCITY_COORDINATE)\n        {\n            fragColor = sphere_velocity;\n        }\n        else if(sphere_attribute_index == SPHERE_COLOR_COORDINATE)\n        {\n            fragColor = sphere_color;\n        }\n\n        return;\n    }  \n    \n    if(sphere_attribute_index == SPHERE_POSITION_AND_RADIUS_COORDINATE)\n    {\n    #ifdef GRAVITY\n        /*\n        if(sphere_position_and_radius.y > 0.0)\n        {\n    \t\tsphere_position_and_radius.y -= 0.1;\n        }\n        */\n        \n        //if(sphere_position_and_radius.y > 0.0)\n        {\n    \t\tsphere_position_and_radius.y -= gravity;\n        }\n        /*\n        else\n        {\n    \t\tsphere_position_and_radius.y = 0.0;\n        }\n        */\n    \t\n        sphere_position = sphere_position_and_radius.xyz;\n        \n    #endif\n    \n        vec3 previous_position = sphere_position_and_radius.xyz;\n        \n        for(int i=0; i<SPHERE_COUNT; ++i)\n        {\n            if(i != sphere_index)\n            {\n                vec4 other_sphere_position_and_radius = texelFetch(iChannel1, ivec2(i, SPHERE_POSITION_AND_RADIUS_COORDINATE), 0);\n\n                vec3 other_sphere_to_sphere = sphere_position - other_sphere_position_and_radius.xyz;\n                float sphere_distance_squared = dot(other_sphere_to_sphere, other_sphere_to_sphere);\n                float radii_sum = other_sphere_position_and_radius.w + sphere_radius;\n                if(sphere_distance_squared < radii_sum*radii_sum)\n                {\n                    float sphere_distance = sqrt(sphere_distance_squared);\n                    float distance_to_push_apart = (radii_sum - sphere_distance) * 0.5;\n\n                    if(i < 6) // Wall and ceiling spheres:\n                    {\n                        distance_to_push_apart *= 2.0;\n                    }\n\n                    vec3 push_vector = other_sphere_to_sphere / sphere_distance * distance_to_push_apart;\n                    sphere_position += push_vector;\t// TODO: Do properly!\n                    \n                    /*\n                    vec3 push_vector = normalize(other_sphere_to_sphere) * radii_sum;\n                    vec3 center = (other_sphere_position_and_radius.xyz + sphere_position) * 0.5;\n                    sphere_position_and_radius.xyz = center + push_vector * 0.5;\n                    */\n                }\n            }\n        }   \n        \n       // sphere_position_and_radius.xyz = sphere_position;\n        sphere_position_and_radius.xyz = previous_position + (sphere_position - previous_position);\n\n        \n        \n        //sphere_position_and_radius.xyz += sphere_velocity.xyz;\n        //sphere_position_and_radius.w = 0.5 + abs(sin(iTime * 1.0 + float(sphere_attribute_index)));\n        \n        \n/*\n        for(int i=0; i<SPHERE_COUNT; ++i)\n        {\n            if(i != sphere_index)\n            {\n                vec4 other_sphere_position_and_radius = texelFetch(iChannel0, ivec2(i, SPHERE_POSITION_AND_RADIUS_COORDINATE), 0);\n\n                float sphere_distance = distance(other_sphere_position_and_radius.xyz, sphere_position);\n                float radii_sum = other_sphere_position_and_radius.w + sphere_radius;\n                if(sphere_distance < radii_sum)\n                {\n                    other_sphere_position_and_radius.xyz += (sphere_position - other_sphere_position_and_radius.xyz) / sphere_distance * radii_sum / 2.0;\t// TODO: Do properly!\n                }\n            }\n        }   \n*/\n\n\n        //sphere_position_and_radius.xyz += (sphere_position_and_radius.xyz - sphere_previous_position) * 0.2;\t// TODO: What to do here?\n\n\n        //fragColor = vec4(float(sphere_index) * 3.0, 0.0, 5.0, 0.5 + abs(sin(iTime * 1.0 + float(sphere_attribute_index))));\n        fragColor = sphere_position_and_radius;\n        //fragColor = vec4(float(sphere_index) * 3.0, 0.0, 5.0, 1.0);\n\t}\n    else if(sphere_attribute_index == SPHERE_VELOCITY_COORDINATE)\n    {\n        \n        /*\n        if(sphere_position_and_radius.y > 0.0)\n        {\n    \t\tsphere_velocity.y -= gravity;\n        }\n        else\n        {\n    \t\tsphere_velocity.y = 0.0;\n        }\n        */        \n        \n        sphere_velocity.xyz += (sphere_position - sphere_previous_position);\n        \n        sphere_velocity *= 0.98;\n        \n        fragColor = sphere_velocity;\n\t}\n    else if(sphere_attribute_index == SPHERE_COLOR_COORDINATE)\n    {\n        //fragColor = vec4(abs(sin(iTime * 0.01)));\n        //fragColor = vec4(0.5);\n        fragColor = vec4(abs(sin(float(sphere_index) * 13.0)) * 0.75,\n                         abs(sin(float(sphere_index) * 21.0)) * 0.75,\n                         abs(sin(float(sphere_index) * 17.0)) * 0.75,\n                         1.0) + vec4(0.25);\n        //fragColor = vec4(1.0, 0.0, 0.0, 1.0);\n        \n        float roughness = 1.0;\t// TODO: Make this a sphere parameter!\n        if((sphere_index >= 16)&&(sphere_index <= 19))\n        {\n            roughness = 0.0;\n        }\n        if(sphere_index > 19) \n        {\n            roughness = 0.5;\n        }\n            \n        fragColor.a = roughness;\n        fragColor.a = abs(sin(float(sphere_index) * 13.0));\n        \n        if(sphere_index > 45)\n        {\n            fragColor.a = 0.0;\n        }\n\t}\n}\n\n\n\n\n\n/*\n\n// This pass/buffer does the collision detection and response between the spheres.\n\n//const int SPHERE_ATTRIBUTE_INDEX = 0;\n\nconst int SPHERE_COUNT = 30;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    \n    int sphere_index = int(fragCoord.x);\t// TODO: Round?\n    int sphere_attribute_index = int(fragCoord.y - 0.5);\t// TODO: Round?\n    \n    vec4 sphere_position_and_radius = texelFetch(iChannel0, ivec2(sphere_index, SPHERE_POSITION_AND_RADIUS_COORDINATE), 0);\n                   \n    vec3 sphere_position = sphere_position_and_radius.xyz;\n    float sphere_radius = sphere_position_and_radius.w;\n    vec4 sphere_color = texelFetch(iChannel0, ivec2(sphere_index, SPHERE_COLOR_COORDINATE), 0);\n    vec4 sphere_velocity = texelFetch(iChannel0, ivec2(sphere_index, SPHERE_VELOCITY_COORDINATE), 0);\n        \n    fragColor = sphere_velocity;\n    \n    \n    if(sphere_attribute_index == SPHERE_POSITION_AND_RADIUS_COORDINATE)\n    {\n\n        //if(sphere_position_and_radius.y > 0.0)\n        //{\n    \t//\tsphere_position_and_radius.y -= 0.1;\n        //}\n        \n        sphere_position_and_radius.xyz += sphere_velocity.xyz;\n        //sphere_position_and_radius.w = 0.5 + abs(sin(iTime * 1.0 + float(sphere_attribute_index)));\n        \n\n        //fragColor = vec4(float(sphere_index) * 3.0, 0.0, 5.0, 0.5 + abs(sin(iTime * 1.0 + float(sphere_attribute_index))));\n        fragColor = sphere_position_and_radius;\n        //fragColor = vec4(float(sphere_index) * 3.0, 0.0, 5.0, 1.0);\n\t}\n    else if(sphere_attribute_index == SPHERE_VELOCITY_COORDINATE)\n    {\n        //if(sphere_position_and_radius.y > 0.0)\n        //{\n    \t//\tsphere_velocity.y -= 0.01;\n        //}\n        //else\n        //{\n    \t//\tsphere_velocity.y = 0.0;\n        //}\n        \n        sphere_velocity *= 0.98;\n        \n        fragColor = sphere_velocity;\n\t}\n    else if(sphere_attribute_index == SPHERE_COLOR_COORDINATE)\n    {\n        fragColor = vec4(1.0, 0.0, 0.0, 1.0);\n        //discard;\n\t}\n    \n    //fragColor = sphere_velocity;\n}\n\n*/","name":"Buffer C","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Copy C to A so A contains the old position like in verlet integration.\n    fragColor = texelFetch(iChannel1, ivec2(fragCoord.xy), 0);\n}\n\n/*\n// This pass/buffer is used to update the spheres.\n\nconst float gravity = 0.01;\n\n// Sphere attribute coordinates (X = sphere index, Y = sphere attribute):\nconst int SPHERE_POSITION_AND_RADIUS_COORDINATE = 0;\nconst int SPHERE_VELOCITY_COORDINATE = 1;\nconst int SPHERE_COLOR_COORDINATE = 2;\t// TODO: RENAME TO \"SPHERE_COLOR_AND_ROUGHNESS_COORDINATE\"\n\n//const int SPHERE_ATTRIBUTE_INDEX = 0;\n//const int SPHERE_COLOR_COORDINATE = 1;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0,0.0,0.0,0.0);\n    \n    //fragColor = texelFetch(iChannel1, ivec2(fragCoord.xy), 0);\n    //return;\n    \n    int sphere_index = int(fragCoord.x);\t// TODO: Round?\n    int sphere_attribute_index = int(fragCoord.y - 0.5);\t// TODO: Round?\n    \n    vec4 sphere_position_and_radius = texelFetch(iChannel0, ivec2(sphere_index, SPHERE_POSITION_AND_RADIUS_COORDINATE), 0);\n             \n    vec3 sphere_position = sphere_position_and_radius.xyz;\n    float sphere_radius = sphere_position_and_radius.w;\n    \n    vec4 sphere_color = texelFetch(iChannel0, ivec2(sphere_index, SPHERE_COLOR_COORDINATE), 0);\n    vec4 sphere_velocity = texelFetch(iChannel0, ivec2(sphere_index, SPHERE_VELOCITY_COORDINATE), 0);\n       \n    \n    // Initialize simulation:\n    if(iTime < 0.1)\n    {\n        sphere_position_and_radius = vec4(float(sphere_index) * 3.0, 2.0, 5.0,\n                                          0.5 + abs(sin(iTime * 1.0 + float(sphere_attribute_index))));\n        \n        sphere_velocity.xyz = vec3(sin(float(sphere_attribute_index) * 13.0),\n                                   sin(float(sphere_attribute_index) * 21.0),\n                                   sin(float(sphere_attribute_index) * 13.0)) * 0.1;\n        \n        \n        if(sphere_index == 0)\t// -X wall:\n        {\n            sphere_position_and_radius = vec4(-105.0, 0.0, 0.0, 100.0);\n            sphere_velocity = vec4(0.0);\n            sphere_color = vec4(1.0, 0.0, 0.0, 1.0);\n        }  \n        else if(sphere_index == 1)\t// +X wall:\n        {\n            sphere_position_and_radius = vec4(105.0, 0.0, 0.0, 100.0);\n            sphere_velocity = vec4(0.0);\n            sphere_color = vec4(0.5, 0.0, 0.0, 1.0);\n        }  \n        else if(sphere_index == 2)\t// -Y wall:\n        {\n            sphere_position_and_radius = vec4(0.0, -105.0, 0.0, 100.0);\n            sphere_velocity = vec4(0.0);\n            sphere_color = vec4(1.0, 1.0, 1.0, 1.0);\n        }  \n        else if(sphere_index == 3)\t// +Y wall:\n        {\n            sphere_position_and_radius = vec4(0.0, 105.0, 0.0, 1.0);\n            sphere_velocity = vec4(0.0);\n            sphere_color = vec4(0.0, 0.5, 0.0, 1.0);\n        } \n        else if(sphere_index == 4)\t// -Z wall:\n        {\n            sphere_position_and_radius = vec4(0.0, 0.0, -105.0, 100.0);\n            sphere_velocity = vec4(0.0);\n            sphere_color = vec4(0.0, 0.0, 1.0, 1.0);\n        }  \n        else if(sphere_index == 5)\t// +Z wall:\n        {\n            sphere_position_and_radius = vec4(0.0, 0.0, 105.0, 100.0);\n            sphere_velocity = vec4(0.0);\n            sphere_color = vec4(0.0, 0.0, 0.5, 1.0);\n        }\n        else\n        {\n            sphere_position_and_radius = vec4(mod(float(sphere_index), 3.0) * 2.0,\n                                              mod(float(sphere_index / 3), 3.0) * 2.0,\n                                              mod(float(sphere_index / 9), 3.0) * 2.0,\n                                              1.0);\n            sphere_velocity = vec4(0.0);\n            sphere_color = vec4(1.0, 1.0, 1.0, 1.0);\n        }\n    }    \n    \n    if(sphere_index == 10)\n    {\n        if(sphere_attribute_index =-= SPHERE_POSITION_AND_RADIUS_COORDINATE)\n        {\n            fragColor = sphere_position_and_radius;\n            fragColor.w = 10.0;\n        }\n        else if(sphere_attribute_index == SPHERE_VELOCITY_COORDINATE)\n        {\n            fragColor = sphere_velocity;\n        }\n        else if(sphere_attribute_index == SPHERE_COLOR_COORDINATE)\n        {\n            fragColor = sphere_color;\n        \tfragColor = vec4(1.0, 0.0, 0.0, 1.0);\n        }\n\n        return;\n    }  \n    \n    if(sphere_index <= 5)\n    {\n        if(sphere_attribute_index =-= SPHERE_POSITION_AND_RADIUS_COORDINATE)\n        {\n            fragColor = sphere_position_and_radius;\n        }\n        else if(sphere_attribute_index == SPHERE_VELOCITY_COORDINATE)\n        {\n            fragColor = sphere_velocity;\n        }\n        else if(sphere_attribute_index == SPHERE_COLOR_COORDINATE)\n        {\n            fragColor = sphere_color;\n        \tfragColor = vec4(1.0, 0.0, 0.0, 1.0);\n        }\n\n        return;\n    }  \n    \n    if(sphere_attribute_index == SPHERE_POSITION_AND_RADIUS_COORDINATE)\n    {\n        //if(sphere_position_and_radius.y > 0.0)\n        //{\n    \t//\tsphere_position_and_radius.y -= 0.1;\n        //}\n        \n        sphere_position_and_radius.xyz += sphere_velocity.xyz;\n        //sphere_position_and_radius.w = 0.5 + abs(sin(iTime * 1.0 + float(sphere_attribute_index)));\n        \n\n        //fragColor = vec4(float(sphere_index) * 3.0, 0.0, 5.0, 0.5 + abs(sin(iTime * 1.0 + float(sphere_attribute_index))));\n        fragColor = sphere_position_and_radius;\n        //fragColor = vec4(float(sphere_index) * 3.0, 0.0, 5.0, 1.0);\n\t}\n    else if(sphere_attribute_index == SPHERE_VELOCITY_COORDINATE)\n    {\n        \n        if(sphere_position_and_radius.y > 0.0)\n        {\n    \t\tsphere_velocity.y -= gravity;\n        }\n        else\n        {\n    \t\tsphere_velocity.y = 0.0;\n        }\n                \n        sphere_velocity *= 0.98;\n        \n        fragColor = sphere_velocity;\n\t}\n    else if(sphere_attribute_index == SPHERE_COLOR_COORDINATE)\n    {\n        //fragColor = vec4(abs(sin(iTime * 0.01)));\n        //fragColor = vec4(0.5);\n        fragColor = vec4(abs(sin(float(sphere_attribute_index) * 13.0)) * 0.75,\n                         abs(sin(float(sphere_attribute_index) * 21.0)) * 0.75,\n                         abs(cos(float(sphere_attribute_index) * 13.0)) * 0.75,\n                         0.0) + vec4(0.25);\n        \n        \n        float roughness = 1.0;\t// TODO: Make this a sphere parameter!\n        if((sphere_index >= 16)&&(sphere_index <= 19))\n        {\n            roughness = 0.0;\n        }\n        if(sphere_index > 19) \n        {\n            roughness = 0.5;\n        }\n        \n        fragColor.a = roughness;\n        \n        fragColor = vec4(1.0, 0.0, 0.0, 1.0);\n\t}\n}\n*/","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// Updates the object positions\n\n// Channel0 = keyboard\n// Channel1 = Buffer B\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    \n    bool key_left_pressed = texelFetch( iChannel0, ivec2(KEY_LEFT, 0), 0 ).x > 0.5;\n    bool key_right_pressed = texelFetch( iChannel0, ivec2(KEY_RIGHT, 0), 0 ).x > 0.5;\n    bool key_up_pressed = texelFetch( iChannel0, ivec2(KEY_UP, 0), 0 ).x > 0.5;\n    bool key_down_pressed = texelFetch( iChannel0, ivec2(KEY_DOWN, 0), 0 ).x > 0.5;\n    bool key_control_pressed = texelFetch( iChannel0, ivec2(KEY_CONTROL, 0), 0 ).x > 0.5;\n    bool key_space_pressed = texelFetch( iChannel0, ivec2(KEY_SPACE, 0), 0 ).x > 0.5;\n    \n    vec3 camera_position_offset = vec3(0.0);\n    \n    if(key_left_pressed)\n    {\n        camera_position_offset.x -= camera_speed;\n        //fragColor = vec4(1.0);\n    }\n    \n    if(key_right_pressed)\n    {\n        camera_position_offset.x += camera_speed;\n        //fragColor = vec4(0.0, 1.0, 0.0, 1.0);\n    }\n    \n    if(key_up_pressed)\n    {\n        camera_position_offset.y += camera_speed;\n        //fragColor = vec4(1.0, 0.0, 0.0, 1.0);\n    }\n    \n    if(key_down_pressed)\n    {\n        camera_position_offset.y -= camera_speed;\n        //fragColor = vec4(0.0, 0.0, 1.0, 1.0);\n    }\n    \n    ivec2 pixel_coordinate = ivec2(fragCoord - vec2(0.5));\n    \n    if(pixel_coordinate == CAMERA_POSITION_COORDINATE)\n    {\n        //fragColor = vec4(1.0, 0.0, 1.0, 1.0);\n        //fragColor = vec4(camera_position_offset, 1.0);\n    \tvec3 camera_rotation = texelFetch(iChannel1, CAMERA_ROTATION_COORDINATE, 0).xyz;\n\n        mat3 view_matrix = calculate_view_matrix(vec3(0.0), camera_rotation);\n        vec3 movement_vector = view_matrix[2];\n          \n        float speed = camera_speed;\n        \n        // Move forward and back:\n        if(!key_up_pressed)\n        {\n            speed = 0.0;\n        }\n        \n        if(key_down_pressed)\n        {\n            speed = -camera_speed;\n        }\n\n        vec3 camera_position = texelFetch(iChannel1, CAMERA_POSITION_COORDINATE, 0).xyz;\n        vec3 new_camera_position = camera_position;\n        \n\t\tnew_camera_position += movement_vector * speed;\n        \n        if(key_control_pressed)\n        {\n            new_camera_position.y -= camera_speed;\n        }\n\n        if(key_space_pressed)\n        {\n            new_camera_position.y += camera_speed;\n        }\n\n        \n        // Move sideways:\n        vec3 movement_vector_sideways = vec3(cos(camera_rotation.y),\n                                             0.0,\n                                             sin(camera_rotation.y));\n\n        if(key_left_pressed)\n        {\n            new_camera_position -= movement_vector_sideways * camera_speed;\n        }\n\t\telse if(key_right_pressed)\n        {\n            new_camera_position += movement_vector_sideways * camera_speed;\n        }\n\n        \n        if(iTime < 0.1)\t// Initialization:\n        {\n            new_camera_position = vec3(0.0, 0.0, -3.0);\n        } \n            \n        //fragColor = vec4(camera_position + camera_position_offset, 1.0);\n        fragColor = vec4(new_camera_position, 1.0);\n        //fragColor = vec4(camera_position_offset, 1.0);\n    }\n    else if(pixel_coordinate == CAMERA_ROTATION_COORDINATE)\n    {\n        /*\n    \tvec4 mouse_coordinates = iMouse / iResolution.xyxy;\n        \n        vec2 mouse_offset = mouse_coordinates.xy - mouse_coordinates.zw;\n        \n    \tvec3 camera_rotation = texelFetch(iChannel1, CAMERA_ROTATION_COORDINATE, 0).xyz;\n        fragColor = vec4(camera_rotation + vec3(mouse_offset.x, mouse_offset.y, 0.0), 1.0);\n        */\n        \n        \n        \n    \tvec3 camera_rotation = texelFetch(iChannel1, CAMERA_ROTATION_COORDINATE, 0).xyz;\n        \n\t\t\n        if(key_left_pressed)\n        {\n            camera_rotation.y += 0.1;\n        }\n\n        if(key_right_pressed)\n        {\n            camera_rotation.y -= 0.1;\n        }\n        \n        camera_rotation.yx = -iMouse.xy * mouse_speed;\n        \n            \n        fragColor = vec4(camera_rotation, 1.0);\n    }\n    /*\n    else if(pixel_coordinate == MOUSE_PREVIOUS_COORDINATE)\n    {\n    \tvec3 mouse_coordinates = texelFetch(iChannel1, MOUSE_PREVIOUS_COORDINATE, 0).xyz;\n        fragColor = vec4(iMouse / iResolution.xyxy, 0.0, 1.0);\n    }\n    */\n    \n    \n\n        \n/*\n    \tvec3 camera_position = texelFetch(iChannel1, CAMERA_POSITION_COORDINATE, 0).xyz;\n        fragColor = vec4(camera_position + camera_position_offset, 1.0);\n*/\n    //vec3 camera_position = texelFetch(iChannel1, CAMERA_POSITION_COORDINATE, 0).xyz;\n    //fragColor = vec4(camera_position + camera_position_offset, 1.0);\n    //fragColor = vec4(camera_position_offset, 1.0);\n\n    //bool key_left_pressed = texelFetch( iChannel0, ivec2(KEY_LEFT,0), 0 ).x > 0.5;\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"// 2022.03.16: Added various small improvements (tone mapping, RNG, blue noise, performance, visuals, physics).\n\n\n// User settings: //////////////////////////\nconst int samples_per_pixel = 4;\nconst int max_bounces_per_pixel = 6;\nconst float averaging_factor = 0.5;\n\nconst float camera_speed = 0.1;\nconst float mouse_speed = 0.02;\n\nconst float gravity = 0.2;\n#define GRAVITY\n\nconst int KEY_LEFT  = 65;\nconst int KEY_UP    = 87;\nconst int KEY_RIGHT = 68;\nconst int KEY_DOWN  = 83;\nconst int KEY_CONTROL  = 17;\nconst int KEY_SPACE  = 32;\n////////////////////////////////////////////\n\nconst float gamma = 2.2;\nconst float PI = 3.1415926535897932384626433832795;\n\nconst int SPHERE_COUNT = 50;\n// Sphere attribute coordinates (X = sphere index, Y = sphere attribute):\nconst int SPHERE_POSITION_AND_RADIUS_COORDINATE = 0;\nconst int SPHERE_VELOCITY_COORDINATE = 1;\nconst int SPHERE_COLOR_COORDINATE = 2;\n\n// X = roughness\n// Y = metallic\nconst int SPHERE_MATERIAL_COORDINATE = 3;\n\nconst ivec2 CAMERA_POSITION_COORDINATE = ivec2(10, 10);\nconst ivec2 CAMERA_ROTATION_COORDINATE = ivec2(11, 10);\nconst ivec2 MOUSE_PREVIOUS_COORDINATE = ivec2(12, 10);\n\n\nvec3 to_linear_space(vec3 color)\n{\n\treturn(pow(color, vec3(gamma)));  \n}\n\nfloat to_linear_space(float color)\n{\n\treturn(pow(color, gamma));  \n}\n\nvec3 to_gamma_space(vec3 color)\n{\n\treturn(pow(color, vec3(1.0 / gamma)));\n}\n\nfloat to_gamma_space(float color)\n{\n\treturn(pow(color, 1.0 / gamma));\n}\n\nvec3 tonemap(vec3 color)\n{\n\treturn(color / (1.0 + color));\n}\n\n\n\n\n\n// ACES tone mapping curve fit to go from HDR to LDR\n//https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/\nvec3 ACESFilm(vec3 x)\n{\n    float a = 2.51;\n    float b = 0.03;\n    float c = 2.43;\n    float d = 0.59;\n    float e = 0.14;\n    return clamp((x*(a*x + b)) / (x*(c*x + d) + e), 0.0, 1.0);\n}\n\n// Modified version of the above, that produces less harsh tone mapping.\nvec3 ACESFilmModified(vec3 x)\n{\n    float a = 1.5;\n    float b = 0.03;\n    float c = 0.45;\n    float d = 1.0;\n    float e = 0.1;\n    return clamp((x*(a*x + b)) / (x*(c*x + d) + e), 0.0, 1.0);\n}\n\n// https://github.com/TheRealMJP/BakingLab/blob/master/BakingLab/ACES.hlsl\nconst mat3 ACESInputMat = mat3(\n    vec3(0.59719, 0.35458, 0.04823),\n    vec3(0.07600, 0.90834, 0.01566),\n    vec3(0.02840, 0.13383, 0.83777)\n);\n\n// ODT_SAT => XYZ => D60_2_D65 => sRGB\nmat3 ACESOutputMat = mat3(\n    vec3( 1.60475, -0.53108, -0.07367),\n    vec3(-0.10208,  1.10813, -0.00605),\n    vec3(-0.00327, -0.07276,  1.07602)\n);\n\nvec3 RRTAndODTFit(vec3 v)\n{\n    vec3 a = v * (v + 0.0245786) - 0.000090537;\n    vec3 b = v * (0.983729 * v + 0.4329510) + 0.238081;\n    return a / b;\n}\n\nvec3 ACESFitted(vec3 color)\n{\n    color = (transpose(ACESInputMat) * color);\n\n    // Apply RRT and ODT\n    color = RRTAndODTFit(color);\n\n    color = (transpose(ACESOutputMat) * color);\n\n    // Clamp to [0, 1]\n    color = clamp(color, 0.0, 1.0);\n\n    return(color);\n}\n\n\n\n\nmat3 calculate_view_matrix(vec3 camera_position, vec3 camera_rotation)\n{\n    mat3 view_matrix = mat3(1.0, 0.0, 0.0,\n                            0.0, 1.0, 0.0,\n                            0.0, 0.0, 1.0);\n    \n    // X axis:\n    view_matrix[0][0] = cos(camera_rotation.y);\n    view_matrix[0][1] = 0.0;\n    view_matrix[0][2] = sin(camera_rotation.y);\n    \n    // Y axis:\n    view_matrix[1][0] = 0.0;\n    view_matrix[1][1] = 1.0;\n    view_matrix[1][2] = 0.0;\n    \n    // Z axis:\n    view_matrix[2][0] = cos(camera_rotation.y + 1.5707963267948966192313216916398);\n    view_matrix[2][1] = 0.0;\n    view_matrix[2][2] = sin(camera_rotation.y + 1.5707963267948966192313216916398);\n    \n    /*\n    // X axis:\n    view_matrix[0][0] *= sin(camera_rotation.x);\n    view_matrix[0][1] = 0.0;\n    view_matrix[0][2] *= sin(camera_rotation.x);\n    */\n    \n    /*\n    // Y axis:\n    view_matrix[1][0] *= cos(camera_rotation.x);\n    view_matrix[1][1] *= cos(camera_rotation.x);\n    view_matrix[1][2] *= cos(camera_rotation.x);\n    \n    // Z axis:\n    view_matrix[2][0] *= cos(camera_rotation.x);\n    view_matrix[2][1] *= cos(camera_rotation.x);\n    view_matrix[2][2] *= cos(camera_rotation.x);\n    */\n    \n    camera_rotation.x += PI;\n    camera_rotation.x = -camera_rotation.x;\n    camera_rotation.x = clamp(camera_rotation.x, -PI * 0.5, PI * 0.5);\n\n    \n    \n    \n    // Source: https://en.wikipedia.org/wiki/Rotation_matrix\n    mat3 rotation_matrix_x = mat3(1.0, 0.0, 0.0,\n                                  0.0, cos(camera_rotation.x), -sin(camera_rotation.x),\n                                  0.0, sin(camera_rotation.x), cos(camera_rotation.x));\n    \n    mat3 rotation_matrix_y = mat3(cos(camera_rotation.y), 0.0, sin(camera_rotation.y),\n                                0.0, 1.0, 0.0,\n                                -sin(camera_rotation.y), 0.0, cos(camera_rotation.y));\n    \n    mat3 rotation_matrix_z = mat3(cos(camera_rotation.z), -sin(camera_rotation.z), 0.0,\n                                sin(camera_rotation.z), cos(camera_rotation.z), 0.0,\n                                0.0, 0.0, 1.0);\n    \n    view_matrix = view_matrix * rotation_matrix_x;\n    //view_matrix = rotation_matrix_x * view_matrix;\n    /*\n    view_matrix[0] = normalize(view_matrix[0]);\n    view_matrix[1] = normalize(view_matrix[1]);\n    view_matrix[2] = normalize(view_matrix[2]);\n    */\n    \n    return(view_matrix);\n} ","name":"Common","description":"","type":"common"}]}