{"ver":"0.1","info":{"id":"XdlBRH","date":"1494860827","viewed":954,"name":"Basic edge detection","username":"VB","description":"answering: http://stackoverflow.com/questions/43977910/edge-outline-detection-from-texture-in-fragment-shader","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["basicedgedetection"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xsf3Rn","filepath":"/media/a/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png","previewfilepath":"/media/ap/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png","type":"texture","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    // need a *6.0 for U since initial texture contains a strip of 6 images\n    vec2 uvTex = vec2(uv.x/6.0, uv.y);\n    \n    // compute the steps to read neighbor pixel\n    // note the * 6.0 for U\n    float step_u = 1.0/(iResolution.x*6.0); \n    float step_v = 1.0/iResolution.y; \n        \n    // color at current pixel\n    vec4 cCenter = texture(iChannel0, uvTex);\n    \n    // color of right pixel\n    vec4 cRight = texture(iChannel0, uvTex + vec2(step_u, 0.0));\n    \n    // color of bottom pixel\n    vec4 cBottom = texture(iChannel0, uvTex + vec2(0.0, step_v));\n    \n    // compute derivatives manually\n    float _dFdx = length(cCenter-cRight) / step_u;\n    float _dFdy = length(cCenter-cBottom) / step_v;\n    \n    // show initial image, at 40% brightness\n    fragColor = vec4(cCenter.rgb*0.4, cCenter.a);\n    \n    // add derivatives color\n    fragColor.r += _dFdx;\n    fragColor.g += _dFdy;    \n}","name":"Image","description":"","type":"image"}]}