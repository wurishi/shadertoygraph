{"ver":"0.1","info":{"id":"WtyGDy","date":"1579739590","viewed":1812,"name":"Infinite procedural editor grid","username":"jesusdz","description":"Just a shader that paints a procedural grid on the floor plane. Useful for 3D engine/scene editors.","likes":7,"published":1,"flags":48,"usePreview":0,"tags":["procedural","grid","editor"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define TILE_SIZE 1.0\n#define LINE_WIDTH 1.0\n\n#define ANTIALIASED_LINES 0\n\n// gives the grid lines alpha factor\nfloat grid(in vec2 uv)\n{\n    vec2 grid = vec2(0.0);\n    float line = 0.0;\n    \n    for (int i = 0; i < 3; ++i)\n    {\n#if ANTIALIASED_LINES == 1\n    \t// antialiased lines\n    \tgrid = 1.0 * abs(mod(uv + 0.5*TILE_SIZE, TILE_SIZE * pow(10.0, float(i))) - 0.5) / fwidth(uv) / LINE_WIDTH;\n    \tline = max(line, pow(4.0, float(i)) * (1.0 - min(min(grid.x, grid.y), 1.0)));\n#else\n    \t// almost pixel-perfect lines\n    \tgrid = 1.0 * fwidth(uv)/mod(uv, pow(10.0, float(i)));\n    \tline = max(line, pow(4.0, float(i)) * step(1.0/LINE_WIDTH, max(grid.x, grid.y)));\n#endif\n    }\n    \n    return line;\n}\n\n// intersection with floor plane\nbool iFloor(in vec3 ro, in vec3 rd, out float t)\n{\n    float floor_y = -1.5;\n    t = (floor_y - ro.y) / rd.y;\n    return t > 0.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // Normalized pixel coordinates (from -1 to 1)\n    vec2 nuv = -1.0 + 2.0 * uv;\n    nuv.x *= iResolution.x / iResolution.y; // aspect ratio correction\n\n    // Camera -> world matrix\n    vec3 obs = getValueAt(INDEX_POSITION).xyz;\n    vec3 vrp = obs + getValueAt(INDEX_DIRECTION).xyz;\n    vec3 up = vec3(0.0, 1.0, 0.0);\n    vec3 ww = normalize(obs - vrp);\n    vec3 uu = cross(up, ww);\n    vec3 vv = cross(ww, uu);\n    \n    // Ray origin / direction in world space\n   \tvec3 ro = obs;\n    vec3 rd = uu * nuv.x + vv * nuv.y - ww * 2.8;\n    \n    // Background color\n    vec3 topColor = vec3(0.4);\n    vec3 botColor = vec3(0.1);\n    vec3 col = mix(botColor, topColor, smoothstep(-0.05, 0.1, rd.y));\n    \n    float t;\n    if (iFloor(ro, rd, t))\n    {\n        vec3 floorPos = ro + t*rd;\n        vec2 uv = floorPos.xz;\n        \n        float alpha = grid(uv);\n        \n        alpha = min(1.0, alpha/(t*t)); // distance attenuation\n        \n        col = mix(col, vec3(1.0), alpha);\n    }\n    \n    col = sqrt(col);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\n#define ACCEL     30.0\n#define MAX_SPEED 10.0\n\nvec3 getAcceleration()\n{\n    vec3 acc = vec3(0.0, 0.0, 0.0);\n    \n    acc.z += texelFetch(iChannel1, ivec2(83, 0), 0).x;\n    acc.z -= texelFetch(iChannel1, ivec2(87, 0), 0).x;\n    acc.x += texelFetch(iChannel1, ivec2(68, 0), 0).x;\n    acc.x -= texelFetch(iChannel1, ivec2(65, 0), 0).x;\n    \n    if (length(acc) > 0.1)\n    {\n        acc = normalize(acc);\n    }\n    \n    return acc;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Discard fragments not in the first row of pixels\n    if (fragCoord.y >= 1.0)\n    {\n        discard;\n    }\n    \n    int index = int(fragCoord.x);\n    \n    vec2 q = vec2(fragCoord.x, 0.0) / iResolution.xy;\n    vec2 bs = fragCoord.xy;\n    vec4 value = vec4(0.0);\n    \n    if (index == INDEX_ROTATION)\n    {\n       \tvalue = getValueAt(INDEX_ROTATION);\n        \n        if (iMouse.z > 0.0) // interacting\n        {\n        \tvec4 mouse = 2.0 * iMouse / iResolution.y;\n        \tvec4 rot = getValueAt(INDEX_ROTATION_BACKUP);\n        \n        \tvalue.x = mouse.z - mouse.x + rot.x;\n        \tvalue.y = mouse.y - mouse.w + rot.y;\n        \n            value.x = mod(value.x, 2.0 * PI);\n        \tvalue.y = clamp(value.y, -PI / 2.01, PI / 2.01);\n        }\n    }\n    else if (index == INDEX_ROTATION_BACKUP)\n    {\n        value = getValueAt(INDEX_ROTATION_BACKUP);\n        \n        if (iMouse.z < 0.0) // not interacting\n        {\n        \tvalue = getValueAt(INDEX_ROTATION);\n        }\n    }\n    else if (index == INDEX_DIRECTION)\n    {\n        vec2 rotation = getValueAt(INDEX_ROTATION).xy;\n        vec3 direction = vec3(\n            sin(rotation.x)*cos(rotation.y),\n            sin(rotation.y),\n            cos(rotation.x)*cos(rotation.y)\n        );\n        value = vec4(direction, 0.0);\n    }\n    else if (index == INDEX_POSITION)\n    {   \n        value = getValueAt(INDEX_POSITION);\n        \n        vec4 speed = getValueAt(INDEX_SPEED);\n        value += speed * iTimeDelta;\n    }\n    else if (index == INDEX_SPEED)\n    {\n        value = getValueAt(INDEX_SPEED);\n        \n        vec3 accel = getAcceleration();\n        \n        if (dot(accel, accel) > 0.01)\n        {\n            vec3 direction = getValueAt(INDEX_DIRECTION).xyz;\n            vec3 ww = normalize(-direction);\n            vec3 uu = cross(vec3(0.0, 1.0, 0.0), ww);\n            vec3 vv = cross(ww, uu);\n            accel = mat3(uu, vv, ww) * accel;\n            value.xyz += ACCEL * accel * iTimeDelta;\n            \n            float absSpeed = abs(length(value.xyz));\n            if (absSpeed > MAX_SPEED)\n            {\n                value.xyz *= MAX_SPEED / absSpeed;\n            }\n        }\n        else\n        {\n        \tvalue *= 0.9;\n        }\n    }\n    \n    fragColor = vec4(value);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define INDEX_POSITION        (0)\n#define INDEX_DIRECTION       (1)\n#define INDEX_SPEED           (2)\n#define INDEX_ROTATION        (3)\n#define INDEX_ROTATION_BACKUP (4)\n\nvec4 _getValueAt(in sampler2D texData, in vec2 texDataSize, int index)\n{\n    return texelFetch(texData, ivec2(index, 0), 0);\n}\n\n#define getValueAt(index) _getValueAt(iChannel0, iResolution.xy, index)\n\n#define PI 3.14159265359\n","name":"Common","description":"","type":"common"}]}