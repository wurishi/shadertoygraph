{"ver":"0.1","info":{"id":"XcjXzy","date":"1706513355","viewed":112,"name":"RayMarch SDF Sphere Animation","username":"shadowzhg","description":"You can intuitively compare the results obtained by Ray Marching with each forward step and the performance cost incurred as the step count increases. ","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raymarch","sdf","sphere","plan"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const vec2 sphereXY = vec2(0.0, 1.0);\nconst float sphereDist = 3.0;\nconst float sphereRadius = 1.0;\nconst vec3 CameraPos = vec3(0.0, 1.0, 0.0);\nconst float surfaceDist = 0.01;\nconst float farDist = 128.0;\nconst float planHeight = 0.0;\n\nconst float stepNum = 32.0;//在进行stepNum步后重新开始\nconst float PlaySpeed = 2.0;\n\n\nvec4 SpherePos = vec4(sphereXY.xy,sphereDist,sphereRadius);\n\nint setBgColor = 1;//是否修改背景颜色\nfloat BGMask = 0.0;\nvec3 backGroundColor = vec3(0.15, 0.15, 0.2);\n\nfloat SDFSphere(vec3 pos){\n    return length(pos.xyz - SpherePos.xyz) - SpherePos.w;\n}\n\n//第一种计算平面的方法\nfloat SDFPlan(vec3 pos){\n    \n    float plan = 0.0;\n    if(pos.y < planHeight){\n        return 1.0;\n    }\n    else{\n        return pos.y;\n    }\n}\n\n//第二种计算平面的方法\nfloat SDFPlan02(vec3 pos){\n    \n    return dot(pos.xyz, vec3(0.0, 1.0, 0.0)) + planHeight;\n}\n\nfloat GetDir(vec3 pos){\n    return min(SDFPlan(pos),SDFSphere(pos));\n}\n\nfloat RayMarch(vec3 CameraDir){\n    float currentDist = 0.0;\n    \n\n    for(float i; i< mod(iTime * PlaySpeed,stepNum * PlaySpeed); i++){\n    \n        vec3 pos = CameraPos + CameraDir * currentDist;\n        float DistScene = GetDir(pos);\n        currentDist += DistScene;\n        \n        if(currentDist > farDist || DistScene < surfaceDist){\n            break;\n        }\n    }\n    \n    if(currentDist < 10.0 && setBgColor == 1){\n        BGMask = 1.0;\n    }\n\n    return currentDist;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord / iResolution.xy;\n    uv -= 0.5;\n    uv *= 2.0;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    vec3 cameraDir = vec3(uv.xy,1.0);\n\n    vec3 col = RayMarch(cameraDir) / 9.0 * vec3(1.0, 1.0, 1.0);\n    \n    if(setBgColor == 1){\n        col = mix(backGroundColor,col,BGMask);\n    }\n    \n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}