{"ver":"0.1","info":{"id":"Ds2SD3","date":"1671009610","viewed":109,"name":"SimpleRayTracingTemplate","username":"ShadingKnight","description":"a template shader for ray tracing experiment.","likes":1,"published":1,"flags":48,"usePreview":0,"tags":["raytracing","template"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 toneMapAces(vec3 color)\n{\n    float A = 2.51;\n    float B = 0.03;\n    float C = 2.43;\n    float D = 0.59;\n    float E = 0.14;\n\n    color = (color*(A*color+B))/(color*(C*color+D)+E);\n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    vec4 data = texelFetch( iChannel0, ivec2(fragCoord), 0 );\n    vec3 res = data.xyz / data.w;\n    \n    float exposure = 0.0;\n    res = pow(2.0, exposure) * res;\n    res = toneMapAces(res);\n    res = linearToSRGB(res);\n    \n    fragColor = vec4(res, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define store(P, V) if (all(equal(ivec2(fragCoord), P))) fragColor = V\n#define load(P) texelFetch(iChannel1, ivec2(P), 0)\n#define key(K)  step(0.5, texelFetch(iChannel0, ivec2(K, 0), 0).x)\n\n#define M_E  2.71828182846\n#define M_PI 3.14159265359\n\nstruct Ray\n{\n    vec3 origin;\n    vec3 dir;\n};\n\nstruct Sphere\n{\n    vec3 center;\n    float radius;\n};\n\nstruct Camera \n{\n    vec3  lookfrom;\n    vec3  lookat;    \n    vec3  vup;          \n    float vfov;\n    float aspect;\n    float focus;\n};\n\nbool intersectRaySphere(vec3 rayOrigin, vec3 rayDir, vec3 sphereCenter, float sphereRadius, out float t0, out float t1)\n{\n    // Implementation is taken from Chapter 7 of Ray-Tracing Gems\n    vec3 f = rayOrigin - sphereCenter;\n    float a = dot(rayDir, rayDir);\n    float b = dot(-f, rayDir);\n    float discriminant = sphereRadius * sphereRadius - dot(f + b / a * rayDir, f + b / a * rayDir);\n\n    // Negative discriminant means ray missed sphere.\n    if (discriminant < 0.f) \n    {\n        return false;\n    }\n\n    if (b == 0.0 && discriminant == 0.0)\n    {\n        t0 = 0.0;\n        t1 = 0.0;\n        return true;\n    }\n\n    // There are two solutions t0 and t1, but one or both may be negative.\n    float c = dot(f, f) - sphereRadius * sphereRadius;\n    float signB = (b < 0.0) ? -1.0 : 1.0;\n    float q = b + signB * sqrt(a * discriminant);\n    \n    t0 = c / q;\n    t1 = q / a;\n    if (t0 > t1)\n    {\n        float tmp = t0;\n        t0 = t1;\n        t1 = tmp;\n    }\n    \n    float tc = t0 < 0.f ? t1 : t0; // tc is the closest hit we care about\n    if (tc < 0.f) \n    {\n        return false;\n    }\n\n    return true;\n}\n\nbool intersectRaySphere(vec3 rayOrigin, vec3 rayDir, vec3 sphereCenter, float sphereRadius, out float t)\n{\n    float t0;\n    float t1;\n    if (!intersectRaySphere(rayOrigin, rayDir, sphereCenter, sphereRadius, t0, t1))\n    {\n        return false;\n    }\n    \n    float tc = t0 < 0.f ? t1 : t0; // tc is the closest hit we care about\n    if (tc < 0.f) \n    {\n        return false;\n    }\n\n    t = tc;\n    return true;\n}\n\nvec2 directionToEquirectUV(vec3 normalizedDirection)\n{\n    float elevation = asin(normalizedDirection.y);\n    float azimuth = 0.0;\n    if (abs(normalizedDirection.y) < 1.0)\n        azimuth = atan(normalizedDirection.z, normalizedDirection.x);\n\n    vec2 uv;\n    uv.x = azimuth / (2.0 * M_PI) - 0.25;\n    uv.y = 0.5 - elevation / M_PI;\n\n    return uv;\n}\n\nvec3 sampleSphere(vec2 u)\n{\n    float phi = 2.0f * M_PI * u.y;\n    float cosTheta = 1.0f - 2.0f * u.x;\n    float sinTheta = sqrt(max(0.0f, 1.0f - cosTheta * cosTheta));\n    return vec3(sinTheta * cos(phi), sinTheta * sin(phi), cosTheta);\n}\n\nfloat linearToSRGB(float lin)\n{\n    if (lin <= 0.0031308f)\n    {\n        return lin * 12.92f;\n    }\n    else\n    {\n        return pow(lin, (1.0f / 2.4f)) * (1.055f) - 0.055f;\n    }\n}\n\nvec3 linearToSRGB(vec3 lin)\n{\n    return vec3(\n        linearToSRGB(lin.x),\n        linearToSRGB(lin.y),\n        linearToSRGB(lin.z));\n}\n\nfloat sRGBToLinear(float srgb)\n{\n    if (srgb <= 0.04045f)\n    {\n        return srgb * (1.0f / 12.92f);\n    }\n    else\n    {\n        return pow((srgb + 0.055f) * (1.0f / 1.055f), 2.4f);\n    }\n}\n\nvec3 sRGBToLinear(vec3 srgb)\n{\n    return vec3(\n        sRGBToLinear(srgb.x),\n        sRGBToLinear(srgb.y),\n        sRGBToLinear(srgb.z));\n}\n\n///////////////////////////////////////////////\n//                Free Camera\n// from https://www.shadertoy.com/view/ddSSWy\n// Modification: add dirty flag.\n///////////////////////////////////////////////\nconst ivec2 MEMORY_BOUNDARY = ivec2(4, 3);\n\nconst ivec2 POSITION = ivec2(1, 0);\n\nconst ivec2 VMOUSE = ivec2(1, 1);\nconst ivec2 PMOUSE = ivec2(2, 1);\nconst ivec2 DIRTY = ivec2(2, 2);\n\nconst ivec2 TARGET = ivec2(0, 2);\n\nconst ivec2 RESOLUTION = ivec2(3, 1);\nconst ivec2 SPACE = ivec2(4, 1);\n\nmat3 CameraRotation( vec2 m ) {\n    m.y = -m.y;\n    \n    vec2 s = sin(m);\n    vec2 c = cos(m);\n    mat3 rotX = mat3(1.0, 0.0, 0.0, 0.0, c.y, s.y, 0.0, -s.y, c.y);\n    mat3 rotY = mat3(c.x, 0.0, -s.x, 0.0, 1.0, 0.0, s.x, 0.0, c.x);\n    \n    return rotY * rotX;\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Created by genis sole - 2016\n// License Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International.\n\n// Keyboard constants definition\nconst int KEY_BSP   = 8;\nconst int KEY_SP    = 32;\nconst int KEY_LEFT  = 37;\nconst int KEY_UP    = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN  = 40;\nconst int KEY_A     = 65;\nconst int KEY_B     = 66;\nconst int KEY_C     = 67;\nconst int KEY_D     = 68;\nconst int KEY_E     = 69;\nconst int KEY_F     = 70;\nconst int KEY_G     = 71;\nconst int KEY_H     = 72;\nconst int KEY_I     = 73;\nconst int KEY_J     = 74;\nconst int KEY_K     = 75;\nconst int KEY_L     = 76;\nconst int KEY_M     = 77;\nconst int KEY_N     = 78;\nconst int KEY_O     = 79;\nconst int KEY_P     = 80;\nconst int KEY_Q     = 81;\nconst int KEY_R     = 82;\nconst int KEY_S     = 83;\nconst int KEY_T     = 84;\nconst int KEY_U     = 85;\nconst int KEY_V     = 86;\nconst int KEY_W     = 87;\nconst int KEY_X     = 88;\nconst int KEY_Y     = 89;\nconst int KEY_Z     = 90;\nconst int KEY_COMMA = 188;\nconst int KEY_PER   = 190;\n\nvec3 KeyboardInput() {\n\tvec3 i = vec3(key(KEY_D) - key(KEY_A), \n                  key(KEY_E) - key(KEY_Q),\n                  key(KEY_S) - key(KEY_W));\n    \n    float n = abs(abs(i.x) - abs(i.y));\n    return i * (n + (1.0 - n)*inversesqrt(2.0));\n}\n\nvec3 CameraDirInput(vec2 vm) {\n    vec2 m = vm/iResolution.x;\n    \n    return CameraRotation(m) * KeyboardInput();\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {   \n    if (any(greaterThan(ivec2(fragCoord), MEMORY_BOUNDARY))) return;\n    \n    fragColor = load(fragCoord);\n    \n    vec2 resolution = load(RESOLUTION).xy;\n    store(RESOLUTION, vec4(iResolution.xy, 0.0, 0.0));\n    store(SPACE, vec4(key(KEY_SP)));\n    \n    if (iTime == 0.0 || iFrame == 0 || any(notEqual(iResolution.xy, resolution))) {\n        store(POSITION, vec4(0.0, 0.0, 4.0, 0.0));\n        store(TARGET, vec4(0.0, -0.2, 4.0, 0.0));\n        store(VMOUSE, vec4(0.0));\n        store(PMOUSE, vec4(0.0));\n        \n        return;\n    }\n\n    vec3 target      = load(TARGET).xyz;   \n    vec3 position    = load(POSITION).xyz;\n    vec2 pm          = load(PMOUSE).xy;\n    vec3 vm          = load(VMOUSE).xyz;\n    \n    bool dirty = false;\n    \n    vec3 ptarget = target;\n    vec3 cameraInput = CameraDirInput(vm.xy);\n    if (length(cameraInput) > 0.05)\n    {\n        dirty = true;\n    }\n    \n    target += cameraInput * iTimeDelta * 15.0;\n    \n    position += (target - position) * iTimeDelta * 15.0;\n    \n    store(TARGET, vec4(target, 0.0));\n    store(POSITION, vec4(position, 0.0));\n    \n\tif (iMouse.z > 0.0) \n    {\n        dirty = true;\n    \tstore(VMOUSE, vec4(pm + (abs(iMouse.zw) - iMouse.xy), 1.0, 0.0));\n\t}\n    else if (vm.z != 0.0) \n    {\n    \tstore(PMOUSE, vec4(vm.xy, 0.0, 0.0));\n    }\n    \n    if (dirty)\n    {\n        store(DIRTY, vec4(1.0));\n    }\n    else\n    {\n        store(DIRTY, vec4(0.0));\n    }\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"int   seed = 1;\n\nint   rand(void) \n{ \n    seed = seed*0x343fd+0x269ec3; \n    return (seed>>16)&32767; \n}\n\nfloat frand(void) \n{ \n    return float(rand())/32767.0; \n}\n\nvec2 frand2(void) \n{\n    return vec2(frand(), frand());\n}\n\nvoid  srand( ivec2 p, int frame )\n{\n    int n = frame;\n    n = (n<<13)^n; n=n*(n*n*15731+789221)+1376312589; // by Hugo Elias\n    n += p.y;\n    n = (n<<13)^n; n=n*(n*n*15731+789221)+1376312589;\n    n += p.x;\n    n = (n<<13)^n; n=n*(n*n*15731+789221)+1376312589;\n    seed = n;\n}\n\n// from https://www.shadertoy.com/view/ddSSWy\nRay GetPrimaryRay(vec2 fragCoord)\n{\n    vec2 pixelSize = 1.0 / iResolution.xy;\n    vec2 uv = fragCoord * pixelSize;\n    \n    vec3 lookfrom  = load(POSITION).xyz;\n    vec3 direction = CameraRotation(load(VMOUSE).xy * pixelSize) * vec3(0, 0, -1);\n    vec3 lookat    = lookfrom + direction;\n    \n    Camera c;\n    c.lookfrom = lookfrom;\n    c.lookat   = lookat;\n    c.aspect   = pixelSize.y/pixelSize.x;\n    c.vfov     = 30.0;\n    c.vup      = vec3(0, 1, 0);\n    c.focus    = 2.0;\n    \n    float theta = radians(c.vfov);\n    float half_height = tan(theta * 0.5);\n    float half_width = c.aspect * half_height;\n    \n    vec3 z = normalize(c.lookfrom - c.lookat);\n    vec3 x = normalize(cross(c.vup, z));\n    vec3 y = cross(z, x);\n    \n    vec3 hwfx = half_width  * c.focus * x;\n    vec3 hhfy = half_height * c.focus * y;\n    \n    vec3 lower_left_corner = c.lookfrom - hwfx - hhfy - c.focus * z;\n    \n    vec3 horizontal = 2.0 * hwfx;\n    vec3 vertical   = 2.0 * hhfy;\n    \n    vec3 ro = c.lookfrom;\n    vec3 po = lower_left_corner + uv.x * horizontal\n                                + uv.y * vertical;\n    vec3 rd = normalize(po - ro);\n    \n    Ray ray;\n    ray.origin = ro;\n    ray.dir = rd;\n    \n    return ray;\n}\n\nfloat beerLambert(float dist, float sigma)\n{\n    return exp(-dist * sigma);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    // init randoms\n    srand( ivec2(fragCoord), iFrame );\n    \n    vec3 res = vec3(0.0);\n    Ray ray = GetPrimaryRay(fragCoord);\n    \n    vec3 backgroundCol = sRGBToLinear(texture(iChannel0, ray.dir).xyz);\n    \n    Sphere sphere;\n    sphere.center = vec3(0.25, -0.75, -0.75);\n    sphere.radius = 2.2;\n    vec3 sphereCol = vec3(0.4, 0.5, 0.6);\n    float sigma = 0.1;\n    \n    float tranmission = 1.0f;\n    float t0; \n    float t1;\n    if (intersectRaySphere(ray.origin, ray.dir, sphere.center, sphere.radius, t0, t1))\n    {\n        float dist = abs(t0 - t1);\n        int sampleNum = 8;\n        float stepSize = dist / float(sampleNum);\n        for (int i = 0; i < sampleNum; i++)\n        {\n            // Ray Marching\n            tranmission *= beerLambert(stepSize, sigma);\n            vec3 sampleOrigin = ray.origin + (float(i) * stepSize + 0.5f * stepSize) * ray.dir;\n            vec3 sampleDir = sampleSphere(frand2());\n            float lightDist = 0.0f;\n            if (intersectRaySphere(sampleOrigin, sampleDir, sphere.center, sphere.radius, lightDist))\n            {\n                float lightAttenuation = beerLambert(lightDist, sigma);\n                vec3 lightIntensity = 5.0f * sRGBToLinear(texture(iChannel0, sampleDir).xyz);\n                res += tranmission * lightAttenuation * lightIntensity * 4.0 * M_PI * stepSize;\n            }\n        }\n\n        res += tranmission * backgroundCol;\n    }\n    else\n    {\n        res = backgroundCol;\n    }\n     \n    vec4 data = texelFetch( iChannel2, ivec2(fragCoord), 0 );\n    if(iFrame == 0 || load(DIRTY).x > 0.5) \n    {\n        data = vec4(0.0);\n    }\n    data += vec4(res, 1.0);\n    fragColor = data;\n}","name":"Buffer B","description":"","type":"buffer"}]}