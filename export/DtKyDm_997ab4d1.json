{"ver":"0.1","info":{"id":"DtKyDm","date":"1700305285","viewed":103,"name":"2024 Year","username":"Efim","description":"3D text example","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["sdf","text","font"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14159265359\n#define TAU 6.283185\n#define nn 128\n#define rot2(a)      mat2(cos(a), -sin(a), sin(a), cos(a)) \nconst float dist_infin = 4.0;\nconst float eps = 0.01;\n\nvec3 csky(vec3 p)\n{\n    return texture(iChannel1, p).rgb;\n}\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n    \n}\n\n//https://www.shadertoy.com/view/mlcyDj\nvec4 texChar(float char, vec2 uv) {\n    vec2 pt = uv/16.0;\n    pt.x += char/16.0;\n    pt.y += 12.0/16.0;\n    return texture(iChannel0, pt);\n}\n\nfloat sdTextBox ( vec2 p, vec2 b, float char ) {\n    float l = sdBox(p,b);\n    vec2 pn = (p.xy / b.xy) * .5 + .5;\n    float lt = (texChar(char, pn).w - 0.5);\n    return max(lt,l); \n}\n//===========================================\n\nfloat sdBox3( in vec3 p, in vec2 b, float h, float char)\n{\n    float d = sdTextBox(p.xy, b, char);\n    vec2 w = vec2( d, abs(p.z) - h );\n    return min(max(w.x,w.y),0.0) + length(max(w,0.0)) - 0.02;\n}\n\nfloat map( in vec3 pos, float char )\n{\n    return sdBox3(pos, vec2(1., 1.), 0.2, char);\n    \n}\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal( in vec3 pos, float char )\n{\n    const float h = 0.0001; // replace by an appropriate value\n    const vec2 k = vec2(1,-1);\n    return normalize( k.xyy*map(pos + k.xyy*h, char ) + \n                      k.yyx*map(pos + k.yyx*h, char ) + \n                      k.yxy*map(pos + k.yxy*h, char ) + \n                      k.xxx*map(pos + k.xxx*h, char ) );\n}\n\nfloat steps(vec3 ro, vec3 rd, float char)\n{\n    float t  = 0.;\n    for (int i = 0; i < nn; i++)\n    {\n        vec3 pos = ro + rd*t;\n        float h = map(pos, char);\n        if (h < eps || t >= dist_infin)\n            break;\n        t += h;  \n    }    \n\n    if (t >= dist_infin)\n        return dist_infin;\n    return t;    \n}\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 \n        f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u;\n    return normalize(i);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float t = iTime ;\n    vec3 ro = vec3(0.0, 0.0, 2.5); // camera\n    vec2 m = cos(.3*t + vec2(.3,.3));\n    if  (iMouse.z > 0.0)\n        m = (-iResolution.xy + 2.0*(iMouse.xy))/iResolution.y;\n    \n    ro.yz *= rot2(m.y*PI); \n    ro.xz *= rot2(-m.x*TAU);\n    \n    const float fl = 1.5; // focal length\n    vec3 tot = vec3(0.0);\n    const float[] text = float[](2., 0., 2., 4.); \n    \n    #define AA 2\n    //antiblick\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        float dist = dist_infin;\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n        vec3 rd = GetRayDir(p, ro, vec3(0,0.,0), fl); //ray direction\n        vec3 col = vec3(0.5, 0.5, 1.);//csky(rd);\n        vec3 shift = vec3(2.5, 0., 0.);\n        vec3 sh = vec3(0.0);\n        float shx = 1.0;\n        vec3 nor = vec3(0.);\n        float char = 6.;\n        \n        for (int i = 0; i < 4; i++)\n        {\n            shift.x -= shx;\n            float giper = steps((ro + shift), rd, text[i]);\n            if (giper < dist)\n            {\n                dist = giper;\n                char = text[i];\n                sh = shift;\n            }\n        }\n        \n        if (dist < dist_infin)\n        {\n            vec3 pos = (ro + sh) + dist*rd;\n            vec3 nor = calcNormal(pos, char);\n            col = csky(reflect(rd,normalize(nor)));\n        }\n\t    tot += col;\n    }\n    //antiblick\n    tot /= float(AA*AA);\n    fragColor = vec4(tot,1.0);\n    \n}","name":"Image","description":"","type":"image"}]}