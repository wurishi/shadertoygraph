{"ver":"0.1","info":{"id":"llGGDK","date":"1476747454","viewed":469,"name":"trefoil","username":"halcy","description":"some displacement also","likes":12,"published":1,"flags":96,"usePreview":0,"tags":["music","sync"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define DO_BLUR 1\n\n// blur with hexagonalish sampling pattern\n// weighs samples according to depth (so that \"in focus\" samples count for less)\n// and according to tap nb (weighs outer samples higher)\nvec3 hexablur(sampler2D tex, vec2 uv) {\n    vec2 scale = vec2(1.0) / iResolution.xy;\n    vec3 col = vec3(0.0);\n    float asum = 0.0;\n    float coc = texture(iChannel0, uv).a;\n    for(float t = 0.0; t < 8.0 * 2.0 * 3.14; t += 3.14 / 32.0) {\n    \tfloat r = cos(3.14 / 6.0) / cos(mod(t, 2.0 * 3.14 / 6.0) - 3.14 / 6.0);\n        \n        // Tap filter once for coc\n        vec2 offset = vec2(sin(t), cos(t)) * r * t * scale * coc;\n        vec4 samp = texture(tex, uv + offset * 1.0);\n        \n        // Tap filter with coc from texture\n        offset = vec2(sin(t), cos(t)) * r * t * scale * samp.a;\n        samp = texture(tex, uv + offset * 1.0);\n        \n        // weigh and save\n        col += samp.rgb * samp.a * t; \n        asum += samp.a * t;\n        \n    }\n    col = col / asum;\n    return(col);\n}\n\n// Blur image from buffer\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 coords = (2.0 * fragCoord.xy  - iResolution.xy) / max(iResolution.x, iResolution.y);\n    if(DO_BLUR == 1) {\n\t\tfragColor = vec4(hexablur(iChannel0, uv), 0.0);\n    }\n    else {\n        fragColor = texture(iChannel0, uv);\n    }\n    fragColor = fragColor * clamp(mod(fragCoord.y + 1.5 * fragCoord.x, 5.0), 0.7, 1.0) * (1.2 - pow(length(coords), 4.0));\n\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XdfGRn","filepath":"/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","previewfilepath":"/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dX3zn","filepath":"/media/a/550a8cce1bf403869fde66dddf6028dd171f1852f4a704a465e1b80d23955663.png","previewfilepath":"/media/ap/550a8cce1bf403869fde66dddf6028dd171f1852f4a704a465e1b80d23955663.png","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"ls2Gzm","filepath":"https://soundcloud.com/maslyastar/capsule-the-music","previewfilepath":"https://soundcloud.com/maslyastar/capsule-the-music","type":"musicstream","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Various knobs to twiddle\n#define MIN_DIST 0.01\n#define STEP_MULTIPLIER 0.9\n#define NORMAL_OFFSET 0.01\n#define MAX_STEPS 64\n#define MAX_STEPS_SHADOW 64\n#define SHADOW_OFFSET 0.02\n#define SHADOW_HARDNESS 128.0\n#define RAY_FUZZ 0.003\n\n// Palette helper\nvec3 color(float inVal) {\n\tvec3 a = vec3(0.5, 0.5, 0.5);\n\tvec3 b = vec3(0.5, 0.5, 0.5);\n\tvec3 c = vec3(1.0, 1.0, 0.5);\n\tvec3 d = vec3(0.8, 0.9, 0.3);\n\treturn(a + b * cos(6.28318 * (c * inVal + d)));\n}\n\n// For fuzzing up rays a little\nvec3 hash33(vec3 p){ \n    float n = sin(dot(p, vec3(7, 157, 113)));    \n    return fract(vec3(2097152, 262144, 32768)*n); \n}\n\n// Trefoil knot positions\n// hard to do implicitly, lets cheat.\nvec3 trefoil(float t) {\n\treturn vec3(\n        sin(t) + 2.0 * sin(2.0 * t),\n        cos(t) - 2.0 * cos(2.0 * t),\n        -sin(3.0 * t)\n    );\n}\n\n// Distance / color combiner\nvec4 distcompose(vec4 dista, vec4 distb, float softness) {\n    float mixfact = clamp(0.5 + 0.5 * (distb.a - dista.a) / softness, 0.0, 1.0);\n    return mix(distb, dista, mixfact) - vec4(0.0, 0.0, 0.0, softness * mixfact * (1.0 - mixfact));\n}\n\n// World\nvec4 distfunc(vec3 pos) {\n  \tvec4 box = vec4(0.0);\n    float boxlights = pow(texture(iChannel2, pos.xy + vec2(pos.z)).r * 2.0, 6.0);\n    box.xyz = color(pos.z / 10.0) * 0.3 + vec3(boxlights);\n    box.a = min(min(pos.y, -abs(pos.z) + 2.0), -abs(pos.x) + 2.0);;\n    \n    vec4 dist = box;\n    \n    for(int i = 0; i < 64; i++) {\n        vec3 spherecenter = vec3(0.0, 1.0, 0.0) + trefoil(3.14 * 2.0 * float(i) / 64.0) * 0.2;\n        vec4 sphere = vec4(0.0);\n        float muspos = mod(iTime * 0.03 * 0.25 * float(i) / 64.0, 0.25);\n        float rad = pow(texture(iChannel1, vec2(muspos, 0.0)).r, 5.0);\n        vec3 texdir = normalize(pos - spherecenter) +\n                      vec3(cos(2.0 * 3.14 * (float(i) / 64.0 + iTime * 0.3)));\n        sphere.xyz = color(texture(iChannel0, normalize(texdir)).r);\n        sphere.a = length(pos - spherecenter) - (0.04 + 0.15 * rad) - (sphere.z * 0.05);\n        \n        dist = distcompose(dist, sphere, 0.13);\n    }\n    \n    return(dist);\n}\n\n// Renderer\nvec4 pixel(vec2 fragCoord) {\n    // Screen -1 -> 1 coordinates\n    vec2 coords = (2.0 * fragCoord.xy  - iResolution.xy) / max(iResolution.x, iResolution.y);\n    \n    // Set up time dependent stuff\n    vec3 lightpos = vec3(cos(iTime * 1.7), 1.5, sin(iTime * 1.7));\n    float wobble = sin(iTime * 0.2) * 4.8;\n    \n    // Camera as eye + imaginary screen at a distance\n    vec3 eye = vec3(sin(wobble) * -1.75, 1.4 + cos(iTime * 0.3), cos(wobble) * -1.75);\n    vec3 lookat = vec3(0.0, 1.0, 0.0);\n    vec3 lookdir = normalize(lookat - eye);\n    vec3 left = normalize(cross(lookdir, vec3(0.0, 1.0, 0.0)));\n    vec3 up = normalize(cross(left, lookdir));\n    vec3 lookcenter = eye + lookdir;\n\tvec3 pixelpos = lookcenter + coords.x * left + coords.y * up;\n    vec3 ray = normalize(pixelpos - eye);\n    ray += hash33(ray) * RAY_FUZZ;\n    \n    // March\n    vec3 pos = eye;\n    float dist = 0.0;\n    float curdist = 1.0;\n    float iters = float(MAX_STEPS);\n    for(int i = 0; i < MAX_STEPS; i++) {\n        curdist = distfunc(pos).a;\n        dist += curdist * STEP_MULTIPLIER;\n        pos = eye + ray * dist;\n        if(curdist < MIN_DIST) {\n        \titers = float(i);\n            break;\n        }\n    }\n    \n\t// Finite-difference normals\n   \tvec2 d = vec2(NORMAL_OFFSET, 0.0);\n    vec3 normal = normalize(vec3(\n        distfunc(pos + d.xyy).a - distfunc(pos - d.xyy).a,\n        distfunc(pos + d.yxy).a - distfunc(pos - d.yxy).a,\n        distfunc(pos + d.yyx).a - distfunc(pos - d.yyx).a\n    ));\n    \n    // Offset from surface\n    vec3 shadowstart = eye + ray * dist + normal * SHADOW_OFFSET;\n    vec3 shadowpos = shadowstart;\n    \n    // Shadow ray\n    vec3 shadowray = normalize(lightpos - pos);\n    float shadowdist = length(lightpos - pos);\n    float penumbra = 1.0;\n    dist = 0.0;\n    for(int i = 0; i < MAX_STEPS_SHADOW; i++) {\n        curdist = distfunc(shadowpos).a;\n\t\tdist += curdist * STEP_MULTIPLIER;        \n        shadowpos = shadowstart + shadowray * dist;\n        \n        if(curdist < MIN_DIST) {\n            penumbra = 0.0;\n            break;\n        }\n        \n        penumbra = min(penumbra, SHADOW_HARDNESS * curdist / dist);\n        if(dist >= shadowdist) {;\n        \tbreak;   \n        }\n        \n        if(i == MAX_STEPS_SHADOW - 1) {\n        \tpenumbra = 0.0;   \n        }\n        \n    }\n    \n    // Shading\n    float light = max(0.0, dot(normal, shadowray)) * penumbra + 0.1;\n    vec3 itershade = vec3(iters / float(MAX_STEPS));\n    vec3 colorval = (light + itershade * 0.1) * distfunc(pos).rgb + itershade * 0.3;\n    \n    // \"Post-processing\"\n    float depth = length(pos - eye);\n    vec4 fragColor = vec4(colorval.xyz, 0.0);\n    float coc = 0.4 * abs(1.0 - length(eye - lookat) / depth);    \n    return(vec4(fragColor.rgb,  max(0.01, min(0.35, coc))));\n}\n\n// Image\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    fragColor = pixel(fragCoord);\n}","name":"Buf A","description":"","type":"buffer"}]}