{"ver":"0.1","info":{"id":"stcyzS","date":"1660018423","viewed":161,"name":"flight of the octahedra","username":"vivavolt","description":"raymarching but doing it wrong","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["spheres","raymarcher"],"hasliked":0,"parentid":"NtXXzN","parentname":"a few spheres"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define max_iters 500\nfloat max_dist = 1000.0;\nvec3 bg_col = vec3(0.8, 0.8, 1.0);\nvec3 fg_col = vec3(1.0, 1.0, 0.6);\n\n/**\n * Rotation matrix from angles\n */\nmat3 rotateX(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(1, 0, 0),\n        vec3(0, c, s),\n        vec3(0, -s, c)\n    );\n}\nmat3 rotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, 0, s),\n        vec3(0, 1, 0),\n        vec3(-s, 0, c)\n    );\n}\n\n//the signed distance field function\n//used in the ray march loop\nfloat sdf(vec3 p, float r) {\n    //a sphere of radius 1.\n    return length( p ) - r;\n}\n\nfloat sdOctahedron( vec3 p, float s)\n{\n  p = abs(p);\n  return (p.x+p.y+p.z-s)*0.57735027;\n}\n\n\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nvec3 pal_col(in float t) {\n\nreturn pal( t, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.0,0.10,0.20) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n//1 : retrieve the fragment's coordinates\n\tvec2 uv = ( fragCoord.xy / iResolution.xy ) * 2.0 - 1.0;\n\t//preserve aspect ratio\n\tuv.x *= iResolution.x / iResolution.y;\n\n    vec3 camera_pos = vec3(50. - iTime * 2.0, 50. + iTime * 1.5, 50. + iTime);\n    vec3 camera_dir = vec3(0.5, 0.5, 0.5);\n\n//2 : camera position and ray direction\n\tvec3 pos = camera_pos;\n\tvec3 dir = camera_dir*.5 * normalize( vec3( uv, 3.0 ) );\n\n    vec2 mos = (iMouse.xy / iResolution.xy) - vec2(0.5);\n    //pos = rotateY(iTime / 6.0) * pos;\n    dir = rotateY(mos.x * 3.0) * rotateX(mos.y * 3.0) * dir;\n    \n//3 : ray march loop\n    //ip will store final color\n\tvec3 col = pal_col(iTime / 100.);\n\n\t//variable step size\n\tfloat t = 0.0;\n\n\tfor(int i = 0; i < max_iters; i++) {\n        //update position along path\n        vec3 ip = pos + dir * t;\n\n        //gets the shortest distance to the scene\n        float m = 16.0;\n        ip = abs(mod(ip, m) - m*0.5);\n\t\tfloat d = sdOctahedron( ip, 2.5 * abs(sin(iTime + float(i))));\n\n        //break the loop if the distance was too small\n        //this means that we are close enough to the surface\n        if (d < 0.01) {\n            float a = float(i) / float(max_iters);\n            float diffuse = dot(ip, vec3(0.6, 0.8, 0.0))*0.5 + 0.5;\n            \n            // colour based on depth\n            col = pal_col( a*10. + iTime / 10.);\n            break;\n        }\n\n\t\t//increment the step along the ray path\n\t\tt += d;\n\n        //break if too far\n        if (t > max_dist) {\n            break;\n        }\n\t}\n        \n\n//4 : apply color to this fragment\n\tfragColor = vec4(col, 1.0);\n\n}","name":"Image","description":"","type":"image"}]}