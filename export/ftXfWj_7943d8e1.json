{"ver":"0.1","info":{"id":"ftXfWj","date":"1651434637","viewed":132,"name":"Mandala (Twitch)","username":"rimina","description":"Shader from my live shader coding stream from 1st of May 2022. I was exploring something with limiting myself to use only spheres, one color (ok sure, there are shades) besides black and white, negated color and space folding in kaleidoscopic way. ","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","kaleidoscope"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Copyright 2022 rimina.\n// All rights to the likeness of the visuals reserved.\n\n// Any individual parts of the code that produces the visuals is\n// available in the public domain or licensed under the MIT license,\n// whichever suits you best under your local legislation.\n\n// This is to say: you can NOT use the code as a whole or the visual\n// output it produces for any purposes without an explicit permission,\n// nor can you remix or adapt the work itself without a permission.*\n// You absolutely CANNOT mint any NFTs based on the Work or part of it.\n// You CAN however use any individual algorithms or parts of the Code\n// for any purpose, commercial or otherwise, without attribution.\n\n// *(In practice, for most reasonable requests, I will gladly grant\n//   any wishes to remix or adapt this work :))\n\n//Huge thanks to the live coding community,\n//I've learned so much from you, e.g. the glow trick!!!\n\nconst float E = 0.001;\nconst float FAR = 150.0;\nconst int STEPS = 64;\n\nvec3 glow = vec3(0.0);\n\nfloat sphere(vec3 p, float r){\n    return length(p)-r;\n}\n\nvoid rot(inout vec2 p, float a){\n    p = cos(a)*p + sin(a)* vec2(p.y, -p.x);\n}\n\nfloat scene(vec3 p){\n    vec3 pp = p;\n\n    float safe = sphere(pp, 23.0);\n\n    float center = sphere(pp, 19.0);\n\n    for(int i = 0; i < 7; ++i){\n        pp = abs(pp)-vec3(0., 5., 1.0);\n        rot(pp.xy, iTime*0.1);\n        pp = abs(pp)-vec3(0., 0.7, 7.0);\n        rot(pp.xy, iTime*0.05);\n        pp = abs(pp)-vec3(0.0, 7.0, 0.5);\n        rot(pp.zy, iTime*0.01);\n    }\n\n    float caleidos = sphere(pp, 7.);\n\n    glow += vec3(0.5) * 0.01 / (abs(caleidos) + 0.01);\n    glow += vec3(0.5) * 0.001 /(abs(center) + 0.01);\n\n    caleidos = max(caleidos, 0.9);\n\n    return min(center, max(caleidos, -safe));\n}\n\nfloat march(vec3 ro, vec3 rd){\n    float t = E;\n    vec3 p = ro;\n    for(int i = 0; i < STEPS; ++i){\n        float d = scene(p);\n        t += d;\n        p = ro + rd * t;\n\n        if(d < E || t > FAR){\n          break;\n        }\n    }\n    return t;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 q = -1.0 + 2.0*uv;\n    q.x *= iResolution.x/iResolution.y;\n\n    vec3 ro = vec3(0.0, 0.25, 100.0);\n    vec3 rt = vec3(0.0, 0.0, -1.0);\n\n    vec3 z = normalize(rt-ro);\n    vec3 x = normalize(cross(z, vec3(0.0, 1.0, 0.0)));\n    vec3 y = normalize(cross(x, z));\n\n    vec3 rd = normalize(mat3(x,y,z) * vec3(q, 1.0/radians(90.0)));\n\n    float t = march(ro, rd);\n    vec3 p = ro + rd * t;\n\n    vec3 col = vec3(0.0, 0.0, 0.01);\n    if(t < FAR){\n        col = vec3(0.1, 0.5, 1.0)*100.0*(1.0/t);\n    }\n\n    col += glow;\n    col = 1.0 - col;\n    \n    //In the original shader there is heavy motion blurr\n    //vec3 prev = texture(texPreviousFrame, uv).rgb;\n    //col = mix(col, prev, 0.9);\n\n    col = smoothstep(-0.2, 1.2, col);\n  \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}