{"ver":"0.1","info":{"id":"mlVcWD","date":"1700255119","viewed":40,"name":"mandelbrot_set_ordo","username":"ordo","description":"Mandelbrot set","likes":0,"published":1,"flags":16,"usePreview":0,"tags":["mandelbrot"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec2 mandel_scale(vec2 uv);\nfloat scale_f(float val, vec2 in_range, vec2 out_range);\n\nconst vec2 x_scale = vec2(-2.00, 0.47);\nconst vec2 y_scale = vec2(-1.12, 1.12);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 color = vec3(0.0,0.0,0.0);\n    \n    vec2 scaled = mandel_scale(fragCoord);\n    // scaled.x /= iTime;\n    // scaled.y /= iTime;\n    \n    // kinda moves\n    // scaled.x -= (iMouse.x / iResolution.x);\n    // scaled.y -= (iMouse.y / iResolution.y);\n    \n    // kinda zooms\n    //scaled *= (iMouse.x / iResolution.x)*3.;\n    //scaled /= (iTime);\n    \n    \n    // moves it to look at a branch\n    // for movement, try store global pos,\n    // or just program it to zoom into a bulb thing forever\n    // scaled.x -= 1.401;\n    // scaled.y += 0.5;\n\n    float x = 0.0;\n    float y = 0.0;\n    float tmp = 0.0;\n    \n    int iter_max = 800;\n    int i = 0;\n    for(; i < iter_max; i++){\n        // premature optimisation, try this later\n        // float xsq = x*x;\n        // float ysq = y*y;\n        \n\n        // shaders are bad at conditional logic (sometimes)\n        // might be a better way\n        if (x*x + y*y > 4.0){\n            break;\n        }\n        \n        tmp = x*x - y*y + scaled.x;\n        y = 2.0 * x * y + scaled.y;\n        x = tmp;\n    }\n   \n   \n    // i that ranges from 0 to 1\n    float i_norm = ((float(i))/float(iter_max));\n    \n    float fi = float(i);\n    //vec2 i_scale = vec2(0.0,1000.0);\n    vec2 uv_scale = vec2(0.0,1.0);\n\n    \n    if(i<iter_max){\n        color.r = i_norm * fi/2.0;\n        color.g = i_norm * fi/2.0;\n        color.b = i_norm * fi;\n    }\n    float f_max = float(iter_max);\n    float val = (f_max - fi) / f_max;\n    if(i<10){\n        color.b = val*0.10;\n    }\n    \n    \n    \n    fragColor = vec4(color,1.0);\n}\n\n// doesn't really need to be a function\n// i just think it looks better\nvec2 mandel_scale(vec2 uv){\n    \n    return vec2(\n        scale_f(uv.x, vec2(0.5, iResolution.x),x_scale),\n        scale_f(uv.y, vec2(0.5, iResolution.y),y_scale)\n    );\n}\n\nfloat scale_f(float val, vec2 in_range, vec2 out_range){\n    // this is jank, i know\n    float in_min, in_max, out_min, out_max;\n    in_min = in_range.x;\n    in_max = in_range.y;\n    out_min = out_range.x;\n    out_max = out_range.y;\n    \n    // this is gross as hell\n    return (val - in_min)/(in_max - in_min) * (out_max-out_min) + out_min;\n}","name":"Image","description":"","type":"image"}]}