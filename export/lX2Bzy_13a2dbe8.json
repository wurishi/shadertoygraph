{"ver":"0.1","info":{"id":"lX2Bzy","date":"1729635866","viewed":84,"name":"Starfield - Shadetober24 #22","username":"franke333","description":"Day 22 of shadetober","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["shadetober"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sfGRn","filepath":"/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","previewfilepath":"/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":0,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define STARTRESHOLD 0.9975\n#define PLANETTRESHOLD 0.97\n\n\n\nfloat hash(vec2 p) {\n    p = 50.0 * fract(p * 0.3183099 + vec2(0.71, 0.113)); \n    return fract(p.x * p.y * (p.x + p.y));\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.x;\n    //stars\n    vec3 star = vec3(0.);\n    for(float i = 1.; i < 5.1;i += 1.){\n        vec2 noiseUV = i*75.*(uv + vec2((.07-0.01*i)*iTime,0.)) + 127.57*i;\n        float noise = hash(floor(noiseUV));\n        if(noise > STARTRESHOLD){\n            star = getColor((noise-STARTRESHOLD)/(1.-STARTRESHOLD));\n            star *= 1.-smoothstep(0.2,0.6,distance(fract(noiseUV),vec2(0.5)));\n            break;\n        }\n    }\n    \n    //planets\n    vec2 noiseUV = 7.*(uv + vec2(.123*iTime,0.03*sin(0.33*iTime))) + 7.7;\n    float planetHash = hash(floor(noiseUV));\n    vec3 planet;\n    if(planetHash>PLANETTRESHOLD){\n        planetHash = (planetHash-PLANETTRESHOLD)/(1.-PLANETTRESHOLD);\n        float f = smoothstep(0.2,0.4,distance(fract(noiseUV),vec2(0.5)));\n        vec3 texSample = vec3(1.-f)*texture(iChannel1,rotate2D(planetHash*6.28*5.)*fract(noiseUV)).xyz;\n        planet = pow3(texSample,0.5*planetHash)*getColor(planetHash);\n    }\n    \n    // nebula\n    noiseUV = 2.11*(uv + vec2(.015*iTime,0.)) + 1.3;\n    float p = perlinNoise(vec3(noiseUV*2.,0.025*iTime), 2., 3, .666, 2.,0x12345U)*0.5+0.5;\n    float nebula = p*perlinNoise(vec3(noiseUV*1.3,0.01*iTime),0x17745U)*0.8;\n    \n    fragColor = vec4(vec3(star)*smoothstep(0.2,0.,length(planet))+planet,1.0);\n    fragColor += smoothstep(0.1,0.0,length(fragColor.xyz))*vec4(nebula*vec3(0.6,0.2,0.95),1.);\n    \n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"mat2 rotate2D(float angle)\n{\n    return mat2(cos(angle),-sin(angle),sin(angle),cos(angle));\n}\n\nvec3 pow3(vec3 v,float p)\n{\n    return vec3(pow(v.x,p),pow(v.y,p),pow(v.z,p));\n}\n\nvec3 getColor(float value){\n        \n    vec4 colors[3] = vec4[](\n        vec4(0.68,0.875,1.,0.05),\n        vec4(1.,0.98,0.97,0.5),\n        vec4(1.,0.66,0.4,0.95)\n    );\n\n    // vec4 -> xyz = rgb, w = treshold\n    if(value < colors[0].w)\n        return colors[0].xyz;\n\n        \n    int i = 1;\n    while(i < 3){\n        if(value < colors[i].w){\n            float a = colors[i-1].w;\n            float b = colors[i].w;\n            float t = (value-a)/(b-a);\n            return mix(colors[i-1].xyz,colors[i].xyz,t);\n        }\n        i = i + 1;\n    }\n    return colors[2].xyz;\n}\n\n\n// ---------- PERLIN ------------\n\n//Taken from https://www.shadertoy.com/view/slB3z3\n\n// implementation of MurmurHash (https://sites.google.com/site/murmurhash/) for a \n// single unsigned integer.\n\nuint hash(uint x, uint seed) {\n    const uint m = 0x5bd1e995U;\n    uint hash = seed;\n    // process input\n    uint k = x;\n    k *= m;\n    k ^= k >> 24;\n    k *= m;\n    hash *= m;\n    hash ^= k;\n    // some final mixing\n    hash ^= hash >> 13;\n    hash *= m;\n    hash ^= hash >> 15;\n    return hash;\n}\n\n// implementation of MurmurHash (https://sites.google.com/site/murmurhash/) for a  \n// 3-dimensional unsigned integer input vector.\n\nuint hash(uvec3 x, uint seed){\n    const uint m = 0x5bd1e995U;\n    uint hash = seed;\n    // process first vector element\n    uint k = x.x; \n    k *= m;\n    k ^= k >> 24;\n    k *= m;\n    hash *= m;\n    hash ^= k;\n    // process second vector element\n    k = x.y; \n    k *= m;\n    k ^= k >> 24;\n    k *= m;\n    hash *= m;\n    hash ^= k;\n    // process third vector element\n    k = x.z; \n    k *= m;\n    k ^= k >> 24;\n    k *= m;\n    hash *= m;\n    hash ^= k;\n\t// some final mixing\n    hash ^= hash >> 13;\n    hash *= m;\n    hash ^= hash >> 15;\n    return hash;\n}\n\n\nvec3 gradientDirection(uint hash) {\n    switch (int(hash) & 15) { // look at the last four bits to pick a gradient direction\n    case 0:\n        return vec3(1, 1, 0);\n    case 1:\n        return vec3(-1, 1, 0);\n    case 2:\n        return vec3(1, -1, 0);\n    case 3:\n        return vec3(-1, -1, 0);\n    case 4:\n        return vec3(1, 0, 1);\n    case 5:\n        return vec3(-1, 0, 1);\n    case 6:\n        return vec3(1, 0, -1);\n    case 7:\n        return vec3(-1, 0, -1);\n    case 8:\n        return vec3(0, 1, 1);\n    case 9:\n        return vec3(0, -1, 1);\n    case 10:\n        return vec3(0, 1, -1);\n    case 11:\n        return vec3(0, -1, -1);\n    case 12:\n        return vec3(1, 1, 0);\n    case 13:\n        return vec3(-1, 1, 0);\n    case 14:\n        return vec3(0, -1, 1);\n    case 15:\n        return vec3(0, -1, -1);\n    }\n}\n\nfloat interpolate(float value1, float value2, float value3, float value4, float value5, float value6, float value7, float value8, vec3 t) {\n    return mix(\n        mix(mix(value1, value2, t.x), mix(value3, value4, t.x), t.y),\n        mix(mix(value5, value6, t.x), mix(value7, value8, t.x), t.y),\n        t.z\n    );\n}\n\nvec3 fade(vec3 t) {\n    // 6t^5 - 15t^4 + 10t^3\n\treturn t * t * t * (t * (t * 6.0 - 15.0) + 10.0);\n}\n\nfloat perlinNoise(vec3 position, uint seed) {\n    vec3 floorPosition = floor(position);\n    vec3 fractPosition = position - floorPosition;\n    uvec3 cellCoordinates = uvec3(floorPosition);\n    float value1 = dot(gradientDirection(hash(cellCoordinates, seed)), fractPosition);\n    float value2 = dot(gradientDirection(hash((cellCoordinates + uvec3(1, 0, 0)), seed)), fractPosition - vec3(1, 0, 0));\n    float value3 = dot(gradientDirection(hash((cellCoordinates + uvec3(0, 1, 0)), seed)), fractPosition - vec3(0, 1, 0));\n    float value4 = dot(gradientDirection(hash((cellCoordinates + uvec3(1, 1, 0)), seed)), fractPosition - vec3(1, 1, 0));\n    float value5 = dot(gradientDirection(hash((cellCoordinates + uvec3(0, 0, 1)), seed)), fractPosition - vec3(0, 0, 1));\n    float value6 = dot(gradientDirection(hash((cellCoordinates + uvec3(1, 0, 1)), seed)), fractPosition - vec3(1, 0, 1));\n    float value7 = dot(gradientDirection(hash((cellCoordinates + uvec3(0, 1, 1)), seed)), fractPosition - vec3(0, 1, 1));\n    float value8 = dot(gradientDirection(hash((cellCoordinates + uvec3(1, 1, 1)), seed)), fractPosition - vec3(1, 1, 1));\n    return interpolate(value1, value2, value3, value4, value5, value6, value7, value8, fade(fractPosition));\n}\n\nfloat perlinNoise(vec3 position, float frequency, int octaveCount, float persistence, float lacunarity, uint seed) {\n    float value = 0.0;\n    float amplitude = 1.0;\n    float currentFrequency = float(frequency);\n    uint currentSeed = seed;\n    for (int i = 0; i < octaveCount; i++) {\n        currentSeed = hash(currentSeed, 0x0U); // create a new seed for each octave\n        value += perlinNoise(position * currentFrequency, currentSeed) * amplitude;\n        amplitude *= persistence;\n        currentFrequency *= lacunarity;\n    }\n    return value;\n}\n","name":"Common","description":"","type":"common"}]}