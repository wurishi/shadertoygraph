{"ver":"0.1","info":{"id":"wlSGWV","date":"1561449313","viewed":247,"name":"Game - Snake","username":"DrCosinus","description":"The Classic SNAKE game:\n  you are a snake, you must eat fruits (pink dots) to grow and score, but you must not eat your own tail\n- use arrow keys to change direction\n- use space to restart when game is over\n","likes":6,"published":1,"flags":48,"usePreview":0,"tags":["2d","game","snake"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const ivec2 ptrSnakeInfo =   ivec2(0,0); // xy:head pos, z:total length, w:current direction\nconst ivec2 ptrFruit\t   = ivec2(1,0);\nconst ivec2 ptrSnakeBuffer = ivec2(3,0); // xy:pos\n\nconst int gridSize = 24;\nconst float scale = 14.;\nconst float gridPixelSize = float(gridSize) * scale;\n\nconst vec3 backdropColor = vec3(0.1);\nconst vec3 gridBackColor = vec3(0,0,0.5);\n\nconst vec3 snakeOutlineColor = vec3(0.1,0.7,0.2);\nconst vec3 snakeFillColor = vec3(0.5, 1.,0.5);\n\nvec4 loadValue(in ivec2 ptr)\n{\n    return texelFetch(iChannel0, ptr, 0);\n}\n\n// distance to segment\nfloat segment(in vec2 start, in vec2 end, in vec2 p)\n{\n    vec2 ap = p - start;\n    vec2 ab = end - start;\n    float t = clamp(dot(ap,ab)/dot(ab,ab),0.,1.);\n    return length(ap-ab*t);\n}\n\nfloat snakeSegment(in vec2 start, in vec2 end, in vec2 p)\n{\n    if (end.x-start.x<-scale)\n        end.x += gridPixelSize;\n    if (end.x-start.x>scale)\n        start.x += gridPixelSize;\n    if (end.y-start.y<-scale)\n        end.y += gridPixelSize;\n    if (end.y-start.y>scale)\n        start.y += gridPixelSize;\n    \n    return segment(start, end, p);\n}\n\nfloat snakeDistance(in vec2 uv)\n{\n    vec4 snakeInfo = loadValue( ptrSnakeInfo );\n    int snakeSegmentCount = int(snakeInfo.z);\n\n    vec2 start = snakeInfo.xy * scale;\n    float snakeBody = segment( start, start, uv ); // head\n\n    for (int i=snakeSegmentCount-1; i>=0; i--)\n    {\n        vec2 end = loadValue(ptrSnakeBuffer+ivec2(i,0)).xy * scale;\n        if (abs(start.x-end.x)<=scale&& abs(start.y-end.y)<=scale)\n            snakeBody = min( snakeBody, snakeSegment( start, end, uv ));\n        else\n        {\n            vec2 delta = sign(end-start)*scale;\n            snakeBody = min( snakeBody, snakeSegment( start, start-delta, uv ));\n            snakeBody = min( snakeBody, snakeSegment( end, end+delta, uv ));\n        }\n        start = end;\n    }\n    return snakeBody;\n}\n\nvoid snake(in vec2 uv, inout vec3 col)\n{\n    float snakeDist = snakeDistance(uv);\n    float snakeOutline = clamp( smoothstep(7.5,6.0, snakeDist) - smoothstep(3.5,3.0, snakeDist), 0., 1. );\n    float snakeFill = clamp( smoothstep(4.1, 3.6, snakeDist), 0., 1. );\n    col = mix( col, snakeOutlineColor, snakeOutline );\n    col = mix( col, snakeFillColor, snakeFill );\n}\n\nvoid fruit(in vec2 uv, inout vec3 col)\n{\n    vec2 fruitPos = loadValue( ptrFruit ).xy;\n    float fruitDistance = distance( fruitPos * scale, uv );\n    float fruitOutline = clamp( smoothstep( 6.5, 6.0, fruitDistance ) - smoothstep( 3.5, 3.0, fruitDistance ), 0., 1. );\n    float fruitFill = clamp( smoothstep( 4.1, 3.6, fruitDistance ), 0., 1. );\n    col = mix( col, vec3(1, 0.4, 0.6), fruitOutline );\n    col = mix( col, vec3(1, 1, 1), fruitFill );\n}\n\nvoid borders(in vec2 uv, inout vec3 col)\n{\n    float borderDist = segment( vec2(-scale, -scale*.5), vec2(-scale, gridPixelSize+scale*.5), uv );\n    borderDist = min( borderDist, segment( vec2(gridPixelSize, -scale*.5), vec2(gridPixelSize, gridPixelSize+scale*.5), uv ));\n    float borderFill = smoothstep( 7.0, 6.5, borderDist );\n    col = mix( col, vec3(0.5,0.5,1.0), borderFill );\n}\n\nbool isGameOver()\n{\n    return int(loadValue( ptrSnakeInfo ).w) == 4;\n}\n\nfloat digit(in int value, in int rank, in vec2 uv)\n{\n    uv += vec2(120,0);\n    uv *= .1;\n    uv.x -= float(2*rank);\n    float d;\n    switch(value)\n    {\n    case 0:\n        d =        segment(vec2(0,0), vec2(0,2), uv);\n        d = min(d, segment(vec2(1,0), vec2(1,2), uv));\n        d = min(d, segment(vec2(0,0), vec2(1,0), uv));\n        d = min(d, segment(vec2(0,2), vec2(1,2), uv));\n        break;\n    case 1:\n        d =        segment(vec2(1,0), vec2(1,2), uv);\n        break;        \n    case 2:\n        d =        segment(vec2(0,2), vec2(1,2), uv);\n        d = min(d, segment(vec2(1,2), vec2(1,1), uv));\n        d = min(d, segment(vec2(1,1), vec2(0,1), uv));\n        d = min(d, segment(vec2(0,1), vec2(0,0), uv));\n        d = min(d, segment(vec2(0,0), vec2(1,0), uv));\n        break;\n    case 3:\n        d =        segment(vec2(0,2), vec2(1,2), uv);\n        d = min(d, segment(vec2(1,2), vec2(1,1), uv));\n        d = min(d, segment(vec2(1,1), vec2(0,1), uv));\n        d = min(d, segment(vec2(1,1), vec2(1,0), uv));\n        d = min(d, segment(vec2(0,0), vec2(1,0), uv));\n        break;\n    case 4:\n        d =        segment(vec2(0,2), vec2(0,1), uv);\n        d = min(d, segment(vec2(0,1), vec2(1,1), uv));\n        d = min(d, segment(vec2(1,2), vec2(1,0), uv));\n        break;\n    case 5:\n        d =        segment(vec2(0,2), vec2(1,2), uv);\n        d = min(d, segment(vec2(0,2), vec2(0,1), uv));\n        d = min(d, segment(vec2(1,1), vec2(0,1), uv));\n        d = min(d, segment(vec2(1,1), vec2(1,0), uv));\n        d = min(d, segment(vec2(0,0), vec2(1,0), uv));\n        break;\n    case 6:\n        d =        segment(vec2(0,2), vec2(1,2), uv);\n        d = min(d, segment(vec2(0,2), vec2(0,0), uv));\n        d = min(d, segment(vec2(1,1), vec2(0,1), uv));\n        d = min(d, segment(vec2(1,1), vec2(1,0), uv));\n        d = min(d, segment(vec2(0,0), vec2(1,0), uv));\n        break;\n    case 7:\n        d =        segment(vec2(1,0), vec2(1,2), uv);\n        d = min(d, segment(vec2(0,2), vec2(1,2), uv));\n        break;        \n    case 8:\n        d =        segment(vec2(0,2), vec2(1,2), uv);\n        d = min(d, segment(vec2(0,2), vec2(0,0), uv));\n        d = min(d, segment(vec2(1,1), vec2(0,1), uv));\n        d = min(d, segment(vec2(1,2), vec2(1,0), uv));\n        d = min(d, segment(vec2(0,0), vec2(1,0), uv));\n        break;\n    case 9:\n        d =        segment(vec2(0,2), vec2(1,2), uv);\n        d = min(d, segment(vec2(0,2), vec2(0,1), uv));\n        d = min(d, segment(vec2(1,1), vec2(0,1), uv));\n        d = min(d, segment(vec2(1,2), vec2(1,0), uv));\n        d = min(d, segment(vec2(0,0), vec2(1,0), uv));\n        break;        \n    default:\n        d = segment(vec2(0,0), vec2(1,2), uv);\n        d = min(d, segment(vec2(1,0), vec2(0,2), uv));\n        break;\n    }\n    return d*10.;    \n}\n\nvoid score(in vec2 uv, inout vec3 col)\n{\n    int s = int(loadValue( ptrSnakeInfo ).z)-1;\n    \n    float digits =              digit((s/100)%10,0,uv);\n          digits = min( digits, digit((s/10)%10,1,uv));\n          digits = min( digits, digit(s%10,2,uv));\n    col = mix( col, vec3(1.), smoothstep(3.0,2.5, digits));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragCoord -= vec2((iResolution.x-iResolution.y)/2.,0.);\n    fragCoord = fragCoord * vec2(gridPixelSize) / iResolution.yy ;\n        \n    vec2 uv = fragCoord - vec2(scale*0.5);\n    \n    bool gameOver = isGameOver();\n    \n    vec3 col = gameOver ? mix( vec3(1,0,0), vec3(1,0.66,0.22), pow(sin(iTime*3.5),2.)) : backdropColor;\n    \n    vec3 gridBackground = gridBackColor;\n    bool gridBackgroundMask = fragCoord.x>=0. && fragCoord.y>=0. && fragCoord.x<gridPixelSize && fragCoord.y<gridPixelSize;\n    col = mix( col, gridBackground, float(gridBackgroundMask) );\n    \n    if (gridBackgroundMask)\n    {\n        snake(uv, col);\n    }\n\n    fruit(uv, col);\n    \n    borders(uv, col);\n    \n    score(uv, col);\n\n    fragColor = vec4(vec3(col),1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"const ivec2 ptrSnakeInfo   = ivec2(0,0); // xy:head pos, z:total length, w:current direction\nconst ivec2 ptrFruit\t   = ivec2(1,0);\nconst ivec2 ptrTimer \t   = ivec2(2,0);\nconst ivec4 ptrSnakeBuffer = ivec4(3,0,600,0); // xy:pos\n\nconst int gridSize = 24;\n\nconst ivec2 ptrLast = ivec2(600,0);\n\nconst vec2 directions[5] = vec2[5]( vec2(1,0), vec2(0,1), vec2(-1,0), vec2(0,-1), vec2(0,0) );\n\nconst int DIR_RIGHT = 0;\nconst int DIR_UP    = 1;\nconst int DIR_LEFT  = 2;\nconst int DIR_DOWN  = 3;\nconst int DIR_NONE  = 4;\n\nconst int VK_SPACE = 32;\nconst int VK_LEFT  = 37;\nconst int VK_UP    = 38;\nconst int VK_RIGHT = 39;\nconst int VK_DOWN  = 40;\nconst int VK_G     = 71;\n\nvec4 loadValue(in ivec2 ptr)\n{\n    return texelFetch(iChannel0, ptr, 0);\n}\n\nvoid storeValue(in ivec2 ptr, in vec4 value, inout vec4 color, in ivec2 coord)\n{\n    color = (ptr==coord) ? value : color;\n}\n\nvoid storeValue(in ivec4 ptr, in vec4 value, inout vec4 color, in ivec2 coord)\n{\n    color = (coord.x>=ptr.x && coord.y>=ptr.y && coord.x<=ptr.z && coord.y<=ptr.w) ? value : color;\n}\n\nfloat hash1(in float n ) { return fract(sin(n)*138.5453123); }\n\nbool isKeyDown(in int key)\n{\n    return texelFetch( iChannel1, ivec2(key,1), 0 ).x > 0.5;\n}\n\nvec2 NewFruit(in vec2 head, in int len)\n{\n\tvec2 pos;\n    bool success = true;\n    int offset = 0;\n    do\n    {\n        pos =\n            vec2(\n                floor( float(gridSize) * hash1(\n                    iDate.w + 7.1*float(iFrame+offset)\n                )),\n                floor( float(gridSize) * hash1(\n                    iDate.w + 9.3*float(iFrame+3*offset)\n                ))\n            );\n\t\tsuccess = (pos!=head);\n        for(int i=0; (i<len) && success; ++i)\n        {\n            success = (pos!=loadValue( ptrSnakeBuffer.xy + ivec2(i,0)).xy);\n        }\n        offset++;\n    } while(!success);\n    \n    //if (\n    return pos;\n}\n\nvoid InitGame(\n    out vec2 snakeHead,\n    out int  snakeLength,\n    out int  snakeDir, \n    out vec2 fruitPos, \n    out vec2 snakeBuffer,\n\tout float currentTime)\n{\n    snakeHead = vec2(gridSize/2,gridSize/2);\n    snakeLength = 1;\n    snakeDir = DIR_RIGHT;\n    fruitPos = NewFruit(snakeHead,snakeLength);\n    snakeBuffer = snakeHead;\n    currentTime = 0.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 pixel = ivec2( fragCoord - 0.5 );\n    \n    // don't compute gameplay outside of the data area\n    if (pixel.x>ptrLast.x || pixel.y>ptrLast.y)\n    {\n        discard;\n    }\n\n    // ===========\n    // load values\n    // ===========\n    \n    vec4 snakeInfo = loadValue( ptrSnakeInfo);\n    vec2 fruitPos = loadValue( ptrFruit ).xy;\n    vec2 timer = loadValue( ptrTimer ).xy;\n    vec2 snakeBuffer = loadValue( pixel ).xy;\n    \n    vec2 snakeHead = snakeInfo.xy;\n    int len = int(snakeInfo.z); \n    int dir = int(snakeInfo.w);    \n    float currentTime = timer.x;\n    \n    if (iFrame == 0)\n    {\n        InitGame(snakeHead, len, dir, fruitPos, snakeBuffer, currentTime);\n    }\n    \n    // ==========\n    // game logic\n    // ==========\n    \n    if ( dir != DIR_NONE )\n    {\n        bool moveUp    = isKeyDown(VK_UP)    && dir!=DIR_DOWN;\n        bool moveDown  = isKeyDown(VK_DOWN)  && dir!=DIR_UP;\n        bool moveLeft  = isKeyDown(VK_LEFT)  && dir!=DIR_RIGHT;\n        bool moveRight = isKeyDown(VK_RIGHT) && dir!=DIR_LEFT;\n        \n        currentTime += iTimeDelta;\n        \n        if (currentTime > 0.1 || moveUp || moveDown || moveLeft || moveRight )\n        {\n            currentTime = 0.;\n            \n            if (moveUp)\n                dir = DIR_UP;\n            if (moveDown)\n                dir = DIR_DOWN;\n            if (moveLeft)\n                dir = DIR_LEFT;\n            if (moveRight)\n                dir = DIR_RIGHT;\n            \n            if (snakeHead != fruitPos)\n            {\n                // no food evolution\n                int offset = pixel.x - ptrSnakeBuffer.x;\n\n                if (offset>=0 && offset<len)\n                {\n                    if (offset == len-1)\n                        snakeBuffer.xy = snakeHead;\n                    else\n                        snakeBuffer = loadValue( pixel + ivec2(1,0) ).xy;\n                }\n            }\n            else\n            {\n                // food evolution\n                if (pixel.x - ptrSnakeBuffer.x == len)\n                    snakeBuffer.xy = snakeHead;\n                len++;\n                fruitPos = NewFruit(snakeHead,len);\n            }\n            snakeHead += directions[ dir ];\n            snakeHead = mod(snakeHead, float(gridSize));\n\n            // check head against tail\n            for(int i=0; i<len; ++i)\n            {\n                if ( loadValue( ptrSnakeBuffer.xy + ivec2(i,0) ).xy == snakeHead )\n                {\n                    dir = DIR_NONE; // game over\n                }\n            }\n        }\n    }\n    else\n    {\n       \tif (isKeyDown(VK_SPACE)) \n        {\n            InitGame(snakeHead, len, dir, fruitPos, snakeBuffer, currentTime);\n        }\n    }\n    \n    // ============\n    // store values\n    // ============\n    fragColor = vec4(0);\n    \n    storeValue( ptrSnakeInfo,   vec4(snakeHead, float(len), float(dir)), fragColor, pixel );\n    storeValue( ptrFruit,       vec4(fruitPos, 0, 0),                    fragColor, pixel );\n\tstoreValue( ptrTimer,       vec4(currentTime, 0, 0, 0 ),             fragColor, pixel );\n    storeValue( ptrSnakeBuffer, vec4(snakeBuffer, 0, 0),                 fragColor, pixel ); \n}","name":"Buffer A","description":"","type":"buffer"}]}