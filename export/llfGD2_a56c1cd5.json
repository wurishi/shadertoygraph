{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"uniform struct points { vec2 p[8]; };\n    \nstruct ind_dist { vec2 v; float dist; };\n\nfloat thresh(float x) {\n    if (x > 1.0) { return 1.0; }\n    if (x < 0.0) { return 0.0; }\n\treturn x;\n}\n    \nind_dist get_nearest(points p, vec2 uv)\n{\n    \n    float minval = 1e10;\n    vec2  v;\n    for (int i = 0; i < 8; i ++) {\n        float d = distance(uv, p.p[i]);\n        minval = min(d,minval);\n        if (minval == d) {\n            v = p.p[i];\n        }\n    }\n    \n    ind_dist o;\n    o.v = v;\n    o.dist  = minval;\n\treturn o;\n}\n    \nfloat ani(float iTime){\n    return abs(sin(1.0*iTime));\n}\n\nvec2 getuv(float scale, vec2 uv) {\n    // Get Normalized UV Coordinates\n\tuv = (uv - 0.5);\n   \tuv[0] = 1.8*uv[0];\n    uv = scale*uv; \n    return uv;\n}\n\nvec2 sphereinv(vec2 x, float r){\n    return r*x/(x[0]*x[0] + x[1]*x[1]);\n}\n\nmat2 rotate_mat(float theta) {\n    // 2x2 Rotation Matrix\n    return mat2( cos( theta ), -sin( theta ),\n                 sin( theta ),  cos( theta ));    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t\n    float t = iTime;\n    \n    points p;\n    p.p[0] = vec2(  0.0,  2.0 );\n    p.p[1] = vec2(  2.0,  0.0 );\n    p.p[2] = vec2( -2.0,  0.0 );\n    p.p[3] = vec2(  0.0, -2.0 );\n    \n    float c = sqrt(2.0);\n    p.p[4] = vec2( -c, -c  );\n    p.p[5] = vec2( -c,  c );\n    p.p[6] = vec2(  c,  c );\n    p.p[7] = vec2(  c, -c );\n    \n    vec2 uv = getuv(3.2,fragCoord.xy / iResolution.xy);\n    \n\tind_dist I;\n    const int iters = 10;\n    float depth = 0.0;\n    vec2 closest_pt;\n    for (int i = 0; i < iters; i++) {\n        I = get_nearest(p, uv);\n        closest_pt = I.v;        \n        uv = (2.0)*(uv - closest_pt) + closest_pt;\n        uv = rotate_mat(0.5*t)*uv;\n        if (length(uv) < 1.7 -3.5*cos(1.0*t) ){\n            uv = sphereinv(uv,1.0 );\n    \t}\n        depth = depth + I.dist;\n    }\n    \n    float minval = I.dist/pow(2.0,float(iters));\n    float r; float g; float b;\n    r = 1.0 - smoothstep(0.0,15.0,depth);\n    g = 1.0 - smoothstep(0.0,15.0,depth);\n    b = 1.0 - smoothstep(0.0,15.0,depth);\n\n    fragColor = vec4(r,g,b,1.0);\n    \n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"llfGD2","date":"1425175054","viewed":1252,"name":"Fractal Wheel 2.0","username":"gabgoh","description":"Wheel Fractal","likes":9,"published":1,"flags":0,"usePreview":0,"tags":["thisonelookslikeawheel"],"hasliked":0,"parentid":"","parentname":""}}