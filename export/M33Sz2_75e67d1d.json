{"ver":"0.1","info":{"id":"M33Sz2","date":"1719276496","viewed":16,"name":"Raymarching template v2","username":"FrederickAmpsUp","description":"Ray Marching template that includes a number of utility functions related to SDFs and raymarching, and is easily extensible.\nIncludes my skybox integration lighting, as well as a GI technique that I invented called FXGI. ","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","template"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define CAM_ORG vec3(0,-3,0)\n\nvec3 skyColor(vec3 rd) {\n    float upc = dot(rd, UP);\n    vec3 atmos = mix(SKY_BOTTOM, SKY_TOP, upc);\n    atmos += SKY_HORIZ * pow(1.0 - upc, 8.0);\n    \n    vec3 col = atmos * step(-0.1, upc);\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    time = iTime;\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 ndc = uv * 2.0 - 1.0;\n    vec2 acdc = vec2(ndc.x, ndc.y * (iResolution.y / iResolution.x));\n    \n    ONB camTransform = lookAt(CAM_ORG, vec3(0, 0, 0));\n    Ray cam = cameraRay(acdc, CAM_ORG, camTransform, 60.0);\n    \n    SurfaceInfo inf;\n    \n    float d = march(cam, inf);\n    \n    vec3 col;\n    if (d < MARCH_MISS) {\n            // hit\n        vec3 norm = normal(inf.pos);\n        col = vec3(0.0);\n        \n        col += zeroBounceLighting(inf, norm);\n        if (dot(inf.pos-CAM_ORG, inf.pos-CAM_ORG) < BOUNCE_LIGHT_DIST*BOUNCE_LIGHT_DIST)\n            col += bounceLighting(inf, norm);\n    } else {\n            // miss\n        col = skyColor(cam.direction);\n    }\n    \n    col = flim_transform(col, 0.0, true);\n\n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define PI 3.14159265\n\n#define MARCH_STEPS 512\n#define MARCH_SURF 0.001\n#define MARCH_MISS 1000.\n\n#define CPDS_ITERATIONS 64\n\n#define UP vec3(0,0,1)\n\n#define LIGHT_POS vec3(3, -3, 3) * 2.0\n#define LIGHT_SIZE 2.0\n#define LIGHT_COL vec3(10, 10, 10) * 4.0\n\n#define SKY_TOP vec3(.46, .84, .92)*0.3\n#define SKY_BOTTOM (SKY_TOP * 0.6)\n#define SKY_HORIZ vec3(.9, .2, .2)\n\n#define BOUNCE_LIGHT_DIST 50.0\n\n    // integrate the sky function\n#define SKY_AMBIENCE ((SKY_BOTTOM - SKY_TOP + PI*SKY_TOP/2.0 + SKY_HORIZ/9.0) * (2.0 / PI))\n\nstruct Ray {\n    vec3 origin, direction;\n};\n\nstruct Material {\n    vec3 diffuseColor;\n};\n\nstruct SurfaceInfo {\n    vec3 pos;\n    Material mat;\n};\n\nstruct ONB {\n    vec3 forward, right, up;\n};\n\nfloat opUnion(out Material mat, float a, Material mA, float b, Material mB) {\n    if (a < b) {\n        mat = mA;\n        return a;\n    }\n    mat = mB;\n    return b;\n        \n}\n\nfloat time;\n\nfloat map(vec3 p, out Material m) {\n    Material mGround = Material(vec3(0.9, 0.8, 0.8));\n    float dGround = p.z + 1.0;\n    \n    Material mSphere = Material(vec3(0.9, 0.1, 0.1));\n    float dSphere = length(p - vec3(0, 0, sin(time))) - 1.0;\n    \n    return opUnion(m, dGround, mGround, dSphere, mSphere);\n}\n\nfloat map(vec3 p) {\n    Material _;\n    return map(p, _);\n}\n\nfloat march(Ray r, inout SurfaceInfo surf) {\n    float t = 0.0;\n    surf.pos = r.origin;\n    float s = map(surf.pos, surf.mat);\n    \n    for (int i = 0; i < MARCH_STEPS; i++) {\n        if (abs(s) < MARCH_SURF || s > MARCH_MISS) return s;\n        if (t > MARCH_MISS) return MARCH_MISS + 1.;\n        if (s < 0.0) i++; // take less steps if we're inside a surface\n        t += s;\n        surf.pos += r.direction * s;\n        \n        s = map(surf.pos, surf.mat);\n    }\n    return s;\n}\n\nvec3 normal(in vec3 pos) {\n    float epsilon = 0.01;\n    return normalize(\n        vec3(\n            map(pos + vec3(epsilon, 0, 0)) - map(pos - vec3(epsilon, 0, 0)),\n            map(pos + vec3(0, epsilon, 0)) - map(pos - vec3(0, epsilon, 0)),\n            map(pos + vec3(0, 0, epsilon)) - map(pos - vec3(0, 0, epsilon))\n        )\n    );\n}\n\nfloat shadow(vec3 shadedPos, vec3 lightPos, float lightSize, inout SurfaceInfo surf) {\n    float res = 1.0;\n    float t = 0.005;\n    vec3 toLight = normalize(lightPos - shadedPos);\n    float maxt = distance(shadedPos, lightPos);\n    \n    for( int i=0; i<MARCH_STEPS && t<maxt; i++ ) {\n        float h = map(shadedPos + toLight * t, surf.mat);\n        res = min( res, h/(lightSize*t) );\n        t += min(h, 0.005);\n        if(res<-1.0) break;\n    }\n    res = max(res,-1.0);\n    if (res != res) return 1.0;\n    float final = 0.25*(1.0+res)*(1.0+res)*(2.0-res);\n    return final;\n}\n\nfloat shadow(vec3 shadedPos, vec3 lightPos, float lightSize) {\n    SurfaceInfo _;\n    return shadow(shadedPos, lightPos, lightSize, _);\n}\n\nfloat estimateSolidAngleOfHemisphere(vec3 point, vec3 norm, inout SurfaceInfo surf) {\n    return shadow(point, point + norm * 1000.0, 1.0, surf);\n}\n\nfloat estimateSolidAngleOfHemisphere(vec3 point, vec3 norm) {\n    SurfaceInfo _;\n    return estimateSolidAngleOfHemisphere(point, norm, _);\n}\n\nvec3 closestPointOnDifferentSurface(vec3 point, vec3 norm, inout SurfaceInfo surf) {\n    // https://excalidraw.com/#json=0ZCMIrFGquxxjJb_SYNq5,P4V2AYmj0pCY-IuNRia_kQ\n    \n    surf.pos = point - norm * (map(point) - MARCH_SURF);\n    \n    // Step 3: Iterate\n    for (int j = 0; j < CPDS_ITERATIONS; j++) {\n            // Step 1: Up\n        float t = 0.0;\n        float s = map(surf.pos, surf.mat);\n\n        for (int i = 0; i < MARCH_STEPS; i++) {\n        \n            if (map(surf.pos + norm * s) - s < s - MARCH_SURF && j == 0)\n                i = MARCH_STEPS;\n            \n            if (map(surf.pos + norm * s) < s && j > 0) {\n                surf.pos -= norm * s;\n                break;\n            }\n            \n            if (t > MARCH_MISS && j > 0) break;\n            \n            t += s;\n            surf.pos += norm * s;\n\n            s = map(surf.pos, surf.mat);\n        }\n        \n            // Step 2: Snap\n        surf.pos -= normal(surf.pos) * (map(surf.pos) - MARCH_SURF);\n        // move toward the point we started at\n        norm = normalize(point - surf.pos);\n    }\n    \n    map(surf.pos, surf.mat);\n    return surf.pos;\n}\n\nfloat march(Ray r) {\n    SurfaceInfo _;\n    return march(r, _);\n}\n\n\nONB lookAt(vec3 lookfrom, vec3 lookat) {\n    vec3 forward = normalize(lookat - lookfrom);\n    vec3 right = normalize(cross(forward, UP));\n    vec3 up = cross(forward, right);\n    up *= sign(dot(up, UP));\n    \n    return ONB(forward, right, up);\n}\n\nRay cameraRay(vec2 acdc, vec3 ro, ONB onb, float vfov) {\n    float focal = 1.0 / (2.0*tan(radians(vfov) / 2.0));\n    Ray r;\n    r.origin = ro;\n    r.direction = normalize(onb.right * acdc.x + onb.up * acdc.y + onb.forward * focal);\n    return r;\n}\n\nvec3 directLighting(SurfaceInfo inf, vec3 norm, vec3 lightPos, float lightSize, vec3 lightColor) {\n    vec3 toL = lightPos - inf.pos;\n    float dstL = length(toL);\n    vec3 nL = toL / dstL;\n    \n    float lambert = max(0.0, dot(norm, nL));\n    float occlusion = shadow(inf.pos, lightPos, (lightSize / dstL));\n    float light = lambert * occlusion;\n    \n    return inf.mat.diffuseColor * lightColor * light / dot(toL, toL);\n}\n\nvec3 zeroBounceLighting(SurfaceInfo inf, vec3 norm) {\n    vec3 direct = directLighting(inf, norm, LIGHT_POS, LIGHT_SIZE, LIGHT_COL);\n    \n    float occlusion = estimateSolidAngleOfHemisphere(inf.pos + norm * MARCH_SURF * 10.0, UP);\n    vec3 sky = inf.mat.diffuseColor * SKY_AMBIENCE * occlusion;\n    \n    return direct + sky;\n}\n\nvec3 bounceLighting(SurfaceInfo inf, vec3 norm) {\n    SurfaceInfo closestInf;\n    vec3 closest = closestPointOnDifferentSurface(inf.pos, norm, closestInf);\n    vec3 closestNorm = normal(closest);\n    vec3 toC = closest - inf.pos;\n    float dstC = length(toC);\n    \n    float invStrength = dstC;\n    vec3 closestSurfLighting = zeroBounceLighting(closestInf, closestNorm);\n    \n    float lambert = dot(norm, toC / dstC);\n    \n    return inf.mat.diffuseColor * lambert * closestSurfLighting;\n}\n\n\n/*-----------------------------------------------\n\nflim - Filmic Color Transform\n\nInput Color Space:   Linear BT.709 I-D65\nOutput Color Space:  Linear BT.709 I-D65 / sRGB 2.2 (depends on arguments)\n\nDescription:\n  Experimental port of flim for GLSL/Shadertoy\n  matching flim v1.1.0.\n\nAuthor:\n  Bean (beans_please on Shadertoy)\n\nOriginal Repo:\n  https://github.com/bean-mhm/flim\n\nOriginal Shader:\n  https://www.shadertoy.com/view/dd2yDz\n\n-----------------------------------------------*/\n\n// parameters\n\nconst float flim_pre_exposure = 4.3;\nconst vec3 flim_pre_formation_filter = vec3(1.);\nconst float flim_pre_formation_filter_strength = 0.;\n\nconst float flim_extended_gamut_red_scale = 1.05;\nconst float flim_extended_gamut_green_scale = 1.12;\nconst float flim_extended_gamut_blue_scale = 1.045;\nconst float flim_extended_gamut_red_rot = .5;\nconst float flim_extended_gamut_green_rot = 2.;\nconst float flim_extended_gamut_blue_rot = .1;\nconst float flim_extended_gamut_red_mul = 1.;\nconst float flim_extended_gamut_green_mul = 1.;\nconst float flim_extended_gamut_blue_mul = 1.;\n\nconst float flim_sigmoid_log2_min = -10.;\nconst float flim_sigmoid_log2_max = 22.;\nconst float flim_sigmoid_toe_x = .44;\nconst float flim_sigmoid_toe_y = .28;\nconst float flim_sigmoid_shoulder_x = .591;\nconst float flim_sigmoid_shoulder_y = .779;\n\nconst float flim_negative_film_exposure = 6.;\nconst float flim_negative_film_density = 5.;\n\nconst vec3 flim_print_backlight = vec3(1);\nconst float flim_print_film_exposure = 6.;\nconst float flim_print_film_density = 27.5;\n\nconst float flim_black_point = -1.; // -1 = auto\nconst vec3 flim_post_formation_filter = vec3(1);\nconst float flim_post_formation_filter_strength = 0.;\nconst float flim_midtone_saturation = 1.02;\n\n// color space conversions\n// the matrices below represent data in row-major, but GLSL matrices are in\n// column-major, so we need to multiply a vec3 by a matrix rather than\n// multiplying a matrix by a vec3.\n\nconst mat3 mat_bt2020_to_xyz = mat3(\n     0.6369580483,  0.1446169036,  0.1688809752,\n     0.2627002120,  0.6779980715,  0.0593017165,\n     0.0000000000,  0.0280726930,  1.0609850577\n);\n\nconst mat3 mat_xyz_to_bt2020 = mat3(\n     1.7166511880, -0.3556707838, -0.2533662814,\n    -0.6666843518,  1.6164812366,  0.0157685458,\n     0.0176398574, -0.0427706133,  0.9421031212\n);\n\nconst mat3 mat_bt709_to_xyz = mat3(\n     0.4123907993,  0.3575843394,  0.1804807884,\n     0.2126390059,  0.7151686788,  0.0721923154,\n     0.0193308187,  0.1191947798,  0.9505321522\n);\n\nconst mat3 mat_xyz_to_bt709 = mat3(\n     3.2409699419, -1.5373831776, -0.4986107603,\n    -0.9692436363,  1.8759675015,  0.0415550574,\n     0.0556300797, -0.2039769589,  1.0569715142\n);\n\nconst mat3 mat_dcip3_to_xyz = mat3(\n     0.4451698156,  0.2771344092,  0.1722826698,\n     0.2094916779,  0.7215952542,  0.0689130679,\n     0.0000000000,  0.0470605601,  0.9073553944\n);\n\nconst mat3 mat_xyz_to_dcip3 = mat3(\n     2.7253940305, -1.0180030062, -0.4401631952,\n    -0.7951680258,  1.6897320548,  0.0226471906,\n     0.0412418914, -0.0876390192,  1.1009293786\n);\n\nvec3 oetf_pow(vec3 col, float power)\n{\n    return pow(col, vec3(1. / power));\n}\n\nvec3 eotf_pow(vec3 col, float power)\n{\n    return pow(col, vec3(power));\n}\n\n// flim's utility functions\n\nfloat flim_wrap(float v, float start, float end)\n{\n    return start + mod(v - start, end - start);\n}\n\nfloat flim_remap(\n    float v,\n    float inp_start,\n    float inp_end,\n    float out_start,\n    float out_end\n)\n{\n    return out_start\n        + ((out_end - out_start) / (inp_end - inp_start)) * (v - inp_start);\n}\n\nfloat flim_remap_clamp(\n    float v,\n    float inp_start,\n    float inp_end,\n    float out_start,\n    float out_end\n)\n{\n    float t = clamp((v - inp_start) / (inp_end - inp_start), 0., 1.);\n    return out_start + t * (out_end - out_start);\n}\n\nfloat flim_remap01(\n    float v,\n    float inp_start,\n    float inp_end\n)\n{\n    return clamp((v - inp_start) / (inp_end - inp_start), 0., 1.);\n}\n\nvec3 flim_blender_rgb_to_hsv(vec3 rgb)\n{\n    float cmax, cmin, h, s, v, cdelta;\n    vec3 c;\n\n    cmax = max(rgb[0], max(rgb[1], rgb[2]));\n    cmin = min(rgb[0], min(rgb[1], rgb[2]));\n    cdelta = cmax - cmin;\n\n    v = cmax;\n    if (cmax != 0.)\n    {\n        s = cdelta / cmax;\n    }\n    else\n    {\n        s = 0.;\n        h = 0.;\n    }\n\n    if (s == 0.)\n    {\n        h = 0.;\n    }\n    else\n    {\n        c = (vec3(cmax) - rgb.xyz) / cdelta;\n\n        if (rgb.x == cmax)\n        {\n            h = c[2] - c[1];\n        }\n        else if (rgb.y == cmax)\n        {\n            h = 2. + c[0] - c[2];\n        }\n        else\n        {\n            h = 4. + c[1] - c[0];\n        }\n\n        h /= 6.;\n\n        if (h < 0.)\n        {\n            h += 1.;\n        }\n    }\n\n    return vec3(h, s, v);\n}\n\nvec3 flim_blender_hsv_to_rgb(vec3 hsv)\n{\n    float f, p, q, t, h, s, v;\n    vec3 rgb;\n\n    h = hsv[0];\n    s = hsv[1];\n    v = hsv[2];\n\n    if (s == 0.)\n    {\n        rgb = vec3(v, v, v);\n    }\n    else\n    {\n        if (h == 1.)\n        {\n            h = 0.;\n        }\n\n        h *= 6.;\n        int i = int(floor(h));\n        f = h - float(i);\n        rgb = vec3(f, f, f);\n        p = v * (1. - s);\n        q = v * (1. - (s * f));\n        t = v * (1. - (s * (1. - f)));\n\n        if (i == 0)\n        {\n            rgb = vec3(v, t, p);\n        }\n        else if (i == 1)\n        {\n            rgb = vec3(q, v, p);\n        }\n        else if (i == 2)\n        {\n            rgb = vec3(p, v, t);\n        }\n        else if (i == 3)\n        {\n            rgb = vec3(p, q, v);\n        }\n        else if (i == 4)\n        {\n            rgb = vec3(t, p, v);\n        }\n        else\n        {\n            rgb = vec3(v, p, q);\n        }\n    }\n\n    return rgb;\n}\n\nvec3 flim_blender_hue_sat(vec3 col, float hue, float sat, float value)\n{\n    vec3 hsv = flim_blender_rgb_to_hsv(col);\n\n    hsv[0] = fract(hsv[0] + hue + .5);\n    hsv[1] = clamp(hsv[1] * sat, 0., 1.);\n    hsv[2] = hsv[2] * value;\n\n    return flim_blender_hsv_to_rgb(hsv);\n}\n\nfloat flim_rgb_avg(vec3 col)\n{\n    return (col.x + col.y + col.z) / 3.;\n}\n\nfloat flim_rgb_sum(vec3 col)\n{\n    return col.x + col.y + col.z;\n}\n\nfloat flim_rgb_max(vec3 col)\n{\n    return max(max(col.x, col.y), col.z);\n}\n\nfloat flim_rgb_min(vec3 col)\n{\n    return min(min(col.x, col.y), col.z);\n}\n\nvec3 flim_rgb_uniform_offset(vec3 col, float black_point, float white_point)\n{\n    float mono = flim_rgb_avg(col);\n    float mono2 = flim_remap01(\n        mono, black_point / 1000.,\n        1. - (white_point / 1000.)\n    );\n    return col * (mono2 / mono);\n}\n\nvec3 flim_rgb_sweep(float hue)\n{\n    hue = flim_wrap(hue * 360., 0., 360.);\n\n    vec3 col = vec3(1, 0, 0);\n    col = mix(col, vec3(1, 1, 0), flim_remap01(hue, 0., 60.));\n    col = mix(col, vec3(0, 1, 0), flim_remap01(hue, 60., 120.));\n    col = mix(col, vec3(0, 1, 1), flim_remap01(hue, 120., 180.));\n    col = mix(col, vec3(0, 0, 1), flim_remap01(hue, 180., 240.));\n    col = mix(col, vec3(1, 0, 1), flim_remap01(hue, 240., 300.));\n    col = mix(col, vec3(1, 0, 0), flim_remap01(hue, 300., 360.));\n    \n    return col;\n}\n\nvec3 flim_rgb_exposure_sweep_test(vec2 uv0to1)\n{\n    float hue = 1. - uv0to1.y;\n    float exposure = flim_remap(uv0to1.x, 0., 1., -5., 10.);\n    return flim_rgb_sweep(hue) * pow(2., exposure);\n}\n\n// https://www.desmos.com/calculator/khkztixyeu\nfloat flim_super_sigmoid(\n    float v,\n    float toe_x,\n    float toe_y,\n    float shoulder_x,\n    float shoulder_y\n)\n{\n    // clip\n    v = clamp(v, 0., 1.);\n    toe_x = clamp(toe_x, 0., 1.);\n    toe_y = clamp(toe_y, 0., 1.);\n    shoulder_x = clamp(shoulder_x, 0., 1.);\n    shoulder_y = clamp(shoulder_y, 0., 1.);\n\n    // calculate straight line slope\n    float slope = (shoulder_y - toe_y) / (shoulder_x - toe_x);\n\n    // toe\n    if (v < toe_x)\n    {\n        float toe_pow = slope * toe_x / toe_y;\n        return toe_y * pow(v / toe_x, toe_pow);\n    }\n\n    // straight line\n    if (v < shoulder_x)\n    {\n        float intercept = toe_y - (slope * toe_x);\n        return slope * v + intercept;\n    }\n\n    // shoulder\n    float shoulder_pow =\n        -slope / (\n            ((shoulder_x - 1.) / pow(1. - shoulder_x, 2.))\n            * (1. - shoulder_y)\n        );\n    return\n        (1. - pow(1. - (v - shoulder_x) / (1. - shoulder_x), shoulder_pow))\n        * (1. - shoulder_y)\n        + shoulder_y;\n}\n\nfloat flim_dye_mix_factor(float mono, float max_density)\n{\n    // log2 and map range\n    float offset = pow(2., flim_sigmoid_log2_min);\n    float fac = flim_remap01(\n        log2(mono + offset),\n        flim_sigmoid_log2_min,\n        flim_sigmoid_log2_max\n    );\n\n    // calculate amount of exposure from 0 to 1\n    fac = flim_super_sigmoid(\n        fac,\n        flim_sigmoid_toe_x,\n        flim_sigmoid_toe_y,\n        flim_sigmoid_shoulder_x,\n        flim_sigmoid_shoulder_y\n    );\n\n    // calculate dye density\n    fac *= max_density;\n\n    // mix factor\n    fac = pow(2., -fac);\n\n    // clip and return\n    return clamp(fac, 0., 1.);\n}\n\nvec3 flim_rgb_color_layer(\n    vec3 col,\n    vec3 sensitivity_tone,\n    vec3 dye_tone,\n    float max_density\n)\n{\n    // normalize\n    vec3 sensitivity_tone_norm =\n        sensitivity_tone / flim_rgb_sum(sensitivity_tone);\n    vec3 dye_tone_norm = dye_tone / flim_rgb_max(dye_tone);\n\n    // dye mix factor\n    float mono = dot(col, sensitivity_tone_norm);\n    float mix_fac = flim_dye_mix_factor(mono, max_density);\n\n    // dye mixing\n    return mix(dye_tone_norm, vec3(1), mix_fac);\n}\n\nvec3 flim_rgb_develop(vec3 col, float exposure, float max_density)\n{\n    // exposure\n    col *= pow(2., exposure);\n\n    // blue-sensitive layer\n    vec3 result = flim_rgb_color_layer(\n        col,\n        vec3(0, 0, 1),\n        vec3(1, 1, 0),\n        max_density\n    );\n\n    // green-sensitive layer\n    result *= flim_rgb_color_layer(\n        col,\n        vec3(0, 1, 0),\n        vec3(1, 0, 1),\n        max_density\n    );\n\n    // red-sensitive layer\n    result *= flim_rgb_color_layer(\n        col,\n        vec3(1, 0, 0),\n        vec3(0, 1, 1),\n        max_density\n    );\n\n    return result;\n}\n\nvec3 flim_gamut_extension_mat_row(\n    float primary_hue,\n    float scale,\n    float rotate,\n    float mul\n)\n{\n    vec3 result = flim_blender_hsv_to_rgb(vec3(\n        flim_wrap(primary_hue + (rotate / 360.), 0., 1.),\n        1. / scale,\n        1.\n    ));\n    result /= flim_rgb_sum(result);\n    result *= mul;\n    return result;\n}\n\nmat3 flim_gamut_extension_mat(\n    float red_scale,\n    float green_scale,\n    float blue_scale,\n    float red_rot,\n    float green_rot,\n    float blue_rot,\n    float red_mul,\n    float green_mul,\n    float blue_mul\n)\n{\n    mat3 m;\n    m[0] = flim_gamut_extension_mat_row(\n        0.,\n        red_scale,\n        red_rot,\n        red_mul\n    );\n    m[1] = flim_gamut_extension_mat_row(\n        1. / 3.,\n        green_scale,\n        green_rot,\n        green_mul\n    );\n    m[2] = flim_gamut_extension_mat_row(\n        2. / 3.,\n        blue_scale,\n        blue_rot,\n        blue_mul\n    );\n    return m;\n}\n\nvec3 negative_and_print(vec3 col, vec3 backlight_ext)\n{\n    // develop negative\n    col = flim_rgb_develop(\n        col,\n        flim_negative_film_exposure,\n        flim_negative_film_density\n    );\n\n    // backlight\n    col *= backlight_ext;\n\n    // develop print\n    col = flim_rgb_develop(\n        col,\n        flim_print_film_exposure,\n        flim_print_film_density\n    );\n\n    return col;\n}\n\n// the flim transform\n\nvec3 flim_transform(vec3 col, float exposure, bool convert_to_srgb)\n{\n    // eliminate negative values\n    col = max(col, 0.);\n\n    // pre-Exposure\n    col *= pow(2., flim_pre_exposure + exposure);\n\n    // clip very large values for float precision issues\n    col = min(col, 5000.);\n\n    // gamut extension matrix (Linear BT.709)\n    mat3 extend_mat = flim_gamut_extension_mat(\n        flim_extended_gamut_red_scale,\n        flim_extended_gamut_green_scale,\n        flim_extended_gamut_blue_scale,\n        flim_extended_gamut_red_rot,\n        flim_extended_gamut_green_rot,\n        flim_extended_gamut_blue_rot,\n        flim_extended_gamut_red_mul,\n        flim_extended_gamut_green_mul,\n        flim_extended_gamut_blue_mul\n    );\n    mat3 extend_mat_inv = inverse(extend_mat);\n\n    // backlight in the extended gamut\n    vec3 backlight_ext = flim_print_backlight * extend_mat;\n\n    // upper limit in the print (highlight cap)\n    const float big = 10000000.;\n    vec3 white_cap = negative_and_print(vec3(big, big, big), backlight_ext);\n\n    // pre-formation filter\n    col = mix(\n        col,\n        col * flim_pre_formation_filter,\n        flim_pre_formation_filter_strength\n    );\n\n    // convert to the extended gamut\n    col *= extend_mat;\n\n    // negative & print\n    col = negative_and_print(col, backlight_ext);\n\n    // convert from the extended gamut\n    col *= extend_mat_inv;\n\n    // eliminate negative values\n    col = max(col, 0.);\n\n    // white cap\n    col /= white_cap;\n\n    // black cap (-1 = auto)\n    if (flim_black_point == -1.)\n    {\n        vec3 black_cap = negative_and_print(vec3(0.), backlight_ext);\n        black_cap /= white_cap;\n        col = flim_rgb_uniform_offset(\n            col,\n            flim_rgb_avg(black_cap) * 1000.,\n            0.\n        );\n    }\n    else\n    {\n        col = flim_rgb_uniform_offset(col, flim_black_point, 0.);\n    }\n\n    // post-formation filter\n    col = mix(\n        col,\n        col * flim_post_formation_filter,\n        flim_post_formation_filter_strength\n    );\n\n    // clip\n    col = clamp(col, 0., 1.);\n\n    // midtone saturation\n    float mono = flim_rgb_avg(col);\n    float mix_fac =\n        (mono < .5)\n        ? flim_remap01(mono, .05, .5)\n        : flim_remap01(mono, .95, .5);\n    col = mix(\n        col,\n        flim_blender_hue_sat(col, .5, flim_midtone_saturation, 1.),\n        mix_fac\n    );\n\n    // clip\n    col = clamp(col, 0., 1.);\n\n    // OETF\n    if (convert_to_srgb)\n    {\n        col = oetf_pow(col, 2.2);\n    }\n\n    return col;\n}\n\n/*____________________ end ____________________*/","name":"Common","description":"","type":"common"}]}