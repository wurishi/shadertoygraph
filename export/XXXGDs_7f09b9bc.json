{"ver":"0.1","info":{"id":"XXXGDs","date":"1708097716","viewed":83,"name":"noise fog raycaster","username":"Zentient","description":"Interpolation method for this is horrible, requiring 9 distance functions per octave, per ray step. It also suffers from lots of artifacts, but is slightly easier for my lizard brain to scale dimensionally than billinear filtering.","likes":1,"published":1,"flags":32,"usePreview":1,"tags":["whitenoise","hashing"],"hasliked":0,"parentid":"4XXGWX","parentname":"3d hash noise"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define hashi(x)   lowbias32(x)\n#define hash(x)  ( float( hashi(x) ) / float( 0xffffffffU ) )\n\nconst float kernelDia = 3.0; //odd numbers only\n\n//bias: 0.17353355999581582 ( very probably the best of its kind )\nuint lowbias32(uint x)\n{\n    x ^= x >> 16;\n    x *= 0x7feb352dU;\n    x ^= x >> 15;\n    x *= 0x846ca68bU;\n    x ^= x >> 16;\n    return x;\n}\n\n//Random function from: www.shadertoy.com/view/WttXWX\n\nfloat rand(vec3 position)\n{\n    uvec3 V = uvec3(position);\n    float h = hash( V.x + (V.y<<16) + (V.z<<8) );  // 2D hash (should be ok too )\n    return h;\n\n}\n\n\n\n//interpolation function\nfloat interpolate(vec3 position)\n{\n    vec3 quantPos = 0.0 + round((position));\n    float kernelRad = kernelDia / 2.0;\n    vec3 truePos = position;\n    vec3 divPos = fract(0.5 + (position));\n    float div = 0.0;\n    float grad = 0.0;\n    vec3 ix;\n    \n    for(ix.x = (kernelRad * -1.0); ix.x < kernelRad; ix.x++)\n    {\n         for(ix.y = (kernelRad * -1.0); ix.y < kernelRad; ix.y++)\n         {    \n             for(ix.z = (kernelRad * -1.0); ix.z < kernelRad; ix.z++)\n             {\n             vec3 quantScan = round((position + ix));\n             float dist = pow(distance(truePos, quantScan), 3.0);\n             div = div + 1.0 / dist;\n             grad = grad + (rand(quantScan)) / dist;\n             }\n         }\n    }\n    \n    return pow(grad / div, 2.0);\n    \n}\n\nfloat octave(vec3 coord, float octaves, float div)\n{\n    \n    float col = 0.0;\n    float it = 1.0;\n    float cnt = 1.0;\n    for(float i = 1.0; i <= octaves; i++)\n    {\n        col = col + interpolate((it * coord / (div)));// / it;\n        it = it * 2.0;\n        cnt = cnt + 1.0;// / it;\n       \n    }\n    return col / cnt;\n}\n\nvec3 rayCast(vec3 position, vec3 vector, float steps, float offset)\n{\n    float i = 0.0;\n    float vol = 0.0;\n    vec3 rayPos = position;\n    rayPos = rayPos + vector * offset;\n    float occ = 1.0;\n    for(i = 0.0; i <= steps; i++)\n    {\n        \n        //vol = vol + octave(abs(rayPos), 1.0, 1000.0);\n        float val = pow(octave(abs(rayPos), 4.0, 15.0), 2.0); //sin(rayPos.x * rayPos.y + rayPos.z);\n        if (val <= 0.5) {occ = occ + 1.0 / steps;}\n        vol = vol + val / (occ);\n        rayPos = rayPos + (3.0 * vector);\n        //if (val <= 0.01) {return vec3(vol);}\n        \n    }\n    return vec3(vol);\n\n}\n\nvoid mainImage( out vec4 fragColor, vec2 fragCoord )\n{\n   vec2 uv = fragCoord/iResolution.xy;\n   float offset = texture(iChannel1, fragCoord / 1024.0).b;\n   vec3 vector = texture(iChannel0, uv).rgb;\n   vec3 pos = vec3(300.0 * sin(0.1 * iTime));\n   vec3 col = rayCast(pos, vector, 10.0, 5.0 * offset);\n   fragColor = vec4(col, 1.0);\n    \n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//Camera vectors\nconst float FOV = 90.0 * 0.0174533;\n\nvoid mainImage( out vec4 viewVector, in vec2 fragCoord )\n{\n    vec2 rayD = FOV * ((fragCoord) / iResolution.x - 0.5);\n    vec3 rayV = vec3(cos(rayD.x), sin(rayD.x), sin(rayD.y));\n    viewVector = vec4(rayV.x, rayV.y , rayV.z, 1.0);\n}","name":"Buffer A","description":"","type":"buffer"}]}