{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[],"code":"void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 1.0 - 1.0; // Normalizacja do [-1, 1]\n    uv.x *= iResolution.x / iResolution.y; // Korekta proporcji ekranu\n\n    float time = iTime * 1.4;\n\n    // Wirujące pola energii\n    vec2 offset1 = vec2(sin(time), cos(time * 1.5)) * 0.3;\n    vec2 offset2 = vec2(cos(time * 0.8), sin(time * 1.2)) * 0.5;\n\n    // Złożone gradienty oparte na odległościach\n    float radius1 = length(uv - offset1);\n    float radius2 = length(uv + offset2);\n\n    // Efekty burz\n    float storm1 = sin(radius1 * 10.0 - time * 3.0) / (radius1 + 0.2);\n    float storm2 = sin(radius2 * 12.0 + time * 2.0) / (radius2 + 0.3);\n\n    // Kolory burz\n    vec3 color1 = vec3(1.0, 0.3, 0.6) * storm1;\n    vec3 color2 = vec3(0.2, 0.7, 1.0) * storm2;\n\n    // Dodanie \"wirowania\" energii\n    float swirl = sin(uv.x * 10.0 + uv.y * 10.0 - time * 2.0);\n    vec3 swirlColor = vec3(0.5, 0.2, 0.8) * swirl;\n\n    // Łączenie efektów\n    vec3 finalColor = color1 + color2 + swirlColor;\n\n    // Saturacja i delikatne światło\n    finalColor = pow(finalColor, vec3(1.2)); // Podbicie intensywności\n    finalColor *= 0.8 + 0.4 * sin(time * 1.5); // Pulsujące światło\n\n    fragColor = vec4(finalColor, 1.0);\n}\n","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"4fVfWw","date":"1734098318","viewed":14,"name":"323323323","username":"mgras","description":"3232","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["232"],"hasliked":0,"parentid":"","parentname":""}}