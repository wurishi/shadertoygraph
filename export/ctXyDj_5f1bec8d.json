{"ver":"0.1","info":{"id":"ctXyDj","date":"1691160366","viewed":109,"name":"Rolling polar unit circle","username":"ChunderFPV","description":"Cartesian & polar waves.  Mouse X to transform.","likes":10,"published":1,"flags":0,"usePreview":0,"tags":["waves","graph","plot","polar","transform","trigonometry"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define L(v) smoothstep(2.*min(fwidth(u.y-v), 1.), 0., abs(u.y-v))\n#define P(v) 1./length((v)/fwidth(v)/R.y*3e2)\n#define W \\\n          if (b_sin) c += L(sin(u.x))*c_sin*f; \\\n          if (b_cos) c += L(cos(u.x))*c_cos*f; \\\n          if (b_tan) c += L(tan(u.x))*c_tan*f; \\\n          if (b_csc) c += L(1./sin(u.x))*c_tan*f; \\\n          if (b_sec) c += L(1./cos(u.x))*c_sec*f; \\\n          if (b_cot) c += L(1./tan(u.x))*c_cot*f;\n\nvoid mainImage( out vec4 C, in vec2 U )\n{\n    float s = 6., // scale\n          pi = 3.1416,\n          t = .001+iTime*pi/10.,\n          a, b, f;\n    \n    // toggles\n    bool b_sin = true,\n         b_cos = true,\n         b_tan = true,\n         b_csc = true,\n         b_sec = true,\n         b_cot = true;\n    \n    // colors\n    vec3 c = vec3(0),\n         c_sin = vec3(.9, .2, .1),\n         c_cos = vec3(.1, .5, .9),\n         c_tan = vec3(.9, .7, .6),\n         c_csc = vec3(.9, .6, .9),\n         c_sec = vec3(.1, .7, .7),\n         c_cot = vec3(.9, .6, .1);\n    \n    vec2 R = iResolution.xy,\n         m = iMouse.xy/R, // mouse coords\n         u = (U-vec2(.6, .5)*R)/R.y*s, // screen coords\n         w = fwidth(u), // pixel size\n         g; // grid\n    \n    // snap to 0 & 1 when close\n    if (m.x < .1) m.x = 0.;\n    if (m.x > .9 || iMouse.z < 1.) m.x = 1.;\n    \n    c += .2*w.y/abs(u.y); // x axis\n    c += .2*w.x/abs(u.x); // y\n    \n    // points\n    if (b_sin) c += P(u-vec2(0, sin(t))) * c_sin;\n    if (b_cos) c += P(u-vec2(0, cos(t))) * c_cos;\n    if (b_tan) c += P(u-vec2(0, tan(t))) * c_tan;\n    if (b_csc) c += P(u-vec2(0, 1./sin(t))) * c_csc;\n    if (b_sec) c += P(u-vec2(0, 1./cos(t))) * c_sec;\n    if (b_cot) c += P(u-vec2(0, 1./tan(t))) * c_cot;\n    \n    u.x += t; // shift x with time\n    g = max(vec2(0), 1.-abs(u-round(u))/w/1.5); // standard grid\n    c += max(g.x, g.y)*.2; // grid lines\n    c += min(g.x, g.y)*.5; // grid points\n    \n    // waves\n    f = step(u.x-t, 0.)*m.x; // fade\n    W\n    \n    u.x -= t;\n    \n    c *= smoothstep(1., 0., u.x/s); // darken right bg\n    u = (1.-m.x)*u + m.x*vec2(atan(-u.x, u.y), length(u)); // polar transform\n    \n    a = smoothstep(2.*min(w.x, 1.), 0., abs(abs(u.y-1.)));\n    b = pi-mod(t+pi, pi*2.); // arc (theta)\n    c += a*.3;  // unit circle\n    c.g += a*step(max(0., u.x/b), min(u.x/b, 1.)); // arc length\n    c += P(u-vec2(b, 1.)) * .5;    // arc 0\n    c.g += P(u-vec2(0., 1.)) * .5; // arc length\n    \n    u.x += t;\n    \n    // polar waves\n    f = smoothstep(1., 0., abs(u.y)/s); // darken with distance\n    W\n    if (b_tan) c += L(-tan(u.x)) * c_tan * m.x * f;\n    if (b_cot) c += L(-1./tan(u.x)) * c_cot * m.x * f;\n    \n    C = vec4(c, 1);\n}","name":"Image","description":"","type":"image"}]}