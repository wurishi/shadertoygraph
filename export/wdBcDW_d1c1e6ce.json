{"ver":"0.1","info":{"id":"wdBcDW","date":"1586639170","viewed":64,"name":"glsl workshop from CharStiles","username":"mpinner","description":"converted from The Force","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["tutorial"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nconst float PI = 3.1415926535;\n\nfloat noise1d(float n){\n    return fract(cos(n*89.42)*343.42);\n}\nfloat noise2d(vec2 co){\n  return fract(sin(dot(co.xy ,vec2(1.0,73))) * 43758.5453);\n}\n\nvec2 hash2( vec2 p )\n{\n    return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\nvec2 rotate(in vec2 position,in vec2 center,in float angle)\n{\n    //Function seen from https://www.shadertoy.com/view/XlsGWf\n    float rot = radians(angle);\n    mat2 rotation = mat2(cos(rot), -sin(rot), sin(rot), cos(rot));\n    return vec2((position-center)*rotation);\n}\n\n// https://iquilezles.org/articles/distfunctions2d\nfloat equiTri(vec2 p){\n    float side = sqrt(3.0);\n    \n //   side = sqrt(10.0);\n //   side = sqrt(noise2d(p));\n    \n    p.x = abs(p.x) - 1.0;\n    p.y = p.y +1.0/side;\n    if(p.x + side*p.y > 0.0){\n        p = vec2(p.x - side*p.y, -side*p.x - p.y)/2.0;\n    }\n    p.x -= clamp(p.x,-2.0,0.0);\n    return -length(p)*sign(p.y);\n    \n}\n\n// https://iquilezles.org/articles/palettes\n// As t runs from 0 to 1 (our normalized palette index or domain), \n//the cosine oscilates c times with a phase of d. \n//The result is scaled and biased by a and b to meet the desired constrast and brightness.\nvec3 cosPalette( float t, vec3 a, vec3 b, vec3 c, vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nfloat sphere(vec2 p) {\n    float r = 2.0;\n//r = 5.2*noise2d(p);\n    return length(p)-r;\n}\n\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\n\n//void main () {\n//    vec2 pos = uv();\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 pos = uv;\n    \n    // vec2 rot = rotate(vec2(1.9, 1.9),  pos, time/10.0);\n    vec2 rot = rotate(vec2(0, 0),  pos, PI+sin(iTime)/10.0);\n    vec2 rot2 = rotate(vec2(0, 0),  pos, PI+sin(iTime)/-10.0);\n  //  pos = rot2;\n    \n     //vec2 rot = rotate(vec2(1.9, 1.9),  pos, time/10.0);\n    // pos.x += sin(noise(time))/10.0;\n\n    pos *= 4.0;\n    pos -= 2.0;\n    float shape = equiTri(rot);\n    //shape = clamp(shape, 0.1, 0.75);\n\n    float shape2 = sphere(pos);\n    \n    shape = smin(shape,shape2, 0.1);\n    \n\t//gl_FragColor = vec4(shape);\n\t\n\tvec3 a = vec3(0.5, 0.5, 0.9);\n\tvec3 b = vec3(0.5, 0.3, 0.5);\n\tvec3 c = vec3(2.0, 1.0, 10.0);\n\tvec3 d = vec3(0.0, 0.1, 0.25);\n\t\n\tvec3 col2 = cosPalette(0.5,vec3(0.5),vec3(0.5),vec3(1),vec3(iTime*0.1,iTime*0.1,iTime*.2));\n\tvec3 col = cosPalette(shape+(-iTime/10.0), a, b, c, d);\n// \t,vec3(0.5),vec3(0.5),vec3(1),vec3(time*0.01,time*0.1,time*.2));\n\n// \tfragColor = vec4(col2, 1);\n\tfragColor = vec4((vec3(col.x, col.y, col.z)), 1);\n// \tfragColor = vec4((vec3(pos.x, pos.y,1)), 1);\n// \tfragColor = vec4(hsv2rgb(vec3(pos.x, pos.y,0.5)), rand(1.0));\n// \tfragColor = vec4(hsv2rgb(vec3(pos.x, pos.y,.5)), rand(1.0));\n//\tfragColor = vec4(vec3(noise1d(pos[1]),noise2d(pos),0.5), 1.0);\n//\tfragColor = vec4(pos[0],pos[1],0.5, 1.0);\n}\n\n\n\n\n    \n//\tfragColor = vec4((vec3(pos.x, pos.y, .5)), 1);\n   \n    \n    \n\n\n","name":"Image","description":"","type":"image"}]}