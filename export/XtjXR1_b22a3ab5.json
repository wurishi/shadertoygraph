{"ver":"0.1","info":{"id":"XtjXR1","date":"1441631860","viewed":255,"name":"Circle Graph","username":"ridhojeftha","description":"A circle graph that has segments that increase in size according to its percentage","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["circlegraph"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[],"code":"//inverse of Pi to use for angle formula conversion\nconst float inversePi = 1.0 / 3.141592;\n\n//start - where the segment should start - normalised to (0, 1)\n//segLength - the length of the segment\n//distance = the distance from the pixel to the origin\n//radius - the inner radius\n//angle - the angle of the pixel around the circle\nfloat getCircleSegment(float start, float segLength, float distanceO, float radius, float angle)\n{\n  float circle;\n    \n  //the amount of blur to add for anti-aliasing\n  float blur = 0.005;\n    \n  float width = radius + segLength*0.5; //segment length determines the width\n \n  //add a circle\n  circle = smoothstep( width + blur, width - blur, distanceO); \n        \n  //subtract the hole from the centre\n  circle -= smoothstep(radius + blur, radius - blur, distanceO);\n    \n  //add the segment\n  float segment = smoothstep(start + segLength + blur*0.5, start + segLength - blur*0.5, angle);\n  segment -= smoothstep(start + blur*0.5,  start - blur*0.5, angle ); \n    \n    \n  circle *= mix( segment, 1.0, step( 1.0, segLength ) );\n    \n  return circle;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    float timeScale = 0.5;\n    \n    float p1 = 0.1 + 0.30 * abs (sin (iTime * timeScale)); //yellow\n\t\n    float p2 = 0.1 + 0.30 * abs (cos (iTime * timeScale)); //red\n    \n\tfloat p3 = 0.05 + 0.1 * abs (sin (iTime * timeScale)); //green\n    \n\tfloat p4 = 1.0 - (p1 + p2 + p3); //blue\n    \n    float radius = 0.35; //Range (0f, 1f]\n\tvec2 uv = fragCoord.xy / iResolution.xy; // calculate the texture coords\n    \n    // Convert from range [0,1] to [-1,1]\n    uv = 2.0 * uv - 1.0;\n    \n    // this line adjusts for the aspect ratio\n    uv.x *= (iResolution.x / iResolution.y);\n    \n    // distance to the Origin\n    float distanceO = length( uv );\n    \n    //calculate the angle for the segments uding formula\n\tfloat angle = atan( uv.x, uv. y ) * inversePi * 0.5;\n    \n     //can add ofsett here to rotate the circle\n    float offset = 0.0;//0.1 * iTime; //using time to make it rotate for demo purposes\n\tangle = fract( angle + offset );\n    \n    vec3 rgb;  \n    \n    //draw the four segments in different colours\n     rgb = vec3( 1.0, 1.0, 0.0) * getCircleSegment(0.0, p1, distanceO, radius, angle);        \n\t rgb += vec3( 1.0, 0.0, 0.0 ) * getCircleSegment(p1, p2, distanceO, radius, angle); \n \t rgb += vec3( 0.0, 1.4, 0.0 ) * getCircleSegment(p1+p2, p3, distanceO, radius, angle);  \n     rgb += vec3( 0.0, 0.0, 1.0 ) *  getCircleSegment(p1+p2+p3, p4, distanceO, radius, angle); \n  \n    fragColor = vec4( rgb, 1);    \n}","name":"","description":"","type":"image"}]}