{"ver":"0.1","info":{"id":"7s2XWh","date":"1620158368","viewed":212,"name":"Cubes fractal zoom","username":"Bleuje","description":"2 seconds long perfect loop","likes":16,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// by @etiennejcb\n// code can be messy and stupid, not optimized\n\n// Thanks tdhooper, iq, leon, FabriceNeyret2 and others\n\n// most important parameters\n#define motionBlur 1.0 // (integer)\n#define duration 2.0\n#define AA false\n\n// others\n#define nbIterations 6.0\n#define ratio 4.0\n\nfloat time;\n\n// volumes description\nVolume map(vec3 pos)\n{\n    float L = 0.01;\n    float scene = 100.;\n\n    Volume white;\n    white.mat = 1;\n    // (unused)\n    \n    Volume black;\n    black.mat = 2;\n    \n    white.dist = 100.0;\n    \n    \n    \n    for(float it=0.0;it<nbIterations;it+=1.0)\n    {\n        vec3 p = pos;\n        \n        float rit = (it+time)*TAU*0.125;\n\n        p.yz *= rot(TAU*0.08);\n        p.xz *= rot(rit);\n        p.y += -2.4+0.8325*L*pow(ratio,it+time);\n        \n        float curL = L/2.0*pow(ratio,it+time);\n        \n        //float boxDist = max(sdBox(p,vec3(curL)),-sdBox(p,vec3(curL)));\n        float boxDist = sdBox(p,vec3(curL));\n        \n        if(boxDist<scene)\n        {\n            scene = boxDist;\n            black.dist = scene;\n            black.iteration = it+time;\n            \n            float eps = 0.;\n            \n            float nbSquares = 6.0;\n            \n            float borderFactor = 0.96;\n            \n            float indX = floor(nbSquares*p.x/curL/2.0*borderFactor);\n            float indY = floor(nbSquares*p.y/curL/2.0*borderFactor);\n            float indZ = floor(nbSquares*p.z/curL/2.0*borderFactor);\n            \n            if(abs(p.x)<=curL+eps&&abs(p.y)<=curL+eps)\n            {\n                black.surfaceType = int(mod(indX+indY,2.0));\n                black.face = vec3(0.,0.,p.z>0.?1.:-1.);\n                black.facePos = p.xy/curL;\n            }\n            else if(abs(p.y)<=curL+eps&&abs(p.z)<=curL+eps)\n            {\n                black.surfaceType = int(mod(indY+indZ,2.0));\n                black.face = vec3(p.x>0.?1.:-1.,0.,0.);\n                black.facePos = p.yz/curL;\n            }\n            else\n            {\n                black.surfaceType = int(mod(indX+indZ,2.0));\n                black.face = vec3(0.,p.y>0.?1.:-1.,0.);\n                black.facePos = p.xz/curL;\n            }\n        }\n    }\n    \n    \n    \n    Volume volume = select(white,black);\n\n    return volume;\n}\n\n// NuSan\n// https://www.shadertoy.com/view/3sBGzV\nvec3 getNormal(vec3 p) {\n\tvec2 off=vec2(0.001,0);\n\treturn normalize(map(p).dist-vec3(map(p-off.xyy).dist, map(p-off.yxy).dist, map(p-off.yyx).dist));\n}\n\nfloat activation(Volume volume,float pw)\n{\n    float eps = 0.1;\n    float len0 = max(abs(volume.facePos.x),abs(volume.facePos.y));\n    if(len0>1.0+eps) return 0.0;\n    float len = abs(volume.facePos.x) + abs(volume.facePos.y);\n    return 1.0*pow((0.5+0.5*sin(TAU*(1.7*volume.iteration + 0.*3.*atan(volume.facePos.y,volume.facePos.x)/TAU- 1.6*len))),pw);    \n}\n\nvec3 finishColor(float travel, float shade, float glow, Volume volume, vec3 normal, vec3 col)\n{\n    vec3 seed2 = volume.face*100.0;\n    \n    float act = 0.15+activation(volume,40.0);\n    \n    float scl = 12.0;\n    \n    col = vec3(0.);\n    \n    if(volume.surfaceType==1) col += vec3(0.8);\n    else\n    {\n        for(int i=0;i<4;i++){\n            float val = simplex3d(vec3(123.456*float(i)+seed2.x+scl*volume.facePos.x,seed2.y+scl*volume.facePos.y,seed2.z+0.7*(volume.iteration)));\n            val = smoothstep(0.57,0.7,val);\n            col += val*vec3(1.0);\n        }\n\n        col += smoothstep(0.95,0.98,act)*vec3(1.0);\n    }\n    \n    /*\n    vec2 f = volume.facePos;\n    float distBorder = min(abs(abs(f.x)-1.0),abs(abs(f.y)-1.0));\n    float borderLight = smoothstep(0.009,0.003,distBorder);\n    col += vec3(borderLight);\n    */\n    \n    //col *= pow(dot(vec3(-1.0,1.0,1.0),normal)*0.3+0.5,0.3);\n    //col *= 1.0-smoothstep(nbIterations-2.0,nbIterations,volume.iteration);\n    col *= smoothstep(0.,1.0,volume.iteration);\n    //col += vec3(0.5,0.8,1.2)*shade;\n    col += vec3(1.0)*pow(1.13*glow,1.8);\n    return clamp(col,0.,1.);\n}\n\nvoid mainImage0( out vec4 color, in vec2 coordinate )\n{\n    color = vec4(0);\n    // coordinates\n    vec2 uv = coordinate / iResolution.xy;\n    vec2 p = 2.*(coordinate - 0.5 * iResolution.xy)/iResolution.y;\n    \n    // camera\n    vec3 cameraPos = vec3(0,0,-5);\n    \n    // look at\n    vec3 z = normalize(vec3(0,0,0)-cameraPos);\n    vec3 x = normalize(cross(z, vec3(0,1,0)));\n    vec3 y = normalize(cross(x, z));\n    vec3 ray = normalize(z * 1.5 + x * p.x + y * p.y);\n    \n    float mb = motionBlur;\n    \n    for(float it=0.0;it<mb;it++){\n    \n        time = mod(iTime,duration)/duration - it*0.017/mb;\n    \n        // render variables\n        float shade = 0.0;\n        vec3 normal = vec3(0,1,0);\n        float ao = 1.0;\n        float rng = hash12(coordinate + time);\n        const int count = 40;\n        float travel = 0.0;\n        float glow = 0.0;\n        vec3 col;\n        \n        vec3 pos = cameraPos;\n        \n        int index;\n        \n        Volume volume;\n\n        // raymarch iteration\n        for (index = 0; index < count; ++index)\n        {\n            volume = map(pos);\n\n            // accumulate fullness\n            shade += 0.5/float(60);\n\n            // step further on edge of volume\n            normal = getNormal(pos);\n            \n            if(volume.dist>0.001){\n                volume.dist *= 0.9+0.1*rng;\n\n                // keep marching\n                pos += ray * volume.dist;\n                travel += volume.dist;\n                \n                if(volume.dist<0.65)\n                {\n                    float nf = 0.6+2.0*pow(abs(dot(normal,ray)),1.7);\n\n                    glow += (0.027+0.07*activation(volume,4.0))*nf;\n                    \n                    if(volume.surfaceType==1) glow += 0.03;\n                }\n            }\n            else\n            {\n\n                // coloring\n                col = vec3(0);\n                switch (volume.mat)\n                {\n                    case mat_bright:\n                    col = vec3(1.3);\n                    break;\n\n                    case mat_dark:\n                    col = vec3(0.25);\n                    \n                    \n                    break;\n                }\n\n                break;\n\n            }\n        }\n        \n        if(index==count)\n        {\n            col = vec3(0.0);\n        }\n        color.rgb += finishColor(travel, shade, glow, volume, normal, col);\n    }\n    \n    color.rgb /= mb;\n}\n\n// smart AA, from FabriceNeyret2\nvoid mainImage(out vec4 O, vec2 U) {\n    mainImage0(O,U);\n    if(AA)\n    if ( fwidth(length(O)) > .01 ) {  // difference threshold between neighbor pixels\n        vec4 o;\n        for (int k=0; k < 9; k+= k==3?2:1 )\n          { mainImage0(o,U+vec2(k%3-1,k/3-1)/3.); O += o; }\n        O /= 9.;\n     // O.r++;                        // uncomment to see where the oversampling occurs\n    }\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define PI 3.14159\n#define TAU (2.*PI)\n\nfloat repeat (float v, float c) { return mod(v,c)-c/2.; }\nvec2 repeat (vec2 v, vec2 c) { return mod(v,c)-c/2.; }\nvec3 repeat (vec3 v, float c) { return mod(v,c)-c/2.; }\n\n// details about sdf volumes\nstruct Volume\n{\n    float dist;\n    int mat;\n    int surfaceType;\n    float iteration;\n    vec3 face;\n    vec2 facePos;\n};\n\n// union operation between two volume\nVolume select(Volume a, Volume b)\n{\n    if (a.dist < b.dist) return a;\n    return b;\n}\n\n// materials\nconst int mat_bright = 1;\nconst int mat_dark = 2;\n\n// Rotation 2D matrix\nmat2 rot(float a) { float c = cos(a), s = sin(a); return mat2(c,-s,s,c); }\n\n// Dave Hoskins\n// https://www.shadertoy.com/view/4djSRW\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n// Inigo Quilez\n// https://iquilezles.org/articles/distfunctions\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n\n// 3d simplex noise from https://www.shadertoy.com/view/XsX3zB\n\n/* discontinuous pseudorandom uniformly distributed in [-0.5, +0.5]^3 */\nvec3 random3(vec3 c) {\n\tfloat j = 4096.0*sin(dot(c,vec3(17.0, 59.4, 15.0)));\n\tvec3 r;\n\tr.z = fract(512.0*j);\n\tj *= .125;\n\tr.x = fract(512.0*j);\n\tj *= .125;\n\tr.y = fract(512.0*j);\n\treturn r-0.5;\n}\n\n/* skew constants for 3d simplex functions */\nconst float F3 =  0.3333333;\nconst float G3 =  0.1666667;\n\n/* 3d simplex noise */\nfloat simplex3d(vec3 p) {\n\t /* 1. find current tetrahedron T and it's four vertices */\n\t /* s, s+i1, s+i2, s+1.0 - absolute skewed (integer) coordinates of T vertices */\n\t /* x, x1, x2, x3 - unskewed coordinates of p relative to each of T vertices*/\n\t \n\t /* calculate s and x */\n\t vec3 s = floor(p + dot(p, vec3(F3)));\n\t vec3 x = p - s + dot(s, vec3(G3));\n\t \n\t /* calculate i1 and i2 */\n\t vec3 e = step(vec3(0.0), x - x.yzx);\n\t vec3 i1 = e*(1.0 - e.zxy);\n\t vec3 i2 = 1.0 - e.zxy*(1.0 - e);\n\t \t\n\t /* x1, x2, x3 */\n\t vec3 x1 = x - i1 + G3;\n\t vec3 x2 = x - i2 + 2.0*G3;\n\t vec3 x3 = x - 1.0 + 3.0*G3;\n\t \n\t /* 2. find four surflets and store them in d */\n\t vec4 w, d;\n\t \n\t /* calculate surflet weights */\n\t w.x = dot(x, x);\n\t w.y = dot(x1, x1);\n\t w.z = dot(x2, x2);\n\t w.w = dot(x3, x3);\n\t \n\t /* w fades from 0.6 at the center of the surflet to 0.0 at the margin */\n\t w = max(0.6 - w, 0.0);\n\t \n\t /* calculate surflet components */\n\t d.x = dot(random3(s), x);\n\t d.y = dot(random3(s + i1), x1);\n\t d.z = dot(random3(s + i2), x2);\n\t d.w = dot(random3(s + 1.0), x3);\n\t \n\t /* multiply d by w^4 */\n\t w *= w;\n\t w *= w;\n\t d *= w;\n\t \n\t /* 3. return the sum of the four surflets */\n\t return dot(d, vec4(52.0));\n}","name":"Common","description":"","type":"common"}]}