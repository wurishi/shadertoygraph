{"ver":"0.1","info":{"id":"fd3yRS","date":"1653577291","viewed":83,"name":"creepy donuts","username":"axelduch","description":"Tried to make them look alive","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["3d","sdf","torus","texture","abstract"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS 70\n#define MAX_DIST 50.\n#define SURF_HIT 0.005\n#define EPSILON 0.001\n\n\nconst float PI = 3.1415926535897932384626433832795;\n\n// Rotation matrix around the Y axis.\nmat3 rotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, 0, s),\n        vec3(0, 1, 0),\n        vec3(-s, 0, c)\n    );\n}\n\n// Rotation matrix around the Z axis.\nmat3 rotateZ(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, -s, 0),\n        vec3(s, c, 0),\n        vec3(0, 0, 1)\n    );\n}\n\n\nfloat sphere(vec3 p, float radius) {\n    return length(p) - radius;\n}\n\n\nfloat torus( vec3 p, vec2 t ) {\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n\nvec3 map_texture(vec3 p) {\n    return texture(iChannel0, p.xz * .5 + iTime * .05).xyz * .01;\n}\n\n\nfloat dist_field(vec3 p) {\n    float c = 0.5;\n    return torus(mod(\n        c * .5 + iTime * .1 + .5 + vec3(p.x + .2, p.y - .3, p.z + iTime * .0001)\n        * rotateY(p.y * 0.02)\n        * rotateZ(p.z * .3) - .5 * c, c) \n        - map_texture(p)\n        - c * .5,\n        vec2(0.2, abs(cos(iTime*6.+p.x*1.*p.z*10.) * 0.004 + .06)));\n}\n\n\nfloat ray_march(vec3 ro, vec3 rd) {\n    float dist = 0.0f;\n    \n    for (int i = 0; i < MAX_STEPS; i++) {\n        vec3 p = ro + rd * dist;\n        float _dist = dist_field(p);\n        \n        dist += _dist;\n        \n        if (_dist < SURF_HIT || dist > MAX_DIST) break;\n    }\n    \n    return dist;\n}\n\n\nvec3 get_normal(vec3 p) {\n    vec2 eps = vec2(EPSILON, 0.);\n    float d = dist_field(p);\n    vec3 n = vec3(\n        d - dist_field(p - eps.xyy),\n        d - dist_field(p - eps.yxy),\n        d - dist_field(p - eps.yyx)\n    );\n    \n    return normalize(n);\n}\n\n\nfloat get_light(vec3 light_pos, vec3 p, float spec_pow) {\n    vec3 l = normalize(light_pos - p);\n    vec3 n = get_normal(p);\n    float diffuse = max(dot(n, l), 0.);\n    float specular = pow(max(dot(l, reflect(-l, n)), 0.), spec_pow);\n    \n    float d = ray_march(p + n * 2. * SURF_HIT, l);\n    if (d < length(light_pos - p)) {\n        diffuse *= .1;\n        specular = .1;\n    }\n    \n    return diffuse + specular;\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    vec3 eye = vec3(.1, .6,-0.3);\n    vec3 eye_dir = vec3(uv, cos(iTime * 0.1));\n    \n    float d = ray_march(eye, eye_dir);\n    vec3 p = eye + eye_dir * d;\n    vec3 sky = vec3(\n           .2 * p.x,\n           .4 * p.y,\n           .5\n    );\n    vec3 col = sky * 1.;\n    \n    vec3 light_pos = eye - .2;\n    vec3 light_pos1 = eye + .2;\n    float light = get_light(light_pos, p, 64.);\n    float light1 = get_light(light_pos1, p, 32.);\n    \n    if (d <= MAX_DIST) {\n        col *= light + light1;\n    } else {\n        col = sky;\n    }\n    \n    col = pow(col, vec3(.4545));\n    \n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}