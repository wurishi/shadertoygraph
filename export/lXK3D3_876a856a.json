{"ver":"0.1","info":{"id":"lXK3D3","date":"1718350463","viewed":49,"name":"Scales of Randomness","username":"HexPrism33","description":"Came Accross This while studying flow fields","likes":1,"published":1,"flags":32,"usePreview":0,"tags":["procedural","buffers"],"hasliked":0,"parentid":"M3K3zK","parentname":"Cool Slider Like Thing"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord/iResolution.xy);\n//    vec4 col = 0.1+0.8*texture(iChannel0,uv);\n\n    vec4 col = texture(iChannel0,uv);\n    //col *= 10.;\n    //col = pow(col, vec4(.7));\n    col = col  * vec4(1.,0.,0.,1.0);\n    fragColor = col;\n\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// -- tweakable parameters --\n// size of particles\n#define PARTICLE_SIZE 0.04\n// amount of particles\n#define PARTICLES 128\n// opacity of particles\n#define OPACITY 1.0\n// step size per frame\n#define STEP_SIZE 0.002\n// scale of the noise function used for the curls\n#define FIELD_SCALE 2.5\n// offset of the noise function for variety\n#define FIELD_OFFSET vec2(0, 0)\n// if defined, use curl field else just noise field\n//#define CURL\n// if defined, particles have the given probability to teleport to a random position each frame (the closer to 0 the longer the paths)\n#define RESET_PROB 0.02\n// if 2, the mouseposition modifies the distortion if 1 it doesn't and if 0 it is the only distortion\n#define MOUSE 1\n// if defined, the image appears white with black dots, else, it's the other way around\n#define LIGHT_MODE\n// if defined, the particles are reset when out of bounds\n//#define RESET_OUTOFBOUNDS\n// if defined, a subtle blur is added to the older lines.\n//#define BLUR\n// if defined a vignette effect is added\n//#define VIGNETTE\n\n\n// -- helper functions and definitions --\n\n// reset key\nconst int R = 82;\n\n// indexing of the position buffer (Buffer A)\nivec2 idxToPos(int i, int width) {return ivec2(i / width, i % width);}\nint posToIdx(ivec2 i, int width) {return i.x * width + i.y;}\n\n\n// -- noise functions --\n\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\nvec2 hash22(vec2 co) {\n    return fract(sin(vec2(dot(co,vec2(167.1,311.7)),dot(co,vec2(269.5,183.3))))*737.5453);\n}\n\nfloat smoother(float t) {\n    t = clamp(t, 0.0, 1.0);\n    // 6t^{5}-15t^{4}+10t^{3}; polynomial used for smooth interpolation (from the same family of curves as the smoothstep function)\n    // this function has a continuous second derivative which makes it very useful for many applications\n    return 6.0*(t*t*t*t*t) - 15.0*(t*t*t*t) + 10.0*(t*t*t);\n}\n\nfloat perlin2d(vec2 p) {\n    vec2 i = floor(p);\n    vec2 j = ceil(p);\n    vec2 f = fract(p);\n    \n    //float su = smoothstep(uv.x, 0.0, 1.0);\n    //float sv = smoothstep(uv.y, 0.0, 1.0);\n    float su = smoother(f.x);\n    float sv = smoother(f.y);\n\n    float n0 = (1.-su)*dot(normalize(hash22(vec2(i.x, i.y))*2.-1.), f)\n                 + su *dot(normalize(hash22(vec2(j.x, i.y))*2.-1.), f-vec2(1, 0));\n    float n1 = (1.-su)*dot(normalize(hash22(vec2(i.x, j.y))*2.-1.), f-vec2(0, 1))\n                 + su *dot(normalize(hash22(vec2(j.x, j.y))*2.-1.), f-1.);\n    \n    return (1.-sv)*n0 + sv*n1;\n}\n\n// had to define them as macros because iMouse and iResolution are not defined in the \"Common\" Tab\n#define mouse_to_world(p) (iMouse.xy/iResolution.xy-(p)/vec2(iResolution.x/iResolution.y, 1.0))*vec2(iResolution.x/iResolution.y, 1.0)\n#if MOUSE == 2\n#define distortion(p) (perlin2d((p).xy * FIELD_SCALE + FIELD_OFFSET)*(clamp(length(mouse_to_world(p)), 0.0,0.4)*2.5-1.)*2.0)\n#elif MOUSE == 1\n#define distortion(p) (perlin2d((p).xy * FIELD_SCALE + FIELD_OFFSET))\n#else\n#define distortion(p) (clamp(length(mouse_to_world(p)), 0.0, 0.5)*2.-.5)\n#endif\n\n#define EPS 0.0001\n#ifdef CURL\n// the raw code of this function is commented out at the bottom (curl())\n#define field(p) normalize(vec2((distortion((p) + vec2(0,EPS)) - distortion((p) - vec2(0,EPS)))/(2.0 * EPS), -(distortion((p) + vec2(EPS,0)) - distortion((p) - vec2(EPS,0)))/(2.0 * EPS)))*4.0\n#else\nvec2 field(vec2 p) {\n    return normalize(vec2(perlin2d(p*FIELD_SCALE+FIELD_OFFSET), perlin2d(p*FIELD_SCALE + FIELD_OFFSET + 100.)))*2.;\n}\n#endif\n\n\n\n/*\nvec2 curl(vec2 p) {\n    // source: https://al-ro.github.io/projects/curl/\n    \n    float eps = 0.0001;\n    vec2 r = vec2(0);\n    \n    float n1 = distortion(vec2(p.x + eps, p.y));\n    float n2 = distortion(vec2(p.x - eps, p.y));\n    \n    r.y = (n1 - n2)/(2.0 * eps);\n\n    n1 = distortion(vec2(p.x, p.y + eps));\n    n2 = distortion(vec2(p.x, p.y - eps));\n\t\n    r.x = (n1 - n2)/(2.0 * eps);\n    return vec2(r.x, -r.y);\n}*/","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"float rand(float x){\n    return  fract(sin(x) * 437862.45678);\n}\n\nvec2 getRandVec(vec2 pos,float time){\n    float _r = rand(dot(pos,vec2(12.989845,78.23334)));\n    float angle = 6.283185 * _r + 4.0 * time * _r;\n    return vec2(cos(angle),sin(angle));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 col;\n    vec2 uv = (fragCoord/iResolution.xy);//+ vec2((iResolution.y - iResolution.x) / iResolution.y / 2.0, 0));\n\n    uv.y *= iResolution.y/iResolution.x;\n\n    uv *= 10.;\n    uv = fract(uv);\n    // rendering the dots\n    float minDist = .1;\n    for (int i = 0; i < PARTICLES; i++) {\n        ivec2 a =  idxToPos(i, int(iResolution.y));\n        vec2 p = getRandVec(floor(uv*10.),iTime);\n        minDist = min(minDist, length(uv-p));\n    }\n    \n\n    if ((iFrame == 0) || bool(texelFetch(iChannel2, ivec2(R, 0), 0).x)){\n        col = vec4(0);\n    } else {\n        col = texture(iChannel1,(fragCoord/iResolution.xy)\n#ifdef BLUR\n        // adding a small amount to the coordinates adds a subtle blur to the old lines\n        +0.000006*(iFrame%2==0?-1.0:1.0)\n#endif\n        );\n    }\n    col = col + (1.-col) * vec4(OPACITY*smoothstep(PARTICLE_SIZE + 0.0015, PARTICLE_SIZE - 0.0015, minDist));\n    \n    // damping\n    col = col*0.996;\n    \n    // col = vec3(texelFetch(iChannel0, ivec2(fragCoord), 0));\n\n    fragColor = col;\n}","name":"Buffer A","description":"","type":"buffer"}]}