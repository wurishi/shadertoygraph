{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"const float PI=3.14159265358979323846;\nfloat r = .1;\n\nfloat Power =8.0;\n\nfloat marched = 0.0;\nfloat scale = .0;\nfloat min_distance = 1.0;\nfloat max_distance = 3.2;\n\n\nvec2 rotate(vec2 k,float t)\n\t{\n\treturn vec2(cos(t)*k.x-sin(t)*k.y,sin(t)*k.x+cos(t)*k.y);\n\t}\n\nfloat sphere( vec3 pos){\nvec3 z = pos;\n\t\n\t//Power += 2.0;\n\t\n\tfloat dr = .4;\n\tfloat r = 0.0;\n\tfor (int i = 0; i < 8 ; i++) {\n\t\tr = length(z);\n\t\tif (r>2.0) break;\n\t\t\n\t\t// convert to polar coordinates\n\t\tfloat theta = acos( z.z/r );\nfloat phi = atan( z.y,z.x );\n\t\tdr =  pow( r, Power-1.0)*Power*dr + 2.0;\n\t\t\n\t\t// scale and rotate the point\n\t\tfloat zr = pow( r,Power);\n\t\ttheta = theta*Power;\n\t\tphi = phi*Power;\n\t\t\n\t\t// convert back to cartesian coordinates\n\t\tz = (vec3(sin(theta)*cos(phi), sin(phi)*sin(theta), cos(theta))*zr);\n\n\t\tz+=pos;\n\t}\n\treturn 0.5*log(r)*r/dr;\n}\n\nfloat rm(vec3 origin, vec3 ray) {\n\tfloat distance_marched = min_distance;\n\n\tfor (int i=0; i<80; i++) {\n\t\t\n\t\tfloat step_distance = sphere(origin + ray*distance_marched);\n\t\tif (abs(step_distance) < 0.009 ) {\n\t\t\treturn distance_marched/(max_distance-min_distance);\n\t\t}\n\t\tdistance_marched += step_distance;\n\t\tmarched = distance_marched;\n\t\tif (distance_marched > max_distance) {\n\t\t\treturn -1.0;\n\t\t}\n\t}\n\treturn -1.0;\n}\n\nvec3 render(vec2 q) {\n    float time = sin (iTime)*.4;\n    float speed=iTime*0.2975;\n\tvec3 eye = vec3(0.0, .2, -3.0 + time/ 2.0 );\n\tvec3 screen = vec3(q,1.0);\n\tvec3 ray = normalize(screen - eye);\n\tray.yz=rotate(ray.yz,PI*0.11*sin(speed*0.825));\t// rotation x\n\tray.zx=rotate(ray.zx,-PI*time*0.25);\t\t\t\t// rotation y\n\tray.xy=rotate(ray.xy,speed*PI*.2);\t\t\t\t\t// rotation z\n\nfloat s = rm(eye, ray);\n\t\n\tvec3 col;\n\t\n\tif (s == -1.0) {\n\t\t\t\tcol =  vec3(0.0);\n\n\t} else {\n\t\n   \t\tcol = vec3(s-.8*.8+0.4*q.y *sin(q.x))*marched/1.76;\n\t\tcol.rg *= marched*.83;\n\t\t\n\t}\n\t\n\treturn col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 q = (fragCoord.xy*2.0 - iResolution.xy) / iResolution.y;\n\t\n\tvec3 col = render(q);\n\tq.x=col.x;\n\tq.y=col.y;\t\n//  vec3 col2 = texture( iChannel0,q ).xyz;\n  fragColor = vec4(col,1.0); \t\n//\tfragColor = vec4(sin(col.xyz+col2), 1.0);\n}\n","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"lslXzN","date":"1398000301","viewed":161,"name":"Dieselman","username":"rebb","description":"simple iteration over mandelbulb","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["fractal"],"hasliked":0,"parentid":"","parentname":""}}