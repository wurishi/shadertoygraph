{"ver":"0.1","info":{"id":"4Xf3Dr","date":"1707324237","viewed":45,"name":"Fork GM Shaders applegod 199","username":"applegod","description":"Taken from Xor article [url=mini.gmshaders.com/p/oklab]newest shader tutorial[/url]","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["colorspace","oklab","gmshaders"],"hasliked":0,"parentid":"ct3Bzj","parentname":"GM Shaders: OkLab"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n    \"GM Shaders: OkLab\" by @XorDev\n    \n    Written for my newest shader tutorial:\n    mini.gmshaders.com/p/oklab\n\n    Top:    sRGB color blending (most standard practice)\n    Middle: Linear color blending (most phyiscally accurate for blurs)\n    Bottom: OkLab color blending (most perceptually consistent)\n*/\n\n//Number of shaded cells\n#define SHADES 7.0  //0.0\n#define GAMMA 2.2\n\n//Classic gamma correction functions\nvec3 linear_from_srgb(vec3 rgb)\n{\n    return pow(rgb, vec3(GAMMA));\n}\nvec3 srgb_from_linear(vec3 lin)\n{\n    return pow(lin, vec3(1.0/GAMMA));\n}\n\nfloat sdBox(in vec2 p, in vec2 b)\n{\n    vec2 d = abs(p) - b;\n    return length(max(d, 0.0)) + min(max(d.x, d.y), 0.0);\n}\n//By Inigo Quilez, under MIT license\n//https://www.shadertoy.com/view/ttcyRS\nvec3 oklab_mix(vec3 lin1, vec3 lin2, float a)\n{\n    // https://bottosson.github.io/posts/oklab\n    const mat3 kCONEtoLMS = mat3(                \n         0.4121656120,  0.2118591070,  0.0883097947,\n         0.5362752080,  0.6807189584,  0.2818474174,\n         0.0514575653,  0.1074065790,  0.6302613616);\n    const mat3 kLMStoCONE = mat3(\n         4.0767245293, -1.2681437731, -0.0041119885,\n        -3.3072168827,  2.6093323231, -0.7034763098,\n         0.2307590544, -0.3411344290,  1.7068625689);\n                    \n    // rgb to cone (arg of pow can't be negative)\n    vec3 lms1 = pow( kCONEtoLMS*lin1, vec3(1.0/3.0) );\n    vec3 lms2 = pow( kCONEtoLMS*lin2, vec3(1.0/3.0) );\n    // lerp\n    vec3 lms = mix( lms1, lms2, a );\n    // gain in the middle (no oklab anymore, but looks better?)\n    lms *= 1.0+0.2*a*(1.0-a);\n    // cone to rgb\n    return kLMStoCONE*(lms*lms*lms);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    //Divide into shaded cells\n    if (SHADES > 0.0)\n    {\n        uv.x = floor(uv.x*SHADES) / (SHADES-1.0);\n    }\n    \n    //Pseudo random colors\n    vec3 rgb1 = vec3(0., 0.2, .9);\n    vec3 rgb2 = vec3(0., 0.3, .5);\n    \n    //Convert to linear color space\n    vec3 lin1 = linear_from_srgb(rgb1);\n    vec3 lin2 = linear_from_srgb(rgb2);\n    \n    //Interpolate in sRGB (most common)\n    vec3 rgb = mix(rgb1, rgb2, uv.x);\n    \n    //Interpolate in linear, convert to sRGB\n    vec3 lin = srgb_from_linear(mix(lin1, lin2, uv.x));\n    \n    //Interpolate in OkLab, convert to sRGB\n    vec3 okl = srgb_from_linear(oklab_mix(lin1, lin2, uv.x));\n    \n       \n    //Display sRGB on the top\n    vec3 col = rgb;\n    //Display Linear in the middle\n    col = uv.y>.67? col : lin;\n    //Display OkLab on the bottom\n    col = uv.y>.33? col : okl;\n    \n    vec3 clampedOkl = okl;\n    clampedOkl.x = clamp(clampedOkl.x, 0., 1.);\n    clampedOkl.y = clamp(clampedOkl.y, 0., 1.);\n    clampedOkl.z = clamp(clampedOkl.z, 0., 1.);\n    \n    float box = step(0.001, sdBox(uv , vec2(1., 0.5)));\n    //if i mix clamped Oklab and white - it turns purple\n    col = mix(vec3(1.), clampedOkl, box);\n    //if i mix clamped Oklab and not clamped Oklab - seems the same\n    //col = mix(okl, clampedOkl, box);\n    \n    //Display sRGB output\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}