{"ver":"0.1","info":{"id":"mltyRM","date":"1699021629","viewed":65,"name":"binary gcd","username":"jt","description":"Uses the [url=https://en.wikipedia.org/wiki/Binary_GCD_algorithm]binary GCD[/url] to subdivide a rectangle into the greatest possible square tiles. Change the resolution of the window (e.g. fullscreen) to see a different result or use the mouse.","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["binary","algorithm","euclidean","subdivision","gcd","common","steins","greatest","divisor"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// https://www.shadertoy.com/view/mltyRM binary gcd, 2023 by jt\n\n// Uses the https://en.wikipedia.org/wiki/Binary_GCD_algorithm binary GCD\n// to draw a checker pattern with the biggest possible square tiles.\n// Change the resolution of the window (e.g. fullscreen) to see a different result\n// or use the mouse.\n// The complexity of the binary GCD algorithm is linear to the number of bits of the input.\n// This can be used in procedural generation to fit square patterns in rectangular boxes,\n// like in https://www.shadertoy.com/view/mltyzM asymmetric blocks gcd subdivided\n\n// tags: binary, algorithm, euclidean, gcd, common, steins, greatest, divisor\n\n// adapted from: https://www.geeksforgeeks.org/steins-algorithm-for-finding-gcd/\n// \"(1) If both a and b are 0, gcd is zero gcd(0, 0) = 0.\n//  (2) gcd(a, 0) = a and gcd(0, b) = b because everything divides 0.\n//  (3) If a and b are both even, gcd(a, b) = 2*gcd(a/2, b/2) because 2 is a common divisor.\n//      Multiplication with 2 can be done with bitwise shift operator.\n//  (4) If a is even and b is odd, gcd(a, b) = gcd(a/2, b). Similarly, if a is odd and b is even, then\n//      gcd(a, b) = gcd(a, b/2). It is because 2 is not a common divisor.\n//  (5) If both a and b are odd, then gcd(a, b) = gcd(|a-b|/2, b). Note that difference of two odd numbers is even\n//  (6) Repeat steps 3â€“5 until a = b, or until a = 0. In either case, the GCD is power(2, k) * b, where power(2, k) is 2 raise to the power of k and k is the number of common factors of 2 found in step 2.\n/*uint binary_gcd(uint a, uint b)\n{\n    // GCD(0, b) == b; GCD(a, 0) == a, GCD(0, 0) == 0\n    if (a == 0u) return b;\n    if (b == 0u) return a;\n\n    // Finding K, where K is the greatest power of 2 that divides both a and b.\n    uint k;\n    for(k = 0u; ((a | b) & 1u) == 0u; ++k)\n    {\n        a >>= 1u;\n        b >>= 1u;\n    }\n\n    // Dividing a by 2 until a becomes odd\n    while((a & 1u) == 0u) a >>= 1u;\n\n    // From here on, 'a' is always odd.\n    do\n    {\n        // If b is even, remove all factor of 2 in b\n        while((b & 1u) == 0u) b >>= 1u;\n\n        // Now a and b are both odd. Swap if necessary so a <= b, then set b = b - a (which is even).\n        if (a > b)\n        {\n            uint h = a;\n            a = b;\n            b = h;\n        }\n\n        b -= a;\n    }\n    while (b != 0u);\n\n    return a << k; // restore common factors of 2\n}\n*/\nuint binary_gcd(uvec2 v)\n{\n    // GCD(0, 0) == 0\n    if (v.x == 0u) return v.y; // GCD(0, v.y) == v.y\n    if (v.y == 0u) return v.x; // GCD(v.x, 0) == v.x\n\n    uint k;\n    for(k = 0u; ((v.x | v.y) & 1u) == 0u; ++k) v >>= 1u; // Finding K, where K is the greatest power of 2 that divides both v.x and v.y.\n    \n    while((v.x & 1u) == 0u) v.x >>= 1u; // Dividing v.x by 2 until v.x becomes odd\n\n    do // From here on, v.x is always odd.\n    {\n        while((v.y & 1u) == 0u) v.y >>= 1u; // If v.y is even, remove all factor of 2 in v.y\n\n        // Now v.x and v.y are both odd.\n        if (v.x > v.y) v = v.yx; // Swap if necessary so v.x <= v.y ...\n\n        v.y -= v.x; // ...then set v.y = v.y - v.x (which is even).\n    }\n    while (v.y != 0u);\n\n    return v.x << k; // restore common factors of 2\n}\n\nuint gcd(uvec2 v) // NOTE: modulo-based gcd is way more compact...\n{\n    while(v.y != 0u) v = uvec2(v.y, v.x % v.y);\n    return v.x;\n}\n\nbool checker(uvec2 p)\n{\n    return (p.x&1u)!=(p.y&1u);\n}\n\nvoid mainImage(out vec4 frag_color, vec2 I)\n{\n    uvec2 R = uvec2(iResolution.xy);\n    //if(any(greaterThan(abs(iMouse.zw), vec2(10)))) R = uvec2(abs(iMouse.zw));\n    if(any(greaterThan(abs(iMouse.xy), vec2(10)))) R = uvec2(abs(iMouse.xy));\n    uvec2 p = uvec2(floor(I));\n    uint c = binary_gcd(R);\n    vec3 color = vec3(all(lessThanEqual(p, R)) && checker(p / c));\n    frag_color = vec4(color,1.0);\n}\n","name":"Image","description":"","type":"image"}]}