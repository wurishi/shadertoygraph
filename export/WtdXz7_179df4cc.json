{"ver":"0.1","info":{"id":"WtdXz7","date":"1580662419","viewed":71,"name":"Normals and Lighting","username":"HenriPK","description":"An SDF scene with normals applied!","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["sdf","lighting","normals"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//#version 400 core\n\nuniform float time;\nuniform vec2 resolution;\n\n/* Default is pointing X+ in rectangular coordinates.\n\nIncreasing X rotates the screen clockwise,\n  Y rotates the screen upwards,\n    Z rotates the screen to the right.*/\nvec3 camera_rotation;\n\nconst float min_step = 0.001;\nconst int max_stepc = 300;\n\nvec3 raymarch (vec2 uv, vec3 camera_scale);\nfloat ssdf (vec3 p);\nvec3 vecFloor (vec3 inv);\nvec3 ssnormal (vec3 p);\nvec3 rotate3d(vec3 vector, vec3 rotations);\nfloat smin(float a, float b, float k);\nfloat smax(float m, float n, float k);\n\nvec2 mouseuv;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  mouseuv = iMouse.xy / iResolution.xy - .5;\n   \n  vec2 uv = fragCoord.xy / iResolution.xy;\n\n  vec3 col = raymarch(uv - .5, vec3(1.6, 0.9, 1.0));\n\n  fragColor = vec4(col, 1.0);\n}\n\nvec3 raymarch (vec3 origin, vec3 ray)\n{\n  float dist; vec3 cray;\n\n  for(int steps = 0; steps < max_stepc; steps++)\n  {\n    float sdist = ssdf((cray));\n    dist += sdist;\n    cray = origin + (dist * ray);\n      \n    cray -=vec3(-2.2, -2.2, -2.2);\n      cray = rotate3d(cray, vec3(0.0, mouseuv.y*3.0, mouseuv.x*4.0));\n\tcray +=vec3(-2.2, -2.2, -2.2);\n\n    if(sdist <= min_step)\n    {\n      vec3 normal = ssnormal(cray);\n      vec3 light = (vec3(0.0, 0.0, 3.0));\n      vec3 lrdir = normalize(light - cray);\n      //return 1.0 - normal;\n      return  vec3(0.4, 0.4, 0.5)*(0.1 + 0.9 * dot(normal, lrdir));\n    }\n  }\n\n  return -vec3(ray);\n}\n\nvec3 raymarch (vec2 uv, vec3 camera_scale)\n{\n  vec3 ray = rotate3d(normalize(vec3(1.0, camera_scale.xy * uv)), vec3(0.0, .6, 3.95));\n  float dist; vec3 cray;\n\n  for(int steps = 0; steps < max_stepc; steps++)\n  {\n    float sdist = ssdf((cray));\n    dist += sdist;\n    cray = vec3(-0.0, -0.0, 0.0) + (dist * ray);\n      \n    cray += 2.2;\n      //cray = rotate3d(cray, vec3(0.0, mouseuv.y*3.0, mouseuv.x*4.0));\n\t\tcray = rotate3d(cray, vec3(0.0, 0.0, iTime));\n\tcray -= 2.2;\n\n    \n      \n    if(sdist <= min_step)\n    {\n      vec3 normal = ssnormal(cray);\n      vec3 light = (vec3(0.0, 0.0, 3.0));\n      vec3 lrdir = normalize(light - cray);\n      //return normal*0.5 + 0.5;\n      return  mix(vec3(0.4, 0.4, 0.5)*(0.1 + 0.9 * dot(normal, lrdir)), mix(vec3(0.4, 0.4, 0.5), raymarch(cray, reflect(ray, normal)),0.5), 0.8);\n    }\n  }\n\n  return -vec3(ray);\n}\n\nfloat ssdf (vec3 p) {\n\n  vec4 object = vec4(-2.2, -2.2, -2.2, 1.0);\n\n  float cd = distance(p.x, object.x) - object.w/2.;\n        cd = smax(cd, distance(p.y, object.y) - object.w/2., 0.3);\n        cd = smax(cd, distance(p.z, object.z) - object.w/2., 0.3);\n\n  //return (length(object.xyz - p) - object.w/2.);\n  //return cd;\n  vec3 d = (object.xyz - p);\n            d.x += 0.7*sin(iTime*2.);\n            \n  return smin(cd, (length(d) - object.w/2.*1.2), 0.5);\n    \n  //return smax(cd, -(length(object.xyz - p) - object.w/2. * 0.8 + 0.1 * sin(iTime)), 0.3);\n}\n\nvec3 ssnormal(vec3 p) {\n    return normalize(vec3(\n        ssdf(vec3(p.x + min_step, p.y, p.z)) - ssdf(vec3(p.x - min_step, p.y, p.z)),\n        ssdf(vec3(p.x, p.y + min_step, p.z)) - ssdf(vec3(p.x, p.y - min_step, p.z)),\n        ssdf(vec3(p.x, p.y, p.z  + min_step)) - ssdf(vec3(p.x, p.y, p.z - min_step))\n    ));\n}\n\nmat4 rotationMatrix(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n\n    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n                0.0,                                0.0,                                0.0,                                1.0);\n}\n\nvec3 rotate3d(vec3 vector, vec3 rotations) {\n\n  mat4 rx = rotationMatrix(vec3(1.0, 0.0, 0.0), rotations.x);\n  mat4 ry = rotationMatrix(vec3(0.0, -1.0, 0.0), rotations.y);\n  mat4 rz = rotationMatrix(vec3(0.0, 0.0, -1.0), rotations.z);\n\n  return (rz * ry * rx * vec4(vector, 1.0)).xyz;\n}\n\nfloat smin(float a, float b, float k) {\n    float h = clamp(0.5 + 0.5*(a-b)/k, 0.0, 1.0);\n    return mix(a, b, h) - k*h*(1.0-h);\n}\n\nvec3 smin(vec3 a, vec3 b, float k) {\n\t\n    return vec3(smin(a.x, b.x, k), smin(a.y, b.y, k), smin(a.z, b.z, k));\n}\n\nfloat smax(float m, float n, float k) {\n    \n    float a = -m;\n    float b = -n;\n    \n    float h = clamp(0.5 + 0.5*(a-b)/k, 0.0, 1.0);\n    return -(mix(a, b, h) - k*h*(1.0-h));\n}\n\nvec3 smax(vec3 a, vec3 b, float k) {\n\t\n    return vec3(smax(a.x, b.x, k), smax(a.y, b.y, k), smax(a.z, b.z, k));\n}","name":"Image","description":"","type":"image"}]}