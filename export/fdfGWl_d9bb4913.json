{"ver":"0.1","info":{"id":"fdfGWl","date":"1616962070","viewed":82,"name":"Zepplin crossing Desert TP5","username":"JohannaTrost","description":"A Zepplin finding its way through a canyon using 5 concatenated curved splines. ","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["terrain","catmullromspline","desert","canyon","proceduralanimation"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Texturing\n// Eric Galin\n\nconst float View = 2800.0;  // View distance\nconst float Epsilon = 0.01; // Marching epsilon\nconst int Steps = 400;      // Number of steps\n\n// Lipschitz constant\nconst float K=1.7;\n\n// Structure for objects\n// v : Field value\n// i : Texture index\nstruct V {\n    float v; \n    int i;\n};\n\n\n// Controlling the curve -----------------------------------------------------------------------------------\n\n// CatmullRomSpline\n// A, B, C, D : control points \nvec2 CatmullRomSpline (vec2 A, vec2 B, vec2 C, vec2 D, float t)\n{\n    vec2 a = -A/2. + (3.*B)/2. - (3.*C)/2. + D/2.;\n    vec2 b = A - (5.*B)/2. + 2.*C - D / 2.;\n    vec2 c = -A/2. + C/2.;\n    vec2 d = B;\n\n    return a*t*t*t + b*t*t + c*t + d;\n}\n\n\n// Derivative\n// A, B, C, D : control points \nvec2 Derivative (vec2 A, vec2 B, vec2 C, vec2 D, float t)\n{\n    vec2 a = -A/2.0 + (3.0*B)/2.0 - (3.0*C)/2.0 + D/2.0;\n    vec2 b = A - (5.0*B)/2.0 + 2.0*C - D / 2.0;\n    vec2 c = -A/2.0 + C/2.0;\n    vec2 d = B;\n  \n    return 3.*a*t*t + 2.*b*t + c;\n}\n\n\n// Boolean operations -----------------------------------------------------------------------------------\n\n// Union\n// a : field function of left sub-tree\n// b : field function of right sub-tree\nV Union(V a,V b)\n{\n    if (a.v<b.v)\n        return V(a.v,a.i);\n    else \n    {\n        return V(b.v,b.i);\n    }\n}\n\n// Smooth Union\n// a : field function of left sub-tree\n// b : field function of right sub-tree\nV SmoothUnion( V a, V b, float k ) \n{\n    float h = clamp( 0.5 + 0.5*(b.v-a.v)/k, 0.0, 1.0 );\n    \n    if(a.v<b.v)\n    {\n        return V(mix( b.v, a.v, h ) - k*h*(1.0-h),a.i); \n    }\n    else\n    {\n        return V(mix( b.v, a.v, h ) - k*h*(1.0-h),b.i);\n    }\n}\n\n// Intersection, preserve the index of first object\n// a, b : field function of left and right sub-trees\nV Intersection(V a,V b)\n{\n    if (a.v>b.v)\n    {\n        return V(a.v,a.i);\n    }\n    else \n    {\n        return V(b.v,a.i);\n    }\n}\n\n// Transformations ---------------------------------------------------------------------------------------------------------\n\n// Translation\n// p : point \n// t : point to translate\nvec3 Translation(vec3 p, vec3 t)\n{\n  return p-t;\n}\n\n// Scale\n// p : point \n// s : scaling factor \nvec3 Scale(vec3 p, vec3 s)\n{\n  return p/s;\n}\n\n// Rotation\n// p : point\n// d : degrees of rotation\n// a : axis 1 for x, 2 for y, 3 for z\nvec3 Rotation(vec3 p, float d, int axis)\n{\n  float a = radians(d); \n  float sa = sin(a); \n  float ca = cos(a); \n\n  if(axis == 1) // rotation x axis\n  {\n    return p*mat3(1.,0.,0.,    0.,ca,-sa,  0.,sa,ca);\n  }\n  else if(axis == 2) // rotation y axis\n  {\n    return p*mat3(ca,0.,sa,    0.,1.,0.,  -sa,0.,ca);\n  }\n  else if(axis == 3) // rotation z axis\n  {\n    return p*mat3(ca,-sa,0.,    sa,ca,0.,  0.,0.,1.);\n  }\n  else \n  {\n    // case never applies\n  }\n}\n  \n// Transformations depending on time ---------------------------------------------------------------------------------------------------------\n\n// Translation\n// p : point dir=(pxyz,0) pos=(pxyz,1) \n// t : point to translate\nvec4 TranslationT(vec4 p, vec3 t)\n{\n  mat4 tm = mat4(1.,0.,0.,0.,    0.,1.,0.,0.,    0.,0.,1.,0.,  t.x,t.y,t.z,1.);\n  return p*tm;\n}\n\n// Scale\n// p : point \n// s : scaling factor \nvec4 ScaleT(vec4 p, vec3 s)\n{\n  mat4 sm = mat4(s.x,0.,0.,0.,    0.,s.y,0.,0.,    0.,0.,s.z,0.,  0.,0.,0.,1.);\n  return p*sm;\n}\n\n// Rotation\n// p : point\n// d : degrees of rotation\n// a : axis 1 for x, 2 for y, 3 for z\nvec4 RotationT(vec4 p, float d, int axis)\n{\n  float a = d;//radians(d); \n  float sa = sin(a); \n  float ca = cos(a); \n\n  if(axis == 1) // rotation x axis\n  {\n    return p*mat4(1.,0.,0.,0.,    0.,ca,-sa,0.,  0.,sa,ca,0.,  0.,0.,0.,1.);\n  }\n  else if(axis == 2) // rotation y axis\n  {\n    return p*mat4(ca,0.,sa,0.,    0.,1.,0.,0.,  -sa,0.,ca,0.,  0.,0.,0.,1.);\n  }\n  else if(axis == 3) // rotation z axis\n  {\n    return p*mat4(ca,-sa,0.,0.,    sa,ca,0.,0.,  0.,0.,1.,0.,  0.,0.,0.,1.);\n  }\n  else \n  {\n    // case never applies\n  }  \n}\n\n// Primitive functions -----------------------------------------------------------------------------------\n\n// Sphere \n// p : point\n// c : center of skeleton\n// r : radius\nV Sphere(vec3 p, vec3 c,float r, int index)\n{\n  return V(length(p-c)-r,index);\n}\n\n// Sphere \n// p : point\n// n : Normal of Plan\n// o : Point on Plan\nV Plan(vec3 p, vec3 n, vec3 o, int index)\n{\n    return V(dot((p-o),n), index);\n}\n\n// Disc\n// p : point\n// c : center point \n// n : normal\n// r : radius \n// t : thickness of disc\nV Disc(vec3 p, vec3 c, vec3 n, float r, float t, int index)\n{\n  vec3 pc = p-c;\n  float h = dot(pc,n);\n  float m = sqrt(dot(pc, pc)-h*h) - r;\n\n  if(m < 0.0)\n  {\n      return V(abs(h) - t,index); \n  }\n  else\n  {\n      return V(sqrt(m*m + h*h) - t, index);\n  }\n}\n\n// Box\n// p : point \n// b : box size \n// r : radius for round edges \nV Box( vec3 p, vec3 b, float r, int index)\n{\n  vec3 q = abs(p) - b; // b is (Rx,Ry,Rz)\n  return V(length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) -r, index);\n}\n\n// Segment\n// p : point \n// a : point A of segment \n// b : point B of segment \nV Segment(vec3 p, vec3 a, vec3 b, int index)\n{\n  float h; // dist between A and point on AB segment that is closest to p\n  vec3 ab = b-a; \n  vec3 ap = p-a;\n  vec3 bp = p-b;\n\n  h = dot(ap,(ab/length(ab)));\n\n  if(h < 0.0) \n  {\n    return V(length(ap),index); \n  }\n  else if(h > length(ab))\n  {\n    return V(length(bp),index);\n  }\n  else \n  {\n    return V(sqrt(dot(ap,ap) - h*h),index);  \n  }\n}\n\n// Capsule\n// p : point \n// a : point A of segment \n// b : point B of segment \n// r : radius\nV Capsule(vec3 p, vec3 a, vec3 b, float r, int index)\n{\n  return V(Segment(p, a, b, index).v - r, index); \n}\n\n// Cylinder\n// p : point \n// a : point A of segment \n// b : point B of segment \n// r : radius\nV Cylinder(vec3 p, vec3 a, vec3 b, float r, int index)\n{\n    return  Intersection(\n                Intersection(\n                    Capsule(p, a, b, r,index), \n                    Plan(p, normalize(a-b), a,index)), \n                Plan(p, -normalize(a-b), b,index)\n                );\n}\n\n// Vesica - taken from: https://iquilezles.org/articles/distfunctions2d\nV Vesica(in vec3 p, float r, float d, in float h, in int index)\n{\n    vec2 p2 = abs(p.xy);\n\n    float b = sqrt(r*r-d*d); \n    float sdf = ((p2.y-b)*d > p2.x*b) \n               ? length(p2-vec2(0.0,b))\n               : length(p2-vec2(-d,0.0))-r;\n            \n    vec2 w = vec2( sdf, abs(p.z) - h );\n    \n  \treturn V(min(max(w.x,w.y),0.0) + length(max(w,0.0)),index);\n}\n \n\n// Ellipsoid - taken from: https://www.shadertoy.com/view/tdS3DG\n// p : point \n// r : size\nV Ellipsoid( vec3 p, vec3 r, int index)\n{\n  float k0 = length(p/r);\n  float k1 = length(p/(r*r));\n  return V(k0*(k0-1.0)/k1, index);\n}\n\n// Objects for the Plane -----------------------------------------------------------------------------------\n\n// Propeller\n// p : point\nV Propeller(vec3 p, int index)\n{\n  V u = Cylinder(p,vec3(0.,0.,0.),vec3(5.,0.,0.),5.,index);\n  \n  // distribute 3 propeller wings equally on a circle with same distance to center of cylinder\n  for(float i=0.; i <= 240.; i=i+120.)\n  {\n    u = Union(Vesica(Rotation( // make propeller wings be \"even\" with cylinder\n                            Rotation( // make them point outwards\n                              Translation( // positioning using polar coordinates r=20\n                                p-vec3(2.5,0.,0.), \n                                vec3(0., \n                                     20.*cos(radians(i)),\n                                     20.*sin(radians(i))\n                                     )), \n                              -i, \n                              1),\n                            90., \n                            2), 35., 28., 0.5, index-1),u);\n  }\n  \n  return u;\n}\n\n// Zepllin\n// p : point \nV Zepllin(vec3 p, int index)\n{\n  V u = Ellipsoid(p, vec3(50.,150.,50.), index);\n  \n  u = SmoothUnion(u, Box(p-vec3(0.,-15.,-55.), vec3(9.,11.,4.), 10., index-1), 10.);\n  \n  vec3 pProp = Rotation(p-vec3(0.,155.,0.), 90., 3);\n  u = Union(u, Propeller(Rotation(pProp, mod(iTime*800., 8000.), 1), index-2));\n  \n  return u;\n}\n\n// Terrain -----------------------------------------------------------------------------------------------\n\nfloat replace(float ha, float hb, float mask)\n{\n    return mix(ha,hb,mask);\n}\n\nfloat Plateau(float h, float starth, float endh ,bool limit)\n{\n  if(h > starth && h < endh)\n  {      \n      return starth + smoothstep(0., 1., (h - starth) / (endh - starth))* (endh - starth);\n  }\n  else if (limit && h >= endh) \n  {\n      return endh;\n  }\n  else \n  {\n      return h;\n  }\n}\n\nfloat PlateauInMountain(float h, float starth, float endh)\n{ \n  float mid1 = starth + (endh - starth)*.3;\n  float mid2 = endh - (endh - starth)*.3;\n  if(h > starth && h < mid2)\n  {\n      return Plateau(h, starth, mid1, true);\n  }\n  else \n  {\n      return Plateau(h, mid2, endh, false);\n  }\n} \n\n// Terrain heightfield\n// x : Position in the plane\nfloat Canyon(in vec2 p)\n{\n    float l0 = 110.;\n    float z1 = 30.;\n    float z2 = 200.;\n    return z1 + 0.25*(z2-z1) + HeteroFbmRidge(p,.25*(z2-z1),l0,4);\n} \n\n\n// Implicit surface defining the terrain\n// p : Point\nV ImplicitTerrain(in vec3 p, in float terrain, in int index)\n{\n    float h = (p.z - terrain) / K; \n    return V(h, index);\n}\n\n// Masque à support compact dans cercle (c, ra) avec decroissance jusqu'à rb\nfloat AlphaDisk(in vec2 p, in vec2 c, float ra, float rb)\n{\n    float d=length(p-c);\n    return 1.-smoothstep(ra,rb,d);\n}\n\n// Scene --------------------------------------------------------------------------\n\n// Potential field of the object\n// p : point\nV Object(vec3 p)\n{\n  // ------------------ Terrain ------------------\n  \n  float hCanyon = Canyon( p.xy);\n  \n  hCanyon = Plateau(hCanyon, 80., 160., true);\n  hCanyon = PlateauInMountain(hCanyon, 110., 140.);\n  hCanyon = PlateauInMountain(hCanyon, 80., 100.);\n  hCanyon = PlateauInMountain(hCanyon, 60., 70.);\n  //hCanyon = PlateauInMountain(hCanyon, 20., 40.);\n  \n  float terrain = replace(30.,hCanyon,AlphaDisk(p.xy,vec2(0.,0.), 400., 600.)); \n\n  V u = Intersection(\n      ImplicitTerrain(p,terrain,0),\n      Disc(p, vec3(0.0,0.0,0.0), vec3(0.0,0.0,1.0), 350.0, 200., 0));\n   \n  // ------------------ Moving Object ------------------\n  \n  // first curve\n  vec2 p0 = vec2(1044., 100.);\n  vec2 p1 = vec2(460., 230.);\n  vec2 p2 = vec2(160., 100.);\n  vec2 p3 = vec2(-396., 836.);\n  \n  // uncomment following comments to visualize control points\n  //u = Union(u, Box( p+vec3(p1.x, p1.y, 0.), vec3(5.,5.,300.), 0., 8));\n  //u = Union(u, Box( p+vec3(p2.x, p2.y, 0.), vec3(5.,5.,300.), 0., 8));\n  \n  // second curve\n  vec2 p4 = -p3;\n  vec2 p5 = p2;\n  vec2 p6 = vec2(-110., -30.);\n  vec2 p7 = vec2(133., -670.);\n  \n  // uncomment following comment to visualize control point\n  //u = Union(u, Box( p+vec3(p6.x, p6.y, 0.), vec3(5.,5.,300.), 0., 8));\n  \n  // third curve\n  vec2 p8 = -p7;//vec2(-490., 608.);\n  vec2 p9 = p6;\n  vec2 p10 = vec2(-80., -350.);\n  vec2 p11 = vec2(782., -70.);\n  \n  // uncomment following comment to visualize control point\n  //u = Union(u, Box( p+vec3(p10.x, p10.y, 0.), vec3(5.,5.,300.), 0., 8));\n  \n  // fourth curve\n  vec2 p12 = -p11;\n  vec2 p13 = p10;\n  vec2 p14 = vec2(400., -150.);\n  vec2 p15 = vec2(1562., -152.);\n  \n  // uncomment following comment to visualize control point\n  //u = Union(u, Box( p+vec3(p14.x, p14.y, 0.), vec3(5.,5.,300.), 0., 8));\n  \n  float timePeriods = mod(iTime, 25.);\n  float t = mod(iTime, 5.)/5.;\n  \n  vec2 move;\n  vec2 speed;\n  \n  if(timePeriods < 5.) // first curve \n  {\n      move = CatmullRomSpline(p0, p1, p2, p3, t);\n      speed = Derivative(p0, p1, p2, p3, t);\n  }\n  else if(timePeriods < 10.)// second curve\n  {\n      move = CatmullRomSpline(p4, p5, p6, p7, t);\n      speed = Derivative(p4, p5, p6, p7, t);\n  }\n  else if(timePeriods < 15.)// third curve\n  {\n      move = CatmullRomSpline(p8, p9, p10, p11, t);\n      speed = Derivative(p8, p9, p10, p11, t);\n  }\n  else if(timePeriods < 20.)// fourth curve\n  {\n      move = CatmullRomSpline(p12, p13, p14, p15, t);\n      speed = Derivative(p12, p13, p14, p15, t);\n  } \n  else // connecting the very first and last point \n  {\n      vec2 p16 = -p15;\n      vec2 p17 = p14;\n      vec2 p18 = p1;\n      vec2 p19 = -p0;\n      \n      move = CatmullRomSpline(p16, p17, p18, p19, t);\n      speed = Derivative(p16, p17, p18, p19, t);\n  }\n  \n  p = vec3(p.x+move.x, p.y+move.y, p.z); // move object over curve(s)\n  p = RotationT(vec4(p.x,p.y,p.z,0.),atan(speed.x, speed.y),3).xyz; // turn object according to where its going\n  \n  V z = Zepllin(Scale(p - vec3(0.,0.,120.),vec3(.3,.3,.3)), 10);\n  \n  u = Union(u, V(z.v*.3, z.i));\n  \n  return u;\n}\n\n// Analysis of the scalar field --------------------------------------------------------------------------\n\n// Calculate object normal\n// p : point\nvec3 ObjectNormal(in vec3 p )\n{\n  float eps = 0.001;\n  vec3 n;\n  float v = Object(p).v;\n  n.x = Object( vec3(p.x+eps, p.y, p.z) ).v - v;\n  n.y = Object( vec3(p.x, p.y+eps, p.z) ).v - v;\n  n.z = Object( vec3(p.x, p.y, p.z+eps) ).v - v;\n  return normalize(n);\n}\n\n// Trace ray using ray marching\n// o : ray origin\n// u : ray direction\n// e : Maximum distance \n// h : hit\n// s : Number of steps\nfloat SphereTrace(vec3 o, vec3 u, float e,out bool h,out int s)\n{\n  h = false;\n\n    // Start at the origin\n    float t=0.0;\n\n  for(int i=0; i<Steps; i++)\n  {\n    s=i;\n    vec3 p = o+t*u;\n    float v = Object(p).v;\n    // Hit object\n      if (v < 0.0)\n      {\n          s=i;\n          h = true;\n          break;\n      }\n      // Move along ray\n      t += max(Epsilon,v/K);\n      // Escape marched too far away\n      if (t>e)\n      {\n          break;\n      }\n  }\n  return t;\n}\n\n// Shading and lighting ---------------------------------------------------------------------------\n\nvec3 TextureRock(in vec3 p)\n{\n  return mix(vec3(0.92,0.91,0.90),vec3(0.74,0.72,0.72),Fbm(p/50.0));   \n}\n\nvec3 TextureSand(in vec3 p)\n{\n  vec3 c = vec3(0.68, 0.35, 0.17)*2.5;\n  return mix(0.35*c, 0.65*c, Fbm(p));\n}\n\nvec3 TextureZepllin(in vec3 p)\n{\n  return mix(vec3(1.0, 0.99, 0.),vec3(1.0, 0.99, 0.)*1.5,Fbm(p/80.0));   \n}\n\n// Compute color \n// p : Point\n// n : Normal\nvec3 Color(in vec3 p,in vec3 n)\n{\n  V vp= Object(p);\n  \n  if( vp.i == 10 ) \n  {\n      return TextureZepllin(p);\n  }\n  else if( vp.i == 9 ) // little cabin\n  {\n      return vec3(.9, .9, .9)/2.;\n  }\n  else if( vp.i == 8 ) // propeller cylinder\n  {\n      return vec3(0., 0.35, 1.0)/1.5;\n  }\n  else if( vp.i == 7 ) // propeller wings\n  {\n      return vec3(1., 0., 0.0);\n  }\n  else if(p.z < 0.)\n  {\n      return TextureRock(p);\n  }\n  else\n  {\n      return TextureSand(p)*(1.-p.z/160.);\n  }\n}\n\n// Rendering \n// ro, rd : Ray origin and direction\n// pip : Picture in picture boolean\nvec4 Render( in vec3 ro, in vec3 rd, bool pip )\n{\n    // Light direction\n    vec3 light1 = normalize( vec3(-0.8,-0.3,0.4) );\n   \n    \n\tvec3 col;\n    int it;\n    bool b;\n    float t = SphereTrace( ro, rd, View,b , it);\n\tvec3 p = ro + t*rd;\n    float vp= Object(p).v;\n    vec3 n = ObjectNormal( p );\n\n\n    col = Color(p,n);\n    // Sky\n    if( b==false )\n    {\n        col = vec3(0.35,0.65,0.95) - rd.z*rd.z*2.5;\n    }\n\telse \n\t{\n        vec3 ref = reflect( rd, n );\n        float fre = clamp( 1.0+dot(rd,n), 0.0, 1.0 );\n        vec3 hal = normalize(light1-rd);\n                   \n\n         // Pseudo diffuse lighting\n\t\tfloat dif = 0.5*(1.0+dot( light1, n ));\n        dif*=dif;\n        \n        col = 0.45*col+0.55*dif*vec3(0.35,0.35,0.35);\n\t}\n    \n    // Shading for iterations\n    if (pip==true)\n    {\n    \tfloat s=float(it)/float(Steps);\n\t\treturn vec4(0.112+0.824*s,0.418+0.556*s,0.611-0.515*s,t);\n    }\n    else\n    {\n    \t// Gamma with square root\n    \treturn vec4( sqrt(col), t );\n    }\n}\n\nvec2 RayDirection(in vec2 pixel, out bool pip)\n{\n    pip=false;\n    // Pixel coordinates\n    vec2 p = (-iResolution.xy + 2.0*pixel)/iResolution.y;\n   if (pip==true)\n   {    \n    const float fraction=1.0/4.0;\n    // Picture in picture\n    if ((pixel.x<iResolution.x*fraction) && (pixel.y<iResolution.y*fraction))\n    {\n        p=(-iResolution.xy*fraction + 2.0*pixel)/(iResolution.y*fraction);\n        pip=true;\n    }\n       else\n       {\n           pip=false;\n       }\n   }\n   return p;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   // Time as function of the position of the mouse\n    float a = 3.14*2.0*1.5*iMouse.x/iResolution.x;\n\n    // Camera transform\n    vec3 ro; \n    mat3 cam = Camera( a, ro);   \n\n    // Picture in picture\n    bool pip=true;\n    \n    // Pixel coordinates\n    vec2 p = RayDirection(fragCoord, pip);\n   \n    // Camera ray    \n    vec3 rd = cam * normalize(vec3(p,5.0));\n    \n    // Render\n    vec4 res = Render( ro, rd, pip );\n     \n    fragColor = vec4( res.xyz, 0.0 );\n    \n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// Texturing\n// Eric Galin\n\n// Texturing and noise ---------------------------------------------------------\n\n// Hashing function\n// Returns a random number in [-1,1]\n// p : Vector in space\nfloat Hash(in vec3 p)  \n{\n    p  = fract( p*0.3199+0.152 );\n\tp *= 17.0;\n    return fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\n}\n\n// Procedural value noise with cubic interpolation\n// x : Point \nfloat Noise(in vec3 p)\n{\n    vec3 i = floor(p);\n    vec3 f = fract(p);\n  \n    f = f*f*(3.0-2.0*f);\n    // Could use quintic interpolation instead of cubic\n    // f = f*f*f*(f*(f*6.0-15.0)+10.0);\n\n    return mix(mix(mix( Hash(i+vec3(0,0,0)), \n                        Hash(i+vec3(1,0,0)),f.x),\n                   mix( Hash(i+vec3(0,1,0)), \n                        Hash(i+vec3(1,1,0)),f.x),f.y),\n               mix(mix( Hash(i+vec3(0,0,1)), \n                        Hash(i+vec3(1,0,1)),f.x),\n                   mix( Hash(i+vec3(0,1,1)), \n                        Hash(i+vec3(1,1,1)),f.x),f.y),f.z);\n}\n\n// Hashing function\n// Returns a random number in [-1,1]\n// p : Vector in the plane\nfloat Hash(in vec2 p)  \n{\n    p  = fract( p*0.3199+0.152 );\n\tp *= 17.0;\n    return fract( p.x*p.y*(p.x+p.y) );\n}\n\n\n// Procedural value noise with cubic interpolation\n// x : Point \n//float Noise(in vec2 p)\n//{\n//    vec2 i = floor(p);\n//    vec2 f = fract(p);\n//  \n//    f = f*f*(3.0-2.0*f);\n    // Could use quintic interpolation instead of cubic\n    // f = f*f*f*(f*(f*6.0-15.0)+10.0);\n\n//    return mix(mix( Hash(i+vec2(0,0)), \n//                        Hash(i+vec2(1,0)),f.x),\n//                   mix( Hash(i+vec2(0,1)), \n//                        Hash(i+vec2(1,1)),f.x),f.y);\n//}\n\nfloat Random (in vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))*\n        43758.5453123);\n}\n\n// Based on Morgan McGuire @morgan3d\n// https://www.shadertoy.com/view/4dS3Wd\nfloat Noise (in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    // Four corners in 2D of a tile\n    float a = Random(i);\n    float b = Random(i + vec2(1.0, 0.0));\n    float c = Random(i + vec2(0.0, 1.0));\n    float d = Random(i + vec2(1.0, 1.0));\n\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\n// FBM ---------------------------------------------------------------------------\n\n// Fractal brownian motion with 4 frequencies\n// p : Point\nfloat Fbm(in vec3 p)\n{\n    return Noise(p)/2.0+Noise(p*2.0)/4.0+Noise(p*4.0)/8.0+Noise(p*8.0)/16.0;\n}\n\n// Ridge\nfloat Ridge(in float x)\n{\n  return 1.-2.*abs(x);\n}\n\n// Fractial Brownien Motion on Noise\nfloat Fbm(in vec2 p, in float a0, in float l0, in int o)\n{\n  float a = a0;\n  float l = l0;\n  float noiseSum = 0.;\n  for(int i=0;i<o;i++)\n  {\n    noiseSum+=a*Noise(p/l);\n    a*=pow(2.,float(-i));\n    l*=pow(2.,float(-i));\n  }\n  return noiseSum;\n}\n\n// Fractional Brownian Motion on Ridge Noise\nfloat FbmRidge(in vec2 p, in float a0, in float l0, in int o)\n{\n  float a = a0;\n  float l = l0;\n  float noiseSum = 0.;\n  for(int i=0;i<o;i++)\n  {\n    noiseSum+=a*Ridge(Noise(p/l));\n    a*=pow(2.,float(-i));\n    l*=pow(2.,float(-i));\n  }\n  return noiseSum;\n}\n\n// Fbm on ridge noise\n// output +/- a0 + a0/2 + a0/4 + a0/8 + ... ~ +/- 2a0 = [-2 a0, 2 a0]\nfloat HeteroFbmRidge(in vec2 p, in float a0, in float l0, in int o)\n{\n  float noiseSum = a0*Ridge(Noise(p/l0)); // starting with a signal: level 0\n  float a = a0;\n  float l = l0; \n  for(int i=1;i<o;i++)\n  {\n    noiseSum+=a*Ridge(Noise(p/l))*smoothstep(-a,a,noiseSum); // attenuation depends on current altitude\n    a*=.5;\n    l*=.5;\n  }\n  return noiseSum;\n}\n\n// Camera\n// a: Rotation angle around z axis\n// ro : Ray origin\nmat3 Camera(float a, out vec3 ro)\n{\n\tfloat range=1000.0;\n    // Origin\n    ro = vec3(range*cos(a),range*sin(a),range/4.0);\n\t\n    // Target\n    vec3 ta = vec3(-100.0,0.0,20.0);\n    \n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(0.0, 0.0,1.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}","name":"Common","description":"","type":"common"}]}