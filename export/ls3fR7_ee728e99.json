{"ver":"0.1","info":{"id":"ls3fR7","date":"1524916855","viewed":269,"name":"Path Tracing Demo","username":"dhblooo","description":"A progressive path tracing demo derived from smallpt (documented in Chinese)","likes":4,"published":1,"flags":48,"usePreview":0,"tags":["raytracing","pathtracing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define GAMMA 2.2f\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tvec3 color = texture(iChannel0, uv).rgb;\n    \n\tfragColor = vec4(clamp(pow(color, vec3(1./GAMMA)), 0., 1.), 1.);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\n// Constants\n#define PI 3.14159265359\n#define SUB_SAMPLES 1\n#define EPSILON 1e-4\n#define RAY_EPSILON 1e-3\n#define MAX_DEPTH 64\n\n// Material Types (漫反射表面, 镜面反射表面, 折射表面)\n#define DIFF 0\n#define SPEC 1\n#define REFR 2\n\nstruct Ray { \n    vec3 origin;\t// 光线原点\n    vec3 dir; \t\t// 光线方向\n};\n    \nstruct Material {\n    int refl;\t    // 表面属性(DIFF, SPEC, REFR)\n    vec3 emission;\t// 自发光\n    vec3 color;\t\t// 颜色\n    float ior;\t\t// 折射率\n};\n    \nstruct Sphere {\n\tfloat radius;\t// 半径\n\tvec3 pos;\t\t// 位置\n\tMaterial mat;\t// 材质\n};\n    \nstruct Plane {\n    vec3 pos;\t\t// 位置\n    vec3 normal;\t// 法线\n    Material mat;\t// 材质\n};\n\n// Util functions\nfloat seed = 0.;\nfloat rand() { return fract(sin(seed++)*43758.5453123); }\n\nvec3 cosWeightedSampleHemisphere(vec3 n) {\n    float u1 = rand(), u2 = rand();\n    float r = sqrt(u1);\n    float theta = 2. * PI * u2;\n    \n    float x = r * cos(theta);\n    float y = r * sin(theta);\n    float z = sqrt(max(0., 1. - u1));\n    \n    vec3 a = n, b;\n    \n    if (abs(a.x) <= abs(a.y) && abs(a.x) <= abs(a.z))\n\t\ta.x = 1.0;\n\telse if (abs(a.y) <= abs(a.x) && abs(a.y) <= abs(a.z))\n\t\ta.y = 1.0;\n\telse\n\t\ta.z = 1.0;\n        \n    a = normalize(cross(n, a));\n    b = normalize(cross(n, a));\n    \n    return normalize(a * x + b * y + n * z);\n}\n\n// Scene Description\n#define NUM_SPHERES 3\n#define NUM_PLANES 6\nSphere spheres[NUM_SPHERES];\nPlane planes[NUM_PLANES];\n\nvoid initScene() {\n    spheres[0] = Sphere(16.5, vec3(27,16.5,47), Material(SPEC, vec3(0.), vec3(1.), 0.));\n    spheres[1] = Sphere(16.5, vec3(73, 16.5, 78), Material(REFR, vec3(0.), vec3(.75, 1., .75), 1.5));\n    spheres[2] = Sphere(600., vec3(50, 689.3, 50), Material(DIFF, vec3(6.), vec3(0.), 0.));\n    \n\tplanes[0] = Plane(vec3(0, 0, 0), vec3(0, 1, 0), Material(DIFF, vec3(0.), vec3(.75), 0.));\n    planes[1] = Plane(vec3(-7, 0, 0), vec3(1, 0, 0), Material(DIFF, vec3(0.), vec3(.75, .25, .25), 0.));\n    planes[2] = Plane(vec3(0, 0, 0), vec3(0, 0, -1), Material(DIFF, vec3(0.), vec3(.75), 0.));\n    planes[3] = Plane(vec3(107, 0, 0), vec3(-1, 0, 0), Material(DIFF, vec3(0.), vec3(.25, .25, .75), 0.));\n    planes[4] = Plane(vec3(0, 0, 180), vec3(0, 0, 1), Material(DIFF, vec3(0.), vec3(0.), 0.));\n    planes[5] = Plane(vec3(0, 90, 0), vec3(0, -1, 0), Material(DIFF, vec3(0.), vec3(.75), 0.));\n}\n\nvec3 background(vec3 dir) {\n    //return mix(vec3(0.), vec3(.9), .5 + .5 * dot(dir, vec3(0., 1., 0.)));\n    return texture(iChannel1, dir).rgb;\n}\n\n// 检测光线与圆相交\nfloat intersectSphere(Ray r, Sphere s) {\n    vec3 op = s.pos - r.origin;\n    float b = dot(op, r.dir);\n    \n    float delta = b * b - dot(op, op) + s.radius * s.radius;\n\tif (delta < 0.)           // 光线与球体未相交\n        return 0.; \t\t        \n    else                      // 光线与球体相交\n        delta = sqrt(delta);\n    \n    float t;                  // 找到t最小的交点\n    if ((t = b - delta) > EPSILON)\n        return t;\n    else if ((t = b + delta) > EPSILON)\n        return t;\n    else\n        return 0.;\n}\n\nfloat intersectPlane(Ray r, Plane p) {\n    float t = dot(p.pos - r.origin, p.normal) / dot(r.dir, p.normal);\n    return mix(0., t, float(t > EPSILON));\n}\n\n// 光线与整个场景相交，找到相交的几何体，返回相交几何体的ID\nint intersect(Ray ray, out float t, out vec3 normal, out Material mat) {\n\tint id = -1;\n\tt = 1e5;\n\tfor (int i = 0; i < NUM_SPHERES; i++) {\n\t\tfloat d = intersectSphere(ray,  spheres[i]);\n\t\tif (d != 0. && d<t) { \n            id = i; \n            t = d; \n         \tnormal = normalize(ray.origin + ray.dir * t - spheres[i].pos);\n            mat = spheres[i].mat;\n        }\n\t}\n    \n    for (int i = 0; i < NUM_PLANES; i++) {\n        float d = intersectPlane(ray, planes[i]);\n        if (d != 0. && d < t) {\n            id = i;\n            t = d;\n            normal = planes[i].normal;\n            mat = planes[i].mat;\n        }\n    }\n\treturn id;\n}\n\n// 根据相机模型生成初始光线\nRay generateRay(vec2 uv) {\n    vec2 p = uv * 2. - 1.;\n    \n    vec3 camPos = vec3(50., 40.8, 172.);\n\tvec3 cz = normalize(vec3(50., 40., 81.6) - camPos);\n\tvec3 cx = vec3(1., 0., 0.);\n\tvec3 cy = normalize(cross(cx, cz)); \n    cx = cross(cz, cy);\n    \n    float aspectRatio = iResolution.x / iResolution.y;\n    return Ray(camPos, normalize(.5135 * (aspectRatio * p.x * cx + p.y * cy) + cz));\n}\n\n// 辐射度计算\nvec3 trace(Ray ray) {\n    vec3 radiance = vec3(0.);\t\t // 累积辐射度\n    vec3 reflectance = vec3(1.);\t // 累积反射率\n    for (int depth = 0; depth < MAX_DEPTH; depth++) {\n        float t;\t    // 相交处距离\n        vec3 n;\t\t\t// 相交面的法线\n        Material mat;   // 相交处材质\n\n        int id = intersect(ray, t, n, mat);\n        \n        // 如果没有和物体相交，返回背景的辐射度\n        if (id < 0) {\n            radiance += reflectance * background(ray.dir);\n            break;\n        }\n        \n        \n        // 累加这一次的辐射度\n        radiance += reflectance * mat.emission;\n        \n        vec3 color = mat.color;\n        // 反射率最大分量\n        float p = max(color.x, max(color.y, color.z));\n        // Russain roulette\n        if (rand() < p)\n            color /= p;\n        else\n            break;\n        \n        // 根据光线与法线的方向判断是射入还是射出，并反转法线\n        vec3 nl = n * sign(-dot(n, ray.dir));\n        // 将光线的原点移动到相交点\n        ray.origin += ray.dir * t;\n\t\t\n        \n        if (mat.refl == DIFF) {\t\t\t\t// 漫反射表面\n            ray.dir = cosWeightedSampleHemisphere(nl);\n            reflectance *= color;\n        } else if (mat.refl == SPEC) {\t    // 镜面反射表面\n            ray.dir = reflect(ray.dir, n);\n            reflectance *= color;\n        } else {\t\t\t\t\t\t    // 折射表面\n            float ior = mat.ior;\n            float into = float(dot(n, nl) > 0.);\t // 光线是否从外部进来\n            float ddn = dot(nl, ray.dir);\n            float nnt = mix(ior, 1. / ior, into);\n            vec3 rdir = reflect(ray.dir, n);\n            float cos2t = 1. - nnt * nnt * (1. - ddn * ddn);\n            if (cos2t > 0.) {\t\t// 是否发生Total Internal Reflection\n                // 算出折射光线的方向\n                vec3 tdir = normalize(ray.dir * nnt - nl * (ddn * nnt + sqrt(cos2t)));\n                \n                float R0 = (ior-1.) * (ior-1.) / ((ior+1.) * (ior+1.));\n\t\t\t\tfloat c = 1. - mix(dot(tdir, n), -ddn, into);\t// 1 - cosθ\n\t\t\t\tfloat Re = R0 + (1. - R0) * c * c * c * c * c;\t// 菲涅尔项\n                \n                float P = .25 + .5 * Re;\t\t\t  // 反射概率\n                float RP = Re / P, TP = (1. - Re) / (1. - P);   // 反射/折射系数\n                \n                // Russain roulette\n                if (rand() < P) {\t\t\t\t// 选择反射\n                    reflectance *= RP;\n                    ray.dir = rdir;\n                } else { \t\t\t\t        // 选择折射\n                    reflectance *= color * TP; \n                    ray.dir = tdir; \n                }\n            } else\n                ray.dir = rdir;\n        }\n        \n        // 将光线往前推进一点，防止自相交\n        ray.origin += ray.dir * RAY_EPSILON;\n    }\n    return radiance;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // 初始化随机数种子\n    seed = iTime + iResolution.y * fragCoord.x / iResolution.x + fragCoord.y / iResolution.y;\n    \n    // 初始化场景\n    initScene();\n    \n    vec3 color = vec3(0.);\n    // 超采样\n    for (int x = 0; x < SUB_SAMPLES; x++) {\n        for (int y = 0; y < SUB_SAMPLES; y++) {\n        \t// Tent Filter\n            float r1 = 2. * rand(), r2 = 2. * rand();\n            float dx = mix(sqrt(r1) - 1., 1. - sqrt(2. - r1), float(r1 > 1.));\n            float dy = mix(sqrt(r2) - 1., 1. - sqrt(2. - r2), float(r2 > 1.));\n            vec2 jitter = vec2(dx, dy);\n\n            // 计算像素内采样点的uv坐标\n            vec2 subuv = (fragCoord.xy + jitter) / iResolution.xy;\n\n            // 生成相机光线\n            Ray camRay = generateRay(subuv);\n\n            // 计算光线对应的辐射度\n            color += trace(camRay);\n        }\n    }\n\n    color /= float(SUB_SAMPLES * SUB_SAMPLES);\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    // muiltpass 多次采样算出平均结果\n\tcolor += texture(iChannel0, uv).rgb * float(iFrame);\n    \n\tfragColor =vec4(color / float(iFrame + 1), 1.);\n}","name":"Buffer A","description":"","type":"buffer"}]}