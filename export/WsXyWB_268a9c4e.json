{"ver":"0.1","info":{"id":"WsXyWB","date":"1585431454","viewed":82,"name":"Appollonius Circles","username":"plosique","description":"Constructs the Appollonius Circles for a rotating set of two points. ","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["geometry"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Appollonius equation k*|z-p|=|z-q|\n\nstruct Appollo{ \n    vec2 p,q;\n}; \n\nfloat circle(Appollo A,vec2 z,float k){\n    return k*(length(z-A.p))-length(z-A.q);\n} \n//estimated gradient for isoline distance estimation\n//based off https://iquilezles.org/articles/distance\n\nvec2 grad(Appollo A, vec2 z,float k )\n{\n    vec2 h = vec2( 0.01, 0.0 );\n    return vec2( circle(A,z+h.xy,k)-circle(A,z-h.xy,k),circle(A,z+h.yx,k)-circle(A,z-h.yx,k))/(2.*h.x); \n}  \n\nfloat color(vec2 z){\n    float eps=0.1;\n    float col=0.; \n    float theta=iTime/2.;\n    //rotate points;\n    Appollo A=Appollo(vec2(cos(theta),sin(theta)),vec2(cos(theta+pi),sin(theta+pi)));\n    float k=0.;\n    //union various values of k\n    while(k<=2.){\n        col+=1.0-smoothstep(0.,1.0*eps,abs(circle(A,z,k))/length(grad(A,z,k)));\n    \tk+=.2;\n    } \n    return col; \n}\n\n    \n        \n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from -3 to 3)\n    vec2 uv = fragCoord/iResolution.y;\n    vec2 z=2.*uv-vec2(iResolution.x/iResolution.y,1.);\n    z*=3.;\n    \n\n\n    // Output to screen\n    fragColor = vec4(vec3(color(z)),1.);  \n    \n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"const vec4 clear=vec4(0.);\nconst vec3 white=vec3(1.);\nconst vec3 black=vec3(0.,0.,0.);\nconst vec3 red=vec3(1.,0.,0.);\nconst vec3 green=vec3(0.,1.,0.);\nconst vec3 blue=vec3(0.,0.,1.);\nconst vec3 magenta=vec3(1.,0.,1.);\nconst vec3 yellow=vec3(1.,1.,0.);\nconst vec3 cyan=vec3(0.,1.,1.);\n\nconst vec2 i=vec2(0.,1.); \nconst float pi=acos(-1.);\n\nvec2 cm(vec2 a,vec2 b){\n  return vec2(a.x*b.x-a.y*b.y,a.x*b.y+a.y*b.x);  \n}\nvec2 cd(vec2 a,vec2 b){\n  float d=pow(length(b),2.);\n    return vec2(a.x*b.x+a.y*b.y,a.y*b.x-a.x*b.y)/d;\n}\n\nvec2 conj(vec2 z){ \n    return vec2(z.x,-z.y);\n}\n\nvec2 expz(vec2 z){\n  float f=1.;\n    vec2 sum=vec2(1.,0.)+z;\n    vec2 p=z;\n    for(float j=2.;j<8.;++j){\n        f*=j;\n        p=cm(p,z);\n        sum+=p/f;\n    }\n    return sum;\n}\n\nvec2 coshz(vec2 z){ \n    return (expz(z)+expz(-z))/2.;\n} \n\nvec2 sinhz(vec2 z){ \n    return (expz(z)-expz(-z))/2.;\n} \n\nvec2 tanhz(vec2 z){ \n    return cd(sinhz(z),coshz(z));\n}\n\nvec2 cosz(vec2 z){ \n    return expz(cm(i,z))+expz(cm(-1.*i,z))/2.;\n} \n\nvec2 sinz(vec2 z){ \n    return cd(expz(cm(i,z))-expz(cm(-i,z)),2.*i);\n}\n\nvec2 logzp(vec2 z){ \n    float r=length(z);\n    float theta=atan(z.y,z.x);\n    return vec2(log(r),theta);\n}\n\nvec2 powz(vec2 z1,vec2 z2){ \n    return expz(cm(z1,logzp(z2)));\n}\n\n\n\nvec2 polar(vec2 c){\n  return vec2(length(c),atan(c.y,c.x));  \n}\nvec2 cart(vec2 p){\n  return vec2(p.x*cos(p.y),p.x*sin(p.y));  \n}\n//from iq - smooth version\nvec3 hsv2rgb(vec3 c){\n    vec3 rgb=clamp(abs(mod(c.x*6.+vec3(0.,4.,2.),6.)-3.)-1.,0.,1.);\n    rgb=rgb*rgb*(3.-2.*rgb);\n    return c.z*mix(vec3(1.),rgb,c.y);\n}\nvec4 dc(vec2 uv){\n    vec2 po=polar(uv); \n    vec2 intensity=vec2(po.r,0.);\n    vec3 col=hsv2rgb(vec3(po.y/2./pi,1.,smoothstep(0.,1.,tanhz(100.*intensity))));\n  return vec4(col,1.);  \n}\n    \n    \n","name":"Common","description":"","type":"common"}]}