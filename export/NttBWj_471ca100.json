{"ver":"0.1","info":{"id":"NttBWj","date":"1663645128","viewed":810,"name":"Volumetric Fire","username":"myth0genesis","description":"Apparently nimitz's volumetric ray marcher and fBm algorithm is great for fire, too!\nClick and drag to rotate camera.","likes":47,"published":1,"flags":0,"usePreview":0,"tags":["3d","raymarching","ray","raymarch","fbm","fire","marching","volumetric","transparent","march","gyroid"],"hasliked":0,"parentid":"3l23Rh","parentname":"Protean clouds"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// 2022 myth0genesis\n// Volumetric Fire\n// Most code is from nimitz's Protean clouds\n// https://www.shadertoy.com/view/3l23Rh\n\nconst mat3 m3 = mat3( 0.3338,  0.56034, -0.71817,\n                     -0.87887, 0.32651, -0.15323,\n                      0.15162, 0.69596,  0.61339) * 1.93;\n\nfloat LinStep(float mn, float mx, float x) {\n    return clamp((x - mn) / (mx - mn), 0.0, 1.0);\n}\n\nmat2 rotate(float a) {\n    float c = cos(a);\n    float s = sin(a);\n    return mat2( c, s,\n                -s, c);\n}\n\n// nimitz's genius fast gyroid fBm\nfloat gyroidFBM3D(vec3 p, float cl) {\n    float d = 0.0;\n    p *= 0.185;\n    p.z -= iTime;\n    float z = 1.0;\n    float trk = 1.0;\n    float dspAmp = 0.1;\n    for(int i = 0; i < 5; i++) {\n        p += sin(p.yzx * 1.5 * trk) * dspAmp;\n        d -= abs(dot(cos(p), sin(p.zxy)) * z);\n        z *= 0.7;\n        trk *= 1.4;\n        p = p * m3;\n        // move it faster to hide banding between steps\n        p -= iTime * 2.0;\n    }\n    // stepped back distance function to help with banding and color density\n    return (cl + d * 6.5) * 0.5;\n}\n\n// nimitz's volumetric ray marcher (which seems to be loosely based on iq's)\n// https://www.shadertoy.com/view/XslGRr\n// I eliminated some diffuse passes because self-shadowing isn't necessary with \"emissive\" fire\nvec3 transRender(vec3 ro, vec3 rd) {\n    vec4 rez = vec4(0.0);\n    float t = 20.0;\n    for(int i = 0; i < 100; i++) {\n        if(rez.w > 0.99) break;\n        vec3 pos = ro + t * rd;\n        float mpv = gyroidFBM3D(pos, -pos.z);\n        float den = clamp(mpv - 0.2, 0.0, 1.0) * 0.71;\n        float dn = clamp((mpv * 2.0), 0.0, 3.0);\n        vec4 col = vec4(0.0);\n        if(mpv > 0.6) {\n            col = vec4(11.0, 1.0, 0.0, 0.08);\n            // accumulate den linearly\n            col *= den;\n            col.xyz *= LinStep(3.0, -1.0, mpv) * 3.0;\n            // just calculate one diffuse pass for a color gradient\n            // and use precalculated distance to speed things up a bit\n            float dif = clamp((den - mpv + 1.5) * 0.125, 0.08, 1.0);\n            col.xyz *= den * (1.5 * vec3(0.005, 0.045, 0.075) + 1.5 * vec3(0.033, 0.05, 0.030) * dif);\n        }\n        rez += col * (1.0 - rez.w);\n        // kept steps as close together as I dared to hide banding\n        t += clamp(0.25 - dn * dn * 0.05, 0.15, 1.4);\n    }\n    return clamp(rez.xyz, 0.0, 1.0);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = (fragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n    vec3 ro = vec3(0.0, 0.0, -3.0);\n    \n    // uncomment for forward movement\n//    ro += vec3(0.0, iTime * 30.0, 0.0);\n    vec3 rd = normalize(vec3(uv.x, 1.0, uv.y));\n//    rd.xy *= rotate(sin(iTime * 0.5));\n    if(iMouse.z > 0.0) {\n//        rd.xy *= rotate((iMouse.x - 0.5 * iResolution.x) * 2.0 / iResolution.x);\n        rd.xy *= rotate(2.0 * (iMouse.x / iResolution.x - 0.5));\n    }\n    vec3 col = transRender(ro, rd);\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}