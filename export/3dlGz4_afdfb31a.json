{"ver":"0.1","info":{"id":"3dlGz4","date":"1545191469","viewed":157,"name":"snowbird army","username":"bitnenfer","description":"small shader done for streaming. :3","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","snowman"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define EPSILON 0.001\n#define FARCLIP 100.0\n#define NEARCLIP 0.001\n#define MATERIAL_NONE -1.0\n#define MATERIAL_BODY 0.0\n#define MATERIAL_FLOOR 1.0\n#define MATERIAL_ARMS 2.0\n#define MATERIAL_BUTTON 3.0\n#define MATERIAL_NOSE 4.0\n\nconst vec3 kLightDir = vec3(0.268683, 0.228427, -0.127168);\n\nvec2 opUnion(in vec2 a, in vec2 b)\n{\n    return a.x < b.x ? a : b;\n}\n\nfloat sdSphere(vec3 p, float r)\n{\n    return length(p) - r;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0))\n         + min(max(d.x,max(d.y,d.z)),0.0); // remove this line for an only partially signed sdf \n}\n\nvec2 mapBody(in vec3 p)\n{\n    p.y *= 1.2;\n    float bottom = sdSphere(p + vec3(0.0, 0.0, 0.0), 0.8);\n    float middle = sdSphere(p + vec3(0.0, -0.99, 0.0), 0.65);\n    float head = sdSphere(p + vec3(0.0, -1.8, 0.0), 0.4);\n    \n    return vec2(min(middle, min(bottom, head)), MATERIAL_BODY);\n}\n\nvec2 mapArms(in vec3 p)\n{\n    p.y -= sin(iTime * 4.0) * 0.33;\n    p.y += sin(p.x * 1.1 + iTime * 4.0) * 0.3;\n    float arm = sdBox(p + vec3(0.0, -0.99, 0.0), vec3(1.4, 0.02, 0.02)) - 0.04;\n\n    return vec2(arm, MATERIAL_ARMS);\n}\n\nvec2 mapButtons(in vec3 p)\n{\n    float b0 = sdSphere(p + vec3(0.0, -0.4, 0.6), 0.1);\n    float b1 = sdSphere(p + vec3(0.0, -0.9, 0.59), 0.1);\n    float b2 = sdSphere(p + vec3(0.0, -1.15, 0.45), 0.1);\n    \n    float e0 = sdSphere(p + vec3(0.25, -1.55, 0.28), 0.05);\n    float e1 = sdSphere(p + vec3(-0.25, -1.55, 0.28), 0.05);\n    \n    return vec2(min(e1, min(e0, min(b0, min(b1, b2)))), MATERIAL_BUTTON);\n}\n\nvec2 mapScene(vec3 p)\n{\n    p.y *= 1.0 + sin(iTime * 4.0 + p.x * 0.25 + p.z * 0.25) * 0.1;\n    vec3 rep = vec3(4.0, 0.0, 4.0);\n    p = mod(p, rep) - 0.5 * rep;\n     \n    vec2 scene = vec2(0.0, -1.0);\n    vec2 body = mapBody(p);\n    vec2 arms = mapArms(p);\n    vec2 buttons = mapButtons(p);\n    vec2 flr = vec2(p.y + 0.28, MATERIAL_FLOOR);\n\n    vec3 size = vec3(0.05, 0.1 * sin(p.z * 10.0), 0.4); \n    vec2 nose = vec2(sdBox(p + vec3(0.0, -1.5, 0.3), size) - 0.05, MATERIAL_NOSE);\n    \n    scene = opUnion(body, flr);\n    scene = opUnion(scene, arms);\n    scene = opUnion(scene, buttons);\n    scene = opUnion(scene, nose);\n    \n    return scene;\n}\n\nvec2 rayMarch(in vec3 ro, in vec3 rd)\n{\n    float t = 0.0;\n    for (int i = 0; i < 400; ++i)\n    {\n        vec2 r =  mapScene(ro + rd * t);\n        if (r.x < EPSILON)\n        {\n            return vec2(t,r.y);\n        }\n        t += r.x * 0.7;\n        if (t > FARCLIP) break;\n    }\n    return vec2(FARCLIP, -1.0);\n}\n\nvoid opRotate(inout vec2 p, float r)\n{\n    float c = cos(r);\n    float s = sin(r);\n    float vx = p.x * c - p.y * s;\n    float vy = p.x * s + p.y * c;\n    p.x = vx;\n    p.y = vy;\n}\n\nvec3 opNormal(vec3 p)\n{\n    float d = mapScene(p).x;\n    vec2 e = vec2(0.0, EPSILON);\n    vec3 n = d - vec3(\n        mapScene(p - e.yxx).x,\n        mapScene(p - e.xyx).x,\n        mapScene(p - e.xxy).x\n    );\n    return normalize(n);\n}\n\nvec3 baseShade(in vec3 ro, in vec3 rd, in vec2 ray)\n{\n    vec3 color = vec3(1.0, 0.0, 1.0);\n    \n    if (ray.y == MATERIAL_BODY)\n    {\n        color = vec3(1.0, 1.0, 1.0);\n    }\n    else if (ray.y == MATERIAL_FLOOR)\n    {\n        color = vec3(0.9, 0.9, 1.0);\n    }\n    else if (ray.y == MATERIAL_ARMS)\n    {\n        color = vec3(0.55, 0.32, 0.19);\n    }\n    else if (ray.y == MATERIAL_BUTTON)\n    {\n        color = vec3(0.0, 0.0, 0.0);\n    }\n    else if (ray.y == MATERIAL_NOSE)\n    {\n        color = vec3(1.0, 0.37, 0.2);\n    }\n    \n    vec3 p = ro + rd * ray.x;\n    vec3 n = opNormal(p);\n    float diff = max(0.0, dot(n, normalize(kLightDir)));\n    \n    vec2 shadowRay = rayMarch(p + n * 0.001, normalize(kLightDir));\n    if (shadowRay.x < FARCLIP)\n    {\n        color *= vec3(0.5, 0.5, 0.9);\n    }\n    \n    return color;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec3 color = vec3(1.0);\n    vec2 uv = (fragCoord.xy / iResolution.xy - 0.5) * vec2(iResolution.x / iResolution.y, 1.0);    \n    vec3 ro = vec3(0.0, 3.0, -5.0);\n    vec3 rd = normalize(vec3(uv, 1.0));\n    \n    opRotate(ro.yz, 0.3);\n    opRotate(rd.yz, 0.3);\n    \n    float rx = (iMouse.x / iResolution.x * 2.0 - 1.0) * 3.15 * 2.0;\n    opRotate(ro.xz, rx);\n    opRotate(rd.xz, rx);\n    \n    vec2 r = rayMarch(ro, rd);\n        \n    if (r.x < FARCLIP)\n    {\n        color = baseShade(ro, rd, r);\n    }\n    \n    color += 1.0 - pow((1.0 - (r.x / FARCLIP)), sqrt(0.1));\n    \n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}