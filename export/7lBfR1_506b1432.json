{"ver":"0.1","info":{"id":"7lBfR1","date":"1651952203","viewed":238,"name":"Soft shadows test","username":"Heksi","description":".","likes":12,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","domainrepetition","softshadows"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xsf3Rr","filepath":"/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","previewfilepath":"/media/ap/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS 400.\n#define HIT_DISTANCE 0.0001\n\n#define PI 3.14159265359\n\n// Structs\nstruct camera {\n    vec3 pos;\n    vec3 fwd;\n    vec3 right;\n    vec3 up;\n};\n\nstruct sdMap {\n    vec3 col;\n    float d;\n};\n\nstruct rmRes {\n    bool hasHit;\n    vec3 col;\n    vec3 pos;\n};\n\n\n// Util functions\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\n\n// SDF's\nfloat sphereSDF(vec3 p, vec3 c, float r) {\n    return length(p - c) - r;\n}\n\nfloat boxSDF(vec3 p, vec3 b)\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nsdMap map(vec3 p) {\n    float modSize = 3.;\n\n    vec3 q = vec3(\n        mod(p.x + modSize/2., modSize) - modSize/2.,\n        p.y,\n        mod(p.z + modSize/2., modSize) - modSize/2.\n    );\n\n    \n    sdMap maps[] = sdMap[](\n        // Spheres\n        sdMap(\n            vec3(1, 0.5, 0), \n            sphereSDF(q, vec3(0, 0.8, 0), .6)\n        ),\n        \n        // Ground\n        sdMap(\n            vec3(0.2), \n            smin(\n                boxSDF(q, vec3(0.4, 0.1, 0.4)) - 0.05, // Sphere base\n                p.y + .1, // Ground plane\n                0.5\n            )\n        )\n    );\n\n    sdMap m = sdMap(vec3(0), 1e6);\n    \n    for (int i = 0; i < maps.length(); i++) {\n        bool b = maps[i].d < m.d;\n        \n        m.d =   b ? maps[i].d   : m.d;\n        m.col = b ? maps[i].col : m.col;\n    }\n    \n    return m;\n}\n\n\n\n// Raymarching\nrmRes raymarch(vec3 o, vec3 d) {\n    rmRes res = rmRes(\n        false,\n        vec3(0),\n        vec3(0)\n    );\n    \n    vec3 cp = o;\n    float cd = 0.;\n    \n    for (float i = 0.; i < MAX_STEPS; i++) {\n        sdMap sd = map(cp);\n        \n        if (sd.d <= HIT_DISTANCE) { \n            res.hasHit = true;\n            res.col = sd.col;\n            res.pos = cp;\n            break; \n        }\n        \n        cd += sd.d;\n        cp += d * sd.d;\n    }\n    \n    return res;\n}\n\n// https://iquilezles.org/articles/rmshadows/\nfloat softshadow( in vec3 ro, in vec3 rd, float mint, float maxt, float k )\n{\n    float res = 1.0;\n    float ph = 1e20;\n    for( float t=0.; t<MAX_STEPS; )\n    {\n        float h = map(ro + rd*t).d;\n        \n        if( h<HIT_DISTANCE )\n            return 0.0;\n            \n        float y = h*h/(2.0*ph);\n        float d = sqrt(h*h-y*y);\n        \n        res = min( res, k*d/max(0.0,t-y) );\n        ph = h;\n        t += h;\n    }\n    return res;\n}\n\nvec3 normal(vec3 p) \n{\n\n    sdMap d0 = map(p);\n    const vec2 epsilon = vec2(.0001,0);\n    vec3 d1 = vec3(\n        map(p-epsilon.xyy).d,\n        map(p-epsilon.yxy).d,\n        map(p-epsilon.yyx).d);\n    return normalize(d0.d - d1);\n}\n\n\n// mainImage\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec2 mouse = (iMouse.xy-.5*iResolution.xy)/iResolution.y;\n\n    camera cam = camera(\n        vec3(cos(mouse.x * PI*2.) * 6., 4, sin(mouse.x * PI*2.) * 6. + iTime),\n        vec3(1, -1, 1),\n        vec3(0),\n        vec3(0)\n    );\n\n    cam.fwd = normalize(vec3(0, 1, iTime) - cam.pos);\n    cam.right = cross(cam.fwd, vec3(0, 1, 0));\n    cam.up = cross(cam.right, cam.fwd);\n\n    vec3 sunPos = vec3(cos(iTime)*4., 2., sin(iTime)*4. + iTime);\n    vec3 rayDir = normalize(cam.fwd + cam.right*uv.x + cam.up*uv.y);\n    \n    rmRes r = raymarch(cam.pos, rayDir);\n    \n    vec3 sunCol = vec3(1, 0.6, 0.4);\n    vec3 sunDir = normalize(sunPos - r.pos);\n    float sunPow = (sin(iTime*1.5)*.5+.5) * 3. + 8.;\n\n    float shadowAmt = softshadow(r.pos - rayDir*0.001, sunDir, 0., 1., 4.);\n    \n    vec3 norm = normal(r.pos);\n\n    vec3 col = r.col;\n    \n    // Specular highlight\n    col += sunCol * smoothstep(0.9, 0.96, dot(reflect(rayDir, norm), normalize(sunPos - r.pos))) * sunPow / 10.; \n    \n    // Shadow\n    col = mix(col, vec3(0), clamp( 1.-shadowAmt, 0., 1. )); \n    \n    // Diffuse \n    // Added at the end for the illusion of global illumination. (This likely won't work for other scenes)\n    col += sunCol / (length(r.pos - sunPos) / sunPow * 2.); \n\n    // Light falloff\n    col = mix(col, vec3(0), clamp( length(r.pos - sunPos) / sunPow, 0., 1. )); \n    \n    // Black sky\n    col = mix(col, vec3(0), 1.-float(r.hasHit));\n\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}