{"ver":"0.1","info":{"id":"McSXWh","date":"1706253551","viewed":190,"name":"Fork chained gest 856","username":"gest","description":"original https://www.shadertoy.com/view/fscBWB\n\nAdded different types of chains","likes":14,"published":1,"flags":0,"usePreview":0,"tags":["raymarch","chained"],"hasliked":0,"parentid":"fscBWB","parentname":"chained"},"renderpass":[{"inputs":[{"id":"4sXGRn","filepath":"/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","previewfilepath":"/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define SHADERTOY\n\n#ifdef SHADERTOY\n    #define main() mainImage( out vec4 fragColor, in vec2 fragCoord )\n    #define u_canvas iResolution\n    #define u_mouse iMouse\n    #define u_time iTime\n    #define gl_FragCoord fragCoord\n    #define gl_FragColor fragColor\n\t#define texture2D texture\n\t#define textureCube texture\n\t#define u_texture0 iChannel0\n\t#define u_texture1 iChannel1\n\t#define u_textureCube0 iChannel0\n\t#define u_textureCube1 iChannel1\n#endif\n\n//#define SUPER_GRAPHIC_CARD\n\n#ifdef SUPER_GRAPHIC_CARD\n\t#define SOFT_SHADOW\n#endif\n\nfloat time;\n\nstruct Light {\n\tvec3 position;\n\tvec3 color;\n};\nLight light1 = Light(vec3(-10.0, 120.0, -25.), vec3(1));\nLight light2 = Light(vec3(10.0, 20.0, -25.0 ), vec3(1));\n\n#define FAR 110.\n#define ID_NONE -1.\n#define ID_CHAIN_X 100.\n#define ID_CHAIN_Z 101.\n#define ID_CHAIN_Y 102.\n\n///Gracias a Shane...16-jun-2020\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n ){    \n  n = max(n*n - .2, .001); // max(abs(n), 0.001), etc.\n  n /= dot(n, vec3(1)); \n  vec3 tx = texture2D(tex, p.yz).xyz;\n  vec3 ty = texture2D(tex, p.zx).xyz;\n  vec3 tz = texture2D(tex, p.xy).xyz;\n  return mat3(tx*tx, ty*ty, tz*tz)*n; \n}\n\n//IQ\nfloat sdLink(vec3 p, float W, float H, float r ) {\n\tvec3 q = vec3( p.x, max(abs(p.y)-W,0.0), p.z );\n\treturn length(vec2(length(q.xy)-H,q.z)) - r;\n}\n//Параметры звена\n// W ширина звеня\n// H высота звена\n// r размер профиля звена\n// linkForm - форма звена (0 - капсула, 1 - прямоугольник, 2 - эллипс 3 - скругленный прямоугольник)\n// linkProfile - профиль звена (0 - круг, 1 - квадрат, 2 - эллипс, 3 - ромб)\nfloat dfLink(vec3 p, float W, float H, float r, float linkForm, float linkProfile) {\n\tif (linkForm==1.) {\n\t\t//Прямоугольник\n\t\tp.x = TF_BOX2D(p.xy, vec2(W, H));\n\t} else if (linkForm==2.) {\n\t\t//Эллипс\n\t\tp.x = TF_ELLIPSE2D(p.xy, vec2(W, H));\n\t} else if (linkForm==3.) {\n\t\t//Скругленный прямоугольник\n\t\tp.x = TF_BOX_ROUND(p.xy, vec2(W, H), 1.5*r);\n\t} else {\n\t\t//Капсула\n\t\tp.x = TF_BOX_ROUND(p.xy, vec2(0,H), W);\n\t}\n\tif (linkProfile==1.) {\n\t\t//Квадрат\n\t\treturn TF_BOX(p.xz, r);\n\t} else if (linkProfile==2.) {\n\t\t//Эллипс\n\t\treturn TF_ELLIPSE2D(p.xz, vec2(0.75*r, 1.5*r));\n\t} else if (linkProfile==3.) {\n\t\t//Ромб\n\t\tTF_ROTATE(p.xz, PI/4.);\n\t\treturn TF_BOX(p.xz, r);\n\t} else {\n\t\t//Круг\n\t\treturn TF_BALL(p.xz, r);\n\t}\n}\n\nObject LinkChain( vec3 p, float scale, float id, float linkForm, float atime ) {\n\tvec3 q;\n\n\tTF_SCALE(p, scale);\n\t\n\t// animate\n\tp.y += atime;\n\n\tfloat W, H, r;\n\tif (linkForm==1.) {\n\t\t//Параметры цепи \"Эллипс\"\n\t\tW = 0.24, H = 0.35, r = 0.09;\n\t} else if (linkForm==2.) {\n\t\t//Параметры цепи \"Прямоугольник\"\n\t\tW = 0.24, H = 0.35, r = 0.09;\n\t} else if (linkForm==3.) {\n\t\t//Параметры цепи \"Скругленный прямоугольник\"\n\t\tW = 0.12, H = 0.23, r = 0.09;\n\t} else {\n\t\t//Параметры цепи \"Капсула\"\n\t\tW = 0.22, H = 0.14, r = 0.09;\n\t}\n\n\tObject OBJ1 = Object(FAR, id, p);\n\t{\n\t\tq = p.xyz;\n\t\tq.y -= 0.5; \n\t\tfloat id = TF_REPLICA(q.y, 1.);\n\t\tfloat linkProfile = mod(id, 4.);\n\t\tOBJ1.distance = dfLink(q, W, H, r, linkForm, linkProfile) * scale*0.8;\n\t\tOBJ1.position = q;\n\t}\n\n\tObject OBJ2 = Object(FAR, id, p);\n\t{\n\t\tq = p.zyx; \n\t\tfloat id = TF_REPLICA(q.y, 1.);\n\t\tfloat linkProfile = mod(id, 4.);\n\t\tOBJ2.distance = dfLink(q, W, H, r, linkForm, linkProfile) * scale*0.8;\n\t\tOBJ2.position = q;\n\t}\n\n\treturn OR(OBJ1, OBJ2);\n}\n\nfloat map(vec3 p, inout Object object) {\n\tvec3 q;\n\tfloat d;\n\tfloat CID, linkForm, scale, atime;\n\t\n\tobject = Object(FAR, ID_NONE, p);\n\t\t\n\t//Цепи вдоль X\n\tq = p;\n\tTF_MIRROR(q.y, 12.5);\n\tCID = TF_REPLICA(q.z, 25.);\n\tlinkForm = mod(CID, 4.);\n\tscale = 7.;\n\tatime = 0.25*time;\n\tobject = OR(object, LinkChain(q.zxy, scale, ID_CHAIN_X, linkForm, atime));\n\n\t//Цепт вдоль Z\n    q = p;\n\tTF_MIRROR(q.y, 15.);\n\tTF_MIRROR(q.y, 8.);\n\tCID = TF_REPLICA(q.x, 25.);\n\tlinkForm = mod(CID, 4.);\n\tscale = 6.;\n\tatime = 0.5*time;\n\tobject = OR(object, LinkChain(q.yzx, scale, ID_CHAIN_Z, linkForm, atime));\n\n\t//Цепь вдоль Y\n    q = p;\n\tTF_TRANSLATE(q.xz, -12.5);\n\tTF_REPLICA_LIMIT(q.x, 25., -3., 3.);\n\tCID = TF_REPLICA_LIMIT(q.z, 25., -4., 3.);\n\tlinkForm = mod(CID, 4.);\n\tscale = 8.;\n\tatime = 0.75*time;\n\tobject = OR(object, LinkChain(q.xyz, scale, ID_CHAIN_Y, linkForm, atime));\n\n    return object.distance;\n}\n\nfloat map ( in vec3 p ) {\n\tObject object;\n\treturn map (p, object);\n}\n\nvec3 mapNormal(vec3 p, float eps) {   \n    vec2 e = vec2(eps, 0);\n    return normalize(map(p) - vec3(\n\t\tmap(p-e.xyy),\n\t\tmap(p-e.yxy),\n\t\tmap(p-e.yyx)\n\t));\n}\n\nfloat rayMarch(inout Ray ray) {\n\tray.distance = ray.near;\n\tfloat steps;\n\tfor (float i = 0.; i < 200.; ++i) {\n\t\tray.position = ray.origin + ray.direction * ray.distance;\n\t\tray.object.distance = map(ray.position, ray.object);\n\t\tray.hit = ray.object.distance < ray.epsilon;\n\t\tif (ray.hit) break;\n\t\tray.distance += ray.object.distance*ray.swing;\n\t\tif (ray.distance>ray.far) break;\n\t\tsteps = i + 1.;\n\t\tif (steps>ray.steps) break;\n\t}\n\treturn steps;\n}\n\nfloat softShadow( Ray ray, float k ) {\n    float shade = 1.0;\n    ray.distance = ray.near;    \n\tfloat steps = 1.;\n    for ( int i = 0; i < 50; i++ ) {\n\t\tray.position = ray.origin + ray.direction * ray.distance;\n        ray.object.distance = map(ray.position);\n        shade = min( shade, smoothstep( 0.0, 1.0, k * ray.object.distance / ray.distance)); \n\t\tray.hit = ray.object.distance < ray.epsilon;\n\t\tif (ray.hit) break;\n        ray.distance += min( ray.object.distance, ray.far / ray.steps * 2. ); \n        if (ray.distance > ray.far ) break; \n\t\tsteps++;\n\t\tif (steps>ray.steps) break;\n    }\n    return min( max( shade, 0.0 ) + 0.5, 1.0 ); \n}\n\nvec3 skyColor(vec3 rd) {   \n\treturn mix(vec3(0.0, 0.1, 0.4), vec3(1.0, 0.4, 0.1), 2.*(1.0 - rd.y));\n}\n\nvec3 lighting(Ray ray, Light light, vec3 mColor) {   \n    vec3 lightDir = normalize (light.position - ray.position);\n    float lightDist = max(length(lightDir), .001);\n    float atten = 1.0 / (1.0 + lightDist * 0.125 + lightDist * lightDist * .05);\n   \n\n    float sh = 1.;\n\t#ifdef SOFT_SHADOW\n\t\tRay ray1 = ray;\n\t\t{\n\t\t\tray1.origin = ray.position;\n\t\t\tray1.direction = lightDir;\n\t\t\tray1.steps = 50.;\n\t\t}\n\t\tsh = softShadow(ray1, 20.);\n\t#endif\n\t\n\tlightDir /= atten;\n\tconst float Ka = 0.5;\n    const float shininess = 10.0;\n\tfloat ambi = Ka * (1. + dot(ray.normal, vec3(0., 1., 0.)));\n    float diff = clamp(dot(ray.normal, lightDir), 0.0, 1.0);\n    float spec = pow(max(dot(reflect (-lightDir, ray.normal), -ray.direction), 0.0), shininess);\n    float back = clamp(dot(ray.normal, -lightDir), 0.0, 1.0);\n    vec3 col = mColor*(0.3 * (ambi + back) +  0.7 * diff * sh) + 0.5 * spec * sh;\n    col = col * light.color;\n\treturn col;\n}\n\nvec3 getMaterial (Ray ray) { \n\tvec3 q = ray.object.position; \t\n\tvec3 mColor = vec3(1); \n    if (ray.object.id==ID_CHAIN_X) { \n\t\tmColor = tex3D(u_texture0, q.yzx, ray.normal)*2.;\n\t} else if (ray.object.id==ID_CHAIN_Z) { \n\t\tmColor = tex3D(u_texture0, q.zxy, ray.normal)*2.;\n\t} else if (ray.object.id==ID_CHAIN_Y) { \n\t\tmColor = tex3D(u_texture0, q, ray.normal)*2.;\n\t}\n\treturn mColor;    \n}\n\nvec3 linear2srgb(vec3 c) { \n\treturn mix(12.92 * c,1.055 * pow(c, vec3(1.0/1.8)) - 0.055, step(vec3(0.0031308), c)); \n}\n\nvec3 exposureToneMapping(float exposure, vec3 hdrColor) { \n\treturn vec3(1.0) - exp(-hdrColor * exposure); \n}\n\nvec3 ACESFilm(vec3 x) {   \n\tfloat a,b,c,d,e;\n    a = 2.51; b = 0.03; c = 2.43;d = 0.59; e = 0.14;\n    return (x*(a*x+b))/(x*(c*x+d)+e);\n}\n\nvec3 Render(Ray ray) {  \n\trayMarch(ray);\n\t \n\tvec3 col = vec3(0);\n\n\tif(ray.distance<ray.far) {\n\t\tray.normal = mapNormal(ray.position, 0.01);\n\t\tvec3 mColor = getMaterial(ray);\n\t\tcol =  lighting(ray, light1, mColor);\n\t\tcol += lighting(ray, light2, mColor);\n\t\tcol /= 2.;\n\t\t\n\t\t#if 0\n\t\t\t//\n\t\t\tcol = ACESFilm(col);\n\t\t\tcol = linear2srgb(col);\n\t\t\tcol = (ACESFilm(col) + linear2srgb(col)+col + exposureToneMapping(3.0, col))/4.0;\n\t\t#endif\n\t\t\n\t\t#if 1\n\t\t\t//Подсветка\n\t\t\tfloat fres = pow(clamp(1.0 + dot(ray.direction, ray.normal), 0.0, 1.0), 2.0);\n\t\t\tcol = mix(col, skyColor(reflect(ray.direction, ray.normal))*0.5, fres);\n\t\t#endif\n\t\t      \n    } else {\n    \tcol= skyColor(ray.direction);\n\t}\n\t\n\tcol = pow(col, vec3(1./2.2)); \n\t\n   \treturn col;\n}\n\nvoid main() {  \n\ttime = u_time;\n\n\tfloat aspect = u_canvas.x/u_canvas.y;\n\tvec2 uv = gl_FragCoord.xy/u_canvas.xy;\n\tuv = uv - 0.5;\n\n\tvec2 mouse = u_mouse.xy / u_canvas.xy - 0.5;\n\tif (u_mouse.xy==vec2(0)) mouse = vec2(0);\n\t\n    vec2 ori = vec2(\n        u_mouse.z==0. ? sin(u_time*0.25)*PI/4. : mouse.y*PI*2.,\n        u_mouse.z==0. ? cos(u_time*0.25)*PI/4. : mouse.x*PI*2.\n    );\n\tori.x = clamp(ori.x, -PI/2., PI/2.);\n\n\tCamera cam;\n\t{\n\t\tcam.fov     = 60. ;\n\t\tcam.aspect\t= aspect;\n\t\tcam.origin  = vec3(0.0,0,-25.0); + 10.*vec3(1, 0.0, 1)* TF_ROTATE_Y(radians( time*0.5));\n\t\tcam.target\t= vec3(0, 0, 0);\n\t\tcam.up \t\t= vec3(0, 1, 0);\n\t\tcam.vMat \t= TF_ROTATE_Y(ori.y) * TF_ROTATE_X(ori.x);\n\t\tcam.tMat\t= mat3(1);//TF_ROTATE_Y(ori.y) * TF_ROTATE_X(ori.x);\n\t}\n\n\tRay ray = lookAt(uv, cam);\n\t{\n\t\tray.near \t= 0.01;\n\t\tray.far  \t= FAR;\n\t\tray.epsilon = 0.001;\n\t\tray.swing\t= 1.;\n\t\tray.steps \t= 200.;\n\t}\n\n    vec3 col = Render(ray);\n\t\n    gl_FragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"const float PI = radians(180.);\n//Камера\nstruct Camera {\n\t//Задаваемые параметры\n\tfloat fov, aspect;\n\tvec3  origin, target, up;\n\tmat3 vMat, tMat;\n\t//Расчетные параметры\n\tfloat factor;\n\tvec3  forward, right, position, coord;\n\tmat3 pMat, uMat;\n};\n\n//Параметры объекта\nstruct Object {\n\tfloat   distance;\t//Последнее приближение к объекту сцены\n\tfloat \tid;\t\t\t//id найденого объека сцены\n\tvec3 \tposition;\t//Координатв поверхности объекта\n};\n\n//Луч\nstruct Ray {\n\t//Задаваемые параметры\n\tvec3  origin;\t\t//Начало луча\n\tvec3  direction;\t//Направление луча\n\tfloat near;\t\t\t//Минимальное расстояние от камеры (начало сцены)\n\tfloat far;\t\t\t//Максивальное расстояние от камеры (конец сцены)\n\tfloat epsilon;\t\t//Точность обнаружения поверхности\n\tfloat steps;\t\t//Максимальное число итераций\n\tfloat swing;\t\t//\"+\" -колебание в найденной точке, \"-\"\n\t//Вычисляемые параметры\n\tfloat distance; \t//Расстояние до объекта сцены от ray.origin в направлении ray.direction\n\tvec3  position; \t//Точка поверхности\n\tvec3  normal;\t\t//Нормаль в точке поверхности\n\tbool  hit;\t\t\t//Флаг нахождения точки поверхности с заданной точностью\n\tObject object;\t\t//Параметры объекта (можно формировать непосредственно в карте расстояний)\n};\n//Формирование луча камеры\nRay lookAt (in vec2 uv, inout Camera cam) {\n\t//Расчетные характеристики камеры\n\tcam.factor\t\t= 1.0/tan(radians(cam.fov/2.));\n\tcam.forward \t= normalize(cam.target-cam.origin); \n\tcam.right \t\t= normalize(cross(cam.forward, cam.up));\n\tcam.up \t\t\t= cross(cam.right, cam.forward);\n\tcam.position \t= cam.origin + cam.factor * cam.forward;\n\tcam.coord \t\t= cam.position + uv.x * cam.right*cam.aspect + uv.y * cam.up;\n\tcam.pMat \t\t= mat3(cam.right, cam.up, cam.forward);\n\tvec3 u \t\t\t= - cam.forward.y * cam.forward;\n\tfloat f \t\t= 1. / sqrt (1. - cam.forward.y * cam.forward.y);\n\tcam.uMat \t\t= mat3 (\n\t\tf * vec3 (- cam.forward.z, 0., cam.forward.x), \n\t\tf * vec3 (u.x, 1. + u.y, u.z), \n\t\tvec3 (cam.forward.x, cam.forward.y, cam.forward.z)\n\t);\n\t//Формирование луча\n\tRay ray;\n\t{\n\t\tray.origin \t\t= cam.tMat * cam.origin;\n\t\tray.direction \t= cam.tMat * normalize( cam.pMat * cam.vMat * vec3(uv.x*cam.aspect, uv.y, cam.factor));\n\t\t//Умолчания\n\t\tray.near\t\t= 0.01;\n\t\tray.far\t\t\t= 100.;\n\t\tray.epsilon\t\t= 0.001;\n\t\tray.swing\t\t= 1.0;\n\t\tray.steps\t\t= 200.;\n\t}\n\treturn ray;\n}\n//-------------------функции трансформации и позиционирования объектов сцены\n//Допустимая ошибка (для удаления артефактов) 1./min(u_canvas.x, u_canvas.y)\nfloat EPS = 0.01;\n//Функция расстояния до фигуры со скругленными ребрами (объединение и сглаживание с увеличением на R)\n//float d - сглаживание фигуры\n//vec2 d - объединение и сглаживание двух фигур\n//vec3 d - объединение и сглаживание трех фигур\n//vec4 d - объединение и сглаживание четырех фигур\n#define TF_ROUND(d, R) (length(max(d, 0.)) - (R))\n//Функция расстояния до бокса (p vec3) или прямоугольника (p vec2) со скругленными ребрами\n//Функция расстояния до капсулы, если два размера 0\n#define TF_BOX_ROUND(p, S, R) TF_ROUND(abs(p)-(S), R)\n#define TF_BOX_ROUND1(p, S, R) TF_ROUND(abs(p)-(S) + R, R)\n//Функция расстояния до бокса (p vec3) или прямоугольника (p vec2)\n#define TF_BOX(p, S) TF_ROUND(abs(p) - (S) + EPS, EPS)\n#define TF_BOX1(p, S) TF_ROUND(abs(p) - (S), 0.)\n#define TF_BOX3D(p, S) max(abs((p).x)-(S).x, max(abs((p).y)-(S).y, abs((p).z)-(S).z))\n#define TF_BOX2D(p, S) max(abs(p.x)-S.x, abs(p.y)-S.y)\n//Функция расстояния до шара (p vec3) или круга (p vec2)\n#define TF_BALL(p, R) TF_ROUND(abs(p), R)\n//Эллипс\n#define TF_ELLIPSE3D(p, r) min ((r).x, min((r).y, (r).z)) * TF_BALL(p/(r), 1.)\n#define TF_ELLIPSE2D(p, r) min ((r).x, (r).y) * TF_BALL(p/(r), 1.)\n//Функция расстояния до пространства ДО p1\n#define TF_BEFORE(p, p1) p - (p1)\n#define TF_BEFORE1(p, p1) TF_ROUND(p - (p1) + EPS, EPS)\n//Функция расстояния до пространства ПОСЛЕ p1\n#define TF_AFTER(p, p1) TF_ROUND(-p + (p1) + EPS, EPS)\n//Функция расстояния до симметричного пространства МЕЖДУ -p1 и +p1\n//#define TF_BETWEEN(p, p1) TF_ROUND(abs(p) - (p1) + EPS, EPS)\n#define TF_BETWEEN(p, p1) abs(p) - (p1)\n//Функция расстояния до несимметричного пространства МЕЖДУ p1 и p2\n#define TF_BETWEEN2(p, p1, p2) TF_ROUND( abs(p - 0.5*(p1+p2)) - 0.5*(p2-p1) + EPS, EPS)\n//Перемещение пространства p (float p...vec4 p)\n#define TF_TRANSLATE(p, d) p -= d;\n//Масштаб\n#define TF_SCALE(p, s) p /= s\n//Вращение пространства p (vec2 p)\n#if 0\n\t#define TF_ROTATE(p, a) p = mat2(cos(a), sin(a), -sin(a), cos(a)) * p\n#else\n\t#define TF_ROTATE(p, a) p = p.xy * cos (a) * vec2 (1., 1.) + p.yx * sin (a) * vec2 (-1., 1.)\n#endif\n#define TF_ROTATE_MAT2(a) mat2(cos(a), sin(a), -sin(a), cos(a))\n#define TF_ROTATE_X(a) mat3(1.0,    0.0, 0.0,       0.0, cos(a), -sin(a),   0.0, sin(a), cos(a))\n#define TF_ROTATE_Y(a) mat3(cos(a), 0.0, -sin(a),   0.0, 1.0, 0.0,   \t    sin(a), 0.0, cos(a))\n#define TF_ROTATE_Z(a) mat3(cos(a), -sin(a), 0.0,   sin(a), cos(a), 0.0,   \t0.0, 0.0, 1.0)\n//Отражение пространства p (float p...vec4 p)\n#define TF_MIRROR(p, d) p = abs(p) - (d)\n//Разбиение пространства на повторяющиеся. Возвращает id центра ячейки\n//float p - пространство 1D\n//vec2 p - пространство 2D\n//vec3 p - пространство 3D\n#define TF_REPLICA(p, d) \\\n\tfloor((p/d) + 0.5);\\\n\tp = mod(p + (0.5*d), d) - (0.5*d)\n//Разбиение пространства на повторяющиеся в диапазоне id от ida до idb включительно. Возвращает id центра ячейки\n#define TF_REPLICA_LIMIT(p, d, ida, idb) \\\n\tfloor(p/d + 0.5);\\\n\tp = p-(d)*clamp(floor((p)/(d) + 0.5), ida, idb)\n//Разбиение пространства на повторяющиеся сектора в плоскости vec2 p. Возвращает id сектора\t\n#if 0\n\t#define TF_REPLICA_ANGLE(p, n, off) \\\n\t\tfloor(mod(atan(p.x, p.y) + PI /n + off, 2.*PI)/(2.* PI /n));\\\n\t\tfloat _p_ = mod(atan(p.x, p.y) + PI /n + off, 2.* PI /n) - PI /n;\\\n\t\tp = length(p.xy) * vec2(sin(_p_),cos(_p_))\n#else\n\t#define TF_REPLICA_ANGLE(p, n, off) \\\n\t\tfloor(mod(atan(p.x, p.y) + PI /(n) + off, 2.*PI)/(2.* PI /(n)));\\\n\t\tTF_ROTATE(p.xy, -off);\\\n\t\tTF_ROTATE(p.xy, (2.* PI /(n)) * floor ( atan(p.x, p.y)/(2.* PI /(n)) + 0.5 ) )\n#endif\t\n\n//Возвращает для момента u_time номер отрезка времени 0,1,2...\n//      -------         -------\n//     |       |       |       |\n//_____|       |_______|       |\n#define TF_TIMER(u_time, intervalCount, intervalDuration) mod(floor(u_time/(intervalDuration)), (intervalCount))\n\n//-------------------Функции сочетания расстояний до объектов сцены\n//Сложение / Объединение / ИЛИ\nfloat OR(float distA, float distB) {\n\treturn mix(distA, distB, step(distB, distA)); //if (distB<distA) return distB; return distA;\n}\n//Умножение / Пересечение / И\nfloat AND(float distA, float distB) {\n\treturn mix(distA, distB, step(distA, distB)); //if (distB>distA) return distB; return distA;\n}\n// Минимальная функция сглаживания. Есть бесчисленное множество статей, но IQ объясняет это лучше всего здесь:\n// http://iquilezles.org/www/articles/smin/smin.htm\n//Гладкое сложение / Объединение / ИЛИ (k==0 без)\nfloat OR( float distA, float distB, float k ) {\n\tfloat h = clamp( 0.5 + 0.5*(distB-distA)/k, 0., 1. );\n\treturn mix( distB, distA, h ) - k*h*(1.-h);\n}\n//Гладкое умножение / Пересечение / И (k==0 без)\n#if 0\n\tfloat AND( float distA, float distB, float k ) {\n\t\tfloat h = clamp( 0.5 - 0.5*(distB-distA)/k, 0., 1. );\n\t\treturn mix( distB, distA, h ) + k*h*(1.-h);\n\t}\n#else\n\tfloat AND( float distA, float distB, float k ) {\n\t\treturn - OR (- distA, - distB, k);\n\t}\n#endif\n//Исключение / НЕ\nfloat NOT(float dist) {\n\treturn -dist;\n}\n//-------------------Функции сочетания объектов сцены\n//Сложение / Объединение / ИЛИ\n//object = OR(objectA, objectB)\nObject OR(Object objectA, Object objectB) {\n\tif (objectB.distance<objectA.distance) return objectB;\n\treturn objectA;\n}\n//Мягкое Сложение / Объединение / ИЛИ  \n//object = OR(objectA, objectB, k)\nObject OR(Object objectA, Object objectB, float k) {\n\tObject object = objectA;\n\tif (objectB.distance<objectA.distance) object = objectB;\n\tif (k!=0.) object.distance = OR(objectA.distance, objectB.distance, k);\n\treturn object;\n}\n//Умножение / Пересечение / И\n//object = AND(objectA, objectB)\nObject AND(Object objectA, Object objectB) {\n\tif (objectB.distance>objectA.distance) return objectB;\n\treturn objectA;\n}\n//Мягкое Умножение / Пересечение / И\n//object = AND(objectA, objectB, k)\nObject AND(Object objectA, Object objectB, float k) {\n\tObject object = objectA;\n\tif (objectB.distance>objectA.distance) object = objectB;\n\tif (k!=0.) object.distance = AND(objectA.distance, objectB.distance, k);\n\treturn object;\n}\n//Исключение / НЕ\n//object = NOT(objectA)\nObject NOT(Object object) {\n\tobject.distance = -object.distance;\n\treturn object;\n}\n","name":"Common","description":"","type":"common"}]}