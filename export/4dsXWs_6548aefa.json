{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[{"channel":0,"type":"texture","id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"code":"// The min and max sizes of the circles (in pixels) over time.\n#define MIN_SIZE 2.0\n#define MAX_SIZE 150.0\n\n// Compute the relative distance to the circle, where < 0.0 is outside the feathered border,\n// and > 1.0 is inside the feathered border.\nfloat ComputeCircle(vec2 pos, vec2 center, float radius, float feather)\n{\n    // Determine the distance to the center of the circle.\n\tfloat dist = length(center - pos);\n    \n    // Use the distance and the specified feather factor to determine where the distance lies\n    // relative to the circle border.\n    float start = radius - feather;\n    float end   = radius + feather;\n    return smoothstep(start, end, dist);\n}\n\n// The main function, which is executed once per pixel.\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Prepare the circle parameters, cycling the circle size over time.\n    float cycle = clamp(cos(iTime / 2.0) * 0.6 + 0.7, 0.0, 1.0);\n    float diameter = mix(MAX_SIZE, MIN_SIZE, cycle);\n    float radius = diameter / 2.0;\n    vec2  center = vec2(0.0);\n    \n    // Compute the relative distance to the circle, using mod() to repeat the circle across the display.\n    // A feather value (in pixels) is used to reduce aliasing artifacts when the circles are small.\n    // The position is adjusted so that a circle is in the center of the display.\n    vec2 screenPos = fragCoord.xy - (iResolution.xy / 2.0) - vec2(radius);\n    vec2 pos = mod(screenPos, vec2(diameter)) - vec2(radius);\n    float d = ComputeCircle(pos, center, radius, 0.5);\n    \n    // Compute \"pixelated\" (stepped) texture coordinates using the floor() function.\n    // The position is adjusted to match the circles, i.e. so a pixelated block is at the center of the\n    // display.\n    vec2 count = iResolution.xy / diameter;\n    vec2 shift = vec2(0.5) - fract(count / 2.0);\n    vec2 uv = floor(count * fragCoord.xy / iResolution.xy + shift) / count;\n    \n\t// Sample the texture, using an offset to the center of the pixelated block.\n    // NOTE: Use a large negative bias to effectively disable mipmapping, which would otherwise lead\n    // to sampling artifacts where the UVs change abruptly at the pixelated block boundaries.\n    uv += vec2(0.5) / count;\n    uv = clamp(uv, 0.0, 0.99);\n    uv.y = 1.0 - uv.y;\n    vec3 texColor = texture(iChannel0, uv, -32.0).rgb;    \n    \n\t// Calculate the color based on the circle shape, mixing between that color and a background color.\n    // NOTE: Set the mix factor to 0.0 to see the pixelating effect directly, without the circles.\n    vec3 bg  = vec3(0.0, 0.0, 0.0);\n    vec3 col = mix(texColor, bg, d);\n        \n    // Set the final fragment color.\n\tfragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"4dsXWs","date":"1407870096","viewed":1577,"name":"SIG2014 - First Shadertoy","username":"Sarconix","description":"This is my first Shadertoy, which I started at the SIGGRAPH 2014 hackathon.  It was based on the 2D template, which draws a single circle.  I modified it to show a pixelated image as viewed through a grid of circles that cycle their size over time.","likes":29,"published":1,"flags":0,"usePreview":1,"tags":["siggraph2014"],"hasliked":0,"parentid":"","parentname":""}}