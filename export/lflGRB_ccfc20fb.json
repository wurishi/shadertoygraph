{"ver":"0.1","info":{"id":"lflGRB","date":"1703386362","viewed":142,"name":"Giant's Deep","username":"SL0ANE","description":"想做AA的但是采样了体积不大好处理","likes":8,"published":1,"flags":96,"usePreview":0,"tags":["noise","raymarch","space","planet","outerwilds"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4d3GRl","filepath":"https://soundcloud.com/andrewprahlow/giants-deep","previewfilepath":"https://soundcloud.com/andrewprahlow/giants-deep","type":"musicstream","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// material#1: 深巨星 material#0: 背景\n\n# define MAX_DISTANCE 1024.0\n# define MAX_STEP 512\n# define MIN_DIS_SHADOW 0.064\n# define MIN_DIS_VOL 2.0\n# define BACKGROUND_COLOR vec4(0.004, 0.004, 0.004, 1.0)\n# define SLOANE_COLOR vec4(0.98, 0.52, 0.52, 1.0)\n\n# define LIGHT_DIRECTION vec3(-1.0, -0.5, 1.0)\n# define LIGHT_COLOR vec4(1.0, 1.0, 1.0, 1.0)\n# define LIGHT_STRENGTH 1.5\n# define SHADOW_COLOR vec4(0.20, 0.12, 0.24, 1.0)\n# define ATMO_LIGHT_COLOR vec4(0.6, 1.0, 1.0, 1.0)\n# define ATMO_SHADOW_COLOR vec4(0.4, 0.20, 0.24, 1.0)\n\n# define GIANT_COLOR_0 vec4(36.0, 54.0, 25.0, 255.0) / 255.0\n# define GIANT_COLOR_1 vec4(28.0, 42.0, 26.0, 255.0) / 255.0\n# define CLOUD_COLOR vec4(69.0, 75.0, 48.0, 255.0) / 255.0\n# define GIANT_RADIUS 64.0\n# define GIANT_ATMO_RADIUS 72.0\n\n// Pre\nObjectInfo sceneSolidMap(vec3 point, bool withMat);\nvec4 quaternionMul(vec4 left, vec4 right);\nMaterial sceneBaseMaterial(vec3 point, float len);\nvec4 mainLightShading(vec3 lightDir, float strength, vec4 lightColor, vec4 shadowColor, Material material, vec3 pos, vec3 normal, vec3 view);\nvec4 atmosphereShading(vec4 backGroundColor, vec4 LightColor, vec4 ShadowColor, Material material, vec3 normal);\nvec4 getColorAtPos(vec3 pos, vec3 ray, float len, vec2 screenCoord, float pixelSize, float dis, inout vec3 normal);\n\n// Camera Config\nfloat cameraFov = 80.0f;\n\n// Bone\n\nvec3 positionLocal_Camera = vec3(0.0, 0.0, 0.0);\nvec4 rotationLocal_Camera = vec4(0.0, 0.0, 0.0, 1.0);\nvec3 positionWorld_Camera;\nvec4 rotationWorld_Camera;\n\nvec3 positionLocal_Giant = vec3(0.0, 0.0, 256.0);\nvec4 rotationLocal_Giant = vec4(0.0, 0.0, 0.0, 1.0);\nvec3 positionWorld_Giant;\nvec4 rotationWorld_Giant;\n\n// Object\nObjectInfo sdGiantBase(vec3 p, bool withMat)\n{\n    ObjectInfo outValue = ObjectInfo(0.0, Material(GIANT_COLOR_0, 0.03, 4.0, 0.2, 1));\n    vec3 transPoint = p - positionWorld_Giant;\n    transPoint = rotatePoint(transPoint, vec3(0), quaternionInverse(rotationLocal_Giant));\n    outValue.dis = length(transPoint) - GIANT_RADIUS;\n    vec3 cenVector = normalize(transPoint);\n    float offset = iTime * 1.0;\n    \n    if(withMat)\n    {\n        float u = atan(transPoint.z, transPoint.x) / (PI * 2.0) + 0.5;\n        float v = atan(transPoint.y, sqrt(transPoint.x * transPoint.x + transPoint.z * transPoint.z)) / PI + 0.5;\n        \n        float twist = 0.0625 * (perlin(u, 16.0, 1.0, iTime / 4.0) / 2.0 - 0.5);\n        \n        float t = mix(0.0, fbm(vec2(u, v + twist), 0.0, vec2(1.0, 3.0), vec2(1.0, 65535.0), vec2(iTime / 2.0, 0.0), 4), (1.0 - pow(0.5 - v, 2.0) * 4.0));\n        \n        float cloud = abs(0.5 - v) * 2.0;\n        cloud = clamp((cloud - 0.4) * (0.94 - cloud) * 64.0, 0.0, 1.0);\n        cloud *= fbm(vec2(u, v), 0.25, vec2(2.0, 8.0), vec2(1.0, 65535.0), vec2(iTime / 8.0, 4.0), 3), (1.0 - pow(0.5 - v, 2.0) * 4.0);\n        cloud = clamp(cloud, 0.0, 1.0);\n        \n        outValue.material.baseColor = mix(mix(GIANT_COLOR_0, GIANT_COLOR_1, t), CLOUD_COLOR, cloud);\n        // outValue.material.baseColor = vec4(vec3(perlin(vec2(u, v), vec2(4.0, 3.0), vec2(1.0, 65535.0))), 1.0);\n        // outValue.material.baseColor = vec4(vec3(cloud), 1.0);\n    }\n        \n    return outValue;\n}\n\nObjectInfo sdGiantAtmo(vec3 p, vec3 view, bool withMat)\n{\n    ObjectInfo outValue = ObjectInfo(0.0, Material(vec4(1.0, 1.0, 1.0, 1.0), 42.0, 0.0, 0.0, 128));\n    vec3 cenVector = p - positionWorld_Giant;\n    vec3 transPoint = cenVector;\n    transPoint = rotatePoint(transPoint, vec3(0), quaternionInverse(rotationLocal_Giant));\n    outValue.dis = length(transPoint) - GIANT_ATMO_RADIUS;\n    \n    if(withMat)\n    {\n        float strength = pow(1.0 - abs(dot(normalize(cenVector), view)), 3.0);\n        \n        outValue.material.baseColor.a = -outValue.dis / (GIANT_ATMO_RADIUS - GIANT_RADIUS) * strength;\n    }\n  \n    return outValue;\n}\n\n\n// Util\nvec3 getSolidNormal(vec3 point, float pixelSize)\n{\n    vec3 deltaX = vec3(pixelSize, 0.0, 0.0);\n    vec3 deltaY = vec3(0.0, pixelSize, 0.0);\n    vec3 deltaZ = vec3(0.0, 0.0, pixelSize);\n    \n    float x = sceneSolidMap(point + deltaX, false).dis - sceneSolidMap(point - deltaX, false).dis;\n    float y = sceneSolidMap(point + deltaY, false).dis - sceneSolidMap(point - deltaY, false).dis;\n    float z = sceneSolidMap(point + deltaZ, false).dis - sceneSolidMap(point - deltaZ, false).dis;\n    \n    return normalize(vec3(x, y, z));\n}\n\nvec3 getRoughSolidNormal(vec3 point, float curDis, float pixelSize)\n{\n    vec3 deltaX = vec3(pixelSize, 0.0, 0.0);\n    vec3 deltaY = vec3(0.0, pixelSize, 0.0);\n    vec3 deltaZ = vec3(0.0, 0.0, pixelSize);\n    \n    float x = sceneSolidMap(point + deltaX, false).dis - curDis;\n    float y = sceneSolidMap(point + deltaY, false).dis - curDis;\n    float z = sceneSolidMap(point + deltaZ, false).dis - curDis;\n    \n    return normalize(vec3(x, y, z));\n}\n\nfloat softshadow(vec3 ro, vec3 rd, float mint, float maxt, float k)\n{\n    float res = 1.0;\n    float t = mint;\n    while(t < maxt)\n    {\n        float h = sceneSolidMap(ro + rd * t, false).dis;\n        if(h < TOLERANCE)\n            return 0.0;\n        res = min(res, k * h/t);\n        t += h;\n    }\n    return res;\n}\n\n// Project\n\nObjectInfo sceneSolidMap(vec3 point, bool withMat)\n{\n    ObjectInfo info = sdGiantBase(point, withMat);\n    return info;\n}\n\nObjectInfo sceneVolMap(vec3 point, vec3 view, bool withMat)\n{\n    ObjectInfo info = sdGiantAtmo(point, view, withMat);\n    return info;\n}\n\nvec4 march(vec3 start, vec3 ray, vec3 front, vec2 screenCoord, float pixelSize, inout vec3 pos, inout vec3 normal, inout float len)\n{\n    len = 0.0;\n    float dis = 0.0;\n    vec3 curPos = vec3(0.0);\n    \n    ObjectInfo curSolidInfo;\n    ObjectInfo lastSolidInfo;\n    \n    ObjectInfo curVolInfo;\n    ObjectInfo lastVolInfo;\n    \n    float stepDis;\n    \n    float lenWhenHit;\n    float disWhenHit;\n    int stepCount = 0;\n    float threshold_0;\n    float threshold_1;\n    \n    float curPixelSize;\n    \n    float theta = dot(ray, front);\n    vec4 mixColor = vec4(0.0);\n    vec4 volumnColor = vec4(0.0);\n    float volumnFactor;\n    \n    while(len < MAX_DISTANCE && stepCount <= MAX_STEP)\n    {\n        curPos = len * ray + start;\n        pos = curPos;\n        \n        curPixelSize = len * theta * pixelSize;\n        threshold_0 = curPixelSize * 1.5;\n        \n        // 处理体积部分\n        lastVolInfo = curVolInfo;\n        curVolInfo = sceneVolMap(curPos, ray, true);\n        \n        if(volumnColor.a <= 1.0 && curVolInfo.dis < threshold_0 && lastVolInfo.dis < threshold_0)\n        {\n            vec4 curVolColor = lastVolInfo.material.baseColor;\n            volumnFactor = 1.0 / lastVolInfo.material.t0 * stepDis;\n            \n            // Shading直接在这里做了，不太爽\n            float volShadow = softshadow(pos, -normalize(LIGHT_DIRECTION), MIN_DIS_SHADOW, 32.0, 2.0);\n            volumnColor.rgb += volumnFactor * curVolColor.a * curVolColor.rgb * mix(ATMO_SHADOW_COLOR, ATMO_LIGHT_COLOR, volShadow).rgb;\n            \n            volumnColor.a += volumnFactor * curVolColor.a;\n        }\n        \n        // 处理不透明部分\n        lastSolidInfo = curSolidInfo;\n        curSolidInfo = sceneSolidMap(curPos, false);\n        \n        dis = curSolidInfo.dis;\n        \n        if(dis < threshold_0)\n        {\n            break;\n        }\n              \n        threshold_1 = curPixelSize * 2.0;\n        if(dis < threshold_1 && dis > lastSolidInfo.dis)\n         {\n            float overlapFactor = 1.0 - (dis - threshold_0) / (threshold_1 - threshold_0);\n            vec3 tempNormal;\n            vec4 overlapColor = getColorAtPos(pos, ray, len, screenCoord, curPixelSize, dis, normal);\n            mixColor.rgb += (1.0 - mixColor.a) * overlapFactor * overlapColor.rgb;\n            mixColor.a += (1.0 - mixColor.a) * overlapFactor;\n            if( mixColor.a > 1.0 - TOLERANCE ) break;\n        }\n        \n        stepDis = min(dis, max(abs(curVolInfo.dis), MIN_DIS_VOL)) / 4.0;\n        len += stepDis;\n        stepCount += 1;\n    }\n    \n    vec4 outputColor = getColorAtPos(pos, ray, len, screenCoord, curPixelSize, dis, normal);\n    // AA的作用看上去相当有限，还会使得星球周围出现黑边不好处理\n    // outputColor.rgb = mix(outputColor.rgb, mixColor.rgb / (0.01 + mixColor.w), mixColor.a);\n    outputColor.rgb += volumnColor.rgb;\n    \n    // return volumnColor;\n    return outputColor;\n}\n\nMaterial sceneBaseMaterial(vec3 point, float len, vec2 screenCoord)\n{\n    if(len >= MAX_DISTANCE) {\n        Material outMat;\n        outMat.baseColor = texture(iChannel0, screenCoord);\n        outMat.index = 0;\n        return outMat;\n    } \n    \n    return sceneSolidMap(point, true).material;\n}\n\nvec4 getColorAtPos(vec3 pos, vec3 ray, float len, vec2 screenCoord, float pixelSize, float dis, inout vec3 normal)\n{\n    Material material = sceneBaseMaterial(pos, len, screenCoord);\n    \n    if(material.index == 0) return material.baseColor;\n    \n    normal = getRoughSolidNormal(pos, dis, pixelSize);\n    return mainLightShading(normalize(LIGHT_DIRECTION), LIGHT_STRENGTH, LIGHT_COLOR, SHADOW_COLOR, material, pos, normal, ray);\n}\n\nvoid updateBone()\n{\n    float angle;\n    \n    // 相机\n    positionWorld_Camera = positionLocal_Camera;\n    rotationWorld_Camera = rotationLocal_Camera;\n    \n    \n    // 根\n    positionWorld_Giant = positionLocal_Giant;\n\n    angle = PI / 4.0; \n    rotationLocal_Giant = quaternionMul(vec4(sin(angle / 2.0), 0.0, 0.0, cos(angle / 2.0)), rotationLocal_Giant);\n    angle = -PI / 6.0; \n    rotationLocal_Giant = quaternionMul(vec4(0.0, sin(angle / 2.0), 0.0, cos(angle / 2.0)), rotationLocal_Giant);\n    rotationWorld_Giant = rotationLocal_Giant;\n}\n\nvec4 mainLightShading(vec3 lightDir, float strength, vec4 lightColor, vec4 shadowColor, Material material, vec3 pos, vec3 normal, vec3 view)\n{\n    float expSmoothness = pow(2.7, 5.0 * material.t0 + 1.0);\n    \n    float shodow = softshadow(pos, -lightDir, MIN_DIS_SHADOW, MAX_DISTANCE, 24.0);\n    float lightLevel = clamp(min(dot(-normal, lightDir), shodow), 0.0, 1.0);\n    \n    vec4 diffuse = material.baseColor * mix(shadowColor, lightColor, lightLevel) * strength;\n    \n    float res_0 = dot(normalize(mix(lightDir, view, 0.5)), -normal);\n    lightLevel = pow(clamp(res_0, 0.0, 1.0), expSmoothness);\n    \n    vec4 specular = lightColor * lightLevel * shodow * material.t0 * strength;\n    \n    vec4 fresnel = material.t2 * pow(1.0 + dot(view, normal), material.t1) * material.baseColor * lightColor * strength;\n    \n    return diffuse + specular + fresnel;\n}\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    updateBone();\n    \n    vec2 uv = (fragCoord.xy - iResolution.xy / 2.0) / iResolution.x;\n    float delta = 1.0 / iResolution.x;\n    float tanFov = tan(cameraFov / 360.0 * PI);\n    vec3 ray = normalize(vec3(uv, 0.5 / tanFov));\n    // 平面距离为1时，每个像素对应的大小\n    float pixelSize = 2.0 * tanFov / iResolution.x;\n    vec3 front = rotatePoint(vec3(0.0, 0.0, 1.0), vec3(0.0), rotationWorld_Camera);\n    ray = rotatePoint(ray, vec3(0.0), rotationWorld_Camera);\n    \n    vec3 pos;\n    vec3 normal;\n    float len;\n    \n    vec4 color = march(positionWorld_Camera, ray, front, fragCoord / iResolution.xy, pixelSize, pos, normal, len);\n    // color.rgb = pow(color.rgb, vec3(1.0 / 2.2));\n    \n    fragColor = color;\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"# define PI 3.1415926535897932384626433832795\n# define TOLERANCE 0.0001\n\n# define POINTER_ROT ivec2(0, 1)\n# define POINTER_TIME ivec2(0, 2)\n# define POINTER_PRESS ivec2(0, 3)\n# define POINTER_MOUSE ivec2(0, 4)\n# define POINTER_RESETCAM ivec2(0, 5)\n\n# define store(P, V) if (all(equal(ivec2(fragCoord), P))) fragColor = V\n# define load(P) texelFetch(iChannel2, ivec2(P), 0)\n\n#define keyToggle(ascii)  ( texelFetch(iChannel3,ivec2(ascii,2),0).x > 0.)\n#define keyClick(ascii)   ( texelFetch(iChannel3,ivec2(ascii,1),0).x > 0.)\n#define keyDown(ascii)    ( texelFetch(iChannel3,ivec2(ascii,0),0).x > 0.)\n// Structure\nstruct Material\n{\n    vec4 baseColor;\n    // #0: smoothness, fresnelPower, fresnelScale\n\tfloat t0;\n    float t1;\n    float t2;\n    int index;\n};\n\nstruct ObjectInfo\n{\n\tfloat dis;\n    Material material;\n};\n\n// Util\nvec4 conjugate(vec4 q) {\n    return vec4(-q.x, -q.y, -q.z, q.w);\n}\n\nvec4 quaternionInverse(vec4 q) {\n    return conjugate(q) / dot(q, q);\n}\n\nvec4 quaternionMul(vec4 left, vec4 right)\n{\n    float w = left.w*right.w - left.x*right.x - left.y*right.y - left.z * right.z;\n    float x = left.w*right.x + left.x*right.w + left.z*right.y - left.y * right.z;\n    float y = left.w*right.y + left.y*right.w + left.x*right.z - left.z * right.x;\n    float z = left.w*right.z + left.z*right.w + left.y*right.x - left.x * right.y;\n    \n    return vec4(x, y, z, w);\n}\n\nvec4 quaternionLerp(vec4 starting, vec4 ending, float t)\n{\n    float cosa = starting.x *ending.x + starting.y * ending.y + starting.z *ending.z  + starting.w * ending.w;\n    \n    if (cosa < 0.0) \n    {\n        ending.x = -ending.x;\n        ending.y = -ending.y;\n        ending.z = -ending.z;\n        ending.w = -ending.w;\n        cosa = -cosa;\n    }\n    \n    float k0, k1;\n    \n    if (cosa > 0.9995f) \n    {\n        k0 = 1.0 - t;\n        k1 = t;\n    }\n    else \n    {\n        float sina = sqrt(1.0 - cosa * cosa);\n        float a = atan(sina, cosa);\n        k0 = sin((1.0 - t) * a) / sina;\n        k1 = sin(t * a) / sina;\n    }\n    \n    vec4 result;\n    \n    result.x = starting.x * k0 + ending.x * k1;\n    result.y = starting.y * k0 + ending.y * k1;\n    result.z = starting.z * k0 + ending.z * k1;\n    result.w = starting.w * k0 + ending.w * k1;\n    \n    return result;\n}\n\nvec3 rotatePoint(vec3 p, vec3 center, vec4 q) {\n    vec4 pQuaternion = vec4(p - center, 0.0);\n\n    vec4 rotatedP = quaternionMul(quaternionMul(q , pQuaternion), conjugate(q));\n    vec3 rotatedPoint = rotatedP.xyz;\n    \n    rotatedPoint += center;\n    \n    return rotatedPoint;\n}\n\nfloat multiStep(float value, float level, float minValue)\n{\n    if(level <= 1.0) return 1.0;\n    \n    float curLevel = floor(value * level);\n    curLevel += mix(minValue, 1.0, curLevel / (level - 1.0));\n    \n    return curLevel / level;\n}\n\nfloat smin(float a, float b, float k)\n{\n    float h = max(k - abs(a - b), 0.0);\n    return min(a, b) - h * h * 0.25 / k;\n}\n\nfloat xor(float a, float b)\n{\n    if(a >= 0.0 && b >= 0.0) return min(a, b);\n    if(a < 0.0 && b >= 0.0) return -min(-a, b);\n    if(a >= 0.0 && b < 0.0) return -min(a, -b);\n    return min(-a, -b);\n}\n\nuint murmurHash12(uvec2 src) {\n    const uint M = 0x5bd1e995u;\n    uint h = 1190494759u;\n    src *= M; src ^= src>>24u; src *= M;\n    h *= M; h ^= src.x; h *= M; h ^= src.y;\n    h ^= h>>13u; h *= M; h ^= h>>15u;\n    return h;\n}\n\nfloat hash12(vec2 src) {\n    uint h = murmurHash12(floatBitsToUint(src));\n    return uintBitsToFloat(h & 0x007fffffu | 0x3f800000u) - 1.0;\n}\n\nuint murmurHash11(uint src) {\n    const uint M = 0x5bd1e995u;\n    uint h = 1190494759u;\n    src *= M; src ^= src>>24u; src *= M;\n    h *= M; h ^= src;\n    h ^= h>>13u; h *= M; h ^= h>>15u;\n    return h;\n}\n\nfloat hash11(float src) {\n    uint h = murmurHash11(floatBitsToUint(src));\n    return uintBitsToFloat(h & 0x007fffffu | 0x3f800000u) - 1.0;\n}\n\nuvec2 murmurHash22(uvec2 src) {\n    const uint M = 0x5bd1e995u;\n    uvec2 h = uvec2(1190494759u, 2147483647u);\n    src *= M; src ^= src>>24u; src *= M;\n    h *= M; h ^= src.x; h *= M; h ^= src.y;\n    h ^= h>>13u; h *= M; h ^= h>>15u;\n    return h;\n}\n\nvec2 hash22(vec2 src) {\n    uvec2 h = murmurHash22(floatBitsToUint(src));\n    return uintBitsToFloat(h & 0x007fffffu | 0x3f800000u) - 1.0;\n}\n\nfloat perlin(float p, float freq, float rep, float offset)\n{\n    p += offset / freq;\n    p *= freq;\n    \n\tvec2 i = vec2(floor(p)) + vec2(0.0, 1.0);\n    i = mod(i, vec2(rep * freq));\n\tfloat f = fract(p);\n\tfloat u = f * f * (3.0 - 2.0 * f);\n\treturn mix(hash11(i.x), hash11(i.y), u);\n}\n\nfloat perlin(vec2 p, vec2 freq, vec2 rep, vec2 offset)\n{\n    p += offset / freq;\n    p *= freq;\n    vec4 gridSet = floor(p.xyxy) + vec4(0.0, 0.0, 1.0, 1.0);\n    vec4 dirSet = fract(p.xyxy) - vec4(0.0, 0.0, 1.0, 1.0);\n    // 必要时保证噪声在连接处连续\n    gridSet = mod(gridSet, (rep * freq).xyxy);\n    \n    vec2 gridLevel_00 = hash22(gridSet.xy) * 2.0 - 1.0;\n    vec2 gridLevel_01 = hash22(gridSet.xw) * 2.0 - 1.0;\n    vec2 gridLevel_10 = hash22(gridSet.zy) * 2.0 - 1.0;\n    vec2 gridLevel_11 = hash22(gridSet.zw) * 2.0 - 1.0;\n    \n    float product_00 = dot(gridLevel_00, dirSet.xy);\n    float product_01 = dot(gridLevel_01, dirSet.xw);\n    float product_10 = dot(gridLevel_10, dirSet.zy);\n    float product_11 = dot(gridLevel_11, dirSet.zw);\n    \n    float t_0 = pow(dirSet.x, 3.0) * (6.0 * pow(dirSet.x, 2.0) - 15.0 * dirSet.x + 10.0);\n    float t_1 = pow(dirSet.y, 3.0) * (6.0 * pow(dirSet.y, 2.0) - 15.0 * dirSet.y + 10.0);\n    \n    // return dirSet.x;\n    return mix(mix(product_00, product_10, t_0), mix(product_01, product_11, t_0), t_1);\n}\n\nfloat voronoi(vec2 p) {\n    vec2 point = floor(p);\n    vec2 f = fract(p);\n    float res = 0.0;\n    for (int j = -1; j <= 1; j++) {\n        for (int i = -1; i <= 1; i++) {\n            vec2 b = vec2(i, j);\n            vec2 r = vec2(b) - f + hash22(point + b);\n            res += 1.0 / pow(dot(r, r), 8.0);\n      }\n  }\n  return pow(1.0 / res, 0.0625);\n}\n\nfloat fbm(vec2 x, float H, vec2 freq, vec2 rep, vec2 offset, int numOctaves)\n{    \n    float G = exp2(-H);\n    float f = 1.0;\n    float a = 1.0;\n    float t = 0.0;\n    for( int i=0; i < numOctaves; i++ )\n    {\n        t += a * perlin(f * x, freq, f * rep, offset / freq);\n        f *= 2.0;\n        a *= G;\n    }\n    return t;\n}\n\nMaterial objectMix(Material a, Material b, float k)\n{\n    Material outMat = a;\n    outMat.baseColor = mix(a.baseColor, b.baseColor, k);\n\toutMat.t0 = mix(a.t0, b.t0, k);\n    outMat.t1 = mix(a.t1, b.t1, k);\n    outMat.t2 = mix(a.t2, b.t2, k);\n    \n    return outMat;\n}\n\nObjectInfo objectSmoothMin(ObjectInfo a, ObjectInfo b, float k)\n{\n    float h = max(k - abs(a.dis - b.dis), 0.0);\n    ObjectInfo outInfo = a;\n    float rate;\n    if(a.dis < b.dis) rate = a.dis / b.dis * 0.5;\n    else rate = 1.0 - b.dis / a.dis * 0.5;\n    outInfo.material = objectMix(a.material, b.material, rate);\n    outInfo.dis = min(a.dis, b.dis) - h * h * 0.25 / k;\n    \n    return outInfo;\n}\n\nObjectInfo objectMin(ObjectInfo a, ObjectInfo b)\n{\n    if(a.dis > b.dis ) return a;\n    else return b;\n}\n\n// Shape\nfloat sdSphere(vec3 p, vec3 sdf_pos, vec4 sdf_rot, float sdf_rad)\n{\n    vec3 transPoint = p - sdf_pos;\n    transPoint = rotatePoint(transPoint, vec3(0), quaternionInverse(sdf_rot));\n    return distance(transPoint, vec3(0)) - sdf_rad;\n}\n\nfloat sdEllipsoid(vec3 p, vec3 sdf_pos, vec4 sdf_rot, vec3 sdf_rad)\n{\n    vec3 transPoint = p - sdf_pos;\n    transPoint = rotatePoint(transPoint, vec3(0), quaternionInverse(sdf_rot));\n    float k0 = length(transPoint / sdf_rad);\n    float k1 = length(transPoint / (sdf_rad * sdf_rad));\n    return k0 * (k0-1.0) / k1;\n}\n\nfloat sdCapsule(vec3 p, vec3 sdf_pos_0, vec3 sdf_pos_1, float sdf_rad)\n{\n    vec3 pa = p - sdf_pos_0, ba = sdf_pos_1 - sdf_pos_0;\n    float h = clamp(dot(pa, ba)/dot(ba, ba), 0.0, 1.0);\n    return length( pa - ba*h ) - sdf_rad;\n}","name":"Common","description":"","type":"common"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define STAR_DENSITY 32.0\n#define STAR_POSIBILITY 0.96\n\nfloat star(vec2 p) {\n    vec2 point = floor(p);\n    vec2 f = fract(p);\n    float res = -1.0;\n    float minDis = 1024.0;\n    vec2 starPos;\n    for (int j = -1; j <= 1; j++) {\n        for (int i = -1; i <= 1; i++) {\n            vec2 b = vec2(i, j);\n            vec2 r = vec2(b) - f + hash22(point + b);\n            vec2 curPos = r + f + point;\n            \n            float showStar = hash12(curPos);\n            float dis = dot(r, r);\n            \n            if(minDis > dis && showStar > STAR_POSIBILITY)\n            {\n                minDis = dis;\n                res = sqrt(dis);\n                starPos = curPos;\n            }\n      }\n  }\n  if(res == -1.0)\n  {\n      res = 0.0;\n      return res;\n  }\n  \n  float starRad = 0.3 * perlin(starPos.x + 256.0 * starPos.y, 16.0, 1.0, iTime);\n  res = (starRad - res) / starRad;\n  float starBrightness = pow(starRad, 0.25);\n  res = clamp(res * starBrightness, 0.0 , 1.0);\n  return res;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord / iResolution.x * 2.0 - 1.0) * STAR_DENSITY;\n\n    // Output to screen\n    fragColor = vec4(vec3(star(uv)), 1.0);\n}","name":"Buffer A","description":"","type":"buffer"}]}