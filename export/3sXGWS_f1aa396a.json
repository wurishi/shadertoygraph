{"ver":"0.1","info":{"id":"3sXGWS","date":"1547627259","viewed":149,"name":"Knighty's dragon with mouse","username":"thesage1014","description":"Knighty's dragon with mouse. I did only tiny changes to make knighty's shader work with mouse","likes":11,"published":1,"flags":0,"usePreview":0,"tags":["distanceestimation"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"////////////////////////////////////////////////////////////////////////////////\n// Distance estimation for dragon IFS. by knighty (nov. 2014).\n////////////////////////////////////////////////////////////////////////////////\n\n#define DEPTH 15\n//The refine step doesn't work well :-/\n//#define REFINE_DE\n//interior only mode is much faster :-)\n#define INTERIOR_ONLY\n////////////////////////////////////////////////////////////////////////////////\n\n#ifdef INTERIOR_ONLY\n#ifdef REFINE_DE\n#undef REFINE_DE\n#endif\n#endif\n\n#define ITER_NUM pow(2., float(DEPTH))\n//Bounding radius to bailout. must be >1. higher values -> more accurate but slower (try 1000)\n//for raymarching a value of 2 or 4 is enought in principle. A vuale of 1 (when REFINE_DE is undefined) will show the bounding circle and its transformations\n#ifdef INTERIOR_ONLY\n#define BR2BO 0.99\n#else\n#define BR2BO 64.\n#endif\nvec2  A0   = vec2(1.,-1.);//1st IFS's transformation similatrity\nvec2  F0   = vec2(-1.,0.);//fixed point of 1st IFS's transformation.\nvec2  T0; //Translation term Computed in ComputeBC().\nfloat scl0;// = length(A0);//scale factor of the 1st IFS's \n\n//2nd IFS's transformation.\nvec2  A1   = vec2(-1.,-1.);\nvec2  F1   = vec2(1.,0.);\nvec2  T1;\nfloat scl1;// = length(A1);\n\nfloat Findex=0.;//mapping of IFS point to [0,1[\nfloat minFindex=0.;//for colouring\nfloat BR;//Computed in ComputeBC(). Bounding circle radius. The smaller, the better (that is faster) but it have to cover the fractal (actually it have to cover it's images under the transforms)\nfloat BO;//Computed in ComputeBC(). Bailout value. it should be = (BR*s)^2 where s>1. bigger s give more accurate results but is slower.\n\n//Complex multiplication\nvec2 Cmult(vec2 a, vec2 b){ return vec2(a.x*b.x-a.y*b.y, a.x*b.y+a.y*b.x);}\n\n//Compute bounding circle\nvoid ComputeBC(){\n    //Compute bounding circle center w.r.t. fixed points\n    float ss0=length(vec2(1.,0.)-A0);\n    float ss1=length(vec2(1.,0.)-A1);\n    float s= ss1*(1.-scl0)/(ss0*(1.-scl1)+ss1*(1.-scl0));\n    vec2 C=F0+s*(F1-F0);\n    //Translate the IFS in order to center the bounding circle at (0,0)\n    F0-=C;\n    F1-=C;\n    //Pre-compute translations terms\n    T0 = Cmult(vec2(1.,0.)-A0,F0);\n    T1 = Cmult(vec2(1.,0.)-A1,F1);\n    //Bounding circle radius\n    BR = -ss0*length(F0)/(1.-scl0);\n    //\n    BO = BR*BR*BR2BO;\n}\n\n//Computes distance to the point in the IFS which index is the current index.\n//lastDist is a given DE. If at some level the computed distance is bigger than lastDist\n//that means the current index point is not the nearest so we bail out and discard all\n//children of the current index point.\n//We also use a static Bail out value to speed things up a little while accepting less accurate DE.\nfloat dragonSample(vec2 p, float lastDist){\n\tfloat q=Findex;//Get the index of the current point\n\tfloat dd=1.;//running scale\n\tfloat j=ITER_NUM;\n\tfor(int i=0; i<DEPTH; i++){\n        float l2=dot(p,p);\n#ifndef INTERIOR_ONLY\n\t\tfloat temp=BR+lastDist*dd;//this is to avoid computing length (sqrt)\n\t\tif(l2>0.001+temp*temp || l2>BO) break;//continue;//continue is too slow here\n#else\n        if(l2>BO) break;\n#endif\n\t\t\n\t\t//get the sign of the translation from the binary representation of the index\n\t\tq*=2.;\n        float sgn=floor(q); q=fract(q); j*=.5;\n\t\t\n        if(sgn==0.){\n            p=Cmult(A0,p)+T0;\n            dd*=scl0;\n        } else {\n            p=Cmult(A1,p)+T1;//similarity\n            dd*=scl1;\n        }\n\t}\n\t//update current index. it is not necessary to check the next j-1 points.\n\t//This is the main optimization\n\tFindex = ( Findex + j*1./ITER_NUM );\n#ifdef REFINE_DE\n    for(int i=0; i<DEPTH; i++){\n        if(j==1.) break;\n        j*=0.5;\n        vec2 p0=Cmult(A0,p)+T0, p1=Cmult(A1,p)+T1;\n        if(dot(p0,p0)<dot(p1,p1)){p=p0; dd=dd*scl0;}\n        else {p=p1; dd=dd*scl1;}\n    }\n#endif\n    float d=(length(p)-1.*BR)/dd;//distance to current point\n\tif(d<lastDist) minFindex=Findex;\n\treturn min(d,lastDist);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    A0 = vec2((iMouse.x/iResolution.x*1.)-1.,-(iMouse.y/iResolution.y*1.)-1.);\n\tscl0 = length(A0);\n    scl1 = length(A1);\n    float t=iTime*0.2-.5*3.14159;\n    vec2 rot=vec2(cos(t),sin(t));\n    A1=Cmult(rot,A0);\n    ComputeBC();\n    //coordinates of current pixel in object space. \n\tvec2 uv = 1.7*BR*(fragCoord.xy-0.5*iResolution.xy) / iResolution.y;\n\t//Get an estimate. not necessary, but it's faster this way.\n\tfloat d=length(uv)+0.5;\n\t//refine the DE\n\tfor(int i=0; i<500; i++){//experiment: try other values\n\t// In principle max number of iteration should be ITER_NUM but we actually\n\t//do much less iterations. Maybe less than O(DEPTH^2). Depends also on scl.\n\t\td=dragonSample(uv,d);\n\t\tif(Findex>=1.) break;\n\t}\n#ifdef INTERIOR_ONLY\n    d=max(0.,-d);\n#endif\n\tfragColor = vec4(pow(abs(d),0.2))*(0.75+0.25*sin(vec4(15.,6.5,3.25,1.)*minFindex));//\n}","name":"Image","description":"","type":"image"}]}