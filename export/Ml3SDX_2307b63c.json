{"ver":"0.1","info":{"id":"Ml3SDX","date":"1481811267","viewed":474,"name":"TSAA Study","username":"public_int_i","description":"Testing temporal super sampling","likes":5,"published":1,"flags":96,"usePreview":0,"tags":["study","sampling","super","temporal"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Ethan Alexander Shulman 2016\n\n//Testing out temporal super sampling using 1/2 the resolution,\n//this has no reprojection its more a test on mapping low res pixels -> high res\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = texture(iChannel0, fragCoord/iResolution.xy);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XdXGzn","filepath":"/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","previewfilepath":"/media/ap/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Ms23WW","filepath":"https://soundcloud.com/maggs-2/bassnectar-magical-world-feat","previewfilepath":"https://soundcloud.com/maggs-2/bassnectar-magical-world-feat","type":"musicstream","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//Ethan Alexander Shulman 2016\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 tuv = fragCoord/(iResolution.xy/2.),\n        uv = tuv - .5,\n        muv = uv;\n    \n    if (tuv.x > 1. || tuv.y > 1.) {\n        return;\n    }\n    \n    for (int i = 0; i < 7; i++) {\n        float t = float(i)+iTime*(1.+float(i))*.1;\n        muv = abs(muv)*mat2(sin(t),cos(t),-cos(t),sin(t));\n    \tmuv = abs(muv)-(float(i)*.1);\n    }\n    \n    \n    float sx = mod(abs(atan(muv.y,muv.x))/9.-iTime*.04, .5);\n    float freq = max( texture(iChannel1, vec2(sx,0.)).x,\n                     texture(iChannel1, vec2(sx,.25)).x );\n    freq *= 1.+sx*2.;\n    \n    float line = (length(max(abs(uv), 0.))-freq*.3)*10.;\n    line = max(0., line-max(0.,line-1.)*2.);\n\tline *= line;\n    \n    vec3 c = texture(iChannel3, floor(abs(muv*14.)-iTime)/64.).xyz*\n                 texture(iChannel3, floor(abs(muv*14.+freq)-iTime)/64.).x;\n    \n    c = c+c*line+line;\n    \n    fragColor = vec4(texture(iChannel0,uv*(.98+freq*.05+cos(iTime*.324+freq*7.342)*.005*freq)+.5).x*.9,\n                     texture(iChannel0,uv*(.98+freq*.05+cos(iTime+.294+freq*12.342)*.005*freq)+.5).y*.9,\n                     texture(iChannel0,uv*(.98+freq*.05+cos(iTime*.794+.593+freq*3.1324)*.005*freq)+.5).z*.9,\n                     1.)+\n        \t\tvec4(c, 1.)*.1;\n}","name":"Buf A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"//Ethan Alexander Shulman 2016\n\n\n\n#define CONE_PATHS 1\n\n\n    \n#define EPSILON .01\n\n#define nObjects 2\nfloat objectDistances[nObjects];\n\nstruct material {\n    vec3 diffuse,specular,emissive;\n    float roughness,metallic;\n};\n\nvec2 rot(vec2 p, float ang) {\n    return p*mat2(sin(ang),cos(ang),-cos(ang),sin(ang));\n}\n\nfloat df(vec3 p) {\n    objectDistances[0] = min(length(max(abs(abs(p)-6.)-vec3(1.,10.,1.), 0.)),\n        \t\t\t\t\tlength(p-vec3(0.,8.,0.))-2.);\n    \n    vec3 d = abs(p) - vec3(20.,10.,20.);\n    objectDistances[1] = abs(min(max(d.x,max(d.y,d.z)),0.0) +\n         length(max(d,0.0)));\n    \n    return min(objectDistances[0], objectDistances[1]);\n}\n\nvec3 normal(vec3 p) {\n    vec2 NE = vec2(EPSILON, 0.);\n    return normalize(vec3( df(p+NE.xyy)-df(p-NE.xyy),\n                           df(p+NE.yxy)-df(p-NE.yxy),\n                           df(p+NE.yyx)-df(p-NE.yyx) ));\n}\n\nmaterial mat(vec3 p) {\n   \tbool isph = length(p-vec3(0.,8.,0.)) < 2.01;\n    if (objectDistances[0] < objectDistances[1] && ! isph) {\n        //pillars\n        return material(vec3(.8), vec3(.8), vec3(0.), 0.8, 0.);\n    } else {\n        if (abs(p.y)/10. > max(abs(p.x),abs(p.z))/20. && !isph) {\n            //floor and ceiling\n        \treturn material(vec3(0.93,.93,0.92), vec3(0.), vec3(0.), .2, 0.);\n        } else {\n            if (abs(p.x) > abs(p.z) || isph) {\n                //emissive music visualizer wall + sphere\n                vec3 ts = pow(texture(iChannel0, p.zy*vec2(.025,.05)/2.+.5/2.).xyz, vec3(2.2*1.6));\n        \t\treturn material(vec3(0.0), vec3(0.0), ts*100., 0., 0.);\n            } else {\n                //walls\n        \t\treturn material(vec3(.84,.83,.84), vec3(0.8), vec3(0.0), .6, 0.);\n            }\n        }\n    }\n}\n\n\nfloat rand(vec3 s) {\n    \n    //Thanks to Shane for the improved random function\n    return fract(cos(dot(s, vec3(7, 157, 113)))*43758.5453);\n\n    /* old\n    return fract( (fract(s.x*32.924)*8. + fract(s.x*296.234) +\n                 fract(s.y*32.924)*8. + fract(s.y*296.234) +\n                 fract(s.z*32.924)*8. + fract(s.z*296.234))*98.397 );*/\n}\nvec3 randDir(vec3 s) {\n    return vec3(sin(rand(s.yzx+.89234)*34.24),\n                cos(rand(s.zxy-1.445)*34.24),\n                -cos(rand(s)*34.35));\n}\n\n\nvec3 ilTrace(vec3 rp, vec3 rd, float rough, float seed) {\n     \n    float blur = rough;\n    float coneSize = 16.*blur,//10.*(blur*.8+.2),\n        \t\tconeRand = .5*blur,\n        \t\taddMult = .1,\n        \t\talphaMult = .5;//.25+(1.-blur)*.5;\n    \n    \n    vec4 c = vec4(0.);//color sum, w is alpha/opacity\n    vec3 lp = rd;\n    float s = 0.,ld = 0.;\n    for (int i = 0; i < 128; i++) {\n        vec3 p = rp+normalize(rd+randDir(lp+vec3(seed,seed*1.1294,seed*.1294))*coneRand)*s;\n        float d = df(p);\n        \n        float alpha = max(0., 1.-abs(d)/min(s*.2,coneSize))*addMult;\n        c += vec4(mat(p).emissive*alpha,alpha*alphaMult);\n        \n        if (c.w > 1.) break;\n        \n        s += d*(.1+rand(p+vec3(seed,seed*1.1294,seed*.1294))*.4);\n    \tlp = p;\n        ld = d;\n    }\n    \n    return c.xyz*c.w*.5;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 R = iResolution.xy/2.,\n        uv = fragCoord.xy*2.;//(fragCoord.xy*2. - R)/R.y;\n    \n    //uv jitter for temporal sampling\n    uv += randDir(vec3(uv,float(iFrame)/60.)).xy;\n        \n    uv = (uv-R)/R.y;\n    \n    vec2 suv = fragCoord/iResolution.xy;\n    if (suv.x > 0.5 || suv.y > 0.5) {\n        return;\n    }\n    \n    \n    vec3 rp = vec3(sin(float(iFrame)/660.)*15., 4., cos(float(iFrame)/660.)*15.);\n    vec3 rd = normalize(vec3(uv,-1.));\n    rd.y = -rd.y;\n    rd.yz = rot(rd.yz,1.8);\n    rd.zx = rot(rd.zx,float(iFrame)/660.+1.5);\n    \n    float s = 0.;\n    for (int i = 0; i < 77; i++) {\n        float d = df(rp+rd*s);\n        if (d < EPSILON) break;\n        s += d;\n    }\n    \n    vec3 hp = rp+rd*s;\n    if (df(hp) >= EPSILON) {\n        fragColor = vec4(0.);\n        return;\n    }\n    \n    vec3 n = normal(hp);\n    material m = mat(hp);\n    \n    vec3 c = m.emissive;\n    \n    vec3 il = vec3(0.);\n    //cone paths\n    for (int i = 0; i < CONE_PATHS; i++) {\n        il += ilTrace(hp+n*.1, mix(reflect(rd,n),n,max(0.0,m.roughness-0.5)*2.0), m.roughness*.95+0.05, float(i));\n    }\n    c += m.diffuse*il/float(CONE_PATHS);\n    \n    \n    fragColor = vec4(pow(c,vec3(1.0/2.2)), 1.);\n}","name":"Buf B","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"//Ethan Alexander Shulman 2016\n\n\nfloat rand(vec3 s) {\n    \n    //Thanks to Shane for the improved random function\n    return fract(cos(dot(s, vec3(7, 157, 113)))*43758.5453);\n\n    /* old\n    return fract( (fract(s.x*32.924)*8. + fract(s.x*296.234) +\n                 fract(s.y*32.924)*8. + fract(s.y*296.234) +\n                 fract(s.z*32.924)*8. + fract(s.z*296.234))*98.397 );*/\n}\nvec3 randDir(vec3 s) {\n    return vec3(sin(rand(s.yzx+.89234)*34.24),\n                cos(rand(s.zxy-1.445)*34.24),\n                -cos(rand(s)*34.35));\n}\n\n\nvec2 rot(vec2 p, float ang) {\n    return p*mat2(sin(ang),cos(ang),-cos(ang),sin(ang));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 suv = fragCoord/iResolution.xy;\n    vec4 c = vec4(texture(iChannel1, suv).xyz,1.)*10.;\n    \n    \n    vec2 R = iResolution.xy*2.,\n         cuv = fragCoord.xy,\n         buv = floor(fragCoord.xy/2.);//lower res base uv\n    \n    //add temporal sample portions from surrounding pixels\n    for (int x = -1; x < 2; x++) {\n        for (int y = -1; y < 2; y++) {\n            vec2 uv = buv*2.+vec2(x,y)+0.5;//(fragCoord.xy*2. - R)/R.y;\n            \n            //uv jitter\n            uv += randDir(vec3(uv,float(iFrame)/60.)).xy;\n\n            float portion = max(0.,1.-length(cuv-uv));\n            c += vec4(texture(iChannel0, uv/R).xyz,1.)*portion;\n            //fragColor = texture(iChannel0, suv/2.);\n        }\n    }\n    \n    //fragColor = texture(iChannel0, suv/2.);\n    fragColor = vec4(clamp(c.xyz/c.w,0.,1.),1.);\n}","name":"Buf C","description":"","type":"buffer"}]}