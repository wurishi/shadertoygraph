{"ver":"0.1","info":{"id":"cttcDj","date":"1699656760","viewed":25,"name":"Tp infomatique graphique ","username":"Tamazgha","description":"Rendu tp informatique graphique ","likes":0,"published":1,"flags":0,"usePreview":0,"tags":[],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"struct Material {\n    vec3 ambient; // Composante ambiante\n    vec3 diffuse; // Composante diffuse\n    vec3 specular; // Composante spéculaire\n};\n\n\n\nstruct Sphere {\n    vec3 c; // Centre\n    float r; // Radius\n    int i; // Texture Id\n};\n\n\n\nstruct Box {\n    vec3 min; // Coin inférieur\n    vec3 max; // Coin supérieur\n    int i; // Texture Id\n};\n\n\n\nstruct Cylinder {\n    vec3 p; // Point du cnetre\n    vec3 d; // direction de l'axe de symétrie du cylindre\n    float r; //rayon du cylindre\n    float h; // Height\n    int i; // Texture Id\n};\n\n\n\nstruct Ellipsoid {\n    vec3 c; // Centre\n    vec3 radii; // Demis axes principaux d'un ellipsoide\n    int i; // Texture Id\n};\n\n\n\nstruct Capsule {\n    vec3 p1; // Position du premier bout de la capsule\n    vec3 p2; // Position du deuxième bout de la capsule\n    float r; // Rayon de la capsule\n    int i; // Texture Id\n};\n\n\n\nstruct Plane {\n    vec3 n; // Normale\n    vec3 p; // Point\n    int i; // Texture Id\n};\n\n\n\nstruct Hit {\n    float t; // Intersection depth\n    vec3 n; // Normal\n    int i; // Texture Id\n};\n\n\n\nstruct Ray {\n    vec3 o; // Origin\n    vec3 d; // Direction\n};\n\n\n\nstruct Torus {\n    vec3 center; // Centre du tore \n    float majorRadius; // Rayon majeur du tore\n    float minorRadius; // Rayon mineur du tore\n    int i; // Texture Id\n};\n\n\n\n// Compute point on ray\nvec3 Point(Ray ray,float t) {\n    return ray.o+t*ray.d;\n}\n\n\n\n//texture Damiers\nfloat Checkers(in vec2 p){\n    // Filter kernel\n    vec2 w=fwidth(p)+.001;\n    // Box box filter\n    vec2 i=2.*(abs(fract((p-.5*w)*.5)-.5)-abs(fract((p+.5*w)*.5)-.5))/w;\n    // xor pattern\n    return.3-.4*i.x*i.y;\n}\n\n\n\nvec3 RadialTexture(vec3 p) {\n    // Définir les paramètres de la texture radiale\n    vec3 center = vec3(1.0, 1.0, 0.0);\n    float frequency = 6.0;\n    float amplitude = 0.2;\n\n    // Calcule la distance entre le point `p` et le centre de la texture radiale\n    float distance = length(p - center);\n\n    // Calcule la valeur de la texture radiale en fonction de la distance\n    float pattern = cos(frequency * distance) * amplitude;\n\n    // Couleur de base\n    vec3 baseColor = vec3(0.4, 0.09, 0.0);\n\n    // Couleur radiale\n    vec3 radialColor =vec3(0.6, 0.6, 0.0);\n\n    // Mélange la couleur de base avec la texture radiale\n    return mix(baseColor, radialColor, pattern);\n}\n\n\n\nvec3 MarbleTexture(vec3 p) {\n    float scale = 6.0;\n    float turbulence = 6.0;\n    float amplitude = 9.0; // Augmente l'amplitude pour des motifs plus clairs\n    vec3 marbleColor = vec3(0.1, 0.6, 0.9);\n\n    for (int i = 0; i < 4; i++) {\n        turbulence += amplitude * (sin(scale * p.x) * sin(scale * p.y) * sin(scale * p.z));\n        scale *= 0.8;\n        amplitude *= 0.6;\n        p *= 2.0;\n    }\n\n    float f = 0.5 * sin(turbulence);\n    return marbleColor + f * vec3(0.5);\n}\n\n\n\n\nMaterial Texture(vec3 p, int i){\n    if (i == 1)\n    {\n        // Créer un matériau avec les trois composantes\n        Material mat;\n        mat.ambient = vec3(0.4, 0.1, 0.2);\n        mat.diffuse = vec3(1.9, 1.5, 0.4);\n        mat.specular = vec3(1.0, 1.0, 3.0);\n        return mat;\n    }\n    else if (i == 0)\n    {\n        // Calculer la texture du damier\n        float f = Checkers(0.5 * p.xy);\n        vec3 ambient = vec3(0.2, 0.2, 0.2);\n        vec3 diffuse = vec3(0.4, 0.5, 0.7) + f * vec3(0.7);\n        vec3 specular = vec3(1.0, 1.0, 1.0);\n        Material mat;\n        mat.ambient = vec3(0.2, 0.2, 0.2);\n        mat.diffuse =vec3(0.4, 0.5, 0.7) + f * vec3(0.7);\n        mat.specular = vec3(1.0, 1.0, 1.0);\n        return mat;\n       \n    }\n    else if (i == 3)\n    {\n        // Appliquer la texture marbre\n        vec3 marbledColor = MarbleTexture(p);\n\n        Material mat;\n        mat.ambient = marbledColor;\n        mat.diffuse = marbledColor;\n        mat.specular = vec3(1.0, 4.0, 5.0);\n\n        return mat;\n    } \n    else if (i == 4)\n    {\n        // Appliquer la texture radiale\n        vec3 radialColor = RadialTexture(p);\n\n        Material mat;\n        mat.ambient = radialColor;\n        mat.diffuse = radialColor;\n        mat.specular = vec3(1.0, 1.0, 1.0);\n        return mat;\n    }\n\n    // Retourner un matériau par défaut (toutes les composantes à zéro)\n    Material defaultMat;\n    defaultMat.ambient = vec3(0.0);\n    defaultMat.diffuse = vec3(0.0);\n    defaultMat.specular = vec3(0.0);\n    return defaultMat;\n}\n\n\n\n//translation\nRay TranslateRay(Ray ray, vec3 translation) {\n    Ray translatedRay;\n    translatedRay.o = ray.o + translation;\n    translatedRay.d = ray.d;\n    return translatedRay;\n}\n\n\n\n//rotation\nmat3 rotationMatrixX(float angleX) {\n    return mat3(\n    1, 0, 0,\n    0, cos(angleX), -sin(angleX),\n    0, sin(angleX), cos(angleX));\n}\n\n\n\nmat3 rotationMatrixY(float angle) {\n    return mat3(\n        cos(angle), 0, -sin(angle),\n        0, 1, 0,\n        sin(angle), 0, cos(angle)\n    );\n}\n\n\n\nmat3 rotationMatrixZ(float angleZ) {\n    return mat3(\n       cos(angleZ), -sin(angleZ), 0,\n        sin(angleZ), cos(angleZ), 0,\n        0, 0, 1\n    );\n}\n\n\n\nRay RotateRayX(Ray ray) {\n    Ray rotatedRay;\n    rotatedRay.o = ray.o;\n    rotatedRay.d =rotationMatrixX(radians (20.0)) * ray.d;\n    return rotatedRay;\n}\n\n\n\nRay RotateRayZ(Ray ray) {\n    Ray rotatedRay;\n    rotatedRay.o = ray.o;\n    rotatedRay.d =rotationMatrixZ(radians (35.0)) * ray.d;\n    return rotatedRay;\n}\n\n\nRay RotateRayY(Ray ray) {\n    Ray rotatedRay;\n    rotatedRay.o = ray.o;\n    rotatedRay.d =rotationMatrixY(radians (35.0)) * ray.d;\n    return rotatedRay;\n}\n\n\n\n//homothétie\nRay ScaleRay(Ray ray, vec3 scaleFactors) {\n    Ray scaledRay;\n    scaledRay.o = ray.o;\n    scaledRay.d = ray.d * scaleFactors;\n    return scaledRay;\n}\n\n\n\nvec3 Hemisphere(int seed, vec3 n) {\n    float a = fract(sin(176.19 * float(seed)));\n    float b = fract(sin(164.19 * float(seed)));\n\n    float u = 2.0 * 3.1415 * a;\n    float v = acos(2.0 * b - 1.0);\n\n    vec3 d = vec3(cos(u) * cos(v), sin(u) * cos(v), sin(v));\n\n    if (dot(d, n) < 0.0) {\n        d = -d;\n    }\n\n    return d;\n}\n\n\n\n// Sphere intersection\n// ray : The ray\n//   x : Returned intersection information\nbool IntersectSphere(Ray ray,Sphere sph,out Hit x) {\n    vec3 oc=ray.o-sph.c;\n    float b=dot(oc,ray.d);\n    float c=dot(oc,oc)-sph.r*sph.r;\n    float d=b*b-c;\n    if(d>0.)\n    {\n        float t=-b-sqrt(d);\n        if(t>0.)\n        {\n            vec3 p=Point(ray,t);\n            x=Hit(t,normalize(p-sph.c),sph.i);\n           \n            return true;\n        }\n    }\n    return false;\n   \n}\n\n\n\nbool IntersectBox(Ray ray, Box box, out Hit x) {\n    vec3 invDir = 1.0 / ray.d;\n    vec3 t0 = (box.min - ray.o) * invDir;\n    vec3 t1 = (box.max - ray.o) * invDir;\n    vec3 tmin = min(t0, t1);\n    vec3 tmax = max(t0, t1);\n\n    float tNear = max(max(tmin.x, tmin.y), tmin.z);\n    float tFar = min(min(tmax.x, tmax.y), tmax.z);\n\n    if (tNear <= tFar && tFar >= 0.0) {\n        vec3 hitPoint = Point(ray, tNear);\n\n        vec3 normal = vec3(0.0);\n        float eps = 1e-6;\n        for (int i = 0; i < 3; i++) {\n            if (abs(hitPoint[i] - box.min[i]) < eps) normal[i] = -1.0;\n            if (abs(hitPoint[i] - box.max[i]) < eps) normal[i] = 1.0;\n        }\n\n        x = Hit(tNear, normal, box.i);\n        return true;\n    }\n\n    return false;\n}\n\n\n\nbool IntersectCylinder(Ray ray, Cylinder cyl, out Hit x) {\n    vec3 dLocal = (ray.d - dot(ray.d, cyl.d) * cyl.d);\n    vec3 oLocal = (ray.o - cyl.p - dot(ray.o - cyl.p, cyl.d) * cyl.d);\n\n    float a = dot(dLocal, dLocal);\n    float b = 2.0 * dot(dLocal, oLocal);\n    float c = dot(oLocal, oLocal) - cyl.r * cyl.r;\n\n    float discriminant = b * b - 4.0 * a * c;\n\n    if (discriminant > 0.0) {\n        float t1 = (-b - sqrt(discriminant)) / (2.0 * a);\n        float t2 = (-b + sqrt(discriminant)) / (2.0 * a);\n\n        if (t1 > 0.0 || t2 > 0.0) {\n            float t = t1 > 0.0 ? t1 : t2;\n            vec3 p = Point(ray, t);\n           \n            float height = dot(p - cyl.p, cyl.d);\n            if (height >= 0.0 && height <= cyl.h) {\n                vec3 normal_side = normalize(p - (cyl.p + dot(p - cyl.p, cyl.d) * cyl.d));\n                x = Hit(t, normal_side, cyl.i);\n                return true;\n            }\n        }\n    }\n\n    float t_top = (cyl.h - dot(ray.o - cyl.p, cyl.d)) / dot(ray.d, cyl.d);\n    float t_bottom = (-dot(ray.o - (cyl.p + cyl.h * cyl.d), cyl.d)) / dot(ray.d, cyl.d);\n   \n    if (t_top > 0.0) {\n        vec3 p_top = Point(ray, t_top);\n        float height_top = dot(p_top - cyl.p, cyl.d);\n       \n        if (height_top >= 0.0 && height_top <= cyl.h) {\n            float distance_squared_top = dot(p_top - (cyl.p + cyl.h * cyl.d), p_top - (cyl.p + cyl.h * cyl.d));\n            if (distance_squared_top <= cyl.r * cyl.r) {\n                x = Hit(t_top, normalize(cyl.d), cyl.i);\n                return true;\n            }\n        }\n    }\n   \n    if (t_bottom > 0.0) {\n        vec3 p_bottom = Point(ray, t_bottom);\n        float distance_squared_bottom = dot(p_bottom - (cyl.p + cyl.h * cyl.d), p_bottom - (cyl.p + cyl.h * cyl.d));\n        if (distance_squared_bottom <= cyl.r * cyl.r) {\n            x = Hit(t_bottom, normalize(-cyl.d), cyl.i);\n            return true;\n        }\n    }\n\n    return false;\n}\n\n\n\nbool IntersectCapsule(Ray ray, Capsule cap, out Hit x) {\n    vec3 ro = ray.o;\n    vec3 rd = ray.d;\n    vec3 pa = cap.p1;\n    vec3 pb = cap.p2;\n    float ra = cap.r;\n\n    vec3 ba = pb - pa;\n    vec3 oa = ro - pa;\n    float baba = dot(ba, ba);\n    float bard = dot(ba, rd);\n    float baoa = dot(ba, oa);\n    float rdoa = dot(rd, oa);\n    float oaoa = dot(oa, oa);\n    float a = baba - bard * bard;\n    float b = baba * rdoa - baoa * bard;\n    float c = baba * oaoa - baoa * baoa - ra * ra * baba;\n    float h = b * b - a * c;\n\n    if (h >= 0.0) {\n        float t = (-b - sqrt(h)) / a;\n        float y = baoa + t * bard;\n       \n        // Check if the intersection point is within the capsule body\n        if (y >= 0.0 && y <= baba) {\n            x.t = t;\n            vec3 intersectionPoint = ro + rd * t;\n\n            // Calculate the normal for the capsule body\n            vec3 baNormalized = normalize(ba);\n            vec3 paToIntersection = intersectionPoint - pa;\n            vec3 pointOnAxis = pa + dot(paToIntersection, baNormalized) * baNormalized;\n            vec3 normal = normalize(intersectionPoint - pointOnAxis);\n\n            x.n = normal;\n            x.i = cap.i;\n            return true;\n        }\n\n        // Check the end caps\n        vec3 oc = (y <= 0.0) ? oa : ro - pb;\n        b = dot(rd, oc);\n        c = dot(oc, oc) - ra * ra;\n        h = b * b - c;\n\n        if (h > 0.0) {\n            x.t = -b - sqrt(h);\n            if (x.t > 0.0) {\n                // Calculate the normal for the first end cap\n                x.n = normalize(ro + x.t * rd - pa);\n            } else {\n                // Calculate the normal for the second end cap\n                x.n = normalize(ro + x.t * rd - pb);\n            }\n            x.i = cap.i;\n            return true;\n        }\n    }\n    return false;\n}\n\n\n\n// Plane intersection\n// ray : The ray\n//   x : Returned intersection information\nbool IntersectPlane(Ray ray,Plane pl,out Hit x) {\n    float t=-dot(ray.o-pl.p,pl.n)/dot(ray.d,pl.n);\n    if(t>0.)\n    {\n       \n        x=Hit(t,vec3(0,0,1),0);\n        return true;\n    }\n    return false;\n}\n\n\n\nbool IntersectEllipsoid(Ray ray, Ellipsoid ellipsoid, out Hit x) {\n    vec3 rayOrigin = (ray.o - ellipsoid.c) / ellipsoid.radii; // nouveau point d'origine de rayon\n    vec3 rayDirection = ray.d / ellipsoid.radii; // ajuste la direction de rayon par rapport aux rayons de l'ellipsoide\n   \n    float a = dot(rayDirection, rayDirection);\n    float b = 2.0 * dot(rayDirection, rayOrigin);\n    float c = dot(rayOrigin, rayOrigin) - 1.0;\n   \n    // discriminant\n    float discriminant = b * b - 4.0 * a * c;\n   \n    if (discriminant > 0.0) {\n        float t1 = (-b - sqrt(discriminant)) / (2.0 * a);\n        float t2 = (-b + sqrt(discriminant)) / (2.0 * a);\n        float t = min(t1, t2);\n        if (t > 0.0) {\n            vec3 intersectionPointLocal = rayOrigin + t * rayDirection;\n            vec3 intersectionPointGlobal = ellipsoid.c + ellipsoid.radii * intersectionPointLocal;\n            vec3 normalLocal = 2.0 * intersectionPointLocal;\n            vec3 normalGlobal = normalize(normalLocal / ellipsoid.radii);\n            x = Hit(t, normalGlobal, ellipsoid.i);\n            return true;\n        }\n    }\n   \n    return false;\n}\n\n\n\nbool IntersectTorus(Ray ray, Torus torus, out Hit x) {\n    float po = 1.0;\n    float Ra2 = torus.majorRadius * torus.majorRadius;\n    float ra2 = torus.minorRadius * torus.minorRadius;\n\n    vec3 ro = ray.o - torus.center;\n    float m = dot(ro, ro);\n    float n = dot(ro, ray.d);\n\n    float k = (m - ra2 - Ra2) / 2.0;\n    float k3 = n;\n    float k2 = n * n + Ra2 * ray.d.z * ray.d.z + k;\n    float k1 = k * n + Ra2 * ro.z * ray.d.z;\n    float k0 = k * k + Ra2 * ro.z * ro.z - Ra2 * ra2;\n\n    // Prevent |c1| from being too close to zero\n    if (abs(k3 * (k3 * k3 - k2) + k1) < 0.01)\n    {\n        po = -1.0;\n        float tmp = k1;\n        k1 = k3;\n        k3 = tmp;\n        k0 = 1.0 / k0;\n        k1 = k1 * k0;\n        k2 = k2 * k0;\n        k3 = k3 * k0;\n    }\n\n    float c2 = 2.0 * k2 - 3.0 * k3 * k3;\n    float c1 = k3 * (k3 * k3 - k2) + k1;\n    float c0 = k3 * (k3 * (-3.0 * k3 * k3 + 4.0 * k2) - 8.0 * k1) + 4.0 * k0;\n\n    c2 /= 3.0;\n    c1 *= 2.0;\n    c0 /= 3.0;\n\n    float Q = c2 * c2 + c0;\n    float R = 3.0 * c0 * c2 - c2 * c2 * c2 - c1 * c1;\n\n    float h = R * R - Q * Q * Q;\n    float z = 0.0;\n    if (h < 0.0)\n    {\n        // 4 intersections\n        float sQ = sqrt(Q);\n        z = 2.0 * sQ * cos(acos(R / (sQ * Q)) / 3.0);\n    }\n    else\n    {\n        // 2 intersections\n        float sQ = pow(sqrt(h) + abs(R), 1.0 / 3.0);\n        z = sign(R) * abs(sQ + Q / sQ);\n    }\n    z = c2 - z;\n\n    float d1 = z - 3.0 * c2;\n    float d2 = z * z - 3.0 * c0;\n    if (abs(d1) < 1.0e-4) \n    {\n        if (d2 < 0.0)\n        {\n            x = Hit(-1.0, vec3(0.0), torus.i);\n            return false;\n        }\n        d2 = sqrt(d2);\n    }\n    else\n    {\n        if (d1 < 0.0)\n        {\n            x = Hit(-1.0, vec3(0.0), torus.i);\n            return false;\n        }\n        d1 = sqrt(d1 / 2.0);\n        d2 = c1 / d1;\n    }\n\n    float result = 1e20;\n\n    h = d1 * d1 - z + d2;\n    if (h > 0.0) \n    {\n        h = sqrt(h);\n        float t1 = -d1 - h - k3;\n        t1 = (po < 0.0) ? 2.0 / t1 : t1;\n        float t2 = -d1 + h - k3;\n        t2 = (po < 0.0) ? 2.0 / t2 : t2;\n        if (t1 > 0.0)\n            result = t1;\n        if (t2 > 0.0)\n            result = min(result, t2);\n    }\n\n    h = d1 * d1 - z - d2;\n    if (h > 0.0)\n    {\n        h = sqrt(h);\n        float t1 = d1 - h - k3;\n        t1 = (po < 0.0) ? 2.0 / t1 : t1;\n        float t2 = d1 + h - k3;\n        t2 = (po < 0.0) ? 2.0 / t2 : t2;\n        if (t1 > 0.0)\n            result = min(result, t1);\n        if (t2 > 0.0)\n            result = min(result, t2);\n    }\n\n    x = Hit(result, normalize(ray.o + ray.d * result - torus.center), torus.i);\n    return true;\n}\n\n\n\nbool Intersect(Ray ray, out Hit x) {\n    // Spheres\n    const Sphere sph1 = Sphere(vec3(-6.5, 1.0, 1.5), 1.5, 3);\n    const Sphere sph2 = Sphere(vec3(-4.0, 5.0, 1.7), 1.5, 1);\n\n    // Box\n    const Box box = Box(vec3(-3.0, 0.0, 0.5), vec3(-1.0, 2.0, 2.0), 4);\n\n    // Cylinder\n    const Cylinder cyl = Cylinder(vec3(1.5, 1.0, 1.0), vec3(0.0, 0.0, 1.0), 1.0, 4.0, 4);\n\n    // Ellipsoid\n    const Ellipsoid ellipsoid = Ellipsoid(vec3(4.5, -2.0, 3.0), vec3(0.8, 3.0, 1.8), 4);\n\n    // Capsule\n    const Capsule cap = Capsule(vec3(1.0, 4.0, 2.0), vec3(3.0, 4.0, 2.0), 0.5, 3);\n\n    //Tore\n    const Torus torus = Torus(vec3(0.0, -4.0, 1.0), 1.5, 0.3,3);\n\n    //Plan\n    const Plane pl = Plane(vec3(0., 0., 8.), vec3(0., 0., 0.), 0);\n\n\n    x = Hit(1000., vec3(0), -1);\n    Hit current;\n    bool ret = false;\n    \n   \n    if (IntersectSphere(ray, sph1, current) && current.t < x.t) {\n        x = current;\n        ret = true;\n    }\n     \n    if (IntersectSphere(ScaleRay(ray, vec3(1.1, 1.0, 1.0)), sph2, current) && current.t < x.t) {\n        x = current;\n        ret = true;\n    }\n\n    if (IntersectBox(ray, box, current) && current.t < x.t) {\n        x = current;\n        ret = true;\n    }\n   \n    if (IntersectCylinder(RotateRayZ(ray), cyl, current) && current.t < x.t) {\n        x = current;\n        ret = true;\n    }\n   \n    if (IntersectEllipsoid(TranslateRay(ray, vec3(0.1, 1.0, 1.0)),ellipsoid,current) && current.t < x.t) {\n        x = current;\n        ret = true;\n    }\n   \n    if (IntersectCapsule(RotateRayY(ray), cap, current) && current.t < x.t) {\n        x = current;\n        ret = true;\n    }\n     if (IntersectTorus(RotateRayX(ray), torus, current) && current.t < x.t) {\n        x = current;\n        ret = true;\n    }\n   \n    if (IntersectPlane(ray, pl, current) && current.t < x.t) {\n        x = current;\n        ret = true;\n    }\n\n    return ret;\n}\n\n\n\nvec3 Background(vec3 rd) {\n    return mix(vec3(.8,.8,.9),vec3(.7,.7,.8),rd.z);\n}\n\n\n\n// Camera rotation matrix\n// ro : Camera origin\n// ta : Target point\nmat3 setCamera(in vec3 ro,in vec3 ta) {\n    vec3 cw=normalize(ta-ro);\n    vec3 cp=vec3(0,0,1);\n    vec3 cu=-normalize(cross(cw,cp));\n    vec3 cv=-normalize(cross(cu,cw));\n    return mat3(cu,cv,cw);\n}\n\n\n\nfloat AmbientOcclusion(vec3 p, vec3 n, int N) {\n    if (N == 0) {\n        return 1.0;\n    }\n\n    float ao = 0.0;\n\n    for (int i = 0; i < N; i++) {\n        vec3 d = Hemisphere(i, n);\n        float occlusionRayLength = 0.1; \n\n        // Lance un rayon depuis le point p dans la direction d avec une petite marge\n        Hit occlusionHit;\n        if (Intersect(Ray(p + n * occlusionRayLength, d), occlusionHit)) {\n            ao += 1.0;\n        }\n    }\n\n    // Calcule la moyenne de l'occlusion sur tous les échantillons\n    ao = 1.0 - (ao / float(N));\n\n    return ao;\n}\n\n\n\n// Apply color model\n// m : Material\n// n : normal\nvec3 Color(Material material,vec3 n, vec3 p, vec3 light,vec3 viewDirection) {\n    // Propriétés du matériau\n    vec3 ambient = material.ambient;\n    vec3 diffuse = material.diffuse;\n    vec3 specular = material.specular;\n\n    // Luminosité ambiante\n \n    // float ao = AmbientOcclusion(p, n, 20);\n    vec3 ambientColor = material.ambient;\n     \n    // Luminosité spéculaire (calcul de la réflexion)\n    vec3 reflectionPonctuelle = reflect(-light, n);\n    float spec = pow(max(dot(reflectionPonctuelle, viewDirection), 0.2), 32.0); // Exposant spéculaire\n    vec3 specularColor = spec * specular * vec3(1.0);\n   \n    Hit osef;\n    if(!Intersect(Ray(p+ n*0.01, light), osef))\n    {\n        float diff=clamp(dot(n,light),0.,1.);\n        vec3 col= material.diffuse*diff+vec3(.2,.2,.2) + ambientColor + specularColor;\n        return col;\n    } else {\n        return vec3(.2,.2,.2);\n    }\n}\n\n\n\n// Rendering\nvec3 Shade(Ray ray, float lightIntensity){\n    Hit x;\n    bool idx = Intersect(ray, x);\n   \n    if (idx)\n    {\n        vec3 p = Point(ray, x.t);\n        Material mat;\n        mat = Texture(p, x.i);\n        vec3 normal = x.n; // Normale à la surface au point d'intersection\n        vec3 viewDirection = -ray.d; // Direction de vue\n\n        // Direction de la source lumineuse directionnelle\n        vec3 lightDirection = normalize(vec3(1.2, 0.7, 0.9));\n        // Calcule la couleur en tenant compte de l'éclairage\n        vec3 col = Color(mat, normal, p,lightDirection,viewDirection);\n    \n        //source lumineuse ponctuelle\n        vec3 lightPosition = vec3(20.0, -4.0, 20.0);\n        \n        lightDirection = normalize(lightPosition );\n   \n        //calcule d'éclairage\n        col += Color(mat, normal,p,lightDirection,viewDirection);\n         \n        // Calcule l'occlusion ambiante\n        float ao = AmbientOcclusion(p, normal, 20);\n        vec3 ambientColor = mat.ambient * ao;\n\n        // Ajoute l'éclairage direct et l'éclairage ambiant\n        col += ambientColor;\n        col *=lightIntensity;\n     \n        return col;\n    } else {\n        return Background(ray.d);\n    }\n   \n    return vec3(0);\n}\n\n\n\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord) {\n    // From uv which are the pixel coordinates in [0,1], change to [-1,1] and apply aspect ratio\n    vec2 uv=(-iResolution.xy+2.*fragCoord.xy)/iResolution.y;\n   \n    // Mouse control\n    vec2 mouse=iMouse.xy/iResolution.xy;\n   \n    // Ray origin\n    vec3 ro=12.*normalize(vec3(sin(2.*3.14*mouse.x),cos(2.*3.14*mouse.x),1.4*(mouse.y-.1)));\n    vec3 ta=vec3(0.,0.,1.5);\n    mat3 ca=setCamera(ro,ta);\n   \n    // Ray\n    vec3 rd=ca*normalize(vec3(uv.xy*tan(radians(22.5)),1.));\n\n    // Render\n    vec3 col=Shade(Ray(ro,rd), 0.5);\n   \n    fragColor=vec4(col,1.5);\n}","name":"Image","description":"","type":"image"}]}