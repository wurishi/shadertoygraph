{"ver":"0.1","info":{"id":"mdGfWG","date":"1698584106","viewed":420,"name":"Tunnel in space","username":"nayk","description":"space, stars, tunnel, copypast","likes":24,"published":1,"flags":1,"usePreview":0,"tags":["tunnel","space","stars","copypast"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*original https://www.shadertoy.com/view/lslyRn, https://www.shadertoy.com/view/3sGfD3 */\n#define iterations 17\n#define formuparam 0.53\n\n#define volsteps 20\n#define stepsize 0.1\n\n#define zoom   0.800\n#define tile   0.850\n#define speed  0.000 \n\n#define brightness 0.0015\n#define darkmatter 0.300\n#define distfading 0.730\n#define saturation 1.150\n#define PI 3.14159265359\n#define E 2.7182818284\n#define GR 1.61803398875\n#define EPS .001\n\n#define time2 (float(__LINE__)+iTime/PI)\n\nfloat saw(float x)\n{\n    return acos(cos(x))/3.14;\n}\nvec2 saw(vec2 x)\n{\n    return acos(cos(x))/3.14;\n}\nvec3 saw(vec3 x)\n{\n    return acos(cos(x))/3.14;\n}\nvec4 saw(vec4 x)\n{\n    return acos(cos(x))/3.14;\n}\nfloat stair(float x)\n{\n    return float(int(x));\n}\nvec2 stair(vec2 x)\n{\n    return vec2(stair(x.x), stair(x.y));\n}\n\n\nfloat jag(float x)\n{\n    return mod(x, 1.0);\n}\nvec2 jag(vec2 x)\n{\n    return vec2(jag(x.x), jag(x.y));\n}\n\n\n\nvec2 SinCos( const in float x )\n{\n\treturn vec2(sin(x), cos(x));\n}\nvec3 RotateZ( const in vec3 vPos, const in vec2 vSinCos )\n{\n\treturn vec3( vSinCos.y * vPos.x + vSinCos.x * vPos.y, -vSinCos.x * vPos.x + vSinCos.y * vPos.y, vPos.z);\n}\n      \nvec3 RotateZ( const in vec3 vPos, const in float fAngle )\n{\n\treturn RotateZ( vPos, SinCos(fAngle) );\n}\nvec2 RotateZ( const in vec2 vPos, const in float fAngle )\n{\n\treturn RotateZ( vec3(vPos, 0.0), SinCos(fAngle) ).xy;\n}\nmat4 RotateZ( const in mat4 vPos, const in float fAngle )\n{\n\treturn mat4(RotateZ( vec3(vPos[0].xy, 0.0), SinCos(fAngle) ).xy, 0.0, 0.0,\n                RotateZ( vec3(vPos[1].xy, 0.0), SinCos(fAngle) ).xy, 0.0, 0.0,\n                RotateZ( vec3(vPos[2].xy, 0.0), SinCos(fAngle) ).xy, 0.0, 0.0,\n                RotateZ( vec3(vPos[3].xy, 0.0), SinCos(fAngle) ).xy, 0.0, 0.0);\n}\nmat4 translate( const in mat4 vPos, vec2 offset )\n{\n\treturn mat4(vPos[0].xy+offset, 0.0, 0.0,\n                vPos[1].xy+offset, 0.0, 0.0,\n                vPos[2].xy+offset, 0.0, 0.0,\n                vPos[3].xy+offset, 0.0, 0.0);\n} \nmat4 scale( const in mat4 vPos, vec2 factor )\n{\n\treturn mat4(vPos[0].xy*factor, 0.0, 0.0,\n                vPos[1].xy*factor, 0.0, 0.0,\n                vPos[2].xy*factor, 0.0, 0.0,\n                vPos[3].xy*factor, 0.0, 0.0);\n} \nvec4 spiral(vec4 uv)\n{\n    //uv = normalize(uv)*log(length(uv)+1.0);\n    float r = log(length(uv)+1.0)*2.0*PI;\n    float theta = mod((atan(uv.y, uv.x)+r), 2.0*PI);\n    \n    return vec4(saw(r), saw(theta),\n               \tr, theta);\n}\n\n\nfloat square(vec2 uv, float iteration)\n{\n\tif(abs(abs(saw(uv.x*(1.5+sin(iTime*.654321))*PI+iTime*.7654321)*2.0-1.0)-abs(uv.y)) < .5)\n\t\treturn 1.0-abs(abs(saw(uv.x*(1.5+sin(iTime*.654321))*PI+iTime*.7654321)*2.0-1.0)-abs(uv.y))/.5*uv.x;\n\telse\n\t\treturn 0.0;\n}\n\n#define rot(a) mat2(cos(a),sin(a),-sin(a),cos(a))\n\nvec3 render(vec2 p) {\n    p*=rot(iTime*.1);\n    p*=fract(iTime*0.1);\n    p.y-=.2266;\n    p.x+=.2082;\n    vec2 ot=vec2(100.);\n    float m=100.;\n    for (int i=0; i<150; i++) {\n        vec2 cp=vec2(p.x,-p.y);\n\t\tp=p+cp/dot(p,p)-vec2(0.,.25);\n        p*=.1;\n        p*=rot(1.5);\n        ot=min(ot,abs(p)+.15*fract(max(abs(p.x),abs(p.y))*.25+iTime*.1+float(i)*.15));\n        m=min(m,abs(p.y));\n    }\n    ot=exp(-200.*ot)*2.;\n    m=exp(-200.*m);\n    return vec3(ot.x,ot.y*.5+ot.x*.3,ot.y)+m*.2;\n}\n\n\n\nvec2 sp(vec2 uv){ // spiral\n    float r = length(uv);\n    float angle = atan(uv.x, uv.y);\n    uv *= cos(15.0 * r - 1.0 * angle - iTime * 0.8 );\n    return uv;\n}\nvoid mainVR( out vec4 fragColor, in vec2 fragCoord, in vec3 ro, in vec3 rd )\n{\n\t//get coords and direction\n\tvec3 dir=rd;\n\tvec3 from=ro;\n\t\n\t//volumetric rendering\n\tfloat s=0.1,fade=1.;\n\tvec3 v=vec3(0.);\n\tfor (int r=0; r<volsteps; r++) {\n\t\tvec3 p=from+s*dir*.5;\n\t\tp = abs(vec3(tile)-mod(p,vec3(tile*2.))); // tiling fold\n\t\tfloat pa,a=pa=0.;\n\t\tfor (int i=0; i<iterations; i++) { \n\t\t\tp=abs(p)/dot(p,p)-formuparam; // the magic formula\n\t\t\ta+=abs(length(p)-pa); // absolute sum of average change\n\t\t\tpa=length(p);\n\t\t}\n\t\tfloat dm=max(0.,darkmatter-a*a*.001); //dark matter\n\t\ta*=a*a; // add contrast\n\t\tif (r>6) fade*=1.-dm; // dark matter, don't render near\n\t\t//v+=vec3(dm,dm*.5,0.);\n\t\tv+=fade;\n\t\tv+=vec3(s,s*s,s*s*s*s)*a*brightness*fade; // coloring based on distance\n\t\tfade*=distfading; // distance fading\n\t\ts+=stepsize;\n\t}\n\tv=mix(vec3(length(v)),v,saturation); //color adjust\n\tfragColor = vec4(v*.03,1.);\t\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t\n\tvec2 uv=fragCoord.xy/iResolution.xy-.5;\n    vec4 uv2 = vec4(fragCoord.xy / iResolution.xy, 0.0, 0.0);\n    \n\tuv.y*=iResolution.y/iResolution.x;\n\tvec3 dir=vec3(uv*zoom,iTime*0.01);\n   \n\tfloat time=iTime*speed+.25;\n \n    float map = 0.0;\n    \n    float lambda = 4.0;\n    float amplitude = 32.0;\n    float scale = pow(E, saw(time)*amplitude);\n    dir.yx*=mat2(cos(iTime*0.1),sin(iTime*0.1),-sin(iTime*0.1),cos(iTime*0.1));\n    uv2.xy *= scale;\n    uv2.xy -= scale/2.0;\n\tuv2.x *= iResolution.x/iResolution.y;\n    uv2.xy = normalize(uv2.xy)*log(length(uv2.xy)+1.0);\n    uv2.zw*=mat2(cos(iTime*0.1),sin(iTime*0.1),-sin(iTime*0.1),cos(iTime*0.1));\n\tconst int max_iterations = 1;\n\n    float noise = 1.0;\n    \n    for(int i = 0; i < max_iterations; i++)\n    {\n        uv2 = spiral(uv2);\n        uv2.xy *= scale;\n        uv2.xy -= scale/2.0;\n        \n        uv2.xy = normalize(uv2.xy)*log(length(uv2.xy)+1.0);\n        map += (uv2.z+uv2.w);\n    }\n    \n  \n  \nvec2 sv = sp(uv); // warping uv space to spiral\n\n    vec3 bg = texture(iChannel0, sv - 0.5).xyz; // get background texture\n    // mix between the warped uv and the warped background. then the dot of the two interpolates it\n    vec3 col = mix(vec3(sv, 0.0), bg, dot(vec3(sv, 1.05), bg)) * 1.88; \n      vec2 d=vec2(0.,.5)/iResolution.xy;\n  col = render(uv)+render(uv+d.xy)+render(uv-d.xy)+render(uv+d.yx)+render(uv-d.yx);\n\tvec3 from=vec3(1.,.5,0.5)*saw(map)*col;\n\tfrom+=vec3(time*2.,time,-2.);\n\t\n\t\n\tmainVR(fragColor, fragCoord, from, dir);\t\n      fragColor+= vec4(col*.2,1.0);\n}\n\n","name":"Image","description":"","type":"image"}]}