{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[{"channel":0,"type":"texture","id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}},{"channel":1,"type":"texture","id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"code":"//\n// TEMPORAL DITHERING TEST\n//\n\n//\n// This is biased (saturates + adds contrast) because dithering done in non-linear space.\n//\n\n// Shows proper dithering of a signal (overlapping of dither between bands).\n// Results in about a 1-stop improvement in dynamic range over conventional dither\n//   which does not overlap dither across bands\n//   (try \"#define WIDE 0.5\" to see the difference below). \n//\n// This would work a lot better with a proper random number generator (flicker etc is bad).\n// Sorry there is a limit to what can be done easily in shadertoy.\n//\n// Proper dithering algorithm,\n//\n//   color = floor(color * steps + noise) * (1.0/(steps-1.0))\n//\n// Where,\n//   \n//   color ... output color {0 to 1}\n//   noise ... random number between {-1 to 1}\n//   steps ... quantization steps, ie 8-bit = 256\n//\n// The noise in this case is shaped by a high pass filter.\n// This is to produce a better quality temporal dither.\n\n// Scale the width of the dither\n#define STEPS 8.0\n#define WIDE 1.0\n\n//-----------------------------------------------------------------------\n\n#define F1 float\n#define F2 vec2\n#define F3 vec3\n#define F4 vec4\n\nF1 Noise(F2 n,F1 x){n+=x;return fract(sin(dot(n.xy,F2(12.9898, 78.233)))*43758.5453)*2.0-1.0;}\n\n// Step 1 in generation of the dither source texture.\nF1 Step1(F2 uv,F1 n){\n F1 a=1.0,b=2.0,c=-12.0,t=1.0;   \n return (1.0/(a*4.0+b*4.0-c))*(\n  Noise(uv+F2(-1.0,-1.0)*t,n)*a+\n  Noise(uv+F2( 0.0,-1.0)*t,n)*b+\n  Noise(uv+F2( 1.0,-1.0)*t,n)*a+\n  Noise(uv+F2(-1.0, 0.0)*t,n)*b+\n  Noise(uv+F2( 0.0, 0.0)*t,n)*c+\n  Noise(uv+F2( 1.0, 0.0)*t,n)*b+\n  Noise(uv+F2(-1.0, 1.0)*t,n)*a+\n  Noise(uv+F2( 0.0, 1.0)*t,n)*b+\n  Noise(uv+F2( 1.0, 1.0)*t,n)*a+\n 0.0);}\n    \n// Step 2 in generation of the dither source texture.\nF1 Step2(F2 uv,F1 n){\n F1 a=1.0,b=2.0,c=-2.0,t=1.0;   \n return (4.0/(a*4.0+b*4.0-c))*(\n  Step1(uv+F2(-1.0,-1.0)*t,n)*a+\n  Step1(uv+F2( 0.0,-1.0)*t,n)*b+\n  Step1(uv+F2( 1.0,-1.0)*t,n)*a+\n  Step1(uv+F2(-1.0, 0.0)*t,n)*b+\n  Step1(uv+F2( 0.0, 0.0)*t,n)*c+\n  Step1(uv+F2( 1.0, 0.0)*t,n)*b+\n  Step1(uv+F2(-1.0, 1.0)*t,n)*a+\n  Step1(uv+F2( 0.0, 1.0)*t,n)*b+\n  Step1(uv+F2( 1.0, 1.0)*t,n)*a+\n 0.0);}\n    \n// Used for stills.\nF3 Step3(F2 uv){\n F1 a=Step2(uv,0.07);    \n F1 b=Step2(uv,0.11);    \n F1 c=Step2(uv,0.13);\n #if 1\n  // Monochrome can look better on stills.\n  return F3(a);\n #else\n  return F3(a,b,c);\n #endif\n}\n\n// Used for temporal dither.\nF3 Step3T(F2 uv){\n F1 a=Step2(uv,0.07*(fract(iTime)+1.0));    \n F1 b=Step2(uv,0.11*(fract(iTime)+1.0));    \n F1 c=Step2(uv,0.13*(fract(iTime)+1.0));\n return F3(a,b,c);}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){    \n F2 uv=fragCoord.xy;\n F2 uv2=fragCoord.xy/iResolution.xy;F2 uv3=F2(uv2.x,1.0-uv2.y); \n F3 color=texture(iChannel0,uv2).rgb;\n F3 color2=texture(iChannel1,uv3*2.0).rgb;\n // BOTTOM: Show bands.\n if(uv2.y<0.1){color=F3(uv2.x);color=floor(0.5+color*(STEPS+WIDE-1.0)+(-WIDE*0.5)+Step3(uv)*WIDE)*(1.0/(STEPS-1.0));}   \n else if(uv2.y<0.2){color=F3(uv2.x);color=floor(0.5+color*(STEPS-1.0))*(1.0/(STEPS-1.0));}   \n else if(uv2.y<0.3){color=F3(uv2.x);color=floor(0.5+color*(STEPS+WIDE-1.0)+(-WIDE*0.5)+Step3T(uv)*WIDE)*(1.0/(STEPS-1.0));}   \n // Show video and texture.\n else if(uv2.y<0.9){\n  if(uv2.x<0.3)color=color2;\n  color=floor(0.5+color*(STEPS+WIDE-1.0)+(-WIDE*0.5)+Step3T(uv)*(WIDE))*(1.0/(STEPS-1.0));}\n // TOP: Show dither texture.\n else{color=Step3(uv)*0.25+0.5;}    \n fragColor=F4(color,1.0);}\n\n\n","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"4sBSDW","date":"1411862097","viewed":4183,"name":"TemporalDithering","username":"TimothyLottes","description":"Nice way to do temporal dithering using a high frequency color dither pattern and dithering more than just the LSB.","likes":41,"published":1,"flags":0,"usePreview":0,"tags":["temporaldithering","removingbanding"],"hasliked":0,"parentid":"","parentname":""}}