{"ver":"0.1","info":{"id":"XdVyRD","date":"1521233822","viewed":137,"name":"random explosion experiment","username":"satbir121","description":"I was trying to do a wobbly effect with an impulse function. But when you give a negative value to impulse function, cool stuff happens!","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","explosion"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Ray marching from Jamie Wong's blog http://jamie-wong.com/2016/07/15/ray-marching-signed-distance-functions/\n// A few functions from https://iquilezles.org/\n\nconst int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float EPSILON = 0.0001;\nconst float MORPH_INTENSITY = 10.;\n\n/**\n * Signed sitance function for a sphere centered at the origin with radius 1.0\n */\nfloat sphereSDF(vec3 samplePoint) {\n\treturn length(samplePoint) - abs(sin(iTime * 1.) * 0.05 + 0.05 + 0.7);\n}\n\n\n\nfloat displacement(vec3 p) {\n\treturn sin(MORPH_INTENSITY*p.x)*sin(MORPH_INTENSITY*p.y)*sin(MORPH_INTENSITY*p.z);\n}\n\n//  Function from IÃ±igo Quiles\n//  iquilezles.org/articles/functions\nfloat impulse( float k, float x ){\n    float h = k*x;\n    return h*exp(1.0-h);\n}\n\n\nfloat opDisplace( vec3 p )\n{\n    float d1 = sphereSDF(p);\n    // TODO: Make this a impluse function\n    float d2 = 0.15 * abs(impulse(12., sin(iTime))) * displacement(p);\n    return d1+d2;\n}\n\n\n/**\n * Signed distance function for describing the scene.\n *\n * Absolute value of the return indicates the distance to the surface.\n * Sign indicates whether the point is inside or outside the surface,\n * negative indicating inside.\n */\nfloat sceneSDF(vec3 samplePoint) {\n\treturn opDisplace(samplePoint);\n}\n\n\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: max distance away from the eye too march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n\tfloat depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n    \tfloat dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < EPSILON) {\n        \treturn depth;\n        }\n        \n        depth += dist;\n        if (depth >= end) {\n        \treturn end;\n        }\n    }\n    return end;\n}\n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n\tvec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 dir = rayDirection(45.0, iResolution.xy, fragCoord);\n    vec3 eye = vec3(0.0, 0.0, 14.0);\n    float dist = shortestDistanceToSurface(eye, dir, MIN_DIST, MAX_DIST);\n    \n    if (dist > MAX_DIST - EPSILON) {\n    \t// Didn't hit anything\n        fragColor = vec4(0., 0., 0., 0.);\n        return;\n    }\n    \n    fragColor = vec4(1., 0., 0., 1.);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"float rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\n\n","name":"Common","description":"","type":"common"}]}