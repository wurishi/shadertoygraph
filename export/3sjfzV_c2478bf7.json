{"ver":"0.1","info":{"id":"3sjfzV","date":"1590428912","viewed":112,"name":"Outline 2020/23 may/MsieurSoleil","username":"MonsieurSoleil","description":"I lost control over my shader :D, so the result was kinda unexpected.\n\nI wanted to use reflections, and I played, with a \"broken\" shader. (Meaning of broken, Is that it did not what I wanted him to do).\n","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["livecode"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define time iTime * 0.5\n#define mod01 floor(mod(time * 2.0, 4.0))\n#define mod02 floor(mod(time * 4.0, 2.0))\n#define mod03 floor(mod(time * 2.0, 16.0))\n#define mod04 floor(mod(time, 4.0))\n\nfloat gg = 0.0;\n\nstruct matter\n{\n  float mat;\n  int type;\n};\n\nmat2 rot(float a)\n{\n  float ca = cos(a);\n  float sa = sin(a);\n  \n  return mat2(ca, -sa, sa, ca);\n}\n\n//I WONT PANICK I'M FRENCH MUAHHAAHAHAHAAHAHAHH\nvec2 rep(vec2 p, float repeat)\n{\n  return (floor(abs(p)/repeat - 0.5) - 0.5) * repeat;\n}\n// ZBLEH !!!!\n\nfloat sphere(vec3 p, float r)\n{\n  return length(p)-r;\n}\n\n// TRROOOOOPAAAAAASKKAAAYAAAAAAAA\nfloat box(vec3 p, vec3 s)\n{\n  p = abs(p) - s;\n  return max(p.x, max(p.y, p.z));\n}\n\nfloat rnd(float t)\n{\n  return fract( sin(t*423.1256) * 4523.1524);\n}\n\nfloat curve(float t)\n{\n  return mix(\n  rnd(floor(t)),\n  rnd(floor(t) + 1.0),\n  smoothstep(0.0, 1.0, fract(t)));\n}\n\nfloat smin(float a , float b, float k)\n{\n  float h = clamp( 0.5 - 0.5 * (a - b) / k, 0.0, 1.0);\n  return mix(b, a, h) - k*h*(1.0-h);  \n}\n\nmatter map(vec3 p)\n{\n  matter mat;\n  \n  float mat01, mat02, mat03, mat04;\n  \n  vec3 p02 = p;\n  vec3 p03 = p;\n  vec3 p04 = p;\n  \n  p04.xz = rep(p.xz, 4.0);\n  p04.xz *= rot(p.y * 0.01 + sin(time * 0.1));\n \n  \n  p02.xy *= rot(sin(p.z * 0.05 + time * 0.2)) * 2.0 * mod03 + 1.0;\n  \n  p03.xy *= rot(sin(p.z * 0.01 + (curve(time * 1.0) * 12.2 * mod04))) * 2.5;\n  \n  \n   p.xy *= rot(sin(p.z * 0.05 + curve(time))) * 1.5;\n  \n  float scale = 0.5 + 0.5 * mod01 + 0.5 * mod03 + 0.2 * mod02 * 0.05;\n  \n  mat.mat = sphere(p, scale);\n  \n  mat01 = box(p + vec3(curve(time * 2.0) * 12.0, curve(time * 4.0) * 8.0, 0.0), vec3(0.1, scale * 1.5, 100000.0));\n  \n  //mat02 = box(p02 + vec3(5.0, 2.0, 0.0), vec3(0.1, scale, 100000.0));\n  //mat02 = min(mat02, box(p02 + vec3(-5.0, 2.0, 0.0), vec3(0.01, scale, 1000000.0)));\n   //mat02 = min(mat02, box(p02 + vec3(5.0, 6.0, 0.0), vec3(0.01, scale, 1000000.0)));\n   //mat02 = min(mat02, box(p02 + vec3(-10.0, 4.0, 0.0), vec3(0.1, scale, 1000000.0)));\n   //mat02 = min(mat02, box(p02 + vec3(10.0, 4.0, 0.0), vec3(0.1, scale, 1000000.0)));\n   \n   //mat02 = min(mat02, box(p03 + vec3(15.0, 8.0, 0.0), vec3(0.2, scale, 1000000.0)));\n   \n   //mat02 = min(mat02, box(p04 + vec3(8.0, 4.0, 0.0), vec3(0.01, scale, 1000000.0)));\n  // mat02 = min(mat02, box(p04 + vec3(6.0, 4.0, 0.0), vec3(0.01, scale, 1000000.0)));\n   \n   \n  mat03 = -box(p03, vec3(55.0 + (mod04 * 15.0),55.0 + (mod04 * 15.0), 1000000.0));\n  \n  \n  \n  //mat04 = box(p04, vec3(sin(mod01) * 2.5, sin(mod01) * 2.5, 1000000.0));\n  //mat03 = smin(mat03, mat04 , pow(10.0 * curve(abs(sin(time * 2.0))), 2.6));\n  \n  //mat.mat = min(mat01, mat02);\n  mat.mat = min(mat01, mat03);\n  \n \n  \n  if(mat.mat < 0.01)\n  {\n    mat.type = 1;\n  }\n  \n  gg += 0.1/(0.9 +mat01*mat01);\n  \n  \n  \n  \n  return mat;\n}\n\nvec3 normals(vec3 p)\n{\n  vec2 uv = vec2(0.01, 0.0);\n  \n  return normalize(map(p).mat - vec3(map(p - uv.xyy).mat, map(p - uv.yxy).mat, map(p - uv.yyx).mat ));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n\n    \n    vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n  uv -= 0.5;\n  uv /= vec2(iResolution.y / iResolution.x, 1);\n\n  vec3 o = vec3(curve(time * 2.0) * 6.0, curve(time) * 4.0 + 6.5, 10.0 + curve(time * 4.5) * 325.0), t = vec3(curve(time * 2.0) * 6.0, 8.5, curve(time* 4.5) * 325.0);\n  vec3 fr = normalize( t - o );\n  vec3 ri =  normalize( cross( vec3(0.0, 1.0, 0.0), fr) );\n  vec3 up =  normalize( cross( fr, ri ) );\n  vec3 dir = normalize( fr + uv.x * ri + uv.y * up );\n  vec3 p = o + dir * 0.5;\n  \n  vec3 col = vec3(0.0);\n  \n  matter mat;\n  float shad, d;\n  for(int i = 0; i < 120; ++i)\n  {\n   p.xy *= rot(sin(time * 0.1 * mod01) * 0.001);\n    p.xz *= rot(sin(time * 0.01 * mod01) * 0.0001);\n    \nmat = map(p);\n\nif(mat.mat < 0.001)\n{\n  if(mat.type == 1)\n  {\n    mat.mat = 1.5 * (mod03 / 16.0);\n    \n     vec3 n = normals(p);\n    \n    dir = reflect(dir, n);\n    \n  } else {\n    \n    break;\n  }\n  \n  shad = clamp( 1.0 - (float(i)/200.0), 0.0, 1.0);\n}  \n\np += mat.mat * dir;\nd+= mat.mat;\n\n  col += mix(vec3(0.0, 0.5, 0.0), vec3(0.0, 0.0, 1.0), sin((p.z * 0.01 * mod01) + time )) * gg * (0.0002 * (mod01/6.0));\n  }\n  \n  col += shad * vec3(1.0);\n  \n float fog = clamp(1.0 - (d/100.0), 0.0, 1.0);\n  \n  vec3 sky = mix(vec3(1.0 * mod01, 0.0, 0.0), vec3(0.0, 0.5, 1.2), uv.y - 0.5);\n  col += sky * pow(0.3 * 2.5* (mod03 / 16.0), 1.6);\n  \n  fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}