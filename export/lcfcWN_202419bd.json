{"ver":"0.1","info":{"id":"lcfcWN","date":"1721161987","viewed":259,"name":"Mountains, lake and bridge","username":"bangerzzz","description":"\"POGL-v1.2.6 water\"\nexploring shader creation using everything i learned until now\nwater for my dulcin√©e","likes":24,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","noise","reflection","sdf","fbm","domainrepetition","water","painting","raymarcher","maths"],"hasliked":0,"parentid":"lfXyWN","parentname":"POGL-v1.2.5 exploring"},"renderpass":[{"inputs":[{"id":"4sfGRn","filepath":"/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","previewfilepath":"/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sfGRr","filepath":"/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin","previewfilepath":"/media/ap/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin","type":"volume","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const int g_raymarcher_max_steps = 560; // 547 no discontinuities\nconst float g_min_SD = 0.0;\nconst float g_max_SD = 2048.0; // DONT GO OVER 2048.0\n\nconst float g_water_height = 120.0;\n\n/* === Domain Repetition (DR) === */\n\n/**\n * rep_first_dim: how much repetition in vec2(-sign, +sign) of first dimension\n * rep_second_dim: how much repetition in vec2(-sign, +sign) of second dimension\n */\nvec2 limited_repetition_2D(vec2 point, float spacing, vec2 rep_first_dim, vec2 rep_second_dim) {\n    return point - spacing * clamp(round(point / spacing), -rep_first_dim, rep_second_dim);\n}\n\n/* === Actual scene === */\n\nfloat bridgeSDF(vec3 point) {\n    // bridge location\n    \n    point.x += 1500.0;\n    point.y -= 134.0;\n    \n    point.x = point.x + 10.0 * sin(0.023 * point.z) + 7.0; // can tweak\n    \n    // bridge\n    \n    float bridge_y = 0.0;\n    float bridge_SD;\n    \n    // floor planks\n    \n    vec3 q1 = point;\n    float planks_spacing = 2.0;\n    \n    q1.z = mod(q1.z + 1.0, planks_spacing) - 1.0;\n    float ground_planks_SD = boxSDF(q1, vec3(0.0, bridge_y, 0.0), vec3(5.0, 0.2, 0.9));\n    \n    // bottom planks\n    \n    vec3 q2 = vec3(abs(point.x), point.yz); // abs to get symmetry over x for bottom side bars\n    float bottom_planks_spacing = 4.0;\n    \n    q2.z = mod(q2.z + 2.0, bottom_planks_spacing) - 2.0;\n    float middle_plank_SD = boxSDF(q2, vec3(0.0, bridge_y - 0.6, 0.0), vec3(0.4, 0.4, 2.0));\n    \n    float side_planks_SD = boxSDF(vec3(q2.x - 3.6, q2.yz), vec3(0.0, bridge_y - 0.55, 0.0), vec3(0.4, 0.4, 2.0));\n\n    // =\n\n    float bottom_planks_SD = CSGunion(middle_plank_SD, side_planks_SD);\n    bridge_SD = CSGunion(ground_planks_SD, bottom_planks_SD);\n    \n    // side railings\n    \n    // pillars\n    \n    vec3 q3 = vec3(abs(point.x), point.yz);\n    float railings_vbars_spacing = 8.0;\n    \n    q3.z = mod(q3.z + 2.0, railings_vbars_spacing) - 2.0;\n    float railings_vbars_SD = boxSDF(vec3(q3.x - 4.5, q3.yz), vec3(0.0, bridge_y + 2.5, 0.0), vec3(0.5, 3.5, 0.7));\n    bridge_SD = CSGunion(bridge_SD, railings_vbars_SD);\n    \n    // horizontal guards\n    \n    float top_guards1_SD = boxSDF(vec3(q2.x - 4.5, q2.yz), vec3(0.0, bridge_y + 6.0, 0.0), vec3(0.7, 0.15, 2.0));\n    float top_guards2_SD = boxSDF(vec3(q2.x - 4.5, q2.yz), vec3(0.0, bridge_y + 6.3, 0.0), vec3(0.9, 0.15, 2.0));\n    bridge_SD = CSGunion(bridge_SD, top_guards1_SD);\n    bridge_SD = CSGunion(bridge_SD, top_guards2_SD);\n    \n    float side_guards1_SD = boxSDF(vec3(q2.x - 3.6, q2.yz), vec3(0.0, bridge_y + 4.6, 0.0), vec3(0.2, 0.4, 2.0));\n    float side_guards2_SD = boxSDF(vec3(q2.x - 3.6, q2.yz), vec3(0.0, bridge_y + 3.2, 0.0), vec3(0.2, 0.4, 2.0));\n    float side_guards3_SD = boxSDF(vec3(q2.x - 3.6, q2.yz), vec3(0.0, bridge_y + 2.2, 0.0), vec3(0.2, 0.4, 2.0));\n    float side_guards4_SD = boxSDF(vec3(q2.x - 3.6, q2.yz), vec3(0.0, bridge_y + 1.2, 0.0), vec3(0.2, 0.4, 2.0));\n    bridge_SD = CSGunion(bridge_SD, side_guards1_SD);\n    bridge_SD = CSGunion(bridge_SD, side_guards2_SD);\n    bridge_SD = CSGunion(bridge_SD, side_guards3_SD);\n    bridge_SD = CSGunion(bridge_SD, side_guards4_SD);\n    \n    return bridge_SD;\n}\n\nfloat terrainSDF(vec2 p)\n{\n    float e = value_fbm1(p/2000.0 + vec2(1.0, -2.0));\n    e = 600.0*e + 600.0;\n    \n    return e;\n}\n\n// Describe the objects and structures of the scene here using their respective SDFs\n// use ids for materials and transmit them to raymarcher (out variable)\nfloat map(vec3 point, out float material_id) {\n    material_id = 0.0;\n    \n    // bridge\n    \n    float bridge_SD = bridgeSDF(point);\n    if (bridge_SD < 0.1) {\n        material_id = 1.0;\n    }\n    \n    // terrain\n    \n    float terrain_SD = terrainSDF(point.xz);\n    terrain_SD = point.y - terrain_SD;\n    if (terrain_SD < 0.1) {\n        material_id = 3.0;\n    }\n    \n    // res\n\n    float res_SD = CSGunion(bridge_SD, terrain_SD);\n    return res_SD;\n}\n\n// to add noise and texturing\n// => also used to compute normals\nfloat map2(vec3 point) {\n    float material_id;\n    float SD = map(point, material_id);\n    \n    if (material_id == 1.0) { // bridge\n        // SD -= 0.1 * (0.0 + 0.7 * fbm1_sampler3D(iChannel0, point * vec3(3, 1, 2)));\n        SD -= 0.06 * (0.0 + 0.9 * fbm1_sampler2D(iChannel1, point.xz * vec2(3, 1)));\n    }\n    \n    return SD;\n}\n\n/* === Raymarcher === */\n\nvec3 terrainNormalEstimate(vec2 p)\n{\n    vec2 e = vec2(0.001, 0.0);\n\treturn normalize(vec3(terrainSDF(p - e.xy) - terrainSDF(p + e.xy),\n                          2.0 * e.x,\n                          terrainSDF(p - e.yx) - terrainSDF(p + e.yx)));\n}\n\n// normalized normal estimate (not like in raytracer cause we dont know the function to get the exact gradient)\nvec3 getNormalEstimate(vec3 point) {\n    float tmp;\n    \n    vec3 e = vec3(0.001, 0.0, 0.0); // trick to simplify equations below using vector notation\n    vec3 normal_estimate = vec3(\n        map2(vec3(point + e.xyy)) - map2(vec3(point - e.xyy)),\n        map2(vec3(point + e.yxy)) - map2(vec3(point - e.yxy)),\n        map2(vec3(point + e.yyx)) - map2(vec3(point - e.yyx))\n    );\n    \n    return normalize(normal_estimate); \n}\n\nvec3 fog(vec3 color, float t) {\n    vec3 ext = exp(-0.00035 * vec3(1.0, 1.5, 3.0) * t); // separate RGB canals influence \n    return color * ext + vec3(0.5) * (1.0 - ext);\n}\n\nfloat terrainShadow(vec3 ray_origin, vec3 light_dir, float start, float end, float k) {\n    # if 0 // disable shadows\n        return 1.0;\n    #endif\n    \n    float res = 1.0;\n    float depth = start;\n    \n    float material_id;\n    for (int i = 0; i < g_raymarcher_max_steps && depth < end; i++) {\n        vec3 point = ray_origin + depth * light_dir;\n        float cur_SD = map(point, material_id);\n        \n        if (point.y <= g_water_height) { // remove to get below bridge reflection\n            return 0.0;\n        }\n        \n        if (cur_SD < g_epsilon) {\n            return 0.0;\n        }\n        \n        res = min(res, k * cur_SD / depth);\n        depth += cur_SD;\n    }\n    \n    return S3(0.0, 1.0, res);\n}\n\nvec3 terrainMaterial(vec3 point) {\n    vec3 color;\n    \n    vec3 terrain_color = vec3(0.2, 0.18, 0.1); \n    vec3 grass_color = vec3(0.03, 0.21, 0.09);\n    // vec3 sand_color = vec3(0.22, 0.21, 0.11);\n\n    vec3 normal = terrainNormalEstimate(point.xz);\n    \n    if (point.y > g_water_height - 20.0) { // below is ignored cause water\n        if (point.y < g_water_height + 3.0) {\n            color = terrain_color;\n        } else {\n            float grass_factor = S3(0.7, 1.0, normal.y);\n            color = (1.0 - grass_factor) * terrain_color + grass_factor * grass_color;\n        }\n    } else {\n        color = terrain_color;\n    }\n    \n    // color = terrain_color;\n\n    return color;\n}\n\n// maybe lighting for all\nvec3 sceneLighting(vec3 point, vec3 dir, float material_id) {\n    vec3 color;\n    \n    vec3 normal;\n    if (material_id <= 1.1) {\n        normal = getNormalEstimate(point);\n    } else\n    if (material_id <= 3.1) {\n        normal = terrainNormalEstimate(point.xz);\n    }\n    \n    // return normal;\n    \n    vec3 sky_color = vec3(0.25, 0.55, 1.5);\n    \n    vec3 sun_color = vec3(1.5, 0.9, 0.2);\n    float sun_theta = 0.9; // 0.9\n    float sun_phi = 4.0; // 4.0\n    vec3 sun_dir = vec3(sin(sun_theta) * sin(sun_phi), cos(sun_theta), sin(sun_theta) * cos(sun_phi));\n    \n    float nor_sun_dot = dot(normal, sun_dir);\n    if (nor_sun_dot >= 0.0) {\n        float soft_shadow = terrainShadow(point + vec3(0.0, 0.2, 0.0), sun_dir, g_min_SD, g_max_SD, 16.0);\n        color = sun_color * nor_sun_dot * soft_shadow; // sun direct contribution\n        \n        color += (1.0 + normal.y) / 2.0 * sky_color / 10.0; // sky lighting contribution\n        \n        vec3 sun_bounce = -sun_dir;\n        float nor_bounce_dot = dot(normal, sun_bounce);\n        if (nor_bounce_dot >= 0.0) {\n            color += sun_color / 10.0; // sun bounce contribution\n        }\n    }\n    \n    return color;\n}\n\n/**\n * @brief dir must be normalized\n *\n * @return vec3(shortest_SD, material_id, is_reflect)\n */\nvec3 getShortestSDInfo(vec3 eye, vec3 dir, float start, float end) {\n    float depth = start;\n    \n    float material_id;\n    for (int i = 0; i < g_raymarcher_max_steps; i++) {\n        vec3 point = eye + depth * dir;\n        \n        // water reflection\n        \n        float is_reflect = 0.0;\n        if (point.y <= g_water_height) {\n            point.y = g_water_height - (point.y - g_water_height);\n            \n            // point.x += 0.5 * cos(iTime * (point.z / 200.0) + 10.0);\n            // point.z += 0.2 * sin(iTime * (point.z / 50.0) + 10.0);\n            \n            is_reflect = 1.0;\n        }\n        \n        float cur_SD = map(point, material_id);\n        \n        if (cur_SD < g_epsilon) { // inside scene surface\n            return vec3(depth, material_id, is_reflect);\n        }\n        \n        depth += cur_SD;\n        \n        if (depth >= end) { // went beyond scene\n            return vec3(end, -1.0, is_reflect);\n        }\n    }\n    \n    return vec3(end, -1.0, 0.0); // if reached, too few steps probably\n}\n\n/**\n * (from gluLookAt)\n * Creates a viewing matrix derived from an eye point, a reference point indicating the center\n * of the scene, and an UP vector.\n *\n * The matrix maps the reference point to the negative z axis and the eye point to the origin.\n * When a typical projection matrix is used, the center of the scene therefore maps\n * to the center of the viewport. Similarly, the direction described by the UP vector projected\n * onto the viewing plane is mapped to the positive y axis so that it points upward in the viewport.\n * The UP vector must not be parallel to the line of sight from the eye point to the reference point. \n */\nmat4 myGluLookAt(vec3 eye, vec3 center, vec3 up) {\n\tvec3 f = normalize(center - eye);\n\tvec3 s = normalize(cross(f, up));\n\tvec3 u = cross(s, f);\n\treturn mat4(\n\t\tvec4(s, 0.0),\n\t\tvec4(u, 0.0),\n\t\tvec4(-f, 0.0),\n\t\tvec4(0.0, 0.0, 0.0, 1)\n\t);\n}\n\nvec3 getMarchingDirection(float vfov_degrees, vec2 fragCoord) {\n    float vfov_radians = radians(vfov_degrees);\n    float h = tan(vfov_radians / 2.0);\n\n    vec2 xy = fragCoord - iResolution.xy / 2.0;\n    float z = iResolution.y / h;\n    return normalize(vec3(xy, -z));\n}\n\n// should be useful, but testing doesnt change from just using world_up vector as camera_up\nvec3 getCameraUpVector(vec3 eye, vec3 look_at) {\n    vec3 forward = normalize(look_at - eye);\n    vec3 world_up = vec3(0.0, 1.0, 0.0);\n    vec3 right = normalize(cross(forward, world_up));\n    return cross(right, forward);\n}\n\nvec3 raymarch(vec2 fragCoord) {\n    // vec3 eye = vec3(-1370.0, 150.0, 620.0);\n    vec3 eye = vec3(-1488.0, 150.0, 730.0); // real 1.2.6\n    \n    // vec3 look_at = vec3(-800.0 + eye.x, eye.y - 100.0, 250.0 + eye.z);\n    vec3 look_at = vec3(-2000.0 + eye.x, eye.y - 100.0, -5000.0 + eye.z); // real 1.2.6\n    \n    vec3 camera_up = getCameraUpVector(eye, look_at);\n    \n    mat4 view_to_world_mat = myGluLookAt(eye, look_at, camera_up);\n    \n    float vfov_degrees = 95.0; // 95.0\n    vec3 view_marching_dir = getMarchingDirection(vfov_degrees, fragCoord);\n    vec3 world_marching_dir = (view_to_world_mat * vec4(view_marching_dir, 0.0)).xyz;\n    \n    vec3 SD_info = getShortestSDInfo(eye, world_marching_dir, g_min_SD, g_max_SD);\n    float SD = SD_info.x;\n    float material_id = SD_info.y;\n    float is_reflect = SD_info.z;\n    \n    if (SD <= g_max_SD - g_epsilon) { // Hit something\n        vec3 color;\n        vec3 material;\n        \n        vec3 point = eye + SD * world_marching_dir;\n        \n        // materials (diffuse colors should be around 0.2)\n        \n        if (material_id <= 0.1) { // debug color\n            return vec3(1.0, 1.0, 1.0);\n        } else\n        if (material_id <= 1.1) { // wood = 1.0\n            material = vec3(0.2, 0.07, 0.2);\n        } else\n        if (material_id <= 3.1) { // terrain = 3.0\n            material = terrainMaterial(point);\n        }\n        \n        vec3 lighting = sceneLighting(point, world_marching_dir, material_id);\n        color = material * lighting;\n        \n        color = fog(color, SD);\n        \n        if (is_reflect >= 0.1) { // TODO sinus, refraction, ...\n            color *= vec3(0.8, 1.0, 1.4);\n        }\n        \n        color = pow(color, vec3(1.0, 0.9, 1.0));\n        return color;\n    }\n    \n    // Background color\n    // return vec3(1.0, 0.0, 0.0);\n    \n    vec3 sky_color = vec3(0.25, 0.55, 1.5);\n    if (is_reflect >= 0.1) {\n        return sky_color - 0.2 * -world_marching_dir.y;\n    } else {\n        return sky_color - 0.5 * world_marching_dir.y;\n    }\n    \n    // float a = 0.5 * (world_marching_dir.y + 1.0);\n    // return (1.0 - a) * vec3(1.5, 1.5, 1.5) + a * vec3(0.75, 1.05, 1.5); // gradient trick\n}\n\n/* === Post-processing === */\n\n// Based on http://www.oscars.org/science-technology/sci-tech-projects/aces\n// To go from HDR (High Dynamic Range) to LDR (Low Dynamic Range)\n// also includes gamma correction\nvec3 hill_aces_tonemap(vec3 color){\t\n\tmat3 m1 = mat3(\n        0.59719, 0.07600, 0.02840,\n        0.35458, 0.90834, 0.13383,\n        0.04823, 0.01566, 0.83777\n\t);\n    \n\tmat3 m2 = mat3(\n         1.60475, -0.10208, -0.00327,\n        -0.53108,  1.10813, -0.07276,\n        -0.07367, -0.00605,  1.07602\n\t);\n    \n\tvec3 v = m1 * color;    \n\tvec3 a = v * (v + 0.0245786) - 0.000090537;\n\tvec3 b = v * (0.983729 * v + 0.4329510) + 0.238081;\n    \n    float gamma = 2.2;\n\treturn pow(clamp(m2 * (a / b), 0.0, 1.0), vec3(1.0 / gamma));\t\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    // vec2 uv = fragCoord/iResolution.xy;\n    \n    vec3 raymarching_res = raymarch(fragCoord);\n    \n    vec3 output_color = hill_aces_tonemap(raymarching_res);\n    \n    fragColor = vec4(output_color, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"const float g_pi = 3.141592; // maybe add more precision if needed\nconst float g_tau = 6.283185; // maybe add more precision if needed\n\nconst float g_epsilon = 0.0001;\n\n/* === rotation utils === */\n\nmat2 rotation_mat_2D(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    \n    return mat2(c,-s,\n                s,c );\n}\n\n/* === Constructive Solid Geometry (CSG) operations === */\n\nfloat CSGinter(float dist1, float dist2) {\n    return max(dist1, dist2);\n}\n\nfloat CSGunion(float dist1, float dist2) {\n    return min(dist1, dist2);\n}\n\n// not commutative\nfloat CSGdiff(float dist1, float dist2) {\n    return max(dist1, -dist2);\n}\n\nfloat CSGxor(float dist1, float dist2) {\n    return max(-max(-dist1, -dist2), min(-dist1, -dist2));\n}\n\n/* === CSG smooth minimums === */\n\n// https://iquilezles.org/articles/smin/ recap of different smin functions at the end as well as examples\n\n// k (tolerance) normalization included in function\nfloat quadratic_polynomial_smin(float a, float b, float k) {\n    k *= 4.0;\n    float h = max(k - abs(a - b), 0.0) / k;\n    return min(a, b) - h * h * k / 4.0;\n}\n\n/* === SDF Primitives === */\n\nfloat sphereSDF(vec3 point, vec3 center, float radius) {\n    return length(point - center) - radius;\n}\n\n// R is a vector from the center of the box to the top right corner\nfloat boxSDF(vec3 point, vec3 center, vec3 R) {\n    vec3 q = abs(point - center) - R;\n    return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);\n}\n\n// my non optimized version\n// movable only in x and z for now\nfloat cappedYCylinderSDF(vec3 point, vec3 center, float radius, float height) {\n    float infinite_Ycylinder_dist = length(point.xz - center.xz) - radius;\n    float res_dist = max(infinite_Ycylinder_dist, point.y - height);\n    return max(res_dist, -point.y - height);\n}\n\n/* === smoothstep functions === */\n\n// can also use \"smoothstep\" from glsl\n// https://registry.khronos.org/OpenGL-Refpages/gl4/html/smoothstep.xhtml\n\n// cubic polynomial\n\nfloat S3(float a, float b, float x) {\n    float l = min(1.0, max(0.0, (x - a)/(b - a)));\n    return l*l * (3.0 - 2.0 * l);\n}\n\nfloat S3(float l) {\n    return l*l * (3.0 - 2.0 * l);\n}\n\n// quintic polynomial\n\nfloat S5(float a, float b, float x) {\n    float l = min(1.0, max(0.0, (x - a)/(b - a)));\n    return l*l*l * (l * (l * 6.0 - 15.0) + 10.0);\n}\n\nfloat S5(float l) {\n    return l*l*l * (l * (l * 6.0 - 15.0) + 10.0);\n}\n\n/* === hash utils === */\n\n// FIXME replace with better hash, for now using example hash from iq\n// https://www.youtube.com/watch?v=BFld4EBO2RE\nfloat hash1(vec2 p)\n{\n    vec2 uv = 50.0 * fract(p / g_pi);\n    return 2.0 * fract(uv.x * uv.y * (uv.x + uv.y)) - 0.5;\n}\n\n/* === Value noise === */\n\n// P: vec2(x, z) coordinates to evaluate noise at\n// try with S3 and S5\nfloat value_noise1(vec2 P) {\n    vec2 p = floor(P);\n    \n    // hashed tile corners\n    float a = hash1(p + vec2(0, 0));\n    float b = hash1(p + vec2(1, 0));\n    float c = hash1(p + vec2(0, 1));\n    float d = hash1(p + vec2(1, 1));\n    \n    // TODO is (-1.0 + 2.0 *) related to vec2(-1.0, 2.0) displacement in terrainMap ?? or with hash ?? idk\n    return -1.0 + 2.0 * (a +\n           (b - a) * S5(P.x - p.x) +\n           (c - a) * S5(P.y - p.y) +\n           (a - b - c + d) * S5(P.x - p.x) * S5(P.y - p.y));\n}\n\nfloat value_fbm1(vec2 P) {\n    float res = 0.0;\n    \n    // nice trick here, use pythagorean triplet to avoid cos and sin computation\n    // (inverse rotation matrix)\n    mat2 rot_mat = mat2( 0.80, 0.60,\n                        -0.60, 0.80 );\n    \n    float frequency = 2.02;\n    float persistence = 0.5;\n    float amplitude = 0.4;\n    int octaves = 12;\n    for(int i = 0; i < octaves; i++)\n    {\n        float n = value_noise1(P);\n        res += amplitude * n;\n        amplitude *= persistence;\n        P = frequency * rot_mat * P;\n    }\n    \n\treturn res;\n}\n\n/* === noise and fractal brownian motion from input texture === */\n\nfloat noise1_sampler2D(sampler2D tex, vec2 P) {\n    return textureLod(tex, (P + 0.5) / 64.0, 0.0).x;\n}\n\n// 4 octaves\nfloat fbm1_sampler2D(sampler2D tex, vec2 P) {\n    float res = 0.0;\n    float lacunarity = 2.0;\n    float persistence = 0.5;\n    \n    res += persistence * noise1_sampler2D(tex, P);\n    P *= lacunarity;\n    \n    res += (persistence / 2.0) * noise1_sampler2D(tex, P);\n    P *= lacunarity;\n    \n    res += (persistence / 4.0) * noise1_sampler2D(tex, P);\n    P *= lacunarity;\n    \n    res += (persistence / 8.0) * noise1_sampler2D(tex, P);\n    \n    return res;\n}\n\n\n// TODO tweak and understand\nfloat noise1_sampler3D(sampler3D tex, vec3 P) {\n    return textureLod(tex, (P + 0.5) / 32.0, 0.0).x;\n}\n\n// 4 octaves\nfloat fbm1_sampler3D(sampler3D tex, vec3 P) {\n    float res = 0.0;\n    float lacunarity = 2.0;\n    float persistence = 0.5;\n    \n    res += persistence * noise1_sampler3D(tex, P);\n    P *= lacunarity;\n    \n    res += (persistence / 2.0) * noise1_sampler3D(tex, P);\n    P *= lacunarity;\n    \n    res += (persistence / 4.0) * noise1_sampler3D(tex, P);\n    P *= lacunarity;\n    \n    res += (persistence / 8.0) * noise1_sampler3D(tex, P);\n    \n    return res;\n}\n","name":"Common","description":"","type":"common"}]}