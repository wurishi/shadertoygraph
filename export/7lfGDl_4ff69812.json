{"ver":"0.1","info":{"id":"7lfGDl","date":"1623277914","viewed":172,"name":"Some refraction practice.","username":"Danchyg1337","description":"Just sample refraction/reflection shader. \nAny thoughts on improvements?","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["reflection","refraction","practice"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_DIST 100.\n#define SURF_DIST 0.0001\n#define MAX_PATH 100\n\n\n#define OBJ_REFR 3\n#define OBJ_REFL 4\n#define RI 1.5\n\n#define MAT_NONE   0\n#define MAT_METAL  1\n#define MAT_GLASS  2\n#define MAT_DEBRAY 3\n\n#define DEBRAY_START vec3(14, -1, -1.5)\n#define DEBRAY_DIR   normalize(vec3(-.6, .04, .3))\n#define DEBRAY_DIST  7\n\n#define PI 3.14159265359\n\n#define USE_AA\n\n#define USE_DEBUGRAY\n\nstruct Sphere{\n    vec3 pos;\n    float rad;\n} sph;\n\nstruct Cube{\n    vec3 pos;\n    vec3 sides;\n} box;\n\nstruct Torus{\n    vec3 pos;\n\tfloat inrad;\n    float rrad;\n    vec3 col;\n\tvec3 dir;\n} tor;\n\nstruct Line{\n    vec3 start;\n    vec3 end;\n};\n\nLine debRays[DEBRAY_DIST];\n\nfloat sdLine( vec3 p, vec3 a, vec3 b)\n{\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - 0.01;\n}\n\nmat2 Rot(float angl){\n    float s = sin(angl), c = cos(angl);\n    return mat2(c, -s, s, c);\n}\n\nfloat sdBox(vec3 p, vec3 s) {\n    //p.xy *= Rot(iTime);\n    //p.zx *= Rot(iTime);\n    p = abs(p)-s;\n\treturn length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.) - .05;\n}\n\nfloat sdTorus(vec3 p){\n    vec3 tp = p - tor.pos;\n    tp.xy *= Rot(iTime);\n    tp.zy *= Rot(iTime);\n\tvec2 q = vec2(length(tp.xz)-tor.inrad,tp.y);\n\treturn length(q)-tor.rrad;\n}\n\n\nfloat GetDist(vec3 point, out int mat, bool inside, bool getDebRay){\n    float sphDist = length(point - sph.pos) - sph.rad;\n    float boxDist = sdBox(point - box.pos, box.sides);\n    float torDist = sdTorus(point - tor.pos);\n    \n    float redDist = 9999.; \n    if(getDebRay){\n        for(int t=0;t<DEBRAY_DIST;t++){\n            redDist = min(redDist, sdLine(point, debRays[t].start, debRays[t].end));\n        }\n    }\n    \n    mat = MAT_NONE;\n    if(boxDist < SURF_DIST) mat = MAT_GLASS;\n    if(sphDist < SURF_DIST) mat = MAT_METAL;\n    if(torDist < SURF_DIST) mat = MAT_GLASS;\n    if(redDist < SURF_DIST) mat = MAT_DEBRAY;\n    \n    float d = min(sphDist, min(boxDist, torDist));\n    if(inside) return max(-redDist, d);\n    return min(redDist, d);\n}\n\n\nvec3 GetNormal(vec3 p) {\n    int matDummy = MAT_NONE;\n\tfloat d = GetDist(p, matDummy, false, false);\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy, matDummy, false, false),\n        GetDist(p-e.yxy, matDummy, false, false),\n        GetDist(p-e.yyx, matDummy, false, false));\n    \n    return normalize(n);\n}\n\nvec3 March(vec3 pos, vec3 dir, out int mat, bool outs, bool getDebRay){\n    vec3 finalPos = pos;\n    mat = MAT_NONE;\n    for(int t=0;t<MAX_PATH;t++){\n        float dist = GetDist(finalPos, mat, outs, getDebRay) * (outs ? -1. : 1.);\n        if(mat == MAT_DEBRAY) return pos;\n        finalPos += dist * dir;\n        if(dist < SURF_DIST || dist > MAX_DIST) break;  \n    }\n    return finalPos;\n}\n\nvec3 GetRayDir(vec2 uv, vec3 lookAt, vec3 camPos, float zoom){\n    vec3 Ldir = normalize(lookAt - camPos);\n    \n    vec3 right = normalize(cross(vec3(0, 1, 0), Ldir));\n    vec3 up = normalize(cross(Ldir, right));\n    \n    return normalize(Ldir * zoom + right * uv.x + up * uv.y);\n}\n\nbool RefractRay(inout vec3 pos, inout vec3 dir, bool debRay, inout int debRayNum){\n    vec3 n = GetNormal(pos);\n    dir = refract(dir, n, 1./RI);\n    pos = pos - n * SURF_DIST * 2.;\n    \n    for(int t=0;t<OBJ_REFL;t++){\n        int mat = MAT_NONE;\n        \n        if(debRay) debRays[debRayNum].start = pos;\n        vec3 inside = March(pos, dir, mat, true, !debRay);\n        \n        if(mat == MAT_DEBRAY) return true;\n        if(debRay) debRays[debRayNum].end = inside;\n        \n        vec3 nR = -GetNormal(inside);\n        \n        vec3 refrOut = refract(dir, nR, RI);\n        \n        if(length(refrOut) != 0.){\n            dir = refrOut;\n            pos = inside - nR * SURF_DIST * 3.;\n            return false;\n        }\n        dir = reflect(dir, nR);\n        pos = inside + nR * SURF_DIST * 3.;\n        \n        if(debRay) debRayNum++;\n    }\n}\n\nvec3 GetPixel(vec2 fragCoord){   \n    vec2 uv = (fragCoord - iResolution.xy * .5) / iResolution.y;\n    vec2 m = iMouse.xy/iResolution.xy;\n    \n    vec3 camPos = vec3(9, 0, 0);\n    \n    if(length(m) != 0.){\n        camPos.xy *= Rot(m.y * PI + PI / 2.);\n        camPos.zx *= Rot(m.x * PI * 3.);\n    }\n\n    camPos += box.pos;\n\n    vec3 dir = GetRayDir(uv, box.pos, camPos, 1.); \n\n    vec3 currPos = camPos;\n    vec3 finDir = dir;\n\n    for(int t=0;t<OBJ_REFR;t++){\n        int mat = MAT_NONE;\n        vec3 marched = March(currPos, finDir, mat, false, true);\n    \n    \n        if(mat == MAT_NONE) break;\n        if(mat == MAT_GLASS){\n            int dummy = 0;\n            if(RefractRay(marched, finDir, false, dummy)) return vec3(1, 0, 0);\n            currPos = marched;\n        }\n        if(mat == MAT_METAL){\n            vec3 n = GetNormal(marched);\n            finDir = reflect(finDir, n);\n            currPos = marched + n * SURF_DIST * 3.;\n        }\n        if(mat == MAT_DEBRAY){\n            return vec3(1, 0, 0);\n        }\n    }\n    vec3 col = texture(iChannel0, finDir).rgb;\n    return col;\n}\n\nvoid ComputeDebugRay(vec3 start, vec3 dir){\n    vec3 currPos = start;\n    vec3 finDir = dir;\n\n    for(int t=0;t<DEBRAY_DIST;t++){\n        debRays[t].start = currPos;\n        int mat = MAT_NONE;\n        vec3 marched = March(currPos, finDir, mat, false, false);\n        debRays[t].end = marched;\n    \n    \n        if(mat == MAT_NONE) break;\n        if(mat == MAT_GLASS){\n            t++;\n            RefractRay(marched, finDir, true, t);\n            currPos = marched;\n        }\n        if(mat == MAT_METAL){\n            vec3 n = GetNormal(marched);\n            finDir = reflect(finDir, n);\n            currPos = marched + n * SURF_DIST * 3.;\n        }\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    sph.pos = vec3(0, 0, 0);\n    sph.rad = 1.;\n\n    box.pos = vec3(7, 0, 0);\n    box.sides = vec3(2, 2, 2);\n    \n    tor.pos = vec3(0, 0, 0);\n    tor.inrad = 3.;\n    tor.rrad = .7;\n    tor.dir = normalize(vec3(1, 0, 0));\n    \n    #ifdef USE_DEBUGRAY\n    ComputeDebugRay(DEBRAY_START, DEBRAY_DIR);\n    #endif\n    \n    vec3 col = GetPixel(fragCoord);\n    #ifdef USE_AA\n    col += GetPixel(fragCoord + vec2(.5, 0.));\n    col += GetPixel(fragCoord + vec2(-.5, 0.));\n    col += GetPixel(fragCoord + vec2(0., .5));\n    col += GetPixel(fragCoord + vec2(0., -.5));\n    col /= 5.;  \n    #endif\n    \n    //col = pow(col, vec3(.4545));\n    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}