{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[],"code":"#define PI 3.14159265\n\n#define GRIDSIZE 140.\n// must be less than sqrt(2)/4 ~= 0.35 or stuff can overlap (bad)\n#define VARIANCE 0.25\n#define SPEED 0.2\n#define CONTRAST 0.5\n\n// gradient ‚ù§Ô∏èüíúüíô\n#define GRAD_A vec3( 0.839 , 0.008 , 0.439 )\n#define GRAD_B vec3( 0.0   , 0.22  , 0.659 )\n\n// smooth pseudo-random motion\n// FIXME: somehow loses accuracy as iTime gets larger so lines eventually stop lining up\nvec2 move( vec2 pos ) {\n    float T      = SPEED * iTime ;\n    float warble = pos.x / 24.68 ;\n    float shift  = pos.y / 36.912 ;\n    float pinch  = mod ( shift * warble * 123.567 , 10. ) - 5. ;\n    float grit   = mod ( shift * warble * 234.678 ,  4. ) - 2. ;\n    return pos + vec2(\n        cos( pinch * cos( cos( grit * T ) + T + warble ) + T + shift ) ,\n        cos( pinch * cos( cos( grit * T ) + T - warble ) + T - shift )\n    ) * GRIDSIZE * VARIANCE ;\n}\n\nfloat theta( vec2 p ) { // angle from 12 o'clock\n    float th = acos( dot( vec2( 0 , 1 ) , normalize( p ) ) ) ;\n    if ( p.x < 0. ) th = 2. * PI - th ;\n    return th ;\n}\n\nvec2 centre( vec2 a , vec2 b , vec2 c ) { // centre of 3 points\n    return ( a + b + c ) / 3. ;\n}\n\nbool above( vec2 a , vec2 b , vec2 p ) { // return whether p lies above the line a->b\n    float m = ( b.y - a.y ) / ( b.x - a.x ) ;\n    float c = a.y - m * a.x ;\n    return m * p.x + c < p.y ;\n}\n\n// return the centre point of the triangle uv falls into\nvec2 getTriangle( vec2 uv ) {\n    vec2 r = floor( uv / GRIDSIZE + 0.5 ) * GRIDSIZE ; // nearest (unmoved) grid point\n    vec2 a = move( vec2( r.x , r.y + GRIDSIZE ) ) ; // up\n    vec2 b = move( vec2( r.x + GRIDSIZE , r.y + GRIDSIZE ) ) ; // up+right\n    vec2 c = move( vec2( r.x + GRIDSIZE , r.y ) ) ; // right\n    vec2 d = move( vec2( r.x , r.y - GRIDSIZE ) ) ; // down\n    vec2 e = move( vec2( r.x - GRIDSIZE , r.y - GRIDSIZE ) ) ; // down+left\n    vec2 f = move( vec2( r.x - GRIDSIZE , r.y ) ) ; // left\n    vec2 p = move( r ) ;\n    \n    // angle of p->uv\n    float th = theta( uv - p ) ;\n\n    // vectors p->[a-f] form 6 segments around p at the corners of each triangle\n    float a_ = theta( a - p ) ;\n    float b_ = theta( b - p ) ;\n    if ( a_ < PI ) {\n        // A B\n        if ( th >= a_ && th < b_ ) return centre( a , p , b ) ;\n        // F A outer triangle\n        if ( above( f , a , uv ) ) return centre( f , a , move( vec2( r.x - GRIDSIZE , r.y + GRIDSIZE ) ) ) ;\n        // 0 A\n        if ( th < a_ ) return centre( f , a , p ) ;\n    } else { // A 0 & 0 B\n        if ( th < b_ || th > a_ ) return centre( a , p , b ) ;\n    }\n    // B C\n    if ( th < theta( c - p ) ) return centre( c , p , b ) ;\n    // C D\n    if ( th < theta( d - p ) ) {\n        // outer triangle\n        if ( ! above( d , c , uv ) ) return centre( d , c , move( vec2( r.x + GRIDSIZE , r.y - GRIDSIZE ) ) ) ;\n        // inner triangle\n        return centre( d , p , c ) ;\n    }\n    // D E\n    if ( th < theta( e - p ) ) return centre( e , p , d ) ;\n    // E F\n    if ( th < theta( f - p ) ) return centre( f , p , e ) ;\n    float f_ = theta( f - p ) ;\n    // F A outer triangle\n    if ( above( f , a , uv ) ) return centre( f , a , move( vec2( r.x - GRIDSIZE , r.y + GRIDSIZE ) ) ) ;\n    if ( a_ < PI ) { // F 0 & 0 A\n        if ( th >= f_ || th < a_ ) return centre( f , a , p ) ;\n    } else { // F A\n        if ( th < a_ ) return centre( f , a , p ) ;\n    }\n    return vec2( 0 ) ;\n}\n\nfloat getColour( vec2 p , vec2 bias ) { // diagonal gradient\n    vec2 a = vec2( 0. , 1. + sin( iTime * SPEED ) / 1.5 ) * iResolution.xy - bias * CONTRAST ;\n    vec2 b = vec2( 1. , 1. - sin( iTime * SPEED ) / 1.5 ) * iResolution.xy - bias * CONTRAST ;\n    return dot( p - a , b - a ) / dot( b - a , b - a ) ;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // split canvas into grid connected horizontally, vertically, and diagonally up+right\n    // move all grid points around for variance over time\n    // detect which triangle the current point lies in\n    // colour it based on its position in the gradient\n    \n    vec2 p = getTriangle( fragCoord ) ;\n    vec3 col = mix( GRAD_A , GRAD_B , getColour( p , p - fragCoord ) ) ;\n    //vec3 col = vec3( getColour( p ) ) ;\n    //vec3 col = p.xxx ;\n    \n    fragColor = vec4( col , 1.0 ) ;\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"DdsXz2","date":"1669231710","viewed":74,"name":"low poly gradient thing idk","username":"mira","description":"Gradient split into little moving triangles.\n\nDoesn't work very well lmao.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["gradient","lowpoly","pride"],"hasliked":0,"parentid":"","parentname":""}}