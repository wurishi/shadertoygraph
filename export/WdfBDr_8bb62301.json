{"ver":"0.1","info":{"id":"WdfBDr","date":"1587998192","viewed":172,"name":"Overlapping squares - need help","username":"newtoglsl77","description":"I'm hoping somebody can chime in with an easier way to accomplish this. I tiled my coordinate system, rotated each tile using a rotation matrix, and used the inverse of the rotation matrix to determine overlapping","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["beginner","help","request"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14159265358979323846\n#define aa 0.02\n\nvec2 rotate2D (vec2 st, float angle, float offset) \n{\n    st -= offset;\n    st = mat2(cos(angle),-sin(angle),\n                sin(angle),cos(angle)) * st;\n    st += offset;\n    return st;\n}\n\nvec2 inverseMatrix(vec2 st, float angle, float offset) \n{\n\t//st -= offset;\n\t//float s = (st.y + st.x*cos(angle)/sin(angle))/(sin(angle)+(cos(angle)*cos(angle)/sin(angle)));\n\t//float t = (s*cos(angle)-st.x)/sin(angle);\n    //float s = st.y*sin(angle) + st.x*cos(angle);\n \t//float t = st.y*cos(angle) - st.x*sin(angle);\n\t//st = vec2(s,t);\n\t//st += offset;\n    \n    // this line replaces the above 7 lines\n    st = rotate2D(st, angle, offset);\n\t\n\t// this is a mask so that just the overlapping values are selected\n    st *= step(0.0,st.x) * (1.0-step(1.0, st.x));\n    st *= step(0.0,st.y) * (1.0-step(1.0, st.y));\n    st *= smoothstep(0.0,aa,st.x) * (smoothstep(1.0,1.0-aa,st.x));\n    st *= smoothstep(0.0,aa,st.y) * (smoothstep(1.0,1.0-aa,st.y));\n\t\n\treturn st;\n}\n\nvoid mainImage ( out vec4 fragColor, in vec2 fragCoord ) \n{\n    //vec2 st = fragCoord/iResolution.xy;\n    //st.x *= iResolution.x/iResolution.y;\n\tvec2 st = fragCoord/iResolution.y;\n    \n\t//create a grid of tiles that is 5 tall\n    float numTiles = 5.0;\n    st *= numTiles;    \n    vec2 i_st = floor(st);\n    vec2 f_st = fract(st);\n    vec2 tile = f_st;\n    \n    // rotate each tile by the angle, which increases in each column\n    float angle = PI/10.0*(i_st.x+1.0)*sin(iTime);\n    float offset = 0.5;\n    st = rotate2D(tile,angle,offset);\n    \n    // only show the square, we want black space in between each square\n    st *= smoothstep(0.0,aa,st.x) * (smoothstep(1.0,1.0-aa,st.x));\n    st *= smoothstep(0.0,aa,st.y) * (smoothstep(1.0,1.0-aa,st.y));\n    \n    // this section finds the values of the neighbor's overlapping corner\n    angle = PI/10.0*(i_st.x)*sin(iTime);\n    vec2 neighborLeft = f_st + vec2(1.0,0.0);\n    neighborLeft = inverseMatrix(neighborLeft,angle,offset);\n    angle = PI/10.0*(i_st.x+1.0)*sin(iTime);\n    vec2 neighborBelow = f_st + vec2(0.0,1.0);\n    neighborBelow = inverseMatrix(neighborBelow,angle,offset);\n    angle = PI/10.0*(i_st.x+2.0)*sin(iTime);\n    vec2 neighborRight = f_st + vec2(-1.0,0.0);\n    neighborRight = inverseMatrix(neighborRight,angle,offset);\n    angle = PI/10.0*(i_st.x+1.0)*sin(iTime);\n    vec2 neighborAbove = f_st + vec2(0.0,-1.0);\n    neighborAbove = inverseMatrix(neighborAbove,angle,offset);\n    \n    // this is my hacky method of masking in the overlapped section\n    //st *= step(neighborLeft.x+neighborLeft.y, 0.01);\n    //st *= step(neighborBelow.x+neighborBelow.y, 0.01);\n    //st *= step(neighborRight.x+neighborRight.y, 0.01);\n    //st *= step(neighborAbove.x+neighborAbove.y, 0.01);\n    //st += neighborLeft;\n    //st += neighborBelow;\n    //st += neighborRight;\n    //st += neighborAbove;\n    st = max(st,neighborLeft);\n    st = max(st,neighborBelow);\n    st = max(st,neighborRight);\n    st = max(st,neighborAbove);\n    \n    // output\n    vec3 color = vec3(st,0.0);\n    fragColor = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"}]}