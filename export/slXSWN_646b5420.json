{"ver":"0.1","info":{"id":"slXSWN","date":"1700747438","viewed":81,"name":"Rain on glass","username":"Althar","description":"Another attempt at making convincing rain on glass","likes":3,"published":1,"flags":32,"usePreview":0,"tags":["rain"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sX3Rn","filepath":"/media/a/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv","previewfilepath":"/media/ap/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv","type":"video","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // Start off with a grey background\n    vec4 colour = texture(iChannel0, uv);\n    \n    float dropStrength = max(colour.x, colour.y);\n    vec3 normal = normalize(vec3(colour.zw, 1.0 - sqrt(max(colour.z * colour.z + colour.w * colour.w, 1e-5))));\n    \n    vec3 lightDirection = normalize(vec3(-1.0, 1.0, -1.0));\n    float nDotL = max(dot(normal, -lightDirection), 0.98);\n    \n    vec4 mudColour  = vec4(92.0/255.0, 74.0/255.0, 65.0/255.0, 1.0);\n    \n    vec4 dropColour = mix(vec4(1.0), mudColour, 0.05) * nDotL;\n    \n    vec4 background = texture(iChannel1, uv * (1.0 - 0.001 * dropStrength) + normal.xy * 0.1 * dropStrength);\n    \n    vec4 finalColour = background * mix(vec4(1.0), dropColour, dropStrength);    \n\n    // Output to screen\n    fragColor = finalColour;\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Work out the current drop index\n    uint dropIndex = uint(fragCoord.x) + uint(fragCoord.y) * uint(iChannelResolution[0].x);\n    \n    // Only support a certain number of drops\n    if (dropIndex > cMaxDrops)\n    {\n        discard;\n    }\n    \n    // Read the buffer\n    vec4 buffer = texelFetch(iChannel0, ivec2(fragCoord.xy), 0);\n    \n    // A drop\n    Drop drop;\n    \n    // Decode the drop\n    decodeDrop(buffer, drop);\n    \n    // Spawn, or update drop position\n    if (iFrame == 0 || drop.mass <= 0.0)\n    {\n        // Spawn drop\n        //if (iMouse.z > 0.0)\n        //{\n        //    drop.position = iMouse.xy;\n        //}\n        //else\n        {\n            //uint seed = uint( iTime );\n            uint index  = uint((cos(float(dropIndex) + iTime) * 0.5 + 0.5) * iResolution.x * iResolution.y);\n            uint x      = index % uint( iResolution.x );\n            uint y      = index / uint( iResolution.x );\n            \n            drop.position = vec2(x, y);\n            \n\n            drop.position = vec2(x, y);\n        }\n        \n        drop.velocity = vec2(0.0, 0.0);\n        drop.mass   = mix(2.0, 8.0, (cos(iTime + float(dropIndex)) * 0.5 + 0.5));\n    }\n    else\n    {\n       // Move drop\n       drop.position += drop.velocity * cSimulationSpeed * iTimeDelta;\n        \n       // Absorb\n       for (uint otherDropIndex = 0u ; otherDropIndex < cMaxDrops ; ++otherDropIndex)\n       {\n           // Don't want to interact with oneself\n           if (otherDropIndex != dropIndex)\n           {\n                // Work out the buffer coordinate\n                ivec2 bufferCoord = ivec2(otherDropIndex % uint(iChannelResolution[0].x), otherDropIndex / uint(iChannelResolution[0].x));\n\n                // Read the buffer\n                vec4 otherBuffer = texelFetch(iChannel0, bufferCoord, 0);\n\n                // A drop\n                Drop otherDrop;\n\n                // Decode the drop\n                decodeDrop(otherBuffer, otherDrop);\n\n                // Compute separation vector\n                vec2 delta = (otherDrop.position - drop.position);\n                \n                // Compute attraction force towards the other drop - drops need to be touching\n                float minRadius = (otherDrop.mass + drop.mass);\n                bool bIntersect = dot(delta, delta) < (minRadius * minRadius);\n                \n                if (bIntersect)\n                {\n                    // Kill or absorb\n                    if (otherDrop.mass < drop.mass && drop.mass < cMaxMass)\n                    {\n                        drop.mass += min(otherDrop.mass, 0.01 * iTime);\n                    }\n                    else if (drop.mass < otherDrop.mass)// && otherDrop.mass < cMaxMass)\n                    {\n                        drop.mass -= min(drop.mass, 0.01 * iTime);\n                    }\n                    \n                    drop.mass = max(drop.mass, 0.0);\n                }\n           }\n       }\n           \n       // Kill off drop\n       if (drop.position.x < -drop.mass * 0.5 || drop.position.x > iResolution.x - drop.mass * 0.5 ||\n           drop.position.y < -drop.mass * 0.5 || drop.position.y > iResolution.y - drop.mass * 0.5)\n       {\n           drop.mass = 0.0;\n       }\n    }\n    \n    // Encode back\n    encodeDrop(drop, buffer);\n   \n    // Done - write back\n    fragColor = buffer;\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"// Simulation\nconst uint cMaxDrops = 256u;\nconst float cVelocityEncodingFactor = 10000.0;\n\nconst float cSimulationSpeed = 1.0;\n\nconst float cGravityStrength  = 1.0;\nconst float cAffinityStrength = 1.0;\n\n// Fluid properties\nconst float cCriticalMass = 8.0;\nconst float cMaxMass      = 200.0;\nconst float cMaxRadius    = 15.0;\n\n// Structure defining a single drop\nstruct Drop\n{\n    vec2 position;\n    vec2 velocity;\n    float mass;\n};\n\n// Encodes the drop\nvoid encodeDrop(in Drop drop, inout vec4 colour)\n{\n    colour.xy = drop.position;\n    colour.z  = uintBitsToFloat(packSnorm2x16(drop.velocity / cVelocityEncodingFactor));\n    colour.w  = drop.mass;\n}\n\n// Decodes the drop\nvoid decodeDrop(in vec4 colour, inout Drop drop)\n{\n    drop.position = colour.xy;\n    drop.velocity = unpackSnorm2x16(floatBitsToUint(colour.z)) * cVelocityEncodingFactor;\n    drop.mass   = colour.w;\n}\n\n// Returns a random number\nfloat random( vec2 p )\n{\n    vec2 K1 = vec2(\n        23.14069263277926, // e^pi (Gelfond's constant)\n        2.665144142690225  // 2^sqrt(2) (Gelfondâ€“Schneider constant)\n    );\n    return fract( cos( dot(p,K1) ) * 12345.6789 );\n}\n\n// SDF of a circle\nfloat circleSDF(in vec2 centre, in float radius, vec2 fragCoord)\n{\n    float dst = radius / length(fragCoord - centre);\n    return dst;\n}\n\n// Draws a single drop\nvoid drawDrop(in Drop drop, in uint dropIndex, in vec2 fragCoord, inout vec4 colour)\n{\n    float radius = min(drop.mass, cMaxRadius);\n    float angleA = float(dropIndex);\n    float angleB = 2.0 * float(dropIndex);\n    vec2 pinchA = drop.position + vec2(cos(angleA), sin(angleA)) * radius;\n    vec2 pinchB = drop.position + vec2(cos(angleB), sin(angleB)) * radius;\n    float total = circleSDF(drop.position, radius, fragCoord) + clamp(1.0 - dot(drop.velocity, drop.velocity) / 2.0, 0.0, 1.0) * (circleSDF(pinchA, radius * 0.5, fragCoord) + circleSDF(pinchB, radius * 0.5, fragCoord));\n    float mask  = total > 2.0 ? 1.0 : 0.0;\n    \n    vec3 normal = normalize(vec3(fragCoord - drop.position, 10.0));\n    \n    // Drop data\n    vec4 dropColour = vec4(1.0, 0.0, -normal.x, -normal.y);\n    \n    colour = mix(colour, dropColour, mask);\n}\n\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Work out the current drop index\n    uint dropIndex = uint(fragCoord.x) + uint(fragCoord.y) * uint(iChannelResolution[0].x);\n    \n    // Only support a certain number of drops\n    if (dropIndex > cMaxDrops)\n    {\n        discard;\n    }\n    \n    // Read the buffer\n    vec4 buffer = texelFetch(iChannel0, ivec2(fragCoord.xy), 0);\n    \n    // A drop\n    Drop drop;\n    \n    // Decode the drop\n    decodeDrop(buffer, drop);\n    \n    // Update velocity\n    {\n       // Compute velocity\n       drop.velocity = vec2(0.0);\n       \n       // Mass factor - to simulate stickiness of a drop to the surface\n       float MassFactor = max(drop.mass - cCriticalMass, 0.0) / (0.005 * cMaxMass);\n       \n       // Gravity\n       drop.velocity += vec2(0.0, -1.0) * MassFactor * cGravityStrength;\n       \n       // Wind\n       //drop.velocity += (iMouse.xy - (iResolution.xy * 0.5)) / 1000.0 * MassFactor;\n       \n       // Random perpendicular component\n       drop.velocity += length(drop.velocity) > 0.0 ? cAffinityStrength * 0.25 * MassFactor * normalize(vec2(-drop.velocity.y, drop.velocity.x)) * cos(20.0 * (iTime + float(dropIndex) + drop.position.x + drop.position.y)) : drop.velocity;\n       \n       // Collide - attract\n       for (uint otherDropIndex = 0u ; otherDropIndex < cMaxDrops ; ++otherDropIndex)\n       {\n           // Don't want to interact with oneself\n           if (otherDropIndex != dropIndex)\n           {\n                // Work out the buffer coordinate\n                ivec2 bufferCoord = ivec2(otherDropIndex % uint(iChannelResolution[0].x), otherDropIndex / uint(iChannelResolution[0].x));\n\n                // Read the buffer\n                vec4 otherBuffer = texelFetch(iChannel0, bufferCoord, 0);\n\n                // A drop\n                Drop otherDrop;\n\n                // Decode the drop\n                decodeDrop(otherBuffer, otherDrop);\n\n                // Compute separation vector\n                vec2 delta = (otherDrop.position - drop.position);\n                \n                // Compute attraction force towards the other drop - drops need to be touching\n                float maxRadius = (otherDrop.mass + drop.mass) * 0.5;\n                bool bTouching  = dot(delta, delta) < (maxRadius * maxRadius);\n\n                if (bTouching)\n                {\n                    vec2 attractionForce = normalize(delta) * (otherDrop.mass) / max(dot(delta, delta), 0.0);\n                    drop.velocity += 20.0 * attractionForce;\n                }\n               \n           }\n       }\n       \n       // Slowly dry\n       drop.mass -= (cCriticalMass * 0.005 * iTimeDelta);\n    }\n    \n    // Encode back\n    encodeDrop(drop, buffer);\n    \n    // Done - write back\n    fragColor = buffer;\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // Start off with a grey background\n    vec4 oldColour = texture(iChannel0, uv);\n    \n    // New colour\n    vec4 colour = vec4(0.0);\n\n    // Iterate through every particle\n    for (uint dropIndex = 0u ; dropIndex < cMaxDrops ; ++dropIndex)\n    {\n        // Work out the buffer coordinate\n        ivec2 bufferCoord = ivec2(dropIndex % uint(iChannelResolution[0].x), dropIndex / uint(iChannelResolution[0].x));\n\n        // Read the buffer\n        vec4 buffer = texelFetch(iChannel1, bufferCoord, 0);\n\n        // A drop\n        Drop drop;\n\n        // Decode the drop\n        decodeDrop(buffer, drop);\n\n        // Draw the drop\n        drawDrop(drop, dropIndex, fragCoord, colour);\n    }\n\n    // Output to screen\n    fragColor = vec4(colour.x, min(oldColour.y + colour.x, 1.0), mix(oldColour.zw, colour.zw, colour.x).xy);\n}","name":"Buffer C","description":"","type":"buffer"},{"inputs":[{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // Start off with a grey background\n    vec4 colour = texture(iChannel0, uv);\n\n    // Output to screen\n    fragColor = vec4(colour.x, max(colour.y - 0.2 * iTimeDelta, 0.0), mix(colour.zw, vec2(0.0), 4.0 * iTimeDelta));\n}","name":"Buffer D","description":"","type":"buffer"}]}