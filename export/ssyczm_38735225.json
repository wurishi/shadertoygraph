{"ver":"0.1","info":{"id":"ssyczm","date":"1654607723","viewed":119,"name":"2D Infinite shadow test","username":"amagitakayosi","description":"Infinite shadow can be drawn easily if the shape is defined as SDF.","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["2d","sdf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define SHADOW_ANGLE -50.0\n#define SHADOW_COLOR vec3(1, 0, 0);\n#define LIGHT_DIR vec2(1, 1)\n#define LIGHT_INTENSITY 0.3\n\n#define EPS 0.01\n#define ITER 30\n\nvec2 rot(vec2 uv, float t) {\n    float c = cos(t), s = sin(t);\n    return mat2(c, -s, s, c) * uv;\n}\n\nfloat sdCircle(vec2 p, float radius) {\n    return length(p) - radius;\n}\n\n// Copied from iq's article\nfloat sdStar5(in vec2 p, in float r, in float rf)\n{\n    const vec2 k1 = vec2(0.809016994375, -0.587785252292);\n    const vec2 k2 = vec2(-k1.x,k1.y);\n    p.x = abs(p.x);\n    p -= 2.0*max(dot(k1,p),0.0)*k1;\n    p -= 2.0*max(dot(k2,p),0.0)*k2;\n    p.x = abs(p.x);\n    p.y -= r;\n    vec2 ba = rf*vec2(-k1.y,k1.x) - vec2(0,1);\n    float h = clamp( dot(p,ba)/dot(ba,ba), 0.0, r );\n    return length(p-ba*h) * sign(p.y*ba.x-p.x*ba.y);\n}\n\nfloat map(vec2 p) {\n    p = rot(p, iTime);\n    return sdStar5(p, 0.4, 0.5);\n    //return sdCircle(p, 0.3);\n}\n\nvec2 getNormal(vec2 p) {\n    vec2 d = vec2(1, 0) * EPS;\n    return normalize(vec2(\n        map(p + d.xy) - map(p - d.xy),\n        map(p + d.yx) - map(p - d.yx)\n    ));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 p = uv * 2. - 1.;\n    p.x *= iResolution.x / iResolution.y; // fix aspect ratio\n\n    vec3 col;\n    \n    // Draw BG\n    float a = floor((uv.x - uv.y * 0.5 - iTime * .08) * 8.) - iTime * 2.;\n    col = vec3(sin(a), sin(a + 2.), sin(a + 3.)) * 0.2 + 0.7;\n    \n    // Draw infinite shadow by raymarching\n    float angle = radians(SHADOW_ANGLE);\n    vec2 dir = -vec2(cos(angle), sin(angle));\n    float d;\n    float t = 0.;\n    vec2 p2;\n    \n    for (int i = 0; i < ITER; i++) {\n        p2 = p + dir * t;\n        d = map(p2);\n        if (d < EPS) {\n            vec2 n = getNormal(p2);\n            float shade = dot(n, normalize(LIGHT_DIR));\n            col = SHADOW_COLOR;\n            col *= 1. + shade * LIGHT_INTENSITY;\n        }\n        t += d;\n    }    \n\n    // Draw foreground\n    d = map(p);\n    float inside = step(d, EPS);\n    if (d < EPS) {\n        col = vec3(step(d, -EPS));\n    }    \n    \n    // vignette\n    col -= smoothstep(0.5, 3.0, length(p));\n    \n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}