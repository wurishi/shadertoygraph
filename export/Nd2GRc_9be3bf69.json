{"ver":"0.1","info":{"id":"Nd2GRc","date":"1619878101","viewed":1017,"name":"New York City VI (torso)","username":"shau","description":"trying to emulate H.R. Giger (kind of)\n[url]https://wikioo.org/paintings.php?refarticle=A25TAE&titlepainting=hr%20giger%20newyorkcity%20VI%20torso&artistname=H.R.%20Giger[/url]","likes":19,"published":1,"flags":0,"usePreview":0,"tags":["3d","reproduction","giger"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Created by SHAU - 2021\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//-----------------------------------------------------\n\n#define R iResolution.xy\n#define ZERO (min(iFrame,0))\n#define EPS 0.001\n#define FAR 100.0\n#define T iTime\n\n#define BODY 1.0\n#define HELMET 2.0\n#define METAL 3.0\n#define WALL 4.0\n#define WIRE 5.0\n\n//Fabrice - compact rotation\nmat2 rot(float x) {return mat2(cos(x), sin(x), -sin(x), cos(x));}\n\n//Dave Hoskins - hash without sin\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\n//Shane IQ\nfloat n3D(vec3 p) {    \n\tconst vec3 s = vec3(7, 157, 113);\n\tvec3 ip = floor(p); \n    p -= ip; \n    vec4 h = vec4(0., s.yz, s.y + s.z) + dot(ip, s);\n    p = p * p * (3. - 2. * p);\n    h = mix(fract(sin(h) * 43758.5453), fract(sin(h + s.x) * 43758.5453), p.x);\n    h.xy = mix(h.xz, h.yw, p.y);\n    return mix(h.x, h.y, p.z);\n}\n\n//Distance functions IQ\nfloat smin(float a, float b, float k) {\n\tfloat h = clamp(0.5 + 0.5 * (b - a) / k, 0., 1.);\n\treturn mix(b, a, h) - k * h * (1. - h);\n}\n\nfloat smax(float a, float b, float k) {\n\tfloat h = clamp( 0.5 + 0.5 * (b - a) / k, 0.0, 1.0 );\n\treturn mix(a, b, h) + k * h * (1.0 - h);\n}\n\nvec3 opRepLim(vec3 p, float c, vec3 l)\n{\n    return p-c*clamp(round(p/c),-l,l);\n}\n\nfloat sdBox(vec3 p, vec3 b)\n{\n    vec3 q = abs(p) - b;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdCapsule(vec3 p, float h, float r)\n{\n    p.x -= clamp(p.x,0.0,h);\n    return length(p) - r;\n}\n\nfloat sdTorus(vec3 p, vec2 t) \n{\n    vec2 q = vec2(length(p.yz) - t.x, p.x);\n    return length(q) - t.y;\n}\n\nfloat sdEllipsoid(vec3 p, vec3 r)\n{\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n}\n\nfloat dot2(vec3 v) { return dot(v,v); }\nfloat sdRoundCone(vec3 p, vec3 a, vec3 b, float r1, float r2)\n{\n    // sampling independent computations (only depend on shape)\n    vec3  ba = b - a;\n    float l2 = dot(ba,ba);\n    float rr = r1 - r2;\n    float a2 = l2 - rr*rr;\n    float il2 = 1.0/l2;\n    \n    // sampling dependant computations\n    vec3 pa = p - a;\n    float y = dot(pa,ba);\n    float z = y - l2;\n    float x2 = dot2( pa*l2 - ba*y );\n    float y2 = y*y*l2;\n    float z2 = z*z*l2;\n\n    // single square root!\n    float k = sign(rr)*rr*rr*x2;\n    if( sign(z)*a2*z2 > k ) return  sqrt(x2 + z2)        *il2 - r2;\n    if( sign(y)*a2*y2 < k ) return  sqrt(x2 + y2)        *il2 - r1;\n                            return (sqrt(x2*a2*il2)+y*rr)*il2 - r1;\n}\n\n//A useful little function from IQ\n//https://iquilezles.org/articles/functions\nfloat almostIdentity(float x, float m, float n) {\n    if (x > m) return x;\n    float a = 2.0 * n - m;\n    float b = 2.0 * m - 3.0 * n;\n    float t = x / m;\n    return (a * t + b) * t * t + n;\n}\n\nfloat boxIntersection(vec3 ro, vec3 rd, vec3 boxSize) \n{\n    vec3 m = 1.0/rd; // can precompute if traversing a set of aligned boxes\n    vec3 n = m*ro;   // can precompute if traversing a set of aligned boxes\n    vec3 k = abs(m)*boxSize;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n    if( tN>tF || tF<0.0) return -1.0; // no intersection\n    return tN;\n}\n\nvec2 near(vec2 a, vec2 b)\n{\n    return mix(a,b,step(b.x,a.x));\n}\n\nfloat SXY(float p, float a)\n{\n    return smoothstep(-16.0,-5.0,p)*smoothstep(a,-5.0,p);\n}\n\nvec2 map(vec3 p) \n{\n    //wires\n    //1\n    vec3 q = p - vec3(-2.2,-12.0,-3.9);\n    q.yz *= rot(0.4);\n    float wire = max(sdTorus(q.zyx,vec2(2.6,0.1)),-q.x);\n    q.y += cos(q.x*0.6)*0.8;\n    q.z -= smoothstep(0.0,-6.0,q.x)*2.0;\n    wire = min(wire, sdCapsule(q - vec3(-10.0,-1.8,0.0),10.0,0.1));\n    //2\n    q = p - vec3(-3.8,-12.0,-3.9);\n    q.yz *= rot(0.6);\n    wire = min(wire,max(max(sdTorus(q.zyx,vec2(3.4,0.1)),-q.x),q.y));\n    q.y += cos(q.x*0.6)*0.6;\n    q.z -= smoothstep(0.0,-4.0,q.x)*3.0;\n    wire = min(wire, sdCapsule(q - vec3(-10.0,-2.8,0.0),10.0,0.1));\n    //wall\n    float sxy = SXY(p.y,-2.0),\n          h1 = hash11(floor(p.x*1.7)),\n          wx = fract(p.x*1.7),\n          wall = smin(sdBox(p, vec3(1100.0,100.0,1.8 + sin((p.y + h1)*(12.0+h1*3.0))*0.04)),\n                      sdBox(vec3(wx,p.yz), vec3(h1*0.2,100.0,2.0))-0.04,0.3);\n    //bullets\n    q = p - vec3(2.4,0.0,-5.2);\n    q.z += sxy*1.6 - smoothstep(-16.0,-10.0,p.y)*2.0;\n    q.x -= sxy*0.4;\n    q.xz *= rot(sxy*0.4 + smoothstep(-5.0,5.0,p.y));\n    q.y = mod(q.y,0.4) - 0.2;\n    float bullets = min(sdBox(q,vec3(0.6,0.1,0.1)) - 0.06, \n                        sdBox(q - vec3(1.0 + sxy*0.2,0.0,-0.3),vec3(0.6,0.1,0.1)) - 0.06);\n    bullets = min(bullets, sdBox(q - vec3(2.0 + sxy*0.4,0.0,-0.6),vec3(0.6,0.1,0.1)) - 0.06);\n    bullets = min(bullets, sdBox(q - vec3(3.0 + sxy*0.6,0.0,-0.8),vec3(0.6,0.1,0.1)) - 0.06);\n    //helmet\n    float helmet =    min(sdEllipsoid(p - vec3(-2.4,-2.0,-3.8),vec3(0.8,2.2,1.8)),  \n                          sdEllipsoid(p - vec3(-3.0,-2.0,-3.8),vec3(0.8,1.0,1.0)));\n    helmet = smin(helmet, sdTorus(p - vec3(-3.1,-2.0,-3.8), vec2(1.1,0.2)),0.2);\n    helmet = smin(helmet, sdEllipsoid(p - vec3( 0.0,-5.5,-2.6),vec3(4.8,2.2,1.9)),0.6);\n    //helmet = max(helmet, -sdEllipsoid(p - vec3(-2.4,-2.0,-3.8),vec3(0.6,1.8,1.4)));\n    p.x = abs(p.x);\n    helmet = max(helmet, -(length(p - vec3(4.6,-7.4,-2.6)) - 2.9));\n    helmet = max(helmet, -sdBox(p, vec3(2.0,10.0,10.0)));\n    helmet = smax(helmet,-(sdBox(p - vec3(0.0,-2.2,0.0),vec3(2.3,1.8,8.0))), 0.3);\n    //body\n    float torso = smin(min(sdEllipsoid(p - vec3(0.0,-5.3, -2.6),vec3(3.5,2.0,1.9)),\n                       max(sdEllipsoid(p - vec3(0.0,-5.3, -2.6),vec3(3.5,7.4,1.9)),p.y + 5.3)),\n                       min(sdEllipsoid(p - vec3(0.0,-16.0,-2.6),vec3(3.5,1.8,2.0)),\n                       max(sdEllipsoid(p - vec3(0.0,-16.0,-2.6),vec3(3.5,4.8,2.0)) , -(p.y + 16.0))),\n                  1.6);\n    //shoulders\n    torso = smin(torso, sdEllipsoid(p - vec3(2.8,-5.5, -2.4),vec3(1.2,1.76,1.1)),0.8);\n    //pipes\n    q = p - vec3(10.0,-9.8,-4.9-p.y*0.1);\n    q.y += smoothstep(1.0+sxy*1.0,6.0,p.x)*2.0;\n    q.z -= smoothstep(1.0+sxy*1.0,6.0,p.x)*2.0;\n    q = opRepLim(q,0.6,vec3(0.0,4.0,0.0));\n    float metal = sdCapsule(q,-8.9+sxy,0.2),\n          socket = smax(length(q - vec3(-9.2+sxy,0.0,0.0)) - 0.3, -metal, 0.2);\n    torso = smin(torso,socket,0.3);\n    //neck\n    torso = smin(torso,sdRoundCone(p,vec3(0.0,-5.0,-2.4),vec3(0.0,0.0,-1.64),1.4,1.1),0.4);\n    //backbone\n    sxy = SXY(p.y,-2.0);\n    q = p;\n    q.y -= 0.2 / (1.0 + abs(q.x)*abs(q.x));\n    torso -= (sin(q.y*10.0) + 1.0)\n            * sxy\n            * (smoothstep(0.8+sxy,0.0+sxy,q.x) * smoothstep(sxy-0.2,0.1+sxy,q.x)*0.04 +\n               smoothstep(0.4,0.0,q.x)*0.04 + smoothstep(1.4,0.0,q.x)*0.02 +\n               /*- n3D(p*vec3(1.3,6.1,5.9))*0.04 + */\n               smoothstep(sxy*3.8,0.0,q.x)*0.04) * step(q.x,0.5 + sxy);\n\n    //skin peel\n    torso -= smoothstep(0.5+sxy,0.6+sxy,p.x)*0.08;    \n    //bum\n    p.x = almostIdentity(p.x,0.2,0.04);\n    \n    q = p - vec3(1.9,-16.0,-2.8);\n    q.xy *= rot(0.6);\n    torso = smin(torso, sdEllipsoid(q,vec3(2.2,2.8,2.4)),0.5);\n    q.xz *= rot(1.0);\n    \n    helmet = smin(helmet,sdTorus(q + vec3(-3.0,-8.6,4.7),vec2(1.5,0.54+sin(p.y*24.0)*0.01)),0.2);\n    \n    //v\n    torso += smoothstep(0.4,0.0,p.x+p.y+15.4)*0.04;\n    //box\n    torso = smax(torso,-sdBox(p - vec3(0.0,-18.21,-2.8),vec3(0.1,2.0,4.0)),0.6);\n    //head\n    torso = smin(torso,\n                 smin(sdEllipsoid(p - vec3(0.0,0.0,-0.8),vec3(0.8,2.8,2.4)),\n                      sdEllipsoid(p - vec3(0.8,0.0,-0.4),vec3(1.1,2.6,2.6)),0.4),\n                 0.4);\n    \n    vec2 nr = near(vec2(torso,BODY),vec2(helmet,HELMET));\n    nr = near(nr,vec2(min(metal,bullets),METAL));\n    nr = near(nr,vec2(wire,WIRE));\n    return near(nr,vec2(wall,WALL));\n}\n\nfloat mapD(vec3 p, float sid) \n{\n    float h = map(p).x;\n    if (sid==WALL)\n    {\n        h += (n3D(p*vec3(11.1,1.7,9.3)) + n3D(p*vec3(1.9,12.3,9.1)))*0.02;\n    }\n    if (sid==BODY)\n    {\n        //head\n        vec3 q = p - vec3(0.0,0.0,-0.4);\n        float a = atan(q.z,q.y)/6.283185;\n        float ia = floor(a*16.0)/16.0*6.283185;\n        q.yz *= rot(ia);\n        h += smoothstep(0.1,0.0,abs(q.z))*0.06*\n             smoothstep(0.0,2.0,abs(q.x))* \n             smoothstep(2.8,2.6,length(q.yz));//*\n             //smoothstep(0.5,1.2,length(q.yz));\n             \n        \n        //back\n        float sxy = SXY(p.y,-2.0);\n        p.x = abs(p.x);\n        \n        //vertical\n        h += (smoothstep(0.0,0.1,abs(p.x-1.0-sxy)) +\n              smoothstep(0.0,0.1,abs(p.x-1.2-sxy*2.0)))*0.04*\n              smoothstep(2.0,-6.0,p.y)*\n              smoothstep(-15.0,-10.0,p.y);\n        //horizontal\n        h += sin(p.y*20.0)*0.04 * smoothstep(0.0,-0.1,p.x-1.2-sxy*2.0)*\n                                  smoothstep(-0.1,0.0,p.x-1.1-sxy*1.0)*\n                                  smoothstep(-6.0,-10.0,p.y)*\n                                  smoothstep(-15.0,-10.0,p.y);                         \n        h += sin(p.y*20.0)*0.04 * smoothstep(-0.1,0.0,p.x-1.3-sxy*2.0)*\n                                  smoothstep(0.0,-1.4,p.x-2.6) *\n                                  smoothstep(-10.0,-12.0,p.y)*\n                                  smoothstep(-15.0,-12.0,p.y);\n        //spine \n        h -= pow(n3D(p*vec3(7.7,15.1,14.3)),2.0)*0.02*step(p.x-0.5-sxy,0.0)*smoothstep(6.0,0.0,abs(p.y + 8.0));\n        h -= n3D(p*vec3(1.9,4.1,6.3))*0.064*step(p.x-0.5-sxy,0.0)*smoothstep(5.0,0.0,abs(p.y + 6.0));\n    }\n    if (sid==HELMET)\n    {\n        vec3 q = p - vec3(-2.4,-2.0,-3.8);\n        float a = atan(q.z,q.y)/6.283185;\n        float ia = floor(a*16.0)/16.0*6.283185;\n        q.yz *= rot(ia);\n        h += smoothstep(0.0,0.1,abs(q.z))*0.06*\n             smoothstep(0.8,1.2,length(q.yz))*\n             smoothstep(-2.4,-2.8,p.x)*\n             smoothstep(-5.0,-4.0,p.y);\n    }\n    return h;\n}\n\nvec3 normal(vec3 p, float sid) \n{  \n    vec4 n = vec4(0.0);\n    for (int i=ZERO; i<4; i++) \n    {\n        vec4 s = vec4(p, 0.0);\n        s[i] += EPS;\n        n[i] = mapD(s.xyz,sid);\n    }\n    return normalize(n.xyz-n.w);\n}\n\n//IQ - https://iquilezles.org/articles/raymarchingdf\nfloat AO(vec3 p, vec3 n) \n{\n    float ra = 0., w = 1., d = 0.;\n    for (int i=ZERO; i<5; i++){\n        d = float(i) / 5.;\n        ra += w * (d - map(p + n*d).x);\n        if (ra>1.) break;\n        w *= .5;\n    }\n    return 1. - clamp(ra,0.,1.);\n}\n\n//IQ soft shadows\n//https://www.shadertoy.com/view/lsKcDD\nfloat calcSoftshadow(vec3 ro, vec3 rd, float mint, float tmax, int technique )\n{\n\tfloat res = 1.0;\n    float t = mint;\n    float ph = 1e10; // big, such that y = 0 on the first iteration\n    \n    for( int i=0; i<60; i++ )\n    {\n\t\tfloat h = map( ro + rd*t ).x;\n\n        // traditional technique\n        if( technique==0 )\n        {\n        \tres = min( res, 10.0*h/t );\n        }\n        // improved technique\n        else\n        {\n            // use this if you are getting artifact on the first iteration, or unroll the\n            // first iteration out of the loop\n            //float y = (i==0) ? 0.0 : h*h/(2.0*ph); \n\n            float y = h*h/(2.0*ph);\n            float d = sqrt(h*h-y*y);\n            res = min( res, 10.0*d/max(0.0,t-y) );\n            ph = h;\n        }\n        \n        t += h;\n        \n        if( res<0.0001 || t>tmax ) break;\n        \n    }\n    res = clamp( res, 0.0, 1.0 );\n    return 0.001 + res*res*(3.0-2.0*res);\n}\n\nvec2 march(vec3 ro, vec3 rd) \n{\n    float t = 0.0, id = 0.0;   \n    for (int i=ZERO; i<120; i++)\n    {\n        vec2 ns = map(ro + rd*t);\n        if (ns.x<EPS)\n        {\n            id = ns.y;\n            break;\n        }\n        t += ns.x*0.8;\n        if (t>FAR) \n        {\n            t = -1.0;\n            break;\n        }\n        \n    }\n    return vec2(t,id);\n}\n\nvec3 camera(vec2 uv, vec3 ro, vec3 la, float fl) \n{\n    vec3 fwd = normalize(la-ro),\n         rgt = normalize(vec3(fwd.z,0.0,-fwd.x));\n    return normalize(fwd + fl*uv.x*rgt + fl*uv.y*cross(fwd, rgt));\n}\n\nfloat BXY(float py, float a, float b, float c, float d, float e)\n{\n    return smoothstep(b,a,py) +\n           smoothstep(b,c,py) - \n           smoothstep(c,d,py) +\n           smoothstep(d,e,py);\n}\n\nvoid mainImage(out vec4 C, vec2 U)\n{\n    vec3 pc = vec3(0),\n         la = vec3(0,-8.0,0),\n         lp = vec3(-8,20.0,-10.0),\n         ro = vec3(0,-8.0,-20);\n    vec2 uv = (U - R*.5) / R.y;\n    \n    ro.xz *= rot(sin(T*0.07)*0.18);\n    ro.yz *= rot(sin((T-0.7)*0.04)*0.14);\n    vec3 rd = camera(uv,ro,la,1.0);\n    \n    float bounds = boxIntersection(ro,rd,vec3(8.0,20.0,6.0));\n    if (bounds>0.0)\n    {\n        ro += rd*bounds;\n        vec2 s = march(ro,rd);\n        if (s.x>0.0)\n        {\n            vec3 p = ro + rd*s.x;\n            vec3 n = normal(p, s.y);\n            vec3 ld = normalize(lp - p);\n            float diff = max(0.0,dot(ld,n));\n            float ao = AO(p,n);\n            float spec = pow(max(dot(reflect(-ld,n),-rd),0.0),4.0);\n            float nz = n3D(p*vec3(1.7,5.7,7.9));\n            float nzy = n3D(p*vec3(13.9,1.1,15.8));\n            float sh = calcSoftshadow(p + n*0.003,ld,EPS,FAR,1);\n            if (s.y==BODY)\n            {\n                float sxy = SXY(p.y,-2.0);\n                //back\n                vec3 bc = mix(vec3(0.01),vec3(0.4),smoothstep(-1.0,2.0,p.y));\n                bc = mix(bc,vec3(0.3),nzy*smoothstep(-3.0,1.0,p.y));\n                bc = mix(bc,vec3(0.4),smoothstep(-12.0,-14.0,p.y));\n                bc *= diff;\n                bc += vec3(0.04)*pow(spec,4.0)*smoothstep(2.0,0.0,abs(p.y + 5.0));\n                //skin\n                float sclpb = BXY(p.y,-16.0,-10.0,-5.0,-2.0,1.0);\n                vec3 sc = mix(vec3(0.2),vec3(0.01),nzy*2.0*(1.0 - sclpb));\n                sc += vec3(0.3)*smoothstep(-13.6,-15.0,p.y); //bum highlight\n                sc += vec3(0.4)*smoothstep(1.2,0.0,abs(p.y + 5.0)); //shoulder highlight                \n                sc *= diff;\n                sc += vec3(0.2)*spec;\n                \n                pc = mix(bc,sc,smoothstep(0.1,0.2,abs(p.x)-0.5-sxy*1.0));\n                pc *= smoothstep(-12.0,-16.0,p.y) + smoothstep(-12.0,-4.0,p.y);\n                pc += vec3(0.3)*smoothstep(0.0,2.0,p.y); //head highlight\n            }\n            if (s.y==WALL)\n            {\n                pc = vec3(0.01)*diff + vec3(0.1)*pow(spec,4.0);\n            }\n            if (s.y==METAL)\n            {\n                pc = mix(vec3(0.0),vec3(0.04)+smoothstep(2.0,0.0,abs(p.y+4.0))*0.4,pow(nz,4.0))*diff; \n                pc += vec3(0.2)*pow(spec,4.0);\n                pc += vec3(1.0)*pow(spec,16.0);\n                pc *= smoothstep(6.0,1.0,p.x);\n            }\n            if (s.y==HELMET)\n            {\n                vec3 q = p - vec3(-2.4,-2.0,-3.8);\n                vec3 bc = mix(vec3(0.8),vec3(0.1),n3D(p*3.0));\n                vec3 cc = mix(vec3(0.0),vec3(0.1),pow(nz,2.0));\n                pc = mix(cc,bc,smoothstep(0.9,1.0,length(q.yz)));\n                pc *= diff;\n                pc += vec3(0.2)*pow(spec,4.0);\n            }\n            if (s.y==WIRE)\n            {\n                float lt = length(p - vec3(0.0,-12.0,-3.2));\n                pc = mix(vec3(0.001),vec3(0.4),smoothstep(1.6,2.4,lt))*diff;\n                pc += vec3(0.2)*pow(spec,4.0)*smoothstep(-1.0,-2.0,p.x);\n            }\n            pc *= ao*sh;\n            pc *= smoothstep(8.0,2.0,abs(p.x));\n        }\n        \n    }\n    pc = pow(pc, vec3(0.3545));\n    pc *= 1. + sin(uv.y*800. + T)*0.02;\n    pc *= 1. + sin(uv.x*800. + T)*0.02; \n    \n    C = vec4(pc,1.0);\n}","name":"Image","description":"","type":"image"}]}