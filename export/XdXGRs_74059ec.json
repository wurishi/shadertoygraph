{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[{"channel":0,"type":"texture","id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"code":"// Hazel Quantock - 16/08/2013\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// constants, don't edit\nconst float tau = 6.28318530717958647692;\nfloat Noise( in vec3 x );\n\n\n\n// ------- EDIT THESE THINGS! -------\n\n// Camera (also rotated by mouse)\nconst vec3 CamPos = vec3(0,20.0,-20.0);\nconst vec3 CamLook = vec3(0,0,0);\n\n// Lights\nconst vec3 lightDir = vec3(0,1,1); // used for shadow rays\nconst vec3 fillLightDir = vec3(0,0,-1);\nconst vec3 lightColour = vec3(1,1,1);\nconst vec3 fillLightColour = vec3(.05,.15,.25);\n\n// Shape\n// This should return continuous positive values when outside and negative values inside,\n// which roughly indicate the distance of the nearest surface.\nfloat Isosurface( vec3 pos )\n{\n\tfloat f = pos.y*.2-1.5;\n\n\tpos.z += iTime*.5;\n\tpos /= 2.0;\n\tf += Noise(pos/3.0)*3.0; // I tried putting this in a for loop but it vanished. Faster like this anyway\n\tf += Noise(pos/1.0)*1.0;\n\tf += Noise(pos*3.0)/3.0;\n\t//f += Noise(pos*9.0)/9.0;\n\t//f += Noise(pos*27.0)/27.0;\n\t\n\treturn f;\n}\n\n// Colour\nvec3 Shading( vec3 pos, vec3 norm, float shadow )\n{\n\tvec3 albedo = mix( vec3(1,.8,.7), vec3(.5,.3,.2), Noise(pos*vec3(1,10,1)) );\n\n\tvec3 l = shadow*lightColour*max(0.0,dot(norm,lightDir));\n\tvec3 fl = fillLightColour*(dot(norm,fillLightDir)*.5+.5);\n\t\n\treturn albedo*(l+fl);\n}\n\n\n// Precision controls\nconst float epsilon = .003;\nconst float normalPrecision = .1;\nconst float shadowOffset = .1;\nconst int traceDepth = 100; // takes time\nconst float drawDistance = 100.0;\n\n\n\n// ------- BACK-END CODE -------\n\nfloat Noise( in vec3 x )\n{\n    vec3 p = floor(x.xzy);\n    vec3 f = fract(x.xzy);\n\tf = f*f*(3.0-2.0*f);\n//\tvec3 f2 = f*f; f = f*f2*(10.0-15.0*f+6.0*f2);\n\n//cracks cause a an artefact in normal, of course\n\t\n\t// there's an artefact because the y channel almost, but not exactly, matches the r channel shifted (37,17)\n\t// this artefact doesn't seem to show up in chrome, so I suspect firefox uses different texture compression.\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\tvec2 rg = textureLod( iChannel0, (uv+0.5)/256.0, 0.0 ).ba;\n\treturn mix( rg.y, rg.x, f.z );\n}\n\nfloat Trace( vec3 ro, vec3 rd )\n{\n\tfloat t = 0.0;\n\tfloat dist = 1.0;\n\tfor ( int i=0; i < traceDepth; i++ )\n\t{\n\t\tif ( abs(dist) < epsilon || t > drawDistance || t < 0.0 )\n\t\t\tcontinue;\n\t\tdist = Isosurface( ro+rd*t );\n\t\tt = t+dist;\n\t}\n\t\n\treturn t;//vec4(ro+rd*t,dist);\n}\n\n// get normal\nvec3 GetNormal( vec3 pos )\n{\n\tconst vec2 delta = vec2(normalPrecision, 0);\n\t\n\tvec3 n;\n\n// it's important this is centred on the pos, it fixes a lot of errors\n\tn.x = Isosurface( pos + delta.xyy ) - Isosurface( pos - delta.xyy );\n\tn.y = Isosurface( pos + delta.yxy ) - Isosurface( pos - delta.yxy );\n\tn.z = Isosurface( pos + delta.yyx ) - Isosurface( pos - delta.yyx );\n\treturn normalize(n);\n}\t\t\t\t\n\n// camera function by TekF\n// compute ray from camera parameters\nvec3 GetRay( vec3 dir, float zoom, vec2 uv )\n{\n\tuv = uv - .5;\n\tuv.x *= iResolution.x/iResolution.y;\n\t\n\tdir = zoom*normalize(dir);\n\tvec3 right = normalize(cross(vec3(0,1,0),dir));\n\tvec3 up = normalize(cross(dir,right));\n\t\n\treturn dir + right*uv.x + up*uv.y;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\n\tvec3 camPos = CamPos;\n\tvec3 camLook = CamLook;\n\n\tvec2 camRot = tau*(vec2(.3,-.05)+vec2(.5,.25)*(iMouse.xy-iResolution.xy*.5)/iResolution.x);\n\tcamPos.yz = cos(camRot.y)*camPos.yz + sin(camRot.y)*camPos.zy*vec2(-1,1);\n\tcamPos.xz = cos(camRot.x)*camPos.xz + sin(camRot.x)*camPos.zx*vec2(1,-1);\n\t\n\tif ( Isosurface(camPos) <= 0.0 )\n\t{\n\t\t// camera inside ground\n\t\tfragColor = vec4(0,0,0,0);\n\t\treturn;\n\t}\n\n\tvec3 ro = camPos;\n\tvec3 rd;\n\trd = GetRay( camLook-camPos, 1.0, uv );\n\t\n\tfloat t = Trace(ro,rd);\n\n\tvec3 result = vec3(.7,.9,1.2);\n\tif ( t > 0.0 && t < drawDistance )\n\t{\n\t\tvec3 pos = ro+t*rd;\n\t\t\t\n\t\tvec3 norm = GetNormal(pos);\n\t\t\n\t\t// shadow test\n\t\tfloat shadow = 1.0;\n\t\tif ( Trace( pos+lightDir*shadowOffset, lightDir ) < drawDistance )\n\t\t\tshadow = 0.0;\n\t\t\n\t\tresult = Shading( pos, norm, shadow );\n\t\t\n\t\t// fog\n\t\tresult = mix ( vec3(.7,.9,1.2), result, exp(-t*t*.0002) );\n\t}\n\t\n\n\tfragColor = vec4( result, 1.0 );\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"XdXGRs","date":"1376475210","viewed":1368,"name":"Isosurface","username":"TekF","description":"Basic isosurface renderer, for use as a base for other scenes.","likes":18,"published":1,"flags":0,"usePreview":0,"tags":["example","isosurface"],"hasliked":0,"parentid":"","parentname":""}}