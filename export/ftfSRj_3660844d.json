{"ver":"0.1","info":{"id":"ftfSRj","date":"1626010763","viewed":291,"name":"Bilinear Patch 2D SDF + Normal","username":"sdfgeoff","description":"Computes an approximate surface bormal and SDF in 2D for a bilinear patch. Click for normals\nSDF and normals are only accurate near 0.0 - I think. Probably not even there :(\n\nI'd love to know if there are better ways to generate the normal/SDF","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["sdf","normal","bilinear"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n\n    +-----------------------------------------------------+\n    | There are probably better solutions and I'd love to |\n    | learn about them! If you know one, please comment   |\n    +-----------------------------------------------------+\n\n\n\n\n-------------------------- CONTEXT -----------------------------\nI wanted to generate an interesting 2D environment by thresholding\ninterpolated noise. Then came the challenge of applying physics to\nit. For this I needed the normal vector of the zero-crossing and\nan approximate distance to the surface.\n\nThis is the function I came up with. It's an approximation using\nthe partial derivatives. It has two major issues:\n\n1) when the interpolated surface is surface goes hyperbolic as it \n   cannot model the discontinuity in the distance function.\n   The partial derivatives tend to zero, 1/length(normal) -> inf\n\n2) Neigbouring patches are not taken into account, so the SDF/normal\n   of a larger texture will not be continuous.\n\nSo long as you only care about the values near the zero crossing\nyou'll probably be OK.\n\nAs far as I can tell it is impossible to get a perfect sdf. Imagine\nif all four corners have the same value. How can evenly spaced lines\nbe drawn on it? \n\n\n------------------------- CONTROLS --------------------------\nClick to show normal\n\nYou can select from two approximation modes below using the #defines\nbelow:\n - EVEN_SPACING uses an experimental approximation to try get more\n   even line spacing closer to hyperbolic inflection points, but it\n   gains dependence on the scale of the corners.\n\n- CONSTANT_LINECOUNT is \"analytic\" and is properly independant on the\n  scale of the corners matrix, but it behaves poorly if there is an\n  inflection point anywhere vaguely close.\n  \nIn practice, if you know that the corners matrix ranges from\n-1.0 to 1.0 I find that EVEN_SPACING gives a better approximation.\n\n*/\n\n#define EVEN_SPACING\n//#define CONSTANT_LINECOUNT\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n \n\n \n    //We're only interested in a single patch\n    vec2 co = uv * 2.0 - 1.0;\n    co.x *= iResolution.x / iResolution.y;\n    co = co * 0.6 + 0.5;\n    \n    if (co.x > 1.0 || co.x < 0.0 || co.y > 1.0 || co.y < 0.0) {\n        fragColor = vec4(0.2);\n        return;\n    }\n\n    // The patch we will be sampling. We will be finding the zero\n    // crossing, so this can range from -1.0 to 1.0\n    mat2 corners = mat2(\n        sin(iTime * 2.0), // COORD [0,0]\n        cos(iTime * 0.5), // COORD [0,1samples]\n        sin(iTime), // COORD [1,0]\n        -cos(iTime) // COORD [1,1]\n    );\n\n    \n    vec2 co_int = floor(co);\n    ivec2 here_co = ivec2(co_int);\n    vec2 delta = co - co_int;\n    vec2 inv_delta = vec2(1.0) - delta;\n    \n\n    // Contain some numbers for ease of future referencing\n    vec4 x = vec4(inv_delta.x, delta.x, -1.0, 1.0);\n    vec4 y = vec4(inv_delta.y, delta.y, -1.0, 1.0);\n    \n    \n    // Bilinear interpolation\n    float bilinear_interpolation = dot(x.xy * corners, y.xy);\n    \n    // Partial derivatives in X/Y direction combined to make an\n    // approximate normal vector.\n    \n    // At this stage it is non-normalized.\n    float dx = dot(x.zw * corners, y.xy);\n    float dy = dot(x.xy * corners, y.zw);\n    vec2 normal = vec2(\n        dx,\n        dy\n    );\n    \n    // Approx sdf.\n#ifdef CONSTANT_LINECOUNT\n    // This approximation ensures a constant number of dividing lines\n    // across the patch regardless of scale between points.\n    float sdf = bilinear_interpolation / length(normal);\n#endif\n#ifdef EVEN_SPACING\n    // This approximation ensures a more even spacing\n    float sdf = bilinear_interpolation / sqrt(length(normal));\n#endif\n    \n    normal = normalize(normal);\n    \n    \n    vec4 out_col = vec4(0.0);\n    \n    if (iMouse.z < 0.0) {\n        // Draw the value produced by the interpolation\n        out_col += vec4(bilinear_interpolation * 0.5 + 0.5);\n\n        // Shade one side of the SDF\n        out_col += mix(vec4(0.0, 0.2, 0.0, 1.0), vec4(0.0), step(0.0, sdf));\n\n\n        // Draw equal distance lines\n        float lines = step(1.0 / iResolution.y, abs(0.01 - mod(sdf, 0.1)));\n        out_col = mix(vec4(1.0, 0.0, 1.0, 1.0), out_col, lines);\n\n        // Draw where the interpolation crosses the zero mark\n        float crossing = step(1.0 / iResolution.y, abs(0.01 - sdf));\n        out_col = mix(vec4(0.0, 0.0, 1.0, 1.0), out_col, crossing);\n    } else {\n        \n        out_col.rg = normal * 0.5 + 0.5;\n    }\n    \n    \n\n    // Output to screen\n    fragColor = out_col;\n}","name":"Image","description":"","type":"image"}]}