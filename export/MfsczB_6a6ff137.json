{"ver":"0.1","info":{"id":"MfsczB","date":"1721284912","viewed":42,"name":"[ARTS1308] Volumetric","username":"ARTS1308","description":"Simple moving smoke based on\nhttps://www.shadertoy.com/view/lss3zr\nhttps://www.shadertoy.com/view/WslGWl\nSee comment in the program about the improvements and/or corrections.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["volumetric"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n\nMoving smoke based on\nhttps://www.shadertoy.com/view/lss3zr\nhttps://www.shadertoy.com/view/WslGWl\n\nSome improvements:\n\n1. The transmission T is updated as T *= exp( - density * something).\n   Then the exponent really did the integration.\n   I think the original implements are wrong on this aspect.\n   \n2. The transmitted light is not (should not be) added to color at every step.\n   This is just physically not correct.\n   Instead, the transmission rate is only used after raycasting.\n   \n3. The background color is mixed with scattered color.\n   The transmission is used as the rate of the mix.\n   \n4. The smoke is now moving.\n\nNow you can increase \"absorption\" or \"scatter\" to make the smoke look thicker\n... as should be the case.\n\n*/\n\n\nfloat density(vec3 p)\n{\t\n    return 0.1-length(p)*.05+fbm(p*.3 - iTime);\n}\n\nmat3 camera(vec3 cameraPos, vec3 lookAtPoint) {\n    vec3 cd = normalize(lookAtPoint - cameraPos); // camera direction\n    vec3 cr = normalize(cross(vec3(0, 1, 0), cd)); // camera right\n    vec3 cu = normalize(cross(cd, cr)); // camera up\n\n    return mat3(-cr, cu, -cd);\n}\n\n#define ZERO min(0, iFrame)\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec3 lp = vec3(0.); // lookat point (aka camera target)\n    vec3 ro = 25. * vec3(cos(-iTime * 0.5), 0., sin(-iTime * 0.5));\n    vec3 rd = camera(ro, lp) * normalize(vec3(uv, -1)); // ray direction\n\tvec3 color = vec3(0.);\n    \n\tconst int MAX_STEP = 64;\n    const float MAX_DIST = 64.;\n\t\n\tfloat ds = MAX_DIST / float(MAX_STEP);\n    float T = 1.;\n    float absorption = 0.02;\n    float scatter = 0.5;\n\tvec3  sundir = normalize( vec3(1.,.0,.0) ); // sun direction\n    vec3  suncol = vec3(1., .7, .6); // sun color\n    \n\tfor(int i=ZERO; i<MAX_STEP; i++)\n\t{\n        vec3 p1 = ro + float(i) * ds * rd;\n        float d1 = density(p1);\n\t\tif(d1 > 0.)\n\t\t{\n\t\t\tT *= exp(- d1 * absorption * ds);\n\t\t\tif( T <= 0.01)\n\t\t\t\tbreak;\t\t\t\t\n\t\t\t\t\n\t\t\t //Light scattering\n\t\t\tfloat Tl = 1.0;\n\t\t\tfor(int j=ZERO; j < MAX_STEP/16; j++)\n\t\t\t{\n\t\t\t\tvec3 p2 = p1 + float(j) * ds * 16. * sundir;\n                float d2 = density( p2 );\n\t\t\t\tif(d2 > 0.)\n                \tTl *= exp(- d2 * absorption * ds * 16.);\n                    if (Tl <= 0.01)\n                        break;\n\t\t\t}\n\t\t\t\n\t\t\tcolor += suncol * T * Tl * ds;\n\t\t}\n\t}\n    color = mix(scatter * color, texture(iChannel0, rd).rgb, T);\n    //color = mix(color, vec3(0.), T);\n    fragColor = vec4(pow(color, vec3(1.0/2.2)), 1.);\n    \n    //fragColor = vec4(vec3(noise(vec3(uv, iTime))), 1.);\n\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// noise from iq: https://www.shadertoy.com/view/Xsl3Dl\n\nvec3 hash( vec3 p ) // replace this by something better\n{\n\tp = vec3( dot(p,vec3(127.1,311.7, 74.7)),\n\t\t\t  dot(p,vec3(269.5,183.3,246.1)),\n\t\t\t  dot(p,vec3(113.5,271.9,124.6)));\n\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\nfloat noise( in vec3 p )\n{\n    vec3 i = floor( p );\n    vec3 f = fract( p );\n\n     // cubic interpolant\n    vec3 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( mix( dot( hash( i + vec3(0.0,0.0,0.0) ), f - vec3(0.0,0.0,0.0) ), \n                          dot( hash( i + vec3(1.0,0.0,0.0) ), f - vec3(1.0,0.0,0.0) ), u.x),\n                     mix( dot( hash( i + vec3(0.0,1.0,0.0) ), f - vec3(0.0,1.0,0.0) ), \n                          dot( hash( i + vec3(1.0,1.0,0.0) ), f - vec3(1.0,1.0,0.0) ), u.x), u.y),\n                mix( mix( dot( hash( i + vec3(0.0,0.0,1.0) ), f - vec3(0.0,0.0,1.0) ), \n                          dot( hash( i + vec3(1.0,0.0,1.0) ), f - vec3(1.0,0.0,1.0) ), u.x),\n                     mix( dot( hash( i + vec3(0.0,1.0,1.0) ), f - vec3(0.0,1.0,1.0) ), \n                          dot( hash( i + vec3(1.0,1.0,1.0) ), f - vec3(1.0,1.0,1.0) ), u.x), u.y), u.z );\n}\n\nmat3 m = mat3( 0.00,  0.80,  0.60,\n              -0.80,  0.36, -0.48,\n              -0.60, -0.48,  0.64 );\n\nfloat fbm( vec3 p )\n{\n    float f;\n    f  = 1.0000*noise( p );\n    p = m*p*2.02;  f += 0.5000*noise( p );\n    p = m*p*2.03;  f += 0.2500*noise( p );\n    p = m*p*2.04;  f += 0.1250*noise( p );\n    //p = m*p*2.01;  f += 0.0625*noise( p );\n    return 0.5 + 0.5 * f;\n}\n","name":"Common","description":"","type":"common"}]}