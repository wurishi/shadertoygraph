{"ver":"0.1","info":{"id":"MdSyRd","date":"1493729032","viewed":301,"name":"2D Light Renderer","username":"pixartist","description":"2D Light Renderer with terrible performance","likes":7,"published":1,"flags":32,"usePreview":0,"tags":["2d","light","shadows","renderer"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tfragColor = texture(iChannel0, uv);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define COUNT_TRI 16\n#define COUNT_LIGHT 4\n#define LIGHT_SAMPLES_HALF 4\n//structs\nstruct Ray\n{\n    vec2 o;\n    vec2 d;\n};\nstruct Tri\n{\n    vec2 p1;\n    vec2 p2;\n    vec2 p3;\n    bool enabled;\n};\nstruct Light\n{\n    vec2 o;\n    float r;\n    vec3 c;\n    bool enabled;\n};\n//globals\nvec2 uv;\nivec2 coord;\nvec2 p;\nvec2 ss;\nfloat px;\nuint seed;\nTri[COUNT_TRI] tris;\nLight[COUNT_LIGHT] lights;\nfloat hash( uint n ) \n{\n    // integer hash copied from Hugo Elias\n\tn = (n << 13U) ^ n;\n    n = n * (n * n * 15731U + 789221U) + 1376312589U;\n    \n    \n    //return 1.0 - float(n&0x7fffffffU)/float(0x7fffffff);\n  \n    // floating point conversion from https://iquilezles.org/articles/sfrand\n    return uintBitsToFloat( (n>>9U) | 0x3f800000U ) - 1.0;\n}\nvoid rndTri(int i, vec2 p, vec2 size)\n{\n    tris[i].enabled = true;\n    tris[i].p1 = p + vec2(hash(seed++), hash(seed++)) * size;\n    tris[i].p2 = p + vec2(hash(seed++), hash(seed++)) * size;\n    tris[i].p3 = p + vec2(hash(seed++), hash(seed++)) * size;\n}\nvoid map()\n{\n    vec2 s = vec2(1.9, 1) * 0.3;\n    rndTri(0, vec2(0.7, 0.5), s);\n    rndTri(1, vec2(0.3, 0.5), s);\n    rndTri(2, vec2(0.3, 0.2), s);\n    rndTri(3, vec2(1.3, 0.5), s);\n    rndTri(4, vec2(1.1, 0.0), s);\n    rndTri(5, vec2(1.0, 0.5), s);\n    rndTri(6, vec2(0.1, 0.0), s);\n    rndTri(7, vec2(0.8, 0.3), s);\n    rndTri(8, vec2(0.7, 0.0), s);\n    rndTri(9, vec2(0.7, 0.7), s);\n    \n    \n    lights[0].enabled = true;\n    lights[0].o = vec2(0.5 + 0.5 * sin(iTime * 0.1), 0.5 + 0.5 * cos(iTime * 0.4632123)) * ss;\n    lights[0].r = 0.05;\n    lights[0].c = vec3(0.1,0.1,1.0);\n    \n    lights[1].enabled = true;\n    lights[1].o = vec2(0.5 + 0.5 * sin(iTime * 0.41453), 0.5 + 0.5 * sin(iTime * 0.6)) * ss;\n    lights[1].r = 0.02;\n    lights[1].c = vec3(1.0,0.1,0.1);\n    \n    lights[2].enabled = true;\n    lights[2].o = vec2(0.5 + 0.5 * sin(iTime * 0.13123), 0.5 + 0.5 * sin(iTime * 0.1)) * ss;\n    lights[2].r = 0.01;\n    lights[2].c = vec3(0.1,1.0,0.1);\n}\n\nvoid init(vec2 fragCoord)\n{\n    seed = 0u;\n    uv = fragCoord.xy / iResolution.xy;\n    ss = vec2(iResolution.x / iResolution.y, 1.0);\n    p = uv * ss;\n    px = 1.0 / iResolution.x;\n    coord = ivec2(fragCoord);\n    for(int i = 0; i < COUNT_TRI; i++)\n    {\n        tris[i].enabled = false;\n    }\n    for(int i = 0; i < COUNT_LIGHT; i++)\n    {\n        lights[i].enabled = false;\n    }\n    map();\n}\nbool rayLineIntersect(Ray r, vec2 a, vec2 b, out float p)\n{\n\n    vec2 v1 = a - r.o;\n    vec2 v2 = b - a;\n    vec2 v3 = vec2(-r.d.y, r.d.x);\n    float d = dot(v2, v3);\n    if(d == 0.0)\n        return false;\n    float d2 = dot(v1, v3) / -d;\n    if(d2 < 0.0 || d2 > 1.0)\n        return false;\n    p = (v1.x * v2.y - v1.y * v2.x) / d;\n\n    if(p < 0.0)\n        return false;\n    return true;\n}\nbool rayTriangleIntersect(Ray r, int i, out float p)\n{\n    bool hit = false;\n    if(tris[i].enabled)\n    {\n        float d = 0.0;\n        vec2 p1 = tris[i].p1;\n        vec2 p2 = tris[i].p2;\n        vec2 p3 = tris[i].p3;\n        if(rayLineIntersect(r, p1, p2, d))\n        {\n            hit = true;\n            p = d;\n        }\n        if(rayLineIntersect(r, p2, p3, d))\n        {\n            if(!hit || p > d)\n            {\n            \thit = true;\n                p = d;\n            }\n        }\n        if(rayLineIntersect(r, p3, p1, d))\n        {\n            if(!hit || p > d)\n            {\n            \thit = true;\n            \tp = d;\n            }\n        }\n    }\n    return hit;\n}\nfloat renderTriangle(int i)\n{\n    if(tris[i].enabled)\n    {\n        vec2 p1 = tris[i].p1;\n        vec2 p2 = tris[i].p2;\n        vec2 p3 = tris[i].p3;\n        float A = ((p2.y - p3.y)*(p.x - p3.x) + (p3.x - p2.x)*(p.y - p3.y)) /\n        ((p2.y - p3.y)*(p1.x - p3.x) + (p3.x - p2.x)*(p1.y - p3.y));\n        float B = ((p3.y - p1.y)*(p.x - p3.x) + (p1.x - p3.x)*(p.y - p3.y)) /\n       ((p2.y - p3.y)*(p1.x - p3.x) + (p3.x - p2.x)*(p1.y - p3.y));\n        float C = 1.-A-B;\n        if(A>1.)\n            A=1.-A;\n        if(B>1.)\n            B=1.-B;\n        if(C>1.)\n            C=1.-C;\n        return min(min(smoothstep(-px * 8.0, 0.0, A),\n                       smoothstep(-px * 8.0, 0.0, B)),\n                   smoothstep(-px * 8.0, 0.0, C));\n        //return A >= 0. && A <= 1. && B >= 0. && B <= 1. && C >= 0. && C <= 1.;\n    }\n    return 0.0;\n}\nvec3 renderLight(int i)\n{\n    const int samples = 1 + LIGHT_SAMPLES_HALF * 2;\n    if(lights[i].enabled)\n    {\n        float d = distance(lights[i].o, p);\n        float str = 1.0 / abs(d); //no inverse-square reduction\n        if(str > 0.0)\n        {\n            Ray r;\n            r.o = p;\n            r.d = normalize(lights[i].o - p);\n            vec2 nrm = vec2(-r.d.y, r.d.x);\n            float stp = lights[i].r * 2.0 / float(samples);\n            float intensity = 0.0;\n            for(float s = -lights[i].r; s <= lights[i].r; s+=stp)\n            {\n                Ray ray;\n                ray.o = r.o;\n                vec2 tgt = lights[i].o + s * nrm -(lights[i].r - abs(s)) * r.d;\n                float dst = distance(ray.o, tgt);\n                ray.d = normalize(tgt - ray.o);\n                float h;\n                bool hit = false;\n                for(int i = 0; i < COUNT_TRI; i++)\n                {\n                    if(rayTriangleIntersect(ray, i, h) && h < dst)\n                    {\n                        hit = true;\n                       \tbreak;\n                    }\n                }\n                if(!hit)\n                    intensity += str;\n            }\n            return intensity * lights[i].c * 0.09 / float(samples);\n        }\n    }\n    return vec3(0.0);\n}\nfloat renderCircle(vec2 o, float r)\n{\n    return 1.0 - smoothstep(-px * 3.0, 0.0, distance(o, p) - r);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    init(fragCoord);\n    vec4 color = vec4(0.0);\n    \n    \n    float tri = 0.0;\n    for(int i = 0; i < COUNT_TRI; i++)\n    {\n     \ttri += renderTriangle(i);\n    }\n    vec3 l = vec3(0.0);\n    for(int i = 0; i < COUNT_LIGHT; i++)\n    {\n        l += renderLight(i);\n    }\n    color += tri * vec4(uv,1.0,1.0) * 0.4 + vec4(l, 1.0);\n    fragColor = color;\n}","name":"Buf A","description":"","type":"buffer"}]}