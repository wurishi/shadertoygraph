{"ver":"0.1","info":{"id":"McfGWH","date":"1703001093","viewed":30,"name":"Twisted torus MIPT HW3","username":"polinavenberg","description":"MIPT homework 3: twisted torus with noise texture on background and liquid metal texture on the object","likes":3,"published":1,"flags":32,"usePreview":0,"tags":["torus","texture","gradient","mobius"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdfGzn","filepath":"/media/a/894a09f482fb9b2822c093630fc37f0ce6cfec02b652e4e341323e4b6e4a4543.mp3","previewfilepath":"/media/ap/894a09f482fb9b2822c093630fc37f0ce6cfec02b652e4e341323e4b6e4a4543.mp3","type":"music","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define EPS 0.01\n#define STEPS 64\n\nfloat mobius(vec3 p, float b) {\n float x = p.x, y = p.y, z = p.z;\n float xx = x*x, yy = y*y, zz = z*z, y3 = yy*y, x3 = xx*x;\n float xy = xx+yy, b2 = b*2.0, zxy = z*(xx*y*3.0-y3), xyy = x*yy*3.0-x3;\n    float k1 = (2.0*zxy+xyy*(xy-zz+1.0))*(b-0.1)-xy*xy*(b2+0.2);\n    float k2 = b*xy*0.2+(b2-0.2)*(zxy+xyy)-xy*(b+0.1)*(xy+zz+1.0);\n return k1*k1-xy*k2*k2;\n}\n\nvec3 gradient(vec3 p, float b) {\n vec2 q = vec2(0.0, EPS);\n return vec3(mobius(p+q.yxx, b) - mobius(p-q.yxx, b), \n       mobius(p+q.xyx, b) - mobius(p-q.xyx, b),\n       mobius(p+q.xxy, b) - mobius(p-q.xxy, b));\n}\n\nfloat torus(vec3 p) {\n vec2 t = vec2(1.0, 0.3);\n   vec2 q = vec2(length(p.xy)-t.x,p.z);\n   return length(q)-t.y;\n}\n\nmat3 rotY(float ang) {\n return mat3(cos(ang), 0.0, sin(ang), 0.0, 1.0, 0.2, -sin(ang), 0.0, cos(ang));\n}\n\nmat3 rotX(float ang) {\n return mat3(1.0, 0.0, 0.0, 0.2, cos(ang), -sin(ang), 0.0, sin(ang), cos(ang));\n}\n\nvec3 shade(vec3 p, vec3 rd, float b, vec2 uv) {\n vec3 col = cos(iTime + uv.xyx + vec3(1.0, 3.0, 3.0));\n vec3 n = normalize(-gradient(p, b));\n col += 2.0*pow(clamp(1.0+dot(n, rd), 0.0, 1.0), 2.0);\n    \n return col/(col+1.0);\n\n}\n\nvec3 background(vec3 rd) {\n    vec2 texturecoords = vec2(atan(rd.x, rd.z), rd.y) * 0.5;\n    vec3 texturecol = texture(iChannel0, texturecoords).rgb;\n    float k = rd.x*0.5;\n    vec3 col = mix(vec3(0.0, 0.1, 0.3), cos(iTime + vec3(1.0, 3.0, 3.0)), k) * 1.2;\n    return mix(col, texturecol, 0.1);\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n vec2 fc = fragCoord.xy / iResolution.xy;\n vec2 uv = -1.0+2.0*fc;\n uv.x *= iResolution.x/iResolution.y; \n \n vec2 mouse = iMouse.xy/iResolution.xy + 0.3*iTime;\n \n mat3 m = rotY(mouse.x)*rotX(mouse.y);\n vec3 ro = m*vec3(0.0, 0.0, 2.0);\n vec3 rd = m*normalize(vec3(uv, -1.0));\n \n float d = 10.0, t1 = 0.0;\n vec3 p = ro, col = vec3(1.0);\n \n for (int i = 0; i < STEPS; ++i) {\n  if (d < EPS) continue;\n  d = torus(p);\n  t1 += d; p = ro + t1*rd;\n }\n    \n    col=vec3(0.0);\n    col += background(rd);\n    float b = 0.005;\n \n if (d < EPS) { \n        float t2 = t1; d = mobius(p, b);\n  for (int i = 0; i < 2*STEPS; ++i) {\n   if (d > 0.0) continue;\n   d = mobius(p, b);\n   t2 += 2.0*EPS; p = ro + t2*rd;\n  }\n        \n\n        if (d > 0.0) {\n   for (int i = 0; i < STEPS; ++i) {\n    d = 0.5*(t1+t2); p = ro + d*rd;\n    if (mobius(p, b) > 0.0) t2 = d; else t1 = d;\n   }\n   col = shade(ro+d*rd, rd, b, uv);\n            vec3 textureColor = texture(iChannel2, uv).rgb;\n            col = mix(col, textureColor, 0.3);\n  }\n        \n }\n    \n    col *= pow(30.0*fc.x*(1.0-fc.x)*fc.y*(1.0-fc.y), 0.5);\n    \n \n fragColor = vec4(sqrt(col), 0.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    float timePattern = sin(iTime * 10.0 + uv.x * 10.0) * cos(iTime + uv.y * 10.0);\n    vec3 color = vec3(timePattern * 0.5 + 0.5);\n\n    fragColor = vec4(color, 1.0);\n}","name":"Buffer A","description":"","type":"buffer"}]}