{"ver":"0.1","info":{"id":"Mty3Rc","date":"1475817134","viewed":245,"name":"Meteor shower","username":"Karang","description":"Simulation used to test computer vision algorithms.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["earth","orbit","meteor","satellite"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define M_PI 3.1415926535897932384626433832795\n\nfloat hash(float h) {\n    h += 40.0; // prevent center symetry\n\treturn fract(sin(h) * 43758.5453123);\n}\n\nfloat snoise(vec3 x) {\n\tvec3 p = floor(x);\n\tvec3 f = fract(x);\n\tf = f * f * (3.0 - 2.0 * f);\n\n\tfloat n = p.x + p.y * 157.0 + 113.0 * p.z;\n\treturn mix(\n\t\t\tmix(mix(hash(n + 0.0), hash(n + 1.0), f.x),\n\t\t\t\t\tmix(hash(n + 157.0), hash(n + 158.0), f.x), f.y),\n\t\t\tmix(mix(hash(n + 113.0), hash(n + 114.0), f.x),\n\t\t\t\t\tmix(hash(n + 270.0), hash(n + 271.0), f.x), f.y), f.z);\n}\n\nvec3 hash3( in vec3 p ) {\n    return vec3(snoise(p),snoise(p+1.5),snoise(p+2.5))*2.0-vec3(1.0);\n}\n\nfloat fbm(vec3 p) {\n    float h = 0.0;\n    float f = 1.0;\n    for (int i=0 ; i<8 ; i++) {\n        //if (i>6) break;\n        h += abs((snoise(p*f*0.2)-0.5)/f);\n        f *= 2.0;\n    }\n    return h;\n}\n\n/* Return the rotation matrix defined by its axis and angle */\nmat4 rotationMatrix(vec3 axis, float angle) {\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n                0.0,                                0.0,                                0.0,                                1.0);\n}\n\n\n/*\n\tReturn true if the ray hit the sphere\n\tIf true, A and B contains the ray entry and exit point\n*/\nbool raySphereI(vec3 ro, vec3 rd, vec3 c, float r, out vec3 A, out vec3 B) {\n    vec3 OC = c - ro;\n    float x = dot(OC, rd);\n    float d = dot(OC, OC) - x*x;\n    if (d > (r*r)) return false;\n    float t = sqrt(r*r - d);\n    A = ro + rd*(x-t);\n    B = ro + rd*(x+t);\n    return x>0.0;\n}\n\nvoid rayRayI(vec3 P0, vec3 u, vec3 Q0, vec3 v, out vec3 P, out vec3 Q) {\n    vec3 w0 = P0-Q0;\n    float a = dot(u, u);\n    float b = dot(u, v);\n    float c = dot(v, v);\n    float d = dot(u, w0);\n    float e = dot(v, w0);\n    float den = a*c-b*b;\n    if (den==0.0) { // parallels\n    \t //TODO\n    } else {\n        float sC = (b*e-c*d)/den;\n        float tC = (a*e-b*d)/den;\n        P = P0+u*sC;\n        Q = Q0+v*tC;\n    }\n}\n\n\nfloat star(vec3 p) {\n    float h = 0.0;\n    float f = 1.0;\n    for (int i=0 ; i<6 ; i++) {\n        h += (snoise(p*f*200.0)/f);\n        f *= 2.0;\n    }\n    return smoothstep(0.1, 0.9, 1.0-h*2.0);\n}\n\n/*\n\tPerform the light scattering computation.\n\thttp://http.developer.nvidia.com/GPUGems2/gpugems2_chapter16.html\n\thttp://scratchapixel.com/lessons/procedural-generation-vritual-worlds/simulating-sky/simulating-colors-of-the-sky\n*/\n\nconst vec3 lightDir = normalize(vec3(1.0,0.0,0.0));\n\nconst vec3 planetCenter = vec3(0.0);\n\nconst float innerRadius = 10.0; // The inner (planetary) radius\nconst float outerRadius = 10.3; // The outer (atmosphere) radius\n\nconst int nSamples = 16;\nconst int nSamplesLight = 8;\n\nconst float Hr = 7994.0;\nconst float Hm = 1200.0;\nconst vec3 betaM = vec3(21e-2);\nconst vec3 betaR = vec3(3.8e-2, 13.5e-2,33.1e-2);\n    \nvec3 lightScattering(vec3 A, vec3 B, vec3 rd) {\n    vec3 samplePoint = A;\n    float sampleLength = length(A-B) / float(nSamples);\n    \n    vec3 sumR = vec3(0.0);\n    vec3 sumM = vec3(0.0);\n    float opticalDepthR = 0.0;\n    float opticalDepthM = 0.0;\n    float mu = dot(rd, lightDir);\n    float phaseR = 3.0 / (16.0*M_PI) * (1.0 + mu*mu);\n    float g = 0.76;\n    float phaseM = 3.0 / (8.0*M_PI) * ((1.0-g*g)*(1.0+mu*mu)) / ((2.0+g*g) * pow(1.0+g*g-2.0*g*mu, 1.5)); \n    \n    for (int i=0 ; i<nSamples ; i++) {\n        float height = length(samplePoint - planetCenter) - innerRadius;\n        \n        // compute optical depth for light\n        float hr = exp(-height / Hr) * sampleLength;\n        float hm = exp(-height / Hm) * sampleLength;\n        opticalDepthR += hr;\n        opticalDepthM += hm;\n        \n        // light optical depth\n        vec3 ALight, BLight;\n        raySphereI(samplePoint, lightDir, planetCenter, outerRadius, ALight, BLight);\n        float sampleLengthLight = length(BLight-samplePoint)/float(nSamplesLight);\n        float opticalDepthLightR = 0.0;\n        float opticalDepthLightM = 0.0;\n        vec3 sampleLightPoint = samplePoint;\n        bool ok = true;\n        for (int j=0; j<nSamplesLight ; j++) {\n            float heightLight = length(sampleLightPoint-planetCenter) - innerRadius;\n            if (heightLight < 0.0) {\n                ok = false;\n                break;\n            }\n            opticalDepthLightR += exp(-heightLight/Hr) * sampleLengthLight;\n            opticalDepthLightM += exp(-heightLight/Hm) * sampleLengthLight;\n            sampleLightPoint += lightDir*sampleLengthLight;\n        }\n\n        if (ok) {\n            vec3 tau = betaR * (opticalDepthR + opticalDepthLightR);\n            tau += betaM * 1.1 * (opticalDepthM + opticalDepthLightM);\n            vec3 attenuation = vec3(exp(-tau.x), exp(-tau.y), exp(-tau.z));\n            sumR += attenuation * hr;\n            sumM += attenuation * hm;\n        }\n        \n        samplePoint += rd*sampleLength;\n    }\n    return (sumR * betaR * phaseR + sumM * betaM * phaseM) * 20.0;\n}\n\nvec3 render(vec3 ro, vec3 rd) {\n    vec3 color = vec3(0.005,0.005,0.06);\n    \n     // Space\n    vec3 lCol = vec3(1.0, 0.9, 0.8);\n    float sun = clamp(dot(rd, lightDir),0.0,1.0)+0.05;\n    color += 0.01 * lCol * pow(sun, 150.0);\n    color += star(rd);\n    \n    // Earth\n    vec3 closestPoint;\n    vec3 earthA, earthB;\n    if (raySphereI(ro, rd, planetCenter, innerRadius, earthA, earthB)) {\n        vec3 nor = normalize(earthA);\n        color = vec3(0.0,0.0,1.0);\n        float light = clamp(dot(lightDir, nor), 0.0, 0.9)+0.1;\n        \n        float geography = 1.0-fbm(2.0 * earthA)*2.0;\n\n        float coast = 0.2 * pow(geography + 0.5, 50.0);\n        float population = smoothstep(0.2, 0.8, fbm(40.0 * earthA) + coast - light);\n        vec3 p = 1000.0 * earthA;\n        population *= (snoise(p) + coast);\n        population *= (snoise(p*2.0) + coast);\n        population *= (snoise(p*4.0) + coast);\n        population *= (snoise(p*8.0) + coast);\n        population *= (snoise(p*16.0) + coast);\n        population = smoothstep(0.0, 0.1, population);\n\n        vec3 land = vec3(0.6, 0.4, 0.2) * light;\n        land = mix(land, vec3(2.0, 1.3, 1.0), clamp(population, 0.0, 1.0));\n        vec3 water = vec3(0.0, 0.5, 1.0) * light;\n        vec3 ground = mix(land, water, smoothstep(0.49, 0.5, geography));\n\n        vec3 wind = vec3(fbm(30.0 * earthA + iTime), fbm(60.0 * earthA + iTime), 0.0);\n        float weather = fbm(1.0 * (earthA + wind + iTime*0.1)) * (0.6 + 0.4 * snoise(10.0 * earthA))*2.5;\n\n        float clouds = 0.8 * smoothstep(0.35, 0.45, weather) * smoothstep(-0.25, 1.0, fbm(wind));\n        color = mix(ground, vec3(1.0, 1.0, 1.0)*light*1.5, clouds);\n    }\n    closestPoint = earthA;\n    \n    // Meteors\n    for (int i=0 ; i<10 ; i++) {\n        float time = iTime*3.0+0.1*float(i);\n        //time = iTime+0.1*float(i);\n        vec3 seed = vec3(floor(time), float(i), floor(time));\n        float t = fract(time);\n        vec3 meteorO = hash3(vec3(seed));//*innerRadius\n        vec3 meteorD = normalize(hash3(vec3(seed)+0.5));\n        \n        vec3 A,B;\n        raySphereI(meteorO, meteorD, planetCenter, outerRadius, A,B);\n        vec3 meteorIn = A;\n        raySphereI(meteorO, meteorD, planetCenter, innerRadius, A,B);\n        vec3 meteorOut = A;\n        if (t<0.5)\n            meteorOut = mix(meteorIn, meteorOut, t*2.0);\n        else\n            meteorIn = mix(meteorIn, meteorOut, t*2.0-1.0);\n        \n        vec3 P, Q;\n        rayRayI(ro, rd, meteorO, meteorD, P, Q);\n        if (dot(rd, P-ro)>0.0) {\n            if (length(ro-P)>length(ro-closestPoint))\n                P = closestPoint;\n            vec3 mC = (meteorIn+meteorOut)/2.0;\n            color += vec3(1.0)*pow(clamp(1.0-(length(P-meteorIn)+length(P-meteorOut)*1.01)*2.87/(1.0-abs(t*2.0-1.0)), 0.0, 10.0)*7.2,50.0);\n        }\n    }\n    \n    // Atmosphere\n    vec3 atmoA, atmoB;\n    if (raySphereI(ro, rd, planetCenter, outerRadius, atmoA, atmoB)) {\n        if (length(ro-atmoB)>length(ro-earthA))\n            atmoB = earthA;\n        color += lightScattering(atmoA, atmoB, rd);\n    }\n    \n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 pos = 2.0 * ( fragCoord.xy / iResolution.xy ) - 1.0;\n\tpos.x *= iResolution.x / iResolution.y;\n    \n    // Camera\n    float angle = -1.1;\n    float radius = 10.5;\n    //float t = iMouse.x*0.01;\n    float t = (iTime+150.0)*0.01;\n    vec3 cPos = vec3(radius, 0.0, 0.0);\n    cPos = (rotationMatrix(vec3(0.0, 1.0, 0.0), t)*rotationMatrix(vec3(0.0, 0.0, 1.0), angle)*vec4(cPos, 1.0)).xyz;\n\t\n\tconst vec3 cUp = vec3(0., 1., 0.);\n    //vec3 cLook = vec3(0.0, 0.0, 0.0);\n\tvec3 cLook = vec3(radius-0.1, 0.0, 0.0);\n   \tcLook = (rotationMatrix(vec3(0.0, 1.0, 0.0), t+0.1)*rotationMatrix(vec3(0.0, 0.0, 1.0), angle)*vec4(cLook, 1.0)).xyz;\n\t\n\t// Camera matrix\n\tvec3 ww = normalize( cLook-cPos );\n\tvec3 uu = normalize( cross(ww, cUp) );\n\tvec3 vv = normalize( cross(uu, ww) );\n\t\n\tvec3 rd = normalize( pos.x*uu + pos.y*vv + 2.0*ww );\n    \n\tfragColor = vec4(render(cPos, rd), 1.0);\n}","name":"Image","description":"","type":"image"}]}