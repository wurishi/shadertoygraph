{"ver":"0.1","info":{"id":"MsVczR","date":"1520891338","viewed":236,"name":"Hypertori Rays","username":"audiopixel","description":"Light in the middle","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","rays","lighting"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// 'Hypertori Rays'\n// Created by hepp maccoy 2018 hepp@audiopixel.com\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// Building on techniques by @iq, @alteredq, @mrkishi and others\n// Thanks to @cacheflowe & @reinder for advice on ray marching\n\nmat2 r2d(float a) {\n    float sa=sin(a);\n    float ca=cos(a);\n    return mat2(ca,sa,-sa,ca);\n}\n\nvec2 amod(vec2 p, float m) {\n    float a=mod(atan(p.x,p.y), m)-m*.5;\n    return vec2(cos(a), sin(a))*length(p);\n}\n\nfloat soc(vec3 p) {\n    vec3 n = normalize(sign(p+1e6));\n    return min(min(dot(p.xy, n.xy), dot(p.yz, n.yz)), dot(p.xz, n.xz));\n}\n\nfloat map(vec3 p) {\n    float t = (iTime * 12.) + sin(iTime * .9) * 20.;\n    float a1 = -13. + sin(iTime * .8) * .3;\n    float a2 = -14.5 + sin(iTime * .9) * .2;\n    float d = 1.0; vec3 o = p;\n    float a = mod(o.y+5., (20.))-10.; a = abs(o.y);\n    p.yz *= r2d(sign(a)* .2);\n    p.xz *= r2d(sign(a)*(t * .04));\n    p.xz = amod(p.xz, 0.38205625 + sin(iTime * .7) * .13);\n    p.xz = max(abs(p.xz)-14.552, -14.0311);\n    p.z = mod(p.z, a1)-(a1 *.5);\n    p.x = mod(p.x, a2)-(a2 *.5);\n    p.y = mod(p.y+t, 12.)-5.;\n    d = min(d, soc(max(abs(p) + 2., -2.)));\n    return (length(p*-0.3637)-0.4866)*1.1851 - (d * (1.8873 + sin(iTime * 5.4) * .03));\n}\n\nvec3 calcNormal(in vec3 p) {\n    vec2 e = vec2(1.0, -1.0) * 0.8;\n    return normalize(\n        e.xyy * map(p + e.xyy) +\n        e.yyx * map(p + e.yyx) +\n        e.yxy * map(p + e.yxy) +\n        e.xxx * map(p + e.xxx));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 st = (fragCoord.xy/iResolution.xy)*2.5-1.;\n    st.x *= 1.7;\n    vec3 l = vec3(0, 0, -15);\n    vec3 ro = vec3(st, -18. + sin(iTime * .8) * 1.5);\n    vec3 rd = normalize(vec3(st+vec2(0.), 0.4 + sin(iTime * .6) * .14));\n    vec3 mp; mp = ro;\n    float md;\n    for (int i=0; i<50; i++) {\n        md = map(mp); if (md <.001) break; mp += rd*md;\n    }\n    vec3 p = ro + rd * (mp);\n    vec3 normal = calcNormal(p);\n    float dif = clamp(dot(normal, normalize(l - p)), 0., 1.);\n    dif *= 5. / dot(l - p, l - p);\n    vec3 c2 = vec3(pow(dif, .2424));\n    c2 += vec3((mp.z * 2.5) * (md * .05), 0, 0 );\n    fragColor = vec4(c2, 1.);\n}","name":"Image","description":"","type":"image"}]}