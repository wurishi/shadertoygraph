{"ver":"0.1","info":{"id":"7lffDj","date":"1651485845","viewed":249,"name":"Toon-Style Gravity Wave","username":"Rrrrichard","description":"Gravity wave in toon style\n\nWritten by Rrrrichard (Zhehao Li) in a \"2-hour shader challenge\" on 2022/05/02 ","likes":10,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","toonstyle"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// ==========================================================\n// Written by Rrrrichard(Zhehao Li) \n// in a \"2-hour shader challenge\" on 2022/05/02 \n// \n// Copyright Zhehao Li, 2022 \n// You cannot use this work in any commercial product, \n// website or project. You cannot sell this Work \n// and you cannot mint NFTs of it.\n// \n// ==========================================================\n\n#define MAX_STEPS 300\n//#define MAX_DIST 10. --> amazing effect with the shape of SDF\n#define MAX_DIST 1e10\n#define EPS .001\n\nfloat GetSceneDistance(vec3 point, out int obj)\n{\n    vec4 sphere = vec4(0, 1.5, 6, 1.); // (xyz, radius)\n    vec4 sphere2 = vec4(0., 1.5, 6, 0.38); \n    vec4 sphere3 = vec4(0., 1.5, 6, 0.1);\n    vec4 sphere4 = vec4(0., 1.5, 6, 0.2);\n    \n    float rotate_r2 = 2.0;\n    float rotate_r3 = 1.4;\n    float rotate_r4 = 1.7;\n    \n    float bounce_frequen = 4.;\n    sphere += vec4(0., 0.1 *sin(bounce_frequen * iTime), 0., 0.);\n    \n    sphere2 += vec4(rotate_r2 *sin(iTime), \n                    0.8*sin(iTime),\n                    rotate_r2 *cos(iTime),\n                    0.);\n                    \n    float delta = 1.5;\n    sphere3 += vec4(rotate_r3 *sin(iTime+delta), \n                    0.5*sin(iTime+delta),\n                    rotate_r3 *cos(iTime+delta),\n                    0.);\n    sphere4 += vec4(rotate_r4 *sin(iTime+2.*delta), \n                    -0.6*sin(iTime+2.*delta),\n                    rotate_r4 *cos(iTime+2.*delta),\n                    0.);\n    \n    float sphere_dist = length(point - sphere.xyz)-sphere.w;\n    float sphere_dist2 = length(point - sphere2.xyz)-sphere2.w;\n    float sphere_dist3 = length(point - sphere3.xyz)-sphere3.w;\n    float sphere_dist4 = length(point - sphere4.xyz)-sphere4.w;\n    float ground_dist =  point.y;\n    \n    float t = length(point.xz - sphere.xz);\n    float t2 = length(point.xyz - sphere2.xyz);\n    float t3 = length(point.xyz - sphere3.xyz);\n    float t4 = length(point.xyz - sphere4.xyz);\n    bool is_background_obj = false;\n    if (t < 15.)\n    {\n        /// Tricks to add sin wave surface, not precise distance, wrong with big magnitude\n        float wave = 0.2 *pow(0.95, t)*  sin( 4. *pow(0.98, t) * t - bounce_frequen * iTime);\n        float wave2 = -10.  *pow(sphere2.w, 3.) * 0.15 *pow(0.8, t)*  sin(4. * t2);\n        float wave3 = -5.  *pow(sphere3.w, 3.) *0.15 *pow(0.8, t)*  sin(4. * t3);\n        float wave4 = -20.  *pow(sphere4.w, 3.)*0.15 *pow(0.9, t)*  sin(4. * t4);\n        //ground_dist += (wave);\n        ground_dist += (wave + wave2 + wave3 + wave4);\n    }\n    //else if (t <20.)\n      //  ground_dist =  point.y;\n    else\n        is_background_obj = true;\n    \n    \n    float d = \n            min(\n            min(\n            min(\n            min(sphere_dist, ground_dist),\n            sphere_dist2),\n            sphere_dist3),\n            sphere_dist4);\n    //float d = sphere_dist;\n    \n    float eps = 0.01;\n    if( abs(sphere_dist - d) < eps)\n        obj = 1;\n    else if( abs(sphere_dist2 - d) < eps)\n        obj = 2;\n    else if( abs(sphere_dist3 - d) < eps)\n        obj = 3;\n    else if( abs(sphere_dist4 - d) < eps)\n        obj = 4;\n    else\n        obj = 0; \n        \n    if(is_background_obj)\n        obj = -1;\n    \n    return d; \n}\n\nfloat RayMarch(vec3 ray_origin, vec3 ray_dir, out int obj)\n{\n    float d = 0.; \n    for(int i = 0; i < MAX_STEPS; i++)\n    {\n        vec3 p = ray_origin + ray_dir * d;\n        float ds = GetSceneDistance(p, obj); \n        d += ds; \n        if(d > MAX_DIST || ds < EPS) \n            break;  // hit object or out of scene\n    }\n    return d; \n}\n\nvec3 GetNormal(vec3 point)\n{\n    int obj_nouse;\n    float d = GetSceneDistance(point, obj_nouse); \n    vec2 e = vec2(0.01, 0); \n    vec3 n = d - vec3(\n        GetSceneDistance(point - e.xyy, obj_nouse),\n        GetSceneDistance(point - e.yxy,  obj_nouse),\n        GetSceneDistance(point - e.yyx, obj_nouse)\n    );\n    \n    return normalize(n); \n}\n\nfloat smoothStep(float edge0, float edge1, float x)\n{\n    \n    if (x < edge0)\n        return 0.;\n    if (x > edge1)\n        return 1.;\n    if(edge1 == edge0)\n        return 0.; \n    x = (x - edge0) / (edge1 - edge0);\n    return x*x * (3.-2.*x);\n}\n\nvec3 GetLight(bool is_ground, vec3 point, vec3 light_pos, vec3 light_col, vec3 camera_pos)\n{    \n    vec3 to_light = normalize(light_pos - point); \n    vec3 normal = GetNormal(point); \n        \n    //======== 1. diffuse ==========\n    bool in_shadow = false; \n    float NdotL = dot(to_light, normal);\n    float diffuse = NdotL > 0. ? 1. : 0.;\n    if(is_ground)\n    {\n        float NdotL_smooth = smoothStep(0.4, 1.0, NdotL);\n        diffuse = NdotL > 0.4 ? 1.0 : 0.5;\n    }\n        \n    // Shoot a ray towards light \n    int obj_nouse;\n    float d = RayMarch(point+normal*2.*EPS, to_light, obj_nouse);\n    \n    // Shadow \n    if (d < length(light_pos - point))\n    {\n        in_shadow = true;\n        diffuse *= 0.;\n    }        \n    \n    // ======== 2. ambient ===========\n    float ambient = 0.3; \n    \n    // ======== 3. specular ===========\n    vec3 to_camera = normalize(camera_pos - point);\n    vec3 half_vector = normalize(to_camera + to_light);\n    float NdotH = dot(normal, half_vector);\n    \n    float glossiness = 20.; \n    float specular = pow(NdotH, glossiness * glossiness);\n    float specular_smooth = smoothStep(0.005, 0.01, specular);\n    \n    // ======== 4. rim light ===========\n    float scale = 0.2;\n    if (is_ground)\n        scale = 0.3;\n    float rimDot = pow(NdotL, scale)* (1. - clamp(dot(to_camera, normal), 0., 1.));\n    float rimAmount = 0.616; \n    float rim = 0.5 *  smoothStep(rimAmount - 0.01, rimAmount+0.01, rimDot);\n    \n    // ======== Final light ==========\n    float intensity = 0.8; \n    \n    float sum = 0.;\n    if(in_shadow)\n        sum = (diffuse + ambient);\n    else\n        sum = (diffuse + ambient + specular_smooth + rim);\n    \n    vec3 light = intensity * sum * light_col ;\n    \n    return light;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from -0.5 to 0.5)\n    vec2 uv = (fragCoord - .5*iResolution.xy)/iResolution.x;\n\n    // Time varying pixel color\n    vec3 ray_origin = vec3(0, 1.5, -1);\n    vec3 ray_dir = normalize(vec3(uv.x, uv.y, 1.));\n    \n    // light\n    vec3 light_pos = vec3(3, 8, -1); \n    vec3 light_col = vec3(60.,179.,113.) / 255.;\n    //vec3 ground_col = vec3(120.,19.,27.) / 255.;\n    vec3 ground_col = vec3(105,26.,235.) / 255.;\n    vec3 light_col2 = vec3(10.,149.,237.) / 255.;\n    vec3 light_col3 = vec3(200.,100.,37.) / 255.;\n    vec3 light_col4 = vec3(100.,149.,27.) / 255.;\n    \n    float spin = 5.;\n    float range = 2.;\n    vec3 light_pos2 = light_pos + range* vec3(sin(spin*iTime), cos(spin *iTime), cos(spin*iTime));\n    \n    // \n    int obj = 0; \n    float d = RayMarch(ray_origin, ray_dir, obj);\n    \n    vec3 point = ray_origin + d * ray_dir; \n   \n    vec3 col; \n    if(obj == 1)\n        col = GetLight(false, point, light_pos2, light_col, ray_origin);\n    else if(obj == 2)\n        col = GetLight(false, point, light_pos2, light_col2, ray_origin);\n    else if(obj == 3)\n        col = GetLight(false, point, light_pos2, light_col3, ray_origin);\n    else if(obj == 4)\n        col = GetLight(false, point, light_pos2, light_col4, ray_origin);\n    else if(obj==-1)\n        col = ground_col * 0.1;\n    else\n        col = GetLight(true, point, light_pos, ground_col, ray_origin);\n    \n    col = pow(col, vec3(0.4545)); // Gamma correction\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}