{"ver":"0.1","info":{"id":"4Xl3DN","date":"1707774998","viewed":63,"name":"imperfect ellipsoid sdf","username":"playbyan1453","description":"Try to squeeze in one axis it will clearly wants to explode. I have tried a LOT of tinkering with codes here, from newton root solver and analytical approach and yet this one that I see the result. Such improvements are welcomed.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["3d","ellipsoid"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Ref : https://www.shadertoy.com/view/tt3yz7\n#define steps 256\n#define mint 1e-4\n#define maxt 1e1\n\nfloat sdEllipsoid(vec3 p, vec3 ra) {\n    vec3 pa = abs(p);\n    vec3 ei = 1.0 / ra;\n    vec3 r2 = ra * ra;\n    vec3 ve = ei * vec3(r2.x - max(r2.y, r2.z),\n                        r2.y - max(r2.x, r2.z),\n                        r2.z - max(r2.x, r2.y)); // I mostly believe the order affects the guess\n    \n    vec3 t = vec2(0.70710678118654752, 0.0).xyy; // or the initial\n    \n    for(int i = 0; i < 5; i++) {\n        vec3 v = ve * t * t * t;\n        vec3 u = normalize(pa - v) * distance(t * ra, v);\n        vec3 w = ei * (v + u);\n        t = normalize(clamp(w, 0.0, 1.0));\n    }\n    \n    vec3 na = t * ra;\n    float d = length(pa - na);\n    return dot(pa, pa) < dot(na, na) ? -d : d;\n}\n\nfloat map(vec3 p) {\n    return sdEllipsoid(p, vec4(1.0, 0.5, 0.25, 0.1).xxz);\n}\n\n// Draft, src : https://www.shadertoy.com/view/stB3zw\n/*\nfloat sdEllipsoid(vec3 p, vec3 ab) {\n    p = abs(p);\n    if(ab.y > ab.x && ab.y > ab.z) {\n        p = p.yxz;\n        ab = ab.yxz;\n    }\n\n    vec3 pab = p * ab;\n    float s1 = ab.x * ab.x - ab.y * ab.y - ab.z * ab.z;\n    float s2 = length(pab);\n    float offs = atan(pab.z, pab.y);\n\n    float t = 1.0;\n    for(int n = 0; n < 5; n++) {\n        float to = t + offs, t2 = 2.0 * t;\n        float y = 0.5 * s1 * sin(t2) + s2 * cos(to);\n        t -= y / (s1 * cos(t2) - s2 * sin(to));\n        if(abs(y) < 1e-7 * (s2 + s1)) break;\n    }\n\n    pab = p / ab;\n    return length(p - vec3(cos(t), sin(t), sin(t)) * ab) * sign(dot(pab, pab) - 1.0);\n}\n*/\n\nvec3 normal(vec3 p) {\n    const float e = mint;\n    const vec2 h = vec2( 1,-1);\n    return normalize(h.xyy * map(p + h.xyy*e)+\n                     h.yyx * map(p + h.yyx*e)+\n                     h.yxy * map(p + h.yxy*e)+\n                     h.xxx * map(p + h.xxx*e));\n}\n\nfloat raymarch(vec3 ro, vec3 rd) {\n    float t = 0.0;\n    for(int i = 0; i < steps; i++) {\n        float d = map(ro + rd * t);\n        t += d;\n        if(d < mint || t > maxt) break;\n    }\n    return t;\n}\n\nmat3 cam(vec3 at, vec3 ro) {\n    vec3 z = normalize(at - ro);\n    vec3 x = normalize(cross(vec3(0, 1, 0), z));\n    vec3 y = cross(z, x);\n    return mat3(x, y, z);\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n    vec2 uv = (2.0 * fragCoord - iResolution.xy) / max(iResolution.x, iResolution.y);\n    \n    vec3 at = vec3(0, 0, 0);\n    vec3 ro = vec3(sin(iTime) * 6.0, 0,-cos(iTime) * 6.0);\n    mat3 ca = cam(at, ro);\n    vec3 rd = ca * normalize(vec3(uv, 1));\n    \n    float t = raymarch(ro, rd);\n    \n    vec3 col = vec3(0);\n    vec3 n = rd;\n    if(t > mint && t < maxt) {\n        n = normal(ro + rd * t);\n    }\n    n *= ca;\n    \n\tfragColor = vec4(n * 0.5 + 0.5, 1);\n}","name":"Image","description":"","type":"image"}]}