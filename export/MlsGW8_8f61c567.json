{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[{"channel":0,"type":"texture","id":"XdfGRn","filepath":"/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"code":"#define BICUBIC\n#define SHADOWS  \n//#define COLOR_GRADIENT\n    \n#define time iTime\n#define resolution iResolution\n\n\nconst float MAX_STEPS = 1024.;\nconst float SX = 76.;\nconst float SY = 48.;\nconst float SZ = 80.;\n\nfloat NB_X = floor(MAX_STEPS/SX);\n\nconst float dval = .05;    // distance entre 2 valeurs significatives\nconst float dd = 1.;       // pas d'avancement du rendu volumique\nconst float _density = 1.; // densitee de la matiere\n\nconst float MinVal = .3,  \n            MaxVal = .5;\n\nvec3 Bounds;\n\n\nfloat hash1(float seed) {\n    return fract(sin(seed)*43758.5453123);\n}\n\n// -------------------------------------------------------\n\nbool box(vec3 ro, vec3 rd, vec3 sz, out float tN, out float tF, out vec3 n) {\n    vec3 m = 1./rd,\n         k = abs(m)*sz,\n         a = -m*ro-k*.5, b = a+k;\n    n = -sign(rd) * step(a.yzx,a.xyz) * step(a.zxy,a.xyz);\n    tN = max(max(a.x,a.y),a.z);\n    tF = min(min(b.x,b.y),b.z);\n    return tN<tF;\n}\n\n// - Bicubic --------------------------------------------------------\n// [iq: https://www.shadertoy.com/view/XsSXDy]\n\nvec4 BS_A = vec4(3.0,  -6.0,   0.0,  4.0 ) /  6.;\nvec4 BS_B = vec4(-1.0,   6.0, -12.0,  8.0 ) /  6.;\nvec4 powers( float x ) { return vec4(x*x*x, x*x, x, 1.0); }\n\nfloat spline(float x, float c0, float c1, float c2, float c3 ) {\n    return c0*dot( BS_B, powers(x + 1.)) + c1*dot( BS_A, powers(x      )) +\n           c2*dot( BS_A, powers(1. - x)) + c3*dot( BS_B, powers(2. - x));\n}\n\n#define SAM(a,b) textureLod(iChannel0, (i+vec2(a,b)+0.5)/res,0.).g\n\nfloat texture_Bicubic(sampler2D tex, vec2 t) {\n    vec2 res = iChannelResolution[0].xy;\n    vec2 p = res*t - 0.5, f = fract(p), i = floor(p);\n    return spline( f.y, spline( f.x, SAM(-1,-1), SAM( 0,-1), SAM( 1,-1), SAM( 2,-1)),\n                        spline( f.x, SAM(-1, 0), SAM( 0, 0), SAM( 1, 0), SAM( 2, 0)),\n                        spline( f.x, SAM(-1, 1), SAM( 0, 1), SAM( 1, 1), SAM( 2, 1)),\n                        spline( f.x, SAM(-1, 2), SAM( 0, 2), SAM( 1, 2), SAM( 2, 2)));\n}\n\n#ifdef BICUBIC\nfloat valueAt(in vec3 p) {\n    p*= 2.2;\n    float cval0 = texture_Bicubic(iChannel0, .6*p.xy/MAX_STEPS);\n    float cval1 = texture_Bicubic(iChannel0, .5*p.xz/MAX_STEPS);\n    // Values\n    float v0 = sqrt(cval0*cval1);  // true value = v0*255.\n    return clamp(.1+.3*abs(cos(iTime*.1)) + .5*v0/*.5*mix(v0, v1, fract(p.z))*/,0.,1.);\n}\n#else\nfloat valueAt(in vec3 p) {\n    p*= 1.8;\n    vec4 cval0 = textureLod(iChannel0, .6*p.xy/MAX_STEPS,0.);\n    vec4 cval1 = textureLod(iChannel0, .5*p.xz/MAX_STEPS,0.);\n    // Values\n    float v0 = sqrt(cval0.g*cval1.b) + (cval0.r*cval1.g);  // true value = v0*255.\n    return clamp(.1+.3*abs(cos(iTime*.1)) + .5*v0/*.5*mix(v0, v1, fract(p.z))*/,0.,1.);\n}\n#endif\n\n// ------------------------------------------------------------------\n\nvec3 normalAt(in vec3 p) {\n    vec2 e = vec2(0.1, -0.1); \n    return normalize(e.xyy * valueAt(p + e.xyy) + e.yyx * valueAt(p + e.yyx) + e.yxy * valueAt(p + e.yxy) + e.xxx * valueAt(p + e.xxx));;\n}\n\nconst vec2 ep2 = vec2(.5,-.5); \nvec3 gradAt(in vec3 p) {\n    return (ep2.xyy * valueAt(p + ep2.xyy) + ep2.yyx * valueAt(p + ep2.yyx) + ep2.yxy * valueAt(p + ep2.yxy) + ep2.xxx * valueAt(p + ep2.xxx));;\n}\n\n\n\n// -----------------------------------------------------------------\n\n\n\nfloat doShadow(vec3 ro, vec3 rd, float len) {\n    vec3 p2,n;\n    float dmin, dmax;\n    bool intersect = box(ro, rd, Bounds, dmin, dmax, n);\n    if (intersect) {   \n        float val,valId,d=min(.25,dmax); //, d=.5+.5*dd*hash1(ro.x+ro.y+ro.z);\n        // suivre cette direction et ajouter un truc a ao si on rtouve un obstacle avant dMax\n        for(int k=0;k<40; k++) {\n             if (d>=dmax) break;\n            p2 = ro + min(d,dmax) *rd;\n            val = valueAt(p2);\n            if (val >= MinVal && val < MaxVal) {\n                // on a rencontrÃ© un obstacle,\n                return clamp(mix(0.,1.,(min(d,dmax)/len)),0.,1.); // plus il est pres plus il a de l'influence\n            }\n            d+=.25*dd;\n\n        }\n    }\n    return 1.;\n}\n\n\nvec3 doShading(vec3 rd, vec3 pos, vec3 nor, vec3 lig, vec3 col, float t) {\n\n    vec3 ref = reflect( rd, nor );\t        \n    float occ = 1.; \n    float amb = .9;\n    float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n    float fre = pow( clamp(1.0+dot(nor,rd),0.0,1.0), 2.0 );\n    float spe = pow(clamp( dot( ref, lig ), 0.0, 1.0 ),16.0);\n    \n#ifdef SHADOWS\n    dif *= doShadow(pos, lig, 10. );\n#endif\n    vec3 brdf = vec3(0.0);\n    brdf += 1.20*dif*vec3(1.00,0.90,0.60);\n    brdf += 1.20*spe*vec3(1.00,0.90,0.60)*dif;\n    brdf += 0.30*amb*vec3(0.50,0.70,1.00)*occ;\n    brdf += 0.40*fre*vec3(1.00,1.00,1.00)*occ;\n    brdf += 0.4;\n    return col*brdf; //sqrt(brdf);\n}\n\nvec3 heatmapGradient(in float t) {\n    return clamp((pow(t, 1.5) * .8 + .2) * vec3(smoothstep(0., .35, t) + t * .5, smoothstep(.5, 1., t), max(1. - t * 1.7, t * 7. - 6.)), 0., 1.);\n}\n\nvec3 getColor(float val) {\n#ifndef COLOR_GRADIENT    \n    val = floor(val/dval)*dval;                \n#endif    \n    return heatmapGradient(1.5*val);\n}\n\n// -------------------------------------------------------------------------------\n\nmat3 LookAt(in vec3 ro, in vec3 up){\n    vec3 fw = normalize(ro),\n         rt = normalize(cross(fw,up));\n    return mat3(rt, cross(rt,fw), fw);\n}\n\nvec2 globalFragCoord;\nvec3 RD(in vec3 ro, in vec3 cp) {\n    return LookAt(cp-ro, vec3(0,1,0)) * normalize(vec3((2.*globalFragCoord.xy-resolution.xy)/resolution.y, 5.));\n}\n\n// -------------------------------------------------------------------------------\n\nfloat isoline(float val, vec3 p, vec3 n, float pas, float tickness) {\n    vec3 grad = gradAt(p);\n    grad -= n*dot(grad,n);\n    float v = abs(mod((val)+pas*.5, pas)-pas*.5)*(resolution.x*ep2.x)/(100.*length(grad)*tickness);\n    float v1 = abs(val-MinVal)*(resolution.x*ep2.x)/(200.*length(grad)*tickness);\n    float v2 = abs(val-MaxVal)*(resolution.x*ep2.x)/(200.*length(grad)*tickness);\n    return smoothstep(.1,.9, v)*smoothstep(.3,.7, v1)*smoothstep(.3,.7, v2);\n}\n\n\n// -----------------------------------------------------------------\n\n\nfloat preciseSurface(vec3 ro, vec3 rd, float val, float dmin, float dmax, float sig) {\n    float dm = dmin;\n    val *= sig;\n    for (int j=0; j<6;j++) {\n       dm = (dmin + dmax)*.5;  // on dÃ©termine l'indice de milieu\n       if (valueAt(ro+rd*dm)*sig > val) dmax = dm;  //si la valeur qui est Ã  la case \"im\" est supÃ©rieure Ã  la valeur recherchÃ©e, l'indice de fin \"ifin\" << devient >> l'indice de milieu\n       else dmin = dm;               //sinon l'indice de dÃ©but << devient >> l'indice de milieu et l'intervalle est de la mÃªme faÃ§on restreint\n    }\n    return dm;  \n}\n\nfloat findPosOfVal(vec3 ro, vec3 rd, float val, float dmin, float dmax, float dd2) {\n    vec3 p = ro+rd*dmin;\n    float v, d, sig = sign(val - valueAt(p));\n    d = dmin+dd2+hash1(rd.y*(p.x+p.y+p.z));\n\n    for (int i=0; i<100; i++) {\n        v = valueAt(ro+rd*d);\n    \tif ((d>=dmax+dd2) || (sig*(v-val)>0.)) \n            break;\n        d += dd2;\n    }\n    return (sig*(v-val)>0.) ? preciseSurface(ro, rd, val, d-dd, d, sig) : d;\n}\n\n  \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    globalFragCoord = fragCoord;\n    Bounds = vec3(.8*SX, .7*SY, abs(.5)*SZ);\n  \n    vec2 q = fragCoord.xy/resolution.xy;\n\n    vec3 lightDir = -normalize(vec3(1.,-5.,6.5));\n    \n    vec3 ro = 180.*vec3(cos(.5*time-3.*iMouse.x/resolution.x), cos(.5*time*.3), sin(.5*time-3.*iMouse.x/resolution.x)*sin(.5*time*.3));\n    vec3 rd = RD(ro, vec3(0));\n    \n    vec4 cSum = vec4(0);\n    vec3 n,p;\n    \n    float d, dmin, dmax,\n          val, valIdMem, valId, v0;\n       \n    vec3 col = vec3(.22,.26,.28) * pow(16.0*q.x*q.y*(1.-q.x)*(1.-q.y),.3);\n\n    if (box(ro, rd, Bounds, dmin, dmax, n) && dmin>0.) {\n       p = ro+rd*(dmin);\n       v0 = valueAt(p);\n\n       if (v0 >= MinVal && v0 <= MaxVal) {\n           col = doShading(rd,p,n,lightDir, getColor(v0), d);\n           col = col*isoline(v0, p, n, dval, 1.);\n       } else {\n           val = (v0<=MinVal) ? MinVal : MaxVal;\n           d = findPosOfVal(ro, rd, val, dmin, dmax, dd);\n\t\t   if (d<dmax) {\n            \tp = ro+rd*d;\n            \tn = sign(v0-MinVal)*normalAt(p);\n           \t\tcol = doShading(rd,p,n, lightDir, getColor(val-.02), d);\n           }\n     \t}\n    }\n\n   \tfragColor = vec4(col,1);  \n}\n","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"MlsGW8","date":"1421769097","viewed":2044,"name":"Iso Surface","username":"iapafoto","description":"isosurface volume rendering ","likes":50,"published":1,"flags":0,"usePreview":1,"tags":["isosurface","isoline"],"hasliked":0,"parentid":"","parentname":""}}