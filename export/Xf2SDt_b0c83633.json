{"ver":"0.1","info":{"id":"Xf2SDt","date":"1707178527","viewed":66,"name":"Beyond","username":"andreibazzaev","description":"My first test shader, as an outcome of learning raymarching techniques.\n","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raymarchinglearning"],"hasliked":0,"parentid":"lcSXDd","parentname":"Learn Ray Marching P5"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Camera params\nstruct Camera{\n    float fovX;\n    float fovY;\n    vec3 pos;\n};\n\nstruct Ray{\n    vec3 o;\n    vec3 d;\n};\n\n// Ray marching values\nconst int MaxSteps = 100;\nconst float MinDist = 0.f;\nconst float MaxDist = 1000.f;\nconst float epsilon = 0.0001f;\n\n// Glow, Fake AO, Fake Glass\n//https://www.youtube.com/watch?v=f-VQfigEoO0&t=2577s&ab_channel=ACMSIGGRAPH\nfloat GlowVal = 0.f;\nfloat FakeAO = 0.f;\nvec3 BallCol = vec3(0.f, 0.f, 0.f);\nvec3 LineCol = vec3(0.f, 0.f, 0.f);\nfloat Progress = -1.f;\n\n// Fisheye RayGen\n// ref. Ray Tracing Gems II\nRay GetFisheyeRay(Camera cam, vec2 fragCoord, vec2 resolution) {\n    vec2 clampedHalfFOV = vec2(min(radians(cam.fovX), PI),min(radians(cam.fovY) , PI)) / 2.f;\n    vec2 angle = (fragCoord - resolution / 2.f) * clampedHalfFOV;\n\n     // Don't generate rays for pixels outside the fisheye\n     if (length(angle) > 0.5f * PI) {\n         return Ray(cam.pos - vec3(100000.f), vec3(0.f));\n     }\n     vec3 dir = normalize(vec3(sin(angle.x), -sin(angle.y) * cos(angle.x), - cos(angle.x) * cos(angle.y)));\n     return Ray(cam.pos, dir);\n}\n\nfloat SceneSDF(vec3 pos, out vec3 id){\n    // Cylinders\n    vec3 cpos = pos;\n    cpos = GetInfinitePosWithID(pos + vec3(0.0, 25.f, 0.f), vec3(10.f, 50.f, 10000.f), id);\n    cpos.x += sin(cpos.z / 10.f * sin(id.x * 41.3 + id.y * 15.4f + iTime* 0.1)) * 2.f;\n    cpos.y += sin(cpos.z / 5.f * sin(id.x * 11.3 + id.y * 22.4f + iTime * 0.2)) * 3.f;\n    float cdist = CyliderSDF(cpos);\n    LineCol = GetColorFromPalette( sin(id.x * 26.3f + id.y * 278.2f), vec3(0.5, 0.5, 0.5), vec3(0.5, 0.5, 0.5),vec3(2.f, 1.f, 0.f),vec3(0.50, 0.20, 0.25));\n    // Sphere\n    float sphereZ = 0.f;\n    if(Progress > 0.f) sphereZ = EaseOutBack(Progress) * 5.f;\n    vec3 spos = abs(vec3(pos.xy * RotateCenter(iTime), pos.z - sphereZ)) - vec3(0.7f, 0.7f,0.f);\n    float sdist = SphereSDF(spos / 0.3f) * 0.3f;\n      // Add glow effect\n    GlowVal += 0.1 / (0.1 + sdist * sdist);\n    return Union(cdist, sdist);\n}\n\nfloat GetShortestSceneDist(Ray ray, out vec3 id){\n    float depth = MinDist;\n    FakeAO = 0.f;\n    for (int i = 0; i < MaxSteps; i++){\n        vec3 ckeckPos = ray.o + ray.d * depth;\n        float dist = SceneSDF(ckeckPos, id);\n        if(dist < epsilon){\n            FakeAO = float(i) / float(MaxSteps); // How hard it was to get to the point\n            return depth;\n        }\n        else{\n            depth += dist;\n            if(depth >= MaxDist){\n                return MaxDist;\n            }\n        }\n    }\n    return MaxDist;\n}\n\nvec3 GetColor(Ray ray){\n    vec3 id = vec3(0.f, 0.f, 0.f);\n    float dist = GetShortestSceneDist(ray, id);\n    // Miss\n    if (dist > MaxDist - epsilon){\n        return vec3(0.f ,0.f, 0.f);\n    }\n    // Hit\n    else{\n          vec3 col = LineCol;\n          // Apply AO\n          col *= 1.f - FakeAO;\n          return col * 250.f / dist;\n    }\n}\n\n//https://jamie-wong.com/2016/07/15/ray-marching-signed-distance-functions/\nmat4 GetLookAtMatrix(vec3 eye, vec3 center, vec3 up) {\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat4(\n        vec4(s, 0.0),\n        vec4(u, 0.0),\n        vec4(-f, 0.0),\n        vec4(0.0, 0.0, 0.0, 1)\n    );\n}\n\nvoid FisheyePart(out vec4 fragColor, in vec2 fragCoord, in float progress){\n    float seed = hash12(fragCoord * iTime);\n    \n    float ratio = fragCoord.x / iResolution.x;\n    ratio = clamp((ratio - 0.7) * 3.33f, 0.f, 1.f);\n    \n    // Line Bending, using fisheye of different fov\n    float camFov = mix(0.8, 0.3, ratio);\n    if(ratio + sin(seed) * sin( (fragCoord.y + sin(seed * 13.3f) * 10.f) /10.f) * 0.2 > progress){\n        camFov = 0.8;\n    }\n    \n    float camZ = 0.f;\n    if(progress == -1.f){\n        \n        if(sin(iTime) >= 0.f) {\n            float time = mod(iTime, PI);\n            camZ =  20.f * EaseOutBack(time / PI);\n        }\n        else {\n            float time = mod(iTime, PI * 0.5f);\n            camZ =  20.f * EaseOutBack(1.f - time / (PI * 0.5f));\n        }\n    }\n    Camera cam = Camera(camFov, camFov, vec3(-5.f, 0.f, camZ));\n    \n    BallCol = GetColorFromPalette( sin(iTime), vec3(0.5, 0.5, 0.5), vec3(0.5, 0.5, 0.5),vec3(2.f, 1.f, 0.f),vec3(0.50, 0.20, 0.25));\n    Ray ray = GetFisheyeRay(cam, fragCoord+ vec2(sin(seed * 11.3f), sin (seed * 321.6f)), iResolution.xy);\n    \n    mat4 viewToWorld = GetLookAtMatrix(cam.pos, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    ray.d = (viewToWorld * vec4(ray.d, 0.0)).xyz;\n    vec3 col = GetColor(ray);\n    // Add glow to the final color\n    col += BallCol * GlowVal * 0.7;\n    fragColor = vec4(col, 1.f);\n}\n\nvec2 GetGlassOffset(in vec2 fragCoord){\n    \n    vec2 offset = vec2(0.f, 0.f);\n    for(float i = 0.f; i < 40.f; i += 1.f){\n        float seed = hash12(vec2(143.5f, 12.7f) * i);\n        vec2 center = vec2((1.4f + abs(sin(seed * 156.2)) * EaseOutBack(Progress)) * (iResolution.x / 2.f),  (1.f + sin(seed * 16.2) * EaseOutBack(Progress) * 1.0f) * iResolution.y / 2.f);\n        float r = 20.f + abs(sin(seed * 56.7)) * 50.f;\n        vec2 p0 = center + r * vec2(sin(seed * 12.6), cos(seed * 82.4));\n        vec2 p1 = center + r * vec2(sin(seed * 132.9), cos(seed * 98.2));\n        vec2 p2 = center + r * vec2(sin(seed * 76.7), cos(seed * 46.9));\n        bool inside = PointInsideTriangle(fragCoord, p0, p1, p2);\n        offset += inside ? vec2( sin(seed* i * 36.9) * 15.0f, 5.f + sin(seed* i * 136.2) * 15.0f) : vec2(0.f,0.f);\n    }\n    return offset;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Calculate the time elapsed since the beginning\n    float elapsedTime = mod(iTime, 4.f * PI);\n    Progress = -1.f;\n    // Check the current state based on the elapsed time\n    if (elapsedTime < 1.5 * PI) {\n        FisheyePart(fragColor, fragCoord, -1.f);\n    } \n    else if (elapsedTime < 4.f * PI) {\n         \n        Progress = (elapsedTime / PI - 1.5f)/ 2.5f;\n        if(Progress > 0.5f) Progress = 1.f - Progress;\n        \n        // Add Glass Shards\n        vec2 offset = GetGlassOffset(fragCoord);\n        fragCoord += offset;\n         \n        FisheyePart(fragColor, fragCoord, EaseOutBack(Progress) * 2.5f);\n        // Add Slight Brightness to Glass Shards\n        fragColor += vec4(clamp(offset.y, 0.f, 1.f)) * 0.1f;\n    }\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define PI 3.1415926f\n\nfloat SphereSDF(vec3 pos){\n    return length(pos) - 1.0f;\n}\nfloat CyliderSDF(vec3 pos){\n    return length(pos.xy) - 1.0f;\n}\n\nbool PointInsideTriangle(vec2 p, vec2 p0, vec2 p1, vec2 p2) {\n    vec2 e0 = p1 - p0, e1 = p2 - p0, e2 = p - p0;\n    float dot00 = dot(e0, e0);\n    float dot01 = dot(e0, e1);\n    float dot02 = dot(e0, e2);\n    float dot11 = dot(e1, e1);\n    float dot12 = dot(e1, e2);\n    float invDenom = 1.0 / (dot00 * dot11 - dot01 * dot01);\n    float u = (dot11 * dot02 - dot01 * dot12) * invDenom;\n    float v = (dot00 * dot12 - dot01 * dot02) * invDenom;\n    return (u >= 0.0) && (v >= 0.0) && (u + v < 1.0);\n}\n\nfloat Union(float d1, float d2) {\n    return min(d1, d2);\n}\n\n// Transforms\nmat2 RotateCenter(float angle){\n    return mat2(cos(angle), sin(angle), - sin(angle), cos(angle));\n}\n\n// Domain Repetition (Advanced)\n// Adding ID\nvec3 GetInfinitePosWithID(vec3 pos, vec3 spacing, out vec3 id){\n     id = round(pos / spacing);\n     return pos - spacing * id;\n}\n// Random\n// by Dave_Hoskins\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n// Color pallets\n//https://iquilezles.org/articles/palettes/\nvec3 GetColorFromPalette( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b * cos(6.28318 * (c * t + d));\n}\n\n// Animation\n// https://easings.net/\nfloat EaseOutBack(float x) {\n    float c1 = 1.70158f;\n    float c3 = c1 + 1.f;\n    return 1.f + c3 * pow(x - 1.f, 3.f) + c1 * pow(x - 1.f, 2.f);\n}\n\n","name":"Common","description":"","type":"common"}]}