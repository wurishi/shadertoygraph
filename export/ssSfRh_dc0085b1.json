{"ver":"0.1","info":{"id":"ssSfRh","date":"1645756181","viewed":123,"name":"HPP Lattice Grid Automata Gas","username":"ebopalisesy","description":"Demonstration of encoding integer values into the LSBs of a vec3.","likes":5,"published":1,"flags":32,"usePreview":0,"tags":["simulation","steganography"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n * The main image shader just copies iChannel0 to the output.\n * This is to more closely mimic the available environment in\n * the Shader Editor live wallpaper, which is what this shader\n * is eventaully intended to be used in.\n */\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    fragColor = texture(iChannel0, uv);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// #version 300 es\n#define SHADERTOY\n\n// In order to get this to work on Shader Editor, comment out the SHADERTOY define\n// and comment in the #version tag.\n\n/********** SHADERTOY COMPAT ***********/\n// Shadertoy uses different input names from Shader Editor.\n#ifdef SHADERTOY\n#define resolution iResolution\n#define backbuffer iChannel0\n#define noise iChannel1\n#define touch iMouse\n#define time iTime\n#define gl_FragCoord fragCoord\n#define pointerCount 1\n#define NOISE_CUTOFF 0.7\n// Shadertoy provides far higher resolution for color storage, so we can get away with a much\n// higher value for FLOAT_MAX there.\n#define FLOAT_MAX pow(2.0, 15.0)\n#else\nuniform sampler2D backbuffer;\nuniform sampler2D noise;\nuniform vec2 resolution;\nuniform vec2 touch;\nuniform float time;\nuniform int pointerCount;\nout vec4 fragColor;\n#define NOISE_CUTOFF 0.5\n// Shader Editor clamps our color values, so we're limited to 7 bits of color resolution.\n#define FLOAT_MAX pow(2.0, 7.0)\n#endif\n\n// We only need 5 bits, so set the steganography parameters to hold\n// 6 bits total.\n#define BITS_PER_CHANNEL 2\n\n// Shader Editor absolutely destroys the precision of any colors in the output buffer\n// (potentially as bad as 7 bits worth of color precision), so there's no point in\n// using highp floats.\nprecision mediump float;\n\n\n/*********** STEGANOGRAPHIC STUFF ************/\n\n// Convenience function to pull out a single \"bit\" from a large float (just modulo by 2^bit).\nint getBit(float v, int bit) {\n    return int(mod(v / pow(2.0, float(bit)), 2.0));\n}\n\n// Pulls out 3 * BITS_PER_CHANNEL bits of data from the \"LSB\" of the R, G, B channels\nint decode(vec3 color) {\n    vec3 ex = round(color * FLOAT_MAX);\n    int data = 0;\n    for (int i = 0; i < BITS_PER_CHANNEL; i++) {\n        data |= getBit(ex.r, i) << (i);\n        data |= getBit(ex.g, i) << (i + BITS_PER_CHANNEL);\n        data |= getBit(ex.b, i) << (i + 2 * BITS_PER_CHANNEL);\n    }\n    return data;\n}\n\n\n// Encode up to 3 * BITS_PER_CHANNEL bits of data in the given vec3's \"LSBs\".\nvec3 encode(vec3 color, int data) {\n    vec3 ex = color * FLOAT_MAX;\n    ex = min(ex, FLOAT_MAX);\n    ex /= pow(2.0, float(BITS_PER_CHANNEL));\n    // This is a *hack* that makes it work with an initial value of 1.0, but seems to\n    // kind of break encoding of 0.0\n    ex -= vec3(1.0, 1.0, 1.0) / FLOAT_MAX;\n    ex = floor(ex);\n    ex *= pow(2.0, float(BITS_PER_CHANNEL));\n    ex.r += float(data & int(pow(2.0, float(BITS_PER_CHANNEL)) - 1.0));\n    ex.g += float((data >> BITS_PER_CHANNEL) & int(pow(2.0, float(BITS_PER_CHANNEL)) - 1.0));\n    ex.b += float((data >> (BITS_PER_CHANNEL * 2)) & int(pow(2.0, float(BITS_PER_CHANNEL)) - 1.0));\n    ex /= FLOAT_MAX;\n    return ex;\n}\n\n\n// Get the RGB value of the pixel at the given offset from pix\nvec4 get(vec2 pix, vec2 offset) {\n    return texture(backbuffer, (pix + offset) / resolution.xy);\n}\n\n// Do the movement step for a single vector.  This essentially just looks in the given\n// direction for a vector that should move into this cell, and returns the vector if it\n// exists in the adjacent cell.  It also handles reflections off of the black border at the edge.\nint getNeighborOrReflect(vec2 pix, vec2 offset, int data, int bit) {\n    const int reflections[4] = int[4](0x2, 0x1, 0x8, 0x4);\n\n    vec2 neighbor = (pix + offset);\n    // Can't really figure out why, but we need to leave a 1px black border.\n    if ((pix.x < 1.0 || pix.y < 1.0 || pix.x > resolution.x - 1.0 || pix.y > resolution.y - 1.0)) {\n        return 0;\n    }\n    if ((neighbor.x < 1.0 || neighbor.y < 1.0 || neighbor.x > resolution.x - 1.0 || neighbor.y > resolution.y - 1.0)\n         && (data & reflections[bit]) != 0) {\n        return 1 << bit;\n    }\n    return decode(get(pix, offset).rgb) & (1 << bit);\n}\n\n/********************* SIMULATION *******************/\n/*\n * Bit 0 indicates the prescence of an up vector.\n * Bit 1 is for a down vector.\n * Bit 2 is for a left vector.\n * Bit 3 is for a right vector.\n * Bit 4 is for the time information - 0 if a collision step\n *        is next, 1 if a movement step is next.\n */\n\n\nint collide(int data) {\n    // This is just implemented as a lookup table.\n                                       //    D    U    DU\n    const int collisions[16] = int[16](0x0, 0x1, 0x2, 0xC,\n                              /* L */  0x4, 0x5, 0x6, 0x7,\n                              /* R */  0x8, 0x9, 0xA, 0xB,\n                              /* LR*/  0x3, 0xD, 0xE, 0xF);\n\n    return collisions[data & 0xF];\n}\n\nint move(vec2 coord, int data) {\n    return getNeighborOrReflect(coord, vec2(0, 1), data, 0) |\n           getNeighborOrReflect(coord, vec2(0, -1), data, 1) |\n           getNeighborOrReflect(coord, vec2(-1, 0), data, 2) |\n           getNeighborOrReflect(coord, vec2(1, 0), data, 3);\n}\n\n\n// For the Gaussian blur, a 5x5 kernel defined as a constant\n#define SIGMA 2.0\n#define GB(x, y) (2.0/(2.0 * 3.1415926 * SIGMA * SIGMA) * exp(-1.0 * (float(x) * float(x) + float(y) * float(y)) / (2.0 * SIGMA * SIGMA)))\nconst float kernel[25] = float[25](GB(2,2), GB(1,2), GB(0,2), GB(1,2), GB(2,2),\n                    GB(2,1), GB(1,1), GB(0,1), GB(1,1), GB(2,1),\n                    GB(2,0), GB(1,0), GB(0,0), GB(1,0), GB(2,0),\n                    GB(2,1), GB(1,1), GB(0,1), GB(1,1), GB(2,1),\n                    GB(2,2), GB(1,2), GB(0,2), GB(1,2), GB(2,2));\n\n// Apply the Gaussian kernel to the current pixel.\nfloat gaussian(vec2 coord) {\n    float sum = 0.0;\n    for (int x = -2; x <= 2; x++) {\n        for(int y = -2; y <= 2; y++) {\n            int data = decode(get(coord, vec2(x, y)).rgb);\n            if ((data & 0xF) != 0) {\n                sum += kernel[x * 5 + y];\n            }\n        }\n    }\n    return sum;\n}\n\n\n#ifdef SHADERTOY\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n#else\nvoid main()\n#endif\n{\n    vec2 uv = gl_FragCoord.xy / resolution.xy;\n    vec2 pix = gl_FragCoord.xy;\n    vec3 color = texture(backbuffer, uv).rgb;\n\n    if (time < 0.06) {\n        color = vec3(uv, abs(sin(uv.x * uv.y * 2.0)));\n        // if (uv.x > 0.4 && uv.x < 0.7 && uv.y > 0.4 && uv.y < 0.7) {\n        // We can't allow pixels in the border region to be set, as they'll just spawn particles indefinitely without moving\n        // this is also a massive hack since it just... doesn't work sometimes?\n        if (texture(noise, uv).r > NOISE_CUTOFF && \n        \t     pix.y > 1.0) {\n            color = encode(color, 0xf);\n        } else {\n            color = encode(color, 0);\n        }\n    }\n\n    // Grab the vector data from the previous frame\n    int data = decode(color);\n\n    // mouse can spawn particles\n    if (distance(touch.xy, pix) < 5.0 && pointerCount > 0) {\n        data |= 0xF;\n    }\n    \n    // Do the actual collision / movement step\n    if ((data & 0x10) != 0) {\n        data = move(pix.xy, data);\n    } else {\n        data = collide(data) | 0x10;\n    }\n\n    // Color the output based on whether or not there's at least\n    // one particle there\n    //if ((data & 0xF) != 0) {\n        // color = vec3(1.0, 1.0, 1.0);\n        float strength = gaussian(pix);\n        color = vec3(uv.x, 1.0 - uv.y, uv.y) * strength;\n    //} else {\n    //    color = vec3(0.1, 0.0, 0.1);\n    //}\n\n    // Finally, encode the new vector data back into the newly selected color\n    color = encode(color, data);\n\n    fragColor = vec4(color, 1.0);\n}","name":"Buffer A","description":"","type":"buffer"}]}