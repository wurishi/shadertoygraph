{"ver":"0.1","info":{"id":"3sycDD","date":"1602820153","viewed":109,"name":"DronesyInSpace","username":"vageev01","description":"intro for web game","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["game","intro"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdfGRn","filepath":"/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","previewfilepath":"/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// --- access to the image of ascii code c // from Fabrice ;\n#define C(c) U.x-=.5; T+= U.x<.0||U.x>1.||U.y<0.||U.y>1. ?vec4(0): texture( iChannel0, U/16. + fract( floor(vec2(c, 15.999-float(c/16))) / 16.))/1.5\n\n\n\nfloat shtoy(vec2 U) { // to alter in the icon with the alter message\n    vec4 T = vec4(0); \n    C(32);C(32);C(32);C(32);C(32);C(32);C(32);C(68);C(82);C(79);C(78);C(69);C(83);C(89);C(32);C(32);C(32);C(32);C(32);C(32);C(32);C(32);\n  \n    return length(T.yz)==0. ? 0. : T.x;\n}\n\n\n \n\n\n#define dir 2    // define direction 0,1,2,3  up/down/left/right\n#define time iTime\n#define speed 0.4\n\nvec2 mod289(vec2 x) {\n\t\t  return x - floor(x * (1.0 / 289.0)) * 289.0;\n\t\t}\n\n\t\tvec3 mod289(vec3 x) {\n\t\t  \treturn x - floor(x * (1.0 / 289.0)) * 289.0;\n\t\t}\n\t\t\n\t\tvec4 mod289(vec4 x) {\n\t\t  \treturn x - floor(x * (1.0 / 289.0)) * 289.0;\n\t\t}\n\t\t\n\t\tvec3 permute(vec3 x) {\n\t\t  return mod289(((x*34.0)+1.0)*x);\n\t\t}\n\n\t\tvec4 permute(vec4 x) {\n\t\t  return mod((34.0 * x + 1.0) * x, 289.0);\n\t\t}\n\n\t\tvec4 taylorInvSqrt(vec4 r)\n\t\t{\n\t\t  \treturn 1.79284291400159 - 0.85373472095314 * r;\n\t\t}\n\t\t\n\t\tfloat snoise(vec2 v)\n\t\t{\n\t\t\t\tconst vec4 C = vec4(0.211324865405187,0.366025403784439,-0.577350269189626,0.024390243902439);\n\t\t\t\tvec2 i  = floor(v + dot(v, C.yy) );\n\t\t\t\tvec2 x0 = v -   i + dot(i, C.xx);\n\t\t\t\t\n\t\t\t\tvec2 i1;\n\t\t\t\ti1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n\t\t\t\tvec4 x12 = x0.xyxy + C.xxzz;\n\t\t\t\tx12.xy -= i1;\n\t\t\t\t\n\t\t\t\ti = mod289(i); // Avoid truncation effects in permutation\n\t\t\t\tvec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n\t\t\t\t\t+ i.x + vec3(0.0, i1.x, 1.0 ));\n\t\t\t\t\n\t\t\t\tvec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\n\t\t\t\tm = m*m ;\n\t\t\t\tm = m*m ;\n\t\t\t\t\n\t\t\t\tvec3 x = 2.0 * fract(p * C.www) - 1.0;\n\t\t\t\tvec3 h = abs(x) - 0.5;\n\t\t\t\tvec3 ox = floor(x + 0.5);\n\t\t\t\tvec3 a0 = x - ox;\n\t\t\t\t\n\t\t\t\tm *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n\t\t\t\t\n\t\t\t\tvec3 g;\n\t\t\t\tg.x  = a0.x  * x0.x  + h.x  * x0.y;\n\t\t\t\tg.yz = a0.yz * x12.xz + h.yz * x12.yw;\n\n\t\t\t\treturn 130.0 * dot(m, g);\t\t\n\t\t}\n\t\t\n\t\tfloat cellular2x2(vec2 P)\n\t\t{\n\t\t\t\t#define K 0.142857142857 // 1/7\n\t\t\t\t#define K2 0.0714285714285 // K/2\n\t\t\t\t#define jitter 0.8 // jitter 1.0 makes F1 wrong more often\n\t\t\t\t\n\t\t\t\tvec2 Pi = mod(floor(P), 289.0);\n\t\t\t\tvec2 Pf = fract(P);\n\t\t\t\tvec4 Pfx = Pf.x + vec4(-0.5, -1.5, -0.5, -1.5);\n\t\t\t\tvec4 Pfy = Pf.y + vec4(-0.5, -0.5, -1.5, -1.5);\n\t\t\t\tvec4 p = permute(Pi.x + vec4(0.0, 1.0, 0.0, 1.0));\n\t\t\t\tp = permute(p + Pi.y + vec4(0.0, 0.0, 1.0, 1.0));\n\t\t\t\tvec4 ox = mod(p, 7.0)*K+K2;\n\t\t\t\tvec4 oy = mod(floor(p*K),7.0)*K+K2;\n\t\t\t\tvec4 dx = Pfx + jitter*ox;\n\t\t\t\tvec4 dy = Pfy + jitter*oy;\n\t\t\t\tvec4 d = dx * dx + dy * dy; // d11, d12, d21 and d22, squared\n\t\t\t\t// Sort out the two smallest distances\n\t\t\t\t\n\t\t\t\t// Cheat and pick only F1\n\t\t\t\td.xy = min(d.xy, d.zw);\n\t\t\t\td.x = min(d.x, d.y);\n\t\t\t\treturn d.x; // F1 duplicated, F2 not computed\n\t\t}\n\n\n#define PI 3.14159265358979\n\nconst float pi = 3.14159;\nmat3 xrot(float t)\n{    return mat3(1.0, 0.0, 0.0,\n    0.0, cos(t), -sin(t),\n    0.0, sin(t), cos(t));\n}\nmat3 yrot(float t)\n{    return mat3(cos(t), 0.0, -sin(t),\n    0.0, 1.0, 0.0,\n    sin(t), 0.0, cos(t));\n}\n\nmat3 zrot(float t)\n{    return mat3(cos(t), -sin(t), 0.0,\n    sin(t), cos(t), 0.0,\n    0.0, 0.0, 1.0);\n}\n\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nvec2 uv (vec3 p) {\n\tfloat x = p.x;\n    float y = p.y;\n    float z = p.z;\n    float u = atan(x, z) / (2. * PI) + .5;\n    float v = asin(y) / (PI) + .5;\n    return vec2(u,v);\n}\n\n\n\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) +\n    length(max(d,0.0));\n}\n\nfloat udBox( vec3 p, vec3 b, float r )\n{\n\treturn length(max(abs(p)-b,0.0))-r;\n}\nfloat sdCylinder( vec3 p, vec2 h )\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\nvec2 map(vec3 p)\n{\n    vec2 f=(fract(p.xy) * 2.0 - 1.0) ;\n    vec3 q = vec3(f.x-0.5, f.y, p.z);\n    float br = 0.4;\n    float c = sdCylinder(  p+vec3( 0.0,0.60,-1.0), vec2(3.0,3.0)  );\n   // float b = sdCylinder(p, vec2(1.1,1.3))*br;\n    \n  //  float b= sdBox(p-vec3( 0.0,0.25, 0.0), vec3(0.65) );\n \n    float  ss = sdSphere(    p-vec3( 0.0,0.00, 0.0),1.00 )  ;\n  \n    return vec2(ss, ss);\n    \n}\nvec3 normal(vec3 p)\n{\n    vec3 o = vec3(0.02, 0.0, 0.0);\n    return normalize(vec3(map(p+o.xyy).x - map(p-o.xyy).x,\n    map(p+o.yxy).x - map(p-o.yxy).x,\n    map(p+o.yyx).x - map(p-o.yyx).x));\n}\nfloat trace(vec3 o, vec3 r)\n{\n    float t = 0.0;\n    for (int i = 0; i < 32; ++i) {\n    vec3 p = o + r * t;\n    float d = map(p).x;\n    t += d;\n\t}\nreturn t;\n}\n\nvec4 tex(vec3 p)\n{\n    \n    \n    vec4 tx= texture(iChannel1,uv(normalize(p)));\n    \n    return (tx ) ;\n}\n\n\n\n\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n   \n    \n    float t=iTime*3.0;\n    \n     \n    vec2 uv3 = fragCoord.xy / iResolution.xy;\n   \t\t uv3 = uv3 * 2.0 - 1.0;\n   \t\t uv3.x *=iResolution.x/iResolution.y;    \n \n    \n    \n    vec2 uv = fragCoord.xy / iResolution.xy ;\n\t\t\t\n\t\tuv.x*=(iResolution.x/iResolution.y);\n    \n    vec2 uvs = uv*2.-1.0;\n    \n    float rot = radians(iTime * 360.0)/30.0;\n    \n     \n    \n    mat2 m = mat2(cos(rot), -sin(rot), sin(rot), cos(rot));\n   \t\n    float gtimer = iTime;\n    \n    uv = uv -0.5;\n    if (gtimer>30.0) {  uv  = m * uv;\n    \t\t\t\t\tuv +=vec2(0.5,0.0);\n    }\n    if (gtimer>60.0) {  uv  = m * -uv;\n    \t\t\t\t\tuv +=vec2(0.5,0.0);\n    }\n\t\t\t\t\t\n\t\tvec2 GA=vec2(0);\n\t\t\t\t\n        #if dir==0 \n        GA.y +=time*speed;\n        #elif dir==1\n        GA.y -=time*speed;\n        #elif dir==2\n        GA.x +=time*speed;\n        #elif dir==3\n        GA.x -=time*speed;\n        #endif\n\t\t\n    \t// multi declaration \n        float   F1,F2,F3,F4,F5,F6,F7,F8=0.0;\n\t\tfloat   N1,N2,N3,N4,N5,N6,N7,N8=0.0;\n\t\tfloat A,A1,A2,A3,A4,A5,A6,A7,A8=0.0;\n\t\n\n\n\t// Snow layers, somewhat like an fbm with worley layers.\n\tF1 = 1.0-cellular2x2((uv+(GA*0.1))*8.0);\t\n\tA1 = 1.0-(A*0.8);\n\tN1 = smoothstep(0.9998,1.0,F1)*0.2*A1;\t\n\n\tF2 = 1.0-cellular2x2((uv+(GA*0.2))*7.0);\t\n\tA2 = 1.0-(A*0.8);\n\tN2 = smoothstep(0.9998,1.0,F2)*0.3*A2;\t\t\t\t\n\n\tF3 = 1.0-cellular2x2((uv+(GA*0.3))*6.0);\t\n\tA3 = 1.0-(A*0.8);\n\tN3 = smoothstep(0.9998,1.0,F3)*0.4*A3;\t\t\t\n            \n    F4 = 1.0-cellular2x2((uv+(GA*0.4))*5.0);\t\n\tA4 = 1.0-(A*0.8);\n\tN4 = smoothstep(0.9998,1.0,F4)*0.5*A4;\t\n            \n    F5 = 1.0-cellular2x2((uv+(GA*0.5))*4.0);\t\n\tA5 = 1.0-(A*0.8);\n\tN5 = smoothstep(0.9998,1.0,F5)*0.6*A5;\t\n\t\t\t\t\t\t\t\t\n    F6 = 1.0-cellular2x2((uv+(GA*0.8))*3.0);\t\n\tA6 = 1.0-(A*0.8);\n\tN6 = smoothstep(0.9999,1.0,F6)*0.59*A6;\n    \n    F7 = 1.0-cellular2x2((uv+(GA*1.2))*2.9);\t\n\tA7 = 1.0-(A*0.8);\n\tN7 = smoothstep(0.9999,1.0,F7)*0.58*A7;\n    \n    F8 = 1.0-cellular2x2((uv+(GA*1.8))*2.8);\t\n\tA8 = 1.0-(A*0.8);\n\tN8 = smoothstep(0.9999,1.0,F8)*0.57*A8;\n   \n    \n    \n\t float cl= (N8+N7+N6+N5+N4+N3+N2+N1)*2.0;\n \n   \n    float tm=iTime/5.0;\n    \n   \n    \n    vec3 r = normalize(vec3(uv3, 1.3));//1.5\n    vec3 o = vec3(0.0, 0.0, -2.5);\n \n    mat3 xfm = yrot(-iMouse.x*0.01)*xrot(iMouse.y*0.01)*zrot(0.);\n    xfm *= xrot(0.4*tm*3.5);// unused !\n    o *= xfm;\n    r *= xfm;\n    float tt = trace(o, r);\n    vec3 w = o + r * tt;\n    vec3 sn = normal(w);\n    vec2 fd = map(w);\n    vec3 lpos = o-1.8*sin(tm)  ;// remove  \n    vec3 ldel = lpos - w;\n    float llen = length(ldel);\n    ldel /= llen;\n    vec3 refl = reflect(ldel, sn);\n    float prod = max(dot(ldel,sn), 1.5)*1.5;\n    float spow = max(dot(refl,r), 0.1);\n    vec4 diff = tex(w*0.4);//0.4\n    vec4 spec = vec4(0.0);\n    float fog = 1.0 / (1.0 + t * t * 0.1 + fd.x * 500.0);\n    vec4 fc = (diff * prod + spec * spow) * fog;\n    \n    //uv3.x = uv3.x+0.2*iTime;\n   \n      \n     \n    \n    \n     vec3 tx   = 2.*texture(iChannel2,uv).xyz;\n        \n     float txty = 2.0;\n     float txtx = -4.0;           \n       \n     float intensity =1.0;\n    \n    \n     uvs = uvs -0.5;\n    if (gtimer>=32.0) {intensity =0.1+abs(2.*sin(gtimer)*2.0);}\n   \n    if (gtimer>=34.0) {uvs.y += 0.5+2.2*sin(gtimer)*0.5;}\n    if (gtimer>=44.0) {uvs.x += 0.5+2.2*sin(gtimer)*0.8;}\n    if (gtimer>=64.0) {uvs.x -= 0.5+2.2*sin(-gtimer)*0.8;}\n    \n      \n      \n  float a  = shtoy((uvs*0.9*5.*abs(sin(iTime*0.8)))-vec2(txtx,txty-4.8));\n        a += shtoy((uvs*1.1*5.*abs(sin(iTime*0.7)))-vec2(txtx,txty-4.2));\n        a += shtoy((uvs*1.2*5.*abs(sin(iTime*0.6)))-vec2(txtx,txty-3.6));\n        a += shtoy((uvs*1.3*5.*abs(sin(iTime*0.5)))-vec2(txtx,txty-3.0));\n        a += shtoy((uvs*1.4*5.*abs(sin(iTime*0.4)))-vec2(txtx,txty-2.4));\n        a += shtoy((uvs*1.5*5.*abs(sin(iTime*0.3)))-vec2(txtx,txty-1.8));\n        a += shtoy((uvs*1.6*5.*abs(sin(iTime*0.2)))-vec2(txtx,txty-1.2));\n\n     \n    \n     \n     \n                      \n     float final = a ;\n        \n     fragColor    = vec4(mix(vec3(final*tx.r,final*tx.g,final*tx.b)*intensity,\n                             \n                             \n                             vec3(cl,cl,cl),cl),1.0); \n      \n     \n   // *** bar layer\n    \n    vec2 bl = fragCoord.xy / iResolution.xy;\n    \n    if(bl.y>.50-min(t/8.,0.4) ^^ bl.y<0.50+min(t/8.0,.4))  fragColor  = vec4(0.2,0.2,0.2,1.0);\n    \n     \n    \n    \n}","name":"Image","description":"","type":"image"}]}