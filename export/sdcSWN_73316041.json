{"ver":"0.1","info":{"id":"sdcSWN","date":"1633706639","viewed":288,"name":"TAA + clip GGX integral","username":"damart3d","description":"GGX MC integration using TAA with color clip. Color clip rejects a lot of samples and is dependent on noise type, both temporal and spatial.\n| no_clip(reference) | R2_2d_scrambled | R2_index_scrambled | offset_fibonacci_lattice |\nLMB = IGN noise\n","likes":9,"published":1,"flags":32,"usePreview":0,"tags":["montecarlo","integration","temporal","taa"],"hasliked":0,"parentid":"wd3Bzn","parentname":"MC integration over time"},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nvec3 YCoCgToRGB( vec3 YCoCg )\n{\n\tfloat Y= YCoCg.x;\n\tfloat Co= YCoCg.y - ( 0.5 * 256.0 / 255.0 );\n\tfloat Cg= YCoCg.z - ( 0.5 * 256.0 / 255.0 );\n\tfloat R= Y + Co-Cg;\n\tfloat G= Y + Cg;\n\tfloat B= Y - Co-Cg;\n\treturn vec3(R,G,B);\n}\n\nvec3 heat(float x)\n{\n    float a = clamp((-x+0.5)/0.5,0.0,1.0);\n    float b = clamp(-abs((x-0.5) * 2.0)+1.0,0.0,1.0);\n    float c = clamp((x-0.5)*2.0,0.0,1.0);\n    \n    return vec3(0,0,0.1)*a + vec3(0,1,0)*b + vec3(1,0,0)*c;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 fragUV = fragCoord / iResolution.xy;\n    fragColor.xyzw = texture(iChannel0, fragUV).xyzw;\n    fragColor.xyz = YCoCgToRGB(fragColor.xyz);\n\n    vec3 mean   = texture(iChannel0, fragUV).rgb;\n    vec3 variance   = vec3(0.0);\n\n    for(int i = 0; i < 8; i++)\n    {\n        vec3 fetch = texelFetch(iChannel0, ivec2(fragCoord.xy)+offsets[i], 0).xyz;\n        mean  += fetch;\n    }\n    mean /= 9.0;\n\n    for(int i = 0; i < 8; i++)\n    {\n        vec3 fetch = texelFetch(iChannel0, ivec2(fragCoord.xy)+offsets[i], 0).xyz;\n        vec3 sVar = (fetch - mean);\n        variance  += sVar*sVar;\n    }\n\n    //spatial variance\n    if(fragUV.y<2.0/3.0)\n    {\n        fragColor.rgb = (variance.yyy*500.0);\n    }\n    \n    //temporal variance\n    if(fragUV.y<1.0/3.0)\n    {\n        fragColor.rgb = (fragColor.www*5000.0);\n    }\n\n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"float PI = 3.14159265359;\n\nvec3 RGBToYCoCg( vec3 RGB )\n{\n\tfloat Y = dot(RGB, vec3(  1, 2,  1 )) * 0.25;\n\tfloat Co= dot(RGB, vec3(  2, 0, -2 )) * 0.25 + ( 0.5 * 256.0/255.0 );\n\tfloat Cg= dot(RGB, vec3( -1, 2, -1 )) * 0.25 + ( 0.5 * 256.0/255.0 );\n\treturn vec3(Y, Co, Cg);\n}\n\nvec4 bluenoise( vec2 fc )\n{\n    return texture( iChannel2, fc / iChannelResolution[2].xy );\n}\n\n//----------------------------------------------------------------------------------\nvec4 ImportanceSampleGGX( vec2 E, float Roughness )\n{\n\tfloat m = Roughness * Roughness;\n\tfloat m2 = m * m;\n\n\tfloat Phi = 2.0 * PI * E.x;\n\tfloat CosTheta = sqrt( (1.0 - E.y) / ( 1.0 + (m2 - 1.0) * E.y ) );\n\tfloat SinTheta = sqrt( 1.0 - CosTheta * CosTheta );\n\n\tvec3 H;\n\tH.x = SinTheta * cos( Phi );\n\tH.y = SinTheta * sin( Phi );\n\tH.z = CosTheta;\n\t\n\tfloat d = ( CosTheta * m2 - CosTheta ) * CosTheta + 1.0;\n\tfloat D = m2 / ( PI*d*d );\n\tfloat PDF = D * CosTheta;\n\t\n\treturn vec4( H, PDF );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //loop every \"temporalSamples\" frames\n    float tempSampleCount = temporalSamples;\n    float frameIndex = fract(float(iFrame)/tempSampleCount) * tempSampleCount;\n      \n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 uvO = uv;\n    vec2 size = vec2(4.0,3.0);\n\n    uv = fract(uv*size)/size + vec2(0.45,0.3);\n    vec3 noise = bluenoise(fragCoord).xyz;\n    \n    if(iMouse.z>0.0)\n    {\n        noise.x = IGN(fragCoord);\n        noise.y = IGN(fragCoord.yx);\n    }\n\n    float roughness = 0.35;\n    \n    float goldenRatio = 1.6180339887;\n    float noise1d = IGN(fragCoord);\n\n    float g = 1.32471795724474602596;\n\tvec2 a = vec2(1.0 / g, 1.0 / ( g * g));\n\n    vec2 Xi = fract(noise.xy + a.xy * vec2(iFrame, iFrame) );\n\n    //r2 sequence\n    //http://extremelearning.com.au/unreasonable-effectiveness-of-quasirandom-sequences/\n    if(uvO.x > 0.5)\n    {\n        float i = float(iFrame) + noise.x*temporalSamples;\n        vec2 r2 = fract(0.5 + a.xy * vec2(i,i) );\n        Xi = r2;\n    }\n\n    //offset lattice\n    //http://extremelearning.com.au/how-to-evenly-distribute-points-on-a-sphere-more-effectively-than-the-canonical-fibonacci-lattice/\n    if(uvO.x > 0.75)\n    {   \n        float e = 0.33;\n        float i = fract(noise.y + frameIndex / tempSampleCount) * tempSampleCount;\n        vec2 offLat = vec2( i/goldenRatio,(i + e)/(tempSampleCount - 1.0 +2.0*e));\n        Xi = fract(offLat.xy);\n    }\n\n    vec4 roughMap = texture( iChannel1, uv);\n\n    vec4 GGX = ImportanceSampleGGX( Xi, roughness );\n    vec2 texCoord = uv + 100.0*GGX.xy/iResolution.xy;\n    vec4 sampleTex = textureLod( iChannel3, texCoord, 0.0);\n\n    // Output to screen\n    fragColor.xyz = sampleTex.xyz;\n  \n    fragColor.xyz = RGBToYCoCg(sampleTex.xyz);\n\n\n    fragColor = vec4(fragColor.xyz,0.5);\n\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"\n//UE4 color clip\nfloat HistoryClip(vec3 History, vec3 Filtered, vec3 NeighborMin, vec3 NeighborMax)\n{\n#if 0\n\tvec3 Min = min(Filtered, min(NeighborMin, NeighborMax));\n\tvec3 Max = max(Filtered, max(NeighborMin, NeighborMax));\t\n\tvec3 Avg2 = Max + Min;\n\tvec3 Dir = Filtered - History;\n\tvec3 Org = History - Avg2 * 0.5;\n\tvec3 Scale = Max - Avg2 * 0.5;\n\treturn saturate(IntersectAABB(Dir, Org, Scale));\n#else\n\tvec3 BoxMin = NeighborMin;\n\tvec3 BoxMax = NeighborMax;\n\t//vec3 BoxMin = min( Filtered, NeighborMin );\n\t//vec3 BoxMax = max( Filtered, NeighborMax );\n\n\tvec3 RayOrigin = History;\n\tvec3 RayDir = Filtered - History;\n    RayDir.x = abs( RayDir.x ) < (1.0/65536.0) ? (1.0/65536.0) : RayDir.x;\n    RayDir.y = abs( RayDir.y ) < (1.0/65536.0) ? (1.0/65536.0) : RayDir.y;\n    RayDir.z = abs( RayDir.z ) < (1.0/65536.0) ? (1.0/65536.0) : RayDir.z;\n\tvec3 InvRayDir = 1.0 / RayDir;\n\n\tvec3 MinIntersect = (BoxMin - RayOrigin) * InvRayDir;\n\tvec3 MaxIntersect = (BoxMax - RayOrigin) * InvRayDir;\n\tvec3 EnterIntersect = min( MinIntersect, MaxIntersect );\n\treturn max( EnterIntersect.x, max(EnterIntersect.y, EnterIntersect.z ));\n#endif\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    vec4 current = texture(iChannel0, fragCoord / iResolution.xy);\n    float blend = 1.0/temporalSamples;\n    \n    vec4 history = texture(iChannel1, fragCoord / iResolution.xy);\n\t\n    vec3 maxNbr = current.xyz;\n    vec3 minNbr = current.xyz;\n    vec3 mean   = current.xyz;\n\n    for(int i = 0; i < 8; i++)\n    {\n        vec3 fetch = texelFetch(iChannel0, ivec2(fragCoord.xy)+offsets[i], 0).xyz;\n        maxNbr = max(fetch, maxNbr);\n        minNbr = min(fetch, minNbr);\n        mean  += fetch;\n    }\n\n    mean *= 1.0/9.0;\n\n    float hWeight = HistoryClip(history.xyz, mean, minNbr, maxNbr);\n    hWeight = max(hWeight, blend);  \n\n    if(uv.x < 0.25)\n    {\n        hWeight = blend;\n    }\n   \n    //fill the first frame\n    if(iFrame == 0)\n    {\n       hWeight = 1.0; \n    }\n    \n    if(clipEnable == false)\n    {\n        hWeight = 1.0/temporalSamples;\n    }\n\n    fragColor.xyz = mix(history.xyz, current.xyz, hWeight);\n\n    //compute the varince of final color, not current\n    float delta = fragColor.y - history.y;\n    float tVar = (1.0 - hWeight) * history.w + hWeight * (1.0 - hWeight) * delta * delta;\n\n    fragColor.w = tVar;\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"float temporalSamples = 40.0;\nbool clipEnable = true;\n\nfloat IGN( vec2 iPos )\n{\n\treturn fract( 52.9829189f * fract( (iPos.x * 0.06711056) + (iPos.y * 0.00583715)) );\n}\n\nivec2 offsets[8] = ivec2[8]( \n    ivec2(-1,-1), ivec2(-1, 1), \n\tivec2(1, -1), ivec2(1, 1), \n\tivec2(1, 0), ivec2(0, -1), \n\tivec2(0, 1), ivec2(-1, 0)\n);","name":"Common","description":"","type":"common"}]}