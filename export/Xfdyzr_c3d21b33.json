{"ver":"0.1","info":{"id":"Xfdyzr","date":"1730466575","viewed":643,"name":"Stochastic Tile Traversal","username":"Shane","description":"Traversing an extruded packed stochastic rectangular tiling of the plane in realtime.","likes":49,"published":3,"flags":32,"usePreview":0,"tags":["raymarching","grid","bokeh","rectangle","prism","stochastic","traversal","sparse","asymmetric"],"hasliked":0,"parentid":"l3sBzM","parentname":"Monomino Domino Tile Traversal"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n\n    Stochastic Tile Traversal\n    -------------------------\n\n    See \"Buffer A\" for an explanation.\n\n*/\n\n\n/*\n\n// Just a very basic depth of field routine -- I find a lot of it is\n// common sense. Basically, you store the scene distance from the camera \n// in the fourth channel, then use it to determine how blurry you want\n// your image to be at that particular distance.\n//\n// For instance, in this case, I want pixels that are 2.25 units away from \n// the camera to be in focus (not blurred) and for things to get more \n// blurry as you move away from that point -- aptly named the focal point \n// for non camera people. :)\n//\n// I based this on old code of mine, but adopted things that I found in \n// IQ and Nesvi7's examples, which you can find here:\n//\n// Ladybug - IQ\n// https://www.shadertoy.com/view/4tByz3\n//\n// Cube surface II - Nesvi7\n// https://www.shadertoy.com/view/Mty3DV\n//\nvec3 DpthFld(sampler2D iCh, vec2 uv){\n\t\n    // Focal point and circle of confusion.\n    const float focD = 2.25, coc = 1.25;\n    // Linear distance from either side of the focal point.\n    float l = abs(texture(iCh, uv).w - focD) - coc;\n    // Using it to calculate the DOF.\n    float dof = clamp(l/coc, 0., 2.)*2.; \n    \n    // Combine samples. Samples with a larger DOF value are taken further \n    // away from the original point, and as such appear blurrier.\n    vec3 acc = vec3(0);\n\n    for(int i = 0; i<25; i++){\n        // Accumulate samples.\n        acc += texture(iCh, uv + (vec2(i/5, i%5) - 2.)/iResolution.y*dof).xyz;\n        //acc.x *= dof/2.;\n    }\n\n    // Return the new variably blurred value.\n    return acc /= 25.;\n    // Visual debug representation of DOF value.\n    //return vec3(length(dof)*450./2.5);\n}\n\n*/\n\n// Standard 2D rotation formula.\n//mat2 rot2(in float a){ float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\n\n// IQ's float to float hash. I've added an extra sine wrapping modulo to\n// cater for my annoying AMD based system, which can't wrap sine with a \n// proper degree of accuracy.\nfloat hash11B(float x){ return fract(sin(mod(x, 6.2831853))*43758.5453); }\n\n// This is an amalgamation of old blur and DOF functions with a heap of borrowed \n// lines from Dave Hoskins's much nicer Fibonacci based \"Bokeh disc\" function, which \n// you can find here: https://www.shadertoy.com/view/4d2Xzw\n//\n// If you're interested in bokeh, Dave's function above and some of Shadertoy user, \n// Hornet's, are probably the ones you should be looking at. Xor has some cool simple \n// ones on here too.\n//\nvec4 bokeh(sampler2D iCh, vec2 uv){\n\n\n    // UV based DOF. Focused on the horizontal line, then blurring further away.\n    //float r = smoothstep(0., 1., abs(uv.y - .57)/.57)*2.;\n    // Focal point and circle of confusion.\n    const float focD = 2.25, coc = 1.25;\n    // Linear distance from either side of the focal point.\n    float l = abs(texture(iCh, uv).w - focD) - coc;\n    // Using it to calculate the DOF.\n    float ra = clamp(l/coc, 0., 2.);\n    //float ra = smoothstep(.1, .9, abs(uv.y - .5)*2.)*2.;\n    //float ra = mix(clamp(l/coc, 0., 2.), smoothstep(.3, 1., abs(uv.y - .5)*2.), .25);\n    //float ra = (smoothstep(.2, 1., length(uv - .5)));\n\n    // Standard Fibonacci distribution calculations, compliments of Dave Hoskins.\n    const int iter = 96;\n    float rad = 1.6;//max(2.*ra, .5); // Bokeh radius.\n    float r = 1.;\n\tvec4 tot = vec4(0), div = tot;\n    vec2 vangle = vec2(0., rad*.01/sqrt(float(iter)));\n    #define GA 2.3999632 // Golden angle.\n    const mat2 rot = mat2(cos(GA), sin(GA), -sin(GA), cos(GA));\n\n    // Aspect ratio.\n    vec2 aspect = vec2(iResolution.y/iResolution.x, 1);\n    // Trying to reduce the sample spread at larger resolutions.\n    //if(iResolution.y>450.) aspect *= mix(iResolution.y, 450., .5)/iResolution.y;\n    \n    \n\tfor (int i = 0; i<iter; i++){\n        \n        #if 1\n        \n        // Dave Hoskin's Fibonacci based scattering. Cheaper and much nicer, so\n        // it's set as the default.\n        // The approx increase in the scale of sqrt(0, 1, 2, 3...).\n        r += 1./r;\n\t    vangle = rot*vangle;\n        vec4 col = texture(iCh, uv - (r - 1.)*vangle*aspect, iResolution.y/450.*1.5); \n        \n        #else\n        \n        // A hash based random distribution, for anyone who wants to try it.\n        //int ii = i%10; // For square bokeh.\n        //int jj = i/10;\n    \n        // Random offset contained within a disk or radius n.\n        float fi = float(i) + fract(iTime);\n        //vec2 fi = vec2(ii, jj) - 5. + fract(iTime);\n        vec2 rnd2 = vec2(hash11B(fi), hash11B(fi + .1)*6.2831);\n        vec2 offs = 6.*sqrt(rnd2.x)*vec2(cos(rnd2.y), sin(rnd2.y));\n        ////////\n        /*\n        // Polygons, if desired. Comment out the line above and comment in\n        // the \"rot2\" formula above, if using it.\n        const float N = 6.;\n        float ra = rnd2.y;\n        float a = (floor(ra*N) + .5)*6.2831859/N;\n        vec2 offs  = mix(rot2(a)*vec2(0, 1), rot2(a + 6.2831859/N)*vec2(0, 1), fract(ra*N));\n        offs *= 6.*sqrt(rnd2.x);\n        */\n        ////////\n        offs *= rad;\n        //offs = rad*(offs + (vec2(hash11B(fi), hash11B(fi + .21)) - .5));\n        vec4 col = texture(iCh, uv - offs/iResolution.xy, iResolution.y/450.*1.5);  \n  \n        #endif\n         \n        // Thanks to Dave for figuring out how to tweak the colors to produce brighter \n        // contrast. It's common sense... once someone figures it out for you. :D \n        vec4 bokeh = pow(col, vec4(4));\n\t\ttot += bokeh*col*col;\n\t\tdiv += bokeh;\n        \n\t}\n    \n    \n    // Mixing the original value with the bokeh tweaked value according\n    // to the depth of field.\n    vec4 colOrig = texture(iCh, uv);\n    // Not entirely correct, but no one will notice here. :)\n\treturn mix(colOrig, colOrig*.25 + tot/div*4., ra);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\n\n    // Screen oordinates.\n    vec2 uv = fragCoord/iResolution.xy;\n\n    //vec4 col = DpthFld(iChannel0, uv).xyzz;\n\n    // Retrieving the stored color.\n    //vec4 col = texture(iChannel0, uv);\n\n    vec4 col = bokeh(iChannel0, uv);\n    \n \n    // Subtle tone-mapping.\n    //col /= (1.5 + col)/2.;\n    \n    // Subtle vignette.\n    col *= pow(16.*uv.x*uv.y*(1. - uv.x)*(1. - uv.y) , 1./16.);\n\n    // Rough gamma correction and screen presentation.\n    fragColor = pow(max(col, 0.), vec4(1./2.2)); \n    \n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"\n\n// Standard 2D rotation formula.\nmat2 rot2(in float a){ float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\n\n// Fabrice's fork of \"Integer Hash - III\" by IQ: https://shadertoy.com/view/4tXyWN\nfloat hash21(vec2 f){\n    \n    // Annoying GPU accuracy hack. For this example only... I'll hack to \n    // fix the algorithm using it to get rid of it.\n    f = mod(f + 16384., 16384.); \n    // The first line relates to ensuring that icosahedron vertex identification\n    // points snap to the exact same position in order to avoid hash inaccuracies.\n    uvec2 p = floatBitsToUint(f);\n    p = 1664525U*(p>>1U^p.yx);\n    return float(1103515245U*(p.x^(p.y>>3U)))/float(0xffffffffU);\n}\n\n/*\n// Dave Hoskins's well known hash formula. More reliabel than the\n// above formula in some cases.\nfloat hash21(vec2 p){\n\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 19.1943);\n    return fract((p3.x + p3.y) * p3.z);\n}\n*/\n\n// IQ's \"uint\" based uvec3 to float hash.\nfloat hash31(vec3 f){\n\n    //f.xy = mod(f.xy, GRID_SIZE);\n    uvec3 p = floatBitsToUint(f);\n    p = 1103515245U*((p >> 2U)^(p.yzx>>1U)^p.zxy);\n    uint h32 = 1103515245U*(((p.x)^(p.y>>3U))^(p.z>>6U));\n\n    uint n = h32^(h32 >> 16);\n    return float(n & uint(0x7fffffffU))/float(0x7fffffff);\n}\n\n\n///////////////////////////\nconst float PI = 3.14159265;\n\n// Microfaceted normal distribution function.\nfloat D_GGX(float NoH, float roughness) {\n    float alpha = pow(roughness, 4.);\n    float b = (NoH*NoH*(alpha - 1.) + 1.);\n    return alpha/(PI*b*b);\n}\n\n// Surface geometry function.\nfloat G1_GGX_Schlick(float NoV, float roughness) {\n    //float r = roughness; // original\n    float r = .5 + .5*roughness; // Disney remapping.\n    float k = (r*r)/2.;\n    float denom = NoV*(1. - k) + k;\n    return max(NoV, .001)/denom;\n}\n\nfloat G_Smith(float NoV, float NoL, float roughness) {\n    float g1_l = G1_GGX_Schlick(NoL, roughness);\n    float g1_v = G1_GGX_Schlick(NoV, roughness);\n    return g1_l*g1_v;\n}\n\n// Bidirectional Reflectance Distribution Function (BRDF). \n//\n// If you want a quick crash course in BRDF, see the following:\n// Microfacet BRDF: Theory and Implementation of Basic PBR Materials\n// https://www.youtube.com/watch?v=gya7x9H3mV0&t=730s\n//\nvec3 BRDF(vec3 col, vec3 n, vec3 l, vec3 v, \n          float type, float rough, float fresRef, vec3 spCol){\n   \n    vec3 h = normalize(v + l); // Half vector.\n\n    // Standard BRDF dot product calculations.\n    float nv = clamp(dot(n, v), 0., 1.);\n    float nl = clamp(dot(n, l), 0., 1.);\n    float nh = clamp(dot(n, h), 0., 1.);\n    float vh = clamp(dot(v, h), 0., 1.);  \n\n    // Specular microfacet (Cook- Torrance) BRDF.\n    //\n    // F0 for dielectics in range [0., .16] \n    // Default FO is (.16 * .5^2) = .04\n    // Common Fresnel values, F(0), or F0 here.\n    // Water: .02, Plastic: .05, Glass: .08, Diamond: .17\n    // Metals: I think all need to be converted to linear form (roughly squared).\n    // Copper: vec3(.95, .64, .54), Aluminium: vec3(.91, .92, .92), Gold: vec3(1, .71, .29),\n    // Silver: vec3(.95, .93, .88), Iron: vec3(.56, .57, .58).\n    vec3 f0 = vec3(.16*(fresRef*fresRef)); \n    // For metals, the base color is used for F0.\n    f0 = mix(f0, col, type);\n    vec3 F = f0 + (1. - f0)*pow(1. - vh, 5.);  // Fresnel-Schlick reflected light term.\n    // Microfacet distribution... Most dominant term.\n    float D = D_GGX(nh, rough); \n    // Geometry self shadowing term.\n    float G = G_Smith(nv, nl, rough); \n    // Combining the terms above.\n    vec3 spec = F*D*G/(4.*max(nv, .001));\n\n\n    // Diffuse calculations.\n    vec3 diff = vec3(nl);\n    diff *= 1. - F; // If not specular, use as diffuse (optional).\n    diff *= (1. - type); // No diffuse for metals.\n\n\n    // Combining diffuse and specular.\n    // You could specify a specular color, multiply it by the base\n    // color, or multiply by a constant. It's up to you.\n    return (col*diff + spCol*spec*PI);\n  \n}\n////////////////////\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4sXGRn","filepath":"/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","previewfilepath":"/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":2,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"/*\n\n    Stochastic Tile Traversal\n    -------------------------\n    \n    Traversing an extruded packed stochastic rectangular tiling of the plane in \n    realtime.\n    \n    This is one of many shaders that I've had sitting in my account for too long. \n    The largest shaders on Shadertoy are still considered tiny in the real world -- \n    I've completely abandoned projects hundreds of times this size. :D Even so, I \n    don't enjoy cleaning up and presenting anything but the tiniest of shaders, \n    so examples like this sit around for way too long. :)\n    \n    I wrote a stochastic rectangular tile algorithm some time ago. At the time, \n    there was nothing out there. In fact, besides a few people who've used it, \n    there are still not a lot of examples around, which surprises me, since a \n    random packed rectangular tiling is something that is often desired.\n    \n    Anyway, the original algorithm was a slower version, on account of the fact \n    that I'd produced information for all neighboring tiles -- There are\n    situations where that is necessary. This, however, is a traversal, so only one \n    rectangle per cell need be calculated, which means it's possible to use line \n    stepping trickery and so forth. \n    \n    The algorithm I put together is pretty fast, but it's always possible to tweak \n    things for more speed. In regard to the quickest way to do it, that is obvious;\n    Precalculate everything on a backbuffer, then use that. :) I have a couple of \n    examples on here that do that. By the way, over time, I've thought of some \n    other cheap ways to produce stochastic tiles, so I might post one of those at \n    some stage.\n    \n    \n    \n    \n    // Other examples:\n    \n    // A 2D asymmetric block example. JT has a lot of\n    // tiling examples.\n    Asymmetric Blocks SDF  - jt\n    https://www.shadertoy.com/view/ftcfWf\n    \n    // Amalgamating cell-by-cell traversal and raymarching to render\n    // a subdivided rectangular grid. The tiling is not what I'd describe\n    // as stochastic, but it's very cheap and has a mild random feeling to it.\n    Cell-By-Cell Raymarching - Shane\n    https://www.shadertoy.com/view/DdBfzt\n    \n    // I wrote this one a while ago. It provides information for four\n    // neighboring blocks at once, which is slower, but useful for all\n    // kinds of things.\n    Asymmetric Blocks - Shane\n    https://www.shadertoy.com/view/Ws3GRs\n\n*/\n\n\n// Max ray distance.\n#define FAR 15.\n\n// Only display the 2D pattern.\n//#define SHOW_2D_PATTERN\n\n\n// Scene object ID to separate the mesh object from the terrain.\nfloat objID;\n\n\n// Tri-Planar blending function: Based on an old Nvidia writeup:\n// GPU Gems 3 - Ryan Geiss: http://http.developer.nvidia.com/GPUGems3/gpugems3_ch01.html\nvec3 tex3D(sampler2D tex, in vec3 p, in vec3 n){    \n    \n    // Abosolute normal with a bit of tightning.\n    n = max(n*n - .2, .001); // max(abs(n), 0.001), etc.\n    n /= dot(n, vec3(1)); \n    //n /= length(n); \n    \n    // Texure samples. One for each plane.\n    vec3 tx = texture(tex, p.zy).xyz;\n    vec3 ty = texture(tex, p.xz).xyz;\n    vec3 tz = texture(tex, p.xy).xyz;\n    \n    // Multiply each texture plane by its normal dominance factor.... or however you wish\n    // to describe it. For instance, if the normal faces up or down, the \"ty\" texture \n    // sample, represnting the XZ plane, will be used, which makes sense.\n    \n    // Textures are stored in sRGB (I think), so you have to convert them to linear space \n    // (squaring is a rough approximation) prior to working with them... or something like\n    // that. :) Once the final color value is gamma corrected, you should see correct \n    // looking colors.\n    return mat3(tx*tx, ty*ty, tz*tz)*n;\n}\n\n\n// Texture sample.\n//\nvec3 getTex(sampler2D iCh, vec2 p){\n    \n    // Strething things out so that the image fills up the window..\n    //p *= vec2(iResolution.y/iResolution.x, 1);\n    vec3 tx = texture(iCh, p).xyz;\n    return tx*tx; // Rough sRGB to linear conversion.\n}\n\n// Height map value.\nfloat hm(in vec2 p){ \n\n    //float h = dot(getTex(iChannel1, p), vec3(.299, .587, .114)); \n    //float h = texture(iChannel1, p/128.).x; \n    float h = dot(sin(p - cos(p.yx*2.5 + iTime*2.)), vec2(.25)) + .5; \n    return smoothstep(0.2, 1., h)*.7 + h*.3;\n    //return sin(6.2831853*h + iTime)*.5 + .5;\n}\n\n\n// IQ's extrusion formula.\nfloat opExtrusion(in float sdf, in float pz, in float h, in float sf){\n\n    // Slight rounding. A little nicer, but slower.\n    vec2 w = vec2( sdf, abs(pz) - h) + sf;\n  \treturn min(max(w.x, w.y), 0.) + length(max(w, 0.)) - sf;\n}\n\n\n/*\n// Signed distance to a line passing through A and B.\nfloat distLineS(vec2 p, vec2 a, vec2 b){\n\n   b -= a; \n   return dot(p - a, vec2(-b.y, b.x)/length(b));\n}\n*/\n\n// IQ's smooth box function. I like to add in a rounding\n// factor, \"rf\", which IQ's calculations make possible.\nfloat sBoxS(in vec2 p, in vec2 b, in float rf){\n  \n  vec2 d = abs(p) - b + rf;\n  return min(max(d.x, d.y), 0.) + length(max(d, 0.)) - rf;\n}\n\n\n// Global cell boundary distance variables.\nvec3 gDir; // Cell traversing direction.\nvec3 gRd; // Ray direction.\nfloat gCD; // Cell boundary distance.\n// Box dimension and local XY coordinates.\n//vec3 gSc; \nvec2 gP;\n\n// Block scale. The Z-value can be used, but I'm\n// not using it here.\nvec3 gSc = vec3(1, 1, 1)/4.;\n\n//vec2 gP;\nvec2 cntr = vec2(0);\nvec2 dim = vec2(0);\n\nfloat gD;\n\n// The stochastic packed rectangle routine.\nvec4 blocks(vec2 p){\n    \n    // Rectangle scale. Stretching is possible, by the way.\n    vec2 sc = gSc.xy;\n    \n    // Cell ID and local coordinates.\n    vec2 ip = floor(p/sc);\n    p -= (ip + .5)*sc;\n    \n       \n    // Mid-edge IDs. These are handy to have when working with squares.\n    mat2x2 eID = mat2x2(vec2(-.5, 0), vec2(0, .5));\n     \n    // Offset factor. Values between zero and almost one will work.\n    vec2 oFctr = .65*sc;\n\n    \n    // Random X and Y tile extrema positions... or the left, right,\n    // top and bottom positions, if you prefer.\n    vec2 rnd, rndN;\n    vec2 dir; // Direction X and Y variable. Used for line stepping.\n    \n    \n    // Alternating checkers variable: The algorithm is based on vertical \n    // cell partitioning on the metaphorical black checkerboard squares and\n    // horizontal partitioning on the white ones.\n    float check = mod(ip.x + ip.y, 2.)<.5? -1. : 1.;\n\n    // Note that I'm not using an \"if-else\" statement. I'm not sure how \n    // GPUs work now, but they used to handle \"if-else\" statements in\n    // annoying ways, so for extra speed, you'd split them... The compiler\n    // might help these days, but just to be safe... Either way, it'd be\n    // possible to eliminate most of this altogether, so I'll do that at\n    // some stage.\n    if(check<0.){\n    \n        // Randomly offset vertical partition line.\n        rnd.x = (hash21(ip) - .5)*oFctr.x;\n         \n        // Vertical offset line step.\n        dir.x = p.x<rnd.x? -1. : 1.;\n\n        // Neighbor randomly offset horizontal partition line.\n        rnd.y = (hash21(ip + dir*vec2(1, 0)) - .5)*oFctr.y;\n          \n        // Horizontal offset line step.\n        dir.y = p.y<rnd.y? -1. : 1.;\n\n        // Neighborirng X vertical lines (Neighboring diagnal offset).\n        rndN.x = hash21(ip + dir*vec2(1, 1));\n        \n        // Neighborirng Y horizontal lines.\n        rndN.y  = hash21(ip + dir*vec2(0, 1));\n          \n    }\n    \n    if(check>0.){\n\n        // Randomly offset horizontal partition line.\n        rnd.y = (hash21(ip) - .5)*oFctr.y;\n        dir.y = p.y<rnd.y? -1. : 1.;\n\n        // Neighbor randomly offset vertical partition line.\n        rnd.x = (hash21(ip + dir*vec2(0, 1)) - .5)*oFctr.x;\n        dir.x = p.x<rnd.x? -1. : 1.;\n\n        // Neighborirng vertical lines.\n        rndN.x = hash21(ip + dir*vec2(1, 0));\n     \n        // Neighborirng Y horizontal lines (Neighboring diagnal offset).\n        rndN.y = hash21(ip + dir*vec2(1, 1));\n       \n    }\n    \n    // Step to the outer neighboring extreme points.\n    rndN = (rndN - .5)*oFctr;\n    rndN += dir*sc;\n    \n    // Rectangle center and dimensions.\n    cntr = mix(rnd, rndN, .5);\n    dim = -dir*(rnd - rndN);\n   \n    \n    // Central-position based ID. Division involving irrational scaling \n    // factors \"like 1/6\" can cause rounding errors, so we don't use things\n    // like \"oIP + cntr/sc\". Quadrant based things like \"oIP + sign(cntr)/2.\" \n    // will also work, but will not be based on correct block position,. However,\n    // if that doesn't matter, then you can use that instead.\n    ip = ip*sc + cntr; \n    \n    //ip = (ip + sign(cntr)/2.)*sc; // No hack needed, but not entirely position based.\n    \n    // Returning the centered coordinates and ID.\n    return vec4(p - cntr, ip);//floor(ip*16384. + .001)/16384.\n}  \n\n/*\n// Ray origin, ray direction, point on the line, normal. \nfloat rayLine(vec2 ro, vec2 rd, vec2 p, vec2 n){\n   \n   // This it trimmed down, and can be trimmed down more. Note that \n   // \"1./dot(rd, n)\" can be precalculated outside the loop. However,\n   // this isn't a GPU intensive example, so it doesn't matter here.\n   //return max(dot(p - ro, n), 0.)/max(dot(rd, n), 1e-8);\n   float dn = dot(p - ro, n)/dot(rd, n);\n   return dn<0.? 1e8 : dn;   \n\n} \n*/\n\n// Gloval block values -- It's a bit lazy putting it here, but it works. :)\nvec4 gVal;\n\n// Glow variable.\nvec3 glow;\n\n// The extruded image.\nfloat map(vec3 p){\n    \n    // Floor.\n    float fl = -p.z;\n\n\n       // The extruded blocks.\n    vec4 d4 = blocks(p.xy);\n    \n    // Local block position and ID.\n    vec2 p2 = d4.xy;\n    vec2 id = d4.zw;\n \n     \n    // 2D rectangular cross section.\n    float d2 = sBoxS(p2, dim/2. - .0025, .025);\n    \n    \n    // The extruded block height. See the height map function, above.\n    float h = hm(id);\n    h = h*1.5 + .05;\n    if(hash21(id + .43)<.5) h = h*.25;//.05; \n    \n    // Sporadic holes on the larger panels.\n    float minSc = min(gSc.x, gSc.y);\n    if(dim.x>gSc.x && dim.y>gSc.y){\n        d2 = max(d2, -(d2 + minSc/2.));\n    }\n\n\n    // Extrude the 2D shape.\n    float d = opExtrusion(d2, p.z + h/2., h/2., .01);// - bev;\n    \n    // Top panel.\n    d -= smoothstep(0., .007, abs(d2 + .035))*.005;\n  \n    // Beveling.\n    //d -= min(-d2/gSc.x, .05)*.25;  \n    d += (d2 + .035)*.15;\n    \n    \n    /*\n    // Side panels.\n    float pnl = sBoxS( vec2(p2.x, p.z + h/2.), vec2(dim.x, h)/2., .01);\n    d = d + smoothstep(-.005, .005, -(pnl + .05))*.02;\n    pnl = sBoxS( vec2(p2.y, p.z + h/2.), vec2(dim.y, h)/2., .01);\n    d = d + smoothstep(-.005, .005, -(pnl + .05))*.02;\n    */\n    \n    // Side ribbing.\n    const float lNum = 8.;\n    float z = p.z + h;\n    float ln = (abs(fract(z*lNum + .5) - .5) -.25)/lNum;\n    d += smoothstep(0., 1./64., ln)*.01;\n    \n    // Rivots. Put together in a hurry, so there are probably better\n    // ways to do this. It works though.\n    vec2 q = p2;\n    // Double up on the X and Y axes, if there's enough room.\n    if(dim.x>gSc.x/1.2) q.x = abs(q.x + sign(p2.x)*.07) - dim.x/2.;\n    if(dim.y>gSc.y/1.2) q.y = abs(q.y + sign(p2.y)*.07) - dim.y/2.;\n    // q = abs(q); float hex = max(q.x*.8660254 + q.y*.5, q.y);\n    //float dR = opExtrusion(length(q) - .03, p.z + h/2., h/2. + .06, .01);\n    float dR = length(vec3(q, p.z + h + .015)) - .02;\n \n    //d = min(d, dR);\n    //if(hash21(id + .23)<.5) d = max(d, -dR);\n\n    // Very basic (lazy) height-based glow.\n    glow += max(p.z + h, 0.);\n    \n    \n    // The distance from the current ray position to the cell boundary\n    // wall in the direction of the unit direction ray. This is different\n    // to the minimum wall distance, so you need to trace out instead\n    // of merely doing a box calculation. Anyway, the following are pretty \n    // standard cell by cell traversal calculations. The resultant cell\n    // distance, \"gCD\", is used by the \"trace\" and \"shadow\" functions to \n    // restrict the ray from overshooting, which in turn restricts artifacts.\n    \n    // The single-liner below is just an amalgamation and reduction of the\n    // following.\n    //vec3 rC;\n    //rC.x = rayLine(p2, gRd.xy, gDir.xy*sc.xy*vec2(1, 0), -gDir.xy*vec2(2, 0));\n    //rC.y = rayLine(p2, gRd.xy, gDir.xy*sc.xy*vec2(0, 1), -gDir.xy*vec2(0, 2));\n\n    //vec3 rC = (gDir*vec3(dim, 1) - vec3(p2, p.z))/gRd;\n    vec2 rC = (gDir.xy*dim.xy - p2)/gRd.xy; // For 2D, this will work too.\n    // Minimum of all distances, plus not allowing negative distances, which\n    // stops the ray from tracing backwards... I'm not entirely sure it's\n    // necessary here, but it stops artifacts from appearing with other \n    // non-rectangular grids.\n    //gCD = max(min(min(rC.x, rC.y), rC.z), 0.) + .0015;\n    gCD = min(rC.x, rC.y) + .0001; // Adding a touch to advance to the next cell.\n\n    \n    // Save the distances and the position-base ID.\n    gVal = vec4(d2, d, id);\n    gSc = vec3(gSc.xy, h); // Save the scale and block height.\n    \n \n    // Overall object ID. It's slower to do it here, since calculating things\n    // several times per frame is always slower, but it involves less book keeping.\n    objID = fl<d && fl<dR? 0. : d<dR? 1. : 2.;\n    \n    // Combining the floor with the extruded blocks.\n    return  min(fl, min(d, dR));\n \n}\n\n \n// Basic raymarcher.\nfloat trace(in vec3 ro, in vec3 rd){\n\n    // Overall ray distance and scene distance.\n    float d, t = hash31(ro + rd)*.1;\n    \n    //vec2 dt = vec2(1e5, 0); // IQ's clever desparkling trick.\n    \n    // Set the global ray direction varibles -- Used to calculate\n    // the cell boundary distance inside the \"map\" function.\n    gDir = step(0., rd) - .5;\n    gRd = rd; \n    \n    glow = vec3(0);\n    \n    int i;\n    const int iMax = 128;\n    for (i = min(iFrame, 0); i<iMax; i++){ \n    \n        d = map(ro + rd*t);       \n        //dt = d<dt.x? vec2(d, dt.x) : dt; // Shuffle things along.\n        \n        // Note the \"t*b + a\" addition. Basically, we're putting less emphasis on accuracy, \n        // as \"t\" increases. It's a cheap trick that works in most situations.\n        if(abs(d)<.001 || t>FAR) break; \n        \n        //t += i<32? d*.75 : d; \n        t += min(d, gCD); \n    }\n    \n    // If we've run through the entire loop and hit the far boundary, \n    // check to see that we haven't clipped an edge point along the way. \n    // Obvious... to IQ, but it never occurred to me. :)\n    //if(i>=iMax - 1) t = dt.y;\n\n    return min(t, FAR);\n}\n\n\n// Normal function. It's not as fast as the tetrahedral calculation, but more symmetrical.\nvec3 getNormal(in vec3 p, float t){\n\t\n    //return normalize(vec3(map(p + e.xyy) - map(p - e.xyy), \n    //                      map(p + e.yxy) - map(p - e.yxy),\t\n    //                      map(p + e.yyx) - map(p - e.yyx)));\n    \n    // This mess is an attempt to speed up compiler time by contriving a break... It's \n    // based on a suggestion by IQ. I think it works, but I really couldn't say for sure.\n    float sgn = 1.;\n    vec3 e = vec3(.001, 0, 0), mp = e.zzz; // Spalmer's clever zeroing.\n    for(int i = min(iFrame, 0); i<6; i++){\n\t\tmp.x += map(p + sgn*e)*sgn;\n        sgn = -sgn;\n        if((i&1)==1){ mp = mp.yzx; e = e.zxy; }\n    }\n    \n    return normalize(mp);\n}\n\n// Cheap shadows are hard. In fact, I'd almost say, shadowing particular scenes with \n// limited iterations is impossible... However, I'd be very grateful if someone could \n// prove me wrong. :)\nfloat softShadow(vec3 ro, vec3 lp, vec3 n, float k){\n\n     \n    ro += n*.0015; // Coincides with the hit condition in the \"trace\" function.\n    vec3 rd = lp - ro; // Unnormalized direction ray.\n    \n\n    float shade = 1.;\n    float t = 0.; \n    float end = max(length(rd), .0001);\n    //float stepDist = end/float(maxIterationsShad);\n    rd /= end;\n    \n    // Set the global ray direction varibles -- Used to calculate\n    // the cell boundary distance inside the \"map\" function.\n    gDir = sign(rd)*.5;\n    gRd = rd;\n\n    // Max shadow iterations - More iterations make nicer shadows, but slow things down. \n    // Obviously, the lowest number to give a decent shadow is the best one to choose. \n    for (int i = min(iFrame, 0); i<48; i++){\n\n        float d = map(ro + rd*t);\n        \n        \n        shade = min(shade, k*d/t);\n        //shade = min(shade, smoothstep(0., 1., k*h/dist)); // Thanks to IQ for this tidbit.\n        // So many options here, and none are perfect: dist += min(h, .2), \n        // dist += clamp(h, .01, stepDist), etc.\n        t += clamp(min(d, gCD), .01, .25); \n        \n        \n        // Early exits from accumulative distance function calls tend to be a good thing.\n        if (d<0. || t>end) break; \n    }\n\n    // Shadow.\n    return max(shade, 0.); \n}\n\n\n// I keep a collection of occlusion routines... OK, that sounded really nerdy. :)\n// Anyway, I like this one. I'm assuming it's based on IQ's original.\nfloat calcAO(in vec3 p, in vec3 n){\n\n\tfloat sca = 2., occ = 0.;\n    for(int i = 0; i<5; i++){\n    \n        float hr = float(i + 1)*.2/5.;        \n        float d = map(p + n*hr);\n        occ += (hr - d)*sca;\n        sca *= .7;\n    }\n    \n    return clamp(1. - occ, 0., 1.);    \n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n    \n    // Screen coordinates.    \n\tvec2 uv = (fragCoord - iResolution.xy*.5)/iResolution.y;\n    \n    // Faux screen-based lens distortion.\n    //uv *= 1. + (dot(uv, uv) - .5)*.2;\n\t\n\t// Camera Setup.\n\tvec3 ro = vec3(iTime/2., 0, -3); // Camera position, doubling as the ray origin.\n\tvec3 lk = ro + vec3(.0, .1, .25);//vec3(0, -.25, iTime);  // \"Look At\" position.\n \n    // Light positioning.\n    vec3 lp = ro + vec3(1, 1, 0);// Put it a bit in front of the camera.\n\t\n\n    // Using the above to produce the unit ray-direction vector.\n    float FOV = 1.25; // FOV - Field of view.\n    vec3 fwd = normalize(lk - ro);\n    vec3 rgt = normalize(vec3(fwd.z, 0., -fwd.x ));\n    vec3 up = cross(fwd, rgt); \n\n    // rd - Ray direction.\n    vec3 rd = normalize(uv.x*rgt + uv.y*up + fwd/FOV);\n    \n    // Rotation.\n\trd.xy *= rot2(-.15);    \n\n\t \n    \n    // Raymarch to the scene.\n    float t = trace(ro, rd);\n    \n    // Save the block distances and individual block ID.\n    vec4 svVal = gVal;\n    \n    // Scene object ID. Either the pylons or the floor.\n    float svObjID = objID;\n    \n    // Saving the block scale and local 2D base coordinates.\n    vec3 svSc = gSc;\n    vec2 svP = gP;\n    \n    vec3 svGlow = glow;\n \t\n    // Initiate the scene color to black.\n    vec3 col = vec3(0);\n\t\n\t// The ray has effectively hit the surface, so light it up.\n\tif(t < FAR){\n        \n  \t\n    \t// Surface position and surface normal.\n\t    vec3 sp = ro + rd*t;\n\t    //vec3 sn = getNormal(sp, edge, crv, ef, t);\n        vec3 sn = getNormal(sp, t);\n        \n        // Light direction vector.\n\t    vec3 ld = lp - sp;\n\n        // Distance from respective light to the surface point.\n\t    float lDist = max(length(ld), .001);\n    \t\n    \t// Normalize the light direction vector.\n\t    ld /= lDist;\n        \n          \n        // Obtaining the texel color. \n\t    vec3 oCol; \n        \n        \n        // Standard material properties: Roughness, matType and reflectance.\n        //\n        float roughness = 1.; // Lower roughness reflects more light, as expected.\n        float matType = 1.; // Dielectric (non conducting): 0, or metallic: 1.\n        float reflectance = .25; // Reflective strength.\n\n\n        // The extruded grid.\n        if(svObjID>.5){\n            \n            \n            // Random coloring using IQ's short versatile palette formula.\n            float rnd = hash21(svVal.zw + .34);\n            vec3 sCol = .5 + .45*cos(6.2831853*rnd/7. + vec3(0, 1, 2)*1.5 - .5);\n             \n            // Changing color on the metal plates. Doesn't work here.\n            //vec3 gr = vec3(1)*dot(sCol, vec3(.299, .587, .114));\n            //if(hash21(svGID.zw + .24)<1.66 && -svGID.x>.035) sCol = sCol/4. + gr*.75;\n            \n \n            sCol = mix(sCol, sCol*vec3(4, 1, .5), smoothstep(0., 1., sp.z + svSc.z));\n            sCol += sCol*svGlow/4.;\n            //sCol = mix(sCol, sCol.xzy, smoothstep(0., 1., uv.y + .15)); \n            \n            // Coloring the rivots.\n            if(svObjID==2.) sCol = sCol/2.; \n           \n          \n            // Coloring the individual blocks with the saved ID.\n            vec3 tx = getTex(iChannel1, svVal.zw);\n            //sCol = smoothstep(0., .5, tx);\n            // Grunge texturing.\n            vec3 tx2 = tex3D(iChannel1, sp - vec3(0, 0, -svSc.z), sn);\n            // Combining.\n            oCol = sCol*(tx2*2.);\n            //oCol = tx.yzx*.65;//\n            \n            // Texture based roughness.\n            float grT = dot(tx2, vec3(.299, .587, .114)); \n            roughness *= grT*grT*4. + .2;\n            \n            // More roughness for the rivots.\n            if(svObjID==2.) roughness *= 1.5;\n            \n \n        }\n        else {\n            \n            // The dark floor in the background. Hidden behind the pylons, but\n            // I'm including it anyway.\n            //vec3 tx = getTex(iChannel1, sp.xy);\n            //oCol = vec3(.1)/8.*(tx*2. + 1.);\n            \n            // Add some glow to the floor. It's barely seen, but it's there.\n            oCol = vec3(4, 1, .5)*svGlow/4.; \n        }\n      \n        \n        // Shadows and ambient self shadowing.\n    \tfloat sh = softShadow(sp, lp, sn, 16.);\n    \tfloat ao = calcAO(sp, sn); // Ambient occlusion.\n\t    \n\t    // Light attenuation, based on the distances above.\n\t    float atten = 1./(1. + lDist*.05);\n    \t\n         \n         \n        // Cheap specular reflections. Requires loading the \"Forest\" cube map \n        // into \"iChannel2\".\n        float speR = pow(max(dot(normalize(ld - rd), sn), 0.), 5.);\n        vec3 rf = reflect(rd, sn); // Surface reflection.\n        vec3 rTx = texture(iChannel2, rf.xzy*vec3(1, -1, -1), 1.).xyz; rTx *= rTx;\n        oCol = oCol + oCol*speR*rTx*1.5;\n         \n         \n        \n        // I wanted to use a little more than a constant for ambient light this \n        // time around, but without having to resort to sophisticated methods, then I\n        // remembered Blackle's example, here:\n        // Quick Lighting Tech - blackle\n        // https://www.shadertoy.com/view/ttGfz1\n        // Studio.\n        //float am = pow(length(sin(sn*2.)*.5 + .5)/sqrt(3.), 2.)*1.5; \n        // Outdoor.\n        float am = length(sin(sn*2.)*.5 + .5)/sqrt(3.)*smoothstep(-1., 1., -sn.z); \n\n        // Specular light color. I've hacked in some depth based coloring to give\n        // the impression that the lower tiles are warmer... Completely fake. :)\n        vec3 lCol = mix(vec3(4, 1, .5), vec3(1, 2, 8), \n                        smoothstep(0., 1., -sp.z + svSc.z)*.5 + .5);\n\n        // Cook-Torrance based lighting. The last term is specular coloring.\n        vec3 ct = BRDF(oCol, sn, ld, -rd, matType, roughness, reflectance, lCol);\n\n\n        // Combining the ambient and microfaceted terms to form the final color:\n        // None of it is technically correct, but it does the job. Note the hacky \n        // ambient shadow term. Shadows on the microfaceted metal doesn't look \n        // right without it... If an expert out there knows of simple ways to \n        // improve this, feel free to let me know. :)\n        col = (oCol*am*(.75 + sh*.25) + ct*(sh));        \n        \n        \n        // Shading.\n        col *= ao*atten;\n          \n\t\n\t}\n    \n    // Applying fog. Definitely not based on real life physics, but it\n    // looks interesting. :)\n    #if 1 \n    col = mix(col, (col + .5)*vec3(4, 2, 1), smoothstep(.15, .99, t/FAR));\n    float ux = fragCoord.x/iResolution.x;\n    col = mix(col, mix(col.zyx, col.xzy, ux), smoothstep(0., 1., uv.y + .25)); \n    #else\n    col = mix(col, (col + .5)*vec3(1, 2, 4), smoothstep(.15, .99, t/FAR));\n    #endif\n    \n    \n    #ifdef SHOW_2D_PATTERN\n    vec4 b = blocks(uv*4. + vec2(0, iTime/4.));\n    float rnd = hash21(b.zw + .34);\n    vec3 sCol = .5 + .45*cos(6.2831853*rnd/1. + vec3(0, 1, 2)*1.5);\n    float bx = sBoxS(b.xy, dim/2., .02);\n    col = mix(vec3(0), sCol, 1. - smoothstep(0., 1./iResolution.y, bx/4. + .003));\n    t = 3.; // Hack to stop the bokeh effect, which doesn't work here.\n    #endif\n    \n    // Greyscale, for those who like that bleak arthouse style. :)\n    //col = vec3(.85)*dot(col, vec3(.299, .587, .114));\n    \n \n    // Output the fragment color to the buffer.\n    fragColor = vec4(max(col, 0.), t);\n    \n\t\n}","name":"Buffer A","description":"","type":"buffer"}]}