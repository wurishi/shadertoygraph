{"ver":"0.1","info":{"id":"Ms3cWn","date":"1518415203","viewed":1021,"name":"Parabolic Transformation","username":"roice3","description":"An \"elementary\" transformation of hyperbolic space in the upper half space model. The visible plane is the \"plane at infinity\". The sphere is a horosphere that kisses the plane at the origin, also the center of the horosphere and the single fixed point.","likes":25,"published":1,"flags":32,"usePreview":0,"tags":["mobius","geometry","transformation","hyperbolic","parabolic"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tfragColor = texture(iChannel0,uv);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"//\n// View Helpers\n// http://jamie-wong.com/2016/07/15/ray-marching-signed-distance-functions/\n// \n//\n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n/**\n * Return a transform matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\n//\n// CSG Helpers\n// http://jamie-wong.com/2016/07/15/ray-marching-signed-distance-functions/\n//\n\n/**\n * Constructive solid geometry intersection operation on SDF-calculated distances.\n */\nfloat intersectSDF(float distA, float distB) {\n    return max(distA, distB);\n}\n\n/**\n * Constructive solid geometry union operation on SDF-calculated distances.\n */\nfloat unionSDF(float distA, float distB) {\n    return min(distA, distB);\n}\n\n/**\n * Constructive solid geometry difference operation on SDF-calculated distances.\n */\nfloat differenceSDF(float distA, float distB) {\n    return max(distA, -distB);\n}\n\n//\n// Color functions\n//\n\n#define twopi 6.28319\n\n// From https://www.shadertoy.com/view/ldtGDn\nvec3 hsv2rgb (vec3 hsv) \n{ \n    // from HSV to RGB color vector\n\thsv.yz = clamp (hsv.yz, 0.0, 1.0);\n\treturn hsv.z*(0.63*hsv.y*(cos(twopi*(hsv.x + vec3(0.0, 2.0/3.0, 1.0/3.0))) - 1.0) + 1.0);\n}\n\n//\n// Misc\n//\n\n// Repeat a suqare grid in two dimensions\nvoid Mod2D( inout vec2 p, vec2 size ) \n{\n\tp = mod( p + size*0.5, size) - size*0.5;\n}\n\n//\n// Complex number operations\n//\n\nvec2 C_Conj( vec2 c )\n{\n\treturn vec2( c.x, -c.y );\n}\n\nvec2 C_Mult( vec2 a, vec2 b )\n{\n\treturn vec2( a.x * b.x - a.y * b.y, a.y * b.x + a.x * b.y );\n}\n\nfloat C_MagSquared( vec2 c )\n{\n\treturn c.x * c.x + c.y * c.y;\n}\n\nvec2 C_Div( vec2 a, vec2 b )\n{\n\treturn C_Mult( a, C_Conj( b ) ) / C_MagSquared( b );\n}\n\nvec2 C_Inv( vec2 c )\n{\n\treturn C_Conj( c ) / C_MagSquared( c );\n}\n\nvec2 C_Sqrt( vec2 c )\n{\n\t// Implement me!\n\treturn c;\n}\n\n//\n// Quaternion operations\n//\n\n//\n// Mobius transformations\n//\n\nstruct Mobius\n{\n\tvec2 A;\n\tvec2 B;\n\tvec2 C;\n\tvec2 D;\n};\n\nMobius M_Scale( in Mobius m, vec2 s )\n{\n\tMobius result;\n\tresult.A = C_Mult( m.A, s );\n\tresult.B = C_Mult( m.B, s );\n\tresult.C = C_Mult( m.C, s );\n\tresult.D = C_Mult( m.D, s );\n\treturn m;\n}\n\nMobius M_Normalize( in Mobius m )\n{\n\t// See Visual Complex Analysis, p150\n\tvec2 k = C_Inv( C_Sqrt( m.A * m.D - m.B * m.C ) );\n\treturn M_Scale( m, k );\n}\n\nMobius M_Mult( in Mobius a, in Mobius b )\n{\n\tMobius result;\n\tresult.A = a.A * b.A + a.B * b.C;\n\tresult.B = a.A * b.B + a.B * b.D;\n\tresult.C = a.C * b.A + a.D * b.C;\n\tresult.D = a.C * b.B + a.D * b.D;\n\treturn M_Normalize( result );\n}\n\nvec2 M_Apply( in Mobius m, in vec2 z )\n{\n\treturn C_Div( C_Mult( m.A, z ) + m.B, C_Mult( m.C, z ) + m.D );\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//\n// Elementary transformations of hyperbolic space 1 (Parabolic), by Roice Nelson\n// license: Public Domain\n//\n// This shows an \"elementary\" transformation of hyperbolic space in the upper half space model. \n// The visible plane is the \"plane at infinity\". The sphere is a horosphere that kisses the plane \n// at the origin, which is also the center of the horosphere and the single fixed point of the\n// tranformation.\n//\n// I liberally repurposed code from the following:\n// - The very helpful ray marching tutorial at: http://jamie-wong.com/2016/07/15/ray-marching-signed-distance-functions/\n// - The beautiful particle shader at: https://www.shadertoy.com/view/ld3GWS\n//\n\nconst int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float EPSILON = 0.0001;\n\n// Signed distance function for a sphere kissing the origin with radius r.\nfloat sphereSdf(vec3 p, float r) \n{\n    p.z -= r;\n    return length(p) - r;\n}\n\n// Signed distance function for the z=0 plane\nfloat planeSdf( vec3 p )\n{\n    return p.z;\n}\n\nfloat sceneSDF(vec3 samplePoint) {\n    \n\tfloat plane = planeSdf( samplePoint );\n    float sphere = sphereSdf( samplePoint, .75 );\n    float combined = unionSDF( sphere, plane );\n    return combined;\n}\n\n// Particle time constants\nconst float time_factor = 0.75;                               // Time in s factor, <1. for slow motion, >1. for faster movement\n\n// Particle intensity constants\nconst float part_int_div = 40000.;                            // Divisor of the particle intensity. Tweak this value to make the particles more or less bright\nconst float part_int_factor_min = 0.1;                        // Minimum initial intensity of a particle\nconst float part_int_factor_max = 3.2;                        // Maximum initial intensity of a particle\nconst float mp_int = 12.;                                     // Initial intensity of the main particle\nconst float dist_factor = 3.;                                 // Distance factor applied before calculating the intensity\nconst float ppow = 1.9;  \n\n// Particle color constants\nconst float part_min_hue = -0.13;                             // Minimum particle hue shift (spectrum width = 1.)\nconst float part_max_hue = 0.13;                              // Maximum particle hue shift (spectrum width = 1.)\nconst float part_min_saturation = 0.5;                        // Minimum particle saturation (0. to 1.)\nconst float part_max_saturation = 0.9;                        // Maximum particle saturation (0. to 1.)\nconst float hue_time_factor = 0.035;                          // Time-based hue shift\nconst float mp_hue = 0.5;                                     // Hue (shift) of the main particle\nconst float mp_saturation = 0.18;        \n\n// Particle star constants\nconst vec2 part_starhv_dfac = vec2(9., 0.32);                 // x-y transformation vector of the distance to get the horizontal and vertical star branches\nconst float part_starhv_ifac = 0.25;                          // Intensity factor of the horizontal and vertical star branches\nconst vec2 part_stardiag_dfac = vec2(13., 0.61);              // x-y transformation vector of the distance to get the diagonal star branches\nconst float part_stardiag_ifac = 0.19;                        // Intensity factor of the diagonal star branches\n\nconst float mb_factor = 0.88;                                 // Mix factor for the multipass motion blur factor\n\n\nvec3 getParticleColor_mp( float pint )\n{\n   float hue;\n   float saturation;\n   \n   saturation = 0.75/pow(pint, 2.5) + mp_saturation;\n   float time2 = time_factor*iTime;\n   hue = hue_time_factor*time2 + mp_hue;\n\n   return hsv2rgb(vec3(hue, saturation, pint));\n}\n\nfloat particleColorInt( vec2 p )\n{\n    float dist = length( p );\n    vec2 uv = p;\n    vec2 ppos = vec2( 0., 0. );\n    \n        // Draws the eight-branched star\n        // Horizontal and vertical branches\n        vec2 uvppos = uv - ppos;\n        float distv = distance(uvppos*part_starhv_dfac + ppos, ppos);\n        float disth = distance(uvppos*part_starhv_dfac.yx + ppos, ppos);\n        // Diagonal branches\n        vec2 uvpposd = 0.7071*vec2(dot(uvppos, vec2(1., 1.)), dot(uvppos, vec2(1., -1.)));\n        float distd1 = distance(uvpposd*part_stardiag_dfac + ppos, ppos);\n        float distd2 = distance(uvpposd*part_stardiag_dfac.yx + ppos, ppos);\n        // Middle point intensity star inensity\n        float pint1 = 1./(dist*dist_factor + 0.015) + \n            part_starhv_ifac/(disth*dist_factor + 0.01) + \n            part_starhv_ifac/(distv*dist_factor + 0.01) + \n            part_stardiag_ifac/(distd1*dist_factor + 0.01) + \n            part_stardiag_ifac/(distd2*dist_factor + 0.01);\n        \n        if (part_int_factor_max*pint1>6.)\n        {\n            float pint = part_int_factor_max*(pow(pint1, ppow)/part_int_div)*mp_int;\n           \treturn pint;\n        }\n    \n    return 0.;\n}\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nvec3 shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    float accum = 0.;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) \n    {\n        vec3 current = eye + depth * marchingDirection;\n        float dist = sceneSDF( current );\n        if (dist < EPSILON) \n        {\n            vec3 samplePoint = current;\n\n            // Inversion\n            float t = dot( samplePoint, samplePoint );\n            samplePoint /= t;\n\n            // Move the points and mod to get a repeating grid.\n            float spacing = 0.15;\n            samplePoint.xy += vec2( iTime*spacing/2., spacing/2. );\n            Mod2D( samplePoint.xy, vec2( spacing, spacing ) );\n\n\t\t\t// Calc the point intentsity.\n            float pint = particleColorInt( samplePoint.xy );\n            return vec3( pint, depth, 0. );\n        }\n\n        depth += dist;\n      \n        if (depth >= end) \n        {\n            return vec3( 0., end, 0. );\n        }\n    }\n    \n    return vec3( 0., end, 0. );\n}\n\n// Mobius\nMobius m;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    // Setup Mobius (not currently using this, but will for other classes of transformations)\n    float t = sqrt( 2. ) / 2.;\n    m.A = vec2( 0., 0. );\n    m.B = vec2( -1., 0. );\n    m.C = vec2( 1., 0. );\n    m.D = vec2( -1., 0. );\n    \n    // Setup the view.\n\tvec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);\n    vec3 eye = vec3(-2., -2., 1.5)*2.;\n    vec3 lookat = vec3( 0., 0., 0.5 );\n    mat3 viewToWorld = viewMatrix(eye, lookat, vec3(0.0, 0.0, 1.0));    \n    vec3 worldDir = viewToWorld * viewDir;\n    \n    // Raymarch.\n    vec3 distVec = shortestDistanceToSurface(eye, worldDir, MIN_DIST, MAX_DIST);\n\n    // Color.\n    vec3 color = vec3( 0., 0., 0. );\n    if( distVec.x > 0. )\n    {\n        color = getParticleColor_mp( distVec.x );\n    }\n    \n    // Multipass motion blur\n    vec2 uv2 = fragCoord.xy / iResolution.xy;\n    vec3 pcolor = texture(iChannel0,uv2).rgb*mb_factor;\n    pcolor += color*0.9;\n    fragColor = vec4( pcolor, 0. );\n}","name":"Buf A","description":"","type":"buffer"}]}