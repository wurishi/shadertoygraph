{"ver":"0.1","info":{"id":"cdcXRn","date":"1679278983","viewed":120,"name":"HexTilingTest","username":"bytearray","description":"very basic implementation of \nhttps://jcgt.org/published/0011/03/05/\n\nuse mouse to scale/rotate patches!","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["tiling"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4df3Rr","filepath":"/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","previewfilepath":"/media/ap/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define TRI_HEIGHT 0.866025\n\nvec2 randomOffsetUv(vec2 uv, vec2 vertex) {\n    vec2 offset = fract(vertex * vec2(37625.7264, 7891.2846));\n    \n    return (fract(uv * 0.8 + 0.5) + offset) / 2.;\n}\n\nvec2 skew(vec2 xy)\n{\n    xy.y /= TRI_HEIGHT;\n    xy.x = xy.x + xy.y / 2.;\n    return xy;\n}\n\nvec2 unskew(vec2 ab)\n{\n    ab.x -= ab.y / 2.;\n    ab.y *= TRI_HEIGHT;\n    return ab;\n}\n\nvec3 blend(vec3 c1, vec3 c2, vec3 c3, vec3 w, float gamma)\n{\n    w = pow(w, vec3(gamma));\n    w /= w.x + w.y + w.z;\n    \n    return w.x * c1 + w.y * c2 + w.z * c3;\n}\n\nvec3 gain3(vec3 x, float k)\n{\n    vec3 s = 2.*step(0.5, x);\n    vec3 m = 2.*(1. - s);\n    vec3 res = 0.5*s + 0.25*m * pow(max(vec3(0.), s + x*m), vec3(k));\n    return res / (res.x + res.y + res.z);\n}\n\nvec3 blendColor(vec3 c1, vec3 c2, vec3 c3, vec3 w, float gamma, float k)\n{\n    vec3 luminanceCorr = vec3(0.299, 0.587, 0.114);\n    vec3 corr = vec3(\n        dot(c1, luminanceCorr),\n        dot(c2, luminanceCorr),\n        dot(c3, luminanceCorr)\n    );\n    \n    w = corr * pow(w, vec3(gamma));\n    w /= w.x + w.y + w.z;\n    w = gain3(w, k);\n    \n    // uncomment to too see color blend weights\n    // return w.x * vec3(1., 0., 0.) + w.y * vec3(0., 1., 0.) + w.z * vec3(0., 0., 1.);\n    \n    return w.x * c1 + w.y * c2 + w.z * c3;\n}\n\nvec2 rotate(vec2 v, float a) {\n\tfloat s = sin(a);\n\tfloat c = cos(a);\n\tmat2 m = mat2(c, -s, s, c);\n\treturn m * v;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 args = vec2(iTime * 0.01, 3);\n    if(iMouse.xy != vec2(0)) {\n        args = iMouse.xy * vec2(0.001, 0.01);\n    }\n\n    vec2 xy = fragCoord/iResolution.xx * (args.y);\n    \n    vec2 ab = skew(xy);\n    \n    vec2 AB = ab - fract(ab);\n    bool isLeft = fract(ab.x) > fract(ab.y);\n    \n    int cell = int(mod(-AB.x - AB.y, 3.));\n    \n    vec2 v[] = vec2[](\n        AB + (isLeft ? vec2(1., 0.) : vec2(0., 1.)),\n        AB + vec2(1., 1.),\n        AB + vec2(0., 0.)\n    );\n    \n    vec2 v1 = unskew(v[(cell + 0) % 3]);\n    vec2 v2 = unskew(v[(cell + 1) % 3]);\n    vec2 v3 = unskew(v[(cell + 2) % 3]);\n    \n    // barycentric = 1 - trilinear for equilateral triangles\n    vec3 bary = 1. - vec3(\n        distance(xy, v1),\n        distance(xy, v2),\n        distance(xy, v3)\n    );\n    \n    float a = args.x; // iTime * 0.01;\n    \n    vec2 uv1 = rotate(xy - v1, a);\n    vec2 uv2 = rotate(xy - v2, a);\n    vec2 uv3 = rotate(xy - v3, a);\n    \n    vec3 c1 = texture(iChannel0, randomOffsetUv(uv1, v1)).rgb;\n    vec3 c2 = texture(iChannel0, randomOffsetUv(uv2, v2)).rgb;\n    vec3 c3 = texture(iChannel0, randomOffsetUv(uv3, v3)).rgb;\n    \n    vec3 col = blendColor(c1, c2, c3, bary, 3., 6.);\n    // vec3 col = vec3(float(cell) / 3., 0., 0.);\n    fragColor = vec4(col, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}