{"ver":"0.1","info":{"id":"XslfWr","date":"1495731502","viewed":133,"name":"Globular","username":"brainslug","description":"Raymarching spheres","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raymarch"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define EPSILON 0.002\n#define MAX_STEPS 32\n#define FAR_CLIP 200.0\n#define RADIUS .95\n\nfloat map(vec3 p)\n{\n    vec3 s = vec3(2.0);\n    vec3 m = mod(p, s) - 0.5 * s;\n    return length(m) - sin(iTime * RADIUS) * 0.5 - 0.5;\n}\n\nvec3 getNormal(vec3 p)\n{\n    return normalize(vec3(\n\tmap(vec3(p.x + EPSILON, p.y, p.z)) - map(vec3(p.x - EPSILON, p.y, p.z)),\n\tmap(vec3(p.x, p.y + EPSILON, p.z)) - map(vec3(p.x, p.y - EPSILON, p.z)),\n\tmap(vec3(p.x, p.y, p.z + EPSILON)) - map(vec3(p.x, p.y, p.z - EPSILON))\n\t));\n}\n\nvec3 trace(vec3 o, vec3 r)\n{\n    float t = 0.0;\n    vec3 p;\n    for (int i = 0; i < MAX_STEPS; i++)\n    {\n        p = o + (r * t);\n        float d = map(p);\n        \n        if (d < EPSILON)\n        {\n            break;\n        }\n        \n        t += d * 0.5;\n        \n        if (t > FAR_CLIP)\n        {\n            return vec3(0.0);\n        }\n    }\n    \n    return (getNormal(p) + vec3(1.0)) / 2.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec3 o = vec3(0.0, 0.0, iTime);\n    vec3 focus = vec3(0.0, 1.0, iTime + 1.0);\n    \n    vec3 lookDir = normalize(focus - o);\n    vec3 up = vec3(0.0, 1.0, 0.0);\n    vec3 right = cross(lookDir, up);\n    float fov = 3.;\n    \n    vec3 r = normalize(right * uv.x + up * uv.y + fov * lookDir);\n    \n    vec3 t = trace(o, r);\n    \n    vec3 col = vec3(0.0, 0.75, 0.5);\n    \n    vec3 fc = t;\n    \n\tfragColor = vec4(fc,1.0);\n}","name":"Image","description":"","type":"image"}]}