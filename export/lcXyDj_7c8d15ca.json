{"ver":"0.1","info":{"id":"lcXyDj","date":"1721587222","viewed":294,"name":"Not today","username":"ODtian","description":"See you again. You can control the cam using keyboard. (WASD to move, arrow keys to change the view dir)","likes":8,"published":1,"flags":48,"usePreview":1,"tags":["raymarching","plane","pbr","procedure"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// The MIT License\n// Copyright © 2013 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n//\n// The license is here only not because I want to (can one\n// license pieces of math?), but because people get upset\n// if I don't add one...\n\n// A list of useful distance function to simple primitives. All\n// these functions (except for ellipsoid) return an exact\n// euclidean distance, meaning they produce a better SDF than\n// what you'd get if you were constructing them from boolean\n// operations (such as cutting an infinite cylinder with two planes).\n\n// List of other 3D SDFs:\n//    https://www.shadertoy.com/playlist/43cXRl\n// and\n//    https://iquilezles.org/articles/distfunctions\n\n// #if HW_PERFORMANCE==0\n// #iFirstPersonControls\n#define AA 1\n#define rot3x(x) mat4(1, 0, 0, 0, 0, cos(x), sin(x), 0, 0, -sin(x), cos(x), 0, 0, 0, 0, 1)\n#define rot3y(x) mat4(cos(x), 0, -sin(x), 0, 0, 1, 0, 0, sin(x), 0, cos(x), 0, 0, 0, 0, 1)\n#define rot3z(x) mat4(cos(x), sin(x), 0, 0,  -sin(x), cos(x), 0, 0, 0, 0, 1, 0, 0, 0, 0, 1)\n#define translate3(x, y, z) mat4(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, x, y ,z, 1)\n#define rot2(x) mat2(cos(x), -sin(x), sin(x), cos(x))\n\n#define PI 3.1415926\n// #iChannel0 \"file://controller.glsl\"\n\n// #else\n// #define AA 1   // make this 2 or 3 for antialiasing\n// #endif\n\n//------------------------------------------------------------------\n// float N2(vec2 p) {\t// Dave Hoskins - https://www.shadertoy.com/view/4djSRW\n//     p = mod(p, vec2(1456.2346));\n//     vec3 p3 = fract(vec3(p.xyx) * vec3(443.897, 441.423, 437.195));\n//     p3 += dot(p3, p3.yzx + 19.19);\n//     return fract((p3.x + p3.y) * p3.z);\n// }\n\n// float Noise2(vec2 uv) {\n//     vec2 corner = floor(uv);\n//     float c00 = N2(corner + vec2(0.0, 0.0));\n//     float c01 = N2(corner + vec2(0.0, 1.0));\n//     float c11 = N2(corner + vec2(1.0, 1.0));\n//     float c10 = N2(corner + vec2(1.0, 0.0));\n\n//     vec2 diff = fract(uv);\n\n//     diff = diff * diff * (vec2(3) - vec2(2) * diff);\n//     //diff = smoothstep(vec2(0), vec2(1), diff);\n\n//     return mix(mix(c00, c10, diff.x), mix(c01, c11, diff.x), diff.y);\n// }\n\n// float cloudSky(vec2 skyUv, float blur) {\n//     float sum = Noise2(skyUv);\n//     float div = 1.0;\n\n//     if (blur < 0.75) {\n//         sum += Noise2(skyUv * 8.0) * 0.1 - 0.05;\n\n//         if (blur < 0.50) {\n//             sum += Noise2(skyUv * 4.0) * 0.25 - 0.125;\n\n//             if (blur < 0.25) {\n//                 sum += Noise2(skyUv * 2.0) * 0.5 - 0.25;\n//             }\n//         }\n//     }\n//     sum /= 3.0;\n//     return sum;\n// }\n\n// vec3 SkyDome(vec3 rayDir, float blur) {\n//     float blue = clamp(rayDir.y * 2.0 + 0.7, 0.0, 1.0);\n//     vec3 col = mix(vec3(0.8, 0.9, 1.0), vec3(0.5, 0.6, 1.0), blue);\n\n//     vec2 dome = rayDir.xz;\n//     float len = length(dome);\n\n//     float a = atan(rayDir.x, rayDir.z);\n\n//     // Compute 2 layers of clouds and blend them with longitude to mask the vertical seam\n//     vec2 skyUv = vec2(a * 7.5 - iTime * 0.1, rayDir.y * 10.0);\n//     float cloud1 = cloudSky(skyUv, blur);\n\n//     vec2 skyUv2 = vec2((a + PI * 2.0) * 7.5 - iTime * 0.1, rayDir.y * 10.0);\n//     float cloud2 = cloudSky(skyUv2, blur);\n\n//     float ratio = 1.0 - (a + PI) / PI / 2.0;\n//     float cloud = mix(cloud1, cloud2, ratio);\n\n//     // Mask the cloud across a horizontal band\n//     float cloudMask = smoothstep(0.8, 0.0, abs(rayDir.y + 0.2));\n//     cloud *= cloudMask;\n\n//     // When blurred the clouds are merely the mask itself\n//     cloud = mix(cloud, cloudMask * (1.0 - blur * 0.6), blur);\n\n//     // Add some burn around the sun\n//     float sun = max(0.0, dot(rayDir, normalize(vec3(-1.0, 0.4, -1))) - 0.3);\n\n//     col.rgb += cloud;\n//     col.rgb += sun * sun * sun;\n\n//     //col.rgb = mix(col.rgb, vec3(0, 1, 0), S(-0.5, -1.0, rayDir.y));\n\n//     return col;\n// }\n\nfloat dot2(in vec2 v) {\n    return dot(v, v);\n}\nfloat dot2(in vec3 v) {\n    return dot(v, v);\n}\n\nfloat sdRoundBox(vec3 p, vec3 b, float r) {\n    vec3 q = abs(p) - b + r;\n    return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0) - r;\n}\n\nfloat sdCappedCylinder(vec3 p, vec3 a, vec3 b, float r) {\n    vec3 ba = b - a;\n    vec3 pa = p - a;\n    float baba = dot(ba, ba);\n    float paba = dot(pa, ba);\n    float x = length(pa * baba - ba * paba) - r * baba;\n    float y = abs(paba - baba * 0.5) - baba * 0.5;\n    float x2 = x * x;\n    float y2 = y * y * baba;\n    float d = (max(x, y) < 0.0) ? -min(x2, y2) : (((x > 0.0) ? x2 : 0.0) + ((y > 0.0) ? y2 : 0.0));\n    return sign(d) * sqrt(abs(d)) / baba;\n}\n\nfloat sdRoundCone(vec3 p, vec3 a, vec3 b, float r1, float r2) {\n    // sampling independent computations (only depend on shape)\n    vec3 ba = b - a;\n    float l2 = dot(ba, ba);\n    float rr = r1 - r2;\n    float a2 = l2 - rr * rr;\n    float il2 = 1.0 / l2;\n\n    // sampling dependant computations\n    vec3 pa = p - a;\n    float y = dot(pa, ba);\n    float z = y - l2;\n    float x2 = dot2(pa * l2 - ba * y);\n    float y2 = y * y * l2;\n    float z2 = z * z * l2;\n\n    // single square root!\n    float k = sign(rr) * rr * rr * x2;\n    if (sign(z) * a2 * z2 > k)\n        return sqrt(x2 + z2) * il2 - r2;\n    if (sign(y) * a2 * y2 < k)\n        return sqrt(x2 + y2) * il2 - r1;\n    return (sqrt(x2 * a2 * il2) + y * rr) * il2 - r1;\n}\n\nfloat sdSphere(vec3 p, float s) {\n    return length(p) - s;\n}\n\nfloat sdBox(vec3 p, vec3 b) {\n    vec3 d = abs(p) - b;\n    return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));\n}\n//------------------------------------------------------------------\n\nconst int MAX_MARCHING_STEPS = 255;\nconst int MAX_SHADOW_STEPS = 15;\n\nconst float PRECISION = 1e-5;\nconst float MAX_DIST = 100.0;\n\n#define PI 3.1415926\n\nstruct Material {\n    // vec3 ambientColor; // k_a * i_a\n    vec3 albedo;\n    float roughness;\n    float metallic;\n};\n\n// struct Material {\n//     vec3 ambientColor; // k_a * i_a\n//     vec3 diffuseColor; // k_d * i_d\n//     vec3 specularColor; // k_s * i_s\n//     float alpha; // shininess\n// };\n\nstruct Surface {\n    // int id; // id of object\n    float d; // signed distance\n    Material mat;\n};\n\nfloat pow5(float x) {\n    float pow2 = x * x;\n    return pow2 * pow2 * x;\n}\n\n// https://blog.csdn.net/qq_28299311/article/details/123312767\nvec3 DisneyDiffuse(float NdotV, float NdotL, float LdotH, float roughness, vec3 base_color) {\n    float fd90 = 0.5 + 2.0 * LdotH * LdotH * roughness;\n    // Two schlick fresnel term\n    float light_scatter = (1.0 + (fd90 - 1.0) * pow5(1.0 - NdotL));\n    float view_scatter = (1.0 + (fd90 - 1.0) * pow5(1.0 - NdotV));\n    return (base_color / PI) * light_scatter * view_scatter;\n}\n\n// D\nfloat D_GGX_TR(float NdotH, float roughness) {\n    float a2 = roughness * roughness;\n    float NdotH2 = NdotH * NdotH;\n    float denom = (NdotH2 * (a2 - 1.0) + 1.0);\n    denom = PI * denom * denom;\n    denom = max(denom, 0.001); //防止分母为0\n    return a2 / denom;\n}\n\n// G\nfloat GeometrySchlickGGX(float NdotV, float k) {\n    float nom = NdotV;\n    float denom = NdotV * (1.0 - k) + k;\n\n    return nom / denom;\n}\n\nfloat GeometrySmith(float NdotV, float NdotL, float k) {\n    float ggx1 = GeometrySchlickGGX(NdotV, k);\n    float ggx2 = GeometrySchlickGGX(NdotL, k);\n\n    return ggx1 * ggx2;\n}\n// float GeometrySmith(vec3 N, vec3 V, vec3 L, float k) {\n//     float NdotV = max(dot(N, V), 0.0);\n//     float NdotL = max(dot(N, L), 0.0);\n//     float ggx1 = GeometrySchlickGGX(NdotV, k);\n//     float ggx2 = GeometrySchlickGGX(NdotL, k);\n\n//     return ggx1 * ggx2;\n// }\n\n// F\nvec3 F_Schlick(float HdotV, vec3 F0) {\n    return F0 + (1.0 - F0) * pow(1.0 - HdotV, 5.0);\n}\n\nvec2 PrefilteredDFG_Karis(float roughness, float NoV) {\n    // Karis 2014, \"Physically Based Material on Mobile\"\n    const vec4 c0 = vec4(-1.0, -0.0275, -0.572, 0.022);\n    const vec4 c1 = vec4(1.0, 0.0425, 1.040, -0.040);\n\n    vec4 r = roughness * c0 + c1;\n    float a004 = min(r.x * r.x, exp2(-9.28 * NoV)) * r.x + r.y;\n\n    return vec2(-1.04, 1.04) * a004 + r.zw;\n}\n\nvec3 Irradiance_SphericalHarmonics(const vec3 n) {\n    // Irradiance from \"Ditch River\" IBL (http://www.hdrlabs.com/sibl/archive.html)\n    return max(vec3(0.754554516862612, 0.748542953903366, 0.790921515418539) + vec3(-0.083856548007422, 0.092533500963210, 0.322764661032516) * (n.y) + vec3(0.308152705331738, 0.366796330467391, 0.466698181299906) * (n.z) + vec3(-0.188884931542396, -0.277402551592231, -0.377844212327557) * (n.x), 0.0);\n}\n\nvec3 Tonemap_ACES(const vec3 x) {\n    // Narkowicz 2015, \"ACES Filmic Tone Mapping Curve\"\n    const float a = 2.51;\n    const float b = 0.03;\n    const float c = 2.43;\n    const float d = 0.59;\n    const float e = 0.14;\n    return (x * (a * x + b)) / (x * (c * x + d) + e);\n}\n//------------------------------------------------------------------\n\n#define ZERO (min(iFrame,0))\n\n//------------------------------------------------------------------\n\nSurface surf_op_union(Surface s1, Surface s2) {\n    if (s1.d < s2.d) {\n        return s1;\n    } else {\n        return s2;\n    }\n}\n\nSurface surf_op_sub(Surface s1, Surface s2) {\n    s2.d *= -1.0;\n    if (s1.d > s2.d) {\n        return s1;\n    } else {\n        return s2;\n    }\n}\n\nSurface surf_op_smooth_union(Surface s1, Surface s2, float k) {\n    float h = clamp(0.5 + 0.5 * (s2.d - s1.d) / k, 0.0, 1.0);\n\n    vec3 p1 = vec3(s1.d, s1.mat.roughness, s1.mat.metallic), p2 = vec3(s2.d, s2.mat.roughness, s2.mat.metallic);\n    p1 = mix(p2, p1, h) - k * h * (1.0 - h);\n\n    s1.mat.albedo = mix(s2.mat.albedo, s1.mat.albedo, h) - k * h * (1.0 - h);\n    s1.d = p1.x;\n    s1.mat.roughness = p1.y;\n    s1.mat.metallic = p1.z;\n    return s1;\n}\n\nSurface surf_op_smooth_sub(Surface s1, Surface s2, float k) {\n    float h = clamp(0.5 - 0.5 * (s2.d + s1.d) / k, 0.0, 1.0);\n    vec3 p1 = vec3(s1.d, s1.mat.roughness, s1.mat.metallic), p2 = vec3(s2.d, s2.mat.roughness, s2.mat.metallic);\n    p1 = mix(p2, -p1, h) + k * h * (1.0 - h);\n\n    s1.mat.albedo = mix(s2.mat.albedo, s1.mat.albedo, h) - k * h * (1.0 - h);\n    s1.d = p1.x;\n    s1.mat.roughness = p1.y;\n    s1.mat.metallic = p1.z;\n    return s1;\n}\n\nSurface surf_op_smooth_intersection(Surface s1, Surface s2, float k) {\n    float h = clamp(0.5 - 0.5 * (s2.d - s1.d) / k, 0.0, 1.0);\n    vec3 p1 = vec3(s1.d, s1.mat.roughness, s1.mat.metallic), p2 = vec3(s2.d, s2.mat.roughness, s2.mat.metallic);\n    p1 = mix(p2, p1, h) + k * h * (1.0 - h);\n\n    s1.mat.albedo = mix(s2.mat.albedo, s1.mat.albedo, h) - k * h * (1.0 - h);\n    s1.d = p1.x;\n    s1.mat.roughness = p1.y;\n    s1.mat.metallic = p1.z;\n    return s1;\n}\n\nfloat op_union(float d1, float d2) {\n    return min(d1, d2);\n}\n\nfloat op_inter(float d1, float d2) {\n    return max(d1, d2);\n}\n\nfloat op_sub(float d1, float d2) {\n    return max(d1, -d2);\n}\n\nfloat op_smooth_union(float d1, float d2, float k) {\n    float h = clamp(0.5 + 0.5 * (d2 - d1) / k, 0.0, 1.0);\n    return mix(d2, d1, h) - k * h * (1.0 - h);\n}\n\nfloat op_smooth_subtraction(float d1, float d2, float k) {\n    float h = clamp(0.5 - 0.5 * (d2 + d1) / k, 0.0, 1.0);\n    return mix(d2, -d1, h) + k * h * (1.0 - h);\n}\n\nfloat op_smooth_intersection(float d1, float d2, float k) {\n    float h = clamp(0.5 - 0.5 * (d2 - d1) / k, 0.0, 1.0);\n    return mix(d2, d1, h) + k * h * (1.0 - h);\n}\n\nSurface map(vec3 pos) {\n    Surface co;\n    Material body;\n    co.d = pos.y;\n\n    mat4 plane_origin = translate3(0.0, 10.0 + sin(iTime * 1.1 + 0.1) * 0.03, 0.0) * rot3x(sin(iTime * 1.33) * 0.01) * rot3z(sin(iTime) * 0.03 - 0.1) * mat4(1.0), inv_plane_origin = inverse(plane_origin);\n    vec3 plane_pos = (inv_plane_origin * vec4(pos, 1.0)).xyz;\n    plane_pos.z = -abs(plane_pos.z);\n    float d = pos.y;\n    d = op_union(d, sdRoundCone(plane_pos - vec3(0.0, 0.35, 0.0), vec3(0.1, 0.00, 0.0), vec3(-0.15, -0.064, 0.0), 0.18, 0.08 * (smoothstep(-1.0, 0.9, plane_pos.x))));\n\n    d = op_smooth_union(d, sdRoundCone(plane_pos - vec3(0.0, 0.35, 0.0), vec3(0.04, -0.03, 0.0), vec3(-0.15, -0.06, 0.0), 0.145, 0.06), 0.02 * (smoothstep(-1.0, 0.9, plane_pos.x)));\n\n    d = op_union(d, sdCappedCylinder(plane_pos - vec3(0.0, 0.35, 0.0), vec3(0.1, 0.0, 0.0), vec3(2.0, 0.0, 0.0), 0.18));\n\n    d = op_union(d, sdRoundCone(plane_pos - vec3(2.0, 0.35, .0), vec3(0.0, 0.0, 0.0), vec3(0.4, 0.1, 0.0), 0.18, 0.08));\n    float central_box_curve = 0.08 * (smoothstep(-0.1, 1.0, plane_pos.x) - smoothstep(1.0, 1.9, plane_pos.x));\n\n    d = op_smooth_union(d, sdRoundBox(plane_pos - vec3(0.9, 0.3 - 0.2 * abs(plane_pos.z), 0.0), vec3(0.5 * (1.0 - abs(plane_pos.z)), 0.04 + central_box_curve * (1.0 - abs(plane_pos.z) * 3.0), 0.1 + central_box_curve * 1.5), 0.05), 0.04);\n    // res = opU(res, )\n    co.d = d;\n    float stripa = step(0.28, plane_pos.y) - step(0.30, plane_pos.y), stripb = step(0.25, plane_pos.y) - step(0.26, plane_pos.y), stripc = step(0.30, plane_pos.y);\n    vec3 strip = vec3(0.3, 0.0, 0.0) * stripa + vec3(0.0, 0.0, 0.3) * stripb;\n\n    body.albedo = mix(vec3(0.7), strip, vec3(stripa + stripb));\n    // body.albedo = vec3(0.6);\n    body.roughness = mix(0.01, 1.0, stripa + stripb);\n    body.metallic = mix(1.0, 0.01, stripa + stripb);\n\n    co.mat = body;\n\n    Surface wings;\n    Material mat_wing;\n    d = pos.y;\n    // duo\n    d = op_union(d, sdRoundBox(plane_pos - vec3(1.9 + plane_pos.y * 0.4, 0.8, 0.0), vec3(0.35 - plane_pos.y * 0.2, 0.3, 0.02), 0.06));\n    // yi gen\n    d = op_union(d, sdRoundBox(plane_pos - vec3(0.9 - plane_pos.z * 0.3, -0.78 + log(abs(plane_pos.z) * 2.0 + 8.0) / 2.0, -0.35), vec3(0.45 + plane_pos.z * 0.3, 0.04 + plane_pos.z * 0.02, 0.2), 0.06));\n\n    // ji yi\n    d = op_union(d, sdRoundBox(plane_pos - vec3(0.85 - plane_pos.z * 0.4, -0.78 + log(abs(plane_pos.z) * 2.0 + 8.0) / 2.0, -0.95), vec3(0.37 + plane_pos.z * 0.15, 0.04 + plane_pos.z * 0.02, 0.7), 0.06));\n\n    // shui ping weiyi\n    d = op_union(d, sdRoundBox(plane_pos - vec3(2.2 - plane_pos.z * 0.3, -0.6 + log(abs(plane_pos.z) * 2.0 + 8.0) / 2.0, -0.3), vec3(0.2 + plane_pos.z * 0.15, 0.04 + plane_pos.z * 0.05, 0.4), 0.06));\n\n    // engine\n    d = op_union(d, sdRoundBox(plane_pos - vec3(0.75 + plane_pos.y * 0.4, 0.28, -0.5), vec3(0.3 - plane_pos.y * 0.4, 0.06, 0.02), 0.06));\n\n    d = op_union(d, sdRoundCone(plane_pos - vec3(0.8, 0.20, -0.5), vec3(0.0, 0.0, 0.0), vec3(-0.15, 0.0, 0.0), 0.09, 0.10));\n\n    d = op_smooth_subtraction(sdSphere(plane_pos - vec3(0.62, 0.20, -0.5), 0.07), d, 0.04);\n\n    d = op_union(d, sdRoundCone(plane_pos - vec3(0.8, 0.20, -0.5), vec3(0.0, 0.0, 0.0), vec3(-0.17, 0.0, 0.0), 0.02, 0.01));\n\n    vec3 fan_origin_pos = vec3(0.65, 0.2, -0.5);\n    int n = 6;\n    vec3 rpos = plane_pos - fan_origin_pos;\n    float s = length(rpos), k = clamp(s, 0.0, 1.0), r = clamp(s, 0.2, 1.0);\n\n    for (int i = 0; i < n; ++i) {\n        vec3 rpos = plane_pos - fan_origin_pos;\n        rpos.yz = rot2(PI / float(n) * float(i) + float(iFrame) + (1.0 / iTimeDelta)) * rpos.yz;\n        rpos.xy = rot2(rpos.z * 8.0) * rpos.xy;\n        d = op_union(d, sdRoundBox(rpos, vec3(0.1 * r, 0.02 * k, 0.09), 0.00));\n    }\n\n\n    wings.d = d;\n\n    mat_wing.albedo = vec3(0.6);\n    mat_wing.roughness = .02;\n    mat_wing.metallic = 1.0;\n    wings.mat = mat_wing;\n    co = surf_op_smooth_union(co, wings, 0.02);\n\n    Surface windows;\n    Material mat_windows;\n\n    d = pos.y;\n    vec3 wpos = vec3(mod(clamp(plane_pos.x, 0.24, 1.92), 0.06), plane_pos.y, plane_pos.z);\n    d = op_union(d, sdRoundBox(wpos - vec3(0.03, 0.4, 0.0), vec3(0.016, 0.02, 0.8), 0.008));\n\n    d = op_union(d, sdRoundBox(plane_pos - vec3(-0.2, 0.42, -0.031), vec3(0.8, 0.02, 0.03), 0.004));\n\n    d = op_union(d, sdRoundBox(plane_pos - vec3(-0.2, 0.42, -0.088), vec3(0.8, 0.02, 0.023), 0.008));\n\n    windows.d = op_inter(co.d, d);\n    mat_windows.albedo = vec3(0.0);\n    mat_windows.roughness = 0.01;\n    mat_windows.metallic = 0.01;\n    co = surf_op_smooth_union(co, windows, 0.00);\n\n    Surface twin;\n    Material mat_twin;\n    d = pos.y;\n    d = op_union(d, sdBox(pos - vec3(10.0 + (iTime * 0.001), 8.0, 10.0), vec3(2.0, 10.0, 2.0)));\n\n    d = op_union(d, sdBox(pos - vec3(15.0 + (iTime * 0.001), 8.0, 5.0), vec3(2.0, 10.0, 2.0)));\n    twin.d = d;\n    mat_twin.albedo = vec3(0.7);\n    mat_twin.roughness = 0.6;\n    mat_twin.metallic = 0.1;\n    twin.mat = mat_twin;\n\n    co = surf_op_smooth_union(co, twin, 0.00);\n    return co;\n}\n\n\nSurface raymarch(vec3 ro, vec3 rd) {\n    float depth = 0.0;\n    Surface co;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        vec3 p = ro + depth * rd;\n        co = map(p);\n        depth += (co.d);\n        if (abs(co.d) < PRECISION || depth > MAX_DIST)\n            break;\n    }\n\n    co.d = depth;\n\n    return co;\n}\n\nvec3 calc_normal(in vec3 pos) {\n#if 0\n    vec2 e = vec2(1.0, -1.0) * 0.5773 * 0.0005;\n    return normalize(e.xyy * map(pos + e.xyy).d +\n        e.yyx * map(pos + e.yyx).d +\n        e.yxy * map(pos + e.yxy).d +\n        e.xxx * map(pos + e.xxx).d);\n#else\n    // inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times\n    vec3 n = vec3(0.0);\n    for (int i = ZERO; i < 4; i++) {\n        vec3 e = 0.5773 * (2.0 * vec3((((i + 3) >> 1) & 1), ((i >> 1) & 1), (i & 1)) - 1.0);\n        n += e * map(pos + 0.0005 * e).d;\n      //if( n.x+n.y+n.z>100.0 ) break;\n    }\n    return normalize(n);\n#endif    \n}\n\nfloat soft_shadow(vec3 ro, vec3 rd, float mint, float tmax) {\n    float res = 1.0;\n    float t = mint;\n\n    for (int i = 0; i < MAX_SHADOW_STEPS; i++) {\n        float h = map(ro + rd * t).d;\n        res = min(res, 8.0 * h / t);\n        t += clamp(h, 0.02, 0.10);\n        if (h < 0.001 || t > tmax)\n            break;\n    }\n\n    return clamp(res, 0.0, 1.0); // soft shadow\n  //return step(tmax - 0., t); //hard shadow\n}\n\n// https://iquilezles.org/articles/nvscene2008/rwwtt.pdf\nfloat calc_ao(in vec3 pos, in vec3 nor) {\n    float occ = 0.0;\n    float sca = 1.0;\n    for (int i = ZERO; i < 5; i++) {\n        float h = 0.01 + 0.12 * float(i) / 4.0;\n        float d = map(pos + h * nor).d;\n        occ += (h - d) * sca;\n        sca *= 0.95;\n        if (occ > 0.35)\n            break;\n    }\n    return clamp(1.0 - 3.0 * occ, 0.0, 1.0) * (0.5 + 0.5 * nor.y);\n}\n\nvec3 render_indirect(vec3 ro, vec3 rd) {\n    Surface co = raymarch(ro, rd);\n    vec3 pos = ro + rd * co.d; // point on surface found by ray marching\n    if (co.d > MAX_DIST) {\n        return vec3(0.75, 0.85, 1.0) - rd.y * 0.72;\n    }\n\n    vec3 light_dir = normalize(vec3(-0.5, 0.4, -0.6)), light_col = 2.0 * vec3(0.98, 0.92, 0.89);\n\n    Material mat = co.mat;\n\n    vec3 normal = calc_normal(pos); // surface normal\n    vec3 view = -rd;\n\n    float NdotL = max(0.0, dot(light_dir, normal));\n\n    float ao = calc_ao(pos, normal);\n    vec3 diffuse = mat.albedo / PI;\n    return diffuse * light_col * NdotL * ao;\n}\n\nvec3 render(vec3 ro, vec3 rd, out float d) {\n    Surface co = raymarch(ro, rd);\n    d = co.d;\n    vec3 pos = ro + rd * co.d; // point on surface found by ray marching\n    if (co.d > MAX_DIST) {\n        // return SkyDome(rd, 1.0);\n        return vec3(0.65, 0.85, 1.0) - rd.y * 0.72;\n    }\n\n    vec3 light_dir = normalize(vec3(-0.5, 0.4, -0.6)), light_col = 2.0 * vec3(0.98, 0.92, 0.89);\n\n    Material mat = co.mat;\n\n    vec3 normal = calc_normal(pos); // surface normal\n    vec3 view = -rd;\n\n    vec3 h = normalize(light_dir + view);\n    vec3 r = reflect(rd, normal);\n    // float NdotL = max(0.0, dot(light_dir, normal));\n    float NdotL = max(0.0, dot(light_dir, normal));\n    float NdotH = dot(normal, h);\n    float LdotH = max(0.0, dot(light_dir, h));\n\n    float VdotH = dot(view, h);\n    float NdotV = dot(normal, view);\n\n    float ao = calc_ao(pos, normal);\n\n    vec3 F0 = mix(vec3(0.04), mat.albedo, mat.metallic);\n\n    // vec3 diffuse = DisneyDiffuse(NdotV, NdotL, LdotH, mat.roughness, mat.albedo);\n    vec3 diffuse = mat.albedo / PI;\n    float D = D_GGX_TR(NdotH, mat.roughness);\n    float G = GeometrySmith(NdotV, NdotL, mat.roughness);\n    vec3 F = F_Schlick(VdotH, F0);\n    vec3 spec = D * G * F;\n    spec /= 4.0 * max(0.0, NdotL) * NdotV + 0.0001;\n\n    vec3 kd = (1.0 - F) * (1.0 - mat.metallic);\n    vec3 indirect = render_indirect(pos + 0.001 * normal, r);\n\n    // vec3 indirect_diffuse = ;\n    vec2 dfg = PrefilteredDFG_Karis(mat.roughness, NdotV);\n    vec3 indirect_specular_color = F0 * dfg.x + dfg.y;\n\n    indirect = diffuse * Irradiance_SphericalHarmonics(normal) + indirect * indirect_specular_color;\n    float atten = soft_shadow(pos, light_dir, PRECISION * 100.0, 20.0);\n        // vec3 ind_h = normalize(r + view);\n    // vec3 ind_F = F_Schlick(dot(view, ind_h), F0);\n    // vec3 ind_diffuse = diffuse * max(0.0, dot(r, normal)) * indirect;\n    // vec3 ind_kd = (1.0 - ind_F) * (1.0 - mat.metallic);\n    // indirect = mix(ind_diffuse, indirect, F + mat.metallic);\n    // indirect = indirect * ind_F;\n\n    return (kd * diffuse + spec) * light_col * NdotL * atten + indirect * ao;\n    // return indirect;\n    // return (diffuse + spec) * light_col * NdotL + vec3(0.1, 0.1, 0.9);\n    // return vec3(diffuse);\n}\n\n// vec3 _render(in vec3 ro, in vec3 rd, in vec3 rdx, in vec3 rdy) { \n//     // background\n//     vec3 col = vec3(0.7, 0.7, 0.9) - max(rd.y, 0.0) * 0.3;\n\n//     // raycast scene\n//     vec2 res = raycast(ro, rd);\n//     float t = res.x;\n//     float m = res.y;\n//     if (m > -0.5) {\n//         vec3 pos = ro + t * rd;\n//         vec3 nor = (m < 1.5) ? vec3(0.0, 1.0, 0.0) : calcNormal(pos);\n//         vec3 ref = reflect(rd, nor);\n\n//         // material        \n//         col = 0.2 + 0.2 * sin(m * 2.0 + vec3(0.0, 1.0, 2.0));\n//         float ks = 1.0;\n\n//         if (m < 1.5) {\n//             // project pixel footprint into the plane\n//             vec3 dpdx = ro.y * (rd / rd.y - rdx / rdx.y);\n//             vec3 dpdy = ro.y * (rd / rd.y - rdy / rdy.y);\n\n//             float f = checkersGradBox(3.0 * pos.xz, 3.0 * dpdx.xz, 3.0 * dpdy.xz);\n//             col = 0.15 + f * vec3(0.05);\n//             ks = 0.4;\n//         }\n\n//         // lighting\n//         float occ = calcAO(pos, nor);\n\n//         vec3 lin = vec3(0.0);\n\n//         // sun\n//         {\n//             vec3 lig = normalize(vec3(-0.5, 0.4, -0.6));\n//             vec3 hal = normalize(lig - rd);\n//             float dif = clamp(dot(nor, lig), 0.0, 1.0);\n//             if (dif > 0.0001)\n//                 dif *= calcSoftshadow(pos, lig, 0.02, 2.5);\n//             float spe = pow(clamp(dot(nor, hal), 0.0, 1.0), 16.0);\n//             spe *= dif;\n//             spe *= 0.04 + 0.96 * pow(clamp(1.0 - dot(hal, lig), 0.0, 1.0), 5.0);\n//                 //spe *= 0.04+0.96*pow(clamp(1.0-sqrt(0.5*(1.0-dot(rd,lig))),0.0,1.0),5.0);\n//             lin += col * 2.20 * dif * vec3(1.30, 1.00, 0.70);\n//             lin += 5.00 * spe * vec3(1.30, 1.00, 0.70) * ks;\n//         }\n//         // sky\n//         {\n//             float dif = sqrt(clamp(0.5 + 0.5 * nor.y, 0.0, 1.0));\n//             dif *= occ;\n//             float spe = smoothstep(-0.2, 0.2, ref.y);\n//             spe *= dif;\n//             spe *= 0.04 + 0.96 * pow(clamp(1.0 + dot(nor, rd), 0.0, 1.0), 5.0);\n//           //if( spe>0.001 )\n//             spe *= calcSoftshadow(pos, ref, 0.02, 2.5);\n//             lin += col * 0.60 * dif * vec3(0.40, 0.60, 1.15);\n//             lin += 2.00 * spe * vec3(0.40, 0.60, 1.30) * ks;\n//         }\n//         // back\n//         {\n//             float dif = clamp(dot(nor, normalize(vec3(0.5, 0.0, 0.6))), 0.0, 1.0) * clamp(1.0 - pos.y, 0.0, 1.0);\n//             dif *= occ;\n//             lin += col * 0.55 * dif * vec3(0.25, 0.25, 0.25);\n//         }\n//         // sss\n//         {\n//             float dif = pow(clamp(1.0 + dot(nor, rd), 0.0, 1.0), 2.0);\n//             dif *= occ;\n//             lin += col * 0.25 * dif * vec3(1.00, 1.00, 1.00);\n//         }\n\n//         col = lin;\n\n//         col = mix(col, vec3(0.7, 0.7, 0.9), 1.0 - exp(-0.0001 * t * t * t));\n//     }\n\n//     return vec3(clamp(col, 0.0, 1.0));\n// }\n\nmat3 setCamera(in vec3 ro, in vec3 ta, float cr) {\n    vec3 cw = normalize(ta - ro);\n    vec3 cp = vec3(sin(cr), cos(cr), 0.0);\n    vec3 cu = normalize(cross(cw, cp));\n    vec3 cv = (cross(cu, cw));\n    return mat3(cu, cv, cw);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 mo = iMouse.xy / iResolution.xy;\n    float time = 32.0 + iTime * 1.5;\n\n    // camera\t\n    vec3 ta = vec3(0.0);\n    // vec3 ro = ta + vec3(1.0, 1.0, 1.0);\n    vec3 ro = vec3(0.0);\n    // mat4 view = mat4(texelFetch(iChannel0, ivec2(2, 0), 0), texelFetch(iChannel0, ivec2(3, 0), 0), texelFetch(iChannel0, ivec2(4, 0), 0), texelFetch(iChannel0, ivec2(5, 0), 0));\n    mat4 view;\n    view[0] = texelFetch(iChannel0, ivec2(0, 0), 0);\n    view[1] = texelFetch(iChannel0, ivec2(1, 0), 0);\n    view[2] = texelFetch(iChannel0, ivec2(2, 0), 0);\n    view[3] = texelFetch(iChannel0, ivec2(3, 0), 0);\n    // mat4 view = mat4(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);\n    // ca[0][3] =1.0;\n    ro = (view * vec4(ro, 1.0)).xyz;\n    // camera-to-world transformation\n    // mat3 ca = setCamera( ro, ta, 0.0 );\n\n    vec2 p = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n    const float fl = 2.5;\n    vec3 rd = (view * vec4(normalize(vec3(p, fl)), 0.0)).xyz;\n    float d;\n    vec3 col = render(ro, rd, d);\n    // col = col * 3.0 / (2.5 + col);\n    col = Tonemap_ACES(col);\n    col = pow(col, vec3(0.4545));\n    col = mix(col, 0.8 * vec3(0.7, 0.8, 1.0), 1.0 - exp2(-0.00011 * d * d));\n//     vec3 tot = vec3(0.0);\n// #if 0\n//     for (int m = ZERO; m < AA; m++) for (int n = ZERO; n < AA; n++) {\n//         // pixel coordinates\n//             vec2 o = vec2(float(m), float(n)) / float(AA) - 0.5;\n//             vec2 p = (2.0 * (fragCoord + o) - iResolution.xy) / iResolution.y;\n// #else    \n//             vec2 p = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n// #endif\n\n//         // focal length\n//             const float fl = 2.5;\n\n//         // ray direction\n//             vec3 rd = (view * vec4(normalize(vec3(p, fl)), 0.0)).xyz;\n\n//          // ray differentials\n//             vec2 px = (2.0 * (fragCoord + vec2(1.0, 0.0)) - iResolution.xy) / iResolution.y;\n//             vec2 py = (2.0 * (fragCoord + vec2(0.0, 1.0)) - iResolution.xy) / iResolution.y;\n//             vec3 rdx = (view * normalize(vec4(px, fl, 0.0))).xyz;\n//             vec3 rdy = (view * normalize(vec4(py, fl, 0.0))).xyz;\n\n//         // render\t\n//             vec3 col = render(ro, rd, rdx, rdy);\n\n//         // gain\n//         // col = col*3.0/(2.5+col);\n\n// \t\t// gamma\n//             col = pow(col, vec3(0.4545));\n\n//             tot += col;\n// #if AA>1\n//         }\n//     tot /= float(AA * AA);\n// #endif\n\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// #iKeyboard\n// #iChannel0 \"self\"\n\n#define rot3x(x) mat4(1, 0, 0, 0, 0, cos(x), sin(x), 0, 0, -sin(x), cos(x), 0, 0, 0, 0, 1)\n#define rot3y(x) mat4(cos(x), 0, -sin(x), 0, 0, 1, 0, 0, sin(x), 0, cos(x), 0, 0, 0, 0, 1)\n#define rot3z(x) mat4(cos(x), sin(x), 0, 0,  -sin(x), cos(x), 0, 0, 0, 0, 1, 0, 0, 0, 0, 1)\n// #define translate3(x, y, z) mat4(1, 0, 0, x, 0, 1, 0, y, 0, 0, 1, z, 0, 0, 0, 0)\n#define translate3(x, y, z) mat4(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, x, y ,z, 1)\n\n// #define ikey\n// #define iKeyboard iChannel1\n\nconst int Key_W = 87;\nconst int Key_A = 65;\nconst int Key_S = 83;\nconst int Key_D = 68;\nconst int Key_Q = 81;\nconst int Key_E = 69;\nconst int Key_Shift = 16;\nconst int Key_Space = 32;\nconst int Key_LeftArrow = 37;\nconst int Key_UpArrow = 38;\nconst int Key_RightArrow = 39;\nconst int Key_DownArrow = 40;\n\n#ifdef ikey\nfloat getKey(int key_code) {\n    return float(isKeyDown(key_code));\n}\n#else\nfloat getKey(int key_code) {\n    return texelFetch(iChannel1, ivec2(key_code, 0), 0).x;\n}\n#endif\n\nconst float acc = 0.001;\nconst float move_speed = 1.8;\nconst float rotate_speed = 0.9;\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    ivec2 coord = ivec2(fragCoord);\n    // a: xyz translate  \n    // b: lr rotate up down rotate speed scale \n    // c d e f view matrix\n    vec4 a, b;\n    if (iFrame == 0) {\n        a = vec4(-4.0, 11.5, -3.0, 0.0);\n        b = vec4(1.25, 0.2, 0.0, 0.0);\n    } else {\n        a = texelFetch(iChannel0, ivec2(4, 0), 0);\n        b = texelFetch(iChannel0, ivec2(5, 0), 0);\n    }\n    vec3 move_vec;\n    vec2 rotate_vec;\n\n    move_vec.x = getKey(Key_D) - getKey(Key_A);\n    move_vec.y = clamp(0.0, 1.0, getKey(Key_E) + getKey(Key_Space)) - clamp(0.0, 1.0, getKey(Key_Q) + getKey(Key_Shift));\n    move_vec.z = getKey(Key_W) - getKey(Key_S);\n\n    rotate_vec.x = getKey(Key_RightArrow) - getKey(Key_LeftArrow);\n    rotate_vec.y = getKey(Key_DownArrow) - getKey(Key_UpArrow);\n\n    if (length(move_vec) > 1e-1) {\n        // b.z = clamp(0.0, move_speed, b.z + acc * iTimeDelta);\n        move_vec = normalize(move_vec) * move_speed * iTimeDelta;\n    } else {\n        // b.z = clamp(0.0, move_speed, b.z - acc * iTimeDelta);\n    }\n\n    if (length(rotate_vec) > 1e-5) {\n        rotate_vec = normalize(rotate_vec) * rotate_speed * iTimeDelta;\n    }\n    b.xy += rotate_vec;\n\n    mat4 view = mat4(1), rot, tran;\n    rot = rot3y(b.x) * rot3x(b.y);\n    a.xyz += (rot * vec4(move_vec, 1.0)).xyz;\n    tran = translate3(a.x, a.y, a.z);\n\n    view = tran * rot * view;\n    if (coord.y < 1) {\n        if (coord.x == 0) {\n            fragColor = view[0];\n        } else if (coord.x == 1) {\n            fragColor = view[1];\n        } else if (coord.x == 2) {\n            fragColor = view[2];\n        } else if (coord.x == 3) {\n            fragColor = view[3];\n        } else if (coord.x == 4) {\n            fragColor = a;\n        } else if (coord.x == 5) {\n            fragColor = b;\n        }\n        return;\n    }\n    // fragColor.rgb = vec3(a.x);\n}","name":"Buffer A","description":"","type":"buffer"}]}