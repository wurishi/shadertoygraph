{"ver":"0.1","info":{"id":"ftKSzK","date":"1641050029","viewed":356,"name":"Reflecting Pseudo Kleinian","username":"Kamoshika","description":"This changes shape and color and reflects light.","likes":22,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","reflection"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float pi=acos(-1.);\nconst float c=.9;\nconst float sp=1.;\nfloat ac;\nfloat T,b;\n\nvoid rot3d(inout vec3 v,float a,vec3 ax){\n    ax=normalize(ax);\n    v=mix(dot(ax,v)*ax,v,cos(a))-sin(a)*cross(ax,v);\n}\n\n#define ihash(x) floor(fract(sin(x)*1426.1623)*3.-1.)*c*2.\nfloat in1d(float x){\n    x/=c*2.;\n    float i=floor(x);\n    float s=.2;\n    float u=smoothstep(.5-s,.5+s,fract(x));\n    return mix(ihash(i),ihash(i+1.),u);\n}\n\nfloat map(vec3 p){\n    float d1,d2,a=1.;\n    vec3 p0=p;\n    p=abs(mod(p,c*2.)-c);\n    \n    for(int i=0;i<3;i++){\n        p=2.*clamp(p,-c,c)-p;\n        float k=max(1./dot(p,p),1.);\n        p*=k;\n        a*=k;\n    }\n    d1=(p.x+p.y+p.z-1.54)/a*.5;\n    d2=p.y/a*.5;\n    float s=smoothstep(-2.,2.,b-p0.z);\n    float Tm=mod(T+.5,4.);\n    if(Tm<1.){\n        d1=mix(d1,d2,s);\n        ac+=mix(a,1.,s);\n    }else if(Tm<2.){\n        d1=d2;\n        ac+=1.;\n    }else if(Tm<3.){\n        d1=mix(d2,d1,s);\n        ac+=mix(1.,a,s);\n    }else{\n        ac+=a;\n    }\n    \n    return d1;\n}\n\nvec3 calcN(vec3 p){\n    vec2 e=vec2(.001,0);\n    return normalize(vec3(map(p+e.xyy)-map(p-e.xyy),\n                          map(p+e.yxy)-map(p-e.yxy),\n                          map(p+e.yyx)-map(p-e.yyx)));\n}\n\nfloat fs(float f0,float c){\n    return f0+(1.-f0)*pow(1.-c,5.);\n}\n\nvec3 hsv(float h,float s,float v){\n    vec3 res=fract(h+vec3(0,2,1)/3.)*6.-3.;\n    res=clamp(abs(res)-1.,0.,1.);\n    res=(res-1.)*s+1.;\n    res*=v;\n    return res;\n}\n\nvec3 getC(vec3 rp){\n    float i=floor(T+.5);\n    vec3 c1=hsv(pi*.5*i,.8,1.);\n    vec3 c2=hsv(pi*.5*(i+1.),.8,1.);\n    float v=smoothstep(-.3,.3,b-rp.z);\n    return mix(c1,c2,v);\n}\n\nvec3 march(inout vec3 rp,inout vec3 rd,inout vec3 ra,vec3 cp){\n    vec3 col=vec3(0);\n    float d,t=0.;\n    ac=0.;\n    for(int i=0;i<100;i++){\n        d=map(rp);\n        if(abs(d)<.0001||t>20.)break;\n        t+=d;\n        rp+=rd*d;\n    }\n    \n    vec3 n=calcN(rp);\n    vec3 ref=reflect(rd,n);\n    float fog=exp(-t*t*.01);\n    vec3 al=getC(rp);\n    float lp=.1/abs(b-rp.z);\n    \n    col+=al*lp+ac*.0005;\n    col=mix(vec3(1),col,fog);\n    \n    col*=ra;\n    ra*=al*fs(.8,dot(ref,n))*fog;\n    \n    rp+=.001*n;\n    rd=ref;\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = vec2(gl_FragCoord.x / iResolution.x, gl_FragCoord.y / iResolution.y);\n    uv -= 0.5;\n    uv /= vec2(iResolution.y / iResolution.x, 1)*.5;\n    vec3 col=vec3(0);\n    \n    T=iTime*sp/c*.5;\n    \n    vec3 cp=vec3(0,0,-iTime*sp);\n    cp.x+=in1d(cp.z*.5-c);\n    float Tm=mod(T+.5,4.);\n    cp.y+=in1d(cp.z*.5-c*400.);\n    \n    b=cp.z+tan(T*pi);\n    \n    vec3 rd=normalize(vec3(uv,-1));\n    \n    rot3d(rd,iTime*.5,vec3(1,2,9));\n    rot3d(rd,pi/4.,vec3(0,1,0));\n    \n    vec3 rp=cp;\n    vec3 ra=vec3(1);\n    col+=march(rp,rd,ra,cp);\n    col+=march(rp,rd,ra,cp);\n    col+=march(rp,rd,ra,cp);\n    \n    fragColor = vec4(col,1);\n}","name":"Image","description":"","type":"image"}]}