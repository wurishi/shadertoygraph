{"ver":"0.1","info":{"id":"7dB3Dy","date":"1618133898","viewed":107,"name":"ray-tracing","username":"augenzu","description":"Ray Tracing","likes":4,"published":1,"flags":32,"usePreview":0,"tags":["raytracing","raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n\n    fragColor = texture(iChannel0, uv) / float(iFrame + 1);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4sXGRn","filepath":"/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","previewfilepath":"/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4sfGRr","filepath":"/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin","previewfilepath":"/media/ap/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin","type":"volume","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// infinity\nconst float INF = 1e10;\n\n// camera\nconst vec3 CAMERA_POS = vec3(-2, 1.5, -7);//vec3(-2, 1.5, -6);\n\n// table\nconst float TABLE_PLANE_Y = -1.2;\nconst float TABLE_RADIUS = 7.0;\n\n// lights number \nconst int N_LIGHTS = 3;\n\n// sphere\nconst vec3 SPHERE_POS = vec3(0, 0, 0);\nconst float SPHERE_RADIUS = 1.0;\n\n// cylinder\nconst float CYLINDER_HIGH_Y = SPHERE_POS.y - SPHERE_RADIUS;\nconst float CYLINDER_RADIUS = 1.2;\n\n// ambient coefficient\nconst float AMBIENT_COEFF = 0.1;\n\n// materials\nconst int EMISSION = 0;\nconst int DIFFUSION = 1;\nconst int REFLECTION = 2;\nconst int REFRACTION = 3;\n\n// refractive indexes\nconst float AIR_N = 1.0;\nconst float SPHERE_N = 2.0;//1.5;\n\n// reflective coefficient\nconst float TABLE_R = 0.2;\nconst float CYLINDER_N = 0.9;\n\n// reflections number\nconst int N_REFLECTIONS = 10;\n\n// fog\nconst vec3 FOG_SPHERE_POS = vec3(0, -0.2, 0);\nconst float FOG_SPHERE_RADIUS = 0.9;\nconst vec3 FOG_COLOR = vec3(2, 1, 6);\n\nfloat ABSORPTION = 5.0;\nfloat OPAQUE = 1.0;\n\nconst float MARCH_STEP = 0.01;\nconst int N_MARCH_STEPS = 150;\n\n\nstruct Light {\n    vec3 pos;\n    float radius;\n    vec3 color;\n    float attenuation;\n};\n\n\n// lights\nLight LIGHTS[N_LIGHTS];\n\nvec3 randDir;\n\n\nfloat pow2(float f) {\n    return f * f;\n}\n\nfloat rand(float frame) {\n    return fract(sin(dot(vec3(frame), vec3(12.9898,78.233,45.5432))) * 43758.5453);\n}\n\n\nfloat traceHorizontalCircle(vec3 pos, vec3 dir, float planeY, float radius,\n        out vec3 normal) {\n    // (pos + t * dir).y == planeY\n    \n    float t = (planeY - pos.y) / dir.y;\n    if (t < 0.0) {\n        return INF;\n    }\n    vec3 worldPos = pos + t * dir;\n    if (dot(worldPos.xz, worldPos.xz) > radius * radius) {\n        return INF;\n    }\n    \n    // normal to horizontal plane\n    normal = vec3(0, 1, 0);\n    return t;\n}\n\nfloat traceSphere(vec3 pos, vec3 dir, vec3 spherePos, float radius,\n        out vec3 normal) {\n    // dot(pos + t * dir, pos + t * dir) == radius ** 2\n    // dot(pos, pos) + 2 * t * dot(pos, dir) + t ** 2 * dot(dir, dir)\n    //       - radius ** 2 == 0\n    \n    // move sphere center to the origin\n    pos = pos - spherePos;\n    \n    float a = dot(dir, dir);\n    float b = dot(pos, dir);\n    float c = dot(pos, pos) - radius * radius;\n    float D = b * b - a * c;\n\n    if (D < 0.0) {\n        return INF;\n    }\n    float t = (-b - sqrt(D)) / a;\n    if (t > 0.0) {\n        vec3 posOnSphere = pos + t * dir;\n        normal = normalize(posOnSphere);\n        return t;\n    }\n    t = -b + sqrt(D);\n    if (t > 0.0) {\n        vec3 posOnSphere = pos + t * dir;\n        normal = normalize(posOnSphere);\n        return t;\n    }\n    return INF;\n}\n\n// only accepts cylinders centered on the origin\nfloat traceCylinder(vec3 pos, vec3 dir,\n        float highY, float radius, out vec3 normal) {        \n    // must intersect top face plane\n    // (pos + t * dir).y == highY\n    \n    float t = (highY - pos.y) / dir.y;\n    if (t < 0.0) {\n        return INF;\n    }\n    \n    // intersects top face exactly\n    vec3 worldPos = pos + t * dir;\n    if (dot(worldPos.xz, worldPos.xz) < radius * radius) {\n        normal = vec3(0, 1, 0);\n        return t;\n    }\n    \n    // intersects side face\n    // dot((pos + t * dir).xz, (pos + t * dir).xz) == radius ** 2\n    // dot(pos.xz, pos.xz) + 2 * t * dot(pos.xz, dir.xz)\n    //         + t ** 2 * dot(dir.xz, dir.xz) - radius ** 2 == 0\n    float a = dot(dir.xz, dir.xz);\n    float b = dot(pos.xz, dir.xz);\n    float c = dot(pos.xz, pos.xz) - radius * radius;\n    float D = b * b - a * c;\n    \n    if (D < 0.0) {\n        return INF;\n    }\n    t = (-b - sqrt(D)) / a;\n    if (t > 0.0) {\n        vec3 worldPos = pos + t * dir;\n        if (worldPos.y < highY) {\n            normal = normalize(vec3(worldPos.x, 0, worldPos.z));\n            return t;\n        }\n    }\n    t = (-b + sqrt(D)) / a;\n    if (t > 0.0) {\n        vec3 worldPos = pos + t * dir;\n        if (worldPos.y < highY) {\n            normal = normalize(vec3(worldPos.x, 0, worldPos.z));\n            return t;\n        }\n    }\n    return INF;\n    \n}\n\n\nvec3 refraction(vec3 dir, vec3 normal, inout float fromN, inout float toN) {\n    if (dot(dir, normal) < 0.0) {\n        normal = -normal;\n    }\n    float cosA = dot(dir, normal);\n    float sinA = sqrt(1.0 - pow2(cosA));\n    vec3 tanComponent = normalize(dir - cosA * normal);\n    float sinB = sinA / toN * fromN;\n    if (sinB > 1.0) {\n        return reflect(dir, normal);\n    }\n    float cosB = sqrt(1.0 - pow2(sinB));\n    vec3 refracted = sinB * tanComponent + cosB * normal;\n    float tmp = fromN;\n    fromN = toN;\n    toN = tmp;\n    return refracted;\n}\n\n\nfloat sphereSdf(vec3 pos, vec3 spherePos, float radius) {\n    float sdf = length(pos - spherePos) - radius;\n    return sdf;\n}\n\nfloat beerLambertAbsorption(float absorptionCoeff, float distTraveled) {\n    float absorption = exp(-absorptionCoeff * distTraveled);\n    return absorption;\n}\n\nvec4 sampleFog(vec3 pos, vec3 dir) {\n    float t = sphereSdf(pos, FOG_SPHERE_POS, FOG_SPHERE_RADIUS);\n    float opacity = OPAQUE;\n    float absorption = ABSORPTION;\n    float totalAbsorpton = 0.0;\n    \n    for (int i = 0; i < N_MARCH_STEPS; ++i) {\n        vec3 curPos = pos + (t + float(i) * MARCH_STEP) * dir;\n        float sdf = sphereSdf(curPos, FOG_SPHERE_POS, FOG_SPHERE_RADIUS);\n        if (sdf < 0.0) {\n            float prevOpacity = opacity;\n            float colorDensity = (texture(iChannel3, curPos * 0.2).r\n                    + texture(iChannel3, curPos * 0.4).r\n                    + texture(iChannel3, curPos * 0.8).r\n                    + texture(iChannel3, curPos * 1.6).r)\n                    * 0.25;\n            float absorptionCoeff = absorption\n                    * colorDensity * abs(sdf);\n                    \n            opacity *= beerLambertAbsorption(absorptionCoeff, MARCH_STEP);\n            float lastAbsorbed = prevOpacity - opacity;\n            totalAbsorpton += lastAbsorbed;\n        }\n    }\n    \n    return vec4(FOG_COLOR * totalAbsorpton, 1.0 - opacity);\n}\n\n\nbool isOccluded(vec3 pos, vec3 lightPos) {\n    vec3 toLight = lightPos - pos;\n    float toLightDist = length(toLight);\n    vec3 toLightDir = normalize(toLight);\n    \n    vec3 sphereNormal;\n    float sphereT = traceSphere(pos, toLightDir,\n            SPHERE_POS, SPHERE_RADIUS, sphereNormal);\n    if (sphereT > 1e-5 && sphereT < toLightDist) {\n        return true;\n    }\n    vec3 cylinderNormal;\n    float cylinderT = traceCylinder(pos, toLightDir,\n            CYLINDER_HIGH_Y, CYLINDER_RADIUS, cylinderNormal);\n    if (cylinderT > 1e-5 && cylinderT < toLightDist) {\n        return true;\n    }\n    return false;\n}\n\nvec3 computeLight(vec3 pos, vec3 color, vec3 normal) {\n    vec3 effectLight = vec3(0, 0, 0);\n\n    for (int i = 0; i < N_LIGHTS; ++i) {\n        vec3 toLight = LIGHTS[i].pos - pos;\n        float distSquared = dot(toLight, toLight);\n        float att = isOccluded(pos, LIGHTS[i].pos + randDir * LIGHTS[i].radius)\n                ? 0.0\n                : LIGHTS[i].attenuation / distSquared;\n        vec3 attComponent = color * max(0.0, dot(normalize(toLight), normal))\n                * att * LIGHTS[i].color;\n        effectLight += attComponent;\n    }\n            \n    vec3 ambientComponent = texture(iChannel1, normal).rgb * AMBIENT_COEFF;\n    effectLight += ambientComponent;\n    \n    return effectLight;\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    LIGHTS[0].pos = vec3(-2.3, 1.2, 0.5);\n    LIGHTS[0].radius = 0.2;\n    LIGHTS[0].color = vec3(0, 1, 1);\n    LIGHTS[0].attenuation = 10.0;\n\n    LIGHTS[1].pos = vec3(1.5, 0.5, -0.2);\n    LIGHTS[1].radius = 0.2;\n    LIGHTS[1].color = vec3(1, 0.7, 0);\n    LIGHTS[1].attenuation = 6.0;\n\n    LIGHTS[2].pos = vec3(-1.3, -0.3, -1.5);\n    LIGHTS[2].radius = 0.1;\n    LIGHTS[2].color = vec3(1, 1, 1);\n    LIGHTS[2].attenuation = 6.0;\n\n    vec3 randVals = vec3(rand(float(iFrame)),\n            rand(float(iFrame + 5)),\n            rand(float(iFrame + 15)));\n    randDir = normalize(randVals - 0.5);\n\n    vec2 uv = (fragCoord - iResolution.xy * 0.5\n            + (randVals.xy - 0.5) * 2.0) / iResolution.x;\n    \n    vec3 front = normalize(-CAMERA_POS);\n    vec3 up = vec3(0, 1, 0);\n    vec3 right = normalize(cross(front, up));\n    up = normalize(cross(right, front));\n    \n    vec3 viewVec = normalize(front + uv.x * right + uv.y * up);\n    \n    vec3 curPos = CAMERA_POS;\n    vec3 curDir = viewVec;\n    \n    float fromN = AIR_N;\n    float toN = SPHERE_N;\n    float glassR = pow2(fromN - toN) / pow2(fromN + toN);  // reflectance\n    \n    float mult = 1.0;\n    \n    for (int i = 0; i < N_REFLECTIONS; ++i) {\n        float t = INF;\n        \n        vec3 normal;\n        int materialType;\n        vec3 color;\n        \n        // looking for the min t over all the intersections\n        vec3 tableNormal;\n        float tableT = traceHorizontalCircle(curPos, curDir,\n                TABLE_PLANE_Y, TABLE_RADIUS, tableNormal);\n        if (tableT < t) {\n            t = tableT;\n            normal = tableNormal;\n            if (randVals.y < TABLE_R) {\n                materialType = REFLECTION;\n            } else {\n                materialType = DIFFUSION;\n            }\n            vec3 worldPos = curPos + t * curDir;\n            color = texture(iChannel0, worldPos.xz * 0.1).rgb;\n        }\n        for (int i = 0; i < N_LIGHTS; ++i) {\n            vec3 lightNormal;\n            float lightT = traceSphere(curPos, curDir,\n                    LIGHTS[i].pos, LIGHTS[i].radius, lightNormal);\n            if (lightT < t) {\n                t = lightT;\n                normal = lightNormal;\n                materialType = EMISSION;\n                color = LIGHTS[i].color;\n            }\n        }\n        vec3 sphereNormal;\n        float sphereT = traceSphere(curPos, curDir,\n                SPHERE_POS, SPHERE_RADIUS, sphereNormal);\n        if (sphereT < t) {\n            t = sphereT;\n            normal = sphereNormal;\n            if (randVals.x < glassR) {\n                materialType = REFLECTION;\n            } else {\n                materialType = REFRACTION;\n            }\n        }\n        vec3 cylinderNormal;\n        float cylinderT = traceCylinder(curPos, curDir,\n                CYLINDER_HIGH_Y, CYLINDER_RADIUS, cylinderNormal);\n        if (cylinderT < t) {\n            t = cylinderT;\n            normal = cylinderNormal;\n            if (randVals.z < CYLINDER_N) {\n                materialType = REFLECTION;\n            } else {\n                materialType = DIFFUSION;\n            }\n            vec3 worldPos = curPos + t * curDir;\n            color = texture(iChannel2, worldPos.xz * worldPos.y).rgb;\n        }\n        \n        if (t != INF) {\n            vec3 worldPos = curPos + t * curDir;\n            fragColor = mix(fragColor, texture(iChannel0, worldPos.xz), mult);\n            \n            if (materialType == EMISSION) {\n                fragColor.rgb = color;\n                break;\n            } else if (materialType == DIFFUSION) {\n                fragColor.rgb = mix(fragColor.rgb,\n                        computeLight(worldPos, color, normal),\n                        mult);\n                break;\n            } else if (materialType == REFLECTION) {\n                curDir = reflect(curDir, normal);\n                curPos = worldPos + curDir * 1e-3;\n            } else if (materialType == REFRACTION) {\n                curDir = refraction(curDir, normal, fromN, toN);\n                curPos = worldPos + curDir * 1e-3;\n                vec4 fog = sampleFog(curPos, curDir);\n                fragColor.rgb = mix(fragColor.rgb, fog.rgb * fog.a, mult);\n                mult *= 1.0 - fog.a;\n            }\n        } else {\n            fragColor = mix(fragColor, texture(iChannel1, curDir), mult);\n        }\n    }\n}\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    fragColor = texture(iChannel0, uv) + texture(iChannel1, uv);\n}","name":"Buffer B","description":"","type":"buffer"}]}