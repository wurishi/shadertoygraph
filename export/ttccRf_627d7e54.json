{"ver":"0.1","info":{"id":"ttccRf","date":"1609611076","viewed":100,"name":"Deformed line distance field","username":"kajbostrom","description":"Using gradient descent to approximate the distance field of a line warped by noise (on both axes) - thanks iq for the analytic gradient noise derivatives!\nUse the mouse to show the gradient descent path for a given point.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["2d","noise","sdf","distance"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Distance to warped line by Kaj Bostrom, 2021\n\n\n// Gradient noise with analytic derivatives (and hash function) by iq\nvec2 hash( in vec2 x )  // replace this by something better\n{\n    const vec2 k = vec2( 0.3183099, 0.3678794 );\n    x = x*k + k.yx;\n    return -1.0 + 2.0*fract( 16.0 * k*fract( x.x*x.y*(x.x+x.y)) );\n}\n\n\n// return gradient noise (in x) and its derivatives (in yz)\nvec3 noised( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\n#if 1\n    // quintic interpolation\n    vec2 u = f*f*f*(f*(f*6.0-15.0)+10.0);\n    vec2 du = 30.0*f*f*(f*(f-2.0)+1.0);\n#else\n    // cubic interpolation\n    vec2 u = f*f*(3.0-2.0*f);\n    vec2 du = 6.0*f*(1.0-f);\n#endif    \n    \n    vec2 ga = hash( i + vec2(0.0,0.0) );\n    vec2 gb = hash( i + vec2(1.0,0.0) );\n    vec2 gc = hash( i + vec2(0.0,1.0) );\n    vec2 gd = hash( i + vec2(1.0,1.0) );\n    \n    float va = dot( ga, f - vec2(0.0,0.0) );\n    float vb = dot( gb, f - vec2(1.0,0.0) );\n    float vc = dot( gc, f - vec2(0.0,1.0) );\n    float vd = dot( gd, f - vec2(1.0,1.0) );\n\n    return vec3( va + u.x*(vb-va) + u.y*(vc-va) + u.x*u.y*(va-vb-vc+vd),   // value\n                 ga + u.x*(gb-ga) + u.y*(gc-ga) + u.x*u.y*(ga-gb-gc+gd) +  // derivatives\n                 du * (u.yx*(va-vb-vc+vd) + vec2(vb,vc) - va));\n}\n\n#define STEPS 8\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.,0.,0., 1.);\n\n    vec2 p = 10.*fragCoord.xy / iResolution.y;\n    \n    vec2 o = vec2(0.0, 5);\n    vec2 d = vec2(1.0, 0.0);\n    \n    float s0 = dot(p-o, d);\n    float distSquared;\n    float minDistSquared = -1.0;\n    for (int i = -2; i <= 2; ++i) {\n        float s = s0 + float(i)*0.5;\n        for (int j = 0; j < STEPS; ++j) {\n\n            vec3 nx = noised(vec2(s, 0.+iTime));\n            vec3 ny = noised(vec2(s, 10.+iTime));\n\n            vec2 dn = vec2(nx.y, ny.y);\n\n            vec2 m = s*d + o + vec2(nx.x, ny.x);\n            vec2 dm = dn + d;\n            vec2 off = m - p;\n            distSquared = dot(off, off);\n            float ddist = dot(dm, off)/max(.5,length(off));\n\n            s = s - ddist*0.1/min(1., length(dm));\n        }\n        if (distSquared < minDistSquared || minDistSquared < 0.0) {\n            minDistSquared = distSquared;\n        }\n    }\n\n    float c = sqrt(minDistSquared);\n    \n    fragColor.x = fragColor.y = fragColor.z = 1.0 - c*.6;\n    \n    // Mouse diagnostic points\n    \n    // This section just does the same gradient descent but starting from\n    // the mouse coordinates instead of the current frag coords,\n    // in order to visualize the gradient descent steps\n    vec2 pm = 10.*iMouse.xy / iResolution.y;\n    \n    s0 = dot(pm-o, d);\n    minDistSquared = -1.0;\n    vec4 finalProposal = vec4(0., 0., 0., 0.);\n    for (int i = -2; i <= 2; ++i) {\n        float s = s0 + float(i)*0.5;\n        vec4 colorProposal = vec4(0., 0., 0., 0.);\n        for (int j = 0; j < STEPS; ++j) {\n\n            vec3 nx = noised(vec2(s, 0.+iTime));\n            vec3 ny = noised(vec2(s, 10.+iTime));\n\n            vec2 dn = vec2(nx.y, ny.y);\n\n            vec2 m = s*d + o + vec2(nx.x, ny.x);\n            if (length(m - p) < .1) {\n                float progress = float(j)/float(STEPS-1);\n                progress *= progress*progress;\n                colorProposal = vec4(1.0 - progress, progress, 0.2, 1.);\n            }\n            vec2 dm = dn + d;\n            vec2 off = m - pm;\n            distSquared = dot(off, off);\n            float ddist = dot(dm, off)/max(.5,length(off));\n\n            s = s - ddist*0.1/min(1., length(dm));\n        }\n        if (distSquared < minDistSquared || minDistSquared < 0.0) {\n            finalProposal = colorProposal;\n            minDistSquared = distSquared;\n        }\n    }\n    if (finalProposal.w != 0.) {\n        fragColor = finalProposal;\n    }\n}","name":"Image","description":"","type":"image"}]}