{"ver":"0.1","info":{"id":"XsjXW1","date":"1473401393","viewed":544,"name":"terrain study","username":"hellochar","description":"asdf","likes":15,"published":1,"flags":0,"usePreview":0,"tags":["landscape"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"mat3 m = mat3( 0.00,  0.80,  0.60,\n              -0.80,  0.36, -0.48,\n              -0.60, -0.48,  0.64 );\n\n// the backbone of any noise, or really any chaotic/natural/random looking\n// shader. hash basically maps an input value n to a random location in [0..1]\n// this function does have a period of TWO_PI but because the scaling factor\n// is so large there's significant differences between e.g. hash(0) and hash(TWO_PI)\n// the float data-type is not precise enough to be able to show the pattern even\n// in minute scales\n// and we're sampling with n ranging in the hundreds and thousands - it's basically\n// a reproducable random\nfloat hash( float n )\n{\n    return fract(sin(n)*43758.5453123);\n}\n\n\n// some random noise function that i can't really parse\n// most noise functions are basically chaotic but\n// still continuous mappings whose behavior is complex enough\n// that humans can't see the pattern\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\n    f = f*f*(3.0-2.0*f);\n\n    float n = p.x + p.y*57.0 + 113.0*p.z;\n\n    float res = mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                        mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\n                    mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                        mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\n    return res;\n}\n\n\n\n\n// return an interpolated height and position for the given input\n\n// height algorithm:\n// partition 2d space into a set of 1x1 squares\n// each square has 4 corners; each corner's coordinate is associated\n// with a random height (and with a variable a-d), such that the same corner on two different squares has\n// the same value. Interpolate between the corners\n// depending on where in the 1x1 square you are. Linear interpolation\n// creates discontinuities at the edges, instead use a cubic hermite spline with slope 0 at the tangents - this ensures smoothness\n// of 2 degrees.\n/*\n      x+           \n +------------>   \n |                \n |  a            b\ny|   +----------+ \n+|   |          | \n |   |          | \n v   |          | \n     |          | \n     |          | \n     +----------+ \n    c            d\n*/\nvec3 noised( in vec2 x )\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n\n    vec2 u = f*f*(3.0-2.0*f);\n\n    float n = p.x + p.y*54.0;\n\n    // heights of the four corners\n    float a = hash(n+  0.0);\n    float b = hash(n+  1.0);\n    float c = hash(n+ 54.0);\n    float d = hash(n+ 55.0);\n    \n    return vec3(a+(b-a)*u.x+(c-a)*u.y+(a-b-c+d)*u.x*u.y,\n                // scalar function: f*f*(f*(f-2.0)+1.0) = f^2*(f-1)^2 = hump shape from [0..1] (*30 = goes up to 1.875 in the middle)\n                // any function can serve as the scalar as long as it 1) goes to 0 at the edges, and 2) is continuous (and preferably is smooth as well)\n                // the scalar affects how smooth the terrain is; a higher value will make the mountains more sharp\n                \n                // the actual yz vec2 is another returned value that to add more flavor to the noise. \n                // You can use it as the basis of another noise, or (in the case of the caller here), \n                // modify the .x with the .yz.\n                // the vec2 function should reference a,b,c,d such that the function evaluates to the\n                // same value on either side of the edge of the 1x1 square\n                \n                /* \n\t\t\t\t * if the formula is F(x), the following invariants should hold:\n\t\t\t\t * (1) F(<x+, y>).y = F(<x-, y>).y, x is an integer\n\t\t\t\t * (2) F(<x, y+>).x = F(<x, y->).x, y is an integer\n\t\t\t\t * in (1), the scalar makes the x component go to 0, so only the y components must\n\t\t\t\t * be equal. Similarly in (2), the y component is multiplied by 0, so only the x\n\t\t\t\t * components should be equal.\n\t\t\t\t * With the invariants, transitioning between two cells of the 1x1 grid will be continuous\n\t\t\t\t */\n                30.0*f*f*(f*(f-2.0)+1.0)*(vec2(b-a,c-a)+(a-b-c+d)*u.yx));\n\n}\n\nfloat noise( in vec2 x )\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n\n    f = f*f*(3.0-2.0*f);\n\n    float n = p.x + p.y*57.0;\n\n    float res = mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                    mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y);\n\n    return res;\n}\n\nfloat fbm( vec3 p )\n{\n    float f = 0.0;\n\n    f += 0.5000*noise( p ); p = m*p*2.02;\n    f += 0.2500*noise( p ); p = m*p*2.03;\n    f += 0.1250*noise( p ); p = m*p*2.01;\n    f += 0.0625*noise( p );\n\n    return f/0.9375;\n}\n\nmat2 m2 = mat2(1.6,-1.2,1.2,1.6);\n\n// fbm is a more complex noise, again harmonic\n// that takes several layers of noise at differing\n// scales and adds them up -- basically a more interesting\n// noise\nfloat fbm( vec2 p )\n{\n    float f = 0.0;\n\n    f += 0.5000*noise( p ); p = m2*p*2.02;\n    f += 0.2500*noise( p ); p = m2*p*2.03;\n    f += 0.1250*noise( p ); p = m2*p*2.01;\n    f += 0.0625*noise( p );\n\n    return f/0.9375;\n}\n\n// the height of the terrain at the given xy location\nfloat terrain( in vec2 x )\n{\n    // scale world coordinates down a lot\n    vec2  p = x*0.003;\n    float a = 0.0;\n    float b = 1.0;\n    vec2  d = vec2(0.0);\n    // sample a base noise at different locations 5 times\n    // and accumulate the sample into the final height\n    // this is the technique of taking a simple noise\n    // and making more interesting noise out of it by\n    // doing harmonic sampling? is that what it's called\n    for(int i=0;i<5; i++)\n    {\n        // random n\n        vec3 n = noised(p);\n        // d represents some \"distance\" away from some origin\n        d += n.yz;\n        // b is the octave attenuation (1, 0.5, 0.25, etc)\n        // add this octave, which is scaled by the attenuation\n        // factor and also by the distance factor\n        a += b*n.x/(1.0+dot(d,d));\n        b *= 0.5;\n        // not sure what how this matrix acts on p\n        // i believe it's more or less a twist + expand\n        p=m2*p;\n    }\n\n    return 140.0*a;\n}\n\n// same as terrain but go for 9 more iterations\n// this produces a much more fine-grained terrain function\n// that has goes deeper into the smaller scales of the terrain\n// so if terrain( x ) returned some value like 100,\n// terrain2( x ) returns a slightly more detailed value like 100.125\n// or something - it's a purturbed version of normal terrain\n// but the purtubations also exhibit the fractal landscape behavior\n// that is characterstic of the land\nfloat terrain2( in vec2 x )\n{\n    vec2  p = x*0.003;\n    float a = 0.0;\n    float b = 1.0;\n    vec2  d = vec2(0.0);\n    for(int i=0;i<14; i++)\n    {\n        vec3 n = noised(p);\n        d += n.yz;\n        a += b*n.x/(1.0+dot(d,d));\n        b *= 0.5;\n        p=m2*p;\n    }\n\n    return 140.0*a;\n}\n\n\n// takes in a world location and returns how vertically\n// far away you are from the terrain there\n// when used within raymarching this means that as the ray \n// is marching, since the map is continuous, you'll eventually\n// get within some small epsilon value of the actual terrain,\n// at which point you can count it as a hit\nfloat map( in vec3 p )\n{\n    // the height of the terrain at the location's xz plane\n    float h = terrain(p.xz);\n\n    // some sort of postprocessing of the height here\n    // to give it more jagged edges\n\n    // not sure how it really works yet\n    float ss = 0.03;\n    float hh = h*ss;\n    // scale the height down a lot, decompose it into its fractional\n    // and whole parts\n    float fh = fract(hh);\n    float ih = floor(hh);\n    // transform fh by pushing it up towards its sqrt\n    // by some amount depending on the height of the terrain you're at\n    // fh corresponds to a height of ~33 in the terrain\n    // the effect of this is that regularly at 33 pixel intervals,\n    // the middle area of the interval gets pushed up towards the top\n    // this creates more of a plateau effect which is more realistic\n    // of actual terrain\n    fh = mix( sqrt(fh), fh, smoothstep(50.0,140.0,h) );\n    \n    // reconstruct h with the new fractional part\n    h = (ih+fh)/ss;\n\n    return p.y - h;\n}\n\n// same as map but using terrain2\nfloat map2( in vec3 p )\n{\n    float h = terrain2(p.xz);\n\n\n    float ss = 0.03;\n    float hh = h*ss;\n    float fh = fract(hh);\n    float ih = floor(hh);\n    fh = mix( sqrt(fh), fh, smoothstep(50.0,140.0,h) );\n    h = (ih+fh)/ss;\n\n    return p.y - h;\n}\n\n// return whether the ray starting at rO and pointing at rD\n// hit the map or not. If it did, the distance from the origin to the hit\n// will be stored in resT\n// assumes rD is normalized\nbool jinteresct(in vec3 rO, in vec3 rD, out float resT )\n{\n    float h = 0.0;\n    float t = 0.0;\n    // march the ray forward 120 times\n    for( int j=0; j<120; j++ )\n    {\n        //if( t>2000.0 ) break;\n\n        vec3 p = rO + t*rD;\n        // break out of the iteration if you've passed some vertical\n        // plane which guarantees you won't hit the map\n        // (assumes the map is below 300); it's for performance i think?\nif( p.y>300.0 ) break;\n        h = map( p );\n\n        // if you're within .1 units, count that as a hit on the terrain\n        if( h<0.1 )\n        {\n            resT = t;\n            return true;\n        }\n        // t controls where your ray has been marched to\n        // what iq is saying here is that if the height is\n        // still large (that is, the ray is still quite vertically\n        // away from hitting the terrain), you can jump the\n        // ray much farther forward\n        // the invariant here is that the terrain's slope is less than 2\n        // the invariant is broken sometimes which is where the strange\n        // aliased banding that moves with the camera comes from\n        // this is really cool -- you're dynamically sampling the terrain\n        // based on how far away you are from it\n        t += max(0.1,0.5*h);\n    }\n\n    // if you've reached here, you've gone 120 iterations and still\n    // not hit the terrain, OR you've hit y = 300\n    // if you're within 5 units of the floor, just say you hit\n    // not sure why he does this\n    if( h<5.0 )\n    {\n        resT = t;\n        return true;\n    }\n    return false;\n}\n\n// this is called starting at the original ray's intersection point + 20*light1, in the direction of light1\n// it calculates a long-range shadow with a soft-edge\nfloat sinteresct(in vec3 rO, in vec3 rD )\n{\n    float res = 1.0;\n    float t = 0.0;\n    for( int j=0; j<50; j++ )\n    {\n        //if( t>1000.0 ) break;\n        // cast a ray towards the light\n        vec3 p = rO + t*rD;\n\n        // track how far from the ground you are\n        float h = map( p );\n\n        // if you've hit the ground, you're completely in the shadow\n        if( h<0.1 )\n        {\n            return 0.0;\n        }\n        // 16 * h/t?\n        // 16 is an arbitrary scalar\n        // h/t is the difference in height divided by the distance the ray has travelled\n        res = min( res, 16.0*h/t );\n        // adding h is another performance gain - move the ray based on how far you away you are now\n        // because the terrain is mostly smooth\n        // you can basically analyze this as t will at some point get placed very near the actual minimum distance\n        // away between the ray and the terrain\n        // at that point, res will be set to h/t -- so farther-away terrains will cast shadows with a larger gradient\n        // basically emulates the diffusive quality of light, also realy cool\n        t += h;\n\n    }\n\n    return clamp( res, 0.0, 1.0 );\n}\n\n// approximate the gradient of the terrain at pos by\n// moving in a small epsilon in each of the three directions\n// the epsilon is scaled by t, the distance of the point from\n// the camera. This means that points farther away\n// have a smoother normal calculation\n// the choice of epsilon has a massive effect on the percieved\n// detail of the terrain\n// the difference is clearly noticable if you have a small epsilon\n// on faraway points - there is a lot of aliasing since the effective\n// distance between two adjacent pixels that are both far away\n// is quite large. This achieves the same effect as mip-mapping in terms\n// of detail. You do in fact want to scale by `t` otherwise pixels far away\n// don't look connected\nvec3 calcNormal( in vec3 pos, float t )\n{\n    float e = 0.001 * t;\n    vec3  eps = vec3(e,0.0,0.0);\n    vec3 nor;\n    nor.x = map2(pos+eps.xyy) - map2(pos-eps.xyy);\n    nor.y = map2(pos+eps.yxy) - map2(pos-eps.yxy);\n    nor.z = map2(pos+eps.yyx) - map2(pos-eps.yyx);\n    return normalize(nor);\n}\n\nvec3 camPath( float time )\n{\n    vec2 p = 600.0*vec2( cos(1.4+0.37*time),\n                         cos(3.2+0.31*time) );\n\n    return vec3( p.x, 0.0, p.y );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // maps screen from (-1, -1) on bottom-left to (1, 1) on top-right\n    vec2 xy = -1.0 + 2.0*fragCoord.xy / iResolution.xy;\n\n    // correct aspect ratio; y goes from -1 to 1, x goes from -1.75 to 1.75 (the aspect ratio is hard-coded to be 1.75)\n    vec2 s = xy*vec2(1.75,1.0);\n\n    float time = iTime*0.15;\n\n    // diretional light coming down from the top\n    vec3 light1 = normalize( vec3(  0.4, 0.22,  0.6 ) );\n\n    // a second light, probably directional\n    vec3 light2 = vec3( -0.707, 0.000, -0.707 );\n\n    // camera position is set using two cosines at different speeds\n    vec3 campos = camPath( time );\n    // target's always looking forward -- this is cool\n    vec3 camtar = camPath( time + 3.0 );\n    campos.y = terrain( campos.xz ) + 15.0;\n    // the eye is always just looking down\n    camtar.y = campos.y*0.5;\n\n    // roll the camera\n    float roll = 0.1*cos(0.1*time);\n    // cp is an upwards pointing vector in world space that wiggles slightly\n    // it controls the up vector of the camera\n    vec3 cp = vec3(sin(roll), cos(roll),0.0);\n\n    // the direction the camera's pointing at\n    vec3 cw = normalize(camtar-campos);\n    // points to the \"right\" in the camera\n    vec3 cu = normalize(cross(cw,cp));\n    // points \"up\" in the camera, basically cp projected onto the camera's\n    // viewing plane\n    vec3 cv = normalize(cross(cu,cw));\n    // direction of the ray to cast for this pixel\n    // it's made of 3 components in camera space -\n    // an amount to go horizontally,\n    // an amount to go vertically,\n    // and an amount to go outwards\n    // that cw vector is needed otherwise the rays are always\n    // perpendicular to the camera's viewing angle\n    // the cw factor more or less controls the fov\n    // (a large factor zooms the whole frustum in, a small factor\n    // expands the fov out)\n    // this is shoddily recreating a frustum, i don't\n    // believe this is the right way to do this\n    vec3 rd = normalize( s.x*cu + s.y*cv + 1.6*cw );\n\n    float sundot = clamp(dot(rd,light1),0.0,1.0);\n    vec3 col;\n    float t;\n    // if your ray doesn't hit the ground, this pixel is hitting\n    // the sky instead -- render the sky\n    if( !jinteresct(campos,rd,t) )\n    {\n        // sky is very light blue scaled by the ray's y position,\n        // which is how high up the ray is; higher up means higher up\n        // in the sky means a darker blue;\n        // the y never goes past some small threshold\n        // so the sky always looks *mostly* blue, but you can still see\n        // the gradient\n        col = 0.9*vec3(0.97,.99,1.0)*(1.0-0.3*rd.y);\n\n        // this line adds a small amount of red-orangish color\n        // mostly in a ring shape around where the \"sun\" would be\n        col += 0.2*vec3(0.8,0.7,0.5)*pow( sundot, 4.0 );\n    }\n    else\n    {\n        // here's where you hit\n        vec3 pos = campos + t*rd;\n\n        // the terrain normal at this location\n        vec3 nor = calcNormal( pos, t );\n\n        //basic diffuse light calculation\n        float dif1 = clamp( dot( light1, nor ), 0.0, 1.0 );\n        // i think this basically produces some ambient light as well?\n        float dif2 = clamp( 0.2 + 0.8*dot( light2, nor ), 0.0, 1.0 );\n        \n        // shadow factor -- 1 = no long-range shadow, 0 = completely in shadow\n        float sh = 1.0;\n        // if light1 hits me\n        if( dif1>0.001 )\n            sh = sinteresct(pos+light1*20.0,light1);\n\n        // dif1v is the color contribution of the diffuse of the first light source\n        vec3 dif1v = vec3(dif1);\n        // sh = iMouse.x / iResolution.x;\n        // soft-shadow has a red coloring to it\n        dif1v *= vec3( sh, sh*sh*0.5+0.5*sh, sh*sh );\n\n        // apply a simple random noise factor on the base ground color\n        // just to give it a bit more flavor\n        float r = noise( 7.0*pos.xz );\n\n        // here we begin coloring the terrain. The base color mixes between\n        // a dark brown base color and a slightly more colorful brown at the top\n        // terrain2 is used here as just another random noise function whose input scales\n        // are on the same magnitude as the position; it's used to give the vertical bands\n        // in the terrain\n        float heightMix = clamp(terrain2( vec2(pos.x,pos.y*48.0))/200.0,0.0,1.0);\n        col = (r*0.25+0.75)*0.9*mix( vec3(0.10,0.05,0.03), vec3(0.13,0.10,0.08), heightMix );\n        // mix the color with a more reddish hue if the normal points more up (how flat it is)\n        col = mix( col, 0.17*vec3(0.5,.23,0.04)*(0.50+0.50*r),smoothstep(0.70,0.9,nor.y) );\n        // and if they're *really* flat, give it some green for grass\n        col = mix( col, 0.10*vec3(0.2,.30,0.00)*(0.25+0.75*r),smoothstep(0.95,1.0,nor.y) );\n        col *= 0.75;\n         // snow\n        #if 1\n        // height factor -- higher places have more snow (h=1), lower places have no snow (h=0)\n        float h = smoothstep(55.0,80.0,pos.y + 25.0*fbm(0.01*pos.xz) );\n        // normal+cliff factor -- land that is flatter gets more snow, cliff-like land doesn't get much snow\n        // normal+cliff factor is also scaled by height, aka higher up the slope factor is stronger\n        float e = smoothstep(1.0-0.5*h,1.0-0.1*h,nor.y);\n        // wind directional factor -- if you have a high x slope, put less snow.\n        // so hilly terrain that is going up in one direction will have snow,\n        // going down on the other side will have no snow\n        float o = 0.3 + 0.7*smoothstep(0.0,0.1,nor.x+h*h);\n        float s = h*e*o;\n        s = smoothstep( 0.1, 0.9, s );\n        // mix color with dark grey color for snow\n        col = mix( col, 0.4*vec3(0.6,0.65,0.7), s );\n        #endif\n\n\n        // final light calculation\n        \n        // start with a slope factor -- cliffs will be shaded slightly darker\n        // this is most apparent when the cliff meets the ground; emulates ambient occlusion\n        // a little bit\n        vec3 brdf  = 2.0*vec3(0.17,0.19,0.20)*clamp(nor.y,0.0,1.0);\n        // most of the lighting comes from dif1\n             brdf += 6.0*vec3(1.00,0.95,0.80)*dif1v;\n        // a bit from dif2, which is just a small ambient secondary light to complement the first\n             brdf += 2.0*vec3(0.20,0.20,0.20)*dif2;\n\n       \t// add all of the light\n        col *= brdf;\n\n        // fog factor - 0 at close distances, goes to 1. Has a slightly s shaped curve\n        float fo = 1.0-exp(-pow(0.0015*t,1.5));\n        // fog color -- base 0.7; if you're looking towards the sun, make the fog the color of the sun\n        // when there's a lot of fog in the distance, the fog carries the color of the sun and blends\n        // it in with the actual surface color. This emulates that behavior\n        vec3 fco = vec3(0.7) + 0.6*vec3(0.8,0.7,0.5)*pow( sundot, 4.0 );\n        col = mix( col, fco, fo );\n    }\n\n    // postprocess filter; basically a sqrt color curve that helps the dark parts look brighter\n    // a bit like a compressor audio effect; makes things a bit warmer in general\n    col = sqrt(col);\n\n    // (0, 0) to (1, 1)\n    vec2 uv = xy*0.5+0.5;\n    //create a slight inset shadow on the top corners\n    col *= 0.7 + 0.3*pow(16.0*uv.x*uv.y*(1.0-uv.x)*(1.0-uv.y),0.1);\n\n    // and we're done!\n    fragColor=vec4(col,1.0);\n}\n","name":"Image","description":"","type":"image"}]}