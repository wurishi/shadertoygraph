{"ver":"0.1","info":{"id":"slc3Dr","date":"1635974646","viewed":139,"name":"jneen - angry pulsing glowmoon","username":"jneen","description":"it angey. click it for angeyer, esp top right. bottom right for fire effect\n","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["jneen"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define rad(x) (radians(360.*(x)))\n#define time (iTime*.1)\n#define mouse (iMouse/iResolution.y)\n\nfloat box(vec3 p, vec3 a) {\n  vec3 q = abs(p)-a;\n  return length(max(q,0.))+min(0.,max(q.x,max(q.y,q.z)));\n}\n\nfloat sphere(vec3 p, float r) { return length(p) - r; }\n\nmat2 rot(float a) { float c=cos(a),s=sin(a); return mat2(c,s,-s,c); }\nfloat glow;\n\n#define tri(x) (abs(fract((x)*.5)-.5)*2.)\n#define nsin(x) (.5+.5*sin(x))\nfloat scene(vec3 p) {\n  float bgsize = 2.5;\n  vec3 bgp = p.xyz;\n  bgp.xz *= rot(time);\n  float bg = box(bgp+vec3(0,bgsize+1.2,0),vec3(bgsize))-.3;//p.y + 2.;\n  vec3 orig_p = p.xyz;\n  p.xz *= rot(rad(.2*sin(time)));\n  p.xy *= rot(rad(.3*time*sqrt(2.)));\n  p.yz *= rot(rad(2./6.));\n  \n  p = orig_p;\n  p.y -= 1.;\n  p.xy += .2*mouse.y*nsin(tan(time*10.)*.01)*rot(time*300.)*vec2(1,0);// sin(time*6.);\n  p.yz *= rot(rad(.25)+.5*cos(10.*time));\n  p.xy *= rot(rad(.25)+.1*sin(20.*time));\n  float yzrot = 3.14+sin(tan(time*12.))*.1;\n  p.yz *= rot(yzrot);\n\n  float squeeze = 4.8;\n  float sph = sphere(p,2.);\n  vec2 samp = vec2(atan(p.x,p.z)/3.141592654, p.y*.2);\n  float solid = mix(sph,box(p,vec3(1.5)-.2),.8+.5*sin(time*150.));\n  \n  solid = max(solid,.2-box(p-vec3(0,.6,.4),.5*vec3(5.,.05,.2)));\n  solid = max(solid,.2-box(p-vec3(0,-.6,.4),.5*vec3(5.,.05,.2)));\n  solid = max(solid,.2-box(p*(sin(time*13.)*abs(p.y)-2.)-vec3(0,0,1.2),vec3(5.,.6,.2*nsin(tan(time)))));\n\n  vec2 pole = abs(p.xz)- vec2(1,0)*rot(15.*time);\n  solid = min(solid, max(p.z,length(pole)-p.y*.001));\n  solid += (.1+.2*nsin(time))*mix(texture(iChannel0, samp).r, texture(iChannel0, samp+1.).r, .5);\n\n  float glowr = .5;\n  float glowbase = mix(solid,bg,.1+.5*sin(time*20.));\n  float glowbox = max(glowbase - glowr, -glowbase+glowr-.4);\n  // a buffer between the solid and the fog to prevent\n  // super-bright areas on the solid as the raymarcher\n  // slows down. try setting this to 0 and see what happens\n  // should be at least DENSITY\n  // raising this is the best way to deal with edge glow around\n  // the solid\n  float BUFFER_ZONE = 0.05;\n  \n  \n  // lower = more dense fog. should be at least 1/stepcount\n  // (100 here)\n  float FOGSTEP = .03;\n\n  // ==== and here's the 2-line fog effect ====\n  // * if we're inside the glowbox, increase the glow by how far\n  // we have penetrated into the box.\n  // * however, if we're passing close to the solid object, we have to\n  // not increase the glow because it will overcount as we step closer\n  // and closer to the solid. so we zero it out below the buffer zone\n  glow += max(0., -glowbox)*smoothstep(0.,BUFFER_ZONE*2.,solid);\n  \n  // step towards the glowbox by the distance we are inside the cube,\n  // plus a little buffer to get us inside the box. if we're *in* the\n  // box, we want to keep moving, and abs(glowbox) will make sure we're\n  // approximately inside the box still. note that we will *never* detect\n  // a surface at any point of the glowbox, because the minimum distance is\n  // always positive.\n  glowbox = abs(glowbox) + FOGSTEP;\n  return min(bg,min(solid,glowbox));\n}\n\n\nfloat ray(vec3 start, vec3 dir) {\n  float dist=0.;\n  glow=0.;\n  \n  for (int i=0;i<200;i++) {\n    float c = scene(start+dir*dist);\n    dist += c;\n    if (c < .001) return dist;\n    if (dist > 10000.) return 100001.;\n  }\n  \n  return 1001.;//min(dist,1000.);\n}\n\nvec3 grad(vec3 p) {\n  mat3 K = mat3(p,p,p) - mat3(.01);\n  return scene(p)-vec3(scene(K[0]),scene(K[1]),scene(K[2]));\n}\n\nfloat N(float x) {\n  return fract(tan(x*1234.-2345.));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= .5;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    float band = floor(uv.x*20.+time*200.);\n    uv.y = fract(uv.y+.5 + 0.01*mouse.y*N(band+7.)*time*N(band))-.5;\n    \n    float focus=2.;\n    vec3 cam = vec3(0,0,-5.*focus);\n    vec3 dir = normalize(vec3(uv,focus));\n    \n    float dist = ray(cam, dir);\n    float G = glow; \n    vec3 hit = cam+dir*dist;\n    vec3 norm = normalize(grad(hit));\n    \n    vec3 refl = reflect(dir,norm);\n    float refldist = ray(hit+refl*.1, refl);\n    float reflglow = glow;\n    \n    vec3 col;\n    if (dist < 1000.) {\n      // thanks blackle for the awesome fake image lighting :3\n      float diff = length(sin(norm)*.5+.5)/sqrt(3.);\n      col = max(0., pow(diff, 2.))*vec3(.1,0,0);\n    } else {\n      float moonspeed = 40.;\n      vec2 p = uv*8.+.5*texture(iChannel0,uv).r;\n      col = vec3(1,.5,.1)*(1.-length(p+vec2(4.*sin(moonspeed*sin(time)),-1.+cos(moonspeed*sin(time)))));\n      col = max(col,-mouse.y);\n      //col = tan(col);\n    }\n    \n    \n    // lower numbers are a denser, more uniform fog\n    // high numbers are very glowy and a little glitchy\n    float UNIFORMITY = 0.8;\n    col += pow(G, UNIFORMITY) *mouse.x * vec3(.9, .3,.1);;\n    col += reflglow * vec3(.9,.2,.1)*.8;\n    // Output to screen\n    fragColor = vec4(sqrt(col),1.0);\n}","name":"Image","description":"","type":"image"}]}