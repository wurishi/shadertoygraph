{"ver":"0.1","info":{"id":"3ljyzc","date":"1594973586","viewed":130,"name":"Textured Tunnel (N-Sided)","username":"voax","description":"reusable 3D Tunnel with specifiable number of sides\nmouse controls curvature/roundness","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["tunnel","square","triangular"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xsf3Rn","filepath":"/media/a/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png","previewfilepath":"/media/ap/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"int sides = 3; // [3, ...)\n\nfloat speed \t = 6.0;\nfloat roundness  = 0.0;\nfloat swirl\t\t = 0.01;\nfloat fadeout\t = 1.0;\nvec2 curvature \t = vec2(2.0, 2.0);\nfloat curviness  = 0.5;\nvec3 bg \t\t = vec3(1,1,1);\n\n#define EPS 0.005\n#define FAR 40.0 \n#define PI 3.14159265359\n#define T iTime\n#define NTILES 1.0\n\nstruct Scene {\n    float t;\n    vec2 walluv;\n    vec2 uvr;\n};\n    \nmat2 rot(float x) {return mat2(cos(x), sin(x), -sin(x), cos(x));}\nfloat rand(vec2 p) {return fract(sin(dot(p, vec2(12.9898,78.233))) * 43758.5453);}\n\nvec3 path(float t) {\n    vec2 ab = vec2(sin(t * PI / 16.0 + 1.5707963 * 1.0),\n        \t\t   cos(t * PI / 16.0));\n    return vec3(ab * curvature, t);    \n}\n\nScene map(vec3 rp) {\n    rp.xy -= path(rp.z).xy;\n    rp.xy = rot(rp.z * swirl) * rp.xy;\n    \n    float a = atan(rp.y,rp.x);\n    \n    float fsides = float(sides);\n    \n    float ax = fsides * a / (2.0*PI); \t// [0,3) e.g. sides = 3\n    float nax = floor(ax);\t\t\t\t// (0,1,2)\n    ax = 0.5 - (ax - nax);\t\t\t\t// [-0.5,0.5) x 3\n    float sax = sign(ax);\n    ax = 2.0/fsides *PI * abs(ax);\t\t// [1/3 PI, 0),[0,1/3 PI) x3 (60 degrees)\n    \n    float r1 = length(rp.xy);\n    float r2 = length(rp.xy) * cos(ax);\t\t\n    float r = mix(r2,r1, roundness);\n    \n    float uvx1 = (nax - sax * ax / (2.0 * PI/fsides) + 0.5) / fsides;\n    float uvx2 = (nax - sax * tan(ax) / (2.0 * tan(PI/fsides)) + 0.5) / fsides;\n    float uvx = mix(uvx2,uvx1, roundness);\n    \n    vec2 uv = vec2(uvx, rp.z);\n    vec2 uvr = vec2(0.0, rp.z);\n\n    float tun = 1.7 - r;\n\n    return Scene(tun, uv, uvr);\n}\n\nScene march(vec3 ro, vec3 rd) {\n\n    float t = 0.0;\n    vec2 walluv = vec2(0.0);\n    vec2 walluvr = vec2(0.0);\n    vec2 cellid = vec2(0.0);\n    float edge1 = 0.0;\n    \n    for (int i = 0; i < 96; i++) {\n        vec3 rp = ro + rd * t;\n        Scene scene = map(rp);\n        if (scene.t < EPS || scene.t > FAR) {\n            walluv = scene.walluv;\n            walluvr = scene.uvr;\n            break;\n        }\n        t += scene.t;\n    }\n    \n    return Scene(t, walluv, walluvr);\n}\n\nvec3 colour(Scene scene) {\n    return textureGrad(iChannel0, scene.walluv, dFdx(scene.uvr), dFdy(scene.uvr)).xyz; // uvr: https://iquilezles.org/articles/tunnel\n}\n\nvoid setupCamera(vec2 fragCoord, out vec3 ro, out vec3 rd) {\n\n    vec2 uv = (fragCoord.xy - iResolution.xy * 0.5) / iResolution.y;\n\n    float ct = T * speed;\n\n    vec3 lookAt = vec3(0.0, 0.0, ct);\n    ro = lookAt + vec3(0.0, 0.0, -5.0);\n\n    lookAt.xy += path(lookAt.z).xy;\n    ro.xy += path(ro.z).xy;\n\n    float FOV = PI / 3.0;\n    vec3 forward = normalize(lookAt - ro);\n    vec3 right = normalize(vec3(forward.z, 0.0, -forward.x)); \n    vec3 up = cross(forward, right);\n\n    rd = normalize(forward + FOV * uv.x * right + FOV * uv.y * up);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    if (iMouse.z > 0.5) {\n     \tcurviness = iMouse.x/iResolution.x;\n        roundness = clamp(2.0 * iMouse.y/iResolution.y - 0.5, 0.0,1.0);\n    }\n    else\n        sides = 3 + int(5.0 * fract(iTime * 0.3));\n    \n    curvature *= curviness;\n    \n    vec3 pc = vec3(0.0);\n    float mint = FAR;\n\n    vec3 ro, rd;\n    setupCamera(fragCoord, ro, rd);\n\n    Scene scene = march(ro, rd);\n    if (scene.t > 0.0 && scene.t < FAR) {\n        pc = colour(scene) / (scene.t * 0.5);\n        mint = scene.t;\n        // pc = vec3(scene.walluv, 0);\n    }\n    else\n        pc = bg;\n    \n    pc = mix(pc, bg, fadeout * pow(scene.t/FAR, 2.0));\n        \n    fragColor = vec4(sqrt(clamp(pc, 0.0, 1.0)), 1.0);\n    // fragColor = vec4(pc, 1.0);\n}","name":"Image","description":"","type":"image"}]}