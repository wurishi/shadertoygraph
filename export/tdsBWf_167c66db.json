{"ver":"0.1","info":{"id":"tdsBWf","date":"1589552890","viewed":231,"name":"Ford Monument","username":"spalmer","description":"a testament to Lester R. Ford, Sr. for the circles which bear his name.  A simple kaleidoscope of a 3d view of a simplified sequence of Ford circles.  Or maybe it's to Lita Ford, who probably has a guitar shaped like this.  Uses experimental WoS lighting.","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["sphere","packing","ford","appollonian","rwos"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// fork of Ford Circles 101:  http://shadertoy.com/view/wdlBWX\n// and Orbit Camera:  http://shadertoy.com/view/WlVGD1\n// TODO at some point should merge in some cool rendering/shading\n// haven't merged any code in yet but might regarding random walk on spheres\n// let's see how far I can get w/o referring back to anything lol!\n\n#define IZERO min(0, iFrame)\n\nconst float pi = acos(-1.)\n\t, tau = 2. * pi\n    , phi = .5 * (sqrt(5.) + 1.);\n\nconst float radius = .5 // of object resting on ground to examine\n, orbit_scale = 3.2; // of radius of object\n\nconst int nbulbs = 6;\n\nconst vec3 op = vec3(-1,0,0); // HACK major kludge, quite problematic\n// due to how I arranged the Ford circles with tail end at the origin\n// TODO re-integrate into C somehow\n\n// Ford circle for given rational number p/q\nvoid C(int p, int q, out vec3 c, out float r)\n{\n    if (q <  1) {\n        c = vec3(0); r = 0.; return;\n    }\n    r = .5 / float(q * q); \n    c.x = float(p) / float(q);\n    c.y = r;\n    c.z = 0.;\n}\n    // radius is in fact an easy sequence to compute\n\n    // must actually skip cases that reduce to simpler fractions!!!\n    // first the special cases to start sequence off:\n    // cannot do it recursively in GLSL anyway!\n\n// quick'n'dirty, not precise palette\nvec3 hue(float h)\n{\n    return max(cos(vec3(0,2,4) + (h-.166) * tau), 0.);\n}\n\nvec3 csky(vec3 rd)\n{\n    return rd * .5 + .5; //vec3(0); //  \n}\n\nfloat dPlaneY(vec3 p, vec3 d) { return p.y; }\nfloat dBall(vec3 p, vec3 d) { return length(p) - 1.; }\n\n// FIXME same as ConsiderObject so far\n// first 3 are inout arguments, last 2 unmodified.\n// sorry about the dtemp var hack, it's still pretty lame.\n// macro is to future-proof check of bounding volume etc.\n#define CheckObject(dtemp, dmin, imin, dobj, iobj) \\\ndtemp = dobj; \\\nif (dtemp < dmin) \\\n{ dmin = dtemp; imin = iobj; }\n///\n\n// must replicate traced scene as sdf\nfloat dscene(vec3 p, out int sid)\n{\n    sid = 0; // nearest object (for material/lighting)\n    float d = 3.4e38, dtemp; // prep trace scene\n    vec3 ro = p, rd = vec3(0);\n    int i = 0;\n    CheckObject(dtemp, d, i, dPlaneY(ro, rd), 1);\n//    CheckObject(dtemp, d, i, dBall(ro.zyx / .5, rd) * .5, 2); // for checking sanity\n//    CheckObject(dtemp, d, i, dBall((ro - op) / .5, rd) * .5, 2);\n    \t// in fact with distance field ray marching, yes, totally,\n    // far easier to do symmetry some other way FIXME\n    // but I'll roll with it for now to get started hehe\n    // truly I'm being silly here, I believe I could do the equivalent\n    // by mirroring the camera vectors with the scene in a loop\n    // HACK kludged to make a nice sequence even without sieving primes\n  #if 1\n    for (int j = nbulbs; j-- >= 1; ) {\n        vec3 c; float r; int id = j;\n        C(1, j+1, c, r);\n        int k = 2 + id;\n    \tCheckObject(dtemp, d, i, dBall((ro.zyx * vec3(-1,1, 1) - op - c) / r, rd.zyx * vec3(-1,1, 1)) * r, k);\n    \tCheckObject(dtemp, d, i, dBall((ro.zyx                 - op - c) / r, rd.zyx                ) * r, k);\n    \tCheckObject(dtemp, d, i, dBall((ro     * vec3(-1,1, 1) - op - c) / r, rd     * vec3(-1,1, 1)) * r, k);\n    //\tCheckObject(dtemp, d, i, dBall((ro                     - op - c) / r, rd                    ) * r, k);\n        if (id > 0)\n        { // getting these horns arranged is harder than it looks lol sign madness!\n    //    CheckObject(dtemp, d, i, dBall((ro.yzx * vec3( 1,1, 1) - vec3( .5,-.5, 0) - op - c) / r, rd.yzx * vec3( 1,1, 1)) * r, k);\n    //\t  CheckObject(dtemp, d, i, dBall((ro.yzx * vec3(1,-1, 1) - vec3(-.5,-.5, 0) - op - c) / r, rd.yzx * vec3(-1,1, 1)) * r, k);\n    //    CheckObject(dtemp, d, i, dBall((ro.yxz * vec3( 1,1, 1) - vec3( .5,-.5, 0) - op - c) / r, rd.yxz * vec3( 1,1, 1)) * r, k);\n    \tCheckObject(dtemp, d, i, dBall((ro.yxz * vec3(-1,1, 1) - vec3(-.5,-.5, 0) - op - c) / r, rd.yxz * vec3(-1,1, 1)) * r, k);\n        }\n    }\n  #endif\n    sid = i;\n    return d; // TODO\n}\n// curry shim, yay dead code elimination phase!\nfloat dscene(vec3 p)\n{\n    int _; // unused id\n    return dscene(p, _);    \n}\n\n// safer than usual; TODO incorporate eye distance lod\nvec3 nscene(vec3 p) //, float h, out float d)\n{\n    float h = .002;\n    vec3 n = vec3( \n          dscene(p + vec3(h,0,0))\n        , dscene(p + vec3(0,h,0))\n        , dscene(p + vec3(0,0,h))\n      ) - dscene(p);\n    if (dot(n,n) < 1e-7) n = vec3(0,1,0);\n    else n = normalize(n);\n    return n;\n}\n\nfloat rseed; // random seed\n\n// Wellons lowbias32 from http://nullprogram.com/blog/2018/07/31\n// perhaps the best ever devised for this op count, great distribution and cycle\nuint hashWellons2(uint x)\n{\n    x ^= x >> 16;\n    x *= 0x7feb352du;\n    x ^= x >> 15;\n    x *= 0x846ca68bu;\n    x ^= x >> 16;\n    return x;\n}\n\nfloat rnd() // about that alleged randomness, buddy... FIXME need real hash\n{ // this garbage distribution should be embarrassing enough to prevent publishing the toy\n//    return sin(7. * tau * (rseed = fract(rseed * 5. * phi + 1e-7)));\n    return exp2(-23.) * float(hashWellons2(floatBitsToUint(rseed = fract(rseed + .6182))) & 0x7fffffu) * 2. - 1.;\n} // but I have no shame lol - use whatever hash works for you!\n\nvec3 randomDir()\n{\n    return normalize(vec3(rnd(), rnd(), rnd()));\n}\n// I tried blackle's tangent trick!  slightly different but did not notice major change.\n// I might not have done it correctly though.\n\n// seriously I'm just not finding the hashing to be the major problem.\n// Random Walk On Spheres is awesome!\n\n// creative use of bias should be able to make it replicate\n// traditional ray marching effects, but with some amount of\n// blurriness dependent inversely upon the magnitude of the bias.\n// with no bias, it's really blurry and liable to randomly\n// walk straight back into the neighboring surface, resulting\n// in maybe some subsurface if handled properly (not done here)\n// so usually you'd want to take the surface normal into account.\n// returns final position o walked to.\nvec3 rwos(vec3 o, vec3 bias, int iter, float tol, out int rwid)\n{\n    vec3 orig = o;\n    rwid = 0; // sky if hit nothing else\n    for (int i = iter; --i > 0; ) {\n        int sid;\n        float d = dscene(o, sid);\n        if (d < tol) { // TODO abs(d)?\n            rwid = sid; break;\n        }\n        vec3 g = randomDir();\n        g += bias;\n        float m = dot(g, g);\n        if (m < 1e-6) continue; // avoid nan\n        o += d * inversesqrt(m) * g; // normalize(g) shares m \n    }\n    //o = mix(orig, o, .9); // HACK - no\n    return o;\n}\n\n// HACK x = some hack for lighting; trying to fix stuff\n// when x == 0, basically returns albedo, \n// when x == 1, returns the pulsing glow emission too\n// TODO desperately wants some texture\nvec3 cscene(vec3 hp, vec3 n, float d, int i, float x)\n{\n    // TODO would be better off with actual reflection mapping somehow;\n    // this sort of averages the sky color out to a gray for bounce light purposes\n    vec3 cenv = vec3(.4); \n    vec3 csk = csky(n); //vec3(0,1,0)); // green tho\n    cenv = mix(cenv, csk, .5); \n    vec3 cfire = .2*vec3(1,.4,.16); // lamest fire palette evar\n    vec3 c = vec3(0);\n    switch (i) {\n        case 0: { // sky\n        \tc.rgb = cenv; d = 1e4;\n        \tbreak;\n        }\n        case 1: { // plane\n        //\tfloat stripe = cos(hp.x) * cos(hp.z); //.5; //1.; // 2d grid texture\n        //\tstripe *= stripe; stripe = 1. - stripe; stripe *= stripe;\n        //\tstripe = 0.*mix(stripe, .3, min(1., .4*length(fwidth(hp.xz)))); // aa\n        //\tc.rgb = vec3(0,0,0); //vec3(.1, .1*stripe, .1); // colorize\n            c.rgb = vec3(.1*x); // ambient on plane bounces up onto spheres and lights them, which bounces back down as tinted shadows\n        \tbreak;\n        }\n        default:\n      //  case 2: { // sphere\n        \tc = hue(phi * float(i));\n\t\t\tif (x > 0.) {\n        \tc = .1 + .1*c;\n        \t\tfloat flux = sin(iTime*2.) * .5 + .5;\n                flux *= x;\n                c += cfire * flux;\n            \t//c = mix(c, c + cfire, flux);\n            } // fluctuate\n\t    \tbreak;\n      //  }\n\t}\n    // most gawdawful HACK ever! somehow I've made diffuseness into an argument\n    // what in the heck am I doing here, returning colorization components based\n    // on scalar argument, just make a real light transfer function!\n    if (x == 0.) // general albedo and emission?\n    \tc = .7 * mix(c, vec3(1), .5);\n    //if (x != 0.) //else // what ambient lighting picks up\n    //\tc *= mix(1., 1./2., x); // FIXME probably missing a pi factor elsewhere\n    return c;\n}\n\nvec3 cglow(vec3 hp, vec3 v, float d, int id)\n{\n  //  return vec3((1.-dscene(hp)) * exp2(-.5*d));\n    vec3 n = nscene(hp);\n    n = normalize(n);\n    hp += .025 * n; // random walk already using it as a bias, no need atm\n   \n    vec3 r = n;\n\tif (id == 1) r *= .99; // plane much blurrier\n    else {\n        // balls pretty shiny\n        r = normalize(reflect(-v, n)); //n, v)); //n + \n        r *= exp2(2.); // how shiny?\n        n += r; //n = r; //\n    }\n    vec3 rnorm = normalize(r);\n  //  return n * .5 + .5;\n    // TODO improve lighting\n    vec3 c = vec3(0);\n    int ni = 12;\n    if (iResolution.y > 500.) ni -= 4;\n    if (iResolution.y > 1000.) ni /= 2;\n    if (iResolution.y > 1400.) ni /= 2;\n    //barrier(); // great place for a barrier, but GLES 3 doesn't have any?!\n    ni = max(ni, 1);\n    for (int i = ni + IZERO; --i >= 0; ) {\n        int rwid;\n        vec3 pwalk = rwos(hp, r, 6, .015, rwid);\n        if (hp.y > 1.5) rwid = 0;\n    \tvec3 amb = cscene(pwalk, rnorm, d, rwid, 1.); // / (1. + dot(pwalk - hp, pwalk - hp)); //i); //\n        amb = clamp(amb, 0., 1.);\n        c += amb;\n    }\n    c *= 1. / float(ni);\n    vec3 emi = cscene(hp, n, d, id, 0.);\n    c *= emi; // or is it albedo?\n    c = clamp(c, 0., 1.);\n    return c;\n}\n\n#if 0\n// marching - too slow\n// so I can reuse sdf and maybe debug it, similar but marched\n// returns (distance, material)\nvec2 March(vec3 ro, vec3 rd, float rate, int iters)\n{\n    vec2 c = vec2(3.4e38, 0);\n    int i = iters;\n    float t = 0.;\n    while (i-- > 0) {\n        int id;\n        float d = dscene(ro + rd * t, id);\n        //float d = h.x;\n        //if (d < c.x) {\n        //    c = h; //vec2(d, m);\n        //}\n        t += d * rate;\n        if (d < .01) {\n            c = vec2(d, float(id));\n            break;\n        }\n    }\n    //barrier(); // FIXME sync threads please - lack of barrier makes marching particularly slow, even if unrolled; don't think the threads ever manage to sync up before the next loop\n    int m = int(c.y);\n    const float dmax = 8.5e4;\n    /*if (false && c.x > .05 && ro.y > 0.) { // rescue? no.\n        if (rd.y < 0.) { // ground plane\n            t = ro.y / -rd.y; m = 1;\n        } else { // sky dome\n            t = dmax * pow(1.-.5*rd.y, 2.); m = 0;\n        }\n        c.y = float(m);\n    }*/\n    c.x = clamp(t, 0., dmax);\n    return c;\n}\n\nvec3 RenderScene(vec3 ro, vec3 rd, float time)\n{\n\tvec2 m = March(ro, rd, .5, 48);\n    float d = m.x;\n    int id = int(m.y);\n    vec3 cenv = csky(rd);\n    vec3 hp = ro + d * rd; // hit pos\n    vec3 c = vec3(0.);\n   \tc = cglow(hp, -rd, d, id);\n    float dfade = exp2(-.02 * d);\n    c.rgb = mix(cenv, c.rgb, dfade);\n    return c;\n}\n\n#else\n// tracing\n\n//hp -= op; //vec3 hp = ro + d * rd - op; \n//hp *= 1.*pi;\n\n// basic root finder special case\nfloat Root(vec3 f) // first zero crossing of polynomial quadric function\n{ // f(t) = dot(f, vec3(1.,vec2(1.,t)*t)) == 0\n    float dsc = .25 * f.y * f.y - f.x * f.z;\n    if (dsc < 0.) return -1.; // guard vs. nan fix for busted camera on android \n\tfloat d = sqrt(dsc);\n\tif (f.y * f.z < 0.) d = -d; // wut?\n\treturn (d - .5 * f.y) / f.z;\n} // see also The Quadratic Equation\n\nfloat tracePlaneY(vec3 ro, vec3 rd)\n{\n    return ro.y <= 0. ? 0. : rd.y >= -5e-3 ? -1. : ro.y / -rd.y;\n}\n\n// many cases not handled properly btw\nfloat traceBall(vec3 ro, vec3 rd)\n{\n\treturn Root(vec3(dot(ro, ro) - 1., 2. * dot(ro, rd), 1.));\n}\n\n// first 3 are inout arguments, last 2 unmodified.\n// sorry about the dtemp var hack, it's pretty lame.\n/// macro is to future-proof check of bounding volume etc.\n#define ConsiderObject(dtemp, dmin, imin, dobj, iobj) \\\ndtemp = dobj; \\\nif (0. <= dtemp && dtemp < dmin) \\\n{ dmin = dtemp; imin = iobj; }\n///\n\nfloat Trace(vec3 ro, vec3 rd, out int i)\n{\n    float d = 3.4e38, dtemp; // prep trace scene\n    ConsiderObject(dtemp, d, i, tracePlaneY(ro, rd), 1);\n    // truly I'm being silly here, I believe I could do the equivalent\n    // by mirroring the camera vectors with the scene in a loop\n    // HACK kludged to make a nice sequence even without sieving primes\n    for (int j = nbulbs; --j >= 0; ) {\n        vec3 c; float r; int id = j;\n        C(1, j+1, c, r);\n        int k = 2 + id;\n    \tConsiderObject(dtemp, d, i, traceBall((ro.zyx * vec3(-1,1, 1) - op - c) / r, rd.zyx * vec3(-1,1, 1)) * r, k);\n    \tConsiderObject(dtemp, d, i, traceBall((ro.zyx                 - op - c) / r, rd.zyx                ) * r, k);\n    \tConsiderObject(dtemp, d, i, traceBall((ro     * vec3(-1,1, 1) - op - c) / r, rd     * vec3(-1,1, 1)) * r, k);\n    //\tConsiderObject(dtemp, d, i, traceBall((ro                     - op - c) / r, rd                    ) * r, k);\n        //if (id > 1)\n        { // getting these horns arranged is harder than it looks lol sign madness!\n    //    ConsiderObject(dtemp, d, i, traceBall((ro.yzx * vec3( 1,1, 1) - vec3( .5,-.5, 0) - op - c) / r, rd.yzx * vec3( 1,1, 1)) * r, k);\n    //\t  ConsiderObject(dtemp, d, i, traceBall((ro.yzx * vec3(1,-1, 1) - vec3(-.5,-.5, 0) - op - c) / r, rd.yzx * vec3(-1,1, 1)) * r, k);\n    //    ConsiderObject(dtemp, d, i, traceBall((ro.yxz * vec3( 1,1, 1) - vec3( .5,-.5, 0) - op - c) / r, rd.yxz * vec3( 1,1, 1)) * r, k);\n    \t  ConsiderObject(dtemp, d, i, traceBall((ro.yxz * vec3(-1,1, 1) - vec3(-.5,-.5, 0) - op - c) / r, rd.yxz * vec3(-1,1, 1)) * r, k);\n        }\n    }\n    if (d < 0.) d = 8e5;\n    return d;\n}\n\nvec3 RenderScene(vec3 ro, vec3 rd, float time)\n{\n    vec3 c = vec3(0);\n    int i = 0; // sky is id 0\n    vec3 cenv = csky(rd);\n    float d = Trace(ro, rd, i);\n    vec3 hp = ro + d * rd; // hit pos\n   \tc = cglow(hp, -rd, d, i);\n    float dfade = exp2(-.04 * d);\n    c.rgb = mix(cenv, c.rgb, dfade); // \"fog\"\n    return c;\n}\n\n#endif\n// ray scan method\n\n// I'm sure compiler will figure it out and\n// rewrite to same thing internally either way,\n// but I've always had a soft spot for the\n// identity x + x = 2*x, since historically\n// x += x has been a cheaper operation than\n// x *= 2 or even x <<= 1 in some cases.\n// Nowadays with mads, probably not, in this case.\n// it'll evaluate as (2.*s-r)/r.y, betcha.\nvec2 StoQ(vec2 s, vec2 r)\n{\n\treturn (s + s - r) / r.y;\n}\n\nmat3 CameraMatrix(vec3 camFwd)\n{\n    vec3 w = normalize(camFwd)\n       , u = normalize(cross(vec3(0, 1, 0), w))\n       , v = normalize(cross(w, u));\n    return mat3(u, v, w);\n}\n// then transform by pw = MC * pv;\n\nvec3 sph2cart(vec3 a) // spherical radians theta, psi, radius -> cartesian\n{\n    float cx = cos(a.x), sx = sin(a.x)\n        , cy = cos(a.y), sy = sin(a.y);\n    return vec3(sx*cy, sy, cx*cy) * a.z;\n}\n\nvec3 OrbitCamera(vec2 angles)\n{ // angles is yaw, pitch in radians\n    angles.x *= 2.;\n    angles.y = clamp(angles.y, -.4, .3);\n    return sph2cart(vec3(angles * pi, 1.));\n} // returns forward vector camera aims along\n\nfloat Dither(vec2 p)\n{\n    return sin(dot(p, vec2(1./23., 1./23./17.)) * 23456.);\n}\n\nvoid mainImage(out vec4 c, vec2 p)\n{\n    rseed = fract(fract(iTime*.1)+dot(vec2(.09,.07),p));\n    c = vec4(0,0,0,1);\n    vec2 R = iResolution.xy\n    , M = iMouse.xy\n    , q = StoQ(   p, R)\n    , m = StoQ(M.xy, R);\n    if (length(M.xy) <= 1.)\n        m = vec2(.2 + .02*iTime,.25); // unattended, mouse in bottom left corner?\n    vec3 object_pos = vec3(0, radius, 0)\n        , camera_dir = OrbitCamera(m)\n        , camera_pos = object_pos - orbit_scale * radius * camera_dir;\n    camera_pos.y = max(camera_pos.y, 1e-2); // do not go beneath ground\n    camera_dir = normalize(object_pos - camera_pos); // redo LookAt\n    mat3 cam = CameraMatrix(camera_dir);\n    const float hfovy = pi/6.;\n    vec3 vd = normalize(vec3(q, 1./sin(hfovy)))\n    , ro = camera_pos\n    , rd = normalize(cam * vd); // view ray\n    c.rgb = RenderScene(ro, rd, iTime);\n    c.rgb = pow(c.rgb, vec3(1./2.2)); // to sRGB gamut (approximately)\n    c.rgb += .5/256. * Dither(p);\n}\n\n            //float stripe = 1.; //cos(hp.x) * cos(hp.y) * cos(hp.z); // 3d grid texture\n        //    stripe = 1. - abs(stripe); stripe *= stripe; stripe *= stripe; \n        //    stripe = mix(stripe, .3, min(1., .4*length(fwidth(hp)))); // aa\n        //    if (d == 0.) stripe = sin(iTime*12.); // beneath? flash\n            //c.rgb = vec3(.5, .25*stripe, 0.); // colorize\n            // TODO antialias silhouette edge!  ;)\n\t\t\t//float pixel = .5/r.y;\n\t\t    //d -= .5 * pixel;\n\t\t\t//float cov = clamp(.5 - .5*d*r.y, 0., 1.);\n\t\t    //float g = cov;\n\t\t   // c = h; //vec3 c = 2. * vec3(g) * h; // super bright!  more will saturate weird\n\n","name":"Image","description":"","type":"image"}]}