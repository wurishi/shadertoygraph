{"ver":"0.1","info":{"id":"X3BfWt","date":"1730057329","viewed":168,"name":"cosmic lines","username":"nayk","description":"source https://www.shadertoy.com/view/XlfGRj https://www.shadertoy.com/view/wdtczM","likes":6,"published":3,"flags":0,"usePreview":0,"tags":["lines","cosmos"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n#define iterations 15\n#define formuparam 0.53\n\n#define volsteps 20\n#define stepsize 0.1\n\n#define zoom   0.800\n#define tile   0.850\n#define speed  0.010 \n\n#define brightness 0.0015\n#define darkmatter 0.300\n#define distfading 0.730\n#define saturation 0.850\n#define size 035.\n\nvec2 Hash12(float t)\n{\n    float x = fract(sin(t * 36.3) * 453.2);\n    float y = fract(sin(t * 54.3) * 453.2);\n    \n    return vec2(x,y);\n}\n#define rot(x) mat2(cos(x+vec4(0,11,33,0)))\n\n//Rodrigues-Euler axis angle rotation\n#define ROT(p,axis,t) mix(axis*dot(p,axis),p,cos(t))+sin(t)*cross(p,axis)\n\n//formula for creating colors;\n#define H(h)  (  cos( h*8.*(1.+.8*sin(iTime/7.)) + 30.*vec3(1,3,2)  )*.7 + .2  )\n\n//formula for mapping scale factor \n#define M(c)  log(c)\n\n#define R iResolution\n#define resolution iResolution.xy\n#define time iTime\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t//get coords and direction\n\tvec2 uv=fragCoord.xy/iResolution.xy-.5;\n    float t3 = iTime * .1 + ((.25 + .05 * sin(iTime * .1))/(length(uv.xy) + .27)) * 5.2;\n\tfloat si = sin(t3);\n\tfloat co = cos(t3);\n\tmat2 ma = mat2(co, si, -si, co);\n   \n\tuv.y*=iResolution.y/iResolution.x;\n    vec4 o =fragColor;\n    vec2 F=fragCoord;\n    vec2 R = iResolution.xy; \n    o-=o;\n    for(float d,t = -iTime*.01, i = 0. ; i > -1.; i -= .06 )          \t\n    {   d = fract( i -3.*t );                                          \t\n        vec4 c = vec4( ( F - R *.5 ) / R.y *d ,i,0 ) * 28.;            \t\n        for (int j=0 ; j++ <27; )                                      \t\n            c.xzyw = abs( c / dot(c,c)                                 \t\n                    -vec4( 7.-.2*sin(t) , 6.3 , .7 , 1.-cos(t/.8))/7.);\t\n       o -= c * c.yzww  * d--*d  / vec4(3,5,1,1);                     \n    }\n    \n\tvec3 dir=vec3(uv*zoom,1.);\n\tfloat time=iTime*speed+.25;\nvec4 O=fragColor;\nvec2 U= fragCoord;\nU.xy*=ma;\n O = vec4(0);\n    \n    vec3 c=vec3(0), rd = normalize( vec3(U-.5*R.xy, R.y))*50.;\n    \n    float sc,dotp,totdist=0., t=iTime/2.;\n   \n    \n    for (float i=0.; i<100.; i++) {\n        \n        vec4 p = vec4( rd*totdist, 0.);\n      \n        p -= ( (mod(iTime,4.)<2.) ? round(p/1.5): vec4(0.) );\n        p.xy*=ma;\n        p.xyz += vec3(4.*cos(t),0,-30.+5.*sin(t));\n        sc = 1.;  //scale factor         \n          \n        p.xyz = ROT( p.xyz,\n            normalize(vec3(sin(t/5.),sin(t/3.),0)), mod(5.*t,60.)*sin(t));\n        \n        for (float j=0.; j<2.; j++) {\n        \n            p =  log(1.+abs(p)) ;\n            \n            dotp = max(1./dot(p,p),.3);\n            sc *= dotp;  \n      \n            p *= dotp - .75;\n           \n        }\n         \n        float dist = abs(length(p)-.5)/sc ;  //distance estimate\n        float stepsize2 = dist/40. + 4e-4;   \n        totdist += stepsize2;                  \n        \n       \n        //accumulate color, fading with distance and iteration count\n        c += .03 *  H(M(sc)) * exp(-stepsize2*stepsize2*totdist*totdist*1e5);\n    }\n    \n    c = clamp(c,0.,1.);\n    //c *= c ;\n    \n    O = ( vec4(c,0) );\n\tvec3 from=vec3(1.,.5,0.5);\n\tvec3 rColor =vec3(1.7,1.0,1.0);\n\tvec3 gColor =vec3(0.0,0.9,0.3);\n\tvec3 bColor =vec3(0.0,0.3,0.9);\n\tvec3 yColor =vec3(1.9,1.9,0.3);\n\t\n\tvec2 p =(gl_FragCoord.xy *4.0 -resolution);\n\tp /= min(resolution.x,resolution.y);\n    p.xy*=ma;\n\tfloat a = sin(p.y *0.5 -time*2.1)/1.0;\n\tfloat b = cos(p.y *1.5 -time*0.2)/1.0;\n\tfloat c3 = sin(p.y *3.5 -time*0.3 +3.14)/1.0;\n\tfloat d = cos(p.x *1.5 -time*0.5 +3.14)/1.0;\n\t\n\tfloat e =0.1/abs(p.x+a);\n\tfloat f =0.1/abs(p.x+b+sin(iTime));\n\tfloat g =0.1/abs(p.x+c3);\n\tfloat h =0.1/abs(p.y*d+cos(iTime));\n\t\n\tvec3 destColor = rColor*e + gColor*f +bColor*g +yColor*h;\n\t    vec3 col = vec3(0.0);\n     for(float i = 0.; i < size; i++)\n    {\n     \n uv*=mat2(cos(iTime*0.31),sin(iTime*0.31),-sin(iTime*0.31) ,cos(iTime*0.31));\n        vec2 dir= Hash12(i) -.5; \n        \n        float d = length(uv-dir*cos(iTime));\n \n        float brightness2 = 0.0002+i*0.0001;\n        col += vec3(brightness2*2.5 / d);\n        \n    \n    }   \n    \n\t//volumetric rendering\n\tfloat s=0.1,fade=1.;\n\tvec3 v=vec3(0.);\n\tfor (int r=0; r<volsteps; r++) {\n\t\tvec3 p=from*o.xyz+s*dir*.5;\n\t\tp = abs(vec3(tile)-mod(p,vec3(tile*2.))); // tiling fold\n\t\tfloat pa,a=pa=0.;\n\t\tfor (int i=0; i<iterations; i++) { \n\t\t\tp=abs(p)/dot(p,p)-formuparam;\n                p.xy*=mat2(cos(iTime*0.05),sin(iTime*0.05), -sin(iTime*0.05),cos(iTime*0.05));\n            // the magic formula\n\t\t\ta+=abs(length(p)-pa); // absolute sum of average change\n\t\t\tpa=length(p);\n\t\t}\n\t\tfloat dm=max(0.,darkmatter-a*a*.001); //dark matter\n\t\ta*=a*a; // add contrast\n\t\tif (r>6) fade*=1.2-dm; // dark matter, don't render near\n\t\t//v+=vec3(dm,dm*.5,0.);\n\t\tv+=fade;\n\t\tv+=vec3(s,s*s,s*s*s*s)*a*brightness*fade; // coloring based on distance\n\t\tfade*=distfading; // distance fading\n\t\ts+=stepsize;\n\t}\n\tv=mix(vec3(length(v)),v,saturation); //color adjust\n\tfragColor = vec4(v*.02*destColor*col,1.);\t\n\t\n}","name":"Image","description":"","type":"image"}]}