{"ver":"0.1","info":{"id":"sdXBRs","date":"1645277505","viewed":118,"name":"simple ray tracing (inefficient)","username":"Tomass","description":"its just a simple ray tracer\nI used the collision function from https://www.shadertoy.com/user/reinder  (things that are named i and a shape)","likes":1,"published":1,"flags":48,"usePreview":0,"tags":["raytracing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"bool Reflections = false;\nbool softReflection = false;\nbool Shading = true;\nbool shadows = true;\nbool textures = false;\nbool aniAliasing = false;\nbool srgb = false;\n\n\nint aniAliasingSamples = 3;\nint samples=100;//Soft reflection\n\nvec3 pal(in float t) {\n    t=t*.59996323+.5;\n    vec3 a=vec3(.5);\n    vec3 b=vec3(.5);\n    vec3 c=vec3(1);\n    vec3 d=vec3(0,.1,.2);\n    return a + b*cos(6.28318530718*(c*t+d));\n}\n\nvec3 colors[5]=vec3[5](           vec3(1,0,0),  vec3(.5,.5,.5),  vec3(0,1,1),  vec3(1,1,1),  vec3(0,0,1));\nfloat Reflectivness[5]=float[5](  0.3,          0.2,             0.1,          0.0,          0.15);\nfloat Bluriness[5]=float[5](      0.05,          0.01,            0.0,          0.0,          0.06);\n\n\nfloat MAX_DIST = 1000.0;\nfloat dot2( in vec3 v ) { return dot(v,v); }\n\nfloat iBox( in vec3 ro, in vec3 rd, in vec2 distBound, inout vec3 normal, \n            in vec3 boxSize ) {\n    vec3 m = sign(rd)/max(abs(rd), 1e-8);\n    vec3 n = m*ro;\n    vec3 k = abs(m)*boxSize;\n\t\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\n\tfloat tN = max( max( t1.x, t1.y ), t1.z );\n\tfloat tF = min( min( t2.x, t2.y ), t2.z );\n\t\n    if (tN > tF || tF <= 0.) {\n        return MAX_DIST;\n    } else {\n        if (tN >= distBound.x && tN <= distBound.y) {\n        \tnormal = -sign(rd)*step(t1.yzx,t1.xyz)*step(t1.zxy,t1.xyz);\n            return tN;\n        } else if (tF >= distBound.x && tF <= distBound.y) { \n        \tnormal = -sign(rd)*step(t1.yzx,t1.xyz)*step(t1.zxy,t1.xyz);\n            return tF;\n        } else {\n            return MAX_DIST;\n        }\n    }\n}\n\nfloat iSphere( in vec3 ro, in vec3 rd, in vec2 distBound, inout vec3 normal,\n               float sphereRadius ) {\n    float b = dot(ro, rd);\n    float c = dot(ro, ro) - sphereRadius*sphereRadius;\n    float h = b*b - c;\n    if (h < 0.) {\n        return MAX_DIST;\n    } else {\n\t    h = sqrt(h);\n        float d1 = -b-h;\n        float d2 = -b+h;\n        if (d1 >= distBound.x && d1 <= distBound.y) {\n            normal = normalize(ro + rd*d1);\n            return d1;\n        } else if (d2 >= distBound.x && d2 <= distBound.y) { \n            normal = normalize(ro + rd*d2);            \n            return d2;\n        } else {\n            return MAX_DIST;\n        }\n    }\n}\n\nfloat iCylinder( in vec3 ro, in vec3 rd, in vec2 distBound, inout vec3 normal,\n                 in vec3 pa, in vec3 pb, float ra ) {\n    vec3 ca = pb-pa;\n    vec3 oc = ro-pa;\n\n    float caca = dot(ca,ca);\n    float card = dot(ca,rd);\n    float caoc = dot(ca,oc);\n    \n    float a = caca - card*card;\n    float b = caca*dot( oc, rd) - caoc*card;\n    float c = caca*dot( oc, oc) - caoc*caoc - ra*ra*caca;\n    float h = b*b - a*c;\n    \n    if (h < 0.) return MAX_DIST;\n    \n    h = sqrt(h);\n    float d = (-b-h)/a;\n\n    float y = caoc + d*card;\n    if (y > 0. && y < caca && d >= distBound.x && d <= distBound.y) {\n        normal = (oc+d*rd-ca*y/caca)/ra;\n        return d;\n    }\n\n    d = ((y < 0. ? 0. : caca) - caoc)/card;\n    \n    if( abs(b+a*d) < h && d >= distBound.x && d <= distBound.y) {\n        normal = normalize(ca*sign(y)/caca);\n        return d;\n    } else {\n        return MAX_DIST;\n    }\n}\n\nfloat iPlane( in vec3 ro, in vec3 rd, in vec2 distBound, inout vec3 normal,\n              in vec3 planeNormal, in float planeDist) {\n    float a = dot(rd, planeNormal);\n    float d = -(dot(ro, planeNormal)+planeDist)/a;\n    if (a > 0. || d < distBound.x || d > distBound.y) {\n        return MAX_DIST;\n    } else {\n        normal = planeNormal;\n    \treturn d;\n    }\n}\n\nfloat iCone( in vec3 ro, in vec3 rd, in vec2 distBound, inout vec3 normal,\n             in vec3  pa, in vec3  pb, in float ra, in float rb ) {\n    vec3  ba = pb - pa;\n    vec3  oa = ro - pa;\n    vec3  ob = ro - pb;\n    \n    float m0 = dot(ba,ba);\n    float m1 = dot(oa,ba);\n    float m2 = dot(ob,ba); \n    float m3 = dot(rd,ba);\n\n    //caps\n    if (m1 < 0.) { \n        if( dot2(oa*m3-rd*m1)<(ra*ra*m3*m3) ) {\n            float d = -m1/m3;\n            if (d >= distBound.x && d <= distBound.y) {\n                normal = -ba*inversesqrt(m0);\n                return d;\n            }\n        }\n    }\n    else if (m2 > 0.) { \n        if( dot2(ob*m3-rd*m2)<(rb*rb*m3*m3) ) {\n            float d = -m2/m3;\n            if (d >= distBound.x && d <= distBound.y) {\n                normal = ba*inversesqrt(m0);\n                return d;\n            }\n        }\n    }\n                       \n    // body\n    float m4 = dot(rd,oa);\n    float m5 = dot(oa,oa);\n    float rr = ra - rb;\n    float hy = m0 + rr*rr;\n    \n    float k2 = m0*m0    - m3*m3*hy;\n    float k1 = m0*m0*m4 - m1*m3*hy + m0*ra*(rr*m3*1.0        );\n    float k0 = m0*m0*m5 - m1*m1*hy + m0*ra*(rr*m1*2.0 - m0*ra);\n    \n    float h = k1*k1 - k2*k0;\n    if( h < 0. ) return MAX_DIST;\n\n    float t = (-k1-sqrt(h))/k2;\n\n    float y = m1 + t*m3;\n    if (y > 0. && y < m0 && t >= distBound.x && t <= distBound.y) {\n        normal = normalize(m0*(m0*(oa+t*rd)+rr*ba*ra)-ba*hy*y);\n        return t;\n    } else {   \n\t    return MAX_DIST;\n    }\n}\n\nfloat iTriangle( in vec3 ro, in vec3 rd, in vec2 distBound, inout vec3 normal,\n                 in vec3 v0, in vec3 v1, in vec3 v2 ) {\n    vec3 v1v0 = v1 - v0;\n    vec3 v2v0 = v2 - v0;\n    vec3 rov0 = ro - v0;\n\n    vec3  n = cross( v1v0, v2v0 );\n    vec3  q = cross( rov0, rd );\n    float d = 1.0/dot( rd, n );\n    float u = d*dot( -q, v2v0 );\n    float v = d*dot(  q, v1v0 );\n    float t = d*dot( -n, rov0 );\n\n    if( u<0. || v<0. || (u+v)>1. || t<distBound.x || t>distBound.y) {\n        return MAX_DIST;\n    } else {\n        normal = normalize(-n);\n        return t;\n    }\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nvec3 pos = vec3(2,2,0);\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr ) {\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv =          ( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\nvec3 getSkyColor( vec3 rd ) {\n    vec3 col = mix(vec3(1),vec3(.5,.7,1), .5+.5*rd.y);\n    float sun = clamp(dot(normalize(vec3(-.4,.7,-.6)),rd), 0., 1.);\n    col += vec3(1,.6,.1)*(pow(sun,4.) + 10.*pow(sun,32.));\n    float PI=3.14159265359;\n    float u = 0.5f + atan(rd.x, rd.z) / (2.0 * PI);\n    float v = 0.5f - asin(rd.y) / PI;\n    //texture(iChannel0, dir)\n    return col;\n    vec2 uv =vec2(u,v);\n    vec3 col2 = texture( iChannel1, uv ).xyz;\n    return (col2);\n}\n\nvec4 colide(vec3 pos,vec3 rd, out vec3 outNormalOut){\n    vec3 outNormal;\n    float cola;\n    outNormalOut=vec3(0.0);\n    float colaOut=MAX_DIST;\n    float id=0.0;\n    \n     cola = iSphere( pos-vec3( 0,.250, 1), rd,vec2(.00001, 100),outNormal, .25);\n     if(cola<colaOut){outNormalOut=outNormal;colaOut=cola;id=1.0;}\n     \n     cola = iPlane( pos, rd,vec2(.00001, 100),outNormal,  vec3(0,1,0), 0.0);\n     if(cola<colaOut){outNormalOut=outNormal;colaOut=cola;id=2.0;}\n     \n     \n     cola = iBox( pos-vec3( 1,0.250, 0), rd,vec2(.00001, 100),outNormal, vec3(.25));\n     if(cola<colaOut){outNormalOut=outNormal;colaOut=cola;id=3.0;}\n     \n     cola = iCylinder( pos, rd,vec2(.00001, 100),outNormal, vec3(1,.5,1.0), vec3(1,0,1.0), .1 );\n     if(cola<colaOut){outNormalOut=outNormal;colaOut=cola;id=4.0;}\n     \n     cola = iSphere( pos-vec3( 2,.250, 1), rd,vec2(.00001, 100),outNormal, .25);\n     if(cola<colaOut){outNormalOut=outNormal;colaOut=cola;id=4.0;}\n     \n    // cola = iCone( pos-vec3( 0.0,.200, 1.0), rd,vec2(.00001, 100),outNormal, vec3(0,-0.2,0), vec3(0,.3,0), .15, .05);\n     //if(cola<colaOut){outNormalOut=outNormal;colaOut=cola;id=5.0;}\n     \n     const vec3 tri0 = vec3(-2./3. * 0.43301270189, .1, 0);\n\t const vec3 tri1 = vec3( 1./3. * 0.43301270189, .1, .25);\n\t const vec3 tri2 = vec3( 1./3. * 0.43301270189, .1,-.25);\n\t const vec3 tri3 = vec3( 0, 0.61079191812, 0);\n     cola = iTriangle( pos, rd,vec2(.00001, 100),outNormal, tri0, tri1, tri2);\n     if(cola<colaOut){outNormalOut=outNormal;colaOut=cola;id=5.0;}\n     \n     cola = iTriangle( pos, rd,vec2(.00001, 100),outNormal, tri0, tri3, tri1);\n     if(cola<colaOut){outNormalOut=outNormal;colaOut=cola;id=5.0;}\n     \n     cola = iTriangle( pos, rd,vec2(.00001, 100),outNormal, tri2, tri3, tri0);\n     if(cola<colaOut){outNormalOut=outNormal;colaOut=cola;id=5.0;}\n     \n     cola = iTriangle( pos, rd,vec2(.00001, 100),outNormal, tri1, tri3, tri2);\n     if(cola<colaOut){outNormalOut=outNormal;colaOut=cola;id=5.0;}\n     \n     \n     if(colaOut ==MAX_DIST)\n     id=0.0;\n     return(vec4(outNormalOut.xy,colaOut,id));\n   }\n   \nfloat shade(vec3 normal,vec3 lig){\n    if(Shading)\n       return((0.3+max(0.0,min(1.0, dot(normal, lig)*1.1))*0.9));\n    else\n        return(1.0);\n}\nfloat checker( vec2 p ) {\n    if(textures)\n        return mod(floor(p.x) + floor(p.y), 2.);\n    else\n        return(1.0);\n}\n\nvec3 reflec(vec3 normal,vec3 pos,vec3 rd, float dist,vec3 light,out vec3 normOut,out bool sky,out float reflectivnes,out float distanc,out vec3 NewPos,out vec3 NewRd){\n   normal=normalize(normal);\n   vec3 r=rd-2.0*dot(rd,normal)*normal;\n   \n   //vec3 r=2.0*(rd*normal)*normal-rd;\n   vec3 tras;\n   vec4 pps3 = colide(pos+(rd*(dist-0.001)),r,normOut);\n   vec4 pps4 = colide((pos+(rd*(dist-0.001)))+(r*(pps3.z-0.001)),light,tras);\n   \n   NewPos=pos+(r*(pps3.z-0.0001));\n   NewRd=pos+(r*(pps3.z-0.0001));\n   vec3 rCol;\n   if(pps3.w==0.0){\n        rCol =getSkyColor(r);sky = true;\n        return(rCol);\n        }\n   else{\n        rCol = colors[int(pps3.w)-1];sky = false;\n        \n   \n   \n        \n        }\n    \n   reflectivnes=Reflectivness[int(pps3.w)-1];\n   distanc=pps3.z;\n   \n   if(pps3.w==2.0){\n           vec3 position = (pos+(rd*(dist)))+(r*(pps3.z));\n            float a = checker(position.xz * 5.0)/2.0+0.5;\n            rCol =rCol* a;\n   }\n   \n   if(pps4.w!=0.0&&pps4.w!=pps3.w&&shadows)\n    rCol = rCol/2.0;\n    else\n    rCol = rCol;\n    \n    \n    \n    return(rCol*shade(normOut,light));\n   }\nfloat rand(float co) { return fract(sin(co*(91.3458)) * 47453.5453); }\nvec3 encodeSRGB(vec3 linearRGB)\n{\n    vec3 a = 12.92 * linearRGB;\n    vec3 b = 1.055 * pow(linearRGB, vec3(1.0 / 2.4)) - 0.055;\n    vec3 c = step(vec3(0.0031308), linearRGB);\n    return mix(a, b, c);\n}\n\n\nvoid mainImage( out vec4 fragColorOut, in vec2 fragCoord )\n{\nvec4 fragColor;\n    colors =vec3[5](pal(0.5),  pal(4.),  vec3(0,1,1),  pal(4.),  pal(6.));\n    \n    //fragColorOut=vec4(colors[2],1);\n    //return;\n    if(!aniAliasing)\n    aniAliasingSamples=1;\n    for(int anti=0;anti<aniAliasingSamples;anti++){\n    // Normalized pixel coordinates (from 0 to 1)\n    pos.x=texelFetch(iChannel0, ivec2(0, 0), 0).r;\n    pos.z=texelFetch(iChannel0, ivec2(1, 0), 0).r;\n     pos.y=texelFetch(iChannel0, ivec2(2,0), 0).r;\n    vec2 uv = fragCoord/iResolution.xy;\n    float aspectRatio = iResolution.x/iResolution.y;\n       uv.y = uv.y/aspectRatio;\n    vec2 Mouse = iMouse.xy/iResolution.xy;\n    float vAng = 50.0;\n    vec2 ppang=(uv-vec2(0.5,0.5))*vAng+(Mouse-0.5)*300.0;\n    //vec3 ang = normalize(vec3((Mouse.x-0.5)*2,sin(Mouse.x),cos(Mouse.x)));\n    \n    \n    \n    \n    \n    vec2 mo = iMouse.xy == vec2(0) ? vec2(.125) : \n              abs(iMouse.xy)/iResolution.xy - .5;\n    mo=mo*vec2(1.0,-5.0);\n    vec3 ro = vec3(.5+2.5*cos(1.5+6.*mo.x), 1.+2.*mo.y, -.5+2.5*sin(1.5+6.*mo.x));\n    \n    vec2 p = (-iResolution.xy + 2.*fragCoord - 1.)/iResolution.y;\n    vec3 ta = vec3(.5, -.4, -.5);\n    mat3 ca = setCamera(ro, ta, 0.);  \n    \n    vec3 rd = normalize((ca * normalize( vec3(p.xy,1.6) ))+vec3(rand(float(anti)+1.),rand(float(anti)+2.),rand(float(anti)+3.))/200.0);  \n    \n    \n    \n   // vec3 pos = vec3(1,5,0);\n    // Time varying pixel color\n    //vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    vec3 normal;\n    vec3 normal2;\n    vec3 normal3;\n    vec3 normal4;\n    vec4 pps = colide(pos,rd,normal);\n    vec3 position = pos +(rd*pps.z);\n    //float cola2 = iBox( pos, rd,vec2(.0001, 100),outNormal, vec3(.25));\n    if(pps.w==0.0){fragColor = vec4(getSkyColor(rd),1.0);}\n    else{\n    vec3  lig = normalize( vec3(-.4,.7,-.6) );\n    vec4 pps2 = colide(pos+(rd*(pps.z-0.0001)),lig,normal2);\n   \n    \n    vec3 normalR;\n    bool skyR;\n    float reflectivnesR;\n    float distR;\n    vec3 NewPosR;\n    vec3 NewRdR;\n    vec3 rCol;\n    \n    float rad;\n    if(pps.w!=2.0)\n        rad=Bluriness[int(pps.w)-1];\n    else{\n    \n        float a = (1.0-checker(position.xz * 5.0))/20.0+0.01;\n        rad=a;\n        }\n    \n    if(Reflections){\n    if(rad>0.0&&softReflection){\n    if(Reflectivness[int(pps.w)-1]>0.0)\n            for(int i=0;i<samples;i++){\n                float randi =float(i)+distR+reflectivnesR;\n                vec3 blured = normalize(rd+vec3((rand(randi)-0.5)*rad,(rand(randi+1.0)-0.5)*rad,(rand(randi+2.0)-0.5)*rad));\n                rCol = rCol+reflec(normal,pos,blured,pps.z,lig,normalR,skyR,reflectivnesR,distR,NewPosR,NewRdR);\n            }\n        rCol=rCol/float(samples);\n    }\n    else\n    rCol=reflec(normal,pos,rd,pps.z,lig,normalR,skyR,reflectivnesR,distR,NewPosR,NewRdR);\n    }\n    \n   // vec3 normalR2;\n   // bool skyR2;\n   // float reflectivnesR2;\n   // float distR2;\n   // vec3 NewPosR2;\n   // vec3 NewRdR2;\n   // vec3 rCol2 = reflec(normalR,NewPosR,NewRdR,distR,lig,normalR2,skyR2,reflectivnesR2,distR2,NewPosR2,NewRdR2);\n    \n    vec3 Col;\n\n    \n    \n        \n    if(pps2.w!=0.0&&pps2.w!=pps.w&&shadows)\n    Col = colors[int(pps.w)-1]/2.0;\n    else\n    Col = colors[int(pps.w)-1];\n    \n    Col=Col*shade(normal,lig);\n    if(!Reflections)\n        rCol=Col;\n    \n    if(pps.w!=2.0)\n        fragColor = vec4(mix(Col,rCol,Reflectivness[int(pps.w)-1]),1.0);\n    else{\n    \n        float a = checker(position.xz * 5.0)/2.0+0.3;\n        float a2 = checker(position.xz * 5.0)/2.0+1.0;\n        fragColor = vec4(mix(Col,rCol,a)/a2,1.0);\n        }\n        \n        \n }\n fragColorOut = fragColorOut+fragColor;\n }\n fragColorOut=fragColorOut/float(aniAliasingSamples);\n if(srgb)\n fragColorOut.rgb = encodeSRGB(fragColorOut.rgb);\n    //fragColor = vec4(normal,1.0);\n    \n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"const int KEY_LEFT  = 37;\nconst int KEY_UP    = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN  = 40;\n\nconst int UP    = 32;\nconst int DOWN  = 90;\n\nconst float speed = 1.0;\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    float outData = 0.0;\n    \n    switch(int(fragCoord.x)) {\n        case 0:\n        \toutData = texelFetch(iChannel0, ivec2(0), 0).r +\n                (iTimeDelta * speed) * texelFetch(iChannel1, ivec2(KEY_RIGHT, 0), 0).r -\n                (iTimeDelta * speed) * texelFetch(iChannel1, ivec2(KEY_LEFT, 0), 0).r;\n        \tbreak;\n        \n        case 1:\n        \toutData = texelFetch(iChannel0, ivec2(1, 0), 0).r -\n                (iTimeDelta * speed) * texelFetch(iChannel1, ivec2(KEY_UP, 0), 0).r+\n        \t\t(iTimeDelta * speed) * texelFetch(iChannel1, ivec2(KEY_DOWN, 0), 0).r;\n        \tbreak;\n         case 2:\n        \toutData = texelFetch(iChannel0, ivec2(2, 0), 0).r +\n                (iTimeDelta * speed) * texelFetch(iChannel1, ivec2(UP, 0), 0).r -\n        \t\t(iTimeDelta * speed) * texelFetch(iChannel1, ivec2(DOWN, 0), 0).r;\n        \tbreak;\n    }\n    \n    if(outData==0.0){\n        if(int(fragCoord.x)==0)\n        outData=-1.0;\n        \n        if(int(fragCoord.x)==1)\n        outData=2.0;\n        if(int(fragCoord.x)==2)\n        outData=0.55;\n        }\n    fragColor = vec4(outData, 0.0, 0.0, 1.0);\n}","name":"Buffer A","description":"","type":"buffer"}]}