{"ver":"0.1","info":{"id":"ws33Ws","date":"1583280362","viewed":318,"name":"Triangle Noise","username":"iaian7","description":"Simple procedural noise combined with a triangular UV sample.","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["procedural","geometry","screensaver"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float Perlin3D( vec3 P )\n{\n\t//  https://github.com/BrianSharpe/Wombat/blob/master/Perlin3D.glsl\n\n\t// establish our grid cell and unit position\n\tvec3 Pi = floor(P);\n\tvec3 Pf = P - Pi;\n\tvec3 Pf_min1 = Pf - 1.0;\n\n\t// clamp the domain\n\tPi.xyz = Pi.xyz - floor(Pi.xyz * ( 1.0 / 69.0 )) * 69.0;\n\tvec3 Pi_inc1 = step( Pi, vec3( 69.0 - 1.5 ) ) * ( Pi + 1.0 );\n\n\t// calculate the hash\n\tvec4 Pt = vec4( Pi.xy, Pi_inc1.xy ) + vec2( 50.0, 161.0 ).xyxy;\n\tPt *= Pt;\n\tPt = Pt.xzxz * Pt.yyww;\n\tconst vec3 SOMELARGEFLOATS = vec3( 635.298681, 682.357502, 668.926525 );\n\tconst vec3 ZINC = vec3( 48.500388, 65.294118, 63.934599 );\n\tvec3 lowz_mod = vec3( 1.0 / ( SOMELARGEFLOATS + Pi.zzz * ZINC ) );\n\tvec3 highz_mod = vec3( 1.0 / ( SOMELARGEFLOATS + Pi_inc1.zzz * ZINC ) );\n\tvec4 hashx0 = fract( Pt * lowz_mod.xxxx );\n\tvec4 hashx1 = fract( Pt * highz_mod.xxxx );\n\tvec4 hashy0 = fract( Pt * lowz_mod.yyyy );\n\tvec4 hashy1 = fract( Pt * highz_mod.yyyy );\n\tvec4 hashz0 = fract( Pt * lowz_mod.zzzz );\n\tvec4 hashz1 = fract( Pt * highz_mod.zzzz );\n\n\t// calculate the gradients\n\tvec4 grad_x0 = hashx0 - 0.49999;\n\tvec4 grad_y0 = hashy0 - 0.49999;\n\tvec4 grad_z0 = hashz0 - 0.49999;\n\tvec4 grad_x1 = hashx1 - 0.49999;\n\tvec4 grad_y1 = hashy1 - 0.49999;\n\tvec4 grad_z1 = hashz1 - 0.49999;\n\tvec4 grad_results_0 = inversesqrt( grad_x0 * grad_x0 + grad_y0 * grad_y0 + grad_z0 * grad_z0 ) * ( vec2( Pf.x, Pf_min1.x ).xyxy * grad_x0 + vec2( Pf.y, Pf_min1.y ).xxyy * grad_y0 + Pf.zzzz * grad_z0 );\n\tvec4 grad_results_1 = inversesqrt( grad_x1 * grad_x1 + grad_y1 * grad_y1 + grad_z1 * grad_z1 ) * ( vec2( Pf.x, Pf_min1.x ).xyxy * grad_x1 + vec2( Pf.y, Pf_min1.y ).xxyy * grad_y1 + Pf_min1.zzzz * grad_z1 );\n\n\t// Classic Perlin Interpolation\n\tvec3 blend = Pf * Pf * Pf * (Pf * (Pf * 6.0 - 15.0) + 10.0);\n\tvec4 res0 = mix( grad_results_0, grad_results_1, blend.z );\n\tvec4 blend2 = vec4( blend.xy, vec2( 1.0 - blend.xy ) );\n\tfloat final = dot( res0, blend2.zxzx * blend2.wwyy );\n\treturn ( final * 1.1547005383792515290182975610039 );  // scale things to a strict -1.0->1.0 range  *= 1.0/sqrt(0.75)\n}\n\n\nvec2 rotate2( vec2 xy, float r ) {\n\tvec2 ab = xy;\n\tab.x = xy.x * cos(r) - xy.y * sin(r);\n\tab.y = xy.y * cos(r) + xy.x * sin(r);\n\treturn ab;\n}\n\nfloat Screen(float a, float b) {\n\treturn 1.0 - ((1.0 - a) * (1.0 - b));\n}\n\nvec2 Rotate(vec2 xy, float angle){\n\treturn vec2(xy.x*cos(angle) - xy.y*sin(angle), xy.x*sin(angle) + xy.y*cos(angle));\n}\n\nvec2 Triangle(vec2 uv, float c){\n\tfloat r = 0.5235988;\n\tvec2 o = uv;\n\to.x = floor(uv.x * c + 0.5);\n\to.y = mix(floor(Rotate(uv * c + 0.5, r).y), floor(Rotate(uv * c + 0.5, -r).y), 0.5);\n//\to.y /= cos(0.5235988);\n//\to.y /= 0.86602539158;\n\to.y *= 1.154700555; // This shifts the Y channel back into a -0.5 to +0.5 range, otherwise scrolling the pattern actually changes the output range as well\n\treturn o / c;\n}\n\nvec2 TriangleUV(vec2 uv, float c, float r, float s){\n\tuv = Rotate(uv, r);\n\t// Fix alignment (based on the pre-rendered lines)\n\t// uv.x += (1.0/c)*0.25;\n\t// uv.y -= 0.01;\n\t// Larger numbers (over 10k) hit major issues with value rounding.\n\t// Scrolling needs to be within a much smaller range, so this is designed for a 0-1 loop.\n\t// The magic number scales the scrolling value to a compatible loop point.\n\tuv.y += s;// * 1.154700555;\n\tuv = Triangle(uv, c);\n\t// Invert the vertical scroll so the output UV values remain static, just the pattern scrolls\n\tuv.y -= s;// * 1.154700555;\n\tuv = Rotate(uv, -r);\n\tuv += 0.5;\n\n\treturn uv;\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord)\n{\n\tfragColor = vec4((fragCoord/iResolution.xy).rg, 0.5, 1); // This is the default UV output\n\n\t// Declare variables (these were all dynamic inputs in the Quartz composition)\n\tfloat Time = iTime;\n\tfloat Scroll = 0.0125;\n\tfloat Depth = 0.25;\n\tfloat Rotation = -0.7854;\n\tfloat Contrast = 0.2;\n\tfloat NoiseSpeed = 1.0;\n\tvec4 Color1 = vec4(0.07451, 0.09022, 0.2471, 1.0); // Background\n\tvec4 Color2 = vec4(0.1804, 0.1922, 0.4942, 1.0); // Foreground\n\n\t// Process UV map\n\tvec2 uv = fragCoord.xy * 0.00025; // This sets a fixed resolution for the texture patterns instead of being screen dependent\n\n\t// Create triangular noise pattern (initial magic number for the scale = 11.0)\n\t// float n1 = smoothstep(-Contrast, Contrast, Perlin3D(vec3(TriangleUV(uv, 11.0, Rotation, Time * Scroll)*10.0, Time * NoiseSpeed)));\n\t// float n2 = smoothstep(-Contrast, Contrast, Perlin3D(vec3(TriangleUV(uv*2.0+vec2(10.0, 10.0), 11.0, Rotation, Time * Scroll)*10.0, Time * NoiseSpeed)));\n\t// n1 = mix(n1, n2, 0.5);\n\tfloat n1 = Perlin3D(vec3(TriangleUV(uv, 11.0, Rotation, Time * Scroll)*10.0, Time * NoiseSpeed));\n\tfloat n2 = Perlin3D(vec3(TriangleUV(uv*2.0+vec2(10.0, 10.0), 11.0, Rotation, Time * Scroll)*10.0, Time * NoiseSpeed));\n\tn1 = clamp((n1+n2)*0.5+0.5, 0.0, 1.0);\n\n\t// Final output\n\tfragColor = mix(Color1, Color2, n1);\n}","name":"Image","description":"","type":"image"}]}