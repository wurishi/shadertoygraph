{"ver":"0.1","info":{"id":"fdcBWS","date":"1657139762","viewed":140,"name":"Ray Tracing Light Line","username":"NeilMonday","description":"Ray tracing something like a fluorescent light.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raytracing","light"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float MAX_T = 999999999999.9;\nconst int PLANES_COUNT = 10;\nconst int LIGHTS_COUNT = 10;\n\nstruct Plane {\n    vec3 v [3];\n} planes[PLANES_COUNT];\n\nstruct Light {\n    vec3 v [2];\n} lights[LIGHTS_COUNT];\n    \nstruct Result {\n    vec3 n;\n    float t;\n};\n\nResult intersectTriangle(vec3 origin, vec3 direction)\n{\n    Result result;\n    result.t = MAX_T;\n    \n    for(int i = 0; i<PLANES_COUNT; i++)\n    {\n        vec3 new_normal = normalize(cross(vec3(planes[i].v[1] - planes[i].v[0]), -vec3(planes[i].v[0] - planes[i].v[2])));\n\n        //Ray: P = o + t * d;\n        //Plane: Ax + By + Cz + D = 0\n        //A(o.x + t*d.x) + B(o.y + t*d.y) + C(o.z + t*d.z) + D = 0\n        //A*t*d.x + B*t*d.y + C*t*d.z + A*o.x + B*o.y + C*o.z + D = 0\n        //t * (A*d.x + B*d.y + C*d.z) + A*o.x + B*o.y + C*o.z + D = 0\n\n        //D = -Ax - By - Cz;\n        float a = new_normal.x;\n        float b = new_normal.y;\n        float c = new_normal.z;\n        float D = -a*planes[i].v[0].x - b*planes[i].v[0].y - c*planes[i].v[0].z;\n        float new_t = -(a*origin.x + b*origin.y + c*origin.z + D) / \n            (a*direction.x + b*direction.y + c*direction.z);\n\n        // P is where the ray intersects with the plane\n        bool test0 = false;\n        bool test1 = false;\n        bool test2 = false;\n        vec3 C;\n        vec3 P = vec3(origin) + new_t * vec3(direction);\n\n        //checking if its in the triangle\n        {\n            C = P - vec3(planes[i].v[0]);\n            test0 = dot(new_normal, cross(vec3(planes[i].v[1] - planes[i].v[0]), C)) > 0.0;\n        }\n        {\n            C = P - vec3(planes[i].v[1]);\n            test1 = dot(new_normal, cross(vec3(planes[i].v[2] - planes[i].v[1]), C)) > 0.0;\n        }\n        {\n            C = P - vec3(planes[i].v[2]);\n            test2 = dot(new_normal, cross(vec3(planes[i].v[0] - planes[i].v[2]), C)) > 0.0;\n        }\n\n        // if point P is outside of the triangle, then go onto the next triangle\n        if ((test0 && test1 && test2) &&\n            (0.0 < new_t) &&\n            (new_t < result.t))\n        {\n            result.n = new_normal;\n            result.t = new_t;\n        }\n    }\n    return result;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //bottom\n    planes[0].v[0] =  vec3(-100.1, 0.0, -100.1);\n    planes[0].v[1] =  vec3(100.1, 0.0, -100.1);\n    planes[0].v[2] =  vec3(100.1, 0.0, 100.1);\n    \n    planes[1].v[0] =  vec3(-100.1, 0.0, -100.1);\n    planes[1].v[1] =  vec3(100.1, 0.0, 100.1);\n    planes[1].v[2] =  vec3(-100.1, 0.0, 100.1);\n\n    //back\n    planes[2].v[0] =  vec3(-100.1, 0.0, 100.1);\n    planes[2].v[1] =  vec3(100.1, 0.0, 100.1);\n    planes[2].v[2] =  vec3(100.1, 200.2, 100.1);\n    \n    planes[3].v[0] =  vec3(-100.1, 0.0, 100.1);\n    planes[3].v[1] =  vec3(100.1, 200.2, 100.1);\n    planes[3].v[2] =  vec3(-100.1, 200.2, 100.1);\n    \n    //right\n    planes[4].v[0] =  vec3(100.1, 0.0, 100.1);\n    planes[4].v[1] =  vec3(100.1, 0.0, -100.1);\n    planes[4].v[2] =  vec3(100.1, 200.2, -100.1);\n    \n    planes[5].v[0] =  vec3(100.1, 0.0, 100.1);\n    planes[5].v[1] =  vec3(100.1, 200.2, -100.1);\n    planes[5].v[2] =  vec3(100.1, 200.2, 100.1);\n    \n    //left\n    planes[6].v[0] =  vec3(-100.1, 0.0, 100.1);\n    planes[6].v[1] =  vec3(-100.1, 200.2, -100.1);\n    planes[6].v[2] =  vec3(-100.1, 0.0, -100.1);\n    \n    planes[7].v[0] =  vec3(-100.1, 0.0, 100.1);\n    planes[7].v[1] =  vec3(-100.1, 200.2, 100.1);\n    planes[7].v[2] =  vec3(-100.1, 200.2, -100.1);\n    \n    //top\n    planes[8].v[0] =  vec3(-100.1, 200.2,100.1);\n    planes[8].v[1] =  vec3(100.1, 200.2, 100.1);\n    planes[8].v[2] =  vec3(100.1, 200.2, -100.1);\n    \n    planes[9].v[0] =  vec3(-100.1, 200.2, 100.1);\n    planes[9].v[1] =  vec3(100.1, 200.2, -100.1);\n    planes[9].v[2] =  vec3(-100.1, 200.2, -100.1);\n    \n    lights[0].v[0] = vec3(-80.0, 190.0, 0.0);\n    lights[0].v[1] = vec3( 80.0, 190.0, 0.0);\n    \n    float PI = 3.14159;\n    \n    vec3 A = lights[0].v[0];\n    vec3 B = lights[0].v[1];\n    \n    //camera point\n    vec3 C = vec3(0.0, 100.0, -500.0);\n    \n    //build up our initial rays from camera\n    vec2 screenCoord = (((2.0*fragCoord.xy)-iResolution.xy)/iResolution.x);\n    vec3 direction = vec3(screenCoord * 40.0 + vec2(0.0, 100.0), -400.0) - C;\n    vec3 origin = C;\n    \n    Result result = intersectTriangle(origin, direction);\n    float t = result.t;\n    vec3 normal = result.n;\n    \n    // find the point where rays intersect triangles\n    vec3 P = origin + t * direction;\n    \n    //the power of the light\n    float power = 2000000000.0;\n    \n    //float representing the magnitude of the projection of P onto AB line segment\n    float h = dot((P-A), (B-A))/(length(B-A)*length(B-A));\n    \n    //Q represents the point in 3D space at position h\n    vec3 Q = mix(A, B, h);\n    \n    //total light arriving at the camera\n    float d = 0.0;\n    \n   \n    //Sample the light several times\n    for(float i = 0.0; i<=1.0; i+=0.01)\n    {\n        //S is our sample point\n        vec3 S = mix(A, B, i);\n        \n        //calculate falloff from incident angle\n        float falloff = dot(normalize(P-S), normal);\n        \n        //the numerator is the cos of the angle that the light segment is relative to P \n        float numerator = power * ((dot(P-S, P-Q)/(length(P-S)*length(P-Q)))/(PI/2.0));\n        \n        //the denominator is the sphere equation to figure out how much light falls off due to distance\n        float denominator = (4.0 * PI * (length(P-S)*length(P-S)));\n        \n        d += (numerator / denominator) * falloff;\n    }\n    \n    \n    //falloff between surface and camera\n    d = d / (4.0 * PI * (length(P-C) * length(P-C)));\n        \n    vec3 col = vec3(0.0);\n    \n    //HDR\n    const float gamma = 2.2;\n    float hdrColor = d;\n    const float exposure = 5.0;\n    float mapped = 1.0 - exp(-hdrColor * exposure);\n    mapped = pow(mapped, 1.0 / gamma);\n    col = vec3(mapped);\n\n    // Output to screen\n    fragColor = vec4(col, 0.0);\n}\n","name":"Image","description":"","type":"image"}]}