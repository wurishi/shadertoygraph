{"ver":"0.1","info":{"id":"tst3zM","date":"1568127054","viewed":213,"name":"Fake Azimuthal Equidistant","username":"skye_adaire","description":"This is an interesting view of the hyperboloid model of hyperbolic space that is similar to azimuthal equidistant projection. See my other shaders for more background.","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["fake","projection","hyperbolic","hyperboloid","azimuthal","equidistant"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//created by Skye Adaire\n\n#define tau32 6.2831853072\n#define eps32 1e-10\n\n//begin Ray\n\n//return the first positive solution along the ray\nbool solveQuadraticIntersection(float a, float b, float c, out float t)\n{\n    if(abs(a) < eps32)\n    {\n        t = -c / b;\n        return t > 0.0;\n    }\n\n\tfloat discriminant = b * b - 4.0 * a * c;\n\n    if(abs(discriminant) < eps32)\n    {\n        t = - b / (2.0 * a);\n        return true;\n    }\n    else if(discriminant < 0.0)\n    {\n        return false;\n    }\n    else\n\t{\n        float sqrtd = sqrt(discriminant);\n\n        float t0 = (-b + sqrtd) / (2.0 * a);\n        float t1 = (-b - sqrtd) / (2.0 * a);\n\n        if(t1 < t0)\n        {\n            float tt = t0;\n            t0 = t1;\n            t1 = tt;\n        }\n\n        if(t0 > 0.0)\n        {\n            t = t0;\n            return true;\n        }\n\n        if(t1 > 0.0)\n        {\n            t = t1;\n            return true;\n        }\n\n        return false;\n\t}\n}\n\n//the hyperplane centered at the origin with normal 0,0,1\nbool intersectHyperplane(vec3 rayPosition, vec3 rayDirection, out float t)\n{\n    t = -rayPosition[2] / rayDirection[2];\n\n    return t > 0.0 && !isinf(t);\n}\n\nbool intersectHypersphere(\n    vec2 rayPosition,\n    vec2 rayDirection,\n    vec2 center,\n    float radius,\n    out float t)\n{\n    float a = dot(rayDirection, rayDirection);\n    float b = 2.0 * (dot(rayDirection, rayPosition) - dot(rayDirection, center));\n    float c = dot(rayPosition, rayPosition) - 2.0 * dot(rayPosition, center) + dot(center, center) - radius * radius;\n\n    return solveQuadraticIntersection(a, b, c, t);\n}\n\nfloat hdot(vec3 a, vec3 b)\n{\n    return a[0] * b[0] + a[1] * b[1] - a[2] * b[2];\n}\n\nbool intersectHypercone(vec3 rayPosition, vec3 rayDirection, float hyperness, out float t)\n{\n    float a = hdot(rayDirection, rayDirection);\n    float b = 2.0 * hdot(rayDirection, rayPosition);\n    float c = hdot(rayPosition, rayPosition) + hyperness;\n\n    return solveQuadraticIntersection(a, b, c, t);\n}\n\nbool intersectEllipticHyperboloid(vec3 rayPosition, vec3 rayDirection, out float t)\n{\n    return intersectHypercone(rayPosition, rayDirection, +1.0, t);\n}\n\n//end Ray\n\n//begin Hypercomplex\n\n#define Real float\n\nReal H_conjugate(Real r)\n{\n    return r;\n}\n\nReal H_add(Real lhs, Real rhs)\n{\n    return lhs + rhs;\n}\n\nReal H_subtract(Real lhs, Real rhs)\n{\n    return lhs - rhs;\n}\n\nReal H_multiply(Real lhs, Real rhs)\n{\n    return lhs * rhs;\n}\n\n#define Complex vec2\n\nComplex H_conjugate(Complex h)\n{\n    return Complex(h[0], -h[1]);\n}\n\nReal H_sqnorm(Complex h)\n{\n    return dot(h, h);\n}\n\nReal H_norm(Complex h)\n{\n    return length(h);\n}\n\nComplex H_multiply(Complex lhs, Complex rhs)\n{\n    Real lhs_0 = lhs[0];\n    Real lhs_1 = lhs[1];\n    Real rhs_0 = rhs[0];\n    Real rhs_1 = rhs[1];\n\n    return Complex(\n        H_subtract(H_multiply(lhs_0, rhs_0), H_multiply(H_conjugate(rhs_1), lhs_1)),\n        H_add(H_multiply(rhs_1, lhs_0), H_multiply(lhs_1, H_conjugate(rhs_0))));\n}\n\nComplex H_divide(Complex lhs, Complex rhs)\n{\n    return H_multiply(lhs, H_conjugate(rhs)) / H_sqnorm(rhs);\n}\n\nReal H_argument(Complex h)\n{\n   return atan(h[1], h[0]);//[-pi, pi]\n}\n\nComplex H_versor(Real angle)\n{\n    return Complex(cos(angle), sin(angle));\n}\n\nstruct PolarComplex\n{\n    float norm;\n    float argument;\n};\n\nPolarComplex H_toPolar(Complex h)\n{\n    return PolarComplex(H_norm(h), H_argument(h));\n}\n\n//end Hypercomplex\n\n//column-major and complex-valued \n#define ComplexMatrix2 mat4x2\n\nComplexMatrix2 identityMob = ComplexMatrix2(1,0, 0,0, 0,0, 1,0); \n\n//inverse of mobius transform with det 1\nComplexMatrix2 M_inverse(ComplexMatrix2 m)\n{\n    return ComplexMatrix2(m[3], -m[1], -m[2], m[0]); \n}\n\nComplexMatrix2 M_multiply(ComplexMatrix2 lhs, ComplexMatrix2 rhs)\n{\n    return ComplexMatrix2(\n        H_multiply(lhs[0], rhs[0]) + H_multiply(lhs[2], rhs[1]),\n        H_multiply(lhs[1], rhs[0]) + H_multiply(lhs[3], rhs[1]),\n        H_multiply(lhs[0], rhs[2]) + H_multiply(lhs[2], rhs[3]),\n        H_multiply(lhs[1], rhs[2]) + H_multiply(lhs[3], rhs[3]));\n}\n\n//complex-valued homogeneous transform\nComplex M_multiply(ComplexMatrix2 m, Complex z)\n{\t\n    return H_divide(H_multiply(m[0], z) + m[2], H_multiply(m[1], z) + m[3]);\n}\n\n//returns the mob mapping z0 -> 0, z1 -> 1, z2 -> inf\nComplexMatrix2 M_mapTripleTo01I(Complex z0, Complex z1, Complex z2)\n{\n    return ComplexMatrix2(\n        z0 - z2,\n        z0 - z1,\n        H_multiply(-z1, z0 - z2),\n        H_multiply(-z2, z0 - z1));\n}\n \n//uses the cross ratio to construct the mob taking the ordered triple a,b,c -> p,q,r\nComplexMatrix2 M_mapTripleToTriple(\n    Complex a, Complex b, Complex c, \n\tComplex p, Complex q, Complex r)\n{\n\treturn M_multiply(M_inverse(M_mapTripleTo01I(p, q, r)), M_mapTripleTo01I(a, b, c));\n}\n\n//mob taking  [-1, 0, 1] to [L, c, R]\nComplexMatrix2 M_mapRealsToLine(Complex L, Complex c, Complex R)\n{\n    return M_mapTripleToTriple(\n        Complex(-1, 0), Complex(0, 0), Complex(1, 0),\n        L, c, R);\n}\n\n//the euclidean rotation of the plane is an isometry of the disk\nComplexMatrix2 M_rotation(Real a)\n{\n    return ComplexMatrix2(H_versor(0.5 * a), Complex(0, 0), Complex(0, 0), H_versor(-0.5 * a));\n}\n\nComplexMatrix2 M_translateReals(Real t)\n{\n    Real ex = exp(t);\n    Complex exp1 = Complex(ex + 1.0, 0);\n    Complex exm1 = Complex(ex - 1.0, 0);\n    \n    return ComplexMatrix2(exp1, exm1, exm1, exp1);\n}\n\nComplexMatrix2 M_translateDisk(vec2 v)\n{\n    PolarComplex p = H_toPolar(v);\n    ComplexMatrix2 r = M_rotation(p.argument);\n    return M_multiply(r, M_multiply(M_translateReals(p.norm), M_inverse(r)));\n}\n\nstruct Circle\n{\n \tComplex center;\n    Real radius;\n};\n\nCircle M_getCircleBetweenDiskPoints(Complex p, Complex q)\n{\n    Real dp = H_sqnorm(p) + 1.0;\n    Real dq = H_sqnorm(q) + 1.0;\n    Real dpq = 2.0 * (p[0] * q[1] - p[1] * q[0]);\n    Complex center = Complex(q[1] * dp - p[1] * dq, -q[0] * dp + p[0] * dq) / dpq;\n\n    return Circle(center, sqrt(H_sqnorm(center) - 1.0));\n}\n\nComplexMatrix2 M_getIdealLine(Complex i0, Complex i1)\n{\n \tCircle c = M_getCircleBetweenDiskPoints(i0, i1);\n    vec2 d = normalize(c.center);\n    \n    float t;\n    intersectHypersphere(vec2(0), d, c.center, c.radius, t);\n    \n    return M_mapRealsToLine(i0, t * d, i1);\n}\n\n//a tile is constructed from half planes\n//the union of these half planes is the fundamental domain\n//we reflect the point about half planes until it is in the domain\nvec2 getPoincareTiling(\n    ComplexMatrix2 transformFromA, ComplexMatrix2 transformToA, \n    ComplexMatrix2 transformFromB, ComplexMatrix2 transformToB, \n    ComplexMatrix2 transformFromC, ComplexMatrix2 transformToC, \n    vec2 z, out vec3 d)\n{\n   for(int i = 0; i < 60; i++)\n   {\n      vec2 t;\n       \n      t = M_multiply(transformToA, z);\n\n      d[0] = abs(t.y);\n\n      if(t.y < 0.0)\n      {\n         t = H_conjugate(t);\n         z = M_multiply(transformFromA, t);\n         continue;\n      }\n       \n      t = M_multiply(transformToB, z);\n\n      d[1] = abs(t.y);\n\n      if(t.y < 0.0)\n      {\n         t = H_conjugate(t);\n         z = M_multiply(transformFromB, t);\n         continue;\n      }\n       \n      t = M_multiply(transformToC, z);\n\n      d[2] = abs(t.y);\n\n      if(t.y < 0.0)\n      {\n         t = H_conjugate(t);\n         z = M_multiply(transformFromC, t);\n         continue;\n      }\n\n      //the point is in the fundamental domain\n      break;\n   }\n\n   return z;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float aspectRatio = iResolution.x / iResolution.y;\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 clip = uv * 2.0 - 1.0;\n    vec2 unitSpacePosition = 0.5 * clip;\n    vec2 ratioSpacePosition = vec2(aspectRatio, 1) * unitSpacePosition;\n    vec2 fcc = ratioSpacePosition * 12.5;\n\n    //view basis\n    mat3 viewTransform = mat3(1.0);\n    vec3 viewPosition = viewTransform * vec3(0, 0, 20);\n    vec3 viewRight = viewTransform * vec3(1, 0, 0);\n    vec3 viewUp = viewTransform * vec3(0, 1, 0);\n    vec3 viewForward = viewTransform * vec3(0, 0, -1);\n    \n    //view ray\n    vec3 frustumPoint = viewPosition - viewForward;\n    vec3 srp =\n       viewPosition +\n       viewRight * fcc.x +\n       viewUp * fcc.y;\n    vec3 srd = viewForward;\n    \n    //intersect the screen ray\n    float t;\n    vec3 color = vec3(0);\n    \n    if(intersectEllipticHyperboloid(srp, srd, t))\n    {\n    \tvec3 position = srp + t * srd;\n        vec3 pole = position.z > 0.0 ? vec3(0,0,-1) : vec3(0,0,1);\n        \n        vec3 rp = position;\n        vec3 rd = normalize(pole - rp);\n        \n        intersectHyperplane(rp, rd, t);//must hit\n        \n      \tposition = rp + t * rd;\n       \n        vec2 z = position.xy;\n        \n        //this transform moves us around \n        //transformation could also be done by complex matrix composition, just like view matrices in R3\n        //since this is a fully proceedural shader, I recompute the translation each frame\n        float time = iTime * 0.2;\n        ComplexMatrix2 translation = M_translateDisk(4.0 * vec2(cos(0.5*time), 0.1*sin(time)));\n        z = M_multiply(translation, z);\n         \n        //these transforms comprise the fundamental domain of the tiling\n        ComplexMatrix2 transformFromA = identityMob;\n        ComplexMatrix2 transformToA = M_inverse(transformFromA);\n\n        float angleB = tau32 / 8.0;\n        Complex versorB = H_versor(angleB);\n        ComplexMatrix2 transformFromB = M_mapRealsToLine(versorB, Complex(0,0), -versorB);\n        ComplexMatrix2 transformToB = M_inverse(transformFromB);\n\n        ComplexMatrix2 transformFromC = M_getIdealLine(H_versor(-0.852), H_versor(0.852));\n        ComplexMatrix2 transformToC = M_inverse(transformFromC);\n\n        vec3 distances;\n        z = getPoincareTiling(\n            transformFromA, transformToA,\n            transformFromB, transformToB,\n            transformFromC, transformToC,\n            z, distances);\n\n        distances = vec3(1) - distances;\n        distances = pow(distances, vec3(30.0));\n\n        color = distances;\n    }\n    \n    fragColor = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"}]}