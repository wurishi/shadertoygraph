{"ver":"0.1","info":{"id":"tljGWK","date":"1561282949","viewed":668,"name":" Physically based rendering Test","username":"tuananhlfc","description":"Taking the idea from https://www.shadertoy.com/view/XlKSDR due to the well-structure.\nSome code is given by https://github.com/google/filament\nDemo metallic, roughness, clear coat model. Uncomment/comment line 4 to enable/unenable clear coat","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["pbr"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define saturate(x) clamp(x, 0.0, 1.0)\n#define PI 3.14159265359\n#define MEDIUMP_FLT_MIN    0.00006103515625\n#define MEDIUMP_FLT_MAX    65504.0\n#define saturateMediump(x) min(x, MEDIUMP_FLT_MAX)\n\n#define MATERIAL_HAS_CLEAR_COAT 1\n// Diffuse BRDFs\n#define DIFFUSE_LAMBERT             0\n#define DIFFUSE_BURLEY              1\n\n#define BRDF_DIFFUSE                DIFFUSE_LAMBERT\n\n// Fresnel functions\n#define SPECULAR_F_SCHLICK          0\n\n#define BRDF_CLEAR_COAT_D           SPECULAR_D_GGX\n#define BRDF_CLEAR_COAT_V           SPECULAR_V_KELEMEN\n\n// data types \n// follow structure of Filament\nstruct Light {\n    vec4 colorIntensity;  // rgb, pre-exposed intensity\n    vec3 l;\n    float attenuation;\n    float NoL;\n};\n\nstruct PixelParams {\n    vec3  diffuseColor;\n    float perceptualRoughness;\n    vec3  f0;\n    float roughness;\n    vec3  dfg;\n    vec3  energyCompensation;\n\n#if defined(MATERIAL_HAS_CLEAR_COAT)\n    float clearCoat;\n    float clearCoatPerceptualRoughness;\n    float clearCoatRoughness;\n#endif\n\n#if defined(MATERIAL_HAS_ANISOTROPY)\n    vec3  anisotropicT;\n    vec3  anisotropicB;\n    float anisotropy;\n#endif\n\n#if defined(SHADING_MODEL_SUBSURFACE)\n    float thickness;\n    vec3  subsurfaceColor;\n    float subsurfacePower;\n#endif\n\n#if defined(SHADING_MODEL_CLOTH) && defined(MATERIAL_HAS_SUBSURFACE_COLOR)\n    vec3  subsurfaceColor;\n#endif\n};\n\n//------------------------------------------------------------------------------\n// Distance field functions\n//------------------------------------------------------------------------------\n\nfloat sdPlane(in vec3 p) {\n    return p.y;\n}\n\nfloat sdSphere(in vec3 p, float s) {\n    return length(p) - s;\n}\n\nfloat sdTorus(in vec3 p, in vec2 t) {\n    return length(vec2(length(p.xz) - t.x, p.y)) - t.y;\n}\n\nvec2 opUnion(vec2 d1, vec2 d2) {\n    return d1.x < d2.x ? d1 : d2;\n}\n\nvec2 scene(in vec3 position) {\n    vec2 scene = opUnion(\n          vec2(sdPlane(position), 1.0),\n          vec2(sdSphere(position - vec3(0.0, 0.4, 0.0), 0.4), 12.0)\n    );\n    return scene;\n}\n\n//------------------------------------------------------------------------------\n// Ray casting\n//------------------------------------------------------------------------------\n\nfloat shadow(in vec3 origin, in vec3 direction) {\n    float hit = 1.0;\n    float t = 0.02;\n    \n    for (int i = 0; i < 1000; i++) {\n        float h = scene(origin + direction * t).x;\n        if (h < 0.001) return 0.0;\n        t += h;\n        hit = min(hit, 10.0 * h / t);\n        if (t >= 2.5) break;\n    }\n\n    return clamp(hit, 0.0, 1.0);\n}\n\nvec2 traceRay(in vec3 origin, in vec3 direction) {\n    float material = -1.0;\n\n    float t = 0.02;\n    \n    for (int i = 0; i < 1000; i++) {\n        vec2 hit = scene(origin + direction * t);\n        if (hit.x < 0.002 || t > 20.0) break;\n        t += hit.x;\n        material = hit.y;\n    }\n\n    if (t > 20.0) {\n        material = -1.0;\n    }\n\n    return vec2(t, material);\n}\n\nvec3 normal(in vec3 position) {\n    vec3 epsilon = vec3(0.001, 0.0, 0.0);\n    vec3 n = vec3(\n          scene(position + epsilon.xyy).x - scene(position - epsilon.xyy).x,\n          scene(position + epsilon.yxy).x - scene(position - epsilon.yxy).x,\n          scene(position + epsilon.yyx).x - scene(position - epsilon.yyx).x);\n    return normalize(n);\n}\n\n//------------------------------------------------------------------------------\n// BRDF\n//------------------------------------------------------------------------------\n\nfloat pow5(float x) {\n    float x2 = x * x;\n    return x2 * x2 * x;\n}\n\n\n\n//------------------------------------------------------------------------------\n// Indirect lighting\n//------------------------------------------------------------------------------\n\nvec3 Irradiance_SphericalHarmonics(const vec3 n) {\n    // Irradiance from \"Ditch River\" IBL (http://www.hdrlabs.com/sibl/archive.html)\n    return max(\n          vec3( 0.754554516862612,  0.748542953903366,  0.790921515418539)\n        + vec3(-0.083856548007422,  0.092533500963210,  0.322764661032516) * (n.y)\n        + vec3( 0.308152705331738,  0.366796330467391,  0.466698181299906) * (n.z)\n        + vec3(-0.188884931542396, -0.277402551592231, -0.377844212327557) * (n.x)\n        , 0.0);\n}\n\nvec2 PrefilteredDFG_Karis(float roughness, float NoV) {\n    // Karis 2014, \"Physically Based Material on Mobile\"\n    const vec4 c0 = vec4(-1.0, -0.0275, -0.572,  0.022);\n    const vec4 c1 = vec4( 1.0,  0.0425,  1.040, -0.040);\n\n    vec4 r = roughness * c0 + c1;\n    float a004 = min(r.x * r.x, exp2(-9.28 * NoV)) * r.x + r.y;\n\n    return vec2(-1.04, 1.04) * a004 + r.zw;\n}\n\n//------------------------------------------------------------------------------\n// Tone mapping and transfer functions\n//------------------------------------------------------------------------------\n\nvec3 Tonemap_ACES(const vec3 x) {\n    // Narkowicz 2015, \"ACES Filmic Tone Mapping Curve\"\n    const float a = 2.51;\n    const float b = 0.03;\n    const float c = 2.43;\n    const float d = 0.59;\n    const float e = 0.14;\n    return (x * (a * x + b)) / (x * (c * x + d) + e);\n}\n\nvec3 OECF_sRGBFast(const vec3 linear) {\n    return pow(linear, vec3(1.0 / 2.2));\n}\n\n\n//------------------------------------------------------------------------------\n// Shading model\n//------------------------------------------------------------------------------\n\n\n//------------------------------------------------------------------------------\n// Rendering\n//------------------------------------------------------------------------------\n\nfloat D_GGX(float NoH, float roughness) {\n    float a = NoH * roughness;\n    float k = roughness / (1.0 - NoH * NoH + a * a);\n    return k * k * (1.0 / PI);\n}\n\nvec3 F_Schlick(float VoH, vec3 f0) {\n    return f0 + (vec3(1.0) - f0) * pow(1.0 - VoH, 5.0);\n}\n\nfloat F_Schlick(float f0, float f90, float VoH) {\n    return f0 + (f90 - f0) * pow5(1.0 - VoH);\n}\n\nfloat V_SmithGGXCorrelated(float NoV, float NoL, float a) {\n    float a2 = a * a;\n    float GGXL = NoV * sqrt((-NoL * a2 + NoL) * NoL + a2);\n    float GGXV = NoL * sqrt((-NoV * a2 + NoV) * NoV + a2);\n    return 0.5 / (GGXV + GGXL);\n}\n\nfloat Fd_Burley(float linearRoughness, float NoV, float NoL, float LoH) {\n    float f90 = 0.5 + 2.0 * linearRoughness * LoH * LoH;\n    float lightScatter = F_Schlick(1.0, f90, NoL);\n    float viewScatter  = F_Schlick(1.0, f90, NoV);\n    return lightScatter * viewScatter * (1.0 / PI);\n}\n\nfloat Fd_Lambert() {\n    return 1.0 / PI;\n}\n\nfloat distribution(float roughness, float NoH, const vec3 h) {\n    return D_GGX(roughness, NoH);\n}\n\nfloat visibility(float roughness, float NoV, float NoL, float LoH) {\n    return V_SmithGGXCorrelated(roughness, NoV, NoL);\n}\n\nfloat diffuse(float roughness, float NoV, float NoL, float LoH) {\n#if BRDF_DIFFUSE == DIFFUSE_LAMBERT\n    return Fd_Lambert();\n#elif BRDF_DIFFUSE == DIFFUSE_BURLEY\n    return Fd_Burley(roughness, NoV, NoL, LoH);\n#endif\n}\n\nvec3 isotropicLobe(const PixelParams pixel, const Light light, const vec3 h,\n        float NoV, float NoL, float NoH, float LoH) {\n\n    float D = D_GGX(NoH, pixel.roughness);\n    vec3 F = F_Schlick(LoH, pixel.f0);\n    float V = V_SmithGGXCorrelated(NoV, NoL, pixel.roughness);\n\n    return (D * V) * F;\n}\n\nvec3 specularLobe(const PixelParams pixel, const Light light, const vec3 h,\n        float NoV, float NoL, float NoH, float LoH) {\n#if defined(MATERIAL_HAS_ANISOTROPY)\n    return anisotropicLobe(pixel, light, h, NoV, NoL, NoH, LoH);\n#else\n    return isotropicLobe(pixel, light, h, NoV, NoL, NoH, LoH);\n#endif\n}\n\nvec3 diffuseLobe(const PixelParams pixel, float NoV, float NoL, float LoH) {\n    return pixel.diffuseColor * diffuse(pixel.roughness, NoV, NoL, LoH);\n}\n\nfloat V_Kelemen(float LoH) {\n    return saturateMediump(0.25 / (LoH * LoH));\n}\n\n\nvec3 surfaceShading(const PixelParams pixel, const Light light, vec3 v, vec3 n) {\n    vec3 h = normalize(v + light.l);\n    \n    float NoV = abs(dot(n, v)) + 1e-5;\n    float NoL = clamp(dot(n, light.l), 0.0, 1.0);\n    float NoH = clamp(dot(n, h), 0.0, 1.0);\n    float LoH = clamp(dot(light.l, h), 0.0, 1.0);\n    \n    vec3 Fr = specularLobe(pixel, light, h, NoV, NoL, NoH, LoH);\n    vec3 Fd = diffuseLobe(pixel, NoV, NoL, LoH);\n    vec3 color = Fd + Fr;\n    \n    // clear coat model, on progress\n    // remapping and linearization of clear coat roughness\n#if defined(MATERIAL_HAS_CLEAR_COAT)    \n    float clearCoatPerceptualRoughness = 0.0;\n    float clearCoat = 1.0;\n    clearCoatPerceptualRoughness = mix(0.089, 0.6, clearCoatPerceptualRoughness);\n    float clearCoatRoughness = clearCoatPerceptualRoughness * clearCoatPerceptualRoughness;\n\n    // clear coat BRDF\n    float  Dc = D_GGX(clearCoatRoughness, NoH);\n    float  Vc = V_Kelemen(LoH);\n    float  Fc = F_Schlick(0.04, 1.0, LoH) * clearCoat; // clear coat strength\n    float Frc = (Dc * Vc) * Fc;\n\n    // account for energy loss in the base layer\n    color = (Fd + Fr) + Frc;\n#endif\t\n    return color;\n}\n\nvec3 render(in vec3 origin, in vec3 direction, out float distance) {\n    // Sky gradient\n    vec3 color = vec3(0.65, 0.85, 1.0) + direction.y * 0.72;\n\n    // (distance, material)\n    vec2 hit = traceRay(origin, direction);\n    distance = hit.x;\n    float material = hit.y;\n\n    // We've hit something in the scene\n    vec3 position = origin + distance * direction;\n    \n    // vector input\n    PixelParams pixel;\n    Light light;\n    light.l = vec3(0.6, 0.7, -0.7);\n    vec3 v = normalize(-direction);\n    vec3 n = normal(position);\n    //vec3 h = normalize(v + l);\n    \n    //float NoV = abs(dot(n, v)) + 1e-5;\n    float NoL = clamp(dot(n, light.l), 0.0, 1.0);\n    \n    vec3 baseColor = vec3(0.0);\n    //float perceptualRoughness = 0.0;\n    float metallic = 1.0;\n    \n    float intensity = 2.0;\n    light.colorIntensity = vec4(2.0);\n    \n    if (material < 4.0) {\n        //return vec3(0.65, 0.85, 1.0);\n        float f = mod(floor(6.0 * position.z) + floor(6.0 * position.x), 3.0);\n        //return f;\n        return 0.4 + f * vec3(0.6);\n        //pixel.perceptualRoughness = 0.1;\n    } else if (material < 16.0) {\n        // Metallic objects\n        baseColor = vec3(0.7, 0.0, 0.0);\n        pixel.perceptualRoughness = 0.8;\n        \n        // remap base color\n    \tpixel.diffuseColor = (1.0 - metallic) * baseColor; \n    \t// Reflectance remapping\n    \tfloat reflectance = 0.5;\n    \tpixel.f0 = 0.16 * reflectance * reflectance * (1.0 - metallic) + baseColor * metallic;\n    \t//pixel.f0 = 0.04 * (1.0 - metallic) + baseColor.rgb * metallic;\n    \t// Roughness remapping and clamping\n    \tpixel.roughness = pixel.perceptualRoughness * pixel.perceptualRoughness;\n    \n    \tfloat attenuation = shadow(position, light.l);\n    \n    \t// brdf function\n    \tcolor = surfaceShading(pixel, light, v, n);\n    \t//color = Fd + Fr;\n    \t//color *= (intensity * attenuation * NoL) * vec3(0.98, 0.92, 0.89);\n\n    \treturn color;\n    }\n    \n    \n}\n\n//------------------------------------------------------------------------------\n// Setup and execution\n//------------------------------------------------------------------------------\n\nmat3 setCamera(in vec3 origin, in vec3 target, float rotation) {\n    vec3 forward = normalize(target - origin);\n    vec3 orientation = vec3(sin(rotation), cos(rotation), 0.0);\n    vec3 left = normalize(cross(forward, orientation));\n    vec3 up = normalize(cross(left, forward));\n    return mat3(left, up, forward);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Normalized coordinates\n    vec2 p = -1.0 + 2.0 * fragCoord.xy / iResolution.xy;\n    // Aspect ratio\n    p.x *= iResolution.x / iResolution.y;\n\n    // Camera position and \"look at\"\n    vec3 origin = vec3(0.3, 2.0, 0.3);\n    vec3 target = vec3(0.0);\n\n    //origin.x += cos(iTime * 0.2);\n    //origin.z += sin(iTime * 0.2);\n\n    mat3 toWorld = setCamera(origin, target, 0.0);\n    vec3 direction = toWorld * normalize(vec3(p.xy, 2.0));\n\n    // Render scene\n    float distance;\n    vec3 color = render(origin, direction, distance);\n\n    // Tone mapping\n    color = Tonemap_ACES(color);\n\n    // Exponential distance fog\n    color = mix(color, 0.8 * vec3(0.7, 0.8, 1.0), 1.0 - exp2(-0.011 * distance * distance));\n\n    // Gamma compression\n    color = OECF_sRGBFast(color);\n\n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}