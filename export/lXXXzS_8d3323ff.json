{"ver":"0.1","info":{"id":"lXXXzS","date":"1709652550","viewed":791,"name":"Cheap Turbulence","username":"Xor","description":"Simulating proper fluid dynamics can be complicated. Sometimes, you just want to emulate some smoke or something simple, and you don't want to go through all that trouble. Here's my technique for cheaply faking it","likes":66,"published":1,"flags":0,"usePreview":0,"tags":["2d","simple","fluid","turbulent"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n    \"Cheap Turbulence\" by @XorDev\n\n    Simulating proper fluid dynamics can be complicated and requires a back buffer or multi-pass setup.\n\n    Sometimes, you just want to emulate some smoke or something simple, and you don't want to go through all that trouble.\n\n    This method is very simple! Start with pixel coordinates and scale them down as desired, then with a for loop,\n    you should do a sine wave offset. In my case I'm doing \"p.x+=sin(p.y)\".\n    To animate it, you can add a time offset to the sine wave, and it also helps to shift each iteration with the\n    iterator \"i\" to break up visible patterns.\n\n    Next, you want to rotate the coordinates and scale down. It could be as simple as p=p.yx/0.8 or a rotation matrix like mat2(.8,-.6,.6,.8).\n\n    Now the resulting p coordinates will appear turbulent, and you can use these coordinates in color function.\n    My color equation looks like this:\n\n    fragColor=sin(p.xyxy*.3+vec4(0,1,2,3))*.5+.5\n    \n    Smooth, continious equations look best\n*/\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //Scaled pixel coordinates\n    vec2 p=fragCoord.xy/iResolution.y*6.;\n    \n    //8 wave passes\n    for(float i=0.0; i<8.0;i++)\n    {\n        //Add a simple sine wave with an offset and animation\n        p.x += sin(p.y+i+iTime*.3);\n        //Rotate and scale down\n        p *= mat2(6,-8,8,6)/8.;\n    }\n    //Pick a color using the turbulent coordinates\n    fragColor = sin(p.xyxy*.3+vec4(0,1,2,3))*.5+.5;\n}","name":"Image","description":"","type":"image"}]}