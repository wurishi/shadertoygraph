{"ver":"0.1","info":{"id":"XdXcW4","date":"1488131790","viewed":195,"name":"peacock monster2","username":"pde","description":"Here we have an IFS that generalises from the Julia set; and a plasma tiled out according to the distance covered  by a certain number of iterations of that map. Clicking and dragging alters the IFS parameters.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["plasma","ifs"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec2 cmult(vec2 a, vec2 b)\n{\n    vec2 c;\n    c.x = a.x * b.x - a.y * b.y;\n    c.y = a.x * b.y + a.y * b.x;\n    return c;\n}\n\nvec2 weirdmap(vec2 a, vec2 b, float exp)\n{\n    vec2 c;\n    c.x = a.x * b.x - pow(abs(a.y), abs(0.25 + exp));\n    c.y = a.x * b.y + a.y * b.x;\n    return c;\n}\n\nvec2 spacify(vec2 p)\n{\n    vec2 c = (p.xy / (iResolution.xy * 0.8)) - vec2(0.9, 0.6);\n\treturn c;\n}\n\nvec2 unspacify(vec2 p)\n{\n    vec2 screenPos;\n    screenPos.xy = p.xy + vec2(0.9, 0.6);\n    screenPos.xy *= iResolution.xy * 0.8;\n    return screenPos;\n}\n\n\nvec2 startwalk()\n{\n    vec2 z;\n    vec2 mouse = iMouse.xy;\n    clamp(mouse.x, 0.0, iResolution.x);\n    clamp(mouse.y, 0.0, iResolution.y);\n\n    z = 2.0 * spacify(mouse.xy);\n    z.x += 0.2 * sin(iTime*3.0) * cos(iTime * 0.22);\n    z.y += 0.2 * sin(iTime*2.0) * cos(iTime * 1.3);\n    return z;\n}\n\nfloat pi2 = 0.5 * 3.14159265359;\n\nfloat piecewise(float x)\n{\n\tif (x <= 2.0 ) return sin(x);\n    if (x <= 10.0) return sin(log(x));\n    return sin(log(log(x)));\n}\n\n\nvec3 hsv2rgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvec4 colour(vec2 start, vec2 end, int n)\n{\n    float g = piecewise(length(start - end));\n    //g -= float(floor(g));\n    float b = piecewise(length(spacify(iMouse.xy) - end)*2.0);\n    //b -= float(floor(g));\n    //float invsq = 1.0 / (length(start) * length(start));\n    /*float v = g;\n    float h = float(mod(float(n), 12.0))/12.0;\n    float s = b;\n    vec3 rgb = hsv2rgb(vec3(h,s,v));\n    return vec4(rgb[0], rgb[1], rgb[2], 1.0);*/\n    \n    return vec4(float(n)/64.0, g, b, 1.0);\n}\n\n\nvoid pdeMainImage(out vec4 fragColor, in vec2 fragCoord, out vec2 zplas )\n{\n\tvec2 c = spacify(fragCoord);\n   \n    vec2 c1 = c * 2.5;\n    vec2 c2 = c * (2.3 + 0.2 * sin(iTime));\n    float vert = 5.0*(iMouse.y / iResolution.y) + 0.4 * sin(iTime / 2.1);\n    \n    fragColor = vec4(1.0,0.0,0.0,1.0);\n    vec2 z = startwalk();\n    int i = 0;\n    vec2 z2;\n    zplas = z;\n    for (int n = 0; n < 64; n++) {\n        if (i == 0 && length(z) > 16.0) i = n;\n        if (n == 3) zplas = z;\n        /*if (n == 4 && length(z) > 2.0) zplas = z; \n        if (n == 5 && length(z) > 3.0) zplas = z;*/\n        if (n == 10) z2 = z;\n        z = weirdmap(z, z, vert) + c2;                \n    }\n    fragColor = colour(c1, z2, i);\n    \n\t//fragColor = vec4(uv,0.5+0.5*sin(iTime),1.0);\n}\n\n// PLASMA EFFECT\n//\n// We said that the a pixel's color only depends on its coordinates\n// and other inputs (such as time)\n// \n// There is an effect called Plasma, which is based on a mixture of\n// complex function in the form of f(x,y).\n//\n// Let's write a plasma!\n//\n// http://en.wikipedia.org/wiki/Plasma_effect\n\nfloat PI = 3.14;\n\nvec3 RotateVec3Z(vec3 v, float rad)\n{\n\tfloat cos = cos(rad);\n\tfloat sin = sin(rad);\n\t//if (RIGHT_HANDED_COORD)\n\treturn vec3(cos * v.x + sin * v.y, -sin * v.x + cos * v.y, v.z);\n}\n\nvec2 RotateVec2Z(vec2 v, float rad)\n{\n\tfloat cos = cos(rad);\n\tfloat sin = sin(rad);\n\t//if (RIGHT_HANDED_COORD)\n\treturn vec2(cos * v.x + sin * v.y, -sin * v.x + cos * v.y);\n}\n\nvoid daisyMainImage( out vec4 fragColor, in vec2 fragCoord, in vec2 zplas )\n{\n    fragCoord = unspacify(zplas);\n\tvec2 p = vec2(fragCoord.xy / iResolution.xy);\n\tvec2 r = 2.0*vec2(fragCoord.xy - 0.5*iResolution.xy)/iResolution.y;\n    r = RotateVec2Z(r, 0.5 * PI + iTime / 3.0);\n\n    float t = iTime;\n    r = r * 8.0;\n\t\n    float v1 = sin(r.x +t);\n    float v2 = sin(r.y +t);\n    float v3 = sin(r.x+r.y +t);\n    float v4 = sin(sqrt(r.x*r.x+r.y*r.y) + t);\n\tfloat v = v1+v2+v3+v4;\n\t\n\tvec3 ret;\n\t\t\n\t// mix colors\n\tv *= 1.0;\n\tret = vec3(sin(v), sin(v+0.5*PI), sin(v+1.0*PI));\n\t\n\tret = 0.5 + 0.5*ret;\n\t\n    vec3 pixel = ret;\n    fragColor = vec4(pixel, 1.);\n}\n\nfloat max4(vec4 a)\n{\n    return max(max(a.x, a.y), a.z);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 c1, c2, c3, shadow;\n    vec2 zplas;\n    pdeMainImage(c1, fragCoord, zplas);\n    daisyMainImage(c2, fragCoord, zplas);\n    c3 = vec4(0.0);\n    c3[0] = c2[0];\n    c3[1] = c2[1] * c1[1];\n    c3[2] = c2[2] * max4(c1);\n\t//fragColor = softmax(c1, c2);\n    fragColor = c3;\n    /*vec2 offset = spacify(fragCoord);\n    offset *= 1.2;\n    offset = unspacify(offset);\n    pdeMainImage(shadow, offset);    \n    fragColor = max(c3, 0.0 * shadow);*/\n}\n","name":"Image","description":"","type":"image"}]}