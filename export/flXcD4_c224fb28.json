{"ver":"0.1","info":{"id":"flXcD4","date":"1647978813","viewed":93,"name":"PhongMaterialsSph","username":"MelisaHot","description":"Multiple spheres with materials.\nFrom https://inspirnathan.com/posts/57-shadertoy-tutorial-part-11","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["phong","lighting","materials"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//https://www.shadertoy.com/user/inspirnathan/\nconst int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float PRECISION = 0.001;\n\nfloat sdSphere(vec3 p, float r )\n{\n  return length(p) - r;\n}\n\nstruct Material {\n  vec3 ambientColor; // k_a * i_a\n  vec3 diffuseColor; // k_d * i_d\n  vec3 specularColor; // k_s * i_s\n  float alpha; // shininess\n};\n\nstruct Surface {\n  int id; // id of object\n  float sd; // signed distance\n  Material mat;\n};\n\nMaterial gold() {\n  vec3 aCol = 0.5 * vec3(0.7, 0.5, 0);\n  vec3 dCol = 0.6 * vec3(0.7, 0.7, 0);\n  vec3 sCol = 0.6 * vec3(1, 1, 1);\n  float a = 5.;\n\n  return Material(aCol, dCol, sCol, a);\n}\n\nMaterial silver() {\n  vec3 aCol = 0.4 * vec3(0.8);\n  vec3 dCol = 0.5 * vec3(0.7);\n  vec3 sCol = 0.6 * vec3(1, 1, 1);\n  float a = 5.;\n\n  return Material(aCol, dCol, sCol, a);\n}\n\nMaterial checkerboard(vec3 p) {\n  vec3 aCol = vec3(1. + 0.7*mod(floor(p.x) + floor(p.z), 2.0)) * 0.3;\n  vec3 dCol = vec3(0.3);\n  vec3 sCol = vec3(0);\n  float a = 1.;\n\n  return Material(aCol, dCol, sCol, a);\n}\n\nSurface opUnion(Surface obj1, Surface obj2) {\n  if (obj2.sd < obj1.sd) return obj2;\n  return obj1;\n}\n\nSurface scene(vec3 p) {\n  Surface sFloor = Surface(1, p.y + 1., checkerboard(p));\n  Surface sSphereGold = Surface(2, sdSphere(p - vec3(-2, 0, 0), 1.), gold());\n  Surface sSphereSilver = Surface(2, sdSphere(p - vec3(2, 0, 0), 1.), silver());\n  \n  Surface co = opUnion(sFloor, sSphereGold); // closest object\n  co = opUnion(co, sSphereSilver);\n  return co;\n}\n\nSurface rayMarch(vec3 ro, vec3 rd) {\n  float depth = MIN_DIST;\n  Surface co;\n\n  for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n    vec3 p = ro + depth * rd;\n    co = scene(p);\n    depth += co.sd;\n    if (co.sd < PRECISION || depth > MAX_DIST) break;\n  }\n  \n  co.sd = depth;\n\n  return co;\n}\n\nvec3 calcNormal(vec3 p) {\n    vec2 e = vec2(1.0, -1.0) * 0.0005;\n    return normalize(\n      e.xyy * scene(p + e.xyy).sd +\n      e.yyx * scene(p + e.yyx).sd +\n      e.yxy * scene(p + e.yxy).sd +\n      e.xxx * scene(p + e.xxx).sd);\n}\n\nmat3 camera(vec3 cameraPos, vec3 lookAtPoint) {\n\tvec3 cd = normalize(lookAtPoint - cameraPos); // camera direction\n\tvec3 cr = normalize(cross(vec3(0, 1, 0), cd)); // camera right\n\tvec3 cu = normalize(cross(cd, cr)); // camera up\n\t\n\treturn mat3(-cr, cu, -cd);\n}\n\nvec3 phong(vec3 lightDir, vec3 normal, vec3 rd, Material mat) {\n  // ambient\n  vec3 ambient = mat.ambientColor;\n\n  // diffuse\n  float dotLN = clamp(dot(lightDir, normal), 0., 1.);\n  vec3 diffuse = mat.diffuseColor * dotLN;\n\n  // specular\n  float dotRV = clamp(dot(reflect(lightDir, normal), -rd), 0., 1.);\n  vec3 specular = mat.specularColor * pow(dotRV, mat.alpha);\n\n  return ambient + diffuse + specular;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n  vec3 backgroundColor = mix(vec3(1, .5, .3), vec3(0.6, 0.5, 1), uv.y) * 1.6;\n  vec3 col = vec3(0);\n\n  vec3 lp = vec3(0); // lookat point (aka camera target)\n  vec3 ro = vec3(0, 0, 5);\n\n  vec3 rd = camera(ro, lp) * normalize(vec3(uv, -1)); // ray direction\n\n  Surface co = rayMarch(ro, rd); // closest object\n  \n  if (co.sd > MAX_DIST) {\n    col = backgroundColor;\n  } else {\n      vec3 p = ro + rd * co.sd; // point on surface found by ray marching\n      vec3 normal = calcNormal(p); // surface normal\n\n      // light #1\n      vec3 lightPosition1 = vec3(-8, -6, -5);\n      vec3 lightDirection1 = normalize(lightPosition1 - p);\n      float lightIntensity1 = 0.9;\n      \n      // light #2\n      vec3 lightPosition2 = vec3(1, 1, 1);\n      vec3 lightDirection2 = normalize(lightPosition2 - p);\n      float lightIntensity2 = 0.5;\n\n      // final color of object\n      col = lightIntensity1 * phong(lightDirection1, normal, rd, co.mat);\n      col += lightIntensity2 * phong(lightDirection2, normal , rd, co.mat);\n  }\n\n  fragColor = vec4(col, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}