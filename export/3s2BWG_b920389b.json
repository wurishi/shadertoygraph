{"ver":"0.1","info":{"id":"3s2BWG","date":"1590726933","viewed":193,"name":"Lightning Menger Sponge","username":"TAKUSAKU","description":"Lightning Menger Sponge  Fold","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["lightning","fold","mengersponge"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define time iTime\n\nconst float PI = 3.14159265;\n\n// noise background is baced on 李明杰VIP:\n// https://www.shadertoy.com/view/4sVBDm\n// ---------------------------------------------------------------------\n\nconst float noiseIntensity = 2.8;\nconst float noiseDefinition = 0.6;\nconst vec2 glowPos = vec2(-2., 0.);\n\nfloat random(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(-0.950,-0.910))) * 43758.5453);\n}\n\nfloat noise( in vec2 p ){\n    p*=noiseIntensity;\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\tvec2 u = f*f*(3.0-2.0*f);\n    return mix( mix( random( i + vec2(0.0,0.0) ), \n                     random( i + vec2(1.0,0.0) ), u.x),\n                mix( random( i + vec2(0.0,1.0) ), \n                     random( i + vec2(1.0,1.0) ), u.x), u.y);\n}\n\nfloat fbm( in vec2 uv ){\t\n\tuv *= 5.0;\n    mat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );\n    float f  = 0.5*noise( uv ); uv = m*uv;\n    f += 5.*noise( uv ); uv = m*uv;\n    f += 5.*noise( uv ); uv = m*uv;    \n\tf = 0.1 + .5*f;\n    return f;\n}\n\nvec3 bg(vec2 uv ){\n    float velocity = time * 0.5;\n    float intensity = sin(uv.x*noise(uv)*7.+velocity*3.)*noise(uv*10.)*1.0+.3;\n    uv.y -= 2.;\n    vec2 bp = uv+glowPos;\n    uv *= noiseDefinition;\n\n    //ripple\n    float rb = fbm(vec2(uv.x*.5-velocity*.03, uv.y))*.1;\n    uv += rb;\n\n    //coloring\n    float rz = fbm(uv*.9+vec2(velocity*.35, 0.0));\n    rz *= dot(bp*intensity,bp);\n\n    //bazooca line\n    rz *= sin(uv.x*0.1+velocity*0.8);\n    \n    //lightning\n    rz *= 5.*sin(uv.x*0.1+velocity*sin(time));\n    \n    vec3 bgColor = vec3(cos(time),0.45 * sin(time*0.2),sin(time*0.3));\n    vec3 col = bgColor/(.1-rz);\n    return sqrt(abs(col));\n}\n\n// IFS MengerSponge based on gam0022.net\n// https://gam0022.net/blog/2019/06/25/unity-raymarching/\n// ---------------------------------------------------------------------\n#define ITERATIONS 4\n\nvec3 _MengerOffset = vec3(1.000,0.072,0.414);\nfloat _MengerScale = 2.9;\nfloat _MengerFold = 3.;\n\n// IFS MengerSponge　DistanceFunction\nfloat dMenger(vec3 z0, vec3 offset, float scale) {\n    vec4 z = vec4(z0, 1.0);\n    for (int n = 0; n < ITERATIONS; n++) {\n        z = abs(z);\n\n        if (z.x < z.y) z.xy = z.yx;\n        if (z.x < z.z) z.xz = z.zx;\n        if (z.y < z.z) z.yz = z.zy;\n\n        z *= scale;\n        z.xyz -= offset * (scale - 1.0);\n\n        if (z.z < -0.5 * offset.z * (scale - 1.0))\n            z.z += offset.z * (scale - 1.0);\n    }\n    return (length(max(abs(z.xyz) - vec3(1.0, 1.0, 1.0), 0.0)) - 0.05) / z.w;\n}\n\n// 2D rotate\nmat2 rotate(in float a) {\n    float s = sin(a), c = cos(a);\n    return mat2(c, s, -s, c);\n}\n\n// Deformation used folding\n// https://www.shadertoy.com/view/Mlf3Wj\nvec2 foldRotate(in vec2 p, in float s) {\n    float a = PI / s - atan(p.x, p.y);\n    float n = PI*2. / s;\n    a = floor(a / n) * n;\n    p *= rotate(a);\n    return p;\n}\n\n// Final DistanceFunction\nfloat map(vec3 pos) {\n    pos.xy = foldRotate(pos.xy, _MengerFold);\n    pos.yz = foldRotate(pos.yz, _MengerFold);\n    return dMenger(pos, _MengerOffset, _MengerScale);\n}\n\n// Normal\nvec3 getNormal(vec3 p){\n    const vec2 e = vec2(0.001, 0.0);\n\treturn normalize(vec3(\n\t\tmap(p + e.xyy) - map(p - e.xyy),\n\t\tmap(p + e.yxy) - map(p - e.yxy),\n\t\tmap(p + e.yyx) - map(p - e.yyx)));\n}\n// ---------------------------------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n    vec2 uv = (fragCoord.xy * 2.0 - iResolution.xy) / iResolution.y;// background\n    \n    // camera\n    float pscale = 1.0 + 0.85*cos(time*0.5);\n    vec3 cPos = vec3(pscale*cos(time*0.5), 0.0, pscale*sin(time*0.5));\n    vec3 cDir = vec3(1.*sin(time*0.5+PI*1.5), 0.0, -1.*cos(time*0.5+PI*1.5));\n    vec3 cUp  = vec3(0.0, 1.0, 0.0);\n    vec3 cSide = cross(cDir, cUp);\n    float targetDepth = 1.0;\n     \n    // ray\n    vec3 rPos = cPos;// cPos = ray origin\n    vec3 rd = normalize(cSide * p.x + cUp * p.y + cDir * targetDepth);// ray direction\n    \n    // marching loop\n    float dist = 0.0;\n    float rLen = 0.0;\n    for(int i = 0; i < 42; i++){\n        dist = map(rPos);\n        rLen += dist;\n        rPos = cPos + rd * rLen;\n    }\n    \n    //color\n    vec3 color = vec3(0.0);\n    vec3 bgCol = bg(p)*(2.-abs(uv.y*2.));// background color\n    \n    // hit check\n    if(abs(dist) < 0.001){\n        vec3 normal = getNormal(rPos);\n        vec3 refDir = reflect(rd, normal);// reflect direction\n        float refInt = max(0.0, dot(refDir, vec3(0.279,0.284,0.315)));// reflect Intensity\n        vec3 refCol = 30.0*pow(refInt, 1.5)*(vec3(0.285,0.230,0.211));// reflect color\n        color = mix(bgCol, refCol, 0.5);\n        color = mix(color, refDir, 0.1);\n    }else{\n        color = bg(p*rotate(PI*0.5))*bgCol*0.1;\n    }\n    \n\tfragColor = vec4(mix(bgCol, color, 0.65-0.5*(sin(cos(time*0.5-150.))-0.2)), 1.0);\n}","name":"Image","description":"","type":"image"}]}