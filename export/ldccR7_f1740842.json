{"ver":"0.1","info":{"id":"ldccR7","date":"1518187889","viewed":260,"name":"Parallel God Rays","username":"geckobike","description":"Messing around with parallel God Rays.\nAll the rays are exactly parallel. Demonstrates how perspective works and makes them appear to radiate in different directions from a cloud\n","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["godrays","crepuscular"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.141592\n#define deg_to_radian(x) ((x) * 3.141592 / 180.0)\n#define sqr(x) ((x)*(x))\n\n// A low level cloud might be around 2000m above ground\nfloat god_ray_height = 2000.0;\n// Distance from (initial) eye position to cloud along the ground\nfloat horiz_dist_to_god_ray = 2000.0;\n\n// eye field of view angle\nfloat FOV = deg_to_radian(65.0);\n\n// Change the speed the camera is animated by\nfloat CAM_TIME_SPEED = 1.0;\n\n// Set this between 0.0 and 1.0 to override the position of the camera\nfloat CAM_OVERRIDE_TIME = -1.0;\n\n// Set this to override the camera position (Y is up, Z is forward)\nvec3 CAM_OVERRIDE_POS = vec3(0.0,0.0,0.0);\n\n// camera vectors\nvec3 eye = vec3(0.0);\nvec3 dir = vec3(0.0,0.0,1.0);\nvec3 cam_forward;\nvec3 cam_right;\nvec3 cam_up;\n\nvoid SetupCamera(vec3 eyepos, vec3 lookat)\n{\n    eye = eyepos;\n    cam_forward = normalize(lookat - eye);\n    cam_right = normalize(cross(vec3(0.0,1.0,0.0), cam_forward));\n    cam_up = normalize(cross(cam_forward, cam_right));\n}\n\nfloat distbetweenTwoLines(vec3 start1, vec3 dir1, vec3 start2, vec3 dir2, float length2, inout vec3 p2)\n{\n    // Returns distance between and inifinite long ray\n    // starting at start1 with direction dir1,\n    // and a line starting at start2 with direction dir2, and length length2\n   \n\tvec3 n = normalize(cross(dir1, dir2));\n\tvec3 n1 = normalize(cross(n,dir1));\n\tvec3 n2 = normalize(cross(n,dir2));\n    \n    // t position along ray1\n\tfloat t1 = dot(start2-start1,n2)/dot(dir1,n2);\n    t1 = max(0.0, t1);\n    \n    // t position along ray2\n\tfloat t2 = dot(start1-start2,n1)/dot(dir2,n1);\n    // clamp t2\n    t2 = clamp(t2,0.0,length2);\n    \n    // Length between the two positions\n    vec3 p1 = start1 + dir1 * t1;\n    p2 = start2 + dir2 * t2;\n    return length(p1-p2);\n}\n\nvec3 GodRayDir(float time)\n{\n\t// animate the angle of the sun from (vertical) 0.0 to 70.0\n\tfloat god_ray_angle = deg_to_radian(70.0*sin(0.2*iTime)*sin(0.2*iTime));\n    vec3 god_dir = normalize(vec3(0.0,-cos(god_ray_angle),-sin(god_ray_angle)));\n    return god_dir;\n}\n\nfloat godray(vec3 eye, vec3 dir)\n{\n    vec3 god_dir = GodRayDir(iTime);\n    \n    float d = 100000.0;\n    \n    // ALL GOD RAYS HAVE THE **SAME** DIRECTION\n    for (float zoffset = 0.0; zoffset <= 600.0; zoffset += 300.0)\n    {\n    \tfor (float xpos = -1000.0; xpos <= 1000.0; xpos += 500.0)\n\t    {\n            vec3 godrayStartPos = vec3(xpos, god_ray_height, horiz_dist_to_god_ray + zoffset);\n            vec3 p2;\n            d = min(d, distbetweenTwoLines(eye, dir, godrayStartPos, god_dir, 4000.0, p2));\n    \t}\n    }\n    return d;\n}\n\n\nvec3 SkyAndSun()\n{\n    vec3 sky = (0.9+0.2*dir.y) * vec3(0.65,0.8,1.0);\n    vec3 light = GodRayDir(iTime);\n    float sun = max(0.0, -dot(dir,light));\n    sky += 0.8*pow(sun,12000.0) * (vec3(1.0,1.0,0.0) - 0.2*sky);\n    sky += 0.3*pow(sun,10.0) * (vec3(1.0,1.0,1.0) - 0.7*sky);\n    return sky;\n}\n\nfloat HalfSphere(vec3 p, vec3 centre, float r)\n{\n    p = p - centre;\n\treturn -min(p.y,-(length(p*vec3(1.0,2.0,1.0))-r));\n}\n\nfloat cloud(vec3 eye, vec3 dir)\n{\n    vec3 pos0 = vec3(-890.0, god_ray_height, horiz_dist_to_god_ray+200.0);\n    vec3 pos1 = vec3(-300.0, god_ray_height, horiz_dist_to_god_ray+200.0);\n    vec3 pos2 = vec3(+300.0, god_ray_height, horiz_dist_to_god_ray+200.0);\n    vec3 pos3 = vec3(+900.0, god_ray_height, horiz_dist_to_god_ray+200.0);\n    \n    float d = 100000.0;\n    vec3 p = eye;\n    for (int repeat = 0; repeat<20; repeat++)\n    {\n    \td = min(d, HalfSphere(p, pos0, 350.0));\n    \td = min(d, HalfSphere(p, pos1, 390.0));\n    \td = min(d, HalfSphere(p, pos2, 450.0));\n    \td = min(d, HalfSphere(p, pos3, 350.0));\n   \t\tp = p + dir * d*0.5;\n    }\n    return d;\n}\n\nfloat ParallelLines(vec3 start, vec3 delta, int count, vec3 linedir, float size)\n{\n\tfloat d = 10000.0;\n   \tfloat d2 = 10000.0;\n\tvec3 p2;\n    \n    for (int n = 0; n<count; n++)\n    {\n    \tfloat dcur = distbetweenTwoLines(eye, dir, start, linedir, size, p2);\n        if (dcur < d)\n        {\n            d = dcur;\n\t\t\t// Make the lines look the same width at different distances from the eye\n        \td2 = d / (length(p2 - eye)+1.0);\n        }\n        start += delta;\n    }\n    return d2;\n}\n\nfloat FloorGrid()\n{\n    float floorSize = 2000.0*0.5;\n    float floorStep = 2000.0*0.25*0.5;\n    int count = 9;\n    float d1 = ParallelLines(vec3(-floorSize,0.0,0.0), vec3(floorStep,0.0,0.0), count, vec3(0.0,0.0,1.0), 2.0*floorSize);\n    float d2 = ParallelLines(vec3(-floorSize,0.0,0.0), vec3(0.0,0.0,floorStep), count, vec3(1.0,0.0,0.0), 2.0*floorSize);\n    return min(d1,d2);\n}\n\nfloat SideGrid(float xpos)\n{\n    float gridSize = 2000.0*0.5;\n    float gridStep = 2000.0*0.25*0.5;\n    int count = 9;\n    float d1 = ParallelLines(vec3(xpos,0.0,0.0), vec3(0.0,gridStep,0.0), count, vec3(0.0,0.0,1.0), 2.0*gridSize);\n    float d2 = ParallelLines(vec3(xpos,0.0,0.0), vec3(0.0,0.0,gridStep), count, vec3(0.0,1.0,0.0), 2.0*gridSize);\n    return min(d1,d2);\n}\n\nfloat FarGrid()\n{\n    float gridSize = 2000.0*0.5;\n    float gridStep = 2000.0*0.25*0.5;\n    int count = 9;\n    float d1 = ParallelLines(vec3(-gridSize,0.0,gridSize*2.0), vec3(0.0,gridStep,0.0), count, vec3(1.0,0.0,0.0), 2.0*gridSize);\n    float d2 = ParallelLines(vec3(-gridSize,0.0,gridSize*2.0), vec3(gridStep,0.0,0.0), count, vec3(0.0,1.0,0.0), 2.0*gridSize);\n    return min(d1,d2);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized X pixel coordinates (from -1 to +1)\n    vec2 uv = (fragCoord/iResolution.xy*2.0 - 1.0);\n    uv.y *= (iResolution.y/iResolution.x);\n\n    // Setup the animated camera to look at a point ~ half\n    // way between the cloud and the ground\n    vec3 lookatpos = vec3(0.0,0.8*god_ray_height,horiz_dist_to_god_ray);\n    float camTime = clamp((1.4*(fract(0.1+iTime*0.03*CAM_TIME_SPEED))-0.25), 0.0, 1.0);\n    camTime = (CAM_OVERRIDE_TIME>=0.0 && CAM_OVERRIDE_TIME<=1.0) ? CAM_OVERRIDE_TIME : camTime;\n    float camX = -1.2 * horiz_dist_to_god_ray * sin(2.0*camTime*PI*0.5);\n    float camZ = horiz_dist_to_god_ray * (0.8 - 0.8*cos(2.0*camTime*PI*0.5));\n    float camHeight = 0.9*camTime*god_ray_height;\n    vec3 EyePos = length(CAM_OVERRIDE_POS)>0.0 ? CAM_OVERRIDE_POS : vec3(camX,10.0 + camHeight,camZ);\n    SetupCamera(EyePos, lookatpos);\n    float cam_scale = tan(FOV);\n    \n    // direction for each pixel\n\tdir = normalize(cam_forward + (uv.x * cam_right + uv.y * cam_up) * cam_scale);\n    \n    // Basic sky colour with sun\n    vec3 col = SkyAndSun();\n\n\t// Add the god rays\n\tfloat g = 1.0 - pow(smoothstep(0.0, 1.0, godray(eye, dir)/50.0),0.3);\n    col += vec3(1.0, 1.0, 1.0)*g*0.2;\n    g = 1.0 - pow(smoothstep(0.0, 1.0, godray(eye, dir)/150.0),0.7);\n    col += (vec3(2.0, 1.8, 0.0)-0.5*col) * g * 0.15;\n\n    // Add the grid, repeat twice with hlaf pixel offset to anti-alias the lines\n    float dist = 10000.0;\n    for (int repeat=0; repeat<2; repeat++)\n    {\n    \tdist = min(dist,FloorGrid());\n    \tdist = min(dist, SideGrid(-1000.0));\n    \tdist = min(dist, SideGrid(+1000.0));\n    \tdist = min(dist, FarGrid());\n        dir = normalize(dir + (cam_right*0.5/iResolution.x+cam_up*0.5/iResolution.y)*cam_scale);\n    }\n    col += vec3(0.3)* pow(smoothstep(0.003,0.0,dist),0.3);\n    \n    // Add the cloud\n    float cloudDist = cloud(eye,dir);\n    vec3 cloudCol = vec3(0.0);\n    cloudCol += vec3(0.3,0.3,0.3) * (1.0 - smoothstep(0.0,1.0,cloudDist/450.0));\n    cloudCol += vec3(0.7,0.7,0.7) * (1.0 - smoothstep(0.0,1.0,cloudDist/490.0));\n    col = mix(cloudCol, col, 0.9*smoothstep(0.0,300.0,cloudDist));\n    \n \t// Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}