{"ver":"0.1","info":{"id":"WsyGz1","date":"1569963095","viewed":140,"name":"spiky torus knot","username":"arifr123","description":"spiky torus knot using a torus knot estimated signed distance function.\n","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","torusknot"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.1415926535897932384626433832795\n\nfloat fOverDerF(float t, vec3 p)\n{\n    \n\tfloat sint = sin(t);\n    float cost = cos(t);\n    \n    float sin2t = 2.0*sint*cost;//sin(2.0*t);\n    float cos2t = cost*cost - sint*sint;//cos(2.0*t);\n    \n    float sin4t = 2.0*sin2t*cos2t;//sin(4.0*t);\n    \n    float sin3t = sin(3.0*t);\n    float cos2tSq = cos2t*cos2t;\n    float cos3t = cos(3.0*t);\n    \n    return (2.0*p.x*sint + p.x*sin2t + 2.0*p.x*sin4t - 3.0*p.y*cos3t - 2.0*p.z*cost - 4.0*p.z*cos2tSq + p.z*cos2t + 2.0*p.z - 6.0*sin3t)/(2.0*p.x*cost + 16.0*p.x*cos2tSq + 2.0*p.x*cos2t - 8.0*p.x + 9.0*p.y*sin3t + 2.0*p.z*sint - 2.0*p.z*sin2t + 8.0*p.z*sin4t - 16.0*cos2tSq*cos2t + 12.0*cos2t - 18.0*cos3t + 4.0*cos(6.0*t));\n\t\n    \n    //return (2.0*p.x*sin(t) + p.x*sin(2.0*t) + 2.0*p.x*sin(4.0*t) - 3.0*p.y*cos(3.0*t) - 2.0*p.z*cos(t) - 4.0*p.z*pow(cos(2.0*t), 2.0) + p.z*cos(2.0*t) + 2.0*p.z - 6.0*sin(3.0*t))/(2.0*p.x*cos(t) + 16.0*p.x*pow(cos(2.0*t), 2.0) + 2.0*p.x*cos(2.0*t) - 8.0*p.x + 9.0*p.y*sin(3.0*t) + 2.0*p.z*sin(t) - 2.0*p.z*sin(2.0*t) + 8.0*p.z*sin(4.0*t) - 16.0*pow(cos(2.0*t), 3.0) + 12.0*cos(2.0*t) - 18.0*cos(3.0*t) + 4.0*cos(6.0*t));\n}\n\nvec3 torusKnot(float t)\n{\n    return vec3((cos(3.0*t) + 2.0)*cos(t), sin(3.0*t), (cos(3.0*t) + 2.0)*sin(t));\n}\nvec3 torusKnotDer(float t)\n{\n    return vec3(sin(t)*(-(cos(3.*t) + 2.)) - 3.*sin(3.*t)*cos(t), 3.*cos(3.*t), cos(t)*(cos(3.*t) + 2.) - 3.*sin(t)*sin(3.*t));\n}\n\nfloat lengthSq(vec3 p)\n{\n    return dot(p, p);\n}\n\nfloat oldTorusKnotDist(vec3 p, out vec3 closestPoint)\n{\n    int samplePointsNum = 12;\n    \n    float jump = 2.0 * PI / float(samplePointsNum);\n    \n    float minDistSq = -1.0;\n    float minT;\n    \n    for(int i = 0; i < samplePointsNum; i++)\n    {\n        float cT = jump * float(i);\n        \n        cT -= fOverDerF(cT, p);\n        \n        float cDistSq = lengthSq(torusKnot(cT) - p);\n        \n        if(minDistSq == -1.0 || cDistSq < minDistSq)\n        {\n            minDistSq = cDistSq;\n            minT = cT;\n        }\n    }\n\n    minT -= fOverDerF(minT, p);\n    \n    \n    closestPoint = torusKnot(minT);\n    \n    return distance(closestPoint, p);\n}\n\n\nvec2 cMult(vec2 a, vec2 b)\n{\n    return vec2(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x);\n}\nvec2 cPow(vec2 a, int n)\n{\n    vec2 r = vec2(1, 0);\n    for(int i = 0; i < n; i++)\n    {\n        r = cMult(r, a);\n    }\n    \n    return r;\n}\n\nfloat torusDist(vec3 p, out vec3 closestPoint, float r1, float r2)\n{\n    float d = sqrt(pow(p.y, 2.0) + pow(length(p.xz) - r1, 2.0));\n    \n    closestPoint = p;\n    closestPoint.xz -= p.xz * r1 / length(p.xz);\n    closestPoint *= r2 / d;\n    closestPoint.xz += p.xz * r1 / length(p.xz);\n    \n    return d - r2;\n}\nfloat fastTorusKnotDist(vec3 p, out vec3 closestPoint, int n, float r1)\n{\n    vec2 pa = normalize(p.xz);\n    vec2 rot = cPow(pa, n);\n    p.xz -= pa * rot.x;\n    p.y -= rot.y;\n    \n    float d = torusDist(p, closestPoint, r1, 0.);\n    \n    closestPoint.xz += pa * rot.x;\n    closestPoint.y += rot.y;\n    \n    return d;\n}\n\nfloat pulse(float x, float a, float b)\n{\n    return pow(1./(pow(abs(x), a) + 1.), b);\n}\n\nfloat getT(vec3 closestPoint)\n{\n    return atan(closestPoint.z, closestPoint.x);\n}\nfloat getS(float t, vec3 p, vec3 closestPoint)\n{\n    vec3 normal = vec3(cos(3.0*t)*cos(t), sin(3.0*t), cos(3.0*t)*sin(t));\n    vec3 cpToP = normalize(p - closestPoint);\n    \n    float angle = acos(clamp(dot(normal, cpToP), -1., 1.));\n    \n    \n    float angSign = sign(dot(cross(normal, cpToP), torusKnotDer(t)));\n    \n    return angle * angSign;\n}\n\nfloat getBumps(vec3 p, vec3 lastClosestCurvePoint)\n{\n    float t = getT(lastClosestCurvePoint);\n    float s = getS(t, p, lastClosestCurvePoint);\n\n    float time = -2.*0.3*iTime;\n\n\n    float bump = PI / 24.;\n\n    float modT = t + bump + time;\n\n    modT = mod(modT, 2.*bump);\n\n    modT -= bump;\n\n\n    modT *= 10.;\n    s *= 2.;\n\n\n    return 0.5 * (cos(3.*t)+1.) * exp(-modT*modT -s*s);\n}\n\nfloat spikyTorusKnotDist(vec3 p, out vec3 closestPoint)\n{\n    float tnd = oldTorusKnotDist(p, closestPoint) - 0.5;\n    //float tnd = fastTorusKnotDist(p, closestPoint, 3, 2.) - 0.75;\n    \n    return tnd - getBumps(p, closestPoint);\n}\n\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xx - (iResolution.xy/iResolution.xx)/2.0;\n    \n    float time = 0.1 * iTime;\n    \n    \n    float az = (2.*PI*time);\n    float po = PI/2. * sin(2.*PI*time);\n    \n    \n    vec3 camera = vec3(cos(po) * cos(az), sin(po), cos(po) * sin(az));\n    vec3 cz = -camera;\n    vec3 cy = vec3(sin(-po) * cos(az), cos(-po), sin(-po) * sin(az));\n    vec3 cx = cross(cy, cz);\n    camera *= 14.;\n\n    float zoom = 1.;\n    \n    \n    \n    \n    vec3 sp = normalize(uv.x * cx + uv.y * cy + zoom * cz);\n    \n    vec3 p = camera;\n    \n    float hitDistance = 0.2;\n    \n    \n    vec3 lastClosestCurvePoint;\n    float totalDist = 0.0;\n    float lastDist = -1.0;\n    for(int i = 0; i < 30; i++)//30\n    {\n        p += sp * lastDist;\n        \n        lastDist = spikyTorusKnotDist(p, lastClosestCurvePoint);\n        \n        //lastDist *= 0.35;\n        \n        \n        totalDist += lastDist;\n        \n        //if(lastDist < 0.2)break;\n    }\n    \n    totalDist -= 9.;\n    \n    vec3 col = (4./(totalDist*totalDist) + 0.2) * mix(hsv2rgb(vec3(time + 0.5, 1, 1)), hsv2rgb(vec3(time, 1, 1)), getBumps(p, lastClosestCurvePoint));\n\n    col *= smoothstep(0.2, 0., lastDist);\n\n    fragColor = vec4(col,1.0);\n}\n","name":"Image","description":"","type":"image"}]}