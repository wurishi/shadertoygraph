{"ver":"0.1","info":{"id":"WlSfRd","date":"1599639622","viewed":185,"name":"trying path tracing","username":"acnologia","description":"my effort on ray tracing after seeing many examples","likes":8,"published":1,"flags":32,"usePreview":0,"tags":["raytracing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(texture(iChannel0,fragCoord/iResolution.xy));\n} ","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"/*\nReference\n - https://www.shadertoy.com/view/tsBBWW\n - https://www.shadertoy.com/view/4dBXWw\n*/\n\n#define res iResolution\n#define t iTime\n#define INF 999999.\n#define eps .01\n#define PI 3.142857\n\n#define SKY 0.\n#define SKY_COLOR vec3(.3,.3,.9)\n\n#define PLANE 1.\n\n#define SPHERE 2.\n\n#define LIGHT 3.\n\n#define MAX_DEPTH 100\n\n#define AA_COUNT 5\n#define AA_STRENGTH 300.\n#define MAX_LIGHT_SIZE 1.5\n#define LIGHT_SIZE 1.\nfloat seed = 1.;//iTime*float(iFrame+1);\nvec3 normal;\nvec3 hitColor;\nfloat lerp(float start,float end,float param){\n\treturn start*(1.-param)+param*end;   \n}\nfloat rand(vec2 p){\n    seed = fract((sin(p.x*p.y*4021.)+1.)*232.+5.*seed*5.*float(iFrame+1));\n    return seed;\n}\n\nvec3 uniformHemRandom(float u1, float u2, vec3 normal){\n    float r = sqrt(1. - u1*u1);\n    float phi = 2.*PI*u2;\n    vec3 l = vec3(cos(phi)*r,sin(phi)*r,u1);\n    vec3 binormal;\n    if(abs(normal.x) > abs(normal.z)){\n        binormal.x = -normal.y;\n        binormal.y = normal.x;\n        binormal.z = 0.;\n    }else{\n        binormal.x = 0.;\n        binormal.y = -normal.z;\n        binormal.z = normal.y;\n    }\n    binormal = normalize(binormal);\n    vec3 tangent = cross(binormal,normal);\n    return tangent*l.x+binormal*l.y+normal*l.z;\n    \n}\n\nfloat planeSDF(vec3 pos, vec3 normal, float height){\n\treturn dot(pos,normal) + height;\n}\n\nfloat sphereSDF(vec3 pos,vec3 center,float radius){\n\treturn length(pos - center) - radius;   \n}\nfloat boxSDF( vec3 p,vec3 bpos, vec3 b )\n{\n  vec3 q = abs(p-bpos) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nvec3 planeNormal(vec3 pos,vec3 normal,float h){\n\tvec2 e = vec2(.01,0.);\n    vec3 x2 = pos+e.xyy;\n    vec3 x1 = pos-e.xyy;\n    vec3 y2 = pos+e.yxy;\n    vec3 y1 = pos-e.yxy;\n    vec3 z2 = pos+e.yyx;\n    vec3 z1 = pos-e.yyx;\n  \t\n    normal = vec3(\n        planeSDF(x2,normal,h)-planeSDF(x1,normal,h),\n        planeSDF(y2,normal,h)-planeSDF(y1,normal,h),\n        planeSDF(z2,normal,h)-planeSDF(z1,normal,h)\n    );\n    return normal;\n}\n\nvec2 map(vec3 pos){\n\tfloat dist = INF;\n    float material = SKY;\n    vec3 col = SKY_COLOR;\n    \n    \n    vec3 pn1 = vec3(0.,1.,0.);\n    vec3 pn2 = vec3(0.,-1.,0.);\n    vec3 pn3 = vec3(1.,0.,0.);\n    vec3 pn4 = vec3(-1.,0.,0.);\n    vec3 pn5 = vec3(0.,0.,-1.);\n    vec3 pn6 = vec3(0.,0.,1.);\n    \n    float h1 = 3.;\n    \n    vec3 sc1 = vec3(0.,1.,1.);\n    float r1 = 1.;\n    vec3 sc2 = vec3(0.,-2.,1.);\n    float r2 = 1.;\n    \n    vec3 lc1 = vec3(0.,2.99,0.);\n    vec3 b1 = vec3(LIGHT_SIZE,0.,LIGHT_SIZE);\n    float p1 = planeSDF(pos,pn1,h1);\n    float p2 = planeSDF(pos,pn2,h1);\n    float p3 = planeSDF(pos,pn3,h1);\n    float p4 = planeSDF(pos,pn4,h1);\n    float p5 = planeSDF(pos,pn5,h1);\n    float p6 = planeSDF(pos,pn6,10.);\n    \n    float s1 = sphereSDF(pos,sc2,r1);\n    float l = boxSDF(pos,lc1,b1);\n    \n    vec2 e = vec2(.01,0.);\n    vec3 x2 = pos+e.xyy;\n    vec3 x1 = pos-e.xyy;\n    vec3 y2 = pos+e.yxy;\n    vec3 y1 = pos-e.yxy;\n    vec3 z2 = pos+e.yyx;\n    vec3 z1 = pos-e.yyx;\n  \t\n    if(p1 < dist){\n        dist = p1;\n        material = PLANE;\n        normal = planeNormal(pos,pn1,h1);\n        col = vec3(1.);\n    }\n    if(p2 < dist){\n        dist = p2;\n        material = PLANE;\n        normal = planeNormal(pos,pn2,h1);\n        col = vec3(1.);\n    }\n    if(p3 < dist){\n        dist = p3;\n        material = PLANE;\n        normal = planeNormal(pos,pn3,h1);\n        col = vec3(1.,0.,0.);\n    }\n    if(p4 < dist){\n        dist = p4;\n        material = PLANE;\n        normal = planeNormal(pos,pn4,h1);\n        col = vec3(0.,1.,0.);\n    }\n    if(p5 < dist){\n        dist = p5;\n        material = PLANE;\n        normal = planeNormal(pos,pn5,h1);\n        col = vec3(1.);\n    }\n    if(p6 < dist){\n        dist = p6;\n        material = PLANE;\n        normal = planeNormal(pos,pn6,10.);\n        col = vec3(1.);\n    }\n    if(s1 < dist){\n        dist = s1;\n        material = SPHERE;\n        normal = vec3(\n            sphereSDF(x2,sc2,r1)-sphereSDF(x1,sc2,r1),\n            sphereSDF(y2,sc2,r1)-sphereSDF(y1,sc2,r1),\n            sphereSDF(z2,sc2,r1)-sphereSDF(z1,sc2,r1)\n        );\n        col = vec3(1.,1.,1.);\n    }\n    \n    if(l < dist){\n        dist = l;\n        material = LIGHT;\n        normal = vec3(\n            boxSDF(x2,lc1,b1)-boxSDF(x1,lc1,b1),\n            boxSDF(y2,lc1,b1)-boxSDF(y1,lc1,b1),\n            boxSDF(z2,lc1,b1)-boxSDF(z1,lc1,b1)\n        );\n        col = vec3(1.,1.,1.);\n        //golden light\n        //col = vec3(.8313,.6862,.2156);\n    }\n    \n    normal = normalize(normal);\n    hitColor = col;\n    return vec2(dist,material);\n}\n\nvec3 trace(vec3 ro,vec3 rd,int rdepth){\n    float depth = 0.;\n    vec3 col= vec3(0.);\n    vec3 materialColor;\n    vec3 throughput = vec3(1.);\n    for(int i = 0;i < MAX_DEPTH;++i){\n      \tvec3 pos = ro+rd*depth;\n        vec2 hit = map(pos);\n        \n        if(hit.x < .01){\n            vec3 emissive = vec3(0.);\n            if(hit.y == LIGHT){\n                emissive = hitColor*20.;//lerp(5.,30.,1. - (LIGHT_SIZE-1.)/MAX_LIGHT_SIZE);//(MAX_LIGHT_SIZE-LIGHT_SIZE+4.)*3.;\n            }\n            col += emissive * throughput;\n            throughput *= hitColor;\n            ro = ro + (depth-eps)*rd;\n            rd = uniformHemRandom(rand(pos.xy),rand(pos.xy),normal);\n            depth = 0.;\n            continue;\n        }\n        depth += hit.x;\n    }\n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/res.xy;\n    vec3 col = vec3(0.);\n\tuv -= .5;\n    uv.x *= res.x/res.y;\n\t\n    vec3 ro = vec3(0.,0.,-8.);\n    for(int i = 0;i < AA_COUNT;++i){\n\t    vec3 rd = normalize(vec3(uv.x+rand(uv)/AA_STRENGTH,uv.y+rand(uv)/AA_STRENGTH,1.));\n   \t\tcol += trace(ro,rd,5);\n    }\n    vec3 targetCol = col/float(AA_COUNT);\n    vec3 prev = texture(iChannel0,fragCoord/res.xy).rgb;\n    vec3 current = (prev * float(iFrame) + targetCol) / float(iFrame+1);\n    fragColor = vec4(current,1.0);\n}","name":"Buffer A","description":"","type":"buffer"}]}