{"ver":"0.1","info":{"id":"DlyGDW","date":"1684006196","viewed":126,"name":"Quotient flow","username":"ChunderFPV","description":"Point flow along quotient grids. (x = x/y, y = y/z, z = z/x)\nA fancier version of this: https://www.shadertoy.com/view/msyXWw","likes":5,"published":1,"flags":32,"usePreview":0,"tags":["3d","grid","division"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 C, in vec2 U )\n{\n    vec2 R = iResolution.xy;\n    vec3 c = texture(iChannel0, U/R, .5).rgb*.1; // load buffer A\n    C = vec4(c*c, 1);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define A(a) mat2(cos(m.a*1.5708+vec4(0,-1.5708,1.5708,0)))  // rotate\n#define H(a) (cos(radians(vec3(180, 0, 60))-((a)*6.2832))*.5+.5)  // hue pallete\n#define G3(u) (max(vec3(0), 1.-(abs(fract(u+.5)-.5)/fwidth(u)/1.5))+(1.-abs(sin(u*3.1416)))*.6)*min(vec3(1), 1./abs(u));  // xyz grids\n#define MP(u,t) max(0., 1.-length((fract(u-vec2(t*round(u.y), 0)+.5)-.5)/fwidth(u)/R*300.))*min(1., 1./abs(u.x))  // moving point grid\n#define G(v) max(H(u.v+t), H(1./u.v-t)) * g.v  // quick grid with color\n#define P(v) MP(u.v, t)  // quick points\n\nvoid mainImage( out vec4 C, in vec2 U )\n{\n    float t = iTime/5.,\n          f = .5; // fov\n    vec2 R = iResolution.xy,\n         m = (iMouse.xy/R*4.)-2.; // mouse coords\n    vec3 u = vec3((U-.5*R)/R.y, f), // screen coords\n         c = texture(iChannel0, mix(U/R, vec2(.5), -.001)).rgb*.9; // frame blur\n    \n    if (iMouse.z < 1.) m = vec2(sin(t/2.)*.2, sin(t)*.1); // move camera with time\n    u.yz *= A(y), // pitch\n    u.xz *= A(x); // yaw\n    u /= u.yzx; // transform coords\n    u = max(abs(u), 1./abs(u)); // reciprocals\n    \n    t /= 10.; // slow time\n    vec3 g = G3(u); // form grids\n    c += G(x) + G(y) + G(z); // add grids\n    c += P(yx) + P(zx) + P(xy) + P(zy) + P(yz) + P(xz); // add points\n    \n    vec2 v = abs(fract(U/R+.5)-.5)/fwidth(U/R); // vignette\n    c = min(c, min(v.x, v.y)*.75);\n    \n    C = vec4(c, 1);\n}","name":"Buffer A","description":"","type":"buffer"}]}