{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[{"channel":0,"type":"texture","id":"XsX3Rn","filepath":"/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"code":"// http://www.letsdive.in/2014/05/18/glsl---raymarching/\n// https://iquilezles.org/articles/distfunctions\n// https://iquilezles.org/articles/smin\n\n#define PI 3.14159265358979323846\n\n#define MAX_DISTANCE \t\t100.\n#define MARCHING_STEP_INC \t.65\n#define EPSILON \t\t\t0.01\n\n#define MAX_COLOR_BLEED \t.5\n\n#define MAX_STEPS \t\t\t70\n\n#define ANIMATION_SPEED\t\t15.\n\n#define LIGHT_BRIGHTNESS\t2.\n\n/*\t*\t*\t*\t*\t*\t*\t*\t*\t*\t*\t*\t*\t*\t*\t*\t*\t*\t*\t*\t*\t*\n */\n\n// Current pixel color + z buffer depth (probably not a good way to add different colors\n// to the depth field, but works)!\nfloat zdepth = 10000.;\nvec3 current_color = vec3(0.);\n\n/*\t*\t*\t*\t*\t*\t*\t*\t*\t*\t*\t*\t*\t*\t*\t*\t*\t*\t*\t*\t*\t*\n */\n\n// Linear displacement timer - probably a faster way of doing this, but works!\nfloat timer(float seconds, float min_val, float max_val) {\n\treturn ( (mod(iTime, seconds) * (max_val - min_val)) / seconds ) + min_val;\n}\n\nvec3 rot_x(vec3 p, float rad) {\n\tfloat c = cos(rad); float s = sin(rad);\n\treturn vec3(p.x, p.y*c+p.z*s, -p.y*s+p.z*c);\n}\n\nvec3 rot_y(vec3 p, float rad) {\n\tfloat c = cos(rad); float s = sin(rad);\n\treturn vec3(p.x*c+p.z*s, p.y, -p.x*s+p.z*c);\n}\n\nvec3 rot_z(vec3 p, float rad) {\n\tfloat c = cos(rad); float s = sin(rad);\n\treturn vec3(p.x*c+p.y*s, -p.x*s+p.y*c, p.z);\n}\n\n/*\t*\t*\t*\t*\t*\t*\t*\t*\t*\t*\t*\t*\t*\t*\t*\t*\t*\t*\t*\t*\t*\n */\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat smin( float a, float b )\n{\n\tfloat k =68.7;\n    \n    float res = exp( -k*a ) + exp( -k*b );\n    return -log( res )/k;\n}\n\nvec3 opTwist( vec3 p )\n{\n#\tdefine TWIST 0.11\n    \n\tfloat c = cos(TWIST*p.z+TWIST);\n\tfloat s = sin(TWIST*p.z+TWIST);\n\tmat2 m = mat2(c,-s,s,c);\n\n    return vec3(m*p.xy,p.z);\n}\n\n/*\t*\t*\t*\t*\t*\t*\t*\t*\t*\t*\t*\t*\t*\t*\t*\t*\t*\t*\t*\t*\t*\n */\n\n// Current pixel color within the scene - will be blended with texture below.\n// Probably a better way of doing this, but it works!\nvoid zcolor(float new, vec3 color) {\n\tfloat d = smoothstep(new-MAX_COLOR_BLEED, new+MAX_COLOR_BLEED, zdepth);\n\tzdepth= new*(d) + zdepth*(1.-d);\n    current_color = (1.-d)*current_color + (d)*color;\n}\n\nfloat scene1(vec3 p) {\n   \tconst vec3 c = vec3(2.);\n    \n\tp= opTwist(p);\n\n\tp.x-=2.;\n    vec3 r = mod(p, c)-.5*c;\n\tfloat o1 = sdTorus(r, vec2(.545, .05));\n\tzcolor(o1, vec3(.6,.7, 0.8));\n    \n\tp.z+=5.;\n\tp = rot_z(p, PI/2.);\n    r = mod(p, c)-.5*c;\n\tfloat o2 = sdTorus(r, vec2(.545, .05));\n\tzcolor(o2, vec3(1.,.7, 0.4));\n    \n\treturn smin(o1, o2);\n}\n\nfloat get_distance(vec3 p) {\n\treturn scene1(p);\n}\n\nfloat march(vec3 ray_origin, vec3 ray_direction) {\n    float d = 0.0;\n\n\tfor (int i = 0; i < MAX_STEPS; i++) {\n\t\tvec3 np = ray_origin + ray_direction*d;\n\t\tfloat s = get_distance(np);\n\n        if (s < EPSILON)\n            return d;\n\n        d += s*MARCHING_STEP_INC;\n\n        if (d > MAX_DISTANCE) return MAX_DISTANCE;\n\t}\n\treturn MAX_DISTANCE;\n}\n\nvec3 calc_normal(vec3 p) {\n\tfloat d0 = get_distance(p);\n    \n\tfloat dX = get_distance(p - vec3(EPSILON, 0.0, 0.0));\n\tfloat dY = get_distance(p - vec3(0.0, EPSILON, 0.0));\n\tfloat dZ = get_distance(p - vec3(0.0, 0.0, EPSILON));\n\n\treturn normalize(vec3(dX-d0, dY-d0, dZ-d0));\n}\n\nvec4 texture_pixel (sampler2D t, vec3 p, vec3 n, float scale) {\n\treturn texture(t, p.yz * scale) * abs (n.x)\n\t + texture(t, p.xz * scale) * abs (n.y)\n\t + texture(t, p.xy * scale) * abs (n.z);\n}\n\nvec2 correct_aspect_ratio(in vec2 fragCoord) {\n\tvec2 uv = (fragCoord.xy / iResolution.xy) - vec2(.5);\n    uv.x *= iResolution.x/iResolution.y;\n    \n    return uv;\n}\n\n/*\t*\t*\t*\t*\t*\t*\t*\t*\t*\t*\t*\t*\t*\t*\t*\t*\t*\t*\t*\t*\t*\n */\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat eye_z=sin(mod(iTime, 100.))*4.;\n    \n    // Eye position and light position:\n\tvec3 eye_pos = vec3(0.0, 0.0, -3.+eye_z);\n    vec3 light = vec3(1., 1., -3.+eye_z);\n    \n    // For calc'n the surface normal:\n    vec3 forward = \tvec3(.0, .0, 1.);\n\tvec3 up = \t\tvec3(.0, 1., .0);\n    \n    // Timers for animation/rotation etc:\n    float rx = timer(ANIMATION_SPEED ,0., PI*2.);    \n    float ry = timer(ANIMATION_SPEED ,0., PI*2.);\n    \n\tfloat rz = timer(20. ,0., PI*2.);\n\n\tfloat wait = timer(ANIMATION_SPEED*2., 0., 2.);\n\n    // Spin off into the scene for half the animation cycle:\n\tif (floor(wait)==1.) {\n\t\teye_pos = rot_x(eye_pos, rx);\n\t\tforward = rot_x(forward, rx);\n\t\tup = rot_x(up, rx);\n\t\tlight = rot_x(light, rx);\n\n        eye_pos = rot_y(eye_pos, ry);\n\t\tforward = rot_y(forward, ry);\n\t\tup = rot_y(up, ry);\n\t\tlight = rot_y(light, ry);       \n\t}\n\n    // Rotate:\n\teye_pos = rot_z(eye_pos, rz);\n\tforward = rot_z(forward, rz);\n\tup = rot_z(up, rz);\n\n    // Rotate light:\n    light = rot_z(light, rz);\n    light = rot_x(light, rz);\n\n    // Ray march:\n    vec2 uv = correct_aspect_ratio(fragCoord);\n    \n\tvec3 right = cross(up, forward);\n\tvec3 ray_dir = normalize(up * uv.y + right*uv.x + forward);\n    \n\tfloat d = march(eye_pos, ray_dir);\n    \n\t// Store final color after marching as calc_normal for lighting below will ruin final pixel\n\t// color calc'd:\n\tvec3 finalcolor = current_color;    \n    \n    // Calc lighting if pixel falls within scene:\n    if (d < MAX_DISTANCE) {\n   \t\t// Light direction:     \n  \t\tvec3 p = (eye_pos+ray_dir*d);\n  \t\tvec3 p_normal = calc_normal(p);\n  \t\tvec3 light_dir = -normalize(light-p);\n\n        // Calc attenuation:\n        //\n        // Mental note to self:\n        // The biger K is the quicker light weakens with distance - don't forget location of \n        // light source - I won't fall for that one again!\n#\t\tdefine K .155\n        float attenuation = 1. / (1. + K*pow( length(light -(p)), 2.0));\n        \n        // Calc ambient light:\n        const float ambient_component = .1;\n        float ambient = 1.;\n  \n        // Calc diffuse light:\n        const float diffuse_component = .5;\n\t\tfloat diffuse = max(0.,  dot(light_dir, p_normal));\n        \n        // Calc specular light:\n        const float specular_component = .4;\n        const float material = 15.;\n        vec3 reflected_light_dir = reflect(-light_dir, p_normal);\n        float specular = min(1., pow( max(dot(reflected_light_dir, light_dir), 0.0), material) );\n        \n        // Calc final light density (the min allows components to be cranked up a bit):\n\t\tfloat light_density = min(1., \n         (diffuse*diffuse_component + ambient*ambient_component + specular*specular_component) );\n        light_density*= attenuation;\n        \n\t\t// Calc final color:        \n        finalcolor *= vec3(light_density);\n        \n        // Add texture:\n        const float texture_component = 1.3;\n        const float texture_scale = .5;\n        vec4 tex_col = texture_pixel(iChannel0, p, (p_normal), texture_scale);\n        const float color_component = 1.7;\n\n        // Final color within the scene:\n        finalcolor = finalcolor*color_component + tex_col.rgb*texture_component*(light_density*LIGHT_BRIGHTNESS);\n \t} else {\n        // Final color outside the scene:\n        finalcolor = vec3(0.01);\n    }\n\n\tfragColor = vec4(finalcolor, 1.);\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"4lX3DB","date":"1424692938","viewed":957,"name":"Chains","username":"frutbunn","description":"My first ray marching shader.","likes":9,"published":1,"flags":0,"usePreview":0,"tags":["3d"],"hasliked":0,"parentid":"","parentname":""}}