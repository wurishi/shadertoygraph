{"ver":"0.1","info":{"id":"Xtt3DB","date":"1471374429","viewed":357,"name":"016 simple path tracing","username":"kakaxizhhgjh","description":"original:\nhttps://www.shadertoy.com/view/4ljGRd\nhttps://www.shadertoy.com/view/llBGz1\n","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["intersection"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"struct Light  \t{ vec3 d; vec3 c; };\nstruct Ray \t  \t{ vec3 o; vec3 d; };\nstruct Hit\t\t{ float t; vec3 n; vec3 diff; };\nstruct Sphere \t{ float r; vec3 p; vec3 diff; };\nstruct Plane\t{ float d; vec3 n; vec3 diff; };\n\nconst int \tITER  = 4;\nconst float EPS   = 1e-3;\nconst float TMAX  = 1e3;\nconst Hit \tMISS  = Hit(TMAX, vec3(0), vec3(0));\nconst Light light = Light(normalize(vec3(1)), vec3(1));\n\nHit intersectPlane(Ray r, Plane p) {\n\tfloat k = dot(p.n, r.d);\n    if(k >= 0.0) return MISS;\n    return Hit(-(p.d + dot(p.n, r.o)) / k, p.n, p.diff);\n}\n\nHit intersectSphere(Ray r, Sphere s) {\n\tvec3 op = s.p - r.o;\n    float b = dot(op, r.d);\n    float det = b * b - dot(op, op) + s.r * s.r;\n    if(det < 0.0) return MISS;\n    det = sqrt(det);\n    float t = b - det;\n    if(t < 0.0) t = b + det;\n    if(t < 0.0) return MISS;\n    return Hit(t, (r.o + t * r.d - s.p) / s.r, s.diff);\n}\n\nHit intersect(Ray r) {\n\tSphere spheres[3];\n    spheres[0] = Sphere(2.0, vec3(-4, 3.0 + sin(iTime), 0), vec3(1, 0, 0));\n    spheres[1] = Sphere(3.0, vec3( 4.0 + cos(iTime), 3, 0), vec3(0, 1, 0));\n    spheres[2] = Sphere(1.0, vec3( 0, 1, 4), \t\t\t\t\t  vec3(0, 0, 1));\n    \n    Hit hit = MISS;\n    Hit tmp = intersectPlane(r, Plane(0.0, vec3(0, 1, 0), vec3(1)));\n    if(tmp.t < hit.t) hit = tmp;\n    for(int i = 0; i < 3; ++i) {\n    \ttmp = intersectSphere(r, spheres[i]);\n        if(tmp.t < hit.t) hit = tmp;\n    }\n    return hit;\n}\n\nvec3 schlick(vec3 n, vec3 v, vec3 f0) {\n\treturn pow(1.0 - dot(n, v), 5.0) * (1.0 - f0) + f0;\n}\n\nvec3 shadow(vec3 p, vec3 n) {\n    if(intersect(Ray(p + EPS * light.d, light.d)).t == TMAX) {\n    \treturn max(dot(n, light.d), 0.0) * light.c;\n    }\n    return vec3(0);\n}\n\nvec3 radiance(Ray r) {\n\tvec3 color = vec3(0);\n    vec3 beta = vec3(1);\n    \n    for(int i = 0; i < ITER; ++i) {\n    \tHit hit = intersect(r);\n        if(hit.t < TMAX) {\n        \tvec3 fresnel = schlick(hit.n, -r.d, vec3(0.01));\n            vec3 pos = r.o + hit.t * r.d;\n            color += beta * (1.0 - fresnel) * hit.diff * shadow(pos, hit.n);\n            beta *= fresnel;\n            vec3 d = reflect(r.d, hit.n);\n            r = Ray(pos + EPS * d, d);\n        } else {\n        \tcolor += beta * vec3(1);\n            break;\n        }\n    }\n    \n    return color;\n}\n\nmat3 getCamera(vec3 eye, vec3 target) {\n    vec3 z = normalize(eye - target);\n\tvec3 x = normalize(cross(vec3(0.0, 1.0, 0.0), z));\n    return mat3(x, cross(z, x), z);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\tvec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n    vec2 mo = iMouse.xy / iResolution.y * 5.0;\n    \n    float ox = 0.25 / iResolution.y;\n    float oy = 0.75 / iResolution.y;\n    vec2 msaa[4];\n    msaa[0] = vec2(-ox, -oy);\n    msaa[1] = vec2( ox, -oy);\n    msaa[2] = vec2(-ox,  oy);\n    msaa[3] = vec2( ox,  oy);\n    \n    vec3 color = vec3(0);\n    vec3 ro = vec3(14.0 * sin(mo.x), 2.0 + 2.0 * sin(mo.y), 14.0 * cos(mo.x));\n    mat3 camera = getCamera(ro, vec3(0, 1.5, 0));\n    for(int i = 0; i < 4; ++i) {\n    \tvec3 rd = camera * normalize(vec3(uv, -2) + vec3(msaa[i], 0));\n        color += radiance(Ray(ro, rd));\n    }\n    \n\tfragColor = vec4(pow(color / 4.0, vec3(0.45)), 1.0);\n}","name":"Image","description":"","type":"image"}]}