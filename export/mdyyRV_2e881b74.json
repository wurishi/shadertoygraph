{"ver":"0.1","info":{"id":"mdyyRV","date":"1696319223","viewed":116,"name":"Laplace equation in bend","username":"athibaul","description":"Testing a parallel formulation for the Laplace equation. The na√Øve solution converges very slowly as the domain becomes larger, so I used Successive Over-Relaxation (SOR) to make it faster.","likes":14,"published":1,"flags":32,"usePreview":0,"tags":["tube","bend","fdtd","acoustics"],"hasliked":0,"parentid":"DdycDw","parentname":"FDTD bend mixed formulation"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nMain {\n    float v = A(U).z;\n    \n    Q = vec4(2.*v/(1.+v),v*v,0,0);\n    // Add stripes\n    Q = mix(Q, vec4(1), smoothstep(0.8,1.0,-cos(40.*3.14159*v)) * smoothstep(10.,15.,iTime));\n    // Highlight mid-level stripe\n    Q = mix(Q, vec4(1,0,0,0), smoothstep(1.-1e-4,1.0,v*(1.-v)*4.) * smoothstep(10.,15.,iTime)) ;\n    \n    Q = mix(Q, vec4(0.5), 1.-TUBE(U));\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\n\nMain {\n    Q = A(U);\n    \n    // Successive over-relaxation (SOR)\n    // This number must be between 1.0 <= theta < 2.0\n    // If theta == 1.0, the update amounts to simply taking the\n    // average of the 4 neighbors at each step. This leads to a very slow\n    // convergence as the domain becomes large.\n    // The convergence rate can be increased by increasing theta.\n    // However, the closer theta is to 2.0, the longer the solution contains wave-like errors,\n    // so there is a trade-off between propagation of the information and diminution of the\n    // artifacts.\n    // I know that the optimal value is related to some eigenvalue of the update operator,\n    // but I can't remember how exactly.\n    //float theta = 2.0 - 0.3/(R.y);\n    float theta = 2.0 - 3.0/(R.y);\n    \n    \n    // Laplace equation\n    U = floor(U);\n    // Perform the updates alternately in a checkerboard pattern\n    if(mod(U.x+U.y+float(iFrame),2.) == 0. && TUBE(U) > 0.) {\n        //#define B(U) ((TUBE(U)>0.)? A(U):Q.zzzz)\n        //vec4 n = B(U+vec2(0,1));\n        //vec4 e = B(U+vec2(1,0));\n        //vec4 s = B(U-vec2(0,1));\n        //vec4 w = B(U-vec2(1,0));\n        //Q.z = theta * 0.25 * (n.z + s.z + e.z + w.z) + (1.-theta) * Q.z;\n        \n        float neighbors = 0., nsum=0.;\n        #define B(V) if(TUBE(V)>0.) { neighbors++; nsum+=A(V).z; }\n        B(U+vec2(0,1));\n        B(U+vec2(1,0));\n        B(U-vec2(0,1));\n        B(U-vec2(1,0));\n        Q.z = theta * (nsum / neighbors) + (1.-theta) * Q.z;\n    }\n    \n    \n    \n    // Apply Dirichlet boundary conditions\n    vec2 u = uu(U);\n    if(TUBE(U) > 0. && u.y < 0. && u.x < -1.+1.*fwidth(u.x)) {\n        Q.z = 1.;\n    } else if(TUBE(U) > 0. && u.y > 0. && u.x < -1.+1.*fwidth(u.x)) {\n        Q.z = 0.;\n    } else if(TUBE(U)==0.) {\n        Q.z = 0.;\n    }\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define R iResolution.xy\n#define Main void mainImage(out vec4 Q, in vec2 U)\n#define A(U) texelFetch(iChannel0,ivec2(U),0)\n#define uu(U) (2.*1.1*(floor(U)-.5*R)/R.y)\n#define TUBE(U) tubeF(uu(U))\n\nconst float dt = 1./sqrt(2.);\n\nfloat tubeF(vec2 u) {\n    if (abs(u.x)>1.||abs(u.y)>1.) return 0.;\n    if (u.x < 0.) {\n        return (abs(u.y)>.15) ? 1. : 0.;\n    }\n    return (abs(length(u)-.575) < .425) ? 1. : 0.;\n}","name":"Common","description":"","type":"common"}]}