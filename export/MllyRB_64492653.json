{"ver":"0.1","info":{"id":"MllyRB","date":"1505587154","viewed":392,"name":" - LEGO - ","username":"FranciscoGarcia","description":"A lego pice using distance fields\nLigthing : Diffuse and Spectular ","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["3d","raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define EPS 0.001\n#define MAX 20.0\n#define STEPS 100\n#define PI 3.14159\n//Based on IQ's Distance Functions - references - \nvec2 rot(in vec2 pos, float angle) {\n\tfloat c = cos(angle);\n    float s = sin(angle);\n    return mat2(c, -s, s, c) * pos;\n}\n\nfloat sdBox(in vec3 p,in vec3 dim) {\n    vec3 d = abs(p) - dim;\n  \treturn min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat udRoundBox( vec3 p, vec3 b, float r )\n{\n  return length(max(abs(p)-b,0.0))-r;\n}\n\nfloat sdCappedCylinder2( vec3 p, vec2 h, vec3 pos ){  \n  p -= pos;\n  p.yz = rot(p.yz, PI/2.0);\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat sdCappedCylinder( vec3 p, vec2 h, vec3 pos ){\n  p -= pos;\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat map(in vec3 p){\n    \n    p.xz = rot(p.xz, 1.5*iTime);\n    p.xy = rot(p.xy, 1.5*iTime);\n    p.yz = rot(p.yz, 1.5*iTime);\n   \n    float d1 = sdCappedCylinder( p, vec2(0.2, 0.2), vec3(-0.25, 0.5, 0.2));\n    float d2 = sdCappedCylinder( p, vec2(0.2, 0.2), vec3(0.25, 0.5, 0.2));\n    float d3 = sdCappedCylinder( p, vec2(0.2, 0.2), vec3(0.0, -0.5, 0.0));\n    \n    float d4 = sdCappedCylinder2(p, vec2(0.2, 0.1), vec3(-0.25, 0.0, 0.5));\n    float d5 = sdCappedCylinder2(p, vec2(0.2, 0.1), vec3(0.25, 0.0, 0.5));\n    float d6 = sdCappedCylinder2(p, vec2(0.2, 0.1), vec3(0.0, 0.0, -0.5));\n    \n    float d7 = udRoundBox(p, vec3(0.5), 0.05);\n    \n    float u1 = min(d1,min(d2,d3));\n    float u2 = min(d4, min(d5,d6));\n    //return sdTorus( p, vec2(0.7,0.3) );\n    return min(max(-u2, d7),u1);\n    \n}\n\nvec3 calcNormal(in vec3 p){\n\tvec2 e = vec2(0.001, 0.00);\n    return normalize(vec3(map(p+e.xyy)-map(p-e.xyy),\n                          map(p+e.yxy)-map(p-e.yxy),\n                          map(p+e.yyx)-map(p-e.yyx)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0*uv;\n    p.x *= iResolution.x/iResolution.y;\n    vec3 col = vec3(0.0, 0.0,0.0);\n    \n    vec3 ro = vec3(0.0, 0.1, 1.4);\n    vec3 rd = normalize(vec3(p, -1.0));\n    \n    float t = 0.0;\n    float dist = EPS;\n    for(int i= 0; i<STEPS; i++){\n    \t\n        if(dist <EPS || t > MAX) break;\n        dist = map(ro + t*rd);\n        t += dist;\n    }\n    //Ligth Direction\n    vec3 lig = vec3(0.6);\n\n    if(dist<EPS){\n    \tvec3 pos = ro + t*rd;\n        vec3 normal = calcNormal(pos);\n        //Intensity Factor\n        float intFact = 23.0;\n        float diffuse = max(0.0, dot(lig, normal));\n        float specular = pow(diffuse, intFact);\n        //Phong lighting\n        col = vec3(diffuse + specular)*vec3(1.0,0.6,0.0);\n    }\n    \n\tfragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}