{"ver":"0.1","info":{"id":"ctsBzB","date":"1693757713","viewed":208,"name":"Periodic Minimal Surfaces","username":"otkazano","description":"Periodic Minimal Surfaces visualization","likes":34,"published":1,"flags":0,"usePreview":1,"tags":["raymarch","surface","hyroid","swartz"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//quality params\n#define adiptive\n#define subSamples 3\n#define subSamplesF 1\n#define subSamplesA 2\n#define threshold 0.2\n//uv screen params\n#define du 0.5\n#define dv 0.5\n#define iR vec2(1.0/iResolution.x, 1.0/iResolution.y)\n//march tracing params\n#define MarchMaxDistance 1e2\n#define MarchSteps 1024*1\n#define MarchThreshold 1e-3\n#define MarchInfinity 1e7\n#define MarchNormalPrecision MarchThreshold*0.5\n\n\n\n//camera params\n#define CameraZoom 0.5\n//mice params\n#define miceFactor vec2(-9.0, 3.5)\n\n//TIMING\n\n#define period 7.0\n#define interval 28.0\n\nstruct camera {\n    vec3 position;\n    float zoom;\n    float angleA;\n    float angleB;\n};\n\nstruct directLight {\n    vec3 color;\n    vec3 direction;\n    float power;\n};\n\nstruct ambientLight {\n    vec3 color;\n    vec3 direction;\n    float power;\n    float coverage;\n};\n\nint face;\n\n\n\ncamera cam;\n\n\ndirectLight dl[2];\nambientLight al[2];\n\n/*\ncam.angleA = -0.1;\ncam.angleB = -0.1;\n*/\n\nvec3 matCol[10];\n\nvec3 paint0 = vec3(0.77,0.66,0.44)*0.75+vec3(0.5)*0.25;\nvec3 paint1 = vec3(0.7,0.6,0.8)*0.75+vec3(0.5)*0.25;\nvec3 paint2 = vec3(0.2,0.7,0.7)*0.75+vec3(0.5)*0.25;\nvec3 paint3 = vec3(0.66,0.77,0.33)*0.75+vec3(0.5)*0.25;\nvec3 paint4 = vec3(0.5,0.6,0.7)*0.75+vec3(0.5)*0.25;\nvec3 paint;\n\nfloat[5] aoFadeFactor = float[5](1.0,1.0,1.0,1.0,0.6);\n\nint type = 0;\n//float scale = 0.5;\n\nint[16] word0 = int[16](83,99,104,119,97,114,122,32,80,-1,-1,-1,-1,-1,-1,-1);\nint[16] word1 = int[16](83,99,104,119,97,114,122,32,68,-1,-1,-1,-1,-1,-1,-1);\nint[16] word2 = int[16](71,121,114,111,105,100,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1);\nint[16] word3 = int[16](76,105,100,105,110,111,105,100,-1,-1,-1,-1,-1,-1,-1,-1);\nint[16] word4 = int[16](71,121,114,111,105,100,32,76,97,116,116,105,99,101,-1,-1);\n\nint[16] wrd;\n\n#define sc (1.0/pow(2.0, part))\n\n#define localTime mod(iTime, interval)\n#define part floor(localTime/period)\n#define lt mod(localTime, period)\n\n\n\n//------T E X T------------------------------------------------\nvec4 litera(vec2 uv, int ch, float x, float y, float scale){\n    if(ch < 0) return vec4(-1.0);\n    float r, c, s;\n    vec2 tuv, loc;\n    s = 1.0/16.0;\n    r = 15.0-floor(float(ch)/16.0);\n    c = float(ch)-r*16.0;\n    tuv = (vec2(c,r)-vec2(0.0,0.03))*s;\n    return texture(iChannel0, clamp((uv-vec2(x,y))/scale, 0.0, s)+tuv);\n}\nfloat word(vec2 uv, float x, float y, float scale, float spacing, float weight, int[16] word){\n    float v = 0.0, w = 1.0;\n    vec4 l;\n    for(int i=0; i<16; i++){\n        l = litera(uv, word[i], x+1.0/16.0*float(i)*scale*(1.0+spacing), y, scale);\n        if(l.x<0.0) continue;\n        v = l.a;\n        \n        weight = clamp(0.0, 1.0, weight);\n        w *= smoothstep(0.4+weight*0.1,0.5+weight*0.1,v);\n    }\n    return w;\n}\n//------RANDOM-------------------------------------------------\nfloat hash13(vec3 p, float seed){\n    float h = dot(sin(p*73.4577987),vec3(82.544324-seed,622.2845231+seed,4646.1234+seed))+seed;\n    h = fract(sin(h*873.4743+seed)*547.4654-seed);\n    return h;\n}\nvec3 randVec3(vec3 p, float seed){\n    return vec3(hash13(p, seed+154.4164), hash13(p, seed-4654.454), hash13(p, seed*14.453))-0.5;\n}\n\n//------MATRIX-------------------------------------------------\nmat2 rotMatx2( float a )\n{\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c,-s,s,c);\n}\n//------MICE---------------------------------------------------\nvec2 getMice()\n{\n    if(iMouse.xy==vec2(0.0)) return vec2(0.25,0.2);\n    return vec2(iMouse.x/iResolution.x-.5,iMouse.y/iResolution.y-.5);\n}\n//------SIMPLEX OBJECTS----------------------------------------\nfloat d_hPlate(vec3 p, float dy){// Horizontal plate| dy-altitude\n    return p.y-dy;\n}\n\nfloat d_roundBox(vec3 p, vec3 b, float r){ // by IQ Rounded box\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n//------SCENE--------------------------------------------------\nfloat scene( in vec3 p, out int side, out float track, out float depth)\n{\n    float d = MarchInfinity, D = MarchInfinity, cut = MarchInfinity;\n    vec3 cutDir = normalize(vec3(0.0,0.9,0.0));\n    float cutDist = -(lt*3.0-6.5)/sc;\n    p /= sc;\n    float thickness = 0.05, thicknessT = 0.3, trackDepth = 2.0;\n    D = d_roundBox(p, vec3((6.5-sc)/sc), 0.9);\n    cut = dot(p, cutDir)+cutDist;\n    if(type == 0){ // Schwarz P\n        d = cos(p.x)+cos(p.y)+cos(p.z);\n    }\n    if(type == 1){ // Schwarz D\n        d = sin(p.x)*sin(p.y)*sin(p.z) + sin(p.x)*cos(p.y)*cos(p.z) + cos(p.x)*sin(p.y)*cos(p.z) + cos(p.x)*cos(p.y)*sin(p.z);\n    }\n    if(type == 2){ // Hyroid\n        d = sin(p.x)*cos(p.y) + sin(p.y)*cos(p.z) + sin(p.z)*cos(p.x);\n    }\n    if(type == 3){ // Lidinoid\n        d = 0.5*(sin(p.x*2.0)*cos(p.y)*sin(p.z) + sin(p.y*2.0)*cos(p.z)*sin(p.x) + sin(p.z*2.0)*cos(p.x)*sin(p.y))-0.5*(cos(p.x*2.0)*cos(2.0*p.y) + cos(p.y*2.0)*cos(2.0*p.z)+cos(p.z*2.0)*cos(2.0*p.x));\n    }\n    if(type == 4){ // Custom\n        d = 0.0;\n        //d += sin(p.x)*cos(p.z)+sin(p.z)*sin(p.y)+cos(p.z)*sin(p.z);\n        //d += sin(p.x)*sin(p.z)+sin(p.z)*cos(p.y)+cos(p.y)*cos(p.x);\n        //d += sin(p.x)*sin(p.z)+sin(p.z)*cos(p.y)+cos(p.y)*cos(p.z);\n        //d += sin(p.z)*sin(p.x)+sin(p.x)*cos(p.y)+cos(p.y)*cos(p.z);\n        //d += (pow(sin(p.x),5.0)+pow(sin(p.y),5.0)+pow(sin(p.z),5.0))*0.3+(sin(p.x)+sin(p.y)+sin(p.z))*0.7;\n        d = abs(dot(sin(p), cos(p.zxy))-1.4)-0.2;\n    }\n    side = d<0.0?1:0;\n    track = exp(-abs(cut)*trackDepth);\n    \n    d = (type>3?d:abs(d))-thickness-track*thicknessT;\n    \n    \n    d = max(d, D);\n    d = max(d, cut);\n    p*=40.0;\n    d = max(d, -1.0*(sin(p.x)*sin(p.y)*sin(p.z))*pow(track,4.0));\n   \n\n    if(d<=D) side = 2;\n    if(d<=cut) side = 3;  \n\n    depth = max(-D, 0.0)*aoFadeFactor[type];\n    \n    \n    return d;\n}\n//------PROCEDURAL---------------------------------------------\nvec3 normal(vec3 p){\n    float e = MarchNormalPrecision;\n    int side;\n    float track, depth;\n    float P = scene(p, side, track, depth);\n    return normalize(\n        vec3(\n            scene(p+vec3(e,0.0,0.0), side, track, depth)-P,\n            scene(p+vec3(0.0,e,0.0), side, track, depth)-P,\n            scene(p+vec3(0.0,0.0,e), side, track, depth)-P\n        )\n    );\n    \n}\n\nvec3 marching( in vec3 pos, in vec3 dir, out float d, out bool r, out int objID, out float steps )\n{\n    int side;\n    float track, depth;\n    float k = 0.75*sc;\n    r = false;\n    vec3 p=pos;\n    d = scene(p, side, track, depth);\n    steps = 0.0;\n    float mt = MarchThreshold;\n    float dd = 0.0;\n    for(int i=1; i<=MarchSteps; i++){\n        if(abs(d) <= mt){\n            r = true;\n            return p;\n        }\n        d = scene(p, side, track, depth);\n        d *= d<4.5?0.3:1.0; //Artefacts correction\n        p += dir*d*k;\n        dd += d*k;\n        steps++;\n        if(dd>=MarchMaxDistance){\n            r = false;\n            return p;\n        }\n    }\n    return p;\n}\nfloat lightness ( in vec3 normal, in vec3 dir, float coverage )\n{\n    vec3 n = normal;\n    return max(0.0,-dot(dir, n) * (1.0-0.5*coverage) + 0.5*coverage);\n}\nvec3 uvToSpace( in vec2 uv )\n{\n    vec2 z = vec2(cam.zoom,uv.y);\n    z *= rotMatx2(cam.angleB*miceFactor.y);\n    vec2 xz = vec2(uv.x,z.x);\n    xz *= rotMatx2(cam.angleA*miceFactor.x);\n    return normalize(vec3(xz.x,z.y,xz.y));\n}\nvec3 rotate( in vec3 p, float a, float b )\n{\n    vec3 rp = p;\n    \n    rp.xy *= rotMatx2(b);\n    rp.yz *= rotMatx2(a);\n    return rp;\n}\n\nvec3 getFarColor( vec3 lookAtvector, float size, float factor, float brightness )\n{   \n    float k = size;\n    float p;\n    vec3 rv;\n    vec3 upCol = vec3(0.22,0.21,0.2)*2.0;\n    vec3 dnCol = vec3(0.10,0.11,0.12)*2.0;\n \n    \n    rv += upCol*pow(max(dot(vec3(0.0,1.0,0.0),lookAtvector),0.0),2.0);\n    rv += dnCol*pow(max(dot(vec3(0.0,-1.0,0.0),lookAtvector),0.0),2.0);\n    rv += hash13(lookAtvector, 465.456)*0.01;\n    rv += 0.5;\n    /*\n    for(int i=0;i<2;i++){\n        p = dot(lookAtvector,-dl[i].direction);\n        p = max((p-1.0)/k+1.0,0.0);\n        \n        p = pow(p,factor);\n        rv += p*dl[i].color*brightness;\n    }\n    */\n    return rv+vec3(0.09);\n}\nvec3 frameSubProcessing(vec2 uv){\n    vec2 mice = getMice();\n    \n    //Eyler angles\n    cam.angleA = -mice.x;\n    cam.angleB = -mice.y;\n    cam.zoom = CameraZoom;\n    cam.position = -uvToSpace( vec2(0.0) )*20.0;\n      \n    vec3 v = uvToSpace(uv);    \n    \n    //Direction light\n    dl[0].color = vec3(1.0,1.0,1.0)*0.3;\n    dl[0].direction = normalize(vec3(0.2,-0.3,0.4));\n    dl[1].color = vec3(1.0,1.0,1.0)*0.3;\n    dl[1].direction = normalize(vec3(-0.5,-0.0,-0.3));\n    \n    //Ambient light\n    al[0].color = vec3(0.9);\n    al[0].direction = normalize(vec3(0.4,-0.7,0.2));\n    al[0].coverage = 0.7;\n    \n    al[1].color = vec3(0.5);\n    al[1].direction = normalize(vec3(0.0,0.9,0.0));\n    al[1].coverage = 0.9;\n    \n    type = int(mod(floor(iTime/interval),5.0));\n    \n    matCol[0] = vec3(0.99,0.99,0.99);\n    if(type==0) paint=paint0;\n    if(type==1) paint=paint1;\n    if(type==2) paint=paint2;\n    if(type==3) paint=paint3;\n    if(type==4) paint=paint4;\n    matCol[1] = paint;\n    matCol[2] = (matCol[0] + matCol[1])*0.5;\n    matCol[3] = vec3(0.99,0.4,0.8)*3.0;\n    matCol[4] = vec3(0.99,0.1,0.0)*5.0;\n    \n\n    bool reached;\n    int side;\n    float track, depth;\n    float dist;\n    float s, a, b, w, l;\n    vec3 L = vec3(0.0);\n    vec3 n;\n    vec3 c = vec3(0.0);\n    vec3 txtMet, txtBump, txtCol;\n    \n    vec3 p = marching(cam.position, v, dist, reached, side, s);\n    \n    if(reached){\n        scene(p, side, track, depth); //getAllParams of object\n        n = normalize(normal(p));\n        \n        s = pow(track, 0.75*sc);\n        w = pow(1.0-track,10.0);\n        for(int i=0; i<2; i++){\n            L += lightness(n, al[i].direction, al[i].coverage)*al[i].color;\n        }\n        \n        //fake AO\n        L *= exp(-depth*0.15/pow(sc,0.25));\n        \n        for(int i=0; i<2; i++){\n            l = 1.0;\n            l *= smoothstep(w*0.95, 1.0, max(dot(reflect(n,v), al[i].direction),0.0)); //glossy fade by cut plane\n            l *= exp(-depth*1.0/pow(sc,0.5)); //glossy fade by depth in structure (fade AO shadow)\n            l *= (1.0-dot(-n,v)*0.8); //pseudo fresnel\n            L += l*al[i].color*1.5;\n            \n        }\n        \n\n        \n        c = matCol[side]*L;     \n        if(side>2) c = matCol[side];\n        c += s*matCol[4];\n        \n    }else{\n        c = getFarColor(v, 0.002, 0.75, 5.0);\n    }\n    return c;\n}\n\nvec3 frameProcessing(vec2 uv, int subs){\n    float ss = float(subs);    \n    vec3 c = vec3(0.0);\n    float delta = 1.0/(ss+1.0), pixSize = 1.0/iResolution.x;\n    delta *= pixSize;\n    float dx, dy;\n    dy = 0.0;\n    for(float y=0.0; y<ss; y++){\n        dy += delta;\n        dx = 0.0;\n        for(float x=0.0; x<ss; x++){\n            dx += delta;\n            c += frameSubProcessing(uv+vec2(dx,dy));\n        }\n    }\n    return c/float(ss*ss);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = vec2(fragCoord.x * iR.x - du, (fragCoord.y * iR.y - dv)*iR.x*iResolution.y);\n    \n    int ss;\n    vec3 check, c;\n    \n    #ifndef adiptive\n        if(iResolution.x > 1400.0){\n            ss = subSamplesF;\n        }else{\n            ss = subSamples;\n        }\n        c = frameProcessing(uv, ss);\n    #endif\n    \n\n    \n    \n    #ifdef adiptive\n        check = frameProcessing(uv, 1);\n        if(length(fwidth(check))>threshold){\n            c = frameProcessing(uv, subSamplesA);\n            //c = vec3(1.0,0.0,0.0);\n        }else{\n            c = check;\n        }\n    #endif \n    \n\n    \n    \n    \n    float e = 0.9;\n    c = vec3(pow(c.x,e), pow(c.y,e), pow(c.z,e));\n    c = 1.0-exp(-c*1.6);\n    \n    if(type==0) wrd = word0;\n    if(type==1) wrd = word1;\n    if(type==2) wrd = word2;\n    if(type==3) wrd = word3;\n    if(type==4) wrd = word4;\n    \n    c *= vec3(word(uv, -0.5, 0.5*iResolution.y/iResolution.x-1.5/32.0, 0.5, -0.5, 0.1, wrd));\n    \n    \n    \n    \n    fragColor = vec4(vec3(c),1.0);\n}\n","name":"Image","description":"","type":"image"}]}