{"ver":"0.1","info":{"id":"mtc3W2","date":"1683131076","viewed":55,"name":"RM tutorial: a beginning","username":"jakecariello","description":"hope this goes well\nadded some metaball jazz bc of course\nsee: https://www.youtube.com/watch?v=Ff0jJyyiVyw&list=PLGmrMu-IwbgtMxMiV3x4IrHPlPmg7FD-P&index=1&t=706s&ab_channel=TheArtofCode","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","tutorial"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_THRESH .01\n#define K_FACTOR 4.\n\n// smoothmin function for metaball effect\nfloat smin(float a, float b, float k) {\n  float h = clamp(0.5 + 0.5 * (b - a) / k, 0.0, 1.0);\n  return mix(b, a, h) - k * h * (1.0 - h);\n}\n\n// 3D rotation matrix\nmat4 rotate(vec3 axis, float angle) {\n  axis = normalize(axis);\n  float s = sin(angle);\n  float c = cos(angle);\n  float oc = 1.0 - c;\n\n  return mat4(\n    oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n    oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n    oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n    0.0,                                0.0,                                0.0,                                1.0\n  );\n}\n\n\n// distance from p to the scene's surfaces\nfloat distFrom(vec3 p) {\n    vec4 s = vec4(0, 1, 0, 1); // sphere: x, y, z, r\n    vec4 s2 = vec4(sin(iTime), cos(iTime) + 4., 0, 1);\n    \n    float ds = length(p - s.xyz) - s.w; // dist to sphere\n    float ds2 = length(p - s2.xyz) - s2.w;\n    float dp = p.y; // dist to plane: y = 0\n    return smin(smin(ds, dp, K_FACTOR), ds2, K_FACTOR);\n}\n\n// perform a ray march from ro in direction rd\n// ro: ray origin\n// rd: ray direction\nfloat rayMarch(vec3 ro, vec3 rd) {\n    float L = 0., dL = SURF_THRESH;\n    vec3 dir = normalize(rd), p = ro;\n    for (int i = 0; i < MAX_STEPS && !(L > MAX_DIST || dL < SURF_THRESH); i += 1) {\n        dL = distFrom(p);\n        L += dL;\n        p = ro + dir * L;\n\n    }\n    return L;\n}\n\n// surface normal at point P\n// calculates 3D \"gradient\" (surface normal points along gradient)\nvec3 normalAt(vec3 p) {\n    float d = distFrom(p);\n    vec2 e = vec2(.01, 0);\n    vec3 n = d - vec3(\n        distFrom(p - e.xyy),\n        distFrom(p - e.yxy),\n        distFrom(p - e.yyx));\n    return normalize(n);\n}\n\n// calculate lighting value at point p for light position l\nfloat lightAt(vec3 p, vec3 l) {\n    vec3 lp = l - p;\n    vec3 n = normalAt(p);\n    // diffuse light: measures \"alignment\" between...\n    // 1. lp: unit vector pointing from point to light source\n    // 2: n: the point's surface unit normal\n    // maximized when n == lp\n    float diff = clamp(dot(n, normalize(lp)), 0., 1.);\n    // distance to light from p (need to offset away from surface to prevent ray marching prematurely exiting)\n    float dl = rayMarch(p + n * SURF_THRESH * 2., lp);\n    if (dl < length(lp)) diff *= .4;\n    return diff;\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // [-.5, .5] ... 0-centering required for that convenient rd trick below\n    vec2 uv = (fragCoord - iResolution.xy / 2.)/min(iResolution.x, iResolution.y);\n\n    vec3 col = vec3(0);\n\n    // ray origin and direction\n    vec3 ro = vec3(0, 10, -7);\n    vec3 rd = (rotate(vec3(1, 0, 0), atan(-ro.y, -ro.z)) * vec4(uv.x, uv.y, 1, 1)).xyz;\n    \n    // distance to surface and intersection point\n    float d = rayMarch(ro, rd);\n    vec3 p = ro + normalize(rd) * d;\n    \n    // lighting at point\n    vec3 l = vec3(0, 5, 0);\n    l.xz += vec2(sin(iTime), cos(iTime)) * 3.;\n    float dif = lightAt(p, l);\n    l = vec3(0, 5, 0);\n    l.xz += vec2(cos(iTime * 1.1), -sin(iTime * 1.1)) * 3.;\n    dif = (dif + lightAt(p, l)) / 2.;\n    \n    \n    col = vec3(dif);\n\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}