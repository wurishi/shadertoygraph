{"ver":"0.1","info":{"id":"wdX3WN","date":"1546248252","viewed":232,"name":"Reflect&Refract Solid&Hollow","username":"gest","description":"solid  & hollow spheres","likes":14,"published":1,"flags":0,"usePreview":0,"tags":["sphere","cubemap","intersect","reflect","refract"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Адаптер\nfloat u_time;\n\nconst float PI = radians(180.);\nconst float Infinity = 1./0.;\n\n//Камера\nstruct Camera {\n\t//Задаваемые параметры\n\tfloat fov;\n\tfloat aspect;\n\tvec3  origin;\n\tvec3  target;\n\tvec3  up;\n\t//Расчетные параметры\n\tfloat factor;\n\tvec3  forward;\n\tvec3  right;\n\tvec3  position;\n\tvec3  coord;\n};\n\n//Дополнительные параметры, возвращаемые картой расстояний\nstruct Object {\n\tfloat   distance;\t//Последнее приближение луча к элементу сцены (стремится к 0 в случае нахождения точки пересечения)\n\tint \tid;\t\t\t//id элемента сцены\n};\n//Луч\nstruct Ray {\n\t//Задаваемые параметры\n\tvec3  origin;\t\t//Начало луча\n\tvec3  direction;\t//Направление луча\n\tfloat near;\t\t\t//Минимальное расстояние до элемента\n\tfloat far;\t\t\t//Предельное расстояние до элемента\n\tfloat epsilon;\t\t//Точность\n\tint\t  steps;\t\t//Максимальное число итераций\n\t//Возвращаемые параметры\n\tfloat distance; \t//Расстояние до точки элемента сцены от ray.origin в направлении ray.direction\n\tvec3  position; \t//Текущая точка элемента сцены ray.origin + ray.direction * ray.distance\n\tbool  hit;\t\t\t//Успех нахождения точки пересечения\n\tvec3  normal;\n\tObject object;\t\t//Дополнительные параметры, возвращаемые картой расстояний\n};\n//Формирование луча камеры\nRay lookAt (in vec2 uv, inout Camera cam) {\n\t//Расчетные характеристики камеры\n\tcam.factor \t\t= 1.0/tan(radians(cam.fov/2.));\n\tcam.forward \t= normalize(cam.target-cam.origin); \n\tcam.right \t\t= normalize(cross(cam.up, cam.forward));\n\tcam.up \t\t\t= cross(cam.forward, cam.right);\n\tcam.position \t= cam.origin + cam.factor * cam.forward;\n\tcam.coord \t\t= cam.position + uv.x * cam.right * cam.aspect + uv.y * cam.up;\n\t//Формирование луча\n\tRay ray;\n\t{\n\t\tray.origin \t\t= cam.origin;\n\t\tray.direction \t= normalize(cam.coord - cam.origin);\n\t}\n\treturn ray;\n}\n\nstruct Box {\n\tvec3 center;\n\tvec3 size;\n};\nBox box_0 = Box(vec3(0.0, -1.5, 0.0), vec3(1.0, 1.0, 1.0));\n\nstruct Sphere {\n\tvec3 center;\n\tfloat radius;\n};\nSphere sphere_0 = Sphere(vec3( 0.0, 0.0, 0.0),  0.5);\nSphere sphere_1 = Sphere(vec3( 1.0, 0.0, 0.0),  0.25);\nSphere sphere_2 = Sphere(vec3(-1.0, 0.0, 0.0),  0.25);\nSphere sphere_3 = Sphere(vec3( 0.0, 0.0, 1.0),  0.25);\nSphere sphere_4 = Sphere(vec3( 0.0, 0.0, -1.0), 0.25);\n\nstruct Light {\n\tvec3 position;\n\tvec3 color;\n};\nLight light = Light (vec3(10,20,10), vec3(1));\n\nstruct Material {\n    vec3  colorAmbient;     \n    vec3  colorDiffuse;    \n    vec3  colorSpecular;  \n    float shininess;\n\t\n    float reflectivity; \n    float refractivity;\t\n    float indexRefractive;\n    bool  flagSolid;\n};\nMaterial material_box_0    = Material (vec3(0.1, 0.1, 0.1), vec3(0.9, 0.9, 0.9), vec3(1),   128.0, 0.3, 0.5, 1.0, false);\nMaterial material_sphere_0 = Material (vec3(0.0, 0.0, 0.0), vec3(0.0, 0.0, 0.0), vec3(1),    32.0, 0.5, 0.6, 0.8, true);\nMaterial material_sphere_1 = Material (vec3(0.8, 0.1, 0.1), vec3(0.2, 0.0, 0.0), vec3(1),    32.0, 0.5, 0.5, 0.8, true);\nMaterial material_sphere_2 = Material (vec3(0.1, 0.4, 0.1), vec3(0.1, 0.4, 0.1), vec3(1),    32.0, 0.5, 0.5, 0.8, true);\nMaterial material_sphere_3 = Material (vec3(0.1, 0.1, 0.1), vec3(0.4, 0.4, 0.4), vec3(1),    16.0, 1.0, 0.0, 0.8, true);\nMaterial material_sphere_4 = Material (vec3(0.1, 0.1, 0.4), vec3(0.8, 0.8, 0.8), vec3(0.0), 256.0, 0.0, 0.0, 0.0, true);\n\n//-------------Вспомогательные функции-----------------------------\n//Масштаб вектора\nvoid scale (inout vec3 v, vec3 s) {\n\tv = v * s;\n}\n//Перемещение вектора\nvoid translate (inout vec3 v, vec3 delta) {\n\tv = v - delta;\n}\n//Вращение вектора\nvoid rotate(inout vec3 v, vec3 rad) {\n\tvec3 c = cos(rad), s = sin(rad);\n\tif (rad.x!=0.) v = vec3(v.x, \t\t\t\t   c.x * v.y + s.x * v.z, -s.x * v.y + c.x * v.z);\n\tif (rad.y!=0.) v = vec3(c.y * v.x - s.y * v.z, v.y, \t\t\t\t   s.y * v.x + c.y * v.z);\n\tif (rad.z!=0.) v = vec3(c.z * v.x + s.z * v.y, -s.z * v.x + c.z * v.y, v.z\t\t\t\t\t);\n}\n//-------------------------------------------------------\n\n\nfloat intersectBox(Ray ray, Box box, inout vec3 normal) {\n\t\n\tvec3 minp = box.center - box.size;\n\tvec3 maxp = box.center + box.size;\n\t\n\tfloat tmin = (minp.x - ray.origin.x) / ray.direction.x;\n\tfloat tmax = (maxp.x - ray.origin.x) / ray.direction.x;\n\tif (tmin > tmax) { float s = tmin; tmin = tmax; tmax = s; }\n\tfloat tymin = (minp.y - ray.origin.y) / ray.direction.y;\n\tfloat tymax = (maxp.y - ray.origin.y) / ray.direction.y;\n\tif (tymin > tymax) { float s = tymin; tymin = tymax; tymax = s; }\n\tif ((tmin > tymax) || (tymin > tmax)) return ray.far;\n\tif (tymin > tmin) tmin = tymin;\n\tif (tymax < tmax) tmax = tymax;\n\tfloat tzmin = (minp.z - ray.origin.z) / ray.direction.z;\n\tfloat tzmax = (maxp.z - ray.origin.z) / ray.direction.z;\n\tif (tzmin > tzmax) { float s = tzmin; tzmin = tzmax; tzmax = s; }\n\tif ((tmin > tzmax) || (tzmin > tmax)) return ray.far;\n\tif (tzmin > tmin) tmin = tzmin;\n\tif (tzmax < tmax) tmax = tzmax;\n\t\n\tfloat t;\n\tif ( tmin < ray.epsilon && tmax < ray.epsilon ) return ray.far;\n\tif ( tmin < ray.epsilon ) {\n\t\tt = tmax;\n\t} else if ( tmax < ray.epsilon ) {\n\t\tt = tmin;\n\t} else {\n\t\tt = min(tmin, tmax);\n\t}\n    \n\tfloat flagInside = 1.;\n\tif ( tmin < ray.epsilon && tmax > ray.epsilon ) flagInside = -1.;\n\t\n\tvec3 p = ray.origin + t * ray.direction;\n\t\n\tif ( abs(p.x - maxp.x) < ray.epsilon ) {\n\t\tnormal = vec3(1,0,0) * flagInside;\n\t} else if ( abs(p.x - minp.x) < ray.epsilon ) {\n\t\tnormal = vec3(-1,0,0) * flagInside;\n\t} else if ( abs(p.y - maxp.y) < ray.epsilon ) {\n\t\tnormal = vec3(0,1,0) * flagInside;\n\t} else if ( abs(p.y - minp.y ) < ray.epsilon ) {\n\t\tnormal = vec3(0,-1,0) * flagInside;\n\t} else if ( abs(p.z - maxp.z ) < ray.epsilon ) {\n\t\tnormal = vec3(0,0,1) * flagInside;\n\t} else {\n\t\tnormal = vec3(0,0,-1) * flagInside;\n\t}\n\treturn t;\n}\n\nfloat intersectSphere(Ray ray, Sphere sphere, out vec3 normal) {\n\tvec3 diff = ray.origin-sphere.center;\n\tfloat a = dot(ray.direction, diff);\n\tfloat b = dot(diff, diff);\n\tfloat d = a*a - b + sphere.radius*sphere.radius;\n\tif (d<0.) return ray.far;\n\td = sqrt(d);\n\tfloat ta = -a + d;\n\tfloat tb = -a - d;\n\tfloat t0 = min(ta,tb);\n\tfloat t1 = max(ta,tb);\n\tfloat dist = t0;\n\tif (dist<0.) dist = t1;\n\tif (dist<ray.epsilon) return ray.far;\n    vec3 p = ray.origin + dist * ray.direction;\n    normal = normalize(p - sphere.center);\n    normal *= -sign(dot(ray.direction, p - sphere.center));    \n\treturn dist;\n}\n\n//Пересечение с элементами сцены\nvoid rayMarch (inout Ray ray) {\n\t//Учитываем минимальное расстояние\n\tray.origin += ray.near * ray.direction; \n\t\n\tray.hit = false;\n\tray.distance = ray.far;\n\tray.object.id = 0;\n\tray.position = ray.origin + ray.distance * ray.direction;\n\tray.normal = vec3(0);\n\n\tBox box;\n\tSphere sphere;\n\t\n\tfloat d;\n    vec3 normal;\n\n\t//Куб\n\tbox = box_0;\n    d = intersectBox(ray, box, normal);\n    if (ray.distance > d) {\n\t\tray.hit \t \t= true;\n\t\tray.distance \t= d;\n\t\tray.object.id\t= 1;\n\t\tray.position \t= ray.origin + ray.distance * ray.direction;\n\t\tray.normal \t\t= normal;\n\t}\n\t\n\t//Шар\n    sphere = sphere_0;\n    d = intersectSphere(ray, sphere, normal);\n    if (ray.distance > d) {\n\t\tray.hit \t\t= true;      \n \t\tray.distance \t= d;\n\t\tray.object.id \t= 2;\n\t\tray.position \t= ray.origin + ray.distance * ray.direction;\n        ray.normal \t\t= normal;\n\n\t}\n\n\t//Шар\n    sphere = sphere_1;\n    d = intersectSphere(ray, sphere, normal);\n    if (ray.distance > d) {\n\t\tray.hit \t\t= true;      \n \t\tray.distance \t= d;\n\t\tray.object.id \t= 3;\n\t\tray.position \t= ray.origin + ray.distance * ray.direction;\n        ray.normal \t\t= normal;\n\t}\n\n\t//Шар\n    sphere = sphere_2;\n    d = intersectSphere(ray, sphere, normal);\n    if (ray.distance > d) {\n\t\tray.hit \t\t= true;      \n \t\tray.distance \t= d;\n\t\tray.object.id \t= 4;\n\t\tray.position \t= ray.origin + ray.distance * ray.direction;\n        ray.normal \t\t= normal;\n\n\t}\n\n\t//Шар\n    sphere = sphere_3;\n    d = intersectSphere(ray, sphere, normal);\n    if (ray.distance > d) {\n\t\tray.hit \t\t= true;      \n \t\tray.distance \t= d;\n\t\tray.object.id \t= 5;\n\t\tray.position \t= ray.origin + ray.distance * ray.direction;\n        ray.normal \t\t= normal;\n\n\t}\n\n\t//Шар\n    sphere = sphere_4;\n    d = intersectSphere(ray, sphere, normal);\n    if (ray.distance > d) {\n\t\tray.hit \t\t= true;      \n \t\tray.distance \t= d;\n\t\tray.object.id \t= 6;\n\t\tray.position \t= ray.origin + ray.distance * ray.direction;\n        ray.normal \t\t= normal;\n\n\t}\n}\n\nMaterial getMaterial(Ray ray) {\n\tMaterial material;\n\tif (ray.object.id == 1) {\n\t\tmaterial = material_box_0;\n\t\t\n\t\t//Координата текстуры\n\t\tvec3 p = ray.position - box_0.center;\n\t\tvec3 uaxis = vec3(1,0,0);\n\t\tvec3 vaxis = vec3(0,1,0);\n\t\tif (abs(ray.normal.x) > 0.9) {\n\t\t\tuaxis = vec3(0,1,0);\n\t\t\tvaxis = vec3(0,0,1);\n\t\t} else if (abs(ray.normal.y) > 0.9) {\n\t\t\tuaxis = vec3(1,0,0);\n\t\t\tvaxis = vec3(0,0,1);\t\t\n\t\t}\n\t\tvec2 coord = floor(4. * vec2 ( dot(p, uaxis), dot(p, vaxis) ));   \n    \tfloat col = mod(coord.x + coord.y, 2.0) == 0. ? 0.8 : 0.3;\n\t\tmaterial.colorDiffuse = vec3(col);\n\t\t\n\t} else if (ray.object.id == 2) {\n\t\tmaterial = material_sphere_0;\n\t} else if (ray.object.id == 3) {\n\t\tmaterial = material_sphere_1;\n\t} else if (ray.object.id == 4) {\n\t\tmaterial = material_sphere_2;\n\t} else if (ray.object.id == 5) {\n\t\tmaterial = material_sphere_3;\n\t} else if (ray.object.id == 6) {\n\t\tmaterial = material_sphere_4;\n\t}\n\treturn material;\n}\n\nvec3 lighting (Ray ray, Light light, Material material) {\n\t\n    vec3 lightDirection = normalize(light.position - ray.position);\n\tvec3 rayDirection_ref = reflect (ray.direction, ray.normal);\n    \n\tfloat diffuse = max(dot (ray.normal, lightDirection), .0);\n\tfloat specular = pow (max (dot (rayDirection_ref, lightDirection), .0), material.shininess);\n\n    vec3 color = vec3(0);\n\tcolor += material.colorAmbient * material.colorDiffuse * light.color;\n    color += material.colorDiffuse * diffuse * light.color;\n\tcolor += material.colorSpecular * specular;  \n    return color;\n}\n//Цвет отражений\nvec3 rayReflect(in Ray ray, in Light light) {\n\t//Цвет отражений\n\tvec3 color = vec3(0);\n\t//Фактор отражения\n\tfloat factorReflect = 1.0;\n\t\n\tfor (int i=0; i<4; i++) {\n\t\t\n\t\trayMarch (ray);\n\t\t\n\t\tif (ray.hit) {\n\t\t\tMaterial material = getMaterial(ray);\n\t\t\tcolor += factorReflect * lighting(ray, light, material);\n\t\t\tfactorReflect *= material.reflectivity;\n\t\t\tif (factorReflect < 0.01) break;\n\t\t\t//Следующий луч\n\t\t\t{\n\t\t\t\tray.origin \t\t= ray.position;\n\t\t\t\tray.direction \t= reflect (ray.direction, ray.normal);\n\t\t\t\tray.near \t\t= 0.01; //Отступ\n\t\t\t}\n\t\t} else {\n\t\t\tcolor += factorReflect * texture(iChannel0, ray.direction).rgb;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn color;\n}\n//Цвет преломлений\nvec3 rayRefract(in Ray ray, in Light light) {\n\tvec3 color = vec3(0);\n\t//Фактор преломления\n\tfloat factorRefract = 1.0;\n\t\n\tfor (int i=0; i<4; i++) {\n\t\t//Пересечение луча с фигурой\n\t\trayMarch (ray);\n\t\t\n\t\tif (ray.hit) {\n\t\t\t//Достигли границы 1 фигуры\n\t\t\tMaterial material = getMaterial(ray);\n\t\t\t//Уменьшаем фактор преломления\n\t\t\tfactorRefract *= material.refractivity;\n\t\t\tif (factorRefract < 0.01) break;\n\t\t\t\n\t\t\t//Луч преломления сквозь границу 1 фигуры\n\t\t\t{\n\t\t\t\tray.origin \t\t= ray.position;\n\t\t\t\tray.direction \t= refract (ray.direction, ray.normal, material.indexRefractive);\n\t\t\t\tray.near \t\t= 0.01; //Отступ\n\t\t\t}\n\t\t\t//Пересечение луча с границей 2 той же фигуры \n\t\t\trayMarch (ray);\n            \n\t\t\tif (material.flagSolid == false) {\n\t\t\t\t\n\t\t\t\tif (ray.hit) {\n\t\t\t\t\t//Достигли границы 2 фигуры\n\t\t\t\t\t//Луч преломления сквозь границу 2 фигуры\n\t\t\t\t\t{\n\t\t\t\t\t\tray.origin \t\t= ray.position;\n\t\t\t\t\t\tray.direction \t= refract (ray.direction, ray.normal, material.indexRefractive);\n\t\t\t\t\t\tray.near \t\t= 0.01; //Отступ\n\t\t\t\t\t}\n\t\t\t\t\t//Уменьшаем фактор преломления\n\t\t\t\t\tfactorRefract *= material.refractivity;\n\t\t\t\t\t//Цвет за границей 2 фигуры\n\t\t\t\t\tcolor += factorRefract * rayReflect(ray, light);\n\t\t\t\t\t\n\t\t\t\t\t//Луч отражения от границы 2\n\t\t\t\t\t{\n\t\t\t\t\t\tray.origin \t\t= ray.position;\n\t\t\t\t\t\tray.direction \t= reflect (ray.direction, ray.normal);\n\t\t\t\t\t\tray.near \t\t= 0.01; //Отступ\n\t\t\t\t\t}\n\t\t\t\t\t//Отражение от границы 2\n\t\t\t\t\trayMarch (ray);\n\t\t\t\t\t\n\t\t\t\t\tif (ray.hit) {\n\t\t\t\t\t\t//Отраженный луч достиг границы 1 фигуры\n\t\t\t\t\t\t//Луч преломления сквозь границу 1 фигуры\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tray.origin \t\t= ray.position;\n\t\t\t\t\t\t\tray.direction \t= refract (ray.direction, ray.normal, material.indexRefractive);\n\t\t\t\t\t\t\tray.near \t\t= 0.01; //Отступ\n\t\t\t\t\t\t}\n\t\t\t\t\t\t//Уменьшаем фактор преломления\n\t\t\t\t\t\tfactorRefract *= material.refractivity;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tcolor += factorRefract * rayReflect(ray, light);\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn color;\n}\n\nvoid mainImage( out vec4 GL_FragColor, in vec2 GL_FragCoord ) {\n    //Адаптер\n    u_time = iTime;\n    vec2 u_canvas = iResolution.xy;\n    vec3 u_mouse  = iMouse.xyz;    \n    \n    float aspect = u_canvas.x/u_canvas.y;\n    vec2 uv = GL_FragCoord.xy / u_canvas.xy;\n    uv = uv - 0.5;\n\n    vec3 mouse = u_mouse / vec3(u_canvas, 1.0);\n    mouse.z = mod(mouse.z, 2.);\n\n    //Периодически меняем свойство центрального шара\n    float time = mod(ceil(u_time/4.), 2.);\n    material_sphere_0.flagSolid = time==1.; //Пустотелый/Полнотелый\n    \n    //Формируем камеру\n    Camera cam;\n    {\n        cam.fov     = 45.;\n        cam.aspect  = aspect;\n        cam.origin  = vec3(0, 1.5, 3);\n        if (mouse.z != 0.0) {\n            rotate(cam.origin, vec3(1,1,0) * vec3(PI/3. + mouse.y*PI, mouse.x*2.*PI, 0));\n        } else {\n            rotate(cam.origin, vec3(0,1,0) * u_time * 0.2);            \n        }\n        cam.target  = vec3(0,0,0);\n        cam.up \t\t= vec3(0,1,0);\n    }\n    \n\t//Формируем луч\n    Ray ray = lookAt(uv, cam);\n    {\n        ray.near \t= 0.0;\n        ray.far  \t= 10.;\n        ray.epsilon = 0.001;\n        ray.steps \t= 1;\n    }\t\n\n    vec3 color = vec3(0);\n\n    //Отражение лучей\n    color += rayReflect(ray, light);\n    //Преломление лучей\n    color += rayRefract(ray, light);\n\n    GL_FragColor = vec4(color,1.0);\n\n}","name":"Image","description":"","type":"image"}]}