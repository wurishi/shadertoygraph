{"ver":"0.1","info":{"id":"4ssBRs","date":"1497836334","viewed":590,"name":"The Quest for a Better Starfield","username":"Ebanflo","description":"Update: figured out why the parallax was wrong. Still contemplating the the issue with the projection singularity","likes":1,"published":3,"flags":32,"usePreview":0,"tags":["starfield"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float TwinkleFrequency = 3.0;\nint FractalIterations = 7;\nfloat NebulaThickness = 0.8;\n\nconst vec4 pi = vec4(0,2,4,8)*atan(1.0);\n\nvec4 hBlur(vec2 uv, float blurParam){\n    vec4 result = vec4(0.0);\n    for(int n = -16; n < 17; n++){\n        float x = float(n);\n        result += 0.5 * exp(-x * x * blurParam) * \n            texture(iChannel0, vec2(uv.x + 2.0 * float(n) / iResolution.x, uv.y));\n    }\n    return result * .5;\n}\n\nvec4 vBlur(vec2 uv, float blurParam){\n    vec4 result = vec4(0.0);\n    for(int n = -16; n < 17; n++){\n        float x = float(n);\n        result += 0.5 * exp(-x * x * blurParam) * \n            texture(iChannel0, vec2(uv.x, uv.y + 2.0 * float(n) / iResolution.y));\n    }\n    return result * .5;\n}\n\nvec3 hash32(vec2 p)//Dave_Hoskin's https://www.shadertoy.com/view/4djSRW\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+19.19);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\nvec3 hashNoise(vec2 x){\n    x *= 5.0;\n    vec2 f = fract(x);\n    f = smoothstep(0.0, 1.0, f);\n    vec2 i = floor(x);\n    vec3 b = mix(hash32(i), hash32(i + vec2(1.0, 0.0)), f.x);\n    vec3 t = mix(hash32(i + vec2(0.0, 1.0)), hash32(i + vec2(1.0)), f.x);\n    return mix(b, t, f.y);\n}\n\nvec3 fractalNoise(vec2 x){\n    vec3 acc = vec3(0.0);\n    float scale = 1.0;\n    for(int n = 0; n < FractalIterations; n++){\n        acc += hashNoise(scale * x) / scale;\n        scale *= 2.0;\n    }\n    return acc * .5;\n}\n\nvec3 hsv2rgb(in vec3 c){\n\treturn c.z*mix(vec3(1),0.5+0.5*sin(c.x+pi.xzw*2.0/3.0),c.y);\n}\n\nvec3 triplanarMap(vec3 n){\n    float s1 = smoothstep(0., 1.0, abs(n.x));\n    float s2 = smoothstep(0., 1.0, abs(n.y));\n    float s3 = smoothstep(0., 1.0, abs(n.z));\n    float temp = s1 + s2 + s3;\n    vec3 col1 = s1 * fractalNoise(n.yz);\n    vec3 col2 = s2 * fractalNoise(n.xz);\n    vec3 col3 = s3 * fractalNoise(n.xy);\n    vec3 col = col1 + col2 + col3;\n    return hsv2rgb(col/temp).gbr;\n}\n\nvec3 nebula(vec3 rd){return smoothstep(1.0 - NebulaThickness, 1.0, triplanarMap(rd));}\n\nvec3 r(vec3 v, vec2 r){//rodolphito's rotation\n    vec4 t = sin(vec4(r, r + 1.5707963268));\n    float g = dot(v.yz, t.yw);\n    return vec3(v.x * t.z - g * t.x,\n                v.y * t.w - v.z * t.y,\n                v.x * t.x + g * t.z);\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord){\n    vec2 uv = fragCoord / iResolution.xy;\n    float blurParam = .005 + .0025 * sin(10.0 * dot(vec2(cos(iTime), sin(iTime)), uv - .5) \n                                         + TwinkleFrequency * 6.283185307179586 * iTime);\n    fragColor = hBlur(uv, blurParam);\n    fragColor += vBlur(uv, blurParam);\n    fragColor *= .5;\n    fragColor += texture(iChannel0, uv);\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 xy = 2.0 * uv - vec2(iResolution.x / iResolution.y, 1.0);\n    vec3 rd = normalize(vec3(xy, 2.0));\n    vec2 m = (2.0 * iMouse.xy - iResolution.xy) / iResolution.y;\n    m *= 2.0;\n    rd = r(rd, m);\n    fragColor.xyz += nebula(rd);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//Buffer for storing star position and color\n\nvec3 decode(vec2 n){//rodolphito's Lambert-Azimuthal projection\n    float z=0.5-dot(n,n);\n    return vec3(n*sqrt(z+0.5),z)*2.0;\n}\n\nvec2 hash21(float p){\n\tvec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nvec3 rand3dunit(float p){//rodolphito's random unit vector fcn\n  vec3 r = hash21(p).xxy * 2.0 + vec3(0.5, 0.0, -1.0);\n  r.xy = sin(r.xy * 3.141592654) * sqrt(1.0 - r.z * r.z);\n  return r;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(1.0);\n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 xy = 2.0 * uv - 1.0;\n    fragColor = texture(iChannel0, uv);\n    if(iFrame > 30 && iFrame < 316){\n        vec3 dir = decode(xy);\n        vec3 pos = rand3dunit(float(iFrame));\n\t\tfloat f = dot(dir, pos);\n\t\tfragColor += pow(texture(iChannel1, vec2(float(iFrame - 30) / 256.0, .125)),\n                         100000.0 * vec4(.5 + .5 * f));\n    }\n        \n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"//Buffer for decoding star position and color based on camera direction\n\n//rodolphito's Lambert-Azimuthal Projection\nvec2 encode(vec3 n){return n.xy * inversesqrt(n.z * 2.0 + 2.0);}\n\nvec3 r(vec3 v, vec2 r){//rodolphito's rotation\n    vec4 t = sin(vec4(r, r + 1.5707963268));\n    float g = dot(v.yz, t.yw);\n    return vec3(v.x * t.z - g * t.x,\n                v.y * t.w - v.z * t.y,\n                v.x * t.x + g * t.z);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 xy = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n    vec2 m = (2.0 * iMouse.xy - iResolution.xy) / iResolution.y;\n    vec3 rd = normalize(vec3(xy, 2.0));\n    m *= 2.0;\n    rd = r(rd, m);\n    fragColor = texture(iChannel0, .5 + .5 * encode(rd));\n}","name":"Buffer B","description":"","type":"buffer"}]}