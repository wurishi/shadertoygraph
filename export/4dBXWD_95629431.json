{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"// Spherical polyhedra by nimitz (twitter: @stormoid)\n// https://www.shadertoy.com/view/4dBXWD\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n// Contact the author for other licensing options\n\n/*\n\tFollow up to my \"Sphere mappings\" shader (https://www.shadertoy.com/view/4sjXW1)\n\t\n\tI was thinking about a cheap way to do icosahedral mapping and realized\n\tI could just project on an axis and rotate the sphere for each projected\n\t\"facet\".\n\t\n\tHere I am showing only tilings of the regular polyhedra but this technique can\n\tbe used for any tilings of the sphere, regular or not. (or even arbitrary projections)\n\n\tI omitted the tetraedron since the small number of projections\n\tresults in heavy deformation.\n\n\tPerhaps there is a way to make that process cheaper? Let me know.\n*/\n\n#define time iTime\n\nmat2 mm2(in float a){float c = cos(a), s = sin(a);return mat2(c,-s,s,c);}\nvec3 rotx(vec3 p, float a){ float s = sin(a), c = cos(a);\n    return vec3(p.x, c*p.y - s*p.z, s*p.y + c*p.z); }\nvec3 roty(vec3 p, float a){ float s = sin(a), c = cos(a);\n    return vec3(c*p.x + s*p.z, p.y, -s*p.x + c*p.z); }\nvec3 rotz(vec3 p, float a){ float s = sin(a), c = cos(a);\n    return vec3(c*p.x - s*p.y, s*p.x + c*p.y, p.z); }\n\n//---------------------------Textures--------------------------------\n//-------------------------------------------------------------------\nvec3 texpent(in vec2 p, in float idx)\n{   \n    float siz = iResolution.x *.007;\n    vec2 q = abs(p);\n    float rz = sin(clamp(max(max(q.x*1.176-p.y*0.385, q.x*0.727+p.y),\n                             -p.y*1.237)*33.,0.,25.))*siz+siz;\n    vec3 col = (sin(vec3(1,1.5,5)*idx)+2.)*(rz+0.25);\n    col -= sin(dot(p,p)*10.+time*5.)*0.4;\n\treturn col;\n}\n\nvec3 textri2(in vec2 p, in float idx)\n{   \n    float siz = iResolution.x *.007;\n    vec2 q = abs(p);\n    float rz = sin(clamp(max(q.x*1.73205+p.y, -p.y*2.)*32.,0.,25.))*siz+siz;\n    vec3 col = (sin(vec3(1,1.7,5)*idx)+2.)*(rz+0.25);\n    col -= sin(p.x*20.+time*5.)*0.2;\n    return col;\n}\n\nvec3 texcub(in vec2 p, in float idx)\n{   \n    float siz = iResolution.x *.007;\n    float rz = sin(clamp(max(abs(p.x),abs(p.y))*24.,0.,25.))*siz+siz;\n    vec3 col = (sin(vec3(4,3.,5)*idx*.9)+2.)*(rz+0.25);\n    float a= atan(p.y,p.x);\n    col -= sin(a*15.+time*11.)*0.15-0.15;\n    return col;\n}\n\nvec3 textri(in vec2 p, in float idx)\n{\t\n    float siz = iResolution.x *.001;\n    p*=1.31;\n    vec2 bp = p;\n    p.x *= 1.732;\n\tvec2 f = fract(p)-0.5;\n    float d = abs(f.x-f.y);\n    d = min(abs(f.x+f.y),d);\n    \n    float f1 = fract((p.y-0.25)*2.);\n    d = min(d,abs(f1-0.5));\n    d = 1.-smoothstep(0.,.1/(siz+.7),d);\n    \n    vec2 q = abs(bp);\n    p = bp;\n    d -= smoothstep(1.,1.3,(max(q.x*1.73205+p.y, -p.y*2.)));\n    vec3 col = (sin(vec3(1.,1.5,5)*idx)+2.)*((1.-d)+0.25);\n    col -= sin(p.x*10.+time*8.)*0.15-0.1;\n    return col;\n}\n\n//----------------------------------------------------------------------------\n//----------------------------------Sphere Tilings----------------------------\n//----------------------------------------------------------------------------\n\n//All the rotation matrices can be precomputed for better performance.\n\n//5 mirrored pentagons for the dodecahedron\nvec3 dod(in vec3 p)\n{\n    vec3 col = vec3(1);\n    vec2 uv = vec2(0);\n    for (float i = 0.;i<=4.;i++)\n    {\n        p = roty(p,0.81);\n        p = rotx(p,0.759);\n        p = rotz(p,0.3915);\n    \tuv = vec2(p.z,p.y)/((p.x));\n    \tcol = min(texpent(uv,i+1.),col);\n    }\n    p = roty(p,0.577);\n    p = rotx(p,-0.266);\n    p = rotz(p,-0.848);\n    uv = vec2(p.z,-p.y)/((p.x));\n   \tcol = min(texpent(uv,6.),col);\n    \n    return 1.-col;\n}\n\n//10 mirrored triangles for the icosahedron\nvec3 ico(in vec3 p)\n{\n    vec3 col = vec3(1);\n    vec2 uv = vec2(0);\n    \n    //center band\n    const float n1 = .7297;\n    const float n2 = 1.0472;\n    for (float i = 0.;i<5.;i++)\n    {\n        if(mod(i,2.)==0.)\n        {\n            p = rotz(p,n1);\n        \tp = rotx(p,n2);\n        }\n\t\telse\n        {\n            p = rotz(p,n1);\n        \tp = rotx(p,-n2);\n        }\n        uv = vec2(p.z,p.y)/((p.x));\n    \tcol = min(textri(uv,i+1.),col);\n    }\n    p = roty(p,1.048);\n    p = rotz(p,.8416);\n    p = rotx(p,.7772);\n    //top caps\n    for (float i = 0.;i<5.;i++)\n    {\n        p = rotz(p,n1);\n        p = rotx(p,n2);\n\n    \tuv = vec2(p.z,p.y)/((p.x));\n    \tcol = min(textri(uv,i+6.),col);\n    }\n    \n    return 1.-col;\n}\n\n//4 mirrored triangles for octahedron\nvec3 octa(in vec3 p)\n{\n    vec3 col = vec3(1);\n    vec2 uv = vec2(0);\n    const float n1 = 1.231;\n    const float n2 = 1.047;\n    for (float i = 0.;i<4.;i++)\n    {\n       \tp = rotz(p,n1);\n       \tp = rotx(p,n2);\n    \tuv = vec2(p.z,p.y)/((p.x));\n    \tcol = min(textri2(uv*.54,i+1.),col);\n    }\n    \n    return 1.-col;\n}\n\n//cube using the same technique for completeness\nvec3 cub(in vec3 p)\n{\n    vec3 col = vec3(1);\n    vec2 uv = vec2(p.z,p.y)/((p.x));\n   \tcol = min(texcub(uv*1.01,15.),col);\n    p = rotz(p,1.5708);\n    uv = vec2(p.z,p.y)/((p.x));\n   \tcol = min(texcub(uv*1.01,4.),col);\n    p = roty(p,1.5708);\n    uv = vec2(p.z,p.y)/((p.x));\n    col = min(texcub(uv*1.01,5.),col);\n    \n    return 1.-col;\n}\n\n//----------------------------------------------------------------------------\n//----------------------------------------------------------------------------\n\nvec2 iSphere2(in vec3 ro, in vec3 rd)\n{\n    vec3 oc = ro;\n    float b = dot(oc, rd);\n    float c = dot(oc,oc) - 1.;\n    float h = b*b - c;\n    if(h <0.0) return vec2(-1.);\n    else return vec2((-b - sqrt(h)), (-b + sqrt(h)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n\tvec2 p = fragCoord.xy/iResolution.xy-0.5;\n    vec2 bp = p+0.5;\n\tp.x*=iResolution.x/iResolution.y;\n\tvec2 um = iMouse.xy / iResolution.xy-.5;\n\tum.x *= iResolution.x/iResolution.y;\n\t\n    //camera\n\tvec3 ro = vec3(0.,0.,3.5);\n    vec3 rd = normalize(vec3(p,-1.4));\n    mat2 mx = mm2(time*0.25+um.x*6.);\n    mat2 my = mm2(time*0.27+um.y*6.); \n    ro.xz *= mx;rd.xz *= mx;\n    ro.xy *= my;rd.xy *= my;\n    \n    float sel = mod(floor((time+10.)*0.2),4.);\n    //sel=0.;\n    vec2 t = iSphere2(ro,rd);\n    vec3 col = vec3(0.);\n    float bg = clamp(dot(-rd,vec3(0.577))*0.3+.6,0.,1.);\n    if (sel == 0.) col = dod(rd)*1.2;\n    else if (sel == 1.) col = ico(rd)*1.2;\n    else if (sel == 2.) col = cub(rd)*1.2;\n    else if (sel == 3.) col = octa(rd)*1.2;\n    \n    if (t.x > 0.)\n    {\n    \tvec3 pos = ro+rd*t.x;\n        vec3 pos2 = ro+rd*t.y;\n        vec3 rf = reflect(rd,pos);\n        if (sel == 0.)\n        {\n            vec3 col2 = max(dod(pos)*2.,dod(pos2)*.6);\n            col = mix(max(col,col2),col2,0.6);\n        }\n        else if (sel == 1.)\n        {\n            vec3 col2  = max(ico(pos2)*0.6,ico(pos)*2.);\n            col = mix(max(col,col2),col2,0.6);\n        }\n        else if (sel == 2.)\n        {\n            vec3 col2  = max(cub(pos2)*0.6,cub(pos)*2.);\n            col = mix(max(col,col2),col2,0.6);\n        }\n        else if (sel == 3.) \n        {\n            vec3 col2  = max(octa(pos2)*0.6,octa(pos)*2.);\n            col = mix(max(col,col2),col2,0.6);\n        }\n    }\n    \n\tfragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"4dBXWD","date":"1411926898","viewed":6542,"name":"Spherical polyhedra","username":"nimitz","description":"Follow up to my \"Sphere mappings\" shader (https://www.shadertoy.com/view/4sjXW1).  Projecting the regular convex polyhedra onto a sphere, perhaps dodecaheral spheremaps could be better than cubemaps for some applications.  Drag to rotate.","likes":162,"published":1,"flags":0,"usePreview":0,"tags":["3d","sphere","tilings","polyhedra"],"hasliked":0,"parentid":"","parentname":""}}