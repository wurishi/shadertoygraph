{"ver":"0.1","info":{"id":"ttyGRm","date":"1578512572","viewed":150,"name":"Simple 3d XOR Pattern Sphere","username":"gPlatl","description":"Basic frame for a simple interactive skybox view with an antialiased sphere that has a 3d XOR pattern.\nChange view by moving around with your mouse.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["3d","simple","interactive","cubemap","raymarcher","xor","pattern","skybox","view"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n//----------------------------------------------------------\n// Simple3dXORPatternSphere.glsl       by Gerd Platl\n//\n// Basic frame for a simple interactive skybox view\n// with an antialiased sphere that has a 3d XOR pattern.\n// Change view by moving around with your mouse.\n//\n// Modification of https://www.shadertoy.com/view/4lV3Wc\n//\n//   v1.0  2020-01-08  initial version\n//   \n// tags: 3d, simple, interactive, skybox, view, cubemap, \n//       raymarcher, XOR, pattern\n//----------------------------------------------------------\n\nconst vec4  skyboxColor  = vec4(0.80, 0.96, 1.00, 1.0);\nconst vec4  sphereColor  = vec4(0.80, 0.70, 0.70, 1.0);\nconst float sphereRadius = 3.3;\n\n//------- ray ------- \nstruct Ray\n{\n  vec3 origin;\n  vec3 direction;\n};\nRay camera = Ray(vec3(0), vec3(0,0,1));\n\n// get sphere distance\nfloat sphere(vec3 p)\n{ return length(p) - sphereRadius; }\n\n// raymarcher from rayOrigin with rayDirection,\n// return sphere intersection distance factor\nfloat raymarch()\n{\n  float d = 0.0, t = 0.0;\n  for(int i = 0; i < 32; ++i)\n  {\n    d = sphere(camera.origin + t * camera.direction);\n    if(abs(d) < 0.01) return t;\n    if(t > 100.0) return -1.0;\n    t += d;\n  }\n  return -1.0;  // no intersection\n}\n\n// get surface normal vector\nvec3 getNormalStd (in vec3 p)\n{\n  float d = sphere(p);\n  vec3 eps = vec3(0.0001, 0.0, 0.0);\n  return normalize(vec3(\n           d - sphere(p - eps.xyy),\n           d - sphere(p - eps.yxy),\n           d - sphere(p - eps.yyx)));\n}\n\n// get surface normal vector with tetrahedron technique \nvec3 getNormal (in vec3 p)   \n{ const vec2 k = vec2(0.01,-0.01);\n  return normalize (k.xyy*sphere(p+k.xyy) \n                   +k.yyx*sphere(p+k.yyx)\n                   +k.yxy*sphere(p+k.yxy)\n                   +k.xxx*sphere(p+k.xxx)); }\n\n// get camera data\nvoid getCamera(vec2 coord)\n{\n  vec2 uv = (coord * 2.0 - iResolution.xy) / iResolution.y;\n  vec2 mo = iMouse.xy / iResolution.y * 3.5;\n  if (mo == vec2(0)) mo = vec2(0,1.75);\n  vec3 ro = 5.0 * vec3(sin(mo.x), 2.0-mo.y, cos(mo.x));\n  vec3 z = normalize(ro);\n  vec3 x = normalize(cross(vec3(0.0, 1.0, 0.0), z));\n  vec3 rd = mat3(x, cross(z, x), z) * vec3(uv, -1.0);\n  camera = Ray(ro,rd);\n}\n       \n// get hue-saturation-value color\nvec3 hsv(float h, float s, float v)\n{\n  vec3 c = abs(fract(h+vec3(3.0, 2.0, 1.0)/3.0)*6.0-3.0);  \n  return mix(vec3(1.0),clamp((c-1.0), 0.0, 1.0),s)*v;\n}\n\n// return intensity of \nfloat XORPattern3d(vec3 pos)\n{\n  float an = 0.5; //smoothstep(-1.5, 1.5, cos(3.14159*iTime));\n  float x = 0.0;\n  for( int i=0; i<7; i++ ) \n  {\n    vec3 a=floor(pos);      \n    vec3 b=fract(pos);      \n\n    x += mod(a.x + a.y + a.z, 2.0) \n       * mix(1.0, 1.5*pow(4.0 *(1.0-b.x)*b.x \n                              *(1.0-b.y)*b.y\n                              *(1.0-b.z)*b.z, 0.25), an);\n    pos /= 2.0;\n    x /= 2.0;\n  }\n  return x;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n  getCamera(fragCoord);\n\n  float t = raymarch();   // get sphere distance factor\n  vec3 ro = camera.origin;\n  vec3 rd = camera.direction;\n  // get skybox pixel color\n  fragColor = texture(iChannel0, rd) * skyboxColor;\n\n  if(t > 0.0)               // sphere intersection ?\n  {\n    vec3 p = ro + t * rd;   // intersection point\n    vec3 n = getNormal(p);  // surface normal\n    rd = reflect(rd, n);    // reflection vector\n    vec4 refColor; \n    refColor = vec4(hsv(fract(0.1*iTime),0.4,1.), 1.); // color cycling \n//  refColor = texture(iChannel0, rd) * refColor;  // sphere reflection\n    refColor *= XORPattern3d(77.*p);\n//  refColor = vec4(sin(rd*22.), 1.0);  // funny colors 1\n//  refColor = vec4(mod(rd,1.0) ,0.5);  // funny colors 2\n    float d = 3.2 * dot(rd, n);   // sphere antialiasing\n    fragColor = mix(fragColor, refColor, smoothstep(0.,1.,d));\n  }\n}\n","name":"Image","description":"","type":"image"}]}