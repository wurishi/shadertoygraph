{"ver":"0.1","info":{"id":"ddyBWd","date":"1702591825","viewed":56,"name":"Hexagon ray experiment","username":"Krafpy","description":"Hexagons are the bestagons. Attempt at raycasting through a hexagonal grid with a custom method based on circle intersection. See: https://editor.p5js.org/krafpy/sketches/TQhvnNLGk","likes":11,"published":1,"flags":0,"usePreview":0,"tags":["ray","grid","intersection","hexagon"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define SQRT32 0.86602540378\n#define SQRT3 1.73205080757\n#define RI 0.5\n#define RC (RI/SQRT32)\n\n\nfloat hexDist(vec2 p){\n    p = abs(p);\n    return max(p.x, 0.5*(p.x + SQRT3*p.y));\n}\n\n\n// xy = center of the hexagon, zw = coordinates relative to hexagon center\nvec4 hexCell(vec2 p){\n    vec2 s = vec2(1., SQRT3);\n    vec2 h = s*0.5;\n    vec2 a = mod(p, s) - h;\n    vec2 b = mod(p + h, s) - h;\n    vec2 i = p/s;\n    float sa = step(dot(a, a), dot(b, b));\n    float sb = 1. - sa;\n    vec2 f = sa*floor(i) + sb*floor(i+0.5);\n    vec2 c = f*s + sa*h;\n    return vec4(c, sa*a + sb*b);\n}\n\nfloat sphIntersect(vec2 ro, vec2 rd){\n    float b = dot(ro, rd);\n    float c = dot(ro, ro) - RC*RC;\n    float delta = b*b - c;\n    return sqrt(delta) - b;\n}\n\nvec2 hexNormal(vec2 p) {\n    float k = step(0.5*RC, abs(p.y));\n    return sign(p)*vec2(1.-0.5*k, k*SQRT32);\n}\n\n// visualization: https://editor.p5js.org/krafpy/sketches/TQhvnNLGk\nfloat hexIntersect(vec2 ro, vec2 rd){\n    float t = sphIntersect(ro, rd);\n    vec2 n = hexNormal(ro + rd*t);\n    return (RI - dot(ro, n))/dot(rd, n);\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= 0.5;\n    uv.x *= iResolution.x/iResolution.y;\n    uv *= 5.;\n    \n    vec3 col = vec3(0.);\n    \n    // hex tiling\n    vec4 c0 = hexCell(uv);\n    float hexd = hexDist(c0.zw);\n    col = vec3(smoothstep(-0.1,0.5,hexd));\n    col *= step(hexd, 0.49);\n    col *= smoothstep(0.8,0.2,1.-hexd);\n    col = mix(col, vec3(1.), 1. - 1.25*distance(uv, c0.xy));\n    \n    \n    vec2 a = 1.*vec2(cos(0.2*iTime), sin(0.2*iTime));\n    vec2 b = 2.*vec2(cos(0.4*iTime), sin(0.4*iTime));\n    \n    vec2 ro = a;\n    vec2 rd = normalize(b-a);\n    \n    float d;\n    \n    d = distance(ro, c0.xy);\n    float f = smoothstep(0.5, 2., d);\n    col = mix(col*vec3(1.,0.6,0.4), col*vec3(0.6,0.8,1.), f);\n    \n    // ray line\n    d = distance(uv, ro + max(0., dot(uv-ro, rd))*rd);\n    float s = smoothstep(-0.15,0.15,d);\n    col *= s;\n    col = mix(col, vec3(0.,1.,0.), step(d, 0.02));\n    \n    // intersections\n    float t = 0.;\n    for(int i = 0; i < 10; i++){\n        vec2 p = ro + rd*t;\n        vec4 c = hexCell(p);\n        float it = hexIntersect(c.zw, rd);\n        d = distance(uv, p + rd*it);\n        s = smoothstep(-0.1,0.15,d);\n        col *= s;\n        col = mix(col, vec3(1.,1.,0.), step(d, 0.07));\n        t += it + 0.0001;\n    }\n    \n    // ray origin\n    d = distance(uv, ro);\n    s = smoothstep(-0.05,0.2,d);\n    col *= s;\n    col = mix(col, vec3(0.,1.,0.), step(d, 0.1));\n    \n\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}