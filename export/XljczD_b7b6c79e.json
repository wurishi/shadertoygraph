{"ver":"0.1","info":{"id":"XljczD","date":"1507719020","viewed":839,"name":"Liquid Springs II","username":"aaaidan","description":"It's messed up how easily a bit of specularity and refraction make it look like water.\n\nWave equation where Buffer A represents height (R channel), and vertical velocity (B channel) using 3x3 kernel and Euler integration. ","likes":38,"published":1,"flags":48,"usePreview":0,"tags":["water","physics","buffer","harmonic","springs","shm"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n * HEY! CLICK AND DRAG!\n * Holding SHIFT shows the underlying model.\n * SPACEBAR resets the water.\n *\n * Modify Buf B to change the barriers, or add new ones.\n */\n\n/*\n * This program renders the \"model\" buffers into a visual form.\n * It does refraction, specularity and draws the barriers.\n * The other buffer programs do everything else.\n */\n\nconst int KEY_SHIFT = 16;\n\n#define DEPTH_GAIN 20.0\n#define SPEC_GAIN 0.01\n\n// how refracty\n#define IOR 3.0 \n\n// how much more refracty for deep water\n#define DEPTH_REFRACTION 0.1\n\n// colour of liquid\n#define LIQUID_COLOR vec3(0.1,0.2,0.3)\n\nbool isBorder(in vec2 uv) {\n    return texture(iChannel2, uv).r > 0.5;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 uv_pixel = vec2(1.0) / iResolution.xy;\n    vec2 uv_dx = vec2( uv_pixel.x,        0.0 );\n    vec2 uv_dy = vec2(        0.0, uv_pixel.y );\n    \n    float seeModel = texelFetch( iChannel3, ivec2(KEY_SHIFT,0), 0 ).x;\n    \n    if (isBorder(uv)) {\n        fragColor = vec4(seeModel);\n        return;\n    }\n    \n    if (seeModel < 1.0) {\n        float depth      = texture(iChannel0, uv).r * DEPTH_GAIN;\n        float depthRight = texture(iChannel0, uv + uv_dx).r * DEPTH_GAIN;\n        float depthUp    = texture(iChannel0, uv + uv_dy).r * DEPTH_GAIN;\n        \n        float slopeRight = depthRight - depth;\n        float slopeUp    =    depthUp - depth;\n        \n        vec2 angle = vec2(atan(slopeRight), atan(slopeUp));\n        vec2 specularAngle = vec2(-0.5, 0.5);\n        float distanceToSpecular = distance(angle, specularAngle);\n        float specularity = 1.0 / pow(distanceToSpecular, 3.0);\n        \n        vec3 color = texture(iChannel1,\n                             uv + \n                             slopeRight * uv_dx * IOR * (depth*DEPTH_REFRACTION+1.0) + \n                             slopeUp    * uv_dx * IOR * (depth*DEPTH_REFRACTION+1.0)\n                            ).rgb;\n        color = mix(color,\n                    LIQUID_COLOR,\n                    1.0 - pow(0.9998, max(-10.0, 0.0 - depth * 3.0)) * 1.2 + 0.3\n                   );\n        vec3 specular = vec3(1.0,1.0,1.0) * specularity * SPEC_GAIN;\n        \n     \tfragColor = vec4(color + specular, 1.0);\n    } else {\n        fragColor = texture(iChannel0, uv).rbaa + 0.5;\n    }\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"/*\n * This buffer governs the water simulation and mouse interaction.\n */\n\nconst int KEY_SPACE = 32;\n\n#define CIRCLE_RADIUS 0.015\n#define MOVE_RADIUS 100.0\n\n#define ACCEL 6.0\n#define DAMP 0.995\n#define ACCEL_SCALE 0.4\n\nvec4 blend(in vec4 under, in vec4 over) {\n    float outA = over.a + under.a * (1.0 - over.a);\n    vec3 outCol = vec3(0.0);\n    if (outA > 0.0) {\n    \toutCol = ( over.rgb*over.a + under.rgb*under.a*(1.0-over.a) ) / outA;\n    }\n    return vec4(outCol,outA);\n}\n\nbool isBorder(in vec2 uv) {\n    return texture(iChannel1, uv).r > 0.5;\n}\n\nbool isDropletFrame() {\n    return iFrame > 0 && iFrame < 5;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    float resetModel = texelFetch( iChannel3, ivec2(KEY_SPACE,0), 0 ).x;\n    if (resetModel > 0.5) {\n        fragColor = vec4(0.0);\n        return;\n    }\n    \n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 uv_dx = vec2(1.0 / iResolution.x, 0.0);\n    vec2 uv_dy = vec2(0.0, 1.0 / iResolution.y);\n    bool border = isBorder(uv);\n    \n    vec4 lastFrameColor = texture(iChannel0, uv);\n    \n    vec2 circleCenter = isDropletFrame() ? vec2(0.25 * iResolution.x, 0.5 * iResolution.y) : iMouse.xy;\n    float distToCircle = length(fragCoord - circleCenter);\n    \n    float circleness;\n    if (iMouse.w > 0.0 || isDropletFrame()) {\n    \tcircleness = smoothstep((CIRCLE_RADIUS*iResolution.x), (CIRCLE_RADIUS*iResolution.x)-3.0, distToCircle);\n    } else {\n        circleness = 0.0;\n    }\n    \n\tfragColor = lastFrameColor;\n    \n    fragColor.r = fragColor.r + 0.08 * circleness;\n    fragColor.b = fragColor.b + 0.0 * circleness;\n    \n    float averageNeighbourHeight = fragColor.r;\n    averageNeighbourHeight += texture(iChannel0, uv + uv_dx).r;\n    averageNeighbourHeight += texture(iChannel0, uv - uv_dx).r;\n    averageNeighbourHeight += texture(iChannel0, uv + uv_dy).r;\n    averageNeighbourHeight += texture(iChannel0, uv - uv_dy).r;\n    \n    averageNeighbourHeight += texture(iChannel0, uv + uv_dx + uv_dy).r * 0.7;\n    averageNeighbourHeight += texture(iChannel0, uv - uv_dx + uv_dy).r * 0.7;\n    averageNeighbourHeight += texture(iChannel0, uv + uv_dx - uv_dy).r * 0.7;\n    averageNeighbourHeight += texture(iChannel0, uv - uv_dx - uv_dy).r * 0.7;\n    averageNeighbourHeight = (averageNeighbourHeight - 0.0) / (5.0 + 4.0 * 0.7);\n        \n    float accelAmt = averageNeighbourHeight - fragColor.r;\n    fragColor.b += accelAmt * ACCEL;\n    \n    if (border) {\n        fragColor.r = 0.0;\n        fragColor.b = 0.0;\n    }\n    \n    fragColor.r = fragColor.r * DAMP + 0.0;\n    fragColor.r += fragColor.b * ACCEL_SCALE;\n}","name":"Buf A","description":"","type":"buffer"},{"inputs":[],"outputs":[{"id":"XsXGR8","channel":0}],"code":"/*\n * This buffer defines barriers.\n */\n\n#define BARRIER_WIDTH 2.0\n#define NUM_BARRIERS 6.0\n#define BARRIER_HEIGHT 0.7\n\nbool isBorder(in vec2 fragCoord) {\n    bool border = fragCoord.x < BARRIER_WIDTH || fragCoord.x > iResolution.x - BARRIER_WIDTH ||\n        fragCoord.y < BARRIER_WIDTH || fragCoord.y > iResolution.y - BARRIER_WIDTH;\n    \n    float colSpacing = iResolution.x / NUM_BARRIERS;\n    float col2Spacing = colSpacing * 2.0;\n    \n    if ( mod(fragCoord.x,colSpacing) < BARRIER_WIDTH){\n        if ( mod(fragCoord.x, col2Spacing) > colSpacing) {\n            if (1.0 - fragCoord.y/iResolution.y < BARRIER_HEIGHT) {\n                border = true;\n            }\n        } else {\n            if (fragCoord.y/iResolution.y < BARRIER_HEIGHT) {\n                border = true;\n            }\n        }\n    }\n\n    \n    if (sin(fragCoord.x * 0.01 + fragCoord.y * 0.01) > 0.5) {\n        // border = true;\n    }\n    \n    return border;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(isBorder(fragCoord) ? 1.0 : 0.0);\n}","name":"Buf B","description":"","type":"buffer"}]}