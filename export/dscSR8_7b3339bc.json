{"ver":"0.1","info":{"id":"dscSR8","date":"1679362963","viewed":158,"name":"Ray Marching Shallow Water Model","username":"ijm","description":"Shallow Water Simulation with Ray Marching.\n\nControls:\n   click alown to 'ping' water\n\n   U/D + click to raise/lower sea floor. (click registration is hard for U/D!)\n   arrow key + click to ping in a direction.\n","likes":3,"published":1,"flags":48,"usePreview":0,"tags":["raymarching","shallowwater"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":2,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Description: Water Surface Rendering Experiment using a displaced plane SDFs.\n// License: Copyright (C) 2023 Ian McEwan. Distributed under the MIT License. \n\n// height  data in Chan0.w (bottom) and Chan3.w (water surface)\n//\n// This is a real mess right now while figuring out what works.\n// \n// ... oh ... for recursion ... and more texture buffers.\n// only one itteration of refraction or reflection for now.\n\n\n\nfloat sdfSphere(in vec3 p, in vec4 spec) {\n    return length(p - spec.xyz) - spec.w ;\n}\n\n\nfloat sdfDisplacedWater(in vec3 p) {\n  vec4 cur = texture(iChannel3, Doffset + p.xz * 0.02  );\n  \n  return p.y + cur.w*1.0 - 0.0;\n\n}\n\nfloat sdfDisplacedPlane(in vec3 p) {\n    float h = texture(iChannel0,Doffset + p.xz * 0.02  ).w* 0.02;\n    return p.y - 0.00 + h*8. ;\n}\n\n//int sdfComponents(out float d[AMIN_N],in vec3 p, in int ignore) {\nint sdfComponents(out float d[AMIN_N], vec3 p) {\n    d[SBottom] = sdfDisplacedPlane(p);\n    d[SWater] = sdfDisplacedWater(p);\n    d[SBall] = MAX_DIST; \n   // d[SBall] = sdfSphere(p, vec4( 0., 2., 10., 1.) );\n\n    \n    return 3; //count\n}\n\nfloat sdfAll(in vec3 p, bool mask[AMIN_N] ) {\n    float obs[AMIN_N];\n    float m;\n    \n    int i = sdfComponents(obs, p);\n    \n    bmin(m, obs, mask, i);\n    return m;\n}\nfloat sdfAll(in vec3 p) {\n    return sdfAll(p, mask_nall  );\n}\n\nint sdfAllInx(out float m, in vec3 p, bool mask[AMIN_N]) {\n    float obs[AMIN_N];\n    \n    int i = sdfComponents(obs, p);\n    \n    return bmin(m, obs, mask, i);\n}\n\n\n\nvec3 getNormal(vec3 p) {\n    const vec2 e = vec2(.001, 0);\n    \n    return normalize(\n        sdfAll(p) - vec3(\n        sdfAll(p-e.xyy),\n        sdfAll(p-e.yxy),\n        sdfAll(p-e.yyx))\n    );\n}\n\nivec2 march(inout vec4 o, in vec3 d, in bool mask[AMIN_N] ) {\n    int i, j;\n    vec4 p = o;\n    float s;\n\n    p.w = 0.;\n    \n    j = sdfAllInx(s, p.xyz, mask);\n    \n    for ( i = 0; \n        i < MAX_I && s > MIN_DIST && p.w < MAX_DIST ;\n        ++i\n    ) {  // avoid last 'tiny' step.\n        p.w += s;\n        p.xyz = o.xyz + d * p.w * 1.;\n        j = sdfAllInx(s,p.xyz, mask);\n    }\n    \n    if (s > MIN_DIST)\n        j = SMissed;\n        \n    o = p;\n    return ivec2(j,i);  \n}\n\nvec4 lnormalize(vec3 x) { // grr the comp should catch this.\n    float l = length(x);\n    return vec4( x/l, l) ;\n}\n\nvec3 mrefract(in vec3 p, in vec3 n, float a) {\n    vec3 nxp = cross(n,p);\n    return a*cross(n,-nxp) - n * sqrt( 1. - a*a*dot(nxp,nxp) );\n}\n\n\n    \nivec2 render(out vec3 col, out vec4 rtal, inout vec4 p, in vec3 dir, in bool[AMIN_N] mask){\n\n    ivec2 id = march(p , dir, mask);\n    \n    switch(id.x) {\n        case SMissed: // background\n            //col = vec3(0.1,0.1,0.1);\n            col = texture(iChannel2, dir).xyz;\n            rtal = vec4(0.,0.,1.,1.);\n            break;\n        case SBottom: // ground\n            float x = sin(p.x *8.0) + sin(p.z * 8.0);\n            x *= x;\n            col = vec3( x*0.5,0.5,0.5);\n            rtal = vec4( 0., 0., 1., 0. );\n            break;\n        case SWater: // water surface\n            col = vec3( 0.1, 0.2, 0.3 );\n            rtal = vec4( 0.4, 0.5, 0.9, 0. );\n            break;\n        case SBall: // sphere\n            col = vec3( 0., 0.5, 0.1 );\n            rtal = vec4( 0., 0., 1., 0. );\n            break;\n        default: break;\n    }\n    col *= rtal.z;\n    return id;\n}\n\nvec3 light(in vec4 p, in vec3 n, bool mask[AMIN_N] ) {\n    vec3 oLight = vec3(0.,6.,6.);\n    oLight.x += sin(iTime)*2.;\n    vec3 colD;\n    vec4 rtalD;\n    \n    vec4 dir = lnormalize(oLight - p.xyz);\n    ivec2 id = render(colD, rtalD, p, dir.xyz, mask);    \n    \n    return  vec3(1.0) *\n             clamp(dot(n, dir.xyz), 0., 1.);\n    }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n    vec2 uv = fragCoord / iResolution.xy;\n    vec3 xy = vec3( (fragCoord - 0.5*iResolution.xy)/iResolution.y, 1.0 );\n\n    vec3 oRay = vec3(0.,5.,0.);\n    vec3 dRay = normalize( xy - vec3(0.,0.4,0.) );\n    \n    vec3 c = vec3(0);\n    int steps;\n    vec3 n, col;\n    \n    vec4 p = vec4(oRay,0.);\n    bool mask[AMIN_N] = mask_nall;\n    vec4 rtal;\n    ivec2 id;\n    \n    id = render(col, rtal, p, dRay, mask); \n    \n    n = getNormal(p.xyz);\n    mask[id.x] = false;\n    vec3 sp = vec3(0.);\n    if ( id.x != SMissed ) {\n    vec3 diffuse = light(p, n, mask);\n    sp = diffuse * diffuse;\n    col *= diffuse ;//+ sp*sp;\n}\n    vec4 q ;\n    \n    if (rtal.x != 0.) {\n        sp *= sp;\n        sp *= sp;\n        sp *= sp;\n        col *= sp;\n        vec3 dRef = reflect(dRay, n) ;\n        vec3 colF;\n        vec4 rtalF;\n        q = p;\n        ivec2 jd = render(colF, rtalF, q, dRef, mask);\n        if ( jd.x != SMissed ) {\n\n            vec3 nR = getNormal(q.xyz);\n            colF *= light(q, nR, mask);\n            }\n\n        col += colF * rtal.x;\n        }\n        \n    if (rtal.y != 0.) {\n        vec3 dFrt = refract(dRay, n, 0.8) ;\n        vec3 colF;\n        vec4 rtalF;\n        q = p;\n        render(colF, rtalF, q, dFrt, mask);\n        col += colF * rtal.y;\n        }\n        \n\n    //col = vec3( id.y )* 0.01; // debug num steps\n    //col = vec3( id.x+1, -id.x, 0.) * 0.1; // debug ids.\n    fragColor = vec4(col,1.0);\n}\n\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// Description: Shallow Water Tendencies/derivatives section.\n// License: Copyright (C) 2023 Ian McEwan. Distributed under the MIT License. \n\n\n// Discretizaiton of simple non-conservative shallow water equations\n// without viscuious drag or Coriolis like forces.\n// Discretization choise is single difference in x and y. With a \n// second order two stage RK time stepping. Without more buffers it\n// doesn't seem feasible to shorhorn in more, leaving this code right\n// on the ragady edge of CFL stability.\n\nconst int SBall = 2, SWater = 1, SBottom = 0, SMissed = -1;\n\nconst float g = 0.1;  // restoration force\n\nconst float ds = 1.0;  // grid spacing\nconst float _ds = 1.0 / ds;\nconst float g_ds = g / ds;\n\nconst float k = 0.001; // friction loss\n\nconst float dt = 0.2;  // timestep\n\n//const vec3 tab = vec3( 0.5, 0.5, 1.0); // Heun\nconst vec3 tab = vec3( 0.25, 0.75, 2./3.); // Ralston\n\nvec2 Doffset = vec2(0.5,0.);\n\n\nconst int MAX_I = 50;\nconst float MIN_DIST = 0.01;\nconst float MAX_DIST = 100.;\nconst float MAXN_DIST = -MAX_DIST;\n\nconst int AMIN_N = 4;\nconst bool mask_nall[AMIN_N] = bool[AMIN_N](true,true,true,true);\n\n\nvec4 diff( in vec4 C, in vec4 C_W, in vec4 C_N, in vec2 h_ES, in vec3 ires,\n    in vec2 uv, in sampler2D c0) {\n    vec2 _res = 1.0 / ires.xy;    \n    vec2 ds = vec2(1.0, ires.x / ires.y ) ;\n\n    vec2 N = vec2(0.,1.)* _res;\n    vec2 S = vec2(0.,-1.)* _res;\n    vec2 E = vec2(1.,0.)* _res;\n    vec2 W = vec2(-1.,0.)* _res;\n    \n    vec4 inp = texture(c0, uv ); // w is H, xyz are input pulses.\n    vec4 inp_W = texture(c0, uv + W );\n    vec4 inp_N = texture(c0, uv + N );\n    \n    vec2 HC = max(inp.w + C.w,0.) * C.xy;\n    float Hu_C = HC.x;\n    float Hv_C = HC.y;\n    \n    float Hu_W = max(inp_W.w + C_W.w,0.) * C_W.x;\n    float Hv_N = max(inp_N.w + C_N.w,0.) * C_N.y;\n\n    float dh =  - ( (Hu_W - Hu_C)/ds.x + (Hv_N - Hv_C)/ds.y ) ;    \n    vec2 duv = (h_ES - C.ww) * g / ds - k*C.xy ;\n\n    return vec4(duv, 0., dh);\n}\n\n\nint bmin(out float m, in float[AMIN_N] obs, in bool[AMIN_N] mask, in int n) {\n    int j = 0, i = 1;\n    m = obs[0];\n    n = min(AMIN_N,n);\n    \n    for (;i < n;++i) {\n        if ( mask[i] && obs[i] < m )\n            m = obs[j=i];\n    }\n   \n   return j;\n}\n\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Description: User Input Shader\n// License: Copyright (C) 2023 Ian McEwan. Distributed under the MIT License. \n\nconst int KEY_U   = 85;\nconst int KEY_D   = 68;\nconst int KEY_LEFT   = 37;\nconst int KEY_RIGHT   = 39;\nconst int KEY_UP   = 38;\nconst int KEY_DOWN  = 40;\n\n// Due to shoehorning into ST I have to cut'n'past a lot of \n// this here just to get mouse registration ....\n\nfloat sdfPlane(in vec3 p) {\n    return p.y - 0.00 ;\n}\nfloat sdfDisplacedPlane(in vec3 p) {\n    float h = texture(iChannel0,Doffset + p.xz * 0.02  ).w* 0.02;\n    return p.y - 0.00 + h*8. ;\n}\nfloat sdfSphere(in vec3 p, in vec4 spec) {\n    return length(p - spec.xyz) - spec.w ;\n}\n//int sdfComponents(out float d[AMIN_N],in vec3 p, in int ignore) {\nint sdfComponents(out float d[AMIN_N], vec3 p) {\n    d[SBottom] = sdfDisplacedPlane(p);\n    d[SWater] = sdfPlane(p);\n    d[SBall] = sdfSphere(p, vec4( 0., 2., 10., 1.) );\n    \n    return 3; //count\n}\n\nint sdfAllInx(out float m, in vec3 p, bool mask[AMIN_N]) {\n    float obs[AMIN_N];\n    \n    int i = sdfComponents(obs, p);\n    \n    return bmin(m, obs, mask, i);\n}\n\n\nivec2 march(inout vec4 o, in vec3 d, in bool mask[AMIN_N] ) {\n    int i, j;\n    vec4 p = o;\n    float s;\n\n    p.w = 0.;\n    \n    j = sdfAllInx(s, p.xyz, mask);\n    \n    for ( i = 0; \n        i < MAX_I && s > MIN_DIST && p.w < MAX_DIST ;\n        ++i\n    ) {  // avoid last 'tiny' step.\n        p.w += s;\n        p.xyz = o.xyz + d * p.w * 1.;\n        j = sdfAllInx(s,p.xyz, mask);\n    }\n    \n    if (s > MIN_DIST)\n        j = SMissed;\n        \n    o = p;\n    return ivec2(j,i);  \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 muv = iMouse.xy/iResolution.xy;\n    \n    vec3 mxy = vec3( (iMouse.xy - 0.5*iResolution.xy)/iResolution.y, 1.0 );\n\n    vec3 oRay = vec3(0.,5.,0.);\n    vec3 dir = normalize( mxy - vec3(0.,0.4,0.) );\n    vec4 p;\n    p.xyz = oRay;\n    \n    vec4 env = texture(iChannel0, uv );\n    if( iMouse.z>0. ) { // mouse down\n\n\n    float ud = \n       texelFetch(iChannel1, ivec2(KEY_D, 0), 0).x -\n       texelFetch(iChannel1, ivec2(KEY_U, 0), 0).x;\n\n    float xu = \n       texelFetch(iChannel1, ivec2(KEY_RIGHT, 0), 0).x -\n       texelFetch(iChannel1, ivec2(KEY_LEFT, 0), 0).x;\n       \n    float xv = \n      - texelFetch(iChannel1, ivec2(KEY_UP, 0), 0).x +\n       texelFetch(iChannel1, ivec2(KEY_DOWN, 0), 0).x;\n    \n    float dx, dy, d2, dh;\n    vec2 dm;\n    env.xyz = vec3(0.);  \n       \n    if( ud == 0. && iMouse.w>0.0 ) {// button click\n        ivec2 id = march( p, dir, bool[4](true,true,true,true) );\n        if (id.x == SWater ) {       \n            vec2 mmxy = Doffset + p.xz * 0.02;\n            dm = mmxy - uv ;\n            d2 = dot(dm, dm);\n           \n            float du = exp( -d2 *30000.0 ) * 2.0;\n            env.x = -xu * du * 0.2;  // add momentary x velocity\n            env.y = -xv * du * 0.2; // add momentary y velocity\n            env.z = du; // add momentary z height\n        }\n    } else { // attempt to find the bottom, but alas no refraction.\n        bool mask[AMIN_N] = mask_nall;\n        mask[SWater] = false;\n        ivec2 id = march( p, dir, mask );\n        if (id.x == SBottom ) {       \n            vec2 mmxy = Doffset + p.xz * 0.02;\n            dm = mmxy - uv ;\n            d2 = dot(dm, dm);\n            dh = exp( -d2 *1000.0 ) * 1.0;\n       \n            env.w += ud * dh;     \n        }\n    }\nenv.w = clamp( env.w, -10.0,40.0);\n}\n\n\nif (iTime < 0.1) {\nenv = vec4(0.,0.,0.,20.0);\n}\n    fragColor = env;\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":3,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// Description: Derivative/Tendency step 'A' and h filtering.\n// License: Copyright (C) 2023 Ian McEwan. Distributed under the MIT License. \n\n// Setting up the derivative step is easyer than in the B derivative as\n// the data comes from the previous step and so is just texture lookups\n//\n// Filtering on the previous h value is just a guassian blur on the\n// height pertibation and is passed through to the time step shader; it\n// is not used in computing tendencies. This is enough to improve\n// stability wrt high frequency noise without smoothing out the \n// derivatives.\n\nvec2 kdir[9] = vec2[9](\n    vec2(-1.,1.), vec2(0.,1.), vec2(1.,1.),\n    vec2(-1.,0.), vec2(0.,0.), vec2(1.,0.),\n    vec2(-1.,-1.), vec2(0.,-1.), vec2(1.,-1.)\n);\n\n\nconst float kernal[9] = float[9](\n    1./16., 2./16., 1./16.,\n    2./16., 4./16., 2./16.,\n    1./16., 2./16., 1./16.\n);                    \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 _res = 1.0 / iResolution.xy;\n    float aspectRatio = iResolution.y / iResolution.x;\n    vec2 ds = vec2(1.0, 1.0/aspectRatio );\n\n    vec2 uv = fragCoord * _res;\n    vec2 N = vec2(0.,1.)* _res;\n    vec2 S = vec2(0.,-1.)* _res;\n    vec2 E = vec2(1.,0.)* _res;\n    vec2 W = vec2(-1.,0.)* _res;\n    \n    vec4 C = texture(iChannel3, uv );   // xy is UV and w is h\n\n    vec4 C_W = texture(iChannel3, uv + W );\n    vec4 C_N = texture(iChannel3, uv + N );\n    \n    vec2 h_ES = vec2(\n     texture(iChannel3, uv + E ).w,\n     texture(iChannel3, uv + S).w\n     );\n     \n    vec4 dervs = diff(C, C_W, C_N, h_ES, iResolution, uv, iChannel0);\n    \n    // Guassian blue height pertibation and pass through\n    float r = 0.;\n\tfor(int i = 0; i < 9; i++){\n  \t\tr += texture(iChannel3, uv + kdir[i]/iResolution.xy).w * kernal[i];\n\t}    \n    \n    dervs.z = r;\n    fragColor = dervs;\n}\n\n\n","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"// Description: Derivative/Tendency step 'B'.\n// License: Copyright (C) 2023 Ian McEwan. Distributed under the MIT License. \n\n// Due to ST and glsl limitations, the half time step has to be\n// constructed localy from the 'A' step's output and then\n// carry around as a sort-of patch.\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    //sampler2D chan = iChannel3;\n    \n    vec2 _res = 1.0 / iResolution.xy;\n    float aspectRatio = iResolution.y / iResolution.x;\n    vec2 ds = vec2(1.0, 1.0/aspectRatio );\n\n    vec2 uv = fragCoord * _res;\n    vec2 N = vec2(0.,1.)* _res;\n    vec2 S = vec2(0.,-1.)* _res;\n    vec2 E = vec2(1.,0.)* _res;\n    vec2 W = vec2(-1.,0.)* _res;\n    \n    vec4 D1 = texture(iChannel1, uv );\n    vec4 C = texture(iChannel3, uv );   // xy is UV and w is h\n    vec4 XC = C + tab.z * D1 * dt ;\n\n    vec4 C_W = texture(iChannel3, uv + W );\n    vec4 D1_W = texture(iChannel1, uv + W );\n    vec4 XC_W = C_W + tab.z * D1_W * dt ;\n\n    vec4 C_N = texture(iChannel3, uv + N );\n    vec4 D1_N = texture(iChannel1, uv + N );\n    vec4 XC_N = C_N + tab.z * D1_N * dt ;\n    \n    vec2 h_ES = vec2(\n     texture(iChannel3, uv + E).w,\n     texture(iChannel3, uv + S).w\n     );\n    vec2 dh_ES = vec2(\n     texture(iChannel1, uv + E).w,\n     texture(iChannel1, uv + S).w\n     );\n    vec2 Xh_ES = h_ES + tab.z * dh_ES * dt ;\n\n\n    vec4 dervs = diff(XC, XC_W, XC_N, Xh_ES, iResolution, uv, iChannel0);\n    fragColor = dervs;\n}","name":"Buffer C","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"// Description: Forward Time Step shader.\n// License: Copyright (C) 2023 Ian McEwan. Distributed under the MIT License. \n\n// Combine derivatives according to RK tableau 'tab'. With more buffers\n// I'd up this to RK4, but at least it is more stable than Euler stepping.\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec4 inp = texture(iChannel0, uv ); // w is H, xyz are input pulses.\n    vec4 d1 = texture(iChannel1, uv ); \n    vec4 d2 = texture(iChannel2, uv ); \n    vec4 cur = texture(iChannel3, uv ); // xy are u and v and w is h\n  \n    cur.w = d1.z;\n    vec3 outp = (cur.xyw + (tab.x * d1.xyw + tab.y * d2.xyw) * dt) + vec3(inp.xyz) ;\n    fragColor.xyw = outp; //clamp( outp, -1.0,1.0);\n  \n}","name":"Buffer D","description":"","type":"buffer"}]}