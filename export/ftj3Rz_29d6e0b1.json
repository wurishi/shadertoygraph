{"ver":"0.1","info":{"id":"ftj3Rz","date":"1625244343","viewed":184,"name":"The formula (audio)","username":"mare","description":" * 3 minutes of automated simple DnB loop\n * based entirely on masks rather than branching ( audio wise )- more like a mathematical formula.\n * Not equal temperment - rather playing with integer ratios for chord progression.","likes":5,"published":1,"flags":40,"usePreview":0,"tags":["audio","rorschach"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  \n    vec2 uv = fragCoord/iResolution.y - vec2( .9, .5 ) + vec2( .1 * sin( iTime ), .1 * cos( iTime * 1.3 ) );\n    uv = vec2( abs( uv.x ) + .3 , uv.y );\n    uv += vec2( .0, .1 * sin( uv.x * 10.0 + iTime ) );\n    float centerDist = 2. * length( fragCoord/iResolution.y - vec2( .9, .5 ) + vec2( .0, .1 * sin( uv.x * 10.0 + iTime ) ));\n    vec2 distortion = 9.0 *  texture( iChannel0, vec2( centerDist * centerDist * centerDist* .1, .0 ) ).xy ;  \n    uv *= 1.0 - 1.6 * texture( iChannel0, vec2( .0, .0 ) ).xy ;  \n    float angle = atan( uv.y, uv.x );\n    uv *= .2 + sin( ( 15.0 - 7.0 * chordMask( iTime,  1.4 ) ) * angle) * hatsMask( iTime, 1.4 ) * .03;\n    uv *= 1. + cos( 3.0 * angle + iTime) * padsMask( iTime, 1.4 ) * .5;\n    float lenUvR = length( uv * ( vec2(1.0) + distortion * 1.1) ) * 2.2;\n    float lenUvG = length( uv * ( vec2(1.0) + distortion * 1.) ) * 2.2;\n    float lenUvB = length( uv * ( vec2(1.0) + distortion * .9) ) * 2.2;\n    lenUvR += 0.6 * length( uv - vec2( .295 ) ) * 1.2;\n    lenUvG += 0.6 * length( uv - vec2( .3 ) ) * 1.2;\n    lenUvB += 0.6 * length( uv - vec2( .305 ) ) * 1.2;   \n    vec3 lenUv = vec3( lenUvR, lenUvG, lenUvB );\n    vec3 outColVal = 1000.0 * max( vec3(.0 ),  ( lenUv * (1.0 - lenUv) - .249 ) );\n    float bassM = bassMask( iTime, 1.4 ) + bassMask( iTime + .7, 1.4 ) + bassMask( iTime - .7, 1.4 );\n    vec3 color = vec3( .35 - .1 * bassM, .35 + .2 * sin( .1 * iTime ), .35 + .2 * cos( .1 * iTime ) );\n    \n    fragColor = vec4( outColVal + lenUv * color ,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"\n\nvec2 mainSound( int samp, float time )\n{   \n    float speed = 1.4;\n    float referenceFreq = 110.0;\n    float movedTime = time + speed * 4.0;\n    vec2 outVal = vec2( .0 );\n    float beatMask = beatMask( time, speed );\n    outVal += beatMask * kickLayer( movedTime, speed );\n    outVal += bassMask( time, speed ) * bassLayer( movedTime, speed, referenceFreq);\n    outVal += hatsMask( time, speed ) * hatsLayer( movedTime, speed );\n    outVal += beatMask * snareLayer( movedTime, speed );\n    \n    outVal += chordMask( time, speed ) * chordLayer( movedTime, speed, referenceFreq );\n    outVal += chordMask( time - 1.0, speed ) * chordLayer( movedTime - .25, speed, referenceFreq ) * vec2( .4, .1 );\n    outVal += chordMask( time - 2.0, speed ) * chordLayer( movedTime - .5, speed, referenceFreq ) * vec2( .1, .3 );\n    outVal += padsMask( time, speed ) * padsLayer( movedTime, speed, referenceFreq);\n    \n    float fadeOut = min( 1.0, max( .0, ( 180.0 - time ) * .1 ) );\n    \n    return outVal * fadeOut;       \n}","name":"Sound","description":"","type":"sound"},{"inputs":[],"outputs":[],"code":"\nfloat tone( float time, float freq )\n{\n    return sin(6.2831*freq * time);\n}\n\nfloat midPassedTone( float time, float freq, float lowPass, float highPass, float fade )\n{\n    float tangent = 1.0 / fade;\n    float amp = max( min( min( ( freq - lowPass ) * tangent, ( freq - highPass ) * -tangent ), 1.0 ), 0.0 );\n    return amp * tone( time, freq );\n}\n\nfloat distort( float val )\n{\n    return val * val * val;\n}\n\n\nfloat limit( float val, float lim )\n{\n    return min( max( -lim, val ), lim );\n}\n\nfloat limit( float val )\n{\n    return min( max( -1.0, val ), 1.0 );\n}\n\nfloat bass( float time, float freq )\n{\n    float att = .5 + tone( time, freq ) * .5;\n    att *= att * att;\n    att *= att * 1.7;\n    return limit( tone( time, freq * 2.0 ) * att );\n}\n\nfloat distoredTone( float time, float freq )\n{\n\n    float phase = .4 * cos( time * 1.7 );\n    float phase4 = .4 * sin( time * .7 ) + .4 * sin( time * 70.7 );\n    return ( .6 + .4 * phase ) * limit( distort( tone( time, freq ) ) + ( .2 + .2 * phase4 ) * distort( tone( time, freq * 4.0 ) ), .2 );\n}\n\nfloat padTone( float time, float freq )\n{\n\n    float phaseFactor1 = .4 + .6 * sin( time * 0.5 );\n    float phaseFactor2 = .4 + .6 * sin( time * 1. );\n    float phaseFactor3 = .4 + .6 * sin( time * 1.5 );\n    float lowPass = 500.0;\n    float highPass = 1200.0;\n    float fade = 300.0;\n    return limit(  \n        midPassedTone( time, freq * 2.0, lowPass, highPass, fade ) * 0.15 * phaseFactor1 +\n        midPassedTone( time, freq * 3.0, lowPass, highPass, fade ) * 0.01 * phaseFactor2 +\n        midPassedTone( time, freq * 4.0, lowPass, highPass, fade ) * 0.01 * phaseFactor2 +\n        midPassedTone( time, freq * 5.0, lowPass, highPass, fade ) * 0.31 * phaseFactor3 +        \n        midPassedTone( time, freq * 6.0, lowPass, highPass, fade ) * 0.06 * phaseFactor3 +\n        midPassedTone( time, freq * 7.0, lowPass, highPass, fade ) * 0.11 * phaseFactor2 +\n        midPassedTone( time, freq * 8.0, lowPass, highPass, fade ) * 0.14 * phaseFactor2 +\n        midPassedTone( time, freq * 9.0, lowPass, highPass, fade ) * 0.15 * phaseFactor1\n        );\n}\n\nfloat noise(float time ){\n    return fract(sin(time*256.0) * 43758.0) * 2.0 - 1.0;\n}\n\nfloat timeRange( float time, float when, float peak, float len )\n{\n    float dt = ( time - when ) / len;\n    float val = max( min( min( dt * 100.0, ( 1.0 - dt) * 100.0 ), 1.0 ), .0 );\n    val *= val * val;\n    return val * peak;\n}\n\n\nfloat att( float time, float when, float peak, float len )\n{\n    float dt = ( time - when ) / len;\n    float val = max( min( dt * 100.0, 1.0 - dt ), .0 );\n    val *= val * val;\n    return val * peak;\n}\nfloat attFade( float time, float when, float peak, float len )\n{\n    float dt = ( time - when ) / len;\n    float val = pow( max( min( dt * 2.0, 1.0 - 2.0 * dt ), .0 ), .5 );\n    return val * peak;\n}\n\n\nfloat attSnare( float time, float when, float peak, float len )\n{\n    float dt = ( time - when ) / len;\n    float val = max( min( dt * 100.0, 1.0 - dt ), .0 );\n    val *= val * val * val;\n    val *= val * val * val * val;\n    return val * peak;\n}\n\nfloat att( float time, float when, float peak )\n{\n    return att( time, when, peak, 1.0 );\n}\n\nvec2 pan( float panning, float val )  \n{\n    float left = min( 2.0 - panning * 2.0, 1.0 );\n    float right = min( panning * 2.0, 1.0 );\n    return vec2( left, right ) * val;\n}\n\nvec2 kick ( float time, float loopTime, float when, float val )\n{\n    float rawKick = tone( time, 55.0 ) * attSnare( loopTime, when, 1.5, 1.0 );\n    rawKick += tone( time, 110.0 ) * attSnare( loopTime, when, 1.5, 1.0 );\n    rawKick = limit( rawKick );\n    return pan( .5, rawKick * val );\n}\n\nfloat pickPrime( float scaledTime, float chordReferenceFreq )\n{\n    int index5th = max( ( int( floor( scaledTime ) ) & 3 ) - 2, 0 );\n    float factor5th = float( index5th ) * .5 + 1.0;\n\n    int index = int( floor( scaledTime * .25) ) & 3 ;\n    index = (1 - ((index&2)>>1) ) |  ( (index&1)<<1 );\n    float toneRatio = float( index ) + 3.0;\n    toneRatio = toneRatio / ( toneRatio - 1.0 );\n    return toneRatio * chordReferenceFreq * factor5th;\n}\n\nfloat pick3rdRatio( float scaledTime )\n{\n\n    int index = int( floor( scaledTime * .125 ) ) & 1 ;\n    return 1.25 - float(index) * .05;\n}\n\nfloat isEvenBar( float time, float speed )\n{\n    float scaledTime = time * speed * .5;\n    float loopTime = scaledTime - floor( scaledTime );   \n    return floor( loopTime * 2.0 );\n}\n\nvec2 kickLayer( float time, float speed )\n{\n    float scaledTime = time * speed;\n    float loopTime=  scaledTime - floor( scaledTime );\n    float isEvenBar = isEvenBar(time, speed );\n    float kickGain = .3;\n    vec2 outVal = vec2( .0 );\n    outVal += kick( time, loopTime, .0, kickGain * isEvenBar );\n    outVal += kick( time, loopTime, .25 + .5 * isEvenBar, kickGain );\n    return outVal;\n}\n\nvec2 bassLayer( float time, float speed, float referenceFreq )\n{\n    float scaledTime = time * speed;\n    float bassGain = .17;\n    float isEvenBar = isEvenBar(time, speed );\n    float primeFreq = pickPrime( scaledTime, referenceFreq ) * .25;  \n    float octaveDrop5th = 1.0 / ( 1.0 + floor( primeFreq * .02 ) );\n    float tone5th = primeFreq * 1.5 * octaveDrop5th;\n    float loopTime=  scaledTime - floor( scaledTime );\n   \n    vec2 outVal = vec2( .0 );\n    outVal += pan( .5, bass( time, primeFreq ) * timeRange( loopTime, .0, bassGain * isEvenBar, 0.5 ) );\n    outVal += pan( .5, bass( time, tone5th ) * timeRange( loopTime, .75, bassGain * isEvenBar, .2 ) );\n  \n    return outVal;\n}\nvec2 hatsLayer( float time, float speed )\n{\n    float scaledTime = time * speed;\n    float loopTime=  scaledTime - floor( scaledTime );\n    float hatsGain = .1;\n    vec2 outVal = vec2( .0 );\n    outVal += pan( .2, noise( time ) * attSnare( loopTime, .25, hatsGain, .7 ) );\n    outVal += pan( .8, noise( time ) * attSnare( loopTime, .75, hatsGain, .7 ) );\n    outVal += pan( .5, noise( time ) * attSnare( loopTime, .125, hatsGain * .4, .7 ) );\n    return outVal;\n}\n\nvec2 snareLayer( float time, float speed )\n{\n    float scaledTime = time * speed;\n    float loopTime=  scaledTime - floor( scaledTime );\n    float isEvenBar = isEvenBar(time, speed );\n    vec2 outVal = vec2( .0 );\n    outVal += pan( .5, noise( time ) * attSnare( loopTime, .5 + .25 - .25 * isEvenBar, .3, .7 ) );\n    return outVal;\n}\n\nvec2 chordLayer( float time, float speed, float referenceFreq )\n{\n    float phase = sin( .2 * time );\n    float chordSustain = .4 + .22 * phase;\n    float chordGain = .37 - .2 * phase;\n    float scaledTime = time * speed;\n    float primeFreq = pickPrime( scaledTime, referenceFreq );\n    float tone3rd = primeFreq * pick3rdRatio( scaledTime );\n    float tone5th = primeFreq * 1.5;\n    float toneOctave = primeFreq * 2.0;\n    vec2 outVal = vec2( .0 );\n    float loopTime=  scaledTime - floor( scaledTime );\n\n    outVal += pan( .7, distoredTone( time, tone3rd ) * att( loopTime, .5000, chordGain, chordSustain ) );\n    outVal += pan( .6, distoredTone( time, tone5th ) * att( loopTime, .75, chordGain, chordSustain ) );\n    outVal += pan( .4, distoredTone( time, toneOctave ) * att( loopTime, .0, chordGain, chordSustain ) );\n\n    return outVal;\n}\nvec2 padsLayer( float time, float speed, float referenceFreq )\n{\n    float scaledTime = time * speed;\n    float primeFreq = pickPrime( floor( .25 * scaledTime ) * 4.0, referenceFreq ) * 2.0;\n    float primeFreqPrev = pickPrime( scaledTime - 4.0, referenceFreq ) * 2.0;\n    float loopTime= .25 * scaledTime - floor( .25 * scaledTime );\n    vec2 outVal = vec2( .0 );\n    float padsGain = .32;\n    float padTone1 = padTone( time, primeFreqPrev );\n    padTone1 += padTone( time, primeFreqPrev * 1.5 );\n    padTone1 += padTone( time, primeFreqPrev * 2. );\n    float padTone2 = padTone( time, primeFreq );\n    padTone2 += padTone( time, primeFreq * 1.5 );\n    padTone2 += padTone( time, primeFreq * 2. );\n    \n    outVal += pan( .5, padTone1 * attFade( loopTime, -.5, padsGain, 2. ) );\n    outVal += pan( .5, padTone2 * attFade( loopTime, .5, padsGain, 2. ) );\n    outVal += pan( .5, padTone2 * attFade( loopTime, .0, padsGain, 2.0 ) );\n    float lfoGain = .5 * sin( 6.2831 * loopTime * 16.0 ) + .5;\n    lfoGain *= lfoGain * lfoGain;\n    lfoGain = lfoGain * .7 + .3;\n    outVal *= lfoGain;\n    return outVal;\n}\n\nfloat beatMask( float time, float speed )\n{\n    float scaledTime = ( time * speed ) * .0625 - 1.0;\n    float evenFade = floor( fract( scaledTime * .0625 - .5) + .875 );\n    return max( .0, evenFade * min( floor( scaledTime), 1.0 ) );\n}\n\nfloat bassMask( float time, float speed )\n{\n    float scaledTime = ( time * speed  - 1.0) * .0625;\n    float evenFade = floor( fract( ( scaledTime -1.0 )* .0625 - .5) + .875 );\n    return max( min( evenFade * floor( scaledTime ), 1.0 ), .0 );\n}\n\nfloat hatsMask( float time, float speed )\n{\n    float scaledTime = ( time * speed ) * .0625 - .5;\n    float fadeLastBeat = 20.0 * floor( .875 + fract( scaledTime * .5 - .125) );\n    float evenFade = floor( fract( scaledTime * .0625 - .5) + .875 );\n    return max( .0, min( evenFade * fadeLastBeat * floor( scaledTime), 1.0 ) );\n}\n\nfloat chordMask( float time, float speed )\n{\n    float intro = time * speed * .25;\n    float scaledTime = ( intro - .125 ) * .0625 + 1.0;\n    float evenFade = floor( fract( scaledTime * .5) * 2.0 );\n    return min( intro * evenFade, 1.0 );\n}\n\nfloat padsMask( float time, float speed )\n{\n    float intro = time * speed * .125 - 10.0;\n    return max( min( intro , 1.0 ), .0 );\n}\n","name":"Common","description":"","type":"common"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"vec2 audioForImage( float time )\n{\n    float speed = 1.4;\n    float referenceFreq = 12.0;\n    float movedTime = time + speed * 4.0;\n    vec2 outVal = vec2( .0 );\n    float beatMask = beatMask( time, speed );\n    outVal += .01 * beatMask * kickLayer( movedTime, speed );\n    outVal += .3 * bassMask( time, speed ) * bassLayer( movedTime, speed, referenceFreq);\n    outVal += hatsMask( time, speed ) * hatsLayer( movedTime, speed );\n    outVal += .1 * beatMask * snareLayer( movedTime, speed );\n    \n    outVal += chordMask( time, speed ) * chordLayer( movedTime, speed, referenceFreq );\n    outVal += chordMask( time - 1.0, speed ) * chordLayer( movedTime - .25, speed, referenceFreq ) * vec2( .4, .1 );\n    outVal += chordMask( time - 2.0, speed ) * chordLayer( movedTime - .5, speed, referenceFreq ) * vec2( .1, .3 );\n    outVal += padsMask( time, speed ) * padsLayer( movedTime, speed, referenceFreq);\n    \n    float fadeOut = min( 1.0, max( .0, ( 180.0 - time ) * .1 ) );\n    return outVal * fadeOut;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if( fragCoord.y != .0 )\n    {\n        fragColor = vec4(0.0,0.0,1.0,1.0);    \n    }\n    float timeDelta = fragCoord.x / iResolution.x;\n    vec2 audio = abs( audioForImage( iTime - 2.0 * timeDelta ) );\n    audio = max( audio,abs( audioForImage( iTime - 2.0 * timeDelta + .001 ) ) );\n    audio = max( audio,abs( audioForImage( iTime - 2.0 * timeDelta + .002 ) ) );   \n    \n    fragColor = vec4( audio.x, audio.y, 1.0, 1.0 );\n    \n}","name":"Buffer A","description":"","type":"buffer"}]}