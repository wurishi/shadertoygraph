{"ver":"0.1","info":{"id":"fl3yR2","date":"1660927760","viewed":448,"name":"Simpsons Hit & Run","username":"LucasR","description":"I hope we get a part II or at least a remake some day! You can change to a top-down view by changing the 0 in line 410 to a 1. You can also move the camera with the mouse.","likes":28,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","simpsons"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// SDFs and soft shadows by iq (IÃ±igo Quilez)\n\n// set AA to 0 if the shader is running too slow\n#define AA 2\n#define ZERO (min(iFrame,0))\n#define PI 3.14159\n\nvec2 vmin(vec2 a, vec2 b){ // regular min() compares all components, I don't want to compare material IDs\n    return a.x < b.x ? a : b;\n}\n\nvec2 smin( vec2 a, vec2 b, float k ){\n    float h = max( k-abs(a.x-b.x), 0.0 )/k;\n    return vmin( a, b ) - h*h*k*(1.0/4.0);\n}\n\nfloat smin( float a, float b, float k ){\n    float h = max( k-abs(a-b), 0.0 )/k;\n    return min( a, b ) - h*h*k*(1.0/4.0);\n}\n\nfloat sdSphere( vec3 p, float s ){\n  return length(p)-s;\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r ){\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\n\nfloat sdBox( vec3 p, vec3 b ){\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdCutSphere( vec3 p, float r, float h ){\n  // sampling independent computations (only depend on shape)\n  float w = sqrt(r*r-h*h);\n\n  // sampling dependant computations\n  vec2 q = vec2( length(p.xz), p.y );\n  float s = max( (h-r)*q.x*q.x+w*w*(h+r-2.0*q.y), h*q.x-w*q.y );\n  return (s<0.0) ? length(q)-r :\n         (q.x<w) ? h - q.y     :\n                   length(q-vec2(w,h));\n}\n\nfloat sdTorus( vec3 p, vec2 t ){\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat sdEllipsoid( vec3 p, vec3 r ){\n  float k0 = length(p/r);\n  float k1 = length(p/(r*r));\n  return k0*(k0-1.0)/k1;\n}\n\nfloat sdBox2D( in vec2 p, in vec2 b ){\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat sdCircle( vec2 p, float r ){\n    return length(p) - r;\n}\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\n\nfloat sdTrapezoid( in vec2 p, in float r1, float r2, float he ){\n    vec2 k1 = vec2(r2,he);\n    vec2 k2 = vec2(r2-r1,2.0*he);\n    p.x = abs(p.x);\n    vec2 ca = vec2(p.x-min(p.x,(p.y<0.0)?r1:r2), abs(p.y)-he);\n    vec2 cb = p - k1 + k2*clamp( dot(k1-p,k2)/dot2(k2), 0.0, 1.0 );\n    float s = (cb.x<0.0 && ca.y<0.0) ? -1.0 : 1.0;\n    return s*sqrt( min(dot2(ca),dot2(cb)) );\n}\n\nfloat opExtrussion( in vec3 p, in float sdf, in float h ){\n    vec2 w = vec2( sdf, abs(p.z) - h );\n  \treturn min(max(w.x,w.y),0.0) + length(max(w,0.0));\n}\nvec2 map(in vec3 pos, in float time){ // signed distance in m.x and material ID in m.y\n    vec2 wq = pos.xz + vec2(.6, .3);\n    wq.y = mod(wq.y, 1.)-.2;\n    float wm = sdBox2D(wq, vec2(.4)); // walkway (and driveway) mask\n    wq = pos.xz-vec2(0., -3.);\n    wq.x = mod(wq.x+.1, 1.)-.5;\n    wm = min(wm, sdBox2D(wq, vec2(.4)));\n    wm += (pos.x > -1.1) && (pos.z < -2.5) && (pos.x < 7.) ? 0. : 1.; // cut walkway\n    wm = min(wm, sdBox2D(pos.xz-vec2(6.5, -2.1), vec2(1.5, 3.)));\n    wm = smoothstep(0.0, 0.1, wm);\n    vec2 m = vec2(pos.y+1.4+wm*.1, 8.0); // floor\n    \n    // Homer\n    vec2 hm;\n    float tmp = .02;\n    pos.y += tmp;\n    vec3 q = pos - vec3(0.5, 0., -.5); // y .5\n    hm = vec2(sdCapsule(q, vec3(0.), vec3(0.01, 0.2, -0.01), 0.15), 1.0); // head\n    float HmBV = sdCapsule(pos, vec3(.5, .7, -.5), vec3(.5, -.7, -.5), .31);\n    if(HmBV < 1.){\n        hm.x = smin(hm.x, sdCapsule(q, vec3(.02, 0., -.02), vec3(.04, -.2, -.04), .1), .02); // neck\n        hm.x = smin(hm.x, sdCapsule(q, vec3(0., .1, 0.), vec3(-.07, .1, .15), .03), .02); // nose\n        \n        // upper and lower jaw are separate, different sized spheres\n        \n        // smile test\n        vec3 w = q;\n        float temp = .3;\n        w.z -= temp;\n        w.y -= w.z*w.z*.4;\n        w.z += temp;\n        \n        //w = q; // uncomment to remove smile test\n        \n        hm = vmin(hm, vec2(sdCutSphere(q-vec3(-.02, 0., .02), .15, -.05), 3.0)); // stubble (without max op)\n        hm = smin(hm, vec2(sdTorus(w-vec3(-.02, -.05, .02), vec2(.12, .03)), 3.0), .02); // lip\n        hm = vmin(hm, vec2(sdSphere(q-vec3(-.01, -.03, .02), .13), 3.0)); // lower jaw\n        \n        q.xz = mat2(24, -7, 7, 24)/25.*q.xz;\n        vec3 r = vec3(abs(q.x)-.07, q.y, q.z);\n        hm = smin(hm, vec2(sdTorus(r-vec3(0., .2, 0.05), vec2(.04, .03)), 1.0), .02); // eyebrows\n        \n        r.xy = mat2(63, 16, -16, 63)/65.*r.xy;\n        hm = smin(hm, vec2(sdCutSphere(r-vec3(-.035, .17, .1), .06, .04), 1.0), .05); // eyelids\n        \n        hm = smin(hm, vec2(sdSphere(vec3(abs(q.x)-.07, q.y-.15, q.z-.1), .06), 2.0), .015); // sclera\n        hm = vmin(hm, vec2(sdSphere(vec3(abs(q.x)-.07, q.y-.15, q.z-.155), .01), 6.0)); // pupils\n        hm = smin(hm, vec2(sdSphere(q-vec3(.12, .05, 0.), .05), 1.0), .02); // ear\n        \n        // hair\n        float hair = sdTorus(pos.yzx-vec3(.315, -.46, .52), vec2(.05, .003));\n        hair = min(hair, sdTorus(pos.yzx-vec3(.31, -.48, .56), vec2(.05, .003)));\n        hair = min(hair, sdCapsule(pos, vec3(.62, .1, -.4), vec3(.66, .15, -.46), .003));\n        hair = min(hair, sdCapsule(pos, vec3(.66, .15, -.46), vec3(.68, .13, -.55), .003));\n        hair = min(hair, sdCapsule(pos, vec3(.68, .13, -.55), vec3(.7, .16, -.58), .003));\n        hm = vmin(hm, vec2(hair, 6.0));\n        \n        q.y -= tmp;\n        \n        // body\n        q.y -= .02;\n        float bdy = sdSphere(q-vec3(0.03, -.4, -.03), .16); // chest\n        bdy = smin(bdy, sdCutSphere(q-vec3(0., -.7, 0.), .3, -.1), .2); // belly\n        bdy = smin(bdy, sdTorus(q-vec3(.03, -.28, -.03), vec2(.15, .03)), .05); // collar\n        // arms\n        r.xy = mat2(63, -16, 16, 63)/65.*vec2(abs(q.x)-.1, q.y);\n        bdy = smin(bdy, sdCutSphere(r-vec3(.0, -.48, 0.), .13, -.03), .01); // shoulders\n        hm = vmin(hm, vec2(bdy, 2.0));\n        bdy = sdCapsule(r, vec3(.03, -.45, .0), vec3(.05, -.6, .03), .072); // upper arms\n        bdy = smin(bdy, sdCapsule(r, vec3(.05, -.68, .03), vec3(.02, -.85, .08), .065), .05); // forearms\n        hm = vmin(hm, vec2(bdy, 1.0));\n        // legs\n        bdy = sdSphere(q+vec3(0., .7, 0.), .28);\n        bdy = smin(bdy, sdCapsule(q, vec3(.09, -.8, .0), vec3(.12, -1.2, .0), .18*(1.8+q.y)), .005); // up left\n        bdy = smin(bdy, sdCapsule(q, vec3(-.09, -.8, .0), vec3(-.14, -1.2, -.05), .18*(1.8+q.y)), .005); // up r\n        bdy = smin(bdy, sdCapsule(q, vec3(-.14, -1.225, -.05), vec3(-.12, -1.45, -.08), .1), .01); // down r\n        bdy = smin(bdy, sdCapsule(q, vec3(.12, -1.225, .0), vec3(.12, -1.45, -.05), .1), .01); // down l\n        hm = vmin(hm, vec2(bdy, 7.0));\n        // shoes\n        bdy = sdSphere(q-vec3(.12, -1.5, -.05), .12); // left\n        bdy = min(bdy, sdSphere(q-vec3(-.12, -1.5, -.08), .12)); // right\n        \n        bdy = smin(bdy, sdSphere(q-vec3(-.23, -1.5, .05), .08), .12); // right front\n        bdy = smin(bdy, sdSphere(q-vec3(.18, -1.5, .1), .08), .12); // left front\n        hm = vmin(hm, vec2(bdy, 10.0));\n        \n    }\n    m = vmin(m, hm);\n    \n    // house\n    vec2 hs;\n    float HsBV = sdBox(pos-vec3(1.5, 0., -8.), vec3(5., 2.5, .5)); // house bounding volume\n    q = pos-vec3(-0.5, 0., -7.);\n    hs = vec2(sdBox(q-vec3(0., 1., 0.), vec3(5., 2.5, .5)), 4.0);\n    if(HsBV < 5.2){\n        hs.x = min(hs.x, sdBox(q-vec3(7.2, -.4, -2.), vec3(2.5, 3., 2.)));\n        hs.x = min(hs.x, sdBox(q-vec3(7., 0., -.5), vec3(2., 1.5, 2.5)));\n        hs.x = min(hs.x, sdBox(q+vec3(5.2, 0., 1.5), vec3(.25, 5.5, .5))); // chimney\n        hs.x = min(hs.x, sdBox(q+vec3(5.2, -5.5, 1.5), vec3(.35, .15, .6))); // chimney border\n        // roof\n        vec3 r = q-vec3(0., 3.85, -2.2);\n        r.z = abs(r.z)-2.;\n        r.yz = mat2(35, -12, 12, 35)/37.*r.yz;\n        float rf = sdBox(r, vec3(5.5, .1, 2.1));\n        rf = min(rf, sdBox(r-vec3(7.5, -1.1, -1.5), vec3(2.5, .1, 2.5)));\n        // garage roof\n        r = q;\n        r.x -= 7.;\n        r.x = abs(r.x)-2.;\n        r.xz = mat2(-1, 0, 0, -1)*r.xz; // rotate garage roof\n        r.xy = mat2(35, -12, 12, 35)/37.*r.xy; // break it in half\n        rf = min(rf, sdBox(r-vec3(9.5, 1.5, -.5), vec3(9.5, .1, 2.)));\n        hs = vmin(hs, vec2(rf, 5.0));\n        \n        // add triangular part of garage\n        hs.x = min(hs.x, max(sdBox(pos-vec3(6.5, 0., -7.), vec3(2., 2.5, 2.)), r.y-1.5));\n        \n        float disp = fract(-pos.y*2.5+.54)*.03; // garage door corrugation\n        hs = vmin(hs, vec2(sdBox(pos-vec3(6.5, -.4, -5.18+disp), vec3(1.3, 1., .2)), 9.0)); // garage door\n        \n        HsBV = sdBox(pos+vec3(.5, .2, 5.5), vec3(2.3, .8, .8));\n        if(HsBV < 2.65){ // smaller bounding volume for the details of the front of the house\n        // could be 1.5 without upper windows, maybe I should separate them -- there's a ~5 fps difference\n            // windows\n            q = vec3(abs(pos.x+.5)-3., pos.y-.8, pos.z+6.8);\n            float rw = pos.y*.5-.32;\n            vec2 wi;\n            wi.x = opExtrussion(q.xzy, sdTrapezoid(q.xz-vec2(0., .5), .9-rw*2., .5-rw, .4-rw), .2); // upper\n                // lower border\n            wi.x = min(wi.x,\n            opExtrussion(q.xzy+vec3(0., 0., 1.5), sdTrapezoid(q.xz-vec2(0., .5), .9, .5, .4), .1));\n            wi.x = min(wi.x, sdBox(q-vec3(-.1, 1.2, 0.), vec3(1.1, .7, .32)));\n            wi.y = 5.0;\n                // middle things\n            wi.x = min(wi.x,\n            opExtrussion(vec3(q.x, q.z, abs(q.y+.8)-.8)+vec3(0., 0., 0.5),\n            sdTrapezoid(q.xz-vec2(0., .5), .82, .42, .32), .05));\n            wi.x = min(wi.x, sdBox(vec3(q.x, q.y+.7, q.z), vec3(.05, .7, .82)));\n            wi.x = min(wi.x, sdBox(q-vec3(0., -.8, 0.), vec3(.8, .65, .33)));\n            wi.x = min(wi.x, sdBox(q-vec3(0., -.8, .2), vec3(.62, .65, .33)));\n            wi.x = min(wi.x, sdBox(q-vec3(0., -.8, .465), vec3(.45, .65, .33)));\n            hs = vmin(hs, wi);\n                // glass\n            wi.y = 15.0;\n            wi.x = opExtrussion(q.xzy+vec3(0., 0., .8), sdTrapezoid(q.xz-vec2(0., .5), .8, .4, .3), .7);\n\n            // door\n            float dr = sdCircle(pos.xy-vec2(-.5, 0.), .5);\n            dr = min(dr, sdBox2D(pos.xy-vec2(-.5, -.75), vec2(.5, .7)));\n            float drs = dr;\n            dr = min(dr, sdBox2D(q.xy-vec2(-.1, 1.2), vec2(.9, .5))); // also cut hole for upper windows\n            hs.x += smoothstep(0.05, .0, dr)*.2; // indent wall\n            hs.x -= smoothstep(0.05, .0, drs-.2)*.05;\n            \n            wi.x = min(wi.x, sdBox(q-vec3(-.1, 1.2, 0.), vec3(1., .6, .31))); // upper windows\n            hs = vmin(hs, wi);\n            // upper windows middle things\n            wi.x = sdBox(q-vec3(-.1, 1.2, 0.), vec3(.05, .6, .32));\n            wi.x = min(wi.x, sdBox(q-vec3(-.1, 1.2, 0.), vec3(.95, .05, .32)));\n            hs = vmin(hs, vec2(wi.x, 5.0));\n            \n            dr = sdSphere(pos-vec3(-.85, -.5, -6.575), .08); // knob\n            dr = min(dr, sdBox(pos-vec3(-.8, -.55, -6.775), vec3(.1, .2, .2))); // lock thing\n            hs = vmin(hs, vec2(dr, 11.0));\n            hs = vmin(hs, vec2(sdBox(pos-vec3(-.5, -.5, -7.1), vec3(.6, 1.2, .5)), 12.0)); // door\n\n            // plants\n            q = vec3(abs(pos.x+.6), pos.yz);\n            vec3 rb = .5*vec3(sin(pos.y*23.51), cos(pos.z*18.11), sin(pos.x*25.168))*.05;\n            hs = vmin(hs, vec2(sdBox(q-vec3(1., -1.5, -5.5), vec3(.4, .2, 1.2))-.06, 13.0));\n            hs = vmin(hs, vec2(sdEllipsoid(q-vec3(1., -1., -5.5), rb+vec3(.5, .45, 1.3)), 14.0));\n        }\n    }\n    \n    // fence\n    vec3 r = pos;\n    r.x = abs(r.x-1.5)-7.5;\n    r.z = mod(r.z, .5);\n    float fc = sdBox(r-vec3(0., -1., .25), vec3(.015, 1.2, .2)); // vertical planks\n    fc = min(fc, sdBox2D(vec2(abs(pos.x-1.5)-7.5, abs(pos.y+.6)-.6)-vec2(0.), vec2(.05))); // bars\n    hs = vmin(hs, vec2(fc, 5.0));\n    \n    m = vmin(m, hs);\n    \n    return m;\n}\n\nvec2 castRay( in vec3 ro, in vec3 rd, float time ){\n    vec2 res = vec2(-1.0, -1.0);\n    float tmin = 3.;\n    float tmax = 34.;\n    \n    float t = tmin;\n    for(int i=ZERO; i<256 && t<tmax; i++){\n        vec2 h = map( ro+rd*t, time );\n        //if( h.x < 0.001 ){\n        //if( abs(h.x)<(0.001*t) ){\n        if( abs(h.x)<0.001 ){ // cone tracing (*t) added shadow artifacts\n            res = vec2(t, h.y);\n            break;\n        }\n        t += h.x;\n    }\n    return res;\n}\n\n// change between 0 and 1 to test different normal calculation functions\n#if 1\nvec3 calcNormal(vec3 q, float time){ // gscene3 from https://www.shadertoy.com/view/NscXR4\n    float h = 0.001;\n\tvec3 n = vec3(0);\n\tfor (int i = ZERO; i < 4; ++i) {\n\t\tvec3 e = vec3((ivec3(i+3, i, i+i)&2) - 1);\n\t\tn += map(q + e * h, time).x * e;\n\t}\n\treturn normalize(n);\n}\n#else\nvec3 calcNormal(vec3 p, float time){\n  vec2 e = vec2(1.0, -1.0) * 0.0005;\n  return normalize(\n    e.xyy * map(p + e.xyy, time).x +\n    e.yyx * map(p + e.yyx, time).x +\n    e.yxy * map(p + e.yxy, time).x +\n    e.xxx * map(p + e.xxx, time).x);\n}\n#endif\n\nfloat softShadow(vec3 ro, vec3 rd, float mint, float maxt, float time){\n// source: https://www.shadertoy.com/view/ltyXD3\n    float res = 1.0;\n    float t = mint;\n    \n    for(int i = ZERO; i < 16; i++) {\n        float h = map(ro + rd * t, time).x;\n        res = min(res, 8.0*h/t);\n        t += clamp(h, 0.02, 0.10);\n        if(h < 0.001 || t > maxt) break;\n    }\n    \n    return clamp( res, 0.0, 1.0 );\n}\n\nvec3 render( in vec3 ro, in vec3 rd, float time ){\n    vec3 col = vec3(0.5, 0.8, 0.9) - max(rd.y,0.0)*0.75;\n    vec2 res = castRay(ro, rd, time);\n    vec3 pos = ro+res.x*rd;\n    vec3 n = calcNormal(pos, time);\n    float spe = 0.;\n    \n    vec3 sunDir = normalize(vec3(0.2, 0.3, 0.2));\n    vec3 sunCol = vec3(1.2, 1.1, 0.8);\n    vec3 grassCol = vec3(0.05, 0.25, 0.1);\n    \n    col = pos.y < -.2 ? col : vec3(.05, .25, .05)*dot(sunDir, vec3(0., 1., 0.))*sunCol\n    +.02+vec3(0.2, 0.2, 0.9)*.055; // fill grass in\n    \n    float sunDif = clamp(dot(n, sunDir), 0.0, 1.0);\n    if(res.y > 0.5){ // not sky\n        col = vec3(1., 0.851, 0.059); // skin\n        if((1.5 < res.y) && (res.y < 2.5)){ // Homer's shirt\n            col = vec3(1.);\n        }else if((2.5 < res.y) && (res.y < 3.5)){ // stubble\n            col = vec3(0.973, 0.863, 0.604);\n        }else if((3.5 < res.y) && (res.y < 4.5)){ // house walls\n            // wall : doorframe\n            col = (pos.z < -6.49) || (pos.x > 2.) ? vec3(.95, .55, .55) : vec3(0.4, 0.3, 0.2);\n            col *= clamp((pos.y+1.8), 0., 1.);\n        }else if((4.5 < res.y) && (res.y < 5.5)){ // roof\n            col = vec3(0.4, 0.3, 0.2);\n        }else if((5.5 < res.y) && (res.y < 6.5)){ // pupils and hair\n            col = vec3(.02);\n        }else if((6.5 < res.y) && (res.y < 7.5)){ // pants\n            col = vec3(.439, .82, .996);\n        }else if((7.5 < res.y) && (res.y < 8.5)){ // floor\n            col = pos.y > -1.46 ? vec3(.5, .5, .35) : vec3(.05, .25, .05); // sidewalk : grass\n        }else if((8.5 < res.y) && (res.y < 9.5)){ // garage door\n            col = vec3(.6, .6, .5);\n            col *= fract(pos.y*2.5-.5)+.5; // fake corrugation\n        }else if((9.5 < res.y) && (res.y < 10.5)){ // shoes\n            col = vec3(.2, .2, .25);\n        }else if((10.5 < res.y) && (res.y < 11.5)){ // doorknob\n            col = vec3(0.4);\n        }else if((11.5 < res.y) && (res.y < 12.5)){ // door\n            col = vec3(.75, .3, .3);\n        }else if((12.5 < res.y) && (res.y < 13.5)){ // planters\n            col = vec3(.4, .1, .05);\n        }else if((13.5 < res.y) && (res.y < 14.5)){ // door plants\n            col = vec3(.05, .5, .1) + .05*sin(pos*vec3(15.654, 32.13, 25.8));\n        }else if((14.5 < res.y) && (res.y < 15.5)){ // glass\n            col = vec3(.2, .4, .85);\n            float RV = clamp(dot(reflect(sunDir, n), rd), 0., 1.);\n            spe = pow(RV, 5.)*10.;\n        }\n        \n        float topOcc = softShadow(pos, vec3(0., 1., 0.), 0.02, .5, time)+0.02;\n        vec3 lin = vec3(0.0);\n        lin += sunDif*sunCol*softShadow(pos, sunDir, 0.02, 1.5, time); // Sun\n        lin += spe;\n        lin += .02+(0.05+0.95*clamp(n.y, 0.0, 1.0))*vec3(0.2, 0.2, 0.9)*topOcc; // sky\n        \n        lin += (0.05+0.95*clamp(-n.y, 0.0, 1.0))*grassCol * 0.5;\n        col = col*lin;\n    }\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec3 tot = vec3(0.);\n    float time = iTime;\n#if AA > 1\n    for( int m=ZERO; m<AA; m++ )\n    for( int n=ZERO; n<AA; n++ )\n    {\n    vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n    vec2 uv = ((fragCoord+o) - .5 * iResolution.xy) / iResolution.y;\n#else\n    vec2 uv = (fragCoord - .5 * iResolution.xy) / iResolution.y;\n#endif\n    vec3 ro = vec3(0., -.2, 3.);\n    vec3 rd = normalize(vec3(uv, -1.));\n    rd.yz = mat2(264, 23, -23, 264)/265.*rd.yz;\n    rd.xz = mat2(84, 13, -13, 84)/85.*rd.xz;\n    \n    // top-down view\n#if 0\n    ro = vec3(10., 15., 15);\n    rd.yz = mat2(272, -225, 225, 272)/353.*rd.yz;\n    rd.xz = mat2(272, -225, 225, 272)/353.*rd.xz;\n#endif\n    \n    if(iMouse.z > 0.){ // if LMB is being pressed rotate camera\n        vec2 mouse = (iMouse.xy - .5 * iResolution.xy) / iResolution.y;\n        float cx, cy, sx, sy;\n        cx = cos(mouse.x); cy = cos(mouse.y); sx = sin(mouse.x); sy = sin(mouse.y);\n        rd.yz = mat2(cy, -sy, sy, cy)*rd.yz;\n        rd.xz = mat2(cx, -sx, sx, cx)*rd.xz;\n    }\n    \n    vec3 col = render(ro, rd, time);\n    col = pow(col, vec3(0.4545)); // gamma correction\n    tot += col;\n#if AA > 1\n    }\n    tot /= float(AA*AA);\n#endif\n    \n    fragColor = vec4(tot, 1.);\n}","name":"Image","description":"","type":"image"}]}