{"ver":"0.1","info":{"id":"7sc3DN","date":"1629845608","viewed":125,"name":"Kiss from a rose","username":"AeroShark333","description":"White rose shader (ray-marched)\n\nMy first ever shader published here :D\nThe performance isn't that great but it works I guess :D\nMaybe I will add leaves someday :D","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["3d","noise","raymarch","rose","raymarchingwhiterose"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n * \"Kiss from a rose\" by Abiram Kanagaratnam (AeroShark333)\n *\n * License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n *\n * Contact: <see bottom of shader>\n */\n\n// Recommended range (9.0 ~ 33.0)\n#define FLOWER_QUALITY 15.0\n\n// Ray-marcher options\n#define MAX_STEPS 100\n#define MIN_DIST 0.0003\n#define MAX_DIST 24.0\n#define MIN_LIGHTING_DIST 2.0 * MIN_DIST\n#define NORMAL_OFFSET 0.01\n#define SHADOW_STRENGTH 0.1\n\n// Constants\n#define PI 3.14159265359\n\n// (P)RNG\nfloat hash(float x){\n    return fract(sin(x*1234.0)*4321.0);\n}\n\n// Noise\nfloat value(vec2 xy){\n    vec2 f0 = floor(xy);\n\n    float h1 = hash(f0.y);\n    float h2 = hash(f0.y + 1.0);\n\n    float f1 = f0.x + 1.0;\n\n    float bl = hash(f0.x + h1);\n    float br = hash(f1 + h1);\n\n    float tl = hash(f0.x + h2);\n    float tr = hash(f1 + h2);\n\n    vec2 fr = xy - f0;\n    fr = (3.0 - 2.0*fr)*fr*fr;\n\n    float b = mix(bl, br, fr.x);\n    float t = mix(tl, tr, fr.x);\n\n    return mix(b, t, fr.y);\n}\n\n// Rotate\nmat2 rotate(float a) {\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\n// Plane\nfloat getPlaneDistance(vec3 position){\n    return position.y;\n}\n\n// Cylinder\nfloat getCylinderDistance(vec3 position, vec3 cylinderLowerPosition, vec3 cylinderUpperPosition, float radius){\n    vec3 cylinderVector = cylinderUpperPosition - cylinderLowerPosition;\n    vec3 positionVector = position - cylinderLowerPosition;\n    \n    float innerDistance = dot(cylinderVector, positionVector) / dot(cylinderVector, cylinderVector);\n    \n    vec3 cylinderPosition = cylinderLowerPosition + innerDistance * cylinderVector;\n\n    float x = length(position-cylinderPosition) - radius;\n    float y = (abs(innerDistance-0.5)-0.5)*length(cylinderVector);\n    \n    float exteriorDistance = length(max(vec2(x,y),0.0));\n    float interiorDistance = min(max(x,y), 0.0);\n    \n    float distance = exteriorDistance + interiorDistance;\n    \n    return distance;\n}\n\n// Stem\nfloat getStemDistance(vec3 position){\n\n    vec3 customPosition = position;\n    customPosition.x += 0.05* sin(2.0*position.y);\n    \n    return getCylinderDistance(customPosition, vec3(0.0, 0.75, 0.0), vec3(0.0, 0.0, 0.0), 0.006);\n    \n}\n\n// Flower\nfloat getFlowerDistance(vec3 position){\n    float dist = 100.0;\n    \n    // Quality of rose\n    float hMax = FLOWER_QUALITY;\n    \n    float norm = 10.0 / hMax;\n    for(float h=0.0; h < hMax; h++){\n        vec3 newPosition = position;\n        \n        // More dense in center\n        float h2 = (h / hMax);\n        h2 *= h2 * hMax * norm;\n        \n        // Make sure flower begins at stem\n        newPosition.x += 0.05* sin(2.0*0.75);\n        \n        // Create parabolic displacement in y-direction depending on the radius\n        newPosition.y -= mix(0.0,2.0*sin(distance(newPosition.xz, vec2(0.0, 0.0))),sqrt(abs(newPosition.y-0.75)));\n     \n        // Rotate flower (aka 'cylinder')\n        float offset =  h2*1.3; // + iTime*0.3;\n        float x = clamp(mod(atan(newPosition.x,newPosition.z) + PI/2.0 + offset, PI), 0.0, PI);\n        \n        // Creates petal-like effect\n        newPosition.xz *= 1.0+0.24* clamp(pow(sin(x),1.2),0.0,1.0);\n     \n        float top = 0.84;\n     \n        // Artifacts or something...\n        if(position.y < 1.0){\n            newPosition.xz *= mix(1.0, 0.75, clamp(abs(position.y-top-0.03),0.0,1.0));\n            newPosition.xz *= mix(1.0, 0.45, clamp(abs(position.y-top+0.00),0.0,1.0));\n            newPosition.xz *= mix(1.0, 0.15, clamp(abs(position.y-top+0.03),0.0,1.0));\n        }\n        \n        // Vary radius for every flower (aka 'cylinder')\n        float customRadius = 0.001 + 0.009*h2;\n        customRadius *= 0.01/customRadius + pow(abs((position.y-0.75)/(0.18-0.0057*h2)), 0.3);\n        dist = min(dist, 0.2*getCylinderDistance(newPosition, vec3(0.0, top-0.0057*h2, 0.0), vec3(0.0, 0.75, 0.0), customRadius));\n    }\n    \n    // Artifacts due to deforming I guess...\n    return 3.9*dist;\n    \n}\n\n// Distance\nfloat getDistance(vec3 position){\n    float dist = 0.0;\n    \n    dist = getPlaneDistance(position);\n    \n    dist = min(dist, getStemDistance(position));\n    \n    dist = min(dist, getFlowerDistance(position));\n    \n    return dist;\n}\n\n// Ray-marcher\nfloat rayMarch(vec3 origin, vec3 direction){\n    float distance = 0.0;\n    for(int i = 0 ; i< MAX_STEPS; i++){\n        vec3 position = origin + direction * distance;\n        float step = getDistance(position);\n        distance += step;\n        if(step < MIN_DIST || distance > MAX_DIST){\n            break;\n        }\n    \n    }\n    return distance;\n\n}\n\n// Normal\nvec3 getNormal(vec3 position){\n    vec2 offset = vec2(NORMAL_OFFSET, 0.0);\n    \n    float distance = getDistance(position);\n    \n    vec3 normal = vec3(\n        distance - getDistance(position-offset.xyy),\n        distance - getDistance(position-offset.yxy),\n        distance - getDistance(position-offset.yyx));\n        \n    return normalize(normal);\n}\n\n// Lighting\nfloat getLighting(vec3 position){\n    vec3 lightPosition = vec3(-3.0, 3.0, 0.0);\n    \n    //vec3 lightDirection = normalize(lightPosition - position);\n    vec3 lightDirection = normalize(lightPosition - vec3(0.0));\n    \n    vec3 normal = getNormal(position);\n    \n    \n    float diffuse = clamp(dot(lightDirection, normal),\n                    0.0,\n                    1.0);\n                    \n    float distance = rayMarch(position + normal * MIN_LIGHTING_DIST, lightDirection);\n    \n    // Shadow\n    if(distance < length (lightPosition - position)){\n        diffuse *= 0.45;\n    }\n    \n    // Include ambient lighting\n    return max(diffuse, 0.15);\n}\n\n// Main loop\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Initial color\n    vec3 col = vec3(0.0);\n\n    // Centered UV-coordinates\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    \n    // Input\n    vec2 control = iMouse.xy/iResolution.xy;\n    \n    // Camera\n    vec3 origin = vec3(0.0, 1.0, -3.0);\n    \n    origin.xz *= rotate(iTime*0.3+(1.0-control.x)*PI*2.0);\n    \n    origin *= 1.0-0.93*control.y;\n    origin.y +=  0.87; // +0.3*control.x;\n    \n    vec3 direction = normalize(vec3(uv.x, uv.y-0.5, 1.0));\n    direction.xz *= rotate(iTime*0.3+(1.0-control.x)*PI*2.0);\n    \n    float dist = rayMarch(origin, direction);\n    \n    vec3 position = origin + direction * dist;\n    \n    float diffuse = getLighting(position);\n    \n    col = vec3(diffuse);\n    \n    if(position.y > 0.75){\n    \n        float yVal = 3.0*4.0*(position.y - 0.75);\n        float angleVal = 150.0*dot(getNormal(position),vec3(1.0,0.0,0.0));\n        float factor = value(vec2(yVal,angleVal));\n        \n        col = col * (0.06*factor+1.0) * vec3(1.2,1.2,1.1*sqrt(clamp(distance(position.xz,vec2(-0.05* sin(2.0*0.75),0.0))/0.09,0.0,1.0)));\n        \n        col = clamp(col, vec3(0.0), vec3(1.0));\n    }else if(position.y > MIN_DIST){\n        // 0.0 ~ 0.75\n        float yVal = position.y / 0.75;\n        float angleVal = dot(getNormal(position),vec3(1.0,0.0,0.0));\n        float factor = value(9.0*vec2(yVal,angleVal));\n        col = col * vec3(0.0,0.45+0.30*sin(factor*PI),0.0);\n    }else{\n        float factor = value(9.0*position.xz);\n        col *= col.x;\n        col *= vec3(0.3,1.0-factor*0.1,0.3);\n        col *= pow(1.0 - clamp(distance(position.xz,vec2(0.0))/100.0,0.0,1.0),45.0);\n    }\n    \n    if(distance(position.xz,vec2(0.0))>9.0){\n        col = vec3(0.0);\n    }\n    \n    fragColor = vec4(col,1.0);\n}\n\n// E-mail: abiram26@hotmail.com","name":"Image","description":"","type":"image"}]}