{"ver":"0.1","info":{"id":"MtSXR3","date":"1445295919","viewed":149,"name":"[CIS565 2015F] FinalScene","username":"momeg","description":"https://github.com/megmo21/Project5-GLSL-Ray-Marcher\nAcknoledgments: (also at top of script) \nNumerical Methods for Ray Tracing Implicitly Defined Surfaces (2014). PDF\nIÃ±igo QuÃ­lez. Terrain Raymarchi","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["cis565"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","previewfilepath":"/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"XsX3Rn","filepath":"/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg","previewfilepath":"/media/ap/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"Xdf3zn","filepath":"/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png","previewfilepath":"/media/ap/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png","type":"texture","channel":2,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[],"code":"//https://iquilezles.org/articles/menger - mendel sponge\n//https://en.wikipedia.org/wiki/Blinn%E2%80%93Phong_shading_model - blinn-phong lighting\n//http://graphics.cs.williams.edu/courses/cs371/f14/reading/implicit.pdf - ray marching/sphere tracing\n//http://www2.compute.dtu.dk/pubdb/views/edoc_download.php/6392/pdf/imm6392.pdf - ambient occlusion/soft shadows\n//--Distance Functions-------------------------------------------------------------------\n\n#define NORMALS 0 \n#define RAY_STEPS 0 \n#define DISTANCE 0\n#define SPHERE_TRACE 1\n\n\nfloat planeDist( vec3 p )\n{\n    /*if (p.y < ((sin(p.x) - sin(p.z)) / 4.0)) return (sin(p.x) - sin(p.z)) / 4.0;\n     else return 100.0;\n     return 100.0;*/\n    return p.y;\n    \n}\n\nfloat sphereDist(vec3 p, float r) {\n    return length(p) - r;\n}\n\nfloat boxDist( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat torusDist( vec3 p, vec2 t )\n{\n    return length( vec2(length(p.xz)-t.x,p.y) )-t.y;\n}\n\nfloat roundBoxDist( vec3 p, vec3 b, float r )\n{\n    return length(max(abs(p)-b,0.0))-r;\n}\n\nfloat crossDist( in vec3 p )\n{\n    float da = boxDist(p.xyz,vec3(100000,1.0,1.0));\n    float db = boxDist(p.yzx,vec3(1.0,100000,1.0));\n    float dc = boxDist(p.zxy,vec3(1.0,1.0,100000));\n    return min(da,min(db,dc));\n}\n\nfloat crossDist2( in vec3 p )\n{\n    float da = boxDist(p.xyz,vec3(.7,.3,.3));\n    float db = boxDist(p.yzx,vec3(.3,.7,.3));\n    float dc = boxDist(p.zxy,vec3(.3,.3,.7));\n    return min(da,min(db,dc));\n}\n\n//--CSG Functions----------------------------------------------------------------------\n\nfloat diffFunc(float d1, float d2) {\n    return max(d1, -d2);\n}\n\nfloat intersectionFunc(float d1, float d2) {\n    return max(d1, d2);\n}\n\nfloat repeat( vec3 p, vec3 c )\n{\n    vec3 q = mod(p,c)-0.5*c;\n    vec4 height = texture(iChannel0, p.xz);\n    //float avg = clamp((height.x + height.y + height.z + height.w) / 4.0, 0.0, 2.0);\n    return roundBoxDist(q - vec3(0.0, 0.0, 0.0), vec3(.35, 0.1, .35), 0.1);\n}\n\nfloat displace( vec3 p )\n{\n    float d1 = torusDist(p, vec2(.2, .2));\n    float d2 = (sin(10.0*p.x)*sin(10.0*p.y)*sin(10.0*p.z)) / (16.0*p.y);\n    return d1+d2;\n}\n\nvec3 transform(vec3 pt, vec3 translate, vec3 rot, vec3 scale) {\n    scale.x = 1.0/scale.x;\n    scale.y = 1.0/scale.y;\n    scale.z = 1.0/scale.z;\n    mat3 invRot = mat3(scale.x*cos(rot.y)*cos(rot.x), sin(rot.y)*sin(rot.z)*cos(rot.x) - cos(rot.z)*sin(rot.x) , sin(rot.y)*sin(rot.x) + cos(rot.z)*sin(rot.y)*cos(rot.x) ,\n                       cos(rot.y)*sin(rot.x), (sin(rot.z)*sin(rot.y)*sin(rot.x) + cos(rot.z)*cos(rot.x))*scale.y, sin(rot.x)*sin(rot.y)*cos(rot.z) - cos(rot.x)*sin(rot.z),\n                       -sin(rot.y), cos(rot.y)*sin(rot.z), cos(rot.y)*cos(rot.z)*scale.z);\n \tmat4 trans = mat4(scale.x*cos(rot.y)*cos(rot.x), sin(rot.y)*sin(rot.z)*cos(rot.x) - cos(rot.z)*sin(rot.x) , sin(rot.y)*sin(rot.x) + cos(rot.z)*sin(rot.y)*cos(rot.x) , 0.0, \n                      cos(rot.y)*sin(rot.x), (sin(rot.z)*sin(rot.y)*sin(rot.x) + cos(rot.z)*cos(rot.x))*scale.y, sin(rot.x)*sin(rot.y)*cos(rot.z) - cos(rot.x)*sin(rot.z), 0.0, \n                      -sin(rot.y), cos(rot.y)*sin(rot.z), cos(rot.y)*cos(rot.z)*scale.z, 0.0, \n                      (-invRot*translate).x, (-invRot*translate).y, (-invRot*translate).z, 1.0);\n    \n    vec4 newPt = vec4(pt, 1.0);\n    newPt = trans*newPt;\n    return vec3(newPt);\n                    \n}\n\nvec2 myMin(vec2 d1, vec2 d2) {\n    \n    return (d1.x<d2.x) ? d1 : d2;\n}\n\n//--Different Scenes-------------------------------------------------------------------\n\nvec2 scene(vec3 ro, vec3 rd, float t) {\n    vec3 pt = ro + rd*t;\n    \n    float tmin = boxDist(pt - vec3(1.0, 0.0, -1.0), vec3(.3));\n    //vec2 obj = vec2(tmin, 0.0);\n    float s = 1.0;\n    for( int m=0; m<5; m++ )\n    {\n        vec3 a = mod( pt*s, 2.0 )-1.0;\n        s *= 3.0;\n        vec3 r = abs(1.0 - 3.0*abs(a));\n        \n        float da = max(r.x,r.y);\n        float db = max(r.y,r.z);\n        float dc = max(r.z,r.x);\n        float c = (min(da,min(db,dc))-1.0)/s;\n        \n        tmin = max(tmin,c);\n    }\n    vec2 obj = vec2(tmin, 0.0);\n    obj = myMin(obj, vec2(planeDist(pt - vec3(0.0, -1.0, 1.0)), 1.0));\n    obj = myMin(obj, vec2(displace(pt - vec3(-2.5, 0.0, 1.0)), 2.0));\n    obj = myMin(obj, vec2(diffFunc(boxDist(pt - vec3(-2.0, .5, -.5), vec3(0.30, 0.50, 0.30)), sphereDist(pt - vec3(-2.0, .5, -.5), 0.4)), 3.0));\n    obj = myMin(obj, vec2(torusDist(pt - vec3(0.3, -.2, 2.0), vec2(.3, .1)), 5.0));\n    vec3 pos = transform(pt, vec3(0.0), vec3(radians(iTime*100.), 0.0, 0.0), vec3(1.0));\n    obj = myMin(obj, vec2(crossDist2(pos), 6.0));\n    \n    vec4 color1 = texture (iChannel0, pt.xz/256.0);\n    float avg = (color1.x + color1.y + color1.z) / 3.0;\n    \n    //obj = myMin(obj, vec2(pt.y - (avg*2.0), 4.0));\n    \n    return obj;\n    \n}\n\n\n\n//--Ray Marching------------------------------------------------------------------\n\nvec3 calcNorm( in vec3 pos )\n{\n    vec3 eps = vec3( 0.001, 0.0, 0.0 );\n    vec3 nor = vec3(\n                    scene(pos+eps.xyy, vec3(0.0), 0.0).x - scene(pos-eps.xyy, vec3(0.0), 0.0).x,\n                    scene(pos+eps.yxy, vec3(0.0), 0.0).x - scene(pos-eps.yxy, vec3(0.0), 0.0).x,\n                    scene(pos+eps.yyx, vec3(0.0), 0.0).x - scene(pos-eps.yyx, vec3(0.0), 0.0).x );\n    return normalize(nor);\n}\n\nvec3 findRoot(vec3 ro, vec3 rd) {\n    float dist = 100.0;\n    float i = 0.0;\n    float numObj = 0.0;\n    for (float t = 0.0; t < 5.0; t += .005) {\n        i++;\n        vec2 obj = scene(ro, rd, t);\n        if (obj.x < 0.0) {\n            dist = t;\n            numObj = obj.y;\n            break;\n        }\n    }\n    \n    return vec3(dist, i, numObj);\n    \n}\n\nvec3 sphereTrace(vec3 ro, vec3 rd) {\n    float t = 0.0;\n    float dt;\n    vec2 objs;\n    float numTraces = 0.0;\n    float numObj = 0.0;\n    for (int i = 0; i < 50; i++) {\n        numTraces++;\n        objs = scene(ro, rd, t);\n        dt = objs.x;\n        numObj = objs.y;\n        t = t + dt;\n        if (dt < 0.0001) {\n            break;\n        }\n    }\n    return vec3(t, numTraces, numObj);\n}\n\nfloat softshadow( in vec3 ro, in vec3 rd, in float tmin, in float tmax )\n{\n    float shadow = 1.0;\n    float t = tmin;\n    float d = 0.0;\n    for( int i=0; i<16; i++ )\n    {\n        d = scene(ro, rd, t).x;\n        if (d < 0.0001) return 0.0;\n        shadow = min( shadow, 8.0*d/t );\n        t += d;\n        if( d<0.0001 || t > tmax) break;\n    }\n    return clamp(shadow, 0.0, 1.0);\n    \n}\n\nfloat ambientOcc( in vec3 pt, in vec3 norm )\n{\n    float occ = 0.0;\n    float d = 0.0;\n    for(float k=1.0; k<10.0; k++ )\n    {\n        d = scene(pt, norm, .01*k).x;\n        occ = (1.0 / pow(2.0, k)) * (k*.01 - d);\n    }\n    return clamp(1.0 - 3000.0*occ, 0.0, 1.0);\n}\n\nvec3 render(in vec3 ro, in vec3 rd) {\n    // TODO\n    int debug = 1;\n    bool root;\n    if (SPHERE_TRACE == 1) root = false;\n    else root = true;\n    vec3 col = vec3(.8, .9, 1.0);\n    float t = -1.0;\n    vec3 dist;\n    if (root) {\n        dist = findRoot(ro, rd);\n    }\n    else {\n        dist = sphereTrace(ro, rd);\n    }\n    t = dist.x;\n    if (t < 10.0) {\n        vec3 pt = ro + rd*t;\n        vec3 norm = calcNorm(pt);\n        vec4 diffuse = vec4(1.0);\n        //material\n        if (dist.z == 0.0) {\n            diffuse = vec4(0.0, 0.0, 0.0, 1.0);\n        }\n        if (dist.z == 1.0) {\n            vec4 x = texture( iChannel1, pt.yz );\n            vec4 y = texture( iChannel1, pt.zx );\n            vec4 z = texture( iChannel1, pt.yx );\n            vec3 a = abs(norm);\n            diffuse = (x*a.x + y*a.y + z*a.z) / (a.x + a.y + a.z);\n            \n        }\n        if (dist.z == 6.0) {\n            vec4 x = texture( iChannel2, pt.yz );\n            vec4 y = texture( iChannel2, pt.zx );\n            vec4 z = texture( iChannel2, pt.yx );\n            vec3 a = abs(norm);\n            diffuse = (x*a.x + y*a.y + z*a.z) / (a.x + a.y + a.z);\n        }\n        //end material\n        if (dist.z == 2.0) {\n            diffuse = vec4(0.0, 1.0, 0.0, 1.0);\n        }\n        if (dist.z == 3.0) {\n            diffuse = vec4(0.0, 1.0, 1.0, 1.0);\n        }\n        if (dist.z == 5.0) {\n            diffuse = vec4(1.0, 0.0, 0.0, 1.0);\n        }\n        vec3 ref = reflect(rd, norm);\n        vec3 light = normalize(vec3(0.0, 2.0, 2.0) - pt);\n        float lambert = clamp(dot(light, norm), 0.0, 1.0);\n        float amb = ambientOcc(pt, norm);\n        //soft shadows\n        lambert *= softshadow( pt, light, 0.02, 2.5 );\n        float dom = smoothstep( -0.1, 0.1, ref.y );\n        dom *= softshadow( pt, ref, 0.02, 2.5 );\n        \n        float specular = 0.0;\n        if (lambert > 0.0) {\n            vec3 viewDir = normalize(-pt);\n            vec3 halfDir = normalize(light + viewDir);\n            float specAngle = clamp(dot(halfDir, norm), 0.0, 1.0);\n            specular = pow(specAngle, 8.0);\n            \n        }\n        \n        col = vec3(amb*.2) + lambert * vec3(diffuse) + dom * specular * vec3(0.5);\n        \n        //col = pow(col, vec3(1.0/2.2));\n        col *= 1.0 - smoothstep( 20.0, 40.0, t );\n        \n        \n            \n        if (NORMALS == 1) {\n            col = norm;\n        }\n        else if (RAY_STEPS == 1) {\n            if (root) {\n                col = vec3(1.0, 0.0, 0.0)*(dist.y / 1000.0);\n            }\n            else {\n                col = vec3(1.0, 0.0, 0.0)*(dist.y / 50.0);\n            }\n        }\n        else if (DISTANCE == 1) {\n            col = vec3(1.0) * ((5.0 - t) / 5.0);\n        }\n    }\n    return col; //rd;  // camera ray direction debug view\n}\n\nmat3 setCamera(in vec3 ro, in vec3 ta, float cr) {\n    // Starter code from iq's Raymarching Primitives\n    // https://www.shadertoy.com/view/Xds3zN\n    \n    vec3 cw = normalize(ta - ro);\n    vec3 cp = vec3(sin(cr), cos(cr), 0.0);\n    vec3 cu = normalize(cross(cw, cp));\n    vec3 cv = normalize(cross(cu, cw));\n    return mat3(cu, cv, cw);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Starter code from iq's Raymarching Primitives\n    // https://www.shadertoy.com/view/Xds3zN\n   \n    vec2 q = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * q;\n    p.x *= iResolution.x / iResolution.y;\n    vec2 mo = iMouse.xy / iResolution.xy;\n    \n    float time = 15.0 + iTime;\n    \n    // camera\n    vec3 ro = vec3(\n                   -0.5 + 3.5 * cos(0.1 * time + 6.0 * mo.x),\n                   1.0 + 2.0 * mo.y,\n                   0.5 + 3.5 * sin(0.1 * time + 6.0 * mo.x));\n    vec3 ta = vec3(-0.5, -0.4, 0.5);\n    \n    // camera-to-world transformation\n    mat3 ca = setCamera(ro, ta, 0.0);\n    \n    // ray direction\n    vec3 rd = ca * normalize(vec3(p.xy, 2.0));\n    \n    // render\n    vec3 col = render(ro, rd);\n    \n    col = pow(col, vec3(0.4545));\n    \n    fragColor = vec4(col, 1.0);\n}","name":"","description":"","type":"image"}]}