{"ver":"0.1","info":{"id":"csBXW3","date":"1671747216","viewed":153,"name":"Messing with raymarching lol","username":"Oman395","description":"fun","likes":2,"published":1,"flags":32,"usePreview":0,"tags":["fun"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":2,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const int mode = 0;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = getUv(fragCoord, iResolution.xy);\n    vec2 screenUv = fragCoord / iResolution.xy;\n    vec3 dir = getRayDir(uv, iTime, iMouse.xy / iResolution.xy);\n    vec3 oDir = dir;\n    Collision marched = march(Ray(getCamPos(iMouse.xy / iResolution.xy, iTime), dir), iTime, -2);\n    vec4 lights;\n    if(!USE_N_LIGHTS) lights = vec4(1,1,1,1);\n    else lights = getLights(marched.pos, dir, marched.normal, iTime, marched.id, marched.mat);\n    vec4 col;\n    if(marched.id == -1) col = texture(iChannel2, dir) * getLights(marched.pos, dir, marched.normal, iTime, marched.id, marched.mat);\n    else col = marched.mat.color * (1.0 - marched.mat.refAmnt);\n    float refAmnt = marched.mat.refAmnt;\n    int refs = 0;\n    col *= lights;\n    while(marched.id != -1 && refs < REF_COUNT && refAmnt > 0.0) {\n        dir = reflect(dir, marched.normal * vec3(1,1,1));\n        marched = march(Ray(marched.pos, dir), iTime, marched.id);\n        if(USE_N_LIGHTS && marched.id != -1 && mode != 0) {\n            vec4 colOfOther = marched.mat.color * getLights(marched.pos, dir, marched.normal, iTime, marched.id, marched.mat);\n            col = colOfOther;\n            break;\n        } else if(USE_N_LIGHTS && mode == 0) {\n            col += texture(iChannel2, dir) * getLights(marched.pos, dir, marched.normal, iTime, marched.id, marched.mat) * refAmnt;\n        }\n        refAmnt *= marched.mat.refAmnt;\n        refs++;\n    }\n    if(mode == 0) {\n        fragColor = col;\n    } else if(mode == 1) {\n        fragColor = col;\n    } else if(mode == 2) {\n        fragColor = texture(iChannel0, screenUv);\n    } else if(mode == 3) {\n        fragColor = vec4(dir, 0);\n    } else if(mode == 4) {\n        fragColor = texture(iChannel1, screenUv);\n    } else if(mode == 5) {\n        fragColor = vec4(dir, 0);\n    }\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// Quick note for people tweaking this, who aren't familiar with shadertoy: if it says int, DO NOT USE A DECIMAL. If it says float, USE A DECIMAL, EVEN IF IT'S A WHOLE NUMBER!\n// Bool is easy, just true/false, and the vec3/4/whatever doesn't care about decimals as long as there are the correct number of inputs.\n\n// I don't recommend tweaking these\nconst float MAX_DIST = 10.0;\nconst float MIN_DIST = 0.000001;\nconst vec2 EPSILON = vec2(0.00001, 0.0);\n\n// Light settings\nconst float AMBIENT_INT = 1.0;\nconst float CUBEMAP_REF = 1.0;\nconst vec4 AMBIENT_COLOR = vec4(1,1,1,1);\n\n// Smoothmin (k is really fun to tweak :D)\nconst float K = 0.5;\nconst bool SMIN = true;\n\n// Quality\nconst int MARCH_COUNT = 256;\nconst int REF_COUNT = 5;\nconst float SPEED = 1.0;\n\n// Camera\nconst vec3 CAM_START_POS = vec3(0,0,-3);\n\n// Fun\nconst bool S_BOXES = true;\nconst float BOX_RAD = 0.05;\nconst bool TOROUS = false; // This needs a decently high MARCH_COUNT to render properly\nconst float TOROUS_WIDTH = 0.2;\nconst bool SPIRAL = true;\n\n// Options (Also don't recommend tweaking, unless you can edit the sphere, box, and light arrays)\nconst bool USE_N_LIGHTS = true;\nconst bool USE_SPHERES = true;\nconst bool USE_BOXES = true;\n\nstruct Ray {\n    vec3 pos;\n    vec3 dir;\n};\n\nstruct Material {\n    vec4 color;\n    float refAmnt;\n    float diffuse;\n    float specular;\n    float specularKs;\n    float ambientRef;\n};\n\nstruct Sphere {\n    vec3 pos;\n    float rad;\n    Material mat;\n    int id;\n};\n\nstruct Box {\n    vec3 pos;\n    vec3 bounds;\n    Material mat;\n    int id;\n};\n\nstruct Light {\n    vec3 pos;\n    float inten;\n    vec4 col;\n};\n\nstruct Collision {\n    float dist;\n    vec3 pos;\n    vec3 normal;\n    Material mat;\n    int id;\n};\n\nconst Material DEFAULT_MATERIAL_REFLECTIVE = Material(vec4(1,1,1,1), 1.0, 0.5, 50.0, 0.05, 0.1);\nconst Material DEFAULT_MATERIAL = Material(vec4(1,1,1,1), 0.0, 0.5, 50.0, 0.05, 0.1);\nSphere spheres[] = Sphere[](\nSphere(vec3(0,0,0), 0.5, DEFAULT_MATERIAL_REFLECTIVE, 0)\n);\nBox boxes[] = Box[](\n    Box(vec3(0, 0, 0), vec3(2,0.1,0.1), DEFAULT_MATERIAL_REFLECTIVE, 1)\n);\nLight lights[] = Light[](\nLight(vec3(0,20,-10), 1.0, vec4(1,1,1,1))\n);\n\nvec3 sphereOffsets(Sphere s, float iTime) {\n    if(SPIRAL) {\n        return vec3(cos(iTime * SPEED) * 1.5 * (sin(iTime * SPEED / 10.0)), sin(iTime * SPEED) * 1.5 * (sin(iTime * SPEED / 10.0)), 0);\n    } else {\n        return vec3(cos(iTime * SPEED) * 1.5, sin(iTime * SPEED) * 1.5, 0);\n    }\n    // return vec3(0,-1,0);\n}\n\nfloat sdf_Sphere(Sphere s, vec3 p, float iTime) {\n    s.pos += sphereOffsets(s, iTime);\n    if(!TOROUS) {\n        return distance(s.pos, p) - s.rad;\n    } else {\n        p -= s.pos;\n        vec2 t = vec2(s.rad, TOROUS_WIDTH);\n        vec2 q = vec2(length(p.xz)-t.x,p.y);\n        return length(q)-t.y;\n    }\n}\n\nfloat sdf_Box(vec3 pos, Box box, float iTime) {\n    if(!S_BOXES) {\n        vec3 d = abs(pos - box.pos) - box.bounds;\n        return min(max(d.x, max(d.y,d.z)), 0.0) + length(max(d, 0.0));\n    } else {\n        vec3 q = abs(pos) - box.bounds;\n        return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - BOX_RAD;\n    }\n}\n\nfloat smin(float a, float b, float k) {\n  float h = clamp(0.5 + 0.5 * (b - a) / k, 0.0, 1.0);\n  return mix(b, a, h) - k * h * (1.0 - h);\n}\n\nvec3 rotate(vec3 vec, vec2 angles) {\n    angles = angles.yx;\n    vec = vec3(\n        vec.x,\n        vec.y * cos(angles.x) - vec.z * sin(angles.x),\n        vec.y * sin(angles.x) + vec.z * cos(angles.x)\n    );\n    vec = vec3(\n        vec.x * cos(angles.y) + vec.z * sin(angles.y),\n        vec.y,\n        -vec.x * sin(angles.y) + vec.z * cos(angles.y)\n    );\n    return vec;\n}\n\nvec2 getUv(vec2 fragCoord, vec2 iResolution) {\n    return (-(vec2(0.5, 0.5) - fragCoord / iResolution)) * vec2(iResolution.x / iResolution.y, 1);\n}\n\nvec2 getCamDir(vec2 uv, float iTime, vec2 iMouse) {\n    return vec2( iMouse.x * 3.14159265 * 2.0 + 3.14159265, 3.14159265 - iMouse.y * 3.14159265 + 3.14159265 * 1.5);\n    return vec2(0,0);\n}\n\nvec3 getRayDir(vec2 uv, float iTime, vec2 iMouse) {\n    vec3 dirS = normalize(vec3(uv, 1.0));\n    vec2 camDir = getCamDir(uv, iTime, iMouse) + EPSILON.xx;\n    return rotate(dirS, camDir);\n}\n\nvec3 getCamPos(vec2 iMouse, float iTime) {\n    vec3 pos = CAM_START_POS;\n    vec2 camDir = getCamDir(vec2(0,0), iTime, iMouse) + EPSILON.xx;\n    return rotate(pos, camDir);\n}\n\nCollision sdf_Scene(vec3 p, float iTime, int ignore) {\n    float minDist = MAX_DIST * 2.0;\n    float actualDist = -1.0;\n    Material mat = DEFAULT_MATERIAL;\n    vec3 normal = vec3(0,0,0);\n    int id = -1;\n    if(USE_SPHERES) {\n        for(int i = 0; i < spheres.length(); i++) {\n            if(spheres[i].id == ignore) continue;\n            float dist = sdf_Sphere(spheres[i], p, iTime);\n            if(actualDist == -1.0) actualDist = dist;\n            else if(SMIN) actualDist = smin(actualDist, dist, K);\n            else actualDist = min(actualDist, dist);\n            if(dist < minDist) {\n                id = spheres[i].id;\n                minDist = dist;\n                mat = spheres[i].mat;\n            }\n        }\n    }\n    if(USE_BOXES) {\n        for(int i = 0; i < boxes.length(); i++) {\n            if(boxes[i].id == ignore) continue;\n            float dist = sdf_Box(p, boxes[i], iTime);\n            if(actualDist == -1.0) actualDist = dist;\n            else if(SMIN) actualDist = smin(actualDist, dist, K);\n            else actualDist = min(actualDist, dist);\n            if(dist < minDist) {\n                id = boxes[i].id;\n                minDist = dist;\n                mat = boxes[i].mat;\n            }\n        }\n    }\n    return Collision(actualDist, p, normal, mat, id);\n}\n\nCollision march(Ray ray, float iTime, int ignore) {\n    Collision sceneCol;\n    for(int i = 0; i < MARCH_COUNT; i++) {\n        sceneCol = sdf_Scene(ray.pos, iTime, ignore);\n        // Now we need to calculate the normals\n        if(sceneCol.id != -1) { // We don't need the normals for when the ray goes too far lol\n            vec3 normal1 = vec3(\n                sdf_Scene(ray.pos + EPSILON.xyy, iTime, ignore).dist,\n                sdf_Scene(ray.pos + EPSILON.yxy, iTime, ignore).dist,\n                sdf_Scene(ray.pos + EPSILON.yyx, iTime, ignore).dist\n            );\n            vec3 normal2 = vec3(\n                sdf_Scene(ray.pos - EPSILON.xyy, iTime, ignore).dist,\n                sdf_Scene(ray.pos - EPSILON.yxy, iTime, ignore).dist,\n                sdf_Scene(ray.pos - EPSILON.yyx, iTime, ignore).dist            \n            );\n            sceneCol.normal = normalize(normal1 - normal2);\n        }\n        if(sceneCol.dist < MIN_DIST) {\n            return sceneCol;\n        }\n        if(sceneCol.dist > MAX_DIST) {\n            return Collision(-1.0, vec3(0,0,0), vec3(0,0,0), DEFAULT_MATERIAL, -1);\n        };\n        ray.pos += sceneCol.dist * ray.dir;\n    }\n    return sceneCol;\n}\n\nbool reachesLight(vec3 start, Light light, float iTime) {\n    Ray ray = Ray(light.pos, normalize(start - light.pos));\n    for(int i = 0; i < MARCH_COUNT; i++) {\n        float lightDist = distance(ray.pos, start);\n        Collision col = sdf_Scene(ray.pos, iTime, -2);\n        if(lightDist < col.dist + 0.01) return true;\n        ray.pos += col.dist * ray.dir;\n    }\n    return false;\n}\n\nfloat diff(float Kd, float Ip, vec3 N, vec3 L) {\n    return Kd * Ip * dot(N, L);\n}\n\nvec4 getLight(vec3 pos, vec3 origDir, Light light, vec3 normal, float iTime, Material mat) {\n    if(!reachesLight(pos, light, iTime)) return vec4(0,0,0,0);\n    vec3 posToLight = normalize(light.pos - pos);\n    vec3 amount = vec3(0,0,0);\n    amount += (diff(mat.diffuse, light.inten, normal, posToLight)); // Diffuse lighting\n    amount += mat.specularKs * light.inten * pow(cos(length(normal - posToLight)), mat.specular); // Specular highlight\n    return vec4(length(amount));\n}\n\nvec4 getLights(vec3 pos, vec3 origDir, vec3 normal, float iTime, int ignore, Material mat) {\n    vec4 acc = vec4(0,0,0,0);\n    if(USE_N_LIGHTS) {\n        for(int i = 0; i < lights.length(); i++) {\n            acc += getLight(pos, origDir, lights[i], normal, iTime, mat);\n        }\n    }\n    if(ignore != -1) {\n        acc += AMBIENT_COLOR * mat.ambientRef * AMBIENT_INT;\n    } else {\n        acc += AMBIENT_COLOR * CUBEMAP_REF * AMBIENT_INT;\n    }\n    return acc;\n}","name":"Common","description":"","type":"common"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = getUv(fragCoord, iResolution.xy);\n    vec2 screenUv = fragCoord / iResolution.xy;\n    vec3 dir = getRayDir(uv, iTime, iMouse.xy / iResolution.xy);\n    Collision marched = march(Ray(getCamPos(iMouse.xy / iResolution.xy, iTime), dir), iTime, -2);\n    fragColor = vec4(marched.normal, 1.0);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[{"id":"XsXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = getUv(fragCoord, iResolution.xy);\n    vec2 screenUv = fragCoord / iResolution.xy;\n    vec3 dir = getRayDir(uv, iTime, iMouse.xy / iResolution.xy);\n    vec3 oDir = dir;\n    Collision marched = march(Ray(getCamPos(iMouse.xy / iResolution.xy, iTime), dir), iTime, -2);\n    fragColor = vec4((marched.dist / MAX_DIST));\n}","name":"Buffer B","description":"","type":"buffer"}]}