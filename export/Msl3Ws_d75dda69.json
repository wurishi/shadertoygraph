{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[],"code":"// I find this useful because you can specify the function in code. This allows:\n\n// neat use and sharing of variables and constants\n// subroutines\n// compound functions (such as diffs)\n// animated functions\n// algorithmic functions\n// parametric functions (although expensive and rendering is crap right now)\n// procedural colour\n// use mouse input\n\n//TODO\n// make parametric plot connected dots\n// mouse or keyboard changes zoom?\n// grid lines?\n// make rendering scale invariant so that the graph can be drawn in arbitrary regions of the frame\n// higher dimensional plots?\n\n// use these to turn off a function\n#define NO_FN\ty = 0.;col=vec4(0.); return false;\n#define NO_FN_P\tx = y = mint = maxt = 0.; col = vec4(0.); return false;\n\n// simple macros to pull mouse position in [0,1]\n#define MOUSEX\tiMouse.x/iResolution.x\n#define MOUSEY\tiMouse.y/iResolution.y\n\n#define PI 3.1415927\n#define PARAMETRIC_STEPS 100\n\nvec3 errorColour( float err, float maxerror );\n\n// the functions. return true means 'plot me'\n\n// cosine - dashed line\nbool fn1( float x, out float y, out vec4 col )\n{\n\tcol = vec4(1.,0.7,0.,1.);\n\t// dash\n\tcol.a = floor(mod(x * 20.,2.));\n\t\n\tif( x < 0. )\n\t{\n\t\ty = 0.;\n\t\treturn true;\n\t}\n\t\n\ty = 1.-(.5+.5*cos(x*PI));\n\t\n\treturn true;\n}\n\n// smoothstep - solid blue\nbool fn2( float x, out float y, out vec4 col )\n{\n\tcol = vec4(0.,0.,1.,1.);\n\t\n\ty = smoothstep( 0., 1., x ) ;\n\t\n\treturn true;\n}\n\n// error function between smoothstep and cosine\n// blue = 0 error, red = difference of 0.01\nbool fn3( float x, out float y, out vec4 col )\n{\n\tcol = vec4(1.,0.,0.,1.);\n\tvec4 dcol1, dcol2;\n\tfloat y1, y2;\n\tfn1( x, y1, dcol1 );\n\tfn2( x, y2, dcol1 );\n\t//scale to make visible\n\ty = 10.*abs( y1 - y2 );\n\t\n\t// transformations to map from blue to red\n\tfloat maxerror = 0.01;\n\tcol.xyz = errorColour( abs(y1 - y2), maxerror );\n\treturn true;\n}\n\nbool pfn1( float t, out float x, out float y, out vec4 col, out float mint, out float maxt );\n\n// algorithmic function. finds height of trochoids using fixed point iteration.\n// i presented this in a gdc talk: http://www.huwbowles.com/fpi-gdc-2016/\n// compared to the talk, this is a slightly different formulation - it computes\n// the \"error\" as the current x minus the desired x, and uses this to update t.\n// if you write this down and expand it out, it will boil down to exactly the\n// same thing.\nbool fn4( float x, out float y, out vec4 col )\n{\n\t// need to guess t such that the wave function returns our x.\n\t\n\t// initial guess - the average position of a surface point (look at the trochoid\n\t// x equation)\n\tfloat t0 = x ;\n\tfloat t = t0;\n\t\n\tfloat px,py = 0.;\n\tvec4 dcol;\n\tfloat mint, maxt;\n\t\n\t// 2 fpi iterations to find trochoid height\n    for( int i = 0; i < 2; i++ )\n    {\n        pfn1( t, px, py, dcol, mint, maxt );\n        t -= px - x;\n    }\n\t\n\t// evalue height at final t\n\tpfn1( t, px, py, dcol, mint, maxt );\n\t\n\ty = py;\n\t\n\tcol = vec4(0.5,.6,1.0,1.);\n\t\n\treturn true;\n}\n\n// unused\nbool fn5( float x, out float y, out vec4 col )\n{\n\tNO_FN;\n}\n\n// parametric curve - trochoids/gerstner waves\nbool pfn1( float t, out float x, out float y, out vec4 col, out float mint, out float maxt )\n{\n\t// based on http://graphics.ucsd.edu/courses/rendering/2005/jdewall/tessendorf.pdf\n\tconst float amp = .04;\n\tconst float wavelength = .5;\n\tconst float wave_vector = 2.*PI/wavelength;\n\t\n\t// for deep ocean waves, angular vel ^ 2 = gravity * wavelength\n\tfloat om = sqrt( 9.8 * wave_vector ) * .2 ; // .2 is hack because we're not using real scales\n\n\tx = t + amp*sin(-wave_vector*t + om*iTime);\n\ty = amp*cos(-wave_vector*t + om*iTime);\n\t\n\t// move down to fit with other curves\n\ty -= .05;\n\t\n\tcol = vec4(1.);\n\tmint = 0.;\n\tmaxt = 2.;\n\treturn true;\n}\n// define a body here and then uncomment the 2nd parametric plotting code\nbool pfn2( float t, out float x, out float y, out vec4 col, out float mint, out float maxt )\n{\n\tNO_FN_P;\n}\n\nfloat drawNumber( float num, vec2 pos, vec2 pixel_coords );\n\n// p is in [0,1]. \nvec4 graph( vec2 p, float xmin, float xmax, float ymin, float ymax, float width )\n{\n\tvec4 result = vec4(0.1);\n\t\n\tfloat thisx = xmin + (xmax-xmin)*p.x;\n\tfloat thisy = ymin + (ymax-ymin)*p.y;\n\t\n\t// compute gradient between this pixel and next (seems reasonable)\n\tfloat eps = dFdx(thisx);\n\n\tfloat alpha;\n\t\n\tvec4 axisCol = vec4(vec3(.3),1.);\n\t\n\t// axes\n\t// x\n\talpha = abs( thisy - 0. ); alpha = smoothstep( width, width/4., alpha );\n\tresult = (1.-alpha)*result + alpha*axisCol;\n\t// y\n\talpha = abs( thisx - 0. ); alpha = smoothstep( width, width/4., alpha );\n\tresult = (1.-alpha)*result + alpha*axisCol;\n\t\n\t/*\n\t// show white bars to illustrate mouse position\n\tvec4 mouseBarCol = vec4(1.);\n\talpha = abs( ymin - thisy ); alpha = smoothstep( width, width/4., alpha );\n\talpha *= 1.-step(MOUSEX,p.x);\n\tresult = (1.-alpha)*result + alpha*mouseBarCol;\n\talpha = abs( xmin - thisx ); alpha = smoothstep( width, width/4., alpha );\n\talpha *= 1.-step(MOUSEY,p.y);\n\tresult = (1.-alpha)*result + alpha*mouseBarCol;\n\t*/\n\t\n\t// uses iq's awesome distance to implicit https://iquilezles.org/articles/distance\n\tfloat f;\n\tvec4 fcol;\n\tif( fn5( thisx, f, fcol ) )\n\t{\n\t\tfloat f_1; fn5( thisx + eps, f_1, fcol ); float f_prime = (f_1 - f) / eps;\n\t\talpha = abs(thisy - f)/sqrt(1.+f_prime*f_prime); alpha = smoothstep( width, width/4., alpha ); alpha *= fcol.a;\n\t\tresult = (1.-alpha)*result + alpha*fcol;\n\t}\n\tif( fn4( thisx, f, fcol ) )\n\t{\n\t\tfloat f_1; fn4( thisx + eps, f_1, fcol ); float f_prime = (f_1 - f) / eps;\n\t\talpha = abs(thisy - f)/sqrt(1.+f_prime*f_prime); alpha = smoothstep( width, width/4., alpha ); alpha *= fcol.a;\n\t\tresult = (1.-alpha)*result + alpha*fcol;\n\t}\n\tif( fn3( thisx, f, fcol ) )\n\t{\n\t\tfloat f_1; fn3( thisx + eps, f_1, fcol ); float f_prime = (f_1 - f) / eps;\n\t\talpha = abs(thisy - f)/sqrt(1.+f_prime*f_prime); alpha = smoothstep( width, width/4., alpha ); alpha *= fcol.a;\n\t\tresult = (1.-alpha)*result + alpha*fcol;\n\t}\n\tif( fn2( thisx, f, fcol ) )\n\t{\n\t\tfloat f_1; fn2( thisx + eps, f_1, fcol ); float f_prime = (f_1 - f) / eps;\n\t\talpha = abs(thisy - f)/sqrt(1.+f_prime*f_prime); alpha = smoothstep( width, width/4., alpha ); alpha *= fcol.a;\n\t\tresult = (1.-alpha)*result + alpha*fcol;\n\t}\n\tif( fn1( thisx, f, fcol ) )\n\t{\n\t\tfloat f_1; fn1( thisx + eps, f_1, fcol ); float f_prime = (f_1 - f) / eps;\n\t\talpha = abs(thisy - f)/sqrt(1.+f_prime*f_prime); alpha = smoothstep( width, width/4., alpha ); alpha *= fcol.a;\n\t\tresult = (1.-alpha)*result + alpha*fcol;\n\t}\n\t\n\t// parametric curves. todo - join the dots!\n\tfloat x, mint, maxt;\n\tif( pfn1( 0., x, f, fcol, mint, maxt ) )\n\t{\n\t\tfloat dt = (maxt-mint)/float(PARAMETRIC_STEPS);\n\t\tfloat t = mint;\n\t\tfor( int i = 0; i <= PARAMETRIC_STEPS; i++ )\n\t\t{\n\t\t\tpfn1( t, x, f, fcol, mint, maxt );\n\t\t\talpha = length(vec2(x,f)-vec2(thisx,thisy));\n\t\t\talpha = smoothstep( width, width/4., alpha ); alpha *= fcol.a;\n\t\t\tresult = (1.-alpha)*result + alpha*fcol;\n\t\t\tt += dt;\n\t\t}\n\t}\n\t// uncomment to add a second parametric plot\n\t/*\n\tif( pfn2( 0., x, f, fcol, mint, maxt ) )\n\t{\n\t\tfloat dt = (maxt-mint)/float(PARAMETRIC_STEPS);\n\t\tfloat t = mint;\n\t\tfor( int i = 0; i <= PARAMETRIC_STEPS; i++ )\n\t\t{\n\t\t\tpfn2( t, x, f, fcol, mint, maxt );\n\t\t\talpha = length(vec2(x,f)-vec2(thisx,thisy));\n\t\t\talpha = smoothstep( width, width/4., alpha ); alpha *= fcol.a;\n\t\t\tresult = (1.-alpha)*result + alpha*fcol;\n\t\t\tt += dt;\n\t\t}\n\t}\n\t*/\n\t\n\tresult += vec4(drawNumber(xmin, vec2(0.,0.)+vec2(1.)/iResolution.xy, p ));\n\tresult += vec4(drawNumber(xmax, vec2(1.,0.)+vec2(-26.,1.)/iResolution.xy, p ));\n\tresult += vec4(drawNumber(ymax, vec2(0.,1.)+vec2(1.,-7.)/iResolution.xy, p ));\n\tresult += vec4(drawNumber(ymin, vec2(0.,0.)+vec2(1.,10.)/iResolution.xy, p ));\n\t\n\treturn result;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n \n\tfragColor = graph( uv, 0., 1., -.1, 1., .01 );\n\n\treturn;\n}\n\n\n// digits based on the nice ascii shader by movAX13h\n\nfloat drawDig( vec2 pos, vec2 pixel_coords, float bitfield )\n{\n\t// offset relative to \n\tvec2 ic = pixel_coords - pos ;\n\tic = floor(ic*iResolution.xy);\n\t// test if overlap letter\n\tif( clamp(ic.x, 0., 2.) == ic.x && clamp(ic.y, 0., 4.) == ic.y )\n\t{\n\t\t// compute 1d bitindex from 2d pos\n\t\tfloat bitIndex = ic.y*3.+ic.x;\n\t\t// isolate the bit\n\t\treturn floor( mod( bitfield / exp2( floor(bitIndex) ), 2. ) );\n\t}\n\treturn 0.;\n}\n// decimal point\nfloat drawDecPt( vec2 center, vec2 pixel_coords )\n{\n\treturn drawDig( center, pixel_coords, 1. );\n}\n// minus sign\nfloat drawMinus( vec2 center, vec2 pixel_coords )\n{\n\treturn drawDig( center, pixel_coords, 448. );\n}\n// digits 0 to 9\nfloat drawDigit( float dig, vec2 pos, vec2 pixel_coords )\n{\n\tif( dig == 1. )\n\t\treturn drawDig( pos, pixel_coords, 18724. );\n\tif( dig == 2. )\n\t\treturn drawDig( pos, pixel_coords, 31183. );\n\tif( dig == 3. )\n\t\treturn drawDig( pos, pixel_coords, 31207. );\n\tif( dig == 4. )\n\t\treturn drawDig( pos, pixel_coords, 23524. );\n\tif( dig == 5. )\n\t\treturn drawDig( pos, pixel_coords, 29671. );\n\tif( dig == 6. )\n\t\treturn drawDig( pos, pixel_coords, 29679. );\n\tif( dig == 7. )\n\t\treturn drawDig( pos, pixel_coords, 31012. );\n\tif( dig == 8. )\n\t\treturn drawDig( pos, pixel_coords, 31727. );\n\tif( dig == 9. )\n\t\treturn drawDig( pos, pixel_coords, 31719. );\n\t// 0\n\treturn drawDig( pos, pixel_coords, 31599. );\n}\n\n// max num width is 26px (minus, 3 nums, dec pt, 2 nums)\n// max height is 6px\nfloat drawNumber( float num, vec2 pos, vec2 pixel_coords )\n{\n\tfloat result = 0.;\n\tbool on = false;\n\tfloat d;\n\t\n\t// minus sign\n\tif( num < 0. )\n\t{\n\t\tresult += drawMinus( pos, pixel_coords );\n\t\tpos.x += 4. / iResolution.x;\n\t\tnum = -num;\n\t}\n\t// hundreds\n\td = floor(mod(num/100.,10.));\n\tif( on || d > 0. )\n\t{\n\t\tresult += drawDigit( d, pos, pixel_coords );\n\t\tpos.x += 4. / iResolution.x;\n\t\ton = true;\n\t}\n\t// tens\n\td = floor(mod(num/10.,10.));\n\tif( on || d > 0. )\n\t{\n\t\tresult += drawDigit( d, pos, pixel_coords );\n\t\tpos.x += 4. / iResolution.x;\n\t\ton = true;\n\t}\n\t// ones\n\td = floor(mod(num,10.));\n\tresult += drawDigit( d, pos, pixel_coords );\n\tpos.x += 4. / iResolution.x;\n\t// dec pt\n\tresult += drawDecPt( pos, pixel_coords );\n\tpos.x += 2. / iResolution.x;\n\t// tenths\n\td = floor(mod(num/.1,10.));\n\tif( true )\n\t{\n\t\tresult += drawDigit( d, pos, pixel_coords );\n\t\tpos.x += 4. / iResolution.x;\n\t}\n\t// hundredths\n\td = floor(.5+mod(num/.01,10.));\n\tif( d > 0. )\n\t{\n\t\tresult += drawDigit( d, pos, pixel_coords );\n\t\tpos.x += 4. / iResolution.x;\n\t}\n\t\n\treturn clamp(result,0.,1.);\n}\n\nvec3 hsv2rgb(vec3 c);\nvec3 rgb2hsv(vec3 c);\n\nvec3 errorColour( float err, float maxerror )\n{\n\terr = 1. - err / maxerror;\n\terr *= 2. / 3.;\n\treturn hsv2rgb( vec3(err, 1., 1.) );\n}\n\n//http://lolengine.net/blog/2013/07/27/rgb-to-hsv-in-glsl\n\nvec3 rgb2hsv(vec3 c)\n{\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"Msl3Ws","date":"1382187453","viewed":1438,"name":"TinyGrapher","username":"huwb","description":"A simple graphing app. For most functions an online plotter such as iqs excellent graphtoy works well. I made this to help with more complex plots, see code comments for examples.","likes":30,"published":1,"flags":0,"usePreview":0,"tags":["graph","grapher"],"hasliked":0,"parentid":"","parentname":""}}