{"ver":"0.1","info":{"id":"wsGXzR","date":"1573315771","viewed":518,"name":"Icosahedron hive","username":"munrocket","description":"Made specially for competition of webgl community t.me/webgl_ru\n[2019-11-09] and accidentally re-uploaded.","likes":15,"published":1,"flags":0,"usePreview":0,"tags":["icosahedron","trypophobia","hive"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS 100.\n#define MAX_DIST 2.8\n#define DIFF_EPS 0.001\n#define SHAD_EPS 0.004\n#define vdouble(p, v) min(length(p - v), length(p + v))\n\nfloat vicosahedron(vec3 p, float r0, float h) {\n    float hPhi = h * PHI;\n    float d = vdouble(p, vec3( h, hPhi, 0.));\n    d = min(d, vdouble(p, vec3(-h, hPhi, 0.)));\n    d = min(d, vdouble(p, vec3(hPhi, 0., h)));\n    d = min(d, vdouble(p, vec3(hPhi, 0.,-h)));\n    d = min(d, vdouble(p, vec3(0., h, hPhi)));\n    d = min(d, vdouble(p, vec3(0.,-h, hPhi)));\n    return d - r0;\n}\n\nfloat map(vec3 p) {\n    float r = length(p);\n    float phi = atan(p.y / p.x);\n    float tetha = acos(p.z / r);\n    float displace = 0.01 * cos(20. * (phi + tetha)) * sin(tetha);\n    float d = r - 0.9 + displace;\n    d = opSubstr(d, vicosahedron(p, 0.4, 0.45), 0.1);\n    d = min(d, vicosahedron(p, 0.4, 0.3));\n    d = opSubstr(d, vicosahedron(p, 0.2, 0.41), 0.03);\n    return min(d, r - .65 - 0.005 * sin(2.*iTime));\n}\n\nvec3 normal(vec3 pos) {\n    vec2 e = vec2(DIFF_EPS, 0.);\n    vec3 N = vec3(\tmap(pos + e.xyy) - map(pos - e.xyy),\n        \t\t\tmap(pos + e.yxy) - map(pos - e.yxy),\n        \t\t\tmap(pos + e.yyx) - map(pos - e.yyx));\n   \treturn normalize(N);\n}\n\nvec2 rayCast(vec3 camera, vec3 dir) {\n    vec3 pos;\n    float t = 0., dt = MAX_DIST, I;\n    for(float i = 0.; i < MAX_STEPS; i++) {\n        if(dt < DIFF_EPS || t > MAX_DIST) break;\n    \tpos = camera + t * dir;\n        dt = map(pos);\n        t += dt;\n        I = i;\n    }\n    return vec2(mix(t, -1., step(MAX_DIST, t)), I / MAX_STEPS);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    vec2 uv = (2.*fragCoord - iResolution.xy) / min(iResolution.x, iResolution.y);\n    vec3 camera = vec3(0., 0., 2.5);\n    vec3 dir = normalize(vec3(uv, -2.));\n    vec3 sun_dir = normalize(vec3(-2., 2., 2.));\n    vec3 sky_dir = normalize(vec3(0.,1.,0.2));\n    \n    vec4 mouse = qmouse(iMouse, iResolution, iTime, 0.15);\n    dir = rotate(dir, mouse);\n    camera = rotate(camera, mouse);\n    sun_dir = rotate(sun_dir, mouse);\n    sky_dir = rotate(sky_dir, mouse);\n    \n    vec2 result = rayCast(camera, dir);\n    float t = result.x;\n   \tvec3 pos = camera + t * dir;\n    vec3 N = normal(pos);\n    vec3 R = reflect(dir, N);\n    \n    float sun_dif = clamp(.2+.8* dot(N, sun_dir), 0., 1. );\n    float sun_sha = step(rayCast(pos + N * SHAD_EPS, sun_dir).x, 0.);\n    float sky_dif = clamp(.5 + .5 * dot(N, sky_dir), 0., 1.);\n    vec3 bg = vec3(.4, .1, .2) + 0.7 * exp(0.5 - length(uv)) ;\n\n    vec3 col = vec3(.1, .3, .4) * sun_dif * sun_sha;\n    col += vec3(.6, .2, .2) * sky_dif;\n    col -= vec3(.3, .1, .1) * smoothstep(.0, .3, result.y);\n    col -= .1 * smoothstep(0.0, .4, rayCast(pos + R * 0.01, R)).x;\n    col.r = smoothstep(0.0, .8, col.r);\n    col = mix(bg, col, step(0., t));\n    \n    fragColor = vec4(sqrt(col), 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define M_PI   3.1415926\n#define M_2_PI 6.2831853\n#define M_PI_2 1.5707963\n\n/* quaternions */\n\nvec4 qmult(vec4 p, vec4 q) {\n    vec3 pv = p.xyz, qv = q.xyz;\n    return vec4(p.w * qv + q.w * pv + cross(pv, qv), p.w * q.w - dot(pv, qv));\n}\n\nvec4 qrotor(vec3 axis, float phi) {\n    return vec4(sin(phi*0.5) * axis, cos(phi*0.5));\n}\n\nvec4 qmouse(vec4 iMouse, vec3 iResolution, float iTime, float initRotation) {\n    vec2 init = vec2(0.5 + 0.25*initRotation * sin(iTime), 0.5 + initRotation * cos(iTime));\n    vec2 mouse = mix(init, iMouse.xy / iResolution.xy, step(0.0027, iMouse.y));\n    vec4 rotY = qrotor(vec3(0., 1., 0.), M_PI - M_2_PI * mouse.x);\n    vec4 rotX = qrotor(vec3(1., 0., 0.), M_PI * mouse.y - M_PI_2);\n    return qmult(rotY, rotX);\n}\n\nvec3 rotate(vec3 point, vec4 qrotor) {\n    vec3 rv = qrotor.xyz;\n    return qmult(qrotor, vec4(point * qrotor.w - cross(point, rv), dot(point, rv))).xyz;\n}\n\n#define PHI 1.6180339\n#define INV_PHI 0.61803398\n\n/* SDF functions */\n\nfloat opUnion(float d1, float d2, float k) {\n    float h = clamp(0.5 + 0.5*(d2-d1)/k, 0.0, 1.0);\n    return mix(d2, d1, h ) - k*h*(1.0-h);\n}\n\nfloat opSubstr(float d2, float d1, float k) {\n    float h = clamp(0.5 - 0.5*(d2+d1)/k, 0.0, 1.0);\n    return mix(d2, -d1, h ) + k*h*(1.0-h);\n}","name":"Common","description":"","type":"common"}]}