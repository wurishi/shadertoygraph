{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[{"channel":0,"type":"texture","id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"code":"float camSpeed = 0.25;\n\nvec2 water_area_min = vec2(-0.5, -0.5) * 2.0;\nvec2 water_area_max = vec2(0.5, 0.5) * 2.0;\nvec2 terrain_area_min = vec2(-0.5, -0.5) * 12.0;\nvec2 terrain_area_max = vec2(0.5, 0.5) * 12.0;\n\nfloat dirLightAngle;\nvec3 dirLightDir;\nvec3 dirLightColor = vec3(1.0, 1.0, 1.0);\nfloat dirLightIntensity = 0.9;\n\nvec3 ambientColor = vec3(1.0, 1.0, 1.0);\nfloat ambientIntensity = 0.1;\n\nvec2 terrain_tile_size = vec2(1.0, 1.0) * 1.0;\nvec2 terrain_tile_size_inv;\n\nconst int OBJECT_NONE = 0;\nconst int OBJECT_WATER = 1;\nconst int OBJECT_TERRAIN = 2;\n\nbool overWater(vec3 pos)\n{\n    vec2 p1 = water_area_min;\n    vec2 p2 = water_area_max;\n\tif (pos.x < p1.x || pos.z < p1.y) return false;\n    if (pos.x > p2.x || pos.z > p2.y) return false;\n    return true;\n}\n\n// Note: water is in middle of terrain\nbool overTerrain(vec3 pos)\n{\n\tvec2 p1 = terrain_area_min;\n    vec2 p2 = terrain_area_max;\n    if (pos.x < p1.x || pos.z < p1.y) return false;\n    if (pos.x > p2.x || pos.z > p2.y) return false;\n    return true;\n}\n\nfloat waterDist(vec3 pos)\n{\n    float d;\n\tfloat f = 0.0; // water height\n    \n    f += -0.1 + 0.2 * sin(2.0 * iTime + pos.x);\n    f += -0.1 + 0.2 * sin(0.6 * iTime + pos.x + 0.5);\n    f += -0.1 + 0.2 * sin(0.4 * iTime + pos.z);\n    f += 0.0;\n    \n    d = pos.y - f;\n    \n    return d;\n}\n\nbool terrain_inited = false;\nfloat terrain_v11;\nfloat terrain_v12;\nfloat terrain_v21;\nfloat terrain_v22;\nvec2 last_tile;\n\n// Cannot remember where I borrowed this function\nvec2 smootherstep(vec2 v1, vec2 v2, vec2 t)\n{\n    vec2 v;\n    v.x = clamp((t.x - v1.x) / (v2.x - v1.x), 0.0, 1.0);\n    v.y = clamp((t.y - v1.y) / (v2.y - v1.y), 0.0, 1.0);\n    v.x = v.x * v.x * v.x * (v.x * (v.x * 6.0 - 15.0) + 10.0);\n    v.y = v.y * v.y * v.y * (v.y * (v.y * 6.0 - 15.0) + 10.0);\n    return v;\n}\n\nfloat terrainDist(vec3 pos)\n{\n \tfloat d;\n    float f; // terrain height\n    \n    vec2 place = pos.xz * terrain_tile_size_inv.xy;\n    vec2 frac = fract(place);\n    vec2 tile = floor(place);\n    frac = smootherstep(vec2(0.), vec2(1.), frac);\n    vec2 t = vec2(0.0, 1.0);\n    if (!terrain_inited || tile != last_tile)\n    {\n        float a = 1. / 256.;\n        terrain_v11 = 2.0 * texture(iChannel0, (tile + t.xx) * a).x;\n        terrain_v12 = 2.0 * texture(iChannel0, (tile + t.yx) * a).x;\n        terrain_v21 = 2.0 * texture(iChannel0, (tile + t.xy) * a).x;\n        terrain_v22 = 2.0 * texture(iChannel0, (tile + t.yy) * a).x;\n        last_tile = tile;\n        terrain_inited = true;\n    }\n    f = terrain_v11 * (1.0 - frac.x) * (1.0 - frac.y) +\n        terrain_v12 * frac.x * (1.0 - frac.y) +\n        terrain_v21 * (1.0 - frac.x) * frac.y +\n        terrain_v22 * frac.x * frac.y;\n    f -= 1.0;\n    d = pos.y - f;\n    \n    return d;\n}\n\n// Returns distance to nearest object and object type\nfloat map(vec3 pos, out int object_type)\n{\n    if (overWater(pos))\n    {\n        // Handle water\n        object_type = OBJECT_WATER;\n        return waterDist(pos);\n    }\n    else if (overTerrain(pos))\n    {\n        // Handle terrain\n        object_type = OBJECT_TERRAIN;\n        return terrainDist(pos);\n    }\n    else\n    {\n     \t// No hit\n        object_type = OBJECT_NONE;\n        return 0.0;\n    }\n    \n}\n\nfloat map(vec3 pos)\n{\n\tint object_type;\n    return map(pos, object_type);\n}\n\nvec3 getNormal(vec3 pos)\n{\n    float threshold = 0.001;\n\tvec2 t = vec2(0.0, threshold);\n    //vec3 n = vec3(map(pos + t.yxx) - map(pos - t.yxx),\n    //       \t  map(pos + t.xyx) - map(pos - t.xyx),\n    //          map(pos + t.xxy) - map(pos - t.xxy));\n    vec3 n = vec3(map(pos - t.yxx) - map(pos + t.yxx), \n                  2.0 * t.y,\n                  map(pos - t.xxy) - map(pos + t.xxy));\n    //n = vec3(0.0, 1.0, 0.0);\n    n = normalize(n);\n    return n;\n}\n\nvec3 shadeBackground(vec3 rayPos, vec3 rayDir)\n{\n    vec3 c = vec3(0.0);\n    return c;\n}\n\nfloat perlin(vec2 pos, int octaves, float gain, float freq, float amplitude)\n{\n    float p = 0.0;\n    const int max_octaves = 20;\n    for (int i = 0; i < max_octaves; ++i)\n    {\n        if (i >= octaves)\n            break;\n        p += texture(iChannel0, vec2(pos.x * freq, pos.y * freq)).r * amplitude;\n        amplitude *= gain;\n        freq *= 1.0 / gain;\n    }\n    return p;   \n}\n\nvec3 shadeWater(vec3 pos)\n{\n    vec3 c = vec3(0.0);\n    vec3 d = vec3(0.0, 0.0, 1.0);\n    vec3 n = getNormal(pos);\n    vec3 l = -dirLightDir;\n    \n    c += d * ambientColor * ambientIntensity;\n    c += d * max(dot(n, l), 0.0) * dirLightColor * dirLightIntensity;\n    \n    return c;\n}\n\nfloat terrainMixPerlin(vec3 pos)\n{\n\tconst float gain = 0.5;\n    const int octaves = 3;\n    float freq = 0.005;\n    float amplitude = gain; \n    float p = perlin(pos.xz, octaves, gain, freq, amplitude);\n    return p;\n}\n\nvec3 shadeTerrain(vec3 pos)\n{\n    float m = terrainMixPerlin(pos);\n    m = smoothstep(0.0, 1.0, m + 1.0 / (1.0 + exp(-6.0 + 2.6 * length(pos.xyz))));\n    \n    vec3 c = vec3(0.0);\n    vec3 d = mix(vec3(0.0, 1.0, 0.0), vec3(194., 178., 128.) / 256., m);\n    vec3 n = getNormal(pos);\n    vec3 l = -dirLightDir;\n    \n    c += d * ambientColor * ambientIntensity;\n    c += d * max(dot(n, l), 0.0) * dirLightColor * dirLightIntensity;\n    \n    return c;\n}\n\nvec3 getColor(vec3 rayPos, vec3 rayDir)\n{\n    vec3 c = vec3(0.0);\n    vec3 bg = vec3(0.0, 0.0, 0.0);\n    \n    /* Ray marching */\n    const int max_iter = 1024;\n    const float eps = 0.001;\n    float d;\n    float d_total = 0.0;\n    float delta = 0.03;\t// constant, because water/terrain marching\n    vec3 pos = rayPos;\n    int object_type_temp;\n    int object_type_hit = OBJECT_NONE;\n    for (int i = 0; i < max_iter; ++i)\n    {\n        d = map(pos, object_type_temp);\n        d_total += delta;\n        pos += delta * rayDir;\n        if (d < eps)\n        {\n            object_type_hit = object_type_temp;\n            break;\n        }\n    }\n    \n    /* Shading */\n    if (object_type_hit == OBJECT_NONE)\n    {\n        c = shadeBackground(rayPos, rayDir);\n    }\n    else if (object_type_hit == OBJECT_WATER)\n    {\n        c = shadeWater(pos);\n    }\n    else if (object_type_hit == OBJECT_TERRAIN)\n    {\n        c = shadeTerrain(pos);\n    }\n    \n    return c;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n\tterrain_tile_size_inv = 1.0 / terrain_tile_size;\n    \n    /* Initialize directional light */\n\tdirLightAngle = iTime * 1.0;\n\tdirLightDir = normalize(vec3(0.3 * cos(iTime), -1.0, 0.0));\n    \n    /* Aspect ratio */\n    float aspect = iResolution.x / iResolution.y;\n    uv -= .5;\n    uv.x = aspect * uv.x;\n    \n    /* Camera setup */\n    //vec3 camPos = vec3(1.0, 1.0, -1.0) * 5.0;\n    vec3 camPos = vec3(cos(iTime *camSpeed), 0.5, sin(iTime * camSpeed)) * 5.0;\n    vec3 camTarget = vec3(0.0, 0.0, 0.0);\n    vec3 camUp = vec3(0., 1., 0.);\n    vec3 camDir = normalize(camTarget - camPos);\n    vec3 camRight = normalize(cross(camUp, camDir)); // ?\n    camUp = normalize(cross(camDir, camRight));\n    \n    /* Ray setup */\n    vec3 rayPos = camPos;\n    vec3 rayDir = normalize(camDir + uv.x * camRight + uv.y * camUp);\n    \n    /* Calculate color */\n    vec3 c;\n    c = getColor(rayPos, rayDir);\n    \n\tfragColor = vec4(c, 1.0);\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"ldBXDV","date":"1419793221","viewed":216,"name":"Water and terrain","username":"janneasdf","description":"Water and terrain","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["3d","terrain"],"hasliked":0,"parentid":"","parentname":""}}