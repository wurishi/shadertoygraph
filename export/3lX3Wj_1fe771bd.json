{"ver":"0.1","info":{"id":"3lX3Wj","date":"1557737043","viewed":142,"name":"Columns and planes intersection","username":"madware","description":"test","likes":4,"published":1,"flags":32,"usePreview":0,"tags":["raycaster"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sfGRn","filepath":"/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","previewfilepath":"/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdXGzr","filepath":"/media/a/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg","previewfilepath":"/media/ap/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define h(n) fract(sin(n)*753.5453)\n\nconst float high_plane_h = 0.45;\nconst float  low_plane_h = 0.55;\nconst float   cam_offset = 1.2;\n\nconst vec3 high_plane_p = vec3(0.0, high_plane_h, 0.0);\nconst vec3  low_plane_p = vec3(0.0, -low_plane_h, 0.0);\n\nconst vec3 high_plane_n = vec3(0.0, -1.0, 0.0);\nconst vec3  low_plane_n = vec3(0.0,  1.0, 0.0);\nconst vec3 fog_col = vec3(0.3, 0.28, 0.38);\n\nconst vec3 up = vec3(0.0, 1.0, 0.0);\n\nfloat noise( in vec2 x )\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n    f = f*f*(3. - 2. * f);\n\t\n    float n = p.x + p.y*157. + 113.;\n    return mix(mix( h(n+ 0.), h(n+ 1.),f.x),\n               mix( h(n+63.), h(n+64.),f.x),f.y);\n}\n\nfloat getRayPlaneIntersection(in vec3 rayOrigin, \n                              in vec3 rayDir, \n                              in vec3 planeP, \n                              in vec3 planeN)\n{\n    float cc = dot(planeN, rayDir);   \n    vec3 rp = rayOrigin - planeP;\n    return mix(-dot(planeN, rp) / cc, -1.0, step(abs(cc), 0.0));\n}\n\nfloat getRaySegmentIntersection(in vec3 rayOrigin, \n                                in vec3 rayDir,\n                                in vec3 segP, \n                                in vec3 segN,\n                                in vec3 up,\n                                in vec2 segSize)\n{\n    float cc = dot(segN, rayDir);   \n    vec3 rayp = rayOrigin - segP;\n    float t = -dot(segN, rayp) / cc; \n    vec3 p = rayOrigin + rayDir * t;\n    vec3 dp = p - segP;\n    vec3 left = cross(segN, up);\n    \n    bool inside = abs(dot(left, p - segP)) < segSize.x / 2.0 ;\n    inside = inside && abs(dot(up, p - segP)) < segSize.y / 2.0;\n    return mix(-1.0, t, float(inside));\n}\n\nvec4 getRayCubeIntersection(in vec3 rayOrigin, \n                            in vec3 rayDir, \n                            in vec3 cubeP,\n                            in vec2 cubeSize)\n{\n    float tl = getRaySegmentIntersection(\n        rayOrigin, rayDir, \n        cubeP + vec3(-cubeSize.x / 2.0, 0.0, 0.0),\n        vec3(-1.0, 0.0, 0.0),\n        up,\n        cubeSize);\n    float tr = getRaySegmentIntersection(\n        rayOrigin, rayDir, \n        cubeP + vec3(cubeSize.x / 2.0, 0.0, 0.0),\n        vec3(1.0, 0.0, 0.0),\n        up,\n        cubeSize);\n    float tf = getRaySegmentIntersection(\n        rayOrigin, rayDir, \n        cubeP + vec3(0.0, 0.0, -cubeSize.x / 2.0),\n        vec3(0.0, 0.0, -1.0),\n        up,\n        cubeSize);\n    float tb = getRaySegmentIntersection(\n        rayOrigin, rayDir, \n        cubeP + vec3(0.0, 0.0, cubeSize.x / 2.0),\n        vec3(0.0, 0.0, 1.0),\n        up,\n        cubeSize);\n    \n    vec4 res = vec4(-1.0, 0.0, 0.0, tl);\n    res = mix(res, vec4(1.0, 0.0, 0.0, tr), float(tr > 0.0 && (res.w < 0.0 || res.w > tr)));\n    res = mix(res, vec4(0.0, 0.0, -1.0, tf), float(tf > 0.0 && (res.w < 0.0 || res.w > tf)));\n    res = mix(res, vec4(0.0, 0.0, 1.0, tb), float(tb > 0.0 && (res.w < 0.0 || res.w > tb)));\n    \n    return res;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv  = (fragCoord/iResolution.xy - vec2(0.5, 0.5)) * 2.0;\n    uv.y *= iResolution.y / iResolution.x;\n    vec3 ray_origin = vec3(0.0, 0.0, -cam_offset);\n    vec3 ray = normalize(vec3(uv.x, uv.y, cam_offset));\n    ray_origin.z += iTime * 2.0;\n    \n    float high_t = getRayPlaneIntersection(ray_origin, ray, high_plane_p, high_plane_n);\n    vec3  high_p = ray_origin + ray * high_t;\n    float high_intersect = float(high_t > 0.0);\n    vec3 plane_h_color = mix(\n        fog_col, \n        texture(iChannel0, high_p.xz).rgb, \n        1.0 / max(high_t, 1.0));\n    \n    float low_t = getRayPlaneIntersection(ray_origin, ray, low_plane_p, low_plane_n);\n    vec3  low_p = ray_origin + ray * low_t;\n    float low_intersect = float(low_t > 0.0);\n    vec3 plane_l_color = mix(\n        fog_col, \n        texture(iChannel1, low_p.xz).rgb, \n        1.0 / max(low_t, 1.0));\n    \n    vec4 cube_test = vec4(0.0, 0.0, 0.0, -1.0);\n    vec2 cube_size = vec2((high_plane_h + low_plane_h) / 3.0, high_plane_h + low_plane_h);\n    for(float i = -2.0; i < 2.5; i += 1.2)\n    {\n        for(float j = -10.0; j < 0.5; j += 2.0)\n        {\n            vec3 cubePos = vec3(i * 3.0, \n                                0.5 - low_plane_h, \n                                j * 5.0 + 40.0 +\n                                40.0 * floor(iTime / 20.0)\n                                );\n            cubePos += vec3(noise(cubePos.xz * 15.0), 0.0, noise(cubePos.zx * 15.0) * 10.0);\n            cubePos.x += 1.5;\n            vec4 test = getRayCubeIntersection(\n                ray_origin, \n                ray, \n                cubePos, \n                cube_size);\n            cube_test = mix(\n                cube_test, \n                test, \n                float(test.w > 0.0 && (cube_test.w < 0.0 || cube_test.w > test.w)));\n            \n            test = getRayCubeIntersection(\n                ray_origin, \n                ray, \n                cubePos + up * 0.45, \n                cube_size * vec2(1.2, 0.1));\n            cube_test = mix(\n                cube_test, \n                test, \n                float(test.w > 0.0 && (cube_test.w < 0.0 || cube_test.w > test.w)));\n            \n            test = vec4(-up, getRaySegmentIntersection(\n                ray_origin, \n                ray,\n                cubePos + up * 0.4,\n                -up,\n                vec3(0.0, 0.0, 1.0),\n                vec2(cube_size.x * 1.2, cube_size.x * 1.2)));\n            cube_test = mix(\n                cube_test, \n                test, \n                float(test.w > 0.0 && (cube_test.w < 0.0 || cube_test.w > test.w)));\n            \n            test = getRayCubeIntersection(\n                ray_origin, \n                ray, \n                cubePos - up * 0.45, \n                cube_size * vec2(1.2, 0.1));\n            cube_test = mix(\n                cube_test, \n                test, \n                float(test.w > 0.0 && (cube_test.w < 0.0 || cube_test.w > test.w)));\n                        \n            test = vec4(up, getRaySegmentIntersection(\n                ray_origin, \n                ray,\n                cubePos - up * 0.4,\n                up,\n                vec3(0.0, 0.0, 1.0),\n                vec2(cube_size.x * 1.2, cube_size.x * 1.2)));\n            cube_test = mix(\n                cube_test, \n                test, \n                float(test.w > 0.0 && (cube_test.w < 0.0 || cube_test.w > test.w)));\n        }\n    }\n    \n    float cube_intersect = float(cube_test.w > 0.0);    \n    \n    vec3 cubeP = ray_origin + ray * cube_test.w;\n    vec3 side_color = texture(iChannel2, cubeP.zy).rgb * 0.5;\n    vec3 front_color = texture(iChannel2, cubeP.xy).rgb * 0.9;\n    vec3 top_color = texture(iChannel2, cubeP.xz).rgb;\n    \n    vec3 cube_color = mix(\n        fog_col, \n        front_color * abs(cube_test.z) + \n        side_color * abs(cube_test.x) +\n        top_color * abs(cube_test.y), \n        1.0 / max(cube_test.w, 1.0));      \n    \n    vec3 col = fog_col;\n    col = mix(col, plane_h_color, high_intersect);\n    col = mix(col, plane_l_color, low_intersect);\n    col = mix(col, cube_color, cube_intersect);\n\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0,0.0,1.0,1.0);\n}","name":"Buffer A","description":"","type":"buffer"}]}