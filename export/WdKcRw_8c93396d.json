{"ver":"0.1","info":{"id":"WdKcRw","date":"1602479601","viewed":61,"name":"ze paw","username":"delftblue","description":"The glorious paw commands your attention","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["clearyourmind"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//some dumb shit made by the glorious delft blue\n//don't steal it although shaders are literally just some math\n//and you can't really copyright a sine function\n\n//i'm not responsible if you have epilepsy\n\nbool ellipse( in vec2 ctr1, in vec2 ctr2, in vec2 uv, in float rad)\n\n{\n    return ( distance(ctr1, uv) +  distance(ctr2, uv) ) < rad;\n}\n\nfloat harmonic_mean(in float a, in float b){\n\n\treturn 1.0/(.5*(1.0/a + 1.0/b));\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    //polar coordinates\n    vec2 pc=vec2(\n        atan( uv.y - .5, uv.x - .5),\n        distance(vec2(.5, .5), uv)\n    );\n\n    vec3 col;\n    \n    if(pc.y == mod(iTime, 100.0)){\n    \n    }\n    \n    if (floor(pc.y * 100.0* abs(sin(iTime))) == floor(100.0*distance(vec2(.5, .5), uv)) ){\n        col.r += .29;\n        col.g += .15;\n        col.b += .15;\n        col.b += 2.0*dot(col, col);\n\n    }\n    \n    //if (dot(col, pc.yyy) < .25 ){\n    if (dot(col, pc.yyy) < mod(iTime*.25, .75) ){\n\n        col.r += .10;\n    }\n    \n    vec3 pink = vec3(.99, .66, .77);\n    \n    vec2 ctr1 = vec2(5.5/12.0, .4);\n    vec2 ctr2 = vec2(6.5/12.0, .4);\n    float rad = .18;\n\n    \n    if (ellipse(ctr1, ctr2, uv, rad)){\n    \tcol = pink;\n    }\n    \n    rad = .13;\n    \n\n    \n    if (ellipse(vec2(5.0/12.0, .5), vec2(5.0/12.0, .6), uv, rad)){\n    \tcol = pink;\n        \n    }\n    \n    if (ellipse(vec2(.5, .55), vec2( .5, .65), uv, rad)){\n    \tcol = pink;\n    }\n    \n    if (ellipse(vec2(7.0/12.0, .5), vec2(7.0/12.0, .6), uv, rad)){\n    \tcol = pink;\n    }\n    \n    if (floor(pc.x)  == floor (pc.y * 8.0)){\n\n        col.r += .3;\n    }\n    \n    if (floor(mod(((pc.x + 3.14)/pc.y* sin(iTime)), 3.14)) == 1.0){\n\n        col.b += .4;\n    }\n    \n    if (floor(mod(((pc.x + 3.14)/(pc.y - .7 * sin(iTime))), 3.14)) == 1.0){\n\n        col.r += .4;\n    }\n    \n    //realy cool half spade\n    if (harmonic_mean(-uv.x, uv.y) > harmonic_mean(pc.x, pc.y)){ \n    \tcol.r += .25;\n        col.b += .25;\n    }\n    \n    if (harmonic_mean(-uv.x, -uv.y) > harmonic_mean(pc.x, -pc.y)){ \n    \t//col.r += .25;\n        col.b += .36;\n    }\n    \n    if (harmonic_mean(-uv.x, uv.y) > harmonic_mean(sin(iTime)*pc.x, pc.y)){ \n    \tcol.r += .25;\n        col.b += .25;\n    }\n    \n    //if (harmonic_mean(-pc.x, uv.x) > harmonic_mean(pc.y, uv.y)){ \n    //\tcol.r += .25;\n    //    col.b += .25;\n    //    col.g += 1.0;\n    //}\n    //if (pc.x  < mix((2.0*3.14)*sin(iTime) - 3.1, (2.0*3.14)*sin(iTime) - 3.2, 1.0)){\n    //\tcol.r = 1.0;\n    //}\n    \n    //a little extra flashy shit\n    //if (floor(pc.y * 5.0* abs(tan(iTime))) == floor(100.0*distance(vec2(.5, .5), uv)) ){\n    //    col.r += .6;\n    ///    col.g += .21;\n    //    col.b += .25;\n    //}\n    \n    //if (floor(col.x * 10.0* (tan(iTime))) == floor(100.0*distance(vec2(.75, .25), uv)) ){\n    //    col.r += 1.00;\n    //    col.g -= .25;\n    //    col.b -= .25;\n    //}\n    \n    \n    \n    //if (dot(pc, col.rb) < .01 ){\n        //col.r += dot(pc, col.rb);\n        //col.g += dot(pc, col.gb);\n    //}\n\n\n\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}