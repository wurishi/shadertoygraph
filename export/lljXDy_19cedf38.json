{"ver":"0.1","info":{"id":"lljXDy","date":"1446326227","viewed":459,"name":"SEM Test 2","username":"cabbibo","description":"Disforming the normal of a spherical enviornment map","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["sphericalenviornmentmap","matcap","sem"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[],"code":"/* c = center of sphere\nr = radius\n\nd = -(rd *dot* (ro - c)) + / - sqrt( ((rd *dot* (ro - c))^ 2) - length(ro-c) ^ 2 + r^2 )\n    \n*/\n   \n    \nfloat intersectSphere( vec3 rd , vec3 ro , vec3 c , float r ){\n    \n    vec3 rayDif =  ro - c;\n\n    float matchVec = dot( rd ,rayDif );\n\n\n    float underRoot =(matchVec * matchVec) - length( rayDif ) * length( rayDif ) + r * r;\n\n    if( underRoot  < 0. ){\n\n        return -1.;\n\n    }else if( underRoot == 0. ){\n        \n        return -matchVec;\n        \n    }else{\n        \n        return -matchVec + underRoot;\n\n    }\n    \n}\n\n    \nfloat map( vec3 rd ){\n    \n        \n    vec3 c = vec3( 0., 0., 1. );\n    float r = .447;\n    \n    vec3 ro = vec3( 0. );\n    \n    return intersectSphere( rd , ro , c , r );\n    \n}\n\n// Calculates the normal by taking a very small distance,\n// remapping the function, and getting normal for that\nvec3 calcNormal( vec2 uv ){\n    \n\tvec2 eps = vec2( 0.001, 0.0 );\n\n    vec3 rd = vec3( uv , 1. );\n    rd = normalize( rd );\n    \n    vec3 rdUX = normalize( vec3( uv + eps.xy , 1. ));\n    vec3 rdUY = normalize( vec3( uv + eps.yx , 1. ));\n    vec3 rdDX = normalize( vec3( uv - eps.xy , 1. ));\n    vec3 rdDY = normalize( vec3( uv - eps.yx , 1. ));\n    \n    \n    vec3 pUX = rdUX * map( rdUX );\n    vec3 pDX = rdDX * map( rdDX );\n    vec3 pUY = rdUY * map( rdUY );\n    vec3 pDY = rdDY * map( rdDY );\n    \n    vec3 v1 = pUX - pDX;\n    vec3 v2 = pUY - pDY;\n    \n    vec3 norm = normalize( cross( v1 , v2 ) );\n\n   \treturn norm;\n    \n}\n\nfloat hash( float n ) { return fract(sin(n)*753.5453123); }\n\nvec3 doCol( vec3 eye , vec3 norm ){\n\n    //norm += vec3( hash( norm.x ) , hash( norm.y ) , hash( norm.z ) ) * .3;\n    //norm = normalize( norm );\n    vec3 refl = reflect( eye , norm );\n    \n    float spec1 = max( 0. , dot( refl , vec3( 0., 1. , 0. ) ));\n    float v1 = pow( spec1 , 10. );\n    \n    float spec2 = max( 0. , dot( refl ,  normalize(vec3( 1., -1. , -1. ) ) ));\n    float v2 = pow( spec2 , 2. );\n    \n    float spec3 = max( 0. , dot( refl , normalize(vec3( 0., 1. , 1. ) )));\n    float v3 = pow( spec3 , 3. );\n    \n    vec3 c = vec3( v1 , v2 , v3 );// texture( iChannel0 , normalize( refl ) ).xyz;\n    \n    return c;\n    \n}\n    \n \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.y;\n    \n    uv -= vec2( .5 );\n    uv.y *= -1.;\n    \n    vec3 rd = vec3( uv , 1. );\n    rd = normalize( rd );\n    vec3 ro = vec3( 0. );\n    \n    float intersectVal = intersectSphere( rd , ro , vec3( 0., 0., 1. ) , .447 );\n\n    vec3 n = calcNormal( uv );\n   \n    \n    vec3 col = doCol( rd , n );\n\n    \n    if( uv.x > .5 ){\n     col = vec3( 0. );   \n    }\n    \n\tfragColor = vec4( col ,1.0);\n}","name":"","description":"","type":"image"}]}