{"ver":"0.1","info":{"id":"fdc3R4","date":"1629200963","viewed":293,"name":"old film Scratch","username":"zyc","description":"old film Scratch","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["film"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4df3zn","filepath":"/media/a/3405e48f74815c7baa49133bdc835142948381fbe003ad2f12f5087715731153.ogv","previewfilepath":"/media/ap/3405e48f74815c7baa49133bdc835142948381fbe003ad2f12f5087715731153.ogv","type":"video","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"precision lowp float;\nconst float ScratchValue = 0.31;\n\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\nfloat snoise (vec2 v)\n{\n\tconst vec4 C = vec4(0.211324865405187,\t// (3.0-sqrt(3.0))/6.0\n\t\t\t\t0.366025403784439,\t// 0.5*(sqrt(3.0)-1.0)\n\t\t\t\t-0.577350269189626,\t// -1.0 + 2.0 * C.x\n\t\t\t\t0.024390243902439);\t// 1.0 / 41.0\n\n\t// First corner\n\tvec2 i  = floor(v + dot(v, C.yy) );\n\tvec2 x0 = v -   i + dot(i, C.xx);\n\n\t// Other corners\n\tvec2 i1;\n\ti1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n\tvec4 x12 = x0.xyxy + C.xxzz;\n\tx12.xy -= i1;\n\n\t// Permutations\n\ti = mod289(i); // Avoid truncation effects in permutation\n\tvec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n\t\t+ i.x + vec3(0.0, i1.x, 1.0 ));\n\n\tvec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\n\tm = m*m ;\n\tm = m*m ;\n\n\t// Gradients: 41 points uniformly over a line, mapped onto a diamond.\n\t// The ring size 17*17 = 289 is close to a multiple of 41 (41*7 = 287)\n\n\tvec3 x = 2.0 * fract(p * C.www) - 1.0;\n\tvec3 h = abs(x) - 0.5;\n\tvec3 ox = floor(x + 0.5);\n\tvec3 a0 = x - ox;\n\n\t// Normalise gradients implicitly by scaling m\n\t// Approximation of: m *= inversesqrt( a0*a0 + h*h );\n\tm *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n\n\t// Compute final noise value at P\n\tvec3 g;\n\tg.x  = a0.x  * x0.x  + h.x  * x0.y;\n\tg.yz = a0.yz * x12.xz + h.yz * x12.yw;\n\treturn 130.0 * dot(m, g);\n}\n\n//note: [0;1]\nfloat rand( vec2 n ) {\n    return fract(sin(dot(n.xy, vec2(12.9898, 78.233)))* 43758.5453);\n}\n\n//note: [-1;1]\nfloat srand( vec2 n ) {\n    return rand(n) * 2.0 - 1.0;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 finalColour = texture(iChannel0, uv).xyz;\n    float RandomValue = rand(uv);\n    float TimeLapse = floor(iTime*1000./50.);\n    \n    if ( RandomValue < ScratchValue )\n\t{\n\t\t// Pick a random spot to show scratches\n\t\tfloat dist = 1.0 / ScratchValue;\n\t\tfloat d = distance(uv, vec2(RandomValue * dist, RandomValue * dist));\n\t\tif ( d < 0.4)\n\t\t{\n\t\t\t// Generate the scratch\n\t\t\tfloat xPeriod = 8.0;\n\t\t\tfloat yPeriod = 1.;\n\t\t\tfloat pi = 3.141592;\n\t\t\tfloat phase = TimeLapse;\n\t\t\tfloat turbulence = snoise(uv * 2.5);\n\t\t\tfloat vScratch = 0.5 + (sin(((uv.x * xPeriod + uv.y * yPeriod + turbulence)) * pi + phase) * 0.5);\n\t\t\tvScratch = clamp((vScratch * 10000.0) + 0.5, 0.0, 1.0);\n\n\t\t\tfinalColour.xyz /= vScratch;\n\t\t}\n\t}\n    \n    fragColor = vec4(finalColour, 1.0);\n    \n}","name":"Image","description":"","type":"image"}]}