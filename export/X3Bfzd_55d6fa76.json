{"ver":"0.1","info":{"id":"X3Bfzd","date":"1729806447","viewed":38,"name":"3D Zernike Aberation ","username":"Paganosama","description":"Disk in Space ","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["zernike"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Constants\nconst int MAX_ZERNIKE_TERMS = 10;\nconst float PI = 3.14159265359;\nconst float DISK_RADIUS = 1.0;\nconst float HEIGHT_SCALE = 0.5;  // Controls the vertical exaggeration of Zernike effects\n\n// Function to evaluate Zernike polynomials for height mapping\nfloat evaluateZernike(float r, float theta, float zernike_coeffs[MAX_ZERNIKE_TERMS]) {\n    float zernike = 0.0;\n\n       // Apply the first 10 Zernike polynomials\n    zernike += zernike_coeffs[0] * 1.0;                             // Z0: Piston\n    zernike += zernike_coeffs[1] * 2.0 * r * cos(theta);            // Z1: Tilt X\n    zernike += zernike_coeffs[2] * 2.0 * r * sin(theta);            // Z2: Tilt Y\n    zernike += zernike_coeffs[3] * (2.0 * r * r - 1.0);             // Z3: Defocus\n    zernike += zernike_coeffs[4] * r * r * cos(2.0 * theta);        // Z4: Astigmatism X\n    zernike += zernike_coeffs[5] * r * r * sin(2.0 * theta);        // Z5: Astigmatism Y\n    zernike += zernike_coeffs[6] * (3.0 * r * r * r - 2.0 * r) * cos(theta);  // Z6: Coma X\n    zernike += zernike_coeffs[7] * (3.0 * r * r * r - 2.0 * r) * sin(theta);  // Z7: Coma Y\n    zernike += zernike_coeffs[8] * r * r * r * cos(3.0 * theta);    // Z8: Trefoil X\n    zernike += zernike_coeffs[9] * r * r * r * sin(3.0 * theta);    // Z9: Trefoil Y\n\n    return zernike * HEIGHT_SCALE;  // Scale the height deformation\n}\n\n// Function to raymarch the deformed disk\nfloat raymarchDisk(vec3 ro, vec3 rd, float zernike_coeffs[MAX_ZERNIKE_TERMS]) {\n    float t = 0.0;\n    for (int i = 0; i < 2000; i++) {  // Increased precision by increasing iterations\n        vec3 pos = ro + t * rd;\n\n        // Check if we're within the disk's radius\n        float r = length(vec2(pos.x, pos.z));  // Disk's radius in XZ-plane\n        if (r > DISK_RADIUS) {\n            t += 0.002;  // Outside the disk, keep marching\n            continue;\n        }\n\n        // Convert position to polar coordinates for Zernike evaluation\n        float theta = atan(pos.z, pos.x);  // Angular position\n        float height = evaluateZernike(r, theta, zernike_coeffs);  // Zernike-based height\n\n        // Check if the ray hits the surface (Y-position close to the height)\n        if (abs(pos.y - height) < 0.01) {\n            return t;  // Hit the surface\n        }\n\n        t += 0.005;  // Finer step size for more precision\n    }\n\n    return -1.0;  // No hit\n}\n\n// Function to set up Zernike coefficients controlled by mouse\nvoid setZernikeCoeffs(inout float zernike_coeffs[MAX_ZERNIKE_TERMS], vec2 mousePos) {\n    // Use the vertical mouse position to select which coefficient to modify\n    int selectedCoefficient = int(floor(mousePos.y * float(MAX_ZERNIKE_TERMS)));\n\n    // Limit the selected coefficient to the range [0, MAX_ZERNIKE_TERMS-1]\n    selectedCoefficient = clamp(selectedCoefficient, 0, MAX_ZERNIKE_TERMS - 1);\n\n    // Use the horizontal mouse position to control the value of the selected coefficient\n    zernike_coeffs[selectedCoefficient] = (mousePos.x - 0.5) * 2.0;\n    \n}\n\n// Main shader\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Normalize fragment coordinates to [-1, 1]\n    vec2 uv = fragCoord.xy / iResolution.xy * 2.0 - 1.0;\n\n    // Camera setup (third-person view above and to the side of the disk)\n    vec3 cameraPos = vec3(2.0, 2.0, 2.0);\n    vec3 target = vec3(0.0, 0.0, 0.0);  // Looking at the disk center\n    vec3 forward = normalize(target - cameraPos);\n    vec3 right = normalize(cross(vec3(0.0, 1.0, 0.0), forward));\n    vec3 up = cross(forward, right);\n\n    vec3 rayDir = normalize(forward + uv.x * right + uv.y * up);  // Ray direction\n\n    // Zernike coefficients - Declare and initialize properly\n    float zernike_coeffs[MAX_ZERNIKE_TERMS];\n    for (int i = 0; i < MAX_ZERNIKE_TERMS; i++) {\n        zernike_coeffs[i] = 0.0;  // Initialize all coefficients to 0.0\n    }\n\n    // Use mouse input to control the Zernike coefficients\n    vec2 mousePos = iMouse.xy / iResolution.xy;\n    if (iMouse.xy == vec2(0)) mousePos = vec2(0.1,1.0);\n   \n    \n    setZernikeCoeffs(zernike_coeffs, mousePos);\n\n    // Raymarch to find the intersection with the deformed disk\n    float t = raymarchDisk(cameraPos, rayDir, zernike_coeffs);\n\n    // Shading and color based on hit\n    if (t > 0.0) {\n        vec3 hitPos = cameraPos + t * rayDir;\n        vec3 normal = normalize(vec3(0.0, 1.0, hitPos.y*2.0));  // Disk normal is mostly up (Y-axis)\n        vec3 lightDir = normalize(vec3(1.0, 1.0, 1.0));  // Directional light\n        float diffuse = max(dot(normal, lightDir), 0.0);\n        \n        fragColor = vec4(vec3(diffuse), 1.0);  // Simple diffuse shading\n    } else {\n        fragColor = vec4(0.0);  // Background color\n    }\n}\n","name":"Image","description":"","type":"image"}]}