{"ver":"0.1","info":{"id":"dtXfR4","date":"1692657129","viewed":52,"name":"My_first_raytracer","username":"The_VFX_Wizard","description":"simple raytracing test. I went in blind without many resources, so I'm sure my code is full of inefficiencies.","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["raytracing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Fork of \"Gar_Raytracer_test_06\" by The_VFX_Wizard. https://shadertoy.com/view/mlBcWV\n// 2023-08-21 22:31:36\n\n// Fork of \"Gar_Raytracer_test_05\" by The_VFX_Wizard. https://shadertoy.com/view/mtjcWy\n// 2023-08-17 16:41:53\n\n// Fork of \"Gar_Raytracer_test_04\" by The_VFX_Wizard. https://shadertoy.com/view/mtjcWG\n// 2023-08-17 05:25:02\n\n// Fork of \"Gar_Raytracer_test_03\" by The_VFX_Wizard. https://shadertoy.com/view/dtjcWG\n// 2023-08-17 02:43:13\n\n// Fork of \"Gar_Raytracer_test_02\" by The_VFX_Wizard. https://shadertoy.com/view/Dt2cDy\n// 2023-08-17 02:42:02\n\n// Fork of \"Gar_Raytracer_test\" by The_VFX_Wizard. https://shadertoy.com/view/mtByRd\n// 2023-08-17 01:48:12\n\n#define M_PI 3.1415926535897932384626433832795\n#define SKY 2\n#define PLANE 0\n#define SPHERE 1\n\n\n//how many units can the camera see\nfloat farClip = 1000.;\n//custom time for variable time speeds\nfloat gTime = 0.;\n//random noise seed that changes every frame\nvec2 seed;\n//max lightbounces before a ray stops\nint maxBounces = 4;\n//number of rays to average together. higher values reduce noise\nint samples = 1;\n//number of objects in the objects[] array\nconst int numObjects = 4;\n\n\n//some math functions to help out later\nfloat toRadians(float deg)\n{\n    return deg/180.*M_PI;\n}\nfloat toDegrees(float rad)\n{\n    return rad*180./M_PI;\n}\nfloat rand(vec2 co){\n    return fract(sin(dot(co, vec2(12.9898, 78.233))) * 43758.5453);\n}\nvec3 normalizeVec(vec3 x)\n{\n    return x/length(x);\n}\nvec3 reflectVec(vec3 x, vec3 norm)\n{\n    return x - 2.*norm*dot(x,norm);\n}\n\n\n//aces color transform function from https://github.com/TheRealMJP/BakingLab/blob/master/BakingLab/ACES.hlsl\n// sRGB => XYZ => D65_2_D60 => AP1 => RRT_SAT\nconst mat3 ACESInputMat =\nmat3(\n    0.59719, 0.35458, 0.04823,\n    0.07600, 0.90834, 0.01566,\n    0.02840, 0.13383, 0.83777\n);\n\n// ODT_SAT => XYZ => D60_2_D65 => sRGB\nconst mat3 ACESOutputMat =\nmat3(\n     1.60475, -0.53108, -0.07367,\n    -0.10208,  1.10813, -0.00605,\n    -0.00327, -0.07276,  1.07602\n);\n\nvec3 RRTAndODTFit(vec3 v)\n{\n    vec3 a = v * (v + 0.0245786f) - 0.000090537f;\n    vec3 b = v * (0.983729f * v + 0.4329510f) + 0.238081f;\n    return a / b;\n}\n\nvec3 acesFitted(vec3 color)\n{\n    color = color * ACESInputMat;\n\n    // Apply RRT and ODT\n    color = RRTAndODTFit(color);\n\n    color = color * ACESOutputMat;\n\n    // Clamp to [0, 1]\n    color = clamp(color,0.,1.);\n\n    return color;\n}\n\n\n\n//custom variable type attached to every object and sky\nstruct Material {\n    //rgb value of diffuse color\n    vec3 col;\n    //rgb value of emission color\n    vec3 emit;\n    //scalar value of reflective roughness (0-1)\n    float rough;\n};\n\n\n//defines custom variable type inhereted by every scene object\nstruct Object {\n    //type of object (0 is plane, 1 is sphere)\n    int type;\n    //position of center point\n    vec3 position;\n    //direction of up normal vector (plane only)\n    vec3 normal;\n    //radius (sphere only)\n    float radius;\n    //how the object interacts with light\n    Material mat;\n};\n\n\nstruct RayInfo {\n    //true if the ray has collided\n    bool collided;\n    //worldspace coordinate of intersection point\n    vec3 point;\n    //distance from camera to intersection point\n    float dist;\n    //normalized direction vector of the ray\n    vec3 dir;\n    //normalized normal direction of surface hit\n    vec3 norm;\n    //color of the ray\n    vec3 col;\n    //array element of object intersected with\n    int object;\n};\n\n//define several types of object materials\nconst Material matSphere = Material(vec3(0.761,0.761,0.761), vec3(0.,0.,0.), 0.);\nconst Material matEmit = Material(vec3(0.,0.,0.), vec3(10.,10.,10.), 0.);\nconst Material matGround = Material(vec3(0.463,0.925,0.455), vec3(0.,0.,0.), 1.);\nconst Material matSky = Material(vec3(0.,0.,0.), vec3(0.345,0.682,0.996)*2., 0.);\n\n//define all objects in the scene\nObject objects[numObjects] = Object[](\n    Object(SKY, vec3(0.,0.,0.), vec3(0.,0.,0.), 0., matSky), //sky\n    Object(PLANE, vec3(0.,0.,0.), vec3(0.,0.,1.), 0., matGround),  //plane\n    Object(SPHERE, vec3(0.,0.,.5), vec3(0.,0.,0.), .5, matSphere),   //sphere\n    Object(SPHERE, vec3(-1.,0.,1.5), vec3(0.,0.,0.), .2, matEmit));   //light\n\n\n//Gets the current direction the pixel is facing, to shoot a ray in that direction\nvec3 getPixelVector(vec2 _uv, float _fov, vec2 _camDir)\n{    \n    //get direction from current pixel\n    vec3 rawDir = vec3(_uv.x, 1./tan(_fov*.5),_uv.y);\n    \n    //normalize\n    vec3 fullDirNorm = normalize(rawDir);\n    \n    //add camera y axis rotation\n    fullDirNorm = vec3(fullDirNorm.x, cos(_camDir.y)*fullDirNorm.y-sin(_camDir.y)*fullDirNorm.z, sin(_camDir.y)*fullDirNorm.y+cos(_camDir.y)*fullDirNorm.z);\n    \n    //add camera x axis rotation\n    fullDirNorm = vec3(cos(_camDir.x)*fullDirNorm.x-sin(_camDir.x)*fullDirNorm.y, sin(_camDir.x)*fullDirNorm.x+cos(_camDir.x)*fullDirNorm.y, fullDirNorm.z);\n   \n    return fullDirNorm;\n}\n\n\n//create a checker texture on an object\nvec3 checker(vec3 _point)\n{\n    return vec3(mod(floor(_point.x)+floor(_point.y)+floor(_point.z+.001), 2.));\n}\n\n\n//check if a ray shot out hits a specified plane, and return the RayInfo\nRayInfo intersectPlane(RayInfo _ray, Object _planeObj)\n{\n    //get the angle between _dir and _planeObj normal vectors\n    float dist = dot(_planeObj.position - _ray.point, _planeObj.normal) / dot(_ray.dir, _planeObj.normal);\n    bool collided = (dist < farClip && dist > 0.);\n    vec3 point = _ray.point + (_ray.dir * dist);\n    \n    vec3 col = checker(point)*.5+.5;\n    return RayInfo(collided, point, dist, _ray.dir, _planeObj.normal, _ray.col*col*_planeObj.mat.col+_planeObj.mat.emit, 0);\n}\n\n\n//check if a ray shot out hits a specified sphere, and return the RayInfo\nRayInfo intersectSphere(RayInfo _ray, Object _sphereObj)\n{\n    vec3 sphereRay =  _sphereObj.position - _ray.point;\n    float distToSphere = length(sphereRay);\n    float distToClosestPt = dot(_ray.dir, sphereRay);\n    float distFromClosestPtToSphere = sqrt(pow(distToSphere, 2.) - pow(distToClosestPt, 2.));\n    bool collided = (distFromClosestPtToSphere < _sphereObj.radius && distToClosestPt > 0.);\n    \n    vec3 point;\n    float dist;\n    if(collided)\n    {\n        float distfromClosestPtToIntersect = sqrt(pow(_sphereObj.radius, 2.) - pow(distFromClosestPtToSphere, 2.));\n        dist = distToClosestPt - distfromClosestPtToIntersect;\n        point = _ray.point + _ray.dir * dist;\n    }\n    \n    vec3 col = vec3(1);\n    return RayInfo(collided, point, dist, _ray.dir, normalizeVec(_sphereObj.position - point), _ray.col*col*_sphereObj.mat.col+_sphereObj.mat.emit, 0);\n}\n\n\n//for a given ray, check if it hits every object, then return only the closest hit\nRayInfo intersect(RayInfo _ray, Object[numObjects] _objects)\n{\n    RayInfo closestRay;\n    closestRay.collided = false;\n    closestRay.dist = farClip;\n    for(int i = 0; i <= _objects.length()-1; i++)\n    {\n        if(_objects[i].type == PLANE && _ray.object != SPHERE)\n        {\n            RayInfo testRay = intersectPlane(_ray, _objects[i]);\n            testRay.object = i;\n            \n            if(testRay.collided && testRay.dist < closestRay.dist)\n            {\n                closestRay = testRay;\n            }\n        }\n        if(_objects[i].type == SPHERE && _ray.object != PLANE)\n        {\n            RayInfo testRay = intersectSphere(_ray, _objects[i]);\n            testRay.object = i;\n            \n            if(testRay.collided && testRay.dist < closestRay.dist)\n            {\n                closestRay = testRay;\n            }\n        }        \n    }\n    if(!closestRay.collided)\n    {\n        closestRay.col = _ray.col*_objects[0].mat.emit;\n    }\n    return closestRay;\n}\n\n//function which outputs the color of a ray in a given direction\nRayInfo raytrace (RayInfo _ray, Object[numObjects] _objects)\n{\n    RayInfo newRay = intersect(_ray, _objects);\n    return newRay;\n}\n\n\n//creates a new outgoing direction for an incoming ray and material\nvec3 reflectRay(RayInfo _ray, Material _mat)\n{\n    if(_mat.rough == 0.)\n    {\n        return reflectVec(_ray.dir, _ray.norm);\n    }\n    else\n    {\n        vec3 refl = reflectVec(_ray.dir, _ray.norm);\n        vec3 rand = normalizeVec(vec3(rand(seed)-.5,rand(seed+1.)-.5,rand(seed+2.)-.5));\n        rand = rand*sign(dot(rand,_ray.norm));\n        vec3 avg = normalizeVec(rand*_mat.rough + refl*(1.-_mat.rough));\n        return avg;\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //custom timestep\n    gTime = iTime *.25;\n    \n    //add sub-pixel variance to direction to create antialiasing\n    vec2 uv = fragCoord+vec2(rand(fragCoord+fract(gTime)),rand(fragCoord+1.+fract(gTime)));\n    \n    uv = (uv * 2.0 - iResolution.xy) / iResolution.x;\n    float fov = toRadians(110.);\n    \n    vec3 camPos = vec3(sin(gTime),-cos(gTime),1.-.75*sin(gTime));\n    vec2 camDir = vec2(gTime,toRadians(-20.)+.6*sin(gTime)-.15);\n    vec3 dir = getPixelVector(uv, fov, camDir);\n    \n\n    RayInfo ray = RayInfo(false, camPos, 0., dir, vec3(0.,0.,0.), vec3(1.,1.,1.), -1);\n    vec3 avgCol = vec3(0.,0.,0.);\n    for (int i=1; i<=samples; i++)\n    {    \n        seed = vec2(uv+float(i)+fract(gTime));\n        for(int j=1; j<=maxBounces; j++)\n        {\n            ray = raytrace(ray, objects);\n            if(!ray.collided) { break; }\n            ray.dir = reflectRay(ray, objects[ray.object].mat);\n        }\n        avgCol = avgCol*(1.-1./float(i)) + ray.col*(1./float(i));\n    }\n    fragColor = vec4(acesFitted(avgCol),1.);\n    //fragColor = vec4(fract(dir*10.),1.);\n}","name":"Image","description":"","type":"image"}]}