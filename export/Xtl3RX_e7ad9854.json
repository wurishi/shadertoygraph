{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"//-----------------------------\n#define time iTime\nconst int MAX_ITER = 250;\nvec3 lightDir       = normalize(vec3(3.86, 8.14, -12.46)); \n\nvec3 camPos = vec3(0., 0.,1.5);\nvec3 camDir = vec3(0.0, 0.0, -1.0);\nvec3 camUp  = vec3(0.0, 1.0, 0.0);\nfloat colZ = 1.;\nfloat rad = 1.1;// 1.0;\nstruct mat\n{\n  float typeMat;        // Ñ‚Ð¸Ð¿ Ð¼Ð°Ñ‚ÐµÑ€Ð¸Ð°Ð»Ð° \n};\nmat materialMy = mat(0.0);\n\n//----------------------------------------------------\nvec3 getNormal(in vec3 p);\nfloat renderFunction(in vec3 pos);\nfloat render(in vec3 posOnRay, in vec3 rayDir);\nvec4 getColorPixel(inout vec3 ro, vec3 rd, inout vec3 normal, float dist, float typeColor);\n//----------------------------------------------------\nvec3 rotationCoord(vec3 n)\n{\n vec3 result;\n   float t = time * 0.1;//tmpTime;//\n   vec2 sc = vec2(sin(t), cos(t));\n   mat3 rotate;\n   mat3 rotate_x = mat3(  1.0,  0.0,  0.0,\n                          0.0, sc.y,-sc.x,\n                          0.0, sc.x, sc.y);\n   mat3 rotate_y = mat3( sc.y,  0.0, -sc.x,\n                         0.0,   1.0,  0.0,\n                         sc.x,  0.0,  sc.y);\n   mat3 rotate_z = mat3( sc.y, sc.x,  0.0,\n                        -sc.x, sc.y,  0.0,\n                         0.0,  0.0,   1.0);\n  rotate = rotate_z * rotate_y * rotate_z;                \n  result = n * rotate;\n  return result;\n}\n//----------------------------------------------------\nfloat dSphere(vec3 p, float r)\n{\n   return length(p) - r;\n}\n//---------------------------------------------\n// ÐŸÐ¾Ð»ÑƒÑ‡ÐµÐ½Ð¸Ðµ Ð¿Ñ€Ð¸Ð¼Ð¸Ñ‚Ð¸Ð²Ð° Ð¸ Ð¿Ð°Ñ€Ð°Ð¼ÐµÑ‚Ñ€Ð¾Ð² Ð¼Ð°Ñ‚ÐµÑ€Ð¸Ð°Ð»Ð°\nfloat distMat(inout float curDist, float dist, in float typeMat)\n{\n   float res = curDist;\n   if (dist < curDist) \n   {\n      materialMy.typeMat     = typeMat;\n      res                    = dist;\n     return res;\n   }\n   return curDist;\n}\n//--------------------------------------------------\nfloat sdCross( in vec3 p )\n{\n  float inf = 0.;\n  float da = dSphere(p.xyz*vec3(inf,1.0,1.0), rad);\n  float db = dSphere(p.yzx*vec3(1.0,inf,1.0), rad);\n  float dc = dSphere(p.zxy*vec3(1.0,1.0,inf), rad); \n \n  return min(da,min(db,dc));\n}\n//--------------------------------------------------\nfloat map( in vec3 p )\n{\n\n   float d = dSphere(p, rad);\n    float s = 1.0;\n    float par = 1.;\n    float off = sin( 0.3*iTime );\n    par *=off;\n    if(par > 3.4) par = 3.6;\n    if(par < -0.4) par = -0.6;\n    for( int m=0; m<2; m++ )\n   {\n      vec3 a = mod( p*s, 2.0 )-1.0;\n      s *= 3.0;\n      vec3 r = par - 3.0*abs(a);\n\n      float c = sdCross(r)/s;\n      d = max(d,-c);\n     colZ = 0.;\n        if( c>d )\n          colZ = par/c;\n   }\nreturn d;\n}\n\n//--------------------------------------------------\nfloat myObject(in vec3 p)\n{\n\n   float d =  1.0;\n   materialMy.typeMat = 0.0;\n   vec3 pos = p;\n   pos = rotationCoord(pos);   \n   d =  distMat(d,   map(pos) ,  2.0);   \n   return d; \n}\n//-------------------------------------------------\nfloat renderFunction(in vec3 pos)\n{\n    return  myObject(pos);    \n}\n//------------------------------------------------- \nvec3 getNormal(in vec3 p)\n{\n\n  const float e = 0.001;\n \n  vec3 n = vec3((renderFunction(vec3(p.x - e,p.y,p.z)) - renderFunction(vec3(p.x+ e,p.y,p.z))),\n                (renderFunction(vec3(p.x,p.y - e,p.z)) - renderFunction(vec3(p.x,p.y+ e,p.z))),\n                (renderFunction(vec3(p.x,p.y,p.z - e)) - renderFunction(vec3(p.x,p.y,p.z+ e))));\n  return normalize( n );\n}\n//----------------------------------------------------------------------\nvec4 getColorPixel(inout vec3 ro, vec3 rd, inout vec3 normal, float dist, float typeColor)\n{\n\n  vec4 color = vec4(1.);\n  vec3 hitPos = ro + rd * dist;\n  vec3 lightPos1 = normalize(lightDir);  \n  normal = normalize(getNormal(hitPos));  \n  vec3 diffuse =max(dot(normal,lightPos1),0.0)* vec3(0.9);\n  float specular = 0.0;   \n      if (dot(normal, -lightPos1) < 0.0) \n        specular = 0.0;\n     else \n         specular = pow(max(0.0, dot(reflect(-lightPos1, normal), normalize(ro - hitPos))), 5.0);\n\n//----------------------------------\n   if (materialMy.typeMat == 0.0) \n  {\n     vec3 col = mix( vec3(0.,0.1, 0.2 ), vec3(0., 0.96, 1.), 0.5 + 0.5*rd.y );\n     color =  vec4(col, 1.);\n   } \n   else if (materialMy.typeMat == 2.0)    \n   {\n        vec3 col = vec3(\n            0.5+0.5*cos(0.0+0.5*colZ),\n            0.5+0.5*cos(1.0+2.0*colZ),\n            0.5+0.5*sin(2.0+3.0*colZ) );\n        color.rgb = col * diffuse + specular;\n   }\n    ro = hitPos;\n  return color ;\n}\n\n//-------------------------------------------------\nfloat render(in vec3 posOnRay, in vec3 rayDir)\n{ \n  float t = 0.0;\n  bool glowed = false;\n  for(int i=0; i<MAX_ITER; ++i)\n  {\n    float d = renderFunction(posOnRay + t*rayDir); \n    if (d < 0.001 || t > 10.) \n         break;\n    t += d;\n  }\n   return t;\n}\n//------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 pos     =  fragCoord.xy / iResolution.xy * 2. - 1.;\n\tpos.x *= iResolution.x / iResolution.y;\n    vec3 camP = camPos;\n    vec3 camDir = normalize(-camP);\n    vec3 u = normalize(cross(camUp,camDir));\n    vec3 v = cross(camDir,u);\n    vec3 rayDir = normalize(camDir + pos.x * u + pos.y * v );  \n    vec4 color    = vec4(1.0);\n    vec3 normal   = vec3(1.0);\n    vec3 posOnRay = camP; \n    float path = 0.;\n  //--------------------------- \n     path =  render(posOnRay, rayDir);  \n     if(path > 0.)\n        color = getColorPixel(posOnRay, rayDir, normal, path, materialMy.typeMat); \n    \n     color.rgb = pow( color.rgb, vec3(0.5) );\n     fragColor =  color;\n\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"Xtl3RX","date":"1423822487","viewed":164,"name":"Menger ball","username":"Lio","description":"Experimenting with a fractal. \nhttps://iquilezles.org/articles/menger/menger.htm\nhttps://www.shadertoy.com/view/4sX3Rn","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["3d","raymarching","fractal"],"hasliked":0,"parentid":"","parentname":""}}