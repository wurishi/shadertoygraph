{"ver":"0.1","info":{"id":"lXXSDN","date":"1709521295","viewed":79,"name":"Testing Raytracing Reflections","username":"mehow_one","description":"Barebone chatgpt raytracer","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["raytracing","template"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.141528\n\nfloat map(float val, float inA, float inB, float outA, float outB) {\n  return (val - inA) / (inB - inA) * (outB - outA) + outA;\n}\n\nvec4 remapShadows(vec4 color) {\n  float factor = 2.;\n  return vec4(\n    pow(color.x, factor),\n    pow(color.y, factor),\n    pow(color.z, factor),\n    color.w\n  );\n}\n\nvec4 sampleBackground(vec3 normal, sampler2D bg) {\n  // x = rho sin(phi) cos(theta)\n  // y = rho cos(phi)\n  // z = rho sin(phi) sin(theta)\n  // rho = 1 after normalization\n  float phi = acos(normal.y);\n  float sinPhi = sin(phi);\n  float theta =\n    abs(sinPhi) > 0.0001\n      ? acos(normal.x / sinPhi)\n      : 0.;\n  vec2 coord = vec2(\n    map(theta, 0., PI, 0., 1.),\n    map(phi, 0., PI, 1., 0.)\n  );\n    \n  return texture(bg, coord);\n}\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalize coordinates to [-1, 1]\n    vec2 uv = (fragCoord - iResolution.xy * 0.5) / iResolution.y;\n    \n    // Camera setup\n    vec3 camPos = vec3(0.0, -sqrt(2.),0.00001); // Camera above the sphere at some height\n    vec3 camTarget = vec3(0.0, 0.0, 0.0); // Camera is looking at the center of the sphere\n    vec3 camDir = normalize(camTarget - camPos); // Direction from the camera to the target\n\n    // Constructing a coordinate system for the camera\n    vec3 up = vec3(0.0, 1.0, 0.0); // Up vector\n    vec3 camRight = normalize(cross(up, camDir));\n    vec3 camUp = cross(camDir, camRight);\n\n    // Ray direction for each pixel\n    vec3 rayDir = camDir + uv.x * camRight + uv.y * camUp;\n    // Sphere properties\n    vec3 sphereCenter = vec3(0.0, 0.0, 0.0);\n    float sphereRadius = 0.5;\n\n    // Ray-sphere intersection\n    vec3 toSphere = camPos - sphereCenter;\n    float a = dot(rayDir, rayDir);\n    float b = 2.0 * dot(toSphere, rayDir);\n    float c = dot(toSphere, toSphere) - sphereRadius * sphereRadius;\n    float discriminant = b * b - 4.0 * a * c;\n\n    if (discriminant > 0.0)\n    {\n        // Calculate intersection\n        float t = (-b - sqrt(discriminant)) / (2.0 * a);\n        vec3 hitPoint = camPos + t * rayDir;\n\n        // Reflection vector\n        vec3 normal = normalize(hitPoint - sphereCenter);\n        vec3 reflectedRay = reflect(rayDir, normal);\n\n        // Map texture to the reflected ray\n        vec3 color = texture(iChannel0, reflectedRay).rgb;\n\n        fragColor = vec4(color, 1.0);\n    }\n    else\n    {\n        // Background color if no intersection\n        fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n    }\n}\n","name":"Image","description":"","type":"image"}]}