{"ver":"0.1","info":{"id":"XXlGzH","date":"1707147471","viewed":50,"name":"Menu","username":"MinoLinoTino","description":"Menu","likes":1,"published":1,"flags":32,"usePreview":0,"tags":["menu"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n\n{\nivec2 itclickaddr=ivec2(iResolution.x,0);\nvec4 tlastclick= fetchData(iChannel0,itclickaddr);\n\nfloat sintime = clamp((0.15*(sin(iTime-tlastclick.x)+1.0)),0.0,100.0);\n\n    // Normalized pixel coordinates (from 0 to 1)\n\n    vec2 uv = fragCoord/iResolution.xy;\n\n    \n vec4 uvMouse = vec4( iMouse.x/iResolution.x,iMouse.y/iResolution.y,iMouse.z/iResolution.x,iMouse.w/iResolution.y);\n    vec2 center= vec2(0.5,0.5);\n\n    vec2 scale = vec2(1000.0,1.0);\n\n    \n\n   float dist = distance (uv.xy,uvMouse.xy);\n\n   float gaussi = gauss(dist,sintime,scale.xy);\n\n    // Time varying pixel color\n\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n\n    fragColor = vec4(tlastclick.x,gaussi,0.0,1.0);\n\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n fragColor= vec4(0.0,0.0,0.0,0.0);\n\n//ivec2 bata= fragCoord\nivec2 iposclickaddr= ivec2(0,0);\nvec2 posclickaddr =vec2(0.5,0.5);\n//same data with float and int so i can use both fetch data and == \nvec2 tclickaddr= vec2(-0.5,0.5);\nivec2 itclickaddr = ivec2(iResolution.x,0);\n\nvec4 lastposclick = texelFetch(iChannel0,iposclickaddr,0);\nvec4 lasttimeclick= texelFetch(iChannel0,itclickaddr,0);\n  if (storeData(fragCoord,iposclickaddr)){\n         if (lastposclick.xy !=iMouse.xy){\n      fragColor=iMouse;\n         }\n        \n  }\n  else if (fragCoord.xy==tclickaddr.xy){\n      if (iMouse.zw==lastposclick.zw){\n      \n        fragColor=vec4(lasttimeclick.x,0.0,0.0,0.0);\n        }\n      else if(iMouse.zw != lastposclick.zw){\n      fragColor=vec4(iTime,0.,0.,0.);\n      }\n  }\n \n \n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"vec4 someFunction( vec4 a, float b )\n{\n    return a+b;\n}\nfloat gauss ( float xdist, float xcenter, vec2 scale)\n\n{\n\nfloat gaussian = scale.y * pow(2.7182,-scale.x*pow(xdist-xcenter,2.0));\n\nreturn gaussian;\n\n}\n// Addresses:\n// These should be ivec2s containing the pixel coordinates of where certain data\n// should go. The coordinates are not normalize but can range from (0, 0) to\n// (iResolution.x, iResolution.y).\nconst ivec2 SCREEN_COLOR_ADDR = ivec2(0, 0);\n\n// Unfortunately, the only way to define functions that sample iChannels in Common\n// is with #define :(\n\n// buf - iChannel to read from\n// addr - the data address in the form of an ivec2 (vector containing two integers)\n#define fetchData(buf, addr) texelFetch(buf, addr, 0)\n\n// buf_pos - fragment position (fragCoord)\n// addr - the data address in the form of an ivec2\n// storeData() just evaluates if the data address matches the fragment position\n// in which case the data should be stored in fragColor.\n#define storeData(buf_pos, addr) ivec2(buf_pos) == addr","name":"Common","description":"","type":"common"}]}