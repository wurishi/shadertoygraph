{"ver":"0.1","info":{"id":"McKGz1","date":"1712441313","viewed":51,"name":"Diffuse interpolation - 2D","username":"mrboggieman","description":"Diffuse interpolation by sampling normalised 2d distributions. The alpha changes over time showing the transition between the two distributions. The sampling rate is pretty low as sampling is inefficient","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["blending","diffuse","interpolation"],"hasliked":0,"parentid":"4cK3z1","parentname":"Diffuse interpolation - 2D image"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Diffuse (move pixels) between two 2D images\n// Demo inspired by Iterative-(de)Blending (see Figure 9 in https://arxiv.org/pdf/2305.03486.pdf)\n// Note: the approach in this demo is different - rather than randomising paths we use means which is equivalent with enough samples\n\n// increase for greater precision - this is O(n^2) :(\nconst int num_samples = 40; //this needs to be the resolution of the frame really\n\nconst float framesPerTransition = 500.0; // the number of frames to use between each transition\n\n// https://developer.nvidia.com/gpugems/gpugems/part-i-natural-effects/chapter-8-simulating-diffraction\nvec3 spectral(float x) {\n    vec3 col = 4.0 * (x - vec3(0.75, 0.5, 0.25));\n    return max(vec3(0.0), vec3(1.0) - col * col);\n}\n\n// image samples we will be interpolating\nvec3 from(in vec2 uv) {\n    //large colour circle in the center\n    float mag = smoothstep(0.0, 1.0/iResolution.y, length(uv-0.5) - 0.4);\n    return (1.0 - mag) * spectral((uv.x - 0.1) / 0.8);\n    \n    //circle bottom left\n    //float mag = smoothstep(0.0, 1.0/iResolution.y, length(uv-0.2) - 0.1);\n    //return (1.0 - mag) * spectral((uv.x - 0.1)/0.2);\n}\n\nvec3 to(in vec2 uv) {\n    //blend to almost black\n    return vec3(0.1);\n\n    //circle top right\n    //float mag = smoothstep(0.0, 1.0/iResolution.y, length(uv-0.8) - 0.1);\n    //return (1.0 - mag) * spectral((uv.x - 0.7)/0.2);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\n    float alpha = mod(float(iFrame) / framesPerTransition, 1.0);\n    int stage = int(float(iFrame) / framesPerTransition) % 3;\n\n    if (alpha < 0.00001) {\n        fragColor = vec4(from(uv), 1.0);\n        return;\n    }\n    \n    // we need to normalise the distributions so just sum the samples for a division later\n    // note: could calculate this once per image in a buffer or something\n    vec3 from_total = vec3(0.0);\n    vec3 to_total = vec3(0.0);\n\n    for (int i=0; i<num_samples; i++) {\n        float sample_x = float(i) / float(num_samples);\n\n        for (int j=0; j<num_samples; j++) {\n            float sample_y = float(j) / float(num_samples);\n            vec2 sample_pos = vec2(sample_x, sample_y);\n\n            from_total += from(sample_pos);\n            to_total += to(sample_pos);\n        }\n    }\n\n    // only a subset of the inputs and outputs would cross our 3d coord, we can compute the ranges\n    // maths: https://www.desmos.com/3d/60b155c9e9\n    float from_alpha = -alpha/(1.0-alpha);\n    \n    vec2 from_start = clamp((1.0 - uv) * from_alpha + uv, vec2(0.0), vec2(1.0));\n    vec2 from_end = clamp(-uv * from_alpha + uv, vec2(0.0), vec2(1.0));\n    \n    float to_alpha = (1.0-alpha) / -alpha;\n\n    vec2 to_start = clamp(-uv * to_alpha + uv, vec2(0.0), vec2(1.0));\n    vec2 to_end = clamp((1.0 - uv) * to_alpha + uv, vec2(0.0), vec2(1.0));\n\n    //all we need to do is figure out how many points from the original distribution will go through this coord on their way to the target\n    vec3 sum = vec3(0.0);\n\n    for (int i=0; i<num_samples; i++) {\n        float sample_x = float(i) / float(num_samples);\n\n        for (int j=0; j<num_samples; j++) {\n            float sample_y = float(j) / float(num_samples);\n            vec2 sample_pos = vec2(sample_x, sample_y);\n\n            vec2 from_pos = mix(from_start, from_end, sample_pos);\n            vec2 to_pos = mix(to_start, to_end, sample_pos);\n\n            sum += from(from_pos) * (to(to_pos) / to_total);\n        }\n    }\n    \n    //the two distributions may have a different sum so scale to blend between the two\n    vec3 target_total = mix(from_total, to_total, alpha);\n    vec3 total_multiplier = target_total / from_total;\n\n    sum *= total_multiplier;\n\n    fragColor = vec4(sum,1.0);\n}\n","name":"Image","description":"","type":"image"}]}