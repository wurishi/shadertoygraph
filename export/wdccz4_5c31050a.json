{"ver":"0.1","info":{"id":"wdccz4","date":"1606978923","viewed":80,"name":"triangle texure mapping","username":"wangzhiyong","description":"a triangle texure mapping by shader","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["triangle","texturemapping"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 solveBarycentricWeight(vec3 px, vec3 py, vec2 p_cur)\n{\n    float delta = 0.01;\n    vec4 o1 = vec4(px, p_cur.x);\n    vec4 o2 = vec4(py, p_cur.y);\n    vec4 o3 = vec4(1.0, 1.0, 1.0, 1.0);\n    if(abs(o1.x) < delta)\n        o1 = o1 + o3;\n    o1 = o1 / o1.x;\n    o2 = o2 - o2.x * o1;\n    o3 = o3 - o1;\n    if(abs(o2.y) < delta)\n    {\n        if(abs(o3.y) < delta)\n        {\n            if(abs(o2.z) < delta)\n                return vec3(1, 0, 0);\n            else\n                return vec3(o1.w, 0, o2.w / o2.z);\n        }\n        else\n        {\n            vec4 o_temp = o2;\n            o2 = o3;\n            o3 = o_temp;\n        }\n    }\n    o2 = o2 / o2.y;\n    o3 = o3 - o2 * o3.y;\n    if(abs(o3.z) > delta)\n    {\n        o3 = o3 / o3.z;\n    }\n    else\n    {\n        o3.w = 0.0;\n    }\n    o3 = o3 / o3.z;\n    o2 = o2 - o3 * o2.z;\n    o1 = o1 - o2 * o1.y - o3 * o1.z;\n\n    return vec3(o1.w, o2.w, o3.w);\n}\n\nvec2 warpByTriangle(vec2 origin[3], vec2 target[3], vec2 p)\n{\n    vec3 px = vec3(origin[0].x, origin[1].x, origin[2].x);\n    vec3 py = vec3(origin[0].y, origin[1].y, origin[2].y);\n    \n    float i1 = (origin[1].y - origin[0].y) * (origin[2].x - origin[0].x) - (origin[1].x - origin[0].x) * (origin[2].y - origin[0].y);\n    float i2 = (origin[2].y - origin[1].y) * (origin[0].x - origin[1].x) - (origin[2].x - origin[1].x) * (origin[0].y - origin[1].y);\n    float i3 = (origin[0].y - origin[2].y) * (origin[1].x - origin[2].x) - (origin[0].x - origin[2].x) * (origin[1].y - origin[2].y);\n    \n    float j1 = (origin[1].y - origin[0].y) * (p.x - origin[0].x) - (origin[1].x - origin[0].x) * (p.y - origin[0].y);\n    float j2 = (origin[2].y - origin[1].y) * (p.x - origin[1].x) - (origin[2].x - origin[1].x) * (p.y - origin[1].y);\n    float j3 = (origin[0].y - origin[2].y) * (p.x - origin[2].x) - (origin[0].x - origin[2].x) * (p.y - origin[2].y);\n    \n    vec2 res_p = p;\n    if(i1 * j1 >= 0.0 && i2 * j2 >= 0.0 && i3 * j3 >= 0.0)\n    {\n        vec3 weight = solveBarycentricWeight(px, py, p);\n        res_p = target[0] * weight.x + target[1] * weight.y + target[2] * weight.z;\n//        if(abs(weight.x + weight.y + weight.z - 1.0) < 0.01)\n//            res_p = target[0] * weight.x + target[1] * weight.y + target[2] * weight.z;\n//        else\n//            res_p = p;\n    }\n    return res_p;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 cur_point = uv;\n    vec2 origin[5];\n    vec2 target[5];\n    \n    float a = 0.2;\n    float b = 0.05 * sin(iTime);\n    \n    origin[0] = vec2(0.5, 1.0 - a);\n    origin[1] = vec2(0.5, a);\n    origin[2] = vec2(a, 0.5);\n    origin[3] = vec2(1.0 - a, 0.5);\n    \n    target[0] = origin[0];\n    target[1] = origin[1];\n    target[2] = origin[2];\n    target[3] = origin[3];\n    \n    origin[4] = vec2(0.5 + b, 0.5);\n    target[4] = vec2(0.5, 0.5);\n\n    \n    vec2 origin_used[3];\n    vec2 target_used[3];\n    origin_used[0] = origin[0];\n    origin_used[1] = origin[2];\n    origin_used[2] = origin[4];\n    target_used[0] = target[0];\n    target_used[1] = target[2];\n    target_used[2] = target[4];\n    vec2 res_point1 = warpByTriangle(origin_used, target_used, cur_point);\n  \n    origin_used[0] = origin[0];\n    origin_used[1] = origin[4];\n    origin_used[2] = origin[3];\n    target_used[0] = target[0];\n    target_used[1] = target[4];\n    target_used[2] = target[3];\n    vec2 res_point2 = warpByTriangle(origin_used, target_used, cur_point);\n    \n    origin_used[0] = origin[4];\n    origin_used[1] = origin[2];\n    origin_used[2] = origin[1];\n    target_used[0] = target[4];\n    target_used[1] = target[2];\n    target_used[2] = target[1];\n    vec2 res_point3 = warpByTriangle(origin_used, target_used, cur_point);\n    \n    origin_used[0] = origin[4];\n    origin_used[1] = origin[1];\n    origin_used[2] = origin[3];\n    target_used[0] = target[4];\n    target_used[1] = target[1];\n    target_used[2] = target[3];\n    vec2 res_point4 = warpByTriangle(origin_used, target_used, cur_point);\n    \n    \n    vec2 res_point = res_point1 + res_point2 + res_point3 + res_point4 - 3.0 * cur_point;\n    \n    fragColor = texture(iChannel0, res_point);\n    \n    \n//    if(abs(cur_point.y - res_point.y) < 0.00001)\n//        fragColor = vec4(1.0);\n}","name":"Image","description":"","type":"image"}]}