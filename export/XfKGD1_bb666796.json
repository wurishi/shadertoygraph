{"ver":"0.1","info":{"id":"XfKGD1","date":"1712707977","viewed":45,"name":"SIRV simulation","username":"numpyhard","description":"SIRV simulation based loosely on a paper","likes":1,"published":1,"flags":32,"usePreview":0,"tags":["mask","infection","epidemic"],"hasliked":0,"parentid":"XXfSWl","parentname":"zhangetal"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Output to screen\n    fragColor = texture(iChannel0, uv);\n\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define inf_prob 0.4\n#define rec_prob 0.37\n#define beta 1.\n#define vaccine_payoff -0.1\n#define init_infection 0.00001\n#define init_inf2 1.\n#define init_vacc 0.1\n#define season_length 200\n\nvec2 neighbours[8] = vec2[8](vec2(-1.), vec2(-1.,0.), vec2(-1.,1.), vec2(0., -1.), vec2(0., 1.), vec2(1., -1.), vec2(1., 0.), vec2(1.));\n\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec4 read(vec2 p) {\n\treturn texture(iChannel0, p/iResolution.xy);\n}\n\n\nvec4 pool(vec2 p) {\n  vec4 acc = vec4(0.);\n  for (int y=-1; y<=1; ++y)   \n  for (int x=-1; x<=1; ++x) {\n    acc += read(p + vec2(x, y));\n  }\n  return acc;\n}\n\n\nfloat random(vec2 px){\n    return hash13(vec3(3.*px+vec2(521.3, 0.),mod(1772.*iTime+19.*iDate.w,137.)));\n}\n\nfloat fermi(float diff){\n    return 1./(1.+exp(-beta*diff));\n}\n\nfloat getPayoff(vec4 a){\n    return (a.x+a.y)*-1. + a.z*vaccine_payoff;\n}\n\nvoid mainImage( out vec4 fc, in vec2 fragCoord )\n{\n    // Initialise\n    if (iFrame == 0){\n        // Init vaccination\n        float a = random(fragCoord+vec2(-56593.));\n        fc = vec4(0.);\n        if(a<init_vacc)fc.z=1.;\n        else if (a<init_vacc+init_infection)fc.x = 1.;\n        \n        \n        fc.w = 1.;\n        return;\n    }\n    fc = read(fragCoord);\n    \n    if (iFrame % season_length == 0) {\n        // Imitate strategies\n        int x = int(floor(8.*random(fragCoord+vec2(8782.))));\n        vec4 neighbour = read(fragCoord+neighbours[x]);\n        if(neighbour.z != fc.z){\n            float gd = getPayoff(neighbour)-getPayoff(fc);\n            if(random(fragCoord+vec2(-1232., 0.)) < fermi(gd)){\n                fc.z = neighbour.z;\n            }\n        }\n        fc.x=0.;\n        fc.y=0.;\n\n        float a = random(fragCoord+vec2(-56593.));\n        if(a<init_infection && fc.z!=1. && fragCoord.x>00.){\n            if(random(fragCoord)<init_inf2)fc = vec4(1., 0., 0., 1.);\n        }\n        return;\n    }\n\n    vec4 accum = pool(fragCoord);\n    \n    // If infected, recover\n    if(fc.x > 0.){\n        if(random(fragCoord) < rec_prob){\n            fc = vec4(0.,1.,0.,1.);\n        }\n    } // if susceptible, infect according to prob\n    else if(fc.z == 0. && fc.y == 0. && accum.x > 0.){\n        float tprob = 1.-pow(1.-inf_prob,accum.x);\n        if(random(fragCoord) < tprob){\n            fc=vec4(1.,0.,0.,1.);\n        }\n    }\n}","name":"Buffer A","description":"","type":"buffer"}]}