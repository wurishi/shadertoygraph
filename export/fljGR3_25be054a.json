{"ver":"0.1","info":{"id":"fljGR3","date":"1624419127","viewed":145,"name":"Cubic Bezier 4 Methods","username":"Yusef28","description":"A Cubic Bezier Segment Visualization\nAs linear interpolation, binomial form, matrix form and using mix functions\n4rknova also made a pretty one of these\nA good resource: https://pomax.github.io/bezierinfo/\n\n","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["bezier","cubic","casteljau"],"hasliked":0,"parentid":"NtB3z3","parentname":"Quadratic Bezier (Casteljau)"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Version by 4rknova: Interpolation: Bezier, Cubic: https://www.shadertoy.com/view/ll23Wt\n//Version by oneshade: Cubic Bezier to \"y=\":  https://www.shadertoy.com/view/Nd2Gzw\n//version by fluxatron: Day11: Cubic Bezier: https://www.shadertoy.com/view/WdlBD8\n\n//I'm learning this stuff from ----> https://pomax.github.io/bezierinfo/\n\n//Edit: 24-06-2021 added a matrix representation to the casteljau's segmentation algo\n\n#define numSegments 20.\n#define showSeg\n/*\n//black and light blue\n#define bgCol   vec3(244, 244, 248)/255.\n#define lineCol vec3(254, 215, 102)/255.*0.\n#define segCol vec3(42, 183, 202)/255.\n#define circleCol vec3(42, 183, 202)/255.\n#define segCircleCol vec3(210., 81., 224.)/255.\n#define magikCol vec3(142,142,246)/255.\n*/\n\n\n//Cappacino pallet\n#define bgCol   vec3(60, 47, 47)/255.*0.5\n#define lineCol vec3(133, 68, 66)/255.\n#define segCol vec3(225, 244, 230)/255.\n#define circleCol vec3(255, 244, 230)/255.\n#define segCircleCol vec3(255, 244, 230)/255.\n#define magikCol vec3(60, 47, 47)/255.\n\n\n#define segRingRadius 0.006\n#define pointRingRadius 0.01\n\nfloat distToLine(vec2 A, vec2 B, vec2 p){\n    \n    vec2 PA = p - A;\n    vec2 BA = B - A;\n    float d = dot(PA,BA);\n    float t = clamp(d/(length(BA)*length(BA)),0., 1.);//Vektorprodukt\n    vec2 normal = PA - BA*t;\n    return length(normal);\n\n}\n\nvec3 drawRing(float radius, float thickness, vec2 p, vec2 off, vec3 col, vec3 ringCol){\n    \n    p -= off;\n    \n    float eps = 1./min(iResolution.x,iResolution.y);\n    \n    float circle = 1.-smoothstep(-eps, eps, \n    abs(radius - length(p))-thickness);\n    \n    col = mix(col, ringCol, circle);\n    \n    return col;\n}\n\nvec3 drawLine(vec2 A, vec2 B, vec2 p, vec3 col, vec3 lineColor){\n\n    //float dist = 1.0-smoothstep(0.004, 0.005, distToLine(A, B, p));\n    float dist = distToLine(A, B, p);\n    dist = 1.0-smoothstep(0., fwidth(dist), dist - 0.004);\n    return mix(col, lineColor, dist);\n}\n\n\n//shorten version thx iapafoto, original version with notes is below\n//but then I went and added a matrix version to it\nvec3 drawSegments(vec2 p, vec2 p1, vec2 p2, vec2 p3, vec2 p4, vec3 col){\n    vec2 g, prev = p4;\n    float dt = 1./numSegments;  \n    \n    for(float t = dt; t <= 1.+dt; t+=dt){   \n    \n    \n        //Matrix Representation\n        vec4 T = vec4(1, t, t*t, t*t*t);\n        \n        //nice looking upper triangular matrix there. \n        \n        mat4 M = mat4(1,0,0,0, \n                     -3,3,0,0, \n                      3,-6,3,0, \n                     -1,3,-3,1);\n                     \n        //I wonder what's gonna happen...             \n        vec4 Px = vec4(p4.x,p3.x,p2.x,p1.x);\n        vec4 Py = vec4(p4.y,p3.y,p2.y,p1.y);\n        \n        //in glsl vector  * vector is component wise so to get the scalar product we need to use dot\n        //when the time comes! After the initial M*T (or P*M apparently?)\n        g.x = dot(M*T,Px); // is the same as dot(P*M,T)\n        g.y = dot(Py*M,T); //I flipped them for y just to show there is no difference\n        \n        \n        //or\n        //Mix functions, much smaller\n        //g = mix(p3,p2,t);\n        //g = mix(mix(mix(p4,p3,t), g, t), \n        //            mix(g, mix(p2,p1,t), t), t);\n        \n        \n        //or \n        //Binomial\n        //g = p1*(t*t*t) + p2*3.*(1.-t)*(t*t) + p3*3.*(1.-t)*(1.-t)*(t) + p4*(1.-t)*(1.-t)*(1.-t);\n        \n        col = drawLine(prev,g,p,col,segCol*vec3(t, .7, .9));\n        col = drawRing(segRingRadius, .003, p, g, col, segCircleCol);\n        prev = g;\n    }\n    return col;\n}\n\n//original version with notes\n\nvec3 drawSegmentsOrig(vec2 p, vec2 p1,vec2 p2,vec2 p3,vec2 p4,vec3 col){\n    \n    float t = 0.;\n \n    //basic linear interpolation form\n    vec2 d1 = p1*t + (1.0-t)*p2;\n    vec2 d2 = p2*t + (1.0-t)*p3;\n    vec2 d3 = p3*t + (1.0-t)*p4;\n    \n    vec2 m1 = d1*t + (1.0-t)*d2; \n    vec2 m2 = d2*t + (1.0-t)*d3; \n    \n    vec2 g = m1*t + (1.0-t)*m2;\n\n    \n    //or \n    //vec2 g = p1*(t*t*t) + p2*3.*(1.-t)*(t*t) + p3*3.*(1.-t)*(t*t) + p4*(1.-t)*(1.-t)*(1.-t);\n    \n    //because if you substitute the right side of the d points\n    //into the d's in the right side of the m points\n    //and did that for the the m points into the g\n    //and add like terms you get the above!\n    \n    //p1*t*t + (1.0-t)*p2*t + p2*(1.0-t)*t + (1.0-t)*(1.0-t)*p3;\n    //p2*t*t + (1.0-t)*p3*t + p3*(1.0-t)*t + (1.0-t)*(1.0-t)*p4;\n    //p1*t*t*t + (1.0-t)*p2*t*t + p2*(1.0-t)*t*t + (1.0-t)*(1.0-t)*t*p3;\n    //p2*(1.0-t)*t*t + (1.0-t)*(1.0-t)*p3*t + p3*(1.0-t)*(1.0-t)*t + (1.0-t)*(1.0-t)*(1.0-t)*p4;\n    \n    \n    float dt = 1./numSegments;\n    \n    vec2 prev = g;\n    vec2 next;\n\n    col = drawRing(0.01, 0.003, p, p1, col, magikCol*1.5);\n    \n    for(float i = 0.; i < numSegments; i++){\n    \n        t += dt;\n        //basic linear interpolation form\n        d1 = p1*t + (1.0-t)*p2;\n        d2 = p2*t + (1.0-t)*p3;\n        d3 = p3*t + (1.0-t)*p4;\n    \n        m1 = d1*t + (1.0-t)*d2;\n        m2 = d2*t + (1.0-t)*d3;\n    \n        g = m1*t + (1.0-t)*m2;\n        \n        //or \n        //g = p1*(t*t*t) + p2*3.*(1.-t)*(t*t) + p3*3.*(1.-t)*(1.-t)*(t) + p4*(1.-t)*(1.-t)*(1.-t);\n    \n        next = g;\n        \n        col = drawLine(prev,next,p,col,segCol*vec3(t, 0.7, 0.9));\n        col = drawRing(segRingRadius, 0.003, p, next, col, segCircleCol);\n        prev = next;\n    }\n    \n    return col;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-iResolution.xy*0.5)/iResolution.y;\n    \n    float x =0.4, y=1.2, z=2.6, w=3.;\n    float eps = 1./min(iResolution.x, iResolution.y);\n    vec2 p1 = vec2(-0.6, -0.3) + vec2(sin(iTime/2.+x),cos(iTime/2.+x))/5.;\n    vec2 p2 = vec2(-0.5, 0.3) + vec2(sin(iTime+y),cos(iTime+y))/10.;\n    vec2 p3 = vec2(0.5, 0.3) + vec2(sin(iTime+z),cos(iTime+z))/7.;\n    vec2 p4 = vec2(0.1, -0.2) + vec2(sin(iTime/2.+w),cos(iTime/2.+w))/2.;\n    \n    float t = sin(iTime)*0.5+0.5;\n    \n    vec2 dLinePoint1 = p1*t + (1.0-t)*p2;\n    vec2 dLinePoint2 = p2*t + (1.0-t)*p3;\n    vec2 dLinePoint3 = p3*t + (1.0-t)*p4;\n    \n    vec2 ddPoint1 = dLinePoint1*t + (1.0-t)*dLinePoint2;\n    vec2 ddPoint2 = dLinePoint2*t + (1.0-t)*dLinePoint3;\n    \n    vec2 dddPoint = ddPoint1*t + (1.0-t)*ddPoint2;\n    \n   \n    \n    vec3 col = bgCol;\n    \n    // Time varying pixel color\n    vec3 magik_farber = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4)/4.);\n    \n\n    col = drawLine(p1,p2,uv,col,lineCol*0.5);\n    col = drawLine(p2,p3,uv,col,lineCol*0.5);\n    col = drawLine(p3,p4,uv,col,lineCol*0.5);\n    col = drawLine(dLinePoint1,dLinePoint2,uv,col,lineCol*0.7);\n    col = drawLine(dLinePoint2,dLinePoint3,uv,col,lineCol*0.7);\n    col = drawLine(ddPoint1,ddPoint2,uv,col,lineCol);\n    \n    col = drawRing(0.01, 0.003, uv, p1, col, lineCol);\n    col = drawRing(0.01, 0.003, uv, p2, col, lineCol);\n    col = drawRing(0.01, 0.003, uv, p3, col, lineCol);\n    col = drawRing(0.01, 0.003, uv, p4, col, lineCol);\n    \n    col = drawRing(0.01, 0.003, uv, dLinePoint1, col, circleCol);\n    col = drawRing(0.01, 0.003, uv, dLinePoint2, col, circleCol);\n    col = drawRing(0.01, 0.003, uv, dLinePoint3, col, circleCol);\n    col = drawRing(0.01, 0.003, uv, ddPoint1, col, magikCol);\n    col = drawRing(0.01, 0.003, uv, ddPoint2, col, magikCol);\n    \n    \n    col = drawSegments(uv, p1, p2, p3, p4, col);\n    \n    col = drawRing(0.02+(0.01+sin(iTime*4.)*0.01), 0.003, uv, dddPoint, col, magik_farber);\n    col = pow(col, vec3(0.75));\n    //vignett from ApoorvalJ https://www.shadertoy.com/view/4lSXDm\n    uv = fragCoord/iResolution.xy;\n    uv *=  1.0 - uv.yx;\n    float vig = uv.x*uv.y * 15.0; // multiply with sth for intensity\n    \n    vig = pow(vig, 0.15); // change pow for modifying the extend of the  vignette\n\n    // Output to screen\n    fragColor = vec4(col*vig*1.1,1.0);\n}","name":"Image","description":"","type":"image"}]}