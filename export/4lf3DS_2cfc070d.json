{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"/* Compiled with Shaderforth: https://github.com/daeken/Shaderforth\nimport[ noise ]\n\n:globals\n\ttrue =>shadertoy\n\t\t{\n\t\t\t@vec3 uniform =iResolution @float uniform =iTime\n\t\t\tiResolution .xy =>resolution\n\t\t\tiTime =>time\n\t\t}\n\t\t{ @vec2 uniform =resolution @float uniform =time }\n\tshadertoy cif\n\t@float =scene-noise\n;\n\n:m noise-2d pnoise-2d ;\n:m terrain ( p )\n\t20 2 p .x 6 / abs 0 1 clamp mix =>factor\n\t\tp .xz 2 / noise-2d factor /\n\t\tp .y neg\n\t-\n;\n\n:m ring-terrain ( p )\n\t[\n\t\t[\n\t\t\tp [ 0 .6 0 ] - [ 1 p .y - .05 * 1 - 2.5 2 ] / [ 1 .1 ] torus\n\t\t\tp [ 0 4.8 0 ] + 5 sphere\n\t\t] 1.25 unionsmooth\n\t\tp terrain\n\t] .2 unionsmooth\n;\n\n:m walkway ( p )\n\t{ ( $rp )\n\t\t[ rp .xz p rp - .x.z + 13.7 * sin .5 * rotate-2d rp .y ] .xzy [ .4 .1 .4 ] box\n\t} p [ 0 1 0 ] + [ 0 0 1 ] repeat\n;\n\n:m portal ( p )\n\t[\n\t\tp [ 0 .3 0 ] + [ 1 2.5 1 ] / 1 sphere\n\t\tp [ 1 3 .04 ] box\n\t] intersect\n;\n\n:m columns ( p )\n\tp .x sign neg =>flip\n\t{ ( $rp )\n\t\t[\n\t\t\t[ rp .xz rp .y flip * pi 2 / * pi 8 / + rotate-2d rp .y ] .xzy [ 0 1 0 ] + [ .2 1.5 .2 ] box\n\t\t\trp [ 0 1.25 0 ] - .4 sphere\n\t\t] .75 unionsmooth\n\t} p [ 2.25 0 2.5 ] repeat\n;\n\n:m hell-terrain ( p )\n\tp [ 0 p .z 4 / 0 ] + [ 0 1 0 1 ] plane scene-noise p .x time 1 + 2 * + sin .1 * + -.3 .6 clamp .4 * +\n;\n\n: scene ( p:vec3 -> vec2 )\n\tp .x 100 / round =room\n\tp [ room 100 * 0 0 ] - =p\n\troom 1 eq =heaven\n\troom 2 eq =>hell\n\t\tp .xz [ 1.5 1 ] *\n\t\t[ 0 time neg 1.5 / heaven mix 0 time heaven hell + mix 1 .3 heaven mix * ] - \n\t\tp .y +\n\t\t\t.75\n\t\t\t3 room -\n\t\troom 1 - sign abs mix\n\t* noise-2d =scene-noise\n\t[\n\t\troom 0 == {\n\t\t\t[\n\t\t\t\t[ p [ 0 1 0 ] + ring-terrain 1 ]\n\t\t\t\t[ p walkway 2 ]\n\t\t\t\t[ p portal 3 ]\n\t\t\t] hitunion\n\t\t}\n\t\troom 1 == {\n\t\t\tp [ 1 p .z -.04 * + 1 1 ] * [ 0 p .z .05 * 0 ] + =p\n\t\t\t[\n\t\t\t\t[\n\t\t\t\t\t[\n\t\t\t\t\t\tp [ 0 1 0 ] + [ 0 1 0 0 ] plane\n\t\t\t\t\t\tp columns\n\t\t\t\t\t] .75 unionsmooth\n\t\t\t\t\tp [ 0 0 far .2 + ] - [ 1.5 far far ] box\n\t\t\t\t] intersect\n\t\t\t\t4\n\t\t\t]\n\t\t}\n\t\t{\n\t\t\t[ p hell-terrain 5 ]\n\t\t}\n\t] cond =>temp\n\troom 1 - sign abs temp .y 3 - sign abs * =>is-portal\n\ttemp [ scene-noise .03 * is-portal * 0 ] +\n;\n\n:m portal-texture ( p )\n\t\t[\n\t\t\t##000\n\t\t\t.5 .5 0\n\t\t\tp .z sign 1 + 2 / 1 +\n\t\t\t0\n\t\t] material\n;\n\n:m marble-texture ( p )\n\tscene-noise abs =>noise\n\t##DBDBDB ##4F5052 noise mix =>color\n\t[ p .y .2 - 0 1 clamp 2 ** color - abs .3 .7 noise 100 * eps + 0 0 ] material\n;\n\n:m hell-texture ( p )\n\t[ ##525252 .05 .5 10 0 0 ] material\n;\n\n: get-material ( pos:vec3 dist:float id:float -> material )\n\t[\n\t\tid 1 == {\n\t\t\tpos .y .6 + 0 1 clamp =fade\n\t\t\t[ ##7A3B14 ##878787 fade mix .4 .7 1000 10 fade mix 0 -.3 ] material\n\t\t}\n\t\tid 2 == { [ ##DBDBDB ##525252 pos .z sign 0 1 clamp mix .3 .7 1000 0 0 ] material }\n\t\tid 3 == { pos portal-texture }\n\t\tid 4 == { pos marble-texture }\n\t\tid 5 == { pos hell-texture }\n\t] cond\n;\n\n:m union \\min ;\n:m unionsmooth ( list k ) list \\{ ( a b ) a b k smin-poly } ;\n:m hitunion \\{ ( $a $b ) a b a .x b .x < select } ;\n:m hitunionsmooth ( list k )\n\tlist \\{ ( $a $b )\n\t\ta .x b .x k smin-poly =smin\n\t\t[\n\t\t\tsmin\n\t\t\ta .y b .y a .x smin - abs b .x smin - abs < select\n\t\t]\n\t}\n;\n:m subtract \\{ ( d1 d2 ) d1 neg d2 max } ;\n:m intersect \\max ;\n:m hitintersect \\{ ( $a $b ) a b a .x b .x > select } ;\n:m repeat ( block p c ) p p c mod c 1000 * 0 1 clamp mix 0.5 c * - *block ;\n\n:m sphere ( p s ) p length s - ;\n:m torus ( $p t ) [ p .xy length t .x - p .z ] length t .y - ;\n: box ( p:vec3 b:vec3 -> float )\n\tp abs b - =d\n\td \\max 0 min\n\td 0 max length +\n;\n:m plane ( p n )\n\tp n .xyz dot n .w +\n;\n\n:struct material\n\t@vec3 =color\n\t@float =ambient\n\t@float =diffuse\n\t@float =specular\n\t@float =room\n\t@float =normal-mod\n;\n\n:struct hit\n\t@vec3 =pos\n\t@vec3 =origin\n\t@vec3 =dir\n\t@float =dist\n\t@float =total-dist\n\t@material =mat\n;\n\n:m tx [ _ 0 0 ] + ;\n:m ty [ 0 _ 0 ] + ;\n:m tz [ 0 0 _ ] + ;\n:m get-normal ( p )\n\t[\n\t\tp eps     tx scene .x\n\t\tp eps neg tx scene .x -\n\t\tp eps     ty scene .x\n\t\tp eps neg ty scene .x -\n\t\tp eps     tz scene .x\n\t\tp eps neg tz scene .x -\n\t] normalize\n;\n\n:m lightpos [ 0 room 100 * + 5 5 -1 room 1 - abs mix ] ;\n\n:m shadow-dist 0.1 ;\n\n: get-shadow ( ray:vec3 lpos:vec3 -> float )\n\tlpos ray - normalize =dir\n\tshadow-dist 10 * =dist\n\tlpos ray - length =mdist\n\tfar =lowest\n\t{\n\t\tray dir 2 * dist * + scene =cur\n\t\tlowest cur .x min =lowest\n\t\tdist cur .x abs shadow-dist max + =dist\n\t\t&break cur .x abs shadow-dist < dist mdist >= or when\n\t} 3 times\n\tlowest 0 max 0 shadow-dist .8 ** smoothstep\n;\n\n: ambient-occlusion ( pos:vec3 dir:vec3 cdist:float -> float )\n\tpos dir cdist * + =>npos\n\tnpos scene .x far min =>lowest\n\t0 lowest cdist 1.75 / smoothstep\n;\n\n: apply-fog ( color:vec3 cur:hit dist:float miss:float -> vec3 )\n\t\tcolor\n\t\tcur .origin 1 miss - * cur .dir sky\n\t\tdist cur .total-dist miss mix far fog - - fog / fog-factor * 0 1 clamp\n\tmix\n;\n\n: shade ( cur:hit -> vec3 )\n\tcur .pos =>pos\n\tpos .x 100 / round =room\n\tpos get-normal =normal\n\n\tlightpos =lpos\n\tlpos pos - normalize =ivec\n\tivec normal dot 0 max =incidence\n\tincidence =>diffuse\n\tpos normal cur .dist ambient-occlusion =>ambient\n\n\tcur .mat =>mat\n\n\t0 =specular\n\t{\n\t\t\tivec cur .origin + normalize normal dot\n\t\t\t0\n\t\tmax mat .specular pow\n\t\tlpos pos - length / =specular\n\t} mat .specular 0 != incidence 0 > and when\n\n\tcur .pos lpos get-shadow =shadow\n\n\t\t\tmat .color rgb->hsv1\n\t\t\t\t[ 1 1\n\t\t\t\t\tdiffuse mat .diffuse * shadow *\n\t\t\t\t\tambient mat .ambient * +\n\t\t\t\t\tspecular shadow * +\n\t\t\t\t\tnormal .x abs mat .normal-mod * +\n\t\t\t\t]\n\t\t* hsv1->rgb\n\tcur cur .origin.pos - length 0 apply-fog\n;\n\n:m nullhit\n\t[ ray ray dir far tdist [ 0 vec3 0 0 0 0 0 ] material ] hit\n;\n\n: march ( ray:vec3 dir:vec3 -> hit )\n\tclose =t\n\t0 =tdist\n\t2 =>magic-factor\n\tclose magic-factor * =minstep\n\tfar =last\n\t0 =room\n\t{\n\t\tray dir t * + scene =cur\n\t\t{ nullhit return } cur .x far > when\n\t\t{\n\t\t\t\t{\n\t\t\t\t\tt tdist + =tdist\n\t\t\t\t\t0 =t\n\t\t\t\t\tray 0 3 get-material =mat\n\t\t\t\t\tmat .room =room\n\t\t\t\t\tray [ room 100 * 0 0 ] + =ray\n\t\t\t\t}\n\t\t\t\t&break\n\t\t\tcur .y 3 == if\n\t\t}\n\t\t{\n\t\t\tt cur .x abs minstep + + =t\n\t\t\t{ nullhit return } t far > when\n\t\t\t{\n\t\t\t\tminstep close magic-factor / 3 * + =minstep\n\t\t\t} cur .x last >= room 0 == and when\n\t\t\tcur .x =last\n\t\t} cur .x close close magic-factor / t * + <= if\n\t} 40 times\n\n\tray dir t cur .x + * + =fray\n\n\t[\n\t\tfray\n\t\tray\n\t\tdir\n\t\tcur .x\n\t\ttdist\n\t\tfray cur .x.y get-material\n\t] hit\n;\n\n:m cut-horizon\n\t##000 1 dir .y - 0 1 clamp 2 ** mix\n;\n\n:m clouds ( dir )\n\tdir .xy cart->polar [ 3 7 ] * [ 0 time ] + noise-2d .2 .8 clamp .2 - vec3 cut-horizon\n;\n\n: sky ( origin:vec3 dir:vec3 -> vec3 )\n\torigin .x 100 / round =>room\n\t[\n\t\t0\t##6010C9 ##111438 dir .y 2.5 * mix\n\t\t1\t##FCFFD9 ##9CC5FF dir .y 6 * mix\n\t\t\t##AB1529 ##360B11 dir .y 5 * mix\n\t] room choose\n;\n\n2 =>focus\n:m far 20 ;\n:m fog 14 ;\n:m fog-factor 1.5 ;\n:m close 0.005 ;\n\n: camera-turn ( p:vec3 -> vec3 )\n\ttime 8 - 0 max 3.5 / =v\n\t[ p .xz v 0 1 clamp 1.2 ** v 1 - 0 max + neg rotate-2d p .y ] .xzy\n;\n\n1 time 10 / - 0 1 clamp 3 ** 100 * =>running\n[ 0 .5 -4 running - time 10 - 0 max 4 / sin .1 * + ] camera-turn =origin\n[ 0 .5 -1 ] camera-turn =>ct\n\nresolution frag->position =pos\n\nct origin - normalize =cd\n[ 0 1 0 ] =>cu\ncd cu cross =>cs\ncs pos .x * cu pos .y * + cd focus * + normalize =>dir\n\n:m fade-in ( color )\n\t##fff color time .5 - 2 / 0 1 clamp mix\n;\n\norigin dir march =cur\n\t{ cur shade fade-in ->fragcolor }\n\t{\n\t\t\tcur .origin.dir sky =cursky\n\t\t\t\tcursky\n\t\t\t\tcursky cur far 1 apply-fog\n\t\t\tcur .total-dist far * 1 min mix\n\t\tfade-in ->fragcolor\n\t}\ncur .dist close 10 * < if\n*/\n\nstruct material {\n\tvec3 color;\n\tfloat ambient;\n\tfloat diffuse;\n\tfloat specular;\n\tfloat room;\n\tfloat normal_mod;\n};\nstruct hit {\n\tvec3 pos;\n\tvec3 origin;\n\tvec3 dir;\n\tfloat dist;\n\tfloat total_dist;\n\tmaterial mat;\n};\nfloat scene_noise;\nmaterial get_material(vec3 pos, float dist, float id) {\n\tmaterial temp_1;\n\tif(id == 1.) {\n\t\tfloat fade = clamp(pos.y + .6, 0., 1.);\n\t\ttemp_1 = material(mix(vec3(.47843, .23137, .078431), vec3(.52941, .52941, .52941), fade), .4, .7, mix(1000., 10., fade), 0., -.3);\n\t} else if(id == 2.) {\n\t\ttemp_1 = material(mix(vec3(.85882, .85882, .85882), vec3(.32157, .32157, .32157), clamp(sign(pos.z), 0., 1.)), .3, .7, 1000., 0., 0.);\n\t} else if(id == 3.) {\n\t\ttemp_1 = material(vec3(0., 0., 0.), .5, .5, 0., (sign(pos.z) + 1.) / 2. + 1., 0.);\n\t} else if(id == 4.) {\n\t\ttemp_1 = material(abs(pow(clamp(pos.y - .2, 0., 1.), 2.) - mix(vec3(.85882, .85882, .85882), vec3(.30980, .31373, .32157), abs(scene_noise))), .3, .7, abs(scene_noise) * 100. + .00001, 0., 0.);\n\t} else if(id == 5.) {\n\t\ttemp_1 = material(vec3(.32157, .32157, .32157), .05, .5, 10., 0., 0.);\n\t}\n\treturn temp_1;\n}\nvec3 sky(vec3 origin, vec3 dir) {\n\treturn (floor(origin.x / 100. + .5) == 0. ? mix(vec3(.37647, .062745, .78824), vec3(.066667, .078431, .21961), dir.y * 2.5) : (floor(origin.x / 100. + .5) == 1. ? mix(vec3(.98824, 1., .85098), vec3(.61176, .77255, 1.), dir.y * 6.) : mix(vec3(.67059, .082353, .16078), vec3(.21176, .043137, .066667), dir.y * 5.)));\n}\nvec3 apply_fog(vec3 color, hit cur, float dist, float miss) {\n\treturn mix(color, sky(cur.origin * (1. - miss), cur.dir), clamp((mix(dist, cur.total_dist, miss) - 6.) / 14. * 1.5, 0., 1.));\n}\nfloat pnoise_2d(vec2 v) {\n\tvec4 Pi = mod(floor(v.xyxy) + vec4(0., 0., 1., 1.), 289.);\n\tvec4 Pf = fract(v.xyxy) - vec4(0., 0., 1., 1.);\n\tvec4 gx = fract(mod(((mod((Pi.xzxz * 34. + 1.) * Pi.xzxz, 289.) + Pi.yyww) * 34. + 1.) * (mod((Pi.xzxz * 34. + 1.) * Pi.xzxz, 289.) + Pi.yyww), 289.) / 41.) * 2. - 1.;\n\tvec4 gy = abs(gx) - .5;\n\tgx -= floor(gx + .5);\n\tvec4 norm = inversesqrt(sqrt(gx * gx + gy * gy));\n\tvec2 fade_xy = ((Pf.xy * 6. - 15.) * Pf.xy + 10.) * pow(Pf.xy, vec2(2.));\n\tvec2 n_x = mix(vec2(dot(vec2(gx.x, gy.x) * norm.x, Pf.xy), dot(vec2(gx.z, gy.z) * norm.y, Pf.xw)), vec2(dot(vec2(gx.y, gy.y) * norm.z, Pf.zy), dot(vec2(gx.w, gy.w) * norm.w, Pf.zw)), fade_xy.x);\n\treturn mix(n_x.x, n_x.y, fade_xy.y) * 2.3;\n}\nfloat box(vec3 p, vec3 b) {\n\tvec3 d = abs(p) - b;\n\treturn min(max(max(d.x, d.y), d.z), 0.) + length(max(d, 0.));\n}\nvec2 rotate_2d(vec2 c, float a) {\n\tfloat ca = cos(a);\n\tfloat sa = sin(a);\n\treturn vec2(c.x * ca - c.y * sa, c.y * ca + c.x * sa);\n}\nvec3 hsv1_rgb(vec3 hsv) {\n\treturn mix(vec3(1., 1., 1.), clamp(abs(mod(hsv.x * 6. + vec3(0., 4., 2.), 6.) - 3.) - 1., 0., 1.), hsv.y) * hsv.z;\n}\nfloat smin_poly(float a, float b, float k) {\n\tfloat h = clamp(.5 + .5 * (b - a) / k, 0., 1.);\n\treturn mix(b, a, h) - k * h * (1. - h);\n}\nvec2 scene(vec3 p) {\n\tvec2 temp_17;\n\tfloat room = floor(p.x / 100. + .5);\n\tp -= vec3(room * 100., 0., 0.);\n\tfloat heaven = 1. - abs(sign(room - 1.));\n\tscene_noise = pnoise_2d((p.xz * vec2(1.5, 1.) - vec2(mix(0., -iTime / 1.5, heaven), mix(0., iTime, heaven + 1. - abs(sign(room - 2.))) * mix(1., .3, heaven)) + p.y) * mix(.75, 3. - room, abs(sign(room - 1.))));\n\tif(room == 0.) {\n\t\tvec3 macro_torus_p = (p + vec3(0., 1., 0.) - vec3(0., .6, 0.)) / vec3((1. - (p + vec3(0., 1., 0.)).y) * .05 - 1., 2.5, 2.);\n\t\tvec3 macro_temp_10_rp = mix(p + vec3(0., 1., 0.), mod(p + vec3(0., 1., 0.), vec3(0., 0., 1.)), vec3(0., 0., 1.)) - vec3(0., 0., .5);\n\t\tvec2 macro_temp_13_a = vec2(smin_poly(smin_poly(length(vec2(length(macro_torus_p.xy) - 1., macro_torus_p.z)) - .1, length(p + vec3(0., 1., 0.) + vec3(0., 4.8, 0.)) - 5., 1.25), pnoise_2d((p + vec3(0., 1., 0.)).xz / 2.) / mix(20., 2., clamp(abs((p + vec3(0., 1., 0.)).x / 6.), 0., 1.)) - -(p + vec3(0., 1., 0.)).y, .2), 1.);\n\t\tvec2 macro_temp_13_b = vec2(box(vec3(rotate_2d(macro_temp_10_rp.xz, sin(((p - macro_temp_10_rp).x + (p - macro_temp_10_rp).z) * 13.7) * .5), macro_temp_10_rp.y).xzy, vec3(.4, .1, .4)), 2.);\n\t\tmacro_temp_13_a = (macro_temp_13_a.x < macro_temp_13_b.x ? macro_temp_13_a : macro_temp_13_b);\n\t\tmacro_temp_13_b = vec2(max(length((p + vec3(0., .3, 0.)) / vec3(1., 2.5, 1.)) - 1., box(p, vec3(1., 3., .04))), 3.);\n\t\ttemp_17 = (macro_temp_13_a.x < macro_temp_13_b.x ? macro_temp_13_a : macro_temp_13_b);\n\t} else if(room == 1.) {\n\t\tp = p * vec3(1. + p.z * -.04, 1., 1.) + vec3(0., p.z * .05, 0.);\n\t\tvec3 macro_temp_18_rp = mix(p, mod(p, vec3(2.25, 0., 2.5)), vec3(1., 0., 1.)) - vec3(1.125, 0., 1.25);\n\t\ttemp_17 = vec2(max(smin_poly(dot(p + vec3(0., 1., 0.), vec3(0., 1., 0.)), smin_poly(box(vec3(rotate_2d(macro_temp_18_rp.xz, macro_temp_18_rp.y * -sign(p.x) * 1.5708 + .39270), macro_temp_18_rp.y).xzy + vec3(0., 1., 0.), vec3(.2, 1.5, .2)), length(macro_temp_18_rp - vec3(0., 1.25, 0.)) - .4, .75), .75), box(p - vec3(0., 0., 20.2), vec3(1.5, 20., 20.))), 4.);\n\t} else {\n\t\ttemp_17 = vec2(dot(p + vec3(0., p.z / 4., 0.), vec3(0., 1., 0.)) + 1. + clamp(scene_noise + sin(p.x + (iTime + 1.) * 2.) * .1, -.3, .6) * .4, 5.);\n\t}\n\treturn temp_17 + vec2(scene_noise * .03 * abs(sign(room - 1.)) * abs(sign(temp_17.y - 3.)), 0.);\n}\nfloat get_shadow(vec3 ray, vec3 lpos) {\n\tvec3 dir = normalize(lpos - ray);\n\tfloat dist = 1.0;\n\tfloat mdist = length(lpos - ray);\n\tfloat lowest = 20.;\n\tfor(int temp_27 = 0; temp_27 < 3; ++temp_27) {\n\t\tvec2 cur = scene(ray + dir * 2. * dist);\n\t\tlowest = min(lowest, cur.x);\n\t\tdist += max(abs(cur.x), .1);\n\t\tif(abs(cur.x) < .1 || dist >= mdist) {\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn smoothstep(max(lowest, 0.), 0., .15849);\n}\nhit march(vec3 ray, vec3 dir) {\n\tvec2 cur;\n\tfloat t = .005;\n\tfloat tdist = 0.;\n\tfloat minstep = .010;\n\tfloat last = 20.;\n\tfloat room = 0.;\n\tfor(int temp_28 = 0; temp_28 < 40; ++temp_28) {\n\t\tcur = scene(ray + dir * t);\n\t\tif(cur.x > 20.) {\n\t\t\treturn hit(ray, ray, dir, 20., tdist, material(vec3(0.), 0., 0., 0., 0., 0.));\n\t\t}\n\t\tif(cur.x <= (.005 + .0025 * t)) {\n\t\t\tif(cur.y == 3.) {\n\t\t\t\ttdist += t;\n\t\t\t\tt = 0.;\n\t\t\t\tmaterial mat = get_material(ray, 0., 3.);\n\t\t\t\troom = mat.room;\n\t\t\t\tray += vec3(room * 100., 0., 0.);\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\tt += abs(cur.x) + minstep;\n\t\t\tif(t > 20.) {\n\t\t\t\treturn hit(ray, ray, dir, 20., tdist, material(vec3(0.), 0., 0., 0., 0., 0.));\n\t\t\t}\n\t\t\tif(cur.x >= last && room == 0.) {\n\t\t\t\tminstep += .0075;\n\t\t\t}\n\t\t\tlast = cur.x;\n\t\t}\n\t}\n\tvec3 fray = ray + dir * (t + cur.x);\n\treturn hit(fray, ray, dir, cur.x, tdist, get_material(fray, cur.x, cur.y));\n}\nfloat ambient_occlusion(vec3 pos, vec3 dir, float cdist) {\n\treturn smoothstep(0., min(scene(pos + dir * cdist).x, 20.), cdist / 1.75);\n}\nvec3 camera_turn(vec3 p) {\n\tfloat v = max(iTime - 8., 0.) / 3.5;\n\treturn vec3(rotate_2d(p.xz, -(pow(clamp(v, 0., 1.), 1.2) + max(v - 1., 0.))), p.y).xzy;\n}\nvec3 rgb_hsv1(vec3 rgb) {\n\tvec4 K = vec4(0., -.33333, .66667, -1.);\n\tvec4 p = (rgb.g < rgb.b ? vec4(rgb.bg, K.wz) : vec4(rgb.gb, K.xy));\n\tvec4 q = (rgb.r < p.x ? vec4(p.xyw, rgb.r) : vec4(rgb.r, p.yzx));\n\tfloat d = q.x - min(q.w, q.y);\n\treturn vec3(abs(q.z + (q.w - q.y) / (6. * d + .00001)), d / (q.x + .00001), q.x);\n}\nvec3 shade(hit cur) {\n\tfloat room = floor(cur.pos.x / 100. + .5);\n\tvec3 normal = normalize(vec3(scene(cur.pos + vec3(.00001, 0., 0.)).x - scene(cur.pos + vec3(-.00001, 0., 0.)).x, scene(cur.pos + vec3(0., .00001, 0.)).x - scene(cur.pos + vec3(0., -.00001, 0.)).x, scene(cur.pos + vec3(0., 0., .00001)).x - scene(cur.pos + vec3(0., 0., -.00001)).x));\n\tvec3 lpos = vec3(room * 100., 5., mix(5., -1., abs(room - 1.)));\n\tvec3 ivec = normalize(lpos - cur.pos);\n\tfloat incidence = max(dot(ivec, normal), 0.);\n\tfloat specular = 0.;\n\tif(cur.mat.specular != 0. && incidence > 0.) {\n\t\tspecular = pow(max(dot(normalize(ivec + cur.origin), normal), 0.), cur.mat.specular) / length(lpos - cur.pos);\n\t}\n\tfloat shadow = get_shadow(cur.pos, lpos);\n\treturn apply_fog(hsv1_rgb(rgb_hsv1(cur.mat.color) * vec3(1., 1., incidence * cur.mat.diffuse * shadow + ambient_occlusion(cur.pos, normal, cur.dist) * cur.mat.ambient + specular * shadow + abs(normal.x) * cur.mat.normal_mod)), cur, length(cur.origin - cur.pos), 0.);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec3 origin = camera_turn(vec3(0., .5, -4. - pow(clamp(1. - iTime / 10., 0., 1.), 3.) * 100. + sin(max(iTime - 10., 0.) / 4.) * .1));\n\tvec2 pos = (fragCoord.xy / iResolution.xy * 2. - 1.) * vec2(iResolution.x / iResolution.y, 1.);\n\tvec3 cd = normalize(camera_turn(vec3(0., .5, -1.)) - origin);\n\thit cur = march(origin, normalize(cross(cd, vec3(0., 1., 0.)) * pos.x + vec3(0., 1., 0.) * pos.y + cd * 2.));\n\tif(cur.dist < .050) {\n\t\tfragColor = vec4(mix(vec3(1., 1., 1.), shade(cur), clamp((iTime - .5) / 2., 0., 1.)), 1.);\n\t} else {\n\t\tvec3 cursky = sky(cur.origin, cur.dir);\n\t\tfragColor = vec4(mix(vec3(1., 1., 1.), mix(cursky, apply_fog(cursky, cur, 20., 1.), min(cur.total_dist * 20., 1.)), clamp((iTime - .5) / 2., 0., 1.)), 1.);\n\t}\n}\n","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"4lf3DS","date":"1424626799","viewed":1532,"name":"Limbo -- Unpacked","username":"daeken","description":"My entry for TDF5's GLSL Graphics compo.  This is the original, unpacked version.","likes":23,"published":1,"flags":0,"usePreview":0,"tags":["shaderforth"],"hasliked":0,"parentid":"","parentname":""}}