{"ver":"0.1","info":{"id":"DtBXDt","date":"1676746340","viewed":204,"name":"Gaussian blur w/ R2 curve","username":"clauswilke","description":"Gaussian blur implemented by sampling via a low discrepancy sequence R2. Left: For each output pixel we retrieve N samples displaced by pixel-specific R2 sequence. Right: For each output pixel we retrieve a single sample displaced by global R2 sequence. ","likes":5,"published":3,"flags":0,"usePreview":0,"tags":["2d","noise","blur","lowdiscrepancy","r2curve"],"hasliked":0,"parentid":"dlSXDc","parentname":"2D low discrepancy sequence R2"},"renderpass":[{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Gaussian Blur via 2D Low Discrepancy Sequence\n// Claus O. Wilke, Feb. 2023\n// Licensed CC0, https://creativecommons.org/share-your-work/public-domain/cc0/\n\n// This shader uses the R2 curve described here:\n// http://extremelearning.com.au/unreasonable-effectiveness-of-quasirandom-sequences/\n// See also: https://www.shadertoy.com/view/dlSXDc\n\n// Plastic constant, https://en.wikipedia.org/wiki/Plastic_number\nconst float phi2 = pow((9. + sqrt(69.)) / 18., 1./3.) + pow((9. - sqrt(69.)) / 18., 1./3.); \n\n// Calculate R2 for index i\nvec2 getR2(float i) {\n    // We're using 1 - 1/phi instead of 1/phi for higher precision,\n    // as explained here: https://www.shadertoy.com/view/mts3zN\n    const float C1 = 1. - 1. / phi2;\n    const float C2 = 1. - 1. / (phi2 * phi2);\n\n    return vec2(fract(i * C1), fract(i * C2));\n}\n\n// Taken from: https://www.shadertoy.com/view/Nsjczt by Matt Ebb\n// Modified version of https://www.shadertoy.com/view/WldXR4\n// by TinyTexel\n// License: CC0 (https://creativecommons.org/publicdomain/zero/1.0/)\n\nuint hilbert_idx(uvec2 uv, uint offset)\n{\n    // Hilbert curve:\n    uint C = 0xB4361E9Cu;// cost lookup\n    uint P = 0xEC7A9107u;// pattern lookup\n    \n    uv += uint(offset) * uvec2(2447445397u, 3242174893u);\n    \n    uint c = 0u;// accumulated cost\n    uint p = 0u;// current pattern\n\n    const uint N = 7u;// tile size = 2^N\n    for(uint i = N; --i < N;)\n    {\n        uvec2 m = (uv >> i) & 1u;// local uv\n        uint n = m.x ^ (m.y << 1u);// linearized local uv\n        uint o = (p << 3u) ^ (n << 1u);// offset into lookup tables\n        c += ((C >> o) & 3u) << (i << 1u);// accu cost (scaled by layer)\n        p = (P >> o) & 3u;// update pattern\n    }\n    \n    return c;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    float N = 100.; // number of samples\n    float dmax = 0.02 * (1.01 + sin(0.5 * iTime + 0.5)); // max blur distance\n    float sigma = dmax / 2.5;\n    sigma *= sigma;\n    \n    vec3 col = vec3(0);\n    float weight = 0.;\n    if (uv.x > 0.5) {\n        float idx = mod(float(hilbert_idx(uvec2(fragCoord), 0u)), 100000.);\n        vec2 uvoff = dmax * (getR2(float(idx)) - 0.5);\n        float bw = exp(-dot(uvoff, uvoff) / sigma);\n        col += bw * texture(iChannel0, uv + uvoff).rgb;\n        weight += bw;\n    } else {\n        float idx = mod(float(hilbert_idx(uvec2(fragCoord), 0u)), 100000.);\n        for (float i = 0.; i < N; i++) {\n            vec2 uvoff = dmax * (getR2(idx + i) - 0.5);\n            float bw = exp(-dot(uvoff, uvoff) / sigma);\n            col += bw * texture(iChannel0, uv + uvoff).rgb;\n            weight += bw;\n        }\n    }\n    col /= weight;\n    col *= smoothstep(0.0008, 0.0012, abs(uv.x - 0.5));\n       \n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}