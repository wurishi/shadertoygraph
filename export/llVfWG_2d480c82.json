{"ver":"0.1","info":{"id":"llVfWG","date":"1543946234","viewed":359,"name":"Cookie 2018 NuSan - Round 02","username":"NuSan","description":"Shader made live in 25 minutes during Cookie Demo Party 2018, round 02, semifinals","likes":10,"published":1,"flags":0,"usePreview":0,"tags":["3d","cookie"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGzn","filepath":"/media/a/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3","previewfilepath":"/media/ap/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3","type":"music","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Cookie 2018 NuSan - Round 02\n// Shader made live by NuSan in 25 minutes\n// during Cookie Demo Party 2018 in round 02, semifinals\n// Slightly tweeked as the texture is not the same\n\n#define time iTime\n#define PI 3.1415926535\n\nfloat sph(vec3 p, float r) {\n  return length(p)-r;\n}\n\nfloat cyl(vec2 p, float r) {\n  return length(p)-r;\n}\n\nfloat rnd(float t) {\n\n  return fract(sin(t*425.232)*7423.235);\n}\n\nmat2 rot(float a) {\n  float ca=cos(a);\n  float sa=sin(a);\n  return mat2(ca,sa,-sa,ca);\n}\n\nfloat curve(float t, float d) {\n  float g=t/d;\n  return mix(rnd(floor(g)), rnd(floor(g)+1.0), pow(smoothstep(0.0,1.0,fract(g)),10.0) ); \n}\n\nvec3 tunnel(vec3 p) {\n  float t = p.z * 0.3 + curve(p.z, 2.9) + curve(p.z + 74.0, 0.9) * 0.2;\n  p.x += sin(t) * 0.3 + (curve(p.z+42.0,1.0)-0.5)*0.5;\n  p.y += sin(t*1.7 + 23.0)*0.4;\n  p.xy *= rot(p.z*0.1+curve(time, 0.8)*10.1);\n  return p;\n}\n\nfloat map(vec3 p) {\n\n  p = tunnel(p);\n\n  vec3 rp = vec3(atan(p.x,-p.y)*PI, length(p.xy), p.z);\n\n  float j = 2.1 + curve(p.z, 2.9)*2.0;\n  float t = texture(iChannel0, rp.xz*vec2(0.2,1.0)*0.2).x;\n  float a = -cyl(p.xy,j);\n  \n  float c = t + 1.0-cyl(p.xy, 0.9); \n\n  return min(a, min(c, -p.y+1.4 +t*0.3));\n}\n\nvec3 norm(vec3 p) {\n  float base=map(p);\n  vec2 off=vec2(0.01,0);\n  return normalize(vec3( base-map(p-off.xyy), base-map(p-off.yxy), base-map(p-off.yyx) ));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n  uv -= 0.5;\n  uv /= vec2(iResolution.y / iResolution.x, 1);\n\n  vec3 ro = vec3(0,0,-3);\n  vec3 rd = normalize(vec3(-uv, 1));\n\n  ro.z += time * 4.0;\n  ro = tunnel(ro);\n\n  vec3 p = ro;\n  float dd=0.0;\n  float at = 0.0;\n  for(int i=0; i<100; ++i) {\n    float d = map(p);\n    if(d<0.001) {\n      break;\n    }\n    p+=rd*d*0.5;\n    dd+=d * 0.5;\n    at += exp(-d);\n  }\n\n  vec3 n = norm(p);\n  vec3 l = normalize(vec3(-1));\n  vec3 h = normalize(l-rd);\n  float lum = max(0.0, dot(l,n));\n\n  vec3 col = vec3(0);\n  col += vec3(0.8,0.7,0.2) * lum;\n  col += vec3(0.8,0.7,1.0) * 0.3 * lum * pow(max(0.0, dot(n,h)), 10.0);\n  col += vec3(0.2,0.3,0.7) * 0.02 * at;\n\n  col += vec3(1,0.5,0.3) * 0.1 * exp(dd*0.1) * (1.0 + curve(time+7.0,0.2)) * 1.0;\n\n  float t1 = time + curve(time+2.0,.9) - length(uv) ;\n  col.xy *= rot(t1);\n  col.yz *= rot(t1*1.2);\n\n  col = abs(col);\n\n  col *= 3.0/dd;\n\n  \n\n  fragColor = vec4(col, 1);\n}","name":"Image","description":"","type":"image"}]}