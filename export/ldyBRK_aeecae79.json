{"ver":"0.1","info":{"id":"ldyBRK","date":"1529504280","viewed":209,"name":"Domain warping by using fbm(fbm)","username":"vchizhov","description":"Testing domain warping based on https://iquilezles.org/articles/warp/warp.htm.\nThe coloring is based on the normals.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["procedural","3d","raymarching","noise","distancefield","fbm"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n\n// I recommend cubic:\n\n// type of smoothstep to use:\n// 0: no smoothstep - linear\n// 1: cubic smoothstep\n// 2: quintic smoothstep\n#define SMOOTHSTEP_TYPE 1\n\n\n// I recommend numerical:\n\n// 0 - numerical, 1 - analytical\n#define ANALYTICAL_NORMALS 0\n\n\n\n// I recommend fibonacci, I believe the worst is the density coloring,\n// since it takes samples only along the normal:\n\n// 0 - fibonacci\n// 1 - density coloring\n// 2 - actual ao\n// 3 - crytek ao\n#define AO_TYPE 0\n\n\n\n//////////////////////////////////////////////////////////\n//\t\t\t\t\t\tNOISE\t\t\t\t\t\t\t//\n//////////////////////////////////////////////////////////\n\n\n\n// hashes\nfloat hash( float n ) { return fract(sin(n)*63724.12379f); }\n\n// 3d hash\nfloat hash3(vec3 p)\n{\n    // turn 3d integer coorindtes into scalar seed\n    // note: 137 and 197 are both prime numbers\n    float n = p.x + p.y*197.0f + 137.0f*p.z;\n    return hash(n);\n}\n\n\n/*\n\tComputes 3d value noise at point p\n\t\n\t@param p:\tpoint in 3d space\n\n\t@return: \tvalue noise at p\n\n*/\nfloat noise3D(in vec3 p)\n{\n    vec3 whole = floor(p);\n    vec3 fractional = p - whole;\n    vec3 u = fractional;\n    \n    // cubic smoothstep\n    #if SMOOTHSTEP_TYPE == 1\n    // https://en.wikipedia.org/wiki/Smoothstep\n    // 3*x^2 - 2*x^3\n    u = u*u*(3.0f-2.0f*u);\n    #endif\n    // quintic smoothstep\n    #if SMOOTHSTEP_TYPE == 2\n    // https://en.wikipedia.org/wiki/Smoothstep\n    // 6*x^5 - 15*x^4 + 10*x^3\n    u = u*u*u*(u*(6.0f*u-15.0f)+10.0f);\n    #endif\n    \n    // the 8 grid points\n    float a_x0y0z0 = hash3(whole);\n    float a_x1y0z0 = hash3(whole+vec3(1.0f,0.0f,0.0f));\n    float a_x0y1z0 = hash3(whole+vec3(0.0f,1.0f,0.0f));\n    float a_x0y0z1 = hash3(whole+vec3(0.0f,0.0f,1.0f));\n    float a_x1y1z0 = hash3(whole+vec3(1.0f,1.0f,0.0f));\n    float a_x1y0z1 = hash3(whole+vec3(1.0f,0.0f,1.0f));\n    float a_x0y1z1 = hash3(whole+vec3(0.0f,1.0f,1.0f));\n    float a_x1y1z1 = hash3(whole+vec3(1.0f,1.0f,1.0f));\n    // the coefficients of the trillinear interpolation polynomial\n    float c_1 = a_x0y0z0;\n    float c_x = a_x1y0z0-a_x0y0z0;\n\tfloat c_y = a_x0y1z0-a_x0y0z0;\n\tfloat c_z = a_x0y0z1-a_x0y0z0;\n\tfloat c_xy = a_x1y1z0 - a_x0y1z0 - a_x1y0z0 + a_x0y0z0;\n\tfloat c_xz = a_x1y0z1 - a_x0y0z1 - a_x1y0z0 + a_x0y0z0;\n\tfloat c_yz = a_x0y1z1 - a_x0y0z1 - a_x0y1z0 + a_x0y0z0;\n\tfloat c_xyz = a_x1y0z0 - a_x0y0z0 + a_x0y1z0 - a_x1y1z0 + a_x0y0z1 - a_x1y0z1 - a_x0y1z1 + a_x1y1z1;\n    // the value noise at point p:\n    float val = c_1 \n        + c_x*u.x + c_y*u.y + c_z*u.z \n        + c_xy*u.x*u.y + c_xz*u.x*u.z + c_yz*u.y*u.z \n        + c_xyz*u.x*u.y*u.z;\n    \n    return val;\n}\n\n/*\n\tComputes 3d value noise along with the analytical gradient at point p\n\t\n\t@param p:\tpoint in 3d space\n\n\t@return: \t4d vector, such that x = valueNoise, yzw = derivative\n\n*/\nvec4 dNoise3D(in vec3 p)\n{\n    vec3 whole = floor(p);\n    vec3 fractional = p - whole;\n    vec3 u = fractional;\n    vec3 du = vec3(1.0f);\n    \n     // cubic smoothstep\n    #if SMOOTHSTEP_TYPE == 1\n    // https://en.wikipedia.org/wiki/Smoothstep\n    // 3*x^2 - 2*x^3\n    u = u*u*(3.0f-2.0f*u);\n    // derivative: du = 6*x - 6*x^2\n    du = 6.0f*u*(1.0f-u);\n    #endif\n    // quintic smoothstep\n    #if SMOOTHSTEP_TYPE == 2\n    // https://en.wikipedia.org/wiki/Smoothstep\n    // 6*x^5 - 15*x^4 + 10*x^3\n    u = u*u*u*(u*(6.0f*u-15.0f)+10.0f);\n    // 30*x^4-60*x^3+30*x^2\n    du = 30.0f*u*u*(u*(u-2.0f) + 1.0f);\n    #endif\n   \n    // the 8 grid points\n    float a_x0y0z0 = hash3(whole);\n    float a_x1y0z0 = hash3(whole+vec3(1.0f,0.0f,0.0f));\n    float a_x0y1z0 = hash3(whole+vec3(0.0f,1.0f,0.0f));\n    float a_x0y0z1 = hash3(whole+vec3(0.0f,0.0f,1.0f));\n    float a_x1y1z0 = hash3(whole+vec3(1.0f,1.0f,0.0f));\n    float a_x1y0z1 = hash3(whole+vec3(1.0f,0.0f,1.0f));\n    float a_x0y1z1 = hash3(whole+vec3(0.0f,1.0f,1.0f));\n    float a_x1y1z1 = hash3(whole+vec3(1.0f,1.0f,1.0f));\n    // the coefficients of the trillinear interpolation polynomial\n    float c_1 = a_x0y0z0;\n    float c_x = a_x1y0z0-a_x0y0z0;\n\tfloat c_y = a_x0y1z0-a_x0y0z0;\n\tfloat c_z = a_x0y0z1-a_x0y0z0;\n\tfloat c_xy = a_x1y1z0 - a_x0y1z0 - a_x1y0z0 + a_x0y0z0;\n\tfloat c_xz = a_x1y0z1 - a_x0y0z1 - a_x1y0z0 + a_x0y0z0;\n\tfloat c_yz = a_x0y1z1 - a_x0y0z1 - a_x0y1z0 + a_x0y0z0;\n\tfloat c_xyz = a_x1y0z0 - a_x0y0z0 + a_x0y1z0 - a_x1y1z0 + a_x0y0z1 - a_x1y0z1 - a_x0y1z1 + a_x1y1z1;\n    // the value noise at point p:\n    float val = c_1 \n        + c_x*u.x + c_y*u.y + c_z*u.z \n        + c_xy*u.x*u.y + c_xz*u.x*u.z + c_yz*u.y*u.z \n        + c_xyz*u.x*u.y*u.z;\n    \n    // the partial derivatives of the interpoaltion with respect to u.x, u.y and u.z\n    // dxVal = d[val]/du.x, dyVal = d[val]/du.y, dzVal = d[val]/du.z\n    float duxVal = c_x + c_xy*u.y + c_xz*u.z + c_xyz*u.y*u.z;\n    float duyVal = c_y + c_xy*u.x + c_yz*u.z + c_xyz*u.x*u.z;\n    float duzVal = c_z + c_yz*u.y + c_xz*u.x + c_xyz*u.x*u.y;\n    // the gradient (partial derivatives with respect to x,y,z -> use the chain rule:\n    // dxVal = d[val]/dx = d[val]/du.x * du.x / dx = duxVal * du.x\n    // dyVal = d[val]/dy = d[val]/du.y * du.y / dy = duyVal * du.y\n    // dzVal = d[val]/dz = d[val]/du.z * du.z / dz = duzVal * du.z\n    // gradient = vec3(d[val]/dx, d[val]/dy, d[val]/dz)\n    vec3 gradient = du*vec3(duxVal,duyVal,duzVal);\n    \n    return vec4(val, gradient);\n}\n///////////////////////////////////////////////////////////////////////\n\n// rotation matrix\n\nconst mat3 m = mat3( 0.00,  0.80,  0.60,\n                    -0.80,  0.36, -0.48,\n                    -0.60, -0.48,  0.64 );\n\nconst mat3 mTransp = mat3( 0.00,  -0.80,  -0.60,\n                    0.80,  0.36, -0.48,\n                    0.60, -0.48,  0.64 );\n\n\n/*\nconst mat3 m = mat3( 1.00,  0.0,  0.0,\n                    0.0,  1.0, 0.0,\n                    0.0, 0.0,  1.0 );\n\nconst mat3 mTransp = mat3( 1.00,  0.0,  0.0,\n                    0.0,  1.0, 0.0,\n                    0.0, 0.0,  1.0 );\n*/\n\n\nconst int fbmNumLayers = 8;\nconst float fbmFrequencyMultiplier = 2.0f;\nconst float fbmAmplitudeMultiplier = 0.5f;\nconst vec3 fbmInitialDisplacement = vec3(1.0f,0.0f,0.8f);\n\n// the fbm3D\nfloat displacement(vec3 p)\n{\n    // initial translation - not necessarily important\n    p += fbmInitialDisplacement;\n\n    float amplitude = 1.0f;\n    float frequency = 1.0f;\n    float val = 0.0f;\n    // and unrolled loop with 4 iterations:\n    for(int i=0;i<fbmNumLayers;++i)\n    {\n        amplitude *= fbmAmplitudeMultiplier;\n        p = fbmFrequencyMultiplier*m*p;\n        //frequency *= frequencyMultiplier;\n        val += amplitude*noise3D(p);\n    }\n    \n    return val;\n}\n\n// the fbm3D along with the gradient\nvec4 dDisplacement(vec3 p)\n{\n    // initial translation - not necessarily important\n    p += fbmInitialDisplacement;\n\n\n    float amplitude = 1.0f;\n    \n    float val = 0.0f;\n    vec3 gradient = vec3(0.0f);\n    mat3 ma = mat3(1.0f, 0.0f, 0.0f, \n                   0.0f, 1.0f, 0.0f, \n                   0.0f, 0.0f, 1.0f);\n    // and unrolled loop with 4 iterations:\n    for(int i=0;i<fbmNumLayers;++i)\n    {\n        amplitude *= fbmAmplitudeMultiplier;\n        p = fbmFrequencyMultiplier*m*p;\n        ma = fbmFrequencyMultiplier*mTransp*ma;\n        \n        vec4 noiseAndGradient = dNoise3D(p);\n        \n        val += amplitude*noiseAndGradient.x;\n        gradient += amplitude*ma*noiseAndGradient.yzw;\n    }\n\n    return vec4(val, gradient);\n}\n\n\n\n\n\n\n//////////////////////////////////////////////////////////\n//\t\t\t\t\t\tTERRAIN\t\t\t\t\t\t\t//\n//////////////////////////////////////////////////////////\n\n\n// there is an intrinsic function in glsl for this\n// this is just the implementation\nfloat smoothstepMine(float a, float b, float x)\n{\n    float t = clamp((x - a) / (b - a), 0.0f, 1.0f);\n    return t * t * (3.0f - 2.0f * t);\n}\n\n// derivative of the smoothstep function\nfloat dSmoothstepMine(float a, float b, float x)\n{\n    float zero = (x<a || x>b)? 0.0f : 1.0f;\n    float t = clamp((x - a) / (b - a), 0.0f, 1.0f);\n    float dt = 1.0f/(b-a);\n    return zero * 6.0f*t*(1.0f - t) * dt; \n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\nconst float bboxScale = 1.0f;\nconst vec3 bboxMin = vec3(-bboxScale);\nconst vec3 bboxMax = vec3(bboxScale);\n\n// the field function\nfloat mapTerrain( in vec3 pos )\n{\n    // the scale of your terrain: how stretched/squeezed it is\n    vec3 frequency = vec3(0.8f,1.0f,0.8f);\n    \n    // evaluate the fbm\n    //float fbmVal = displacement(pos*frequency);\n    float fbmVal = displacement(vec3(displacement(pos*frequency), \n                                     displacement(vec3(174.0f, 23.0, 1.0) +\n                                                  pos*frequency),\n                                     displacement(vec3(-123.9, 12801.0, -33.0) +\n                                                  pos*frequency)));\n    \n    // additive factor to the noise: -0.4 makes it denser\n    // by a constant (0.4) everywhere\n    float addFactor = -0.3f;\n    \n    // refer to: https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/smoothstep.xhtml\n    // the higher you go, the lower the density becomes:\n    // for pos.y >= 3.0 -> 0, for pos.y<=1.0 -> 1\n    float altitudeAttenuation = 1.0f-smoothstepMine(-1.0f,3.0f,pos.y);\n    \n    // additional linear attenuation:\n    // linearly attenuates the density with altitude\n    float linearAddY = pos.y*0.1f;\n    \n    float fieldVal = linearAddY + (fbmVal + addFactor)*altitudeAttenuation;\n    float airBox = max(0.0f, sdBox(pos,vec3(0.9f)));\n    float composite = max(airBox, fieldVal);\n    \n    // all of these combined:\n\treturn composite;\n}\n\n// the field function with the gradient\nvec4 dMapTerrain( in vec3 pos )\n{\n    // the scale of your terrain: how stretched/squeezed it is\n    vec3 frequency = vec3(0.8f,1.0f,0.8f);\n    \n    // evaluate the fbm\n    vec4 fbmValAndGradient = dDisplacement(pos*frequency);\n    fbmValAndGradient.yzw *= frequency;\n    \n    // additive factor to the noise: -0.4 makes it denser\n    // by a constant (0.4) everywhere\n    float addFactor = -0.4f;\n    \n    // refer to: https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/smoothstep.xhtml\n    // the higher you go, the lower the density becomes:\n    // for pos.y >= 3.0 -> 0, for pos.y<=1.0 -> 1\n    float altitudeAttenuation = 1.0f-smoothstepMine(1.0f,3.0f,pos.y);\n    \n    \n    //the altitude is only a function of y, then then it can be treated\n    // as a constant for the x and z partial derivatives,\n    // for dy however, we must compute the partial derivative\n    float dyAltitudeAttenuation = -dSmoothstepMine(1.0f, 3.0f, pos.y);\n    \n    // additional linear attenuation:\n    // linearly attenuates the density with altitude\n    float linearAddYFactor = 0.1f;\n    float linearAddY = pos.y*linearAddYFactor;\n    \n    // once again, this is a function of y, then \n    // for x and z it can be treated as a constant\n    // for y however the derivative must be computed\n    float dyLinearAddY = linearAddYFactor;\n    \n    // all of these combined:\n    float val = linearAddY + (fbmValAndGradient.x + addFactor)*altitudeAttenuation;\n    vec3 gradient = vec3(\n    fbmValAndGradient.y*altitudeAttenuation, \n    dyLinearAddY + fbmValAndGradient.z*altitudeAttenuation + (fbmValAndGradient.x+addFactor)*dyAltitudeAttenuation,\n    fbmValAndGradient.w*altitudeAttenuation\n        );\n        \n\treturn vec4(val, gradient);\n}\n\n\n\n// matches along a ray with origin ro, and direction rd (normalized)\n// the ray is evaluated along the line [ro+rd*mint. ro+rd*maxt]\nfloat raymarchTerrain( in vec3 ro, in vec3 rd, in float mint, in float maxt )\n{\n    // starting t (a small offset to avoid self intersection\n    float t = mint;\n    float lasth = 0.1f;\n    // take 256 steps along the ray\n    int i = 0;\n    for(; i<256; i++ )\n    {\n        vec3 pos = ro+rd*t;\n        \n\n        if(any(lessThan(pos,bboxMin)) || any(greaterThan(pos,bboxMax)))\n        {\n            t+=lasth;\n        }\n        else\n        {\n            // compute the density at point ro+rd*t\n        \tfloat h = mapTerrain( ro+rd*t );\n            lasth = h;\n            // if the density is smaller than 0.001f*t (close to 0) \n            // then there is an intersection, since the field is negative \n            // on the inside, the multiplication with t serves as a LOD\n            // the further away the intersection is, the coarser it can be\n            // if t>maxt, we didn't hit anything\n            if( h<(0.001f*t) || t>maxt ) break;\n            // take steps depending on the density, if h is big, then the\n            // field is not very dense there, so we can take larger steps\n            // since we assume that the field is smooth, so it can't become\n            // negative from highly positive with a small step\n            // we're basically using the Lipschitz constant here\n            // which tells us |f(x)-f(x+delta)|<=L*|delta|\n        \tt += h*0.8f;\n        }\n        \n            \n    }\n\n    // if the iterations ended without hitting anyting:\n    // return a negative distance\n    if( t>maxt || i==256) t=-1.0;\n    return t;\n}\n\n// numerical normal estimation\nvec3 calcNormal( in vec3 pos, in float t )\n{\n    #if ANALYTICAL_NORMALS == 1\n    \treturn normalize(dMapTerrain(pos).yzw);\n    \n    #else\n    // the farther away we are - the more smoother normal we should take\n    vec3 eps = vec3( max(0.02f,0.001f*t),0.0f,0.0f);\n\treturn normalize( vec3(\n           mapTerrain(pos+eps.xyy) - mapTerrain(pos-eps.xyy),\n           mapTerrain(pos+eps.yxy) - mapTerrain(pos-eps.yxy),\n           mapTerrain(pos+eps.yyx) - mapTerrain(pos-eps.yyx) ) );\n    #endif\n\n}\n\n\n\n//////////////////////////////////////////////////////////\n//\t\t\t\tYou don't need this\t\t\t\t\t\t//\n//////////////////////////////////////////////////////////\n// setup camera coordinate system from origin, target and rotation\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0f);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\n\n\n\n//////////////////////////////////////////////////////////\n//\t\t\t\t\t\tAO\t\t\t\t\t\t\t//\n//////////////////////////////////////////////////////////\n\n\n// fibonacci points in a sphere, more info:\n// https://mribar03.bitbucket.io/articles/2013/CGF_SF.pdf\nvec3 forwardSF( float i, float n) \n{\n    const float PI  = 3.141592653589793238;\n    const float PHI = 1.618033988749894848;\n    float phi = 2.0*PI*fract(i/PHI);\n    float zi = 1.0 - (2.0*i+1.0)/n;\n    float sinTheta = sqrt( 1.0 - zi*zi);\n    return vec3( cos(phi)*sinTheta, sin(phi)*sinTheta, zi);\n}\n\n\nvec3 exitField(vec3 pos, vec3 nor)\n{\n    int steps = 10;\n    // initial offset\n    const float mint = 0.00f;\n    // maximum offset distance\n    const float maxt = 0.1f;\n    float delta = maxt / float(steps);\n    for(int i=0;i<steps;++i)\n    {\n        float fieldVal = mapTerrain(pos);\n        if(fieldVal>0.0f)\n        {\n            return pos;\n        }\n        pos += delta*nor;\n    }\n    return pos;\n}\n\n// samples the inside the hemisphere above pos\nfloat ao0( in vec3 pos, in vec3 nor )\n{\n    pos = exitField(pos,nor);\n\tfloat ao = 0.0;\n    // number of samples\n    const int aoSamples = 32;\n    for( int i=0; i<aoSamples; i++ )\n    {\n        // find fibonacci point i\n        vec3 ap = forwardSF( float(i), float(aoSamples) );\n        // randomize, returns [0,1)\n        float h = hash(float(i));\n        // radius of the hemisphere - generally, the smaller this is - the darker\n        float samplingRadius = 0.15f;\n        // if the sampled point is in the opposite hemisphere with regards\n        // to the normal - flip it\n\t\tap *= sign( dot(ap,nor) ) *h*samplingRadius;\n        \n        // controls the local brightness per hemisphere sample\n        float brightness = 3.0f;\n        \n        \n        // nor*0.001 gives a small offset to avoid self-intersection\n        // pos+nor*0.001+ap gives a point in the upper hemisphere with regards\n        // to the normal, mapTerrain returns a negative number if this is\n        // inside an object -> 0 light from this sample\n        // if the sample is near an object (the 0.0<density<1.0f/brightness) then some occlusion\n        // is returned, if the object is farther away (density>1.0f/brightness)\n        ao += clamp( mapTerrain( pos + nor*0.001 + ap )*brightness, 0.0, 1.0 );\n    }\n\tao /= float(aoSamples);\n\t\n    // controls the global brightness per point\n    float globalBrightness = 5.0f;\n    return clamp( ao*globalBrightness, 0.0, 1.0 );\n}\n\n\n\n\n\n// the ambient occlusion that requires a distance field\nfloat ao1(vec3 p, vec3 n){\n    const int aoSteps = 16;\n    \n    // step size along the ray - make larger to make darker\n    const float delta = 1.5f;\n\n    // accumulate occlusion\n    float a = 0.0f;\n    // how dark objects in close proximty become\n    float weight = 1.0f;\n    // how fast the weight falls off with distance (object farther away\n    // throw softer shadows) - make lower to make exponentially brighter\n    float weightAtt = 0.5f;\n\n    for(int i=1; i<=aoSteps; i++) {\n        // move distance d along the normal\n        float d = (float(i) / float(aoSteps)) * delta; \n        // compute the difference of the distance to the object\n        // minus the distance to the closest object\n        // this obviously requires a distance field\n        \n        // for a density field, this amounts to taking samples \n        // only along the normal\n        // if inside an object, we get d - -density = d+density\n        // so the further away we move along the normal, the lower the density\n        // that we expect (lower denisty in this case is actually higher mapTerrain\n        // value, since the inside is negative).\n        a += weight*(d - mapTerrain(p + n*d));\n        // for samples further away, make the occlusion weight lower\n        weight *= weightAtt;\n    }\n    // we want % of incoming light, and we have % of occluded light,\n    // do 100% - a\n    return clamp(1.0f - a, 0.0f, 1.0f);\n}\n\n\n// This part is for the vanilla ao:\n\n// a hashing function for the AO, helps to pick \"pseudo-random directions for AO\nfloat hashAO(float seed)\n{\n    return fract(sin(seed)*43758.5453f );\n}\n\n// matches along a ray with origin ro, and direction rd (normalized)\n// the ray is evaluated along the line [ro+rd*mint. ro+rd*maxt]\nfloat raymarchTerrainAO( in vec3 ro, in vec3 rd, in float mint, in float maxt )\n{\n    const int aoSteps = 1;\n    // starting t (a small offset to avoid self intersection\n    float t = mint;\n    float delta = (maxt - mint)/float(aoSteps);\n    // take \n    for( int i=0; i<aoSteps; i++ )\n    {\n        // compute the density at point ro+rd*t\n\t    float h = mapTerrain( ro+rd*t );\n        // if the density is smaller than 0.001f*t (close to 0) \n        // then there is an intersection, since the field is negative \n        // on the inside, the multiplication with t serves as a LOD\n        // the further away the intersection is, the coarser it can be\n        \n        // if t>maxt, we didn't hit anything\n        if( h<0.001f) return t;\n        \n        t += delta;\n    }\n    // didn't hit anything\n    return -1.0f;\n}\n\nfloat ao2(in vec3 p, in vec3 n)\n{\n    float aoRadius = 0.3f;\n    const int aoSamples = 4;\n    // this abomination is only necessary if you don't have random()\n    float seed = hashAO( dot( p.xy*p.yz, vec2(12.9898f, 78.233f)+float(iTime) ) );\n    float occ = 0.0f;\n    // integration of the hemisphere - we take AO_SAMPLES number of samples\n    for(int k=1;k<aoSamples;++k)\n    {\n        // in your implementation u and v would look like this:\n        // u = random();\n        // v = random();\n        // the abomination you see here is because this is glsl code:\n        float u = hashAO( 78.233f + seed + float(k)*92.13f);\n    \tfloat v = hashAO( 10.873f + seed + float(k)*35.00f);\n        //float u = textureLod( iChannel0, vec2(float(k)/float(AO_SAMPLES)), 0.0).x;\n        //float v = textureLod( iChannel0, vec2(float(k)/float(AO_SAMPLES)), 0.0).y;\n        \n        // the next part generates a cosine distributed direction in the upper hemisphere\n        // given a normal, ofr more information: http://amietia.com/lambertnotangent.html\n        // you can simply use your code from the homework - you don't need to use this one\n        // it's just good since it doesn't require you to build a coordinate frame\n        float a = 6.2831853f * v;\n        u = 2.0f*u - 1.0;\n        vec3 dir = normalize(n + vec3(sqrt(1.0f-u*u) * vec2(cos(a), sin(a)), u));\n        // note that since I generate a cosine distributed direction,\n        // the pdf is = cos(theta)/pi\n        // we want to find the visibility integral from here:\n        // https://en.wikipedia.org/wiki/Ambient_occlusion\n        // the cosine term cancel out, with the pdf, also the pi from the pdf cancels out\n        // with the 1/pi in front of the integral from the wikipedia article\n        \n        // this is the part where you check whether this ray intersects anything \n        // in a given radius - if it does - increment the occlusion count\n        // if it doesn't - do nothing\n        float offset = 0.04f;\n    \tif(raymarchTerrain(p,dir,offset,aoRadius)>0.0f)\n        {\n            ++occ;\n        }\n    }\n    // occ/AO_SAMPLES would be the occlusion\n    // I want the oposite, so I subtract it from 1\n    return 1.0f-occ/float(aoSamples);\n}\n\nvec3 forwardSF1( float i, float n, float seed) \n{\n    const float PI  = 3.141592653589793238;\n    const float PHI = 1.618033988749894848;\n    float phi = 2.0*PI*fract(i/PHI+seed);\n    float zi = 1.0 - (2.0*i+1.0)/n;\n    float sinTheta = sqrt( 1.0 - zi*zi);\n    return vec3( cos(phi)*sinTheta, sin(phi)*sinTheta, zi);\n}\n\nfloat ao3(vec3 pos, vec3 nor)\n{\n \n    const int samples = 32;\n    int count = 0;\n    float radius = 1.0f;\n    float threshold = 0.15f;\n    float h = hash3(pos);\n    for(int i=0;i<samples;++i)\n    {\n        vec3 ap = radius*forwardSF1(float(i), float(samples), h);\n        ap *= dot(ap,nor)<0.0f? -1.0f : 1.0f;\n    \tif (mapTerrain(pos+ap) < threshold) {count++;}\n    }\n \n    return float(count)/float(samples);\n}\n\n\n// modified crytek ao to use fibonnaci points\n// it additionally flips negative samples\nfloat ao5(vec3 pos, vec3 nor)\n{\n    pos = pos;//exitField(pos, nor);\n\tint countInside = 0;\n    // make larger to make darker\n    const float threshold = 0.02f;\n    // number of samples\n    const int aoSamples = 32;\n    for( int i=0; i<aoSamples; i++ )\n    {\n        // find fibonacci point i\n        vec3 ap = forwardSF( float(i), float(aoSamples) );\n        // randomize, returns [0,1)\n        float h = 1.0f;//hash(float(i));\n        // radius of the hemisphere - generally, the smaller this is - the darker\n        float samplingRadius = 0.3f;\n        // if the sampled point is in the opposite hemisphere with regards\n        // to the normal - flip it\n\t\tap *= sign( dot(ap,nor) ) *h*samplingRadius;\n       \n        // if the sample is inside count it\n        if(mapTerrain( pos+ ap )<threshold)\n        {\n            ++countInside;\n        }\n    }\n\tfloat ao = float(aoSamples-countInside)/float(aoSamples);\n\t\n    // controls the global brightness per point\n    float globalBrightness = 1.0f;\n    return clamp( ao*globalBrightness, 0.0, 1.0 );\n}\n\n// doesn't work at the moment\n// curvature based coloring \"ambient occlusion\"\nfloat ao4(vec3 pos, vec3 nor)\n{\n    // build an orhtonormal coord system from the normal\n    // http://jcgt.org/published/0006/01/01/paper.pdf\n    float ks = (nor.z>=0.0)?1.0:-1.0;     \n    float ka = 1.0 / (1.0 + abs(nor.z));\n    float kb = -ks * nor.x * nor.y * ka;\n    vec3 uu = vec3(1.0 - nor.x * nor.x * ka, ks*kb, -ks*nor.x);\n    vec3 vv = vec3(kb, ks - nor.y * nor.y * ka * ks, -nor.y);\n    \n    float offset = 0.001f;\n    vec4 dTdu = dMapTerrain(pos + uu*offset);\n    vec4 dTdv = dMapTerrain(pos + vv*offset);\n    return 0.0f;\n}\n\n\n// lighting direction\nvec3 lig = normalize( vec3(0.0f, 1.0f, 0.0f) );\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // You don't care about this stuff:\n    \n    \n    // per-pixel stuff\n    vec2 q = fragCoord.xy / iResolution.xy;\n\tvec2 p = -1.0f + 2.0f*q;\n\tp.x *= iResolution.x / iResolution.y;\n\t\n    vec3 ro, ta; float cr, fl;\n    // camera center\n    float mz = 2.0f*iMouse.x/iResolution.x-1.0f;\n    float ms = 3.0f;\n    ro = vec3(1.5f*sin(mz*ms), 0.0f, 1.5f*cos(mz*ms));\n    // camera target\n    ta = vec3(0.0f, 0.0f, 0.0f);\n    // controls how tilted the camera is (in radians)\n    cr = 0.0f;\n    // controls the field of view\n    fl = 1.0f;\n\t// camera2world transform\n    mat3 cam = setCamera(ro, ta, cr);\n    vec3 rd = cam*normalize(vec3(p.xy, fl));\n    \n    \n    \n    // You care about this stuff for coloring:\n    vec3 col = vec3(0.0f);\n    // terrainintersection\n\tfloat t = raymarchTerrain(ro, rd, 0.1f, 30.0f);\n    if( t>0.0 )\n\t{\n        // intersection point\n\t\tvec3 pos = ro + t*rd;\n\t\tvec3 nor = calcNormal( pos, t );\n\n\t\tnor = normalize( nor );\n\t\t\n        // becomes darker with lower altitude\n\t\tfloat hh = smoothstep( -1.0f, 1.0f, pos.y );\n        \n\t\t//col = vec3(0.8);\n        //\n        float dirL = max(0.0f, dot(nor, lig));\n        float occ = 0.0f;\n        #if AO_TYPE == 0\n        occ = ao0(pos, nor);\n        #endif\n        #if AO_TYPE == 1\n        occ = ao1(pos, nor);\n        #endif\n        #if AO_TYPE == 2\n        occ = ao2(pos, nor);\n        #endif\n        #if AO_TYPE == 3\n        occ = ao3(pos, nor);\n        #endif\n        float wOcc = 1.0f;\n        float wDirL = 1.0f-wOcc;\n        float wBac = 0.3f;\n        col = vec3(wOcc*occ+wDirL*dirL)*sqrt(hh);\n        col *= vec3(abs(nor.x+nor.z), nor.y,0.0f);\n    }\n\n    fragColor = vec4( sqrt(col), 1.0 );\n}\n","name":"Image","description":"","type":"image"}]}