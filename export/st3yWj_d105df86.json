{"ver":"0.1","info":{"id":"st3yWj","date":"1660537595","viewed":171,"name":"UwU","username":"Wabrion","description":"uwu","likes":9,"published":1,"flags":0,"usePreview":0,"tags":["tile","tiles","uwu"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define AA 2\n#define ORTOGRAPHIC 01\n#define RECT_SIZE 9.0\n\n#define ZOOM 1.5\n#define ONLY_UwU 01\n\nfloat idFace = 0.0;\n\nfloat scene(in vec3 p) {\n\n\tp -= vec3(0, 0, 3);\n\tp = rotate(p, vec3(0, 0.7*iTime, 0));\n\tp += vec3(0, 0, 3);\n\n\tp -= vec3(0, 0, 3);\n\tp = rotate(p, vec3(0, 45.0*DEG2R*sign(idFace - 0.5), 0));\n\tp += vec3(0, 0, 3);\n\n#if ONLY_UwU\n\n\treturn min(eyes(p), sdfW(p));\n\n#else\n\n\tfloat face;\n\n\tif (idFace < 0.6) {\n\n\t\tface = min(eyes(p), sdfW(p)); // UwU\n\n\t} else if (idFace < 0.7) {\n\n\t\tp += vec3(0.5, 0, 0);\n\t\tface = min(colon(p), mouth1(p)); // :)\n\n\t} else {\n\t\tp += vec3(2, -0.5, 0);\n\t\tface = min(colon(p - vec3(0.5, 0, 0)), sdfD(p)); // :D\n\t}\n\n\treturn face;\n\n#endif\n\n}\n\nvec3 getNormal(vec3 p) {\n\n\tconst vec2 h = vec2(LIM_VAL, 0);\n\n\treturn normalize(\n\t\tvec3(\n\t\t\tscene(p + h.xyy) - scene(p - h.xyy),\n\t\t\tscene(p + h.yxy) - scene(p - h.yxy),\n\t\t\tscene(p + h.yyx) - scene(p - h.yyx)\n\t\t)\n\t);\n\n}\n\n// -- Credits: nimitz\n// -- https://www.shadertoy.com/view/4s2XRd\nvec3 march(vec3 ro, vec3 rd) {\n\n\tconst float precis = 0.001;\n    float h = precis*2.0;\n    \n\tfloat md = 1.0;\n\tvec2 d = vec2(MIN_DIST, 1000.0);\n\n\tbool stp = false;\n\n\tfor (int i = 0; i < MAX_STEPS; i++) {\n\n\t\tif( abs(h) < precis || d.x >= MAX_DIST )\n            break;\n\n        d.x += h;\n\n\t\tfloat dist = scene(ro + d.x*rd);\n\n\t\tif (!stp) {\n\n\t\t\tmd = min(md, dist);\n\n\t\t\tif (h < EDGE && h < dist && i > 0) {\n\t\t\t\tstp = true;\n\t\t\t\td.y = d.x;\n\t\t\t}\n\n\t\t}\n\n\t\th = dist;\n\n\t}\n\n\treturn vec3(d, stp ? smoothstep(EDGE-SMOOTH, EDGE+0.01, md) : 1.0);\n\n}\n\n#define SPECULAR 0.5\n\nvec3 render(vec3 pos, vec3 ro, int mat) {\n\n\tvec3 n = getNormal(pos);\n\tvec3 viewPos = normalize(ro - pos);\n\tvec3 lightDir = normalize(vec3(2, 1,-5) - pos);\n\tvec3 reflectDir = normalize(reflect(-lightDir, n));\n\n\tfloat spec = pow( max( dot(viewPos, reflectDir), 0.0 ), 512.0);\n\tfloat kw = (1.0 + dot(n, lightDir)) * 0.5;\n\n\tvec3 cw, cc;\n    \n    if (mat == 0) {\n        cw = vec3(0.97, 0.01, 0.78);\n\t\tcc = vec3(0.9333, 1.0, 0.0);\n    } else if (mat == 1) {\n        cw = vec3(1.0, 0.0, 0.6);\n\t\tcc = vec3(0.9, 0.7, 0.7);\n    } else {\n        cw = vec3(0.2);\n\t\tcc = vec3(0.1);\n    }\n\n\tvec3 col = mix(cw, cc, kw);\n\tfloat specSmooth = smoothstep(0.0, 0.0025, spec);\n\n\treturn clamp(col + specSmooth*vec3(1), 0.0, 1.0);\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 col = vec3(0.5, 0.7, 0.9);\n\tvec3 tot = vec3(0);\n\n#if AA > 1\n\tfor( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n\n    vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n    vec2 uv = (2.0*(fragCoord+o) - iResolution.xy)/iResolution.y;\n\n#else\n\n\tvec2 uv = 2.0*(fragCoord / iResolution.xy) - 1.0;\n\tuv.x *= ASPECT;\n    \n#endif\n\n\tuv *= ZOOM;\n\tuv *= rot2D(-45.0 * DEG2R);\n\n\tfloat sgn = sign(mod(floor(uv.x), 2.0) - 0.5);\n\tuv.y += 0.5*iTime*sgn;\n\n\tvec2 fpos = fract(uv) - 0.5;\n\tvec2 ipos = floor(uv);\n\n#if ONLY_UwU\n\tidFace = mod(ipos.y, 2.0);\n#else\n\tidFace = noise(ipos);\n#endif\n\n\tint idMat = int(ceil(mod(ipos.y, 3.0)));\n\n#if ORTOGRAPHIC\n\n\tvec3 ro = vec3(RECT_SIZE*fpos, -6);\n\tvec3 rd = vec3(0, 0, 1);\n\n#else\n\n\tvec3 ro = vec3(0, 0, -6);\n\tvec3 rd = normalize(vec3(fpos, 1.0));\n\n#endif\n\n\tvec3 t = march(ro, rd);\n\tfloat hit = step(t.x, MAX_DIST - LIM_VAL);\n\n\tcol = mix(\n\t\tcol,\n\t\trender(ro + rd*t.x, ro, idMat),\n\t\thit\n\t);\n\n\tcol *= mix(t.z, 1.0, smoothstep(20.,30.,t.y));\n\n\ttot += col;\n\n#if AA > 1\n\t}\n\n\ttot /= float(AA*AA);\n#endif\n\n\tfragColor = vec4(tot, 1);\n\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define ASPECT iResolution.x / iResolution.y\n\n#define MAX_STEPS 64\n#define MIN_DIST  0.0\n#define MAX_DIST  16.0\n#define LIM_VAL   1E-4\n\n#define EDGE 0.05\n#define SMOOTH 0.025\n\n#define DEG2R 0.01745329 // degrees to radians\n\nfloat noise(vec2 st) {\n\n    return fract(sin( dot( st.xy, vec2(12.9898,78.233) ) ) * 43758.5453123);\n\n}\n\nmat2 rot2D(float angle) {\n\n    float c = cos(angle);\n    float s = sin(angle);\n\n    return mat2(\n        c, -s,\n        s, c\n    );\n\n}\n\nvec3 rotate(vec3 p, vec3 a) {\n\n\tp.yz *= rot2D(a.x);\n\tp.xz *= rot2D(-a.y);\n\tp.xy *= rot2D(a.z);\n\n\treturn p;\n\n}\n\n// -- Credits: Inigo Quilez\n// -- https://iquilezles.org/articles/distfunctions/\n// ---------------------------------------------------------\nfloat sdSphere( vec3 p, float r ) {\n\n\treturn length(p) - r;\n\n}\n\nfloat sdBox( vec3 p, vec3 b ) {\n\n\tvec3 q = abs(p) - b;\n\treturn length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n\n}\n\nfloat sdCappedCylinder( vec3 p, float h, float r ) {\n\n\tvec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  \treturn min(max(d.x,d.y),0.0) + length(max(d,0.0));\n\n}\n\nfloat sdTriIso( in vec2 p, in vec2 q ) {\n\n\tp.x = abs(p.x);\n    vec2 a = p - q*clamp( dot(p,q)/dot(q,q), 0.0, 1.0 );\n    vec2 b = p - q*vec2( clamp( p.x/q.x, 0.0, 1.0 ), 1.0 );\n    float s = -sign( q.y );\n    vec2 d = min( vec2( dot(a,a), s*(p.x*q.y-p.y*q.x) ),\n                  vec2( dot(b,b), s*(p.y-q.y)  ));\n    return -sqrt(d.x)*sign(d.y);\n    \n}\n\nfloat opExtrussion( in vec3 p, in float sdf, in float h ) {\n\n\tvec2 w = vec2( sdf, abs(p.z) - h );\n  \treturn min(max(w.x,w.y),0.0) + length(max(w,0.0));\n\n}\n\nfloat opOnion( in float sdf, in float thickness ) {\n\n    return abs(sdf)-thickness;\n\n}\n// ---------------------------------------------------------\n\nfloat sdfV(vec3 p) {\n\n\tvec3 cb = p - vec3(0, 0, 3);\n\tfloat b = sdBox(cb, vec3(1, 0.8, 0.25));\n\n\tvec3 q = p - vec3(0, -0.5*0.5, 3);\n\tfloat tc = opExtrussion(q, sdTriIso(q.xy, vec2(1.25, 3.50)*0.5), 6.0);\n\tb = max(b, -tc);\n\n\tvec3 tcl = vec3(abs(p.x), p.yz) - vec3(2.0*0.5, 3.0*0.5, 3);\n\ttc = opExtrussion(tcl, sdTriIso(-tcl.xy, vec2(2.40, 7.0)*0.5), 6.0);\n\tb = max(b, -tc);\n\n\treturn b;\n\n}\n\nfloat sdfU(vec3 p, float d) {\n\n\tvec3 cc = p - vec3(0, 0, 3);\n\tcc.zy *= rot2D(90.0 * DEG2R);\n\n\tfloat u = max(\n\t\tsdCappedCylinder(cc, 0.9, d),\n\t\t-sdCappedCylinder(cc, 0.5, 1.50)\n\t);\n\n\tvec3 boxCenter = p - vec3(0, 1, 3);\n\n\tu = max(\n\t\tu,\n\t\t-sdBox(boxCenter, vec3(2, 1, 2))\n\t);\n\n\tvec3 cb = p - vec3(0, 0.69, 3);\n\n\tfloat center = max(\n\t\tsdBox(cb, vec3(0.9, 0.75, d)),\n\t\t-sdBox(cb, vec3(0.5, 1, 2))\n\t);\n\n\treturn min(u, center);\n\n}\n\nfloat sdfD(vec3 p) {\n\n\tp -= vec3(2.3, 0, 0);\n\tvec3 sp = p - vec3(1.8, 0, 3);\n\tvec3 cp = p - vec3(-0.50, 0, 3);\n\n\tcp.zy *= rot2D(90.0 * DEG2R);\n\n\tfloat D = max(\n\t\tsdBox(sp, vec3(2.5, 4.25, 0.25)),\n\t\topOnion(sdCappedCylinder(cp, 2.5, 1.0), 0.25)\n\t);\n\n\tvec3 b = p - vec3(-0.45, 0, 3);\n\n\tD = min(\n\t\tD,\n\t\tsdBox(b, vec3(0.25, 2.50, 0.25))\n\t);\n\n\treturn D;\n\n}\n\nfloat colon(in vec3 p) {\n\n\tvec3 d = vec3(p.x, abs(p.y), p.z) - vec3(0, 1.8, 3);\n\td.zy *= rot2D(90.0 * DEG2R);\n\n\treturn sdCappedCylinder(d, 0.35, 0.25);\n\n}\n\nfloat mouth1(in vec3 p) {\n\n\tvec3 q = p - vec3(0, 0, 3);\n\tvec3 u = p - vec3(-3, 0, 3);\n\n\tfloat m = max(\n\t\tsdBox(q, vec3(6.0, 3.0, 0.25)),\n\t\t-sdSphere(u, 5.0)\n\t);\n\n\tu.x -= 0.45;\n\n\tm = max(\n\t\tm,\n\t\tsdSphere(u, 5.0)\n\t);\n\n\treturn m;\n}\n\nfloat eyes(in vec3 p) {\n\n\tvec3 o = vec3(3, 0, 0);\n\treturn sdfU(vec3(abs(p.x), p.yz) - o, 0.25);\n\n}\n\nfloat sdfW(in vec3 p) {\n\n\tvec3 o = vec3(0.6, 0, 0);\n\treturn sdfV(vec3(abs(p.x), p.yz) - o);\n\n}\n","name":"Common","description":"","type":"common"}]}