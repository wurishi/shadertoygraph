{"ver":"0.1","info":{"id":"WdfXD7","date":"1551374221","viewed":6637,"name":"Shader Redstone 2","username":"saidwho12","description":"Redstone dust and blocks don't get updated instantly but rather power is propagated a block per frame. Controls are 1-9 to select items, Q to destroy and E to place/interact.","likes":24,"published":1,"flags":48,"usePreview":0,"tags":["2d","simulation","sdf","minecraft","ao","aa","buffer","redstone"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n\nRedstone Simulator v2:\n\nNumber keys (1;9) to select items on top. Key Q to destroy and E to place/interact.\nThere are also 2 voxels per tile, one above the other.\n\nItem Table:\n1     - void\n2     - block\n3     - redstone wire/dust\n4     - redstone torch\n(5;8) - oriented redstone torch\n9     - lever\n\nThe basics of redstone in the game is that first of all is that redstone components or\nopaque blocks carry power.\n\nThe maximum power value is 16, torches emit this by default same with toggled levers.\n\nDust connected to multiple power emitters will propagate their signal, kinda like an OR gate.\n\nA block can also be powered if a wire if connected to it, however it won't decrement the signal.\n\nIf a torch is attached to a block and the block\nis not unpowered (meaning the maximum power driven into it not 0 or none)\nthen the torch will turn of, kinda like a NOT gate.\n\nWith these concepts you can creating things like clocks, AND and XOR gate, ALUs, etc...\n\nIf this was 3D you could certainly build a full ALU but I don't think\nit's possible here because of the 2 depth limit.\n\nThere's an XOR gate design which is only 2 blocks high with this ruleset.\n\nHave fun :)\n\n*/\n\n\n// WebGL 1 cannot return array\nVoxel[2] GetVoxels(in ivec2 u) {\n    if(   all(greaterThanEqual(u,ivec2(0)))\n       && all(lessThanEqual(u, ivec2(PLAY_AREA)))) {\n    return PixelToVoxels(texture(iChannel0, (vec2(u)+.5)/iResolution.xy));\n       }\n    return VoidVoxels();\n}\n\n\nbvec4 GetBottomDustConnections(in ivec2 u) {\n\tVoxel[2] leftVoxels = GetVoxels(u+ivec2(-1,0));\n    Voxel[2] rightVoxels = GetVoxels(u+ivec2(1,0));\n    Voxel[2] downVoxels = GetVoxels(u+ivec2(0,-1));\n    Voxel[2] upVoxels = GetVoxels(u+ivec2(0,1));\n    \n    return bvec4(IsVoxelDustConnectable(leftVoxels[0])\n                 || leftVoxels[1].type == VOXEL_TYPE_DUST,\n                 IsVoxelDustConnectable(rightVoxels[0])\n                 || rightVoxels[1].type == VOXEL_TYPE_DUST,\n                 IsVoxelDustConnectable(downVoxels[0])\n                 || downVoxels[1].type == VOXEL_TYPE_DUST,\n                 IsVoxelDustConnectable(upVoxels[0])\n                 || upVoxels[1].type == VOXEL_TYPE_DUST\n                 );\n}\n\nbvec4 GetTopDustConnections(in ivec2 u) {\n\tVoxel[2] leftVoxels = GetVoxels(u+ivec2(-1,0));\n    Voxel[2] rightVoxels = GetVoxels(u+ivec2(1,0));\n    Voxel[2] downVoxels = GetVoxels(u+ivec2(0,-1));\n    Voxel[2] upVoxels = GetVoxels(u+ivec2(0,1));\n    \n    return bvec4(IsVoxelDustConnectable(leftVoxels[1])\n                 || leftVoxels[0].type == VOXEL_TYPE_DUST\n                 || IsVoxelOrientedTorchX(leftVoxels[0]),\n                 \n                 IsVoxelDustConnectable(rightVoxels[1])\n                 || rightVoxels[0].type == VOXEL_TYPE_DUST\n                 || IsVoxelOrientedTorchX(rightVoxels[0]),\n                 \n                 IsVoxelDustConnectable(downVoxels[1])\n                 || downVoxels[0].type == VOXEL_TYPE_DUST\n                 || IsVoxelOrientedTorchY(downVoxels[0]),\n                 \n                 IsVoxelDustConnectable(upVoxels[1])\n                 || upVoxels[0].type == VOXEL_TYPE_DUST\n                 || IsVoxelOrientedTorchY(upVoxels[0])\n                 );\n}\n\n#define rot(x) mat2(cos(x),-sin(x),sin(x),cos(x))\n\nfloat udLine(in vec2 p, in vec2 a, in vec2 b) {\n    vec2 pa = p - a, ba = b - a;\n    float h = clamp(dot(pa,ba)/dot(ba, ba), 0.0, 1.0);\n    return length(pa - ba*h);\n}\n\nfloat udBox(in vec2 p, in vec2 b) {\n\treturn length(max(abs(p)-b,0.));\n}\n\nfloat sdBox(vec2 p, vec2 b) {\n  vec2 d = abs(p) - b;\n  return length(max(d,0.0)) + min(max(d.x,d.y),0.0); \n}\n\n\nconst float wireRadius = .15;\nconst float torchRadius = .3;\nconst float torchHandleSize = .15;\n\n#define DARK_RED vec3(.15, 0, 0)\n#define RED vec3(1,0,0)\n#define YELLOW vec3(1,1,0)\n\n#define SS(x) smoothstep(3./R.y,0.,x)\n\nvoid DrawVoxelDust(inout vec4 O, in Voxel voxel, in int z, in vec3 p, in ivec2 c, in vec2 R) {\n\tfloat t = 1000.;\n    vec3 color = mix(DARK_RED, RED, voxel.power/MAX_REDSTONE_POWER);\n\n    bvec4 isConnected = z == 0 ? GetBottomDustConnections(c) : GetTopDustConnections(c);\n\n    if(any(isConnected)) {\n        if(any(isConnected.xy) && !any(isConnected.zw)) t = min(t,abs(p.y));\n        else if(any(isConnected.zw) && !any(isConnected.xy)) t = min(t,abs(p.x));\n            else {\n                if(isConnected.x) t = min(t,udLine(p.xy,vec2(0),vec2(-1,0)));\n                if(isConnected.y) t = min(t,udLine(p.xy,vec2(0),vec2(1,0)));\n                if(isConnected.z) t = min(t,udLine(p.xy,vec2(0),vec2(0,-1)));\n                if(isConnected.w) t = min(t,udLine(p.xy,vec2(0),vec2(0,1)));\n            }\n    } else {\n        t = length(p.xy);\n    }\n\n    t -= wireRadius;\n\n    O.rgb = mix(O.rgb, color, smoothstep(3./R.y, 0., t/p.z));\n}\n\nvoid DrawVoxelNotDust(inout vec4 O, in Voxel voxel, in int z, in vec3 p, in vec2 R) {\n    \n    if(voxel.type == VOXEL_TYPE_BLOCK) {\n        O.rgb = (z == 0) ? YELLOW : .5*YELLOW;\n        return;\n    }\n    \n    if(IsVoxelTorch(voxel)) {\n        float t = 1000.;\n        vec3 color = mix(DARK_RED, RED, voxel.power/MAX_REDSTONE_POWER);\n\n        t = min(t,length(p.xy)-torchRadius);\n        float tHandle = 1000.;\n\n        bvec4 isConnected = bvec4(voxel.type == VOXEL_TYPE_TORCH_POSITIVE_X,\n                                  voxel.type == VOXEL_TYPE_TORCH_NEGATIVE_X,\n                                  voxel.type == VOXEL_TYPE_TORCH_POSITIVE_Y,\n                                  voxel.type == VOXEL_TYPE_TORCH_NEGATIVE_Y\n                                 );\n\n        if(any(isConnected)) {\n            if(isConnected.x) tHandle = min(tHandle,udLine(p.xy,vec2(0),vec2(-1,0)));\n            if(isConnected.y) tHandle = min(tHandle,udLine(p.xy,vec2(0),vec2(1,0)));\n            if(isConnected.z) tHandle = min(tHandle,udLine(p.xy,vec2(0),vec2(0,-1)));\n            if(isConnected.w) tHandle = min(tHandle,udLine(p.xy,vec2(0),vec2(0,1)));\n            tHandle -= torchHandleSize;\n            \n            // Cut from sides of 1.\n            //tHandle = max(tHandle, sdBox(p.xy,vec2(1)));\n            \n            O.rgb = mix(O.rgb, vec3(.3), smoothstep(3./R.y, 0., tHandle/p.z));\n        }\n\n        O.rgb = mix(O.rgb, color, smoothstep(3./R.y, 0., t/p.z));\n    }\n    \n    if(voxel.type == VOXEL_TYPE_LEVER) {\n        // Draw lever base\n        O.rgb = mix(O.rgb, vec3(.25), SS(udBox(p.xy,vec2(.35,.45))/p.z));\n        \n        if(voxel.power <= 0.) p.y = -p.y;\n        // Draw Handle\n        O.rgb = mix(O.rgb, vec3(.65,.5,0), SS( (udLine(p.xy,vec2(0), vec2(0,.7))-.1) /p.z));\n    \n        // Draw Handle head\n    \tO.rgb = mix(O.rgb, vec3(.65), SS( (length(p.xy-vec2(0,.7))-.25) /p.z));\n    }\n}\n\nvoid DrawVoxel(inout vec4 O, in Voxel voxel, in int z, in vec3 p, in ivec2 c, in vec2 R) {\n    if(voxel.type == VOXEL_TYPE_DUST) {\n    \tDrawVoxelDust(O,voxel,z,p,c,R);\n    } else {\n    \tDrawVoxelNotDust(O,voxel,z,p,R);\n    }\n}\n\nvoid mainImage(out vec4 O, in vec2 u) {\n    vec4 bgColor = vec4(1.); \n    O = bgColor;\n    vec2 R = iResolution.xy;\n    vec3 up = vec3((u+u-R)/R.y,1), p = up;\n    \n    p *= .5;\n    p.xy += .5;\n    p *= float(PLAY_AREA); \n    \n    vec2 f = fract(p.xy);\n    vec3 pp = vec3(f,p.z)*2.-vec3(1,1,0);\n    \n    ivec2 c = ivec2(floor(p));\n    \n    Voxel[2] voxels = GetVoxels( c );\n    \n    \n    if(IsVoxelDustConnectable(voxels[0])) {\n        O.rgb = mix(O.rgb, vec3(1,1,0), .5);\n    }\n    \n    DrawVoxel(O,voxels[0],0,pp,c,R);\n    DrawVoxel(O,voxels[1],1,pp,c,R);\n    \n    // Mouse stuff\n    vec2 m = iMouse.xy;\n    vec2 mp = (m+m-R)/R.y;\n    \n    ivec2 mi = ivec2(SCREEN_TO_TILE(iMouse.xy));\n    \n    // Item selection\n    \n    const float selectorWidth = .175;\n    \n    float tItems = 1.-up.y - selectorWidth;\n    O.rgb = mix(O.rgb, vec3(1), SS( tItems ));\n    if(tItems >= 0.) {\n        // Selection\n        \n        if(all(equal(c, mi))\n          // && all(greaterThanEqual(mi, ivec2(0)))\n          // && all(lessThan(mi, ivec2(PLAY_AREA)))\n          ) {\n            O.rgb *= sin(iTime*TAU)*.2+.8;\n        }\n        \n        // Grid\n        pp = vec3(fract(p.xy-.5),p.z)*2.-vec3(1,1,0); // grid point\n        float tGrid = min(abs(pp.x),abs(pp.y))-.03;\n        float tGridPoints = max(abs(pp.x),abs(pp.y))-.08;\n\n        O.rgb *= 1.-.25*smoothstep(3./R.y, 0., tGrid/pp.z);\n        //O *= 1.-.25*smoothstep(3./R.y, 0., tGridPoints/pp.z);\n\n        // AO\n        O.rgb *= 1.-.35*exp(-25.*tItems);\n\t} else {\n        float selectedItemType = texelFetch(iChannel0, SELECTION_COORD,0).x;\n        \n        vec3 fItemBoxes = vec3(1,-1,1)*vec3(up.x,1.-up.y,up.z)/selectorWidth + vec3(VOXEL_TYPE_COUNT*.5,0,0);\n        vec2 iItemBoxes = floor(fItemBoxes.xy);\n    \tvec3 pItemBoxes = vec3(fract(fItemBoxes.xy),fItemBoxes.z)*2.-vec3(1,1,0);\n    \n        if(iItemBoxes.x < VOXEL_TYPE_COUNT && iItemBoxes.x >= 0.) {\n    \t\t#ifdef ENABLED_ITEMBOX_ANIMATION\n        \tfloat x = (iItemBoxes.x+1.)/VOXEL_TYPE_COUNT;\n        \tpItemBoxes.xy = rot(sin((x-iTime)*TAU*.8)*TAU*.05)*pItemBoxes.xy;\n        \t#endif\n        \t\n            //pItemBoxes *= 1.7;\n            \n            if(iItemBoxes.x == VOXEL_TYPE_DUST) { // special case draw dust as cross\n            \tO.rgb = mix(O.rgb, DARK_RED, SS((min(abs(pItemBoxes.x), abs(pItemBoxes.y))-wireRadius)/pItemBoxes.z ) );\n            } else {\n            \tDrawVoxelNotDust(O,DefaultPowerVoxel(iItemBoxes.x),0,pItemBoxes,R);\n            }\n            \n            if(selectedItemType == iItemBoxes.x) {\n                float tSelectedItemBox = abs(sdBox(pItemBoxes.xy, /*vec2(1. + .25 * (.5+.5*sin(iTime*TAU)))*/ vec2(.7) ) )-.03;\n                \n                O.rgb = mix(O.rgb, vec3(0), SS(tSelectedItemBox/pItemBoxes.z) );\n            } else {\n            \tfloat tItemBoxes = abs(sdBox(pItemBoxes.xy, vec2(.64)))-.015;\n        \t    O.rgb = mix(O.rgb, 1.-.4*O.rgb, SS(tItemBoxes/pItemBoxes.z));\n            }\n        }\n    }\n    \n    // Crosshair\n    float tCrosshair = min(udBox(up.xy-mp,vec2(.005,.08)), udBox(up.xy-mp,vec2(.08,.005)));\n    float a = smoothstep(3./R.y,0.,tCrosshair);\n    O.rgb = mix(O.rgb, 1.-.5*O.rgb, a);\n    \n   \t//O = vec4(pp.xy,0,1);\n    \n    float gamma = 1.3;\n    O.rgb = pow(O.rgb, vec3(1./gamma));\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"const float KEY_BSP   = 8.5/256.0;\nconst float KEY_SP    = 32.5/256.0;\nconst float KEY_LEFT  = 37.5/256.0;\nconst float KEY_UP    = 38.5/256.0;\nconst float KEY_RIGHT = 39.5/256.0;\nconst float KEY_DOWN  = 40.5/256.0;\nconst float KEY_A     = 65.5/256.0;\nconst float KEY_B     = 66.5/256.0;\nconst float KEY_C     = 67.5/256.0;\nconst float KEY_D     = 68.5/256.0;\nconst float KEY_E     = 69.5/256.0;\nconst float KEY_F     = 70.5/256.0;\nconst float KEY_G     = 71.5/256.0;\nconst float KEY_H     = 72.5/256.0;\nconst float KEY_I     = 73.5/256.0;\nconst float KEY_J     = 74.5/256.0;\nconst float KEY_K     = 75.5/256.0;\nconst float KEY_L     = 76.5/256.0;\nconst float KEY_M     = 77.5/256.0;\nconst float KEY_N     = 78.5/256.0;\nconst float KEY_O     = 79.5/256.0;\nconst float KEY_P     = 80.5/256.0;\nconst float KEY_Q     = 81.5/256.0;\nconst float KEY_R     = 82.5/256.0;\nconst float KEY_S     = 83.5/256.0;\nconst float KEY_T     = 84.5/256.0;\nconst float KEY_U     = 85.5/256.0;\nconst float KEY_V     = 86.5/256.0;\nconst float KEY_W     = 87.5/256.0;\nconst float KEY_X     = 88.5/256.0;\nconst float KEY_Y     = 89.5/256.0;\nconst float KEY_Z     = 90.5/256.0;\nconst float KEY_COMMA = 188.5/256.0;\nconst float KEY_PER   = 190.5/256.0;\n\nconst float KEY_0     = 48.5/256.0;\nconst float KEY_1     = 49.5/256.0;\nconst float KEY_2     = 50.5/256.0;\nconst float KEY_3     = 51.5/256.0;\nconst float KEY_4     = 52.5/256.0;\nconst float KEY_5     = 53.5/256.0;\nconst float KEY_6     = 54.5/256.0;\nconst float KEY_7     = 55.5/256.0;\nconst float KEY_8     = 56.5/256.0;\nconst float KEY_9     = 57.5/256.0;\n\n#define PI acos(-1.)\n#define TAU (PI+PI)\n\n#define PLAY_AREA 16.\n#define MAX_REDSTONE_POWER 16.\n\n#define SCREEN_TO_TILE(x) ((vec3(((x)+(x)-R)/R.y,1)*.5+vec3(.5,.5,0))*PLAY_AREA)\n\n#define VOXEL_TYPE_VOID 0.\n#define VOXEL_TYPE_BLOCK 1.\n#define VOXEL_TYPE_DUST 2.\n#define VOXEL_TYPE_TORCH 3.\n#define VOXEL_TYPE_TORCH_NEGATIVE_X 4.\n#define VOXEL_TYPE_TORCH_POSITIVE_X 5.\n#define VOXEL_TYPE_TORCH_NEGATIVE_Y 6.\n#define VOXEL_TYPE_TORCH_POSITIVE_Y 7.\n#define VOXEL_TYPE_LEVER 8.\n#define VOXEL_TYPE_COUNT 9.\n\n#define SELECTION_COORD ivec2(0,PLAY_AREA+1.)\n\n#define ENABLED_ITEMBOX_ANIMATION\n\nstruct Voxel {\n\tfloat type;\n    float power;\n};\n\nVoxel[2] GetVoxels(in ivec2 co);\n    \nVoxel PoweredVoxel(float type) {\n\treturn Voxel(type, MAX_REDSTONE_POWER);\n}\n\nVoxel UnpoweredVoxel(float type) {\n\treturn Voxel(type, 0.);\n}\n\nVoxel Torch() {\n\treturn PoweredVoxel(VOXEL_TYPE_TORCH);\n}\n\nVoxel Block() {\n\treturn UnpoweredVoxel(VOXEL_TYPE_BLOCK);\n}\n\nVoxel Void() {\n\treturn UnpoweredVoxel(VOXEL_TYPE_VOID);\n}\n\nVoxel Dust() {\n\treturn UnpoweredVoxel(VOXEL_TYPE_DUST);\n}\n\nVoxel[2] VoidVoxels() {\n    return Voxel[2](Void(), Void());\n}\n\nVoxel[2] PixelToVoxels(in vec4 pixel) {\n\treturn Voxel[2](Voxel(pixel.x,pixel.y),Voxel(pixel.z,pixel.w));\n}\n\nvec4 VoxelsToPixel(in Voxel[2] voxels) {\n\treturn vec4(voxels[0].type, voxels[0].power, voxels[1].type, voxels[1].power);\n}\n\n#define VOID_PIXEL VoxelsToPixel(VoidVoxels())\n\n\n// check only type\nbool IsVoxelTypeOrientedTorchX(in float type) {\n\treturn type == VOXEL_TYPE_TORCH_NEGATIVE_X\n        || type == VOXEL_TYPE_TORCH_POSITIVE_X;\n}\n\nbool IsVoxelTypeOrientedTorchY(in float type) {\n\treturn type == VOXEL_TYPE_TORCH_NEGATIVE_Y\n        || type == VOXEL_TYPE_TORCH_POSITIVE_Y;\n}\n\nbool IsVoxelTypeOrientedTorch(in float type) {\n\treturn  IsVoxelTypeOrientedTorchX(type) || IsVoxelTypeOrientedTorchY(type);\n}\n\nbool IsVoxelTypeTorch(in float type) {\n\treturn type == VOXEL_TYPE_TORCH || IsVoxelTypeOrientedTorch(type);\n}\n\n// Voxel check typeof\nbool IsVoxelOrientedTorchX(in Voxel voxel) {\n\treturn IsVoxelTypeOrientedTorchX(voxel.type);\n}\n\nbool IsVoxelOrientedTorchY(in Voxel voxel) {\n    return IsVoxelTypeOrientedTorchY(voxel.type);\n}\n\nbool IsVoxelOrientedTorch(in Voxel voxel) {\n    return IsVoxelOrientedTorchX(voxel) || IsVoxelOrientedTorchY(voxel);\n}\n\nbool IsVoxelTorch(in Voxel voxel) {\n\treturn IsVoxelTypeTorch(voxel.type);\n}\n\nbool IsVoxelDustConnectable(in Voxel voxel) {\n    return voxel.type == VOXEL_TYPE_DUST ||\n        voxel.type == VOXEL_TYPE_LEVER ||\n        IsVoxelTorch(voxel);\n}\n\nbool IsVoxelBottomDependent(in Voxel voxel) {\n\treturn voxel.type == VOXEL_TYPE_DUST\n        || voxel.type == VOXEL_TYPE_LEVER\n        || voxel.type == VOXEL_TYPE_TORCH;\n}\n\nVoxel DefaultPowerVoxel(float type) {\n\tif(IsVoxelTypeTorch(type)) return PoweredVoxel(type);\n    else return UnpoweredVoxel(type);\n}\n\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"Voxel[2] GetVoxels(in ivec2 u) {\n    if(   all(greaterThanEqual(u,ivec2(0)))\n       && all(lessThanEqual(u, ivec2(PLAY_AREA)))) {\n    return PixelToVoxels(texture(iChannel0, (vec2(u)+.5)/iResolution.xy));\n\n       }\n    return VoidVoxels();\n}\n\nVoxel[4] GetBottomVoxelsAround(in ivec2 u) {\n\tVoxel left = GetVoxels(u+ivec2(-1,0))[0];\n    Voxel right = GetVoxels(u+ivec2(1,0))[0];\n    Voxel down = GetVoxels(u+ivec2(0,-1))[0];\n    Voxel up = GetVoxels(u+ivec2(0,1))[0];\n    \n    return Voxel[4](left,right,down,up);\n}\n\nbvec2 GetDustDirectionBottom(in ivec2 u) {\n    Voxel[2] leftVoxels = GetVoxels(u+ivec2(-1,0));\n    Voxel[2] rightVoxels = GetVoxels(u+ivec2(1,0));\n    Voxel[2] downVoxels = GetVoxels(u+ivec2(0,-1));\n    Voxel[2] upVoxels = GetVoxels(u+ivec2(0,1));\n    \n    bvec4 isConnectedBottom = bvec4(IsVoxelDustConnectable(leftVoxels[0]),\n                 \t\t\t\t\tIsVoxelDustConnectable(rightVoxels[0]),\n                 \t\t\t\t\tIsVoxelDustConnectable(downVoxels[0]),\n                 \t\t\t\t\tIsVoxelDustConnectable(upVoxels[0])\n                 \t\t\t\t\t);\n    bvec4 isConnectedTop = bvec4(leftVoxels[1].type == VOXEL_TYPE_DUST,\n                                 rightVoxels[1].type == VOXEL_TYPE_DUST,\n                                 downVoxels[1].type == VOXEL_TYPE_DUST,\n                                 upVoxels[1].type == VOXEL_TYPE_DUST\n                                );\n\t\n    return bvec2( (any(isConnectedBottom.xy) || any(isConnectedTop.xy))\n                 && !any(isConnectedBottom.zw) && !any(isConnectedTop.zw),\n                   (any(isConnectedBottom.zw) || any(isConnectedTop.zw))\n                 && !any(isConnectedBottom.xy) && !any(isConnectedTop.xy)\n                );\n}\n\nfloat GetDustPowerBottom(in ivec2 u) {\n    float power = 0.;\n\tVoxel[2] leftVoxels = GetVoxels(u+ivec2(-1,0));\n    Voxel[2] rightVoxels = GetVoxels(u+ivec2(1,0));\n    Voxel[2] downVoxels = GetVoxels(u+ivec2(0,-1));\n    Voxel[2] upVoxels = GetVoxels(u+ivec2(0,1));\n    \n    bvec4 isConnectedBottom = bvec4(IsVoxelDustConnectable(leftVoxels[0]),\n                 IsVoxelDustConnectable(rightVoxels[0]),\n                 IsVoxelDustConnectable(downVoxels[0]),\n                 IsVoxelDustConnectable(upVoxels[0])\n                 );\n    \n    bvec4 isConnectedTop = bvec4(leftVoxels[1].type == VOXEL_TYPE_DUST,\n                                   rightVoxels[1].type == VOXEL_TYPE_DUST,\n                                   downVoxels[1].type == VOXEL_TYPE_DUST,\n                                   upVoxels[1].type == VOXEL_TYPE_DUST);\n    \n    vec4 topPower = vec4(isConnectedTop) * vec4(leftVoxels[1].power,\n                                               rightVoxels[1].power,\n                                               downVoxels[1].power,\n                                               upVoxels[1].power);\n    \n    \n   \tvec4 bottomPower = vec4(isConnectedBottom) * vec4(leftVoxels[0].power,\n                                               rightVoxels[0].power,\n                                               downVoxels[0].power,\n                                               upVoxels[0].power);\n    \n    if(any(isConnectedTop) || any(isConnectedBottom)) {\n    \tpower = max(\n            max(max(topPower.x, topPower.y),max(topPower.z, topPower.w)),\n            max(max(bottomPower.x, bottomPower.y),max(bottomPower.z, bottomPower.w))\n            )-1.;\n    }\n    \n    return max(power,0.);\n}\n\nfloat GetDustPowerTop(in ivec2 u) {\n    float power = 0.;\n    \n\tVoxel bottom = GetVoxels(u)[0];\n    if(bottom.type == VOXEL_TYPE_BLOCK && bottom.power > 0.) {\n    \tpower = bottom.power;\n    }\n    Voxel[2] leftVoxels = GetVoxels(u+ivec2(-1,0));\n    Voxel[2] rightVoxels = GetVoxels(u+ivec2(1,0));\n    Voxel[2] downVoxels = GetVoxels(u+ivec2(0,-1));\n    Voxel[2] upVoxels = GetVoxels(u+ivec2(0,1));\n    \n    bvec4 isConnectedTop = bvec4(IsVoxelDustConnectable(leftVoxels[1]),\n                              IsVoxelDustConnectable(rightVoxels[1]),\n                              IsVoxelDustConnectable(downVoxels[1]),\n                              IsVoxelDustConnectable(upVoxels[1])\n                              );\n    \n    bvec4 isConnectedBottom = bvec4(leftVoxels[0].type == VOXEL_TYPE_DUST,\n                                   rightVoxels[0].type == VOXEL_TYPE_DUST,\n                                   downVoxels[0].type == VOXEL_TYPE_DUST,\n                                   upVoxels[0].type == VOXEL_TYPE_DUST);\n    \n   \tvec4 topPower = vec4(isConnectedTop) * vec4(leftVoxels[1].power,\n                                               rightVoxels[1].power,\n                                               downVoxels[1].power,\n                                               upVoxels[1].power);\n    \n    \n   \tvec4 bottomPower = vec4(isConnectedBottom) * vec4(leftVoxels[0].power,\n                                               rightVoxels[0].power,\n                                               downVoxels[0].power,\n                                               upVoxels[0].power);\n    \n    if(any(isConnectedTop) || any(isConnectedBottom)) {\n    \tpower = max(\n            max(max(topPower.x, topPower.y),max(topPower.z, topPower.w)),\n            max(max(bottomPower.x, bottomPower.y),max(bottomPower.z, bottomPower.w))\n            )-1.;\n    }\n    \n    return max(power,0.);\n    \n}\n\n\nfloat GetBlockPowerAroundBottom(in ivec2 u) {\n\tfloat power = 0.;\n    \n    // If redstone dust on top add to power.\n    Voxel top = GetVoxels(u)[1];\n    if(top.type == VOXEL_TYPE_DUST) power = top.power;\n    \n    // Check for connected dust laterally.\n\tVoxel left = GetVoxels(u+ivec2(-1,0))[0];\n    Voxel right = GetVoxels(u+ivec2(1,0))[0];\n    Voxel down = GetVoxels(u+ivec2(0,-1))[0];\n    Voxel up = GetVoxels(u+ivec2(0,1))[0];\n    \n    bvec4 isDust = bvec4(\n        left.type == VOXEL_TYPE_DUST && GetDustDirectionBottom(u+ivec2(-1,0)).x,\n        right.type == VOXEL_TYPE_DUST && GetDustDirectionBottom(u+ivec2(1,0)).x,\n        down.type == VOXEL_TYPE_DUST && GetDustDirectionBottom(u+ivec2(0,-1)).y,\n        up.type == VOXEL_TYPE_DUST && GetDustDirectionBottom(u+ivec2(0,1)).y);\n    \n    vec4 aroundPower = vec4(isDust) * vec4(left.power,right.power,down.power,up.power);\n    \n    power = max(power, max(max(aroundPower.x,aroundPower.y),max(aroundPower.z,aroundPower.w)));\n    \n    return power;\n}\n\nbool IsKeyPressed(float key) {\n    return bool(texture( iChannel1, vec2(key, 0.5) ).x);\n}\n\nstruct WorldWrite {\n\tVoxel[2] voxels;\n    ivec2 coord;\n};\n\nvec4 playInit(ivec2 c) {\n    return VOID_PIXEL;\n    \n    ivec2 offsetXOR = ivec2(0);\n    ivec2 offsetAND = ivec2(4,0);\n    ivec2 offsetClock = ivec2(4,6);\n    \n    WorldWrite[] xorWrites = WorldWrite[](\n        WorldWrite( Voxel[2](DefaultPowerVoxel(VOXEL_TYPE_LEVER), Void()), ivec2(0) ),\n   \t    WorldWrite( Voxel[2](DefaultPowerVoxel(VOXEL_TYPE_LEVER), Void()), ivec2(2,0) ),\n        \n        WorldWrite( Voxel[2](Dust(), Void()), ivec2(0,1) ),\n   \t    WorldWrite( Voxel[2](Dust(), Void()), ivec2(2,1) ),\n   \t    \n        WorldWrite( Voxel[2](Block(), Torch()), ivec2(0,2) ),\n   \t    WorldWrite( Voxel[2](Block(), Dust()), ivec2(1,2) ),\n   \t    WorldWrite( Voxel[2](Block(), Torch()), ivec2(2,2) ),\n   \t    \n        WorldWrite( Voxel[2](DefaultPowerVoxel(VOXEL_TYPE_TORCH_POSITIVE_Y), Void()), ivec2(0,3) ),\n   \t    WorldWrite( Voxel[2](Block(), Dust()), ivec2(1,3) ),\n        WorldWrite( Voxel[2](DefaultPowerVoxel(VOXEL_TYPE_TORCH_POSITIVE_Y), Void()), ivec2(2,3) ),\n        \n        WorldWrite( Voxel[2](Dust(), Void()), ivec2(0,4) ),\n        WorldWrite( Voxel[2](PoweredVoxel(VOXEL_TYPE_TORCH_POSITIVE_Y), Void()), ivec2(1,4) ),\n        WorldWrite( Voxel[2](Dust(), Void()), ivec2(2,4) ),\n        \n        WorldWrite( Voxel[2](Block(), Dust()), ivec2(0,5) ),\n        WorldWrite( Voxel[2](Block(), Dust()), ivec2(2,5) ),\n        \n        WorldWrite( Voxel[2](DefaultPowerVoxel(VOXEL_TYPE_TORCH_POSITIVE_Y), Void()), ivec2(0,6) ),\n        WorldWrite( Voxel[2](Dust(), Void()), ivec2(1,6) ),\n        WorldWrite( Voxel[2](DefaultPowerVoxel(VOXEL_TYPE_TORCH_POSITIVE_Y), Void()), ivec2(2,6) ),\n        \n        WorldWrite( Voxel[2](Dust(), Void()), ivec2(1,7) )\n   \t);\n    \n    WorldWrite[] andWrites = WorldWrite[](\n    \tWorldWrite( Voxel[2](DefaultPowerVoxel(VOXEL_TYPE_LEVER), Void()), ivec2(0) ),\n   \t    WorldWrite( Voxel[2](DefaultPowerVoxel(VOXEL_TYPE_LEVER), Void()), ivec2(2,0) ),\n        \n        WorldWrite( Voxel[2](Dust(), Void()), ivec2(0,1) ),\n   \t    WorldWrite( Voxel[2](Dust(), Void()), ivec2(2,1) ),\n   \t    \n        WorldWrite( Voxel[2](Block(), Torch()), ivec2(0,2) ),\n   \t    WorldWrite( Voxel[2](Block(), Dust()), ivec2(1,2) ),\n   \t    WorldWrite( Voxel[2](Block(), Torch()), ivec2(2,2) ),\n   \t    \n        WorldWrite( Voxel[2](DefaultPowerVoxel(VOXEL_TYPE_TORCH_POSITIVE_Y), Void()), ivec2(1,3) ),\n        \n        WorldWrite( Voxel[2](Dust(), Void()), ivec2(1,4) )\n    );\n    \n    WorldWrite[] clockWrites = WorldWrite[](\n        WorldWrite( Voxel[2](Dust(), Void()), ivec2(1,0)),\n        WorldWrite( Voxel[2](Block(), Void()), ivec2(2,0)),\n        WorldWrite( Voxel[2](DefaultPowerVoxel(VOXEL_TYPE_TORCH_POSITIVE_Y), Void()), ivec2(2,1)),\n        WorldWrite( Voxel[2](Dust(), Void()), ivec2(2,2)),\n        WorldWrite( Voxel[2](Dust(), Void()), ivec2(1,2)),\n        WorldWrite( Voxel[2](Block(), Torch()), ivec2(0,2)),\n        WorldWrite( Voxel[2](Block(), Dust()), ivec2(0,1)),\n    \tWorldWrite( Voxel[2](DefaultPowerVoxel(VOXEL_TYPE_TORCH_NEGATIVE_Y), Void()), ivec2(0))\n        \n    );\n    \n    int i = -1;\n    while(++i<xorWrites.length()) {\n        WorldWrite write = xorWrites[i];\n    \tif(all(equal(write.coord + offsetXOR, c))) return VoxelsToPixel(write.voxels);\n    }\n    \n    i = -1;\n    while(++i<andWrites.length()) {\n        WorldWrite write = andWrites[i];\n    \tif(all(equal(write.coord + offsetAND, c))) return VoxelsToPixel(write.voxels);\n    }\n    \n    i = -1;\n    while(++i<clockWrites.length()) {\n        WorldWrite write = clockWrites[i];\n    \tif(all(equal(write.coord + offsetClock, c))) return VoxelsToPixel(write.voxels);\n    }\n    \n    return VOID_PIXEL; \n}\n\n// CONTROLS\n// E to interact, Q to destroy block.\n// Number keys to select item.\n\nvoid mainImage(out vec4 O, in vec2 u) {\n    vec2 R = iResolution.xy;\n    if(  all(greaterThanEqual(u,vec2(0)))\n      && all(lessThanEqual(u, vec2(PLAY_AREA)))\n           ) {\n        \n        if(iFrame == 0)\t{\n            O = playInit(ivec2(u));\n        } else {\n            // Update\n            Voxel[2] voxels = GetVoxels(ivec2(u));\n            Voxel[2] newVoxels = voxels;\n            \n            if(voxels[0].type == VOXEL_TYPE_DUST) {\n            \tnewVoxels[0].power = GetDustPowerBottom(ivec2(u));\n            }\n            \n            if(voxels[1].type == VOXEL_TYPE_DUST) {\n            \tnewVoxels[1].power = GetDustPowerTop(ivec2(u));\n            }\n            \n            if(voxels[0].type == VOXEL_TYPE_BLOCK) {\n                float aroundPower = GetBlockPowerAroundBottom(ivec2(u));\n                if(aroundPower > 0.) {\n                    newVoxels[0].power = max(voxels[0].power, aroundPower);\n                } else {\n                \tnewVoxels[0].power = 0.;\n                }\n            }\n            \n            if(voxels[1].type == VOXEL_TYPE_TORCH) {\n            \t// Top torch inverted from below.\n            \n                if(voxels[0].type == VOXEL_TYPE_BLOCK) {\n                    float belowPower = voxels[0].power;\n                    if(belowPower > 0.) {\n                        newVoxels[1].power = 0.;\n                    } else {\n                        newVoxels[1].power = MAX_REDSTONE_POWER;\n                    }\n                } else {\n                \t// Remove torch if not standing on block\n                \tnewVoxels[1] = Void();\n                }\n                \n            }\n\n            // Bottom torch inverted from sides.\n            if(IsVoxelOrientedTorch(voxels[0])) {\n            \tVoxel[4] aroundVoxels = GetBottomVoxelsAround(ivec2(u));\n                \n                if(voxels[0].type == VOXEL_TYPE_TORCH_POSITIVE_X) {\n                    if(aroundVoxels[0].type == VOXEL_TYPE_BLOCK\n                   \t&& aroundVoxels[0].power > 0.) {\n                \t\tnewVoxels[0].power = 0.;\n                \t} else {\n                \t\tnewVoxels[0].power = MAX_REDSTONE_POWER;\n                \n                    }\n                }\n                \n                if(voxels[0].type == VOXEL_TYPE_TORCH_NEGATIVE_X) {\n                    if(aroundVoxels[1].type == VOXEL_TYPE_BLOCK\n                   \t&& aroundVoxels[1].power > 0.) {\n                \t\tnewVoxels[0].power = 0.;\n                \t} else {\n                \t\tnewVoxels[0].power = MAX_REDSTONE_POWER;\n                \n                    }\n                }\n                \n                if(voxels[0].type == VOXEL_TYPE_TORCH_POSITIVE_Y) {\n                    if(aroundVoxels[2].type == VOXEL_TYPE_BLOCK\n                   \t&& aroundVoxels[2].power > 0.) {\n                \t\tnewVoxels[0].power = 0.;\n                \t} else {\n                \t\tnewVoxels[0].power = MAX_REDSTONE_POWER;\n                \n                    }\n                }\n                \n                if(voxels[0].type == VOXEL_TYPE_TORCH_NEGATIVE_Y) {\n                    if(aroundVoxels[3].type == VOXEL_TYPE_BLOCK\n                   \t&& aroundVoxels[3].power > 0.) {\n                \t\tnewVoxels[0].power = 0.;\n                \t} else {\n                \t\tnewVoxels[0].power = MAX_REDSTONE_POWER;\n                \n                    }\n                }\n                \n            }\n            \n            // Mouse/Keyboard controls.\n            ivec2 mi = ivec2(floor(SCREEN_TO_TILE(iMouse.xy).xy));\n            if(all(equal(mi,ivec2(u))) &&\n               all(greaterThanEqual(mi, ivec2(0))) &&\n               all(lessThanEqual(mi, ivec2(PLAY_AREA))) ) {\n\n                float selectedVoxelType = texelFetch(iChannel0, SELECTION_COORD, 0).x;\n                Voxel selectedVoxel = DefaultPowerVoxel(selectedVoxelType);\n                \n                bvec2 isVoid = bvec2(voxels[0].type == VOXEL_TYPE_VOID, voxels[1].type == VOXEL_TYPE_VOID);\n                bvec2 isInteractive = bvec2(voxels[0].type == VOXEL_TYPE_LEVER, voxels[1].type == VOXEL_TYPE_LEVER);\n                bvec2 isBottomDependent = bvec2(IsVoxelBottomDependent(voxels[0]) || IsVoxelBottomDependent(voxels[1]));\n                \n                if(IsKeyPressed(KEY_E)) {\n                    // Interact/Place\n                    \n                    int z = int(   (!isVoid.x && !isInteractive.x)\n                                && (IsVoxelBottomDependent(selectedVoxel)\n                                && voxels[0].type == VOXEL_TYPE_BLOCK\n                                   || !IsVoxelBottomDependent(selectedVoxel)\n                                   )\n                               );\n                    \n                    if(voxels[z].type == VOXEL_TYPE_LEVER) {\n                    \tnewVoxels[z].power = float(!bool(voxels[z].power)) * MAX_REDSTONE_POWER;\n                    } else {\n                    \tnewVoxels[z] = selectedVoxel;\n                    }\n                }\n                \n                if(IsKeyPressed(KEY_Q)) {\n                    // Destroy\n                    int z = int(!isVoid.y && isVoid.x || !any(isVoid));\n                    \n                    newVoxels[z] = Void();\n                }\n            }\n            \n        \tO = VoxelsToPixel(newVoxels);\n        }\n    } else if( all(equal(ivec2(floor(u)),SELECTION_COORD))) {\n\t\t\n        O = texelFetch(iChannel0, ivec2(floor(u)),0);\n        \n        #if 0\n        if(IsKeyPressed(KEY_1)) O.x--;\n        if(IsKeyPressed(KEY_2)) O.x++;\n        O.x = clamp(O.x, 0., VOXEL_TYPE_COUNT-1.);\n        #else\n        \n        int i = -1;\n        while(++i < int(VOXEL_TYPE_COUNT)) {\n            if(IsKeyPressed(KEY_0 + float(i+1)/256.0)) {\n            \tO.x = float(i);\n            }\n        }\n        #endif\n        \n        \n    } else {\n    \tO = VOID_PIXEL;\n    }\n}","name":"Buffer A","description":"","type":"buffer"}]}