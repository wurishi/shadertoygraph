{"ver":"0.1","info":{"id":"wdjGRz","date":"1548222616","viewed":1407,"name":"Starhopper","username":"mhnewman","description":"Hopper goes up, hopper comes down.\n\n+25.997, -97.156","likes":27,"published":1,"flags":0,"usePreview":0,"tags":["rocket","spacex","hopper","starship","starhopper","bfr"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float noseLength = 3.0;\nconst float noseRadius = 0.2;\n\nconst float tankLength = 4.0;\nconst float bottomRadius = 0.1;\n\nconst float groundClearance = 1.0;\n\nconst float finHeight = 2.0;\nconst float finWidth = 1.2;\nconst float finRadius = 0.1;\nconst float finSmooth = 0.5;\n\nconst float flameWidth = 0.3;\nconst float flameLength = 6.0;\nconst float flameDiamonds = 8.0;\n\nconst float speed = 0.3;\nconst float hopHeight = 32.0;\n\nconst vec3 lightDir = vec3(0.36, -0.48, 0.8);\n\nconst int marchIter = 200;\nconst float marchDist = 50.0;\nconst float epsilon = 0.001;\n\nconst float tau = 6.283185;\n\nmat4 attitude;\n\nfloat hash1(float p) {\n\tvec2 p2 = fract(p * vec2(5.3983, 5.4427));\n    p2 += dot(p2.yx, p2.xy + vec2(21.5351, 14.3137));\n\treturn fract(p2.x * p2.y * 95.4337);\n}\n\nfloat hash1(vec3 p3) {\n    p3 = fract(p3 * vec3(5.3983, 5.4427, 6.9371));\n    p3 += dot(p3, p3.yxz + 19.1934);\n    return fract(p3.x * p3.y * p3.z);\n}\n\nfloat noise1(vec3 p) {\n    vec3 i = floor(p);\n    vec3 f = fract(p);\n\tvec3 u = f * f * (3.0 - 2.0 * f);\n    return 1.0 - 2.0 * mix(mix(mix(hash1(i + vec3(0.0, 0.0, 0.0)), \n                                   hash1(i + vec3(1.0, 0.0, 0.0)), u.x),\n                               mix(hash1(i + vec3(0.0, 1.0, 0.0)), \n                                   hash1(i + vec3(1.0, 1.0, 0.0)), u.x), u.y),\n                           mix(mix(hash1(i + vec3(0.0, 0.0, 1.0)), \n                                   hash1(i + vec3(1.0, 0.0, 1.0)), u.x),\n                               mix(hash1(i + vec3(0.0, 1.0, 1.0)), \n                                   hash1(i + vec3(1.0, 1.0, 1.0)), u.x), u.y), u.z);\n}\n\nconst mat3 m = mat3( 0.51162, -1.54702,  1.15972,\n                    -1.70666, -0.92510, -0.48114,\n                     0.90858, -0.86654, -1.55678);\n\nfloat fbm1(vec3 p) {\n    float f = noise1(p); p = m * p;\n    f += 0.5 * noise1(p); p = m * p;\n    f += 0.25 * noise1(p);\n    return f / 1.75;\n}\n\nfloat hop() {\n    return pow(max(0.45 - 0.55 * cos(speed * iTime), 0.0), 2.0);\n}\n\nfloat altitude(float h) {\n    return hopHeight * h;\n}\n\nfloat throttle() {\n    return smoothstep(0.95, 0.2, cos(speed * iTime));\n}\n\nfloat hopper(vec3 pos) {\n\tconst float halfTank = 0.5 * (tankLength - bottomRadius);\n\n    vec2 p = vec2(length(pos.xy), pos.z);\n    float dist = length(max(abs(p - vec2(0.0, bottomRadius + halfTank)) - vec2(1.0 - bottomRadius, halfTank), 0.0)) - bottomRadius;\n    \n    const float a = noseLength - noseRadius;\n    const float b = 1.0 - noseRadius;\n    const float r = 0.5 * (a * a + b * b) / b;\n    vec2 q = vec2(1.0 - r - noseRadius, tankLength);\n    vec2 d = p - q;\n    d = d / length(d);\n\tq += r * d;    \n    q.x = max(0.0, q.x);\n    q.y = min(tankLength + noseLength - noseRadius, q.y);\n    dist = min(dist, length(p - q) - noseRadius + marchDist * step(pos.z, tankLength));\n    \n    float t = floor(atan(pos.x, pos.y) * 3.0 / tau + 0.5) * tau / 3.0;\n    float c = cos(t);\n    float s = sin(t);\n\tpos.xy = mat2(c, s, -s, c) * pos.xy;\n    \n    const vec2 finTop = normalize(vec2(finHeight + groundClearance, finWidth));\n    p = (mat3(1.0, 0.0, 0.0, 0.0, finTop.y, finTop.x, 0.0, -finTop.x, finTop.y) * (pos - vec3(0.0, 1.0, finHeight))).xz;\n    p.y = max(p.y, 0.0);\n    float fin = length(p) - finRadius;\n    \n    const vec2 finBottom = normalize(vec2(groundClearance + finRadius, finWidth));\n    p = (mat3(1.0, 0.0, 0.0, 0.0, finBottom.y, finBottom.x, 0.0, -finBottom.x, finBottom.y) * (pos - vec3(0.0, 1.0, finRadius))).xz;\n    p.y = min(p.y, 0.0);\n    fin = max(fin, length(p) - finRadius);\n    \n    float h = clamp(0.5 + 0.5 * (dist - fin) / finSmooth, 0.0, 1.0);\n    dist = mix(dist, fin, h) - finSmooth * h * (1.0 - h);\n    return max(dist, -groundClearance - pos.z);\n}\n\nfloat scene(vec3 pos) {    \n    pos = (attitude * vec4(pos, 1.0)).xyz;\n\n    return hopper(pos);\n}\n\nfloat castRay(vec3 eye, vec3 ray, out float dist) {\n    dist = 0.0;\n    for (int i = 0; i < marchIter; ++i) {\n        float sdf = scene(eye + dist * ray);\n        dist += sdf;\n        if (sdf < epsilon)\n            return 1.0;\n        if (dist >= marchDist)\n            return 0.0;\n    }\n    return 1.0;\n}\n\nvec3 bump(vec3 p) {\n    return vec3(\n        fbm1(vec3(p.x + epsilon, p.y, p.z)) - fbm1(vec3(p.x - epsilon, p.y, p.z)),\n        fbm1(vec3(p.x, p.y + epsilon, p.z)) - fbm1(vec3(p.x, p.y - epsilon, p.z)),\n        fbm1(vec3(p.x, p.y, p.z + epsilon)) - fbm1(vec3(p.x, p.y, p.z - epsilon))\n    ) / epsilon;\n}\n\nvec3 normal(vec3 p) {\n    vec3 norm = normalize(vec3(\n        scene(vec3(p.x + epsilon, p.y, p.z)) - scene(vec3(p.x - epsilon, p.y, p.z)),\n        scene(vec3(p.x, p.y + epsilon, p.z)) - scene(vec3(p.x, p.y - epsilon, p.z)),\n        scene(vec3(p.x, p.y, p.z + epsilon)) - scene(vec3(p.x, p.y, p.z - epsilon))\n    ));\n        \n    p = (attitude * vec4(p, 1.0)).xyz;\n    vec3 skin = bump(p * vec3(2.0, 2.0, 1.0));\n    \n    float z = 17.0 * p.z;\n    skin.z += 0.1 * sin(z) * pow(cos(z) + 1.0, 4.0);\n    \n    return normalize(norm + 0.02 * skin);\n}\n\nfloat drawGround(vec2 pos) {\n    float pad = smoothstep(8.0, 7.5, length(pos));\n    \n    vec3 ground = bump(0.8 * vec3(pos, 0.5));\n    vec2 p = 8.0 * pos;\n    ground.y += 0.03 * pad * sin(p.x) * pow(cos(p.x) + 1.0, 8.0);\n    ground.x += 0.03 * pad * sin(p.y) * pow(cos(p.y) + 1.0, 8.0);\n    ground.xy += 40.0 *normalize(pos) * pad * pad * (pad * (pad - 2.0) + 1.0);\n    vec3 groundNorm = normalize(ground + vec3(0.0, 0.0, 6.0 + 4.0 * pad));\n    float shade = 0.25 + 0.05 * pad + 0.1 * dot(groundNorm, lightDir);\n    \n    float r = length(pos);\n    float power = throttle() / (1.0 + 0.2 * altitude(hop())) / (1.0 + r);\n    shade *= 1.0 + power * 2.0 * fbm1(vec3(6.0 * pos / (r + 1.0 / (1.0 + r)), 0.5 * r - 15.0 * iTime));\n    \n    return shade;\n}\n\nvec3 drawFlame(vec3 color, vec3 eye, vec3 ray, float dist) {\n    const vec3 up = vec3(0.0, 0.0, 1.0);\n    vec3 norm = cross(up, normalize(cross(up, ray)));\n    dist = min(dist - 1.0, dot(norm, eye) / dot(-norm, ray));\n    \n    for (int i = 0; i <= 20; ++i) {\n    \tvec3 pos = eye + (dist + 0.5 - 0.05 * float(i)) * ray;\n        float z = abs(pos.z / max(flameLength * throttle(), epsilon));\n        float r = length(pos.xy) / flameWidth;\n        \n        float diamonds = flameDiamonds * pow(z, 1.3) * (1.0 + 0.05 * hash1(iTime));\n        diamonds = abs(cos(0.5 * tau * diamonds));\n        r = r * (1.2 - 0.2 * diamonds);\n        z *= 1.0 + 0.3 * hash1(iTime + 10.0);\n        float a = 1.0 - z * z - r * r;\n        \n        z += 0.6 * (1.0 - a);\n        vec3 c = 0.8 + 0.3 * cos(tau * (0.25 * z + vec3(0.55, 0.4, 0.0)));\n        c = mix(c, vec3(1.0), 0.7 * smoothstep(0.0, 0.2, a - diamonds));\n        a = 1.5 * smoothstep(0.0, 0.2, a);\n        \n    \tcolor = mix(color, c, 0.05 * a * step(pos.z, 0.0));\n    }\n    \n    return color;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    float h = hop();\n    \n    float height = altitude(h) + groundClearance;\n    float roll = 0.1 * sin(3.0 * speed * iTime) * smoothstep(0.0, 0.5, h);\n    float c = cos(roll);\n    float s = sin(roll);\n    attitude = mat4(c, s, 0, 0, -s, c, 0, 0, 0, 0, 1, 0, 0, 0, -height, 1);\n    \n    float body = noseLength + tankLength;\n    vec3 center = vec3(0.0, 0.0, height + 0.2 * body);\n    vec3 eye = center + vec3(3.0, -0.4, 1.5 - 1.0 * h) * body;\n    float zoom = 3.0;\n    \n    vec3 forward = normalize(center - eye);\n    vec3 right = normalize(cross(forward, vec3(0.0, 0.0, 1.0)));\n    vec3 up = cross(right, forward);\n    vec2 xy = 2.0 * fragCoord - iResolution.xy;\n    vec3 ray = normalize(xy.x * right + xy.y * up + zoom * forward * iResolution.y);\n    \n    float dist;\n    float hit = castRay(eye, ray, dist);\n    vec3 pos = eye + dist * ray;\n\n    vec3 norm = normal(pos);\n    \n    vec3 reflection = reflect(ray, norm);\n    float d = 0.5 + 0.5 * dot(reflection, lightDir);\n    vec3 r = 0.5 + 0.5 * reflection;\n    float hopperShade = 0.3 + 0.15 * dot(cos(r * vec3(7.0, 7.0, 12.0)), vec3(1.0)) + 0.1 * r.z + 0.1 * step(0.35, r.z) + 0.5 * pow(d, 3.0);\n    \n    float groundDist = -eye.z / ray.z;\n    pos = eye + groundDist * ray;\n    float groundShade = drawGround(pos.xy);\n    groundShade *= 1.0 - 0.5 * castRay(pos, lightDir, dist);\n    float skyShade = 0.8 + 0.7 * ray.z;\n    float backShade = mix(groundShade, skyShade, smoothstep(-0.5, 0.0, ray.z));\n    \n    vec3 hopperColor = pow(vec3(hopperShade), vec3(1.5, 1.1, 0.7));\n    vec3 backColor = pow(vec3(backShade), vec3(1.5, 1.1, 0.7));\n    \n    backColor = drawFlame(backColor, eye - vec3(0.0, 0.0, height), ray, groundDist);\n    \n    fragColor = vec4(mix(backColor, hopperColor, hit), 1.0);\n}\n","name":"Image","description":"","type":"image"}]}