{"ver":"0.1","info":{"id":"WltcD8","date":"1608977910","viewed":54,"name":"Chihiro_raytracer03","username":"zjglwt","description":"Trying to add camera control and ideal specular reflection","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["raytracer"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nstruct rec\n{\n    int objectIndex;\n    float t;\n    vec3 normal;\n};\n\n//vec3 CameraPos = vec3(0., -5., 5.);\n//vec3 CameraDirW = normalize(vec3(0., 8., -1.));\n//vec3 CameraDirV = normalize(vec3(0., 1., 8.));\n\nfloat Near = 0.001;\nfloat Fov = 1.;\nfloat Far = 10000.;\n\nfloat phong = 64.;\n\nvec3 ambientLight = vec3(.3);\nvec3 light = vec3(1.);\nvec3 lightDir = normalize(vec3(-5., 0., -5.));\n\n#define PI 3.14159265359\n#define MAX_REFLECT 4\n\nfloat remap(float c, float d, float a, float b, float x)\n{\n    return c + (d - c) * (x - a) / (b - a);\n}\n\n// Check intersection with triangle\nbool hitTri(in vec3 E, in vec3 V, in vec3 A, in vec3 B, in vec3 C, in float t1, in float t2, out rec hitrec)\n{ \n    float a = A.x - B.x;\n    float b = A.y - B.y;\n    float c = A.z - B.z;\n    float d = A.x - C.x;    \n    float e = A.y - C.y;\n    float f = A.z - C.z;\n    float j = A.x - E.x;    \n    float k = A.y - E.y;\n    float l = A.z - E.z;\n    \n    float M = a * (e * V.z - V.y * f) + b * (V.x * f - d * V.z) + c * (d * V.y - e * V.x);\n    if (M == 0.) return false;\n    \n    float t = -(f*(a*k - j*b) + e*(j*c - a*l) + d*(b*l-k*c)) / M;\n    if (t > t1 && t < t2)\n    {\n        float gamma = (V.z*(a*k - j*b) + V.y*(j*c - a*l) + V.x*(b*l - k*c)) / M;\n        if (gamma >= 0. && gamma <= 1.){\n            float beta = (j * (e * V.z - V.y * f) + k * (V.x * f - d * V.z) + l * (d * V.y - e * V.x)) / M;\n            if (beta >= 0. && beta <= 1. - gamma)\n            {\n                hitrec.t = t;\n                vec3 normal = normalize(cross(A - B, C - B));\n                hitrec.normal = dot(V, normal) > 0. ? -normal : normal;\n                return true;\n            }\n        }\n    }\n\n    return false;\n}\n\n\nbool hitOc(in vec3 e, in vec3 v, in vec3 o, in float r, in float t1, in float t2, inout rec hitrec)\n{\n    float cosr = r * cos(iTime);\n    float sinr = r * sin(iTime);\n    vec3 p1 = vec3(o.xy, o.z + r);\n    vec3 p2 = vec3(o.x + cosr, o.y + sinr, o.z);\n    vec3 p3 = vec3(o.x - sinr, o.y + cosr, o.z);\n    vec3 p4 = vec3(o.x - cosr, o.y - sinr, o.z);\n    vec3 p5 = vec3(o.x + sinr, o.y - cosr, o.z);\n    vec3 p6 = vec3(o.xy, o.z - r);\n    \n    float maxt = t2;\n    bool ret = hitTri(e, v, p1, p2, p3, t1, maxt, hitrec);\n    if (ret) maxt = hitrec.t;\n    ret = hitTri(e, v, p1, p3, p4, t1, maxt, hitrec);\n    if (ret) maxt = hitrec.t;\n    ret = hitTri(e, v, p1, p4, p5, t1, maxt, hitrec);\n    if (ret) maxt = hitrec.t;\n    ret = hitTri(e, v, p1, p5, p2, t1, maxt, hitrec);\n    if (ret) maxt = hitrec.t;\n    ret = hitTri(e, v, p6, p2, p3, t1, maxt, hitrec);\n    if (ret) maxt = hitrec.t;\n    ret = hitTri(e, v, p6, p3, p4, t1, maxt, hitrec);\n    if (ret) maxt = hitrec.t;\n    ret = hitTri(e, v, p6, p4, p5, t1, maxt, hitrec);\n    if (ret) maxt = hitrec.t;\n    ret = hitTri(e, v, p6, p5, p2, t1, maxt, hitrec);\n    \n    return maxt < t2;\n}\n\n// Check intersection with sphere\nbool hitSp(in vec3 e, in vec3 v, in vec3 o, in float r, in float t1, in float t2, out rec hitrec)\n{\n    float A = dot(v, v);\n    float B = dot(v, e - o);\n    float C = dot(e - o, e - o) - r * r;\n    \n    float delta = B * B - A * C;\n    \n    float t = delta > 0. ? (-1. * B - sqrt(delta)) / A : -1.;\n    if (t < t2 && t > t1)\n    {\n        hitrec.t = t;\n        //hitrec.normal = e + t * v - o;\n        hitrec.normal = (e + t * v - o) / r;\n        return true;\n    }\n    return false;\n}\n\nbool hitGround(in vec3 e, in vec3 v, in float z, in float t1, in float t2, out rec hitrec)\n{\n    float t = - (e.z - z) / v.z;\n    if (t > 0. && t > t1 && t < t2)\n    {\n        hitrec.t = t;\n        hitrec.normal = vec3(0., 0., 1.);\n        return true;\n    }\n    return false;\n}\n\nbool rayhit(in vec3 e, in vec3 v, in float near, in float far, inout rec hitrec)\n{\n    float t2 = far;\n    if (hitGround(e, v, 0., near, t2, hitrec))\n    {\n        t2 = hitrec.t;\n        vec3 hit = e + hitrec.t * v;\n        float offset = abs(floor(hit.x/4.) - floor(hit.y/4.));\n        hitrec.objectIndex = mod(offset, 2.) > 0. ? 1 : 2;\n    }\n    \n    vec3 sp = vec3(0., 0., 4.);\n    float r = 4.;\n    if (hitSp(e, v, sp, r, near, t2, hitrec))\n    {\n        t2 = hitrec.t;\n        hitrec.objectIndex = 5;\n    }\n    \n    sp = vec3(8., 0., 3.);\n    r = 3.;\n    if (hitSp(e, v, sp, r, near, t2, hitrec))\n    {\n        t2 = hitrec.t;\n        hitrec.objectIndex = 3;\n    }\n    \n    float spinR = 6.5;\n    float ocx = spinR * sin(iTime);\n    float ocy = spinR * cos(iTime);\n    vec3 oc = vec3(ocx, ocy, 2.);\n    r = 2.5;\n    if (hitOc(e, v, oc, r, near, t2, hitrec))\n    {\n        t2 = hitrec.t;\n        hitrec.objectIndex = 4;\n    }\n\n    return hitrec.objectIndex > 0;\n}\n\nvec3 rayColor2(vec3 e, vec3 view, float near, float far, int reflectCount)\n{\n    if (reflectCount > MAX_REFLECT) return vec3(0., 0., 0.);\n    vec3 col = vec3(0.93, 0.97, 1.);\n    rec hitrec;\n    if (rayhit(e, view, near, far, hitrec))\n    {\n        vec3 ambientC, diffuseC, specularC;\n        if (hitrec.objectIndex == 1)\n        {\n            ambientC = vec3(.7, .7, .7);\n            diffuseC = vec3(.9, .9, .9);\n            specularC = vec3(1., 1., 1.);\n        }\n        if (hitrec.objectIndex == 2)\n        {\n            ambientC = vec3(0.05, 0.05, 0.05);\n            diffuseC = vec3(.1, .1, .1);\n            specularC = vec3(.7, .7, .7);\n        }\n        if (hitrec.objectIndex == 3)\n        {\n            ambientC = vec3(.9, .5, .1);\n            diffuseC = vec3(.9, .5, .1);\n            specularC = vec3(.9, .7, .5);\n        }\n        if (hitrec.objectIndex == 4)\n        {\n            ambientC = vec3(.1, .5, .9);\n            diffuseC = vec3(.1, .5, .9);\n            specularC = vec3(.5, .7, .9);\n        }\n        if (hitrec.objectIndex == 5)\n        {\n            ambientC = vec3(.3, .3, .3);\n            diffuseC = vec3(.3, .3, .3);\n            specularC = vec3(.3, .3, .3);\n        }\n        \n        col = ambientLight * ambientC;\n        rec hitrectemp;\n        if (!rayhit(e + hitrec.t * view, - lightDir, near, far, hitrectemp))\n        {\n            vec3 mid = normalize(- lightDir - view);\n            col += light * diffuseC * max(0., dot(- lightDir, hitrec.normal)) + light * specularC * pow(max(0., dot(mid, hitrec.normal)), phong);\n        }\n    }\n    return col;\n}\n\nvec3 rayColor(vec3 e, vec3 view, float near, float far, int reflectCount)\n{\n    if (reflectCount > MAX_REFLECT) return vec3(0., 0., 0.);\n    vec3 col = vec3(0.73, 0.77, .8);\n    rec hitrec;\n    if (rayhit(e, view, near, far, hitrec))\n    {\n        vec3 ambientC, diffuseC, specularC;\n        if (hitrec.objectIndex == 1)\n        {\n            ambientC = vec3(.7, .7, .7);\n            diffuseC = vec3(.9, .9, .9);\n            specularC = vec3(1., 1., 1.);\n        }\n        if (hitrec.objectIndex == 2)\n        {\n            ambientC = vec3(0.05, 0.05, 0.05);\n            diffuseC = vec3(.1, .1, .1);\n            specularC = vec3(.7, .7, .7);\n        }\n        if (hitrec.objectIndex == 3)\n        {\n            ambientC = vec3(.9, .5, .1);\n            diffuseC = vec3(.9, .5, .1);\n            specularC = vec3(.9, .7, .5);\n        }\n        if (hitrec.objectIndex == 4)\n        {\n            ambientC = vec3(.1, .5, .9);\n            diffuseC = vec3(.1, .5, .9);\n            specularC = vec3(.5, .7, .9);\n        }\n        if (hitrec.objectIndex == 5)\n        {\n            ambientC = vec3(.1, .1, .1);\n            diffuseC = vec3(.3, .3, .3);\n            specularC = vec3(.6, .6, .6);\n        }\n        \n        col = ambientLight * ambientC;\n        rec hitrectemp;\n        if (!rayhit(e + hitrec.t * view, - lightDir, near, far, hitrectemp))\n        {\n            vec3 mid = normalize(- lightDir - view);\n            col += light * diffuseC * max(0., dot(- lightDir, hitrec.normal)) + light * specularC * pow(max(0., dot(mid, hitrec.normal)), phong);\n        }\n        \n        if (hitrec.objectIndex == 5)\n        {\n            // Reflection recursive.\n            col += specularC * rayColor2(e + hitrec.t * view, reflect(view, hitrec.normal), near, far, reflectCount + 1);\n        }\n    }\n    return col;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy;\n    \n    uv.x -= iResolution.x / 2.;\n    uv.y -= iResolution.y / 2.;\n    \n\n    \n    float angxy = remap(0., 2. * PI, 0., iResolution.x, iMouse.x); \n    float angy = remap(PI / 6., PI / 4., 0., iResolution.y, iMouse.y);\n    float cameraDistance = remap(6., 20., 0., iResolution.y, iMouse.y);\n    float cameraDisxy = cameraDistance * cos(angy);\n    float cameraZ = cameraDistance * sin(angy) + 2.;\n    float cameraX = cameraDisxy * cos(angxy);\n    float cameraY = - cameraDisxy * sin(angxy);\n    \n    vec3 e = vec3(cameraX, cameraY, cameraZ);\n    vec3 CameraDirW = normalize(-e);\n    vec3 temp = vec3(CameraDirW.xy, CameraDirW.z + 1.);\n    //Form a camera coordinates from camera direction\n    vec3 CameraDirU = normalize(cross(CameraDirW, temp));\n    vec3 CameraDirV = cross(CameraDirU, CameraDirW);\n    float u = Near * Fov;\n    float v = u * iResolution.y / iResolution.x;\n    vec3 PixelDir = Near * CameraDirW + (2. * uv.x / iResolution.x) * u * CameraDirU\n                    + (2. * uv.y / iResolution.y) * v * CameraDirV;\n    vec3 view = normalize(PixelDir);\n    \n    vec3 col = rayColor(e, view, Near, Far, 0);\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}