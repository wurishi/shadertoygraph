{"ver":"0.1","info":{"id":"MddSzM","date":"1458532314","viewed":476,"name":"Interactive Pattern","username":"mhnewman","description":"Drag sources around by clicking on them. Add new sources by clicking in space. Delete sources by dragging them to the red square. Mashup up two previous shaders: XtB3Rd and 4dtSRn\n","likes":13,"published":1,"flags":32,"usePreview":0,"tags":["2d","mouse","wave","interference","pattern","drag","superposition"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Mashup up two previous shaders:\n// https://www.shadertoy.com/view/XtB3Rd\n// https://www.shadertoy.com/view/4dtSRn\n\nconst int maxCount = 16;\nconst float frequency = 0.15;\nconst float radius = 4.0;\n\nconst vec4 deleteRect = vec4(0.0, 0.0, 40.0, 40.0);\n\nconst float statePos = float(maxCount);\n\n#define BufA(x) texture(iChannel0, (vec2(x, 0.0) + 0.5) / iResolution.xy)\n\nbool inRect(vec2 pos, vec4 rect) {\n    return pos.x >= rect.x && pos.y >= rect.y && pos.x < rect.z && pos.y < rect.w;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec4 state = BufA(statePos);\n    \n    float dist = radius + 1.0;\n    vec2 dir = vec2(0.0, 0.0);\n    \n    for (int i = 0; i < maxCount; ++i) {\n        float f = float(i);\n        if (f >= state.y)\n            break;\n        vec2 center = BufA(f).xy;\n        float d = distance(fragCoord, center);\n        dist = min(dist, d);\n        float angle = d * frequency;\n        dir += vec2(sin(angle), cos(angle));\n    }\n    \n    vec3 color = vec3(length(dir) / state.y);\n    color = pow(color, vec3(2.0, 1.0, 0.5));\n    \n    float circle = smoothstep(radius + 1.0,  radius - 1.0, dist);\n    color = mix(color, vec3(0.8, 0.0, 0.0), circle);\n    \n    if (inRect(fragCoord, deleteRect))\n        color = mix(color, vec3(1.0, 0.0, 0.0), 0.3);\n    \n\tfragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Drag and drop framework\n// https://www.shadertoy.com/view/4dtSRn\n// by mhnewman\n//\n// maxCount := the maximum number of objects that can be represented.\n//\n// Buffer pixels (0, 0) to (maxCount - 1, 0) := the coordinates of each object.\n//  * .x := the object's x coordinate.\n//  * .y := the object's y coordinate.\n//\n// Buffer pixel (maxCount, 0) := the current state.\n//  * .x := the index of the currently selected object.\n//  * .y := the number of active objects.\n//  * .z := the mouse state.\n//\n// Buffer pixel (maxCount + 1, 0) := the mouse offset from the center of the current object.\n\nconst int maxCount = 16;\nconst float radius = 20.0;\n\nconst vec4 deleteRect = vec4(0.0, 0.0, 40.0, 40.0);\n\nconst float statePos = float(maxCount);\nconst float offsetPos = float(maxCount + 1);\n\n#define addObject(xPos, yPos) { if (p.x == count) fragColor = vec4((xPos), (yPos), 0.0, 0.0); count += 1.0; }\n\nbool inRect(vec2 pos, vec4 rect) {\n    return pos.x >= rect.x && pos.y >= rect.y && pos.x < rect.z && pos.y < rect.w;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 p = fragCoord - 0.5;\n    \n    if (p.y > 0.0 || p.x > offsetPos) {\n        fragColor = vec4(0.0);\n        return;\n    }\n    \n    if (iFrame == 0) {\n        float count = 0.0;\n\n        //\n        // Initial conditions\n        //\n        addObject(0.2 * iResolution.x, 0.2 * iResolution.y);\n        addObject(0.2 * iResolution.x, 0.8 * iResolution.y);\n        addObject(0.8 * iResolution.x, 0.8 * iResolution.y);\n        \n        if (p.x == statePos)\n            fragColor = vec4(2.0 * statePos, count, 0.0, 0.0);\n        return;\n    }\n    \n    vec4 state = texture(iChannel0, vec2(0.5 + statePos, 0.5) / iResolution.xy);\n    vec4 offset = texture(iChannel0, vec2(0.5 + offsetPos, 0.5) / iResolution.xy);\n\n    if (state.z <= 0.0 && iMouse.z > 0.0) {\n        float r = radius + 1.0;\n        for (int i = 0; i < maxCount; ++i) {\n            float f = float(i);\n            if (f >= state.y)\n                break;\n            vec4 center = texture(iChannel0, vec2(0.5 + f, 0.5) / iResolution.xy);\n            float d = distance(iMouse.xy, center.xy);\n            if (d < r) {\n                r = d;\n                state.x = f;\n                offset = center - iMouse;\n            }\n        }\n        if (r > radius) {\n            if (state.y >= statePos) {\n            \tstate.x = 2.0 * statePos;\n            } else {\n    \t        state.x = state.y;\n        \t    state.y += 1.0;\n        \t}\n        }\n    } else if (state.z > 0.0 && iMouse.z <= 0.0 && inRect(iMouse.xy, deleteRect)) {\n        if (p.x == statePos) {\n            state.x = 2.0 * statePos;\n            state.y -= 1.0;\n            state.z = iMouse.z;\n\t        fragColor = state;\n    \t    return;\n        }\n        if (p.x < state.x) {\n            fragColor = texture(iChannel0, fragCoord / iResolution.xy);\n            return;\n        }\n        fragColor = texture(iChannel0, (fragCoord + vec2(1.0, 0.0)) / iResolution.xy);\n        return;\n    }\n    state.z = iMouse.z;\n    \n    if (p.x == statePos) {\n        fragColor = state;\n        return;\n    }\n    \n    if (p.x == offsetPos) {\n        fragColor = offset;\n        return;\n    }\n\n    if (p.x == state.x && state.z > 0.0) {\n        fragColor = iMouse + offset;\n        return;\n    }\n    \n    fragColor = texture(iChannel0, fragCoord / iResolution.xy);\n}","name":"Buf A","description":"","type":"buffer"}]}