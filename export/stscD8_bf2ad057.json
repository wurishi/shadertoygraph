{"ver":"0.1","info":{"id":"stscD8","date":"1647958906","viewed":52,"name":"Ray Marching Basic 3","username":"federivero","description":"Ray Marching V-3: Figure merging","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n\n#define MAX_MARCHING_STEPS 255\n#define EPSILON 0.01\n#define MAX_DIST 1000.0\n\n// scene declaration\nconst int numCircles = 2;\n\nstruct circle{\n    vec3 center;\n    float radius;\n};\n\ncircle circles[numCircles] = circle[] (circle(vec3(0, 0, 0.2), 0.3), circle(vec3(0, 0, 0.2), 0.3)) ;\n\n\nfloat dist(vec3 v1, vec3 v2){\n    return length(v1 - v2);\n}\n\nfloat signedDistPointCircle(vec3 p, vec3 center, float radius){\n    return dist(center, p) - radius;\n}\n\n// center + side define the box\nfloat signedDistPointBox(vec3 p, vec3 center, float side){\n    vec3 offset = abs(p - center) - side;\n    \n    float unsignedDist = length(max(offset, 0.0));\n    float distInsideBox = length(min(offset, 0.0));\n    \n    return unsignedDist + distInsideBox;\n}\n \nfloat smoothMin(float d1, float d2) {\n    float k = 0.5;\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix(d2, d1, h) - k*h*(1.0-h); \n}\n\nfloat signedDistToScene(vec3 p){\n    float dist = MAX_DIST;\n    \n    for (int i = 0; i < numCircles; i++){\n        float distToCircle = signedDistPointCircle(p, circles[i].center, circles[i].radius);\n        dist = smoothMin(distToCircle, dist);\n    }\n    \n    return dist;\n}\n\nfloat sceneDistance(vec3 where){\n    return signedDistToScene(where);\n}\n\n\nfloat rayMarch(vec3 camera, vec3 viewRayDirection, float start, float end){\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneDistance(camera + depth * viewRayDirection);\n        if (dist < EPSILON) {\n            // We're inside the scene surface!\n            return depth;\n        }\n        // Move along the view ray\n        depth += dist;\n\n        if (depth >= end) {\n            // Gone too far; give up\n            return end;\n        }\n    }\n    return end;\n}\n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n\nvec3 normalAtPoint(vec3 p) {\n    return normalize(vec3(\n        signedDistToScene(vec3(p.x + EPSILON, p.y, p.z)) - signedDistToScene(vec3(p.x - EPSILON, p.y, p.z)),\n        signedDistToScene(vec3(p.x, p.y + EPSILON, p.z)) - signedDistToScene(vec3(p.x, p.y - EPSILON, p.z)),\n        signedDistToScene(vec3(p.x, p.y, p.z  + EPSILON)) - signedDistToScene(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){    \n    vec3 dir = rayDirection(45.0, iResolution.xy, fragCoord);\n    vec3 eye = vec3(0.0, 0.0, 5.0);\n\n    circles[0].center.y = cos(iTime * 1.5) / 1.4;\n    circles[0].center.x = sin(iTime * 1.5) / 1.4;\n    circles[1].center.x = sin(iTime);\n\n    float dist = rayMarch(eye, dir, 0.0, MAX_DIST);\n\n    //vec3 light = vec3(5.0 * cos(iTime), 0.0, 4.0 * sin(iTime));\n    vec3 light = vec3(0, 0.0, 8.0);\n    \n    vec3 col = vec3(0.0, 0.0, 0.0);\n    if (dist > EPSILON && dist < MAX_DIST){\n        // collision\n        vec3 p = eye + dir * dist;\n        vec3 normal = normalAtPoint(p);\n        \n        vec3 lightToP = light - p;\n        float distToLight = length(lightToP);\n        \n        float distToLightMarch = rayMarch(p + lightToP * EPSILON * 5.0, light, 0.0, MAX_DIST);\n        \n        if (distToLightMarch >= distToLight){\n            col = vec3(0.5, 0.5, 1.0) * abs(dot(normalize(lightToP), normalize(normal)));\n        }\n        \n    }\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}