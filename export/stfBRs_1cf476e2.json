{"ver":"0.1","info":{"id":"stfBRs","date":"1651293287","viewed":70,"name":"Sphere Shader using SDFs","username":"matthatter419","description":"Another basic sphere shader, this time using SDF's and ray marching to calculate shadows.","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["sphere","shader","sdfs"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Globals\nfloat aspectRatio;\nvec4 sphere = vec4(0.0,1.0,0.0,1.0); //xyzw\nvec3 light = normalize(vec3(-1.0, -0.8, -1));\nfloat ambientLight = 0.15;\n\nvec3 sphereNormal(in vec4 sphere, in vec3 position) {\n    // Sphere normals are just directed radially (normalize by radius)\n    return (position - sphere.xyz) / sphere.w;\n}\n\nvec3 planeNormal() {\n    return vec3(0.0,1.0,0.0);\n}\n\nfloat sphereIntersect(in vec3 rayOrigin, in vec3 rayDirection, in vec4 sphere) {\n\n    // Equation of sphere: |(x,y,z) - center|^2 = r^2\n    // Equation of ray: ray_O + ray_D*t = (x,y,z)\n    // Solving for t, the length of the ray that intersects the sphere:\n    // |ray_O - center|^2 + 2*<ray_D, ray_O - center>t + t^2 - r^2 = 0 (ray_D is unit length)\n    // This is a quadratic equation which we can solve for t.\n    \n    float r = sphere.w; \n    vec3 center = sphere.xyz;\n    vec3 rayOriginOffset = rayOrigin - center;\n    \n    float b = 2.0*dot(rayDirection, rayOriginOffset);\n    float c = dot(rayOriginOffset, rayOriginOffset) - r*r;\n    float discriminant = b*b - 4.0*c;\n    \n    if (discriminant < 0.0) return -1.0; // no intersection\n    \n    return ((-b - sqrt(discriminant)) / 2.0); // return smaller intersection value\n\n}\n\nfloat sphereSDF(in vec3 point, in vec4 sphere) {\n    return length(point - sphere.xyz) - sphere.w;\n}\n\nfloat planeSDF(in vec3 point) {\n    return dot(point, vec3(0,1,0));\n}\n\nfloat planeIntersect(in vec3 rayOrigin, in vec3 rayDirection) {\n    // Equation of plane: y = 0 (horizontal plane into the screen)\n    // Equation of ray: ray_O + ray_D*t = (x,y,z)\n    // Isolating the y component: ray_O_y + ray_D_y*t = 0\n    // Thus we can easily solve for t, where the plane and ray intersect.\n    \n    return -(rayOrigin.y / rayDirection.y);\n}\n\n// Cast ray at shapes in the scene and see what it intersects\n// Returns ID of object it hit, if any. Also returns intersection distance as out param.\nint castRay(in vec3 rayOrigin, in vec3 rayDirection, out float dist) {\n    int ID = -1;\n    dist = 1000.0f; // essentially functions as far-clip distance \n    \n    float tSphere = sphereIntersect(rayOrigin, rayDirection, sphere);\n    float tPlane = planeIntersect(rayOrigin, rayDirection);\n    \n    if (tSphere > 0.0) {\n        dist = tSphere;\n        ID = 1;\n    }\n    if (tPlane > 0.0 && tPlane < dist) {\n        dist = tPlane;\n        ID = 2;\n    }\n    \n    return ID;\n}\n\nvec3 rayPosition(in vec3 rayOrigin, in vec3 rayDirection, in float t) {\n    return (rayOrigin + (rayDirection * t));\n}\n\nvec2 scaleUV(in vec2 uv) {\n    return (( -1.0 + 2.0 * uv) * vec2(aspectRatio, 1.0));\n}\n\nvoid animateSphere() {\n    sphere.x = 0.5*cos(iTime);\n    sphere.z = 0.5*sin(iTime);\n}\n\n// Calculates factor to scale color depending on if a point is in shadow\nfloat calcShadow(in vec3 rayOrigin, float k) {\n\n    float shadowFactor = 1.0;\n    \n    float t = 0.01;\n    float tIntermediate;\n    int maxIter = 150;\n    for( int i=0; i < maxIter; i++ )\n    {\n        vec3 position = rayOrigin + t*(-light);\n        float dist = sphereSDF(position, sphere);\n        shadowFactor = min( shadowFactor, (k*dist)/t );\n        if( shadowFactor < 0.0001 ) break;\n        t += clamp(shadowFactor,0.01,0.1);\n    }\n\n    return smoothstep(0.0,1.0,shadowFactor);\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    animateSphere();\n\n    // Normalized pixel coordinates (from 0 to 1)\n    aspectRatio = iResolution.x/iResolution.y;\n    vec2 uv = (fragCoord / iResolution.xy);\n    vec2 scaledUV = scaleUV(uv); // shift domain to -1:1, then scale to aspect ratio\n    \n    // Create a ray with given origin and direction pointing at fragment\n    vec3 rayOrigin = vec3(0.0, 0.8, 3.0);\n    vec3 rayDirection = normalize(vec3(scaledUV, -1.0)); \n    \n    // Cast ray and find point of intersection\n    float distIntersect;\n    int intersectionID = castRay(rayOrigin, rayDirection, distIntersect);\n    vec3 position = rayPosition(rayOrigin, rayDirection, distIntersect);\n    \n    // Draw black by default\n    vec3 col = vec3(0.0, 0.0, 0.0);\n    if (intersectionID == 1) {\n        vec3 normal = sphereNormal(sphere, position);\n        float brightness = -dot(normal, light);\n        col = vec3(0.3, 0.6, 0.7) * brightness + ambientLight;\n    }\n    else if (intersectionID == 2) {\n        float shadow = calcShadow(position, 4.0);\n        col = vec3(shadow * 0.55) + ambientLight;\n    }\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n\n","name":"Image","description":"","type":"image"}]}