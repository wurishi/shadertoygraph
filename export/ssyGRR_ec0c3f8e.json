{"ver":"0.1","info":{"id":"ssyGRR","date":"1631045870","viewed":120,"name":"Alcázares Maiden Courtyard ","username":"curena","description":"Islamic star pattern found in the \"Maiden Courtyard\" in Reales Alcázares in Seville, Spain (14th century). In this version, ribbons overlaps has been corrected (there was a bug in previous versions)","likes":9,"published":1,"flags":0,"usePreview":0,"tags":["symmetry","islamicstarpattern"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// -----------------------------------------------------------------------------------\n// ISLAMIC STAR PATTERNS\n// Reales Alcázares de Sevilla, Patio de las Doncellas\n// Sevilla \"Reales Alcázares\", Maiden Courtyard.\n//\n// Carlos Ureña, Apr,2018\n// Ribbons overlap corrected, Sept 2021\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n// -----------------------------------------------------------------------------------\n\nconst int   n_aa  = 3 ;\nconst float pi    = 3.1415927 ;\nconst float xfrec = 2.6 ; \n\nbool schematic_view = false ;\n\n// ----------------------------------------------------------------\n// ISLAMIC STAR PATTERN related functions\n\n\n// parameters and pre-calculated constants\nconst float\n    sqr2       = 1.41421356237, // square root of 2\n    sqr3       = 1.73205080756, // square root of 3.0\n    sqr2_inv   = 1.0/sqr2 ,\n    sqr3_inv   = 1.0/sqr3 ,\n    cos30      = 0.86602540378, // cos(30 degrees)\n    sin30      = 0.50000000000, // sin(30 degrees)\n    l          = 5.5,          // length of triangle in NDC (mind --> 1.0)\n    l_inv      = 1.0/l ,       // length inverse\n    line_w     = 0.03,         // line width for basic symmetry lines render\n    sw         = 0.020 ;       // stripes half width for islamic star pattern\n    \nconst mat2 \n    rot_30 = mat2( cos30, sin30,    // ccw 30 deg. rotation matrix, in column order (as GLSL expects)\n                   -sin30, cos30 );  \n\nconst vec2\n    u        = 1.0*vec2( 1.0, 0.0  ) ,          // grid basis: U vector\n    v        = 0.5*vec2( 1.0, sqr3 ) ,          // grid basis: V vector\n    u_dual   = 1.0*vec2( 1.0, -sqr3_inv ) ,     // dual grid basis: U vector\n    v_dual   = 2.0*vec2( 0.0,  sqr3_inv ) ,     // dual grid basis: V vector\n    tri_cen  = vec2( 0.5, 0.5*sqr3_inv ) ;      // triangle center\n\n\n// -----------------------------------------------------------------------------------\n// point orbit transformation parameters\nint\n    nMirrorOdd = 0 ,\n    nMirror    = 0 ,\n\tnGridX     = 0 ,\n    nGridY     = 0 ;\n\n\n// -------------------------------------------------------------------------------\n// mirror reflection of 'p' around and axis through 'v1' and 'v2'\n// (only for points to right of the line from v1 to v2)\n//\nvec2 Mirror( vec2 p, vec2 v1, vec2 v2 )\n{\n \tvec2   s = v2-v1 ,\n           n = normalize(vec2( s.y, -s.x )) ;\n    float  d = dot(p-v1,n) ;\n\n    if ( 0.0 <= d )\n    {\n       nMirrorOdd = 1-nMirrorOdd ;\n       nMirror = nMirror+1 ;\n       return p-2.0*d*n ;\n    }\n    else\n       return p ;\n}\n// -------------------------------------------------------------------\n// Signed perpendicular distance from 'p' to line through 'v1' and 'v2'\n\nfloat SignedDistance( vec2 p, vec2 v1, vec2 v2 )\n{\n \tvec2   s = v2-v1 ,\n           n = normalize(vec2( s.y, -s.x )) ;\n    return dot(p-v1,n) ;\n}\n// -------------------------------------------------------------------\n// un-normalized signed distance to line\n\nfloat UnSignedDistance( vec2 p, vec2 v1, vec2 v2 )\n{\n \tvec2   s = v2-v1 ,\n           un = vec2( s.y, -s.x ) ;\n    return dot(p-v1,un) ;\n}\n// -------------------------------------------------------------------\n// Signed perpendicular distance from 'p' to polyline from 'v1'\n// to 'v2' then to 'v3'\n\nfloat DoubleSignedDistance( vec2 p, vec2 v1, vec2 v2, vec2 v3 )\n{\n\n    vec2  dir1 = v2 + normalize(v1-v2),\n          dir3 = v2 + normalize(v3-v2);\n    vec2  vm   = 0.5*(dir1+dir3) ;\n    float dm   = UnSignedDistance( p, v2, vm ) ;\n\n    if ( dm >= 0.0 )\n   \t\treturn SignedDistance( p, v1, v2 ) ;\n   \telse\n        return SignedDistance( p, v2, v3 ) ;\n}\n// -------------------------------------------------------------------------------\n// Takes 'p0' to the group's fundamental region, returns its coordinates in that region\n\nvec2 p6mm_ToFundamental( vec2 p0 )\n{\n    nMirrorOdd = 0 ;\n    nMirror    = 0 ;\n\n    // p1 = fragment coords. in the grid reference frame\n\n    vec2 p1 = vec2( dot(p0,u_dual), dot(p0,v_dual) );\n\n    // p2 = fragment coords in the translated grid reference frame\n\n    vec2 p2 = vec2( fract(p1.x), fract(p1.y) ) ;\n\n    nGridX = int(p1.x-p2.x) ; // largest integer g.e. to p1.x\n    nGridY = int(p1.y-p2.y) ; // largest integer g.e. to p2.x\n\n    // p3 = barycentric coords in the translated triangle\n    // (mirror, using line x+y-1=0 as axis, when point is right and above axis)\n\n    vec2 p3 = Mirror( p2, vec2(1.0,0.0), vec2(0.0,1.0) );\n\n    // p4 = p3, but expressed back in cartesian coordinates\n\n    vec2 p4 = p3.x*u + p3.y*v ;\n\n    // p7 = mirror around the three lines through the barycenter, perp. to edges.\n\n    vec2 p5 = Mirror( p4, vec2(0.5,0.0), tri_cen );\n    vec2 p6 = Mirror( p5, vec2(1.0,0.0), tri_cen );\n    vec2 p7 = Mirror( p6, tri_cen, vec2(0.0,0.0) );\n\n    return p7 ;\n}\n\n// --------------------------------------------------------------------\n// A possible distance function\n\nfloat DistanceFunc( float d )\n{\n   return 1.0-smoothstep( line_w*0.5, line_w*1.5, d );\n}\n\n// -------------------------------------------------------------------------------\n// Point color for basic symmetry lines in (r,g,b)\n\nvec4 p6mm_SimmetryLines( vec2 p_ndc )\n{\n\n    vec2 pf = p6mm_ToFundamental( p_ndc );\n\n    float d1 = abs(pf.y),\n          d2 = abs(pf.x-0.5),\n          d3 = abs( SignedDistance( pf, tri_cen, vec2(0.0,0.0) ) );\n\n    vec4 res = vec4( 0.0, 0.0, 0.0, 1.0 ) ;\n\n    res.r = DistanceFunc(d2);\n    res.g = DistanceFunc(d1);\n    res.b = DistanceFunc(d3);\n\n    return res ;\n}\n\n// ---------------------------------------------------------------------\n// Stripe half width for star pattern\n\nvec4 Stripe( float d )\n{\n   if ( d > sw*0.85 )\n     return vec4( 0.0,0.0,0.0,1.0 );\n   else\n     return vec4(1.0,1.0,1.0,1.0)  ;\n}\n\n// ---------------------------------------------------------------------\n// Color for islamic star pattern\n\nvec4 p6mm_pattern( vec2 p )\n{\n    vec2 pf = p6mm_ToFundamental( p );\n\n    //return p6mm_SimmetryLines( p ) ;\n    vec2 c  = tri_cen ;\n\n    // constants defining the stripes\n    float\n        f   = 0.30 ,\n        fs1 = 0.14 ,\n        s1  = fs1*c.x,\n        s2  = 0.5*s1 ;\n\n    // stripes vertexes\n    vec2\n        // upper strip\n        u1 = vec2( f*c.x, 0.0 ) ,\n        u2 = vec2( c.x, (1.0-f)*c.y ),\n\n        // lower strip\n        l1 = vec2( c.x, s1+s2 ),\n        l2 = vec2( c.x-s2, s1 ),\n        l3 = vec2( sqr3*s1, s1 ),\n\n        // right strip\n        r1 = vec2( c.x-s1, (1.0-fs1)*c.y ),\n        r2 = vec2( c.x-s1, s2 ) ,\n        r3 = vec2( c.x-s1-s2, 0.0 ),\n\n    \t// origin star strip\n        mm = vec2( s1*(sqr3-1.0/3.0), s1*(1.0-sqr3_inv) );\n\n    // signed and unsigned distances to stripes:\n\n    float\n        d1s = SignedDistance( pf, u1, u2 ) ,\n        d2s = DoubleSignedDistance( pf, l1, l2, l3 ) ,\n        d3s = DoubleSignedDistance( pf, r1, r2, r3 ) ,\n        d4s = DoubleSignedDistance( pf, u1, mm, l3 ) ,\n        d1  = abs( d1s ),\n        d2  = abs( d2s ),\n        d3  = abs( d3s ),\n        d4  = abs( d4s );\n\n\n    // stripes inclusion\n    bool in1 = ( d1 <= sw ), \n         in2 = ( d2 <= sw ), \n         in3 = ( d3 <= sw ), \n         in4 = ( d4 <= sw );\n         \n    // compute priorities for points included in two ribbons\n\n    if ( nMirrorOdd == 0 )\n    {\n       // prority to ribbon 1 in 1 & 2 overlap\n       if ( in1 && in2 )\n          in2 = false ;\n          \n       // priority to ribbon 2 in 2 & 3 overlap\n       if ( in2 && in3 )\n          in3 = false ;\n          \n       // priority to ribbon 3 in 1 & 3 overlap\n       if ( in1 && in3 )\n          in1 = false ;\n          \n       // pririty to ribbon 4 in 1 & 4 overlap\n       if ( in1 && in4 )\n          in1 = false ;\n       \n       // priority to ribbon 2 in 2 & 4 overlap\n       if ( in2 && in4 )\n          in4 = false ;\n    }\n    else \n    {\n       // use complementary priorities w.r.t. the 'if' case\n       \n       // prority to ribbon 2 in 1 & 2 overlap\n       if ( in1 && in2 )\n          in1 = false ;\n          \n       // priority to ribbon 3 in 2 & 3 overlap\n       if ( in2 && in3 )\n          in2 = false ;\n          \n       // priority to ribbon 1 in 1 & 3 overlap\n       if ( in1 && in3 )\n          in3 = false ;\n          \n       // pririty to ribbon 1 in 1 & 4 overlap\n       if ( in1 && in4 )\n          in4 = false ;\n       \n       // priority to ribbon 4 in 2 & 4 overlap\n       if ( in2 && in4 )\n          in2 = false ;\n    }\n    \n    bool \n       in_green_reg = d2s < 0.0 && d3s < 0.0 ,\n       in_blue_reg  = d1s < 0.0 || d2s < 0.0 ,\n       in_black_reg = d1s < 0.0 && d2s < 0.0 || d1s <0.0 && d3s < 0.0 ;\n       \n       \n     vec4 col ;\n    \n    // compute color for the schematic view \n    \n    if ( schematic_view )\n    {\n    \n       const float fre_width = 0.004 ; // fundamental region edge width\n       float \n          ed1 = abs(pf.y), // edge distance (y=0 line, that is, triangle baseline)\n          ed2 = abs(pf.x-0.5), // vertical line\n          ed3 = abs( UnSignedDistance( pf, vec2(0.0,0.0), vec2(cos30,sin30) ) ); // diagonal line at 30 degr.\n       \n       bool in_fr_edges = min(ed1,min(ed2,ed3)) <= 0.5*fre_width;\n       \n       if ( in_fr_edges )\n         return vec4( 0.8, 0.3, 0.3, 1.0 ); \n        \n       float dmin         = min( min(d1,d2), min(d3,d4) );\n       bool in_any_ribbon = dmin <= sw ; // == in1 || in2 || in3 || in4 ..\n       \n       if ( in_any_ribbon )\n          col = Stripe( dmin );\n       else if ( in_green_reg  )\n          col = vec4( 0.7, 0.7, 0.7, 1.0 ) ;\n       else if ( in_black_reg )\n          col = vec4( 0.5, 0.5, 0.5, 1.0 );\n       else if ( in_blue_reg )\n          col = vec4( 0.8, 0.8, 0.8, 1.0 );\n       else\n          col = vec4( 0.9, 0.9, 0.9, 1.0 ) ;\n          \n       bool in_fund = nMirror == 0 && nGridX == 0 && nGridY == 0 ;\n       \n       if ( in_fund )\n       {   col.r = 1.0 ;\n           col.g *= 0.5 ;\n           col.b *= 0.5 ;\n       }\n          \n       return col ;\n    }\n    \n    // compute final color\n\n    if ( in1 )\n        col = Stripe( d1 ) ;\n    else if ( in2 )\n        col = Stripe( d2 ) ;\n    else if ( in3 )\n        col = Stripe( d3 ) ;\n    else if ( in4 )\n        col = Stripe( d4 ) ;\n    else if ( in_green_reg  )\n        col = vec4( 0.0, 0.4, 0.0, 1.0 ) ;\n    else if ( in_black_reg )\n        col = vec4( 0.1, 0.1, 0.1, 1.0 );\n    else if ( in_blue_reg )\n        col = vec4( 0.0, 0.4, 0.9, 1.0 );\n    else\n        col = vec4( 0.6, 0.0, 0.0, 1.0 ) ;\n\n    return col ;\n}\n//-------------------------------------------------------------------------------------\nbool lastInFundamental()\n{\n \treturn nGridX ==0  && nGridY == 0 && nMirrorOdd == 0 && nMirror == 0  ;\n}\n//-------------------------------------------------------------------------------------\n// returns the (time dependent) pattern color evaluated at a point 'p'\n\nvec4 p6mm_patterns_sum_time_dep( vec2 p )\n{\n\n    const float t   = 30.0 ; // time units for each rotation (period)\n    float       a   = (iTime*2.0*pi)/t,\n                ca  = cos(a),\n                sa  = sin(a),\n                s   = 3.5 + 3.0*sin( iTime/2.0 );\n    mat2        rot = mat2( ca, -sa, sa, ca );\n    vec2        d   = 0.001*vec2( iTime, 0.2*iTime );\n\n    return p6mm_pattern( s*rot*(d+p) );\n}\n//-------------------------------------------------------------------------------------\n// returns a fixed (not time dependent) pattern color evaluated at a point 'p'\n\nvec4 p6mm_patterns_sum_fixed( vec2 p )\n{\n    return p6mm_pattern( 2.0*rot_30*p ); // rotated 30 deg. so it matches the photograph\n}\n\n//-------------------------------------------------------------------------------------\nvec4 AA_pixel_color( in vec2 pixel_coords )\n{\n    vec4        sum    = vec4( 0.0, 0.0, 0.0, 1.0 );\n    const float n      = float(n_aa);\n    const vec2  c      = vec2( 0.5, 0.5 );\n    float       scale  = xfrec/iResolution.x ;\n\n    for( int i = 0 ; i < n_aa ; i++ )\n    for( int j = 0 ; j < n_aa ; j++ )\n    {\n       vec2 samplep = pixel_coords + 1.0001*(c+vec2(i,j)/n) ;\n       //sum = sum + p6mm_patterns_sum_time_dep( scale*(samplep-0.5*iResolution.xy) ); \n       sum = sum + p6mm_patterns_sum_fixed( scale*(samplep-0.5*iResolution.xy) );\n    }\n    return sum/(n*n);\n}\n\n//-------------------------------------------------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = AA_pixel_color( fragCoord ) ;\n    //fragColor = p6mm_pattern( 0.001*fragCoord );\n}\n","name":"Image","description":"","type":"image"}]}