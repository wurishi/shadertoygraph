{"ver":"0.1","info":{"id":"Dtt3z4","date":"1682027821","viewed":33,"name":"A strange solar system","username":"i0h4oc","description":"ARI","likes":6,"published":1,"flags":48,"usePreview":0,"tags":["raycast","camera","postprocess","buffer","lesson"],"hasliked":0,"parentid":"cdGSD3","parentname":"I0H4OC"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    int k = 10;\n    ivec2 pix = ivec2(fragCoord);\n    fragColor = vec4(0);\n    for(int i = -k; i <= k; ++i)\n    {\n        for(int j = -k; j <= k; ++j)\n        {\n            fragColor += texelFetch(iChannel0,pix+ivec2(i,j),0);\n        }\n    }\n    fragColor /= float((2*k+1)*(2*k+1));\n    \n    fragColor = texelFetch(iChannel0,pix,0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XdfGRn","filepath":"/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","previewfilepath":"/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":2,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"const int trianglesNo = 4;\nTriangle triangles[trianglesNo];\n\nconst int spheresNo = 11;\nSphere spheres[spheresNo];\n\nconst int planeNo = 6;\nPlane planes[planeNo];\n\nconst int materialsNo = 11;\nMaterial materials[materialsNo];\n\nconst float air_ior = 1.0029;\n\n// ---- CAMERA and EVENTs ----\n// Common key codes (WASD instead of arrows)\n\nconst int KeyLeft  = 65;\nconst int KeyRight = 68;\nconst int KeyUp    = 87;\nconst int KeyDown  = 83;\n\n#define isKeyHeld(k)  (texelFetch(iChannel1, ivec2(k,0), 0).x > 0.)\n\nconst vec3 EyeStartPosition = vec3(10.,10.,-10.);\n\nRay Camera(vec2 fragCoord, out vec3 eye, out vec2 data2)\n{\n    /*\n        We will use the first 2 pixels of the buffer to store the information we need.\n        Every pixel contains 4 channels (floats), for RGBA. We can exploit this in the following way:\n            pixel0 = (empty, cameraX, cameraY, cameraZ)\n            pixel1 = (empty, empty, U, V)\n        where \n            cameraX, cameraY and cameraZ describe the position of the camera respectively\n            U,V give the current rotation of the camera in spherical coordinates\n\t*/\n    \n    // Ray generation\n    eye = texelFetch(iChannel0, ivec2(0,0), 0).yzw+EyeStartPosition;\t\t// camera position\n    data2 = texelFetch(iChannel0, ivec2(1,0), 0).zw;\t// spherical coordinates\n    vec2 uv\t= abs(data2);\n    \n   \tif(iMouse.z>0. || data2.x >= 0.)\t//mouse held or was held last frame\n        uv += (abs(iMouse.zw)-abs(iMouse.xy))*0.01;\n    \n    vec3 w = vec3(cos(uv.x)*cos(-uv.y),\n                  \t\t\tsin(-uv.y),\n                  sin(uv.x)*cos(-uv.y));\n    vec3 u = normalize(cross(vec3(0,1,0),w));\n\tvec3 v = cross(w,u);\n    \n    vec2 px = (fragCoord/iResolution.xy*2.-1.)*1.*normalize(iResolution.xy);\n    \n    // Keyboard and mouse handling:\n\tfloat speed = 0.2;\n    if (isKeyHeld(KeyLeft )) eye -= u*speed;\n    if (isKeyHeld(KeyRight)) eye += u*speed;\n    if (isKeyHeld(KeyUp   )) eye += w*speed;\n    if (isKeyHeld(KeyDown )) eye -= w*speed;\n    \n    if(iMouse.z>=0.)\t\t//mouse held\n        data2 = abs(data2.xy);\n\telse if(data2.x >= 0.)\t//mouse released\n        data2 = -mod(uv,2.*pi);\n    \n    // Ray generation\n    return Ray(eye,\t\t\t\t\t\t\t//P\n               0.5,\t\t\t\t\t\t\t//minT\n               normalize(w+px.x*u+px.y*v),\t//V\n               500.);\t\t\t\t\t\t//maxT\n}\n\n// ---- MAIN ----\nconst float maxT = 1000.0;\n\nTraceResult intersectTriangle(Ray ray, Triangle triangle)\n{\n    TraceResult res = TraceResult(vec3(0), ray.tmax, 0);\n\n    float EPSILON = 0.0000001;\n    \n    vec3 edge1 = triangle.b - triangle.a;\n    vec3 edge2 = triangle.c - triangle.a;\n    \n    vec3 h = cross(ray.v, edge2);\n    float a = dot(edge1, h);\n    \n    if(a > -EPSILON && a < EPSILON) {\n        return res;\n    }\n    \n    float f = 1. / a;\n    vec3 s = ray.p0 - triangle.a;\n    float u = f * dot(s, h);\n    \n    if(u < 0. || u > 1.) {\n        return res;\n    }\n    \n    vec3 q = cross(s, edge1);\n    float v = f * dot(ray.v, q);\n    \n    if(v < 0. || u + v > 1.) {\n        return res;\n    }\n    \n    // Intersection\n    float t = f * dot(edge2, q);\n    \n    if(t > EPSILON) {\n        vec3 p = ray.p0 + t * ray.v;\n        return TraceResult(normalize(p - vec3(t, u, v)), t, triangle.materialIndex);\n    } else {\n        return res;\n    }\n    \n}\n\n\nTraceResult intersectSphere(Ray ray, Sphere s)\n{\n    vec3 p0c = ray.p0 - s.c;\n    float a = dot(ray.v, ray.v);\n    float b = 2.0 * dot(p0c, ray.v);\n    float c = dot(p0c,p0c) - s.r*s.r;\n    float discriminant = b*b - 4.0*a*c;\n    if(discriminant < 0.0)\n        return TraceResult(vec3(0),ray.tmax, 0); // no intersection\n    float sqd = sqrt(discriminant);\n    float numerator = -b - sqd;\n    if(numerator < 0.0)\n        numerator = -b + sqd;\n    float t = 0.5 * numerator / a;\n    vec3 p = ray.p0 + t * ray.v;\n    vec3 normal = normalize(p - s.c);\n    return TraceResult(normal, t, s.materialIndex);\n}\n\nTraceResult intersectPlane(Ray ray, Plane plane)\n{\n    float t = dot(plane.q0-ray.p0,plane.n)/dot(ray.v,plane.n);\n    return TraceResult(plane.n,t, plane.materialIndex);\n}\n\nTraceResult raycast(Ray ray)\n{\n    TraceResult res = TraceResult(vec3(0), ray.tmax, 0);\n    for(int i = 0; i < trianglesNo; ++i)\n    {\n        TraceResult res2 = intersectTriangle(ray, triangles[i]);\n        if(res2.t < ray.tmax && res2.t > ray.tmin && res2.t < res.t){\n            res = res2;\n        }        \n    }\n    \n    for(int i = 0; i < spheresNo; ++i)\n    {\n        TraceResult res2 = intersectSphere(ray, spheres[i]);\n        if(res2.t < ray.tmax && res2.t > ray.tmin && res2.t < res.t){\n            res = res2;\n        }\n    }\n    for(int i = 0; i < planeNo; ++i)\n    {\n        TraceResult res2 = intersectPlane(ray, planes[i]);\n        if(res2.t < ray.tmax && res2.t > ray.tmin && res2.t < res.t){\n            res = res2;\n        }\n    }\n    return res;\n}\n\nfloat fresnel(vec3 v, vec3 n, float n1, float n2)\n{\n    vec3 t = normalize(refract(v, n, n1/n2));\n    \n    float ci = max(dot(v, n), 0.);\n    float ct = max(-dot(t, n), 0.);\n    \n    float Rs = (n1 * ci - n2 * ct) / (n1 * ci + n2 * ct);\n    Rs *= Rs;\n    \n    float Rp = (n1 * ct - n2 * ci) / (n1 * ct + n2 * ci);\n    Rp *= Rp;\n    \n    return 0.45 * 0.5 * (Rp + Rs) + 0.55 * sqrt(0.5 * (Rs * Rs + Rp * Rp));\n}\n\n\nvec4 missColor(Ray ray)\n{\n    return vec4(texture(iChannel2, ray.v).xyz,1.);\n}\n\nvec4 hitColor(Ray ray, TraceResult tr, vec3 lightPos)\n{\n    vec3 p = ray.p0 + ray.v*tr.t;\n    vec3 n = tr.n;\n    \n    vec3 l = lightPos-p;\n    float lightDist = length(l);\n    l /= lightDist; // normalized direction to the light\n    \n    Ray shadowray = Ray(p+0.001*n, 0.001, l, lightDist);\n                      /*     p0  , tmin , v,    tmax  */\n    TraceResult res = raycast(shadowray);\n    \n    vec3 col = vec3(0); // remains 0 if in shadow\n    if(res.t==shadowray.tmax)\n    {\n        vec3 v = -ray.v;\n             \n        vec3 ambient = dot(n, v) * materials[tr.materialIndex].emission;\n\n        //diffuse\n        float costheta = max(dot(n,l),0.);\n        vec3 k_d = materials[tr.materialIndex].color/pi;               \n\n        //specular\n        vec3 toLight = normalize(lightPos - p);\n        vec3 toEye = -ray.v;\n        vec3 k_s = vec3(0.6);\n        vec3 h = normalize(toLight+toEye);\n        float si = pow(clamp(dot(h,n),0.,1.),100.);\n\n        //sum\n        col += ambient + (k_d + k_s * si) * costheta;\n        \n        float reflectance = fresnel(ray.v, n, air_ior, materials[tr.materialIndex].ior);\n        col += (reflectance * pow(texture(iChannel2, reflect(ray.v, n)).xyz, vec3(2.2)) + (1. - reflectance) * pow(texture(iChannel2, refract(ray.v, n, air_ior / materials[tr.materialIndex].ior)).xyz, vec3(2.2)))*0.1;\n        \n        // Texture\n        vec3 color = materials[tr.materialIndex].color;\n        if(materials[tr.materialIndex].textured)\n            color += texture(iChannel3, p.xy).rgb * 0.2; \n            \n        // Attenuation\n        float d = length(lightPos - p);\n        float attenuation = clamp(10. / d, 0.0, 1.0);\n            \n        // Reflection\n        float reflectMultiplier = fresnel(ray.v, n, 1.0029, materials[res.materialIndex].ior);\n     \n        vec3 reflectedDirection = reflect(ray.v, n);\n        TraceResult res2 = raycast(Ray(p+reflectedDirection*0.01, 0.001, reflectedDirection, 500.));\n        if(res2.t < ray.tmax && res2.t > ray.tmin)\n            color += materials[res2.materialIndex].color * attenuation * reflectMultiplier;\n        else\n            color += pow(texture(iChannel2, reflectedDirection).xyz, vec3(2.2)) * attenuation * reflectMultiplier;\n            \n        // Refraction\n        float refractMultiplier = 1. - reflectMultiplier;\n        \n        vec3 refractedDirection = refract(ray.v, n, 1.0029 / materials[res.materialIndex].ior);\n        TraceResult res3 = raycast(Ray(p+refractedDirection*0.01, 0.001, reflectedDirection, 500.));\n        if(res3.t < ray.tmax && res3.t > ray.tmin)\n            color += materials[res3.materialIndex].color * attenuation * refractMultiplier;\n        else\n            color += pow(texture(iChannel2, refractedDirection).xyz, vec3(2.2)) * attenuation * refractMultiplier;\n        \n        // Blinn-Phong\n        ambient = dot(n, v) * materials[tr.materialIndex].emission;\n        vec3 diffuse = vec3(max(dot(n,l),0.));\n        vec3 specular = vec3(max(0.2*pow(dot(n,h),200.0),0.0));\n        col = ambient + (diffuse + specular) * color;        \n    }\n    return vec4(col,1.);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Description of materials\n    materials[0] = Material(vec3(253., 184., 19.)/255., 0.8, vec3(253., 184., 19.)/(255.*8.), 0.9, false, 2.417); // sun    materials[1] = Material(vec3(173., 168., 165.)/255., 0., vec3(0., 0., 0.), 0.0, false, 1.00029); // mercury\n    materials[2] = Material(vec3(139., 145., 161.)/255., 0.3, vec3(0., 0., 0.), 0.8, false, 0.); // venus\n    materials[3] = Material(vec3(79., 76., 176.)/255., 0.3, vec3(0., 0., 0.), 0.7, false, 0.); // earth\n    materials[4] = Material(vec3(153., 133., 122.)/255., 0.3, vec3(0., 0., 0.), 0.6, false, 0.); // mars\n    materials[5] = Material(vec3(64., 68., 54.)/255., 0.3, vec3(0., 0., 0.), 0.5, false, 0.); // jupiter\n    materials[6] = Material(vec3(52., 62., 71.)/255., 0.3, vec3(0., 0., 0.), 0.4, false, 0.); // saturn\n    materials[7] = Material(vec3(213., 251., 252.)/255., 0.3, vec3(0., 0., 0.), 0.3, false, 0.); // uranus\n    materials[8] = Material(vec3(33., 35., 84.)/255., 0.3, vec3(0., 0., 0.), 0.2, false, 0.); // neptune\n    materials[9] = Material(vec3(20., 20., 90.)/255., 0.5, vec3(0., 0., 0.), 0.7, true, 5.); // space\n    materials[10] = Material(vec3(200., 200., 200.)/255., 0.2, vec3(0.1, 0.1, 0.2), 0.0, false, 2.417); // tetra\n\n    float second = 6.28;\n    float mercurySpeed = second / (87.9 / 50.);\n    float venusSpeed = second / (224.7 / 50.);\n    float earthSpeed = second / (365.25 / 50.);\n    float marsSpeed = second / (686.9 / 50.);\n    float jupiterSpeed = second / (4332.8 / 50.);\n    float saturnSpeed = second / (10755.7 / 50.);\n    float uranusSpeed = second / (30687.1 / 50.);\n    float neptuneSpeed = second / (60190. / 50.);\n    \n    float sunSize = 80000. / 20000.;\n    float mercurySize = 2440. / 20000.;\n    float venusSize = 6052. / 20000.;\n    float earthSize = 6371. / 20000.;\n    float marsSize = 3390. / 20000.;\n    float jupiterSize = 69911. / 20000.;\n    float saturnSize = 58232. / 20000.;\n    float uranusSize = 25362. / 20000.;\n    float neptuneSize = 24622. / 20000.;\n\n    // Description of spheres\n    float distBetwPl = 4.;\n    \n    mat3 yrot = mat3(cos(iTime), 0., sin(iTime),\n                     0., 1., 0.,\n                     -sin(iTime), 0., cos(iTime));\n    \n    spheres[0] = Sphere(vec3(0., 0., 0.), sunSize, 0);\n    spheres[1] = Sphere(vec3(1.3*distBetwPl*sin(mercurySpeed*iTime),0., 1.3*distBetwPl*cos(mercurySpeed*iTime)), mercurySize, 1);\n    spheres[2] = Sphere(vec3(2.*distBetwPl*sin(venusSpeed*iTime),0., 2.*distBetwPl*cos(venusSpeed*iTime)), venusSize, 2);\n    spheres[3] = Sphere(vec3(2.7*distBetwPl*sin(earthSpeed*iTime),0., 2.7*distBetwPl*cos(earthSpeed*iTime)), earthSize, 3);\n    spheres[4] = Sphere(vec3(3.5*distBetwPl*sin(marsSpeed*iTime),0., 3.5*distBetwPl*cos(marsSpeed*iTime)), marsSize, 4);\n    spheres[5] = Sphere(vec3(5.*distBetwPl*sin(jupiterSpeed*iTime),0., 5.*distBetwPl*cos(jupiterSpeed*iTime)), jupiterSize, 5);\n    spheres[6] = Sphere(vec3(7.3*distBetwPl*sin(saturnSpeed*iTime),0., 7.3*distBetwPl*cos(saturnSpeed*iTime)), saturnSize, 6);\n    spheres[7] = Sphere(vec3(9.*distBetwPl*sin(uranusSpeed*iTime),0., 9.*distBetwPl*cos(uranusSpeed*iTime)), uranusSize, 7);\n    spheres[8] = Sphere(vec3(10.5*distBetwPl*sin(neptuneSpeed*iTime),0., 10.5*distBetwPl*cos(neptuneSpeed*iTime)), neptuneSize, 8);\n    \n    // Description of plane\n    planes[0] = Plane(vec3(0., -5., 0.), normalize(vec3(0,1,0)), 9);\n    //planes[1] = Plane(vec3(0., 60., 0.), normalize(vec3(0,-1,0)), 9);\n    //planes[2] = Plane(vec3(60., 0., 0.), normalize(vec3(-1,0,0)), 9);\n    //planes[3] = Plane(vec3(0., 0., 60.), normalize(vec3(0,0,-1)), 9);\n    //planes[4] = Plane(vec3(-60., 0., 0.), normalize(vec3(1,0,0)), 9);\n    //planes[5] = Plane(vec3(0., 0., -60.), normalize(vec3(0,0,1)), 9);\n    \n    // Description of tetrahedron\n    vec3 a = vec3(0., 2.2*sin(iTime)+4.5, 1.);\n    vec3 b = vec3(1., 2.2*sin(iTime)+4.5, 0.);\n    vec3 c = vec3(0., 2.2*sin(iTime)+3.5, 0.);\n    vec3 d = vec3(1., 2.2*sin(iTime)+3.5, 1.);\n    \n    \n    triangles[0] = Triangle(a, b, c, 10);\n    triangles[1] = Triangle(a, b, d, 10);\n    triangles[2] = Triangle(a, c, d, 10);\n    triangles[3] = Triangle(b, c, d, 10);\n\n    vec3 eye; vec2 data;                    // this will be saved into first two pixels\n    Ray ray = Camera(fragCoord, eye, data); // Generate ray from pixel\n    \n    \n    vec3 rayPos = ray.p0;\n    vec3 rayDir = ray.v;\n    \n    vec4 color = vec4(0.);\n    \n    float numIter = 1.;\n    \n    for(int i = 0; i < int(numIter); ++i)\n    {\n        TraceResult result = raycast(ray);\n        \n        if(ray.tmax<=result.t)\n        {\n            color += missColor(ray);\n        }\n        else\n        {\n            color += (hitColor(ray, result, vec3(30.*sin(iTime), 40., -30.*cos(iTime))) + hitColor(ray, result, vec3(-30.*sin(iTime), 40., 30.*cos(iTime))));\n        }\n        \n        rayPos = (rayPos + rayDir * result.t) + result.n * 0.001;\n        rayDir = normalize(result.n);\n        ray = Ray(rayPos, ray.tmin, rayDir, ray.tmax);\n    }\n    fragColor = color/numIter;\n    \n\n    //vec4 prev = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    //fragColor = 0.2*prev + 0.8*fragColor;   // Motion blur\n    //fragColor.w = result.t;\n\n    // First two pixels are reserved\n    if(fragCoord.x == 0.5 && fragCoord.y == 0.5) // pixel (0,0)\n        fragColor.yzw = eye-EyeStartPosition;\n    if(fragCoord.x == 1.5 && fragCoord.y == 0.5) //pixel (1,0)\n        fragColor.zw = data;\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"const float pi = 3.1415926535897932384626433832795;\n\n#define PI              3.14159\n#define ONE_OVER_PI     0.31831\n\nstruct Material {\n    vec3  color;        // [0,1/pi]\n    float roughness;    // [0,~7]\n    vec3  emission;\t    // [0, inf] ambient color\n    float metalness;    // 0.02-0.05 for non-metals, 0.6-0.9 for metals\n    bool textured;\n    float ior;\n};\n\n\nstruct Sphere {\n    vec3 c;    // center\n    float r;   // radius\n    int materialIndex;\n};\n\nstruct Plane {\n    vec3 q0;    // any point on the plane\n    vec3 n;     // normal\n    int materialIndex;\n};\n\nstruct Triangle\n{\n    vec3 a;\n    vec3 b;\n    vec3 c;\n    int materialIndex;\n};\n\nstruct Ray\n{\n\tvec3 p0;    // ray origin if tmin=0\n\tfloat tmin; // omit solutions t<tmin\n\tvec3 v;     // direction\n\tfloat tmax; // omit solutions t>tmax\n};\n\nstruct TraceResult\n{\n    vec3 n;  // Normal vector on surface\n    float t; // Distance taken on ray\n    int materialIndex;\n};\n\n","name":"Common","description":"","type":"common"}]}