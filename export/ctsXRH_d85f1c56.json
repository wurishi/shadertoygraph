{"ver":"0.1","info":{"id":"ctsXRH","date":"1674293000","viewed":218,"name":"foghorn","username":"hayabuzo","description":"This one is inspired by BigWings tutorial \"The Drive Home\". I wanted to create an opposition of two states of mind: a long wander in darkness and fog, and a brief touch on something high and light.","likes":13,"published":1,"flags":64,"usePreview":0,"tags":["sun","sky","fog","rain","lighthouse"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4tjSWc","filepath":"https://soundcloud.com/tripalium-corp/tripalium-podcast-34-periskop?utm_source=clipboard&utm_medium=text&utm_campaign=social_sharing","previewfilepath":"https://soundcloud.com/tripalium-corp/tripalium-podcast-34-periskop?utm_source=clipboard&utm_medium=text&utm_campaign=social_sharing","type":"musicstream","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n#define PI 3.14159265359             \n#define TWO_PI 6.28318530718\n#define s(a,b,t) smoothstep(a,b,t)\n\nfloat uv2frandsin(vec2 uv) {\n\n\treturn fract( sin( mod(uv.x*583.4,PI) + mod(uv.y*3025.7,PI)) * 9553.2 ); \n\t\n}\n\nfloat uv2franddot(vec2 uv) {\n\n\tuv = fract( uv * vec2(253.63, 77.32) );\n\tuv *= dot( uv, uv + 902.84 );\n\treturn fract( uv.x + uv.y );\n\n}\n\nvec2 uv2uvranddot(vec2 uv) {\n\tfloat n = uv2frandsin(uv);\n\treturn vec2(n, uv2franddot(uv+n));\n}\n\nfloat uv2noise(vec2 uv) {\n\n\tfloat s = 10.0;\n\tvec2  uvp = fract(uv*s);\n\t      uvp = smoothstep(0.0,1.0,uvp);\n\t\n\tvec2  id = floor(uv*s);\n\n\tfloat k = 1.0;\n\n\tfloat ul = uv2frandsin(id+vec2(0.0,0.0));\n\tfloat ur = uv2frandsin(id+vec2(1.0,0.0));\n\tfloat dl = uv2frandsin(id+vec2(0.0,1.0));\n\tfloat dr = uv2frandsin(id+vec2(1.0,1.0));\n\n\tfloat us = mix(ul,ur,uvp.x);\n\tfloat ds = mix(dl,dr,uvp.x);\n\tfloat ns = mix(us,ds,uvp.y);\n\n\treturn ns;\n\n}\n\nfloat uv2onoise(vec2 uv) {\n\n  float c = 0.0;\n\t\t\t\tc += uv2noise(uv);\n\t\t\t\tc += uv2noise(uv*2.0)*0.5;\n\t\t\t\tc += uv2noise(uv*4.0)*0.25;\n\t\t\t\tc += uv2noise(uv*8.0)*0.125;\n\t\t\t\tc += uv2noise(uv*16.0)*0.0625;\n\n\t\t\t\tc /= 2.0;\n\treturn c;\n\n}\n\nfloat df4line(vec2 p, vec2 a, vec2 b) {\n\n\tvec2 ap = p-a;\n\tvec2 ab = b-a;\n\tfloat t = clamp ( dot(ap,ab) / dot(ab,ab) , 0.0, 1.0 );\n\treturn length(ap - ab*t);\n\n}\n\nfloat f2f(float f) {\n\treturn clamp(f, 0.0, 1.0);\n}\n\nfloat fog(vec2 uv,float t, vec2 dir) {\n\n\tvec2  shift = vec2(floor(t),0.0);\n\tfloat zoom = 1.0/(fract(t)*5.0+1.0);\n\tfloat alpha = (sin(fract(t)*TWO_PI-PI*0.5)*0.5+0.5);\n\n\treturn  uv2onoise( uv*zoom + shift + dir*1.0 ) * alpha; }\n\nvec3 hsb2rgb ( vec3 c ) {\n  // Color conversion function from Sam Hocevar: \n  // lolengine.net/blog/2013/07/27/rgb-to-hsv-in-glsl\n  vec4   K = vec4(1.0,2.0/3.0,1.0/3.0,3.0);\n  vec3   p = abs(fract(c.xxx+K.xyz)*6.0-K.www);\n  return c.z*mix(K.xxx,clamp(p-K.xxx,0.0,1.0),c.y); }\n\nfloat fsin(float t) {\n\treturn sin(mod(t,TWO_PI))*0.5+0.5;\n}\n\nfloat n(float t) {\n\treturn fract(sin(t*432.63)*984.32); }\n\nvec2 Rain(vec2 uv, float t, float k) {\n\n\tuv.y = -uv.y;\n\t\n\n\tvec2 a = vec2(3.0, 1.0);    //aspect ratio; задаем размер боксов с каплями\n\tt *= 40.0;                  // ускоряем время\n\n\tvec2  st = uv*a;            // создаем новую систему координат с боксами\n\t\n\tvec2  id = floor(st);       // каждому боксу присваиваем уникальный идентификатор\n\t\t\t\tt *= n(id.x)+0.5;     // одни слобцы боксов будут работать быстрее других\n\t\t\t\tst.y += t*.22;        // задаем движение боксов вниз по оси Y\n\t\n\tfloat shift = fract(sin(id.x*64.36)*376.54);    // у каждого слобца боксов будет свой рандомный сдвиг по оси Y\n\t\t\t\tst.y += shift;                            // сдвигаем боксы\n\t\t\t\tuv.y += shift;                            // и следы капель внутри боксов\n\t\n\t\t\t\tid = floor(st);       // идентификаторы должны двигаться вместе с боксами, обновляем их\n\t\t\t\tst = fract(st)-.5;    // замыкаем и центруем систему координат\n\n\t\t\t\tuv.x += 0.02 * sin(uv.y * 50.0 * n(id.x+id.y*23.5)); \n\t\t\t\tuv.y += 0.02 * sin(uv.x * 50.0 * n(id.y+id.x*23.5)); \n\t\n\t\t\t\t// у каждого бокса будет своя начальая позиция капли в зависимости от идентификатора\n\t\t\t  t += fract(sin(id.x*45.36+id.y*72.9)*376.54) * TWO_PI;\n\n\t\t\t\t// функция движения капли внутри бокса\n\tfloat y = -sin(t+sin(t+sin(t)*.5))*(0.43-0.2*n(id.y)); \n\tfloat x = 0.3*sin(uv.y+10.0*n(id.y));\n\n\tvec2  p1 = vec2(x, y);        // задаем координаты капли\n\tvec2  o1 = (st-p1)/a;         // масштабируем координаты капли на локальную систему координат\n\tfloat d = length(o1);         // создаем distance field от координат капли \n\tfloat m1 = s(.07, .0, d);     // рисуем контур капли\n\t\n\tfloat per = 1.5 + n(id.x*23.3+id.y*13.2)*1.0;                         // пусть следы от капли будут на разном расстоянии\n\tvec2  o2 = ( fract(uv*a.x*vec2(1.0,per)) -0.5 - x) / vec2(1.0,per);   // задаем следы от капли\n\t      d = length(o2);                                                 // создаем DF\n\tfloat m2 = s(.3*(.5-st.y), .0, d);   // рисуем контур: размер зависит от расстояния до края                                \n\t      m2 *= s(-.1,.1,st.y-p1.y);     // скрываем следы под каплей\n\n\t// if (st.x>.46 || st.y>.49) m1 = 1.0;  // рисуем обводку бокса\n\n\tm1 *= step(k,n(dot(id.x,id.y)));\n\tm2 *= step(k,n(dot(id.x,id.y)));\n\n\to1.y = -o1.y;\n\to2.y = -o2.y;\n\n\treturn vec2(m1*o1*30.0 + m2*o2*10.0);\n\t// return vec2(m1*30.0 + m2*30.0);\n}\n\nvec2 Rain2(vec2 uv, float t, float k) {\n\n\tuv.y = -uv.y;\n\n\n\tvec2 a = vec2(10.0, 1.0);    //aspect ratio; задаем размер боксов с каплями\n\tt *= 40.0;                  // ускоряем время\n\n\tvec2  st = uv*a;            // создаем новую систему координат с боксами\n\t\n\tvec2  id = floor(st);       // каждому боксу присваиваем уникальный идентификатор\n\t\t\t\tt *= n(id.x)+0.5;     // одни слобцы боксов будут работать быстрее других\n\t\t\t\tst.y += t*.22;        // задаем движение боксов вниз по оси Y\n\t\n\tfloat shift = fract(sin(id.x*64.36)*376.54);    // у каждого слобца боксов будет свой рандомный сдвиг по оси Y\n\t\t\t\tst.y += shift;                            // сдвигаем боксы\n\t\t\t\tuv.y += shift;                            // и следы капель внутри боксов\n\n\n\t\t\t\tid = floor(st);       // идентификаторы должны двигаться вместе с боксами, обновляем их\n\t\t\t\tst = fract(st)-.5;    // замыкаем и центруем систему координат\n\t\n\t\t\t\tuv.x += 0.005 * sin(uv.y * 50.0 * n(id.x+id.y*23.5)); \n\n\t\t\t\t// у каждого бокса будет своя начальая позиция капли в зависимости от идентификатора\n\t\t\t  t += fract(sin(id.x*45.36+id.y*72.9)*376.54) * TWO_PI;\n\n\t\t\t\t// функция движения капли внутри бокса\n\tfloat y = -sin(t+sin(t+sin(t)*.5))*(0.43-0.2*n(id.y)); \n\tfloat x = 0.0;\n\n\tvec2  p1 = vec2(x, y);        // задаем координаты капли\n\n\tfloat per = iResolution.y;                       \n\tvec2  o2 = ( fract(uv*a.x*vec2(1.0,per)) -0.5 - x) / vec2(1.0,per);   // задаем следы от капли\n\tfloat d = length(o2);                                                 // создаем DF\n\tfloat m2 = s(.4, .0, d);              // рисуем контур: размер зависит от расстояния до края                                \n\t      m2 *= -s(-.1,.1,st.y-p1.y);     // скрываем следы под каплей\n\t\t\t\tm2 *= (st.y-0.5);\n\n\to2.y = -o2.y;\n\n\tm2 *= step(k,n(id.x+id.y));\n\n\treturn vec2(m2*o2*30.0);\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n    vec2  uv = fragCoord/iResolution.xy; uv.y = 1.0-uv.y;\n          uv -= 0.5; uv.x *= iResolution.x/iResolution.y;\n\n    float it = (iTime+20.0+14.0)*0.16;\n    float frc = it*5.0;\n    float blend = min(  sin(frc*0.3)*0.5+0.5,  1.0+1.0*sign(sin(frc*0.3*0.5+PI*0.25)));\n    \n\tfloat t = it;\n    float tk = 1.0;\n    \n          // flare of lighthouse will be little above horizon line\n\t\t  uv.y += 0.2*(1.0-blend);\t\n\n          // shaking function * only for night mode\n\tfloat shk = fsin(t*tk*15.0) * step(blend,0.01);\n    \n          // applying shaking to whole uv\n\t\t  uv += shk * 0.02 * vec2(uv2uvranddot(vec2(t*tk*5.0,t*tk*5.0+63.7))-0.5);\n\n          // radius of camera movement * scaling to mode\n\tfloat r = 0.05*sin(mod(t*4.2,TWO_PI)) * (1.0+(1.0-blend));\t\t\n    \n          // direction of movement\n\tvec2  dir = sin( mod( vec2(4.32*t,7.16*t), vec2(TWO_PI) ))*r;\t     \n\n\t\t  // sky upper and lower parts have little different colors\n\tvec3  su = hsb2rgb(vec3( 0.6-blend,     0.5*blend*blend, blend));\n\tvec3  sd = hsb2rgb(vec3( 0.6-blend-0.1, 0.7*blend, blend*0.85 ));\n\tvec3  col = mix(su,sd,f2f(uv.y));\n\n          // position of raindrops\n\tvec2  uvr = uv+dir*0.2;\t\t\t\n\n\tvec2  rainDistort = vec2(0.0);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  \t  // adding rain\n\t      rainDistort += 0.05*mix( vec2(0.0), Rain ((uvr)*3.0, t*5.0*.92, 0.010)*6., 1.0-blend);\n\t      rainDistort += 0.05*mix( vec2(0.0), Rain ((uvr)*5.0, t*5.0*.72, 0.080)*6., 1.0-blend);\n\t      rainDistort += 0.05*mix( vec2(0.0), Rain2((uvr)*0.5, t*5.0*.25, 0.500)*1., 1.0-blend);\n\n\t\t  uv -= rainDistort;  // distorting coordinates with raindrops\n\n\tvec2  p = uv+dir*2.0;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// position of lighthouse's flare\n\t      p.x += mix(-0.1,0.1,abs(sin(mod(t*7.5,TWO_PI)))) * step(blend,0.01);  // spinning simulation\n\tfloat phase = f2f(sin(mod(p.x*5.0+t*tk*15.0,TWO_PI)));                      // phase of lighthouse\n\n          // drawing main light\n          col += f2f( 0.003/dot(p,p) * mix(phase* s(0.02,0.01,blend) ,1.0,blend*blend) )  // lighthouse\n          * vec3(1.0,1.0,0.90+shk*0.2+sqrt(blend)*0.2) \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// color of light\n          * (step(blend,0.01) + s(0.03,0.1,blend));\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// hiding a moment before spinning\n\n          // some inward/outward effect on mode change\n\t\t  t = mix (t, t+2.0, blend);\n\tfloat fs = 2.0;     // fog speed\n\t\t\t\t\n\tfloat f = 0.0;             // adding fog\n          f += fog(uv,fs*t*tk+0.0,dir)*0.33;\n          f += fog(uv,fs*t*tk+5.3,dir)*0.33;\n          f += fog(uv,fs*t*tk+9.6,dir)*0.33;\n  \n          // blacklight of lighthouse\n          f *= 1.0 + f2f(sin(mod(uv.x*1.0+t*tk*15.0,TWO_PI))) * step(blend,0.01) * (1.0-1.0*abs(p.y));\n          \n          // some vignetting\n          f -= (1.0-blend)*0.3*(fsin(t*5.0)+0.5)*s(0.0,1.0,length(fragCoord/iResolution.xy-0.5));   \n          \n          // cut some upper fog in day mode\n          f = mix(f, f*f2f(p.y+0.7), blend);\t\t\n  \n          // apply fog to sky\n          col = mix (col, vec3(1.0), f*(1.0+blend*1.5));\n\n          fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}