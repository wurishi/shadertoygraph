{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[],"code":"\nvec2 noiseOffset = vec2(0.0, 0.0);\nvec2 noiseScale = vec2(16.0, 16.0);\nvec2 noiseScale2 = vec2(200.0, 200.0);\nvec2 noiseScale3 = vec2(50.0, 50.0);\nvec2 cloudNoise = vec2(10.0, 30.0);\n\nfloat cloudiness = 0.5;\n\nvec3 ocean = vec3(13.0 / 255.0, 55.0 / 255.0, 79.0 / 255.0);\nvec3 ice = vec3(250.0 / 255.0, 250.0 / 255.0, 250.0 / 255.0);\nvec3 cold = vec3(53.0 / 255.0, 102.0 / 255.0, 100.0 / 255.0);\nvec3 temperate = vec3(79.0 / 255.0, 109.0 / 255.0, 68.0 / 255.0);\nvec3 warm = vec3(119.0 / 255.0, 141.0 / 255.0, 82.0 / 255.0);\nvec3 hot = vec3(223.0 / 255.0, 193.0 / 255.0, 148.0 / 255.0);\n\n//\n// GLSL textureless classic 2D noise \"cnoise\",\n// with an RSL-style periodic variant \"pnoise\".\n// Author:  Stefan Gustavson (stefan.gustavson@liu.se)\n// Version: 2011-08-22\n//\n// Many thanks to Ian McEwan of Ashima Arts for the\n// ideas for permutation and gradient selection.\n//\n// Copyright (c) 2011 Stefan Gustavson. All rights reserved.\n// Distributed under the MIT license. See LICENSE file.\n// https://github.com/ashima/webgl-noise\n//\n\nvec4 mod289(vec4 x)\n{\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute(vec4 x)\n{\n  return mod289(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nvec2 fade(vec2 t) {\n  return t*t*t*(t*(t*6.0-15.0)+10.0);\n}\n\n// Classic Perlin noise, periodic variant\nfloat pnoise(vec2 P, vec2 rep)\n{\n  vec4 Pi = floor(P.xyxy) + vec4(0.0, 0.0, 1.0, 1.0);\n  vec4 Pf = fract(P.xyxy) - vec4(0.0, 0.0, 1.0, 1.0);\n  Pi = mod(Pi, rep.xyxy); // To create noise with explicit period\n  Pi = mod289(Pi);        // To avoid truncation effects in permutation\n  vec4 ix = Pi.xzxz;\n  vec4 iy = Pi.yyww;\n  vec4 fx = Pf.xzxz;\n  vec4 fy = Pf.yyww;\n\n  vec4 i = permute(permute(ix) + iy);\n\n  vec4 gx = fract(i * (1.0 / 41.0)) * 2.0 - 1.0 ;\n  vec4 gy = abs(gx) - 0.5 ;\n  vec4 tx = floor(gx + 0.5);\n  gx = gx - tx;\n\n  vec2 g00 = vec2(gx.x,gy.x);\n  vec2 g10 = vec2(gx.y,gy.y);\n  vec2 g01 = vec2(gx.z,gy.z);\n  vec2 g11 = vec2(gx.w,gy.w);\n\n  vec4 norm = taylorInvSqrt(vec4(dot(g00, g00), dot(g01, g01), dot(g10, g10), dot(g11, g11)));\n  g00 *= norm.x;  \n  g01 *= norm.y;  \n  g10 *= norm.z;  \n  g11 *= norm.w;  \n\n  float n00 = dot(g00, vec2(fx.x, fy.x));\n  float n10 = dot(g10, vec2(fx.y, fy.y));\n  float n01 = dot(g01, vec2(fx.z, fy.z));\n  float n11 = dot(g11, vec2(fx.w, fy.w));\n\n  vec2 fade_xy = fade(Pf.xy);\n  vec2 n_x = mix(vec2(n00, n01), vec2(n10, n11), fade_xy.x);\n  float n_xy = mix(n_x.x, n_x.y, fade_xy.y);\n  return 2.3 * n_xy;\n}\n\nfloat spow(float x, float y) { float s = sign(x); return s * pow(s * x, y); }\n\nvec4 planet(in vec2 pix, in float rotspeed, in float rot, in float light, in float zLight, in float time) \n{\n    vec2 p = -1.0 + 2.0 * pix;\n    p.x *= iResolution.x / iResolution.y;\n    p = mat2(cos(rot), sin(rot), -sin(rot), cos(rot)) * p;\n\t\n    vec3 ro = vec3( 0.0, 0.0, 2.25 );\n    vec3 rd = normalize( vec3( p, -2.0 ) );\n\n    vec3 col = vec3(0.0);\n\n    // intersect sphere\n    float b = dot(ro,rd);\n    float c = dot(ro,ro) - 1.0;\n    float h = b*b - c;\n\tfloat t = -b - sqrt(h);\n\tvec3 pos = ro + t*rd;\n\tvec3 nor = pos;\n\n\t// texture mapping\n\tvec2 uv;\n\tuv.x = atan(nor.x,nor.z)/6.2831 + rotspeed*time;\n\tuv.y = acos(nor.y)/3.1416;\n\tuv.y = 0.5 + spow(uv.y - 0.5, 1.2);\n\tuv += noiseOffset;\n\t\n\tfloat n2 = pnoise(uv * noiseScale2, noiseScale2) * 0.05;\n\tfloat n = pnoise(uv * noiseScale, noiseScale) + n2;\n\t\n\tfloat temp = cos(nor.y * 4.0) + pnoise(uv * noiseScale3, noiseScale3) * 0.8 + n * 0.5;\n\t\n\tfloat oceanity = min(1.0, 1.0 - smoothstep(0.19, 0.2, n) + 1.0 - smoothstep(0.05, 0.08, mod(temp - uv.x * 35.0 + 0.3, 1.0) + n * n * 0.35));\n\t\t\t\n\tfloat iceity = max(0.0, 1.0 - oceanity - smoothstep(-0.8, -0.6, temp));\n\tfloat coldity = max(0.0, 1.0 - iceity - oceanity - smoothstep(-0.4, 0.0, temp));\n\tfloat temperateity = max(0.0, 1.0 - iceity - coldity - oceanity - smoothstep(0.3, 0.8, temp));\n\tfloat warmity = max(0.0, 1.0 - iceity - coldity - temperateity - oceanity - smoothstep(1.05, 1.3, temp));\n\tfloat hottity = max(0.0, 1.0 - oceanity - iceity - coldity - temperateity - warmity);\n\t\n\tcol = ocean * oceanity + ice * iceity + cold * coldity + temperate * temperateity + warm * warmity + hot * hottity;\n\t\n\tcol *= (0.7 + abs(temp + n * 0.2) * 0.3);\n\tcol *= 0.92 + step(0.1, mod(n2, 0.4)) * 0.08;\n\tcol *= 1.0 + step(0.39, mod(n + uv.x, 0.4)) * 0.1;\n\t\n\tfloat cloudN = max(0.0, pnoise((uv + vec2(rotspeed * time, 0)) * cloudNoise, cloudNoise) + cloudiness + n2);\n\tcol *= 0.7;\n\tcol += vec3(cloudN, cloudN, cloudN) * 0.5;\n\n    float lighting = max(sin(light) * nor.y * 2.0 + cos(light) * nor.x * 2.0 + nor.z * zLight,0.0);\n\tcol *= 0.2 + lighting * 0.7;\n\n    return vec4(mix(vec3(0.0), col, step(0.0, h)), 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time = iTime * 0.1;\n    float left = iResolution.x * 0.3;\n    float top = iResolution.y * 0.3;\n    vec2 resolution = iResolution.xy * 1.6;\n    \n\tvec3 coord = vec3(fragCoord,0.);\n\tcoord.x += left;\n\tcoord.y += top;\n\n\tfragColor = planet(coord.xy / resolution.xy, 0.05, float(int(time * 0.08)), time * 0.1, sin(time * 0.05) * 2.0, time), 1.0;\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"MdX3RM","date":"1365503216","viewed":2252,"name":"Perlin Planet","username":"Zarkonnen","description":"Earthlike planet entirely on the basis of perlin noise, with arbitrary rotational axis and arbitrary lighting angle. Feedback very welcome, especially on how to improve performance.","likes":32,"published":1,"flags":0,"usePreview":0,"tags":["procedural","perlin","space","planet"],"hasliked":0,"parentid":"","parentname":""}}