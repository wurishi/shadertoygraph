{"ver":"0.1","info":{"id":"slSyRd","date":"1650096148","viewed":118,"name":"Interlocking Gears","username":"xaviershay","description":"Adapting https://www.shadertoy.com/view/wdlyRr for something a bit different","likes":9,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sXGRn","filepath":"/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","previewfilepath":"/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Created by inigo quilez - iq/2019\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// Step #1 of the LIVE Shade Deconstruction tutorials for \"Spere Gears\"\n\n// Part 1: https://www.youtube.com/watch?v=sl9x19EnKng\n//   Step 1: https://www.shadertoy.com/view/ws3GD2\n//   Step 2: https://www.shadertoy.com/view/wdcGD2\n//   Step 3: https://www.shadertoy.com/view/td3GDX\n//   Step 4: https://www.shadertoy.com/view/wd33DX\n//   Step 5: https://www.shadertoy.com/view/tdc3DX\n// Part 2: https://www.youtube.com/watch?v=bdICU2uvOdU\n//   Step 6: https://www.shadertoy.com/view/td3GDf\n//   Step 7: https://www.shadertoy.com/view/wssczn\n//   Step 8: https://www.shadertoy.com/view/wdlyRr\n//   Final : https://www.shadertoy.com/view/tt2XzG\n\n#define AA 2\n\nfloat sdSphere( in vec3 p, in float r )\n{\n    return length(p)-r;\n}\nfloat opSubtract( float d1, float d2 ) { return max(-d1,d2); }\n\nfloat sdCylinder( in vec3 p, vec3 c )\n{\n  return length(p.xz-c.xy)-c.z;\n}\n\nfloat sdPlaneSlice( in vec3 p, float r)\n{\n  return abs(p.y) - r;\n}\n\n/*\n// arbitrary orientation\nfloat sdCylinder(vec3 p, vec3 a, vec3 b, float r)\n{\n    vec3 pa = p - a;\n    vec3 ba = b - a;\n    float baba = dot(ba,ba);\n    float paba = dot(pa,ba);\n\n    float x = length(pa*baba-ba*paba) - r*baba;\n    float y = abs(paba-baba*0.5)-baba*0.5;\n    float x2 = x*x;\n    float y2 = y*y*baba;\n    float d = (max(x,y)<0.0)?-min(x2,y2):(((x>0.0)?x2:0.0)+((y>0.0)?y2:0.0));\n    return sign(d)*sqrt(abs(d))/baba;\n}\n*/\n\n// http://iquilezles.org/www/articles/smin/smin.htm\nfloat smax( float a, float b, float k )\n{\n    float h = max(k-abs(a-b),0.0);\n    return max(a, b) + h*h*0.25/k;\n}\n\n// https://www.shadertoy.com/view/MlycD3\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat sdTrapezoid( in vec2 p, in float r1, float r2, float he )\n{\n    vec2 k1 = vec2(r2,he);\n    vec2 k2 = vec2(r2-r1,2.0*he);\n\n\tp.x = abs(p.x);\n    vec2 ca = vec2(max(0.0,p.x-((p.y<0.0)?r1:r2)), abs(p.y)-he);\n    vec2 cb = p - k1 + k2*clamp( dot(k1-p,k2)/dot2(k2), 0.0, 1.0 );\n    \n    float s = (cb.x < 0.0 && ca.y < 0.0) ? -1.0 : 1.0;\n    \n    return s*sqrt( min(dot2(ca),dot2(cb)) );\n}\n\n//----------------------------------\n\nfloat dents( in vec2 q, in float y, in float rc, in float teeth, in float time )\n{\n    float an = 6.283185/teeth;\n    float fa = (atan(q.y,q.x)+an*0.5)/an;\n    float sym = an*floor(fa);\n    vec2 r = mat2(cos(sym),-sin(sym), sin(sym), cos(sym))*q;\n    \n#if 0\n    float d = length(max(abs(r-vec2(0.17,0))-vec2(0.042,0.041*y),0.0));\n#else\n    float d = sdTrapezoid( r.yx-vec2(0.0,rc), 0.085*y, 0.028*y, 0.035 );\n#endif\n\n\treturn d - 0.005;\n}\n\nfloat sdGear( in vec3 p, float r, in float teeth, in float time )\n{\n  vec3 q = p;\n  float off = 0.0;\n  {\n    float an = time + off*6.283185/teeth;\n    float co = cos(an), si = sin(an);\n    q.xz = mat2(co,-si,si,co)*q.xz;\n  }\n  q.y = abs(q.y);\n  float d = abs(length(q.xz) - r) - 0.048;\n  \n  d = min( d, dents(q.xz,0.5, r+0.07, teeth, time) );\n\n//  float de = -0.0015*clamp(600.0*abs(dot(q.xz,q.xz)-0.155*0.155),-100.0,100.0);\n // d = smax( d, abs(r-0.5)-0.03+de, 0.005 );\n    \n  d = max(d, q.y - 0.5);\n  d = max(d, sdPlaneSlice(q, 0.1));\n  return d;\n}\n\nvec4 map( in vec3 p, float time )\n{\nvec3 currentLoc = vec3(-3.0, 0.0, -4.0);\n   float rLast = 0.2;\n   float rCurrent = 0.2;\n   float teethHeight = 0.1;\n   float teethLast = -1.0;\n   float offset = 0.0;\n   float d = 1000000.;\n   float direction = 1.0;\n   \n   for (float i = 0.0; i < 9.1; i++) {\n       vec3 dir = normalize(vec3(1.0-abs(sin(float(i+23.4) * 111.123)), 0.0, abs(sin(float(i+76.4) * 1311.123))));       \n       //dir = normalize(vec3(1.0, 0.0, 0.0));\n       rLast = rCurrent;\n       float teeth = 10.0 + floor( abs(sin(i * 33456.343) * 50.0));\n       rCurrent = teeth * 0.016;\n       //rCurrent = 0.1 + 0.3 * abs(sin(i*536.4));\n       currentLoc += (rLast + rCurrent + 2.0 * teethHeight) * dir ;\n       \n       if (teethLast < 0.0) teethLast = teeth;\n       \n       float speed = teethLast / teeth;\n       // This calculation not quite right, needs to adjust for angle between gears. Eh close enough for now.\n       offset += 2.0 * 3.14159 / teeth * 0.5;\n       d = min(d, sdGear(p + currentLoc, rCurrent, teeth, 2.0 * time * direction * speed + offset));\n       \n       direction *= -1.0;\n   }\n   \n   return vec4( d, p);\n}\n\n#define ZERO min(iFrame,0)\n\nvec3 calcNormal( in vec3 pos, in float time )\n{\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(pos+0.0005*e,time).x;\n    }\n    return normalize(n);\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor, in float time )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=ZERO; i<5; i++ )\n    {\n        float h = 0.01 + 0.12*float(i)/4.0;\n        float d = map( pos+h*nor, time ).x;\n        occ += (h-d)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );\n}\n\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float k, in float time )\n{\n    float res = 1.0;\n    \n    float tmax = 2.0;\n    float t    = 0.001;\n    for( int i=0; i<64; i++ )\n    {\n        float h = map( ro + rd*t, time ).x;\n        res = min( res, k*h/t );\n        t += clamp( h, 0.012, 0.2 );\n        if( res<0.001 || t>tmax ) break;\n    }\n    \n    return clamp( res, 0.0, 1.0 );\n}\n\nvec4 intersect( in vec3 ro, in vec3 rd, in float time )\n{\n    vec4 res = vec4(-1.0);\n    \n    float t = 0.001;\n    float tmax = 15.0;\n    for( int i=0; i<128 && t<tmax; i++ )\n    {\n        vec4 h = map(ro+t*rd,time);\n        if( h.x<0.001 ) { res=vec4(t,h.yzw); break; }\n        t += h.x;\n    }\n    \n    return res;\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv =          ( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 tot = vec3(0.0);\n    \n    #if AA>1\n    for( int m=ZERO; m<AA; m++ )\n    for( int n=ZERO; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (2.0*(fragCoord+o)-iResolution.xy)/iResolution.y;\n        float d = 0.5*sin(fragCoord.x*147.0)*sin(fragCoord.y*131.0);\n        float time = iTime;\n        #else    \n        vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n        float time = iTime;\n        #endif\n\n\t    // camera\t\n        float an = 6.2831*time/5.0;\n        vec3 ta = vec3( 1.0, 0.0, 0.0 );\n        //vec3 ro = ta + vec3( 2.5*cos(an) + 0.0, 0.3, 0.5*sin(an*0.) + 5.0 );\n        vec3 ro = ta + vec3( 3.0, 4.0, 0.2);\n        \n        // camera-to-world transformation\n        mat3 ca = setCamera( ro, ta, 0.0 );\n        \n        // ray direction\n        float fl = 2.0;\n        vec3 rd = ca * normalize( vec3(p,fl) );\n\n        // background\n        vec3 col = vec3(1.0+rd.y)*0.03;\n        \n        // raymarch geometry\n        vec4 tuvw = intersect( ro, rd, time );\n        if( tuvw.x>0.0 )\n        {\n            // shading/lighting\t\n            vec3 pos = ro + tuvw.x*rd;\n            vec3 nor = calcNormal(pos, time);\n                        \n            vec3 te = 0.5*texture( iChannel0, tuvw.yz*2.0 ).xyz+\n                      0.5*texture( iChannel0, tuvw.yw*1.0 ).xyz;\n            \n            vec3 mate = 0.22*te;\n            float len = length(pos);\n            \n            mate *= 1.0 + vec3(2.0,0.5,0.0)*(1.0-smoothstep(0.121,0.122,len) ) ;\n            \n            float focc  = 0.1+0.9*clamp(0.5+0.5*dot(nor,pos/len),0.0,1.0);\n                  focc *= 0.1+0.9*clamp(len*2.0,0.0,1.0);\n            float ks = clamp(te.x*1.5,0.0,1.0);\n            vec3  f0 = mate;\n            float kd = (1.0-ks)*0.125;\n            \n            float occ = calcAO( pos, nor, time ) * focc;\n            \n            col = vec3(0.0);\n            \n            // side\n            {\n            vec3  lig = normalize(vec3(0.8,0.2,0.6));\n            float dif = clamp( dot(nor,lig), 0.0, 1.0 );\n            vec3  hal = normalize(lig-rd);\n            float sha = 1.0; if( dif>0.001 ) sha = calcSoftshadow( pos+0.001*nor, lig, 20.0, time );\n            vec3  spe = pow(clamp(dot(nor,hal),0.0,1.0),16.0)*(f0+(1.0-f0)*pow(clamp(1.0+dot(hal,rd),0.0,1.0),5.0));\n            col += kd*mate*2.0*vec3(1.00,0.70,0.50)*dif*sha;\n            col += ks*     2.0*vec3(1.00,0.80,0.70)*dif*sha*spe*3.14;\n            }\n\n            // top\n            {\n            vec3  ref = reflect(rd,nor);\n            float fre = clamp(1.0+dot(nor,rd),0.0,1.0);\n            float sha = occ;\n            col += kd*mate*25.0*vec3(0.19,0.22,0.24)*(0.6 + 0.4*nor.y)*sha;\n            col += ks*     25.0*vec3(0.19,0.22,0.24)*sha*smoothstep( -1.0+1.5*focc, 1.0-0.4*focc, ref.y ) * (f0 + (1.0-f0)*pow(fre,5.0));\n            }\n            \n            // bottom\n            {\n            float dif = clamp(0.4-0.6*nor.y,0.0,1.0);\n            col += kd*mate*5.0*vec3(0.25,0.20,0.15)*dif*occ;\n            }\n        }\n        \n                // vignetting\n        col *= 1.0-0.1*dot(p,p);\n        \n        // gamma        \n\t    tot += pow(col,vec3(0.45) );\n    #if AA>1\n    }\n    tot /= float(AA*AA);\n    #endif\n\n    // s-curve    \n    tot = min(tot,1.0);\n    tot = tot*tot*(3.0-2.0*tot);\n\n    // cheap dithering\n    tot += sin(fragCoord.x*114.0)*sin(fragCoord.y*211.1)/512.0;\n    \n    \n        \n    \n\n    fragColor = vec4( tot, 1.0 );\n}","name":"Image","description":"","type":"image"}]}