{"ver":"0.1","info":{"id":"X3XXR7","date":"1712271683","viewed":181,"name":"Island - 4k - Revision 2024","username":"Krafpy","description":"4k intro released at Revision 2024. Graphics only, for the music, checkout the video: https://youtu.be/1_wF9xH6PeI\nPouet page: https://www.pouet.net/prod.php?which=96609","likes":8,"published":1,"flags":32,"usePreview":1,"tags":["raymarching","4k","hexagon"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    fragColor = vec4(texture(iChannel0, uv).rgb, 1.);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Very basic shaded rotating cubeconst\n\n\n// constants\nfloat SQRT32 = 0.86602540;\nfloat SQRT3 = 1.73205080;\nfloat PI = 3.141593;\n\n// hex grid settings\nfloat RI = 1.;\nfloat RC = 1.15470053; // RI/SQRT32;\n\n#define iTime mod(iTime,138.)\n\n\nvec2 sincos(float x){\n    return vec2(sin(x), cos(x));\n}\n\nmat2 rot(float a){\n    /*float c = cos(a);\n    float s = sin(a);*/\n    vec2 sc = sincos(a);\n    return mat2(sc.y, -sc.x, sc.x, sc.y);\n}\n\n\n\n// from: https://www.shadertoy.com/view/4djSRW\nfloat hash13(vec3 p3) {\n    p3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.zyx + 31.32);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n/*float hash12(vec2 p) {\n    vec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}*/\n\nvec3 hash32(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\n/*float hash11(float p) {\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}*/\n\n\nfloat noise(vec3 p) {\n    vec3 i = floor(p);\n    vec3 w = smoothstep(0., 1., p-i);\n    \n    vec2 k = vec2(1., 0.);\n    return \n    mix(mix(mix(hash13(i+k.yyy),\n                hash13(i+k.xyy), w.x),\n            mix(hash13(i+k.yxy),\n                hash13(i+k.xxy), w.x), w.y),\n        mix(mix(hash13(i+k.yyx),\n                hash13(i+k.xyx), w.x),\n            mix(hash13(i+k.yxx),\n                hash13(i+k.xxx), w.x), w.y), w.z);\n}\n\nfloat fbm(vec3 p){\n    float f = 0.;\n    float s = 0.5;\n    for(int i = 0; i < 8; i++) {\n        f += s*noise(p);\n        p *= 2.;\n        s *= 0.6;\n    }\n    return f;\n}\n\n\n// xy = center of the hexagon, zw = coordinates relative to hexagon center\nvec4 hexCell(vec2 p){\n    vec2 s = vec2(1., SQRT3)*(2.*RI);\n    vec2 h = s*0.5;\n    vec2 a = mod(p, s) - h;\n    vec2 b = mod(p + h, s) - h;\n    vec2 i = p/s;\n    float sa = step(dot(a, a), dot(b, b));\n    float sb = 1. - sa;\n    vec2 f = sa*floor(i) + sb*floor(i+0.5);\n    vec2 c = f*s + sa*h;\n    return vec4(c, sa*a + sb*b);\n}\n\nfloat hexSphIntersect(vec2 ro, vec2 rd){\n    float b = dot(ro, rd);\n    float c = dot(ro, ro) - RC*RC;\n    float delta = b*b - c;\n    return sqrt(delta) - b;\n}\n\n// vec2 hexNormal(vec2 p) {\n//     float k = step(0.5*RC, abs(p.y));\n//     return sign(p)*vec2(1.-0.5*k, k*SQRT32);\n// }\n\n// visualization: https://editor.p5js.org/krafpy/sketches/TQhvnNLGk\nfloat hexIntersect(vec2 ro, vec2 rd){\n    float t = hexSphIntersect(ro, rd);\n    // vec2 n = hexNormal(ro + rd*t);\n    vec2 p = ro + rd*t;\n    float k = step(0.5*RC, abs(p.y));\n    vec2 n = sign(p)*vec2(1.-0.5*k, k*SQRT32);\n    return (RI - dot(ro, n))/dot(rd, n);\n}\n\n// from: https://iquilezles.org/articles/distfunctions/\nfloat sdBox(vec3 p, vec3 b) {\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n/*float sdBox(vec2 p, vec2 b) {\n  vec2 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,q.y),0.0);\n}*/\n\n/*float hexDist(vec2 p){\n    p = abs(p);\n    return max(p.x, 0.5*(p.x + SQRT3*p.y));\n}*/\n\n\n// from: https://iquilezles.org/articles/distfunctions/\nfloat sdHexPrism(vec3 p, vec2 h){\n  vec3 k = vec3(-SQRT32, 0.5, 0.57735);\n  p = abs(p);\n  p.xz = p.zx;\n  p.xz -= 2.0*min(dot(k.xy, p.xz), 0.0)*k.xy;\n  vec2 d = vec2(\n       length(p.xz-vec2(clamp(p.x,-k.z*h.x,k.z*h.x), h.x))*sign(p.z-h.x),\n       p.y-h.y );\n  //return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n  return length(max(d,0.0));\n}\n\n\nfloat island(vec2 hexc){\n    float d = length(hexc);\n    float x = atan(hexc.x, hexc.y)*7.33;\n    //d += (sin(x)-cos(sin(x))*sin(x))*6.;\n    d += 5.*(2.*noise(vec3(x,0.,0.))-1.);\n    float h = smoothstep(30., 0., d) + 2.*smoothstep(10., 0., d);\n    return h/3.;\n}\n\n\n// from: https://iquilezles.org/articles/smin/\n/*float smin(float a, float b, float k) {\n    //return -log2(exp2(-k*a)+exp2(-k*b))/k;\n    //k *= 2.0;\n    float x = b-a;\n    return 0.5*( a+b-sqrt(x*x+k*k) );\n}*/\n\nfloat defaultHexHeight = 1000.;\n\n\nfloat islandAltitude(){\n    float t = (iTime - 62.);\n    t *= 0.6;\n    float islandTargetAltitude = 20.;\n    return islandTargetAltitude*step(0.,t)*smoothstep(0., islandTargetAltitude, t);\n}\n\nvec2 getHexHeights(vec2 hexCenter, vec3 rand) {\n    float islandScale = island(hexCenter);\n    float isIsland = 1.-step(islandScale,0.);\n    \n    float islandHexHeight = 1.2 + rand.x + 20.*islandScale;\n    \n    float hexHeight = mix(defaultHexHeight, islandHexHeight, isIsland);\n    \n    float islandHexDispY;\n    // cone-like displacement of individual hexagons\n    float islandTargetHexDispY = 15.*islandScale + 1.*rand.y*(1.-islandScale) + 1.;\n    // island build start\n    float s = step(length(hexCenter), 3.);\n    float rh = mix(rand.z*5., 4.5, s);\n    islandHexDispY = islandTargetHexDispY*smoothstep(0.,islandTargetHexDispY*0.1,(iTime-17.)/6.-rh);\n    // altitude of the whole island\n    islandHexDispY += islandAltitude();\n    \n    float hexRandY = -rand.x*0.5*smoothstep(50., 40., length(hexCenter));\n    \n    float hexDispY = hexRandY + islandHexDispY*isIsland;\n    \n    return vec2(hexHeight, hexDispY);\n}\n\nvec2 mapHexs(vec3 p, vec4 hex){\n    vec3 q = vec3(p.x-hex.x, p.y, p.z-hex.y);\n    vec2 hexCenter = hex.xy;\n    \n    vec3 rand = hash32(hexCenter);\n\n    vec2 heights = getHexHeights(hexCenter, rand);\n    float hexDispY = heights.y;\n    float hexHeight = heights.x;\n    \n    float hexRad = 0.1;\n    vec2 mainHex = vec2(RI-hexRad-0.02, hexHeight);\n    float d = sdHexPrism(q-vec3(0.,-hexHeight+hexDispY,0.), mainHex) - hexRad;\n    \n    /*vec2 groove = vec2(0.7, 0.1);\n    float dGroove = sdHexPrism(q-vec3(0.,hexDispY+groove.y,0.), groove) - 0.02;\n    float hasGroove = step(rand.y, 0.5);\n    d = mix(d, smin(d, dGroove, 0.02), hasGroove);*/\n    \n    // underground hexagons\n    vec2 underHex = vec2(0.7, defaultHexHeight);\n    float underOff = -5. - mainHex.y;\n    float dUnder = sdHexPrism(q-vec3(0.,-underHex.y + underOff,0.), underHex) - 0.1;\n    float isUnder = step(0., d-dUnder);\n    d = min(d, dUnder);\n    \n    \n    return vec2(d, isUnder);\n}\n\n\nvec3 cubePos() {\n    float t = iTime - 95.;\n    float y = mix(-5000., -25. + t*2., step(0.,t));\n    \n    float a = smoothstep(-15.,-6.,y);\n    float b = smoothstep(5.,18.,y);\n    float c = smoothstep(20.,45.,y);\n    float r = mix(0.,mix(12.5,mix(34.,0.,c),b),a);\n    vec3 pos = vec3(r,y,0.);\n    pos.xz *= rot(t*0.5);\n    return pos;\n}\n\nvec3 cubeTransform(vec3 p) {\n    p -= cubePos();\n    p.xz *= rot(3.*iTime);\n    p.yx *= rot(3.7*iTime);\n    // p.yz *= rot(-1.9*iTime);\n    p.zx *= rot(1.2*iTime + sin(3.*iTime));\n    return p;\n}\n\nfloat mapCube(vec3 p){ // x = sdf\n    p = cubeTransform(p);\n    \n    vec3 b = vec3(0.5, 0.5, 0.5);\n    float d = sdBox(p, b) - 0.2;\n    return (d - 0.1/length(p))*0.8;\n}\n\nfloat map(vec3 p) {\n    float d = mapHexs(p, hexCell(p.xz)).x;\n    if(iTime > 95.){\n        d = min(d, mapCube(p));\n    }\n    return d;\n}\n\n\nvec2 traverse(vec3 ro, vec3 rd, int maxCells, int maxRMSteps, bool calcShad) { // t, shad\n    float shad = 1.;\n    float t1 = 0.;\n    for(int i = 0; i < maxCells; i++){\n        vec3 p = ro + rd*t1;\n        \n        if(!calcShad && length(p.xz) > 55. && ro.y > 0.1){\n            float t = (0.1-ro.y)/rd.y;\n            return vec2(t, shad);\n        }\n        \n        vec4 hex = hexCell(p.xz);\n        float t2max = hexIntersect(hex.zw, normalize(rd.xz))/length(rd.xz);\n        \n        float t2 = 0.;\n        for(int j = 0; j < maxRMSteps-i/2 && t2 < t2max; j++){\n            vec3 q = p + rd*t2;\n            \n            float d = map(q);\n            float t = t1 + t2;\n            \n            // soft shadows\n            if(calcShad) {\n                vec2 u = vec2(rd.z,-rd.x);\n                float d2 = mapHexs(q, hexCell(q.xz + u*RI)).x;\n                float d3 = mapHexs(q, hexCell(q.xz - u*RI)).x;\n\n                float dmin = min(d,min(d2,d3));\n                shad = min(shad, 32.*dmin/t);\n            }\n            \n            if(d < 0.003) {\n                return vec2(t, 0.);\n            }\n            t2 += d;\n        }\n        \n        t1 += t2max + 0.0001;\n    }\n    return vec2(-1., shad);\n}\n\n\nvec3 normal(vec3 p){\n    vec2 h = 0.0001*vec2(1.,-1.);\n    return normalize(\n        map(p + h.xyy)*h.xyy +\n        map(p + h.yyx)*h.yyx +\n        map(p + h.yxy)*h.yxy +\n        map(p + h.xxx)*h.xxx\n    );\n}\n\n\n\nvec3 skyCol = vec3(0.8,0.82,0.9);\nvec3 sunCol = vec3(1.2, 1.1, 1.);\nvec3 sunDir = normalize(vec3(-0.6, 0.4, 1.));\n// vec3 sunDir = vec3(-0.487,  0.324,  0.811);\n\nvec3 background(vec3 ro, vec3 rd) {\n    float s = max(dot(rd, sunDir), 0.);\n    vec3 bg = mix(skyCol, sunCol, pow(s,8.0));\n    bg = mix(bg, vec3(0.), max(-rd.y, 0.));\n    return bg;\n}\n\nvec3 fog(vec3 col, float t, vec3 ro, vec3 rd) {\n    float strength = 1. - exp(-0.0001*t*t);\n    return mix(col, background(ro, rd), strength);\n}\n\nfloat ao(vec3 p, vec3 n){\n    float occ = 0.;\n    float s = 2.;\n    for(int i = 0; i < 5; i++){\n        float t = 0.01 + float(i)*0.13;        \n        //float d = map(p + t*n);\n        vec3 q = p + t*n;\n        vec2 u = vec2(n.z,-n.x);\n        float d = mapHexs(q, hexCell(q.xz)).x;\n        float d2 = mapHexs(q, hexCell(q.xz + u*RI)).x;\n        float d3 = mapHexs(q, hexCell(q.xz - u*RI)).x;\n        d = min(d, min(d2, d3));\n        occ += s*(t-d);\n        s *= 0.6;\n    }\n    return clamp(1.-occ, 0., 1.);\n}\n\nfloat shadow(vec3 p, vec3 n){\n    vec3 ro = p + n*0.011;\n    return traverse(ro, sunDir, 45, 25, true).y;\n}\n\n/*float saturate(float x) {\n    return clamp(x,0.,1.);\n}*/\n\n/*float G_GGXp(vec3 v, vec3 n, vec3 h, float a){\n    float VdotH = saturate(dot(v,h));\n    float chi = step(0., VdotH/saturate(dot(v,n)));\n    float VdotH2 = VdotH * VdotH;\n    float tan2 = (1. - VdotH2) / VdotH2;\n    return (chi * 2.) / (1. + sqrt(1. + a*a*tan2));\n}\n\nfloat G_GGX(vec3 wi, vec3 wo, vec3 n, vec3 h, float a){\n    return G_GGXp(wo,n,h,a)*G_GGXp(wi,n,h,a);\n}*/\n\nvec3 lighting(vec3 p, vec3 ro, vec3 rd) {\n    vec3 col = vec3(0.);\n\n    vec4 hex = hexCell(p.xz);\n    vec2 hexc = hex.xy;\n    vec3 rand = hash32(hexc);\n\n    float isUnder = mapHexs(p, hex).y;\n    \n    vec3 cubeRelPos = cubeTransform(p);\n    vec3 cubeCol = vec3(1.,0.5, 0.3);\n    float cubeDst = mapCube(p);\n    float atten = 3. / (1.+cubeDst*cubeDst);\n    float isCube = step(cubeDst,0.01);\n    float cubeNoise = 1.-pow(fbm(cubeRelPos), 5.);\n    float cubeRough = clamp(1.-cubeNoise, 0.1, 1.);\n\n    vec3 q = p;\n    q.y -= getHexHeights(hexc, rand).y;\n\n    vec3 n = normal(p);\n    \n    vec3 l = sunDir;\n    vec3 v = -rd;\n    vec3 h = normalize(l + v);\n    \n    // cook-torrance shading for direct sun light\n    float NdotL = clamp(dot(n, l), 0.0, 1.0);\n    float NdotV = clamp(dot(n, v), 0.0, 1.0);\n    float NdotH = clamp(dot(n, h), 0.0, 1.0);\n    float LdotH = clamp(dot(l, h), 0.0, 1.0);\n    float VdotH = clamp(dot(v, h), 0.0, 1.0);\n    \n    float rough = mix(mix(0.1,0.7,rand.y) + 0.05*sin(PI*pow(fbm(2.*q),6.)), cubeRough, isCube);\n    float rough2 = rough*rough;\n    float D = pow(NdotH,2./rough2-2.)/(PI*rough2);\n    \n    float g = 2.*NdotH/VdotH;\n    float G = min(1., g*min(NdotV, NdotH));\n    //float G = G_GGX(v, sunDir, n, h, rough);\n    \n    //vec3 F0 = mix(vec3(0.664,0.824,0.850), vec3(0.549,0.556,0.554), hash12(hexc+vec2(7.045)));\n    float rnd = hash32(hexc+vec2(7.045)).x;\n    vec3 F0 = mix(vec3(0.764,0.824,0.850), vec3(0.972,0.960,0.915), rnd);\n    // if underground hexagon\n    vec3 F0u = mix(vec3(0.664,0.824,0.850), vec3(0.549,0.556,0.554), rnd);\n    F0 = mix(F0, F0u, isUnder);\n    // if cube\n    F0 = mix(F0, vec3(0.045), isCube);\n    \n    vec3 F = F0 + (1.-F0)*pow(1.-LdotH,5.);\n    \n    vec3 metal = vec3(0.5);\n    vec3 diffc = (1.-metal)*F0/metal;\n    diffc *= mix(diffc, diffc*vec3(0.7), pow(fbm(30.*q),5.)+0.5*pow(fbm(2.*q),6.));\n    \n    vec3 diff = diffc*NdotL;\n    vec3 spec = (D*G*F)/(4.*max(0.0001, dot(n,v)));\n    float s = 0.5;\n    col = sunCol*((1.-s)*diff + s*spec);\n    \n    // shadows (direct lighting only)\n    col *= shadow(p, n);\n    \n    // sky color\n    vec3 indirect = 0.1*skyCol;\n    // fake global illumination\n    indirect += 0.1*sunCol*max(0., dot(n, -vec3(sunDir.x, 0., sunDir.z)));\n    indirect += 0.03*skyCol*max(0., dot(n, vec3(sunDir.x, 0., sunDir.z)));\n    \n    indirect *= smoothstep(-1.-islandAltitude(),0.,p.y);\n    \n    col += indirect*diffc;\n    \n    col *= ao(p, n);\n    \n    // light cube illumination\n    // vec3 cubeCol = vec3(1.,0.5, 0.3);\n    // float atten = 3. / (1.+cubeDst*cubeDst);\n    col += cubeCol * atten * max(0., dot(normalize(cubePos()-p),n)) * (1.-isCube)\n        + 2.*cubeCol * cubeNoise * isCube * smoothstep(1.6,1.,length(cubePos()-p));\n    \n    return col;\n}\n\nfloat t0 = 0.;\nvec3 at, ro, rd;\nfloat T(float duration, vec3 target, vec3 offset) {\n    if(iTime>=t0){\n        at = target;\n        ro = target + offset;\n    }\n    t0 += duration;\n    return iTime - t0;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    vec3 prevCol = texture(iChannel0, uv).xyz;\n    uv -= 0.5;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    vec3 col = vec3(0.);\n    \n    // animation and timing\n    vec3 dir = vec3(1.,0.,1.);\n    vec3 pos = vec3(0.,0.,-10.);\n    vec2 rt, ct;\n    float t;\n    \n    // 0\n    t = T(5., pos + dir*iTime, -1.*dir + vec3(0.,10.,0.));\n    // 5\n    t = T(5., pos + dir*iTime, 15.*vec3(dir.z,0.,-dir.x) + vec3(0.,15.,0.));\n    // 10\n    t = T(5., pos + dir*iTime, 10.*vec3(dir.z,0.,-dir.x) + vec3(0.,1.,0.));\n    \n    pos = vec3(-11.,0.,-37.);\n    dir = vec3(0.2,0.,1.);\n    // 15\n    t = T(5., pos + dir*iTime*0.6, -5.*dir + vec3(2.,7.,0.));\n    \n    // 20\n    rt = 40.*sincos(0.1*iTime);\n    t = T(5., vec3(0.), vec3(rt.x,10.,rt.y));\n    // 25\n    rt *= 0.2;\n    t = T(5., vec3(0.,t+7.,0.), vec3(rt.y,5.,rt.x));\n    \n    // 30\n    pos = vec3(0.,10.,0.) - dir*5.;\n    t = T(5., pos + t*dir, 10.*vec3(dir.z,0.,-dir.x));\n    \n    // 35\n    rt = 20.*sincos(0.1*iTime);\n    ct = 20.*sincos(0.1*iTime-0.5);\n    t = T(5., vec3(rt.x,5.,rt.y), vec3(ct.x,10.,ct.y));\n    \n    // 40\n    rt = 15.*sincos(0.1*iTime+1.);\n    ct = 2.*sincos(0.1*iTime+1.-PI/2.);\n    t = T(5., vec3(rt.y,5.,rt.x), vec3(ct.y,1.,ct.x));\n    \n    // 45\n    ct = sincos(0.1*iTime-0.8);\n    t = T(2.5, vec3(0.,t+6.,0.), vec3(ct.y,5.,ct.x));\n    // 47.5\n    ct = sincos(0.1*iTime-0.5);\n    t = T(2.5, vec3(0.,t+6.,0.), vec3(ct.y,15.,ct.x));\n    // 50\n    ct = sincos(0.1*iTime-0.3);\n    t = T(5., vec3(0.,t+6.,0.), vec3(ct.y,25.,ct.x));\n    // 52.5\n    // rt = sincos(0.1*iTime-0.0);\n    // t = T(2.5, vec3(0.,t+6.,0.), vec3(rt.y,35.,rt.x));\n    \n    // 55\n    ct = 30.*sincos(0.1*iTime);\n    t = T(5., vec3(0.,10.,0.), vec3(ct.y,5.,ct.x));\n    \n    // 60\n    ct = 40.*sincos(3.3-t*0.05);\n    t = T(5., vec3(0.,0.,0.), vec3(ct.x,1.,ct.y));\n    \n    // 65\n    ct = 40.*sincos(0.03*t);\n    t = T(5., vec3(0.,0.,0.), vec3(ct.x,1.,ct.y));\n\n    // 70\n    ct = sincos(0.1*iTime-0.3);\n    t = T(5., vec3(0.,0.,0.), vec3(ct.y, 50.,ct.x));\n    \n    // 75\n    ct = 50.*sincos(0.02*t+3.);\n    t = T(5., vec3(0.,-1.,0.), vec3(ct.y,10.,ct.x));\n    \n    // 80\n    t = T(10., vec3(-30.+t,0.+0.7*t,0.), vec3(-4.,1.-0.5*t,-1.));\n    \n    // 90\n    ct = 20.*sincos(t*0.1+3.);\n    t = T(5., vec3(0.,-5.+t*0.5,0.), vec3(ct.x,-t*0.5,ct.y));\n    \n    // 95\n    vec3 c = cubePos();\n    T(10., vec3(0.,c.y,0.), vec3(ct.y,-c.y,ct.x));\n    \n    // 105\n    ct *= rot(PI);\n    t = T(5., vec3(0.,c.y,0.), vec3(ct.x,0.,ct.y));\n    \n    // 110\n    ct = 10.*sincos(-0.1*t-1.5);\n    t = T(5., c, vec3(ct.x,-c.y+2.,ct.y));\n    \n    // 115\n    ct = 50.*sincos(0.5*t+4.);\n    t = T(5., vec3(0.,c.y,0.), vec3(ct.y,10.,ct.x));\n    \n    // 120\n    t = T(5., c, -c + vec3(7., 35., 0.));\n    \n    // 125\n    t = T(5., vec3(0.,35.+0.5*t,0.), vec3(-25.,0.,0.));\n    \n    // 130\n    t = T(10., vec3(0.,40.,0.), vec3(t+45.,0.,0.));\n    \n    \n    // rays\n    vec3 forward = normalize(at - ro);\n    vec3 right = normalize(vec3(forward.z, 0., -forward.x)); // 90° rotation\n    vec3 up = cross(forward, right);\n\n    uv += (2.*hash32(333.*uv+iTime).xy-1.)*0.0005; // randomize edges for a \"good enough\" antialiasing\n    rd = normalize(uv.x*right + uv.y*up + forward);\n    \n    vec4 outCol = vec4(1.,0.,0.,1.);\n    \n    float h = traverse(ro, rd, 100, 100, false).x;\n    if(h > 0.) {\n        vec3 p = ro + rd*h;\n        col = lighting(p, ro, rd);\n        col = fog(col, h, ro, rd);\n    } else {\n        col = background(ro, rd);\n    }\n    \n    outCol = vec4(mix(pow(clamp(col, 0., 1.), vec3(0.45)) * smoothstep(0.,1.,iTime) * smoothstep(136.,135.,iTime),\n                prevCol, 0.4),1.0);\n    fragColor = outCol;\n}","name":"Buffer A","description":"","type":"buffer"}]}