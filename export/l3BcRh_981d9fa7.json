{"ver":"0.1","info":{"id":"l3BcRh","date":"1726925244","viewed":20,"name":"Neon Rectangle Function","username":"g_Bloxy","description":"The function renderRect() draw a neon rectangle based on size (rectSize), center position (rectPos), color (rectColor), and neon color (glowColor).\n\nThe rectangle algorithme is based on Kanawanagasaki's Neon Rect shader.","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["box","function","sd","rect","neon"],"hasliked":0,"parentid":"lXXXDX","parentname":"Neon Rect"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nfloat getGlow(float dist, float radius, float intensity) {\n    return pow(radius / dist, intensity);\n}\n\nfloat sdBox(in vec2 p, in vec2 b) {\n    vec2 d = abs(p) - b;\n    return length(max(d, 0.)) + min(max(d.x, d.y), 0.);\n}\n\nvec4 renderRect(vec2 uv, vec2 rectPos, vec2 rectSize, vec3 rectColor, vec3 glowColor) {\n    vec2 pos = (uv - rectPos) * 2.;\n\n    float dist = sdBox(pos, rectSize);\n    float glow = getGlow(abs(dist), 0.015, 1.55);\n    \n    vec3 col = 10. * vec3(smoothstep(0.01, 0.003, abs(dist)));\n    col += glow * glowColor;\n    col = 1. - exp(-col);\n    col = pow(col, vec3(0.8));\n\n    float alpha = pow(1. - exp(-glow), 0.8);\n\n    col += rectColor * smoothstep(0., 1., 1. - alpha) * smoothstep(0., 1., 1. - glow) * step(dist, 0.);\n\n    return vec4(col, 1.);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n    vec4 col = renderRect(uv, vec2(0.5), vec2(0.4), vec3(1.), vec3(1., 0.1, 0.2));\n    fragColor = col;\n}\n","name":"Image","description":"","type":"image"}]}