{"ver":"0.1","info":{"id":"XlscDn","date":"1504361937","viewed":230,"name":"Visualizing SDFs","username":"Prototonca","description":"A simple raymarch shader to visualize 3D signed distance fields.\n\nThe layers in the shapes aurea show the steps of the raymarch.\nI tried to smooth those layers, with a random multiplier, both on fog and step.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","sdf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define VIEW_WIDTH 6.0\n#define CAM_DIST 6.0\n#define EPSILON 0.001\n#define MAX_MARCH_LENGTH 64\n\n/*\n===== VISUALISING SDFs =====\n\nThe shapes aurea show the closest shape distance in the 3D space.\n\nThe fog colors show a Voronoi-like subdivision of space.\n\nThe layers in the fog are generated by the steps in the raymarching algorithm.\nYou can play with them varying the STEP_DIST_RATIO coefficient diefined just below.\n\nI tried to smooth the aurea with a random multiplier, both on the fog factor and \nthe step of the raymarch. \n\nBoth techniques add a visible noise to the fog render, because of the variance \nof the variance in the random function.\n\nBy smoothing the step gives better results than by smoothing fog. Both add \nthe same amount of noise, while the first hids better the layers. \nApplying both at the same time increases noise variance.\n\n\nTODO: Try with a better noise.\n\n*/\n\n#define STEP_DIST_RATIO 0.5\n// Random fog parameters\n#define SMOOTH_FOG false\n#define FOG_RAND_COEFF 2.0\n// Random step parameters\n#define SMOOTH_STEP false\n#define STEP_RAND_COEFF 2.0\n// Montecarlo\n#define MC_SMOOTH true\n#define N_SAMPLES 50\n\n\nstruct RayState {\n    float d;\n    vec3 base_col;    \n};\n    \n    \n// ---- SHAPES ----\n    \nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat udBox( vec3 p, vec3 b )\n{\n  return length(max(abs(p)-b,0.0));\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat udRoundBox( vec3 p, vec3 b, float r )\n{\n  return length(max(abs(p)-b,0.0))-r;\n}\n\nfloat udPlane(vec3 p) \n{\n    return abs(p.y);\n}\n\nfloat udWaves(vec3 p)\n{\n    return abs(p.y-(cos(length(p.xz-vec2(1.0))*20.0+iTime))*0.01);\n}\n\n// ---- OPERATIONS ----\n\nfloat opU( float d1, float d2 )\n{\n    return min(d1,d2);\n}\n\nvec3 opTrans( vec3 p, vec3 t)\n{\n    return p - t;\n}\n\nRayState opUrs(RayState o1, RayState o2)\n{\n    if (o1.d <= o2.d) return o1;\n    else return o2;\n}\n\n// Basic random float [0.0 - 1.0) function\n// source: https://stackoverflow.com/a/4275343 \nfloat rand(vec2 co)\n{\n    co = normalize(co);\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\n//From demofox: https://www.shadertoy.com/view/4tyXDR\n#define HASHSCALE3 vec3(443.897, 441.423, 437.195)\n#define PERTURB_SIZE 0.0005\n///  3 out, 3 in...\nvec3 hash33(vec3 p3)\n{\n    p3 = fract(p3 * HASHSCALE3);\n    p3 += dot(p3, p3.yxz+19.19);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n}\n\n\n// ---- MAP SCENE ----\nRayState map(vec3 p)\n{\n\n    RayState box = RayState(\n        udRoundBox(opTrans(p,vec3(-cos(iTime*1.4)*0.5,0.2,sin(iTime*1.4))), vec3(0.1, 0.1, 0.1), 0.05),\n        vec3(0.3, 0.2, 0.6)\n    );\n\n\n    RayState sphere = RayState(\n        sdSphere(opTrans(p,vec3(0.0,cos(iTime*1.2),sin(iTime*1.2)*0.5)),0.1),\n        vec3(0.1,0.5,0.1)\n    );\n\n    RayState sphere2 = RayState(\n        sdSphere(opTrans(p,vec3(sin(iTime*1.2)*0.5,-cos(iTime*1.2),0.0)),0.1),\n        vec3(0.7,0.5,0.2)\n    );\n\n    return opUrs(opUrs(box,sphere), sphere2);   \n}\n\n\nvec3 computeNormal(vec3 p) \n{\n    \n    vec3 eps = vec3(0.001, 0.0, 0.0);\n    vec3 nor = vec3(\n        map(p + eps.xyz).d - map(p - eps.xyz).d,\n        map(p + eps.zxy).d - map(p - eps.zxy).d,\n        map(p + eps.yzx).d - map(p - eps.yzx).d\n    );\n    return normalize(nor);\n}\n\n\n// ---- RAYMARCH ----\n\nvec3 trace(vec3 origin, vec3 rayDir)\n{\n    float t = 0.0;\n    vec3 color = vec3(0.0);\n    for(int i=0; i<MAX_MARCH_LENGTH; i++)\n    {\n        vec3 pos = origin + rayDir * t;\n        RayState rs = map(pos);\n\n        float fog = rs.d;\n        if(SMOOTH_FOG)\n        {\n            //Random multiplier\n            float randMul = (\n                rand(pos.xz)+\n                rand(pos.xy)+\n                rand(pos.zy)+\n                rand(pos.zx)+\n                rand(pos.yx)+\n                rand(pos.yz)\n            )/6.0;\n            fog = rs.d*((randMul-0.5)*FOG_RAND_COEFF+1.0);\n        }\n        \n        color += rs.base_col*(0.1/(pow(abs(fog),512.0)+1.0));\n        \n        if(SMOOTH_STEP)\n        {\n            //Random multiplier\n            float randMul = (\n                rand(pos.xz)+\n                rand(pos.xy)+\n                rand(pos.zy)+\n                rand(pos.zx)+\n                rand(pos.yx)+\n                rand(pos.yz)\n            )/6.0;\n            t += ((randMul-0.5)*STEP_RAND_COEFF+1.0) * rs.d * STEP_DIST_RATIO;\n        }\n        else\n        {\n            t += rs.d * STEP_DIST_RATIO;\n        }\n    }\n\n    return color; \n}\n\n// ---- MAIN ----\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Camera\n    vec2 mouse = iMouse.xy / iResolution.xy;\n    \n    vec3 target = vec3(0.0);\n\n    float angleX = 3.14 + iTime * 0.25;\n    float angleY = 0.2;\n    vec3 cameraPos = (vec3(sin(angleX)*cos(angleY), sin(angleY), cos(angleX)*cos(angleY))) * 6.0;\n\n    vec3 cameraFwd = normalize(target - cameraPos);\n    vec3 worldUp = vec3(0.0,sign(cos(angleY)),0.0);\n    vec3 cameraLeft = normalize(cross(cameraFwd, worldUp));\n    vec3 cameraUp = normalize(cross(cameraLeft, cameraFwd));\n\n    float viewHeight = VIEW_WIDTH * iResolution.y / iResolution.x;\n    \n    // Ray\n    vec2 rawPercent = (fragCoord.xy / iResolution.xy); \n    vec2 percent = rawPercent - vec2(0.5,0.5);\n\n    vec3 rayTarget = (cameraFwd * vec3(CAM_DIST,CAM_DIST,CAM_DIST))\n        - (cameraLeft * percent.x * VIEW_WIDTH)\n        + (cameraUp * percent.y * viewHeight);\n    vec3 rayDir = normalize(rayTarget);    \n    if(MC_SMOOTH)\n    {\n        vec3 partial = vec3(0.0);\n        for(int i=0; i<N_SAMPLES; i++)\n        {\n            rayDir = normalize(rayDir*1000.0+hash33(floor(rayDir/PERTURB_SIZE)*PERTURB_SIZE));\n            partial += trace(cameraPos, rayDir);\n        }\n        fragColor = vec4(partial/float(N_SAMPLES), 1.0);\n    }\n    \n    fragColor = vec4(trace(cameraPos, rayDir), 1.0);\n    \n}\n\n","name":"Image","description":"","type":"image"}]}