{"ver":"0.1","info":{"id":"WsByRW","date":"1586148629","viewed":320,"name":"Confetti twister (atz)","username":"ilyaev","description":"Particles emulation via raymarch repetition study","likes":10,"published":1,"flags":0,"usePreview":0,"tags":["raymarch","particles"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS 156\n#define MIN_DISTANCE 0.001\n#define MAX_DISTANCE 10.\n#define LAYERS 10.\n#define LAYER_SIZE 6.\n\nstruct TraceResult {\n    vec3 id;\n    float dt;\n    float ds;\n    float alpha;\n};\n\nfloat dPoint(vec3 ro, vec3 rd, vec3 p) {\n    return length(cross(rd, p - ro))/length(rd);\n}\n\nfloat n21(vec2 p) {\n    //return fract(sin(dot(n, vec2(12.9898, 4.1414 + iTime*0.00001))) * 43758.5453);\n     return fract(sin(p.x*123.231 + p.y*1432.342 + iTime*0.01)*15344.22);\n}\n\nvec3 getIdColor(vec3 id) {\n    float n = max(.2, n21(vec2(id.x + id.y, id.z)));\n    vec3 rcol = vec3(n, fract(n*4567.433), fract(n*45689.33));\n    return rcol;\n}\n\nTraceResult trace(vec3 ro, vec3 rd) {\n    float ds,dt;\n    float n;\n    vec3 id, shift;\n    float baseSize = .05;\n    vec3 baseSpacing = vec3(baseSize * 4.);\n    vec3 bounds = vec3(LAYER_SIZE, LAYER_SIZE, LAYERS);\n    vec3 l = bounds;\n    vec2 mouse = iMouse.xy/iResolution.xy;\n\n    TraceResult res;\n    res.alpha = 1.;\n\n    for(int i = 0 ; i < MAX_STEPS ; i++) {\n        vec3 p = ro + rd * ds;\n\n        float a = 3.14/2.;\n        p.yz *= mat2(vec2(sin(a), cos(a)), vec2(-cos(a), sin(a)));\n        float aa = sin(iTime/4.)*6.26;//mouse.x * 3.14 * 2.;\n        p.xy *= mat2(vec2(sin(aa), cos(aa)), vec2(-cos(aa), sin(aa)));\n\n        vec3 rc1 = vec3(baseSpacing);\n        vec3 q1 = p - rc1 * clamp(round(p/rc1), -l, l);\n\n\n        id = round(p/rc1).xyz;\n\n        float pa = sin(id.z + iTime * id.z*.05)*6.28;\n\n        \n        // z-layer interval scale\n        rc1.xy *= (1. + (sin(id.z/5. + iTime*3.) * .5 + .5)*2.);\n        // z-layer rotation\n        p.xy *= mat2(vec2(sin(pa), cos(pa)), vec2(-cos(pa), sin(pa)));\n\n        q1 = p - rc1 * clamp(round(p/rc1), -l, l);\n        id = round(p/rc1).xyz;\n\n        float n = n21(vec2(id.x * id.y, id.z * id.x*id.z));\n\n        dt = length(q1 + vec3(.04 * n, .04 * fract(n*567.43), .01)) - baseSize;//- (.05 * fract(n*123.22));\n\n\n        ds += dt * .5;\n        if (abs(dt) < MIN_DISTANCE || dt > MAX_DISTANCE) {\n            if (length(id.xy) > 1.6 && fract(n*718.54) > .5) {\n                break;\n            } else {\n                 ds += .1;\n            }\n        }\n    }\n\n\n\n    res.id = id;\n    res.dt = dt;\n    res.ds = ds;\n\n    return res;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoords) {\n    vec2 uv = ((fragCoords.xy / iResolution.xy) - .5) * vec2(iResolution.x / iResolution.y, 1.);\n    vec2 mouse = iMouse.xy/iResolution.xy;\n\n    vec3 col = vec3(.0);\n\n    vec3 ro = vec3(0.+sin(iTime), 0. + cos(iTime) , -3. + sin(iTime));\n    vec3 lookat = vec3(0., 0., 0.);\n    float zoom = .6;\n\n    vec3 f = normalize(lookat - ro);\n    vec3 r = normalize(cross(vec3(0., 1., 0.), f));\n    vec3 u = cross(f, r);\n\n    vec3 c = ro + f * zoom;\n    vec3 I = c + uv.x * r + uv.y * u;\n\n    vec3 rd = normalize(I - ro);\n\n    TraceResult tr = trace(ro, rd);\n\n    if (tr.dt < MIN_DISTANCE) {\n        vec3 id = tr.id;\n        vec3 rcol = getIdColor(id);\n        col += rcol;\n    }\n\n\n    // col.rg = uv;\n\n    fragColor = vec4(col, 1.);\n}","name":"Image","description":"","type":"image"}]}