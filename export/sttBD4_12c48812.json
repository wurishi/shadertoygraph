{"ver":"0.1","info":{"id":"sttBD4","date":"1663114069","viewed":702,"name":"GPU hacks #15 - WebGPU","username":"PrzemyslawZaworski","description":"Comment contains minimal framework for WebGPU API - with working example, visually equivalent to visible shader (WebGPU logo). ","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["framework","tutorial","demo","webgl","opengl","web","gpu","webgpu","wgsl"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// WebGPU Minimal Example (September 2022)\n// Save code as Demo.html. \n// Install Google Chrome Canary.\n// To enable Unsafe WebGPU, type: chrome://flags/#enable-unsafe-webgpu\n// Restart browser, run HTML file.\n/*\n<html>\n\t<head><meta charset=\"UTF-8\" /></head>\n\t<body>\n\t\t<style>body { background-color: black;} canvas { display: block; margin: auto;}</style>\t\n\t\t<canvas width=\"768\" height=\"768\" id=\"canvas\" ></canvas>\n\t\t<script>\n\t\t\tconst vertexShader =\n\t\t\t`\n\t\t\t\tstruct Interpolators \n\t\t\t\t{\n\t\t\t\t\t@builtin(position) position: vec4<f32>,\n\t\t\t\t\t@location(0) texcoord: vec2<f32>,\n\t\t\t\t};\n\n\t\t\t\t@vertex\n\t\t\t\tfn VSMain(@builtin(vertex_index) vertexId: u32) -> Interpolators\n\t\t\t\t{\n\t\t\t\t\tlet vertices = array<vec2<f32>,3> (vec2(-1.0, -1.0), vec2(3.0, -1.0), vec2(-1.0, 3.0));\n\t\t\t\t\treturn Interpolators(vec4(vertices[vertexId], 0.0, 1.0), vec2(0.5 * vertices[vertexId] + vec2(0.5, 0.5)));\n\t\t\t\t}\n\t\t\t`\n\t\t\tconst fragmentShader =\n\t\t\t`\n\t\t\t\tstruct Uniforms {iTime : f32};\n\t\t\t\t@group(0) @binding(0) var<uniform> uniforms : Uniforms;\n\n\t\t\t\tfn Triangle(p: vec2<f32>, a: vec2<f32>, b: vec2<f32>, c: vec2<f32>) -> f32\n\t\t\t\t{\n\t\t\t\t\tvar ba = b - a;\n\t\t\t\t\tvar cb = c - b;\n\t\t\t\t\tvar ac = a - c;\n\t\t\t\t\tvar pa = p - a;\n\t\t\t\t\tvar pb = p - b;\n\t\t\t\t\tvar pc = p - c;\n\t\t\t\t\tvar q0: vec2<f32> = pa - ba * clamp( dot(pa,ba) / dot(ba,ba), 0.0, 1.0);\n\t\t\t\t\tvar q1: vec2<f32> = pb - cb * clamp( dot(pb,cb) / dot(cb,cb), 0.0, 1.0);\n\t\t\t\t\tvar q2: vec2<f32> = pc - ac * clamp( dot(pc,ac) / dot(ac,ac), 0.0, 1.0);   \n\t\t\t\t\tvar s: f32 = ba.x * ac.y - ba.y * ac.x;\n\t\t\t\t\tvar d = vec2<f32>(dot(q0, q0), s * (pa.x * ba.y - pa.y * ba.x));\n\t\t\t\t\td = min(d, vec2<f32>(dot(q1, q1), s * (pb.x * cb.y - pb.y * cb.x)));\n\t\t\t\t\td = min(d, vec2<f32>(dot(q2, q2), s * (pc.x * ac.y - pc.y * ac.x)));\n\t\t\t\t\treturn step(-sqrt(d.x) * sign(d.y), 0.0);\n\t\t\t\t}\n\n\t\t\t\t@fragment\n\t\t\t\tfn PSMain(@location(0) texcoord: vec2<f32>) -> @location(0) vec4<f32> \n\t\t\t\t{\n\t\t\t\t\tlet t1 = Triangle(texcoord, vec2(0.050, 0.800), vec2(0.675, 0.800), vec2(0.350, 0.250));\n\t\t\t\t\tlet t2 = Triangle(texcoord, vec2(0.675, 0.800), vec2(0.825, 0.525), vec2(0.512, 0.524));\n\t\t\t\t\tlet t3 = Triangle(texcoord, vec2(0.513, 0.524), vec2(0.825, 0.525), vec2(0.675, 0.250));\n\t\t\t\t\tlet t4 = Triangle(texcoord, vec2(0.746, 0.670), vec2(0.825, 0.800), vec2(0.910, 0.670));\n\t\t\t\t\tlet t5 = Triangle(texcoord, vec2(0.746, 0.670), vec2(0.910, 0.670), vec2(0.825, 0.525));\n\t\t\t\t\tlet c1 = vec3(0.00, 0.35, 0.61) * t1;\n\t\t\t\t\tlet c2 = vec3(0.00, 0.40, 0.70) * t2;\n\t\t\t\t\tlet c3 = vec3(0.00, 0.46, 0.80) * t3;\n\t\t\t\t\tlet c4 = vec3(0.00, 0.57, 1.00) * t4;\n\t\t\t\t\tlet c5 = vec3(0.00, 0.52, 0.91) * t5;\n\t\t\t\t\tlet logo = c1 + c2 + c3 + c4 + c5;\n\t\t\t\t\tlet f = logo.r > 0.0 || logo.g > 0.0 || logo.b > 0.0;\n\t\t\t\t\treturn mix(vec4(logo, 1.0), vec4(sin(uniforms.iTime) * 0.5 + 0.5), step(f32(f), 0.0));\t\t\t\t\n\t\t\t\t}\n\t\t\t`\n\t\t\tasync function Main()\n\t\t\t{\n\t\t\t\tif (!navigator.gpu)\n\t\t\t\t{\n\t\t\t\t\talert('WebGPU is not supported, see https://webgpu.io or use Chrome Canary with chrome://flags/#enable-unsafe-webgpu');\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tconst device = await (await navigator.gpu.requestAdapter()).requestDevice();\n\t\t\t\tconst format = navigator.gpu.getPreferredCanvasFormat();\n\t\t\t\tconst renderPipeline = device.createRenderPipeline(\n\t\t\t\t{\n\t\t\t\t\tlayout: 'auto',\n\t\t\t\t\tvertex: {module: device.createShaderModule({ code: vertexShader }), entryPoint: 'VSMain'},\n\t\t\t\t\tfragment: {module: device.createShaderModule({ code: fragmentShader }), entryPoint: 'PSMain', targets: [{ format }]},\n\t\t\t\t\tprimitive: {topology: 'triangle-list'},\n\t\t\t\t});\n\t\t\t\tconst context = document.getElementById('canvas').getContext('webgpu');\n\t\t\t\tcontext.configure({ device, format, alphaMode: 'premultiplied' });\n\t\t\t\tconst uniformBuffer = device.createBuffer({size: 4, usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST});\n\t\t\t\tconst uniformBindGroup = device.createBindGroup(\n\t\t\t\t{\n\t\t\t\t\tlayout: renderPipeline.getBindGroupLayout(0),\n\t\t\t\t\tentries: [{binding: 0, resource: {buffer: uniformBuffer}}],\n\t\t\t\t});\n\t\t\t\tconst uniforms = new Float32Array(1);\n\t\t\t\tfunction Update(time)\n\t\t\t\t{\n\t\t\t\t\tuniforms[0] = time * 0.001;\n\t\t\t\t\tdevice.queue.writeBuffer(uniformBuffer, 0, uniforms);\n\t\t\t\t\tconst commandEncoder = device.createCommandEncoder();\n\t\t\t\t\tconst textureView = context.getCurrentTexture().createView();\n\t\t\t\t\tconst renderPassColorAttachment = {view: textureView, clearValue: {r: 0, g: 0, b: 0, a: 1}, loadOp:'clear', storeOp:'store'};\n\t\t\t\t\tconst renderPassEncoder = commandEncoder.beginRenderPass({colorAttachments: [renderPassColorAttachment]});\n\t\t\t\t\trenderPassEncoder.setPipeline(renderPipeline);\n\t\t\t\t\trenderPassEncoder.setBindGroup(0, uniformBindGroup);\n\t\t\t\t\trenderPassEncoder.draw(3, 1, 0, 0);\n\t\t\t\t\trenderPassEncoder.end();\n\t\t\t\t\tdevice.queue.submit([commandEncoder.finish()]);\n\t\t\t\t\trequestAnimationFrame(Update);\n\t\t\t\t}\n\t\t\t\trequestAnimationFrame(Update);\n\t\t\t}\n\t\t\tMain();\n\t\t</script>\n\t</body>\n</html>\n*/\n\nfloat Triangle( vec2 p, vec2 a, vec2 b, vec2 c )\n{\n\tvec2 ba = b - a;\n\tvec2 cb = c - b;\n\tvec2 ac = a - c;\n\tvec2 pa = p - a;\n\tvec2 pb = p - b;\n\tvec2 pc = p - c;\n\tvec2 q0 = pa - ba * clamp( dot(pa,ba) / dot(ba,ba), 0.0, 1.0);\n\tvec2 q1 = pb - cb * clamp( dot(pb,cb) / dot(cb,cb), 0.0, 1.0);\n\tvec2 q2 = pc - ac * clamp( dot(pc,ac) / dot(ac,ac), 0.0, 1.0);   \n    float s = ba.x * ac.y - ba.y * ac.x;\n    vec2 d =  (vec2(dot(q0, q0), s * (pa.x * ba.y - pa.y * ba.x)));\n    d = min(d, vec2(dot(q1, q1), s * (pb.x * cb.y - pb.y * cb.x)));\n    d = min(d, vec2(dot(q2, q2), s * (pc.x * ac.y - pc.y * ac.x)));\n\treturn step(-sqrt(d.x) * sign(d.y), 0.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float aspect = iResolution.x / iResolution.y;\n    vec2 uv = fragCoord.xy/iResolution.xy * vec2(aspect,1.0) - vec2((aspect-1.0)/2., 0.0);\n    float t1 = Triangle(uv, vec2(0.050, 0.800), vec2(0.675, 0.800), vec2(0.350, 0.250));\n    float t2 = Triangle(uv, vec2(0.675, 0.800), vec2(0.825, 0.525), vec2(0.512, 0.524));\n    float t3 = Triangle(uv, vec2(0.513, 0.524), vec2(0.825, 0.525), vec2(0.675, 0.250));\n    float t4 = Triangle(uv, vec2(0.746, 0.670), vec2(0.825, 0.800), vec2(0.910, 0.670));\n    float t5 = Triangle(uv, vec2(0.746, 0.670), vec2(0.910, 0.670), vec2(0.825, 0.525));\n    vec3 c1 = vec3(0.00, 0.35, 0.61) * t1;\n    vec3 c2 = vec3(0.00, 0.40, 0.70) * t2;\n    vec3 c3 = vec3(0.00, 0.46, 0.80) * t3;\n    vec3 c4 = vec3(0.00, 0.57, 1.00) * t4;\n    vec3 c5 = vec3(0.00, 0.52, 0.91) * t5;\n    vec3 logo = c1 + c2 + c3 + c4 + c5;\n    bool f = logo.r > 0.0 || logo.g > 0.0 || logo.b > 0.0;\n    fragColor = mix(vec4(logo, 1.0), vec4(sin(iTime) * 0.5 + 0.5), step(float(f), 0.0));\n}","name":"Image","description":"","type":"image"}]}