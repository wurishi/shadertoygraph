{"ver":"0.1","info":{"id":"XttfR2","date":"1540301442","viewed":103,"name":"Tezza SDF","username":"Tezza48","description":"My attempt at writing a sphere tracer without reading tutorials.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["3d","sdf","spheretrace","moria"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float Map(vec3 p)\n{\n\tfloat result = MAX_D;\n    result = opU(result, sdPlane(p - vec3(0.0, -1.0, 0.0)));\n    result = opU(result, -sdPlane(p - vec3(0.0, 1.0, 0.0)));\n    opRepeat(p, vec3(2.0));\n    result = opU(result, sdSphere(p, 0.2));\n    result = opU(result, length(max(abs(p) - vec3(0.1, 2.0, 0.1), 0.0)));\n    return result;\n}\n\nfloat Trace(vec3 ro, vec3 rd)\n{\n    float result;\n    result = 1.0;\n    for\t(int i = 0; i < MAX_STEPS; i++)\n    {\n        float d = Map(ro + rd * result);\n        \n        if(d < MIN_D || result > MAX_D) break;\n        \n        result += d;\n    }\n    return result;\n}\n\n\nvec4 Render(vec3 ro, vec3 rd)\n{\n    float t = Trace(ro, rd);\n    \n    return vec4(vec3(1.0 - t/MAX_D) * vec3(0.3, 0.1, 0.15), 1.0);\n}\n\nmat3 LookAt(vec3 ep, vec3 ta, float roll)// eyePos, target\n{\n    vec3 f = ta - ep;\n    vec3 r = cross(vec3(sin(roll), cos(roll), 0.0), f);\n    vec3 u = cross(f, r);\n    return mat3(r, u, f);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy * 2.0 - 1.0;\n\tuv.x *= iResolution.x / iResolution.y;\n    \n    vec3 ro = vec3(0.0, 0.0, -5.0 + iTime * 0.2);\n    vec3 rd = LookAt(ro, ro + vec3(0.0, 0.0, 1.0), iTime * 0.2) * normalize(vec3(uv, 1.0));\n                        \n    vec4 col = Render(ro, rd);\n    \n    \n    // Output to screen\n    fragColor = col;\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define MIN_D 0.01\n#define MAX_D 5.0\n#define MAX_STEPS 64\n\nstruct Hit\n{\n\tfloat d;//distance\n    vec3 n;\n};\n\nfloat sdSphere(vec3 p, float r)\n{\n    return length(p) - r;\n}\n\nfloat sdPlane(vec3 p)\n{\n\treturn p.y;\n}\n\nvoid opRepeat(inout vec3 p, vec3 c)\n{\n\tp = mod(p, c) - 0.5 * c;\n}\n\nfloat opU(float a, float b)\n{\n    return min(a, b);\n}","name":"Common","description":"","type":"common"}]}