{"ver":"0.1","info":{"id":"mdSBRR","date":"1689421708","viewed":64,"name":"Boat on the sea","username":"cosmo_brain","description":"it's a boat\ninspiration for the waves came from Just Shapes and Beats","likes":9,"published":1,"flags":0,"usePreview":0,"tags":["boat"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define TAU (3.1415926*2.)\n#define PI 3.1415926\n#define S(a, b, t) smoothstep(a, b, t)\n\nvec2 rotate(vec2 v, float theta) {\n    float s = sin(theta);\n    float c = cos(theta);\n    mat2x2 rotation = mat2x2(c, s, -s, c);\n    return rotation*v;\n}\n\nfloat map(float v, float min1, float max1, float min2, float max2) {\n    return (v-min1)/(max1-min1) * (max2-min2) + min2;\n}\n\nfloat TaperBox(vec2 uv, float bottomWidth, float topWidth, float height, float offset, float blur) {\n    float percentageUp = (uv.y+height/2.)/height;\n    float width = mix(bottomWidth, topWidth, percentageUp);\n    float currentOffset = mix(-offset/2., offset/2., percentageUp);\n    float leftRight = smoothstep(blur, -blur, abs(uv.x-currentOffset)-width/2.);\n    float topBottom = smoothstep(blur, -blur, abs(uv.y)-height/2.);\n    return leftRight*topBottom;\n}\n\nfloat Circle(vec2 uv, float radius, float blur) {\n    return smoothstep(blur, -blur, length(uv)-radius);\n}\n\nfloat SemiCircle(vec2 uv, float radius, float blur) {\n    return S(-blur, blur, uv.y)*S(blur, -blur, length(uv)-radius);\n}\n\nfloat RoundedRectangle(vec2 uv, float width, float thickness, float blur) {\n    float rectangle = TaperBox(uv, width, width, thickness, 0.0, blur);\n    float right = Circle(uv-vec2(width/2., 0.0), thickness/2., blur);\n    float left = Circle(uv-vec2(-width/2., 0.0), thickness/2., blur);\n    return max(max(rectangle, right), left);\n}\n\nvoid colour(inout vec3 col, vec3 colour, float influence) {\n    col = mix(col, colour, influence);\n}\n\nfloat height(float x, float t) {\n    return sin((x+t)*10.2)*0.04 + sin((x+2.*t)*20.32)*0.02 - 0.05;\n}\n\nfloat Ground(vec2 uv, float t, float blur) {\n    return smoothstep(blur, -blur, uv.y-height(uv.x, t));\n}\n\nfloat GroundFancy(vec2 uv, float t, float blur) {\n    float sideLineSize = 0.0; // this doesn't quite work properly idk why \n    float lineWidth = 0.04;\n\n    float id = floor(uv.x/lineWidth + 0.5);\n    uv.x = fract(uv.x/lineWidth + 0.5)-0.5; // -0.5 to 0.5\n    float y = height(lineWidth*(id-0.5), t);\n    \n    // below circle centre (0, y)\n    // uv.x*uv.x + (y-uv.y)*(y-uv.y)/(0.05*0.05) = 0.5*0.5\n    float currentPointHeight = y + sqrt((lineWidth*lineWidth/4.) * (0.4*0.4-uv.x*uv.x));\n    float sideLines = smoothstep(-blur, blur, (0.5-sideLineSize/2.)-abs(uv.x));\n    \n    return smoothstep(blur, -blur, uv.y-currentPointHeight)*sideLines;\n}\n\nfloat GroundFancySaved(vec2 uv, float t, float blur) {\n    float id = floor(uv.x/0.1 + 0.5);\n    uv.x = fract(uv.x/0.1 + 0.5)-0.5; // -0.5 to 0.5\n    float y = height(0.1*(id-0.5), t);\n    \n    // below circle centre (0, y)\n    // uv.x*uv.x + (y-uv.y)*(y-uv.y)/(0.05*0.05) = 0.5*0.5\n    float currentPointHeight = y + sqrt((0.05*0.05) * (0.4*0.4-uv.x*uv.x));\n    float sideLines = smoothstep(-blur, blur, 0.4-abs(uv.x));\n    \n    return smoothstep(blur, -blur, uv.y-currentPointHeight)*sideLines;\n}\n\n\nvoid Boat(inout vec3 col, vec2 uv, float t, float blur) {\n    float minBound = 0.0;\n    float maxBound = 0.9;\n\n    float mastShadow = map(TaperBox(uv-vec2(0.025-0.007, 0.05), 0.01, 0.01, 0.1, 0.0, blur), 0., 1., 1., 0.8);\n    float flag = TaperBox(uv-vec2(0.025, 0.05 + sin((uv.x+t)*36.31)*0.005*S(0., 0.1, uv.x)), 0.1, 0.0, 0.1, -0.05, blur);\n    // if (flag < maxBound && flag > minBound) colour(col, vec3(0), 1.);\n    /* else */ colour(col, vec3(247, 95, 82)/255. * mastShadow, flag);\n    \n    // colour(col, vec3(181, 103, 14)/255., TaperBox(uv, 0.03, 0.03, 0.2, 0.0, blur));\n    float mastShadowOnMast = map(\n        RoundedRectangle(rotate(uv-vec2(.0080, .0), PI/2.), 0.2, 0.016, blur),\n        0., 1., 1., .8);\n    float mast = RoundedRectangle(rotate(uv, PI/2.), 0.2, 0.03, blur);\n    // if (mast < maxBound && mast > minBound) colour(col, vec3(0.), 1.);\n    /* else */ colour(col, vec3(219, 143, 11)/255. * mastShadowOnMast, mast);\n    \n    \n    /*colour(col, vec3(201, 116, 18)/255., RoundedRectangle(uv-vec2(0.0, -0.1), 0.45, 0.03, blur));\n    colour(col, vec3(201, 116, 18)/255., RoundedRectangle(uv-vec2(0.0, -0.128), 0.35, 0.03, blur));\n    colour(col, vec3(201, 116, 18)/255., RoundedRectangle(uv-vec2(0.0, -0.146), 0.25, 0.03, blur));*/\n    \n    float circle = SemiCircle(rotate(uv-vec2(0.0, -0.1), PI)*vec2(0.6, 1.0), 0.1, blur);\n    float circleShadow = map(TaperBox(uv-vec2(0.0, -0.3), 0.5, 0.5, 0.38, 0.0, blur), 0., 1., 1., .8);\n    // if (circle < maxBound && circle > minBound) colour(col, vec3(0.), 1.);\n    /* else */ colour(col, vec3(219, 143, 11)/255. * circleShadow, circle);\n    \n    float nose = RoundedRectangle(uv-vec2(0.14, -0.11), 0.15, 0.02, blur);\n    colour(col, vec3(219, 143, 11)/255. * circleShadow, nose);\n    \n    float line;\n    for (float i=0.; i<1.; i+=1./8.) {\n        line = TaperBox(uv-vec2(0., -0.11-.1*i + .0*abs(uv.x)*abs(uv.x)), 0.5, 0.5, 0.003, 0.0, blur);\n        colour(col, vec3(0.), line*max(circle, nose));\n    }\n    \n    float highest = max(circle, max(mast, max(nose, flag)));\n    // if (highest < maxBound && highest > minBound) colour(col, vec3(0.), 1.);\n}\n\nfloat angle(float x, float t, float delta) {\n    return atan(height(x+delta/2., t)-height(x-delta/2., t), delta);\n}\n\nfloat Ellipse(vec2 uv, float width, float height, float blur) {\n    return S(blur, -blur, length(vec2(uv.x/width, uv.y/height))-1.);\n}\n\nfloat random(inout float seed) {\n    float result = abs(fract(sin(seed*2314.341239+2.1938)*12.1234920));\n    seed = abs(fract(sin(seed*293.1920304+102.392483)*295.123957));\n    return result;\n}\n\nfloat Cloud(vec2 uv, float seed, int circles, float blur) {\n    float col = float(0.);\n    col += Ellipse(uv, 0.2, 0.1, blur);\n    for (int i=0; i<circles; i++) {\n        float r1 = random(seed);\n        float r2 = random(seed);\n        float r3 = random(seed);\n        \n        col += Ellipse(uv-(vec2(r1, r2)*0.3-.15), mix(.1, .2, r3), mix(.1, .2, r3), blur);\n    }\n    // col /= float(circles);\n    return col;\n}\n\nfloat CloudLayer(vec2 uv, float t, vec2 cloudSize) {\n    float id = floor((uv.x+t*0.5)/0.5/cloudSize.x);\n    float unusedID = id;\n    uv.x = fract((uv.x+t*0.5)/0.5/cloudSize.x);\n    float cloud = Cloud((uv*vec2(1., 4./cloudSize.y)-vec2(0.5+(random(unusedID)-.5)*.2, 1.2+(random(unusedID)-.5)*.5)), id, 6, 0.5);\n    return min(max(cloud, 0.), 1.);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord )\n{\n    float t = iTime*0.1;\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    \n    float blur = 0.001;\n    float boatAngleCoefficient = 1.3;\n    float boatHeightChangeCoefficient = 1.;\n\n    // Time varying pixel color\n    vec3 col = vec3(0.);\n    // colour(col, mix(vec3(48, 160, 240)/255., vec3(0.0, 0.4, 1.0), S(0.0, -0.5, uv.y)), GroundFancy(uv-vec2(0.0, -0.1), t, blur));    \n    \n    float sunBrightness = smoothstep(0., 0.5, length(uv-vec2(-0.4, 0.4)));\n    col = mix(vec3(161, 232, 237)/255., vec3(43, 144, 252)/255., sunBrightness);\n    // col *= mix(0.2, 0.85, S(1., 0., -uv.y*2.*1.1));\n    col *= mix(1., 2.*sin(PI*(.5-uv.y))*sin(PI*(.5-uv.y)), S(0., 1., .5-uv.y));\n    col = min(col, vec3(1.));\n    colour(col, vec3(245, 236, 108)/255., Circle(uv-vec2(-0.4, 0.4), 0.1, blur * mix(8., 20., S(-1., 1., sin(t*2.3))) ));\n    \n    float cloudBrightness = map(pow(sunBrightness, .4), 0., 1., 1., .9);\n    colour(col, vec3(cloudBrightness*.9), CloudLayer(uv*1.8-vec2(0.0, -0.3), t*3., vec2(2.3, 3.)));\n    colour(col, vec3(cloudBrightness*.9), CloudLayer(uv*1.8-vec2(0.8, -0.3), t*3., vec2(2.3, 3.)));\n    colour(col, vec3(cloudBrightness), CloudLayer(uv, t, vec2(1., 1.)));\n    colour(col, vec3(cloudBrightness), CloudLayer(uv-vec2(0.8, 0.05), t, vec2(1., 1.)));\n    \n    Boat(col, rotate(uv/0.8-vec2(0.0, 0.04+height(-0.1, t)*boatHeightChangeCoefficient), 0.03-angle(0.025, t, 0.5)*boatAngleCoefficient), t, blur*2.);\n    // Boat(col, rotate(uv-vec2(0.0, 0.08+height(-0.1, t)*boatHeightChangeCoefficient), -angle(0.025, t, 0.5)*boatAngleCoefficient), t, blur);\n    colour(col, mix(vec3(31, 193, 242)/255., vec3(0.0, 0.0, 0.0), S(-0.05, -0.5, uv.y)), GroundFancy(uv-vec2(0.0, -0.1), t, blur)*0.8);\n    \n    \n    // col *= 0.;\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}