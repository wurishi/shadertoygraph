{"ver":"0.1","info":{"id":"Md3Bzf","date":"1526584661","viewed":224,"name":"Shoot For The Moon","username":"slerpy","description":"\"You must give a description to your shader\" - Shadertoy","likes":8,"published":1,"flags":96,"usePreview":0,"tags":["intro","4k","demoscene"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 t;\n\nconst float GA = 2.399; \nmat2 rot = mat2(cos(GA),sin(GA),-sin(GA),cos(GA));\n\nconst int iter = 80;\n\nvec4 fetch(vec2 u)\n{\n    /*float off = .01;\n    \n    vec4 acc = texture(iChannel0, u);\n    acc.r = texture(iChannel0, u*(1.+off) - .5*off).r; off /= 2.;\n    acc.g = texture(iChannel0, u*(1.+off) - .5*off).g;\n    \n    return acc;*/\n    \n    return texture(iChannel0, u);\n}\n\n// \tsimplyfied version of Dave Hoskins blur\nvec4 dof(vec2 uv, float rad)\n{\n\tvec3 acc=vec3(0);\n    vec2 pixel=vec2(.002*t.y/t.x,.002), angle=vec2(0,rad); rad=1.;\n    \n\tfor (int i=0;i<iter;i++)\n    {  \n        rad += 1./rad;\n\t    angle *= rot;\n        vec4 col = fetch(uv+pixel*(rad-1.)*angle);\n\t\tacc += col.xyz;\n\t}\n    \n\treturn vec4(acc/float(iter), 1);\n}\n\n#define L(A,B,C,D) txt+=step(-.1,-l(u,vec2(A,B),vec2(C,D)))\nfloat l(vec2 u, vec2 p, vec2 q) {\n    vec2 d = q-p, e = u-p;\n    return length(e - d * clamp(dot(d, e)/dot(d, d), .0, 1.));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    t = vec3(iResolution.xy, iTime);\n    \n    vec2 u = fragCoord / t.xy;\n    fragColor = dof(u, texture(iChannel0,u).w) * vec4(2.39 * abs(u.y-0.5) < 1.);\n    \n    //fragColor = texture(iChannel0,u);\n    \n    if(t.z > 90.)\n    {\n        float txt = .0;\n        \n        //u = 16. * vec2(u.x, 1.-u.y);\n        \n        u = (2.*fragCoord - t.xy) / t.y;\n        u = 12.*u + vec2(26, 10) / 2.;\n\n        // SHOOT\n        L(0,10,2,10); L(0,10,0,8); L(0,8,2,8); L(2,8,2,6); L(0,6,2,6);\n        L(3,10,3,6); L(5,10,5,6); L(3,8,5,8);\n        L(6,10,8,10); L(8,10,8,6); L(8,6,6,6); L(6,6,6,10);\n        L(9,10,11,10); L(11,10,11,6); L(11,6,9,6); L(9,6,9,10);\n        L(12,10,14,10); L(13,10,13,6);\n        \n        // FOR\n        L(18,10,18,6); L(18,10,20,10); L(18,8,20,8);\n        L(21,10,23,10); L(21,10,21,6); L(23,6,21,6); L(23,6,23,10);\n        L(24,10,24,6); L(24,10,26,10); L(26,10,26,8); L(24,8,26,8); L(24,8,26,6);\n        \n        // THE\n        L(0,4,2,4); L(1,4,1,0);\n        L(3,4,3,0); L(5,4,5,0); L(3,2,5,2);\n        L(6,4,6,0); L(6,4,8,4); L(6,2,8,2); L(6,0,8,0);\n        \n        // MOON\n        L(13,4,13,0); L(13,4,15,0); L(15,0,17,4); L(17,4,17,0);\n        L(18,4,20,4); L(18,4,18,0); L(20,0,18,0); L(20,0,20,4);\n        L(21,4,23,4); L(21,4,21,0); L(23,0,21,0); L(23,0,23,4);\n        L(24,4,24,0); L(24,4,26,0); L(26,4,26,0);\n        \n        fragColor = mix(fragColor, vec4(min(txt, 1.)), vec4(smoothstep(.0, 4., t.z-99.7)));\n    }\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"MsjXzK","filepath":"https://soundcloud.com/one-of-a-million/shoot-for-the-moon","previewfilepath":"https://soundcloud.com/one-of-a-million/shoot-for-the-moon","type":"musicstream","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define TAU 6.28318530718\n#define PI 3.14159265359\n\nvec3 t;\n\nvec3 g, s;\nint scene;\n\nmat3 rx(float a){ float s=sin(a), c=cos(a); return mat3(1,0,0,0,c,s,0,-s,c); }\nmat3 ry(float a){ float s=sin(a), c=cos(a); return mat3(c,0,s,0,1,0,-s,0,c); }\nmat3 rz(float a){ float s=sin(a), c=cos(a); return mat3(c,s,0,-s,c,0,0,0,1); }\n\nfloat box(vec3 p){return max(max(p.x,p.y),p.z);}\nfloat box(vec2 p){return max(p.x,p.y);}\n\n#define sround(X) (floor(X) + smoothstep(.4, .6, fract(X)))\n\nvoid amod(inout vec2 p, float m)\n{\n    float a=mod(atan(p.x, p.y), m)-m/2.;\n    p = vec2(cos(a),sin(a))*length(p);\n}\n\nfloat noise(vec3 p)\n{\n\tvec3 ip=floor(p); p-=ip; \n    vec3 s=vec3(7,157,113);\n    vec4 h=vec4(0.,s.yz,s.y+s.z)+dot(ip,s);\n    p*=p*(3.-2.*p); \n    h=mix(fract(sin(h)*43758.5),fract(sin(h+s.x)*43758.5),p.x);\n    h.xy=mix(h.xz,h.yw,p.y);\n    return mix(h.x,h.y,p.z); \n}\n\nfloat apollonian(vec3 p, float s)\n{\n\tfloat scale = .5;\n\tfor( int i=0; i<5;i++ )\n\t{\n\t\tp = -1.0+2.0*fract(0.5*p+0.5);\n\t\tfloat r2 = dot(p,p);\n\t\tfloat k = s/r2;\n\t\tp *= k, scale *= k;\n\t}\n\treturn abs(p.y)/scale;\n}\n\nvoid light(vec3 col, float d)\n{\n    g += col * pow(d + 1., -2.);\n}\n\nfloat map(vec3 p)\n{\n    float d = 1e+31; g -= g;\n    \n    // scene distance function\n    \n    if(scene == 0)\n    {\n    \td = min(2.-box(abs(p.xy)), 4.+p.z) + .05*noise( sround(3.*p));\n        //d = min(d, length(abs(p.xy)-vec2(2)) - .04); // bug-fix-noodle\n    \tfloat l = length(p.xy - vec2(2.1*sign(p.x), round(p.y/1.5)*1.5)) - .1;\n    \td = min(d, l); if(noise(round(p/1.5))-.2*t.z+.7 < 0.) light(vec3(1), 8.*l); //g = min(g, lights);\n        g += exp(-p.y) * 0.004 * ( noise(2.*p-t.zxx) + noise(3.*p-t.zyy) + 1. );\n    }\n    else if(scene == 1)\n    {\n        vec3 q = (p + 3.*t) * sign(p.y);\n        float h = noise(q.xzx);\n        d = 0.2 * h + 1.5 - abs(p.y);\n        g += 0.1 * noise(q) * exp(-0.05 * dot(p,p));\n    }\n    else if(scene == 2)\n    {\n        vec3 q = p; q.z += 5.*t.z; //(2.5 * vec3(1, 1, t.z*2.) + p) * rz(-.06 * (p.z + t.z));\n        q *= rz(-0.02 * p.z); amod(q.xy, PI/8.);\n        q = abs(q - round(q/5.)*5.);\n        d = min(box(q.xy), min(box(q.xz), box(q.yz))) - .2;\n        float l = length(q) - .2; d = min(d, l); light(noise(p)*vec3(1), 3.*l);\n        d = max(d, 5.-length(p.xy));\n        g += g * noise(p);\n    }\n    else if(scene == 3)\n    {\n        vec3 q = (p + vec3(7, 0, 5.*t.z)) * ry(.25*PI);\n        q.y += sround(noise(q.xzx));\n        d = apollonian(.1*q-1., 1.3);\n        light(vec3(1.), (10.-abs(p.y)) * 16.);\n        g += .03 * noise(q.xzx);\n        p.z -= 1.5 * (t.z - 49. - 2.);\n    }\n    else if(scene == 4)\n    {\n        vec3 q = p + vec3(0, 0, 15.*t.z);\n        q *= rz(.1*q.z); q += 3.;\n        q = abs(q - round(q/6.)*6.);\n        d = min(box(q.xy), min(box(q.xz), box(q.yz))) - .08*dot(q,q) - .1;\n        float l = box(q)-.3; d = min(d, l); light(vec3(1), 2.*l);\n        p.z += .6 * (73.5 - t.z);\n    }\n    else if(scene == 5)\n    {\n        p.z -= 10.;\n        float dist = 4.*(t.z-94.5);\n        const float r = 80.;\n        float l = length(p) - 5. + exp(-dist+2.);\n        vec3 c = p - vec3(0,0,r - min(4.*dist, 0.));\n        float w = 200. - abs(p.x);\n        d = min(min(l, w), length(c) - r + noise(c));\n        light(vec3(3,1,0), l / max(1., .2*dist+1.));\n        p.z -= dist;\n        g += .003 * noise(p);\n    }\n    \n    // ship distance function\n    \n    const float s = .5;\n    \n\tvec3 q = p; amod(q.yz, TAU/6.);\n    float ship = abs(q.x) + s*abs(q.y) - s; // main shape\n    ship = max(.5*ship, -p.z-radians(30.)*abs(p.y)); // back\n    \n    float win = ship + .03;\n    ship = min(win, max(ship, min(p.z-p.y-.1, p.y-.2))); // window\n    light(-g, 10.*win);\n    \n    float thr = box(abs(p)-vec3(.4-s*abs(p.y), .4, .45)) + .05*noise(20.*p.xyx);\n    ship = min(ship, max(p.z, .7*thr) ); // thruster\n    \n    d = min(d, ship);\n    \n    if(scene > 0)\n    {\n        float flicker = 0.7 + 0.6 * noise(20.*t.zzz);\n    \tfloat beam = max(p.z+.5, length(p.xy)-.25); // beam\n        if(flicker > t.z - 93.7)\n        {\n            d = min(d, beam);\n            light(flicker*vec3(0,1,2), 8.*beam);\n        }\n    }\n    \n    return d;\n}\n\nvec3 normal(vec3 p)\n{\n\tvec2 e = vec2(0, 0.001);\n\treturn normalize(vec3(map(p+e.yxx), map(p+e.xyx), map(p+e.xxy)) - map(p));\n}\n\nfloat tracer(vec3 ro, vec3 rd, int iter)\n{\n    s -= s;\n    float tr = .01, m;\n    for(int i=0; i < iter; i++)\n    {\n        tr += m = map(ro + rd * tr), s += g * m;\n        if(m < .001)break;\n    }\n    s = g + 0.1 * s;\n    return tr;\n}\n\n#define CUT(SCENE, TIME, XROT, YROT, ZROT, DIST) \\\n\tfade = min(.3 * abs(t.z-TIME), fade); \\\n    if(t.z > TIME) scene = SCENE, cam = vec4(XROT, YROT, ZROT, DIST)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    t = vec3(iResolution.xy, iTime);\n    \n    // camera setup\n    \n    vec4 cam;\n    float fade = 1.;\n    \n    CUT(0, 00.00, .01*t.z-.1, PI, 0.0, 6.-0.1*t.z);\t// garage\n    CUT(1, 12.50, -.2, 2.5, -.1, 7.);\t\t\t\t// shiny goo\n    CUT(2, 25.00, 0.3, .1*t.z-1.3, 0.0, 9.5);\t\t// lit grid\n    CUT(3, 37.00, -.1, 2., 0.0, 32.);\t\t\t\t// apollonian\n    CUT(4, 61.50, 0.1, .15, -.3, 8.);\t\t\t\t// crystals\n    CUT(5, 85.50, 0.0, PI/2., 0.0, 50.);\t\t\t// moon\n    \n    vec2 shake = vec2(noise(t), noise(1.3*t)) - 0.5;\n    mat3 rm = ry(cam.y) * rx(cam.x) * rz(cam.z);\n    vec3 rd = rm * normalize(vec3(fragCoord.xy-.5*t.xy, t.y));\n\tvec3 ro = rm * vec3(.1*shake, -cam.w);\n    \n    // first trace\n    \n    float tr = tracer(ro,rd, 100);\n\tvec3 sp = ro + rd * tr;\n\tvec3 sn = normal(sp);\n    vec3 emit = s;\n    \n    // debug\n    \n#if 0\n    vec3 col = 0.5 + 0.5 * sn;\n    fragColor = vec4(col + emit, 0);\n    return;\n#endif\n    \n    // reflection\n    \n    vec3 rd2 = reflect(rd, sn), ro2 = sp;\n    float tr2 = tracer(ro2, rd2, 50);\n    emit += g;\n    \n    // color\n    \n    float blur = .06 * abs(tr - cam.w + .5);\n    emit *= smoothstep(0.0, 1.0, fade);\n    vec4 last = texelFetch(iChannel0, ivec2(fragCoord/2.), 1);\n\tfragColor = mix(last, vec4(emit, blur), vec4(.7));\n    \n    fragColor = clamp(vec4(0), vec4(1), fragColor);\n}\n","name":"Buffer A","description":"","type":"buffer"}]}