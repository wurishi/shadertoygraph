{"ver":"0.1","info":{"id":"ltd3D2","date":"1471875415","viewed":127,"name":"rh logo","username":"ZeBestNickname","description":"renderheads logo","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["sdf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n\nfloat sdCylinder(vec3 p, vec2 h)\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdCone(vec3 p, vec3 c)\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    float d1 = -p.y-c.z;\n    float d2 = max( dot(q,c.xy), p.y);\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n}\n\nconst float epsilon = 0.0001;\n\nvec3 transformPoint(vec3 p, vec3 translation, vec3 rotation){\n    vec4 p_fixed = vec4(p, 1);\n    \n    mat4 x_rot_mat = mat4(1, 0, 0, 0,\n                         0, cos(rotation.x), -sin(rotation.x), 0,\n                         0, sin(rotation.x), cos(rotation.x), 0,\n                         0, 0, 0, 1);\n    \n    mat4 y_rot_mat = mat4(cos(rotation.y), 0, sin(rotation.y), 0,\n                         0, 1, 0, 0,\n                         -sin(rotation.y), 0, cos(rotation.y), 0,\n                         0, 0, 0, 1);\n   \n    mat4 z_rot_mat = mat4(cos(rotation.z), -sin(rotation.z), 0, 0,\n                         sin(rotation.z), cos(rotation.z), 0, 0,\n                         0, 0, 1, 0,\n                         0, 0, 0, 1);\n    \n    mat4 translate_mat = mat4(1, 0, 0, translation.x,\n                             0, 1, 0, translation.y,\n                             0, 0, 1, translation.z,\n                             0, 0, 0, 1);\n    \n    vec4 translated = p_fixed * translate_mat * z_rot_mat * y_rot_mat * x_rot_mat;\n    \n    return translated.xyz;\n}\n\nfloat cylinder(vec3 p, vec2 props, vec3 trans, vec3 rot){\n    float wub = 0.2 * sin(iTime * 5.0);\n    p -= vec3(1, 0, 0);\n    vec3 tp = transformPoint(p, trans, rot);\n    float d = sdCylinder(tp, vec2(props.x, props.y + wub));\n\n    return d;\n}\n\nfloat cone(vec3 p, vec3 props, vec3 trans, vec3 rot){\n    float wub = 0.2 * sin(iTime * 5.0);\n    p -= vec3(1, 0, 0);\n    vec3 tp = transformPoint(p, trans, rot);\n    float d = sdCone(tp, vec3(props.xy, props.z + wub / 2.0));\n\n    return d;\n}\n\nconst float PI = 3.1415926;\nconst float quarter = PI / 4.0;\nconst float r_angle = PI / 2.0;\n\nfloat xr1 = quarter / 0.6;\nfloat zr1 = -quarter / 0.8;\n\nfloat xr2 = quarter + quarter / 1.5;\nfloat zr2 = -quarter / 1.1;\n\nfloat xr3 = -quarter - quarter / 4.0;\nfloat zr3 = -r_angle - quarter / 1.55;\n\nfloat xr4 = -quarter - quarter / 2.0;\nfloat zr4 = -r_angle - quarter * 0.2;\n\nfloat xr5 = -quarter * 1.15;\nfloat zr5 = -r_angle - quarter * 0.2;\n\nfloat zr6 = quarter * 1.4;\n\nfloat scene(vec3 p){\n    float out_dist = cylinder(p, vec2(0.5, 3), vec3(3, 0, -20), vec3(xr1, 0, zr1));\n    out_dist = min(out_dist, cylinder(p, vec2(0.3, 3), vec3(2, 0.3, -18), vec3(xr1, 0, zr1)));\n    out_dist = min(out_dist, cylinder(p, vec2(0.35, 3), vec3(1.75, 0.925, -18), vec3(xr1, 0, zr1)));\n    out_dist = min(out_dist, cylinder(p, vec2(0.375, 3), vec3(1.315, 0.325, -18), vec3(xr1, 0, zr1)));\n    out_dist = min(out_dist, cylinder(p, vec2(0.3, 3), vec3(0.95, 0, -18), vec3(xr2, 0, zr2)));\n    out_dist = min(out_dist, cone(p, vec3(normalize(vec2(10, 1)), 3.5), vec3(2, 1.1, -16.5), vec3(xr3, 0, zr3)));\n    out_dist = min(out_dist, cone(p, vec3(normalize(vec2(7.5, 1)), 3.5), vec3(2, 1.1, -16.5), vec3(xr4, 0, zr4)));\n    out_dist = min(out_dist, cone(p, vec3(normalize(vec2(12, 1)), 3.75), vec3(2, 1.1, -16.5), vec3(xr5, 0, zr5)));\n    out_dist = min(out_dist, cylinder(p, vec2(0.35, 3), vec3(0, 0.45, -17.5), vec3(xr1, 0, -zr1)));\n    out_dist = min(out_dist, cylinder(p, vec2(0.35, 4), vec3(-0.55, -0, -18), vec3(xr1, 0, zr6)));\n    \n    return out_dist;\n}\n\nvec4 render(vec3 p){\n    float tot_weight = 0.0;\n    vec4 final_col = vec4(0, 0, 0, 1);\n    \n    float d = cylinder(p, vec2(0.5, 3), vec3(3, 0, -20), vec3(xr1, 0, zr1));\n    float weight = d < epsilon ? 1.0 : 0.0;\n    final_col += weight * vec4(0, 0.75, 0.65, 1);\n    tot_weight += weight;\n    \n    d = cylinder(p, vec2(0.3, 3), vec3(2, 0.3, -18), vec3(xr1, 0, zr1));\n    weight = d < epsilon ? 1.0 : 0.0;\n    final_col += weight * vec4(0, 0.65, 0.75, 1);\n    tot_weight += weight;\n    \n    d = cylinder(p, vec2(0.35, 3), vec3(1.75, 0.925, -18), vec3(xr1, 0, zr1));\n    weight = d < epsilon ? 1.0 : 0.0;\n    final_col += weight * vec4(0, 0.65, 0.25, 1);\n    tot_weight += weight;\n    \n    d = cylinder(p, vec2(0.375, 3), vec3(1.315, 0.325, -18), vec3(xr1, 0, zr1));\n    weight = d < epsilon ? 1.0 : 0.0;\n    final_col += weight * vec4(0, 0.95, 0.9, 1);\n    tot_weight += weight;\n    \n    d = cylinder(p, vec2(0.3, 3), vec3(0.95, 0, -18), vec3(xr2, 0, zr2));\n    weight = d < epsilon ? 1.0 : 0.0;\n    final_col += weight * vec4(0.1, 0.7, 1, 1);\n    tot_weight += weight;\n    \n    d = cone(p, vec3(normalize(vec2(10, 1)), 3.5), vec3(2, 1.1, -16.5), vec3(xr3, 0, zr3));\n    weight = d < epsilon ? 1.0 : 0.0;\n    final_col += weight * vec4(1, 0.45, 0.0, 1);\n    tot_weight += weight;\n    \n    d = cone(p, vec3(normalize(vec2(7.5, 1)), 3.5), vec3(2, 1.1, -16.5), vec3(xr4, 0, zr4));\n    weight = d < epsilon ? 1.0 : 0.0;\n    final_col += weight * vec4(1, 0.1, 0, 1);\n    tot_weight += weight;\n    \n    d = cone(p, vec3(normalize(vec2(12, 1)), 3.75), vec3(2, 1.1, -16.5), vec3(xr5, 0, zr5));\n    weight = d < epsilon ? 1.0 : 0.0;\n    final_col += weight * vec4(1, 1, 0, 1);\n    tot_weight += weight;\n    \n    d = cylinder(p, vec2(0.35, 3), vec3(0, 0.45, -17.5), vec3(xr1, 0, -zr1));\n    weight = d < epsilon ? 1.0 : 0.0;\n    final_col += weight * vec4(0.8, 0.2, 0.4, 1);\n    tot_weight += weight;\n    \n    d = cylinder(p, vec2(0.35, 4), vec3(-0.55, -0, -18), vec3(xr1, 0, zr6));\n    weight = d < epsilon ? 1.0 : 0.0;\n    final_col += weight * vec4(1, 0.4, 0.75, 1);\n    tot_weight += weight;\n    \n    final_col /= tot_weight;\n    \n    return final_col;\n}\n\nfloat max_dist = 100.0;\n\n\nvec3 getNormal(vec3 p){\n    float nx = scene(vec3(p.x + epsilon, p.y, p.z)) - scene(vec3(p.x - epsilon, p.y, p.z));\n    float ny = scene(vec3(p.x, p.y + epsilon, p.z)) - scene(vec3(p.x, p.y - epsilon, p.z));\n    float nz = scene(vec3(p.x, p.y, p.z + epsilon)) - scene(vec3(p.x, p.y, p.z - epsilon));\n    \n    return normalize(vec3(nx, ny, nz));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float aspect = max(iResolution.x, iResolution.y);\n    float x_half = iResolution.x / (aspect * 2.0);\n    float y_half = iResolution.y / (aspect * 2.0);\n    \n    vec3 dir = normalize(vec3(fragCoord.xy / aspect - vec2(x_half, y_half), 1.0));\n    \n    float rayLength = 1.0;\n    \n    vec4 color = vec4(0, 0, 0, 1);\n    \n    for(int k = 0; k < 75; ++k){\n        float d = scene(dir * rayLength);\n        if(d < epsilon){\n            color = render(dir * rayLength);\n            vec3 normal = getNormal(dir * rayLength);\n            \n            float dp = -dot(normal, dir);\n            \n            fragColor = dp * color;\n            break;\n           //return;\n        }\n        \n        if(rayLength > max_dist){\n            fragColor = vec4(0, 0, 0, 1);\n            break;\n            //return;\n        }\n                                \n        rayLength += d;\n    }\n    \n    rayLength /= (max_dist / 5.0);\n    rayLength = 1.0 - rayLength;\n    fragColor = vec4(rayLength, rayLength, rayLength, 1);\n}","name":"Image","description":"","type":"image"}]}