{"ver":"0.1","info":{"id":"mlsBDS","date":"1693417428","viewed":44,"name":"Fork Fork Fork  sleeplessm 640","username":"sleeplessmonk","description":"tried to change the fractal formula part, not the best results but looks cool still","likes":2,"published":1,"flags":64,"usePreview":0,"tags":["fractal","rainbow","esplosion"],"hasliked":0,"parentid":"dlfBRj","parentname":"Fork Fork more  sleeplessm 178"},"renderpass":[{"inputs":[{"id":"MsdGDN","filepath":"https://soundcloud.com/mindfulnomads/internal-strife","previewfilepath":"https://soundcloud.com/mindfulnomads/internal-strife","type":"musicstream","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define l 300\n\nvoid mainImage(out vec4 FragColor, vec2 FragCoord) {\n    vec2 uv = (FragCoord.xy - iResolution.xy/2.0) / min(iResolution.y, iResolution.x) * 100.0;\n    vec2 vv = uv;\n\n    // Apply rotational symmetry\n    float rotationAngle = mod(iTime * 1000.1, 60.1415 * 20000.0);\n    vec2 rotatedUV = mat2(cos(rotationAngle), -sin(rotationAngle), sin(rotationAngle), cos(rotationAngle)) * uv;\n\n    float ft = iTime + 2900.1;\n    float tm = ft * 0.0001;\n    float tm2 = ft * 0.003;\n    \n    // Apply Kaleidoscope Effect\n    vec2 mspt = (vec2(\n        sin(tm) + cos(tm * 0.02) + sin(tm * 0.05) + cos(tm * -0.04) + sin(tm * 10.3),\n        cos(tm) + sin(tm * 0.01) + cos(tm * .8) + sin(tm * -0.1) + cos(tm * .005)\n    ) + 1.0) * 0.35; // 5x harmonics, scale back to [0,1]\n\n    float R = 100.0;\n    float RR = 10.0;\n    float RRR = 10.0;\n    float a = (1. - mspt.x) * 0.05;\n    float C = cos(tm2 * 0.003 + a * 0.001) * 1.1;\n    float S = sin(tm2 * 0.0033 + a * 0.023) * 1.1;\n    float C2 = cos(tm2 * 0.024 + a * 0.023) * 3.1;\n    float S2 = sin(tm2 * 0.03 + a * 0.01) * 3.3;\n    vec2 xa = vec2(C, -S);\n    vec2 ya = vec2(S, C);\n    vec2 xa2 = vec2(C2, -S2);\n    vec2 ya2 = vec2(S2, C2);\n    vec2 shift = vec2(0.033, 0.14);\n    vec2 shift2 = vec2(-0.023, -0.22);\n    float Z = 0.4 + mspt.y * 0.3;\n    float m = 0.99 + sin(iTime * 0.003) * 0.0003;\n\n    // Retrieve audio amplitude from iChannel1\n    float audioAmplitude = texture(iChannel1, vec2(.5)).r;\n\n   for (int i = 80; i < l; i++) {\n    float r = dot(rotatedUV, rotatedUV);\n    float r2 = dot(vv, vv);\n    if (r > 1.0) {\n        r = (1.0) / r;\n        rotatedUV.x = rotatedUV.x * r;\n        rotatedUV.y = rotatedUV.y * r;\n    }\n    if (r2 > 1.0) {\n        r2 = (1.0) / r2;\n        vv.x = vv.x * r2;\n        vv.y = vv.y * r2;\n    }\n    \n    // Apply a rotation to the vectors for more symmetry and branching\n    rotatedUV = mat2(cos(iTime * 0.1), -sin(iTime * 0.1), sin(iTime * 0.1), cos(iTime * 0.1)) * rotatedUV;\n    vv = mat2(cos(iTime * 0.2), -sin(iTime * 0.2), sin(iTime * 0.2), cos(iTime * 0.2)) * vv;\n\n    R *= m;\n    R += r;\n    R *= m;\n    R += r2;\n    if (i < l - 1) {\n        RR *= m;\n        RR += r;\n        RR *= m;\n        RR += r2;\n        if (i < l - 2) {\n            RRR *= m;\n            RRR += r;\n            RRR *= m;\n            RRR += r2;\n        }\n    }\n\n    rotatedUV = vec2(dot(rotatedUV, xa), dot(rotatedUV, ya)) * Z + shift;\n    vv = vec2(dot(vv, xa2), dot(vv, ya2)) * Z + shift2;\n}\n\n\n    float c = ((mod(R, 2.0) > 1.0) ? 1.0 - fract(R) : fract(R));\n    float cc = ((mod(RR, 2.0) > 1.0) ? 1.0 - fract(RR) : fract(RR));\n    float ccc = ((mod(RRR, 2.0) > 1.0) ? 1.0 - fract(RRR) : fract(RRR));\n\n    // Apply audio-reactive neon colors\n    vec3 neonColor = vec3(\n        0.5 + 0.5 * sin(c * 10.0 + iTime * audioAmplitude * 30.0),\n        0.5 + 0.5 * sin(cc * 10.0 + iTime * audioAmplitude * 30.0 + 1.0),\n        0.5 + 0.5 * sin(ccc * 10.0 + iTime * audioAmplitude * 30.0 + 2.0)\n    );\n\n    FragColor = vec4(neonColor, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}