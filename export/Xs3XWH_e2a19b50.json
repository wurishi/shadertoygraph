{"ver":"0.1","info":{"id":"Xs3XWH","date":"1459001923","viewed":400,"name":"mandel-julia relation explorer","username":"MacSlow","description":"A handy mandelbrot-julia set relation explorer. Click or click-drag in the mandelbrot-set to see the related julia-set on the other half of the canvas. The iteration-orbit of the selected point c is also displayed by default.","likes":17,"published":1,"flags":0,"usePreview":0,"tags":["fractal","julia","mandelbrot","explorer"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"////////////////////////////////////////////////////////////////////////////////\n//\n// Plain mandelbrot/julia-set fragment-shader with 2x2-grid super-sampling and\n// relation exploring function... click or click-drag in the mandelbrot-set to\n// see the corresponding julia-set on the other half of the canvas\n//\n// Copyright 2015-2016 Mirco Müller\n//\n// Author(s):\n//   Mirco \"MacSlow\" Müller <macslow@gmail.com>\n//\n// This program is free software: you can redistribute it and/or modify it\n// under the terms of the GNU General Public License version 3, as published\n// by the Free Software Foundation.\n//\n// This program is distributed in the hope that it will be useful, but\n// WITHOUT ANY WARRANTY; without even the implied warranties of\n// MERCHANTABILITY, SATISFACTORY QUALITY, or FITNESS FOR A PARTICULAR\n// PURPOSE.  See the GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License along\n// with this program.  If not, see <http://www.gnu.org/licenses/>.\n//\n////////////////////////////////////////////////////////////////////////////////\n\nconst float PI = 3.14159265358979323846;\nconst vec4 red     = vec4 (1.0, 0.0, 0.0, 1.0);\nconst vec4 green   = vec4 (0.0, 1.0, 0.0, 1.0);\nconst vec4 blue    = vec4 (0.0, 0.0, 1.0, 1.0);\nconst vec4 white   = vec4 (1.0, 1.0, 1.0, 1.0);\nconst vec4 orange  = vec4 (1.0, 0.4, 0.125, 1.0);\nconst vec4 black   = vec4 (0.0, 0.0, 0.0, 1.0);\nconst vec4 cyan    = vec4 (0.0, 1.0, 1.0, 1.0);\nconst vec4 magenta = vec4 (1.0, 0.0, 1.0, 1.0);\nconst vec4 yellow  = vec4 (1.0, 1.0, 0.0, 1.0);\nconst float MAX_ITER = 256.;\nconst float LENGTH_LIMIT = 5.;\nconst bool SHOW_ORBIT = true;\nconst float THICKNESS = 0.0075;\n\nvec4 line (vec2 p, vec2 a, vec2 b, vec4 c, float thickness)\n{\n    vec2 pa = -p - a;\n    vec2 ba = b - a;\n    float h = clamp (dot (pa, ba) / dot (ba, ba), 0.0, 1.0);\n    float d = length (pa - ba * h);\n    \n    return c * clamp (((1.0 - d) - (1.0 - thickness)) * 100.0, 0.0, 1.0);\n}\n\nvec4 gradient (float v) {\n    float steps = 7.;\n    float step = 1. / steps;\n    vec4 col = black;\n\n    if (v >= .0 && v < step) {\n        col = mix (yellow, orange, v * steps);\n    } else if (v >= step && v < 2.0 * step) {\n        col = mix (orange, red, (v - step) * steps);\n    } else if (v >= 2.0 * step && v < 3.0 * step) {\n        col = mix (red, magenta, (v - 2.0 * step) * steps);\n    } else if (v >= 3.0 * step && v < 4.0 * step) {\n        col = mix (magenta, cyan, (v - 3.0 * step) * steps);\n    } else if (v >= 4.0 * step && v < 5.0 * step) {\n        col = mix (cyan, blue, (v - 4.0 * step) * steps);\n    } else if (v >= 5.0 * step && v < 6.0 * step) {\n        col = mix (blue, green, (v - 5.0 * step) * steps);\n    }\n\n    return col;\n}\n\nvec4 calcMandel (vec2 c)\n{\n    vec2 z = vec2 (.0);\n    float iter = .0;\n\n    for (float i = 0.; i < MAX_ITER; i += 1.) {\n        z = mat2 (z, -z.y, z.x) * z + c;\n        if (length (z) > LENGTH_LIMIT && iter == .0) {\n            iter = i;\n        }\n    }\n\n    return length (z) <= LENGTH_LIMIT ? vec4 (0) : gradient (iter / MAX_ITER);\n}\n\nvec4 mandel (vec2 p, vec2 size)\n{\n    // ordered 2x2-grid super-sampling\n    return (  calcMandel (p + size * vec2 (-.5, -.5))\n            + calcMandel (p + size * vec2 ( .5, -.5))\n            + calcMandel (p + size * vec2 ( .5,  .5))\n            + calcMandel (p + size * vec2 (-.5,  .5))) / 4.;\n}\n\nvec4 calcJulia (vec2 p, vec2 c)\n{\n    vec2 z = p;\n    float iter = .0;\n\n    for (float i = 0.; i < MAX_ITER; i+= 1.) {\n        z = mat2 (z, -z.y, z.x) * z + c;\n        if (length (z) > LENGTH_LIMIT && iter == .0) {\n            iter = i;\n        }\n    }\n    return length (z) <= LENGTH_LIMIT ? vec4 (0) : gradient (iter / MAX_ITER);\n}\n\nvec4 julia (vec2 p, vec2 size, vec2 c)\n{\n    // ordered 2x2-grid super-sampling\n    return (  calcJulia (p + size * vec2 (-.5, -.5), c)\n            + calcJulia (p + size * vec2 ( .5, -.5), c)\n            + calcJulia (p + size * vec2 ( .5,  .5), c)\n            + calcJulia (p + size * vec2 (-.5,  .5), c)) / 4.;\n}\n\nvec4 morbit (vec2 p, vec2 s, float thickness)\n{\n    vec4 result = vec4 (.0);\n    vec2 z = vec2 (.0);\n    vec2 zNew = vec2 (.0);\n    vec2 c = s;\n\n    for (float i = .0; i < MAX_ITER; i+= 1.) {\n        zNew = mat2 (z, -z.y, z.x) * z + c;\n\t    result += line (p, vec2 (-z.x, z.y), vec2 (-zNew.x, zNew.y), vec4 (1.), thickness);\n        z = zNew;\n    }\n    return result;\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 p)\n{\n    vec2 res = iResolution.xy;\n    vec2 uv = vec2 (p.x / res.x, p.y / res.y);\n    vec2 nuv = -1. + 2. * uv;\n    float aspect = iResolution.x / iResolution.y;\n    nuv.y /= aspect;\n\n    float s = 3.;\n    vec2 moffset = s * vec2 (1./4., .0);\n    vec2 joffset = s * vec2 (1./6., .0);\n    vec2 pmandel = vec2 (nuv) - moffset;\n    vec2 pjulia = vec2 (nuv) + joffset;\n\n    vec2 m = vec2 (iMouse.x / iResolution.x, iMouse.y / iResolution.y);\n    vec2 nc = -1. + 2. * m;\n    vec2 mc = nc - moffset;\n    mc *= s;\n    mc.y /= aspect;\n    mc.y *= -1.;\n\n    if (nuv.x > .0) {\n    \tfragColor = mandel (s * pmandel , s/res);\n    } else {\n    \tfragColor = julia (s * pjulia , s/res, mc);\n    }\n\n    if (SHOW_ORBIT) {\n        fragColor += morbit (s * pmandel, mc, THICKNESS);\n    }\n}\n","name":"Image","description":"","type":"image"}]}