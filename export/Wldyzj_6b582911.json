{"ver":"0.1","info":{"id":"Wldyzj","date":"1609522421","viewed":653,"name":"Aztec Diamond Animation","username":"Shadron","description":"Animated random generation of an Aztec Diamond domino tiling.\nCreated with Shadron, [url]http://www.shadron.info[/url]\n4K video: [url]https://youtu.be/CCL77BUymSY[/url]\nExplanation by Mathologer: [url]https://youtu.be/Yy7Q8IWNfHM[/url]","likes":22,"published":1,"flags":32,"usePreview":0,"tags":["2d","math","visualization","mathematics","animation","aztecdiamond"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n// Aztec Diamond by Chlumsky\n// Created with Shadron\n// www.shadron.info\n\nconst bool darkMode = true;\nconst bool opaqueBg = true;\nconst float borderThickness = 0.125;\nconst float arrowSize = 0.25;\n\nconst float EPS = 1.0/1024.0;\n\nint animationType;\nint size;\nfloat animationTimer;\nfloat scale;\n\nfloat linearstep(float a, float b, float x) {\n    return clamp((x-a)/(b-a), 0.0, 1.0);\n}\n\nfloat rectangleDistance(vec2 pos, vec2 lb, vec2 rt) {\n    vec2 d = min(pos-lb, rt-pos);\n    return min(d.x, d.y);\n}\n\nfloat halfPlaneDistance(vec2 pos, vec2 a, vec2 b) {\n    return dot(normalize(vec2(b.y-a.y, a.x-b.x)), a-pos);\n}\n\nfloat rectangleSmooth(vec2 pos, vec2 lb, vec2 rt, float border) {\n    return clamp(rectangleDistance(pos, lb, rt)/border+0.5, 0.0, 1.0);\n}\n\nfloat halfPlaneSmooth(vec2 pos, vec2 a, vec2 b, float border) {\n    return clamp(halfPlaneDistance(pos, a, b)/border+0.5, 0.0, 1.0);\n}\n\nbool isNew(vec4 texel) {\n    float a = texel.a;\n    if (a < 0.625)\n        a *= 2.0;\n    return a < 0.9375;\n}\n\nfloat pieceOrd(ivec2 diamondCoord) {\n    vec2 coord = vec2(diamondCoord)+0.5;\n    vec2 baseDataCoord = 0.5*coord/float(diamondSize);\n    vec2 pos = scale*(baseDataCoord-0.5)/vec2(iResolution.x/iResolution.y, 1.0)+0.5;\n    return linearstep(0.25, 0.75, mix(pos.x, pos.y, 0.75));\n}\n\nfloat animatePopIn(vec2 screenPos, ivec2 diamondCoord, float start, float end, float screenBased, float diffuse) {\n    float preT = linearstep(start, end, animationTimer);\n    float prd = mix(pieceOrd(diamondCoord), mix(screenPos.x, screenPos.y, 0.75), screenBased);\n    float t = linearstep(mix(prd, 0.0, diffuse), mix(prd, 1.0, diffuse), preT);\n    float g = 0.0;\n    float tmo = t-1.0;\n    return ((g+1.0)*tmo+g)*tmo*tmo+1.0;\n}\n\nfloat animateShift() {\n    return smoothstep(0.0, 1.0, smoothstep(0.0, 0.95, animationTimer));\n}\n\nfloat animateInflate(vec2 screenPos, ivec2 diamondCoord) { return animatePopIn(screenPos, diamondCoord, 0.0, 0.375, 0.5, 0.25); }\nfloat animateSplit(vec2 screenPos, ivec2 diamondCoord) { return animatePopIn(screenPos, diamondCoord, 0.25, 0.625, 0.0, 0.25); }\nfloat animateArrowFadeIn(vec2 screenPos, ivec2 diamondCoord) { return animatePopIn(screenPos, diamondCoord, 0.375, 0.75, 0.25, 0.25); }\nfloat animateFadeIn(vec2 screenPos, ivec2 diamondCoord) { return animatePopIn(screenPos, diamondCoord, 0.75, 1.0, 0.25, 0.75); }\n\nvec3 drawDomino(vec2 coord, float pixelSize, vec2 orientation) {\n    vec3 domino = vec3(0.0); // vec3(fill, border, arrow)\n    vec2 antiOrientation = vec2(1.0, -1.0)*orientation.yx;\n    vec2 rt = abs(0.5*orientation+antiOrientation);\n    vec2 lb = -rt;\n    float halfBorder = 0.5*borderThickness;\n    vec2 arrowCoord = mat2(orientation, antiOrientation)*coord;\n    domino[2] = (\n        halfPlaneSmooth(arrowCoord, arrowSize*vec2(1.0, 0.0), arrowSize*vec2(0.0, 1.0), pixelSize)*\n        halfPlaneSmooth(arrowCoord, arrowSize*vec2(0.0, -1.0), arrowSize*vec2(1.0, 0.0), pixelSize)\n    );\n    domino[0] = rectangleSmooth(coord, lb, rt, pixelSize);\n    domino[1] = rectangleSmooth(coord, lb-halfBorder, rt+halfBorder, pixelSize)-rectangleSmooth(coord, lb+halfBorder, rt-halfBorder, pixelSize);\n    domino[2] *= halfPlaneSmooth(arrowCoord, arrowSize*vec2(-0.1875, 0.0), arrowSize*vec2(-0.1875, -1.0), pixelSize);\n    domino[2] = max(domino[2], rectangleSmooth(arrowCoord, arrowSize*vec2(-1.0, -0.5), arrowSize*vec2(0.25, 0.5), pixelSize));\n    return domino;\n}\n\nfloat drawSeparator(vec2 coord, float pixelSize, vec2 orientation) {\n    vec2 antiOrientation = vec2(1.0, -1.0)*orientation.yx;\n    vec2 rt = abs(0.5*borderThickness*orientation+antiOrientation);\n    vec2 lb = -rt;\n    float separator = 0.0;\n    separator = rectangleSmooth(coord, lb, rt, pixelSize);\n    return separator;\n}\n\nfloat drawKernel(vec2 coord, float pixelSize, vec2 orientation, float inflate, float split) {\n    if (inflate <= 0.0)\n        return 0.0;\n    float kernel = 0.0, separator = 0.0;\n    float halfBorder = 0.5*borderThickness;\n    vec2 antiOrientation = vec2(1.0, -1.0)*orientation.yx;\n    vec2 rt = abs(0.5*borderThickness*orientation+inflate*antiOrientation);\n    vec2 lb = -rt;\n    vec2 nrt = abs(0.5*borderThickness*orientation+inflate*(1.0-split)*antiOrientation);\n    vec2 nlb = -nrt;\n    kernel = rectangleSmooth(coord, vec2(-inflate*(1.0+halfBorder)), vec2(inflate*(1.0+halfBorder)), pixelSize);\n    kernel -= rectangleSmooth(coord, vec2(-inflate*(1.0+halfBorder)+borderThickness), vec2(inflate*(1.0+halfBorder)-borderThickness), pixelSize);\n    separator = rectangleSmooth(coord, lb, rt, pixelSize);\n    if (split < 1.0)\n        separator -= rectangleSmooth(coord, nlb, nrt, pixelSize);\n    return max(kernel, separator);\n}\n\nconst vec3 leftColor = vec3(1.0, 0.8125, 0.0);\nconst vec3 rightColor = vec3(1.0, 0.0, 0.25);\nconst vec3 downColor = vec3(0.0, 0.875, 0.0);\nconst vec3 upColor = vec3(0.0, 0.5, 1.0);\n\nvec4 drawDiamondDomino(vec2 coord, float pixelSize, ivec2 diamondCoord, vec4 data, int size, float shift) {\n    bool q = (int(diamondCoord.x)+int(diamondCoord.y)+size&1) == 1;\n    vec2 dominoCoord = coord-vec2(diamondCoord);\n    vec2 direction = getDirection(data);\n    vec3 domino = vec3(0.0);\n    if (dot(direction, direction) > 0.5) {\n        bool collision = data.a < 0.625;\n        if (collision)\n            shift *= 1.0+4.0*pow(animationTimer, 24.0);\n        dominoCoord -= (0.5+(0.5-float(q))*direction.yx)+shift*direction;\n        if (!collision || dot(dominoCoord, direction) < 0.5-shift)\n            domino = drawDomino(dominoCoord, pixelSize, direction);\n        if (collision && shift <= 1.0)\n            domino[1] = max(domino[1], drawSeparator(dominoCoord+(shift-0.5)*direction, pixelSize, direction));\n    }\n    return vec4(domino[0]*direction, domino[1]-domino[2], max(domino[0], domino[1]));\n}\n\nvoid mainImage(out vec4 color, in vec2 fragCoord) {\n    vec4 state = texture(iChannel0, vec2(0.0));\n    animationType = int(state[1]);\n    size = int(state[2]);\n    animationTimer = state[3];\n    if (int(state[0]) == SHIFT_OPERATION) {\n        ++size;\n        animationType = SHIFT_OPERATION;\n        animationTimer = 1.0;\n    }\n    scale = texture(iChannel0, vec2(1.5/iResolution.x, 0.0)).r;\n    \n    vec2 dcFactor = vec2(2.0*float(diamondSize))/iResolution.xy;\n    vec2 texCoord = fragCoord/iResolution.xy;\n    float aspect = iResolution.x/iResolution.y;\n    vec4 composite = vec4(0.0);\n    vec2 baseDataCoord = (texCoord-0.5)/scale*vec2(aspect, 1.0)+0.5;\n    vec2 coord = 2.0*float(diamondSize)*baseDataCoord;\n    { // FIX ARTIFACTS\n        bvec2 nearThreshold = lessThan(abs(floor(coord+0.5)-coord), vec2(EPS));\n        if (any(nearThreshold)) {\n            coord += EPS*vec2(nearThreshold);\n            baseDataCoord += 2.0*EPS/(2.0*float(diamondSize))*vec2(nearThreshold);\n        }\n    }\n    float pxSize = 2.0*float(diamondSize)/(scale*iResolution.y);\n    ivec2 diamondCoord = ivec2(floor(coord));\n    float shift = animationType == SHIFT_OPERATION ? animateShift() : 0.0;\n    for (int i = 0; i < 5; ++i)\n        for (int j = 0; j < 5; ++j) {\n            ivec2 offset = ivec2(-4+i, -i)+j;\n            vec2 dataCoord = baseDataCoord+0.5/float(diamondSize)*vec2(offset);\n            vec4 data = texture(iChannel0, dcFactor*dataCoord);\n            vec4 dominoData = data;\n            if (animationType != SHIFT_OPERATION)\n                dominoData.a = 1.0;\n            ivec2 doCoord = diamondCoord+offset;\n            vec4 domino = drawDiamondDomino(coord, pxSize, doCoord, dominoData, size, shift);\n            if (animationType == GENERATE_OPERATION) {\n                if (isNew(data)) {\n                    if ((doCoord.x+doCoord.y+size&1) == 0)\n                        doCoord += ivec2(1.25*getDirection(dominoData)).yx;\n                    float fillOpac = animateFadeIn(texCoord, doCoord);\n                    float arrowOpac = animateArrowFadeIn(texCoord, doCoord);\n                    domino.a *= mix(fillOpac, arrowOpac, max(0.0, -domino.b));\n                    domino.rg *= fillOpac;\n                }\n            }\n            domino.b = abs(domino.b);\n            composite = vec4(composite.rg+domino.rg, max(composite.ba, domino.ba));\n        }\n    if (animationType == GENERATE_OPERATION) {\n        for (int i = -2; i <= 1; ++i)\n            for (int j = -2; j <= 1; ++j) {\n                ivec2 offset = ivec2(j, i);\n                vec2 dataCoord = baseDataCoord+0.5/float(diamondSize)*vec2(offset);\n                vec4 data = texture(iChannel0, dcFactor*dataCoord);\n                if ((data.a > 0.5625 && data.a < 0.8125) || data.a < 0.40625) {\n                    ivec2 doCoord = diamondCoord+offset;\n                    float kernel = drawKernel(coord-1.0-vec2(doCoord), pxSize, data.gb, animateInflate(texCoord, doCoord), animateSplit(texCoord, doCoord));\n                    composite.ba = max(composite.ba, vec2(kernel));\n                }\n            }\n    }\n    vec2 colorDirection = normalize(composite.xy);\n    if (darkMode)\n        colorDirection *= 0.8125;\n    color = vec4(\n        mix(\n            max(0.0, -colorDirection.x)*leftColor+\n            max(0.0, +colorDirection.x)*rightColor+\n            max(0.0, -colorDirection.y)*downColor+\n            max(0.0, +colorDirection.y)*upColor,\n            vec3(0.9375*float(darkMode)),\n            min(1.0, composite.b+linearstep(0.1, 0.0, length(composite.xy)))\n        ),\n        composite.a\n    );\n    if (fragCoord.x+fragCoord.y < 0.5*iResolution.x-0.125*iResolution.y)\n        color.a = 0.0;\n    if (opaqueBg)\n        color = vec4(mix(vec3(1.0-0.90625*float(darkMode)), color.rgb, color.a), 1.0);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\nconst bool determinism = false;\nconst float seed = 0.0;\nconst float generateAnimationDuration = 6.0;\nconst float shiftAnimationDuration = 1.5;\nconst float speedUpOverTime = 0.002;\n\nconst vec4 BLANK = vec4(0.0, 0.0, 0.0, 1.0);\nconst vec4 KERNEL = vec4(1.0, 0.0, 0.0, 1.0);\nconst vec4 LEFT = vec4(0.0, 1.0, 0.0, 1.0);\nconst vec4 RIGHT = vec4(1.0, 1.0, 0.0, 1.0);\nconst vec4 DOWN = vec4(0.0, 0.0, 1.0, 1.0);\nconst vec4 UP = vec4(1.0, 0.0, 1.0, 1.0);\n\nbool isEmpty(vec4 texel) { return texel.g+texel.b < 0.5; } // blank or kernel\nbool isKernel(vec4 texel) { return texel.g+texel.b < 0.5 && texel.r > 0.5; }\nbool isLeft(vec4 texel) { return texel.g-texel.b > 0.5 && texel.r < 0.5; }\nbool isRight(vec4 texel) { return texel.g-texel.b > 0.5 && texel.r > 0.5; }\nbool isDown(vec4 texel) { return texel.b-texel.g > 0.5 && texel.r < 0.5; }\nbool isUp(vec4 texel) { return texel.b-texel.g > 0.5 && texel.r > 0.5; }\n\nbool withinDiamond(ivec2 coord, int size) {\n    return abs(float(coord.x)+0.5)+abs(float(coord.y)+0.5) < float(size)+0.5;\n}\n\nbool canBeKernel(ivec2 coord, int size) {\n    return (coord.x+coord.y+size&1) == 1 && withinDiamond(coord, size) && withinDiamond(coord+1, size);\n}\n\nbool cointoss(ivec2 position, int size);\n\nvoid mainImage(out vec4 outie, in vec2 fragCoord) {\n    outie = BLANK;\n    ivec2 iFragCoord = ivec2(fragCoord);\n    ivec2 coord = iFragCoord-diamondSize;\n    // Initialization\n    if (iFrame == 0) {\n        if (iFragCoord == ivec2(0, 0)) {\n            outie[0] = float(SHIFT_OPERATION);\n            outie[1] = float(GENERATE_OPERATION);\n            outie[2] = float(1);\n            outie[3] = 0.0;\n        } else if (iFragCoord == ivec2(1, 0)) {\n            outie[0] = 0.5*float(diamondSize);\n            outie[1] = 0.0;\n        } else if (iFragCoord.x < 2*diamondSize && iFragCoord.y < 2*diamondSize) {\n            outie = canBeKernel(coord, 1) ? KERNEL : BLANK;\n        }\n    // Update\n    } else {\n        vec4 state = texture(iChannel0, vec2(0.0));\n        int operation = int(state[0]);\n        int animationType = int(state[1]);\n        int size = int(state[2]);\n        float animationTimer = state[3];\n        if (iFragCoord == ivec2(0, 0)) {\n            float deltaTime = exp(speedUpOverTime*iTime)*iTimeDelta;\n            if (operation == SHIFT_OPERATION) {\n                animationTimer = 0.0;\n                operation = GENERATE_OPERATION;\n            } else {\n                operation = NO_OPERATION;\n                if (animationType == GENERATE_OPERATION)\n                    animationTimer += deltaTime/generateAnimationDuration;\n                if (animationType == SHIFT_OPERATION)\n                    animationTimer += deltaTime/shiftAnimationDuration;\n                if (animationTimer >= 1.0) {\n                    animationTimer = 0.0;\n                    if (animationType == SHIFT_OPERATION) {\n                        ++size;\n                        operation = SHIFT_OPERATION;\n                    }\n                    if (animationType == GENERATE_OPERATION) {\n                        if (size < diamondSize-4)\n                            animationType = SHIFT_OPERATION;\n                        else\n                            animationType = NO_OPERATION;\n                    } else\n                        animationType = GENERATE_OPERATION;\n                }\n            }\n            outie[0] = float(operation);\n            outie[1] = float(animationType);\n            outie[2] = float(size);\n            outie[3] = animationTimer;\n        } else if (iFragCoord == ivec2(1, 0)) {\n            float deltaTime = exp(speedUpOverTime*iTime)*iTimeDelta;\n            vec2 scale = texture(iChannel0, vec2(1.5/iResolution.x, 0.0)).rg;\n            float targetScale = float(diamondSize)/float(size+3);\n            scale[0] += deltaTime*scale[1];\n            scale[1] += 4.0*deltaTime*(0.125*(targetScale-scale[0])-scale[1]);\n            outie.rg = scale;\n        } else if (iFragCoord.x < 2*diamondSize && iFragCoord.y < 2*diamondSize && iFragCoord.x+iFragCoord.y > 4) {\n            outie = BLANK;\n            vec2 texCoord = fragCoord/iResolution.xy;\n            vec4 local = texture(iChannel0, texCoord);\n            if (operation == NO_OPERATION) {\n                outie = local;\n            } else {\n                vec2 texelSize = vec2(1.0)/iResolution.xy;\n                vec4 left = texture(iChannel0, texCoord+vec2(-1.0, 0.0)*texelSize);\n                vec4 right = texture(iChannel0, texCoord+vec2(+1.0, 0.0)*texelSize);\n                vec4 bottom = texture(iChannel0, texCoord+vec2(0.0, -1.0)*texelSize);\n                vec4 top = texture(iChannel0, texCoord+vec2(0.0, +1.0)*texelSize);\n                if (operation == GENERATE_OPERATION) {\n                    if (isEmpty(local)) {\n                        vec4 bottomLeft = texture(iChannel0, texCoord+vec2(-1.0, -1.0)*texelSize);\n                        vec4 bottomRight = texture(iChannel0, texCoord+vec2(+1.0, -1.0)*texelSize);\n                        vec4 topLeft = texture(iChannel0, texCoord+vec2(-1.0, +1.0)*texelSize);\n                        vec4 topRight = texture(iChannel0, texCoord+vec2(+1.0, +1.0)*texelSize);\n                        vec4 horizontal = BLANK, vertical = BLANK;\n                        ivec2 kernelCoord = ivec2(0);\n                        if (isKernel(local) && isEmpty(right) && isEmpty(top) && isEmpty(topRight)) horizontal = LEFT, vertical = DOWN, kernelCoord = coord;\n                        if (isKernel(left) && isEmpty(local) && isEmpty(topLeft) && isEmpty(top)) horizontal = RIGHT, vertical = DOWN, kernelCoord = coord-ivec2(1, 0);\n                        if (isKernel(bottom) && isEmpty(bottomRight) && isEmpty(local) && isEmpty(right)) horizontal = LEFT, vertical = UP, kernelCoord = coord-ivec2(0, 1);\n                        if (isKernel(bottomLeft) && isEmpty(bottom) && isEmpty(left) && isEmpty(local)) horizontal = RIGHT, vertical = UP, kernelCoord = coord-1;\n                        if (!isEmpty(horizontal)) { // if any of the four previous conditions applies\n                            outie = cointoss(kernelCoord, size) ? horizontal : vertical;\n                            outie.a = kernelCoord == coord ? 0.75 : 0.875; // mark new\n                        }\n                    } else\n                        outie = local;\n                } else if (operation == SHIFT_OPERATION) {\n                    if (isLeft(right) && !isRight(local)) outie = LEFT;\n                    if (isRight(left) && !isLeft(local)) outie = RIGHT;\n                    if (isDown(top) && !isUp(local)) outie = DOWN;\n                    if (isUp(bottom) && !isDown(local)) outie = UP;\n                    if (isEmpty(outie) && withinDiamond(coord, size)) {\n                        if (canBeKernel(coord, size) && !(isRight(local) && isLeft(right)) && !(isUp(local) && isDown(top)))\n                            outie = KERNEL;\n                    }\n                }\n            }\n        }\n    }\n}\n\n// Shadron <rng> library\n\n#define RNG int\n#define RNG_PCG_INITIAL_STATE 0x46b56677\n#define RNG_PCG_MULTIPLIER 747796405\n#define RNG_PCG_INCREMENT 2891336453\n#define RNG_PERTURB_INCREMENT 0x6004b88e\n#define RNG_FLOAT_MODULO 552580700.774913\n\nRNG rngInitialize(float seed) {\n    return (RNG_PCG_INITIAL_STATE+2*int(sign(seed)))*RNG_PCG_MULTIPLIER+int(mod(log(abs(seed))*float(RNG_PCG_MULTIPLIER), RNG_FLOAT_MODULO))+RNG_PCG_INCREMENT;\n}\n\nRNG rngPerturb(RNG rng, int seed) {\n    return (rng+seed+RNG_PERTURB_INCREMENT)*RNG_PCG_MULTIPLIER+RNG_PCG_INCREMENT;\n}\n\nRNG rngPerturb(RNG rng, float seed) {\n    return (rng+2*int(sign(seed))+RNG_PERTURB_INCREMENT)*RNG_PCG_MULTIPLIER+int(mod(log(abs(seed))*float(RNG_PCG_MULTIPLIER), RNG_FLOAT_MODULO))+RNG_PCG_INCREMENT;\n}\n\nint rngGetInt(RNG rng) {\n    int x = ((rng>>((rng>>28&0x0f)+4))^rng)*277803737;\n    return (x>>22)^x;\n}\n\nbool cointoss(ivec2 position, int size) {\n    RNG rng = rngInitialize(seed);\n    rng = rngPerturb(rng, size);\n    rng = rngPerturb(rng, position.x);\n    rng = rngPerturb(rng, position.y);\n    if (!determinism)\n        rng = rngPerturb(rng, iDate.w);\n    return (rngGetInt(rng)&1) == 1;\n}\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"\nvoid mainImage(out vec4 data, in vec2 fragCoord) {\n    ivec2 iFragCoord = ivec2(fragCoord);\n    vec2 texelSize = vec2(1.0)/iResolution.xy;\n    vec2 texCoord = texelSize*fragCoord;\n    data = texture(iChannel0, texCoord);\n    if (iFragCoord.x < 2*diamondSize && iFragCoord.y < 2*diamondSize && iFragCoord.x+iFragCoord.y > 4) {\n        vec2 direction = getDirection(data);\n        if (dot(direction, direction) > 0.5) {\n            vec4 neighbor = texture(iChannel0, texCoord+texelSize*direction);\n            direction += getDirection(neighbor);\n            if (dot(direction, direction) < 0.5)\n                data.a *= 0.5;\n        }\n    }\n}\n","name":"Buffer B","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"\n// Aztec Diamond by Chlumsky\n// Created with Shadron\n// www.shadron.info\n\nconst int diamondSize = 128;\n\nconst int NO_OPERATION = 0;\nconst int GENERATE_OPERATION = 1;\nconst int SHIFT_OPERATION = 2;\n\nvec2 getDirection(vec4 texel) {\n    return (2.0*texel.r-1.0)*texel.gb;\n}\n","name":"Common","description":"","type":"common"}]}