{"ver":"0.1","info":{"id":"sd33RN","date":"1629230512","viewed":155,"name":"Shape curvature test","username":"TambakoJaguar","description":"Just a small attempt at converting http://madebyevan.com/shaders/curvature/ to Shadertoy, nothing special in fact...","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["3d","wave","shading","curvature","shape"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n\"Shape curvature test\" by Emmanuel Keller aka Tambako - August 2012\nShadertoy adaptation of  http://madebyevan.com/shaders/curvature/\nLicense Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\nContact: tamby@tambako.ch\n*/\n\n#define pi 3.141593\n\nstruct RenderData\n{\n  vec3 col;\n  vec3 pos;\n  vec3 norm;\n  float dist;\n};\n\nvec3 campos = vec3(0., 0., 7.);\nvec3 camdir = vec3(0., 0., -1.);\nfloat fov = 3.8;\n\nconst float normdelta = 0.001;\nconst float maxdist = 17.;\n\nvec3 posr;\n\nfloat angle;\nfloat angle2;\n\n// Antialias. Change from 1 to 2 or more AT YOUR OWN RISK! It may CRASH your browser while compiling!\nconst float aawidth = 0.8;\nconst int aasamples = 1;\n\nvec2 rotateVec(vec2 vect, float angle)\n{\n    vec2 rv;\n    rv.x = vect.x*cos(angle) + vect.y*sin(angle);\n    rv.y = vect.x*sin(angle) - vect.y*cos(angle);\n    return rv;\n}\n\nvec3 rotateVec2(vec3 posr)\n{\n    posr = vec3(posr.x, posr.y*cos(angle2) + posr.z*sin(angle2), posr.y*sin(angle2) - posr.z*cos(angle2));\n    posr = vec3(posr.x*cos(angle) + posr.z*sin(angle), posr.y, posr.x*sin(angle) - posr.z*cos(angle)); \n    \n    return posr;\n}\n\nfloat map(vec3 pos)\n{   \n    vec3 posr = rotateVec2(pos);\n    posr.xy = posr.yx;\n    posr.x = -posr.x;\n    \n    for (int j = 0; j < 12; j++) {\n      posr[j % 3] -= 0.1 * sin(5.* posr[(j + 1) % 3]);\n    }\n    \n    return 0.4*(length(posr) - 1.);\n}\n\nvec2 trace(vec3 cam, vec3 ray, float maxdist) \n{\n    float t = 1.8;\n    vec3 pos;\n    float dist;\n    \n  \tfor (int i = 0; i < 100; ++i)\n    {\n    \tpos = ray*t + cam;\n    \tdist = map(pos);\n        if (dist>maxdist || abs(dist)<0.0001)\n            break;\n        t+= dist*0.8;\n  \t}\n        \n  \treturn vec2(t, dist);\n}\n\nvec3 getNormal(vec3 pos, float e)\n{  \n    vec3 n = vec3(0.0);\n    for( int i=0; i<4; i++ )\n    {\n        vec3 e2 = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e2*map(pos + e*e2);\n    }\n    return normalize(n);\n}\n\n// From http://madebyevan.com/shaders/curvature/ \nvec3 shading_metal(vec3 norm, vec3 pos)\n{\n  // Compute curvature\n  vec3 dx = dFdx(norm);\n  vec3 dy = dFdy(norm);\n  vec3 xneg = norm + dx;\n  vec3 xpos = norm - dx;\n  vec3 yneg = norm - dy;\n  vec3 ypos = norm + dy;\n  float depth = 3.5*length(pos);\n  float curvature = (cross(xneg, xpos).y - cross(yneg, ypos).x) * 4.0 / depth;\n\n  // Compute surface properties\n  float corrosion = clamp(-curvature * 3.0, 0.0, 1.0);\n  float shine = clamp(curvature * 5.0, 0.0, 1.0);\n  vec3 light = normalize(vec3(0.0, 1.0, 10.0));\n  vec3 ambient = vec3(0.15, 0.1, 0.1);\n  vec3 diffuse = mix(mix(vec3(0.3, 0.25, 0.2), vec3(0.45, 0.5, 0.5), corrosion),\n    vec3(0.5, 0.4, 0.3), shine) - ambient;\n  vec3 specular = mix(vec3(0.0), vec3(1.0) - ambient - diffuse, shine);\n  float shininess = 128.0;\n\n  // Compute final color\n  float cosAngle = dot(norm, light);\n  vec3 col = ambient +\n    diffuse * max(0.0, cosAngle) +\n    specular * pow(max(0.0, cosAngle), shininess);\n    \n    return 1.3*col;\n}\n\n// From http://madebyevan.com/shaders/curvature/ \nvec3 shading_red_wax(vec3 norm, vec3 pos)\n{\n  // Compute curvature\n  vec3 dx = dFdx(norm);\n  vec3 dy = dFdy(norm);\n  vec3 xneg = norm + dx;\n  vec3 xpos = norm - dx;\n  vec3 yneg = norm - dy;\n  vec3 ypos = norm + dy;\n  float depth = 3.5*length(pos);\n  float curvature = (cross(xneg, xpos).y - cross(yneg, ypos).x) * 4.0 / depth;\n\n  // Compute surface properties\n  float dirt = clamp(0.25 - curvature * 4.0, 0.0, 1.0);\n  vec3 light = normalize(vec3(0.0, 1.0, 10.0));\n  vec3 ambient = vec3(0.1, 0.05, 0.0);\n  vec3 diffuse = mix(vec3(0.4, 0.15, 0.1), vec3(0.4, 0.3, 0.3), dirt) - ambient;\n  vec3 specular = mix(vec3(0.15) - ambient, vec3(0.0), dirt);\n  float shininess = 32.0;\n\n  // Compute final color\n  float cosAngle = dot(norm, light);\n  vec3 col = ambient +\n    diffuse * max(0.0, cosAngle) +\n    specular * pow(max(0.0, cosAngle), shininess);\n    \n    return 1.2*col;\n}\n\n// From http://madebyevan.com/shaders/curvature/ \nvec3 shading_curvature(vec3 norm, vec3 pos)\n{\n  // Compute curvature\n  vec3 dx = dFdx(norm);\n  vec3 dy = dFdy(norm);\n  vec3 xneg = norm + dx;\n  vec3 xpos = norm - dx;\n  vec3 yneg = norm - dy;\n  vec3 ypos = norm + dy;\n  float depth = 3.5*length(pos);\n  float curvature = (cross(xneg, xpos).y - cross(yneg, ypos).x) * 4.0 / depth;\n\n  // Compute surface properties\n  vec3 light = vec3(0.0);\n  vec3 ambient = vec3(curvature + 0.5);\n  vec3 diffuse = vec3(0.0);\n  vec3 specular = vec3(0.0);\n  float shininess = 0.0;\n\n  // Compute final color\n  float cosAngle = dot(norm, light);\n  vec3 col = ambient +\n    diffuse * max(0.0, cosAngle) +\n    specular * pow(max(0.0, cosAngle), shininess);\n    \n  return 1.2*col;\n}\n\nvec3 shading(vec3 norm, vec3 pos)\n{\n    return shading_metal(norm, pos);\n    //return shading_red_wax(norm, pos);\n    //return shading_curvature(norm, pos);\n}\n\n// From https://www.shadertoy.com/view/lsSXzD, modified\nvec3 GetCameraRayDir(vec2 vWindow, vec3 vCameraDir, float fov)\n{\n\tvec3 vForward = normalize(vCameraDir);\n\tvec3 vRight = normalize(cross(vec3(0.0, 1.0, 0.0), vForward));\n\tvec3 vUp = normalize(cross(vForward, vRight));\n    \n\tvec3 vDir = normalize(vWindow.x * vRight + vWindow.y * vUp + vForward * fov);\n\n\treturn vDir;\n}\n\nRenderData trace0(vec3 tpos, vec3 ray)\n{\n    vec2 t = trace(tpos, ray, maxdist);\n    float tx = t.x;\n    vec3 col;\n    float dist = t.y;\n    \n    vec3 pos = tpos + tx*ray;\n    vec3 norm;\n    if (tx<maxdist*0.65)\n    {\n        norm = getNormal(pos, normdelta);\n\n        // Shading\n        col = shading(norm, pos);\n    }\n    return RenderData(col, pos, norm, dist);\n}\n\nvec4 render(vec2 fragCoord)\n{\n  vec2 uv = fragCoord.xy / iResolution.xy; \n  uv = uv*2.0 - 1.0;\n  uv.x*= iResolution.x / iResolution.y;\n\n  vec3 ray = GetCameraRayDir(uv, camdir, fov);\n    \n  RenderData traceinf = trace0(campos, ray);\n  vec3 col = traceinf.col;\n  \n  if (traceinf.dist>10.)\n  col = vec3(0.5 * (1.0 - length(fragCoord.xy / iResolution.xy - 0.5)));\n\n  return 1.3*vec4(col, 1.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    angle = -2.*pi*(iMouse.x/iResolution.x - 0.5);\n    angle2 = -2.*pi*(iMouse.y/iResolution.y - 0.5);\n    \n    // Antialiasing\n    vec4 vs = vec4(0.);\n    for (int j=0;j<aasamples ;j++)\n    {\n       float oy = float(j)*aawidth/max(float(aasamples-1), 1.);\n       for (int i=0;i<aasamples ;i++)\n       {\n          float ox = float(i)*aawidth/max(float(aasamples-1), 1.);\n          vs+= render(fragCoord + vec2(ox, oy));\n       }\n    }\n    fragColor = vs/vec4(aasamples*aasamples);    \n}","name":"Image","description":"","type":"image"}]}