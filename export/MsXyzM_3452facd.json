{"ver":"0.1","info":{"id":"MsXyzM","date":"1487429035","viewed":188,"name":"-Mandelbulb- with Shading","username":"yumcyawiz","description":"phong shading(steps AO for ambient) + reflection","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","fractal"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\n\nconst int maxIter = 100;\nfloat df(vec3 p) {\n    vec3 z = p;\n    float r = 0.0;\n    float dr = 1.0;\n    float power = 8.0;\n    //float power = 6.0*abs(sin(0.3*iTime)) + 2.0;\n    for(int i = 0; i < maxIter; i++) {\n        r = length(z);\n        if(r > 2.0) break;\n        \n        float theta = acos(z.z/r);\n        float phi = atan(z.y, z.x);\n        \n        dr = power*pow(r, power-1.0)*dr + 1.0;\n        \n        r = pow(r, power);\n        theta *= power;\n        phi *= power;\n        \n        z = r*vec3(sin(theta)*cos(phi), sin(theta)*sin(phi), cos(theta));\n        z += p;\n    }\n    float d = 0.5*log(r)*r/dr;\n    \n    //box\n    d = min(d, sdBox(p - vec3(0, -1, 0), vec3(5, 0.01, 5)));\n    return d;\n}\n\n\nvec3 calcNormal(vec3 p) {\n    float eps = 0.00001;\n    return normalize(vec3(\n        df(p + vec3(eps, 0, 0)) - df(p - vec3(eps, 0, 0)),\n        df(p + vec3(0, eps, 0)) - df(p - vec3(0, eps, 0)),\n        df(p + vec3(0, 0, eps)) - df(p - vec3(0, 0, eps))\n        ));\n}\n\n\nstruct Ray {\n    bool hit;\n    vec3 hitPos;\n    vec3 hitNormal;\n    vec3 rayDir;\n    float t;\n    int steps;\n};\nconst int maxSteps = 200;\nRay trace(vec3 camPos, vec3 rayDir) {\n    vec3 p = vec3(0);\n    vec3 normal = vec3(0);\n    float t = 0.0;\n    int steps = 0;\n    bool hit = false;\n    for(int i = 0; i < maxSteps; i++) {\n        p = camPos + t*rayDir;\n        float d = df(p);\n        if(d < 0.001) {\n            p -= 0.001*rayDir;\n            hit = true;\n            normal = calcNormal(p);\n            steps = i;\n            break;\n        }\n        t += d*0.9;\n    }\n    return Ray(hit, p, normal, rayDir, t, steps);\n}\n\n\nfloat shadow(vec3 from, vec3 rayDir, float k) {\n    float ret = 1.0;\n    for(float t = 0.001; t < 10.0; ) {\n        float d = df(from + t*rayDir);\n        if(d < 0.001) {\n            return 0.0;\n        }\n        ret = min(ret, k*d/t);\n        t += d;\n    }\n    return ret;\n}\n\n\nconst vec3 lightPos = vec3(30, 30, 30);\nconst vec3 skyColor = vec3(0.85, 1.0, 1.0);\n\n\nvec3 phong(Ray tr) {\n    vec3 color = vec3(0);\n    \n    vec3 ao = pow(1.0 - float(tr.steps)/float(maxSteps), 1.0) * skyColor;\n    color += 0.3*ao;\n    \n    vec3 sunDir = normalize(lightPos - tr.hitPos);\n    vec3 diffuse, specular;\n    diffuse = max(dot(tr.hitNormal, sunDir), 0.0) * vec3(1.0);\n        \n    vec3 r = reflect(-sunDir, tr.hitNormal);\n    specular = pow(max(dot(-tr.rayDir, r), 0.0), 14.0) * vec3(1.0);\n    \n    color += shadow(tr.hitPos, sunDir, 64.0) * 0.8 * (0.8*diffuse + 0.2*specular);\n    \n    return color;\n}\n\n\nvec3 shading(Ray tr) {\n    if(!tr.hit) {\n        return vec3(skyColor);\n    }\n    vec3 color = vec3(0);\n    \n    color += phong(tr);\n    \n    vec3 refl = reflect(tr.rayDir, tr.hitNormal);\n    Ray tr2 = trace(tr.hitPos, refl);\n    color += 0.2*phong(tr2);\n    \n    return color;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.0*fragCoord.xy - iResolution.xy) / iResolution.y;\n\t\n    //camera settings\n    vec3 camPos = 2.0*vec3(sin(0.5*iTime), 0, cos(0.5*iTime));\n    vec3 camFront = normalize(-camPos);\n    vec3 camUp = vec3(0, 1, 0);\n    vec3 camRight = cross(camFront, camUp);\n    float focus = 1.3;\n\n    vec3 rayDir = normalize(uv.x*camRight + uv.y*camUp + focus*camFront);\n    Ray tr = trace(camPos, rayDir);\n\n    fragColor = vec4(shading(tr), 1.0);\n}","name":"Image","description":"","type":"image"}]}