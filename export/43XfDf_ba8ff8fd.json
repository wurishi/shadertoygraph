{"ver":"0.1","info":{"id":"43XfDf","date":"1728970141","viewed":16,"name":"oct142024v3","username":"brendanluu","description":"pop","likes":0,"published":3,"flags":0,"usePreview":0,"tags":["popart"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Rotation function\nvec2 rotate(vec2 p, float angle) {\n    return vec2(\n        p.x * cos(angle) - p.y * sin(angle),\n        p.x * sin(angle) + p.y * cos(angle)\n    );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalize pixel coordinates\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    \n    // Define eye centers\n    vec2 leftEyeCenter = vec2(-0.39, 0.0);\n    vec2 rightEyeCenter = vec2(0.39, 0.0);\n    \n    // Define rotation speeds\n    float leftEyeRotationSpeed = 00.0;\n    float rightEyeRotationSpeed = -0.8;\n    \n    // Calculate distance from pixel to eye centers\n    float leftEyeDist = length(uv - leftEyeCenter);\n    float rightEyeDist = length(uv - rightEyeCenter);\n    \n    // Create SDFs for eyes\n    float leftEyeSDF = leftEyeDist - 10.14;\n    float rightEyeSDF = rightEyeDist - .4;\n    \n    // Create rotating Moir√© pattern\n    vec2 leftPatternUV = rotate(uv - leftEyeCenter, iTime * leftEyeRotationSpeed) * 40.0;\n    vec2 rightPatternUV = rotate(uv - rightEyeCenter, iTime * rightEyeRotationSpeed) * 40.0;\n    \n    float leftPattern = sin(leftPatternUV.x) * sin(leftPatternUV.y);\n    float rightPattern = sin(rightPatternUV.x) * sin(rightPatternUV.y);\n    \n    // Combine patterns with eye shapes\n    float leftEyePattern = step(leftEyeSDF, 0.0) * leftPattern;\n    float rightEyePattern = step(rightEyeSDF, 0.0) * rightPattern;\n    \n    float finalPattern = leftEyePattern + rightEyePattern;\n    \n    // Create a static circle surrounding both eyes\n    float surroundingCircleSDF = length(uv) - 1.0;\n    float surroundingCircle = smoothstep(0.0, 0.01, surroundingCircleSDF);\n    \n    // Combine the eyes pattern with the surrounding circle\n    finalPattern = max(finalPattern, surroundingCircle);\n    \n    // Output color\n    fragColor = vec4(vec3(finalPattern * 0.5 + 0.5), 1.0);\n}","name":"Image","description":"","type":"image"}]}