{"ver":"0.1","info":{"id":"3tscDM","date":"1592233356","viewed":153,"name":"digbuild","username":"acdimalev","description":"A small-scale emulation for visual experiments related to Minecraft shaders.","likes":4,"published":1,"flags":32,"usePreview":0,"tags":["minecraft"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float DISTANCE = 4.5;\nconst float HEIGHT = 2.5;\nconst float FOV = radians(45.0);\nconst float MAXDEPTH = 1024.0;\n\nvec4 texturei(sampler2D sampler, int texture_index, vec2 uv)\n{ vec2 st = vec2\n  ( float(texture_index % TEXTURE_RESOLUTION) / float(TEXTURE_RESOLUTION)\n  , float(texture_index / TEXTURE_RESOLUTION) / float(TEXTURE_RESOLUTION)\n  );\n  uv = uv / float(TEXTURE_RESOLUTION);\n  return texture(sampler, st + uv);\n}\n\n// calculate ray vector for a given fragment coordinate\n//\n// this function also determines the handed-ness of the coordinate system\n//   z < 0 : left-handed\n//   z > 0 : right-handed\n//\nvec3 ray_vector(float fov, vec3 iResolution, vec2 fragCoord)\n{ // scale relative to pixel density\n  float size = sqrt(iResolution.x * iResolution.y);\n\n  // calculate vector in screen coordinates\n  vec2 xy = fragCoord - iResolution.xy / 2.0;\n  float z = (size / 2.0) / tan(fov / 2.0);\n\n  // return normalized vector\n  return normalize(vec3(xy, z));\n}\n\n// return a view matrix from `eye` to `center`\n//\n// based on gluLookAt\n// and kindly translated to GLSL by jlfwong\n// https://www.shadertoy.com/user/jlfwong\n//\n// the sign of `f` on the output matrix must be adjusted\n// to match the handed-ness of the coordinate system\n//   left-handed: -f\n//   right-handed: f\n//\nmat3 view_matrix(vec3 eye, vec3 center, vec3 up)\n{ vec3 f = normalize(center - eye);\n  vec3 s = cross(f, up);\n  vec3 u = cross(s, f);\n  return mat3(s, u, f);\n}\n\nstruct rayData\n{ float distance;\n  int texture;\n  vec2 uv;\n};\n\nrayData nearest(rayData a, rayData b)\n{ if (b.distance > a.distance)\n    return a;\n  else\n    return b;\n}\n\nrayData grass_block_side_1(vec3 eye, vec3 ray)\n{ float l = -(eye.z + 0.5) / ray.z;\n  vec2 uv = (eye.xy + l * ray.xy) * vec2(1.0, 1.0) + vec2(0.5);\n  if (uv.x >= 0.0 && uv.x <= 1.0 && uv.y >= 0.0 && uv.y <= 1.0)\n    return rayData(l, 1, uv);\n  else\n    return rayData(MAXDEPTH, 0, vec2(0.0));\n}\n\nrayData grass_block_side_2(vec3 eye, vec3 ray)\n{ float l = -(eye.z - 0.5) / ray.z;\n  vec2 uv = (eye.xy + l * ray.xy) * vec2(-1.0, 1.0) + vec2(0.5);\n  if (uv.x >= 0.0 && uv.x <= 1.0 && uv.y >= 0.0 && uv.y <= 1.0)\n    return rayData(l, 1, uv);\n  else\n    return rayData(MAXDEPTH, 0, vec2(0.0));\n}\n\nrayData grass_block_side_3(vec3 eye, vec3 ray)\n{ float l = -(eye.x + 0.5) / ray.x;\n  vec2 uv = (eye.zy + l * ray.zy) * vec2(-1.0, 1.0) + vec2(0.5);\n  if (uv.x >= 0.0 && uv.x <= 1.0 && uv.y >= 0.0 && uv.y <= 1.0)\n    return rayData(l, 1, uv);\n  else\n    return rayData(MAXDEPTH, 0, vec2(0.0));\n}\n\nrayData grass_block_side_4(vec3 eye, vec3 ray)\n{ float l = -(eye.x - 0.5) / ray.x;\n  vec2 uv = (eye.zy + l * ray.zy) * vec2(1.0, 1.0) + vec2(0.5);\n  if (uv.x >= 0.0 && uv.x <= 1.0 && uv.y >= 0.0 && uv.y <= 1.0)\n    return rayData(l, 1, uv);\n  else\n    return rayData(MAXDEPTH, 0, vec2(0.0));\n}\n\nrayData grass_block_top(vec3 eye, vec3 ray)\n{ float l = -(eye.y - 0.5) / ray.y;\n  vec2 uv = (eye.xz + l * ray.xz) * vec2(1.0, 1.0) + vec2(0.5);\n  if (uv.x >= 0.0 && uv.x <= 1.0 && uv.y >= 0.0 && uv.y <= 1.0)\n    return rayData(l, 2, uv);\n  else\n    return rayData(MAXDEPTH, 0, vec2(0.0));\n}\n\nrayData grass_block(vec3 eye, vec3 ray)\n{ return nearest\n  ( grass_block_side_1(eye, ray)\n  , nearest\n    ( grass_block_side_2(eye, ray)\n    , nearest\n      ( grass_block_side_3(eye, ray)\n      , nearest\n        ( grass_block_side_4(eye, ray)\n        , grass_block_top(eye, ray)\n        )\n      )\n    )\n  );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{ float angle = iTime / 4.0;\n  vec3 eye = vec3(DISTANCE * sin(angle), HEIGHT, DISTANCE * cos(angle));\n  vec3 center = vec3(0.0);\n  vec3 up = vec3(0.0, 1.0, 0.0);\n\n  mat3 view = view_matrix(eye, center, up);\n\n  vec3 ray = view * ray_vector(FOV, iResolution, fragCoord);\n\n  rayData data = grass_block(eye, ray);\n\n  if (MAXDEPTH != data.distance)\n    fragColor = texturei(iChannel0, data.texture, data.uv);\n  else\n    fragColor = vec4(vec3(0.5), 1.0);\n\n  // fragColor = texture(iChannel0, fragCoord / iResolution.xy);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":0,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"float pixelate(float value, int pixels)\n{ return min(1.0, floor(float(pixels) * value) / float(pixels - 1)); }\n\nvec2 pixelate(vec2 value, int pixels)\n{ return min(vec2(1.0), floor(float(pixels) * value) / float(pixels - 1)); }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{ int pixels = 16;\n\n  vec2 qr = pixelate(fragCoord / iResolution.xy, pixels * TEXTURE_RESOLUTION);\n  vec2 uv = pixelate(mod(fragCoord * float(TEXTURE_RESOLUTION) / iResolution.xy, 1.0), pixels);\n  ivec2 st = ivec2(fragCoord * float(TEXTURE_RESOLUTION) / iResolution.xy);\n  int texture_index = TEXTURE_RESOLUTION * st.y + st.x;\n\n  // default\n  fragColor = vec4(0.0);\n\n  vec3 dirt_albedo = vec3(0.63, 0.46, 0.32);\n  vec3 grass_albedo = vec3(0.61, 0.80, 0.42);\n\n  if (1 == texture_index)\n  { // fixme -- split texture and material calculations\n    float dirt = pow(pixelate(texture(iChannel0, qr).x, 9), 2.0);\n    vec3 color = dirt_albedo * (dirt * 0.37 + 0.63);\n\n    float gravel = floor(70.0 * texture(iChannel0, qr).y);\n    // fixme -- translate to a linear equation\n    if (0.0 == gravel)\n      color = vec3(0.42);\n    if (1.0 == gravel)\n      color = vec3(0.53);\n\n    float grass1 = pixelate(texture(iChannel0, qr).x, 65);\n    float grass2 = pixelate(texture(iChannel0, vec2(qr.x, 0)).z, 16);\n    // fixme -- this should be a normal distribution\n    float overhang = 15.0/16.0;\n    if (0.5/16.0 < grass2)\n      overhang = 14.0/16.0;\n    if (1.5/16.0 < grass2)\n      overhang = 13.0/16.0;\n    if (5.5/16.0 < grass2)\n      overhang = 12.0/16.0;\n    if (13.5/16.0 < grass2)\n      overhang = 11.0/16.0;\n    if (uv.y > overhang)\n      color = grass_albedo * (grass1 * 0.43 + 0.57);\n\n    fragColor = vec4(color, 1.0);\n  }\n  if (2 == texture_index)\n  { float grass1 = pixelate(texture(iChannel0, qr).x, 65);\n    vec3 color = grass_albedo * (grass1 * 0.43 + 0.57);\n    fragColor = vec4(color, 1.0);\n  }\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"const int TEXTURE_RESOLUTION = 2;","name":"Common","description":"","type":"common"}]}