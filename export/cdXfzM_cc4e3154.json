{"ver":"0.1","info":{"id":"cdXfzM","date":"1688627742","viewed":263,"name":"Multiple-Scattering Microfacet","username":"pppp11111","description":"Unbiased Multiple-Scattering Microfacet\nleft : multiple scattering GGX\nright : single scattering GGX\ndefault setting : multiple importance sampling\nchange setting from common tab.","likes":12,"published":1,"flags":32,"usePreview":0,"tags":["scattering","pathtracing","mis","microfacet","ggx","unbiased","multiple"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\nMultiple-Scattering Microfacet BRDF (GGX).\n\n7.7 23: fix bsdf_eval_ggx_multi() which evaluate with wrong half vector.\n\nScreen\n    Left : multiple scattering ggx\n    Right : single scattering ggx\n\n\n\nChange settings from common tab.\n    Supported sampling : MIS sampling, bsdf sampling, light sampling(nee)\n      and white furnace test\n      \n    Lighting : Sky light, rectangle area light\n\n\n\n\nAll bsdfs here use Height-Correlated Masking and Shadowing.\n\n\n\nbsdf implementation of\n    d'Eon et al. 2023.\"Microfacet theory for non-uniform heightfields\"\n    It can produce 'hazy' highlight! \n    but not implement single/eval here. \n\n\n\nI'm not sure all math is correct.\nif you found error, please report!!!\n\nyou can extend this with Beckmann NDF or diffuse surface...\n\n\nrefer to this paper and Supplemental Material\nHeitz et al. 2016. \"Multiple-Scattering Microfacet BSDFs with the Smith Model\"\n\nchange variable. h -> z\nDupuy et al. 2016. \"Additional Progress Towards the Unification of Microfacet and Microflake Theories\"\n\n\n*/\n\n\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec4 radiance = texelFetch(iChannel0, ivec2(fragCoord), 0);\n  \n  fragColor = vec4(Gamma(ACESFilm(radiance.rgb / radiance.a)), 1.0);\n  \n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"/*\n    roughness of gold!\n    (0.0, 1.0] \n    \n*/\n#define SS_ROUGHNESS 0.6\n\n/*\n    sample count\n    total sample = SS_SAMPLE * SS_SAMPLE_per_FRAME\n*/\n#define SS_SAMPLE 1024.0\n#define SS_SAMPLE_per_FRAME 1.0\n\n\n/* \n    max bounce = 3 when sobol rng used \n    (LUT size support up to 8 dimension)\n*/\n#define SS_MAX_BOUNCES 3\n\n\n/*\n    truncate randomwalk at single scattering to match with analytic single scattering solution\n    \n    0 : full randomwalk\n    1 : truncate randomwalk at single scattering\n    \n    if setting is 1, left and right should converge to same image\n*/\n#define SS_STOCHASTIC_SINGLE 0\n\n/*\n    samping strategy\n    \n    0 : multiple importance sampling\n    1 : bsdf sampling   \n    2 : light sampling\n    \n    // test energy conservation.\n    3 : white furnace test. (works with : bsdf sampling + modifing scene)\n*/\n#define SS_STRATEGY 0\n\n/*\n    lighting condition\n    \n    0 : sky light using cube map. strongly recommend to use \"bsdf sampling\".\n    1 : rectangle light. MIS recommend. but other works well\n*/\n#define SS_LIGHTING_ENV 1\n\n\n\n/*\n    use analytic single scattering to reduce variance while eval\n    \n    0 : full stochastic evaluation\n    1 : analytic single scattering + stochastic evaluation\n    \n    but can't see much improvemnt so default is 0\n*/\n#define SS_EVAL_ALALYTIC_SINGLE 1\n\n\n\n\n\n// don't modify here\n#if SS_STRATEGY == 0\n\n#    define SS_MIS\n\n#elif SS_STRATEGY == 1\n\n#    define SS_BSDF\n\n\n#elif SS_STRATEGY == 2\n\n#    define SS_LIGHT\n\n#elif SS_STRATEGY == 3\n\n#    define SS_WHITE_FURNACE_TEST\n\n#endif\n\n#if SS_LIGHTING_ENV == 0\n\n#    define SS_SKY\n\n#elif SS_LIGHTING_ENV == 1\n\n#    define SS_AREA\n#endif\n\n\n\n\n\n\n\n\n\n\n\n#define M_PI 3.1415926535897932\n#define M_PI_2 1.5707963267948966\n#define M_1_PI 0.3183098861837067\n#define M_2PI 6.2831853071795864\n\n\n\n#define DIFFUSE 0\n#define GLOSSY 1\n#define DIEL 2\n#define GLOSSY_DIFFUSE 3\n#define SUBSURFACE 4\n#define LIGHT 5\n\n\n\n#define NUM_SPHERES 2\n#define NUM_PLANES 1\n#define NUM_RECTS 1\n\nstruct Material\n{\n\tint type;\n  vec3 Color;\n  float Metallic;\n  float Roughness;\n  float IOR;\n  int TexNumber;\n};\n\nstruct Sphere\n{\n\tvec3 center;\n  float radius;\n  Material material;\n};\n\nstruct Plane\n{\n\tvec3 normal;\n\tfloat pos;\n  Material material;\n};\n\nstruct Rect\n{\n\tfloat x0, x1, y0, y1, k;\n  Material material;\n};\n\n\nstruct Ray\n{\n\tvec3 origin;\n  vec3 direction;\n};\n\n\nSphere sphere[NUM_SPHERES];\nPlane plane[NUM_PLANES];\nRect rect[NUM_RECTS];\n\n\n\nfloat saturate(float d)\n{\n\treturn clamp(d,0.0,1.0);\n}\n\n\n\n\nuint seed1; // for random()\n\n// for sso\nuint seedd; \nuint offsets = 0u;\nuint sam = 0u;\n\n\n\n\n// from https://www.shadertoy.com/view/llGSzw  Base: Hugo Elias.\n//ToFloat: http://iquilezles.org/www/articles/sfrand/sfrand.htm\nfloat random() { \t\nseed1 = (seed1 >> 13U) ^ seed1;\n  seed1 = seed1 * (seed1 * seed1 * 15731U + 789221U) + 1338589U;\n  return uintBitsToFloat((seed1>>9U) | 0x3f800000U) - 1.0;\n}\n\nuint reverse_bits(uint x)\n{\n  x = (((x & 0xaaaaaaaau) >> 1u) | ((x & 0x55555555u) << 1u));\n  x = (((x & 0xccccccccu) >> 2u) | ((x & 0x33333333u) << 2u));\n  x = (((x & 0xf0f0f0f0u) >> 4u) | ((x & 0x0f0f0f0fu) << 4u));\n  x = (((x & 0xff00ff00u) >> 8u) | ((x & 0x00ff00ffu) << 8u));\n  return ((x >> 16u) | (x << 16u));\n}\n\nfloat IGN(vec2 coord) {\n\treturn fract(52.9829189 * fract(0.06711056*coord.x + 0.00583715*coord.y));\n}\n\n// Brent Burley. 2020. \"Practical Hash-based Owen Scrambling\"\nconst uint directions[256] = uint[256](\n0x80000000u, 0x40000000u, 0x20000000u, 0x10000000u,\n0x08000000u, 0x04000000u, 0x02000000u, 0x01000000u,\n0x00800000u, 0x00400000u, 0x00200000u, 0x00100000u,\n0x00080000u, 0x00040000u, 0x00020000u, 0x00010000u,\n0x00008000u, 0x00004000u, 0x00002000u, 0x00001000u,\n0x00000800u, 0x00000400u, 0x00000200u, 0x00000100u,\n0x00000080u, 0x00000040u, 0x00000020u, 0x00000010u,\n0x00000008u, 0x00000004u, 0x00000002u, 0x00000001u,\n\n0x80000000u, 0xc0000000u, 0xa0000000u, 0xf0000000u,\n0x88000000u, 0xcc000000u, 0xaa000000u, 0xff000000u,\n0x80800000u, 0xc0c00000u, 0xa0a00000u, 0xf0f00000u,\n0x88880000u, 0xcccc0000u, 0xaaaa0000u, 0xffff0000u,\n0x80008000u, 0xc000c000u, 0xa000a000u, 0xf000f000u,\n0x88008800u, 0xcc00cc00u, 0xaa00aa00u, 0xff00ff00u,\n0x80808080u, 0xc0c0c0c0u, 0xa0a0a0a0u, 0xf0f0f0f0u,\n0x88888888u, 0xccccccccu, 0xaaaaaaaau, 0xffffffffu,\n\n0x80000000u, 0xc0000000u, 0x60000000u, 0x90000000u,\n0xe8000000u, 0x5c000000u, 0x8e000000u, 0xc5000000u,\n0x68800000u, 0x9cc00000u, 0xee600000u, 0x55900000u,\n0x80680000u, 0xc09c0000u, 0x60ee0000u, 0x90550000u,\n0xe8808000u, 0x5cc0c000u, 0x8e606000u, 0xc5909000u,\n0x6868e800u, 0x9c9c5c00u, 0xeeee8e00u, 0x5555c500u,\n0x8000e880u, 0xc0005cc0u, 0x60008e60u, 0x9000c590u,\n0xe8006868u, 0x5c009c9cu, 0x8e00eeeeu, 0xc5005555u,\n\n0x80000000u, 0xc0000000u, 0x20000000u, 0x50000000u,\n0xf8000000u, 0x74000000u, 0xa2000000u, 0x93000000u,\n0xd8800000u, 0x25400000u, 0x59e00000u, 0xe6d00000u,\n0x78080000u, 0xb40c0000u, 0x82020000u, 0xc3050000u,\n0x208f8000u, 0x51474000u, 0xfbea2000u, 0x75d93000u,\n0xa0858800u, 0x914e5400u, 0xdbe79e00u, 0x25db6d00u,\n0x58800080u, 0xe54000c0u, 0x79e00020u, 0xb6d00050u,\n0x800800f8u, 0xc00c0074u, 0x200200a2u, 0x50050093u,\n\n0x80000000u, 0x40000000u, 0x20000000u, 0xb0000000u,\n0xf8000000u, 0xdc000000u, 0x7a000000u, 0x9d000000u,\n0x5a800000u, 0x2fc00000u, 0xa1600000u, 0xf0b00000u,\n0xda880000u, 0x6fc40000u, 0x81620000u, 0x40bb0000u,\n0x22878000u, 0xb3c9c000u, 0xfb65a000u, 0xddb2d000u,\n0x78022800u, 0x9c0b3c00u, 0x5a0fb600u, 0x2d0ddb00u,\n0xa2878080u, 0xf3c9c040u, 0xdb65a020u, 0x6db2d0b0u,\n0x800228f8u, 0x400b3cdcu, 0x200fb67au, 0xb00ddb9du,\n\n0x80000000u, 0x40000000u, 0x60000000u, 0x30000000u,\n0xc8000000u, 0x24000000u, 0x56000000u, 0xfb000000u,\n0xe0800000u, 0x70400000u, 0xa8600000u, 0x14300000u,\n0x9ec80000u, 0xdf240000u, 0xb6d60000u, 0x8bbb0000u,\n0x48008000u, 0x64004000u, 0x36006000u, 0xcb003000u,\n0x2880c800u, 0x54402400u, 0xfe605600u, 0xef30fb00u,\n0x7e48e080u, 0xaf647040u, 0x1eb6a860u, 0x9f8b1430u,\n0xd6c81ec8u, 0xbb249f24u, 0x80d6d6d6u, 0x40bbbbbbu,\n\n0x80000000u, 0xc0000000u, 0xa0000000u, 0xd0000000u,\n0x58000000u, 0x94000000u, 0x3e000000u, 0xe3000000u,\n0xbe800000u, 0x23c00000u, 0x1e200000u, 0xf3100000u,\n0x46780000u, 0x67840000u, 0x78460000u, 0x84670000u,\n0xc6788000u, 0xa784c000u, 0xd846a000u, 0x5467d000u,\n0x9e78d800u, 0x33845400u, 0xe6469e00u, 0xb7673300u,\n0x20f86680u, 0x104477c0u, 0xf8668020u, 0x4477c010u,\n0x668020f8u, 0x77c01044u, 0x8020f866u, 0xc0104477u,\n\n0x80000000u, 0x40000000u, 0xa0000000u, 0x50000000u,\n0x88000000u, 0x24000000u, 0x12000000u, 0x2d000000u,\n0x76800000u, 0x9e400000u, 0x08200000u, 0x64100000u,\n0xb2280000u, 0x7d140000u, 0xfea20000u, 0xba490000u,\n0x1a248000u, 0x491b4000u, 0xc4b5a000u, 0xe3739000u,\n0xf6800800u, 0xde400400u, 0xa8200a00u, 0x34100500u,\n0x3a280880u, 0x59140240u, 0xeca20120u, 0x974902d0u,\n0x6ca48768u, 0xd75b49e4u, 0xcc95a082u, 0x87639641u\n);\n\nuint sobol(uint index, uint dim) {\n    uint X = 0u;\n    for (uint bit = 0u; bit < 32u; bit++) {\n      uint mask = (index >> bit) & 1u;\n      X ^= mask * directions[dim*32u + bit];\n    }\n    return X;\n}\n\nuvec2 sobol2( uint i ) {\n  return uvec2(sobol(i, 0u), sobol(i, 1u));\n}\nvec2 sobol2f( uint i ) {\n  return vec2(sobol(i, 0u), sobol(i, 1u)) *(1.0 / float(0xffffffffu));\n}\n\n\n// https://psychopath.io/post/2021_01_30_building_a_better_lk_hash\nuint laine_karras_permutation(uint x, uint seed) {\n#if 1\n\tx ^= x * 0x3d20adeau;\n\tx += seed;\n\tx *= (seed >> 16u) | 1u;\n\tx ^= x * 0x05526c56u;\n\tx ^= x * 0x53a22864u;\n#else\n    x += seed;\n    x ^= x * 0x6c50b47cu;\n    x ^= x * 0xb82f1e52u;\n    x ^= x * 0xc7afe638u;\n    x ^= x * 0x8d22f6e6u;\n#endif\n    return x;\n}\n\nuint hash_combine(uint seed, uint v) {\n    return seed ^ (v + (seed << 6u) + (seed >> 2u));\n}\n\nuint nested_uniform_scramble(uint x, uint seed) {\n\tx = reverse_bits(x);\n    x = laine_karras_permutation(x, seed);\n    x = reverse_bits(x);\n    return x;\n}\n\n\nvec2 sso2d(uint dim1, uint index) {\n\n\tindex = nested_uniform_scramble(index, seedd);\n\n\tuint x = sobol(index, dim1);\n\n\tx = nested_uniform_scramble(x, hash_combine(seedd, dim1));\n\n\tuint y = sobol(index, dim1+1u);\n\n\ty = nested_uniform_scramble(y, hash_combine(seedd, dim1+1u));\n\n\n\treturn vec2(x, y)* (1.0 / float(0xffffffffu));\n}\n\n\n\n\n\n\nvec3 rayPointAt(Ray ray, float t) {\n \treturn ray.origin + t * ray.direction;\n}\n\n\n\n// Duff et al. 2017. \"Building an Orthonormal Basis, Revisited\"\nvoid make_orthonormal(vec3 n, out vec3 b1, out vec3 b2) {\n\tfloat sign = (n.z >= 0.0) ? 1.0 : -1.0;\n\tfloat a = -1.0 / (sign + n.z);\n\tfloat b = n.x * n.y * a;\n\tb1 = vec3(1.0 + sign * n.x * n.x * a, sign * b, -sign * n.x);\n\tb2 = vec3(b, sign + n.y * n.y * a, -n.y);\n}\n\n\n\nvec3 sample_hemisphere_cosine(vec3 N, vec2 xi) {\n    // safe_sqrt\n\tfloat phi = xi.x * M_2PI;\n\tfloat cos_theta = sqrt(xi.y);\n\tfloat sin_theta = sqrt(1.0 - cos_theta*cos_theta);\n\n\treturn vec3(sin_theta * cos(phi), sin_theta * sin(phi), cos_theta);\n}\n\n\n\nvec3 bsdf_sample_lambert(vec3 albedo, vec3 N, vec2 r, out vec3 L, out float pdf) {\n    vec3 wo = sample_hemisphere_cosine(N, r);\n\n    vec3 X, Y;\n    make_orthonormal(N, X, Y);\n\n    L = X * wo.x + Y * wo.y + N * wo.z;\n    pdf = wo.z * M_1_PI;\n    \n    return albedo*pdf;\n}\n\nvec3 bsdf_eval_lambert(vec3 albedo, vec3 N, vec3 L, out float pdf) {\n\n\tpdf = dot(N, L) * M_1_PI;\n\tif(pdf < 1e-6) { \n        pdf = 0.0; \n        return vec3(0);\n    }\n\n\treturn albedo*pdf;\n}\n\n\n\n\n\n\n\n\n/*\n    to increase metal's reality, replace this to fresnel which support complex refraction index.\n    to increase performance, replace to schlick approx. there is many varient.\n*/\nvec3 fresnel_dielectric_color(vec3 color, float cosNV) {\n  vec3 colorsqrt = sqrt(clamp(color, vec3(0.0, 0.0, 0.0), vec3(0.999)));\n  vec3 n = (1.0 + colorsqrt) / (1.0 - colorsqrt);\n  vec3 g = sqrt(n*n + cosNV*cosNV - 1.0);\n  vec3 a = (g - cosNV) / (g + cosNV);\n  vec3 b = ((g + cosNV) * cosNV - 1.0) / ((g - cosNV) * cosNV + 1.0);\n\n  return 0.5 * a*a * (1.0 + b*b);\n}\n\n\n/*\n    PDF Approximation from Blender Cycles engine.\n    https://github.com/blender/blender/blob/v3.5.0/intern/cycles/kernel/closure/bsdf_microfacet_multi.h\n    \n    SPDX-License-Identifier: Apache-2.0 \n    Copyright 2011-2022 Blender Foundation\n\n*/\nfloat multipleGGX_albedo(float alpha_xy) {\n\n    float r = sqrt(alpha_xy);\n    float albedo = 0.806495 * exp(-1.98712 * r*r) + 0.199531\n    -((((((1.76741*r - 8.43891)*r + 15.784)*r - 14.398)*r\n    + 6.45221)*r - 1.19722)*r + 0.027803)*r - 0.00568739;\n\n    return saturate(albedo);\n}\n\n\n\n// Eric Heitz. 2018. \"Sampling the GGX Distribution of Visible Normals\"\n// allow lower hemishere view\nvec3 sample_D_wi(vec3 V, vec2 alpha, float xi0, float xi1)\n{\n\tvec3 Vh = normalize(vec3(alpha.x * V.x, alpha.y * V.y, V.z));\n\tfloat lensq = Vh.x * Vh.x + Vh.y * Vh.y;\n\tvec3 T1 = lensq > 0.0 ? vec3(-Vh.y, Vh.x, 0.0) * inversesqrt(lensq) : vec3(1, 0, 0);\n\tvec3 T2 = cross(Vh, T1);\n#if 1\n\tfloat r = xi0 > 0.0 ? sqrt(xi0) : 0.0;\n\tfloat phi = M_2PI * xi1;\n\tfloat t1 = r * cos(phi);\n\tfloat t2 = r * sin(phi);\n#else\n\tvec2 disk = sample_disk_concentric(xi);\n\tfloat t1 = disk.x;\n\tfloat t2 = disk.y;\n#endif\n\tfloat s = 0.5 * (1.0 + Vh.z);\n\tt2 = mix(sqrt(1.0 - t1*t1), t2, s);\n\tvec3 Nh = t1 * T1 + t2 * T2 + sqrt(max(0.0, 1.0 - t1*t1 - t2*t2)) * Vh;\n\n\treturn normalize(vec3(alpha.x * Nh.x, alpha.y * Nh.y, max(0.0, Nh.z)));\n}\n\n\n\n\nvec3 bsdf_sample_ggx(Material m,\n\t vec3 N, vec3 V, vec2 xi, out vec3 L, out float pdf)\n{\n    vec2 alpha = vec2(m.Roughness * m.Roughness);\n\n    float cosNV = dot(N, V);\n\n    if (cosNV < 1e-7) {\n        pdf = 0.0;\n        return vec3(0);\n    }\n\n    if (alpha.x <= 1e-3 && alpha.y <= 1e-3) {\n        /* specular case. off MIS */\n        L = 2.0 * N * cosNV - V;\n        \n        return fresnel_dielectric_color(m.Color, cosNV);\n    }\n\n\n    vec3 X, Y;\n    make_orthonormal(N, X, Y);\n    \n    \n\n    vec3 wi = vec3(dot(X, V), dot(Y, V), cosNV);\n    vec3 wm = sample_D_wi(wi, alpha, xi.x, xi.y);\n    float cosVH = dot(wi, wm);\n    L = 2.0 * wm * cosVH - wi;\n\n    float cosNL = L.z;\n    L = normalize(X * L.x + Y * L.y + N * L.z);\n\n    if (cosNL < 1e-7) {\n        pdf = 0.0;\n        return vec3(0);\n    }\n\n    float cosNH = wm.z;\n\n\n    float alpha2 = alpha.x * alpha.x;\n    float d = (cosNH * alpha2 - cosNH) * cosNH + 1.0;\n    float D = M_1_PI * alpha2 / (d * d);\n\n    float termL = sqrt(cosNL * (cosNL - cosNL * alpha2) + alpha2);\n    float termV = sqrt(cosNV * (cosNV - cosNV * alpha2) + alpha2);\n    float G2_by_cosNV = 2.0 * cosNL / (cosNV*termL + cosNL*termV);\n    float G1v_by_cosNV = 2.0 / (cosNV + termV);\n\n\n    vec3 F = fresnel_dielectric_color(m.Color, cosVH);\n\n\n    pdf = 0.25 *D* G1v_by_cosNV;\n\n    return 0.25 * D *F * G2_by_cosNV;\n}\n\nvec3 bsdf_eval_ggx(Material m,\n\t vec3 N, vec3 V, vec3 L, out float pdf) {\n\n    vec2 alpha = vec2(m.Roughness * m.Roughness);\n\n    float cosNV = dot(N, V);\n\n    if (cosNV < 1e-7) {\n        pdf = 0.0;\n        return vec3(0);\n    }\n\n    if (alpha.x <= 1e-3 && alpha.y <= 1e-3) {\n        /* specular case. off MIS */\n\n        pdf = 0.0;\n        return vec3(0);\n    }\n\n    vec3 H = normalize(V + L);\n    float cosVH = dot(V, H);\n\n    float cosNL = dot(N, L);\n\n    if (cosNL < 1e-7) {\n\n        pdf = 0.0;\n        return vec3(0);\n    }\n\n    float cosNH = dot(N, H);\n\n\n    float alpha2 = alpha.x * alpha.y;\n    float d = (cosNH * alpha2 - cosNH) * cosNH + 1.0;\n    float D = M_1_PI * alpha2 / (d * d);\n\n    float termL = sqrt(cosNL * (cosNL - cosNL * alpha2) + alpha2);\n    float termV = sqrt(cosNV * (cosNV - cosNV * alpha2) + alpha2);\n    float G2_by_cosNV = 2.0 * cosNL / (cosNV*termL + cosNL*termV);\n    float G1v_by_cosNV = 2.0 / (cosNV + termV);\n\n\n    vec3 F = fresnel_dielectric_color(m.Color, cosVH);\n\n    pdf = 0.25 * D * G1v_by_cosNV;\n\n    return 0.25 * D *F * G2_by_cosNV;\n}\n\n\n/*\n    see supplment for G1_dist, lambda(), phase\n    Heitz et al. 2016. \"Multiple-Scattering Microfacet BSDFs with the Smith Model\"\n    \n    \n                \n*/\n\n\n/*\n    smith lambda of ggx.  sign(wi.z) is important.\n    \n    lambda(-wr) = 1 + lambda(wr) \n*/\n\nfloat Lambda(vec2 alpha, vec3 wi) {\n    vec2 wa = wi.xy * alpha / max(abs(wi.z), 1e-6);\n\n    return 0.5 * (-1.0 + sign(wi.z) * sqrt(1.0 + dot(wa, wa)));\n}\n\n\nvec3 bsdf_sample_ggx_multi( Material m, vec3 N, vec3 V, out vec3 L, out float pdf)\n{\n    vec2 alpha = vec2( m.Roughness * m.Roughness);\n\n    vec3 X, Y;\n    make_orthonormal(N, X, Y);\n    vec3 wi = (vec3(dot(X, V), dot(Y, V), dot(N, V)));\n    vec3 wr = -wi;\n\n    bool escape = false;\n    vec3 eval = vec3(1.0);\n    float z = 0.0;\n    \n#if SS_STOCHASTIC_SINGLE\n    for (int i = 0; i < 2; i++) {\n#else\n    for (int i = 0; i < 10; i++) {\n#endif\n        float lambda_wr = Lambda(alpha, wr);\n        float xi = random();\n\n        z += -log(xi) / lambda_wr;\n\n        if (z > 0.0) {\n            escape = true;\n            break;\n        }\n        \n        if (i < 9) {\n            float xi0 = random();\n            float xi1 = random();\n            vec3 wm = sample_D_wi(-wr, alpha, xi0, xi1);\n\n            float cosVH = dot(-wr, wm);\n            wr = normalize(2.0 * wm * cosVH + wr);\n#ifndef SS_WHITE_FURNACE_TEST\n            eval *= fresnel_dielectric_color(m.Color, cosVH);\n#endif\n        }\n    }\n\n\n    if (!escape || wr.z < 1e-7) {\n        //eval = single;\n        pdf = 0.0;\n        return eval*0.0;\n    }\n\n    L = X * wr.x + Y * wr.y + N * wr.z;\n    \n    float pdf_single;\n    float alpha2 = alpha.x * alpha.y;\n    {\n        vec3 wm = normalize(wi+wr); \n        float d = (wm.z * alpha2 - wm.z) * wm.z + 1.0;\n        float D = M_1_PI * alpha2 / (d * d);\n\n        float termV = sqrt(wi.z * (wi.z - wi.z * alpha2) + alpha2);\n\n        float G1v_by_dotNV = 2.0 / (wi.z + termV);\n\n        pdf_single = 0.25 * D * G1v_by_dotNV;\n    }\n\n#if SS_STOCHASTIC_SINGLE\n    float ratio = 1.0;\n#else\n    float ratio = multipleGGX_albedo(alpha2);\n#endif\n    float pdf_multi = wr.z * M_1_PI;\n\n    pdf = mix(pdf_multi, pdf_single, ratio);\n\n\n    return eval * pdf;\n}\n\n\n\nvec3 bsdf_eval_ggx_multi(Material m, vec3 N, vec3 V, vec3 L, out float pdf) {\n\n    vec2 alpha = vec2(m.Roughness * m.Roughness);\n\n    vec3 X, Y;\n    make_orthonormal(N, X, Y);\n    vec3 wi = normalize(vec3(dot(X, V), dot(Y, V), dot(N, V)));\n    vec3 wo = normalize(vec3(dot(X, L), dot(Y, L), dot(N, L)));\n    \n    // reduce variance\n    bool swap = false;\n    if (wo.z < wi.z) {\n        swap = true;\n        vec3 tmp = wi;\n        wi = wo;\n        wo = tmp;\n    }\n    vec3 wr = -wi;\n\n    float z = 0.0;\n\n    float pdf_single = 0.0;\n    vec3 eval = vec3(0.0);\n    vec3 throughput = vec3(1.0);\n    \n    // analytic single scattering \n    float alpha2 = alpha.x * alpha.y;\n    {\n#if SS_STOCHASTIC_SINGLE != 1 || SS_EVAL_ALALYTIC_SINGLE == 1\n        vec3 wm = normalize(wi + wo);\n        float d = (wm.z * alpha2 - wm.z) * wm.z + 1.0;\n        float D = M_1_PI * alpha2 / (d * d);\n\n        float termL = sqrt(wo.z * (wo.z - wo.z * alpha2) + alpha2);\n        float termV = sqrt(wi.z * (wi.z - wi.z * alpha2) + alpha2);\n\n        float G2_by_cosNV = 2.0 * wo.z / (wi.z*termL + wo.z*termV);\n        float G1v_by_cosNV = 2.0 / (swap ? (wo.z + termL) : (wi.z + termV));\n\n        pdf_single = 0.25 * D * G1v_by_cosNV;\n\n        eval = fresnel_dielectric_color(m.Color, dot(wi, wm)) *\n          0.25 * D * G2_by_cosNV;\n#endif\n    }\n\n\n    /*\n        From supplement material of \n        d'Eon et al. 2023.\"Microfacet theory for non-uniform heightfields\"\n        \n        Algoritm 1\n        tau = z * projectedarea(wo)\n        result = result + exp(tau) * phase(wr, wo)\n        \n        seems optical depth should project back to wo by dividing wo.z\n        \n        \n        G1l = exp((z / wo.z) * projectedarea(wo))\n            = exp((z / wo.z) * wo.z * lambda(wo))\n            = exp(z * lambda(wo))\n        \n        wo.z will cancelout and match with below result of G1l\n    */\n    float lambda_wo = Lambda(alpha, wo); \n    vec3 wm = normalize(-wr + wo);\n\n#if SS_STOCHASTIC_SINGLE\n    for (int i = 0; i < 1; i++) {\n#else\n    for (int i = 0; i < 10; i++) {\n#endif\n        float lambda_wr = Lambda(alpha, wr);\n        float xi = random();\n\n        z += -log(xi) / lambda_wr;\n        if (z > 0.0) {\n            break;\n        }\n\n#if SS_STOCHASTIC_SINGLE != 1 || SS_EVAL_ALALYTIC_SINGLE == 1\n        // not estimate first bounce\n        if (i > 0)\n#endif\n        {\n            vec3 wm = normalize(-wr + wo);\n            if (wm.z > 0.0) {\n            \n            float d = (wm.z * alpha2 - wm.z) * wm.z + 1.0;\n            float D = M_1_PI * alpha2 / (d * d);\n            \n            vec3 F = fresnel_dielectric_color(m.Color, dot(-wr, wm));\n            /*\n                see this for z = log(C1(h))\n                Dupuy et al. 2016. \"Additional Progress Towards the Unification of Microfacet and Microflake Theories\"\n                \n                z = log(C1(h))\n                G1_dist(wr, h) = C1(h)^lambda(wr) = exp(z * lambda(wr))\n            */\n            float G1l = exp(z * lambda_wo);\n            /*\n                ray traversal toward wr, wo\n                projectedarea(wr) = wr.z*lambda(wr)   // wr, wo\n                projectedarea(-wr) = wr.z*(1 + lambda(wr)) // wi (which denote 'incident direction')\n                \n                \n                wi = -wr\n                projectedarea(wi) = wi.z * (1 + lambda(wi))\n                projectedarea(wr) = wr.z * lambda(wr)\n            */\n            //float inv_projectedarea = 1.0 / max(1e-6, wr.z * lambda_wr);\n            float inv_projectedarea = 1.0 / max(1e-6, -wr.z *(1.0+ Lambda(alpha , -wr)));\n            /*  \n                D_vis(wi, wm) = D(wi, wm) * max(0, dot(wi, wm)) / projectedarea(wi)\n                phase(wi, wo) = D_vis(wi, wm) / (4 * abs(dot(wi, wm)))               // here, dot(wi, wm) > 0\n                              = D(wi, wm) / (4 * projectedarea(wi))\n            */\n            eval += throughput * // energy\n                    F * // absortion\n                    G1l * // shadowing\n                    0.25 * D *inv_projectedarea; // phase\n            }\n        }\n        \n        if (i < 9) {\n            float xi0 = random();\n            float xi1 = random();\n            vec3 wm_ = sample_D_wi(-wr, alpha, xi0, xi1);\n\n            float cosVH = dot(-wr, wm_);\n            wr = normalize(2.0 * wm_ * cosVH + wr);\n            \n            \n\n            throughput *= fresnel_dielectric_color(m.Color, cosVH);\n        }\n    }\n#if SS_STOCHASTIC_SINGLE\n    float ratio = 1.0;\n#else\n    float ratio = multipleGGX_albedo(alpha2);\n#endif\n// swap?\n    float pdf_multi = (swap? wi.z :wo.z) * M_1_PI;\n\n    pdf = mix(pdf_multi, pdf_single, ratio);\n\n    eval *= swap ? abs(wi.z / wo.z) : 1.0;\n\n    return eval;\n}\n\n\n\n\n\n\n\n// d'Eon et al. 2023.\"Microfacet theory for non-uniform heightfields\"\nvec3 bsdf_sample_ggx_multi_unsym(Material m, vec3 N, vec3 V, out vec3 L, out float pdf)\n{\n    float w_a = 0.5;\n    float w_b = 1.0 - w_a;\n    vec2 alpha_a = vec2(0.424*0.424);\n    vec2 alpha_b = vec2(0.05*0.05);\n    //vec3 color_a = vec3(1.0);\n    //vec3 color_b = vec3(0.28, 0.88, 0.9);\n    \n    vec3 X, Y;\n    make_orthonormal(N, X, Y);\n    vec3 wi = (vec3(dot(X, V), dot(Y, V), dot(N, V)));\n    vec3 wr = -wi;\n\n    bool escape = false;\n    vec3 eval = vec3(1.0);\n    float z = 0.0;\n    float zs = log(1.0 - w_a);\n    \n#if SS_STOCHASTIC_SINGLE\n    for (int i = 0; i < 2; i++) {\n#else\n    for (int i = 0; i < 10; i++) {\n#endif\n        vec2 alpha =  z > zs ? alpha_a : alpha_b;\n        float A = Lambda(alpha, wr);\n        float xi = random();\n\n        z += -log(xi) / A;\n        \n\n        \n        if (z > 0.0) {\n            escape = true;\n            break;\n        }\n        \n        if (i < 9) {\n            vec2 alpha =  z > zs ? alpha_a : alpha_b;\n            \n            float xi0 = random();\n            float xi1 = random();\n            vec3 wm = sample_D_wi(-wr, alpha, xi0, xi1);\n\n            float cosVH = dot(-wr, wm);\n            wr = normalize(2.0 * wm * cosVH + wr);\n\n            eval *= fresnel_dielectric_color(m.Color, cosVH);\n        }\n    }\n\n\n    if (!escape || wr.z < 1e-7) {\n        //eval = single;\n        pdf = 0.0;\n        return eval*0.0;\n    }\n\n    L = X * wr.x + Y * wr.y + N * wr.z;\n    \n    \n    //todo: single scattering\n    pdf = 1.0;\n\n\n    return eval * pdf;\n}\n\n\n\n\n//vec3 bsdf_eval_ggx_multi_unsym(Material m, vec3 N, vec3 V, out vec3 L, out float pdf)\n//{\n//}\n\n\n\n\n//fast inverse for orthogonal matrices\nmat4 mat4Inverse( in mat4 m ) {\n    mat3 rotate_inv = mat3(\tvec3( m[0][0], m[1][0], m[2][0] ),\n                          \tvec3( m[0][1], m[1][1], m[2][1] ),\n                          \tvec3( m[0][2], m[1][2], m[2][2] ) );\n\n    return mat4(\tvec4( rotate_inv[0], 0.0 ),\n                \tvec4( rotate_inv[1], 0.0 ),\n                \tvec4( rotate_inv[2], 0.0 ),\n              \t\tvec4( (-rotate_inv)*m[3].xyz, 1.0 ) );\n}\n\nvec3 toVec3( vec4 v ) {\n    if( ( abs(v.w)<1e-4 ) ) {\n        return v.xyz;\n    }\n\n    return v.xyz*(1.0/v.w);\n}\n\n// Ureña et al. 2013. \"An Area-Preserving Parametrization for Spherical Rectangles\"\nstruct SphQuad {\n    vec3 o, x, y, z; // local reference system R\n    float z0, z0sq; //\n    float x0, y0, y0sq; // rectangle coords in R\n    float x1, y1, y1sq; //\n    float b0, b1, b0sq, k; // misc precomputed constants\n    float S; // solid angle of Q\n};\n\n\nvoid SphQuadInit(vec3 s,vec3 ex,vec3 ey,vec3 o, out SphQuad squad) {\n    squad.o = o;\n    float exl = length(ex), eyl = length(ey);\n    // compute local reference system R\n    squad.x = ex / exl;\n    squad.y = ey / eyl;\n    squad.z = cross(squad.x, squad.y);\n    // compute rectangle coords in local reference system\n    vec3 d = s - o;\n    squad.z0 = dot(d, squad.z);\n    // flip z to make it point against Q\n    if (squad.z0 > 0.) {\n    squad.z *= -1.;\n    squad.z0 *= -1.;\n    }\n    squad.z0sq = squad.z0 * squad.z0;\n    squad.x0 = dot(d, squad.x);\n    squad.y0 = dot(d, squad.y);\n    squad.x1 = squad.x0 + exl;\n    squad.y1 = squad.y0 + eyl;\n    squad.y0sq = squad.y0 * squad.y0;\n    squad.y1sq = squad.y1 * squad.y1;\n  // compute normals to edges\n  float n0z = -squad.y0 * inversesqrt(squad.z0sq + squad.y0sq);\n  float n1z = squad.x1 * inversesqrt(squad.z0sq + squad.x1*squad.x1);\n  float n2z = squad.y1 * inversesqrt(squad.z0sq + squad.y1sq);\n  float n3z = -squad.x0 * inversesqrt(squad.z0sq + squad.x0*squad.x0);\n  // compute internal angles (gamma_i)\n  float g0 = acos(-n0z * n1z);\n  float g1 = acos(-n1z * n2z);\n  float g2 = acos(-n2z * n3z);\n  float g3 = acos(-n3z * n0z);\n    // compute predefined constants\n    squad.b0 = n0z;\n    squad.b1 = n2z;\n    squad.b0sq = squad.b0 * squad.b0;\n    squad.k = M_2PI - g2 - g3;\n    // compute solid angle from internal angles\n    squad.S = g0 + g1 - squad.k;\n}\n\nvoid SphQuadSample(in vec3 x, SphQuad squad, float u, float v, out vec3 w, out float pdf) {\n    // 1. compute cu\n    float au = u * squad.S + squad.k;\n    float fu = (cos(au) * squad.b0 - squad.b1) / sin(au);\n    float cu = inversesqrt(fu*fu + squad.b0sq) * (fu>0. ? +1. : -1.);\n    cu = clamp(cu, -1., 1.); // avoid NaNs\n    // 2. compute xu\n    float xu = -(cu * squad.z0) * inversesqrt(1. - cu*cu);\n    xu = clamp(xu, squad.x0, squad.x1); // avoid Infs\n    // 3. compute yv\n    float d = sqrt(xu*xu + squad.z0sq);\n    float h0 = squad.y0 * inversesqrt(d*d + squad.y0sq);\n    float h1 = squad.y1 * inversesqrt(d*d + squad.y1sq);\n    float hv = h0 + v * (h1-h0), hv2 = hv*hv;\n    float yv = (hv2 < 1.-1e-4) ? (hv*d)* inversesqrt(1.-hv2) : squad.y1;\n    // 4. transform (xu,yv,z0) to world coords\n\n    vec3 p = (squad.o + xu*squad.x + yv*squad.y + squad.z0*squad.z);\n    w = normalize(p - x);\n    pdf = 1. / max(1e-6,squad.S);\n}\n\n\n\n\nbool hitScene(vec3 P, vec3 D, float tMin, float tMax,\n              out float dist, out vec3 normal, out Material material)\n{\n    float near = tMax;\n    bool hit = false;\n\n    for (int i = 0; i < NUM_SPHERES; i++) {\n        Sphere sphere = sphere[i];\n\n        vec3 f = P - sphere.center;\n        float b = dot(-f, D);\n        vec3 k =  f + b * D;\n        float r2 = sphere.radius * sphere.radius;\n        float k2 = dot(k, k);\n\n        if (r2 >= k2) {\n            /* drop sign(b) from (sign(b) * sqrt(r2 - k2)) to handle center behind ray */\n            float q = b + sqrt(r2 - k2);\n            float f2 = dot(f,f);\n            float t = f2 < r2 ?  q : (f2 - r2) / q;\n            if (t > tMin && t < near) {\n                near = t;\n                hit = true;\n                normal = (P+D*t - sphere.center) / sphere.radius;\n                material = sphere.material;\n                if (mod(normal.z, 0.3) < 0.15)\n                //    material.Roughness = 0.6;\n                //else\n                    material.Roughness *= 0.75;\n            }\n        }\n    }\n#ifndef SS_WHITE_FURNACE_TEST\n    for (int j = 0; j < NUM_PLANES; j++) {\n        Plane plane = plane[j];\n        float cosNV = dot(D, -plane.normal);\n        vec3 axis = P * abs(plane.normal);\n        float a = axis.x + axis.y + axis.z;\n\n        float t = ( a - plane.pos ) / cosNV;\n        if ( t > tMin && t < near ) {\n            near = t;\n            hit = true;\n            vec3 position = P+D*t;\n            normal = plane.normal * sign(cosNV);\n            material = plane.material;\n            if ((mod(position.x, 1.0) > 0.5 && mod(position.y, 1.0) > 0.5) || (mod(position.x, 1.0) < 0.5 && mod(position.y, 1.0) < 0.5))\n                material.Color = vec3(0.7177);\n            else\n                material.Color = vec3(0.22);\n        }\n    }\n\n#    ifdef SS_AREA\n    for (int i = 0; i < NUM_RECTS; i++) {\n        Rect rect = rect[i];\n        float a = rect.k - P.z;\n        float t = a / D.z;\n\n        if (t > tMin && t < near) {\n            float x = P.x + t * D.x;\n            float y = P.y + t * D.y;\n\n            if (x > rect.x0 && x < rect.x1 && y > rect.y0 && y < rect.y1) {\n                near = t;\n                hit = true;\n                normal = vec3(0.0, 0.0 ,-sign(a));\n                material = rect.material;\n            }\n        }\n    }\n#    endif\n#endif\n\n    dist = near;\n \treturn hit;\n}\n\n\n\n\n\n\n\nvoid initScene()\n{\n\t/*\n\tint type;\n  vec3 Color;\n  float Metallic;\n  float Roughness;\n  float IOR;\n  */\n\n\t  sphere[0] = Sphere(vec3(0, 0.0, 1.01), 1.0,\n\t  \tMaterial(GLOSSY, \n#ifndef SS_WHITE_FURNACE_TEST        \n        vec3(0.9999,0.782,0.347) // gold??\n#else \n        vec3(1.0) // non absorb\n#endif       \n        , 0.0, (SS_ROUGHNESS), 1.5, 0));\n    //sphere[1] = Sphere(vec3(2, 0, 1), 0.2, Material(DIFFUSE, vec3(1.0), 0.0, 0.950, 1.5, 0));\n   // sphere[2] = Sphere(vec3(0, 1, -1.25), 1.0, Material(GLOSSY, vec3(1), 0.0, 0.0, 1.5, 0));\n   // sphere[3] = Sphere(vec3(0, 1, -3.75), 1.0, Material(GLOSSY_DIFFUSE, vec3(0.2,0.75,0.998), 0.0, 0.0, 1.97, 0));\n    //sphere[4] = Sphere(vec3(-4, 2, 0), 1.5, Material(LIGHT, 10.*vec3(1,0.05,0.0), 0., 0.220, 1.5, 1));\n    //sphere[5] = Sphere(vec3(2.5, 1, 0), 1.0, Material(GLOSSY, vec3(1,0.766,0.336), 1.0, 0.32, 26.5, 0));\n    //sphere[6] = Sphere(vec3(2.5, 2., 3.75), 1.5, Material(LIGHT, 12.*vec3(1), 1.0, 0.42, 26.5, 0));\n   // sphere[7] = Sphere(vec3(4.5, 1, 2.75 ), 01., Material(DIEL, vec3(0.99,0.661,0.425), 1.0, 0.42, 1., 0));\n#ifndef SS_WHITE_FURNACE_TEST\n    //plane[] = Plane(vec3(0, 1, 0), -6.0, Material(DIFFUSE, vec3(0.9623), 0., 0.220, 1.5, 1));\n    plane[0] = Plane(vec3(0, 0, 1), 0.0, Material(DIFFUSE, vec3(0.9623), 0., 0.220, 1.5, 1));\n#   ifdef SS_AREA\n    rect[0] = Rect(-2., 2., -2., 2. , 12., Material(LIGHT, 4. *vec3(5.105), 1.0, 0.2, 1.05,0));\n#   endif\n#endif\n}\n\nvec3 HDR(vec3 c) {\n    c = pow(c, vec3(2.2));\n    float f = smoothstep(2.800,3.0,c.x+c.y+c.z); \n    return mix(c,12.*c,f);\n}\nvec3 Gamma(vec3 x)\n{\n\treturn pow(x , vec3(0.45454545));\n}\n\nvec3 ACESFilm(vec3 x) {\n\tfloat a = 2.51;\n\tfloat b = 0.03;\n\tfloat c = 2.51;//2.43;\n\tfloat d = 0.59;\n\tfloat e = 0.14;\n\t//return x;\n\treturn (x*(a*x+b))/(x*(c*x+d)+e);\n}\n\n\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":1,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\n/*\n    If you enable SS_HAZY, \n    \n    \n    \n                you MUST set SS_STRATEGY to 1\n\n                This flag alter right side of the screen.\n\n\n    \n    change roughness and weight from commom tab line 844\n    \n    optional: SS_LIGHTING_ENV to 1 to see difference clearly\n    \n    see paper for detail\n*/\n\n// #define SS_HAZY\n\n\n\nint spilt;\n\nvec3 trace(Ray ray) {\n\n\tvec3 N;\n\tMaterial material;\n\n\tvec3 radiance = vec3(0.0);\n\tvec3 throughput = vec3(1.0);\n\n\n\tvec3 eval = vec3(1.0);\n\tfloat pdf = 0.0;\n\n    for (int b = max(-iFrame, 0); ;) {\n\n        float dist;\n        if (!hitScene(ray.origin, ray.direction, 1e-5, 1e+9, dist, N, material)) {\n#ifdef SS_WHITE_FURNACE_TEST        \n            vec3 sky = vec3(0.5);\n#else\n            vec3 sky = vec3(0.0);\n#    ifdef SS_SKY   \n            sky = HDR(texture(iChannel2, ray.direction).xyz);\n#    endif\n#endif\n            radiance += throughput * sky;\n            break;\n        }\n        vec3 position = ray.origin + ray.direction*dist;\n        vec3 V = -ray.direction;\n        vec3 L;\n        vec3 Ng = N;\n\n        vec2 r = sso2d(uint(2+b*2), sam);\n\n        //r = vec2(random(), random());\n\n        switch(material.type) {\n\n            case LIGHT :\n            {\n                if(pdf == 0.) return radiance;\n                \n                float mis = 1.0;\n#if defined(SS_MIS) \n                // calc solid angle for MIS\n                const mat4 trans = mat4(\n                vec4( 1.0, 0.0, 0.0, 0.0 ),\n                vec4( 0.0, 1.0, 0.0, 0.0 ),\n                vec4( 0.0, 0.0, 1.0, 0.0 ),\n                vec4( 0.0, 0.0, 12.0, 1.0 ));\n\n                mat4 itrans = mat4Inverse(trans);\n                vec3 pos =  toVec3(itrans*vec4(ray.origin,1));\n                vec2 pmin = vec2(-2.) , pmax = vec2(2.);\n                vec3 s = vec3(pmin, 0.0);\n                vec3 ex = vec3(pmax.x - pmin.x, 0., 0.);\n                vec3 ey = vec3(0., pmax.y - pmin.y, 0.);\n                SphQuad squad;\n                SphQuadInit(s, ex, ey, pos, squad);\n                \n                // actually we need only solidangle, so this is unnecessary..\n                vec3 Li;\n                float pdfl;\n                vec2 xi0;// = vec2(random(), random());\n\n                SphQuadSample(pos, squad, xi0.x, xi0.y, Li, pdfl);\n  \n                mis = pdf*pdf/(pdfl*pdfl+pdf*pdf);\n                \n#endif \n\n#if defined(SS_BSDF) || defined(SS_MIS) \n                radiance += throughput* material.Color * mis;\n#endif  \n                return radiance;\n                \n                break;\n            }\n\n\n            case DIFFUSE :\n            {\n                eval = bsdf_sample_lambert( material.Color, N, r, L, pdf);\n                break;\n            }\n\n\n            case GLOSSY :\n            {\n                if(spilt == 0)\n                    eval= bsdf_sample_ggx_multi(material, N, V, L, pdf);\n                else\n#ifndef SS_HAZY\n                    eval = bsdf_sample_ggx(material, N, V, r, L , pdf);\n#else\n                    eval = bsdf_sample_ggx_multi_unsym(material, N, V, L , pdf);\n#endif\n\n                break;\n            }\n\n\n            default :\n            {\n                radiance = vec3(0);\n                break;\n            }\n        }\n\n        if (b >= max(-iFrame, SS_MAX_BOUNCES)) {\n            break;\n        }\n        \n        b++;\n        \n        \n       ray = Ray(position+N*0.0001, normalize(L));\n        \n#if defined(SS_LIGHT) || defined(SS_MIS)      \n        //  NEE\n        // sample rect light (solid angle)\n\n        const mat4 trans = mat4(\t\n        vec4( 1.0, 0.0, 0.0, 0.0 ),\n        vec4( 0.0, 1.0, 0.0, 0.0 ),\n        vec4( 0.0, 0.0, 1.0, 0.0 ),\n        vec4( 0.0, 0.0, 12., 1.0 ));\n\n        mat4 itrans = mat4Inverse(trans);\n        vec3 pos =  toVec3(itrans*vec4(position,1));\n\n        vec2 pmin = vec2(-2.) , pmax = vec2(2.);\n        vec3 s = vec3(pmin, 0.0);\n        vec3 ex = vec3(pmax.x - pmin.x, 0., 0.);\n        vec3 ey = vec3(0., pmax.y - pmin.y, 0.);\n        SphQuad squad;\n        SphQuadInit(s, ex, ey, pos, squad);\n\n        vec3 Li, du;\n        float pdfl;\n        vec2 xi0 = vec2(random(), random());\n        \n\n        SphQuadSample(pos, squad, xi0.x, xi0.y, Li, pdfl);\n        Material tmp;\n\n        L = toVec3(trans*vec4(Li,0));\n\n        if(dot(L,N)>0.){\n            float dis;\n            if (hitScene(position, L, 0.0001, 1e+9, dis, du, tmp)) {\n                if(tmp.type==LIGHT) {\n\n                vec3 evalb;\n                float pdfb;\n\n                switch(material.type) {\n\n\n                    case DIFFUSE :\n                    {\n                        evalb = bsdf_eval_lambert(material.Color, N, L, pdfb);\n                        break;\n                    }\n\n\n                    case GLOSSY :\n                    {\n                        if(spilt == 0)\n                            evalb = bsdf_eval_ggx_multi(material, N, V, L, pdfb);\n\n                        else\n#ifndef SS_HAZY\n                            evalb = bsdf_eval_ggx(material, N, V, L , pdfb);                      \n#else\n                            evalb = bsdf_eval_ggx_multi_unsym(material, N, V, L , pdfb);\n#endif\n\n\n                        break;\n                    }\n                }\n\n                float mis = 1.0;\n#    if defined(SS_MIS)                   \n                mis = pdfl*pdfl/(pdfl*pdfl+pdfb*pdfb);\n#    endif \n\n                radiance +=  throughput* (tmp.Color/pdfl) *evalb *mis;\n                }\n            }\n        }\n#endif // LIGHT || MIS\n\n        throughput *= eval/pdf;\n\n        if(dot(N, ray.direction) < 0.0 || pdf <= 0.0) return radiance;\n    }\n\n\n    return radiance;\n}\n\n\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec4 PreColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    \n\n    if (PreColor.a >= SS_SAMPLE) {\n        fragColor = PreColor;\n        return;\n    }\n    \n    \n    PreColor.a++;\n    \n    // progress bar\n    if (fragCoord.y > iResolution.y - 5.5) {\n        float b = (uv.x < (PreColor.a) / SS_SAMPLE) ? 1.0 : 0.0;\n        fragColor = (false) ?vec4(0) : PreColor.a * vec4(b, 0.0, b, 1.0);\n        return;\n    }\n\n    \n    \n    initScene();\n\n    // init global RNG\n    vec3 bluenoise = texelFetch(iChannel1, ivec2(fragCoord) % ivec2(1024), 0).xyz;\n    // seed1 = uint(1857371.0*IGN(gl_FragCoord.xy)) + 5392840U*uint(PreColor.a);\n    //seed1 = reverse_bits(uint(gl_FragCoord.x + gl_FragCoord.y *iResolution.x))+ 9280U*uint(PreColor.a);\n    seed1 = uint(1857371.0*IGN(gl_FragCoord.xy)) + 9280U*uint(PreColor.a * SS_SAMPLE_per_FRAME);\n    seedd = uint(1857371.0*IGN(gl_FragCoord.xy));\n    sam = uint(SS_SAMPLE_per_FRAME*PreColor.a);\n\n    // screen split\n    if(uv.x< 0.5)\n        spilt = 0;\n    else\n    {\n        spilt = 1;\n        //sphere[0].material.type = DIFFUSE;\n    }\n        \n\n    // camera\n    vec3 origin;\n    vec3 lookAt = vec3(0.0, 0.0, 1.0);\n    \n    #if 1\n    origin.x = -3.055;\n    origin.y = -3.055;\n    origin.z = 2.837;\n    #else\n    const float dist = 1.0;\n    vec2 mousePos = vec2(5.,1.)*(mouse.xy + vec2(0.05, -1.51));\n    origin.x = sin(mousePos.y)* cos( mousePos.x ) * dist;\n    origin.y = sin(mousePos.y)* sin( mousePos.x ) * dist;\n    origin.z = cos(mousePos.y)* dist;\n    #endif\n\n\n    const float FOV = 50.0;\n    const float halfWidth = tan(radians(FOV) * 0.5);\n    float halfHeight = halfWidth * iResolution.y / iResolution.x;\n\n       \n    vec2 xi = vec2(0.5);\n    //rand = hammersley( uint(PreColor.a), uint(AA_SAMPLE));\n    //rand = halton2(int(PreColor.a), 2, 3);\n    //rand.x = fract(bluenoise.x + rand.x);\n    //rand = R2(vec2(0.5, 0.47), PreColor.a );?? unknown aliasing\n    //rand = vec2(random(),random());\n    xi = sso2d(0u, uint(PreColor.a));\n    \n    vec3 w = normalize(lookAt - origin);\n    vec3 u = normalize(cross(w, vec3(0.0, 0.0, 1.0)));\n    vec3 v = cross(u, w);\n    \n    vec2 uvc = (fragCoord + xi-0.5) / vec2(iResolution) * 2.0 - 1.0;\n    vec3 D = vec3(uvc.x * halfWidth, uvc.y * halfHeight, 1.0);\n    D = D.x*u + D.y*v + D.z*w;\n    D = normalize(D);\n    vec3 P = origin;   \n    \n    \n    \n    \n    vec3 Color = vec3(0);\n    for (int i = min(iFrame, 0); iFrame>-9&& i < max(-iFrame, int(SS_SAMPLE_per_FRAME)); ) {\n        Color += trace(Ray(P, D));\n        sam ++;\n        i++;\n    }\n    Color /= SS_SAMPLE_per_FRAME;\n\n    fragColor = (false) ? vec4(Color, 0.0)\n    : vec4(PreColor.rgb*(PreColor.a==1.?0.:1.) + Color, PreColor.a);\n\n}\n\n\n","name":"Buffer A","description":"","type":"buffer"}]}