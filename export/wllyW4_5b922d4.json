{"ver":"0.1","info":{"id":"wllyW4","date":"1592754529","viewed":879,"name":"Real-Time Atmospheric Scattering","username":"rayferric","description":"Real-time atmospheric scattering\n • Accurate atmospheric scattering that is able to run in true real-time.\n • Primary ray is clamped to a maximum length to ensure pleasant visuals at the horizon while maintaining low sample count.","likes":32,"published":1,"flags":0,"usePreview":1,"tags":["sky","performance","scattering","night","realtime","day"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdfGRn","filepath":"/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","previewfilepath":"/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14159265359\n\n// Dimensions\n#define PLANET_RADIUS     6371e3\n#define ATMOSPHERE_HEIGHT 100e3\n#define RAYLEIGH_HEIGHT   8e3\n#define MIE_HEIGHT        1.2e3\n#define OZONE_PEAK_LEVEL  30e3\n#define OZONE_FALLOFF     3e3\n// Scattering coefficients\n#define BETA_RAY   vec3(3.8e-6, 13.5e-6, 33.1e-6) // vec3(5.5e-6, 13.0e-6, 22.4e-6)\n#define BETA_MIE   vec3(21e-6)\n#define BETA_OZONE vec3(2.04e-5, 4.97e-5, 1.95e-6)\n#define G          0.75\n// Samples\n#define SAMPLES          4\n#define LIGHT_SAMPLES    1 // Set to more than 1 for a realistic, less vibrant sunset\n\n// Other\n#define SUN_ILLUMINANCE   128000.0\n#define MOON_ILLUMINANCE  0.32\n#define SPACE_ILLUMINANCE 0.01\n\nconst float ATMOSPHERE_RADIUS = PLANET_RADIUS + ATMOSPHERE_HEIGHT;\n\n/**\n * Computes entry and exit points of ray intersecting a sphere.\n *\n * @param origin    ray origin\n * @param dir       normalized ray direction\n * @param radius    radius of the sphere\n *\n * @return    .x - position of entry point relative to the ray origin | .y - position of exit point relative to the ray origin | if there's no intersection at all, .x is larger than .y\n */\nvec2 raySphereIntersect(in vec3 origin, in vec3 dir, in float radius) {\n\tfloat a = dot(dir, dir);\n\tfloat b = 2.0 * dot(dir, origin);\n\tfloat c = dot(origin, origin) - (radius * radius);\n\tfloat d = (b * b) - 4.0 * a * c;\n    \n\tif(d < 0.0)return vec2(1.0, -1.0);\n\treturn vec2(\n\t\t(-b - sqrt(d)) / (2.0 * a),\n\t\t(-b + sqrt(d)) / (2.0 * a)\n\t);\n}\n\n/**\n * Phase function used for Rayleigh scattering.\n *\n * @param cosTheta    cosine of the angle between light vector and view direction\n *\n * @return    Rayleigh phase function value\n */\nfloat phaseR(in float cosTheta) {\n    return (3.0 * (1.0 + cosTheta * cosTheta)) / (16.0 * PI);\n}\n\n/**\n * Henyey-Greenstein phase function, used for Mie scattering.\n *\n * @param cosTheta    cosine of the angle between light vector and view direction\n * @param g           scattering factor | -1 to 0 - backward | 0 - isotropic | 0 to 1 - forward\n *\n * @return    Henyey-Greenstein phase function value\n */\nfloat phaseM(in float cosTheta, in float g) {\n\tfloat gg = g * g;\n\treturn (1.0 - gg) / (4.0 * PI * pow(1.0 + gg - 2.0 * g * cosTheta, 1.5));\n}\n\n/**\n * Approximates density values for a given point around the planet.\n *\n * @param pos    position of the point, for which densities are calculated\n *\n * @return    .x - Rayleigh density | .y - Mie density | .z - ozone density\n */\nvec3 avgDensities(in vec3 pos) {\n\tfloat height = length(pos) - PLANET_RADIUS; // Height above surface\n\tvec3 density;\n\tdensity.x = exp(-height / RAYLEIGH_HEIGHT);\n\tdensity.y = exp(-height / MIE_HEIGHT);\n    density.z = (1.0 / cosh((OZONE_PEAK_LEVEL - height) / OZONE_FALLOFF)) * density.x; // Ozone absorption scales with rayleigh\n    return density;\n}\n\n/**\n * Calculates atmospheric scattering value for a ray intersecting the planet.\n *\n * @param pos         ray origin\n * @param dir         ray direction\n * @param lightDir    light vector\n *\n * @return    sky color\n */\nvec3 atmosphere(\n\tin vec3 pos,\n\tin vec3 dir,\n\tin vec3 lightDir\n) {\n\t// Intersect the atmosphere\n    vec2 intersect = raySphereIntersect(pos, dir, ATMOSPHERE_RADIUS);\n\n\t// Accumulators\n\tvec3 opticalDepth = vec3(0.0); // Accumulated density of particles participating in Rayleigh, Mie and ozone scattering respectively\n    vec3 sumR = vec3(0.0);\n    vec3 sumM = vec3(0.0);\n    \n    // Here's the trick - we clamp the sampling length to keep precision at the horizon\n    // This introduces banding, but we can compensate for that by scaling the clamp according to horizon angle\n    float rayPos = max(0.0, intersect.x);\n    float maxLen = ATMOSPHERE_HEIGHT;\n    maxLen *= (1.0 - abs(dir.y) * 0.5);\n\tfloat stepSize = min(intersect.y - rayPos, maxLen) / float(SAMPLES);\n    rayPos += stepSize * 0.5; // Let's sample in the center\n    \n    for(int i = 0; i < SAMPLES; i++) {\n        vec3 samplePos = pos + dir * rayPos; // Current sampling position\n\n\t\t// Similar to the primary iteration\n\t\tvec2 lightIntersect = raySphereIntersect(samplePos, lightDir, ATMOSPHERE_RADIUS); // No need to check if intersection happened as we already are inside the sphere\n\n        vec3 lightOpticalDepth = vec3(0.0);\n        \n        // We're inside the sphere now, hence we don't have to clamp ray pos\n        float lightStep = lightIntersect.y / float(LIGHT_SAMPLES);\n        float lightRayPos = lightStep * 0.5; // Let's sample in the center\n        \n        for(int j = 0; j < LIGHT_SAMPLES; j++) {\n            vec3 lightSamplePos = samplePos + lightDir * (lightRayPos);\n\n\t\t\tlightOpticalDepth += avgDensities(lightSamplePos) * lightStep;\n\n            lightRayPos += lightStep;\n        }\n\n\t\t// Accumulate optical depth\n\t\tvec3 densities = avgDensities(samplePos) * stepSize;\n\t\topticalDepth += densities;\n\n\t\t// Accumulate scattered light\n        vec3 scattered = exp(-(BETA_RAY * (opticalDepth.x + lightOpticalDepth.x) + BETA_MIE * (opticalDepth.y + lightOpticalDepth.y) + BETA_OZONE * (opticalDepth.z + lightOpticalDepth.z)));\n        sumR += scattered * densities.x;\n        sumM += scattered * densities.y;\n\n        rayPos += stepSize;\n    }\n\n    float cosTheta = dot(dir, lightDir);\n    \n    return max(\n        phaseR(cosTheta)    * BETA_RAY * sumR + // Rayleigh color\n       \tphaseM(cosTheta, G) * BETA_MIE * sumM,  // Mie color\n    \t0.0\n    );\n}\n\n/**\n * Draws a blackbody as seen from the planet.\n *\n * @param dir         ray direction\n * @param lightDir    light vector\n *\n * @return    blackbody color\n */\nvec3 renderBlackbody(in vec3 dir, in vec3 lightDir) {\n    float cosTheta = dot(dir, lightDir);\n    \n    float intensity = smoothstep(0.998, 0.999, cosTheta);\n    float glow = pow(max(cosTheta, 0.0), 4.0) * 0.01;\n\t\n    float fade = smoothstep(0.05, 0.25, dir.y);\n    float glowFade = smoothstep(0.05, 0.25, lightDir.y);\n    \n    return vec3(intensity + glow * glowFade) * fade;\n}\n\n/**\n * Calculates daylight factor at given sun height.\n *\n * @param sunHeight    sun height\n *\n * @return    daylight factor in range <0.0, 1.0>\n */\nfloat getDayFactor(in float sunHeight) {\n    return pow(smoothstep(-0.6, 0.6, sunHeight), 8.0);\n}\n\n/**\n * Computes shadow light illuminance at given sun height.\n *\n * @param sunHeight    sun height\n *\n * @return    shadow light illuminance\n */\nfloat getShadowIlluminance(in float sunHeight) {\n    return mix(MOON_ILLUMINANCE, SUN_ILLUMINANCE, getDayFactor(sunHeight - 0.2));\n}\n\n/**\n * Rotates two dimensional coordinate around the origin.\n *\n * @param coord    two-component coordinate\n * @param angle    rotation angle in radians\n *\n * @return    rotated coordinate\n */\nvec2 rotate(in vec2 coord, float angle) {\n    vec2 t = vec2(sin(angle), cos(angle));\n    return vec2(coord.x * t.y - coord.y * t.x, dot(coord, t));\n}\n\n/**\n * Calculates the view direction of a pixel based on its location.\n *\n * @param uv    fragment position in range [0.0, 1.0] on both axes\n *\n * @return    normalized view direction\n */\nvec3 viewDir(in vec2 uv, in float ratio) {\n    uv = uv * 2.0 - 1.0;\n\tuv.x *= ratio;\n\treturn normalize(vec3(uv.x, uv.y, -1.0));\n    \n\t// vec2 t = ((uv * 2.0) - vec2(1.0)) * vec2(PI, PI * 0.5); \n    // return normalize(vec3(cos(t.y) * cos(t.x), sin(t.y), cos(t.y) * sin(t.x)));\n}\n\n/**\n * Transforms HDR color to LDR space using the ACES operator.\n * Ported from original source:\n * https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve\n * For a more accurate curve, head to:\n * https://github.com/TheRealMJP/BakingLab/blob/master/BakingLab/ACES.hlsl\n *\n * @param color    HDR color\n *\n * @return    LDR color\n */\nvec3 tonemapACES(in vec3 color) {\n    float a = 2.51;\n    float b = 0.03;\n    float c = 2.43;\n    float d = 0.59;\n    float e = 0.14;\n    return clamp((color * (a * color + b)) / (color * (c * color + d) + e), 0.0, 1.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    float ratio = iResolution.x / iResolution.y;\n    vec2 mouse = iMouse.xy / iResolution.xy;\n\n\tvec3 pos = vec3(0.0, PLANET_RADIUS + 2.0, 0.0);\n\tvec3 dir = viewDir(uv, ratio);\n    // Clamp dir.y to mask the dark part of the sky\n    // dir.y = dir.y < 0.03 ? (dir.y - 0.03) * 0.2 + 0.03 : dir.y;\n\tvec3 sunDir = iMouse.xy == vec2(0.0) ? vec3(0.0, -0.03, -1.0) : viewDir(mouse, ratio);\n    dir = normalize(dir);\n    sunDir = normalize(sunDir);\n    \n    float shadowIlluminance = getShadowIlluminance(sunDir.y);\n\t// Sky\n\tvec3 color = atmosphere(pos, dir, sunDir) * shadowIlluminance;\n    color += atmosphere(pos, dir, -sunDir) * shadowIlluminance;\n    // Blackbodies\n    color += renderBlackbody(dir, sunDir) * shadowIlluminance;\n    color += renderBlackbody(dir, -sunDir) * shadowIlluminance;\n    // Space (use a cube map with 3 dimensional rotation in real applications)\n    color += texture(iChannel0, rotate(uv, iTime * 0.01) * 2.0).xyz * getDayFactor(dir.y + 0.25) * SPACE_ILLUMINANCE;\n    \n    // Tonemapping\n    float exposure = 16.0 / shadowIlluminance;\n    exposure = min(exposure, 16.0 / (MOON_ILLUMINANCE * 8.0)); // Clamp the exposure to make night appear darker\n    color = tonemapACES(color * exposure);\n    color = pow(color, vec3(1.0 / 2.2));\n    \n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}