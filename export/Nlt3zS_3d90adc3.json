{"ver":"0.1","info":{"id":"Nlt3zS","date":"1700992344","viewed":42,"name":"It's Hexa Britney!","username":"omegasbk","description":"Britney in a hexa field, because why not?","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["sdf","hexafield"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xdf3Rn","filepath":"/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm","previewfilepath":"/media/ap/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm","type":"video","channel":1,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// 17.11.2021.\n// Made by Darko Supe (omegasbk)\n\n#define MAX_STEPS 100\n\n#define MAX_DIST 170.\n#define MIN_DIST 0.0002\n\n#define TILE_SIZE 0.08\n#define SPACING 0.2\n\n#define PI 3.14159265359\n\n#define INTENSITY 1.2\n\nfloat sdfSphere(vec3 c, float r, vec3 p)\n{\n    return distance(p, c) - r + texture(iChannel0, p.xy * 100.).g; \n}\n\nvec3 rotate(in vec3 p, in float angle)\n{\n    mat3 m = mat3(\n        cos(angle),  sin(angle), 0.,  // first column (not row!)\n        -sin(angle), cos(angle), 0.,  // second column\n        0.,                  0., 1.   // third column\n    ); \n    \n    return p * m;\n}\n\n\nfloat sdHexPrism(vec3 p, vec2 h)\n{\n  const vec3 k = vec3(-0.8660254, 0.5, 0.57735);\n  p = abs(p);\n  p.xy -= 2.0*min(dot(k.xy, p.xy), 0.0)*k.xy;\n  vec2 d = vec2(\n       length(p.xy-vec2(clamp(p.x,-k.z*h.x,k.z*h.x), h.x))*sign(p.y-h.x),\n       p.z-h.y );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nvec4 opRep(in vec3 p, in vec3 c)\n{\n    vec3 index;\n    modf((p + 0.5 * c) / c, index);\n    vec3 q = mod(p + 0.5 * c, c) - 0.5 * c; \n    float h = texture(iChannel1, index.xy / 200.).g;\n    return vec4(q, h);\n}\n\nfloat opUnion(float d1, float d2) { return min(d1,d2); }\n\nvec2 getDist(vec3 p)\n{\n    p = p.xzy;\n    float SPACING_X = SPACING + (cos(PI/6.) * TILE_SIZE * 2.);\n    \n    vec4 oneRep = opRep(p.xyz, vec3(SPACING_X, SPACING, 0.));\n    float one = sdHexPrism(oneRep.xyz, vec2(TILE_SIZE, oneRep.w * INTENSITY));\n    vec4 twoRep = opRep(p.xyz + vec3(SPACING_X / 2., SPACING / 2., 0.), vec3(SPACING_X, SPACING, 0.));\n    float two = sdHexPrism(twoRep.xyz, vec2(TILE_SIZE, twoRep.w * INTENSITY));\n    \n    float height = twoRep.w;\n    if (one < two) \n        height = oneRep.w;\n    \n    return vec2(opUnion(one, two), height);\n}\n\nvec2 rayMarch(vec3 ro, vec3 rd)\n{\n    float dist = 0.;\n    float height = 0.;\n    \n    for (int i = 0; i < MAX_STEPS; i++)\n    {\n        vec3 itPos = ro + rd * dist;\n        vec2 itDist = getDist(itPos);\n        \n        dist += itDist.x;\n        height = itDist.y;\n        \n        if (dist > MAX_DIST || dist < MIN_DIST)  \n            break;\n    }    \n    \n    return vec2(dist, height);\n}\n\nvec3 getNormal(vec3 p)\n{\n    vec2 e = vec2(0.01, 0.);    \n    return normalize(vec3(getDist(p + e.xyy).x, getDist(p + e.yxy).x, getDist(p + e.yyx).x));    \n}\n\nfloat getLight(vec3 p)\n{\n    vec3 lightPos = vec3(sin(iTime * 3.), 10., -2.2);\n    vec3 lightDir = normalize(p - lightPos);\n    \n    return -dot(getNormal(p), lightDir);    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    vec2 uv = fragCoord/iResolution.xy - 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    float focalDist = 0.7;\n    vec3 ro = vec3(30., (sin((iTime -3.) / 2.) + 1.) * 10., -1.6);\n    vec3 rd = vec3(uv.x, uv.y, focalDist); \n    \n    rd = rotate(rd.zyx, 1.).zyx;\n  \n    vec3 col = vec3(0.);\n    \n    vec2 dist = rayMarch(ro, rd);\n    if (dist.x < MAX_DIST)\n    {\n        vec3 pHit = ro + rd * dist.x;\n        col = vec3(0.5, 0.6, 0.6);\n        col *= vec3(getLight(pHit)) + vec3(0.1);\n        col += dist.y * vec3(0., .7, .8) / 3.;        \n    }    \n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}