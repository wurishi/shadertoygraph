{"ver":"0.1","info":{"id":"ctl3Dn","date":"1671598306","viewed":205,"name":"inside a singularity","username":"Carandiru","description":"quick shader test, chatgpt is very helpful and even came up with an optimized intersectSphere() function!","likes":4,"published":3,"flags":0,"usePreview":0,"tags":["short","singularity"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Calculate the intersection point of a ray with a sphere\nvec3 intersectSphere(vec3 rayOrigin, vec3 rayDir, vec3 sphereCenter, float sphereRadius)\n{\n    // Calculate the vector from the origin of the ray to the center of the sphere\n    vec3 rayToSphere = sphereCenter - rayOrigin;\n\n    // Calculate the projection of the rayToSphere vector onto the direction of the ray\n    float projection = dot(rayToSphere, rayDir);\n\n    // Calculate the distance from the projection to the intersection point\n    float distanced = sqrt(length(rayToSphere) * length(rayToSphere) - projection * projection);\n\n    // Calculate the distance from the origin of the ray to the intersection point\n    float t = projection - distanced;\n\n    // Calculate the intersection point by moving along the ray\n    return rayOrigin + t * rayDir;\n}\n\n// Calculate the uv coordinates for a point on the surface of the sphere\nvoid calculateUV(vec3 camPos, vec3 rayDir, vec3 center, float radius, out float u, out float v, out float w)\n{\n    // Calculate the intersection point of the ray with the sphere\n    vec3 intersection = intersectSphere(camPos, rayDir, center, radius);\n\n    // Calculate the vector from the center of the sphere to the intersection point\n    vec3 vec = intersection - center;\n\n    // Normalize the vector\n    vec = normalize(vec);\n\n    // Define a unit vector that points in the direction of the x-axis\n    vec3 xAxis = (vec3(log(iTime)*5.0f, 0.0f, 0.0f));\n\n    // Calculate the u coordinate by taking the dot product between the vector and the x-axis unit vector\n    u = dot(vec, xAxis);\n\n    // Define a unit vector that points in the direction of the y-axis\n    vec3 yAxis = (vec3(0.0f, log(iTime)* 5.0f, 0.0f));\n\n    // Calculate the v coordinate by taking the dot product between the vector and the y-axis unit vector\n    v = dot(vec, yAxis);\n    \n    // Define a unit vector that points in the direction of the z-axis\n    vec3 zAxis = (vec3(0.0f, 0.0f, 1.0f));\n    \n    // Calculate the v coordinate by taking the dot product between the vector and the y-axis unit vector\n    w = dot(vec, zAxis);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Define the radius of the sphere\n    const float radius = 1000.0;\n\n    // Define the center of the sphere\n    vec3 center = vec3(0);\n\n    vec2 uv = fragCoord/iResolution.xy;\n    uv = uv * 2.0f - 1.0f;\n    \n    // Calculate the position of the camera and the direction of the ray\n    vec3 camPos = vec3(0.0f, 0.0f, 1.0f) * 0.5f;\n    vec3 rayDir = normalize(vec3(uv.x, uv.y, 0.0f) - camPos);\n\n    // Calculate the u and v coordinates for the point on the surface of the sphere\n    vec3 uvw;\n    calculateUV(camPos, rayDir, center, radius, uvw.x, uvw.y, uvw.z);\n\n    // Set the fragment color to the uv coordinates\n    vec3 color = vec3(0);\n    \n    vec3 L = rayDir * uvw;\n    vec3 N = texture(iChannel0, uvw.xy).rgb * 2.0f - 1.0f;\n        \n    //vec3 t = vec3(dot(uvw, vec3(1,0,0)), dot(uvw, vec3(0,1,0)), dot(uvw, vec3(0,0,1))) * 0.5f + 0.5f;\n    \n    color = vec3(dot(N, normalize(L)));\n    \n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}