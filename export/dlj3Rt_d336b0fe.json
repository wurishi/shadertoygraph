{"ver":"0.1","info":{"id":"dlj3Rt","date":"1673804995","viewed":1327,"name":"Above The Clouds","username":"Poisson","description":"A city above the clouds inspired by Dubai.","likes":79,"published":1,"flags":0,"usePreview":1,"tags":["3d","raymarching","ray","volume","sun","clouds","cloud","volumetric","raymarcher","scattering","city","atmosphere","scatter","volumetrics","mie"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// A city above the clouds inspired by Dubai\n// https://en.wikipedia.org/wiki/Dubai\n\n#define AA 1 // antialiasing, et it to 2 if you have a very fast computer\n\n// light direction\nconst vec3 lig = normalize(vec3(-.1,.2,-1));\n\n// aces tonemapping\nvec3 ACES(vec3 x) {\n    float a = 2.51;\n    float b =  .03;\n    float c = 2.43;\n    float d =  .59;\n    float e =  .14;\n    return (x*(a*x+b))/(x*(c*x+d)+e);\n}\n\n// rotation function\nmat2 rot(float a) {\n    float s = sin(a), c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\n// float random number\nfloat hash(float n) {return fract(sin(n)*43758.5453123);}\n\n// noise function by iq\nfloat noise(vec3 x) {\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.-2.*f); // S curve\n    \n    float n = p.x + p.y*157. + 113.*p.z;\n\n    return mix(mix(mix(hash(n+  0.), hash(n+  1.),f.x),\n                   mix(hash(n+157.), hash(n+158.),f.x),f.y),\n               mix(mix(hash(n+113.), hash(n+114.),f.x),\n                   mix(hash(n+270.), hash(n+271.),f.x),f.y),f.z);\n}\n\n// fractal noise\nfloat fbm(vec3 p) {\n    float f = 0.;\n    f += .5*noise(p);\n    f += .25*noise(2.*p);\n    f += .125*noise(4.*p);\n    f += .0625*noise(8.*p);\n    f += .03125*noise(16.*p);\n    return f;\n}\n\n// 2d box sdf\nfloat sdBox2D(vec2 p, vec2 s) {\n    vec2 q = abs(p) - s;\n    return length(max(q,0.)) + min(max(q.x,q.y),0.);\n}\n\n// buiding sdf\nfloat building(vec3 p) {\n    float d = sdBox2D(p.xz,vec2(.1,.2))-.2;\n    d = max(d,p.y+.6);\n    d = min(d, abs(sdBox2D(p.xz,vec2(.08,.16))-.16+.02)-.02);\n    d = max(d, p.y+.35);\n    d = min(d, abs(sdBox2D(p.xz-vec2(.05,0),vec2(.0,.08)+.05)-.08+.02)-.02);\n    d = max(d, p.y+.2);\n    return d;\n}\n\n// city sdf\nfloat city(vec3 p) {\n    vec3 q = p-vec3(-3,-.4,-8);\n    \n    float s = 2.;\n    q.xz = (fract(q.xz/s+.5)-.5)*s;\n\n    float d = mod(floor(p.x/s)+round(p.z/s),2.)==0. ? \n              building(q-vec3(0,-.2,0)) : \n              building((q.zyx)*vec3(1,1.5,1.2));\n    \n    d = max(d, max(p.x+.5,abs(p.z)-5.5));\n    d = max(d, 2.5-max(abs(p.x),abs(p.z+3.)));\n    \n    return d;\n}\n\n// sdf of the Burj Khalifa\n// it's the ugliest code i've ever write\n// but i'm too lazy to improve it\nfloat highBuilding(vec3 p) {\n    float d = sdBox2D(p.xz,vec2(.1))-.5;\n    d = max(d, p.y+.3);\n    d = min(d, sdBox2D(p.xz-.25,vec2(.1))-.3);\n    d = max(d, p.y-.3);\n    d = min(d, sdBox2D(p.xz+.25,vec2(.1))-.25);\n    d = max(d, p.y-.9);\n    d = min(d, sdBox2D(p.xz-.15,vec2(.1))-.2);\n    d = max(d, p.y-1.5);\n    d = min(d, sdBox2D(p.xz+.1,vec2(.1))-.15);\n    d = max(d, p.y-2.1);\n    d = min(d, sdBox2D(p.xz-.07,vec2(.1))-.1);\n    d = max(d, p.y-2.7);\n    d = min(d, sdBox2D(p.xz+.04,vec2(.1))-.05);\n    d = max(d, p.y-3.3);\n    d = min(d, sdBox2D(p.xz-.02,vec2(.1)));\n    d = max(d, p.y-3.9);\n    d = min(d, sdBox2D(p.xz+.01,vec2(.1))+.05);\n    d = max(d, p.y-4.5);\n    d = min(d, sdBox2D(p.xz-.005,vec2(.1))+.08);\n    d = max(d, p.y-5.1);\n    return d;\n}\n\n// scene sdf\nfloat map(vec3 p) {\n    float d = building((p-vec3(1.3,-.4,0)).zyx*vec3(1,1.5,1.3));\n    d = min(d, building((p-vec3(-3.5,.2,-1.8))*vec3(2,1.3,1))/2.);\n    d = min(d, building((p-vec3(-3.,-.4,-.3)).zyx*vec3(1,1,1.4))/1.4);\n    d = min(d, building((p-vec3(-6,-.4,-2.4))*vec3(-1,1.8,1))/1.4);\n    d = min(d, city(p*vec3(-1,1,1)-vec3(-2,0,-3)));\n    d = min(d, building((p-vec3(.4,.1,-10))*vec3(.6,1.8,1))/1.);\n    d = min(d, building((p-vec3(-.6,-.55,-7)).zyx*vec3(1,1.3,1.3))/1.);\n    d = min(d, building((p-vec3(8,0.4,-20))*.5));\n    d = min(d, highBuilding(p-vec3(-8,0,-12)));\n   \n    return d;\n}\n\n// raymarching loop\nfloat intersect(vec3 ro, vec3 rd, float tmax) {\n    float t = 0.; // distance travelled\n    for (int i=0; i<256 && t<tmax; i++) {\n        vec3 p = ro + rd*t; // current point\n        \n        float h = map(p); // scene distance\n        if (h<.001) break; // we hit the surface\n        \n        t += h; // march the ray\n    }\n    // return the distance\n    return t;\n}\n\n// normal estimation\nvec3 calcNormal(vec3 p) {\n    float h = map(p);\n    const vec2 e = vec2(.0001,0); // epsilon\n    \n    return normalize(h - vec3(map(p-e.xyy),\n                              map(p-e.yxy),\n                              map(p-e.yyx)));\n}\n\n// soft shadow function\n// thanks to iq: https://iquilezles.org/articles/rmshadows/\nfloat shadow(vec3 ro, vec3 rd, float tmax, float k) {\n    float res = 1.;\n    for (float t=0.; t<tmax;) {\n        vec3 p = ro + rd*t;\n        float h = map(p);\n        if (h<.001) return 0.;\n        res = min(res, k*h/t);\n        t += h;\n    }\n    return res*res*(3.-2.*res); // S curve\n}\n\n// ambient occlusion function\nfloat calcAO(vec3 p, vec3 n, float k) {\n    return clamp(.5+.5*map(p+n*k)/k,0.,1.);\n}\n\n// fog\nvec3 fog(float t) {\n    return 1.-exp(-t*t*.0005*vec3(1.3,1.3,1.7)); // beer's law\n}\n\n// clouds map\nfloat mapClouds(vec3 p) {\n\tfloat f = 2.5*fbm(1.2*p+vec3(.5,.9,1)*.1*iTime);\n    f = mix(f,f*.1,.4+.6*noise(.5*p+vec3(.5,.3,1)*.05*iTime));\n    return 1.5*f - 2. - p.y;\n}\n\n// clouds rendering\n// insipred by iq's clouds\n// https://www.shadertoy.com/view/XslGRr\nvec4 renderClouds(vec3 bgCol, float depth, vec3 ro, vec3 rd) {\n    // bounding volumes\n    float tmin = (-.4-ro.y)/rd.y;\n    float tmax = min((-3.-ro.y)/rd.y,depth);\n\n    vec4 sum = vec4(0); // color and opacity\n    if (tmin<0.) return sum;\n    \n    float t = tmin; // distance travelled\n    // dithering\n    t += .2*hash(iTime+gl_FragCoord.x*8315.9213/iResolution.x+gl_FragCoord.y*2942.5192/iResolution.y);\n    \n    for (int i=0; i<64; i++) { // raymarching loop\n       vec3 p = ro + rd*t; // current point\n       float h = mapClouds(p); // density\n       \n       if(h>0.) { // inside the volume\n           // cheap lighting\n           float k = .2;\n           float dif = clamp((h - mapClouds(p + k*lig))/k,0.,1.);\n           // shadow\n           float sha = shadow(p, lig, 16., 16.);\n           // ambient occlusion\n           float occ = exp(-h*4.);\n           occ *= 1.-exp(-map(p)*16.);\n           \n           vec3 col = vec3(0);\n           col += .4*vec3(.75,.75,1)*occ; // sky light\n           float glare = .8+1.4*pow(dot(rd,lig),8.);\n           col += vec3(1,.55,.3)*1.7*dif*sha*occ*glare; // sun light\n           \n           col = mix(col, bgCol, fog(t)); // atmosphere\n           \n           sum += h*vec4(col,1)*(1.-sum.a);\n       }\n       t += t/64.; // march the ray\n       if(t>tmax || sum.a>.99) break; // optimization\n    }\n\n    // output\n    return sum;\n}\n\n// buildings coloring and lighting\nvec3 shade(vec3 bgCol, vec3 p, vec3 rd, float t) {\n    vec3 n = calcNormal(p); // normal of the surface\n        \n    float dif = clamp(dot(n, lig),0.,1.); // diffuse light\n    float bac = clamp(dot(n, -lig),0.,1.); // back/bounce light\n    float sha = shadow(p+n*.002, lig, 16., 16.); // soft shadow\n    float occ = sqrt(calcAO(p, n, .1)*calcAO(p, n, .05)); // ambient occlusion\n    float spe = clamp(dot(reflect(rd,n), lig),0.,1.); // specular\n    \n    // color of the surface\n    vec3 mat = vec3(.8);\n    float f = noise(16.*p+4.*fbm(32.*p));\n    mat *= .8+.2*f;\n    \n    vec3 col = vec3(0);\n    col += mat*2.*vec3(1,.7,.5)*dif*sha; // sun light\n    col += mat*.11*vec3(.75,.75,1)*(.75+.25*bac)*occ; // sky light + bounce light\n    col += f*mat*4.*vec3(1,.7,.5)*pow(spe,12.)*sha*dif*occ; // sun specular\n        \n    col = mix(col, bgCol, fog(t)); // atmosphere\n    return col;\n}\n\n// rendering function\nvec3 render(vec3 ro, vec3 rd) {\n    // background\n    vec3 col = .8*mix(vec3(.85,.7,.75),vec3(.12,.1,.23),clamp(1.-exp(-rd.y*7.),0.,1.));\n    float sun = clamp(dot(rd,lig),0.,1.);\n    // sun\n    col += vec3(1,.6,.3)*.001/(1.-pow(sun,4.));\n    \n    float tmax = 64.; // max distance\n    float t = intersect(ro, rd, tmax); // distance\n    \n    if (t<tmax) { // we hit the surface\n        // shade the buildings\n        vec3 p = ro + rd*t;\n        col = mix(col, shade(col, p, rd, t), smoothstep(-3.,-2.,p.y));\n    }\n    \n    // clouds\n    vec4 res = renderClouds(col, min(t,tmax), ro, rd);\n    col = col*(1.-res.a)+res.rgb; // mix the original color with the clouds color\n    \n    // sun glare\n    col += vec3(1,.4,.2)*pow(sun,14.);\n            \n    // output\n    return clamp(col*.9-.02,0.,1.);\n}\n\n// camera function\nmat3 setCamera(vec3 ro, vec3 ta) {\n    vec3 w = normalize(ta - ro);\n    vec3 u = normalize(cross(w, vec3(0,1,0)));\n    vec3 v = cross(u, w);\n    return mat3(u, v, w);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 tot = vec3(0);\n    \n    // antialiasing loops\n    for (int m=0; m<AA; m++)\n    for (int n=0; n<AA; n++) {\n        vec2 off = vec2(m,n)/float(AA) - .5; // AA offset\n        // pixel coordinates centered at the origin\n        vec2 p = (fragCoord+off - .5*iResolution.xy) / iResolution.y;\n        \n        vec3 ro = vec3(.2+.2*sin(.4*iTime),.7,4); // ray origin\n        vec3 ta = vec3(0); // target\n        mat3 ca = setCamera(ro, ta); // camera matrix\n        \n        vec3 rd = ca * normalize(vec3(p,1)); // ray direction\n        \n        // render\n        vec3 col = render(ro, rd);\n        tot += col;\n    }\n    tot /= float(AA*AA);\n\n    // post processing\n    tot = tot*.6+.4*ACES(tot); // tonemap\n    tot = pow(tot, vec3(.4545)); // gamma correction\n    tot = clamp(tot,0.,1.); // clamping the color\n    tot = tot*.3+.7*tot*tot*(3.-2.*tot); // contrast\n    // color grading\n    //tot = pow(tot,vec3(.8,.9,1))+vec3(0,0,.03); // red tint\n    tot = pow(tot,vec3(1,.9,.8))+vec3(.03,.03,0); // blue tint\n        \n    // vignette\n    vec2 q = fragCoord/iResolution.xy;\n    tot *= .5+.5*pow(16. * q.x*q.y*(1.-q.x)*(1.-q.y), .1);\n        \n    // film grain\n    tot *= .97+.05*hash(q.x*13.+q.y*432.12);\n        \n    // output\n    fragColor = vec4(tot,1.0);\n}","name":"Image","description":"","type":"image"}]}