{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[{"channel":0,"type":"texture","id":"XsX3Rn","filepath":"/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"}},{"channel":1,"type":"texture","id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"}},{"channel":2,"type":"texture","id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"}},{"channel":3,"type":"texture","id":"4sf3Rn","filepath":"/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"}}],"code":"#define MAX_STEPS 64\n#define EPSILON .001\n#define PI 3.1415926535897932384626433832795\n\nmat3 rotateX(float a) {\n\tmat3 m;\n\tm[0][0] = 1.;\n\tm[0][1] = 0.;\n\tm[0][2] = 0.;\n\tm[1][0] = 0.;\n\tm[1][1] = cos(a);\n\tm[1][2] = -sin(a);\n\tm[2][0] = 0.;\n\tm[2][1] = -m[1][2];\n\tm[2][2] = m[1][1];\n\treturn m;\n}\n\n\nmat3 rotateY(float a) {\n\tmat3 m;\n\tm[0][0] = cos(a);\n\tm[0][1] = 0.;\n\tm[0][2] = sin(a);\n\tm[1][0] = 0.;\n\tm[1][1] = 1.;\n\tm[1][2] = 0.;\n\tm[2][0] = -m[0][2];\n\tm[2][1] = 0.;\n\tm[2][2] = m[0][0];\n\treturn m;\n}\n\nmat3 rotateZ(float a) {\n\tmat3 m;\n\tm[0][0] = cos(a);\n\tm[0][1] = -sin(a);\n\tm[0][2] = 0.;\n\tm[1][0] = -m[0][1];\n\tm[1][1] = m[0][0];\n\tm[1][2] = 0.;\n\tm[2][0] = 0.;\n\tm[2][1] = 0.;\n\tm[2][2] = 1.;\n\treturn m;\n}\n\nstruct material {\n    vec3 diffuse;\n};\n\t\nfloat s_floor(vec3 a) {\n\treturn a.y + 1. - 0.03 * texture(iChannel3, vec2(a.x + iTime * .3, a.z + iTime)).r + 0.3 * a.x;\n}\n\nfloat s_sphere(vec3 a) {\n    vec3 b = a;\n\tb = rotateX(iTime) * b;\n\tb = rotateY(PI * 0.5) * b;\n\treturn length(a) - 1. + 0.1 * texture(iChannel2, vec2(atan(sqrt(b.x * b.x + b.y * b.y) / b.z) / PI, atan(b.y / b.x) / PI)).r;\n}\n\nfloat world(vec3 a) {\n    return min(s_floor(a), s_sphere(a));\n}\n\nvec3 wnormal(vec3 a) {\n    vec2 e = vec2(.001, 0.);\n    float w = world(a);\n\treturn normalize(vec3(\n\t    world(a + e.xyy) - w,\n\t    world(a + e.yxy) - w,\n\t    world(a + e.yyx) - w));\n}\n\nmaterial wmaterial(vec3 a) {\n\tmaterial m;\n\tif (s_sphere(a) < s_floor(a)) {\n\t\ta = wnormal(a);\n\t\ta = rotateX(iTime) * a;\n\t\ta = rotateY(PI * .5) * a;\n\t\tm.diffuse = texture(iChannel0, vec2(atan(sqrt(a.x * a.x + a.y * a.y) / a.z) / PI, atan(a.y / a.x) / PI)).rgb;\n\t}\n\telse {\n\t\tm.diffuse = texture(iChannel1, vec2(a.x + iTime * .3, a.z + iTime)).rgb;\n\t}\n\treturn m;\n}\n\nfloat trace(vec3 O, vec3 D, float l_min) {\n    float L = l_min;\n    for (int i = 0; i < MAX_STEPS; ++i) {\n    \tfloat d = world(O + D*L);\n        L += d;\n        if (d < EPSILON*L)\n        \tbreak;\n    }\n    return L;\n}\n\nfloat occlusion(vec3 at, vec3 normal) {\n    float b = 0.;\n    for (int i = 1; i <= 4; ++i) {\n        float L = .06 * float(i);\n        float d = world(at + normal * L);\n        b += max(0., L - d);\n    }\n    return min(b, 1.);\n}\n\nvec3 enlight(vec3 at, material m, vec3 normal, vec3 l_pos) {\n\tvec3 l_dir = l_pos - at;\n\tfloat shadow = 1.;\n\tfloat L = EPSILON * 2.;\n\tfor (int i = 0; i < MAX_STEPS; ++i) {\n    \tfloat d = world(at + normalize(l_dir)*L);\n        if (d < EPSILON*L) {\n\t\t\tshadow = 0.;\n        \tbreak;\n\t\t}\n\t\tshadow = min(shadow, d/L*32.);\n\t\tL += d;\n    }\n\treturn m.diffuse * max(0., dot(normal, normalize(l_dir))) / dot(l_dir, l_dir) * shadow;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord.xy / iResolution.xy * 2. - 1.;\n    uv.x *= iResolution.x / iResolution.y;\n    vec3 eye = vec3(0., 0., 4.);\n    vec3 D = normalize(vec3(uv, -2));\n    float path = trace(eye, D, 0.);\n    vec3 pos = eye + D * path;\n\tvec3 nor = wnormal(pos);\n\tmaterial mat = wmaterial(pos);\n\tvec3 color = .2 * (1. - occlusion(pos, nor)) * mat.diffuse + 0.1;\n\tcolor += enlight(pos, mat, nor, vec3(2.*cos(iTime), 1., 2.*sin(iTime))) * 2.;\n\tcolor = mix(color, vec3(0.8), smoothstep(0.,20.,path));\n\tfragColor = vec4(color, 0.);\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"XslSRM","date":"1398432178","viewed":134,"name":"Kakish","username":"Orion","description":"For studying purposes","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""}}