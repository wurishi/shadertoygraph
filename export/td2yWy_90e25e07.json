{"ver":"0.1","info":{"id":"td2yWy","date":"1587657287","viewed":302,"name":"â™« Loss of Containment","username":"SomeGuy","description":"A random assortment of procedurally generated gelatinous micro- (or maybe nano-) organisms.\nI started out by playing around with blobby KIFS fractals, then got sucked into translucency and glow. At some point, things went a bit techno. Apologies for that.","likes":15,"published":1,"flags":64,"usePreview":0,"tags":["raymarching","music","lifeforms"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sf3Rn","filepath":"/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","previewfilepath":"/media/ap/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Mtj3DW","filepath":"https://soundcloud.com/ed_e_t_uk/ed-et-dtr-vs-mcp-biological-weapon","previewfilepath":"https://soundcloud.com/ed_e_t_uk/ed-et-dtr-vs-mcp-biological-weapon","type":"musicstream","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\nAuthor:  https://www.shadertoy.com/user/SomeGuy\nLicense: Creative Commons Attribution-NonCommercial 3.0 Unported License\n\t     https://creativecommons.org/licenses/by-nc/3.0\n\n\nThere was a power system alert last night during \nthe solar flux event. The logs for the containment\nfield generators show a series of short duration\npower fluctuations just after midnight.\n\nWhile heading to the generator array in order to \nvisually inspect it for damage, I noticed a small \npool of oily fluid near the exhaust vent of \ncontainment building three. The fluid was stinking,\na sour odour like putrid meat, overlayed with the \nsweet, pear-like fragrance of ethyl esters.\n\nI took a sample back to the lab for closer examination.\nBy the time I had walked the short distance back to \nbuilding one, the boro-silicate tube that I was \ntransporting the sample in had begun to soften and \nbecome slightly soft and gelatinous.\n\nI transferred a droplet of the sample to an observation\nslide, and loaded it into the high-frequency Higgs \nTunnelling Nanoscope (TM) for closer examination.\nThe Higgs has been glitchy recently, and I have \nstruggled to get stable images from it. Today the \npicture was stable enough for me to record the footage\nthat you are about to see.\n*/\n\n#define MS 50\t\t\t// max steps\n#define MD 30.          // max distance\n#define SD .001         // surface distance threshold\n#define EP .05          // offset for gradient normal\n\n#define GLITCH\t\t    // enable glitchy effects?\n#define WAIT_SYNC       // wait for sound to load before advancing time\n\n#define SND_BPM 150.         // beats per minute\n#define SND_BPS SND_BPM/60.  // beats per second\n#define SND_OFS 0.            // offset\n\n\nfloat PI = acos(-1.);   // PI!\n\nfloat o1=0., o2=0., o3=0.; // orgone accumulators\nvec3 oc1;                  // base color that gets used in multiple places\n\nfloat time;\n\n//----------------------------------------------\n// SDFs\n//----------------------------------------------\nfloat sph(vec3 p, float r) {return length(p)-r;}\t// sphere\n\nfloat cyl(vec2 p, float r) {return length(p)-r;}    // cylinder\n\n//----------------------------------------------\n// utility functions\n//----------------------------------------------\nvoid rot(inout vec2 p, float a) { // 2d rotation\n  \tfloat c=cos(a), s=sin(a);\n  \tp *= mat2(c,-s,s,c);\n}\n\nfloat rnd(float a) { // hash a single float\n  \treturn fract(sin(a * 58.9199) * 4533.9863);\n}\n\nfloat rnd(vec2 p) {// hash 2 floats\n    return fract(sin(dot(p, vec2(44.1885, 28.1643)))*4689.19966);\n}\n\nfloat curve(float a, float b) { // interpolation between random values (thanks Nusan)\n  \tfloat k = a / b;\n  \treturn mix(rnd(floor(k)), rnd(floor(k)+1.), pow(smoothstep(0.,1.,fract(k)), 12.));\n}\n\nfloat smin(float a, float b, float h) { // smooth minimun\n  \tfloat k = clamp((a-b)/h*.5+.5,0.,1.);\n  \treturn mix(a,b,k)-h*k*(1.-k);\n}\n\n//----------------------------------------------\n// Creature definition\n//----------------------------------------------\nstruct thing {\n    float rn;\n    float blobpos;\n    float blobsize;\n    int reps;\n    vec2 offs;\n    vec3 rots;\n    float scale;\n    float squishy;\n    float tt;\n};\n\n//----------------------------------------------\n// The scene\n//----------------------------------------------    \nfloat prim(vec3 p, thing th) { // The creature building block: a blob and a tentacle\n  \tp.z += sin(p.y+th.tt*4.)*.2; // some time based oscillation\n  \tp.x += cos(p.z+th.tt*3.)*.2;\n  \tp.y += cos(p.x+p.z+th.tt*3.5)*.1;\n  \n    // noise lookup from texture\n  \tvec3 np = p / 5.;\n    float n = (texture(iChannel0, np.xy).r + texture(iChannel0, np.xz).r + texture(iChannel0, np.yz).r)/3.;\n  \tn = n * .1 - .05;\n    \n    float a = cyl(p.xz,cos(p.y/4.)*.1+n);               // main tentacle piece\n  \ta = smin(a, sph(p, 9.), -3.);                       // clamp it, trying to keep the end pointy\n  \n  \tfloat b = sph(p-vec3(0.,th.blobpos,0.),th.blobsize+n);  // spherical blob part \n    b = abs(b) - .1 * th.blobsize;                          // onion trick to make it hollow\n    \n    float d = smin(a, b, th.squishy);  // merge the blob and the tentacle together\n    \n    d *= .8; // avoid artifacts due to distorted geometry\n    \n    o1 += .1 / (.1 + a*a*10.); // glow from tentacle\n    o2 += .1 / (.1 + b*b*10.); // glow from blob\n\n    return d;\n}\n\n    \nfloat map(vec3 p) {\n  \n    // set up a random creature\n  \tthing th;\n    th.tt = time / 2.;                                // creature pulsates at this rate\n    th.rn = rnd(floor(time / 16.));                   // pick a new creature every 16 beats\n    if(time > 224. && time < 300.) th.rn = rnd(228.); // but keep it fixed during the breakdown\n    if(time > 300.) th.rn = rnd(floor(time / 4.));    // then pick a creature every 4 beats when we come back up\n    \n    th.blobpos = mix(0.,3., th.rn);                   // position of the blob on the tentacle\n    th.blobsize=mix(.3, 2., th.rn);                   // size of the blob\n    \n    // number of fractal repetitions - between 2 and 4 for the first part of the tune,\n    // but more complex (between 3 and 4) following the breakdown\n    th.reps = time < 16. ? 0 : time > 300. ? int(mix(3.,4.,th.rn+.1)) : int(mix(2.,4.,th.rn+.1));\n    th.offs = mix(vec2(.4), vec2(.8), th.rn); // position offset\n    \n    \n    th.rots = vec3(// rotations around x,y and z axes\n        mix(-PI/2.,PI/2.,rnd(th.rn+1.)), \n        mix(-PI,PI, rnd(th.rn+2.)), \n        mix(-PI/2.,-PI/2., rnd(th.rn+3.)));\n    \n    th.scale = mix(1.1, 1.5, th.rn);      // scale reduction per iteration\n    th.squishy=mix(.1, 1.5, th.rn);       // squishiness (tightness of the smooth minimum function)\n    \n    oc1 = vec3(.1,.9,.1); \t\t\t \t  // base color for tentacles\n    rot(oc1.xy, mix(-PI/2.,PI/2.,th.rn)); // modify it based on random id\n    oc1 = max(vec3(0.), oc1);             // don't let it go negative\n    \n    if (time < 224. || time >300.)        // oscillate rotation except during the breakdown\n  \t\trot(p.xz, sin(time));\n      \n  \tfloat d = 9999.;                      // distance to the creature\n  \tvec4 fp = vec4(p,1);                  // trick to track scale during fractal iterations (stole it from Evvvvil)\n  \tfloat s = 1.;                         // initial scale\n  \tfor(int i=0; i<5; ++i) {              // using a fixed loop size but bailing early for older WebGL compatability\n        if (i == th.reps) break;\n    \tfp *= s;\t\t\t\t\t\t  // apply the scale\n    \ts *= th.scale;                    // change the scale to be used next iteration\n    \n    \tfp.xz = abs(fp.xz) - th.offs;     // absolute symmetry with offset\n    \trot(fp.yz, th.rots.x*s);          // apply the rotations\n        rot(fp.xz, th.rots.y*s);\n    \trot(fp.xy, th.rots.z*s);\n    \n    \td = min(d, (prim(fp.xyz, th) / fp.w)); // make a tentacle\n  \t}\n    \n  \td = th.reps == 0 ? prim(fp.xyz, th) : d; // draw a single tentacle if the loop was skipped\n   \n    float sw = mix(d-.2, d-10., pow(fract(time / 4.),2.));  // shockwave position\n    o3 += (.1 / (.1 + sw * sw * 1000.));                         // shockwave glow\n    \n  \treturn d;\n}\n\n\n//----------------------------------------------\n// The marching machinery \n//----------------------------------------------\nvec3 normal(vec3 p) { // gradient normal\n  \tvec2 off = vec2(EP,0.);\n  \treturn normalize(map(p) - vec3(map(p-off.xyy), map(p-off.yxy), map(p-off.yyx)));\n}\n\n\nvec3 march(vec3 ro, vec3 rd) {\n    // main ray marching loop\n  \tfloat dd=0.1;\n  \tvec3 col=vec3(0), // color\n         p=ro+rd*dd;  // position\n  \tfloat side = sign(map(p)); // Nusan's translucency trick\n    float att = 1.;   // attenuation\n    for(int i=0; i<MS; ++i) {\n    \tfloat d = map(p);\n    \td *= side;\n        float atten = att;\n        float diff = 0.; // base 'surface' color\n        float frez = 0.; // freznel\n        if(d < SD) {\n            // close enough to an object to notice\n      \t\tvec3 n = normal(p)*side;\n            side = -side;\n            rd = refract(rd, n, 1. + .05*side); // do some refraction\n      \t\td = .01; // step away for next iteration\n            att *= .4;\n            diff = .1;\n            frez = .2*pow(max(.5, 1.-dot(n, -rd)), 3.);\n    \t}\n    \tif(dd > MD) { // falling of the edge of the world\n      \t\tdd = MD;\n      \t\tbreak;\n    \t}\n        \n        \n        // color based on the accumulated orgones\n        // oc1 is random for each creature. \n        // oc2 and oc3 are calculated from oc1\n    \tvec3 oc2 = 1. - oc1;\n    \tvec3 oc3 = normalize(o1 * oc1 + o2 * oc2);\n    \n        float dst = exp(-.0001*dd*dd*dd); // some fog\n     \n        // apply the colors and surface\n        #define c(x,y) x*atten*dst*y\n        vec3 c1 = oc1*o1, c2 = oc2*o2, c3=oc3*o3;\n    \tcol += c(c1, diff*frez) +  c(c1, .01); \n    \tcol += c(c2, diff*frez) + c(c2, .001);\n    \tcol += c(c3, .1) * float(time > 16. && (time < 227.|| time >288.)); // no shock wave initially or during breakdown \n        \n        // distance and pos for next iteration\n    \tp += rd * d;\n    \tdd += d;\n  \t}\n  \n  \treturn col;\n}\n\n\nvec3 raydir(vec3 ro, vec3 la, vec2 uv) {\n\t// construct a ray\n    vec3 cz = normalize(la-ro),\n  \tcx = normalize(cross(cz, vec3(0,1,0))),\n  \tcy=normalize(cross(cx,cz));\n  \treturn normalize(cx*uv.x + cy*uv.y + cz);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t// Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy - 0.5;\n    uv /= vec2(iResolution.y / iResolution.x, 1);\n\n    time = (iTime * SND_BPS) - SND_OFS; // convert time to beats\n    \n#ifdef WAIT_SYNC\n    // don't advance the timeline if the soundtrack hasn't loaded.\n    // Doing a texture lookup for this is a bit expensive, but I \n    // can't figure out another way to check for this\n    if (texture( iChannel1, vec2(.1, 0.) ).x == 0.)\n        time = mod(time, 16.);\n#endif\n    \n    // camera position\n    vec3 cam;\n    if (time > 224. && time <300.) { // simple rotate during the breakdown\n        //cam = vec3(0.,2., 5. * sin(time / 4.));\n        cam = vec3(1.,2.,5.);\n        rot(cam.xz, time/4.);\n    }\n    else { // otherwise, do some random zooming and rotating\n        cam = vec3(\n        \tmix(-4.,4.,curve(time,3.)),\n        \tmix(-4.,4., curve(time-3.,3.)),\n        \tmix(3.,8.,curve(time+2.,3.))\n    \t)*2.5;\n    }\n\t\n    vec2 ouv = uv;\n#ifdef GLITCH\n    float glitch = curve(time,.5);\n    glitch = smoothstep(.9, 1., glitch);\n    uv.x += sin(uv.y*100.+time*glitch*100.)*glitch * max(0., .2-uv.y*uv.y); // sin wave glitch\n    uv += mix(vec2(0), uv * (rnd(uv + time)-.5), smoothstep(.95, 1., curve(time,.1))*.5); // noisy fuzz glitch\n#endif\n    \n    // set up the ray\n\tvec3 ro=cam, la=vec3(0), rd=raydir(ro,la,uv);\n    \n    // clear to black\n  \tvec3 col = vec3(0.);\n    \n    // raymarch\n  \tcol += march(ro, rd);\n  \n    // vignette\n    col *= 1. - length(uv);\n    \n    // exposure\n    col = vec3(1.) - exp(-col*1.5);\n       \n\t// gamma\n    col = pow(col, vec3(1./2.2));\n\n    // final color\n    fragColor = vec4(col,1.0);\n}\n\n","name":"Image","description":"","type":"image"}]}