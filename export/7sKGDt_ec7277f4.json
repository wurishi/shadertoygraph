{"ver":"0.1","info":{"id":"7sKGDt","date":"1633297598","viewed":200,"name":"sphere inversion ray marching","username":"Bananaft","description":"Ray marching away from the surface the regular way (blue), an after preforming sphere inversion near the ray origin (red) with its result projected back to regular space (small blue dot)\nFull story:\nhttps://twitter.com/Bananaft/status/1444768058711629824","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["testsphereinversion"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n\nfloat distance_multiplyer = 1.0;\n\nvec3 circle_invert(vec3 p) {\n    return p/dot(p,p);\n}\n\nfloat fix_dist(vec3 p, float d) {\n\treturn dot(p,p)*d/(1.+length(p)*abs(d));\n}\n\nvec4 invese(vec3 p, vec3 c)\n{\n    //p-=c;\n    float r2 = dot(p,p);\n    float k = (1.0f)/(r2);\n    p*=k;\n    p+=c;\n    return vec4(p,k);\n}\n\nfloat scene(vec3 p, float k)\n{\n    //*\n    float d = p.y + 2.;\n    d = min(d,(-2.0 + length(p)));\n    d = min(d,(-1.2 + length(p-vec3(-2.,1.5,0.))));\n    return d;\n    /*/\n\n    p *= 0.5f;\n    vec4 q = vec4(p - 1.0f, 1);\n    for(int i = 0; i < 11; i++) {\n      q.xyz = abs(q.xyz + vec3(1.0f)) - 1.0f;\n      q /= clamp(dot(vec3(q.xyz), vec3(q.xyz)), 0.12f, 1.0f);\n      q *= 1.837;// + p.y*0.8;\n    }\n    float dist = (length(vec2(q.xz)) - 2.2f)/q.w * 2.f;\n    \n    return dist;\n    //*/\n}\n\nfloat scene(vec3 p)\n{\n    return scene(p,1.0);\n}\n\nfloat iScene1(vec3 p, vec3 c)\n{\n    vec4 ip = invese(p,c);\n    float dist = scene(ip.xyz,ip.w);\n    dist /= ip.w;\n    return dist;\n}\n\n//knighty : https://www.shadertoy.com/view/WdffDs\nvec3 proj(vec3 p) {\n    return p/dot(p,p);\n}\n\nfloat iScene2(vec3 p, vec3 c)\n{\n\n    float r=length(p);\n\tfloat r2=r*r;\n\tvec3 p2=(1./r2)*p;\n    float d = scene(p2+c);\n\td = r2*d/(1.+r*abs(d));\n/*    \n    for (int i = 0; i < 5; i++) {\n    \tp2 = (proj(p-normalize(p)*d) + proj(p+normalize(p)*d))/2.;\n\t\td = scene(p2+c);\n\t\td = r2*d/(1.+r*abs(d));\n       }\n//*/ \n\treturn d;\n}\n\nfloat iScene3(vec3 p, vec3 c)\n{\n    float k = dot(p,p);\n    p /= k;\n    p += c;\n    \n    float d = scene(p);\n    \n    return d * k;\n}\n\nfloat iScene(vec3 p, vec3 c)\n{\n    //return iScene1( p, c);\n    return iScene2( p, c);\n    //return iScene1( p, c);\n}\n\nvec3 calcNormal( in vec3 pos , float size)\n{\n\tvec3 eps = vec3( size,  0.0, 0.0 );\n\n\tfloat x1 = scene(pos+eps.xyy);\n\tfloat x2 = scene(pos-eps.xyy);\n\tfloat y1 = scene(pos+eps.yxy);\n\tfloat y2 = scene(pos-eps.yxy);\n\tfloat z1 = scene(pos+eps.yyx);\n\tfloat z2 = scene(pos-eps.yyx);\n\n\treturn  vec3(x1 - x2, y1 - y2, z1 - z2);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv.y /= iResolution.x/iResolution.y;\n    uv *= 10.;\n    uv += vec2(-5.,-2.5);\n    vec3 pos = vec3(uv.x,uv.y,0.);\n    \n    vec2 m = iMouse.xy;\n    m /=iResolution.xy;\n    m.y /= iResolution.x/iResolution.y;\n    m *= 10.;\n    m += vec2(-5.,-2.5);\n    vec3 mc = vec3(m.x,m.y,0.);\n    \n    \n        \n    float dist = scene(pos,1.0);\n    float idist = iScene(pos, mc);\n    vec3 normal = normalize(calcNormal(mc,0.001));\n    \n    vec3 col = vec3(1.0);\n    if(dist<0.) col *= vec3(0.6,0.6,1.0);\n    if(idist<0.) col *= vec3(0.6,1.0,0.6);\n    col *= 0.5+0.5*fract(idist);\n\n\n    vec4 ipos = invese(pos,mc);\n    \n    vec3 ro2 = mc + normal * 0.2;\n    if(length(ro2 - pos.xyz)<0.1) col = vec3(1.,0.,0.);\n    float td = 5.;\n    float td2 = 0.;\n    for (int i = 0; i<5 ; i++)\n    {\n        float d = distance_multiplyer * iScene(td*normal,mc);\n        if (length(td*normal-pos.xyz)<d) col *= vec3(1.0,0.6,0.6);\n        td-=d;\n        if(td<0.)\n        {\n            td = 0.;\n            break;\n        }\n        \n        float d2 = distance_multiplyer * scene(ro2 + td2 * normal);\n        if (length(ro2+td2*normal-pos.xyz)<d2) col *= vec3(0.8,0.6,1.0);\n        td2 += d2;\n    }\n    vec4 result = invese(td*normal,mc);\n    if(length(result.xyz - pos.xyz)<0.1) col = vec3(0.,0.,1.);\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}