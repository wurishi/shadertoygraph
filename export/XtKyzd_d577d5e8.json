{"ver":"0.1","info":{"id":"XtKyzd","date":"1537392080","viewed":138,"name":"Deterministic Fractals","username":"ptrgags","description":"Trying to use the deterministic algorithm described in Fractals Everywhere and SuperFractals, both by Michael F. Barnsley.\n\nThis shader includes 3 different fractal examples. Select one in Buffer A.","likes":8,"published":1,"flags":32,"usePreview":0,"tags":["fractals","barnsley","inverse"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/**\n * Implement the deterministic method of generating\n * fractals\n *\n * Normally, this is done by taking a set of points\n * from R^2 (let's call it A0) and performing:\n * An + 1) = union(f1(An), f2(An), ... fN(An))\n *          = F(An)\n *\n * where the functions are of the form fi : R^2 -> R^2\n *\n * However, on the GPU we need a couple changes:\n * 1. Since the GPU we have the output point, not the input\n *    point, we need to use the inverse F^-1(An)\n * 2. Since this involves keeping track of the past\n *    iteration, we need to use a buffer\n * 3. Since buffer textures are of finite size, any IFS\n *    used should map the unit square into itself.\n *\n * See the Common buffer for the IFSs\n * See Buffer A for the iteration control.\n */\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   \t// Center the unit square on the screen\n    float extra = iResolution.x - iResolution.y; \n    vec2 offset = vec2(extra / 2.0, 0.0);\n    vec2 uv = (fragCoord - offset)/iResolution.y;\n    \n    // We want to mask out the backgound\n    float outside_left = 1.0 - step(0.0, uv.x);\n    float outside_right = step(1.0, uv.x);\n    float outside_square = max(outside_left, outside_right);\n    \n    // Display the fractal\n    fragColor = texture(iChannel0, uv);\n    fragColor = mix(fragColor, vec4(0.0), outside_square);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define PI 3.1415\n\nmat2 scale(vec2 s) {\n    return mat2(\n        s.x, 0.0, \n        0.0, s.y\n    );\n}\n\nmat2 scale(float s) {\n    return scale(vec2(s));\n}\n\n// Rotation matrix. Remember,\n// GLSL is column major, not row major!\nmat2 rotate(float theta) {\n    return mat2(\n        cos(theta), sin(theta),\n\t\t-sin(theta), cos(theta)\n    );\n}\n \n/**\n * A similtude is a transformation of the form\n * T(x) = A * x + b\n *\n * so T^-1(x) = A^-1(x - b)\n */\nvec2 inv_affine(vec2 x, mat2 A, vec2 b) {\n    return inverse(A) * (x - b);\n}\n\n/**\n * Sierpinski triangle IFS is defined by\n * F(x, y) = union(f1(x, y), f2(x, y), f3(x, y))\n * f1(x, y) = 0.5 * (x, y) + (0.0, 0.5)\n * f2(x, y) = 0.5 * (x, y) + (0.0, 0.0)\n * f3(x, y) = 0.5 * (x, y) + (0.5, 0.0)\n *\n * This function is the inverse F^-1(x, y).\n * This is needed since we are using inverse color\n * lookups.\n */\nvec2 sierpinski_inv(vec2 uv) {\n    mat2 s = scale(0.5);\n    vec2 t;\n    \n    // xform 1\n    if (uv.x < 0.5 && uv.y > 0.5)\n        t = vec2(0.0, 0.5);\n    // xform 2\n    else if (uv.x < 0.5 && uv.y < 0.5)\n        t = vec2(0.0, 0.0);\n   \t// xform 3\n    else if (uv.x > 0.5 && uv.y < 0.5)\n        t = vec2(0.5, 0.0);\n    // don't do anything with the top right hole.\n    else\n        return vec2(-1.0);\n    \n    return inv_affine(uv, s, t);\n}\n\nbool between(float x, float a, float b) {\n    return a <= x && x < b;\n}\n\n/**\n * I wanted to see how well the inverse\n * works when the domains overlap. This should give a picture\n * where the first function that matches is on top.\n */\nvec2 overlap_inv(vec2 uv) {\n    mat2 s = scale(0.5);\n    mat2 r = rotate(0.0);\n    vec2 t;\n    \n    // Square on top shrinks towards center and rotates 180 degrees\n    if (between(uv.x, 0.25, 0.75) && between(uv.y, 0.25, 0.75)) {\n        r = rotate(PI);\n        t = vec2(0.75, 0.75);\n    // Spiral towards top left corner\n    } else if (uv.x < 0.5 && uv.y > 0.5) {\n        r = rotate(-PI / 2.0);\n        t = vec2(0.0, 1.0);\n    // Spiral towards bottomm right corner\n    } else if (uv.x > 0.5 && uv.y < 0.5) {\n        r = rotate(PI / 2.0);\n        t = vec2(1.0, 0.0);\n    // Top right corner shrinks faster and rotates upside-down\n    } else if (uv.x > 0.75 && uv.y > 0.75) {\n        s = scale(0.25);\n        r = rotate(PI);\n        t = vec2(1.0, 1.0);\n    } else\n        return vec2(-1.0);\n    \n    return inv_affine(uv, r * s, t);\n        \n}\n\n/**\n * This fractal divide the unit square into four congruent\n * segments like this.\n * The arrows show which way is up. No flipping\n * happens here\n *\n * |-λ--|------μ-----| (1, 1)\n *  _________________  ___\n * |    |            |  |\n * | 1  |   ->   2   |  λ\n * |    |____________| _|_   Note: μ = 1 - λ\n * | ^  |       |    |  |\n * | |  |       |  | |  |     \n * |    |       |  v |  |\n * |____|_______|    |  μ\n * |            |  3 |  |\n * | 4  <-      |    |  |\n * |____________|____| _|_\n * (0, 0)\n *\n * λ is a number in the range [0, 1.0].\n * \n *\n * Again, this is the inverse transform.\n */\nvec2 donut_inv(vec2 uv, float lambda) {\n    // let mu = 1 - lambda for brevity\n    float mu = 1.0 - lambda;\n    \n    // Translate, rotate and scale components\n    mat2 s = scale(vec2(lambda, mu));\n    mat2 r;\n    vec2 t;\n    \n    // xform 1\n    if (uv.x < lambda && uv.y > lambda) {\n        r = rotate(0.0);\n        t = vec2(0.0, lambda);\n\t// xform 2\n    } else if (uv.x > lambda && uv.y > mu) {\n        r = rotate(-PI / 2.0);\n        t = vec2(lambda, 1.0);\n    // xform 3\n    } else if (uv.x > mu && uv.y < mu) {\n        r = rotate(-PI);\n        t = vec2(1.0, mu);\n    // xform 4\n    } else if (uv.x < mu && uv.y < lambda) {\n        r = rotate(-3.0 * PI / 2.0);\n        t = vec2(mu, 0.0);\n    // Don't include the hole in the center of the donut\n    } else\n        return vec2(-1.0);\n    \n    // Apply the affine transform in reverse.\n    return inv_affine(uv, r * s, t);\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Bigger = slower iteration for easy viewing\n#define FRAMES_PER_ITER 100\n\n// Limit the depth of the iteration. The bigger\n// the number, the more detail, but too high and\n// you get a dark image because the detail is smaller\n// than the size of a pixel.\n#define MAX_ITERS 10\n\n// See donut_inv() in the common buffer. This is\n// the defining measurement for the fractal shape.\n#define DONUT_LAMBDA 0.4\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // Compute the next iteration by using the inverse xform\n    // Uncomment to pick a different IFS <<<<<<<<<<<<<<<<<<<<<<<<<\n    //vec2 new_uv = sierpinski_inv(uv);\n    //vec2 new_uv = overlap_inv(uv);\n    vec2 new_uv = donut_inv(uv, DONUT_LAMBDA);\n    \n    // Pick a color from last iteration, but at different\n    // coordinats.\n    vec4 new_color = texture(iChannel0, new_uv);\n    \n    // Fix \"holes\" in the IFS' domain by painting\n    // them black. The IFSs return (-1, -1) where the\n    // inverse is not defined.\n    float is_hole = float(new_uv == vec2(-1.0));\n    new_color = mix(new_color, vec4(0.0), is_hole);\n    \n    // Also grab the color from this pixel\n    vec4 old_color = texture(iChannel0, uv);\n    \n    // Slow down the iteration and limit the number\n    // of iterations for better viewing experience\n    float timer_up = float(iFrame % FRAMES_PER_ITER == 0);\n    float in_progress = float(iFrame / FRAMES_PER_ITER < MAX_ITERS);\n    vec4 fractal_color = mix(old_color, new_color, in_progress * timer_up);\n    \n    // Finally, during the first second, paint some inital image.\n    float first_sec = float(iTime < 1.0);\n    vec4 initial_color = vec4(uv,  0.0, 1.0);\n    fragColor = mix(fractal_color, initial_color, first_sec);\n}","name":"Buffer A","description":"","type":"buffer"}]}