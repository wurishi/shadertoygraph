{"ver":"0.1","info":{"id":"NlB3WD","date":"1623876819","viewed":150,"name":"Click-me drop ripples","username":"denosya","description":"Click-me !","likes":2,"published":1,"flags":32,"usePreview":0,"tags":["wave","drop"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float WAVE_SPEED = 0.60;\nconst float WAVE_HEIGHT = 0.005;\n\n\nWave waves[10];\n\nvoid readWaves()\n{\n    for(int i=0; i<10; i++) {\n        vec4 c = texelFetch(iChannel0, ivec2(0, i), 0);\n        waves[i] = Wave(c.xy, c.z*1000.);\n    }\n}\n\nfloat f(float x) {\n\n    float attenuate = 1. / (1. + pow(15.*x, 2.0));\n    return cos(40.*x) * attenuate * WAVE_HEIGHT;// * impulsion();\n}\n\nfloat _p(vec2 p) {\n\n    float h = 0.;\n\n    for(int i=0; i<10; i++) {\n    \n        Wave wave = waves[i];\n    \n        if(wave.time > 0.0) {\n    \n            vec2 waveOrigin = wave.origin - 0.5;\n            waveOrigin.x *= iResolution.x / iResolution.y;\n\n            float dt = iTime - wave.time;\n            float pos = dt * WAVE_SPEED;\n            float dist = length(p - waveOrigin);\n            float fade = max(0., (WAVE_DURATION*.5-dt)/(WAVE_DURATION*0.5));  \n            \n\n            h += f(dist - pos) * fade;\n        }\n    }\n    \n    return h;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy - 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    readWaves();\n    \n    vec2 eps = vec2(0.000001, 0.);\n    float dhx = _p(uv + eps.xy) - _p(uv - eps.xy);\n    float dhy = _p(uv + eps.yx) - _p(uv - eps.yx);    \n    \n    vec3 normal = normalize(vec3(dhx, dhy, eps.x*2.));    \n    \n    \n    vec3 light = normalize(vec3(1.0));\n    float diffuse = max(dot(light, normal),-1.);\n    \n    \n    fragColor = vec4(0.33 + diffuse);\n    \n  //  fragColor=texture(iChannel0, fragCoord/iResolution.xy*0.05);\n    \n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"Wave waves[10];\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float init = texelFetch(iChannel0, ivec2(0, 11), 0).x;\n    int firstAvail = -1;    \n\n    for(int i=0; i<10; i++) {\n        vec4 c = texelFetch(iChannel0, ivec2(0, i), 0);\n        \n        waves[i] = Wave(c.xy, c.z);\n        \n        float time = c.z * 1000.;\n        \n        if(iTime - time > WAVE_DURATION) {\n            waves[i].time = 0.;\n        }\n        \n        if(waves[i].time == 0.) {\n            firstAvail = i;\n        }\n    }\n\n    if(firstAvail>-1) {\n        if(iMouse.w>0.) {\n            vec2 mousePos = iMouse.xy/iResolution.xy;\n            waves[firstAvail].origin = mousePos;\n            waves[firstAvail].time = iTime*0.001;\n        }\n        else {\n            if(init == 0.0) {\n                waves[firstAvail].origin = vec2(0.5);\n                waves[firstAvail].time = 0.0001;\n            }\n        }\n    }\n\n    if(fragCoord.y<10.) {\n        Wave wave = waves[int(fragCoord.y)];\n        fragColor = vec4(wave.origin.x, wave.origin.y, wave.time, 0.0);\n    }\n    \n    if(int(fragCoord.x) == 0 && int(fragCoord.y) == 11) {\n        fragColor = vec4(1, 0, 0, 0);\n    }    \n    \n    \n }\n \n \n ","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"struct Wave {\n    vec2 origin;\n    float time;\n};\n\nconst float WAVE_DURATION = 3.;\n","name":"Common","description":"","type":"common"}]}