{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[{"channel":0,"type":"video","id":"Xdf3Rn","filepath":"/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm","sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"}}],"code":"/*\n * Copyright 2020 Simon Green (@simesgreen)\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     https://apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nconst int _Steps = 64;\nconst vec3 lightDir = vec3(0.577, 0.577, 0.577);\n\n// transforms\nvec3 rotateX(vec3 p, float a)\n{\n    float sa = sin(a);\n    float ca = cos(a);\n    vec3 r;\n    r.x = p.x;\n    r.y = ca*p.y - sa*p.z;\n    r.z = sa*p.y + ca*p.z;\n    return r;\n}\n\nvec3 rotateY(vec3 p, float a)\n{\n    float sa = sin(a);\n    float ca = cos(a);\n    vec3 r;\n    r.x = ca*p.x + sa*p.z;\n    r.y = p.y;\n    r.z = -sa*p.x + ca*p.z;\n    return r;\n}\n\nbool\nintersectBox(vec3 ro, vec3 rd, vec3 boxmin, vec3 boxmax, out float tnear, out float tfar)\n{\n\t// compute intersection of ray with all six bbox planes\n\tvec3 invR = 1.0 / rd;\n\tvec3 tbot = invR * (boxmin - ro);\n\tvec3 ttop = invR * (boxmax - ro);\n\t// re-order intersections to find smallest and largest on each axis\n\tvec3 tmin = min (ttop, tbot);\n\tvec3 tmax = max (ttop, tbot);\n\t// find the largest tmin and the smallest tmax\n\tvec2 t0 = max (tmin.xx, tmin.yz);\n\ttnear = max (t0.x, t0.y);\n\tt0 = min (tmax.xx, tmax.yz);\n\ttfar = min (t0.x, t0.y);\n\t// check for hit\n\tbool hit;\n\tif ((tnear > tfar)) \n\t\thit = false;\n\telse\n\t\thit = true;\n\treturn hit;\n}\n\nfloat luminance(sampler2D tex, vec2 uv)\n{\n\tvec3 c = textureLod(tex, uv, 0.0).xyz;\n\treturn dot(c, vec3(0.33, 0.33, 0.33));\n}\n\nvec2 gradient(sampler2D tex, vec2 uv, vec2 texelSize)\n{\n\tfloat h = luminance(tex, uv);\n\tfloat hx = luminance(tex, uv + texelSize*vec2(1.0, 0.0));\t\n\tfloat hy = luminance(tex, uv + texelSize*vec2(0.0, 1.0));\n\treturn vec2(hx - h, hy - h);\n}\n\nvec2 worldToTex(vec3 p)\n{\n\tvec2 uv = p.xz*0.5+0.5;\n\tuv.y = 1.0 - uv.y;\n\treturn uv;\n}\n\nfloat heightField(vec3 p)\n{\n\t//return sin(p.x*4.0)*sin(p.z*4.0);\n\t//return luminance(iChannel0, p.xz*0.5+0.5)*2.0-1.0;\n\treturn luminance(iChannel0, worldToTex(p))*0.5;\n}\n\nbool traceHeightField(vec3 ro, vec3 rayStep, out vec3 hitPos)\n{\n\tvec3 p = ro;\n\tbool hit = false;\n\tfloat pH = 0.0;\n\tvec3 pP = p;\n\tfor(int i=0; i<_Steps; i++) {\n\t\tfloat h = heightField(p);\n\t\tif ((p.y < h) && !hit) {\n\t\t\thit = true;\n\t\t\t//hitPos = p;\n\t\t\t// interpolate based on height\n            hitPos = mix(pP, p, (pH - pP.y) / ((p.y - pP.y) - (h - pH)));\n\t\t}\n\t\tpH = h;\n\t\tpP = p;\n\t\tp += rayStep;\n\t}\n\treturn hit;\n}\n\nvec3 background(vec3 rd)\n{\n     return mix(vec3(1.0, 1.0, 1.0), vec3(0.0, 0.5, 1.0), abs(rd.y));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 pixel = (fragCoord.xy / iResolution.xy)*2.0-1.0;\n\n    // compute ray origin and direction\n    float asp = iResolution.x / iResolution.y;\n    vec3 rd = normalize(vec3(asp*pixel.x, pixel.y, -2.0));\n    vec3 ro = vec3(0.0, 0.0, 2.0);\n\t\t\n\tvec2 mouse = iMouse.xy / iResolution.xy;\n\n\t// rotate view\n    float ax = -0.7;\n\tif (iMouse.x > 0.0) {\n    \tax = -(1.0 - mouse.y)*2.0 - 1.0;\n\t}\n    rd = rotateX(rd, ax);\n    ro = rotateX(ro, ax);\n\t\t\n\tfloat ay = sin(iTime*0.2);\n    rd = rotateY(rd, ay);\n    ro = rotateY(ro, ay);\n\t\n\t// intersect with bounding box\n    bool hit;\t\n\tconst vec3 boxMin = vec3(-1.0, -0.01, -1.0);\n\tconst vec3 boxMax = vec3(1.0, 0.5, 1.0);\n\tfloat tnear, tfar;\n\thit = intersectBox(ro, rd, boxMin, boxMax, tnear, tfar);\n\n\ttnear -= 0.0001;\n\tvec3 pnear = ro + rd*tnear;\n    vec3 pfar = ro + rd*tfar;\n\t\n    float stepSize = length(pfar - pnear) / float(_Steps);\n\t\n    vec3 rgb = background(rd);\n    if(hit)\n    {\n    \t// intersect with heightfield\n\t\tro = pnear;\n\t\tvec3 hitPos;\n\t\thit = traceHeightField(ro, rd*stepSize, hitPos);\n\t\tif (hit) {\n\t\t\t//rgb = hitPos*0.5+0.5;\n\t\t\tvec2 uv = worldToTex(hitPos);\n\t\t\trgb = texture(iChannel0, uv).xyz;\n\t\t\t//vec2 g = gradient(iChannel0, uv, vec2(1.0) / iResolution.xy);\n\t\t\t//vec3 n = normalize(vec3(g.x, 0.01, g.y));\n\t\t\t//rgb = n*0.5+0.5;\n#if 0\n\t\t\t// shadows\n\t\t\thitPos += vec3(0.0, 0.01, 0.0);\n\t\t\tbool shadow = traceHeightField(hitPos, lightDir*0.01, hitPos);\n\t\t\tif (shadow) {\n\t\t\t\trgb *= 0.75;\n\t\t\t}\n#endif\t\t\t\n\t\t}\n     }\n\n    fragColor=vec4(rgb, 1.0);\n\t//fragColor = vec4(vec3(tfar - tnear)*0.2, 1.0);\n}\n","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"Xss3zr","date":"1361796736","viewed":1931,"name":"video heightfield","username":"simesgreen","description":"raycasting a heightfield defined by luminance of video stream","likes":61,"published":1,"flags":0,"usePreview":0,"tags":["video","heightfield"],"hasliked":0,"parentid":"","parentname":""}}