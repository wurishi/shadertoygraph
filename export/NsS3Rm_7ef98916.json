{"ver":"0.1","info":{"id":"NsS3Rm","date":"1617112097","viewed":149,"name":"space rainbows","username":"tripzilch","description":"It was just a color out of space ...","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["space","rainbows"],"hasliked":0,"parentid":"ssX3Dl","parentname":"raaaaainbows"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define TAU 6.283185307179586\n#define phase3 vec3(0.0, 2.0943951023931953, 4.1887902047863905)\n#define gamma vec3(2.2)\n#define igamma vec3(0.454545)\n\nvec3 florp(float a, float p) {\n    // this one maps the color\n    // a = brightness\n    // p = mushrooms\n    float b = clamp(2.*a - 1.,0.,1.); b *= b; b *= b; b *= b;\n    vec3 res = pow(vec3(2.*a - a * a, a * a, b), gamma); // sRGB stands for stupid RGB\n    vec3 f = (1. + sin(phase3 + p)) * 0.333333333;\n    return res.bgr * f.x + res.rbg * f.y + res.rgb * f.z;\n}\n\nfloat onk(vec2 uv, float t) {\n    // this one makes a wobbly function over t, ranged -1 .. 1\n    float bx = uv.x * -3.13 + 2.04 * sin(uv.y * -2.3 + 1.3 * t) - 0.5* t;\n    float by = uv.y * 4.17 - 1.73 * sin(uv.x * 2.5 - 0.7 * t) + 0.9 * t;\n    return .5 * (sin(bx) + sin(by));\n}\n\nfloat unk(vec2 uv, float t) {\n    // this one ALSO makes a wobbly function over t, ranged 0 .. 1\n    float cx = uv.x * 2.23 - 3.33 * sin(uv.y * -1.3 + 0.3 * t) - 0.4* t;\n    float cy = uv.y * -1.41 + 3.15 * sin(uv.x * 1.5 + 0.4 * t) + 0.1 * t;\n    return .5 + .25 * (sin(cx) + sin(cy));\n}\n\nconst vec3 H3 = vec3(0.5497004779019702, 0.671043606703789, 0.8191725133961644);\nfloat space(vec2 uv, float t,float seed) {\n    uv += vec2(271., 497.) * seed; // space is far--it's not\n    uv.x += t * 15.;\n    vec2 ij = floor(uv), fg = uv - ij - .5;\n    float idx = 57. * ij.y + ij.x + seed + .5;\n    vec3 cr = fract(777. * sin(555. * fract(idx * H3)));\n    fg += (cr.xy - .5) * .8;\n    fg *= 5.;\n    return smoothstep(.5, .45, length(fg)) * step(.8, cr.z);\n}\n\nconst vec2 cos_plz = vec2(0, 0.25); // actually forgot to multiply by TAU, but now it is what it is\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Normalized pixel coordinates (from 0 to 1) (??)\n    vec2 aspect = iResolution.xy / iResolution.y;\n    vec2 uv = (fragCoord.xy / iResolution.xy - 0.5) * aspect;\n    uv *= 1.2; // scale\n    float t = iTime * 0.2; // global speed\n    vec2 ee = vec2(4.35, -5.33); // bonus numbers\n    float c = unk(uv * vec2(0.43, -0.53), t); // weirdness amount\n    vec2 trun = sin(cos_plz + c * 8. + t * 0.61); \n    vec2 wp = uv + trun;\n    vec2 wq = uv - trun;\n    float lava = 3. * onk(wp, t) * (1. + onk((wq + ee * c) * 0.618, t * .7)); // left as exercise for the reader\n    float hi = 1.000420 + .7 * c; // how high we are \n    float a = smoothstep(-1., hi, lava); // brightness\n    float hole = smoothstep(hi + .02, hi, lava); // no more brightness\n    hole = max(0., hole - .4 * smoothstep(0., -1., lava));\n\n    float scifi = min(1., // four space, please\n          space(uv*5., t, 81.) \n        + space(uv*10., t, 72.)\n        + space(uv*15., t, 63.)\n        + space(uv*20., t, 54.)\n        );\n    vec3 col = florp(a, c * 12. + 2.5 * t);\n    col = mix(vec3(scifi), col, hole); // put everything together\n\n    // Output to screen\n    fragColor = vec4(pow(col, vec3(igamma)),1.0);\n}\n\n","name":"Image","description":"","type":"image"}]}