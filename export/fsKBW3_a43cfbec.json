{"ver":"0.1","info":{"id":"fsKBW3","date":"1658916578","viewed":240,"name":"SWS2022_3005_13","username":"Lance2001","description":"Group assignment for NUS SWS 2022. Just a toy practice for three novices.\n!Please look here!!\nNotice: you must load the planets' texture manually according to the annotations in Buffer A and Buffer B to make it work. (We think you use chrome by default.)\n","likes":9,"published":1,"flags":32,"usePreview":1,"tags":["raytracing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdfGRn","filepath":"/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","previewfilepath":"/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdXGzn","filepath":"/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","previewfilepath":"/media/ap/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//============================================================================\n// Constants.\n//============================================================================\n\n//Mercury:\n/* Tap F12 and copy the following codes in the console:\ngShaderToy.SetTexture(2, {mSrc:'https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fimg-blog.csdnimg.cn%2Fimg_convert%2F98497b92e2887e5b378c4e303f8182fa.png&refer=http%3A%2F%2Fimg-blog.csdnimg.cn&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=auto?sec=1661440344&t=0b5143f404619dd5f98832688e9b49c7', mType:'texture', mID:1, mSampler:{ filter: 'mipmap', wrap: 'repeat', vflip:'true', srgb:'false', internal:'byte' }});\n*/\n#define EPS 0.00002\n#define MAX_DIST 10.0\nconst float PI = 3.1415926536; \n\nconst vec3 BACKGROUND_COLOR = vec3( 0.0, 0.0, 0.0 );\n\n// Vertical field-of-view angle of camera. In radians.\nconst float FOVY = 50.0 * PI / 180.0;\n\n// Use this for avoiding the \"epsilon problem\" or the shadow acne problem.\nconst float DEFAULT_TMIN = 10.0e-4;\n\n// Use this for tmax for non-shadow ray intersection test.\nconst float DEFAULT_TMAX = 10.0e6;\n\n// Equivalent to number of recursion levels (0 means ray-casting only).\n// We are using iterations to replace recursions.\nconst int NUM_ITERATIONS = 2;\n\n// Constants for the scene objects.\nconst int NUM_LIGHTS = 1;\nconst int NUM_MATERIALS = 12;\nconst int NUM_PLANES = 1;\nconst int NUM_SPHERES = 9;\nfloat vel=0.0;\n// SHIP SDF /////////////////////////////////////////\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nfloat sdEllipsoid( in vec3 p, in vec3 r ) // approximated\n{\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n}\n\n// vertical \nfloat sdCone( in vec3 p, in vec2 c, float h )\n{\n    vec2 q = h*vec2(c.x,-c.y)/c.y;\n    vec2 w = vec2( length(p.xz), p.y );\n    \n\tvec2 a = w - q*clamp( dot(w,q)/dot(q,q), 0.0, 1.0 );\n    vec2 b = w - q*vec2( clamp( w.x/q.x, 0.0, 1.0 ), 1.0 );\n    float k = sign( q.y );\n    float d = min(dot( a, a ),dot(b, b));\n    float s = max( k*(w.x*q.y-w.y*q.x),k*(w.y-q.y)  );\n\treturn sqrt(d)*sign(s);\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\n\nfloat sdCappedCone(vec3 p, vec3 a, vec3 b, float ra, float rb)\n{\n    float rba  = rb-ra;\n    float baba = dot(b-a,b-a);\n    float papa = dot(p-a,p-a);\n    float paba = dot(p-a,b-a)/baba;\n    float x = sqrt( papa - paba*paba*baba );\n    float cax = max(0.0,x-((paba<0.5)?ra:rb));\n    float cay = abs(paba-0.5)-0.5;\n    float k = rba*rba + baba;\n    float f = clamp( (rba*(x-ra)+paba*baba)/k, 0.0, 1.0 );\n    float cbx = x-ra - f*rba;\n    float cby = paba - f;\n    float s = (cbx < 0.0 && cay < 0.0) ? -1.0 : 1.0;\n    return s*sqrt( min(cax*cax + cay*cay*baba,\n                       cbx*cbx + cby*cby*baba) );\n}\n\n\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\n\nfloat opSubtract( float d1, float d2 ) {\n\t return max(-d1,d2); \n}\n\nvec3 opElongate(in vec3 p, in vec3 h )\n{\n    return p - clamp( p, -h, h );\n}\n\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); \n\n}\n\nfloat shipWindows(in vec3 p) {\n    return sdRoundBox(vec3(abs(p.x) - 0.56, p.y - 0.76, p.z-0.57), vec3(0.5, 0.5, 0.5), 0.05);\n}\n\n// returns 0 for body, 1 for window\nfloat windowDeform(in vec3 p){\n\treturn 1.0 - smoothstep(0.0, 0.01, shipWindows(p));\n}\n\n\n\nfloat shipEngine( in vec3 p){\n\treturn opSubtract(\n\t\tsdCone(p-vec3(0,0.2,0) , vec2(0.6, 1.0), 0.25),\n\t\tsdCone(p-vec3(0,0.2,0) , vec2(0.40, 1.0), 0.05) - 0.07\n\t);\n}\n\n\n// ring and landing gear\nfloat shipRing( in vec3 p){\n    float angle=mod(1.5*iTime,PI/1.5);\n    if(angle>(PI/3.0)){\n    angle=PI/1.5-angle;\n    }\n    angle-=PI/8.0;\n    p=vec3(cos(angle)*p.x-sin(angle)*p.y,sin(angle)*p.x+cos(angle)*p.y,p.z);\n\treturn min(sdCappedCone(vec3(p.x,p.y-0.2,p.z), vec3(0, 0, 0.55), vec3(0, 0, 0), 0.05, 0.02),\n\t\tmin(sdTorus(opElongate(vec3(p.x,p.y-0.2,p.z), vec3(0, 0.01, 0)), vec2(0.4, 0.013)),\n\t\tmin(sdCappedCone(vec3(abs(p.x),p.y-0.2,abs(p.z)), vec3(0.45, 0, 0.45), vec3(0.25, 0, 0.25), 0.05, 0.04),\n        min(sdCappedCone(vec3(abs(p.x),p.y-0.2,p.z), vec3(0.55, 0, 0.0), vec3(0.35, 0, 0), 0.05, 0.04),\n        sdCappedCone(vec3(p.x,p.y-0.2,abs(p.z)), vec3(0.0, 0, 0.55), vec3(0, 0, 0.35), 0.05, 0.04))))\n\t);\n}\n\n\n\n\nfloat ship(in vec3 p){\n\treturn min(shipRing(p),shipEngine(p));\n}\n\n// Ship map\nfloat map(in vec3 p){\n    float d2 = dot(p,p);\n    if(d2 > 1.){\n        return sqrt(d2)-0.5;\n    }\n    return ship(p.xzy); // Rotat eship so it's horizontal\n}\n\nfloat windowMat(in vec3 p) {\n    return smoothstep(-0.001, 0.0,-shipWindows(p.xzy));\n}\n\n\nfloat engineMat(in vec3 p) {\n\n    return smoothstep(-EPS - 0.01, -EPS, -shipEngine(p.xzy));\n}\n\n\n// Engine plume\n// returns 3D value noise - from https://iquilezles.org/articles/gradientnoise/\nfloat noise( in vec3 x )\n{\n    vec3 i = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\tvec2 uv = (i.xy+vec2(37.0,17.0)*i.z) + f.xy;\n\tvec2 rg = textureLod( iChannel2, (uv+0.5)/256.0, 0.0).yx;\n\treturn mix( rg.x, rg.y, f.z ) - 0.5;\n    \n}\nfloat fbm( in vec3 x, in float H, in int octaves)\n{    \n    float G = exp2(-H);\n    float f = 1.0;\n    float a = 1.0;\n    float t = 0.0;\n    for( int i=0; i<octaves; i++ )\n    {\n        t += a*noise(f*x);\n        f *= 2.0;\n        a *= G;\n    }\n    return t;\n}\n\nfloat exhaustNoise(in vec3 p, in int octaves){\n    vec3 p2 = p.xzy;\n    vec3 noise_pos = p2 * vec3(10. / p2.y, 2., 10. / p2.y) + vec3(0., 50. * iTime, 0.); // Moving origin to make exhaust move\n   \n    float strength = smoothstep(0.25, 2., -p2.y) * -p2.y * 0.1;\n    float distort = fbm(noise_pos, 1.2, octaves) * strength;\n    return distort;\n}\n\nfloat exhaust(in vec3 p, in int octaves) {\nfloat angle=mod(2.0*iTime,PI);\n    if(angle>(PI/2.0)){\n    angle=PI-angle;\n    }\n    angle-=PI/4.0;\n    p=vec3(cos(angle)*p.x-sin(angle)*p.y,sin(angle)*p.x+cos(angle)*p.y,p.z);\n    vec3 p2 = p.xzy + vec3(0., -0.25, 0.); // origin centered on start of exhaust\n    float distort = exhaustNoise(p, octaves);\n\n    return sdCone(p2, vec2(0.1, 1.0), 100.0) + distort;\n}\n\nvec3 exhaustNormal( in vec3 pos ) // for function f(p)\n{\n    const float h = 0.001;\n    #define ZERO (min(iFrame,0)) // non-constant zero\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*exhaust(pos+e*h, 2);\n    }\n    return normalize(n);\n}\n\n\n\nfloat softshadow( in vec3 ro, in vec3 rd, float mint, float k )\n{\n    float res = 1.0;\n    float t = mint;\n\tfloat h = 1.0;\n    for( int i=0; i<32; i++ )\n    {\n        h = map(ro + rd*t);\n        res = min( res, k*h/t );\n\t\tt += clamp( h, 0.005, 0.1 );\n    }\n    return clamp(res,0.0,1.0);\n}\n\n\n// From https://iquilezles.org/articles/normalsSDF/\nvec3 calcNormal( in vec3 pos ) // for function f(p)\n{\n    const float h = 0.0001;      // replace by an appropriate value\n    #define ZERO (min(iFrame,0)) // non-constant zero\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(pos+e*h);\n    }\n    return normalize(n);\n}\n\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float h = 0.01 + 0.12*float(i)/4.0;\n        float d = map( pos + h*nor );\n        occ += (h-d)*sca;\n        sca *= 0.95;\n        if( occ>0.35 ) break;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 ) * (0.5+0.5*nor.y);\n}\n\n\nbool intersect( in vec3 ro, in vec3 rd, out float dist )\n{\n\tfloat h = 1.0;\n\tdist = 0.0;\n    for( int i=0; i<128; i++ )\n    {\n\t\tif( h < EPS * dist) return true;\n\t\th = map(ro + rd * dist);\n        dist += h;\n\t\tif( dist > MAX_DIST) return false;\n    }\n\treturn false;\n}\n\n// Often fails because of inexact SDF, but this is okay - it leads to a cool pattern in the exhaust.\nbool intersect_exhaust( in vec3 ro, in vec3 rd, out float dist )\n{\n\tfloat h = 1.0;\n\tdist = 0.0;\n    for( int i=0; i<64; i++ )\n    {\n\t\tif( h < 0.0001 * dist) return true;\n        vec3 p = ro + rd * dist;\n\t\th = exhaust(ro + rd * dist, 6);\n        dist += h * 0.9;\n\t\tif( dist > 20.) return false;\n    }\n\treturn h < 0.01;\n}\n\n// Faster, lower quality exhaust\nbool intersect_exhaust_lq( in vec3 ro, in vec3 rd, out float dist)\n{\n\tfloat h = 1.0;\n\tdist = 0.0;\n    for( int i=0; i<16; i++ )\n    {\n\t\tif( h < 0.02 * dist) return true;\n        vec3 p = ro + rd * dist;\n\t\th = exhaust(ro + rd * dist, 1);\n        dist += h * 0.9 + 0.02;\n\t\tif( dist > 50.) return false;\n    }\n\treturn false;\n}\n\n// From https://www.shadertoy.com/view/4slSWf\nvoid generateRay( out vec3 resRo, out vec3 resRd, in vec3 po, in vec3 ta, in vec2 pi )\n{\n\tvec2 p = (2.0*pi-iResolution.xy)/iResolution.y;\n        \n    // camera matrix\n    vec3 ww = normalize( ta - po );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n\n\t// create view ray\n\tvec3 rd = normalize( p.x*uu + p.y*vv + 2.2*ww );\n\n    resRo = po;\n    resRd = rd;\n}\n\n\nvec3 fancyCube( sampler2D sam, in vec3 d, in float s, in float b )\n{\n    vec3 colx = texture( sam, 0.5 + s*d.yz/d.x, b ).xyz;\n    vec3 coly = texture( sam, 0.5 + s*d.zx/d.y, b ).xyz;\n    vec3 colz = texture( sam, 0.5 + s*d.xy/d.z, b ).xyz;\n    \n    vec3 n = d*d;\n    \n    return (colx*n.x + coly*n.y + colz*n.z)/(n.x+n.y+n.z);\n}\n\n\nvec2 hash( vec2 p ) { p=vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))); return fract(sin(p)*43758.5453); }\n\nvec2 voronoi( in vec2 x )\n{\n    vec2 n = floor( x );\n    vec2 f = fract( x );\n\n\tvec3 m = vec3( 8.0 );\n    for( int j=-1; j<=1; j++ )\n    for( int i=-1; i<=1; i++ )\n    {\n        vec2  g = vec2( float(i), float(j) );\n        vec2  o = hash( n + g );\n        vec2  r = g - f + o;\n\t\tfloat d = dot( r, r );\n        if( d<m.x )\n            m = vec3( d, o );\n    }\n\n    return vec2( sqrt(m.x), m.y+m.z );\n}\n\n\n// Background based off of https://www.shadertoy.com/view/llj3Rz\nvec3 background( in vec3 d, in vec3 l , in float starsize)\n{\n    vec3 col = vec3(0.0);\n         col += 0.6*pow( fancyCube( iChannel3, d, 0.05, 5.0 ).zyx, vec3(2.0) );\n         col += 1.5*vec3(0.80,0.5,0.6)*pow( fancyCube( iChannel3, d, 0.1, 0.0 ).xxx, vec3(6.0) );\n    float stars = smoothstep( 0.3, 0.7, fancyCube( iChannel3, d, 0.91, 0.0 ).x );\n\n    col = smoothstep(0.15, 0.5, col);\n    \n    vec3 n = abs(d);\n    n = n*n*n;\n    \n    vec2 vxy = voronoi( 30.0*d.xy*starsize );\n    vec2 vyz = voronoi( 30.0*d.yz*starsize );\n    vec2 vzx = voronoi( 30.0*d.zx*starsize );\n    vec2 r = (vyz*n.x + vzx*n.y + vxy*n.z) / (n.x+n.y+n.z);\n    col += 0.9 * stars * clamp(1.0-(3.0+r.y*5.0)*r.x,0.0,1.0);\n\n\n\n    float s = clamp( dot(d,l), 0.0, 1.0 );\n    col += 0.4*pow(s,10.0*starsize)*vec3(1.0,0.7,0.6)*2.0;\n    col += 0.4*pow(s,100.0*starsize)*vec3(1.0,0.9,0.8)*2.0;\n    \n    return col;\n}\n\nvec3 BlackBody( float t )\n{\n    const float h = 6.6e-34; // Planck constant\n    const float k = 1.4e-23; // Boltzmann constant\n    const float c = 3e8;// Speed of light\n\n    vec3 w = vec3( 480, 580, 530.0) / 1e9; // approximate wavelength of primaries\n    \n    // Planck's law https://en.wikipedia.org/wiki/Planck%27s_law\n    \n    vec3 w5 = w*w*w*w*w;    \n    vec3 o = 2.*h*(c*c) / (w5 * (exp(h*c/(w*k*t)) - 1.0));\n\n    return o;\n}\n\nvec3 shadeExhaust(vec3 p, vec3 rd) {\n    vec3 norm = exhaustNormal(p);\n    float ndotr = dot(rd, norm);\n    float rim = pow(1.0-abs(ndotr),2.0);\n    float temp_gradient = mix(1200., 0., -p.z * 0.03);\n    float temperature = temp_gradient + smoothstep(-0.5, 0.5, -exhaustNoise(p, 8)) * 200.;\n    float thickness = (rim + 0.03) * 0.00001;\n    \n    return vec3(BlackBody(temperature) * thickness);\n}\n\n\nvec3 shadeShip(vec3 p, vec3 rd, vec3 lightDir,float an) {\n    float window = windowMat(p);\n    float engine = engineMat(p);\n    vec3 norm = calcNormal(p);\n    float spec_strength = mix(0.6, 0.9, window);\n    spec_strength = mix(spec_strength, 0.01, engine);\n\n\tfloat ndotl = dot(norm,lightDir);\n    float ao = mix(0.6, 1.0, calcAO(p, norm));\n    float shadowAttenuation = softshadow(p + norm * EPS, lightDir, 0.01, 3.0);\n    float occ = ao * shadowAttenuation;\n\n    \n    // Diffuse\n    vec3 albedo = mix(vec3(0.75, 0.75, 0.75), vec3(0.05, 0.05, 0.05), window);\n    albedo = mix(albedo, vec3(0.05), engine);\n    \n\tvec3 light = smoothstep(-.1, 1.0, ndotl) * vec3( 0.1, 0.1, 0.1 );\n\n\tvec3 col = albedo * light * occ;\n\t\n    vec3 exhaust_dir = vec3(0., 0., -1.);\n    \n    float ndotexhaust = dot(norm, exhaust_dir);\n    light = smoothstep(-.1, 1.0, ndotexhaust) * vec3(1., 0.8, 0.2) * 15.;\n    float exhaust_occ = softshadow(p + norm * EPS, exhaust_dir, 0.001, 0.5) + 0.2;\n    \n\tcol += albedo * light * exhaust_occ;\n    \n\t// specular\n\tvec3 h = normalize(lightDir-rd);\n\tfloat s = pow(max(0.0,dot(norm,h)),50.0) * spec_strength;\n\t\n\tvec3 specular = s*vec3(1.0);\n\n\n    // Reflections\n    // I think these look too sharp on the body of the ship. \n    // Skybox reflection\n\tvec3 rr = reflect(rd, norm);\n    float rr_atten = softshadow(p + norm * EPS, rr, 0.01, 100.0);\n\tspecular += mix(albedo * occ * spec_strength, background(rr, lightDir, spec_strength), rr_atten);\n    \n    // Exhaust reflection\n    float exhaust_d;\n    bool rr_exhaust_hit = intersect_exhaust_lq(p, rr, exhaust_d);\n    if(rr_exhaust_hit){\n        specular += rr_atten * spec_strength * shadeExhaust (p + rr * exhaust_d, rr);\n    }\n\t\n\tfloat ndotr = dot(norm,rd);\n\tfloat fresnel = pow(1.0-abs(ndotr),5.0) * spec_strength;\n\tfresnel = mix(spec_strength, 1.0, fresnel );\n\n\tcol = mix( col, specular, fresnel );\n\t\n\treturn col;\n}\n\n\n\n\nvec3 encodeSRGB(vec3 linearRGB)\n{\n    vec3 a = 12.92 * linearRGB;\n    vec3 b = 1.055 * pow(linearRGB, vec3(1.0 / 2.4)) - 0.055;\n    vec3 c = step(vec3(0.0031308), linearRGB);\n    return mix(a, b, c);\n}\n\n\n\n\n//============================================================================\n// Define new struct types.\n//============================================================================\nstruct Ray_t {\n    vec3 o;  // Ray Origin.\n    vec3 d;  // Ray Direction. A unit vector.\n};\n\nstruct Plane_t {\n    // The plane equation is Ax + By + Cz + D = 0.\n    float A, B, C, D;\n    int materialID;\n};\n\nstruct Sphere_t {\n    vec3 center;\n    float radius;\n    int materialID;\n};\n\nstruct Light_t {\n    vec3 position;  // Point light 3D position.\n    vec3 I_a;       // For Ambient.\n    vec3 I_source;  // For Diffuse and Specular.\n};\n\nstruct Material_t {\n    bool hastexture;\n    int textureID;\n    vec3 k_a;   // Ambient coefficient.\n    vec3 k_d;   // Diffuse coefficient.\n    vec3 k_r;   // Reflected specular coefficient.\n    vec3 k_rg;  // Global reflection coefficient.\n    float n;    // The specular reflection exponent. Ranges from 0.0 to 128.0.\n};\n\n//----------------------------------------------------------------------------\n// The lighting model used here is similar to that shown in\n// Lecture Topic B08 (Basic Ray Tracing). Here it is computed as\n//\n//     I_local = SUM_OVER_ALL_LIGHTS {\n//                   I_a * k_a +\n//                   k_shadow * I_source * [ k_d * (N.L) + k_r * (R.V)^n ]\n//               }\n// and\n//     I = I_local  +  k_rg * I_reflected\n//----------------------------------------------------------------------------\n\n\n//============================================================================\n// Global scene data.\n//============================================================================\nPlane_t Plane[NUM_PLANES];\nSphere_t Sphere[NUM_SPHERES];\nLight_t Light[NUM_LIGHTS];\nMaterial_t Material[NUM_MATERIALS];\n\n\n\n/////////////////////////////////////////////////////////////////////////////\n// Initializes the scene.\n/////////////////////////////////////////////////////////////////////////////\nvoid InitScene()\n{\n    // Horizontal plane.\n    Plane[0].A = 0.0;\n    Plane[0].B = 1.0;\n    Plane[0].C = 0.0;\n    Plane[0].D = 0.0;\n    Plane[0].materialID = 0;\n\n    // Vertical plane.\n    //Plane[1].A = 0.0;\n    //Plane[1].B = 0.0;\n    //Plane[1].C = 1.0;\n    //Plane[1].D = 3.5;\n    //Plane[1].materialID = 0;\n    \n    // Sun.\n    Sphere[0].center = vec3( 0.0, 1.0, 0.0 );\n    Sphere[0].radius = 1.0;\n    Sphere[0].materialID = 3;\n\n    // Jupiter.\n    Sphere[1].center = vec3( -3.0 * cos(iTime / 11.8) * cos(PI / 20.0) + sin(PI / 20.0), cos(PI / 20.0) + 3.0 * cos(iTime / 11.8) * sin(PI / 20.0), -3.0 * sin(iTime / 11.8) );\n    Sphere[1].radius = 0.3;\n    Sphere[1].materialID = 4;\n    \n    // Saturn.\n    Sphere[2].center = vec3( -3.5 * cos(iTime / 15.4) * cos(-PI / 30.0) + sin(-PI / 30.0), cos(-PI / 30.0) + 3.5 * cos(iTime / 15.4) * sin(-PI / 30.0), -3.5 * sin(iTime / 15.4) );\n    Sphere[2].radius = 0.2;\n    Sphere[2].materialID = 5;\n    \n    // Uranus.\n    Sphere[3].center = vec3( -4.0 * cos(iTime / 19.2), 1.0, -4.0 * sin(iTime / 19.2) );\n    Sphere[3].radius = 0.15;\n    Sphere[3].materialID = 6;\n    \n    // Neptune.\n    Sphere[4].center = vec3( -4.5 * cos(iTime / 23.0) * cos(-PI / 20.0) + sin(-PI / 20.0) , cos(PI / 20.0) + 4.5 * sin(iTime / 23.0) * sin(PI / 20.0), -4.5 * sin(iTime / 23.0) );\n    Sphere[4].radius = 0.13;\n    Sphere[4].materialID = 7;\n    \n    // Earth.\n    Sphere[5].center = vec3( -2.1 * cos(iTime) * cos(PI / 30.0) + sin(PI / 30.0), cos(PI / 30.0) + 2.1 * cos(iTime) * sin(PI / 30.0), -2.1 * sin(iTime) );\n    Sphere[5].radius = 0.11;\n    Sphere[5].materialID = 8;\n    \n    // Venus.\n    Sphere[6].center = vec3( -1.7 * cos(iTime / 0.613), 1.0, -1.7 * sin(iTime / 0.613) );\n    Sphere[6].radius = 0.10;\n    Sphere[6].materialID = 9;\n    \n    // Mars.\n    Sphere[7].center = vec3( -2.5 * cos(iTime / 1.3), 1.0, -2.5 * sin(iTime / 1.3) );\n    Sphere[7].radius = 0.08;\n    Sphere[7].materialID = 10;\n    \n    // Mercury.\n    Sphere[8].center = vec3( -1.3 * cos(iTime * 1.5), 1.0, -1.3 * sin(iTime * 1.5) );\n    Sphere[8].radius = 0.06;\n    Sphere[8].materialID = 11;\n    \n\n    // Silver material.\n    Material[0].k_d = vec3( 0.5, 0.5, 0.5 );\n    Material[0].k_a = 0.2 * Material[0].k_d;\n    Material[0].k_r = 2.0 * Material[0].k_d;\n    Material[0].k_rg = 0.5 * Material[0].k_r;\n    Material[0].n = 64.0;\n\n    // Gold material.\n    Material[1].k_d = vec3( 0.8, 0.7, 0.1 );\n    Material[1].k_a = 0.2 * Material[1].k_d;\n    Material[1].k_r = 2.0 * Material[1].k_d;\n    Material[1].k_rg = 0.5 * Material[1].k_r;\n    Material[1].n = 64.0;\n\n    // Green plastic material.\n    Material[2].k_d = vec3( 0.0, 0.8, 0.0 );\n    Material[2].k_a = 0.2 * Material[2].k_d;\n    Material[2].k_r = vec3( 1.0, 1.0, 1.0 );\n    Material[2].k_rg = 0.5 * Material[2].k_r;\n    Material[2].n = 128.0;\n    \n    // Sun material\n    Material[3].hastexture = true;\n    Material[3].textureID = 0;\n    Material[3].n = 128.0;\n    \n    // Jupiter material\n    Material[4].hastexture = true;\n    Material[4].textureID = 1;\n    Material[4].n = 128.0;\n    \n    // Saturn material\n    Material[5].hastexture = true;\n    Material[5].textureID = 2;\n    Material[5].n = 128.0;\n    \n    // Uranus material\n    Material[6].hastexture = true;\n    Material[6].textureID = 3;\n    Material[6].n = 128.0;\n    \n    // Neptune material\n    Material[7].hastexture = true;\n    Material[7].textureID = 4;\n    Material[7].n = 128.0;\n    \n    // Earth material\n    Material[8].hastexture = true;\n    Material[8].textureID = 5;\n    Material[8].n = 128.0;\n    \n    // Venus material\n    Material[9].hastexture = true;\n    Material[9].textureID = 6;\n    Material[9].n = 128.0;\n    \n    // Mars material\n    Material[10].hastexture = true;\n    Material[10].textureID = 7;\n    Material[10].n = 128.0;\n    \n    // Mercury material\n    Material[11].hastexture = true;\n    Material[11].textureID = 8;\n    Material[11].n = 128.0;\n\n    // Light 0.\n    Light[0].position = vec3( 0.0,1.0, 0.0 );\n    Light[0].I_a = vec3( 0.1, 0.1, 0.1 );\n    Light[0].I_source = vec3( 1.0, 1.0, 1.0 );\n\n    // Light 1.\n    //Light[1].position = vec3( -4.0, 8.0, 0.0 );\n    //Light[1].I_a = vec3( 0.1, 0.1, 0.1 );\n    //Light[1].I_source = vec3( 1.0, 1.0, 1.0 );\n}\n\n\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes intersection between a plane and a ray.\n// Returns true if there is an intersection where the ray parameter t is\n// between tmin and tmax, otherwise returns false.\n// If there is such an intersection, outputs the value of t, the position\n// of the intersection (hitPos) and the normal vector at the intersection\n// (hitNormal).\n/////////////////////////////////////////////////////////////////////////////\nbool IntersectPlane( in Plane_t pln, in Ray_t ray, in float tmin, in float tmax,\n                     out float t, out vec3 hitPos, out vec3 hitNormal )\n{\n    vec3 N = vec3( pln.A, pln.B, pln.C );\n    float NRd = dot( N, ray.d );\n    float NRo = dot( N, ray.o );\n    float t0 = (-pln.D - NRo) / NRd;\n    if ( t0 < tmin || t0 > tmax ) return false;\n\n    // We have a hit -- output results.\n    t = t0;\n    hitPos = ray.o + t0 * ray.d;\n    hitNormal = normalize( N );\n    return true;\n}\n\n\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes intersection between a plane and a ray.\n// Returns true if there is an intersection where the ray parameter t is\n// between tmin and tmax, otherwise returns false.\n/////////////////////////////////////////////////////////////////////////////\nbool IntersectPlane( in Plane_t pln, in Ray_t ray, in float tmin, in float tmax )\n{\n    vec3 N = vec3( pln.A, pln.B, pln.C );\n    float NRd = dot( N, ray.d );\n    float NRo = dot( N, ray.o );\n    float t0 = (-pln.D - NRo) / NRd;\n    if ( t0 < tmin || t0 > tmax ) return false;\n    return true;\n}\n\n\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes intersection between a sphere and a ray.\n// Returns true if there is an intersection where the ray parameter t is\n// between tmin and tmax, otherwise returns false.\n// If there is one or two such intersections, outputs the value of the\n// smaller t, the position of the intersection (hitPos) and the normal\n// vector at the intersection (hitNormal).\n/////////////////////////////////////////////////////////////////////////////\nbool IntersectSphere( in Sphere_t sph, in Ray_t ray, in float tmin, in float tmax,\n                      out float t, out vec3 hitPos, out vec3 hitNormal )\n{\n    /////////////////////////////////\n    // TASK: WRITE YOUR CODE HERE. //\n    /////////////////////////////////\n    //transform the ray to the sphere's local coordinate frame\n    vec3 ray_o_in_sphcoord = ray.o - sph.center;\n    float t0 = -1.0;\n    float a = 1.0, b = 2.0 * dot(ray.d, ray_o_in_sphcoord), \n          c = dot(ray_o_in_sphcoord, ray_o_in_sphcoord) - sph.radius * sph.radius,\n          d = b * b - 4.0 * a * c;\n    //if d<=0.0, means the ray doesn't cross the sphere or are tangent, thus return false\n    if(d <= 0.0) return false;\n    float t1 = (-1.0 * b + sqrt(d))/ (2.0 * a),\n          t2 = (-1.0 * b - sqrt(d))/ (2.0 * a);\n    if((t1 < tmin || t1 > tmax) && (t2 < tmin || t2 > tmax)) return false;\n    else if(t1 >= tmin && t1 <= tmax) t0 = t1;\n    if(t2 >= tmin && t2 <= tmax && t2 < t1) t0 = t2;\n    \n    t = t0;\n    hitPos = ray.o + t0 * ray.d;\n    hitNormal = normalize(ray_o_in_sphcoord + t0 * ray.d);\n    return true; \n\n}\n\n\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes intersection between a sphere and a ray.\n// Returns true if there is an intersection where the ray parameter t is\n// between tmin and tmax, otherwise returns false.\n/////////////////////////////////////////////////////////////////////////////\nbool IntersectSphere( in Sphere_t sph, in Ray_t ray, in float tmin, in float tmax )\n{\n    /////////////////////////////////\n    // TASK: WRITE YOUR CODE HERE. //\n    /////////////////////////////////\n    //transform the ray to the sphere's local coordinate frame\n    vec3 ray_o_in_sphcoord = ray.o - sph.center;\n    float t0 = -1.0;\n    float a = 1.0, b = 2.0 * dot(ray.d, ray_o_in_sphcoord), \n          c = dot(ray_o_in_sphcoord, ray_o_in_sphcoord) - sph.radius * sph.radius,\n          d = b * b - 4.0 * a * c;\n    //if d<=0.0, means the ray doesn't cross the sphere or are tangent, thus return false\n    if(d <= 0.0) return false; \n    float t1 = (-1.0 * b + sqrt(d))/ (2.0 * a),\n          t2 = (-1.0 * b - sqrt(d))/ (2.0 * a);\n    if((t1 < tmin || t1 > tmax) && (t2 < tmin || t2 > tmax)) return false;\n    return true;\n}\n\nvec2 Parameterize(in vec3 center, in vec3 hitpos, in float radius){\n    float x = hitpos.x - center.x;\n    float y = hitpos.y - center.y;\n    float z = hitpos.z - center.z;\n    float x0;\n    if(x == 0.0 && z > 0.0) x0 = 0.0;\n    else if(x > 0.0 && z > 0.0) x0 = atan(x / z) / 2.0 / PI;\n    else if(x > 0.0 && z == 0.0) x0 = 0.25;\n    else if(x > 0.0 && z < 0.0) x0 = (PI - atan(x / z * -1.0)) / 2.0 / PI;\n    else if(x == 0.0 && z < 0.0) x0 = 0.5;\n    else if(x < 0.0 && z < 0.0) x0 = (PI + atan(x / z)) / 2.0 / PI;\n    else if(x < 0.0 && z == 0.0) x0 = 0.75;\n    else if(x < 0.0 && z > 0.0) x0 = (2.0 * PI - atan(x / z * -1.0)) / 2.0 / PI;\n    return vec2(x0, y / 2.0 / radius + 0.5);\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes (I_a * k_a) + k_shadow * I_source * [ k_d * (N.L) + k_r * (R.V)^n ].\n// Input vectors L, N and V are pointing AWAY from surface point.\n// Assume all vectors L, N and V are unit vectors.\n/////////////////////////////////////////////////////////////////////////////\nvec3 PhongLighting( in vec3 L, in vec3 N, in vec3 V, in bool inShadow,\n                    bool isSphere, in vec3 center, in float radius,\n                    in Material_t mat, in Light_t light, in vec3 hitpos )\n{\n    \n    if(mat.hastexture){\n        vec3 R = reflect( -L, N );\n        float N_dot_L = max( 0.0, dot( N, L ) );\n        float R_dot_V = max( 0.0, dot( R, V ) );\n        float R_dot_V_pow_n = ( R_dot_V == 0.0 )? 0.0 : pow( R_dot_V, mat.n );\n\n        if (isSphere){\n            vec2 texcoord = Parameterize(center, hitpos, radius);\n            vec3 mat_ka;\n            vec3 mat_kd;\n            vec3 mat_kr;\n            if(mat.textureID == 0){\n                mat_kd = texture(iChannel0, texcoord / 2.0).rgb;\n            }\n            else if (mat.textureID == 1) {\n                mat_kd = texture(iChannel0, texcoord / 2.0 + vec2(0.5, 0.0)).rgb;\n            }\n            else if (mat.textureID == 2) {\n                mat_kd = texture(iChannel0, texcoord / 2.0 + vec2(0.0, 0.5)).rgb;\n            }\n            else if (mat.textureID == 3) {\n                mat_kd = texture(iChannel0, texcoord / 2.0 + vec2(0.5, 0.5)).rgb;\n            }\n            else if (mat.textureID == 4) {\n                mat_kd = texture(iChannel1, texcoord / 2.0).rgb;\n            }\n            else if (mat.textureID == 5) {\n                mat_kd = texture(iChannel1, texcoord / 2.0 + vec2(0.5, 0.0)).rgb;\n            }\n            else if (mat.textureID == 6) {\n                mat_kd = texture(iChannel1, texcoord / 2.0 + vec2(0.0, 0.5)).rgb;\n            }\n            else if (mat.textureID == 7) {\n                mat_kd = texture(iChannel1, texcoord / 2.0 + vec2(0.5, 0.5)).rgb;\n            }\n            else if (mat.textureID == 8) {\n                mat_kd = texture(iChannel2, texcoord).rgb; \n            }\n            mat_ka = mat_kd * 0.2;\n            mat_kr = mat_kd * 2.0;\n            //if ( inShadow ) {\n            //    return light.I_a * mat.k_a * 100.0;\n            //}\n            if(mat.textureID == 0) return mat_kd;\n            return light.I_a * mat_ka +\n                   light.I_source * (mat_kd * N_dot_L + mat_kr * R_dot_V_pow_n);\n        }\n        return texture(iChannel1, vec2(hitpos.x, hitpos.y)).rgb * 0.2 +\n               light.I_source * (texture(iChannel1, vec2(hitpos.x, hitpos.y)).rgb * N_dot_L \n               + texture(iChannel1, vec2(hitpos.x, hitpos.y)).rgb * 2.0 * R_dot_V_pow_n);\n    }\n    else {\n        vec3 R = reflect( -L, N );\n        float N_dot_L = max( 0.0, dot( N, L ) );\n        float R_dot_V = max( 0.0, dot( R, V ) );\n        float R_dot_V_pow_n = ( R_dot_V == 0.0 )? 0.0 : pow( R_dot_V, mat.n );\n\n        return light.I_a * mat.k_a +\n               light.I_source * (mat.k_d * N_dot_L + mat.k_r * R_dot_V_pow_n);\n    }\n}\n\n\n\n/////////////////////////////////////////////////////////////////////////////\n// Casts a ray into the scene and returns color computed at the nearest\n// intersection point. The color is the sum of light from all light sources,\n// each computed using Phong Lighting Model, with consideration of\n// whether the interesection point is being shadowed from the light.\n// If there is no interesection, returns the background color, and outputs\n// hasHit as false.\n// If there is intersection, returns the computed color, and outputs\n// hasHit as true, the 3D position of the intersection (hitPos), the\n// normal vector at the intersection (hitNormal), and the k_rg value\n// of the material of the intersected object.\n/////////////////////////////////////////////////////////////////////////////\nvec3 CastRay( in Ray_t ray,\n              out bool hasHit, out vec3 hitPos, out vec3 hitNormal, out vec3 k_rg )\n{\n    // Find whether and where the ray hits some object.\n    // Take the nearest hit point.\n\n    bool hasHitSomething = false;\n    float nearest_t = DEFAULT_TMAX;   // The ray parameter t at the nearest hit point.\n    vec3 nearest_hitPos;              // 3D position of the nearest hit point.\n    vec3 nearest_hitNormal;           // Normal vector at the nearest hit point.\n    int nearest_hitMatID;             // MaterialID of the object at the nearest hit point.\n\n    float temp_t;\n    vec3 temp_hitPos;\n    vec3 temp_hitNormal;\n    bool temp_hasHit;\n    \n    bool hitSphere = false;\n    vec3 Spherecenter = vec3(0.0, 0.0, 0.0);\n    float radius = 0.0;\n\n    for(int i = 0; i<NUM_SPHERES; i++){\n        if(IntersectSphere(Sphere[i], ray, DEFAULT_TMIN, DEFAULT_TMAX)) {\n            hasHitSomething = true;\n            IntersectSphere(Sphere[i], ray, DEFAULT_TMIN, DEFAULT_TMAX,\n            temp_t, temp_hitPos, temp_hitNormal);\n            if(temp_t < nearest_t) {\n                hitSphere = true;\n                Spherecenter = Sphere[i].center;\n                radius = Sphere[i].radius;\n                nearest_t = temp_t;\n                nearest_hitPos = temp_hitPos;\n                nearest_hitNormal = temp_hitNormal;\n                nearest_hitMatID = Sphere[i].materialID;\n            }\n        }\n    }\n\n\n    // One of the output results.\n    hasHit = hasHitSomething;\n    if ( !hasHitSomething ) return BACKGROUND_COLOR;\n\n    vec3 I_local = vec3( 0.0 ); \n\n    for(int lightcnt = 0; lightcnt <NUM_LIGHTS; lightcnt++){\n        bool inShadow = false;\n        Ray_t shadowray;\n        shadowray.o = Light[lightcnt].position;\n        shadowray.d = normalize(nearest_hitPos - Light[lightcnt].position);\n        float distance_light_hitpos = sqrt(dot(nearest_hitPos - Light[lightcnt].position, nearest_hitPos - Light[lightcnt].position));\n        for(int i = 0; i<NUM_PLANES; i++){\n            if(IntersectPlane(Plane[i], shadowray, DEFAULT_TMIN, \n            distance_light_hitpos - DEFAULT_TMIN)) //minus DEFAULT_TMIN in order to avoid shadow\n                inShadow = true;\n        }\n        for(int i = 0; i<NUM_SPHERES; i++){\n            if(IntersectSphere(Sphere[i], shadowray, DEFAULT_TMIN, \n            distance_light_hitpos - DEFAULT_TMIN)) \n                inShadow = true;\n        }\n        I_local += PhongLighting( normalize(Light[lightcnt].position - nearest_hitPos), \n                nearest_hitNormal, \n                normalize(ray.o - nearest_hitPos), \n                inShadow,\n                hitSphere,\n                Spherecenter,\n                radius,\n                Material[nearest_hitMatID], \n                Light[lightcnt],\n                nearest_hitPos);\n    }\n\n\n    // Populate output results.\n    hitPos = nearest_hitPos;\n    hitNormal = nearest_hitNormal;\n    k_rg = Material[nearest_hitMatID].k_rg;\n\n    return I_local;\n}\n\n\nvec3 intersect_star(in Ray_t nextRay){\n    vec3 I_result = vec3( 0.0 );\n    vec3 compounded_k_rg = vec3( 1.0 );\n    for ( int level = 0; level <= NUM_ITERATIONS; level++ )\n    {\n        bool hasHit;\n        vec3 hitPos, hitNormal, k_rg;\n\n        vec3 I_local = CastRay( nextRay, hasHit, hitPos, hitNormal, k_rg );\n\n        I_result += compounded_k_rg * I_local;\n\n        if ( !hasHit ) break;\n\n        compounded_k_rg *= k_rg;\n\n        nextRay = Ray_t( hitPos, normalize( reflect(nextRay.d, hitNormal) ) );\n    }\n    return I_result;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    InitScene();\n // camera\n    float an=0.1*iTime;// mod(0.1*iTime,PI/3.0);\n    //if(an>PI/6.0){\n  //  an=PI/3.0-an;\n   // }\n   // an-=1.2*PI;\n\tvec3  po = vec3(1.0 + 5.0*sin(an),3.0,5.0*cos(an));\n    vec3  ta = vec3(0.0, 0.0, 0.0);\n\n    vec3 ro,  rd;  generateRay( ro,  rd,  po, ta, fragCoord.xy );\n    \n    vec4 ship_sphere = vec4(vec3(0.), 0.6);\n    \n    vec3 col = vec3(0.0);\n\n    vec3 star_dir = normalize(vec3( 0.0, 1.0, 0.0 ));//normalize(vec3(sin(0.5*iTime),2. * sin(0.34253*iTime),cos(0.5*iTime)));\n\n    \n    float dist; bool hit;\n    float exhaust_dist;\n    Ray_t pRay;\n    hit = intersect(ro, rd, dist);\n    if(hit){\n        vec3 pos = ro + dist * rd;\n        \n        col = shadeShip(pos, rd, star_dir,an);\n        hit = intersect_exhaust(ro, rd, exhaust_dist);\n        if(hit && exhaust_dist < dist){\n            col += shadeExhaust(ro + rd * exhaust_dist, rd);\n        }\n    } else {\n        hit = intersect_exhaust(ro, rd, exhaust_dist);\n        if(hit){\n            col += shadeExhaust(ro + rd * exhaust_dist, rd);\n        }\n        pRay.o = ro;\n        pRay.d = rd;\n\n\n    // Start Ray Tracing.\n    // Use iterations to emulate the recursion.\n\n    vec3 I_result = vec3( 0.0 );\n    vec3 compounded_k_rg = vec3( 1.0 );\n    Ray_t nextRay = pRay;\n\n    for ( int level = 0; level <= NUM_ITERATIONS; level++ )\n    {\n        bool hasHit;\n        vec3 hitPos, hitNormal, k_rg;\n\n        vec3 I_local = CastRay( nextRay, hasHit, hitPos, hitNormal, k_rg );\n\n        I_result += compounded_k_rg * I_local;\n\n        if ( !hasHit ) {\n        if(level == 0 ) I_result += background(rd, star_dir, 1.5) * 0.5;\n        break;\n        }\n\n        compounded_k_rg *= k_rg;\n\n        nextRay = Ray_t( hitPos, normalize( reflect(nextRay.d, hitNormal) ) );\n    }\n    col+=I_result;\n    }\n    \n\n    col = col * vec3(1., 1., 1.);\n    col = encodeSRGB(col);\n    // Output to screen\n    fragColor = vec4(col, 0.0);\n}\n\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//Sun:\n//gShaderToy.SetTexture(0, {mSrc:'https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fs4.51cto.com%2Fimages%2Fblog%2F202107%2F13%2Fb29c57a56144ab681eae690e6e18face.jpeg%3Fx-oss-process%3Dimage%2Fwatermark%2Csize_16%2Ctext_QDUxQ1RP5Y2a5a6i%2Ccolor_FFFFFF%2Ct_100%2Cg_se%2Cx_10%2Cy_10%2Cshadow_90%2Ctype_ZmFuZ3poZW5naGVpdGk%3D&refer=http%3A%2F%2Fs4.51cto.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=auto?sec=1661433510&t=140db6a3f87126e15f88e9b66b7e83b8', mType:'texture', mID:1, mSampler:{ filter: 'mipmap', wrap: 'repeat', vflip:'true', srgb:'false', internal:'byte' }});\n\n//Jupiter:\n//gShaderToy.SetTexture(1, {mSrc:'https://gimg2.baidu.com/image_search/src=http%3A%2F%2F5b0988e595225.cdn.sohucs.com%2Fimages%2F20171228%2Fb9563ef2fae743dc9913ac6851c59742.jpeg&refer=http%3A%2F%2F5b0988e595225.cdn.sohucs.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=auto?sec=1661438640&t=7ebdfe65a9239790337c6361ef9404ed', mType:'texture', mID:1, mSampler:{ filter: 'mipmap', wrap: 'repeat', vflip:'true', srgb:'false', internal:'byte' }});\n\n//Saturn:\n//gShaderToy.SetTexture(2, {mSrc:'https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fp9.itc.cn%2Fq_70%2Fimages03%2F20210915%2F1d1e85b13e78457c93f3acdb3c70f7e8.jpeg&refer=http%3A%2F%2Fp9.itc.cn&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=auto?sec=1661438868&t=a6c47a9556cfd7685be1f1413f8a7144', mType:'texture', mID:1, mSampler:{ filter: 'mipmap', wrap: 'repeat', vflip:'true', srgb:'false', internal:'byte' }});\n\n//Uranus:\n//gShaderToy.SetTexture(3, {mSrc:'https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fp5.itc.cn%2Fq_70%2Fimages03%2F20210915%2F4349fd3f9d1248f9a9b2b80d6f3206f5.jpeg&refer=http%3A%2F%2Fp5.itc.cn&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=auto?sec=1661438943&t=54eb6753d71902e710ecc4fed812f137', mType:'texture', mID:1, mSampler:{ filter: 'mipmap', wrap: 'repeat', vflip:'true', srgb:'false', internal:'byte' }});\n\n/* Tap F12 and copy the following codes in the console:\ngShaderToy.SetTexture(0, {mSrc:'https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fs4.51cto.com%2Fimages%2Fblog%2F202107%2F13%2Fb29c57a56144ab681eae690e6e18face.jpeg%3Fx-oss-process%3Dimage%2Fwatermark%2Csize_16%2Ctext_QDUxQ1RP5Y2a5a6i%2Ccolor_FFFFFF%2Ct_100%2Cg_se%2Cx_10%2Cy_10%2Cshadow_90%2Ctype_ZmFuZ3poZW5naGVpdGk%3D&refer=http%3A%2F%2Fs4.51cto.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=auto?sec=1661433510&t=140db6a3f87126e15f88e9b66b7e83b8', mType:'texture', mID:1, mSampler:{ filter: 'mipmap', wrap: 'repeat', vflip:'true', srgb:'false', internal:'byte' }});\ngShaderToy.SetTexture(1, {mSrc:'https://gimg2.baidu.com/image_search/src=http%3A%2F%2F5b0988e595225.cdn.sohucs.com%2Fimages%2F20171228%2Fb9563ef2fae743dc9913ac6851c59742.jpeg&refer=http%3A%2F%2F5b0988e595225.cdn.sohucs.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=auto?sec=1661438640&t=7ebdfe65a9239790337c6361ef9404ed', mType:'texture', mID:1, mSampler:{ filter: 'mipmap', wrap: 'repeat', vflip:'true', srgb:'false', internal:'byte' }});\ngShaderToy.SetTexture(2, {mSrc:'https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fp9.itc.cn%2Fq_70%2Fimages03%2F20210915%2F1d1e85b13e78457c93f3acdb3c70f7e8.jpeg&refer=http%3A%2F%2Fp9.itc.cn&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=auto?sec=1661438868&t=a6c47a9556cfd7685be1f1413f8a7144', mType:'texture', mID:1, mSampler:{ filter: 'mipmap', wrap: 'repeat', vflip:'true', srgb:'false', internal:'byte' }});\ngShaderToy.SetTexture(3, {mSrc:'https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fp5.itc.cn%2Fq_70%2Fimages03%2F20210915%2F4349fd3f9d1248f9a9b2b80d6f3206f5.jpeg&refer=http%3A%2F%2Fp5.itc.cn&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=auto?sec=1661438943&t=54eb6753d71902e710ecc4fed812f137', mType:'texture', mID:1, mSampler:{ filter: 'mipmap', wrap: 'repeat', vflip:'true', srgb:'false', internal:'byte' }});\n*/\n\nconst float rotationspeed_Sun = 1.0 / 10.0;\nconst float rotationspeed_Jupiter = 1.0 / 10.0;\nconst float rotationspeed_Saturn = 1.0 / 10.0;\nconst float rotationspeed_Uranus = 1.0 / 10.0;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float u = fragCoord.x / iResolution.x;\n    float v = fragCoord.y / iResolution.y;\n    if(u < 0.5 && v < 0.5) fragColor = texture(iChannel0, vec2(fract(u * 2.0 + iTime * rotationspeed_Sun), v * 2.0));\n    if(u >= 0.5 && v < 0.5) fragColor = texture(iChannel1, vec2(fract((u - 0.5) * 2.0 + iTime * rotationspeed_Jupiter), v * 2.0));\n    if(u < 0.5 && v >= 0.5) fragColor = texture(iChannel2, vec2(fract(u * 2.0 + iTime * rotationspeed_Saturn), (v - 0.5) * 2.0));\n    if(u >= 0.5 && v >= 0.5) fragColor = texture(iChannel3, vec2(fract((u - 0.5) * 2.0 + iTime * rotationspeed_Uranus), (v - 0.5) * 2.0));\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[{"id":"XsXGR8","channel":0}],"code":"//Neptune:\n//gShaderToy.SetTexture(0, {mSrc:'https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fwww.daoyouz.com%2Fpicture%2Fd226bb18d3ecdfe911006c61018b5bd12.jpg&refer=http%3A%2F%2Fwww.daoyouz.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=auto?sec=1661440055&t=174909216b5007994b516bbc4eec4494', mType:'texture', mID:1, mSampler:{ filter: 'mipmap', wrap: 'repeat', vflip:'true', srgb:'false', internal:'byte' }});\n\n//Earth:\n//gShaderToy.SetTexture(1, {mSrc:'https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fh.shanse8.com%2Fattachment%2Fphoto%2FMon_1207%2F5665_96e613415040362e27cb94c335597.jpg&refer=http%3A%2F%2Fh.shanse8.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=auto?sec=1661438153&t=0045565b74383152f6bc22a38eaf630f', mType:'texture', mID:1, mSampler:{ filter: 'mipmap', wrap: 'repeat', vflip:'true', srgb:'false', internal:'byte' }});\n\n//Venus:\n//gShaderToy.SetTexture(2, {mSrc:'https://img1.baidu.com/it/u=3518576466,2235478798&fm=253&fmt=auto&app=138&f=JPEG?w=238&h=100', mType:'texture', mID:1, mSampler:{ filter: 'mipmap', wrap: 'repeat', vflip:'true', srgb:'false', internal:'byte' }});\n\n//Mars:\n//gShaderToy.SetTexture(3, {mSrc:'https://gimg2.baidu.com/image_search/src=http%3A%2F%2Ffilescdn.proginn.com%2F376c7713ff32590a655f54b345cfcc43%2Fd6d2bb5e96064fcfd5c0f7a4d563f5cb.webp&refer=http%3A%2F%2Ffilescdn.proginn.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=auto?sec=1661439895&t=c280180b0b49d029b2441f4af2010f4f', mType:'texture', mID:1, mSampler:{ filter: 'mipmap', wrap: 'repeat', vflip:'true', srgb:'false', internal:'byte' }});\n\n/* Tap F12 and copy the following codes in the console:\ngShaderToy.SetTexture(0, {mSrc:'https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fwww.daoyouz.com%2Fpicture%2Fd226bb18d3ecdfe911006c61018b5bd12.jpg&refer=http%3A%2F%2Fwww.daoyouz.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=auto?sec=1661440055&t=174909216b5007994b516bbc4eec4494', mType:'texture', mID:1, mSampler:{ filter: 'mipmap', wrap: 'repeat', vflip:'true', srgb:'false', internal:'byte' }});\ngShaderToy.SetTexture(1, {mSrc:'https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fh.shanse8.com%2Fattachment%2Fphoto%2FMon_1207%2F5665_96e613415040362e27cb94c335597.jpg&refer=http%3A%2F%2Fh.shanse8.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=auto?sec=1661438153&t=0045565b74383152f6bc22a38eaf630f', mType:'texture', mID:1, mSampler:{ filter: 'mipmap', wrap: 'repeat', vflip:'true', srgb:'false', internal:'byte' }});\ngShaderToy.SetTexture(2, {mSrc:'https://img1.baidu.com/it/u=3518576466,2235478798&fm=253&fmt=auto&app=138&f=JPEG?w=238&h=100', mType:'texture', mID:1, mSampler:{ filter: 'mipmap', wrap: 'repeat', vflip:'true', srgb:'false', internal:'byte' }});\ngShaderToy.SetTexture(3, {mSrc:'https://gimg2.baidu.com/image_search/src=http%3A%2F%2Ffilescdn.proginn.com%2F376c7713ff32590a655f54b345cfcc43%2Fd6d2bb5e96064fcfd5c0f7a4d563f5cb.webp&refer=http%3A%2F%2Ffilescdn.proginn.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=auto?sec=1661439895&t=c280180b0b49d029b2441f4af2010f4f', mType:'texture', mID:1, mSampler:{ filter: 'mipmap', wrap: 'repeat', vflip:'true', srgb:'false', internal:'byte' }});\n*/\n\nconst float rotationspeed_Neptune = 1.0 / 10.0;\nconst float rotationspeed_Earth = 1.0 / 10.0;\nconst float rotationspeed_Venus = 1.0 / 10.0;\nconst float rotationspeed_Mars = 1.0 / 10.0;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float u = fragCoord.x / iResolution.x;\n    float v = fragCoord.y / iResolution.y;\n    if(u < 0.5 && v < 0.5) fragColor = texture(iChannel0, vec2(fract(u * 2.0 + iTime * rotationspeed_Neptune), v * 2.0));\n    if(u >= 0.5 && v < 0.5) fragColor = texture(iChannel1, vec2(fract((u - 0.5) * 2.0 + iTime * rotationspeed_Earth), v * 2.0));\n    if(u < 0.5 && v >= 0.5) fragColor = texture(iChannel2, vec2(fract(u * 2.0 + iTime * rotationspeed_Venus), (v - 0.5) * 2.0));\n    if(u >= 0.5 && v >= 0.5) fragColor = texture(iChannel3, vec2(fract((u - 0.5) * 2.0 + iTime * rotationspeed_Mars), (v - 0.5) * 2.0));\n}","name":"Buffer B","description":"","type":"buffer"}]}