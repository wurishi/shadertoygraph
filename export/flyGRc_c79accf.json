{"ver":"0.1","info":{"id":"flyGRc","date":"1638042307","viewed":136,"name":"Edge detection demo","username":"aviii","description":"edge detection and cel shading","likes":0,"published":1,"flags":32,"usePreview":0,"tags":["edgeshader","celshader"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n#define PI acos(-1.)\n#define edgeColor vec4(0., 0., 0., 1.)\n#define SHADES 4\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    float xWidth = 3.;\n    float yWidth = 3.;\n    vec2 dx = vec2(xWidth / iResolution.x, 0.);\n    vec2 dy = vec2(0., yWidth/ iResolution.y);\n\n    vec4 gradientInfo = texture(iChannel0, uv);\n    float amplitude = gradientInfo.x;\n    vec2 G = gradientInfo.yz;\n    float theta = gradientInfo.w;\n\n    float localMax = 0.;\n    if ((theta < 0.125 * PI && theta > -0.125 * PI) ||\n        (theta > 0.875 * PI || theta < -0.875 * PI))\n    {\n        localMax = max(localMax, texture(iChannel0, uv + dx).x);\n        localMax = max(localMax, texture(iChannel0, uv - dx).x);\n    }\n    if ((theta > 0.125 * PI && theta < 0.365 * PI) ||\n       (theta > -0.875 * PI && theta < -0.625 * PI))\n    {\n        localMax = max(localMax, texture(iChannel0, uv - dx - dy).x);\n        localMax = max(localMax, texture(iChannel0, uv + dx + dy).x);\n    }\n    if ((theta > 0.375 * PI && theta < 0.625 * PI) ||\n        (theta < -0.375 * PI && theta > -0.625 * PI))\n    {\n        localMax = max(localMax, texture(iChannel0, uv - dy).x);\n        localMax = max(localMax, texture(iChannel0, uv + dy).x);\n    }\n    if ((theta > 0.625 * PI && theta < 0.875 * PI) ||\n        (theta > -0.365 * PI && theta < -0.125 * PI))\n    {\n        localMax = max(localMax, texture(iChannel0, uv + dx - dy).x);\n        localMax = max(localMax, texture(iChannel0, uv - dx + dy).x);\n    }\n\n    if (gradientInfo.x < localMax)\n    {\n        gradientInfo.x = 0.;\n        gradientInfo.y = 0.;\n        gradientInfo.z = 0.;\n    }\n    \n    //gradientInfo = texture(iChannel0, uv);\n    \n    gradientInfo = 1. - gradientInfo;\n    gradientInfo.w = 1.;\n    vec4 text = texture(iChannel1 , uv);\n    \n    \n    vec4 finalColor = (1. - gradientInfo) * edgeColor + gradientInfo * text;\n    fragColor = vec4(finalColor);\n    \n    //fragColor = texture(iChannel1 , uv);\n    \n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float Pi = 6.28318530718;\n    \n    float Directions = 20.0;\n    float Quality = 3.0;\n    float Size = 6.0;\n   \n    vec2 Radius = Size/iResolution.xy;\n    \n    vec2 uv = fragCoord/iResolution.xy;\n    vec4 Color = texture(iChannel0, uv);\n    \n    \n    for( float angle=0.0; angle<Pi; angle+=Pi/Directions)\n    {\n\t\tfor(float i=1.0/Quality; i<=1.0; i+=1.0/Quality)\n        {\n\t\t\tColor += texture( iChannel0, uv+vec2(cos(angle),sin(angle))*Radius*i);\t\t\n        }\n    }\n    \n    \n    Color /= Quality * Directions - 15.0;\n    fragColor =  Color;\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"#define emboss mat3(-2, -1, 0, -1, 1, 1, 0, 1, 2)\n#define sobelX mat3(-1, -2, -1, 0, 0, 0, 1, 2, 1)\n#define sobelY mat3(-1, 0, 1, -2, 0, 2, -1, 0, 1)\n#define gaussian mat3(0.0625,0.125,0.0625,0.125,0.25,0.125,0.0625,0.125,0.0625)\nvec2 kpos(int index)\n{\n    return vec2[9] (\n    \tvec2(-1, -1),    \n        vec2(0, -1),\n        vec2(1, -1),\n        vec2(-1, 0),\n        vec2(0, 0),\n        vec2(1, 0),\n        vec2(-1, 1),\n        vec2(0, 1),\n        vec2(1, 1)\n    )[index] / iResolution.xy;\n}\n\nmat3[3] region3x3(sampler2D sampler, vec2 uv)\n{\n    // Create each pixels for region\n    vec4[9] region;\n    \n    //\n    for (int i = 0; i < 9; i++)\n        region[i] = texture(sampler, uv + kpos(i));\n\n    // Create 3x3 region with 3 color channels (red, green, blue)\n    mat3[3] mRegion;\n    \n    for (int i = 0; i < 3; i++)\n        mRegion[i] = mat3(\n        \tregion[0][i], region[1][i], region[2][i],\n        \tregion[3][i], region[4][i], region[5][i],\n        \tregion[6][i], region[7][i], region[8][i]\n    \t);\n    \n    return mRegion;\n\n}\n\nvec3 convolution(mat3 kernel, sampler2D sampler, vec2 uv)\n{\n    vec3 fragment;\n    \n    // Extract a 3x3 region centered in uv\n    mat3[3] region = region3x3(sampler, uv);\n    \n    // for each color channel of region\n    for (int i = 0; i < 3; i++)\n    {\n        // get region channel\n        mat3 rc = region[i];\n        \n        // component wise multiplication of kernel by region channel\n        mat3 c = matrixCompMult(kernel, rc);\n        \n        // add each component of matrix\n        float r = c[0][0] + c[1][0] + c[2][0]\n                + c[0][1] + c[1][1] + c[2][1]\n                + c[0][2] + c[1][2] + c[2][2];\n        \n        // for fragment at channel i, set result\n        fragment[i] = r;\n    }\n    \n    return fragment;    \n\n}\n\nvec3 postConvulsion(mat3 kernel, mat3 picture)\n{\n    vec3 fragment;\n    mat3 c = matrixCompMult(kernel, picture);\n    float r = c[0][0] + c[1][0] + c[2][0]\n                + c[0][1] + c[1][1] + c[2][1]\n                + c[0][2] + c[1][2] + c[2][2];\n    return vec3(r);\n}\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    \n    \n    \n    vec3 colX = convolution(sobelX, iChannel0,uv);\n    vec3 colY = convolution(sobelY, iChannel0,uv);\n    \n    vec3 col=vec3(dot(colX,colX)+dot(colY,colY));\n    \n    //vec3 col = convolution(gaussian, iChannel0, uv);\n    \n    //vec4 color = texture(iChannel0,uv);\n    //col = vec3(color.r,color.g,color.b);\n    fragColor = vec4(col,1.0f);\n    \n    //fragColor = texture(iChannel1,uv);\n}\n\n\n   ","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"XdfGRr","filepath":"/media/a/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm","previewfilepath":"/media/ap/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm","type":"video","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    fragColor = texture(iChannel0 , uv);\n}","name":"Buffer C","description":"","type":"buffer"}]}