{"ver":"0.1","info":{"id":"MdScDy","date":"1493583159","viewed":124,"name":"Mandelbrot : External Ray","username":"JCDjcd","description":"External rays are orthogonal to the Douady-Hubbard equipotential lines.","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["fractal","ray","mandelbrot","external"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//--------------------------------------------------------------------------\nvec2 iteration(vec2 z,vec2 c)\n{\n\tfloat x = z.x*z.x-z.y*z.y + c.x;\n    float y = 2.0*z.x*z.y + c.y;\n    return vec2(x,y);\n} // iteration()\n\n//--------------------------------------------------------------------------\nvec4 compute(vec2 c)\n{\n    vec2 \tz \t= c;\n    int \tn\t= 1000; // max\n    float   p   = 0.0;\n    float   q   = 0.0;\n    int \ti;\n    for(i=0;i<n;i++)\n    {\n        // Write p and q in binary, each bit tells what half-plan the current point belongs to.\n        // For p: left or right half-plans.\n        // For q: top or bottom half-plans.\n        if(z.x > 0.0)\n            p += pow(0.5,float(i));\n        if(z.y > 0.0)\n            q += pow(0.5,float(i));\n        \n        if(z.x*z.x+z.y*z.y > 4.0)\n        {\n            break;\n        }\n        z = iteration(z,c);\n    } // for()\n    \n    if(i < n)\n    {\n        int n_diverging = 4;\n        int j;\n        for(j=0;j<n_diverging;j++)\n        {\n            if(z.x > 0.0)\n                p += pow(0.5,float(i));\n            if(z.y > 0.0)\n                q += pow(0.5,float(i));\n            z = iteration(z,c);\n        } // for()\n        float logV = log(log(z.x*z.x+z.y*z.y))-float(i+n_diverging+1)*log(2.0);\n\n        if(cos(10.0*logV)>0.95 && i < 15)\n        {\n\t        // put white pixel on equipotential lines\n            return vec4(1.0,1.0,1.0,1.0);\n        }\n        else\n        {\n            // show external rays\n            float r = 0.5+0.5*sin(q*1000.0*3.1415926535);\n            float g = 0.5+0.5*cos(q*1000.0*3.1415926535);\n            float b = 0.5+0.5*cos(p*1000.0*3.1415926535);\n            return vec4(r,g,b,1.0);\n        }\n    }\n    else\n    {\n    \treturn vec4(0.0,0.0,0.0,1.0);\n    }\n} // compute()\n\n//--------------------------------------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Get min/max of the resolution (in most case the width).\n    float m \t= min(iResolution.x,iResolution.y);\n    float M \t= max(iResolution.x,iResolution.y);\n    vec2 uv \t= ((fragCoord.xy-0.5*iResolution.xy) / m)*3.0-vec2(8.5,-1.5);\n    float beta \t= 0.5*iTime*2.0*3.1415926535/9.0;\n    float scale = (3.0+2.0*(0.5+0.5*cos(beta)))/0.5;\n    uv \t\t\t= vec2(uv.x/scale,uv.y/scale);\n    fragColor \t= compute(uv);\n} // mainImage()\n\n\n\n","name":"Image","description":"","type":"image"}]}