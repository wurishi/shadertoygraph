{"ver":"0.1","info":{"id":"3sXcRj","date":"1585143771","viewed":209,"name":"Gained Gradient Noise","username":"raabix","description":"This is a variation on the classical noise. I love noise and I would like to see more creativity when creating it. So this is my take. \nCLIOK AND DRAG THE MOUSE TO MODIFY NOISE PARAMETERS\nLeft: Classical FBM Noise\nRight: Gained pow FBM noise","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["procedural","noise","texture","gained"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*  \n    This is my take on making an FBM noise that is more interesting by adding some\n    variation to it. This makes it more uneven and gets rid of the cloudy look which\n    is nice, but not always desired. Instead, I am adding variation to the intensities\n    of the gradients using a pow-function.\n\n\tMouse-x: Octaves of noise\n    Mouse-y: Power of variation of intensities\n\n\tLeft view:  The output of the noise function\n\tRight view: Smoothstepping the output to extract a range\n\n\tNOTES:\n\t> The right side of the view applies a simple boxfiltered antialiasing which you can\n      basically turn off by setting BOXFILTER_SAMPLES to 1.0\n\t> The gradient of the noise is being animated with time, so you get a morphing\n\t  effect of the which I found interesting.\n\n\tCHECK OUT\n    *********\n\n\tVanilla FBM explorer:        https://www.shadertoy.com/view/tdlyz4\n    Noise -gradient 2d by IQ:    https://www.shadertoy.com/view/XdXGW8\n\n*/\n\n\n#define DO_ROTATE         true  \n#define BOXFILTER_SAMPLES 2.0\n#define PI                3.14159265359\n\n// Hashes by Dave Hoskins\n// https://www.shadertoy.com/view/4djSRW\n//----------------------------------------------------------------------------------------\n///  2 out, 2 in...\nvec2 hash22(vec2 p)\n{\n\n    vec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\n\nfloat gainf(float x, float k) \n{\n    //remap k, so k is driven by 0...1 range\n    k = k < 0.5 ? 2.*k : 1./(1.-(k-0.5)*2.);\n    float a = 0.5*pow(2.0*((x<0.5)?x:1.0-x), k);\n    return (x<0.5)?a:1.0-a;\n}\n\n// performs a golden-ratio rotation\nvec2 rot_golden(vec2 pos,vec2 uv)\n{\n    // golden/ration in radians: 3.883222072739204862525004958380\n    float sine   = -0.67549029078724183023998;\n    float cosine = -0.73736888126104662389070;\n    mat2 rot = mat2(cosine, -sine, sine, cosine);\n    uv -= pos; \n    uv = rot * uv  ;\n    return uv + pos;\n}\n\n\nfloat gradnoise_random(vec2 uv)\n{\n    vec2 p = floor(uv),\n        f = (fract(uv));\n    \n    vec2 u = f*f*f*(6.0*f*f - 15.0*f +10.0);  // from Ken Perlin's improved noise\n    //vec2 u = f*f*(3.-2.*f);                 // simpler formula (s-curve)\n    float dot1, dot2, dot3, dot4;\n    \n    dot1 = dot(2.*(hash22(p)) - 1.0, f);\n    dot2 = dot(2.*(hash22(p + vec2(1., 0.)))-1.0 , f - vec2(1.,0.));\n    dot3 = dot(2.*(hash22(p + vec2(0., 1.)))-1.0, f - vec2(0.,1.));\n    dot4 = dot(2.*(hash22(p + vec2(1., 1.)))-1.0, f - vec2(1.,1.));\n   \n    float m1, m2;\n    \n    m1 = mix(dot1, dot2, u.x);\n    m2 = mix(dot3, dot4, u.x);\n    \n    return mix(m1, m2, u.y);\n}\n\n// This gradient noise makes sure gradients lie on the unit-circle and it \nfloat gradnoise_circular(vec2 uv, float power)\n{\n    vec2 p = floor(uv),\n        f = (fract(uv));\n    \n    vec2 u = f*f*f*(6.0*f*f - 15.0*f +10.0);\n    //vec2 u = f*f*(3.-2.*f);\n    float dot1, dot2, dot3, dot4;\n    \n    vec2 hash00, hash10, hash01, hash11;\n    vec2 grad00, grad10, grad01, grad11;\n  \n    hash00 = hash22(p);\n    hash01 = hash22(p + vec2(0., 1.));\n    hash10 = hash22(p + vec2(1., 0.));\n    hash11 = hash22(p + vec2(1., 1.));\n\n    // Calculate gradients. The sin and cos part makes sure that the gradient vectors are\n    // unit length. Since the hash values range from 0...1 we need to bring them in the\n    // range of 2 PI which describes a whole circle, so gradient vectors point in any\n    // possible direction.\n    // The pow function at the end is what makes the intensities of the gradients more\n    // uneven, so we get a more irregular pattern of the noise. If the 'power' value gets \n    // too high, the noise starts looking bad though.\n    // One could\n \t//Gradients shall lie on the unit circle\n    grad00 = vec2(sin(hash00.x * PI * 2. + iTime), cos(hash00.x * PI * 2. + iTime)) * (pow(hash00.y, power));\n    grad01 = vec2(sin(hash01.x * PI * 2. + iTime), cos(hash01.x * PI * 2. + iTime)) * (pow(hash01.y, power));\n    grad10 = vec2(sin(hash10.x * PI * 2. + iTime), cos(hash10.x * PI * 2. + iTime)) * (pow(hash10.y, power));\n    grad11 = vec2(sin(hash11.x * PI * 2. + iTime), cos(hash11.x * PI * 2. + iTime)) * (pow(hash11.y, power));\n    \n    dot1 = dot(grad00, f);\n    dot2 = dot(grad10, f - vec2(1.,0.));\n    dot3 = dot(grad01, f - vec2(0.,1.));\n    dot4 = dot(grad11, f - vec2(1.,1.));\n  \n /*   Classic approach\n    dot1 = dot((hash22(p)), f);\n    dot2 = dot((hash22(p + vec2(1., 0.))) , f - vec2(1.,0.));\n    dot3 = dot((hash22(p + vec2(0., 1.))) , f - vec2(0.,1.));\n    dot4 = dot((hash22(p + vec2(1., 1.))) , f - vec2(1.,1.));\n*/    \n    float m1, m2;\n    \n    m1 = mix(dot1, dot2, u.x);\n    m2 = mix(dot3, dot4, u.x);\n   \n   // return abs(box_mueller_transform(hash00)).x;\n    return mix(m1, m2, u.y);\n}\n\nvec2 calc_pos_width(float pos, float width)\n{\n    float low, high;\n    \n    low = pos - width/2.0;\n    high = pos + width/2.0;\n    return clamp(vec2(low, high), vec2(0.0), vec2(1.0));\n}\n\nfloat oct_gained_gradnoise(vec2 uv, float octaves, float roughness, float octscale, float power)\n{\n    float a = 0.;\n    float intensity = 1.;\n    float oct_intensity = 1.0; // first intensity is 1.0, successive octaves get scaled by roughness value\n    float total_scale = 0.0;\n    float remap;\n\n    float contrast = 0.999;\n    float gain = .00111;\n\n    for(float i = 0.; i < octaves; i++)\n    {\n        float gradnoise_lookup = gradnoise_circular(uv, power)*1.75;\n        \n        remap = gradnoise_lookup;\n        remap = gainf((gradnoise_lookup*.5 + .5), gain);\n       // remap = gainf(clamp((gradnoise_lookup*.5 + .5), 0.0, 1.0), gain);\n        remap = ((remap - 0.5) * 2.); \n        \n\t\ttotal_scale += oct_intensity;\n        a += remap* oct_intensity;\n        oct_intensity*= roughness; // get intensity for current octave\n        \n        if(DO_ROTATE)\n        \tuv = rot_golden(vec2(11.1231, 11.1231), uv) * octscale;\n        else\n        \tuv = uv * octscale;\n    }\n    // applying contrast and clamping it\n\t\n    a = (a/(1.0 -contrast)) ;\n    a= clamp(a/total_scale, -1., 1.0);\n    return a; // if we were dividing just by octaves we'd get an intensity shift\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uvMouse;\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv.x *= iResolution.x/iResolution.y;\n    uv.x += iTime*.1;\n    \n    // check for out of range coords (which happens at the start or after\n    // change of resolution)\n    if (iMouse.xy==vec2(0) )\n        uvMouse = vec2(0.75, 0.5);\n    else\n        uvMouse = (iMouse.xy/iResolution.xy);\n        \n    //if(int(iMouse.xy) == 0 || iMouse.x > iResolution.x || iMouse.y > iResolution.y)\n    //    uvMouse = vec2(0.75, 0.5);\n    //else\n\t//\tuvMouse = (iMouse.xy/iResolution.xy);\n     \n\n    int octaves = int(ceil(uvMouse.x * 10.));\n    float power = uvMouse.y * 6.+.1;\n    float roughness = 1.1; //uvMouse.y*1.5;\n    \n    \n    // Static gradnoise\n    float octscale = 2.0; //factor by which each octave gets smaller than the previous one\n    float final_value;\n    \n    final_value = oct_gained_gradnoise(uv * 2., float(octaves), roughness, octscale, power);\n    \n    \n    //antialiasing\n    /*\n\tfloat acc = 0.;\n    for(float i = 0.; i < AA; i++)\n        for(float j = 0.; j < AA; j++)\n        {\n            acc += oct_gained_gradnoise((uv + vec2(i*step_size.x, j*step_size.y)) * 2., float(octaves), roughness, octscale);\n         }\n\tacc /= AA*AA ;    \n*/\n   // final_value = acc;\n    final_value = final_value*0.5 + 0.5;\n    \n    \n    \n    if(fragCoord.x > iResolution.x/2.)\n    {\n        vec2 low_high = calc_pos_width(sin(iTime * .5)*.3 + .3, sin(iTime*.43321578)*.35 + .4);\n        \n        //antialiasing  \n   \t\tfloat AA = BOXFILTER_SAMPLES;\n        vec2 pixel_size = vec2(1.)/iResolution.xy;\n        vec2 step_size = pixel_size/AA * 1.5;\n        float acc = 0.;\n\t\tfloat lookup = 0.0;\n        for(float i = 0.; i < AA; i++)\n            for(float j = 0.; j < AA; j++)\n            {\n                lookup = oct_gained_gradnoise((uv + vec2(i*step_size.x, j*step_size.y)) * 2., float(octaves), roughness, octscale, power);\n\t\t\t\tacc += smoothstep(low_high.x, low_high.y, lookup);\n             }\n        acc /= AA*AA ;    \n    \tfinal_value = acc;\n        \n        \n       \n    }\n\n  \n    if(mod(fragCoord.x, iResolution.x /2.) < 1.)\n\t\tfinal_value = 0.;\n\n    fragColor = vec4(final_value);\n}","name":"Image","description":"","type":"image"}]}