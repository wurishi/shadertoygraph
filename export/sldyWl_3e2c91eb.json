{"ver":"0.1","info":{"id":"sldyWl","date":"1660878371","viewed":326,"name":"The man, earth, and the Gamma","username":"harry7557558","description":"This is a random idea that came into my mind.\nThe man, the earth, and the graph of the Gamma function.\nWhat's beyond them?\n[mouse-able]","likes":27,"published":1,"flags":32,"usePreview":0,"tags":["earth","gamma","human","neural"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// This is a random idea that came into my mind.\n\n// The man, the earth, and the graph of the Gamma function.\n// What's beyond them?\n\n// Modeling in Common.\n// Rendering in Buffer A.\n\n// Mouse-able.\n\nvoid mainImage(out vec4 c, in vec2 g) {\n    vec3 col = texelFetch(iChannel0, ivec2(g), 0).xyz;\n    c = vec4(pow(col, vec3(.4545)), 1);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// Modeling\n\n\n#define PI 3.1415927\nint ZERO;  // reduce compile time\n\n\n// Bounding box intersection\nvec2 intersectBox(vec3 r, vec3 ro, vec3 rd) {\n    vec3 inv_rd = 1./rd;\n    vec3 n = inv_rd*(ro), k = abs(inv_rd)*r;\n    vec3 t1 = -n - k, t2 = -n + k;\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n    if(tN>tF || tF<0.) return vec2(-1);\n    return vec2( tN, tF );\n}\n\n\n\n/* EARTH */\n\n#define sigmoid(x) (1./(1.+exp(-(x))))\n\n// Color, neural network\n// https://github.com/harry7557558/Graphics/blob/master/fitting/neural-earth.ipynb\nvec3 mapEarth(vec3 p) {\n  // (12, 3) (12,)\n  vec4 v00 = sin(vec4(2.18,2.07,-.05,.04)*p.x+vec4(-1.16,2.08,1.81,-.2)*p.y+vec4(-.05,.05,-.81,-.96)*p.z+vec4(.59,-.09,-.03,-.77));\n  vec4 v01 = sin(vec4(-.53,.36,.87,-1.57)*p.x+vec4(-1.84,-2.31,-.71,1.15)*p.y+vec4(.53,.02,-1.08,-.41)*p.z+vec4(.16,.15,-.68,-.43));\n  vec4 v02 = sin(vec4(.75,-2.02,-.46,2.03)*p.x+vec4(-.64,1.16,-.56,-.29)*p.y+vec4(.75,.47,-.6,-.91)*p.z+vec4(-.69,-.53,.98,-.8));\n  // (12, 12) (12,)\n  vec4 v10 = sin(mat4(-1.98,2.1,-.12,-.7,-.17,.55,.35,-1.75,-.92,-.03,-.79,1.02,.21,-1.14,.01,1.08)*v00+mat4(-.27,2.59,-.41,.37,-1.55,-.59,-1.15,.88,.8,.8,0,.19,.22,1.48,.66,.49)*v01+mat4(-1.7,-1.18,1.5,.63,-1.35,1.04,-.39,-.32,.68,2.29,-.28,-.68,-2.15,-1.66,-.37,-1.34)*v02+vec4(-.22,-.5,-.02,1.34));\n  vec4 v11 = sin(mat4(1.09,1.62,-.72,2.4,.74,-.86,2.04,-.07,.65,-.85,1.16,.34,-1.85,1.28,1.14,.3)*v00+mat4(2.43,-2.37,1.71,-2.44,-.74,.51,-1.83,1.02,-.28,-.2,-2.83,1.08,-1.04,.83,.33,1.27)*v01+mat4(.05,-.43,-.77,1.04,1.77,1.44,-2.19,1.4,-3.9,1.1,1.22,1.57,.48,.55,2.61,1.01)*v02+vec4(-.4,.69,-2.1,-.43));\n  vec4 v12 = sin(mat4(-.15,.75,1.32,-.29,-.18,.21,.01,-2.14,.95,-1.85,1.95,-2.53,.94,.54,1.2,1.19)*v00+mat4(.31,-.66,1.91,-1.75,.87,-1.56,1.28,1.72,-.07,-1.4,-1.21,-.07,.96,-.56,-.28,1.24)*v01+mat4(.93,-1.07,2.83,-1.15,-1.29,1.83,1.59,-.15,2.55,-1.7,-2.03,-2.1,.26,-.5,1.05,-.01)*v02+vec4(-1.11,.33,3.23,2.4));\n  // (12, 12) (12,)\n  vec4 v20 = sin(mat4(-1.22,1.04,-.4,.05,.61,-1.16,-1.25,-.9,-.41,-.48,-1.4,.6,-1.37,.45,-.1,-1.82)*v10+mat4(-.53,-1.64,1.07,-.02,1.93,.9,.55,-2.21,1.2,1.01,-.92,-.92,.46,.11,-1.88,-2.65)*v11+mat4(-1.03,.62,-1.22,-.89,-2.27,-.92,-.59,.02,-.43,-1.38,2.93,1.32,2.02,.84,-.57,.91)*v12+vec4(-.6,.73,-1.59,.64));\n  vec4 v21 = sin(mat4(-3.2,.97,-.82,-.94,.42,-.26,-1.6,1.28,-.26,-2.17,.28,1.62,1.6,-.63,-1.1,.57)*v10+mat4(.81,1.76,-1.23,-1.59,-1.88,-.75,-.9,.13,-2.21,1.07,-.39,-1.54,-3.04,.5,-.56,-2.26)*v11+mat4(-.98,-.73,.83,-2.97,-1.61,-.3,1.55,-2.04,1.46,.09,-.13,.88,-.18,.5,-.43,-.2)*v12+vec4(-.08,-2.18,-1.3,1.15));\n  vec4 v22 = sin(mat4(2,.27,.01,-.38,-.11,-.9,.38,-1.35,.3,3.89,-.1,.9,-1.36,-.66,-.52,-.22)*v10+mat4(-.09,-.52,.42,.15,2.85,.16,-.53,-1.15,.27,.32,.81,1.42,-.6,-.22,1.11,2.13)*v11+mat4(-1.96,-1.06,.06,.68,-.58,-1.41,.43,.43,-1.77,-.66,-1.72,-1.22,.19,1.11,1.15,.24)*v12+vec4(.05,.85,-.72,-1.05));\n  // (8, 12) (8,)\n  vec4 v30 = sigmoid(mat4(3.74,2.98,-2.85,1.67,2.69,2.42,-2,2.01,-6.28,-1.99,4.83,-1.36,-5.06,-3.07,1.08,-6.41)*v20+mat4(-2.42,-.87,1.32,-.82,1.25,-6.41,-.49,-5.09,-.04,-.47,3.35,6.26,-3.75,-5.87,3.62,-3.36)*v21+mat4(-4.54,.41,-1.18,-3.14,-8.28,-.79,7.43,-2.98,8.06,-2.25,3.2,.48,-7.99,-3.18,1.12,-7.99)*v22+vec4(5.54,1.15,-2.06,2.02));\n  vec4 v31 = sigmoid(mat4(4.2,-6.97,1.37,2.04,3.42,.97,4.22,1.71,-6.85,2.56,-4,-2.37,-2.77,-2.33,.46,-1.98)*v20+mat4(-2.43,1.87,-2.57,-1.06,-6.1,3.38,-2.83,-2.97,.16,9.4,-4.07,-.43,-4.72,4.07,-3.46,-3.17)*v21+mat4(-1.52,5.93,-1.74,-.6,-3.53,-1.03,-2.08,-1.59,-2.03,6.98,-.7,-.64,-5.34,2.52,-2.22,-2.92)*v22+vec4(.07,-4.84,.67,.98));\n  // (3, 8) (3,)\n  float v40 = sigmoid(dot(vec4(-.93,-3.13,1.01,-1.07),v30)+dot(vec4(-1.65,2.54,-1.78,5.45),v31)+.43);\n  float v41 = sigmoid(dot(vec4(-.26,-2.16,.86,-.87),v30)+dot(vec4(-1.08,2.09,-1.23,3.8),v31)+.01);\n  float v42 = sigmoid(dot(vec4(1.31,-1.13,.97,-.65),v30)+dot(vec4(-.61,1.37,-1.19,2.14),v31)+-.71);\n  return vec3(v40, v41, v42);\n}\n\n// Sphere intersection function\nbool intersectSphere(float r, vec3 ro, vec3 rd,\n        inout float t, inout vec3 n) {\n    float b = -dot(ro, rd), c = dot(ro, ro) - r * r;\n    float delta = b * b - c;\n    if (delta < 0.) return false;\n    delta = sqrt(delta);\n    float t1 = b - delta, t2 = b + delta;\n    if (t1 > t2) t = t1, t1 = t2, t2 = t;\n    if (t1 > t || t2 < 0.) return false;\n    t = t1 > 0. ? t1 : t2;\n    n = normalize(ro + rd * t);\n    return true;\n}\n\nconst vec3 EARTH_CENTER = vec3(-1.5, -3.5, 1);\n\n\n\n/* GAMMA */\n\n// Gamma function\n// From \"Zeta in a box\" by guil, https://www.shadertoy.com/view/7ltcW8\nvec2 cmul(vec2 a, vec2 b)  { return vec2(a.x*b.x - a.y*b.y, a.x*b.y + a.y*b.x); }\nvec2 cinv(vec2 z) { return vec2(z.x,-z.y)/dot(z,z); }\nvec2 cdiv(vec2 a, vec2 b)  { return cmul(a, cinv(b)); }\nvec2 cexp(vec2 z) { return exp(z.x)*vec2(cos(z.y), sin(z.y)); }\nvec2 clog(vec2 z) { return vec2(.5*log(dot(z,z)), atan(z.y,z.x)); }\nvec2 cpow(vec2 a, vec2 b) { return cexp(cmul(b,clog(a))); }\nvec2 gamma0(vec2 z) {\n    const float N = 8.;\n    float c = sqrt(2.*PI);\n\tvec2 s = vec2(c, 0);\n    float f = 1.;\n\tfor(float k=1.; k<N; k++){\n\t\tc = exp(N-k)*pow(N-k,k-.5)/f;\n        f *= -k;\n        s += cinv(z+vec2(k,0.))*c;\n\t}\n\ts = cmul(s,cmul(cexp(-z-vec2(N,0)),cpow(z+vec2(N,0),z+vec2(.5,0))));\n    return cdiv(s,z);\n}\nfloat gamma(vec2 z) {\n    vec2 c = gamma0(z);\n    return min(length(c), 4.5);\n}\n\n// Robust raymarching from\n// https://harry7557558.github.io/tools/raymarching-implicit/index.html\n// Still slow?\nfloat raymarchGamma(vec3 ro, vec3 rd) {\n    vec2 t01 = intersectBox(vec3(5, 4, 3), ro-vec3(-.5,-1,2.5), rd);\n    float t0 = t01.x, t1 = t01.y;\n    t0 = max(t0, .1);\n    if (t1 < t0) return -1.;\n    // https://www.desmos.com/calculator/mhxwoieyph\n    float t = t0, dt = .1;\n    float v = 0., v0 = v, v00 = v;\n    float dt0 = 0., dt00 = 0.;\n    int i = ZERO;\n    for (; i < 64 && t < t1; t += dt, i++) {\n        vec3 p = ro+rd*t;\n        float STEP_SIZE = max(min(min(abs(p.y)-.3,abs(p.x-4.)-.5),10.*abs(p.z)+.1), .1);\n        v = p.z-gamma(p.xy);\n        if (v*v0 < 0.) break;  // intersect\n        if (isnan(dt0) || dt0 <= 0.) v00 = v, v0 = v, dt0 = dt00 = 0.;\n        float g = dt0 > 0. ? ( // estimate gradient\n            dt00 > 0. ? // quadratic fit\n                v00*dt0/(dt00*(dt0+dt00))-v0*(dt0+dt00)/(dt0*dt00)+v*(2.*dt0+dt00)/(dt0*(dt0+dt00))\n                : (v-v0)/dt0  // finite difference\n        ) : 0.;\n        dt = (isnan(g) || g==0.) ? STEP_SIZE :\n            clamp(abs(v/g)-STEP_SIZE, .2*STEP_SIZE, STEP_SIZE);\n        dt *= .9;\n        dt00 = dt0, dt0 = dt, v00 = v0, v0 = v;\n    }\n    if (v*v0 >= 0.) return -1.;  // no intersection\n    return t - dt * v / (v - v0);  // linear interpolation\n}\n\n\n\n/* Human */\n\nfloat sdSegment(vec3 p, vec3 a, vec3 b) {\n    vec3 pa = p-a, ba = b-a;\n    float h = dot(pa,ba)/dot(ba,ba);\n    return length(pa - ba*clamp(h, 0., 1.));\n}\n\nfloat mapHuman(vec3 p) {\n    p *= 2.8;\n    p.xy = mat2(.9,.4,-.4,.9)*p.xy;\n    p.x = abs(p.x);\n    float leg = sdSegment(p, vec3(.12,0,.05), vec3(.1,0,.5)) - .05;\n    float body = sdSegment(p, vec3(.05,0,.55), vec3(.06,0,1.0)) - .08;\n    float arm = sdSegment(p, vec3(.1,0,1.), vec3(.3,-.15,.7)) - .04;\n    float head = length(p-vec3(0,-.02,1.2))-.15;\n    return min(min(arm,leg),min(body,head))/2.8;\n}\nvec3 gradHuman(vec3 p, float h) {\n\tfloat a = mapHuman(p+vec3(h,h,h));\n\tfloat b = mapHuman(p+vec3(h,-h,-h));\n\tfloat c = mapHuman(p+vec3(-h,h,-h));\n\tfloat d = mapHuman(p+vec3(-h,-h,h));\n\treturn (.25/h)*vec3(a+b-c-d,a-b+c-d,a-b-c+d);\n}\n\nfloat intersectHuman(vec3 ro, vec3 rd) {\n    float t = 0.;\n    for (int i=ZERO; i<32; i++) {\n        float dt = mapHuman(ro+rd*t);\n        if (dt < 0.) return t+.5*dt;\n        dt = max(dt, 0.01);\n        t += dt;\n        if (t > 40.) return -1.;\n    }\n    return t;\n}\n\nconst vec3 HUMAN_CENTER = vec3(EARTH_CENTER.xy-vec2(-1.2,.5),0);\n\n\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Path tracing\n\n\n// Random number generator\nuint seed = 0u;\nuint randu() { return seed = seed * 1664525u + 1013904223u; }\nfloat randf() { return float(randu()) / 4294967296.; }\n\n\n\n// Faked multi-scattering BRDF\nvec3 sampleBrdf(\n    vec3 wi, vec3 n,\n    float alpha,  // roughness\n    float f0,  // ratio of reflection along the normal\n    vec3 albedo,\n    inout vec3 m_col\n    ) {\n\n    vec3 u = normalize(cross(n, vec3(1.23, 2.34, -3.45)));\n    vec3 v = cross(u, n);\n    wi = vec3(dot(wi, u), dot(wi, v), dot(wi, n));\n    vec3 wi0 = wi, wo, m;  // in, out and half vector\n\n    // generate output ray\n    for (int i = 0; i < 4; i++) {\n        // generate a random GGX normal\n        float su = 2.*PI*randf();\n        float sv = randf();\n        sv = atan(alpha*sqrt(sv/(1.-sv)));\n        vec3 h = vec3(sin(sv)*vec2(cos(su),sin(su)), cos(sv));\n        // reflect it about the GGX normal\n        wo = -(wi-2.*dot(wi,h)*h);\n        // if below surface, set it as the new in vector,\n        // keep bouncing until it gives a good one\n        if (wo.z < 0.) wi = -wo;\n        else break;\n    }\n    wo.z = abs(wo.z);  // prevent below surface\n    wi = wi0;\n    m = normalize(wi+wo);\n\n    // fresnel\n    float F = mix(pow(1.-dot(wi, m), 5.), 1., f0);\n    m_col *= F * albedo;\n    return wo.x * u + wo.y * v + wo.z * n;\n}\n\n\n\n// Rendering\n\n#define mat_none 0\n#define mat_ground 1\n#define mat_earth 2\n#define mat_human 3\n\nvec3 mainRender(vec3 ro, vec3 rd) {\n\n    vec3 m_col = vec3(1), col;\n\n    for (int iter = ZERO; iter < 8; iter++) {\n        ro += 1e-2*rd;\n        \n        /* Intersection */\n\n        vec3 n, min_n;\n        float t, min_t = 1e3;\n        int mat = mat_none;\n\n        // plane and Γ\n        t = -ro.z / rd.z;\n        if (t > 0.) {\n            min_t = t, min_n = vec3(0, 0, 1);\n            mat = mat_ground;\n        }\n        t = raymarchGamma(ro, rd);\n        if (t > 0. && t < min_t) {\n            vec3 p = ro+rd*t;\n            vec2 g = vec2(gamma(p.xy+vec2(.01,0))-gamma(p.xy-vec2(.01,0)),\n                          gamma(p.xy+vec2(0,.01))-gamma(p.xy-vec2(0,.01)) )/.02;\n            min_t = t, min_n = normalize(vec3(-g,1.));\n            mat = mat_ground;\n        }\n\n        // earth\n        t = min_t;\n        if (intersectSphere(1., ro-EARTH_CENTER, rd, t, n)) {\n            min_t = t, min_n = n;\n            mat = mat_earth;\n        }\n        \n        // human\n        t = intersectHuman(ro-HUMAN_CENTER, rd);\n        if (t > 0. && t < min_t) {\n            min_t = t;\n            min_n = normalize(gradHuman(ro+rd*t-HUMAN_CENTER, .01));\n            mat = mat_human;\n        }\n\n        // update ray\n        ro += rd * (t = min_t);\n        n = faceforward(min_n, rd, min_n);\n\n        /* Shading */\n\n        col = vec3(1);\n        if (mat == mat_none) {  // background\n            col = texture(iChannel1, rd.xzy).xyz;\n            return m_col * col;\n        }\n        if (mat == mat_ground) {  // plane\n            float roughness = mix(.01, .05, smoothstep(0., 1., ro.z));\n            rd = sampleBrdf(-rd, n, roughness, .5, vec3(.9,.9,.95), m_col);\n        }\n        if (mat == mat_earth) {  // earth\n            vec3 ps = ro-EARTH_CENTER;\n            col = mapEarth(vec3(-ps.y,ps.x,ps.z));\n            col = smoothstep(0.,1.,sqrt(col));\n            col = smoothstep(0.,1.,col);  // color adjustment\n            rd = sampleBrdf(-rd, n, .5, 1., col, m_col);\n        }\n        if (mat == mat_human) {  // human\n            rd = sampleBrdf(-rd, n, .5, .3, vec3(.3,.2,.1), m_col);\n        }\n    }\n    return m_col;\n}\n\n\n\n// sample aparture\nvec2 randomUnitDisk() {\n    float a = 2.*PI*randf();\n    return sqrt(randf())*vec2(cos(a), sin(a));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    ZERO = min(iFrame, 0);\n\n    // random number seed\n    vec3 p3 = fract(fragCoord.xyx*1.1031);\n    p3 += dot(p3, p3.zxy + 31.32);\n    float h = fract((p3.x + p3.y) * p3.z);\n    seed = uint(1048576.*h)+uint(iFrame);\n\n    // camera\n    const float SCALE = 2.;  // larger = smaller (more view field)\n    const float DIST = 8.; // larger = smaller\n    const float VIEW_FIELD = .3;  // larger = smaller + more perspective\n    const float APERTURE = .2;  // larger = more blurred\n    \n    float rx = iMouse.z==0.?.01*PI:1.8*(iMouse.y/iResolution.y)-0.2;\n    float rz = iMouse.z==0.?-.69*PI:-4.*PI*iMouse.x/iResolution.x;\n    vec3 w = vec3(cos(rx)*vec2(cos(rz),sin(rz)), sin(rx));\n    vec3 u = vec3(-sin(rz),cos(rz),0);\n    vec3 v = cross(w,u);\n    vec3 ro = DIST*w + EARTH_CENTER+vec3(.5,0,0);\n    vec2 uv = SCALE*(2.*(fragCoord.xy+vec2(randf(),randf())-.5)/iResolution.xy-1.);\n    vec2 sc = iResolution.xy/length(iResolution.xy);\n    vec2 offset = APERTURE*randomUnitDisk();\n    vec3 rd = mat3(u,v,-w)*normalize(vec3(VIEW_FIELD*uv*sc+offset/DIST, 1.));\n    ro -= offset.x*u+offset.y*v;\n\n    // calculate/update pixel color\n    vec3 col = mainRender(ro, rd);\n    col = dot(col,vec3(1))>0. ? col : vec3(0);  // kill NAN\n    vec4 rgbn = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    if (iMouse.z>0.) rgbn.w = 0.;\n    fragColor = vec4((rgbn.xyz*rgbn.w + col)/(rgbn.w+1.), rgbn.w+1.);\n}\n","name":"Buffer A","description":"","type":"buffer"}]}