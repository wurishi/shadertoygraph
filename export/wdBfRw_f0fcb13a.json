{"ver":"0.1","info":{"id":"wdBfRw","date":"1589703551","viewed":180,"name":"#015 infinite torii II","username":"9re","description":"raymarching, bumpmap with gradient noise & voronoi","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["voronoi","fog","bumpmap"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float F = 3.8;\nconst float PI = 3.14159;\nconst vec4 c_pl = vec4(0., 1., 0., 0.);\nconst vec4 c_sp = vec4(1., 1., 1., 0.5);\nconst vec3 c_red_light = vec3(0.8, 0.6, 0.1);\nconst vec3 light_dir_0 = normalize(vec3(1.0, 0.3, -1.));\nconst vec3 c_blue_light = vec3(0.1, 0.3, 0.8);\n//const vec3 c_dir_blue_light = normalize(vec3(0.7, 0.3, -0.9));\nconst float c_max_height = 0.8;\nconst float c_mod = 6.0;\nconst float c_spec = .2;\nconst float c_diffuse = .8;\nconst vec3 c_pavement = vec3(0.5);\n\nvec2 resolution(vec2 p) {\n    vec2 q = 2. * (p / iResolution.xy - .5);\n    q.y *= iResolution.y / iResolution.x;\n    return q;\n}\n\nfloat plane(in vec4 f, in vec3 p)\n{\n    return dot(f.xyz, p) + f.w;\n}\n\n// from Distance Functions - Inigo Quilez\n// https://iquilezles.org/articles/distfunctions\nfloat dot2( vec2 v ) { return dot(v,v); }\n\nfloat box(in vec3 f, in vec3 p)\n{\n  vec3 q = abs(p) - f;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat cappedCone(in float h, in float r1, in float r2, in vec3 p)\n{\n  vec2 q = vec2( length(p.xz), p.y );\n  vec2 k1 = vec2(r2,h);\n  vec2 k2 = vec2(r2-r1,2.0*h);\n  vec2 ca = vec2(q.x-min(q.x,(q.y<0.0)?r1:r2), abs(q.y)-h);\n  vec2 cb = q - k1 + k2*clamp( dot(k1-q,k2)/dot2(k2), 0.0, 1.0 );\n  float s = (cb.x<0.0 && ca.y<0.0) ? -1.0 : 1.0;\n  return s*sqrt( min(dot2(ca),dot2(cb)) );\n}\n\nvec2 torii(in vec3 p, in float time)\n{\n    vec2 d, d1;\n    d = vec2(box(vec3(3.6, 0.3, 0.32), p - vec3(0., 4.3, 0.)), 1.0);\n    d1 = vec2(box(vec3(1.9, 0.2, 0.18), p - vec3(0., 3.5, 0.)), 1.0);\n    if (d.x > d1.x) {\n        d = d1;\n    }\n    d1 = vec2(cappedCone(3.8, .25, .2, p - vec3(-2., 0.2, 0.)), 1.0);\n    if (d.x > d1.x) {\n        d = d1;\n    }\n    d1 = vec2(cappedCone(3.8, .25, .2, p - vec3(2., 0.2, 0.)), 1.0);\n    if (d.x > d1.x) {\n        d = d1;\n    }\n    d1 = vec2(cappedCone(.2, .25, .25, p - vec3(-2., 0., 0.)), 2.0);\n    if (d.x > d1.x) {\n        d = d1;\n    }\n    d1 = vec2(cappedCone(.2, .25, .25, p - vec3(2., 0., 0.)), 2.0);\n    if (d.x > d1.x) {\n        d = d1;\n    }\n    \n    //d -= 0.02 * triNoise3d(p);\n    \n    return d;\n}\n\nvec2 map(in vec3 p, in float time)\n{\n    vec3 q = vec3(p);\n    q.z = mod(q.z, c_mod);\n    return torii(q, time);\n}\n\n\n\n// from Raymarching - Primitives - Inigo Quillez\n// https://www.shadertoy.com/view/Xds3zN\nvec3 normal(in vec3 pos, in float time) {\n    vec2 e = vec2(1.0, -1.0) * 0.5773 * 0.0005;\n    return normalize(e.xyy * map(pos + e.xyy, time).x + \n                                         e.yyx * map(pos + e.yyx, time).x + \n                                         e.yxy * map(pos + e.yxy, time).x + \n                                         e.xxx * map(pos + e.xxx, time).x );\n}\n\nvec3 material(in vec3 p, in float time) {\n    vec3 c;\n    vec2 d = map(p, time);\n        \n    if (d.x > 0.01) {\n        c.x = -1.;\n    } else {\n        if (d.y > 0.5 && d.y < 1.5) {\n            c = vec3(0.937, 0.27, 0.29);\n        }\n    }\n    \n    return c;\n}\n\nvec2 march(in vec3 cam, in vec3 ray, in float time)\n{\n    vec2 d = vec2(1., -1.);\n    \n    float t = dot(c_pl.xyz, ray) * (dot(c_pl.xyz, cam) + c_pl.w);\n    if (t > 0.) {\n        d.x = 10000.;\n        d.y = -1.;\n    } else {\n        d.x = t;\n        d.y = 1.;\n    }\n    \n    vec3 p;\n    t = 1.;\n    for (float r = 0.; r < 96.; r += 1.) {\n        p = cam + t * ray;\n        vec2 dt = map(p, time);\n        if (abs(dt.x) < .0001 * t) {\n            d.x = t;\n            d.y = dt.y;\n            break;\n        }\n        if (p.y < 0.) {\n            d.x = 10000.;\n            d.y = -1.;\n            break;\n        }\n        t += dt.x;\n        if (t > 60.) {\n            break;\n        }\n    }\n    \n    \n    return d;\n}\n\n\n// from penumbra shadows in raymarched SDFs - Inigo Quilez\n// https://iquilezles.org/articles/rmshadows\n\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float time, in float mint, in float tmax )\n{\n    // bounding volume\n    float tp = (c_max_height - ro.y)/rd.y; if( tp>0.0 ) tmax = min( tmax, tp );\n\n    float res = 1.0;\n    float t = mint;\n    for( int i=0; i<16; i++ )\n    {\n\t\tfloat h = map( ro + rd*t, time ).x;\n        float s = clamp(8.0*h/t,0.0,1.0);\n        res = min( res, s*s*(3.0-2.0*s) );\n        t += clamp( h, 0.02, 0.10 );\n        if( res<0.005 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\n//https://www.shadertoy.com/view/4sf3D2\nfloat hash(vec2 p) {return fract(sin(p.x * 1e4 + p.y) * 1e5 + sin(p.y * 1e3) * 1e3 + sin(p.x * 735. + p.y * 11.1) * 1.5e2); }\n\n// Returns three values on [-1, +1]: \n// vec3(d noise(x,y) / dx, d noise(x, y) / dy, noise(x,y));\n\nvec3 noised(vec2 x) {\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n\n\t// Four corners in 2D of a tile\n\tfloat a = hash(p);\n    float b = hash(p + vec2(1.0, 0.0));\n    float c = hash(p + vec2(0.0, 1.0));\n    float d = hash(p + vec2(1.0, 1.0));\n\n    vec2 u, v;\n    u = 30.0 * f * f * (f * (f - 2.0) + 1.0);\n    v = f * f * f * (f * (f * 6.0 - 15.0) + 10.0);\n\t\n\tfloat noiseValue = \n\t \tmix(mix(a, b, v.x), mix(c, d, v.x), v.y);\n\t\n\treturn vec3(u * (vec2(b, c) + (a - b - c + d) * v.yx - a),\n\t\t\t\tnoiseValue);\n}\nfloat hash(float n) { return fract(sin(n) * 1e4); }\nvec2 hash2( vec2 p )\n{\n\treturn fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\n// Based on Morgan McGuire @morgan3d\n// https://www.shadertoy.com/view/4dS3Wd\nfloat noise (in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    // Four corners in 2D of a tile\n    float a = hash2(i).x;\n    float b = hash2(i + vec2(1.0, 0.0)).x;\n    float c = hash2(i + vec2(0.0, 1.0)).x;\n    float d = hash2(i + vec2(1.0, 1.0)).x;\n\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n// This one has non-ideal tiling properties that I'm still tuning\nfloat noise(vec3 x) {\n\tconst vec3 step = vec3(110, 241, 171);\n\n\tvec3 i = floor(x);\n\tvec3 f = fract(x);\n \n\t// For performance, compute the base input to a 1D hash from the integer part of the argument and the \n\t// incremental change to the 1D based on the 3D -> 1D wrapping\n    float n = dot(i, step);\n\n\tvec3 u = f * f * (3.0 - 2.0 * f);\n\treturn mix(mix(mix( hash(n + dot(step, vec3(0, 0, 0))), hash(n + dot(step, vec3(1, 0, 0))), u.x),\n                   mix( hash(n + dot(step, vec3(0, 1, 0))), hash(n + dot(step, vec3(1, 1, 0))), u.x), u.y),\n               mix(mix( hash(n + dot(step, vec3(0, 0, 1))), hash(n + dot(step, vec3(1, 0, 1))), u.x),\n                   mix( hash(n + dot(step, vec3(0, 1, 1))), hash(n + dot(step, vec3(1, 1, 1))), u.x), u.y), u.z);\n}\n\n#define OCTAVES 6\nfloat fbm (in vec2 st) {\n    // Initial values\n    float value = 0.0;\n    float amplitude = .5;\n    float frequency = 0.;\n    //\n    // Loop of octaves\n    for (int i = 0; i < OCTAVES; i++) {\n        value += amplitude * noise(st);\n        st *= 2.;\n        amplitude *= .5;\n    }\n    return value;\n}\n\nfloat fbm (in vec3 st) {\n    // Initial values\n    float value = 0.0;\n    float amplitude = .5;\n    float frequency = 0.;\n    //\n    // Loop of octaves\n    for (int i = 0; i < OCTAVES; i++) {\n        value += amplitude * noise(st);\n        st *= 2.;\n        amplitude *= .5;\n    }\n    return value;\n}\n\nvec3 phong(vec3 v, vec3 n, vec3 l, vec3 c, float d, float s, float sa, vec3 a) {\n    vec3 h = normalize(l - v);\n    return max(dot(n, l), 0.) * c * d + pow(max(dot(n, h), 0.), sa) * c * s + a * 0.4;\n}\n\nvec3 pavement(in vec3 ray, in vec2 x)\n{\n    // based on voronoi from iq's - https://www.shadertoy.com/view/ldl3W8\n    vec2 n = floor(x);\n    vec2 f = fract(x);\n\n\tvec2 mg, mr;\n\n    float md = 8.0;\n    for( int j=-1; j<=1; j++ )\n    for( int i=-1; i<=1; i++ )\n    {\n        vec2 g = vec2(float(i),float(j));\n\t\tvec2 o = hash2(n + g);\n        vec2 r = g + o - f;\n        float d = dot(r,r);\n\n        if( d<md )\n        {\n            md = d;\n            mr = r;\n            mg = g;\n        }\n    }\n\n    md = 8.0;\n    vec2 mp, mo;\n    for( int j=-2; j<=2; j++ )\n    for( int i=-2; i<=2; i++ )\n    {\n        vec2 g = mg + vec2(float(i),float(j));\n\t\tvec2 o = hash2(n + g);\n        vec2 r = g + o - f;\n\n        if(dot(mr-r, mr-r) > 0.00001) {\n            vec2 p = normalize(r - mr);\n            float nd = dot( 0.5 * (mr + r), p);\n            if (nd < md) {\n                md = nd;\n                mo = o;\n                mp = p;\n            }\n        }\n    }\n    \n    float r = 0.19;\n    md = clamp(md, 0., r) / r;\n    vec3 c = fbm(1.6 * x) * .5 + vec3(.5);\n    vec3 norm;\n    if (md == 1.0) {\n        norm = vec3(0., 1., 0.);\n    } else {\n        float t = .1 + mo.y * .3;\n        float cs = cos(t);\n        float ct = 1. - cs; \n        float sn = sin(t);\n        norm = vec3(-mp.x * mp.y * ct, cs + mp.x * mp.x * ct, -mp.y * sn);\n    }\n\n    c *= phong(ray, norm, light_dir_0, vec3(1.), .9, .4, 30., vec3(0.9));\n    c *= smoothstep(.03, .2, md);\n    c = pow(c, vec3(1.4));\n    \n    return c;\n}\n\nvec3 fog(in vec3 col, in vec3 ro, in vec3 rd, in float mt)\n{\n    float d = mt - .1;\n    float r = .9;\n    float f = 0.;\n    for(int i=0;  i < 5; i++)\n    {\n        vec3  pos = ro + rd * d;\n        float rz = fbm(pos + vec3(iTime * .5, 0., 0.));\n        f += rz * .25 * pow(1.3, (d - 11.) * .15);\n        if (d < 5.) break;\n        d *= r;\n    }\n    f = smoothstep(0.4, 0.95, f);\n    f = pow(f, 1.3);\n    return mix(col, vec3(.8, .8, .9), f);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 mouse = resolution(iMouse.xy);\n    vec3 camera = vec3(0., 1.7,  -10.  - iTime * .8 - 100.);\n    vec3 lookAt = normalize(vec3(0., 1. + mouse.y * 2., .5) + camera);\n    float roll = 0.;\n    \n    vec3 cy = normalize(vec3(0., 1., 0.) - lookAt.y * lookAt);\n    vec3 cx = cross(lookAt, cy);\n    \n    vec2 uv = resolution(fragCoord);\n    \n    vec3 tot;\n    vec3 ray = normalize(uv.x * cx + uv.y * cy + F * lookAt);\n    \n    vec2 d = march(camera, ray, iTime);\n    vec3 c = vec3(0., 0., 0.);\n    \n    float dt = 0.;\n    vec3 c_dir_red_light = normalize(vec3(cos(dt - PI * 1.2), 0.7, sin(dt - PI * 1.2)));\n    vec3 c_dir_blue_light = normalize(vec3(cos(dt), 0.3, sin(dt)));\n    \n    float rz;\n    if (d.y > .5) {\n\t    vec3 p = camera + d.x * ray;\n        vec3 n = normal(p, iTime);\n        c = material(p, iTime);\n        c += phong(ray, n, c_dir_blue_light, c_blue_light, 0.3, 0.12, 10., c);\n        c += phong(ray, n, c_dir_red_light, c_red_light, 0.3, 0.12, 10., c);\n        c *= calcSoftshadow(p, c_blue_light, iTime, 0.02, 2.5 );\n        c = pow(c,vec3(1.2, 2.4, 1.64));\n\n        rz = d.x;\n    } else {\n        float t = -(dot(c_pl.xyz, camera) + c_pl.w) / dot(c_pl.xyz, ray);\n        vec3 q = camera + t * ray;\n        if (t > 0.) {\n            if (abs(q.x) < 1.4) {\n                c = pavement(ray, q.xz * vec2(2., 1.));\n            } else {\n                vec3 noise = noised(q.xz * 1.2);\n                vec3 n = -normalize(cross(vec3(1., noise.x, 0.), vec3(0., noise.y, 1.)));\n                c = vec3(0.412, 0.38, 0.28);\n                c += phong(ray, n, c_dir_red_light, c_red_light, 0.8, 0.1, 20., c);\n\t            c = pow(c, vec3(1.5));\n            }\n        }\n        rz = t;\n    }\n\tc = fog(c, camera, ray, rz);\n\n    c *= smoothstep(.0001, 1., 10.5 / rz);\n    \n    // Output to screen\n    fragColor = vec4(c, 1.0);\n}","name":"Image","description":"","type":"image"}]}