{"ver":"0.1","info":{"id":"lsVyzV","date":"1522701945","viewed":232,"name":"2D sun","username":"Pr0fed","description":"This time simple sin-cos pattern noise (does it have a name?) with a voronoi in a circle-like shape.","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["2d","noise","pattern"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// Rotation matrix, it does a big impact, as usual.\nconst mat2 m = mat2( 1.20,  0.80, -0.80,  1.20 );\n\n// Time simplification and easier overall speed control.\n#define time iTime * 0.23\n\n// Just a simple checker-like pattern.\n// Not even sure if we can call it noise.\nfloat squareNoise( in vec2 x )\n{\n\treturn cos(x.x) * sin(x.y);\n}\n\n// Six octave FBM square noise (3 seems enough).\nfloat fbm6( vec2 p )\n{\n    float f = 0.0;\n    f += 0.500000 * (0.5+0.5*squareNoise( p )); p = m * p * 2.02;\n    f += 0.250000 * (0.5+0.5*squareNoise( p )); p = m * p * 2.03;\n    f += 0.125000 * (0.5+0.5*squareNoise( p )); p = m * p * 2.01;\n    //f += 0.062500 * (0.5+0.5*squareNoise( p )); p = m * p * 2.04;\n    //f += 0.031250 * (0.5+0.5*squareNoise( p )); p = m * p * 2.01;\n    //f += 0.015625 * (0.5+0.5*noise( p ));\n    return f / 0.96875;\n}\n\n// This two hash voronoi might sucks. At least it seems ugly to me.\n// I guess i should use IQ's version. But really don't have time today.\nfloat r(float n)\n{\n \treturn fract(cos(n*72.42)*173.42);\n}\n\nvec2 r(vec2 n)\n{\n \treturn vec2(r(n.x*63.62-234.0+n.y*84.35),r(n.x*45.13+156.0+n.y*13.89)); \n}\n\nfloat voronoi2D(in vec2 n)\n{\n    float dis = 2.0;\n    for (int y= -1; y <= 1; y++) \n    {\n        for (int x= -1; x <= 1; x++) \n        {\n            // Neighbor place in the grid.\n            vec2 p = floor(n) + vec2(x,y);\n\n            float d = length(r(p) + vec2(x, y) - fract(n));\n            if (dis > d)\n            {\n             \tdis = d;   \n            }\n        }\n    }\n    \n    return 1.0 - dis;\n}\n\n// Four octave voronoi FBM.\nfloat fbm4( vec2 p )\n{\n    float f = 0.0;\n    f += 0.5000 * voronoi2D( p ); p = p * 2. * m;\n    f += 0.2500 * voronoi2D( p ); p = p * 2. * m;\n    f += 0.1250 * voronoi2D( p ); p = p * 2. * m;\n    f += 0.0625 * voronoi2D( p );\n    return f;\n}\n\nfloat GetFBM( vec2 q, out vec4 ron)\n{\n    // Base motion.\n    float ql = length( q * m );\n\n    // First layer.\n    vec2 o;\n    \n    // Vice versing fbm's addition for points gives nice result.\n    // Note that we pass q length inside outer fbm4 to get a circle pattern.\n    o = vec2(fbm4(vec2(0.5 * ql - time) + fbm6( vec2(2.0 * q + vec2(q)))));\n\n    // Second layer. Note that we use previous result as input.\n    vec2 n;\n    n = vec2(fbm4(q + fbm6( vec2(2.0 * o + vec2(o)))));\n    \n    // Sum of points with increased sharpness. \n    vec2 p = 4.0 * o + 6.0 * n;\n    float f = 0.5 + 0.5 * fbm6(p);\n\n    // I have seen that cubic mixing a couple of times\n    // is it just gives a nice result, or there is something\n    // behind it? Anyone?\n    f = mix( f, f * f * f * 3.5, f * abs(n.y));\n\n    f *= 1.0 - 0.5 * pow( f, 8.0 );\n    \n\tron = vec4( o, n );\n\n    return f;\n}\n\n\n// Main color mixing function.\nvec3 GetColor(vec2 p)\n{\n    vec4 on = vec4(0.0);\n    \n    float f = GetFBM(p, on);\n    \n    vec3 col = vec3(0.0);\n    \n    // You can play with this. Nothing really complex.\n    col = mix( vec3(0.78, 0.45, 0.06), vec3(0.35, 0.0, 0.4), f );\n    col = mix( col, vec3( 0.81, 0.55, 0.0), dot(on.xy, on.zw));\n\n    return col * col * 4. * 0.4545;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n     // Aspect ratio - UV normalization.\n   \tvec2 p = (2. * fragCoord - iResolution.xy ) / iResolution.y;\n    \n    // Zoom level.\n    p *= 5.;\n\n    // Time varying pixel color.\n    vec3 col = GetColor(p);\n\n    // Output to screen.\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}