{"ver":"0.1","info":{"id":"wt3Sz4","date":"1584052682","viewed":1510,"name":"procedural brick wall texture","username":"Cewein","description":"a brick wall, this come packed with both a normal and a colour texture.\nNext up on the list is a wool lattice texture.\n\nif you have any suggestion for improving the brick i'm all in.","likes":6,"published":3,"flags":0,"usePreview":0,"tags":["procedural","2d","texture","wall","normal","brick"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//constant function\nconst float zoom = 10.;\nconst vec3 brickColor = vec3(0.45,0.29,0.23);\nconst vec3 lineColor = vec3(0.845);\nconst float edgePos = 1.5;\n\n//random noise function\nfloat nrand( vec2 n )\n{\n\treturn fract(sin(dot(n.xy, vec2(12.9898, 78.233)))* 43758.5453);\n}\n\nfloat sincosbundle(float val)\n{\n\treturn sin(cos(2.*val) + sin(4.*val)- cos(5.*val) + sin(3.*val))*0.05;\n}\n\n\n//color function\nvec3 color(in vec2 uv)\n{\n    //grid and coord inside each cell\n    vec2 coord = floor(uv);\n    vec2 gv = fract(uv);\n    \n    //for randomness in brick pattern, it could be better to improve the color randomness\n    //you can try to make your own\n   \tfloat movingValue = -sincosbundle(coord.y)*2.;\n\n    //for the offset you can also make it more fuzzy by changing both\n    //the modulo value and the edge pos value\n    float offset = floor(mod(uv.y,2.0))*(edgePos);\n    float verticalEdge = abs(cos(uv.x + offset));\n    \n    //color of the bricks\n    vec3 brick = brickColor - movingValue;\n    \n    \n    bool vrtEdge = step( 1. - 0.01, verticalEdge) == 1.;\n    bool hrtEdge = gv.y > (0.9) || gv.y < (0.1);\n    \n    if(hrtEdge || vrtEdge)  \n        return lineColor;\n    return brick;\n}\n\n//normal functions\n//both function are modified version of https://www.shadertoy.com/view/XtV3z3\nfloat lum(vec2 uv) {\n\tvec3 rgb = color(uv);\n    return 0.2126 * rgb.r + 0.7152 * rgb.g + 0.0722 * rgb.b;\n}\n\nvec3 normal(vec2 uv) {\n    \n    //edge normal, it mean it's the difference between a brick and the white edge\n    //higher value mean bigger edge\n    float r = 0.03;\n    \n    float x0 = lum(vec2(uv.x + r, uv.y));\n    float x1 = lum(vec2(uv.x - r, uv.y));\n    float y0 = lum(vec2(uv.x, uv.y - r));\n    float y1 = lum(vec2(uv.x, uv.y + r));\n    \n    //NOTE: Controls the \"smoothness\"\n    //it also mean how hard the edge normal will be\n    //higher value mean smoother normal, lower mean sharper transition\n    float s = 1.0;\n    vec3 n = normalize(vec3(x1 - x0, y1 - y0, s));\n\n    vec3 p = vec3(uv * 2.0 - 1.0, 0.0);\n    vec3 v = vec3(0.0, 0.0, 1.0);\n\n    vec3 l = v - p;\n    float d_sqr = l.x * l.x + l.y * l.y + l.z * l.z;\n    l *= (1.0 / sqrt(d_sqr));\n\n    vec3 h = normalize(l + v);\n\n    float dot_nl = clamp(dot(n, l), 0.0, 1.0);\n    float dot_nh = clamp(dot(n, h), 0.0, 1.0);\n\n    float color = lum(uv) * pow(dot_nh, 14.0) * dot_nl * (1.0 / d_sqr);\n    color = pow(color, 1.0 / 2.2);\n\n    return (n * 0.5 + 0.5);\n \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord)/iResolution.y;\n    uv *= zoom;\n    //uv.y += iTime;\n\t\n    //get normal with normal(uv)\n    //get color with color(uv)\n    fragColor = vec4(color(uv),1.0);\n    if((fragCoord.x - fragCoord.y)  > (iResolution.x - iResolution.y)/2.)\n        fragColor = vec4(normal(uv),1.0);\n      \n}","name":"Image","description":"","type":"image"}]}