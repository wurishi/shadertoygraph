{"ver":"0.1","info":{"id":"McK3WK","date":"1713301153","viewed":61,"name":"Stack Blur attempt","username":"mehow_one","description":"Recreating the stack blur from : https://underdestruction.com/2004/02/25/stackblur-2004/","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["stackblur"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdfGRr","filepath":"/media/a/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm","previewfilepath":"/media/ap/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm","type":"video","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// ref : https://underdestruction.com/2004/02/25/stackblur-2004/\n\n\n// width of the  read kernel\nconst float kernel = 16.0;\n// width of the  reading head\nconst float cone = 1.;\n\nvec4 stackBlur(sampler2D image, vec2 uv, float kernel, vec2 resolution) {\n    // width of one pixel in texture coordinates\n    vec2 stepSize = cone / resolution;\n    // we stack all the pixels multiplied by a factor, \n    // and we also stack the total factor so we can bring it back between [0,1] for rendering.\n    float weighted = 0.0;\n    vec4 blurred = vec4(0.0);\n\n    // A good advantage of that approach is you can do that for both dimension in one buffer\n    // but at the price of a jagged blur ðŸ˜…\n    // Works better on moving images than static\n    for (int x = -int(kernel); x <= int(kernel); x++) {\n        for (int y = -int(kernel); y <= int(kernel); y++){\n            // how far of the center we sample \n            vec2 offset = vec2(float(x), float(y)) * stepSize;\n            // TO DO : prevent out of bounds fetching, this doesn't break GLSL but since it returns a vec4(0.)\n            // that creates a lighter halo around the border & also adjust weights so it amount to 1\n            // getting the pixel at that offset position\n            vec4 pixel = texture(image, uv + offset);\n            // getting the weight of the sample given its distance from the actual pixel\n            // and then flipping it over to create the 'pyramid' of pixels\n            // the actual blurring, might be replaced by other weighting operations\n            float weight = 1.0 - (length(offset) / (kernel + 1.0));\n            // adding the weight to the total weight\n            weighted += weight;\n            // adding the sample to the blur\n            blurred += pixel * weight;\n        }\n    }\n    // collapsing the whole stack of samples to a color\n    return blurred / weighted;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    fragColor = stackBlur(iChannel0, uv, kernel, iResolution.xy);\n}","name":"Image","description":"","type":"image"}]}