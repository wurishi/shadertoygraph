{"ver":"0.1","info":{"id":"fsyBRK","date":"1658568924","viewed":88,"name":"KnightsTour","username":"julietc","description":"Display knights tour","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["chess","knightstour","lores"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Juliet Colman July 2022\n\nconst int SCREEN_W = 160;\nconst int SCREEN_H = 108;\nconst int BORDER_W = 36;\nconst int BORDER_H = 6;\nconst int SQ_W = 11;\nconst int SQ_H = 12;\n\nconst vec3 BG_COL = vec3(0., 0., 1.);\nconst vec3 BORDER_COL = vec3(1., 1., 1.);\nconst vec3 SQ_B_COL = vec3(0., 0., 0.);\nconst vec3 SQ_W_COL = vec3(1., 1., 1.);\nconst vec3 SQ_VISITED_COL = vec3(1., 0., 0.);\nconst vec3 SQ_START_COL = vec3(1., 1., 0.);\n\n\nint[64] tour;\n\n// Pre-built array of destinations from each square\n// (Not a pre-built tour)\nconst int DESTS[64 * 8] = int[64 * 8]\n(\n    10,  17,  -1,  -1,  -1,  -1,  -1,  -1,\n    16,  11,  18,  -1,  -1,  -1,  -1,  -1,\n     8,  12,  17,  19,  -1,  -1,  -1,  -1,\n     9,  13,  20,  18,  -1,  -1,  -1,  -1,\n    14,  10,  21,  19,  -1,  -1,  -1,  -1,\n    15,  11,  22,  20,  -1,  -1,  -1,  -1,\n    23,  12,  21,  -1,  -1,  -1,  -1,  -1,\n    13,  22,  -1,  -1,  -1,  -1,  -1,  -1,\n     2,  25,  18,  -1,  -1,  -1,  -1,  -1,\n     3,  24,  19,  26,  -1,  -1,  -1,  -1,\n     0,   4,  16,  25,  20,  27,  -1,  -1,\n     1,   5,  17,  21,  28,  26,  -1,  -1,\n     6,   2,  22,  18,  29,  27,  -1,  -1,\n     7,  23,   3,  30,  19,  28,  -1,  -1,\n     4,  31,  20,  29,  -1,  -1,  -1,  -1,\n     5,  30,  21,  -1,  -1,  -1,  -1,  -1,\n     1,  10,  33,  26,  -1,  -1,  -1,  -1,\n     0,   2,  32,  11,  27,  34,  -1,  -1,\n     8,   1,  24,   3,  33,  12,  28,  35,\n     2,   9,   4,  13,  25,  36,  29,  34,\n    14,   3,   5,  30,  10,  37,  26,  35,\n    15,   6,  31,   4,  38,  11,  27,  36,\n     7,  39,   5,  12,  28,  37,  -1,  -1,\n     6,  13,  38,  29,  -1,  -1,  -1,  -1,\n     9,  41,  34,  18,  -1,  -1,  -1,  -1,\n     8,  40,  10,  35,  19,  42,  -1,  -1,\n     9,  16,  32,  41,  11,  36,  20,  43,\n    10,  12,  17,  33,  44,  21,  37,  42,\n    38,  22,  11,  13,  45,  34,  18,  43,\n    39,  23,  14,  46,  12,  35,  19,  44,\n    15,  47,  13,  20,  36,  45,  -1,  -1,\n    14,  46,  21,  37,  -1,  -1,  -1,  -1,\n    49,  17,  42,  26,  -1,  -1,  -1,  -1,\n    48,  16,  50,  43,  27,  18,  -1,  -1,\n    49,  40,  24,  51,  17,  28,  19,  44,\n    52,  50,  25,  41,  29,  20,  18,  45,\n    46,  30,  51,  53,  42,  21,  19,  26,\n    47,  31,  54,  22,  52,  43,  27,  20,\n    55,  23,  53,  28,  44,  21,  -1,  -1,\n    54,  22,  29,  45,  -1,  -1,  -1,  -1,\n    57,  50,  25,  34,  -1,  -1,  -1,  -1,\n    56,  58,  24,  51,  35,  26,  -1,  -1,\n    57,  48,  32,  59,  25,  52,  36,  27,\n    60,  58,  49,  33,  53,  37,  28,  26,\n    54,  59,  61,  50,  38,  34,  29,  27,\n    55,  62,  39,  60,  51,  30,  35,  28,\n    63,  31,  61,  52,  36,  29,  -1,  -1,\n    62,  53,  30,  37,  -1,  -1,  -1,  -1,\n    58,  33,  42,  -1,  -1,  -1,  -1,  -1,\n    59,  32,  43,  34,  -1,  -1,  -1,  -1,\n    56,  60,  40,  33,  44,  35,  -1,  -1,\n    57,  61,  41,  45,  36,  34,  -1,  -1,\n    62,  58,  46,  42,  37,  35,  -1,  -1,\n    63,  47,  59,  38,  43,  36,  -1,  -1,\n    60,  39,  44,  37,  -1,  -1,  -1,  -1,\n    61,  38,  45,  -1,  -1,  -1,  -1,  -1,\n    50,  41,  -1,  -1,  -1,  -1,  -1,  -1,\n    40,  51,  42,  -1,  -1,  -1,  -1,  -1,\n    48,  52,  41,  43,  -1,  -1,  -1,  -1,\n    49,  53,  44,  42,  -1,  -1,  -1,  -1,\n    54,  50,  45,  43,  -1,  -1,  -1,  -1,\n    55,  51,  46,  44,  -1,  -1,  -1,  -1,\n    47,  52,  45,  -1,  -1,  -1,  -1,  -1,\n    53,  46,  -1,  -1,  -1,  -1,  -1,  -1\n);\n\n// Number of destinations from each square: the number of\n//  valid elements in each row above.\nconst int NUM_DESTS[64] = int[64]\n(\n\t2, 3, 4, 4, 4, 4, 3, 2,\n\t3, 4, 6, 6, 6, 6, 4, 3,\n\t4, 6, 8, 8, 8, 8, 6, 4,\n\t4, 6, 8, 8, 8, 8, 6, 4,\n\t4, 6, 8, 8, 8, 8, 6, 4,\n\t4, 6, 8, 8, 8, 8, 6, 4,\n\t3, 4, 6, 6, 6, 6, 4, 3,\n\t2, 3, 4, 4, 4, 4, 3, 2\n);\n\nvoid calcTour(int start)\n{\n\tint touri = 0; // index into tour, the length of the tour so far\n\tint visited[64] = int[64]\n    (\n        0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0\n    );\n    \n\t// Current choice of dest for this sq, [0..7]; \n    //  an index into one row of DESTS.\n\tint choice[64] = int[64]\n    (\n        0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0\n    );\n\t\n\tint sq = start;\n\twhile (true)\n\t{\n\t\ttour[touri] = sq;\n\t\tvisited[sq] = 1;\n\t\t\n\t\tif (touri == 63)\n\t\t{\n\t\t\tbreak; // full tour found\n\t\t}\n\t\t\n\t\t// Go to the next dest. If no more dests, go back one step.\n\t\tint dest = DESTS[sq * 8 + choice[sq]];\n\t\twhile (visited[dest]==1 && choice[sq] < NUM_DESTS[sq])\n\t\t{\n            // Already visited dest, try the next one\n\t\t\tchoice[sq]++;\n\t\t\tdest = DESTS[sq * 8 + choice[sq]];\n\t\t}\n\t\t\n\t\tif (choice[sq] == NUM_DESTS[sq])\n\t\t{\n\t\t\t// We visited all the dests from sq, so backtrack\n\t\t\tvisited[sq] = 0;\n\t\t\tchoice[sq] = 0;\n\t\t\ttouri--;\n\t\t\tif (touri < 0)\n\t\t\t{\n\t\t\t\t// Wow, no tour found?!\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tsq = tour[touri];\n\t\t\tchoice[sq]++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tsq = dest;\n\t\t\ttouri++;\n\t\t}\n\t}\n}\n\n\n// Convert uv coords(0..1) to pixels\nivec2 GetScreenPixelCoord(vec2 vScreenUV)\n{\n    // Thanks to P_Malin\n    vec2 kResolution = vec2(float(SCREEN_W), float(SCREEN_H));\n    vec2 vPixelPos = floor(vScreenUV * kResolution);\n    vPixelPos.y = kResolution.y - vPixelPos.y - 1.;\n    return ivec2(vPixelPos);\n}\n\n// Returns 0 or 1 for pixel colour.\nint getChecker(ivec2 pos)\n{\n    // return 0 or 1 in a checker pattern for pos.\n    return    ((pos.x & 0x01) == 0x01 && (pos.y & 0x01) == 0x01)\n           || ((pos.x & 0x01) == 0x00 && (pos.y & 0x01) == 0x00)\n       ? 0 : 1;\n}\n\n// Convert pixel position to square pos (0..7)(0..7)\nivec2 sqPos(ivec2 pos)\n{\n    return ivec2((pos.x - BORDER_W) / SQ_W, (pos.y - BORDER_H) / SQ_H);\n}\n\nbool isBorder(ivec2 pos)\n{\n    return (pos.x < BORDER_W || pos.x >= (BORDER_W + 8 * SQ_W)\n         || pos.y < BORDER_H || pos.y >= (BORDER_H + 8 * SQ_H));\n}\n\nbool isBorder2(ivec2 pos)\n{\n    int x1 = BORDER_W - 2;\n    int x2 = BORDER_W + 8 * SQ_W + 1;\n    int y1 = BORDER_H - 2;\n    int y2 = BORDER_H + 8 * SQ_H + 1;\n    \n    return (pos.x == x1 || pos.x == x2 || pos.y == y1 || pos.y == y2) &&\n            pos.x >= x1 && pos.x <= x2 && pos.y >= y1 && pos.y <= y2;\n}\n\n// Return bit pattern for knight, r is row is [0..12)\n// There are 11 columns in this image.\n// This includes a border of 1 pixel wide around the image.\nint knight(int r)\n{\n    const int array[12] = int[12](\n        0x000,\n        0x0a0,\n        0x0f0,\n        0x1d8,\n        0x3fe,\n        0x3fe,\n        0x3ee,\n        0x1e0,\n        0x0f8,\n        0x3fe,\n        0x3fe,\n        0x000\n    );\n    return array[r];\n}\n\n// Return 0 or 1 for pixel colour of the given bit in this line.\nint getIntBit(int line, int bit)\n{\n    int p = (line & (1 << bit)) >> bit;\n    return (p & 0x01);\n}\n\nivec2 getTourSquare(int t)\n{\n    return ivec2(t / 8, t %8);\n}\n\nbool isVisited(ivec2 sq, int maxTourPos)\n{\n    for (int i = 0; i < maxTourPos; i++)\n    {\n        if (getTourSquare(tour[i]) == sq)\n        {\n            return true;\n        }\n    }\n    return false;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    ivec2 pos = GetScreenPixelCoord(uv); // pixel pos\n    \n    vec3 col = BG_COL;\n    // Check if border\n    if (isBorder(pos))\n    {\n        if (isBorder2(pos))\n        {\n            col = BORDER_COL;\n        }\n    }\n    else\n    {\n        // A square on the board\n        const float SPEED = 4.;\n        int time = int(iTime * SPEED);\n        int tourStep = time % 64;\n        \n        int start = (time / 64) % 64;\n\n        calcTour(start);\n        \n\n        // Square position (0..7, 0..7)\n        ivec2 sq = sqPos(pos);\n        // Get 1 or 0 in checkerboard pattern\n        int ch = getChecker(sq);\n        \n\n        // Get square the knight should be on\n        ivec2 knightSq = getTourSquare(tour[tourStep]);\n        \n        if (sq == knightSq)\n        {\n            // Pixel coord within sq \n            ivec2 sq = ivec2((pos.x - BORDER_W) % SQ_W, (pos.y - BORDER_H) % SQ_H);\n\n            int knPixel = ch ^ getIntBit(\n                knight(sq.y), // line 0..10\n                       sq.x); // bit 0..10\n                       \n            col = knPixel == 1 ? SQ_W_COL : SQ_B_COL;\n        }\n        else if (sq == getTourSquare(tour[0]))\n        {\n            col = SQ_START_COL;\n        }\n        else if (isVisited(sq, tourStep))\n        {\n            col = SQ_VISITED_COL;\n        }\n        else\n        {\n            // Square background colour\n            col = ch == 1 ? SQ_W_COL : SQ_B_COL;\n        }\n    }\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n","name":"Image","description":"","type":"image"}]}