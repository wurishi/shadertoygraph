{"ver":"0.1","info":{"id":"3llBRN","date":"1691420278","viewed":63,"name":"Visualization of Space and Time","username":"romeosoft","description":"Visualization is the best way to understand math behind space and time.","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["visualization","physics","magneticfield","lorentz","electricfield","spaceandtime"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n                          .-''--.\n                         _`>   `\\.-'<\n                      _.'     _     '._\n                    .'   _.='   '=._   '.\n                    >_   / /_\\ /_\\ \\   _<\n                      / (  \\o/\\\\o/  ) \\\n                      >._\\ .-,_)-. /_.<\n                          /__/ \\__\\\n                            '---'\n\n          “If I can’t picture it, I can’t understand it.”\n*/\n// =========================================================\n#define resolution_3d\t0.02 \n#define depth_of_field\t100\n#define ROT(p, a) p=cos(a)*p+sin(a)*vec2(p.y, -p.x)\n\n// =========================================================\n// random\nreal map(vec3 p) \n{\n\tfloat NebNoise = abs(NebulaNoise(p/0.5)*0.5);\n    \n\treturn max( NebNoise+0.03, 0.0 );\n}\n\n// sdf primatives\nfloat sdCylinder( vec3 p, vec2 h )\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\nfloat sdTorus(vec3 pos, vec2 dimensions)\n{\n\treturn length( vec2(length(pos.xy)-dimensions.x,pos.z) )-dimensions.y;\n}\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n// coordnate\ncrd3 crd_p1(crd3 c0, vec3 p)\n{\n    p = normalize(p);\n    real ang = length(p.zx);\n    \n    return c_x_q(c0, angax_q((5.) * ang, UY));\n}\ncrd3 crd_p2(crd3 c0, vec3 p)\n{\n    return c0;\n}\ncrd3 crd_p3(crd3 c0, vec3 p)\n{\n    crd3 c = c_x_q(c0, angax_q(1.5, UZ));\n    \n    return c;\n}\n\n// sdf normal\nreal sdf_map(in vec3 p)\n{\n    return sdBox(p, vec3(0.158,0.158,0.158));\n}\nvec3 calc_normal( in vec3 pos )\n{\n    // inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times\n    vec3 n = vec3(0.0);\n    for( int i=0; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*sdf_map(pos+0.0005*e);\n      //if( n.x+n.y+n.z>100.0 ) break;\n    }\n    return normalize(n);\n}\n\n// ---------------------------------------------------------\n// MAIN\n// ---------------------------------------------------------\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{  \n    vec2 pp = (-iResolution.xy + 2.0 * fragCoord.xy) / iResolution.y;\n    float eyer = 1.0;\n    float eyea = -((iMouse.x) / iResolution.x) * PI * 2.0;\n    float eyef = ((iMouse.y / iResolution.y) - 0.24) * PI * 2.0;\n\n    vec3 cam = vec3(\n        eyer * cos(eyea) * sin(eyef),\n        eyer * cos(eyef),\n        eyer * sin(eyea) * sin(eyef));\n        \n   // ROT(cam.xz, (0.25) * (iTime + 10.0)); // auto rotation\n\n    vec3 front = normalize(-cam);\n    vec3 left = normalize(cross(normalize(vec3(0.1, 1, -0.001)), front));\n    vec3 up = normalize(cross(front, left));\n    \n    vec3 camd = normalize(front + left * pp.x + up * pp.y);\n    \n    coord3 c0 = uxy_c(UX, UY);\n    \n    lorentz_coord lc = lorentz(UX, UY, UZ, abs(sin(iTime)));\n    \n    vec3 p0 = cam;\n    vec3 v0 = camd;\n    \n    // lorentz transfrom\n    // vec4 vcam = vec4(camd,0.0);\n    // vcam = v_x_l(vcam, lc);\n    // v0 = vcam.xyz;\n    //float time = iTime;// * (1.0 + vcam.w);\n    \n    // electric field \n    //vec3 E = RED;\n    //E = v3_x_l(E, lc);\n    \n    // magnetic field\n    //vec3 B = GREEN;\n    //B = iv3_x_l(B, lc);\n    \n    //float n = 2.0;\n    //float lambda1 = 0.158;\n    //float lambda2 = 0.158;\n    //float T1 = (n*PI*time);\n    //float T2 = -(n*PI*time);\n    \n    float dt = 0.02;\n    vec3 cor1 = vec3(0.0);\n    vec3 cor2 = vec3(0.0);\n    float d = 0.0;\n    float t = 0.0;\n    float tmax = 8.0;\n    for(int i = 0; i < depth_of_field && t < tmax; i ++)\n    {\n        {\n            //coord3 c1 = crd_p1(c0, p0 - UZ / 2.);\n\n            vec3 p1 = p0 - UZ / 2.;//p_x_c(p0 - UZ / 2., c1);\n            \n            //coord3 c2 = crd_p1(c0, p0 + UZ / 2.);\n            \n            vec3 p2 = p0 + UZ / 2.;//p_x_c(p0 + UZ / 2., c2);\n            \n            float d1 = sdf_map(p1);\n            \n            float d2 = sdf_map(p2);\n           \n            d = min(d1, d2);\n            \n            vec3 E1 = calc_normal(p1);\n            \n            vec3 E2 = calc_normal(p2);\n            \n            if(d1 < 0.001) \n            {\n                fragColor = vec4(E1 * dot(camd, E1),1.0);\n                return;\n            }\n            if(d2 < 0.001) \n            {\n                fragColor = vec4(E2 * dot(camd, E2),1.0);\n                return;\n            }\n            \n            cor1 += E1 *(0.158 / max(0.1, d1*d1));\n            \n            cor2 += E2 *(0.158 / max(0.1, d2*d2));\n        }\n        \n        p0 += v0 * max(d/2., 0.001);\n        \n        t += d;\n    }\n    \n    fragColor = vec4(sin(cor1 + iTime * 1.0) + sin(cor2 - iTime * 1.0),1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"/*\n*           Visualization\n*\n*   \n*/\n\n#define PI 3.14156\n#define real float\n#define imag float\n#define quat quaternion\n#define crd3 coord3\n\n#define CSCREEN vec2(0.5,0.5)\n\n#define BLACK vec3(0,0,0)\n#define WHITE vec3(1,1,1)\n#define RED vec3(1,0,0)\n#define GREEN vec3(0,1,0)\n#define BLUE vec3(0,0,1)\n#define YELLOW vec3(1,1,0)\n#define GREY vec3(0.5,0.5,0.5)\n\n#define XYZ0 vec3(0,0,0)\n#define UX vec3(1,0,0)\n#define UY vec3(0,1,0)\n#define UZ vec3(0,0,1)\n#define UC crd3(UX, UY, UZ, XYZ0)\n\n// ---------------------------------------------------------\n// Quaternion:\n// Quaternions are real mathematics numbers, \n// meaning there is number theory behind them.\n// ---------------------------------------------------------\nstruct quaternion\n{\n    real w, x, y, z;\n};\nquaternion angax_q(real ang, vec3 ax)\n{\n    quaternion q;\n    real halfang = 0.5 * ang;\n    real fsin = sin(halfang);\n    q.w = cos(halfang);\n    q.x = fsin * ax.x;\n    q.y = fsin * ax.y;\n    q.z = fsin * ax.z;\n    return q;\n}\nquaternion vv_q(vec3 v1, vec3 v2)\n{\n    real ang = acos(dot(v1, v2));\n    vec3 ax = normalize(cross(v1, v2));\n    return angax_q(ang, ax);\n}\nquaternion wv_q(real w, vec3 v)\n{\n   return quaternion(w, v.x,v.y,v.z);\n}\n// v x q\nvec3 v_x_q(vec3 v, quaternion q)\n{\n    // nVidia SDK implementation\n    vec3 uv, uuv;\n    vec3 qvec = vec3(q.x, q.y, q.z);\n    uv = cross(qvec, v);\n    uuv = cross(qvec, uv);\n    uv = uv * (2.0f * q.w);\n    uuv = uuv * 2.0f;\n\n    return v + uv + uuv;\n}\n// q x q\nquaternion q_x_q(quaternion q1, quaternion q2)\n{\n    quaternion q;\n\n    q.w = q1.w * q2.w - q1.x * q2.x - q1.y * q2.y - q1.z * q2.z;\n    q.x = q1.w * q2.x + q1.x * q2.w + q1.y * q2.z - q1.z * q2.y;\n    q.y = q1.w * q2.y + q1.y * q2.w + q1.z * q2.x - q1.x * q2.z;\n    q.z = q1.w * q2.z + q1.z * q2.w + q1.x * q2.y - q1.y * q2.x;\n    return q;\n}\nquaternion exp_q(quaternion q)\n{\n    vec3 v = vec3(q.x,q.y,q.z);\n    real r = length(v);\n    real tr = exp(q.w);\n    return wv_q(tr * cos(r), normalize(v) * (tr*sin(r)));\n}\n\n// ---------------------------------------------------------\n// Coordinate System:\n// A coordinate system in three-dimensional space \n// consists of an origin plus three orientation axes\n// c++ version : \n// https://github.com/panguojun/Coordinate-system-transformation\n// ---------------------------------------------------------\nstruct coord3\n{\n    vec3 ux, uy, uz; // three axial unit vectors\n    vec3 o;          // origin\n    real s;          // scaling\n};\ncoord3 uxyz_c(vec3 _ux, vec3 _uy, vec3 _uz)\n{\n    coord3 c;\n    c.ux = _ux;\n    c.uy = _uy;\n    c.uz = _uz;\n    c.o = XYZ0;\n    c.s = 1.0;\n    return c;\n}\ncoord3 uxy_c(vec3 _ux, vec3 _uy)\n{\n    coord3 c;\n    c.ux = _ux;\n    c.uy = _uy;\n    c.uz = cross(_ux,_uy);\n    c.o = XYZ0;\n    c.s = 1.0;\n    return c;\n}\ncoord3 norm_c(coord3 c)\n{\n    c.ux = normalize(c.ux);\n    c.uy = normalize(c.uy);\n    c.uz = normalize(c.uz);\n    return c;\n}\n// p x c\nvec3 p_x_c(vec3 p, coord3 c)\n{\n    return c.ux * (c.s * p.x) + c.uy * (c.s * p.y) + c.uz * (c.s * p.z) + c.o;\n}\n// v x c\nvec3 v_x_c(vec3 v, coord3 c)\n{\n    return c.ux * (c.s * v.x) + c.uy * (c.s * v.y) + c.uz * (c.s * v.z);\n}\ncoord3 c_x_q(coord3 c, quat q)\n{\n    return coord3(\n        v_x_q(c.ux, q), v_x_q(c.uy, q), v_x_q(c.uz, q),\n        c.o, c.s);\n}\n// p / c\nvec3 p_z_c(vec3 p, coord3 c)\n{\n    vec3 v = p - c.o;\n    return vec3(dot(v, c.ux), dot(v, c.uy), dot(v, c.uz)) / c.s;\n}\nvec3 v_z_c(vec3 v, coord3 c)\n{\n    return vec3(dot(v, c.ux), dot(v, c.uy), dot(v, c.uz)) / c.s;\n}\nreal c_ax_dot(vec3 v, coord3 c)\n{\n    return dot(v, c.ux + c.uy + c.uz);\n}\nvec3 c_ax_cross(coord3 a, coord3 b)\n{\n    return vec3(\n        dot(a.uy, b.uz) - dot(a.uz, b.uy),\n        dot(a.uz, b.ux) - dot(a.ux, b.uz),\n        dot(a.ux, b.uy) - dot(a.uy, b.ux)\n    );\n}\ncoord3 c_flipx(coord3 c)\n{\n    c.ux = -c.ux;\n    return c;\n}\ncoord3 c_flipy(coord3 c)\n{\n    c.uy = -c.uy;\n    return c;\n}\ncoord3 c_flipz(coord3 c)\n{\n    c.uz = -c.uz;\n    return c;\n}\n\n// ---------------------------------------------------------\n// Lorentz Coordnate System:\n// ---------------------------------------------------------\nstruct lorentz_coord\n{\n    vec3 ux, uy, uz; // three axial unit vectors\n    real tau;        // power of time\n};\nlorentz_coord lorentz(vec3 _ux, vec3 _uy, vec3 _uz, real _tau)\n{\n    lorentz_coord lc;\n    lc.ux = _ux;\n    lc.uy = _uy;\n    lc.uz = _uz;\n    lc.tau = _tau;\n    return lc;\n}\n// v x l\nvec4 v_x_l(vec4 v, lorentz_coord lc)\n{\n    v.xyz = (lc.ux * (v.x) + lc.uy * (v.y) + lc.uz * (v.z))\n            * cos((v.w + lc.tau) * PI / 2.);\n    v.w = v.w + lc.tau;\n    return v;\n}\n// v3 x l\nvec3 v3_x_l(vec3 v, lorentz_coord lc)\n{\n    v = lc.ux * (v.x) + lc.uy * (v.y) + lc.uz * (v.z);\n    return v * cos(lc.tau * PI / 2.);\n}\n// iv3 x l\nvec3 iv3_x_l(vec3 v, lorentz_coord lc)\n{\n    return v * sin(lc.tau * PI / 2.);\n}\n// ---------------------------------------------------------\n// Vector Math\n// ---------------------------------------------------------\nvec3 crossdot(vec3 v1, vec3 v2) {\n    vec3 result;\n    result.x = v1.y * v2.z - v1.z * v2.y;\n    result.y = v1.z * v2.x - v1.x * v2.z;\n    result.z = v1.x * v2.y - v1.y * v2.x;\n    return result;\n}\n\n// ---------------------------------------------------------\n// Random\n// ---------------------------------------------------------\n// iq's\nfloat hash(float n) { return fract(sin(n)*753.5453123); }\nfloat noise(vec3 x)\n{\n\tvec3 p = floor(x);\n\tvec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\tfloat n = p.x + p.y*157.0 + 113.0*p.z;\n\treturn mix(mix(mix(hash(n+0.0), hash(n+1.0),f.x),\n\t\tmix(hash(n+157.0), hash(n+158.0),f.x),f.y),\n\t\tmix(mix(hash(n+113.0), hash(n+114.0),f.x),\n\t\t\tmix(hash(n+270.0), hash(n+271.0),f.x),f.y),f.z);\n}\n\nfloat rrnd(vec2 co)\n{\n\treturn fract(sin(dot(co*0.123,vec2(12.9898,78.233))) * 43758.5453);\n}\n\n// otaviogood's noise from https://www.shadertoy.com/view/ld2SzK\nconst float nudge = 0.739513;\nfloat normalizer = 1.0 / sqrt(1.0 + nudge*nudge);\nfloat SpiralNoiseC(vec3 p)\n{\n\tfloat n = 0.0;\n\tfloat iter = 1.0;\n\tfor (int i = 0; i < 6; i++)\n\t{\n\t\tn += -abs(sin(p.y*iter) + cos(p.x*iter)) / iter;\n\t\tp.xy += vec2(p.y, -p.x) * nudge;\n\t\tp.xy *= normalizer;\n\t\tp.xz += vec2(p.z, -p.x) * nudge;\n\t\tp.xz *= normalizer;\n\t\titer *= 1.733733;\n\t}\n\treturn n;\n}\n\nfloat SpiralNoise3D(vec3 p)\n{\n\tfloat n = 0.0;\n\tfloat iter = 1.0;\n\tfor (int i = 0; i < 4; i++)\n\t{\n\t\tn += (sin(p.y*iter*2.0) + cos(p.x*iter)) / iter;\n\t\tp.xz += vec2(p.z, -p.x) * nudge;\n\t\tp.xz *= normalizer;\n\t\titer *= 1.33733;\n\t}\n\treturn n;\n}\n\nfloat NebulaNoise(vec3 p)\n{\n\tfloat final = p.y + 2.5;\n\tfinal -= SpiralNoiseC(p.xyz*2.0);   // 中等噪声\n\tfinal += SpiralNoiseC(p.zxy*0.5123+100.0)*2.0;   // 大尺度特征\n\tfinal -= SpiralNoise3D(p);   // 更多大尺度特征，但是是3D的\n\n\treturn final;\n}\n\n// ---------------------------------------------------------\n// Color\n// ---------------------------------------------------------\nvec3 RGB2HSV(vec3 c)\n{\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n\tvec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n\tvec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n\tfloat d = q.x - min(q.w, q.y);\n\tfloat e = 1.0e-10;\n\treturn vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\nvec3 HSV2RGB(vec3 c)\n{\n      vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n      vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n      return c.z * mix(K.xxx, (p - K.xxx), c.y);\n}\n\n// ---------------------------------------------------------\n// 4D ROTATION\n// ---------------------------------------------------------\n// https://www.shadertoy.com/view/wsfGDS\nvoid pR(inout vec2 p, float a) {\n    p = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n// Inverse stereographic projection of p,\n// p4 lies onto the unit 3-sphere centered at 0.\n// - mla https://www.shadertoy.com/view/lsGyzm\nvec4 inverseStereographic(vec3 p, out float k) {\n    k = 2.0/(1.0+dot(p,p));\n    return vec4(k*p,k-1.0);\n}\n// The inside-out rotation puts the torus at a different\n// orientation, so rotate to point it at back in the same\n// direction\n// pR(p4.zy, time * -PI / 2.);\n\n// Rotate in 4D, turning the torus inside-out\n//  pR(p4.xw, time * -PI / 2.);","name":"Common","description":"","type":"common"}]}