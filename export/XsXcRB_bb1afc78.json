{"ver":"0.1","info":{"id":"XsXcRB","date":"1488593128","viewed":130,"name":"Constant Time Demo","username":"openflower","description":"Demo of possible technique for eventually achieving constant time on CS8EC by 4onen","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["cs8ec"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float n = 10.0;\n\nconst float rateOfTime = 1.0; // = speed of rotation in rad/sec\nconst float screenSize = 2.0;\n\nconst float circleRadius = 1.0; //radius of circes\nconst float d = 2.0; //distance from center of screen to center of circle\nconst float circleWidth = .01;\nconst float bulletWidth = .05;\nconst float lineWidth = .1; //width of line in units of time, not distance\n\n\n\n\n\n//A list of colors. Have fun messing with these!\nconst vec4 bgColor = vec4(0.25,0.0,0.3,1.0);\nconst vec4 polyColor = vec4(5.0,0.0,5.0,1.0);\nconst vec4 lineColor = vec4(1.0,0.99,1.0,1.0);\nconst vec4 capColor = vec4(1.0);\n\nconst float tau = 6.2831853071795864769;\n//START: HELPER FUNCTIONS------------------------------------------------------------------------\n\nbool inFrame(vec2 xy, float radius)\n{\n   return( \n       abs(xy.y) < circleRadius + bulletWidth &&                  //y within bounds of picture and\n      (\n       abs(xy.x) < d                                              //x between centers of circles\n       ||                                                      //or\n       radius < circleRadius + bulletWidth  //inside the two semicircles that stick out\n      )\n   );\n}\n\n\nbool inCircle(vec2 xy)\n{\n    return(abs(length(xy) - circleRadius) < .1);\n}\n\nfloat time()\n{\n    return(mod(iTime,tau)*rateOfTime);\n}\n\n\nbool inBullet(vec2 xy, float radius, float time)\n{\n    return(\n        abs(length(vec2(abs(abs(xy.x)-d),xy.y))-circleRadius) < bulletWidth //&& abs(atan(xy.y,xy.x)-time) < bulletWidth\n        );\n}\n\n\nfloat timeInLine(vec2 xy, float d)\n{\n    float x = xy.x;\n    float y = xy.y;\n    return(2.0*atan((-sqrt(-4.0*d*d*y*y+2.0*d*d+2.0*x*x+2.0*y*y-1.0)+d-x+y)/(2.0*d*y+d+x+y+1.0)));\n}\n\n//----------------------------------------\n\n\n\n\n\n\n\n//MAIN------------------------------------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //Make an aspect ratio out of it and align the origin to the center of the screen\n    vec2 xy = screenSize*(-1.0 + 2.0*fragCoord/iResolution.xy);\n    xy.x *= iResolution.x/iResolution.y;\n \n    \n    \n    \n    float radius = sqrt(pow((abs(xy.x)-d),2.0) + pow((xy.y),2.0));\n    if(abs(radius-1.0)<.005)\n    {\n        fragColor = polyColor;\n        return;\n    }\n    \n    \n    //The current time, in two second loops.\n    //0.0 is 0 seconds, tau is two seconds.\n    float time = time();\n    \n    \n    if (inBullet(xy,radius,time))\n        fragColor = capColor;\n    \n    \n    \n\n  \n    //don't do anything else if the pixel obviously isn't in picture\n    //this step should come before calculation of time\n    //only where it is right now b/c I'm not worried about optimization yet\n    if(abs(xy.y)>1.0 || (abs(xy.x) > 2.0 && radius > 1.0))\n       {\n       fragColor = bgColor;\n       return;\n       }\n    \n    \n    \n    //draw line\n   \t//if (!(r < 1.0 && xy.x < 0.0))\n    if(abs(mod(timeInLine(xy,d)-time,tau/n))<0.1\n       && (!(radius < 1.0 && xy.x < 0.0))||\n       \n       abs(mod(timeInLine(vec2(-xy.x,xy.y),d)+time-tau/4.0,tau/n))<0.1 \n       && (!(radius < 1.0 && xy.x > 0.0))\n\n       //(mod(timeInLine(vec2(-1.0*xy.x,xy.y),d)-time,tau/n)<0.1))\n       \n      )\n    {\n        fragColor = lineColor;\n        return;\n    }\n    \n    \n    \n    \n    fragColor = bgColor;\n    \n}","name":"Image","description":"","type":"image"}]}