{"ver":"0.1","info":{"id":"XsdXWf","date":"1461864536","viewed":357,"name":"Keep Calm and Shade On","username":"akohdr","description":"Borrowed Ben Weston's flag and pipelined some text over a flag texture to see how it flys.....    60fps on my box.\nMouse moves flag, resizes texture and text size.\n\n(credits in source)","likes":12,"published":1,"flags":32,"usePreview":0,"tags":["2d","text","font","surface","composite","multipass"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Ben Weston 2013\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\nconst float tau = 6.28318530717958647692;\n\n\n// Divide the view into multiple viewports\n// Set global variables to replace iResolution and fragCoord for the local viewport\n// Returns index of which panel is being drawn for this pixel\n// in the range [0,numPanels.x*numPanels.y)\nvec2 view_Resolution;\nvec2 view_FragCoord;\nint view_Index;\nvec4 view_selectionRelativeMouse;\n/*bool SideMenu( ivec2 numPanels )\n{\n\t// arrange so that the main view and the side views have the same aspect ratio\n\tvec2 dims = vec2(\n\t\t\t\t\t\tiResolution.x/float(numPanels.x+numPanels.y), // main view is sv.y times bigger on both axes!\n\t\t\t\t\t\tiResolution.y/float(numPanels.y)\n\t\t\t\t\t\t);\n\n\n\t// which one is selected?\n\tivec2 viewIndex = ivec2(floor(iMouse.xy/dims));\n\n\tint selectedPanel = 0;\n\tif ( viewIndex.x < numPanels.x )\n\t{\n\t\tselectedPanel = viewIndex.y+viewIndex.x*numPanels.y;\n\t}\n\t\n\n\t// figure out which one we're drawing\n\tviewIndex = ivec2(floor(fragCoord.xy/dims));\n\n\tint index;\n\tvec4 viewport;\n\tif ( viewIndex.x < numPanels.x )\n\t{\n\t\tviewport.xy = vec2(viewIndex)*dims;\n\t\tviewport.zw = dims;\n\t\tindex = viewIndex.y+viewIndex.x*numPanels.y;\n\t}\n\telse\n\t{\n\t\t// main view, determined by where the last click was\n\t\tviewport.x = float(numPanels.x)*dims.x;\n\t\tviewport.y = 0.0;\n\t\tviewport.zw = dims*float(numPanels.y);\n\t\tindex = selectedPanel;\n\t}\n\t\n\t// highlight currently selected\n\tif ( index == selectedPanel && viewIndex.x < numPanels.x &&\n\t\t( fragCoord.x-viewport.x < 2.0 || viewport.x+viewport.z-fragCoord.x < 2.0 ||\n\t\t  fragCoord.y-viewport.y < 2.0 || viewport.y+viewport.w-fragCoord.y < 2.0 ) )\n\t{\n\t\tfragColor = vec4(1,1,0,1);\n\t\treturn false;\n\t}\n\t\n\t// compute viewport-relative coordinates\n\tview_FragCoord = fragCoord.xy - viewport.xy;\n\tview_Resolution = viewport.zw;\n\tview_Index = index;\n\n\tview_selectionRelativeMouse = fract(iMouse/dims.xyxy);\n\t\n\treturn true;\n}*/\n\n// Gamma correction\n#define GAMMA (2.2)\n\nvec3 ToLinear( in vec3 col )\n{\n\t// simulate a monitor, converting colour values into light values\n\treturn pow( col, vec3(GAMMA) );\n}\n\nvec3 ToGamma( in vec3 col )\n{\n\t// convert back into colour values, so the correct light will come out of the monitor\n\treturn pow( col, vec3(1.0/GAMMA) );\n}\n\n// Set up a camera looking at the scene.\n// origin - camera is positioned relative to, and looking at, this point\n// distance - how far camera is from origin\n// rotation - about x & y axes, by left-hand screw rule, relative to camera looking along +z\n// zoom - the relative length of the lens\nvoid CamPolar( out vec3 pos, out vec3 ray, in vec3 origin, in vec2 rotation, in float distance, in float zoom )\n{\n\t// get rotation coefficients\n\tvec2 c = vec2(cos(rotation.x),cos(rotation.y));\n\tvec4 s;\n\ts.xy = vec2(sin(rotation.x),sin(rotation.y)); // worth testing if this is faster as sin or sqrt(1.0-cos);\n\ts.zw = -s.xy;\n\n\t// ray in view space\n\tray.xy = view_FragCoord.xy - view_Resolution.xy*.5;\n\tray.z = view_Resolution.y*zoom;\n\tray = normalize(ray);\n\t\n\t// rotate ray\n\tray.yz = ray.yz*c.xx + ray.zy*s.zx;\n\tray.xz = ray.xz*c.yy + ray.zx*s.yw;\n\t\n\t// position camera\n\tpos = origin - distance*vec3(c.x*s.y,s.z,c.x*c.y);\n}\n\n\nvec4 Noise( in vec2 x )\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n//\tvec2 f2 = f*f; f = f*f2*(10.0-15.0*f+6.0*f2);\n\n\tvec2 uv = p + f;\n\n#if (1)\n\tvec4 rg = textureLod( iChannel0, (uv+0.5)/256.0, 0.0 );\n#else\n\t// on some hardware interpolation lacks precision\n\tvec4 rg = mix( mix(\n\t\t\t\ttexture( iChannel0, (floor(uv)+0.5)/256.0, -100.0 ),\n\t\t\t\ttexture( iChannel0, (floor(uv)+vec2(1,0)+0.5)/256.0, -100.0 ),\n\t\t\t\tfract(uv.x) ),\n\t\t\t\t  mix(\n\t\t\t\ttexture( iChannel0, (floor(uv)+vec2(0,1)+0.5)/256.0, -100.0 ),\n\t\t\t\ttexture( iChannel0, (floor(uv)+1.5)/256.0, -100.0 ),\n\t\t\t\tfract(uv.x) ),\n\t\t\t\tfract(uv.y) );\n#endif\t\t\t  \n\n\treturn rg;\n}\n\nfloat DistanceField( vec3 pos );\n\nvec3 Normal( vec3 pos )\n{\n\tconst vec2 delta = vec2(0,.01);\n\tvec3 grad;\n\tgrad.x = DistanceField( pos+delta.yxx )-DistanceField( pos-delta.yxx );\n\tgrad.y = DistanceField( pos+delta.xyx )-DistanceField( pos-delta.xyx );\n\tgrad.z = DistanceField( pos+delta.xxy )-DistanceField( pos-delta.xxy );\n\treturn normalize(grad);\n}\n\n\n// ----------------------\n\nfloat RippleHeight( vec2 pos )\n{\n\tvec2 p = pos+vec2(-1,.2)*iTime;\n\t\n\tp += vec2(1,0)*Noise(p).y; // more natural looking ripples\n\tfloat f = Noise(p).x-.5;\n\tp *= 2.0;\n\tp += vec2(0,-.5)*iTime;\n\tf += (Noise(p).x-.5)*.2;\n\tp *= 2.0;\n\tp += vec2(-3,0)*iTime;\n\tf += (Noise(p).x-.5)*.05;\n\t\n\tf = f*(1.0-exp2(-abs(pos.x)));\n\treturn f*1.0;\n}\n\nfloat DistanceField( vec3 pos )\n{\n\treturn (RippleHeight(pos.xy)-pos.z)*.5;\n}\n\n// map a uv space onto a distorted surface\nvec2 UVMapping( vec2 target )\n{\n\t// need to march vertically to absorb vertical creases, and horizontally for horizontal ones\n\t// cheat, by seperating these two\n\tvec2 uv = vec2(0);\n\t\n\tconst int n = 16;\n\tconst float fudge = 1.0; // use values > 1 to allow for extra ripples we're not measuring\n\tvec2 d = target/float(n);\n\tvec2 l;\n\tl.x = RippleHeight( vec2(0,target.y) );\n\tl.y = RippleHeight( vec2(target.x,0) );\n\tfor ( int i=0; i < n; i++ )\n\t{\n\t\tvec2 s;\n\t\ts.x = RippleHeight( vec2(d.x*float(i),target.y) );\n\t\ts.y = RippleHeight( vec2(target.x,d.y*float(i)) );\n\t\t//uv.x += sign(d.x)*sqrt(pow(fudge*,2.0)+d.x*d.x);\n\t\t//uv.y += sign(d.y)*sqrt(pow(fudge*,2.0)+d.y*d.y);\n\t\tuv += sign(d)*sqrt(pow(fudge*(s-l),vec2(2.0))+d*d);\n\t\tl = s;\n\t}\n\t\n\treturn (uv+vec2(0,1))/vec2(3.0,2.0);\n}\n\n\n// xyz = normal, w = transmission from far side\nvec4 Weave( vec2 uv )\n{\n\tvec2 a = uv*vec2(3.0,2.0)*view_Resolution.y*.85;\n\tfloat h = (sin(a.x)+sin(a.y))*.25+.5;\n\t\n\th = h*.1; // transparency within the flag\n\t\n\t// edges\n\th = max(h,smoothstep(.495,.5,abs(uv.x-.5)));\n\th = max(h,smoothstep(.495,.5,abs(uv.y-.5)));\n\t\n\treturn vec4(0,0,0,h);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t// since Chrome 36 the extra logic for the SideMenu won't compile on some PCs (my work PC is ok, my home one is not)\n\tview_Resolution = iResolution.xy;\n\tview_FragCoord = fragCoord.xy;\n\tview_Index = 3;\n\tview_selectionRelativeMouse = iMouse/view_Resolution.xyxy;\n\n\t//if ( SideMenu( ivec2(1,4) ) )\n\t{\n\t\tvec3 pos, ray;\n\t\tCamPolar( pos, ray, vec3(1.5,0,0), vec2(-.8,-.5)+vec2(.9,1.5)*view_selectionRelativeMouse.yx, 10.0, 3.5 );\n\t\t\n\t\tfloat t = 0.0;\n\t\tfloat h = 1.0;\n\t\tfor ( int i=0; i < 20; i++ )\n\t\t{\n\t\t\tif ( h < .01 )\n\t\t\t\tbreak;\n\t\t\tfloat h = DistanceField( pos+t*ray );\n\t\t\tt += h;\n\t\t}\n\t\t\n\t\tpos += t*ray;\n\n\t\tvec2 uv = UVMapping( pos.xy );\n\t\t\n\t\tvec3 col = texture( iChannel3, uv ).rgb;\n\t\t\n\t\tvec4 weave = Weave(uv);\n\t\t\n\t\tvec3 normal = Normal( pos );\n\t\t\n\t\tfloat nl = dot(normal,normalize(vec3(-3,1,-2)));\n\t\tfloat l = max( nl, .0 );\n\t\tfloat bl = (max( -nl, .0 ))*(weave.a*.0);\n\t\tcol *= (l + bl*vec3(1,.8,1))*vec3(1.2,1.1,1) + vec3(.1,.13,.2);\n\t\t\n\t\t//if ( uv.x < .0 || uv.x > 1.0 || uv.y < 0.0 || uv.y > 1.0 )\n\t\tcol = mix( col, vec3(.5,.65,.9)*(Noise(ray.xy*4.0).x*.3+1.0), weave.a );\n\t\t\n\t\tcol = mix( col, vec3(cos(uv.x*50.0)),smoothstep(0.015,0.01,abs(uv.x+.01))*smoothstep(1.01,1.0,uv.y));\n\t\t\n\t\tfragColor = vec4(ToGamma(col),1.0);\n\t}\n}\n\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Created by Andrew Wild - akohdr/2016\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n/*\n\t\"And that the Union Flag shall be Azure, the Crosses Saltires of St. Andrew and \n     St. Patrick Quarterly per Saltire, counterchanged Argent and Gules; the latter \n     fimbriated of the Second, surmounted by the Cross of St. George of the Third, \n     fimbriated as the Saltire : ...\"\n\n\thttps://en.wikipedia.org/wiki/Union_Jack\n*/\n\n// comment appropriately for favorite flag\n#define LOOP_FLAGS\n\n#define SHOW_ST_ANDREW\n#define SHOW_ST_PATRICK\n#define SHOW_ST_GEORGE\n#define SHOW_GUIDES\n\n// despite working elsewhere quads/triangles not working on iPhone?!\n// ...and now it works after resuffling to add Fab's code golf,  hmmm.....\n//\n// FIXED: see large quad OR on return of Fimbriation()\n//#define USE_TRIANGLES\n\n#define RED vec4(.811, .078, .168, 1.)\n#define WHT vec4(1.00, 1.00, 1.00, 1.)\n#define BLU vec4(.000, .140, .488, 1.)\n#define BLK vec4(.000, .000, .000, 1.)\n\n#define DIM  vec2(60,30)\n#define DIM2 vec2(30,15)\n#define DX(i) (1.479*i)\n#define DY(i) (0.739*i)\n\nbool baryT(const in vec4 a,   // \"The entire British empire was built on cups of tea...\"  :)\n           const in vec4 b) \n{\n    vec4 p =(vec4(a.z,b.wxy) - vec4(b.xyz,a.w)) * a.yxyx,\n         q = vec4(a.wz, b.yx) * b,\n         r = vec4(q.zx - q.wy, a.zw * b.wz);\n    vec2 t = (r.xy + p.yw + p.zx)/(r.x + r.y + r.z - r.w);\n    return !(t.x<0.||t.y<0.||(t.x + t.y)>1.);\n}\n#define inTri(p,a,b,c) baryT(vec4(p,a),vec4(b,c))\n#define inQuad(p,a,b,c,d) (inTri(p,a,b,c)||inTri(p,c,d,a))\n\nfloat distLine(vec2 p, float x, float y, float z) {\n    return abs(x*p.x + y*p.y + z)/sqrt(x*x + y*y);\n}\n\nbool inDiagonalCross(in vec2 p, in float w)\n{\n#ifdef USE_TRIANGLES\n    // Works fine on iPad, I just dont get it !! (see FIX below)\n    vec2 d = vec2(DX(w),-DY(w)),\n         a = DIM+d,\n         b = DIM-d,\n         pa = abs(p-DIM2);\n    \n    return inQuad(pa,a,b,-a,-b);\n#else    \n    float a = 1./DX(1.),\n          b = 1./DY(1.);\n    \n    vec2 po = p-DIM2;;\n        \n    return distLine(po,a, b,.0)<w ||\n           distLine(po,a,-b,.0)<w;\n#endif\n}\n\nbool inCross(in vec2 p, in float w) \n{\n    vec2 a = abs(p-DIM2);\n    return a.x<w || a.y<w;\n}\n\nbool Fimbriation(in vec2 p) \n{\n    if (inCross(p,5.)) return true;\n    \n#ifdef USE_TRIANGLES\n    float r = .3,\n          s = 1.2;\n#else\n    float r = .5,\n          s = 1.55;\n#endif\n    \n    vec2 y1 = vec2(0,DY(4.)),\n         y2 = vec2(0,DY(2.5)),\n         a = p-y1,\t\t\n         b = p+y2,\n         c = p+y1,\n         d = p-y2,\n         q = p-DIM2;\n    \n    bool qx = q.x<0.,\n         qy = q.y<0.;\n    \n    #define inDX inDiagonalCross\n\n/* FIX: Apparently this is where iPhone compiler was choking\n    return (!qx && !qy && (inDX(a,r)||inDX(b,s)))||  // top right clockwise\n           (!qx &&  qy && (inDX(a,r)||inDX(b,s)))||\n           ( qx &&  qy && (inDX(c,r)||inDX(d,s)))||\n           ( qx && !qy && (inDX(c,r)||inDX(d,s)));\n*/\n    \n    bool b1 = (!qx && !qy && (inDX(a,r)||inDX(b,s))),  // top right clockwise\n         b2 = (!qx &&  qy && (inDX(a,r)||inDX(b,s))),\n         b3 = ( qx &&  qy && (inDX(c,r)||inDX(d,s))),\n         b4 = ( qx && !qy && (inDX(c,r)||inDX(d,s)));\n\n    return b1 || b2 || b3 || b4;\n}\n\n#ifdef SHOW_GUIDES\nvoid showGuides( inout vec4 fragColour, in vec2 fragCoord ){\n    bool isMouse = iMouse.z>0.;\n    vec2 ir = isMouse ? iMouse.xy : iResolution.xy;\n    if(isMouse) \n    {\n        float ar = ir.x/ir.y;\n        vec2 ps = ir/DIM,\n             pc = fragCoord-ir/2.;\n\n        for(int i =-3; i<4; i++) {\n            float f = float(i),\n                a = ps.y*DY(f)+ps.x*DX(f),\n                b = pc.x,\n                c = pc.y*ar;\n            if((abs(a+b-c)<1.)||(abs(a-b-c)<1.))\n            {\n                fragColour = BLK; \n                return;\t\t//early exit\n            }\n        }\n    }\n}\n#endif\n\nvoid mainImage( out vec4 fragColour, in vec2 fragCoord )\n{\n    fragColour = WHT;  // Let's spell 'colour' correctly shall we.\n    bool isMouse = iMouse.z>0.;\n\n    if(isMouse && (fragCoord.x>iMouse.x || fragCoord.y>iMouse.y)) return;\n\n    vec2 ir = isMouse ? iMouse.xy : iResolution.xy;\n    vec2 p = DIM * (fragCoord.xy / ir);\n\n    // switch composition of flags on loop\n    float mt = mod(iTime,12.5);\n    \n#ifdef SHOW_ST_ANDREW\n    #ifdef LOOP_FLAGS\n    if((mt<5.)||((mt>7.5)&&(mt<10.)))\n\t#endif\n\tfragColour = !inDiagonalCross(p,2.2) ? BLU : fragColour;\n#endif\n    \n#ifdef SHOW_ST_PATRICK\n    #ifdef LOOP_FLAGS\n    if((mt < 2.5)||(mt>10.))\n\t#endif\n    fragColour = inDiagonalCross(p,2.2) ? RED : fragColour;\n#endif\n\n#ifdef SHOW_ST_GEORGE\n    #ifdef LOOP_FLAGS\n    if(mt <7.5)\n\t#endif\n    {\n        fragColour = Fimbriation(p) ? WHT : fragColour;\n        fragColour = inCross(p,3.)  ? RED : fragColour;\n    }\n#endif\n    \n#ifdef SHOW_GUIDES\n\tshowGuides(fragColour, fragCoord);\n#endif\n    \n    \n#ifdef LOOP_FLAGS\n    // fade through black\n    fragColour *= abs(mod(1.25+mt,2.5)-1.25);\n#endif\n    \n}\n\n// Fab's code golf\nvoid mainImage2( out vec4 O, vec2 u )\n{\n    vec2 U = u;  //reusing input var breaks guides\n    \n    vec2 R =  iResolution.xy,V,S;\n\tU += U-R;\n\t\n    V = abs(S=U/R*mat2(1,-1,1,1)*.7); S*=U; U = abs(U/R.y); \n    float v = min(U.x,U.y), d = min(V.x,V.y);\n    O = vec4(.8,0,0,1);\n    O =   v < .2  ? O\n        : v < .34 ? ++O\n        : d < .12&&min(S.x,S.y)<0. ? O \n        : d < .16  ? ++O \n        :           vec4(0,0,.5,1);\n#ifdef SHOW_GUIDES\n    showGuides(O,u);\n#endif\n}\n\n// Toggle impls.\n//#define mainImage mainImage1\n\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// Created by Andrew Wild - akohdr/2016\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n//    for details refer to dev shader @ https://www.shadertoy.com/view/XsdSWS\n\n// DEBUG flag colours primitives RGB//\n//#define DEBUG\n\n#define SCROLL\n//#define DISTORT\n#define ANIMATE_LETTERS\n\n#define INK vec4(.3,0.,0.,1.)\n#define WIDTH 6.\n\nvoid antialias(inout vec4 k, float d, float w, vec4 K) {\n    // Standard filled antialiased lines\n    //    k += K*(w-d);\n\n    // Neon glow\n        k += K/d;\n\n    // Partially stenciled lines\n    //  k += K*sin(d-w);\n\n    // Hollow lines\n    //k += K*cos(1.5+d-w);\n\n    // Center line plus outline\n    //k += K*tan(.2+d-w);\n\n    // Stripe filled (using screen x/y would give stable fill)\n    //    k += K*max(K*cos(d-w), cos(7.*(d-w)));\n\n    // Temporally striped and outlined\n    //  k += K*max(K*cos(d-w), 1.+2.*cos(7.*(d-w)*(1.1+sin(iTime/2.))));\n\n    // Flashing font (temporal)\n    //    k += K*max(K*cos(d-w), sin(5.*iTime));\n    \n    k.w = k.x+k.y+k.z>.1 ? 1. : 0.;\n}\n\n// ASCII char ordinals\n#define ASC_Sp 32\n#define ASC_a 97\n#define ASC_b 98\n#define ASC_c 99\n#define ASC_d 100\n#define ASC_e 101\n#define ASC_f 102\n#define ASC_g 103\n#define ASC_h 104\n#define ASC_i 105\n#define ASC_j 106\n#define ASC_k 107\n#define ASC_l 108\n#define ASC_m 109\n#define ASC_n 110\n#define ASC_o 111\n#define ASC_p 112\n#define ASC_q 113\n#define ASC_r 114\n#define ASC_s 115\n#define ASC_t 116\n#define ASC_u 117\n#define ASC_v 118\n#define ASC_w 119\n#define ASC_x 120\n#define ASC_y 121\n#define ASC_z 122\n\n// some colours\n#define RED vec4(1.,.0,.0,1.)\n#define GRN vec4(.0,1.,.0,1.)\n#define BLU vec4(.0,.0,1.,1.)\n\nfloat dBezier(vec2 p, vec4 ac, vec2 b);\n\nvoid bezier(inout vec4 k, vec2 p, vec4 ac, vec4 bw, vec4 K) \n{\n    #ifdef DEBUG\n    K = RED;\n    #endif\n    float d = dBezier(p,ac,bw.xy);\n    if(d<bw.z) antialias(k,d,bw.z,K);\n}\n\nvoid circle(inout vec4 k, in vec2 p, vec4 a, vec4 K)\n{\n    #ifdef DEBUG\n    K = GRN;\n    #endif\n    float r = a.z,\n        w = a.w,\n        w2 = w/2.,\n        l = length(p-a.xy),\n        d = (l>r) ? abs((l-r)+w2): abs((r-l)-w2);\n    if(d<w) antialias(k,d,w,K);\n}\n\nvoid line(inout vec4 k, vec2 p, vec4 l, float w, vec4 K)\n{\n    #ifdef DEBUG\n    K = BLU;\n    #endif\n    vec2 a=l.xy, b=l.zw;\n    b -= a;  p -= a;\n    float d = length (p - clamp (dot (p, b) / dot (b, b), .0, 1.) * b);\n    if(d<w) antialias(k,d,w,K);\n}\n\nvec4 procGlyph(inout vec4 k, inout vec4 c, in vec2 p,\n               vec2 s, float w, vec4 K,\n               mat4 ps, int a)\n{\n    bool skip = false;\n    for(int i=0;i<4;i++) {\n        if(skip) {skip = false; continue;}\n        vec4 u = s.xyxy*ps[i];\n        if(u.x<0.)\n            if(u.z<0.){\n                vec4 v = s.xyxy*ps[i+1]; skip = true;\n                bezier(k, p, c.xyxy+vec4(-u.x,u.y,-u.z,u.w), c+vec4(v.xy,w,0.), K);\n            }\n            else\n                circle(k, p, c+vec4(-u.x,u.yz,w), K);\n        else\n            if(u.x>0.) line(k, p, c.xyxy+u,w, K);\n    }\n    c.x += s.x*float(a);\n\treturn k;\n}\n\n// Rotates control points retaining the sign of x components (micro-op)\nvec4 rotPt(vec4 p, float a) \n{\n    vec2 s = sign(p.xz);\n    vec4 trans = -vec4(5,5,5,5);\n    p += trans; p *=.01;\n    \n    vec3 sc = vec3(cos(a),-sin(a),0);\n\t\t      sc.z = -sc.y;\n    mat2 rot2D = mat2( sc.xyzx);\n\n    p.xy = rot2D*p.xy;\n    if(s.x == s.y) // don't transform circle radii\n\t    p.zw = rot2D*p.zw;\n    \n    p*=100.; p -= trans;\n    p.xz = s*abs(p.xz);\n\n    return p;\n}\n\n// Add pipeline step for select chars\nvec4 chainProcGlyph(inout vec4 k, inout vec4 c, in vec2 p,\n                    vec2 s, float w, vec4 K,\n                    mat4 ps, int a)\n{\n    // Because we can.......\n    // tweak the colour\n    float t = iTime+150.,\n         ct = t*.00001*p.x;\n    ct += ct;\n    K = abs(vec4(sin(2.*ct),cos(5.*ct),sin(3.*ct),1));\n\n\t// off centered rotation breaks apart letter into 2D components\n    float sT = sin(p.x/200.+2.*t), cT = cos(t),\n          r = cT*1.5*(1.+cos(2.1+sT));\n    ps[0] = rotPt(ps[0],r);\n    ps[1] = rotPt(ps[1],r);\n    ps[2] = rotPt(ps[2],r);\n    ps[3] = rotPt(ps[3],r);\n\n    return procGlyph(k,c,p,s,w,K,ps,a);\n}\n\n#define Z4 0,0,0,0\n#define Z8 Z4,Z4\n\n//The 'eidos' of font.....\n#define a_   mat4( -2,8,-13,-8, \t16,15,0,0,   -7,-3,6,0,   \tZ4)\n#define b_   mat4( 1,20,0,-7,   \t-8,0,8,0,   Z8)\n#define c_   mat4( -1,0,-13,5,   \t3,12,0,0, \t -1,0,-14,-3,   -2,-12,0,0)\n#define d_   mat4( -5,0,8,0,  \t\t13,20,13,-7, Z8)\n#define e_   mat4( -6,6,-15,-6,   \t-8,-10,0,0,   -7,7,-1,-2,   25,2,0,0)\n#define f_   mat4( -9,18,-2,-8,  \t1,25,0,0,    9,5,0,4,   \tZ4)\n#define g_   mat4( -7,0,8,0,   \t\t-15,8,-1,-16,17,-28,0,0, \tZ4)\n#define h_   mat4( 1,20,0,-8,   \t-1,4,-14,-8, 13,15,0,0,   \tZ4)\n#define i_   mat4( -3,13,2,0,   \t-2,7,-4,-6,  -1,-16,0,0,   \tZ4)\n#define j_   mat4( -2,13,2,0,   \t-2,7,-1,-15, 5,-22,0,0,   \tZ4)\n#define k_   mat4( 1,18,0,-8,   \t1,-2,13,6,   5,0,13,-8,   \tZ4)\n#define l_   mat4( -1,19,-6,-5,  \t0,-18,0,0,   Z8)\n#define m_   mat4( -1,-9,-8,-3,   \t2,20,0,0,  \t -8,-3,-16,-9,  14,20,0,0)\n#define n_   mat4( 1,7,0,-8,   \t\t-1,4,-14,-8, 15,15,0,0,   \tZ4)\n#define o_   mat4( -7,0,8,0, \t\tZ4, \t\t Z8)\n#define p_   mat4( -9,0,8,0,   \t\t1,7,1,-20, \t Z8)\n#define q_   mat4( -6,0,8,0,   \t\t14,7,14,-20, Z8)\n#define r_   mat4( 1,8,0,-7,   \t\t-2,3,-13,5,  11,12,0,0,   \tZ4)\n#define s_   mat4( -5,0,-8,7,   \t-8,8,0,0,  \t -6,-1,-1,-6,   15,-11,0,0)\n#define t_   mat4( -4,15,-12,-5, \t1,-15,0,0,   1,8,8,8, \t\tZ4)\n#define u_   mat4( -1,8,-13,-4,  \t0,-16,0,0,   14,8,14,-8,    Z4)\n#define v_   mat4( 1,8,6,-8,   \t\t11,8,6,-8,   Z8)\n#define w_   mat4( 1,8,4,-8,   \t\t4,-6,9,4,    9,4,14,-6,   \t14,-8,18,8)\n#define x_   mat4( 1,8,8,-8,   \t\t8,8,0,-8,    Z8)\n#define y_   mat4( -2,8,-12,-4,  \t4,-11,0,0,   -14,8,-1,-18,  14,-28,0,0)\n#define z_   mat4( 1,8,8,8,   \t\t8,8,0,-8,    1,-8,8,-8,   \tZ4)\n\nint msgCharAtPos(const int xc){\n// ***WARNING***: Big ugly if blocks blow up compilers, exhaust memory and crash browsers ?!\n\n    /*  \n\t#define MAP(a,b,c) if(a<b)return c;\n\t// char pos mappings\n    #define A_  MAP(xc,x++,97)\n    #define B_  MAP(xc,x++,98)\n    #define C_  MAP(xc,x++,99)\n\n....\n\n    int x = 1;\n    // This is lighter but STILL big if that taxes/breaks the *doze compiler(s)  ???!!!!!\n    SP_ T_ H_ E_ SP_ Q_ U_ I_ C_ K_ SP_ B_ R_ O_ W_ N_ SP_ F_ O_ X_ SP_ SP_ SP_\n        SP_ J_ U_ M_ P_ S_ SP_ O_ V_ E_ R_ SP_ T_ H_ E_ SP_ L_ A_ Z_ Y_ SP_ SP_ SP_\n        SP_ D_ O_ G_\n*/\n    \n    // We can use lookup table with caveats (see below)\n    \n     int m[50];\n     m[ 0] = ASC_k;\n     m[ 1] = ASC_e;\n     m[ 2] = ASC_e;\n     m[ 3] = ASC_p;\n     m[ 4] = ASC_Sp;\n     m[ 5] = ASC_c;\n     m[ 6] = ASC_a;\n     m[ 7] = ASC_l;\n     m[ 8] = ASC_m;\n     m[ 9] = ASC_Sp;\n     m[10] = ASC_a;\n     m[11] = ASC_n;\n     m[12] = ASC_d;\n     m[13] = ASC_Sp;\n     m[14] = ASC_s;\n     m[15] = ASC_h;\n     m[16] = ASC_a;\n     m[17] = ASC_d;\n     m[18] = ASC_e;\n     m[19] = ASC_Sp;\n     m[20] = ASC_Sp;\n     m[21] = ASC_Sp;\n     m[22] = ASC_Sp;\n     m[23] = ASC_Sp;\n     m[24] = ASC_o;\n     m[25] = ASC_n;\n        \n    // The loop is required to overcome compiler requirement for 'constant' index\n    //   (I can only guess maybe internal GPU memory access is somekind of block SRAM (?))\n    for (int i=0; i<26; i++){\n        if (i==xc) return m[i];\n    }\n    \n\treturn ASC_Sp;\n}\n\n// dimension lowering mapping of 2D screen pos (pixels) to 1D text pos (chars)\nfloat whereInFixedFontSpace(vec2 p, vec2 FONT_DIMS) {\n\n    p.y = iResolution.y-p.y; //flip read top down left right\n\n    float row = floor(p.y/FONT_DIMS.y),\n          col = floor(p.x/FONT_DIMS.x),\n   colsPerRow = floor(iResolution.x/FONT_DIMS.x);\n\n    return row*colsPerRow + col;\n}\n\nvoid screen(inout vec4 k, in vec2 p )\n{\n    vec2 SCREEN_SIZE = vec2(10,4),\t\t\t\t\t\t// in chars\n           FONT_DIMS = iResolution.xy/SCREEN_SIZE;\t\t// char cell dims\n\n    // cursor position\n    vec4 c = vec4(0);\n\n    // find 1D linear position in character space\n    float xc = whereInFixedFontSpace(p, FONT_DIMS);\n\n    // find the character at position in message\n    highp int xci = int(xc);\n    int ch = msgCharAtPos(xci);\n\n    if(ch==ASC_Sp) return;  //early exit \n\n    // calculate cursor position based on screen pos\n    c.xy = floor(p/FONT_DIMS)*FONT_DIMS;\n\n    // glyph offset within cell\n    c.xy += FONT_DIMS/vec2(4,2);\n\n    // remainder of glyph rendering context\n    float w = WIDTH;\n    vec4 K = INK;\n\n    // mouse sizing\n    vec2 s = iMouse.z>0. ? 4. * iMouse.xy/iResolution.xy : vec2(.004)*iResolution.xy;\n\n    // call the appropriate rendering function\n    //     uses context (k,c,p,s,w,K)\n\n// ***WARNING***: Big ugly if blocks blow up compilers, exhaust memory and crash browsers ?!\n    \n    // Design descision to use mat4/struct was to facilitate conditional assignment\n    // TODO: red/black tree the glyph lookup process\n    \n\t// 'Wiggly' letters\n    mat4 g =(ch== 97) ? a_ :\n            (ch== 98) ? b_ :\n            (ch==100) ? d_ :\n            (ch==101) ? e_ :\n            (ch==102) ? f_ :\n            (ch==112) ? p_ :\n            mat4(0);\n      \n    if (abs(g[0][0])>0.) \n#ifdef ANIMATE_LETTERS        \n\t    chainProcGlyph(k,c,p,s,w,K,g,50);\n#else\n        procGlyph(k,c,p,s,w,K,g,50);    \n#endif\n    else {\n        g = (ch== 99) ? c_ :\n            (ch==103) ? g_ :\n            (ch==104) ? h_ :\n            (ch==105) ? i_ :\n            (ch==106) ? j_ :\n            (ch==107) ? k_ :\n            (ch==108) ? l_ :\n            (ch==109) ? m_ :\n            (ch==110) ? n_ :\n            (ch==111) ? o_ :\n            (ch==113) ? q_ :\n            (ch==114) ? r_ :\n            (ch==115) ? s_ :\n            (ch==116) ? t_ :\n            (ch==117) ? u_ :\n            (ch==118) ? v_ :\n            (ch==119) ? w_ :\n            (ch==120) ? x_ :\n            (ch==121) ? y_ :\n            (ch==122) ? z_ : \n        \tmat4(0);\n        procGlyph(k,c,p,s,w,K,g,50);    \n    }\n}\n\nvoid mainImage(out vec4 k, in vec2 p )\n{\n    k = vec4(0);\n    \n    // keep undistorted coord for flag backdrop lookup later\n    vec2 uv = p/iResolution.xy;\n\n    vec2 ir = iResolution.xy,\n        ir2 = ir/2.;\n    float f = .0005*ir.y*float(iFrame+50);  // tweaked for preview\n    \n#ifdef DISTORT\n    // shimmer\n    float w = (ir.y/12.);\n    p.x += w/3.*sin(mod(p.y/w,w));\n#endif\n    \n#ifdef SCROLL\n    // scroll up\n//    p.y -= 6.*f;     \t\t// absolute speed pixel/frame\n    p.y -= f*log(ir2.y);\t// seems to balance speed better switching res.\n//    p.y -= 20.*f*log(ir2.y);\t// go nuts....  still solid 60fps on my box\n    p.y = mod(p.y,ir.y);\n#endif\n    \n    screen(k,p);\n    \n    if(k.w<1.) {\n        k = texture(iChannel0, uv);\n    }\n\n}\n\n\n\n\n\n\n\n//=============================================================================\n// derived from bezier code @ https://www.shadertoy.com/view/Mlj3zD\n#define PI 3.14159265358979\nint findRoots(vec4 abcd, out vec3 r)\n{\n    float a = abcd[0], \n          b = abcd[1], \n          c = abcd[2], \n          d = abcd[3];\n    vec3 vS = vec3(-1);\n    if (abs(a) > 1e-9){\n        float z = 1./a;\n        abcd *= z;\n        float d3 = 1./3.,\n             d27 = 1./27.;\n        a = abcd[1];\n        b = abcd[2];\n        c = abcd[3];\n        float aa = a*a,\n              p = b-aa*d3,\n              q = a*(2.*aa-9.*b)*d27+c,\n              ppp = p*p*p,\n              D = q*q+4.*ppp*d27;\n        float delta = -a*d3;\n        if (D > 1e-9){\n            z = sqrt(D);\n            vec2 uv = .5*(vec2(z,-z)-q),\n                  s = sign(uv);\n            uv = abs(uv);\n    \t\tfloat u = s.x*pow(uv.x,d3),\n                  v = s.y*pow(uv.y,d3);\n            r.x = u+v+delta;\n            return 1;\n        }\n        else if (D < -1e-9){\n            float u = sqrt(-p*d3)*2.,\n                  s = -sqrt(-27.0/ppp)*q*.5;\n            if (abs(s) > 0.) {}\n            r = u*cos(vec3(acos(s)*d3) + vec3(0,2,4)*PI*d3)+delta;\n            return 3;\n        }\t\t\n        else {\n            q = sign(q)*pow(abs(q)*.5,d3);\n            r.xy = vec2(-q,q)+delta;\n            r.x *= 2.;\n            return 2;\n        }\n    }\n    else {\n        if (abs(b) <= 1e-9 && abs(c) > 1e-9) {\n            r.x = -d/c;\n            return 1;\n        }\n        else {\n            float D = c*c-4.*b*d,\n                z = 1./(2.*b);\n            if (D > 1e-9) {\n                D = sqrt(D);\n                r.xy = (vec2(-D,D)-c)*z;\n                return 2;\n            }\n            else if (D > -1e-9) {\n                r.x = -c*z;\n                return 1;\n            }\n        }\n    }\n    return 0;\n}\n\nvec2 bzPos(float t, vec2 a, vec2 b, vec2 c) \n{\n    float mT = 1.-t;\n    vec2 pos = mT*mT*a+2.*t*mT*b+t*t*c;\n    return pos;\n}\n\nfloat dBezier(vec2 p, vec4 ac, vec2 b) \n{\n    vec2 a = ac.xy, \n         c = ac.zw,\n       dap = a-p,\n       dba = b-a,\n       sac = a+c-b*2.;\n    vec3 r;\n    float dist = 999.;\n    int roots = findRoots(vec4(dot(sac,sac), \n                               dot(dba,sac)*3.,\n                               dot(dba,dba)*2.+dot(dap, sac), \n                               dot(dap,dba)),r);\n    float r1 = r.x,\n          r2 = r.y,\n          r3 = r.z;\n    if (roots > 0 && r1 >= 0. && r1 <= 1.)\n        dist = distance(p,bzPos(r1,a,b,c));\n    if (roots > 1 && r2 >= 0. && r2 <= 1.)\n        dist = min(dist, distance(p,bzPos(r[1],a,b,c)));\n    if (roots > 2 && r3 >= 0. && r3 <= 1.)\n        dist = min(dist, distance(p,bzPos(r[2],a,b,c)));\n    return min(dist, min(distance(p, a), distance(p, c)));\n}\n","name":"Buffer B","description":"","type":"buffer"}]}