{"ver":"0.1","info":{"id":"XlSyzm","date":"1507958825","viewed":140,"name":"Raycast Learning","username":"mgrant8164","description":"cylinder?\nmouse y to change FOV.\nVery (VERY) much a work in progress.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raycast"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdfGRn","filepath":"/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","previewfilepath":"/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define LOD 1000\n\n#define PI 3.14159265359\n#define TOU 6.28318530718\n\nconst int angM = 0;\n\nconst float radius = 1.;\n\nconst float period = 1.;\n\nconst float maxf = 0.5;\n\nfloat g(float x) {\n    return abs(mod(x,1.) - 0.5);\n}\n\nfloat f(float x, float ang) {\n    x = mod(x, period) / period;\n    //return 0.25 * (.5 - abs(x - .5));\n    //return maxf*abs(cos(x*TOU));\n    //return maxf*abs(cos(x*TOU)) * g(4.*ang/TOU);\n    return \n        maxf*0.5*(cos(x*TOU)+1.)\n        *0.5*(0.25*sin(16.*ang + 1.*iTime*TOU)+1.75);\n}\n\nvec3 getWall(vec2 dir) {\n    const float r = 1.;\n    \n    float slope = length(dir);\n    float ang = atan(dir.y,dir.x);\n    \n    //f(t) = 0.2 * cos(period*t) + 0.1 \n    //f(x) = 0.2x\n    \n    \n    //go to beginning of max\n    float x0 = (radius-maxf)/slope+ iTime + (ang / TOU * period)*float(angM);\n    float r0 = maxf;\n    //x = p / (0.2 - slope);\n    //return vec3(x/20.);\n    //x = (r-maxf)/slope + ( -maxf / (s - 0.2));\n    //x = r / slope;\n    //x *= 1./sin(0.25*iTime);\n    \n    \n    //x is dist, r is the new radius\n    float offset = 0.;\n    for(int i = 0; i < LOD; i++) {\n        //traverse and find nearest intersection\n        offset = float(i)/float(LOD)*period;\n        \n        float fx = f(x0 + offset, ang);\n        if(fx > r0 - slope*offset) {\n            offset -= -1./float(LOD)*period;\n            break;\n        }\n    }\n    float x = offset + x0;\n    \n    return texture(iChannel0,vec2(ang/TOU, fract(x/period))).rgb;\n    \n    return vec3(f(x, ang)/maxf);\n    return vec3(mod(x, period) / period);\n    \n    //vec3 pos = dir;\n    //x^2 + y^2 = r^2\n    float t = r / length(dir);\n    float d = sqrt(t*t-r*r);\n    return vec3(sin(x+4.*iTime),cos(x+-4.*iTime),cos(x+3.*iTime+PI/2.));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float scale = max(iResolution.x, iResolution.y);\n    vec2 dims = iResolution.xy/scale;\n\tvec2 uv = (2.*fragCoord.xy - iResolution.xy) / scale;\n    \n    //field of view, in radians along the x-axis <0,PI> \n    float fov = PI/(2. + 2.*((iMouse.z>0.5)?iMouse.y/iResolution.y-0.5:0. ));\n    \n    //ray direction\n    vec3 dir = normalize(vec3( uv, dims.x/tan(fov/2.) ));\n    //normalized per unit distance\n    vec2 dr = uv * tan(fov / 2.) / dims.x;\n    fragColor = vec4(getWall(dr),1.);\n\t//fragColor = vec4(uv,0.5+0.5*sin(iTime),1.0);\n}","name":"Image","description":"","type":"image"}]}