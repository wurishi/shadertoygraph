{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[{"channel":0,"type":"cubemap","id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"}},{"channel":1,"type":"music","id":"4sXGRr","filepath":"/media/a/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3","sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"}}],"code":"#define REFRACTION_INDEX 0.75\n#define PI   3.14159265359\n#define PI2   ( PI * 2.0 )\n//-----------------------------\n#define time iTime\n#define EPSILON .001\n\nconst int MAX_RAY_STEPS = 100;\nint typeTwisting = 1;\nint typeFigures = 0;\nfloat paramRotate = 7.;\nvec3 lightDir       = normalize(vec3(-1.6, -7., -6.4)); \nfloat segment = 24.;\n\n\nstruct mat\n{\n  float typeMat;        // Ñ‚Ð¸Ð¿ Ð¼Ð°Ñ‚ÐµÑ€Ð¸Ð°Ð»Ð° \n  float koffReflecr;    // ÐºÐ¾ÑÑ„Ñ„Ð¸Ñ†Ð¸ÐµÐ½Ñ‚ Ð¾Ñ‚Ñ€Ð°Ð¶ÐµÐ½Ð¸Ñ ÑÑ†ÐµÐ½Ñ‹\n  bool  speculat;       // Ð¾Ñ‚Ñ€Ð°Ð¶ÐµÐ½Ð¸Ðµ ÑÐ²ÐµÑ‚Ð°\n  bool  transparent;    // Ð¿Ñ€Ð¾Ð·Ñ€Ð°Ñ‡Ð½Ñ‹Ð¹ Ð¾Ð±ÑŠÐµÐºÑ‚\n  vec4  color;          // Ñ†Ð²ÐµÑ‚ Ð¼Ð°Ñ‚ÐµÑ€Ð¸Ð°Ð»Ð°\n     \n};\nmat materialMy = mat(0.0, 0.0, false, false, vec4(1.));\n\n//-----------------------------\nvec3 getNormal(in vec3 p);\nfloat renderFunction(in vec3 pos);\nfloat render(in vec3 posOnRay, in vec3 rayDir);\nvec4 getColorPixel(inout vec3 ro, vec3 rd, inout vec3 normal, float dist, float typeColor);\nvec4 transparency(in vec3 posOnRay, in vec3 rayDir,in vec3 normal,  inout vec4 color);\n//-----------------------------\n// Ð’Ñ€Ð°Ñ‰ÐµÐ½Ð¸Ðµ - Ð¿ÐµÑ€ÐµÑÑ‡ÐµÑ‚ Ð¼Ð°Ñ‚Ñ€Ð¸Ñ†Ñ‹\n//--------------------------------------------------\nvec3 rotationCoord(vec3 n, float paramRotate)\n{\n vec3 result;\n //--------------------------------------------\n   float t = time * 0.1;//tmpTime;//\n   vec2 sc = vec2(sin(t), cos(t));\n   mat3 rotate;\n   if(paramRotate <= 0.1)\n   {\n\n      rotate = mat3(  1.0,  0.0,  0.0,\n                      0.0,  1.0,  0.0,\n                      0.0,  0.0,  1.0);   \n   }\n   else if(paramRotate <= 1.0)\n   {\n      rotate = mat3(  1.0,  0.0,  0.0,\n                      0.0, sc.y,-sc.x,\n                      0.0, sc.x, sc.y);\n   }\n   else if(paramRotate <= 2.0)\n   {\n       rotate = mat3(  1.0,  0.0,  0.0,\n                       0.0, sc.y,sc.x,\n                       0.0, -sc.x, sc.y);  \n   }\n   else if (paramRotate <= 3.0)\n   {\n      rotate = mat3( sc.y,  0.0, -sc.x,\n                     0.0,   1.0,  0.0,\n                     sc.x,  0.0, sc.y);   \n   }\n   else if (paramRotate <= 4.0)\n   {\n      rotate = mat3( sc.y,  0.0, sc.x,\n                     0.0,   1.0,  0.0,\n                    -sc.x,  0.0, sc.y);   \n   }   \n   else if (paramRotate <= 5.0)\n   {\n       rotate = mat3( sc.y,sc.x,  0.0,\n                     -sc.x, sc.y, 0.0,\n                      0.0,  0.0,  1.0);  \n   }   \n   else if (paramRotate <= 6.0)\n   {\n       rotate = mat3( sc.y,-sc.x, 0.0,\n                      sc.x, sc.y, 0.0,\n                      0.0,  0.0,  1.0);  \n   }     \n   else\n   {\n   mat3 rotate_x = mat3(  1.0,  0.0,  0.0,\n                          0.0, sc.y,-sc.x,\n                          0.0, sc.x, sc.y);\n   mat3 rotate_y = mat3( sc.y,  0.0, -sc.x,\n                         0.0,   1.0,  0.0,\n                         sc.x,  0.0,  sc.y);\n   mat3 rotate_z = mat3( sc.y, sc.x,  0.0,\n                        -sc.x, sc.y,  0.0,\n                         0.0,  0.0,   1.0);\n   rotate = rotate_z * rotate_y * rotate_z;                \n   }\n  result = n * rotate;\n  return result;\n}\n//----------------------------------------------------\n//ÐŸÑ€Ð¸Ð¼Ð¸Ñ‚Ð¸Ð²Ñ‹\n//----------------------------------------------------\nfloat capsuleY(vec3 p, float r, float h)\n{\n    p.y -= clamp(p.y, 0.0, h);\n    return length(p) - r;\n}\n//--------------------------------------------------\nfloat capsuleZ(vec3 p, float r, float h)\n{\n    p.z -= clamp(p.z, 0.0, h);\n    return length(p) - r;\n}\n//----------------------------------------------------\nfloat pRoundBox(vec3 p, vec3 b, float r)\n{\n    return length(max(abs(p)-b,0.0))-r;\n}\n//----------------------------------------------------\nfloat zCylinder(vec3 p, vec2 h) \n{\n    return max( length(p.xz)-h.x, abs(p.y)-h.y );\n}\n\n//----------------------------------------------------\nfloat yCylinder(vec3 p, vec2 h) \n{\n    return max( length(p.xy)-h.x, abs(p.z)-h.y );\n}\n\n//----------------------------------------------------\nfloat pTorus(vec3 p, vec2 t)\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n//--------------------------------------------------\nfloat yCone( in vec3 p, in vec2 h, in float plane )\n{\n\n    p.y = - p.y;\n    vec2 c = normalize( h );\n    float q = length(p.xz);\n    float t = max( dot(c,vec2(q,p.y)), -(p.y +  h.x) );\n\n    t = max(t, -(-p.y - plane));\n    return t;\n}\n\n//---------------------------------------------\n// ÐŸÐ¾Ð»ÑƒÑ‡ÐµÐ½Ð¸Ðµ Ð¿Ñ€Ð¸Ð¼Ð¸Ñ‚Ð¸Ð²Ð° Ð¸ Ð¿Ð°Ñ€Ð°Ð¼ÐµÑ‚Ñ€Ð¾Ð² Ð¼Ð°Ñ‚ÐµÑ€Ð¸Ð°Ð»Ð°\nfloat distMat(inout float curDist, float dist, in float typeMat, in float typeRafl, bool typeSpecular, bool typeTransp )\n{\n   float res = curDist;\n   if (dist < curDist) \n   {\n      materialMy.typeMat     = typeMat;\n      materialMy.koffReflecr = typeRafl;\n      materialMy.speculat    = typeSpecular;\n      materialMy.transparent = typeTransp;\n      res                    = dist;\n     return res;\n   }\n   return curDist;\n}\n//--------------------------------------------------\n\nfloat twisting(in vec3 p)\n{\n    float n = segment * sin(time * 0.5 );\n  float colSegm = segment/3.;\n    if(n  < colSegm ) n = colSegm;\n   if(n > segment) n = segment;\n   float f; \n   if(typeTwisting == 0) f  = (n * 0.5)/n;\n   else f = 1. /n;\n   float r = 6.;\n    float a = atan(p.z, p.x);\n    float de = 1.0;\n    for(int i = 0; i < 24; i++)\n    {\n      vec3 q = p;\n       q.xz += normalize(p.xz) * r * sin(a * f);\n       q.y += r * cos(a * f);\n    if(typeFigures == 0)   \n       de = min(de, pTorus(q, vec2(2.0, .7)));\n    else if(typeFigures == 1)\n     de = min(de, yCylinder(q, vec2(1., 0.5)));\n    else if(typeFigures == 2)\n     de = min(de, capsuleY(q, 1.14, 0.7));  \n    else if(typeFigures == 3)\n     de = min(de,  pRoundBox(q,vec3(1.5, 0., 1.5), 0.8));         \n    else\n     de = min(de,  yCone( q,vec2(1.46, 1.34), 0. ) );   \n \n      a += PI2 /n / f;\n    }\n    return de;        \n}\n//--------------------------------------------------\nfloat myObject(in vec3 p)\n{\n\n   float d =  1.0;\n   materialMy.typeMat = 0.0;\n   materialMy.koffReflecr = 0.;\n   materialMy.speculat    = false; \n   materialMy.transparent = false;\n\n   vec3 pos = p;\n   pos += vec3(0., -0.68, 0.);\n  float of = texture( iChannel1, vec2( .01, .25 ) ).x;\n     pos *= sin(of)  ;\n   pos = rotationCoord(pos, paramRotate);   \n   d =  distMat(d,   twisting(pos) ,  1.0, 0.0, true, false);   \n//   d =  distMat(d,   dSphere(pos, 6.) ,  1.0, 0.0, true, false);   \n\nreturn d; \n}\n//-------------------------------------------------\n// Ð²Ñ‹Ð²Ð¾Ð´ Ð¾Ð±ÑŠÐµÐºÑ‚Ð°\nfloat renderFunction(in vec3 pos)\n{\n    return  myObject(pos);    \n}\n//------------------------------------------------- \nvec3 getNormal(in vec3 p)\n{\n\n   vec3 e = vec3( 0.1, 0., 0. );\n   vec3 nor = vec3(\n       renderFunction(p+e.xyy) - renderFunction(p-e.xyy),\n       renderFunction(p+e.yxy) - renderFunction(p-e.yxy),\n       renderFunction(p+e.yyx)- renderFunction(p-e.yyx));\n   return normalize(nor);  \n\n}\n//----------------------------------------------------------------------\nvec4 getColorPixel(inout vec3 ro, vec3 rd, inout vec3 normal, float dist, float typeColor)\n{\n\n  vec4 color = vec4(1.);\n  vec3 hitPos = ro + rd * dist;\n  vec3 lightPos1 = normalize(lightDir);  \n  normal = normalize(getNormal(hitPos));  \n  float diffuse = max(0.0, dot(normal, -lightPos1)) * 0.5 + 0.5;\n \n  float specular = 0.0;   \n  if(materialMy.speculat)\n  { \n      if (dot(normal, -lightPos1) < 0.0) \n         specular = 0.0;\n     else \n         specular = pow(max(0.0, dot(reflect(-lightPos1, normal), normalize(ro - hitPos))), 5.0);\n   }\n//----------------------------------\n   if (materialMy.typeMat == 0.0) \n  {\n     color =  texture(iChannel0, rd);\n     diffuse = 1.0;\n   } \n   else if (materialMy.typeMat == 1.0) \n   {\n \n   color = vec4(1.74, 0.87, 0., 1.);\n   vec3 col = vec3(1.);\n   vec3 newRd = reflect(rd, normal);\n   vec3 mirror = texture(iChannel0, newRd).rgb * 0.5;\n   col = mirror  + pow(0.48, 2.2);\n   color.rgb *= col * diffuse + specular; \n   } \n    ro = hitPos;\n  return color ;\n}\n\n//-------------------------------------------------\nfloat render(in vec3 posOnRay, in vec3 rayDir)\n{ \n  float t = 0.0;\nbool glowed = false;\n  for(int i=0; i< MAX_RAY_STEPS; ++i)\n  {\n    float d = renderFunction(posOnRay + t*rayDir); \n    if (d < 0.01 || d > 10.) \n         break;\n    t += d;\n  }\n   return t;\n}\n//------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 pos     =  fragCoord.xy / iResolution.xy * 2. - 1.;\n  pos.x *= iResolution.x / iResolution.y;                  \n    float t = time* 0.1;\n    vec3 camP = vec3(0., 4., 15.);\n    vec3 camUp = vec3(0. , 1., 0.);\n    vec3 camDir = normalize(-camP);\n    vec3 u = normalize(cross(camUp,camDir));\n    vec3 v = cross(camDir,u);\n    vec3 rayDir = normalize(camDir + pos.x * u + pos.y * v);  \n  vec4 color    = vec4(1.0);\n  vec3 normal   = vec3(1.0);\n\n//------------------------------\n   \n  vec3 posOnRay = camP; \n  float path = 0.;\n  //--------------------------- \n     path =  render(posOnRay, rayDir);  \n     color = getColorPixel(posOnRay, rayDir, normal, path, materialMy.typeMat); \n     fragColor =  color;\n\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"MlX3zX","date":"1423742036","viewed":130,"name":"twisting","username":"Lio","description":"inspired  https://www.shadertoy.com/view/MlfGzS","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["twisting"],"hasliked":0,"parentid":"","parentname":""}}