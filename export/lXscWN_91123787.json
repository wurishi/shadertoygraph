{"ver":"0.1","info":{"id":"lXscWN","date":"1726213705","viewed":116,"name":"thunder flash & grass ","username":"wangqiuyan","description":"thunder flash ","likes":10,"published":1,"flags":0,"usePreview":0,"tags":["thunderflash"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS 200\n#define MAX_DIST 1200.\n#define SURF_DIST .1\n\n\nmat2 rot(float r){\n    return mat2(cos(r), sin(r), -sin(r), cos(r));\n}\n\n\nfloat random(float x)\n{\n    return fract(sin(x*323.9877));\n}\n\nfloat random (in vec2 _st) {\n    return fract(\n                 sin( \n                      dot(\n                          _st.xy,vec2(12.9898,78.233)\n                         )\n                     )*\n        43758.5453123);\n}\n\nvec2 random2(vec2 _st)\n{\n   vec2 res = vec2(fract(\n                 sin( \n                      dot(\n                          _st.xy,vec2(12.9898,78.233)\n                         )\n                     )*\n        43758.5453123),\n        fract(\n                 sin( \n                      dot(\n                          _st.xy,vec2(45.9898,31.233)\n                         )\n                     )*\n        4358.5453123));\n   res-=.5;\n   return res;\n}\n\n\nfloat noise (in vec2 _st) {\n    vec2 i = floor(_st);\n    vec2 f = fract(_st);\n\n    // Four corners in 2D of a tile\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\n#define NUM_OCTAVES 5\n\nfloat fbm ( in vec2 _st) {\n    float v = 0.0;\n    float a = 0.5;\n    vec2 shift = vec2(100.0);\n    // Rotate to reduce axial bias\n    mat2 rot = mat2(cos(0.5), sin(0.5),\n                    -sin(0.5), cos(0.50));\n    for (int i = 0; i < NUM_OCTAVES; ++i) {\n        v += a * noise(_st);\n        _st = rot * _st * 2.0 + shift;\n        a *= 0.5;\n    }\n    return v;\n}\nconst mat2 m2 = mat2(  0.80,  0.60,\n           -0.60,  0.80 );\n           \nfloat fbm_6(vec2 x)\n{\n    float f = 2.0;\n    float s = 0.5;\n    float a = 0.0;\n    float b = 0.5;\n    for( int i=0; i<6; i++ )\n    {\n        float n = noise(x);\n        a += b*n;\n        b *= s;\n        x = f*m2*x;\n    }\n    \n\treturn a;\n}\nfloat skydist(vec3 p)\n{\n     float h=fbm_6(p.xz/120.-iTime*0.2)*80.+550.;\n    \n     return h-p.y; \n}\nfloat terraindist(vec3 p)\n{\n   float orih=120.*fbm_6(p.xz/100.)+200.;\n  \n \n   return (p.y-orih);\n  \n}\n\nfloat RayMarchSky(vec3 ro, vec3 rd) {\n\tfloat dO=0.;\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        \n        float ds=(skydist(p));\n       \n        \n        dO+=ds;\n       \n        if(dO>MAX_DIST||abs(ds)<SURF_DIST){break;}\n       \n    }\n    \n    return dO;\n}\nfloat RayMarchMountain(vec3 ro, vec3 rd) {\n\tfloat dO=0.;\n   \n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float ds=(terraindist(p));\n        dO+=ds;       \n        if(dO>MAX_DIST||abs(ds)<SURF_DIST){break;}\n       \n    }\n    \n    return dO;\n}\n\n\nvec3 skyrender(vec2 st,vec3 rd){\n     vec2 q = vec2(0.);\n    q.x = fbm( st + 0.00*iTime);\n    q.y = fbm( st + vec2(1.0));\n    vec2 r = vec2(0.);\n    r.x = fbm( st + 1.0*q + vec2(1.7,9.2)+ 0.5*iTime );\n    r.y = fbm( st + 1.0*q + vec2(8.3,2.8)+ 0.26*iTime);\n     float f = fbm(st+r);\n    \n     vec3 col= vec3(0.22,0.28,0.41) - rd.y*2.4*rd.y;\n      col = mix( col, vec3(1.0), 0.52*f );\n    \n      col+=smoothstep(0.075,0.0,abs(f-0.79))*.46*vec3(0.54,0.52,0.67);\n   \n    return col;\n    \n}\n\nfloat dseg( vec2 ba, vec2 pa )\n{\n\t\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba),0., 1.6 );\t\n\treturn length( pa - ba*h );\n}\nfloat arc2(vec2 x,vec2 r, vec2 dir,float stepnum)\n{\n   \n    float d=10.;\n    for (float i = 0.; i < stepnum; i++)\n    {\n        vec2 s= normalize(random2(r)+dir);\n      \n        d=min(d,dseg(s,x-r));\n        r += s;\n      \n    }\n    return d;\n    \n}\nfloat arc(vec2 x,vec2 r, vec2 dir,float stepnum)\n{\n   \n    float d=10.;\n    for (float i = 1.; i < stepnum; i++)\n    {\n        vec2 s= normalize(random2(r)+dir);\n      \n        d=min(d,dseg(s,x-r));\n        r += s;\n        \n        if(mod(i,6.)==0.)  d=min(d,arc2(x,r,vec2(0.25,-0.8),fract(iTime*1.4)*5.));\n      \n    }\n    return d*4.;\n    \n}\nfloat  perlight(vec2 uv,float scale,float stepnum)\n{\n    float t=random(iTime*0.01);\n    if(t>0.32)\n        return 0.;\n    vec2 or=vec2(0.03,-0.043);\n    or=or+.01*sin(or+.3*iTime);\n   \n   \n     uv.y-=0.5;\n     \n      float res=exp(-1.8*length(uv))*0.7;\n      if(t>0.06)\n      return res*0.25;\n     \n  \n     uv*=scale;\n     \n   \n   uv.x+=fbm_6(-uv*2.4)*0.4;\n   uv.y+=fbm(uv*2.2)*.6;\n    \n    \n    float d=100.;\n    \n    vec2 r=or*scale;\n    \n  \n    \n    for(float i=0.;i<=stepnum;i++)\n    {\n         \n       \n         vec2 ab=normalize(random2(r)-vec2(0,0.5+fract(iTime*0.0000006)))*0.8;\n         \n         d=min(d, dseg(ab,uv-r));\n         r+=ab;\n        \n        \n         \n        if(mod(i,6.)==floor(random(iTime*0.00001)*2.)+1.)  d=min(d,arc(uv,r,vec2(0.65,-0.5),fract(iTime*1.4)*random(i)*12.));\n        if(mod(i,8.)==floor(random(iTime*0.00002)*1.)+1.)  d=min(d,arc(uv,r,vec2(-0.67,-.5),fract(iTime*1.4)*random(i*3.)*12.));\n     \n        \n    }\n    return max(res,exp(-scale*0.15*d));\n   \n}\nfloat light(vec2 uv)\n{\n   \n    float s=0.;\n   \n   \n    s+=perlight(uv,32.,fract(iTime*1.4)*26.);\n  \n    \n    \n    return s;\n}\n//Grass function shamely copied from https://www.shadertoy.com/view/lslGR8\nvec4 grass(vec2 p, float x)\n{\n\tfloat s = mix(0.7, 2.0, 0.5 + sin(x * 12.0) * 0.5);\n\tp.x += pow(1.0 + p.y, 2.0) * 0.1 * cos(x * 0.5 + iTime);\n\tp.x *= s;\n\tp.y = (1.0 + p.y) * s - 1.0;\n\tfloat m = 1.0 - smoothstep(0.0, clamp(1.0 - p.y * 1.5, 0.01, 0.6) * 0.2 * s, pow(abs(p.x) * 19.0, 1.5) + p.y - 0.6);\n\treturn vec4(mix(vec3(0.05, 0.1, 0.0) * 0.8, vec3(0.0, 0.3, 0.0), (p.y + 1.0) * 0.5 + abs(p.x)), m * smoothstep(-1.0, -0.9, p.y));\n  \n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec2 ouv=uv;\n    vec3 col = vec3(0.);\n     col=vec3(81./255.,89./255.,98./255.);\n     col*=0.8;\n   \n   \n    float light=light(uv);\n     col+=light;\n   \n    \n    vec3 ro=vec3(0,500.,-100.),\n         lookat=vec3(0,400,1600),\n         f=normalize(lookat-ro);\n   \n    float zoom=1.;\n    \n    vec3 r=cross(vec3(0,1,0),f),\n         u=cross(f,r);\n   \n    vec3 c=ro+f*zoom,\n         i=c+uv.x*r+uv.y*u,\n         rd=normalize(i-ro);\n   \n   float d=RayMarchSky(ro,rd);\n   if(d<MAX_DIST){\n       vec3 p = ro + rd * d;\n       \n       vec3 skyf=skyrender(p.xz/100.,rd);\n     \n        col=mix(col,skyf,rd.y*3.);\n       \n      \n  }\n  else\n  {\n  d=RayMarchMountain(ro,rd);\n  if(d<MAX_DIST){\n        vec3 p = ro + rd * d;\n        col=vec3(40./255.,49./255.,58./255.);\n       \n        if(p.z>800.)\n        col=vec3(42./255.,53./255.,64./255.);\n       \n  }\n  else{\n   \n   \n   float dx=fbm(uv*vec2(6.6,2.56))*0.34*smoothstep(-0.7,0.2,uv.x);\n\n   float dy=fbm(uv*vec2(1.6,16.2*(2.-2.*uv.x)))*1.16*smoothstep(0.,0.26,uv.y+0.45)*smoothstep(-0.2,0.5,uv.x);\n  \n   dy=exp(9.*(dy-1.0));\n   col+=dy*vec3(0.65,0.64,0.52);\n   col+=dx*vec3(0.65,0.61,0.52);\n   col-=0.05;\n   \n  }\n  }\n\n  \n     c=ro+f*8.,\n     i=c+uv.x*r+uv.y*u,\n     rd=normalize(i-ro);\n     \n     int BLADES=200;\n    \n     vec3 grasscol=col;\n     for(int i = 0; i < BLADES; i += 1)\n\t {\n\t\tfloat z = -(float(BLADES - i) );\n        z*=10.*0.08;\n\t\t\n\t\tvec2 tc =ro.xy + rd.xy * (-z);\n        \n\t\t\n\t\ttc.x += cos(float(i) * 3.0) * 4.0;\n\t\t\n\t\tfloat cell = floor(tc.x);\n        \n\t\t\n\t\ttc.x = (tc.x - cell)-.5;\n        tc.y=tc.y-498.5+(-z)*0.09;\n        \n     \n\t\t\n\t\tvec4 c = grass(tc, float(i) + cell * 10.0);\n        \n\t\n        grasscol=mix(grasscol,c.rgb,c.w);\n        \n\t\t\n\t }\n  \n       col=mix(grasscol,col,smoothstep(0.0,0.2,uv.y+0.42));\n    \n       col = pow(col * 1.2, vec3(0.8));\n    \n   \n  \n    float fog=clamp(smoothstep(0.1,0.6,fbm_6(uv*2.+vec2(-iTime*0.2,iTime*0.1))),0.,0.4);\n    fog=fbm_6(uv*2.+vec2(-iTime*0.2,iTime*0.1));\n    fog=fbm(uv*2.+fog-vec2(iTime*0.1,-iTime*0.12))*0.5;\n    fog=smoothstep(0.0,0.9,fog);\n    fog*=1.-abs(uv.y);\n    col*=1.-fog;\n  \n    \n\n   \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}