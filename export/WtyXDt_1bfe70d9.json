{"ver":"0.1","info":{"id":"WtyXDt","date":"1583794130","viewed":382,"name":"[twitch] Lava Temple","username":"NuSan","description":"Shader coded live on twitch (https://www.twitch.tv/nusan_fx)\nThe shader was made using Bonzomatic.\nYou can find the original shader here: http://lezanu.fr/LiveCode/LavaTemple.glsl","likes":21,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","cartoon","cellshading"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\nShader coded live on twitch (https://www.twitch.tv/nusan_fx)\nThe shader was made using Bonzomatic.\nYou can find the original shader here: http://lezanu.fr/LiveCode/LavaTemple.glsl\n*/\n\nfloat time = 0.0;\nfloat pi=0.0;\n\nfloat box(vec3 p, vec3 s) {\n  p=abs(p)-s;\n  return max(p.x, max(p.y,p.z));\n}\n\n\nfloat torus(vec3 p, float r, float s) {\n  \n  return length(vec2(length(p.xz)-r,p.y))-s;\n}\n\nfloat cyl(vec3 p, float r, float s) {\n  \n  return max(length(p.xz)-r,abs(p.y)-s);\n}\n\nmat2 rot(float a) {\n  float ca=cos(a);\n  float sa=sin(a);\n  return mat2(ca,sa,-sa,ca);\n}\n\n#define rep(p,s) ((fract((p)/(s)-0.5)-0.5)*(s))\n\nfloat stair(vec3 p, float size, float w) {\n  \n  p.x=rep(p.x,size*2.0);\n  p.xy *= rot(pi*0.25);\n  \n  \n  float d=box(p, vec3(size,size,w));\n  \n  return d;\n}\n\n// repeat r times around y axis\nvec2 rota(vec2 p, float r) {\n  float a=atan(p.y,p.x)/(2.0*pi);\n  a=rep(a,1.0/r)*2.0*pi;\n  return vec2(cos(a),sin(a))*length(p);\n}\n\nfloat temple(vec3 p) {\n  \n  p.y=-abs(p.y-20.0)+20.0;\n    \n  p.xz = rota(p.xz, 10.0);\n  p.x -= 6.0;\n  \n  p.x = abs(p.x-15.0)-15.0;\n\n  p.xz = abs(p.xz);\n  if(p.x>p.z) p.xz=p.zx;\n  \n  p.y=-p.y;\n  \n  vec3 p2=p;\n  p2.y=abs(p2.y)-1.0;\n  float d=box(p2, vec3(1,0.1,2));\n  d=min(d, box(p-vec3(1.0,0,2), vec3(0.1,2.,0.1)));\n  d=min(d,box(p2-vec3(0,1,0), vec3(1.3,0.1,3)));\n  d=min(d,box(p2-vec3(0,1.2,0), vec3(0.8,0.1,2.5)));\n  \n  vec3 p3=p;\n  p3.zy *= rot(-pi*0.25);\n  float d2=stair(p3.zyx-vec3(0,0.7,0.5), 0.1, 0.3);\n  d2=min(d2,stair(p3.zyx-vec3(0,0.3,0.5), 0.3, 0.9));\n  d2=max(d2, p.y+0.9);\n  d=min(d, d2);\n  \n  return d;\n}\n\nfloat ground(vec3 p) {\n  \n  float d=10000.0;\n  p.y-=8.0;\n  for(float i=0.0; i<5.0; ++i) {\n    //p.xz = rota(p.xz, 20);\n    p.xz *= rot(0.3);\n    p.xz = abs(p.xz);\n    p.xz-=5.0;\n    p.y+=0.1;\n    float ouv = sin(p.z*0.8+ i)*0.5;\n    d=min(d, box(p, vec3(2.0+ouv,3,5)));\n    p.xy *= rot(0.03);\n  }\n  \n  return d;\n}\n\n// glow for white lasers\nfloat at=0.0;\n// glow for yellow lava\nfloat at2=0.0;\nfloat map(vec3 p) {\n  \n  float d=temple(p);\n  \n  d=min(d, ground(p));\n  \n  // Lava\n  float d3 = cyl(p-vec3(0,10,0), 30.0,2.0);\n  at2 += 0.5/(0.5+abs(d3));\n  d=min(d,d3);\n\n  // lasers\n  float d2 = abs(length(p.xz)-3.0);\n  \n  p.xz = rota(p.xz, 10.0);\n  p.x -= 36.0;\n  \n  d2 = min(d2, max(p.y,abs(length(p.xz)-0.2)));\n  \n  at += 0.01/(0.1+d2*d2);\n  //at += exp(-d2*2.0)*0.1;\n  \n  // we use max here so that the ray can never get close enough to the surface\n  // so the ray go through the laser and continue\n  d = min(d, max(d2,0.2));\n  \n  return d;\n}\n\nfloat getao(vec3 p, vec3 n, float dist) {\n  return clamp(map(p+n*dist)/dist,0.0,1.0);\n}\n\nvoid cam(inout vec3 p) {\n    float t=time*0.3;\n  p.yz *= rot(sin(t*1.3)*0.2+0.5);\n  p.xz *= rot(t);\n}\n\nfloat rnd(vec2 uv) {\n  return fract(dot(sin(uv*427.542+uv.yx*741.521),vec2(274.511)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\ttime = iTime;\n    pi=acos(-1.0);\n    \n  vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n  uv -= 0.5;\n  uv /= vec2(iResolution.y / iResolution.x, 1);\n\n  float dist = 50.0 + sin(time*0.2)*20.0 + sin(time*0.07)*10.0;\n  vec3 s=vec3(0,0,-dist);\n  cam(s);\n  \n  vec3 t=vec3(0,-10,0);\n  vec3 cz=normalize(t-s);\n  vec3 cx=normalize(cross(cz,vec3(sin(time*0.3)*0.1,1,0)));\n  vec3 cy=normalize(cross(cz,cx));\n  \n  float fov=1.0;\n  vec3 r=normalize(uv.x*cx+uv.y*cy+fov*cz);\n  \n  s.y+=10.0;\n  \n  float edgescreensize=0.0015;\n  float edgesize = 0.05;\n  \n  vec3 p=s;\n  float edge=0.0;\n  bool nearsurface=false;\n  float dd=0.0;\n  \n  float dither = mix(1.0,0.9,rnd(uv));\n\n  for(int i=0; i<100; ++i) {\n    float d=map(p)*dither;\n    // This can be used to adjust the edge size according to distance\n    //edgesize = edgescreensize*dd;\n    \n    // if close enough to the surface\n    if(d<edgesize) {\n      nearsurface=true;\n    }\n    // if we were close enough to the surface but we now are far again, we just missed a surface so this is an edge\n    if(nearsurface && d>edgesize) {\n      edge = 1.0;\n    }\n    if(d<0.001) {\n      break;\n    }\n    if(d>200.0) break;\n      \n    p+=r*d;\n    dd+=d;\n  }\n  \n  float fog = 1.0-clamp(dd/200.0,0.0,1.0);\n  \n  \n  vec3 col=vec3(0);\n  \n  vec2 off=vec2(0.01,0);\n  vec3 n=normalize(map(p)-vec3(map(p-off.xyy), map(p-off.yxy), map(p-off.yyx)));\n  \n  vec3 l=normalize(-vec3(1,3,2));\n  \n  col+=max(0.0,dot(n,l))*vec3(0.2,0.4,1.0)*2.0;\n  col *= fog;\n  \n  vec3 background = mix(vec3(0.6,0.3,0.8),vec3(0.6,0.6,0.0),smoothstep(0.1,0.8,r.y));\n  background = mix(background,vec3(0.0,0.6,0.9),smoothstep(0.1,-0.9,r.y));\n  \n  // background lines, infinitely far away using ray direction\n  vec3 r2 = r;\n  for(float i=0.0; i<5.0; ++i) {\n    float t=time*0.0+i+74.521;\n    r2.xz *= rot(t);\n    r2.xy *= rot(t*1.3);\n    r2 = abs(r2)-0.2;\n  }\n  vec3 grid = smoothstep(0.49,0.5,abs(fract(r2.xyz*5.0)-0.5));\n  background -= max(grid.x,max(grid.y,grid.z))*0.2;\n  \n  col += background*step(fog,0.01);\n  \n  // We use AO to put an edge on the crease of the surface\n  float ao = getao(p,n, edgesize);\n  if(ao<0.9) edge=max(edge,step(0.01,fog));\n  \n  // We use AO from inside the surface to put an edge on the outer edges of the surface\n  float ao2 = getao(p,n, -edgesize);\n  if(ao2<0.9) edge=max(edge,step(0.01,fog));\n  \n  // a little ao shadow below the temple\n  float ao3 = getao(p,n, 5.0)*0.5+0.5;\n  col *= ao3;\n  \n  col += at*0.4;\n  col += at2*vec3(1,0.5,0.2)*0.1;\n  \n  col *= 1.0-edge;\n  \n  fragColor = vec4(col, 1);\n}","name":"Image","description":"","type":"image"}]}