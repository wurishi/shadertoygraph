{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[{"channel":0,"type":"keyboard","id":"4dXGRr","filepath":"/presets/tex00.jpg","sampler":{"filter":"nearest","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"}}],"code":"#define NIBBLE_0 vec4(81, 87, 69, 82)\n#define NIBBLE_1 vec4(65, 83, 68, 70)\n#define NIBBLE_2 vec4(90, 88, 67, 86)\n#define NIBBLE_3 vec4(84, 89 ,85, 73)\n#define NIBBLE_4 vec4(71, 72, 74, 75)\nint s1;\nint s2;\nint s3;\nint s4;\nint s5;\nint s6;\nint s7;\nint s8;\nint s9;\n\nint get_square(int index)\n{\n\tif      (index <= 1) { return s1; }\n\telse if (index == 2) { return s2; }\n\telse if (index == 3) { return s3; }\n\telse if (index == 4) { return s4; }\n\telse if (index == 5) { return s5; }\n\telse if (index == 6) { return s6; }\n\telse if (index == 7) { return s7; }\n\telse if (index == 8) { return s8; }\n\telse                 { return s9; }\n}\n\nvoid set_square(int index, int value)\n{\n\tif      (index <= 1) { s1 = value; }\n\telse if (index == 2) { s2 = value; }\n\telse if (index == 3) { s3 = value; }\n\telse if (index == 4) { s4 = value; }\n\telse if (index == 5) { s5 = value; }\n\telse if (index == 6) { s6 = value; }\n\telse if (index == 7) { s7 = value; }\n\telse if (index == 8) { s8 = value; }\n\telse                 { s9 = value; }\n}\n\nbool validate_nibble_value(int value)\n{\n\treturn (value) >= 1 && (value) <= 9;\n}\n\nvec2 map_nibble_value(int value)\n{\n\tint v = value - 1;\n\tif (!validate_nibble_value(value)) { return vec2(-1.0, -1.0); }\n\tfloat y = floor((float(v) / 3.0)) / 3.0;\n\tfloat x = mod(float(v), 3.0) / 3.0;\n\n\treturn vec2(x, y) + vec2(0.16666);\n}\n\n\nbool check_sequence(vec2 uv, int iA, int iB, int iC)\n{\n\tint a = get_square(iA);\n\tint b = get_square(iB);\n\tint c = get_square(iC);\n\t\n\tbool result = a != 0 && a == b && b == c;\n\t\n\tif (result)\n\t{\n\t\t\n\t\tvec2 aP = map_nibble_value(iA);\n\t\tvec2 bP = map_nibble_value(iB);\n\t\tvec2 cP = map_nibble_value(iC);\n\t\t\n\t\tfloat aD = (abs(aP.x - uv.x) + abs(aP.y - uv.y));\n\t\tif (aD < 0.1 && aD > 0.09) { fragColor = vec4(0.0, 1.0, 0.0, 1.0); }\n\t\t\n\t\tfloat bD = (abs(bP.x - uv.x) + abs(bP.y - uv.y));\n\t\tif (bD < 0.1 && bD > 0.09) { fragColor = vec4(0.0, 1.0, 0.0, 1.0); }\n\t\t\n\t\tfloat cD = (abs(cP.x - uv.x) + abs(cP.y - uv.y));\n\t\tif (cD < 0.1 && cD > 0.09) { fragColor = vec4(0.0, 1.0, 0.0, 1.0); }\n\t}\n\t\n\treturn result;\n}\n\nbool check_subsequence(int a, int b, int c, int v)\n{\n\treturn a == v && a == b && c == 0;\n}\n\nbool check_game_won(vec2 uv)\n{\n\treturn\n\t\tcheck_sequence(uv, 1, 2, 3) ||\n\t\tcheck_sequence(uv, 4, 5, 6) ||\n\t\tcheck_sequence(uv, 7, 8, 9) ||\n\t\tcheck_sequence(uv, 1, 4, 7) ||\n\t\tcheck_sequence(uv, 2, 5, 8) ||\n\t\tcheck_sequence(uv, 3, 6, 9) ||\n\t\tcheck_sequence(uv, 1, 5, 9) ||\n\t\tcheck_sequence(uv, 3, 5, 7);\n}\n\nint check_key(float k)\n{\n\tfloat x = (k) / 255.0;\n\treturn int(texture(iChannel0, vec2(x, 1.0)).r > 0.0);\n}\n\nint check_nibble(vec4 nibble)\n{\n\treturn \n\t\tcheck_key(nibble.x) +\n\t\tcheck_key(nibble.y) * 2 + \n\t\tcheck_key(nibble.z) * 4 +\n\t\tcheck_key(nibble.w) * 8;\n}\n\n\nbool display_cross(vec2 uv, int x)\n{\n\tvec2 p = map_nibble_value(x);\n\t\n\tif (abs(uv.x - p.x) < 0.1 &&\n\t\tabs(uv.y - p.y) < 0.1 &&\n\t\t(\n\t\tabs(uv.y - (p.y - 0.01)) > abs(uv.x - p.x) &&\n\t    abs(uv.y - (p.y + 0.01)) < abs(uv.x - p.x) ||\n\t\tabs(uv.y - (p.y - 0.01)) < abs(uv.x - p.x) &&\n\t    abs(uv.y - (p.y + 0.01)) > abs(uv.x - p.x)) \n\t\t)\n\t{\n\t\t\n\t\tfragColor = vec4(1.0, 0.0, 0.0, 1.0);\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nbool display_nought(vec2 uv, int x)\n{\n\tvec2 p = map_nibble_value(x);\n\t\n\tif (distance(uv, p) < 0.1 && \n\t\tdistance(uv, p) > 0.08)\n\t{\n\t\tfragColor = vec4(0.0, 0.0, 1.0, 1.0);\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nbool display_binary(vec2 uv, int nibble, vec2 corner, vec2 extents)\n{\n\tif (uv.x > corner.x && uv.x < extents.x && uv.y > corner.y && uv.y < extents.y)\n\t{\n\t\tfragColor = vec4(0.3, 0.0, 0.0, 1.0);;\n\t\tint value = nibble;\n\t\t\n\t\tfor (int n = 0; n < 4; n++)\n\t\t{\n\t\t\tfloat width = float(n) / 4.0 * (extents.x - corner.x);\n\t\t\tfloat nextWidth = float(n+1) / 4.0 * (extents.x - corner.x);\n\t\t\t\n\t\t\tint bit = int(mod(float(value), 2.0));\n\t\t\tvalue /= 2;\n\t\t\t\n\t\t\tif (bit > 0 && uv.x - corner.x > width && uv.x - corner.x < nextWidth)\n\t\t\t{\n\t\t\t\tfragColor = vec4(1.0, 0.0, 0.0, 1.0);\n\t\t\t}\n\t\t}\t\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nint check_all_sub_sequences_horizontal(int check_for)\n{\n\tif      (check_subsequence(s1, s2, s3, check_for)) { return 3; }\n\telse if (check_subsequence(s2, s3, s1, check_for)) { return 1; }\n\telse if (check_subsequence(s1, s3, s2, check_for)) { return 2; }\n\t\n\telse if (check_subsequence(s4, s5, s6, check_for)) { return 6; }\n\telse if (check_subsequence(s5, s6, s4, check_for)) { return 4; }\n\telse if (check_subsequence(s4, s6, s5, check_for)) { return 5; }\n\t\n\telse if (check_subsequence(s7, s8, s9, check_for)) { return 9; }\n\telse if (check_subsequence(s8, s9, s7, check_for)) { return 7; }\n\telse if (check_subsequence(s9, s7, s8, check_for)) { return 8; }\n\telse { return -1; }\n}\n\nint check_all_sub_sequences_vertical(int check_for)\n{\n\tif      (check_subsequence(s1, s4, s7, check_for)) { return 7; }\n\telse if (check_subsequence(s4, s7, s1, check_for)) { return 1; }\n\telse if (check_subsequence(s1, s7, s4, check_for)) { return 4; }\n\t\n\telse if (check_subsequence(s2, s5, s8, check_for)) { return 8; }\n\telse if (check_subsequence(s5, s8, s2, check_for)) { return 2; }\n\telse if (check_subsequence(s2, s8, s5, check_for)) { return 5; }\n\t\n\telse if (check_subsequence(s3, s6, s9, check_for)) { return 9; }\n\telse if (check_subsequence(s6, s9, s3, check_for)) { return 3; }\n\telse if (check_subsequence(s3, s9, s6, check_for)) { return 6; }\n\telse { return -1; }\n}\n\nint check_all_sub_sequences_diagonal(int check_for)\n{\n\tif      (check_subsequence(s1, s5, s9, check_for)) { return 9; }\n\telse if (check_subsequence(s5, s9, s1, check_for)) { return 1; }\n\telse if (check_subsequence(s1, s9, s5, check_for)) { return 5; }\n\telse if (check_subsequence(s3, s5, s7, check_for)) { return 7; }\n\telse if (check_subsequence(s5, s7, s3, check_for)) { return 3; }\n\telse if (check_subsequence(s3, s7, s5, check_for)) { return 5; }\n\telse { return -1; }\n}\n\nint check_all_sub_sequences(int check_for)\n{\n\tint h = check_all_sub_sequences_horizontal(check_for);\n\tif (h > 0) { return h; }\n\tint v = check_all_sub_sequences_vertical(check_for);\n\tif (v > 0) { return v; }\n\tint d = check_all_sub_sequences_diagonal(check_for);\n\treturn d;\n}\n\nint check_expansion(int index)\n{\n\tif (index == 1)\n\t{\n\t\tif      (s5 == 0) { return 5; }\n\t\telse if (s2 == 0) { return 2; }\n\t\telse if (s4 == 0) { return 4; }\n\t}\n\telse if (index == 2)\n\t{\n\t\tif      (s5 == 0) { return 5; }\n\t\telse if (s1 == 0) { return 1; }\n\t\telse if (s3 == 0) { return 3; }\n\t\telse if (s4 == 0) { return 4; }\n\t\telse if (s6 == 0) { return 6; }\n\t}\n\telse if (index == 3)\n\t{\n\t\tif      (s5 == 0) { return 5; }\n\t\telse if (s2 == 0) { return 2; }\n\t\telse if (s6 == 0) { return 6; }\n\t}\n\telse if (index == 4)\n\t{\n\t\tif      (s5 == 0) { return 5; }\n\t\telse if (s1 == 0) { return 1; }\n\t\telse if (s2 == 0) { return 2; }\n\t\telse if (s7 == 0) { return 7; }\n\t\telse if (s8 == 0) { return 8; }\n\t}\n\telse if (index == 5)\n\t{\n\t\tif      (s1 == 0) { return 1; }\n\t\telse if (s2 == 0) { return 2; }\n\t\telse if (s3 == 0) { return 3; }\n\t\telse if (s4 == 0) { return 4; }\n\t\telse if (s6 == 0) { return 6; }\n\t\telse if (s7 == 0) { return 7; }\n\t\telse if (s8 == 0) { return 8; }\n\t\telse if (s9 == 0) { return 9; }\n\t}\n\telse if (index == 6)\n\t{\n\t\tif      (s5 == 0) { return 5; }\n\t\telse if (s3 == 0) { return 3; }\n\t\telse if (s2 == 0) { return 2; }\n\t\telse if (s8 == 0) { return 8; }\n\t\telse if (s9 == 0) { return 9; }\n\t}\n\telse if (index == 7)\n\t{\n\t\tif      (s5 == 0) { return 5; }\n\t\telse if (s4 == 0) { return 4; }\n\t\telse if (s8 == 0) { return 8; }\n\t}\n\telse if (index == 8)\n\t{\n\t\tif      (s5 == 0) { return 5; }\n\t\telse if (s7 == 0) { return 7; }\n\t\telse if (s9 == 0) { return 9; }\n\t\telse if (s4 == 0) { return 4; }\n\t\telse if (s6 == 0) { return 6; }\n\t}\n\telse if (index == 9)\n\t{\n\t\tif      (s5 == 0) { return 5; }\n\t\telse if (s8 == 0) { return 8; }\n\t\telse if (s6 == 0) { return 6; }\n\t}\n\treturn -1;\n}\n\nint check_all_expansions(int check_for)\n{\n\tint center = check_expansion(5);\n\tif (s5 == check_for && center > 0) { return center; }\n\t\n\tfor (int n = 1; n <= 4; n++)\n\t{\n\t\tint result = check_expansion(n);\n\t\tif (get_square(n) == check_for && result > 0) { return result; }\n\t}\n\t\n\tfor (int n = 6; n <= 9; n++)\n\t{\n\t\tint result = check_expansion(n);\n\t\tif (get_square(n) == check_for && result > 0) { return result; }\n\t}\n\t\n\treturn -1;\n}\n\n\nint computer_player()\n{\n\t\n\tint decision = 0;\n\t\n\t//Win if you can\n    decision = check_all_sub_sequences(2);\n\tif (decision > 0) { return decision; }\n\t\n\t//Block if your opponent is about to\n\tdecision = check_all_sub_sequences(1);\n\tif (decision > 0) { return decision; }\n\t\n\t//Expand from an already-held square\n\tdecision = check_all_expansions(2);\n\tif (decision > 0) { return decision; }\n\t\n\t//Seize the center if its free\n\tif (s5 == 0) { return 5; }\n\t\n\t//Pick the first empty square otherwise\n\tfor (int n = 1; n <= 9; n++)\n\t{\n\t\tif (get_square(n) == 0)\n\t\t{\n\t\t\treturn n;\n\t\t}\n\t}\n\t\n\t//Something went wrong\n\treturn -1;\n}\n\nvoid gameplay(vec2 uv, int nibble0, int nibble1, int nibble2, int nibble3, int nibble4)\n{\n\tfor (int n = 1; n <= 9; n++)\n\t{\n\t\tset_square(n, 0);\n\t}\n\t\n\tif (!(validate_nibble_value(nibble0) && get_square(nibble0) == 0)) { return; }\n\tset_square(nibble0, 1);\n\tdisplay_cross(uv, nibble0);\n\t\n\tint ai_move_1 = computer_player();\n\tset_square(ai_move_1, 2);\n\tdisplay_nought(uv, ai_move_1);\n\t\n\tif (!(validate_nibble_value(nibble1) && get_square(nibble1) == 0)) { return; }\n\tset_square(nibble1, 1);\n\tdisplay_cross(uv, nibble1);\n\t\n\tint ai_move_2 = computer_player();\n\tset_square(ai_move_2, 2);\n\tdisplay_nought(uv, ai_move_2);\n\t\n\tif (!(validate_nibble_value(nibble2) && get_square(nibble2) == 0)) { return; }\n\tset_square(nibble2, 1);\n\tdisplay_cross(uv, nibble2);\n\t\n\tif (check_game_won(uv)) { return; }\n\t\n\tint ai_move_3 = computer_player();\n\tset_square(ai_move_3, 2);\n\tdisplay_nought(uv, ai_move_3);\n\t\n\tif (check_game_won(uv)) { return; }\n\t\n\tif (!(validate_nibble_value(nibble3) && get_square(nibble3) == 0)) { return; }\n\tset_square(nibble3, 1);\n\tdisplay_cross(uv, nibble3);\n\t\n\tif (check_game_won(uv)) { return; }\n\t\n\tint ai_move_4 = computer_player();\n\tset_square(ai_move_4, 2);\n\tdisplay_nought(uv, ai_move_4);\n\t\n\tif (check_game_won(uv)) { return; }\n\t\n\tif (!(validate_nibble_value(nibble4) && get_square(nibble4) == 0)) { return; }\n\tset_square(nibble4, 1);\n\tdisplay_cross(uv, nibble4);\n\t\n\tif (check_game_won(uv)) { return; }\n\n\t\n\treturn;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tvec2 mp = iMouse.xy / iResolution.xy;\n\tuv.x *= iResolution.x / iResolution.y;\n\tmp.x *= iResolution.x / iResolution.y;\n\tint nibble0 = check_nibble(NIBBLE_0);\n\tint nibble1 = check_nibble(NIBBLE_1);\n\tint nibble2 = check_nibble(NIBBLE_2);\n\tint nibble3 = check_nibble(NIBBLE_3);\n\tint nibble4 = check_nibble(NIBBLE_4);\n\n\t\n\tif (uv.x > 1.0)\n\t{\n\t\tfragColor = vec4(0.0);\n\t\t\n\t\tif (mp.x < 1.0)\n\t\t{\n\t\t\tint yVal = int(mp.y * 3.0);\n\t\t\tint xVal = int(mp.x * 3.0);\n\t\t\tint mVal = yVal * 3 + xVal + 1;\n\t\t\t\n\t\t\tif (validate_nibble_value(mVal))\n\t\t\t{\n\t\t\t\tdisplay_binary(uv, mVal, vec2(1.0, 0.975), vec2(1.1, 1.0));\n\t\t\t}\n\t\t}\n\t\t\n\t\tdisplay_binary(uv, nibble0, vec2(1.0, 0.025 * 4.0), vec2(1.1, 0.025 * 5.0));\n\t\tdisplay_binary(uv, nibble1, vec2(1.0, 0.025 * 3.0), vec2(1.1, 0.025 * 4.0));\n\t\tdisplay_binary(uv, nibble2, vec2(1.0, 0.025 * 2.0), vec2(1.1, 0.025 * 3.0));\n\t\tdisplay_binary(uv, nibble3, vec2(1.0, 0.025 * 1.0), vec2(1.1, 0.025 * 2.0));\n\t\tdisplay_binary(uv, nibble4, vec2(1.0, 0.025 * 0.0), vec2(1.1, 0.025 * 1.0));\n\t\treturn;\n\t}\n\t\n\tfragColor = vec4(0.5 + 0.5*float(\n\t\tabs(uv.x - 0.3333) < 0.01 || abs(uv.x - 0.6666) < 0.01 ||\n\t\tabs(uv.y - 0.3333) < 0.01 || abs(uv.y - 0.6666) < 0.01));\n\tgameplay(uv, nibble0, nibble1, nibble2, nibble3, nibble4);\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":true,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"Xd2GRy","date":"1390169685","viewed":347,"name":"Playable Tic-Tac-Toe","username":"Protarget","description":"Please see comments below for instructions on how to play!","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["game","fakestate"],"hasliked":0,"parentid":"","parentname":""}}