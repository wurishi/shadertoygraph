{"ver":"0.1","info":{"id":"WsKyDy","date":"1603664930","viewed":90,"name":"Noise functions","username":"henrmota","description":"Just a collection of noise functions to practice and understand. Fractal brownian motion is just awesome.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["noise"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14159265359\n#define TWO_PI 2.*PI\n#define FBM_OCTAVES 4\n#define DX 1./iResolution.x\n#define DY 1./iResolution.y\n\n//1d pseudo-random for shaders\nfloat random(vec2 p) {\n    p = mod(p, 10000.);\n    \n \treturn fract(sin(dot(p, vec2(12.9898,78.233))) * 43758.5453); \n}\n\n//2d pseudo-random\nvec2 random2(vec2 p) {\n    p = mod(p, 10000.);\n    \n \treturn fract(\n        sin( \n            vec2( \n                dot(p,vec2(127.1,311.7)), \n                dot(p,vec2(269.5,183.3)) \n            ) \n        ) \n    \t* 43758.5453\n    ); \n}\n\nfloat noise(vec2 p) {\n\tvec2 i = floor(p);\n    vec2 f = fract(p);\n    \n    float bottom_left = random(i);\n    float bottom_right = random(i + vec2(1.0, 0.0));\n    float top_left = random(i + vec2(0.0, 1.0));\n    float top_right = random(i + vec2(1.0, 1.0));\n    \n    // Quintic interpolation\n    f = f*f*f*(f*(f*6.-15.)+10.);\n    \n    // Cubic interpolationn\n    //f = f*f*(3.0 - 2.0*f);\n    \n    float bottom = mix(bottom_left, bottom_right, f.x); \n    float top = mix(top_left, top_right, f.x); \n    \n    return mix(bottom, top, f.y);\n}\n\nfloat perlinNoise(vec2 p) {\n \tvec2 i = floor(p);\n    vec2 f = fract(p);\n    \n    vec2 a = i;\n    vec2 b = i + vec2(1., 0.);\n    vec2 c = i + vec2(0., 1.);\n    vec2 d = i + vec2(1., 1.);\n    \n    //random angles\n    float bl_angle = random(a) * TWO_PI;\n    float br_angle = random(b) * TWO_PI;\n    float tl_angle = random(c) * TWO_PI;\n    float tr_angle = random(d) * TWO_PI;\n    \n    // corner vectors \n    vec2 bl_vec = vec2(-sin(bl_angle), cos(bl_angle));\n    vec2 br_vec = vec2(-sin(br_angle), cos(br_angle));\n    vec2 tl_vec = vec2(-sin(tl_angle), cos(tl_angle));\n    vec2 tr_vec = vec2(-sin(tr_angle), cos(tr_angle));\n   \n    float bl = dot(bl_vec, p - a);\n    float br = dot(br_vec, p - b);\n    float tl = dot(tl_vec, p - c);\n    float tr = dot(tr_vec, p - d);\n    \n    \n     // Quintic interpolation\n    f = f*f*f*(f*(f*6.-15.)+10.);\n    \n    // Cubic interpolationn\n    //f = f*f*(3.0 - 2.0*f);\n    \n    float bottom = mix(bl, br, f.x); \n    float top = mix(tl, tr, f.x); \n    \n    return clamp(mix(bottom, top, f.y) + 0.5, 0., 1.);  \n}\n\nfloat celularNoise(vec2 p) {\n\tvec2 i = floor(p);\n    vec2 f = fract(p);\n    \n    float minDist = 100.;\n    \n    for(float x=-1.; x < 2.; x++) {\n        for(float y=-1.; y < 2.; y++) {\n            vec2 coord = vec2(x, y);\n         \tvec2 point = random2(i + coord) + coord;\n            \n            float dist = distance(f, point);\n            \n            minDist = min(minDist, dist); \n        }\n    }\n    \n    return minDist;\n}\n\nfloat fbm(vec2 p, float shift) {\n   float amplitude = 1.0;\n   float freq = 4.;\n   float normalizeFactor = 0.0;\n   float value = 0.0;\n   \n    \n   for(int i = 0; i <= FBM_OCTAVES; i++) {\n      float angle = float(i) * PI;\n      //avoid axis bias\n      mat2 rotate = mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n      \n      value += perlinNoise(rotate * p * freq + shift) * amplitude;\n      normalizeFactor += amplitude;\n      amplitude *= 0.5;\n      freq *= 2.1;\n   }\n    \n   return value/normalizeFactor;\n}\n\nvec2 fbmGradient(vec2 p, float shift) {\n \tfloat value = fbm(p, shift);\n    \n    float valueX = (fbm(vec2(p.x + DX, p.y), shift) - value)/DX;\n    float valueY = (fbm(vec2(p.x, p.y + DY), shift) - value)/DY;\n    \n    vec2 result = vec2(valueX, valueY);\n    \n    return normalize(result);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 gv = uv * 10.;\n   \n    float t = abs(cos(iTime));\n    float distortion = fbm(uv + t,  0.);\n    float distortionGradient =  dot(\n        vec2(distortion), \n        fbmGradient(uv + t, 0.)\n    );\n    \n    vec3 col = vec3(0.0);\n    col.gb +=fbm(uv + distortionGradient * 0.01, t);\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}