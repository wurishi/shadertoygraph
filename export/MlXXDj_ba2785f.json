{"ver":"0.1","info":{"id":"MlXXDj","date":"1439705732","viewed":253,"name":"Learning Raymarching 2","username":"dmarcos","description":"In this shader I explain a simple shading technique. You can move the light with your mouse","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[],"code":"// Author: Diego Marcos\n// Learning Computer Graphics Techniques\n// \n// 2. Shading and raymarching\n// --------------------------\n//\n// This is a continuation of https://www.shadertoy.com/view/MtlSWS\n//\n// In the previous shader I described the basics of raymarching. Now I will apply\n// an illumination model to the sphere instead of just a plain color. \n//\n// I will be using a Phong shading model that it's pretty standard nowadays. \n// As many of the computer graphics breakthroughs it was invented in the 70s at the \n// University of Utah. It's an empirical model that doesn't accurately simulate\n// how light behaves at a physical level. The basic idea is that the light reflected\n// by an object can be approximated by the addition of \n// three components: Ambient, Diffuse, Specular.\n//\n// Ambient: There's always residual light combination of all reflections in the scene. \n// This light affects all surfaces uniformingly and is independent from number and \n// the direction of the light sources. \n//\n// Diffuse: Surfaces scatter part of the incoming light in all directions simultaneously. \n// Ideal diffuse surfaces reflect every incoming ray in all directions with equal probability.\n// In the real world different materials reflect some wavelengths and absorb the rest. That's\n// what gives the color to an object. The amount of light reflected depends on the \n// number of rays(or energy, or radiation) per unit area that hit the object surface.\n// A surface perpendicular to the ray direction receives that maximum amount of light.\n// As we tilt the object with respect to the light source the exposed surface decreases.\n// This is why the parts of an object that face the light source are brighter than\n// those pointing away. \n// The amount of incoming light is directly proportional to the cosine of the angle between \n// the direction of the light source and the surface normal. This is called the Lambert cosine law.\n//\n// Specular: Part of the light reflected by an object leaves the surface at an angle equal to \n// the ray incidence angle. These are the mirror-like reflections. Polished objects approximate\n// a pure specular surface where an incoming ray is reflected into a single outgoing angle. \n// The direction of a reflected ray is determined by the vector of incidence and the \n// surface normal vector\n//\n// All materials are somewhere between a pure diffuse and a pure specular surface. \n\n\nfloat sphereMap( vec3 p, float radius )\n{\n  return length(p)- radius;\n}\n\n// We need to calculate the normal for each point on the sphere\n// Thanks to the distance function we know the value of the sphere surface \n// at any point. We can approximate the normal via the gradient numerical\n// calculation using the central differences method\n// We don't need to divide the calculated vector by the epsilon length\n// because we are going to normalize it.\nvec3 calcNormal( in vec3 pos, float radius )\n{\n    vec3 eps = vec3(0.002,0.0,0.0);\n\treturn normalize( vec3(\n           sphereMap(pos+eps.xyy, radius) - sphereMap(pos-eps.xyy, radius),\n           sphereMap(pos+eps.yxy, radius) - sphereMap(pos-eps.yxy, radius),\n           sphereMap(pos+eps.yyx, radius) - sphereMap(pos-eps.yyx, radius ) ));\n}\n\n// This function calculates the color of a pixel given \n// the normal of the surface, the light and the camera positions.\nvec3 shade(in vec3 normal, in vec3 light, in vec3 camera) {\n    // These are properties of the surface material\n    vec3 ambientColor = vec3(0.0, 0.0, 0.0);\n   \tvec3 diffuseColor = vec3(0.118, 0.11, 0.875);\n    vec3 specularColor = vec3(1.0, 1.0, 1.0);\n  \tfloat specular = 0.0;\n    const float shininess = 30.0;\n    float lambertian = max(dot(normal, light), 0.0);\n    // If the surface is not receiving any light\n    // we can skip the specular component calculation\n    if(lambertian > 0.0) {\n        // Phong\n        vec3 reflection = normalize(2.0*(dot(normal, light)) * normal - light);\n        float k = dot(reflection, camera); \n    \tspecular = pow(k, shininess);\n        \n        // Blinn-Phong approximation\n        // This is an approximation to pure Phong shading that it's faster to calculate\n        // vec3 halfVec = normalize(light + camera);\n   \t\t// mediump float halfVecDot = dot(halfVec,normal);\n   \t\t// if(halfVecDot > 0.0) {\n    \t// \tspecular = max(0.0,pow(halfVecDot, shininess));\n   \t\t//}\n    }\n    return ambientColor + lambertian * diffuseColor + specular * specularColor;\n}\n \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    // Fragment coordinate in NDC (Normalized Device Coordinates)\n\t// Coordinates of the fragment in the range of [-1,1]\n    vec2 q = ( 2.0 * fragCoord.xy - iResolution.xy ) / iResolution.y;\n        \n    // ray origin\n    // the camera position\n    vec3 ro = vec3( 0.0, 0.0, 1.0 );\n    \n    // light position\n    vec3 lightPos = vec3(0.0, 0.0, 1.0);\n    \n    // ray direction pointing deep in the scene (z < 0)\n    // We want a unit vector to keep things tidy\n    vec3 rd = normalize( vec3(q , -1.0) );\n    \n    // Default / background color\n    vec3 col = vec3( 0.0, 0.0, 0.0 );\n        \n   \t// sphere radius\n    float radius = 0.5;\n\n    // Raymarcher\n    //\n    // We stop raymarching if we are very far from the object.\n    // This behaves a like your far clipping plane of a camera frustum\n    float tmax = 125.0;\n    // Acumulated distance to the object\n    float t = 0.0;\n    // We advance a maximum i steps in the direction of the ray\n    for( int i=0; i<200; i++ )\n    {\n        // That's the current position over the ray\n        // we move over the ray the previous distance\n        // calculated to the object\n        vec3 pos = ro + rd*t;\n        // We evaluate how far we're from the objects\n        // In this case we just have sphere of radius 0.5\n        // centered in the origin\n        float h = sphereMap( pos, radius );\n        // If h is very very small or negative we stop because we're either very close or inside the object\n        // If t > tmax we stop as well because we're very far from it.\n        if( h < 0.001 || t > tmax ) break;\n        // It accumulates the distances to the object calculated in each step\n        // We want this so for rays passing close to an object but not hitting it. \n        // These cases might not trigger the t > max condition above and we could end up painting those pixels\n        t += h;\n    }\n    \n    // If t is less than the max distance we stablished we color the pixel\n    if( t < tmax )\n    {\n        // current position\n        vec3 pos = ro + rd*t;\n        // Surface normal approximation \n       \tvec3 normal = calcNormal( pos, radius );\n        // The light position changes based on the mouse location\n  \t\tvec2 mouseLight = ( 2.0 * iMouse.xy - iResolution.xy ) / iResolution.y;\n        // Let's color the pixel based on surface normal, light and camera positions\n       \tcol = shade(normal, normalize(vec3(mouseLight, 1.0)), ro);\n    }\n    \n    // We assign the final color to the pixel\n\tfragColor = vec4( col, 1.0 );\n}","name":"","description":"","type":"image"}]}