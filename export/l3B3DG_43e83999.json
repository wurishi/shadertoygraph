{"ver":"0.1","info":{"id":"l3B3DG","date":"1708800038","viewed":90,"name":"Change shape scale","username":"nakira974","description":"Basic scale changing operation","likes":0,"published":3,"flags":0,"usePreview":0,"tags":["exemple"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/**\n* @brief Calculate the scaling factor based on time never inferior de 1/10\n* @param time The elapsed time\n* @param initialScale The initial scale factor\n* @param speed The speed of scaling variation\n* @return The calculated scale factor\n*/\nfloat calculateScale(float time, float initialScale, float speed)\n{\n    float minScale = max(initialScale / 10.0, initialScale - (1.0 - initialScale));\n    float scale = initialScale + sin(time * speed/2.0) * 0.5;\n\n    return max(scale, minScale);\n}\n\n/**\n* @brief Generate a random color using the time salt\n* @param time Elapsed time since the shader is running\n* @return The generated color\n*/\nvec3 generateColor(float time)\n{\n    // Use the sin function to create color variation over time\n    float red = sin(time * 0.5) * 0.5 + 0.5;\n    float green = sin(time * 0.7) * 0.5 + 0.5;\n    float blue = sin(time * 0.9) * 0.5 + 0.5;\n    \n    return vec3(red, green, blue);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Définir le centre du triangle\n    vec2 center = vec2(0.5, 0.5);\n    \n    // Définir l'échelle de déformation initiale\n    float initialScale = 1.5;\n    \n    // Définir la vitesse d'agrandissement et de rétrécissement\n    float speed = 0.8;\n    \n      // Calculer l'échelle en fonction du temps\n    float scale = calculateScale(iTime, 0.5, 0.5);\n    \n    // Calculer le décalage par rapport au centre\n    vec2 offset = fragCoord - center * iResolution.xy;\n    \n    // Appliquer l'échelle de déformation\n    offset *= scale;\n    \n    vec2 offsetScaled = offset * scale;\n    \n    // Recentrer le triangle\n    vec2 uv = (2.5 * fragCoord - iResolution.xy) / min(iResolution.y, iResolution.x) + offsetScaled;\n    \n    // Dessiner le triangle (par exemple, en utilisant les coordonnées barycentriques)\n    float triangle = uv.x > 0.0 && uv.y > 0.0 && uv.x + uv.y < 1.0 ? 1.0 : 0.0;\n    \n    // Générer la couleur en fonction du temps\n    vec3 color = generateColor(iTime);\n    \n    vec3 bgColor = vec3(1.0); // Définir la couleur du fond en blanc\n    fragColor = vec4(mix(bgColor, color, triangle), 1.0); // Mélange le blanc avec la couleur du triangle\n}","name":"Image","description":"","type":"image"}]}