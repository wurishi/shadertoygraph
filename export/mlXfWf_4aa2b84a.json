{"ver":"0.1","info":{"id":"mlXfWf","date":"1693533687","viewed":54,"name":"Dual Arrow","username":"sgundam","description":"This code defines functions for rendering a rotating, zooming and wobbling dual-arrow shape. The properties such as size, rotation and distortion are controlled by time-dependent factors resulting in an animated visual effect.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["vectorarrowdualpointed"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Define constants for arrow properties and scaling factor\n#define ARROW_STEM_THICKNESS 0.01\n#define ARROW_STEM_ANTIALIAS 6.0\n#define ARROW_HEAD_WIDTH 0.08\n#define ARROW_HEAD_HEIGHT 0.16\n#define ARROW_HEAD_ANTIALIAS 64.0\n#define SCALE 2.0\n\n// Function to compute the scalar value of the vector projection of vec_a onto vec_b\nfloat vector_projection_scalar(vec2 vec_a, vec2 vec_b) {\n    return dot(vec_a, vec_b) / dot(vec_b, vec_b);\n}\n\n// Function to calculate the signed distance field (SDF) of a point to a line segment defined by vec_a and vec_b\nfloat df_line_segment(vec2 vec_p, vec2 vec_a, vec2 vec_b) {\n    vec2 dvec_ap = vec_p - vec_a;\n    vec2 dvec_ab = vec_b - vec_a;\n    vec2 vproj_ap_ab = dvec_ab * clamp(vector_projection_scalar(dvec_ap, dvec_ab), 0.0, 1.0);\n    return distance(dvec_ap, vproj_ap_ab) - ARROW_STEM_THICKNESS;\n}\n\n// Function to calculate the signed distance field (SDF) of a point to a triangle defined by vec_a, vec_b, and vec_c\nfloat sdf_triangle(vec2 vec_p, vec2 vec_a, vec2 vec_b, vec2 vec_c) {\n    vec2 dvec_ab = vec_b - vec_a;\n    vec2 dvec_ac = vec_c - vec_a;\n    vec2 dvec_ap = vec_p - vec_a;\n\n    float det_dvec_ab_dvec_ac = dvec_ab.x * dvec_ac.y - dvec_ac.x * dvec_ab.y;\n    float det_dvec_ap_dvec_ac = dvec_ap.x * dvec_ac.y - dvec_ac.x * dvec_ap.y;\n    float det_dvec_ab_dvec_ap = dvec_ab.x * dvec_ap.y - dvec_ap.x * dvec_ab.y;\n    float inv_det_dvec_ab_dvec_ac = 1.0 / det_dvec_ab_dvec_ac;\n\n    float bary_x = det_dvec_ap_dvec_ac * inv_det_dvec_ab_dvec_ac;\n    float bary_y = det_dvec_ab_dvec_ap * inv_det_dvec_ab_dvec_ac;\n    float bary_z = 1.0 - bary_x - bary_y;\n\n    return min(min(bary_x, bary_y), bary_z);\n}\n\n// Function to draw an arrow at the specified position (uv)\nfloat draw_arrow(vec2 uv) {\n    vec2 base = vec2(0.0); // Position vector at the origin\n    float dir = iTime; // Rotate the arrow based on time\n    float norm = 1.0; // Length of the arrow\n\n    uv = mat2(cos(dir), -sin(dir), sin(dir), cos(dir)) * uv;\n\n    float stem_len = norm - 2.0 * ARROW_HEAD_HEIGHT;\n    // Subtract arrowhead heights from the line segment\n    float stem = df_line_segment(uv, base - vec2(stem_len / 2.0 - ARROW_HEAD_HEIGHT, 0.0), base + vec2(stem_len / 2.0 - ARROW_HEAD_HEIGHT, 0.0));\n\n    // Calculate head positions for both ends of the arrow, pointing towards the stem\n    vec2 head_a1, head_b1, head_c1;\n    vec2 head_a2, head_b2, head_c2;\n\n    head_a1 = base + vec2(stem_len / 2.0, 0.0);\n    head_b1 = base + vec2(stem_len / 2.0 - ARROW_HEAD_HEIGHT, ARROW_HEAD_WIDTH);\n    head_c1 = base + vec2(stem_len / 2.0 - ARROW_HEAD_HEIGHT, -ARROW_HEAD_WIDTH);\n    \n    head_a2 = base - vec2(stem_len / 2.0, 0.0);\n    head_b2 = base - vec2(stem_len / 2.0 - ARROW_HEAD_HEIGHT, ARROW_HEAD_WIDTH);\n    head_c2 = base - vec2(stem_len / 2.0 - ARROW_HEAD_HEIGHT, -ARROW_HEAD_WIDTH);\n\n    float head1 = sdf_triangle(uv, head_a1, head_b1, head_c1);\n    float head2 = sdf_triangle(uv, head_a2, head_b2, head_c2);\n\n    stem = smoothstep(ARROW_STEM_ANTIALIAS / iResolution.y, 0.0, stem);\n    head1 = smoothstep(0.0, ARROW_HEAD_ANTIALIAS / iResolution.y, head1);\n    head2 = smoothstep(0.0, ARROW_HEAD_ANTIALIAS / iResolution.y, head2);\n\n    return max(max(stem, head1), head2);\n}\n\n// Main function to render the image\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = SCALE * (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n\n    // Apply zooming effect based on time\n    float zoomFactor = 1.0 + 0.2 * sin(0.5 * iTime);\n    uv *= zoomFactor;\n\n    // Apply a wobbling effect based on time\n    float wobbleFactor = 0.1 * sin(iTime * 0.5);\n    uv += wobbleFactor * sin(uv * 4.0);\n    \n    // Calculate the signed distance field (SDF) for the arrow and set the color\n    float arrow_df = draw_arrow(uv);\n    fragColor.rgb = vec3(arrow_df);\n}\n","name":"Image","description":"","type":"image"}]}