{"ver":"0.1","info":{"id":"ssccRB","date":"1653619766","viewed":122,"name":"PICO-8 Palettized Image","username":"jamp","description":"A shader that takes an input image and re-colors it in the PICO-8 color palette. (See: https://lospec.com/palette-list/pico-8 )\n","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["pixelart","pico8","quantized","palettized"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":0,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":1,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGRr","filepath":"/media/a/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm","previewfilepath":"/media/ap/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm","type":"video","channel":2,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// The short dimension of the screen will be this many pixels across\nconst float targetResolutionBase = 128.0;\nconst float noiseInfluence = 0.03;\n\nconst vec3 colors[16] = vec3[16](\n    vec3(0, 0, 0),\n    vec3(0.11372549019607843, 0.16862745098039217, 0.3254901960784314),\n    vec3(0.49411764705882355, 0.1450980392156863, 0.3254901960784314),\n    vec3(0, 0.5294117647058824, 0.3176470588235294),\n    vec3(0.6705882352941176, 0.3215686274509804, 0.21176470588235294),\n    vec3(0.37254901960784315, 0.3411764705882353, 0.30980392156862746),\n    vec3(0.7607843137254902, 0.7647058823529411, 0.7803921568627451),\n    vec3(1, 0.9450980392156862, 0.9098039215686274),\n    vec3(1, 0, 0.30196078431372547),\n    vec3(1, 0.6392156862745098, 0),\n    vec3(1, 0.9254901960784314, 0.15294117647058825),\n    vec3(0, 0.8941176470588236, 0.21176470588235294),\n    vec3(0.1607843137254902, 0.6784313725490196, 1),\n    vec3(0.5137254901960784, 0.4627450980392157, 0.611764705882353),\n    vec3(1, 0.4666666666666667, 0.6588235294117647),\n    vec3(1, 0.8, 0.6666666666666666)\n);\n\n// Can weight individual colors here, if you want any of them to appear less\nconst float colorWeights[16] = float[16](\n    1.0,\n    1.0,\n    1.0,\n    1.0,\n    1.0,\n    1.0,\n    1.0,\n    1.0,\n    1.0,\n    1.0,\n    1.0,\n    1.0,\n    1.0,\n    0.75,\n    1.0,\n    1.0\n);\n\n// rgb2hsv and hsv2rgb functions are from: https://stackoverflow.com/a/17897228\n\n// All components are in the range [0…1], including hue.\nvec3 rgb2hsv(vec3 c)\n{\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\n// All components are in the range [0…1], including hue.\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvec3 closestColor(vec3 color) {\n    vec3 targetHSV = rgb2hsv(color);\n\n    vec3 closest = colors[0];\n    float minDist = 999.0;\n    for (int i = 0; i < 16; i++) {\n        vec3 col = colors[i];\n        vec3 colHSV = rgb2hsv(col);\n        \n        float dr = abs(color.r - col.r);\n        float dg = abs(color.g - col.g);\n        float db = abs(color.b - col.b);\n        \n        float dist = sqrt(dr * dr + dg * dg + db * db) / colorWeights[i];\n        \n        if (dist < minDist) {\n            closest = col;\n            minDist = dist;\n        }\n    }\n    return closest;\n}\n\nvec3 saturateAndDesaturate(vec3 color) {\n    // Push saturation to extremes a bit (desaturate washed out colors, saturate colors that are already saturated)\n    vec3 hsv = rgb2hsv(color);\n    \n    if (hsv.y > 0.5) {\n        // saturate & raise value\n        hsv.y = pow(hsv.y, 0.4);\n        hsv.z = pow(hsv.z, 0.2);\n    } else if (hsv.y < 0.25) {\n        // lower value\n        hsv.z = round(hsv.z * 6.0) / 6.0;\n    }\n    \n    return hsv2rgb(hsv);\n}\n\nvec2 rightSideZoom(vec2 uv) {\n    uv /= 3.0;\n    uv.x += sin(iTime * 3.14 / 10.0) / 3.0;\n    uv.y += cos(iTime * 3.14 / 40.0) / 6.0;\n    return uv;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float aspectRatio = iResolution.x / iResolution.y;\n    vec2 targetResolution;\n    if (aspectRatio > 1.0) {\n        targetResolution = vec2(floor(targetResolutionBase * aspectRatio), targetResolutionBase);\n    } else {\n        targetResolution = vec2(targetResolutionBase, floor(targetResolutionBase * aspectRatio));\n    }\n    \n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // ----- Some shadertoy-specific fiddling to get the 2 images to appear side-by-side -----\n    float origUvX = uv.x;\n    uv.x *= 2.0;\n    targetResolution.x /= 2.0;\n    if (origUvX < 0.5) {\n        // Zoom in a bit on the video\n        uv.x *= 0.4;\n        uv.x += 0.2;\n        targetResolution.x /= 0.4;\n    } else {\n        uv = rightSideZoom(uv);\n        targetResolution *= 3.0;\n    }\n    // --------------------\n    \n    uv = floor(uv * targetResolution) / targetResolution;\n    \n    vec3 texColor0 = texture(iChannel0, uv).xyz;\n    vec3 texColor1 = texture(iChannel2, uv).xyz;\n    \n    vec3 texColor = origUvX > 0.5 ? texColor0 : texColor1;\n    texColor += (texture(iChannel1, uv).xyz - vec3(0.5, 0.5, 0.5)) * noiseInfluence;\n    \n    texColor = saturateAndDesaturate(texColor);\n    \n    texColor = closestColor(texColor);\n    \n    fragColor.rgb = texColor;\n    fragColor.a = 1.0;\n}","name":"Image","description":"","type":"image"}]}