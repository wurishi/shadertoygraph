{"ver":"0.1","info":{"id":"7lGXWK","date":"1641335188","viewed":223,"name":"Uniform Random Showcase 2D","username":"harry7557558","description":"An idea to showcase generating uniformly random points inside 2D shapes.\nLet me know about any idea to showcase 3D random functions.","likes":13,"published":1,"flags":32,"usePreview":0,"tags":["2d","spiral","intersection","dof","bokeh","random","star","heart","polygon","cardioid","rose","shape","union","uniform","subtraction","vesica"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// An idea to showcase generating uniformly random points inside 2D shapes\n// Each random function takes exactly two random values between 0 and 1, no rejection sampling\n\n// Functions are derived based on the following principles:\n// For circles/spiral, solve for a constant Jacobian (equals the reciprocal of shape area)\n// For polygons/stars, divide into multiple triangles\n// For explicit curves, apply inverse CDF sampling\n// If the inverse function cannot be solved analytically, start Newton-Raphson iteration at a point of inflection\n\n// Top to bottom, left to right:\n// - a circle\n// - a sector\n// - an ellipse\n// - a piecewise-elliptical heart\n// - a square\n// - a convex quadrilateral\n// - a regular polygon\n// - a regular polygonal star\n// - the area between two concentric circles\n// - the intersection of two circles\n// - the union of two circles\n// - the subtraction of two circles\n// - a cosine-based vesica-like shape\n// - a cardioid\n// - a rose curve\n// - a logarithmic spiral\n\n// See Buffer A\n\nvoid mainImage(out vec4 color, in vec2 coord) {\n    vec3 col = texelFetch(iChannel0,ivec2(coord),0).xyz;\n    col = vec3(0.8,1.0,1.2)*pow(col, vec3(0.7));\n    color = vec4(col, 1.0);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define PI 3.1415926\n\n\n// ================ RANDOM FUNCTIONS START ================\n\n// unit circle\nvec2 randCircle(float rand1, float rand2) {\n    float u = 2.0*PI*rand1;  // θ\n    float v = sqrt(rand2);  // r\n    return v*vec2(cos(u), sin(u));\n}\n\n// sector with abs(θ)<angle\nvec2 randSector(float angle, float rand1, float rand2) {\n    float u = angle*(2.0*rand1-1.0);  // θ\n    float v = sqrt(rand2);  // r\n    return v*vec2(cos(u), sin(u));\n}\n\n// ellipse with major and minor radius\nvec2 randEllipse(float rx, float ry, float rand1, float rand2) {\n    float u = 2.0*PI*rand1;  // θ\n    float v = sqrt(rand2);  // r\n    vec2 circ = v * vec2(cos(u), sin(u));  // unit circle\n    return vec2(rx, ry) * circ;  // linear transform\n}\n\n// x²-|x|y+y² < 1\nvec2 randHeart(float rand1, float rand2) {\n    float u = 2.0*PI*rand1;  // θ\n    float v = sqrt(rand2);  // r\n    vec2 c = v*vec2(cos(u), sin(u));  // unit circle\n    c = mat2(1.0,1.0,-0.577,0.577)*c;  // ellipse\n    if (c.x<0.0) c.y=-c.y;  // mirror\n    return c;\n}\n\n// -1 <= x,y < 1\nvec2 randSquare(float rand1, float rand2) {\n    float u = 2.0*rand1-1.0;\n    float v = 2.0*rand2-1.0;\n    return vec2(u, v);\n}\n\n// convex quadrilateral defined by ccw vertices\nvec2 randQuad(vec2 p0, vec2 p1, vec2 p2, vec2 p3, float rand1, float rand2) {\n    float u = rand1;\n    float v = rand2;\n    p1 -= p0, p2 -= p0, p3 -= p0;  // one point and three vectors\n    float area1 = 0.5*(p1.x*p2.y-p1.y*p2.x);  // area of the first triangle\n    float area2 = 0.5*(p2.x*p3.y-p2.y*p3.x);  // area of the second triangle\n    float th = area1 / (area1+area2);  // threshold to decide which triangle\n    if (u > th) p1 = p2, p2 = p3, u = (u-th)/(1.0-th);  // use the second triangle\n    else u /= th;  // use the first triangle\n    return p0 + mix(p1, p2, u) * sqrt(v);  // sample inside triangle\n    if (u+v>1.) u=1.-u, v=1.-v; return p0 + p1*u + p2*v;  // avoid square root, may or may not be faster\n}\n\n// regular n-gon with radius 1\nvec2 randPolygon(float n, float rand1, float rand2) {\n    float u = n*rand1;\n    float v = rand2;\n    float ui = floor(u);  // index of triangle\n    float uf = fract(u);  // interpolating in triangle\n    vec2 v0 = vec2(cos(2.*PI*ui/n), sin(2.*PI*ui/n));  // triangle edge #1\n    vec2 v1 = vec2(cos(2.*PI*(ui+1.)/n), sin(2.*PI*(ui+1.)/n));  // triangle edge #2\n    return sqrt(v) * mix(v0, v1, uf);  // sample inside triangle\n}\n\n// regular n-star with normalized size\nvec2 randStar(float n, float rand1, float rand2) {\n    float u = n*rand1;\n    float v = rand2;\n    float ui = floor(u);  // index of triangle\n    float uf = fract(u);  // interpolating in rhombus\n    vec2 v0 = vec2(cos(2.*PI*ui/n), sin(2.*PI*ui/n));  // rhombus edge #1\n    vec2 v1 = vec2(cos(2.*PI*(ui+1.)/n), sin(2.*PI*(ui+1.)/n));  // rhombus edge #2\n    vec2 p = v0 * v + v1 * uf;  // sample rhombus\n    return p / (n*sin(2.*PI/n)/PI);  // normalize size\n}\n\n// ring formed by two concentric circles with radius r0 and r1\nvec2 randConcentric(float r0, float r1, float rand1, float rand2) {\n    float u = 2.0*PI*rand1;  // θ\n    float v = sqrt(mix(r0*r0, r1*r1, rand2));  // r\n    return v * vec2(cos(u), sin(u));  // polar to Cartesian\n}\n\n// intersection of two circles with centers (0,±c) and radius r\nvec2 randIntersection(float c, float r, float rand1, float rand2) {\n    // https://www.desmos.com/calculator/sctxdxh1td\n    float u = rand1;\n    float v = 2.0*rand2-1.0;\n    float x1 = sqrt(r*r-c*c);  // x range [-x1, x1]\n    float i1 = 0.5*r*r*asin(x1/r)+0.5*x1*sqrt(r*r-x1*x1)-c*x1;  // area under the curve from 0 t0 x1\n    u = 2.0*i1*u - i1;  // u = Integral[0,x1,sqrt(x^2+y^2-c)]\n    float x = 0.0;  // solve for the x-coordinate\n    for (int iter=0; iter<6; iter++) {  // Newton-Raphson\n        float cdf = 0.5*(r*r*asin(x/r)+x*sqrt(r*r-x*x))-c*x;\n        float pdf = sqrt(r*r-x*x)-c;\n        x -= (cdf-u)/pdf;\n    }\n    float y = (sqrt(r*r-x*x)-c) * v;  // y-coordinate\n    return vec2(x, y);\n}\n\n// union of two circles with centers (±c,0) and radius r\nvec2 randUnion(float c, float r, float rand1, float rand2) {\n    // https://www.desmos.com/calculator/ddyum0rkgw\n    float u = 2.0*rand1-1.0;\n    float v = 2.0*rand2-1.0;\n    float s = sign(u);\n    float x1 = r+c;  // (x1,0)\n    float h0 = sqrt(r*r-c*c);  // (0,h0)\n    float i0 = -0.5*(c*h0+r*r*atan(c/h0));  // defaultIntegral(0.0)\n    float i1 = 0.25*PI*r*r;  // defaultIntegral(1.0)\n    u = mix(i0, i1, abs(u));  // x = defaultIntegral(u)\n    float x = c;  // iteration starts at a point of inflection\n    for (int iter=0; iter<6; iter++) {  // Newton-Raphson, solve for x\n        float pdf = sqrt(r*r-(x-c)*(x-c));\n        float cdf = 0.5*((x-c)*pdf+r*r*atan((x-c)/pdf));\n        x -= (cdf-u)/pdf;\n    }\n    float y = sqrt(r*r-(x-c)*(x-c)) * v;  // y-coordinate\n    return vec2(s*x, y);\n}\n\n// subtraction of a circle with center (c,0) from a circle with (0,0)\nvec2 randSubtraction(float c, float r, float rand1, float rand2) {\n    // https://www.desmos.com/calculator/jk1okdxoks\n    float u = rand1;\n    float v = 2.0*rand2-1.0;\n    float x1 = 0.5*c;  // x in [-r, x1]\n    float y1 = sqrt(r*r-0.25*c*c);  // rightmost (x1,±y1)\n    float a1 = y1*c;  // area of the middle part\n    float i1 = 0.5*(x1*sqrt(r*r-x1*x1)+r*r*asin(x1/r))-x1*y1;\n    float a2 = 2.0*i1;  // area of the top/bottom part\n    float th = a1/(a1+a2);  // decide the point lie in which part\n    if (u < th) {\n        float y = y1*v;  // y-coordinate\n        float x = c*(u/th) - sqrt(r*r-y*y);  // x-coordinate, shear a rectangle\n        return vec2(x, y);\n    }\n    u = i1 * (2.*((u-th)/(1.-th)) - 1.);  // x = defaultIntegral(u)\n    float x = 0.0;  // solve for x-coordinate\n    for (int iter=0; iter<6; iter++) {  // Newton-Raphson\n        float cdf = 0.5*(x*sqrt(r*r-x*x)+r*r*asin(x/r))-y1*x;\n        float pdf = sqrt(r*r-x*x)-y1;\n        x -= (cdf-u)/pdf;\n    }\n    float y = sign(v) * (y1+(sqrt(r*r-x*x)-y1)*abs(v));  // y-coordinate, note that v in [-1, 1)\n    return vec2(x, y);\n}\n\n// |y| < cos(x)-k\nvec2 randCosine(float k, float rand1, float rand2) {\n    float u = 2.0*rand1-1.0;  // related to x\n    float v = 2.0*rand2-1.0;  // related to y\n    float x1 = acos(k);  // maximum x\n    float y1 = sin(x1) - k*x1;  // a quarter of area\n    float yt = u*y1;  // randomly chosen area position\n    float x = 0.0;  // start iteration\n    for (int iter=0; iter<6; iter++) {  // Newton-Raphson\n        float cdf = sin(x)-k*x;\n        float pdf = cos(x)-k;\n        x -= (cdf-yt)/pdf;\n    }\n    float y = cos(x)-k;  // calculate y from x\n    return vec2(x, y*v);  // apply random to y\n}\n\n// r(θ) = 1-cos(θ)\nvec2 randCardioid(float rand1, float rand2) {\n    // integrate (1-cos(θ))², find the inverse on [0,2π)\n    float u = 3.0*PI*rand1;  // integral is 3π\n    float v = sqrt(rand2);  // r\n    float theta = PI;  // iteration starting point\n    for (int iter=0; iter<10; iter++) {\n        float cdf = 0.25*(sin(2.0*theta)-8.0*sin(theta)+6.0*theta);  // integral\n        float pdf = (1.0-cos(theta))*(1.0-cos(theta));  // area element\n        theta -= (cdf-u)/pdf;  // Newton-Raphson\n    }\n    float r = 1.0-cos(theta);  // polar equation\n    return v * r * vec2(cos(theta), sin(theta));  // polar coordinate\n}\n\n// r(θ) = cos(nθ)\nvec2 randRose(float n, float rand1, float rand2) {\n    // integrate cos(nθ)², split into n intervals and inverse in [-π/2n,π/2n)\n    float u = PI*rand1;  // integral in [0,2π) is π\n    float v = sqrt(rand2);  // r\n    float ui = PI/n*floor(2.0*n/PI*u);  // center of each \"petal\"\n    float uf = mod(u,PI/(2.0*n))-PI/(4.0*n);  // parameter of each \"petal\", integralOfCosNThetaSquared(θ)\n    float theta = 0.0;  // iteration starting point\n    for (int iter=0; iter<9; iter++) {\n        float cdf = 0.5*theta + sin(2.0*n*theta)/(4.0*n);  // integral of cos(nθ)²\n        float pdf = 0.5 + 0.5*cos(2.0*n*theta);  // cos(nθ)²\n        theta -= (cdf-uf)/pdf;  // Newton-Raphson\n    }\n    theta = ui + theta;  // move to petal\n    float r = cos(n*theta);  // polar equation\n    return v * r * vec2(cos(theta), sin(theta));  // polar coordinate\n}\n\n// logarithmic spiral, solvable analytically\nvec2 randSpiral(float k, float a0, float a1, float rand1, float rand2) {\n    float s0 = exp(2.0*PI*k*a0), s1 = exp(2.0*PI*k*a1);  // r = s*exp(kθ)\n    // (x,y)=s*exp(kθ)*(cos(θ),sin(θ)), ∂(x,y)/∂(s,θ)=s*exp(2kθ), s*exp(2kθ)*∂(s,θ)/∂(u,v)=(s1²-s0²)/4k\n    // ∂u∂v=(2s/(s1²-s0²))∂s*(2kexp(2kθ))∂θ, integrate and invert to find θ(u) and s(v)\n    float u = rand1;  // for angle\n    float v = rand2;  // for distance\n    float theta = log(1.0-u)/(2.0*k);  // θ(u)\n    float s = sqrt(mix(s0*s0, s1*s1, v));  // s(v)\n    return s * exp(k*theta) * vec2(cos(theta),sin(theta));  // formula\n}\n\n// ================ RANDOM FUNCTIONS END. ================\n\n\n\n// scene\nvec3 intersectRay(vec3 ro, vec3 rd) {\n    vec3 col = mix(vec3(0.0), 0.1*vec3(0.2,0.3,0.8), 0.5+0.5*sin(4.0*rd.x)*cos(4.0*rd.y)*sin(4.0*rd.z));\n    vec3 p;\n    // red\n    p = ro+rd*(-(ro.y+4.0)/rd.y);\n    if (length(p.xz-vec2(-0.8,-0.8))<0.2) col+=20.0*vec3(1.0,0.3,0.1);\n    // yellow\n    p = ro+rd*(-(ro.y+10.0)/rd.y);\n    if (length(p.xz-vec2(3.0,2.0))<0.2) col+=20.0*vec3(1.0,0.8,0.5);\n    // blue\n    p = ro+rd*(-(ro.y+20.0)/rd.y);\n    if (length(p.xz-vec2(0.0,-1.5))<0.2) col+=20.0*vec3(0.1,0.6,1.0);\n    // green\n    p = ro+rd*(-(ro.y+50.0)/rd.y);\n    if (length(p.xz-vec2(-12.0,1.0))<0.2) col+=40.0*vec3(0.1,1.0,0.4);\n    return col;\n}\n\n// quasi-random\nfloat vanDerCorput(float n, float b) {\n    float x = 0.0;\n    float e = 1.0 / b;\n    while (n > 0.0) {\n        float d = mod(n, b);\n        x += d * e;\n        e /= b;\n        n = floor(n / b);\n    }\n    return x;\n}\n\n// main\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // random number seed\n    vec3 p3 = fract(fragCoord/iResolution.xy*.1031).xyx;\n    p3 += dot(p3, p3.zyx + 31.32);\n    float h = fract((p3.x + p3.y) * p3.z);\n    float seed = floor(65536.*h) + float(iFrame);\n\n    // camera parameters\n    const vec3 POS = vec3(3.0,3.0,0.0);\n    const float SCALE = 1.5;  // larger = smaller (more view field)\n    const float DIST = 0.2;  // larger = smaller\n    const float VIEW_FIELD = 0.5;  // larger = larger + more perspective\n    const float APERTURE = 0.02;  // larger = blurred\n\n    // sample aperture shape\n    float rand1 = vanDerCorput(seed, 2.);\n    float rand2 = vanDerCorput(seed, 3.);\n    vec2 rnd;\n\n    ivec2 shape_id = ivec2(floor(4.0*fragCoord.xy/iResolution.xy));\n    if (shape_id.y==3) {\n        if (shape_id.x==0) rnd = randCircle(rand1, rand2);\n        if (shape_id.x==1) rnd = randSector(0.8*PI, rand1, rand2);\n        if (shape_id.x==2) rnd = randEllipse(1.2, 0.8, rand1, rand2);\n        if (shape_id.x==3) rnd = randHeart(rand1, rand2);\n    }\n    if (shape_id.y==2) {\n        if (shape_id.x==0) rnd = randSquare(rand1, rand2);\n        if (shape_id.x==1) rnd = randQuad(vec2(-1.0,-1.0), vec2(0.8,-0.9), vec2(1.0,1.2), vec2(-0.4,0.8), rand1, rand2);\n        if (shape_id.x==2) rnd = randPolygon(5., rand1, rand2);\n        if (shape_id.x==3) rnd = randStar(5., rand1, rand2);\n    }\n    if (shape_id.y==1) {\n        if (shape_id.x==0) rnd = randConcentric(0.6, 1.1, rand1, rand2);\n        if (shape_id.x==1) rnd = randIntersection(0.9, 1.6, rand1, rand2);\n        if (shape_id.x==2) rnd = randUnion(0.6, 0.8, rand1, rand2);\n        if (shape_id.x==3) rnd = randSubtraction(1.0, 1.0, rand1, rand2);\n    }\n    if (shape_id.y==0) {\n        if (shape_id.x==0) rnd = randCosine(0.4, rand1, rand2);\n        if (shape_id.x==1) rnd = randCardioid(rand1, rand2);\n        if (shape_id.x==2) rnd = randRose(5., rand1, rand2);\n        if (shape_id.x==3) rnd = randSpiral(0.2, -0.1, 0.3, rand1, rand2);\n    }\n\n    // camera\n    vec3 ro = POS+vec3(0,DIST,0);\n    vec2 randuv = vec2(vanDerCorput(seed,5.), vanDerCorput(seed,7.));\n    vec2 uv = SCALE*(2.0*fract(4.0*(fragCoord.xy+randuv-0.5)/iResolution.xy)-1.0);\n    vec2 sc = iResolution.xy/length(iResolution.xy);\n    vec2 offset = APERTURE*rnd;\n    ro.xz += offset;\n    vec3 rd = vec3(VIEW_FIELD*uv*sc+vec2(-0.25,0.0)-offset/DIST, -1.0).xzy;\n\n    // calculate pixel color\n    vec3 col = intersectRay(ro, rd);\n    vec4 rgbn = texelFetch(iChannel0, ivec2(int(fragCoord.x), int(fragCoord.y)), 0);\n    fragColor = vec4((rgbn.xyz*rgbn.w + col)/(rgbn.w+1.0), rgbn.w+1.0);\n}\n","name":"Buffer A","description":"","type":"buffer"}]}