{"ver":"0.1","info":{"id":"NsjXzW","date":"1619794864","viewed":151,"name":"Quick Little Ray Tracer","username":"trigophers","description":"A simple raytracer that I wrote in an OpenGL project, just copied and pasted the fragment shader over here and then added anti-aliasing, sine normal texture, and movement.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["raytracer"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 pos;\nvec3 ray;\nvec3 normal;\nvec3 c;\nvec3 temp;\nvec4 average;\nfloat rDist;\n//vec3 CamPos = vec3(-50, 0.0, -250.0);\n//vec2 CamDir = vec2(0.7853, -0.1745);\nfloat FoV = 300.0;\n\nvoid setVec(vec3 cP, vec3 cR) {\n    pos = cP;\n    ray = normalize(cR);\n}\n\nvoid dirVec(vec2 cD) {\n    temp.x = ray.z;\n    ray.z = ray.z * cos(cD.y) - ray.y * sin(cD.y);\n    ray.y = ray.y * cos(cD.y) + temp.x * sin(cD.y);\n    temp.x = ray.z;\n    ray.z = ray.z * cos(cD.x) - ray.x * sin(cD.x);\n    ray.x = ray.x * cos(cD.x) + temp.x * sin(cD.x);\n}\n\nvoid sphere(vec3 sPos, float rad, vec3 sColor, int mat) {\n    vec3 obj = sPos - pos;\n    temp.x = dot(obj, ray);\n    temp.y = dot(obj, obj);\n    if ((temp.x > 0.0) && (rad * rad > (temp.y - temp.x * temp.x))) {\n        temp.z = sqrt(rad * rad - (temp.y - temp.x * temp.x));\n        if ((temp.y > rad * rad) && rDist > temp.x - temp.z) {\n            rDist = temp.x - temp.z;\n            vec3 normalTemp = pos + ray * vec3(rDist, rDist, rDist) - sPos;\n            normal = normalize(normalTemp+vec3(sin(normalTemp.x*1.0)*2.0, \n                                               sin(normalTemp.y*1.0)*2.0, \n                                               sin(normalTemp.z*1.0)*2.0));\n            // 0: color by color, 1: color by normal\n            if (mat == 0) {\n                c = sColor;\n            }\n            else if (mat == 1) {\n                c = (normal + vec3(1.0, 1.0, 1.0)) / vec3(2.0, 2.0, 2.0);\n            }\n        }\n    }\n}\n\nvoid scene() {\n    sphere(vec3(0.0, -1000100, 0.0), 1000000.0, vec3(0.9, 0.9, 0.9), 1);\n    sphere(vec3(0.0, -80.0, 0.0), 20.0, vec3(0.0, 1.0, 0.0), 1);\n    sphere(vec3(-30.0, -70.0, 50), 30.0, vec3(1.0, 0.0, 0.0), 1);\n    sphere(vec3(30.0, -90.0, -50), 10.0, vec3(0.2, 0.3, 0.8), 1);\n}\n\nvoid raytrace(vec2 pos) {\n    vec3 CamPos = vec3(cos(iTime)*200.0, -20.0, sin(iTime)*200.0);\n    vec2 CamDir = vec2(iTime*-1.0+4.7123, -0.3);\n    //vec2 CamDir = vec2(0.0, 0.0);\n    setVec(CamPos, vec3(pos, 512));\n    dirVec(CamDir);\n    rDist = 10000.0;\n    scene();\n    if (!(rDist < 10000.0)) {\n        temp.x = (ray.y + 1.0) / 2.0;\n        temp.y = 1.0 - temp.x;\n        c = vec3(temp.y, temp.y, temp.y)\n            + vec3(temp.x, temp.x, temp.x)\n            * vec3(0.5, 0.7, 1.0);\n    }\n\n    \n    average += vec4(c, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    vec2 uv = fragCoord/(iResolution.x<iResolution.y?\n        vec2(iResolution.x, iResolution.x):\n        vec2(iResolution.y, iResolution.y));\n        \n    average = vec4(0, 0, 0, 0);\n    vec2 positionTemp = gl_FragCoord.xy - iResolution.xy/vec2(2.0, 2.0);\n    raytrace(positionTemp+vec2(-0.5, -0.5));\n    raytrace(positionTemp+vec2(-0.5,  0.5));\n    raytrace(positionTemp+vec2( 0.5, -0.5));\n    raytrace(positionTemp+vec2( 0.5,  0.5));\n    \n    fragColor = average / vec4(4, 4, 4, 4);\n}\n","name":"Image","description":"","type":"image"}]}