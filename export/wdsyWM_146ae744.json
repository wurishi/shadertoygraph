{"ver":"0.1","info":{"id":"wdsyWM","date":"1588961101","viewed":46,"name":"titanic telegraph side","username":"mrabbitz","description":"text","likes":0,"published":1,"flags":32,"usePreview":0,"tags":["text"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Look at Buffer A\n// comes from modification of https://www.shadertoy.com/view/XdXGRB\n// it is mapped onto the side of the telgraphs at https://www.shadertoy.com/view/WslyRj\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    // [-1, 1]\n    vec2 uv2 = 2.0 * uv - vec2(1.0);\n    fragColor.rgb = texture(iChannel0, uv).rgb;\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// comes from modification of https://www.shadertoy.com/view/XdXGRB\n// it is mapped onto the side of the telgraphs at https://www.shadertoy.com/view/WslyRj\n\nvec2 coord;\n\n#define font_size 20. \n#define font_spacing .055\n#define STROKEWIDTH 0.2\n#define PI 3.14159265359\n\n#define A_ vec2(0.,0.)\n#define A1_ vec2(1.,0.)\n#define B_ vec2(2.,0.)\n#define B1_ vec2(3.,0.)\n#define C_ vec2(4.,0.)\n\n#define D_ vec2(0.,1.)\n#define E_ vec2(2.,1.)\n#define F_ vec2(4.,1.)\n\n#define G_ vec2(0.,2.)\n#define G1_ vec2(1.,3.2)\n#define H_ vec2(2.,2.)\n#define H1_ vec2(3.,3.2)\n#define I_ vec2(4.,2.)\n\n#define J_ vec2(0.,3.)\n#define K_ vec2(2.,3.)\n#define L_ vec2(4.,3.)\n\n#define M_ vec2(0.,4.)\n#define M1_ vec2(1.,4.)\n#define N_ vec2(2.,4.)\n#define N1_ vec2(3.,4.)\n#define O_ vec2(4.,4.)\n\n#define P_ vec2(0.,5.)\n#define Q_ vec2(2.,5.)\n#define R_ vec2(4.,5.)\n\n#define S_ vec2(0.,6.)\n#define T_ vec2(2.,6.)\n#define U_ vec2(4.,6.)\n\n#define L(p) t(M_,O_,p) + t(M_,A_,p)\n#define O(p) t(M_,O_,p) + t(O_,C_,p) + t(C_,A_, p) + t(A_,M_,p)\n#define S(p) t(M_,O_,p) + t(O_,I_,p) + t(I_,G_,p) + t(G_,A_,p) + t(A_,C_,p)\n#define W(p) t(A_,M1_,p) + t(M1_,B_,p) + t(B_,N1_,p) + t(N1_,C_,p)\n\n#define F(p) t(M_,A_,p) + t(A_,C_,p) + t(G_,I_,p)\n#define U(p) t(M_,A_,p) + t(M_,O_,p) + t(O_,C_,p)\n\n#define H(p) t(M_,A_,p) + t(G_,I_,p) + t(O_,C_,p)\n#define A(p) t(M_,B_,p) + t(G1_,H1_,p) + t(B_,O_,p)\n\n#define T(p) t(N_,B_,p) + t(A_,C_,p)\n#define P(p) t(M_,A_,p) + t(A_,C_,p) + t(G_,I_,p) + t(C_,I_,p)\n\t\nvec2 caret_origin = vec2(11., .5);\nvec2 caret;\n\n//-----------------------------------------------------------------------------------\nfloat minimum_distance(vec2 v, vec2 w, vec2 p)\n{\t// Return minimum distance between line segment vw and point p\n  \tfloat l2 = (v.x - w.x)*(v.x - w.x) + (v.y - w.y)*(v.y - w.y); //length_squared(v, w);  // i.e. |w-v|^2 -  avoid a sqrt\n  \tif (l2 == 0.0) {\n\t\treturn distance(p, v);   // v == w case\n\t}\n\t\n\t// Consider the line extending the segment, parameterized as v + t (w - v).\n  \t// We find projection of point p onto the line.  It falls where t = [(p-v) . (w-v)] / |w-v|^2\n  \tfloat t = dot(p - v, w - v) / l2;\n  \tif(t < 0.0) {\n\t\t// Beyond the 'v' end of the segment\n\t\treturn distance(p, v);\n\t} else if (t > 1.0) {\n\t\treturn distance(p, w);  // Beyond the 'w' end of the segment\n\t}\n  \tvec2 projection = v + t * (w - v);  // Projection falls on the segment\n\treturn distance(p, projection);\n}\n\n//-----------------------------------------------------------------------------------\nfloat textColor(vec2 from, vec2 to, vec2 p)\n{\n\tp *= font_size;\n\tfloat inkNess = 0., nearLine, corner;\n\tnearLine = minimum_distance(from,to,p); // basic distance from segment, thanks http://glsl.heroku.com/e#6140.0\n\tinkNess += smoothstep(0., 1., 1.- 14.*(nearLine - STROKEWIDTH)); // ugly still\n\tinkNess += smoothstep(0., 2.5, 1.- (nearLine  + 5. * STROKEWIDTH)); // glow\n\treturn inkNess;\n}\n\n//-----------------------------------------------------------------------------------\nvec2 grid(vec2 letterspace) \n{\n\treturn ( vec2( (letterspace.x / 2.) * .65 , 1.0-((letterspace.y / 2.) * .95) ));\n}\n\n//-----------------------------------------------------------------------------------\nfloat count = 0.0;\nfloat gtime;\nfloat t(vec2 from, vec2 to, vec2 p) \n{\n\treturn textColor(grid(from), grid(to), p);\n}\n\n//-----------------------------------------------------------------------------------\nmat2 rotate2d(float _angle){\n    return mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle));\n}\nvec2 rSlow()\n{\n\tvec2 pos = coord.xy/iResolution.xy;\n\t\n    \n    pos -= vec2(0.5);\n    // rotate the space\n    pos = rotate2d( PI / 4. ) * pos;\n    // move it back to the original place\n    pos += vec2(0.5);\n    \n    pos.y -= caret.y;\n\tpos.x -= font_spacing*caret.x;\n\treturn pos;\n}\nvec2 rFull()\n{\n\tvec2 pos = coord.xy/iResolution.xy;\n\t\n    \n    pos -= vec2(0.5);\n    // rotate the space\n    pos = rotate2d( -PI / 5. ) * pos;\n    // move it back to the original place\n    pos += vec2(0.5);\n    \n    pos.y -= caret.y;\n\tpos.x -= font_spacing*caret.x;\n    \n    pos.y += 0.01;\n    pos.x -= 0.01;\n    \n\treturn pos;\n}\nvec2 rHalf()\n{\n\tvec2 pos = coord.xy/iResolution.xy;\n\t\n    \n    pos -= vec2(0.5);\n    // rotate the space\n    pos = rotate2d( PI / 5. ) * pos;\n    // move it back to the original place\n    pos += vec2(0.5);\n    \n    pos.y -= caret.y;\n\tpos.x -= font_spacing*caret.x;\n    \n    pos.y -= 0.01;\n    pos.x -= 0.01;\n    \n\treturn pos;\n}\nvec2 rStop()\n{\n\tvec2 pos = coord.xy/iResolution.xy;\n    pos.y -= caret.y;\n\tpos.x -= font_spacing*caret.x;\n\treturn pos;\n}\nvec2 rHalf1()\n{\n\tvec2 pos = coord.xy/iResolution.xy;\n\t\n    \n    pos -= vec2(0.5);\n    // rotate the space\n    pos = rotate2d( -PI / 5. ) * pos;\n    // move it back to the original place\n    pos += vec2(0.5);\n    \n    pos.y -= caret.y;\n\tpos.x -= font_spacing*caret.x;\n    \n    pos.x += 0.55;\n    \n\treturn pos;\n}\nvec2 rFull1()\n{\n\tvec2 pos = coord.xy/iResolution.xy;\n\t\n    \n    pos -= vec2(0.5);\n    // rotate the space\n    pos = rotate2d( PI / 5. ) * pos;\n    // move it back to the original place\n    pos += vec2(0.5);\n    \n    pos.y -= caret.y;\n\tpos.x -= font_spacing*caret.x;\n    \n    pos.x += 0.55;\n    \n\treturn pos;\n}\n\n//-----------------------------------------------------------------------------------\nvoid add()\n{\n\tcaret.x += 1.7;\n}\n\n//-----------------------------------------------------------------------------------\nvoid space()\n{\n\tcaret.x += 1.5;\n}\n\n//-----------------------------------------------------------------------------------\nvoid newline()\n{\n\tcaret.x = caret_origin.x;\n\tcaret.y -= .18;\n}\n\n//-----------------------------------------------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat d = 0.;\n\tvec3 col = vec3(0.0, 0.0, 0.0);\n    \n    coord = fragCoord;\n\t\n    // SLOW\n\t//caret = caret_origin;\n\t//d += S(rSlow()); add(); d += L(rSlow()); add(); d += O(rSlow()); add(); d += W(rSlow());\n    // FULL\n    caret = caret_origin;\n    d += F(rFull()); add(); d += U(rFull()); add(); d += L(rFull()); add(); d += L(rFull());\n    // HALF\n    caret = caret_origin;\n    d += H(rHalf()); add(); d += A(rHalf()); add(); d += L(rHalf()); add(); d += F(rHalf());\n    // STOP\n    caret = caret_origin;\n    caret.x -= 5.0;\n    caret.y += 0.38;\n    d += S(rStop()); add(); d += T(rStop()); add(); d += O(rStop()); add(); d += P(rStop());\n    // HALF\n    caret = caret_origin;\n    d += H(rHalf1()); add(); d += A(rHalf1()); add(); d += L(rHalf1()); add(); d += F(rHalf1());\n    // FULL\n    caret = caret_origin;\n    d += F(rFull1()); add(); d += U(rFull1()); add(); d += L(rFull1()); add(); d += L(rFull1());\n      \n    col += vec3(d);\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    // [-1, 1]\n    uv = 2.0 * uv - vec2(1.0);\n    col *= 1.0 - step(1.0, length(uv));\n    if (col.r > 0.0)\n    {\n        if (uv.x > 0.0 || (uv.x > -0.4 && uv.y > 0.5))\n        {\n        \tcol = vec3(1.0, 0.0, 0.0);\n        }\n        else\n        {\n            col = vec3(1.0);\n        }\n    }\n\n    //if((step(0.0, uv.y + 0.01) - step(0.0, uv.y - 0.01)) > 0.1)\n    //{\n    //    col = vec3(1.0);\n    //}\n    if (length(uv) < 0.15 && length(uv) > 0.12)\n    {\n        col = vec3(1.0);\n    }\n    if (abs(uv.x) < 0.015 && abs(uv.y) > 0.15 && abs(uv.y) < 0.28)\n    {\n        col = vec3(1.0);\n    }\n        if (abs(uv.y) < 0.015 && abs(uv.x) > 0.15 && abs(uv.x) < 0.37)\n    {\n        col = vec3(1.0);\n    }\n    if(abs(uv.x) > 0.36 || abs(uv.y) > 0.28)\n    {\n    \tif ((step((uv.x/1.3)-0.015, uv.y-.28) - step((uv.x/1.3)+0.015, uv.y-.28)) > 0.5)\n    \t{\n    \t    col = vec3(1.0);\n    \t}\n    \tif ((step((uv.x/1.3)-0.015, uv.y+.28) - step((uv.x/1.3)+0.015, uv.y+.28)) > 0.5)\n    \t{\n    \t    col = vec3(1.0);\n    \t}\n    \tif ((step((-uv.x/1.3)-0.015, uv.y-.28) - step((-uv.x/1.3)+0.015, uv.y-.28)) > 0.5)\n    \t{\n    \t    col = vec3(1.0);\n    \t}\n    \tif ((step((-uv.x/1.3)-0.015, uv.y+.28) - step((-uv.x/1.3)+0.015, uv.y+.28)) > 0.5)\n    \t{\n    \t    col = vec3(1.0);\n    \t}\n    }\n    \n    fragColor = vec4( col, 1.0 );\n}\n","name":"Buffer A","description":"","type":"buffer"}]}