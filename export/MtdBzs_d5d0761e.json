{"ver":"0.1","info":{"id":"MtdBzs","date":"1540725661","viewed":1083,"name":"Raymarching Basics - Part 4","username":"liqwidice","description":"Final part of the Raymarching workshop\nView full course here:\nhttps://github.com/electricsquare/raymarching-workshop","likes":11,"published":1,"flags":0,"usePreview":1,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4df3Rr","filepath":"/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","previewfilepath":"/media/ap/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// The MIT License\n// Copyright Â© 2018-2021 AJ Weeks\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Part of the Raymarching workshop\n// https://github.com/electricsquare/raymarching-workshop\n//\n// Part 1a: https://www.shadertoy.com/view/XltBzj\n// Part 1b: https://www.shadertoy.com/view/4tdBzj\n// Part 1c: https://www.shadertoy.com/view/4t3fzn\n// Part 2:  https://www.shadertoy.com/view/Xl3fzn\n// Part 3a: https://www.shadertoy.com/view/Xtcfzn\n// Part 3b: https://www.shadertoy.com/view/XlcfRM\n// Part 4:  https://www.shadertoy.com/view/MtdBzs\n//\n\n\n#define AA_QUALITY 0\n#define ENABLE_POST_PROCESSING 1\n#define ENABLE_CAMERA_MOVEMENT 0\n#define ENABLE_SHADOWS 1\n#define SHADOW_FALLOFF 0.05\n#define SHADOW_OPACITY 0.8\n\nfloat sdSphere(vec3 p, float r)\n{\n    return length(p)-r;\n}\n\nfloat sdBox(vec3 p, vec3 size)\n{\n    vec3 d = abs(p) - size;\n    return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));\n}\n\nfloat sdTorus(vec3 p, vec2 radii)\n{\n    return length(vec2(length(p.xz) - radii.x, p.y)) - radii.y;\n}\n\nfloat sdPlane(vec3 p, vec4 n)\n{\n    return dot(p, n.xyz) + n.w;\n}\n\n//------------------------------------------------------------------\n\n\nfloat opS(float d1, float d2)\n{\n    return max(-d2, d1);\n}\n\nvec2 opU(vec2 d1, vec2 d2)\n{\n\treturn (d1.x < d2.x) ? d1 : d2;\n}\n\n//------------------------------------------------------------------\n\n// polynomial smooth min (k = 0.1);\nfloat sminCubic(float a, float b, float k)\n{\n    float h = max(k-abs(a-b), 0.0);\n    return min(a, b) - h*h*h/(6.0*k*k);\n}\n\nvec2 opBlend(vec2 d1, vec2 d2)\n{\n    float k = 2.0;\n    float d = sminCubic(d1.x, d2.x, k);\n    float m = mix(d1.y, d2.y, clamp(d1.x-d,0.0,1.0));\n    return vec2(d, m);\n}\n\n\n//------------------------------------------------------------------\n\nvec2 SDF(vec3 pos)\n{\n    vec2 res =         vec2(sdSphere(pos-vec3(3.5,-0.5,10), 2.5),    0.1);\n    res = opBlend(res, vec2(sdSphere(pos-vec3(-3.5, -0.5, 10), 2.5), 2.0));\n    res = opBlend(res, vec2(sdSphere(pos-vec3(0, sin(iTime*2.0)*0.4+4., 10), 3.0),      5.0));\n    res = opBlend(res, vec2(sdSphere(pos-vec3(0, sin(1.0+iTime*2.5)*0.4-3.5, 10), 2.0), 8.0));\n    res = opBlend(res, vec2(sdSphere(pos-vec3(0, -0.75, 8), 1.3),    1.0));\n    res = opU(res, vec2(sdPlane(pos, vec4(0, 1.4, 0, 10)),           -0.5));\n    \n    vec2 shapeA = vec2(sdBox(pos-vec3(9, -3.0, 8), vec3(1.5)),  1.5);\n    vec2 shapeB = vec2(sdSphere(pos-vec3(9, -3.0, 8), 1.5),        3.0);\n    res = opU(res, mix(shapeA, shapeB, sin(iTime)*1.0));\n    \n    float radius = (sin(iTime*1.6)*0.3+0.15)+1.3;\n    res = opU(res, vec2(opS(sdBox(pos -  vec3(-9, 4.5, 12), vec3(1,1,1)),     \n                            sdSphere(pos-vec3(-9, 4.5, 12), radius)),8.0));\n\n    return res;\n}\n\nvec3 calcNormal(vec3 pos)\n{\n\t// Center sample\n    float c = SDF(pos).x;\n\t// Use offset samples to compute gradient / normal\n    vec2 eps_zero = vec2(0.001, 0.0);\n    return normalize(vec3(\n        SDF(pos + eps_zero.xyy).x,\n        SDF(pos + eps_zero.yxy).x,\n        SDF(pos + eps_zero.yyx).x) - c);\n}\n\nstruct IntersectionResult\n{\n    float minDist;\n    float mat;\n    int steps;\n};\n\nIntersectionResult castRay(vec3 rayOrigin, vec3 rayDir)\n{\n    float tmax = 100.0;\n    float t = 0.0;\n    \n    IntersectionResult result;\n    result.mat = -1.0;\n    \n    for (result.steps = 0; result.steps < 128; result.steps++)\n    {\n        vec2 res = SDF(rayOrigin + rayDir * t);\n        if (res.x < (0.0001*t))\n        {\n            result.minDist = t;\n            return result;\n        }\n        else if (res.x > tmax)\n        {\n            result.mat = -1.0;\n            result.minDist = -1.0;\n            return result;\n        }\n        t += res.x;\n        result.mat = res.y;\n    }\n    \n    result.minDist = t;\n    return result;\n}\n\nvec3 triplanarMap(vec3 surfacePos, vec3 normal, float scale)\n{\n\t// Take projections along 3 axes, sample texture values from each projection, and stack into a matrix\n\tmat3x3 triMapSamples = mat3x3(\n\t\ttexture(iChannel0, surfacePos.yz * scale).rgb,\n\t\ttexture(iChannel0, surfacePos.xz * scale).rgb,\n\t\ttexture(iChannel0, surfacePos.xy * scale).rgb\n\t\t);\n\n\t// Weight three samples by absolute value of normal components\n\treturn triMapSamples * abs(normal);\n}\n\n// https://iquilezles.org/articles/checkerfiltering\nfloat checkersGradBox(vec2 p)\n{\n    vec2 w = fwidth(p) + 0.001;\n    vec2 i = 2.0*(abs(fract((p-0.5*w)*0.5)-0.5)-abs(fract((p+0.5*w)*0.5)-0.5))/w;\n    return clamp(0.5 - 0.5*i.x*i.y,0.0,1.0);\n}\n\nvec3 fogColor = vec3(0.30, 0.36, 0.60);\n\nvec3 applyFog(vec3 rgb, float dist)\n{\n    float startDist = 80.0;\n    float fogAmount = 1.0 - exp(-(dist-8.0) * (1.0/startDist));\n    return mix(rgb, fogColor, fogAmount);\n}\n\n// Return a psuedo random value in the range [0, 1), seeded via coord\nfloat rand(vec2 coord)\n{\n    return fract(sin(dot(coord.xy, vec2(12.9898,78.233))) * 43758.5453);\n}\n\n//https://www.shadertoy.com/view/ll2GD3\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nvec3 render(vec3 rayOrigin, vec3 rayDir)\n{\n    vec3 col = fogColor - rayDir.y * 0.4; // Default skybox colour\n    IntersectionResult res = castRay(rayOrigin, rayDir);\n    float t = res.minDist; // Distance to surface\n    float m = res.mat; // Material ID\n    float steps = float(res.steps);\n\n#define SHOW_STEP_COUNT 0\n#if SHOW_STEP_COUNT\n    return vec3(steps/350., 0.0, 0.0);\n#endif\n    \n    vec3 N = vec3(0.0, 1.0, 0.0);\n    vec3 L = normalize(vec3(sin(iTime), 0.9, -0.5));\n\n    if (m > -1.0)\n    {\n        vec3 pos = rayOrigin + rayDir * t;\n        \n        if (m > -0.5)\n        {\n            N = calcNormal(pos);\n            \n            //col = pal(m*0.05, vec3(0.05,0.2,0.2),vec3(0.2,0.4,0.5),vec3(0.39,0.6,0.7),vec3(0.1,0.3,0.90));\n            col = vec3(0.18*m, 0.6-0.05*m, 0.2+0.2*N.y)*0.8+0.2;\n\t\t\t\n        \t// L is vector from surface point to light, N is surface normal. N and L must be normalized!\n            float NoL = max(dot(N, L), 0.0);\n            vec3 LDirectional = vec3(1.25, 1.2, 0.8) * NoL;\n            vec3 LAmbient = vec3(0.03, 0.04, 0.1);\n            vec3 diffuse = col * (LDirectional + LAmbient);\n            \n            vec3 texSample = triplanarMap(pos, N, 0.2);\n            // Only apply texture to materials > 4.5\n        \tcol = mix(diffuse, diffuse*texSample, step(4.5, m));\n            \n            // Visualize normals:\n          \t//col = N * vec3(0.5) + vec3(0.5);\n        }\n        else\n        {\n            // Ground plane\n            float grid = checkersGradBox(pos.xz*0.2) * 0.03 + 0.1;\n            col = vec3(grid, grid, grid);\n            \n#if ENABLE_SHADOWS\n            float shadow = 0.0;\n            float shadowRayCount = 2.0;\n            for (float s = 0.0; s < shadowRayCount; s++)\n            {\n                vec3 shadowRayOrigin = pos + N * 0.01;\n                float r = rand(vec2(rayDir.xy)) * 2.0 - 1.0;\n                vec3 shadowRayDir = L + vec3(1.0 * SHADOW_FALLOFF) * r;\n                IntersectionResult shadowRayIntersection = castRay(shadowRayOrigin, shadowRayDir);\n                if (shadowRayIntersection.mat != -1.0)\n                {\n                    shadow += 1.0;\n                }\n            }\n            \n    \t\tvec3 cshadow = pow(vec3(shadow), vec3(1.0, 1.2, 1.5));\n            col = mix(col, col*cshadow*(1.0-SHADOW_OPACITY), shadow/shadowRayCount);\n#endif\n        }\n\n        col = applyFog(col, pos.z);\n    }\n    \n    return col;\n}\n\nvec3 getCameraRayDir(vec2 uv, vec3 camPos, vec3 camTarget)\n{\n\tvec3 camForward = normalize(camTarget - camPos);\n\tvec3 camRight = normalize(cross(vec3(0.0, 1.0, 0.0), camForward));\n\tvec3 camUp = normalize(cross(camForward, camRight));\n\n    // fPersp controls the camera's field of view. Try changing it!\n    float fPersp = 2.0;\n\tvec3 vDir = normalize(uv.x * camRight + uv.y * camUp + camForward * fPersp);\n\n\treturn vDir;\n}\n\nvec2 normalizeScreenCoords(vec2 screenCoord)\n{\n    vec2 result = 2.0 * (screenCoord/iResolution.xy - 0.5);\n    result.x *= iResolution.x/iResolution.y; // Correct for aspect ratio\n    return result;\n}\n\nvec4 getSceneColor(vec2 fragCoord)\n{ \n    vec3 camPos = vec3(0, 0, -7);\n#if ENABLE_CAMERA_MOVEMENT\n    camPos += vec3(sin(iTime*0.5)*0.5, cos(iTime*0.5)*0.1, 0.0);\n#endif\n    vec3 at = vec3(0, 0, 0);\n    \n    vec2 uv = normalizeScreenCoords(fragCoord);\n    vec3 rayDir = getCameraRayDir(uv, camPos, at);\n    \n    vec3 col = render(camPos, rayDir);\n    \n    return vec4(col, 1.0);\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord)\n{\n    fragColor = vec4(0.0);\n    \n#if AA_QUALITY > 1\n    float AA_size = float(AA_QUALITY);\n    float count = 0.0;\n    for (float aaY = 0.0; aaY < AA_size; aaY++)\n    {\n        for (float aaX = 0.0; aaX < AA_size; aaX++)\n        {\n            fragColor += getSceneColor(fragCoord + vec2(aaX, aaY) / AA_size);\n            count += 1.0;\n        }\n    }\n    fragColor /= count;\n#else\n    fragColor = getSceneColor(fragCoord);\n#endif\n    \n    \n#if ENABLE_POST_PROCESSING\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 screenCoord = fragCoord/iResolution.xy;\n\n    // Vignette\n    float radius = 0.8;\n    float d = smoothstep(radius, radius-0.5, length(screenCoord-vec2(0.5)));\n    fragColor = mix(fragColor, fragColor * d, 0.5);\n    \n    // Contrast\n    float constrast = 0.3;\n    fragColor = mix(fragColor, smoothstep(0.0, 1.0, fragColor), constrast);\n    \n    // Colour mapping\n    fragColor *= vec4(0.90,0.96,1.1,1.0);\n#endif\n    \n    fragColor = pow(fragColor, vec4(0.4545)); // Gamma correction (1.0 / 2.2)\n}","name":"Image","description":"","type":"image"}]}