{"ver":"0.1","info":{"id":"lcjyzD","date":"1722603375","viewed":104,"name":"Area Lights Refactor","username":"spalmer","description":"Area lights (sphere, line, rect, disc) using the most representative point method.\nJust refactoring piyushslayer's toy, mostly.\n","likes":18,"published":1,"flags":32,"usePreview":0,"tags":["specular","brdf","disc","tube","arealight","pbr","ggx","mrp","noh","mostrepresentativepoint"],"hasliked":0,"parentid":"3dsBD4","parentname":"Area Lights"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":2,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\nCreative Commons CC0 1.0 Universal (CC-0)\nreal-time area light sources\nSee Buffer A for more details\n*/\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord)\n{\n    ivec2 p = ivec2(fragCoord);\n    vec3 c = TAA != 0 \n        ? texelFetch(iChannel1, p, 0).rgb // buffer B\n        : texelFetch(iChannel0, p, 0).rgb; // buffer A\n    c = pow(c, vec3(.4545)); // gamma OETF\n    c += exp2(-8.) * (texture(iChannel2, fragCoord / iChannelResolution[2].xy).b - .5); // bluenoise dither vs. color banding\n    fragColor = vec4(c, 1.);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"/*\nCC0 1.0\n*/\n\n// can switch temporal antialiasing on (1) or off (0) in which case it reverts to supersampling\n#define TAA 0\n// the TAA introduces minor artifacts which I didn't want to deal with\n\n/*\nfloat hash12(vec2 p)\n{\n    uint m = 1597334673u;\n\tuvec2 q = uvec2(ivec2(p)) * uvec2(m, 3812015801u);\n\tuint n = (q.x ^ q.y) * m;\n\treturn 1. / float(~0u) * float(n);\n}\n*/\n/*\nmat2 mrot(float ra)\n{\n    float c = cos(ra), s = sin(ra);\n\treturn mat2( c, -s,\n                 s,  c);\n}\n*/","name":"Common","description":"","type":"common"},{"inputs":[{"id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","previewfilepath":"/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"/*\nCreative Commons CC0 1.0 Universal (CC-0)  http://creativecommons.org/publicdomain/zero/1.0\n\nby spalmer http://shadertoy.com/view/lcjyzD\nfork of Area Lights by piyushslayer http://shadertoy.com/view/3dsBD4  (2020, 16449 total ch)\n\npiyushslayer had implemented 3 types of area light sources (sphere, line, and rectangle).\nBased on most representative point techniques by Brian Karis (Epic) and Sébastien Lagarde (Unity).\nCalculates the location of nearest point on light surface angularly to the reflection ray\nand use that for the light direction to calculate the diffuse and specular components.\n\nhttps://cdn2.unrealengine.com/Resources/files/2013SiggraphPresentationsNotes-26915738.pdf\nKaris fixed up Iñigo's sphere light, did tubes.  Lagarde added rect lights and disc lights.\nhttps://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf\n\nso far spalmer refactored bunch of stuff into shared areaLight function,\n and some other stuff (combining diffuse*albedo + specular) into the shapeLight functions\n so that it doesn't have to be done once per light source ad-hoc anymore.\nspalmer allowed each light to have its own color and sub-id, moved the brightnesses into a table of colors,\n discovered missing normalization factor from Karis' work,\n retuned the attenuation inverse distance squared falloff,\n clamped output (kind of a hack actually) to prevent specular from seeming too bright.\nTODO solve the overbrightness issue\nadded support for disc lights; seems to work.\n\nPlus, I had saved almost 5000 characters!  gave back 2000 implementing disc lights and bypassing computing H vector.\nThe TAA is currently disabled in Common, could save more by trimming Buffer B, or re-enable.\n\nTODO may try to implement roundbox lights  :)\n*/\n\n// enable/disable for floor normal map and roughness map\n#define FLOOR_BUMP\n//#define FLOOR_ROUGHNESS\n\n#define DRAW_LIGHTS\n\nconst int // perf / quality tuning\n    REFLECTION_TRACES = 8,\n    SOFTSHADOW_STEPS = 32,\n    RAYMARCH_STEPS = 128,\n    REFLECTION_STEPS = 32;\n\nvec2 oUnion(vec2 a, vec2 b)\n{\n \treturn a.x < b.x ? a : b;  \n}\n\nfloat dPlaneNoDisplacement(vec3 q, float h)\n{\n\treturn q.y - h;\n}\n\nfloat dPlane(vec3 q, float h)\n{\n\tfloat d = dPlaneNoDisplacement(q, h);\n  #ifdef FLOOR_BUMP\n    d -= textureLod(iChannel0, q.xz * .04, 0.).r * .01; // wood texture  \n  #endif\n    return d;\n}\n\nfloat dSphere(vec3 q, vec3 center, float radius)\n{\n\treturn length(q - center) - radius;   \n}\n\n\n#define saturate(x) clamp(x, 0., 1.)\n            \n#define sqr(x) dot(x, x)\n\n\nfloat dCapsule(vec3 q, vec3 end0, vec3 end1, float poof)\n{\n    q -= end0; vec3 e = end1 - end0;\n    float h = saturate(dot(q, e) / sqr(e));\n    return length(q - h * e) - poof;\n}\n\nfloat dRect(vec3 p, vec3 a, vec3 b, vec3 c, vec3 d)\n{\n    vec3 ba = b - a, pa = p - a,\n         cb = c - b, pb = p - b,\n         dc = d - c, pc = p - c,\n         ad = a - d, pd = p - d,\n        nor = cross(ba, ad);\n    return sqrt(\n        (sign(dot(cross(ba, nor), pa)) +\n         sign(dot(cross(cb, nor), pb)) +\n         sign(dot(cross(dc, nor), pc)) +\n         sign(dot(cross(ad, nor), pd)) < 3.)\n        ? min(min(min(\n                sqr(ba * clamp(dot(ba, pa) / sqr(ba), 0., 1.) - pa),\n                sqr(cb * clamp(dot(cb, pb) / sqr(cb), 0., 1.) - pb)),\n                sqr(dc * clamp(dot(dc, pc) / sqr(dc), 0., 1.) - pc)),\n                sqr(ad * clamp(dot(ad, pd) / sqr(ad), 0., 1.) - pd))\n        : dot(nor, pa) * dot(nor, pa) / sqr(nor) \n      );\n}\n// spalmer just hacked something together but it seems to be working; there's probably some slight optimizations to be had\nfloat dDisc(vec3 q, vec3 p, float r, vec3 d)\n{\n    p -= q;\n    float pd = dot(p, d);\n    return length(vec2(max(0.,  length(p - pd * d) - r), pd));\n}\n \nvec2 SceneSmooth(vec3 q)\n{\n    // ball id = 1. + fraction = roughness\n\tvec2 r =      vec2(dSphere(q, vec3(-4.5, .75, 0.), 1.5), 1.1);\n    r = oUnion(r, vec2(dSphere(q, vec3(-1.5, .75, 0.), 1.5), 1.3));\n    r = oUnion(r, vec2(dSphere(q, vec3( 1.5, .75, 0.), 1.5), 1.5));\n    r = oUnion(r, vec2(dSphere(q, vec3( 4.5, .75, 0.), 1.5), 1.7));\n    return r;\n}\n// wood floor id = 3\n// when computing discrete gradient, want extra details for bumpmaps\nvec2 SceneForGradient(vec3 q)\n{\n\treturn oUnion(SceneSmooth(q),\n        vec2(dPlane(q, -.75), 3.));\n}\n// most traces don't need bumpmap details\nvec2 SceneNoLights(vec3 q)\n{\n\treturn oUnion(SceneSmooth(q), \n        vec2(dPlaneNoDisplacement(q, -.75), 3.));\n}\n\nvec3 SceneGradient(vec3 q, float eps)\n{\n    vec2 ep = vec2(eps, 0.);\n    return vec3(SceneForGradient(q + ep.xyy).x, \n                SceneForGradient(q + ep.yxy).x, \n                SceneForGradient(q + ep.yyx).x) \n              - SceneForGradient(q         ).x; // / eps;\n}\n\n// animation key\n#define T (iTime * .25)\n\n#define SPHERE_LIGHT_POS \\\n    vec3(9. * cos(T), 6. * abs(sin(T)) - .75 + SPHERE_LIGHT_RADIUS, 1.)\n#define SPHERE_LIGHT_RADIUS (sin(.9*T) * .5 + .7)\n \n#define SPHERE_LIGHT2_POS vec3(0, 4, -20-2)\n#define SPHERE_LIGHT2_RADIUS 5.\n           \n#define LINE_LIGHT_RADIUS (sin(T) * .075 + .125)\n// interestingly, if it gets much smaller, it just breaks\n#define RECT_LIGHT_SIZE 1.5\n\n#define DISC_LIGHT_POS (sin(vec3(.9,1.,.8)*T) * vec3(7,2.,4) + vec3(-2,8,4))\n#define DISC_LIGHT_RADIUS ((sin(1.9*T) * .5 + .7) * 4.)\n#define DISC_LIGHT_DIR vec3(1,0,0) //0,-1,0) //0,0,-1) // should animate it rotating\n\nstruct Rect\n{\n\tvec3 center, a, b, c, d; \n\tvec3 up, right, front;\n    vec2 halfSize;\n};\n\n// animated globals\nvec3 lineStart, lineEnd;\nRect rect;\n\nvec2 Scene(vec3 q)\n{\n\tvec2 h = SceneNoLights(q);\n  #ifdef DRAW_LIGHTS\n    // all lights are id 0; using fraction now to indicate which light\n\th = oUnion(h, vec2(dSphere(q, SPHERE_LIGHT_POS, SPHERE_LIGHT_RADIUS), 0.0));    \n    h = oUnion(h, vec2(dCapsule(q, lineStart, lineEnd, LINE_LIGHT_RADIUS), 0.1));\n    //h = oUnion(h, vec2(dSphere(q, SPHERE_LIGHT2_POS, SPHERE_LIGHT2_RADIUS), 0.2));\n    h = oUnion(h, vec2(dRect(q, rect.a, rect.b, rect.c, rect.d), 0.3));\n    h = oUnion(h, vec2(dDisc(q, DISC_LIGHT_POS, DISC_LIGHT_RADIUS, DISC_LIGHT_DIR), 0.4));\n  #endif\n    return h;\n}\n\nvec3 calcNormal(vec3 q)\n{\n    return normalize(SceneGradient(q, .0002));\n}\n\nfloat D_TrowbridgeReitz(float c, float a) // without divide by pi\n{\n    float aa = a * a;\n\treturn aa / (sqr(sqr(c) * (aa - 1.) + 1.));\n    //return aa * pow(c * c * (aa - 1.) + 1., -2.);\n}\n// hard to find any actual reference for this, but Karis\n// just says they use alpha' *instead* of alpha.\n// I did see some reference to such modifications to TR, but can't recall where now.\n// it's not quite Disney GTR.\n// anyway I tried just using aPrime as alpha, that just doesn't work, unfortunately, way too wide lobes.\n// but I cannot see using this more complicated interface for TR,\n// when the modification may be accomplished by simply multiplying the above result by aPrime.\n// a = alpha = roughness²\n// aPrime is Karis' Specular D Modification stuff.\n// c is a cosine such as dot(N,H)\n/*float D_TrowbridgeReitz(float c, float a, float aPrime)\n{\n    float aa = a * a;\n    return aa * aPrime * pow(c * c * (aa - 1.) + 1., -2.);\n}*/\n// the divide by pi got moved/cancelled elsewhere, seems\n\n// Schlick approximation for Smith G half-factor\nfloat G_Schlick(float c, float k)\n{\n    return c / (c * (1. - k) + k);\n}\n    //const float SMOL_EPS = -1.; //.0000002; // just don't need it; roughness gets clamped elsewhere anyhow\n    //return c / max(c * (1. - k) + k, SMOL_EPS);\n\nfloat G_Smith(float nv, float nl, float rough)\n{\n \tfloat r1 = rough + 1.,\n        k = r1 * r1 / 8.; // divide by extra 2. for GGX\n    return G_Schlick(nv, k)\n         * G_Schlick(nl, k);\n}\n\n// Schlick's approximation for Fresnel equation\nvec3 F_Schlick(vec3 F0, float c)\n{\n    float rc5 = pow(max(0., 1. - c), 5.); // (1-c)^5\n    return F0 + (1. - F0) * rc5; //mix(F0, vec3(1), rc5); //\n}\n\n// used for IBL specular only; I'd prefer to use the one main BRDF if possible, I dislike the exp2 'optimization'\nvec2 PrefilteredDFG_Karis(float roughness, float nv)\n{\n    // Karis 2014, \"Physically Based Material on Mobile\"\n    // http://unrealengine.com/en-US/blog/physically-based-shading-on-mobile\n    const vec4 c0 = vec4(-1., -.0275,  -.572,  .022),\n               c1 = vec4( 1.,  .0425,  1.040, -.040);\n    vec4 r = roughness * c0 + c1;\n    float a004 = min(r.x * r.x, exp2(-9.28 * nv)) * r.x + r.y;\n    return vec2(-1.04, 1.04) * a004 + r.zw;\n}\n\n// the main BRDF is in specularCookTorrance/areaLight\nconst float\n    pi = radians(360.),\n    tau = pi + pi;\n\n// refactored in more traditional form:\nvec3 specularTorranceSparrowBRDF(float ra, float nl, float rl, float nh, float vh, float nv, \n            vec3 f0, float roughness, float aPrime,\n            out vec3 fresnel)\n{\n    float alpha = roughness * roughness; // aka a\n    fresnel = F_Schlick(f0, vh);\n    float s = aPrime * D_TrowbridgeReitz(nh, alpha) //D_TrowbridgeReitz(nh, alpha, aPrime) //D_TrowbridgeReitz(nh, aPrime) //\n        * G_Smith(nv, ra, roughness); // nl customizable here in this model; to use other G model, may need to recompute alternative vh somehow.\n    s /= pi * sqr(alpha); // Karis mentions, missing in parent fork; combined, these two factors seem to fix the 'dimmer with distance' problem\n    //s /= 4. * nl * nv; // FIXME missing - using traditional way jacks things up though, something else must be wrong somewhere (clamping?) should mostly just cancel out some factors in G\n    s /= sqr(2. * vh); // Hammon(GDC'17) did with VH, seems works out better.\n    return s * fresnel;\n}\n// caller can do aPrime normalization\n\nconst float\n    lightFalloff = 50.;\n    \n// TODO seems that, provided a few key measurements,\n// we could refactor all this in a far more general way.\n\n// like, if we had the 'distance to nearest point on light'\n// and, 'angle of ray vs. closest edge of light' \n// (some sine, clamp to 0 when aimed directly at the light source,\n// or a cosine, whichever) we could just compute some angular vs. distance falloffs\n// just multiply by softshadow to nearest point on light, and light color, afterward\n// multiply .a (diffuse response) by albedo (but isn't that related to f0?) and add .rgb (specular response)\n\n    // this aPrime seems to be key to Karis' area lighting trick:  Specular D Modification\nvec4 areaLight(float ra, float nl, float rl, float nh, float vh, float nv, \n            float d, vec3 f0, float roughness, float aPrime, // d = light distance\n            float normalizationPower, // factored out common power alpha/aPrime gets raised to (2 for sphere lights, 1 for tube lights, due to anisotropy)\n            out vec3 fresnel) // out fresnel used for computing diffuse, is only to satisfy prior interface sphereLight, lineLight, rectLight; TODO simplify interface, maybe pass in albedo/cdiff\n{\n    float alpha = roughness * roughness; // aka a\n    vec4 ret = vec4(specularTorranceSparrowBRDF(ra, nl, rl, nh, vh, nv, f0, roughness, aPrime, fresnel), nl);\n    // \"To derive an approximate normalization for the representative point operation we divide the new widened normalization factor by the original:\" --Karis\n    ret.rgb *= pow(alpha / aPrime, normalizationPower); //sqr(alpha / aPrime); // normalization factor mentioned by Karis.\n    // inverse squared falloff attenuation (for diffuse only?)\n    ret/*.a*/ *= 1. / (sqr(d / lightFalloff) + 1.); // the +1. may not even be correct but I like it\n    // FIXME clearly the above is missing some factor or other, since the reflected light for pure mirror\n    // winds up far brighter than the light when viewed directly.  I'll try to solve it eventually.\n    // seems should limit so it doesn't become too glossy somehow, clamping works for now.\n    //ret.rgb *= .25 / pi / pi / pi / pi; // HACK // one of the infinities involved didn't get cancelled/balanced out, or missing some 4 or pi factor.\n    // probably the F and D terms aren't balanced by G and vis denominator.  This is using stuff adapted from point/infinite directional light sources.\n    // we're supposed to at some point multiply by the solid angle, which may fix this infinity business.\n    // I'm unsure why I wound up needing to clamp spec to pi/2 (~ 1.57) instead of 1. to get it to match .. 1.5 works, can't tell difference\n    ret = clamp(ret, vec4(0.), vec4(vec3(.5), 1.) * pi); // HACK I'm tired of things getting brighter than the actual light color, I want to do something about it\n    // I suppose I can allow it to exceed 1.0 direct-viewed-color a little bit in cases where point is practically next to the light, when it would receive samples from multiple directions?\n    // it may be easier to solve this by hacking things the other way, by scaling the direct-viewed luminance brighter instead.\n    // but in my simple mind, a punctual light source as an area light should integrate to zero.\n    // sure, one could instead normalize the total power output for each source, by dividing by surface area somehow...\n    // then the total power might remain constant even if area goes to zero.  But I took a different approach.\n    return ret;\n}\n// the caller then combines diffuse with result lc and lf:\n//   c += cLite * (lc.a * (1. - lf) * cdiff + lc.rgb);\n\n    //float attenuation = 1. //nl * nv //sqr(vh) // // \n    //    ;\n    //ret/*.a*/ *= attenuation; // shadow\n// outputs fresnel for use by caller, which I should probably refactor somehow (this entire interface in fact)\n\n// http://shadertoy.com/view/XcXyDX\nvoid ShadingDots(float vl, inout float nv, inout float nl, out float nh, out float vh)\n{\n\tfloat vl1 = vl + 1.,\n        q = inversesqrt(vl1 + vl1);\n    vh = q * vl1;\n    nh = q * (nv + nl);\n    // only clamp *afterward* or won't match\n    //vl = max(vl, 0.); // unused actually\n    nv = max(nv, 2e-4); //0.);\n    nl = max(nl, 2e-4); //0.);\n    nh = max(nh, 2e-4); //0.);\n    vh = max(vh, 2e-4); //0.);\n}\n\nstruct Ray\n{\n    vec3 org, dir;\n};\n\n#define IZERO min(0, iFrame)\n\nconst float sEPS = .002;\n\nfloat softShadow(Ray ray)\n{\n \tfloat shadow = 1., dist = 0.;\n    for (int i = 0 + IZERO; i < SOFTSHADOW_STEPS; ++i)\n    {\n        vec2 result = SceneNoLights(dist * ray.dir + ray.org);\n        if (result.y > 0.)\n        {\n            // iq's soft shadows\n            shadow = min(shadow, .5 + .5 * 32. * result.x / dist);\n            if (shadow < 0.) break;\n            dist += clamp(result.x, .005, .5);\n        }\n    }\n    return saturate(shadow); //smoothstep(0., 1., max(shadow, 0.));\n}\n\n\n// p = hit pos, r = reflect dir, n = surf normal, v = view dir\n// nv = dot(n, v) just happens to have been computed already\n// f0 = perpendicular rgb spec response, material roughness, metalness\n\nvec3 sphereLight(vec3 center, float radius, // of light\n            vec3 p, vec3 r, \n            vec3 n, vec3 v, float nv, \n            vec3 f0, vec3 cdiff, float roughness)\n{\n    vec3 L = center - p,\n        centerToRay = dot(L, r) * r - L;\n    L += saturate(radius / length(centerToRay)) * centerToRay;\n    float lightDist = length(L);\n    vec3 l = normalize(L);\n    float vl = dot(v, l),\n        nl = dot(n, l),\n        nh,\n        vh;\n    ShadingDots(vl, nv, nl, nh, vh);\n\n    float attenuation = 1.; //nl * nv //sqr(vh) //\n\tattenuation *= softShadow(Ray(sEPS * n + p, l));\n    \n    float alpha = roughness * roughness; // aka a\n    // this aPrime seems to be key to Karis' area lighting trick:  Specular D Modification\n    float aPrime = saturate(alpha + radius / (2. * lightDist));\n    //aPrime = sqr(aPrime); // why?!  aha this is what was breaking zero-radius sphere lights -- seems better without it\n    vec3 fresnel;\n    vec4 lc = areaLight(nl, nl, dot(r,l), nh, vh, nv, lightDist, f0, roughness, aPrime, 2., fresnel);\n    return attenuation * (lc.a * (1. - fresnel) * cdiff + lc.rgb);\n}\n// returns attenuated specular in rgb and attenuation factor for diffuse, including shading and distance falloff, in a\n\n/* // experimenting; got pretty close\nvec3 snapSeg(vec3 q, vec3 end0, vec3 end1)\n{\n    q -= end0; vec3 e = end1 - end0;\n    float h = saturate(dot(q, e) / sqr(e));\n    return e * h + end0;\n}\n\nvec3 snapCapsule(vec3 q, vec3 end0, vec3 end1, float poof)\n{\n    q -= end0; vec3 e = end1 - end0;\n    float h = saturate(dot(q, e) / sqr(e));\n    e *= h;\n    return poof * normalize(q - e) + e + end0;\n}\n*/\n\nvec3 lineLight(vec3 end0, vec3 end1, float radius, // of light\n            vec3 p, vec3 r, \n            vec3 n, vec3 v, float nv, \n            vec3 f0, vec3 cdiff, float roughness)\n{\n    // according to Karis it's finding closest point on segment to ray, an alternative to Picott's smallest angle method\n    vec3 l0 = end0 - p, l1 = end1 - p, ld = l1 - l0;\n    float rl0 = dot(r, l0),\n          rld = dot(r, ld),\n         l0ld = dot(l0, ld),\n         ldld = dot(ld, ld);\n    float t = (rl0 * rld - l0ld) / (ldld - rld * rld + 2.); // index of most representative location on segment\n    // @Zavie mentions Karis had a + 2 in the denominator, I had overlooked.  parent fork didn't have it.  seems to help slightly.\n    vec3 L = saturate(t) * ld + l0; // most representative point on line segment\n    // can *almost* get away with just using the sphereLight function here, except it uses a different aPrime and ra and correctionFactor, shadow direction\n    //return sphereLight(L + p, radius, p, r, n, v, nv, f0, cdiff, roughness);\n    // point on tube based on radius, from pt on seg\n    vec3 centerToRay = dot(L, r) * r - L;\n    // closest point on light source relative query\n    L += saturate(radius / length(centerToRay)) * centerToRay;\n    float lightDist = length(L);\n    vec3 l = normalize(L);\n    float vl = dot(v, l),\n        nl = dot(n, l),\n        nh,\n        vh;\n    ShadingDots(vl, nv, nl, nh, vh);\n\n    float lenL0 = length(l0), lenL1 = length(l1),\n        nl0 = dot(n, l0) / (2. * lenL0),\n        nl1 = dot(n, l1) / (2. * lenL1);\n    // similar to NdotL but only used for specular correction, definitely not for diffuse lighting\n    float ra = (2. * saturate(nl0 + nl1)) / \n        \t (lenL0 * lenL1 + dot(l0, l1) + 2.);\n\n    float attenuation = 1.; //nl * nv; //\n\tattenuation *= softShadow(Ray(sEPS * n + p, normalize(l0 + ld * .5))); //l)); // use middle of tube to assess 'average' occlusion\n    \n    float alpha = roughness * roughness,\n        aPrime = saturate(alpha + (radius / (2. * lightDist)));\n    vec3 fresnel;  \n    vec4 lc = areaLight(ra, nl, dot(r,l), nh, vh, nv, lightDist, f0, roughness, aPrime, 1., fresnel);\n    return attenuation * (lc.a * (1. - fresnel) * cdiff + lc.rgb);\n}\n\n// Based on technique in EA's frostbite engine\nfloat rectSolidAngle(vec3 p, vec3 v0, vec3 v1, vec3 v2, vec3 v3)\n{\n    vec3 n0 = normalize(cross(v0, v1)),\n         n1 = normalize(cross(v1, v2)),\n         n2 = normalize(cross(v2, v3)),\n         n3 = normalize(cross(v3, v0));    \n    float g0 = acos(dot(-n0, n1)),\n\t      g1 = acos(dot(-n1, n2)),\n\t      g2 = acos(dot(-n2, n3)),\n\t      g3 = acos(dot(-n3, n0));    \n    return g0 + g1 + g2 + g3 - tau;\n}\n\nvec3 rayPlaneIntersect(Ray ray, Rect rct)\n{\n   return ray.org + ray.dir * (dot(rct.front, rct.center - ray.org)\n\t\t\t\t\t\t\t/  dot(rct.front, ray.dir));\n}\n\nvec3 rectLight(Rect rect,\n            vec3 p, vec3 r, \n            vec3 n, vec3 v, float nv, \n            vec3 f0, vec3 cdiff, float roughness)\n{\n \tvec3 ret = vec3(0);\n    \n    // facing side check -- good for spot lights, not for 'an actual glowing rectangle' which would be 2-sided\n    //float windingCheck = dot(cross(rect.right, rect.up), rect.center - p);\n    //if (windingCheck > 0.)\n    //    return ret;\n    \n    vec3 v0 = rect.a - p,\n         v1 = rect.b - p,\n         v2 = rect.c - p,\n         v3 = rect.d - p;\n    float solidAngle = rectSolidAngle(p, v0, v1, v2, v3),\n        ra = solidAngle * .2 * (\n            saturate(dot(normalize(v0), n)) +\n            saturate(dot(normalize(v1), n)) +\n            saturate(dot(normalize(v2), n)) +\n            saturate(dot(normalize(v3), n)) +\n            saturate(dot(normalize(rect.center - p), n)));    \n    ra = abs(ra); //-ra; // ???! backward?  was causing strange glitches around rough metal spheres\n    ra = min(ra, 1.); //saturate(ra); //ra = max(ra, 0.); //\n    // specular\n\tRay rectRay = Ray(p, r);\n    vec3 planePointCenter = rayPlaneIntersect(rectRay, rect) - rect.center;\n    // project point on the plane on which the rectangle lies\n    vec2 planePointProj = vec2(dot(planePointCenter, rect.right), \n                               dot(planePointCenter, rect.up));\n    // translate the point to the top-right quadrant of the rectangle, project it on\n    // the rectangle or its edge and translate back using sign of the original point.\n    vec2 c = min(abs(planePointProj), rect.halfSize) * sign(planePointProj);\n    vec3 L = rect.center + rect.right * c.x + rect.up * c.y - p;\n    float lightDist = length(L);\n    \n    vec3 l = normalize(L);\n    float vl = dot(v, l),\n        nl = dot(n, l),\n        nh,\n        vh;\n    ShadingDots(vl, nv, nl, nh, vh);\n    \n    float attenuation = softShadow(Ray(sEPS * sign(nl) * n + p, normalize(rect.center - p))); //l)); //1.; //\n    \n    float alpha = roughness * roughness;\n    float aPrime = saturate(alpha + 0. / (2. * lightDist)); // this rect has no thickness, so keep same aPrime as alpha\n    \n    vec3 fresnel;  \n    vec4 lc = areaLight(ra, nl, dot(r,l), nh, vh, nv, lightDist, f0, roughness, aPrime, 3., fresnel);\n\n    return attenuation * (lc.a * (1. - fresnel) * cdiff + lc.rgb);\n}\n\n\nvec3 snapDisc(vec3 q, vec3 dpos, float drad, vec3 ddir)\n{\n    vec3 to = q - dpos;\n    to -= dot(to, ddir) * ddir;\n    return saturate(drad / length(to + 1e-7)) * to + dpos;\n}\n\n// Lagarde does not use Most Representative Point method for disc lights!\n// So I'm trying something experimental.\n// sort of works; not sure that it's correct yet\nvec3 discLight(vec3 discpos, float discradius, vec3 discdir, \n            vec3 p, vec3 r, \n            vec3 n, vec3 v, float nv, \n            vec3 f0, vec3 cdiff, float roughness)\n{\n    //if (dot(p - discpos, discdir) < 0.) // backfacing - for spot lights\n    //    return vec3(0);\n    vec3 L = discpos - p,\n        centerToRay = dot(L, r) * r - L; // on ray near disc center\n    //centerToRay -= dot(centerToRay, discdir) * discdir;\n    //vec3 O = saturate(discradius / length(centerToRay + 1e-7)) * centerToRay;\n    //L += O; //O - dot(O, discdir) * discdir; // fine, this isn't quite right, done here, actually; kind of cosine-weighted.\n    // I think I should try the snap algorithm way and just guess at the alphaPrime: \n    L += snapDisc(centerToRay, vec3(0), discradius, discdir);\n    // no real horizon handling, just let shadowing handle it\n    float lightDist = length(L);\n    vec3 l = normalize(L);\n    float vl = dot(v, l),\n        nl = dot(n, l),\n        nh,\n        vh;\n    ShadingDots(vl, nv, nl, nh, vh);\n    \n    float ra = nl; // TEMP - not correcting for MRP yet\n    \n    float attenuation = softShadow(Ray(sEPS * sign(nl) * n + p, normalize(discpos - p))); //l)); //1.; //\n    \n    float alpha = roughness * roughness;\n    float aPrime = saturate(alpha + 0. / (2. * lightDist)); // disc has no thickness, so keep same aPrime as alpha? idk actually\n    vec3 fresnel;  \n    vec4 lc = areaLight(ra, nl, dot(r,l), nh, vh, nv, lightDist, f0, roughness, aPrime, 1., fresnel);\n    return attenuation * (lc.a * (1. - fresnel) * cdiff + lc.rgb);\n}\n\n// TODO maybe try general ellipsoid\n\nconst float mEPS = .001;\n\nvec2 rayMarch(Ray ray, float tmax, int iter)\n{\n\tfloat t = 0.;\n    vec2 h = vec2(-1.);\n    for (int i = iter; i-- > 0; )\n    {  \n        h = Scene(t * ray.dir + ray.org);\n        if (h.x < mEPS * t || t >= tmax) break;\n        t += h.x;\n    }\n    if (t >= tmax) h.y = -1.;\n    return vec2(t, h.y);\n}\n// exact same raymarcher, different scene\nvec2 rayMarchNoLights(Ray ray, float tmax, int iter)\n{\n\tfloat t = 0.;\n    vec2 h = vec2(-1.);\n    for (int i = iter; i-- > 0; )\n    {  \n        h = SceneNoLights(t * ray.dir + ray.org);\n        if (h.x < mEPS * t || t >= tmax) break;\n        t += h.x;\n    }\n    if (t >= tmax) h.y = -1.;\n    return vec2(t, h.y);\n}\n\n// spin v by radian angle around unit axis\nvec3 erot(vec3 v, vec3 ax, float ra)\n{\n    float c = cos(ra), s = sin(ra);\n    return c * v + s * cross(ax, v) + (1. - c) * dot(ax, v) * ax;\n}\n\n// TODO material parameters from id\n\nvec3 shadeSurface(Ray ray, vec2 hit)\n{\n    vec3 col = vec3(0);\n    if (hit.y >= 0.) // check id\n    {\n        const vec3 \n            SPHERE_ALBEDO = vec3(.2, .01, .6),\n            SILVER_F0 = vec3(.95, .93, .88),\n            PLASTIC_F0 = vec3(.05);\n\n        const vec3 cLight[] = vec3[] (\n            5. * vec3(2,2,2), //0,1,0), //\n            5. * vec3(0,2,1), //.1,3,.1), //3,2,1), //\n            0. * .5 * vec3(1,1,0),\n            2. * vec3(.5,.1,0),\n            1. * vec3(1,.0,.0)\n        );\n\n        vec3 pos = hit.x * ray.dir + ray.org,\n            normal = calcNormal(pos),\n            viewDir = -ray.dir,\n            reflectDir = reflect(ray.dir, normal),\n            albedo = SPHERE_ALBEDO,\n            reflectance = SILVER_F0;\n\n        Ray reflectRay = Ray(pos, reflectDir); //, vec3(0));\n        float roughness = fract(hit.y), \n            metalness = 1.; //.88; //\n\n        // FIXME material switch happens 2 places in here, should refactor\n        if (hit.y >= 3.) // floor\n        {\n            albedo = pow(textureLod(iChannel0, pos.xz * .18, 0.).rgb, vec3(2.2)); // gamma EOTF\n          #ifdef FLOOR_ROUGHNESS\n            roughness = albedo.r * .5;\n          #else\n            roughness = .08;\n          #endif\n            metalness = .0;\n            reflectance = PLASTIC_F0;\n        }\n        else if (hit.y < 1.)\n            return cLight[int(10. * fract(hit.y))];\n        \n        float nv = dot(normal, viewDir); //max(dot(normal, viewDir), 0.); // common to all lights - but don't clamp here?\n        vec3 F0 = mix(reflectance, albedo, metalness), // rgb spec response at perpendicular angle\n            cdiff = (1. - metalness) / pi * albedo;\n        // much refactored\n        col += cLight[0] * sphereLight(SPHERE_LIGHT_POS, SPHERE_LIGHT_RADIUS,\n                    pos, reflectDir, \n                    normal, viewDir, nv, \n                    F0, cdiff, roughness);\n        col += cLight[1] * lineLight(lineStart, lineEnd, LINE_LIGHT_RADIUS, \n                    pos, reflectDir, \n                    normal, viewDir, nv, \n                    F0, cdiff, roughness);\n        col += cLight[2] * sphereLight(SPHERE_LIGHT2_POS, SPHERE_LIGHT2_RADIUS,\n                    pos, reflectDir, \n                    normal, viewDir, nv, \n                    F0, cdiff, roughness);\n        col += cLight[3] * rectLight(rect, \n                    pos, reflectDir, \n                    normal, viewDir, nv, \n                    F0, cdiff, roughness);\n        col += cLight[4] * discLight(DISC_LIGHT_POS, DISC_LIGHT_RADIUS, DISC_LIGHT_DIR,\n                    pos, reflectDir, \n                    normal, viewDir, nv, \n                    F0, cdiff, roughness);\n        \n        //col += .025 * albedo; // global ambient\n        // TODO IBL cubemap - not main point of this toy\n        \n        // calculate glossy reflection + IBL\n        float alp = roughness * roughness;\n        vec3 indirectSpecular = .0 * vec3(.1125, .1875, .25) + .0 * reflectDir.y; // fake as little as possible\n        for (int i = REFLECTION_TRACES + IZERO; i-- > 0; )\n        {\n\t\t\tfloat pc = float(i) / float(REFLECTION_TRACES);\n            vec3 delta = erot(vec3(0, 1, 0), reflectDir, tau * pc);\n\t\t\treflectRay.dir = normalize(alp * delta + reflectDir);\n        \tvec2 hi = rayMarchNoLights(reflectRay, 10., REFLECTION_STEPS + IZERO);\n            // another material id switch\n            if (hi.y >= 3.)\n            { // wood floor\n                vec3 indirectPos = pos + hi.x * reflectRay.dir;\n                indirectSpecular += pow(textureLod(iChannel0, indirectPos.xz * .18, 0.).rgb, vec3(2.2)); // gamma srgb2lin EOTF\n            }  \n            else if (hi.y >= 1. && hi.y < 2.)\n                indirectSpecular += .4 * SPHERE_ALBEDO;\n        }\n        indirectSpecular /= float(REFLECTION_TRACES);\n        \n        vec2 dfg = PrefilteredDFG_Karis(roughness, nv);\n        vec3 specularColor = F0 * dfg.x + dfg.y;\n        vec3 ibl = indirectSpecular * specularColor\n            //+ Irradiance_SphericalHarmonics(normal) * PI_INV * albedo // TODO maybe do cubemap IBL instead\n            ;\n        // HACK the reflection+IBL lighting is basically ambient reflections\n        // from the lights, of mostly the table, but gives impression of nearby objects\n        col += ibl * .5; // ambient (why .5?)\n    }   \n    // dim brown fog\n    return mix(.1 * vec3(.01, .006, .004), col, exp2(-.1 * hit.x));\n}\n\nvec3 renderScene(Ray ray, float tfar)\n{\n    vec2 hit = rayMarch(ray, tfar, RAYMARCH_STEPS + IZERO);\n    return shadeSurface(ray, hit);\n}\n\nvoid initScene()\n{ // animate global state\n    float t = T; // macro for iTime animation\n    // set line light endpoints\n    vec3 lineRot = erot(vec3(2.95, 0, 0), vec3(0,0,1), t),\n        linePos = vec3(6. * sin(t), 3., 5.);\n    lineStart = linePos - lineRot;\n    lineEnd = linePos + lineRot;\n\t// set rect light parameters\n    rect.up = vec3(0, 0, 1);\n    rect.right = vec3(1, 0, 0);\n    rect.front = normalize(cross(rect.right, rect.up));\n    vec2 widthScale = vec2(cos(t), sin(t)) * .25 + .75;\n    rect.halfSize = vec2(2.5, 1.5) * widthScale * RECT_LIGHT_SIZE;    \n    rect.center = vec3(0., 6., sin(t) * 4. - 1.5);    \n    rect.a = rect.center + rect.halfSize.x * rect.right + rect.halfSize.y * rect.up;\n    rect.b = rect.center - rect.halfSize.x * rect.right + rect.halfSize.y * rect.up;\n    rect.c = rect.center - rect.halfSize.x * rect.right - rect.halfSize.y * rect.up;\n    rect.d = rect.center + rect.halfSize.x * rect.right - rect.halfSize.y * rect.up;\n}\n\nmat3 lookAt(vec3 origin, vec3 target)\n{\n    vec3 fw = normalize(target - origin),\n        rt = normalize(cross(fw, vec3(0, 1, 0))),\n        up = normalize(cross(rt, fw));\n    return mat3(rt, up, fw);\n}\n\nconst vec3 CAMERA_POS = vec3(0., 9., 21.),\n        CAMERA_TARGET = vec3(0, 1, 0);\nconst float CAMERA_FAR = 50.;\n\nRay getCameraRay(vec2 uv, float zoom)\n{\n    mat3 camera = lookAt(CAMERA_POS, CAMERA_TARGET);\n    vec3 dir = normalize(camera * vec3(uv, zoom));\n    return Ray(CAMERA_POS, dir);\n}\n\nvec3 tonemap(vec3 c)\n{\n    return asinh(c) / asinh(2.);\n}\n\nconst int SSAA = 2; // how many samples/pixel when supersampling\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord)\n{\n    vec2 R = iResolution.xy,\n        blueNz = float(TAA) * (texelFetch(iChannel1, (iFrame * ivec2(113, 127)) & 63, 0).rg - .5),\n        q = (2. * (fragCoord + blueNz) - R) / R.y;\n    initScene();\n    const float phi = sqrt(1.25) + .5;\n    int nss = (1-TAA) * (SSAA + 1) + 1;\n    vec3 c = vec3(0);\n    for (int ss = IZERO + nss; ss-- > 0; ) {\n        float j = (float(ss) + .5) / float(nss);\n        vec2 jit = float(1-TAA) * 1. / R.y * sqrt(j) * sin(vec2(.5 * pi, 0) + j * tau * phi) + q;\n        vec3 rc = renderScene(getCameraRay(jit, 2.5), CAMERA_FAR);\n        c += sqrt(tonemap(rc)); // accumulating tonemapped samples with gamma really helps, otherwise bright lights dominate and won't AA\n    }\n    c /= float(nss);\n    fragColor = vec4(c * c, 1.);\n}\n\n\n// see also:\n// Area Lights WIP: (SS10) by angelo12  http://shadertoy.com/view/ttGSW3\n// Light rod test by Zavie  http://shadertoy.com/view/XcdGRS\n// 3D Analytic Line Light Primitive by chronos  http://shadertoy.com/view/MfsGzS  is an independent derivation I should investigate\n// Simple Light Door by ParaBellum  http://shadertoy.com/view/tsKXzK\n// Approx Analytic Area Light by neoragex2002  http://shadertoy.com/view/4dVGDt\n// SDF Fake Area Light by XT95  http://shadertoy.com/view/llfBz7\n// and maybe search \"linearly transformed cosines\"\n// I haven't found iq's sphere light yet\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"/*\nCreative Commons CC0 1.0 Universal (CC-0)\n\nbasic TAA implementation based on variance clipping technique by Marco Salvi (Nvidia).\n*/\n// FIXME paying many ch for a disabled feature\n\n// I can't tell the difference this makes.  very small.\n//#if 0\n//vec3 RGBToYCoCg(vec3 RGB)\n//{\n//    float Y = dot(RGB, vec3(1, 2,  1))  * .25,\n//          Co= dot(RGB, vec3(2, 0, -2))  * .25 + (.5 * 256./255.),\n//          Cg= dot(RGB, vec3(-1, 2, -1)) * .25 + (.5 * 256./255.);\n//    return vec3(Y, Co, Cg) * (1. / (1. + Y)); // tonemap\n//}\n//\n//vec3 YCoCgToRGB(vec3 YCoCg)\n//{\n//    YCoCg *= 1. / (1. - YCoCg.x); // tonemap\n//\tfloat Y = YCoCg.x,\n//\t      Co = YCoCg.y - (.5 * 256. / 255.),\n//\t      Cg = YCoCg.z - (.5 * 256. / 255.),\n//\t      R = Y + Co - Cg,\n//\t      G = Y + Cg,\n//\t      B = Y - Co - Cg;\n//\treturn vec3(R, G, B);\n//}\n//#else\n#define RGBToYCoCg(c) (c)\n#define YCoCgToRGB(c) (c)\n//#endif\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord)\n{\n    if (TAA == 0) discard;\n    vec2 uv = fragCoord / iResolution.xy;\n    // not using mipmaps anyway\n    vec3 current = RGBToYCoCg(textureLod(iChannel0, uv, 0.).rgb), // buffer A\n         history = RGBToYCoCg(textureLod(iChannel1, uv, 0.).rgb), // buffer B\n        mean = current,\n        variance = current * current,\n        filtered = current * .25;\n    const ivec2 offsets[8u] = ivec2[]\n    (\n        ivec2(-1,-1), ivec2(-1, 1), \n        ivec2(1, -1), ivec2(1, 1), \n        ivec2(1, 0),  ivec2(0, -1), \n        ivec2(0, 1),  ivec2(-1, 0)\n    );\n    const float gaussian[8u] = float[]\n    (\n        .0625, .0625,\n        .0625, .0625,\n        .125,  .125,\n        .125,  .125\n    );\n    // Marco Salvi's Implementation (by Chris Wyman)\n    for (int i = 0; i < 8; ++i)\n    {\n        vec3 neighbor = RGBToYCoCg(texelFetch(iChannel0, ivec2(fragCoord) + offsets[i], 0).rgb);\n        mean += neighbor;\n        variance += neighbor * neighbor;\n        filtered += neighbor * gaussian[i];\n    }\n    mean /= 9.;\n    variance /= 9.;\n    const float stDev = 1.5;\n\tvec3 sigma = sqrt(abs(variance - mean * mean)),\n\t    colorMin = min(filtered, mean - stDev * sigma),\n\t    colorMax = max(filtered, mean + stDev * sigma);\n    history = clamp(history, colorMin, colorMax);\n    vec3 c = mix(history, filtered, .05);\n\tfragColor = vec4(YCoCgToRGB(c), 1.);\n}\n","name":"Buffer B","description":"","type":"buffer"}]}