{"ver":"0.1","info":{"id":"4sVBRw","date":"1528077922","viewed":237,"name":"De Rham Curves 4","username":"rory618","description":"Drawing the De Rham curves, this time out of line segments rendered with SR.","likes":11,"published":1,"flags":48,"usePreview":0,"tags":["2d","fractal","lines","stochastic","routing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Fork of \"Stochastic Routing\" by rory618. https://shadertoy.com/view/Xd3BW8\n// 2018-06-04 01:06:52\n\nvoid mainImage( out vec4 o, in vec2 i )\n{\n    \n    vec4 cSlider = processSliders(i,iChannel0,R);\n    Da=.5;\n    Db=1.;\n\tvec2 uv = i/R.xy;\n    o = texture(iChannel1,uv);\n    \n    o.xyz = mix(o.xyz,cSlider.rgb,cSlider.a);\n    o = max(o, texelFetch(iChannel0, ivec2(i),0));\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define R iResolution\n#define F iFrame\n#define T iTime\n#define iter 12\n#define scale 1.\n#define shift vec2(0)\n\n#define d0 mat3(1,0,0,0,Da,Dd,0,Db,De)\n#define d1 mat3(1,0,0,Da,1.-Da,Dl,Db,-Db,Dn)\nfloat Dd,De,Dl,Dn,Da,Db;\n\nvec2 DeRham(float t){\n    int f = int(t * float(2<<iter));\n    vec2 z = vec2(f&1,0);\n    f /= 2;\n    for(int i = 0; i < iter; i++){\n        \n        z=(vec3(1,z)*(1==(f&1)?d1:d0)).yz;\n    f /= 2;\n        \n    }\n    \n    return z;\n}\n\nvec4 processSliders(in vec2 fragCoord, sampler2D tex, vec3 R)\n{\n    vec4 sliderVal = texture(tex,vec2(0,0));\n\tDd  = (sliderVal[2]+sliderVal[0])*2.0-2.;\n\tDe  = (sliderVal[1]-sliderVal[3])*2.0;\n\tDl  = (sliderVal[2]-sliderVal[0])*2.0;\n\tDn  = (sliderVal[1]+sliderVal[3])*2.0-2.;\n    \n    if(length(fragCoord.xy-vec2(0,0))>1.)\n    {\n    \treturn texture(tex,fragCoord.xy/R.xy);\n    }\n    return vec4(0);\n}\n\nfloat particles = 1e3;\n\nfloat lineDist(vec2 z, vec2 a, vec2 b){\n    \n    z -= a; b -= a;                        // go to A referential\n    float q = dot(z, b) / dot(b, b) ;      // projection of P on line AB: normalized ordinate\n    b *= clamp(q, 0., 1.);                 // point on segment AB closest to P \n\n    \n    return length( z - b);\n}\n\nstruct line {\n    vec2 A;\n    vec2 B;\n    float w;\n    vec3 color;\n}; \n\nvec4 hash44(vec4 p4)\n{\n\tp4 = fract(p4  * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+19.19);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\n\n//Convert uniform random to normal\nvec2 randn(vec2 randuniform){\n    vec2 r = randuniform;\n    r.x = sqrt(-2.*log(r.x));\n    r.y *= 6.28318;\n    r = r.x*vec2(cos(r.y),sin(r.y));\n    return r;\n}\n\nline getLine(float id, vec3 R, float T){\n    //vec4 r1 = hash44(vec4(0,0,0,mod(id,50.)));\n    //vec4 r2 = hash44(vec4(0,0,0,id+floor(1.+r1.x*10.)));\n    return line(.25+.5*DeRham(id/float(2<<iter)),.25+.5*DeRham((id+1.)/float(2<<iter)),1.4,vec3(.5+.5*cos(4.+vec3(4,5,6)*id/float(2<<iter))));\n   // return line(.5+(randn(r1.zw)*R.y/4.)/R.xy, .5+(randn(r2.zw)*R.y/4.)/R.xy, 1., vec3(1));\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"/*\nThe idea behind stochastic routing is to route information to all relevant \ndestinations by passing everything through a series of layers, taking a stochastic\npath, such that the information gets closer and closer to the destination over \neach layer. For graphics, the destination is one of the pixels rendered in image,\nand the information is the parameters of an obect to be drawn. In this example, a \npoint is stored as a vec2 and rendered as a gaussian.\n\nEach layer of computation, stored in channels x,y,z,w of this buffer, randomly\nsamples 10 points stored in the previous layer. Only the one closest to the fragCoord\nis saved, this satisfies that information gets closer to the destination over \neach layer. This is why normal distributions with shrinking sigma over the layers \nis used.\n\nAn id tag is passed through the channel output, which enables using one buffer to\nget a lot of passes in by pipelining through xyzw. Even more than 4 passes would be \npossible by using only 16 bits or so to store the tag to get twice the passes.\n\nNear the latter layers, the id tags become closer in fragCoord space to the pixels \nthat the associeted particles will be affected, so the final rendering pass only needs\nto scan a few nearby locations in order to find every relevant particle.\n\n\n*/\nvoid mainImage( out vec4 o, in vec2 i )\n{\n    processSliders(i,iChannel0,R);\n    Da=.5;\n    Db=1.;\n    o = vec4(-1);\n    \n    \n    //Set the current best distance to infinity ish\n    float d=1e9;\n    for(int j = 0; j < 10; j++){\n        vec4 r = hash44(vec4(j,F,i));\n        float id = floor(r.x * float(2<<iter))+.5;\n        line l = getLine(id,R,T);\n        float dp = lineDist(i,R.xy*l.A,R.xy*l.B)-l.w;\n        //vec2 t = getParticle(id,R);//Uniformly sample one of the particles\n\n        //float dp = length(i-t*R.xy);\n        //compute the length to see if it is closer than the current champion\n        if(abs(dp)<abs(d)){\n            d = dp;\n            o.x = id;//Output the nearest points ID\n        }\n    }\n    //Repeat for each getParticle->x->y->z->w\n    d=1e9;\n    for(int j = 0; j < 10; j++){\n        vec4 r = hash44(vec4(j,F,i));\n        //Sample using a shrinking normal distribution\n        float id = texture(iChannel1,(i+randn(r.zw)*27.)/R.xy).x;\n        line l = getLine(id,R,T);\n        float dp = lineDist(i,R.xy*l.A,R.xy*l.B)-l.w;\n        \n        if(abs(dp)<abs(d)){\n            d = dp;\n            o.y = id;\n        }\n    }\n    \n    d=1e9;\n    for(int j = 0; j < 10; j++){\n        vec4 r = hash44(vec4(j,F,i));\n        float id = texture(iChannel1,(i+randn(r.zw)*9.)/R.xy).y;\n        line l = getLine(id,R,T);\n        float dp = lineDist(i,R.xy*l.A,R.xy*l.B)-l.w;\n        \n        if(abs(dp)<abs(d)){\n            d = dp;\n            o.z = id;\n        }\n    }\n    d=1e9;\n    \n    for(int j = 0; j < 10; j++){\n        vec4 r = hash44(vec4(j,F,i));\n        float id = texture(iChannel1,(i+randn(r.zw)*3.)/R.xy).z;\n        line l = getLine(id,R,T);\n        float dp = lineDist(i,R.xy*l.A,R.xy*l.B)-l.w;\n        \n        if(abs(dp)<abs(d)){\n            d = dp;\n            o.w = id;\n        }\n    }\n    \n}","name":"Buf A","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"//Buffer A : slider management (this is not required)\n\n#define saturate(x) clamp(x,0.0,1.0)\nvec4 sliderVal = vec4(0.625,0.375,.5,0.5); //Default slider values [0-1]\n\nvoid SLIDER_setValue(float idx, float val)\n{\n    if(idx<0.) return;\n    else if(idx<0.25) sliderVal[0] = saturate(val);\n\telse if(idx<0.50) sliderVal[1] = saturate(val);\n\telse if(idx<0.75) sliderVal[2] = saturate(val);\n\telse if(idx<1.00) sliderVal[3] = saturate(val);\n}\n\nfloat SLIDER_getValue(float idx)\n{\n    if     (idx<0.25) return sliderVal[0];\n    else if(idx<0.50) return sliderVal[1];\n    else if(idx<0.75) return sliderVal[2];\n    else if(idx<1.00) return sliderVal[3];\n\telse return 0.;\n}\n\nvoid SLIDER_init(vec2 mousePos, vec2 cMin, vec2 cMax )\n{\n    vec4 cPingPong = textureLod(iChannel0,vec2(0),0.0);\n    if(length(cPingPong)>0.001)\n        sliderVal = cPingPong;\n        \n    float width = cMax.x-cMin.x;\n    float height = cMax.y-cMin.y;\n    if(mousePos.x>cMin.x && mousePos.x<cMax.x &&\n       mousePos.y>cMin.y && mousePos.y<cMax.y )\n    {\n        float t = (mousePos.y-cMin.y)/height;\n        t = clamp(t/0.75-0.125,0.,1.); //25% top/bottom margins\n\t\tSLIDER_setValue((mousePos.x-cMin.x)/width, t);\n    }\n}\n\n//Returns the distance from point \"p\" to a given line segment defined by 2 points [a,b]\nfloat UTIL_distanceToLineSeg(vec2 p, vec2 a, vec2 b)\n{\n    //       p\n    //      /\n    //     /\n    //    a--e-------b\n    vec2 ap = p-a;\n    vec2 ab = b-a;\n    //Scalar projection of ap in the ab direction = dot(ap,ab)/|ab| : Amount of ap aligned towards ab\n    //Divided by |ab| again, it becomes normalized along ab length : dot(ap,ab)/(|ab||ab|) = dot(ap,ab)/dot(ab,ab)\n    //The clamp provides the line seg limits. e is therefore the \"capped orthogogal projection\", and length(p-e) is dist.\n    vec2 e = a+clamp(dot(ap,ab)/dot(ab,ab),0.0,1.0)*ab;\n    return length(p-e);\n}\n\n//uv = slider pixel in local space [0-1], t = slider value [0-1], ar = aspect ratio (w/h)\nvec4 SLIDER_drawSingle(vec2 uv, float t, vec2 ar, bool bHighlighted)\n{\n    const vec3  ITEM_COLOR = vec3(1);\n    const vec3  HIGHLIGHT_COLOR = vec3(0.2,0.7,0.8);\n    const float RAD = 0.05;  //Cursor radius, in local space\n    const float LW  = 0.030; //Line width\n    float aa  = 14./iResolution.x; //antialiasing width (smooth transition)\n    vec3 selectionColor = bHighlighted?HIGHLIGHT_COLOR:ITEM_COLOR;\n    vec3 cheapGloss   = 0.8*selectionColor+0.2*smoothstep(-aa,aa,uv.y-t-0.01+0.01*sin(uv.x*12.));\n    vec2 bottomCenter = vec2(0.5,0.0);\n\tvec2 topCenter    = vec2(0.5,1.0);\n    vec2 cursorPos    = vec2(0.5,t);\n    float distBar = UTIL_distanceToLineSeg(uv*ar, bottomCenter*ar, topCenter*ar);\n    float distCur = length((uv-cursorPos)*ar)-RAD;\n    float alphaBar = 1.0-smoothstep(2.0*LW-aa,2.0*LW+aa, distBar);\n    float alphaCur = 1.0-smoothstep(2.0*LW-aa,2.0*LW+aa, distCur);\n    vec4  colorBar = vec4(mix(   vec3(1),vec3(0),smoothstep(LW-aa,LW+aa, distBar)),alphaBar);\n    vec4  colorCur = vec4(mix(cheapGloss,vec3(0),smoothstep(LW-aa,LW+aa, distCur)),alphaCur);\n    return mix(colorBar,colorCur,colorCur.a);\n}\n\n#define withinUnitRect(a) (a.x>=0. && a.x<=1. && a.y>=0. && a.y<=1.0)\nvec4 SLIDER_drawAll(vec2 uv, vec2 cMin, vec2 cMax, vec2 muv)\n{\n    float width = cMax.x-cMin.x;\n    float height = cMax.y-cMin.y;\n    vec2 ar = vec2(0.30,1.0);\n    uv  = (uv -cMin)/vec2(width,height); //pixel Normalization\n    muv = (muv-cMin)/vec2(width,height); //mouse Normalization\n    if( withinUnitRect(uv) )\n    {\n        float t = SLIDER_getValue(uv.x);\n\t\tbool bHighlight = withinUnitRect(muv) && abs(floor(uv.x*4.0)-floor(muv.x*4.0))<0.01;\n\t\tuv.x = fract(uv.x*4.0); //repeat 4x\n\t\tuv.y = uv.y/0.75-0.125; //25% margins\n        return SLIDER_drawSingle(uv,t,ar,bHighlight);\n    }\n    return vec4(0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 cMinSliders = vec2(0.9,0.80);\n    vec2 cMaxSliders = vec2(1.0,1.00);\n    vec2 uvSliders = fragCoord.xy / iResolution.xy;\n    vec2 mousePos = iMouse.xy / iResolution.xy;\n    SLIDER_init(mousePos, cMinSliders, cMaxSliders);\n    vec4 cSlider = SLIDER_drawAll(uvSliders,cMinSliders, cMaxSliders, mousePos);\n\n    if(length(fragCoord.xy-vec2(0,0))<1.) \n        fragColor = sliderVal;\n\telse fragColor = cSlider;\n}","name":"Buf B","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"// Fork of \"Stochastic Routing\" by rory618. https://shadertoy.com/view/Xd3BW8\n// 2018-06-04 01:06:52\n\nvoid mainImage( out vec4 o, in vec2 i )\n{\n    \n    vec4 cSlider = processSliders(i,iChannel0,R);\n    Da=.5;\n    Db=1.;\n\tvec2 uv = i/R.xy;\n    o = vec4(0);\n    \n    for(int j = 0; j < 10; j++){//Rendering pass is just the last layer pass\n        \n        vec4 r = hash44(vec4(F,i,j));\n        r.zw = randn(r.zw);\n        float id = texture(iChannel1,(i+r.zw)/R.xy).w;\n\n\n            \n        if(id >= 0.){\n        \tline l = getLine(id,R,T);\n        \tfloat d = lineDist(i,R.xy*l.A,R.xy*l.B);\n            o = max(o,vec4(l.color,1)*clamp(l.w-d,0.,1.));\n        }\n        \n    }\n    o = mix(o,texture(iChannel2,uv),.9);\n}","name":"Buf C","description":"","type":"buffer"}]}