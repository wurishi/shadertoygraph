{"ver":"0.1","info":{"id":"DdBfzd","date":"1689999171","viewed":61,"name":"Pixel Fun: Circles in Chaos","username":"nllorcajr","description":"Basic Shape Series: Circle","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["basicshape"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Study exercise from iquilezles and trinketMage.\n// Basically same way of doing shapes, the same parameters, same goal, differentiated by chaos.\n\nfloat createCircle(vec2 uv, vec2 shapePosition, float size)\n{\n    float distance = length(shapePosition - uv) - size;\n\treturn 1.0 - clamp(distance, 0.0, 1.0);\n}\n\nfloat createCircle2(vec2 uv, vec2 shapePosition, float size)\n{\n    return step(distance(uv, shapePosition), size);\n}\n\nfloat colormap_red(float x) {\n    if (x < 0.0) {\n        return 54.0 / 255.0;\n    } else if (x < 20049.0 / 82979.0) {\n        return (829.79 * x + 54.51) / 255.0;\n    } else {\n        return 1.0;\n    }\n}\n\nfloat colormap_green(float x) {\n    if (x < 20049.0 / 82979.0) {\n        return 0.0;\n    } else if (x < 327013.0 / 810990.0) {\n        return (8546482679670.0 / 10875673217.0 * x - 2064961390770.0 / 10875673217.0) / 255.0;\n    } else if (x <= 1.0) {\n        return (103806720.0 / 483977.0 * x + 19607415.0 / 483977.0) / 255.0;\n    } else {\n        return 1.0;\n    }\n}\n\nfloat colormap_blue(float x) {\n    if (x < 0.0) {\n        return 54.0 / 255.0;\n    } else if (x < 7249.0 / 82979.0) {\n        return (829.79 * x + 54.51) / 255.0;\n    } else if (x < 20049.0 / 82979.0) {\n        return 127.0 / 255.0;\n    } else if (x < 327013.0 / 810990.0) {\n        return (792.02249341361393720147485376583 * x - 64.364790735602331034989206222672) / 255.0;\n    } else {\n        return 1.0;\n    }\n}\n\nvec4 colormap(float x) {\n    return vec4(colormap_red(x), colormap_green(x), colormap_blue(x), 1.0);\n}\n\n\nfloat rand(vec2 n) { \n    return fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\n\nfloat noise(vec2 p){\n    vec2 ip = floor(p);\n    vec2 u = fract(p);\n    u = u*u*(3.0-2.0*u);\n\n    float res = mix(\n        mix(rand(ip),rand(ip+vec2(1.0,0.0)),u.x),\n        mix(rand(ip+vec2(0.0,1.0)),rand(ip+vec2(1.0,1.0)),u.x),u.y);\n    return res*res;\n}\n\n// iquilezles!\nconst mat2 mtx = mat2( 0.80,  0.60, -0.60,  0.80 );\nfloat fbm( vec2 p )\n{\n    float f = 0.0;\n\n    f += 0.500000*noise( p + iTime  ); p = mtx*p*2.02;\n    f += 0.031250*noise( p ); p = mtx*p*2.01;\n    f += 0.250000*noise( p ); p = mtx*p*2.03;\n    f += 0.125000*noise( p ); p = mtx*p*2.01;\n    f += 0.062500*noise( p ); p = mtx*p*2.04;\n    f += 0.015625*noise( p + sin(iTime) );\n\n    return f/0.96875;\n}\n\nfloat pattern( in vec2 p )\n{\n\treturn fbm( p + fbm( p + fbm( p ) ) );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // POSITION_____________________________\n    \n   \tvec2 uv = fragCoord.xy;\n\tfloat radius = 0.21 * iResolution.y;\n    \n    // Upper Row  \n    vec2 centerPosition = vec2(iResolution.x * 0.5, iResolution.y * 0.75);\n    vec2 leftPosition = vec2(iResolution.x * 0.25, iResolution.y * 0.75);\n    vec2 rightPosition = vec2(iResolution.x * 0.75, iResolution.y * 0.75);\n    // Lower Row\n    vec2 centerPosition2 = vec2(iResolution.x * 0.5, iResolution.y * 0.25);\n    vec2 leftPosition2 = vec2(iResolution.x * 0.25, iResolution.y * 0.25);\n    vec2 rightPosition2 = vec2(iResolution.x * 0.75, iResolution.y * 0.25);\n    \n    // SHAPES_____________________________\n    \n    //float circle = createCircle(uv, center, radius * 1.1);\n    //basic shape!\n    //float circle0 = createCircle(uv, leftPosition, radius);\n    \n    float circle0 = createCircle(uv, leftPosition, fbm(uv * (cos(iTime * 0.5))) * radius * 1.5);\n    float circle1 = createCircle(uv, centerPosition, rand(uv * (cos(iTime * 0.5))) * radius);\n    float circle2 = createCircle2(uv, rightPosition, noise(uv * (cos(iTime * 0.15))) * radius);\n    \n    float circle3 = createCircle(uv, leftPosition2, noise(uv/(cos(iTime * 10.01))) * radius);\n    float circle4 = createCircle(uv, centerPosition2, noise(uv/abs(cos(iTime * 0.01))) * radius);\n    float circle5 = createCircle2(uv, rightPosition2, pattern(uv/abs(cos(iTime * 12334534120.021))) * radius * 1.5);\n    \n    // COLORS_____________________________\n    vec2 uvNormalized = fragCoord/iResolution.x;\n\tfloat shade = pattern(uvNormalized) * 4.;\n    vec4 fragsColor = vec4(colormap(shade).rgb, shade);\n        \n    // Dark background\n    vec3 backgroundColor =  vec3(0.000,0.000,0.000);\n    \n    // Time varying pixel color\n    vec3 debuGShape =  circle2 * abs(sin(iTime * 0.5) +  vec3(1.000,0.000,0.000));\n    \n    vec3 shape0 =  fragsColor.rgb * circle0 * vec3(1.000,0.000,0.000);\n    vec3 shape1 =  fragsColor.rgb * circle1 * vec3(1.000,0.933,0.000);\n    vec3 shape2 =  fragsColor.rgb * circle2 * vec3(0.000,1.000,0.882);\n    \n    vec3 shape3 =  fragsColor.rgb * circle3 * abs(sin(iTime * 2.5) +  vec3(1.000,0.400,0.000));\n    vec3 shape4 =  fragsColor.rgb * circle4 * vec3(1.000,0.000,0.635);\n    vec3 shape5 =  fragsColor.rgb * circle5 * vec3(0.451,0.000,1.000);\n    \n    // add these 2 colors\n    vec3 debug = debuGShape;\n    vec3 renderColor =  backgroundColor + shape0 + shape1 + shape2 + shape3 + shape4 + shape5;\n    \n    // RENDER_____________________________\n    fragColor = vec4(renderColor,1.0);\n}","name":"Image","description":"","type":"image"}]}