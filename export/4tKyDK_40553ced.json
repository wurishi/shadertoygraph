{"ver":"0.1","info":{"id":"4tKyDK","date":"1537794836","viewed":451,"name":"Heat diffusion (Gaussian blur)","username":"vchizhov","description":"You may have to reset the shader at the beginning. Hold LMB to blur.\nUsing finite differences to solve the heat pde: du/dt = d^2u/dx^2 + d^2u/dy^2\nAnalytically the solution is a convolution with a Gaussian, so ultimately we get Gaussian blur.","likes":5,"published":1,"flags":32,"usePreview":0,"tags":["gaussianblur","pde","heatdiffusion"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Output to screen\n    //fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    fragColor = texture(iChannel0, uv);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 invR = vec2(1.0) / iResolution.xy;\n    vec2 uv = fragCoord * invR;\n    vec3 c, e, w, s, n;\n    bool textureLoaded = iChannelResolution[1].x>0.0;\n    bool flagTextureNeedsUpdate = textureLoaded && texelFetch(iChannel0, ivec2(0), 0).a<0.5;\n    if(flagTextureNeedsUpdate)\n    {\n        c = texture(iChannel1, uv).xyz;\n        e = texture(iChannel1, uv+vec2(-1,0)*invR).xyz;\n        w = texture(iChannel1, uv+vec2(1,0)*invR).xyz;\n        n = texture(iChannel1, uv+vec2(0,1)*invR).xyz;\n        s = texture(iChannel1, uv+vec2(0,-1)*invR).xyz;\n    }\n    else\n    {\n        c = texture(iChannel0, uv).xyz;\n        e = texture(iChannel0, uv+vec2(-1,0)*invR).xyz;\n        w = texture(iChannel0, uv+vec2(1,0)*invR).xyz;\n        n = texture(iChannel0, uv+vec2(0,1)*invR).xyz;\n        s = texture(iChannel0, uv+vec2(0,-1)*invR).xyz;\n    }\n    \n    // forward difference for time:\n    // du/dt(x,y,t) = (u(x,y,t+tau) - u(x,y,t))/tau + O(tau)\n    // central differences for the derivatives with respect to x and y:\n    // d^2u/dx^2(x,y,t) = (u(x+delta,y,t) - 2*u(x,y,t) + u(x-delta,y,t))/delta^2 + O(delta^2)\n    // d^2u/dy^2(x,y,t) = (u(x,y+delta,t) - 2*u(x,y,t) + u(x,y-delta,t))/delta^2 + O(delta^2)\n    \n    // du/dt = d^2u/dx^2 + d^2u/dy^2 ~\n    // u(x,y,t+tau) - u(x,y,t))/tau = (u(x+delta,y,t) - 2*u(x,y,t) + u(x-delta,y,t))/delta^2\n    // + (u(x,y+delta,t) - 2*u(x,y,t) + u(x,y-delta,t))/delta^2\n    \n    // u(x,y,t+tau) = tau/delta^2 * ( u(x+delta,y,t) + u(x-delta,y,t) + u(x,y+delta,t) + u(x,y-delta,t)) \n    // (1-4*tau/delta^2) * u(x,y,t)\n    \n    // let delta = 1, c = u(x,y,t), e = u(x-delta,y,t), w = u(x+delta,y,t), n = u(x,y+delta,t), s = u(x,y-delta,t)\n    // c' = tau * ( e + w + n + s) + (1-4*tau)*c\n    // this is stable for (1-4*tau)>=0 -> tau <= 1/4\n    \n    \n    bool mouseDown = iMouse.z > 0.0;\n    float tau = 0.2;\n    vec3 color = mouseDown ? tau*(e+w+n+s - 4.0*c) + c : c;\n    fragColor = vec4(color,float(textureLoaded));\n}","name":"Buffer A","description":"","type":"buffer"}]}