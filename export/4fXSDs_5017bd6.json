{"ver":"0.1","info":{"id":"4fXSDs","date":"1707732481","viewed":27,"name":"[inspirnathan] 06 - uniqColors","username":"hrst4","description":"[inspirnathan] 06 - uniqColors","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["inspirnathan"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// This a french translation of the highly educational Nathan Vaughn's tutorials.\n// Un grand merci à lui !\n// his website: https://inspirnathan.com/\n// original:\n// from https://inspirnathan.com/posts/53-shadertoy-tutorial-part-7\n#define PART 6\n\n/*\nBonjour, chers amis ! Bienvenue dans la partie 7 de ma série de tutoriels Shadertoy.\nAjoutons un peu de couleur à notre scène 3D et apprenons comment ajouter plusieurs objets 3D à notre scène, comme un sol !\n\n# Dessiner plusieurs formes 3D\n\nDans le dernier tutoriel, nous avons appris à dessiner une sphère à l'aide de Shadertoy, \nmais notre scène n'était configurée que pour dessiner une seule forme.\n\nRestructurons notre code pour qu'une fonction appelée sdScene soit chargée de renvoyer la forme la plus proche dans notre scène.\n*/\n\n#if PART == 0\n\nconst int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float PRECISION = 0.001;\n\nfloat sdSphere(vec3 p, float r )\n{\n  vec3 offset = vec3(0, 0, -2);\n  return length(p - offset) - r;\n}\n\nfloat sdScene(vec3 p) {\n  return sdSphere(p, 1.);\n}\n\nfloat rayMarch(vec3 ro, vec3 rd, float start, float end) {\n  float depth = start;\n\n  for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n    vec3 p = ro + depth * rd;\n    float d = sdScene(p);\n    depth += d;\n    if (d < PRECISION || depth > end) break;\n  }\n\n  return depth;\n}\n\nvec3 calcNormal(in vec3 p) {\n    vec2 e = vec2(1.0, -1.0) * 0.0005; // epsilon\n    float r = 1.; // radius of sphere\n    return normalize(\n      e.xyy * sdScene(p + e.xyy) +\n      e.yyx * sdScene(p + e.yyx) +\n      e.yxy * sdScene(p + e.yxy) +\n      e.xxx * sdScene(p + e.xxx));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n  vec3 backgroundColor = vec3(0.835, 1, 1);\n\n  vec3 col = vec3(0);\n  vec3 ro = vec3(0, 0, 3); // ray origin that represents camera position\n  vec3 rd = normalize(vec3(uv, -1)); // ray direction\n\n  float d = rayMarch(ro, rd, MIN_DIST, MAX_DIST); // distance to sphere\n\n  if (d > MAX_DIST) {\n    col = backgroundColor; // ray didn't hit anything\n  } else {\n    vec3 p = ro + rd * d; // point on sphere we discovered from ray marching\n    vec3 normal = calcNormal(p);\n    vec3 lightPosition = vec3(2, 2, 7);\n    vec3 lightDirection = normalize(lightPosition - p);\n\n    // Calculate diffuse reflection by taking the dot product of \n    // the normal and the light direction.\n    float dif = clamp(dot(normal, lightDirection), 0.3, 1.);\n\n    // Multiply the diffuse reflection value by an orange color and add a bit\n    // of the background color to the sphere to blend it more with the background.\n    col = dif * vec3(1, 0.58, 0.29) + backgroundColor * .2;\n  }\n\n  // Output to screen\n  fragColor = vec4(col, 1.0);\n}\n\n/*\nRemarquez que chaque instance de sdSphere a été remplacée par sdScene. \nSi nous voulons ajouter d'autres objets à la scène, nous pouvons utiliser la fonction min pour obtenir \nl'objet le plus proche dans notre scène.\n\nfloat sdScene(vec3 p) {\n  float sphereLeft = sdSphere(p, 1.);\n  float sphereRight = sdSphere(p, 1.);\n  return min(sphereLeft, sphereRight);\n}\n\nActuellement, les sphères sont superposées. Ajoutons un paramètre de décalage à notre fonction sdSphere :\n\nfloat sdSphere(vec3 p, float r, vec3 offset )\n{\n  return length(p - offset) - r ;\n}\n\nEnsuite, nous pouvons ajouter des décalages à chacune de nos sphères :\n\nfloat sdScene(vec3 p) {\n  float sphereLeft = sdSphere(p, 1., vec3(-2.5, 0, -2));\n  float sphereRight = sdSphere(p, 1., vec3(2.5, 0, -2));\n  return min(sphereLeft, sphereRight);\n}\n\nLe code complété devrait ressembler à ce qui suit :\n\n\n*/\n\n#elif PART == 1\nconst int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float PRECISION = 0.001;\n\nfloat sdSphere(vec3 p, float r, vec3 offset )\n{\n  return length(p - offset) - r;\n}\n\nfloat sdScene(vec3 p) {\n  float sphereLeft = sdSphere(p, 1., vec3(-2.5, 0, -2));\n  float sphereRight = sdSphere(p, 1., vec3(2.5, 0, -2));\n  return min(sphereLeft, sphereRight);\n}\n\nfloat rayMarch(vec3 ro, vec3 rd, float start, float end) {\n  float depth = start;\n\n  for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n    vec3 p = ro + depth * rd;\n    float d = sdScene(p);\n    depth += d;\n    if (d < PRECISION || depth > end) break;\n  }\n\n  return depth;\n}\n\nvec3 calcNormal(in vec3 p) {\n    vec2 e = vec2(1.0, -1.0) * 0.0005; // epsilon\n    float r = 1.; // radius of sphere\n    return normalize(\n      e.xyy * sdScene(p + e.xyy) +\n      e.yyx * sdScene(p + e.yyx) +\n      e.yxy * sdScene(p + e.yxy) +\n      e.xxx * sdScene(p + e.xxx));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n  vec3 backgroundColor = vec3(0.835, 1, 1);\n\n  vec3 col = vec3(0);\n  vec3 ro = vec3(0, 0, 3); // ray origin that represents camera position\n  vec3 rd = normalize(vec3(uv, -1)); // ray direction\n\n  float d = rayMarch(ro, rd, MIN_DIST, MAX_DIST); // distance to sphere\n\n  if (d > MAX_DIST) {\n    col = backgroundColor; // ray didn't hit anything\n  } else {\n    vec3 p = ro + rd * d; // point on sphere we discovered from ray marching\n    vec3 normal = calcNormal(p);\n    vec3 lightPosition = vec3(2, 2, 7);\n    vec3 lightDirection = normalize(lightPosition - p);\n\n    // Calculate diffuse reflection by taking the dot product of \n    // the normal and the light direction.\n    float dif = clamp(dot(normal, lightDirection), 0.3, 1.);\n\n    // Multiply the diffuse reflection value by an orange color and add a bit\n    // of the background color to the sphere to blend it more with the background.\n    col = dif * vec3(1, 0.58, 0.29) + backgroundColor * .2;\n  }\n\n  // Output to screen\n  fragColor = vec4(col, 1.0);\n}\n\n/*\nAprès avoir exécuté notre code, nous devrions voir deux sphères orange légèrement éloignées l'une de l'autre.\nhttps://inspirnathan.com/_nuxt/img/img-1.7af01c9.png\n\n# Ajouter un sol\nNous pouvons ajouter un plancher qui se situera une unité en dessous de nos sphères grâce à la fonction suivante :\n\nfloat sdFloor(vec3 p) {\n  return p.y + 1.;\n}\n\nEn écrivant p.y + 1, cela revient à dire p.y - (-1), ce qui signifie que nous soustrayons un décalage du sol\net que nous le poussons vers le bas d'une unité.\n\nNous pouvons ensuite ajouter le sol à notre fonction sdScene en utilisant à nouveau la fonction min :\n\nfloat sdScene(vec3 p) {\n  float sphereLeft = sdSphere(p, 1., vec3(-2.5, 0, -2));\n  float sphereRight = sdSphere(p, 1., vec3(2.5, 0, -2));\n  float res = min(sphereLeft, sphereRight);\n  res = min(res, sdFloor(p));\n  return res;\n}\n\nLorsque nous exécutons notre code, le sol semble brun parce qu'il utilise \nla même couleur orange que les sphères et qu'il n'y a pas beaucoup de lumière qui frappe la surface du sol.\nhttps://inspirnathan.com/_nuxt/img/img-2.9b75860.png\n\n\n*/\n\n#elif PART == 2\nconst int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float PRECISION = 0.001;\n\nfloat sdFloor(vec3 p) {\n  p.y += sin(p.x*20.)*.1;\n  return p.y + 1.;\n}\n\n\nfloat sdSphere(vec3 p, float r, vec3 offset )\n{\n  return length(p - offset) - r;\n}\n\nfloat sdScene(vec3 p) {\n  float sphereLeft = sdSphere(p, 1., vec3(-2.5, 0, -2));\n  float sphereRight = sdSphere(p, 1., vec3(2.5, 0, -2));\n  float res = min(sphereLeft, sphereRight);\n  res = min(res, sdFloor(p));\n  return res;\n}\n\n\nfloat rayMarch(vec3 ro, vec3 rd, float start, float end) {\n  float depth = start;\n\n  for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n    vec3 p = ro + depth * rd;\n    float d = sdScene(p);\n    depth += d;\n    if (d < PRECISION || depth > end) break;\n  }\n\n  return depth;\n}\n\nvec3 calcNormal(in vec3 p) {\n    vec2 e = vec2(1.0, -1.0) * 0.0005; // epsilon\n    float r = 1.; // radius of sphere\n    return normalize(\n      e.xyy * sdScene(p + e.xyy) +\n      e.yyx * sdScene(p + e.yyx) +\n      e.yxy * sdScene(p + e.yxy) +\n      e.xxx * sdScene(p + e.xxx));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n  vec3 backgroundColor = vec3(0.835, 1, 1);\n\n  vec3 col = vec3(0);\n  vec3 ro = vec3(0, 0, 3); // ray origin that represents camera position\n  vec3 rd = normalize(vec3(uv, -1)); // ray direction\n\n  float d = rayMarch(ro, rd, MIN_DIST, MAX_DIST); // distance to sphere\n\n  if (d > MAX_DIST) {\n    col = backgroundColor; // ray didn't hit anything\n  } else {\n    vec3 p = ro + rd * d; // point on sphere we discovered from ray marching\n    vec3 normal = calcNormal(p);\n    vec3 lightPosition = vec3(2, 2, 7);\n    vec3 lightDirection = normalize(lightPosition - p);\n\n    // Calculate diffuse reflection by taking the dot product of \n    // the normal and the light direction.\n    float dif = clamp(dot(normal, lightDirection), 0.3, 1.);\n\n    // Multiply the diffuse reflection value by an orange color and add a bit\n    // of the background color to the sphere to blend it more with the background.\n    col = dif * vec3(1, 0.58, 0.29) + backgroundColor * .2;\n  }\n\n  // Output to screen\n  fragColor = vec4(col, 1.0);\n}\n\n/*\n# Ajout de couleurs uniques - Méthode 1\n\nIl existe plusieurs techniques utilisées par les utilisateurs de Shadertoy pour ajouter des couleurs aux formes 3D.\nL'une d'entre elles consisterait à modifier nos SDF pour qu'ils renvoient à la fois la distance à notre forme et\nune couleur. \n\nPar conséquent, nous devrions modifier plusieurs endroits de notre code pour renvoyer un type de données vec4 au \nlieu d'un float. \n\nLa première valeur de la variable vec4 contiendra la valeur de la \"distance signée\" que nous renvoyons normalement \nà partir d'un SDF, et les trois dernières valeurs contiendront notre valeur de couleur.\n\nLe code final devrait ressembler à ceci :\n\n*/\n\n#elif PART == 3\n\nconst int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float PRECISION = 0.001;\n\nvec4 sdSphere(vec3 p, float r, vec3 offset, vec3 col )\n{\n  float d = length(p - offset) - r;\n  return vec4(d, col);\n}\n\nvec4 sdFloor(vec3 p, vec3 col) {\n  float d = p.y + 1.;\n  return vec4(d, col);\n}\n\nvec4 minWithColor(vec4 obj1, vec4 obj2) {\n  if (obj2.x < obj1.x) return obj2; // The x component of the object holds the \"signed distance\" value\n  return obj1;\n}\n\nvec4 sdScene(vec3 p) {\n  vec4 sphereLeft = sdSphere(p, 1., vec3(-2.5, 0, -2), vec3(0, .8, .8));\n  vec4 sphereRight = sdSphere(p, 1., vec3(2.5, 0, -2), vec3(1, 0.58, 0.29));\n  vec4 co = minWithColor(sphereLeft, sphereRight); // co = closest object containing \"signed distance\" and color\n  co = minWithColor(co, sdFloor(p, vec3(0, 1, 0)));\n  return co;\n}\n\nvec4 rayMarch(vec3 ro, vec3 rd, float start, float end) {\n  float depth = start;\n  vec4 co; // closest object\n\n  for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n    vec3 p = ro + depth * rd;\n    co = sdScene(p);\n    depth += co.x;\n    if (co.x < PRECISION || depth > end) break;\n  }\n  \n  vec3 col = vec3(co.yzw);\n\n  return vec4(depth, col);\n}\n\nvec3 calcNormal(in vec3 p) {\n    vec2 e = vec2(1.0, -1.0) * 0.0005; // epsilon\n    return normalize(\n      e.xyy * sdScene(p + e.xyy).x +\n      e.yyx * sdScene(p + e.yyx).x +\n      e.yxy * sdScene(p + e.yxy).x +\n      e.xxx * sdScene(p + e.xxx).x);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n  vec3 backgroundColor = vec3(0.835, 1, 1);\n\n  vec3 col = vec3(0);\n  vec3 ro = vec3(0, 0, 3); // ray origin that represents camera position\n  vec3 rd = normalize(vec3(uv, -1)); // ray direction\n\n  vec4 co = rayMarch(ro, rd, MIN_DIST, MAX_DIST); // closest object\n\n  if (co.x > MAX_DIST) {\n    col = backgroundColor; // ray didn't hit anything\n  } else {\n    vec3 p = ro + rd * co.x; // point on sphere or floor we discovered from ray marching\n    vec3 normal = calcNormal(p);\n    vec3 lightPosition = vec3(2, 2, 7);\n    vec3 lightDirection = normalize(lightPosition - p);\n\n    // Calculate diffuse reflection by taking the dot product of \n    // the normal and the light direction.\n    float dif = clamp(dot(normal, lightDirection), 0.3, 1.);\n\n    // Multiply the diffuse reflection value by an orange color and add a bit\n    // of the background color to the sphere to blend it more with the background.\n    col = dif * co.yzw + backgroundColor * .2;\n  }\n\n  // Output to screen\n  fragColor = vec4(col, 1.0);\n}\n\n/*\nhttps://inspirnathan.com/_nuxt/img/img-3.7deaf05.png\n\nIl y a plusieurs endroits dans notre code où nous avons dû faire des ajustements pour satisfaire le compilateur. \nLa première chose que nous avons changée a été de modifier les SDF pour qu'ils renvoient une valeur vec4 \nau lieu d'une valeur float.\n\nvec4 sdSphere(vec3 p, float r, vec3 offset, vec3 col )\n{\n  float d = length(p - offset) - r;\n  return vec4(d, col);\n}\n\nvec4 sdFloor(vec3 p, vec3 col) {\n  float d = p.y + 1.;\n  return vec4(d, col);\n}\n\nCes deux fonctions acceptent désormais un nouveau paramètre pour la couleur.\nCependant, cela casse la fonction min que nous utilisions dans la fonction sdScene, \nnous avons donc dû la modifier également et créer notre propre fonction min.\n\n\nvec4 minWithColor(vec4 obj1, vec4 obj2) {\n  if (obj2.x < obj1.x) return obj2;\n  return obj1;\n}\n\nvec4 sdScene(vec3 p) {\n  vec4 sphereLeft = sdSphere(p, 1., vec3(-2.5, 0, -2), vec3(0, .8, .8));\n  vec4 sphereRight = sdSphere(p, 1., vec3(2.5, 0, -2), vec3(1, 0.58, 0.29));\n  vec4 co = minWithColor(sphereLeft, sphereRight); // co = closest object containing \"signed distance\" and color\n  co = minWithColor(co, sdFloor(p, vec3(0, 1, 0)));\n  return co;\n}\n\nLa fonction minWithColor effectue la même opération que la fonction min, \nsauf qu'elle renvoie un vec4 qui contient à la fois la valeur de la \"distance signée\" \net la couleur de l'objet le plus proche pendant la boucle de marche des rayons.\n\nEn parlant de marche des rayons, nous avons dû modifier notre fonction rayMarch pour satisfaire le compilateur.\n\nvec4 rayMarch(vec3 ro, vec3 rd, float start, float end) {\n  float depth = start;\n  vec4 co; // closest object\n\n  for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n    vec3 p = ro + depth * rd;\n    co = sdScene(p);\n    depth += co.x;\n    if (co.x < PRECISION || depth > end) break;\n  }\n  \n  vec3 col = vec3(co.yzw);\n\n  return vec4(depth, col);\n}\n\nNous avons également dû modifier la fonction calcNormal pour extraire la composante x \nde l'objet obtenu par la fonction sdScene :\n\nvec3 calcNormal(in vec3 p) {\n    vec2 e = vec2(1.0, -1.0) * 0.0005; // epsilon\n    return normalize(\n      e.xyy * sdScene(p + e.xyy).x +\n      e.yyx * sdScene(p + e.yyx).x +\n      e.yxy * sdScene(p + e.yxy).x +\n      e.xxx * sdScene(p + e.xxx).x);\n}\n\nEnfin, nous avons modifié la fonction mainImage pour qu'elle utilise également les changements.\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n  vec3 backgroundColor = vec3(0.835, 1, 1);\n\n  vec3 col = vec3(0);\n  vec3 ro = vec3(0, 0, 3); // ray origin that represents camera position\n  vec3 rd = normalize(vec3(uv, -1)); // ray direction\n\n  vec4 co = rayMarch(ro, rd, MIN_DIST, MAX_DIST); // closest object\n\n  if (co.x > MAX_DIST) {\n    col = backgroundColor; // ray didn't hit anything\n  } else {\n    vec3 p = ro + rd * co.x; // point on sphere or floor we discovered from ray marching\n    vec3 normal = calcNormal(p);\n    vec3 lightPosition = vec3(2, 2, 7);\n    vec3 lightDirection = normalize(lightPosition - p);\n\n    // Calculate diffuse reflection by taking the dot product of \n    // the normal and the light direction.\n    float dif = clamp(dot(normal, lightDirection), 0.3, 1.);\n\n    // Multiply the diffuse reflection value by an orange color and add a bit\n    // of the background color to the sphere to blend it more with the background.\n    col = dif * co.yzw + backgroundColor * .2;\n  }\n\n  // Output to screen\n  fragColor = vec4(col, 1.0);\n}\n\nNous extrayons la valeur de la \"distance signée\" à l'aide de col.x, et nous obtenons la couleur à l'aide de col.yzw.\n\nCette méthode permet de stocker des valeurs dans vec4 comme s'il s'agissait de tableaux dans d'autres langages.\nGLSL vous permet également d'utiliser des tableaux, mais ils ne sont pas aussi flexibles que des langages tels \nque JavaScript. Vous devez savoir combien de valeurs se trouvent dans les tableaux et vous ne pouvez \ny stocker que des valeurs du même type.\n\n*/\n\n/*\n# Ajouter des couleurs uniques - méthode 2\n\nSi l'utilisation de vec4 pour stocker à la fois la distance et la couleur semble être une mauvaise solution,\nune autre option serait d'utiliser des structures.\n\nLes structures sont un excellent moyen d'organiser votre code GLSL.\nLes structs sont définis de manière similaire à la syntaxe C++. \nSi vous n'êtes pas familier avec le C++ et que vous êtes plus familier avec JavaScript, \nvous pouvez considérer les structs comme une combinaison d'objets et de classes. Voyons ce que j'entends par là.\n\nUne structure peut avoir des propriétés. Créons une structure appelée \"Surface\".\n\nstruct Surface {\n  float signedDistance;\n  vec3 color;\n};\n\nVous pouvez créer des fonctions qui renvoient des structures \"Surface\" et vous pouvez créer de nouvelles \ninstances d'une structure :\n\n// This function's return value is of type \"Surface\"\nSurface sdSphere(vec3 p, float r, vec3 offset, vec3 col)\n{\n  float d = length(p - offset) - r;\n  return Surface(d, col); // We're initializing a new \"Surface\" struct here and then returning it\n}\n\nVous pouvez accéder aux propriétés de la structure en utilisant la syntaxe point :\n\nSurface minWithColor(Surface obj1, Surface obj2) {\n  if (obj2.sd < obj1.sd) return obj2 ; // La composante sd de la structure contient la valeur de la \"distance signée\".\n  return obj1 ;\n}\n\nGrâce à notre nouvelle connaissance des structures, nous pouvons modifier notre code pour utiliser des structures au lieu de vec4.\n\n*/\n\n#elif PART == 4\nconst int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float PRECISION = 0.001;\n\nstruct Surface {\n    float sd; // signed distance value\n    vec3 col; // color\n};\n\nSurface sdSphere(vec3 p, float r, vec3 offset, vec3 col)\n{\n  float d = length(p - offset) - r;\n  return Surface(d, col);\n}\n\nSurface sdFloor(vec3 p, vec3 col) {\n  float d = p.y + 1.;\n  return Surface(d, col);\n}\n\nSurface minWithColor(Surface obj1, Surface obj2) {\n  if (obj2.sd < obj1.sd) return obj2; // The sd component of the struct holds the \"signed distance\" value\n  return obj1;\n}\n\nSurface sdScene(vec3 p) {\n  Surface sphereLeft = sdSphere(p, 1., vec3(-2.5, 0, -2), vec3(0, .8, .8));\n  Surface sphereRight = sdSphere(p, 1., vec3(2.5, 0, -2), vec3(1, 0.58, 0.29));\n  Surface co = minWithColor(sphereLeft, sphereRight); // co = closest object containing \"signed distance\" and color\n  co = minWithColor(co, sdFloor(p, vec3(0, 1, 0)));\n  return co;\n}\n\nSurface rayMarch(vec3 ro, vec3 rd, float start, float end) {\n  float depth = start;\n  Surface co; // closest object\n\n  for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n    vec3 p = ro + depth * rd;\n    co = sdScene(p);\n    depth += co.sd;\n    if (co.sd < PRECISION || depth > end) break;\n  }\n  \n  co.sd = depth;\n  \n  return co;\n}\n\nvec3 calcNormal(in vec3 p) {\n    vec2 e = vec2(1.0, -1.0) * 0.0005; // epsilon\n    return normalize(\n      e.xyy * sdScene(p + e.xyy).sd +\n      e.yyx * sdScene(p + e.yyx).sd +\n      e.yxy * sdScene(p + e.yxy).sd +\n      e.xxx * sdScene(p + e.xxx).sd);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n  vec3 backgroundColor = vec3(0.835, 1, 1);\n\n  vec3 col = vec3(0);\n  vec3 ro = vec3(0, 0, 3); // ray origin that represents camera position\n  vec3 rd = normalize(vec3(uv, -1)); // ray direction\n\n  Surface co = rayMarch(ro, rd, MIN_DIST, MAX_DIST); // closest object\n\n  if (co.sd > MAX_DIST) {\n    col = backgroundColor; // ray didn't hit anything\n  } else {\n    vec3 p = ro + rd * co.sd; // point on sphere or floor we discovered from ray marching\n    vec3 normal = calcNormal(p);\n    vec3 lightPosition = vec3(2, 2, 7);\n    vec3 lightDirection = normalize(lightPosition - p);\n\n    // Calculate diffuse reflection by taking the dot product of \n    // the normal and the light direction.\n    float dif = clamp(dot(normal, lightDirection), 0.3, 1.);\n\n    // Multiply the diffuse reflection value by an orange color and add a bit\n    // of the background color to the sphere to blend it more with the background.\n    col = dif * co.col + backgroundColor * .2;\n  }\n\n  // Output to screen\n  fragColor = vec4(col, 1.0);\n}\n\n/*\nCe code devrait se comporter de la même manière que lorsque nous avons utilisé vec4 plus tôt.\nÀ mon avis, les structures sont plus faciles à raisonner et ont un aspect beaucoup plus propre. \nVous n'êtes pas non plus limité à quatre valeurs comme c'était le cas avec les vecteurs vec4. \nChoisissez l'approche que vous préférez.\n*/\n\n\n/*\n# Réalisation d'un sol carrelé (avec des patterns)\nSi vous souhaitez créer un sol carrelé fantaisie, vous pouvez ajuster la couleur du sol de la manière suivante :\n\nSurface sdScene(vec3 p) {\n  Surface sphereLeft = sdSphere(p, 1., vec3(-2.5, 0, -2), vec3(0, .8, .8));\n  Surface sphereRight = sdSphere(p, 1., vec3(2.5, 0, -2), vec3(1, 0.58, 0.29));\n  Surface co = minWithColor(sphereLeft, sphereRight);\n\n  vec3 floorColor = vec3(1. + 0.7*mod(floor(p.x) + floor(p.z), 2.0));\n  co = minWithColor(co, sdFloor(p, floorColor));\n  return co;\n}\n\nhttps://inspirnathan.com/_nuxt/img/img-4.e8ed1af.png\n\n\nLes sols carrelés aident les gens à visualiser la profondeur et font ressortir davantage vos scènes 3D. \nLa fonction mod est couramment utilisée pour créer des motifs en damier ou pour diviser une partie de la scène \nen morceaux répétables qui peuvent être colorés ou stylisés différemment.\n\n\n*/\n\n#elif PART == 5\nconst int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float PRECISION = 0.001;\n\nstruct Surface {\n    float sd; // signed distance value\n    vec3 col; // color\n};\n\nSurface sdSphere(vec3 p, float r, vec3 offset, vec3 col)\n{\n  float d = length(p - offset) - r;\n  return Surface(d, col);\n}\n\nSurface sdFloor(vec3 p, vec3 col) {\n  float d = p.y + 1.;\n  return Surface(d, col);\n}\n\nSurface minWithColor(Surface obj1, Surface obj2) {\n  if (obj2.sd < obj1.sd) return obj2; // The sd component of the struct holds the \"signed distance\" value\n  return obj1;\n}\n\nSurface sdScene(vec3 p) {\n  Surface sphereLeft = sdSphere(p, 1., vec3(-2.5, 0, -2), vec3(0, .8, .8));\n  Surface sphereRight = sdSphere(p, 1., vec3(2.5, 0, -2), vec3(1, 0.58, 0.29));\n  Surface co = minWithColor(sphereLeft, sphereRight);\n\n  vec3 floorColor = vec3(1. + 0.7*mod(floor(p.x) + floor(p.z), 2.0));\n  co = minWithColor(co, sdFloor(p, floorColor));\n  return co;\n}\n\nSurface rayMarch(vec3 ro, vec3 rd, float start, float end) {\n  float depth = start;\n  Surface co; // closest object\n\n  for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n    vec3 p = ro + depth * rd;\n    co = sdScene(p);\n    depth += co.sd;\n    if (co.sd < PRECISION || depth > end) break;\n  }\n  \n  co.sd = depth;\n  \n  return co;\n}\n\nvec3 calcNormal(in vec3 p) {\n    vec2 e = vec2(1.0, -1.0) * 0.0005; // epsilon\n    return normalize(\n      e.xyy * sdScene(p + e.xyy).sd +\n      e.yyx * sdScene(p + e.yyx).sd +\n      e.yxy * sdScene(p + e.yxy).sd +\n      e.xxx * sdScene(p + e.xxx).sd);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n  vec3 backgroundColor = vec3(0.835, 1, 1);\n\n  vec3 col = vec3(0);\n  vec3 ro = vec3(0, 0, 3); // ray origin that represents camera position\n  vec3 rd = normalize(vec3(uv, -1)); // ray direction\n\n  Surface co = rayMarch(ro, rd, MIN_DIST, MAX_DIST); // closest object\n\n  if (co.sd > MAX_DIST) {\n    col = backgroundColor; // ray didn't hit anything\n  } else {\n    vec3 p = ro + rd * co.sd; // point on sphere or floor we discovered from ray marching\n    vec3 normal = calcNormal(p);\n    vec3 lightPosition = vec3(2, 2, 7);\n    vec3 lightDirection = normalize(lightPosition - p);\n\n    // Calculate diffuse reflection by taking the dot product of \n    // the normal and the light direction.\n    float dif = clamp(dot(normal, lightDirection), 0.3, 1.);\n\n    // Multiply the diffuse reflection value by an orange color and add a bit\n    // of the background color to the sphere to blend it more with the background.\n    col = dif * co.col + backgroundColor * .2;\n  }\n\n  // Output to screen\n  fragColor = vec4(col, 1.0);\n}\n\n/*\n# Ajouter des couleurs uniques - méthode 3\n\nLorsque vous regardez des shaders sur Shadertoy, vous pouvez voir du code qui utilise des identifiants\nou ID pour colorer chaque objet unique de votre scène. \nIl est courant de voir des personnes utiliser une fonction map au lieu d'une fonction sdScene. \nVous pouvez également voir une fonction render utilisée pour assigner des couleurs à chaque objet\nen regardant l'ID de l'objet le plus proche renvoyé par l'algorithme de marche des rayons.\nVoyons à quoi ressemble le code en utilisant cette approche plus conventionnelle.\n\n*/\n\n#elif PART == 6\nconst int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float PRECISION = 0.001;\nconst vec3 COLOR_BACKGROUND = vec3(0.835, 1, 1);\n\nfloat sdSphere(vec3 p, float r)\n{\n  float d = length(p) - r;\n  return d;\n}\n\nfloat sdFloor(vec3 p) {\n  float d = p.y + 1.;\n  return d;\n}\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n  return (d1.x < d2.x) ? d1 : d2; // the x-component is the signed distance value\n}\n\nvec2 map(vec3 p) {\n  vec2 res = vec2(1e10, 0.); // ID = 0\n  vec2 flooring = vec2(sdFloor(p), 0.5); // ID = 0.5\n  vec2 sphereLeft = vec2(sdSphere(p - vec3(-2.5, 0, -2), 1.), 1.5); // ID = 1.5\n  vec2 sphereRight = vec2(sdSphere(p - vec3(2.5, 0, -2), 1.), 2.5); // ID = 2.5\n\n  res = opU(res, flooring);\n  res = opU(res, sphereLeft);\n  res = opU(res, sphereRight);\n  return res; // the y-component is the ID of the object hit by the ray\n}\n\nvec2 rayMarch(vec3 ro, vec3 rd) {\n  float depth = MIN_DIST;\n  vec2 res = vec2(0.0); // initialize result to zero for signed distance value and ID\n  float id = 0.;\n\n  for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n    vec3 p = ro + depth * rd;\n    res = map(p); // find resulting target hit by ray\n    depth += res.x;\n    id = res.y;\n    if (res.x < PRECISION || depth > MAX_DIST) break;\n  }\n  \n  return vec2(depth, id);\n}\n\nvec3 calcNormal(in vec3 p) {\n    vec2 e = vec2(1.0, -1.0) * 0.0005; // epsilon\n    return normalize(\n      e.xyy * map(p + e.xyy).x +\n      e.yyx * map(p + e.yyx).x +\n      e.yxy * map(p + e.yxy).x +\n      e.xxx * map(p + e.xxx).x);\n}\n\nvec3 render(vec3 ro, vec3 rd) {\n    vec3 col = COLOR_BACKGROUND;\n    \n    vec2 res = rayMarch(ro, rd);\n    float d = res.x; // signed distance value\n    if (d > MAX_DIST) return col; // render background color since ray hit nothing\n\n\tfloat id = res.y; // id of object\n    \n    vec3 p = ro + rd * d; // point on sphere or floor we discovered from ray marching\n    vec3 normal = calcNormal(p);\n    vec3 lightPosition = vec3(2, 2, 7);\n    vec3 lightDirection = normalize(lightPosition - p);\n\n    float dif = clamp(dot(normal, lightDirection), 0.3, 1.);\n\n    if (id > 0.) col = dif * vec3(1. + 0.7*mod(floor(p.x) + floor(p.z), 2.0));\n    if (id > 1.) col = dif * vec3(0, .8, .8);\n    if (id > 2.) col = dif * vec3(1, 0.58, 0.29);\n    \n    col += COLOR_BACKGROUND * 0.2; // add a bit of the background color to blend objects more with the scene\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n  vec3 ro = vec3(0, 0, 3); // ray origin that represents camera position\n  vec3 rd = normalize(vec3(uv, -1)); // ray direction\n  \n  vec3 col = render(ro, rd);\n\n  // Output to screen\n  fragColor = vec4(col, 1.0);\n}\n\n/*\nVous remarquerez que la fonction minWithColor s'appelle désormais opU, \nce qui signifie \"operation, union\", car il s'agit d'une opération d'union qui ajoute des formes à la scène.\nNous en apprendrons plus sur les opérations 3D SDF dans la partie 14 de ma série de tutoriels. \n\nLa fonction opU compare les valeurs de distance signées de deux objets pour voir lequel est le plus proche du rayon \npendant l'algorithme de marche des rayons.\n\nLa fonction map est utilisée pour ajouter ou \"mapper\" des objets à notre scène. \nNous utilisons un vec2 pour stocker une valeur de distance signée dans la composante x et un ID dans la composante y. \n\nVous verrez généralement une valeur fractionnaire utilisée pour l'ID. En effet, nous pouvons vérifier l'ID dans la\nfonction de rendu en regardant si cette valeur fractionnaire est supérieure à un nombre entier. \nVous vous demandez peut-être pourquoi nous n'utilisons pas des nombres entiers pour l'ID,\npuis un opérateur == pour vérifier si l'ID est égal à l'ID de l'objet le plus proche trouvé à partir de la marche des rayons.\n\nCela peut fonctionner pour vous et votre compilateur, mais pas pour tout le monde.\nL'utilisation de valeurs fractionnaires et d'une vérification supérieure à (>) garantit un rendu correct de la scène. \nLorsque vous utilisez des valeurs flottantes telles que 1. ou 2., vous pouvez rencontrer des problèmes étranges où \nid == 1. ou id == 2. ne se comportent pas comme vous l'auriez souhaité. \nEn vérifiant si id > 1. ou id > 2. lorsque l'ID est soit 0.5 soit 1.5, nous pouvons être sûrs que le code se comporte de manière prévisible pour tout le monde.\n\nIl est important de comprendre cette méthode pour ajouter des couleurs uniques à la scène car vous\nla verrez probablement utilisée par de nombreux développeurs de la communauté Shadertoy.\n\n# Conclusion\n\nDans cet article, nous avons appris à dessiner plusieurs objets 3D dans la scène et à donner \nà chacun d'eux une couleur unique. Nous avons appris trois techniques pour ajouter des couleurs \nà chaque objet de notre scène, mais il existe certainement d'autres approches ! \n\nUtilisez la méthode qui vous convient le mieux. Je trouve que travailler avec des structures donne à mon code \nune approche plus \"structurée\".\n\n*/\n#endif\n","name":"Image","description":"","type":"image"}]}