{"ver":"0.1","info":{"id":"NdBGDc","date":"1618009005","viewed":70,"name":"PBR sphere","username":"akoylasar","description":"Simple PBR rendering of a sphere as described in:\nhttps://learnopengl.com/PBR/Theory","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raytracing","pbr"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// 2021-2021 Fouad Valadbeigi (akoylasar@gmail.com).\n\n// Constants\n#define PI 3.1415926535\n#define TWO_PI 6.2831853071\n#define RADIANS PI / 180.\n#define WORLD_UP vec3(0.0, 1.0, 0.0)\n\nconst float cameraFov = 36. * RADIANS;\n\nstruct Ray \n{\n    vec3 ro;\n    vec3 rd;\n};\n\nfloat intersectSphere(vec4 sphere, Ray ray)\n{\n    vec3 oc = ray.ro - sphere.xyz;\n    float a = dot(ray.rd, ray.rd);\n    float b = 2.0 * dot(oc, ray.rd);\n    float c = dot(oc, oc) - sphere.w * sphere.w;\n    float d = b * b - 4.0 * a * c;\n    if (d < 0.0) return -1.0;\n    return (-b - sqrt(d)) / 2.0 * a;\n}\n\nRay getRay(vec2 fragCoord, vec3 origin, vec3 target) \n{\n    vec3 w = normalize(target - origin);\n    vec3 u = normalize(cross(w, WORLD_UP));\n    vec3 v = cross(u, w);\n    \n    vec2 p = 2.0 * (fragCoord / iResolution.xy) - 1.0;\n    \n    float aspect = iResolution.x / iResolution.y;\n    float s = tan(cameraFov * 0.5);\n    \n    p.x *= s * aspect; \n    p.y *= s;\n    \n    Ray ray;\n    ray.rd = normalize(w + p.x * u + p.y * v);\n    ray.ro = origin;\n    return ray;\n}\n\n// The next four functions are described in great details at:\n// https://learnopengl.com/PBR/Lighting\nvec3 fresnelSchlick(float cosTheta, vec3 F0)\n{\n    return F0 + (1.0 - F0) * pow(max(1.0 - cosTheta, 0.0), 5.0);\n}\n\nfloat DistributionGGX(vec3 N, vec3 H, float roughness)\n{\n    float a = roughness * roughness;\n    float a2 = a * a;\n    float NdotH = max(dot(N, H), 0.0);\n    float NdotH2 = NdotH * NdotH;\n\t\n    float num = a2;\n    float denom = (NdotH2 * (a2 - 1.0) + 1.0);\n    denom = PI * denom * denom;\n\t\n    return num / denom;\n}\n\nfloat GeometrySchlickGGX(float NdotV, float roughness)\n{\n    float r = (roughness + 1.0);\n    float k = (r * r) / 8.0;\n\n    float num = NdotV;\n    float denom = NdotV * (1.0 - k) + k;\n\t\n    return num / denom;\n}\n\nfloat GeometrySmith(vec3 N, vec3 V, vec3 L, float roughness)\n{\n    float NdotV = max(dot(N, V), 0.0);\n    float NdotL = max(dot(N, L), 0.0);\n    float ggx2 = GeometrySchlickGGX(NdotV, roughness);\n    float ggx1 = GeometrySchlickGGX(NdotL, roughness);\n\t\n    return ggx1 * ggx2;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{    \n    vec3 lightPos = vec3(0.0, 0.0, 2.0);\n    vec3 lightColor = vec3(2.5, 2.5, 2.5);\n    vec4 sphere = vec4(0.0, 0.0, 0.0, 1.0); // position, radius\n    vec3 cameraOrigin = vec3(0., 0., 5.0);\n    \n    Ray ray = getRay(fragCoord, cameraOrigin, vec3(0.0));\n    \n    vec3 albedo = vec3(0.0, 0.15, 0.9);\n    float metallic = 0.1;\n    float roughness = 0.8;\n    float ao = 1.0;\n\n    vec3 F0 = vec3(0.04); \n    F0 = mix(F0, albedo, metallic);\n    \n    vec3 Lo = vec3(0.0);\n    float t = intersectSphere(sphere, ray);\n    if (t > 0.0)\n    {\n        vec3 hitPos = ray.ro + t * ray.rd;\n        vec3 N = normalize(hitPos - sphere.xyz);\n        vec3 V = normalize(ray.ro - hitPos);\n        \n        vec3 L = normalize(lightPos - hitPos);\n        vec3 H = normalize(L + V);\n        \n        // Calculate light radiance\n        float lightDistance = length(lightPos - hitPos);\n        float attenuation = 1.0 / (lightDistance * lightDistance);\n        vec3 radiance = lightColor * attenuation;\n        \n        // Cook-Torrance BRDF\n        float NDF = DistributionGGX(N, H, roughness);        \n        float G = GeometrySmith(N, V, L, roughness);      \n        vec3 F = fresnelSchlick(max(dot(H, V), 0.0), F0); \n        \n        vec3 kS = F;\n        vec3 kD = vec3(1.0) - kS;\n        kD *= 1.0 - metallic;\n        \n        vec3 numerator = NDF * G * F;\n        float denominator = 4.0 * max(dot(N, V), 0.0) * max(dot(N, L), 0.0);\n        vec3 specular = numerator / max(denominator, 0.001); \n        \n        float NdotL = max(dot(N, L), 0.0);                \n        Lo += (kD * albedo / PI + specular) * radiance * NdotL;\n    }\n    \n    vec3 ambient = vec3(0.03) * albedo * ao;\n    vec3 color = ambient + Lo;\n    \n    // Tone-mapping\n    color = color / (vec3(1.0) + color);\n    // Gamma correction\n    color = pow(color, vec3(1.0 / 2.2));\n    \n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}