{"ver":"0.1","info":{"id":"ltK3zc","date":"1476126854","viewed":350,"name":"Vizu #4 - Lissajous (Ix)","username":"ttoinou","description":"FFT from https://www.shadertoy.com/view/XtVGDz \nLissajous curves drawn with segments and parabolas, animated on sound","likes":1,"published":1,"flags":96,"usePreview":0,"tags":["fft","music","bezier","curve","parametric","lissajou"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define dx (iMouse.x/iResolution.x)\n#define dy (iMouse.y/iResolution.y)\n#define TWOPI (6.28318530718)\n\n#define soundStep 1.0/iChannelResolution[0].y //1.0/512.0\n#define sound iChannel0\n\n// https://www.shadertoy.com/view/XtVGDz \n\nvec3 fft(float freq,float time){\n    return texture(sound,vec2(freq,time)).rgb;\n}\n\nvec3 segment(  vec2  p,\n               vec2  a,\n               vec2  b,\n               float d ){\n    float len = length(b-a);\n    \n    // avoids vertex overlap\n    float dd = d/(sqrt(2.0)*0.2);\n    //float D = d;\n    //float D = dd*exp(0.5-dd*dd);\n    float dhalf = 0.1;\n    float D = d < dhalf ? d*1.3 : smoothstep(0.,dhalf,2.*dhalf - d);\n    //float D = d < 0.1 ? d : 0.0;\n    //float D = d/dhalf*exp(- (1.0-d/dhalf)*(1.0-d/dhalf));\n    //if( D < len ){\n    \t//b = a+( ((b-a)/len)*max(len-D,0.) );\n    \t//len = length(b-a);\n    //}\n    /*\n    if( D < len ){\n    \tb = a+(b-a)/len*max(len-D,0.);\n    \tlen = length(b-a);\n    }*/\n    \n    float sx = (b.x - a.x);\n    float sy = (b.y - a.y);\n    vec2 r;\n    \n    if( sx == 0. && sy == 0. ){\n        r = vec2(length(p-a));\n        return vec3(1. - clamp(r.y/d,0.,1.),0.,0.0);\n    } else {\n    \tr = (mat2(sx,-sy,sy,sx))*(p-a)/len;\n    }\n    \n    r.y = (1.0 - smoothstep(0.0,1.0,abs(r.y)/(d)) )\n        * (smoothstep(0.,1., (r.x+d)/(d)) )\n        * (1.0 - smoothstep(0.,1., (r.x-len)/(d)) );\n    \n    r.x = clamp(r.x,0.0,len);\n    \n    return vec3( r.y\n                , r.x , r.x / len );\n}\n\nvec4 colorSegment(vec2  p,\n              \t  vec2  a,\n                  vec2  b,\n                  float d,\n                  vec4  color1,\n                  vec4  color2){\n    vec3 s = segment(p,a,b,d);\n    return pow(s.x,0.5)*mix(color1*color1.a,color2*color2.a,s.z);\n}\n\nconst float width = 1.1;\n\nvec2 viewport(vec2 p){\n    return vec2( (2.*p.x - iResolution.x)/ iResolution.y,\n                  2.*p.y                 / iResolution.y - 1.)*width;\n}\n\n// <https://www.shadertoy.com/view/XsX3zf>\n\nfloat det(vec2 a, vec2 b) { return a.x*b.y-b.x*a.y; }\n\nvec3 closestPointInSegment( vec2 a, vec2 b )\n{\n  vec2 ba = b - a;\n    float t = clamp( -dot(a,ba)/dot(ba,ba), 0.0, 1.0 );\n  return vec3(a + ba*t,t);\n}\n\n// From: http://research.microsoft.com/en-us/um/people/hoppe/ravg.pdf\nvec3 get_distance_vector(vec2 b0, vec2 b1, vec2 b2) {\n\t\n  float a=det(b0,b2), b=2.0*det(b1,b0), d=2.0*det(b2,b1); // ð›¼,ð›½,ð›¿(ð‘)\n  \n  if( abs(2.0*a+b+d) <  0.0001 ) return closestPointInSegment(b0,b2);\n\t\n  float f=b*d-a*a; // ð‘“(ð‘)\n  vec2 d21=b2-b1, d10=b1-b0, d20=b2-b0;\n  vec2 gf=2.0*(b*d21+d*d10+a*d20);\n  gf=vec2(gf.y,-gf.x); // âˆ‡ð‘“(ð‘)\n  vec2 pp=-f*gf/dot(gf,gf); // ð‘â€²\n  vec2 d0p=b0-pp; // ð‘â€² to origin\n  float ap=det(d0p,d20), bp=2.0*det(d10,d0p); // ð›¼,ð›½(ð‘â€²)\n  // (note that 2*ap+bp+dp=2*a+b+d=4*area(b0,b1,b2))\n  float t=clamp((ap+bp)/(2.0*a+b+d), 0.0 ,1.0); // ð‘¡Ì…\n  return vec3(mix(mix(b0,b1,t),mix(b1,b2,t),t),t); // ð‘£ð‘–= ð‘(ð‘¡Ì…)\n\n}\n\n// </https://www.shadertoy.com/view/XsX3zf>\n\nfloat bezier3(vec2 p, vec2 b0, vec2 b1, vec2 b2) {\n  return length(get_distance_vector(b0-p, b1-p, b2-p));\n}\n\nvec4 colorBezier3(vec2  p,\n              \t  vec2  a,\n                  vec2  b,\n                  vec2  c,\n                  float d,\n                  vec4  color1,\n                  vec4  color2){\n    vec3 B = get_distance_vector(a-p,b-p,c-p);\n    return exp(-(B.x*B.x + B.y*B.y)/(d*d)) * mix(color1*color1.a,color2*color2.a,B.z);\n}\n\n\nfloat repeat(float x,float y){\n    x = mod(x,2.0*y);\n    if( x > y ){\n        x = 2.0*y - x;\n    }\n    return x;\n    //return mod(x+y,y);\n}\n\nvoid mainImage( out vec4 o, in vec2 fragCoord )\n{\n    const int minpts = 31;\n    const int maxpts = 111;\n    \n    vec2 uv_ = fragCoord.xy/iResolution.xy;\n\t//vec2 uv = viewport(fragCoord)*2.*abs(1. - fft(uv_.x,0.0).b );\n\tvec2 uv = viewport(fragCoord)*2.*abs(1. - (fft(0.1,0.0)+fft(0.05,0.0)).b*0.4 );\n\t//vec2 uv = viewport(fragCoord);\n\n\n\t//o = vec4( (uv+1.0)/(2.0*width),0.0,1.0);\n\to = vec4(0.0,0.0,0.0,0.0);\n    \n    vec2 p1;\n    vec2 p3;\n    vec2 p2;\n    vec4 c1;\n    vec4 c2;\n    float di;\n    float lineThickness0 = 16./max(iResolution.x,iResolution.y);\n    float lineThickness;\n    \n    vec2 pcenter = 0.5*vec2(\n        cos(iTime*TWOPI/4.0),\n        sin(iTime*TWOPI/3.0)\n        );\n   \n    float pts = min(iTime/(6.5*60.0)*float(maxpts-minpts)+float(minpts),float(maxpts));\n    \n    for( int i = 0 ; i < maxpts ; i++ ){\n        if( float(i) <= pts ) {\n            di = float(i)/pts;\n            // curve\n            p2 = (vec2(\n                sin(di*(7.0+iTime/(60.0*6.5)*7.0)*TWOPI+iTime)+cos(di*3.0*TWOPI),\n                cos(di*5.0*TWOPI+sqrt(3.0)*iTime)\n            ));\n            // color scheme\n            c2 = clamp(vec4(\n                mix(0.5+0.5*cos(di*4.0*TWOPI-iTime/8.0),fft(repeat(di,1.),0.).r,0.4),\n                mix(0.5+0.5*cos(di*9.0*TWOPI-iTime/11.0),fft(repeat(di,1.),0.).g,0.3),\n                mix(0.5+0.5*cos(di*2.0*TWOPI-iTime/17.0),fft(repeat(di,1.),0.).b,0.2),\n                (0.7+0.3*cos(di*6.0*TWOPI+iTime*TWOPI/4.0))*pow(fft(repeat(di*2.,1.),0.0).b,1.5)*3.\n            ),0.,1.);\n            \n\n            if( i > 0 ){\n                //lineThickness = lineThickness0 + + 0.05*(1. + cos(iTime*3.14/7.0));\n                lineThickness = lineThickness0 + 0.1*(1. + cos(di*2.0*TWOPI))*fft(0.2,0.0).b;\n                o += (-.5 + 4.*fft(repeat(di*8.,1.),0.0).r )*colorSegment(uv,p1,p2,lineThickness,c1,c2);\n\n                p3 = mix(pcenter,0.5*(p1+p2),0.7-0.8*sin(iTime*TWOPI/30.0));\n                //p3 = mix(pcenter,0.5*(p1+p2),0.);\n                o += colorBezier3(uv,p1,p3,p2,lineThickness,c1,c2);\n            }\n\n            c1 = c2;\n            p1 = p2;\n        }\n    }\n    o /= pts/30.0;\n    #define lum (1.+(fft(0.1,0.0).b+fft(0.5,0.0).r)*5.)\n    o.r = tanh(o.r*lum);\n    o.g = tanh(o.g*lum);\n    o.b = tanh(o.b*lum);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"MsS3Rm","filepath":"https://soundcloud.com/stephanbodzin/ix?in=stephanbodzin/sets/powers-of-ten","previewfilepath":"https://soundcloud.com/stephanbodzin/ix?in=stephanbodzin/sets/powers-of-ten","type":"musicstream","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// https://www.shadertoy.com/view/XtVGDz\n\n#define buffer iChannel0\n#define sound  iChannel1\n#define soundRes iChannelResolution[1]\n#define step 1.0/iResolution.y\n#define inputSound iChannel0\n#define fftWidth \t\t1.0\t\t\t// width of fft texture (why not 512.0 ?! )\n#define fftMinBass \t\t0.00196 \t// 1.0/512.0\n#define fftSmoothTime   0.9\n\n#define render 0\n\n// fft Options\n#if render\n\n#define fftSmooth \t\t1.3\t\t\t// smoothness coeff\n#define fftPreamp\t\t0.65\t\t// pre amp before dynamic\n#define fftBoost  \t\t0.14\t\t// dynamic amp\n#define fftAmp\t\t\t0.46\t\t// pre amp before dynamic\n#define noiseLevel      0.1\n#define fftTrebles\t\t2.5\n#define fftBass\t\t\t1.0\n\n#else\n\n#define fftSmooth \t\t1.3\t\t\t// smoothness coeff\n#define fftPreamp\t\t0.65\t\t// pre amp before dynamic\n#define fftBoost  \t\t0.14\t\t// dynamic amp\n#define fftAmp\t\t\t0.6\t\t\t// pre amp before dynamic\n#define noiseLevel      0.05\n#define fftTrebles\t\t3.0\n#define fftBass\t\t\t1.6\n\n#endif\n\n#define fftRadiusR\t\t8.0/512.0\n#define fftRadiusG\t\tfftRadiusR*4.0\n#define fftRadiusB\t\tfftRadiusR*4.0*4.0\n#define fftSamplesR \t8 // number of iteration for fft sampling, increases quality !\n#define fftSamplesG \tfftSamplesR*4\n#define fftSamplesB \tfftSamplesR*4*4\n#define fftGBGain       1.1\n\n#define to01(x) clamp(x,0.0,1.0)\n\nfloat remapIntensity(float f, float i){\n  //return i;\n  // noise level\n  i = to01( (i - noiseLevel) / (1.0 - noiseLevel) );\n  float k = f-1.0;\n  i *= ( fftTrebles - fftBass*k*k ) * fftPreamp;\n  // more dynamic\n  i *= (i+fftBoost);\n    \n  return i*fftAmp;\n  // limiter, kills dynamic when too loud\n  //return 1.0 - 1.0 / ( i*4.0 + 1.0 );\n}\n\nfloat remapFreq(float freq){\n // linear scale\n //return clamp(freq,fftMinBass,1.0);\n // log scale\n return clamp(to01(- log(1.0-freq/1.65 + fftMinBass)),fftMinBass,1.0);\n}\n\nfloat fftR(float f){\n    float sum = 0.0;\n    float val = 0.0;\n    float coeff = 0.0;\n    float k = 0.0;\n    for( int i = 0; i < fftSamplesR ; i++ ){\n        k = float(i)/float(fftSamplesR-1)-0.5;\n        coeff = exp(-k*k/(fftSmooth*fftSmooth)*2.0);\n\t\tval += texture(sound, vec2( remapFreq(f + k * fftRadiusR)*fftWidth, 0.0) ).r * coeff;\n        sum += coeff;\n    }\n    return remapIntensity(f,val/sum);\n}\n\nfloat fftG(float f){\n    float sum = 0.0;\n    float val = 0.0;\n    float coeff = 0.0;\n    float k = 0.0;\n    for( int i = 0; i < fftSamplesG ; i++ ){\n        k = float(i)/float(fftSamplesG-1)-0.5;\n        coeff = exp(-k*k/(fftSmooth*fftSmooth)*2.0);\n\t\tval += texture(sound, vec2( remapFreq(f + k * fftRadiusG)*fftWidth, 0.0) ).r * coeff;\n        sum += coeff;\n    }\n    return remapIntensity(f,val/sum)*fftGBGain;\n}\n\nfloat fftB(float f){\n    float sum = 0.0;\n    float val = 0.0;\n    float coeff = 0.0;\n    float k = 0.0;\n    for( int i = 0; i < fftSamplesB ; i++ ){\n        k = float(i)/float(fftSamplesB-1)-0.5;\n        coeff = exp(-k*k/(fftSmooth*fftSmooth)*2.0);\n\t\tval += texture(sound, vec2( remapFreq(f + k * fftRadiusB)*fftWidth, 0.0) ).r * coeff;\n        sum += coeff;\n    }\n    return remapIntensity(f,val/sum)*fftGBGain*fftGBGain;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\n   \t// black by default\n    fragColor = vec4(0.0,0.0,0.0,1.0);\n\n     // iFrame == 0 => Reset\n    if( iFrame != 0 ){\n        // store current fft\n        if( fragCoord.y <= 1.0 ){\n            \n            float freq = uv.x;\n            float i1,i2,i3;\n\n            i1 = fftR(freq);\n            i2 = fftG(freq);\n            i3 = fftB(freq);\n\t\n            fragColor.rgb = vec3(i1,i2,i3);\n\n            #if render\n            vec3 mean = mix(fragColor.rgb,texture(buffer,vec2(uv.x,uv.y - step)).rgb,fftSmoothTime);\n            \n            /*if( length(mean) > length(fragColor.rgb) ){\n               fragColor.rgb = mean.rgb; \n            }\n            */\n            fragColor.rgb = max(fragColor.rgb,mean.rgb);\n            #endif\n            //fragColor.rgb = vec3(0.0);\n            fragColor.a = texture(sound,vec2(freq,1.0)).x;\n            \n        // store previous fft\n        } else if( fragCoord.y < iResolution.y - 1.0 ) {\n            fragColor=texture(buffer,vec2(uv.x,uv.y - step));\n        }\n    }\n}","name":"Buf A","description":"","type":"buffer"}]}