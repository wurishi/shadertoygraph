{"ver":"0.1","info":{"id":"7sVSzc","date":"1635074681","viewed":68,"name":"Interactive camping scene","username":"korompg","description":"WASD: Move camera.\nDrag LMB across the window: Rotate camera.\nC + W or S: Display the sdf visualization plane and move it around.\nHold LMB + Q: Shoot a visualized sphere trace ray.\nIf you like this, please leave a heart!","likes":1,"published":1,"flags":48,"usePreview":0,"tags":["raytracing","interactive","sdf","spheretracing","signeddistacefunction"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    fragColor = texelFetch(iChannel0,ivec2(fragCoord),0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":2,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// This file contains the \n// ---- SPHERE TRACING ----\n\nstruct Ray\n{\n\tvec3 P;\n\tfloat Tmin;\n\tvec3 V;\n\tfloat Tmax;\n    float visualization_plane_point_distance;\n};\n\nstruct TraceResult\n{\n    float T;\t\t// Distance taken on ray\n    int material_index;\n    float sdf;\n    int flags;\t\t// bit 0:   distance condition:     true if travelled to far t > t_max\n                    // bit 1:   surface condition:      true if distance to surface is small < error threshold\n};                  // bit 2:   iteration condition:    true if took too many iterations\n\n#define EPSILON 0.006\n#define MAX_ITERATIONS 102\n\nstruct SphereTraceDesc\n{\n    float epsilon;  //Stopping distance to surface\n    int maxiters;   //Maximum iteration count\n};\n\nstruct Plane{\n    vec3 position;\n    vec3 normal;\n};\n\n\nTraceResult calculate_visualization_spheres(in Ray visual_ray, in SphereTraceDesc params, out int number_of_spheres, out vec3 sphere_origins[MAX_ITERATIONS], out float sphere_radiuses[MAX_ITERATIONS]){\n    TraceResult visual_ray_trace_result = TraceResult(visual_ray.Tmin, 0, 0.0, 0);\n    float delta_t;\n    \n    int i = 0;\n    number_of_spheres = 0;\n    \n    do{\n        //The next point of the ray is the sphere's origin:\n        sphere_origins[i] = visual_ray.P + visual_ray_trace_result.T * visual_ray.V;\n        delta_t = sdf(sphere_origins[i], iTime).sdf;\n        //The next delta_t is the sphere's radius:\n        sphere_radiuses[i] = delta_t;\n        visual_ray_trace_result.T += sphere_radiuses[i];\n        ++number_of_spheres;\n        ++i;\n    } while (\n        visual_ray_trace_result.T < visual_ray.Tmax &&          // Stay within bound box\n\t\tdelta_t\t> params.epsilon * visual_ray_trace_result.T &&\t// Stop if cone is close to surface\n\t\ti < params.maxiters\t                                    // Stop if too many iterations\n\t);\n    \n    visual_ray_trace_result.flags = int(visual_ray_trace_result.T >= visual_ray.Tmax)\n              | (int(delta_t <= params.epsilon* visual_ray_trace_result.T)  << 1)\n              | (int(i >= params.maxiters) << 2);\n    \n    return visual_ray_trace_result;\n}\n\nTraceResult view_sphere_trace(in Ray view_ray, in SphereTraceDesc params){\n    TraceResult result = TraceResult(view_ray.Tmin, 0, 0.0, 0);\n    float delta_t;\n    \n    int i = 0; do\n    {\n        Value surface = sdf(view_ray.P + result.T * view_ray.V, iTime);\n        delta_t = surface.sdf;\n        result.T+=delta_t;\n        result.material_index = surface.material_index;\n        ++i;\n    } while (\n\t\tresult.T < view_ray.Tmax &&       \t    // Stay within bound box\n\t\tdelta_t\t > params.epsilon * result.T &&\t// Stop if cone is close to surface\n\t\ti        < params.maxiters\t        \t// Stop if too many iterations\n\t);\n    \n    result.flags =  int(result.T >= view_ray.Tmax)\n              | (int(delta_t  <= params.epsilon* result.T)  << 1)\n              | (int(i >= params.maxiters) << 2);\n\n    return result;\n}\n\nTraceResult visualize_sphere_trace(in Ray view_ray, in SphereTraceDesc params, in Ray visual_ray, in int number_of_spheres, in vec3 sphere_origins[MAX_ITERATIONS], in float sphere_radiuses[MAX_ITERATIONS]){\n    //Now we sphere only trace the visualization spheres and not the sdf scene:\n    TraceResult view_ray_trace_result = TraceResult(view_ray.Tmin, 0, 0.0, 0);\n    float delta_t;\n    \n    int i = 0; do{\n        vec3 viewpoint = view_ray.P + view_ray_trace_result.T * view_ray.V;\n        \n        //We start the comparison from the middle of the array:\n        int current_index = number_of_spheres/2; \n        vec3 closest_sphere_origin = sphere_origins[current_index];\n        float closest_sphere_radius = sphere_radiuses[current_index];\n        \n        //If the closer spheres start from a smaller index, we iterate to the left:\n        if(current_index > 1 && (distance(viewpoint, sphere_origins[current_index-1]) - sphere_radiuses[current_index-1]) < (distance(viewpoint, sphere_origins[current_index]) - sphere_radiuses[current_index])){\n            //If we find a new closest sphere, we update the starting index:\n            current_index--;\n            closest_sphere_origin = sphere_origins[current_index];\n            closest_sphere_radius = sphere_radiuses[current_index];\n            if(current_index > 0 ){\n                for(int j = current_index - 1; j >= 0; j--){\n                    if( (distance(viewpoint, sphere_origins[j]) - sphere_radiuses[j]) < (distance(viewpoint, closest_sphere_origin) - closest_sphere_radius) ){\n                        closest_sphere_origin = sphere_origins[j];\n                        closest_sphere_radius = sphere_radiuses[j];\n                    }\n                }\n            }\n        //Otherwise to the left:\n        } else {\n            for(int j = current_index + 1; j < number_of_spheres; j++){\n                if( (distance(viewpoint, sphere_origins[j]) - sphere_radiuses[j]) < (distance(viewpoint, closest_sphere_origin) - closest_sphere_radius) ){\n                    closest_sphere_origin = sphere_origins[j];\n                    closest_sphere_radius = sphere_radiuses[j];\n                }\n            }\n        }\n        //Conclusion: Starting the search from the middle of the array saves plenty of iterations. \n        delta_t = distance(viewpoint, closest_sphere_origin) - closest_sphere_radius;\n        view_ray_trace_result.T += delta_t;\n        ++i;\n    } while (\n        view_ray_trace_result.T < view_ray.Tmax &&            // Stay within bound box\n\t\tdelta_t\t> params.epsilon * view_ray_trace_result.T && // Stop if cone is close to surface\n\t\ti       < params.maxiters\t        \t              // Stop if too many iterations\n\t);\n    \n    view_ray_trace_result.flags =  int(view_ray_trace_result.T >= view_ray.Tmax)\n              | (int(delta_t <= params.epsilon * view_ray_trace_result.T)  << 1)\n              | (int(i       >= params.maxiters) << 2);\n              \n    return view_ray_trace_result;\n}\n\n// ---- SHADING ---- (todo!)\n\nvec3 normal(const in vec3 p)\n{\n    const float eps=0.001;\n    vec3 plus = vec3(sdf(p+vec3(eps,0,0), 0.).sdf,sdf(p+vec3(0,eps,0), 0.).sdf,sdf(p+vec3(0,0,eps), 0.).sdf);\n    vec3 minu = vec3(sdf(p-vec3(eps,0,0), 0.).sdf,sdf(p-vec3(0,eps,0), 0.).sdf,sdf(p-vec3(0,0,eps), 0.).sdf);\n    return normalize(plus-minu);\n}\n\nvec4 missColor(Ray ray)\n{\n    return vec4(texture(iChannel2, ray.V).xyz,1.);\n}\n\nvec4 errorColor(Ray ray, float t)\n{\n    return vec4(1.,0.,0.,1.);\n}\n\nvec3 calculate_scene_surface_color(vec3 surface_point, int material_index, int light_source_index, vec3 eye_position) \n{\n\tMaterial material = materials[material_index];\n    PointLightSource light = point_light_sources[light_source_index];\n    if(light_source_index == 2) light.brightness = 0.5 * abs(cos(iTime)) + 1.5;\n    \n    // ambient\n\tvec3 ambient_color = light.ambient_color * material.emission;\n\n\t// diffuse\n    vec3 surface_normal = normal(surface_point);\n\tvec3 to_light = normalize(light.position - surface_point);\n    float costheta_to_light = clamp(dot(to_light, surface_normal), 0.0, 1.0);\n    \n\tvec3 diffuse_color = light.diffuse_color * material.color * costheta_to_light;\n\n\t// specular\n\tvec3 specular_color = vec3(0);\n\n\tif (costheta_to_light > 0.0)\n\t{\n\t\tvec3 to_eye = normalize(eye_position - surface_point);\n\t\tvec3 reflected_light = reflect(-to_light, surface_normal);\n\t\tfloat shine = pow(clamp(dot(to_eye, reflected_light), 0.0f, 1.0f), 25.0);\n\t\tspecular_color = light.specular_color * material.metalness * shine;\n\t}\n\n\t// falloff for point light\n\tfloat distance = distance(light.position, surface_point);\n\tfloat falloff = light.brightness / distance / distance;\n\n\treturn ambient_color + falloff * (diffuse_color + specular_color);\n}\n\nvec4 scene_hitColor(Ray ray, float t, int material_index)\n{\n    vec3 surface_point = ray.P + ray.V*t;\n    vec3 eye_position = ray.P;\n    \n    vec3 scene_surface_color = vec3(0);\n    for(int light_source_index = 0; light_source_index<=2; light_source_index++){\n        scene_surface_color += calculate_scene_surface_color(surface_point, material_index, light_source_index, eye_position);\n    }\n    \n    return vec4(scene_surface_color, 1.0);\n}\n\n// cosine based palette, 4 vec3 params\nvec3 palette( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nvec3 calculate_sphere_surface_color(vec3 sphere_surface_point, vec3 sphere_surface_normal, int sphere_index, int number_of_spheres, int light_source_index, vec3 eye_position) \n{\n    PointLightSource light = point_light_sources[light_source_index];\n    if(light_source_index == 2) light.brightness = 0.5 * abs(cos(iTime)) + 1.5;\n    \n    // ambient\n    vec3 ambient_color = vec3(0);   //A vizualizációs gömbökre nem hat ambiens fény.\n\n\t// diffuse\n\tvec3 to_light = normalize(light.position - sphere_surface_point);\n    float costheta_to_light = clamp(dot(to_light, sphere_surface_normal), 0.0, 1.0);\n    \n    vec3 a = vec3(0.5, 0.5, 0.5);\n    vec3 b = vec3(0.5, 0.5, 0.5);\n    vec3 c = vec3(1.0, 1.0, 1.0);\n    vec3 d = vec3(0.00, 0.33, 0.67);\n    \n    vec3 diffuse_color = vec3(palette(float(sphere_index) / float(number_of_spheres-1), a, b, c, d)/pi) * light.diffuse_color * costheta_to_light;\n\n\t// specular\n\tvec3 specular_color = vec3(0);\n\n\tif (costheta_to_light > 0.0)\n\t{\n\t\tvec3 to_eye = normalize(eye_position - sphere_surface_point);\n\t\tvec3 reflected_light = reflect(-to_light, sphere_surface_normal);\n\t\tfloat shine = pow(clamp(dot(to_eye, reflected_light), 0.0f, 1.0f), 25.0);\n\t\tspecular_color = light.specular_color * shine;\n\t}\n\n\t// falloff for point light\n\tfloat distance = distance(light.position, sphere_surface_point);\n\tfloat falloff = light.brightness / distance / distance;\n\n\treturn ambient_color + falloff * (diffuse_color + specular_color);\n}\n\nvec4 visual_ray_hitColor(in Ray view_ray, in float sphere_surface_distance, in int number_of_spheres, in vec3 sphere_origins[MAX_ITERATIONS], in float sphere_radiuses[MAX_ITERATIONS]){\n    //From the surface point hit by the ray we calculate which sphere's surface it is and then we color it based on the array index it's on. \n    \n    vec3 sphere_surface_point = view_ray.P + sphere_surface_distance * view_ray.V;\n    int sphere_index;\n    vec3 sphere_origin;\n    float sphere_radius;\n    for(int i = 0; i < number_of_spheres; i++){\n        //Ray to sphere_surface distance equation:\n            //P0 = view_ray.P\n            //c = sphere_origins[i]\n            //t = sphere_surface_distance\n            //v = view_ray.V\n            //r = sphere_radiuses[i]\n            //We won't compare the distance to 0.0, but an acceptable error margin instead.\n        float acceptable_error_margin = (2.5 * sphere_radiuses[i] * EPSILON * sphere_surface_distance);\n        if(dot( ((view_ray.P - sphere_origins[i]) + sphere_surface_distance * view_ray.V), ((view_ray.P - sphere_origins[i]) + sphere_surface_distance * view_ray.V) ) - (sphere_radiuses[i] * sphere_radiuses[i]) <= acceptable_error_margin ){\n            sphere_origin = sphere_origins[i];\n            sphere_radius = sphere_radiuses[i];\n            sphere_index = i;\n            break;\n        }\n    }\n    \n    vec3 sphere_surface_normal = normalize(sphere_surface_point - sphere_origin);   //We can calculate it heuristically.\n    \n    vec3 eye_position = view_ray.P;\n    \n    vec3 sphere_surface_color = vec3(0);\n    for(int light_source_index = 0; light_source_index<=2; light_source_index++){\n        sphere_surface_color += calculate_sphere_surface_color(sphere_surface_point, sphere_surface_normal, sphere_index, number_of_spheres, light_source_index, eye_position);\n    }\n    \n    return vec4(sphere_surface_color, 1.0);\n}\n\n// ---- CAMERA and EVENTs ----\n// Common key codes (WASD instead of arrows)\n\nconst int C = 67;\nconst int A = 65;\nconst int D = 68;\nconst int W = 87;\nconst int S = 83;\nconst int Q = 81;\n\n#define isKeyHeld(k)  (texelFetch(iChannel1, ivec2(k,0), 0).x > 0.)\n\nconst vec3 EyeStartPosition = vec3(-4.5,0.1,1.5);\n\nRay Camera(vec2 fragCoord, out vec3 eye, out vec2 data2, out Plane sdf_visualization_plane, inout float plane_distance)\n{\n    /*\n        We will use the first 2 pixels of the buffer to store the information we need.\n        Every pixel contains 4 channels (floats), for RGBA. We can exploit this in the following way:\n            pixel0 = (empty, cameraX, cameraY, cameraZ)\n            pixel1 = (empty, empty, U, V)\n        where \n            cameraX, cameraY and cameraZ describe the position of the camera respectively\n            U,V give the current rotation of the camera in spherical coordinates\n\t*/\n    \n    // Ray generation\n    eye = texelFetch(iChannel0, ivec2(0,0), 0).yzw+EyeStartPosition;\t\t// camera position\n    data2 = texelFetch(iChannel0, ivec2(1,0), 0).zw;\t// spherical coordinates\n    vec2 uv\t= abs(data2);\n    \n   \tif(iMouse.z>0. || data2.x >= 0.)\t//mouse held or was held last frame\n        uv += (abs(iMouse.zw)-abs(iMouse.xy))*0.01;\n    \n    vec3 w = vec3(cos(uv.x)*cos(-uv.y),\n                  \t\t\tsin(-uv.y),\n                  sin(uv.x)*cos(-uv.y));\n    vec3 u = normalize(cross(vec3(0,1,0),w));\n\tvec3 v = cross(w,u);\n    \n    vec2 px = (fragCoord/iResolution.xy*2.-1.)*1.*normalize(iResolution.xy);\n    \n    // Keyboard and mouse handling:\n\tfloat speed = 0.2;\n    if (!isKeyHeld(C)){\n        if (isKeyHeld(A)) eye -= u*speed;\n        if (isKeyHeld(D)) eye += u*speed;\n        if (isKeyHeld(W)) eye += w*speed;\n        if (isKeyHeld(S)) eye -= w*speed;\n    }\n    \n    if(iMouse.z>=0.)\t\t//mouse held\n        data2 = abs(data2.xy);\n\telse if(data2.x >= 0.)\t//mouse released\n        data2 = -mod(uv,2.*pi);\n    \n        //SDF visualization plane generation (consider it a camera accessory):\n    float offset_speed = 0.1;\n    if (isKeyHeld(C)){\n        if (isKeyHeld(W))  plane_distance += offset_speed;\n        if (isKeyHeld(S))  plane_distance -= offset_speed;\n    }\n    \n    if(plane_distance > 10.0) plane_distance = 10.0;\n    if(plane_distance < 0.1) plane_distance = 0.1;\n    \n    sdf_visualization_plane.position = eye - plane_distance * normalize(w);             //Center of the visualization plane.\n        //Miért kivonni kell a szem pozíciójából.\n    sdf_visualization_plane.normal = normalize(eye - sdf_visualization_plane.position); //The visualization plane always faces the camera.\n    \n    \n    //The ray casted from this pixel:\n    Ray ray;\n    ray.P    = eye;\n    ray.Tmin = 0.5;\n    ray.V    = normalize(w+px.x*u+px.y*v);\n    ray.Tmax = 500.;\n    \n    //Plane point distance from camera position using trigonometry:\n    float eye_to_plane_distance = distance(eye, sdf_visualization_plane.position);\n    float ray_to_normal_angle = dot(sdf_visualization_plane.normal, ray.V);   //A szög koszinusza. Negatív is lehet.\n    \n    ray.visualization_plane_point_distance = (eye_to_plane_distance / ray_to_normal_angle);\n    \n    // Ray generation\n    return ray;\n}\n\nRay generate_visualization_ray(in vec3 eye, in vec2 data, in vec4 clicked_pixel_position){\n    //We generate the visualization ray using the current camera position, orientation, and the selected pixel.\n    \n    //The camera's rotation and view direction:\n    vec2 uv\t= abs(data);\n    \n    vec3 w = vec3(cos(uv.x)*cos(-uv.y),\n                  \t\t\tsin(-uv.y),\n                  sin(uv.x)*cos(-uv.y));\n    vec3 u = normalize(cross(vec3(0,1,0),w));\n\tvec3 v = cross(w,u);\n    \n    //The ray casted from the selected pixel (MLB held):\n    vec2 px = (clicked_pixel_position.xy/iResolution.xy*2.-1.)*1.*normalize(iResolution.xy);\n    return Ray(eye,\t\t\t\t\t\t\t//P\n               0.5,\t\t\t\t\t\t\t//Tmin\n               normalize(w+px.x*u+px.y*v),\t//V\n               500.,\t\t\t\t\t\t//Tmax\n               0.0);  //Doesn't matter for this one.\n}\n\n// ---- MAIN ----\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //Generate ray from pixel:\n    vec3 eye; vec2 data; // this will be saved into first two pixels\n    \n    Plane sdf_visualization_plane;\n    float plane_distance = texelFetch(iChannel0, ivec2(2,0), 0).w;\n    Ray view_ray = Camera(fragCoord, eye, data, sdf_visualization_plane, plane_distance);\n    \n    //Set epsilon and maximum iteration:\n    SphereTraceDesc params = SphereTraceDesc(EPSILON, MAX_ITERATIONS);\n    \n    //Setting up the visualization ray and it's spheres:\n    Ray visualization_ray;\n    \n    visualization_ray.P    = texelFetch(iChannel0, ivec2(3,0), 0).xyz;\n    visualization_ray.Tmin = texelFetch(iChannel0, ivec2(3,0), 0).w;\n    visualization_ray.V    = texelFetch(iChannel0, ivec2(4,0), 0).xyz;\n    visualization_ray.Tmax = texelFetch(iChannel0, ivec2(4,0), 0).w;\n    \n    if (isKeyHeld(Q)) visualization_ray = generate_visualization_ray(eye, data, iMouse);\n    \n    int number_of_spheres;\n    vec3 sphere_origins[MAX_ITERATIONS];\n    float sphere_radiuses[MAX_ITERATIONS];\n    \n    TraceResult sphere_calculation_result = calculate_visualization_spheres(visualization_ray, params, number_of_spheres, sphere_origins, sphere_radiuses);\n    \n    //Raytrace:\n        //Doing the scene first:\n    TraceResult view_ray_sdf_trace_result = view_sphere_trace(view_ray, params);\n        //Then the visualization ray:\n    TraceResult view_ray_visualization_spheres_trace_result = visualize_sphere_trace(view_ray, params, visualization_ray, number_of_spheres, sphere_origins, sphere_radiuses);\n    \n    //Calculating scene color:\n    vec3 scene_color;\n       \n    if(bool(view_ray_sdf_trace_result.flags&2)) scene_color = scene_hitColor(view_ray, view_ray_sdf_trace_result.T, view_ray_sdf_trace_result.material_index).xyz;\n    else                                        scene_color = missColor(view_ray).xyz;\n    \n    if(bool(view_ray_visualization_spheres_trace_result.flags&2) && (view_ray_visualization_spheres_trace_result.T < view_ray_sdf_trace_result.T)) scene_color = visual_ray_hitColor(view_ray, view_ray_visualization_spheres_trace_result.T, number_of_spheres, sphere_origins, sphere_radiuses).xyz;\n    \n    //Calculating the sdf visualization plane color:\n    vec3 visualization_plane_color;\n    vec3 a,b,c,d;\n    Value visualization_plane_point_value = sdf(view_ray.P + view_ray.visualization_plane_point_distance * view_ray.V, iTime);\n    \n        //We can keep it simple...\n    /*\n    if(visualization_plane_point_value.sdf < 0.0)                        visualization_plane_color = vec3(1,0,0);\n    else if(visualization_plane_point_value.sdf <= params.epsilon * 5.0) visualization_plane_color = vec3(0,1,0);\n    else                                                                 visualization_plane_color = vec3(0,0,1);\n    */\n    \n        //..or you can use a fancy color palettes to make it look like a LSD trip:\n    \n    if(visualization_plane_point_value.sdf < 0.0){\n        a = vec3(0.5, 0.5, 0.5);\n        b = vec3(0.5, 0.5, 0.5);\n        c = vec3(1.0, 1.0, 1.0);\n        d = vec3(0.00, 0.33, 0.67);\n    } else if(visualization_plane_point_value.sdf <= params.epsilon * 5.0){\n        a = vec3(0.5, 0.5, 0.5);\n        b = vec3(0.5, 0.5, 0.5);\n        c = vec3(1.0, 1.0, 0.5);\n        d = vec3(0.8, 0.9, 0.3);\n    } else {\n        a = vec3(0.5, 0.5, 0.5);\n        b = vec3(0.5, 0.5, 0.5);\n        c = vec3(2.0, 1.0, 0.0);\n        d = vec3(0.50, 0.20, 0.25);\n    }\n    \n    visualization_plane_color = palette(visualization_plane_point_value.sdf, a, b, c, d);\n    \n    \n    if(isKeyHeld(C)) fragColor.xyz = mix(scene_color, visualization_plane_color, 0.5);\n    else             fragColor.xyz = scene_color;\n\n    //First two pixels are reserved:\n    if(fragCoord.x == 0.5 && fragCoord.y == 0.5) //pixel (0,0)\n        fragColor.yzw = eye-EyeStartPosition;\n    if(fragCoord.x == 1.5 && fragCoord.y == 0.5) //pixel (1,0)\n        fragColor.zw = data;\n    if(fragCoord.x == 2.5 && fragCoord.y == 0.5) //pixel (2,0)\n        fragColor.w = plane_distance;\n    if(fragCoord.x == 3.5 && fragCoord.y == 0.5){//pixel (3,0)\n        fragColor.xyz = visualization_ray.P;\n        fragColor.w   = visualization_ray.Tmin;\n    }\n    if(fragCoord.x == 4.5 && fragCoord.y == 0.5){//pixel (4,0)\n        fragColor.xyz = visualization_ray.V;\n        fragColor.w   = visualization_ray.Tmax;\n    }\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"//This file contains the code for the scene\n\n//Constants:\nconst float pi = 3.1415926535897932384626433832795;\n\n//Helper functions for theprimitives:\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat dot2( in vec3 v ) { return dot(v,v); }\nfloat ndot( in vec2 a, in vec2 b ) { return a.x*b.x - a.y*b.y; }\n\n//Material attributes and their operations:\nstruct Material {\n    vec3  color;      // [0,1/pi]\n    float roughness;  // [0,~7]\n    vec3  emission;   // [0, inf]\n    float metalness;  // 0.02-0.05 for non-metals, 0.6-0.9 for metals\n};\n\nconst Material materials[7] = Material[7](\n    Material(vec3(0.6, 0.3, 0.08), 4.0, vec3(0.1,0.1,0.1),  0.02),   //0: Tree trunk\n    Material(vec3(0, 1, 0)       , 4.0, vec3(0.1,0.1,0.1),  0.02),   //1: Grass, tree leafs\n    Material(vec3(0.4)           , 4.0, vec3(0.1,0.1,0.1),  0.02),   //2: Mountains, rocks\n    Material(vec3(1, 1, 0)       , 4.0, vec3(0.1,0.1,0.1),  0.02),   //3: Tent, center flame\n    Material(vec3(1)             , 4.0, vec3(0.1,0.1,0.1),  0.6),    //4: Camper body\n    Material(vec3(0)             , 4.0, vec3(0.1,0.1,0.1),  0.02),   //5: Camper wheels\n    Material(vec3(1, 0.56, 0)    , 4.0, vec3(1.0,0.56,0.0), 0.02)    //6: Outer flames\n);\n\nstruct Value{\n    float sdf;\n    int material_index;\n};\n\n//CSG operations:\n\nfloat unite(float sdf1, float sdf2){ // union on the original sdf representation\n    return min(sdf1, sdf2);\n}\n\nValue unite(Value value1, Value value2){ // same union but also carrying mat id\n    float union_sdf = min(value1.sdf, value2.sdf);\n    int union_material_index;\n    \n    if(union_sdf == value1.sdf){\n        union_material_index = value1.material_index;\n    } else {\n        union_material_index = value2.material_index;\n    }\n    \n    return Value(union_sdf, union_material_index);\n}\n\nValue unite(Value value1, float sdf, int material_index){ // creates a Value from the (float,int)\n    Value value2 = Value(sdf, material_index);\n\n    return unite(value1, value2);\n}\n\nfloat subtract(float sdf1, float sdf2){ // union on the original sdf representation\n    return max(sdf1, -sdf2);\n}\n\nValue subtract(Value value1, Value value2){ // same union but also carrying mat id\n    float difference_sdf = max(value1.sdf, -value2.sdf);\n    int difference_material_index;\n    \n    if(difference_sdf == value1.sdf){\n        difference_material_index = value1.material_index;\n    } else {\n        difference_material_index = value2.material_index;\n    }\n    \n    return Value(difference_sdf, difference_material_index);\n}\n\nValue subtract(Value value1, float sdf, int material_index){ // creates a Value from the (float,int)\n    Value value2 = Value(sdf, material_index);\n\n    return subtract(value1, value2);\n}\n\nfloat intersect(float sdf1, float sdf2){ // union on the original sdf representation\n    return max(sdf1, sdf2);\n}\n\nValue intersect(Value value1, Value value2){ // same union but also carrying mat id\n    float intersection_sdf = max(value1.sdf, value2.sdf);\n    int intersection_material_index;\n    \n    if(intersection_sdf == value1.sdf){\n        intersection_material_index = value1.material_index;\n    } else {\n        intersection_material_index = value2.material_index;\n    }\n    \n    return Value(intersection_sdf, intersection_material_index);\n}\n\nValue intersect(Value value1, float sdf, int material_index){ // creates a Value from the (float,int)\n    Value value2 = Value(sdf, material_index);\n\n    return intersect(value1, value2);\n}\n\n//Primitives modified to use materials\n//Original functions are from: https://iquilezles.org/articles/distfunctions\n\nValue sdPyramid(vec3 p, float h, float scale, int material_index){\n  Value pyramid;\n  \n  p /= scale;\n  \n  float m2 = h*h + 0.25;\n    \n  p.xz = abs(p.xz);\n  p.xz = (p.z>p.x) ? p.zx : p.xz;\n  p.xz -= 0.5;\n\n  vec3 q = vec3( p.z, h*p.y - 0.5*p.x, h*p.x + 0.5*p.y);\n   \n  float s = max(-q.x,0.0);\n  float t = clamp( (q.y-0.5*p.z)/(m2+0.25), 0.0, 1.0 );\n    \n  float a = m2*(q.x+s)*(q.x+s) + q.y*q.y;\n  float b = m2*(q.x+0.5*t)*(q.x+0.5*t) + (q.y-m2*t)*(q.y-m2*t);\n    \n  float d2 = min(q.y,-q.x*m2-q.y*0.5) > 0.0 ? 0.0 : min(a,b);\n    \n  pyramid.sdf = sqrt( (d2+q.z*q.z)/m2 ) * sign(max(q.z,-p.y)) * scale;\n  pyramid.material_index = material_index;\n  \n  return pyramid;\n}\n\nValue sdCappedCylinder(vec3 p, float h, float r, int material_index){\n  Value capped_cylinder;\n  \n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  \n  capped_cylinder.sdf = min(max(d.x,d.y),0.0) + length(max(d,0.0));\n  capped_cylinder.material_index = material_index;\n  \n  return capped_cylinder;\n}\n\nValue sdCappedCone(vec3 p, float h, float r1, float r2, int material_index){\n  Value capped_cone;\n  \n  vec2 q = vec2( length(p.xz), p.y );\n  vec2 k1 = vec2(r2,h);\n  vec2 k2 = vec2(r2-r1,2.0*h);\n  vec2 ca = vec2(q.x-min(q.x,(q.y<0.0)?r1:r2), abs(q.y)-h);\n  vec2 cb = q - k1 + k2*clamp( dot(k1-q,k2)/dot2(k2), 0.0, 1.0 );\n  float s = (cb.x<0.0 && ca.y<0.0) ? -1.0 : 1.0;\n  \n  capped_cone.sdf = s*sqrt( min(dot2(ca),dot2(cb)) );\n  capped_cone.material_index = material_index;\n  \n  return capped_cone;\n}\n\nValue sdCone(in vec3 p, in vec2 c, float h, int material_index){\n  Value cone;\n  \n  // c is the sin/cos of the angle, h is height\n  // Alternatively pass q instead of (c,h),\n  // which is the point at the base in 2D\n  vec2 q = h*vec2(c.x/c.y,-1.0);\n    \n  vec2 w = vec2( length(p.xz), p.y );\n  vec2 a = w - q*clamp( dot(w,q)/dot(q,q), 0.0, 1.0 );\n  vec2 b = w - q*vec2( clamp( w.x/q.x, 0.0, 1.0 ), 1.0 );\n  float k = sign( q.y );\n  float d = min(dot( a, a ),dot(b, b));\n  float s = max( k*(w.x*q.y-w.y*q.x),k*(w.y-q.y)  );\n  \n  cone.sdf = sqrt(d)*sign(s);\n  cone.material_index = material_index;\n  \n  return cone;\n}\n\nValue sdTriPrism(vec3 p, vec2 h, int material_index){\n  Value triangular_prism;\n  \n  vec3 q = abs(p);\n  \n  triangular_prism.sdf = max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n  triangular_prism.material_index = material_index;\n  \n  return triangular_prism;\n}\n\nValue sdBox(vec3 p, vec3 b, int material_index){\n    Value box;\n    \n\tvec3 d = abs(p) - b;\n    \n\tbox.sdf = length(max(d,0.0))+min(max(d.x,max(d.y,d.z)),0.0); // remove this line for an only partially signed sdf \n    box.material_index = material_index;\n    \n    return box;\n}\n\nValue sdSphere(vec3 p, float s, int material_index){\n    Value sphere;\n    \n\tsphere.sdf = length(p)-s;\n    sphere.material_index = material_index;\n    \n    return sphere;\n}\n\n//Scene objects:\n\nValue mountains(vec3 default_position, vec3 offset){\n    Value mountains;\n    \n    Value mountain1 = sdPyramid(default_position - offset, 1.0, 6.0, 2);\n    mountains = mountain1;\n    Value mountain2 = sdPyramid(default_position - offset - vec3(4.0, 0.0, 0.0), 1.0, 5.0, 2);\n    mountains = unite(mountains, mountain2);\n    Value mountain3 = sdPyramid(default_position - offset - vec3(8.0, 0.0, 0.0), 1.0, 6.0, 2);\n    mountains = unite(mountains, mountain3);\n    \n    return mountains;\n}\n\nValue pine_tree(vec3 default_position, vec3 offset){\n    Value pine_tree;\n    \n    Value tree_trunk = sdCappedCylinder(default_position - vec3(0,0.25,0) - offset, 0.25, 0.25, 0);\n    pine_tree = tree_trunk;\n    \n    Value tree_middle = sdCappedCone(default_position - vec3(0,1,0) - offset, 0.5, 1.0, 0.6, 1);\n    pine_tree = unite(pine_tree, tree_middle);\n    \n    Value tree_top = sdCone(default_position - vec3(0,2.5,0) - offset, vec2(1,1), 1.0, 1);\n    pine_tree = unite(pine_tree, tree_top);\n    \n    return pine_tree;\n}\n\nValue tent(vec3 default_position, vec3 offset){\n    Value tent;\n    \n    Value tent_outline = sdTriPrism(default_position - offset, vec2(1.5, 1.5), 3);\n    tent = tent_outline;\n    Value tent_interior = sdTriPrism(default_position - offset, vec2(1.4, 1.4), 3);\n    tent = subtract(tent, tent_interior);\n    Value tent_entrance = sdTriPrism(default_position - offset - vec3(0,0,1), vec2(1, 1), 3);\n    tent = subtract(tent, tent_entrance);\n    \n    return tent;\n}\n\nValue camper(vec3 default_position, vec3 offset){\n    Value camper;\n    \n    Value camper_body = sdBox(default_position - offset /*vec3(6, 1.3, 8)*/, vec3(2, 1, 1), 4);\n    camper = camper_body;\n    Value camper_bumper = sdBox(default_position - offset - vec3(2.5, -0.3, 0), vec3(0.5, 0.7, 1), 4);\n    camper = unite(camper, camper_bumper);\n    Value camper_top1 = sdBox(default_position - offset - vec3(1.3, 1.5, 0), vec3(1.5, 0.5, 1), 4);\n    camper = unite(camper, camper_top1);\n    Value camper_interior = sdBox(default_position - offset, vec3(1.9, 0.9, 0.9), 4);\n    camper = subtract(camper, camper_interior);\n    Value camper_entrance = sdBox(default_position - offset - vec3(0, 0, 0.9), vec3(0.5, 0.9, 0.9), 4);\n    camper = subtract(camper, camper_entrance);\n    \n    float angle = pi/2.0;\n    mat4 wheels_rotation = mat4(1.0, 0.0, 0.0, 0.0,\n                                0.0, cos(angle), -sin(angle), 0.0,\n                                0.0, sin(angle), cos(angle), 0.0,\n                                0.0, 0.0, 0.0, 1.0);\n    \n    vec3 front_left_wheel_position = (inverse(wheels_rotation) * (vec4(default_position, 0) - vec4(offset, 0) - vec4(1.5, -0.8, 1, 0))).xyz;\n    Value camper_front_left_wheel = sdCappedCylinder(front_left_wheel_position, 0.4, 0.2, 5);\n    camper = unite(camper, camper_front_left_wheel);\n    \n    vec3 front_right_wheel_position = (inverse(wheels_rotation) * (vec4(default_position, 0) - vec4(offset, 0) - vec4(1.5, -0.8, -1, 0))).xyz;\n    Value camper_front_right_wheel = sdCappedCylinder(front_right_wheel_position, 0.4, 0.2, 5);\n    camper = unite(camper, camper_front_right_wheel);\n    \n    vec3 back_left_wheel_position = (inverse(wheels_rotation) * (vec4(default_position, 0) - vec4(offset, 0) - vec4(-1.2, -0.8, 1, 0))).xyz;\n    Value camper_back_left_wheel = sdCappedCylinder(back_left_wheel_position, 0.4, 0.2, 5);\n    camper = unite(camper, camper_back_left_wheel);\n    \n    vec3 back_right_wheel_position = (inverse(wheels_rotation) * (vec4(default_position, 0) - vec4(offset, 0) - vec4(-1.2, -0.8, -1, 0))).xyz;\n    Value camper_back_right_wheel = sdCappedCylinder(back_right_wheel_position, 0.4, 0.2, 5);\n    camper = unite(camper, camper_back_right_wheel);\n    \n    return camper;\n}\n\nValue campfire(vec3 default_position, vec3 offset, float iTime){\n    //Campfire:\n        //Stones:\n    Value campfire;\n    \n    float rock_circle_radius = 0.4;\n    int number_of_rocks = 8;\n    \n    for(int rock_index = 1; rock_index <= number_of_rocks + 1; rock_index++){\n        Value current_rock;\n        \n        float theta = 2.0 * pi * float(rock_index) / float(number_of_rocks + 1);//get the current angle\n\n        float x = rock_circle_radius * cos(theta);//calculate the x component\n        float z = rock_circle_radius * sin(theta);//calculate the z component\n        \n        current_rock = sdSphere(default_position - vec3(x, 0, z) - offset, 0.1, 2);\n        \n        if(rock_index == 1){\n            campfire = current_rock;\n        } else {\n            campfire = unite(campfire, current_rock);\n        }\n    }\n    \n        //Outer flames:\n    float flame_circle_radius = 0.2;\n    int number_of_flames = 6;\n    \n    for(int flame_index = 1; flame_index <= number_of_flames + 1; flame_index++){\n        Value current_flame;\n        \n        float theta = 2.0 * pi * float(flame_index) / float(number_of_flames + 1);//get the current angle\n\n        float x = flame_circle_radius * cos(theta);//calculate the x component\n        float z = flame_circle_radius * sin(theta);//calculate the z component\n        \n        current_flame = sdCone(default_position - vec3(x, cos(iTime) * 0.1 + 0.3, z) - offset, vec2(0.5,1), 0.4, 6);\n        campfire = unite(campfire, current_flame);\n    }\n   \n        //Center flame:\n    Value center_flame = sdCone(default_position - vec3(0, -(cos(iTime) * 0.1) + 0.3, 0) - offset, vec2(0.5,1), 0.4, 3);\n    campfire = unite(campfire, center_flame);\n    \n    return campfire;\n}\n\n///SDF\n\nValue sdf(in vec3 p, float iTime)\n{\n    //p is close to (0,0,0).\n    \n    //Unite the whole scene int this:\n    Value scene;\n    \n    //Grass:\n    Value ground = Value(p.y, 1);\n    scene = ground;\n    \n    //Mountains:\n    Value mountains = mountains(p, vec3(0));\n    scene = unite(scene, mountains);\n    \n    //Pine trees:\n    Value pine_trees;\n    \n    for(int tree_index = 0; tree_index < 5; tree_index++){\n        vec3 current_pine_tree_position = vec3(tree_index*2, 0, 3.5);\n        if(tree_index == 0){\n            pine_trees = pine_tree(p, current_pine_tree_position);\n        } else {\n            pine_trees = unite(pine_trees, pine_tree(p, current_pine_tree_position));\n        }\n    }\n    scene = unite(scene, pine_trees);\n    \n    //Tent:\n    Value tent = tent(p, vec3(0, 0, 8));\n    scene = unite(scene, tent);\n    \n    //Camper:\n    Value camper = camper(p, vec3(6, 1.3, 8));\n    scene = unite(scene, camper);\n    \n    //Campfire:\n        //Stones:\n    Value campfire = campfire(p, vec3(4,0,12), iTime);\n    \n    scene = unite(scene, campfire);\n    \n    return scene;\n}\n\n//Light sorces:\nstruct PointLightSource{\n    vec3 position;\n    float brightness;\n    vec3 ambient_color;\n    vec3 diffuse_color;\n    vec3 specular_color;\n};\n\nPointLightSource point_light_sources[3] = PointLightSource[3](\n    PointLightSource(vec3(6, 1.3, 8),  2.0, vec3(0.1, 0.1, 0.1), vec3(0.5, 0.5, 0.0), vec3(1.0, 1.0, 1.0)),\n    PointLightSource(vec3(0, 0.0, 8),  2.0, vec3(0.1, 0.1, 0.1), vec3(0.5, 0.5, 0.0), vec3(1.0, 1.0, 1.0)),\n    PointLightSource(vec3(4, 0.5, 12), 2.0, vec3(0.1, 0.1, 0.1), vec3(1.0, 0.56, 0.0), vec3(1.0, 0.56, 0.0))\n);","name":"Common","description":"","type":"common"}]}