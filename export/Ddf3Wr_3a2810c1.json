{"ver":"0.1","info":{"id":"Ddf3Wr","date":"1665931469","viewed":157,"name":"Convolutional filter","username":"tpoomlmly","description":"Make image blurry (and whatever else you can dream of)","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["convolution"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    fragColor = vec4(0);\n    for (int i = 0; i < k_size; i++) {\n        for (int j = 0; j < k_size; j++) {\n        \n            // Calculate the coordinates of the pixel under this part of the kernel\n            vec2 sample_coord = vec2(\n                (fragCoord.x + float(k_size / 2) - float(i)) / iResolution.x,\n                (fragCoord.y + float(k_size / 2) - float(j)) / iResolution.y\n            );\n            \n            // Get that pixel's colour\n            vec4 sample_colour = texture(iChannel0, sample_coord);\n            \n            // Multiply it by its corresponding coefficient in the kernel\n            sample_colour *= kernel[i + j*(k_size)];\n            \n            // Add it to the colour of the output pixel\n            fragColor += sample_colour;\n        }\n    }\n    \n    // Negative edges also count\n    fragColor = abs(fragColor);\n    \n    // Show original image\n    //fragColor = texture(iChannel0, vec2(fragCoord.x/iResolution.x, fragCoord.y/iResolution.y));\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"/*\nconst int k_size = 3;  // 3x3 mean blur\nconst float kernel[k_size*k_size] = float[k_size*k_size](\n    1./9., 1./9., 1./9.,\n    1./9., 1./9., 1./9.,\n    1./9., 1./9., 1./9.\n);\n*/\n\n/*\nconst int k_size = 5;  // 5x5 mean blur\nconst float kernel[k_size*k_size] = float[k_size*k_size](\n    1./25., 1./25., 1./25., 1./25., 1./25.,\n    1./25., 1./25., 1./25., 1./25., 1./25.,\n    1./25., 1./25., 1./25., 1./25., 1./25.,\n    1./25., 1./25., 1./25., 1./25., 1./25.,\n    1./25., 1./25., 1./25., 1./25., 1./25.\n);\n*/\n\n/*\nconst int k_size = 7;  // 7x7 mean blur\nconst float kernel[k_size*k_size] = float[k_size*k_size](\n    1./49., 1./49., 1./49., 1./49., 1./49., 1./49., 1./49.,\n    1./49., 1./49., 1./49., 1./49., 1./49., 1./49., 1./49.,\n    1./49., 1./49., 1./49., 1./49., 1./49., 1./49., 1./49.,\n    1./49., 1./49., 1./49., 1./49., 1./49., 1./49., 1./49.,\n    1./49., 1./49., 1./49., 1./49., 1./49., 1./49., 1./49.,\n    1./49., 1./49., 1./49., 1./49., 1./49., 1./49., 1./49.,\n    1./49., 1./49., 1./49., 1./49., 1./49., 1./49., 1./49.\n);\n*/\n\n/*\nconst int k_size = 3;  // 3x3 Laplacian edge detection\nconst float kernel[k_size*k_size] = float[k_size*k_size](\n    0., -1., 0.,\n    -1., 4., -1.,\n    0., -1., 0.\n);\n*/\n\n/*\nconst int k_size = 3;  // Bidirectional Prewitt edge detection?\nconst float kernel[k_size*k_size] = float[k_size*k_size](\n    2., 1., 0.,\n    1., 0., -1.,\n    0., -1., -2.\n);\n*/\n\n/*\nconst int k_size = 3;  // 3x3 Basic horizontal edge detection\nconst float kernel[k_size*k_size] = float[k_size*k_size](\n     1./3.,  1./3.,  1./3.,\n        0.,     0.,     0.,\n    -1./3., -1./3., -1./3.\n);\n*/\n\n/*\nconst int k_size = 5;  // 5x5 Sobel horizontal edge detection\nconst float kernel[k_size*k_size] = float[k_size*k_size](\n     1./48.,  4./48.,   6./48.,  4./48.,  1./48.,\n     2./48.,  8./48.,  12./48.,  8./48.,  2./48.,\n         0.,      0.,       0.,      0.,      0.,\n    -2./48., -8./48., -12./48., -8./48., -2./48.,\n    -1./48., -4./48.,  -6./48., -4./48., -1./48.\n);\n*/\n\n/*\nconst int k_size = 13;  // Horizontal reverb i think\nconst float kernel[k_size*k_size] = float[k_size*k_size](\n    0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,\n    0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,\n    0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,\n    0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,\n    0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,\n    0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,\n    0., 0., 0., 0., 0., 0., 7./28., 6./28., 5./28., 4./28., 3./28., 2./28., 1./28.,\n    0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,\n    0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,\n    0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,\n    0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,\n    0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,\n    0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.\n);\n*/\n\n\nconst int k_size = 13;  // Band pass filter?\nconst float m = 1./36.;\nconst float kernel[k_size*k_size] = float[k_size*k_size](\n    0., 0., 0., 0., m , m , m , m , m , 0., 0., 0., 0.,\n    0., 0., m , m , 0., 0., 0., 0., 0., m , m , 0., 0.,\n    0.,  m, 0., 0., 0., 0., 0., 0., 0., 0., 0., m , 0.,\n    0.,  m, 0., 0., 0., 0., 0., 0., 0., 0., 0., m , 0.,\n    m , 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., m ,\n    m , 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., m ,\n    m , 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., m ,\n    m , 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., m ,\n    m , 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., m ,\n    0., m , 0., 0., 0., 0., 0., 0., 0., 0., 0., m , 0.,\n    0., m , 0., 0., 0., 0., 0., 0., 0., 0., 0., m , 0.,\n    0., 0., m , m , 0., 0., 0., 0., 0., m , m , 0., 0.,\n    0., 0., 0., 0., m , m , m , m , m , 0., 0., 0., 0.\n);\n\n","name":"Common","description":"","type":"common"}]}