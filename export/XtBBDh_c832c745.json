{"ver":"0.1","info":{"id":"XtBBDh","date":"1515715532","viewed":152,"name":"mapper","username":"Xafer","description":"Perlin simulation of earth-like terrain","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["terrain","perlin"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define WATER_HEIGHT 0.5\n#define SAND_MAX_HEIGHT 0.53\n#define GRASS_MAX_HEIGHT 0.6\n#define SNOW_MIN_HEIGHT 0.7\n#define FROZENLAVA_MIN_HEIGHT 0.8\n#define OX -4.1523\n#define OY -5.1928\n#define MAP_ITERATIONS 8\n#define MAP_START_ITERATIONS 0.3\n#define ZOOM_MOD 0.6\n\nfloat getRandom(vec2 seed)\n{\n    return fract(sin(dot(seed.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvec2 getRandomVec(vec2 seed)\n{\n  float s = getRandom(seed);\n  return vec2(s,getRandom(vec2(s,s+3.0)));\n}\n\nfloat fade(float t) {\n    //Don't interpolate for now\n    return t;//mix(t,(cos(1.5708*2.0 + 1.5708*2.0*t)/2.0 + 0.5),0.1);\n}\n\nfloat getNoiseAt(float x,float y)\n{\n    vec2 loc = vec2(x, y);\n    vec2 tl = floor(loc);\n    vec2 tr = tl + vec2(1.0,0.0);\n    vec2 bl = tl + vec2(0.0,1.0);\n    vec2 br = tl + vec2(1.0,1.0);\n    \n    float a = dot(normalize(getRandomVec(tl)),loc.xy-tl.xy);\n    float b = dot(normalize(getRandomVec(tr)),loc.xy-tr.xy);\n    float c = dot(normalize(getRandomVec(bl)),loc.xy-bl.xy);\n    float d = dot(normalize(getRandomVec(br)),loc.xy-br.xy);\n    \n    vec2 weight = loc.xy-tl.xy;\n    \n    return mix(mix(a,c,fade(weight.y)),mix(b,d,fade(weight.y)),fade(weight.x));\n}\n\nfloat getHeightAt(float x, float y, int iterations, float start)\n{\n    float height = 0.0;\n    float depth = pow(2.0,start);\n    \n    for(int i = 0; i < iterations; i++)\n    {\n        float noise = getNoiseAt(x*depth,y*depth);\n        height = mix(height, noise , 1.0/depth);\n        depth *= 2.0;\n    }\n    \n    return (height*3.0)+0.5;\n}\n\nfloat getShadow(float x, float y, int iterations, float start, vec3 sunDirection)\n{\n    float size = 1.0/pow(2.0,float(iterations)+start);\n    vec2 cc = vec2(x,y);\n    vec2 t = cc+vec2(0,-size);\n    vec2 r = cc+vec2(-size,0);\n    vec2 b = cc+vec2(0,size);\n    vec2 l = cc+vec2(size,0);\n    \n    float top = getHeightAt(t.x,t.y, iterations, start);\n    float bottom = getHeightAt(b.x,b.y, iterations, start);\n    float left = getHeightAt(l.x,l.y, iterations, start);\n    float right = getHeightAt(r.x,r.y, iterations, start);\n    \n    float n = size*2.0;\n    \n    vec3 or = normalize(-vec3(right-left,bottom-top,n));\n    \n    return dot(or,sunDirection);\n}\n\nfloat getCloud(float x, float y)\n{\n    x += iTime/23.25 + sin(iTime/10.0);\n    y += iTime/31.20;\n    float cloud = getHeightAt(x+2.232,y+3.1027,6,3.0);\n    float cloudDensity = getHeightAt(-x+0.21,y-1.121,5,0.5)-0.1;\n    return (min(cloud,cloudDensity)-0.5) * 4.0 + sin(iTime/6.5)/5.0;\n}\n\nfloat getCloudShadow(float x, float y, float h, vec3 sunDir)\n{\n    vec3 dist = sunDir * ((1.0-h)/sunDir.z);\n    return getCloud(x+0.1,y+0.01);\n}\n\nvec3 getHeightColor(float height, float x, float y)\n{\n    vec3 color = vec3(0,0,0);\n    \n    //Trees and tree density\n    float treeDensity = getHeightAt(x+323.1, y+225.5, 2, 3.0);\n    float treeDetailing = getHeightAt(x,y, 2, 6.0);\n    \n    float td = min(treeDensity,treeDetailing);\n    \n    //Water tides\n    float wt = (getHeightAt(x+2.12 + sin(iTime/10.0),y*2.98+0.21, 4, 0.25) - 0.5)*0.1;\n    \n    //Grass irregularities\n    \n    float gi = (getHeightAt(-x+2.12,-y*1.68+0.71, 4, 0.25) - 0.5)*0.1;\n    \n    //Stone irregularities\n    float si = (getHeightAt(x-2.42,y*3.03-0.21, 4, 0.25) - 0.5)*0.1;\n    \n    if(height < WATER_HEIGHT + wt)\n    {color = vec3(height*0.7,height*0.9,height*1.1);}\n    else if(height < SAND_MAX_HEIGHT+gi)\n    {color = vec3(height*1.1,height*1.1,height*0.95);}\n    else if(height < GRASS_MAX_HEIGHT+si)\n    {\n        color = vec3(height*0.6,height*0.9,height*0.2);\n        if(td > 0.5)\n            color.rgb *= 0.7;\n    }\n    else if(height < SNOW_MIN_HEIGHT)\n    {\n        color = vec3(height/1.2,height/1.2,height/1.2);\n        if(td > 0.5)\n            color.rb *= 0.0;\n    }\n    else\n    {\n        color = vec3(height,height,height);\n        if(td > 0.5)\n            color.rgb *= 0.95;\n    }\n    \n    if(height > FROZENLAVA_MIN_HEIGHT && td > 0.5)\n        {\n            color.r *= 0.7;\n            color.b *= 1.0;\n            color.g *= 0.85;\n        }\n    \n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float s = iTime;\n    float aspect = iResolution.y/iResolution.x;\n\tvec2 texCoord = fragCoord.xy/iResolution.xy*2.0 - 1.0;\n    texCoord.y *= aspect;\n    float zoom = sin(s/2.1243)/8.0 + 0.55;\n    vec2 offset = vec2(0,0);\n    offset.x = sin(s/7.2374)/2.0;\n    offset.y = cos(s/10.7412)/2.0;\n    \n    texCoord += offset;\n    \n    texCoord *= zoom / ZOOM_MOD;\n    \n   \tfloat centerDist = texCoord.x*texCoord.x + texCoord.y*texCoord.y;\n    \n    texCoord.x += OX;\n    texCoord.y += OY;\n    \n    float height = getHeightAt(texCoord.x, texCoord.y, MAP_ITERATIONS, MAP_START_ITERATIONS);\n    \n    float t = iTime/8.0;\n    height = max(0.3,height-centerDist*centerDist*0.2);\n    if(centerDist < 0.025) height = mix(1.0,height,centerDist*40.0);\n    vec3 col = getHeightColor(height, texCoord.x, texCoord.y);\n    \n    float underwater = height>WATER_HEIGHT?1.0:0.2;\n    \n    vec3 sunDir = normalize(vec3(-2.0,sin(t),cos(t)*0.5));\n    \n    float shadow = getShadow(texCoord.x, texCoord.y, MAP_ITERATIONS, MAP_START_ITERATIONS, sunDir);\n    \n    shadow += 1.0;\n    \n    shadow += getCloudShadow(texCoord.x,texCoord.y ,height, sunDir);\n    \n    float cloud = getCloud(texCoord.x, texCoord.y);\n    \n    if(shadow <= 1.0)col = mix(col,vec3(0),(shadow - 1.0)/4.0*underwater);\n    if(cos(t) < 0.0)col = mix(vec3(0.05,0.0,0.1),col,1.0+cos(t)/1.4);\n    \n    if(cloud > 0.0)col = mix(vec3(1.0,1.0,1.0),col,1.0-cloud);\n    \n    fragColor = vec4(col.xyz,1.0);\n}","name":"Image","description":"","type":"image"}]}