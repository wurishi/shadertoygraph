{"ver":"0.1","info":{"id":"XtfXDl","date":"1440407477","viewed":685,"name":"glitchy eatbrain logo","username":"nexor","description":"\"From the mind of neurofunk pioneer Jade, comes EATBRAIN - a forward thinking imprint standing at the crux of heavy dancefloor rhythms and the razors edge of drum & bass.\"\n\nThis is an attempt to recreate the eatbrain logo using 2d distance functions.","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["glitch","distancefunctions"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n\n#define time iTime\n#define resolution iResolution.xy\n\nconst float pi = 3.14159265359;\nconst float pi2 = 2.0*pi;\n\nvec2 tr(vec2 p)\n{\n\t p /= resolution.xy;\n\t p = -1.0+2.0*p;\n\t p.x *= resolution.x/resolution.y;\n\t return p;\n}\n\nvec2 pix(vec2 p, int s)\n{\n\t return floor(p*float(s)+0.5)/float(s);\n}\n\nfloat hash( float n )\n{\n    return fract(sin(n)*43758.5453123);\n}\n\nfloat noise( in vec2 x )\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    float n = p.x + p.y*157.0;\n    return mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n               mix( hash(n+157.0), hash(n+158.0),f.x),f.y);\n}\n\nconst mat2 m2 = mat2( 0.80, -0.60, 0.60, 0.80 );\n\nfloat fbm( vec2 p )\n{\n    float f = 0.0;\n    f += 0.5000*noise( p ); p = m2*p*2.02;\n    f += 0.2500*noise( p ); p = m2*p*2.03;\n    f += 0.1250*noise( p ); p = m2*p*2.01;\n    f += 0.0625*noise( p );\n    return f/0.9375;\n}\n\nvec2 rot(vec2 p, float a)\n{\n\t a = radians(a);\n\t float c = cos(a);\n\t float s = sin(a);\n\t return p*mat2(c,s,s,-c);\n}\n\nfloat saw2(float x)\n{\n\t return abs(fract(x)*2.-1.);\n}\n\nfloat saw(float x)\n{\n\t return abs(fract(x)*4.-2.)-1.;\n}\n\n#define ss(x,f) smoothstep(f+.01,f,x)\n\nfloat rct(vec2 p,float w,float h)\n{\n\tp=abs(p);\n\treturn ss(p.x,w)\n\t      *ss(p.y,h);\n}\n\nfloat crc(vec2 p,float r)\n{\n\treturn ss(length(p),r);\n}\n\nfloat tri(vec2 p,float w,float h)\n{\n\treturn ss(abs(p.x),w*saw(p.y*w/h))\n\t      *ss(abs(p.y+h),h);\n}\n\nvoid mainImage( out vec4 fragColor, vec2 fragCoord )\n{\n\tvec2 uv = tr(fragCoord.xy);\n\n\tvec2 pq = uv;\n\n\n float t = time*.8;\n\n float len = length(pq);\n\tvec3 col = vec3(0.0);\n\n\tuv *= 2.5;\n\t//pq = rot(pq,fbm(vec2(0.)+t)*45.);\n\tvec2 gl = floor(2.*cos(2.*t))/2.*step(mod(pq.yx-.0625,.125),vec2(.0625));\n\tuv.y += mix(mix(gl,gl.yx,floor(2.*saw2(4.*t))/2.),\n\t\t         vec2(0.),floor(4.*saw2(2.*t))/4.).y;\n    //uv.y += mix(mix(gl,gl.yx,floor(2.*saw2(4.*t))/2.),vec2(0.),floor(4.*saw2(2.*t))/4.).y;\n\t//uv.x += floor(2.*tan(2.*t))/2.*step(mod(pq.y-.0625,.125),.0625);\n\n\tuv = rot(uv,cos(2.*t)*10.+180.);\n\n float sw = .25;\n float sh = .3;\n float shb = sh+.1;\n float ch = .05;\n float ew = .3;\n float eh = .1;\n float er = 45.;\n\n\tvec2 pc = vec2(0.,-.2);\n\n\tvec2 pl = vec2(-.5,.5);\n\tvec2 pr = vec2(.5,.5);\n\n\tvec2 sll = vec2(-sw,pc.y-ch);\n\tvec2 slr = vec2(sw,pc.y-ch);\n\n\tvec2 sbl = vec2(-sw*3.,pc.y-ch);\n\tvec2 sbr = vec2(sw*3.,pc.y-ch);\n\n\tvec2 tmpv = vec2(0.);\n\tfloat tmpf = 0.;\n\n\tvec3 v = vec3(.0);\n\t//*\n\tv = max(v,rct(uv-pc,sw*5.,ch));\n tmpv = rot(uv-pl,45.0);\n\tv = max(v,rct(tmpv,ew,eh));\n\tv = max(v,rct(tmpv.yx,ew,eh));\n\n tmpv = uv-pr;\n tmpf = (1.+cos(5.*t))*.5;\n tmpf = max(rct(rot(tmpv,er),ew,eh),\n \t           rct(rot(tmpv,-er),ew,eh));\n\n\tv = max(v,tmpf);\n //*/\n\tv = max(v,tri(uv-sll,sw,sh));\n\tv = max(v,tri(uv-slr,sw,sh));\n\n\tv = max(v,tri(uv-sbl,sw,shb));\n\tv = max(v,tri(uv-sbr,sw,shb));\n    \n    tmpv = uv-vec2(0.,0.1);\n    tmpv = rot(tmpv,45.0);\n    v = mod(v+crc(tmpv,1.5),2.);\n\n\tfloat q = 1.0\n\t//*fbm(pq*32.+time)\n\t;\n\n col = v*q;\n\n\tfragColor = vec4( col, 1.0 );\n}","name":"Image","description":"","type":"image"}]}