{"ver":"0.1","info":{"id":"MXSfWw","date":"1729521105","viewed":82,"name":"Hexagon For Games","username":"proas61","description":"Its hexagon shader for manupulate your game","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["game","hexagon"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float sqrt3 = 1.73205;\n\nvec3 hexagon(vec2 r, vec2 offset, vec3 fillColor) {  \n    vec2 r1 = abs(r - offset);\n    r1.y += 1.0 * r1.x / sqrt3;   \n    return (r1.x <= 0.5 * sqrt3 && r1.y <= 1.0)?fillColor:vec3(0.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 r = 20.0 * vec2(uv.x - 0.5, uv.y - 0.5);\n    r.x *= iResolution.x / iResolution.y;\n    \n    vec3 ret = vec3(0.0); // Default background is black\n\n    // Global default and hover colors\n    vec3 defaultColor = vec3(0.1); // Grey\n    vec3 hoverColor = vec3(0.0, 1.0, 0.0); // Green\n\n    float vertSpacing = 1.65; // Vertical spacing with padding\n    float horizSpacing = sqrt3 * sqrt3 * 0.64; // Horizontal spacing with padding\n    vec2 offset = vec2(0.0);\n    \n    // Loop through surrounding layers in a circular manner\n    for (int layer = 1; layer <= 6; layer++) {\n        // Traverse the hexagons in the current layer (ring)\n        for (int i = -layer; i <= layer; i++) {\n            for (int j = max(-layer, -i - layer); j <= min(layer, -i + layer); j++) {\n                offset = vec2(float(i) * horizSpacing + float(j) * horizSpacing * 0.5, float(j) * vertSpacing);\n                \n                ret += hexagon(r, offset, (i == 0 && j == 0)? hoverColor:defaultColor);\n            }\n        }\n    }\n    \n    fragColor = vec4(ret, 1.0);\n}\n\n/*\n// Im gonna try this in unity3d\n// Created by mattz in 2017-04-20\n// https://www.shadertoy.com/view/XdSyzK\n\nconst float hex_factor = 0.8660254037844386;\n\n#define HEX_FROM_CART(p) vec2(p.x / hex_factor, p.y)\n#define CART_FROM_HEX(g) vec2(g.x * hex_factor, g.y)\n\nvec2 nearestHexCell(in vec2 pos) {\n    vec2 gpos = HEX_FROM_CART(pos);\n    vec2 hex_int = floor(gpos);\n\n    float sy = step(2.0, mod(hex_int.x+1.0, 4.0));\n    hex_int += mod(vec2(hex_int.x, hex_int.y + sy), 2.0);\n\n    vec2 gdiff = gpos - hex_int;\n    if (dot(abs(gdiff), vec2(hex_factor*hex_factor, 0.5)) > 1.0) {\n        vec2 delta = sign(gdiff) * vec2(2.0, 1.0);\n        hex_int += delta;\n    }\n\n    return hex_int;\n    \n}\n\nvec2 alignNormal(vec2 h, vec2 d) {\n    return h*sign(dot(h, CART_FROM_HEX(d)));\n}\n\nfloat hexDist(vec2 p) {\n    p = abs(p);\n    return max(dot(p, vec2(hex_factor, 0.5)), p.y) - 1.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    float scl = 10.5 / iResolution.y;\n    float gridline_width = max(0.025, 0.125*scl);\n    vec2 pos = (fragCoord.xy + 0.5 - .5*iResolution.xy) * scl; \n    vec2 ro = vec2(0.0, 0.0);\n    vec2 rd = vec2(0.0, 0.0);\n    vec2 ro_cell = nearestHexCell(ro);\n    vec2 pos_cell = nearestHexCell(pos);\n    \n    float d = abs(hexDist(pos - CART_FROM_HEX(pos_cell)));\n\n    vec3 c;\n\n    // hex color\n    if (pos_cell == ro_cell) {\n        c = vec3(0.0, 1.0, 0.0);\n        gridline_width = max(0.02, 1.325*scl);\n    } else {\n        c = vec3(0.5, 0.5, 0.5);\n    }\n\n    // grid lines\n    c *= smoothstep(0.1, scl, d-gridline_width);\n    fragColor = vec4(c, 1.0);          \n}\n\n*/","name":"Image","description":"","type":"image"}]}