{"ver":"0.1","info":{"id":"MlVGRh","date":"1473267395","viewed":2658,"name":"SDF Inspector","username":"lara","description":"(See Buf A for controls.)\nI needed a simple inspector tool with a fly mode and thought I'd share it.\n\nIf you get lots of errors, try uncommenting line 01.","likes":73,"published":3,"flags":48,"usePreview":0,"tags":["sdf","tool","inspector"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Font by Flyguy (Bit Packed Sprites 2 (5x7))\n// https://www.shadertoy.com/view/llSGRm\n\n#define get(a,b) texture(b,(a+0.5)/iResolution.xy)\nconst vec2 _bufA_res = vec2(0,0);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float res = get(_bufA_res,iChannel0).x;\n    fragCoord.xy *= res;\n    \n    // Hide data pixels\n    if (fragCoord.y < 1.5) fragCoord.y += 1./res;\n\n    vec4 text = texture(iChannel1, fragCoord.xy/iResolution.xy/res);\n    \n    fragColor = vec4(mix(\n        texture(iChannel0, fragCoord.xy/iResolution.xy).rgb,\n        text.rgb,\n        text.a\n    ),1);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// #define noTransparency\nvec3 safeNormalize(vec3 p);\n\n/*\n\n    Camera\n\n    - Mouse:   drag to change view\n    - E/S/D/F: move camera [fly mode]\n\n    Toggles\n\n    - R: fly mode\n    - N: normal coloring\n    - T: translucency\n    - A: ambient occlusion\n    - G: grid\n    - H: distance visualization\n    - J: step visualization\n    - C: cast normal/view coordinates\n    - X: axes\n    - Q: flip windows (top/front/left -> bottom/back/right)\n\n    Axes\n\n    - (x) Cyan\n    - (y) Magenta\n    - (z) Yellow\n\n    For a better performance, lower the marching steps (S) and/or substeps (R) below.\n    The grid also seems to have a great impact on the fps.\n\n*/\n\n// Your SDF here\nfloat myObject(vec3 p)\n{\n    float c = cos(length(p.xy)*5.), s = sin(length(p.xy)*5.);\n    \n    p.yz *= mat2(c,s,-s,c);\n    \n    return length(vec2(length(p.xy)-.5,p.z))-.2;  \n}\n\n// ( pos., normal, dist. to obj., dist. travelled, steps taken, cam pos. )\nvec3 myColor(vec3 p, vec3 n, float d, float t, float s, vec3 cam)\n{\n    float diff = max(dot(n, safeNormalize(cam-p)),.0);\n    float spec = pow(max(dot(reflect(safeNormalize(p-cam),n),safeNormalize(cam-p)),0.001),100.);\n    \n    return vec3(1)*diff + spec;\n}\n\nbool _plane_xz = true;\nbool _plane_xy = false;\nbool _plane_yz = false;\n\nbool _grid_xz = true;\nbool _grid_xy = false;\nbool _grid_yz = false;\n\n#define RES        (1./1.)\n#define GRID_SIZE  (1./4.)\n#define GRID_WIDTH (1./500.)\n\n#define COL_FOG     vec3(0.5)\n#define COL_GRID    vec3(0)\n#define COL_PLANE_A vec3(.25)\n#define COL_PLANE_B vec3(0,1,2)\n\n#define P 0.001  // Precision\n#define D 5.     // Max distance\n#define S 256    // Marching steps\n#define R 2.     // Marching substeps\n#define A 4.     // AO steps\n\n/* ===================== */\n/* === Logic Globals === */\n/* ===================== */\n\n#define set(a,b) if(gl_FragCoord.x==a.x+0.5&&gl_FragCoord.y==a.y+0.5){b;return true;}\n#define get(a,b) textureLod(b,(a+0.5)/iResolution.xy,0.)\n#define init(a) if(iFrame<2){a;return true;}\n#define keyInfo(a,b) textureLod(iChannel3, vec2(a+.5,b+.5)/vec2(256.,3.),0.).x \n\nconst vec2 _bufA_res = vec2(0,0);\nconst vec2 _bufA_mouse = vec2(1,0);\nconst vec2 _bufA_mouse_drag = vec2(2,0);\nconst vec2 _bufA_cam_pos = vec2(3,0);\nconst vec2 _bufA_cam_dir = vec2(4,0);\nconst vec2 _bufA_cast = vec2(5,0);\n\n/* ======================== */\n/* === Marching Globals === */\n/* ======================== */\n\nstruct Hit {\n    vec3 p;\n    float t;\n    float d;\n    float s;\n};\n\nstruct Ray {\n    vec3 o;\n    vec3 d;\n}, _ray;\n\nstruct Cam {\n    vec3 p;\n    vec3 d;\n    vec3 u;\n    float f;\n}, _cam;\n\n\nint _ignore = -1;\nconst int _num_objects = 4;\nfloat _d, _dplanes, _dgrid, _darrow, _dobject;\n\nbool _ortho = false;\nbool _ambOccMarch = false;\n\nvec3 _cast;\nvec3 _cpos;\n\nmat2 rot(float a)\n{\n    float c = cos(a), s = sin(a);\n    return mat2(c,s,-s,c);\n}\n\nvec3 safeNormalize(vec3 p)\n{\n    float l = length(p);\n    if (l == 0.) return vec3(0);\n    return p/l;\n}\n\n/* ============= */\n/* === Scene === */\n/* ============= */\n\nfloat sdGrid(vec3 p)\n{\n    if (_ambOccMarch == true || keyInfo(74.,2.) > 0. || keyInfo(71.,2.) > 0.) return 1e10;\n    \n    float d = 1e10;\n    float s = GRID_SIZE;\n    float r = GRID_WIDTH;\n    \n    if (_ortho == true) r *= 4.;\n    \n    \n    if (_grid_xz == true)\n    {\n        d = min(d,length(vec2(mod(p.x+s/2.,s)-s/2.,p.y))-r);\n        d = min(d,length(vec2(mod(p.z+s/2.,s)-s/2.,p.y))-r);\n    }\n    \n    if (_grid_xy == true)\n    {\n        d = min(d,length(vec2(mod(p.x+s/2.,s)-s/2.,p.z))-r);\n        d = min(d,length(vec2(mod(p.y+s/2.,s)-s/2.,p.z))-r);\n    }\n    \n    if (_grid_yz == true)\n    {\n        d = min(d,length(vec2(mod(p.y+s/2.,s)-s/2.,p.x))-r);\n        d = min(d,length(vec2(mod(p.z+s/2.,s)-s/2.,p.x))-r);\n    }\n    \n    return d;\n}\n\nfloat sdAxes(vec3 p)\n{\n    if (_ambOccMarch == true || keyInfo(74.,2.) > 0. || keyInfo(88.,2.) > 0.) return 1e10;\n    \n    float d = 1e10;\n    float s = GRID_SIZE;\n    float r = GRID_WIDTH;\n    \n    if (_ortho == true) r *= 4.;\n\n    if (_ortho == false || _grid_xz == false)\n    d = min(d,length(p.xz)-r);\n    if (_ortho == false || _grid_xy == false)\n    d = min(d,length(p.xy)-r);\n    if (_ortho == false || _grid_yz == false)\n    d = min(d,length(p.yz)-r);\n    \n    return d;\n}\n\nfloat sdDistancePlanes(vec3 p)\n{\n    if (_ambOccMarch == true || keyInfo(74.,2.) > 0. || keyInfo(72.,2.) > 0.) return 1e10;\n    \n    float d = 1e10;\n    \n    if ((_plane_xz == true && _ortho == false) || (_ortho == true && _plane_xy == false && _plane_yz == false))\n    d = min(d,abs(p.y));\n    \n    if (_plane_xy == true)\n    d = min(d,abs(p.z));\n    \n    if (_plane_yz == true)\n    d = min(d,abs(p.x));\n    \n    return d;\n}\n\nfloat sdCone_(vec3 p, vec3 a, vec3 b, float r1, float r2)\n{\n    vec3 ab = b-a, ap = p-a;\n    float t = clamp(dot(ap,ab)/max(dot(ab,ab),P),0.,1.);\n    return length(ap-ab*t)-mix(r1,r2,t);\n}\n\nvec3 getNormalExclusive(vec3 p)\n{    \n    vec2 e = vec2(P,0.);\n\n    return safeNormalize(vec3(\n        myObject(p+e.xyy)-myObject(p-e.xyy),\n        myObject(p+e.yxy)-myObject(p-e.yxy),\n        myObject(p+e.yyx)-myObject(p-e.yyx)\n    ));\n}\n\nfloat sdNormalArrow(vec3 p)\n{\n    if(_ambOccMarch == true || keyInfo(67.,2.) < 1.) return 1e10;\n\n    vec3 n = getNormalExclusive(_cast);\n    \n    return min(\n        sdCone_(p,_cast,_cast+n*.1,0.005,0.005),\n        sdCone_(p,_cast+n*.1,_cast+n*.13,0.015,0.0)\n    );\n}\n\nfloat scene(vec3 p)\n{\n    _d = 1e10;\n    \n    _dplanes = sdDistancePlanes(p);\n    _dgrid = min(sdAxes(p),sdGrid(p));\n    _darrow = sdNormalArrow(p);\n    _dobject = _ignore == 3 ? 1e10 : myObject(p);\n\n    _d = min(_d, _dplanes);\n    _d = min(_d, _dgrid);\n    _d = min(_d, _darrow);\n    _d = min(_d, _dobject);\n\n    return _d;\n}\n\n/* ================ */\n/* === Marching === */\n/* ================ */\n\nRay lookAt(Cam c, vec2 uv)\n{\n    vec3 r = safeNormalize(cross(c.d,c.u));\n    vec3 u = cross(r,c.d);\n    \n    if (_ortho == true)\n    return Ray(c.p*c.f + uv.x*r + uv.y*u, c.d*c.f);\n    return Ray(c.p*c.f, safeNormalize(uv.x*r + uv.y*u + c.d*c.f));\n}\n\nHit march(Ray r)\n{\n    float t = 0., d, s;\n    vec3 p;\n    \n    for(int i = 0; i < S; i++)\n    {\n        d = scene(p = r.o + r.d*t);\n\n        if (d < P || t > D)\n        {\n            s = float(i);\n            break;\n        }\n\n        t += d/max(R+1.,1.);\n    }\n\n    return Hit(p, t, d, s);\n}\n\nvec3 getNormal(vec3 p)\n{    \n    vec2 e = vec2(P,0.);\n\n    return safeNormalize(vec3(\n        scene(p+e.xyy)-scene(p-e.xyy),\n        scene(p+e.yxy)-scene(p-e.yxy),\n        scene(p+e.yyx)-scene(p-e.yyx)\n    ));\n}\n\n/* =============== */\n/* === Shading === */\n/* =============== */\n\nfloat getAmbientOcclusion(Hit h) \n{  \n    _ambOccMarch = true;\n    \n    float t = 0., a = 0.;\n    \n    for(float i = 0.; i < A; i++)\n    {\n        float d = scene(h.p-_ray.d*i/A*.2);\n        t += d;\n    }\n\n    return clamp(t/A*20.,0.,1.);\n}\n\n// http://lolengine.net/blog/2013/07/27/rgb-to-hsv-in-glsl\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvec3 getColor(Hit h)\n{\n    float key_j = keyInfo(74.,2.);\n    \n    if (h.d > P)\n    {\n        if (key_j > 0.)\n        {\n            float h = h.s/float(S);\n            return hsv2rgb(vec3(h,1.,1.));\n        }\n        return COL_FOG;\n    }\n\n    vec3 col = vec3(0), c;\n    vec3 n = getNormal(h.p);\n    \n    float opacity = 0.;\n    float lastOpacity = 0.;\n    float dist = pow(max(h.t/D,P),2.);\n    \n    bool firstPass = true;\n    \n    for(int i = 0; i < 2; i++)\n    {\n        // Distance plane\n        if (_d == _dplanes)\n        {\n            \n            if (key_j < 1.)\n            {\n                float d = myObject(h.p);\n                c = (d >= 0. ? COL_PLANE_A : COL_PLANE_B) * smoothstep(0.,1.,(sin(d/P*.2)+1.)/2.);\n            }\n            else\n            {\n                float h = h.s/float(S);\n                c = hsv2rgb(vec3(h,1.,1.));\n            }\n        }\n        // Grid\n        else if (_d == _dgrid)\n        {\n            c = COL_GRID;\n            \n            if (keyInfo(88.,2.) < 1.)\n            {\n                float r = GRID_WIDTH*2.;\n\n                if (_ortho == true) r *= 4.;\n\n                if (length(h.p.xy)-r < 0.)\n                c = vec3(1,1,0);\n                else if (length(h.p.xz)-r < 0.)\n                c = vec3(1,0,1);\n                else if (length(h.p.yz)-r < 0.)\n                c = vec3(0,1,1);\n            }\n        }\n        // Normal arrow\n        else if (_d == _darrow)\n        {\n            float diff = max(dot(n, safeNormalize(_cam.p-h.p)),.0);\n            c = vec3(1.5)*diff;\n        }\n        // MyObject\n        else if (_d == _dobject)\n        {\n            c = myColor(h.p,n,h.d,h.t,h.s,_cam.p);\n            \n            // key N is on: display normals\n            if(keyInfo(78.,2.) > 0.)\n            {\n                c = (n+1.)/2.;\n            }\n            // key T is off: make object translucent\n            else if(keyInfo(84.,2.) < 1.)\n            {\n                opacity = .5;\n                _ignore = 3;\n            }\n        }\n        \n        #ifdef noTransparency\n        \n        col = c;\n        break;\n        \n        #else\n\n        // not pretty i know\n        if (firstPass == true)\n        {\n        \tcol = c;\n            firstPass = false;\n        }\n        else\n        {\n            float f = _ortho == true || key_j > 0. ? 0. : pow(max(h.t/D,P),2.);\n            c = mix(c, COL_FOG, f);\n        \tcol = mix(col, c, lastOpacity);\n        }\n        \n        #endif\n        \n        if (opacity > 0.)\n        {\n            _ray.o = h.p;\n            h = march(_ray);\n            \n            if (h.d > P)\n            {\n                col = mix(c,COL_FOG,opacity);\n                break;\n            }\n \n            lastOpacity = opacity;\n            continue;\n        }\n\n        break;\n    }\n\n    // key A is off\n    if (keyInfo(65.,2.) < 1.)\n    {\n        col *= getAmbientOcclusion(h);\n    }\n\n    return mix( col, COL_FOG,_ortho == true || key_j > 0. ? 0. : dist );\n}\n\nbool logic(inout vec4 F)\n{\n    F = textureLod(iChannel0, gl_FragCoord.xy/iResolution.xy,0.);\n    \n    set(_bufA_res,   { F.x = RES;  });\n    set(_bufA_mouse, { F = iMouse; });\n    \n    // looks almost like lambdas ^_^\n    set(_bufA_mouse_drag,\n    {\n        init({ F = vec4(0); });\n        \n        // No dragging in cast mode\n        if (keyInfo(67.,2.) > 0.)\n        {\n            return true;\n        }\n        \n        vec4 iMouseLast = get(_bufA_mouse, iChannel0);\n        if (iMouseLast.w < 1.0) { iMouseLast.xy = iMouse.xy; }\n        \n        float key_r = keyInfo(82.,2.);\n        float t = get(_bufA_cam_pos,iChannel0).w;\n        \n        // Reset values on view toggle\n        if (key_r != t)\n        {\n            F.xy = vec2(0);\n            \n            return true;\n        }\n\n        vec2 uv = iMouse.xy/iResolution.xy;\n        vec2 a = vec2(1.-1./3.*iResolution.y/iResolution.x,1.);\n\n        if (uv.x < a.x)        \n        F.yx += (iMouseLast.xy-iMouse.xy)/(iResolution.xy*a)*vec2(1,-1)*2.;\n    });\n    \n    set(_bufA_cam_dir,\n    {\n        vec3 n = safeNormalize(-_cpos);\n        \n        init({ F.xyz = n; });\n\n        vec4 d = get(_bufA_mouse_drag,iChannel0);     \n        \n        // Always look at the center when fly mode is off\n        if (keyInfo(82.,2.) < 1.)\n        {\n            n = _cpos;\n            n.yz *= rot(d.x);\n            n.xz *= rot(d.y);\n            F.xyz = safeNormalize(-n);\n            \n            return true;\n        }\n\n        n.yz *= rot(d.x);\n        n.xz *= rot(d.y);\n        \n        F.xyz = n;\n    });\n        \n    set(_bufA_cam_pos,\n    {\n        init({ F.xyz = _cpos; });\n        \n        float key_r = keyInfo(82.,2.);\n        \n        // Reset position on view toggle\n        if (key_r != F.w)\n        {\n            F.xyz = _cpos;\n            F.w = key_r;\n            \n            return true;\n        }\n        \n        // Rotate around the center when fly mode is off\n        if (key_r < 1.)\n        {\n            vec2 d = get(_bufA_mouse_drag,iChannel0).xy;\n            \n            F.xyz = _cpos;\n            F.yz *= rot(d.x);\n            F.xz *= rot(d.y);\n            \n            return true;\n        }\n        \n        vec3 dir = get(_bufA_cam_dir,iChannel0).xyz;\n        vec3 right = safeNormalize(cross(dir,vec3(0,1,0)));\n\n        float key_left  = keyInfo(83.,0.); // keyInfo(37.,0.)\n        float key_up    = keyInfo(69.,0.); // keyInfo(38.,0.)\n        float key_right = keyInfo(70.,0.); // keyInfo(39.,0.)\n        float key_down  = keyInfo(68.,0.); // keyInfo(40.,0.)\n        \n        float x = key_left > 0.0 ? -1. : key_right > 0.0 ? 1. : 0.0;\n        float z = key_down > 0.0 ? -1. : key_up    > 0.0 ? 1. : 0.0;\n\n        F.xyz += (right*x + dir*z)*.1;\n        F.w = key_r;\n    });\n    \n    set(_bufA_cast,\n    {\n        F.xyz = _cast;\n    });\n    \n    return false;\n}\n\n/* ============ */\n/* === Main === */\n/* ============ */\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n     _cpos = safeNormalize(vec3(1,1,-1.2))*2.;\n    \n    // Discard pixels that are outside the defined resolution\n    vec2 uv = fragCoord.xy/iResolution.xy/RES;\n    if (uv.x > 1. || uv.y > 1.) { discard; }\n\n    _cam = Cam(\n        iFrame < 2 ?  _cpos    : get(_bufA_cam_pos,iChannel0).xyz,\n        iFrame < 2 ? -_cpos/2. : get(_bufA_cam_dir,iChannel0).xyz,\n        vec3(0,1,0), 1.\n    );\n    \n    float f = 1.;\n    vec2 s = vec2(1./6.)*vec2(iResolution.y/iResolution.x,1);\n    vec2 a = vec2(1.-s.x*2.,1.);\n    \n    // When C was toggled cast a ray to the mouse position\n    if(keyInfo(67.,2.) > 0.)\n    {\n        _cast = march(lookAt(_cam,(2.*iMouse.xy/RES-iResolution.xy*a)/(iResolution.xx*a.xx))).p;\n    }\n    \n    bool data = logic(fragColor);\n    \n    if (data == true)\n    {\n        return;\n    }\n    \n    // axis-view windows\n    if (uv.x > 1.-s.x*2.-0.0025)\n    {\n        _ortho = true;\n        \n        // top\n        if (length(max(abs((1.-uv)-s)-s,0.)) == 0.)\n        {\n            _plane_xz = true;\n            _grid_xz = true;\n            _grid_xy = false;\n            _grid_yz = false;\n            \n            _cam.p = vec3(0,D,0);\n            _cam.u = vec3(0,0,-1);\n            _cam.d = vec3(0,-1,0);\n        }\n        // front\n        else if (length(max(abs((1.-uv-vec2(0,s.y*2.))-s)-s,0.)) == 0.)\n        {\n            _plane_xy = true;\n            _grid_xz = false;\n            _grid_xy = true;\n            _grid_yz = false;\n            \n            _cam.p = vec3(0,0,D);\n            _cam.u = vec3(0,-1,0);\n            _cam.d = vec3(0,0,-1);\n        }\n        // left\n        else if (length(max(abs((1.-uv-vec2(0,s.y*4.))-s)-s,0.)) == 0.)\n        {\n            _plane_yz = true;\n            _grid_xz = false;\n            _grid_xy = false;\n            _grid_yz = true;\n            \n            _cam.p = vec3(-D,0,0);\n            _cam.u = vec3(0,-1,0);\n            _cam.d = vec3(1,0,0);\n        }\n        \n        if (keyInfo(81.,2.) > 0.)\n        {\n            _cam.p *= -1.;\n            _cam.d *= -1.;\n        }\n    \n        // window borders\n        if (step(uv.x-(1.-s.x*2.)+.0025,0.)<1.)\n        {\n            f *= 1.-step(abs(uv.x-(1.-s.x*2.))-.0025,0.);\n            f *= 1.-step(abs(uv.y-1./3.)-.0025/s.x/6.,0.);\n            f *= 1.-step(abs(uv.y-2./3.)-.0025/s.x/6.,0.);\n        }\n        \n        uv = (mod((1.-uv),s*2.)/(s*2.)-.5)*2.;\n    }\n    else\n    {  \n        uv = (2.*fragCoord.xy/RES-iResolution.xy*a)/(iResolution.xx*a.xx);\n    }\n\n    _ray = lookAt(_cam,uv);\n    \n    fragColor = vec4(getColor(march(_ray))*f,1);\n}","name":"Buf A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// Bit Packed Sprites 2 (5x7) by Flyguy\n// https://www.shadertoy.com/view/llSGRm\n\n#define CHAR_SIZE vec2(6, 7)\n#define CHAR_SPACING vec2(6, 9)\n\n#define STRWIDTH(c) (c * CHAR_SPACING.x)\n#define STRHEIGHT(c) (c * CHAR_SPACING.y)\n\n#define DOWN_SCALE 2.0\n\n/*\nTop left pixel is the most significant bit.\nBottom right pixel is the least significant bit.\n\n â–ˆâ–ˆâ–ˆ  |\nâ–ˆ   â–ˆ |\nâ–ˆ   â–ˆ |  \nâ–ˆ   â–ˆ |\nâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ |\nâ–ˆ   â–ˆ |\nâ–ˆ   â–ˆ |\n\n011100 \n100010\n100010  \n100010\n111110\n100010\n100010\n\n011100 (upper 21 bits)\n100010 -> 011100 100010 100010 100 -> 935188\n100010  \n100\n   010 (lower 21 bits)\n111110 -> 010 111110 100010 100010 -> 780450\n100010\n100010\n\nvec2(935188.0,780450.0)\n*/\n\n//Automatically generated from the sprite sheet here: http://uzebox.org/wiki/index.php?title=File:Font6x8.png\nvec2 ch_spc = vec2(0.0,0.0);\nvec2 ch_exc = vec2(276705.0,32776.0);\nvec2 ch_quo = vec2(1797408.0,0.0);\nvec2 ch_hsh = vec2(10738.0,1134484.0);\nvec2 ch_dol = vec2(538883.0,19976.0);\nvec2 ch_pct = vec2(1664033.0,68006.0);\nvec2 ch_amp = vec2(545090.0,174362.0);\nvec2 ch_apo = vec2(798848.0,0.0);\nvec2 ch_lbr = vec2(270466.0,66568.0);\nvec2 ch_rbr = vec2(528449.0,33296.0);\nvec2 ch_ast = vec2(10471.0,1688832.0);\nvec2 ch_crs = vec2(4167.0,1606144.0);\nvec2 ch_per = vec2(0.0,1560.0);\nvec2 ch_dsh = vec2(7.0,1572864.0);\nvec2 ch_com = vec2(0.0,1544.0);\nvec2 ch_lsl = vec2(1057.0,67584.0);\nvec2 ch_0 = vec2(935221.0,731292.0);\nvec2 ch_1 = vec2(274497.0,33308.0);\nvec2 ch_2 = vec2(934929.0,1116222.0);\nvec2 ch_3 = vec2(934931.0,1058972.0);\nvec2 ch_4 = vec2(137380.0,1302788.0);\nvec2 ch_5 = vec2(2048263.0,1058972.0);\nvec2 ch_6 = vec2(401671.0,1190044.0);\nvec2 ch_7 = vec2(2032673.0,66576.0);\nvec2 ch_8 = vec2(935187.0,1190044.0);\nvec2 ch_9 = vec2(935187.0,1581336.0);\nvec2 ch_col = vec2(195.0,1560.0);\nvec2 ch_scl = vec2(195.0,1544.0);\nvec2 ch_les = vec2(135300.0,66052.0);\nvec2 ch_equ = vec2(496.0,3968.0);\nvec2 ch_grt = vec2(528416.0,541200.0);\nvec2 ch_que = vec2(934929.0,1081352.0);\nvec2 ch_ats = vec2(935285.0,714780.0);\nvec2 ch_A = vec2(935188.0,780450.0);\nvec2 ch_B = vec2(1983767.0,1190076.0);\nvec2 ch_C = vec2(935172.0,133276.0);\nvec2 ch_D = vec2(1983764.0,665788.0);\nvec2 ch_E = vec2(2048263.0,1181758.0);\nvec2 ch_F = vec2(2048263.0,1181728.0);\nvec2 ch_G = vec2(935173.0,1714334.0);\nvec2 ch_H = vec2(1131799.0,1714338.0);\nvec2 ch_I = vec2(921665.0,33308.0);\nvec2 ch_J = vec2(66576.0,665756.0);\nvec2 ch_K = vec2(1132870.0,166178.0);\nvec2 ch_L = vec2(1065220.0,133182.0);\nvec2 ch_M = vec2(1142100.0,665762.0);\nvec2 ch_N = vec2(1140052.0,1714338.0);\nvec2 ch_O = vec2(935188.0,665756.0);\nvec2 ch_P = vec2(1983767.0,1181728.0);\nvec2 ch_Q = vec2(935188.0,698650.0);\nvec2 ch_R = vec2(1983767.0,1198242.0);\nvec2 ch_S = vec2(935171.0,1058972.0);\nvec2 ch_T = vec2(2035777.0,33288.0);\nvec2 ch_U = vec2(1131796.0,665756.0);\nvec2 ch_V = vec2(1131796.0,664840.0);\nvec2 ch_W = vec2(1131861.0,699028.0);\nvec2 ch_X = vec2(1131681.0,84130.0);\nvec2 ch_Y = vec2(1131794.0,1081864.0);\nvec2 ch_Z = vec2(1968194.0,133180.0);\nvec2 ch_lsb = vec2(925826.0,66588.0);\nvec2 ch_rsl = vec2(16513.0,16512.0);\nvec2 ch_rsb = vec2(919584.0,1065244.0);\nvec2 ch_pow = vec2(272656.0,0.0);\nvec2 ch_usc = vec2(0.0,62.0);\nvec2 ch_a = vec2(224.0,649374.0);\nvec2 ch_b = vec2(1065444.0,665788.0);\nvec2 ch_c = vec2(228.0,657564.0);\nvec2 ch_d = vec2(66804.0,665758.0);\nvec2 ch_e = vec2(228.0,772124.0);\nvec2 ch_f = vec2(401543.0,1115152.0);\nvec2 ch_g = vec2(244.0,665474.0);\nvec2 ch_h = vec2(1065444.0,665762.0);\nvec2 ch_i = vec2(262209.0,33292.0);\nvec2 ch_j = vec2(131168.0,1066252.0);\nvec2 ch_k = vec2(1065253.0,199204.0);\nvec2 ch_l = vec2(266305.0,33292.0);\nvec2 ch_m = vec2(421.0,698530.0);\nvec2 ch_n = vec2(452.0,1198372.0);\nvec2 ch_o = vec2(228.0,665756.0);\nvec2 ch_p = vec2(484.0,667424.0);\nvec2 ch_q = vec2(244.0,665474.0);\nvec2 ch_r = vec2(354.0,590904.0);\nvec2 ch_s = vec2(228.0,114844.0);\nvec2 ch_t = vec2(8674.0,66824.0);\nvec2 ch_u = vec2(292.0,1198868.0);\nvec2 ch_v = vec2(276.0,664840.0);\nvec2 ch_w = vec2(276.0,700308.0);\nvec2 ch_x = vec2(292.0,1149220.0);\nvec2 ch_y = vec2(292.0,1163824.0);\nvec2 ch_z = vec2(480.0,1148988.0);\nvec2 ch_lpa = vec2(401542.0,66572.0);\nvec2 ch_bar = vec2(266304.0,33288.0);\nvec2 ch_rpa = vec2(788512.0,1589528.0);\nvec2 ch_tid = vec2(675840.0,0.0);\nvec2 ch_lar = vec2(8387.0,1147904.0);\n\n\nvec2 res;\nvec2 print_pos = vec2(0);\n\n//Extracts bit b from the given number.\n//Shifts bits right (num / 2^bit) then ANDs the result with 1 (mod(result,2.0)).\nfloat extract_bit(float n, float b)\n{\n    b = clamp(b,-1.0,22.0); //Fixes small artefacts on my nexus 7\n\treturn floor(mod(floor(n / pow(2.0,floor(b))),2.0));   \n}\n\n//Returns the pixel at uv in the given bit-packed sprite.\nfloat sprite(vec2 spr, vec2 size, vec2 uv)\n{\n    uv = floor(uv);\n    //Calculate the bit to extract (x + y * width) (flipped on x-axis)\n    float bit = (size.x-uv.x-1.0) + uv.y * size.x;\n    \n    //Clipping bound to remove garbage outside the sprite's boundaries.\n    bool bounds = all(greaterThanEqual(uv,vec2(0)));\n    bounds = bounds && all(lessThan(uv,size));\n    \n    return bounds ? extract_bit(spr.x, bit - 21.0)+extract_bit(spr.y, bit) : 0.0;\n\n}\n\n//Prints a character and moves the print position forward by 1 character width.\nfloat char(vec2 ch, vec2 uv)\n{\n    float px = sprite(ch, CHAR_SIZE, uv - print_pos);\n    print_pos.x += CHAR_SPACING.x;\n    return px;\n}\n\n//Returns the digit sprite for the given number.\nvec2 get_digit(float d)\n{\n    d = floor(d);\n    \n    if(d == 0.0) return ch_0;\n    if(d == 1.0) return ch_1;\n    if(d == 2.0) return ch_2;\n    if(d == 3.0) return ch_3;\n    if(d == 4.0) return ch_4;\n    if(d == 5.0) return ch_5;\n    if(d == 6.0) return ch_6;\n    if(d == 7.0) return ch_7;\n    if(d == 8.0) return ch_8;\n    if(d == 9.0) return ch_9;\n    return vec2(0.0);\n}\n\n//Prints out the given number starting at pos.\nfloat print_number(float number, vec2 uv)\n{\n    float result = 0.0;\n    \n\tfor(int i = 3;i >= -3;i--)\n    {\n        float digit = mod( number / pow(10.0, float(i)) , 10.0);\n        \n        if(i == -1) //Add a decimal point.\n        {\n            result += char(ch_per,uv);\n        }\n        \n        if(i < 1) //Clip off leading zeros.\n        {\n        \tresult += char(get_digit(digit),uv);\n        }\n    }   \n    return result;\n}\n\n#define get(a,b) texture(b,(a+0.5)/iResolution.xy)\n#define keyInfo(a,b) texture(iChannel3, vec2(a+.5,b+.5)/vec2(256.,3.)).x \n\nconst vec2 _bufA_cast = vec2(5,0);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    res = iResolution.xy / DOWN_SCALE;\n    \n    if(keyInfo(67.,2.) < 1.)\n    {\n        fragColor = vec4(0);\n        return;\n    }\n    \n    vec2 uv = fragCoord.xy;\n    vec3 pos = get(_bufA_cast,iChannel0).xyz;\n\n    float d = 0.0;\n    \n    print_pos = iMouse.xy + vec2(STRWIDTH(1.),0);\n    d += char(ch_x,uv);\n    d += char(ch_col,uv);\n    d += pos.x < 0. ? char(ch_dsh,uv) : char(ch_spc,uv);\n    d += print_number(abs(pos.x),uv);\n    if (d > 0.) { fragColor = vec4(0,1,1,1); return; }\n    \n    print_pos = iMouse.xy + vec2(STRWIDTH(1.),-STRHEIGHT(1.));\n    d += char(ch_y,uv);\n    d += char(ch_col,uv);\n    d += pos.y < 0. ? char(ch_dsh,uv) : char(ch_spc,uv);\n    d += print_number(abs(pos.y),uv);\n    if (d > 0.) { fragColor = vec4(1,0,1,1); return; }\n    \n    print_pos = iMouse.xy + vec2(STRWIDTH(1.),-STRHEIGHT(1.)*2.);\n    d += char(ch_z,uv);\n    d += char(ch_col,uv);\n    d += pos.z < 0. ? char(ch_dsh,uv) : char(ch_spc,uv);\n    d += print_number(abs(pos.z),uv); \n    if (d > 0.) { fragColor = vec4(1,1,0,1); return; }\n    \n\tfragColor = vec4(vec3(d),d);\n}","name":"Buf B","description":"","type":"buffer"}]}