{"ver":"0.1","info":{"id":"tdX3DS","date":"1547507365","viewed":255,"name":"Fractal Kaleidoscope","username":"NAME_REDACTED","description":"Julia fractal inside a kaleidoscope.","likes":5,"published":1,"flags":32,"usePreview":0,"tags":["fractal","julia","kaleidoscope","warning","seizure"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec2 kaleido(float srcAngle, float rotation, float dist)\n{\n    //basic kaleidopattern\n \tfloat angle2 = mod(srcAngle * float(SYMMETRY) + rotation, 2.);\n    if (angle2 > 1.) angle2 = 2. - angle2;\n\tangle2 = (angle2 / float(SYMMETRY) * PI);\n    vec2 xy = vec2(cos(angle2), sin(angle2)) * dist;\n    \n    //repeat and reflect\n    const int maxReflections = 3;\n    int reflections = 0;\n    do {\n        //alternating reflections about the x-axis\n        xy.x = mod(xy.x, 2.);\n        if (xy.x > 1.) xy.x = 2. - xy.x; //inverted reflections\n        \n        #if SYMMETRY == 3 //take care of bad triangles for 3-symmetry\n\t        xy.y = mod(xy.y, 2.);\n    \t    if (xy.y > 1.) xy.y = 2. - xy.y;\n        #endif\n        \n        //take care of all symmetrical reflections about the center\n        if (xy.y > xy.x * tansym)\n        {\n\t        float newAngle = atan(xy.y / xy.x) ;\n            newAngle = mod(newAngle, symmetry * 2.);\n            if (newAngle > symmetry) newAngle = symmetry * 2. - newAngle; ///inverted reflections\n            xy = vec2(cos(newAngle), sin(newAngle)) * length(xy);\n        }\n\n    } while (xy.x > 1. && ++reflections < maxReflections);\n    return xy;\n}\n\n#define MID_ZOOM 2.5\n#define ZOOM_RANGE 1.25\n#define ZOOM_SPEED .5\n#define ROTATION_SPEED .17\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - iResolution.xy * .5) / iResolution.y;\n   \n    vec2 ar = vec2(c_arg(uv), length(uv));\n\n    float dist = ar.y * (MID_ZOOM + sin(iTime * ZOOM_SPEED) * ZOOM_RANGE);\n    float rotation = sin(iTime * ROTATION_SPEED) * PI;\n    \n    float normalizedAngle = (ar.x + PI2) / PI;\n\tvec2 srcCoord = kaleido(normalizedAngle, rotation, dist);\n    \n    fragColor = (texelFetch(iChannel0, ivec2(srcCoord * iResolution.yy), 0));\n\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define NORMALIZED_ITERATION_COUNT //removes banding\n#define MAX_ITS 100\n#define BAILOUT_VALUE 20. //larger bailout value to assist normalized iteration count\n#define COLOR_DENSITY 3. //number of rotations through the palette.  Negative to flow in reverse.\n#define COLOR_SPEED .25 //iTime multiple for time-based cycles (like color)\n\nconst float angleCutoff = PI2 - symmetry; //doesn't draw anything outside of this angle\n    \nfloat normalizedIterationCount(float i, vec2 z)\n{\n    return i - log2( log( dot(z, z)) );\n}\n\nvec3 palette1d(float i)\n{\n    i = i * COLOR_DENSITY + iTime * COLOR_SPEED;\n    float h = sin(i) + sin(i * 2.618) * .5;\n    float l = (sin(i * 6.618 + 1.) + 1.) * .5;\n    float s = (sin(i * 4.141 + 4.) + 1.) * .5;\n    return vec3(hsv2rgb(vec3(h, 1. - s * s, 1. - l * l)));\n}\n\nvec3 Julia(vec2 c, vec2 init)\n{\n    vec2 z = c;\n        \n    int i = 0;\n    for (; i < MAX_ITS; i++)\n    {\n        z = c_sqr(z) + init;\n        if (dot(z,z) > BAILOUT_VALUE * BAILOUT_VALUE) { break; }\n    }\n    \n    if (i == MAX_ITS) //inside\n    {\n        return vec3(0,0,0);\n    }\n    else //outside\n    { \t\n        #ifdef NORMALIZED_ITERATION_COUNT\n\t\treturn palette1d(normalizedIterationCount(float(i), z) / float(MAX_ITS));\n        #else\n        return palette1d(float(i) / float(MAX_ITS));\n\t\t#endif\n    }\n\n}\n\n/*\nvec2 warp(vec2 uv){ \n    float px = sin(uv.x * 12. + sin(uv.y * 6. + iTime) * 2.);\n    float py = sin(uv.y * 12. + sin(uv.x * 3.75 + iTime) * .35);\n    uv *= 1. + px * py * .5;\n    return uv;\n}\n*/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.yy;\n    \n    if (fragCoord.x > iResolution.y) return;\n    if ((fragCoord.y - 1.) > fragCoord.x * tansym) return;\n\n    //julia func\n    float t1 = iTime * 1.040, t2 = iTime * 3.618;\n    float s2 = .8 + .1 * sin(t2);\n    vec2 z = vec2(cos(t1) - .25, sin(t1)) * s2;\n    \n    vec2 c = (fragCoord / iResolution.y - vec2(.65, .35)) * 2.;\n    fragColor = vec4(Julia(c, z), 1.);\n    \n    \n    /*\n    vec2 sv = warp(uv);\n    vec3 bg = texture(iChannel0, sv - iTime * .1).xyz; // get background texture\n    // mix between the warped uv and the warped background. then the dot of the two interpolates it\n    vec3 col = mix(vec3(sv, 0.0), bg, dot(vec3(sv, 1.05), bg)) * 1.88; \n    fragColor = vec4(col, 1.0) ;\n    */\n    \n    /*\n\t//just move around a picture\n    float t = iTime * .2;\n    vec2 offset = vec2(sin(t), cos(t * .618));\n    float rotation = t * 1.618;\n    fragColor = texture(iChannel0, rotate(uv, rotation) + offset);\n\t*/\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define PI 3.14159265358979\n#define PI2 1.570796326795\n#define PI4 0.7853981634\n#define TAU 6.28318530718\n\n#define SYMMETRY 6\n\nconst float symmetry = PI / float(SYMMETRY);\nconst float tansym = tan(symmetry);\n\nvec3 hsv2rgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvec2 rotate(vec2 vec, float angle)\n{\n    float sa = sin(angle);\n    float ca = cos(angle); //float ca = sqrt(1. - sa * sa); //<-- not faster on modern cards\n    return vec2(vec.x * ca - vec.y * sa,\n                vec.x * sa + vec.y * ca);\n}\n\nvec2 c_sqr(in vec2 value) \n{\n    return vec2(value.x * value.x - value.y * value.y,\n                2. * value.x * value.y);\n}\n\nfloat c_arg(in vec2 value)\n{\n    float a = atan(value.y / value.x);\n    if (value.x >= 0.)\n        return a;\n    else //if (value.x < 0.)\n    {\n        if (value.y > 0.)\n\t        return a + PI;\n        else\n            return a - PI;\n    }\n    /*\n    else //x == 0 (bah, who cares?)\n    {\n        return (value.y > 0.) ? PI2 : PI2;\n    }\n\t*/\n}\n\n","name":"Common","description":"","type":"common"}]}