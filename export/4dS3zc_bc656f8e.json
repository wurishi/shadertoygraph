{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"vec3 localRay;\n\n// Set up a camera looking at the scene.\n// origin - camera is positioned relative to, and looking at, this point\n// distance - how far camera is from origin\n// rotation - about x & y axes, by left-hand screw rule, relative to camera looking along +z\n// zoom - the relative length of the lens\nvoid CamPolar( out vec3 pos, out vec3 ray, in vec3 origin, in vec2 rotation, in float distance, in float zoom, vec2 fragCoord )\n{\n\t// get rotation coefficients\n\tvec2 c = vec2(cos(rotation.x),cos(rotation.y));\n\tvec4 s;\n\ts.xy = vec2(sin(rotation.x),sin(rotation.y)); // worth testing if this is faster as sin or sqrt(1.0-cos);\n\ts.zw = -s.xy;\n\n\t// ray in view space\n\tray.xy = fragCoord.xy - iResolution.xy*vec2(.5,.5);\n\tray.z = iResolution.y*zoom;\n\tray = normalize(ray);\n\tlocalRay = ray;\n\t\n\t// rotate ray\n\tray.yz = ray.yz*c.xx + ray.zy*s.zx;\n\tray.xz = ray.xz*c.yy + ray.zx*s.yw;\n\t\n\t// position camera\n\tpos = origin - distance*vec3(c.x*s.y,s.z,c.x*c.y);\n}\n\n\n// polynomial smooth min (k = 0.1);\n/*float smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}*/\n\n// power smooth min (k = 8);\nfloat smin( float a, float b, float k )\n{\n    a = pow( a, k ); b = pow( b, k );\n    return pow( (a*b)/(a+b), 1.0/k );\n}\n\nfloat distSphere( vec3 point, vec3 sphereCenter, float sphereRadius )\n{\n\tvec3 vec = (point - sphereCenter);\n\treturn length( vec ) - sphereRadius;\n}\n\nfloat distRoundedBox( vec3 point, vec3 pos, vec3 size, float r )\n{\n  return length(max(abs(point - pos)-size,0.0)) - r;\n}\n\nfloat getDist( vec3 point )\n{\n\tfloat k = 10.0;\n\t\n\tfloat res = 0.0;\n\t\n\t/*\n\tmat4 boxes;\n\tboxes[0] = vec3(1.0,0.0,0.0);\n\tboxes[0][1] = vec3(0,1,0);\n\tboxes[0][2] = vec3(0,0,1);\n\tboxes[0][3] = vec3(0,0,0);\n\t\n\tres += exp( -k*distRoundedBox( point, boxes[0][3], vec3(boxes[0][0].x,boxes[0][1].y,boxes[0][2].z), 0.1 ) );\n\t*/\n\t\n\t\n\tres += exp( -k*distSphere( point, vec3(cos(iTime),0,1.2), 0.1 ) );\n\t\n\t// Nose\n\tres += exp( -k*distSphere( point, vec3(1.5,0,0.0), 0.10 ) );\n\tres += exp( -k*distRoundedBox( point, vec3(1.1,0,-0.0), vec3(0.10,0.06,0.06), 0.2 ) );\n\t\n\t// Body\n\tres += exp( -k*distSphere( point, vec3(0,0,0.0), 0.3 ) );\n\tres += exp( -k*distRoundedBox( point, vec3(0.1,0,-0.0), vec3(0.5,0.0,0.1), 0.3 ) );\n\t\n\t/// Wing\n\tres += exp( -k*distRoundedBox( point, vec3(0.4,0,-0.0), vec3(0.2,0.0,0.6), 0.2 ) );\n\tres += exp( -k*distRoundedBox( point, vec3(0.1,0,-0.0), vec3(0.2,0.0,1.25), 0.1 ) );\n\tres += exp( -k*distRoundedBox( point, vec3(-0.2,0,-0.0), vec3(0.2,0.0,1.5), 0.1 ) );\n\t\n\t// Tail\n\tres += exp( -k*distRoundedBox( point, vec3(-1.2,0.4,-0.0), vec3(0.4,0.0,0.10), 0.2 ) );\n\n\t\t\n\t//float res = exp( -k*dist1 ) + exp( -k*dist2 ) + exp( -k*dist3 );\n    float dist = -log( res )/k;\n\treturn dist;\n}\n\nvec3 getNormal( vec3 p )\n{\n\tfloat eps = 0.001;\n\t\n    vec3 n = vec3( getDist(vec3(p.x-eps,p.y,p.z)) - getDist(vec3(p.x+eps,p.y,p.z)),\n                   getDist(vec3(p.x,p.y-eps,p.z)) - getDist(vec3(p.x,p.y+eps,p.z)),\n                   getDist(vec3(p.x,p.y,p.z-eps)) - getDist(vec3(p.x,p.y,p.z+eps)) );\n\t\n    return normalize( -n );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 camRot = vec2(1.5,1.5)+vec2(-3.0,5.0)*(iMouse.yx/iResolution.yx);\n\tvec3 pos, ray;\n\tCamPolar( pos, ray, vec3(0), camRot, 3.0, 1.0, fragCoord );\n\t\n\tvec3 viewVec = ray;\n\tviewVec = normalize( viewVec );\n\t\n\tvec3 colour = -viewVec*0.2;\n\t\n\t\n\tvec3 currPoint = pos;\n\t\n\tvec3 hitPoint = vec3(0.0,0.3,0.0);\n\tvec3 hitNorm = vec3(0,1,0);\n\tfloat hitDist = fract( iTime*0.1 ) * 4.0;\n\t\n\tfloat accuracy = 0.01;\n\t\n\t\n\tfor (int i=0; i<60; ++i)\n\t{\n\t\tfloat dist = abs( getDist( currPoint ) );\n\t\t\n\t\tif (dist > 0.0)\n\t\t{\n\t\t\tcurrPoint += viewVec * dist;\n\t\t\t\n\t\t\tif (dist <= accuracy)\n\t\t\t{\n\t\t\t\tvec3 norm = getNormal( currPoint );\n\t\t\t\t\n\t\t\t\tfloat distToHit = length(currPoint - hitPoint);\n\t\t\t\t\n\t\t\t\tdistToHit *= 1.0 + 1.0*(1.0 - (dot( hitNorm, norm ) * 0.5 + 0.5));\n\t\t\t\t\n\t\t\t\tif (distToHit < hitDist)\n\t\t\t\t{\n\t\t\t\t\tcolour += vec3(0.1,0.1,0.5);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tcolour += vec3(0.1,0.1,0.1);\t\t\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t\n\t\t\t\tcurrPoint += viewVec * accuracy*10.0;\n\t\t\t\t\n\t\t\t\t//break;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfragColor = vec4(colour,1.0);\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"4dS3zc","date":"1391511930","viewed":230,"name":"Shield","username":"theraz0r","description":"Initial version of a shield effect","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["distancefield","volumetric","shield"],"hasliked":0,"parentid":"","parentname":""}}