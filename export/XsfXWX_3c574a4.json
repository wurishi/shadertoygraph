{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[{"channel":0,"type":"cubemap","id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"}}],"code":"#define PI 3.1415926535897932384626433832795\n\nvec3 obj_pos = vec3(0.0,0.0,-10.0);\nfloat obj_size = 5.0;\n\nfloat sphere(vec3 dir, vec3 center, float radius) {\n    vec3 rp = -center;\n\tfloat b = dot(rp,dir);\n\tfloat dist = b * b - (dot(rp,rp) - radius * radius);\n\tif(dist <= 0.0) return -1.0;\n\treturn -b - sqrt(dist);\n}\n\nfloat somestep(float t) {\n    return pow(t,4.0);\n}\n\nvec3 getFishEye(vec2 uv, float level) {\n    float len = length(uv);\n    float a = len * level;\n    return vec3(uv / len * sin(a), -cos(a));\n}\n\nvec3 textureAVG(samplerCube tex, vec3 tc) {\n    const float diff0 = 0.35;\n    const float diff1 = 0.12;\n \tvec3 s0 = texture(tex,tc).xyz;\n    vec3 s1 = texture(tex,tc+vec3(diff0)).xyz;\n    vec3 s2 = texture(tex,tc+vec3(-diff0)).xyz;\n    vec3 s3 = texture(tex,tc+vec3(-diff0,diff0,-diff0)).xyz;\n    vec3 s4 = texture(tex,tc+vec3(diff0,-diff0,diff0)).xyz;\n    \n    vec3 s5 = texture(tex,tc+vec3(diff1)).xyz;\n    vec3 s6 = texture(tex,tc+vec3(-diff1)).xyz;\n    vec3 s7 = texture(tex,tc+vec3(-diff1,diff1,-diff1)).xyz;\n    vec3 s8 = texture(tex,tc+vec3(diff1,-diff1,diff1)).xyz;\n    \n    return (s0 + s1 + s2 + s3 + s4 + s5 + s6 + s7 + s8) * 0.111111111;\n}\n\nvec3 textureBlured(samplerCube tex, vec3 tc) {\n   \tvec3 r = textureAVG(tex,vec3(1.0,0.0,0.0));\n    vec3 t = textureAVG(tex,vec3(0.0,1.0,0.0));\n    vec3 f = textureAVG(tex,vec3(0.0,0.0,1.0));\n    vec3 l = textureAVG(tex,vec3(-1.0,0.0,0.0));\n    vec3 b = textureAVG(tex,vec3(0.0,-1.0,0.0));\n    vec3 a = textureAVG(tex,vec3(0.0,0.0,-1.0));\n        \n    float kr = dot(tc,vec3(1.0,0.0,0.0)) * 0.5 + 0.5; \n    float kt = dot(tc,vec3(0.0,1.0,0.0)) * 0.5 + 0.5;\n    float kf = dot(tc,vec3(0.0,0.0,1.0)) * 0.5 + 0.5;\n    float kl = 1.0 - kr;\n    float kb = 1.0 - kt;\n    float ka = 1.0 - kf;\n    \n    kr = somestep(kr);\n    kt = somestep(kt);\n    kf = somestep(kf);\n    kl = somestep(kl);\n    kb = somestep(kb);\n    ka = somestep(ka);    \n    \n    float d;\n    vec3 ret;\n    ret  = f * kf; d  = kf;\n    ret += a * ka; d += ka;\n    ret += l * kl; d += kl;\n    ret += r * kr; d += kr;\n    ret += t * kt; d += kt;\n    ret += b * kb; d += kb;\n    \n    return ret / d;\n}\n\nfloat phong(vec3 l, vec3 e, vec3 n, float power) {\n    float nrm = (power + 8.0) / (PI * 8.0);\n    return pow(max(dot(l,reflect(e,n)),0.0), power) * nrm;\n}\n\n// GGX code from https://www.shadertoy.com/view/MlB3DV\nfloat G1V ( float dotNV, float k ) {\n\treturn 1.0 / (dotNV*(1.0 - k) + k);\n}\nfloat GGX(vec3 N, vec3 V, vec3 L, float roughness, float F0) {\n    \tfloat alpha = roughness*roughness;\n\tvec3 H = normalize (V + L);\n\n\tfloat dotNL = clamp (dot (N, L), 0.0, 1.0);\n\tfloat dotNV = clamp (dot (N, V), 0.0, 1.0);\n\tfloat dotNH = clamp (dot (N, H), 0.0, 1.0);\n\tfloat dotLH = clamp (dot (L, H), 0.0, 1.0);\n\n\tfloat D, vis;\n\tfloat F;\n\n\t// NDF : GGX\n\tfloat alphaSqr = alpha*alpha;\n\tfloat pi = 3.1415926535;\n\tfloat denom = dotNH * dotNH *(alphaSqr - 1.0) + 1.0;\n\tD = alphaSqr / (pi * denom * denom);\n\n\t// Fresnel (Schlick)\n\tfloat dotLH5 = pow (1.0 - dotLH, 5.0);\n\tF = F0 + (1.0 - F0)*(dotLH5);\n\n\t// Visibility term (G) : Smith with Schlick's approximation\n\tfloat k = alpha / 2.0;\n\tvis = G1V (dotNL, k) * G1V (dotNV, k);\n\n\treturn /*dotNL */ D * F * vis;\n}\n\nvec3 getColor(vec3 ray) {\n    float dist = sphere(ray,obj_pos,obj_size);    \n    if(dist > 0.0) {\n        \n    \tvec3 point = ray * dist;\n    \tvec3 normal = point - obj_pos;\n        normal = normalize(normal);\n        \n        // material\n        float metallic = 0.04;\n        float roughness = step(fract(normal.x * 2.02), 0.5) + 0.1;\n        float fresnel_pow = mix(5.0, 3.5,metallic);\n        //const vec3 color_mod = vec3(1.000, 0.766, 0.336);\n        vec3 color_mod = vec3(1.0);\n        vec3 light_color = pow(texture(iChannel0,vec3(1.0,0.0,0.0)).xyz * 1.2, vec3(2.2));\n                \n                \n        // IBL\n        vec3 ibl_diffuse = pow(textureBlured(iChannel0,normal), vec3(2.2));\n        vec3 ibl_reflection = pow(textureBlured(iChannel0,reflect(ray,normal)), vec3(2.2));\n        \n        // fresnel\n        float fresnel = max(1.0 - dot(normal,-ray), 0.0);\n        fresnel = pow(fresnel,fresnel_pow);    \n        \n        // reflection        \n        vec3 refl = pow(texture(iChannel0,reflect(ray,normal)).xyz, vec3(2.2));\n        refl = mix(refl,ibl_reflection,(1.0-fresnel)*roughness);\n        refl = mix(refl,ibl_reflection,roughness);\n        \n        // specular\n        vec3 light = normalize(vec3(-0.5,1.0,0.0));\n        float power = 1.0 / max(roughness * 0.4,0.01);\n        //vec3 spec = light_color * phong(light,ray,normal,power);\n        vec3 spec = light_color * GGX(normal,-ray,light,roughness*0.7, 0.2);\n        refl -= spec;\n        \n        // diffuse\n        vec3 diff = ibl_diffuse * vec3(1.0,0.2,0.0);\n        diff = mix(diff * color_mod,refl,fresnel);        \n\n        vec3 color = mix(diff,refl * color_mod,metallic) + spec;\n        return pow(color, vec3(1.0/2.2));\n        \n    } else {      \n        \n        return texture(iChannel0,ray).xyz;\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {   \n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    vec3 dir = getFishEye(uv,1.2);\n    \n    // rotation\n    float c = cos(iTime);\n    float s = sin(iTime);\n    dir.xz = vec2(dir.x * c - dir.z * s, dir.x * s + dir.z * c);\n    obj_pos.xz = vec2(obj_pos.x * c - obj_pos.z * s, obj_pos.x * s + obj_pos.z * c);\n    \n    // color\n    float fish_eye = smoothstep(2.0,1.6,length(uv)) * 0.25 + 0.75;\n\tfragColor = vec4(getColor(dir) * fish_eye, 1.0);\n}\n","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"XsfXWX","date":"1407324234","viewed":6882,"name":"Physically based rendering","username":"TDM","description":"fish eye, fake IBL, fake roughness etc.","likes":77,"published":1,"flags":0,"usePreview":0,"tags":["fisheye","fresnel","pbr"],"hasliked":0,"parentid":"","parentname":""}}