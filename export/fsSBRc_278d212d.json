{"ver":"0.1","info":{"id":"fsSBRc","date":"1646727309","viewed":637,"name":"Raymarching SDF Visualization 2","username":"viclw17","description":"Based on https://www.shadertoy.com/view/XdtSWl\nBlog post --> https://viclw17.github.io/2022/03/01/raymarching-visualization-shaders","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","visualization","distance","depth","steps","debug"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Based on https://www.shadertoy.com/view/XdtSWl\n//This shader visualizes the way raymarching works. \n\n//- mouse.y to push the iteration\n//- left side rgb grid to visualize world position of sdf traced points + depth (distance from the camera to FAR_PLANE)\n//- right side white gradient to visualize the iterations (how many times the for loop ran to calculate the pixel)\n\n#define MAX_ITERATIONS 100\n#define MIN_DISTANCE .001\n#define FAR_PLANE    100.\n\nstruct Ray { vec3 ori; vec3 dir;  };\nstruct Hit { vec3 pos; float dst; int iter; };\n\n\nfloat sdSphere(vec3 p, vec3 pos, float r) {\n    return length(pos - p) - r;   \n}\n\n\nfloat sdFloor(vec3 p, float y) {\n    return p.y - y;  \n}\n\n\n//Smooth Minimum by iq\n//Source: https://iquilezles.org/articles/smin\nfloat smin( float a, float b, float k ){\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\n\nfloat sdScene(vec3 p) {\n    float sdf = 0.;\n    float sdFloor = sdFloor(p, 0.1);\n    //float sdSphere = sdSphere(p, vec3(0.), 1.);\n    //sdf = min(sdFloor, sdSphere);\n    sdf = smin(sdFloor, sdSphere(p, vec3( 1.5 * sin(iTime), 2.0, 5.1), 1.), .5);\n    sdf = smin(sdf,      sdSphere(p, vec3(-1.5 * sin(iTime), 0.5, 5.1), 1.), .5);\n\n    return sdf;\n}\n\n\nHit Raymarching(Ray ray) {\n    float dO  = 0.; // distance to origin\n    float dS = 0.; // distance to scene\n    int iteration = 0;\n    vec3 position;\n    \n    float y = iMouse.y / iResolution.y;\n    if(iMouse.y == 0.) y = 1.;\n    int steps = int(y * float(MAX_ITERATIONS));\n    \n    for(int i = 0; i < steps; i++) {\n        position = ray.ori + ray.dir * dO;\n        dS = sdScene(position);\n        dO += dS;\n        //dO += .1;\n        iteration = i;\n        \n        if(dS <= MIN_DISTANCE || dO > FAR_PLANE) {\n            //iteration = i;\n            break;       \n        }   \n    }   \n    return Hit(position, dO, iteration);\n}\n\n\nvec3 shade(Ray ray, vec2 fragCoord) {\n    Hit scn = Raymarching(ray);\n    float x = iMouse.x / iResolution.x;\n    if(iMouse.x == 0.) x = .5;\n    vec3 col = vec3(0.);\n    \n    if((fragCoord.x / iResolution.x) <= x) {     \n        float dist = scn.dst / FAR_PLANE; \n        col = vec3(dist * 5.);\n        //col += floor(mod(scn.pos,.5)/.5 + .1) * (1./(scn.pos.z - 1.));\n        col += smoothstep(0.9,1.0,   mod(scn.pos,.5)/.5) + \n               smoothstep(0.9,1.0,1.-mod(scn.pos,.5)/.5);\n    } else {\n        col = vec3(float(scn.iter))/float(MAX_ITERATIONS);     \n    }\n    \n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\tvec2 uv = (fragCoord - iResolution.xy * .5) / iResolution.y;\n    vec3 ori = vec3(0.,1.,0.);\n    // normalize!\n    vec3 dir = normalize(vec3(uv, 1.));\n\tfragColor = vec4(shade(Ray(ori,dir),fragCoord),1.);\n}","name":"Image","description":"","type":"image"}]}