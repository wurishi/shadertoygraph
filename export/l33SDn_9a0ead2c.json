{"ver":"0.1","info":{"id":"l33SDn","date":"1719152889","viewed":72,"name":"UI demo (WIP)","username":"hasenpfote","description":"This is a demonstration of sliders and an experiment with the HUD pass.\n\n2024-06-27: I changed the original concept to handle more UI elements.","likes":1,"published":1,"flags":48,"usePreview":0,"tags":["font","ui","slider","hud","gui","toggle","segmentedcontrol"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/**\n * UI demo:\n *\n * ===\n * Inspired by the following work:\n * Distance field outline mask - Good\n * https://www.shadertoy.com/view/XtG3Rt\n */\n\n#define DEBUG_DISPLAY\n\n#define FONT_SAMPLER iChannel2\n\nfloat load_state(in int id){\n    return load_state(iChannel3, id).w;\n}\n\n#ifdef DEBUG_DISPLAY\n\nDEF_STRING8(STRING_D_01, _STRING_D_01, int[](_f,_p,_s,_COLON,_SP))\nDEF_STRING32(STRING_D_02, _STRING_D_02, int[](_P,_r,_e,_s,_s,_SP,_F,_1,_SP,_t,_o,_SP,_t,_o,_g,_g,_l,_e,_SP,_H,_U,_D))\nDEF_STRING16(STRING_D_03, _STRING_D_03, int[](_V,_i,_s,_i,_b,_i,_l,_i,_t,_y,_COLON,_SP))\nDEF_STRING8(STRING_D_04, _STRING_D_04, int[](_A,_c,_t,_i,_v,_e,_COLON,_SP))\nDEF_STRING8(STRING_D_05, _STRING_D_05, int[](_S,_l,_i,_d,_e,_r,_SP))\nDEF_STRING8(STRING_D_06, _STRING_D_06, int[](_T,_o,_g,_g,_l,_e,_SP))\nDEF_STRING8(STRING_D_07, _STRING_D_07, int[](_S,_e,_g,_C,_t,_l,_SP))\n\nvec3 draw_debug(in vec2 pos, in vec3 color){\n#define CRLF  text_newline(ts)\n#define C(c) text_char(FONT_SAMPLER, ts, c);\n#define S(s) text_string(FONT_SAMPLER, ts, s)\n#define SX(s, x) text_string(FONT_SAMPLER, ts, s, x)\n#define X(x) text_value(FONT_SAMPLER, ts, x, 1)\n\n    vec2 uv = pos / iResolution.y;\n    TextState ts;\n\n    text_init(ts, iResolution.y);\n\n    vec2 raw_char_size = text_raw_char_size(ts);\n\n    text_begin(ts, 1.);\n    text_set_pos(ts, uv, vec2(0., 1.));\n    SX(STRING_D_01, iFrameRate); CRLF;\n    text_end(ts, color);\n\n    text_begin(ts, 0.5);\n    vec2 char_size = raw_char_size * ts.scale;\n    int len = text_length(STRING_D_02);\n    float right = iResolution.x / iResolution.y;\n    text_set_pos(ts, uv, vec2(right - float(len) * char_size.x, char_size.y));\n    S(STRING_D_02); CRLF;\n    text_end(ts, color);\n\n    text_begin(ts, 0.75);\n    text_set_pos(ts, uv, vec2(0.7, 0.7));\n    SX(STRING_D_03, int(load_state(SID_HUD_VISIBILITY))); CRLF;\n    SX(STRING_D_04, int(load_state(SID_ACTIVE_UI)));  CRLF;\n    SX(STRING_D_05, 1); C(_COLON); C(_SP); X(load_state(SID_SLIDER_1)); CRLF;\n    SX(STRING_D_05, 2); C(_COLON); C(_SP); X(load_state(SID_SLIDER_2)); CRLF;\n    SX(STRING_D_05, 3); C(_COLON); C(_SP); X(load_state(SID_SLIDER_3)); CRLF;\n    SX(STRING_D_06, 1); C(_COLON); C(_SP); X(int(load_state(SID_TOGGLE_1))); CRLF;\n    SX(STRING_D_06, 2); C(_COLON); C(_SP); X(int(load_state(SID_TOGGLE_2))); CRLF;\n    SX(STRING_D_07, 1); C(_COLON); C(_SP); X(int(load_state(SID_SEG_CTRL_1))); CRLF;\n    text_end(ts, color);\n\n    return color;\n\n#undef X\n#undef SX\n#undef S\n#undef C\n#undef CRLF\n}\n\n#endif // DEBUG_DISPLAY\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    int index = int(load_state(SID_SEG_CTRL_1));\n    vec2 uv = fragCoord / iResolution.xy;\n    vec3 color;\n\n    switch(index){\n    case 1: color = srgb_to_linear(texture(iChannel0, uv).rgb); break;\n    case 2: color = srgb_to_linear(texture(iChannel1, uv).rgb); break;\n    default: color = vec3(1.); break;\n    }\n\n    vec3 hud = texture(iChannel3, uv).rgb;\n    vec3 mixed_color = mix(color, hud.rgb, 0.75);\n\n    color = mix(mixed_color, color, step(dot(hud, hud), 0.));\n#ifdef DEBUG_DISPLAY\n    color.rgb = draw_debug(fragCoord, color.rgb);\n#endif\n    fragColor = vec4(linear_to_srgb(color), 1.);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"\n#define SID_HUD_VISIBILITY 0\n#define SID_ACTIVE_UI      1\n#define SID_SLIDER_1       2\n#define SID_SLIDER_2       3\n#define SID_SLIDER_3       4\n#define SID_TOGGLE_1       5\n#define SID_TOGGLE_2       6\n#define SID_SEG_CTRL_1     7\n\n//==============================================================================\n\nvec3 srgb_to_linear(in vec3 color){\n    vec3 lo = vec3(color / 12.92);\n    vec3 hi = pow((color + 0.055) / 1.055, vec3(2.4));\n\n    return mix(hi, lo, lessThanEqual(color, vec3(0.04045)));\n}\n\nvec3 linear_to_srgb(in vec3 color){\n    vec3 lo = 12.92 * color;\n    vec3 hi = 1.055 * pow(color, vec3(1./2.4)) - 0.055;\n\n    return mix(hi, lo, lessThanEqual(color, vec3(0.0031308)));\n}\n\n//==============================================================================\n// State buffer\n//==============================================================================\n\nconst ivec2 STATE_BUFFER_SIZE = ivec2(128);\n\nvec4 load_state(in sampler2D sampler, in int id){\n    ivec2 pos = ivec2(id % STATE_BUFFER_SIZE.x, id / STATE_BUFFER_SIZE.y);\n    return texelFetch(sampler, pos, 0);\n}\n\nint pos_to_sid(in ivec2 pos){\n    int factor = 1 - 2 * int(any(greaterThanEqual(pos, STATE_BUFFER_SIZE)));\n    return (pos.y * STATE_BUFFER_SIZE.x + pos.x) * factor;\n}\n\nbool can_store_state(in int id, in ivec2 pos){\n    return id == pos_to_sid(pos);\n}\n\n//==============================================================================\n\n#define ENABLE_STRING\n\n// https://dev.w3.org/html5/spec-LC/named-character-references.html\n\n#define _SP     0x20 // ' '\n#define _EXCL   0x21 // '!'\n#define _QUOT   0x22 // '\"'\n#define _NUM    0x23 // '#'\n#define _DOLLAR 0x24 // '$'\n#define _PERCNT 0x25 // '%'\n#define _AMP    0x26 // '&'\n#define _APOS   0x27 // '''\n#define _LPAR   0x28 // '('\n#define _RPAR   0x29 // ')'\n#define _AST    0x2A // '*'\n#define _PLUS   0x2B // '+'\n#define _COMMA  0x2C // ','\n#define _HYPHEN 0x2D // '-'\n#define _PERIOD 0x2E // '.'\n#define _SOL    0x2F // '/'\n#define _0      0x30 // '0'\n#define _1      0x31 // '1'\n#define _2      0x32 // '2'\n#define _3      0x33 // '3'\n#define _4      0x34 // '4'\n#define _5      0x35 // '5'\n#define _6      0x36 // '6'\n#define _7      0x37 // '7'\n#define _8      0x38 // '8'\n#define _9      0x39 // '9'\n#define _COLON  0x3A // ':'\n#define _SEMI   0x3B // ';'\n#define _LT     0x3C // '<'\n#define _EQUALS 0x3D // '='\n#define _GT     0x3E // '>'\n#define _QUEST  0x3F // '?'\n#define _COMMAT 0x40 // '@'\n#define _A      0x41 // 'A'\n#define _B      0x42 // 'B'\n#define _C      0x43 // 'C'\n#define _D      0x44 // 'D'\n#define _E      0x45 // 'E'\n#define _F      0x46 // 'F'\n#define _G      0x47 // 'G'\n#define _H      0x48 // 'H'\n#define _I      0x49 // 'I'\n#define _J      0x4A // 'J'\n#define _K      0x4B // 'K'\n#define _L      0x4C // 'L'\n#define _M      0x4D // 'M'\n#define _N      0x4E // 'N'\n#define _O      0x4F // 'O'\n#define _P      0x50 // 'P'\n#define _Q      0x51 // 'Q'\n#define _R      0x52 // 'R'\n#define _S      0x53 // 'S'\n#define _T      0x54 // 'T'\n#define _U      0x55 // 'U'\n#define _V      0x56 // 'V'\n#define _W      0x57 // 'W'\n#define _X      0x58 // 'X'\n#define _Y      0x59 // 'Y'\n#define _Z      0x5A // 'Z'\n#define _LSQB   0x5B // '['\n#define _BSOL   0x5C // '\\'\n#define _RSQB   0x5D // ']'\n#define _HAT    0x5E // '^'\n#define _LOWBAR 0x5F // '_'\n#define _GRAVE  0x60 // '`'\n#define _a      0x61 // 'a'\n#define _b      0x62 // 'b'\n#define _c      0x63 // 'c'\n#define _d      0x64 // 'd'\n#define _e      0x65 // 'e'\n#define _f      0x66 // 'f'\n#define _g      0x67 // 'g'\n#define _h      0x68 // 'h'\n#define _i      0x69 // 'i'\n#define _j      0x6A // 'j'\n#define _k      0x6B // 'k'\n#define _l      0x6C // 'l'\n#define _m      0x6D // 'm'\n#define _n      0x6E // 'n'\n#define _o      0x6F // 'o'\n#define _p      0x70 // 'p'\n#define _q      0x71 // 'q'\n#define _r      0x72 // 'r'\n#define _s      0x73 // 's'\n#define _t      0x74 // 't'\n#define _u      0x75 // 'u'\n#define _v      0x76 // 'v'\n#define _w      0x77 // 'w'\n#define _x      0x78 // 'x'\n#define _y      0x79 // 'y'\n#define _z      0x7A // 'z'\n#define _LCUB   0x7B // '{'\n#define _VERBAR 0x7C // '|'\n#define _RCUB   0x7D // '}'\n#define _TILDE  0x7E // '~'\n\n/*\n * horizontal\n *\n *   | ML | LSB | Width | RSB | MR |\n *        |<<    Advance    >>|\n *\n *   Advance = LSB + Width + RSB\n *   ML = (CharSize - Width) / 2 - LSB\n *   MR = CharSize - (ML + LSB + Width + RSB)\n *\n * vertical\n *\n *   | LG/2 | MT | Height | MB | LG/2 |\n *\n *   Height = Ascent + Descent\n *   MT = CharSize - (Baseline + Ascent)\n *   MB = CharSize - (MT + Height)\n *\n */\nstruct FontMetrics{\n    // horizontal\n    float advance;\n    float margin_left;\n    float margin_right;\n    // vertical\n    float height;\n    float margin_top;\n    float margin_bottom;\n    float line_gap;\n};\n\nstruct TextState{\n    vec2 hori_offset;\n    vec2 vert_offset;\n    vec2 org;\n    vec2 pos;\n    float dist;\n    float scale;\n    float res_scale;\n};\n\nconst float FONT_TEXTURE_SIZE = 1024.;\nconst float FONT_CHAR_SIZE = 64.;\nconst float FONT_GRID_SIZE = 16.;\n\nconst FontMetrics FONT_METRICS_DEFAULT = FontMetrics(36., 14., 14., 58., 4., 2., 10.);\n\nconst float FONT_SDF_INITIAL_DISTANCE = 1e1;\n\nconst int TEXT_MAX_INT_DIGITS = 4;\nconst int[] TEXT_POW10_TABLE = int[TEXT_MAX_INT_DIGITS + 1](1, 10, 100, 1000, 10000);\nconst int TEXT_MAX_INT_PLACE = TEXT_POW10_TABLE[TEXT_MAX_INT_DIGITS - 1];\n\nconst vec3 TEXT_COLOR_DEFAULT = vec3(1.);\nconst vec3 TEXT_OUTLINE_COLOR_DEFAULT = vec3(0.);\n\nint pop(in uint x){\n    x = (x & 0x55555555u) + ((x >> 1) & 0x55555555u);\n    x = (x & 0x33333333u) + ((x >> 2) & 0x33333333u);\n    x = (x & 0x0F0F0F0Fu) + ((x >> 4) & 0x0F0F0F0Fu);\n    x = (x & 0x00FF00FFu) + ((x >> 8) & 0x00FF00FFu);\n    x = (x & 0x0000FFFFu) + ((x >> 16) & 0x0000FFFFu);\n\n    return int(x);\n}\n\nint nlz(in uint x){\n    x = x | (x >> 1);\n    x = x | (x >> 2);\n    x = x | (x >> 4);\n    x = x | (x >> 8);\n    x = x | (x >> 16);\n\n    return pop(~x);\n}\n\nint log2i(in uint x){\n    return 31 - nlz(x);\n}\n\nfloat font_sdf_char(in sampler2D sampler, in int code, in vec2 char_uv){\n    if(char_uv.x < 0. || char_uv.x > 1. || char_uv.y < 0. || char_uv.y > 1.)\n        return FONT_SDF_INITIAL_DISTANCE;\n\n    const float reciprocal = 1. / FONT_GRID_SIZE;\n\n    /*\n     * (char_uv + vec2(code % 16, 15 - code / 16)) / 16.;\n     */\n    float c = float(code);\n    vec2 uv = char_uv * reciprocal\n                + fract(vec2(c, FONT_GRID_SIZE - 1. - floor(c * reciprocal)) * reciprocal);\n\n    /*\n     *                 boundary\n     *   -0.5 ========== 0.0 ========= +0.5 (distance)\n     *     |<--  Int.  -->|<--  Ext.  -->|\n     */\n    return textureLod(sampler, uv, 0.).a - 0.5;\n}\n\nvoid text_init(out TextState ts, in float base_dim){\n    float ml = FONT_METRICS_DEFAULT.margin_left / FONT_TEXTURE_SIZE;\n    float mt = (FONT_METRICS_DEFAULT.margin_top - 0.5 * FONT_METRICS_DEFAULT.line_gap) / FONT_TEXTURE_SIZE;\n    ts.hori_offset = vec2(ml, -(ml + floor(FONT_METRICS_DEFAULT.advance / FONT_TEXTURE_SIZE * base_dim) / base_dim));\n    ts.vert_offset = vec2(-mt, mt + floor((FONT_METRICS_DEFAULT.height + FONT_METRICS_DEFAULT.line_gap) / FONT_TEXTURE_SIZE * base_dim) / base_dim);\n\n    ts.dist = FONT_SDF_INITIAL_DISTANCE;\n    ts.res_scale = base_dim / FONT_TEXTURE_SIZE;\n}\n\nvec2 text_raw_char_size(in TextState ts){\n    return vec2(abs(ts.hori_offset.x + ts.hori_offset.y),\n                ts.vert_offset.x + ts.vert_offset.y);\n}\n\nvec2 text_char_size(in TextState ts){\n    return text_raw_char_size(ts) * ts.scale;\n}\n\nvoid text_begin(inout TextState ts, in float scale){\n    ts.dist = FONT_SDF_INITIAL_DISTANCE;\n    ts.scale = scale;\n}\n\nvoid text_end(inout TextState ts,\n              in vec3 text_color, in vec3 outline_color, inout vec3 color){\n    // Inversely proportional to the font scale.\n    float scale = ts.res_scale * ts.scale;\n    float f = 1. - exp2(- 1. / (scale * scale));\n\n    /*\n     *        1.5*MID  MID  0.5*MID   0   0.5*MED  MED  1.5*MED\n     * --~-------+------+------+------+------+------+------+------+--~-->\n     *      Font |<<   MIX   >>| OTL. | OTL. |<<   MIX   >>| BG.  |\n     */\n    float max_interior_dist = mix(0.004, 0.010, f);\n    float max_exterior_dist = mix(0.020, 0.050, f);\n\n    vec3 mixed_color = mix(text_color, color, step(0., ts.dist));\n\n    vec3 interior_color = mix(outline_color, mixed_color, smoothstep(0., max_interior_dist, abs(ts.dist) - 0.5 * max_interior_dist));\n    vec3 exterior_color = mix(outline_color, mixed_color, smoothstep(0., max_exterior_dist, ts.dist - 0.5 * max_exterior_dist));\n\n    mixed_color = mix(interior_color, exterior_color, step(0., ts.dist));\n    color = mix(mixed_color, color, step(FONT_SDF_INITIAL_DISTANCE, ts.dist));\n}\n\nvoid text_end(inout TextState ts, inout vec3 color){\n    text_end(ts, TEXT_COLOR_DEFAULT, TEXT_OUTLINE_COLOR_DEFAULT, color);\n}\n\nvoid text_set_pos(inout TextState ts, in vec2 uv, in vec2 x){\n    ts.pos = ts.org = uv - (x - vec2(0., 1.));\n}\n\nvoid text_advance_pos(inout vec2 p, in vec2 offset, in float scale, in int num_chars){\n    p.x += float(num_chars) * (offset.x + offset.y) * scale;\n}\n\nvoid text_newline(inout vec2 p, in vec2 offset, in float scale, in float left){\n    p.x = left;\n    p.y += (offset.x + offset.y) * scale;\n}\n\nvoid text_newline(inout TextState ts){\n    text_newline(ts.pos, ts.vert_offset, ts.scale, ts.org.x);\n}\n\nivec2 text_map_to_index(in vec2 p, in vec2 hori_offset, in vec2 vert_offset, in float scale){\n    return ivec2(floor(p.x / (abs(hori_offset.x + hori_offset.y) * scale)),\n                 floor((1. - p.y) / ((vert_offset.x + vert_offset.y) * scale)));\n}\n\nint text_count_digits(in uint x){\n    x = min(x, uint(TEXT_POW10_TABLE[TEXT_MAX_INT_DIGITS] - 1));\n\n    int y = (9 * log2i(x | 1u)) >> 5;\n\n    return y + int(x > uint(TEXT_POW10_TABLE[y + 1] - 1)) + 1;\n}\n\nint text_count_digits(in uint x, in int min_digits){\n    return max(text_count_digits(x), min_digits);\n}\n\nvoid text_char_internal(in sampler2D sampler, in int code,\n                        inout vec2 p, in vec2 hori_offset, in vec2 vert_offset, in float scale, inout float dist){\n    vec2 q = p + vec2(hori_offset.x, vert_offset.x) * scale;\n\n    float gs = FONT_GRID_SIZE / scale;\n    vec2 char_uv = q * gs;\n    char_uv.y -= gs - 1.;\n\n    dist = min(dist, font_sdf_char(sampler, code, char_uv));\n\n    p.x = q.x + hori_offset.y * scale;\n}\n\nvoid text_char(in sampler2D sampler, inout TextState ts, in int code){\n    ivec2 index = text_map_to_index(ts.pos, ts.hori_offset, ts.vert_offset, ts.scale);\n\n    if(index.x >= 1 || index.y >= 1){\n        text_advance_pos(ts.pos, ts.hori_offset, ts.scale, 1);\n        return;\n    }\n\n    if(index.x < 0 || index.y < 0){\n        return;\n    }\n\n    text_char_internal(sampler, code, ts.pos, ts.hori_offset, ts.vert_offset, ts.scale, ts.dist);\n}\n\nvoid text_value_common(in sampler2D sampler, inout TextState ts,\n                       in int signum, in int i, in int f, in int i_len, in int f_len){\n    int signed_int_len = int(signum < 0) + i_len;\n    int len = signed_int_len + f_len + int(f_len > 0);\n    ivec2 index = text_map_to_index(ts.pos, ts.hori_offset, ts.vert_offset, ts.scale);\n\n    if(index.x >= len || index.y >= 1){\n        text_advance_pos(ts.pos, ts.hori_offset, ts.scale, len);\n        return;\n    }\n\n    if(index.x < 0 || index.y < 0){\n        return;\n    }\n\n    int code;\n\n    if(index.x == 0 && signum < 0){\n        code = 45;\n    }else if(index.x == signed_int_len){\n        code = 46;\n    }else if(index.x < signed_int_len){\n        int place = TEXT_POW10_TABLE[signed_int_len - 1 - index.x];\n        code = 48 + ((i / place) % 10);\n    }else{\n        int place = TEXT_POW10_TABLE[len - 1 - index.x];\n        code = 48 + ((f / place) % 10);\n    }\n\n    text_advance_pos(ts.pos, ts.hori_offset, ts.scale, index.x);\n    text_char_internal(sampler, code, ts.pos, ts.hori_offset, ts.vert_offset, ts.scale, ts.dist);\n}\n\nvoid text_decompose_value(in uint x, in int min_digits,\n                          out int signum, out int i, out int f, out int i_len, out int f_len){\n    signum = int(x > 0u);\n    i = int(x);\n    f = 0;\n    i_len = text_count_digits(x, min_digits);\n    f_len = 0;\n}\n\nvoid text_decompose_value(in int x, in int min_digits,\n                          out int signum, out int i, out int f, out int i_len, out int f_len){\n    signum = sign(x);\n    i = abs(x);\n    f = 0;\n    i_len = text_count_digits(uint(i), min_digits);\n    f_len = 0;\n}\n\nvoid text_decompose_value(in float x, in int min_digits,\n                          out int signum, out int i, out int f, out int i_len, out int f_len){\n    float fx, ix;\n    fx = modf(abs(x), ix);\n    fx = float(TEXT_POW10_TABLE[min_digits]) * fx;\n\n    signum = sign(int(x));\n    i = int(ix);\n    f = int(fx);\n    i_len = text_count_digits(uint(i), 1);\n    f_len = text_count_digits(uint(f), min_digits) * int(min_digits > 0);\n}\n\n#define DEF_TEXT_VALUE(T) \\\n    int text_length_inner(in T x, in int min_digits, \\\n                          out int signum, out int i, out int f, out int i_len, out int f_len){ \\\n        min_digits = min(min_digits, TEXT_MAX_INT_DIGITS); \\\n        text_decompose_value(x, min_digits, signum, i, f, i_len, f_len); \\\n        return int(signum < 0) + i_len + f_len + int(f_len > 0); \\\n    } \\\n    int text_length(in T x, in int min_digits){ \\\n        int signum, i, f, i_len, f_len; \\\n        return text_length_inner(x, min_digits, signum, i, f, i_len, f_len); \\\n    } \\\n    void text_value(in sampler2D sampler, inout TextState ts, in T x, in int min_digits){ \\\n        int signum, i, f, i_len, f_len; \\\n        text_length_inner(x, min_digits, signum, i, f, i_len, f_len); \\\n        text_value_common(sampler, ts, signum, i, f, i_len, f_len); \\\n    }\n\nDEF_TEXT_VALUE(uint)\nDEF_TEXT_VALUE(int)\nDEF_TEXT_VALUE(float)\n\n/*\n * This macro defines text_value functions for vector types.\n * It separates definitions by dimension, such as 2D, 3D, and 4D, to reduce\n * compile time.\n *\n * Usage example:\n *\n *   DEF_TEXT_VEC2_VALUE(uvec2)\n *\n *   void text_value(in sampler2D sampler, inout TextState ts,\n *                   in uvec2 x, in int min_digits){\n *       text_vec_value(sampler, x, min_digits, _COMMA, ts);\n *   }\n *\n *   DEF_TEXT_VEC2_VALUE(ivec2)\n *\n *   void text_value(in sampler2D sampler, inout TextState ts,\n *                   in ivec2 x, in int min_digits){\n *       text_vec_value(sampler, x, min_digits, _COMMA, ts);\n *   }\n *\n *   DEF_TEXT_VEC2_VALUE(vec2)\n *\n *   void text_value(in sampler2D sampler, inout TextState ts,\n *                   in vec2 x, in int min_digits){\n *       text_vec_value(sampler, x, min_digits, _COMMA, ts);\n *   }\n *\n */\n#define DEF_TEXT_VEC2_VALUE(T) \\\n    int text_length_inner(in T x, in int min_digits, \\\n                          out ivec2 signum, out ivec2 i, out ivec2 f, out ivec2 i_len, out ivec2 f_len){ \\\n        min_digits = min(min_digits, TEXT_MAX_INT_DIGITS); \\\n        text_decompose_value(x.x, min_digits, signum.x, i.x, f.x, i_len.x, f_len.x); \\\n        text_decompose_value(x.y, min_digits, signum.y, i.y, f.y, i_len.y, f_len.y); \\\n        ivec2 len = ivec2(lessThan(signum, ivec2(0))) + i_len + ivec2(lessThan(ivec2(0), f_len)) + f_len; \\\n        return 2 - 1 + len.x + len.y; \\\n    } \\\n    int text_length(in T x, in int min_digits){ \\\n        ivec2 signum, i, f, i_len, f_len; \\\n        return text_length_inner(x, min_digits, signum, i, f, i_len, f_len); \\\n    } \\\n    void text_vec_value(in sampler2D sampler, inout TextState ts, in T x, in int min_digits, in int sep){ \\\n        ivec2 signum, i, f, i_len, f_len; \\\n        int total_len = text_length_inner(x, min_digits, signum, i, f, i_len, f_len); \\\n        vec2 size = text_char_size(ts); \\\n        size.x *= float(total_len); \\\n        vec2 p = ts.pos; \\\n        if(p.x < 0. || p.x > size.x || p.y > 1. || p.y < 1. - size.y){ \\\n            text_advance_pos(p, ts.hori_offset, ts.scale, total_len); \\\n            ts.pos = p; \\\n            return; \\\n        } \\\n        text_value_common(sampler, ts, signum.x, i.x, f.x, i_len.x, f_len.x); \\\n        text_char(sampler, ts, sep); \\\n        text_value_common(sampler, ts, signum.y, i.y, f.y, i_len.y, f_len.y); \\\n    }\n\n#define DEF_TEXT_VEC3_VALUE(T) \\\n    int text_length_inner(in T x, in int min_digits, \\\n                          out ivec3 signum, out ivec3 i, out ivec3 f, out ivec3 i_len, out ivec3 f_len){ \\\n        min_digits = min(min_digits, TEXT_MAX_INT_DIGITS); \\\n        text_decompose_value(x.x, min_digits, signum.x, i.x, f.x, i_len.x, f_len.x); \\\n        text_decompose_value(x.y, min_digits, signum.y, i.y, f.y, i_len.y, f_len.y); \\\n        text_decompose_value(x.z, min_digits, signum.z, i.z, f.z, i_len.z, f_len.z); \\\n        ivec3 len = ivec3(lessThan(signum, ivec3(0))) + i_len + ivec3(lessThan(ivec3(0), f_len)) + f_len; \\\n        return 3 - 1 + len.x + len.y + len.z; \\\n    } \\\n    int text_length(in T x, in int min_digits){ \\\n        ivec3 signum, i, f, i_len, f_len; \\\n        return text_length_inner(x, min_digits, signum, i, f, i_len, f_len); \\\n    } \\\n    void text_vec_value(in sampler2D sampler, inout TextState ts, in T x, in int min_digits, in int sep){ \\\n        ivec3 signum, i, f, i_len, f_len; \\\n        int total_len = text_length_inner(x, min_digits, signum, i, f, i_len, f_len); \\\n        vec2 size = text_char_size(ts); \\\n        size.x *= float(total_len); \\\n        vec2 p = ts.pos; \\\n        if(p.x < 0. || p.x > size.x || p.y > 1. || p.y < 1. - size.y){ \\\n            text_advance_pos(p, ts.hori_offset, ts.scale, total_len); \\\n            ts.pos = p; \\\n            return; \\\n        } \\\n        text_value_common(sampler, ts, signum.x, i.x, f.x, i_len.x, f_len.x); \\\n        text_char(sampler, ts, sep); \\\n        text_value_common(sampler, ts, signum.y, i.y, f.y, i_len.y, f_len.y); \\\n        text_char(sampler, ts, sep); \\\n        text_value_common(sampler, ts, signum.z, i.z, f.z, i_len.z, f_len.z); \\\n    }\n\n#define DEF_TEXT_VEC4_VALUE(T) \\\n    int text_length_inner(in T x, in int min_digits, \\\n                          out ivec4 signum, out ivec4 i, out ivec4 f, out ivec4 i_len, out ivec4 f_len){ \\\n        min_digits = min(min_digits, TEXT_MAX_INT_DIGITS); \\\n        text_decompose_value(x.x, min_digits, signum.x, i.x, f.x, i_len.x, f_len.x); \\\n        text_decompose_value(x.y, min_digits, signum.y, i.y, f.y, i_len.y, f_len.y); \\\n        text_decompose_value(x.z, min_digits, signum.z, i.z, f.z, i_len.z, f_len.z); \\\n        text_decompose_value(x.w, min_digits, signum.w, i.w, f.w, i_len.w, f_len.w); \\\n        ivec4 len = ivec4(lessThan(signum, ivec4(0))) + i_len + ivec4(lessThan(ivec4(0), f_len)) + f_len; \\\n        return 4 - 1 + len.x + len.y + len.z + len.w; \\\n    } \\\n    int text_length(in T x, in int min_digits){ \\\n        ivec4 signum, i, f, i_len, f_len; \\\n        return text_length_inner(x, min_digits, signum, i, f, i_len, f_len); \\\n    } \\\n    void text_vec_value(in sampler2D sampler, inout TextState ts, in T x, in int min_digits, in int sep){ \\\n        ivec4 signum, i, f, i_len, f_len; \\\n        int total_len = text_length_inner(x, min_digits, signum, i, f, i_len, f_len); \\\n        vec2 size = text_char_size(ts); \\\n        size.x *= float(total_len); \\\n        vec2 p = ts.pos; \\\n        if(p.x < 0. || p.x > size.x || p.y > 1. || p.y < 1. - size.y){ \\\n            text_advance_pos(p, ts.hori_offset, ts.scale, total_len); \\\n            ts.pos = p; \\\n            return; \\\n        } \\\n        text_value_common(sampler, ts, signum.x, i.x, f.x, i_len.x, f_len.x); \\\n        text_char(sampler, ts, sep); \\\n        text_value_common(sampler, ts, signum.y, i.y, f.y, i_len.y, f_len.y); \\\n        text_char(sampler, ts, sep); \\\n        text_value_common(sampler, ts, signum.z, i.z, f.z, i_len.z, f_len.z); \\\n        text_char(sampler, ts, sep); \\\n        text_value_common(sampler, ts, signum.w, i.w, f.w, i_len.w, f_len.w); \\\n    }\n\n#ifdef ENABLE_STRING\n/*\n * String\n *\n * Inspired by the following work:\n * Mostly-readable text in source - ttg\n * https://www.shadertoy.com/view/Wd2SDt\n */\n\n#define ENCODE_CHARS(a, b, c, d) \\\n    (((a) << 24) | (((b) & 0xFF) << 16) | (((c) & 0xFF) << 8) | ((d) & 0xFF))\n\n#define DECODE_CHARS(x) \\\n    int[4](((x) >> 24) & 0xFF,((x) >> 16) & 0xFF,((x) >> 8) & 0xFF, (x) & 0xFF)\n\n#define ENCODE_STRING_HEADER(f0, f1, f2, f3) \\\n    ENCODE_CHARS(f0, f1, f2, f3)\n\n#define DECODE_STRING_HEADER(header) \\\n    DECODE_CHARS(header)\n\n#define STRING_AT(arr, i) arr[clamp((i), 0, arr.length() - 1)]\n\n#define STRING_ENCODE_CHARS(arr, offs) \\\n    ENCODE_CHARS(STRING_AT(arr, offs + 0), STRING_AT(arr, offs + 1), STRING_AT(arr, offs + 2), STRING_AT(arr, offs + 3))\n\n/*\n * DEF_STRING:\n *   WebGL does not support the token-pasting operator (##), so a temporary\n *   variable must be manually specified.\n *   Let's hope the compiler optimizes away the temporary variable.\n */\n\n// STRING8\n\n#define _DEF_STRING8(var, tmp, f0, f1, f2, f3, arr) \\\n    const int[] tmp = arr; \\\n    const int[] var = int[3](ENCODE_STRING_HEADER(f0, f1, f2, f3), \\\n                             STRING_ENCODE_CHARS(tmp, 0x00), STRING_ENCODE_CHARS(tmp, 0x04));\n\n#define DEF_STRING8_WITH_VALUE(var, tmp, p, d, arr) \\\n    _DEF_STRING8(var, tmp, min(tmp.length(), 8), p, d, 0, arr)\n\n#define DEF_STRING8_WITH_VALUE_AT_START(var, tmp, d, arr) \\\n    DEF_STRING8_WITH_VALUE(var, tmp, 0, d, arr)\n\n#define DEF_STRING8_WITH_VALUE_AT_END(var, tmp, d, arr) \\\n    DEF_STRING8_WITH_VALUE(var, tmp, min(tmp.length(), 8), d, arr)\n\n#define DEF_STRING8(var, tmp, arr) \\\n    DEF_STRING8_WITH_VALUE_AT_END(var, tmp, 1, arr)\n\n// STRING16\n\n#define _DEF_STRING16(var, tmp, f0, f1, f2, f3, arr) \\\n    const int[] tmp = arr; \\\n    const int[] var = int[5](ENCODE_STRING_HEADER(f0, f1, f2, f3), \\\n                             STRING_ENCODE_CHARS(tmp, 0x00), STRING_ENCODE_CHARS(tmp, 0x04), \\\n                             STRING_ENCODE_CHARS(tmp, 0x08), STRING_ENCODE_CHARS(tmp, 0x0C));\n\n#define DEF_STRING16_WITH_VALUE(var, tmp, p, d, arr) \\\n    _DEF_STRING16(var, tmp, min(tmp.length(), 16), p, d, 0, arr)\n\n#define DEF_STRING16_WITH_VALUE_AT_START(var, tmp, d, arr) \\\n    DEF_STRING16_WITH_VALUE(var, tmp, 0, d, arr)\n\n#define DEF_STRING16_WITH_VALUE_AT_END(var, tmp, d, arr) \\\n    DEF_STRING16_WITH_VALUE(var, tmp, min(tmp.length(), 16), d, arr)\n\n#define DEF_STRING16(var, tmp, arr) \\\n    DEF_STRING16_WITH_VALUE_AT_END(var, tmp, 1, arr)\n\n// STRING32\n\n#define _DEF_STRING32(var, tmp, f0, f1, f2, f3, arr) \\\n    const int[] tmp = arr; \\\n    const int[] var = int[9](ENCODE_STRING_HEADER(f0, f1, f2, f3), \\\n                             STRING_ENCODE_CHARS(tmp, 0x00), STRING_ENCODE_CHARS(tmp, 0x04), \\\n                             STRING_ENCODE_CHARS(tmp, 0x08), STRING_ENCODE_CHARS(tmp, 0x0C), \\\n                             STRING_ENCODE_CHARS(tmp, 0x10), STRING_ENCODE_CHARS(tmp, 0x14), \\\n                             STRING_ENCODE_CHARS(tmp, 0x18), STRING_ENCODE_CHARS(tmp, 0x1C));\n\n#define DEF_STRING32_WITH_VALUE(var, tmp, p, d, arr) \\\n    _DEF_STRING32(var, tmp, min(tmp.length(), 32), p, d, 0, arr)\n\n#define DEF_STRING32_WITH_VALUE_AT_START(var, tmp, d, arr) \\\n    DEF_STRING32_WITH_VALUE(var, tmp, 0, d, arr)\n\n#define DEF_STRING32_WITH_VALUE_AT_END(var, tmp, d, arr) \\\n    DEF_STRING32_WITH_VALUE(var, tmp, min(tmp.length(), 32), d, arr)\n\n#define DEF_STRING32(var, tmp, arr) \\\n    DEF_STRING32_WITH_VALUE_AT_END(var, tmp, 1, arr)\n\n// STRING64\n\n#define _DEF_STRING64(var, tmp, f0, f1, f2, f3, arr) \\\n    const int[] tmp = arr; \\\n    const int[] var = int[17](ENCODE_STRING_HEADER(f0, f1, f2, f3), \\\n                              STRING_ENCODE_CHARS(tmp, 0x00), STRING_ENCODE_CHARS(tmp, 0x04), \\\n                              STRING_ENCODE_CHARS(tmp, 0x08), STRING_ENCODE_CHARS(tmp, 0x0C), \\\n                              STRING_ENCODE_CHARS(tmp, 0x10), STRING_ENCODE_CHARS(tmp, 0x14), \\\n                              STRING_ENCODE_CHARS(tmp, 0x18), STRING_ENCODE_CHARS(tmp, 0x1C), \\\n                              STRING_ENCODE_CHARS(tmp, 0x20), STRING_ENCODE_CHARS(tmp, 0x24), \\\n                              STRING_ENCODE_CHARS(tmp, 0x28), STRING_ENCODE_CHARS(tmp, 0x2C), \\\n                              STRING_ENCODE_CHARS(tmp, 0x30), STRING_ENCODE_CHARS(tmp, 0x34), \\\n                              STRING_ENCODE_CHARS(tmp, 0x38), STRING_ENCODE_CHARS(tmp, 0x3C));\n\n#define DEF_STRING64_WITH_VALUE(var, tmp, p, d, arr) \\\n    _DEF_STRING64(var, tmp, min(tmp.length(), 64), p, d, 0, arr)\n\n#define DEF_STRING64_WITH_VALUE_AT_START(var, tmp, d, arr) \\\n    DEF_STRING64_WITH_VALUE(var, tmp, 0, d, arr)\n\n#define DEF_STRING64_WITH_VALUE_AT_END(var, tmp, d, arr) \\\n    DEF_STRING64_WITH_VALUE(var, tmp, min(tmp.length(), 64), d, arr)\n\n#define DEF_STRING64(var, tmp, arr) \\\n    DEF_STRING64_WITH_VALUE_AT_END(var, tmp, 1, arr)\n\n// STRING functions\n\n#define DEF_TEXT_STRING_WITH_VALUE(N, T) \\\n    int text_length(in int[N] string, in T x){ \\\n        return (string[0] >> 24) + text_length(x, (string[0] >> 8) & 0xFF); \\\n    } \\\n    void text_string(in sampler2D sampler, inout TextState ts, in int[N] string, in T x){ \\\n        int[] header = DECODE_STRING_HEADER(string[0]); \\\n        int s_len = header[0]; \\\n        int x_pos = header[1]; \\\n        int min_digits = header[2]; \\\n        if(x_pos == 0){ \\\n            text_value(sampler, ts, x, min_digits); \\\n            text_string(sampler, ts, string); \\\n        }else if(x_pos == s_len){ \\\n            text_string(sampler, ts, string); \\\n            text_value(sampler, ts, x, min_digits); \\\n        }else{ \\\n            text_substring(sampler, ts, string, 0, x_pos); \\\n            text_value(sampler, ts, x, min_digits); \\\n            text_substring(sampler, ts, string, x_pos, s_len - x_pos); \\\n        } \\\n    }\n\n#define DEF_TEXT_STRING(N) \\\n    int text_length(in int[N] string){ \\\n        return string[0] >> 24; \\\n    } \\\n    void text_substring(in sampler2D sampler, inout TextState ts, in int[N] string, in int offset, in int len){ \\\n        ivec2 index = text_map_to_index(ts.pos, ts.hori_offset, ts.vert_offset, ts.scale); \\\n        if(index.x >= len || index.y >= 1){ \\\n            text_advance_pos(ts.pos, ts.hori_offset, ts.scale, len); \\\n            return; \\\n        } \\\n        if(index.x < 0 || index.y < 0){ \\\n            return; \\\n        } \\\n        int offset_index = index.x + offset; \\\n        int code = DECODE_CHARS(string[(offset_index / 4) + 1])[offset_index % 4]; \\\n        text_advance_pos(ts.pos, ts.hori_offset, ts.scale, index.x); \\\n        text_char_internal(sampler, code, ts.pos, ts.hori_offset, ts.vert_offset, ts.scale, ts.dist); \\\n    } \\\n    void text_string(in sampler2D sampler, inout TextState ts, in int[N] string){ \\\n        int[] header = DECODE_STRING_HEADER(string[0]); \\\n        text_substring(sampler, ts, string, 0, header[0]); \\\n    } \\\n    DEF_TEXT_STRING_WITH_VALUE(N, int) \\\n    DEF_TEXT_STRING_WITH_VALUE(N, uint) \\\n    DEF_TEXT_STRING_WITH_VALUE(N, float)\n\nDEF_TEXT_STRING(3)\nDEF_TEXT_STRING(5)\nDEF_TEXT_STRING(9)\nDEF_TEXT_STRING(17)\n\n#endif // ENABLE_STRING\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\n#define FONT_SAMPLER iChannel3\n\nconst float BASE_SIZE = 1024.;\n\n//==============================================================================\n// I/O\n//==============================================================================\n\nfloat load_state(in int id){\n    return load_state(iChannel0, id).w;\n}\n\nbool is_mouse_down(){\n    return iMouse.z > 0.;\n}\n\nbool is_key_down(int code){\n    return texelFetch(iChannel2, ivec2(code, 0), 0).x > 0.;\n}\n\nbool is_key_pressed(int code){\n    return texelFetch(iChannel2, ivec2(code, 1), 0).x > 0.;\n}\n\n//==============================================================================\n// SDF\n//==============================================================================\n\nfloat sd_circle(in vec2 p, in float r){\n    return length(p) - r;\n}\n\nfloat sd_box(vec2 p, vec4 b, float radius){\n    vec2 size = b.zw * 0.5 - vec2(radius);\n    vec2 d = abs(p - b.xy - 0.5 * b.zw) - size;\n\n    return min(max(d.x, d.y), 0.) + length(max(d, 0.)) - radius;\n}\n\n//==============================================================================\n// UI - Label\n//==============================================================================\n\n#define _EOD 0xFF\n\n#define MAKE_LABEL_STRING(n, c0, c1, c2, c3, c4, c5, c6, c7, c8, c9, cA, cB, cC, cD, cE, cF) \\\n    ENCODE_STRING_HEADER(n, n, 1, 0), ENCODE_CHARS(c0, c1, c2, c3), ENCODE_CHARS(c4, c5, c6, c7), ENCODE_CHARS(c8, c9, cA, cB), ENCODE_CHARS(cC, cD, cE, cF)\n\nstruct Label{\n    int header, s0, s1, s2, s3;\n};\n\nvoid text_string(in sampler2D sampler, inout TextState ts, in Label label){\n    int[] string = int[](label.header, label.s0, label.s1, label.s2, label.s3);\n    text_string(sampler, ts, string);\n}\n\nint text_length(in Label label){\n    return label.header >> 24;\n}\n\n//==============================================================================\n// UI - Slider\n//==============================================================================\n\nstruct Slider{\n    vec2 origin;\n    vec2 size;\n    float corner_radius;\n    float lo, hi, step_size, default_value;\n    int min_digits;\n    int sid;\n};\n\nconst vec3 SLIDER_ACTIVE_TRACK_COLOR = vec3(1.);\nconst vec3 SLIDER_INACTIVE_TRACK_COLOR = vec3(0.5);\n\nfloat slider_normalize_value(in Slider s, in float x){\n    return (x - s.lo) / (s.hi - s.lo);\n}\n\nfloat slider_value_horizontal(in Slider s, in float pos){\n    float u = clamp(pos - s.origin.x, 0., s.size.x) / s.size.x;\n\n    return floor(mix(s.lo, s.hi, u) / s.step_size) * s.step_size;\n}\n\nbool slider_contains(in Slider s, in vec2 pos){\n    vec2 p = pos - s.origin;\n\n    return all(greaterThanEqual(p, vec2(0.))) && all(lessThan(p, s.size));\n}\n\nvec3 slider_horizontal(in Slider s, in vec2 pos, in float value, in vec3 color){\n    float u = slider_normalize_value(s, value);\n    vec2 thumb_pos = vec2(u, 0.5) * s.size;\n    float dist;\n\n    dist = sd_box(pos, vec4(s.origin, s.size), s.corner_radius);\n    color = mix(SLIDER_INACTIVE_TRACK_COLOR, color, smoothstep(-2., 2., dist));\n\n    dist = sd_box(pos, vec4(s.origin, thumb_pos.x, s.size.y), s.corner_radius);\n    color = mix(SLIDER_ACTIVE_TRACK_COLOR, color, smoothstep(-2., 2., dist));\n\n    return color;\n}\n\n/**\n * Normalizes the slider scale for consistency across different resolutions.\n */\nSlider slider_normalize_scale(in Slider s, in float base_dim){\n    float factor = base_dim / BASE_SIZE;\n\n    Slider res = s;\n\n    res.origin *= factor;\n    res.size *= factor;\n    res.corner_radius *= factor;\n\n    return res;\n}\n\n//==============================================================================\n// UI - Toggle\n//==============================================================================\n\nstruct Toggle{\n    vec2 origin;\n    vec2 size;\n    float corner_radius;\n    float thumb_radius;\n    bool default_is_on;\n    int sid;\n};\n\nconst vec3 TOGGLE_THUMB_ON_COLOR = vec3(1.);\nconst vec3 TOGGLE_THUMB_OFF_COLOR = vec3(0.75);\nconst vec3 TOGGLE_TRACK_ON_COLOR = vec3(0., 1., 0.);\nconst vec3 TOGGLE_TRACK_OFF_COLOR = vec3(0.5);\n\nbool toggle_contains(in Toggle t, in vec2 pos){\n    vec2 p = pos - t.origin;\n\n    return all(greaterThanEqual(p, vec2(0.))) && all(lessThan(p, t.size));\n}\n\nvec3 toggle_horizontal(in Toggle t, in vec2 pos, in bool is_on, in vec3 color){\n    vec3 thumb_color = is_on ? TOGGLE_THUMB_ON_COLOR : TOGGLE_THUMB_OFF_COLOR;\n    vec3 track_color = is_on ? TOGGLE_TRACK_ON_COLOR : TOGGLE_TRACK_OFF_COLOR;\n    float offset = 1.2 * t.thumb_radius;\n    vec2 thumb_pos = vec2(mix(offset, t.size.x - offset, float(is_on)), 0.5 * t.size.y);\n    float dist;\n\n    dist = sd_box(pos, vec4(t.origin, t.size), t.corner_radius);\n    color = mix(track_color, color, smoothstep(-2., 2., dist));\n\n    dist = sd_circle(pos - (t.origin + thumb_pos), t.thumb_radius);\n    color = mix(thumb_color, color, smoothstep(-2., 2., dist));\n\n    return color;\n}\n\nToggle toggle_normalize_scale(in Toggle t, in float base_dim){\n    float factor = base_dim / BASE_SIZE;\n\n    Toggle res = t;\n\n    res.origin *= factor;\n    res.size *= factor;\n    res.corner_radius *= factor;\n    res.thumb_radius *= factor;\n\n    return res;\n}\n\n//==============================================================================\n// UI - SegmentedControl\n//==============================================================================\n\nstruct SegmentedControl{\n    vec2 origin;\n    vec2 size;\n    float corner_radius;\n    int num_segments;\n    int default_index;\n    int sid;\n};\n\nconst vec3 SEGMENTED_CONTROL_BACKGROUND_COLOR = vec3(0.5);\nconst vec3 SEGMENTED_CONTROL_SELECTED_SEGMENT_COLOR = vec3(1.);\n\nint segmented_control_index(in SegmentedControl s, in float pos){\n    float u = (pos - s.origin.x) / s.size.x;\n\n    return clamp(int(floor(u * float(s.num_segments))), 0, s.num_segments - 1);\n}\n\nbool segmented_control_contains(in SegmentedControl s, in vec2 pos){\n    vec2 p = pos - s.origin;\n\n    return all(greaterThanEqual(p, vec2(0.))) && all(lessThan(p, s.size));\n}\n\nvec3 segmented_control(in SegmentedControl s, in vec2 pos, in int index, in vec3 color){\n    vec2 size = s.size / vec2(s.num_segments, 1);\n    vec2 margin = 0.05 * size;\n    vec2 interior_size = size - 2. * margin;\n    vec2 delta = vec2(size.x, 0.);\n    vec2 origin = s.origin;\n    float dist;\n\n    dist = sd_box(pos, vec4(s.origin, s.size), s.corner_radius);\n    color = mix(SEGMENTED_CONTROL_BACKGROUND_COLOR, color, smoothstep(-1., 1., dist));\n\n    for(int i = 0; i < s.num_segments; i++){\n        vec3 selected_segment_color\n            = mix(SEGMENTED_CONTROL_BACKGROUND_COLOR, SEGMENTED_CONTROL_SELECTED_SEGMENT_COLOR, 0.25 + 0.75 * float(i == index));\n\n        dist = sd_box(pos, vec4(origin + margin, interior_size), s.corner_radius);\n        color = mix(selected_segment_color, color, smoothstep(-1., 1., dist));\n        origin += delta;\n    }\n\n    return color;\n}\n\nSegmentedControl segmented_control_normalize_scale(in SegmentedControl s, in float base_dim){\n    float factor = base_dim / BASE_SIZE;\n\n    SegmentedControl res = s;\n\n    res.origin *= factor;\n    res.size *= factor;\n    res.corner_radius *= factor;\n\n    return res;\n}\n\n//==============================================================================\n\n#define KEY_F1 112\n\nconst Label[] SLIDER_LABELS = Label[](\n    Label(MAKE_LABEL_STRING(8,_S,_l,_i,_d,_e,_r,_SP,_1,_EOD,_EOD,_EOD,_EOD,_EOD,_EOD,_EOD,_EOD)),\n    Label(MAKE_LABEL_STRING(8,_S,_l,_i,_d,_e,_r,_SP,_2,_EOD,_EOD,_EOD,_EOD,_EOD,_EOD,_EOD,_EOD)),\n    Label(MAKE_LABEL_STRING(8,_S,_l,_i,_d,_e,_r,_SP,_3,_EOD,_EOD,_EOD,_EOD,_EOD,_EOD,_EOD,_EOD))\n);\n\nconst Label[] TOGGLE_LABELS = Label[](\n    Label(MAKE_LABEL_STRING(8,_T,_o,_g,_g,_l,_e,_SP,_1,_EOD,_EOD,_EOD,_EOD,_EOD,_EOD,_EOD,_EOD)),\n    Label(MAKE_LABEL_STRING(8,_T,_o,_g,_g,_l,_e,_SP,_2,_EOD,_EOD,_EOD,_EOD,_EOD,_EOD,_EOD,_EOD))\n);\n\nconst Label[] SEG_CTRL_LABELS = Label[](\n    Label(MAKE_LABEL_STRING(9,_S,_e,_g,_C,_t,_r,_l,_SP,_1,_EOD,_EOD,_EOD,_EOD,_EOD,_EOD,_EOD))\n);\n\nconst Slider[] SLIDERS = Slider[](\n    Slider(vec2(20., 350.), vec2(300., 20.), 8., 0.,  1.,  0.01, 0.5, 2, SID_SLIDER_1),\n    Slider(vec2(20., 250.), vec2(300., 20.), 8., 0., 10.,  1.,   5.,  0, SID_SLIDER_2),\n    Slider(vec2(20., 150.), vec2(300., 20.), 8., 0.,  2.,  1.,   0.,  0, SID_SLIDER_3)\n);\n\nconst Toggle[] TOGGLES = Toggle[](\n    Toggle(vec2(1720., 960.), vec2(60., 40.), 16., 16., false, SID_TOGGLE_1),\n    Toggle(vec2(1720., 900.), vec2(60., 40.), 16., 16., true,  SID_TOGGLE_2)\n);\n\nconst SegmentedControl[] SEGMENTED_CONTROLS = SegmentedControl[](\n    SegmentedControl(vec2(20., 50.), vec2(300., 40.), 10., 3, 0, SID_SEG_CTRL_1)\n);\n\nint find_ui_sid(in vec2 pos){\n    // sliders\n    for(int i = 0; i < SLIDERS.length(); i++){\n        Slider s = slider_normalize_scale(SLIDERS[i], iResolution.y);\n\n        if(slider_contains(s, pos))\n            return s.sid;\n    }\n\n    // toggles\n    for(int i = 0; i < TOGGLES.length(); i++){\n        Toggle t = toggle_normalize_scale(TOGGLES[i], iResolution.y);\n\n        if(toggle_contains(t, pos))\n            return t.sid;\n    }\n\n    // segmented controls\n    for(int i = 0; i < SEGMENTED_CONTROLS.length(); i++){\n        SegmentedControl s = segmented_control_normalize_scale(SEGMENTED_CONTROLS[i], iResolution.y);\n\n        if(segmented_control_contains(s, pos))\n            return s.sid;\n    }\n\n    return -1;\n}\n\nbool is_focus_locked(in int active_ui, in vec2 pos){\n    // sliders\n    for(int i = 0; i < SLIDERS.length(); i++){\n        if(SLIDERS[i].sid == active_ui)\n            return true;\n    }\n\n    // toggles\n    for(int i = 0; i < TOGGLES.length(); i++){\n        if(TOGGLES[i].sid != active_ui)\n            continue;\n\n        Toggle t = toggle_normalize_scale(TOGGLES[i], iResolution.y);\n\n        return toggle_contains(t, pos);\n    }\n\n    // segmented controls\n    for(int i = 0; i < SEGMENTED_CONTROLS.length(); i++){\n        if(SEGMENTED_CONTROLS[i].sid != active_ui)\n            continue;\n\n        SegmentedControl s = segmented_control_normalize_scale(SEGMENTED_CONTROLS[i], iResolution.y);\n\n        return segmented_control_contains(s, pos);\n    }\n\n    return false;\n}\n\nfloat handle_hud_visibility_state(){\n    int visibility;\n\n    if(iFrame > 0){\n        visibility = int(load_state(SID_HUD_VISIBILITY));\n        if(is_key_pressed(KEY_F1)){\n            visibility = ~visibility & 0x1;\n        }\n    }else{\n        visibility = 1;\n    }\n\n    return float(visibility);\n}\n\nfloat handle_active_ui_state(in int active_ui, in int hud_visibility){\n    if(iFrame > 0 && hud_visibility > 0){\n        if(iMouse.w > 0.){\n            active_ui = find_ui_sid(iMouse.xy);\n        }else if(iMouse.w < 0. && iMouse.z > 0.){\n            active_ui = is_focus_locked(active_ui, iMouse.xy) ? active_ui : -1;\n        }else if(iMouse.z < 0.){\n            active_ui = -1;\n        }\n    }else{\n        active_ui = -1;\n    }\n\n    return float(active_ui);\n}\n\nfloat handle_slider_state(in int sid){\n    int i = sid - SID_SLIDER_1;\n\n    if(iFrame > 0){\n        int active_ui = int(load_state(SID_ACTIVE_UI));\n\n        if(SLIDERS[i].sid == active_ui){\n            Slider s = slider_normalize_scale(SLIDERS[i], iResolution.y);\n\n            return slider_value_horizontal(s, iMouse.x);\n        }else{\n            return load_state(SLIDERS[i].sid);\n        }\n    }else{\n        return SLIDERS[i].default_value;\n    }\n}\n\nfloat handle_toggle_state(in int sid){\n    int i = sid - SID_TOGGLE_1;\n\n    if(iFrame > 0){\n        int active_ui = int(load_state(SID_ACTIVE_UI));\n\n        if(TOGGLES[i].sid == active_ui && iMouse.z < 0.){\n            return float(!bool(load_state(TOGGLES[i].sid)));\n        }else{\n            return load_state(TOGGLES[i].sid);\n        }\n    }else{\n        return float(TOGGLES[i].default_is_on);\n    }\n}\n\nfloat handle_segmented_control_state(in int sid){\n    int i = sid - SID_SEG_CTRL_1;\n\n    if(iFrame > 0){\n        int active_ui = int(load_state(SID_ACTIVE_UI));\n\n        if(SEGMENTED_CONTROLS[i].sid == active_ui && iMouse.z < 0.){\n            SegmentedControl s = segmented_control_normalize_scale(SEGMENTED_CONTROLS[i], iResolution.y);\n\n            return float(segmented_control_index(s, iMouse.x));\n        }else{\n            return load_state(SEGMENTED_CONTROLS[i].sid);\n        }\n    }else{\n        return float(SEGMENTED_CONTROLS[i].default_index);\n    }\n}\n\nvec3 draw_hud(in vec2 pos){\n    vec3 color = vec3(0.);\n\n    for(int i = 0; i < SLIDERS.length(); i++){\n        Slider s = slider_normalize_scale(SLIDERS[i], iResolution.y);\n        float value = load_state(s.sid);\n\n        color = slider_horizontal(s, pos, value, color);\n    }\n\n    for(int i = 0; i < TOGGLES.length(); i++){\n        Toggle t = toggle_normalize_scale(TOGGLES[i], iResolution.y);\n        bool is_on = bool(load_state(t.sid));\n\n        color = toggle_horizontal(t, pos, is_on, color);\n    }\n\n    for(int i = 0; i < SEGMENTED_CONTROLS.length(); i++){\n        SegmentedControl s = segmented_control_normalize_scale(SEGMENTED_CONTROLS[i], iResolution.y);\n        int index = int(load_state(s.sid));\n\n        color = segmented_control(s, pos, index, color);\n    }\n\n    //========\n\n    vec2 uv = pos / iResolution.y;\n    TextState ts;\n\n    text_init(ts, iResolution.y);\n\n    vec2 raw_char_size = text_raw_char_size(ts);\n\n    text_begin(ts, 0.5);\n\n    vec2 char_size = raw_char_size * ts.scale * iResolution.y;\n\n    for(int i = 0; i < SLIDER_LABELS.length(); i++){\n        Slider s = slider_normalize_scale(SLIDERS[i], iResolution.y);\n        float value = load_state(s.sid);\n        vec2 label_pos = s.origin + vec2(0., s.size.y + char_size.y);\n        vec2 value_pos = s.origin + vec2(s.size.x + char_size.x, 0.5 * (s.size.y + char_size.y));\n\n        text_set_pos(ts, uv, label_pos / iResolution.y);\n        text_string(FONT_SAMPLER, ts, SLIDER_LABELS[i]);\n        text_set_pos(ts, uv, value_pos / iResolution.y);\n        text_value(FONT_SAMPLER, ts, value, s.min_digits);\n    }\n\n    for(int i = 0; i < TOGGLE_LABELS.length(); i++){\n        Toggle t = toggle_normalize_scale(TOGGLES[i], iResolution.y);\n        vec2 label_pos = t.origin + vec2(- 16. * char_size.x, 0.5 * (t.size.y + char_size.y));\n\n        text_set_pos(ts, uv, label_pos / iResolution.y);\n        text_string(FONT_SAMPLER, ts, TOGGLE_LABELS[i]);\n    }\n\n    for(int i = 0; i < SEG_CTRL_LABELS.length(); i++){\n        SegmentedControl s = segmented_control_normalize_scale(SEGMENTED_CONTROLS[i], iResolution.y);\n        vec2 label_pos = s.origin + vec2(0., s.size.y + char_size.y);\n\n        text_set_pos(ts, uv, label_pos / iResolution.y);\n        text_string(FONT_SAMPLER, ts, SEG_CTRL_LABELS[i]);\n    }\n\n    text_end(ts, vec3(1.), vec3(0.3), color);\n\n    return color;\n}\n\n//==============================================================================\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec4 color = vec4(0.);\n    int sid = pos_to_sid(ivec2(fragCoord));\n    int hud_visibility = int(load_state(SID_HUD_VISIBILITY));\n\n    switch(sid){\n    case SID_HUD_VISIBILITY:\n        color.a = handle_hud_visibility_state();\n        hud_visibility = int(color.a);\n        break;\n    case SID_ACTIVE_UI:\n        int active_ui = int(load_state(SID_ACTIVE_UI));\n        color.a = handle_active_ui_state(active_ui, hud_visibility);\n        break;\n    case SID_SLIDER_1:\n    case SID_SLIDER_2:\n    case SID_SLIDER_3:\n        color.a = handle_slider_state(sid);\n        break;\n    case SID_TOGGLE_1:\n    case SID_TOGGLE_2:\n        color.a = handle_toggle_state(sid);\n        break;\n    case SID_SEG_CTRL_1:\n        color.a = handle_segmented_control_state(sid);\n        break;\n    default:\n        break;\n    }\n\n    //========\n\n    // Press F1 to toggle HUD\n    if(hud_visibility > 0){\n        color.rgb = draw_hud(fragCoord);\n    }\n\n    fragColor = color;\n}\n","name":"Buffer A","description":"","type":"buffer"}]}