{"ver":"0.1","info":{"id":"7tKcDz","date":"1661848707","viewed":125,"name":"2D Voroni Cave","username":"sdfgeoff","description":"I need to figure out how to smooth the rock edges. Advice greatly appreciated!","likes":10,"published":1,"flags":0,"usePreview":0,"tags":["terrain","voroni"],"hasliked":0,"parentid":"3dyBzK","parentname":"2D Voroni Terrain"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float rand(vec2 n) { \n\treturn fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\n\n\n/// Returns the position in the cell to use for voroni\nvec2 cell_offset(vec2 cell_id) {\n    return vec2(\n        (rand(cell_id) - 0.5),\n        (rand(cell_id + 13.2980235) - 0.5)\n    ) * 0.9;\n}\n\nvec3 neon(float val, vec3 color) {\n\tfloat r = clamp(val, 0.0, 1.0);\n    float r2 = r * r;\n    float r4 = r2 * r2;\n    float r16 = r4 * r4;\n    vec3 c = color;\n    vec3 c2 = pow(color, vec3(4.0)); // A darker, more saturated version of color\n    \n\tvec3 outp = vec3(0.0);\n\toutp += c2 * r2; // Darker color falloff\n\toutp += c * r4; // Specified Color main part\n\toutp += vec3(1.0) * r16; // White core\n\treturn outp;\n}\n\n\n\n/// Returns the cell ID (x,y), distance to the cell point (z) and distance\n/// from edge (w)\nvec4 voroni_cell(vec2 uv) {\n    vec4 data = vec4(0.0, 0.0, 100.0, 100.0);\n    \n    vec2 closest_point = vec2(0.0);\n\n    for (float i=-1.0; i<=1.0; i+=1.0) {\n        for (float j=-1.0; j<=1.0; j+=1.0) {\n            vec2 this_cell_id = floor(uv) + 0.5 + vec2(i, j);\n            vec2 this_cell_offset = cell_offset(this_cell_id);\n            vec2 this_cell_point = this_cell_id + this_cell_offset;\n            float dist_to_this_cell_point = length(uv - this_cell_point);\n\n            if (dist_to_this_cell_point < data.z) {\n                data.z = dist_to_this_cell_point;\n                data.xy = this_cell_id;\n                closest_point = this_cell_point;\n            }\n        }\n    }\n    for (float i=-1.0; i<=1.0; i+=1.0) {\n        for (float j=-1.0; j<=1.0; j+=1.0) {            \n            vec2 this_cell_id = floor(uv) + 0.5 + vec2(i, j);\n            vec2 this_cell_offset = cell_offset(this_cell_id);\n            vec2 this_cell_point = this_cell_id + this_cell_offset;\n            \n            vec2 point_direction = this_cell_point - closest_point;\n            if (length(point_direction) < 0.001) continue;\n\n            \n            vec2 midpoint = (closest_point + this_cell_point) / 2.0;\n            \n            float len = dot(midpoint - uv, normalize(point_direction));\n            \n            data.w = min(\n                data.w, \n                len\n            );\n        }\n    }\n    return data;\n}\n\n\n\nfloat map(vec2 p) {\n    return abs(p.y * 0.5 - 5.0 + sin(p.x * 0.3)) - 1.0 + sin(p.x * 0.2) * 0.7 + cos(p.y);\n}\n\n\n// x = color, y = filled\nvec2 walls(vec2 p) {\n    vec4 data = voroni_cell(p);\n\n    float filled = 1.0 - map(data.xy) > 0.0 ? 0.0 : 1.0;\n    float edges = clamp((1.0 - data.w * 5.0), 0.0, 1.0);\n    \n    edges *= 1.3 - map(p);\n    return vec2(\n        filled * edges,\n        filled\n    );\n}\n\nfloat background(vec2 p, vec2 l) {\n    vec2 light_vector = (l - p) / 3.0;\n    vec4 data = voroni_cell(p);\n    //data.w = 1.0 - data.z;\n    data.w = rand(data.xy) * data.w;\n\n    data.w = data.w * 0.5 + 0.5;\n    \n    float light_intensity = 1.0 / (dot(light_vector, light_vector) + 1.7);\n    \n    return data.w * light_intensity + light_intensity;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    float scroll = iTime * 3.0;\n    vec2 cam_position = vec2(\n        uv.x * 20.0 + sin(iTime) + scroll,\n        uv.y * 20.0 + sin(iTime * 0.2) * 2.0\n    );\n    vec2 cam_position2 = vec2(\n        uv.x * 25.0 + sin(iTime) + scroll,\n        uv.y * 25.0 + sin(iTime * 0.2) * 2.0\n    );\n    \n    \n    \n\t\n    vec2 light_pos = vec2(5) + vec2(\n        cos(iTime * 0.5) * 10.0 + 15.0 + scroll,\n        sin(iTime * 0.3) * 10.0 + 5.0\n    );\n    \n    vec2 w = walls(cam_position);\n    float b = background(cam_position2, light_pos);\n    vec3 back = neon(pow(b, 0.3), vec3(0.6, 0.4, 0.2));\n    vec3 rocks = neon(pow(clamp(w.x, 0.0, 1.0), 0.5), vec3(0.7, 0.8, 0.8));\n    \n    vec3 outp = rocks + back * vec3(1.0 - w.y);\n    \n    fragColor = vec4(outp, 1.0);\n}","name":"Image","description":"","type":"image"}]}