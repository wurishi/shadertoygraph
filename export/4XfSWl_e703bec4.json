{"ver":"0.1","info":{"id":"4XfSWl","date":"1710175017","viewed":69,"name":"Closest Segment Point - Segment","username":"natevm","description":"Closest point between two segments. Adapted from the work by David Eberly: https://www.geometrictools.com/Documentation/DistanceLine3Line3.pdf\nMore distance queries here: https://www.shadertoy.com/playlist/fcGBWG","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["3d","sdf","capsule","closest"],"hasliked":0,"parentid":"stXXzl","parentname":"Capsule - closest 3D"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// The MIT License\n// Copyright Â© 2024 Nate Morrical\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Returns {distance squared between line and segment, parameter of line, parameter of segment}\nvec3 lineSegmentQuery(in vec3 ro, in vec3 rd, in vec3 s0, in vec3 s1)\n{\n    vec3 sd = s1 - s0;\n    vec3 diff = ro - s0;\n\n    float rdLen2 = dot(rd, rd);\n    float sdLen2 = dot(sd, sd);\n    float raySegmentDot = -dot(rd, sd);\n    float rayStartDot = dot(rd, diff);\n    float segmentStartDot = -dot(sd, diff);\n\n    float det = max(rdLen2 * sdLen2 - raySegmentDot * raySegmentDot, 0.0);\n\n    float tRay = 0.0;\n    float tSegment = 0.0;\n\n    if (det > 0.0) {\n        tSegment = (raySegmentDot * rayStartDot - rdLen2 * segmentStartDot) / det;\n        tSegment = clamp(tSegment, 0.0, 1.0); // Ensure tSegment is within the segment bounds\n        tRay = (raySegmentDot * segmentStartDot - sdLen2 * rayStartDot) / det;\n    } else {\n        // Handle the case when determinant is zero or negative\n        tRay = -rayStartDot / rdLen2;\n    }\n\n    vec3 closestPointOnRay = ro + tRay * rd;\n    vec3 closestPointOnSegment = s0 + tSegment * sd;\n    vec3 differenceVector = closestPointOnRay - closestPointOnSegment;\n    float diffLen2 = dot(differenceVector, differenceVector);\n\n    return vec3(diffLen2, tRay, tSegment);\n}\n  \n  \n// Returns the \"st\" parameters defining the closest points between two segments. \n//  P0 / P1 - the start and end points for the first segment\n//  Q0 / Q1 - the start and end points for the second segment\nvec2 segmentSegmentQuery(vec3 P0, vec3 P1, vec3 Q0, vec3 Q1) {\n    vec3 P1mP0 = P1 - P0;\n    vec3 Q1mQ0 = Q1 - Q0;\n    vec3 P0mQ0 = P0 - Q0;\n    float a = dot(P1mP0, P1mP0);\n    float b = dot(P1mP0, Q1mQ0);\n    float c = dot(Q1mQ0, Q1mQ0);\n    float d = dot(P1mP0, P0mQ0);\n    float e = dot(Q1mQ0, P0mQ0);\n    float det = a * c - b * b;\n    float s, t, nd, bmd, bte, ctd, bpe, ate, btd;\n\n    if (det > 0.)\n    {\n        bte = b * e;\n        ctd = c * d;\n        if (bte <= ctd)  // s <= 0\n        {\n            s = 0.;\n            if (e <= 0.)  // t <= 0\n            {\n                // region 6\n                t = 0.;\n                nd = -d;\n                if (nd >= a)\n                {\n                    s = 1.;\n                }\n                else if (nd > 0.)\n                {\n                    s = nd / a;\n                }\n                // else: s is already zero\n            }\n            else if (e < c)  // 0 < t < 1\n            {\n                // region 5\n                t = e / c;\n            }\n            else  // t >= 1\n            {\n                // region 4\n                t = 1.;\n                bmd = b - d;\n                if (bmd >= a)\n                {\n                    s = 1.;\n                }\n                else if (bmd > 0.)\n                {\n                    s = bmd / a;\n                }\n                // else:  s is already zero\n            }\n        }\n        else  // s > 0\n        {\n            s = bte - ctd;\n            if (s >= det)  // s >= 1\n            {\n                // s = 1\n                s = 1.;\n                bpe = b + e;\n                if (bpe <= 0.)  // t <= 0\n                {\n                    // region 8\n                    t = 0.;\n                    nd = -d;\n                    if (nd <= 0.)\n                    {\n                        s = 0.;\n                    }\n                    else if (nd < a)\n                    {\n                        s = nd / a;\n                    }\n                    // else: s is already one\n                }\n                else if (bpe < c)  // 0 < t < 1\n                {\n                    // region 1\n                    t = bpe / c;\n                }\n                else  // t >= 1\n                {\n                    // region 2\n                    t = 1.;\n                    bmd = b - d;\n                    if (bmd <= 0.)\n                    {\n                        s = 0.;\n                    }\n                    else if (bmd < a)\n                    {\n                        s = bmd / a;\n                    }\n                    // else:  s is already one\n                }\n            }\n            else  // 0 < s < 1\n            {\n                ate = a * e;\n                btd = b * d;\n                if (ate <= btd)  // t <= 0\n                {\n                    // region 7\n                    t = 0.;\n                    nd = -d;\n                    if (nd <= 0.)\n                    {\n                        s = 0.;\n                    }\n                    else if (nd >= a)\n                    {\n                        s = 1.;\n                    }\n                    else\n                    {\n                        s = nd / a;\n                    }\n                }\n                else  // t > 0\n                {\n                    t = ate - btd;\n                    if (t >= det)  // t >= 1\n                    {\n                        // region 3\n                        t = 1.;\n                        bmd = b - d;\n                        if (bmd <= 0.)\n                        {\n                            s = 0.;\n                        }\n                        else if (bmd >= a)\n                        {\n                            s = 1.;\n                        }\n                        else\n                        {\n                            s = bmd / a;\n                        }\n                    }\n                    else  // 0 < t < 1\n                    {\n                        // region 0\n                        s /= det;\n                        t /= det;\n                    }\n                }\n            }\n        }\n    }\n    else\n    {\n        // The segments are parallel. The quadratic factors to\n        //   R(s,t) = a*(s-(b/a)*t)^2 + 2*d*(s - (b/a)*t) + f\n        // where a*c = b^2, e = b*d/a, f = |P0-Q0|^2, and b is not\n        // zero. R is constant along lines of the form s-(b/a)*t = k\n        // and its occurs on the line a*s - b*t + d = 0. This line\n        // must intersect both the s-axis and the t-axis because 'a'\n        // and 'b' are not zero. Because of parallelism, the line is\n        // also represented by -b*s + c*t - e = 0.\n        //\n        // The code determines an edge of the domain [0,1]^2 that\n        // intersects the minimum line, or if none of the edges\n        // intersect, it determines the closest corner to the minimum\n        // line. The conditionals are designed to test first for\n        // intersection with the t-axis (s = 0) using\n        // -b*s + c*t - e = 0 and then with the s-axis (t = 0) using\n        // a*s - b*t + d = 0.\n\n        // When s = 0, solve c*t - e = 0 (t = e/c).\n        if (e <= 0.)  // t <= 0\n        {\n            // Now solve a*s - b*t + d = 0 for t = 0 (s = -d/a).\n            t = 0.;\n            nd = -d;\n            if (nd <= 0.)  // s <= 0\n            {\n                // region 6\n                s = 0.;\n            }\n            else if (nd >= a)  // s >= 1\n            {\n                // region 8\n                s = 1.;\n            }\n            else  // 0 < s < 1\n            {\n                // region 7\n                s = nd / a;\n            }\n        }\n        else if (e >= c)  // t >= 1\n        {\n            // Now solve a*s - b*t + d = 0 for t = 1 (s = (b-d)/a).\n            t = 1.;\n            bmd = b - d;\n            if (bmd <= 0.)  // s <= 0\n            {\n                // region 4\n                s = 0.;\n            }\n            else if (bmd >= a)  // s >= 1\n            {\n                // region 2\n                s = 1.;\n            }\n            else  // 0 < s < 1\n            {\n                // region 3\n                s = bmd / a;\n            }\n        }\n        else  // 0 < t < 1\n        {\n            // The point (0,e/c) is on the line and domain, so we have\n            // one point at which R is a minimum.\n            s = 0.;\n            t = e / c;\n        }\n    }\n\n    return vec2(s, t);\n}\n\n//------------------------------------------------------------\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n\tvec3 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h ) - r;\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdSphere( vec3 p, vec3 cen, float rad )\n{\n    return length(p-cen)-rad;\n}\n\n//------------------------------------------------------------\nconst float rad = 0.5;\nconst vec3 pa = vec3(-0.7,-0.2,0.4);\nconst vec3 pb = vec3( 0.7,0.2,-0.1);\n\nvec2 map( in vec3 pos, bool showCapsule, in vec3 sampleLineStart, in vec3 sampleLineStop )\n{\n\n    vec2 result = segmentSegmentQuery(sampleLineStart, sampleLineStop, pa, pb);\n    vec3 closestPointOnQuery = mix(sampleLineStart, sampleLineStop, result.x);\n    vec3 closestPointOnSurface = mix(pa, pb, result.y);\n    \n    vec2 res = vec2(1e38f);\n    \n    \n    // query surface \n    {\n    float d = sdCapsule( pos, sampleLineStart, sampleLineStop, .015 );\n    if( d<res.x ) res =  vec2( d, 1.0 );\n    }\n    \n    // closest point on query surface\n    {\n    float d = sdSphere( pos, closestPointOnQuery, 0.06 );\n    if( d<res.x ) res = vec2( d, 1.0 );\n    }\n    \n    // surface \n    {\n    float d = sdCapsule( pos, pa, pb, .02 );\n    if( d<res.x ) res =  vec2( d, 5.0 );\n    }\n    \n    // closest point on surface\n    {\n    float d = sdSphere( pos, closestPointOnSurface, 0.06 );\n    if( d<res.x ) res = vec2( d, 4.0 );\n    }\n\n    // segment connecting closest points\n    {\n    float d = sdCapsule( pos, closestPointOnQuery, closestPointOnSurface, 0.015 );\n    if( d<res.x ) res =  vec2( d, 4.0 );\n    }\n    \n    // capsule demonstrating correctness.\n    if (showCapsule){\n    float radius = distance(closestPointOnQuery, closestPointOnSurface);   \n    float d = sdCapsule( pos, sampleLineStart, sampleLineStop, radius );\n    if( d<res.x ) res =  vec2( d, 1.0 );\n    }\n    \n    return res;\n}\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal( in vec3 pos, bool showCapsule, in vec3 sampleLineStart, in vec3 sampleLineStop )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773;\n    const float eps = 0.0005;\n    return normalize( e.xyy*map( pos + e.xyy*eps, showCapsule, sampleLineStart, sampleLineStop ).x + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx*eps, showCapsule, sampleLineStart, sampleLineStop ).x + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy*eps, showCapsule, sampleLineStart, sampleLineStop ).x + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx*eps, showCapsule, sampleLineStart, sampleLineStop ).x );\n}\n\n// https://iquilezles.org/articles/rmshadows\nfloat calcSoftShadow( vec3 ro, vec3 rd, bool showCapsule, in vec3 sampleLineStart, in vec3 sampleLineStop )\n{\n    float res = 1.0;\n    const float tmax = 2.0;\n    float t = 0.001;\n    for( int i=0; i<64; i++ )\n    {\n     \tfloat h = map(ro + t*rd, showCapsule, sampleLineStart, sampleLineStop).x;\n        res = min( res, 64.0*h/t );\n    \tt += clamp(h, 0.01,0.5);\n        if( res<-1.0 || t>tmax ) break;\n        \n    }\n    res = max(res,-1.0);\n    return 0.25*(1.0+res)*(1.0+res)*(2.0-res); // smoothstep, in [-1,1]\n}\n\n#if HW_PERFORMANCE==0\n#define AA 1\n#else\n#define AA 2\n#endif\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 tot = vec3(0.0);\n    #if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (2.0*(fragCoord+o)-iResolution.xy)/iResolution.y;\n        // pixel sample\n        ivec2 samp = ivec2(fragCoord)*AA + ivec2(m,n);\n        // time sample\n        float td = 0.5+0.5*sin(fragCoord.x*114.0)*sin(fragCoord.y*211.1);\n        float time = iTime - 0.5*(1.0/60.0)*(td+float(m*AA+n))/float(AA*AA-1);\n        #else    \n        // pixel coordinates\n        vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n        // pixel sample\n        ivec2 samp = ivec2(fragCoord);\n        // time sample\n        float time = iTime;\n        #endif\n\n        // animate camera\n        float an = 0.25*time + 6.283185*iMouse.x/iResolution.x;\n        vec3 ro = vec3( 2.4*cos(an), 0.7, 2.4*sin(an) );\n        vec3 ta = vec3( 0.0, 0.0, 0.0 );\n\n        // camera matrix\n        vec3 ww = normalize( ta - ro );\n        vec3 uu = normalize( cross(ww,vec3(0.2,1.0,0.0) ) );\n        vec3 vv = normalize( cross(uu,ww));\n\n        // animate query line\n        vec3 sampleLineStart = -sin(time*0.5*vec3(1.0,1.1,1.2)+vec3(4.0,2.0,1.0));\n        vec3 sampleLineStop  = -cos(time*0.5*vec3(1.0,1.1,1.2)+vec3(4.0,2.0,1.0));\n        \n        // Make bounding capsule transparent\n        bool showCapsule = ((samp.x+samp.y+1)&1)==0; \n        \n\t    // create view ray\n        vec3 rd = normalize( p.x*uu + p.y*vv + 1.5*ww );\n\n        // raycast\n        const float tmax = 5.0;\n        float t = 0.0;\n        float m = -1.0;\n        for( int i=0; i<256; i++ )\n        {\n            vec3 pos = ro + t*rd;\n            vec2 hm = map(pos, showCapsule, sampleLineStart, sampleLineStop);\n            m = hm.y;\n            if( hm.x<0.0001 || t>tmax ) break;\n            t += hm.x;\n        }\n    \n        // shade background\n        vec3 col = vec3(0.05)*(1.0-0.2*length(p));\n        \n        // shade objects\n        if( t<tmax )\n        {\n            // geometry\n            vec3  pos = ro + t*rd;\n            vec3  nor = calcNormal(pos, showCapsule, sampleLineStart, sampleLineStop);\n\n            // color\n            vec3  mate = 0.55 + 0.45*cos( m + vec3(0.0,1.0,1.5) );\n            \n            vec2 result = segmentSegmentQuery(sampleLineStart, sampleLineStop, pa, pb);\n            vec3 closestPointOnQuery = mix(sampleLineStart, sampleLineStop, result.x);\n            vec3 closestPointOnSurface = mix(pa, pb, result.y);\n            \n            \n            // show distance isolines on surface\n            if( abs(m-5.0)<0.5 )\n            {\n                float dref = sdCapsule( closestPointOnQuery, pa, pb, .1 );\n                float dsam = length(pos-closestPointOnQuery);\n                mate += 0.25*smoothstep(0.8,0.9,sin((dsam-dref)*100.0))*exp2(-12.0*(dsam-dref)*(dsam-dref));\n            }\n            \n            // Show distance isolines on query\n            if( abs(m-1.0)<0.6 )\n            {                \n                float dref = sdCapsule( closestPointOnSurface, sampleLineStart, sampleLineStop, .1 );\n                float dsam = length(pos-closestPointOnSurface);\n                mate += smoothstep(0.8,0.9,sin((dsam-dref)*80.0))*exp2(-12.0*(dsam-dref)*(dsam-dref));\n            }\n                       \n            // lighting\t\n            col = vec3(0.0);\n            {\n              // key light\n              vec3  lig = normalize(vec3(0.3,0.7,0.2));\n              float dif = clamp( dot(nor,lig), 0.0, 1.0 );\n              if( dif>0.001 ) dif *= calcSoftShadow(pos+nor*0.001,lig, showCapsule, sampleLineStart, sampleLineStop);\n              col += 0.75*mate*vec3(1.0,0.9,0.8)*dif;\n            }\n            {\n              // dome light\n              float dif = 0.5 + 0.5*nor.y;\n              col += 0.75*mate*vec3(0.2,0.3,0.4)*dif;\n            }\n        }\n\n        // gamma        \n        col = pow( col, vec3(0.4545) );\n\t    tot += col;\n    #if AA>1\n    }\n    tot /= float(AA*AA);\n    #endif\n\n    // cheap dithering\n    tot += sin(fragCoord.x*114.0)*sin(fragCoord.y*211.1)/512.0;\n\n\tfragColor = vec4( tot, 1.0 );\n}","name":"Image","description":"","type":"image"}]}