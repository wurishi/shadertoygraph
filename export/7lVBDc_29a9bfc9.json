{"ver":"0.1","info":{"id":"7lVBDc","date":"1665410410","viewed":150,"name":"dbz stars","username":"natnatnat","description":"cheap, scalable, spheremap with definable distance out, practical.\n\nfork of Nebula Clouds by mu6k https://www.shadertoy.com/view/lsBGDt\nused parts/modified Pixel Stars by _Chae4ek_ https://www.shadertoy.com/view/flcSz2\n","likes":7,"published":1,"flags":64,"usePreview":0,"tags":["noise","volume","space","stars"],"hasliked":0,"parentid":"NlGBWc","parentname":"quality stars"},"renderpass":[{"inputs":[{"id":"XlSSWh","filepath":"https://soundcloud.com/fahim-auvro/cha-la-head-cha-la","previewfilepath":"https://soundcloud.com/fahim-auvro/cha-la-head-cha-la","type":"musicstream","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[],"code":"// high quality stars ---- cheap, scalable, spheremap with definable distance out, practical.\n\n// fork of Nebula Clouds by mu6k https://www.shadertoy.com/view/lsBGDt\n// used parts/modified Pixel Stars by _Chae4ek_ https://www.shadertoy.com/view/flcSz2\n\n#define scale (0.72)\n#define distance_out (9.0f)\n\n#define GOLDEN_RATIO (1.61803398874989484820)\n#define GOLDEN_RATIO_ZERO (0.61803398874989484820)\n\n// most of the code has changed, simplified and focused soley on the star spheremap\n// original noise not used any more and replaced with \"Pixel Stars\"\n/////////////////////////\n\n\nfloat rand(in vec3 st) {\n  vec3 r = fract(sin(st) * GOLDEN_RATIO);\n  return fract(r.z * (9999.0 * GOLDEN_RATIO) + r.y * (99.0 * GOLDEN_RATIO) + r.x);\n}\n\nfloat pixel_stars(in vec3 st) {\n  float r = rand(floor(st));\n  return 0.01 + smoothstep(0.995, 1.0, r);\n}\n\n#define ps(st) pixel_stars(st)\n\nfloat stars(in vec3 st, in float d) {\n  float luma = ps(st);\n  \n  luma = mix( mix(luma, ps(st - d), 0.5f),\n              mix(luma, ps(st + d), 0.5f),\n              0.5f );\n              \n  return(luma + texture(iChannel0, vec2(d)).x);\n}\n\n\n/////////////////////////\n\n//functions that build rotation matrixes\nmat2 rotate_2D(float a){float sa = sin(a); float ca = cos(a); return mat2(ca,sa,-sa,ca);}\nmat3 rotate_x(float a){float sa = sin(a); float ca = cos(a); return mat3(1.,.0,.0,    .0,ca,sa,   .0,-sa,ca);}\nmat3 rotate_y(float a){float sa = sin(a); float ca = cos(a); return mat3(ca,.0,sa,    .0,1.,.0,   -sa,.0,ca);}\nmat3 rotate_z(float a){float sa = sin(a); float ca = cos(a); return mat3(ca,sa,.0,    -sa,ca,.0,  .0,.0,1.);}\n\n//background with stars\nfloat background(vec3 dir, float d)\n{\n    d = 1.0f / (1.0f + d*d);\n    \n    float n = stars(scale * (dir*(1.0f - d)*iResolution.y), d);\n    \n\tfloat den = abs(dir.y); den = 1.0-den; den=den*den*den*den; den*=.1;\n\treturn pow(n*0.95f+den,22.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float t = 4. * iTime + 8.0f;\n    \n    vec2 uv = fragCoord.xy / iResolution.yy -vec2(.9,.5);\n\tvec2 m = iMouse.xy*8.0/ iResolution.yy;\n\t//rotation matrix for the camera\n\tmat3 rotmat = rotate_y((t)*.07+m.x)*rotate_x((t)*.031+m.y);\n\t//p is ray position\n\tvec3 p = vec3(.0,.0,-30.0); p*=rotmat;\n\tp += vec3(sin(t),cos(t),sin(t*.25)*29.0+t*7.0-22.0-4.0/((t)*.01+0.01));\n\t//d is ray direction\n\tvec3 d = normalize(vec3(uv*(sin(t*.17)*.2+0.8),1.0-length(uv)*.2));\n\td*=rotmat;\n\tp+=d;\n\t\n    // stars\n\tvec3 color = vec3(background(d,distance_out) + background(-d,distance_out));\n\t\n\tfragColor = vec4(pow(color, vec3(1.0f/2.2f)),1.0);\n\t\n}","name":"Image","description":"","type":"image"}]}