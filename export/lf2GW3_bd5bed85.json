{"ver":"0.1","info":{"id":"lf2GW3","date":"1704825326","viewed":147,"name":"Tree Desert Lonely","username":"spalmer","description":"idk, I needed a new testbed for raymarching that has improved shading,\nand I kind of went off on a tangent with the tree Lindenmayer-system which wound up working better than anticipated","likes":24,"published":1,"flags":0,"usePreview":1,"tags":["raymarch","shading","tree","lsystem","conetrace","plant","softshadow"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// fork of (private) Sinus Fbm Hills http://shadertoy.com/view/3lVyDR\n// fork of Fly Camera's renderer http://shadertoy.com/view/tdsfR4 adding cone tracing 2nd fragment\n// general idea about tree optimization trick thanks to http://shadertoy.com/view/4tKGzD\n\n// not the most realistic shading, this is mostly about\n// showing off the dead tree, being a decent testbed\n// to try things out going forward.  Not necessarily in that order.\n\n#define IZERO min(iFrame, 0)\n\nconst float tau = radians(360.); //2. * acos(-1.); //6.28318531; //\n\n// cos,sin of radians\nvec2 spin(float r)\n{\n    return sin(r + vec2(.25*tau, 0));\n}\n\nmat2 mrot(vec2 s)\n{\n    return mat2(vec4(s.xyyx) * vec4(1,-1,1,1));\n}\n/*\nvec3 vrot(vec3 v, vec3 axis, float angle)\n{ // Rodrigues rotate v around unit axis by angle in radians\n    return mix(dot(axis, v) * axis, v, cos(angle)) + sin(angle) * cross(axis, v);\n}\n\n// idk, sus af\nvec3 shash(vec3 p)\n{\n    return sin(fract(p * 777.) * 3333.);\n}\n\n\nfloat dsphere(vec3 q, float r) // r is radius\n{\n    return length(q) - r;\n}\n\nfloat dbox(vec3 q, vec3 e)\n{\n    q = abs(q) - e;\n\treturn all(lessThan(q, vec3(0))) \n        ? max(max(q.x,q.y),q.z)\n        : length(max(q, 0.));\n}\n\nfloat dseg(vec3 q, vec3 a, vec3 b)\n{\n    q -= a; b -= a; \n    return length(q - clamp(dot(q, b) / dot(b, b), 0., 1.) * b);\n}\n*/\n\n// iq http://iquilezles.org/www/articles/smin/smin.htm\nfloat smin(float a, float b, float k)\n{\n\tfloat h = a - b;\n    return .5 * (a + b - sqrt(h * h + k));\n}\n// the sqrt version is apparently the best\n\nconst float hillheight = 128.;\n\n// bounding clip plane height for entire scene - nothing is taller than this\nconst float hmax = 0.;\n// far clip distance\nconst float tmax = 3e3;\n\nfloat sinFbm1(vec2 p, int octaves)\n{\n    p *= tau / 9. / hillheight; // to scale of largest features\n    const float c = .617 // cos(phi*tau) or cos(Phi*tau) golden angle?\n    , s = sqrt(1. - c * c) // rotation angle\n    , g = .59; // gain or lacunarity factor\n    mat2 m = (1./g) * mat2(c,-s,s,c); // not the greatest random rotation\n    float h = 0., a = 1.;\n    for (int i = octaves; --i >= 0; p = p * m, a *= g)\n        h += sin(p.x) * a;\n    h = .2 * h + .5;\n    return h * hillheight;\n}\n\nfloat HillHeight(vec2 p)\n{\n    return sinFbm1(p, 4);\n}\n\n// iq cheap vertical drop http://shadertoy.com/view/XtyGR1\nfloat dBranch(vec3 p, float l, float w)\n{\n    float h = clamp(p.y / l, 0., 1.),\n\t    d = length(p - vec3(0, l * h, 0));\n    d = d - w * (1. - h);\n    d += .004*sin(8. * atan(p.x,p.z)) * clamp(1. - .04/d, 0., 1.); // waves for bark grain\n    return d;\n}\n\n// TODO consider avoiding rotations entirely using drop from http://shadertoy.com/view/mdBcDw\n\nfloat dTree(vec3 p)\n{\n    const int nl = 6, // max recursion depth\n        nb = 3; // branches per layer\n    const float phi = sqrt(1.25);\n    float l = .7,\n        d2 = dot(p - vec3(0,l,0), p - vec3(0,l,0));\n    // bound sphere for entire tree, careful not to break soft shadows, please!\n    if (d2 > 16.*l*l)\n        return sqrt(d2) - 2.5*l;\n    float w = .08*l/max(1., float(nl)),\n        d = dBranch(p, l, w),\n        seed = .1 + iDate.w*.001; // involving iDate in seed makes it change slightly over time, kind of interesting usually\n    for (int i = 0; i < nl; ++i) {\n        p.y -= l;\n        l *= .8;\n        d -= w;\n        w *= .9;\n        vec3 q = p;\n        float dc = 999.;\n        // query only follows closest branch\n        // so details where branches cross will get lost\n        for (int j = nb; j-- > 0; ) {\n            q.zy *= mrot(spin(phi * tau / 11. + .02 * sin(1.3 * iTime))); // wave slightly in breeze\n            q.xy *= mrot(spin(phi * tau / 8.));\n            q.zx *= mrot(spin(phi * tau / 5.));\n            // any of these *potential* branches may be pruned,\n            // skipped due to some other factor such as seeded hash noise\n            // for a more 'stochastic' L-system.\n            seed = fract(seed * sqrt(1.25) + .5);\n            if (seed < .2) continue;\n            float db = dBranch(q, l, w);\n            if (db < dc) {\n                p = q;\n                dc = db;\n            }\n            //d = smin(d, dc, 2e-5);\n            d = min(d, dc);\n        }\n        //p.yz *= mrot(spin(.1*tau)); // bend\n        //p.xz *= mrot(spin(phi*tau)); // twist\n    }\n    return d;\n}\n\n// So this wound up being interesting enough and fast enough,\n// and remains high enough quality despite some obvious (to me)\n// artifacts where branches interpenetrate each others' areas.\n// Even when twigs get broken strangely, it often appears\n// reasonable anyway or gets lost in the visual chaos.\n// You'd need to examine the tree in detail from other angles to notice.\n// add some leaves and they'll never notice such glitches!\n// I feel like I should post it as an example of efficient\n// low-quality yet high-recursivity SDF of a plant-like fractal\n// structure based on L-system.  But perhaps should hold off until\n// I've explored some more L-system plants and gained more experience.\n// This may not work out well for plants with longer, more curving limbs.\n// I haven't explored any context-sensitive systems yet.\n// This is a glorified koch snowflake, after all.  ;)\n// anything fancier would require a stack and more advanced technique, \n// see mla's koch stuff.\n// my rotations are a chaotic mess, and that turned out ok for this one tree.\n// I still need to explore better 'tree design' parameters.\n// my bark texture is terrible.\n// without leaves, it looks really dead.\n// TODO http://shadertoy.com/view/tsjBW3 or fix http://shadertoy.com/view/tlyGzG\n\nvec3 treepos = vec3(0, -.317*hillheight, -100);\n\n// material ids\nconst int\n  mSky   = 0,\n  mWood  = 1,\n  mHill  = 2;\n\n\nstruct Hit\n{\n    float d; // signed distance to surface\n    int m; // material id\n};\n\nHit Scene(vec3 p)\n{\n    Hit h = Hit(tmax, mSky);\n    if (p.y < hmax + .125 * hillheight) \n    {\n        float\n            dt = dTree(p - treepos),\n        //  r = 1., // ball radius\n        //  or = .5, // other radius\n        //  db = dsphere(p - vec3(0,r,0), r), // ball\n        //  dx = dbox(p - vec3(0,.7,-7.5), vec3(6,.3,.3)), // box\n        //  dc = dseg(p, vec3(-10,or,0), vec3(-10,1.+or,0)) - or, // capsule\n            dp = p.y; // ground plane +Y\n        //dc = min(dc, dseg(p, vec3(10,or+.25,5), vec3(10,or+.25,-5)) - or);\n        // for the hills will probably have to use height not distance :(\n        float dx = (p.y + hillheight - HillHeight(p.xz)) * .7;\n        if (h.d > dx) h = Hit(dx, mHill);\n        if (h.d > dt) h = Hit(dt, mWood);\n    }\n    else h = Hit(p.y - hmax, mSky); // plane approx when high enough\n    //if (h.d > db) h = Hit(db, mRed);\n    //if (h.d > dc) h = Hit(dc, mBlue);\n    return h;\n}\n\n// loop using uniform to limit compile time bloat on complex scene\nvec3 gScene(vec3 p, float h, out Hit hit, int zero)\n{\n    vec3 n, o = vec3(0, 0, h);\n    vec4 s;\n    for (int i = zero + 4; i-- > 0; o = vec3(o.yz, 0))\n        hit = Scene(p + o), s[i] = hit.d;\n    n = s.yzw - s.x;\n    return n;\n}\n\nvec3 norm(vec3 n)\n{\n    float d = dot(n, n);\n    return d < 1e-7 ? vec3(0,1,0) : n / sqrt(d);\n}\n\nvec3 snz(vec3 p)\n{\n    return (sin(p) + sin(p.zxy) + sin(p.yzx)) / 3.;\n}\n\nstruct Marched \n{\n    float t;   // index/time/distance along ray to intersection\n    //int m;     // material id\n    float nmt; // nearest miss index\n    float nma; // nearest miss coverage alpha\n};\n\nMarched March(vec3 ro, vec3 rd, float thresh, float dmax, int iters)\n{\n    // FAKE FAKE FAKE 'heat distortions' in air - it's wrong because it distorts nearby stuff as much as faraway stuff\n    // but this particular scene looks 'more wrong' without any heat distortions\n    // TODO need more mirrorlike mirages hehe\n    vec3 rdw = rd + .0007 * snz(ro + rd * 377. + vec3(0,-19.*iTime,0)); rd = norm(rd);\n    // TODO study http://aty.sdsu.edu/mirages/mirintro.html\n    Marched c = Marched(dmax, dmax, 0.);\n    float t = 0., od = dmax;\n    while (iters-- > 0) {\n        vec3 mp = t * (t < 7. ? rd : rdw) + ro;\n        Hit h = Scene(mp);\n        float d = h.d, ad = abs(d);\n        t += d;\n        float e = thresh * (t - od);\n        if (c.nma < .5 && d > od && od < 1.5 * e) {\n            float a = 1. - (od - .5 * e) / e;\n            if (a * (1. - c.nma) > c.nma) {\n                c.nma = a;\n                c.nmt = t - od;\n            }\n        }\n        //if (ad < abs(c.nmd)) {\n            //c.m = h.m; //, c.nmd = h.d;\n            if (rd.y >= 0. && (ad > dmax\n            \t|| mp.y > hmax)) {\n                t = dmax; break;\n            }\n        \tif (ad < .5 * thresh * t || t >= dmax) {\n        \t\tbreak;\n            }\n        //}\n        od = d;\n    }\n    c.t = t = clamp(t, 0., dmax);\n    return c;\n}\n\n// idea from dila http://shadertoy.com/view/4l23zy\nfloat Shadow(vec3 p, vec3 n, vec3 l, int ssteps)\n{\n    float nl = dot(n, l);\n    if (nl > 1e-4) {\n        p += .003 * (n + l); // self-shadow bias hit position\n        float att = 1.;\n        float t = 0.02;\n        for (; ssteps-- > 0; ) {\n    \t\tfloat d = Scene(t * l + p).d;\n            // fading out ok now, but idk about exponentiation inside loop...\n            // surely can find a cheaper way?!\n            att = min(att, d / t + exp2(.02*t) - 1.);\n            t += max(.02, d);\n        }\n        float sh = 1.; // min shadow factor found so far\n        sh = 12. * att; // soft shadows exposes many artifacts of my scene, must tune carefully\n        //sh += .02; // HACK\n        sh = clamp(sh, 0., 1.);\n        nl *= sh; // fake soft shadow attenuates direct lighting\n    }\n    nl = clamp(nl, 0., 1.);\n    return nl;\n}\n// I chopped it down in Pillars Scene: http://shadertoy.com/view/tt2cWc\n// moved nl stuff out to caller\n/*\nfloat shadow(vec3 p, vec3 l, float tmax, int ssteps)\n{\n    float att = 1., t = 1e-2;\n    for ( ; ssteps-- > 0 && t < tmax; ) {\n        float d = scene(t * l + p).d;\n        att = min(att, d / t + exp2(.02 * t) - 1.);\n        t += max(.02, d);\n    }\n    return clamp(12. * att, 0., 1.);\n}*/\n\n// Voronoi by Shane from http://shadertoy.com/view/Mld3Rn\nfloat Voronoi(vec2 p)\n{    \n\tvec2 g = floor(p), o; p -= g;\t\n\tvec3 d = vec3(1.4); // d.z = distance comparison value, y = 2nd closest, x = closest\n\tfor (int y = -1; y < 2; ++y)\n\t\tfor (int x = -1; x < 2; ++x) {\n\t\t\to = vec2(x, y);\n            o += fract(vec2(32768, 7137) * sin(dot(g + o, vec2(41, 289)))) - p;\n\t\t\td.z = dot(o, o); \n            d.y = max(d.x, min(d.y, d.z));\n            d.x = min(d.x, d.z); \n\t\t}\n    return max(d.y - d.x, 0.);\n}\n\n// compute material (albedo for now) from id\nvec3 Material(int i, vec3 p, inout vec3 n, float d)\n{\n    float tscale = 32.;\n    vec3 a; //, t = abs(sin(tscale*p + .25*tau));\n    float f = 1.; // untextured\n    //f = dot(1. - n * n, t) // triplanar texture\n         //* exp2(-4. * tscale / iResolution.y*d) * .25 // distance fade\n        //+ .5\n    switch (i) {\n      default:\n      //case mSky:   \n          a = vec3(  0  );\n          break;\n      case mWood:\n          a = vec3(  f  ); // too bad I didn't keep track of the UV mapping somehow\n          n = norm(n + .4 * exp2(-1.2 * d) * snz(p * vec3(303,75,303)));\n          break;\n      case mHill:\n          a = mix(vec3(.2,.25,.1), vec3(1), min(1.,exp2(.09*(p.y + hillheight * .3)))) * f;\n          n = n + .4 * exp2(-.4 * d) * snz(245. * p) * snz(147. * p.xzy);\n          if (d < 30.) n.y += max(0., .5 - 2.4 * Voronoi(3.*p.xz));\n          n = norm(n);\n          // TODO needs some voronoi cracks or something\n          break;\n    }\n    return a;\n}\n         \nconst float\n  fogdensity = .001,\n  ambient = .04; // balance between ambient and direct light\n\n// TODO improve atmosphere\nconst vec3\n  csun = vec3( 1., .8, .6) * 3., // light color\n  cmie = vec3(.8,.5,.1), // fake mie\n  csky = vec3(.19, .2, .5); // fake rayleigh, gets dimmed by sun angle though\n\nconst vec3 sunDir = normalize(vec3(-.6,.2,.98));\n\nconst int shadowsteps = 32;\n\nvec3 Light(vec3 p, vec3 v, float d, float rnd)\n{\n    vec3 c = vec3(0), l = sunDir;\n    float h = 3e-4 * (d + 1.), //2e-3 * clamp(d, .01, 100.), //\n      vl = max(0., dot(-v, l));\n    if (d < .98 * tmax && p.y < hmax) {\n        Hit hit;\n        vec3 n = gScene(p, h, hit, IZERO);\n        n = norm(n);\n        int m = /*hit.d > 10. || d >= .9 * tmax ? mSky : */hit.m;\n        vec3 albedo = Material(m, p, n, d);\n        c = albedo;\n        //c *= n * .5 + .5; // DEBUG hit normal\n        float nl = Shadow(p, n, sunDir, /*hit.d, d, rnd,*/ shadowsteps + IZERO);\n        vec3 h = norm(mix(v, l, .5));\n        float nh = max(0., dot(n, h));\n        nh *= pow(nl, .06125); //if (nl < 0.) nh = 0.; //nh *= nl; //\n        float sp = 16.; // how shiny? rocks aren't wet\n        float spec = 1.2 * sp * .038 * pow(nh, sp);\n        // TODO replace with custom illumination\n        float ah = mix(n.y, 1., .5) * ambient; // hemisphere ambient\n        nl *= 1. - ambient; // leave room for ambient factor\n        nl += ah; // * ao; // hemi ambient only where not occluded\n        c *= nl;\n        c += spec;\n    } else { // sky\n        c += .51*pow(vl, 1024.);\n    }\n    float fogscale = fogdensity, // / dmax * 8.5e4; // TODO scale by dmax somehow?\n          fexp = exp2(-fogscale * d);\n    vec3 cfog = (csky // fake optical depth for atmo, fake sky coloration, inscatter color\n        + (1. - fexp) * .7 * pow(clamp(1. - abs(v.y), 0., 1.), 8.) * vec3(1.8,1.9,2) // fake all the things!  distant horizon fog\n        ) * abs(sunDir.y)\n        + .37*pow(vl, 16.) * cmie // fake mie\n        + .51*pow(vl, 256.); // sun disc halo\n    c = mix(cfog, c, fexp) * csun; // simple fog Beer's law (not spectral, extinction&inscatter fused)\n    return c;\n}\n    //c = clamp(c, 0., 1.);\n//    if (hd <-2e-3*d) c = vec3(20,1,0); // DEBUG orange where march penetrated surface - usually only happens in the far distance where rays hit at very shallow angles, presumably due to numerical inaccuracy\n//    if (hd > 2e-3*d) c = vec3(10,0,9); // DEBUG violet where march missed surface\n\n// WAHa_06x36 http://shadertoy.com/view/MssXDn\n// I'm not using it well here\nfloat spike(vec2 q, float confradius, float filmsize)\n{\n    q = abs(q);\n    float aa = .0 / iResolution.x;\n    if (q.y > confradius + aa) return 0.;\n\tfloat y = min(1., q.y / confradius);\n\tfloat d = q.x / filmsize;\n\tfloat x = sqrt(1. - y * y) / (.0001 + d * d) * .00001;\n    x = clamp(x, 0., 1.);\n    //x *= smoothstep(confradius + aa, max(0., confradius - aa), q.y);\n    return x;\n}\n\nconst int marchsteps = 160; //128;//\n\nvec3 Render(vec3 ro, vec3 rd, float rnd, out float depth)\n{\n    Marched mr = March(ro, rd, 2e-3, tmax, marchsteps + IZERO);\n    float t = mr.t; // trace depth to first hit\n    vec3 hp = t * rd + ro,\n      c = Light(hp, -rd, t, rnd);\n    depth = mr.t;\n    if (mr.nma > 0.) {\n        float t2 = mr.nmt; // second fragment for antialiasing\n        vec3 hp2 = t2 * rd + ro,\n          c2 = Light(hp2, -rd, t2, rnd);\n        c = mix(c, c2, mr.nma);\n        depth = mix(t, t2, mr.nma); //t2; // probably not perfect accurate depth blend toward front fragment\n    }\n    vec3 halo = 40.*(rd - sunDir);\n    c += spike(halo.yx, 15., 25.);\n    c += spike(halo.xy, 15., 25.);\n    return c;\n}\n\n// vogel disc based super sampler\n// handles depth of field, blur, antialiasing effects\n// technique only works well for scenes simple enough\n// to be rendered many times per frame; more complex\n// scenes would require a temp buffer and some CoC work.\nvec3 RenderSS(vec3 ro, vec2 q, mat3 cam, float hfovy\n     , int supersamples, float focuscos, float focaldepth\n     , float rnd)\n{\n\tconst float phi = .5*(sqrt(5.) + 1.),\n      temporal = 0., //12., // temporal jitter animation rate?\n      ssgamma = .45; // to sRGB gamut for averaging\n\tvec3 c = vec3(0); float s = sqrt(max(0., 1. - focuscos*focuscos)), tot = 0.;\n\tfor (int i = supersamples; --i >= 0; ) {\n\t\tfloat f = (float(i) + .5) / float(supersamples), //float(i) / (float(supersamples) - .5) //\n\t\t  a = phi * tau * (f + rnd + temporal * fract(iTime)),\n\t\t  omff = 1., //exp2(-4. * f * s) //1.-f*f //sqrt(f) //\n          od;\n\t\tvec2 vogeldisc = sin(a + vec2(.25*tau, 0)) * sqrt(f) * s;\n\t\tvec3 vd = normalize(vec3(q + vogeldisc, 1. / tan(hfovy))),\n\t\t  rd = normalize(cam * vd), // view ray\n\t\t  vj = cam * vec3(vogeldisc,0), // vogel disc jitter in world space\n\t\t  vp = ro - vj * (1. * focaldepth), // + .5/iResolution.y)\n\t\t  rc = Render(vp, rd, fract(rnd + f), od);\n        rc = 1.2 * rc / (rc + .3); // reinhard tonemap+gamma\n\t\tc.rgb += rc * omff; \n        tot += omff;\n\t}\n    c /= tot;\n\treturn c;\n}\n\n// multipurpose DoF and SSAA and temporal motion blur\n// tracing and lighting the scene multiple times\nconst int SSAA = 1; //2; // gets slow\n\n// rotate (a,b) as a 2D vector using s cossin spin unit vector\nvoid rot(inout vec3 a, inout vec3 b, vec2 s)\n{\n    vec3 t = s.x * a + s.y * b;\n    b   =   -s.y * a + s.x * b;\n    a = t;\n}\n\nvec3 Draw(vec2 p, float rnd)\n{\n\tvec2 R = iResolution.xy,\n      q = (p + p - R) / R.y;\n\tivec2 i = ivec2(p);\n\tmat3 view = mat3(1);\n    rot(view[0], view[2], spin( 0.*tau + .5*sin(.1*iTime)));\n    rot(view[1], view[2], spin(.02*tau));\n\tfloat hfovy = tau/14., //radians(30.) //\n\t  focus = cos(hfovy * .5/R.y), //1. //.999996 //\n\t  foclen = 1.;\t\n\tint ss = SSAA;\n    ss = int(float(ss) * min(1., 720. / R.y) + .5); // reduce ss for high resolutions\n\tss = max(ss, 1 + IZERO);\n    return RenderSS(treepos + vec3(0,1,-2), q, view,\n\t   hfovy, ss, focus, foclen, rnd);\n}\n\nvoid mainImage(out vec4 o, vec2 p)\n{\n    float rn = texelFetch(iChannel3, \n                    ivec2(p) % ivec2(iChannelResolution[3].xy), 0).x;\n\tvec3 c = Draw(p, rn);\n    \n\tc += .6 / 256. * rn; // bluenoise dither\n\to = vec4(c, 1);\n}\n","name":"Image","description":"","type":"image"}]}