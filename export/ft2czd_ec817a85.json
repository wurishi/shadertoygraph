{"ver":"0.1","info":{"id":"ft2czd","date":"1650124859","viewed":108,"name":"Revision22 shader showdown final","username":"Exca","description":"Shader made during Revision 2022 shader showdown final.","likes":3,"published":1,"flags":32,"usePreview":0,"tags":["raymarching","revision"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    fragColor = texture(iChannel0, uv);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\nfloat time;\nfloat ffts = 0.0;\nfloat ffti;\nfloat beat;\nfloat beatstep;\nfloat bar;\n\nfloat glow = 0.0;\n\nvec3 getcam( vec3 cam, vec3 target, vec2 uv, float fov)\n{\n  vec3 forward = normalize( target - cam);\n  vec3 right = normalize( cross( vec3(0,1,0), forward));\n  vec3 up = normalize( cross( forward, right));\n  return normalize( forward*fov + uv.y * up + uv.x * right);\n}\n\nfloat sphere(vec3 p , float r)\n{\n  return length(p)-r;\n}\n\nfloat ground(vec3 p, float h)\n{\n  return  p.y-h;\n}\nfloat wall(vec3 p, float x)\n{\n  return p.x-x;\n}\n\nvec3 repeat( vec3 p, vec3 q)\n{\n  return mod(p +0.5*q, q) -q*0.5;\n}\n\nvec3 map( vec3 p)\n{\n  float g = ground(p, 0.0);\n  float wl = wall(p, -4.0);\n  float wr =-wall(p, 4.0);\n  g = min(wl,g);\n  g = min(wr,g);\n\n\n  vec3 bp = repeat( p, vec3( 0.0, 0.0, 10.0));\n  \n  vec3 bounce = vec3( 0.0, -abs(sin(time*1.5)*0.5)-0.5, 0.0);\n  float s = sphere(bp+bounce, 0.5+ffts*15.0);\n\n  vec3 bounce2 = vec3( 2.0, -abs(sin(time*0.5)*1.25)-0.5, 2.0);\n  float s2 = sphere(bp+bounce2, 0.5+ffts*15.0);\n  vec3 bounce3 = vec3( -1.5, -abs(sin(time*1.25)*1.1)-0.5, 0.0);\n  float s3 = sphere(bp+bounce3, 0.5+ffts*15.0);\n  vec3 bounce4 = vec3( 0.7, -abs(sin(time*1.75))-0.5, -3.0);\n  float s4 = sphere(bp+bounce4, 0.5+ffts*15.0);\n\n  s = min( s, s2);\n  s = min( s, s3);\n  s = min( s, s4);\n  \n  \n  float mat = g < s ? 1.0 : 2.0;\n  \n  s = min(g,s);\n  \n  \n  \n  return vec3( s, mat, 1.0);\n}\n\nvec3 march( vec3 cam, vec3 rd, out vec3 p, out float t)\n{\n  for(int i = 0;i  < 250; i++)\n  {\n    p = cam + rd*t;\n    vec3 r = map(p);\n    t += r.x*0.5;\n    if( r.x < 2.0){\n      glow +=0.05;\n    }\n    \n    if(r.x < 0.001){\n      return r;\n    }\n    if(t > 50.0){\n      t = 50.0;\n       return vec3(-1.0);\n    }\n  }\n  return vec3(-1.0);\n}\n\nvec3 normal( vec3 p)\n{\n  vec3 c = map( p);\n  vec2 e = vec2(0.01, 0.0);\n  return normalize( vec3(\n    map(p+e.xyy).r,\n    map(p+e.yxy).r,\n    map(p+e.yyx).r\n  \n  )-c.x);\n}\n\nfloat light(vec3 p, vec3 l, vec3 n)\n{\n  return max(0.0, dot( n, normalize(l-p)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = vec2(gl_FragCoord.x / iResolution.x, gl_FragCoord.y / iResolution.y);\n  vec2 vuv = uv;\n\tuv -= 0.5;\n\tuv /= vec2(iResolution.y / iResolution.x, 1);\n\n  ffts = texture(iChannel1, vec2(0.1,0.5)).r;\n  ffti = iTime;  \n  \n  beat = floor( iTime * 136.0/60.0);\n  beatstep = fract( iTime * 136.0/60.0);\n  bar = floor( beat / 4.0);\n  \n  time = iTime*0.1 + ffti*2.5;\n  \n\tvec3 col = vec3(0.0);\n  vec3 cam = vec3(0,2,2);\n  \n  cam += vec3( sin(bar*3.5)*2.5,abs(sin(bar*1.5)*2.5),sin(bar*2.5)*2.5);\n  \n    \n  vec3 target = vec3(0,1,-5);\n  vec3 light1 = vec3(sin(time)*10.0,10.0,0);\n  float fov = sin(bar*3.1)*1.5 + 3.0;\n  \n  \n  \n  \n  \n  vec3 rd = getcam( cam, target, uv, fov);\n  vec3 p = cam; float t = 0.0;\n  vec3 res = march( cam, rd, p, t);\n  \n    vec3 n = normal(p);\n  \n  if(res.y > 1.5)\n  {\n    vec3 refrd = reflect( rd, n);\n    vec3 refp = p;\n    float reft = 0.0;\n    vec3 refres = march( p + refrd*0.01, refrd, refp, reft);\n    vec3 refn = normal( refp);\n    \n    vec3 refc = vec3(0.0);\n    if(refres.y > 1.5)\n    {\n      vec3 rrefrd = reflect( refrd, n);\n      vec3 rrefp = refp;\n      float rreft = 0.0;\n      vec3  rrefres = march( refp + rrefrd*0.01, rrefrd, rrefp, rreft);\n      vec3 rrefn = normal( rrefp);\n      \n      vec3 refc = vec3(0.0);\n      if(rrefres.y > 1.5)\n      {\n        vec2 pat = vec2(\n          step( mod(time+ rrefp.x+rrefp.y, 1.0), 0.5),\n          step( mod(-time+ rrefp.z, 1.0), 0.5)\n        );\n        \n        refc = mix( vec3(1.0, 0.5, 0.0), vec3(0.0, 0.5, 1.0), pat.x+pat.y) *  vec3(1.0)*(0.5+light(rrefp,light1,rrefn)*0.75);\n        \n      }\n      else\n      {\n        vec2 pat = vec2(\n          step( mod(time+ rrefp.x+rrefp.y, 1.0), 0.5),\n          step( mod(-time+ rrefp.z, 1.0), 0.5)\n        );\n        \n        refc = mix( vec3(1.0, 0.5, 0.0), vec3(0.0, 0.5, 1.0), pat.x+pat.y) *  vec3(1.0)*(0.5+light(rrefp,light1,refn)*0.75);\n        \n      }\n      col = mix(col, refc, 0.5);\n      \n    }\n    else\n    {\n      vec2 pat = vec2(\n        step( mod(time+ refp.x+refp.y, 1.0), 0.5),\n        step( mod(-time+ refp.z, 1.0), 0.5)\n      );\n      \n      col = mix( vec3(1.0, 0.5, 0.0), vec3(0.0, 0.5, 1.0), pat.x+pat.y) *  vec3(1.0)*(0.5+light(refp,light1,refn)*0.75);\n      \n    }\n    col = mix(col, refc, 0.5);\n    \n    \n  }\n  else if(res.y > -0.5){\n    vec2 pat = vec2(\n      step( mod(time+ p.x+p.y, 1.0), 0.5),\n      step( mod(-time+ p.z, 1.0), 0.5)\n    );\n    \n    col = 0.5* mix( vec3(1.0, 0.5, 0.0), vec3(0.0, 0.5, 1.0), pat.x+pat.y) *  vec3(1.0)*(0.5+light(p,light1,n)*0.75);\n  }\n  \n  vec3 previous = texture( iChannel0, vuv).rgb;\n  \n  col += glow*0.1*vec3(1.0, 0.5, 0.0);\n  \n  col += previous * 0.5 + smoothstep(0.0, 0.1, ffts);\n  \n  fragColor = vec4( col, 1.0);\n\n }\n \n \n","name":"Buffer A","description":"","type":"buffer"}]}