{"ver":"0.1","info":{"id":"Xc2yW1","date":"1722274474","viewed":25,"name":"Circle thru 3 Points CGA","username":"spalmer","description":"same thing but done with Conformal Geometric Algebra techniques.\n","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["circle","conformal","three","cga","geometricalgebra","3points"],"hasliked":0,"parentid":"4csyDX","parentname":"three points circle"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// http://shadertoy.com/view/Xc2yW1 by spalmer\n// fork of three points circle by jt  http://shadertoy.com/view/4csyDX\n\n// Implementation of a circle through three points as described in\n// http://euclideanspace.com/maths/geometry/space/nonEuclid/conformal\n\n// The MIT License\n// Copyright (c) 2024 spalmer\n// Copyright (c) 2024 Jakob Thomsen\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n#define draw(q) o *= smoothstep(0.0, length(fwidth(I)), abs(q))\n\n//float sqr(vec2 v)\n//{\n//    return dot(v,v);\n//}\n\nvec2 I; // global HACK so circle_through_three_points can draw()\nvec4 o;\n\n//#define drawV(v) \\\n//    draw(dseg(I, vec2(0), v) - .02)\n\n#define drawP(p) \\\n    draw(length(I - p) - .02)\n\n#define drawL(l) ( \\\n    draw(abs(dot(I, pline2(l).xy) - pline2(l).z)))\n\n#define drawCirc(c) \\\n    draw(length(I - center(c)) - radius(c))\n\n// a circle here can either be finite (draw as circle) or through infinity (draw as line)\n#define drawC(c) \\\n    draw(isinf(radius(c)) ? abs(dot(I, pline2(c).xy) - pline2(c).z) : length(I - center(c)) - radius(c))\n    //drawP(center(c))\n\n#define drawM(m) ( \\\n    m[_1] == 0. \\\n        ? o \\\n        : drawP(vector(m)) \\\n        )\n        // TODO handle circle, line\n\n\n// uses GA geometric algebra from Common\nvec3 circle_through_three_points(vec2 a, vec2 b, vec2 c)\n{\n    M   ma = point(a),\n        mb = point(b),\n        mc = point(c);\n    M result = wedge(wedge(ma, mb), mc); // construct the circle\n    // can normalize any of these multivectors in this crazy conformal geometry, \n    // and it still works, due to the norm etc in center, radius extraction\n    //result = normalized(result);\n    drawC(result); // draw using generalized circle macro while we still have the multivector\n    vec2 p = center(result);\n    float r = radius(result);\n    return vec3(p, r);\n}\n    //drawP(point2(ma));\n    //drawP(point2(mb));\n    //drawP(point2(mc));        \n    //draw(length(I - p) - r);\n    //drawP(p);\n\n\nvoid mainImage(out vec4 O, vec2 v)\n{\n    InitGlobalConstants();\n    \n    vec2 R = iResolution.xy;\n    I = 2.0*(v+v-R)/R.y;\n\n    o = vec4(1);\n    //draw((length(I) - 0.04) * 2.); // where is origin?  small thin circle\n        \n    {\n        vec2 a = vec2(-1.3, -0.2)+0.7*vec2(cos(iTime/2.0),sin(iTime/2.0));\n        vec2 b = vec2(+1.1, -0.7)+0.5*vec2(cos(iTime/3.0),sin(iTime/3.0));\n        vec2 c = vec2(+0.1, +1.4)+0.3*vec2(cos(iTime/5.0),sin(iTime/5.0));\n        \n        draw(length(I - a) - 0.02);\n        draw(length(I - b) - 0.02);\n        draw(length(I - c) - 0.02);\n        \n        vec3 d = circle_through_three_points(a, b, c);\n        //draw(length(I - d.xy) - d.z);\n        draw(length(I - d.xy) - 0.01);\n       #if 0\n        // line thru b c\n        M bc = wedge(wedge(point(b), point(c)), einf);\n        vec3 pbc = pline2(bc);\n        //draw(abs(dot(I, pbc.xy) - pbc.z));\n        drawL(bc);\n        //drawC(bc);\n       #endif\n        //drawCirc(circle(vec2(0), 1.));        \n    }\n    O = o;\n}\n\n// note the 1.3 second (here) compile time!  this is making the compiler infrastructure work hard optimizing these ridiculous expressions.\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// Sure, one could probably optimize more.\n// Just let the compiler toolchain do the optimization!\n\n// this toy only uses 3,1,0 conformal GA\n// but keeping these others just so folks can use them.\n// they're still useful, just not for circles!\n#if 0\n// 2D Projective Geometric Algebra\n// Written by a generator written by enki.\n// http://bivector.net/tools.html?p=2&q=0&r=1\n// Translated to glsl by spalmer.\n\n// PGA\n\n//#define PI 3.14159265358979323846\nfloat PI = radians(180.);\n\n// typedef\n#define PGA2D float[8]\n\n// e0 squares to 0, e1, e2 square to 1\n//char* basis[] = { \"1\",\"e0\",\"e1\",\"e2\",\"e01\",\"e20\",\"e12\",\"e012\" };\nconst int\n    _1 = 0, // scalar\n    _e0 = 1, // 3 vectors\n    _e1 = 2,\n    _e2 = 3,\n    _e01 = 4, // 3 bivectors\n    _e20 = 5,\n    _e12 = 6,\n    _e012 = 7; // pseudoscalar\n\n// ctors\nPGA2D MV0() {\n    PGA2D v;\n    //v[0] = 0.;\n    return v; \n}\n\nPGA2D MVk(float f, int k) {\n    PGA2D v;\n    v[k] = f;\n    return v; \n}\n\nPGA2D MVI(float f) {\n    PGA2D v;\n    for (int i = v.length(); i-- > 0; v[i] = f);\n    return v; \n}\n/*\nPGA2D log(PGA2D v) {\n  //int n=0; \n  //for (int i=0,j=0;i<8;i++) \n  //  if (mvec[i]!=0.0f) { n++; printf(\"%s%0.7g%s\",(j>0)?\" + \":\"\",mvec[i],(i==0)?\"\":basis[i]); j++; };\n  //if (n==0) printf(\"0\");  \n  //printf(\"\\n\"); \n  return v; \n}\n*/\n\n//***********************\n// PGA2D.Reverse : r = ~a\n// Reverse the order of the basis blades.\n//***********************\n//PGA2D operator ~ (PGA2D a) {\nPGA2D rev(PGA2D a) {\n  PGA2D r;\n  r[0]=a[0];\n  r[1]=a[1];\n  r[2]=a[2];\n  r[3]=a[3];\n  r[4]=-a[4];\n  r[5]=-a[5];\n  r[6]=-a[6];\n  r[7]=-a[7];\n  return r;\n}\n\n//***********************\n// PGA2D.Dual : r = !a\n// Poincare duality operator.\n//***********************\n//PGA2D operator ! (PGA2D a) {\nPGA2D dual(PGA2D a) {\n  PGA2D r;\n  r[0]=a[7];\n  r[1]=a[6];\n  r[2]=a[5];\n  r[3]=a[4];\n  r[4]=a[3];\n  r[5]=a[2];\n  r[6]=a[1];\n  r[7]=a[0];\n  return r;\n}\n\n//***********************\n// PGA2D.Conjugate : r = a.Conjugate()\n// Clifford Conjugation\n//***********************\nPGA2D conjugate(PGA2D v) {\n  PGA2D r;\n  r[0]=v[0];\n  r[1]=-v[1];\n  r[2]=-v[2];\n  r[3]=-v[3];\n  r[4]=-v[4];\n  r[5]=-v[5];\n  r[6]=-v[6];\n  r[7]=v[7];\n  return r;\n}\n\n//***********************\n// PGA2D.Involute : r = a.Involute()\n// Main involution\n//***********************\nPGA2D involute(PGA2D v) {\n  PGA2D r;\n  r[0]=v[0];\n  r[1]=-v[1];\n  r[2]=-v[2];\n  r[3]=-v[3];\n  r[4]=v[4];\n  r[5]=v[5];\n  r[6]=v[6];\n  r[7]=-v[7];\n  return r;\n}\n\n//***********************\n// PGA2D.Mul : r = a * b \n// The geometric product.\n//***********************\n//PGA2D operator * (PGA2D a, PGA2D b) {\nPGA2D mul(PGA2D a, PGA2D b) {\n  PGA2D r;\n  r[0]=b[0]*a[0]+b[2]*a[2]+b[3]*a[3]-b[6]*a[6];\n  r[1]=b[1]*a[0]+b[0]*a[1]-b[4]*a[2]+b[5]*a[3]+b[2]*a[4]-b[3]*a[5]-b[7]*a[6]-b[6]*a[7];\n  r[2]=b[2]*a[0]+b[0]*a[2]-b[6]*a[3]+b[3]*a[6];\n  r[3]=b[3]*a[0]+b[6]*a[2]+b[0]*a[3]-b[2]*a[6];\n  r[4]=b[4]*a[0]+b[2]*a[1]-b[1]*a[2]+b[7]*a[3]+b[0]*a[4]+b[6]*a[5]-b[5]*a[6]+b[3]*a[7];\n  r[5]=b[5]*a[0]-b[3]*a[1]+b[7]*a[2]+b[1]*a[3]-b[6]*a[4]+b[0]*a[5]+b[4]*a[6]+b[2]*a[7];\n  r[6]=b[6]*a[0]+b[3]*a[2]-b[2]*a[3]+b[0]*a[6];\n  r[7]=b[7]*a[0]+b[6]*a[1]+b[5]*a[2]+b[4]*a[3]+b[3]*a[4]+b[2]*a[5]+b[1]*a[6]+b[0]*a[7];\n  return r;\n}\n\n//***********************\n// PGA2D.Wedge : r = a ^ b \n// The outer product. (MEET)\n//***********************\n//PGA2D operator ^ (PGA2D a, PGA2D b) {\nPGA2D wedge(PGA2D a, PGA2D b) {\n  PGA2D r;\n  r[0]=b[0]*a[0];\n  r[1]=b[1]*a[0]+b[0]*a[1];\n  r[2]=b[2]*a[0]+b[0]*a[2];\n  r[3]=b[3]*a[0]+b[0]*a[3];\n  r[4]=b[4]*a[0]+b[2]*a[1]-b[1]*a[2]+b[0]*a[4];\n  r[5]=b[5]*a[0]-b[3]*a[1]+b[1]*a[3]+b[0]*a[5];\n  r[6]=b[6]*a[0]+b[3]*a[2]-b[2]*a[3]+b[0]*a[6];\n  r[7]=b[7]*a[0]+b[6]*a[1]+b[5]*a[2]+b[4]*a[3]+b[3]*a[4]+b[2]*a[5]+b[1]*a[6]+b[0]*a[7];\n  return r;\n}\n\n//***********************\n// PGA2D.Vee : r = a & b \n// The regressive product. (JOIN)\n//***********************\n//PGA2D operator & (PGA2D a, PGA2D b) {\nPGA2D vee(PGA2D a, PGA2D b) {\n  PGA2D r;\n  r[7]=(a[7]*b[7]);\n  r[6]=(a[6]*b[7]+a[7]*b[6]);\n  r[5]=(a[5]*b[7]+a[7]*b[5]);\n  r[4]=(a[4]*b[7]+a[7]*b[4]);\n  r[3]=(a[3]*b[7]+a[5]*b[6]-a[6]*b[5]+a[7]*b[3]);\n  r[2]=(a[2]*b[7]-a[4]*b[6]+a[6]*b[4]+a[7]*b[2]);\n  r[1]=(a[1]*b[7]+a[4]*b[5]-a[5]*b[4]+a[7]*b[1]);\n  r[0]=(a[0]*b[7]+a[1]*b[6]+a[2]*b[5]+a[3]*b[4]+a[4]*b[3]+a[5]*b[2]+a[6]*b[1]+a[7]*b[0]);\n  return r;\n}\n\n#define meet(a,b) wedge(a,b)\n#define join(a,b)   vee(a,b)\n\n\n//***********************\n// PGA2D.Dot : r = a | b \n// The inner product.\n//***********************\n//PGA2D operator | (PGA2D a, PGA2D b) {\nPGA2D dp(PGA2D a, PGA2D b) {\n  PGA2D r;\n  r[0]=b[0]*a[0]+b[2]*a[2]+b[3]*a[3]-b[6]*a[6];\n  r[1]=b[1]*a[0]+b[0]*a[1]-b[4]*a[2]+b[5]*a[3]+b[2]*a[4]-b[3]*a[5]-b[7]*a[6]-b[6]*a[7];\n  r[2]=b[2]*a[0]+b[0]*a[2]-b[6]*a[3]+b[3]*a[6];\n  r[3]=b[3]*a[0]+b[6]*a[2]+b[0]*a[3]-b[2]*a[6];\n  r[4]=b[4]*a[0]+b[7]*a[3]+b[0]*a[4]+b[3]*a[7];\n  r[5]=b[5]*a[0]+b[7]*a[2]+b[0]*a[5]+b[2]*a[7];\n  r[6]=b[6]*a[0]+b[0]*a[6];\n  r[7]=b[7]*a[0]+b[0]*a[7];\n  return r;\n}\n\n//***********************\n// PGA2D.Add : r = a + b \n// Multivector addition\n//***********************\n//PGA2D operator + (PGA2D a, PGA2D b) {\nPGA2D add(PGA2D a, PGA2D b) {\n  PGA2D r;\n    r[0] = a[0]+b[0];\n    r[1] = a[1]+b[1];\n    r[2] = a[2]+b[2];\n    r[3] = a[3]+b[3];\n    r[4] = a[4]+b[4];\n    r[5] = a[5]+b[5];\n    r[6] = a[6]+b[6];\n    r[7] = a[7]+b[7];\n  return r;\n}\n\n//***********************\n// PGA2D.Sub : r = a - b \n// Multivector subtraction\n//***********************\n//PGA2D operator - (PGA2D a, PGA2D b) {\nPGA2D sub(PGA2D a, PGA2D b) {\n  PGA2D r;\n    r[0] = a[0]-b[0];\n    r[1] = a[1]-b[1];\n    r[2] = a[2]-b[2];\n    r[3] = a[3]-b[3];\n    r[4] = a[4]-b[4];\n    r[5] = a[5]-b[5];\n    r[6] = a[6]-b[6];\n    r[7] = a[7]-b[7];\n  return r;\n}\n\n//***********************\n// PGA2D.smul : r = a * b \n// scalar/multivector multiplication\n//***********************\n//PGA2D operator * (float a, PGA2D b) {\nPGA2D mul(float a, PGA2D b) {\n  PGA2D r;\n    r[0] = a*b[0];\n    r[1] = a*b[1];\n    r[2] = a*b[2];\n    r[3] = a*b[3];\n    r[4] = a*b[4];\n    r[5] = a*b[5];\n    r[6] = a*b[6];\n    r[7] = a*b[7];\n  return r;\n}\n\n//***********************\n// PGA2D.muls : r = a * b \n// multivector/scalar multiplication\n//***********************\n//PGA2D operator * (PGA2D a, float b) {\nPGA2D mul(PGA2D a, float b) {\n  PGA2D r;\n    r[0] = a[0]*b;\n    r[1] = a[1]*b;\n    r[2] = a[2]*b;\n    r[3] = a[3]*b;\n    r[4] = a[4]*b;\n    r[5] = a[5]*b;\n    r[6] = a[6]*b;\n    r[7] = a[7]*b;\n  return r;\n}\n\n//***********************\n// PGA2D.sadd : r = a + b \n// scalar/multivector addition\n//***********************\n//PGA2D operator + (float a, PGA2D b) {\nPGA2D add(float a, PGA2D b) {\n  PGA2D r;\n    r[0] = a+b[0];\n    r[1] = b[1];\n    r[2] = b[2];\n    r[3] = b[3];\n    r[4] = b[4];\n    r[5] = b[5];\n    r[6] = b[6];\n    r[7] = b[7];\n  return r;\n}\n\n//***********************\n// PGA2D.adds : r = a + b \n// multivector/scalar addition\n//***********************\n//PGA2D operator + (PGA2D a, float b) {\nPGA2D add(PGA2D a, float b) {\n  PGA2D r;\n    r[0] = a[0]+b;\n    r[1] = a[1];\n    r[2] = a[2];\n    r[3] = a[3];\n    r[4] = a[4];\n    r[5] = a[5];\n    r[6] = a[6];\n    r[7] = a[7];\n  return r;\n}\n\n//***********************\n// PGA2D.ssub : r = a - b \n// scalar/multivector subtraction\n//***********************\n//PGA2D operator - (float a, PGA2D b) {\nPGA2D sub(float a, PGA2D b) {\n  PGA2D r;\n    r[0] = a-b[0];\n    r[1] = -b[1];\n    r[2] = -b[2];\n    r[3] = -b[3];\n    r[4] = -b[4];\n    r[5] = -b[5];\n    r[6] = -b[6];\n    r[7] = -b[7];\n  return r;\n}\n\n//***********************\n// PGA2D.subs : r = a - b \n// multivector/scalar subtraction\n//***********************\n//PGA2D operator - (PGA2D a, float b) {\nPGA2D sub(PGA2D a, float b) {\n  PGA2D r;\n    r[0] = a[0]-b;\n    r[1] = a[1];\n    r[2] = a[2];\n    r[3] = a[3];\n    r[4] = a[4];\n    r[5] = a[5];\n    r[6] = a[6];\n    r[7] = a[7];\n  return r;\n}\n\nfloat norm(PGA2D v) { \n    return sqrt(abs(mul(v, conjugate(v))[0])); \n}\nfloat inorm(PGA2D v) {\n    return norm(dual(v)); \n}\nPGA2D normalized(PGA2D v) {\n    return mul(v, 1./norm(v));\n}\n\n// TODO sandwich product Q*P*~Q\n\n// rotor (Euclidean line)\nPGA2D rotor(float angle, PGA2D line) { \n\treturn add(cos(angle/2.), mul(sin(angle/2.), normalized(line)));\n}\n// translator (Ideal line)\nPGA2D translator(float dist, PGA2D line) {\n\treturn add(1., mul(dist/2., line));\n}\n\n\nPGA2D e0, e1, e2, e01, e20, e12, e012;\n\nvoid InitGlobalConstants()\n{\n\te0 = MVk(1.,_e0); //1);\n\te1 = MVk(1.,_e1); //2);\n\te2 = MVk(1.,_e2); //3);\n\te01 = MVk(1.,_e01); //4);\n\te20 = MVk(1.,_e20); //5);\n\te12 = MVk(1.,_e12); //6);\n\te012 = MVk(1.,_e012); //7);\n}\n\n// project blades out to extract regular glsl vector types\nvec2 vector2(PGA2D v) {\n\treturn vec2(v[_e1], v[_e2]);\n}\n\nvec2 point2(PGA2D v) {\n\treturn vec2(v[_e01], v[_e20]); //vector2(dual(v));\n}\n\nvec3 plane2(PGA2D v) {\n\treturn vec3(vector2(v), v[_e0]);\n}\n\n// construct from scalars\n// A plane is defined using its homogenous equation ax + by + cz + d = 0\nPGA2D plane(float a,float b,float c) { \n//\treturn a*e1 + b*e2 + c*e0; \n    return add(add(MVk(a,_e1), MVk(b,_e2)), MVk(c,_e0));\n}\n// A point is just a homogeneous point, euclidean coordinates plus the origin\n// TODO optimize more\nPGA2D point(float x, float y) { \n\t//return add(e12, add(mul(x,e01), mul(y,e02)));\n\t//return dual(add(MVk(x,_e1), MVk(y,_e2))); // must we add 1 also?\n    return add(e12, add(MVk(x,_e01), MVk(y,_e20)));\n}\n\n// for our toy problem (generate points on the surface of a torus)\n// we start with a function that generates motors.\n// circle(t) with t going from 0 to 1.\nPGA2D circle(float t, float radius, PGA2D line) {\n  return mul(rotor(t*2.*PI,line), translator(radius,rev(e01))); // wedge(e1,e0) = e1^e0 = rev(e01) or MVk(-1., _e01)\n}\n\n/*\nint ExercisePGA2D() {\n  InitGlobalConstants();\n  //printf(\"e0*e0         : \"); log(mul(e0,e0));\n  //printf(\"pss           : \"); log(e012);\n  //printf(\"pss*pss       : \"); log(mul(e012,e012));\n  return 0;\n}\n*/\n\n#elif 0\n// I still think CGA2D has some potential but would need to work out how to embed the null and infinite basis vectors into it\n\n// CGA\n// 2D Conformal Geometric Algebra\n// Written by a generator written by enki.\n// http://bivector.net/tools.html?p=2&q=1&r=1\n// Translated to glsl by spalmer.\n\n//#define PI 3.14159265358979323846\nfloat PI = radians(180.);\n\n// e0 squares to 0, e1, e2 square to 1, e3 squares to -1\n//char* basis[] = { \"1\",\"e0\",\"e1\",\"e2\",\"e3\",\"e01\",\"e02\",\"e03\",\"e12\",\"e13\",\"e23\",\"e012\",\"e013\",\"e023\",\"e123\",\"e0123\" }\nconst int\n    _1 = 0, // scalar\n    _e0 = 1, // 4 vectors\n    _e1 = 2,\n    _e2 = 3,\n\t_e3 = 4,\n    _e01 = 5, // 6 bivectors\n    _e02 = 6,\n\t_e03 = 7,\n\t_e12 = 8,\n\t_e13 = 9,\n\t_e23 = 10,\n\t_e012 = 11, // 4 trivectors\n\t_e013 = 12,\n\t_e023 = 13,\n\t_e123 = 14,\n    _e0123 = 15; // pseudoscalar\n\n#define CGA2D float[16]\n\n// ctors\nCGA2D MV0() {\n    CGA2D v;\n    //v[0] = 0.;\n    return v; \n}\n\nCGA2D MVk(float f, int k) {\n    CGA2D v;\n    v[k] = f;\n    return v; \n}\n\nCGA2D MVI(float f) {\n    CGA2D v;\n    for (int i = v.length(); i-- > 0; v[i] = f);\n    return v; \n}\n/*\nCGA2D log(CGA2D v) {\n int n=0; \n //for (int i=0,j=0;i<16;i++) if (mvec[i]!=0.) { n++; printf(\"%s%0.7g%s\",(j>0)?\" + \":\"\",mvec[i],(i==0)?\"\":basis[i]); j++; }if (n==0) printf(\"0\");  printf(\"\\n\"); \n return v; \n}\n*/\n\n//***********************\n// CGA2D.Reverse : res = ~a\n// Reverse the order of the basis blades.\n//***********************\n//CGA2D operator ~ (CGA2D a) {\nCGA2D rev(CGA2D a) {\n  CGA2D res;\n  res[0]=a[0];\n  res[1]=a[1];\n  res[2]=a[2];\n  res[3]=a[3];\n  res[4]=a[4];\n  res[5]=-a[5];\n  res[6]=-a[6];\n  res[7]=-a[7];\n  res[8]=-a[8];\n  res[9]=-a[9];\n  res[10]=-a[10];\n  res[11]=-a[11];\n  res[12]=-a[12];\n  res[13]=-a[13];\n  res[14]=-a[14];\n  res[15]=a[15];\n  return res;\n}\n\n//***********************\n// CGA2D.Dual : res = !a\n// Poincare duality operator.\n//***********************\n//CGA2D operator ! (CGA2D a) {\nCGA2D dual(CGA2D a) {\n  CGA2D res;\n  res[0]=a[15];\n  res[1]=a[14];\n  res[2]=a[13];\n  res[3]=a[12];\n  res[4]=a[11];\n  res[5]=a[10];\n  res[6]=a[9];\n  res[7]=a[8];\n  res[8]=a[7];\n  res[9]=a[6];\n  res[10]=a[5];\n  res[11]=a[4];\n  res[12]=a[3];\n  res[13]=a[2];\n  res[14]=a[1];\n  res[15]=a[0];\n  return res;\n}\n\n//***********************\n// CGA2D.Conjugate : res = a.Conjugate()\n// Clifford Conjugation\n//***********************\nCGA2D conjugate(CGA2D v) {\n  CGA2D res;\n  res[0]=v[0];\n  res[1]=-v[1];\n  res[2]=-v[2];\n  res[3]=-v[3];\n  res[4]=-v[4];\n  res[5]=-v[5];\n  res[6]=-v[6];\n  res[7]=-v[7];\n  res[8]=-v[8];\n  res[9]=-v[9];\n  res[10]=-v[10];\n  res[11]=v[11];\n  res[12]=v[12];\n  res[13]=v[13];\n  res[14]=v[14];\n  res[15]=v[15];\n  return res;\n}\n\n//***********************\n// CGA2D.Involute : res = a.Involute()\n// Main involution\n//***********************\nCGA2D involute(CGA2D v) {\n  CGA2D res;\n  res[0]=v[0];\n  res[1]=-v[1];\n  res[2]=-v[2];\n  res[3]=-v[3];\n  res[4]=-v[4];\n  res[5]=v[5];\n  res[6]=v[6];\n  res[7]=v[7];\n  res[8]=v[8];\n  res[9]=v[9];\n  res[10]=v[10];\n  res[11]=-v[11];\n  res[12]=-v[12];\n  res[13]=-v[13];\n  res[14]=-v[14];\n  res[15]=v[15];\n  return res;\n}\n\n//***********************\n// CGA2D.Mul : res = a * b \n// The geometric product.\n//***********************\n//CGA2D operator * (CGA2D a, CGA2D b) {\nCGA2D mul(CGA2D a, CGA2D b) {\n  CGA2D res;\n  res[0]=b[0]*a[0]+b[2]*a[2]+b[3]*a[3]-b[4]*a[4]-b[8]*a[8]+b[9]*a[9]+b[10]*a[10]+b[14]*a[14];\n  res[1]=b[1]*a[0]+b[0]*a[1]-b[5]*a[2]-b[6]*a[3]+b[7]*a[4]+b[2]*a[5]+b[3]*a[6]-b[4]*a[7]-b[11]*a[8]+b[12]*a[9]+b[13]*a[10]-b[8]*a[11]+b[9]*a[12]+b[10]*a[13]-b[15]*a[14]+b[14]*a[15];\n  res[2]=b[2]*a[0]+b[0]*a[2]-b[8]*a[3]+b[9]*a[4]+b[3]*a[8]-b[4]*a[9]+b[14]*a[10]+b[10]*a[14];\n  res[3]=b[3]*a[0]+b[8]*a[2]+b[0]*a[3]+b[10]*a[4]-b[2]*a[8]-b[14]*a[9]-b[4]*a[10]-b[9]*a[14];\n  res[4]=b[4]*a[0]+b[9]*a[2]+b[10]*a[3]+b[0]*a[4]-b[14]*a[8]-b[2]*a[9]-b[3]*a[10]-b[8]*a[14];\n  res[5]=b[5]*a[0]+b[2]*a[1]-b[1]*a[2]+b[11]*a[3]-b[12]*a[4]+b[0]*a[5]-b[8]*a[6]+b[9]*a[7]+b[6]*a[8]-b[7]*a[9]+b[15]*a[10]+b[3]*a[11]-b[4]*a[12]+b[14]*a[13]-b[13]*a[14]+b[10]*a[15];\n  res[6]=b[6]*a[0]+b[3]*a[1]-b[11]*a[2]-b[1]*a[3]-b[13]*a[4]+b[8]*a[5]+b[0]*a[6]+b[10]*a[7]-b[5]*a[8]-b[15]*a[9]-b[7]*a[10]-b[2]*a[11]-b[14]*a[12]-b[4]*a[13]+b[12]*a[14]-b[9]*a[15];\n  res[7]=b[7]*a[0]+b[4]*a[1]-b[12]*a[2]-b[13]*a[3]-b[1]*a[4]+b[9]*a[5]+b[10]*a[6]+b[0]*a[7]-b[15]*a[8]-b[5]*a[9]-b[6]*a[10]-b[14]*a[11]-b[2]*a[12]-b[3]*a[13]+b[11]*a[14]-b[8]*a[15];\n  res[8]=b[8]*a[0]+b[3]*a[2]-b[2]*a[3]-b[14]*a[4]+b[0]*a[8]+b[10]*a[9]-b[9]*a[10]-b[4]*a[14];\n  res[9]=b[9]*a[0]+b[4]*a[2]-b[14]*a[3]-b[2]*a[4]+b[10]*a[8]+b[0]*a[9]-b[8]*a[10]-b[3]*a[14];\n  res[10]=b[10]*a[0]+b[14]*a[2]+b[4]*a[3]-b[3]*a[4]-b[9]*a[8]+b[8]*a[9]+b[0]*a[10]+b[2]*a[14];\n  res[11]=b[11]*a[0]+b[8]*a[1]-b[6]*a[2]+b[5]*a[3]+b[15]*a[4]+b[3]*a[5]-b[2]*a[6]-b[14]*a[7]+b[1]*a[8]+b[13]*a[9]-b[12]*a[10]+b[0]*a[11]+b[10]*a[12]-b[9]*a[13]+b[7]*a[14]-b[4]*a[15];\n  res[12]=b[12]*a[0]+b[9]*a[1]-b[7]*a[2]+b[15]*a[3]+b[5]*a[4]+b[4]*a[5]-b[14]*a[6]-b[2]*a[7]+b[13]*a[8]+b[1]*a[9]-b[11]*a[10]+b[10]*a[11]+b[0]*a[12]-b[8]*a[13]+b[6]*a[14]-b[3]*a[15];\n  res[13]=b[13]*a[0]+b[10]*a[1]-b[15]*a[2]-b[7]*a[3]+b[6]*a[4]+b[14]*a[5]+b[4]*a[6]-b[3]*a[7]-b[12]*a[8]+b[11]*a[9]+b[1]*a[10]-b[9]*a[11]+b[8]*a[12]+b[0]*a[13]-b[5]*a[14]+b[2]*a[15];\n  res[14]=b[14]*a[0]+b[10]*a[2]-b[9]*a[3]+b[8]*a[4]+b[4]*a[8]-b[3]*a[9]+b[2]*a[10]+b[0]*a[14];\n  res[15]=b[15]*a[0]+b[14]*a[1]-b[13]*a[2]+b[12]*a[3]-b[11]*a[4]+b[10]*a[5]-b[9]*a[6]+b[8]*a[7]+b[7]*a[8]-b[6]*a[9]+b[5]*a[10]+b[4]*a[11]-b[3]*a[12]+b[2]*a[13]-b[1]*a[14]+b[0]*a[15];\n  return res;\n}\n\n//***********************\n// CGA2D.Wedge : res = a ^ b \n// The outer product. (MEET)\n//***********************\n//CGA2D operator ^ (CGA2D a, CGA2D b) {\nCGA2D wedge(CGA2D a, CGA2D b) {\n  CGA2D res;\n  res[0]=b[0]*a[0];\n  res[1]=b[1]*a[0]+b[0]*a[1];\n  res[2]=b[2]*a[0]+b[0]*a[2];\n  res[3]=b[3]*a[0]+b[0]*a[3];\n  res[4]=b[4]*a[0]+b[0]*a[4];\n  res[5]=b[5]*a[0]+b[2]*a[1]-b[1]*a[2]+b[0]*a[5];\n  res[6]=b[6]*a[0]+b[3]*a[1]-b[1]*a[3]+b[0]*a[6];\n  res[7]=b[7]*a[0]+b[4]*a[1]-b[1]*a[4]+b[0]*a[7];\n  res[8]=b[8]*a[0]+b[3]*a[2]-b[2]*a[3]+b[0]*a[8];\n  res[9]=b[9]*a[0]+b[4]*a[2]-b[2]*a[4]+b[0]*a[9];\n  res[10]=b[10]*a[0]+b[4]*a[3]-b[3]*a[4]+b[0]*a[10];\n  res[11]=b[11]*a[0]+b[8]*a[1]-b[6]*a[2]+b[5]*a[3]+b[3]*a[5]-b[2]*a[6]+b[1]*a[8]+b[0]*a[11];\n  res[12]=b[12]*a[0]+b[9]*a[1]-b[7]*a[2]+b[5]*a[4]+b[4]*a[5]-b[2]*a[7]+b[1]*a[9]+b[0]*a[12];\n  res[13]=b[13]*a[0]+b[10]*a[1]-b[7]*a[3]+b[6]*a[4]+b[4]*a[6]-b[3]*a[7]+b[1]*a[10]+b[0]*a[13];\n  res[14]=b[14]*a[0]+b[10]*a[2]-b[9]*a[3]+b[8]*a[4]+b[4]*a[8]-b[3]*a[9]+b[2]*a[10]+b[0]*a[14];\n  res[15]=b[15]*a[0]+b[14]*a[1]-b[13]*a[2]+b[12]*a[3]-b[11]*a[4]+b[10]*a[5]-b[9]*a[6]+b[8]*a[7]+b[7]*a[8]-b[6]*a[9]+b[5]*a[10]+b[4]*a[11]-b[3]*a[12]+b[2]*a[13]-b[1]*a[14]+b[0]*a[15];\n  return res;\n}\n\n//***********************\n// CGA2D.Vee : res = a & b \n// The regressive product. (JOIN)\n//***********************\n//CGA2D operator & (CGA2D a, CGA2D b) {\nCGA2D vee(CGA2D a, CGA2D b) {\n  CGA2D res;\n  res[15]=1.*(a[15]*b[15]);\n  res[14]=-1.*(a[14]*-1.*b[15]+a[15]*b[14]*-1.);\n  res[13]=1.*(a[13]*b[15]+a[15]*b[13]);\n  res[12]=-1.*(a[12]*-1.*b[15]+a[15]*b[12]*-1.);\n  res[11]=1.*(a[11]*b[15]+a[15]*b[11]);\n  res[10]=1.*(a[10]*b[15]+a[13]*b[14]*-1.-a[14]*-1.*b[13]+a[15]*b[10]);\n  res[9]=-1.*(a[9]*-1.*b[15]+a[12]*-1.*b[14]*-1.-a[14]*-1.*b[12]*-1.+a[15]*b[9]*-1.);\n  res[8]=1.*(a[8]*b[15]+a[11]*b[14]*-1.-a[14]*-1.*b[11]+a[15]*b[8]);\n  res[7]=1.*(a[7]*b[15]+a[12]*-1.*b[13]-a[13]*b[12]*-1.+a[15]*b[7]);\n  res[6]=-1.*(a[6]*-1.*b[15]+a[11]*b[13]-a[13]*b[11]+a[15]*b[6]*-1.);\n  res[5]=1.*(a[5]*b[15]+a[11]*b[12]*-1.-a[12]*-1.*b[11]+a[15]*b[5]);\n  res[4]=-1.*(a[4]*-1.*b[15]+a[7]*b[14]*-1.-a[9]*-1.*b[13]+a[10]*b[12]*-1.+a[12]*-1.*b[10]-a[13]*b[9]*-1.+a[14]*-1.*b[7]+a[15]*b[4]*-1.);\n  res[3]=1.*(a[3]*b[15]+a[6]*-1.*b[14]*-1.-a[8]*b[13]+a[10]*b[11]+a[11]*b[10]-a[13]*b[8]+a[14]*-1.*b[6]*-1.+a[15]*b[3]);\n  res[2]=-1.*(a[2]*-1.*b[15]+a[5]*b[14]*-1.-a[8]*b[12]*-1.+a[9]*-1.*b[11]+a[11]*b[9]*-1.-a[12]*-1.*b[8]+a[14]*-1.*b[5]+a[15]*b[2]*-1.);\n  res[1]=1.*(a[1]*b[15]+a[5]*b[13]-a[6]*-1.*b[12]*-1.+a[7]*b[11]+a[11]*b[7]-a[12]*-1.*b[6]*-1.+a[13]*b[5]+a[15]*b[1]);\n  res[0]=1.*(a[0]*b[15]+a[1]*b[14]*-1.-a[2]*-1.*b[13]+a[3]*b[12]*-1.-a[4]*-1.*b[11]+a[5]*b[10]-a[6]*-1.*b[9]*-1.+a[7]*b[8]+a[8]*b[7]-a[9]*-1.*b[6]*-1.+a[10]*b[5]+a[11]*b[4]*-1.-a[12]*-1.*b[3]+a[13]*b[2]*-1.-a[14]*-1.*b[1]+a[15]*b[0]);\n  return res;\n}\n\n#define meet(a,b) wedge(a,b)\n#define join(a,b)   vee(a,b)\n\n//***********************\n// CGA2D.Dot : res = a | b \n// The inner product.\n//***********************\n//CGA2D operator | (CGA2D a, CGA2D b) {\nCGA2D dp(CGA2D a, CGA2D b) {\n  CGA2D res;\n  res[0]=b[0]*a[0]+b[2]*a[2]+b[3]*a[3]-b[4]*a[4]-b[8]*a[8]+b[9]*a[9]+b[10]*a[10]+b[14]*a[14];\n  res[1]=b[1]*a[0]+b[0]*a[1]-b[5]*a[2]-b[6]*a[3]+b[7]*a[4]+b[2]*a[5]+b[3]*a[6]-b[4]*a[7]-b[11]*a[8]+b[12]*a[9]+b[13]*a[10]-b[8]*a[11]+b[9]*a[12]+b[10]*a[13]-b[15]*a[14]+b[14]*a[15];\n  res[2]=b[2]*a[0]+b[0]*a[2]-b[8]*a[3]+b[9]*a[4]+b[3]*a[8]-b[4]*a[9]+b[14]*a[10]+b[10]*a[14];\n  res[3]=b[3]*a[0]+b[8]*a[2]+b[0]*a[3]+b[10]*a[4]-b[2]*a[8]-b[14]*a[9]-b[4]*a[10]-b[9]*a[14];\n  res[4]=b[4]*a[0]+b[9]*a[2]+b[10]*a[3]+b[0]*a[4]-b[14]*a[8]-b[2]*a[9]-b[3]*a[10]-b[8]*a[14];\n  res[5]=b[5]*a[0]+b[11]*a[3]-b[12]*a[4]+b[0]*a[5]+b[15]*a[10]+b[3]*a[11]-b[4]*a[12]+b[10]*a[15];\n  res[6]=b[6]*a[0]-b[11]*a[2]-b[13]*a[4]+b[0]*a[6]-b[15]*a[9]-b[2]*a[11]-b[4]*a[13]-b[9]*a[15];\n  res[7]=b[7]*a[0]-b[12]*a[2]-b[13]*a[3]+b[0]*a[7]-b[15]*a[8]-b[2]*a[12]-b[3]*a[13]-b[8]*a[15];\n  res[8]=b[8]*a[0]-b[14]*a[4]+b[0]*a[8]-b[4]*a[14];\n  res[9]=b[9]*a[0]-b[14]*a[3]+b[0]*a[9]-b[3]*a[14];\n  res[10]=b[10]*a[0]+b[14]*a[2]+b[0]*a[10]+b[2]*a[14];\n  res[11]=b[11]*a[0]+b[15]*a[4]+b[0]*a[11]-b[4]*a[15];\n  res[12]=b[12]*a[0]+b[15]*a[3]+b[0]*a[12]-b[3]*a[15];\n  res[13]=b[13]*a[0]-b[15]*a[2]+b[0]*a[13]+b[2]*a[15];\n  res[14]=b[14]*a[0]+b[0]*a[14];\n  res[15]=b[15]*a[0]+b[0]*a[15];\n  return res;\n}\n\n//***********************\n// CGA2D.Add : res = a + b \n// Multivector addition\n//***********************\n//CGA2D operator + (CGA2D a, CGA2D b) {\nCGA2D add(CGA2D a, CGA2D b) {\n  CGA2D res;\n    res[0] = a[0]+b[0];\n    res[1] = a[1]+b[1];\n    res[2] = a[2]+b[2];\n    res[3] = a[3]+b[3];\n    res[4] = a[4]+b[4];\n    res[5] = a[5]+b[5];\n    res[6] = a[6]+b[6];\n    res[7] = a[7]+b[7];\n    res[8] = a[8]+b[8];\n    res[9] = a[9]+b[9];\n    res[10] = a[10]+b[10];\n    res[11] = a[11]+b[11];\n    res[12] = a[12]+b[12];\n    res[13] = a[13]+b[13];\n    res[14] = a[14]+b[14];\n    res[15] = a[15]+b[15];\n  return res;\n}\n\n//***********************\n// CGA2D.Sub : res = a - b \n// Multivector subtraction\n//***********************\n//CGA2D operator - (CGA2D a, CGA2D b) {\nCGA2D sub(CGA2D a, CGA2D b) {\n  CGA2D res;\n    res[0] = a[0]-b[0];\n    res[1] = a[1]-b[1];\n    res[2] = a[2]-b[2];\n    res[3] = a[3]-b[3];\n    res[4] = a[4]-b[4];\n    res[5] = a[5]-b[5];\n    res[6] = a[6]-b[6];\n    res[7] = a[7]-b[7];\n    res[8] = a[8]-b[8];\n    res[9] = a[9]-b[9];\n    res[10] = a[10]-b[10];\n    res[11] = a[11]-b[11];\n    res[12] = a[12]-b[12];\n    res[13] = a[13]-b[13];\n    res[14] = a[14]-b[14];\n    res[15] = a[15]-b[15];\n  return res;\n}\n\n//***********************\n// CGA2D.smul : res = a * b \n// scalar/multivector multiplication\n//***********************\n//CGA2D operator * (float a, CGA2D b) {\nCGA2D mul(float a, CGA2D b) {\n  CGA2D res;\n    res[0] = a*b[0];\n    res[1] = a*b[1];\n    res[2] = a*b[2];\n    res[3] = a*b[3];\n    res[4] = a*b[4];\n    res[5] = a*b[5];\n    res[6] = a*b[6];\n    res[7] = a*b[7];\n    res[8] = a*b[8];\n    res[9] = a*b[9];\n    res[10] = a*b[10];\n    res[11] = a*b[11];\n    res[12] = a*b[12];\n    res[13] = a*b[13];\n    res[14] = a*b[14];\n    res[15] = a*b[15];\n  return res;\n}\n\n//***********************\n// CGA2D.muls : res = a * b \n// multivector/scalar multiplication\n//***********************\n//CGA2D operator * (CGA2D a, float b) {\nCGA2D mul(CGA2D a, float b) {\n  CGA2D res;\n    res[0] = a[0]*b;\n    res[1] = a[1]*b;\n    res[2] = a[2]*b;\n    res[3] = a[3]*b;\n    res[4] = a[4]*b;\n    res[5] = a[5]*b;\n    res[6] = a[6]*b;\n    res[7] = a[7]*b;\n    res[8] = a[8]*b;\n    res[9] = a[9]*b;\n    res[10] = a[10]*b;\n    res[11] = a[11]*b;\n    res[12] = a[12]*b;\n    res[13] = a[13]*b;\n    res[14] = a[14]*b;\n    res[15] = a[15]*b;\n  return res;\n}\n\n//***********************\n// CGA2D.sadd : res = a + b \n// scalar/multivector addition\n//***********************\n//CGA2D operator + (float a, CGA2D b) {\nCGA2D add(float a, CGA2D b) {\n  CGA2D res;\n    res[0] = a+b[0];\n    res[1] = b[1];\n    res[2] = b[2];\n    res[3] = b[3];\n    res[4] = b[4];\n    res[5] = b[5];\n    res[6] = b[6];\n    res[7] = b[7];\n    res[8] = b[8];\n    res[9] = b[9];\n    res[10] = b[10];\n    res[11] = b[11];\n    res[12] = b[12];\n    res[13] = b[13];\n    res[14] = b[14];\n    res[15] = b[15];\n  return res;\n}\n\n//***********************\n// CGA2D.adds : res = a + b \n// multivector/scalar addition\n//***********************\n//CGA2D operator + (CGA2D a, float b) {\nCGA2D add(CGA2D a, float b) {\n  CGA2D res;\n    res[0] = a[0]+b;\n    res[1] = a[1];\n    res[2] = a[2];\n    res[3] = a[3];\n    res[4] = a[4];\n    res[5] = a[5];\n    res[6] = a[6];\n    res[7] = a[7];\n    res[8] = a[8];\n    res[9] = a[9];\n    res[10] = a[10];\n    res[11] = a[11];\n    res[12] = a[12];\n    res[13] = a[13];\n    res[14] = a[14];\n    res[15] = a[15];\n  return res;\n}\n\n//***********************\n// CGA2D.ssub : res = a - b \n// scalar/multivector subtraction\n//***********************\n//CGA2D operator - (float a, CGA2D b) {\nCGA2D sub(float a, CGA2D b) {\n  CGA2D res;\n    res[0] = a-b[0];\n    res[1] = -b[1];\n    res[2] = -b[2];\n    res[3] = -b[3];\n    res[4] = -b[4];\n    res[5] = -b[5];\n    res[6] = -b[6];\n    res[7] = -b[7];\n    res[8] = -b[8];\n    res[9] = -b[9];\n    res[10] = -b[10];\n    res[11] = -b[11];\n    res[12] = -b[12];\n    res[13] = -b[13];\n    res[14] = -b[14];\n    res[15] = -b[15];\n  return res;\n}\n\n//***********************\n// CGA2D.subs : res = a - b \n// multivector/scalar subtraction\n//***********************\n//CGA2D operator - (CGA2D a, float b) {\nCGA2D sub(CGA2D a, float b) {\n  CGA2D res;\n    res[0] = a[0]-b;\n    res[1] = a[1];\n    res[2] = a[2];\n    res[3] = a[3];\n    res[4] = a[4];\n    res[5] = a[5];\n    res[6] = a[6];\n    res[7] = a[7];\n    res[8] = a[8];\n    res[9] = a[9];\n    res[10] = a[10];\n    res[11] = a[11];\n    res[12] = a[12];\n    res[13] = a[13];\n    res[14] = a[14];\n    res[15] = a[15];\n  return res;\n}\n\n\nfloat norm(CGA2D v) { \n\treturn sqrt(abs(mul(v, conjugate(v))[0]));\n}\nfloat inorm(CGA2D v) { \n\treturn norm(dual(v));\n}\nCGA2D normalized(CGA2D v) { \n\treturn mul(v, 1./norm(v));\n}\n\n// TODO sandwich product Q*P*~Q   >>>\n\n// rotor (Euclidean line)\nCGA2D rotor(float angle, CGA2D line) { \n\treturn add(cos(angle/2.), mul(sin(angle/2.), normalized(line)));\n}\n// translator (Ideal line)\nCGA2D translator(float dist, CGA2D line) {\n\treturn add(1., mul(dist/2., line));\n}\n\n\n\nCGA2D e0, e1, e2, e3, e01, e02, e03, e12, e13, e23, e012, e013, e023, e123, e0123;\n\nvoid InitGlobalConstants()\n{\n\te0 = MVk(1.,1);\n\te1 = MVk(1.,2);\n\te2 = MVk(1.,3);\n\te3 = MVk(1.,4);\n\te01 = MVk(1.,5);\n\te02 = MVk(1.,6);\n\te03 = MVk(1.,7);\n\te12 = MVk(1.,8);\n\te13 = MVk(1.,9);\n\te23 = MVk(1.,10);\n\te012 = MVk(1.,11);\n\te013 = MVk(1.,12);\n\te023 = MVk(1.,13);\n\te123 = MVk(1.,14);\n\te0123 = MVk(1.,15);\n}\n\n// project blades out to extract regular glsl vector types\nvec2 vector2(CGA2D v) {\n    return vec2(v[_e1], v[_e2]);\n}\n\nvec2 point2(CGA2D v) {\n    return vec2(v[_e01], v[_e02]); //vector2(dual(v));\n}\n\nvec3 plane2(CGA2D v) {\n    return vec3(vector2(v), v[_e0]);\n}\n\nvec2 trivector2(CGA2D v) {\n    return vec2(v[_e013], v[_e023]);\n}\n\n// construct from scalars\n// A plane is defined using its homogenous equation ax + by + cz + d = 0\nCGA2D plane(float a,float b,float c) { \n//\treturn a*e1 + b*e2 + c*e0; \n    return add(add(MVk(a,_e1), MVk(b,_e2)), MVk(c,_e0));\n}\n// A point is just a homogeneous point, euclidean coordinates plus the origin\n// TODO optimize more\nCGA2D point(float x, float y) { \n    //return add(e12, add(mul(x,e01), mul(y,e02)));\n    //return dual(add(MVk(x,_e1), MVk(y,_e2))); // must we add 1 also?\n    return add(e12, add(MVk(x,_e01), MVk(y,_e02)));\n}\n/*\nint ExerciseCGA2D() {\n  InitGlobalConstants();\n  //printf(\"e0*e0         : \"); \n  log(mul(e0, e0));\n  //printf(\"pss           : \"); \n  log(e0123);\n  //printf(\"pss*pss       : \"); \n  log(mul(e0123, e0123));\n\n  return 0;\n}\n*/\n#elif 1\n// actually I think I should be using 3,1,0\n\n// 2D Conformal Geometric Algebra\n// Written by a generator written by enki.\n// http://bivector.net/tools.html?p=3&q=1&r=0\n// ported to glsl by spalmer\n\n//#define PI 3.14159265358979323846\nconst float PI = radians(180.);\n\n// e1, e2, e3 square to 1, e4 squares to -1.  the null basis e0 and infinity basis einf are defined below using e3 and e4.\n//const char* basis[] = { \"1\",\"e1\",\"e2\",\"e3\",\"e4\",\"e12\",\"e13\",\"e14\",\"e23\",\"e24\",\"e34\",\"e123\",\"e124\",\"e134\",\"e234\",\"e1234\" }\n// basis indices\nconst int\n\t_1 = 0,\n\t_e1 = 1,\n\t_e2 = 2,\n\t_e3 = 3,\n\t_e4 = 4,\n\t_e12 = 5,\n\t_e13 = 6,\n\t_e14 = 7,\n\t_e23 = 8,\n\t_e24 = 9,\n\t_e34 = 10,\n\t_e123 = 11,\n\t_e124 = 12,\n\t_e134 = 13,\n\t_e234 = 14,\n\t_e1234 = 15;\n\n#define CGA2M float[16]\n\n// ctors\nCGA2M MV0() {\n    CGA2M v;\n    //v[0] = 0.;\n    return v; \n}\n\nCGA2M MVk(float f, int k) {\n    CGA2M v;\n    v[k] = f;\n    return v; \n}\n\nCGA2M MVI(float f) {\n    CGA2M v;\n    for (int i = v.length(); i-- > 0; v[i] = f);\n    return v; \n}\n\n\n/*\nCGA2M log(CGA2M v) {\n\tint n=0; \n\tfor (int i=0,j=0;i<16;i++) \n\tif (mvec[i]!=0.0f) { \n\t\tn++; \n\t\tprintf(\"%s%0.7g%s\",(j>0)?\" + \":\"\",mvec[i],(i==0)?\"\":basis[i]); \n\t\tj++; \n\t}\n\tif (n==0) printf(\"0\");  \n\tprintf(\"\\n\"); \n\treturn *this; \n}\n*/\n\n//***********************\n// CGA2M.Reverse : res = ~a\n// Reverse the order of the basis blades.\n//***********************\n//CGA2M operator ~ (CGA2M a) {\nCGA2M rev(CGA2M a) {\n  CGA2M res;\n  res[0]=a[0];\n  res[1]=a[1];\n  res[2]=a[2];\n  res[3]=a[3];\n  res[4]=a[4];\n  res[5]=-a[5];\n  res[6]=-a[6];\n  res[7]=-a[7];\n  res[8]=-a[8];\n  res[9]=-a[9];\n  res[10]=-a[10];\n  res[11]=-a[11];\n  res[12]=-a[12];\n  res[13]=-a[13];\n  res[14]=-a[14];\n  res[15]=a[15];\n  return res;\n}\n\n//***********************\n// CGA2M.Dual : res = !a\n// Poincare duality operator.\n//***********************\n//CGA2M operator ! (CGA2M a) {\nCGA2M dual(CGA2M a) {\n  CGA2M res;\n  res[0]=-a[15];\n  res[1]=-a[14];\n  res[2]=a[13];\n  res[3]=-a[12];\n  res[4]=-a[11];\n  res[5]=a[10];\n  res[6]=-a[9];\n  res[7]=-a[8];\n  res[8]=a[7];\n  res[9]=a[6];\n  res[10]=-a[5];\n  res[11]=a[4];\n  res[12]=a[3];\n  res[13]=-a[2];\n  res[14]=a[1];\n  res[15]=a[0];\n  return res;\n}\n\n//***********************\n// CGA2M.Conjugate : res = a.Conjugate()\n// Clifford Conjugation\n//***********************\n//CGA2M CGA2M::Conjugate () {\nCGA2M conjugate(CGA2M v) {\n  CGA2M res;\n  res[0]=v[0];\n  res[1]=-v[1];\n  res[2]=-v[2];\n  res[3]=-v[3];\n  res[4]=-v[4];\n  res[5]=-v[5];\n  res[6]=-v[6];\n  res[7]=-v[7];\n  res[8]=-v[8];\n  res[9]=-v[9];\n  res[10]=-v[10];\n  res[11]=v[11];\n  res[12]=v[12];\n  res[13]=v[13];\n  res[14]=v[14];\n  res[15]=v[15];\n  return res;\n}\n\n//***********************\n// CGA2M.Involute : res = a.Involute()\n// Main involution\n//***********************\nCGA2M involute(CGA2M v) {\n  CGA2M res;\n  res[0]=v[0];\n  res[1]=-v[1];\n  res[2]=-v[2];\n  res[3]=-v[3];\n  res[4]=-v[4];\n  res[5]=v[5];\n  res[6]=v[6];\n  res[7]=v[7];\n  res[8]=v[8];\n  res[9]=v[9];\n  res[10]=v[10];\n  res[11]=-v[11];\n  res[12]=-v[12];\n  res[13]=-v[13];\n  res[14]=-v[14];\n  res[15]=v[15];\n  return res;\n}\n\n//***********************\n// CGA2M.Mul : res = a * b \n// The geometric product.\n//***********************\n//CGA2M operator * (CGA2M a, CGA2M b) {\nCGA2M mul(CGA2M a, CGA2M b) {\n  CGA2M res;\n  res[0]=b[0]*a[0]+b[1]*a[1]+b[2]*a[2]+b[3]*a[3]-b[4]*a[4]-b[5]*a[5]-b[6]*a[6]+b[7]*a[7]-b[8]*a[8]+b[9]*a[9]+b[10]*a[10]-b[11]*a[11]+b[12]*a[12]+b[13]*a[13]+b[14]*a[14]-b[15]*a[15];\n  res[1]=b[1]*a[0]+b[0]*a[1]-b[5]*a[2]-b[6]*a[3]+b[7]*a[4]+b[2]*a[5]+b[3]*a[6]-b[4]*a[7]-b[11]*a[8]+b[12]*a[9]+b[13]*a[10]-b[8]*a[11]+b[9]*a[12]+b[10]*a[13]-b[15]*a[14]+b[14]*a[15];\n  res[2]=b[2]*a[0]+b[5]*a[1]+b[0]*a[2]-b[8]*a[3]+b[9]*a[4]-b[1]*a[5]+b[11]*a[6]-b[12]*a[7]+b[3]*a[8]-b[4]*a[9]+b[14]*a[10]+b[6]*a[11]-b[7]*a[12]+b[15]*a[13]+b[10]*a[14]-b[13]*a[15];\n  res[3]=b[3]*a[0]+b[6]*a[1]+b[8]*a[2]+b[0]*a[3]+b[10]*a[4]-b[11]*a[5]-b[1]*a[6]-b[13]*a[7]-b[2]*a[8]-b[14]*a[9]-b[4]*a[10]-b[5]*a[11]-b[15]*a[12]-b[7]*a[13]-b[9]*a[14]+b[12]*a[15];\n  res[4]=b[4]*a[0]+b[7]*a[1]+b[9]*a[2]+b[10]*a[3]+b[0]*a[4]-b[12]*a[5]-b[13]*a[6]-b[1]*a[7]-b[14]*a[8]-b[2]*a[9]-b[3]*a[10]-b[15]*a[11]-b[5]*a[12]-b[6]*a[13]-b[8]*a[14]+b[11]*a[15];\n  res[5]=b[5]*a[0]+b[2]*a[1]-b[1]*a[2]+b[11]*a[3]-b[12]*a[4]+b[0]*a[5]-b[8]*a[6]+b[9]*a[7]+b[6]*a[8]-b[7]*a[9]+b[15]*a[10]+b[3]*a[11]-b[4]*a[12]+b[14]*a[13]-b[13]*a[14]+b[10]*a[15];\n  res[6]=b[6]*a[0]+b[3]*a[1]-b[11]*a[2]-b[1]*a[3]-b[13]*a[4]+b[8]*a[5]+b[0]*a[6]+b[10]*a[7]-b[5]*a[8]-b[15]*a[9]-b[7]*a[10]-b[2]*a[11]-b[14]*a[12]-b[4]*a[13]+b[12]*a[14]-b[9]*a[15];\n  res[7]=b[7]*a[0]+b[4]*a[1]-b[12]*a[2]-b[13]*a[3]-b[1]*a[4]+b[9]*a[5]+b[10]*a[6]+b[0]*a[7]-b[15]*a[8]-b[5]*a[9]-b[6]*a[10]-b[14]*a[11]-b[2]*a[12]-b[3]*a[13]+b[11]*a[14]-b[8]*a[15];\n  res[8]=b[8]*a[0]+b[11]*a[1]+b[3]*a[2]-b[2]*a[3]-b[14]*a[4]-b[6]*a[5]+b[5]*a[6]+b[15]*a[7]+b[0]*a[8]+b[10]*a[9]-b[9]*a[10]+b[1]*a[11]+b[13]*a[12]-b[12]*a[13]-b[4]*a[14]+b[7]*a[15];\n  res[9]=b[9]*a[0]+b[12]*a[1]+b[4]*a[2]-b[14]*a[3]-b[2]*a[4]-b[7]*a[5]+b[15]*a[6]+b[5]*a[7]+b[10]*a[8]+b[0]*a[9]-b[8]*a[10]+b[13]*a[11]+b[1]*a[12]-b[11]*a[13]-b[3]*a[14]+b[6]*a[15];\n  res[10]=b[10]*a[0]+b[13]*a[1]+b[14]*a[2]+b[4]*a[3]-b[3]*a[4]-b[15]*a[5]-b[7]*a[6]+b[6]*a[7]-b[9]*a[8]+b[8]*a[9]+b[0]*a[10]-b[12]*a[11]+b[11]*a[12]+b[1]*a[13]+b[2]*a[14]-b[5]*a[15];\n  res[11]=b[11]*a[0]+b[8]*a[1]-b[6]*a[2]+b[5]*a[3]+b[15]*a[4]+b[3]*a[5]-b[2]*a[6]-b[14]*a[7]+b[1]*a[8]+b[13]*a[9]-b[12]*a[10]+b[0]*a[11]+b[10]*a[12]-b[9]*a[13]+b[7]*a[14]-b[4]*a[15];\n  res[12]=b[12]*a[0]+b[9]*a[1]-b[7]*a[2]+b[15]*a[3]+b[5]*a[4]+b[4]*a[5]-b[14]*a[6]-b[2]*a[7]+b[13]*a[8]+b[1]*a[9]-b[11]*a[10]+b[10]*a[11]+b[0]*a[12]-b[8]*a[13]+b[6]*a[14]-b[3]*a[15];\n  res[13]=b[13]*a[0]+b[10]*a[1]-b[15]*a[2]-b[7]*a[3]+b[6]*a[4]+b[14]*a[5]+b[4]*a[6]-b[3]*a[7]-b[12]*a[8]+b[11]*a[9]+b[1]*a[10]-b[9]*a[11]+b[8]*a[12]+b[0]*a[13]-b[5]*a[14]+b[2]*a[15];\n  res[14]=b[14]*a[0]+b[15]*a[1]+b[10]*a[2]-b[9]*a[3]+b[8]*a[4]-b[13]*a[5]+b[12]*a[6]-b[11]*a[7]+b[4]*a[8]-b[3]*a[9]+b[2]*a[10]+b[7]*a[11]-b[6]*a[12]+b[5]*a[13]+b[0]*a[14]-b[1]*a[15];\n  res[15]=b[15]*a[0]+b[14]*a[1]-b[13]*a[2]+b[12]*a[3]-b[11]*a[4]+b[10]*a[5]-b[9]*a[6]+b[8]*a[7]+b[7]*a[8]-b[6]*a[9]+b[5]*a[10]+b[4]*a[11]-b[3]*a[12]+b[2]*a[13]-b[1]*a[14]+b[0]*a[15];\n  return res;\n}\n\n//***********************\n// CGA2M.Wedge : res = a ^ b \n// The outer product. (MEET)\n//***********************\n//CGA2M operator ^ (CGA2M a, CGA2M b) {\nCGA2M wedge(CGA2M a, CGA2M b) {\n  CGA2M res;\n  res[0]=b[0]*a[0];\n  res[1]=b[1]*a[0]+b[0]*a[1];\n  res[2]=b[2]*a[0]+b[0]*a[2];\n  res[3]=b[3]*a[0]+b[0]*a[3];\n  res[4]=b[4]*a[0]+b[0]*a[4];\n  res[5]=b[5]*a[0]+b[2]*a[1]-b[1]*a[2]+b[0]*a[5];\n  res[6]=b[6]*a[0]+b[3]*a[1]-b[1]*a[3]+b[0]*a[6];\n  res[7]=b[7]*a[0]+b[4]*a[1]-b[1]*a[4]+b[0]*a[7];\n  res[8]=b[8]*a[0]+b[3]*a[2]-b[2]*a[3]+b[0]*a[8];\n  res[9]=b[9]*a[0]+b[4]*a[2]-b[2]*a[4]+b[0]*a[9];\n  res[10]=b[10]*a[0]+b[4]*a[3]-b[3]*a[4]+b[0]*a[10];\n  res[11]=b[11]*a[0]+b[8]*a[1]-b[6]*a[2]+b[5]*a[3]+b[3]*a[5]-b[2]*a[6]+b[1]*a[8]+b[0]*a[11];\n  res[12]=b[12]*a[0]+b[9]*a[1]-b[7]*a[2]+b[5]*a[4]+b[4]*a[5]-b[2]*a[7]+b[1]*a[9]+b[0]*a[12];\n  res[13]=b[13]*a[0]+b[10]*a[1]-b[7]*a[3]+b[6]*a[4]+b[4]*a[6]-b[3]*a[7]+b[1]*a[10]+b[0]*a[13];\n  res[14]=b[14]*a[0]+b[10]*a[2]-b[9]*a[3]+b[8]*a[4]+b[4]*a[8]-b[3]*a[9]+b[2]*a[10]+b[0]*a[14];\n  res[15]=b[15]*a[0]+b[14]*a[1]-b[13]*a[2]+b[12]*a[3]-b[11]*a[4]+b[10]*a[5]-b[9]*a[6]+b[8]*a[7]+b[7]*a[8]-b[6]*a[9]+b[5]*a[10]+b[4]*a[11]-b[3]*a[12]+b[2]*a[13]-b[1]*a[14]+b[0]*a[15];\n  return res;\n}\n\n//***********************\n// CGA2M.Vee : res = a & b \n// The regressive product. (JOIN)\n//***********************\n//CGA2M operator & (CGA2M a, CGA2M b) {\nCGA2M vee(CGA2M a, CGA2M b) {\n  CGA2M res;\n  res[15]=1.*(a[15]*b[15]);\n  res[14]=-1.*(a[14]*-1.*b[15]+a[15]*b[14]*-1.);\n  res[13]=1.*(a[13]*b[15]+a[15]*b[13]);\n  res[12]=-1.*(a[12]*-1.*b[15]+a[15]*b[12]*-1.);\n  res[11]=1.*(a[11]*b[15]+a[15]*b[11]);\n  res[10]=1.*(a[10]*b[15]+a[13]*b[14]*-1.-a[14]*-1.*b[13]+a[15]*b[10]);\n  res[9]=-1.*(a[9]*-1.*b[15]+a[12]*-1.*b[14]*-1.-a[14]*-1.*b[12]*-1.+a[15]*b[9]*-1.);\n  res[8]=1.*(a[8]*b[15]+a[11]*b[14]*-1.-a[14]*-1.*b[11]+a[15]*b[8]);\n  res[7]=1.*(a[7]*b[15]+a[12]*-1.*b[13]-a[13]*b[12]*-1.+a[15]*b[7]);\n  res[6]=-1.*(a[6]*-1.*b[15]+a[11]*b[13]-a[13]*b[11]+a[15]*b[6]*-1.);\n  res[5]=1.*(a[5]*b[15]+a[11]*b[12]*-1.-a[12]*-1.*b[11]+a[15]*b[5]);\n  res[4]=-1.*(a[4]*-1.*b[15]+a[7]*b[14]*-1.-a[9]*-1.*b[13]+a[10]*b[12]*-1.+a[12]*-1.*b[10]-a[13]*b[9]*-1.+a[14]*-1.*b[7]+a[15]*b[4]*-1.);\n  res[3]=1.*(a[3]*b[15]+a[6]*-1.*b[14]*-1.-a[8]*b[13]+a[10]*b[11]+a[11]*b[10]-a[13]*b[8]+a[14]*-1.*b[6]*-1.+a[15]*b[3]);\n  res[2]=-1.*(a[2]*-1.*b[15]+a[5]*b[14]*-1.-a[8]*b[12]*-1.+a[9]*-1.*b[11]+a[11]*b[9]*-1.-a[12]*-1.*b[8]+a[14]*-1.*b[5]+a[15]*b[2]*-1.);\n  res[1]=1.*(a[1]*b[15]+a[5]*b[13]-a[6]*-1.*b[12]*-1.+a[7]*b[11]+a[11]*b[7]-a[12]*-1.*b[6]*-1.+a[13]*b[5]+a[15]*b[1]);\n  res[0]=1.*(a[0]*b[15]+a[1]*b[14]*-1.-a[2]*-1.*b[13]+a[3]*b[12]*-1.-a[4]*-1.*b[11]+a[5]*b[10]-a[6]*-1.*b[9]*-1.+a[7]*b[8]+a[8]*b[7]-a[9]*-1.*b[6]*-1.+a[10]*b[5]+a[11]*b[4]*-1.-a[12]*-1.*b[3]+a[13]*b[2]*-1.-a[14]*-1.*b[1]+a[15]*b[0]);\n  return res;\n}\n\n//***********************\n// CGA2M.Dot : res = a | b \n// The inner product.\n//***********************\n//CGA2M operator | (CGA2M a, CGA2M b) {\nCGA2M dp(CGA2M a, CGA2M b) {\n  CGA2M res;\n  res[0]=b[0]*a[0]+b[1]*a[1]+b[2]*a[2]+b[3]*a[3]-b[4]*a[4]-b[5]*a[5]-b[6]*a[6]+b[7]*a[7]-b[8]*a[8]+b[9]*a[9]+b[10]*a[10]-b[11]*a[11]+b[12]*a[12]+b[13]*a[13]+b[14]*a[14]-b[15]*a[15];\n  res[1]=b[1]*a[0]+b[0]*a[1]-b[5]*a[2]-b[6]*a[3]+b[7]*a[4]+b[2]*a[5]+b[3]*a[6]-b[4]*a[7]-b[11]*a[8]+b[12]*a[9]+b[13]*a[10]-b[8]*a[11]+b[9]*a[12]+b[10]*a[13]-b[15]*a[14]+b[14]*a[15];\n  res[2]=b[2]*a[0]+b[5]*a[1]+b[0]*a[2]-b[8]*a[3]+b[9]*a[4]-b[1]*a[5]+b[11]*a[6]-b[12]*a[7]+b[3]*a[8]-b[4]*a[9]+b[14]*a[10]+b[6]*a[11]-b[7]*a[12]+b[15]*a[13]+b[10]*a[14]-b[13]*a[15];\n  res[3]=b[3]*a[0]+b[6]*a[1]+b[8]*a[2]+b[0]*a[3]+b[10]*a[4]-b[11]*a[5]-b[1]*a[6]-b[13]*a[7]-b[2]*a[8]-b[14]*a[9]-b[4]*a[10]-b[5]*a[11]-b[15]*a[12]-b[7]*a[13]-b[9]*a[14]+b[12]*a[15];\n  res[4]=b[4]*a[0]+b[7]*a[1]+b[9]*a[2]+b[10]*a[3]+b[0]*a[4]-b[12]*a[5]-b[13]*a[6]-b[1]*a[7]-b[14]*a[8]-b[2]*a[9]-b[3]*a[10]-b[15]*a[11]-b[5]*a[12]-b[6]*a[13]-b[8]*a[14]+b[11]*a[15];\n  res[5]=b[5]*a[0]+b[11]*a[3]-b[12]*a[4]+b[0]*a[5]+b[15]*a[10]+b[3]*a[11]-b[4]*a[12]+b[10]*a[15];\n  res[6]=b[6]*a[0]-b[11]*a[2]-b[13]*a[4]+b[0]*a[6]-b[15]*a[9]-b[2]*a[11]-b[4]*a[13]-b[9]*a[15];\n  res[7]=b[7]*a[0]-b[12]*a[2]-b[13]*a[3]+b[0]*a[7]-b[15]*a[8]-b[2]*a[12]-b[3]*a[13]-b[8]*a[15];\n  res[8]=b[8]*a[0]+b[11]*a[1]-b[14]*a[4]+b[15]*a[7]+b[0]*a[8]+b[1]*a[11]-b[4]*a[14]+b[7]*a[15];\n  res[9]=b[9]*a[0]+b[12]*a[1]-b[14]*a[3]+b[15]*a[6]+b[0]*a[9]+b[1]*a[12]-b[3]*a[14]+b[6]*a[15];\n  res[10]=b[10]*a[0]+b[13]*a[1]+b[14]*a[2]-b[15]*a[5]+b[0]*a[10]+b[1]*a[13]+b[2]*a[14]-b[5]*a[15];\n  res[11]=b[11]*a[0]+b[15]*a[4]+b[0]*a[11]-b[4]*a[15];\n  res[12]=b[12]*a[0]+b[15]*a[3]+b[0]*a[12]-b[3]*a[15];\n  res[13]=b[13]*a[0]-b[15]*a[2]+b[0]*a[13]+b[2]*a[15];\n  res[14]=b[14]*a[0]+b[15]*a[1]+b[0]*a[14]-b[1]*a[15];\n  res[15]=b[15]*a[0]+b[0]*a[15];\n  return res;\n}\n\n// TODO ldot << left contraction produces a scalar iirc,\n// whereas the general inner product produces a multivector\n\n//***********************\n// CGA2M.Add : res = a + b \n// Multivector addition\n//***********************\n//CGA2M operator + (CGA2M a, CGA2M b) {\nCGA2M add(CGA2M a, CGA2M b) {\n  CGA2M res;\n    res[0] = a[0]+b[0];\n    res[1] = a[1]+b[1];\n    res[2] = a[2]+b[2];\n    res[3] = a[3]+b[3];\n    res[4] = a[4]+b[4];\n    res[5] = a[5]+b[5];\n    res[6] = a[6]+b[6];\n    res[7] = a[7]+b[7];\n    res[8] = a[8]+b[8];\n    res[9] = a[9]+b[9];\n    res[10] = a[10]+b[10];\n    res[11] = a[11]+b[11];\n    res[12] = a[12]+b[12];\n    res[13] = a[13]+b[13];\n    res[14] = a[14]+b[14];\n    res[15] = a[15]+b[15];\n  return res;\n}\n\n//***********************\n// CGA2M.Sub : res = a - b \n// Multivector subtraction\n//***********************\n//CGA2M operator - (CGA2M a, CGA2M b) {\nCGA2M sub(CGA2M a, CGA2M b) {\n  CGA2M res;\n    res[0] = a[0]-b[0];\n    res[1] = a[1]-b[1];\n    res[2] = a[2]-b[2];\n    res[3] = a[3]-b[3];\n    res[4] = a[4]-b[4];\n    res[5] = a[5]-b[5];\n    res[6] = a[6]-b[6];\n    res[7] = a[7]-b[7];\n    res[8] = a[8]-b[8];\n    res[9] = a[9]-b[9];\n    res[10] = a[10]-b[10];\n    res[11] = a[11]-b[11];\n    res[12] = a[12]-b[12];\n    res[13] = a[13]-b[13];\n    res[14] = a[14]-b[14];\n    res[15] = a[15]-b[15];\n  return res;\n}\n\n//***********************\n// CGA2M.smul : res = a * b \n// scalar/multivector multiplication\n//***********************\n//CGA2M operator * (float a, CGA2M b) {\nCGA2M mul(float a, CGA2M b) {\n  CGA2M res;\n    res[0] = a*b[0];\n    res[1] = a*b[1];\n    res[2] = a*b[2];\n    res[3] = a*b[3];\n    res[4] = a*b[4];\n    res[5] = a*b[5];\n    res[6] = a*b[6];\n    res[7] = a*b[7];\n    res[8] = a*b[8];\n    res[9] = a*b[9];\n    res[10] = a*b[10];\n    res[11] = a*b[11];\n    res[12] = a*b[12];\n    res[13] = a*b[13];\n    res[14] = a*b[14];\n    res[15] = a*b[15];\n  return res;\n}\n\n//***********************\n// CGA2M.muls : res = a * b \n// multivector/scalar multiplication\n//***********************\n//CGA2M operator * (CGA2M a, float b) {\nCGA2M mul(CGA2M a, float b) {\n  CGA2M res;\n    res[0] = a[0]*b;\n    res[1] = a[1]*b;\n    res[2] = a[2]*b;\n    res[3] = a[3]*b;\n    res[4] = a[4]*b;\n    res[5] = a[5]*b;\n    res[6] = a[6]*b;\n    res[7] = a[7]*b;\n    res[8] = a[8]*b;\n    res[9] = a[9]*b;\n    res[10] = a[10]*b;\n    res[11] = a[11]*b;\n    res[12] = a[12]*b;\n    res[13] = a[13]*b;\n    res[14] = a[14]*b;\n    res[15] = a[15]*b;\n  return res;\n}\n\n//***********************\n// CGA2M.sadd : res = a + b \n// scalar/multivector addition\n//***********************\n//CGA2M operator + (float a, CGA2M b) {\nCGA2M add(float a, CGA2M b) {\n  CGA2M res;\n    res[0] = a+b[0];\n    res[1] = b[1];\n    res[2] = b[2];\n    res[3] = b[3];\n    res[4] = b[4];\n    res[5] = b[5];\n    res[6] = b[6];\n    res[7] = b[7];\n    res[8] = b[8];\n    res[9] = b[9];\n    res[10] = b[10];\n    res[11] = b[11];\n    res[12] = b[12];\n    res[13] = b[13];\n    res[14] = b[14];\n    res[15] = b[15];\n  return res;\n}\n\n//***********************\n// CGA2M.adds : res = a + b \n// multivector/scalar addition\n//***********************\n//CGA2M operator + (CGA2M a, float b) {\nCGA2M add(CGA2M a, float b) {\n  CGA2M res;\n    res[0] = a[0]+b;\n    res[1] = a[1];\n    res[2] = a[2];\n    res[3] = a[3];\n    res[4] = a[4];\n    res[5] = a[5];\n    res[6] = a[6];\n    res[7] = a[7];\n    res[8] = a[8];\n    res[9] = a[9];\n    res[10] = a[10];\n    res[11] = a[11];\n    res[12] = a[12];\n    res[13] = a[13];\n    res[14] = a[14];\n    res[15] = a[15];\n  return res;\n}\n\n//***********************\n// CGA2M.ssub : res = a - b \n// scalar/multivector subtraction\n//***********************\n//CGA2M operator - (float a, CGA2M b) {\nCGA2M sub(float a, CGA2M b) {\n  CGA2M res;\n    res[0] = a-b[0];\n    res[1] = -b[1];\n    res[2] = -b[2];\n    res[3] = -b[3];\n    res[4] = -b[4];\n    res[5] = -b[5];\n    res[6] = -b[6];\n    res[7] = -b[7];\n    res[8] = -b[8];\n    res[9] = -b[9];\n    res[10] = -b[10];\n    res[11] = -b[11];\n    res[12] = -b[12];\n    res[13] = -b[13];\n    res[14] = -b[14];\n    res[15] = -b[15];\n  return res;\n}\n\n//***********************\n// CGA2M.subs : res = a - b \n// multivector/scalar subtraction\n//***********************\n//CGA2M operator - (CGA2M a, float b) {\nCGA2M sub(CGA2M a, float b) {\n  CGA2M res;\n    res[0] = a[0]-b;\n    res[1] = a[1];\n    res[2] = a[2];\n    res[3] = a[3];\n    res[4] = a[4];\n    res[5] = a[5];\n    res[6] = a[6];\n    res[7] = a[7];\n    res[8] = a[8];\n    res[9] = a[9];\n    res[10] = a[10];\n    res[11] = a[11];\n    res[12] = a[12];\n    res[13] = a[13];\n    res[14] = a[14];\n    res[15] = a[15];\n  return res;\n}\n\nfloat norm(CGA2M v) { \n\treturn sqrt(abs(mul(v, conjugate(v))[0])); \n}\nfloat inorm(CGA2M v) {\n\treturn norm(dual(v));\n}\nCGA2M normalized(CGA2M v) { \n\treturn mul(v, 1./norm(v)); \n}\n\n// TODO sandwich product Q*P*~Q   >>>\n\n// TODO idk if screws work in CGA, actually\n/*\n// rotor (Euclidean line)\nCGA2M rotor(float angle, CGA2M line) { \n\treturn add(cos(angle/2.), mul(sin(angle/2.), normalized(line)));\n}\n// translator (Ideal line)\nCGA2M translator(float dist, CGA2M line) {\n\treturn add(1., mul(dist/2., line));\n}\n*/\n// exponentiation in conformal GA is much simpler because things square to zero.\nCGA2M expo(CGA2M v) {\n    return add(1., v);\n}\n\n// supposed to be read-only but must be initialized using functions, which aren't const (can they be?)\nCGA2M e1, e2, e3, e4, e12, e13, e14, e23, e24, e34, e123, e124, e134, e234, e1234;\n\n// the conformal basis setup used is a combination of two axes, it's easiest to use mul and dp to work with these.\nCGA2M e0, einf;\n\nvoid InitGlobalConstants()\n{\n    e1 = MVk(1.,1); // _e1\n    e2 = MVk(1.,2); // _e2\n    e3 = MVk(1.,3);\n    e4 = MVk(1.,4);\n    e12 = MVk(1.,5); // _e12\n    e13 = MVk(1.,6);\n    e14 = MVk(1.,7);\n    e23 = MVk(1.,8);\n    e24 = MVk(1.,9);\n    e34 = MVk(1.,10);\n    e123 = MVk(1.,11);\n    e124 = MVk(1.,12);\n    e134 = MVk(1.,13);\n    e234 = MVk(1.,14);\n    e1234 = MVk(1.,15);\n    // carefully construct the null basis and infinity basis\n    // by rotating 45 degrees between our two extra axes.\n    einf = add(e4, e3);\n    e0   = sub(e4, e3); // some folks reverse this, but it seems to only flip the signs when working with e0\n    e0 = mul(.5, e0); // idk why though.  seems necessary, but perhaps could be accounted for elsewhere...\n}\n// see https://enkimute.github.io/ganja.js/examples/coffeeshop.html#cga2d_points_and_circles\n// We don't work directly in the e3/e4 basis, but instead rotate it so we have\n// two null vectors to work with (called origin and infinite)\n//  var ni = 1*e4+1*e3,           // n-infinite\n//      no = .5*e4-.5*e3;         // n-origin\n  // if you swap those, you get -no in formulas\n  // I call them einf and e0 to match other sources\n\n// project blades out to extract regular glsl vector types\nvec2 vector2(CGA2M v) {\n    return vec2(v[_e1], v[_e2]);\n}\n\nvec2 point2(CGA2M v) {\n    return vector2(v);\n}\n\nvec2 trivector2(CGA2M v) {\n    return vec2(v[_e134], v[_e234]);\n}\n// project onto einf and convert to scalar\nfloat mageinf(CGA2M v) {\n    return norm(dp(v, einf));\n}\n\nvec3 pline2(CGA2M v) {\n    // these are actually trivectors also, but with einf as one point, so...\n    float l = mageinf(v);\n    vec2 normal = vec2(-v[_e234], v[_e134]); //trivector2(v); //\n    float ln = length(normal);\n    normal = normalize(normal);\n    float xlat = -norm(dp(v, e0)) / ln;\n    return vec3(normal, xlat);\n}\n\nfloat radius(CGA2M c) { // of circle c\n    // TODO if c isn't finite, return a large number (so can draw as line) // isinf(radius(c)) ? 99. :\n    return norm(c) / mageinf(c); // aha!\n}\n\nvec2 center(CGA2M c) { // of circle c\n    // TODO if c isn't finite, return a point biased in correct direction by a large number // isinf(radius(c)) ? pline2(c).xy * 99. :\n    CGA2M cdual = dual(c);    // to find circle center, take dual\n    return vector2(cdual) / mageinf(c); \n    //return trivector2(c).yx / mageinf(c); //\n}\n\n// construct from scalars, vec2\nCGA2M vector(float x, float y) {\n    return add(MVk(x, _e1), MVk(y, _e2));\n}\nCGA2M vector(vec2 v) {\n    return vector(v.x, v.y);\n}\n// points are vectors plus .5 * sqrlen * einf, minus e0?\nCGA2M point(vec2 p) {\n    return add(add(vector(p), mul(.5 * dot(p, p), einf)), e0);\n}\n// a homogeneous point, set in this conformal null vector basis\nCGA2M point(float x, float y) { \n    return point(vec2(x, y));\n}\n\n// see https://enkimute.github.io/ganja.js/examples/coffeeshop.html#cga2d_points_and_circles\n// Define points, lines, circles using the null basis.  \n//  var point  = (x,y)=>no + x*e1 + y*e2 + 0.5*(x*x+y*y)*ni,\n//      line   = (a,b,c)=>!(a*e1 + b*e2 + c*ni),\n//      circle = (x,y,r)=>!(point(x,y) - pow(r,2)/2*ni);\n// ! means dual, << left contraction  \n// Distances and Angles. \n//  var dist=(x,y)=>sqrt(2*(x<<y).Length),\n//      angle=(x,y)=>Math.acos(!x.Normalized<<!y.Normalized);\n\nCGA2M circle(vec2 a, float r) {\n    return dual(add(point(-a), mul(.5*r*r, einf))); //mul(1./r, dual(point(a))); //add(dual(point(a)), mul(1./r, einf));\n}\n\nCGA2M circle(vec2 a, vec2 b, vec2 c) {\n    return wedge(wedge(point(a), point(b)), point(c));\n}\n\n// lines in CGA2M are simply circles with one point at einf\nCGA2M line(vec2 a, vec2 b) {\n    return wedge(wedge(point(a), point(b)), einf);\n    //return circle(point(a), point(b), einf);\n}\n\n// WIP A pline is defined using its homogenous equation ax + by + c = 0\nCGA2M pline(float a,float b,float c) { \n//\treturn a*e1 + b*e2 + c*e3;\n    return add(add(MVk(a,_e1), MVk(b,_e2)), MVk(c,_e3)); // _e4?\n}\n\n/*CGA2M circle(CGA2M a, CGA2M b, CGA2M c) {\n    return wedge(wedge(a, b), c);\n}\nCGA2M line(CGA2M a, CGA2M b) {\n    return wedge(wedge(a, b), einf);\n}*/\n\n/*\nint Exercise() {\n  //InitGlobalConstants();\n  //printf(\"e1*e1         : \"); \n  //log(mul(e1, e1));\n  //printf(\"pss           : \"); \n  //log(e1234);\n  //printf(\"pss*pss       : \"); \n  //log(mul(e1234, e1234));\n\n  return 0;\n}*/\n#endif\n\n#define M CGA2M // CGA2D // PGA2D //\n","name":"Common","description":"","type":"common"}]}