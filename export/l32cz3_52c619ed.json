{"ver":"0.1","info":{"id":"l32cz3","date":"1727532206","viewed":141,"name":"[20240928] WebGL Confetti","username":"Kamoshika","description":"h_doxasさんの「WebGL 総本山 + normalize.fm あわせて１３周年感謝祭」夜の部 Shader Jamsで書いたシェーダーです。\nお祝いの気持ちを込めて紙吹雪っぽいものを作りました。\n\nhttps://x.com/h_doxas/status/1825839058431426673\nhttps://sn13.peatix.com/view","likes":18,"published":1,"flags":32,"usePreview":0,"tags":["raycasting","livecoding","characters","confetti"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGRr","filepath":"/media/a/d96b229eeb7a08d53adfcf1ff89e54c9ffeebed193d317d1a01cc8125c0f5cca.mp3","previewfilepath":"/media/ap/d96b229eeb7a08d53adfcf1ff89e54c9ffeebed193d317d1a01cc8125c0f5cca.mp3","type":"music","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// If you don't hear the sound, please click on ⏸→⏮→▶.\n// 音が聞こえない場合、 ⏸→⏮→▶ を順にクリックしてください\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = texture(iChannel0, fragCoord / iResolution.xy);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// 乱数\n#define hash(x) fract(sin(x) * 43758.5453123)\n\nconst float PI = acos(-1.); // 円周率π\nconst float PI2 = PI * 2.;  // τ\n//const float BPM = 145.;\nconst float BPM = 128.;\nconst float quadScale = 1.; // quad（紙吹雪）の大きさ\nconst int numSamples = 8;   // 被写界深度のサンプル数（GPUの処理能力が高ければ大きくしてください）\nfloat Time;   // BPMによって補正された時間\nfloat reTime; // 時間の速さに変化をつける（時間停止や巻き戻し）用の時間\n\n//--------------------------------------------------------------------------------\n// ピクセルフォント\n// 参考：\"96-bit 8x12 Font\" by Flyguy.\n// https://www.shadertoy.com/view/Mt2GWD1\n// http://www.massmind.org/techref/datafile/charset/extractor/charset_extractor.htm\nconst uvec4 ch_W = uvec4(0x00C6C6,0xC6C6D6,0xD66C6C,0x6C0000);\nconst uvec4 ch_e = uvec4(0x000000,0x0078CC,0xFCC0CC,0x780000);\nconst uvec4 ch_b = uvec4(0x00E060,0x607C66,0x666666,0xDC0000);\nconst uvec4 ch_G = uvec4(0x003C66,0xC6C0C0,0xCEC666,0x3E0000);\nconst uvec4 ch_L = uvec4(0x00F060,0x606060,0x626666,0xFE0000);\nconst uvec4 ch_lov = uvec4(0x0044EE,0xFEFEFE,0x7C3838,0x100000); // 追加\nconst uvec4 ch_1 = uvec4(0x001030,0xF03030,0x303030,0xFC0000);\nconst uvec4 ch_0 = uvec4(0x007CC6,0xD6D6D6,0xD6D6C6,0x7C0000);\nconst uvec4 ch_crs = uvec4(0x000000,0x18187E,0x181800,0x000000);\nconst uvec4 ch_3 = uvec4(0x0078CC,0x0C0C38,0x0C0CCC,0x780000);\n\n// コードは改変済み\nbool extract_bit(uint n, int b) {\n    return bool(1U & (n >> b));\n}\n\n// コードは改変済み\nbool sprite(uvec4 spr, vec2 uv) {\n    ivec2 I = ivec2(floor(uv));\n    bool bounds = 0 <= I.x && I.x < 8 && 0 <= I.y && I.y < 12;\n    int h = I.y / 3;\n    if(h < 2) {\n        spr.xy = spr.zw;\n    }\n    if(h % 2 == 0) {\n        spr.x = spr.y;\n    }\n    int bit = 7 - I.x + (I.y % 3) * 8;\n    return bounds && extract_bit(spr.x, bit);\n}\n//--------------------------------------------------------------------------------\n\n// 乱数\nfloat hash13(vec3 p) {\n    return hash(dot(p, vec3(127.1, 311.7, 74.7)));\n}\n\n// 2次元の回転行列\nmat2 rotate2D(float a) {\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, s, -s, c);\n}\n\n// HSVからRGBへの変換\nvec3 hsv(float h, float s, float v) {\n    vec3 res = fract(h + vec3(0, 2, 1) / 3.);\n    res = clamp(abs(res * 6. - 3.) - 1., 0., 1.);\n    res = (res - 1.) * s + 1.;\n    return res * v;\n}\n\n// ルーマ（色をグレースケールに変換）\nfloat luma(vec3 col) {\n    return dot(col, vec3(0.299, 0.587, 0.114));\n}\n\n// 3次元空間上の点ceを通り、法線ベクトルnormalの平面とレイとの交差判定関数\nfloat plaIntersect(vec3 oc, vec3 rd, vec3 normal) {\n    //vec3 oc = ro - ce;\n    return -dot(oc, normal) / dot(rd, normal); // 平面まで伸ばしたレイの長さ（交差しない場合は負の値）\n}\n\n// 3次元空間上の点ceを中心とする半径raの球面とレイとの交差判定関数\nbool sphIntersect(vec3 oc, vec3 rd, float ra2) {\n    //vec3 oc = ro - ce;\n    float b = dot(oc, rd);\n    float c = dot(oc, oc) - ra2; // ra2はraの2乗\n    return b * b > c;\n}\n\n// レイを算出\nvec3 rayDir(vec2 uv, vec3 dir, float fov) {\n    dir = normalize(dir); // カメラの方向ベクトルを正規化\n    vec3 u = abs(dir.y) < 0.999 ? vec3(0, 1, 0) : vec3(0, 0, 1);\n    vec3 side = normalize(cross(dir, u));\n    vec3 up = cross(side, dir);\n    return normalize(uv.x * side + uv.y * up + dir / tan(fov / 360. * PI));\n}\n\n// 被写界深度\nvoid dof(inout vec3 ro, inout vec3 rd, inout float seed, float L, float factor) {\n    float r = sqrt(hash(seed++)); // 半径rの円の内部に一様に分布させるためにsqrt()\n    float a = hash(seed++) * PI2;\n    vec3 v = vec3(r * vec2(cos(a), sin(a)) * factor, 0);\n    ro += v;\n    rd = normalize(rd * L - v);\n}\n\n// 滑らかな矩形波\nfloat smoothSqWave(float x, float factor) {\n    x -= 0.5;\n    float odd = mod(floor(x), 2.);\n    factor *= odd * 2. - 1.;\n    float res = smoothstep(0.5 - factor, 0.5 + factor, fract(x));\n    return res * 2. - 1.;\n}\n\n// 三角波\nfloat triWave(float x) {\n    x -= 0.5;\n    x *= 0.5;\n    float res = abs(fract(x) - 0.5) - 0.25;\n    return res * 4.;\n}\n\n// 画面上に文字列を表示する\nvec3 hud(vec2 uv, vec3 col, float scale) {\n    bool webgl = mod(Time, 2.) < 1.;\n    uvec4[] str = uvec4[](ch_1, ch_0, ch_crs, ch_3, ch_crs);\n    if(webgl) {\n        str[0] = ch_W;\n        str[1] = ch_e;\n        str[2] = ch_b;\n        str[3] = ch_G;\n        str[4] = ch_L;\n    }\n    int len = webgl ? 5 : 4;\n    \n    uv *= 12. / scale;\n    uv += vec2(8 * len, 12) * 0.5;\n    int ix = int(floor(uv.x / 8.));\n    ix = clamp(ix, 0, len - 1);\n    uv.x -= float(ix * 8);\n    \n    if(sprite(str[ix], uv)) { // 文字列\n        col = min(col + 0.7, 1.);\n    } else if(-5. < uv.x && uv.x < 11. && 0. < uv.y && uv.y < 13.) { // 文字列の縁\n        col *= 0.3;\n    }\n    return col;\n}\n\n// quad（紙吹雪）上の文字とレイとの交差判定関数\nfloat confettiIntersect(vec3 ro, vec3 rd, out vec3 normal, out float hue) {\n    float t = -1.; // quad（紙吹雪）上の文字まで伸ばしたレイの長さ（交差しない場合は負）\n    \n    for(int i = -1; i < 10; i++) { // 手前のオブジェクトから順に交差判定\n        float pZ = floor(ro.z) - float(i); // z軸に垂直な平面のz座標\n        float tp = plaIntersect(ro - vec3(0, 0, pZ), rd, vec3(0, 0, 1)); // z軸に垂直な平面まで伸ばしたレイの長さ\n        vec2 p = ro.xy + tp * rd.xy; // z軸に垂直な平面まで伸ばしたレイの先端のxy座標\n        \n        float zID = mod(pZ, 500.); // z軸に垂直な平面のID、長時間経過時の精度対策でmod()\n        vec2 dis = vec2(sin(zID * 2.2), 0);\n        p.x += dis.x; // 平面ごとにx方向にずらす\n        dis.y = hash(floor(p.x) + zID * 50.3218) * 500.;\n        p.y += dis.y; // 平面ごとにy方向にずらす\n        \n        vec3 ID = vec3(floor(p), zID); // quadのID\n        vec3 ce = vec3(ID.xy + 0.5 - dis, pZ); // quadの中心座標\n        vec3 oc = ro - ce;\n        \n        // quadの最大サイズ（※quadが大きすぎると隣のquadの表示範囲にはみ出して消えてしまう）\n        vec2 maxQuadSize = normalize(vec2(8, 12)) * 0.5;\n        \n        vec2 quadSize = maxQuadSize * quadScale;\n        float ra2 = dot(quadSize, quadSize);\n        if(!sphIntersect(oc, rd, ra2)) {\n            continue; // レイが球面と交差しないので、球の内部のquadと交差しないことが確定する\n        }\n        \n        ID.xy = mod(ID.xy, 500.); // 長時間経過時の精度対策でmod()\n        float h = hash13(ID); // quadごとに異なる乱数\n        hue = h;\n        float a = (fract(reTime * 0.4) + h * 1e1) * PI2;\n        mat2 rotA = rotate2D(a);\n        normal = vec3(0, rotA[0].yx); // quadの法線ベクトルを回転させる\n        \n        // 法線ベクトルの回転軸をquadごとにずらす\n        float phi = fract(h * 1e2) * PI2;\n        mat2 rotPhi = rotate2D(phi);\n        float theta = acos(fract(h * 1e3) * 2. - 1.);\n        theta += sign(fract(h * 1e4) - 0.5) * reTime * 0.1517;\n        mat2 rotTheta = rotate2D(theta);\n        normal.yx *= rotPhi;\n        normal.xz *= rotTheta;\n        \n        float tc = plaIntersect(oc, rd, normal); // roからquadまで伸ばしたレイの長さ\n        if(tc < 0.) { // quadとレイが交差しない場合、次の平面に進む\n            continue;\n        }\n        \n        vec3 P = oc + tc * rd; // quadまで伸ばしたレイの先端の座標（quad上の点）\n        \n        // Pは回転したquad上の点なので、quad上のxy座標を求めるために逆回転させる\n        P.zx *= rotTheta;\n        P.xy *= rotPhi;\n        P.y = dot(P.zy, rotA[1]); // P.zy *= rotA; のP.yだけを計算（P.zはこの後使わないため）\n        \n        P.xy *= rotate2D(h * 1e5); // xy平面上で文字をランダムに傾ける\n        \n        vec2 q = P.xy;\n        q *= 12. / quadSize.y * 0.5;\n        q += vec2(8, 12) * 0.5;\n        \n        //p -= 0.25;\n        //p = fract(p) * 15.;\n        \n        uvec4[] str = uvec4[](ch_W, ch_e, ch_b, ch_G, ch_L, ch_lov); // 表示させる文字の配列\n        //uvec4[] str = uvec4[](ch_1, ch_0, ch_crs, ch_3);\n        int len = str.length(); // 文字列の長さ\n        int ix = int(floor(fract(h * 1e6) * float(len))); // 文字列のランダムなインデックス\n        //if(sprite(uvec4(-1), q)) {\n        if(sprite(str[ix], q)) { // レイがquad上の文字と交差する場合、交差判定を終了\n            t = tc;\n            break;\n        }\n    }\n    \n    if(dot(rd, normal) > 0.) { // quadの裏側が見えている場合は法線ベクトルを反転\n        normal = -normal;\n    }\n    \n    return t;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // 画面上の座標を正規化\n    vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n    uv -= 0.5;\n    uv /= vec2(iResolution.y / iResolution.x, 1) * 0.5;\n    \n    vec3 col = vec3(0); // 色\n    \n    Time = iTime * BPM / 60. * 0.5;\n    reTime = Time + triWave(Time - 0.5) * 0.47; // 時間停止のために時間に三角波を足す\n    //reTime = Time + triWave(Time) * 0.47;\n    //reTime = sin(Time * PI);\n    \n    vec3 ro = vec3(1, 1, -1) * reTime; // カメラの座標（レイの原点）\n    float fov = 60.; // 視野の広さ\n    fov += smoothSqWave(Time, 0.15) * 20.;\n    vec3 dir = vec3(0, 0, -1); // カメラの方向\n    vec3 rd = rayDir(uv, dir, fov); // レイの方向（レイベクトル）\n    \n    float seed = hash13(vec3(uv, fract(iTime * 0.1))); // 被写界深度用の乱数を初期化\n    float L = 3. + sin(iTime) * 2.; // 被写界深度の焦点までの距離\n    for(int i = 0; i < numSamples; i++) { // 被写界深度用のサンプリング\n        vec3 ros = ro;\n        vec3 rds = rd;\n        dof(ros, rds, seed, L, 0.1); // 被写界深度\n        \n        vec3 normal; // 法線ベクトル\n        float hue;   // 色相\n        float t = confettiIntersect(ros, rds, normal, hue); // quad（紙吹雪）上の文字まで伸ばしたレイの長さ\n        if(t > 0.) { // レイがquad（紙吹雪）上の文字と交差する場合、色を計算\n            vec3 albedo = hsv(hue, 0.7, 1.); // アルベド\n            vec3 ld = normalize(vec3(1, 5, 2)); // 平行光源の方向\n            float diff = max(dot(normal, ld), 0.); // 拡散反射\n            float spec = pow(max(dot(reflect(ld, normal), rd), 0.), 30.); // 鏡面反射\n            col += albedo * (mix(diff, spec, 0.5) * 7. + 0.3) * exp(-t * t * 0.02);\n        }\n    }\n    col /= float(numSamples);\n    col = clamp(col, 0., 1.);\n    \n    col = pow(col, vec3(1. / 2.2)); // ガンマ補正\n    \n    //col += float(sprite(ch_W, uv * 15.));\n    //col += fract(atan(uv.y, uv.x) / 6. + 0.5 - Time);\n    \n    float lu = luma(1. - col); // 反転したグレースケール\n    if(mod(Time - 1., 2.) < 1.) {\n        // RGBずらし（色収差）\n        vec2 pos = fragCoord / iResolution.xy;\n        vec2 dis = (pos - 0.5) * 0.07;\n        col.r = texture(iChannel0, pos - dis).a;\n        col.g = texture(iChannel0, pos).a;\n        col.b = texture(iChannel0, pos + dis).a;\n    }\n    \n    float s = 0.25 + pow(sin(Time * PI2 * 2.) * 0.5 + 0.5, 5.) * 0.3; // 文字列の大きさ\n    col = hud(uv, col, s); // 画面上に文字列を表示\n    \n    fragColor = vec4(col, lu); // アルファにグレースケールを保存\n}","name":"Buffer A","description":"","type":"buffer"}]}