{"ver":"0.1","info":{"id":"ldByDc","date":"1494087474","viewed":590,"name":"Cube Raytracer","username":"Assossa","description":"Credits in comments.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["raytracer","cube","prototype"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\nBase raytracer: http://fhtr.blogspot.com/2013/12/opus-2-glsl-ray-tracing-tutorial.html\nCube intersection function: https://tavianator.com/fast-branchless-raybounding-box-intersections/\nCube normal function: http://ray-tracing-conept.blogspot.com/2015/01/ray-box-intersection-and-normal.html\n*/\n\nfloat sphere(vec3 ray, vec3 dir, vec3 center, float radius) {\n    vec3 rc = ray - center;\n    float c = dot(rc, rc) - (radius * radius);\n    float b = dot(dir, rc);\n    float d = b * b - c;\n    float t = -b - sqrt(abs(d));\n    float st = step(0.0, min(t, d));\n    return mix(-1.0, t, st);\n}\n\nfloat cube(vec3 ray, vec3 dir, vec3 bmin, vec3 bmax) {\n    float tx1 = (bmin.x - ray.x) / dir.x;\n    float tx2 = (bmax.x - ray.x) / dir.x;\n\n    float tmin = min(tx1, tx2);\n    float tmax = max(tx1, tx2);\n\n    float ty1 = (bmin.y - ray.y) / dir.y;\n    float ty2 = (bmax.y - ray.y) / dir.y;\n\n    tmin = max(tmin, min(ty1, ty2));\n    tmax = min(tmax, max(ty1, ty2));\n\n    float tz1 = (bmin.z - ray.z) / dir.z;\n    float tz2 = (bmax.z - ray.z) / dir.z;\n\n    tmin = max(tmin, min(tz1, tz2));\n    tmax = min(tmax, max(tz1, tz2));\n\n    return tmax >= tmin ? tmin : -1.0;\n}\n\nvec3 cubeNml(vec3 i, vec3 bmin, vec3 bmax) {\n    float epsilon = 0.01;\n\n    float cx = abs(i.x - bmin.x);\n    float fx = abs(i.x - bmax.x);\n    float cy = abs(i.y - bmin.y);\n    float fy = abs(i.y - bmax.y);\n    float cz = abs(i.z - bmin.z);\n    float fz = abs(i.z - bmax.z);\n\n    if(cx < epsilon)\n        return vec3(-1.0, 0.0, 0.0);\n    else if (fx < epsilon)\n        return vec3(1.0, 0.0, 0.0);\n    else if (cy < epsilon)\n        return vec3(0.0, -1.0, 0.0);\n    else if (fy < epsilon)\n        return vec3(0.0, 1.0, 0.0);\n    else if (cz < epsilon)\n        return vec3(0.0, 0.0, -1.0);\n    else if (fz < epsilon)\n        return vec3(0.0, 0.0, 1.0);\n    \n    return vec3(0.0, 0.0, 0.0);\n}\n\nvec3 background(float t, vec3 rd) {\n    vec3 light = normalize(vec3(sin(t), 0.1, cos(t)));\n    float sun = max(0.0, dot(rd, light));\n    float sky = max(0.0, dot(rd, vec3(0.0, 1.0, 0.0)));\n    float ground = max(0.0, -dot(rd, vec3(0.0, 1.0, 0.0)));\n    return (pow(sun, 256.0) + 0.2 * pow(sun, 2.0)) * vec3(2.0, 1.6, 1.0) +\n        pow(ground, 0.5) * vec3(0.4, 0.3, 0.2) +\n        pow(sky, 1.0) * vec3(0.5, 0.6, 0.7);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = (-1.0 + 2.0 * fragCoord.xy / iResolution.xy) * vec2(iResolution.x / iResolution.y, 1.0);\n    vec3 ro = vec3(0.0, sin(iTime * 1.6478), -3.0);\n    vec3 rd = normalize(vec3(uv, 1.0));\n\n    float change = sin(iTime * 1.2847) * 2.0;\n    vec3 cmin = vec3(-0.5 + change, -0.5, -0.5);\n    vec3 cmax = vec3(0.5 + change, 0.5, 0.5);\n\n    float t = cube(ro, rd, cmin, cmax);\n\n    vec3 nml = cubeNml((rd * t) + ro, cmin, cmax);\n    vec3 bgCol = background(iTime, rd);\n    rd = reflect(rd, nml);\n\n    vec3 col = background(iTime, rd) * vec3(0.9, 0.8, 1.0);\n\tfragColor = vec4(mix(bgCol, col, step(0.0, t)), 1.0);\n}","name":"Image","description":"","type":"image"}]}