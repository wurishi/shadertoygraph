{"ver":"0.1","info":{"id":"WtByRm","date":"1593928780","viewed":169,"name":"Littlewood polynomials","username":"rory618","description":"Placing bvh style bounds on the values and roots of the Littlewood Polynomials to draw the generalized dragon curves and the beauty of roots fractal through a mandelbrot julia correspondence. Space to switch. See http://math.ucr.edu/home/baez/roots/","likes":8,"published":1,"flags":16,"usePreview":0,"tags":["2d","fractal","bvh"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define R iResolution\n#define sf (R.y/2.)\nvec2 pxToC(vec2 px){\n    px -= R.xy/2.;\n    px /= sf;\n    return px;\n}\n\nint dfs(vec2 x, vec2 c){\n    int depth = 0;\n    int maxDepth = 14;\n    \n    vec2 e = x;\n    \n    vec2[] xn = vec2[] (x,vec2(0),vec2(0),vec2(0),vec2(0),vec2(0),vec2(0),vec2(0),vec2(0),vec2(0),vec2(0),vec2(0),vec2(0),vec2(0),vec2(0),vec2(0));\n    \n    //Create a circular bound on around the fractal. Because of self simmilarity, this\n    //bound can be scaled to make a bound around every smaller copy within the fractal.\n    for(int i = 0; i < maxDepth; i++){\n        xn[i+1] = mat2(x,-x.y,x.x)*xn[i];\n    \t//Each new branch will either increase or decrease the distance from the origin so always select the branch that increases it\n        if(length(e + xn[i+1]) > length(e - xn[i+1])){\n            e += xn[i+1];\n        } else {\n            e -= xn[i+1];\n        }\n    }\n    \n    float rad = length(e);\n    float f = length(x);\n    \n    int[] next = int[] (0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);\n    vec2[] save = vec2[] (vec2(0), vec2(0), vec2(0), vec2(0), vec2(0), vec2(0), vec2(0), vec2(0), vec2(0), vec2(0), vec2(0), vec2(0), vec2(0), vec2(0), vec2(0), vec2(0));\n    \n    vec2 d = vec2(0);\n    \n    int v = 0;\n    if(length(c-d)<rad){\n        v++;\n    \trad *= f;\n    \n        for(int i = 0; i < 256; i++){\n            \n            save[depth] = d;\n\n            if(next[depth] == 0){\n                vec2 A = d + xn[depth];\n                vec2 B = d - xn[depth];\n\n                bool A_bound = length(c-A)<rad;\n                bool B_bound = length(c-B)<rad;\n\n                v += int(A_bound);\n                v += int(B_bound);\n\n                if(depth < maxDepth){\n                    if(A_bound){\n                    \tif(B_bound){\n                            //Go A\n                            //Next = B\n                            next[depth] = 1;\n                            depth++;\n                \t\t\trad *= f;\n                \t\t\td = A;\n                        } else {\n                            //Go A\n                            //Next = Up\n                            next[depth] = 2;\n                            depth++;\n                \t\t\trad *= f;\n                \t\t\td = A;\n                        }\n                    } else {\n\t\t\t\t\t\tif(B_bound){\n                            //Go B\n                            //Next = Up\n                            next[depth] = 2;\n                            depth++;\n                \t\t\trad *= f;\n                \t\t\td = B;\n                        } else {\n                            //Go up\n                            //Next = 0\n                \t\t\tif(depth==0) break;\n                            next[depth] = 0;\n                            depth--;\n                \t\t\trad /= f;\n                            d = save[depth];\n                        }\n                    }\n                } else {\n                \t//Go up\n                    //Next = 0\n                \tif(depth==0) break;\n                    next[depth] = 0;\n                    depth--;\n                \trad /= f;\n                    d = save[depth];\n                }\n            } else if(next[depth] == 1){\n                //Go B\n                //Next = Up\n            \tnext[depth] = 2;\n                d -= xn[depth];\n                depth++;\n                rad *= f;\n            } else {\n                //Go up\n                //Next = 0\n                if(depth==0) break;\n                next[depth] = 0;\n                depth--;\n                rad /= f;\n                d = save[depth];\n            }\n        }\n    }\n    return v;\n}\n\nvoid mainImage( out vec4 O, in vec2 I )\n{\n    vec2 c = pxToC(I);\n    O = vec4(0);\n    vec2 x;\n    \n    bool julia = texelFetch(iChannel0, ivec2(32,2),0).x>.5;\n    \n\n    if(julia){\n        if(iMouse.z>0.){\n            x = pxToC(iMouse.xy);\n        } else {\n            x = (.6 + .05*sin(iTime/10.))*vec2(cos(iTime/4.),sin(iTime/4.));\n        }\n    \tO.xyz += .5+.5*cos(log(2.+float(dfs(x, c)))*vec3(2,3,4)/2.);\n    } else {\n        if(iMouse.z>0.){\n            c = c/4. + 2.*pxToC(iMouse.xy);\n        } else {\n            c *= 2.;\n        }\n        if(length(c)>1.)\n            c /= dot(c,c);\n    \tO.xyz += .5+.5*cos(log(2.+float(dfs(c, vec2(1,0))))*vec3(2,3,4)/2.);\n    }\n}","name":"Image","description":"","type":"image"}]}