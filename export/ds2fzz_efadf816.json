{"ver":"0.1","info":{"id":"ds2fzz","date":"1689496248","viewed":111,"name":"my 9th audio visualizer","username":"momie","description":"my 9th audio visualizer","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["audiovisualizer"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sXGRr","filepath":"/media/a/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3","previewfilepath":"/media/ap/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3","type":"music","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_DIST 100.0\n#define MAX_STEPS 200\n#define EPSILON 0.01\n\n#define QUANTIZE_STEP 0.035  // Add a quantization step size\n\nfloat getAudio(float xPos) {\n    xPos = floor(xPos / QUANTIZE_STEP) * QUANTIZE_STEP;  // Quantize the x position\n    return texture(iChannel0, vec2(xPos, 0.0)).r;\n}\n\n// Scene creation function\nfloat mapScene(vec3 position) {\n    float audioR = getAudio(abs(position.x)); // get the audio spectrum dependent on x position\n    float cylDist = length(position.yz) - audioR;  // set the radius of the cylinder along the yz plane based on the audio spectrum\n    cylDist = max(cylDist, abs(position.x) - 1.0);  // set the height of the cylinder by x coordinate (here it is set to 1.0)\n    return cylDist;\n}\n\nvec3 getNormal(vec3 pos) {\n    vec2 e = vec2(EPSILON, 0.0);\n    return normalize(vec3(\n        mapScene(pos + e.xyy) - mapScene(pos - e.xyy),\n        mapScene(pos + e.yxy) - mapScene(pos - e.yxy),\n        mapScene(pos + e.yyx) - mapScene(pos - e.yyx)\n    ));\n}\nvec3 rotateY(vec3 v, float angle) {\n    float s = sin(angle);\n    float c = cos(angle);\n    return vec3(c*v.x - s*v.z, v.y, s*v.x + c*v.z);\n}\n\n// レイマーチングを行う関数\nfloat rayMarch(vec3 ro, vec3 rd) {\n    float t = 0.0;\n    float angle = radians(iTime); // 45度で回転させます\n    ro = rotateY(ro, angle);\n    rd = rotateY(rd, angle);\n    for (int i = 0; i < MAX_STEPS; i++) {\n        vec3 position = ro + rd * t;\n        float dS = mapScene(position);\n        if (dS < EPSILON) return t;\n        t += dS;\n        if (t > MAX_DIST) break;\n    }\n    return -1.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord / iResolution.xy -.5;\n\n\n    // FMシンセサイズ: 3つのオペレーターを追加\n    vec2 op1 = sin(80.0 * 3.14 * uv.xy );\n    vec2 op2 = sin(2.0 * 3.14 * (uv.xy + op1) );\n    vec2 op3 = sin(2.0 * 3.14 * (uv.xy + op2) + iTime);\n    vec2 fm = 1. + op3;\n\n    // グラデーション色\n    float blue = 0.5 + 0.25 * cos(3.14 * (uv.x + iTime / 4.0))+0.25 * cos(3.14 * (uv.y + iTime / 4.0));\n\n    // FMとグラデーションの積\n    vec3 col = vec3(fm, blue);\n\n    // 色を出力\n    fragColor = vec4(col,1.0);\n    \n\n    vec3 camPos = vec3(0, 0, -3.0);\n    vec3 rayDir = normalize(vec3(uv, 1.0));\n    \n    float t = rayMarch(camPos, rayDir);\n\n    vec3 color = vec3(0);\n    if (t > 0.0) {\n        vec3 pos = camPos + rayDir * t;\n        vec3 normal = getNormal(pos);\n        vec3 lightDir = normalize(vec3(1, 2, -1)); // 光源の位置\n        float diff = max(0.0, dot(normal, lightDir)); // 拡散光の計算\n        color = vec3(diff); // 光の強さを色に反映\n    }\n    \n    fragColor *= vec4(color,1.0);\n}\n","name":"Image","description":"","type":"image"}]}