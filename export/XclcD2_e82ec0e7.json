{"ver":"0.1","info":{"id":"XclcD2","date":"1721623983","viewed":33,"name":"Raymarching intro by Chus","username":"ChustrupFx","description":"Im learning raymarching","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","study"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nstruct RayColor {\n    vec3 color;\n    float dist;\n};\n\nfloat sdSphere( vec3 uv, vec3 pos, float r) {\n\n    return length(uv - pos) - r;\n    \n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdPlane(vec3 uv, vec3 pos) {\n    \n    vec3 ro = vec3(0, 0, -3.0);\n    \n    return -pos.y;\n    \n}\n\n\n\nRayColor createRayColor(float dist, vec3 color) {\n    \n    RayColor rc;\n    rc.dist = dist;\n    rc.color = color;\n    \n    return rc;\n\n}\n\nfloat smin( float a, float b, float k )\n{\n    k *= 1.0;\n    float r = exp2(-a/k) + exp2(-b/k);\n    return -k*log2(r);\n}\n\nRayColor unionRayColor(RayColor rc1, RayColor rc2) {\n    float dist1 = rc1.dist;\n    float dist2 = rc2.dist;\n    \n    RayColor new;\n    \n    new.dist = smin(dist1, dist2, 0.3);\n    new.color = dist1 < dist2 ? rc1.color : rc2.color;\n    \n    return new;\n}\n\nRayColor map(vec3 rayPos) {\n    \n    float sphere = sdSphere(rayPos, vec3(sin(iTime * 3.0) * 2.0, 0.0, (cos(iTime * 3.0) * 2.0) + 3.0), 1.0);\n    \n    float plane = rayPos.y - -2.0;\n   \n   \n    float box = sdBox(rayPos - vec3(-2.0, 0.0, 1.0), vec3(0.5));\n    \n    RayColor planeRayColor = createRayColor(plane, vec3(1.000,0.478,0.984));\n    RayColor sphereRayColor = createRayColor(sphere, vec3(1.000,0.000,0.000));\n    RayColor boxRayColor = createRayColor(box, vec3(0.000,1.000,0.251));\n   \n    \n    RayColor result = unionRayColor(planeRayColor, sphereRayColor);\n    result = unionRayColor(result, boxRayColor);\n    \n    return result;\n\n}\n\nvec3 GetNormal(vec3 p)\n{\n    float d = map(p).dist;// Distance\n    vec2 e=vec2(.001,0);// Epsilon\n     \n     // e.xyy = (.001, 0, 0)\n     // e.yxy = (0, .001, 0)\n     // e.yyx = (0, 0, .001)\n     \n     \n    vec3 n= vec3(d) - vec3(\n        map(p-e.xyy).dist,// e.xyy is the same as vec3(.01,0,0). The x of e is .01. this is called a swizzle\n        map(p-e.yxy).dist,\n        map(p-e.yyx).dist) ;\n         \n    return normalize(n);\n}\n\n\nfloat getLight(vec3 pos, vec3 surfaceNormal) {\n    vec3 lightPos = vec3(3, 2, 1);\n    \n    \n    vec3 posToLight = normalize(lightPos - pos);\n    \n    float result = dot(surfaceNormal, posToLight);\n    \n    return result;\n} \n\nfloat RayMarch(vec3 ro, vec3 rd) {\n    vec3 currPos;\n    float dt = 0.0;\n    \n    for (int i = 0; i < 50; i++) {\n        \n        vec3 currPos = ro + rd * dt;\n        \n        RayColor rayColor = map(currPos);\n            \n        dt += rayColor.dist;\n        \n        if (dt > 100.0) break;\n        if (dt <= .001) break;\n       \n    }\n    \n    return dt;\n}\n\nfloat distSquared(vec3 v1, vec3 v2) {\n    vec3 diff = v2 - v1;\n    \n    return dot(diff, diff);\n}\n\nfloat getShadow(vec3 pos, vec3 lightPos) {\n\n    vec3 dirToLightPos = normalize(lightPos - pos);\n    \n    \n    vec3 currPos;\n    float dt = 0.01;\n    \n    for (int i = 0; i < 50; i++) {\n        \n        vec3 currPos = pos + dirToLightPos * dt;\n        \n        \n        RayColor rayColor = map(currPos);\n            \n        dt += rayColor.dist;\n        \n        if (dt > 100.0) break;\n        if (dt <= .001) break;\n       \n    }\n    \n    float distToLight = distSquared(currPos, lightPos);\n    \n    return distToLight < dt ? 1.0 : 0.0;\n\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (((fragCoord - (iResolution.xy * 0.5)) * 2.0) / iResolution.xy) * vec2(iResolution.x / iResolution.y, 1.0);\n      \n    float maxDistView = 2.0;\n    \n    vec3 ro = vec3(0, 1, -3.0);\n    vec3 rd = normalize(vec3(uv, 1.0));\n    \n    float dt = RayMarch(ro, rd);\n    \n    vec3 currPos = ro + rd * dt;\n    \n    vec3 color = map(currPos).color;\n    \n    if (dt > 100.0) {\n        color = vec3(1.000,1.000,1.000);\n    }\n    \n    vec3 normal = GetNormal(currPos);\n        \n    float lightPercent = getLight(currPos, normal);\n    float lightIntensity = 0.8;\n \n    float shadow = getShadow(currPos, vec3(3, 2, 1));\n    \n    \n    vec3 col = vec3(color * dt * 0.2) * lightPercent * lightIntensity * shadow;\n\n    // Output to screen\n    fragColor = vec4(vec3(col), 1.0);\n}","name":"Image","description":"","type":"image"}]}