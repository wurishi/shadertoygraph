{"ver":"0.1","info":{"id":"MX2SWy","date":"1711036755","viewed":92,"name":"Volumetric absorption test thing","username":"TheJinxedArtist","description":"just a little test to try and get to know volumetric stuff. I know this is probably not very photorealistic, but it works.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["volume","volumetric","absorption"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":2,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"Xdf3zn","filepath":"/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png","previewfilepath":"/media/ap/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png","type":"texture","channel":3,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdX3Rr","filepath":"/media/a/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin","previewfilepath":"/media/ap/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin","type":"volume","channel":1,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float sdSphere(vec3 p, float r) {\n    return length(p) - r;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat noise(vec3 p) {\n    float v = 0.0;\n    \n    v += texture(iChannel1, p * 0.25).r;\n    v += texture(iChannel1, p * 0.5).g * 0.75;\n    v += texture(iChannel1, p * 0.75).b * 0.5;\n    v += texture(iChannel1, p).a * 0.25;\n    \n    return clamp(v, 0.0, 1.0);\n}\n\nfloat sdScene(vec3 p) {\n    float d = 0.0;\n    \n    d = sdBox(p, vec3(1.0));\n    //d = min(d, sdBox(p - vec3(1.0, 0.0, 0.0), vec3(0.5)));\n    //d -= noise(p * 0.25);\n    //d = max(d, -sdBox(p, vec3(0.5)));\n    \n    return d;\n}\n\nconst float maxDist = 10.0;\nconst int samples = 512;\nconst float stepSize = maxDist / float(samples);\nconst float minDist = 0.001;\nfloat RayMarch(vec3 ro, vec3 rd, float n) {\n    float d = 0.0;\n    float a = 0.0;\n    for(int i = 0; i < samples; i++) {\n        vec3 p = ro + rd * d;\n        float s = sdScene(p);\n        if(s < minDist) {    \n            a += stepSize;\n            d += stepSize + n * minDist;\n        }\n        else if(s >= minDist && d < maxDist) {\n            d += s + n * minDist;\n            //break;\n        }\n        else {\n            break;\n        }\n    }\n    return a;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n    vec2 mouse = (iMouse.xy - 0.5 * iResolution.xy) / iResolution.y;\n    float n = texture(iChannel3, fragCoord.xy / 8.0).r;\n    //n = 0.0;\n    vec3 ro = vec3(mouse.x, 0.0, mouse.y) * 10.0;\n    vec3 rd = normalize(vec3(uv, 1.0));\n    \n    float a = RayMarch(ro, rd, n);\n    a = 1.0 - exp(-a * 1.0);\n    \n    vec3 c = texture(iChannel2, rd).rgb;\n    c *= mix(vec3(1.0), vec3(sin(iTime),0,cos(iTime)) * (1.0 - a), a);\n    \n    fragColor = vec4(1.0 - exp(-c * 3.0), 1.0);\n}","name":"Image","description":"","type":"image"}]}