{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"// Many thanks to iq, learnt so much from his tutorials & site.\n\n// TURN THIS ON TO DO PRETTY REFLECTIONS N STUFF\n#define FANCY 0\n\n\n#define STEPS 128\n#define EPSILON 0.001\n#define PI 3.145\nconst vec3 lightPosition = vec3(-10.0, 10.0, -6.0);\nconst vec3 lightColor = vec3(1.0,1.0,1.0);\n\n\nfloat opS( float d1, float d2 )\n{\n    return max(-d1,d2);\n}\n\nfloat udRoundBox( vec3 p, vec3 b, float r )\n{\n  return length(max(abs(p)-b,0.0))-r;\n}\n\nfloat sdSphere(vec3 p, float r)\n{\n    return length(p) - r;\n}\n\nfloat sdPlane( vec3 p, vec4 n )\n{\n  return dot(p,n.xyz) + n.w;\n}\n\n\nfloat sphereBox(vec3 p)\n{\n    return opS(sdSphere(p,0.5),udRoundBox(p,vec3(0.35,0.35,0.35),0.05));\n}\n\n\nfloat spherePos(vec3 p, float r, vec3 pos)\n{\n    vec3 q = p;\n    q -= pos;\n    return sdSphere(q,r);\n}\n\n\nvec4 m_distance(vec3 p) \n{\n    const int numObjects = 5;\n    vec4 d[numObjects];\n    \n    d[0] = vec4(0.5,0.5,1.0,sdPlane(p,vec4(0.0,1.0,0.0,0.4)));\n    d[1] = vec4(0.5,1.0,0.5,sphereBox(p));\n    d[2] = vec4(1.0,0.5,0.5,spherePos(p,0.2,vec3(0.0)));\n    \n    float r = 0.3;\n    float theta = PI*0.5;//iTime*1.5;\n    float st = sin(theta);\n    float ct = sin(theta);\n    float phi = iTime*1.0;\n    float sp = sin(phi);\n    float cp = cos(phi);\n    \n    d[3] = vec4(1.0,1.0,1.0,spherePos(p,0.05,vec3(ct*sp*r,st*sp*r,cp*r))); \n    \n    theta = -PI*0.5;\n    st = sin(theta);\n    ct = sin(theta);    \n    \n    d[4] = vec4(1.0,1.0,1.0,spherePos(p,0.05,vec3(ct*sp*r,st*sp*r,cp*r))); \n    \n    vec4 min = vec4(0,0,0,99999.0);\n    for(int i=0; i<numObjects; i++)\n    {\n        if(d[i].w < min.w)\n            min = d[i];\n    }\n    \n    return min;\n    \n}\n\n\nvec3 normal(vec3 p) \n{\n    float h = 0.0001;\n\n\treturn normalize(vec3(\n\t\tm_distance(p + vec3(h, 0, 0)).w - m_distance(p - vec3(h, 0, 0)).w,\n\t\tm_distance(p + vec3(0, h, 0)).w - m_distance(p - vec3(0, h, 0)).w,\n\t\tm_distance(p + vec3(0, 0, h)).w - m_distance(p - vec3(0, 0, h)).w));\n}\n\n#if FANCY\n\nfloat getShadow(vec3 p, float k)\n{\n\n    float maxt = length(lightPosition - p);\n\tvec3 rd = (lightPosition- p)/maxt;\n\t\n\tfloat t = 5.0*EPSILON;\n    vec4 d = vec4(0.0);\n    float f = 1.0;\n    \n\tfor(int i = 0; i < STEPS; ++i)\n\t{\n\t\td = m_distance(p + rd * t);\n\n\t\tif(d.w < EPSILON)\n\t\t\treturn 0.0;\n        \n\t\tf = min(f, k * d.w / t);\n        \n        t+=d.w;\n        if(t>maxt)\n            break;\n\t}\n\n\treturn f;\n}\n\n\nvec4 getShade(vec3 p, vec3 n)\n{\n    float shadow = getShadow(p,32.0);\n    float lightIntensity = 0.0;\n    if(shadow > 0.0)\n    {\n        vec3 lightDir = normalize(lightPosition - p);\n        lightIntensity = shadow * clamp(dot(n, lightDir),0.0,1.0);\n    }\n    vec3 ambient = vec3(0.3,0.3,0.3);\n    \n    vec3 result = lightIntensity*lightColor + ambient*(1.0-lightIntensity);\n    return vec4(result,1.0);\n}\n\nvec4 getReflection(vec3 p, vec3 n, vec3 origin)\n{\n    vec3 r = normalize(reflect(p-origin,n));\n    float maxt = 400.0;\n    \n    float t = 5.0*EPSILON;\n    \n    vec4 d = vec4(0.0);\n    vec3 q = p;\n    \n    for(int i = 0; i < STEPS; ++i)\n\t{\n        q = p + r * t;\n        d = m_distance(q);\n        \n\t\tif(d.w < EPSILON)\n        {\n            vec4 s1 = getShade(q, normal(q));\n            return vec4(d.rgb,1.0)*s1;\n        }\n        \n        t+=d.w;\n        if(t>maxt)\n            break;\n    }\n    \n    return vec4(0.1);\n}\n\n#endif\n\n\nfloat getOcclusion(vec3 p, vec3 n)\n{\n\tfloat stepSize = 0.01;\n\tfloat t = stepSize;\n\tfloat oc = 0.0;\n\tfor(int i = 0; i < 10; ++i)\n\t{\n\t\tvec4 d = m_distance(p + n * t);\n\t\toc += t - d.w; // Actual distance to surface - distance field value\n\t\tt += stepSize;\n\t}\n\n\treturn clamp(oc, 0.0, 1.0);\n}\n\n\nvec4 march(vec3 origin, vec3 dir)\n{\n    float t = 0.0;\n    vec4 d = vec4(0.0);\n\tvec3 p = origin;\n    \n    for(int i = 0; i < STEPS; ++i)\n    {\n        p = origin + dir * t;\n        d = m_distance(p);\n        \n        if( abs(d.w) < EPSILON )\n        {\n            vec3 n = normal(p);            \n            vec4 color = vec4(d.rgb,1.0);\n            \n            #if FANCY\n            vec4 s1 = getShade(p, n);\n            \n            vec4 reflection = getReflection(p,n, origin);\n            \n            color = (reflection*0.5 + color*0.5) * s1; \n            color = color * (1.0-getOcclusion(p,n));\n            #endif\n            \n            return color;\n            break;\n        }\n\n        t += d.w;\n    }\n    \n    return vec4(0.1);\n}\n\n \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 eye = vec3(0.0,0.0,1.0);\n\n    //eye.y = 0.2 +  0.2 * sin(iTime*0.2);\n    eye.x = cos(iTime*0.4);\n    eye.z = sin(iTime*0.4);\n\n    vec3 forward = eye * -1.0; //vec3(0,0,1);\n    vec3 up = vec3(0, 1, 0);\n    vec3 right = cross(forward,up); //vec3(1, 0, 0);\n    \n    float aspect = iResolution.x/iResolution.y;\n    \n    float u = fragCoord.x * 2.0 / iResolution.x - 1.0;\n    float v = fragCoord.y * 2.0 / iResolution.y - 1.0;\n\n    vec3 ro = eye;\n\tvec3 rd = normalize(forward + right * u * aspect + up * v);\n    \n    vec4 color = vec4(0.0); // Sky color\n\n    color = march(ro,rd);\n    fragColor = color;// * 2.0;\n}\n","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"4dBXDW","date":"1411922587","viewed":154,"name":"Ray Marching learning","username":"dgoemans","description":"Teaching myself basics of ray marching. Set FANCY to turn on the lighting ( really slow ). Reflection color is weird ( probably wrong ). Any comments/crits/help welcome :)","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raymarch"],"hasliked":0,"parentid":"","parentname":""}}