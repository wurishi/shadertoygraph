{"ver":"0.1","info":{"id":"NtKGRG","date":"1640299668","viewed":100,"name":"Playground raymarching hunter","username":"HuntNight1337","description":"Playground 3d","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_DISTANCE 100.\n#define MAX_STEPS 200\n#define SURF_DIST 0.01\n#define lightPosition vec3(0, 10, -1)\n#define yBias ((iMouse.y / iResolution.y) - 0.5) * 6. + 2.\n#define sPos vec2(0.5, yBias)\n\nfloat point (vec2 uv, vec2 pos) {\n    float radius = 0.1;\n    vec2 localPos = uv - pos;\n    float d = length(localPos) - radius;\n    d = step(d, 0.0);\n    return d;\n}\nfloat smooth_min(float distA, float distB, float k){\n    float h = clamp(0.5 + 0.5 * (distA - distB)/k, 0.0, 1.0);\n    return mix(distA, distB, h) - k*h*(1.0-h);\n}\nfloat getDistance (vec3 p) {\n    vec4 sphere = vec4(vec3(sPos,6), 1.0);\n    sphere.y += 1.0;\n    \n    float planeDir = p.y;\n    float sphereDir = length(sphere.xyz - p) - sphere.w;\n    \n    return smooth_min(planeDir, sphereDir, 0.8);\n}\nfloat rayMarching(vec3 ro, vec3 rd) {\n    float d0 = 0.0;\n    for (int i = 0; i < MAX_STEPS; i++) {\n        vec3 p = ro + rd * d0;\n        float ds = getDistance(p);\n        d0 += ds;\n        if (i > MAX_STEPS || ds < SURF_DIST || d0 > MAX_DISTANCE) break;\n    }\n    return d0;\n}\nvec3 getNormal(vec3 p) {\n    float d = getDistance(p);\n    vec2 b = vec2(0.0, 0.1);\n    return normalize(d - vec3(\n        getDistance(p - b.yxx),\n        getDistance(p - b.xyx),\n        getDistance(p - b.xxy)));\n}\nfloat getShadow (vec3 p, vec3 normal) {\n    return 1.;\n    p += normal * SURF_DIST;\n    vec3 dirToL = normalize(lightPosition - p);\n    float canGoDistToL = rayMarching(p, dirToL);\n    float distToTheL = length(lightPosition - p);\n    float d = canGoDistToL / distToTheL;\n    return clamp(d, 0.8, 1.);\n}\nfloat getLight(vec3 p) {\n    vec3 lightDirection = normalize(lightPosition - p);\n    vec3 normal = getNormal(p);\n    float l = dot(lightDirection, normal);\n    l = clamp(l, 0.1, 1.);\n    float s = getShadow(p, normal);\n    l = min(l, s);\n    return clamp(l, 0.0, 1.0);\n}\nmat3 rotateX(float a){\n    float cosA = cos(a);\n    float sinA = sin(a);\n    return mat3(1., 0., 0.,\n                0., cosA, -sinA,\n                0., sinA, cosA);\n}\nmat3 rotateY(float a){\n    float cosA = cos(a);\n    float sinA = sin(a);\n    return mat3(cosA, 0., sinA,\n                0., 1., 0.,\n                -sinA, 0., cosA);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy) / iResolution.y;\n    vec3 ro = vec3(0, 1, 0);\n    vec3 rd = vec3(uv.x, uv.y, 1);\n    float dist = rayMarching(ro, rd);\n    vec3 p = ro + rd * dist;\n    vec3 nm = getNormal(p);\n    float light = getLight(p);\n    fragColor = vec4(light, light, light, 1);\n}","name":"Image","description":"","type":"image"}]}