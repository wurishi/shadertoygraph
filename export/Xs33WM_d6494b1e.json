{"ver":"0.1","info":{"id":"Xs33WM","date":"1449860650","viewed":447,"name":"Multiple importance sample","username":"zhuxinyue","description":"Multiple importance  sampling ","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["missamplelight"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[],"code":"precision highp float;\nprecision highp int;\n//----------choose the thing u want to sample--\n//#define SAMPLE_BRDF\n//#define COMBINE\n//#define SAMPLE_LIGHT\n//------------------------------\n\n//#define SCENE_DEFAULT\n#define SCENE_SMPL_LIHGT\n//#define SCENE_SMPL_BRDF\n#define LIGHTCOLOR          vec3(1.0,1.0,1.0)\n#define BLINNCOLOR          vec3( 0.1,0.1,0.7 )\n#define SAMPLES \t\t    1\n#define N                   5\n#define EPSILON \t\t\t0.001 \n#define GAMMA \t\t\t\t2.2\t\t\t\n#define DEPTH\t\t        5\n#define INDIRECT_CLAMP \t\t20.0\t\n#define INFINITY            9999.9\n#define FOG_STRENGTH 1.0\n#define BLACK               vec3( 0.0 )\n#define PI \t\t\t\t\t3.1415926\n#define TWO_PI \t\t\t\t6.2831852\n#define REFLECTION_STRENGTH 100000.0\nfloat INTENSITY=   50.0;\n\n#define OBJ_NULL 0\n#define OBJ_CUBE 1\n#define OBJ_SPHERE 2\n#define OBJ_PLANE 3\n\n#define COLOR_STRENGTH 10.0\n//varying vec2 v_uv;\n\nfloat seed;\t//seed initialized in main\n//reference:https://www.shadertoy.com/view/MtfGR4\nfloat rand1() { return fract(sin(seed++)*43758.5453123); }\nvec2  rand2() {\n    return fract(sin(vec2(seed+=0.1,seed+=0.1))*vec2(43758.5453123,22578.1459123));\n}\nstruct Ray {vec3 origin; vec3 dir;};\nstruct Intersection\n{\n    vec3 point;\n    vec3 normal;\n    float t;\n    int hit_obj;\n    int hit_mat;\n   // vec3 hit_color;\n};\n//-------------geometry-----------------//\nstruct Sphere { int materialId; vec3 pos; float r;  float area; };\nstruct Plane { int materialId; vec4 abcd; };\nstruct Box { vec3 Bl; vec3 Bh; int materialId; };\n//----------------------------------------------    \nstruct Material { vec3 base; float spec; };\nstruct Camera { mat3 rotate; vec3 pos; vec3 target; float fovV; float lensSize; float focusDist; };\n\n\n    \n//------------ SCENE--------------\nBox boxes[5];\nPlane walls[5];\nSphere spherelight;\nSphere spheres[5];\nCamera camera;\nvec3 light_color=vec3(1.0);\n//data structure:https://www.shadertoy.com/view/lts3Dr\n//-----------------------------------\n//--------------------material-------\n//-----------------------------------\n//---1)diffuse-----------------------\n#define M_DIF_WHITE\t        0\n#define M_DIF_BLACK \t\t1\n#define M_DIF_GREY\t        2\n#define M_DIF_RED   \t\t3\n#define M_DIF_GREEN \t\t4\n//---2)blinn-------------------------\n#define M_BLINN_1\t        5\n#define M_BLINN_2           6\n#define M_BLINN_3           7\n#define M_BLINN_4           8\n//----3)mirro------------------------\n#define M_MIRRO             9\n#define M_LIGHT             10\n#define M_COUNT\t\t\t    11\n\nMaterial materials[M_COUNT];\n//interesting... cant use A.base=base;\n#define SET_MAT(i,_diff,_spec) { materials[i].base=_diff; materials[i].spec=_spec; }\n\nvoid initMaterial() {\n    float intensity = 50.0 ;\n  \n    SET_MAT( M_DIF_WHITE, vec3( 1.0 ), 0.0 );\n    SET_MAT( M_DIF_BLACK, vec3( 0.0 ),  0.2 );\n    SET_MAT( M_DIF_GREY, vec3( 0.5, 0.6, 0.8 ),  0.8 );\n    SET_MAT( M_DIF_RED, vec3( 1.0, 0.1, 0.15 ),  0.2 );\n    SET_MAT( M_DIF_GREEN, vec3( 0.1, 0.8, 0.1 ), 0.2 );\n   \n    \n    SET_MAT( M_BLINN_1,vec3( 0.1,0.1,0.7 ), 10.0 );\n    SET_MAT( M_BLINN_2,vec3( 0.1,0.1,0.7 ), 20.0 );\n    SET_MAT( M_BLINN_3,vec3( 0.1,0.1,0.7 ), 50.0 );\n    SET_MAT( M_BLINN_4,vec3( 0.1,0.1,0.7 ), 100.0 );\n    \n    SET_MAT( M_MIRRO, vec3( 0.7,0.1,0.4 ),  1.0 );\n    SET_MAT( M_LIGHT, vec3( 1.0 ), INTENSITY );\n}\n\nMaterial GetMaterial(int index ) \n{   \n    for(int i=0; i<M_COUNT; i++ ) { \n    \tif( index == i ) {\n            return materials[i];\n        }\n    }  \n    return materials[0];\n}\nvoid initLightSphere( float time ) {\n\tspherelight.pos = vec3( 3.5*sin(time*0.9),2.0,-2.0);\n}\n\nvoid initScene() \n{\n\n    float time = iTime;\n\n    //lights\n    float rlgiht=0.3;\n    float r = 1.0;\n    \n    spherelight = Sphere( M_LIGHT, vec3( 2.0, 2.0, -2.0 ), rlgiht, rlgiht*rlgiht*4.0*PI );\n    SET_MAT( M_LIGHT, vec3( 1.0 ), 50.0 );\n    \n   // int scene=0;\n#ifdef SCENE_DEFAULT\n   // if(scene==0){\n    //cornelbox scene---\n    //walls\n    //bottom adc:normal\n    walls[0].abcd = vec4( 0.0, 1.0, 0.0, 1.0 );\n    walls[0].materialId = M_DIF_GREY;\n  \n    //top\n    walls[1].abcd = vec4( 0.0, -1.0, 0.0, 5.5 );\n    walls[1].materialId = M_DIF_BLACK;\n    \n    //front\n    walls[2].abcd = vec4( 0.0, 0.0, 1.0, 6.0 );\n    walls[2].materialId = M_DIF_WHITE;\n    \n    //left\n    walls[3].abcd = vec4( 1.0, 0.0, 0.0, 4.0 );\n    walls[3].materialId = M_DIF_GREEN;\n    \n    //right\n    walls[4].abcd = vec4( -1.0, 0.0, 0.0, 4.0 );\n    walls[4].materialId = M_DIF_RED;\n    \n    //box\n    boxes[0].Bl = vec3( 0.2, -1.0, -2.5 );\n    boxes[0].Bh = vec3( 2.0, 0.8, -1.6 );\n    boxes[0].materialId = M_BLINN_1;\n    \n    //sphere\n    r = 0.5;\n    spheres[1] = Sphere( M_BLINN_1, vec3( -2, 0.0, -3.0 ), r, r*r*4.0*PI  );\n    spheres[2] = Sphere( M_BLINN_2, vec3( -0.5, 3.0, -3.0 ), r, r*r*4.0*PI  );\n        \n    spheres[3] = Sphere( M_BLINN_3, vec3( 3.5, 3.0, -3.0 ), r, r*r*4.0*PI  );\n    spheres[4] = Sphere( M_BLINN_4, vec3( -2.5, 3.0, -3.0 ), r, r*r*4.0*PI  );\n     \n  //  }\n#endif    \n#ifdef SCENE_SMPL_LIHGT\n  //  if(scene==1)\n   // {\n        //4 plane:\n   //  walls[0].abcd = vec4( 0.0, 1.0, 0.0,2.0 );\n  //   walls[0].materialId =M_DIF_GREY;\n    walls[0].abcd = vec4( 0.0, 1.0, 0.0, 1.0 );\n    walls[0].materialId = M_DIF_GREY;\n  \n    //top\n   /* walls[1].abcd = vec4( 0.0, -1.0, 0.0, 5.5 );\n    walls[1].materialId = M_DIF_BLACK;\n    \n    //front\n    walls[2].abcd = vec4( 0.0, 0.0, 1.0, 6.0 );\n    walls[2].materialId = M_DIF_WHITE;\n    \n    //left\n    walls[3].abcd = vec4( 1.0, 0.0, 0.0, 4.0 );\n    walls[3].materialId = M_DIF_GREEN;\n    \n    //right\n    walls[4].abcd = vec4( -1.0, 0.0, 0.0, 4.0 );\n    walls[4].materialId = M_DIF_RED;*/\n    r=0.5;\n    spheres[0] = Sphere( M_MIRRO, vec3( -0.5,1.0, -3.0 ), r, r*r*4.0*PI  );        \n    spheres[1] = Sphere( M_BLINN_1, vec3( -2.0, 1.0, -3.0 ), r, r*r*4.0*PI  );\n    spheres[2] = Sphere( M_BLINN_2, vec3( -3.5, 1.0, -3.0 ), r, r*r*4.0*PI  );  \n        \n    spheres[3] = Sphere( M_BLINN_3, vec3( 1.0, 1.0, -3.0 ), r, r*r*4.0*PI  );       \n    spheres[4] = Sphere( M_BLINN_4, vec3( 3.0, 1.0, -3.0 ), r, r*r*4.0*PI  );\n    \n//  }\n#endif\n    \n}\n\nIntersection SetNull()\n{\n    Intersection isx;\n    isx.t=-1.0;\n    isx.hit_obj=OBJ_NULL;\n    return isx;\n}\n// intersection function\nIntersection raySphereIntersection(in Ray r, in Sphere sphr) \n{    \n    vec3 os=r.origin-sphr.pos;\n    //remember to normalize the r.direction\n    float A=1.0;\n    float B=2.0*(r.dir.x*os.x+r.dir.y*os.y+r.dir.z*os.z);\n    float C = pow(os.x,2.0) + pow(os.y,2.0) +pow(os.z,2.0)-sphr.r*sphr.r;\n    float Discre=pow(B,2.0)-4.0*A*C;\n    \n    if(Discre < 0.0) {\n       \n        return SetNull();\n    }\n    else{\n        \n        float t0= (-B - sqrt(Discre))/(2.0*A);\n         \n        if(t0>0.0)//intersecton\n        {\n            Intersection isx;\n            isx.point = r.dir*t0+r.origin;//to Local\n            isx.normal= normalize(isx.point-sphr.pos);//normalize!!!!!\n            isx.t=t0;\n            isx.hit_obj=OBJ_SPHERE;\n            \n            return isx;\n        }\n        else{\n            float t1= (-B + sqrt(Discre))/(2.0*A);\n            \n            if(t1>0.0)//t1 intersect at front in sphere\n            {\n                 Intersection isx;\n                 isx.point = r.dir*t1+r.origin;\n                 isx.normal =normalize(isx.point-sphr.pos);//normalize!!!!!\n                 isx.t = t1;\n                 isx.hit_obj=OBJ_SPHERE;\n                 \n                 return isx;\n            }\n            else {\n                return SetNull();\n            }\n        }\n    }\n    \n}\nIntersection rayCubeIntersection(in Ray r,in Box cube)\n{\n   float Tnear=-INFINITY;\n   float Tfar=INFINITY;\n    \n   vec3 R=r.dir;\n   vec3 Position=r.origin;\n   vec3 point;\n \n   Intersection isx=SetNull();\n\n   if(abs(R.x)<=EPSILON&&(Position.x < cube.Bl.x||Position.x > cube.Bh.x))return isx;\n   else if(abs(R.y)<=EPSILON&&(Position.y<cube.Bl.y||Position.y>cube.Bh.y))return isx;\n   else if(abs(R.z)<=EPSILON&&(Position.z<cube.Bl.z||Position.z>cube.Bh.z))return isx;\n   else{\n          float t1, t2;\n          float a;\n          int face=-1;\n          t1 = (cube.Bl.z -Position.z)/R.z;\n          t2 = (cube.Bh.z -Position.z)/R.z;\n          if(t1>t2){\n              a = t1;t1 = t2;t2 = a;\n          }\n          if(t1>Tnear){\n              Tnear = t1; face=1;\n          }\n          if(t2<Tfar) Tfar = t2;\n    //*********************x\n          t1 = (cube.Bl.x - Position.x)/R.x;\n          t2 = (cube.Bh.x - Position.x)/R.x;\n          if(t1>t2){a = t1;t1 = t2;t2 = a;}\n          if(t1>Tnear){Tnear = t1;face=2;}\n          if(t2<Tfar) Tfar = t2;\n          point.x=Tnear;\n   //**********************Y\n          t1 = (cube.Bl.y - Position.y)/R.y;\n          t2 = (cube.Bh.y - Position.y)/R.y;\n          if(t1>t2){a = t1;t1 = t2;t2 = a;}\n          if(t1>Tnear) {Tnear = t1;face=3;}\n          if(t2<Tfar) Tfar = t2;\n          if(Tnear<Tfar){//swap -1\n              vec3 normal;\n              point = Position+ Tnear*R;//local\n              if(face==1){normal=vec3(0.0,0.0,1.0);}\n              if(face==2){normal=vec3(1.0,0.0,0.0);}\n              if(face==3){normal=vec3(0.0,1.0,0.0);}\n              vec3 _sign = sign(point);\n              isx.point=point;\n              isx.normal=normal*_sign;\n              isx.hit_obj=OBJ_CUBE;\n              isx.t=Tnear;\n                  return isx;\n             // return Intersection(point,vec3(normal.x*_sign.x, normal.y*_sign.y, normal.z*_sign.z),Tnear,OBJ_CUBE);\n          }         \n          else\n              return isx;\n       }\n}\nIntersection rayPlaneIntersection( Ray ray, Plane plane)\n{\n    Intersection isx=SetNull();\n\n    float dotVN = dot( ray.dir, plane.abcd.xyz );\n   //dot(N,(S - R0)):S is random point on plane\n    if ( abs( dotVN ) > EPSILON ) {\n\t\tisx.t = -(dot(plane.abcd.xyz, ray.origin) + plane.abcd.w)/dotVN;\n        isx.hit_obj=OBJ_PLANE;\n        isx.point=ray.origin+ray.dir*isx.t;\n        isx.normal=plane.abcd.xyz;\n    }\n    \n    return isx;\n}\n\n\n \n//-------Geometry functions--------\nfloat UniformConePdf(float cosThetaMax)\n{\n    return 1.0 / (2.0 * PI * (1.0 - cosThetaMax));\n}\nvec3 localToWorld( in vec3 localDir, in vec3 normal )\n{\n    vec3 binormal = normalize( ( abs(normal.x) > abs(normal.z) )?vec3( -normal.y, normal.x, 0.0 ):vec3( 0.0, -normal.z, normal.y ) );\n\tvec3 tangent = cross( binormal, normal );\n    \n\treturn localDir.x*tangent + localDir.y*binormal + localDir.z*normal;\n}\nIntersection GetSphereSurfaceSample(in float u1,in float u2)\n{\n    float z = 1.0 - 2.0 * u1;\n    float r = sqrt(max(0.0, 1.0 - z*z));\n    float phi = 2.0 * PI * u2;\n    float x = r * cos(phi);\n    float y = r * sin(phi);\n    vec3 normal = normalize(vec3(x,y,z));\n    \n    vec4 pointL=vec4( x/2.0, y/2.0, z/2.0, 1.0);\n    vec3 ppoint=vec3(x/2.0, y/2.0, z/2.0);\n    vec4 normalL=vec4(normal,0.0);\n   \n    vec3 T = normalize(cross(vec3(0,1,0),vec3(normalL)));\n    vec3 B = cross(vec3(normalL), T);\n\n    Intersection result;\n   \n    result.point = spherelight.pos+ppoint;\n    result.normal = normalize(result.point-spherelight.pos);\n\n    return result;\n}\nRay shootRay( in vec2 pixel,vec2 mo )\n{\n    Ray ray;\n    vec3 m=vec3(mo.x,mo.y,mo.x);\n    vec3 eye = vec3(0, 2.0, 12.00);\n    vec3 ref = vec3(0, 2.0,  0.00)+m;\n    vec3 F = normalize( ref - eye );\n    vec3 U = normalize( cross(F,vec3(0.0,1.0,0.0) ) );\n    vec3 R = normalize( cross(U,F)); \n\t//vec3 rd = normalize( (pixel.x+rand1)*U + (pixel.y+rand2)*R +4.* F );\n    vec3 rd = normalize( pixel.x*U + pixel.y*R +4.* F );\n    ray.origin=eye;\n    ray.dir=rd;  \n\treturn ray;\n}\n\nIntersection raySceneIntersection( in Ray ray)\n{    \n    float nearest_t = INFINITY;\n    Intersection isx_f=SetNull();\n    \n    //check lights\n    Intersection isx0=raySphereIntersection( ray, spherelight);\n    if(isx0.t>0.0){\n        nearest_t=isx0.t;\n        isx_f=isx0; \n        isx_f.hit_mat=M_LIGHT;}\n    \n    //sphere  \n    for(int i=0;i<5;i++)\n    {\n       Intersection isx_sphere=raySphereIntersection( ray, spheres[i]);\n       float ts= isx_sphere.t; \n       if(ts<0.0)continue;\n       else\n       {\n           if(ts<nearest_t) \n           {\n               nearest_t=ts;\n               isx_f=isx_sphere;\n               isx_f.hit_mat=spheres[i].materialId;\n           }\n       }\n    }    \n     for( int i=0; i<5; i++ )\n     {\n       \n        Intersection isx_p=rayPlaneIntersection(ray, walls[i]);\n        float ps=isx_p.t;\n        if(ps<0.0)continue;\n        else\n         {\n             if(ps<nearest_t){\n                 nearest_t=ps;\n                 isx_f=isx_p;\n                 isx_f.hit_mat=walls[i].materialId;\n             }\n         }\n     }\n    //cube\n   \n      Intersection isx_cube = rayCubeIntersection(ray,boxes[0]);\n      float cs= isx_cube.t;\n      if(cs<nearest_t&&cs>0.0)\n      {\n         nearest_t=cs;isx_f=isx_cube;\n         isx_f.hit_mat=boxes[0].materialId;\n      }\n    \n   \n      return isx_f;\n}\n\nvec3 blin_microfacet(in vec3 normal,in vec3 wo,in vec3 wi, in vec3 diffuse, in float exponent)\n{\n\n   //------ Geometry term-------:\n    \n    normal=normalize(normal);\n    vec3 wh=normalize(wo+wi);\n    float a=abs(dot(wh,normal));\n    float M=abs(2.0*dot(normal,wh)*dot(normal,wo)/dot(wo,wh));\n    float S=abs(2.0*dot(normal,wh)*dot(normal,wi)/dot(wo,wh));\n    float _G=min(min(M,S),1.0);\n\n\n    //------Distribution term------\n    //float exponent=10.0;\n    float _D=( exponent+2.0)/(2.0*PI)*pow(a, exponent);\n\n    float costheta_o=dot(normal,wo);//normalize!!!\n    float costheta_i=dot(normal,wi);\n    float brdf=_D*_G/(4.0*costheta_o*costheta_i);\n    \n    //----color--calculation--\n    \n    return brdf*diffuse;\n}\n\nbool ShadowTest( Ray shadowRay ) {\n    float distToHit;\n   \n    Intersection isx=raySceneIntersection( shadowRay);\n    if(isx.hit_mat==M_LIGHT)return true;\n    else return false;\n}\nvec3 EvaluateLightBRDF(in vec3 wo, in vec3 wi,in vec3 normal, in int matId)\n{\n   Material mat=GetMaterial(matId) ;\n   //diffuse\n   if(matId<=4&&matId>=0){ return mat.base/PI;}\n   if(matId>=5&&matId<=8)\n    {\n       return blin_microfacet(normal,wo, wi, mat.base,mat.spec);\n    }\n    if(matId==9) return BLACK;\n    else return BLACK;\n}\n\nfloat LightRayPDF(in Intersection light_isx,in Ray light_ray)\n{\n    vec3 Pcenter = spherelight.pos;\n    float radius = spherelight.r;\n    float a_temp=distance(light_isx.point, Pcenter);\n    float dis=pow(a_temp,2.0);\n  //  return dis;\n    // Return uniform weight if point inside sphere\n    if (dis - radius*radius <EPSILON)\n    {\n      //if(light_isx.hit_obj == OBJ_NULL){return 0.0;}\n        \n      float cos_theta=dot(-light_ray.dir,light_isx.normal);\n      return radius/(cos_theta*spherelight.area);\n   }\n\n    // Compute general sphere weight\n    float sinThetaMax2 = radius*radius / dis;\n    float cosThetaMax = sqrt(max(0.0, 1.0 - sinThetaMax2));\n    return UniformConePdf(cosThetaMax);\n}\nvec3 SampleLambert(in Intersection isx,in vec3 ray_dir,out vec3 new_dir,out float brdf_pdf)\n{\n      vec2 rnd=rand2();\n \n    \n       float t = 2.0*PI*rnd.x;\n       float u = rnd.y-0.5;//[-0.5,+0.5]*/\n\n       float x=u*cos(t);\n       float y=u*sin(t);\n       float z=sqrt(0.25-pow(x,2.0)-pow(y,2.0));\n       new_dir=normalize(vec3(x,y,z));\n       brdf_pdf=dot(new_dir,isx.normal)/PI;\n       return EvaluateLightBRDF(ray_dir, new_dir, isx.normal, isx.hit_mat);\n     \n}\nbool samehemi(vec3 x, vec3 y)\n{\n    return x.z*y.z>0.0;\n}\nvec3 SampleBlinn(in Intersection isx,in vec3 ray_dir,out vec3 new_dir,out float brdf_pdf)\n{\n    vec2 rnd2=rand2();\n    float rand1=rnd2.x;float rand2=rnd2.y;\n    \n    Material mat=GetMaterial(isx.hit_mat);\n    float exponent=mat.spec;\n    float costheta=pow(rand1,1.0/(exponent+1.0));\n    float sintheta=sqrt(max(0.0,1.0-costheta*costheta));\n    float phi=rand2*2.0*PI;\n    \n    vec3 wh;\n    wh.x=cos(phi)*sintheta;\n    wh.y=sin(phi)*sintheta;\n    wh.z=costheta;\n    wh=localToWorld( wh, isx.normal );\n  //  if(!samehemi(ray_dir, wh))wh=-wh;\n\n    new_dir=-ray_dir+2.0*dot(ray_dir,wh)*wh;\n    \n    vec3 result=EvaluateLightBRDF(ray_dir, new_dir, isx.normal, isx.hit_mat);\n\n    vec3 wm=normalize(ray_dir+new_dir);\n    float cst=abs(wm.z);\n    brdf_pdf=(exponent+1.0)*pow(cst,exponent)/(2.0*PI*4.0*dot(ray_dir,wm));\n\n    return result;\n}\nvec3 SampleMirro(in Intersection isx,in vec3 ray_dir,out vec3 new_dir,out float brdf_pdf)\n{\n   // new_dir=normalize(vec3(-ray_dir.x,-ray_dir.y,ray_dir.z));\n  //  new_dir=localToWorld(new_dir, isx.normal );\n    new_dir=normalize(reflect(-ray_dir,isx.normal));\n    brdf_pdf=1.0;\n    return BLINNCOLOR;//to make the compare color he same..so not using base_color\n}\nvec3 EvaluateSampleBRDF(in Intersection isx,in vec3 ray_dir,out vec3 new_dir,out float brdf_pdf)\n{\n    vec2 rnd=rand2();\n    if(isx.hit_mat<=4)\n    { \n        return SampleLambert(isx, ray_dir,new_dir, brdf_pdf);\n    }\n    if(isx.hit_mat<=8&&isx.hit_mat>=5)\n    {\n        return SampleBlinn(isx, ray_dir,new_dir, brdf_pdf);\n    }\n    if(isx.hit_mat==9)\n    {\n        return SampleMirro(isx, ray_dir,new_dir, brdf_pdf);\n    }\n    else return vec3(0.0);\n}\nvec3 Light_Radiance(in vec3 dir, in vec3 normal)\n{\n   return dot(dir,normal)>0.0? INTENSITY*vec3(1,1,1):vec3(0.0);\n}\nvec3 Directlight( in Ray ray) {\n    \n    vec3 color = vec3( 0.0 );\n    vec3 weight = vec3( 1.0 );\n    //for(int i=0;i<2;i++){\n    Intersection isx=raySceneIntersection(ray);\n    if(isx.t<0.0) {return vec3(0.0,0.0,0.0);}\n    else\n    {\n        if(isx.hit_mat==M_LIGHT)return LIGHTCOLOR;\n        //sample light\n      \n        vec2 rnd2=rand2();\n        vec3 light_color;\n        vec3 brdf_color;\n        Intersection light_isx= GetSphereSurfaceSample(rnd2.x,rnd2.y);\n        \n        Ray light_ray;\n        light_ray.origin=light_isx.point;\n        light_ray.dir=normalize(light_isx.point-isx.point);\n        light_ray.origin += light_ray.dir*EPSILON;\n        \n        //if(ShadowTest(light_ray))\n        //{\n           //EvaluateScatteredEnergy of light matrial\n            vec3 radiance= Light_Radiance(-light_ray.dir,light_isx.normal);\n            //vec3 radiance=dot(-light_ray.dir,light_isx.normal)>0.0?50.0*vec3(1,1,1):vec3(0.0);\n            float light_pdf=LightRayPDF(light_isx,light_ray);\n            vec3 light_brdf=EvaluateLightBRDF(-ray.dir,light_ray.dir,isx.normal,isx.hit_mat);\n            vec3 sample_light_color=radiance*light_brdf*abs(dot(isx.normal,light_ray.dir))/light_pdf;\n            light_color=light_brdf;\n            \n        //}\n        \n        Ray new_ray;\n        new_ray.origin=isx.point;\n        float brdf_pdf;\n        vec3 brdf_brdf=EvaluateSampleBRDF(isx,-ray.dir,new_ray.dir,brdf_pdf);\n        //update ray\n        new_ray.dir=normalize(new_ray.dir);\n        new_ray.origin+=new_ray.dir*EPSILON;\n        \n        \n        //------\n        vec3 Ld;\n        Intersection isx_new=raySceneIntersection(new_ray);\n        if(isx_new.t<0.0){Ld=vec3(0.0);}\n        else if(isx_new.hit_mat==M_LIGHT){Ld=vec3(1.0);}//Ld= Light_Radiance(new_ray.dir,isx.normal);}\n        else Ld=vec3(0.0);\n    \n        vec3 test_color=Ld;\n       // vec3 test_color=vec3(brdf_pdf,0.0,0.0);\n        if(abs(brdf_pdf)>0.0)\n        {\n            float absd=abs(dot(isx.normal,new_ray.dir));\n            vec3 sample_brdf_color=Ld*brdf_brdf*absd/brdf_pdf;\n            brdf_color=sample_brdf_color;\n        }\n        \n         float w_light=pow(light_pdf,2.0)/(pow(light_pdf,2.0)+pow(brdf_pdf,2.0));\n         float w_brdf=pow(brdf_pdf,2.0)/(pow(light_pdf,2.0)+pow(brdf_pdf,2.0));\n        \n         vec3 com_color =(light_color*w_light+brdf_color*w_brdf);\n        #ifdef SAMPLE_BRDF\n         return brdf_color;\n        #endif\n        #ifdef SAMPLE_LIGHT\n        return light_color;\n        #endif\n        #ifdef COMBINE\n        return com_color;\n        #endif\n        return com_color;\n       // return light_color;\n        \n  //   }\n   \n       \n     }\n\n}       \n \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t//iResolution.xy=gl_FragCoord.xy/v_uv.xy;\n    seed = iResolution.y * fragCoord.x / iResolution.x + fragCoord.y / iResolution.y;\n    float fov = radians(45.0);\n    initMaterial();\n    initScene();\n    vec2 mo = iMouse.xy/iResolution.xy;\n\tvec3 accumulatedColor = vec3( 0.0 );\n    vec2 p = -1.0 + 2.0 * (fragCoord.xy) / iResolution.xy;\n    p.x *= iResolution.x/iResolution.y;//*1.7;\n\t//p.y *= iResolution.y/iResolution.x;//*1.7;\n\t//p.y-=0.3;\n    Ray ray;\n    \n\tfor( int i=0; i<SAMPLES; i++){\n        \n        initLightSphere( iTime );\n        ray = shootRay(p,mo);\n    //    ray = shootRay(p, rnd()/float(SAMPLES), rnd()/float(SAMPLES) );\n        accumulatedColor += Directlight( ray );\n       // accumulatedColor += Directlight( ray, ( float(i) + rnd() )/float(SAMPLES) );\n\t}\n\taccumulatedColor = accumulatedColor/float(SAMPLES);\n\t//if(if_gamma>0.0)\n    accumulatedColor = pow( accumulatedColor, vec3( 1.0 / GAMMA ) );\n\n\tfragColor = vec4( accumulatedColor,1.0 );\n\t\n}","name":"","description":"","type":"image"}]}