{"ver":"0.1","info":{"id":"sdcyR4","date":"1653058685","viewed":181,"name":"Jetlag","username":"Flopine","description":"Trying to wake up my creativity, kinda off but anyway","likes":17,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","animation","rainbow","isometric"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Code by Flopine\n\n// Thanks to wsmind, leon, XT95, lsdlive, lamogui, \n// Coyhot, Alkama,YX, NuSan, slerpy, wwrighter \n// BigWings, FabriceNeyret and Blackle for teaching me\n\n// Thanks LJ for giving me the spark :3\n\n// Thanks to the Cookie Collective, which build a cozy and safe environment for me \n// and other to sprout :)  \n// https://twitter.com/CookieDemoparty\n\n\n#define PI acos(-1.)\n#define TAU (2.*PI)\n\n#define rot(a) mat2(cos(a),sin(a),-sin(a),cos(a))\n#define crep(p,c,l) p-=c*clamp(round(p/c),-l,l)\n#define pal(c,t,d) (vec3(.5)+vec3(.5)*cos(TAU*(c*t+d)))\n\n#define t (iTime*2.)\n\n\nstruct obj{\n    float d;\n    vec3 c;\n};\n\nvoid mo(inout vec2 p, vec2 d)\n{\n    p = abs(p)-d;\n    if (p.y>p.x) p=p.yx;\n}\n\nobj minobj (obj a, obj b)\n{\n    if (a.d<b.d) return a;\n    else return b;\n}\n\nfloat box (vec3 p, vec3 c)\n{\n    vec3 q = abs(p)-c;\n    return min(0., max(q.x, max(q.y, q.z)))+length(max(q,0.));\n}\n\nobj prim1 (vec3 p, float variation, bool inver)\n{\n    float per = 0.7;\n    mo(p.xz, vec2(variation));\n    p.z -= inver ? t : -t;   \n    float id = floor(p.z/per);\n    p.z = mod(p.z,per)-per*.5;\n    float d = box(p,vec3(1.,0.05,0.3));\n    \n    return obj(d, pal(vec3(0.1), id, vec3(0.8,0.2,0.65)));\n}\n\nobj SDF (vec3 p)\n{\n    p.yz *= rot(-atan(1./sqrt(2.)));\n    p.xz *= rot(PI/4.);\n    \n    crep(p.y, 18., 1.);   \n    mo(p.xy,vec2(2.));\n    obj B = obj(box(p-vec3(0.19),vec3(0.05,0.1,1e10)), vec3(1.));\n    \n    obj O = obj(1e10, vec3(0.));\n    float var = 0.3;\n    bool inv = false;\n    for (int i=0; i<3; i++)\n    {\n        O = minobj(O, prim1(p, var, inv));\n        var += 5.; \n        inv = inv ? false : true;\n    }\n    \n    return minobj(O, B);\n}\n\nvec3 getnorm (vec3 p)\n{\n    vec2 eps = vec2(0.001,0.);\n    return normalize(SDF(p).d-vec3(SDF(p-eps.xyy).d,SDF(p-eps.yxy).d,SDF(p-eps.yyx).d));\n}\n\nfloat ao (float e, vec3 p, vec3 n)\n{return clamp(SDF(p+e*n).d/e,0.,1.);}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.*fragCoord-iResolution.xy)/iResolution.y;\n  \n    vec3 ro=vec3(uv*6.,-50.), rd=vec3(0.,0.,1.),p=ro,\n    col=vec3(0.), l=normalize(vec3(1.,3.,-1.));\n    \n    bool hit=false; obj O;\n    \n    for(float i=0.;i<64.;i++)\n    {\n        O = SDF(p);\n        if(O.d<0.001)\n        {\n            hit=true; break;\n        }\n        p += O.d*rd;\n    }\n\n    if (hit)\n    {\n        vec3 n = getnorm(p);\n        float light = dot(n,l)*.5+.5; \n        float AO = ao(0.1, p, n)+ao(0.25, p, n)+ao(0.4, p, n);\n        col = O.c*light*AO/3.;\n    }\n    \n    fragColor = vec4(sqrt(col),1.0);\n}","name":"Image","description":"","type":"image"}]}