{"ver":"0.1","info":{"id":"4cKSDd","date":"1715926588","viewed":70,"name":"kaleidoscope-practice","username":"dragonfly","description":"练习作品，shader万花筒","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["kaleidoscope"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// 调色板函数\nvec3 palette(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n    // 6.28318 约等于 2π\n    return a + b * cos(6.28318 * (c * t + d));\n}\n\n// 固定好调色板参数\nvec3 palette(in float t) {\n    return palette(t, vec3(0.5, 0.5, 0.5), \n            vec3(0.5, 0.5, 0.5), \n            vec3(1.0, 1.0, 1.0), \n            vec3(0.263, 0.416, 0.557));\n}\n\n// 将fragCoord（像素坐标）除以画布分辨率iResolution.xy，获得归一化后的uv\nvoid sample1(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n    fragColor = vec4(uv, 0.0, 1.0);\n}\n\n// 让uv范围变成-1~1\nvoid sample2(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n    // 让中心点变0,0点\n    uv = uv - vec2(0.5, 0.5);\n    // 简化写法 和上面这一句是等价的\n    // uv -= 0.5;\n    \n    // uv:  -0.5,0.5  =>  -1, 1\n    uv *= 2.0;\n    \n    fragColor = vec4(uv, 0.0, 1.0);\n}\n\n// 将uv转换合并到一句里\nvoid sample3(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy * 2.0 - 1.0;\n    fragColor = vec4(uv, 0.0, 1.0);\n}\n\n// 使用length函数，这个函数计算的是向量的长度\n// 将uv的x轴方向的值乘以宽高比，获得正圆的图形\nvoid sample4(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    // 可以合并简化成\n    // vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n    \n    float d = length(uv);\n    fragColor = vec4(d, 0.0, 0.0, 1.0);\n}\n\n\nvoid sample5(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n    \n    float d = length(uv);\n    \n     d-=0.5;\n     //使用三角函数函数来创造连续不断的圆环\n     //d = sin(d * 8.0);\n     // 黑色部分太细了调粗一点\n     //d = sin(d * 8.0) / 8.0;\n     // 加上时间参数，让画面动起来\n     //d = sin(d * 8.0 + iTime) / 8.0;\n     \n    // abs函数取绝对值\n     d = abs(d);\n    // step函数设定一个比较两个值的大小，返回0或者1\n    d = step(0.1, d);\n    // smoothstep函数，设定一个平滑过渡区间，区间内返回0~1之间的值\n    //d = smoothstep(0.0, 0.1, d);\n    fragColor = vec4(d, d, d, 1.0);\n}\n\n// 使用倒数来改善颜色过渡变化\n// 设定一个颜色\nvoid sample6(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n    float d = length(uv);\n    \n    // 给个固定颜色\n    //vec3 col = vec3(1.0, 2.0, 3.0);\n    // 用调色板制作一个渐变的色带\n    //vec3 col = palette(d);\n    // 加上时间参数，让颜色变化起来\n    //vec3 col = palette(d + iTime);\n\n    \n    d = sin(d * 8.0 + iTime) / 8.0;\n    d = abs(d);\n     // 使用倒数，获得更接近与自然界光照衰减的效果\n    d = 0.02 / d;\n    \n   //col *= d;\n    \n    //fragColor = vec4(d, d, d, 1.0);\n    //fragColor = vec4(col, 1.0);\n}\n\n// 分形\nvoid sample7(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n    \n    // 记录下没有分形之前的uv\n    //vec2 uv0 = uv;\n    // 使用fract函数，取小数部分\n    uv = fract(uv);\n    // 将分形的每个晶格的uv也归一成中心点位00点，取值范围从-1,到1\n    //uv = fract(uv * 2.0) - 0.5;\n    \n    float d = length(uv);\n    \n    vec3 col = palette(d + iTime);\n    //vec3 col = palette(length(uv0) + iTime);\n\n\n    d = sin(d * 8.0 + iTime) / 8.0;\n    d = abs(d);\n    d = 0.02 / d;\n    col *= d;\n    \n    fragColor = vec4(col, 1.0);\n}\n\n// 迭代\nvoid sample8(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n    \n    vec3 finalColor = vec3(0.0);\n    vec2 uv0 = uv;\n    \n    for (float i = 0.0; i < 4.0; i++) {\n        //每次迭代，uv都在原来的基础上细分切割\n        uv = fract(uv * 2.0) - 0.5;\n        // 2倍这个参数容易造成很多正好重叠的画面表现，调节一下，打破这种对称性\n        //uv = fract(uv * 1.5) - 0.5;\n\n        float d = length(uv);\n        // 乘以uv0长度构造的指数函数，让离中心越远的地方，越拉伸开来\n        d *= exp(-length(uv0));\n\n        vec3 col = palette(length(uv0) + iTime);\n        // 调节一下颜色变化速度\n         //vec3 col = palette(length(uv0) + iTime * 0.4);\n         // 加入i参数，让每个迭代的颜色起始值有所不同\n         //vec3 col = palette(length(uv0) + i * 0.4 + iTime * 0.4);\n\n\n\n        d = sin(d * 8.0 + iTime) / 8.0;\n        d = abs(d);\n        \n        d = 0.02 / d;\n        // 叠代之后亮度太大了点，修改一下参数，条件亮度\n        //d = 0.01 / d;\n        finalColor += col * d;    \n    }\n\n    \n    fragColor = vec4(finalColor, 1.0);\n}\n\nvoid sampleFinal(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n    vec2 uv0 = uv;\n    vec3 finalColor = vec3(0.0);\n\n    for (float i = 0.0; i < 4.0; i++) {\n        uv = fract(uv * 1.5) - 0.5;\n        float d = length(uv) * exp(-length(uv0));\n        vec3 col = palette(length(uv0) + i * 0.4 + iTime * 0.4);\n        d = sin(d * 8. + iTime) / 8.;\n        d = abs(d);\n        // 用幂函数来改善整体对比度\n        d = pow(0.01 / d, 1.2); \n        finalColor += col * d;        \n    }\n\n    fragColor = vec4(finalColor, 1.);\n}\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    //sample1(fragColor, fragCoord);\n    //sample2(fragColor, fragCoord);\n    //sample3(fragColor, fragCoord);\n    //sample4(fragColor, fragCoord);\n    //sample5(fragColor, fragCoord);\n    //sample6(fragColor, fragCoord);\n    //sample7(fragColor, fragCoord);\n    //sample8(fragColor, fragCoord);\n    sampleFinal(fragColor, fragCoord);\n}","name":"Image","description":"","type":"image"}]}