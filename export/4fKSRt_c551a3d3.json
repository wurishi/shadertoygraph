{"ver":"0.1","info":{"id":"4fKSRt","date":"1715841762","viewed":43,"name":"jko278: Ray Marching","username":"jko278","description":"Trying out Ray Marching","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["3d","raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14159265\n\nstruct ray {\n    vec3 rayOrigin, rayDirection;\n};\n\nmat3 rotMatrix(float yaw, float pitch) {\n    float cosYaw = cos(yaw);\n    float sinYaw = sin(yaw);\n    float cosPitch = cos(pitch);\n    float sinPitch = sin(pitch);\n\n    return mat3(\n        cosYaw, 0, -sinYaw,\n        sinYaw * sinPitch, cosPitch, cosYaw * sinPitch,\n        sinYaw * cosPitch, -sinPitch, cosPitch * cosYaw\n    );\n}\n\n\nray Ray(in vec2 uv, in vec3 rayOrigin, mat3 rotMatrix, float zoom) {\n    vec3 center = vec3(rayOrigin.xy, rayOrigin.z + zoom);\n    vec3 intersect = center + uv.x * vec3(1., 0., 0.) + uv.y * vec3(0., 1., 0.);\n\n    ray Ray;\n    Ray.rayDirection = rotMatrix* normalize(intersect - rayOrigin);\n    Ray.rayOrigin = rayOrigin;\n    return Ray;\n}\n\nfloat sdSphere(vec3 point, vec3 center, float radius) {\n    return length(point - center) - radius;\n}\n\nfloat sdBox(vec3 point, vec3 boxSize, vec3 boxCenter) {\n    // Translate the point to the box's coordinate system\n    vec3 translatedPoint = point - boxCenter;\n\n    // Calculate the difference between the translated point coordinates and the box dimensions\n    vec3 distanceFromBox = abs(translatedPoint) - boxSize;\n\n    // Calculate the distance outside the box (if any)\n    float outsideDistance = length(max(distanceFromBox, 0.0));\n\n    // Calculate the distance inside the box (if any)\n    float insideDistance = min(max(distanceFromBox.x, max(distanceFromBox.y, distanceFromBox.z)), 0.0);\n\n    // Combine the distances to get the signed distance\n    return outsideDistance + insideDistance;\n}\nfloat sdPlane( vec3 point, vec3 normal, float disOrigin ) {\n  // n must be normalized\n  return dot(point,normal) + disOrigin;\n}\n\n\nvec2 sdTotal(vec3 point) {\n    vec3 center = vec3(0., 1., 0.);\n    float radius = 1.;\n    vec3 center2 = vec3(1., 0., 0.);\n    float radius2 = 1.;\n    vec3 boxSize = vec3(3.,2.2,.4);\n    vec3 boxCenter = vec3(0.,0.,.0);\n\n    float distancePlane = sdPlane(point, vec3(0.,1.,0.), 2.);\n    float distanceBox = sdBox(point, boxSize, boxCenter);\n    float distanceSphere = -sdSphere(point, center2, radius2);\n    float distanceSphere2 = sdSphere(point, vec3(sin(iTime*0.6)*5.,1.,cos(iTime*0.6)*5.), 1.);\n    \n    float distance = min(distancePlane, min( distanceSphere2, max(distanceBox, distanceSphere)));\n    float id = 0.0;\n\n    if (distance == distancePlane) {\n        id = 1.0; // Plane\n    } else if (distance == distanceBox) {\n        id = 2.0; // Box\n    } else if (distance == distanceSphere) {\n        id = 3.0; // Sphere\n    }else if (distance == distanceSphere2) {\n        id = 4.0; // Sphere\n    }\n\n    return vec2(distance, id);\n}\n\nvec3 linearColor ( in vec3 color ){\n    return pow(color, vec3(2.2));\n}\nvec3 sRGB ( in vec3 color){\n    return pow(color, vec3(1.0 / 2.2));\n}\n\n\nvec3 calculateNormal(vec3 point) {\n    float normalOffset = 0.01;\n    vec2 disxp = sdTotal(point + vec3(normalOffset, 0., 0.));\n    vec2 disxn = sdTotal(point + vec3(-normalOffset, 0., 0.));\n    vec2 disyp = sdTotal(point + vec3(0., normalOffset, 0.));\n    vec2 disyn = sdTotal(point + vec3(0., -normalOffset, 0.));\n    vec2 diszp = sdTotal(point + vec3(0., 0., normalOffset));\n    vec2 diszn = sdTotal(point + vec3(0., 0., -normalOffset));\n\n    vec3 normal = vec3(disxp.x - disxn.x, disyp.x - disyn.x, diszp.x - diszn.x);\n    return normalize(normal);\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n    uv -= 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec2 mouse = iMouse.xy/iResolution.xy;\n\n    vec3 lightSource = vec3(sin(iTime)*10., 10., cos(iTime)*10.);\n    //vec3 lightSource = vec3(0.,10.,0.);\n    vec3 lightColor = linearColor(vec3(1.,1.,0.9843137254901961));\n    vec3 backgroundColor = linearColor(vec3(0.698, 1., 1.));\n    vec3 objectColor1 = linearColor(vec3(1., 1., 1.)); // Color for Plane\n    vec3 objectColor2 = linearColor(vec3(0., 1., 0.)); // Color for Box\n    vec3 objectColor3 = linearColor(vec3(0., 1., 0.));\n    vec3 objectColor4 = linearColor(vec3(0., 0., 1.));// Color for Sphere\n    vec3 ambient = vec3(0.1, .1, 0.1);\n\n    //vec3 rayOrigin = vec3(sin(iTime), 4., cos(iTime)-10.);\n    vec3 rayOrigin = vec3 (5.,3.,-8.);\n    float pitch = -0.5;\n    float yaw = .3;\n    float zoom = 1.;\n    vec3 rayPoint = rayOrigin;\n    ray Ray = Ray(uv, rayOrigin, rotMatrix(pitch, yaw), zoom);\n\n    bool hit = false;\n    float maxSteps = 512.;\n    float steps = 0.;\n\n    vec3 finalColor = backgroundColor.rgb;\n\n    while (!hit && steps < maxSteps) {\n        vec2 dis = sdTotal(rayPoint);\n\n        if (dis.x < 0.0001) {\n            hit = true;\n            vec3 normal = calculateNormal(rayPoint);\n            vec3 lightDir = normalize(lightSource - rayPoint);\n            float diff = max(dot(normal, lightDir), 0.0);\n\n            Ray.rayDirection = lightDir;\n            steps = 0.;\n            float shadow = 1.;\n            rayPoint += normal * 0.002;\n            vec3 objectColor = (dis.y == 1.0) ? objectColor1 : (dis.y == 2.0) ? objectColor2 : (dis.y == 3.0) ? objectColor3 : objectColor4;\n            while (steps < maxSteps) {\n                dis = sdTotal(rayPoint);\n                \n                if (dis.x < 0.0001) {\n                    shadow = 0.0; // In shadow\n                    \n                    break;\n                }\n                rayPoint += Ray.rayDirection * dis.x;\n                steps++;\n            }\n\n            \n            vec3 lighting = objectColor * (ambient + diff * shadow)*lightColor;\n            \n            finalColor = lighting;\n            break;\n        }\n\n        rayPoint += Ray.rayDirection * dis.x;\n        steps++;\n    }\n\n    fragColor =  vec4(sRGB(finalColor),1.);\n    if (!hit) {\n        fragColor = vec4(sRGB(backgroundColor),1.); \n    }\n}\n\n","name":"Image","description":"","type":"image"}]}