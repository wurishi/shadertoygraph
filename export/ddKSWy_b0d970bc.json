{"ver":"0.1","info":{"id":"ddKSWy","date":"1682267235","viewed":172,"name":"Chromatic Glass Pawn","username":"xor_swap","description":"Shading glass on a dark background is EXTREMELY HARD.\nThis is a chromatic glass shader that works with both a light and a dark environment.","likes":10,"published":1,"flags":0,"usePreview":0,"tags":["3d","glass"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n// Cristian A. aka @swap_xor on twitter\n// I make cool stuff, leave a like if you enjoy it ;)\n\n// ==== PRIMITIVES ================================================================\n\nfloat sphere(vec3 p, vec3 o, float r) {\n\treturn length(p - o) - r;\n}\n\nfloat capsule(vec3 p, vec3 a, vec3 b, float r) {\n\tvec3 ab = b - a;\n\tvec3 ap = p - a;\n\tfloat t = dot(ab, ap) / dot(ab, ab);\n\tt = clamp(t, 0.0, 1.0);\n\tvec3 c = a + t * ab;\n\treturn length(p - c) - r;\n}\n\nfloat cylinder(vec3 p, vec3 a, vec3 b, float r) {\n\tvec3 ab = b - a;\n\tvec3 ap = p - a;\n\tfloat t = dot(ab, ap) / dot(ab, ab);\n\tvec3 c = a + t * ab;\n\tfloat x = length(p - c) - r;\n\tfloat y = (abs(t - 0.5) - 0.5) * length(ab);\n\tfloat e = length(max(vec2(x, y), 0.0)); // exterior distance\n\tfloat i = min(max(x, y), 0.0); // interior distance\n\treturn e + i;\n}\n\nfloat cylinder(vec3 p, vec3 b, float h, float r) {\n\treturn cylinder(p, b, vec3(b.x, b.y + h, b.z), r);\n}\n\n// ==== SCENE =====================================================================\n\nmat2 rotation(float a) {\n    float s = sin(a), c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat pawn(vec3 p, vec3 b) {\n    float y = b.y + 1.5 - p.y;\n    float base = cylinder(p, vec3(b.x, b.y, b.z), 0.05, 0.365) / 2.2;\n    float belly = cylinder(p, vec3(b.x, b.y + 0.3, b.z), - 0.3,\n        0.35 * (sin(y * 6.0 - 0.1) + 0.03)\n    );\n    float neck = cylinder(p, vec3(b.x, b.y + 0.775, b.z), - 0.04, 0.26 * y);\n    float separator = cylinder(p, vec3(b.x, b.y + 0.33, b.z), vec3(b.x, b.y + 0.29, b.z), 0.275);\n    float body = capsule(p, vec3(b.x, b.y + 1.0, b.z), vec3(b.x, b.y + 0.3, b.z),\n        (p.y < b.y || p.y > b.y + 1.5) ? 0.0 : clamp(0.25 * pow(y * 0.8, 2.4), 0.0, 1.5)\n\t);\n    float head = sphere(p, vec3(b.x, b.y + 1.0, b.z), 0.22);\n    return min(base, min(head, min(neck, min(separator, min(body, belly)))));\n}\n\nfloat scene(vec3 p) {\n    vec3 q = p;\n    q.y -= 0.5;\n    q.xz *= rotation(sin(iTime * 0.8) * 2.0);\n    q.yz *= rotation(cos(iTime * 0.8) * 2.0 + 0.5);\n    q.y -= 0.5;\n    //q.z += cos(iTime);\n    return pawn(q, vec3(0, -1.0, 0));\n}\n\nconst int   MAX_STEPS = 100;\nconst float MAX_DIST  = 100.0;\nconst float SURF_DIST = 0.01;\n\nconst float INSIDE = -1.0, OUTSIDE = 1.0;\nfloat march(in vec3 ro, in vec3 rd, float side) {\n\tfloat d0 = 0.0, ds = 0.0;\n\tfor (int i = 0; i < MAX_STEPS; i++) {\n\t\tvec3 p = ro + rd * d0;\n\t\tds = scene(p) * side; // outside or inside (1, -1)\n\t\td0 += ds;\n\t\tif (d0 >= MAX_DIST || abs(ds) <= SURF_DIST) break;\n\t}\n\treturn d0;\n}\n\nvec3 normal(vec3 p) {\n\tfloat d = scene(p);\n\tvec2 e = vec2(0.01, 0.0);\n\tvec3 n = d - vec3(\n\t\tscene(p - e.xyy),\n\t\tscene(p - e.yxy),\n\t\tscene(p - e.yyx)\n\t); // n is a point close to p;\n\treturn normalize(n);\n}\n\n/// adds source lights to the scene\nfloat light(vec3 n) {\n    float t = 1.0;// (sin(iTime) * 0.5) + 0.5; // light movement\n    vec3 l1 = vec3(clamp(n.z, -0.5, 0.5), t, clamp(n.x, -0.5, 0.5));\n    vec3 l2 = vec3(clamp(n.y, -0.5, 0.5), clamp(n.x, -0.5, 0.5), t);\n    vec3 l3 = vec3(t, clamp(n.z, -0.5, 0.5), clamp(n.y, -0.5, 0.5));\n    float brightness = 0.0;\n    brightness += max(0.0, dot(n, normalize(l1))) * 0.3;\n    brightness += max(0.0, dot(n, normalize(l2))) * 0.3;\n    brightness += max(0.0, dot(n, normalize(l3))) * 0.3;\n    return clamp(brightness, 0.0, 1.0);\n}\n\n/// fetches the background\nvec3 background(vec3 ray) {\n    // return texture(iChannel0, ray).rgb; // IT ALSO WORKS WITH CUBEMAPS\n    vec3 color = vec3((0.2 - ray.y) / 10.0);\n    color.b += 0.2;\n    color.r += length(ray.zy) * (sin(iTime) * 0.5 + 0.5) * 0.3;\n    color.g += length(ray.xz) * 0.1;\n    return max(color * 0.5, 0.0);\n}\n\n/// fetches the foreground\nvec3 foreground(vec3 ray) {\n    const float cs = 1.5; // chromatic shift\n    const float gl = 1.0; // white glare\n    vec3 q = sin(vec3(1) + ray * 0.01 / cs) * 0.5 - 0.5;\n    vec3 color = vec3(gl / length(mod(q, cs)));\n    color /= cs * 10.0;\n    float l = light(normal(normalize(ray))) * cs;\n    color /= sin(l) * 0.5;\n    color = mix(color, background(ray), l);\n    return color;\n}\n\nvec3 direction(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l - p),\n         r = normalize(cross(vec3(0, 1, 0), f)),\n         u = cross(f, r),\n         c = f * z,\n         i = c + uv.x * r + uv.y * u;\n    return normalize(i);\n}\n\nvec3 reflection(vec3 rd, vec3 n, float d, vec3 color) {\n    vec3 r = reflect(rd, n);\n    vec3 t = foreground(r).rgb;\n    return vec3(d) * t * color;\n}\n\n/// reflects a surface with chromatic aberration\nvec3 reflection(vec3 rd, vec3 n, float d, vec3 color, float ca) {\n    vec3 t;\n    t.r = foreground(reflect(rd - ca, n)).r;\n    t.g = foreground(reflect(rd, n)).g;\n    t.b = foreground(reflect(rd + ca, n)).b;\n    return vec3(d) * t * color;\n}\n\nvec3 glass(vec3 p, vec3 rd, vec3 n) {\n    const float ior = 3.5;\n    vec3 refo = foreground(reflect(rd, n)); // reflection outside\n    vec3 ri = refract(rd, n, 1.0 / ior);    // inside refraction ray\n    vec3 e = p - n * SURF_DIST * 3.0;       // enter point\n    float i = march(e, ri, INSIDE);         // raymarch the inside\n    e = e + ri * i;                         // exit point\n    vec3 en = - normal(e);                  // exit normal\n\n    vec3 ro, t = vec3(0);\n    // total internal reflection with chromatic aberation \n    const float ca = 0.17; // chromatic aberration\n\n    t.r = foreground(reflect(ri, en - ca)).r;\n    t.g = foreground(reflect(ri, en)).g;\n    t.b = foreground(reflect(ri, en + ca)).b;\n    \n    t = pow(pow(t, vec3(3.0)) * (exp(length(t - 0.2)) * 0.5), vec3(0.9));\n\n    // outside reflection\n    float fresnel = pow(1.0 + dot(rd, n), 8.0);\n    t = mix(t, refo, fresnel);\n\n    return max(vec3(0.0), t);\n}\n\n// ==== CAMERA =====================================================================\n\nvec3 fragment(in vec2 uv) {\n    vec2 m = iMouse.xy / iResolution.xy;\n    vec3 ro = vec3(0, 5, - 4);\n    ro.yz *= rotation(- m.y * 3.14);\n    ro.xz *= rotation(- m.x * 6.2831);// + (sin(iTime / 9.5) * 3.0);\n    vec3 rd = direction(uv, ro, vec3(0, 0.5, 0), 3.0);\n    float d = march(ro, rd, OUTSIDE);\n    vec3 color = vec3((uv.y + 0.5) * 0.5) * background(rd);\n    if (d < MAX_DIST) {\n        vec3 p = ro + rd * d;\n        color = glass(p, rd, normal(p));\n        color = mix(color, background(p), 0.5);\n    }\n    color = pow(color, vec3(0.4545)); // gamma correction\n\treturn color;\n}\n\nvoid mainImage(out vec4 color, in vec2 coord) {\n\tvec2 uv = (coord - 0.5 * iResolution.xy) / iResolution.y;\n\tcolor = vec4(fragment(uv), 1.0);\n}\n","name":"Image","description":"","type":"image"}]}