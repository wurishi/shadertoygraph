{"ver":"0.1","info":{"id":"XXjyDG","date":"1727667400","viewed":19,"name":"Fork Spider 3d - 2024","username":"davidmachadosf","description":"CONTROLS:\n  ARROWS : move image\n  * /    : zoom in/out  \n  + -    : increase/decrease zoom velocity\n  HOME:  : reset initial status\n  .      : cicles pallete\n\nThere are 15 different functions to generate images.\nPgUp and PgDown cicles different functions ","likes":1,"published":1,"flags":48,"usePreview":0,"tags":["math"],"hasliked":0,"parentid":"l3X3WB","parentname":"Spider Web - FixedBack - 3D"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n  David Machado Santos Filho\n  davidmachadosf@gmail.com\n  \n  Based on openprocessing app:\n  https://openprocessing.org/sketch/1916670\n  (same author)\n  \n  \n  Any suggestion for improvement and inclusion of \n  interesting features is welcome! \n  \n  Feel free to fork the code and test your own ideas! \n  This code is copyleft! ;-)\n  \n*/\n\n\n\n\nfloat pi = 3.141592;\n\n// gohu font start\n#define _EXCLAM TXT(p,uvec3(         0,    458240,         0)); // '!'\n#define _QUOTE  TXT(p,uvec3( 939524096,         0,       224)); // '\"'\n#define _SHARP  TXT(p,uvec3(4161339428,4286615583,  37751041)); // '#'\n#define _DOLLAR TXT(p,uvec3( 272908430, 287309585, 236995649)); // '$'\n#define _PRCENT TXT(p,uvec3(1354842114,2349123596, 268476610)); // '%'\n#define _AMP    TXT(p,uvec3(2956722176, 344207888, 285227201)); // '&'\n#define _TICK   TXT(p,uvec3(         0,      7680,         0)); // '''\n#define _LPAREN TXT(p,uvec3(1612578816,   8913944,         4)); // '('\n#define _RPAREN TXT(p,uvec3( 134217728,2248672320,      7681)); // ')'\n#define _TIMES  TXT(p,uvec3(    655428, 268695553,  71305728)); // '*'\n#define _PLUS   TXT(p,uvec3(    262160, 268695553,  16778240)); // '+'\n#define _COMMA  TXT(p,uvec3(         0,    917592,         0)); // ','\n#define _MINUS  TXT(p,uvec3(    262144, 268451841,  16778240)); // '-'\n#define _PERIOD TXT(p,uvec3(         0,    393240,         0)); // '.'\n#define _FSLASH TXT(p,uvec3(  12582912, 201375756,    786624)); // '/'\n#define _0      TXT(p,uvec3( 272596992, 151274514, 266355009)); // '0'\n#define _1      TXT(p,uvec3(1073872896,4278192128,         1)); // '1'\n#define _2      TXT(p,uvec3( 274825216, 285508628, 274743873)); // '2'\n#define _3      TXT(p,uvec3( 270565376, 285492240, 249578561)); // '3'\n#define _4      TXT(p,uvec3(2148270080, 570462210,  33587136)); // '4'\n#define _5      TXT(p,uvec3(2418262016, 151266320, 252723777)); // '5'\n#define _6      TXT(p,uvec3(2420080640, 151266320, 251675201)); // '6'\n#define _7      TXT(p,uvec3( 268451840, 822543360,   3146560)); // '7'\n#define _8      TXT(p,uvec3( 272334848, 285492241, 249578561)); // '8'\n#define _9      TXT(p,uvec3( 268664832, 285492241, 132129857)); // '9'\n#define _COLON  TXT(p,uvec3(         0,2349215744,         1)); // ':'\n#define _SCOLON TXT(p,uvec3(3221225472,    929880,         0)); // ';'\n#define _LT     TXT(p,uvec3(    524288,  67248133,     32897)); // '<'\n#define _EQ     TXT(p,uvec3(1074855936,1140920324,  71307520)); // '='\n#define _GT     TXT(p,uvec3(1082163200,1342316560,      2048)); // '>'\n#define _QMARK  TXT(p,uvec3( 134234112, 277250560,   7340576)); // '?'\n#define _AT     TXT(p,uvec3(3359645951,1116015123, 401623201)); // '@'\n#define _A      TXT(p,uvec3( 276791296, 285230081, 534774848)); // 'A'\n#define _B      TXT(p,uvec3( 276807680, 285492241, 249578561)); // 'B'\n#define _C      TXT(p,uvec3( 272596992,  17040400, 136331329)); // 'C'\n#define _D      TXT(p,uvec3( 276807680,  17040400, 130031745)); // 'D'\n#define _E      TXT(p,uvec3( 276807680, 285492241, 269500481)); // 'E'\n#define _F      TXT(p,uvec3( 276807680, 285230081,   1048640)); // 'F'\n#define _G      TXT(p,uvec3( 272596992, 285475856, 253772865)); // 'G'\n#define _H      TXT(p,uvec3(   8372224, 268451841, 535823360)); // 'H'\n#define _I      TXT(p,uvec3( 268435456,  17300496,         1)); // 'I'\n#define _J      TXT(p,uvec3(   3145728,    262160, 267403265)); // 'J'\n#define _K      TXT(p,uvec3(   8372224,1140891649, 269492352)); // 'K'\n#define _L      TXT(p,uvec3(   8372224,    262160, 268451841)); // 'L'\n#define _M      TXT(p,uvec3(1073775103,  67133440, 535822464)); // 'M'\n#define _N      TXT(p,uvec3(1618984960,1610637312, 535846912)); // 'N'\n#define _O      TXT(p,uvec3( 272596992,  17040400, 266354753)); // 'O'\n#define _P      TXT(p,uvec3( 276807680, 285230081,  14681152)); // 'P'\n#define _Q      TXT(p,uvec3( 272596992,1627653136, 937435201)); // 'Q'\n#define _R      TXT(p,uvec3( 276807680, 822100993, 417338432)); // 'R'\n#define _S      TXT(p,uvec3( 270761984, 285492241, 236995649)); // 'S'\n#define _T      TXT(p,uvec3( 268451841,  17300480,   1048640)); // 'T'\n#define _U      TXT(p,uvec3(   4177920,    262160, 267403265)); // 'U'\n#define _V      TXT(p,uvec3(    245760,2147876871,  15735809)); // 'V'\n#define _W      TXT(p,uvec3(   7340095, 536899586,  66088960)); // 'W'\n#define _X      TXT(p,uvec3(3227566080, 268451846, 405805824)); // 'X'\n#define _Y      TXT(p,uvec3(    196611, 268926977,   3146496)); // 'Y'\n#define _Z      TXT(p,uvec3( 275791872, 151274514, 271597889)); // 'Z'\n#define _LBRKET TXT(p,uvec3(         0,   9436672,     32802)); // '['\n#define _BSLASH TXT(p,uvec3( 805318656, 805318656, 805318656)); // '\\'\n#define _RBRKET TXT(p,uvec3( 134217728,4287103520,         3)); // ']'\n#define _CARET  TXT(p,uvec3( 268468224,  16777728,       128)); // '^'\n#define _UNDER  TXT(p,uvec3(   8389120,    524320, 536903682)); // '_'\n#define _BTICK  TXT(p,uvec3( 268443648,      2048,         0)); // '`'\n#define _a      TXT(p,uvec3(1077411840, 335826961, 528491777)); // 'a'\n#define _b      TXT(p,uvec3(2155864064,  67375120, 260063489)); // 'b'\n#define _c      TXT(p,uvec3(1077805056,  67375120, 142622977)); // 'c'\n#define _d      TXT(p,uvec3(1077805056,  67375120, 536355073)); // 'd'\n#define _e      TXT(p,uvec3(1077805056, 604278802, 327174401)); // 'e'\n#define _f      TXT(p,uvec3(4026531840, 142615071,       544)); // 'f'\n#define _g      TXT(p,uvec3(1077805056,  69472400,2143428873)); // 'g'\n#define _h      TXT(p,uvec3(2155864064,  67112960, 528482560)); // 'h'\n#define _i      TXT(p,uvec3(1073807360,    521728,     16385)); // 'i'\n#define _j      TXT(p,uvec3(  33554432,4255125632,         7)); // 'j'\n#define _k      TXT(p,uvec3(   8380416,1342210050, 268444160)); // 'k'\n#define _l      TXT(p,uvec3( 134217728,    261632, 268451841)); // 'l'\n#define _m      TXT(p,uvec3(1073807868,  67629056, 528482560)); // 'm'\n#define _n      TXT(p,uvec3(1082064896,  67112960, 528482560)); // 'n'\n#define _o      TXT(p,uvec3(1077805056,  67375120, 260063489)); // 'o'\n#define _p      TXT(p,uvec3(2214526976,  67375120, 260063489)); // 'p'\n#define _q      TXT(p,uvec3(1077805056,  67375120,4290781441)); // 'q'\n#define _r      TXT(p,uvec3(2155806720,  67112960,   8388864)); // 'r'\n#define _s      TXT(p,uvec3(1078329344, 604278802, 201345281)); // 's'\n#define _t      TXT(p,uvec3(1073741824,  67370496,     16641)); // 't'\n#define _u      TXT(p,uvec3(   4128768,    262160, 532684801)); // 'u'\n#define _v      TXT(p,uvec3(    458752,2147876870,  29366273)); // 'v'\n#define _w      TXT(p,uvec3(   6291580,1073790980, 130048000)); // 'w'\n#define _x      TXT(p,uvec3(   6488064, 536903685, 415241216)); // 'x'\n#define _y      TXT(p,uvec3(   4128768,   2359440,2143428617)); // 'y'\n#define _z      TXT(p,uvec3(1080098816, 335843348, 272646913)); // 'z'\n#define _LCURL  TXT(p,uvec3(    524320,   9403394,1074331684)); // '{'\n#define _PIPE   TXT(p,uvec3(         0,   2096640,         0)); // '|'\n#define _RCURL  TXT(p,uvec3( 151003136,3742368320,  33556483)); // '}'\n#define _TILDE  TXT(p,uvec3(2147614768, 536887296,  25167872)); // '~'\n#define _        CURSOR.x+=8;\n#define _NEWLINE CURSOR=ivec2(CURSOR_START.x, CURSOR.y-14);\n#define NUM(value) _NUM(p,value);\n#define FNUM(value) _FNUM(p,value, 5);\nvec3 TXT_COL=vec3(0.0); ivec2 CURSOR_START = ivec2(0), CURSOR = ivec2(0);\nvoid TXT(vec2 p, uvec3 g){_ int x=int(p.x)-CURSOR.x,y=CURSOR.y-int(p.y),b=x*14+y-16;if(x>0&&x<8&&y>=0&&y<14&&b>=0)TXT_COL+=vec3((g[b/32]>>(b&31))&1u); }\nvoid _NUM(vec2 p, float n){\n\n    if(n<0.){\n        _MINUS n=-n;\n    }\n    \n    \n    for (int i=6,k=100000000,m=int(round(n*100.0));i>-3;i--,k/=10){\n    \n        int d = m>=k||i<=0?int(m/k)%10:-1;\n        \n        if(i==-1)_PERIOD \n        if(d==0)_0 \n        if(d==1)_1 \n        if(d==2)_2 \n        if(d==3)_3 \n        if(d==4)_4 \n        if(d==5)_5 \n        if(d==6)_6 \n        if(d==7)_7 \n        if(d==8)_8 \n        if(d==9)_9 \n        \n        if(i==0&&(m%100)==0)break;\n     }\n }\n \n \n void _FNUM(vec2 p, float n,int point){\n\n    if(n<0.){\n        _MINUS n=-n;\n    }\n    \n    \n    for (int i=6,k=100000000,m=int(round(n*100000000.0));i>-3;i--,k/=10){\n    \n        int d = m>=k||i<=0?int(m/k)%10:-1;\n        \n        if(i==point)_PERIOD \n        if(d==0)_0 \n        if(d==1)_1 \n        if(d==2)_2 \n        if(d==3)_3 \n        if(d==4)_4 \n        if(d==5)_5 \n        if(d==6)_6 \n        if(d==7)_7 \n        if(d==8)_8 \n        if(d==9)_9 \n        \n        if(i==0&&(m%100000000)==0)break;\n     }\n }\n// gohu font end\n\n\n\nfloat n = 10.;\nfloat thetax = 0.;\nfloat thetay = .5*3.141592;\n\n\n\n\nfloat processFunction(int func, float x, float y){\n\n    switch(func){\n        case  0: return log(abs(x)) + log(abs(y));\n        case  1: return log(abs(x)) +         y  ;\n        case  2: return         x   + log(abs(y));\n        case  3: return         x   +         y  ;\n        case  4: return         x   +       y*y  ;\n        case  5: return       x*x   +       y*y  ;\n        case  6: return       x*x   +     y*y*y  ;\n        case  7: return     x*x*x   +       y*y  ;\n        case  8: return     x*x*x   +     y*y*y  ;\n        case  9: return   x*x*x*x   +   y*y*y*y  ;\n        case 10: return x*x*x*x*x   + y*y*y*y*y  ;\n        case 11: return      1./x   +      1./y  ;\n        case 12: return  1./(x*x)   +  1./(y*y)  ;\n        case 13: return 1./(x*x*x)  + 1./(y*y*y) ;\n        case 14: return  sin (log(abs(x*y))) + \n                         cos (log(abs(y/x)))     ;\n                         \n        case 15: return  sin (log(abs(x/y))) + \n                         cos (log(abs(y*(y+x))))     ;\n    }\n\n}\n\nfloat processDeep(int deep, int func, float x, float y){\n\n   switch(deep){ \n       //case 0: return cos(pow(y*y+x*x,.5));\n       case 0: return pow(y*y+x*x,.5);\n       case 1: return cos(x+y);\n       case 2: return abs(x*x);\n       case 3: return abs(y*y);\n       case 4: return 100.*processFunction(func,x,y);\n       //case 5: return 50.*processFunction(func,x,y) + 50.*processFunction(func+1>=16?0:func+1,x,y);\n       case 5: return 100.*processFunction(func,cos(x*10.),y*y);\n       case 6: return(x+y);\n       case 7: return(y*x);\n       case 8: return cos(x*y);\n       case 9: return sin(x*y);\n       case 10: return (x*y)/100.;\n   }\n    //return pow(y*y+x*x,.5);\n\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n    bool crosseye = get(paramCrosseye)>0.;\n    bool anaglyph = get(paramAnaglyph)>0.;\n    \n    bool esq;\n    \n    if(crosseye){\n        esq = (fragCoord.x/iResolution.x)<.5;\n    \n        if(!esq){\n            fragCoord.x -= iResolution.x/2.;\n        }\n        fragCoord.x *= 2.;\n    }\n    else{\n        esq = int(fragCoord.y)%2==0;\n    }\n    \n     \n    float[10] colors;\n    //int ini=2;\n    \n    //\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n     uv -= vec2(.5,0.);\n    uv *= vec2(iResolution.x/iResolution.y,1.);\n    uv += vec2(.5,0.);\n    //uv *= vec2(iResolution.x/iResolution.y,1.);\n    //uv += vec2(.5,0.);\n    \n    \n    // get parameters\n    float xi   = get(paramXi );\n    float xf   = get(paramXf );\n    float yi   = get(paramYi );\n    float yf   = get(paramYf );\n    float vel  = get(paramVel);\n    \n    float fFunc = get(paramFunc);\n    int func = int(fFunc);\n    int off = int(get(paramOff));\n     \n    bool      cicle = get(paramCicle)>0.;\n    float  velCicle = get(paramVelCicle);\n    float timeCicle = get(paramTimeCicle);\n    float timeBase  = get(paramTimeBase);    \n    float cpow      = get(paramCpow);\n    \n    float paralax   = get(paramParalax);\n    \n    float fPall = get(paramPall);\n    int pall = int(fPall);\n\n\n    float fCoord = get(paramCoord);\n    int coord = int(fCoord);\n    \n    float fReverse = get(paramReverse);\n    float fUrev = get(paramUrev);\n    bool reverse = fReverse>0.;\n    bool urev = fUrev>0.;\n    \n    bool params = get(paramParams)>0.;\n    \n    float x = (xi+(xf-xi)*uv.x);\n    float y = (yi+(yf-yi)*uv.y);\n    \n    \n    float zoom=pow(pow(xf-xi,2.)+pow(yf-yi,2.),.5);\n    \n    \n    //*(.1*pow((y*y+x*x)*1.,.5))/zoom;\n    ;\n    \n    float d, newx, newy;\n    float t = timeCicle;\n          \n    for(int i=0;i<10;i++){\n    \n        //float xStereo = x + paralax*(esq?-1.:+1.);\n\n        d = processFunction(func,x,y);\n\n        if(cicle){\n           newx=sin(y/d+x/sqrt(n)+thetax);\n           newy=sin(x/d+y/sqrt(n)+thetay);\n        }\n        else {\n           newx=sin(y/d+x/sqrt(n)+thetax-2.*iTime);\n           newy=sin(x/d+y/sqrt(n)+thetay+.5*iTime);\n\t\t}\t\t\n\t\t\n        // bellow some different recurrence steps if anyone wants to test ;-)\n        \n        //newx=sin(y/d+x/d+thetax);\n        //newy=sin(x/d+y/d+thetay);\n\t\t\t\t\n\t\t//newx=sin(y/sqrt(n)+x/sqrt(n)+thetax);\n        //newy=sin(x/sqrt(n)+y/sqrt(n)+thetay);\n\t\t\t\t\n\t\t//newx=sin(log(y)/d+log(x)/sqrt(n)+thetax);\n        //newy=sin(log(x)/d+log(y)/sqrt(n)+thetay);\n\t\t\t\t\n        x = newx;\n\t\ty = newy;\n        \n        colors[i]=abs(280.-pow(x+y,2.)*128.);\n      }\n\t\t\t\n\n    // Output to screen\n    //vec3 col = vec3();\n    \n    fragColor = vec4(colors[off]/256.,colors[off+1]/256.,colors[off+2]/256.,1.0);\n   \n    \n    // uncomment to generate RED-BLUE anaglyphs,\n    // to visualize on non interlaced-3D devices\n    /*if(esq){\n        fragColor *= vec4(1.,0.,0.,0.);\n    }\n    else{\n        fragColor *= vec4(0.,1.,1.,0.);\n    }*/\n    \n    \n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"/*\n  David Machado Santos Filho\n  davidmachadosf@gmail.com\n  \n  Based on openprocessing app:\n  https://openprocessing.org/sketch/1916670\n  (same author)\n  \n  \n  Any suggestion for improvement and inclusion of \n  interesting features is welcome! \n  \n  Feel free to fork the code and test your own ideas! \n  This code is copyleft! ;-)\n  \n*/\n\n// parameters (coordinates on texture buffer)\nconst ivec2 paramXi = ivec2(0,0);\nconst ivec2 paramXf = ivec2(0,1);\nconst ivec2 paramYi = ivec2(0,2);\nconst ivec2 paramYf = ivec2(0,3);\n\nconst ivec2 paramVel   = ivec2(1,0);\nconst ivec2 paramFunc  = ivec2(2,0);\n\n\nconst ivec2 paramCicle     = ivec2(3,0);\nconst ivec2 paramVelCicle  = ivec2(3,1);\nconst ivec2 paramTimeCicle = ivec2(3,2);\nconst ivec2 paramTimeBase  = ivec2(3,3);\nconst ivec2 paramParams    = ivec2(3,4);\n\nconst ivec2 paramCpow      = ivec2(4,0);\nconst ivec2 paramPall      = ivec2(4,1);\nconst ivec2 paramCoord     = ivec2(4,2);\nconst ivec2 paramReverse   = ivec2(4,3);\nconst ivec2 paramUrev      = ivec2(4,4);\n\nconst ivec2 paramParalax   = ivec2(4,5);\nconst ivec2 paramCrosseye  = ivec2(4,6);\nconst ivec2 paramAnaglyph  = ivec2(4,7);\n\nconst ivec2 paramOff   = ivec2(4,8);\n\n\n// read and store values as x value on texture pixels\n#define get(var) texelFetch(iChannel0, var, 0).x\n#define set(var, value, fragColor, fragCoord) fragColor=(ivec2(fragCoord)==var?vec4(value,0.,0.,1.):fragColor)\n\n\n// reset to initial parameters\nconst int keyReset = 83; // s//the \"' key, below Esc\n\n// change image functions\nconst int keyPrev = 33; // PgUp\nconst int keyNext = 34; // PgDown\n\n\n// change position (arrow keys)\nconst int keyNorth = 38;\nconst int keySouth = 40;\nconst int keyEast  = 37;\nconst int keyWest  = 39;\nconst int keyOrig  = 12;\n\n\n// keycodes below are from numeric keyboard\n\n// change scale\nconst int keyZoomOut = 111; // /\nconst int keyZoomIn  = 106; // *\n\n// change scale velocity\nconst int keySlow = 109; // -\nconst int keyFast = 107; // +\n\n// cicle palete over time\nconst int keyCicle = 110; // .\n\n// change cicle velocity\nconst int keyCicleSlow = 36; // Home\nconst int keyCicleFast = 35; // End\n\n\n// change palete pow\nconst int keyPowDec  = 81; // q\nconst int keyPowInc  = 65; // a\nconst int keyPowZero = 90; // z\n\n\n// change palete type\nconst int keyPallInc  = 80; // p\nconst int keyPallDec  = 79; // o\nconst int keyPallZero = 73; // i\n\n// toglr polar/cartesian coordinates\n//const int keyPolar = 45; // insert, 0 on keypad\nconst int keyCoord = 45; // insert, 0 on keypad\n\n// toglr polar/cartesian coordinates\nconst int keyReverse = 82; // r\nconst int keyUrev    = 85; // u\n\n// zero time\nconst int keyZeroTime = 84; // t\n\n// show parameter values\nconst int keyParams = 86; // v\n\n\n\n#define keyToggle(code)  ( texelFetch(iChannel1,ivec2(code,2),0).x > 0.)\n#define keyClick(code)   ( texelFetch(iChannel1,ivec2(code,1),0).x > 0.)\n#define keyDown(code)    ( texelFetch(iChannel1,ivec2(code,0),0).x > 0.)\n\n#define shift             ( texelFetch(iChannel1,ivec2(16,0),0).x  > 0.)\n#define ctrl              ( texelFetch(iChannel1,ivec2(17,0),0).x  > 0.)\n#define alt               ( texelFetch(iChannel1,ivec2(18,0),0).x  > 0.)\n#define modifier          ( int(shift) +2*int(ctrl) + 4*int(alt) )\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"/*\n  David Machado Santos Filho\n  davidmachadosf@gmail.com\n  \n  Based on openprocessing app:\n  https://openprocessing.org/sketch/1916670\n  (same author)\n  \n  \n  Any suggestion for improvement and inclusion of \n  interesting features is welcome! \n  \n  Feel free to fork the code and test your own ideas! \n  This code is copyleft! ;-)\n  \n*/\n\n\n/* MANUAL\n\nKEYS\n    ' : reset\n  (numpad numlock OFF):..\n    ARROWS   : move\n    NUMPAD5  : center 0,0\n    * /      : zoom in/out  \n    + -      : inc/dec zoom vel\n    .        : pause/play time\n    Home End : inc/dec cicle vel\n    PgUp PgDown: Cicle 31 diff f(x,y)\n    q a: change palete gamute\n    \n*/\n\n\nconst float minFloat  = .000001;\nconst float lastFunc  = 57.;\nconst float lastPall  = 15.;\nconst float lastCoord = 12.;\n\n\n// initial parameter values\nfloat iniXi       =  -60. ;\nfloat iniXf       =   60. ;\nfloat iniYi       =  -23. ;\nfloat iniYf       =   23. ;\nfloat iniVel      =   .01 ;\nfloat iniFunc     =   29. ;\nfloat iniCoord    =    0. ; \n\nfloat iniCicle     =  1.  ; // -1.: FALSE 1.:TRUE\nfloat iniVelCicle  =  1.  ;\nfloat iniTimeCicle =  0.  ;\nfloat iniTimeBase  =  0.  ;\nfloat iniParams    =  1.  ; // -1.: FALSE 1.:TRUE\n\n\nfloat iniCpow = 1. ; \nfloat iniPall = 4. ; \n\nfloat iniParalax = 1.5;\n\n\nfloat iniReverse = -1.; // -1.: normal colors 1.:reversed colors\nfloat iniUrev    = -1.; // -1.: uniform 0-1 colors: 1. reversed 1-0 uniform scale\n\nfloat iniCrosseye = -1.; // -1.: interlaced 3D 1.:crossed eyes 3d\nfloat iniAnaglyph = -1.; // -1.: no anaglyphs 1.:uses red-blue anaglips\n\n\nfloat iniOff   =  2.;\n\nvoid initParameters(inout vec4 fragColor, in vec2 fragCoord){\n    set(paramXi,       iniXi,       fragColor, fragCoord);   \n    set(paramXf,       iniXf,       fragColor, fragCoord);   \n    set(paramYi,       iniYi,       fragColor, fragCoord);   \n    set(paramYf,       iniYf,       fragColor, fragCoord);   \n    set(paramVel,      iniVel,      fragColor, fragCoord);   \n    set(paramFunc,     iniFunc,     fragColor, fragCoord);   \n    \n    set(paramCicle,     iniCicle,     fragColor, fragCoord);   \n    set(paramVelCicle,  iniVelCicle,  fragColor, fragCoord);   \n    set(paramTimeCicle, iniTimeCicle, fragColor, fragCoord);   \n    set(paramTimeBase,  iniTimeBase,  fragColor, fragCoord); \n    set(paramParams,    iniParams,    fragColor, fragCoord); \n    \n    set(paramParalax,    iniParalax,    fragColor, fragCoord); \n\n    \n    set(paramCpow,  iniCpow,  fragColor, fragCoord); \n    set(paramPall,  iniPall,  fragColor, fragCoord); \n    set(paramCoord, iniCoord, fragColor, fragCoord); \n    \n    set(paramReverse,  iniReverse,  fragColor, fragCoord); \n    set(paramUrev,     iniUrev,     fragColor, fragCoord); \n    set(paramCrosseye, iniCrosseye, fragColor, fragCoord);\n    set(paramAnaglyph, iniAnaglyph, fragColor, fragCoord);\n    \n    set(paramOff,   iniOff,   fragColor, fragCoord);  \n    \n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    \n    // initialize values\n    if (iFrame==0) {\n        initParameters(fragColor, fragCoord);    \n    }\n\n    else { \n    \n        // get current values\n        float xi       = get(paramXi);   \n        float xf       = get(paramXf);   \n        float yi       = get(paramYi);   \n        float yf       = get(paramYf);   \n        float vel      = get(paramVel);   \n        float func     = get(paramFunc); \n        \n         float off   = get(paramOff); \n        \n        float cicle     = get(paramCicle);  \n        float velCicle  = get(paramVelCicle);  \n        float timeCicle = get(paramTimeCicle);  \n        \n        float timeBase  = get(paramTimeBase);\n        float params    = get(paramParams);\n        \n        float paralax   = get(paramParalax);\n        \n        float cpow      = get(paramCpow);\n        float pall      = get(paramPall);\n        float coord     = get(paramCoord);\n        float reverse   = get(paramReverse);\n        float urev      = get(paramUrev);\n        \n        \n        float crosseye  = get(paramCrosseye);\n        float anaglyph  = get(paramAnaglyph);\n        \n        // current visible window size\n        float dx = xf-xi;\n        if(dx<minFloat){\n            dx = minFloat;\n        }\n        \n        \n        float dy = yf-yi;\n        if(dy<minFloat){\n            dy = minFloat;\n        }\n        \n        \n       \n        \n        // move image\n        if(keyDown(keyNorth)){\n            yi+=dy/100.;\n            yf+=dy/100.;\n        }\n        if(keyDown(keySouth)){\n            yi-=dy/100.;\n            yf-=dy/100.;\n        }\n        if(keyDown(keyEast)){\n            xi-=dx/100.;\n            xf-=dx/100.;\n        }\n        if(keyDown(keyWest)){\n            xi+=dx/100.;\n            xf+=dx/100.;\n        }\n        \n        // return to 0,0 (dont change scale)\n        if(keyDown(keyOrig)){\n            xi=-dx/2.;\n            xf=+dx/2.;\n            yi=-dy/2.;\n            yf=+dy/2.;\n        }\n        \n        // zoom controls\n        if(keyDown(keyZoomOut)){\n            xi-=dx*vel;\n            xf+=dx*vel;\n            if(!shift){\n                yi-=dy*vel;\n                yf+=dy*vel;\n            }\n        }        \n        if(keyDown(keyZoomIn)){\n            xi+=dx*vel;\n            xf-=dx*vel;\n            if(!shift){\n                yi+=dy*vel;\n                yf-=dy*vel;\n            }\n        }\n        \n        \n        \n        \n         // change paralax\n        bool changedParalax = false; \n        if(keyDown(keySlow)){\n            if(shift){\n                paralax/=1.01;\n                if(paralax<=minFloat){\n                    paralax = minFloat;\n                }\n                changedParalax = true;\n            }\n        }\n        \n        if(keyDown(keyFast)){\n            if(shift){\n                paralax*=1.01;\n                if(paralax>=10000.){\n                    paralax = 10000.;\n                }\n                changedParalax = true;\n            }\n        }\n        \n        if(!changedParalax){\n\t\t    // zoom velocity change\n\t\t    if(keyClick(keySlow)){\n\t\t        if(!shift){\n\t\t            vel/=2.;\n                    if(vel<=minFloat){\n                        vel=minFloat;\n                    }\n                    \n\t\t        }\t\t        \n\t\t    }        \n\t\t    if(keyClick(keyFast)){\n\t\t        if(!shift){\n\t\t            vel*=2.;\n\t\t        }\t\t        \n\t\t    }\n        }\n        \n       \n        // restart to initial status\n        if(keyClick(keyReset)){            \n            xi    = iniXi;\n            xf    = iniXf;\n            yi    = iniYi;\n            yf    = iniYf;\n            vel   = iniVel;\n            func  = iniFunc;\n            \n            cicle     = iniCicle;\n            velCicle  = iniVelCicle;  \n            timeCicle = 0.; \n            timeBase  = 1.*iTime;\n            paralax   = iniParalax;\n        }\n        \n        \n        // change f(x,y) function\n        if(keyClick(keyPrev)){\n            if(!shift){\n                func = func-1.;\n                if(func<0.) func = lastFunc;\n            }\n            else{\n                off = off-1.;\n                if(off<0.) off = 7.;            \n            }\n        }        \n        if(keyClick(keyNext)){\n            if(!shift){ \n                func = func+1.;\n                if(func>=16.) func = 0.;\n            }\n            else{\n                off = off+1.;\n                if(off>=8.) off = 0.;\n            }\n        }\n        \n        // cicle fase and colors by iTime\n        if(keyClick(keyCicle)){\n            // its a bool, but I must store as float... \n            \n            if(shift){\n                crosseye*=-1.;\n            }\n            else\n            if(ctrl){\n                anaglyph*=-1.;\n            }            \n            else {\n                float fTime = 1.*iTime;\n\n                if(cicle < 0.){\n                    // estava parado                \n                    timeBase = fTime;\n                }\n                else{\n                    // estava ciclando\n                    float dt  = (fTime - timeBase)*velCicle;\n                    timeCicle += dt;\n                    timeBase = timeCicle;        \n                }\n\n                cicle*=-1.;\n            }\n        }\n        \n        // cicle velocity change\n        if(keyDown(keyCicleSlow)){\n        \n            \n            float fTime = 1.*iTime;\n            \n            if(cicle > 0.){\n                // estava ciclando\n                float dt  = (fTime - timeBase)*velCicle;\n                timeCicle += dt;\n                timeBase = fTime;        \n            }\n        \n            velCicle/=1.01; \n            if(velCicle<=minFloat){\n                velCicle=minFloat;\n            }\n        }        \n        if(keyDown(keyCicleFast)){\n            \n            float fTime = 1.*iTime;\n            \n            if(cicle > 0.){\n                // estava ciclando\n                float dt  = (fTime - timeBase)*velCicle;\n                timeCicle += dt;\n                timeBase = fTime;        \n            }\n            \n            velCicle*=1.01;            \n        }\n        \n        \n        // change palete power\n        if(keyDown(keyPowDec)){\n            cpow /=1.01;\n            if(cpow<=minFloat){\n                cpow=minFloat;\n            }\n        }        \n        if(keyDown(keyPowInc)){\n            cpow *=1.01;\n        }\n        if(keyClick(keyPowZero)){\n            cpow = iniCpow;\n        }      \n        \n        // change palete \n        if(keyClick(keyPallDec)){\n            pall = pall-1.;\n            if(pall<0.) pall = lastPall;\n        }        \n        if(keyClick(keyPallInc)){\n            pall = pall+1.;\n            if(pall>lastPall) pall = 0.;\n        }\n        if(keyClick(keyPallZero)){\n            pall = iniPall;\n        }  \n        \n        // change coords systems\n        if(keyClick(keyCoord)){\n            coord = coord+1.;\n            if(coord>lastCoord) coord = 0.;\n        }\n        \n        // change color normal/reversed\n        if(keyClick(keyReverse)){\n            // its a bool, but I must store as float... \n            reverse*=-1.;\n        }\n        \n        \n        // change pallete mapping 0-1  1-0\n        if(keyClick(keyUrev)){\n            // its a bool, but I must store as float... \n            urev*=-1.;\n        }\n        \n        // zero time\n        if(keyClick(keyZeroTime)){\n            \n           timeCicle = 0.; \n           timeBase  = 1.*iTime;    \n            \n        }\n        \n        \n         // change showParams\n        if(keyClick(keyParams)){\n            // its a bool, but I must store as float... \n            params*=-1.;\n        }\n        \n        \n        \n        // update parameters\n        set(paramXi,       xi,       fragColor, fragCoord);   \n        set(paramXf,       xf,       fragColor, fragCoord);   \n        set(paramYi,       yi,       fragColor, fragCoord);   \n        set(paramYf,       yf,       fragColor, fragCoord);   \n        set(paramVel,      vel,      fragColor, fragCoord);   \n        set(paramFunc,     func,     fragColor, fragCoord);   \n        \n        set(paramCicle,     cicle,     fragColor, fragCoord); \n        set(paramVelCicle,  velCicle,  fragColor, fragCoord); \n        set(paramTimeCicle, timeCicle, fragColor, fragCoord); \n        set(paramTimeBase,  timeBase, fragColor, fragCoord); \n        set(paramParams,    params,    fragColor, fragCoord); \n        \n        set(paramParalax,   paralax,    fragColor, fragCoord); \n     \n        set(paramCpow,  cpow,  fragColor, fragCoord); \n        set(paramPall,  pall,  fragColor, fragCoord); \n        set(paramCoord, coord, fragColor, fragCoord); \n        \n        set(paramReverse, reverse, fragColor, fragCoord); \n        set(paramUrev,    urev,    fragColor, fragCoord); \n        \n        set(paramCrosseye, crosseye, fragColor, fragCoord);\n        set(paramAnaglyph, anaglyph, fragColor, fragCoord);\n    }\n}\n","name":"Buffer A","description":"","type":"buffer"}]}