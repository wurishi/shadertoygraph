{"ver":"0.1","info":{"id":"ll3GWl","date":"1472741912","viewed":300,"name":"020 diffuse material","username":"kakaxizhhgjh","description":"diffuse material","likes":8,"published":1,"flags":32,"usePreview":0,"tags":["diffusematerial"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tfragColor = vec4(pow(texture(iChannel0, uv).rgb, vec3(0.45)), 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"struct Ray\t\t{ vec3 o, d; };\nstruct Hit\t\t{ float t; vec3 n, c; };\nstruct Sphere\t{ float r; vec3 p, c; };\nstruct Plane \t{ float d; vec3 n, c; };\nstruct Box\t\t{ vec3 center, size, c; };\n\nconst float PI   = 3.141692;\nconst float EPS  = 1e-3;\nconst float TMAX = 1e2;\nconst int   ITER = 6;\nconst Hit   MISS = Hit(TMAX, vec3(0), vec3(0));\n\nfloat rand(vec2 scale, float seed) {\n    return fract(sin(mod(dot(gl_FragCoord.xy * seed, scale), 3.1415926)) * 43758.5453);\n}\n\nvec3 cosineWeightedRay(vec3 n, float t) {\n    float u = rand(vec2(12.9898, 78.233), t);\n    float v = rand(vec2(63.7264, 10.873), t);\n    float phi = 2.0 * PI * u;\n    float stheta  = sqrt(v);\n    vec3 x = abs(n.x) < 0.5 ? vec3(1, 0, 0) : vec3(0, 1, 0);\n    vec3 z = normalize(cross(x, n));\n    x = cross(n, z);\n    return mat3(x, n, z) * vec3(stheta * cos(phi), sqrt(1.0 - v), stheta * sin(phi));\n}\n\nvec3 boxNormal(vec3 p, Box b) {\n\tvec3 delta = (p - b.center ) / b.size;\n\treturn normalize(step(1.0 - EPS, delta) - step(1.0 - 0.0001, -1.0 * delta));\n}\n\nvec3 getNormal(vec3 p, Box b) {\n\tvec3 bmin = b.center - b.size;\n    vec3 bmax = b.center + b.size;\n    if(p.x < bmin.x + EPS) return vec3(-1, 0, 0);\n    else if(p.x > bmax.x - EPS) return vec3(1, 0, 0);\n    else if(p.y < bmin.y + EPS) return vec3(0, -1, 0);\n    else if(p.y > bmax.y - EPS) return vec3(0, 1, 0);\n    else if(p.z < bmin.z - EPS) return vec3(0, 0, -1);\n    else return vec3(vec3(0, 0, 1));\n}\n\nHit intersect(Ray r, Box b) {\n    vec3 bmin = b.center - b.size;\n    vec3 bmax = b.center + b.size;\n    vec3 tmin = (bmin - r.o) / r.d;\n    vec3 tmax = (bmax - r.o) / r.d;\n    vec3 t1 = min(tmin, tmax);\n    vec3 t2 = max(tmin, tmax);\n    float tNear = max(max(t1.x, t1.y), t1.z);\n    float tFar  = min(min(t2.x, t2.y), t2.z);\n    \n    if(tNear > tFar) return MISS;\n    return Hit(tNear, getNormal(r.o + tNear * r.d, b), b.c);\n}\n\nHit intersect(Ray r, Sphere s) {\n    vec3 op = s.p - r.o;\n    float b = dot(op, r.d);\n    float det = b * b - dot(op, op) + s.r * s.r;\n    if(det < EPS) return MISS;\n    det = sqrt(det);\n    float t = b - det;\n    if(t < EPS) return MISS;\n    return Hit(t, (r.o + t * r.d - s.p) / s.r, s.c);\n}\n\nHit intersect(Ray r, Plane p) {\n    float t = (p.d - dot(p.n, r.o)) / dot(r.d, p.n);\n    if(t < EPS) return MISS;\n    return Hit(t, p.n, p.c);\n}\n\nBox boxs[8];\nHit intersect(Ray r) {\n    boxs[0] = Box(vec3( 0.6, 0.5,  0.6), vec3(0.5), vec3(0.1, 0.1, 0.1));\n    boxs[1] = Box(vec3( 0.6, 0.5, -0.6), vec3(0.5), vec3(1.0, 0.1, 0.1));\n    boxs[2] = Box(vec3(-0.6, 0.5,  0.6), vec3(0.5), vec3(0.1, 0.1, 1.0));\n    boxs[3] = Box(vec3(-0.6, 0.5, -0.6), vec3(0.5), vec3(1.0, 0.1, 1.0));\n    boxs[4] = Box(vec3( 0.6, 1.7,  0.6), vec3(0.5), vec3(0.1, 1.0, 0.1));\n    boxs[5] = Box(vec3( 0.6, 1.7, -0.6), vec3(0.5), vec3(1.0, 1.0, 0.1));\n    boxs[6] = Box(vec3(-0.6, 1.7,  0.6), vec3(0.5), vec3(0.1, 1.0, 1.0));\n    boxs[7] = Box(vec3(-0.6, 1.7, -0.6), vec3(0.5), vec3(1.0, 1.0, 1.0));\n    \n    Hit hit = intersect(r, Plane(0.0, vec3(0, 1, 0), vec3(1)));\n    \n    for(int i = 0; i < 8; ++i) {\n    \tHit tmp = intersect(r, boxs[i]);\n        if(tmp.t > EPS && tmp.t < hit.t) hit = tmp;\n    }\n    return hit;\n}\n\nvec3 radiance(Ray r) {\n\tvec3 color = vec3(0);\n    vec3 mask  = vec3(1);\n    for(int i = 0; i < ITER; ++i) {\n    \tHit hit = intersect(r);\n        if(hit.t < TMAX) {\n        \tmask *= hit.c;\n            r = Ray(r.o + (hit.t + EPS) * r.d, cosineWeightedRay(hit.n, iTime));\n        } else {\n            color += mask * texture(iChannel1, r.d).rgb;\n            break;\n        }\n    }\n    return color;\n}\n\nmat3 getCamera(vec3 ro, vec3 o) {\n    vec3 z = normalize(ro - o);\n    vec3 x = normalize(cross(vec3(0, 1, 0), z));\n    return mat3(x, cross(z, x), z);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec3 info = texture(iChannel0, vec2(0)).rgb;\n    float weight = info.z;\n\n    if(length(info.xy * iResolution.xy - iMouse.xy) > 1.0 || iFrame == 0){\n        weight = 1.0;\n    }\n    \n    if(fragCoord.x == 0.5 && fragCoord.y == 0.5){\n        fragColor = vec4(iMouse.xy / iResolution.xy, 1.0 / (1.0 / weight + 1.0), 0.0);\n        return;\n    }\n    \n    vec2 st = fragCoord / iResolution.xy;\n    vec2 mo = (iMouse.xy * 2.0 - iResolution.xy) / iResolution.y * vec2(3.0, 1.0);\n    if(iMouse.xy == vec2(0, 0)) mo = vec2(0.75);\n    vec3 ro = vec3(sin(mo.x), mo.y, cos(mo.x)) * 6.0;\n    mat3 ca = getCamera(ro, vec3(0, 1.1, 0));\n    \n    vec3 co = vec3(0);\n    for(int i = 0; i < 5; ++i) {\n        float x = fragCoord.x + rand(vec2(12.9898, 78.233), iTime + float(i)) - 0.5;\n        float y = fragCoord.y + rand(vec2(63.7264, 10.873), iTime + float(i)) - 0.5;\n        vec2 uv = (vec2(x, y) * 2.0 - iResolution.xy) / iResolution.y;\n        vec3 rd = ca * normalize(vec3(uv, -2));\n        co += radiance(Ray(ro, rd));\n    }\n        \n\tfragColor = vec4(mix(texture(iChannel0, st).rgb, co / 5.0, weight), 1.0);\n}","name":"Buf A","description":"","type":"buffer"}]}