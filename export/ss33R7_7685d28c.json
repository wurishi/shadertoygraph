{"ver":"0.1","info":{"id":"ss33R7","date":"1629459403","viewed":659,"name":"SIMPLE GLITTER","username":"alro","description":"Use mouse to move camera","likes":20,"published":1,"flags":32,"usePreview":0,"tags":["glow","flare","shine","glitter","glint","velvet"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sfGzn","filepath":"/media/a/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png","previewfilepath":"/media/ap/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Simple (if a bit costly) glitter effect\n// Distribute points on layers\n// Assign each point a random orientation and colour\n// Iterate over layers near surface intersection point to accumulate colour \n\nconst float glintCount = 20000.0;\n\n//https://www.shadertoy.com/view/4d3SR4\nvec3 getPastelGradient(float h) {\n    h = fract(h + 0.92620819117478) * 6.2831853071796;\n    vec2 cocg = 0.25 * vec2(cos(h), sin(h));\n    vec2 br = vec2(-cocg.x, cocg.x) - cocg.y;\n    vec3 c = 0.729 + vec3(br.y, cocg.y, br.x);\n    return c * c;\n}\n\n//-------------------------- Camera ---------------------------\n\nvec3 rayDirection(float fieldOfView, vec2 fragCoord, vec2 resolution) {\n    vec2 xy = fragCoord - resolution.xy / 2.0;\n    float z = (0.5 * resolution.y) / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n//https://www.geertarien.com/blog/2017/07/30/breakdown-of-the-lookAt-function-in-OpenGL/\nmat3 lookAt(vec3 camera, vec3 targetDir, vec3 up){\n    vec3 zaxis = normalize(targetDir);    \n    vec3 xaxis = normalize(cross(zaxis, up));\n    vec3 yaxis = cross(xaxis, zaxis);\n\n    return mat3(xaxis, yaxis, -zaxis);\n}\n\n//---------------------- Intersection -----------------------\n\n//Return the near and far intersections of an infinite ray and a sphere. \n//Assumes sphere at origin. No intersection if result.x > result.y\nvec2 sphereIntersect(vec3 start, vec3 dir, float radius){\n    float a = dot(dir, dir);\n    float b = 2.0 * dot(dir, start);\n    float c = dot(start, start) - (radius * radius);\n    float d = (b * b) - 4.0 * a * c;\n    if (d < 0.0){\n    \treturn vec2(1e5, -1e5);\n    }\n    return vec2((-b - sqrt(d))/(2.0 * a), (-b + sqrt(d))/(2.0 * a));\n}\n\nfloat hash(vec2 par){\n   return fract(sin(dot(par,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvec2 random2(vec2 par){\n\tfloat rand = hash(par);\n\treturn vec2(rand, hash(par + rand));\n}\n\n//https://en.wikipedia.org/wiki/Spherical_coordinate_system\nvec3 sphericalToCartesian(float theta, float phi){\n    float sinTheta = sin(theta);\n\treturn normalize(vec3(sinTheta * cos(phi), sinTheta * sin(phi), cos(theta)));\n}\n\n//Get a random direction on a unit sphere\n//http://corysimon.github.io/articles/uniformdistn-on-sphere/\nvec3 getRandomDirection(vec2 seed){\n    vec2 param = random2(seed);\n    float phi = TWO_PI * param.x;\n    float theta = acos(1.0 - 2.0 * param.y);\n\treturn sphericalToCartesian(theta, phi);\n}\n\n//--------------------------- Glints ----------------------------\n\n//https://www.shadertoy.com/view/4djSRW\nfloat random(float p){\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);;\n}\n\nbool isActiveElevation(float theta, float level){\n    return sin(theta) > hash(vec2(theta, level));\n}\n\nfloat getDistToGlint(vec3 p, float theta, float phi){\n    vec3 glintPos = sphericalToCartesian(theta, phi);\n    return clamp(dot(glintPos, p), 0.0, 1.0);\n}\n\nfloat getGlow(float dist, float radius, float intensity){\n\treturn pow(radius / max(dist, 1e-6), intensity);\t\n}\n\n\n// Get glint colour from view direction.\nvec3 getGlints(vec3 normal, vec3 rayDir){\n    \n    // acos returns a value in the range [0, PI].\n    // The theta of the original view ray.\n    float theta = acos(normal.z);\n\n    // Extent of each level.\n    float width = PI / glintCount;\n    \n    // The level on which the view ray falls.\n    float level = floor((theta/PI) * glintCount);\n    \n    // The theta of the level considered.\n    float theta_;\n\n    // Random angle of the glint on the level.\n    float phi_;\n    \n    vec3 glints = vec3(0);\n    \n    // Variable to keep track of neighbouring levels.\n    float level_;\n    \n    // For a set number of layers above and below the view ray intersection point,\n    // accumulate the glint colour.\n    for(float l = -64.0; l <= 64.0; l++){\n        \n    \tlevel_ = min(glintCount - 1.0, max(0.0, level + l));\n        theta_ = (level_ + 0.5) * width;\n\n        // Uniformly picked latitudes lead to glints concentrating at the poles.\n        // Make the likelyhood of rendering glints a function of sin(theta_)\n        if(!isActiveElevation(theta_, 0.0)){\n            continue;\n        }\n        \n        phi_ = TWO_PI * random(level_);\n        \n        vec3 detailDir = getRandomDirection(vec2(theta_, phi_));\n        \n        // Random directions are in a sphere\n        // If one falls on the other side of the surface normal plane, flip it\n        if(dot(detailDir, sphericalToCartesian(theta_, phi_)) < 0.0){\n            detailDir = -detailDir;\n        } \n        \n        // Add some colour to the mix\n        vec3 col = hash(vec2(theta_, level_)) > 0.85 \n                ? getPastelGradient(100.0 * level_ / glintCount) : vec3(1);\n        \n        // Alignment of the view ray and the glitter particle position\n        float dist = getDistToGlint(normal, theta_, phi_);\n        \n        // Alignment of view ray and the glitter particle orientation\n        float mu = clamp(dot(detailDir, -rayDir), 0.0, 1.0);\n        \n        // Raising mu to a power controls the range of viewing angles \n        // where the glint is visible\n        // Higher values lead to more abrupt flashes during movement\n        glints += col*(3.0*pow(mu, 256.0) + pow(mu, 32.0)) * getGlow(1.0-dist, 1.5e-6, 1.45);\n    }\n    \n    return glints;\n}\n\n\n//----------------------- Tonemapping and render ------------------------\n\n//https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/\nvec3 ACESFilm(vec3 x){\n    return clamp((x * (2.51 * x + 0.03)) / (x * (2.43 * x + 0.59) + 0.14), 0.0, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n    //Get the default direction of the ray (along the negative Z direction)\n    vec3 rayDir = rayDirection(60.0, fragCoord, iResolution.xy);\n   \n    //----------------- Define a camera -----------------\n    \n    vec3 cameraPos = texelFetch(iChannel0, ivec2(0.5, 1.5), 0).xyz;\n    vec3 targetDir = -normalize(cameraPos);\n    \n    vec3 up = vec3(0.0, 1.0, 0.0);\n    vec3 right = vec3(1.0, 0.0, 0.0);\n\n    //Get the view matrix from the camera orientation\n    mat3 viewMatrix = lookAt(cameraPos, targetDir, up);\n\n    //---------------------------------------------------\n    \n    //Transform the ray to point in the correct direction\n    rayDir = normalize(viewMatrix * rayDir);\n\n    vec2 intersections = sphereIntersect(cameraPos, rayDir, 1.0);\n\n    bool hitsSphere = intersections.x < intersections.y && intersections.x > 0.0;\n    \n    vec3 col = vec3(0);\n    \n    if(hitsSphere){\n        vec3 pos = cameraPos + rayDir * intersections.x;\n        vec3 normal = normalize(pos);\n        // Add red velvet colour with fake sheen on the edge\n        float d = 1.0 - dot(normal, -rayDir);\n        col = vec3(0.05 + pow(0.25 * d, 2.0), 0, 0);\n        \n        col += 0.5 * vec3(getGlints(normal, rayDir));\n        \n        // Tonemapping\n        col = ACESFilm(col);\n        \n        // Gamma\n        col = pow(col, vec3(0.4545));\n    }else{\n        col = textureLod(iChannel1, rayDir, 8.0).rgb;\n    }\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Track mouse movement and resolution change between frames and set camera position.\n\n#define CAMERA_DIST 2.2\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    // Work with just the first four pixels.\n    if((fragCoord.x == 0.5) && (fragCoord.y < 4.0)){\n        \n        vec4 oldData = texelFetch(iChannel0, ivec2(0.5), 0).xyzw;\n\n        vec2 oldPolarAngles = oldData.xy;\n        vec2 oldMouse = oldData.zw;\n\n        vec2 polarAngles = vec2(0);\n        vec2 mouse = iMouse.xy / iResolution.xy; \n        \n        // Stop camera going directly above and below\n        float angleEps = 0.01;\n\n        float mouseDownLastFrame = texelFetch(iChannel0, ivec2(0.5, 3.5), 0).x;\n        \n        // If mouse button is down and was down last frame.\n        if(iMouse.z > 0.0 && mouseDownLastFrame > 0.0){\n            \n            // Difference between mouse position last frame and now.\n            vec2 mouseMove = mouse - oldMouse;\n            polarAngles = oldPolarAngles + vec2(5.0, 3.0) * mouseMove;\n            \n        }else{\n            polarAngles = oldPolarAngles;\n        }\n        \n        polarAngles.x = mod(polarAngles.x, 2.0 * PI - angleEps);\n        polarAngles.y = min(PI - angleEps, max(angleEps, polarAngles.y));\n\n        // Store mouse data in the first pixel of Buffer A.\n        if(fragCoord == vec2(0.5, 0.5)){\n            // Set value at first frames.\n            if(iFrame < 10){\n                polarAngles = vec2(2.9, 1.7);\n                mouse = vec2(0);\n            }\n            \n            fragColor = vec4(polarAngles, mouse);\n        }\n\n        // Store camera position in the second pixel of Buffer A.\n        if(fragCoord == vec2(0.5, 1.5)){\n            // Cartesian direction from polar coordinates.\n            vec3 cameraPos = normalize(vec3(-cos(polarAngles.x) * sin(polarAngles.y), \n                                             cos(polarAngles.y), \n                                            -sin(polarAngles.x) * sin(polarAngles.y)));\n\n            fragColor = vec4(CAMERA_DIST * cameraPos, 1.0);\n        }\n        \n        // Store resolution change data in the third pixel of Buffer A.\n        if(fragCoord == vec2(0.5, 2.5)){\n            float resolutionChangeFlag = 0.0;\n            // The resolution last frame.\n            vec2 oldResolution = texelFetch(iChannel0, ivec2(0.5, 2.5), 0).yz;\n            \n            if(iResolution.xy != oldResolution){\n            \tresolutionChangeFlag = 1.0;\n            }\n            \n        \tfragColor = vec4(resolutionChangeFlag, iResolution.xy, 1.0);\n        }\n           \n        // Store whether the mouse button is down in the fourth pixel of Buffer A\n        if(fragCoord == vec2(0.5, 3.5)){\n            if(iMouse.z > 0.0){\n            \tfragColor = vec4(vec3(1.0), 1.0);\n            }else{\n            \tfragColor = vec4(vec3(0.0), 1.0);\n            }\n        }\n        \n    }\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define PI 3.14159\n#define TWO_PI (2.0 * PI)","name":"Common","description":"","type":"common"}]}