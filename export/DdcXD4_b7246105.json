{"ver":"0.1","info":{"id":"DdcXD4","date":"1679766190","viewed":46,"name":"gpt4 cat3: rotating camera","username":"memo","description":"code created by chatgpt using gpt4\nsee code comments","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["chatgpt","gpt4"],"hasliked":0,"parentid":"cs3XD4","parentname":"gpt4 cat2: 3D cat with SDFs"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\ncode created by chatgpt using gpt4\ncontinuing from before (See fork or https://www.shadertoy.com/user/memo )\nprompt:\nmake the camera slowly rotate around the cat\n\ngpt4 outputted only relevant code changes:\n- rotationMatrix function\n- new mainImage\n\nI had to make two fixes due to incorrect coordinate system:\n- flip the rayDir (camera was looking the other way\n- swap the cross-product order for cameraUp (camera was upside down)\n*/\n\n\nfloat sphereSDF(vec3 p, vec3 center, float radius) {\n    return length(p - center) - radius;\n}\n\nfloat boxSDF(vec3 p, vec3 center, vec3 size) {\n    vec3 d = abs(p - center) - size;\n    return length(max(d, 0.0)) + min(max(d.x, max(d.y, d.z)), 0.0);\n}\n\nfloat unionSDF(float d1, float d2) {\n    return min(d1, d2);\n}\n\n\nfloat sceneSDF(vec3 p) {\n    // Cat body\n    float body = sphereSDF(p, vec3(0.0, 0.0, 0.0), 1.0);\n\n    // Cat head\n    float head = sphereSDF(p, vec3(0.0, 1.5, 0.0), 0.7);\n\n    // Cat ears\n    float leftEar = boxSDF(p, vec3(-0.4, 2.2, 0.0), vec3(0.2, 0.3, 0.1)); // MEMO changed vec2 to vec3\n    float rightEar = boxSDF(p, vec3(0.4, 2.2, 0.0), vec3(0.2, 0.3, 0.1)); // MEMO changed vec2 to vec3\n\n    return unionSDF(unionSDF(body, head), unionSDF(leftEar, rightEar));\n}\n\nvec3 getNormal(vec3 p) {\n    float eps = 0.001;\n    vec2 h = vec2(eps, 0.0);\n    return normalize(vec3(\n        sceneSDF(p + h.xyy) - sceneSDF(p - h.xyy),\n        sceneSDF(p + h.yxy) - sceneSDF(p - h.yxy),\n        sceneSDF(p + h.yyx) - sceneSDF(p - h.yyx)\n    ));\n}\n\n\nmat3 rotationMatrix(vec3 axis, float angle) {\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat3(\n        oc * axis.x * axis.x + c,\n        oc * axis.x * axis.y - axis.z * s,\n        oc * axis.z * axis.x + axis.y * s,\n        oc * axis.x * axis.y + axis.z * s,\n        oc * axis.y * axis.y + c,\n        oc * axis.y * axis.z - axis.x * s,\n        oc * axis.z * axis.x - axis.y * s,\n        oc * axis.y * axis.z + axis.x * s,\n        oc * axis.z * axis.z + c\n    );\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord.xy / iResolution.xy * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n\n    float t = iTime * 0.1;\n    vec3 cameraPos = vec3(5.0 * cos(t), 2.0, 5.0 * sin(t));\n    vec3 target = vec3(0.0, 1.0, 0.0);\n    vec3 up = vec3(0.0, 1.0, 0.0);\n\n    vec3 cameraForward = normalize(target - cameraPos);\n    vec3 cameraRight = normalize(cross(up, cameraForward));\n    vec3 cameraUp = cross(cameraRight, cameraForward); // MEMO swapped order of cross product\n    mat3 viewMatrix = mat3(cameraRight, cameraUp, -cameraForward);\n\n    vec3 rayDir = -normalize(viewMatrix * vec3(uv, 1.0)); // MEMO made this -ve\n\n    vec3 p = cameraPos;\n    for (int i = 0; i < 64; ++i) {\n        float t = sceneSDF(p);\n        if (t < 0.001) {\n            break;\n        }\n        p += rayDir * t;\n    }\n\n    vec3 normal = getNormal(p);\n    vec3 lightDir = normalize(vec3(-0.5, 1.0, -1.0));\n    float diffuse = max(dot(normal, lightDir), 0.0);\n    vec3 color = vec3(0.8, 0.6, 0.4) * diffuse;\n\n    fragColor = vec4(color, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}