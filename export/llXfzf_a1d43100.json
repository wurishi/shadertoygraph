{"ver":"0.1","info":{"id":"llXfzf","date":"1516035580","viewed":1966,"name":"Checkerboard reconstruction","username":"nimitz","description":"Left: 35% more pixels rendered (in a real scenario), right checkerboard reconstruction (half of the pixels rendered compared to full resolution)","likes":31,"published":1,"flags":32,"usePreview":0,"tags":["a"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//2x2 Checkerboard bicubic reconstruction with gradient evaluation\n//by nimitz 2018 (twitter: @stormoid)\n//License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n/*\n\tIn this example the left side is rendered at a lower resolution and then upscaled using standard\n\tfiltering and the right side is rendered at full resolution, but with only half the pixels in a\n\tcheckerboard pattern. The result is visually very similar and the base version would be rendering\n\t35% more total fragments than the checkerboard version for a given effect in a practical scenario.\n\n\tInstead of using the typical 4x4 checkerboards grid a 2x2 grid can be used by splitting the render buffer\n\tin half and offsetting the rays accordingly, this then allows for this reconstruction algorithm to be used\n\twhile minimizing the potential costs associated with fragment discard.\n\n\tThe basic idea behind this reconstruction filter is to approximate the missing pixel color by running\n\ta somewhat standard bicubic filtering algorithm (with slightly tweaked parameters) allowing for a wide\n\tenough computation to smooth out the missing information. The algorithm is split into two main branches,\n\tdepending on the on/off state of the evaluated fragment and then fetching not only the fragments required\n\tfor the cubic evaluation but also the next neighbors for the first reconstruction step to feed the cubic filter.\n\tThe first idea was to simply average the neighbors to get the missing information to evaluate the cubic spline,\n\tbut this turned out to be prone to artifacts when the input contained linear features (especially at high contrast)\n\tand was inducing unwanted blur to the image. The solution was to introduce a simple luminosity gradient evaluation\n\tstep which is then used to determine the texels to be used for the reconstructed spline input. The sharpness\n\tof that transition can be tweaked using a smoothstep function to accomodate for different inputs.\n\n\tThis technique can be applied for any fragment side effect which takes enough rendering time\n\t(say over 1.5ms) to offset the cost of the reconstruction algorithm and the additional buffer required.\n\t\t\n\tI am using a standard bilinear filter for the reference (left) side, which could be argued\n\tto be contributing to the lower quality of the left side, but in the vast majority of applications\n\tbilinear filtering is still used so I feel this is a fair comparison. \n\n\tThe left side is also scaled up for the demo, which I have to do due to shadertoy fixed buffer size\n\tthis would likely result in a small improvement in visual fidelity for the left side in real applications\n*/\n\n//You can test at the same fragment count (same rendering speed) by adding this define in both in this tab and in Buf B\n//#define SAME_FRAG_COUNT\n\nvec4 texfetch(sampler2D tx, vec4 p) {\n    vec4 rez = texture(tx, p.xy, p.w);\n    return rez;\n}\n  \n//Mitchell Netravali Reconstruction Filter\n//From gpu gems (http://developer.download.nvidia.com/books/HTML/gpugems/gpugems_ch24.html)\n//(slightly optimized to combine powers)\nfloat recons(float x)\n{\n    #if 0\n\tconst float B = 1./3.;\n    const float C = 1./3.;\n    #else\n    const float B = 2./12.;\n    const float C = 5./12.;\n    #endif\n    \n  \tfloat ax = abs(x);\n    float ax2 = ax*ax;\n    \n    if (ax < 1.) \n    {\n        return ((12. - 9.*B - 6. * C)*ax*ax2 +\n                (-18. + 12.*B + 6. * C)*ax2 + (6. - 2.*B))/6.;\n    } \n    else if ((ax >= 1.) && (ax < 2.)) \n    {\n        return ((-B - 6. * C)*ax*ax2 + (6.*B + 30.*C) * ax2 +\n               (-12. * B - 48. * C)*ax + (8.*B + 24.*C)) / 6.;\n    }\n    else\n    {\n        return 0.;\n    }\n}\n\nvec4 eval(vec4 v0, vec4 v1, vec4 v2, vec4 v3, float x) {\n    \n    return v0*recons(x + 1.0) + v1*recons(x) + v2*recons(1.0 - x) + v3*recons(2.0 - x);\n}\n\n//--------------------------------------------------------------------------------------------------------------------------------------\n//--------------------------------------------------------------------------------------------------------------------------------------\n\nvec4 lerp(vec4 a, vec4 b, float x) { return mix(a,b,x); }\nvec4 reconstruct(sampler2D smp, vec2 t)\n{\n    vec2 resl = iChannelResolution[0].xy;\n    vec2 p = resl*t - 0.5;\n    vec2 fp = fract(p);\n    vec2 ip = floor(p);\n    float isOff = mod(ip.x + ip.y + 1., 2.);\n\n    const float smm = 0.48;\n    const float smx = 0.52;\n    \n    if (isOff >= 1.){\n        \n        vec4 s99 = texfetch(smp, vec4((ip+vec2(-1,-1) + 0.5)/resl, 0,-100.0));\n        vec4 s19 = texfetch(smp, vec4((ip+vec2(1,-1) + 0.5)/resl, 0,-100.0));\n        vec4 s00 = texfetch(smp, vec4((ip+vec2(0,0) + 0.5)/resl, 0,-100.0));\n        vec4 s20 = texfetch(smp, vec4((ip+vec2(2,0) + 0.5)/resl, 0,-100.0));\n        vec4 s91 = texfetch(smp, vec4((ip+vec2(-1, 1) + 0.5)/resl, 0,-100.0));\n        vec4 s11 = texfetch(smp, vec4((ip+vec2(1, 1) + 0.5)/resl, 0,-100.0));\n        vec4 s02 = texfetch(smp, vec4((ip+vec2(0,2) + 0.5)/resl, 0,-100.0));\n        vec4 s22 = texfetch(smp, vec4((ip+vec2(2,2) + 0.5)/resl, 0,-100.0));\n        \n        vec4 s08 = texfetch(smp, vec4((ip+vec2(0,-2) + 0.5)/resl, 0,-100.0));\n        vec4 s28 = texfetch(smp, vec4((ip+vec2(3,-2) + 0.5)/resl, 0,-100.0));\n        vec4 s39 = texfetch(smp, vec4((ip+vec2(3,-1) + 0.5)/resl, 0,-100.0));\n        vec4 s80 = texfetch(smp, vec4((ip+vec2(-2,0) + 0.5)/resl, 0,-100.0));\n        vec4 s31 = texfetch(smp, vec4((ip+vec2(3, 1) + 0.5)/resl, 0,-100.0));\n        vec4 s82 = texfetch(smp, vec4((ip+vec2(-2, 2) + 0.5)/resl, 0,-100.0));\n        vec4 s93 = texfetch(smp, vec4((ip+vec2(-1,3) + 0.5)/resl, 0,-100.0));\n        vec4 s13 = texfetch(smp, vec4((ip+vec2(1,3) + 0.5)/resl, 0,-100.0));\n        \n        float d99 = dot(vec3(0.3333), s99.rgb);\n        float d19 = dot(vec3(0.3333), s19.rgb);\n        float d00 = dot(vec3(0.3333), s00.rgb);\n        float d20 = dot(vec3(0.3333), s20.rgb);\n        float d91 = dot(vec3(0.3333), s91.rgb);\n        float d02 = dot(vec3(0.3333), s02.rgb);\n        float d11 = dot(vec3(0.3333), s11.rgb);\n        float d22 = dot(vec3(0.3333), s22.rgb);\n        \n        float is09 = (abs(d99 - d19) - abs(dot(vec3(0.3333), s08.rgb) - d00))*0.5+0.5;\n        float is29 = (abs(d19 - dot(vec3(0.3333), s39.rgb)) - abs(dot(vec3(0.3333), s28.rgb) - d20))*0.5+0.5;\n        float is90 = (abs(dot(vec3(0.3333), s80.rgb) - d00) - abs(d99 - d91))*0.5+0.5;\n        float is10 = (abs(d00 - d20) - abs(d19 - d11))*0.5+0.5;\n        float is01 = (abs(d91 - d11) - abs(d00 - d02))*0.5+0.5;\n        float is21 = (abs(d11 - dot(vec3(0.3333), s31.rgb)) - abs(d20 - d22))*0.5+0.5;\n        float is92 = (abs(dot(vec3(0.3333), s82.rgb) - d02) - abs(d91 - dot(vec3(0.3333), s93.rgb)))*0.5+0.5;\n        float is12 = (abs(d02 - d22) - abs(d11 - dot(vec3(0.3333), s13.rgb)))*0.5+0.5;\n        \n        //                    X    ,     Y\n        vec4 s09 = lerp(s99 + s19, s00 + s08, smoothstep(smm, smx, is09))/2.;\n        vec4 s29 = lerp(s19 + s39, s20 + s28, smoothstep(smm, smx, is29))/2.;\n        vec4 s90 = lerp(s80 + s00, s91 + s99, smoothstep(smm, smx, is90))/2.;\n        vec4 s10 = lerp(s00 + s20, s11 + s19, smoothstep(smm, smx, is10))/2.;\n        vec4 s01 = lerp(s91 + s11, s02 + s00, smoothstep(smm, smx, is01))/2.;\n        vec4 s21 = lerp(s11 + s31, s22 + s20, smoothstep(smm, smx, is21))/2.;\n        vec4 s92 = lerp(s82 + s02, s93 + s91, smoothstep(smm, smx, is92))/2.;\n        vec4 s12 = lerp(s02 + s22, s13 + s11, smoothstep(smm, smx, is12))/2.;\n        return eval(eval(s99, s09, s19, s29, fp.x), eval(s90, s00, s10, s20, fp.x),\n                    eval(s91, s01, s11, s21, fp.x), eval(s92, s02, s12, s22, fp.x), fp.y);\n    }\n    else\n    {\n        vec4 s09 = texfetch(smp, vec4((ip+vec2(0,-1) + 0.5)/resl, 0,-100.0));\n        vec4 s29 = texfetch(smp, vec4((ip+vec2(2,-1) + 0.5)/resl, 0,-100.0));\n        vec4 s90 = texfetch(smp, vec4((ip+vec2(-1,0) + 0.5)/resl, 0,-100.0));\n        vec4 s10 = texfetch(smp, vec4((ip+vec2(1,0) + 0.5)/resl, 0,-100.0));\n        vec4 s01 = texfetch(smp, vec4((ip+vec2(0, 1) + 0.5)/resl, 0,-100.0));\n        vec4 s21 = texfetch(smp, vec4((ip+vec2(2, 1) + 0.5)/resl, 0,-100.0));\n        vec4 s92 = texfetch(smp, vec4((ip+vec2(-1,2) + 0.5)/resl, 0,-100.0));\n        vec4 s12 = texfetch(smp, vec4((ip+vec2(1,2) + 0.5)/resl, 0,-100.0));\n        \n        vec4 s89 = texfetch(smp, vec4((ip+vec2(-2,-1) + 0.5)/resl, 0,-100.0));\n        vec4 s98 = texfetch(smp, vec4((ip+vec2(-1,-2) + 0.5)/resl, 0,-100.0));\n        vec4 s18 = texfetch(smp, vec4((ip+vec2(1,-2) + 0.5)/resl, 0,-100.0));\n        vec4 s30 = texfetch(smp, vec4((ip+vec2(3,0) + 0.5)/resl, 0,-100.0));\n        vec4 s81 = texfetch(smp, vec4((ip+vec2(-2, 1) + 0.5)/resl, 0,-100.0));\n        vec4 s03 = texfetch(smp, vec4((ip+vec2(0, 3) + 0.5)/resl, 0,-100.0));\n        vec4 s23 = texfetch(smp, vec4((ip+vec2(2,3) + 0.5)/resl, 0,-100.0));\n        vec4 s32 = texfetch(smp, vec4((ip+vec2(3,2) + 0.5)/resl, 0,-100.0));\n        \n        float d09 = dot(vec3(0.3333), s09.rgb);\n        float d90 = dot(vec3(0.3333), s90.rgb);\n        float d29 = dot(vec3(0.3333), s29.rgb);\n        float d10 = dot(vec3(0.3333), s10.rgb);\n        float d01 = dot(vec3(0.3333), s01.rgb);\n        float d21 = dot(vec3(0.3333), s21.rgb);\n        float d92 = dot(vec3(0.3333), s92.rgb);\n        float d12 = dot(vec3(0.3333), s12.rgb);\n        \n        float is99 = (abs(dot(vec3(0.3333), s89.rgb) - d09) - abs(dot(vec3(0.3333), s98.rgb) - d90))*0.5+0.5; \n        float is19 = (abs(d09 - d29) - abs(dot(vec3(0.3333), s18.rgb) - d10))*0.5+0.5; \n        float is00 = (abs(d90 - d10) - abs(d09 - d01))*0.5+0.5; \n        float is20 = (abs(d10 - dot(vec3(0.3333), s30.rgb)) - abs(d29 - d21))*0.5+0.5; \n        float is91 = (abs(dot(vec3(0.3333), s81.rgb) - d01) - abs(d90 - d92))*0.5+0.5; \n        float is11 = (abs(d01 - d21) - abs(d10 - d12))*0.5+0.5; \n        float is02 = (abs(d92 - d12) - abs(d01 - dot(vec3(0.3333), s03.rgb)))*0.5+0.5; \n        float is22 = (abs(d12 - dot(vec3(0.3333), s32.rgb)) - abs(d21 - dot(vec3(0.3333), s23.rgb)))*0.5+0.5; \n        \n        //                    X    ,     Y\n        vec4 s99 = lerp(s89 + s09, s90 + s98, smoothstep(smm, smx, is99))/2.;\n        vec4 s19 = lerp(s09 + s29, s10 + s18, smoothstep(smm, smx, is19))/2.;\n        vec4 s00 = lerp(s90 + s10, s01 + s09, smoothstep(smm, smx, is00))/2.;\n        vec4 s20 = lerp(s10 + s30, s21 + s29, smoothstep(smm, smx, is20))/2.;\n        vec4 s91 = lerp(s81 + s01, s92 + s90, smoothstep(smm, smx, is91))/2.;\n        vec4 s11 = lerp(s01 + s21, s12 + s10, smoothstep(smm, smx, is11))/2.;\n        vec4 s02 = lerp(s92 + s12, s03 + s01, smoothstep(smm, smx, is02))/2.;\n        vec4 s22 = lerp(s12 + s32, s23 + s21, smoothstep(smm, smx, is22))/2.;\n        \n        return eval(eval(s99, s09, s19, s29, fp.x), eval(s90, s00, s10, s20, fp.x),\n                    eval(s91, s01, s11, s21, fp.x), eval(s92, s02, s12, s22, fp.x), fp.y);\n    }\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 q = fragCoord.xy/iResolution.xy;\n    vec3 col = vec3(0);\n    \n    if (q.x > 0.5)\n    {\n    \tcol = reconstruct(iChannel0, q - vec2(0.5,0.)).xyz;\n        vec3 colb= texfetch(iChannel0, vec4(q - vec2(0.5,0.),0.,0.)).rgb;\n        col = mix(col, colb, smoothstep(0.85,0.95, cos(iTime*0.6+1.)));\n    }\n    else\n    {\n        #ifdef SAME_FRAG_COUNT\n        col = texture(iChannel1, q*.7071, -99.).rgb;\n        #else\n        col = texture(iChannel1, q*.82, -99.).rgb;\n        #endif\n    }\n    \n    col *= smoothstep( 0.0, 0.004, abs(q.x-0.5));\n\tfragColor = vec4( col, 1.0 );\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//2x2 Checkerboard bicubic reconstruction with gradient evaluation\n//by nimitz 2018 (twitter: @stormoid)\n//License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n//Fully procedural texture, for testing\n/*\n\tUsually, the effect would be in a halved buffer with offsets for every other fragment,\n\tbut as the shadertoy tools currently don't allow to set arbitrary buffer sizes, \n\tI felt this was\tnot relevant to implement in this demo.\n*/\n\n#define time iTime\n\nmat2 m2 = mat2( 0.80,  0.60, -0.60,  0.80 );\n\nvec2 hash( vec2 p )\n{\n\tp = vec2( dot(p,vec2(127.1,311.7)),\n\t\t\t  dot(p,vec2(269.5,183.3)) );\n\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\n//Based on the 2D simplex noise from iq: https://www.shadertoy.com/view/Msf3WH\nvec3 simplex2D( in vec2 p )\n{\n    const float K1 = 0.366025404; // (sqrt(3)-1)/2;\n    const float K2 = 0.211324865; // (3-sqrt(3))/6;\n\n\tvec2 i = floor(p + (p.x + p.y)*K1);\n\t\n    vec2 a = p - i + (i.x + i.y)*K2;\n    vec2 o = mix(vec2(1.0, 0.0), vec2(0.0,1.0), step(a.x,a.y));\n    vec2 b = a - o + K2;\n\tvec2 c = a - 1.0 + 2.0*K2;\n    \n    vec3 h = max(0.5 - vec3(dot(a,a), dot(b,b), dot(c,c)), 0.0 );\n\n    vec3 h2 = h*h;\n    vec3 h4 = h2*h2;\n    \n    vec2 r0 = hash(i + 0.0);\n    vec2 r1 = hash(i + o);\n    vec2 r2 = hash(i + 1.0);\n    \n    float va = dot(a, r0);\n    float vb = dot(b, r1);\n    float vc = dot(c, r2);\n    \n    vec3 n = h4*vec3(va, vb, vc);\n    \n    vec2 gr = a*h2.x*h.x*va;\n    gr += b*h2.y*h.y*vb;\n    gr += c*h2.z*h.z*vc;\n    gr *= -8.0;\n    gr += h4.x*r0 + h4.y*r1 + h4.z*r2;\n    gr *= 35.0;\n\n    return vec3(dot(n, vec3(70.0)), gr);\n\t\n}\n\nfloat estep( float x, float k, float n )\n{\n    return exp( -k*pow(abs(x),n) );\n}\n\nfloat map( in vec2 p)\n{\n    float a = 0.0;\n    float z = 1.;\n\tvec2  d = vec2(0.0);\n    for( int i=0; i<10; i++ )\n    {\n        vec3 n = simplex2D(p*0.5);\n        d += pow(abs(n.yz),vec2(1.))*10.*sign(n.yz);\n        d *= .7;\n        \n        a += z * (sin(n.x/(dot(d,d)+5.)*8.)*1.+0.6);     \n\t\tz *= -.75;\n        p = m2*p*1.36;\n        \n    }   \n    a = 1.-estep(a,2.5,1.)*1.;\n    \n    return a;\n}\n\nfloat map2( in vec2 p)\n{\n    float a = 0.0;\n    float z = 1.;\n\tvec2  d = vec2(0.0);\n    for( int i=0; i<9; i++ )\n    {\n        vec3 n = simplex2D(p*0.75);\n        d += abs(n.yz)*7.*sign(n.yz);\n        d *= .65;\n        a += z * (sin(n.x/(dot(d,d)+2.)*7.)*.4+.8);\n\t\tz *= -.85;\n        p = m2*p*1.4;\n        \n    }\n    \n    return a;\n}\n\nvec3 normal(in vec2 p)\n{\n    const vec2 e = vec2(0.0065,0.);\n    return normalize( vec3( map(p+e.xy) - map(p-e.xy), 0.05, map( p+e.yx)-map(p-e.yx) ) );\n}\n\nvec3 tex(in vec2 p)\n{\n    p *= 2.5;\n    vec3 col = vec3(0);\n    float rz = map(p);\n    rz = 3.-rz;\n    vec2 dd = vec2(0.7,-.75);\n    float dif = clamp(dot( normal(p),(vec3(dd.x,0.1,dd.y)) )*0.5+0.5,0.0,1.0);\n    \n    rz= pow(abs(rz),.72);\n    col = 1.45-(sin(vec3(.24*rz*rz+0.4 ,0.75*rz, 1.55)+rz*1.1+3.8))*0.9;\n    col *= dif*map2(p*1.)*1.8;\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = fragCoord.xy / iResolution.xy-0.5;\n\tp.x *= iResolution.x/iResolution.y;\n\tp *= 1.6;\n\t\n    \n    float isOff = mod(fragCoord.x + fragCoord.y, 2.);\n    \n    vec3 col = vec3(0);\n    \n    if (isOff > 0.5)\n\t\tcol = tex(p+time*0.1 + 10.);\n    \n\tfragColor = vec4(col,1.0);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[{"id":"XsXGR8","channel":0}],"code":"//2x2 Checkerboard bicubic reconstruction with gradient evaluation\n//by nimitz 2018 (twitter: @stormoid)\n//License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n//Fully procedural texture, for testing\n\n\n//#define SAME_FRAG_COUNT\n\n#define time iTime\n\nmat2 m2 = mat2( 0.80,  0.60, -0.60,  0.80 );\n\nvec2 hash( vec2 p )\n{\n\tp = vec2( dot(p,vec2(127.1,311.7)),\n\t\t\t  dot(p,vec2(269.5,183.3)) );\n\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\n//Based on the 2D simplex noise from iq: https://www.shadertoy.com/view/Msf3WH\nvec3 simplex2D( in vec2 p )\n{\n    const float K1 = 0.366025404; // (sqrt(3)-1)/2;\n    const float K2 = 0.211324865; // (3-sqrt(3))/6;\n\n\tvec2 i = floor(p + (p.x + p.y)*K1);\n\t\n    vec2 a = p - i + (i.x + i.y)*K2;\n    vec2 o = mix(vec2(1.0, 0.0), vec2(0.0,1.0), step(a.x,a.y));\n    vec2 b = a - o + K2;\n\tvec2 c = a - 1.0 + 2.0*K2;\n    \n    vec3 h = max(0.5 - vec3(dot(a,a), dot(b,b), dot(c,c)), 0.0 );\n\n    vec3 h2 = h*h;\n    vec3 h4 = h2*h2;\n    \n    vec2 r0 = hash(i + 0.0);\n    vec2 r1 = hash(i + o);\n    vec2 r2 = hash(i + 1.0);\n    \n    float va = dot(a, r0);\n    float vb = dot(b, r1);\n    float vc = dot(c, r2);\n    \n    vec3 n = h4*vec3(va, vb, vc);\n    \n    vec2 gr = a*h2.x*h.x*va;\n    gr += b*h2.y*h.y*vb;\n    gr += c*h2.z*h.z*vc;\n    gr *= -8.0;\n    gr += h4.x*r0 + h4.y*r1 + h4.z*r2;\n    gr *= 35.0;\n\n    return vec3(dot(n, vec3(70.0)), gr);\n\t\n}\n\nfloat estep( float x, float k, float n )\n{\n    return exp( -k*pow(abs(x),n) );\n}\n\nfloat map( in vec2 p)\n{\n    float a = 0.0;\n    float z = 1.;\n\tvec2  d = vec2(0.0);\n    for( int i=0; i<10; i++ )\n    {\n        vec3 n = simplex2D(p*0.5);\n        d += pow(abs(n.yz),vec2(1.))*10.*sign(n.yz);\n        d *= .7;\n        \n        a += z * (sin(n.x/(dot(d,d)+5.)*8.)*1.+0.6);     \n\t\tz *= -.75;\n        p = m2*p*1.36;\n        \n    }   \n    a = 1.-estep(a,2.5,1.)*1.;\n    \n    return a;\n}\n\nfloat map2( in vec2 p)\n{\n    float a = 0.0;\n    float z = 1.;\n\tvec2  d = vec2(0.0);\n    for( int i=0; i<9; i++ )\n    {\n        vec3 n = simplex2D(p*0.75);\n        d += abs(n.yz)*7.*sign(n.yz);\n        d *= .65;\n        a += z * (sin(n.x/(dot(d,d)+2.)*7.)*.4+.8);\n\t\tz *= -.85;\n        p = m2*p*1.4;\n        \n    }\n    \n    return a;\n}\n\nvec3 normal(in vec2 p)\n{\n    const vec2 e = vec2(0.0065,0.);\n    return normalize( vec3( map(p+e.xy) - map(p-e.xy), 0.05, map( p+e.yx)-map(p-e.yx) ) );\n}\n\nvec3 tex(in vec2 p)\n{\n    p *= 2.5;\n    vec3 col = vec3(0);\n    float rz = map(p);\n    rz = 3.-rz;\n    vec2 dd = vec2(0.7,-.75);\n    float dif = clamp(dot( normal(p),(vec3(dd.x,0.1,dd.y)) )*0.5+0.5,0.0,1.0);\n    \n    rz= pow(abs(rz),.72);\n    col = 1.45-(sin(vec3(.24*rz*rz+0.4 ,0.75*rz, 1.55)+rz*1.1+3.8))*0.9;\n    col *= dif*map2(p*1.)*1.8;\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 p = fragCoord.xy / iResolution.xy;\n    \n    #ifdef SAME_FRAG_COUNT\n    p *= 1.6/0.7071;\n    p -= 0.5*1.6;\n    p.x *= iResolution.x/iResolution.y;\n    #else\n    p *= 1.6/0.82;\n    p -= 0.5*1.6;\n    p.x *= iResolution.x/iResolution.y;\n    #endif\n    \n   \n    float isOff = mod(fragCoord.x + fragCoord.y, 2.);\n    \n    vec3 col = vec3(0);\n\tcol = tex(p+time*0.1 + 10.);\n    \n\tfragColor = vec4(col,1.0);\n}","name":"Buffer B","description":"","type":"buffer"}]}