{"ver":"0.1","info":{"id":"XsKczV","date":"1522730583","viewed":217,"name":"Computed Spherical Harmonics","username":"hallabada","description":"Simple ray tracer for SHs\n\nChange L and M values to draw different SH.\nRotation of SH is not included. Current implementation of rotation is wrong.","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["raytracer","sphericalharmonics"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/**\n* Written by Jung, Yucheol <ycjung@postech.ac.kr>\n* ycjungSubhuman@github.com\n*\n* Reference : Robin Green, Spherical Harmonic Lighting - The Grity Details\n* Visualizes spherical harmonics\n*\n* Calculates SH without using pre-computed values\n*/\n\n/** \n * MODIFY THESE VALUES TO SEE DIFFERENT SHs \n * L > 0, L is int.\n * -L <= M <= L, M is int.\n */\n#define L 1\n#define M 0\n\n/* MATH UTILITIES *************************************************************/\n#define PI 3.14159265358979323846264\n#define SQRT_TWO 1.41421356237309504880169\n\nconst int factorial_table[12] = int[12](\n  1,\n  2,\n  6,\n  24,\n  120,\n  720,\n  5040,\n  40320,\n  362880,\n  3628800,\n  39916800,\n  479001600);\n\nint factorial (int n) {\n  return factorial_table[n-1];\n}\n\n/* SH *************************************************************************/\n\n/**\n* Calculate associated Legendre polynomial\n*\n* \"Numerical Methods in C: The Art of Scientific Computing”,\n* Cambridge University Press, 1992, pp 252-254\n*/\nfloat P(int l, int m, float x) {\n  // Calculate P_m^m first (Because it has a closed form)\n  float p_mm=1.0;\n  if (m>0) {\n    float somx2 = sqrt((1.0-x)*(1.0+x));\n    float fact = 1.0;\n    for(int i=1; i<=m; i++) {\n      p_mm *= (-fact) * somx2;\n      fact += 2.0;\n    }\n  }\n  // If l==m, no need for further calculation, return.\n  if (l==m) return p_mm;\n  // Proceed to P_{m+1}^{m} using P_m^m\n  float p_mmp1 = x * (2.0*float(m) + 1.0) * p_mm;\n  // Just a micro optimization with early return\n  if (l==m+1) return p_mmp1;\n  // Calclulate general p_l^{m}\n  // Using relation\n  //   (l-m)P_l^m = x(2l-1)P_{l-1}^m - (l+m-1)P_{l-2}^m\n  float p_ll = 0.0;\n  for (int ll=m+2; ll<=l; ll++) {\n    p_ll = ( (2.0*float(ll)-1.0)*x*p_mmp1-(float(ll)+float(m)-1.0)*p_mm )\n    / float(ll-m);\n    p_mm = p_mmp1;\n    p_mmp1 = p_ll;\n  }\n  return p_ll;\n}\n\n/** Normalization coefficient for SH */\nfloat K(int l, int m) {\n  return sqrt(\n    (2.0*float(l)+1.0)*float(factorial(l-m))\n    / (4.0*PI*float(factorial(l+m)))\n    );\n}\n\n/** SH of l, m, theta(zenith), phi(azimuth) */\nfloat SH(int l, int m, float theta, float phi) {\n  if (m==0) {\n    return K(1, 0)*P(l, m, cos(theta));\n  }\n  else if (m>0) {\n    return SQRT_TWO*K(l,m)*cos(float(m)*phi)*P(l,m,cos(theta));\n  }\n  else {\n    return SQRT_TWO*K(l,-m)*sin(-float(m)*phi)*P(l,-m,cos(theta));\n  }\n}\n\n/* RAYTRACING *****************************************************************/\n// Reference : Annotated Ray Tracing by Polytonic\n// (https://www.shadertoy.com/view/4ljGRd)\n// Reference : Jamie Wong, Ray marching signed distance functions\n// (http://jamie-wong.com/2016/07/15/ray-marching-signed-distance-functions/)\n#define RENDER_EPSILON    1e-4\n#define RENDER_ITERATION  200\n#define RENDER_RAY_RECURSION  1\n#define RENDER_ENDDEPTH   50.0\n#define RENDER_EXPOSURE   5e-2\n#define RENDER_GAMMA      2.2\n#define RENDER_INTENSITY  100.0\n#define RENDER_AMBIENT (vec3(0.6, 0.8, 1.0) * RENDER_INTENSITY / RENDER_GAMMA)\n\nstruct Ray {\n  vec3 origin;\n  vec3 direction;\n};\n\nstruct Light {\n  vec3 color;\n  vec3 direction;\n};\n\nstruct Intersect {\n  float len;\n  vec3 normal;\n};\n    \nconst Intersect MISS = Intersect(0.0, vec3(0.0));\n\n/* RAYTRACING-SDF *************************************************************/\nfloat sdf_sh(int l, int m, float scale, vec3 sh_position, vec3 ray_position, vec3 ro) {\n  vec3 p = (ray_position - sh_position);\n  float pr = length(p);\n  float theta = atan(sqrt(p.x*p.x + p.y*p.y)/p.z);\n  float phi = PI+atan(p.x, p.y);\n  \n  float fr = scale*abs(SH(l, m, theta, phi));\n   \n  vec3 delta = ray_position - fr*normalize(p);\n  if(dot(delta, p) < 0.0) {\n      return -length(delta);\n  }\n  else {\n      return length(delta);\n  }\n}\n\n/* RAYTRACING-SCENE-RENDER ****************************************************/\n#define NUM_SH_BANDS 5\n#define SCENE_SH_COUNT (NUM_SH_BANDS*NUM_SH_BANDS)\n\nfloat sdf_scene(vec3 p, vec3 ro) {\n  float sh = sdf_sh(L,M, 5.0, vec3(0.0, 0.0, 0.0), p, ro);\n  return sh;\n}\n\nvec3 estimate_normal(vec3 p, vec3 ro) {\n  return normalize(vec3(\n    sdf_scene(vec3(p.x + RENDER_EPSILON, p.y, p.z), ro)\n    - sdf_scene(vec3(p.x - RENDER_EPSILON, p.y, p.z), ro),\n    sdf_scene(vec3(p.x, p.y + RENDER_EPSILON, p.z), ro)\n    - sdf_scene(vec3(p.x, p.y - RENDER_EPSILON, p.z), ro),\n    sdf_scene(vec3(p.x, p.y, p.z + RENDER_EPSILON), ro)\n    - sdf_scene(vec3(p.x, p.y, p.z - RENDER_EPSILON), ro)\n    ));\n}\n\nIntersect trace(Ray ray) {\n  float depth = 0.0;\n\n  for (int i=0; i<RENDER_ITERATION; i++) {\n    float dist = sdf_scene(ray.origin + depth*ray.direction, ray.origin);\n\n    if (dist < RENDER_EPSILON) {\n      break;\n    }\n    depth += dist;\n\n    if (depth >= RENDER_ENDDEPTH) {\n      return MISS;\n      break;\n    }\n  }\n  return Intersect(depth, estimate_normal(ray.origin + depth*ray.direction, ray.origin));\n}\n\nLight light = Light(vec3(1.0, 1.0, 1.0), normalize(vec3(1.0, 1.0, 1.0)));\n\nvec3 render(Ray ray) {\n  vec3 color = vec3(0.0);\n  vec3 color_surf = vec3(1.0, 2.0, 1.0);\n\n  for (int i=0; i<RENDER_RAY_RECURSION; i++) {\n    Intersect hit = trace(ray);\n\tvec3 reflection = reflect(ray.direction, hit.normal);\n    Intersect next_hit = trace(Ray(ray.origin + ray.direction*hit.len + 1e9*light.direction, light.direction));\n    if (next_hit == MISS){\n      color += clamp(dot(hit.normal, light.direction), 0.1, 1.0)\n                 * light.color * color_surf;\n    }\n    \n    if (hit == MISS) { \n      color *= RENDER_AMBIENT;\n      break;\n    }\n\n    ray = Ray(ray.origin + ray.direction*hit.len + RENDER_EPSILON*reflection,\n      reflection);\n  }\n  return color;\n}\n\n/* MAIN ***********************************************************************/\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = fragCoord.xy / iResolution.xy;\n  // coordinate whose (0,0) is the center of canvas.\n  // independent of aspect ratio\n  vec2 p = vec2((-0.5+uv.x)*(iResolution.x/iResolution.y), -0.5+uv.y);\n\n    //Camera code from iq (https://www.shadertoy.com/view/lsfXWH)\n    // camera\n    float an = 10.0*iMouse.x/iResolution.x;\n    vec3  ro = vec3(12.0*sin(an),0.0,12.0*cos(an));\n    vec3  ta = vec3(0.0,0.0,0.0);\n\n    // camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    \n    vec3 rd = normalize( p.x*uu + p.y*vv + 2.0*ww );\n\n  light.direction = normalize(vec3(1, 2.0*sin(iTime), 1.0*sin(2.0*iTime)));\n  //Ray ray = Ray(vec3(0.0, 0.0, 12), normalize(vec3(p.x, p.y, -1.0)));\n    Ray ray = Ray(ro, rd);\n  fragColor = vec4(pow(render(ray)*RENDER_EXPOSURE, vec3(1.0/RENDER_GAMMA)), 1.0);\n}\n","name":"Image","description":"","type":"image"}]}