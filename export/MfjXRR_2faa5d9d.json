{"ver":"0.1","info":{"id":"MfjXRR","date":"1705981481","viewed":393,"name":"Bent horizon","username":"felipetovarhenao","description":"Infinite terrain using raymarching and fbm noise.","likes":35,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","terrain","fbm"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\nAuthor: Felipe Tovar-Henao [www.felipe-tovar-henao.com]\n*/\n\n\n#define PI 3.14159265359\n#define TWO_PI 6.28318530718\n#define FBM_ITER 5\n\nvec2 viewport(in vec2 uv,in vec2 r){\n\treturn(uv*2.-r)/min(r.x,r.y);\n}\n\nfloat rand(in float x,in int s){\n    return fract(sin(x+float(s))*43758.5453123);\n}\n\nfloat rand(in vec2 uv,in int seed){\n    return fract(sin(dot(uv.xy,vec2(12.9898,78.233))+float(seed))*43758.5453123);\n}\n\nfloat noise(in float x,in int s){\n    float xi=floor(x);\n    float xf=fract(x);\n    return mix(rand(xi,s),rand(xi+1.,s),smoothstep(0.,1.,xf));\n}\n\nfloat noise(in vec2 p,in int s){\n    vec2 pi=floor(p);\n    vec2 pf=fract(p);\n    \n    vec2 o=vec2(0,1);\n    \n    float bl=rand(pi,s);\n    float br=rand(pi+o.yx,s);\n    float tl=rand(pi+o.xy,s);\n    float tr=rand(pi+o.yy,s);\n    \n    vec2 w=smoothstep(0.,1.,pf);\n    \n    float t=mix(tl,tr,w.x);\n    float b=mix(bl,br,w.x);\n    \n    return mix(b,t,w.y);\n}\n\nfloat fbm(in vec2 p,in int seed){\n    float v=0.;\n    float a=.5;\n    float f=0.;\n    for(int i=0;i<FBM_ITER;i++){\n        v+=a*noise(p,seed);\n        p*=2.;\n        a*=.5;\n    }\n    return v;\n}\n\nvec3 gradient(in float t,in vec3 a,in vec3 b,in vec3 c,in vec3 d){\n\treturn a+b*cos(TWO_PI*(c*t+d));\n}\n\nfloat cosine(in float x,in float s){\n    float y=cos(fract(x)*PI);\n    return floor(x)+.5-(.5*pow(abs(y),1./s)*sign(y));\n}\n\nfloat noise(in float x){\n    return noise(x,0);\n}\n\nmat2 rot2(in float a){\n    float c=cos(a);\n    float s=sin(a);\n    return mat2(c,-s,s,c);\n}\n\nfloat map(vec3 p){\n\tfloat t=iTime*.5;\n\tp.z+=t;\n\tt*=.125;\n\tfloat ti=floor(t);\n\tfloat tf=fract(t);\n\tfloat n=fbm(p.xz,0);\n\tn=pow(n,3.+sin(t));\n\tfloat g=p.y+2.;\n\tg-=n;\n\tg=min(g,3.3-g);\n\treturn g;\n}\n\nconst vec3 c3=vec3(.05);\nconst vec3 c4=vec3(.52,.57,.59);\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\tvec2 uv=viewport(fragCoord.xy,iResolution.xy);\n\tfloat t=iTime*.1;\n\t\n\tvec3 ro=vec3(0,0,-3);\n\tvec3 rd=normalize(vec3(uv,1));\n    rd.xz *= rot2(sin(t));\n\tvec3 p=vec3(0);\n\t\n\tfloat d=0.;\n\tfloat dt=0.;\n\t\n\tfloat j=0.;\n    \n    float m=.1;\n\tfloat an=cos(t*.05)*m;\n\n\tfor(int i=0;i<30;i++){\n\t\tp=ro+rd*d;\n        p.xy*=rot2(d*an);\n\t\tdt=map(p);\n\t\td+=dt;\n\t\tj=float(i);\n\t\tif(dt<.001||d>100.){\n\t\t\tbreak;\n\t\t}\n\t}\n    \n    \n    float glow=sin(noise(t*5.))*.005+.02;\n\td+=+j*(.33+glow*5.);\n\tfloat a=smoothstep(0.,30.,d);\n\tfloat phase=cosine(length(p.zy*.1),2.);\n    \n    float g=sin(iTime*.125)*.25+.35;\n    vec3 c12=vec3(g);\n\tvec3 col1=gradient(phase,c12,c12,c3,c4)*d*.2;\n    \n    vec3 col2=mix(vec3(.9,.9,.56),vec3(.95,.65,.38),sin(noise(t*5.+uv.x*.3))*.5+.5)*d*glow;\n\tvec3 col=mix(col1,col2,a);\n\t\n\tfragColor=vec4(col,1.);\n}","name":"Image","description":"","type":"image"}]}