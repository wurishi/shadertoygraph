{"ver":"0.1","info":{"id":"McjBzK","date":"1725218407","viewed":48,"name":"Pixel scan","username":"fw3d","description":"Pixel scan appear effect. By VFX-JS library https://x.com/amagitakayosi","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["effect","appear"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Constants (adjust these values as needed)\n#define MODE 0  // 0: Left-to-right, 1: Top-to-bottom, 2: Radial\n#define LAYERS 5.0\n#define SPEED 1.0\n#define DELAY 0.0\n#define WIDTH 0.05\n\n#define W WIDTH\n#define MAX_LAYERS 32.0 // Define a maximum number of layers\n\nvec4 readTex(vec2 uv) {\n    if (uv.x < 0.0 || uv.x > 1.0 || uv.y < 0.0 || uv.y > 1.0) {\n        return vec4(0.0);\n    }\n    return texture(iChannel0, uv);\n}\n\nfloat hash(vec2 p) {\n    return fract(sin(dot(p, vec2(4859.0, 3985.0))) * 3984.0);\n}\n\nvec3 hsv2rgb(vec3 c) {\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nfloat sdBox(vec2 p, float r) {\n    vec2 q = abs(p) - r;\n    return min(length(q), max(q.y, q.x));\n}\n\nfloat dir = 1.0;\n\nfloat toRangeT(vec2 p, float scale) {\n    float d;\n    \n    if (MODE == 0) {\n        d = p.x / (scale * 2.0) + 0.5;\n    }\n    else if (MODE == 1) {\n        d = 1.0 - (p.y / (scale * 2.0) + 0.5);\n    }\n    else if (MODE == 2) {\n        d = length(p) / scale;\n    }\n    \n    d = dir > 0.0 ? d : (1.0 - d);\n    \n    return d;\n}\n\nvec4 cell(vec2 p, vec2 pi, float scale, float t, float edge) {\n    vec2 pc = pi + 0.5;\n    vec2 uvc = pc / scale;\n    uvc.y /= iResolution.y / iResolution.x;\n    uvc = uvc * 0.5 + 0.5;\n    if (uvc.x < 0.0 || uvc.x > 1.0 || uvc.y < 0.0 || uvc.y > 1.0) {\n        return vec4(0.0);\n    }\n    float alpha = smoothstep(0.0, 0.1, texture(iChannel0, uvc).a);\n    \n    vec4 color = vec4(hsv2rgb(vec3((pc.x * 13.0 / pc.y * 17.0) * 0.3, 1.0, 1.0)), 1.0);\n    \n    float x = toRangeT(pi, scale);\n    float n = hash(pi);\n    float anim = smoothstep(W * 2.0, 0.0, abs(x + n * W - t));\n    color *= anim;    \n    \n    color *= mix(\n        1.0, \n        clamp(0.3 / abs(sdBox(p - pc, 0.5)), 0.0, 10.0),\n        edge * pow(anim, 10.0)\n    ); \n    \n    return color * alpha;\n}\n\nvec4 cellsColor(vec2 p, float scale, float t) {\n    vec2 pi = floor(p);\n    \n    vec2 d = vec2(0.0, 1.0);\n    vec4 cc = vec4(0.0);\n    cc += cell(p, pi, scale, t, 0.2) * 4.0;\n    cc += cell(p, pi + d.xy, scale, t, 0.9);\n    cc += cell(p, pi - d.xy, scale, t, 0.9);\n    cc += cell(p, pi + d.yx, scale, t, 0.9);\n    cc += cell(p, pi - d.yx, scale, t, 0.9);\n    \n    return cc / 8.0;\n}\n\nvec4 draw(vec2 uv, vec2 p, float t, float scale) {\n    vec4 c = readTex(uv);\n    vec2 pi = floor(p * scale);\n    float n = hash(pi);\n    t = t * (1.0 + W * 4.0) - W * 2.0;\n    \n    float x = toRangeT(pi, scale);\n    float a1 = smoothstep(t, t - W, x + n * W);    \n    c *= a1;\n    c += cellsColor(p * scale, scale, t) * 1.5;\n    \n    return c;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 p = uv * 2.0 - 1.0;\n    p.y *= iResolution.y / iResolution.x;\n    \n    // Calculate transition time based on iTime\n    float transitionDuration = 2.0; // Adjust this value to change transition duration\n    float t = mod(iTime / transitionDuration, 2.0);\n    if (t > 1.0) {\n        t = 2.0 - t;\n        dir = -1.0;\n    } else {\n        dir = 1.0;\n    }\n    t = clamp((t - DELAY) * SPEED, 0.0, 1.0);\n    t = (fract(t * 0.99999) - 0.5) * dir + 0.5;\n    \n    vec4 finalColor = vec4(0.0);\n    float layerCount = 0.0;\n    for (float i = 0.0; i < MAX_LAYERS; i++) {\n        if (i >= LAYERS) break;\n        float s = cos(i) * 7.3 + 10.0; \n        finalColor += draw(uv, p, t, abs(s));\n        layerCount += 1.0;\n    }\n    fragColor = finalColor / layerCount;  \n    \n    fragColor *= smoothstep(0.0, 0.01, t);\n}","name":"Image","description":"","type":"image"}]}