{"ver":"0.1","info":{"id":"ltVGzy","date":"1475344341","viewed":265,"name":"Regular Tetrahedron","username":"deadmanswitch","description":"Regular Tetrahedron","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["raymarch","wip","green","tetrahedron","regular"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.141592653\n#define FOV 60.0\n\n#define MAX_STEP   32\n#define MAX_STEP_F 32.0\n\nconst float infinity = 1.0/0.00000000001;\n\n#define epsilon 0.0025\n\n\nfloat sum(in vec3 v3) {\n \treturn dot(v3, vec3(1.0));   \n}\n\nstruct Hit {\n    float dist;\n    vec3 norm;\n    vec3 col;\n};\n    \nstruct DirLight {\n\tvec3 dir;\n    vec3 col;\n    float intensity;\n};\n    \nvec3 applyLight(in DirLight light, in vec3 pos, in vec3 cam, in Hit hit) {\n\t\n    vec3 surfaceToLight = light.dir;\n\n    float diffuseCoefficient = max(0.0, dot(hit.norm, surfaceToLight));\n    \n    vec3 diffuse = diffuseCoefficient * hit.col*light.col * light.intensity;\n\n    // specular\n    vec3 surfaceToCamera = normalize(cam - pos);\n\n    float specularCoefficient = pow(\n        max(0.0, dot(surfaceToCamera, reflect(-surfaceToLight, hit.norm))),\n        1.0/0.0025/*materialShininess*/\n    );\n\n    vec3 specular = specularCoefficient * vec3(1.0, 1.0, 1.0)/*materialSpecularColor*/ * light.intensity;\n\t\n    // ambient\n    vec3 ambient = hit.col*light.col*0.05;\n    \n    // result\n    return diffuse + specular + ambient;\n    \n}\n\n// rotations\nmat4 rotationMatrix(vec3 axis, float angle) {\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n                0.0,                                0.0,                                0.0,                                1.0);\n}\n\n// matrix functions\n\nvec3 applyMat( in vec3 v, in mat4 mat) {\n    return (vec4(v, 1.0) * mat).xyz;\n}\n\n//\nconst vec3 shadowColor = vec3(0.1, 0.0, 0.1);\nconst vec3 backColor = vec3(0.5, 0.5, 0.5);\nconst vec3 tetColor = vec3(0.0, 0.75, 0.0);\n\n/***************\n\nTetrahedron start\n\n***************/\n\n// normals\nconst vec3 norm1 = vec3(\n\t 0.4714045226573944,\n     0.3333333432674408,\n    -0.8164966106414795\n);\nconst vec3 norm2 = vec3(\n\t-0.9428090453147888,\n     0.3333333432674408,\n     0.0\n);\nconst vec3 norm3 = vec3(\n\t 0.4714045524597168,\n     0.3333333432674408,\n     0.8164966106414795\n);\nconst vec3 norm4 = vec3(\n\t 0.0,\n    -1.0,\n     0.0\n);\n\n// points\nconst vec3 point0 = vec3( 0.0,                 1.0,                 0.0);\nconst vec3 point1 = vec3( 0.9428090453147888, -0.3333333432674408,  0.0);\nconst vec3 point2 = vec3(-0.4714045226573944, -0.3333333432674408, -0.8164966106414795);\nconst vec3 point3 = vec3(-0.4714045226573944, -0.3333333432674408,  0.8164966106414795);\n\nfloat planedist(in vec3 point, in vec3 norm) {\n\n    return dot(point, norm) - norm.y;\n\n}\n\nconst float size = 3.0;\nHit tet(in vec3 point) {\n    \n    Hit hit;\n    point = point/size;\n\n    // subtracting the planes from a sphere\n    vec4 distances = vec4(\n        planedist(point, norm1),\n        planedist(point, norm2),\n        planedist(point, norm3),\n        -(1.0/3.0+point.y)\n    );\n\n    float dist = max( max(distances.x, distances.y), max(distances.z, distances.w) );\n\n    // the sphere has a `size` radius\n    hit.dist = max(length(point)-1.0, dist)*size;\n    \n    if(hit.dist < epsilon) {\n        \n        // select the appropriate norm\n        vec4 eq = vec4(equal(distances, vec4(dist)));\n        \n        hit.norm = eq.x*norm1 + eq.y*norm2 + eq.z*norm3 + eq.w*norm4;\n        \n        hit.col = tetColor;\n        \n    }\n\n    return hit;\n    \n}\n\n/***************\n\nTetrahedron end\n\n***************/\n\nHit DE(in vec3 pos, in mat4 trans, in mat4 invTrans) {\n    \n    pos = applyMat(pos, invTrans);\n    \n    Hit hit = tet(pos);\n    \n    // convert back normal coordinates to global\n    hit.norm = normalize(applyMat(hit.norm, trans) - applyMat(vec3(0.0, 0.0, 0.0), trans));\n    \n    return hit;\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    // camera\n\tvec2 view = fragCoord.xy / iResolution.xy * 2.0 - 1.0;\n    \n    float aspect = iResolution.x/iResolution.y;\n    float a = tan(FOV * (PI/180.0) / 2.0);\n    vec2 ab = vec2(a * aspect, a);\n    \n    // the start point, and the direction of the ray\n    vec3 dir = normalize(vec3(ab*view, -1.0));\n    vec3 point = vec3(0.0, 0.0, 10.0+sin(iTime)*4.0);\n    vec3 pos = point;\n    \n    // light\n    DirLight light;\n    light.dir = normalize(vec3(0.25, 0.25, 1.0));\n    light.col = vec3(1.0, 1.0, 1.0);\n    light.intensity = 1.0;\n    \n    // trans\n    float rot = (iTime*0.25)*PI*2.0;\n    \n    mat4 trans = rotationMatrix(vec3(1.0, 0.0, 0.0), rot)*rotationMatrix(vec3(0.0, 1.0, 0.0), rot)*rotationMatrix(vec3(0.0, 0.0, 1.0), rot);\n    mat4 invTrans = inverse(trans);\n    \n    // ray-march\n    float closest = infinity;\n\n    for(int i = 0; i<MAX_STEP; i++) {\n\t\t\n        Hit hit = DE(pos, trans, invTrans);\n        float dist = hit.dist;\n\n        if(dist < epsilon) {\n            /*\n            fragColor = vec4(mix(\n                tetColor,\n                shadowColor,\n                sqrt(float(i)/MAX_STEP_F)\n            ), 1.0);\n            */\n            \n            fragColor = vec4(applyLight(light, pos, point, hit), 1.0);\n            \n            return;\n        }\n\n        closest = min(closest, dist);\n\n        pos += dir*dist;\n\n    }\n\n    fragColor = vec4(mix(\n        shadowColor,\n        backColor,\n        sqrt(clamp(closest/2.0, 0.0, 1.0))\n    ), 1.0);\n    \n}","name":"Image","description":"","type":"image"}]}