{"ver":"0.1","info":{"id":"MlSXzG","date":"1444539928","viewed":7149,"name":"Are Gee Be","username":"jasminpatry","description":"First foray into 3D SDF raymarching.  See top of code to enable AA, importance sampling, DOF, motion blur, etc. \n","likes":123,"published":1,"flags":0,"usePreview":0,"tags":["procedural","3d","raymarching","sdf","metaballs","motionblur","dof","importancesampling","pbr","ggx"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[],"code":"\n// Configuration\n\n// Number of (primary) rays per pixel\n\n#define RAY_COUNT (1)\n\n// Enable specular importance sampling?\n\n#define ENABLE_IS 0\n\n// Larger values reduces fireflies\n\nconst float g_gISNoiseReduction = 0.005;\n\n// Enable depth of field?\n\n#define ENABLE_DOF 0\n\n// Controls size of DOF ray cone\n\nconst float g_rDOFScale = 0.015;\n\n// Enable motion blur?\n\n#define ENABLE_MOTION_BLUR 0\n\n// Motion blur exposure time in seconds.\n\nconst float g_dTExposure = 1.0 / 48.0;\n\n// Number of reflection bounces\n\nconst int g_cBounce = 3;\n\n// Angle (radians) to tilt camera down\n\nconst float g_radTiltCamera = 0.06;\n\n// Full-strength (mirror-like, no fog) sun reflections. Fake, but combined with long-exposure\n//\tmotion blur gives cool specular light painting effects. Has no effect unless ENABLE_IS is on.\n\n#define FULL_STRENGTH_SUN 0\n\n// Scaling factor for sun reflections & specular highlights. Alternative or complement to\n//\tFULL_STRENGTH_SUN to achieve light painting effects.\n\nconst float g_rSunSpecScale = 1.0;\n\n// If true, uses same low-discrepancy sequence to generate DOF and IS samples. Generally not good\n//\tpractice, but can generate rather beautiful results when combined with long exposure times.\n\n#define CORRELATED_DOF 0\n\n// If true, uses same low-discrepancy sequence to generate motion blur and IS samples. Generally\n//\tnot good practice, but can generate rather beautiful results when combine with long exposure\n//\ttimes. For example see https://twitter.com/jasminpatry/status/652570309204115456\n\n#define CORRELATED_MB 0\n\n// For doing high-res offline tiled renders\n\n#define TILED_RENDER 0\n\n// If true, use soft-min from @mmalex's SIGGRAPH 2015 presentation. (This is what started me on\n//\tthis in the first place.) If false, uses \"classic\" soft-min (see\n//\thttp://www.johndcook.com/blog/2010/01/20/how-to-compute-the-soft-maximum/ ), which has the\n//\tadvantage that its derivatives are continuous everywhere.\n\n#define MM_SOFT_MIN 0\n\n// My son's color scheme :)\n\n#define BERNIE_COLORS 0\n\n// Halloween colors\n\n#define HALLOWEEN_COLORS 0\n\n// Disable AO? Doesn't contribute very much since diffuse albedo is dark, and it's pretty\n//\texpensive...\n\n#define DISABLE_AO 0\n\n// Disable shadows?\n\n#define DISABLE_SHADOWS 0\n\n// Debug displays\n\n#define DEBUG_STEPS\t\t0\n#define DEBUG_DIFFUSE\t0\n#define DEBUG_NORMALS\t0\n#define DEBUG_AO\t\t0\n#define DEBUG_SHADOWS\t0\n\n// End configuration\n\n\n\nconst float g_gPi = 3.14159265359;\n\n// Maximum ray length\n\nconst float g_sRayMax = 1.0e5;\n\n// Maximum geometry height\n\nconst float g_zMax = 400.0;\n\n// Specular reflectance at normal incidence\n\nconst float g_rSpecular = 0.04;\n\n// Global time (jittered if motion blur is enabled)\n\nfloat g_t = 0.0;\n\n// [0-1] uniform random values for importance sampling\n\nvec2 g_vecURandomIS = vec2(0);\n\n// Light direction\n\nvec3 g_normalLight = vec3(0);\n\nfloat saturate(float g)\n{\n\treturn clamp(g, 0.0, 1.0);\n}\n\nvec2 saturate(vec2 vec)\n{\n\treturn clamp(vec, 0.0, 1.0);\n}\n\nvec3 saturate(vec3 vec)\n{\n\treturn clamp(vec, 0.0, 1.0);\n}\n\nvec4 saturate(vec4 vec)\n{\n\treturn clamp(vec, 0.0, 1.0);\n}\n\nfloat GLuminance(vec3 rgbLinear)\n{\n\treturn dot(rgbLinear, vec3(0.2126, 0.7152, 0.0722));\n}\n\nfloat GSign(float g)\n{\n\treturn (g < 0.0) ? -1.0 : 1.0;\n}\n\nfloat GSqr(float g)\n{\n\treturn g * g;\n}\n\nfloat GLengthSqr(vec3 vec)\n{\n\treturn dot(vec, vec);\n}\n\nfloat UHash(vec2 xy)\n{\n\treturn fract(sin(dot(xy.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nvec2 VecHash2(vec2 xy)\n{\n\t// BB Values for y component pulled out of the air, more or less.\n\n\treturn fract(sin(vec2(\n\t\t\t\t\t\tdot(xy, vec2(12.9898, 78.233)),\n\t\t\t\t\t\tdot(xy, vec2(-67.233, 10.9898)))) * vec2(43758.5453, 73756.5453));\n}\n\nvec2 VecSubRandom(vec2 vecPrev)\n{\n\t// From http://mollwollfumble.blogspot.com/2011/03/subrandom-numbers.html\n\t//\tInteractive graph: https://www.desmos.com/calculator/rvtbalxuhq\n\n\tvecPrev += vec2(0.5545497, 0.308517);\n\treturn vecPrev - floor(vecPrev);\n}\n\nvec2 VecDisc(vec2 vecURandom)\n{\n\t// For vecURandom uniformly distributed in [0, 1], returns uniform samples on unit disc.\n\n\tfloat rad = vecURandom.x * 2.0 * g_gPi;\n\tfloat s = sqrt(vecURandom.y);\n\treturn s * vec2(cos(rad), sin(rad));\n}\n\nvec3 VecRotateY(vec3 vec, float rad)\n{\n\tfloat gSin = sin(rad);\n\tfloat gCos = cos(rad);\n\tvec3 vecRot = vec;\n\tvecRot.x = vec.x * gCos + vec.z * gSin;\n\tvecRot.z = - vec.x * gSin + vec.z * gCos;\n\treturn vecRot;\n}\n\nvoid UpdateLightDirection()\n{\n\tvec3 normalLight = normalize(vec3(0.2, 0.9, 0.2));\n\tfloat radTheta = 2.0 * g_gPi * g_t / 60.0;\n\tfloat gSin = sin(radTheta);\n\tfloat gCos = cos(radTheta);\n\tmat2 matRot = mat2(gCos, -gSin, gSin, gCos);\n\tnormalLight.xy = matRot * normalLight.xy;\n\tg_normalLight = normalLight;\n}\n\nvec3 RgbLight()\n{\n#if BERNIE_COLORS\n\treturn vec3(1.7, 0.3, 0.1);\n#elif HALLOWEEN_COLORS\n\treturn vec3(1.7, 0.15, 0.0);\n#else\n\treturn vec3(2.0, 0.1, 0.1);\n#endif\n}\n\nfloat RLightCone()\n{\n\t// tan of one half of subtended angle of sun disc in sky\n\n\treturn 0.02;\n}\n\nfloat GDotLightCone()\n{\n\treturn cos(atan(RLightCone()));\n}\n\nvec3 RgbSunDisc()\n{\n\treturn RgbLight() / (GSqr(RLightCone()));\n}\n\nvec3 RgbSky()\n{\n#if BERNIE_COLORS\n\treturn vec3(0.6, 0.4, 0.05);\n#elif HALLOWEEN_COLORS\n\treturn vec3(0.01, 0.001, 0.0);\n#else\n\treturn vec3(1.0, 1.0, 1.0) * 0.1;\n#endif\n}\n\nvec3 RgbAmbient()\n{\n\treturn RgbSky() / g_gPi;\n}\n\nvec3 RgbFog(vec3 normalRay)\n{\n#if BERNIE_COLORS\n\tvec3 rgbFog = RgbSky() * 3.0;\n#elif HALLOWEEN_COLORS\n\tvec3 rgbFog = vec3(1.0, 0.0, 0.0) * 0.03;\n#else\n\tvec3 rgbFog = vec3(0.6, 0.2, 1.0);\n#endif\n\treturn mix(rgbFog, RgbLight() * 3.5, GSqr(saturate(dot(normalRay, g_normalLight))));\n}\n\nvec4 VecOsc(vec4 vecFreq, vec4 vecAmp, float dT)\n{\n\treturn vecAmp * sin(vec4((g_t + dT) * 2.0 * g_gPi) * vecFreq);\n}\n\nvec4 Sphere0(vec4 sphereBase, float uRandom)\n{\n\treturn sphereBase + VecOsc(\n\t\t\t\t\t\t\tvec4(1.02389382 / 2.0, 1.0320809 / 3.0, 1.07381 / 4.0, 0.0),\n\t\t\t\t\t\t\tvec4(20, 100, 100, 0) +\n\t\t\t\t\t\t\tVecOsc(\n\t\t\t\t\t\t\t\tvec4(1.10382 / 6.0, 1.092385 / 10.0, 1.03389 / 14.0, 0),\n\t\t\t\t\t\t\t\tvec4(10, 50, 50, 0), 100.0 * uRandom), 100.0 * uRandom);\n}\n\nvec4 Sphere1(vec4 sphereBase, float uRandom)\n{\n\treturn sphereBase + VecOsc(\n\t\t\t\t\t\t\tvec4(1.032038 / 4.0, 1.13328 / 2.0, 1.09183 / 3.0, 0),\n\t\t\t\t\t\t\tvec4(20, 100, 100, 0) +\n\t\t\t\t\t\t\tVecOsc(\n\t\t\t\t\t\t\t\tvec4(1.0328 / 14.0, 1.1381 / 6.0, 1.0238 / 10.0, 0),\n\t\t\t\t\t\t\t\tvec4(10, 50, 50, 0), 100.0 * uRandom), 100.0 * uRandom);\n}\n\nvec4 Sphere2(vec4 sphereBase, float uRandom)\n{\n\treturn sphereBase + VecOsc(\n\t\t\t\t\t\t\tvec4(1.123283 / 3.0, 1.13323 / 4.0, 1.2238 / 2.0, 0),\n\t\t\t\t\t\t\tvec4(20, 100, 100, 0) +\n\t\t\t\t\t\t\tVecOsc(\n\t\t\t\t\t\t\t\tvec4(1.0 / 10.0, 1.0 / 14.0, 1.0 / 6.0, 0),\n\t\t\t\t\t\t\t\tvec4(10, 50, 50, 0), 100.0 * uRandom), 100.0 * uRandom);\n}\n\nfloat SSoftMinRadius01(float uRandom)\n{\n\treturn 100.0 + 50.0 * sin(g_t * 1.14 + uRandom * 100.0);\n}\n\nfloat SSoftMinRadius12(float uRandom)\n{\n\treturn 100.0 + 50.0 * sin(g_t * 1.16323823 + uRandom * 100.0);\n}\n\nvec3 RgbTonemap(vec3 rgbLinear)\n{\n\t// Desaturate with luminance\n\n\tfloat gLuminance = GLuminance(rgbLinear);\n\trgbLinear = mix(rgbLinear, vec3(gLuminance), GSqr(saturate((gLuminance - 1.0) / 1.0)));\n\n\t// Hejl/Burgess-Dawson approx to Hable operator; includes sRGB conversion\n\n\tvec3 rgbT = max(vec3(0.0), rgbLinear - 0.004);\n\tvec3 rgbSrgb = (rgbT * (6.2 * rgbT + 0.5)) / (rgbT * (6.2 * rgbT + 1.7) + 0.06);\n\n\treturn rgbSrgb;\n}\n\nstruct SMaterial\t// tag = mtl\n{\n\tvec3 m_rgbDiffuse;\n\tfloat m_gGgxAlpha;\n};\n\nSMaterial MtlCreate(vec3 rgbDiffuse, float gGgxAlpha)\n{\n\tSMaterial mtl;\n\tmtl.m_rgbDiffuse = rgbDiffuse;\n\tmtl.m_gGgxAlpha = gGgxAlpha;\n\treturn mtl;\n}\n\nSMaterial MtlLerp(SMaterial mtl0, SMaterial mtl1, float u)\n{\n\tSMaterial mtl;\n\tmtl.m_rgbDiffuse = mix(mtl0.m_rgbDiffuse, mtl1.m_rgbDiffuse, u);\n\tmtl.m_gGgxAlpha = mix(mtl0.m_gGgxAlpha, mtl1.m_gGgxAlpha, u);\n\treturn mtl;\n}\n\nstruct SHit\t// tag = hit\n{\n\tfloat m_s;\n\tvec3 m_normal;\n\tSMaterial m_mtl;\n};\n\nSHit HitMin(SHit hit0, SHit hit1)\n{\n\tif (hit0.m_s < hit1.m_s)\n\t{\n\t\treturn hit0;\n\t}\n\telse\n\t{\n\t\treturn hit1;\n\t}\n}\n\nSHit HitPlane(vec4 plane, SMaterial mtl, vec3 posRay, vec3 normalRay)\n{\n\tfloat gDotNormal = dot(plane.xyz, normalRay);\n\n\tfloat s = -dot(plane, vec4(posRay, 1.0)) / gDotNormal;\n\n\tSHit hit;\n\n\thit.m_normal = plane.xyz;\n\tvec3 posHit = (posRay + s * normalRay);\n\thit.m_normal.xy += saturate(-normalRay.z) * 0.1 * sin(posHit.xy / (100.0));\n\thit.m_normal = normalize(hit.m_normal);\n\thit.m_s = (abs(gDotNormal) > 1e-6 && s > 0.0) ? s : g_sRayMax;\n\thit.m_mtl = mtl;\n\n\treturn hit;\n}\n\nstruct SSdfSample\t// tag = sdf\n{\n\tfloat m_s;\n\tSMaterial m_mtl;\n};\n\nSSdfSample SdfSoftMin(SSdfSample sdf0, SSdfSample sdf1, float sRadiusBlend)\n{\n#if MM_SOFT_MIN\n\tfloat gT = max(sRadiusBlend - abs(sdf0.m_s - sdf1.m_s), 0.0);\n\tfloat s = min(sdf0.m_s, sdf1.m_s) - gT * gT * 0.25 / sRadiusBlend;\n#else\n\tfloat gK = 0.25 * sRadiusBlend;\n\tfloat sMin = min(sdf0.m_s, sdf1.m_s);\n\tfloat sMax = max(sdf0.m_s, sdf1.m_s);\n\tfloat s = sMin - gK * log2(exp2((sMin - sMax) / gK) + 1.0);\n#endif\n\tfloat dS0 = sdf0.m_s - s;\n\tfloat dS1 = sdf1.m_s - s;\n\tfloat u = dS0 / (dS1 + dS0);\n\tSSdfSample sdf;\n\tsdf.m_s = s;\n\tsdf.m_mtl = MtlLerp(sdf0.m_mtl, sdf1.m_mtl, u);\n\treturn sdf;\n}\n\nSSdfSample SdfSphere(vec4 sphere, SMaterial mtl, vec3 pos)\n{\n\tvec3 posSphere = sphere.xyz;\n\tfloat sRadius = sphere.w;\n\n\tSSdfSample sdf;\n\tsdf.m_s = length(pos - posSphere) - sRadius;\n\tsdf.m_mtl = mtl;\n\treturn sdf;\n}\n\nSSdfSample SdfBlobby(vec3 pos, float uRandom)\n{\n\tconst float gGgxAlpha = 1.0 / 64.0;\n\tconst vec4 sphereBase = vec4(0.0, 0.0, 200.0, 50.0);\n\n\tSSdfSample sdf = SdfSphere(\n\t\t\t\t\t\tSphere0(sphereBase, uRandom),\n\t\t\t\t\t\tMtlCreate(vec3(0.1, 0.8, 0.1) / 4.0, gGgxAlpha),\n\t\t\t\t\t\tpos);\n\n\tsdf = SdfSoftMin(\n\t\t\tsdf,\n\t\t\tSdfSphere(\n\t\t\t\tSphere1(sphereBase, uRandom),\n\t\t\t\tMtlCreate(vec3(0.1, 0.3, 0.8) / 4.0, gGgxAlpha),\n\t\t\t\tpos),\n\t\t\tSSoftMinRadius01(uRandom));\n\n\tsdf = SdfSoftMin(\n\t\t\tsdf,\n\t\t\tSdfSphere(\n\t\t\t\tSphere2(sphereBase, uRandom),\n\t\t\t\tMtlCreate(vec3(0.7, 0.05, 0.2) / 4.0, gGgxAlpha),\n\t\t\t\tpos),\n\t\t\tSSoftMinRadius12(uRandom));\n\n\treturn sdf;\n}\n\nconst float g_sRepeat = 800.0;\n\nvec2 PosIndex(vec3 pos)\n{\n\tvec2 posIndex;\n\tposIndex.x = floor((pos.x + 0.5 * g_sRepeat) / g_sRepeat);\n\tposIndex.y = floor((pos.y + 0.5 * g_sRepeat) / g_sRepeat);\n\treturn posIndex;\n}\n\nvec3 PosWrap(vec3 pos)\n{\n\tvec2 posIndex = PosIndex(pos);\n\tpos.xy = fract(pos.xy / g_sRepeat + 0.5) * g_sRepeat - 0.5 * g_sRepeat;\n\tif (dot(posIndex, posIndex) != 0.0)\n\t{\n\t\tpos.xy += (VecHash2(posIndex) - vec2(0.5, 0.5)) * g_sRepeat * 0.5;\n\t}\n\treturn pos;\n}\n\nfloat UHashFromPos(vec3 pos)\n{\n\tpos.xy = PosIndex(pos);\n\treturn UHash(pos.xy);\n}\n\nvec3 PosRound(vec3 pos)\n{\n\tpos.xy = floor((pos.xy + 0.5 * g_sRepeat) / g_sRepeat + 0.5) * g_sRepeat - 0.5 * g_sRepeat;\n\treturn pos;\n}\n\nfloat DSCellEdge(vec3 pos)\n{\n\tvec2 dPos = abs(PosRound(pos).xy - pos.xy);\n\tconst float sZSlop = 10.0;\n\treturn (pos.z > g_zMax) ? (pos.z - g_zMax - sZSlop) : min(dPos.x, dPos.y);\n}\n\nSSdfSample SdfScene(vec3 pos, float uRandom)\n{\n\tSSdfSample sdf = SdfBlobby(pos, uRandom);\n\n\t// Try to keep from penetrating the ground plane\n\t// BB Causes issues with shadows, better solution?\n\n\tsdf.m_s += max(0.0, max(20.0 - pos.z, 100.0 / max(pos.z, 1e-6)));\n\n\t// And g_zMax\n\n\tsdf.m_s += max(0.0, max(20.0 - (g_zMax - pos.z), 100.0 / max(g_zMax - pos.z, 1e-6)));\n\n\treturn sdf;\n}\n\nbool FIntersectScene(\n\t\tvec3 posRay,\n\t\tvec3 normalRay,\n\t\tout SHit o_hit,\n\t\tout int o_cStep)\n{\n\tSMaterial mtlPlane = MtlCreate(vec3(0.2, 0.2, 0.2), 1.0 / 20.0);\n\tSHit hitPlane = HitPlane(vec4(0, 0, 1, 0), mtlPlane, posRay, normalRay);\n\n\tfloat sRay = 0.0;\n\tconst int cStepMax = 100;\n\tfor (int cStep = 0; cStep < cStepMax; ++cStep)\n\t{\n\t\to_cStep = cStep;\n\n\t\tvec3 pos = posRay + normalRay * sRay;\n\n\t\tfloat uRandom = UHashFromPos(pos);\n\t\tSSdfSample sdf = SdfScene(PosWrap(pos), uRandom);\n\n\t\tfloat dSEdge = DSCellEdge(pos);\n\t\tconst float sEdgeSlop = 100.0;\n\t\tsRay += min(sdf.m_s, dSEdge + sEdgeSlop);\n\n\t\tif (sRay >= hitPlane.m_s ||\n\t\t\tpos.z < 0.0 ||\n\t\t\t(pos.z > g_zMax && normalRay.z >= 0.0))\n\t\t{\n\t\t\to_hit = hitPlane;\n\t\t\treturn hitPlane.m_s < g_sRayMax;\n\t\t}\n\n\t\tif (sdf.m_s < 1.0)\n\t\t{\n\t\t\to_hit.m_s = sRay;\n\t\t\tvec3 posHit = posRay + normalRay * sRay;\n\t\t\tposHit = PosWrap(posHit);\n\t\t\tSSdfSample sdfHit = SdfScene(posHit, uRandom);\n\n\t\t\t// Construct normal\n\n\t\t\tSSdfSample sdfHitX = SdfScene(posHit + vec3(0.1, 0, 0), uRandom);\n\t\t\tSSdfSample sdfHitY = SdfScene(posHit + vec3(0, 0.1, 0), uRandom);\n\t\t\tSSdfSample sdfHitZ = SdfScene(posHit + vec3(0, 0, 0.1), uRandom);\n\n\t\t\to_hit.m_normal = vec3(\n\t\t\t\t\t\t\t\tsdfHitX.m_s - sdfHit.m_s,\n\t\t\t\t\t\t\t\tsdfHitY.m_s - sdfHit.m_s,\n\t\t\t\t\t\t\t\tsdfHitZ.m_s - sdfHit.m_s);\n\t\t\to_hit.m_normal = normalize(o_hit.m_normal);\n\n\t\t\to_hit.m_mtl = sdfHit.m_mtl;\n\t\t\treturn true;\n\t\t}\n\t}\n\n\to_cStep = cStepMax;\n\n\to_hit = hitPlane;\n\treturn hitPlane.m_s < g_sRayMax;\n}\n\nfloat UConeTraceScene(vec3 posRay, vec3 normalRay, float rConeWidth, float dS, float dUOccMax, bool fCrossCells)\n{\n\tfloat sRay = 3.0;\n\n\tfloat uOcclusion = 1.0;\n\n\tfloat uRandom = 0.0;\n\n\t// rConeNoOcc is the non-occluded portion of the cone (tan of the cone half-angle)\n\n\tfloat rConeNoOcc = rConeWidth;\n\n\tif (!fCrossCells)\n\t{\n\t\tuRandom = UHashFromPos(posRay);\n\t\tposRay = PosWrap(posRay);\n\t}\n\n\tfor (int iStep = 0; iStep < 50; ++iStep)\n\t{\n\t\tvec3 pos = posRay + normalRay * sRay;\n\n\t\tfloat sConeWidth = sRay * rConeWidth;\n\n\t\t// Compute min step size. The second argument to max() is the step size yielding a maximum occlusion change of\n\t\t//\tdUOccMax.\n\n\t\tfloat dSMin = max(dS, 2.0 * dUOccMax * sRay * rConeWidth);\n\n\t\t// Find sRay_new such that sRay_new - sRay_old == sdf.m_s - rConeNoOcc * sRay_new\n\t\t//\ti.e., march until until new cone potentially touches surface\n\t\t//\tSolution is: sRay_new := (sdf.m_s - sRay_old * rConeNoOcc) / (1.0 + rConeNoOcc)\n        //  Then add dSMin to potentially get some occlusion.\n\n\t\tSSdfSample sdf;\n\t\tif (fCrossCells)\n\t\t{\n\t\t\tuRandom = UHashFromPos(pos);\n\t\t\tsdf = SdfScene(PosWrap(pos), uRandom);\n\n\t\t\tfloat dSCellEdge = DSCellEdge(pos);\n\t\t\tconst float sEdgeSlop = 10.0;\n\t\t\tsRay += max(\n\t\t\t\t\t\t0.0,\n\t\t\t\t\t\t(min(dSCellEdge + sEdgeSlop, sdf.m_s) - sRay * rConeNoOcc) /\n\t\t\t\t\t\t(1.0 + rConeNoOcc));\n            sRay += dSMin;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tsdf = SdfScene(pos, uRandom);\n\n\t\t\tsRay += max(0.0, (sdf.m_s - sRay * rConeNoOcc) / (1.0 + rConeNoOcc));\n            sRay += dSMin;\n\t\t}\n\n\t\t// Update occlusion and non-occluded cone width\n\n\t\tuOcclusion = min(uOcclusion, saturate(0.5 * (1.0 + sdf.m_s / sConeWidth)));\n\t\trConeNoOcc = rConeWidth * saturate(2.0 * uOcclusion - 1.0);\n\n\t\tif (uOcclusion < 0.01 ||\n\t\t\tpos.z < 0.0 ||\n\t\t\t(pos.z > g_zMax && normalRay.z >= 0.0))\n\t\t{\n\t\t\treturn uOcclusion;\n\t\t}\n\t}\n\n\treturn uOcclusion;\n}\n\n// GGX specular lighting\n// See e.g. http://blog.selfshadow.com/publications/s2013-shading-course/karis/s2013_pbs_epic_notes_v2.pdf\n\nfloat GGgxVisRcp(float gGgxAlphaSqr, float gDot)\n{\n\tgDot = saturate(gDot);\n\treturn gDot + sqrt(mix(GSqr(gDot), 1.0, gGgxAlphaSqr));\n}\n\nfloat UFresnel(float gDot)\n{\n\tfloat uFresnel = 1.0 - gDot;\n\tfloat uFresnel2 = GSqr(uFresnel);\n\tuFresnel = GSqr(uFresnel2) * uFresnel;\n\treturn uFresnel;\n}\n\nfloat RSpecularLight(vec3 normalRay, vec3 normal, float gGgxAlpha, out float o_rDiffuse)\n{\n\tfloat gGgxAlphaSqr = GSqr(gGgxAlpha);\n\n\tvec3 normalHalf = normalize(g_normalLight - normalRay);\n\tfloat gDotHalf = saturate(dot(normalHalf, normal));\n\n\tfloat uFresnel = UFresnel(gDotHalf);\n\n\tfloat rSpecular = mix(g_rSpecular, 1.0, uFresnel);\n\n\tfloat gNdf = gGgxAlphaSqr / GSqr(GSqr(gDotHalf) * (gGgxAlphaSqr - 1.0) + 1.0);\n\tfloat gVis = 1.0 / (GGgxVisRcp(gGgxAlphaSqr, dot(-normalRay, normal)) *\n\t\t\t\t\t\tGGgxVisRcp(gGgxAlphaSqr, dot(g_normalLight, normal)));\n\n\to_rDiffuse = 1.0 - rSpecular;\n\n#if ENABLE_IS\n\treturn 0.0;\n#else\n\treturn gNdf * gVis * rSpecular * g_rSunSpecScale;\n#endif\n}\n\nvec3 RgbLightHit(vec3 posHit, vec3 normalRay, SHit hit)\n{\n\tconst float rScaleLightCone = 3.0;\t// Enlarge light cone for softer shadows\n\n\tfloat uShadow = UConeTraceScene(\n\t\t\t\t\t\tposHit,\n\t\t\t\t\t\tg_normalLight,\n\t\t\t\t\t\tRLightCone() * rScaleLightCone,\n\t\t\t\t\t\t20.0,\n\t\t\t\t\t\t0.15,\n\t\t\t\t\t\ttrue);\n\n#if DISABLE_SHADOWS\n\tuShadow = 1.0;\n#endif\n\n#if DEBUG_SHADOWS\n\treturn vec3(uShadow);\n#endif\n\n\tfloat uAmbient = UConeTraceScene(posHit, hit.m_normal, 1.0, 20.0, 0.05, false);\n\n\t// BB Hacky AO based on normal Z with height falloff\n\n\tuAmbient = min(uAmbient, mix(\n\t\t\t\t\t\t\t\tsaturate(0.5 + 0.5 * hit.m_normal.z),\n\t\t\t\t\t\t\t\t1.0,\n\t\t\t\t\t\t\t\tsaturate(posHit.z / 300.0)));\n\n\tfloat dSCellEdge = DSCellEdge(posHit);\n\tuAmbient = mix(uAmbient, 1.0, smoothstep(0.0, 1.0, 1.0 - dSCellEdge / 100.0));\n\n#if DISABLE_AO\n\tuAmbient = 1.0;\n#endif\n\n#if DEBUG_AO\n\treturn vec3(uAmbient);\n#endif\n\n\tvec3 rgbLight = uAmbient * RgbAmbient() * hit.m_mtl.m_rgbDiffuse;\n\tfloat gDotLight = dot(g_normalLight, hit.m_normal);\n\tvec3 rgbDiffuse = hit.m_mtl.m_rgbDiffuse;\n\tfloat rDiffuse;\n\tfloat rSpecularLight = RSpecularLight(\n\t\t\t\t\t\t\tnormalRay,\n\t\t\t\t\t\t\thit.m_normal,\n\t\t\t\t\t\t\thit.m_mtl.m_gGgxAlpha,\n\t\t\t\t\t\t\trDiffuse);\n\trgbDiffuse *= rDiffuse;\n\trgbLight += uShadow * saturate(gDotLight) * (rgbDiffuse + rSpecularLight) * RgbLight();\n\n\treturn rgbLight;\n}\n\nfloat RFog(float s, vec3 posRay, vec3 normalRay)\n{\n\t// Height-based exponential fog\n\n\tconst float gDensityAtGround = 1.0 / 40000.0;\n\tconst float gHeightFalloff = 1.0 / 10000.0;\n\n\tfloat gT = -gDensityAtGround * exp(-gHeightFalloff * posRay.z);\n\n\tif (abs(normalRay.z) > 1e-6)\n\t{\n\t\tgT *= (1.0 - exp(-gHeightFalloff * normalRay.z * s)) / (gHeightFalloff * normalRay.z);\n\t}\n\telse\n\t{\n\t\tgT *= s;\n\t}\n\n\treturn exp(gT);\n}\n\nvec3 RgbIntersectScene(vec3 posRay, vec3 normalRay)\n{\n\tSHit hit;\n\tvec3 rgbLight = vec3(0);\n\tfloat r = 1.0;\n\tint cStepTotal = 0;\n\n\tfor (int iBounce = 0; iBounce <= g_cBounce; ++iBounce)\n\t{\n\t\tint cStep = 0;\n\t\tbool fIntersect = FIntersectScene(posRay, normalRay, hit, cStep);\n\n\t\tcStepTotal += cStep;\n\n#if DEBUG_DIFFUSE\n\t\t// BB Should use exact sRGB conversion\n\n\t\treturn (fIntersect) ? pow(hit.m_mtl.m_rgbDiffuse, vec3(1.0 / 2.2)) : vec3(0);\n#endif\n\n#if DEBUG_NORMALS\n\t\treturn (fIntersect) ? hit.m_normal * 0.5 + 0.5 : vec3(0);\n#endif\n\n\t\tif (fIntersect)\n\t\t{\n\t\t\tvec3 posHit = posRay + normalRay * hit.m_s;\n\n\t\t\tfloat rFog = RFog(hit.m_s, posRay, normalRay);\n\t\t\trgbLight += (1.0 - rFog) * r * RgbFog(normalRay);\n\t\t\tr *= rFog;\n\n\t\t\tvec3 rgbLightHit = RgbLightHit(posHit, normalRay, hit);\n\n#if DEBUG_AO || DEBUG_SHADOWS\n\t\t\treturn rgbLightHit;\n#endif\n\n\t\t\trgbLight += r * rgbLightHit;\n\n\t\t\t// Prepare for next bounce\n\n\t\t\tvec3 normalReflect;\n\n#if ENABLE_IS\n\t\t\t{\n\t\t\t\t// GGX importance sampling (see Karis notes linked above)\n\n\t\t\t\tfloat gGgxAlphaSqr = GSqr(hit.m_mtl.m_gGgxAlpha);\n\t\t\t\tfloat radPhi = 2.0 * g_gPi * g_vecURandomIS.x;\n\t\t\t\tfloat gCosTheta = sqrt((1.0 - g_vecURandomIS.y) /\n\t\t\t\t\t\t\t\t\t   (1.0 + (gGgxAlphaSqr - 1.0) * g_vecURandomIS.y));\n\t\t\t\tfloat gSinTheta = sqrt(1.0 - GSqr(gCosTheta));\n\n\t\t\t\tvec3 normalHalfTangentSpace = vec3(\n\t\t\t\t\t\t\t\t\t\t\t\tgSinTheta * cos(radPhi),\n\t\t\t\t\t\t\t\t\t\t\t\tgSinTheta * sin(radPhi),\n\t\t\t\t\t\t\t\t\t\t\t\tgCosTheta);\n\n\t\t\t\t// Construct orthonormal basis (Frisvad method)\n\n\t\t\t\tfloat gA = (hit.m_normal.z > -0.99999) ? 1.0 / (1.0 + hit.m_normal.z) : 0.0;\n\t\t\t\tfloat gB = -hit.m_normal.x * hit.m_normal.y * gA;\n\t\t\t\tvec3 tangent = vec3(1.0 - GSqr(hit.m_normal.x) * gA, gB, -hit.m_normal.x);\n\t\t\t\tvec3 binormal = vec3(gB, 1.0 - GSqr(hit.m_normal.y) * gA, -hit.m_normal.y);\n\t\t\t\tvec3 normalHalf = normalHalfTangentSpace.x * tangent +\n\t\t\t\t\tnormalHalfTangentSpace.y * binormal +\n\t\t\t\t\tnormalHalfTangentSpace.z * hit.m_normal;\n\n\t\t\t\tnormalReflect = normalRay - 2.0 * dot(normalRay, normalHalf) * normalHalf;\n\n\t\t\t\tfloat gDotRay = saturate(dot(hit.m_normal, -normalRay));\n\t\t\t\tfloat gDotReflect = saturate(dot(hit.m_normal, normalReflect));\n\t\t\t\tfloat gDotHalf = saturate(dot(hit.m_normal, normalHalf));\n\t\t\t\tfloat gRayDotHalf = saturate(dot(-normalRay, normalHalf));\n\t\t\t\tif (gDotReflect > 0.0)\n\t\t\t\t{\n\t\t\t\t\tfloat gVisRcp = GGgxVisRcp(gGgxAlphaSqr, gDotRay) *\n\t\t\t\t\t\t\t\t\tGGgxVisRcp(gGgxAlphaSqr, gDotReflect);\n\t\t\t\t\tfloat uFresnel = UFresnel(gRayDotHalf);\n\t\t\t\t\tfloat rSpecular = mix(g_rSpecular, 1.0, uFresnel);\n\t\t\t\t\tr *= 4.0 * rSpecular * gRayDotHalf * gDotReflect / (gVisRcp * gDotHalf);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t// NOTE a break here makes the AMD compiler on Windows unhappy\n\n\t\t\t\t\tr = 0.0;\n\t\t\t\t\tposRay = vec3(0.0, 0.0, g_zMax * 10.0);\n\t\t\t\t\tnormalRay = vec3(0.0, 0.0, 1.0);\n\t\t\t\t}\n\t\t\t}\n\n#else // !ENABLE_IS\n\t\t\t// BB This works ok for our low roughness values, but for rougher materials would want\n\t\t\t//\tsomething better, e.g. an analytic approximation to the pre-integrated ambient\n\t\t\t//\tspecular BRDF LUT in Karis's notes.\n\n\t\t\tnormalReflect = reflect(normalRay, hit.m_normal);\n\t\t\tr *= mix(g_rSpecular, 1.0, UFresnel(saturate(dot(normalReflect, hit.m_normal))));\n#endif // !ENABLE_IS\n\n\t\t\tposRay = posHit + normalReflect * 10.0;\n\t\t\tnormalRay = normalReflect;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tfloat rFog = RFog(1e10, posRay, normalRay);\n\t\t\trgbLight += (1.0 - rFog) * r * RgbFog(normalRay);\n\t\t\tr *= rFog;\n\n\t\t\t// Sun + sky\n\t\t\t// BB Just hacking here, can probably be simplified a bunch.\n\n\t\t\tfloat gDotLight = dot(normalRay, g_normalLight);\n\n\t\t\tvec3 vecPerp = normalRay - gDotLight * g_normalLight;\n\n\t\t\tfloat gPerpDistSqr = dot(vecPerp, vecPerp);\n\t\t\tfloat rGlow = 20.0;\n\n\t\t\tbool fDrawSun = true;\n#if !ENABLE_IS\n\t\t\tfDrawSun = (iBounce == 0);\n#endif\n\n\t\t\tif (fDrawSun &&\n\t\t\t\tgDotLight > 0.0 &&\n\t\t\t\tgPerpDistSqr < GSqr(RLightCone() * rGlow * gDotLight))\n\t\t\t{\n\t\t\t\tfloat gSunLum = GLuminance(RgbSunDisc());\n\t\t\t\tfloat gK = 0.1;\n\t\t\t\tgSunLum /= gK + gSunLum;\n\t\t\t\tfloat gNewLum = gSunLum * GSqr(smoothstep(\n\t\t\t\t\t\t\t\t\t\t\t(RLightCone() * rGlow),\n\t\t\t\t\t\t\t\t\t\t\tRLightCone() * 1.0,\n\t\t\t\t\t\t\t\t\t\t\tlength(vecPerp)));\n\t\t\t\tgNewLum *= gK / (1.0 - gNewLum);\n\n\t\t\t\tfloat rSun = r;\n\n#if FULL_STRENGTH_SUN\n\t\t\t\trSun = 1.0;\n#endif\n\n\t\t\t\tif (iBounce > 0)\n\t\t\t\t{\n\t\t\t\t\trSun *= g_rSunSpecScale;\n\t\t\t\t}\n\n\t\t\t\trgbLight += rSun * gNewLum / GLuminance(RgbSunDisc()) * RgbSunDisc();\n\t\t\t}\n\n\t\t\trgbLight += r * RgbSky();\n\n\t\t\tfloat u = saturate(\n\t\t\t\t\t\t-gDotLight / (GDotLightCone() + 1.0) + 1.0 / (1.0 / GDotLightCone() + 1.0));\n\t\t\tfloat g = u / max(1.0 - u, 1e-8);\n\t\t\tfloat rHaze = exp(-g * 10.0);\n\t\t\trHaze += rHaze * (1.0 + rHaze * (1.0 + rHaze * (1.0 + rHaze)));\n\t\t\trgbLight += r * 0.4 * RgbLight() * rHaze;\n\n\t\t\t// NOTE a break here makes the AMD compiler on Windows unhappy\n\n\t\t\tr = 0.0;\n\t\t\tposRay = vec3(0.0, 0.0, g_zMax * 10.0);\n\t\t\tnormalRay = vec3(0.0, 0.0, 1.0);\n\t\t}\n\t}\n\n#if DEBUG_STEPS\n\treturn vec3(float(cStepTotal) / 100.0);\n#endif\n\n\treturn rgbLight;\n}\n\nvoid mainImage(out vec4 o_rgbaColor, in vec2 xyPixel)\n{\n#if TILED_RENDER\n\txyPixel += iOffset;\n#endif\n\n\tg_t = iTime;\n\tvec3 rgbColor = vec3(0);\n\tfloat gWeightSum = 0.0;\n\n\tg_vecURandomIS = VecHash2(vec2(xyPixel + g_t));\n\tvec2 vecURandomDOF = VecHash2(vec2(xyPixel * g_gPi + g_t * exp(1.0)));\n\tvec2 vecURandomAA = VecHash2(vec2(xyPixel * exp(1.0) + g_t * g_gPi));\n\tfloat uRandomMB = UHash(vec2(xyPixel * sqrt(2.0) + g_t * 0.5 * (1.0 + sqrt(5.0))));\n\n\tfor (int iRay = 0; iRay < RAY_COUNT; ++iRay)\n\t{\n#if CORRELATED_DOF\n\t\tvecURandomDOF = g_vecURandomIS;\n#endif\n\n#if CORRELATED_MB\n\t\tuRandomMB = g_vecURandomIS.x;\n#endif\n\n#if ENABLE_MOTION_BLUR\n\t\tg_t = iTime - uRandomMB * g_dTExposure;\n#endif\n\n\t\tUpdateLightDirection();\n\n\t\tvec3 posView = vec3(-500.0, 0.0, 200.0);\n\t\tvec2 dXyOffset = vec2(0);\n#if RAY_COUNT > 1\n\t\tdXyOffset = vecURandomAA - 0.5;\n#endif\n\t\tvec2 xyPixelOffset = (xyPixel.xy + dXyOffset);\n\t\tvec2 uvScreen = xyPixelOffset / iResolution.xy;\n\t\tvec3 normalCm = vec3(1.0, 0.0, 0.0);\n\t\tvec2 vecAspect = vec2(-1.0, iResolution.y / iResolution.x);\n\t\tfloat gFov = 0.9;\n\t\tnormalCm.yz = (uvScreen * 2.0 - 1.0) * vecAspect * gFov;\n\n#if ENABLE_DOF\n\t\tvec2 vecDisc = VecDisc(vecURandomDOF);\n\t\tnormalCm.yz += vecDisc * g_rDOFScale;\n\t\tposView.yz += vecDisc * g_rDOFScale * posView.x;\n#endif\n\n\t\tnormalCm = VecRotateY(normalCm, g_radTiltCamera);\n\n\t\t// Lens distortion\n\n\t\tnormalCm.yz *= 5.0 / (5.0 + dot(normalCm.yz, normalCm.yz));\n\n\t\tnormalCm = normalize(normalCm);\n\n\t\tvec3 rgbHit = RgbIntersectScene(posView, normalCm);\n\t\tfloat gLum = GLuminance(rgbHit);\n\t\tfloat gWeight = 1.0 / (1.0 / (g_gISNoiseReduction + 1e-10) + gLum);\n\t\trgbColor += rgbHit * gWeight;\n\t\tgWeightSum += gWeight;\n\n\t\tg_vecURandomIS = VecSubRandom(g_vecURandomIS);\n\t\tvecURandomDOF = VecSubRandom(vecURandomDOF);\n\t\tvecURandomAA = VecSubRandom(vecURandomAA);\n\t\tuRandomMB = VecSubRandom(vec2(uRandomMB)).x;\n\t}\n\n\trgbColor = rgbColor / gWeightSum;\n\n#if DEBUG_STEPS || DEBUG_DIFFUSE || DEBUG_NORMALS || DEBUG_AO || DEBUG_SHADOWS\n\to_rgbaColor.rgb = rgbColor;\n#else\n\to_rgbaColor.rgb = RgbTonemap(rgbColor);\n#endif\n\n\t// Vignette\n\n\to_rgbaColor.rgb *= 1.0 - smoothstep(0.8, 2.6, length((xyPixel.xy / iResolution.xy) * 2.0 - 1.0));\n\n\t// Noise to reduce banding\n\n\to_rgbaColor.rgb += (g_vecURandomIS.x - 0.5) / 255.0;\n\n\to_rgbaColor.a = 1.0;\n}\n","name":"","description":"","type":"image"}]}