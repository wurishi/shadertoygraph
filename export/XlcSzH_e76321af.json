{"ver":"0.1","info":{"id":"XlcSzH","date":"1478010516","viewed":1014,"name":"UE4 - PBR","username":"toffanim","description":"Simple implementation of real-time PBR through IBL WITHOUT PRECOMPUTING THE ENVIRONNEMENT SAMPLING. Light is a simple spheric area light","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["ibl","pbr"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4sfGzn","filepath":"/media/a/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png","previewfilepath":"/media/ap/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// Simple shader implementation of Brian Karis 2013 talk at siggraph : Real Shading in Unreal Engine 4\n// http://blog.selfshadow.com/publications/s2013-shading-course/karis/s2013_pbs_epic_notes_v2.pdf\n//\n// The IBL part is very very rough, not using sampling, just using the fully blured cubemap for roughness = 0\n// The code for blured cubemap is taken from user TDM at : https://www.shadertoy.com/view/XsfXWX\n//\n// The Area Lights is only Spheric for now, maybe I'll add tubular lights later\n//\n// toffanim - 2016\n\n// Mathematical approximation\n#define PI 3.14159\n#define TWO_PI 6.28318\n#define PI_OVER_TWO 1.570796\n#define ONE_OVER_PI 0.318310\n\n//Globals\n#define SPHERE_GRID_NUM_ROWS 7\n#define SPHERE_GRID_NUM_COLS 7\n//\tRay marching parameters\n#define RAY_MARCHING_STEPS 100\n#define RAY_MARCHING_MAX_DISTANCE 20.\n#define RAY_MARCHING_MIN_HIT_VALUE 0.001\n//\tUse cubemap bluring or simply use ShaderToy bluredTexture (iChannel1)\n#define USE_CUBEMAP_BLUR 1\n#define USE_AREA_LIGHT 1\n//\tLight parameters\nconst vec3 LightColor = vec3(1.);\nvec3 LightPosition = vec3( -5, 5, 15 );\nconst float LightRadius = 1.;\n//\tSphere parameters\nconst float SphereRadius = 1.;\nvec3 SphereInitialPosition = vec3(0.);\n//\tCameraVectors\nvec3 Eye = vec3(0.);\nvec3 ForwardVector = normalize( vec3( 0., 0., 1.) );\nvec3 UpVector = normalize( vec3( 0., 1., 0.) );\nvec3 RightVector = normalize( vec3( -1., 0., 0.) );\n\n//Structs\nstruct material\n{\n    float Metallic;\n    float Roughness;\n    vec3 BaseColor;\n};\n           \nstruct map_result\n{\n    float dp;\n    vec3 Normal; \n    material Material;\n};\n    \nstruct hit_result\n{\n    bool Hit;\n    float T;\n    map_result Geometry;\n};\n\n\n#if USE_CUBEMAP_BLUR\n//Shamelessly taken from TDR : https://www.shadertoy.com/view/XsfXWX\nfloat somestep(float t) {\n    return pow(t,4.0);\n} \nvec3 textureAVG(samplerCube tex, vec3 tc) {\n    const float diff0 = 0.35;\n    const float diff1 = 0.12;\n \tvec3 s0 = texture(tex,tc).xyz;\n    vec3 s1 = texture(tex,tc+vec3(diff0)).xyz;\n    vec3 s2 = texture(tex,tc+vec3(-diff0)).xyz;\n    vec3 s3 = texture(tex,tc+vec3(-diff0,diff0,-diff0)).xyz;\n    vec3 s4 = texture(tex,tc+vec3(diff0,-diff0,diff0)).xyz;\n    \n    vec3 s5 = texture(tex,tc+vec3(diff1)).xyz;\n    vec3 s6 = texture(tex,tc+vec3(-diff1)).xyz;\n    vec3 s7 = texture(tex,tc+vec3(-diff1,diff1,-diff1)).xyz;\n    vec3 s8 = texture(tex,tc+vec3(diff1,-diff1,diff1)).xyz;\n    \n    return (s0 + s1 + s2 + s3 + s4 + s5 + s6 + s7 + s8) * 0.111111111;\n}\nvec3 textureBlured(samplerCube tex, vec3 tc) {\n   \tvec3 r = textureAVG(tex,vec3(1.0,0.0,0.0));\n    vec3 t = textureAVG(tex,vec3(0.0,1.0,0.0));\n    vec3 f = textureAVG(tex,vec3(0.0,0.0,1.0));\n    vec3 l = textureAVG(tex,vec3(-1.0,0.0,0.0));\n    vec3 b = textureAVG(tex,vec3(0.0,-1.0,0.0));\n    vec3 a = textureAVG(tex,vec3(0.0,0.0,-1.0));\n        \n    float kr = dot(tc,vec3(1.0,0.0,0.0)) * 0.5 + 0.5; \n    float kt = dot(tc,vec3(0.0,1.0,0.0)) * 0.5 + 0.5;\n    float kf = dot(tc,vec3(0.0,0.0,1.0)) * 0.5 + 0.5;\n    float kl = 1.0 - kr;\n    float kb = 1.0 - kt;\n    float ka = 1.0 - kf;\n    \n    kr = somestep(kr);\n    kt = somestep(kt);\n    kf = somestep(kf);\n    kl = somestep(kl);\n    kb = somestep(kb);\n    ka = somestep(ka);    \n    \n    float d;\n    vec3 ret;\n    ret  = f * kf; d  = kf;\n    ret += a * ka; d += ka;\n    ret += l * kl; d += kl;\n    ret += r * kr; d += kr;\n    ret += t * kt; d += kt;\n    ret += b * kb; d += kb;\n    \n    return ret / d;\n}\n#endif    \n    \n    \n// Geometry definition and resolution through RayMarching\nfloat Sphere( vec3 p, float r )\n{\n    return ( length(p) - r );   \n}\n\nmap_result Map( vec3 p )\n{\n    //Grid layout of spheres\n    // Metallic on Y axis\n    // Roughness on X axis\n    vec3 SpherePosition = SphereInitialPosition;\n    //\tCompute steps for spheres spacing and metallic/roughness value\n    float SphereXStep = (SphereRadius * float(SPHERE_GRID_NUM_COLS+10)) / float(SPHERE_GRID_NUM_COLS);\n    float SphereYStep = (SphereRadius * float(SPHERE_GRID_NUM_ROWS+10)) / float(SPHERE_GRID_NUM_COLS);\n    float MetallicStep = 0.9 / float(SPHERE_GRID_NUM_COLS);\n    float RoughnessStep = 0.9 / float(SPHERE_GRID_NUM_ROWS);\n    \n    map_result Result;\n    Result.dp = RAY_MARCHING_MAX_DISTANCE;\n    Result.Material.BaseColor = vec3(1.,0.,0.);\n    Result.Material.Metallic = 0.1;\n    Result.Material.Roughness = 0.1;\n    \n    float NewDp;\n    for ( int i = 0; i < SPHERE_GRID_NUM_COLS; ++i)\n    {\n        SpherePosition = SphereInitialPosition - 10. * UpVector;\n        SpherePosition -= float(i) * SphereXStep * RightVector;\n        for ( int j = 0; j < SPHERE_GRID_NUM_ROWS; ++j )\n        {\n            SpherePosition += SphereYStep * UpVector;\n            NewDp = Sphere( p - SpherePosition, SphereRadius );\n            if(Result.dp > NewDp)\n            {\n                Result.dp = NewDp;\n                Result.Normal = normalize(p - SpherePosition); \n                Result.Material.Metallic = 0.1 + float(j) * MetallicStep;\n                Result.Material.Roughness = 0.1 + float(i) * RoughnessStep;\n            }\n         }\n    }\n    \n    #if USE_AREA_LIGHT\n    NewDp = Sphere( p - LightPosition, LightRadius );\n    if ( Result.dp > NewDp )\n    {\n        Result.dp = NewDp;\n        Result.Normal = normalize( p - LightPosition );\n        Result.Material.Metallic = 0.001;\n        Result.Material.Roughness = 1.;\n        Result.Material.BaseColor = vec3(10.,10.,10.);\n    }    \n    #endif\n    return (Result) ;  \n}\n\nhit_result March(vec3 ro, vec3 rd)\n{\n    hit_result Result;\n    Result.Hit = false;\n    Result.T = 0.0;\n    map_result MapResult;\n    \n    for(int i=0; i<RAY_MARCHING_STEPS; ++i)\n    {\n        MapResult = Map(ro+rd*Result.T);\n        if(abs(MapResult.dp)<RAY_MARCHING_MIN_HIT_VALUE){Result.Hit=true; break;}\n        if(Result.T>RAY_MARCHING_MAX_DISTANCE) break;\n        Result.T += MapResult.dp;\n        Result.Geometry = MapResult; \n    }    \n    return (Result) ;\n}\n\nfloat D_GGX_AreaLight( float NDotH, float Alpha, float AlphaPrim )\n{\n    float AlphaSqr = Alpha*Alpha;\n    float GGXNormalizationFactor = (1. / AlphaSqr) * ONE_OVER_PI;\n    float GGXNormalizationFactorSqr = GGXNormalizationFactor * GGXNormalizationFactor ;\n    float AlphaPrimSqr = AlphaPrim * AlphaPrim;\n    float SphereNormalization = AlphaPrimSqr / GGXNormalizationFactorSqr;\n\tfloat OneOverDenominator = 1. / ( (NDotH * NDotH) *(AlphaSqr - 1.0) + 1.0 );\n\tfloat Result = SphereNormalization * OneOverDenominator * OneOverDenominator;\n    return(Result);\n}\n\nfloat D_GGX( float NDotH, float Alpha )\n{\n    float AlphaSqr = Alpha*Alpha;\n\tfloat OneOverDenominator = 1. / ( (NDotH * NDotH) *(AlphaSqr - 1.0) + 1.0 );\n\tfloat Result = AlphaSqr * OneOverDenominator * OneOverDenominator * ONE_OVER_PI;\n    return(Result);\n}  \n\nfloat G1V ( float NDotV, float K ) {\n\treturn NDotV / (NDotV*(1.0 - K) + K);\n}\n\nfloat G_Schlick( float NDotL, float NDotV, float Alpha )\n{\n    // Disney remapping Roughness only if we are using area lights\n    //float Roughness = (roughness +1.)/2.;\n    //float Alpha = Roughness * Roughness;\n    float K = Alpha / 2.0;\n\tfloat Result = G1V (NDotL, K) * G1V (NDotV, K);\n    return(Result);\n}\n\nfloat F_Schlick( float VDotH, float F0 )\n{\n    float Exponent = ( -5.55473*VDotH -6.98316) * VDotH;\n    float Result = F0 + (1.0 - F0) * pow(2., Exponent);\n    return(Result);\n}\n\nfloat Specular_CookTorrance(vec3 N, vec3 V, vec3 L, float Roughness, float AlphaPrim, float F0) {\n    // Disney remapping of alpha\n    float Alpha = Roughness*Roughness;\n\tvec3 H = normalize (V + L);\n\n\tfloat NDotL = clamp (dot (N, L), 0.0, 1.0);\n\tfloat NDotV = clamp (dot (N, V), 0.0, 1.0);\n\tfloat NDotH = clamp (dot (N, H), 0.0, 1.0);\n\tfloat LDotH = clamp (dot (L, H), 0.0, 1.0);\n    float VDotH = clamp (dot (V, H), 0.0, 1.0);\n    \n    // NDF : GGX/Trowbridge-Reitz\n    #if USE_AREA_LIGHT\n    float D = D_GGX_AreaLight(NDotH, Alpha, AlphaPrim);\n    #else\n    float D = D_GGX(NDotH, Alpha);\n    #endif\n    \n    // Visibility term (G) : Smith with Schlick's approximation\n    float G = G_Schlick( NDotL, NDotV, Alpha );\n       \n    // Fresnel (Schlick)\n    float F = F_Schlick(VDotH, F0);\n\n\n\treturn (D * F * G);\n}\n\nvec3 Lambert( vec3 Color )\n{\n    // See https://seblagarde.wordpress.com/2012/01/08/pi-or-not-to-pi-in-game-lighting-equation/\n    // as to why I'm not dividing by PI\n    return( Color );   \n}\n\n\nvec3 Shade( vec3 Eye, vec3 View, hit_result HitResult )\n{\n    vec3 FragWorldPosition = (Eye + View * HitResult.T);\n    vec3 Normal = HitResult.Geometry.Normal;\n    material Material = HitResult.Geometry.Material;\n\n    // IBL\n    // This is where we should precompute the environnement sampling using Hammersley and ImportanceSamplingGGX\n    // but for demo pursposes I'm using the shadertoy given blurred cubemap as my roughness = 0\n    // Or you can use the code prodived to fully blured the EnvironementMap before use\n    #if USE_CUBEMAP_BLUR\n    vec3 IBLMinRoughnessColor = textureBlured(iChannel1, reflect(View,Normal));\n    vec3 IBLMaxRoughnessColor = texture(iChannel0, reflect(View,Normal)).xyz;\n    #else\n    vec3 IBLMinRoughnessColor = texture(iChannel1, reflect(View,Normal)).xyz;\n    vec3 IBLMaxRoughnessColor = texture(iChannel0, reflect(View,Normal)).xyz;\n    #endif\n    // Lambertian diffuse model\n    vec3 IBLMinMetallicColor = Lambert(Material.BaseColor);   \n    vec3 IBLDiffuse = IBLMinMetallicColor;\n    vec3 IBLSpecular = mix(IBLMaxRoughnessColor,IBLMinRoughnessColor,Material.Roughness);\n    //Fresnel term to darken the edges\n    float FresnelTerm = max(1.0 - dot(Normal,-View), 0.0);\n    FresnelTerm = pow(FresnelTerm, Material.Roughness +1.5);\n    IBLDiffuse = mix(IBLDiffuse, IBLSpecular, FresnelTerm);\n    vec3 FinalIBL = mix(IBLDiffuse, IBLSpecular, Material.Metallic);  \n\n    // Spheric Area Light Specular\n    vec3 L = LightPosition - FragWorldPosition;\n    float RoughnessPrim = clamp( ((1./Material.Roughness) * ONE_OVER_PI)  + LightRadius / (2. * length( L )) , 0., 1.);\n    #if USE_AREA_LIGHT\n    vec3 r = reflect(-View, Normal);\n    vec3 centerToRay = dot( L, r ) * r - L;\n    vec3 closestPoint = L + centerToRay * clamp( LightRadius / length(centerToRay) ,0., 1.);\n    vec3 l = normalize(closestPoint);\n    #else\n    vec3 l = LightPosition;\n    #endif\n    vec3 LightSpecular = LightColor * Specular_CookTorrance(Normal,-View,l,Material.Roughness, RoughnessPrim, 0.2);      \n\n    vec3 Result = FinalIBL + LightSpecular;\n    return (Result);   \n}\n\nvoid RotateCameraVectors( mat3 Rotation )\n{\n    //Rotate all camera vectors to do billboarding of the grid\n    ForwardVector = ForwardVector * Rotation;\n    UpVector = UpVector * Rotation;\n    RightVector = RightVector * Rotation;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t// Screen coordinates  \n    vec2 P = (2.0*fragCoord - iResolution.xy) / iResolution.y;\n    \n    vec3 View = normalize(vec3( P, 1.0 ));\n    \n    \n    // Scene rotation\n    float c = cos(iTime);\n    float s = sin(iTime);   \n    mat3 YRotationMatrix = mat3( vec3( c, 0., s ), \n                                vec3( 0., 1., 0. ), \n                                vec3( -s, 0., c) );\n    View = View * YRotationMatrix;\n    RotateCameraVectors( YRotationMatrix );\n    //LightPosition *= s * c * YRotationMatrix;\n    \n    // Billboarding of the grid\n    SphereInitialPosition = Eye + ForwardVector * 10.0;\n    SphereInitialPosition += 8. * RightVector;\n    \n    // Ray marching\n    hit_result HitResult  = March( Eye,  View);\n    \n    // Shading\n    vec3 Color = vec3(0.);\n    if( HitResult.Hit )\n    {\n        Color = Shade( Eye, View , HitResult );\n    }\n    else\n        Color = texture(iChannel0, View).xyz;\n    \n\tfragColor = vec4(Color,1.0);\n}","name":"Image","description":"","type":"image"}]}