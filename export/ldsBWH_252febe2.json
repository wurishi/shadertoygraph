{"ver":"0.1","info":{"id":"ldsBWH","date":"1496092830","viewed":97,"name":"raym donuts infinite","username":"anclin","description":"raym donuts infinite","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["raymdonutsinfinite"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float EPSILON = 0.0001;\nconst float MAX_DIST = 100.0;\n\nfloat remap(float low1, float high1, float low2, float high2, float value){\n    return low2 + (value - low1) * (high2 - low2) / (high1 - low1);\n}\n\n/**\n * Rotation matrix around the Y axis.\n */\nmat3 rotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, 0, s),\n        vec3(0, 1, 0),\n        vec3(-s, 0, c)\n    );\n}\n\n/**\n * Constructive solid geometry intersection operation on SDF-calculated distances.\n */\nfloat intersectSDF(float distA, float distB) {\n    return max(distA, distB);\n}\n\n/**\n * Constructive solid geometry union operation on SDF-calculated distances.\n */\nfloat unionSDF(float distA, float distB) {\n    return min(distA, distB);\n}\n\n/**\n * Constructive solid geometry difference operation on SDF-calculated distances.\n */\nfloat differenceSDF(float distA, float distB) {\n    return max(distA, -distB);\n}\n\nfloat SphereSDF(vec3 p, float size){\n\treturn length(p) - size;\n}\n\nfloat CubeSDF(vec3 p, vec3 size){\n    vec3 d = abs(p) - size;\n    \n    float insideDistance = min( max(max(d.x, d.y),d.z), 0.0);\n    \n    float outsideDistance = length( max(d, 0.0) );\n    \n    return insideDistance + outsideDistance;\n}\n\nfloat TorusSDF( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n\n\n\nfloat SceneSDF(vec3 p){\n    \n    p = rotateY(iTime * 0.2) * p;\n    \n    float gap = 1.75;\n    \n    p.x = mod(p.x + gap, 2.0 * gap) - gap;\n    p.z = mod(p.z + gap, 2.0 * gap) - gap;\n    \n\tfloat torus = TorusSDF(p, vec2(1,0.5));\n    return torus;\n}\n\n\n\n\nvec3 EstimateNormal(vec3 p){\n\treturn normalize(vec3(\n        SceneSDF(vec3(p.x+EPSILON, p.y, p.z)) - SceneSDF(vec3(p.x-EPSILON, p.y, p.z)),\n        SceneSDF(vec3(p.x, p.y+EPSILON, p.z)) - SceneSDF(vec3(p.x, p.y-EPSILON, p.z)),\n        SceneSDF(vec3(p.x, p.y, p.z+EPSILON)) - SceneSDF(vec3(p.x, p.y, p.z-EPSILON))\n        ));\n}\n\n/**\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        SceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - SceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        SceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - SceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        SceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - SceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\nvec3 RayDirection(float fieldOfView, vec2 fragCoord, vec2 size){\n\tvec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\nfloat ShortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end){\n\tfloat depth = start;\n    for(int i = 0; i < 255; i++){\n    \tfloat dist = SceneSDF(eye + depth * marchingDirection);\n        if( dist <= EPSILON){\n            return depth;\n        }\n        depth += dist;\n        if(depth >= end){\n        \treturn end;\n        }\n    }\n    return end;\n}\n\n/**\n * Return a transform matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat4 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat4(\n        vec4(s, 0.0),\n        vec4(u, 0.0),\n        vec4(-f, 0.0),\n        vec4(0.0, 0.0, 0.0, 1)\n    );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 rayDir = RayDirection(45.0, fragCoord.xy, iResolution.xy);\n    \n    vec3 eye = vec3(0.0 + 0.0 * cos(iTime),\n                    12.0 + 0.0 * sin(iTime),\n                    40.0 + 0.0 * sin(iTime));\n    \n    vec3 lookAtPos = vec3(3.0 + 0.0 * cos(iTime),\n                          0.0 + 0.0 * sin(iTime/2.0),\n                          -3.0 + 0.0 * sin(iTime));\n    \n    mat4 viewToWorld = viewMatrix(eye, lookAtPos, vec3(0,1,0) );\n    vec3 worldDir = ( viewToWorld * vec4(rayDir,0) ).xyz;\n    \n    float dist = ShortestDistanceToSurface(eye, worldDir, 0.0, 100.0);\n    \n    vec3 ambientColor = vec3(0.5, 0.3, 0.3);\n    vec3 color = vec3(1,0,0);\n    \n    //vec3 lightPos = vec3(0.5, 0.5, 0.5);\n    vec3 lightPos = vec3(4.0 * sin(iTime),\n                         6.0,\n                         4.0 * cos(iTime));\n    \n    \n    vec3 lightDirection = normalize(-lightPos);\n    \n    vec3 p = eye + dist * worldDir;\n    vec3 normal = estimateNormal(p);\n    float diffuse = dot(normal, -lightDirection);\n    diffuse = max(diffuse, 0.0);\n    \n    vec3 finalColor = vec3(0);\n    \n    if( dist < MAX_DIST){\n    \tfinalColor = (normal + vec3(1.0)) / 2.0;\n        //finalColor = finalColor * (diffuse + ambientColor);\n        finalColor = finalColor * remap(60.0, 20.0, 0.0, 1.0, dist);\n    }\n    \n\tfragColor = vec4(finalColor,1);\n}","name":"Image","description":"","type":"image"}]}