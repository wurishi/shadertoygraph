{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[],"code":"// by Austin Lancaster\n// pFrieze() uses code by FabriceNeyret2 found at https://www.shadertoy.com/view/ll2fWG\n\n\n#define PI 3.14159265359\n#define DURATION 4.0\n\nvec2 offset = vec2(0.0);\nvec3 col1;\nvec3 col2;\nbool jumper = true;\n\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat random() {\n\toffset.x+=1.0;\n    return rand(offset);\n}\n\nmat2 scale(vec2 _scale)\n{\n    return mat2(_scale.x,0.0,\n                0.0,_scale.y);\n}\n\nmat2 rotate2d(float _angle){\n    return mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle));\n}\n\nvec2 tile (vec2 uv)\n{\n    float cols = 3.0;\n    float rows = 2.0;\n    uv.x *= cols;\n    uv.y *= rows;\n    offset = floor(uv)+floor(iTime / DURATION)*2.0;\n    uv = fract(uv);\n    uv.x -= ((iResolution.x/cols-iResolution.y/rows)/(iResolution.x/cols))/rows;\n    return scale(vec2((iResolution.x/cols)/(iResolution.y/rows), 1.0)) * uv;   \n}\n\nvec2 jumper_space (vec2 uv)\n{\n    uv -= vec2(0.5);\n    uv *= vec2(1.7, 1.2);\n    uv.y -= 0.075*(-0.5 + pow(abs(uv.x), 2.0));\n    uv += vec2(0.5);\n    \n    // hem\n    float s2 = 0.2;\n    float s1 = 0.1;\n    if (uv.y < s2 && uv.y >= 0.0) {\n        uv.x -= 0.5;\n        float xsign = sign(uv.x);\n        uv.x = abs(uv.x);\n        float h = uv.y / s2;\n        uv.x += 0.1*(1.0 - pow(h, 0.25));\n        uv.x *= xsign;\n        uv.x += 0.5;\n    }\n    if (uv.y < s1 && uv.y >= 0.0 && uv.x < 1.0 && uv.x > 0.0) {\n        uv.y = 0.01;\n        uv.x = 0.5;\n    }\n    \n    // collar\n    vec2 c_uv = uv;\n    c_uv.x -= 0.5;\n    c_uv.x = abs(c_uv.x);\n    float height = 0.15;\n    float h = (c_uv.y - (1.0-height))/height;\n    c_uv.x *= 4.0;\n\n    float y = pow(c_uv.x, 2.0);\n    c_uv.x *= 0.5;\n    float y2 = 2.9*pow(c_uv.x, 2.0);\n    if (h > y) {\n\t\tuv = vec2(-1.0);\n    } else if (h > y2 - 0.3 && uv.y < 1.0) {\n       uv.y = 0.01;\n       uv.x = 0.5;\n    }\n    \n    return uv;\n}\n\nvec2 sleeve_space (vec2 uv)\n{\n    uv.x -= 0.5;\n    uv.x = abs(uv.x);\n    uv.x += 0.5;\n    \n    uv -= vec2(0.5);\n    uv = rotate2d(PI/8.0) * uv;\n    uv = scale(vec2(5.0, 1.3)) * uv;\n    uv.x *=0.5;\n    uv += vec2(0.5)-vec2(1.65*0.5, -0.145);\n    \n    uv.x-=0.5;\n    uv.y -= 0.075*(-0.5 + pow(abs(uv.x), 2.0));\n    uv.x+=0.5;\n    \n    // sleeve\n    float s2=0.35;\n    float s1=0.15;\n    \n    if (uv.y < s2 && uv.y >= 0.0) {\n        uv.x-=0.5;\n        float xsign = sign(uv.x);\n        uv.x = abs(uv.x);\n        float h = (uv.y / s2) * PI;\n        uv.x+=0.2*0.5*0.5*(cos(h) + 1.0);\n        uv.x*=xsign;\n        uv.x+=0.5;\n    }\n    if (uv.y < s1 && uv.y >= 0.0 && uv.x < 0.75 && uv.x > 0.25) {\n        uv.y = 0.01;\n        uv.x = 0.5;\n    }\n        \n\treturn uv;\n}\n\nbool insideBox (vec2 uv, vec2 scale)\n{\n \treturn abs(uv.x-0.5)<0.5*scale.x && abs(uv.y-0.5)<0.5*scale.y;   \n}\n\nbool insideBox (vec2 uv)\n{\n    \n\treturn insideBox(uv, vec2(1.0, 1.0));\n}\n\nvec3 getColor() {\n\tvec3 col = 0.1+0.7*vec3(random(), random(), random());\n    \n    vec3 sepia = vec3((col.r * .393) + (col.g *.769) + (col.b * .189),\n                (col.r * .349) + (col.g *.686) + (col.b * .168),\n                (col.r * .272) + (col.g *.534) + (col.b * .131));\n    return mix(col, sepia, 0.6 + 0.4*random());\n}\n\nvoid pickTwoColors() {\n    col1 = getColor();\n    col2 = getColor();\n    \n    // ensure a minimum constrasst\n    float min_contrast = 0.15;\n    vec3 col_diff = col1-col2;\n    if (length(col_diff)< min_contrast) {\n    \tcol_diff /= length(col_diff);\n        col_diff *= min_contrast;\n        col2 = col1-col_diff;\n    }\n}\n\nvec3 pFrieze(vec2 uv) {\n\tuv.y = dot( cos( 3.* ceil(uv.y*2.0 + random()*2.0) * max(0.,.5-length(uv = fract(uv)-.5)) - vec2(33,0) ), uv);\n    return mix(col1, col2, step(0.0, uv.y));\n}\n\nvec3 pLines(vec2 uv) {\n    return vec3(0.0);\n}\n\nvec3 pJagged(vec2 uv) {\n    vec3 col;\n    float h = abs(uv.x-0.5)*2.0;\n    float a = step(h, uv.y);\n    col = mix(col2, col1, a);\n\treturn col;   \n}\n\nvec3 pZigzag(vec2 uv) {\n    float thickness = 0.1+random()*0.15;\n\tvec3 col;\n    float h = abs(uv.x-0.5)*2.0*(1.0-2.0*thickness) + thickness;\n    float a = step(h+thickness, uv.y);\n    float b = 1.0-step(h-thickness, uv.y);\n    col = mix(col2, col1, a+b);\n\treturn col; \n}\n\nvec3 pWave(vec2 uv) {\n    float thickness = 0.2;\n    vec3 col;\n    float h = sin(uv.x*PI*2.0)*0.5+0.5;\n    h *= 1.0-2.0*thickness;\n    h += thickness;\n    float a = step(h+thickness, uv.y);\n    float b = 1.0-step(h-thickness, uv.y);\n    col = mix(col2, col1, a+b);\n\treturn col;   \n}\n\nvec3 pTexture(vec2 uv) {\n    float thickness = 0.1+random()*0.15;\n\tvec3 col;\n    float h = sin(PI*4.0*uv.x);\n    float a = step(h+thickness, uv.y);\n    float b = 1.0-step(h-thickness, uv.y);\n    col = mix(col2, col1, a+b);\n\treturn col; \n \t   \n}\n\nfloat pfCos(float a) {\n    float selector = random();\n    float middle = random()*0.7;\n    return middle + (1.0 - middle)*cos(a*(4.0+4.0*step(0.5, selector)) + PI);\n}\n\nfloat pfCog(float a) {\n    float selector = random();\n    float middle = random()*0.7;\n    return max(middle, cos(a*(4.0+4.0*step(0.5, selector)) + PI));\n}\n\nfloat pfCircle(float a) {\n \treturn 0.1 + 0.8*random();\n}\n\nvec3 pPolar(vec2 uv) {\n    uv = vec2(0.5)-uv;\n    float r = length(uv)*2.0;\n    float a = atan(uv.y,uv.x);\n    float f = pfCog(a);\n    float x = step(f,r);\n    vec3 col;\n    col = mix(col2, col1, x);\n    return col;\n}\n\nvec3 chooseP(vec2 uv) {\n\tfloat selector = random();\n    if (selector < 0.5) {\n        return pPolar(uv);\n    } else if (selector < 0.6) {\n\t\treturn pJagged(uv); \t\n    } else if (selector < 0.7) {\n        return pZigzag(uv);\n    } else if (selector < 0.85) {\n        return pWave(uv);\n    } else {\n        return pFrieze(uv);\n    }\n}\n\nvec3 lStripe(vec2 uv) {\n    vec3 col;\n    float x;\n    if (random() < 0.5) {\n        x = 0.5;\n    } else {\n        x = random()*0.8 + 0.1;\n    }\n    if (uv.y > x) {\n        col = col1;\n    } else {\n        col = col2;\n    }\n    return col;\n}\n\n// l for giving random angle?\n\n// l with own selector for square patterns\n\n// repeat pattern horizontally\nvec3 lRepeatH(vec2 uv) {\n    float repeats = 4.0 + random()*4.0;\n\tuv.x *= repeats;\n    uv.x = fract(uv.x);\n    float sel = random();\n    return chooseP(uv);\n}\n\nvec3 mFullStripe(vec2 uv)\n{\n    float min = 2.0; float median = 5.0; float max = 14.0;\n    uv.y += random();\n    float selection = random();\n    float rows;\n    if (selection < 0.5) {\n        selection *= 2.0;\n        rows = floor(selection*(median - min) + min);\n    } else {\n        selection = (selection-0.5)*2.0;\n    \trows = floor(selection*(max - median) + median);        \n    }\n    uv.y = fract(uv.y*rows);\n    return lStripe(uv);\n}\n\nvec3 mMultipleStripe(vec2 uv)\n{\n    uv.y += random();\n    float old_y = uv.y;\n    float n = floor(2.0+random()*2.0);\n    float thickness = 0.04+random()*0.09; //0.07+random()*0.06; polar\n    uv.y = fract(uv.y*(1.0/thickness));\n    float modVal = mod(floor(old_y*(1.0/thickness)),n); // TODO: check that this behaves properly with other offset changes\n    offset += modVal; \n    for (float i = 0.0; i<1.0; i+=1.0/n)\n    if (modVal > i) {\n    \tpickTwoColors();\n    }\n    return lRepeatH(uv);\n}\n\nvec3 mOneStrip(vec2 uv)\n{\n    float height;\n    if (jumper) {\n        height = 0.6;\n    } else {\n        uv.y *= 1.25;\n        height = 0.25;\n    }\n    uv.y -= height;\n    uv.y = clamp(uv.y*8.0, -0.1, 1.1);\n    \n    return lRepeatH(uv);\n}\n\nvec3 mCurved(vec2 uv)\n{\n    return vec3(0.0);\n}\n\nvec3 mFancyStrip(vec2 uv)\n{\n    float height; float scale; float sel = random();\n    if (jumper) {\n        height = 0.45;\n        scale = 3.0;\n    } else {\n        uv.y *= 1.25;\n        height = 0.25;\n        scale = 12.0;\n    }\n    uv.y -= height;\n    uv.y = clamp(uv.y*scale, -0.001, 1.0);\n    if (jumper) {\n        if (abs(uv.y-0.5)>0.25) {\n            // edge stripes\n            uv.y-=0.5;\n            uv.y*=4.0;\n            uv.y=abs(uv.y);\n            uv.y-=1.0;\n            \n            if (sel > 0.5) {\n                // extra stripe\n                uv.y=uv.y*2.0;\n                if (uv.y > 1.0) {\n                    uv.y -= 1.0;   \n                }\n            }\n        } else {\n            // middle stripe\n            pickTwoColors();\n            uv.y-=0.5;\n            uv.y*=2.0;\n            uv.y+=0.5;\n        }        \n    }\n    return lRepeatH(uv);\n}\n\nvec3 mOneDot(vec2 uv) {\n    uv -= 0.5;\n    uv.y *= 1.7/1.2; // matches with jumper space scaling\n    uv *= 1.2;\n    uv += 0.5;\n    \n    if (random() < 0.5) {\n        // break into 4\n     \tuv -= 0.5;\n        uv *= 2.0;\n        uv = abs(uv);\n    }\n\n    if (jumper) {\n \t\treturn chooseP(uv);\n    } else {\n        return col1;\n    }\n}\n\nvec3 chooseM(vec2 uv) {\n    float sel = random();\n    vec3 col;\n    if (sel < 0.2) {\n        col = mOneDot(uv);\n    } else if (sel < 0.4) {\n        col = mOneStrip(uv);\n    } else if (sel < 0.6) {\n        col = mMultipleStripe(uv);\n    } else if (sel < 0.8) {\n        col = mFancyStrip(uv);\n    } else {\n        col = mFullStripe(uv);   \n    }\n    return col;\n}\n\nvec3 pattern(vec2 uv) {\n\n    vec3 col;\n    if (uv.y < 0.02){\n        // color trimmings\n        col = col1 + (0.5 - step(1.0, length(col1)))*vec3(0.15);\n    } else {\n        float sel = random();\n        return chooseM(uv);\n    }\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n        \n    vec2 uv = fragCoord/iResolution.xy;\n    uv = tile(uv);\n    vec2 js = jumper_space(uv);\n    vec2 ss = sleeve_space(uv);\n    \n\tpickTwoColors();\n\n    vec3 col = vec3(1.0);\n    \n    if (insideBox(js)) {\n        jumper = true;\n        col = pattern(js);\n    } else {\n        jumper = false;\n    }\n    if (col == vec3(1.0) && insideBox(ss, vec2(0.5, 1.0))) {\n    \tcol = pattern(ss);\n        col *= 0.97;\n    }\n    if (col == vec3(1.0)) {\n        col = vec3(1.0, 1.0, 0.875);\n    }\n    fragColor = vec4(col,1.5);\n}\n\n/*\nTODO:\n1.macropatterns\n\tX stripes\n\tX onedot\n\tX layeredstripes\n\tX strip\n\tX fancy strip\n2. offset repeats (dots only)\n3. increase variety of patterns looking at google image for inspiration\n\tmore half-halfs\n4. bans: \n\tonly dots for onedot\n\tonly lines for fancy offbits\n\nany way to make fancy stripe more continuous with other patterns?\nuneven layeredstripes?\ncurved top-half?\nguaranteed squares?\n\tseparate lines and dots\n*/","name":"Image","description":"","type":"image"},{"outputs":[],"inputs":[],"code":"","name":"Common","description":"","type":"common"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"Mt3yW7","date":"1533690676","viewed":2830,"name":"Op shop jumpers","username":"austinlanc","description":"A collection of procedurally generated jumpers.","likes":71,"published":1,"flags":0,"usePreview":0,"tags":["patterns","vintage","sweater","jumper","clothing"],"hasliked":0,"parentid":"","parentname":""}}