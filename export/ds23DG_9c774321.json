{"ver":"0.1","info":{"id":"ds23DG","date":"1668178379","viewed":96,"name":"Moon Test - Normalmapping","username":"Datablock","description":"Normal mapping test using the moon. <See top of code to apply textures>\nI'm still not exactly sure what method works well.\nThe TBN matrix implementation code is inaccurate, but this one seems to be off as well.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["normalmap","moon","normal","customtexture"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\nFeel free to copy any of the code in this program, none of it is licensed.\n\nwww.dropbox.com -> dl.dropboxusercontent.com\n\n1] 1024 x 512\ngShaderToy.SetTexture(0, {mSrc:'https://dl.dropboxusercontent.com/s/ldc1k98x9v84k7u/albedo.jpg?dl=0', mType:'texture', mID:1, mSampler:{ filter: 'linear', wrap: 'repeat', vflip:'true', srgb:'true', internal:'byte' }});\ngShaderToy.SetTexture(1, {mSrc:'https://dl.dropboxusercontent.com/s/m47n0ronw7u396h/normal.jpg?dl=0', mType:'texture', mID:1, mSampler:{ filter: 'linear', wrap: 'repeat', vflip:'true', srgb:'true', internal:'byte' }});\n\n2] 8192 x 4096\ngShaderToy.SetTexture(0, {mSrc:'https://dl.dropboxusercontent.com/s/slkn4u4gzk3jtql/albedo4k.jpg?dl=0', mType:'texture', mID:1, mSampler:{ filter: 'linear', wrap: 'repeat', vflip:'true', srgb:'true', internal:'byte' }});\ngShaderToy.SetTexture(1, {mSrc:'https://dl.dropboxusercontent.com/s/ykyg30p0s4xbbqc/normal4k.jpg?dl=0', mType:'texture', mID:1, mSampler:{ filter: 'linear', wrap: 'repeat', vflip:'true', srgb:'true', internal:'byte' }});\n\n3] 8192 x 4096 With more accurate albedo texture\ngShaderToy.SetTexture(0, {mSrc:'https://dl.dropboxusercontent.com/s/zpiz5knbbzuyfld/albedo4k_true.jpg?dl=0', mType:'texture', mID:1, mSampler:{ filter: 'linear', wrap: 'repeat', vflip:'true', srgb:'true', internal:'byte' }});\ngShaderToy.SetTexture(1, {mSrc:'https://dl.dropboxusercontent.com/s/ykyg30p0s4xbbqc/normal4k.jpg?dl=0', mType:'texture', mID:1, mSampler:{ filter: 'linear', wrap: 'repeat', vflip:'true', srgb:'true', internal:'byte' }});\n\nCopy the two javascript commands under 1], 2] or 3] into the console.\n<The console is accesable with F12 on the keyboard or right click and -inspect- >\n\n*/\n\nconst vec3  ballPos = vec3(0.0, 0.0, 100.0);\nconst float ballRad = 5.0;\n\nconst float ballRadiusSquared = ballRad*ballRad;\n\nconst vec3 camPosConst = vec3(3.0, -2.0, -5.0);\n\nconst float aspectRatio = 16.0/9.0;\n\nvec3 getColor(vec2 uv);\nvec3 blend_rnm(vec3 n1, vec3 n2);\nvec3 getNormal(vec3 normal, float rotation);\nvec3 getColorFromTexture(vec3 normal, float rotation, sampler2D texID, float gamma);\nvec3 crossproduct(vec3 a, vec3 b);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float dx = 0.25/iResolution.x;\n    float dy = 0.25/iResolution.y;\n    \n    vec2 uv0 = fragCoord/iResolution.xy;\n    vec2 uv1 = uv0 + vec2( dx, dy);\n    vec2 uv2 = uv0 + vec2(-dx, dy);\n    vec2 uv3 = uv0 + vec2( dx,-dy);\n    vec2 uv4 = uv0 + vec2(-dx,-dy);\n    \n    vec3 color1 = getColor(uv1);\n    vec3 color2 = getColor(uv2);\n    vec3 color3 = getColor(uv3);\n    vec3 color4 = getColor(uv4);\n    \n    vec3 color = (color1 + color2 + color3 + color4) * 0.25;\n    \n    vec3 gammaCorrected = pow(color, vec3(0.4545454545));\n    \n    fragColor = vec4(gammaCorrected, 1.0);\n}\n\nvec3 getColor(vec2 uv) {\n    \n    float f = clamp((iMouse.x/iResolution.x-0.1)/0.8, 0.0, 1.0);//sin(iTime * 0.5) * 0.5 + 0.5;\n    \n    float zoom = 1.0 * (1.0 - f) + 9.0 * f;\n    \n    vec2 screenCoords = (uv - 0.5) * 2.0 * vec2(aspectRatio, 1);\n    \n    vec3 dir = vec3(0.0, 0.0, 1.0);\n    vec3 camPos = camPosConst * sqrt(f) + vec3(screenCoords * ballRad * 1.09 / zoom, 0.0);\n    \n    vec3 off = camPos - ballPos;\n    float b = dot(off, dir);\n    float bb = b*b;\n    float c = dot(off, off) - ballRadiusSquared;\n    float d = bb - c;\n    float s = sqrt(d);\n    \n    float dist1 = -b - s;\n    //float dist2 = -b + s;\n    vec3 position = camPos + dir * dist1;\n    vec3 planetNormal = (position - ballPos)/ballRad;\n    float angle = iTime / 5.0;\n    \n    /*\n    \n    vec3 N = planetNormal;\n    vec3 T = -normalize(cross(vec3(0.0, 1.0, 0.0), N));\n    vec3 B = cross(N, T);\n    \n    mat3 tangentToObject = inverse(mat3(T, B, N));\n    vec3 sampledNormal = getColorFromTexture(N, angle, iChannel1, 1.0) * 2.0 - 1.0;\n    sampledNormal *= vec3(1.0, 1.0, 350.0);\n    vec3 normal = normalize(tangentToObject * sampledNormal);\n    \n    */\n    \n    vec3 normal = getNormal(planetNormal, angle);\n    \n    //normal = planetNormal;\n    \n    vec3 textureColor = getColorFromTexture(planetNormal, angle, iChannel0, 2.2);\n    \n    float sunAngle = 4.0;//iTime*0.2;\n    vec3 sunRay = vec3(cos(sunAngle), 0.0, sin(sunAngle));\n    float brightness = dot(sunRay, normal);//min(dot(sunRay, normal), 0.1+dot(sunRay, planetNormal));\n    vec3 sunLightColor = vec3(1.0, 0.98, 0.96);\n    \n    vec3 color = textureColor * brightness * sunLightColor;\n    return max(color, 0.0);\n}\n\nvec3 getColorFromTexture(vec3 normal, float rotation, sampler2D texID, float gamma) {\n    \n    float lon = asin(normal.y)*0.636619772368;\n    float lat = atan(normal.z, normal.x)*0.318309886184 - rotation*0.159154943092;\n    return pow(texture(texID, vec2(lat, lon)*0.5+0.5).rgb, vec3(gamma));\n    \n}\n\nvec3 getNormal(vec3 normal, float rotation) {\n\n    vec3 color = getColorFromTexture(normal, rotation, iChannel1, 1.0) * 2.0 - 1.0;\n    return normalize(blend_rnm(normal, color * vec3(-1.0, 1.0, 6.0)));\n    \n}\n\nvec3 blend_rnm(vec3 n1, vec3 n2) {\n\tn1.z += 1.0001;//If this is just +1.0, a small black singularity appears\n\tn2.xy = -n2.xy;\n    return n1 * dot(n1, n2) - n2*n1.z;\n}\n\n/*\nvec3 blend_rnm(vec3 n1, vec3 n2)\n{\n    \n    vec3 N1 = vec3(n1.z, n1.y, -n1.x); // +90 degree rotation around y axis\n    vec3 N2 = vec3(n1.x, n1.z, -n1.y); // -90 degree rotation around x axis\n    vec3 N3 = vec3(n1.x, n1.y,  n1.z);\n    \n    vec3 r = normalize(n2.x*N1 + n2.y*N2 + n2.z*N3);\n    return r*0.5 + 0.5;\n}\n*/\n\n/*\n    cross(a, b) is a native glsl function so i didn't need this one.\n    vec3 crossproduct(vec3 a, vec3 b) {\n        return vec3(a.y*b.z-a.z*b.y, a.z*b.x-a.x*b.z, a.x*b.y-a.y*b.x);\n    }\n    */\n\n/*\n    Failed Test\n    float xylengthSqrd = N.x*N.x + N.y*N.y;\n    float xylengthInv = 1.0 / sqrt(xylengthSqrd);\n    vec3 O1 = vec3(N.x*N.z, N.y*N.z, -xylengthSqrd) * xylengthInv;\n    vec3 O2 = vec3(-N.y, N.x, 0.0) * xylengthInv;\n    vec3 T = normalize(0.70710678118 * (O1 + O2));\n    */\n\n/*\n    Rotation around y-axis for sphere normals\n    float angle = iTime / 5.0;\n    vec3 planetNormalRotated = vec3(\n     cos(angle)*planetNormal.x + sin(angle)*planetNormal.z,\n                planetNormal.y,\n    -sin(angle)*planetNormal.x + cos(angle)*planetNormal.z);\n    */\n\n/*\n    Projective Projection\n    vec3 camPos = camPosConst;\n    vec3 dir = normalize(vec3(screenCoords, 0.4));\n    float dirangle = -atan((ballPos.y-camPos.y)/(ballPos.z-camPos.z));\n    dir = vec3(\n                   dir.x,\n     cos(dirangle)*dir.y - sin(dirangle)*dir.z,\n     sin(dirangle)*dir.y + cos(dirangle)*dir.z);\n    */\n\n/*\n    Triplanar method\n    vec3 absNormal = abs(normal);\n    vec3 col1 = texture(iChannel0, absNormal.xy).rrr * absNormal.z;\n    vec3 col2 = texture(iChannel0, absNormal.zx).rrr * absNormal.y;\n    vec3 col3 = texture(iChannel0, absNormal.yz).rrr * absNormal.x;\n    return 0.6 + (col1 + col2 + col3) / (absNormal.z + absNormal.y + absNormal.x) * 0.4;\n    */\n\n/*\n    Triplanar method\n    vec3 absNormal = abs(normal);\n    vec3 bW = absNormal;\n\tbW /= bW.x + bW.y + bW.z;\n    \n    vec3 cx = texture(iChannel1, absNormal.yz).rgb * 2.0 - 1.0;\n    vec3 cy = texture(iChannel1, absNormal.zx).rgb * 2.0 - 1.0;\n    vec3 cz = texture(iChannel1, absNormal.xy).rgb * 2.0 - 1.0;\n    \n    cx.z = 1.0;\n    cy.z = 1.0;\n    cz.z = 1.0;\n    \n    cx = blend_rnm(0.5*vec3(normal.zy, 5.0*absNormal.x), cx);\n\tcy = blend_rnm(0.5*vec3(normal.xz, 5.0*absNormal.y), cy);\n\tcz = blend_rnm(0.5*vec3(normal.xy, 5.0*absNormal.z), cz);\n\t\n\tvec3 axisSign = sign(normal);\n\tcx.z *= axisSign.x;\n\tcy.z *= axisSign.y;\n\tcz.z *= axisSign.z;\n    \n    return normalize(cx.zyx * bW.x + cy.xzy * bW.y + cz.xyz * bW.z);\n    */\n","name":"Image","description":"","type":"image"}]}