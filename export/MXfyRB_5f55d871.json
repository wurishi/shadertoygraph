{"ver":"0.1","info":{"id":"MXfyRB","date":"1726327208","viewed":34,"name":"lizard","username":"0x177","description":"the shading is shit","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"l3XGRl","parentname":"raymarching startingpoint"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS 100\n#define MAX_DIST 250.\n#define SURF_DIST .001\n#define TAU 6.283185\n#define PI 3.141592\n\nconst float globalAmbient = 0.4; // how strong is the ambient lightning\nconst float globalDiffuse = 0.8; // how strong is the diffuse lightning\nconst float globalSpecular = 0.0; // how strong is the specular lightning\nconst float globalSpecularExponent = 32.0; // how focused is the shiny spot\nconst vec3 lightPos = vec3(-2.0, -1.0, 0.5); // position of the light source\nconst vec3 lightColor = vec3(0.9, 0.9, 0.68); // color of the light source\nconst vec3 ambientColor = vec3(1.0, 1.0, 1.0); // ambient color\n\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\n\nvec4 boxmap( in sampler2D s, in vec3 p, in vec3 n, in float k )\n{\n    // project+fetch\n\tvec4 x = texture( s, p.yz );\n\tvec4 y = texture( s, p.zx );\n\tvec4 z = texture( s, p.xy );\n    \n    // and blend\n    vec3 m = pow( abs(n), vec3(k) );\n\treturn (x*m.x + y*m.y + z*m.z) / (m.x + m.y + m.z);\n}\n\nfloat capsule( vec3 p, vec3 a, vec3 b, float r )\n{\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\n\n\nfloat dot2( in vec3 v ) { return dot(v,v); }\n\n// https://www.shadertoy.com/view/WltSD7\nfloat cos_acos_3( in float x )\n{\n\tx = sqrt(0.5+0.5*x);\n    return x*(x*(x*(x*-0.008972+0.039071)-0.107074)+0.576975)+0.5; \n}\n\n// https://www.shadertoy.com/view/ltXSDB\nvec2 bezier(vec3 pos, vec3 A, vec3 B, vec3 C)\n{    \n    vec3 a = B - A;\n    vec3 b = A - 2.0*B + C;\n    vec3 c = a * 2.0;\n    vec3 d = A - pos;\n\n    float kk = 1.0 / dot(b,b);\n    float kx = kk * dot(a,b);\n    float ky = kk * (2.0*dot(a,a)+dot(d,b)) / 3.0;\n    float kz = kk * dot(d,a);      \n\n    vec2 res;\n\n    float p = ky - kx*kx;\n    float p3 = p*p*p;\n    float q = kx*(2.0*kx*kx - 3.0*ky) + kz;\n    float q2 = q*q;\n    float h = q2 + 4.0*p3;\n\n    if(h >= 0.0) \n    { \n        h = sqrt(h);\n        vec2 x = (vec2(h,-h)-q)/2.0;\n        \n        #if 1\n        // When p≈0 and p<0, h-q has catastrophic cancelation. So, we do\n        // h=√(q²+4p³)=q·√(1+4p³/q²)=q·√(1+w) instead. Now we approximate\n        // √ by a linear Taylor expansion into h≈q(1+½w) so that the q's\n        // cancel each other in h-q. Expanding and simplifying further we\n        // get x=vec2(p³/q,-p³/q-q). And using a second degree Taylor\n        // expansion instead: x=vec2(k,-k-q) with k=(1-p³/q²)·p³/q\n        if( abs(p)<0.001 )\n        {\n          //float k = p3/q;              // linear approx\n            float k = (1.0-p3/q2)*p3/q;  // quadratic approx \n            x = vec2(k,-k-q);  \n        }\n        #endif\n        \n        vec2 uv = sign(x)*pow(abs(x), vec2(1.0/3.0));\n        float t = clamp(uv.x+uv.y-kx, 0.0, 1.0);\n\n        // 1 root\n        res = vec2(dot2(d+(c+b*t)*t),t);\n        \n        //res = vec2( dot2( pos-bezier(A,B,C,t)), t );\n    }\n    else\n    {\n        float z = sqrt(-p);\n        #if 0\n        float v = acos( q/(p*z*2.0) ) / 3.0;\n        float m = cos(v);\n        float n = sin(v)*1.732050808;\n        #else\n        float m = cos_acos_3( q/(p*z*2.0) );\n        float n = sqrt(1.0-m*m)*1.732050808;\n        #endif\n        vec3 t = clamp( vec3(m+m,-n-m,n-m)*z-kx, 0.0, 1.0);\n        \n        // 3 roots, but only need two\n        float dis = dot2(d+(c+b*t.x)*t.x);\n        res = vec2(dis,t.x);\n\n        dis = dot2(d+(c+b*t.y)*t.y);\n        if( dis<res.x ) res = vec2(dis,t.y );\n    }\n    \n    res.x = sqrt(res.x);\n    return res;\n}\n\nfloat smin( float d1, float d2, float k )\n{\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\nfloat hash(float p)\n{\n\tvec3 p3  = fract(vec3(p) * .1031);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec2 GetDist(vec3 p) {    \n    float d = 999.0;\n    float mat = 0.0;\n \n    {\n        vec3 bp = p;\n        bp.z -= 1.4;\n        bp.y += 1.0;\n        bp.x += 1.0;\n    \n        float body = capsule(bp,vec3(1.0,0.85,0.0),vec3(0.5,1.0,1.0),0.2);\n        \n        d = min(d,body);\n    }\n    \n    {\n        vec3 tp = p;\n        \n        tp.z -= 2.3;\n        tp.y -= 0.0;\n        tp.x += 0.6;\n        \n        float tail = bezier(tp,vec3(0.2,0.,0.0),vec3(-0.3,0.3,0.0),vec3(-0.6,-0.3,0.5)).x;\n        tail = smin(tail,bezier(tp,vec3(-0.6,-0.3,0.5),vec3(-0.6,-0.7,0.5),vec3(-0.3,-0.9,0.0)).x,0.05);\n        \n        d = smin(d,tail-0.1,0.1);\n        mat = (tail-0.1-d < 0.01) ? 1.0 : mat;\n    }\n    \n    {\n        vec3 lp = p;\n        \n        lp.z -= 1.8;\n        lp.x += 0.2;\n        lp.xz *= Rot(-0.5);\n        lp.xz = abs(lp.xz);\n        lp.z -= 0.4;\n        lp.x -= 0.15;\n        lp.y += 0.1;\n        \n        float leg = capsule(lp,vec3(0.0),vec3(0.1,-0.25,0.0),0.05);\n        \n        leg = min(leg,capsule(lp,vec3(0.1,-0.25,0.0),vec3(0.0,-0.5,0.0),0.05));\n        \n        d = smin(d,leg,0.1);\n    }\n    \n    {\n        vec3 tp = p;\n        \n        tp.z -= 1.8;\n        tp.x += 0.2;\n        tp.xz *= Rot(-0.5);\n        tp.xz = abs(tp.xz);\n        tp.z -= 0.4;\n        tp.x -= 0.15;\n        tp.y += 0.6;\n        \n        tp.xy = tp.yx;\n        \n        float toes = 999.0;\n        \n        for (int i = 0; i < 3; i++) {\n            tp.yz *= Rot(TAU/3.);\n        \n            toes = min(toes,capsule(tp,vec3(0.,0.0,0.0),vec3(0.0,0.15,0.0),0.05));\n        }\n        \n        d = smin(d,toes,0.01);\n        \n    }\n    \n    {\n    \n        vec3 hp  = p;\n        \n        hp.z -= 1.2;\n        hp.x -= 0.1;\n        \n        float k = hash(floor(iTime)) * 0.3;\n        float k2 = hash(floor(iTime+2013144.)) * 0.3;\n        \n        hp.xy *= Rot(k);\n        hp.xz *= Rot(k2);\n        \n        float head = length(hp)-0.2;\n       \n        hp.z += 0.15;\n        \n        hp.x = abs(hp.x);\n        \n        hp.y -= 0.07;\n        \n        hp.x -= 0.09;\n        \n        float eyes = length(hp)-0.05;\n \n        head = min(head,eyes);\n        \n        d = smin(d,head,0.03);\n        \n        mat = (head - d < 0.01) ? ((head == eyes) ? 3.0 : 2.0) : mat;\n    }\n \n    return vec2(d,mat);\n}\n\nvec2 RayMarch(vec3 ro, vec3 rd) {\n\tfloat dO=0.;\n    float mat;\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        vec2 dS = GetDist(p);\n        dO += dS.x;\n        mat = dS.y;\n        \n        if(dO>MAX_DIST || abs(dS.x)<SURF_DIST) break;\n    }\n    \n    return vec2(dO,mat);\n}\n\nvec3 GetNormal(vec3 p) {\n    vec2 e = vec2(.001, 0);\n    vec3 n = GetDist(p).x - \n        vec3(GetDist(p-e.xyy).x, GetDist(p-e.yxy).x,GetDist(p-e.yyx).x);\n    \n    return normalize(n);\n}\n\nfloat ambientOcclusion(vec3 p, vec3 n){\n    const int steps = 1;\n    const float delta = 0.5;\n\n    float a = 0.0;\n    float weight = 0.75;\n    float m;\n    for(int i=1; i<=steps; i++) {\n        float d = (float(i) / float(steps)) * delta;\n        a += weight*(d - GetDist(p + n*d).x);\n        weight *= 0.5;\n    }\n    return clamp(1.0 - a, 0.0, 1.0);\n}\n\nfloat softshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n\tfloat res = 1.0;\n    float t = mint;\n    for( int i=0; i<100; i++ )\n    {\n\t\tfloat h = GetDist( ro + rd*t ).x;\n        res = min( res, 8.0*h/t );\n        t += h*.25;\n        if( h<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0.1, 1. );\n}\n\n\nvec3 shade(  vec3 position,\n                           vec3 lightPosition,\n                           vec3 ambientCol,\n                           vec3 lightCol,\n                           float ambientCoeff,\n                           float diffuseCoeff,\n                           float specularCoeff,\n                           float specularExponent,\n                           vec3 camera_pos,\n                           vec3 ray_direction\n)\n{\n      vec3 normal = GetNormal(position);\n      vec3 toEye = normalize(camera_pos - position);\n      vec3 toLight = normalize(lightPosition - position);\n      vec3 reflection = reflect(-toLight, normal);\n\n      vec3 ambientFactor = ambientCol * ambientCoeff;\n      vec3 diffuseFactor = diffuseCoeff * lightCol * max(0.0, dot(normal, toLight));\n      vec3 specularFactor = lightCol * pow(max(0.0, dot(toEye, reflection)), specularExponent)\n                     * specularCoeff;\n                     \n      float bac = clamp( dot( normal, normalize(vec3(-lightPosition.x,0.0,-lightPosition.z))), 0.0, 1.0 )*clamp( 1.0-position.y,0.0,1.0);\n      float fre = pow( clamp(1.0+dot(normal,ray_direction),0.0,1.0), 2.0 );\n\n      float ao = ambientOcclusion(position+normal*0.1,normal);\n      float ss= softshadow(position,lightPos,0.1,10.0);\n      \n      float sky = sqrt(0.5+0.5*normal.z);\n      diffuseFactor += sky;\n       \n    diffuseFactor *= ss;\n    diffuseFactor *= ao;\n    return ambientFactor + diffuseFactor + specularFactor + 0.30 * bac + 0.20 * fre;\n}\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 \n        f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u;\n    return normalize(i);\n}\n\nvec3 lsk(vec3 p) {\n    vec2 uv = p.xy;\n\n    uv *= 50.0;\n\n    float k = (sin(uv.x) - sin(uv.y) + 0.1)*0.5+0.5;\n\n    return mix(vec3(0.0,0.3,0.0),vec3(0.0,0.6,0.0),1.0-smoothstep(k,0.3,0.0));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\tvec2 m = iMouse.xy/iResolution.xy;\n\n    vec3 ro = vec3(0, 0, 0);\n    \n    vec3 rd = normalize(vec3(uv,1.0));\n    vec3 bg = vec3(0.3);\n    vec3 col = bg;\n   \n    vec2 rm = RayMarch(ro, rd);\n    float d = rm.x;\n\n    if(d<MAX_DIST) {\n        vec3 p = ro + rd * d;\n        vec3 n = GetNormal(p);\n        \n        if (rm.y == 0.0) {\n            col = lsk(p);\n        } else  if (rm.y == 1.0) {\n            col = mix(vec3(0.7,0.7,0.0),lsk(p),clamp(p.y+1.2,0.0,1.0));\n        } else  if (rm.y == 2.0) {\n            vec3 hp = p;\n            \n            float k = hash(floor(iTime)) * 0.3;\n            float k2 = hash(floor(iTime+2013144.)) * 0.3;\n        \n            hp.xy *= Rot(k);\n            hp.xz *= Rot(k2);\n            \n            col = lsk(hp);\n        } else  if (rm.y == 3.0) {\n            col = vec3(1.0);\n        }\n        \n        col *= shade(p,lightPos,ambientColor,lightColor,globalAmbient,globalDiffuse,globalSpecular,globalSpecularExponent,ro,rd);\n        col = mix(col,bg,1.0 - exp(-0.0004*d*d));\n    }\n    \n    float c = 1.1;\n    float b = 0.0;\n    col = c * (col-0.5) + 0.5 + b;\n    vec3 greyscale = vec3(dot(col,vec3(0.299,0.587,0.114)));\n    col = mix(greyscale,col,1.3);\n    col = clamp(col,vec3(0.0),vec3(1.0));\n    \n    col = pow(col, vec3(.4545));\t// gamma correction\n    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}