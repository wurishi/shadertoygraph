{"ver":"0.1","info":{"id":"llGXWc","date":"1486240430","viewed":2701,"name":"Geodesic tiling minimal","username":"tdhooper","description":"(shane style) minimal version of the technique used in [url]https://www.shadertoy.com/view/llVXRd[/url]. See [url]https://www.shadertoy.com/view/XtKSWc[/url] for version with full absolute positions.","likes":82,"published":1,"flags":0,"usePreview":0,"tags":["sphere","hexagon","tile","minimal","geodesic"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n\n\tGeodesic tiling\n\t---------------\n\n    I've been looking for a way to create geodesic geometry\n\t(subdivided polyhedra) in sdf land for a while.\n\n\tI'd initially tried folding/mirroring as with knighty's\n\ticosahedron method below, however I never found a way\n\tof generalising it, and getting a cell id was painful:\n\n\t// Subdivided icosahedron\n\thttps://www.shadertoy.com/view/lsV3RV\n\n\t// With cell ids\n\thttps://www.shadertoy.com/view/4syGDG\n\t\n\t// Using hexagons\n\thttps://www.shadertoy.com/view/4tG3zW\n\n\tThis method allows any level of subdivision, and the\n\ttiling approach allows creating interesting geometry\n\twith variation based on position:\n\n\t// Animated hexagons \n\thttps://www.shadertoy.com/view/llVXRd\n\t\n\tOne drawback is you don't get the point's full absolute\n\tposition in space, as everything is mirrored around\n\tthe icosahedron's schwarz triangle, you can see this\n\tin the colouring. This is fixed here:\n\n\t// Version with full absolute positions\n\thttps://www.shadertoy.com/view/XtKSWc\n\n*/\n\n\n#define HEX_TILE\n\n\n// --------------------------------------------------------\n// Icosahedral domain mirroring\n// knighty https://www.shadertoy.com/view/MsKGzw\n// \n// Also get the face normal, and tangent planes used to\n// calculate the uv coordinates later.\n// --------------------------------------------------------\n\n#define PI 3.14159265359\n\nvec3 facePlane;\nvec3 uPlane;\nvec3 vPlane;\n\nint Type=5;\nvec3 nc;\nvec3 pab;\nvec3 pbc;\nvec3 pca;\n\nvoid init() {\n    float cospin=cos(PI/float(Type)), scospin=sqrt(0.75-cospin*cospin);\n    nc=vec3(-0.5,-cospin,scospin);\n    pbc=vec3(scospin,0.,0.5);\n    pca=vec3(0.,scospin,cospin);\n    pbc=normalize(pbc); pca=normalize(pca);\n\tpab=vec3(0,0,1);\n    \n    facePlane = pca;\n    uPlane = cross(vec3(1,0,0), facePlane);\n    vPlane = vec3(1,0,0);\n}\n\nvoid fold(inout vec3 p) {\n\tfor(int i=0;i<5 /*Type*/;i++){\n\t\tp.xy = abs(p.xy);\n\t\tp -= 2. * min(0., dot(p,nc)) * nc;\n\t}\n}\n\n\n// --------------------------------------------------------\n// Triangle tiling\n// Adapted from mattz https://www.shadertoy.com/view/4d2GzV\n//\n// Finds the closest triangle center on a 2D plane \n// --------------------------------------------------------\n\nconst float sqrt3 = 1.7320508075688772;\nconst float i3 = 0.5773502691896258;\n\nconst mat2 cart2tri = mat2(1, 0, i3, 2. * i3);\nconst mat2 tri2cart = mat2(1, 0, -.5, .5 * sqrt3);\n\nvec2 pick3(vec2 a, vec2 b, vec2 c, float u) {\n\tfloat v = fract(u * 0.3333333333333);\n\treturn mix(mix(a, b, step(0.3, v)), c, step(0.6, v));\n}\n\nvec2 closestHex(vec2 p) {\n    p = cart2tri * p;\n\tvec2 pi = floor(p);\n\tvec2 pf = fract(p);\n\tvec2 nn = pick3(\n        vec2(0, 0),\n        vec2(1, 1),\n        vec2(1, 0),\n        pi.x + pi.y\n    );\n\tvec2 hex = mix(nn.xy, nn.yx, step(pf.x, pf.y)) + pi;\n    hex = tri2cart * hex;\n    return hex;\n}\n\nvec2 closestTri(vec2 p) {\n    p = cart2tri * p;\n    vec2 pf = fract(p);\n    vec2 v = vec2(1./3., 2./3.);\n    vec2 tri = mix(v, v.yx, step(pf.y, pf.x));\n    tri += floor(p);\n    tri = tri2cart * tri;\n    return tri;\n}\n\n\n\n\n// --------------------------------------------------------\n// Geodesic tiling\n//\n// Finds the closest triangle center on the surface of a\n// sphere:\n// \n// 1. Intersect position with the face plane\n// 2. Convert that into 2D uv coordinates\n// 3. Find the closest triangle center (tile the plane)\n// 4. Convert back into 3D coordinates\n// 5. Project onto a unit sphere (normalize)\n//\n// You can use any tiling method, such as one that returns\n// hex centers or adjacent cells, so you can create more\n// interesting geometry later.\n// --------------------------------------------------------\n\n// Intersection point of vector and plane\nvec3 intersection(vec3 n, vec3 planeNormal, float planeOffset) {\n    float denominator = dot(planeNormal, n);\n    float t = (dot(vec3(0), planeNormal) + planeOffset) / -denominator;\n    return n * t;\n}\n\n// 3D position -> 2D (uv) coordinates on the icosahedron face\nvec2 icosahedronFaceCoordinates(vec3 p) {\n    vec3 i = intersection(normalize(p), facePlane, -1.);\n    return vec2(dot(i, uPlane), dot(i, vPlane));\n}\n\n// 2D (uv) coordinates -> 3D point on a unit sphere\nvec3 faceToSphere(vec2 facePoint) {\n\treturn normalize(facePlane + (uPlane * facePoint.x) + (vPlane * facePoint.y));\n}\n\n// Edge length of an icosahedron with an inscribed sphere of radius of 1\nconst float edgeLength = 1. / ((sqrt(3.) / 12.) * (3. + sqrt(5.)));\n// Inner radius of the icosahedron's face\nconst float faceRadius = (1./6.) * sqrt(3.) * edgeLength;\n\n// Closest geodesic point (triangle center) on unit sphere's surface\nvec3 geodesicTri(vec3 p, float subdivisions) {\n    // faceRadius is used as a scale multiplier so that our triangles\n    // always stop at the edge of the face\n\tfloat uvScale = subdivisions / faceRadius;\n\n    vec2 uv = icosahedronFaceCoordinates(p);\n\n    #ifdef HEX_TILE\n        uvScale /= 1.3333;\n        vec2 closest = closestHex(uv * uvScale);\n    #else\n        uvScale /= 2.;\n        vec2 closest = closestTri(uv * uvScale);\n    #endif\n    \n    return faceToSphere(closest / uvScale);\n}\n\n\n// --------------------------------------------------------\n// Modelling\n// --------------------------------------------------------\n\nstruct Model {\n    float dist;\n    vec3 color;\n};\n\nvoid spin(inout vec3 p) {\n    float r = iTime / 6.;\n    mat2 rot = mat2(cos(r), -sin(r), sin(r), cos(r));\n   \tp.xz *= rot;\n    p.zy *= rot;\n}\n\n// Smooth transition between subdivisions\nfloat animSubdivitions(float start, float end) {\n    \n    float t = mod(iTime, 2.) - 1. + .5;\n    t = clamp(t, 0., 1.);\n    t = cos(t * PI + PI) * .5 + .5;\n    \n    float n = floor(iTime / 2.);\n\n    float diff = end - start;\n    n = mod(n, diff + 1.);\n\n    if (n == diff) {\n    \treturn end - diff * t;\n    }\n\n    return n + start + t;\n} \n\n// The actual model\nModel map(vec3 p) {\n    \n    // Spin the whole model\n    spin(p);\n    \n    // Fold space into an icosahedron,\n    // disable this to get a better idea of what\n    // geodesicTri is doing\n    fold(p);\n    \n\tfloat subdivisions = animSubdivitions(1., 10.);\n\tvec3 point = geodesicTri(p, subdivisions);\n\n\tfloat sphere = length(p - point) - .195 / subdivisions; \n    \n    // Use red/green to indicate point's position,\n    // you can see that space always mirrored at the\n    // Icosahedron's schwarz triangle\n    vec3 color = vec3(0, point.yx * 3. + .5);\n    color = clamp(color, 0., 1.);\n\n\treturn Model(sphere, color);\n}\n\n\n// --------------------------------------------------------\n// Ray Marching\n// Adapted from cabbibo https://www.shadertoy.com/view/Xl2XWt\n// --------------------------------------------------------\n\nconst float MAX_TRACE_DISTANCE = 8.;\nconst float INTERSECTION_PRECISION = .001;\nconst int NUM_OF_TRACE_STEPS = 100;\n\nstruct CastRay {\n    vec3 origin;\n    vec3 direction;\n};\n\nstruct Ray {\n    vec3 origin;\n    vec3 direction;\n    float len;\n};\n\nstruct Hit {\n    Ray ray;\n    Model model;\n    vec3 pos;\n    bool isBackground;\n    vec3 normal;\n    vec3 color;\n};\n\nvec3 calcNormal( in vec3 pos ){\n    vec3 eps = vec3( 0.001, 0.0, 0.0 );\n    vec3 nor = vec3(\n        map(pos+eps.xyy).dist - map(pos-eps.xyy).dist,\n        map(pos+eps.yxy).dist - map(pos-eps.yxy).dist,\n        map(pos+eps.yyx).dist - map(pos-eps.yyx).dist );\n    return normalize(nor);\n}\n    \nHit raymarch(CastRay castRay){\n\n    float currentDist = INTERSECTION_PRECISION * 2.0;\n    Model model;\n    \n    Ray ray = Ray(castRay.origin, castRay.direction, 0.);\n\n    for( int i=0; i< NUM_OF_TRACE_STEPS ; i++ ){\n        if (currentDist < INTERSECTION_PRECISION || ray.len > MAX_TRACE_DISTANCE) {\n            break;\n        }\n        model = map(ray.origin + ray.direction * ray.len);\n        currentDist = model.dist;\n        ray.len += currentDist;\n    }\n    \n    bool isBackground = false;\n    vec3 pos = vec3(0);\n    vec3 normal = vec3(0);\n    vec3 color = vec3(0);\n    \n    if (ray.len > MAX_TRACE_DISTANCE) {\n        isBackground = true;\n    } else {\n        pos = ray.origin + ray.direction * ray.len;\n        normal = calcNormal(pos);\n    }\n\n    return Hit(ray, model, pos, isBackground, normal, color);\n}\n\n\n// --------------------------------------------------------\n// Rendering\n// --------------------------------------------------------\n\nvec3 render(Hit hit){\n    if (hit.isBackground) {\n        return vec3(0);\n    }\n    vec3 color = hit.model.color;\n    color += sin(dot(hit.normal, vec3(0,1,0))) * .2; // lighting\n    color *= 1. - clamp(hit.ray.len * .4 - .8, 0., 1.); // fog\n    return color;\n}\n\n\n// --------------------------------------------------------\n// Camera\n// https://www.shadertoy.com/view/Xl2XWt\n// --------------------------------------------------------\n\nmat3 calcLookAtMatrix( in vec3 ro, in vec3 ta, in float roll )\n{\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(sin(roll),cos(roll),0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    return mat3( uu, vv, ww );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    init();\n    \n    vec2 p = (-iResolution.xy + 2. * fragCoord.xy) / iResolution.y;\n\n    vec3 camPos = vec3(0, 0, 2.5);\n    vec3 camTar = vec3(0);\n    float camRoll = 0.;\n    mat3 camMat = calcLookAtMatrix(camPos, camTar, camRoll);\n    \n    vec3 rd = normalize(camMat * vec3(p.xy, 2.));\n    Hit hit = raymarch(CastRay(camPos, rd));\n\n    vec3 color = render(hit);\n    fragColor = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"}]}