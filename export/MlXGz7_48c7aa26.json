{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"//Jogging Rat by eiffie\n\n//this wouldn't compile for me with texturing so it is a bit flat\n\n#define time iTime\n\nbool bInside=false;\nvec3 L,mcol;\nint id;\n\n#define TAO 6.2831\nvec2 kaleido(vec2 v, float p){float a=floor(.5+atan(v.x,-v.y)*p/TAO)*TAO/p;return cos(a)*v+sin(a)*vec2(v.y,-v.x);}\n\nfloat DE(in vec3 z){\n\tvec2 p=z.xy;p.y*=2.0;\n\tif(mod(p.y,2.0)<1.0)p.x+=0.5;\n\tvec2 c=floor(p);\n\tp=fract(p)-vec2(0.5);\n\tp.y*=0.5;\n\tfloat dB=length(max(abs(vec3(p.xy,z.z))-vec3(0.425,0.175,0.175),0.0))-0.05;\n\tfloat dM=abs(z.z)-0.175;\n\tp=z.xy;\n\tp.x=mod(p.x,8.0)-4.0;\n\tfloat dW=min(max(abs(p.x)-2.0,abs(p.y-5.0)-3.0),length(vec2(p.x,p.y-8.0))-2.0);\n\tdB=max(dB,-dW);dM=max(dM,-dW);\n\tvec2 p2=abs(mod(z.xy+vec2(1.0),2.0)-vec2(1.0));\n\tp.y-=8.0;\n\tfloat dP=min(min(p2.x,p2.y)-0.05,max(-p.y,0.7*min(abs(p.x+p.y)-0.05,abs(p.x-p.y)-0.05)));\n\tdP=min(dM,max(dP,abs(z.z)-0.1));\n\tp2=kaleido(p,31.0);\n\tfloat dB2=max(-p.y-0.1,length(max(abs(vec3(p2.x,p2.y+2.48,z.z))-vec3(0.175,0.425,0.225),0.0))-0.05);\n\tp=vec2(min(abs(z.x),z.y+2.0),z.z);\n\tfloat dC=length(max(abs(p)-vec2(0.5),0.0))-0.05;\n\tfloat tile=(bInside?1.0:3.0);\n\tp=abs(mod(z.xz+vec2(0.0,tile),2.0*tile)-tile);\n\tfloat dG=z.y+2.0+0.5*clamp(0.1-min(p.x,p.y),0.0,0.1);\n\tfloat d1=min(dB,dB2),d2=min(d1,dP),d3=min(d2,dC);\n\tif(dG<d3){id=0;return dG;}\n\telse if(dC<d2){id=1;return dC;}\n\telse if(dP<d1){id=2;return dP;}\n\telse if(dB<dB2){id=3;return dB;}\n\tid=4;return dB2;\n}\nfloat hash(float c){return fract(sin(c)*717.351);}\nfloat rnd(vec2 co){return fract(sin(dot(co,vec2(123.42,117.853)))*412.453);}\n\nfloat rndStart(vec2 fragCoord){return 0.5+0.5*rnd(fragCoord.xy+vec2(time));}\n\nfloat CE(in vec3 z){\n\tfloat d=DE(z);\n\tvec3 col=vec3(1.0);\n\tif(id!=2){\n\t\t//vec2 p=z.xy;//you can uncomment all this to get some texturing \n\t\tif(id==0){\n\t\t\tcol=vec3(2.25+z.y);//p=z.xz;\n            if(bInside){col+=vec3(0.25);}//p=vec2(z.x+z.z,(z.x-z.z)*0.1);}\n\t\t}else if(id==1)col=vec3(0.5);\n\t\telse if(id==4)col=vec3(0.5,0.35,0.3)*0.75;\n\t\telse if(id==3){\n\t\t\tvec2 c=floor(z.xy);\n\t\t\tcol=vec3(0.5,0.35,0.3)+vec3(sin(c.x*2.0)*0.025,sin(c.y*2.0)*0.025,sin(c.x+sin(c.y))*0.05);\n\t\t}\n\t\t//vec3 tx=texture(tex,p*0.2).rgb;\n\t\t//col+=tx*0.125;\n\t\tif(abs(z.z)<0.13)col=vec3(1.0);\n\t\t//else d+=tx.r*0.03;\n\t}\n\tmcol+=col;\n\treturn d;\n}\nfloat smin(float a,float b,float k){float h=clamp(0.5+0.5*(b-a)/k,0.0,1.0);return b+h*(a-b-k+k*h);}//from iq\n\nfloat leg(vec3 p, vec3 j0, vec3 j3, vec3 l, vec4 r, vec3 rt){//z joint with tapered legs\n\tfloat lx2z=l.x/(l.x+l.z),h=l.y*lx2z;\n\tvec3 u=(j3-j0)*lx2z,q=u*(0.5+0.5*(l.x*l.x-h*h)/dot(u,u));\n\tq+=sqrt(max(0.0,l.x*l.x-dot(q,q)))*normalize(cross(u,rt));//faster version\n\tvec3 j1=j0+q,j2=j3-q*(1.0-lx2z)/lx2z;\n\tu=p-j0;q=j1-j0;\n\th=clamp(dot(u,q)/dot(q,q),0.0,1.0);\n\tfloat d=length(u-q*h)-r.x-(r.y-r.x)*h;\n\tu=p-j1;q=j2-j1;\n\th=clamp(dot(u,q)/dot(q,q),0.0,1.0);\n\td=min(d,length(u-q*h)-r.y-(r.z-r.y)*h);\n\tu=p-j2;q=j3-j2;\n\th=clamp(dot(u,q)/dot(q,q),0.0,1.0);\n\treturn min(d,length(u-q*h)-r.z-(r.w-r.z)*h);\n}\n\nfloat DER(in vec3 z0){\n\tz0+=vec3(mod(time*8.0,80.0)-40.0,1.5,1.0);\n\tfloat d=length(z0);\n\tif(d>1.75)return d-1.5;\n\tconst vec3 rt=vec3(0.0,0.0,1.0);\n\tvec3 p=z0;p.z=abs(p.z)-0.125;\n\tfloat sx=sign(p.x),a=-sx*time*24.0+1.57,sa=sin(a);\n\tvec3 j0=vec3((sa*0.05+0.5)*sx,+sx*0.1,0.0),j3=vec3(0.6*sx+sx*sa*0.25,-0.5+max(0.0,cos(a)*0.25),0.0);\n\tfloat dL=leg(p,j0,j3,vec3(0.2+sx*0.1,0.25,0.2),vec4(0.06,0.05,0.03,0.01),rt);\n\tp=z0;\n\tvec3 u=p-j0,q=-j0;\n\tfloat h=clamp(dot(u,q)/dot(q,q),0.0,1.0);\n\tp.y+=sa*0.05;\n\tfloat dB=length(u-q*h)-0.13,dB2=length(p*vec3(0.5,1.0,1.0))-0.2;\n\tu.x+=0.25;u.y+=0.01;\n\tq=j0+(sx+2.0)*vec3(0.3,-0.1,0.0);\n\th=clamp(dot(u,q)/dot(q,q),0.0,1.0);\n\tif(sx>0.0){q.z+=sin(h*2.0+time*8.0)*h*0.5;}\n\tfloat dH=length(u-q*h)-(1.2-h)*abs(sx-0.5)*0.06;\n\th=1.0;\n\tif(sx<0.0){\n\t\tu.z=abs(u.z)-0.05;u.y-=0.05;\n\t\tdH=min(dH,length(u*vec3(1.5,0.5,1.0))-0.05);\n\t\tif(id<0){\n\t\t\tu.x+=0.08+sa*0.01;u.y+=0.05;\n\t\t\tif(length(u)-0.025<dH)h=0.0;\n\t\t}\n\t}else dH*=0.8;\n\tmcol.r+=h;\n\treturn smin(min(dL,min(dB2,dH)),dB,0.1);\n}\n\nvec3 getBackground( in vec3 ro, in vec3 rd ){\n\treturn 0.3*(0.5+rd.y*0.5)*vec3(0.5,0.7,0.8);\n}\nfloat getShadow(vec3 ro){\n\tfloat t=-ro.z/L.z;\n\tvec2 p=ro.xy+L.xy*t;\n\tp.x=mod(p.x,8.0)-4.0;\n\tfloat d=min(max(abs(p.x)-2.0,abs(p.y-5.0)-3.0),length(vec2(p.x,p.y-8.0))-2.0);\n\tp=abs(mod(p+vec2(1.0),2.0)-vec2(1.0));\n\tfloat dP=min(p.x,p.y)-0.05;\n\treturn 0.5+0.5*smoothstep(-0.1,0.1,min(-d,dP));\n}\nvec3 Color(vec3 ro, float px){\n\tvec2 e=vec2(0.5*px,0.0);\n\tmcol=vec3(0.0);\n\tfloat d=CE(ro);\n\tvec3 dn=vec3(CE(ro-e.xyy),CE(ro-e.yxy),CE(ro-e.yyx));\n\tvec3 dp=vec3(CE(ro+e.xyy),CE(ro+e.yxy),CE(ro+e.yyx));\n\tvec3 N=(dp-dn)/(length(dp-vec3(d))+length(vec3(d)-dn));\n    vec3 f=ro*0.3;\n    f=sin(f+sin(f.zxy));\n\tmcol*=0.143*clamp(0.5+0.2*(f.x+f.y+f.z)+clamp(((ro.y+2.0)-ro.z)*0.5-0.1,0.0,0.7),0.0,1.0);\n\tfloat shad=1.0;\n\tif(bInside && ro.y<=-2.0+px)shad=getShadow(ro);\n\treturn mcol*(0.5+0.5*dot(L,N))*shad;\n}\nvec3 ColorR(vec3 ro, float d, float px){\n\tvec2 e=vec2(0.5*px,0.0);\n\tid=-1;mcol.r=0.0;\n\tvec3 dp=vec3(DER(ro+e.xyy),DER(ro+e.yxy),DER(ro+e.yyx));\n\tvec3 N=normalize(dp-vec3(d));\n\treturn 0.25*mcol.r*vec3(1.0,0.9,0.8)*(1.0-(ro.y+2.0)*1.25)*(0.5+0.5*dot(L,N));\n}\nfloat rndFloor(float x){return floor(x+sin(x*0.25-sin(x*0.5-sin(x)*0.75)*0.58)*1.6);}\n\nvec3 streetScene(vec3 ro, vec3 rd){\n\tfloat d=rd.y;\n\tfloat t=(-20.0-ro.z)/rd.z;\n\tvec2 p=ro.xy+rd.xy*t;p*=vec2(0.175,0.25);\n\td=smin(d,0.05*(min(length(p+vec2(sin(time*0.5)*20.0,0.0)),length(p+vec2(sin(time*0.6)*20.0,-0.1)))-1.0),0.1);\n\tvec3 col=vec3(0.5+0.25*smoothstep(0.0,0.1,d));\n\tp=mod(ro.xy,2.0)-vec2(1.0);\n\tvec2 c=floor(ro.xy*0.5);\n\tif(hash(c.x+c.y)<0.125 && ro.y<8.0){\n\t\tvec2 rc=2.0*vec2(hash(c.x),hash(c.x+c.y))-vec2(1.0,0.5);\n\t\tp-=rc;\n\t\tfloat a=atan(p.y,p.x)+c.x*2.0+c.y;\n\t\tfloat r=0.25+hash(rndFloor(a*5.0))*(0.5+hash(c.x-c.y));\n\t\tif(length(p)<r)col=vec3((bInside)?1.0:0.0);\n\t}\n\treturn col;\n}\nvec3 scene( vec3 ro, vec3 rd, float px, vec2 fragCoord )\n{\n\tfloat tG=(-1.75-ro.y)/rd.y;if(tG<0.0)tG=1000.0;\n\tfloat tMax=(1.0-ro.z)/rd.z,tMin=min(tG,(-0.75-ro.z)/rd.z);\n\tfloat t=tMin+DE(ro+rd*tMin)*rndStart(fragCoord),d=1.0,od=1.0,ed=1.0,et=-1.0;\n\tbool grab=false;\n\tfor(int i=0;i<12;i++){\n\t\tif(t>tMax || d<0.00001)break;\n\t\td=DE(ro+rd*t);\n\t\tif(d>od){\n\t\t\tif(grab && d<px*t && et<0.0){ed=d;et=t;}\n\t\t}else grab=true;\n\t\tod=d;\n\t\tt+=d;\n\t}\n\tvec3 col=getBackground(ro,rd);\n\tif(t>-ro.z/rd.z){//window reflection\n\t\tfloat frez=sqrt(rd.z);\n\t\tif(!bInside)frez=1.0-frez;\n\t\tcol+=frez*streetScene(ro+rd*(-ro.z/rd.z),vec3(rd.xy,-rd.z));//reflect rd and get street scene\n\t}\n\tif(d<px*t)col=Color(ro+rd*t,px*t);\n\tif(ed<px*et)col=mix(Color(ro+rd*et,px*et),col,clamp(ed/(px*et),0.0,1.0));//nice-ify the edges\n\t\n\ttG=(-2.0-ro.y)/rd.y;if(tG<0.0)tG=1000.0;\n\ttMax=-ro.z/rd.z;tMin=min(tG,(-1.5-ro.z)/rd.z);\n\tt=tMin+DER(ro+rd*tMin)*rndStart(fragCoord);d=1.0;od=1.0;ed=1.0;et=-1.0;\n\tgrab=false;\n\tfor(int i=0;i<24;i++){\n\t\tif(t>tMax || d<0.00001)break;\n\t\td=DER(ro+rd*t);\n\t\tif(d>od){\n\t\t\tif(grab && d<px*t && et<0.0){ed=d;et=t;}\n\t\t}else grab=true;\n\t\tod=d;\n\t\tt+=d;\n\t}\n\tt-=d;\n\tif(d<px*t)col=ColorR(ro+rd*t,d,px*t);\n\tif(ed<px*et)col=mix(ColorR(ro+rd*et,ed,px*et),col,clamp(ed/(px*et),0.0,1.0));\n\treturn col;\n}\t \n\nmat3 lookat(vec3 fw){\n\tfw=normalize(fw);vec3 rt=normalize(cross(fw,vec3(0.0,1.0,0.0)));return mat3(rt,cross(rt,fw),fw);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tL=normalize(vec3(-0.3,0.7,-0.5));\n\tvec2 uv=(2.0*fragCoord.xy-iResolution.xy)/iResolution.y;\n\tvec3 ro=vec3(1.5,2.5,-8.5),dr=vec3(uv,1.0),rd=lookat(vec3(clamp(-mod(time*8.0,80.0)+40.0,-0.5,3.5),2.0,0.0)-ro)*normalize(dr);\n\tif(mod(time,20.0)>10.0){bInside=true;L.z=-L.z;}\n\tvec3 color=scene(ro,rd,2.5/iResolution.y,fragCoord);\n\tfloat fade=min(5.0-abs(mod(time,10.0)-5.0),1.0);\n\tfragColor = vec4(color*fade,1.0);\n\n}\n","name":"Image","description":"","type":"image"},{"outputs":[],"inputs":[],"code":"#define bps 10.0\nfloat nofs(float n){//the song's \"random\" ring\n    n=mod(n,8.0);\n    if(n<1.0)return 2.0;\n    if(n<2.0)return 1.0;\n    if(n<3.0)return 4.0;\n    if(n<4.0)return 4.0;\n    if(n<5.0)return 8.0;\n    if(n<6.0)return 4.0;\n    if(n<7.0)return 2.0;\n    return 0.0;\n}\nfloat scale(float note){//throws out dissonant tones\n\tfloat n2=mod(note,12.0);\n\tif((n2==1.0)||(n2==2.0)||(n2==4.0)||(n2==8.0)||(n2==9.0)||(n2==11.0))note=-100.0;//blues\n\treturn note;\n}\n#define TAO 6.2831\n// note number to frequency  from https://www.shadertoy.com/view/ldfSW2\nfloat ntof(float n){if(n<12.0)return 0.0;return 440.0 * pow(2.0, (n - 67.0) / 12.0);}\nfloat ssaw(float t){return 4.0*abs(fract(t)-0.5)-1.0;}\nfloat rnd(float t){return fract(sin(t*341.545234)*1531.2341);}\nfloat srnd(float t){float t2=fract(t);return mix(rnd(floor(t)),rnd(floor(t+1.0)),t2*t2*(3.0-2.0*t2));}\nfloat harm(float f,float t,float ps,float hs){//pitch shift, harmonic sustain\n\tfloat a=0.0;\n\tfor(float i=1.0;i<5.0;i+=1.0){\n\t\ta+=ssaw(f*i*(t+ps*i))/max(i-i*i*hs,1.0);\n\t}\n\treturn a;\n}\nfloat inst(float n,float t,float bt,int i){\n\tfloat f=ntof(scale(n)),ps=0.0,hs=0.0;\n\tif(f<24.0)return 0.0;\t\n\tif(i==0){ps=bt*0.0005;hs=bt*0.05;}//piano\n\telse if(i==1){ps=bt*0.5;hs=bt*0.05;f*=0.5;}//bell\n\telse if(i==9){ps=bt*rnd(t);hs=bt*0.05;f*=0.125;}//clanker\n\tfloat a=harm(f,t,ps,hs);\n\ta=sign(a)*pow(clamp(abs(a),0.0,1.0),70.0/n);\n\ta*=exp(-bt*(1.0+float(i)));\n\ta*=min(min(bt,2.0-bt)*100.0,1.0);\n\treturn a*60.0/n*(0.8+0.2*rnd(n));\n}\nvec2 mainSound( in int samp,float time)\n{\n\tint i0=0,i1=0,i1h=0,i2=0,i2h=0;\n\tfloat tim=time*bps,b=floor(tim);\n\tfloat t0=fract(tim),t1=mod(tim,2.0)*0.5,t2=mod(tim,4.0)*0.25;\n\tfloat n2=nofs(b*0.0625)+nofs(b*0.125)+nofs(b*0.25);\n\tfloat n1=n2+nofs(b*0.5),n0=n1+nofs(b);\n\n\tfloat a0=inst(n0+72.0,time,t0,i0);\n\tfloat a1=inst(n1+60.0,time,t1,i1);\n\tfloat a1h=inst(n1+65.0,time*1.005,t1,i1h);\n\tfloat a1hb=inst(n1+64.0,time,t1,9);\n\tfloat a2=inst(n2+48.0,time,t2,i2);\n\tfloat a2h=inst(n2+53.0,time,t2,i2h);\n\tvec2 v=0.25*vec2(a0+a1+a1h+a1hb+a2+a2h);\n\t\n\t//this is annoying to duplicate but it adds the note tails\n\tb-=1.0;\n\tn2=nofs(b*0.0625)+nofs(b*0.125)+nofs(b*0.25);\n\tn1=n2+nofs(b*0.5);n0=n1+nofs(b);\n\ta0=inst(n0+72.0,time,t0+1.0,i0);\n\tv+=vec2(0.25*a0);\n\tb-=1.0;\n\tn2=nofs(b*0.0625)+nofs(b*0.125)+nofs(b*0.25);\n\tn1=n2+nofs(b*0.5);\n\ta1=inst(n1+60.0,time,t1+1.0,i1);\n\ta1h=inst(n1+65.0,time*1.005,t1+1.0,i1h);\n\tv+=0.25*vec2(a1+a1h);\n\tb-=2.0;\n\tn2=nofs(b*0.0625)+nofs(b*0.125)+nofs(b*0.25);\n\ta2=inst(n2+48.0,time,t2+1.0,i2);\n\ta2h=inst(n2+53.0,time,t2+1.0,i2h);\n\tv+=0.25*vec2(a2+a2h);\n\treturn clamp(v,-1.0,1.0);\n}\n","name":"Sound","description":"","type":"sound"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":true,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"MlXGz7","date":"1419954923","viewed":362,"name":"Jogging Rat","username":"eiffie","description":"um... a rat... possibly jogging or perhaps he is late for something?","likes":19,"published":1,"flags":0,"usePreview":0,"tags":["rat"],"hasliked":0,"parentid":"","parentname":""}}