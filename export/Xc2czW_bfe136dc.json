{"ver":"0.1","info":{"id":"Xc2czW","date":"1721983585","viewed":37,"name":"Hex Packing Stanford Bunny","username":"stakikawa","description":"Submission to HPG 2024 Student Competition. Click and hold to return it to bunny form!\n\nA Stanford bunny made of spheres arranged in a hexagonal sphere packing. The spheres randomly scatter and come back when click is held.","likes":0,"published":1,"flags":32,"usePreview":0,"tags":["spheres","bunny","hpgconf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Shadertoy for a Stanford bunny re-interpretation, made of spheres arranged\n// in a hexagonal sphere packing. The spheres randomly scatter and come back\n// when click is held!\n\nbool raySphereIntersect(vec3 ro, vec3 rd, vec3 sp, float sr, out float t) {\n    vec3 oc = ro - sp;\n    float b = dot(oc, rd);\n    float c = dot(oc, oc) - sr * sr;\n    float h = b * b - c;\n    if (h < 0.0) return false;\n    h = sqrt(h);\n    t = -b - h;\n    if (t < 0.0) t = -b + h;\n    return t > 0.0;\n}\n\nvec3 phongShading(vec3 hitPoint, vec3 normal, vec3 lightPos, vec3 viewPos, vec3 color) {\n    vec3 lightDir = normalize(lightPos - hitPoint);\n    vec3 viewDir = normalize(viewPos - hitPoint);\n    vec3 reflectDir = reflect(-lightDir, normal);\n\n    vec3 ambient = vec3(color) * 0.35;\n    float diff = max(dot(normal, lightDir), 0.0);\n    vec3 diffuse = diff * vec3(1.0);\n    float spec = pow(max(dot(viewDir, reflectDir), 0.0), 16.0);\n    vec3 specular = spec * vec3(1.0);\n\n    return ambient + diffuse + specular;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    ivec2 fragCoordInt = ivec2(fragCoord.xy);\n    int index = fragCoordInt.x + fragCoordInt.y * int(iResolution.x);\n\n    vec2 uv = fragCoord / iResolution.xy * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n\n    // camera setup\n    vec3 lightPos = vec3(10.0, 10.0, 20.0);\n    \n    vec3 ro = getCameraPosition(iTime + 3.25);\n    vec3 target = vec3(0.0, 0.0, 0.0);\n    vec3 up = vec3(0.0, 1.0, 0.0);\n\n    mat3 viewMatrix = lookAt(ro, target, up);\n    vec3 rd = normalize(viewMatrix * vec3(uv, -1.0));\n\n    vec3 viewPos = ro;\n\n    // ray intersection setup\n    vec3 hitPoint, normal, color;\n    bool hit = false;\n    float closestT = 1e20;\n\n    for (int i = 0; i < NUM_SPHERES; i++) { \n        vec4 data = texelFetch(iChannel0, ivec2((i * 2) % int(iResolution.x), (i * 2) / int(iResolution.x)), 0);\n        vec3 spherePos = data.xyz;\n        float t;\n\n        if (raySphereIntersect(ro, rd, spherePos, SPHERE_RADIUS, t) && t < closestT) {\n            closestT = t;\n            hitPoint = ro + t * rd;\n            normal = normalize(hitPoint - spherePos);\n            \n            vec4 dataOther = texelFetch(iChannel0, ivec2((i * 2 + 1) % int(iResolution.x), (i * 2 + 1) / int(iResolution.x)), 0);\n            float h = data.w;\n            color = hslToRgb(h, 0.7, 0.72); // sphere hsl color\n            hit = true;\n        }\n    }\n\n    if (hit) {\n        vec3 shadedColor = phongShading(hitPoint, normal, lightPos, viewPos, color) * color;\n        fragColor = vec4(shadedColor, 1.0);\n    } else {\n        fragColor = vec4(0.0, 0.0, 0.0, 1.0); // Background color;\n    }\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define NUM_SPHERES 3316\n#define SPHERE_RADIUS 0.04\n#define SPHERE_RETURN_SPEED 0.03\n\n// Convert from HSL to RGB\nvec3 hslToRgb(float hue, float saturation, float lightness) {\n    float c = (1.0 - abs(2.0 * lightness - 1.0)) * saturation;\n    float x = c * (1.0 - abs(mod(hue / 60.0, 2.0) - 1.0));\n    float m = lightness - c / 2.0;\n    vec3 rgb;\n\n    if (0.0 <= hue && hue < 60.0) {\n        rgb = vec3(c, x, 0.0);\n    } else if (60.0 <= hue && hue < 120.0) {\n        rgb = vec3(x, c, 0.0);\n    } else if (120.0 <= hue && hue < 180.0) {\n        rgb = vec3(0.0, c, x);\n    } else if (180.0 <= hue && hue < 240.0) {\n        rgb = vec3(0.0, x, c);\n    } else if (240.0 <= hue && hue < 300.0) {\n        rgb = vec3(x, 0.0, c);\n    } else {\n        rgb = vec3(c, 0.0, x);\n    }\n\n    rgb += vec3(m, m, m);\n    return rgb;\n}\n\n// camera rotation around the origin\nvec3 getCameraPosition(float time) {\n    float radius = 1.5;\n    float angle = time * 0.5;\n    float x = radius * cos(angle);\n    float z = radius * sin(angle);\n    return vec3(x, 0.75, z);\n}\n\n// lookat to origin\nmat3 lookAt(vec3 eye, vec3 center, vec3 up) {\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Hexagonal sphere packing done with my own Python code for this project:\n// https://github.com/stakikawa/hexagonal_sphere_packing\nconst int spheres[] = int[] (\n-25,-25,-25,-25,-25,-25,-25,-25,-25,-25,-25,-25,-25,-25,-25,-25,-25,-25,-25,-25,-25,\n-25,-25,-25,-25,-25,-25,-25,-25,-25,-25,-25,-25,-25,-25,-25,-25,-25,-25,-25,-25,-25,\n-25,-25,-25,-25,-25,-25,-25,-25,-25,-25,-25,-25,-25,-25,-25,-25,-25,-25,-25,-25,-25,\n-25,-25,-25,-25,-25,-25,-25,-25,-25,-25,-25,-25,-25,-25,-25,-25,-25,-25,-25,-25,-25,\n-25,-25,-25,-25,-25,-25,-25,-25,-25,-25,-25,-25,-25,-25,-25,-25,-25,-25,-25,-25,-25,\n-25,-25,-25,-25,-25,-25,-25,-25,-25,-25,-25,-25,-25,-25,-25,-25,-25,-25,-25,-25,-25,\n-25,-25,-25,-25,-25,-25,-25,-25,-25,-25,-25,-25,-25,-25,-25,-25,-25,-25,-25,-25,-25,\n-25,-25,-25,-25,-25,-25,-25,-25,-25,-25,-25,-25,-25,-25,-25,-25,-25,-25,-5,1,-19,\n-25,-25,-25,-25,-25,-25,-25,-25,-25,-25,-25,-25,-25,-25,-25,-25,-25,-25,-25,-25,-25,\n-25,-25,-25,-25,-25,-25,-5,1,-19,-5,1,-19,-25,-25,-25,-25,-25,-25,-25,-25,-25,-25,\n-25,-25,-25,-25,-25,-25,-25,-25,-25,-25,-25,-25,-25,-25,-4,1,-20,-5,1,-19,-4,1,-20,\n-4,1,-20,-25,-25,-25,-25,-25,-25,-25,-25,-25,-25,-25,-25,-25,-25,-25,-25,-25,-25,\n-25,-25,-25,-25,-25,-5,1,-19,-5,1,-19,-5,1,-19,-4,1,-20,-25,-25,-25,-25,-25,-25,-25,\n-25,-12,2,-11,-11,2,-12,-11,4,-10,-10,4,-11,-11,4,-10,-11,2,-12,-25,-25,-25,-25,-25,\n-25,-25,-25,-25,-25,-4,2,-19,-4,1,-20,-4,2,-19,-3,1,-21,-25,-25,-25,-25,-10,1,-14,\n-25,-13,3,-9,-11,6,-8,-11,6,-8,-11,6,-8,-11,7,-7,-10,7,-8,-11,7,-7,-10,7,-8,-12,4,\n-9,-25,-25,-25,-25,-25,-25,-25,-25,-25,-5,1,-19,-4,2,-19,-4,2,-19,-4,1,-20,-25,-25,\n-25,-25,-8,8,-9,-8,9,-8,-11,7,-7,-10,8,-7,-10,8,-7,-10,8,-7,-10,9,-6,-9,9,-7,-10,\n9,-6,-10,7,-8,-12,4,-9,-25,-25,-25,-25,-25,-25,-25,-25,-4,1,-20,-4,2,-19,-3,2,-20,\n-4,1,-20,-12,1,-12,-25,-25,-25,-25,-8,2,-3,5,-7,-8,10,-7,-10,9,-6,-10,9,-6,-11,9,\n-5,-10,10,-5,-10,10,-5,-9,11,-5,-7,14,-4,-6,14,-5,-7,13,-5,-7,12,-6,-9,9,-7,-15,1,\n-9,-25,-25,-25,-25,-25,-4,2,-19,-5,2,-18,-4,2,-19,-4,2,-7,1,-11,-12,1,-12,-12,1,-12,\n-12,1,-12,-25,-25,-8,1,-6,3,-7,-8,10,-7,-10,9,-6,-9,10,-6,-10,10,-5,-7,13,-5,-5,15,\n-5,-4,16,-5,-4,17,-4,-4,16,-5,-4,16,-5,-4,15,-6,-6,13,-6,-6,11,-8,-25,-25,-25,-25,\n-25,-3,2,-20,-4,2,-19,-3,2,-5,3,-12,-10,3,-12,-10,2,-13,-11,1,-13,-25,-25,-25,-6,\n3,-7,2,-7,-6,13,-6,-8,14,-3,-7,15,-3,-8,13,-4,-7,14,-4,-5,16,-4,-4,17,-4,-4,18,-3,\n-3,18,-4,-4,17,-4,-4,16,-5,-5,15,-5,-5,14,-6,-6,13,-6,-8,1,-16,-25,-25,-25,-4,2,-19,\n-4,2,-19,-4,1,-4,4,-12,-9,3,-13,-9,2,-14,-11,1,-13,-25,-25,-25,-5,5,-2,1,-2,5,-5,\n-5,16,-4,-6,17,-2,-6,16,-3,-6,17,-2,-4,17,-4,-4,17,-4,-3,18,-4,-3,18,-4,-2,19,-4,\n-3,18,-4,-2,18,-5,-3,17,-5,-3,16,-6,-3,15,-7,-3,6,-4,3,-9,-3,4,-18,-3,3,-19,-4,2,\n-19,-3,2,-3,1,-16,-4,1,-3,4,-13,-7,3,-15,-8,2,-15,-9,1,-15,-25,-25,-25,-25,-5,5,-5,\n6,-4,-4,18,-3,-6,17,-2,-6,17,-2,-7,17,-1,-4,19,-2,-4,18,-3,-3,19,-3,-3,19,-3,-2,20,\n-3,-3,19,-3,-2,19,-4,-3,18,-4,-3,17,-5,-3,17,-5,-2,16,-7,-3,6,-16,-3,5,-17,-4,4,-17,\n-3,6,-16,-4,2,-1,4,-14,-7,2,-16,-9,1,-15,-25,-25,-25,-25,-25,-4,17,-4,-4,18,-3,-6,\n17,-2,-6,17,-2,-5,19,-1,-3,20,-2,-3,19,-3,-2,19,-4,-2,20,-3,-1,20,-4,-2,19,-4,-2,\n18,-5,-2,18,-5,-2,17,-6,-2,17,-6,-1,9,-2,5,-8,-2,6,-17,-2,5,-18,-3,5,-17,-2,6,-17,\n-6,3,-16,-25,-25,-25,-25,-25,-25,-25,-5,6,-4,6,-4,-5,17,-3,-8,16,-1,-7,16,-2,-6,18,\n-1,-4,20,-1,-4,18,-3,-3,19,-3,-3,19,-3,-2,19,-4,-2,20,-3,-2,19,-4,-3,18,-4,-2,18,\n-5,-2,18,-5,-1,17,-7,-2,7,-16,-2,6,-17,-3,5,-17,-2,6,-17,-3,5,-17,-25,-25,-25,-25,\n-25,-25,-25,-6,15,-4,-6,16,-3,-7,16,-2,-7,16,-2,-5,18,-2,-3,19,-3,-3,19,-3,-2,19,\n-4,-2,19,-4,-1,20,-4,-2,19,-4,-2,18,-5,-2,18,-5,-1,18,-6,-1,18,-6,-1,7,-4,5,-8,-2,\n6,-17,-1,6,-18,-2,6,-17,-1,6,-18,-4,2,-19,-25,-25,-25,-25,-25,-25,-25,-6,5,-5,3,-6,\n-6,15,-4,-8,14,-3,-7,16,-2,-7,16,-2,-5,16,-4,-4,18,-3,-3,18,-4,-3,19,-3,-2,19,-4,\n-3,18,-4,-2,19,-4,-3,18,-4,-2,18,-5,-2,17,-6,-1,7,-5,4,-8,-2,7,-16,-2,6,-17,-2,6,\n-17,-2,5,-18,-4,3,-18,-25,-25,-25,-25,-25,-25,-25,-5,14,-6,-5,14,-6,-7,13,-5,-7,13,\n-5,-7,14,-4,-4,16,-5,-4,17,-4,-3,17,-5,-3,18,-4,-2,18,-5,-3,17,-5,-2,17,-6,-3,17,\n-5,-2,16,-7,-2,6,-4,5,-8,-1,7,-17,-2,6,-17,-2,5,-18,-2,5,-18,-2,5,-18,-25,-25,-25,\n-25,-25,-25,-25,-25,-6,5,-4,3,-7,-5,13,-7,-7,12,-6,-8,2,-1,8,-6,-8,12,-5,-8,12,-5,\n-5,16,-4,-4,16,-5,-4,17,-4,-3,17,-5,-4,16,-5,-4,15,-6,-4,15,-6,-2,6,-4,5,-8,-2,6,\n-6,2,-9,-2,6,-17,-2,6,-17,-2,5,-18,-3,4,-18,-3,4,-18,-25,-25,-25,-25,-25,-25,-25,\n-25,-6,11,-8,-5,3,-1,7,-9,-11,7,-7,-11,7,-7,-12,7,-6,-11,7,-7,-6,4,-1,8,-6,-5,14,\n-6,-5,14,-6,-4,15,-6,-5,14,-6,-5,2,-4,4,-1,1,-8,-14,1,-10,-1,5,-19,-2,5,-18,-1,5,\n-19,-2,4,-19,-2,3,-20,-3,3,-19,-25,-25,-25,-25,-25,-25,-25,-25,-25,-10,4,-11,-10,\n4,-11,-13,4,-8,-12,5,-8,-13,5,-7,-12,6,-7,-12,7,-6,-11,7,-7,-12,7,-6,-11,7,-7,-13,\n4,-8,-25,-25,-3,2,-20,-3,3,-19,-2,4,-19,-3,3,-19,-3,2,-20,-4,1,-20,-25,-25,-25,-25,\n-25,-25,-25,-25,-25,-25,-25,-25,-25,-13,3,-9,-12,4,-9,-12,5,-8,-11,5,-9,-12,5,-8,\n-12,3,-10,-25,-25,-25,-4,1,-20,-4,2,-19,-3,2,-20,-3,2,-20,-25,-25,-25,-25,-25,-25,\n-25,-25,-25,-25,-25,-25,-25,-25,-25,-25,-25,-25,-25,-25,-25,-25,-25,-25,-25,-25,-25,\n-25,-25,-25,-25,-25,-25,-25,-25,-25,-25,-25,-25,-25,-25,-25,-25,-25,-25,-25,-25,-25,\n-25,-25,-25,-25,-25,-25,-25,-25,-25,-25,-25,-25,-25,-25,-25,-25,-25,-25,-25,-25,-25,\n-25,-25,-25,-25,-25,-25,-25,-25,-25,-25,-25,-25,-25,-25,-25,-25,-25,-25,-25,-25,-25,\n-25,-25,-25,-25,-25,-25,-25,-25,-25,-25,-25,-25,-25,-25,-25,-25,-25,-25,-25,-25,-25,\n-25,-25,-25,-25,-25,-25,-25,-25,-25,-25);\n\n// dimension of sphere grid\nint Z_SIZE = 30;\nint Y_SIZE = 28;\nint X_SIZE = 25;\n\n// offsets of the spheres\nfloat row_offset = SPHERE_RADIUS;\nfloat layer_z_offset = (2.0 * SPHERE_RADIUS * sqrt(6.0)) / 3.0;\nfloat layer_x_offset = SPHERE_RADIUS;\nfloat layer_y_offset = SPHERE_RADIUS * sqrt(3.0) / 3.0;\n\n// compute the sphere centers\nvec3 getInitialPosition(int index) {\n    int posIndex = index / 2;\n    int searchIndex = 0;\n    int z = 0;\n    int y = 0;\n    int x = 0;\n    \n    int size = spheres.length();\n    for (int i; i < size; i++) {\n        int s = spheres[i];\n        \n        // gap of spheres - count in x/y/z but not in index\n        if (s < 0) {\n            x += -s;\n        }\n        // define spheres - count in x/y/z and index\n        else {\n            x += s;\n            searchIndex += s;\n        }\n        \n        // iterate rows and layers\n        if (x >= X_SIZE) {\n            x = x - X_SIZE;\n            y++;\n\n            if (y >= Y_SIZE) {\n                y = y - Y_SIZE;\n                z++;\n            }\n        }\n        \n        // if sphere is found, compute its coordinates\n        if (searchIndex > posIndex) {\n            x = x - (searchIndex - posIndex);\n\n            float vx = (float(x) * 2.0 * SPHERE_RADIUS) + \n            (mod(float(y), 2.0) * row_offset) + \n            (mod(float(z), 2.0) * layer_x_offset) - 1.0;\n            \n            float vy = (float(y) * SPHERE_RADIUS * sqrt(3.0)) +\n            (mod(float(z), 2.0) * layer_y_offset) - 1.0;\n            \n            float vz = float(z) * layer_z_offset - 1.0;\n            return vec3(vx, vy, vz);\n        }\n    }\n    \n    // should only happen if invalid sphere packing\n    return vec3(20.0, 20.0, 20.0);\n}\n\n// Getting the initial velocity randomly\nvec3 getInitialVelocity(int index) {\n    return vec3(\n        fract(sin(float(index) * 12.9238) * 438.5453) * 2.0 - 1.0,\n        fract(cos(float(index) * 4.1514) * 48.2486) * 2.0 - 1.0,\n        fract(sin(float(index) * 7.2213) * 45.5411) * 2.0 - 1.0\n    ) * 1.0;\n}\n\n// Getting the color for each sphere - using HSL so that only 1 float is needed\nfloat getInitialColor(int index) {\n    float h = fract(sin(float(index) * 1.5281) * 45.1445);\n    h = h * 360.0;\n    return h;\n}\n\n// render to buffer the sphere positions and velocities\n// requires at least NUM_SPHERES * 2 pixels on the screen\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    ivec2 fragCoordInt = ivec2(fragCoord.xy);\n    \n    // sphere index - i is for position and color, i + 1 is for velocity and time\n    int index = fragCoordInt.x + fragCoordInt.y * int(iResolution.x);\n    if (index < NUM_SPHERES * 2) {\n        vec4 data = texelFetch(iChannel0, fragCoordInt, 0);\n        int modu = index % 2;\n\n        if (iFrame == 0) {\n            // position + color\n            if (modu == 0) {\n                fragColor = vec4(getInitialPosition(index), getInitialColor(index));\n            }\n            \n            // velocity + time\n            else {\n                fragColor = vec4(getInitialVelocity(index), 0.0);\n            }\n        } else {\n            // position + color\n            if (modu == 0) {\n                vec3 pos = data.xyz;\n                ivec2 fragCoordIntAdjusted = fragCoordInt;\n                fragCoordIntAdjusted.x = (fragCoordIntAdjusted.x + 1) % int(iResolution.x);\n                fragCoordIntAdjusted.y = (fragCoordIntAdjusted.x + 1) / int(iResolution.x);\n                \n                // interpolation mode\n                if (sign(iMouse.z) > 0.0 || sign(iMouse.w) > 0.0) {\n                    float t = texelFetch(iChannel0, fragCoordIntAdjusted, 0).w;\n                    pos = mix(pos, getInitialPosition(index), t * SPHERE_RETURN_SPEED);\n                }\n                \n                // velocity mode\n                else {\n                    vec3 vel = texelFetch(iChannel0, fragCoordIntAdjusted, 0).xyz;\n                    pos += vel * iTimeDelta;\n                }\n                \n                fragColor = vec4(pos, data.w);\n            }\n            \n            // velocity + time\n            else {\n                vec3 pos = texelFetch(iChannel0, ivec2(index % int(iResolution.x), index / int(iResolution.x)), 0).xyz;\n                vec3 vel = data.xyz;\n                float w = data.w;\n                \n                // interpolation mode\n                if (sign(iMouse.z) > 0.0 || sign(iMouse.w) > 0.0) {\n                    vel = vec3(0.0);\n                    w += iTimeDelta;\n                }\n                \n                // velocity mode\n                else {\n                    vel = getInitialVelocity(index);\n                    w = 0.0;\n                }\n                fragColor = vec4(vel, w);\n            }\n        }\n    } else {\n        fragColor = vec4(0.0);\n    }\n}\n","name":"Buffer A","description":"","type":"buffer"}]}