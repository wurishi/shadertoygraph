{"ver":"0.1","info":{"id":"3dXBzs","date":"1588833744","viewed":316,"name":"bicubic nearest neigbour","username":"sh1boot","description":"Thought it might be the beginning of a simple pixel art scaler.\n\nDrag mouse to compare with nearest neighbour.","likes":3,"published":3,"flags":0,"usePreview":0,"tags":["pixelartscaler"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xsf3Rn","filepath":"/media/a/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png","previewfilepath":"/media/ap/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float score(vec4 a, vec4 b, float d) {\n    // TODO: be smarter\n\treturn distance(a, b);\n}\n\nvec2 zoom(vec2 uv) {\n    const vec2 window = vec2(32.,24.);\n    vec2 range = max(vec2(1.), iResolution.xy - window);\n    vec2 t = vec2(4.0, 4.1) * iTime / iResolution.xy;\n\tuv = uv * window / iResolution.xy;\n    uv += (vec2(sin(t.x), cos(t.y)) + vec2(1.)) * 0.5 * range;\n    return uv;\n}\n\nvec4 cubic(vec4 A, vec4 B, vec4 C, vec4 D, float t) {\n\tfloat t2 = t * t;\n    float t3 = t * t * t;\n    vec4 a = .5 * (-A + 3. * B - 3. * C + D);\n    vec4 b = A - 2.5 * B + 2. * C - .5 * D;\n    vec4 c = .5 * (C - A);\n   \tvec4 d = B;\n    \n    return a*t3 + b*t2 + c*t + d;\n}\n\nvoid swap(inout float s0, inout float s1, inout vec4 n0, inout vec4 n1) {\n    float ts = s1;\n    s1 = s0;\n    s0 = ts;\n    vec4 tn = n1;\n    n1 = n0;\n    n0 = tn;\n}\n\nvoid sort(inout float s0, inout float s1, inout vec4 n0, inout vec4 n1) {\n    if (s0 > s1) swap(s0, s1, n0, n1);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = zoom(fragCoord);\n\n    vec4 n[20];\n    float d[20];\n    for (int i = 0; i < 4; ++i) {\n        for (int j = 0; j < 4; ++j) {\n            int k = i * 5 + j;\n            vec2 ij = vec2(float(j), float(i)) - vec2(2.0);\n            n[k] = texture(iChannel0, (floor(uv + ij) + 0.5) / iChannelResolution[0].xy);\n            d[k] = distance(floor(uv + ij) + 1., uv);\n        }\n        // TODO: save the real colours somewhere, and then \"palettise\" this\n        // buffer with similarity metrics from each of the four corners.\n        // This should result in the bicubic interpolation explicitly interpolating\n        // between corners rather than passing through an arbitrary space and using\n        // arbitrary distance metrics.  Then the final blend may be each corner weighted\n        // by the interpolated similarities, or something like that.\n        n[i * 5 + 4] = cubic(n[i * 5 + 0], n[i * 5 + 1], n[i * 5 + 2], n[i * 5 + 3], fract(uv.x));\n    }\n    vec4 interp = cubic(n[4], n[9], n[14], n[19], fract(uv.y));\n    n[0] = n[6];\n    n[1] = n[7];\n    n[2] = n[11];\n    n[3] = n[12];\n    d[0] = d[6];\n    d[1] = d[7];\n    d[2] = d[11];\n    d[3] = d[12];\n\n    float s[4];\n    for (int i = 0; i < 4; ++i) {\n        s[i] = score(interp, n[i], d[i]);\n    }\n\n\n    sort(s[0], s[2], n[0], n[2]);\n    sort(s[1], s[3], n[1], n[3]);\n    sort(s[0], s[1], n[0], n[1]);\n    sort(s[2], s[3], n[2], n[3]);\n    sort(s[1], s[2], n[1], n[2]);\n\n    vec4 o = n[0];\n\n    vec4 m = iMouse;\n    m.w = abs(m.w);  // discard click event\n    if (m.z > 0. && m.w > 0.) {\n        m = vec4(min(m.xy, m.zw), max(m.xy, m.zw));\n        if (m.x < fragCoord.x && fragCoord.x < m.z\n            && m.y < fragCoord.y && fragCoord.y < m.w) {\n#if 1\n            o = fract(uv.y) < 0.5\n                ? fract(uv.x) < 0.5 ? n[6] : n[7]\n                : fract(uv.x) < 0.5 ? n[11] : n[12];\n#else\n            o = vec4(fract(uv.y) < 0.5\n                ? fract(uv.x) < 0.5 ? d[6] : d[7]\n                : fract(uv.x) < 0.5 ? d[11] : d[12]);\n#endif\n            vec2 box = smoothstep(0.05, 1.10, abs(fragCoord - m.xy))\n                     * smoothstep(0.05, 1.10, abs(fragCoord - m.zw));\n            o *= box.x * box.y;\n        }\n        vec2 grid = smoothstep(0.05, 0.10, fract(uv));\n        o *= grid.x * grid.y;\n    }\n\n    fragColor = o;\n}","name":"Image","description":"","type":"image"}]}