{"ver":"0.1","info":{"id":"fdXXWH","date":"1618607284","viewed":991,"name":"White Drops","username":"Xor","description":"Is it milk? I don't know. I just think it looks cool","likes":45,"published":1,"flags":0,"usePreview":0,"tags":["liquid","ripple","droplets"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Anti-Aliasing (SSAA). Use 1.0 on slower computers\n#define AA 2.\n\n//Background gradient\nvec3 background(vec3 d)\n{\n    float light = dot(d,sqrt(vec3(.3,.5,.2)));\n    \n    return vec3(max(light*.5+.5,.0));\n}\n//Smooth minimum (based off IQ's work)\nfloat smin(float d1, float d2)\n{\n    const float e = -6.;\n    return log(exp(d1*e)+exp(d2*e))/e;\n}\n//Ripple and drop distance function\nfloat dist(vec3 p)\n{\n    float l = pow(dot(p.xz,p.xz),.8);\n    float ripple = p.y+.8+.4*sin(l*3.-iTime+.5)/(1.+l);\n    \n    float h1 = -sin(iTime);\n    float h2 = cos(iTime+.1);\n    float drop = length(p+vec3(0,1.2,0)*h1)-.4;\n    drop = smin(drop,length(p+vec3(.1,.8,0)*h2)-.2);\n    return smin(ripple,drop);\n}\n//Typical SDF normal function\nvec3 normal(vec3 p)\n{\n    vec2 e = vec2(1,-1)*.01;\n    \n    return normalize(dist(p-e.yxx)*e.yxx+dist(p-e.xyx)*e.xyx+\n    dist(p-e.xxy)*e.xxy+dist(p-e.y)*e.y);\n}\n//Basic raymarcher\nvec4 march(vec3 p, vec3 d)\n{\n    vec4 m = vec4(p,0);\n    for(int i = 0; i<99; i++)\n    {\n        float s = dist(m.xyz);\n        m += vec4(d,1)*s;\n        \n        if (s<.01 || m.w>20.) break;\n    }\n    return m;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 res = iResolution.xy;\n    vec3 col = vec3(0);\n    \n    vec3 pos = vec3(.05*cos(iTime),.1*sin(iTime),-4);\n    vec3 lig = sqrt(vec3(.3,.5,.2));\n    \n    //Sample\n    for(float x = 0.;x<AA;x++)\n    for(float y = 0.;y<AA;y++)\n    {\n        vec3 ray = normalize(vec3(fragCoord-res/2.+vec2(x,y)/AA,res.y));\n        vec4 mar = march(pos,ray);\n        vec3 nor = normal(mar.xyz);\n        vec3 ref = refract(ray,nor,.75);\n        float r = smoothstep(.8,1.,dot(reflect(ray,nor),lig));\n        float l = 1.-dot(ray,nor);\n        vec3 wat = background(ref)+.3*r*l*l;\n        vec3 bac = background(ray)*.5+.5;\n\n        float fade = pow(min(mar.w/20.,1.),.3);\n        col += mix(wat,bac,fade);\n    }\n    col /= AA*AA;\n\n    fragColor = vec4(col*col,1);\n}","name":"Image","description":"","type":"image"}]}