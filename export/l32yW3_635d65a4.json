{"ver":"0.1","info":{"id":"l32yW3","date":"1728523675","viewed":25,"name":"Hex interpolation","username":"FordPerfect","description":"Implementation several hexagon-based interpolation primitives.","likes":2,"published":3,"flags":0,"usePreview":0,"tags":["filter","spline","hexagon","interpolation","hexspline","boxspline"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Public Domain under http://unlicense.org, see link for details.\n\n// Implementation of several hexagon-based interpolation primitives.\n// Clockwise, from the top:\n//     1st order hex-spline (nearest sampling)\n//     linear-dithered sampling\n//     1st order box-spline (linear sampling)\n//     2nd order hex-spline\n//     2nd order box-spline (non-interpolating: blurs at gridpoints)\n// NOTE: this is largely based on box-splines and hex-splines of\n// Laurent Condat, Dimitri Van De Ville et al., see\n//     L. Condat, D. Van De Ville, \"Three-Directional Box-Splines: Characterization and Efficient Evaluation,\" IEEE Signal Processing Letters, vol. 13, no. 7, pp. 417–420, July 2006.\n//         https://bigwww.epfl.ch/publications/condat0601.html\n//     Dimitri Van De Ville, Thierry Blu, Michael Unser, Wilfried Philips, Ignace Lemahieu, Rik Van de Walle, \"Hex-splines: A novel spline family for hexagonal lattices,\" IEEE Transactions on Image Processing, 13(6), pp. 758-772, June 2004.\n//         https://bigwww.epfl.ch/publications/vandeville0402.html\n// and also\n//     https://bigwww.epfl.ch/demo/hexsplines/\n// which contains the following disclaimer:\n//\n//     Important note:\n//     You are free to use this software for research purposes, but you\n//     should not redistribute it without our consent. In addition,\n//     we expect you to include adequate citations and acknowledgments\n//     whenever you present or publish results that are based on it.\n//\n// While this shader does not use the software (Maple worksheets)\n// in question at all (it is either based on code snippets in above papers,\n// or rederived from scratch), do be warned of potential licensing issues\n// (it is probably good idea to credit the original authors regardless).\n\n// Interpolation involves taking a function G, defined on a discrete set of\n// points (hexagonal grid in our case), and constructing a function F,\n// of continuous argument, that agrees with it in some sense. It is convenient\n// to express interpolation (and such) in terms of kernel K, so that\n//     F(r) = Σ K(r-c[i])*G(c[i])\n// where sum is taken over all (potentially infinite number of) grid points\n// (c[i] being their coordinates).\n//\n// We use cube coordinate system (see https://www.redblobgames.com/grids/hexagons/\n// for context), namely a plane\n//     x+y+z=0\n// with hex centers being at all-integer points on it.\n// Note that this differs from the coordinate system used in the papers. In\n// particular, the distance between neighbour cells' centers is sqrt(2),\n// neighbours of (0,0,0) being 6 permutations of (+1,0,-1).\n//\n// We use low-order hex- and box-splines as kernels.\n//\n// Hex-splines, based on\n//     Dimitri Van De Ville, Thierry Blu, Michael Unser, Wilfried Philips, Ignace Lemahieu, Rik Van de Walle, \"Hex-splines: A novel spline family for hexagonal lattices,\" IEEE Transactions on Image Processing, 13(6), pp. 758-772, June 2004.\n//         https://bigwww.epfl.ch/publications/vandeville0402.html\n// The 1st order hex-spline is an indicator function of the hex (Voronoi cell),\n// i.e. it is 1 inside, and 0 outside (on borders, the paper defines it\n// to use averaging, but consistent tie-breaking should work as well).\n// The higher-order hex-splines are defined as convolution:\n//     hexspline[n+1]=conv(hexspline[n],hexspline1)/S\n// where S is the area of the hex. In partticular, the 2nd order hexspline is\n// a fraction of hexagon's area that overlaps its shifted copy.\n//\n// Box-splines, based on\n//     L. Condat, D. Van De Ville, \"Three-Directional Box-Splines: Characterization and Efficient Evaluation,\" IEEE Signal Processing Letters, vol. 13, no. 7, pp. 417–420, July 2006.\n//         https://bigwww.epfl.ch/publications/condat0601.html\n// The 1st order box-spline is a hexagonal pyramid (when placed at hex's center,\n// its base's vertices coincide with neighbors' centers)\n// The higher-order box-splines are defined as convolution:\n//     boxspline[n+1]=conv(boxspline[n],boxspline1)/S\n// where S is the area of the hex.\n//\n// Interpolation with 1st and 2nd order hex-splines and 1st order box-splines\n// is exact at gridpoints: F(c[i])=G(c[i]) for all i, but that's not the case\n// for higher orders. Sometimes, resulting blur is what you want, but if not,\n// the papers suggest using discrete prefiltering, i.e. replacing G with such\n// G' that when blurred it produces exactly G at gridpoints.\n// Note that such prefiltering is not local: the result at gridpoint depends\n// on entire input G.\n//\n// Besides spline interpolation, a function for (linear) dithering on a\n// hexagonal grid is also provided (see https://www.shadertoy.com/view/lcf3DN\n// for similar functions on square grid).\n\n//==============================================================================\n// Functions for working with cube coordinates. See\n// https://www.redblobgames.com/grids/hexagons/ and\n// https://www.shadertoy.com/view/dtySDy.\n\n// NOTE: due to x+y+z=0 the following identities hold:\n//    dot(abs(v),vec3(1)) = 2*max3(abs(v))\n//    max3(abs(v-v.yzx))  = 2*max3(abs(v))-min3(abs(v))\n//    min3(abs(v-v.yzx))  = max3(abs(v))-2*min3(abs(v))\n\nvec3 xy2hex(vec2 xy)\n{\n    return vec3(+sqrt(0.5)*xy.x-sqrt(1.0/6.0)*xy.y,\n                                sqrt(2.0/3.0)*xy.y,\n                -sqrt(0.5)*xy.x-sqrt(1.0/6.0)*xy.y);\n}\n\nvec2 hex2xy(vec3 hex)\n{\n    return vec2(sqrt(1.0/2.0)*(hex.x-hex.z),sqrt(3.0/2.0)*hex.y);\n}\n\nvec3 hexround(vec3 hex)\n{\n    float xy=floor(hex.x-hex.y);\n    float yz=floor(hex.y-hex.z);\n    float zx=floor(hex.z-hex.x);\n    float q=round((zx-xy)/3.0);\n    float r=round((xy-yz)/3.0);\n    float s=-q-r;\n    return -vec3(q,r,s);\n}\n\nfloat min3(vec3 v) {return min(min(v.x,v.y),v.z);}\nfloat max3(vec3 v) {return max(max(v.x,v.y),v.z);}\n\n//==============================================================================\n// Hex-splines. Based on\n//     Dimitri Van De Ville, Thierry Blu, Michael Unser, Wilfried Philips, Ignace Lemahieu, Rik Van de Walle, \"Hex-splines: A novel spline family for hexagonal lattices,\" IEEE Transactions on Image Processing, 13(6), pp. 758-772, June 2004.\n//         https://bigwww.epfl.ch/publications/vandeville0402.html\n\nfloat hexspline1(vec3 hex)\n{\n    return step(max3(abs(hex-hex.yzx)),1.0);\n}\n\nfloat hexspline2(vec3 hex)\n{\n    float l=min3(abs(hex)),h=max3(abs(hex));\n    if(2.0*h-l>2.0) return 0.0;\n    if(l+h>1.0) return (l+h-2.0)*(2.0*h-l-2.0)/3.0;\n    return 1.0-(2.0*l*(l-1.0)+h*(l-h+4.0))/3.0;\n}\n\n//==============================================================================\n// Box-splines. Based on\n//     L. Condat, D. Van De Ville, \"Three-Directional Box-Splines: Characterization and Efficient Evaluation,\" IEEE Signal Processing Letters, vol. 13, no. 7, pp. 417–420, July 2006.\n//         https://bigwww.epfl.ch/publications/condat0601.html\n\nfloat boxspline1(vec3 hex)\n{\n    return max(1.0-max3(abs(hex)),0.0);\n}\n\n// Based on C code provided in the abopve paper.\nfloat boxspline2(vec3 hex)\n{\n    float l=min3(abs(hex)),h=max3(abs(hex));\n    if (h>2.0) return 0.0;\n    if (h<1.0) return (l*(l*(l*(2.0*l-4.0*h)+12.0*h-12.0)+h*(h*(2.0*h-12.0)+12.0))+h*h*((8.0-h)*h-12.0)+6.0)/12.0;\n    if (h-l>1.0) return (h-2.0)*(h-2.0)*(h-2.0)*(0.5*h-l-1.0)/6.0;\n    return (l*(l*(l*(2.0*l-4.0*h)+12.0*h-12.0)+h*(h*(2.0*h-12.0)+12.0))+h*((4.0-h)*h*h-12.0)+10.0)/12.0;\n}\n\n//==============================================================================\n// Function to interpolate.\n\n// Underlying continuous function.\nvec4 F(vec3 hex)\n{\n    vec4 ret=textureLod(iChannel0,2.0*hex2xy(hex)/vec2(textureSize(iChannel0,0))+0.5,0.0);\n    ret.rgb=mix(ret.rgb/12.92,pow((ret.rgb+0.055)/1.055,vec3(2.4)),step(0.04045,ret.rgb)); // sRGB->linear.\n    return ret;\n}\n\n// And its discrete sampling on a grid.\nvec4 G(ivec3 hex)\n{\n    // return vec4(1.0);           // Debug: partition of unity.\n    // return vec4(hex==ivec3(0)); // Debug: shape of the kernel.\n    return F(vec3(hex));\n}\n\n//==============================================================================\n// Interpolation filters.\n\n// Interpolation with hexspline1 kernel, optimized.\n// Equivalent to point sampling.\nvec4 G_hex1(vec3 hex)\n{\n    return G(ivec3(hexround(hex)));\n}\n\n// Interpolation with boxspline1 kernel, optimized.\n// Equivalent to linear sampling.\nvec4 G_box1(vec3 hex)\n{\n    ivec3 r=ivec3(floor(hex));\n    int s=1-2*((r.x+r.y+r.z)&1);\n    r+=max(s,0);\n    vec3 w=abs(hex-vec3(r));\n    return w.x*G(r-ivec3(s,0,0))+\n           w.y*G(r-ivec3(0,s,0))+\n           w.z*G(r-ivec3(0,0,s));\n}\n\n// Interpolation with hexspline2 kernel, not optimized.\nvec4 G_hex2(vec3 hex)\n{\n    // NOTE: the hexspline2 kernel is non-zero in at most\n    // 4 sampling points.\n    // However trying evaluating only on these points seems\n    // to result in considerably slower GLSL than the\n    // starightforward 7-point code below.\n    vec4 ret=vec4(0);\n    ivec3 r=ivec3(hexround(hex));\n    for(int y=-1;y<=+1;++y)\n        for(int x=-1-min(y,0);x<=+1-max(y,0);++x)\n            ret+=hexspline2(hex-vec3(r)-vec3(x,y,-x-y))*G(r+ivec3(x,y,-x-y));\n    return ret;\n}\n\n// Interpolation with boxspline2 kernel, not optimized.\nvec4 G_box2(vec3 hex)\n{\n    // NOTE: the boxspline2 kernel is non-zero in at most\n    // 12 sampling points. For point within dgh triangle,\n    // they are:\n    //     a b\n    //    c d e\n    //   f g h i\n    //    j k l\n    // However trying evaluating only on these points seems\n    // to result in considerably slower GLSL than the\n    // starightforward 19-point code below.\n    vec4 ret=vec4(0);\n    ivec3 r=ivec3(hexround(hex));\n    for(int y=-2;y<=+2;++y)\n        for(int x=-2-min(y,0);x<=+2-max(y,0);++x)\n            ret+=boxspline2(hex-vec3(r)-vec3(x,y,-x-y))*G(r+ivec3(x,y,-x-y));\n    return ret;\n}\n\n//==============================================================================\n// Dithering.\n\nvec4 G_linear_dither(vec3 hex,float rnd)\n{\n    ivec3 r=ivec3(floor(hex));\n    int s=1-2*((r.x+r.y+r.z)&1);\n    r+=max(s,0);\n    vec3 w=abs(hex-vec3(r));\n    r[int(rnd>w.x)+int(rnd>w.x+w.y)]-=s;\n    return G(r);\n}\n\n//==============================================================================\n// Hash function (for dithering).\n// See https://www.shadertoy.com/view/dllSW7.\n\nuint hash(uint x)\n{\n    x^=x>>15;\n    x^=(x*x)|1u;\n    x^=x>>17;\n    x*=0x9E3779B9u;\n    x^=x>>13;\n    return x;\n}\n\n//==============================================================================\n// Main image.\n\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord)\n{\n    vec2 R=(2.0*fragCoord-iResolution.xy)/min(iResolution.x,iResolution.y);\n    vec3 col=vec3(0.5);\n    float s=exp2(4.0+2.0*sin(0.125*iTime));\n    vec2 r=s*R;\n    vec3 v=xy2hex(r);\n    vec3 k=hexround(v);\n    vec3 f=v-k;\n    if(length(R)<0.5)\n    {\n        col=F(xy2hex(r)).xyz;\n    }\n    else\n    {\n        const float pi=3.14159265358979;\n        float a=atan(-r.y,r.x)+2.7*pi;\n        switch(int(2.5*a/pi)%5)\n        {\n            case 0: col=G_hex1(v).rgb; break;\n            case 1: col=G_linear_dither(v,float(hash(uint(fragCoord.x)+65536u*uint(fragCoord.y)))*exp2(-32.0)).rgb; break;\n            case 2: col=G_box1(v).rgb; break;\n            case 3: col=G_hex2(v).rgb; break;\n            case 4: col=G_box2(v).rgb; break;\n        }\n        col=mix(col,vec3(0.2,0.7,0.2),smoothstep(5.0*fwidth(length(r)),0.0,length(r)*abs(sin(2.5*a))));\n    }\n    col=mix(col,vec3(0.2,0.7,0.2),smoothstep(2.0*length(fwidth(R)),0.0,abs(length(R)-0.5)));\n    col=mix(12.92*col,1.055*pow(col,vec3(1.0/2.4))-0.055,step(0.0031308,col)); // linear->sRGB.\n    fragColor=vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}