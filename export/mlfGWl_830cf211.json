{"ver":"0.1","info":{"id":"mlfGWl","date":"1672644446","viewed":248,"name":"moonwaves","username":"OscarSaharoy","description":"line of reflection of moon on sea\nneeds antialiasing\nhttps://github.com/OscarSaharoy/moonwaves","likes":22,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","sea","moon","scene"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n\n#define t iTime\n#define pi 3.14159265359\n#define n normalize\n#define failure vec3(-1)\n\n\nfloat saturate( float x ) {\n\n        return clamp( x, 0., 1. );\n}\n\nfloat hash( float x ) {\n\n        return fract(sin(x) * 43758.5453123);\n}\n\n\nfloat wave( float x ) {\n\n        // remap domain\n        float rx = mod( x, 2.*pi );\n        rx -= 2. * (rx-pi) * step(pi, rx);\n\n        // coefficients from wave.c\n        float m = 5.;\n        float n = .2;\n        float a = 0.947154;\n        float b = -0.165649;\n        float c = 8.876987;\n        float k = -7.711339;\n\n        // wave function\n        return a*rx + b*exp(-m*rx) + c*exp(-n*rx) + k;\n}\n\nfloat dwave( float x ) {\n\n        // remap domain\n        float rx = mod( x, 2.*pi );\n        float drxdx = 1. - step(pi, rx) * 2.;\n        rx -= 2. * (rx-pi) * step(pi, rx);\n\n        // coefficients from wave.c\n        float m = 5.;\n        float n = .2;\n        float a = 0.947154;\n        float b = -0.165649;\n        float c = 8.876987;\n        float k = -7.711339;\n\n        // differential of wave function\n        return\n                ( a + -b*m*exp(-m*rx) + -c*n*exp(-n*rx) )\n                * drxdx;\n}\n\n\nfloat waves( vec2 p ) {\n\n        float r = 0.;\n\n        float f = 1.;\n        float a = .1;\n\n        for( float i = 0.; i<4.; ++i ) {\n\n                float o = hash(i) * 10.;\n                vec2 d = n(vec2( hash(i+.1), hash(i+.2)*.2 ));\n                float s = dot(d,p) * f + o - f*t;\n\n                r += wave( s ) * a;\n\n                float m = 1.05;\n\n                f = f * m;\n                a = a / m;\n        }\n\n        return r;\n}\n\nvec2 dwaves( vec2 p ) {\n\n        vec2 dr = vec2(0);\n\n        float f = 1.;\n        float a = .1;\n\n        // r = sum_i wave(s_i)\n\n        for( float i = 0.; i<4.; ++i ) {\n\n                float o = hash(i) * 10.;\n                vec2 d = n(vec2( hash(i+.1), hash(i+.2)*.2 ));\n\n                float s = dot(d,p) * f + o - f*t;\n\n                // d(wavei + waves) = dwavei + dwaves\n\n                dr += dwave(s) * a * f * d;\n\n                float m = 1.05;\n\n                f = f * m;\n                a = a / m;\n        }\n\n        return dr;\n}\n\nvec3 intPlane( vec3 ro, vec3 rd, vec4 plane ) {\n\n        float t = ( dot(ro, plane.xyz) - plane.w )\n                / -dot(rd, plane.xyz);\n\n        if( t < 0. ) return failure;\n        return ro + t * rd;\n}\n\nvec3 marchWaves( vec3 ro, vec3 rd ) {\n\n        vec4 surfPlane = vec4(0,1,0,0);\n        if( intPlane( ro, rd, surfPlane ) == failure )\n                return failure;\n\n        vec3 p = ro;\n\n        for( float i = 0.; i<100.; ++i ) {\n\n                float d = p.y - waves(p.xz);\n\n                if( d < .01 ) return p;\n\n                p += d*rd;\n        }\n\n        return p;\n}\n\nfloat moon( vec3 rd ) {\n\n        float a = dot( rd, n(vec3(-.8,.1,0.)) );\n        return .015/sqrt(1.-a) + .1*exp(-abs(rd.y)*10.) + hash(rd.y+hash(rd.z))*1e-2;\n}\n\nvoid mainImage(\n                out vec4 fragColor, in vec2 fragCoord ) {\n\n        vec3 light = vec3(0);\n\n        vec2 p = ( fragCoord - iResolution.xy * .5 )\n                / min(iResolution.x, iResolution.y) * 2.;\n\n        vec3 rd = n(vec3( p.x, p.y, -2. ));\n        rd = rd.zyx;\n        vec3 ro = vec3( 0., 1., 0. );\n\n        vec3 wavesPos = marchWaves( ro, rd );\n\n        if( wavesPos != failure ) {\n\n                vec2 ddxddz = dwaves( wavesPos.xz );\n\n                vec3 ddx = vec3( 1., ddxddz.x, 0. );\n                vec3 ddz = vec3( 0., ddxddz.y, 1. );\n                vec3 normal = n(cross( ddz, ddx ));\n\n                vec3 refl = rd - 2.*normal * dot(rd,normal);\n                light += moon(refl) * exp( -.02*length(wavesPos) );\n        }\n        else {\n\n                light += moon(rd);\n        }\n\n        fragColor = vec4( light, 1. );\n}","name":"Image","description":"","type":"image"}]}