{"ver":"0.1","info":{"id":"MXscWn","date":"1726065495","viewed":11,"name":"SLOW Quasi-Fuchsian Ford circles","username":"Refurio","description":"SLOW VERSION: Quasi-Fuchsian group with generators based on Ford circles.","likes":2,"published":3,"flags":0,"usePreview":0,"tags":["kleinian","maths"],"hasliked":0,"parentid":"X3sczr","parentname":"Quasi-Fuchsian: Ford circles"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nconst int n = 10;\nconst int depth = 100;\n\n////////////////////////////////\n// view port\n////////////////////////////////\nconst vec2 center = vec2(.5,-1.);\nconst float radius = .51;\nconst float angle = radians(0.);\n\nconst float linewidth = 1.5; // in pixels\n\n////////////////////////////////\n// complex arithmetic\n////////////////////////////////\nconst float pi = radians(180.);\nfloat arg(vec2 z) {\n  return atan(z.y, z.x);\n}\nfloat abs2(vec2 z) {\n  return z.x*z.x + z.y*z.y;\n}\nvec2 cmul(vec2 a, vec2 b) {\n  return vec2(a.x*b.x-a.y*b.y, a.x*b.y+a.y*b.x);\n}\n// see my \"Lambert w\" shader for the full set.\n\n////////////////////////////////\n// coloring functions:\n////////////////////////////////\n// https://github.com/hughsk/glsl-hsv2rgb/blob/master/index.glsl\nvec3 hsv(in vec3 c) {\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\nvec3 hsv(float h, float s, float v) {\n  return hsv(vec3(h, s, v));\n}\nvec3 phase(vec2 z) {\n  return hsv(vec3(arg(z)/pi, 1., 1.));\n}\nvec3 axies(vec2 z) {\n  float t = arg(z)/pi;\n  float a = mod(2.*t+2., 2.)-1.;\n  a = abs(2.*a)-1.;\n  a = asin(a)/pi+.5;\n  return vec3(a,a,a);\n}\nvec3 black  = vec3(0.,0.,0.);\nvec3 white  = vec3(1.,1.,1.);\nvec3 red    = vec3(1.,0.,0.);\nvec3 blue   = vec3(.3,.3,1.);\nvec3 orange = vec3(1.,.7,.2);\n\n// convert pixel coordinate to complex plane coordinate\nvec2 p2c(vec2 p) {\n  vec2 wh2 = iResolution.xy/2.;\n  float pr = min(wh2.x, wh2.y);\n  vec2 c = (p - wh2)/pr;\n  vec2 r = radius * vec2(cos(angle), sin(angle));\n  return cmul(r,c) + center;\n}\n\n\n////////////////////////////////\n// oop for geometry\n////////////////////////////////\n\nconst int o_sphere = 0;\nconst int o_line = 1;\nstruct object {\n  int t;\n  vec2 n;\n  float d;\n};\nint no = 0;\n// n*n/2 is an aupper bound for the sum over n of\n// Euler's totient function. That counts the number\n// of proper fractions between 0 and 1 with denominator\n// up to n, and thus the number of Ford circles we need\n// to draw. Then add 1 for the blue line.\nobject[n*n/2+1] o;\n\nvoid sphere(vec2 c, float r) {\n  o[no++] = object(o_sphere, c, r);\n}\nvoid line(vec2 n, float d) {\n  o[no++] = object(o_line, normalize(n), d);\n}\n\n// I got these from https://bulatov.org/math/180110/index.html\n// reflect\nvec2 line_refl(vec2 A, vec2 N, float d) {\n  return A - 2.*dot(A - d*N, N)*N;\n}\n// signed distance\nfloat line_dist(vec2 A, vec2 N, float d) {\n  return dot(A, N) - d;\n}\nvec2 sphere_invert(vec2 A, vec2 C, float r) {\n  return C + r*r/abs2(A-C) * (A-C);\n}\nfloat sphere_dist(vec2 A, vec2 C, float r) {\n  return sign(r)*(length(A-C)-abs(r));\n}\n\nvec2 inv(vec2 A, object o) {\n  if(o.t == o_sphere)\n    return sphere_invert(A, o.n, o.d);\n  return line_refl(A, o.n, o.d);\n}\nfloat dist(vec2 A, object o) {\n  if(o.t == o_sphere)\n    return sphere_dist(A, o.n, o.d);\n  return line_dist(A, o.n, o.d);\n}\n\nfloat osc(float a, float lo, float hi) {\n  return (1.-cos(a*2.*pi))/2.*(hi-lo) + lo;\n}\n\nvoid circle(int p, int q) {\n  float r = .5/float(q*q);\n  sphere(vec2(float(p)/float(q), r-1.), r);\n}\nint gcd(int i, int j) {\n  do {\n    int t = i;\n    i = j;\n    j = t%j;\n  } while(j > 0);\n  return i;\n}\nvoid ford(int n) {\n  circle(0, 1);\n  circle(1, 1);\n  for(int q = 1; q <= n; ++q)\n    for(int p = 1; p < q; ++p)\n      if(gcd(q, p) == 1)\n        circle(p, q);\n}\n\nvec3 f(vec2 z) {\n  float t = iTime;\n  float R = 1.;\n\n  ford(int(osc(.5+iTime/3., 1., float(n)+.9)));\n  line(vec2(0, 1), -1.);\n\n  int i, k;\n  for(i = 0; i < depth; ++i) {\n    for(k = 0; k < no; ++k) {\n      float r = dist(z, o[k]);\n      if(r < 0.) {\n        z = inv(z, o[k]);\n        break;\n      }\n    }\n    if(k == no)\n      break;\n  }\n\n  // outside\n  if(i == depth)\n    return black;\n\n  float s = float(i)/float(depth);\n  s = pow(s,.35);\n  return hsv(.1, 0., 1.-s);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 z = p2c(fragCoord);\n  fragColor = vec4(f(z), 1.);\n  \n  float pixelwidth = min(iResolution.x, iResolution.y)/2./radius;\n  for(int k = 0; k < no; ++k) {\n    float r = abs(dist(z, o[k]));\n    float w = clamp(r/linewidth*pixelwidth, 0., 1.);\n    fragColor = mix(vec4(hsv(float(sign(o[k].d))/3., 1., 1.), 1.), fragColor, w);\n  }\n}\n","name":"Image","description":"","type":"image"}]}