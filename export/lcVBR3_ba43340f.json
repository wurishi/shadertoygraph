{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[{"channel":0,"type":"cubemap","id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"}},{"channel":1,"type":"cubemap","id":"4sfGzn","filepath":"/media/a/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png","sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"}}],"code":"//A new material maker operator\n//SDF and texture is displaced by TEX3D\n\n// Made in Material Maker\n//\n// Code generate in Material Maker not optimized, or simplified \n//\n\n\n#define SEED_VARIATION 0.0\n\nfloat dot2(vec2 x) {\n\treturn dot(x, x);\n}\n\nfloat rand(vec2 x) {\n    return fract(cos(mod(dot(x, vec2(13.9898, 8.141)), 3.14)) * 43758.5453);\n}\n\nvec2 rand2(vec2 x) {\n    return fract(cos(mod(vec2(dot(x, vec2(13.9898, 8.141)),\n\t\t\t\t\t\t      dot(x, vec2(3.4562, 17.398))), vec2(3.14))) * 43758.5453);\n}\n\nvec3 rand3(vec2 x) {\n    return fract(cos(mod(vec3(dot(x, vec2(13.9898, 8.141)),\n\t\t\t\t\t\t\t  dot(x, vec2(3.4562, 17.398)),\n                              dot(x, vec2(13.254, 5.867))), vec3(3.14))) * 43758.5453);\n}\n\nvec3 rgb2hsv(vec3 c) {\n\tvec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n\tvec4 p = c.g < c.b ? vec4(c.bg, K.wz) : vec4(c.gb, K.xy);\n\tvec4 q = c.r < p.x ? vec4(p.xyw, c.r) : vec4(c.r, p.yzx);\n\n\tfloat d = q.x - min(q.w, q.y);\n\tfloat e = 1.0e-10;\n\treturn vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\nvec3 hsv2rgb(vec3 c) {\n\tvec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n\tvec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n\treturn c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nfloat param_rnd(float minimum, float maximum, float seed) {\n\treturn minimum+(maximum-minimum)*rand(vec2(seed));\n}\n\nfloat param_rndi(float minimum, float maximum, float seed) {\n\treturn floor(param_rnd(minimum, maximum + 1.0, seed));\n}\nfloat wave_constant(float x) {\n\treturn 1.0;\n}\n\nfloat wave_sine(float x) {\n\treturn 0.5-0.5*cos(3.14159265359*2.0*x);\n}\n\nfloat wave_triangle(float x) {\n\tx = fract(x);\n\treturn min(2.0*x, 2.0-2.0*x);\n}\n\nfloat wave_sawtooth(float x) {\n\treturn fract(x);\n}\n\nfloat wave_square(float x) {\n\treturn (fract(x) < 0.5) ? 0.0 : 1.0;\n}\n\nfloat wave_bounce(float x) {\n\tx = 2.0*(fract(x)-0.5);\n\treturn sqrt(1.0-x*x);\n}\n\nfloat mix_mul(float x, float y) {\n\treturn x*y;\n}\n\nfloat mix_add(float x, float y) {\n\treturn min(x+y, 1.0);\n}\n\nfloat mix_max(float x, float y) {\n\treturn max(x, y);\n}\n\nfloat mix_min(float x, float y) {\n\treturn min(x, y);\n}\n\nfloat mix_xor(float x, float y) {\n\treturn min(x+y, 2.0-x-y);\n}\n\nfloat mix_pow(float x, float y) {\n\treturn pow(x, y);\n}float mix3d_mul(float x, float y, float z) {\n\treturn x*y*z;\n}\n\nfloat mix3d_add(float x, float y, float z) {\n\treturn min(x+y+z, 1.0);\n}\n\nfloat mix3d_max(float x, float y, float z) {\n\treturn max(max(x, y), z);\n}\n\nfloat mix3d_min(float x, float y, float z) {\n\treturn min(min(x, y), z);\n}\n\nfloat mix3d_xor(float x, float y, float z) {\n\tfloat xy = min(x+y, 2.0-x-y);\n\treturn min(xy+z, 2.0-xy-z);\n}\n\nfloat mix3d_pow(float x, float y, float z) {\n\treturn pow(pow(x, y), z);\n}vec3 MFSDF_Obj_Maker_rotate3d(vec3 p, vec3 a) {\n\tvec3 rv;\n\tfloat c;\n\tfloat s;\n\tc = cos(a.x);\n\ts = sin(a.x);\n\trv.x = p.x;\n\trv.y = p.y*c+p.z*s;\n\trv.z = -p.y*s+p.z*c;\n\tc = cos(a.y);\n\ts = sin(a.y);\n\tp.x = rv.x*c+rv.z*s;\n\tp.y = rv.y;\n\tp.z = -rv.x*s+rv.z*c;\n\tc = cos(a.z);\n\ts = sin(a.z);\n\trv.x = p.x*c+p.y*s;\n\trv.y = -p.x*s+p.y*c;\n\trv.z = p.z;\n\treturn rv;\n}\nfloat rand31(vec3 p) {\n\treturn fract(sin(dot(p,vec3(127.1,311.7, 74.7)))*43758.5453123);\n}\nvec3 rand33(vec3 p){\n\tp = vec3( dot(p,vec3(127.1,311.7, 74.7)),\n\t\t\t  dot(p,vec3(269.5,183.3,246.1)),\n\t\t\t  dot(p,vec3(113.5,271.9,124.6)));\n\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\nfloat tex3d_fbm_value(vec3 coord, vec3 size, float seed) {\n\tvec3 o = floor(coord)+rand3(vec2(seed, 1.0-seed))+size;\n\tvec3 f = fract(coord);\n\tfloat p000 = rand31(mod(o, size));\n\tfloat p001 = rand31(mod(o + vec3(0.0, 0.0, 1.0), size));\n\tfloat p010 = rand31(mod(o + vec3(0.0, 1.0, 0.0), size));\n\tfloat p011 = rand31(mod(o + vec3(0.0, 1.0, 1.0), size));\n\tfloat p100 = rand31(mod(o + vec3(1.0, 0.0, 0.0), size));\n\tfloat p101 = rand31(mod(o + vec3(1.0, 0.0, 1.0), size));\n\tfloat p110 = rand31(mod(o + vec3(1.0, 1.0, 0.0), size));\n\tfloat p111 = rand31(mod(o + vec3(1.0, 1.0, 1.0), size));\n\tvec3 t =  f * f * f * (f * (f * 6.0 - 15.0) + 10.0);\n\treturn mix(mix(mix(p000, p100, t.x), mix(p010, p110, t.x), t.y), mix(mix(p001, p101, t.x), mix(p011, p111, t.x), t.y), t.z);\n}\n\nfloat fbm3d_value(vec3 coord, vec3 size, int octaves, float persistence, float seed) {\n\tfloat normalize_factor = 0.0;\n\tfloat value = 0.0;\n\tfloat scale = 1.0;\n\tfor (int i = 0; i < octaves; i++) {\n\t\tvalue += tex3d_fbm_value(coord*size, size, seed) * scale;\n\t\tnormalize_factor += scale;\n\t\tsize *= 2.0;\n\t\tscale *= persistence;\n\t}\n\treturn value / normalize_factor;\n}\n\nfloat tex3d_fbm_value_nowrap(vec3 coord, vec3 size, float seed) {\n\tvec3 o = floor(coord)+rand3(vec2(seed, 1.0-seed))+size;\n\tvec3 f = fract(coord);\n\tfloat p000 = rand31(o);\n\tfloat p001 = rand31(o + vec3(0.0, 0.0, 1.0));\n\tfloat p010 = rand31(o + vec3(0.0, 1.0, 0.0));\n\tfloat p011 = rand31(o + vec3(0.0, 1.0, 1.0));\n\tfloat p100 = rand31(o + vec3(1.0, 0.0, 0.0));\n\tfloat p101 = rand31(o + vec3(1.0, 0.0, 1.0));\n\tfloat p110 = rand31(o + vec3(1.0, 1.0, 0.0));\n\tfloat p111 = rand31(o + vec3(1.0, 1.0, 1.0));\n\tvec3 t =  f * f * f * (f * (f * 6.0 - 15.0) + 10.0);\n\treturn mix(mix(mix(p000, p100, t.x), mix(p010, p110, t.x), t.y), mix(mix(p001, p101, t.x), mix(p011, p111, t.x), t.y), t.z);\n}\n\nfloat fbm3d_value_nowrap(vec3 coord, vec3 size, int octaves, float persistence, float seed) {\n\tfloat normalize_factor = 0.0;\n\tfloat value = 0.0;\n\tfloat scale = 1.0;\n\tfor (int i = 0; i < octaves; i++) {\n\t\tvalue += tex3d_fbm_value_nowrap(coord*size, size, seed) * scale;\n\t\tnormalize_factor += scale;\n\t\tsize *= 2.0;\n\t\tscale *= persistence;\n\t}\n\treturn value / normalize_factor;\n}\n\nfloat tex3d_fbm_perlin(vec3 coord, vec3 size, float seed) {\n\tvec3 o = floor(coord)+rand3(vec2(seed, 1.0-seed))+size;\n\tvec3 f = fract(coord);\n\tvec3 v000 = normalize(rand33(mod(o, size))-vec3(0.5));\n\tvec3 v001 = normalize(rand33(mod(o + vec3(0.0, 0.0, 1.0), size))-vec3(0.5));\n\tvec3 v010 = normalize(rand33(mod(o + vec3(0.0, 1.0, 0.0), size))-vec3(0.5));\n\tvec3 v011 = normalize(rand33(mod(o + vec3(0.0, 1.0, 1.0), size))-vec3(0.5));\n\tvec3 v100 = normalize(rand33(mod(o + vec3(1.0, 0.0, 0.0), size))-vec3(0.5));\n\tvec3 v101 = normalize(rand33(mod(o + vec3(1.0, 0.0, 1.0), size))-vec3(0.5));\n\tvec3 v110 = normalize(rand33(mod(o + vec3(1.0, 1.0, 0.0), size))-vec3(0.5));\n\tvec3 v111 = normalize(rand33(mod(o + vec3(1.0, 1.0, 1.0), size))-vec3(0.5));\n\tfloat p000 = dot(v000, f);\n\tfloat p001 = dot(v001, f - vec3(0.0, 0.0, 1.0));\n\tfloat p010 = dot(v010, f - vec3(0.0, 1.0, 0.0));\n\tfloat p011 = dot(v011, f - vec3(0.0, 1.0, 1.0));\n\tfloat p100 = dot(v100, f - vec3(1.0, 0.0, 0.0));\n\tfloat p101 = dot(v101, f - vec3(1.0, 0.0, 1.0));\n\tfloat p110 = dot(v110, f - vec3(1.0, 1.0, 0.0));\n\tfloat p111 = dot(v111, f - vec3(1.0, 1.0, 1.0));\n\tvec3 t =  f * f * f * (f * (f * 6.0 - 15.0) + 10.0);\n\treturn 0.5 + mix(mix(mix(p000, p100, t.x), mix(p010, p110, t.x), t.y), mix(mix(p001, p101, t.x), mix(p011, p111, t.x), t.y), t.z);\n}\n\nfloat fbm3d_perlin(vec3 coord, vec3 size, int octaves, float persistence, float seed) {\n\tfloat normalize_factor = 0.0;\n\tfloat value = 0.0;\n\tfloat scale = 1.0;\n\tfor (int i = 0; i < octaves; i++) {\n\t\tvalue += tex3d_fbm_perlin(coord*size, size, seed) * scale;\n\t\tnormalize_factor += scale;\n\t\tsize *= 2.0;\n\t\tscale *= persistence;\n\t}\n\treturn value / normalize_factor;\n}\n\nfloat tex3d_fbm_perlin_nowrap(vec3 coord, vec3 size, float seed) {\n\tvec3 o = floor(coord)+rand3(vec2(seed, 1.0-seed))+size;\n\tvec3 f = fract(coord);\n\tvec3 v000 = normalize(rand33(o)-vec3(0.5));\n\tvec3 v001 = normalize(rand33(o + vec3(0.0, 0.0, 1.0))-vec3(0.5));\n\tvec3 v010 = normalize(rand33(o + vec3(0.0, 1.0, 0.0))-vec3(0.5));\n\tvec3 v011 = normalize(rand33(o + vec3(0.0, 1.0, 1.0))-vec3(0.5));\n\tvec3 v100 = normalize(rand33(o + vec3(1.0, 0.0, 0.0))-vec3(0.5));\n\tvec3 v101 = normalize(rand33(o + vec3(1.0, 0.0, 1.0))-vec3(0.5));\n\tvec3 v110 = normalize(rand33(o + vec3(1.0, 1.0, 0.0))-vec3(0.5));\n\tvec3 v111 = normalize(rand33(o + vec3(1.0, 1.0, 1.0))-vec3(0.5));\n\tfloat p000 = dot(v000, f);\n\tfloat p001 = dot(v001, f - vec3(0.0, 0.0, 1.0));\n\tfloat p010 = dot(v010, f - vec3(0.0, 1.0, 0.0));\n\tfloat p011 = dot(v011, f - vec3(0.0, 1.0, 1.0));\n\tfloat p100 = dot(v100, f - vec3(1.0, 0.0, 0.0));\n\tfloat p101 = dot(v101, f - vec3(1.0, 0.0, 1.0));\n\tfloat p110 = dot(v110, f - vec3(1.0, 1.0, 0.0));\n\tfloat p111 = dot(v111, f - vec3(1.0, 1.0, 1.0));\n\tvec3 t =  f * f * f * (f * (f * 6.0 - 15.0) + 10.0);\n\treturn 0.5 + mix(mix(mix(p000, p100, t.x), mix(p010, p110, t.x), t.y), mix(mix(p001, p101, t.x), mix(p011, p111, t.x), t.y), t.z);\n}\n\nfloat fbm3d_perlin_nowrap(vec3 coord, vec3 size, int octaves, float persistence, float seed) {\n\tfloat normalize_factor = 0.0;\n\tfloat value = 0.0;\n\tfloat scale = 1.0;\n\tfor (int i = 0; i < octaves; i++) {\n\t\tvalue += tex3d_fbm_perlin_nowrap(coord*size, size, seed) * scale;\n\t\tnormalize_factor += scale;\n\t\tsize *= 2.0;\n\t\tscale *= persistence;\n\t}\n\treturn value / normalize_factor;\n}\n\nfloat tex3d_fbm_cellular(vec3 coord, vec3 size, float seed) {\n\tvec3 o = floor(coord)+rand3(vec2(seed, 1.0-seed))+size;\n\tvec3 f = fract(coord);\n\tfloat min_dist = 3.0;\n\tfor (float x = -1.0; x <= 1.0; x++) {\n\t\tfor (float y = -1.0; y <= 1.0; y++) {\n\t\t\tfor (float z = -1.0; z <= 1.0; z++) {\n\t\t\t\tvec3 node = 0.4*rand33(mod(o + vec3(x, y, z), size)) + vec3(x, y, z);\n\t\t\t\tfloat dist = sqrt((f - node).x * (f - node).x + (f - node).y * (f - node).y + (f - node).z * (f - node).z);\n\t\t\t\tmin_dist = min(min_dist, dist);\n\t\t\t}\n\t\t}\n\t}\n\treturn min_dist;\n}\n\nfloat fbm3d_cellular(vec3 coord, vec3 size, int octaves, float persistence, float seed) {\n\tfloat normalize_factor = 0.0;\n\tfloat value = 0.0;\n\tfloat scale = 1.0;\n\tfor (int i = 0; i < octaves; i++) {\n\t\tvalue += tex3d_fbm_cellular(coord*size, size, seed) * scale;\n\t\tnormalize_factor += scale;\n\t\tsize *= 2.0;\n\t\tscale *= persistence;\n\t}\n\treturn value / normalize_factor;\n}\n\nfloat tex3d_fbm_cellular_nowrap(vec3 coord, vec3 size, float seed) {\n\tvec3 o = floor(coord)+rand3(vec2(seed, 1.0-seed))+size;\n\tvec3 f = fract(coord);\n\tfloat min_dist = 3.0;\n\tfor (float x = -1.0; x <= 1.0; x++) {\n\t\tfor (float y = -1.0; y <= 1.0; y++) {\n\t\t\tfor (float z = -1.0; z <= 1.0; z++) {\n\t\t\t\tvec3 node = 0.4*rand33(o + vec3(x, y, z)) + vec3(x, y, z);\n\t\t\t\tfloat dist = sqrt((f - node).x * (f - node).x + (f - node).y * (f - node).y + (f - node).z * (f - node).z);\n\t\t\t\tmin_dist = min(min_dist, dist);\n\t\t\t}\n\t\t}\n\t}\n\treturn min_dist;\n}\n\nfloat fbm3d_cellular_nowrap(vec3 coord, vec3 size, int octaves, float persistence, float seed) {\n\tfloat normalize_factor = 0.0;\n\tfloat value = 0.0;\n\tfloat scale = 1.0;\n\tfor (int i = 0; i < octaves; i++) {\n\t\tvalue += tex3d_fbm_cellular_nowrap(coord*size, size, seed) * scale;\n\t\tnormalize_factor += scale;\n\t\tsize *= 2.0;\n\t\tscale *= persistence;\n\t}\n\treturn value / normalize_factor;\n}\n\nvec3 v4v4_rotate(vec3 p, vec3 a) {\n\tvec3 rv;\n\tfloat c;\n\tfloat s;\n\tc = cos(a.x);\n\ts = sin(a.x);\n\trv.x = p.x;\n\trv.y = p.y*c+p.z*s;\n\trv.z = -p.y*s+p.z*c;\n\tc = cos(a.y);\n\ts = sin(a.y);\n\tp.x = rv.x*c+rv.z*s;\n\tp.y = rv.y;\n\tp.z = -rv.x*s+rv.z*c;\n\tc = cos(a.z);\n\ts = sin(a.z);\n\trv.x = p.x*c+p.y*s;\n\trv.y = -p.x*s+p.y*c;\n\trv.z = p.z;\n\treturn rv;\n}\n\n\n\nconst float p_o7511_LookAtX = 0.000000000;\nconst float p_o7511_LookAtY = 0.000000000;\nconst float p_o7511_LookAtZ = 0.000000000;\nconst float p_o7511_CamD = 1.500000000;\nconst float p_o7511_CamZoom = 1.000000000;\nconst float p_o7511_SunX = -9.801000000;\nconst float p_o7511_SunY = 10.002000000;\nconst float p_o7511_SunZ = -5.570000000;\nconst float p_o7511_AmbLight = 0.250000000;\nconst float p_o7511_AmbOcclusion = 0.000000000;\nconst float p_o7511_Shadow = 1.000000000;\nconst float p_o7511_Gamma = 1.400000000;\nconst float p_o7533_ax = 0.000000000;\nconst float p_o7533_az = 0.000000000;\nconst float p_o7527_Distort = 0.162000000;\nconst float p_o7527_Correction = 0.000000000;\nconst float p_o7527_Bound = 0.000000000;\nconst vec4 p_o7519_BaseColor = vec4(0.792671680, 0.551293612, 0.244781733, 1.000000000);\nconst float p_o7519_Metallic = 1.000000000;\nconst float p_o7519_Specular = 0.500000000;\nconst float p_o7519_Roughness = 0.000000000;\nconst float p_o7519_Emission = 0.000000000;\nconst float p_o7519_scale = 1.000000000;\nconst float p_o7519_TranlateX = 0.000000000;\nconst float p_o7519_TranlateY = 0.000000000;\nconst float p_o7519_TranlateZ = 0.000000000;\nconst float p_o7519_RotateX = 0.000000000;\nconst float p_o7519_RotateY = 0.000000000;\nconst float p_o7519_RotateZ = 0.000000000;\nvec3 o7519_input_BaseColor_tex3d(vec4 p, float _seed_variation_) {\n\nreturn vec3(1.0);\n}\nconst float p_o429172_x_scale = 8.000000000;\nconst float p_o429172_y_scale = 8.000000000;\nconst float p_o429172_z_scale = 8.000000000;\n\nfloat o7519_input_Metallic_tex3d(vec4 p, float _seed_variation_) {\nfloat o429172_0_1_tex3d_gs = mix3d_xor(wave_square(p_o429172_x_scale*(p).x), wave_square(p_o429172_y_scale*(p).y), wave_square(p_o429172_z_scale*(p).z));\n\nreturn o429172_0_1_tex3d_gs;\n}\n\nfloat o7519_input_Specular_tex3d(vec4 p, float _seed_variation_) {\n\nreturn 1.0;\n}\n\nfloat o7519_input_Roughness_tex3d(vec4 p, float _seed_variation_) {\n\nreturn 1.0;\n}\n\nvec3 o7519_input_Emission_tex3d(vec4 p, float _seed_variation_) {\n\nreturn vec3(1.0);\n}\n\nconst float p_o232021_r = 0.400000000;\n\nfloat o7519_input_sdf3d(vec3 p, float _seed_variation_) {\nfloat o232021_0_1_sdf3d = length((p))-p_o232021_r;\n\nreturn o232021_0_1_sdf3d;\n}\n\nvec4 PBRObjectMaker_o7519(vec4 uv, float _seed_variation_) {\n    uv.xyz=MFSDF_Obj_Maker_rotate3d(uv.xyz-vec3(p_o7519_TranlateX,p_o7519_TranlateY,p_o7519_TranlateZ),vec3(p_o7519_RotateX,p_o7519_RotateY,p_o7519_RotateZ)*0.01745329251)/p_o7519_scale;\n\tfloat sdf=o7519_input_sdf3d(uv.xyz, _seed_variation_)*p_o7519_scale;\n\t//13 - Emission\n\tif (uv.w>12.5&&uv.w<13.5) {\n\t\treturn vec4(p_o7519_Emission*o7519_input_Emission_tex3d(vec4(uv.xyz,13.0), _seed_variation_),sdf);\n\t} else\n\t//5 - Roughness\n\tif (uv.w>4.5&&uv.w<5.5) {\n\t\treturn vec4(p_o7519_Roughness*clamp(o7519_input_Roughness_tex3d(vec4(uv.xyz,5.0), _seed_variation_),0.0,1.0),0.0,0.0,sdf);\n\t} else\n\t//4 - Specular\n\tif (uv.w>3.5) {\n\t\treturn vec4(p_o7519_Specular*clamp(o7519_input_Specular_tex3d(vec4(uv.xyz,4.0), _seed_variation_),0.0,1.0),0.0,0.0,sdf);\n\t} else\n\t//2 - Metallic\n\tif (uv.w>1.5&&uv.w<2.5) {\n\t\treturn vec4(p_o7519_Metallic*clamp(o7519_input_Metallic_tex3d(vec4(uv.xyz,2.0), _seed_variation_),0.0,1.0),0.0,0.0,sdf);\n\t} else\n\t//1 - BaseColor\n\tif (uv.w>0.5){\n\t\treturn vec4(p_o7519_BaseColor.rgb*clamp(o7519_input_BaseColor_tex3d(vec4(uv.xyz,1.0), _seed_variation_),vec3(0.0),vec3(1.0)),sdf);\n\t} else\n\t//0 - SDF\n\t{\n\t\treturn vec4(vec3(0),sdf);\n\t}\n}\n\nvec4 o7527_input_mfsdf(vec4 p, float _seed_variation_) {\n    vec4 o7519_0_1_v4v4 = PBRObjectMaker_o7519((p), _seed_variation_);\n\n    return o7519_0_1_v4v4;\n}\n\nconst float seed_o73213 = 0.000000000;\nconst float p_o73213_scale_x = 6.000000000;\nconst float p_o73213_scale_y = 6.000000000;\nconst float p_o73213_scale_z = 6.000000000;\nconst float p_o73213_iterations = 1.000000000;\nconst float p_o73213_persistence = 0.000000000;\nvec3 o7527_input_tex3d(vec4 p, float _seed_variation_) {\nfloat o73213_0_1_tex3d_gs = fbm3d_perlin_nowrap(((p)*(sin(iTime)*0.5+1.0)).xyz, vec3(p_o73213_scale_x, p_o73213_scale_y, p_o73213_scale_z), int(p_o73213_iterations), p_o73213_persistence, float((seed_o73213+fract(_seed_variation_))));\nvec3 o677591_0_1_tex3d = vec3(o73213_0_1_tex3d_gs);\n\nreturn o677591_0_1_tex3d;\n}\n\n//tetrahedron normal by PauloFalcao\n//https://www.shadertoy.com/view/XstGDS\nvec3 normal_o7527(vec3 p, float _seed_variation_) {  \n  const vec3 e=vec3(0.01,-0.01,0.0);\n  float v1=o7527_input_mfsdf(vec4(p+e.xyy,0.0), _seed_variation_).w;\n  float v2=o7527_input_mfsdf(vec4(p+e.yyx,0.0), _seed_variation_).w;\n  float v3=o7527_input_mfsdf(vec4(p+e.yxy,0.0), _seed_variation_).w;\n  float v4=o7527_input_mfsdf(vec4(p+e.xxx,0.0), _seed_variation_).w;\n  return normalize(vec3(v4+v1-v3-v2,v3+v4-v1-v2,v2+v4-v3-v1));\n}\n\n//By pauloFalcao\nvec4 distortHeighByNormal_o7527(vec4 uv, float _seed_variation_) {\n    float d=o7527_input_mfsdf(uv, _seed_variation_).w;\n\tif (d<=abs(p_o7527_Distort*(p_o7527_Bound+1.0))+0.01){\n\t\tvec3 n=normal_o7527(uv.xyz, _seed_variation_);\n\t\tvec3 s=o7527_input_tex3d(vec4(uv.xyz-d*n,0.0), _seed_variation_);\n\t    return o7527_input_mfsdf(vec4(uv.xyz-n*s*p_o7527_Distort,uv.w), _seed_variation_);\n\t} else {\n\t\treturn vec4(vec3(0.0),d);\n\t}\n}\n\nvec4 o7511_input_mfsdf(vec4 p, float _seed_variation_) {\n    vec4 o7527_0_d = distortHeighByNormal_o7527((vec4(v4v4_rotate((p).xyz, -vec3(p_o7533_ax, (-iTime*40.0), p_o7533_az)*0.01745329251), (p).w)), _seed_variation_);\n    o7527_0_d.w = o7527_0_d.w/(1.0+p_o7527_Distort*p_o7527_Correction);vec4 o7527_0_1_v4v4 = o7527_0_d;\n    vec4 o7533_0_1_v4v4 = o7527_0_1_v4v4;\n\n    return o7533_0_1_v4v4;\n}\n\n\nvec3 o7511_input_hdri(vec3 p,float v) {\n\treturn pow(texture(iChannel0, p).xyz, vec3(2.2))\n    + pow(texture(iChannel0, p).xxx, vec3(16.0)) * v;\n}\n\n\n\n//tetrahedron normal by PauloFalcao\n//https://www.shadertoy.com/view/XstGDS\nvec3 normal_o7511(vec3 p, float _seed_variation_) {  \n  const vec3 e=vec3(0.001,-0.001,0.0);\n  float v1=o7511_input_mfsdf(vec4(p+e.xyy,0.0), _seed_variation_).w;\n  float v2=o7511_input_mfsdf(vec4(p+e.yyx,0.0), _seed_variation_).w;\n  float v3=o7511_input_mfsdf(vec4(p+e.yxy,0.0), _seed_variation_).w;\n  float v4=o7511_input_mfsdf(vec4(p+e.xxx,0.0), _seed_variation_).w;\n  return normalize(vec3(v4+v1-v3-v2,v3+v4-v1-v2,v2+v4-v3-v1));\n}\n\nvoid march_o7511(inout float d,inout vec3 p,float dS, vec3 ro, vec3 rd, float _seed_variation_) {\n    for (int i=0; i < 500; i++) {\n    \tp = ro + rd*d;\n        dS = o7511_input_mfsdf(vec4(p,0.0), _seed_variation_).w;\n        d += dS;\n        if (d > 50.0 || abs(dS) < 0.0001) break;\n    }\n}\n\n//from https://www.shadertoy.com/view/lsKcDD\nfloat calcAO_o7511( in vec3 pos, in vec3 nor , float _seed_variation_) {\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ ){\n        float h = 0.001 + 0.25*float(i)/4.0;\n        float d = o7511_input_mfsdf(vec4( pos + h*nor ,0.0), _seed_variation_).w;\n        occ += (h-d)*sca;\n        sca *= 0.98;\n    }\n    return clamp( 1.0 - 1.6*occ, 0.0, 1.0 );    \n}\n\n//from https://www.shadertoy.com/view/lsKcDD\nfloat calcSoftshadow_o7511( in vec3 ro, in vec3 rd, in float mint, in float tmax, float _seed_variation_) {\n\tfloat res = 1.0;\n    float t = mint;\n    float ph = 1e10; // big, such that y = 0 on the first iteration\n    for( int i=0; i<32; i++ ){\n\t    vec3 p=ro + rd*t;\n\t\tfloat h = o7511_input_mfsdf(vec4(p,0.0), _seed_variation_).w;\n\t\tfloat isLight=o7511_input_mfsdf(vec4(p,13.0), _seed_variation_).x;\n\t\tif (isLight>0.0) h=999999.0;\n        res = min( res, 10.0*h/t );\n        t += h;\n        if( res<0.0001 || t>tmax ) break;  \n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\nvec3 raymarch_o7511(vec2 uv, float _seed_variation_) {\n    uv-=0.5;\n\tvec3 cam=vec3((-2.2+sin(iTime*0.17)*0.5),(0.324+sin(iTime*0.4)*0.5),(sin(iTime*0.3)*0.5+0.5))*p_o7511_CamZoom;\n\tvec3 lookat=vec3(p_o7511_LookAtX,p_o7511_LookAtY,p_o7511_LookAtZ);\n\tvec3 ray=normalize(lookat-cam);\n\tvec3 cX=normalize(cross(vec3(0.0,1.0,0.0),ray));\n\tvec3 cY=normalize(cross(cX,ray));\n\tvec3 rd = normalize(ray*p_o7511_CamD+cX*uv.x+cY*uv.y);\n\tvec3 ro = cam;\n\t\n\tfloat d=0.;\n\tvec3 p=vec3(0);\n\tfloat dS=0.0;\n\tmarch_o7511(d,p,dS,ro,rd, _seed_variation_);\n\t\n    vec3 color=vec3(0.0);\n\tvec3 objColor=o7511_input_mfsdf(vec4(p,1.0), _seed_variation_).xyz;   // 1 - BaseColor (r,g,b,sdf) linear (0-1)\n\tfloat objMetallic=clamp(o7511_input_mfsdf(vec4(p,2.0), _seed_variation_).x,0.0,1.0);  // 2 - Metallic  (v,0,0,sdf)\n\tfloat objSpecular=clamp(max(o7511_input_mfsdf(vec4(p,4.0), _seed_variation_).x*0.2,objMetallic),0.0,1.0);  // 4 - Specular  (v,0,0,sdf)\n\tfloat objRoughness=o7511_input_mfsdf(vec4(p,5.0), _seed_variation_).x; // 5 - Roughness (v,0,0,sdf)\n\tvec3 objEmission=o7511_input_mfsdf(vec4(p,13.0), _seed_variation_).xyz; // 13 - Emission (r,g,b,sdf)\n\tobjColor=max(objColor,objEmission);\n\tvec3 light=normalize(vec3(p_o7511_SunX,p_o7511_SunY,p_o7511_SunZ));\n\tif (d<50.0) {\n\t    vec3 n=normal_o7511(p, _seed_variation_);\n\t\tfloat l=clamp(dot(-light,-n),0.0,1.0);\n\t\tvec3 ref=normalize(reflect(rd,-n));\n\t\tfloat r=clamp(dot(ref,light),0.0,1.0);\n\t\tfloat cAO=mix(1.0,calcAO_o7511(p,n, _seed_variation_),p_o7511_AmbOcclusion);\n\t\tfloat shadow=mix(1.0,calcSoftshadow_o7511(p,light,0.05,5.0, _seed_variation_),p_o7511_Shadow);\n\t\tif (objEmission.x>0.0){\n\t\t\tcolor=objEmission;\n\t\t} else {\n\t\t\tcolor=min(vec3(max(shadow,p_o7511_AmbLight)),max(l,p_o7511_AmbLight))*max(cAO,p_o7511_AmbLight)*((1.0-objMetallic)*objColor)+\n\t\t\tpow(r,pow(256.0,(1.0-objRoughness)))*objSpecular*mix(vec3(1.0),objColor,objMetallic)*(1.0-objRoughness)*16.0;\n\t\t}\n\t\t//reflection\n\t\td=0.01;\n\t\tmarch_o7511(d,p,dS,p,ref, _seed_variation_);\n\t\tvec3 objColorRef=vec3(0);\n\t\tvec3 objEmissionRef=vec3(0);\n\t\tif (d<50.0) {\n\t\t\tobjColorRef=o7511_input_mfsdf(vec4(p,1.0), _seed_variation_).xyz;\n\t\t\tobjEmissionRef=o7511_input_mfsdf(vec4(p,13.0), _seed_variation_).xyz;\n\t\t\tn=normal_o7511(p, _seed_variation_);\n\t\t\tl=clamp(dot(-light,-n),0.0,1.0);\n\t\t\tif (objEmissionRef.x>0.0){\n\t\t\t  objColorRef=objEmissionRef;\n\t\t\t} else {\n\t\t\t  objColorRef=max(l,p_o7511_AmbLight)*objColorRef;\n\t\t\t}\n\t\t} else {\n\t\t\tobjColorRef=o7511_input_hdri(ref.xyz,2.0);\n\t\t}\n\t\tcolor=mix(color,objColorRef,objSpecular*mix(vec3(1.0),objColor,objMetallic));\n\t} else {\n\t\tcolor=o7511_input_hdri(rd.xyz,0.0);\n\t}\n\treturn pow(color,vec3(1.0/p_o7511_Gamma));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    float minSize = min(iResolution.x, iResolution.y);\n    float _seed_variation_ = SEED_VARIATION;\n    vec2 UV = vec2(0.0, 1.0) + vec2(1.0, -1.0) * (fragCoord-0.5*(iResolution.xy-vec2(minSize)))/minSize;\n    vec3 o7511_0_1_rgb = raymarch_o7511((UV), _seed_variation_);\n    fragColor = vec4(o7511_0_1_rgb, 1.0);\n}\n","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"lcVBR3","date":"1734297329","viewed":167,"name":"MFSDF Displace","username":"PauloFalcao","description":"MFSDF displace operator, texture and sdf is displaced by object normal","likes":17,"published":3,"flags":0,"usePreview":0,"tags":["mfsdf"],"hasliked":0,"parentid":"","parentname":""}}