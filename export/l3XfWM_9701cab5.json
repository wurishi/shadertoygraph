{"ver":"0.1","info":{"id":"l3XfWM","date":"1728683802","viewed":115,"name":"dual-n-back","username":"zenbooster","description":"In this dual task implementation, two independent sequences are presented simultaneously using different types of stimuli: symbolic and positional.\n\nKeys:\n\nleft:\t\t\tmatch of symbols\nright:\t\tmatch of positions\nbackspace:\treset scores\npause:\t\tpauses","likes":1,"published":3,"flags":48,"usePreview":0,"tags":["psy","braintraining"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"bool bUseSmooth = !false;\n\nvec2 dist(vec2 pos, vec2 ofs, float shape)\n{\n    if(bUseSmooth)\n    {\n        return pos + (shape - 1.) * \n            texture(iChannel2, ofs).xy * 0.05;\n    }\n    else\n    {\n        return pos + (1. - shape) * \n            texture(iChannel2, ofs).xy * 0.05;\n    }\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 uvo = uv;\n    uv -= 0.5;\n    uv.x *= iResolution.x/iResolution.y;\n    vec2 ofso = uvo;\n    float shape = 1.;\n\n   \n    update_shapes_pos();\n\n    int idx = 0;\n    for(int j = 0; j < 3; j++)\n        for(int i = 0; i < 3; i++)\n        {\n            vec2 ofdt = (uv - shapes_pos[idx]) * k;\n            float shp = drawShape(iTime + float(idx*10), ofdt);\n            if(bUseSmooth)\n            {\n                shp = smoothstep(0., 50., shp);\n            }\n            shapes[idx] = shp;\n            shape = min(shape, shapes[idx]);\n\n            idx++;\n        }\n\n    if(!bUseSmooth)\n    {\n        shape = step(0., shape - .01);\n    }\n\n    vec2 tc = dist(uvo, ofso, shape);\n    vec4 c = texture(iChannel1, tc);\n    \n    letter = Loadv4(iChannel0, iChannelResolution[0].xy, V_QUEUE).x;\n    selShape = int(Loadv4(iChannel0, iChannelResolution[0].xy, V_QUEUE).y);\n\n    for(int i = 0; i < 9; i++)\n    {\n        if (bUseSmooth)\n        {\n            if(shapes[i] >= 0.)\n            {\n                if(i == selShape)\n                {\n                    c.rgb = mix(c.rgb * vec3(0.0, 1.0, 0.0), c.rgb, shapes[i]);\n                    float lb = Loadv4(iChannel0, iChannelResolution[0].xy, V_LETTER_BRIGHT).x;\n                    c.rgb = char(c.rgb, vec3(1, 1, 0) * lb, iChannel3, (uv / fnt_scale + 0.5 - shapes_pos[i] / fnt_scale), letter);\n                }\n                else\n                {\n                    c.rgb = mix(c.rgb * vec3(0.3, 0.3, 1.0), c.rgb, shapes[i]);\n                }\n            }\n        }\n        else\n        {\n            if(shapes[i] <= 0.)\n            {\n                if(i == selShape)\n                {\n                    c.rgb *= vec3(0.0, 1.0, 0.0);\n                    c.rgb += char(c.rgb, vec3(1, 1, 0), iChannel3, (uv / fnt_scale + 0.5 - shapes_pos[i] / fnt_scale), letter);\n                }\n                else\n                {\n                    c.rgb *= vec3(0.3, 0.3, 1.0);\n                }\n            }\n        }\n    }\n    \n    vec2 fo;\n    \n    if(uv.y < -0.32)\n    {\n        c.rgb *= vec3(0.2, 0.2, 1.0);\n        fo = vec2(-0.2, -0.41);\n        //bool isLeftPressed = texelFetch( iChannel3, ivec2(KEY_LEFT,0), 0 ).x > 0.;\n        //bool isRightPressed = texelFetch( iChannel3, ivec2(KEY_RIGHT,0), 0 ).x > 0.;\n        bool isLeftPressed = Loadv4(iChannel0, iChannelResolution[0].xy, V_IS_LEFT).x > 0.;\n        bool isRightPressed = Loadv4(iChannel0, iChannelResolution[0].xy, V_IS_RIGHT).x > 0.;\n        vec3 cbABC;\n        vec3 cfABC;\n        vec3 cbPOS;\n        vec3 cfPOS;\n        \n        /*float br = 0.75;\n        vec3 cg = vec3(0, 1, 0) * br;\n        vec3 cr = vec3(1, 0, 0) * br;\n        vec3 cw = vec3(1) * br;*/\n        vec3 cbPressedR = cr;\n        vec3 cbPressedG = cg;\n        vec3 cbUnpressed = cw;\n        vec3 cfPressed = cw;\n        vec3 cfUnpressed = cr;\n\n        int qsz = int(Loadv4(iChannel0, iChannelResolution[0].xy, V_QUEUE_SIZE).x);\n        if(qsz == N+1)\n        {\n            if(isLeftPressed)\n            {\n                cbABC = (Loadv4(iChannel0, iChannelResolution[0].xy, V_QUEUE).x == \n                         Loadv4(iChannel0, iChannelResolution[0].xy, V_QUEUE + N).x) ?\n                         cbPressedG : cbPressedR;\n                cfABC = cfPressed;\n            }\n            else\n            {\n                cbABC = cbUnpressed;\n                cfABC = cfUnpressed;\n            }\n\n            if(isRightPressed)\n            {\n                //cbPOS = cbPressed;\n                //cfPOS = cfPressed;\n                cbPOS = (Loadv4(iChannel0, iChannelResolution[0].xy, V_QUEUE).y == \n                         Loadv4(iChannel0, iChannelResolution[0].xy, V_QUEUE + N).y) ?\n                         cbPressedG : cbPressedR;\n                cfPOS = cfPressed;\n            }\n            else\n            {\n                cbPOS = cbUnpressed;\n                cfPOS = cfUnpressed;\n            }\n        }\n        else\n        {\n            cbABC = cw;\n            cfABC = cw;\n            cbPOS = cw;\n            cfPOS = cw;\n        }\n\n        float shpBtn = step(0., sdBox(uv - fo, vec2(0.15, 0.07)));\n        c.rgb = mix((c.rgb + cbABC) / 2., c.rgb, shpBtn);\n        c.rgb = char(c.rgb, cfABC, iChannel3, ((uv-fo-vec2(-0.1, 0.)) / fnt_scale + 0.5), 65.);\n        c.rgb = char(c.rgb, cfABC, iChannel3, ((uv-fo-vec2(0., 0.)) / fnt_scale + 0.5), 66.);\n        c.rgb = char(c.rgb, cfABC, iChannel3, ((uv-fo-vec2(0.1, 0.)) / fnt_scale + 0.5), 67.);\n        \n        int nScoreABC = int(Loadv4(iChannel0, iChannelResolution[0].xy, V_SCORE_ABC).x);\n        vec3 cs = Loadv4(iChannel0, iChannelResolution[0].xy, V_SCORE_ABC_COLOR).xyz;\n        c.rgb = number(c.rgb, cs, iChannel3, ((uv-fo-vec2(-0.6, 0.)) / fnt_scale + 0.5), nScoreABC, true);\n\n        fo = vec2(0.2, -0.41);\n        shpBtn = step(0., sdBox(uv - fo, vec2(0.15, 0.07)));\n        c.rgb = mix((c.rgb + cbPOS) / 2., c.rgb, shpBtn);\n        c.rgb = char(c.rgb, cfPOS, iChannel3, ((uv-fo-vec2(-0.1, 0.)) / fnt_scale + 0.5), 80.);\n        c.rgb = char(c.rgb, cfPOS, iChannel3, ((uv-fo-vec2(0., 0.)) / fnt_scale + 0.5), 79.);\n        c.rgb = char(c.rgb, cfPOS, iChannel3, ((uv-fo-vec2(0.1, 0.)) / fnt_scale + 0.5), 83.);\n        \n        int nScorePOS = int(Loadv4(iChannel0, iChannelResolution[0].xy, V_SCORE_POS).x);\n        cs = Loadv4(iChannel0, iChannelResolution[0].xy, V_SCORE_POS_COLOR).xyz;\n        c.rgb = number(c.rgb, cs, iChannel3, ((uv-fo-vec2(0.6, 0.)) / fnt_scale + 0.5), nScorePOS, false);\n    }\n    \n    float fPause = Loadv4(iChannel0, iChannelResolution[0].xy, V_IS_PAUSE).x;\n    if(fPause > 0.)\n    {\n        fo = vec2(0., 0.);\n        float iv = 0.2;\n        c.rgb = char(c.rgb, vec3(1, 0, 0), iChannel3, ((uv-fo-vec2(-iv*2., 0.)) / (fnt_scale*2.) + 0.5), 80.);\n        c.rgb = char(c.rgb, vec3(1, 0, 0), iChannel3, ((uv-fo-vec2(-iv, 0.)) / (fnt_scale*2.) + 0.5), 65.);\n        c.rgb = char(c.rgb, vec3(1, 0, 0), iChannel3, ((uv-fo-vec2(0., 0.)) / (fnt_scale*2.) + 0.5), 85.);\n        c.rgb = char(c.rgb, vec3(1, 0, 0), iChannel3, ((uv-fo-vec2(iv, 0.)) / (fnt_scale*2.) + 0.5), 83.);\n        c.rgb = char(c.rgb, vec3(1, 0, 0), iChannel3, ((uv-fo-vec2(iv*2., 0.)) / (fnt_scale*2.) + 0.5), 69.);\n    }\n    \n    // Output to screen\n    fragColor = c;\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void ChkAndDoneFlashTimer(inout vec4 c, vec2 fragCoord)\n{\n    if( (Loadv4(iChannel0, iChannelResolution[0].xy, V_SCORE_ABC_FLASH_SHOW_TIME).x == 0.) &&\n        (Loadv4(iChannel0, iChannelResolution[0].xy, V_SCORE_POS_FLASH_SHOW_TIME).x == 0.))\n    {\n        Savev4(V_SCORE_FLASH_TIME, vec4(0.), c, fragCoord);\n        Savev4(V_SCORE_FLASH, vec4(0.), c, fragCoord);\n    }\n}\n\nvoid SetScoreColor(int vScoreX, int vScoreXColor, int vScoreXFlashColor, int vScoreXFlashShowTime, float vScoreFlash, inout vec4 c, vec2 fragCoord)\n{\n    float vScoreFlashShowTime = Loadv4(iChannel0, iChannelResolution[0].xy, vScoreXFlashShowTime).x;\n    vec3 vScoreFlashColor = Loadv4(iChannel0, iChannelResolution[0].xy, vScoreXFlashColor).xyz;\n    vec3 vScoreColor;\n    if(vScoreFlashShowTime > 0.)\n    {\n        if(iTime - vScoreFlashShowTime >= DELAY * 0.75)\n        {\n            Savev4(vScoreXFlashShowTime, vec4(0.), c, fragCoord);\n        }\n\n        vScoreColor = vScoreFlash > 0. ? cw : vScoreFlashColor;\n    }\n    else\n    {\n        int nScore = int(Loadv4(iChannel0, iChannelResolution[0].xy, vScoreX).x);\n        vScoreColor = nScore >= 0 ? cg : cr;\n    }\n    \n    Savev4(vScoreXColor, vec4(vScoreColor, 0.),  c, fragCoord);\n}\n\nvoid ChangeScore(int vIdx, int delta, inout vec4 c, vec2 fragCoord)\n{\n    int nScore = int(Loadv4(iChannel0, iChannelResolution[0].xy, vIdx).x);\n    nScore += delta;\n    Savev4(vIdx, vec4(nScore), c, fragCoord);\n    // run flash timer\n    Savev4(V_SCORE_FLASH_TIME, vec4(iTime), c, fragCoord);\n}\n\nvoid IncScoreABC(inout vec4 c, vec2 fragCoord)\n{\n    ChangeScore(V_SCORE_ABC, 1, c, fragCoord);\n    Savev4(V_SCORE_ABC_FLASH_COLOR, vec4(cg, 0), c, fragCoord);\n    Savev4(V_SCORE_ABC_FLASH_SHOW_TIME, vec4(iTime), c, fragCoord);\n}\n\nvoid DecScoreABC(inout vec4 c, vec2 fragCoord)\n{\n    ChangeScore(V_SCORE_ABC, -1, c, fragCoord);\n    Savev4(V_SCORE_ABC_FLASH_COLOR, vec4(cr, 0), c, fragCoord);\n    Savev4(V_SCORE_ABC_FLASH_SHOW_TIME, vec4(iTime), c, fragCoord);\n}\n\nvoid IncScorePOS(inout vec4 c, vec2 fragCoord)\n{\n    ChangeScore(V_SCORE_POS, 1, c, fragCoord);\n    Savev4(V_SCORE_POS_FLASH_COLOR, vec4(cg, 0), c, fragCoord);\n    Savev4(V_SCORE_POS_FLASH_SHOW_TIME, vec4(iTime), c, fragCoord);\n}\n\nvoid DecScorePOS(inout vec4 c, vec2 fragCoord)\n{\n    ChangeScore(V_SCORE_POS, -1, c, fragCoord);\n    Savev4(V_SCORE_POS_FLASH_COLOR, vec4(cr, 0), c, fragCoord);\n    Savev4(V_SCORE_POS_FLASH_SHOW_TIME, vec4(iTime), c, fragCoord);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    vec4 c = texture(iChannel0, uv);\n    \n    ChkAndDoneFlashTimer(c, fragCoord);\n\n    int qsz = int(Loadv4(iChannel0, iChannelResolution[0].xy, V_QUEUE_SIZE).x);\n\n    float fPause = Loadv4(iChannel0, iChannelResolution[0].xy, V_IS_PAUSE).x;\n    \n    float vLetterBrightTime = Loadv4(iChannel0, iChannelResolution[0].xy, V_LETTER_BRIGHT_TIME).x;\n    if((fPause == 0.) && (iTime - vLetterBrightTime >= LETTER_BRIGHT_DELAY))\n    {\n        float lb = Loadv4(iChannel0, iChannelResolution[0].xy, V_LETTER_BRIGHT).x;\n        Savev4(V_LETTER_BRIGHT, vec4(lb - LETTER_FADE_DT),  c, fragCoord);\n        Savev4(V_LETTER_BRIGHT_TIME, vec4(iTime),  c, fragCoord);\n    }\n    \n    float vLastCardTime = Loadv4(iChannel0, iChannelResolution[0].xy, V_LAST_CARD_ITIME).x;\n    if((fPause == 0.) && ((vLastCardTime == 0.) || iTime - vLastCardTime >= DELAY))\n    {\n        Savev4(V_LETTER_BRIGHT, vec4(1.),  c, fragCoord);\n\n        if(qsz == N + 1)\n        {\n            float vIsOk = Loadv4(iChannel0, iChannelResolution[0].xy, V_IS_LEFT_OK).x;\n            if( (vIsOk == 0.) || (vLastCardTime - vIsOk >= DELAY))\n            {\n                if(Loadv4(iChannel0, iChannelResolution[0].xy, V_QUEUE).x == \n                   Loadv4(iChannel0, iChannelResolution[0].xy, V_QUEUE + N).x)\n                {\n                    DecScoreABC(c, fragCoord);\n                }\n            }\n\n            vIsOk = Loadv4(iChannel0, iChannelResolution[0].xy, V_IS_RIGHT_OK).x;\n            if( (vIsOk == 0.) || (vLastCardTime - vIsOk >= DELAY))\n            {\n                if(Loadv4(iChannel0, iChannelResolution[0].xy, V_QUEUE).y == \n                   Loadv4(iChannel0, iChannelResolution[0].xy, V_QUEUE + N).y)\n                {\n                    DecScorePOS(c, fragCoord);\n                }\n            }\n        }\n\n        vLastCardTime = iTime;\n        Savev4(V_LAST_CARD_ITIME, vec4(vLastCardTime), c, fragCoord);\n        float letter = float(int(rand(iTime, fragCoord.x) * float(LETTERS_CNT)) + 65);\n        int selShape = int(rand(iTime, fragCoord.y) * 9.);\n\n        for(int i = min(qsz, N); i > 0; i--)\n        {\n            vec4 t = Loadv4(iChannel0, iChannelResolution[0].xy, V_QUEUE + i - 1);\n            Savev4(V_QUEUE + i, vec4(t), c, fragCoord);\n        }\n        Savev4(V_QUEUE, vec4(letter, selShape, 0, 0), c, fragCoord);\n\n        if(qsz < N+1)\n        {\n            Savev4(V_QUEUE_SIZE, vec4(qsz + 1), c, fragCoord);\n        }\n    }\n\n    if(qsz == N + 1)\n    {\n        if(texelFetch( iChannel1, ivec2(KEY_LEFT, 0), 0 ).x > 0.)\n        {\n            Savev4(V_IS_LEFT, vec4(1.),  c, fragCoord);\n            if(Loadv4(iChannel0, iChannelResolution[0].xy, V_IS_LEFT_OK).x == 0.)\n            {\n                Savev4(V_IS_LEFT_OK, vec4(vLastCardTime),  c, fragCoord);\n\n                if(Loadv4(iChannel0, iChannelResolution[0].xy, V_QUEUE).x == \n                   Loadv4(iChannel0, iChannelResolution[0].xy, V_QUEUE + N).x)\n                {\n                    IncScoreABC(c, fragCoord);\n                }\n                else\n                {\n                    DecScoreABC(c, fragCoord);\n                }\n            }\n        }\n        else\n        {\n            Savev4(V_IS_LEFT, vec4(0.),  c, fragCoord);\n            \n            float vIsLeftOk = Loadv4(iChannel0, iChannelResolution[0].xy, V_IS_LEFT_OK).x;\n            if((vIsLeftOk > 0.) && (vLastCardTime - vIsLeftOk >= DELAY))\n            {\n                Savev4(V_IS_LEFT_OK, vec4(0.),  c, fragCoord);\n            }\n        }\n\n        if(texelFetch( iChannel1, ivec2(KEY_RIGHT, 0), 0 ).x > 0.)\n        {\n            Savev4(V_IS_RIGHT, vec4(1.),  c, fragCoord);\n            if(Loadv4(iChannel0, iChannelResolution[0].xy, V_IS_RIGHT_OK).x == 0.)\n            {\n                Savev4(V_IS_RIGHT_OK, vec4(vLastCardTime),  c, fragCoord);\n\n                if(Loadv4(iChannel0, iChannelResolution[0].xy, V_QUEUE).y == \n                   Loadv4(iChannel0, iChannelResolution[0].xy, V_QUEUE + N).y)\n                {\n                    IncScorePOS(c, fragCoord);\n                }\n                else\n                {\n                    DecScorePOS(c, fragCoord);\n                }\n            }\n        }\n        else\n        {\n            Savev4(V_IS_RIGHT, vec4(0.),  c, fragCoord);\n\n            float vIsRightOk = Loadv4(iChannel0, iChannelResolution[0].xy, V_IS_RIGHT_OK).x;\n            if((vIsRightOk > 0.) && (vLastCardTime - vIsRightOk >= DELAY))\n            {\n                Savev4(V_IS_RIGHT_OK, vec4(0.),  c, fragCoord);\n            }\n        }\n    } // if(qsz == N + 1)\n\n    if(texelFetch( iChannel1, ivec2(KEY_PAUSE, 0), 0 ).x > 0.)\n    {\n        if(Loadv4(iChannel0, iChannelResolution[0].xy, V_IS_PAUSE_OK).x == 0.)\n        {\n            float fPause = Loadv4(iChannel0, iChannelResolution[0].xy, V_IS_PAUSE).x;\n\n            if(fPause == 0.)\n            {\n                Savev4(V_QUEUE_SIZE, vec4(0.),  c, fragCoord);\n            }\n\n            Savev4(V_IS_PAUSE, vec4(1. - fPause),  c, fragCoord);\n            Savev4(V_IS_PAUSE_OK, vec4(1.),  c, fragCoord);\n        }\n    }\n    else\n    {\n        if(Loadv4(iChannel0, iChannelResolution[0].xy, V_IS_PAUSE_OK).x == 1.)\n        {\n            Savev4(V_IS_PAUSE_OK, vec4(0.),  c, fragCoord);\n        }\n    }\n\n    if(texelFetch( iChannel1, ivec2(KEY_BACKSPACE, 0), 0 ).x > 0.)\n    {\n        Savev4(V_QUEUE_SIZE, vec4(0.),  c, fragCoord);\n        Savev4(V_SCORE_ABC, vec4(0.), c, fragCoord);\n        Savev4(V_SCORE_POS, vec4(0.), c, fragCoord);\n        Savev4(V_LAST_CARD_ITIME, vec4(0), c, fragCoord);\n    }\n\n    float vScoreFlashTime = Loadv4(iChannel0, iChannelResolution[0].xy, V_SCORE_FLASH_TIME).x;\n    float vScoreFlash = Loadv4(iChannel0, iChannelResolution[0].xy, V_SCORE_FLASH).x;\n    if((vScoreFlashTime > 0.) && (iTime - vScoreFlashTime >= DELAY_FLASH))\n    {\n        Savev4(V_SCORE_FLASH, vec4(1. - vScoreFlash), c, fragCoord);\n        Savev4(V_SCORE_FLASH_TIME, vec4(iTime),  c, fragCoord);\n    }\n\n    SetScoreColor(V_SCORE_ABC, V_SCORE_ABC_COLOR, V_SCORE_ABC_FLASH_COLOR, V_SCORE_ABC_FLASH_SHOW_TIME, vScoreFlash, c, fragCoord);\n    SetScoreColor(V_SCORE_POS, V_SCORE_POS_COLOR, V_SCORE_POS_FLASH_COLOR, V_SCORE_POS_FLASH_SHOW_TIME, vScoreFlash, c, fragCoord);\n    //ChkAndDoneFlashTimer(c, fragCoord);\n\n    fragColor = c;\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// Offsetting alternate rows -- I feel it distributes the effect more,\n// but if you prefer more order, comment out the following:\n#define OFFSET_ROW\n\n\n// Standard 2D rotation formula.\nmat2 rot2(in float a){ float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\n\n// IQ's vec2 to float hash.\nfloat hash21(vec2 p){  return fract(sin(dot(p, vec2(27.619, 57.583)))*43758.5453); }\n\n\nvec2 cellID; // Individual Voronoi cell IDs.\n\n\n// vec2 to vec2 hash.\nvec2 hash22B(vec2 p) { \n\n    // Faster, but doesn't disperse things quite as nicely. However, when framerate\n    // is an issue, and it often is, this is a good one to use. Basically, it's a tweaked \n    // amalgamation I put together, based on a couple of other random algorithms I've \n    // seen around... so use it with caution, because I make a tonne of mistakes. :)\n    float n = sin(dot(p, vec2(41, 289)));\n    return fract(vec2(262144, 32768)*n)*2. - 1.; \n    //return sin( p*6.2831853 + iTime ); \n}\n\n// Based on IQ's gradient noise formula.\nfloat n2D3G( in vec2 p ){\n   \n    // Cell ID and local coordinates.\n    vec2 i = floor(p); p -= i;\n    \n    // Four corner samples.\n    vec4 v;\n    v.x = dot(hash22B(i), p);\n    v.y = dot(hash22B(i + vec2(1, 0)), p - vec2(1, 0));\n    v.z = dot(hash22B(i + vec2(0, 1)), p - vec2(0, 1));\n    v.w = dot(hash22B(i + 1.), p - 1.);\n\n    // Cubic interpolation.\n    p = p*p*(3. - 2.*p);\n    \n    // Bilinear interpolation -- Along X, along Y, then mix.\n    return mix(mix(v.x, v.y, p.x), mix(v.z, v.w, p.x), p.y);\n    \n}\n\n// Two layers of noise.\nfloat fBm(vec2 p){ return n2D3G(p)*.66 + n2D3G(p*2.)*.34; }\n\n\nfloat bMap(vec2 p){\n    \n    // Put the grid on an angle to interact with the light a little better.\n    p *= rot2(-3.14159/5.);\n   \n    #ifdef OFFSET_ROW\n    // Tacky way to construct an offset square grid.\n    if(mod(floor(p.y), 2.)<.5) p.x += .5;\n    #endif\n\n    \n    // Cell ID and local coordinates.\n    vec2 ip = floor(p);\n    p -= ip + .5;\n    \n    // Recording the cell ID.\n    cellID = ip;\n\n    // Transcendental angle function... Made up on the spot.\n    //float ang = dot(sin(ip/4. - cos(ip.yx/2. + iTime))*6.2831, vec2(.5));\n    \n    // Noise function. I've rotated the point around a bit so that the \n    // objects hang down due to gravity at the zero mark.\n    float ang = -3.14159*3./5. + (fBm(ip/8. + iTime/3.))*6.2831*2.;\n    // Offset point within the cell. You could increase this to cell edges\n    // (.5), but it starts to look a little weird at that point.\n    vec2 offs = vec2(cos(ang), sin(ang))*.35;\n     \n    // Linear pyramid shading, according to the offset point. Basically, you\n    // want a value of zero at the edges and a linear increase to one at the \n    // offset point peak. As you can see, I've just hacked in something quick \n    // that works, but there'd be more elegant ways to achieve the same.\n    if(p.x<offs.x)  p.x = 1. - (p.x + .5)/abs(offs.x  + .5);\n    else p.x = (p.x - offs.x)/(.5 - offs.x);\n\n    if(p.y<offs.y) p.y = 1. - (p.y + .5)/abs(offs.y + .5);\n    else p.y = (p.y - offs.y)/(.5 - offs.y);\n\n    // Return the offset pyramid distance field. Range: [0, 1].\n    return 1. - max(p.x, p.y);\n}\n\n\n// Standard function-based bump mapping function, with an edge value \n// included for good measure.\nvec3 doBumpMap(in vec2 p, in vec3 n, float bumpfactor, inout float edge){\n    \n    // Sample difference. Usually, you'd have different ones for the gradient\n    // and the edges, but we're finding a happy medium to save cycles.\n    vec2 e = vec2(.025, 0);\n    \n    float f = bMap(p); // Bump function sample.\n    float fx = bMap(p - e.xy); // Same for the nearby sample in the X-direction.\n    float fy = bMap(p - e.yx); // Same for the nearby sample in the Y-direction.\n    float fx2 = bMap(p + e.xy); // Same for the nearby sample in the X-direction.\n    float fy2 = bMap(p + e.yx); // Same for the nearby sample in the Y-direction.\n    \n    vec3 grad = (vec3(fx - fx2, fy - fx2, 0))/e.x/2.;   \n    \n    // Edge value: There's probably all kinds of ways to do it, but this will do.\n    edge = length(vec2(fx, fy) + vec2(fx2, fy2) - f*2.);\n    //edge = (fx + fy + fx2 + fy2 - f*4.);\n    //edge = abs(fx + fx2 - f*2.) + abs(fy + fy2 - f*2.);\n    //edge /= e.x;\n    edge = smoothstep(0., 1., edge/e.x);\n     \n    // Applying the bump function gradient to the surface normal.\n    grad -= n*dot(n, grad);          \n    \n    // Return the normalized bumped normal.\n    return normalize( n + grad*bumpfactor );\n\t\n}\n\n\n// A hatch-like algorithm, or a stipple... or some kind of textured pattern.\nfloat doHatch(vec2 p, float res){\n    \n    \n    // The pattern is physically based, so needs to factor in screen resolution.\n    p *= res/16.;\n\n    // Random looking diagonal hatch lines.\n    float hatch = clamp(sin((p.x - p.y)*3.14159*200.)*2. + .5, 0., 1.); // Diagonal lines.\n\n    // Slight randomization of the diagonal lines, but the trick is to do it with\n    // tiny squares instead of pixels.\n    float hRnd = hash21(floor(p*6.) + .73);\n    if(hRnd>.66) hatch = hRnd;  \n\n\n    return hatch;\n\n    \n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\n    // Resolution and aspect correct screen coordinates.\n    vec2 uv = (fragCoord - iResolution.xy*.5)/iResolution.y;\n    \n    // Unit direction vector. Used for some mock lighting.\n    vec3 rd = normalize(vec3(uv, .5));\n    \n    // Scaling and tranlation.\n    const float gSc = 10.;\n    vec2 p = uv*gSc + vec2(0, iTime/2.);\n    vec2 oP = p; // Saving a copy for later.\n    \n    \n    // Take a function sample.\n    float m = bMap(p);\n    \n    vec2 svID = cellID;\n  \n    // Face normal for and XY plane sticking out of the screen.\n    vec3 n = vec3(0, 0, -1);\n    \n    // Bump mapping the normal and obtaining an edge value.\n    float edge = 0., bumpFactor = .25;\n    n = doBumpMap(p, n, bumpFactor, edge);\n   \n    // Light postion, sitting back from the plane and animated slightly.\n\tvec3 lp =  vec3(-0. + sin(iTime)*.3, .0 + cos(iTime*1.3)*.3, -1) - vec3(uv, 0);\n    \n    // Liight distance and normalizing.\n    float lDist = max(length(lp), .001);\n    vec3 ld = lp/lDist;\n\t\n\t// Diffuse, specular and Fresnel.\n\tfloat diff = max(dot(n, ld), 0.);\n    diff = pow(diff, 4.);\n    float spec = pow(max(dot(reflect(-ld, n), -rd), 0.), 16.);\n\t// Fresnel term. Good for giving a surface a bit of a reflective glow.\n    float fre = min(pow(max(1. + dot(n, rd), 0.), 4.), 3.);\n    \n\n    // Applying the lighting.\n    vec3 col = vec3(.15)*(diff + .251 + spec*vec3(1, .7, .3)*9. + fre*vec3(.1, .3, 1)*12.);\n    \n    \n    // Some dodgy fake reflections. This was made up on the fly. It's no sustitute for reflecting\n    // into a proper back scene, but it's only here to add some subtle red colors.\n    float rf = smoothstep(0., .35, bMap(reflect(rd, n).xy*2.)*fBm(reflect(rd, n).xy*3.) + .1);\n    col += col*col*rf*rf*vec3(1, .1, .1)*15.;\n\n     // Using the distance function value for some faux shading.\n    float shade = m*.83 + .17;\n    col *= shade;\n    \n    // Apply the edging from the bump function. In some situations, this can add an\n    // extra touch of dimension. It's so easy to apply that I'm not sure why people \n    // don't use it more. Bump mapped edging works in 3D as well.\n    col *= 1. - edge*.8;\n    \n    // Apply a cheap but effective hatch function.\n    float hatch = doHatch(oP/gSc, iResolution.y);\n    col *= hatch*.5 + .7;\n\n\n    update_shapes_pos();\n\n    int idx = 0;\n    for(int j = 0; j < 3; j++)\n        for(int i = 0; i < 3; i++)\n        {\n            vec2 ofdt = (uv - shapes_pos[idx]) * k;\n            shapes[idx] = drawShape(iTime + float(idx*10), ofdt);\n\n            idx++;\n        }\n\n    letter = Loadv4(iChannel0, iChannelResolution[0].xy, V_QUEUE).x;\n    selShape = int(Loadv4(iChannel0, iChannelResolution[0].xy, V_QUEUE).y);\n\n    for(int i = 0; i < 9; i++)\n    {\n        if (shapes[i] <= 0.)\n        {\n            if(i == selShape)\n            {\n                col = char(col, vec3(1, 1, 0), iChannel1, (uv / fnt_scale + 0.5 - shapes_pos[i] / fnt_scale), letter);\n            }\n        }\n    }\n    \n\tfragColor = vec4(sqrt(max(col, 0.)), 1);\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"//bool is_initialized = false;\n\nfloat shapes[9];\nvec2 shapes_pos[9];\nint selShape = 4;\n\nconst float PI = 3.141593;\nfloat k = 1000.;\nconst float fnt_weight = 0.5;\nconst float fnt_sharpen = 100.;\nconst float fnt_scale = 0.2;\nfloat letter = 65.;\n\nconst float br = 0.75;\n//const vec3 cg = vec3(0, 1, 0) * br;\nconst vec3 cg = vec3(0, 0.8, 0) * br;\nconst vec3 cr = vec3(1, 0, 0) * br;\nconst vec3 cw = vec3(1) * br;\n\nconst int N  = 2; // number of steps back\nconst int LETTERS_CNT = 9;// the number of possible letters now matches the number of possible positions\n\n// In order for the player to understand that the position in the next step of the game remains the same:\nconst float LETTER_BRIGHT_DELAY = 0.1; // the brightness of the symbol decreases every LETTER_BRIGHT_DELAY seconds\nconst float LETTER_FADE_DT = 0.03; // by the value LETTER_FADE_DT\n\nconst float DELAY  = 1.3;\nconst float DELAY_FLASH = 0.03;\nconst int KEY_BACKSPACE = 8;\nconst int KEY_PAUSE = 19;\nconst int KEY_LEFT  = 37;\nconst int KEY_UP    = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN  = 40;\n\nconst int POS_NOMOD_TEXEL = 2;\nconst int KEY_PRINTABLE_END  = 96;\n\n// A single iteration of Bob Jenkins' One-At-A-Time hashing algorithm.\nuint hash( uint x )\n{\n    x += ( x << 10u );\n    x ^= ( x >>  6u );\n    x += ( x <<  3u );\n    x ^= ( x >> 11u );\n    x += ( x << 15u );\n    return x;\n}\n\nuint hash( uvec2 v ) { return hash( v.x ^ hash(v.y)                         ); }\nuint hash( uvec3 v ) { return hash( v.x ^ hash(v.y) ^ hash(v.z)             ); }\nuint hash( uvec4 v ) { return hash( v.x ^ hash(v.y) ^ hash(v.z) ^ hash(v.w) ); }\n\n// Construct a float with half-open range [0:1] using low 23 bits.\n// All zeroes yields 0.0, all ones yields the next smallest representable value below 1.0.\nfloat floatConstruct( uint m ) {\n\n    const uint ieeeMantissa = 0x007FFFFFu; // binary32 mantissa bitmask\n    const uint ieeeOne      = 0x3F800000u; // 1.0 in IEEE binary32\n\n    m &= ieeeMantissa;                     // Keep only mantissa bits (fractional part)\n    m |= ieeeOne;                          // Add fractional part to 1.0\n\n    float  f = uintBitsToFloat( m );       // Range [1:2]\n    return f - 1.0;                        // Range [0:1]\n}\n\n// Pseudo-random value in half-open range [0:1].\nfloat rand(float tm, float x) { return floatConstruct(hash(floatBitsToUint(x+tm))); }\nfloat rand(float tm, vec2 v) { return floatConstruct(hash(floatBitsToUint(v+tm))); }\nfloat rand(float tm, vec3  v) { return floatConstruct(hash(floatBitsToUint(v+tm))); }\nfloat rand(float tm, vec4  v) { return floatConstruct(hash(floatBitsToUint(v+tm))); }\n\nconst int V_IS_PAUSE = 0;\nconst int V_IS_PAUSE_OK = 1;\nconst int V_IS_LEFT = 2;\nconst int V_IS_LEFT_OK = 3;\nconst int V_IS_RIGHT = 4;\nconst int V_IS_RIGHT_OK = 5;\nconst int V_LAST_CARD_ITIME = 6;\nconst int V_SCORE_ABC = 7;\nconst int V_SCORE_POS = 8;\nconst int V_LETTER_BRIGHT = 9;\nconst int V_LETTER_BRIGHT_TIME = 10;\nconst int V_SCORE_FLASH = 11;\nconst int V_SCORE_FLASH_TIME = 12;\nconst int V_SCORE_ABC_COLOR = 13;\nconst int V_SCORE_ABC_FLASH_COLOR = 14;\nconst int V_SCORE_ABC_FLASH_SHOW_TIME = 15;\nconst int V_SCORE_POS_COLOR = 16;\nconst int V_SCORE_POS_FLASH_COLOR = 17;\nconst int V_SCORE_POS_FLASH_SHOW_TIME = 18;\nconst int V_QUEUE_SIZE = 19;\nconst int V_QUEUE = 20;\n\nconst float txRow = 32.;\n\nvec4 Loadv4(sampler2D ich, vec2 irs, int idVar)\n{\n  float fi = float(idVar);\n  return texture(ich, (vec2 (mod (fi, txRow), floor (fi / txRow)) + 0.5) / irs);\n}\n\nvoid Savev4 (int idVar, vec4 val, inout vec4 fCol, vec2 fCoord)\n{\n  float fi = float (idVar);\n  vec2 d = abs (fCoord - vec2 (mod (fi, txRow), floor (fi / txRow)) - 0.5);\n  if (max (d.x, d.y) < 0.5) fCol = val;\n}\n\nbool is_any_key_pressed(sampler2D ich)\n{\n    bool res = false;\n\n    for(int i = POS_NOMOD_TEXEL + 1; i < KEY_PRINTABLE_END; ++i)\n        if(texelFetch(ich, ivec2(i,0), 0).x > 0.5)\n        {\n            res = true;\n            break;\n        }\n\n    return res;\n}\n\nfloat sdStar( in vec2 p, in float r, in int n, in float m)\n{\n    // next 4 lines can be precomputed for a given shape\n    float an = PI/float(n);\n    float en = PI/m;  // m is between 2 and n\n    vec2  acs = vec2(cos(an),sin(an));\n    vec2  ecs = vec2(cos(en),sin(en)); // ecs=vec2(0,1) for regular polygon\n\n    float bn = mod(atan(p.x,p.y),2.0*an) - an;\n    p = length(p)*vec2(cos(bn),abs(sin(bn)));\n    p -= r*acs;\n    p += ecs*clamp( -dot(p,ecs), 0.0, r*acs.y/ecs.y);\n    return length(p)*sign(p.x);\n}\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nvec2 rotate(vec2 pos, float rot)\n{\n    float a = rot * PI * 2. * -1.;\n    float sn = sin(a);\n    float cs = cos(a);\n    return vec2(cs * pos.x + sn * pos.y, cs * pos.y - sn * pos.x);\n}\n\nfloat drawShape(float tm, vec2 ofs)\n{\n    vec2 to = ofs;\n    float sdf0 = sdStar(rotate(to, tm * 0.1), 200., 3, -0.6);\n    float sdf1 = sdBox(to, vec2(150, 50));\n    float res = (mix(sdf0, sdf1, 1. - abs(sin(tm)*0.3)) - 30.);\n    //res = sdf0;\n    \n    return res;\n}\n\nvec3 char(vec3 cSrc, vec3 cDst, sampler2D ich, vec2 p, float ch)\n{\n\tif(p.x<0.||p.x>1.||p.y<0.||p.y>1.)\n    {\n        return cSrc;\n    }\n\n    vec2 o = vec2(int(ch)%16, 15. - floor(ch/16.));\n    o = (p + o) / 16.;\n\tfloat t = texture(ich, o).a;\n    float v = (fnt_weight - t) * fnt_sharpen;\n\n    return (v < 0.5) ? cSrc : mix(cDst, cSrc, 0.15);\n}\n\nvec3 number(vec3 cSrc, vec3 cDst, sampler2D ich, vec2 p, int n, bool is_left_aligned)\n{\n    vec2 dt = vec2(-0.1 / fnt_scale, 0.);\n    vec2 dt0;\n    \n    if(is_left_aligned)\n    {\n        dt0 = dt;\n    }\n    else\n    {\n        dt0 = vec2(0.);\n    }\n\n    if(n < 0)\n    {\n        p += dt0;\n    }\n    \n    int an = abs(n);\n    int t = an / 10;\n    while(t > 0)\n    {\n        p += dt0;\n        t /= 10;\n    };\n\n    t = an;\n    do\n    {\n        int d = t % 10;\n        float ch = 48. + float(d);\n        cSrc = char(cSrc, cDst, ich, p, ch);\n        p -= dt;\n     \n        t /= 10;\n    } while(t > 0);\n\n    if(n < 0)\n    {\n        //p += dt0;\n        cSrc = char(cSrc, cDst, ich, p, 45.);\n        p -= dt;\n    }\n\n    return cSrc;\n}\n\nvoid update_shapes_pos()\n{\n    int idx = 0;\n    //if(!is_initialized)\n    {\n        for(int j = 0; j < 3; j++)\n            for(int i = 0; i < 3; i++)\n            {\n                vec2 dt = vec2(0.5 * float(i - 1), 0.1 + 0.25 * float(1 - j));\n                shapes_pos[idx] = dt;\n                \n                idx++;\n            }\n\n        //is_initialized = true;\n    }\n}","name":"Common","description":"","type":"common"},{"inputs":[],"outputs":[{"id":"4sXGR8","channel":0}],"code":"float M(inout vec3 s, inout vec3 q, float t)\n{\n  vec4 v = vec4(0, 33, 55, 0);\n  vec4 z = cos( v + t*.4);\n  mat2 m0 = mat2(z.x, z.y, z.z, z.w);\n  z = cos( v + t*.3);\n  mat2 m1 = mat2(z.x, z.y, z.z, z.w);\n\n  s.xz *= m0;\n  s.xy *= m1;\n  float a = sin(q+sin(q+sin( q ).y).z).x*.5 - 1.;\n  q = s + s + t;\n  return length(s+sin(t*.7)) * log(length(s)+1.) + a;\n}\n\nvoid mainImage(out vec4 o, vec2 u)\n{\n    float z = 0.0;\n    o *= 0.;\n    vec3 q, p, s;\n    vec2 R = iResolution.xy;\n    float t = mod(iTime, 251.328);\n    float d = 2.5;\n    float r;\n    for(; z < 7.; z++ )\n    {\n        s = p = vec3((u - .5 * R.xy) / R.y * d, 5. - d);\n        r = M(s, q, t);\n        d += min(r, 1.);\n        s = p + .1;\n        o += max(.7-r*.28 ,0.);\n        o *= vec4(.1, .3, .4,0) - vec4(10, 5, 6,0) * (M(s, q, t) - r) / 4.;\n    }\n    o.a = 1.0;\n}","name":"Buffer C","description":"","type":"buffer"}]}