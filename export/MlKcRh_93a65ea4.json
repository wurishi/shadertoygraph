{"ver":"0.1","info":{"id":"MlKcRh","date":"1535191962","viewed":157,"name":"Distance field fun 2D","username":"bitblast","description":"just some fun with 2D distance fields","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["2d","distancefield"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float logicalVerticalResolution = 600.0;\nconst float DEG2RAD = 0.01745329251;\nconst float TPI = 6.28318530718;\nconst float PI = 3.14159265359;\n\nfloat circle(vec2 pos)\n{\n    return length(pos);\n}\n\nfloat box(vec2 pos, float w, float h)\n{\n    pos = abs(pos) - vec2(w, h);\n    if (pos.x < 0.0 || pos.y < 0.0)\n        return max(pos.x, pos.y);\n    else\n        return length(pos);\n}\n\nfloat unite(float dista, float distb)\n{\n    return min(dista, distb);\n}\n\nfloat invert(float dist)\n{\n    return -dist;\n}\n\nfloat intersect(float dista, float distb)\n{\n    return max(dista, distb);\n}\n\nfloat subtract(float dista, float distb)\n{\n    return intersect(dista, invert(distb));\n}\n\nfloat softunite(float dista, float distb, float rad)\n{\n    if (dista < rad && distb < rad)\n        return rad - length(vec2(dista, distb) - rad);\n    else\n        return min(dista, distb);\n}\n\nvec2 move(vec2 pos, float x, float y)\n{\n    return pos - vec2(x, y);\n}\n\nvec2 rotate(vec2 pos, float degs)\n{\n    float rad = degs * DEG2RAD;\n    return vec2(-sin(rad) * pos.y + cos(rad) * pos.x, sin(rad) * pos.x + cos(rad) * pos.y);\n}\n\nfloat outline(float dist, float width)\n{\n    return abs(dist) - width;\n}\n\nfloat checkers(vec2 pos, float size)\n{\n    vec2 scl = fract(0.5 * pos / size);\n    return ((scl.x >= 0.5) == (scl.y >= 0.5)) ? 1.0 : 0.0;\n}\n\nfloat smpl(vec2 pos, float iTime)\n{\n    float prog = sin(iTime);\n    //prog = 0.25;\n    float shape =  \n        subtract(\n            softunite(\n                softunite(\n                    box(move(pos, 10.0, 0.0), 300.0, 40.0) - 10.0,\n                    box(rotate(pos, prog * 90.0), 100.0, 100.0) - 10.0,\n                    30.0),\n                box(rotate(pos, prog * -90.0), 100.0, 100.0) - 10.0,\n                30.0),\n            circle(pos) - 60.0\n            ) - 5.0;\n    \n    float dist =\n        unite(\n        \tshape,\n            outline(shape - 30.0, 10.0)\n            );\n    return dist;\n}\n\nvec2 pixelSizeEffect(vec2 pos, float size)\n{\n    if (size < 2.0)\n        return pos;\n    return round(pos / size) * size;\n}\n\nfloat boopBoop(float iTime)\n{\n    iTime *= 3.0;\n    iTime = mod(iTime, 8.0);\n    if (iTime >= 2.0)\n        return 0.0;\n    else\n        return 0.5 * (1.0 - cos(TPI * iTime));\n}\n\nfloat quantize(float val, float size)\n{\n    return size * round(val / size);\n}\n\nvec2 distort(vec2 pos, vec2 center, float rad)\n{\n    vec2 diff = pos - center;\n    float len = length(pos - center);\n    return center +(0.5 * (1.0 - cos(clamp(len / rad, 0.0, 1.0) * PI))) * diff;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 pos = fragCoord * logicalVerticalResolution / iResolution.y\n        - 0.5 * logicalVerticalResolution * vec2(iResolution.x / iResolution.y, 1.0);\n    /*pos += vec2(15.0 * (2.0 + sin(iTime * 0.33)) * sin(pos.y / 20.0 + iTime),\n                15.0 * (2.0 + sin(iTime * 0.43)) * sin(pos.y / 20.0 + iTime));*/\n\t\n    float time = iTime;\n        \n    vec2 center = vec2(-150.0 * sin(time * 20.0), 0.0);\n    float radius = boopBoop(time) * 500.0;\n    //radius = 200.0;\n    pos = distort(pos, center, radius);\n    float positional = 0.5 * (1.0 + sin(pos.x / 10.0 + sin(time) * TPI) * cos(pos.y / 10.0 + time * TPI));\n    float radial = 1.0 - clamp(length(pos - center) / radius / 1.3, 0.0, 1.0);\n    float timed = boopBoop(time);\n    float pixelAdd = 0.4 * timed * radial;\n    //pixelAdd = 0.0;\n    float pixelSize = 1.0 + 50.0 * pixelAdd;\n    pos = pixelSizeEffect(pos, pixelSize);\n    \n    float water = (1.0 - clamp(length(pos - vec2(300.0, 0.0)) / 150.0, 0.0, 1.0)) * (positional - 0.5) * 10.0;\n    float dist = smpl(pos, time) - water;\n        \n    float log2phys = iResolution.y / logicalVerticalResolution / pixelSize;\n    float alpha = clamp(0.5 - dist * log2phys, 0.0, 1.0);\n    float pattern = 1.0;\n    //alpha = dist / 100.0;\n    vec3 col = mix(0.0, 1.0, alpha) * vec3(pattern);\n    //col = vec3(water) / 10.0;\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n","name":"Image","description":"","type":"image"}]}