{"ver":"0.1","info":{"id":"7tBGWc","date":"1624848134","viewed":299,"name":"On The River","username":"andrew741","description":"Ripples in a river using refraction with a nice atmosphere added on top. Theres also a nice night sky. I made this after getting inspired from another shader with water ripples and then added the atmosphere and stars on top. I also through on some clouds.","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["raytracing","clouds","refraction","water","sky","night","atmosphere","volumetrics"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdfGRn","filepath":"/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","previewfilepath":"/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGRr","filepath":"/media/a/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3","previewfilepath":"/media/ap/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3","type":"music","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\nThe code for the atmospheric scattering came from some of my other projects and was modified to work on a flat world\nThe code for the clouds was writen fully for this program dispite using this same method to render volumetric clouds in some of my other shaders\nThe stary sky is using the same method as one of my space (earth) shaders (The method is to use triplanar mapping and taking the color of the stars and putting it to a large power to single out the stars)\nThe noise function was from another shadertoy as I'm not very good at making/inplementing gradient noise algerithms myself\n\nI hope you enjoy this shader as It took me over 4.5 hours\n*/\n\n\n// from another shadertoy shader\nvec3 hash( vec3 p )\n{\n\tp = vec3( dot(p,vec3(127.1,311.7, 74.7)),\n\t\t\t  dot(p,vec3(269.5,183.3,246.1)),\n\t\t\t  dot(p,vec3(113.5,271.9,124.6)));\n\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\n// from another shadertoy shader\nvec4 noised( in vec3 x )\n{\n    // grid\n    vec3 i = floor(x);\n    vec3 w = fract(x);\n    \n    // cubic interpolant\n    vec3 u = w*w*(3.0-2.0*w);\n    vec3 du = 6.0*w*(1.0-w);\n    \n    // gradients\n    vec3 ga = hash( i+vec3(0.0,0.0,0.0) );\n    vec3 gb = hash( i+vec3(1.0,0.0,0.0) );\n    vec3 gc = hash( i+vec3(0.0,1.0,0.0) );\n    vec3 gd = hash( i+vec3(1.0,1.0,0.0) );\n    vec3 ge = hash( i+vec3(0.0,0.0,1.0) );\n\tvec3 gf = hash( i+vec3(1.0,0.0,1.0) );\n    vec3 gg = hash( i+vec3(0.0,1.0,1.0) );\n    vec3 gh = hash( i+vec3(1.0,1.0,1.0) );\n    \n    // projections\n    float va = dot( ga, w-vec3(0.0,0.0,0.0) );\n    float vb = dot( gb, w-vec3(1.0,0.0,0.0) );\n    float vc = dot( gc, w-vec3(0.0,1.0,0.0) );\n    float vd = dot( gd, w-vec3(1.0,1.0,0.0) );\n    float ve = dot( ge, w-vec3(0.0,0.0,1.0) );\n    float vf = dot( gf, w-vec3(1.0,0.0,1.0) );\n    float vg = dot( gg, w-vec3(0.0,1.0,1.0) );\n    float vh = dot( gh, w-vec3(1.0,1.0,1.0) );\n\t\n    // interpolations\n    return vec4( va + u.x*(vb-va) + u.y*(vc-va) + u.z*(ve-va) + u.x*u.y*(va-vb-vc+vd) + u.y*u.z*(va-vc-ve+vg) + u.z*u.x*(va-vb-ve+vf) + (-va+vb+vc-vd+ve-vf-vg+vh)*u.x*u.y*u.z,    // value\n                 ga + u.x*(gb-ga) + u.y*(gc-ga) + u.z*(ge-ga) + u.x*u.y*(ga-gb-gc+gd) + u.y*u.z*(ga-gc-ge+gg) + u.z*u.x*(ga-gb-ge+gf) + (-ga+gb+gc-gd+ge-gf-gg+gh)*u.x*u.y*u.z +   // derivatives\n                 du * (vec3(vb,vc,ve) - va + u.yzx*vec3(va-vb-vc+vd,va-vc-ve+vg,va-vb-ve+vf) + u.zxy*vec3(va-vb-ve+vf,va-vb-vc+vd,va-vc-ve+vg) + u.yzx*u.zxy*(-va+vb+vc-vd+ve-vf-vg+vh) ));\n}\n\n\n// samples 3D nosie and stores it in one channel (x aka a float)\nfloat SampleNoise(vec3 p)\n{\n    float h = noised(p).x;\n    h += noised(p*2. + 100.).x * 0.5;\n    h += noised(p*4. - 100.).x * 0.25;\n    h += noised(p*8. + 1000.).x * 0.125;\n    return h / (1.865);\n}\n\n\nvec4 sampleNoise(vec3 p)\n{\n    vec4 h = noised(p);\n    h += noised(p*2. + 100.).x * 0.5;\n    h += noised(p*4. - 100.).x * 0.25;\n    h += noised(p*8. + 1000.).x * 0.125;\n    return h / (1.865);\n}\n\n\n// stores data on specualar refleciton and diffusion\nstruct SpecularLight\n{\n    float highlight;  // the specular reflection/highlight\n    float diffuse;    // basic diffuse lighting (dosent give the best ouput in this shader and some others)\n};\n\n\n// calculates the speucalar reflection and diffusion\nSpecularLight Specular(float smoothness, vec3 normal, vec3 rd, vec3 sun_dir)\n{\n    float specularAngle = acos(dot(normalize(sun_dir - rd), normal));\n    float specularExponent = specularAngle / (1. - smoothness);\n    // finding the specular highlight\n    float specularHighlight = exp(-specularExponent * specularExponent);\n    // fidning the amount of diffused light\n    float diffseLighting = clamp(dot(normal, sun_dir), 0., 1.);\n    return SpecularLight(specularHighlight, diffseLighting);\n}\n\n\n// the density at a given point in the atmosphere\nfloat GetDensity(float dstToPlannet)\n{\n    float density_fall_off = 6.5;  // the falloff speed for the atmospheric density\n    float h = dstToPlannet * 0.2;  // normalizeing the distance to the plannet based on the difference between the raidius of the atmosphere and the plannet\n    float density = exp(-h * density_fall_off) * (1. - h);\n    return density;\n}\n\n\n// uses ray marching to find the distance through the plannet (for a given position and direction)\nfloat raySphere(vec3 ro, vec3 rd)\n{\n    float lp;\n    float dst;\n    vec3 p = ro;\n    float dfs = 0.;\n    // stepping and moving the ray closer and closer\n    for (int s = 0; s < 80; s++)\n    {\n        dst = -(p.y - 5.);\n        \n        // checking if its super close (to speed it up some sense its called so many times)\n        if (dst < 0.01) break;\n        dfs += dst;\n        p += rd * dst;\n    }\n    // returning the distance through the sphere\n    return dfs;\n}\n\n\n// gets the optical depth based on the ray direction, length, and position\nfloat opticalDepth(vec3 ro, vec3 rd, float rl)\n{\n    // the rays position\n    vec3 p = ro;\n    // the step size\n    float step_size = rl / 11.;\n    vec3 v3_step_size = rd * step_size;\n    // the optical depth\n    float odepth = 0.;\n    // the density\n    float ldense;\n    // stepping throught the atmosphere\n    for (int s = 0; s < 10; s++)\n    {\n        // moving the ray/point\n        p += v3_step_size;\n        // sampling the atmospheric density\n        ldense = GetDensity(p.y);\n        // adding up the optical depth\n        odepth += ldense * step_size;\n    }\n    // returning the optical depth\n    return odepth;\n}\n\n\n// triplannar mapping https://www.youtube.com/watch?v=lctXaT9pxA0&t=1031s\nvec3 TriplannarStars(vec3 p, vec3 normal)\n{\n    // the scale of the texture\n    float scale = 1.;\n    // the sharpness of the blending between different axises\n    float blendSharpness = 5.;\n    // finding the different axise's color\n    vec3 colX = texture(iChannel1, p.zy * scale).rgb;\n    vec3 colY = texture(iChannel1, p.xz * scale).rgb;\n    vec3 colZ = texture(iChannel1, p.xy * scale).rgb;\n    \n    // finding the blending amount for each axis\n    vec3 bw = pow(abs(normal), vec3(blendSharpness));\n    // making it so the total (x + y + z) is 1\n    bw /= dot(bw, vec3(1.));\n    \n    // finding the final color\n    return colX * bw.x + colY * bw.y + colZ * bw.z;\n}\n\n\n// gets the density of a cloud at a 3D point\nfloat CloudDensity(vec3 p)\n{\n    return max(noised(p * 0.01).z * 0.9 + 0.1, 0.);\n}\n\n\nfloat GetDst(vec3 p)\n{\n    return p.y + texture(iChannel0, p.xz * 0.5, 0.).g;\n}\n\n\n// returns the normal based on a signed distance feild\nvec3 GroundNoraml(vec3 p)\n{\n\tfloat d = GetDst(p);\n    vec2 e = vec2(0.075, 0);\n    \n    vec3 normal = d - vec3(\n        GetDst(p - e.xyy),\n        GetDst(p - e.yxy),\n        GetDst(p - e.yyx));\n    \n    return normalize(normal);\n}\n\n\n// finding the scattering coefficents based on the wave lengths of different light colors\nvec3 scatteringCoefficents = pow(vec3(400.) / vec3(700, 530, 440), vec3(4.)) * 1.5;  // the coefficents for the scattering of different wave lengths/colors of light\n\n\nvec4 RenderAtmo(vec3 rd, vec3 ro, vec3 waterCp, vec3 sun_dir, vec3 col)\n{\n    float dstThroughAtmosphere;\n    if (rd.y <= 0.)\n    {\n        dstThroughAtmosphere = min(length(waterCp - ro) / 20., 5.);\n    }\n    else dstThroughAtmosphere = 5.;  // - min(ro.y, 5.);\n    // finding the step size going through the atmosphere\n    float step_size_f = dstThroughAtmosphere / 11.;\n    vec3 step_size = rd * step_size_f;\n    vec3 p = vec3(0.);\n    \n    // initizalizing some terms\n    float density;\n    float sun_length;\n    vec3 transmittance;\n    float sunRayOpticalDepth;\n    float veiwRayOpticalDepth;\n    vec3 inScatteredLight = vec3(0.);\n    // stepping through the atmosphere\n    for (int s = 0; s < 10; s++)\n    {\n        // moving the ray/point\n        p += step_size;\n        // fining the length through the atmosphere in the direction of the sun\n        sun_length = raySphere(p, sun_dir);\n        // finding the optical depth for the view ray and sun ray\n        sunRayOpticalDepth = opticalDepth(p, sun_dir, sun_length);\n        veiwRayOpticalDepth = opticalDepth(p, -rd, step_size_f * float(s));\n        // finding the transmittance\n        transmittance = exp(-(sunRayOpticalDepth + veiwRayOpticalDepth) * scatteringCoefficents);\n        // finding the atmospheric density at this point\n        density = GetDensity(p.y);\n        \n        // finding the amount of addition light\n        inScatteredLight += density * transmittance * scatteringCoefficents * step_size_f;\n    }\n    // applying the atmosphere\n    return vec4(inScatteredLight, exp(-veiwRayOpticalDepth));\n}\n\n\nvec3 renderSky(vec3 ro, vec3 rd, vec3 waterCp, vec3 sun_dir, vec3 sun_col, float time, vec3 col)\n{\n    // rendering atmosphere\n    // finding the distance through the atmosphere\n    float density;\n    vec4 inscat = RenderAtmo(rd, ro, waterCp, sun_dir, col);\n    col = col * inscat.w + inscat.rgb;\n    \n    // checking if the sky needs to be rendered\n    if (rd.y > 0.)\n    {\n        // adding the stars\n        col += pow(TriplannarStars(rd + time * 0.1, rd), vec3(2.75)) * pow(1. - length(col), 5.) * 0.7;\n        // adding the sun\n        col = mix(col, sun_col + inscat.rgb, pow(max(dot(rd, sun_dir), 0.), 275.));\n        \n        // rendering clouds\n        // finding the distance to the cloud layer\n        float toClouds = (40. - ro.y) / rd.y;\n        // checking if the cloud layer is within a reasonable range\n        if (toClouds < 920.)\n        {\n            // finding the distance throught the cloud layer\n            float throughClouds = 50. / rd.y;\n\n            // finding the step size going through the cloud layer\n            float step_size_f = min(throughClouds / 21., 15.);\n            vec3 step_size = rd * step_size_f;\n            \n            // finding where the point collides with the cloud layer (with some shifting so the cloud move)\n            vec3 p = vec3(-ro.x * 4. + iTime * 12., ro.y, -ro.z * 4. + iTime * 12.) + rd * toClouds;\n            float oy = p.y;\n            \n            // defining some terms\n            vec3 sun_p;\n            vec3 sunStep;\n            float sunStepF;\n\n            vec3 inScattered = vec3(0.);\n            float transmittion = 1.;\n            float totalLightDensity;\n\n            vec4 inscat2 = RenderAtmo(vec3(0., 0., 1.), p, vec3(9999999999.), sun_dir, vec3(0.));\n\n            // stepping through the clouds\n            for (int s = 0; s < 20; s++)\n            {\n                // moving the point/ray\n                p += step_size;\n\n                // sampling the density\n                density = CloudDensity(p) * step_size_f;  // replace with noise function\n                \n                // stepping twords the sun\n                if (density >= 0.)\n                {\n                    // reseting some terms\n                    sun_p = p;\n                    totalLightDensity = 0.;\n                    if (sun_dir.y >= 0.)\n                    {\n                        sunStepF = min((50. - (p.y - 40.)) / sun_dir.y / 11., 10.);\n                    }\n                    else\n                    {\n                        sunStepF = min(((p.y - 40.) / abs(sun_dir.y) / 11.), 10.);\n                    }\n                    sunStep = sun_dir * sunStepF;\n                    // stepping through the cloud twords the sun\n                    for (int s = 0; s < 10; s++)\n                    {\n                        sun_p += sunStep;\n                        // sampling the density at the current point\n                        totalLightDensity += CloudDensity(sun_p) * sunStepF;\n                        // moving the ray/point\n                    }\n                    // finding the transmittance based on the amount of stuff (cloud) in the way e^-density\n                    transmittion *= exp(-density * 0.1);\n                    // finding the amount of inScatterd light\n                    //vec3 c = RenderAtmo(rd, p * vec3(1., 0.075, 1.), vec3(999999999.), sun_dir, vec3(0.)).rgb;\n                    // (vec3(1.) - vec3(0., 0.8, 1.) * (1. - c.b))\n                    inScattered += (vec3(1.)*inscat2.rgb) * (density * transmittion * exp(-totalLightDensity * 0.1) * 0.1);\n                    //inScattered = sun_col + c;\n                    //col = c;\n                    //return col;\n                }\n\n                if (transmittion < 0.05) break;  // an optomization as the transmittion is so low that anything lower dosent vissually change much\n            }\n            // fading the clouds out at the edges so it looks like they are within the atmosphere\n            transmittion = mix(transmittion, 1., (toClouds / 920.));\n            // checking if the clouds are being shadowed by the planet (night time)\n            // add the clouds on top of the current color based on the transmittion\n            col = col*(transmittion) + vec3(inScattered * 0.8 + 0.2) * (1. - transmittion);\n            \n        }\n    }\n    \n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // the uv coord\n    vec2 uv = (fragCoord - iResolution.xy * 0.5) / iResolution.y;\n    // the scaled time\n    float time = iTime * 0.1;\n\n    vec3 sun_col = vec3(1., 0.8, 0.65) * 1.4;\n    //vec3 sun_dir = normalize(vec3(0.2, 0.3, 1.));\n    vec3 sun_dir = normalize(vec3(sin(time) * 0.2 + 0.2, sin(time), cos(time)));\n\n    // the ray direction and ray orgin\n    vec3 rd = normalize(vec3(uv.x, uv.y+0., 1.));\n    vec3 ro = vec3(2. - iMouse.x / iResolution.x * 4. - 2., 2., 2. - iMouse.y / iResolution.y * 4. - 2.);\n    \n    // the color (which will be the output)\n    vec3 col = vec3(0.);\n    \n    // the waters collide point\n    vec3 waterCp = ro + rd * (ro.y / rd.y);\n    if (rd.y <= 0.)\n    {\n        // finding a noise value at the position of where the ray collides with the water plane\n        vec4 noise = (1. - abs(sampleNoise(vec3(waterCp.xz - time, iTime * 0.5)))) * 2. - 1.;\n        // finding the water normal (for refraction)\n        vec3 waterNorm = normalize(vec3((noise.x * 0.5), 12., (noise.w * 0.5)));\n        // fining the refracted ray direction (to sample the texture)\n        vec3 refracted = refract(rd, waterNorm, 0.075);\n        // fidning where the refracted ray hits the bottom of the river\n        vec3 cp = waterCp + refracted * ((waterCp.y + 2.) / refracted.y);\n                \n        // fidning the river bottoms texture\n        vec3 text = texture(iChannel0, cp.xz * 0.5, 0.).rgb;\n        // setting the color to the texture\n        col = text;\n        // adding specular reflection/highlight to the waters surface\n        SpecularLight spec = Specular(0.6, waterNorm, rd, sun_dir);\n        col = col + spec.highlight;\n        \n        // add a bit of diffuse lighting to the river bed (i think its diffuse lighting at least)\n        vec3 groundNormal = GroundNoraml(cp);\n        col *= dot(groundNormal, sun_dir) * 0.25 + 0.75;\n        \n        float waterDepth = max(length(cp - waterCp) - groundNormal.y * 5., 0.);\n        \n        // haveing the water be dark during the night (sense the lighting dosent make it very dark)\n        col *= min(sun_dir.y * 0.3 - 0.7, 0.) + 1.;\n        \n        col = mix(col, vec3(0.1, 0.1, 0.4), 1. - exp(-waterDepth * 0.25));\n        \n        vec3 reflected = reflect(rd, waterNorm);\n        col = mix(col, renderSky(waterCp, reflected, waterCp, sun_dir, sun_col, time, col), min(1. + dot(-sun_dir, reflected), 1.));\n    }\n    col = renderSky(ro, rd, waterCp, sun_dir, sun_col, time, col);\n\n    // setting the final color to col\n    fragColor = vec4(col,1.0);\n}\n\n","name":"Image","description":"","type":"image"}]}