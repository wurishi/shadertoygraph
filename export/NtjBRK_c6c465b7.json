{"ver":"0.1","info":{"id":"NtjBRK","date":"1652872250","viewed":152,"name":"Cartoon shader for exam","username":"rucksack","description":"Click and drag to spin the view.\nThis lighting model is a solution to a task in an earlier exam in TDT4230, made in part to show an error in the task, which asked for a lighting model without diffuse reflection. This did not create the intended effect.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["cartoon","banding","attenuation"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// READ THIS PLEASE\n// Comment either of these to toggle light types\n#define USE_DIFFUSE 1\n//#define USE_SPECULAR 1\n\n\n\n// Raymarching parameters\n#define MAX_STEPS 512\n#define NEAR_ENOUGH 0.001\n#define TOO_FAR 85.0\n\n// Lighting parameters\n// Shininess is set to \n#define SHININESS .5\n#define ATTENUATION 0.4\n\n// Colors\n#define BACKGROUND_COLOR vec3(.7, .7, .7)\n#define SMOOTH_FACTOR 0.5\n\n#define COLOR0 vec3(0.384,0.627,0.918)\n#define COLOR1 vec3(0.70196,0.64314,0.24706)\n#define COLOR2 vec3(0.0902,0.42745,0.2902)\n#define COLOR3 vec3(0.76471,0.33725,0.76471)\n\n#define PI 3.14159265359\n\nconst float bands = 3.;\n\nfloat sphere(vec3 point, vec3 center, float radius) {\n    return length(point - center) - radius;\n}\n\n// Smooth operator by Inigo Iquilez\nfloat smooth_min(float a, float b, float k) {\n    float h = max(k - abs(a-b), 0.) / k;\n    return min(a, b) - h*h*h*k*(1./6.);\n}\n\n// Alternate minimum for preserving material color\n// (using blend factor like in iq's article)\nvec4 smooth_min2(vec4 a, vec4 b, float k) {\n    float h = max(k - abs(a.x-b.x), 0.) / k;\n    vec3 c;\n    if (a.x < b.x)\n        c = mix(a.yzw, b.yzw, h*h*h*.5);\n    else\n        c = mix(a.yzw, b.yzw, 1. - h*h*h*.5);        \n    return vec4(min(a.x, b.x) - h*h*h*k*(1./6.), c);\n}\n\nfloat distance_from_everything(vec3 point) {\n    float d = sphere(point, vec3(sin(1.1*iTime+.5), -.8, -.3), .6);\n    d = smooth_min(d, sphere(point, vec3(1.2, -.3, 0), 1.), SMOOTH_FACTOR);\n    d = smooth_min(d, sphere(point, vec3(-1.3, 0, -.2), 1.), SMOOTH_FACTOR);\n    d = smooth_min(d, sphere(point, vec3(0, 1, 0), 1.), SMOOTH_FACTOR);\n    return d;\n}\n\nvec3 material_color(vec3 point) {\n    vec4 sphere0 = vec4(sphere(point, vec3(sin(1.1*iTime+.5), -.8, -.3), .6), COLOR0);\n    vec4 sphere1 = vec4(sphere(point, vec3(1.2, -.3, 0), 1.), COLOR1);\n    vec4 sphere2 = vec4(sphere(point, vec3(-1.3, 0, -.2), 1.), COLOR2);\n    vec4 sphere3 = vec4(sphere(point, vec3(0, 1, 0), 1.), COLOR3);\n\n    vec4 d = smooth_min2(sphere0, sphere1, SMOOTH_FACTOR);\n    d = smooth_min2(d, sphere2, SMOOTH_FACTOR);\n    d = smooth_min2(d, sphere3, SMOOTH_FACTOR);\n    return d.yzw;\n}\n\nfloat ray_march(vec3 ray_origin, vec3 ray_direction) {\n    // How far we've traveled\n    float d = 0.0;\n    for (int i = 0; i < MAX_STEPS; i++) {\n        // Where we stand\n        vec3 point = ray_origin + ray_direction*d;\n        // How far anything is from us\n        float current_distance = distance_from_everything(point);\n        // March on\n        d += current_distance;\n        // Check status - have we reached a surface?\n        if (current_distance < NEAR_ENOUGH || d > TOO_FAR)\n            break;\n    }\n    return d;\n}\n\n// See https://iquilezles.org/articles/normalsSDF\nvec3 estimate_normal(vec3 point) {\n    vec2 e = vec2(NEAR_ENOUGH, 0); // x smol, y none\n    // Find normal as tangent of distance function\n    return normalize(vec3(\n        distance_from_everything(point + e.xyy) - distance_from_everything(point - e.xyy),\n        distance_from_everything(point + e.yxy) - distance_from_everything(point - e.yxy),\n        distance_from_everything(point + e.yyx) - distance_from_everything(point - e.yyx)\n    ));\n}\n\nfloat phong_light(vec3 point, vec3 light_position, vec3 n, vec3 camera) {\n    vec3 l = normalize(light_position-point);\n    vec3 l2 = normalize(vec3(-1, .2, -1.4));\n    vec3 c = normalize(camera-point);\n    float d = length(c); // TODO add sth here to fix attenuation\n#ifdef USE_SPECULAR\n#ifdef USE_DIFFUSE\n    float specularity = 0.4;\n#else\n    float specularity = 0.8;\n#endif\n#endif\n    // Contribution from point light\n    float intensity = 0.;\n#ifdef USE_DIFFUSE\n    intensity += max(dot(n, l), 0.);\n#endif\n#ifdef USE_SPECULAR\n    intensity += pow(max(dot(reflect(-l, n), c), 0.), SHININESS) * specularity;\n#endif\n    // Attenuation on point light, only obeying square law\n    float attenuation = 1./(ATTENUATION*d*d);\n    intensity *= attenuation;\n    // Contribution from sun\n#ifdef USE_DIFFUSE\n    intensity += max(dot(n, l2), 0.) * .7;\n#endif\n#ifdef USE_SPECULAR\n    intensity += pow(max(dot(reflect(-l2, n), c), 0.), SHININESS) * specularity;\n#endif\n    // Ambient intensity (added after banding)\n    float ambient = .4;\n    // Banding\n    float max_intensity = .5;\n#ifdef USE_DIFFUSE\n    max_intensity += 1. + .7;\n#endif\n#ifdef USE_SPECULAR\n    max_intensity += specularity * 2.;\n#endif\n    max_intensity /= 2.;\n    return floor((intensity) / max_intensity * bands + .5) / bands + ambient;\n}\n\nvec3 lighting(vec3 point, vec3 camera, vec3 camDir, float dist) {\n    // Avoid casting specular highlight from the void\n    if (length(point - camera) > TOO_FAR*0.99)\n        return BACKGROUND_COLOR;\n\n    vec3 changing_color = vec3(1., max(0., cos(point.y +.9)), max(0., sin(point.x)));\n    \n    return phong_light(point, vec3(.6, 1, -1.7), estimate_normal(point), camera) * material_color(point);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 xy = (fragCoord - 0.5*iResolution.xy) / iResolution.y;\n    vec2 m = iMouse.xy/iResolution.xy;\n\n    vec3 camera = vec3(0., 0.3, -4.);\n    vec3 ray_direction = vec3(xy, 1.);\n\n    // Rotate the view\n    float a = PI*.43 + m.x*PI*2.;\n    float b = -PI*.5 - m.y*PI*2.;\n    mat3 rotY = mat3(\n        -sin(a),      0, cos(a),\n              0,      1, 0,\n         cos(a),      0, sin(a)\n    );\n    mat3 rotX = mat3(\n              1,       0,      0,\n              0, -sin(b), cos(b),\n              0,  cos(b), sin(b)\n    ); // not really successful :(\n    camera = camera * rotY;\n    ray_direction = ray_direction * rotY;\n\n    float d = ray_march(camera, ray_direction);\n    \n    vec3 point = camera + ray_direction * d;\n    \n    vec3 base_color = lighting(point, camera, ray_direction, d);\n\n    fragColor = vec4(base_color, 1.);\n}\n","name":"Image","description":"","type":"image"}]}