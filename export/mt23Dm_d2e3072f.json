{"ver":"0.1","info":{"id":"mt23Dm","date":"1673432816","viewed":104,"name":"raytrace AABB","username":"lambwww","description":"使用了包围盒的思想对立方体进行光线追踪","likes":5,"published":1,"flags":32,"usePreview":0,"tags":["raytraceaabb"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 col = texture(iChannel0, fragCoord / iResolution.xy).rgb;\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//光线可以看到的最远距离\nconst float maxFar=10000.;\n//光线交叉的最短距离，防止刚反弹出来又弹射\nconst float minRayHitTime=0.01;\n//光线弹射次数\nconst int bounceTime=8;\n\nconst float pi=3.1415926535;\n//交点信息\nstruct SRayHitInfo\n{\n    float dist;\n    vec3 normal;\n    vec3 albedo; //颜色\n    vec3 emission; //发光\n};\n//随机数处理使用了重要性采样，这里也有点没搞清楚原理\nuint wang_hash(inout uint seed)\n{\n    seed = uint(seed ^ uint(61)) ^ uint(seed >> uint(16));\n    seed *= uint(9);\n    seed = seed ^ (seed >> 4);\n    seed *= uint(0x27d4eb2d);\n    seed = seed ^ (seed >> 15);\n    return seed;\n}\nfloat RandomFloat01(inout uint state)\n{\n    return float(wang_hash(state)) / 4294967296.0;\n}\nvec3 RandomUnitVec(inout uint state)\n{\n    float z = RandomFloat01(state) * 2.0f - 1.0f;\n    float a = RandomFloat01(state) * 2. * pi;\n    float r = sqrt(1.0f - z * z);\n    float x = r * cos(a);\n    float y = r * sin(a);\n    return vec3(x, y, z);\n}\n//dmin dmax代表原点到当前四边形的最小、最大有向距离，tmin tmax代表比较出来的最小、最大时间\nbool TestAABB(vec3 ro,vec3 rd,vec3 dmin,vec3 dmax,inout float tmin,inout float tmax)\n{\n    // tx=(d−ROx)/RDx \n    //理论参考https://blog.csdn.net/weixin_40301728/article/details/114239266\n    vec3 temp1=(dmin-ro)/rd;\n    vec3 temp2=(dmax-ro)/rd;\n    \n    vec3 t1=min(temp1,temp2);\n    vec3 t2=max(temp1,temp2);\n    \n    tmin=max(max(t1.x,t1.y),max(t1.z,tmin));\n    tmax=min(min(t2.x,t2.y),min(t2.z,tmax));\n    if(tmin<tmax && tmax>=0.)\n        return true;\n    return false;\n}\nbool TestBoxTrace(vec3 ro,vec3 rd,inout SRayHitInfo info,vec3 size,vec3 center)\n{\n    float tmin=0.;\n    float tmax=maxFar;\n    if(TestAABB(ro,rd,center-size,center+size,tmin,tmax))\n    {\n        vec3 p=ro+tmin*rd;\n        vec3 normal;\n        //判断平面，给normal赋值\n        if(p.x==center.x-size.x) //左\n        {\n            normal=vec3(-1.,0.,0.);\n        }\n        else if(p.x==center.x+size.x)//右\n        {\n            normal=vec3(1.,0.,0.0);\n        }\n        else if(p.y==center.y+size.y)//上\n            normal=vec3(0.,1.,0.);\n        else if(p.y==center.y-size.y)//下\n            normal=vec3(0.,-1.,0.);\n        else if(p.z==center.z+size.z)//后\n            normal=vec3(0.,0.,1.);\n        else if(p.z==center.z-size.z)//前\n            normal=vec3(0.,0.,-1.);\n        if (tmin > minRayHitTime && tmin < info.dist)\n        {\n            info.dist = tmin;   \n            info.normal=normal;\n            return true;\n        }\n    }\n    return false;\n}\n//判断光线是否和矩形相交\n//a b c d是矩形的四个顶点，左下点开始逆时针分别是四个点\nbool TestQuadTrace(vec3 ro,vec3 rd,inout SRayHitInfo info,vec3 a,vec3 b,vec3 c,vec3 d)\n{\n    vec3 normal=normalize(cross(c-a,c-b));//两个向量叉乘获得垂直于矩形的法向量\n    //如果法线和光线夹角小于90度，就把法线和平面一块180度翻转一下\n    //这里暂时没搞懂为什么这样做，mark一下\n    if (dot(normal, rd) > 0.0f)\n    {\n        normal *= -1.0f;\n        \n\t\tvec3 temp = d;\n        d = a;\n        a = temp;\n        \n        temp = b;\n        b = c;\n        c = temp;\n    }\n    \n    vec3 p = ro;\n    vec3 q = ro + rd;\n    vec3 pq = q - p;\n    vec3 pa = a - p;\n    vec3 pb = b - p;\n    vec3 pc = c - p;\n    \n    //以ac对角线为边界，判断光线在对角线上面还是下面\n    vec3 m = cross(pc, pq);\n    float v = dot(pa, m);\n    vec3 intersectPos;//交点\n    //将光线和矩形求交优化为光线和三角形求交\n    if (v >= 0.0f)\n    {\n        //和三角形abc求交\n        //三角形平面内任意点可表示为p=ua+vb+wc，abc是三角形三个顶点坐标，uvw根据重心坐标的性质有u+v+w=1\n        //将等号左边的射线式子和等号右边的三角形坐标式子联立：o+td=(1-u-v)a+ub+vc\n        //整理为矩阵形式并使用Cramer法则对方程求解\n        //原理参考了文章https://zhuanlan.zhihu.com/p/405075535\n        vec3 e1=b-a;\n        vec3 e2=c-a;\n        vec3 q1=cross(rd,e2);\n        float a1=dot(e1,q1);\n        float f=1./a1;\n        vec3 s=ro-a;\n        float u=f*dot(s,q1);\n        if(u<.0) return false;\n        vec3 r=cross(s,e1);\n        float w=f*dot(rd,r);\n        if(w<0. || w+u>1.) return false;\n        intersectPos=(1.-u-w)*a+u*b+w*c; //等号右边的三个参数对应重心性质的三个参数\n    }\n    else\n    {\n        //和三角形acd求交\n        //自己参考资料写的：\n        vec3 e1=d-a;\n        vec3 e2=c-a;\n        vec3 q1=cross(rd,e2);\n        float a1=dot(e1,q1);\n        float f=1./a1;\n        vec3 s=ro-a;\n        float u=f*dot(s,q1);\n        if(u<.0) return false;\n        vec3 r=cross(s,e1);\n        float w=f*dot(rd,r);\n        if(w<0. || w+u>1.) return false;\n        intersectPos=(1.-u-w)*a+u*d+w*c;\n    }\n    \n    float dist; //求距离值\n    if (abs(rd.x) > 0.1f)\n    {\n        dist = (intersectPos.x - ro.x) / rd.x;\n    }\n    else if (abs(rd.y) > 0.1f)\n    {\n        dist = (intersectPos.y - ro.y) / rd.y;\n    }\n    else\n    {\n        dist = (intersectPos.z - ro.z) / rd.z;\n    }\n    \n\tif (dist > minRayHitTime && dist < info.dist)\n    {\n        info.dist = dist;        \n        info.normal = normal;        \n        return true;\n    }    \n    \n    return false;\n}\n//场景\nvoid TestSceneTrace(vec3 ro,vec3 rd,inout SRayHitInfo info)\n{\n    if(TestBoxTrace(ro,rd,info,vec3(4.,5.,2.),vec3(16.,-1.,23.)))\n    {\n        //赋颜色值\n        info.albedo=vec3(0.9f, 0.95f, 0.75f);\n        info.emission=vec3(.0,.0,.0);\n    }\n    if(TestBoxTrace(ro,rd,info,vec3(4.,6.,2.),vec3(-16.,-8.,20.)))\n    {\n        //赋颜色值\n        info.albedo=vec3(0.9f, 0.95f, 0.75f);\n        info.emission=vec3(.0,.0,.0);\n    }\n    //前面的墙\n    if(TestQuadTrace(ro,rd,info,vec3(-20.,-15.,25.),vec3(20.,-15.,25.),vec3(20.,15.,25.),vec3(-20.,15.,25.)))\n    {\n        info.albedo=vec3(.7,.7,.7);\n        info.emission=vec3(.0,.0,.0);\n    }\n    //上面的墙\n    if(TestQuadTrace(ro,rd,info,vec3(-20.,15.,25.),vec3(20.,15.,25.),vec3(20.,15.,17.),vec3(-20.,15.,17.)))\n    {\n        info.albedo=vec3(.7,.7,.7);\n        info.emission=vec3(.0,.0,.0);\n    }\n    //下面的墙\n    if(TestQuadTrace(ro,rd,info,vec3(-20.,-15.,25.),vec3(20.,-15.,25.),vec3(20.,-15.,17.),vec3(-20.,-15.,17.)))\n    {\n        info.albedo=vec3(.7,.7,.7);\n        info.emission=vec3(.0,.0,.0);\n    }\n    //左\n    if(TestQuadTrace(ro,rd,info,vec3(-20.,-15.,25.),vec3(-20.,15.,25.),vec3(-20.,15.,17.),vec3(-20.,-15.,17.)))\n    {\n        info.albedo=vec3(0.7,.1,.1);\n        info.emission=vec3(.0,.0,.0);\n    }\n    //右\n    if(TestQuadTrace(ro,rd,info,vec3(20.,-15.,25.),vec3(20.,15.,25.),vec3(20.,15.,17.),vec3(20.,-15.,17.)))\n    {\n        info.albedo=vec3(0.1,.7,.1);\n        info.emission=vec3(.0,.0,.0);\n    }\n    //light\n    if(TestQuadTrace(ro,rd,info,vec3(-6.,14.9,23.),vec3(6.,14.9,23),vec3(6.,14.9,18.),vec3(-6.,14.9,18.)))\n    {\n        info.albedo = vec3(0.0f, 0.0f, 0.0f);\n        info.emission = vec3(1.0f, 0.9f, 0.7f) * 40.0f;\n    }\n}\n//返回光线相交到点的颜色\nvec3 GetColorForRay(vec3 ro,vec3 rd, uint random)\n{\n    vec3 res=vec3(.0,.0,.0);\n    vec3 throughput = vec3(1.0f, 1.0f, 1.0f); //我的理解就是光线的颜色\n    for(int i=0;i<bounceTime;i++)\n    {\n        SRayHitInfo hitInfo; //ray和物体的交点\n        hitInfo.dist=maxFar;\n        TestSceneTrace(ro,rd,hitInfo);\n        //代表没有相交物体\n        if(hitInfo.dist==maxFar) \n        {\n            res += texture(iChannel1, rd).rgb * throughput;//添加一个环境光让整体更亮\n            break; \n        }\n        ro=ro+hitInfo.dist*rd; //更新位置\n        rd=normalize(hitInfo.normal+RandomUnitVec(random)); //光线随机反射一个方向\n        \n        res+=hitInfo.emission*throughput; //为当前像素的颜色赋值\n        throughput*=hitInfo.albedo; //光线和物体碰撞后的颜色值，物体的颜色影响了光线，所以要进行变化\n    }\n    \n    return res;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //vec2 uv = fragCoord/iResolution.xy*2.-1.;\n    vec2 uv = ( 2.*fragCoord - iResolution.xy ) / iResolution.y;//修改了变形\n    vec3 ro=vec3(.0,.0,.0); //ray origin\n    vec3 rd=normalize(vec3(uv,1.)-ro); //ray dirction\n    //生成随机数\n    uint rngState = uint(uint(fragCoord.x) * uint(1973) + uint(fragCoord.y) * uint(9277) + uint(iFrame) * uint(26699)) | uint(1);\n    //进行追踪\n    vec3 col=GetColorForRay(ro,rd,rngState);\n    //和上一帧的图像进行混合\n    vec3 lastFrameColor = texture(iChannel0, fragCoord / iResolution.xy).rgb;\n    col = mix(lastFrameColor, col, 1.0/ float(iFrame+1));\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Buffer A","description":"","type":"buffer"}]}