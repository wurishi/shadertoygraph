{"ver":"0.1","info":{"id":"slKBRm","date":"1664366677","viewed":190,"name":"Reflection with Ray Marching","username":"Renslay","description":"An iterative ray marching using SDF, using reflective surfaces and hard shadows.","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","reflection","sdf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float PRECISION = 0.001;\nconst float EPSYLON = 0.01;\nconst float SUN_RADIUS = 0.1; // radius of the sphere around the light source\n\nconst int RAY_DEPTH = 10; // Rays are bouncing around! :)\n\n///////////////////////////////////////////////////////\n// Utils for surface and material descriptions\n\nstruct Material {\n  vec3 ambientColor; // k_a * i_a\n  vec3 diffuseColor; // k_d * i_d\n  vec3 specularColor; // k_s * i_s\n  float alpha; // shininess\n  float ref; // reflection (0: non-reflective, 1: perfect mirror)\n};\n\nstruct Surface {\n  int id; // id of an object\n  float sd; // signed distance\n  Material mat;\n};\n\n///////////////////////////////////////////////////////\n// Surfaces\n\nfloat sdSphere(vec3 p, float r ) {\n  return length(p) - r;\n}\n\nfloat sdFloor(vec3 p, float r ) {\n  return p.y + r;\n}\n\nfloat sdLeftWall(vec3 p, float r ) {\n  return p.x + r;\n}\n\nfloat sdRightWall(vec3 p, float r ) {\n  return -p.x + r;\n}\n\nfloat sdBackWall(vec3 p, float r ) {\n  return p.z + r;\n}\n\nfloat sdFrontWall(vec3 p, float r ) {\n  return -p.z + r;\n}\n\n///////////////////////////////////////////////////////\n// Materials\n\n// Sun will be handled differently; some parameters are ineffective\nMaterial sun() {\n  vec3 aCol = 0.5 * vec3(0.7, 0.5, 0);\n  vec3 dCol = 0.6 * vec3(0.7, 0.7, 0);\n  vec3 sCol = 0.6 * vec3(1, 1, 1);\n  float a = 5.;\n  float ref = 0.0;\n\n  return Material(aCol, dCol, sCol, a, ref);\n}\n\nMaterial gold() {\n  vec3 aCol = 0.5 * vec3(0.7, 0.5, 0);\n  vec3 dCol = 0.6 * vec3(0.7, 0.7, 0);\n  vec3 sCol = 0.6 * vec3(1, 1, 1);\n  float a = 5.;\n  float ref = 0.3;\n\n  return Material(aCol, dCol, sCol, a, ref);\n}\n\nMaterial silver() {\n  vec3 aCol = 0.4 * vec3(0.8);\n  vec3 dCol = 0.5 * vec3(0.7);\n  vec3 sCol = 0.6 * vec3(1, 1, 1);\n  float a = 5.;\n  float ref = 0.3;\n\n  return Material(aCol, dCol, sCol, a, ref);\n}\n\nMaterial blue() {\n  vec3 aCol = 0.5 * vec3(0.2, 0.2, 0.8);\n  vec3 dCol = 0.6 * vec3(0.7);\n  vec3 sCol = 0.6 * vec3(0);\n  float a = 5.;\n  float ref = 0.0;\n\n  return Material(aCol, dCol, sCol, a, ref);\n}\n\nMaterial green() {\n  vec3 aCol = 0.5 * vec3(0.2, 0.8, 0.2);\n  vec3 dCol = 0.6 * vec3(0.7);\n  vec3 sCol = 0.6 * vec3(0);\n  float a = 5.;\n  float ref = 0.0;\n\n  return Material(aCol, dCol, sCol, a, ref);\n}\n\nMaterial red() {\n  vec3 aCol = 0.5 * vec3(0.8, 0.2, 0.2);\n  vec3 dCol = 0.6 * vec3(0.7);\n  vec3 sCol = 0.6 * vec3(0);\n  float a = 5.;\n  float ref = 0.0;\n\n  return Material(aCol, dCol, sCol, a, ref);\n}\n\nMaterial purple() {\n  vec3 aCol = 0.5 * vec3(0.8, 0.2, 0.8);\n  vec3 dCol = 0.6 * vec3(0.7);\n  vec3 sCol = 0.6 * vec3(0);\n  float a = 5.;\n  float ref = 0.0;\n\n  return Material(aCol, dCol, sCol, a, ref);\n}\n\nMaterial checkerboard(vec3 p) {\n  vec3 aCol = vec3(1. + 0.7*mod(floor(p.x) + floor(p.z), 2.0)) * 0.3;\n  vec3 dCol = vec3(0.3);\n  vec3 sCol = vec3(0);\n  float a = 1.;\n  float ref = 0.5;\n\n  return Material(aCol, dCol, sCol, a, ref);\n}\n\n///////////////////////////////////////////////////////\n// Utils for surface unions\n\nSurface opUnion(Surface obj1, Surface obj2) {\n  if (obj2.sd < obj1.sd) return obj2;\n  return obj1;\n}\n\n// The gold and silver spheres are fused smoothly\nSurface opSmoothUnion( Surface obj1, Surface obj2, float k ) {\n    float d1 = obj1.sd;\n    float d2 = obj2.sd;\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    float sd = mix( d2, d1, h ) - k*h*(1.0-h);\n    \n    if (h > 0.5) {\n      obj1.sd = sd;\n      return obj1;\n    }\n    obj2.sd = sd;\n    return obj2;\n}\n\n\n///////////////////////////////////////////////////////\n// The main scene\n\nSurface scene(vec3 p) {\n  Surface sFloor = Surface(1, sdFloor(p, 1.0), checkerboard(p));\n  Surface sLeftWall = Surface(2, sdLeftWall(p, 4.0), blue());\n  Surface sRightWall = Surface(3, sdRightWall(p, 4.0), green());\n  Surface sBackWall = Surface(4, sdBackWall(p, 6.0), red());\n  Surface sFrontWall = Surface(5, sdFrontWall(p, 6.0), purple());\n  Surface sSphereGold = Surface(6, sdSphere(p - vec3(-.5, 1, 0), sin(iTime/2.)/2.+.5), gold());\n  Surface sSphereSilver = Surface(7, sdSphere(p - vec3(.5, 1, 0), -sin(iTime/2.)/2.+.5), silver());\n  // The position of the sun is the same as the light source\n  Surface sSun = Surface(0, sdSphere(p - vec3(cos(iTime), 3, sin(iTime)), SUN_RADIUS), sun());\n  \n  Surface co = sSphereGold;\n  co = opSmoothUnion(co, sSphereSilver, 0.5);\n  co = opUnion(co, sFloor);\n  co = opUnion(co, sLeftWall);\n  co = opUnion(co, sRightWall);\n  co = opUnion(co, sBackWall);\n  co = opUnion(co, sFrontWall);  \n  co = opUnion(co, sSun);\n  return co;\n}\n\n///////////////////////////////////////////////////////\n// Ray marching\n\nSurface rayMarch(vec3 ro, vec3 rd) {\n  float depth = MIN_DIST;\n  Surface co;\n\n  for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n    vec3 p = ro + depth * rd;\n    co = scene(p);\n    depth += co.sd;\n    if (co.sd < PRECISION || depth > MAX_DIST) break;\n  }\n  \n  co.sd = depth;\n\n  return co;\n}\n\n// Tetrahedron method for calculating surface normals\n// https://iquilezles.org/articles/normalsSDF/\nvec3 calcNormal(vec3 p) {\n    vec2 e = vec2(1.0, -1.0) * 0.0005;\n    return normalize(\n      e.xyy * scene(p + e.xyy).sd +\n      e.yyx * scene(p + e.yyx).sd +\n      e.yxy * scene(p + e.yxy).sd +\n      e.xxx * scene(p + e.xxx).sd);\n}\n\n// Result of a raycast\nstruct CastRayResult {\n    bool isHit; // true if we hit a surface; if false, the rest is irrelevant\n    vec3 p; // position of the hit\n    vec3 n; // normal vector at hit point\n    Surface co; // what surface did we hit\n};\n\n// Casting a ray from ray origin at ray direction\nCastRayResult castRay(vec3 ro, vec3 rd){\n    CastRayResult result;\n    result.isHit = false;\n    \n    result.co = rayMarch(ro, rd);\n    if (result.co.sd > MAX_DIST) return result;\n\n    result.isHit = true;\n    result.p = ro + rd * result.co.sd;\n    result.n = calcNormal(result.p);\n    \n    // move p a bit in the direction of n to avoid self-collision at the next ray cast\n    result.p += result.n * EPSYLON;\n    \n    return result;\n}\n\n///////////////////////////////////////////////////////\n// Camera matrix\n\nmat3 camera(vec3 cameraPos, vec3 lookAtPoint) {\n\tvec3 cd = normalize(lookAtPoint - cameraPos); // camera direction\n\tvec3 cr = normalize(cross(vec3(0, 1, 0), cd)); // camera right\n\tvec3 cu = normalize(cross(cd, cr)); // camera up\n\t\n\treturn mat3(-cr, cu, -cd);\n}\n\n///////////////////////////////////////////////////////\n// Phong light model\n\nvec3 phong(vec3 lightDir, vec3 normal, vec3 rd, Material mat) {\n  // ambient\n  vec3 ambient = mat.ambientColor;\n\n  // diffuse\n  float dotLN = clamp(dot(lightDir, normal), 0., 1.);\n  vec3 diffuse = mat.diffuseColor * dotLN;\n\n  // specular\n  float dotRV = clamp(dot(reflect(lightDir, normal), rd), 0., 1.);\n  vec3 specular = mat.specularColor * pow(dotRV, mat.alpha);\n\n  return ambient + diffuse + specular;\n}\n\n///////////////////////////////////////////////////////\n// Main function\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  // Adjust pixel coordinates\n  vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n  // The final color of a pixel\n  vec3 col = vec3(0);\n  \n  // Light source; same position as the \"Sun sphere\"\n  vec3 lightPosition = vec3(cos(iTime), 3, sin(iTime));\n\n  vec3 lp = vec3(0, 1, 0); // lookat point (aka camera target)\n  vec3 ro = vec3(0, 2, 5); // ray origin (camera position)\n\n  vec3 rd = camera(ro, lp) * normalize(vec3(uv, -1)); // ray direction\n\n  // Within the ray casting cycle, we store the previous material's reflection\n  // attribute, to know how to mix the current and the next color\n  float reflection;\n  \n  // Ray casting cycle\n  for (int i = 0; i < RAY_DEPTH; ++i) {\n  \n    CastRayResult ray = castRay(ro, rd);\n    if (!ray.isHit) break;\n    \n    vec3 lightDirection = normalize(lightPosition - ray.p);\n\n    // If we hit the \"sun sphere\", we want to skip shadow rays\n    // oterwise everything would be in a shadow (since the lightsource\n    // is inside the sphere)\n    // Also we cast an artificial second light source just on this sphere,\n    // at direction (1,1,1), so it will look like an actual sphere\n    if (ray.co.id == 0 && i == 0) {\n        col = phong(normalize(vec3(1, 1, 1)), ray.n, rd, ray.co.mat);\n        break;\n    }\n    \n    // Get the proper color at the hit point\n    vec3 newCol = phong(lightDirection, ray.n, rd, ray.co.mat);\n    \n    // In the first iteration there is no previous color\n    if (i == 0)\n      col = newCol;\n    // At further iterations if there is a reflection, we mix the previous\n    // and the new colors\n    else {\n      if (reflection < 0.01) break;\n      col = mix(col, newCol, reflection);\n    }\n    \n    // Cast a shadow ray\n    CastRayResult shadowRay = castRay(ray.p, lightDirection);\n    // We have to consider the \"sun sphere\": hitting the light source\n    // is actually hitting the \"sun sphere\" instead!\n    if (shadowRay.co.sd < distance(ray.p, lightPosition) - SUN_RADIUS - PRECISION)\n      col *= 0.4;\n    \n    // Update the ray origin and the direction for the next ray to cast\n    // and save the reflection attribute for the next color mixing\n    ro = ray.p;\n    rd = reflect(rd, ray.n);\n    reflection = ray.co.mat.ref;    \n  }\n\n  fragColor = vec4(col, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}