{"ver":"0.1","info":{"id":"tlSXDc","date":"1567298075","viewed":126,"name":"Fibers","username":"gressettd","description":"Tiling threads / fibers","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["fiber"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// With props / regards to\n//\n// https://www.shadertoy.com/view/lsdfRM\n// and\n// https://www.researchgate.net/publication/230605029_A_Procedural_Thread_Texture_Model\n//\n\nfloat Random1D(float seed)\n{\n\treturn fract(sin(seed)*32767.0);\n}\n\nfloat Random1DB(float seed)\n{\n\treturn fract(sin(seed)* (65536.0*3.14159265359));\n}\n\nconst float PI = 3.1415926535897932384626433832795;\n\n\nfloat Random2D(vec2 p)\n{\n\tvec2 comparator = vec2(\n\t\t12.34 * Random1D(p.x), \n\t\t56.789 * Random1DB(p.y));\n\tfloat alignment = dot(p, comparator);\n\tfloat amplitude = sin(alignment) * 32767.0;\n\tfloat random = fract(amplitude);\n\treturn random;\n}\n\nfloat Map( float range_a_point, float a0, float a1, float b0, float b1 )\n{\n    return (((range_a_point - a0) * (abs(b1-b0)))/abs(a1-a0)) + b0;\n}\n\nvec4 ComputeThreadPattern(\n\tvec2 pos, \n\n\tfloat twists,\n\tfloat facetLength, // def 5.0\n\tfloat tightness, // 0 .. 1, default 0.5\n\tfloat smoothness, //\n\tvec2 offset, // brightness offset, default 0.3\n\tbool rounded\n\t)\n{\n    vec2 uv = pos;\n\tuv.x *= twists;\n\t\n\n\tfloat twistTrajectory = \n       ( ( asin( 2.0 * uv.y - 1.0)/( PI / 2.0 ) + 1.0 ) * tightness * facetLength ) / 2.0;\n    \n\tfloat thickness = 1.0 - Map(sin(1.0 - PI / 2.0), -1.0, 1.0, 0.0, 0.6);\n\tfloat trajH = uv.x + twistTrajectory;\n\tfloat displacement =\n\t\t(2.0 / thickness) * (trajH - (floor(trajH / thickness) * thickness)) - 1.0;\n\t\n\tfloat pDisplacement =\n\t\tsmoothness * displacement + (1.0 - smoothness);\n\n\tfloat twistShading = 0.0;\n\tif (rounded)\n\t\ttwistShading = exp( -(  pow( pDisplacement, 2.0 )/0.5 ) );\n\telse\n\t\ttwistShading = abs(pDisplacement);\n\n\tfloat yShading = offset.y + (1.0 - offset.y) * sin(uv.y * PI);\n\tfloat xShading = 1.0;\n\tfloat steepness = facetLength;\n\t//if (uv.x < 0.5)\n\t//{\n\t\txShading = offset.x + (1.0 - offset.x) * tanh(pos.x * steepness);\n\t//}\n\t//else\n\t//{\n\t//\txShading = offset.x + (1.0 - offset.x) * tanh((1.0 - scaledPos.x) * steepness);\n\t//}\n\n\tfloat threadShading = twistShading * yShading * xShading;\n\n\treturn vec4(threadShading, twistShading, xShading, yShading);\n}\n\nvec4 ComputeThreadsPatternH(\n    highp vec2 pos,\n    vec2 tiling,\n    \n    float twists,\n\tfloat facetLength, // def 5.0\n\tfloat tightness, // 0 .. 1, default 0.5\n\tfloat smoothness, //\n\tvec2 offset, // brightness offset, default 0.3\n\tbool rounded)\n{\n    highp vec2 uv = \n        vec2(pos.x, fract(pos.y * tiling.y));\n    \n    vec4 rv = ComputeThreadPattern(uv,\n                                twists * tiling.x, \n                                facetLength,\n                                tightness,\n                                smoothness,\n                                offset,\n                                rounded);\n    rv.z = floor(pos.x * tiling.x);\n    rv.w = floor(pos.y * tiling.y);\n    return rv;\n    \n}\n    \nvec4 ComputeThreadsPatternV(\n    highp vec2 pos,\n    vec2 tiling,\n    \n    float twists,\n\tfloat facetLength, // def 5.0\n\tfloat tightness, // 0 .. 1, default 0.5\n\tfloat smoothness, //\n\tvec2 offset, // brightness offset, default 0.3\n\tbool rounded)\n{\n    highp vec2 uv = \n        vec2( pos.y, fract(pos.x * tiling.x));\n    \n    vec4 rv = ComputeThreadPattern(uv,\n                                twists * tiling.x, \n                                facetLength,\n                                tightness,\n                                smoothness,\n                                offset,\n                                rounded);\n    rv.z = floor(pos.x * tiling.x);\n    rv.w = floor(pos.y * tiling.y);\n    return rv;\n    \n}\n\nvec4 ComputeWaveGradientRGB(float t, vec4 bias, vec4 scale, vec4 freq, vec4 phase)\n{\n\tvec4 rgb = bias + scale * cos(6.28 * (freq * t + phase));\n\treturn vec4(clamp(rgb.xyz,0.0,1.0), 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    highp vec2 uv = fragCoord/iResolution.xy;\n    uv += vec2(cos(iTime*0.1) + iTime*0.1,iTime * 0.05);\n    \n    vec4 cc;\n    \n    float switchSeconds = 6.6;\n    float frm = mod(iTime,switchSeconds) /switchSeconds;\n    \n    vec4 bias = vec4(0.5, 0.5, 0.5, 1.0);\n    vec4 scale = vec4(1.0, 1.0, 1.0, 1.0);\n    vec4 freq = vec4(1.0, 1.0, 1.0, 1.0);\n    vec4 phase = vec4(0.0, 0.3333, 0.6666, 1.0);\n    \n    \n    \n    float t = 0.0;\n    \n    if(frm < 0.5)\n    {\n        cc = ComputeThreadsPatternH(\n            uv, \n            vec2(16.0,16.0),\n\n            5.0, \n            5.0, \n            1.0, \n            1.0, \n            vec2(0.5,0.1), \n            true);\n        \n        t = Random1D(cc.w);\n    } else\n        \n    {\n\t    cc = ComputeThreadsPatternV(\n            uv, \n            vec2(16.0,16.0),\n\n            5.0, \n            5.0, \n            1.0, \n            1.0, \n            vec2(0.5,0.1), \n            true);\n        \n        t = Random1D(cc.z);\n    }   \n    \n    vec4 col = cc.x * ComputeWaveGradientRGB(t,bias,scale,freq,phase);\n    \n    // Output to screen\n    fragColor = col;\n}","name":"Image","description":"","type":"image"}]}