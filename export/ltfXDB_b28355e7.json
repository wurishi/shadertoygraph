{"ver":"0.1","info":{"id":"ltfXDB","date":"1439391399","viewed":194,"name":"PT I - The basics","username":"Piperoman","description":"PiperoTutorial 1. Learn more in this tutorial from vgs: https://www.shadertoy.com/view/Md23DV","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["test","learning","nolook"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[],"code":"// Description: Basic concepts & Geometric drawing\n//\n// Introduce basic concepts:\n// - How coordinate system can be used\n// - How pixel point for each shader thread is used propertly\n// - How draw a unique color and a Axis system\n// - How to draw different 2D geometrics\n\n\n////////////////////////////////////////////\n// \t\tFunction declaration\n////////////////////////////////////////////\nvoid getCoordinateSystem( inout vec2 r, in vec2 fragCoord );\nvoid getCoordinateSystemWithAspectRatio( inout vec2 r, in vec2 fragCoord );\nvoid getPoint( in vec2 p, in vec2 fragCoord );\nvoid drawBackground( inout vec3 pixel, in vec3 color );\nvoid drawAxis( inout vec3 pixel, in vec2 r );\nvoid drawCircle( inout vec3 pixel, in vec2 r, in vec3 color, in vec2 center, in float radius );\nvoid drawSmoothCircle(inout vec3 pixel, in vec2 r, in vec2 center, in float radius, in float lineThickness, in bool inside);\nvoid drawStep( inout vec3 pixel, in float amplitude, in float edge, in float variable);\nvoid drawGradient(inout vec3 pixel, bool horizontal, bool growing, in vec2 fragCoord );\nvoid drawClamp(inout vec3 pixel, float variable, float minimun, float maximun, bool growing );\n\n////////////////////////////////////////////\n// \t\tFunction implementation\n////////////////////////////////////////////\n/*\n* // r = x,y [-1.0, 1.0]   \n*/\nvoid getCoordinateSystem( inout vec2 r, in vec2 fragCoord )\n{\n\tr = vec2(2.0 * vec2( fragCoord.xy - 0.5*iResolution.xy ) / iResolution.xy) ; // x,y [-1.0, 1.0]  \n}\n/*\n* This function calculate the vector to normalize from size width x height to -1,1\n* r(x, y) = x,y [-1.0, 1.0]    with aspect ratio\n*/\nvoid getCoordinateSystemWithAspectRatio( inout vec2 r, in vec2 fragCoord )\n{\n\tr = vec2(2.0 * vec2( fragCoord.xy - 0.5*iResolution.xy ) / iResolution.y) ; \n}\n/**\n* This function calculate the normalized point this shader iteration. This is userful to know where we are.\n* p(x, y) = [0, 1]\n*/\nvoid getPoint( in vec2 p, in vec2 fragCoord )\n{\n\tp = vec2(fragCoord.xy / iResolution.xy);\t\n}\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//////////////////////////////////     Userful functions        //////////////////////////////////////////////\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n/*\n* This function return a color in RGB\n*/\nvoid drawBackground( inout vec3 pixel, in vec3 color )\n{\n    pixel = vec3(color);   \n}\n\n/*\n* This function draw the axis\n*/\nvoid drawAxis( inout vec3 pixel, in vec2 r )\n{\t\n\tvec3 backgroundColor = vec3(1.0);\t\t// Background white\n\tvec3 axesColor = vec3(0.0, 0.0, 1.0);\t// Axes in blue\n\tvec3 gridColor = vec3(0.5);\t\t\t\t// Gray grid\n\t\n\t// Draw the grid lines\n\t// we used \"const\" because loop variables can only be manipulated\n\t// by constant expressions.\n\tconst float tickWidth = 0.1;\n\tfor(float i=-2.0; i<2.0; i+=tickWidth) \n    {\n\t\t// \"i\" is the line coordinate.\n\t\tif(abs(r.x - i)<0.004) pixel = gridColor;\n\t\tif(abs(r.y - i)<0.004) pixel = gridColor;\n\t}\n\t// Draw the axes\n\tif( abs(r.x)<0.006 ) pixel = axesColor;\n\tif( abs(r.y)<0.007 ) pixel = axesColor;\n}\n/*\n* This function draw a circle\n*/\nvoid drawCircle( inout vec3 pixel, in vec2 r, in vec3 color, in vec2 center, in float radius )\n{\t    \n\t// Option 1: To draw a shape we should know the analytic geometrical\n\t// expression of that shape.\n\t// A circle is the set of points that has the same distance from\n\t// it its center. The distance is called radius.\n\t// The distance from the coordinate center is sqrt(x*x + y*y)\n\t// Fix the distance as the radius will give the formula for\n\t// a circle at the coordinate center\n\t// sqrt(x*x + y*y) = radius\n\t// The points inside the circle, the disk, is given as\n\t// sqrt(x*x + y*y) < radius\n\t// Squaring both sides will give\n\t// x*x + y*y < radius*radius\n    \n\t// Option 2: There is a shorthand expression for sqrt(v.x*v.x + v.y*v.y)\n\t// of a given vector \"v\", which is \"length(v)\"\n\t\n\t// Option 3: Draw a disk of which center is not at (0,0).\n\t// Say the center is at c: (c.x, c.y). \n\t// The distance of any point r: (r.x, r.y) to c is \n\t// sqrt((r.x-c.x)^2+(r.y-c.y)^2)\n\t// define a distance vector d: (r.x - c.x, r.y - c.y)\n\t// in GLSL d can be calculated \"d = r - c\".\n\t// Just as in division, substraction of two vectors is done\n\t// component by component.\n\t// Then, length(d) means sqrt(d.x^2+d.y^2)\n\t// which is the distance formula we are looking for.\n    \n\t// This shifting of the center of the shape works for any\n\t// kind of shape. If you have a formula in terms of r\n\t// f(r) = 0, then f(r-c)=0 expresses the same geometric shape\n\t// but its coordinate is shifted by c.\n\t\n    //if( r.x*r.x + r.y*r.y < radius*radius ) pixel = color;\t\t// Option 1\n    //if( length(r) < radius) pixel = color;\t\t\t\t\t\t// Option 2 \n\tif( length(r - center) < radius) pixel = color;\t\t\t\t\t// Option 3\n}\n\nvoid drawSmoothCircle(inout vec3 pixel, in vec2 r, in vec2 center, in float radius, in float lineThickness, in bool inside, in vec3 color) \n{\n    float value;\n    if(inside)\n    {\n        // Inside a circle\n        value = 1.0 - smoothstep( radius-lineThickness, radius+lineThickness, length(r-center));\n    }\n    else\n    {\n        // Out of a circle\n        value = smoothstep( radius-lineThickness, radius+lineThickness, length(r-center));\n    }\n    pixel = mix(pixel, color, value);\n}\n\n/*\n* This function draw a edge function\n*\n*    x0 = edge = where change value\n*    x = variable\n* // f(x0, x) = {1 x>x0, \n* //            {0 x<x0\n*/\nvoid drawStep( inout vec3 pixel, in float amplitude, in float edge, in float variable)\n{\n    float ret = amplitude * step(edge, variable); // step function is equivalent to the\n\tpixel = vec3(ret, ret, ret);\n}\n/**\n* Gradient using relative coordinate to set grey color\n*/\nvoid drawGradient(inout vec3 pixel, bool horizontal, bool growing, in vec2 fragCoord )\n{\n   vec2 p = vec2(fragCoord.xy / iResolution.xy);\n    \n   float ret;\n    \n   if(horizontal)\n   {\n      ret = p.x; // the brightness value is assigned the x coordinate it'll create a gradient  \n   }\n   else\n   {\n      ret = p.y; // the brightness value is assigned the y coordinate it'll create a gradient  \n   }\n   if(!growing) ret = 1.0 - ret;\n   pixel = vec3(ret, ret, ret);\n}\n/**\n* This function return a clamp color, like gradient with limits.\n*\n*  f(x, min, max) = { max   x > max\n*                   { x   \t\tmax > x > min\n*                   { min \t \t      \t  min > x\n*    x = variable\n*/\nvoid drawClamp(inout vec3 pixel, float variable, float minimun, float maximun, bool growing )\n{\n    float ret = clamp(variable, minimun, maximun);\n    if(!growing) ret = 1.0 - ret;\n    pixel = vec3(ret);\n}\n/**\n* Main\n* Learning here: https://www.shadertoy.com/view/Md23DV\n*/\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Basic variables\n    vec3 blackColor = vec3(0.0);\n    vec3 grayColor = vec3(0.5);\n    vec3 whiteColor = vec3(1.0);\n    vec3 redColor = vec3(1.0, 0.0, 0.0);\n    vec3 greenColor = vec3(0.0, 1.0, 0.0);\n    vec3 blueColor = vec3(0.0, 0.0, 1.0);\n    \n    // Operation variables\n    vec2 r;\t\t// x,y [-1.0, 1.0] with Aspect Ratio\n    vec2 rxy;  \t// x,y [-1.0, 1.0] \n    vec2 p;\t\t// Point this shader iteration\n    \n    getCoordinateSystem(rxy, fragCoord);\n    getCoordinateSystemWithAspectRatio(r, fragCoord);\n    getPoint(p, fragCoord);\n        \n    // Output variables\n    vec3 pixel = vec3(0.5);\n\n    // Comment draw* functions to avoid draw and overlap :D\n    ////////////////////////////////////\n    //////// Basic draw\t\t\t\t////\n    ////////////////////////////////////\n    \t// ( inout vec3 pixel, in vec3 color )\n    drawBackground( pixel, whiteColor);\n    \t// ( inout vec3 pixel, in vec2 r )\n    drawAxis( pixel, r );\n    \n    ////////////////////////////////////\n    //////  Geometric figures\t\t////\n    ////////////////////////////////////\n    // Try http://www.mathsisfun.com/geometry/plane-geometry.html\n    \t// ( inout vec3 pixel, in vec2 r, in vec3 color, in vec2 center, in float radius )\n    drawCircle( pixel, r, greenColor, vec2(0.0, 0.0), 0.5 );\n    \t// (inout vec3 pixel, in vec2 r, in vec2 center, in float radius, in float lineThickness, in bool inside)\n    drawSmoothCircle(pixel, r, vec2(-1.1,0.3), 0.4, 0.1, true, vec3(0.216, 0.471, 0.698));\n    \n    ////////////////////////////////////\n    /// Functions applied to color\t////\n    ////////////////////////////////////\n    \t// ( inout vec3 pixel, in float amplitude, in float edge, in float variable)\n    //drawStep( pixel, 1.0, 0.0, r.x);\n    \t// (inout vec3 pixel, bool horizontal, bool growing, in vec2 fragCoord )\n    //drawGradient( pixel, true, false, fragCoord);\n    \t// (inout vec3 pixel, float variable, float minimun, float maximun, bool growing )\n    //drawClamp( pixel, r.x, -0.75, 0.75, false);\n    \n    // Final draw\n    fragColor = vec4(pixel, 1.0);\n}\n","name":"","description":"","type":"image"}]}