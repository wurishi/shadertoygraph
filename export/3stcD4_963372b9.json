{"ver":"0.1","info":{"id":"3stcD4","date":"1600967261","viewed":1396,"name":"Capsule shadow","username":"romainguy","description":"Implements the capsule shadow technique used in The Last Of Us. This implementation does not rely on a lookup table like in the original presentation but uses an analytical solution instead.\n\nClick and drag to move the light direction.","likes":19,"published":1,"flags":0,"usePreview":0,"tags":["shadow","occlusion","capsule"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define CONE_ANGLE      45.0 // degrees\n#define SHOW_CAPSULE    1\n#define OCCLUDER_RADIUS 0.2\n#define CONE_DIRECTION  0.5, 0.9, -0.4\n\n#define PI              3.14159265359\n#define saturate(x)     clamp(x, 0.0, 1.0)\n#define sq(x)           (x * x)\n\nfloat acosFast(float x) {\n    // Lagarde 2014, \"Inverse trigonometric functions GPU optimization for AMD GCN architecture\"\n    // This is the approximation of degree 1, with a max absolute error of 9.0x10^-3\n    float y = abs(x);\n    float p = -0.1565827 * y + 1.570796;\n    p *= sqrt(1.0 - y);\n    return x >= 0.0 ? p : PI - p;\n}\n\nfloat acosFastPositive(float x) {\n    // Lagarde 2014, \"Inverse trigonometric functions GPU optimization for AMD GCN architecture\"\n    float p = -0.1565827 * x + 1.570796;\n    return p * sqrt(1.0 - x);\n}\n\nfloat sphericalCapsIntersection(float cosCap1, float cosCap2, float cap2, float cosDistance) {\n    // Oat and Sander 2007, \"Ambient Aperture Lighting\"\n    // Approximation mentioned by Jimenez et al. 2016\n    float r1 = acosFastPositive(cosCap1);\n    float r2 = cap2;\n    float d  = acosFast(cosDistance);\n\n    // We work with cosine angles, replace the original paper's use of\n    // cos(min(r1, r2)_ with max(cosCap1, cosCap2)\n    // We also remove a multiplication by 2 * PI to simplify the computation\n    // since we divide by 2 * PI at the call site\n\n    if (min(r1, r2) <= max(r1, r2) - d) {\n        return 1.0 - max(cosCap1, cosCap2);\n    } else if (r1 + r2 <= d) {\n        return 0.0;\n    }\n\n    float delta = abs(r1 - r2);\n    float x = 1.0 - saturate((d - delta) / max(r1 + r2 - delta, 0.0001));\n    // simplified smoothstep()\n    float area = sq(x) * (-2.0 * x + 3.0);\n    return area * (1.0 - max(cosCap1, cosCap2));\n}\n\nfloat directionalOcclusionSphere(in vec3 pos, in vec4 sphere, in vec4 cone) {\n    vec3 occluder = sphere.xyz - pos;\n    float occluderLength2 = dot(occluder, occluder);\n    vec3 occluderDir = occluder * inversesqrt(occluderLength2);\n\n    float cosPhi = dot(occluderDir, cone.xyz);\n    // sq(sphere.w) should be a uniform --> capsuleRadius^2\n    float cosTheta = sqrt(occluderLength2 / (sq(sphere.w) + occluderLength2));\n    float cosCone = cos(cone.w);\n\n    return 1.0 - sphericalCapsIntersection(cosTheta, cosCone, cone.w, cosPhi) / (1.0 - cosCone);\n}\n\nfloat directionalOcclusionCapsule(in vec3 pos, in vec3 capsuleA, in vec3 capsuleB, in float capsuleRadius, in vec4 cone) {\n    vec3 Ld = capsuleB - capsuleA;\n    vec3 L0 = capsuleA - pos;\n    float a = dot(cone.xyz, Ld);\n    float t = saturate(dot(L0, a * cone.xyz - Ld) / (dot(Ld, Ld) - a * a));\n    vec3 posToRay = capsuleA + t * Ld;\n\n    return directionalOcclusionSphere(pos, vec4(posToRay, capsuleRadius), cone);\n}\n\n//=====================================================\n\n// Sphere intersection\n// From iq\nfloat sphIntersect( in vec3 ro, in vec3 rd, in vec4 sph ) {\n    vec3 oc = ro - sph.xyz;\n    float b = dot( oc, rd );\n    float c = dot( oc, oc ) - sph.w*sph.w;\n    float h = b*b - c;\n    if( h<0.0 ) return -1.0;\n    return -b - sqrt( h );\n}\n\n// From iq\nfloat capIntersect( in vec3 ro, in vec3 rd, in vec3 pa, in vec3 pb, in float r ) {\n    vec3  ba = pb - pa;\n    vec3  oa = ro - pa;\n\n    float baba = dot(ba,ba);\n    float bard = dot(ba,rd);\n    float baoa = dot(ba,oa);\n    float rdoa = dot(rd,oa);\n    float oaoa = dot(oa,oa);\n\n    float a = baba      - bard*bard;\n    float b = baba*rdoa - baoa*bard;\n    float c = baba*oaoa - baoa*baoa - r*r*baba;\n    float h = b*b - a*c;\n    if(h >= 0.0)\n    {\n        float t = (-b-sqrt(h))/a;\n\n        float y = baoa + t*bard;\n        \n        // body\n        if( y>0.0 && y<baba ) return t;\n\n        // caps\n        vec3 oc = (y<=0.0) ? oa : ro - pb;\n        b = dot(rd,oc);\n        c = dot(oc,oc) - r*r;\n        h = b*b - c;\n        if( h>0.0 )\n        {\n            return -b - sqrt(h);\n        }\n    }\n    return -1.0;\n}\n\n// From iq\nvec3 capNormal( in vec3 pos, in vec3 a, in vec3 b, in float r )\n{\n    vec3  ba = b - a;\n    vec3  pa = pos - a;\n    float h = clamp(dot(pa,ba)/dot(ba,ba),0.0,1.0);\n    return (pa - h*ba)/r;\n}\n\n// From iq\nfloat iPlane( in vec3 ro, in vec3 rd ) {\n    return (-1.0 - ro.y)/rd.y;\n}\n\nvec4 Dither_Vlachos(vec4 rgba) {\n    // Vlachos 2016, \"Advanced VR Rendering\"\n    highp vec3 noise = vec3(dot(vec2(171.0, 231.0), gl_FragCoord.xy + iTime));\n    noise = fract(noise / vec3(103.0, 71.0, 97.0));\n    // remap from [0..1[ to [-1..1[\n    noise = (noise * 2.0) - 1.0;\n    return vec4(rgba.rgb + (noise / 255.0), rgba.a);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 p = (2.0 * fragCoord.xy - iResolution.xy) / iResolution.y;\n    \n    vec3 ro = vec3(0.0, 0.0, 4.0 );\n    vec3 rd = normalize( vec3(p,-2.0) );\n    \n    // sphere animation\n    vec4 sph = vec4(cos(iTime + vec3(2.0,1.0,1.0)) * vec3(1.5,0.5,1.0) + vec3(0.0, OCCLUDER_RADIUS * 0.5, 0.0), OCCLUDER_RADIUS);\n    vec3 capsuleA = vec3(cos(iTime + vec3(2.0,0.5,1.0)) * vec3(1.0,0.1,-0.5) - vec3(0.0, OCCLUDER_RADIUS * 0.5, 0.0));\n    vec3 capsuleB = vec3(cos(iTime + vec3(1.0,1.0,1.0)) * vec3(-1.0,0.5,2.0) - vec3(0.0, OCCLUDER_RADIUS * 0.5, 0.0));\n    float capsuleRadius = OCCLUDER_RADIUS;\n\n    vec4 cone = vec4(CONE_DIRECTION, radians(CONE_ANGLE) * 0.5);\n    cone.xz = 2.0 * iMouse.xy / iResolution.xy - 1.0;\n    cone.xyz = normalize(cone.xyz);\n\n    vec3 col = vec3(0.0);\n\n    float tmin = 1e10;\n    \n    float t1 = iPlane( ro, rd );\n    if( t1>0.0 )\n    {\n        tmin = t1;\n        vec3 pos = ro + tmin*rd;\n        vec3 nor = vec3(0.0,1.0,0.0);\n        float occ = 0.0;\n        \n#if SHOW_CAPSULE == 0\n        occ = directionalOcclusionSphere( pos, sph, cone );\n#else\n        occ = directionalOcclusionCapsule( pos, capsuleA, capsuleB, capsuleRadius, cone );\n#endif\n\n        col = vec3(1.0);\n        col *= occ;\n    }\n\n#if SHOW_CAPSULE == 0\n    float t2 = sphIntersect( ro, rd, sph );\n#else\n    float t2 = capIntersect( ro, rd, capsuleA, capsuleB, capsuleRadius );\n#endif\n    if( t2>0.0 && t2<tmin )\n    {\n        tmin = t2;\n        float t = t2;\n        vec3 pos = ro + t*rd;\n#if SHOW_CAPSULE == 0\n        vec3 nor = normalize( pos - sph.xyz );\n#else\n        vec3 nor = capNormal( pos, capsuleA, capsuleB, capsuleRadius );\n#endif\n        col = vec3(1.2);\n        col *= 0.6+0.4*nor.y;\n    }\n\n    col *= exp( -0.05*tmin );\n   \n    fragColor = vec4( col, 1.0 );\n    fragColor = Dither_Vlachos(fragColor);\n}","name":"Image","description":"","type":"image"}]}