{"ver":"0.1","info":{"id":"MsyXzz","date":"1462462472","viewed":363,"name":"Path tracer test #1","username":"elzeru","description":"A first path tracing with depth of field.\nQuantities are not physical for now. Has to be improved !","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["3d","pathtracer","montecarlo","pathtracinf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// A first path tracing with depth of field.\n// By El Zeru\n// Some things from https://drive.google.com/file/d/0B8g97JkuSSBwUENiWTJXeGtTOHFmSm51UC01YWtCZw/view\n// and some lines of code from iq and other members of the Shadertoy community (love you all)\n\n#define PI 3.14159265359\n\n// PRIM_RAY_IT : Max number of iteration for the raycasting\n// PRIM_RAY_STEP : Min step size for the raycasting\n// EPS_NOR : Shift for the normal computation. No need to change\n// NB_RAY : Number of primary ray cast\n// FOCAL_DIST : Focal distance.\n// BLUR_AMOUNT : Amount of blur\n\nconst int PRIM_RAY_IT = 80 ;\nconst float PRIM_RAY_STEP = 0.01;\nconst float EPS_NOR = 0.001;\nconst int NB_RAY = 64;\nconst float FOCAL_DIST = 3.0;\nconst float BLUR_AMOUNT = 0.001;\n\n//Describe the properties of a ray/surface intersection\nstruct Impact {\n\tfloat d;\n    float lum;\n\tvec3 col;\n\tint refl;\n};\n\n//Describe a light \n//In a next version, other objects could be structures.\nstruct Light{\n\tvec3 p;\n    float r;    \n    float lum; \n    vec3 col;\n}\n\n//The light move through time\nlight = Light(vec3( sin(iTime)*1.5, cos(iTime), 1.0), 0.15, 2.0, vec3(1.0,1.0,1.0));\n   \n//Seed and generator\nfloat seed = 0.;\n\nfloat rand() { return fract(sin(seed++)*43758.5453123); }\n\n// A min function based on the distance for the Impact structures\nImpact getClosest( Impact p1, Impact p2 )\n{\n if (p1.d<p2.d)\n    {\n        return p1;\n    }\n    else return p2;\n}\n\n\n//Primitive definition\nfloat dPlaneY( vec3 p )\n{\n\treturn p.y;\n}\n\nfloat dSphere( vec3 p, float s )\n{\n\treturn length(p)-s;\n}\n\n\nfloat dBox( vec3 p, vec3 s )\n{\n\tvec3 d = abs(p) - s; \n    return min(max(d.x,max(d.y,d.z)),0.0) +length(max(d,0.0));\n}\n\nfloat dInvertedBox( vec3 p, vec3 s )\n{\n\treturn -dBox(p,s);\n}\n\n\n//Return information about the closest primitives\nImpact map(in vec3 pos)\n{\n    //Sphere1\n\tfloat sphereRadius = 0.5;\n\tfloat sphereDistance = dSphere( pos-vec3( -1.5, -1.0, 2.5), sphereRadius );\n\tvec3 sphereColour = vec3(1.0, 1.0, 0.8);\n    Impact sphere1_p = Impact(sphereDistance,0.0,sphereColour,0);\n    \n    //Sphere2\n\tsphereRadius = 0.5;\n\tsphereDistance = dSphere( pos-vec3( 2.0, 1.0, 2.0), sphereRadius );\n\tsphereColour = vec3(1.0, 1.0, 0.8);\n    Impact sphere2_p = Impact(sphereDistance,0.0,sphereColour,0);\n    \n    //Box 1\n    vec3 boxSize = vec3(0.2,2.0,2.0);\n    vec3 boxPosition = vec3(1.5,-2.0, 5.0);\n    float boxDistance = dBox(pos-boxPosition, boxSize);\n    vec3 boxColour = vec3(1.0, 1.0, 0.8);   \n   \tImpact box1_p = Impact(boxDistance, 0.0, boxColour,0); \n    \n    //Room\n    vec3 roomSize = vec3(5.0,3.0,5.0);\n    vec3 roomPosition = vec3(0.0,0.0, 1.0);\n    float roomDistance = dInvertedBox(pos-roomPosition, roomSize);\n    \n    //Room colour, fancy or regular\n    //vec3 roomColour = vec3(pow(abs(pos)*0.1,vec3(2.0)) );//+tex.rgb*0.3; \n    vec3 roomColour =vec3(0.8,0.8,0.8);\n    if (pos.x > roomSize.x-0.01) roomColour = vec3(1.0,0.0,0.0);\n    if (pos.x < - roomSize.x+0.01) roomColour = vec3(0.0,0.0,1.0);\n    if (pos.y > roomSize.y-0.01) roomColour = vec3(1.0,0.6,0.2);\n    if (pos.y < - roomSize.y+0.01) roomColour = vec3(0.0,1.0,0.2);\n    Impact room_p = Impact(roomDistance, 0.0, roomColour, 0);\n    \n    //Light globe\n    float lightRadius = light.r;\n\tfloat lightDistance = dSphere( pos-light.p, lightRadius );\n\t\n    Impact light_p = Impact(lightDistance,light.lum, light.col, 0);\n    \n  \n    Impact closest = getClosest(box1_p,sphere1_p);\n    closest= getClosest(closest,sphere2_p); \n    closest= getClosest(closest,room_p); \n    closest= getClosest(closest,light_p); \n      \n    return closest;\n}\n\n//Compute the normal - Gradient of the distance function\nvec3 getNormal( in vec3 pos )\n{\n\tvec2 eps = vec2( EPS_NOR, 0.0 );\t\n\tvec3 nor = vec3(\n\t\tmap(pos+eps.xyy).d - map(pos-eps.xyy).d,\n\t\tmap(pos+eps.yxy).d - map(pos-eps.yxy).d,\n\t\tmap(pos+eps.yyx).d - map(pos-eps.yyx).d );\n    \n\treturn normalize(nor);\n}\n\n//Cast a ray from ro in direction d\nImpact castRay(in vec3 ro, in vec3 d)\n{\n    vec3 r = ro+d*PRIM_RAY_STEP*1.0;\n    Impact impact;\n \tfor (int i = 0; i < PRIM_RAY_IT; i++)\n    {\n        impact = map(r);     \n        if(impact.d < PRIM_RAY_STEP*0.1) {\n            impact.d = length(r-ro);\n            return impact;\n        }\n        r += (impact.d)*d;          \n    }\n    return Impact(0.0,0.0,vec3(0.0,0.0,0.0),-1);\n}\n\n//Return a vector in the \"hemisphere\" of dir\nvec3 vecInHemisphere(vec3 dir, float phi, float sina, float cosa) {\n    // Define a local frame from the normal\n\tvec3 w = normalize(dir), u = normalize(cross(w.yzx, w)), v = cross(w, u);\n   \n\treturn (u*cos(phi) + v*sin(phi)) * sina + w * cosa;\n}\n\n\nvec3 tracePath(in vec3 po, in vec3 dir, in vec2 fragCoord)\n{\n    //Fist impact\n    vec3 p = po;\n    vec3 col_base = vec3(1.0);\n    vec3 col = vec3(0.0);\n    vec3 norm = getNormal(p);\n    \n    //Secondary impacts\n    float fact_r = 1.0;\n    for (int i = 0; i<2   ;i++)\n        {   \n     \n\t        Impact impact = castRay(p,dir);\n    \t    p = p+dir*impact.d;\n            \n            vec3 norm = getNormal(p);             \n\t\t\t\n\t\t\tvec3 dirToLight0 = light.p - p;\n            //Compute cos of angular diameter of the light sphere\n\t\t\tfloat cos_a_max = sqrt(1. - clamp(light.r * light.r / dot(dirToLight0, dirToLight0), 0., 1.));\n\n\t\t\tfloat cosa = mix(cos_a_max, 1., rand());\n            \n            //Compute sample direction\n \t\t    vec3 dirToLight = normalize(vecInHemisphere(dirToLight0, 2.*PI*rand(), sqrt(1. - cosa*cosa), cosa));\n    \n\t\t\tImpact impactOnLight = castRay(p,dirToLight);\n            \n            //Compute intensity of light on surface\n\t\t\tfloat omega = 2. * PI * (1. - cos_a_max);\n\t\t\tfloat e = (impactOnLight.lum * clamp(dot(dirToLight, norm),0.,1.) * omega) / PI;\t\t\t\t    \n  \t\t   \n            //Dirty 100.0 factor to produce nice image. To improve...\n            vec3 myCol = col_base*(impact.col*impact.lum)*1.0 + col_base*impact.col*e*100.0;\n                      \n            col_base = impact.col;             \t\n          \t  \t    \n    \t    col += myCol*fact_r;\n            \n            //Decay of intensity\n            fact_r *=0.9;\n            \n            //Next ray direction\n            norm = getNormal(p);\n            float rand2 = rand();\n            rand2 = rand2 * rand2;\n            dir = vecInHemisphere(norm, 2.*PI*rand(), sqrt(rand2), sqrt(1. - rand2));            \n        }\n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 eye = vec3(0.0, 0.0+0.1,-0.6);\n\n    float resRatio = iResolution.x/iResolution.y;\n    \n    vec3 pixelPos = vec3(fragCoord.xy/ iResolution.xy*vec2(resRatio,1.0)-vec2(0.5*resRatio,0.5),0.0);\n    \n    vec3 dir = normalize(pixelPos - eye);  \n    \n    vec3 focalPoint = pixelPos + dir * FOCAL_DIST;\n    \n    seed = iTime + iResolution.y * fragCoord.x / iResolution.x + fragCoord.y / iResolution.y;\n    \n    vec3 col = vec3(0.0);\n\n    for (int j = 0; j<NB_RAY\t ; j++)\n    { \n    \tvec3 focOp = vec3(rand(),rand(),0.0)*BLUR_AMOUNT;\n        eye = eye+focOp; \n       \tdir = normalize (focalPoint - eye);\n        \n        col+=tracePath(eye,dir, fragCoord*sin(float(j)));             \n    }   \n    \n\tcol /= vec3(NB_RAY);\n    col = pow(col,vec3(0.8));\n       \n    fragColor = vec4(col,1.0);\n    \n}","name":"Image","description":"","type":"image"}]}