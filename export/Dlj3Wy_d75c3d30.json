{"ver":"0.1","info":{"id":"Dlj3Wy","date":"1673863177","viewed":176,"name":"win 10 ","username":"2505598272","description":"from https://www.shadertoy.com/view/lllSR2\nfaster","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["windows10","cineshader"],"hasliked":0,"parentid":"lllSR2","parentname":"w10"},"renderpass":[{"inputs":[],"outputs":[],"code":"\n#define PI     3.1415926535897921284\n#define REP    25\n#define d2r(x) (x * PI / 180.0)\n#define WBCOL  (vec3(0.5, 0.7,  1.7))\n#define WBCOL2 (vec3(0.15, 0.8, 1.7))\n\n\nfloat hash( vec2 p ) {\n  float h = dot( p, vec2( 127.1, 311.7 ) );\n  return fract( sin( h ) * 458.325421) * 2.0 - 1.0;\n}\n\nfloat noise( vec2 p ) {\n  vec2 i = floor( p );\n  vec2 f = fract( p );\n  \n  f = f * f * ( 3.0 - 2.0 * f );\n  \n  return mix(\n    mix( hash( i + vec2( 0.0, 0.0 ) ), hash( i + vec2( 1.0, 0.0 ) ), f.x ),\n    mix( hash( i + vec2( 0.0, 1.0 ) ), hash( i + vec2( 1.0, 1.0 ) ), f.x ),\n    f.y\n  );\n}\n\nvec2 rot(vec2 p, float a) {\n  return vec2(\n    p.x * cos(a) - p.y * sin(a),\n    p.x * sin(a) + p.y * cos(a));\n}\n\nfloat nac(vec3 p, vec2 F, vec3 o) {\n  const float R = 0.0001;\n  p += o;\n  return length(max(abs(p.xy)-vec2(F),0.0)) - R;  \n}\n\n\nfloat by(vec3 p, float F, vec3 o) {\n  const float R = 0.0001;\n  p += o;\n  return length(max(abs(mod(p.xy, 3.0))-F,0.0)) - R;  \n}\n\n\nfloat recta(vec3 p, vec3 F, vec3 o) {\n  const float R = 0.0001;\n  p += o;\n  return length(max(abs(p)-F,0.0)) - R; \n}\n\n\nfloat map1(vec3 p, float scale) {\n  float G = 0.50;\n  float F = 0.50 * scale;\n  float t =  nac(p, vec2(F,F), vec3( G,  G, 0.0));\n  t = min(t, nac(p, vec2(F,F), vec3( G, -G, 0.0)));\n  t = min(t, nac(p, vec2(F,F), vec3(-G,  G, 0.0)));\n  t = min(t, nac(p, vec2(F,F), vec3(-G, -G, 0.0)));\n  return t;\n}\n\nfloat map2(vec3 p) {\n  float t = map1(p, 0.9);\n  t = max(t, recta(p, vec3(1.0, 1.0, 0.02), vec3(0.0, 0.0, 0.0)));\n  return t;\n}\n\n\n// http://glslsandbox.com/e#26840.0\nfloat gennoise(vec2 p) {\n  float d = 0.5;\n  mat2 h = mat2( 1.6, 1.2, -1.2, 1.6 );\n  \n  float color = 0.0;\n  for( int i = 0; i < 2; i++ ) {\n    color += d * noise( p * 5.0 + iTime);\n    p *= h;\n    d /= 2.0;\n  }\n  return color;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    fragColor = vec4(0.0);\n    for(int count = 0 ; count < 2; count++) {\n        vec2 uv = -1.0 + 2.0 * ( fragCoord.xy / iResolution.xy );\n        uv *= 1.4;\n        uv.x += hash(uv.xy + iTime + float(count)) / 512.0;\n        uv.y += hash(uv.yx + iTime + float(count)) / 512.0;\n        vec3 dir = normalize(vec3(uv * vec2(iResolution.x / iResolution.y, 1.0), 1.0 + sin(iTime) * 0.01));\n        dir.xz = rot(dir.xz, d2r(70.0));\n        dir.xy = rot(dir.xy, d2r(90.0));\n        vec3 pos    = vec3(-0.1 + sin(iTime * 0.3) * 0.1, 2.0 + cos(iTime * 0.4) * 0.1, -3.5);\n        vec3  col   = vec3(0.0);\n        float t     = 0.0;\n        float M     = 1.002;\n        float bsh   = 0.01;\n        float dens  = 0.0;\n\n        for(int i = 0 ; i < REP * 24; i++) {\n            float temp = map1(pos + dir * t, 0.6);\n            if(temp < 0.2) {\n                col += WBCOL * 0.005 * dens;\n            }\n            \n            if (temp > 10. && i != 0) {\n                break;\n            } else if (temp > 1.5) {\n                float d = t + temp - 1.;\n                while (t < d) {\n                    t += bsh * M;\n                    bsh *= M;\n                    dens += 0.025;\n                }\n            } else {\n                t += bsh * M;\n                bsh *= M;\n                dens += 0.025;\n            }\n      \n            \n        }\n\n        //windows\n        t = 0.0;\n        for(int i = 0 ; i < REP * 50; i++) {\n            float temp = map2(pos + dir * t);\n            if(temp < 0.1) {\n                col += WBCOL2 * 0.005;\n            }\n            if (temp > 10. && i != 0) {\n                break;\n            }\n            t += temp;\n        }\n        col += ((2.0 + uv.x) * WBCOL2) + (float(REP * 50) / (25.0 * 50.0));\n        col += gennoise(dir.xz) * 0.5;\n        col *= 1.0 - uv.y * 0.5;\n        col *= vec3(0.05);\n        col  = pow(col, vec3(0.717));\n        fragColor += vec4(col, 1.0 / (t));\n    }\n    fragColor /= vec4(2.0);\n}\n\n","name":"Image","description":"","type":"image"}]}