{"ver":"0.1","info":{"id":"sddfWM","date":"1656618007","viewed":76,"name":"Triangle SDF With L1 Metric","username":"Envy24","description":"Triangle SDF With L1 Metric","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["sdf","triangle","line","space","segment","metric","l1"],"hasliked":0,"parentid":"fdGyWV","parentname":"Line SDF With L1 Metric"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define R                           iResolution\n#define TO_CENTERED_NDC(SC)       ( ((SC)+(SC)-R.xy) / R.y )         // in range x=[-AR; AR], y=[-1.0; 1.0]\n#define NZMX                      ( (iMouse.x+iMouse.x-R.x) / R.x )  // in range [-1.0; 1.0]\n#define NZMY                      ( (iMouse.y+iMouse.y-R.y) / R.y )  // in range [-1.0; 1.0]\n#define LMB_IS_HOLD               ( iMouse.z > 0.0 )\n#define INITIALLY_FAR               9e30\n\nfloat L1(vec2 B, vec2 E)\n{\n    vec2 D = E - B;\n    return abs(D.x) + abs(D.y);\n    return abs(E.x - B.x) + abs(E.y - B.y);\n}\n\n// https://www.shadertoy.com/view/fdKyD3\n#define P(t) (S + (E - S)*t)\nfloat segmentSDF_L1(\n    vec2 NDC,\n    vec2 S,\n    vec2 E)\n{\n    float invD0 = 1.0 / (S.y-E.y);\n    return min(L1(P(clamp((NDC.x-S.x)/(E.x-S.x), 0.0, 1.0)), NDC), \n               min(L1(P(clamp((NDC.y+S.y) * invD0, 0.0, 1.0)), NDC),\n                   L1(P(clamp((S.y-NDC.y) * invD0, 0.0, 1.0)), NDC)));\n}\n\nfloat triangleSDF_L1(\n    vec2 NDC,\n    vec2 P0,\n    vec2 P1,\n    vec2 P2)\n{\n    float minDist = INITIALLY_FAR;\n\n    minDist = min(minDist, segmentSDF_L1(NDC, P1, P0));\n    minDist = min(minDist, segmentSDF_L1(NDC, P1, P2));\n    minDist = min(minDist, segmentSDF_L1(NDC, P2, P0));\n    \n    vec3 BARY = inverse(mat3(\n                     P0.x, P0.y, 1.0,\n                     P1.x, P1.y, 1.0,\n                     P2.x, P2.y, 1.0)) * vec3(NDC.x, NDC.y, 1);\n\n    float R = sinOSC(0.0, 0.1, iTime);\n    \n    return \n        BARY.x >= 0.0 && BARY.y >= 0.0 && BARY.z >= 0.0 ?\n            -(minDist + R) :\n             minDist - R;\n}\n\n/* IQ coloring scheme */\nvec3 colorize_field(float dist, vec3 color)\n{\n    // Change color if dist is negative.\n    color = 1.0 - sign(dist) * color;\n    \n    // Attenuate color around edges.\n\tcolor *= 1.0 - exp(-4.0 * abs(dist));\n    \n    // Add interleaved \"lines\".\n\tcolor *= 0.7 + 0.2 * cos(60.0 * dist);\n    \n    // Add white edges.\n    return mix(color, vec3(1.0), 1.0 - smoothstep(0.0, 6./R.y, abs(dist)));\n}\n\nvec3 add_metric_box(\n    vec2 NDC,\n    vec2 P0,\n    vec2 P1,\n    vec2 P2,\n    vec3 color)\n{\n    float unit = 5.0 / R.y;\n\n    vec2 M = \n        LMB_IS_HOLD ?\n            TO_CENTERED_NDC(iMouse.xy):\n            rotateAroundZ(vec2(1, 0), iTime * 0.5) * 0.5;\n            //vec2(0);\n\n    // Add point\n    color = mix(color, vec3(1.0, 1.0, 0.0), smoothstep(unit, 0.0, length(NDC - M) - 0.008));\n\n    float dist_form_point_to_box_edge = L1(NDC, M) - abs(triangleSDF_L1(M, P0, P1, P2));\n    float outline = abs(dist_form_point_to_box_edge);\n    \n    // Add metric box\n    return mix(color, vec3(1.0, 1.0, 0.0), smoothstep(unit, 0.0, outline));\n}\n/* IQ coloring scheme */\n\nvoid mainImage( out vec4 O, in vec2 SC )\n{\n    float xo = sinOSC(-0.3, 0.3, iTime * 0.3);\n    float yo = sinOSC(-0.3, 0.3, iTime * 0.6);\n    float s = 0.75;\n    vec2 P0 = vec2(-0.5, -0.5) * s;\n    vec2 P1 = vec2( 0.0,  0.5) * s;\n    vec2 P2 = vec2( 0.5, -0.5) * s;\n    \n    /**/\n    P0 = rotateAroundZ(P0, iTime * 0.1) + vec2(xo, yo);\n    P1 = rotateAroundZ(P1, iTime * 0.1) + vec2(-xo, yo);\n    P2 = rotateAroundZ(P2, iTime * 0.2) + vec2(xo, -yo);\n    /**/\n    \n    vec2 NDC = TO_CENTERED_NDC(SC) * 1.0;\n    float minDist = triangleSDF_L1(NDC, P0, P1, P2);\n    \n    // Blending.\n    vec3 color = colorize_field(minDist, vec3(0.1, 0.4, 0.7));\n    color = add_metric_box(NDC, P0, P1, P2, color);\n\n    O = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"/* Returns sine modulated value in range [min, max]. */\nfloat sinOSC(in float min, in float max, in float T)\n{\n    float v = (sin(T) + 1.0) * 0.5; // map T to [0.0, 1.0];\n    return min + v * (max - min);   // map T to [min, max];\n}\n\nvec2 rotateAroundZ(vec2 p, float a)\n{\n    float s = sin(a);\n    float c = cos(a);\n\n    return vec2(\n        p.x * c - p.y * s,\n        p.y * c + p.x * s);\n}","name":"Common","description":"","type":"common"}]}