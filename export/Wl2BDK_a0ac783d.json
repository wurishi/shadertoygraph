{"ver":"0.1","info":{"id":"Wl2BDK","date":"1601022083","viewed":98,"name":"oblique_ellipse_scale","username":"wangzhiyong","description":"a test for mouth resize","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["ellipse","scale"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// ellipse_alpha is x_axis/y_axis of the ellipse\n// face_dir is the direction vector of line of iris\n\nvec2 warpLocalScalePositionToUse(vec2 center, vec2 p, vec2 face_dir_x, float r, float R, float intensity, float ratio, float ellipse_alpha)\n{\n    // cos(agnle) = face_dir.x; sin(angle) = - face_dir.y;\n    float cos_alpha = face_dir_x.x;\n    float sin_alpha = -face_dir_x.y;\n    vec2 face_dir_y = vec2(sin_alpha, cos_alpha);\n    \n    vec2 point = p;\n    vec2 p_u = vec2(p.x, p.y * ratio + 0.5 - 0.5 * ratio * ellipse_alpha); \n    vec2 c_u = vec2(center.x, center.y * ratio + 0.5 - 0.5 * ratio * ellipse_alpha);\n    vec2 vec_pc = p_u - c_u;\n    \n    vec2  p_r = vec2(dot(vec_pc, face_dir_x), dot(vec_pc, face_dir_y));\n    \n    \n    float d = sqrt(p_r.x * p_r.x + p_r.y * p_r.y * ellipse_alpha * ellipse_alpha);\n    float scale = (R - r) / r * intensity;\n    float r_m = r * (1.0 + scale);\n    \n    if (d < r_m)\n    {\n        float alpha = 1.0 / (1.0 + scale);\n        point = center + (p - center) * alpha;\n    }\n    else if (d < R)\n    {\n        float percent = (R - d) / (R - r_m);\n        point = center + (p - center) * (R - percent * (R - r)) / d;\n    }\n    \n\treturn point;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\t\n    vec2 point = uv;\n    vec2 center = vec2(0.5);\n    float angle = 30.0 / 180.0 * 3.1416;\n    vec2 dir = vec2(cos(angle), -sin(angle));\n    float ratio = iResolution.y / iResolution.x;\n    float r = 0.18;\n    float R = 0.21;\n    float alpha = 1.5; // the a/b for ellipse\n    float alpha_2 = sqrt(alpha);\n    float intensity = 0.3 + 0.3 * sin(iTime);\n//    float intensity = 0.597;\n    float ar = r;\n    float br = r / alpha;\n    float aR = R;\n    float bR = R / alpha;\n    \n    vec2 pointToUse = vec2(point.x, point.y * ratio + 0.5 - 0.5 * ratio);\n    vec2 centerToUse  = vec2(center.x, center.y * ratio + 0.5 - 0.5 * ratio);\n    \n    point = warpLocalScalePositionToUse(center, point, dir, r, R, intensity, ratio, alpha);    \n    \n    vec2 temp_p = pointToUse - centerToUse;\n    float s_r = sin(angle);\n    float c_r = cos(angle);\n    vec2  p_r = vec2(dot(temp_p, vec2(c_r, -s_r)), dot(temp_p, vec2(s_r, c_r)));\n\n    \n    fragColor = texture(iChannel0, point);\n//    if (abs(pow(p_r.x / aR, 2.0) + pow(p_r.y / bR, 2.0) - 1.0) < 0.01)\n//    {\n//        // 添加边框\n//        fragColor = vec4(1.0);\n//    }\n    \n//    if (abs((point.x - center.x) / (point.y - center.y) * cos(angle) / sin(angle)) < 0.01)\n//    {\n//        // 添加边框\n//        fragColor = vec4(1.0);\n//    }\n\n}","name":"Image","description":"","type":"image"}]}