{"ver":"0.1","info":{"id":"lXfczX","date":"1727718107","viewed":13,"name":"SHADER","username":"Ssofochk","description":"SHADER","likes":0,"published":1,"flags":48,"usePreview":0,"tags":["shader"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdfGRn","filepath":"/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","previewfilepath":"/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dX3Rn","filepath":"/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg","previewfilepath":"/media/ap/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec2 rotate(vec2 uv, float th) {\n  return mat2(cos(th), sin(th), -sin(th), cos(th)) * uv;\n}\n\nvec3 getBackgroundColor(vec2 uv) {\n  vec3 gradientStartColor = vec3(1., 0., 1.);\n  vec3 gradientEndColor = vec3(0., 1., 1.);\n  return mix(gradientStartColor, gradientEndColor, uv.y + sin(iTime));\n}\n\nfloat sdCircle(vec2 uv, float r, vec2 offset) {\n  float x = uv.x - offset.x;\n  float y = uv.y - offset.y;\n\n  return length(vec2(x, y)) - r;\n}\n\nfloat sdRectangle(vec2 uv, vec2 size, vec2 offset, float speed) {\n  uv.x = uv.x - offset.x;\n  uv.y = uv.y - offset.y;\n  uv = rotate(uv, speed*iTime);\n\n  return max(abs(uv.x)-size.x, abs(uv.y)-size.y);\n}\n\nfloat sdEqTriangle(vec2 uv, float r, vec2 offset, float speed) {\n    uv -= offset;\n    uv = rotate(uv, speed*iTime);\n    const float k = sqrt(3.);\n    uv.x = abs(uv.x) - r;\n    uv.y = uv.y + r/k;\n    if(uv.x + k * uv.y > 0.0 ) uv = vec2(uv.x-k*uv.y,-k*uv.x-uv.y)/2.0;\n    uv.x -= clamp(uv.x, -2.0*r, 0.0 );\n    return -length(uv)*sign(uv.y);\n}\n\nvec3 drawScene(vec2 uv) {\n  vec3 col = getBackgroundColor(uv);\n  vec2 ofs1 = texelFetch(iChannel0, ivec2(0, 0), 0).xy + vec2(1.5, 1.1);\n  vec2 ofs2 = texelFetch(iChannel0, ivec2(0, 0), 0).zw + vec2(1.4, 1.3);\n  float d1 = sdCircle(uv+0.5, 0.1, ofs1);\n  float d2 = sdRectangle(uv+0.5, vec2(0.3, 0.1), ofs2, 5.);\n  float d3 = sdCircle(uv+0.5, 0.07, ofs2);\n  float d4 = sdEqTriangle(uv+0.5, 0.05, ofs2, -5.);\n  vec2 texuv = uv + sin(iTime);\n  vec2 rotuv = rotate(uv, iTime/2.);\n  col = mix(texture(iChannel1, texuv).xyz, col, step(0., d1));\n  col = mix(vec3(1., 0., 0.), col, step(step(0., d3), step(0., d2)));\n  col = mix(texture(iChannel2, rotuv).xyz, col, step(0., d4));\n\n  return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = fragCoord/iResolution.xy;\n  uv.x *= iResolution.x/iResolution.y;\n\n  vec3 col = drawScene(uv);\n\n  fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"const int KEY_LEFT = 37;\nconst int KEY_LEFT1 = 65;\nconst int KEY_RIGHT = 39;\nconst int KEY_RIGHT1  = 68;\n\nvec2 handleKeyboard(vec2 offset, int k_left, int k_right) {\n  float velocity = 1. / 100.; // This will cause offset to change by 0.01 each time an arrow key is pressed\n\n    // texelFetch(iChannel1, ivec2(KEY, 0), 0).x will return a value of one if key is pressed, zero if not pressed\n  vec2 left = texelFetch(iChannel1, ivec2(k_left, 0), 0).x * vec2(-4, 0);\n  vec2 right = texelFetch(iChannel1, ivec2(k_right, 0), 0).x * vec2(4, 0);\n\n    //offset += (left + up + right + down) * velocity;\n  offset += (left + right) * velocity;\n  return offset;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Return the offset value from the last frame (zero if it's first frame)\n    vec2 offset = texelFetch( iChannel0, ivec2(0, 0), 0).xy;\n    vec2 offset1 = texelFetch( iChannel0, ivec2(0, 0), 0).zw;\n    \n    offset = handleKeyboard(offset, KEY_LEFT, KEY_RIGHT);\n    offset1 = handleKeyboard(offset1, KEY_LEFT1, KEY_RIGHT1);\n    \n    \n    offset1.y -= 0.005;\n    if (offset1.y < -.88) {\n        offset1.y = 0.;\n    }\n    if (offset1.x > 0.3*(iResolution.x/iResolution.y)) { //1.2 - край\n        offset1.x = 0.3*(iResolution.x/iResolution.y);\n    }\n    \n    fragColor = vec4(offset, offset1);\n}","name":"Buffer A","description":"","type":"buffer"}]}