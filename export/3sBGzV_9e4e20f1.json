{"ver":"0.1","info":{"id":"3sBGzV","date":"1549316373","viewed":1338,"name":"[twitch] Sky Path","username":"NuSan","description":"Shader coded live on twitch (https://www.twitch.tv/nusan_fx)\nYou can lower the MARCH_STEPS if too slow\nThe shader was made using Bonzomatic.\nYou can find the original shader here: http://lezanu.fr/LiveCode/SkyPath.glsl","likes":51,"published":1,"flags":0,"usePreview":0,"tags":["3d","raymarching","live","twitch"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\nShader coded live on twitch (https://www.twitch.tv/nusan_fx)\nYou can lower the MARCH_STEPS if too slow\n\nThe shader was made using Bonzomatic.\nYou can find the original shader here: http://lezanu.fr/LiveCode/SkyPath.glsl\n*/\n\n#define MARCH_STEPS 100\n#define time iTime\nfloat PI = acos(-1.0);\n\nfloat box(vec3 p, vec3 s) {\n\n  vec3 ap=abs(p)-s;\n  return length(max(vec3(0),ap)) + min(0.0, max(ap.x, max(ap.y,ap.z)));\n\n}\n\nmat2 rot(float a) {\n  float ca=cos(a);\n  float sa=sin(a);\n  return mat2(ca,sa,-sa,ca);\n}\n\nvec3 tunnel(vec3 p) {\n  vec3 off=vec3(0);\n  off.x += sin(p.z*0.6)*0.7;\n  off.x += sin(p.z*0.17)*1.5;\n\n  off.y += cos(p.z*0.27)*0.5;\n  off.y += cos(p.z*0.34)*0.25;\n  return off;\n}\n\nfloat stair(vec3 p, float s1, float s2) {\n\n  p.z = (fract(p.z/s1-0.5)-0.5)*s1;\n  p.yz *= rot(PI*0.25);\n  float b = box(p, vec3(s2,s1,s1));\n\n  return b;\n}\n\nfloat map(vec3 p) {\n\n  float rep = 10.0;\n  p.y -= max(0.0,abs(p.x)-10.0)*0.3;\n  p.x = (fract(p.x/rep-0.5)-0.5)*rep;\n  \n  p += tunnel(p);\n\n  vec3 rp = p;\n  float boxrep = 10.0;\n  rp.z = (fract(rp.z/boxrep-0.5)-0.5)*boxrep;\n\n  vec3 rp2 = p;\n  float boxrep2 = 1.0;\n  rp2.x=abs(rp2.x)-0.4;\n  rp2.z = (fract(rp2.z/boxrep2-0.5)-0.5)*boxrep2;\n\n  float b = box(rp + vec3(0,-9,0), vec3(0.6,10.5,0.6));\n  vec3 rp3 = rp + vec3(0,1.5,0);\n  rp3.xy *= rot(PI*0.3);\n  rp3.yz *= rot(PI*0.3);\n  float b2 = box(rp3, vec3(0.7));\n  b2 = max(b2, p.y+1.5);\n  b = min(b, b2);\n\n  \n\n  float st = stair(p, 0.1, 0.4);\n  float st2 = stair(p + vec3(0,0.7,0), 0.6, 0.4);\n\n  b = max(b, -st2);\n\n  float c = box(rp2 + vec3(0,0.3,0), vec3(0.05,0.3,0.2));\n  rp2.y = abs(rp2.y + 0.43)-0.1;\n  c = min(c, box(rp2, vec3(0.03,0.03,1.0)));\n  \n  \n\n  return min(c,min(b, st));\n}\n\n\nvec3 norm(vec3 p) {\n  vec2 off=vec2(0.01,0);\n  return normalize(map(p)-vec3(map(p-off.xyy), map(p-off.yxy), map(p-off.yyx)));\n}\n\nfloat rnd(vec2 uv) {\n  return fract(dot(sin(uv*723.588+uv.yx*413.877),vec2(9865.535)));\n}\n\nfloat rnd(float t) {\n  return fract(sin(t*435.232)*7412.223);\n}\n\nfloat curve(float t, float d) {\n  float g=t/d;\n  return mix(rnd(floor(g)),rnd(floor(g)+1.0), pow(smoothstep(0.0,1.0,fract(g)), 10.0));\n}\n\nfloat curve2(float t, float d) {\n  float g=t/d;\n  float ig = floor(g);\n  float fg = fract(g);\n  fg = smoothstep(0.0,1.0,fg);\n  fg = pow(fg,rnd(ig)*2.0+0.5);  \n  //fg = smoothstep(0,1,fg);\n  return (ig+fg)*d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n  uv -= 0.5;\n  uv /= vec2(iResolution.y / iResolution.x, 1);\n\n  float rand=rnd(uv);\n  float dither = 0.8+0.1*rand;\n\n  vec3 s=vec3(0,-1,0);\n  vec3 t=vec3(0,-0.3,3);\n  vec3 tar=vec3(0,-0.7,3);\n\n  float motion = curve2(time*1.5, 0.8)*3.0;\n  s.z += motion;\n  t.z += motion;\n  //tar.z += time*1.5*3.0;// + pow(curve(time, 0.7),2)*5.0;\n  float offset = 15.0;\n  tar.z += (curve2(time*1.5-offset, 1.1)+offset)*3.0 + pow(curve(time, 0.9),3.0)*5.0;\n\n  s-=tunnel(s);\n  vec3 offt = tunnel(t);\n  t-=offt;\n  tar-=tunnel(tar);\n\n  vec3 cz=normalize(t-s);\n  vec3 cx=normalize(cross(cz, vec3(0,1,0) - offt*0.2));\n  vec3 cy=normalize(cross(cz,cx));\n\n  vec3 r = normalize(cx*uv.x + cy*uv.y + cz*(0.7+sin(time*2.0)*0.4));\n  \n  vec3 col = vec3(0);\n  vec3 l = normalize(vec3(-0.7,-1.0,-0.5));\n\n  vec3 back = mix(vec3(0.1,0.3,1.0)*0.1, vec3(1.0,0.3,0.5)*0.5, pow(r.y*0.5+0.5,2.0));\n\n  vec3 p = s;\n  float dd=0.0;\n  int i=0;\n  float at=0.0;\n  float at2 = 0.0;\n  for(i=0; i<MARCH_STEPS; ++i) {\n    float d=map(p) * dither;\n    if(d<0.001) {\n      vec3 n=norm(p);\n      float fog = clamp(1.0-dd*0.018, 0.0, 1.0);\n      float bot = pow(clamp(-(p.y-10.0)*.1,0.0,1.0),2.0)*fog;\n\n      float aodist = 0.3;\n      float ao = clamp(map(p+n*aodist)/aodist,0.0,1.0);\n      ao = mix(ao,1.0,0.3);\n      \n      float f = pow(1.0-dot(n,-r), 2.0);\n      col += vec3(0.3,0.4,0.7)*max(0.0, dot(n,l)) * bot * ao;\n      col += 4.0*f * back*2.0 * (-n.y*0.5+0.5) * bot*ao;\n\n      dd = mix(100.0, d, bot);\n      \n      break;\n    }\n    if(dd>100.0) {\n      dd=100.0;\n      break;\n    }\n    p+=d*r;\n    dd+=d;\n\n    at += exp(-length(tar-p)*7.0);\n    at2 += exp(-d*0.1)*0.05;\n  }\n  if(i>99) dd=100.0;\n\n  col += vec3(1,0.3,0.5) * at * 3.3;\n  col += vec3(1,0.3,0.5) * at2 * 0.2;\n  col += back*0.05 * exp(dd*0.05);\n\n\n  fragColor = vec4(col, 1);\n}","name":"Image","description":"","type":"image"}]}