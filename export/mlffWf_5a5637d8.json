{"ver":"0.1","info":{"id":"mlffWf","date":"1693549656","viewed":169,"name":"Generalized Kuwahara shader","username":"p4vv37","description":"Generalized Kuwahara filter, based on work of Acerola, basically his code rewritten to Shadertoy\n- https://www.youtube.com/watch?v=LDhN-JK3U9g\n- https://github.com/GarrettGunnell/Post-Processing/tree/main/Assets/Kuwahara%20Filter","likes":5,"published":1,"flags":0,"usePreview":1,"tags":["kuwahara","generalized"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\nGeneralized Kuwahara filter, based on work of Acerola\nBasically Acerola code rewritten to Shadertoy\n- https://www.youtube.com/watch?v=LDhN-JK3U9g\n- https://github.com/GarrettGunnell/Post-Processing/tree/main/Assets/Kuwahara%20Filter\n*/\n\nconst int _KernelSize = 6;\nconst int N = 4;\nconst float alpha = 0.5;\nconst float q = 18.;\nconst float PI = 3.14159265358979323846;\nconst float _Hardness = 100.;\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv=fragCoord/iResolution.xy;\n    int kernelRadius = _KernelSize;\n\n\n    float zeta = 2.0f / float(kernelRadius);\n\n    float zeroCross = 2.;\n\n    float sinZeroCross = sin(zeroCross);\n    float eta = 0.;\n    int k;\n    vec4 m[8];\n    vec3 s[8];\n\n\n    for (k = 0; k < N; ++k) {\n        m[k] = vec4(0.0f);\n        s[k] = vec3(0.0f);\n    }\n\n\n    for (int y = -kernelRadius; y <= kernelRadius; ++y) {\n        for (int x = -kernelRadius; x <= kernelRadius; ++x) {\n            vec2 v = vec2(x, y) / float(kernelRadius);\n            vec3 c = texture ( iChannel0 , uv + vec2(x, y) * 1.0/iResolution.xy). xyz;\n            c = clamp(c,0.0,1.0) ;\n            float sum = 0.;\n            float w[8];\n            float z, vxx, vyy;\n\n            /* Calculate Polynomial Weights */\n            vxx = zeta - eta * v.x * v.x;\n            vyy = zeta - eta * v.y * v.y;\n            z = max(0., v.y + vxx); \n            w[0] = z * z;\n            sum += w[0];\n            z = max(0., -v.x + vyy); \n\n\n            w[2] = z * z;\n            sum += w[2];\n            z = max(0., -v.y + vxx); \n            w[4] = z * z;\n            sum += w[4];\n            z = max(0., v.x + vyy); \n            w[6] = z * z;\n            sum += w[6];\n            v = sqrt(2.0f) / 2.0f * vec2(v.x - v.y, v.x + v.y);\n            vxx = zeta - eta * v.x * v.x;\n            vyy = zeta - eta * v.y * v.y;\n            z = max(0., v.y + vxx); \n            w[1] = z * z;\n            sum += w[1];\n            z = max(0., -v.x + vyy); \n            w[3] = z * z;\n            sum += w[3];\n            z = max(0., -v.y + vxx); \n            w[5] = z * z;\n            sum += w[5];\n            z = max(0., v.x + vyy); \n            w[7] = z * z;\n            sum += w[7];\n\n\n            float g = exp(-3.125f * dot(v,v)) / sum;\n\n            for (int k = 0; k < 8; ++k) {\n                float wk = w[k] * g;\n                m[k] += vec4(c * wk, wk);\n                s[k] += c * c * wk;\n            }\n        }\n\n    }\n\n    vec4 ou = vec4(0.);\n    for (k = 0; k < N; ++k) {\n        m[k].rgb /= m[k].w;\n        s[k] = abs(s[k] / m[k].w - m[k].rgb * m[k].rgb);\n\n        float sigma2 = s[k].r + s[k].g + s[k].b;\n        float w = 1.0f / (1.0f + pow(_Hardness * 1000.0f * sigma2, 0.5f * q));\n\n        ou += vec4(m[k].rgb * w, w);\n    }\n\n    fragColor = clamp((ou / ou.w),0.0,1.0);\n}","name":"Image","description":"","type":"image"}]}