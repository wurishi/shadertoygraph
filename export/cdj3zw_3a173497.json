{"ver":"0.1","info":{"id":"cdj3zw","date":"1667409489","viewed":86,"name":"Continuous vector field (NDC)","username":"Envy24","description":"Mouse.y control DIR_SCALE.\nTruncated variant: https://www.shadertoy.com/view/ddX3WX","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["field","vector","continuous"],"hasliked":0,"parentid":"DsSGzw","parentname":"Truncated VS Continuous Cells"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define R                         ( iResolution )\n#define AR                        ( R.x / R.y )                      // Aspect ratio.\n#define PIXELATE(SC, PS)          ( floor( (SC) / (PS) ) * (PS) )    // PS - pixel size\n\n#define MOUSE_OFFSET ( iMouse.z > 0. ? iMouse.xy - R.xy * 0.5 : vec2(0) )\nvec2 map_to_centered_ndc(in vec2 SC, in float scale, in vec2 origin, in bool use_mouse)\n{\n    vec2 M = MOUSE_OFFSET * (use_mouse ? 1. : 0.);\n    return ((2. * (SC - M) - R.xy) / R.y) * scale - origin;\n}\nvec2 truncated_centered_cells_map(in vec2 SC, in float scale, in vec2 origin, in bool use_mouse, in float ps_size)\n{\n    return map_to_centered_ndc(PIXELATE(SC, ps_size)+vec2(ps_size*0.5), scale, origin, use_mouse);\n}\n\n// Points after point E.\nfloat arrowSDF(\n    in vec2 NDC,\n    in vec2 B,\n    in vec2 E,\n    in float r,\n    in float S) // Scale for working in screen coordinates.\n{\n    float len = length(B-E);\n    vec2 dir = len < 1e-7 ? vec2(1,0) : normalize(E-B),\n         up = cross(vec3(dir, 0.), vec3(0, 0, -1)).xy,\n         C = E - dir * 0.05 * S, //      U--\n         U = C + up  * 0.05 * S, // B----C--E--E'\n         D = C - up  * 0.05 * S; //      D--\n         E += dir * 0.05 * S;\n    \n    vec3 BARY = inverse(mat3(\n            U.x, U.y, 1.0,\n            D.x, D.y, 1.0,\n            E.x, E.y, 1.0)) * vec3(NDC.x, NDC.y, 1.0);\n    \n    float sign = \n        BARY.x >= 0.0 &&    \n        BARY.y >= 0.0 && \n        BARY.z >= 0.0 ?  // inside triangle?\n            -1. : 1.;\n    \n    float d = segmentSDF_L2(NDC, U, D, 0.);\n          d = min(d, segmentSDF_L2(NDC, U, E, 0.));\n          d = min(d, segmentSDF_L2(NDC, D, E, 0.));\n          d = \n              len < 0.05 * S ? \n                  d :\n                  min(d, segmentSDF_L2(NDC, B, C, 0.));\n    \n    return sign*d-r;\n}\n\n// for NDC\nvec2 vector_field_ndc(vec2 P)\n{\n    //return vec2(1, 1);\n    //return vec2(P.y*P.y, -P.x);\n    //return vec2(P.y, -P.x);\n    //return rotateAroundZ(vec2(P.y, -P.x), iTime);\n    return rotateAroundZ(vec2(P.y*P.y, -P.x), iTime);\n}\n\n#define SCENE_SCALE    ( 1.0 )\n#define ORIGIN         ( vec2(0) )\n#define CELL_SIZE_SC   ( 50. )\n#define CELL_SIZE_NDC  ( (2.*CELL_SIZE_SC*SCENE_SCALE) / R.y )\n#define RANGES         ( map_to_centered_ndc(R.xy, SCENE_SCALE, vec2(0), false) )\n#define DIR_SCALE      ( iMouse.z > 0. ? iMouse.y/R.y : 0.125 )\n#define ORDER          ( 4. )   // increase this parameter if arrows looks truncated.\n\nvec3 scene(in vec2 SC)\n{      \n    vec2 NDC = map_to_centered_ndc(SC, SCENE_SCALE, ORIGIN, false),\n         CC = truncated_centered_cells_map(SC, SCENE_SCALE, ORIGIN, false, CELL_SIZE_SC),\n         ranges = RANGES;\n                        \n    vec2 CC_ = CC; \n    //vec3 color = vec3(normalize(vector_field_ndc(CC)), 0.5);  // Pixelated    \n    vec3 color = vec3(normalize(vector_field_ndc(NDC).xy), 0.5); // Smooth\n     \n    for (float y = -ORDER; y <= ORDER; y += 1.)\n    {       \n        for (float x = -ORDER; x <= ORDER; x += 1.)\n        {\n            // Calculate current cell center.\n            vec2 CC = CC_ + vec2(x*CELL_SIZE_NDC, y*CELL_SIZE_NDC);\n            \n            // Optimization 1. Truncate scene.\n            //if (abs(CC.x) > ranges.x || abs(CC.y) > ranges.y) { continue; }\n            \n            /* Optimization 2. If NDC is far from CC, then skip this cell. *\n            vec2 diff = CC - NDC; \n            if (dot(diff, diff) > CELL_SIZE_NDC) { continue; }\n            /**/\n            \n            vec2 dir = vector_field_ndc(CC) * DIR_SCALE,\n                 E = CC + dir * 0.5; // half step forward\n                 CC -= dir * 0.5;    // half step back\n\n            float minDist = arrowSDF(NDC, CC, E, 0., 0.25*SCENE_SCALE);\n    \n            color = mix( color, vec3(1), smoothstep((3.*SCENE_SCALE)/R.y, 0., minDist));                 \n        }\n    }\n    \n    return color;\n}\n\nvoid mainImage( out vec4 O, in vec2 SC )\n{\n    vec3 color = scene(SC); // continuous and faster than second scene.\n\n    O = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"\n\nfloat diskSDF_L2(vec2 NDC, vec2 C, float r)\n{\n    return length(C - NDC)-r;\n}\n\nfloat segmentSDF_L2(\n    in vec2 NDC,\n    in vec2 B,   \n    in vec2 E,\n    float r)\n{\n    vec2 BP = NDC - B, BE = E - B;\n    return length(BP - BE * clamp(dot(BP, BE) / dot(BE, BE), 0.0, 1.0)) - r;\n}\n\nvec2 rotateAroundZ(vec2 p, float a)\n{\n    float s = sin(a);\n    float c = cos(a);\n\n    return vec2(\n        p.x * c - p.y * s,\n        p.y * c + p.x * s);\n}","name":"Common","description":"","type":"common"}]}