{"ver":"0.1","info":{"id":"4ldyRj","date":"1533298558","viewed":384,"name":"Arbitrary Regular Stars","username":"nr4","description":"Signed distance to regular stars.","likes":11,"published":1,"flags":0,"usePreview":0,"tags":["2d","sdf","stars","regular"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n * Arbitrary Regular Stars\n * \n * Copyright (C) 2018  Alexander Kraus <nr4@z10.info>\n * \n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n * \n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n * \n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n//Update 1: Distance is now not relying on min(.) anymore to decide which edge should be used.\n//Update 2: Added sign to distance function by avoiding length(p).\n//Update 3: Used mix(vec2,vec2,float) for the alternating radii instead of 2 times mix(float,float,float).\n//Update 4: Added slight grid lines\n//Update 5: Fixed rotation and hash evaluation\n//Update 6: Added counter-clockwise rotations\n\nconst float pi = acos(-1.);\nconst vec3 c = vec3(1.,0.,-1.);\n\n// hash function\nfloat r(vec2 a0)\n{\n    return fract(sin(dot(a0.xy ,vec2(12.9898,78.233)))*43758.5453);\n}\n\n// compute distance to regular star\nfloat dstar(vec2 x, float N, vec2 R)\n{\n    float d = pi/N,\n        p0 = acos(x.x/length(x)),\n        p = mod(p0, d),\n        i = mod(round((p-p0)/d),2.);\n    x = length(x)*vec2(cos(p),sin(p));\n    vec2 a = mix(R,R.yx,i),\n    \tp1 = a.x*c.xy,\n        ff = a.y*vec2(cos(d),sin(d))-p1;\n   \tff = ff.yx*c.zx;\n    return dot(x-p1,ff)/length(ff);\n}\n\n#define A iResolution.y\n#define B 3./Y\n#define S(v) smoothstep(-1.5/A,1.5/A,v)\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float a = .1, aa = .5*a; // tile size\n    vec2 uv = fragCoord/A+.5,\n        x = mod(uv, a)-aa, y = uv-x; // we want many polygons\n    \n    //random number of edges and random rotation\n    float p = 5.*(-1.+.1+2.*r(y))*iTime,\n        k = cos(p), s = sin(p),\n        d = dstar(mat2(k,s,-s,k)*x, 3.+floor(8.*r(2.e2*y)), vec2(.15,.45)*a); \n    \n    //set random colors\n    vec3 col = .5 + .5*cos(p+uv.xyx+vec3(0.,2.,4.));\n    fragColor = vec4(col*mix(S(d),1.,.5)+S(-abs(d)),1.);\n    \n    //add borders\n    vec2 v = smoothstep(-aa,-aa+1.5/A,x)*smoothstep(aa,aa-1.5/A,x);\n    fragColor *= v.x*v.y;\n}","name":"Image","description":"","type":"image"}]}