{"ver":"0.1","info":{"id":"7dGBzW","date":"1679166505","viewed":141,"name":"Raymarched moon ","username":"Wildric","description":"Move the mouse in the window to distort the moon","likes":5,"published":1,"flags":32,"usePreview":0,"tags":["raymarching","space","moon"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4df3Rr","filepath":"/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","previewfilepath":"/media/ap/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\nThis function is the most important one here\nIt outputs the distance between a point (position) and the nearest point in \nour shape (if there were multiple shapes, we would need the take the min). \nThis function is used at every iteration of the raymarcher to get if the ray hits\nthe shape or not.\nSince we need to also output the color of the hitten pixel we pass color buffer \n(inout keyword is similar to a pointer)\n\n*/\nfloat GetDistance(in vec3 position, inout vec3 color) {\n        vec2 sphereUV; //This is the buffer where a point is mapped in the sphere\n                       //So that we can texture it \n        vec3 inter = sphere0.center + sphere0.radius*normalize(position - sphere0.center);\n        vec3 n = normalize(inter - sphere0.center); //Normal of a the point in SPHERE (don't need to use here GetNormal then, the shape)\n        sphereUV.x = atan(n.x, - n.z) / (PI*2.0) + 0.5; //https://en.wikipedia.org/wiki/UV_mapping\n        sphereUV.y = 0.5 + asin(n.y)/PI;\n        \n        color = texture(iChannel0, sphereUV * TEXTURE_REPETITION).xyz;\n        \n        //Getting the distance to the nearest point in the shape\n        //Making factor equal to 0 will make the shape just a phere\n        //Substracting varying value (depending here on the uv) will stylize the shape as it is done\n        float factor = perlin(sphereUV * PERLIN_FREQUENCY, 0.5,3.0, 6.0,5.0).x * heightIntensity;\n        float dist = length(sphere0.center - position) - (sphere0.radius - factor);\n       \n        return dist; \n    }\n\n\n/*Function that differentiate a vector relatively to x,y,z\n   (we make the difference with a small value of each coordinate )to\n    get normal at that point. parameter point is the point where \n    we want to get the normal, and prec is the precision to the normal\n    which basically is the macro already defined\n*/\nvec3 GetNormal(vec3 point, float prec) {\n    float dis = GetDistance(point, none);\n    vec2 epsilon = vec2(prec, 0.0);\n    return normalize (dis -\n                vec3(\n                GetDistance(point - epsilon.xyy, none),\n                GetDistance(point - epsilon.yxy,  none),\n                GetDistance(point - epsilon.yyx, none)\n                ));\n}\n\n\n\nvec3 RayMarcher(in camera camera, inout vec3 newPos) {\n    //March from camera till hitting an object or passing depth\n    float march = .05;\n    vec3 position = camera.position + camera.lookAt*march;\n    vec3 outColor = BG;\n    float nearestObj = 0.0;\n    int counter = 0;\n    for (int i = 1; i < MAX_STEPS; i++) {\n       nearestObj = GetDistance(position, outColor);\n       march += nearestObj;\n       position = camera.position+march*camera.lookAt;\n    }\n\n   if (nearestObj > DEPTH) {\n    return BG; //If depth distance is passed we will render BG color in that pixel\n   }\n   //There is here only one iteration\n   //Here is applied the classical Blinn-Phong model \n   // https://en.wikipedia.org/wiki/Blinn%E2%80%93Phong_reflection_model\n    for (int i = 0; i < LIGHT_NUM; i++) {\n            vec3 projection =  normalize(-position + lights[i].position);\n            vec3 normal = GetNormal(position, NORMAL_PRECISION);\n            vec3 reflection = reflect(normal, projection);\n            vec3 blinn = normalize(projection - camera.lookAt);\n            float specular  = pow(max(0.0,dot(blinn, normal)),SPECULAR_QUALITY);\n            float diffuse = dot(projection, normal);\n            vec3 result = (specular+diffuse)*lights[i].color + AMBIENT_LIGHT;\n            outColor *= result;\n    }\n    \n    newPos = position;\n    return outColor;\n\n }\n \n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //making screen coord centred in the middle and orthonormal\n    screenCoord = (fragCoord - 0.5* iResolution.xy)/iResolution.y;\n    vec2 mouse =  iMouse.xy/iResolution.xy;\n    \n    heightIntensity = 0.3*mouse.x;\n   \n    vec3 lookAt = normalize(vec3(screenCoord.xy,1.0));\n    //lookAt = EulerRotation(lookAt,10.0*sin(iTime/2.0),0.0,0.0);  //Camera rotation testing\n    vec3 origin = vec3(0.0,0.0,0.0);\n    //BG = vec3(screenCoord.y, 0.0,screenCoord.y);\n    //It's a bit of a hack; we take rand() and apply power to it to make it fade and just \n    //little white point will remain\n    BG = vec3(pow(rand(screenCoord), STARS));\n    camera cam = camera(origin, lookAt);\n    //Our output\n    vec3 col = RayMarcher(cam, origin);\n\n    fragColor = vec4(col,1.0);\n} ","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"/*\nThe following shader implements the following to generate this beautiful shape:\n\n - One iteration of raytracing (no reflection)\n - Blinn-Phong reflection/lighting model\n - Perlin noise to make the geography of the shape\n - Perlin noise to generate the starry sky in the background\n - Implementation of camera rotation (won't affect the background however)\n\n*/\n\n\nstruct sphere {\n   vec3 center;\n   vec3 color;\n   float radius;\n};\n\nstruct light {\n    vec3 position;\n    vec3 color;\n};\n\nstruct camera {\n    vec3 position;\n    vec3 lookAt;\n};\n\n\n\n\n//User Parameters\n//Sphere and light struct initialization you can set position, radius, color\nsphere sphere0 = sphere(  vec3(0.0, 0.0,2.5), vec3(1.0,0.0, 0.1), 1.0);   \nlight lights[] = light[] ( light (vec3(0.0,0.0,0.0), vec3(1.0)  ) );\n\n//---------Raytracing Parameters\n\n//MAX_STEPS: Indicates how many march in Raymarcher function \n//(Note that in our particular scene we don't need that much, the more there is the lower the fps is)\n#define MAX_STEPS 50\n//MIN_DISTANCE: The distance between a point and an object below which we consider there is collision\n#define MIN_DISTANCE 0.01\n#define NORMAL_PRECISION 0.001\n//DEPTH: How far you can see in the scene\n#define DEPTH 10.0\n\n//---------Noise Parameters\n//PERLIN_OCTAVES: Sets the quality of the perlin noise, bigger this is, better is the perlin noise, however the fps decreases very quickly\n#define PERLIN_OCTAVES 1\n//PERLIN_FREQUENCY: Sets the frequency of noise in this particular scene\n#define PERLIN_FREQUENCY 1.1\n\n//---------Light Parameters\n//Ambient Light color and specular reflection model quality\n#define AMBIENT_LIGHT vec3(0.0,0.0,0.0)\n#define SPECULAR_QUALITY 50.0\n\n\n//---------Other\n//TEXTURE_REPETITION: number of times the texture of iChannel0, mapped in the sphere, should repeat\n#define TEXTURE_REPETITION 1.0\n//STARS: Bigger this is, less stars there are out there\n#define STARS 300.0\n//If you add a light object to associated array, make sure to increase this\n#define LIGHT_NUM 1\n//---------------------------------------------------------------\n\n#define PI 3.14159265359\n\nfloat heightIntensity = 0.0;\nvec3 none; //Buffer that will contain undesired output of GetDistance() function in the case of it's call from within GetNormal()\nvec3 BG = vec3(0.0); //Background Color, it's written in mainImage()\nvec2 screenCoord;  \n\n\n\n\n\n\n//NOISE FUNCTIONS\n//-----------------------------------------------------------------------------------\n\n//Classic fractional random function and noise function, see TheBookOfShaders for more details\nfloat rand(vec2 uv) {\n    return fract(sin(dot(uv, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nfloat noise(vec2 uv, float freq) {\n    uv *= freq;\n    vec2 fractional = fract(uv);\n    vec2 integer = floor(uv);\n    fractional = fractional*fractional*(3.0-2.0*fractional);\n    vec2 down = vec2( rand(integer), rand(integer + vec2(1.0, 0.0)) );\n    vec2 up = vec2( rand(integer + vec2(0.0,1.0)), rand(integer + vec2(1.0, 1.0)) );\n    float x = mix(down.x, down.y, fractional.x);\n    float y = mix(up.x, up.y, fractional.x);\n    return mix(x,y, fractional.y);\n}\n\n//Perlin uses noise function and superimpose multiple layers\n//of it with different frequencies, which we name Octaves, at the end we normalize\nvec3 perlin(vec2 uv, float amplitudeMul, float freqMul,float amplitude, float freq)  {\n    vec3 col = vec3(noise(uv, 10.0)*10.0);\n    float total = amplitude;\n    for (int i = 0; i<PERLIN_OCTAVES; i++) {\n        freq *= freqMul;\n        amplitude *= amplitudeMul;\n        col += vec3(noise(uv, freq)*amplitude);\n        total += amplitude;\n    }\n    col/= total;\n    return col;\n}\n\n\n\n\n/*\n    This function rotates a vector, given angles in degree\n    i'm putting it here in the case if camera is meant to rotate\n    then, we have just to rotate the vector lookAt (see mainImage).\n    Basically it uses rotation matrix from linear algebra\n*/\nvec3 EulerRotation(vec3 vector, float x, float y, float z) {\n   x*= PI/180.0;\n   y*= PI/180.0;\n   z*= PI/180.0;\n  \n   vec3 rot = mat3(\n            1,0,0,\n            0,cos(x), -sin(x),\n            0,sin(x), cos(x)\n           )\n           *\n           mat3(\n            cos(y), -sin(y), 0,\n            sin(y), cos(y), 0,\n            0,0,1\n           )\n           *\n           mat3(\n            cos(z), 0, sin(z),\n            0, 1, 0,\n            -sin(z), 0, cos(z)\n           )\n           *vector;\n           \n   return rot;\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Copyright © 2022 Wildric Auric\n\n\n//Change macros value to generate the best scales output\n\n//Scales shape parameters\nfloat SHAPE_HORIZONTAL_RADIUS  =0.4;\nfloat SHAPE_VERTICAL_RADIUS = 1.8;\nfloat PATTERN_FREQUENCY = 6.0;\n\n\n//Color Parameters\n#define SCALE_COLOR vec3(1.0,1.0,1.0)\n#define NOISE false\n#define BLACK_BORDER true\n#define COLOR_INTENSITY 1.0\n\n#define RANDOMIZE_COLOR false\n#define colIntensity vec3(1.0,1.0,1.0)\n\n\n\n//Light Parameters\n#define LIGHT false\n#define LIGHT_COLOR vec3(1.0, 1.0, 1.0)\n#define LIGHT_INTENSITY 1.0\n\n\n//Animation parameters\n\n#define ANIMATION true\n#define ANIMATION_SPEED 0.5\n\n\n//OTHER\n\n#define LIGHT_Z_POS 0.5\n\n\n\n\n\n//-----------------------------------------------------------\n\nvec2 originalUV = vec2(0.0);\nbool passed = false;\nvec3 lightPosition = vec3(0.5,0.5,LIGHT_Z_POS);\n\n\n\n\n\nvec3 CalculateNormal(vec2 coord,float len) {\n    return normalize(\n           vec3(\n                coord.x*0.4,\n                coord.y*0.4,\n                1.0\n                )\n            );\n}\n\n\nvec3 MagicalColorRandomizer(vec2 uv) {\n    vec3 r = perlin(uv, 0.5, 2.0, 100.0, 3.0)*colIntensity.r; //arbitrary values in perlin function to generate \"galatical\" colors\n    vec3 g = perlin(uv+0.1, 0.5, 2.0, 100.0, 3.0)*colIntensity.g;\n    vec3 b = perlin(uv + 0.5, 0.5, 4.0, 100.0, 1.0)*colIntensity.b;\n    float fade = pow(length(perlin(uv-0.1, 0.6, 2.0, 10.,10.0)), 30.0)*4.0;\n    return vec3(length(r),length(g), length(b))/sqrt(3.0);\n\n}\n\n\n\n\nvec3 Lit(vec2 position, vec3 normal) {\n    vec3 dir = normalize(vec3(position.x,position.y, 0.0) - lightPosition);\n    return -LIGHT_INTENSITY*dot(dir, normal) * LIGHT_COLOR;\n    \n}\n\n\n\n\nvec3 ShapePattern(vec2 uv,vec2 center) {\n    uv -= center;\n    vec2 localCoord = (uv + vec2(SHAPE_HORIZONTAL_RADIUS*0.5, 0.0))\n                       /vec2(SHAPE_HORIZONTAL_RADIUS, SHAPE_VERTICAL_RADIUS);\n    float len = pow(uv.x/(SHAPE_HORIZONTAL_RADIUS), 2.0) +  pow(uv.y/(SHAPE_VERTICAL_RADIUS), 2.0);\n    float offsetu = 0.0;\n    if (ANIMATION) offsetu =  0.05*cos(iTime*ANIMATION_SPEED);\n    if (  len<= 1.3 + offsetu && uv.y < 0.0) {\n        //Point is inside the shape\n        passed = true;\n        localCoord = -localCoord;\n        \n        vec3 result =  SCALE_COLOR * vec3(smoothstep(0.0,0.15,localCoord.y/2.0));\n        if (RANDOMIZE_COLOR) {\n            result *= MagicalColorRandomizer(originalUV);\n        };\n        if ( NOISE ) result *= 2.0* noise(localCoord, 1.0);\n        if (BLACK_BORDER) {\n                result *= vec3(smoothstep(1.0, 0.0,len/3.0));\n        }\n        if (LIGHT) \n            result *= Lit(originalUV, CalculateNormal(localCoord,len));\n        return result ; \n         \n        \n    }\n    return vec3(0.0,0.0,.0);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n\n    vec2 uv = fragCoord/iResolution.xy;\n    PATTERN_FREQUENCY = 10.0 + 0.5*(sin((cos(iTime*ANIMATION_SPEED) - uv.x * uv.y)*2.0)+1.0);\n   \n\n    //PATTERN_FREQUENCY = 6.0 + sin(iTime);\n    originalUV = uv;\n    uv *= float(PATTERN_FREQUENCY);\n\n\tuv.x += 0.05*sin(uv.y*10.0+iTime)/10.0;\n    \n    vec2 mouse = iMouse.xy/iResolution.xy;\n    lightPosition.xy = mouse.xy;\n    \n    vec3 col = vec3(0.0);\n   \n   \n    float offset = 0.0;\n    for (int y = 0; y < int(float(PATTERN_FREQUENCY)/(SHAPE_VERTICAL_RADIUS)*2.0)+4; y++) {\n        for (int x = 0; x < int(float(PATTERN_FREQUENCY)/2.0/SHAPE_HORIZONTAL_RADIUS)+3; x++) {\n               if (passed) break;\n               vec2 center = vec2( (2.0*float(x) + offset) * float(SHAPE_HORIZONTAL_RADIUS),\n                                    float(PATTERN_FREQUENCY)+1.0- float(y)*SHAPE_VERTICAL_RADIUS*0.5);\n               col += ShapePattern(uv, center);\n       }\n       offset = 1.0 - offset;\n    }\n    \n    // Output to screen\n    fragColor = vec4(col + 0.15,1.0);\n}","name":"Buffer A","description":"","type":"buffer"}]}