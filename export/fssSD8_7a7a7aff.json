{"ver":"0.1","info":{"id":"fssSD8","date":"1618674446","viewed":95,"name":"Menger_sponge_ifs","username":"kinakomoti","description":"I made this for IFS practice.  \n","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["fractal"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float pi = acos(-1.0);\nconst float pi2 = pi * 2.;\nconst vec3 lightray = vec3(1.);\n\nvec3 alpha = vec3(3.4,5.0,8.0);\nmat2 rot(float a)\n{\n    float s = sin(a), c = cos(a);\n    return mat2(c, s, -s, c);\n}\nmat3 camera(vec3 ro, vec3 ta)\n{\n    vec3 up = vec3(0, 1, 0);\n    vec3 cw = normalize(ta - ro);\n    vec3 cu = normalize(cross(cw, up));\n    vec3 cv = normalize(cross(cu, cw));\n    return mat3(cu, cv, cw);\n}\nvec2 pmod(vec2 p, float r)\n{\n    float a = atan(p.x, p.y) + pi / r;\n    // \"+ pi / r\" means shortcut of \"+ ((pi2 / r) * 0.5)\".\n    // so we want to get half angles of circle splitted by r.\n\n    float n = pi2 / r;\n    a = floor(a / n) * n;\n    // floor(a / n) means calculating ID.\n\n    return p * rot(-a);\n}\nfloat dMenger(vec3 z0,vec3 offset, float scale){\n    vec4 z = vec4(z0,1.0);\n    z.xyz = mod(z.xyz,alpha.y) - alpha.y/2.0 ;\n    z.z = mod(z.z,4.0) - 0.2;\n    z.xy = pmod(z.xy,alpha.z);\n    for(int n = 0; n < 4; n ++){\n        z = abs(z);\n\n        if(z.x < z.y) z.xy = z.yx;\n        if(z.x < z.z) z.xz = z.zx;\n        if(z.y < z.z) z.yz = z.zy;\n\n        z *= scale;\n        z.xyz -= offset * (scale - 1.0);\n        if(z.z < -0.5 * offset.z * (scale - 1.0)) z.z += offset.z * (scale -1.0);\n    }\n    return (length(max(abs(z.xyz)-vec3(1.0,1.0,1.0),0.0)) - 0.05) / z.w;\n}\n\nvec3 normal(vec3 p,vec3 offset,float scale)\n{\n    vec2 e = vec2(0.0001, 0.0);\n    float d = dMenger(p,offset,scale);\n    vec3 n = d - vec3(\n        dMenger(p - e.xyy,offset,scale),\n        dMenger(p - e.yxy,offset,scale),\n        dMenger(p - e.yyx,offset,scale));\n    return normalize(n);\n}\n\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord)\n{\n    vec2 uv = (fragCoord.xy * 2.0 - iResolution.xy)/iResolution.y;\n\n\tvec3 col = vec3(0);\n\n    float dist = 5.0;\n    vec3 ro = vec3(2.5, 2.5, iTime);\n    vec3 ta = vec3(0.,0.,1.0) + ro;\n    \n    vec3 ray = camera(ro, ta) * normalize(vec3(uv, 1.8));\n    \n    vec3 p = ro;\n    float d = 0., t = 0.;\n    vec3 offset = vec3(4.,4.,1.5);\n    offset.x = offset.x + 1.13 * sin(iTime * 0.54) + 4.;\n    float scale = alpha.x;\n    float alpha = 0.;\n    for (int i = 0; i < 64; i++)\n    {\n        d = dMenger(p,offset,scale);\n        if (d < 0.01) break;\n        p += ray * d;\n        alpha += d;\n    }\n    \n    if (d < 0.01)\n    {\n        vec3 n =  4.0 * vec3(1.0) / alpha;\n        col = n;\n    }\n    else\n    {\n        col = vec3(0.);\n    }\n    \n    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}