{"ver":"0.1","info":{"id":"ss23Rc","date":"1618177784","viewed":42,"name":"Noise to Texture","username":"lindayukeyi","description":"Apply noise function to texture","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["noise"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sf3Rn","filepath":"/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","previewfilepath":"/media/ap/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const int RAY_STEPS = 256;\nconst float HALF_PI = 3.14159 * 0.5;\nconst vec3 LIGHT_POS = vec3(0, 7.45, -1);\nconst float FOCAL_LENGTH = 30.0;\nconst float FOCAL_RANGE = 30.0;\nconst float AO_DIST = 0.15;\nconst float FIVETAP_K = 2.0;\n\n\n//Rotates the camera around the Y-axis\nvec3 rotateY(vec3 p, float a) {\n    return vec3(cos(a) * p.x + sin(a) * p.z, p.y, -sin(a) * p.x + cos(a) * p.z);\n}\n\n//Primitive SDFs\n#define BACK_WALL_SDF plane(pos, vec4(0.0, 0.0, -1.0, 6.0))\n#define LEFT_WALL_SDF plane(pos, vec4(1.0, 0.0, 0.0, 5.0))\n#define RIGHT_WALL_SDF plane(pos, vec4(-1.0, 0.0, 0.0, 5.0))\n#define CEILING_SDF plane(pos, vec4(0.0, -1.0, 0.0, 7.5))\n#define FLOOR_SDF plane(pos, vec4(0.0, 1.0, 0.0, 2.0))\n#define TALL_BOX_SDF box(rotateY(pos + vec3(1.5, 0.0, -2.0), -65.0 * 3.14159 / 180.0), vec3(2.0, 5.0, 2))\n#define SPHERE_SDF sphere(pos, 2.0, vec3(2.2, 0.0, 2.0))\n\n//Primtives IDs\n#define BACK_WALL 0\n#define LEFT_WALL 1\n#define RIGHT_WALL 2\n#define CEILING 3\n#define FLOOR 4\n#define TALL_BOX 5\n#define SPHERE 6\n\nstruct Intersection\n{\n    float t;\n    vec3 color;\n    vec3 p;\n    int object;\n};\n\n\nfloat sphere(vec3 p, float r, vec3 c)\n{\n    return distance(p, c) - r;\n}\n\n// Box with side lengths b\nfloat box(vec3 p, vec3 b)\n{\n  return length(max(abs(p) - b, 0.0));\n}\n\nfloat plane( vec3 p, vec4 n )\n{\n  // n must be normalized\n  return dot(p,n.xyz) + n.w;\n}\n\nvoid raycast(vec2 uv, out vec3 dir, out vec3 eye, out vec3 ref) {\n    //eye = rotateY(vec3(0.0, 0.0, 15.0), sin(iTime * 0.1) * 3.14159 * 0.5);\n    eye = vec3(0, 4.5, -35);\n    ref = vec3(0, 2.8, 0);\n    \n    \n    float len = tan(19.5 / 360.0 * 3.1415926) * length(eye - ref);\n    vec3 H = normalize(cross(vec3(0.0, 1.0, 0.0), ref - eye));\n    vec3 V = normalize(cross(H, eye - ref));\n    V *= len;\n    H *= len * iResolution.x / iResolution.y;\n    vec3 p = ref + uv.x * H + uv.y * V;\n    dir = normalize(p - eye);\n}\n\nvoid sceneMap3D(vec3 pos, out float t, out int obj) {\n    t = BACK_WALL_SDF;\n    obj = BACK_WALL;\n    \n    float t2;\n    if((t2 = LEFT_WALL_SDF) < t) {\n        t = t2;\n        obj = LEFT_WALL;\n    }\n    if((t2 = RIGHT_WALL_SDF) < t) {\n        t = t2;\n        obj = RIGHT_WALL;\n    }\n    if((t2 = CEILING_SDF) < t) {\n        t = t2;\n        obj = CEILING;\n    }\n    if((t2 = FLOOR_SDF) < t) {\n        t = t2;\n        obj = FLOOR;\n    } \n    if ((t2 = TALL_BOX_SDF) < t) {\n    \tt = t2;\n        obj = TALL_BOX;\n    }\n    if ((t2 = SPHERE_SDF) < t) {\n    \tt = t2;\n        obj = SPHERE;\n    }\n}\n\n\nfloat sceneMap3D(vec3 pos) {\n    float t = BACK_WALL_SDF;\n    \n    float t2;\n    if((t2 = LEFT_WALL_SDF) < t) {\n        t = t2;\n    }\n    if((t2 = RIGHT_WALL_SDF) < t) {\n        t = t2;\n    }\n    if((t2 = CEILING_SDF) < t) {\n        t = t2;\n    }\n    if((t2 = FLOOR_SDF) < t) {\n        t = t2;\n    }  \n    if ((t2 = TALL_BOX_SDF) < t) {\n    \tt = t2;\n    }\n    if ((t2 = SPHERE_SDF) < t) {\n    \tt = t2;\n    }\n    \n    return t;\n}\n\nvoid march(vec3 origin, vec3 dir, out float t, out int hitObj)\n{\n    t = 0.001;\n    for(int i = 0; i < RAY_STEPS; ++i)\n    {\n        vec3 pos = origin + t * dir;\n    \tfloat m;\n        sceneMap3D(pos, m, hitObj);\n        if(m < 0.01)\n        {\n            return;\n        }\n        t += m;\n    }\n    t = -1.0;\n    hitObj = -1;\n}\n\nvec2 random2( vec2 p ) {\n    return fract(sin(vec2(dot(p, vec2(127.1, 311.7)),\n                 dot(p, vec2(269.5,183.3))))\n                 * 43758.5453);\n}\n\n\nfloat WorleyNoise(vec2 uv) {\n    uv *= 10.0; // Now the space is 10x10 instead of 1x1. Change this to any number you want.\n    vec2 uvInt = floor(uv);\n    vec2 uvFract = fract(uv);\n    float minDist = 1.0; // Minimum distance initialized to max.\n    for(int y = -1; y <= 1; ++y) {\n        for(int x = -1; x <= 1; ++x) {\n            vec2 neighbor = vec2(float(x), float(y)); // Direction in which neighbor cell lies\n            vec2 point = random2(uvInt + neighbor); // Get the Voronoi centerpoint for the neighboring cell\n            vec2 diff = neighbor + point - uvFract; // Distance between fragment coord and neighborâ€™s Voronoi point\n            float dist = length(diff);\n            minDist = min(minDist, dist);\n        }\n    }\n    return minDist;\n}\n\nvec3 computeNormal(vec3 pos)\n{\n    vec3 epsilon = vec3(0.0, 0.001, 0.0);\n    return normalize( vec3( sceneMap3D(pos + epsilon.yxx) - sceneMap3D(pos - epsilon.yxx),\n                            sceneMap3D(pos + epsilon.xyx) - sceneMap3D(pos - epsilon.xyx),\n                            sceneMap3D(pos + epsilon.xxy) - sceneMap3D(pos - epsilon.xxy)));\n}\n\nfloat interpNoise2D(float x, float y) {\n    int intX = int(floor(x));\n    float fractX = fract(x);\n    int intY = int(floor(y));\n    float fractY = fract(y);\n\n    float v1 = random2(vec2(intX, intY)).x;\n    float v2 = random2(vec2(intX + 1, intY)).x;\n    float v3 = random2(vec2(intX, intY + 1)).x;\n    float v4 = random2(vec2(intX + 1, intY + 1)).x;\n\n    float i1 = mix(v1, v2, fractX);\n    float i2 = mix(v3, v4, fractX);\n    return mix(i1, i2, fractY);\n}\n\nfloat fbm(float x, float y) {\n    float total = 0.0;\n    float persistence = 0.5f;\n    int octaves = 4;\n\n    for(int i = 1; i <= octaves; i++) {\n        float freq = pow(2.0, float(i));\n        float amp = pow(persistence, float(i));\n\n        total += interpNoise2D(x * freq,\n                               y * freq) * amp;\n    }\n    return total;\n}\n\nfloat surflet(vec2 p, vec2 gridPoint) {\n    // Compute the distance between p and the grid point along each axis, and warp it with a\n    // quintic function so we can smooth our cells\n    float t2 = length(p - gridPoint);\n    vec2 t = vec2(1.0) - 6.0 * pow(t2, 5.0) + 15.0 * pow(t2, 4.0) - 10.0 * pow(t2, 3.0);\n    // Get the random vector for the grid point (assume we wrote a function random2\n    // that returns a vec2 in the range [0, 1])\n    vec2 gradient = random2(gridPoint) * 2.0 - vec2(1.0,1.0);\n    // Get the vector from the grid point to P\n    vec2 diff = p - gridPoint;\n    // Get the value of our height field by dotting grid->P with our gradient\n    float height = dot(diff, gradient);\n    // Scale our height field (i.e. reduce it) by our polynomial falloff function\n    return height * t.x * t.y;\n}\n\nfloat perlinNoise(vec2 uv) {\n\tfloat surfletSum = 0.0;\n\t// Iterate over the four integer corners surrounding uv\n\tfor(int dx = 0; dx <= 1; ++dx) {\n\t\tfor(int dy = 0; dy <= 1; ++dy) {\n\t\t\tsurfletSum += surflet(uv, vec2(floor(uv.x), floor(uv.y)) + vec2(dx, dy));\n\t\t}\n\t}\n\treturn surfletSum;\n}\n\n\nvec3 palette( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\n// Reference: https://www.shadertoy.com/view/MtcGRl \nvec2 GetGradient(vec2 intPos, float t) {\n    \n    // Uncomment for calculated rand\n    //float rand = fract(sin(dot(intPos, vec2(12.9898, 78.233))) * 43758.5453);;\n    \n    // Texture-based rand (a bit faster on my GPU)\n    float rand = texture(iChannel0, intPos / 64.0).r;\n    \n    // Rotate gradient: random starting rotation, random rotation rate\n    float angle = 6.283185 * rand + 4.0 * t * rand;\n    return vec2(cos(angle), sin(angle));\n}\n\n\nfloat Pseudo3dNoise(vec3 pos) {\n    vec2 i = floor(pos.xy);\n    vec2 f = pos.xy - i;\n    vec2 blend = f * f * (3.0 - 2.0 * f);\n    float noiseVal = \n        mix(\n            mix(\n                dot(GetGradient(i + vec2(0, 0), pos.z), f - vec2(0, 0)),\n                dot(GetGradient(i + vec2(1, 0), pos.z), f - vec2(1, 0)),\n                blend.x),\n            mix(\n                dot(GetGradient(i + vec2(0, 1), pos.z), f - vec2(0, 1)),\n                dot(GetGradient(i + vec2(1, 1), pos.z), f - vec2(1, 1)),\n                blend.x),\n        blend.y\n    );\n    return noiseVal / 0.7; // normalize to about [-1..1]\n}\n\n// This is where you give your objects in the scene materials\nvec3 computeMaterial(int hitObj, vec3 p, vec3 n, vec3 lightVec, vec2 uv) {\n    float lambert = dot(n, lightVec) + 0.2;\n    \n    switch(hitObj) {\n        case BACK_WALL:\n        case CEILING:\n        case FLOOR:\n        return vec3(0.85, 0.81, 0.78) * lambert;\n        case TALL_BOX:\n        float noise_box = Pseudo3dNoise(vec3(uv * 10.0, iTime));\n        return palette(noise_box, \n                        vec3(0.8, 0.5, 0.4), \n                        vec3(0.2, 0.4, 0.2), \n                        vec3(2.0, 1.0, 1.0), \n                        vec3(0.00, 0.25, 0.25)) * lambert;\n        break;\n        case SPHERE:\n        float noise_sphere = fbm(uv.x * 5.0, uv.y * 5.0);\n        return palette(noise_sphere, \n                        vec3(0.8, 0.5, 0.4), \n                        vec3(0.2, 0.4, 0.2), \n                        vec3(2.0, 1.0, 1.0), \n                        vec3(0.00, 0.25, 0.25)) * lambert;\n        break;\n        case RIGHT_WALL:\n        float noise = WorleyNoise(uv);\n        return palette(noise, \n                        vec3(0.8, 0.5, 0.4), \n                        vec3(0.2, 0.4, 0.2), \n                        vec3(2.0, 1.0, 1.0), \n                        vec3(0.00, 0.25, 0.25)) * lambert;\n        break;\n        case LEFT_WALL:\n        return vec3(0.065, 0.63, 0.05) * lambert;\n        break;\n        case -1:\n        return vec3(0., 0., 0.);\n        break;\n    }\n    return vec3(0., 0., 0.);\n}\n\nfloat fiveTapAO(vec3 p, vec3 n, float k) {\n    float aoSum = 0.0;\n    for(float i = 0.0; i < 5.0; ++i) {\n        float coeff = 1.0 / pow(2.0, i);\n        aoSum += coeff * (i * AO_DIST - sceneMap3D(p + n * i * AO_DIST));\n    }\n    return 1.0 - k * aoSum;\n}\n\nIntersection sdf3D(vec3 dir, vec3 eye, vec2 uv)\n{\n    float t;\n    int hitObj;\n    march(eye, dir, t, hitObj);\n\n    vec3 isect = eye + t * dir;\n    vec3 nor = computeNormal(isect);\n    vec3 lightDir = normalize(LIGHT_POS - isect);\n\n\n    vec3 sdfColor = computeMaterial(hitObj, isect, nor, normalize(LIGHT_POS - isect), uv);\n    float ao = fiveTapAO(isect, nor, FIVETAP_K);\n    vec3 finalColor = sdfColor * ao;\n        \n    return Intersection(t, finalColor, isect, hitObj);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    // [-1, 1]\n    vec2 uv2 = 2.0 * uv - vec2(1.0);\n        vec3 dir, eye, ref;\n\n    raycast(uv2, dir, eye, ref);\n\n  \tIntersection isect = sdf3D(dir, eye, uv2  + iTime * 0.05);\n    float distAlongCamZ = abs(dot(normalize(ref - eye), (isect.p - eye)));\n    float dofZ = min(1.0, abs(distAlongCamZ - FOCAL_LENGTH * abs(cos(iTime))) / FOCAL_RANGE);\n    dofZ = pow(dofZ, 0.5);   \n    fragColor = vec4(isect.color, dofZ);\n}\n\n","name":"Image","description":"","type":"image"}]}