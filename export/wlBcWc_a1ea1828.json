{"ver":"0.1","info":{"id":"wlBcWc","date":"1595528867","viewed":2010,"name":"Raytraced Swept BSpline Surfaces","username":"fizzer","description":"Raytracing a surface-of-revolution defined by a 1D quadratic uniform B-spline. This involves the solving of a quartic equation. I used Shane's generalised quartic solver and added some tricks on top to improve the precision and numerical stability.","likes":109,"published":1,"flags":0,"usePreview":1,"tags":["raytrace","spline","quadratic","quartic"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","previewfilepath":"/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Raytracing a surface-of-revolution defined by a quadratic B-spline, by splitting the spline\n// into sections which can each be expressed as quadratic polynomial.\n//\n// This is much faster than raymarching!\n//\n// See the comments throughout the code for details.\n\n\n// Supersampled anti-aliasing level. Sample count = AA x AA.\n#define AA 2\n\n#define MAX_RAY_PATH_DEPTH 16\n\n\n// Evaluate quadratic polynomial with given coefficients.\nfloat applyCoeffs(vec3 coeffs, float x)\n{\n    return (x * coeffs.x + coeffs.y) * x + coeffs.z;\n}\n\n// Polynomial coefficient factors for a section of a 1D quadratic uniform B-spline.\nvec3 coeffsForCP(float i)\n{\n    if(i < 1.)\n        return vec3(.5, 0, 0);\n    else if(i < 2.)\n        return vec3(-1., 1., .5);\n    return vec3(.5, -1., .5);\n}\n\n// Functions solve_quadric, solve_cubic, solve_quartic, and absmax are from Wyatt's\n// quartic solver collection: https://www.shadertoy.com/view/XddfW7\n\nint solve_quadric(vec2 coeffs, inout vec2 roots){\n    float p = coeffs.y / 2.;\n    float D = p*p - coeffs.x;\n    if (D <= 0.) return 0;\n    else {\n        roots = vec2(-1, 1)*sqrt(D) - p;\n        return 2;\n    }\n}\nint solve_cubic(vec3 coeffs, inout vec3 r){\n    float a = coeffs[2];\n    float b = coeffs[1];\n    float c = coeffs[0];\n    float p = b - a*a/3.;\n    float q = a * (2.*a*a - 9.*b)/27. + c;\n    float p3 = p*p*p;\n    float d = q*q + 4.*p3/27.;\n    float offset = -a/3.;\n    if(d >= 0.0) { \n        vec2 uv = (vec2(1, -1)*sqrt(d) - q)/2.;\n        uv = uv = sign(uv)*pow(abs(uv), vec2(1./3.));\n        r[0] = offset + uv.x + uv.y;\t\n        float f = ((r[0] + a)*r[0] + b)*r[0] + c;\n        float f1 = (3.*r[0] + 2. * a)*r[0] + b;\n        r[0] -= f/f1;\n        return 1;\n    }\n    float u = sqrt(-p/3.);\n    float v = acos(-sqrt(-27./p3)*q/2.)/3.;\n    float m = cos(v), n = sin(v)*1.732050808;\n    float f,f1;\n    r[0] = offset + u * (m + m);\n    f = ((r[0] + a)*r[0] + b)*r[0] + c;\n    f1 = (3.*r[0] + 2. * a)*r[0] + b;\n    r[0] -= f / f1;\n    r[1] = offset - u * (n + m);\n    f = ((r[1] + a)*r[1] + b) * r[1] + c;\n    f1=(3.*r[1] + 2. * a)*r[1] + b;\n    r[1] -= f / f1;\n    r[2] = offset + u * (n - m);\n    f = ((r[2] + a)*r[2] + b)*r[2] + c;\n    f1 = (3.*r[2] + 2. * a)*r[2] + b;\n    r[2] -= f / f1;\n    return 3;\n}\nbvec4 solve_quartic(vec4 coeffs, inout vec4 s){\n    bvec4 broots;\n    float a = coeffs[0];\n    float b = coeffs[1];\n    float c = coeffs[2];\n    float d = coeffs[3];\n    float sq_a = a * a;\n    float p = - 3./8. * sq_a + b;\n    float q = 1./8. * sq_a * a - 1./2. * a * b + c;\n    float r = - 3./256.*sq_a*sq_a + 1./16.*sq_a*b - 1./4.*a*c + d;\n    int num;\n    vec3 cubic_coeffs;\n    cubic_coeffs[0] = 1.0/2. * r * p - 1.0/8. * q * q;\n    cubic_coeffs[1] = - r;\n    cubic_coeffs[2] = - 1.0/2. * p;\n    solve_cubic(cubic_coeffs, s.xyz);\n    float z = s[0];\n    float u = z * z - r;\n    float v = 2. * z - p;\n    if(u > 0.) u = sqrt(abs(u));\n    else return bvec4(false);\n    if(v > 0.) v = sqrt(abs(v));\n    else return bvec4(false);\n    vec2 quad_coeffs;\n    quad_coeffs[0] = z - u;\n    quad_coeffs[1] = q < 0. ? -v : v;\n    num = solve_quadric(quad_coeffs, s.xy);\n    if (num == 0) broots.xy = bvec2(false);\n    if (num == 2) broots.xy = bvec2(true);\n    quad_coeffs[0] = z + u;\n    quad_coeffs[1] = q < 0. ? v : -v;\n    vec2 tmp = vec2(1e8);\n    int old_num = num;\n    num = solve_quadric(quad_coeffs, s.zw);\n    if (num == 0) broots.zw = bvec2(false);\n    if (num == 2) broots.zw = bvec2(true);\n    s -= a/4.;\n    \n#if 1\n    // Newton-Raphson iteration to improve precision\n    s -= ((((s + a) * s + b) * s + c) * s + d) / \n        (((4. * s + 3. * a) * s + 2. * b) * s + c);\n#endif\n    \n    return broots;\n}\n\nfloat absmax(float a, float b) {\n\tif (b>1e-3) return max(a,b);\n    return a;\n}\n\n// Ray-cylinder intersection.\nvec2 intersectCylinder(vec2 ro, vec2 rd, float r)\n{\n    float a = dot(rd, rd);\n    float b = 2.0 * dot(rd, ro);\n    float c = dot(ro, ro) - r * r;\n    float desc = b * b - 4.0 * a * c;\n    if (desc < 0.0)\n        return vec2(1.0, 0.0);\n\n    return vec2((-b - sqrt(desc)) / (2.0 * a), (-b + sqrt(desc)) / (2.0 * a));\n}\n\n// Ray-box intersection.\nvec2 box(vec3 ro,vec3 rd,vec3 p0,vec3 p1)\n{\n    vec3 t0 = (mix(p1, p0, step(0., rd * sign(p1 - p0))) - ro) / rd;\n    vec3 t1 = (mix(p0, p1, step(0., rd * sign(p1 - p0))) - ro) / rd;\n    return vec2(max(t0.x, max(t0.y, t0.z)),min(t1.x, min(t1.y, t1.z)));\n}\n\n// Performs ray-versus-swept-curve intersection test, and computes surface normal\n// at the intersection if it exists.\n// The surface is a radially-swept quadratic curve and the intersection test requires\n// solving a quartic (degree 4) equation.\nvec4 intersectSection(vec3 ro, vec3 rd, vec3 quadCoeffs, vec2 hs)\n{\n    ro.y -= hs.x;\n    hs.y -= hs.x;\n    hs.x = -1e-3;\n    hs.y += 1e-3;\n    \n    // Differentiate the profile curve to find the inflection point, in order to calculate\n    // a radius for the bounding cylinder of this section.\n    vec2 differentialLine = vec2(2. * quadCoeffs.x, quadCoeffs.y);\n    float inflectionPoint = (0. - differentialLine.y) / differentialLine.x;\n    \n    float r0 = applyCoeffs(quadCoeffs, 0.);\n    float r1 = applyCoeffs(quadCoeffs, 1.);\n    \n    float cylinderRadius = max(r0, r1);\n    \n    if(inflectionPoint >= 0. && inflectionPoint < 1.)\n    \tcylinderRadius = max(cylinderRadius, applyCoeffs(quadCoeffs, inflectionPoint));\n    \n    // Test the ray against a capped bounding cylinder for early rejection.\n    \n    vec2 is = intersectCylinder(ro.xz, rd.xz, cylinderRadius + 1e-2);\n\n    vec2 planeIntersections = (hs.xy - ro.y) / rd.y;\n    \n    if(rd.y > 0.)\n        is.x = max(is.x, planeIntersections.x);\n    else\n        is.y = min(is.y, planeIntersections.x);\n    \n    if(rd.y < 0.)\n        is.x = max(is.x, planeIntersections.y);\n    else\n        is.y = min(is.y, planeIntersections.y);\n        \n    if(is.y < 1e-3 || is.x > is.y)\n        return vec4(1e4, 0, 0, 0);\n    \n    is.x = max(0., is.x);\n    \n    // Offset the ray start position along the ray to the bounding cylinder intersection, to\n    // gain some precision in the quartic solver.\n    ro += rd * is.x;\n\n    // Note that Z and Y are swapped here. This is because the up vector of the scene is Y, but\n    // the axis of revolution for my swept curve is Z.\n    float ox = ro.x, oy = ro.z, oz = ro.y;\n    float dx = rd.x, dy = rd.z, dz = rd.y;\n    \n    // Quadratic profile curve coefficients.\n    float a = quadCoeffs.x, b = quadCoeffs.y, c = quadCoeffs.z;\n    \n    // The equation to solve is d² = (az² + bz + c)²\n    // Where d is length(vec2(ox, oy) + t * vec2(dx, dy)) and z is oz + t * dz.\n    // This yields a quartic polynomial equation in t.\n    \n    vec4 coeffs;\n    \n    float c4 = -(a * a * dz * dz * dz * dz);\n    \n    coeffs.x = -2. * dz *(2. * a * a * oz *  dz * dz + a * b * dz * dz);\n\n    coeffs.y = dx * dx + dy * dy - \n        dz * ((oz * 6. * a * a * dz + 6. * a * b * dz) * oz + 2. * a * c * dz + b * dz * b);\n    \n    coeffs.z = 2. * ((ox * dx + oy * dy) - \n        dz * (((oz * 2. * a * a + 3. * a * b) * oz + 2. * a * c + b * b) * oz + b * c));\n\n    coeffs.w = ox * ox + oy * oy -\n\t\t((((oz * a * a + 2. * b * a) * oz + 2. * a * c + b * b) * oz + 2. * b * c) * oz + c * c);\n\n    // Since solve_quartic works on a so-called 'depressed quartic', the coefficients would normally\n    // be divided by c4 (the 4th-order coefficient). However, this coefficient very quickly\n    // approaches zero as dz approaches zero, which eventually results in catastrophic cancellation\n    // during the root-finding process.\n    // To overcome this, I'm using a trick which I learned from IQ: The order of the coefficients\n    // is reversed so that the division is by the constant term instead. The solution to this\n    // equation is 1 / t, hence the calculation of t as 1 / i.\n    \n    vec4 roots;\n    bvec4 br = solve_quartic(vec4(coeffs.z, coeffs.y, coeffs.x, c4) / coeffs.w, roots);\n    float i = -1.;\n    \n    if (br.x)\n        i = absmax(i, roots.x);\n    if (br.y)\n        i = absmax(i, roots.y);\n    if (br.z)\n        i = absmax(i, roots.z);\n    if (br.w)\n       \ti = absmax(i, roots.w);\n    \n    float t = 1. / i;\n    \n    if(t < 1e-3 || t > (is.y - is.x))\n        return vec4(1e4, 0, 0, 0);\n    \n    vec3 p = ro + rd * t;\n    vec3 tangent_u = vec3(p.z, 0, -p.x);\n    vec3 tangent_v = vec3(normalize(p.xz) * (differentialLine.y + differentialLine.x * p.y), 1.).xzy;\n    vec3 normal = cross(tangent_u, tangent_v);\n\n    return vec4(is.x + t, normal);\n}\n\n// Perform intersection tests against each section of a surface defined by a radially-swept\n// 1D quadratic uniform B-spline. A section is a range of the parameter domain between two\n// control points, over which the set of contributing points is constant. \nvec4 traceSurface(float[10] controlPoints, vec3 ro, vec3 rd, int N)\n{\n    float mt = 1e3;\n    vec3 normal;\n    \n    for(int i = 0; i < N; ++i)\n    {\n        // Sections are non-overlapping and ordered along a line (the axis of revolution), so\n        // it's easy to order them along a ray.\n        int j = (rd.y > 0. ? i : N - 1 - i);\n        \n        // The polynomial coefficients can be expressed as a linear combination of the 3 contributing\n        // control points.\n        float h = float(j);\n        vec3 coeffs = \tcoeffsForCP(2.) * controlPoints[j] +\n            \t\t\tcoeffsForCP(1.) * controlPoints[j + 1] +\n            \t\t\tcoeffsForCP(0.) * controlPoints[j + 2];\n        \n        vec4 res = intersectSection(ro, rd, coeffs, vec2(h, h + 1.));\n\n        if(res.x > 1e-3 && res.x < mt)\n        {\n            normal = res.yzw;\n            mt = res.x;\n            // Breaking on the first intersection found is safe due to the axial ordering.\n            break;\n        }\n    }\n    \n    return vec4(mt, normal);\n}\n\nvec3 sampleEnv(vec3 ro, vec3 rd)\n{\n    if(rd.y < 0.)\n    {\n\t\t// Include the (parallax-correct) floor in the environment, because it's cheap to do so.\n    \tfloat floort = -ro.y / rd.y;\n        vec2 uv = ro.xz + rd.xz * floort;\n        if(floort > 0. && floort < 1e4 && max(abs(uv.x), abs(uv.y)) < 15.)\n        {\n            return texture(iChannel1, uv / 20.).rgb / 2.5;\n        }\n    }\n    // Sample the environment map.\n    return texture(iChannel0, rd.zyx, 2.).rgb;\n}\n\nvec4 traceScene(vec3 ro, vec3 rd, out int objid)\n{\n    float mt = 1e3;\n    vec3 normal;\n    \n    objid = 0;\n    \n    // Floor object\n    if(rd.y < 0.)\n    {\n    \tfloat floort = (0. - ro.y) / rd.y;\n        vec2 uv = ro.xz + rd.xz * floort;\n        if(floort > 0. && floort < mt && abs(uv.x) < 15. && abs(uv.y) < 15.)\n        {\n            mt = floort;\n            normal = vec3(0, 1, 0);\n            objid = 1;\n        }\n    }\n    \n    vec4 res;\n    float sc = .52;\n    \n    vec2 wineglass_box_is = box(ro, rd, vec3(-1.6, 0., -1.6), vec3(1.6, 10, 1.6));\n    \n    if(wineglass_box_is.x < wineglass_box_is.y)\n    {\n        // Wineglass (outer)\n        res = traceSurface(float[10](2.5, .1, .1, .1, .1, 1.1, 1.6, 1.5, 1.2, 1.), ro, rd, 8);\n        if(res.x > 1e-3 && res.x < mt)\n        {\n            mt = res.x;\n            normal = res.yzw;\n            objid = 2;\n        }\n\n\n        // Wineglass (inner)\n        res = traceSurface(float[10](0., 0., 0., 0., 0., 1., 1.5, 1.4, 1.1, .9), ro, rd, 8);\n        if(res.x > 1e-3 && res.x < mt)\n        {\n            mt = res.x;\n            normal = -res.yzw;\n            objid = 3;\n        }\n\n\n        // Glass wine surface\n        {\n            float t = (6. - ro.y) / rd.y;\n            if(t > 1e-3 && t < mt)\n            {\n                vec3 p = ro + rd * t;\n                if(length(p.xz) < 1.45)\n                {\n                    mt = t;\n                    normal = vec3(0, -1, 0);\n                    objid = 3;\n                }\n            }\n        }\n    }\n    \n    vec3 bottle_pos = vec3(6,0,-2);\n    vec2 winebottle_box_is = box((ro - bottle_pos), rd, vec3(-2, 0., -2), vec3(2, 15, 2));\n\n    if(winebottle_box_is.x < winebottle_box_is.y)\n    {\n        // Wine bottle (outer)\n\n        res = traceSurface(float[10](.9, 1., 1., 1., 1., 1., .6, .3, .3, .3), (ro - bottle_pos)  * sc, rd * sc, 8);\n        if(res.x > 1e-3 && res.x < mt)\n        {\n            mt = res.x;\n            normal = res.yzw;\n            objid = 4;\n        }\n\n        // Wine bottle (inner)\n        res = traceSurface(float[10](.9 - .1, 1. - .1, 1. - .1, 1. - .1, 1. - .1, 1. - .1,\n                                     .6 - .1, .3 - .1, .3 - .1, .3 - .1), (ro - bottle_pos)  * sc, rd * sc, 8);\n        if(res.x > 1e-3 && res.x < mt)\n        {\n            mt = res.x;\n            normal = -res.yzw;\n            objid = 5;\n        }\n    }\n    \n    vec3 vase_pos = vec3(5, 0, 7);\n    vec2 vase_box_is = box((ro - vase_pos), rd, vec3(-3.5, 0., -3.5), vec3(3.5, 12, 3.5));\n\n    if(vase_box_is.x < vase_box_is.y)\n    {\n        float sc = .45;\n\n        // Water vase (outer)\n        res = traceSurface(float[10](.1, 1.5, 1.5, 1.5, .5, .5, 1.6, 0., 0., 0.),\n                           (ro - vase_pos)  * sc, rd * sc, 5);\n        if(res.x > 1e-3 && res.x < mt)\n        {\n            mt = res.x;\n            normal = res.yzw;\n            objid = 6;\n        }\n\n\n        // Water vase (inner)\n        res = traceSurface(float[10](.1 - .1, 1.5 - .1, 1.5 - .1, 1.5 - .1, .5 - .1, .5 - .1, 1.6 - .1, 0., 0., 0.),\n                           (ro - vase_pos)  * sc, rd * sc, 5);\n        if(res.x > 1e-3 && res.x < mt)\n        {\n            mt = res.x;\n            normal = -res.yzw;\n            objid = 7;\n        }\n\n        // Vase water surface\n        {\n            float t = (2. - ro.y) / rd.y;\n            if(t > 1e-3 && t < mt)\n            {\n                vec3 p = ro + rd * t;\n                if(length(p.xz - vase_pos.xz) < 1.4 / sc)\n                {\n                    mt = t;\n                    normal = vec3(0, -1, 0);\n                    objid = 7;\n                }\n            }\n        }\n    }\n    \n\n    return vec4(mt, normal);\n}\n    \nmat3 rotX(float a)\n{\n    return mat3(1., 0., 0., 0., cos(a), sin(a), 0., -sin(a), cos(a));\n}\n\nmat3 rotY(float a)\n{\n    return mat3(cos(a), 0., sin(a), 0., 1., 0., -sin(a), 0., cos(a));\n}\n\nmat3 rotZ(float a)\n{\n    return mat3(cos(a), sin(a), 0., -sin(a), cos(a), 0., 0., 0., 1.);\n}\n\nvoid render(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy * 2. - 1.;\n\tuv.x *= iResolution.x / iResolution.y;\n    \n    // Camera position and target.\n    vec3 campos = vec3(0, -.5, 22);\n    campos.y += 3.2;\n    vec3 camtarget = vec3(0, -.5, 0);\n\tvec3 ro = campos, rd = normalize(vec3(uv, 3.5));\n    \n    // Camera lookat.\n    vec3 w = normalize(camtarget - campos);\n    vec3 u = normalize(cross(vec3(0, 1, 0), w));\n    vec3 v = cross(w, u);\n    rd = mat3(u, v, w) * rd;\n\n\t// Scene rotation and positioning\n    mat3 m = rotY(.9 + cos(iTime / 9.) * 1.5);\n    ro = m * ro + vec3(2, 5.5, 1.);\n    rd = m * rd;\n    \n    fragColor.rgb = vec3(0);\n    \n    vec3 fac = vec3(1);\n    float ray_ior = 1.;\n    float ray_spread = 0.;\n    \n    for(int i = 0; i < MAX_RAY_PATH_DEPTH; ++i)\n    {\n        rd = normalize(rd);\n        int objid;\n        vec4 res = traceScene(ro, rd, objid);\n\n        if(res.x > 1e2)\n        {\n            // Ray escaped the scene. Sample the environment map.\n            fragColor.rgb += texture(iChannel0, rd.zyx, 1.5 + ray_spread).rgb * fac;\n            break;\n        }\n\n        vec3 normal = normalize(res.yzw);\n        vec3 forwardNormal = faceforward(normal, rd, normal);\n        vec3 rp = ro + rd * res.x;\n        \n        if(rp.y < 1e-2)\n        {\n            // Floor.\n            float fr = mix(.2, .5, clamp(pow(1. - dot(rd, -forwardNormal), 2.), 0., 1.)) / 2.;\n            fr *= smoothstep(.1, .7, texture(iChannel1, rp.xz / 20.).r);\n            fragColor.rgb += texture(iChannel1, rp.xz / 20.).rgb * (1. - fr) * fac * .3;\n            fac *= fr;\n            ro += rd * (res.x + .001);\n            rd = reflect(rd, normal);\n            ray_spread += 1.;\n        }\n        else\n        {\n            // Fresnel term.\n            float fr = mix(.022, .9, clamp(pow(1. - dot(rd, -forwardNormal), 3.), 0., 1.));\n\n            // Use a different fresnel curve for liquids.\n            if((objid == 7 && rp.y < 2.01) || (objid == 3 && rp.y < 6.01))\n            \tfr = mix(.05, .2, clamp(pow(1. - dot(rd, -forwardNormal), 3.), 0., 1.));\n\n            float medium_ior;\n            bool entering = dot(rd, normal) > 0.;\n            \n            // Apply object-dependent shading.\n            \n            if(objid == 5)\n                fac *= vec3(.5,1.,.5) / 2.;\n            \n            if(objid == 5 && rp.y < 10.)\n            \tfac *= .1;\n               \n            if((objid == 3 && rp.y < 6.01) || (objid == 7 && rp.y < 2.01))\n            {\n                if(entering)\n                {\n                    medium_ior = 1.36;\n                }\n                else\n                {\n                    if(objid == 7)\n                        fac *= exp(-res.x * vec3(4,4,1) / 100.);\n                    else\n                \t\tfac *= exp(-res.x * vec3(1,4,4) / 1.);\n                    medium_ior = (abs(res.z) == 1.) ? 1. : 1.5;\n                }\n            }\n            else\n            {\n                medium_ior = !entering ? 1.5 : 1.0;\n            }\n\n            // Offset ray away from surface.\n            ro += rd * (res.x + .02)*1.0;\n            ro -= forwardNormal * 0.02 * (abs(dot(rd, normal)));\n            \n            // Take a non-shadowed environment sample.\n            fragColor.rgb += sampleEnv(ro, reflect(rd, normal)) * fr * fac;\n            \n            fac *= 1. - fr;\n            \n            vec3 ord = rd;\n            \n            // Refract the ray.\n            rd = refract(normalize(rd), forwardNormal, ray_ior / medium_ior);\n            \n            // Handle total internal reflection.\n            if(rd == vec3(0))\n               \trd = reflect(ord, normal);\n            \n            ray_ior = medium_ior;\n            \n            // Terminate paths which make too small a contribution.\n            if(max(fac.r, max(fac.g, fac.b)) < .002)\n                break;\n        }\n        \n        // Always lose a small amount of energy on every bounce.\n        fac *= .99;\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy * 2. - 1.;\n\tuv.x *= iResolution.x / iResolution.y;\n    fragColor.rgb = vec3(0);\n    \n\tfor(int y = 0; y < AA; ++y)\n        for(int x = 0; x < AA; ++x)\n        {\n            vec4 col = vec4(0);\n            render(col, fragCoord + vec2(x, y) / float(AA));\n            fragColor.rgb += max(col.rgb, 0.);\n        }\n    \n    fragColor.rgb *= 1.2 / float(AA * AA);\n    \n    // Vignet,\n    fragColor.rgb *= vec3(1. - (pow(abs(uv.x), 4.) + pow(abs(uv.y * 1.5), 4.)) * .04);\n    \n    // Tonemapping.\n    fragColor.rgb /= (fragColor.rgb + 1.) * .5;\n    \n    // Gamma and dither.\n    fragColor.rgb = pow(fragColor.rgb, vec3(1. / 2.2)) +\n        \t\t\t\ttexelFetch(iChannel2, ivec2(fragCoord) & 1023, 0).rgb / 200.;\n}\n","name":"Image","description":"","type":"image"}]}