{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"// how should the black points be described? they are points where the iterate stays\n// small in magnitude. there's a special name for this right?\n// i guess the symmetries are due to multiplication of complex numbers being\n// equivalent to rotation in the complex plane.\n\n#define MAX_ITERS 150.0\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tvec2 c = (2.0 * uv - 1.0)\n\t\t\t * vec2(iResolution.x / iResolution.y, 1.0);\n\n\t// view\n\tc.x -=.3;\n\tc *= 1.5;\n\n\tvec2 z = vec2(iMouse.xy/iResolution.xy);  \n\n\t// it really doesnt need to be this complicated, it evolved into this while i was trying to keep the animation at a reasonable speed\n\tfloat iters = 20.*(\n\t\t1.-cos(((.2*iTime+6.*log(.5*iTime+1.))*.9)*.05) \n\t\t\t\t\t  );\n\t//iters += .1*atan(c.y,c.x);\n\t//iters -= .1*c.x;\n\t//iters -= .1*length(c);\n\t\n\tfor (float i = 0.; i < MAX_ITERS; ++i) {\n\t\tif( i > iters ) continue;\n\t\t\n\t\tfloat alpha = clamp(iters-float(i),0.,1.);\n\t\talpha = smoothstep(0.,1.,alpha);\n\t\t\n\t\tvec2 newz = vec2(z.x  * z.x - z.y * z.y, 2.0 * z.x * z.y ) + c;\n\t\t\n\t\t// simple linear interpolation\n\t\tz = (1.-alpha)*z + alpha*newz;\n\t\t\n\t\t// suprisingly (to me) a polar interpolation doesn't look as nice as the simple\n\t\t// linear interpolation - it fades instead of interpolates\n\t\t/*\n\t\tfloat theta0 = atan(z.y,z.x);\n\t\tfloat a0 = sqrt(z.x*z.x+z.y*z.y);\n\t\t\n\t\tfloat theta1 = atan(newz.y,newz.x);\n\t\tfloat a1 = sqrt(newz.x*newz.x+newz.y*newz.y);\n\t\t\n\t\tfloat newtheta = mix( theta0, theta1, alpha );\n\t\tfloat newa = mix(a0,a1,alpha);\n\t\tz.x = newa * cos(newtheta);\n\t\tz.y = newa * sin(newtheta);\n\t\t*/\n \t}\n\t\n\tfloat col = (z.x*z.x+z.y*z.y);\n\t\n\t// method 1\n\t/*col = 1.-col;\n\tcol = clamp(col,0.,1.);\n\tcol = pow(col,3.);\n\tcol = 1.-col;\n\t*/\n\t// method 2\n\t//.35\n\t\n\tcol = pow(col,.35);\n\tcol = clamp(col,0.,1.1);\n\t\n\tfloat vign = (1.-.5*dot(uv-.5,uv-.5));\n\tfragColor.xyz = vec3(.95,.95,.8)*(col) * vign;\n\t\n\t/* use something like mmalex's elegant background?\n\tvec2 uv2=fragCoord.xy*(1./128.0);\n\tfloat h= texture(iChannel0,uv2).x;\n\tfloat h2=texture(iChannel0,uv2+vec2(0.001,0.003)).x;\n\tvec3 col2 = vec3(0.75+(h-h2)*0.2);\n\tfragColor=col*vec4(pow(col2*vec3(0.99,0.98,0.97),vec3(0.55)),0.0);\n*/\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"Mdj3Rh","date":"1383872581","viewed":571,"name":"Mandelbrots darker side","username":"huwb","description":"I wanted to visualise the points inside the mandelbrot set, usually drawn black. Here I shade based on the size of the iterate. I found that blending in iterations produces the nice animated effect. Question for you guys in the code comments :).","likes":27,"published":1,"flags":0,"usePreview":0,"tags":["mandelbrot"],"hasliked":0,"parentid":"","parentname":""}}