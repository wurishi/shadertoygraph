{"ver":"0.1","info":{"id":"3tSfWK","date":"1599841664","viewed":377,"name":"fake CRT monitor","username":"latel88","description":"fake CRT monitor","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["2d","video","crt"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sX3Rn","filepath":"/media/a/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv","previewfilepath":"/media/ap/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv","type":"video","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/* crt buffer*/\n\nprecision highp int;\nprecision highp float;\nprecision highp sampler2D;\n\n#define QUATER 0.7853981633974483\n#define HALF 1.5707963267948966\n#define PI 3.141592653589793\n#define CIRCLE 6.283185307179586\n\n#define REZ (iResolution.xy)\n\nconst bool shadowMask = true;\nconst int subScale = 3;\nconst float gamma = 1.25;\nconst float bright = 7.5;\nconst float blink_force = 0.0125;\nconst float blink_time = 1.0;\nconst float line = 0.25;\nconst float scanline = 0.2;\nconst float scanline_count = 25.0;\nconst float scanline_speed = 1.0;\nconst float vig = 0.175;\nconst float ca = 2.5;\nconst float lens = 0.125;\nconst float deep =  0.075;\nconst float edge = 0.0125;\nconst float factor = 32.0;\n\nconst mat4 table = mat4(\n    -4.0, 0.0, -3.0, 1.0,\n    2.0, -2.0, 3.0, -1.0,\n    -3.0, 1.0, -4.0, 0.0,\n    3.0, -1.0, 2.0, -2.0\n);\n\nvec2 sub;\n\nfloat calcUV ( const in vec2 uv, const in float m )\n{\t\n\tfloat s = (0.0 + 1.0 * 16.0 * uv.x * uv.y * (1.0 - uv.x) * (1.0 - uv.y));\n\t\n\treturn max( m, s );\n\n}\n\nbool hasOutScreen ( const in vec2 uv )\n{\n\treturn uv.x < 0.0 || uv.x > 1.0 || uv.y < 0.0 || uv.y > 1.0;\n\n}\n\nfloat udRoundBox ( const in vec2 p, const in vec2 b, const in float r )\n{\n\treturn length( max( abs( p ) - b + r, 0.0 ) ) - r;\n\n}\n\nbool hasOut ( vec2 fuv )\n{\n\treturn hasOutScreen( fuv ) || udRoundBox( fuv * REZ - REZ * 0.5, REZ * 0.5, min( REZ.x, REZ.y ) * edge ) > 0.0;\n\n}\n\nbool hasShadowMaskX ( const vec2 uv )\n{\n\treturn shadowMask && mod( uv.x * REZ.x, sub.x * 2.0 ) / sub.x > 1.0;\n\n}\n\nbool hasShadowMaskY ( const vec2 uv )\n{\n\treturn shadowMask && mod( uv.y * REZ.y, sub.y * 2.0 ) / sub.y > 1.0;\n\n}\n\nvec3 calcCRTX ( const in vec3 color, const in vec2 uv )\n{\n\tfloat scan = mod(uv.x * REZ.x, sub.x) / sub.x * PI;\n\tfloat scansY = clamp( sin( scan ), 0.0, 1.0 );\n\tfloat sy = 0.5 + scansY * line * 0.5;\n\n\treturn color * sy;\n\n}\n\nvec3 calcCRTY ( const in vec3 color, const in vec2 uv )\n{   \n\tfloat scan = mod(uv.y * REZ.y, sub.y) / sub.y * PI;\n\tfloat scansX = clamp( sin( scan ), 0.0, 1.0 );\n\tfloat sx = 0.5 + scansX * line * 0.5;\n\n\treturn color * sx;\n\n}\n\nvec3 calcScanLine ( const in vec3 color, const in vec2 uv )\n{\n\tfloat scan = uv.y * scanline_count;\n\tfloat scansX = clamp( 0.35 + 0.35 * cos( scan + (iTime * scanline_speed * PI) ), 0.0, 1.0 );\n\tfloat sx = pow( scansX * scanline, 1.7 );\n\n\treturn color * vec3(0.4 + 0.75 * sx);\n\n}\n\nvec3 fillter ( const in vec3 color, const in vec2 uv )\n{\n    vec3 col = color;\n    \n    col += table[int( uv.x ) % 4][int( uv.y ) % 4] * 0.005;  \n\n    return floor(col * factor) / factor; \n}\n\nvec3 getColor ( const in vec2 uv )\n{\n    vec2 fuv = (uv * REZ - mod( uv * REZ, sub )) / REZ;\n\tvec3 color = hasOut( uv ) ? vec3(0.0) : texture( iChannel0, fuv ).rgb;\n\t\n    color = fillter( color, uv );\n    \n\tcolor = pow( color, vec3(1.0 / gamma) );\n\tcolor = color + color * bright;\n\t\n    color = calcCRTX( color, uv );\n    color = calcCRTY( color, uv );\n    \n\treturn color;\n\n}\n\nvec2 getLensUV ( const in vec2 uv )\n{\n\tfloat quat = QUATER;\n\tvec2 u = (uv - 0.5) * 2.0;\n\n\tvec2 par = vec2(\n\t\t(1.0 - abs( cos( u.y * quat ) )),\n\t\t(1.0 - abs( cos( u.x * quat ) ))\n\t\t\n\t);\n\n\tvec2 aspect = vec2(\n\t\t1.0 / (REZ.x / REZ.y),\n\t\t1.0 / (REZ.y / REZ.x)\n\n\t);\n\n\tpar.x = par.x * lens + (uv.y * deep);\n\tpar.y = par.y * (lens + par.x * uv.y * deep) + deep / 2.0;\n\t\n\treturn par * aspect;\n\t\n}\n\nvec2 calcLensUV ( const in vec2 uv )\n{\n\tvec2 u = (uv - 0.5) * 2.0;\n\t\n\tu *= 1.0 + getLensUV( uv );\n\t\n\treturn (u / 2.0) + 0.5;\n\t\n}\n\nvec3 calcChromaticAberration ( const in vec2 fuv )\n{\n\tfloat d = (1.0 / iResolution.x * sub.x)  / 3.0;\n    \n    vec2 texel = 1.0 / REZ;\n    vec2 coords = (fuv - 0.5) * 2.0;\n    float coordDot = dot( coords, coords );\n    vec2 precompute = vec2(ca) * coordDot * coords;\n\n    bool x = hasShadowMaskX( fuv );\n\n    vec2 u = fuv + vec2(0.0, x ? 0.0 : 1.0 / REZ.y * sub.y / 2.0 );\n    \n\tvec2 red = u - texel.xy * precompute;\n\tvec2 green = u;\n\tvec2 blue = u + texel.xy * precompute;\n    \n    vec3 o = getColor( fuv );\n    \n    if (!hasOut( red ))\n    {\n        o.r = getColor( red ).r;\n\n    }\n\n    if (!hasOut( green ))\n    {\n        o.g = getColor( green ).g;\n\n    }\n\n    if (!hasOut( blue ))\n    {\n        o.b = getColor( blue ).b;\n\n    }\n    \n\treturn o;\n\n}\n\nvec3 calcBlink ( const in vec3 color, const in vec2 uv )\n{\n\tvec3 col = color;\n\n\tcol *= 1.0 + blink_force * sin( 110.0 * (iTime * blink_time) );\n\n\treturn col;\n\n}\n\nvec3 calcVig ( const in vec3 color, const in vec2 uv )\n{\n\tfloat v = (0.0 + 1.0 * 16.0 * uv.x * uv.y * (1.0 - uv.x) * (1.0 - uv.y));\n\n\treturn color * vec3(pow( v, vig ));\n\t\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / REZ;\n\tvec2 fuv = calcLensUV( uv );\n\n\tif (!hasOut( fuv ))\n\t{\n        float m = iMouse.x / iResolution.x;\n    \tsub = max(vec2(subScale + int((m * 15.0) - mod(m * 15.0, 3.0))), REZ / iChannelResolution[0].xy);\n    \n\t\tvec3 color = calcChromaticAberration( fuv );\n\n\t\tcolor = calcScanLine( color, fuv );\n\t\tcolor = calcBlink( color, uv );\n\t\tcolor = calcVig( color, fuv );\n\t\t\n\t\tfragColor = vec4(color, 1.0);\n\n\t}\n\telse\n\t{\n\t\tfragColor = vec4(vec3(0.0), 1.0);\n\n\t}\n}","name":"Image","description":"","type":"image"}]}