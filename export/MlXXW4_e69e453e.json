{"ver":"0.1","info":{"id":"MlXXW4","date":"1436772426","viewed":559,"name":"Cubemap Seam Fix","username":"ben","description":"I finally got sick of cubemap seams with native WebGL on Windows. There's a small improvement with ANGLE too. [url=http://i.imgur.com/b7dSFFu.gif]Here's a comparison[/url] so people can see what I'm talking about. :)","likes":9,"published":1,"flags":0,"usePreview":0,"tags":["cubemap"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sX3zn","filepath":"/media/a/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png","previewfilepath":"/media/ap/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png","type":"cubemap","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[],"code":"//  Creative Commons CC0 1.0 Universal (CC-0) \n//  \n//  A simple fix for cubemap seams when using native WebGL instead of ANGLE on Windows.\n//  Not sure if it's a problem on other operating systems.\n//  \n//  The cubemap resolution needs to be passed in manually because iChannelResolution \n//  only seems to work correctly for 2D textures.\n//  \n//  ~bj.2015\n//  \n\n\nvec4 textureFixed(const in samplerCube tex, in vec3 P, const in float cubeResolution)\n{\n    vec3 absP = abs(P);\n    vec3 mask = step(absP.xyz, max(absP.yzx, absP.zxy));\n    float scale = cubeResolution / (cubeResolution - 1.0);\n    P *= mix(vec3(scale), vec3(1.0), mask);\n    return texture(tex, P);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = 2.0 * fragCoord.xy - iResolution.xy;\n    uv /= max(iResolution.x, iResolution.y);\n    \n    float mo = fragCoord.x - iMouse.x;\n    if (iMouse.z <= 0.0) mo = fragCoord.x - (sin(iTime*0.5) + 1.0) * iResolution.x * 0.5;\n    \n    vec3 ro = vec3(cos(0.2), -0.2, sin(0.2)) * 3.0;\n    vec3 w = -normalize(ro);\n    vec3 u = normalize(cross(w, vec3(0.0, 1.0, 0.0)));\n    vec3 v = cross(u, w);\n    vec3 rd = normalize(u*uv.x + v*uv.y + w*0.5);\n    \n    // sphere intersection\n    float f = 1.0;\n    vec3 o = ro - vec3(1,-0.4,1);\n    float b = dot(o,rd);\n    float d = b*b - dot(o,o) + 1.0;\n    if (d >= 0.0)\n    {\n        float t = -b - sqrt(d);\n        vec3 p = o + t*rd;\n        vec3 n = normalize(p);\n        vec3 v = -normalize(rd);\n        // update view direction\n        rd = reflect(rd,n);\n        // Fresnel-ish mask for reflection color\n        f = 1.0 - dot(n,v);\n        f = 0.1 + 0.9*f*f;\n    }\n    \n    // sample fixed and unfixed cubemaps\n    vec3 cubeFixed = textureFixed(iChannel0, rd, 64.0).rgb;\n    vec3 cubeUnfixed = texture(iChannel0, rd).rgb;\n    \n    // blend between them to show the difference\n    vec3 c = mix(cubeFixed, cubeUnfixed, step(0.0, mo));\n    \n    // modulate the sphere color\n    c *= mix(vec3(0.5, 0.7, 0.9), vec3(1.0), f);\n    \n    // line dividing fixed and unfixed\n    c = mix(vec3(0.85,0.15,0.15), c, smoothstep(0.0, 1.5, abs(mo)));\n    \n    // yay\n    fragColor = vec4(c, 1.0);\n}","name":"Image","description":"","type":"image"}]}