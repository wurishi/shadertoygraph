{"ver":"0.1","info":{"id":"tdS3zK","date":"1549340758","viewed":259,"name":"Neon Metaballs","username":"scratch13764","description":"Metaballs using blur noise (smoothstep). I use perlin noise to control the position, size, and tension of each ball. They have a rainbow glow around them too, and the ball weight has motion blur.","likes":3,"published":1,"flags":32,"usePreview":0,"tags":["metaballs","perlin","glow","neon"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\nI store all of the metaball weight values in a buffer because\neach pixel has to look at it's neighboring pixels' values.\nUsing the buffer speeds up the shader by preventing the metaball\ncalculations from happening many times for each pixel.\n*/\n\n#define pw 1. / iResolution.xy\n#define pi 3.14159265\n\nfloat GetWeight (vec2 p)\n{\n    return texture(iChannel0, p).x;\n}\n\nvec2 GetNormal (vec2 p)\n{\n    vec2 n = normalize(vec2(\n        GetWeight( vec2(p.x + pw.x, p.y) ) - GetWeight( vec2(p.x - pw.x, p.y)),\n        GetWeight( vec2(p.x, p.y + pw.y) ) - GetWeight( vec2(p.x, p.y - pw.y))\n        ));\n    if(length(n) > 0.) return n;\n    else return vec2(0);\n}\n\nvoid mainImage( out vec4 c, in vec2 p )\n{\n    vec2 uv = p / iResolution.xy;\n    \n    float Ball = smoothstep(0.48, 0.52, GetWeight(uv));\n    \n    vec2 Normal = GetNormal(uv);\n    float Angle = atan(Normal.x/Normal.y) + step(-Normal.y, 0.)*pi;\n    \n    float Colors = 2. + sin(iTime*pi)*2.;\n    \n    vec4 GlowColor = sin(vec4(0.,pi*.66,pi*1.33,0) + Angle * Colors + iTime)*.5 + .5;\n    GlowColor = (GlowColor + 2.)/2.5;\n    \n    c = mix(GlowColor*GetWeight(uv)*2., vec4(1), Ball);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XdXGzn","filepath":"/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","previewfilepath":"/media/ap/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"/*\nb d\na c\n*/\nvec4 Perlin(vec2 p)\n{\n    vec4 a = texture(iChannel0, vec2(floor(p.x*64.)/64.,floor(p.y*64.)/64.));\n    vec4 b = texture(iChannel0, vec2(floor(p.x*64.)/64.,ceil(p.y*64.)/64.));\n    vec4 c = texture(iChannel0, vec2(ceil(p.x*64.)/64.,floor(p.y*64.)/64.));\n    vec4 d = texture(iChannel0, vec2(ceil(p.x*64.)/64.,ceil(p.y*64.)/64.));\n    \n    float ac = smoothstep(0.,1.,fract(p.x*64.));\n    float ab = smoothstep(0.,1.,fract(p.y*64.));\n    \n    return mix(mix(a, b, ab), mix(c,d , ab), ac);\n}\n\nfloat BallWeight (vec2 p, float r, float a)\n{\n    a *= .5;\n    a = max(a, 0.0001);\n    return smoothstep(a, -a , length(p) - r);\n}\n\nfloat GetWeight (vec2 p)\n{\n    float w = 0.;\n    vec4 b;\n    for(float i = 0.; i <= 15.; i++)\n    {\n        b = Perlin(vec2(i/64., iTime/128. + i/15.)); \n        //adding i/15. offsets the times when the metaballs stop moving, so there are always some moving\n        w += BallWeight(p - (b.xy - .5)*2.5, b.z/15. + 0.05, b.w/15. + .1);\n    }\n    return w;\n}\n\nvoid mainImage( out vec4 c, in vec2 p )\n{\n    vec2 uv = (p - .5*iResolution.xy)/iResolution.y;\n    \n    float Weight = GetWeight(uv);\n    if(iFrame != 0)\n    c = (vec4(Weight) + texture(iChannel1, p / iResolution.xy)*5.)/6.;\n    else c = vec4(Weight);\n}","name":"Buffer A","description":"","type":"buffer"}]}