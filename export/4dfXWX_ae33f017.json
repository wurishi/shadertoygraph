{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"struct Ray {\n    vec2 d;\n    vec2 o;\n};\n    \nstruct Segment {\n    vec4 a, b;\n};\n    \nstruct IsectData {\n    vec2 n;\n    float t;\n};\n    \nstruct Material {\n    vec4 K_d;\n    vec4 K_e;\n    vec4 K_s;\n};\n    \nfloat tmin = 0.0;\nvec2 seed;\nconst int samples = 100;\nconst int bounces = 3;\nconst float tau = 6.28318530718;\n\n\nfloat\nrand(vec2 co)\n{\n    float a = 12.9898;\n    float b = 78.233;\n    float c = 43758.5453;\n    float dt= dot(co.xy ,vec2(a,b));\n    float sn= mod(dt,3.14);\n    return fract(sin(sn) * c);\n}\n\nfloat\ncross2(const vec2 u, const vec2 v)\n{\n    return u.x*v.y - u.y*v.x;\n}\n\nbool\nintersect(const Ray r, const Segment segment, out IsectData isect)\n{\n    vec2 d = segment.b.xy - segment.a.xy;\n    vec2 o = segment.a.xy;\n\n    float c = cross2(d, r.d);\n    float s = cross2(r.o - o, r.d) / c;\n\n    if (c != 0.0 && 0.0 <= s && s <= 1.0) {\n        isect.n = normalize(c*vec2(-d.y, d.x));\n        isect.t = (o.x - r.o.x + s*d.x)/r.d.x;\n        return true;   \n    } else {\n        return false;\n    }\n}\n    \n    \n// TODO: segments lying exactly on pixels and being lights causes problems\nvoid\nmainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    seed = fragCoord.xy*iTime;\n\n\n    Material materials[6];\n    materials[0] = Material(vec4(0.0), vec4(5.0*abs(sin(iTime)), 2.0*abs(sin(iTime - 0.01)), 0.0, 1.0), vec4(0.0));\n    materials[1] = Material(vec4(0.0), vec4(0.0, 2.0, 2.0, 1.0), vec4(0.0));\n    materials[2] = Material(vec4(0.0), vec4(0.0), vec4(1.0));\n    materials[3] = Material(vec4(0.0), vec4(0.0), vec4(1.0));\n    materials[4] = Material(vec4(0.0), vec4(0.0), vec4(1.0));\n    materials[5] = Material(vec4(0.0), vec4(0.0), vec4(1.0));\n\n    Segment segments[6];\n    segments[0] = Segment(vec4(0.75*iResolution.x, 0.25*iResolution.x, 0.0, 1.0), vec4(0.625*iResolution.x, 0.12*iResolution.x, 0.0, 1.0));\n    segments[1] = Segment(vec4(0.06*iResolution.x, 0.2*iResolution.x, 0.0, 1.0), vec4(0.1*iResolution.x, 0.3*iResolution.x, 0.0, 1.0));\n    segments[2] = Segment(vec4(-0.06*iResolution.x, -0.06*iResolution.x, 0.0, 1.0), vec4(0.06*iResolution.x, -0.06*iResolution.x, 0.0, 1.0));\n    segments[3] = Segment(vec4(0.06*iResolution.x, -0.06*iResolution.x, 0.0, 1.0), vec4(0.06*iResolution.x, 0.06*iResolution.x, 0.0, 1.0));\n    segments[4] = Segment(vec4(0.06*iResolution.x, 0.06*iResolution.x, 0.0, 1.0), vec4(-0.06*iResolution.x, 0.06*iResolution.x, 0.0, 1.0));\n    segments[5] = Segment(vec4(-0.06*iResolution.x, 0.06*iResolution.x, 0.0, 1.0), vec4(-0.06*iResolution.x, -0.06*iResolution.x, 0.0, 1.0));\n\n    float cos_val = cos(iTime/4.0);\n    float sin_val = sin(iTime/4.0);\n    \n    mat4 m_model = mat4(\n        cos_val, sin_val, 0.0, 0.0,\n        -sin_val, cos_val, 0.0, 0.0,\n        0.0, 0.0, 1.0, 0.0,\n        0.31*iResolution.x, 0.25*iResolution.x + 0.06*iResolution.x*cos_val, 0.0, 1.0);\n    segments[2].a = m_model*segments[2].a;\n    segments[2].b = m_model*segments[2].b;\n    segments[3].a = m_model*segments[3].a;\n    segments[3].b = m_model*segments[3].b;\n    segments[4].a = m_model*segments[4].a;\n    segments[4].b = m_model*segments[4].b;\n    segments[5].a = m_model*segments[5].a;\n    segments[5].b = m_model*segments[5].b;\n\n    vec2 uv = fragCoord.xy/iResolution.xy;\n\n    vec4 color = vec4(0.0);\n    for (int i = 0; i < samples; i++) {\n        seed += 1.0;\n        // pixel ray\n        float random = rand(seed);\n        random = float(i)/float(samples) + random*1.0/float(samples);\n        Ray r = Ray(normalize(vec2(cos(tau*random), sin(tau*random))), fragCoord.xy);\n        vec4 L = vec4(0.0);\n        vec4 R = vec4(1.0);\n        \n     \n        vec4 R_s = vec4(0.0);\n        vec4 L_s = vec4(0.0);\n        IsectData isect;\n        IsectData isect_tmp;\n        \n        for (int j = 0; j < bounces; j++) {\n            float tmax = 1.0/0.0;\n\n            for (int k = 0; k < 6; k++) {\n                // get closest object\n                if (intersect(r, segments[k], isect_tmp) && isect_tmp.t >= tmin && isect_tmp.t <= tmax) {\n                    isect = isect_tmp;\n                    R_s = materials[k].K_s;\n                    L_s = materials[k].K_e;\n                    tmax = isect_tmp.t;\n                }\n            }\n\n            if (R_s != vec4(0.0)) {\n                r = Ray(reflect(r.d, isect.n), r.o + (tmax - 0.001)*r.d); // avoid self intersection\n            }\n\n            L += R*L_s;\n            R *= R_s;\n        }\n        color += 1.0/float(samples)*L;\n    }\n    \n    fragColor = color;\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"4dfXWX","date":"1407174442","viewed":224,"name":"2D Rays","username":"klacansky","description":"A simple 2D line path tracer.","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["2d"],"hasliked":0,"parentid":"","parentname":""}}