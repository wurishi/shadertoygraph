{"ver":"0.1","info":{"id":"lsXfWS","date":"1497779573","viewed":1068,"name":"Anisotropic brdf ashikhmin","username":"pouja","description":"implementation of ashikhmin and shirley brdf\nhttp://www.irisa.fr/prive/kadi/Lopez/ashikhmin00anisotropic.pdf\nand inspired by https://www.shadertoy.com/view/lsXSz7","likes":32,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","phong","texture","sphere","aa","brdf","anisotropic","shirley","ashikhmin"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xsf3Rr","filepath":"/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","previewfilepath":"/media/ap/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14159265359\n#define DEG_TO_RAD PI / 180.0\n\n// configure\n#define AA 4\n#define TEXTURE 1\n#define NORMAL_BUMP 1\n\n// math\nmat2 rot2( float angle ) {\n\tfloat c = cos( angle );\n\tfloat s = sin( angle );\n\t\n\treturn mat2(\n\t\t c, s,\n\t\t-s, c\n\t);\n}\n\n// rotate over the xy plane\nmat3 rot3xy( vec2 angle ) {\n\tvec2 c = cos( angle );\n\tvec2 s = sin( angle );\n\t\n\treturn mat3(\n\t\tc.y      ,  0.0, -s.y,\n\t\ts.y * s.x,  c.x,  c.y * s.x,\n\t\ts.y * c.x, -s.x,  c.y * c.x\n\t);\n}\n\nfloat sqr(float x) {\n    return x * x;\n}\n\n// distance functions\nfloat sdPlane(vec3 v) {\n    return v.y;\n}\n\nfloat sdBox( vec3 v, vec3 size, float r ) {\n\treturn length( max( abs( v ) - size, 0.0 ) ) - r;\n}\n\nfloat sdSphere(vec3 v, float r) {\n    return length(v) - r;\n}\n\nvec2 scene(vec3 v) {\n\t// sphere\n\tfloat sphere = sdSphere( v - vec3(0.0, 0.4, 0.0), 2.7 );\n\t\n\t// box\n\tv.xz = rot2( v.y ) * v.xz;\n\tfloat box = sdBox( v - vec3(0.0, 0.4, 0.0), vec3( 2.0, 2.0, 2.0 ), 0.05 );\n\n    // blend sphere and the box\n\treturn vec2(min( sphere, box ),1.0);\n}\n\n// gets the direction of the camera through the pixel coordinates\nvec3 rayDir(float fov, vec2 size, vec2 pos) {\n    // get the xy between -1 and 1;\n    vec2 xy = pos - size * 0.5;\n    \n    float halfFov = tan( (90.0 - fov * 0.5) * DEG_TO_RAD);\n    float z = size.y * 0.5 * halfFov;\n    \n    return normalize( vec3(xy, -z));\n}\n\n// basic raymarching\nvec2 rayMarching(vec3 origin, vec3 direction) {\n    const float NEAR_CLIPPING_PLANE = 0.1;\n\tconst float FAR_CLIPPING_PLANE = 100.0;\n\tconst int MAX_MARCH_STEPS = 64;\n    const float DISTANCE_BIAS = 0.4;\n\tconst float EPSILON = 0.01;\n\n    float t = NEAR_CLIPPING_PLANE;\n    float material = -1.0;\n    \n    for( int i=0; i < MAX_MARCH_STEPS; i++ )\n    {\n\t    vec2 hit = scene( origin + direction * t );\n        if( hit.x < EPSILON || t > FAR_CLIPPING_PLANE) break;\n        t += hit.x * DISTANCE_BIAS;\n\t    material= hit.y;\n    }\n\n    if( t > FAR_CLIPPING_PLANE ) material = -1.0;\n    return vec2(t, material);\n}\n\n// takes the absolutes of the dot product (since we are between -1 and 1)\nfloat minMax(float d) {\n    return max(abs(d),0.0001);\n}\n\n// calculate micro normal of p on the scene\nvec3 normal(vec3 p, float smoothness)\n{\t\n    // From https://www.shadertoy.com/view/MdSGDW\n\tvec3 n;\n\tvec2 dn = vec2(smoothness, 0.0);\n\tn.x\t= scene(p + dn.xyy).x - scene(p - dn.xyy).x;\n\tn.y\t= scene(p + dn.yxy).x - scene(p - dn.yxy).x;\n\tn.z\t= scene(p + dn.yyx).x - scene(p - dn.yyx).x;\n\treturn normalize(n);\n}\n\n\n// Ashikmin-Shirely BRDF function\nvec3 brdf(vec3 p, vec3 n, vec3 eye, vec3 lightPos, vec3 lightCol, vec3 mat) {\n    vec3 k1 = normalize(lightPos - p);\n    vec3 k2 = normalize(eye - p);\n    vec3 h = normalize(k1 + k2);\n    vec3 u = cross(n, vec3(1.0,0.0,0.0));\n    vec3 v = cross(n, u);\n    u = normalize(u);\n    v = normalize(v);\n    \n    // You can tweak n_u,n_v,Rs and the normal bump map \n    // to get different material metal look.\n    float n_u = 10.0;\n    float n_v = 100.0;\n    \n    float nDoth = minMax(dot(n,h));\n    float nDotk1 = minMax(dot(n,k1));\n    float nDotk2 = minMax(dot(n,k2));\n    float hDotu = minMax(dot(h,u));\n    float hDotv = minMax(dot(h,v));\n    float hDotn = minMax(dot(h,n));\n    float hDotk = minMax(dot(h,k1));\n    \n    vec3 Rs = vec3(0.1);\n    vec3 Rd =  mat * lightCol;\n    \n    // fresnal\n    vec3 F = Rs + (vec3(1.0) - Rs) * pow(1.0 - hDotk, 5.0);\n    \n    // specular\n    float specExp = (n_u * sqr(hDotu) + n_v * sqr(hDotv)) / (1.0 - sqr(hDotn));\n    vec3 spec = (sqrt((n_u + 1.0) * (n_v + 1.0)) / 8.0 * PI) *\n        (pow(nDoth, specExp) / (hDotk * max(nDotk1, nDotk2))) * F;\n            \n    // diffuse\n    vec3 diff = ((28.0 * Rd) / (23.0 * PI)) *\n        (vec3(1.0) - Rs) *\n        (1.0 - pow(1.0 - 0.5 * nDotk1, 5.0)) *\n        (1.0 - pow(1.0 - 0.5 * nDotk2, 5.0));\n    \n    diff *= 2.0;\n    \n    return diff + spec;\n}\n\n// Calculates the color at the given position with the normal, eye position and material color\n// for every light there is.\nvec3 shading(vec3 p, vec3 n, vec3 eye, vec3 mat) {\n\tvec3 final = vec3( 0.0 );\t\n\tmat3 rot = rot3xy( vec2( -DEG_TO_RAD*30.0, iTime * 0.5 ) );\n\n\t// light 0\n\t{\n\t\tvec3 light = vec3( 2.0, 5.0, 2.0 );\n\t\tvec3 lightColor = vec3( 0.4, 0.6, 0.8 );\n\t\t\n\t\tfinal += brdf(p,n,eye,light,lightColor,mat);\n\t}\n\t\n\t// light 1\n\t{\n\t\tvec3 light = vec3( -3.0, 7.0, -3.0 );\n\t\tvec3 lightColor = vec3( 0.8, 0.5, 0.3 );\n\t\t\n\t\tfinal += brdf(p,n,eye,light,lightColor,mat);\n\t}\n\n\treturn final;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 totalColor = vec3(0.0);\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        vec2 offset = vec2(float(m),float(n)) / float(AA) - 0.5;\n        \n        vec3 dir = rayDir(45.0, iResolution.xy + offset, fragCoord.xy);\n\n        vec3 color = vec3(0.7) + dir.y * 0.72;\n\n        vec3 eye = vec3(0.0,0.0,10.0);\n\n        // rotate camera\n        mat3 rot = rot3xy( vec2( -DEG_TO_RAD*30.0, iTime * 0.5 ) );\n        dir = rot * dir;\n        eye = rot * eye;\n\n        vec2 hit = rayMarching(eye, dir);\n        float depth = hit.x;\n\n        // if hit\n        if (hit.y == 1.0) {\n            vec3 p = eye + dir * depth;\n            vec3 n = normal(p, 0.1);\n\n            #if TEXTURE\n            // material color from texture\n            float u = atan(n.z, n.x) / PI*2.0;\n            float v = asin(n.y) / PI*2.0 + 0.5;\n            vec3 mat = texture( iChannel0, vec2(u,v)).xyz;\n            #else\n            vec3 mat = vec3(0.6);\n            #endif\n\n            #if TEXTURE&&NORMAL_BUMP\n            // bumbmapping\n            float maxVariance = 2.0; \n            float minVariance = maxVariance / 6.0;\n            n += normalize(mat * maxVariance - minVariance);\n\t\t\t#endif \n            \n            color = shading(p,n,eye,mat); \n        }\n        totalColor += color;\n    }\n    \n    totalColor /= float(AA*AA);\n    \n    fragColor = vec4(totalColor, 1.0);        \n}","name":"Image","description":"","type":"image"}]}