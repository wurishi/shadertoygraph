{"ver":"0.1","info":{"id":"wsyBW1","date":"1607273946","viewed":137,"name":"raymaaa","username":"nff","description":"fsdfs","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["fdsfsa"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// raymarch2.bonzo\n\n#define tt iTime\n#define res iResolution\n\nconst int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float EPSILON = 0.0001;\n\nfloat stillNoise (vec2 uv) {\n    return sin(dot(uv.xy,vec2(130.9898,500.233)));}\n\n/* Signed distance function for a sphere centered at \"position\" */\nfloat sphereSDF(vec3 samplePoint, float radius, vec3 position) {\n    samplePoint = vec3(samplePoint.x+position.x, samplePoint.y+position.y, samplePoint.z+position.z);\n    return length(samplePoint) - radius * stillNoise(samplePoint.xy);\n  }\n\n/*\n * Signed distance function describing the scene.\n * \n * Absolute value of the return value indicates the distance to the surface.\n * Sign indicates whether the point is inside or outside the surface,\n * negative indicating inside.\n */\nfloat sceneSDF(vec3 samplePoint) {\n    return sphereSDF(samplePoint, .5, vec3(sin(tt),0.,0.));\n}\n\n/*\n * Return the shortest distance from the camera position to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * cam: the camera position, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * minDepth: the starting distance away from the camera\n * maxDepth: the max distance away from the camera to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 cam, vec3 marchingDirection, float minDepth, float maxDepth) {\n    float depth = minDepth;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(cam + depth * marchingDirection);\n        if (dist < EPSILON) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= maxDepth) {\n            return maxDepth;\n        }\n    }\n    return maxDepth;\n}\n            \n\n/*\n * Return the normalized direction to march in from the cam point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 dir = rayDirection(45.0, res.xy, fragCoord);\n    vec3 cam = vec3(0., 0., 5.);\n    float dist = shortestDistanceToSurface(cam, dir, MIN_DIST, MAX_DIST);\n    \n    if (dist > MAX_DIST - EPSILON) {\n        // Didn't hit anything >> black\n        fragColor = vec4(0., 0., 0., 0.);\n\t\treturn;\n    }\n    \n    fragColor = vec4(1., 1., 1., 1.);\n}","name":"Image","description":"","type":"image"}]}