{"ver":"0.1","info":{"id":"McBXRt","date":"1706694475","viewed":70,"name":"zy ray marching 02","username":"xu_wenjun118","description":"学习ray marching","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["learnraymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS 100\n#define MAX_DIST 100.0\n#define SURF_DIST 0.01\n\n\nfloat sdOctahedron(vec3 p, float s) {\n    p = abs(p);\n    return (p.x + p.y + p.z - s) * 0.57735027;\n}\n\nvec3 palette(float t) {\n    vec3 a = vec3(0.5);\n    vec3 b = vec3(0.5);\n    vec3 c = vec3(1.0);\n    vec3 d = vec3(0.263, 0.416, 0.557);\n    return a + b * cos(6.28318 * (c * t + d));\n}\n\nvec3 rot3D(vec3 p, vec3 axis, float angle) {\n    return mix(dot(axis, p) * axis, p, cos(angle)) + cross(axis, p) * sin(angle);\n}\n\nmat2 rot2D(float angle) {\n    float s = sin(angle);\n    float c = cos(angle);\n    return mat2(c, -s, s, c);\n}\n\nfloat smin(float a, float b, float k) {\n    float h = max(k - abs(a - b), 0.0) / k;\n    return min(a, b) - h * h * h * k * (1.0 / 6.0);\n} \n\n// 定义到球体的距离函数\n// 其中p是球体的位置，s是球体的半径\nfloat sdSphere(vec3 p, float s) {\n    return length(p) - s;\n}\n\n// 定义到盒子的距离函数\n// b为边长\nfloat sdBox(vec3 p, vec3 b) {\n    vec3 q = abs(p) - b;\n    return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)),0.0);\n}\n\nfloat GetDist(vec3 p) {\n    p.z += iTime * 0.4;\n    p.xy = fract(p.xy) - 0.5;\n    p.z = mod(p.z, 0.25) - 0.125;\n    float box = sdOctahedron(p, 0.15);\n    return box;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n    vec2 m = (iMouse.xy * 2.0 - iResolution.xy) / iResolution.y;\n\n    vec3 ro = vec3(0, 0, -4); // 摄像机的位置\n    vec3 rd = normalize(vec3(uv, 1.0)); // 光线方向\n    \n    // 旋转摄像机(绕y轴旋转)\n    // ro.xz *= rot2D(-m.x);\n    // rd.xz *= rot2D(-m.x);\n    // ro.yz *= rot2D(-m.y);\n    // rd.yz *= rot2D(-m.y);\n    \n    float d0 = 0.0;\n    int i;\n    for (i = 0; i < MAX_STEPS; i++) {\n        vec3 p = ro + rd * d0;\n        p.xy *= rot2D(d0 * 0.2);\n        p.y += sin(d0 * (m.y + 1.0) * 0.5) * 0.35;\n        float ds = GetDist(p);\n        d0 += ds;\n        if (d0 > MAX_DIST || ds < SURF_DIST) {\n            break;\n        }\n    }\n    vec3 col = palette(d0 * 0.04 + float(i) * 0.005);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}