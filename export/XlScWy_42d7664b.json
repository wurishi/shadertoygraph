{"ver":"0.1","info":{"id":"XlScWy","date":"1509928000","viewed":369,"name":"Karman Vortex Street Fork","username":"riouxld","description":"Vortex street should start slowly near 30sec, fully developped (mostly) at 60 sec! (60fps) \nAdd smoke/die with left click.\n\n(the shock at the start is due to large time-step and incompatbility between inlet and initial condition)","likes":14,"published":1,"flags":32,"usePreview":0,"tags":["simulation","fluid","advection","multipass","navierstokes","jacobi","multistep"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Variation of a precedent project\n// https://www.shadertoy.com/view/XtSczK\n\n// added substance advection/diffusion along the flow (like die coloring in fluid experiment)\n// you can modify the parameter (but do it in all buffer)\n\n// choose what field to look at by commenting the others\n//#define VELOCITY\n//#define PRESSURE\n//#define DIVERGENCE\n//#define VORTICITY\n#define DENSITY //density of smoke/die\n\n// must be modified in all buffers and image\n// simulation parameters\nconst float dt = 1.0/400.0; //time-stepping\nconst vec2 force = vec2(2.0, 0.0); //constant pressure gradiant flow\nconst float reynold = 100.0; //constant defining the flow ~high=water, ~low=vscous\n\t\t\t\t\t\t\t //for karman, higher the better.\n\t\t\t\t\t\t\t //reynold an dt are \"coupled\" so modify both for accuracy.\n\nconst float kappa = 0.000005; //substance diffusion constant\nconst float alpha = 0.3; //substance dissipation rate\nconst int bandNb = 8; //number of die line\nconst int bandDens = 2; //density of die line (high mean less dense)\n\nconst int obsRadius = 10; //radius of obstacle\nconst vec2 obsPos = vec2(0.12,0.5); //positon (iResotution.xy*obsPos.xy)\n\n//macro\n#define GetDensity(I,J) texelFetch( iChannel1, ijCoord+ivec2(I,J), 0 ).z\n#define GetVelocity(I,J) texelFetch( iChannel3, ijCoord+ivec2(I,J), 0 ).xy\n#define GetPressure(I,J) texelFetch( iChannel2, ijCoord+ivec2(I,J), 0 ).x\n\n// COLORMAP\nvec3 hot(float t)\n{\n    return vec3(smoothstep(0.00,0.33,t),\n                smoothstep(0.33,0.66,t),\n                smoothstep(0.66,1.00,t));\n}\n\n\nvec3 gray(float t)\n{\n    return vec3(t);\n}\n\nvec3 jet(float t)\n{\n    return smoothstep(0.5,0.75,t) * vec3(1,0,0)\n         + (smoothstep(0.0,0.25,t)-(smoothstep(0.75,1.0,t))) * vec3(0,1,0)\n        + (1.0-smoothstep(0.25,0.5,t)) * vec3(0,0,1);\n}\n\nvec3 wheel(float t)\n{\n    return clamp(abs(fract(t + vec3(1.0, 2.0 / 3.0, 1.0 / 3.0)) * 6.0 - 3.0) -1.0, 0.0, 1.0);\n}\n\nvec3 cool(float t)\n{\n    return mix( vec3(0.0,1.0,1.0), vec3(1.0,0.0,1.0), t);\n}\n\n// for testing purpose, https://www.shadertoy.com/view/4dlczB\nvec3 blackbody(float t)\n{\n\tfloat Temp = t*7500.0;\n    vec3 col = vec3(255.);\n    col.x = 56100000. * pow(Temp,(-3. / 2.)) + 148.;\n   \tcol.y = 100.04 * log(Temp) - 623.6;\n   \tif (Temp > 6500.) col.y = 35200000. * pow(Temp,(-3. / 2.)) + 184.;\n   \tcol.z = 194.18 * log(Temp) - 1448.6;\n   \tcol = clamp(col, 0., 255.)/255.;\n    if (Temp < 1000.) col *= Temp/1000.;\n   \treturn col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //set grid\n    float dx = 1.0 / iResolution.y;\n    float dxPow = dx *dx ;\n    vec2 uvCoord = dx*fragCoord.xy;\n    ivec2 ijCoord = ivec2(floor(fragCoord.xy));\n\n    // set obstacle\n\tivec2 obsCenter = ivec2(floor(iResolution.xy*obsPos));\n    ivec4 obsCoord = ivec4(obsCenter-obsRadius, obsCenter+obsRadius);\n\n    if (abs(ijCoord.x - obsCenter.x) <= obsRadius  &&  abs(ijCoord.y - obsCenter.y) <= obsRadius) \n    {\n    \tfragColor = vec4(0.5);\n        return;\n    } \n    \n    //to compute finite difference approximaton\n\n    vec2 uv = GetVelocity(0,0); \n    float p = GetPressure(0,0); \n    float density = GetDensity(0,0); \n\n    //to compute finite difference approximaton\n    vec2 uvip1j = GetVelocity(1,0);\n    vec2 uvim1j = GetVelocity(-1,0);\n    vec2 uvijp1 = GetVelocity(0,1);\n    vec2 uvijm1 = GetVelocity(0,-1);\n    vec2 uvijentry =  GetVelocity(-ijCoord.x,0);\n    vec2 uvijexit =  GetVelocity(-ijCoord.x+int(iResolution.x)-1,0);\n\n    // set outer boundary conditions\n    if(ijCoord.x ==  int(iResolution.x)-1)\n    {\n        uvip1j = uv;\n    }\n    \n    if(ijCoord.x == 0)\n    {\n        uvim1j = 2.0*vec2(4.0*uvCoord.y*(1.0-uvCoord.y),0.0)-uv; \n    }\n    if(ijCoord.y ==  int(iResolution.y)-1)\n    {\n        uvijp1 = -uv;\n    }\n    \n    if(ijCoord.y == 0)\n    {\n        uvijm1 = -uv;\n    }\n    \n    // set obstacle boundary conditions\n    if(ijCoord.x == obsCoord.x-1 && ijCoord.y >= obsCoord.y && ijCoord.y <= obsCoord.w )\n    {\n        uvip1j = -uv;\n    }\n    if(ijCoord.x == obsCoord.z+1 && ijCoord.y >= obsCoord.y && ijCoord.y <= obsCoord.w )\n    {\n        uvim1j = -uv;\n    }\n    if(ijCoord.y == obsCoord.w+1 && ijCoord.x >= obsCoord.x && ijCoord.x <= obsCoord.z )\n    {\n        uvijm1 = -uv;\n    }\n    if(ijCoord.y == obsCoord.y-1 && ijCoord.x >= obsCoord.x && ijCoord.x <= obsCoord.z )\n    {\n        uvijp1 = -uv;\n    }\n    \n    float vortiticy = 0.5*(uvijp1.y-uvim1j.y +uvijp1.x-uvijm1.x)/dx;\n    float divervence =  0.5*(uvip1j.x-uvim1j.x+uvijp1.y-uvijm1.y)/dx;\n    \n\n    #ifdef VELOCITY\n    fragColor =vec4(1.0-hot(0.5*(uv.x+1.0)),1);\n    #endif\n    #ifdef PRESSURE\n    fragColor =vec4(1.0-hot(0.01*(p+60.0)),1);\n    #endif\n    #ifdef DIVERGENCE\n    fragColor =vec4(1.0-hot(0.1*(divervence+5.0)),1);\n    #endif\n    #ifdef VORTICITY\n    fragColor =vec4(1.0-hot(0.1*(vortiticy+5.0)),1);\n    #endif\n    #ifdef DENSITY\n    fragColor = vec4(1.0-blackbody(1.0-density),1);\n    //fragColor = vec4(hot(density),1);\n    #endif\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//Set initial condition / perturbation / advection / force\n\n// must be modified in all buffers and image\n// simulation parameters\nconst float dt = 1.0/400.0; //time-stepping\nconst vec2 force = vec2(2.0, 0.0); //constant pressure gradiant flow\nconst float reynold = 100.0; //constant defining the flow ~high=water, ~low=vscous\n\t\t\t\t\t\t\t //for karman, higher the better.\n\t\t\t\t\t\t\t //reynold an dt are \"coupled\" so modify both for accuracy.\n\nconst float kappa = 0.000005; //substance diffusion constant\nconst float alpha = 0.1; //substance dissipation rate\nconst int bandNb = 5; //number of die line\nconst int bandDens = 3; //density of die line (high mean less dense)\n\nconst int obsRadius = 10; //radius of obstacle\nconst vec2 obsPos = vec2(0.12,0.5); //positon (iResotution.xy*obsPos.xy)\n\n//macro\n#define GetVelocity(I,J) texelFetch( iChannel0, ijCoord+ivec2(I,J), 0 ).xy\n#define GetVelocityUV(X,Y) texture( iChannel3, fragCoord.xy/ iResolution.xy+vec2(X,Y)).xy\n#define GetDensity(I,J) texelFetch( iChannel1, ijCoord+ivec2(I,J), 0 ).z\n#define GetDensityUV(X,Y) texture( iChannel1, fragCoord.xy/ iResolution.xy+vec2(X,Y)).z\n\n\n// constant height bumb function\nconst float radius = 0.05; \nfloat bumbCyl(float p)\n{\n\treturn 1.0;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    // set grid\n    float dx = 1.0 / iResolution.y;\n    float dxPow = dx *dx ;\n    vec2 uvCoord = dx*fragCoord.xy;\n    ivec2 ijCoord = ivec2(floor(fragCoord.xy));\n    \n    // set obstacle\n\tivec2 obsCenter = ivec2(floor(iResolution.xy*obsPos));\n    ivec4 obsCoord = ivec4(obsCenter-obsRadius, obsCenter+obsRadius);\n    \n    if (abs(ijCoord.x - obsCenter.x) <= obsRadius  &&  abs(ijCoord.y - obsCenter.y) <= obsRadius) \n    {\n    \tfragColor = vec4(0,0,0,0);\n        return;\n    } \n    \n    // initial condition\n    if (iFrame==0) {\n        fragColor = vec4(4.0*uvCoord.y*(1.0-uvCoord.y),0,0,0);\n        return;\n    }\n    \n    // advect via semi-lagrangian method\n    vec2 uv = GetVelocity(0,0);\n    vec2 uvAdv = GetVelocityUV( -uv.x*dt,-uv.y*dt);\n    float densityAdv = GetDensityUV( -uv.x*dt,-uv.y*dt)/(1.0+dt*alpha);\n    \n    // add driving force\n    // may be problematic with obstacle. can be removed. The simulation will have less energy,\n    // but the inlet boundary condition should be enough.\n    uvAdv += dt*force/reynold;\n    \n    // add die with mouse\n    float pert = length((fragCoord.xy - iMouse.xy) / iResolution.y);   \n    if(iMouse.z > 0.0 && pert < radius) {\n        fragColor = vec4(uv,1.0,0);\n        return;\n    }\n    \n    fragColor = vec4(uvAdv, densityAdv, 0); \n}","name":"Buf A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// solve for diffusion\n\n// must be modified in all buffers and image\n// simulation parameters\nconst float dt = 1.0/400.0; //time-stepping\nconst vec2 force = vec2(2.0, 0.0); //constant pressure gradiant flow\nconst float reynold = 200.0; //constant defining the flow ~high=water, ~low=vscous\n\t\t\t\t\t\t\t //for karman, higher the better.\n\t\t\t\t\t\t\t //reynold an dt are \"coupled\" so modify both for accuracy.\n\nconst float kappa = 0.000005; //substance diffusion constant\nconst float alpha = 0.3; //substance dissipation rate\nconst int bandNb = 21; //number of die line\nconst int bandDens = 2; //density of die line (high mean less dense)\n\nconst int obsRadius = 10; //radius of obstacle\nconst vec2 obsPos = vec2(0.12,0.5); //positon (iResotution.xy*obsPos.xy)\n\n//macro\n#define GetVelocity(I,J) texelFetch( iChannel0, ijCoord+ivec2(I,J), 0 ).xy\n#define GetDensity(I,J) texelFetch( iChannel0, ijCoord+ivec2(I,J), 0 ).z\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    // set grid\n    float dx = 1.0 / iResolution.y;\n    float dxPow = dx *dx ;\n    vec2 uvCoord = dx*fragCoord.xy;\n    ivec2 ijCoord = ivec2(floor(fragCoord.xy));\n    \n    //set die parameters\n    float bandWidth = 1.0/float(bandDens*bandNb);\n    float gapWidth = (1.0-float(bandNb)*bandWidth)/float(bandNb+1);\n    \n    // set obstacle\n\tivec2 obsCenter = ivec2(floor(iResolution.xy*obsPos));\n    ivec4 obsCoord = ivec4(obsCenter-obsRadius, obsCenter+obsRadius);\n    \n    if (abs(ijCoord.x - obsCenter.x) <= obsRadius  &&  abs(ijCoord.y - obsCenter.y) <= obsRadius) \n    {\n    \tfragColor = vec4(0,0,0,0);\n        return;\n    } \n    \n    //to compute velocity finite difference approximaton\n    vec2 uv = GetVelocity(0,0); \n    vec2 uvip1j = GetVelocity(1,0);\n    vec2 uvim1j = GetVelocity(-1,0);\n    vec2 uvijp1 = GetVelocity(0,1);\n    vec2 uvijm1 = GetVelocity(0,-1);\n    \n    \n    //to compute density finite difference approximaton\n    float densij = GetDensity(0,0); \n    float densip1j = GetDensity(1,0); \n    float densim1j = GetDensity(-1,0); \n    float densijp1 = GetDensity(0,1); \n    float densijm1 = GetDensity(0,-1); \n    \n    // set outer boundary conditions\n    if(ijCoord.x ==  int(iResolution.x)-1)\n    {\n        uvip1j = uv;\n        densip1j = densij;\n    }\n    \n    if(ijCoord.x == 0)\n    {\n        uvim1j = 2.0*vec2(4.0*uvCoord.y*(1.0-uvCoord.y),0.0)-uv;\n        \n        for (int k = 1;k<=bandNb;k++)\n        {\n            if (uvCoord.y >= gapWidth*float(k)+bandWidth*float(k-1) && \n                uvCoord.y <=  gapWidth*float(k)+bandWidth*float(k))\n            {\n                densim1j = 2.0*1.0-densij;\n                break;\n            }\n            else\n            {\n            \tdensim1j =-densij;\n            }\n        }\n    }\n    if(ijCoord.y ==  int(iResolution.y)-1)\n    {\n        uvijp1 = -uv;\n        densijp1 = -densij;\n    }\n    \n    if(ijCoord.y == 0)\n    {\n        uvijm1 = -uv; \n        densijm1 = -densij; \n    }\n    \n    // set obstable boundary conditions\n    if(ijCoord.x == obsCoord.x-1 && ijCoord.y >= obsCoord.y && ijCoord.y <= obsCoord.w )\n    {\n        uvip1j = -uv; \n        densip1j = -densij; \n    }\n    if(ijCoord.x == obsCoord.z+1 && ijCoord.y >= obsCoord.y && ijCoord.y <= obsCoord.w )\n    {\n        uvim1j = -uv; \n        densim1j = -densij;\n    }\n    if(ijCoord.y == obsCoord.w+1 && ijCoord.x >= obsCoord.x && ijCoord.x <= obsCoord.z )\n    {\n        uvijm1 = -uv;\n        densijm1 = -densij;\n    }\n    if(ijCoord.y == obsCoord.y-1 && ijCoord.x >= obsCoord.x && ijCoord.x <= obsCoord.z )\n    {\n        uvijp1 = -uv; \n        densijp1 = -densij;\n    }\n    \n    \n    //should use more than 1 iteration...\n    //solve with jacobi for new velocity with laplacian\n    float coef = dt/(dxPow*reynold);\n    vec2 uvDiff = (uv+coef*(uvip1j+uvim1j+uvijp1+uvijm1))/(1.0+4.0*coef);\n \n    //should use more than 1 iteration...\n    //solve with jacobi for new velocity with laplacian\n    coef = kappa*dt/(dxPow);\n    densij = (densij+coef*(densip1j+densim1j+densijp1+densijm1))/(1.0+4.0*coef);\n \n    fragColor = vec4(uvDiff,densij,0);\n}","name":"Buf B","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"// solve for pressure\n\n// must be modified in all buffers and image\n// simulation parameters\nconst float dt = 1.0/400.0; //time-stepping\nconst vec2 force = vec2(2.0, 0.0); //constant pressure gradiant flow\nconst float reynold = 100.0; //constant defining the flow ~high=water, ~low=vscous\n\t\t\t\t\t\t\t //for karman, higher the better.\n\t\t\t\t\t\t\t //reynold an dt are \"coupled\" so modify both for accuracy.\n\nconst float kappa = 0.000005; //substance diffusion constant\nconst float alpha = 0.3; //substance dissipation rate\nconst int bandNb = 5; //number of die line\nconst int bandDens = 3; //density of die line (high mean less dense)\n\nconst int obsRadius = 10; //radius of obstacle\nconst vec2 obsPos = vec2(0.12,0.5); //positon (iResotution.xy*obsPos.xy)\n\n//macro\n#define GetVelocity(I,J) texelFetch( iChannel1, ijCoord+ivec2(I,J), 0 ).xy\n#define GetPressure(I,J) texelFetch( iChannel2, ijCoord+ivec2(I,J), 0 ).x\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    //set grid\n    float dx = 1.0 / iResolution.y;\n    float dxPow = dx *dx ;\n    vec2 uvCoord = dx*fragCoord.xy;\n    ivec2 ijCoord = ivec2(floor(fragCoord.xy));\n    \n    // set obstacle\n\tivec2 obsCenter = ivec2(floor(iResolution.xy*obsPos));\n    ivec4 obsCoord = ivec4(obsCenter-obsRadius, obsCenter+obsRadius);\n    \n    if (abs(ijCoord.x - obsCenter.x) <= obsRadius  &&  abs(ijCoord.y - obsCenter.y) <= obsRadius) \n    {\n    \tfragColor = vec4(0,0,0,0);\n        return;\n    } \n    \n    //to compute diveergence finite difference approximaton\n    vec2 uv = GetVelocity(0,0); // texture.x value of u this step\n    vec2 uvip1j = GetVelocity(1,0);\n    vec2 uvim1j = GetVelocity(-1,0);\n    vec2 uvijp1 = GetVelocity(0,1);\n    vec2 uvijm1 = GetVelocity(0,-1);\n    \n    vec2 uvijentry =  GetVelocity(-ijCoord.x,0);\n    vec2 uvijexit =  GetVelocity(-ijCoord.x+int(iResolution.x)-1,0);\n    \n    //to compute pressure finite difference approximaton\n    float p = GetPressure(0,0); // texture.x value of u this step\n    float pip1j = GetPressure(1,0);\n    float pim1j = GetPressure(-1,0);\n    float pijp1 = GetPressure(0,1);\n    float pijm1 = GetPressure(0,-1);\n    \n    float pijentry =  GetPressure(-ijCoord.x,0);\n    float pijexit =  GetPressure(-ijCoord.x+int(iResolution.x)-1,0);\n    \n    // set outer boundary conditions\n    if(ijCoord.x ==  int(iResolution.x)-1)\n    {\n        uvip1j = uv;\n        pip1j = p;\n    }\n    if(ijCoord.x == 0)\n    {\n        uvim1j =  2.0*vec2(4.0*uvCoord.y*(1.0-uvCoord.y),0.0)-uv;\n        pim1j = -p;\n    }\n    if(ijCoord.y ==  int(iResolution.y)-1)\n    {\n        uvijp1 = -uv;\n        pijp1 = p;\n    }\n    \n    if(ijCoord.y == 0)\n    {\n        uvijm1 =  -uv;\n        pijm1 = p;\n    }\n    \n    // set obstable boundary conditions\n    if(ijCoord.x == obsCoord.x-1 && ijCoord.y >= obsCoord.y && ijCoord.y <= obsCoord.w )\n    {\n        uvip1j = -uv;\n        pip1j = p;\n    }\n    if(ijCoord.x == obsCoord.z+1 && ijCoord.y >= obsCoord.y && ijCoord.y <= obsCoord.w )\n    {\n        uvim1j = -uv;\n        pim1j = p;\n    }\n    if(ijCoord.y == obsCoord.w+1 && ijCoord.x >= obsCoord.x && ijCoord.x <= obsCoord.z )\n    {\n        uvijm1 = -uv;\n        pijm1 = p;\n    }\n    if(ijCoord.y == obsCoord.y-1 && ijCoord.x >= obsCoord.x && ijCoord.x <= obsCoord.z )\n    {\n        uvijp1 = -uv;\n        pijp1 = p;\n    }\n    \n    // compute velocity divergence\n    float divergence = 0.5*(uvip1j.x-uvim1j.x+uvijp1.y-uvijm1.y)/dx;\n    \n    // should use more than 1 iteration...\n    // compute pressure (auxiliary) via jacobi iteration... \n    float phi = 0.25*((pip1j+pim1j)+(pijp1+pijm1)-dxPow*reynold*divergence/dt);\n        \n    fragColor = vec4(phi,0,0,0);\n}","name":"Buf C","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"// project for incompressibility\n\n// must be modified in all buffers and image\n// simulation parameters\nconst float dt = 1.0/400.0; //time-stepping\nconst vec2 force = vec2(2.0, 0.0); //constant pressure gradiant flow\nconst float reynold = 100.0; //constant defining the flow ~high=water, ~low=vscous\n\t\t\t\t\t\t\t //for karman, higher the better.\n\t\t\t\t\t\t\t //reynold an dt are \"coupled\" so modify both for accuracy.\n\nconst float kappa = 0.000005; //substance diffusion constant\nconst float alpha = 0.3; //substance dissipation rate\nconst int bandNb = 5; //number of die line\nconst int bandDens = 3; //density of die line (high mean less dense)\n\nconst int obsRadius = 10; //radius of obstacle\nconst vec2 obsPos = vec2(0.12,0.5); //positon (iResotution.xy*obsPos.xy)\n\n//macro\n#define GetVelocity(I,J) texelFetch( iChannel1, ijCoord+ivec2(I,J), 0 ).xy\n#define GetPressure(I,J) texelFetch( iChannel2, ijCoord+ivec2(I,J), 0 ).x\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    //set grid\n    float dx = 1.0 / iResolution.y;\n    float dxPow = dx *dx ;\n    vec2 uvCoord = dx*fragCoord.xy;\n    ivec2 ijCoord = ivec2(floor(fragCoord.xy));\n    \n    // set obstacle\n\tivec2 obsCenter = ivec2(floor(iResolution.xy*obsPos));\n    ivec4 obsCoord = ivec4(obsCenter-obsRadius, obsCenter+obsRadius);\n    \n    if (abs(ijCoord.x - obsCenter.x) <= obsRadius  &&  abs(ijCoord.y - obsCenter.y) <= obsRadius) \n    {\n    \tfragColor = vec4(0,0,0,0);\n        return;\n    } \n    \n    //to compute finite difference approximaton\n    vec2 uv = GetVelocity(0,0); \n    \n    //to compute finite difference approximaton\n    float p = GetPressure(0,0); // texture.x value of u this step\n    float pip1j = GetPressure(1,0);\n    float pim1j = GetPressure(-1,0);\n    float pijp1 = GetPressure(0,1);\n    float pijm1 = GetPressure(0,-1);\n    \n     // set outer boundary conditions\n    if(ijCoord.x ==  int(iResolution.x)-1)\n    {\n        pip1j = p;\n    }\n    if(ijCoord.x == 0)\n    {\n        pim1j = -p;\n    }\n    if(ijCoord.y ==  int(iResolution.y)-1)\n    {\n        pijp1 = p;\n    }\n    \n    if(ijCoord.y == 0)\n    {\n        pijm1 = p;\n    }\n    \n    // set obstable boundary conditions\n    if(ijCoord.x == obsCoord.x-1 && ijCoord.y >= obsCoord.y && ijCoord.y <= obsCoord.w )\n    {\n        pip1j = p;\n    }\n    if(ijCoord.x == obsCoord.z+1 && ijCoord.y >= obsCoord.y && ijCoord.y <= obsCoord.w )\n    {\n        pim1j = p;\n    }\n    if(ijCoord.y == obsCoord.w+1 && ijCoord.x >= obsCoord.x && ijCoord.x <= obsCoord.z )\n    {\n        pijm1 = p;\n    }\n    if(ijCoord.y == obsCoord.y-1 && ijCoord.x >= obsCoord.x && ijCoord.x <= obsCoord.z )\n    {\n        pijp1 = p;\n    }\n    \n    \n    //compute gradiant of pressure\n    vec2 pGrad = 0.5*vec2(pip1j-pim1j, pijp1-pijm1)/dx;\n    \n    //projection (helmholtz-hodge) to obtain divergence free\n    vec2 uvProj = uv-dt/reynold*pGrad;\n    \n    fragColor = vec4(uvProj,  0,0);\n}","name":"Buf D","description":"","type":"buffer"}]}