{"ver":"0.1","info":{"id":"NtsGzS","date":"1622318388","viewed":150,"name":"Slither Boy","username":"elitewalrus","description":"He slither.","likes":18,"published":1,"flags":0,"usePreview":0,"tags":["raymarch","sdf","shadows","snake","worm"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"int MAX_STEPS = 200; //max steps for raymarching algorithm\nfloat THRESHOLD = 0.001; //distance for which the ray marcher considers a surface to be hit\nfloat MAX_DISTANCE = 80.0; //the ray marcher will stop after this distance; no hit\nfloat NORMAL_DIFFERENTIAL = 0.0001; //a samll variation for gradient/normal approximations\nfloat SHADOW_MARCH_OFFSET = 0.001; //a small offset to prevent self intersection during the shadow march\nfloat SHADOW_SHARPNESS_FACTOR = 64.0; //how sharp the soft shadows should be\nfloat IMPLICIT_SURFACE_UNDERESTIMATION_FACTOR = 0.7; //controls convergence speed\n\n//not using AO for now\n#define AO_STEPS 0\nfloat AO_INTENSITY = 0.0;\nfloat AO_DIFFERENTIAL = 0.01;\n\nfloat hillInvAmplitude = 1.0; //inverse amplitude of the ground function\nfloat hillFrequency = 0.5; //the frequency of the ground function\n\nvec3 snakePos = vec3(0.0, 0.0, 0.0); //the root position of the snake's head\n\n//a slow way to get a translation-rotation transformation\nmat4 transform(vec3 translation, vec3 rotation) {\n\tfloat g = rotation.x;\n\tfloat b = rotation.y;\n\tfloat a = rotation.z;\n\n    mat4 roll = mat4( //transposed compared to standard math notation\n \t\tcos(a), sin(a), 0.0, 0.0, \t\t\n  \t\t-sin(a), cos(a), 0.0, 0.0, \t\t\n  \t\t0.0, 0.0, 1.0, 0.0, \t\t\n  \t\t0.0, 0.0, 0.0, 1.0  \t\t\t\n\t);\n    mat4 yaw = mat4( //transposed compared to standard math notation\n \t\tcos(b), 0.0, -sin(b), 0.0, \t\t\n  \t\t0.0, 1.0, 0.0, 0.0, \t\t\n  \t\tsin(b), 0.0, cos(b), 0.0, \t\t\n  \t\t0.0, 0.0, 0.0, 1.0  \t\t\t\n\t);\n\tmat4 pitch = mat4( //transposed compared to standard math notation\n \t\t1.0, 0.0, 0.0, 0.0, \t\t\n  \t\t0.0, cos(g), sin(g), 0.0, \t\t\n  \t\t0.0, -sin(g), cos(g), 0.0, \t\t\n  \t\t0.0, 0.0, 0.0, 1.0  \t\t\t\n\t);\n\n\n\tmat4 rot = pitch * yaw * roll;\n    rot[3] = vec4(translation, 1.0);\n    return rot;\n}\n\n//easy way to transform pos into a modified sdf space\nvec3 sdTransform(vec3 translation, vec3 rotation, vec3 pos) {\n    //transform pos instead of the sdf because the sdfs change in a complicated way\n    mat4 trans = inverse(transform(translation, rotation));\n    return vec3(trans*vec4(pos, 1.0));\n}\n\n//union of two sdfs (like OR)\nfloat sdUnion(float dist1, float dist2) {\n    return min(dist1,dist2);\n}\n\n//intersection of two sdfs (like AND)\nfloat sdIntersection(float dist1, float dist2) {\n    return max(dist1,dist2);\n}\n\n//subtraction of two sdfs (like AND but sdf1 is inside out)\nfloat sdSubtraction(float dist1, float dist2) {\n    return max(-dist1,dist2);\n}\n\n//smooth union of two sdfs\nfloat sdSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); \n}\n\n//smooth intersection of two sdfs\nfloat sdSmoothIntersection( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.0-h); \n}\n\n//smooth subtraction of two sdfs\nfloat sdSmoothSubtraction( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); \n}\n\n//sdf to sphere\nfloat sdSphere(vec3 pos) {\n    return length(pos) - 1.0;\n}\n\n//sdf to ellipsoid\nfloat sdEllipsoid(vec3 p, vec3 r){\n  float k0 = length(p/r);\n  float k1 = length(p/(r*r));\n  return k0*(k0-1.0)/k1;\n}\n\n//a function to represent the ground\nfloat groundFunction (vec3 pos) {\n    return sin(hillFrequency*pos.x) + \n    cos(hillFrequency*pos.z) + \n    -hillInvAmplitude*(pos.y );\n}\n\n//the gradient of the ground\nvec3 groundGradient (vec3 pos) {\n    return vec3(\n        hillFrequency*cos(hillFrequency*pos.x), \n        -hillInvAmplitude, \n        -hillFrequency*sin(hillFrequency*pos.z)\n    );\n}\n\n//the approximate signed distance to the ground (just an lower bound and not even an sdf)\nfloat sdGround(vec3 pos) {\n   float f = groundFunction(pos);\n   vec3 grad = groundGradient(pos);\n   return IMPLICIT_SURFACE_UNDERESTIMATION_FACTOR*abs(f)/length(grad);\n}\n\n//the sdf of the head of the snake. All done by trial and error there is no method to the mayhem\nfloat scene_head(vec3 pos){ \n    vec3 q = pos;\n    float head = sdSphere(q);\n    head = sdSmoothUnion(0.7*sdSphere((q-vec3(0.0,-0.3,-1.0))/0.7), head, 0.8);\n    head = sdSmoothSubtraction(2.0*sdSphere((q-vec3(0.0,2.1,0.4))/2.0), head, 0.3);\n    head = sdSmoothSubtraction(0.6*sdSphere((q-vec3(0.65,0.5,0.4))/0.6), head ,0.3);\n    head = sdSmoothSubtraction(0.6*sdSphere((q-vec3(-0.65,0.5,0.4))/0.6), head, 0.3);\n    head = sdSmoothUnion(0.5*sdSphere((q-vec3(-0.3,0.2,-0.3))/0.5), head, 0.3);\n    head = sdSmoothUnion(0.5*sdSphere((q-vec3(0.3,0.2,-0.3))/0.5), head, 0.3);\n    head = sdSmoothSubtraction(0.5*sdSphere((q-vec3(0.35,0.2,-0.2))/0.5), head ,0.05);\n    head = sdSmoothSubtraction(0.5*sdSphere((q-vec3(-0.35,0.2,-0.2))/0.5), head ,0.05);\n    return head;\n}\n\n//the sdf of the eyes of the snake\nfloat scene_eyes(vec3 pos) {\n    vec3 q = pos;\n    float eyes = 0.5*sdSphere((q-vec3(0.35,0.2,-0.2))/0.5);\n    eyes = sdUnion(0.5*sdSphere((q-vec3(-0.35,0.2,-0.2))/0.5), eyes);\n    eyes = sdSmoothSubtraction (0.2*sdSphere((q-vec3(0.4,0.3,0.1))/0.2), eyes, 0.15);\n    eyes = sdSmoothSubtraction (0.2*sdSphere((q-vec3(-0.4,0.3,0.1))/0.2), eyes, 0.15);\n    return eyes;\n}\n\n//the sdf of the pupils of the snake\nfloat scene_pupils(vec3 pos) {\n    vec3 q = pos;\n    float pupils = 0.3*sdSphere((q-vec3(0.4,0.3,-0.02))/0.3);\n    pupils = sdUnion(0.3*sdSphere((q-vec3(-0.4,0.3,-0.02))/0.3), pupils);\n    return pupils;\n}\n\n//the sdf of the body. This is extreamly slow.\nfloat scene_body(vec3 pos, vec3 rootPos){\n    #define segmentCount 48; \n    float segmentLength = 0.5;\n    float segmentWidth = 0.5;\n    float segmentOffsetFactor = 0.5;\n    vec3 root = vec3(0.0, 0.0, -1.0);\n     \n    float body = 1000000.0;\n    for(int i = 0; i < segmentCount i++) { \n        vec3 segmentPos = 2.0*segmentOffsetFactor*segmentLength*float(i)*vec3(0, 0.0, -1);\n        segmentPos += vec3(0, 0, 1) * snakePos;\n        segmentPos += root;\n        segmentPos.y = groundFunction(segmentPos) + segmentWidth;\n        \n        float segment = sdEllipsoid(vec3(pos - segmentPos), vec3(segmentWidth, segmentWidth, segmentLength));\n        body = sdSmoothUnion(body, segment, 0.6);\n    }\n    \n    return body;\n}\n\n//combine all the sdfs for the scene and use the distance to choose the right material id\n//returns vec2 sd where sd.x = distToScene and sd.y = materialID\nvec2 scene (vec3 pos) {\n\n    float ground = sdGround(pos);\n    \n    //slapped together bounding volume; hooray for longer worm.\n    if(pos.y> 5.0 || pos.y < -1.5 || pos.x < -3.0 || pos.x > 2.0 || pos.z > snakePos.z + 4.0) {\n        return vec2(ground, 1);\n    }\n    \n    //head rotation\n    vec3 groundGrad = groundGradient(snakePos);\n    float groundAngleX = acos(dot(groundGrad, vec3(0, 0, 1))/ length(groundGrad)) - 0.5*3.14;\n    float groundAngleZ = -acos(dot(groundGrad, vec3(1, 0, 0))/ length(groundGrad)) + 0.5*3.14;\n    \n    vec3 q = sdTransform(snakePos, vec3(groundAngleX, 0.0, groundAngleZ), pos);\n    float head = scene_head(q);\n    float eyes =  scene_eyes(q);\n    float pupils = scene_pupils(q);\n    float body = scene_body(pos, snakePos);\n    \n    //merge body and head\n    head = sdSmoothUnion(body, head, 0.3);\n\n    //find the shortest sd\n    float dist = min(head, ground);\n    dist = min(dist, eyes);\n    dist = min(dist, pupils);\n    //choose material id based on shortest distance\n    float objectID = -1.0;\n    if (dist >= head) { \n        objectID = 2.0;\n    }else if (dist >= eyes) {\n        objectID = 3.0;\n    }else if (dist >= pupils) {\n        objectID = 4.0;\n    }else {\n        objectID = 1.0;\n    }\n    \n    return vec2 (dist, objectID);\n}\n\n//aproximate normal to scene. Basically central differences method for the gradient\n//returns vec2 rayData where rayData.x = rayLength and rayData.y = materialID\nvec3 getNormal(vec3 pos) {\n    vec3 h = vec3 (NORMAL_DIFFERENTIAL, 0, 0);\n    \n    vec3 normal = vec3(\n        scene(pos + h.xyy).x - scene(pos - h.xyy).x,\n        scene(pos + h.yxy).x - scene(pos - h.yxy).x,\n        scene(pos + h.yyx).x - scene(pos - h.yyx).x\n    );\n\n    return normalize(normal);\n}\n\n//the raymarching algorithm\nvec2 Raymarch (vec3 ro, vec3 rd) {\n    vec2 sceneDistance = vec2 (0.0, -1.0);\n    for(int i = 0; i < MAX_STEPS; i++) {\n        vec3 rayPos = ro + sceneDistance.x*rd;\n        \n        vec2 localDistance = scene(rayPos);\n        if (localDistance.x < THRESHOLD) {\n            break;\n        }\n    \n        sceneDistance.x += localDistance.x;\n        sceneDistance.y = localDistance.y;\n        \n        if (sceneDistance.x > MAX_DISTANCE) {\n            break;\n        }\n    }\n    if(sceneDistance.x > MAX_DISTANCE) {\n        sceneDistance.x = -1.0;\n    }\n    \n    return sceneDistance;\n}\n\n//sdf ambient occlusion. Didn't play well with the implicit surface\nfloat AO (vec3 pos, vec3 normal) {\n    float ao = 0.0;\n    float dist = 0.0;\n    for(int i = 0; i < AO_STEPS; i++) {\n        dist = AO_DIFFERENTIAL * float(i);\n        ao += max (0.0, (dist - scene(pos + normal*dist).x)/dist);\n    }\n    return 1.0 - ao*AO_INTENSITY;\n}\n\nfloat softShadow (vec3 ro, vec3 rd) {\n    float penumbra = 1.0;\n\n    float sceneDistance = 0.0;\n    for(int i = 0; i < MAX_STEPS; i++) {\n        vec3 rayPos = ro + sceneDistance*rd;\n        \n        float localDistance = scene(rayPos).x;\n        \n        penumbra = min(penumbra, SHADOW_SHARPNESS_FACTOR*localDistance/sceneDistance);\n             \n        if (localDistance < THRESHOLD) {\n            break;\n        }\n        \n        sceneDistance += localDistance;\n        \n        if (sceneDistance > MAX_DISTANCE) {\n            break;\n        }\n    }\n    \n    return penumbra;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //normalized screen space coordinates\n    vec2 uv = (fragCoord - 0.5f*iResolution.xy)/iResolution.y;\n    \n    //snake pos \n    snakePos = vec3(0.0, 0.0, 3.0*iTime);\n    snakePos.y = groundFunction(snakePos) + 1.0;\n    \n    //choose a camera angle based on mouse position\n    float anglex = iMouse.xy==vec2(0) ? -0.2 : 10.0*iMouse.x/iResolution.x;\n    float angley = iMouse.xy==vec2(0) ? 5.75 : 10.0*iMouse.y/iResolution.y;\n    \n    //set the ray origin\n    float cameraDist = 12.0;\n    vec3 ro = vec3(cameraDist*sin(anglex), angley, cameraDist*cos(anglex)) + vec3(0.0, 0.0, snakePos.z);\n  \n    //lookat computations\n    vec3 target = snakePos;\n    vec3 w = normalize((target - ro));\n    vec3 u = normalize (cross(w, vec3(0, 1, 0)));\n    vec3 v = normalize (cross(u, w));\n   \n    //set the ray direction using the lookat values\n    vec3 rd = normalize(uv.x*u + uv.y*v + 1.0*w);\n    \n    //use blue gradient to color the sky\n    vec3 col = vec3(0.4, 0.75, 1.0) - 1.0*rd.y;\n    \n    //ray march\n    vec2 sceneDistance = Raymarch(ro, rd);\n    \n    if(sceneDistance.x > 0.0) {\n        //recover the ray\n        vec3 hitPosition = ro + sceneDistance.x*rd;\n        vec3 hitNormal = getNormal(hitPosition);\n        \n        //default material value\n        vec3 material = vec3(0.18);\n        \n        //use the material id to choose the material properies\n        if(sceneDistance.y == 1.0) { //the ground material\n            material = 0.18*vec3(0.129, 0.909, 0.137);\n            \n            //darken the color with sin to get stripes\n            float f = smoothstep(0.4, 0.5, 0.5 + 0.5*sin(6.0*hitPosition.z + 6.0*hitPosition.x));\n            material = mix (material, 0.8*material, f);\n        } else if (sceneDistance.y == 2.0) { //the snake skin material\n            material = 0.18*vec3(1.0, 0.564, 0.180);\n            \n            //darken the color with sin to get stripes\n            float f = smoothstep(0.4, 0.5, 0.5 + 0.5*sin(12.0*(hitPosition.z - snakePos.z)));\n            material = mix (material, 0.8*material, f);\n        } else if (sceneDistance.y == 3.0) { //the eye material\n            material = 0.18*vec3(1.0, 1.0, 1.0);\n        } else if (sceneDistance.y == 4.0) { //the snake pupil material\n            material = 0.18*vec3(0.03, 0.03, 0.03);\n        }\n        \n        //set a direction for the sun light\n        vec3 sunDirection = normalize(vec3(0.8, 0.4, 0.2));\n        \n        //light colors\n        vec3 sunColor = vec3(7.0, 4.5, 3.0);\n        vec3 skyColor = vec3(0.5, 0.8, 0.9);\n        vec3 bounceColor = vec3(0.7, 0.3, 0.2);\n        \n        //specular strengtho constant. Could be changed to be per material.\n        float specularStrength = 0.7;\n        \n        //directional light calculations. The bias for bounceDiffuse and skyDiffuse is in effect an ambient lighting layer\n        float sunDiffuse = clamp(dot(hitNormal, sunDirection), 0.0, 1.0);\n        float skyDiffuse = clamp(0.5 + 0.5*dot(hitNormal, vec3(0.0, 1.0, 0.0)), 0.0, 1.0);\n        float bounceDiffuse = clamp(0.5 + 0.5*dot(hitNormal, vec3(0.0, -1.0, 0.0)), 0.0, 1.0);\n        //specular according to the Phong model\n        float specular = pow(max(dot(rd, reflect(sunDirection, hitNormal)), 0.0), 32.0);\n        //sun showow is computed with a second ray march (a hit is any value not -1.0 so the step funtion is used)\n        float sunShadow = softShadow(hitPosition + SHADOW_MARCH_OFFSET*hitNormal, sunDirection);\n        \n        //calulate ambient occlusion\n        float ao = AO(hitPosition, hitNormal);\n        \n        //combine all the light calculations do get the final pixel color\n        col = material*ao*(\n            sunColor*sunDiffuse*sunShadow + \n            sunColor*specular*specularStrength +\n            skyColor*skyDiffuse + \n            bounceDiffuse*bounceColor\n        );\n    }\n    \n    //gamma correction. Standard value for the average monitor. Makes it easier to choose good colors\n    col = pow(col, vec3(0.4545)); \n    \n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}