{"ver":"0.1","info":{"id":"MljyRG","date":"1509467650","viewed":217,"name":"MyOwnHexagons (wip)","username":"FallenNode","description":"I don't know, a thing inspired by better work.","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["hexagonal"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Credit To: https://www.shadertoy.com/view/llSyDh\n//For inspiration and hexagon finding code\n\n// Helper vector. If you're doing anything that involves regular triangles or hexagons, the\n// 30-60-90 triangle will be involved in some way, which has sides of 1, sqrt(3) and 2.\nconst vec2 s = vec2(1, 1.7320508);\n\n// Standard vec2 to float hash - Based on IQ's original.\nfloat hash21(vec2 p){ return fract(sin(dot(p, vec2(141.173, 289.927)))*43758.5453); }\n\n\n// Standard 2D rotation formula.\nmat2 r2(in float a){ float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\n\n// The 2D hexagonal isosuface function: If you were to render a horizontal line and one that\n// slopes at 60 degrees, mirror, then combine them, you'd arrive at the following.\nfloat hex(in vec2 p){\n    \n    p = abs(p);\n    \n    // Below is equivalent to:\n    //return max(p.x*.5 + p.y*.866025, p.x); \n\n    return max(dot(p, s*.5), p.x); // Hexagon.\n    \n}\n\n// This function returns the hexagonal grid coordinate for the grid cell, and the corresponding \n// hexagon cell ID - in the form of the central hexagonal point. That's basically all you need to \n// produce a hexagonal grid.\n//\n// When working with 2D, I guess it's not that important to streamline this particular function.\n// However, if you need to raymarch a hexagonal grid, the number of operations tend to matter.\n// This one has minimal setup, one \"floor\" call, a couple of \"dot\" calls, a ternary operator, etc.\n// To use it to raymarch, you'd have to double up on everything - in order to deal with \n// overlapping fields from neighboring cells, so the fewer operations the better.\nvec4 getHex(vec2 p){\n    \n    // The hexagon centers: Two sets of repeat hexagons are required to fill in the space, and\n    // the two sets are stored in a \"vec4\" in order to group some calculations together. The hexagon\n    // center we'll eventually use will depend upon which is closest to the current point. Since \n    // the central hexagon point is unique, it doubles as the unique hexagon ID.\n    vec4 hC = floor(vec4(p, p - vec2(.5, 1))/s.xyxy) + .5;\n    \n    // Centering the coordinates with the hexagon centers above.\n    vec4 h = vec4(p - hC.xy*s, p - (hC.zw + .5)*s);\n    \n    // Nearest hexagon center (with respect to p) to the current point. In other words, when\n    // \"h.xy\" is zero, we're at the center. We're also returning the corresponding hexagon ID -\n    // in the form of the hexagonal central point. Note that a random constant has been added to \n    // \"hC.zw\" to further distinguish it from \"hC.xy.\"\n    //\n    // On a side note, I sometimes compare hex distances, but I noticed that Iomateron compared\n    // the Euclidian version, which seems neater, so I've adopted that.\n    return dot(h.xy, h.xy)<dot(h.zw, h.zw) ? vec4(h.xy, hC.xy) : vec4(h.zw, hC.zw + 9.43);\n    \n}\n\n// Dot pattern.\nfloat dots(in vec2 p){\n    \n\tp = abs(fract(p) - .5);\n    \n    return length(p); // Circles.\n    \n    //return (p.x + p.y)/1.5 + .035; // Diamonds.\n    \n    //return max(p.x, p.y) + .03; // Squares.\n    \n    //return max(p.x*.866025 + p.y*.5, p.y) + .01; // Hexagons.\n    \n    //return min((p.x + p.y)*.7071, max(p.x, p.y)) + .08; // Stars.\n    \n    \n}\n\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    // Aspect correct screen coordinates.\n\tvec2 u = (fragCoord - iResolution.xy*.5)/iResolution.y;\n    \n    // Scaling and moving the screen coordinates.\n    vec2 sc = u*4. + s.yx*iTime/8.;\n    \n    // Converting the scaled and translated pixels to a hexagonal grid cell coordinate and\n    // a unique coordinate ID. The resultant vector contains everything you need to produce a\n    // pretty pattern, so what you do from here is up to you.\n    vec4 h = getHex(sc); // + s.yx*iTime/2.\n    \n    // Storing the hexagonal coordinates in \"p\" to save having to write \"h.xy\" everywhere.\n    vec2 p = h.xy;\n\n    float cDist = length(p);\n    \n    // Using the idetifying coordinate - stored in \"h.zw,\" to produce a unique random number\n    // for the hexagonal grid cell.\n    float rnd = hash21(h.zw);\n    \n    // It's possible to control the randomness to form some kind of repeat pattern.\n    //rnd = mod(h.z + h.w, 2.);\n    \n    //Base Fade In-Out\n    vec3 col = vec3(cDist, 0., 0.);\n    col *= sin(iTime + rnd * 4.0) + 1.0;\n    \n    float sqrt3 = sqrt(3.);\n    float hexR = 0.56;\n    float hexA = mod(acos(dot(p, vec2(0., 1.))/cDist), 1.0472);\n    float hexDist = (sqrt3*hexR) / (sqrt3 * cos(hexA) + sin(hexA));\n    \n    col.x *= hash21(p);\n\n    if(cDist > hexDist) {\n        float lineX = mod(iTime, 100.0);\n        float lineAngle = sin(floor(iTime / 100.));\n        \n        if(mod((sc.x+lineX) + sc.y * lineAngle, 20.) < 1.) {\n            col = vec3(1.);\n        } else {\n            col.x = 1.;\n        }\n    }\n\n    \n    fragColor = vec4(col, 1.);\n}","name":"Image","description":"","type":"image"}]}