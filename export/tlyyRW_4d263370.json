{"ver":"0.1","info":{"id":"tlyyRW","date":"1610559469","viewed":147,"name":"SDF envelope","username":"Reynolds","description":"Tracing the envelope of the SDF.","likes":6,"published":1,"flags":32,"usePreview":0,"tags":["sdf","tracing","tracer","envelope"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS 100\n#define MIN_SURFACE_DIST 0.01\n#define MAX_DIST 100.0\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\n\nfloat get_dist(vec3 p)\n{\n    vec3 s = vec3(0, 1, 4);\n\n    vec3 r = s + vec3(sin(iTime), cos(iTime), sin(iTime));\n    vec3 t = r + vec3(cos(iTime),sin(iTime*2.0), sin(iTime*2.0));\n    float sd = sdCapsule(p, s, r, 0.025);\n    sd = min(sd, sdCapsule(p, r, t, 0.025));\n    \n    float pd = p.y+2.0;\n    return min(sd, pd);\n}\n\nvec3 get_normal(vec3 p)\n{\n\tvec2 e = vec2(0.01, 0);\n    float d = get_dist(p);\n    vec3 n = vec3(\n        d-get_dist(p-e.xyy),\n        d-get_dist(p-e.yxy),\n        d-get_dist(p-e.yyx)\n    );\n    return normalize(n);\n}\n\nfloat march(vec3 ro, vec3 rd)\n{\n    float total_dist = 0.0;\n    for(int i = 0; i < MAX_STEPS; i++)\n    {\n    \tvec3 p = ro + rd * total_dist;\n        float dist = get_dist(p);\n        total_dist += dist;\n        if(dist < MIN_SURFACE_DIST || total_dist > MAX_DIST)\n        {\tbreak;\t}\n    }\n    return total_dist;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //\tstart it off\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n\tvec3 col = vec3(0);\n\n    // light\n    vec3 light_center = vec3(0, 1, -6);\n    vec3 light_offset = vec3(\n    \t(sin(iTime) - 0.5) * 2.0,\n        0.0,\n        (cos(iTime) - 0.5) * 2.0);\n    vec3 light = light_center ;\n    \n    //\tfire a ray for each pixel\n    vec3 ro = vec3(0, 1, 0);\n    vec3 rd = normalize(vec3(uv.x, uv.y, 1));\n    \n     uv = (fragCoord)/iResolution.xy;\n    vec4 a = texture(iChannel0, uv);\n    \n    //\tmarch the ray\n\tfloat total_dist = march(ro, rd);\n    vec3 hit_pos = ro + rd * a.w;\n    \n    //\tlighting\n    vec3 to_cam = normalize(ro - hit_pos);\n    vec3 to_light = normalize(light - hit_pos);\n    vec3 normal = get_normal(hit_pos);\n\n    float b = max(dot(normal, to_light), 0.0);\n    \n    \n    \n    \n    uv = (fragCoord)/iResolution.xy;\n    //vec4 a = texture(iChannel0, uv);\n    \n    normal = vec3(a.xyz);\n    b = max(dot(normal, to_light), 0.0);\n\n    fragColor = vec4(vec3(b),1.0);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define MAX_STEPS 100\n#define MIN_SURFACE_DIST 0.01\n#define MAX_DIST 100.0\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdSphere(vec3 p, float r) {\n    return length(p) - r; \n}\n\nvec2 minA(vec2 a, vec2 b) {\n    \n    return vec2(min(a.x, b.x), mix(a.y, b.y, float(a.x < b.x))); \n}\n\nfloat get_dist(vec3 p)\n{\n    vec3 s = vec3(0, 1, 10);\n    float toi = iTime/2.5;\n    float toi2 = iTime;\n    vec3 r = s + 6.0*vec3(sin(toi), 0.25*cos(toi), 0.0);\n    vec3 t = r + 1.8*vec3(0.,cos(toi2), sin(toi2));\n    float sd = sdSphere(p - t, 0.25);     \n\n    toi += 6.28;\n    toi2 *= -1.0;\n    vec3 r2 = s + -6.0*vec3(sin(toi), 0.25*cos(toi), 0.0);\n    vec3 t2 = r2 + -1.8*vec3(0.,cos(toi2), sin(toi2));\n    float sd2 = sdSphere(p - t2, 0.25);     \n\n\n    return min(sd,sd2);\n}\n\nvec3 get_normal(vec3 p)\n{\n\tvec2 e = vec2(0.01, 0);\n    float d = get_dist(p);\n    vec3 n = vec3(\n        d-get_dist(p-e.xyy),\n        d-get_dist(p-e.yxy),\n        d-get_dist(p-e.yyx)\n    );\n    return normalize(n);\n}\n\nfloat march(vec3 ro, vec3 rd)\n{\n    float total_dist = 0.0;\n    for(int i = 0; i < MAX_STEPS; i++)\n    {\n    \tvec3 p = ro + rd * total_dist;\n        float dist = get_dist(p);\n        total_dist += dist;\n        if(dist < MIN_SURFACE_DIST || total_dist > MAX_DIST)\n        {\tbreak;\t}\n    }\n    return total_dist;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //\tstart it off\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n\tvec3 col = vec3(0);\n    \n    //\tfire a ray for each pixel\n    vec3 ro = vec3(0, 1, 0);\n    vec3 rd = normalize(vec3(uv.x, uv.y, 1));\n    \n    vec3 normal = vec3(0.0);\n    //\tmarch the ray\n\tfloat total_dist = march(ro, rd);\n    if(total_dist > MAX_DIST) {\n\n    } else {\n        vec3 hit_pos = ro + rd * total_dist;\n\n        //\tlighting\n        normal = get_normal(hit_pos);\n    }\n    \n    \n   \n    uv = (fragCoord)/iResolution.xy;\n    vec4 prev = texture(iChannel0, uv);\n    \n    if(iFrame == 0) {\n        fragColor = vec4(normal,total_dist); \n    } else if(total_dist > MAX_DIST) {\n       fragColor = prev;  \n    } else {\n       if(prev.w > total_dist) {\n           fragColor = vec4(normal, total_dist); \n       } else {\n           fragColor = prev;\n       }\n    }\n    //fragColor = vec4(normal,total_dist); \n}\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord)/iResolution.xy;\n\n    \n    int s = 1;\n    vec4 a = texture(iChannel0, uv);\n    vec4[4] ts;\n    ts[0] = texelFetch(iChannel0, ivec2(fragCoord.xy) + ivec2(s, 0), 0);\n    ts[1] = texelFetch(iChannel0, ivec2(fragCoord.xy) + ivec2(-s, 0), 0);\n    ts[2] = texelFetch(iChannel0, ivec2(fragCoord.xy) + ivec2(0, s), 0);\n    ts[3] = texelFetch(iChannel0, ivec2(fragCoord.xy) + ivec2(0, -s), 0);\n    \n    \n    //here I try to smooth the envelope by taking samples and averaging\n    //only if the distance to the camera is close enough\n    vec4 S = a;\n    float cnt = 1.0;\n    for(int i = 0; i< 4; ++i) {\n        if(abs(a.w - ts[i].w) < 0.5) {\n            S += ts[i];\n            cnt += 1.0;\n        }\n    }\n    S /= cnt;\n    \n    fragColor = S;\n}","name":"Buffer B","description":"","type":"buffer"}]}