{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"\n// two cool iq functions\nfloat sphere(vec3 p, float s) { return length(p) - s; }\nfloat smin(float a, float b, float k ) { float h = clamp(0.5 + 0.5 * (b - a) / k, 0.0, 1.0); return mix(b, a, h) - k * h * (1.0 - h); }\n\nfloat map(vec3 p) {\n\tfloat d = 10.;\n\tfloat t = iTime / 4.;\n\td = smin(d, sphere(p - vec3(cos(t * 1.3) * 1.5, 0.0, sin(t)), 0.5), 1.0);\n\td = smin(d, sphere(p + vec3(sin(t), cos(t * 2.1) * 1.5, cos(t * 0.6)), .7), 1.0);\n\td = smin(d, sphere(p + vec3(0.0), 1.0), 1.0);\n\td += cos((p.x + t) * 10.0) / 40.0;\n\td += sin(p.y * cos(t)) / 30.0;\n\td += cos(p.z * sin(t)) / 20.0;\n\treturn d;\n}\n\nfloat pIn(vec3 ro, vec3 rd) {\n\tfloat t = 0.0;\n\tfor (int i = 0; i < 100; i++) {\n\t\tfloat d = map(ro + rd * t);\n\t\tif (d <= 0.01) return t;\n\t\tt += d;\n\t}\n\treturn 0.0;\n}\n\nfloat pOut(vec3 ro, vec3 rd) {\n\tfloat t = 0.0;\n\tfor (int i = 0; i < 100; i++) {\n\t\tfloat d = map(ro + rd * t);\n\t\tif (d >= -0.01) return t;\n\t\tt += d;\n\t}\n\treturn 0.0;\n}\n\nvec3 normal(vec3 p) {\n\tfloat eps = 0.1;\n\treturn normalize(vec3(\n\t\tmap(p + vec3(eps, 0.0, 0.0)) - map(p - vec3(eps, 0.0, 0.0)),\n\t\tmap(p + vec3(0.0, eps, 0.0)) - map(p - vec3(0.0, eps, 0.0)),\n\t\tmap(p + vec3(0.0, 0.0, eps)) - map(p - vec3(0.0, 0.0, eps))\n\t));\n}\n\nfloat cao(vec3 p) {\n\tfloat ao = 0.0;\n\tfloat eps = 0.5;\n\tao += map(p + vec3(eps, eps, eps));\n\tao += map(p + vec3(eps, eps, -eps));\n\tao += map(p + vec3(eps,-eps, eps));\n\tao += map(p + vec3(eps, -eps, -eps));\n\tao += map(p + vec3(-eps, eps, eps));\n\tao += map(p + vec3(-eps, eps, -eps));\n\tao += map(p + vec3(-eps, -eps, eps));\n\tao += map(p + vec3(-eps, -eps, -eps));\n\treturn ao / (8.0 * eps);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy - 0.5;\n\tuv.x = uv.x * iResolution.x / iResolution.y;\n\t\n\tfloat cm = cos(iMouse.x / (iResolution.x / 8.0));\n\tfloat sm = sin(iMouse.x / (iResolution.x / 8.0));\n\t\n\tvec3 ro = vec3(0.0, 0.0, -5.0);\n\tvec3 ta = vec3(0.0);\n\tvec3 ww = normalize(vec3(ta - ro));\n\tvec3 uu = normalize(cross(ww, vec3(0.0, 1.0, 0.0)));\n\tvec3 vv = vec3(0.0, 1.0, 0.0);\n\tvec3 rd = normalize(uv.x * uu + uv.y * vv + ww);\n\tvec3 l1 = normalize(vec3(1.0 * sm, 1.0, .1 * cm));\n\tvec3 l2 = normalize(vec3(-1.0 * sm, -1.0, -1.0 * cm));\n\t\n\tfloat d = pIn(ro, rd);\n\tvec3 color = vec3(0.0);\n\t\n\tif (d > 0.0) {\n\t\tvec3 pi = ro + rd * d;\n\t\tvec3 ni = normal(pi);\n\t\tfloat spec1 = pow(max(0.0, dot(reflect(l1, ni), rd)), 80.0);\n\t\tfloat spec2 = pow(max(0.0, dot(reflect(l2, ni), rd)), 80.0);\n\t\tfloat spec = spec1 + spec2 / 2.0;\n\t\tvec3 peps = ro + rd * (d + 0.1);\n\t\tvec3 rn = reflect(rd, ni);\n\t\tfloat ao = cao(pi);\n\t\tvec3 bk = peps + ni * pOut(peps, -ni);\n\t\tfloat lm = dot(normalize(bk), l1) / (1.4 - distance(pi, bk) * 4.0);\n\t\tlm += dot(normalize(bk), l2) / (1.4 - distance(pi, bk) * 4.0);\n\t\tlm = min(1.0, lm);\n\t\tcolor = vec3(0.7, 0.5, 0.0) * ao + spec + (lm / 2.0);\n\t}\n\telse {\n\t\tfloat r = mod(uv.x, 0.2) > 0.1 ? 0.3 : 0.0;\n\t\tfloat g = mod(uv.y, 0.2) > 0.1 ? 0.2 : 0.0;\n\t\tcolor = vec3(r, g, 0.3) - length(uv / 3.0);\n\t}\n\n\tfragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"XdSGW3","date":"1393881881","viewed":1367,"name":"Translucent thing","username":"Pierco","description":"I don't know if it's the correct way to calculate translucency but it seems to work. Click and drag to rotate lights.","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["translucency"],"hasliked":0,"parentid":"","parentname":""}}