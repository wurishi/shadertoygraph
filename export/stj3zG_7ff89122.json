{"ver":"0.1","info":{"id":"stj3zG","date":"1624183884","viewed":420,"name":"Basic curve plotter","username":"Envy24","description":"Some setup for plotting curves in range x=[0, 1], y = [0, 1].\nTHIS WAS MY OLD PLOTTER AND IT WAS UGLY)\nBETTE PLOTTER HERE (highly recommended): https://www.shadertoy.com/view/stVcDz","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["bezier","curve","fade","plot","functions","interpolation","easing","gain"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define R              iResolution\n#define center(P)    ( (P+P-R.xy) / R.y )               // in range x=[-AR; AR], y=[-1.0; 1.0]\n#define MX           ( iMouse.x / R.x )                 // in range [0.0; 1.0]\n#define MY           ( iMouse.y / R.y )                 // in range [0.0; 1.0]\n#define FAR            9e30\n#define ZMX          ( (iMouse.x+iMouse.x-R.x) )        // in range [-iMouse.x; iMouse.x]\n#define ZMY          ( (iMouse.y+iMouse.y-R.y) )        // in range [-iMouse.y; iMouse.y]\n#define LMB_IS_HOLD  ( iMouse.z > 0.0 )\n\n/* See functions definitions is Common */\n\nfloat xAxis(vec2 p, float gray) { return abs(p.y) < 0.0024 ? 0.4 : gray; }\nfloat yAxis(vec2 p, float gray) { return abs(p.x) < 0.0024 ? 0.4 : gray; }\n\n\nfloat drawExplicitFuction(vec2 P)\n{   \n    float range = 2.0;\n    P *= range;\n\n    float xStep = (2.0 * range / R.x);\n    float xStart = -range;\n    int count = int(R.x);\n\n    float dist = FAR;\n\n    for (int c = 0; c < count; ++c)\n    {\n        float x = xStart + float(c) * xStep;\n        \n        vec2 C;\n        /* y = f(x) */    \n        C.x = x;         // x\n        C.y = x * x * x; // y = f(x)\n        /* f(x) */\n        \n        \n        \n        /* (x, y) = f(t). */\n        //C = quadraticBezier(vec2(0.5, 0.5), x); \n        //C = cubicBezier(vec2(0.0, 0.0), vec2(1.0, 1.0), x);\n        /* (x, y) = f(t). */\n\n\n        dist = min(dist, circleSQFSD(P, C, (range * 0.05) / R.y, (range * 0.06) / R.y));\n    }\n    \n    return 1.0 - dist;\n}\n\nfloat morph2(float t0, float t1, float morphSpeed) { return mix(t0, t1, (1.0 + sin(iTime * morphSpeed)) * 0.5); }\n\nfloat singleCurve(float u)\n{\n    float v = 0.5;\n    \n    //v = twoPeaksTransform(u);\n    //v = gain(0.3, u);\n    //v = smoothstep(0.0, 1.0, u);\n    //v = fadeCurve(u);\n    v = powerCurve(u, 2.0);\n    //v = easeInSine(u);\n    //v = easeOutSine(u);\n    //v = easeInOutSine(u);\n    //v = easeInQuad(u);\n    //v = easeOutQuad(u);\n    //v = easeInOutQuad(u);\n    //v = easeInCubic(u);\n    //v = easeOutCubic(u);\n    //v = easeInOutCubic(u);\n    //v = easeInQuart(u);\n    //v = easeOutQuart(u);\n    //v = easeInOutQuart(u);\n    //v = easeInQuint(u);\n    //v = easeOutQuint(u);\n    //v = easeInOutQuint(u);\n    //v = easeInExpo(u);\n    //v = easeOutExpo(u);\n    //v = easeInOutExpo(u);\n    //v = easeInCirc(u);\n    //v = easeOutCirc(u);\n    //v = easeInOutCirc(u);\n    //v = easeInBack(u);\n    //v = easeInBack(u);\n    //v = easeOutBack(u);\n    //v = easeInOutBack(u);\n    //v = easeInElastic(u);\n    //v = easeOutElastic(u);\n    //v = easeInOutElastic(u);\n    //v = easeInBounce(u);\n    //v = easeOutBounce(u);\n    //v = easeInOutBounce(u);\n\n    return v;\n}\n\n\n\nfloat drawImplicitFunction(vec2 P)\n{\n    float range = 1.0;\n    P *= range;\n\n    // p = (u, t).\n    vec2 C;\n    C.x = P.x;\n\n    // Single curve. p = (u, t).\n    //C.y = singleCurve(P.x);    \n    \n    \n    \n    /* Morphing two curves */\n    C.y = morph2(\n              twoPeaksTransform(P.x),\n              easeInOutBounce(P.x),\n              0.3);\n    // One more curve\n    C.y = morph2(C.y, fadeCurve(P.x), 0.6);\n    /* */\n    \n    return 1.0 - circleSQFSD(P, C, (range * 0.05) / R.y, (range * 0.06) / R.y);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 P )\n{\n    P -= LMB_IS_HOLD == true ? vec2(ZMX, ZMY) * 0.5 : vec2(-R.x, -R.y) * 0.25;\n    P = center(P);\n    \n    // Implicit of Explicit function?\n    //float gray = drawExplicitFuction(P);\n    float gray = drawImplicitFunction(P);\n            \n    gray = xAxis(P, gray); // f(x) = 0;\n    gray = yAxis(P, gray); // f(y) = 0;\n\n    // Output to screen\n    fragColor = vec4(gray);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define TAU 6.2831853071795862 // 2*PI\n#define PI 3.1415926535897932\n\n/* Signed distance of squared distances. \n   Should work faster without calculation square root. */\nfloat circleSQFSD(vec2 S, vec2 C,float r, float smoothness)\n{\n    // Sample coordinates relative to circle center.\n    float _x = S.x - C.x; float _y = S.y - C.y;\n    \n    // Signed distance of squares.\n    float sqs = _x * _x + _y *_y - r * r;\n    \n    //float ss = smoothness * smoothness;\n    \n    // Smoothstep interpolation.\n    return smoothstep(-smoothness, smoothness, sqs);\n    //return smoothstep(-ss, ss, sds * sds); // outline\n}\n\n/*\n    g in range (0.0; 1.0)\n    t in range [0.0; 1.0]\n*/\nfloat gain(const float g, const float t)\n{\n    // 1.0 / log(0.5) = 1.0 / -0.69314718055994529 = -1.4426950408889634;\n    \n    return \n        t < 0.5 ?\n        0.5 * pow(2.0 * t, log(1.0 - g) * -1.4426950408889634) :\n        1.0 - 0.5 * pow(2.0 - 2.0 * t, log(1.0 - g) * -1.4426950408889634);\n}\n\nfloat powerCurve(float t, float exponent)\n{\n    return \n        t < 0.5 ?\n        pow(2.0 * t, exponent) * 0.5 : \n        1.0 - pow(2.0 * (1.0 - t), exponent) * 0.5;\n}\n\n/*\n    t in range [0.0; 1.0]\n*/\nfloat twoPeaksTransform(float t)\n{\n    t = clamp(t, 0.0, 1.0) * 2.0 - 1.0;\n\n    return 0.5 * (1.0 + sin(4.71239 * t * t));\n}\n\nfloat fadeCurve(float t)\n{\n    return t * t* t* (10.0 - t * (15.0 - 6.0 * t));\n}\n\nvec2 cubicBezier_(float t, vec2 A, vec2 B, vec2 C, vec2 D)\n{\n    float f = (1. - t);\n    return f*f*(A*f + 3.*B*t) + t*t*(3.*C*f + D*t);\n}\nvec2 qudraticBezier(float t, vec2 A, vec2 B, vec2 C)\n{\n    float f = (1. - t);\n    return f*(A*f + 2.*B*t) + C*t*t;\n}\n\nvec2 quadraticBezier_(vec2 p, float t)\n{\n    float tSquare = t * t;\n    float oneMinusT = 1.0 - t;\n    float oneMinusTSquare = oneMinusT * oneMinusT;\n\n    vec2 begin = vec2(0.0, 0.0);\n    vec2 end = vec2(1.0, 1.0);\n\n    return vec2(\n        oneMinusTSquare * begin.x + 2.0 * oneMinusT * t * p.x + tSquare * end.x,\n        oneMinusTSquare * begin.y + 2.0 * oneMinusT * t * p.y + tSquare * end.y);\n}\n\nvec2 cubicBezier(vec2 p0, vec2 p1, float t)\n{\n    float tSquare = t * t;\n    float tCube = t * t * t;\n    float oneMinusT = 1.0 - t;\n    float oneMinusTSquare = oneMinusT * oneMinusT;\n    float oneMinusTCube = oneMinusT * oneMinusT * oneMinusT;\n\n    vec2 begin = vec2(0.0, 0.0);\n    vec2 end = vec2(1.0, 1.0);\n\n    return vec2(\n        oneMinusTCube * begin.x + 3.0 * oneMinusTSquare * t * p0.x + 3.0 * oneMinusT * tSquare * p1.x + tCube * end.x,\n        oneMinusTCube * begin.y + 3.0 * oneMinusTSquare * t * p0.y + 3.0 * oneMinusT * tSquare * p1.y + tCube * end.y);\n}\n\n/*\n    Easing functions. https://easings.net\n*/\nfloat easeInSine(float t) { return 1.0 - cos(t * PI * 0.5); }\nfloat easeOutSine(float t) { return sin((t * PI) * 0.5); }\nfloat easeInOutSine(float t) { return -(cos(PI * t) - 1.0) * 0.5; }\nfloat easeInQuad(float t) { return t * t; }\nfloat easeOutQuad(float t) { return 1.0 - (1.0 - t) * (1.0 - t); }\nfloat easeInOutQuad(float t) { return t < 0.5 ? 2.0 * t * t : 1.0 - ((-2.0 * t + 2.0) * (-2.0 * t + 2.0)) * 0.5; }\nfloat easeInCubic(float t) { return t * t * t; }\nfloat easeOutCubic(float t) { return 1.0 - (1.0 - t) * (1.0 - t) * (1.0 - t); }\nfloat easeInOutCubic(float t) { return t < 0.5 ? 4.0 * t * t * t : 1.0 - ((-2.0 * t + 2.0) * (-2.0 * t + 2.0) * (-2.0 * t + 2.0)) * 0.5; }\nfloat easeInQuart(float t) { return t * t * t * t; }\nfloat easeOutQuart(float t) { return 1.0 - (1.0 - t) * (1.0 - t) * (1.0 - t) * (1.0 - t) * (1.0 - t); }\nfloat easeInOutQuart(float t) { return t < 0.5 ? 8.0 * t * t * t * t : 1.0 - pow(-2.0 * t + 2.0, 4.0) * 0.5; }\nfloat easeInQuint(float t) { return t * t * t * t * t; }\nfloat easeOutQuint(float t) { return 1.0 - pow((1.0 - t), 5.0); }\nfloat easeInOutQuint(float t) { return t < 0.5 ? 16.0 * t * t * t * t * t : 1.0 - pow(-2.0 * t + 2.0, 5.0) * 0.5; }\nfloat easeInExpo(float t) { return t == 0.0 ? 0.0 : pow(2.0, 10.0 * t - 10.0); }\nfloat easeOutExpo(float t) { return t == 1.0 ? 1.0 : 1.0 - pow(2.0, -10.0 * t); }\nfloat easeInOutExpo(float t) { \n    return \n        t == 0.0 ?\n            0.0 : t == 1.0 ?\n                1.0 : t < 0.5 ?\n                    pow(2.0, 20.0 * t - 10.0) * 0.5 : (2.0 - pow(2.0, -20.0 * t + 10.0)) * 0.5; }\nfloat easeInCirc(float t) { return 1.0 - sqrt(1.0 - t * t); }\nfloat easeOutCirc(float t) { return sqrt(1.0 - (t - 1.0) * (t - 1.0)); }\nfloat easeInOutCirc(float t) { return t < 0.5 ? (1.0 - sqrt(1.0 - (2.0 * t) * (2.0 * t))) * 0.5 : (sqrt(1.0 - (-2.0 * t + 2.0) * (-2.0 * t + 2.0)) + 1.0) * 0.5; }\nfloat easeInBack(float t) {\n    const float c1 = 1.70158;\n    const float c3 = c1 + 1.0;\n    return c3 * t * t * t - c1 * t * t; }\nfloat easeOutBack(float t) {\n    const float c1 = 1.70158;\n    const float c3 = c1 + 1.0;\n    return 1.0 + c3 * (t - 1.0) * (t - 1.0) * (t - 1.0) + c1 * (t - 1.0) * (t - 1.0); }\nfloat easeInOutBack(float t) {\n    const float c1 = 1.70158;\n    const float c2 = c1 * 1.525;\n    return t < 0.5\n        ? (pow(2.0 * t, 2.0) * ((c2 + 1.0) * 2.0 * t - c2)) * 0.5\n        : (pow(2.0 * t - 2.0, 2.0) * ((c2 + 1.0) * (t * 2.0 - 2.0) + c2) + 2.0) * 0.5; }\nfloat easeInElastic(float t) {\n    const float c4 = (2.0 * PI) / 3.0;\n    return \n        t == 0.0 ? \n            0.0 : t == 1.0 ?\n                1.0 : -pow(2.0, 10.0 * t - 10.0) * sin((t * 10.0 - 10.75) * c4); }\nfloat easeOutElastic(float t) {\n    const float c4 = (2.0 * PI) / 3.0;\n    return \n        t == 0.0 ?\n            0.0 : t == 1.0 ?\n                1.0 : pow(2.0, -10.0 * t) * sin((t * 10.0 - 0.75) * c4) + 1.0; }\nfloat easeInOutElastic(float t) {\n    const float c5 = (2.0 * PI) / 4.5;\n    return \n        t == 0.0 ?\n        0.0 : t == 1.0 ?\n            1.0 : t < 0.5 ?\n                -(pow(2.0, 20.0 * t - 10.0) * sin((20.0 * t - 11.125) * c5)) * 0.5 :\n                (pow(2.0, -20.0 * t + 10.0) * sin((20.0 * t - 11.125) * c5)) * 0.5 + 1.0; }\nfloat easeOutBounce(float t) {\n    const float n1 = 7.5625;\n    const float d1 = 1.0 / 2.75;\n\n    int case_ = \n        int(t < 1.0 * d1) |\n        (int(t < 2.0 * d1) << 1) |\n        (int(t < 2.5 * d1) << 2);\n           \n    switch (case_)\n    {   \n    case 7: return n1 * t * t;\n    case 6: return n1 * (t -= 1.5 * d1) * t + 0.75;\n    case 4: return n1 * (t -= 2.25 * d1) * t + 0.9375;\n    \n    default: return n1 * (t - 2.625 * d1) * (t - 2.625 * d1) + 0.984375;\n    }\n}\nfloat easeInBounce(float t) { return 1.0 - easeOutBounce(1.0 - t); }\nfloat easeInOutBounce(float t) {\n    return \n        t < 0.5 ?\n            (1.0 - easeOutBounce(1.0 - 2.0 * t)) * 0.5 :\n            (1.0 + easeOutBounce(2.0 * t - 1.0)) * 0.5; }","name":"Common","description":"","type":"common"}]}