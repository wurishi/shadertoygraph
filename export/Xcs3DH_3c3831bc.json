{"ver":"0.1","info":{"id":"Xcs3DH","date":"1703023379","viewed":67,"name":"Clock with planetary gears","username":"KaleyGoode","description":"Clock with planetary gears, luminous hands and dial.\nUse the full-screen button!\nClick/tap the gold centre-cap to check out the lighting movement through 24 hours (watch the specular light).\nTap elsewhere on the backgound to return to normal.","likes":11,"published":1,"flags":0,"usePreview":0,"tags":["circles","gears","lines","clock","watch","steampunk","planetary"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Clock with planetary gears and Sunlight\n\n#define  pi 3.14159265359\n#define tau (2.*pi)\n\n// Clock (Aesthetic settings - radii are [0,1] relative to distance from centre to the biggest circle that fits in the canvas)\n#define    luminosity 1.3\n#define            fg vec3(.2)        // Foreground colour\n#define            fs vec3(.6,.0,.1)  // Foreground colour of second hand\n#define          gold vec3(.9,.7,.3)\n#define        clockR .98 // Clock outer radius\n#define         caseR .02\n#define    tickWeight .05\n#define    tickInner  .8  // Radius\n#define          sLen (tickInner+.03) // Second Hand Length [0,1] of the radius\n#define          mLen (sLen-.05)      // Minute Hand Length [0,1] of the radius\n#define          hLen (.7 * mLen)     //   Hour Hand Length [0,1] of the radius\n#define        hWidth (.2 * hLen)\n#define        mWidth (.7 * hWidth)\n#define        sWidth (.2 * mWidth)\n#define          capR       hWidth\n#define            p0 vec2(.0)        // Centre of clock face (a convenience for the line routine, not intended for positioning the clock)\n#define shadowBlur    .4 // For shadows [0,1]\n#define shadowOpacity .2 // For shadows [0,1]\n\n// Gears:\n#define      planets  3.\n#define  planetTeeth 28.\n#define    ringTeeth 70.\n#define     sunTeeth 14.\n#define carrierSpeed   .25\n#define  ribbonSpeed 15.\n#define   ringRadius   .85 // of the canvas height\n#define    pinRadius   .07\n#define  toothHeight   .1 // [.01, .15]\n#define  toothCurve   2.  // [.25, 3.]\n#define        zoom   2.  // 2. fills canvas height with a small border\n\n//__Helpers____________________________________________________________________________________\nfloat   Signed(float x)          {return 2.* x-1. ;} // Unsigned Unit Interval [ 0,1] to   Signed UI [-1,1]\nfloat Unsigned(float x)          {return .5*(x+1.);} //   Signed Unit Interval [-1,1] to Unsigned UI [ 0,1]\nfloat Lower   (float n, float t) {return clamp(n* t       ,0.,1.);} // if n=5, returns the lower fifth spread out to [0,1]\nfloat Upper   (float n, float t) {return clamp(n*(t-1.)+1.,0.,1.);} // t-(n-1)/n; if n=5, returns the upper fifth spread out to [0,1]\nfloat Upper3  (float n, float t) {return pow(Upper(n,t),3.);} // if n=5, the upper fifth is spread out to [0,1]. That result is then cubed and returned.\nfloat atan2   (float y, float x) {return (abs(x) < 0.00001) ? tau*sign(y) : atan(y,x);}\nfloat SphereZ (vec2 uv)          {return sqrt(abs(1.-dot(uv,uv)));}\n\nfloat Radii(float a, float n) {return abs(Signed(fract(n/tau*a+.5)));} // n radial peaks. fract creates a triangle wave [0,1); Signed makes that [-1,1); abs makes flat gaps as wide as the peaks; +.5 rotates to mark at the top\n\n// Values are unit intervals (relative to uv)\n// px is the current pixel coord (fragCoord)\n// p1,p2 are the start and end points of the line\nvoid line(inout vec3 color, vec3 lineColor, float alpha, float blur,              // Colour parameters\n                vec2 p1   , vec2 p2       , vec2  px   , float width, bool shape) { // Shape  parameters\n  vec2  h = px-p1, // Vector from current pixel to line start point (hypotenuse)\n        a = p2-p1; // Direction vector along line (adjacent)\n  float t = clamp(dot(h,a)/dot(a,a), 0.,1.), // Parametric t along line segment [0,1]\n        d = length(h - t*a),         // Distance from current pixel to line (length of opposite)\n       dw = fwidth(d)*(1.+10.*blur); // Antialiasing width\n       t = 1.-t;\n  if(shape && (length(a)>2.*width)) width *= .3+t*(1.5-1.3*t);smoothstep(.25, .5, t);//-smoothstep(4., .4, 1.5*t);\n//  if(shape && (length(a)>2.*width)) width *= smoothstep(1., .2, .7*t)-smoothstep(.9, 1.9, 1.5-t);\n  color = mix(color, lineColor, alpha*smoothstep(width+dw, width-dw, d));\n}\n\n//__Clock______________________________________________________________________________________\nbool spin = false; // Tap the centre cap to set, elsewhere to clear.\n\n// Centre cap of clock and planet gears: [https://www.shadertoy.com/view/XstyD8]\n#define Cap(UV,D,R) mix(.8*gold*Unsigned(30.*dot(UV,vSun)+SphereZ(UV/R)),color, smoothstep(-antialias, antialias, D-R))\n\n#define Hand(Ang, Fg, Len, Width, P0, shape)                                                       \\\n  dir = Len*vec2(sin(tau*Ang), cos(tau*Ang));                                                       \\\n  line(color, fg, shadowOpacity, shadowBlur,              p0, dir, p1,   Width, shape); /* Shadow */ \\\n  line(color, Fg,            1.,                      0., P0, dir, uv,   Width, shape);               \\\n  line(color, luminous,      .8, sWidth!=Width ? .4 : 0., P0, dir, uv,.4*Width, sWidth!=Width); // luminous line glows at night\n\nvoid Ribbon(inout vec3 color, float r1, float r2, float r, vec2 uv, bool clockwise) {\n  float  a = ribbonSpeed*iTime;\n  vec2  cw = vec2(sin(a),cos(a)); // Clockwise\n  vec2 dir = vec2(clockwise ? cw : cw.yx); // The .yx reverses the spin direction\n  float  t = Unsigned(r==0. ? .5 : dot(uv/r2,dir));\n  t  = Upper(3.,t); // Ribbon length is a third of the circle\n  t *= SphereZ(uv); // Spherical shading on the ribbons (more transparent at the circumference)\n  color = mix(color,gold, t);\n}\n\n//__Gear_______________________________________________________________________________________\nstruct Gear {\n  float gearR; // Gear radius\n  float diskR; // Inner or outer border radius\n  float teeth; // Tooth count\n  vec3  color; // Colour (input as background, output as uv fragColor)\n  float t;     // Time\n};\n\nvoid DrawGear(inout vec3 color, Gear g, vec2 uv, float antialias) {\n  float r = length(uv);\n  float a = atan(uv.y, uv.x);\n  float p = g.gearR // Gear polar function:\n          - .5*toothHeight // Make gears with internal or external teeth have the same thickness\n          + toothHeight / (1. + exp(toothCurve*sin(g.t + a*g.teeth)));\n  float gear = r-p;\n  float disk = r-g.diskR;\n  bool ring = (g.gearR < g.diskR);\n  //               Ring:              Pinions:\n  float t = ring ? max(disk, -gear) : max(-disk, gear);\n  float d = smoothstep(antialias,-antialias, t);\n  color = mix(color, g.color, d);\n  if(spin) {\n    float r1 = min(g.gearR, g.diskR);\n    float r2 = max(g.gearR, g.diskR);\n    if(ring) r1-=.5*toothHeight;\n    else     r2+=.5*toothHeight;\n    if((r1<r)&&(r<r2)) Ribbon(color, r1,r2,r, uv, g.teeth!=sunTeeth);\n  }\n}\n\n//__Main_______________________________________________________________________________________\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  float rPx = .5*min(iResolution.x, iResolution.y); // Radius in pixels\n  vec2   uv = (fragCoord.xy-.5*iResolution.xy)/rPx;\n\n  spin = (distance(iMouse.xy, .5*iResolution.xy)<(rPx * capR)); // Global boolean button state\n\n  float r = length(uv),\nantialias = length(fwidth(uv)),\n        a = atan2(uv.y, uv.x),\n        t = (spin ? 10000. : 1.) * iDate.w, // Current Time in seconds (Unix/Zulu/GMT)\n        s = mod(floor(t), 60.), // floor is optional (makes the second hand 'tick') s = mod(floor(t), 60.),\n        m = mod(t/ 60. ,  60.), // At full-screen, you should be able to see the minute hand slowly moving\n        h = mod(t/3600.,  24.),\n       sa = tau*h/24.,\n        c = cos(sa);\n  vec2 dir, // Direction vector for general usage\n       vSun = -vec2(sin(sa), c), // The 'Sun' rotates clockwise once every 24 hours\n         p1 = uv+capR*vSun; // Shadow is cast by the Sun position\n  vec3 color = fg, // FragColor accumulator\n    luminous = gold * vec3(luminosity, luminosity+Unsigned(cos(sa)), luminosity); // Oversaturated green with a touch of sun\n  float sun = dot(uv,vSun);\n  vec3 face = vec3(.9-.3*r*r+.2*sun);\n\n// Draw from back to front:\n\n// Background:\n  if(r>clockR-caseR) {\n    vec3 night = vec3(.2 ,.1,.1) + .2*sun,\n           day = vec3(.25,.3,.4) + .2*sun;\n         color = mix(day,night, cos(sa));\n    line(color, fg, shadowOpacity, shadowBlur, p0-capR*vSun, p0, p1, 1., false); // Clock shadow\n    if(r>rPx) { // Leave some background to overalias with, only return when away from the clock\n    fragColor = vec4(color,1.);\n    return;\n  } }\n\n// Clock Face\n   if(r<ringRadius+toothHeight) color = face; // No need to antialias, it's overdrawn by the ring gear\n\n// Planetary Gears\n  t = (spin ? 11. : 1.) * carrierSpeed*iTime;\n  const float scale = ringRadius / ringTeeth,\n       planetRadius =    scale * planetTeeth,\n          sunRadius =    scale *    sunTeeth,\n           sunSpeed = -planetTeeth,\n          ringSpeed =    ringTeeth+planetTeeth+sunTeeth,\n        planetSpeed =    ringTeeth,\n      carrierRadius =    ringRadius*(sunTeeth+planetTeeth)/ringTeeth,\n          ringOuter = .1+ringRadius;\n  Gear   ringGear   = Gear(  ringRadius,ringOuter ,  ringTeeth, gold, 0.);\n  Gear planetGear   = Gear(planetRadius, pinRadius,planetTeeth, gold, 0.);\n  Gear    sunGear   = Gear(   sunRadius, pinRadius,   sunTeeth, gold, 0.);\n  ringGear.t = ringSpeed*t; DrawGear(color, ringGear, uv, antialias);\n   sunGear.t =  sunSpeed*t; DrawGear(color,  sunGear, uv, antialias);\n  for(float i=1.; i<=planets; ++i) {\n    t += tau/planets; // Evenly-space the planet gears around the ring\n    planetGear.t = 4.*i+planetSpeed*t; // The 4xi sychronises the cogs\n    vec2 c = uv+carrierRadius*vec2(cos(t),sin(-t));\n    DrawGear(color, planetGear, c, antialias);\n    color=Cap(c, length(c), pinRadius); // Gear's axle cap\n  }\n\n// Hands drawn from back to front (h,m,s) shadow then hand\n  Hand(h/12., fg, hLen, hWidth, p0, true)               // Hour hand\n  if(!spin) {\n    Hand(m/60., fg, mLen, mWidth, p0, true)             // Minute hand\n    Hand(s/60., fs, sLen, sWidth, p0+(capR+2.*sWidth)*dir, false) // Second hand\n    color = mix(color, fs, smoothstep(.005+antialias,.005-antialias, abs(r-capR))); // Ring\n  }\n\n// Radial ticks:\n  if(r>tickInner) {\n    float t1  =                   Radii(60.,a), // 60 radial peaks. fract creates a triangle wave [0,1); Signed makes that [-1,1); abs makes flat gaps as wide as the peaks; +.5 rotates to mark at the top\n          t5  = smoothstep(.1,0., Radii(12.,a)),//  5 minute marks; smoothstep selects top (narrow) peak\n          t15 = smoothstep(.1,0., Radii( 4.,a)),// 15 minute marks; smoothstep selects top (narrow) peak\n            w = fwidth(t1);\n    t  = smoothstep(t5+tickWeight+w, t5+tickWeight-w, t1); // Select an aesthetic tick weight\n    t *= smoothstep(.85, .86, r+tickWeight*t5*t15);\n    t *= smoothstep(.95, .94, r); // Clip to the face (unless you like it looking like Sun rays!)\n    color = mix(color,luminous, t); // Ticks glow at night\n  }\n\n// Clock centre cap: [https://www.shadertoy.com/view/XstyD8]\n  color = Cap(uv,r,capR);\n\n// Glass cover:\n  if(r<clockR-caseR) {\n    a = atan2(vSun.y, vSun.x) - atan2(uv.y, uv.x) - .25*pi; // Adjusted because the original lighting is top left\n    uv = r*vec2(sin(a), cos(a)); // Where is the Sun\n    float x = uv.x, // x,y are Unsigned Unit Intervals [0,1]\n          y =-uv.y,\n          z = SphereZ(uv), // Get the third coordinate using a spherical model\n    ambient  = Upper3( 5., Unsigned(( 2.*x     +6.*z)/ 7. ))  // take the Upper fifth and spread it\n             + Upper3( 3., Unsigned((    x+4.*y+6.*z)/ 8.5)), // take the Upper third and spread it\n    specular = Upper3(15., Unsigned((-6.*x-3.*y+9.*z)/11.7))\n             + Upper3(17., Unsigned((-3.*x-6.*y+9.*z)/11.3));\n    color = .5*(specular+(1.5+ambient)*color); // No need to mix and antialias the border (it'll be overwritten by the clock case)\n  }\n\n// Clock case:\n  color = mix(1.5*gold*face,color, smoothstep(caseR-antialias, caseR+3.*antialias, abs(r-clockR+caseR))); // The 3* adds a little more blur\n\n  fragColor = vec4(color,1.);\n}\n","name":"Image","description":"","type":"image"}]}