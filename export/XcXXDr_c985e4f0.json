{"ver":"0.1","info":{"id":"XcXXDr","date":"1705169708","viewed":196,"name":"GM Shaders: Simplex Noise","username":"Xor","description":"Demo for shader tut\nhttps://mini.gmshaders.com/p/noise3","likes":13,"published":1,"flags":0,"usePreview":0,"tags":["noise","gradient","simplex","gmshaders"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n    \"Simplex Noise\" by @XorDev\n\n    Here's my updated implementation of the Simplex Noise algorithm for my tutorial:\n    https://mini.gmshaders.com/p/noise3\n\n    Source\n    https://en.wikipedia.org/wiki/Simplex_noise\n\n    Also see iq's implementation:\n    https://www.shadertoy.com/view/Msf3WH\n*/\n\n//vec2 signed white noise (ranging from -1.0 to +1.0)\nvec2 noise2(vec2 p)\n{\n    //Generate a pseudo random vec2 from p\n    return fract(sin(p * mat2(0.129898, 0.81314, 0.78233,  0.15926)) * 43758.5453);\n}\n\nfloat simplex_noise(vec2 p)\n{\n    //Skewing and \"unskewing\" constants as decribed here:\n    //https://en.wikipedia.org/wiki/Simplex_noise\n    //N = dimensions, in this case: 2\n    //Skewing factor for triangular grid\n    #define F 0.366025403784 //(sqrt(N+1.0)-1.0)/N\n    //Reverse skewing factor for square grid\n\t#define G 0.211324865405 //(1.0 - 1.0/sqrt(N+1.0))/N\n   \n    //Skew sample position to trianglular grid\n    vec2 skew = p+F*(p.x+p.y);\n    //Break into cells\n    vec2 cell = floor(skew);\n    //Subcell coordinates, same as fract(skew)\n    vec2 sub = skew - cell;\n    //Pick end vertex depending on what cell half the sample position is in.\n    vec2 end = sub.x>sub.y ? vec2(1,0) : vec2(0,1);\n    \n    //Positions relative to the nearest 3 points\n    vec2 p0 = cell-p-G*(cell.x+cell.y    )    ;\n    vec2 p1 = cell-p-G*(cell.x+cell.y+1.0)+end;\n    vec2 p2 = cell-p-G*(cell.x+cell.y+2.0)+1.0;\n    \n    //Square distances to points\n    float d0 = dot(p0,p0);\n    float d1 = dot(p1,p1);\n    float d2 = dot(p2,p2);\n    \n    //Compute gradient weights using distance to points\n    vec3 w = max(0.5 - vec3(d0, d1, d2), 0.0);\n    //Raise to 4th power\n    w *= w*w*w;\n    \n    //Compute gradients for each point\n    vec3 g;\n    g.x = dot(noise2(cell    )*2.0-1.0,p0);\n    g.y = dot(noise2(cell+end)*2.0-1.0,p1);\n    g.z = dot(noise2(cell+1.0)*2.0-1.0,p2);\n    \n    //Sum gradients with their weights\n    return 0.5+dot(g,w)*32.0;\n    //32 here is the noise contrast factor\n    //The weights are at most 1/16th, but 32 was an arbitrary pick\n}\n\n//Function demo\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord)\n{\n    //Compute 3x2 uv cells\n    vec2 uv = fragCoord / iResolution.xy * vec2(3,2);\n    \n    //Use scaled coordinates\n    vec2 coord = fragCoord/iResolution.y*10.0;\n    //Scroll horizontally\n    coord.x += iTime;\n    \n    //Initialize noise value\n    float noise = simplex_noise(coord);\n    \n    //Output noise\n    fragColor = vec4(noise);\n}","name":"Image","description":"","type":"image"}]}