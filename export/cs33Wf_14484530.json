{"ver":"0.1","info":{"id":"cs33Wf","date":"1677894293","viewed":96,"name":"rASSterizer","username":"LVutner","description":"rASSterizer.","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["ass"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n    rASSterizer. \n    \n    Probably the worst rasterizer you've ever seen.\n*/\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{ \n    //Some constants\n    vec2 device_resolution = iResolution.xy;\n    float fov = radians(67.5); //get the reference yo\n    float aspect = device_resolution.x / device_resolution.y;\n    float near = 0.2;\n    float far = 1000.0;\n    \n    //NDC\n    vec2 ndc = (fragCoord / device_resolution.xy) * 2.0 - 1.0;\n\n    //World/model matrix\n    //mat4 m_W = DeezNutsAddSomeRotationMatrixLater;\n    \n    //View matrix\n    mat4 m_V = createTranslationMatrix(vec3(0.0, 0.0, -2.0));\n    \n    //Projection Matrix\n    mat4 m_P = createProjectionMatrix(fov, aspect, near, far); \n   \n    //Model-View-Projection matrix\n    mat4 m_MVP = m_P * m_V;\n\n    //Buffer color\n    vec3 framebuffer = vec3(0.0, 0.0, 0.0) / 255.0;\n\n    //Iterate over vertices\n    for(int i = 0; i < vertices.length(); i += 3)\n    {\n        //Vertex->proj position\n        vec4 vl_Position_0 = m_MVP * vec4(vertices[i], 1.0);\n        vec4 vl_Position_1 = m_MVP * vec4(vertices[i + 1], 1.0);\n        vec4 vl_Position_2 = m_MVP * vec4(vertices[i + 2], 1.0);\n        \n        //Invert\n        vl_Position_0.w = 1.0 / vl_Position_0.w;\n        vl_Position_1.w = 1.0 / vl_Position_1.w;        \n        vl_Position_2.w = 1.0 / vl_Position_2.w;  \n        \n        //To NDC\n        vl_Position_0.xyz *= vl_Position_0.w;\n        vl_Position_1.xyz *= vl_Position_1.w;\n        vl_Position_2.xyz *= vl_Position_2.w;\n\n        //Vertex color\n        vec3 vl_Color_0 = color[i] * vl_Position_0.w;\n        vec3 vl_Color_1 = color[i + 1] * vl_Position_1.w;\n        vec3 vl_Color_2 = color[i + 2] * vl_Position_2.w;\n\n        //Texture coordinates\n        vec2 vl_TexCoord_0 = uv[i] * vl_Position_0.w;\n        vec2 vl_TexCoord_1 = uv[i + 1] * vl_Position_1.w;\n        vec2 vl_TexCoord_2 = uv[i + 2] * vl_Position_2.w;\n                        \n        //Triangle area\n        float area_ori = area(vl_Position_0.xy, vl_Position_1.xy, vl_Position_2.xy);\n\n        vec3 area_ndc;\n        {\n            area_ndc.x = area(ndc.xy, vl_Position_1.xy, vl_Position_2.xy);\n            area_ndc.y = area(vl_Position_0.xy, ndc.xy, vl_Position_2.xy);\n            area_ndc.z = area(vl_Position_0.xy, vl_Position_1.xy, ndc.xy);\n        }\n\n        //Barycentricsssssssss\n        vec3 bary = area_ndc / area_ori;\n\n        //This does work.\n        if(bary.x >= 0.0 && bary.y >= 0.0 && bary.z >= 0.0)\n        {\n            //Interpolated Z\n            float interpolated_z = bary.x * vl_Position_0.z + bary.y * vl_Position_1.z + bary.z * vl_Position_2.z;\n\n            //Interpolated W //remember we inverted it\n            float interpolated_w = 1.0 / (bary.x * vl_Position_0.w + bary.y * vl_Position_1.w + bary.z * vl_Position_2.w);\n      \n            //Interpolated color\n            vec3 color;\n            {\n                color.x = bary.x * vl_Color_0.x + bary.y * vl_Color_1.x + bary.z * vl_Color_2.x;\n                color.y = bary.x * vl_Color_0.y + bary.y * vl_Color_1.y + bary.z * vl_Color_2.y;\n                color.z = bary.x * vl_Color_0.z + bary.y * vl_Color_1.z + bary.z * vl_Color_2.z;\n                \n                //Fix the colors!!!!\n                color *= interpolated_w;\n            }\n\n            //Interpolated UVs\n            vec2 interpolated_uv = bary.x * vl_TexCoord_0 + bary.y * vl_TexCoord_1 + bary.z * vl_TexCoord_2;\n            interpolated_uv *= interpolated_w; //Perspective correction...\n\n            //GL_ZERO_TO_ONE-ish shit\n            if(interpolated_z >= 0.0 && interpolated_z <= 1.0)\n            {\n                framebuffer = color.xyz;\n            }\n        }\n    }\n      \n    //Gamma correction\n    framebuffer = pow(framebuffer, vec3(1.0 / 2.2));\n\n    //Output...\n    fragColor = vec4(framebuffer,1.0); \n}\n\n\n\n\n\n\n\n\n\n\n//Bruh.","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"//Vertex data...\n\n//Triangle points\nconst vec3 vertices[] = vec3[] (\n    vec3(-1.0, -1.0, 0.0),\n    vec3(0.0, 1.0, 0.0),\n    vec3(1.0, -1.0, 0.0)\n);\n\n//Vertex color\nconst vec3 color[] = vec3[] (\n    vec3(1.0, 0.0, 0.0),\n    vec3(0.0, 1.0, 0.0),\n    vec3(0.0, 0.0, 1.0)\n);\n\n//UVs\nconst vec2 uv[] = vec2[] (\n    vec2(0.0, 0.0),\n    vec2(0.0, 1.0),\n    vec2(1.0, 0.0)\n);\n\n//Fucking matrices\nmat4 createProjectionMatrix(float fov, float aspect, float near, float far)\n{\n\tfloat inv_tan_fov = 1.0 / tan(fov / 2.0);\n\t\n\treturn mat4(\n\t\tinv_tan_fov / aspect, 0.0, 0.0, 0.0,\n\t\t0.0, inv_tan_fov, 0.0, 0.0,\n\t\t0.0, 0.0, -(far + near) / (far - near), -1.0,\n\t\t0.0, 0.0, -2.0 * far * near / (far - near), 0.0\n\t);\n}\n\nmat4 createTranslationMatrix(vec3 xyz)\n{\n   return mat4(\n        vec4(1.0, 0.0, 0.0, 0.0),\n        vec4(0.0, 1.0, 0.0, 0.0),\n        vec4(0.0, 0.0, 1.0, 0.0),\n        vec4(xyz, 1.0));\n}\n\n//Fucking utilities\nfloat area(vec2 p0, vec2 p1, vec2 p2) \n{\n    return (p2.x - p0.x) * (p1.y - p0.y) - (p2.y - p0.y) * (p1.x - p0.x); \n}\n","name":"Common","description":"","type":"common"}]}