{"ver":"0.1","info":{"id":"MtXXW7","date":"1437043872","viewed":437,"name":"Ellipse - Distance III","username":"Antonalog","description":"yet another way to compute distance to an ellipse","likes":17,"published":1,"flags":0,"usePreview":0,"tags":["2d","distance","ellipse"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[],"code":"//newton's method in polar coordinates http://wwwf.imperial.ac.uk/~rn/distance2ellipse.pdf\n//but added a more stable choice of initial guess!\n\n//compare and constrast with these two...\n//https://www.shadertoy.com/view/4lsXDN\n//https://www.shadertoy.com/view/4sS3zz\n\n#define PI 3.1415927\n\nvec2 ClosestPointOnEllipse(vec2 p, vec2 ab)\n{\n\t//focal point of ellipse - either on x axis if a>b or y otherwise\n\tfloat c = ab.x > ab.y ? sqrt(ab.x*ab.x - ab.y*ab.y) : sqrt(ab.y*ab.y - ab.x*ab.x);\n\n\tfloat t = 0.;\n\tif (ab.y < ab.x && abs(p.x) < c)\n\t{\n\t\tt = p.y > 0. ? 0. * PI : -0.5 * PI;\n\t}\n\telse if (ab.x < ab.y && abs(p.y) < c)\n\t{\n\t\tt = p.x > 0. ? 0. : -PI;\n\t}\n\telse\n\t{\n\t\tt = atan(ab.x*p.y,ab.y*p.x);\n\t}\n\n\tfloat aa_bb = ab.x * ab.x - ab.y * ab.y;\n\tvec2 pab = p*ab;\n\tfor (int i=0; i<3; i++)\n\t{\n\t\tfloat sint = sin(t);\n\t\tfloat cost = cos(t);\n\t\tfloat ft = aa_bb * cost * sint - pab.x * sint + pab.y * cost;\n\t\tfloat dft = aa_bb * (cost * cost - sint * sint) - pab.x * cost - pab.y * sint;\n\n\t\tt = t - ft/dft;\n\t}\n\n\treturn vec2(cos(t),sin(t))*ab;\n}\n\nfloat sdEllipse(vec2 p, vec2 ab)\n{\n\tab = abs(ab);\n    p = -abs(p);\n\tvec2 closest = ClosestPointOnEllipse(p, ab);\n\n\tfloat dist = length(closest-p);\n\n\tvec2 poverab = p/ab;\n\tfloat inouttest = dot(poverab,poverab);\n\n\tif (inouttest > 1.) dist = -dist;\n\treturn dist;\n}\n\n//borrowed from iq\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = -1.0 + 2.0 * fragCoord.xy/iResolution.xy;\n\tuv.x *= iResolution.x/iResolution.y;\n\t\n    vec2 m = iMouse.xy/iResolution.xy;\n\tm.x *= iResolution.x/iResolution.y;\n\t\n\tfloat d = sdEllipse( uv, vec2(0.3,0.3)*m + vec2(1.0,0.5)  );\n\tvec3 col = clamp( abs(d), 0.0, 1.0 ) * (vec3(0.8) + vec3(-0.2,0.0,0.2)*sign(d) );\n\tcol = mix( col, vec3(1.0,0.5,0.1), 1.0-smoothstep(abs(d),0.0,0.003));\n\tcol *= 1.0 + 0.1*sin( 157.1*d );\n\n    // gradient / normal\n    //col = vec3( 0.5+0.5*normalize( vec2(dFdx(d), dFdy(d) ) ), 1.0 );\n    \n\tfragColor = vec4( col, 1.0 );\n}","name":"","description":"","type":"image"}]}