{"ver":"0.1","info":{"id":"ttByDz","date":"1684328852","viewed":100,"name":"Siri_Test","username":"MartinRGB","description":"siri  test","likes":1,"published":1,"flags":32,"usePreview":0,"tags":["siritest"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define STEPS 100.\n\n#define ENABLE_RADIAL_BLUR true\n\nvec4 blurEffect( sampler2D sourceImage, vec2 inUV, vec2 innerPoint ){\n    \n    float u_slot1 = (sin(iTime*2.) + 1.)/2.;\n    \n    vec2 targetVector = innerPoint - inUV;\n    float shineFactor = 1. - length(targetVector) / sqrt(1.); //0.005 + 0.5 * u_slot1\n    //shineFactor = 0.5 + u_slot1*0.5;\n    \n    //shineFactor*= (sin(iTime) +1.)/2.;\n    \n    vec4 result = texture(sourceImage, inUV);\n    \n    // Turn on to overlay blur over texture\n    bool textureOverlay = true;\n    \n    if(!textureOverlay)\n    \tresult = vec4(0.0);\n    \n    if(ENABLE_RADIAL_BLUR)\n        for(float dist = 0.0; dist < 1.0; dist += 2. / STEPS){\n\n            result += texture(sourceImage, inUV + targetVector * dist*1.) * shineFactor / STEPS;\n\n        }\n    else\n        result = texture(sourceImage,inUV);\n    \n    result.w = 1.;\n    return result;\n    \n}\n\n\n\n// Move mouse around to set inner point of radial blur!\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // Normalized inner point of radial blur\n    vec2 innerPoint = iMouse.xy / iResolution.xy; //vec2((sin(iTime)+1.)/2.,0.5);\n\n    //innerPoint = vec2(0.5 + 0.25*sin(iTime),0.5);\n    fragColor = blurEffect(iChannel0, uv, innerPoint);\n    //fragColor = texture(iChannel0,uv);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XdXGzn","filepath":"/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","previewfilepath":"/media/ap/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sfGzn","filepath":"/media/a/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png","previewfilepath":"/media/ap/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define MIN_FLOAT 1e-6\n#define MAX_FLOAT 1e6\n\nstruct Sphere{vec3 origin;float rad;};\nstruct Ray{ vec3 origin, dir;};\nstruct HitRecord{ float t; vec3 p;};\n\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord,float offset) {\n    vec2 xy = fragCoord - size *offset;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\nvec3 hash(vec3 x){\n\tx = vec3( dot(x,vec3(127.1,311.7, 74.7)),\n\t\t\t  dot(x,vec3(269.5,183.3,246.1)),\n\t\t\t  dot(x,vec3(113.5,271.9,124.6)));\n\n\treturn fract(sin(x)*43758.5453123);\n}\n\nbool sphere_hit(const in Sphere sphere, const in Ray inray, float t_min, float t_max, inout HitRecord rec) {\n    vec3 oc = inray.origin - sphere.origin;\n    float a = dot(inray.dir, inray.dir);\n    float b = dot(oc, inray.dir);\n    float c = dot(oc, oc) - sphere.rad*sphere.rad;\n    float discriminant = b*b - a*c;\n    if (discriminant > 0.) {\n        float temp = (-b - sqrt(discriminant))/a;\n        if (temp < t_max && temp > t_min) {\n            rec.t = temp;\n            rec.p = inray.origin + inray.dir * rec.t;\n            return true;\n        }\n    }\n    return false;\n}\n\nfloat noise( in vec3 p ){\n    vec3 i = floor( p );\n    vec3 f = fract( p );\n\t\n\tvec3 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( mix( dot( hash( i + vec3(0.0,0.0,0.0) ), f - vec3(0.0,0.0,0.0) ), \n                          dot( hash( i + vec3(1.0,0.0,0.0) ), f - vec3(1.0,0.0,0.0) ), u.x),\n                     mix( dot( hash( i + vec3(0.0,1.0,0.0) ), f - vec3(0.0,1.0,0.0) ), \n                          dot( hash( i + vec3(1.0,1.0,0.0) ), f - vec3(1.0,1.0,0.0) ), u.x), u.y),\n                mix( mix( dot( hash( i + vec3(0.0,0.0,1.0) ), f - vec3(0.0,0.0,1.0) ), \n                          dot( hash( i + vec3(1.0,0.0,1.0) ), f - vec3(1.0,0.0,1.0) ), u.x),\n                     mix( dot( hash( i + vec3(0.0,1.0,1.0) ), f - vec3(0.0,1.0,1.0) ), \n                          dot( hash( i + vec3(1.0,1.0,1.0) ), f - vec3(1.0,1.0,1.0) ), u.x), u.y), u.z );\n}\n\nvec3 hsv2rgb(vec3 c) {\n  // Íñigo Quílez\n  // https://www.shadertoy.com/view/MsS3Wc\n  vec3 rgb = clamp(abs(mod(c.x*6.+vec3(0.,4.,2.),6.)-3.)-1.,0.,1.);\n  rgb = rgb * rgb * (3. - 2. * rgb);\n  return c.z * mix(vec3(1.), rgb, c.y);\n}\n\nfloat fbm1x(float x, float time){\n\tfloat amplitude = 1.;\n    float frequency = 1.;\n    float y = sin(x * frequency);\n    float t = 0.01*(-time * 130.0);\n    y += sin(x*frequency*2.1 + t)*4.5;\n    y += sin(x*frequency*1.72 + t*1.121)*4.0;\n    y += sin(x*frequency*2.221 + t*0.437)*5.0;\n    y += sin(x*frequency*3.1122+ t*4.269)*2.5;\n    y *= amplitude*0.06;\n    return y;\n}\n\n\n\n#define MAX_MARCHING_STEPS 64\n\nfloat map(vec3 p){\n    //return texture(iChannel2,p.xy/3.+p.yz/3.+p.xz/3.).x/3. + texture(iChannel2,p.xy/3.+p.yz/3.+p.xz/3.).y/3. + texture(iChannel2,p.xy/3.+p.yz/3.+p.xz/3.).z/3.;\n    return noise(p + vec3(0., iTime, 0.));\n    //return texture(iChannel2,(p.yz + vec2(iTime,0.))).x;\n    //return texture(iChannel1,(p.xy/4. + p.yz/4. + p.xz/2. + vec2(0.,iTime)/2. + vec2(iTime,0.))/32.).x/3. + texture(iChannel1,(p.xy/4. + p.yz/4. + p.xz/2. + vec2(0.,iTime)/2. + vec2(iTime,0.))/32.).y/4. + texture(iChannel1,(p.xy/4. + p.yz/4. + p.xz/2. + vec2(0.,iTime)/2. + vec2(iTime,0.))/32.).z/4.;\n}\n\nvec3 render(in vec2 fragCoord){\n\tvec3 color = vec3(0.);\n    float scaleDownSize = 5.5;\n    float a = (iResolution.x - iTime*1.) * .05;\n    vec3 eye = vec3(4.5 * sin(a), 3., 4.5 * cos(a));\n    vec3 viewDir = rayDirection(45., iResolution.xy/scaleDownSize, fragCoord,0.5*scaleDownSize);\n    vec3 worldDir = viewMatrix(eye, vec3(0., 0., 0.), vec3(0., 10., 0.)) * viewDir;\n\t\n    Ray camRay = Ray(eye, worldDir);\n    HitRecord rec;\n    if(sphere_hit(Sphere(vec3(0.), 1.00001), camRay, MIN_FLOAT, MAX_FLOAT, rec)){\n\t\tvec3 sp;\n        float t=rec.t, layers=0., d, aD;\n        for(int i=0; i<MAX_MARCHING_STEPS; i++)\t{\n            sp = eye + worldDir * t;\n            d = map(sp);\n            if(abs(pow(d, 0.5) - min(pow(sp.y, 0.75), (.75 - pow(length(sp.xz), 64.)))) <= .05)\n            \t//color += hsv2rgb(vec3(fbm1x(d, iTime * .1 + 100.) * 3.1415, 1., 1.)) * .015;\n                color += hsv2rgb(vec3(0.56,0.,1.))*.015;\n            t += .01;\n        }\n        \n\t}\n    return color;\n}\n\n#define AA 1\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord ){\n    fragColor -= fragColor;\n    for(int y = 0; y < AA; ++y)\n        for(int x = 0; x < AA; ++x){\n            fragColor.rgb += clamp(render(fragCoord + vec2(x, y) / float(AA)), 0., 1.);\n        }\n    \n    fragColor.rgb /= float(AA * AA);\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    \n    //fragColor = vec4(vec3(noise(vec3(uv*100.,1.))),1.);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"#define BlendLinearDodgef               BlendAddf\n#define BlendLinearBurnf                BlendSubstractf\n#define BlendAddf(base, blend)          min(base + blend, 1.0)\n#define BlendSubstractf(base, blend)    max(base + blend - 1.0, 0.0)\n#define BlendLightenf(base, blend)      max(blend, base)\n#define BlendDarkenf(base, blend)       min(blend, base)\n#define BlendLinearLightf(base, blend)  (blend < 0.5 ? BlendLinearBurnf(base, (2.0 * blend)) : BlendLinearDodgef(base, (2.0 * (blend - 0.5))))\n#define BlendScreenf(base, blend)       (1.0 - ((1.0 - base) * (1.0 - blend)))\n#define BlendOverlayf(base, blend)      (base < 0.5 ? (2.0 * base * blend) : (1.0 - 2.0 * (1.0 - base) * (1.0 - blend)))\n#define BlendSoftLightf(base, blend)    ((blend < 0.5) ? (2.0 * base * blend + base * base * (1.0 - 2.0 * blend)) : (sqrt(base) * (2.0 * blend - 1.0) + 2.0 * base * (1.0 - blend)))\n#define BlendColorDodgef(base, blend)   ((blend == 1.0) ? blend : min(base / (1.0 - blend), 1.0))\n#define BlendColorBurnf(base, blend)    ((blend == 0.0) ? blend : max((1.0 - ((1.0 - base) / blend)), 0.0))\n#define BlendVividLightf(base, blend)   ((blend < 0.5) ? BlendColorBurnf(base, (2.0 * blend)) : BlendColorDodgef(base, (2.0 * (blend - 0.5))))\n#define BlendPinLightf(base, blend)     ((blend < 0.5) ? BlendDarkenf(base, (2.0 * blend)) : BlendLightenf(base, (2.0 *(blend - 0.5))))\n#define BlendHardMixf(base, blend)      ((BlendVividLightf(base, blend) < 0.5) ? 0.0 : 1.0)\n#define BlendReflectf(base, blend)      ((blend == 1.0) ? blend : min(base * base / (1.0 - blend), 1.0))\n\n// Component wise blending\n#define Blend(base, blend, funcf)       vec3(funcf(base.r, blend.r), funcf(base.g, blend.g), funcf(base.b, blend.b))\n\n#define BlendNormal(base, blend)        (blend)\n#define BlendLighten                    BlendLightenf\n#define BlendDarken                     BlendDarkenf\n#define BlendMultiply(base, blend)      (base * blend)\n#define BlendAverage(base, blend)       ((base + blend) / 2.0)\n#define BlendAdd(base, blend)           min(base + blend, vec3(1.0))\n#define BlendSubstract(base, blend)     max(base + blend - vec3(1.0), vec3(0.0))\n#define BlendDifference(base, blend)    abs(base - blend)\n#define BlendNegation(base, blend)      (vec3(1.0) - abs(vec3(1.0) - base - blend))\n#define BlendExclusion(base, blend)     (base + blend - 2.0 * base * blend)\n#define BlendScreen(base, blend)        Blend(base, blend, BlendScreenf)\n#define BlendOverlay(base, blend)       Blend(base, blend, BlendOverlayf)\n#define BlendSoftLight(base, blend)     Blend(base, blend, BlendSoftLightf)\n#define BlendHardLight(base, blend)     BlendOverlay(blend, base)\n#define BlendColorDodge(base, blend)    Blend(base, blend, BlendColorDodgef)\n#define BlendColorBurn(base, blend)     Blend(base, blend, BlendColorBurnf)\n#define BlendLinearDodge                BlendAdd\n#define BlendLinearBurn                 BlendSubstract\n\n#define BlendLinearLight(base, blend)   Blend(base, blend, BlendLinearLightf)\n#define BlendVividLight(base, blend)    Blend(base, blend, BlendVividLightf)\n#define BlendPinLight(base, blend)      Blend(base, blend, BlendPinLightf)\n#define BlendHardMix(base, blend)       Blend(base, blend, BlendHardMixf)\n#define BlendReflect(base, blend)       Blend(base, blend, BlendReflectf)\n#define BlendGlow(base, blend)          BlendReflect(blend, base)\n#define BlendPhoenix(base, blend)       (min(base, blend) - max(base, blend) + vec3(1.0))\n#define BlendOpacity(base, blend, F, O) (F(base, blend) * O + blend * (1.0 - O))\n\nfloat map(float value, float inMin, float inMax, float outMin, float outMax) {\n  return outMin + (outMax - outMin) * (value - inMin) / (inMax - inMin);\n}\n\nfloat roundRect(vec2 p, vec2 size, float radius) {\n  vec2 d = abs(vec2(p.x,p.y)) - vec2(size.x,size.y);\n  d.y /= iResolution.x/iResolution.y;  \n    \n  return min(max(d.x, d.y), 0.0) + length(max(d,0.0))- radius;\n}\n\nfloat smoothedge(float v) {\n    return smoothstep(0.0, 1.0 / iResolution.x, v);\n}\n\nfloat smoothedge1(float v,float before,float after) {\n    return smoothstep(before, after, v);\n}\n\n\nfloat sdEllipse( vec2 p, in vec2 ab )\n{\n\tp = abs( p ); if( ab.x > ab.y ){ p=p.yx; ab=ab.yx; }\n\t\n\tfloat l = ab.y*ab.y - ab.x*ab.x;\n\t\n    float m = ab.x*p.x/l; \n\tfloat n = ab.y*p.y/l; \n\tfloat m2 = m*m;\n\tfloat n2 = n*n;\n\t\n    float c = (m2 + n2 - 1.0)/3.0; \n\tfloat c3 = c*c*c;\n\n    float q = c3 + m2*n2*2.0;\n    float d = c3 + m2*n2;\n    float g = m + m*n2;\n\n    float co;\n\n    if( d<0.0 )\n    {\n        float h = acos(q/c3)/3.0;\n        float s = cos(h);\n        float t = sin(h)*sqrt(3.0);\n        float rx = sqrt( -c*(s + t + 2.0) + m2 );\n        float ry = sqrt( -c*(s - t + 2.0) + m2 );\n        co = ( ry + sign(l)*rx + abs(g)/(rx*ry) - m)/2.0;\n    }\n    else\n    {\n        float h = 2.0*m*n*sqrt( d );\n        float s = sign(q+h)*pow( abs(q+h), 1.0/3.0 );\n        float u = sign(q-h)*pow( abs(q-h), 1.0/3.0 );\n        float rx = -s - u - c*4.0 + 2.0*m2;\n        float ry = (s - u)*sqrt(3.0);\n        float rm = sqrt( rx*rx + ry*ry );\n        //co = (ry/sqrt(rm-rx) + 2.0*g/rm - m)/2.0;\n        co = min(0.999,(ry/sqrt(rm-rx) + 2.0*g/rm - m)/2.0);\n    }\n    \n    float si = sqrt( 1.0 - co*co );\n    vec2 r = ab * vec2(co,si);\n    return length(r-p) * sign(p.y-r.y);\n}\n\n\n//#define USE_APPROXIMATION\n#define PI 3.1415926\n// See: https://iquilezles.org/articles/ellipsoids\nfloat sdEllipsoidApproximated( in vec2 p, in vec2 r ) \n{\n    // # funny method \n    //r = r*0.01 + 0.15;\n    //r = vec2(pow(r.x,0.5),pow(r.y,0.5));\n    //r =  r + 0.1;\n    \n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n}\n\nvec4 ringImage( in float radius,in float borderWidth,in vec2 pos,in float radians,float blur,vec3 blurColor)\n{\n\tvec2 uv = -.5 + 1.0 * gl_FragCoord.xy/iResolution.xy;\n\tuv.x *= iResolution.x/iResolution.y;\n    \n    uv -= pos;\n\t\n    vec2 m = iMouse.xy/iResolution.xy;\n\tm.x *= iResolution.x/iResolution.y;\n    \n    //float radius = 0.2;\n    //float borderWidth = 0.2;\n\t\n    #ifdef USE_APPROXIMATION\n\tfloat d = sdEllipsoidApproximated( uv, vec2(radius + 0.003  - (((sin(iTime*2.))+1.)/2.*radius),radius));\n    d = sdEllipsoidApproximated(uv,vec2(radius - map(sin(radians),-1.,1.,0.003,0.001+radius)+0.0012 ,radius ));\n    #else\n    float d = sdEllipse(uv,vec2(radius - map(sin(radians),-1.,1.,0.003,0.001+radius)+0.0012 ,radius )); // map(sin(iTime*2. + radians),-1.,1.,0.003,0.001+radius)\n    //d = sdEllipse(uv,vec2(radius - 0.003,radius));\n    #endif\n    \n    //d = mix(d1,d2,0.5);\n    \n    #ifdef USE_APPROXIMATION\n \tfloat r = 1.0-smoothstep(borderWidth-borderWidth/2. ,borderWidth+borderWidth/2. ,abs(d));\n    float rBlur = 1.0-smoothstep(borderWidth-borderWidth/2.*blur ,borderWidth+borderWidth/2.*blur ,abs(d));\n    #else\n    float r = 1.0-smoothstep(borderWidth-borderWidth/2. ,borderWidth+borderWidth/2. ,abs(d));\n    float rBlur = 1.0-smoothstep(borderWidth-borderWidth/2.*blur ,borderWidth+borderWidth/2.*blur ,abs(d));\n    #endif\n    \n    vec4 col,colBlur;\n    \n    r = smoothedge1(r,0.2,1.);\n    \n\tcol = vec4(r);\n\tcolBlur = vec4(blurColor,pow(rBlur,1.5));\n    \n//     vec4 color = vec4(r);\n//     if(color.a <= 0.9999999){\n//         color.a = 0.;\n//     }\n//     else{\n        \n//     }\n    \n    if(col.a <= 0.001){\n        col = vec4(1.,1.,1.,0.);\n    }\n    else{\n        //col = mix(vec4(vec3(1.,0.,0.),1.),col,col.a);\n        \n    }\n    \n    //col += colBlur;\n    col = mix(colBlur,col,col.a);\n    \n\treturn col; //1.0 -abs(d)\n}\n\n#define TAU 6.2831852\n#define MOD3 vec3(.1031,.11369,.13787)\n#define BLACK_COL vec3(16,21,25)/255.\n\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * MOD3);\n    p3 += dot(p3, p3.yxz+19.19);\n    return -1.0 + 2.0 * fract(vec3((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y, (p3.y+p3.z)*p3.x));\n}\n\nfloat simplex_noise(vec3 p)\n{\n    const float K1 = 0.333333333;\n    const float K2 = 0.166666667;\n    \n    vec3 i = floor(p + (p.x + p.y + p.z) * K1);\n    vec3 d0 = p - (i - (i.x + i.y + i.z) * K2);\n        \n    vec3 e = step(vec3(0.0), d0 - d0.yzx);\n\tvec3 i1 = e * (1.0 - e.zxy);\n\tvec3 i2 = 1.0 - e.zxy * (1.0 - e);\n    \n    vec3 d1 = d0 - (i1 - 1.0 * K2);\n    vec3 d2 = d0 - (i2 - 2.0 * K2);\n    vec3 d3 = d0 - (1.0 - 3.0 * K2);\n    \n    vec4 h = max(0.6 - vec4(dot(d0, d0), dot(d1, d1), dot(d2, d2), dot(d3, d3)), 0.0);\n    vec4 n = h * h * h * h * vec4(dot(d0, hash33(i)), dot(d1, hash33(i + i1)), dot(d2, hash33(i + i2)), dot(d3, hash33(i + 1.0)));\n    \n    return dot(vec4(31.316), n);\n}\n\nvec4 ringFluid(in vec2 fragCoord){\n    vec2 uv = (fragCoord.xy-iResolution.xy*0.5)/iResolution.y;\n    uv *= 3.8;\n    \n    float a = sin(atan(uv.y, uv.x));\n    float am = abs(a-.5)/14.;\n    float l = length(uv);                         \n    \n    float m1 = clamp(.18/smoothstep(.0, 1.75, l), 0., 1.);\n    float m2 = clamp(.18/smoothstep(.42, 0., l), 0., 1.);\n    //float s1 = (simplex_noise(vec3(uv*2., 1. + iTime*1.525))*(max(1.0 - l*1.75, 0.)) + .9);\n    //float s2 = (simplex_noise(vec3(uv*1., 15. + iTime*1.525))*(max(.0 + l*1., .025)) + 1.25);\n    //float s3 = (simplex_noise(vec3(vec2(am, am*100. + iTime*3.)*.15, 30. + iTime*.525))*(max(.0 + l*1., .25)) + 1.5);\n    \n    float s1,s2,s3;\n    \n    s1 = texture(iChannel0,vec2(uv.x*2.,1.*(1. + iTime*1.525))).x*max(1.0 - l*1.75, 0.)+.9;\n    s2 = texture(iChannel0,vec2(15. + iTime*1.525,uv.y)).y*max(.0 + l*1., .025) + 1.25;\n    s3 = texture(iChannel0,vec2(am, am*100. + iTime*3.)*.15).z * (max(.0 + l*1., .25)) + 1.5;\n    \n    s1 = texture(iChannel0,vec2(uv.x*2.,1.*(1. + iTime*1.525))).x*max(1.0 - l*1.75, 0.)+.9;\n    s2 = texture(iChannel0,vec2(15. + iTime*1.525,uv.y)).y*max(.0 + l*1., .025) + 1.25;\n    s3 = texture(iChannel0,vec2(am, am*100. + iTime*3.)*.15).z * (max(.0 + l*1., .25)) + 1.5;\n    \n    \n    s3 *= smoothstep(0.0, .43345, l);  \n    //float s3 = 1.;\n    \n    float sh = smoothstep(0.15, .35, l);\n    \n    \n    float m = m1*m1*m2 * ((s1*s2*s3) * (1.5-l)) * sh;\n    //m = clamp(m, 0., 1.);\n    \n    //vec3 col = mix(BLACK_COL, (0.5 + 0.5*cos(iTime+uv.xyx*3.+vec3(0,2,4))), m);\n\t\n    vec3 col = vec3(1.,0.,0.)*m;\n    vec3 col2 = mix(BLACK_COL, (0.5 + 0.5*cos(iTime*4. + 3.14*0.25 +uv.xyx*3.+vec3(0,2,4))), m1*m1*m2);\n    \n    vec3 finCol = mix(col,col2,sin(iTime));\n    \n    \n    if(l> 4.2/4.2){\n       return vec4(0.,0.,0.,0.);\n    }\n    else{\n       return vec4(col2,1.- l);\n    }\n \n    \n}\n\n\nvec4 drawObjectColor(in vec2 uv,in vec2 fragCoord){\n    vec4 color,colorAdd;\n    vec4 colorC0,colorL1,colorL2,colorL3,colorR1,colorR2,colorR3;\n    \n    float u_slot1 = (sin(iTime*2.) + 1.)/2.;\n    float u_slot2 = (cos(iTime) + 1.)/2.;\n    u_slot2 = 1.;\n    u_slot1 = 0.;\n    float u_slot3 = 0.;\n    \n    vec3 blurColor = vec3(1.5);\n    vec3 blueColor = vec3(0.,0.,1.);\n    blurColor = mix(blurColor,blueColor,1.);\n    \n    float blurRadius = 5. + 4.*u_slot1;\n    \n    colorC0 = ringImage(0.09,0.01,vec2(0.,0.) + vec2(u_slot1*0.,0.),PI*1.5 - PI*u_slot1,blurRadius*u_slot3,blurColor);\n    colorL1 = ringImage(0.070 - u_slot1*0.02 + 0.02*u_slot2,0.015,vec2(0.,0.) + vec2(-u_slot1*0.1,0.),PI*1.5 - PI*u_slot1,blurRadius*u_slot3,blurColor);\n    colorL3 = ringImage(0.050 - u_slot1*0.048+ 0.04*u_slot2,0.015,vec2(0.,0.) + vec2(-u_slot1*0.3,0.),PI*1.5 - PI*u_slot1,blurRadius*u_slot3,blurColor);\n    colorL2 = ringImage(0.050 - u_slot1*0.03+ 0.04*u_slot2,0.015,vec2(0.,0.) + vec2(-u_slot1*0.2,0.),PI*1.5 - PI*u_slot1,blurRadius*u_slot3,blurColor);\n    colorR1 = ringImage(0.070 - u_slot1*0.02+ 0.02*u_slot2,0.015,vec2(0.,0.)+ vec2(u_slot1*0.1,0.),PI*1.5 - PI*u_slot1,blurRadius*u_slot3,blurColor);\n    colorR2 = ringImage(0.050  - u_slot1*0.03+ 0.04*u_slot2,0.015,vec2(0.,0.)+ vec2(u_slot1*0.2,0.),PI*1.5 - PI*u_slot1,blurRadius*u_slot3,blurColor);\n    colorR3 = ringImage(0.050 - u_slot1*0.048+ 0.04*u_slot2,0.001,vec2(0.,0.) + vec2(u_slot1*0.3,0.),PI*1.5 - PI*u_slot1,blurRadius*u_slot3,blurColor);\n    \n    vec4 ringFluid = ringFluid(fragCoord);\n\n    vec4 texCol = texture(iChannel1,uv)*4.;\n    //ringFluid.rgb *= mix(texCol.rgb,vec3(1.),(cos((iResolution.x + iTime*2.)) + 1.)/2.);\n    \n    color = mix(color,ringFluid,ringFluid.a);\n    \n    \n    //color = mix(color,colorR3,colorR3.a);\n    //color = mix(color,colorL3,colorL3.a);\n    //color = mix(color,colorR2,colorR2.a);\n    //color = mix(color,colorL2,colorL2.a);\n    //color = mix(color,colorR1,colorR1.a);\n    //color = mix(color,colorL1,colorL1.a);\n    color = mix(color,colorC0,colorC0.a);\n    \n    colorAdd = colorC0+colorL1+colorL2+colorL3+colorR1+colorR2+colorR3;\n\n   \n    \n    //color = mix(colorAdd,color,1. - u_slot1);\n    //color = colorAdd;\n    \n    return color;\n    \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    vec4 baseColor = vec4(117./255.,127./255.,143./255.,1.);\n    float d = roundRect(uv - vec2(0.5, 0.5), vec2(0.04, 0.07),0.06);\n    vec4 rectColor = vec4(vec3(smoothedge(d)),1. - smoothedge(d));\n    rectColor.rgb = vec3(39./255.,38./255.,56./255.);\n    baseColor = mix(baseColor,rectColor,rectColor.a);\n    \n    vec4 color = drawObjectColor(uv,fragCoord);\n    //color = mix(baseColor,color,color.a);\n    vec4 texCol = texture(iChannel1,uv)*4.;\n    //color = mix(texCol,color,color.a);\n    \n    color.rgb = BlendOverlay(color.rgb,texCol.rgb);\n    //color = mix(color,drawObjectColor(uv,fragCoord),drawObjectColor(uv,fragCoord).a);\n    \n    \n    fragColor =  color;\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[],"outputs":[{"id":"4sXGR8","channel":0}],"code":"\nvec3 hash(vec3 x){\n\tx = vec3( dot(x,vec3(127.1,311.7, 74.7)),\n\t\t\t  dot(x,vec3(269.5,183.3,246.1)),\n\t\t\t  dot(x,vec3(113.5,271.9,124.6)));\n\n\treturn fract(sin(x)*43758.5453123);\n}\n\nfloat noise( in vec3 p ){\n    vec3 i = floor( p );\n    vec3 f = fract( p );\n\t\n\tvec3 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( mix( dot( hash( i + vec3(0.0,0.0,0.0) ), f - vec3(0.0,0.0,0.0) ), \n                          dot( hash( i + vec3(1.0,0.0,0.0) ), f - vec3(1.0,0.0,0.0) ), u.x),\n                     mix( dot( hash( i + vec3(0.0,1.0,0.0) ), f - vec3(0.0,1.0,0.0) ), \n                          dot( hash( i + vec3(1.0,1.0,0.0) ), f - vec3(1.0,1.0,0.0) ), u.x), u.y),\n                mix( mix( dot( hash( i + vec3(0.0,0.0,1.0) ), f - vec3(0.0,0.0,1.0) ), \n                          dot( hash( i + vec3(1.0,0.0,1.0) ), f - vec3(1.0,0.0,1.0) ), u.x),\n                     mix( dot( hash( i + vec3(0.0,1.0,1.0) ), f - vec3(0.0,1.0,1.0) ), \n                          dot( hash( i + vec3(1.0,1.0,1.0) ), f - vec3(1.0,1.0,1.0) ), u.x), u.y), u.z );\n}\n\nfloat map(vec3 p){\n    return noise(p + vec3(0., iTime, 0.));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    float noiseVal = map(vec3(uv.x,uv.y,1.))/3. + map(vec3(uv.x,0.,uv.y))/3. + map(vec3(0.,uv.x,uv.y))/3.;\n    fragColor = vec4(vec3(noiseVal),1.0);\n    \n    //fragColor = texture(iChannel0,uv*3.);\n}","name":"Buffer C","description":"","type":"buffer"}]}