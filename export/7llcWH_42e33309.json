{"ver":"0.1","info":{"id":"7llcWH","date":"1648882212","viewed":392,"name":"Wired Skies","username":"Sumaleth","description":"My first ray-marching experiment!\n\nUpdate 2: more speed gains, small compile time gain.\n\nBig thanks to the incredible frameworks of iq and the tutorials of iq, Martijn (The Art of Code), and Electric Square.\n\nRef: https://tinyurl.com/2s493wmh (pwnisher)","likes":30,"published":1,"flags":0,"usePreview":1,"tags":["reproduction","photorealism"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PRECISION .002\n#define PI2 6.28319\n#define DEG2RAD .01745329251\n#define CAMDIST 5.3\n\n// materials\n#define mPOLE 0.\n#define mMETAL 1.\n#define mWIRE 2.\n#define mRUBBER 3.\n#define mBUNDLE 4.\n#define mLIGHT 5.\n#define mUNKNOWN 6.\n\n// options\n#define FASTNORMALS\n//#define MOUSESPIN\n//#define ANTIALIAS\n#define ANTIALIAS_SIZE 2.0   // valid values are 1.0 to 5.0, and don't use 5 unless you have a good GPU\n\n// optimizations\n#define ROT0 mat2(1.,0,0.,1.)\n#define ROT3 mat2(.99862953475,-.05233595624,.05233595624,.99862953475)\n#define ROT4 mat2(.99756405026,-.06975647374,.06975647374,.99756405026)\n#define ROT7 mat2(.99254615164,-.1218693434,.1218693434,.99254615164)\n#define ROT10 mat2(.98480775301,-.17364817766,.17364817766,.98480775301)\n#define ROT20 mat2(.93969262078,-.34202014332,.34202014332,.93969262078)\n#define ROT30 mat2(.86602540378,-.5,.5,.86602540378)\n#define ROT33 mat2(.83867056794,-.54463903501,.54463903501,.83867056794)\n#define ROT40 mat2(.76604444311,-.64278760968,.64278760968,.76604444311)\n#define ROT45 mat2(.70710678118,-.70710678118,.70710678118,.70710678118)\n#define ROT65 mat2(.42261826174,-.90630778703,.90630778703,.42261826174)\n#define ROT90 mat2(0.,-1.,1.,0.)\n#define ROT180 mat2(-1.,0.,0.,-1.)\n#define ROTm5 mat2(.99619469809,.08715574274,-.08715574274,.99619469809)\n#define ROTm6 mat2(.99452189536,.10452846326,-.10452846326,.99452189536)\n#define ROTm7 mat2(.99254615164,.1218693434,-.1218693434,.99254615164)\n#define ROTm20 mat2(.93969262078,.34202014332,-.34202014332,.93969262078)\n#define ROTm30 mat2(.86602540378,.5,-.5,.86602540378)\n#define ROTm40 mat2(.76604444311,.64278760968,-.64278760968,.76604444311)\n#define ROTm90 mat2(0.,1.,-1.,0.)\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat dot2( in vec3 v ) { return dot(v,v); }\n\nfloat hash( float n )\n{\n    return fract(sin(n)*158.5453123);\n}\n\nfloat noise( in vec2 x )\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n\n    f = f*f*(3.-2.*f);\n\n    float n = p.x + p.y*157.;\n\n    return mix(mix(hash(n+  0.),hash(n+  1.),f.x),\n               mix(hash(n+157.),hash(n+158.),f.x),f.y);\n}\n\nfloat smin( float d1, float d2, float k ) \n{\n    float h = clamp( .5+.5*(d2-d1)/k, 0., 1. );\n    return mix(d2,d1,h) - k*h*(1.-h); \n}\n\nfloat smax( float d1, float d2, float k ) \n{\n    float h = clamp( .5-.5*(d2-d1)/k, 0., 1. );\n    return mix(d2,d1,h) + k*h*(1.-h); \n}\n\n\n\nfloat opOnion( in float sdf, in float thickness )\n{\n    return abs(sdf)-thickness;\n}\n\n// https://www.shadertoy.com/view/ftfXDH (credit: rodolphito)\nfloat sdCircle( vec2 p, float r ) { return length(p) - r; }\nfloat map2d( in vec2 p, in float r) { return sdCircle(p, r); }\nfloat opRevolutionArc( in vec3 p, in float w, in float h, in vec2 c ) {\n    p.x = abs(p.x);\n    float l = length(p.xy);\n    p.xy = mat2(-c.x, c.y, \n                 c.y, c.x)*p.xy;\n    p.xy = vec2((p.y>0.0 || p.x>0.0)?p.x:l*sign(-c.x),\n                (p.x>0.0)?p.y:l );\n    p.y -= w;\n    \n    vec2 v = vec2( map2d( p.yz, h), p.x - h );\n  \treturn min(max(v.x,v.y),0.0) + length(max(v,0.0));\n}\n\n// https://www.shadertoy.com/view/Ns23RK\nfloat iBox(vec3 raypos, vec3 raydir, vec3 boxmin, vec3 boxmax)\n{\n    float t1 = (boxmin.x - raypos.x) / raydir.x;\n    float t2 = (boxmax.x - raypos.x) / raydir.x;\n    float t3 = (boxmin.y - raypos.y) / raydir.y;\n    float t4 = (boxmax.y - raypos.y) / raydir.y;\n    float t5 = (boxmin.z - raypos.z) / raydir.z;\n    float t6 = (boxmax.z - raypos.z) / raydir.z;\n\n    float tmin = max(max(min(t1, t2), min(t3, t4)), min(t5, t6));\n    float tmax = min(min(max(t1, t2), max(t3, t4)), max(t5, t6));\n/*\n    if (tmax < 0.0) // box on ray but behind ray origin\n    {\n        return -1.;\n    }\n*/\n    if (tmin > tmax) // ray doesn't intersect box\n    {\n        return -1.;\n    }\n\n    return tmin;\n}\n\n\n\n\n\n\n\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\nfloat sdRoundedCylinder( vec3 p, float ra, float rb, float h )\n{\n  vec2 d = vec2( length(p.xz)-2.0*ra+rb, abs(p.y) - h );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb;\n}\nvec2 sdStick(vec3 p, vec3 a, vec3 b, float r1, float r2)\n{\n    vec3 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn vec2( length( pa - ba*h ) - mix(r1,r2,h*h*(3.0-2.0*h)), h );\n}\n\nfloat sdCappedCone( vec3 p, float h, float r1, float r2 )\n{\n  vec2 q = vec2( length(p.xz), p.y );\n  vec2 k1 = vec2(r2,h);\n  vec2 k2 = vec2(r2-r1,2.0*h);\n  vec2 ca = vec2(q.x-min(q.x,(q.y<0.0)?r1:r2), abs(q.y)-h);\n  vec2 cb = q - k1 + k2*clamp( dot(k1-q,k2)/dot2(k2), 0.0, 1.0 );\n  float s = (cb.x<0.0 && ca.y<0.0) ? -1.0 : 1.0;\n  return s*sqrt( min(dot2(ca),dot2(cb)) );\n}\nfloat sdRoundCone( vec3 p, float r1, float r2, float h )\n{\n  // sampling independent computations (only depend on shape)\n  float b = (r1-r2)/h;\n  float a = sqrt(1.0-b*b);\n\n  // sampling dependant computations\n  vec2 q = vec2( length(p.xz), p.y );\n  float k = dot(q,vec2(-b,a));\n  if( k<0.0 ) return length(q) - r1;\n  if( k>a*h ) return length(q-vec2(0.0,h)) - r2;\n  return dot(q, vec2(a,b) ) - r1;\n}\n\nfloat sdEllipsoid( vec3 p, vec3 r )\n{\n  float k0 = length(p/r);\n  float k1 = length(p/(r*r));\n  return k0*(k0-1.0)/k1;\n}\n\nfloat sdSphere( vec3 p, float r )\n{\n    return length(p) - r;\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n\n\n\n\n\n\n\nfloat _cross(vec3 p)\n{\n    p -= vec3(.0,.105,.5);\n    float d20 = sdRoundBox(p, vec3(.015,.0025,.06), .003);\n    p.z -= .01;\n    float d21 = sdRoundBox(p, vec3(.05,.0025,.015), .003);\n    return smin(d20, d21, .005);\n}\n\nfloat _insulator(vec3 pos)\n{\n    vec3 p = abs(pos);\n    p.x -= .35;\n    p.yz *= ROT45;\n    float d = sdTorus(p, vec2(.5,.25));\n    p = pos;\n    p.xy *= ROT90;\n    float d2 = sdTorus(p, vec2(.5,.25));\n    d = smin(d, d2, .25);\n    \n    return d;\n}\n\nfloat _light(vec3 p, vec3 offset)\n{\n    float d = sdCappedCone(p, .15, .2, .1);\n    p.xy *= ROTm90;\n    float d4 = sdRoundedCylinder(p - vec3(-.2,0.,0.), .12, .12, .05);\n    d = smin(d,d4,.08);\n    float d10 = sdRoundBox(p - offset, vec3(1.,.025,1.),.0125);\n    d = smax(d10,d,.01);\n    \n    return d;\n}\n\nvec2 _peg(vec3 pos)\n{\n    float d1 = sdCapsule(pos, vec3(.0,.0,.0), vec3(-.23,.0,.0), .008);\n    float d2 = sdCapsule(pos, vec3(-.23,.0,.0), vec3(-.23,.04,.0), .008);\n    d1 = smin(d1, d2, .005);\n    \n    return vec2(d1, -1.);\n}\n\nfloat _runner(vec3 pos)\n{\n    float d = 1000000.;\n\n    pos.x = abs(pos.x);\n    float d10 = sdRoundBox(pos, vec3(.1,.02,.0125), .005);\n    d = min(d, d10);\n    vec3 p2 = pos;\n    p2.xy *= ROT10;\n    float d11 = sdRoundBox(p2 - vec3(0.,.025,0.), vec3(.1,.015,.0125), .005);\n    d = min(d, d11);\n    float d12 = sdSphere(pos - vec3(0.,.005,0.), 0.025);\n    d = min(d, d12);\n    float d13 = sdSphere(pos - vec3(.06,.005,0.), 0.025);\n    d = min(d, d13);\n    pos.y += .025;\n    float d14 = sdRoundBox(pos, vec3(.08,.0025,.006), .005);\n    d = min(d, d14);\n\n    return d;\n}\n\nfloat _smallPoleConnector(vec3 p, mat2 r1, mat2 r2)\n{\n    p.xz *= r1;\n    p.xy *= r2;\n        \n    float d = sdRoundBox(p, vec3(.03,.007,.04), .005);\n    p.x += .17;\n    float d2 = sdRoundBox(p, vec3(.03,.007,.04), .005);\n    d = min(d, d2);\n    vec3 p2 = p;\n    p2.x += .03;\n    float d3 = sdRoundBox(p2, vec3(.03,.009,.05), .005);\n    d = min(d, d3);\n    float d6 = sdCapsule(p, vec3(.18,.0,-.04), vec3(.18,.0,.04), .019);\n    d = min(d, d6);\n    \n    vec3 p3 = p;\n    p3.z = abs(p.z);\n    float d5 = sdCapsule(p3, vec3(.02,.0,.03), vec3(.17,.0,.03), .013);\n    d = min(d, d5);\n    float d7 = sdCapsule(p3, vec3(.18,.0,.04), vec3(.4,.0,.02), .01);\n    d = min(d, d7);\n    \n    p.x -= .38;\n    float d8 = sdRoundBox(p, vec3(.015,.007,.035), .005);\n    d = min(d, d8);\n    p.x -= .08;\n    float d9 = sdRoundBox(p, vec3(.05,.004,.03), .005);\n    d = min(d, d9);\n    p.x -= .06;\n    float d10 = sdRoundBox(p, vec3(.015,.007,.035), .005);\n    d = min(d, d10);\n    \n    return d;\n}\n\n\n\n\n\n\n\n\n\n\nfloat map_pole(in vec3 p, out float m)\n{\n    float d = sdStick(\n            p - sin(p.y*10.1)*vec3(1.,1.,0.)*.001 - cos(p.y*6.1)*vec3(1.,1.,0.)*.002,\n            vec3(1.8,-3.5,0),\n            vec3(1.8,3.5,0),\n            0.1,\n            0.1\n            ).x;\n    m = mPOLE;\n    return d;\n}\n\nfloat map_pegs(in vec3 pos, out float m)\n{\n    float d = 10000.;\n    m = mMETAL;\n    \n    {\n    vec3 p = pos - vec3(1.8, .0, .0);\n    p.y = mod(p.y+.25,.5);\n    p.y -= .125;\n    p.xz *= ROTm90;\n\n    float d1 = _peg(p).x; // TODO: not used?\n    p.xz *= ROT180;\n    p.y -= .25;\n    float d2 = _peg(p).x;\n    d = min(d,d2);\n    }\n    \n    // other peg\n    {\n    vec3 p = pos - vec3(1.8, 1., 0.);\n    p.xz *= ROT180;\n    float d1 = _peg(p).x;\n    d = min(d, d1);\n    }\n    \n    // other other peg\n    {\n    vec3 p = pos - vec3(1.8, 0.1, 0.);\n    p.xz *= ROT180;\n    float d1 = _peg(p).x;\n    d = min(d, d1);\n    }\n    \n    return d;\n}\n\n    \nfloat map_wirefrombottomofpole(in vec3 p, out float m)\n{\n    p -= vec3(1.8, .1, 0.);\n    p.xz *= ROT180;\n    p.y += cos(p.z*.5)*.6 - 0.6;\n\n    // stray wire\n    float d = sdCapsule(p, vec3(0.,0.,0.), vec3(0.,-2.5,4.), .003);\n    m=mWIRE;\n       \n    return d;\n}\n\nfloat map_fusebox(in vec3 p, out float m)\n{\n    vec3 boxoffset = vec3(1.67,-.55,.005);\n    p -= boxoffset;\n    p *= 1.7;\n    float d = sdRoundBox(p, vec3(.03,.2,.16), .005);\n    \n    p -= vec3(.025,.1,.11);\n    vec3 size = vec3(.005,.01,.01);\n    float d2 = -sdRoundBox(p, size, .0125);\n    d = max(d, d2);\n    p.y += .06;\n    float d3 = -sdRoundBox(p, size, .0125);\n    d = max(d, d3);\n    p.y += .06;\n    float d4 = -sdRoundBox(p, size, .0125);\n    d = max(d, d4);\n    p.y += .06;\n    float d5 = -sdRoundBox(p, size, .0125);\n    d = max(d, d5);\n    p.y += .06;\n    float d6 = -sdRoundBox(p, size, .0125);\n    d = max(d, d6);\n    \n    p -= boxoffset;\n    p *= 1.7;\n    float d9 = sdRoundBox(p - vec3(0.,.23,0.), vec3(.037,.03,.165), .005);\n    d = min(d, d9);\n    \n    m = mMETAL;\n    return d;\n}\n\nfloat map_wirestofusebox(in vec3 p, out float m)\n{\n    p -= vec3(1.705,.22,.05);\n    p.x -= sin(p.y*15.)*.005;\n    float d = sdCapsule(p, vec3(.0,.0,.0), vec3(.0,-2.0,.0), .004);\n    m = mBUNDLE;\n    \n    p -= vec3(-.001,-.72,.05);\n    p.x -= cos(p.y*25.)*.006;\n    p.z -= sin(p.y*45.)*.006;\n    float d2 = sdCapsule(p, vec3(.0,.0,.0), vec3(.0,-2.0,.0), .002);\n    if(d2<d) { d=d2; m=mWIRE; }\n    \n    return d;\n}\n\nfloat map_complexpoleconnection(in vec3 pos, out float m)\n{\n    float d = 10000.;\n    \n    {\n    vec3 boxoffset = vec3(2.02,1.5,0.);\n    vec3 p = pos - boxoffset;\n    p *= 1.5;\n    p.y -= -.4;\n\n    float d1 = _smallPoleConnector(p, ROT0, ROT0);\n    if(d1<d) { d=d1; m=mMETAL; }\n\n    vec3 p3 = p;\n    p3.z = abs(p.z);\n    float d11 = sdCapsule(p3, vec3(.0,.0,.04), vec3(.7,.0,.0), .004);\n    if(d11<d) { d=d11; m=mWIRE; }\n    float d12 = sdCapsule(p, vec3(.64,.0,-.005), vec3(1.7,.0,-.005), .004);\n    if(d12<d) { d=d12; m=mWIRE; }\n    float d13 = sdCapsule(p, vec3(1.35,.0,-.005), vec3(2.7,.0,-.005), .006);\n    if(d13<d) { d=d13; m=mWIRE; }\n    }\n    {\n    vec3 boxoffset = vec3(1.58,1.48,0.);\n    vec3 p = pos - boxoffset;\n    p *= 1.5;\n    p.y -= -.4;\n    \n    float d1 = _smallPoleConnector(p, ROT180, ROT4);\n    if(d1<d) { d=d1; m=mMETAL; }\n\n    vec3 p3 = p;\n    p3.z = abs(p.z);\n    float d11 = sdCapsule(p3, vec3(-.35,-.025,.04), vec3(-1.,-.08,.0), .004);\n    if(d11<d) { d=d11; m=mWIRE; }\n    float d12 = sdCapsule(p, vec3(-1.,-.08,.0), vec3(-2.,-.16,.0), .004);\n    if(d12<d) { d=d12; m=mWIRE; }\n    float d13 = sdCapsule(p, vec3(-2.,-.16,.0), vec3(-2.3,-.19,.0), .006);\n    if(d13<d) { d=d13; m=mWIRE; }\n    p3 = p;\n    p3.z = abs(p.z);\n    float d14 = sdCapsule(p3, vec3(-2.3,-.19,.0), vec3(-2.42,-.235,.04), .004);\n    if(d14<d) { d=d14; m=mWIRE; }\n    float d15 = sdCapsule(p3, vec3(-2.3,-.19,.0), vec3(-2.43,-.155,.04), .004);\n    if(d15<d) { d=d15; m=mWIRE; }\n    }\n \n    return d;\n}\n\nfloat map_insulator(in vec3 p, out float m)\n{\n    vec3 boxoffset = vec3(-.085,1.08,0.);\n    p -= boxoffset;\n    p.xy *= ROTm5;\n    p *= 15.;\n    float d = _insulator(p);\n    m = mMETAL;\n\n    p /= 15.;\n    p *= 1.5;\n    \n    // (wire continued from insulator)\n    p.z = abs(p.z);\n    float d14 = sdCapsule(p, vec3(-.05,-.05,.04), vec3(-.21,-.01,.0), .004);\n    if(d14<d) { d=d14; m=mWIRE; }\n    float d15 = sdCapsule(p, vec3(-.05,.05,.04), vec3(-.21,-.01,.0), .004);\n    if(d15<d) { d=d15; m=mWIRE; }\n\n    float d16 = sdRoundBox(p - vec3(-.21,-.01,.0), vec3(.01,.02,.02), .0005);\n    if(d16<d) { d=d16; m=mRUBBER; }\n\n    return d;\n}\n\nfloat map_insulatorwire(in vec3 p, out float m)\n{\n    m=mWIRE;\n    \n    vec3 boxoffset = vec3(-.085,1.08,0.);\n    p -= boxoffset;\n    p.xy *= ROTm5;\n    p *= 15.;\n    p /= 15.;\n    p *= 1.5;\n\n    float d = sdCapsule(p, vec3(-.21,-.01,.0), vec3(-.71,-.01,.0), .006);\n    float d18 = sdCapsule(p, vec3(-.71,-.01,.0), vec3(-30.,-.01,.0), .004);\n    if(d18<d) { d=d18; }\n    \n    return d;\n}\n\nfloat map_wirebelowinsulator(in vec3 pos, out float m)\n{\n    float y = -.35;\n    vec3 boxoffset1 = vec3(1.8,y + .84,.105);\n    vec3 boxoffset2 = vec3(2.25,y + .9,.105);\n\n    vec3 p = pos - boxoffset1;\n    p *= 2.;\n    \n    float d = _runner(p);\n    m=mMETAL;\n\n    // (in wire)\n    vec3 p3 = pos - boxoffset2;\n    p3.xy *= ROTm7;\n    p3 *= 1.5;\n    float d1 = sdCapsule(p3, vec3(-.71,-.01,.0), vec3(-30.,-.01,.0), .004);\n    if(d1<d) { d=d1; m=mWIRE; }\n    \n    // (out wire)\n    p3.xy *= ROT7;\n    float d2 = sdCapsule(p3, vec3(-.71,-.1,.0), vec3(10.,-.1,.0), .004);\n    if(d2<d) { d=d2; m=mWIRE; }\n\n    return d;\n}\n\nfloat map_andthewirebelowthat(in vec3 pos, out float m)\n{\n    float y = -.6;\n    vec3 boxoffset1 = vec3(1.8,y + .84,.105);\n    vec3 boxoffset2 = vec3(2.25,y + .9,.105);\n\n    vec3 p = pos - boxoffset1;\n    p *= 2.;\n    float d = _runner(p);\n    m = mMETAL;\n    \n    // (in wire)\n    vec3 p3 = pos - boxoffset2;\n    p3.xy *= ROTm7;\n    p3 *= 1.5;\n    float d1a = sdCapsule(p3, vec3(-.71,-.01,.0), vec3(-3.45,-.4,.0), .004);\n    if(d1a<d) { d=d1a; m=mWIRE; }\n    float d1b = sdCapsule(p3, vec3(-3.45,-.4,.0), vec3(-14.,-.5,.0), .004);\n    if(d1b<d) { d=d1b; m=mWIRE; }\n    \n    // (bundle to round thing)\n    vec3 p4 = p3;\n    p4.y -= sin(p4.x*5.)*.02;\n    float d3 = sdCapsule(p4, vec3(-4.05,-.42,.0), vec3(-14.,-.52,.0), .011);\n    p4 -= vec3(-.5,.0,-.5);\n    float d4 = sdTorus(p4 - vec3(-3.55,-.42,.0), vec2(.5,.011));\n    float d5 = sdRoundBox(p4 - vec3(-3.55,-.42,.0) + vec3(-1.,0.,-1.), vec3(1.,.5,1.), .003);\n    d4 = max(d4, d5);\n    d3 = smin(d3, d4, .001);\n    if(d3<d) { d=d3; m=mBUNDLE; }\n\n    // (out wire)\n    p3.xy *= ROT7;\n    float d2 = sdCapsule(p3, vec3(-.71,-.1,.0), vec3(10.,-.1,.0), .004);\n    d = min(d, d2);\n    if(d2<d) { d=d2; m=mWIRE; }\n\n    return d;\n}\n\nfloat map_light(in vec3 pos, out float m)\n{\n    float d = 100000.;\n    float pipeR = .03;\n    float arcR = .8;\n\n    vec3 savepos = pos - vec3(1.8,1.4,0.);\n\n    vec3 p0 = savepos;\n    p0.xz *= ROT65;\n    p0.xy *= ROTm40;\n    float d0a = sdRoundBox(p0 - vec3(.0,.2,-.03), vec3(.25,.0125,.005), .003);\n    if(d0a<d) { d=d0a; m=mMETAL; }\n    \n    p0.xy *= ROT40;\n    float d0b = sdRoundBox(p0 - vec3(-.09,.15,.0), vec3(.05,.02,.005), .003);\n    if(d0b<d) { d=d0b; m=mMETAL; }\n\n    float d0c = sdSphere(p0 - vec3(-.12,.15,.01), .011);\n    if(d0c<d) { d=d0c; m=mMETAL; }\n\n    p0.xy *= ROT90;\n    float d0d = sdRoundedCylinder(p0 - vec3(.0,-.1,-.005), .015, .015, .01 );\n    if(d0d<d) { d=d0d; m=mMETAL; }\n\n    vec3 p1 = savepos;\n    p1.xz *= ROT33;\n    float d1 = sdCapsule(p1, vec3(0.,0.,0.), vec3(-.6,0.,.31), pipeR);\n    if(d1<d) { d=d1; m=mMETAL; }\n\n    vec3 p2 = savepos - vec3(-1.05,0.,.23);\n    p2.xz *= ROT30;\n    p2.yz *= ROT90;\n    float d2 = opRevolutionArc(p2, arcR, pipeR, vec2(-.15,.1));\n    if(d2<d) { d=d2; m=mMETAL; }\n\n    \n    vec3 p3 = savepos - vec3(-1.26,-.02,1.06);\n    p3.xz *= ROT10;\n    p3.z *= 1.5;\n    p3.xy *= ROT90;\n    vec3 p4 = p3;\n    float l1 = _light(p3, vec3(0.,.025,0.));\n    p3 *= vec3(2.05,1.01,1.1);\n    float l2 = _light(p3, vec3(0.,-.025,0.));\n    float l = min(l1, l2);\n    if(l<d) { d=l; m=mMETAL; }\n    \n    \n    float l3 = sdRoundBox(p4 - vec3(-.01,0.,0.), vec3(.05,.05,.05), .003);\n    if(l3<d) { d=l3; m=mMETAL; }\n    float l4 = sdRoundBox(p4 - vec3(-.025,.125,0.), vec3(.04,.052,.06), .003);\n    if(l4<d) { d=l4; m=mMETAL; }\n\n    float d11 = sdRoundBox(p4 - vec3(-.13,-.11,0.), vec3(.04,.03,.01), .003);\n    if(d11<d) { d=d11; m=mMETAL; }\n    float d12 = sdEllipsoid(p4 - vec3(.02,-.2,0.), vec3(.1,.2,.19));\n    if(d12<d) { d=d12; m=mLIGHT; }\n    \n    float d14 = sdRoundBox(pos - vec3(.84,1.416,1.03), vec3(.01,.03,.01), .003);\n    if(d14<d) { d=d14; m=mMETAL; }\n\n    vec3 p6 = pos - vec3(.9,1.39,.95);\n    p6.xz *= ROTm20;\n    p6.yz *= ROT90;\n    p6.x += cos(pos.y*8.)*.08;\n    p6.y += sin(pos.x*5.)*cos(pos.z*3.)*.08;\n    float d15 = sdTorus(p6, vec2(.11,.003));\n    if(d15<d) { d=d15; m=mWIRE; }\n    \n    vec3 p7 = pos - vec3(.84,1.45,.97);\n    p7.xz *= ROTm30;\n    p7.yz *= ROT90;\n    p7.z += cos(pos.z*18.)*.03;\n    p7.y += sin(pos.x*25.)*cos(pos.z*21.)*.03;\n    float d16 = sdTorus(p7, vec2(.12,.003));\n    if(d16<d) { d=d16; m=mWIRE; }\n\n    return d;\n}\n\nfloat map_lightwire(in vec3 p, out float m)\n{\n    p.z += sin(p.z*3.)*.05;\n    p.x += cos(p.y*2.)*.08;\n    float d = sdCapsule(p, vec3(1.8,4.3,-.2), vec3(.78,1.43,1.05), .0015);\n    m = mWIRE;\n    \n    return d;\n}\n\nfloat map_nearverticallines(in vec3 p, out float m)\n{\n    p.xz *= ROT3;\n    \n    float d = sdCapsule(p, vec3(1.8+.4,4.,.5), vec3(1.8+.25,-0.6,-7.9), .005);\n    m = mWIRE;\n    float d2 = sdCapsule(p, vec3(1.8-.1,4.,.5), vec3(1.8-.04,-0.2,-7.5), .005);\n    if(d2<d) { d=d2; m=mWIRE; }\n    float d3 = sdCapsule(p, vec3(1.8+.6,4.,.5), vec3(1.8+.4,-0.3,-7.9), .005);\n    if(d3<d) { d=d3; m=mWIRE; }\n    float d4 = sdCapsule(p, vec3(1.8-.6,4.5,.5), vec3(1.8-.6,2.4,-2.8), .005);\n    float d5 = sdCapsule(p, vec3(1.8-.6,2.4,-2.8), vec3(1.8-.6,1.6,-4.3), .005);\n    d4 = smin(d4, d5, .01);\n    float d6 = sdCapsule(p, vec3(1.8-.6,1.6,-4.3), vec3(1.8-.6,-0.1,-7.3), .005);\n    d4 = smin(d4, d6, .01);\n    if(d4<d) { d=d4; m=mWIRE; }\n    \n    p.z += sin(p.z*10.)*.05;\n    p.y += sin(p.z*15.)*cos(p.y)*0.03;\n    p.x += cos(p.y*11.)*0.02;\n    float d7 = sdCapsule(p, vec3(1.8-.1,4.3,.5), vec3(1.8-.34,-2.9,-12.5), .011);\n    if(d7<d) { d=d7; m=mBUNDLE; }\n\n    return d;\n}\n   \nfloat map_largeroundthing(in vec3 pos, out float m)\n{\n    float d = 10000.;\n    vec3 p = pos - vec3(.0,-.35,-.41);\n    \n    vec3 p1 = p;\n    p1.yz *= ROTm90;\n    p1.y = abs(p1.y);\n    float d1 = sdRoundedCylinder(p1 - vec3(.0,.15,.0), .04, .005, .1445);\n    float d2 = opOnion(sdRoundedCylinder(p1 - vec3(.0,.33,.0), .036, .005, .02),.007);\n    d2 = smax(d2, p1.y - .325, .01);\n    d2 = min(d1, d2);\n\n    vec3 p2 = p;\n    p2.xz *= ROT90;\n    p2.yz *= ROT90;\n    p2.x = abs(p2.x);\n    float d3 = sdRoundedCylinder(p2 - vec3(.22,.0,-.08), .015, .005, .006);\n    float d4 = sdRoundBox(p2 - vec3(.0,.0,-.075), vec3(.25,.006,.01), .003);\n    d3 = smin(d3, d4, .005);\n    d2 = smin(d2, d3, .005);\n    if(d2<d) { d=d2; m=mMETAL; }\n\n    vec3 p3 = p;\n    p3.xy *= ROT45;\n    p3.z = abs(p3.z);\n    float d5 = sdRoundBox(p3 - vec3(.0,.09,.2), vec3(.003,.02,.01), .003);\n    if(d5<d) { d=d5; m=mRUBBER; }\n\n    return d;\n}\n\nfloat map_largeroundthingwiresetc(in vec3 pos, out float m)\n{\n    float d = 10000.;\n    vec3 p = pos - vec3(.0,-.35,-.41);\n\n    // (wire out)\n    vec3 p4 = p;\n    p4.y -= smoothstep(-.3,-.6,p4.z)*.1;\n    float d10 = sdCapsule(p4, vec3(.0,.0,.0), vec3(.0,.0,-10.), .006);\n    if(d10<d) { d=d10; m=mBUNDLE; }\n    float d11 = sdCapsule(p, vec3(.0,.114,.5), vec3(.0,.1,-10.), .0025);\n    if(d11<d) { d=d11; m=mWIRE; }\n\n    // (wire in)\n    vec3 p5 = p;\n    float d12 = sdCapsule(p5, vec3(.0,.0,.0), vec3(.0,.02,1.31), .006);\n    p5.y += sin(p5.z*5.)*cos(p5.z*7.)*.01;\n    float d13 = sdCapsule(p5, vec3(.0,.015,1.31), vec3(.0,-.38,5.), .006);\n    d12 = smin(d12, d13, .005);\n    if(d12<d) { d=d12; m=mBUNDLE; }\n\n    vec3 p6 = p;\n    float d14 = sdCapsule(p6, vec3(.0,.114,.5), vec3(.0,-.38,5.), .0025);\n    if(d14<d) { d=d14; m=mWIRE; }\n\n    // small intersection\n    p6.xy *= ROTm6;\n    float d20 = _cross(p6);\n    p6 *= 1.25;\n    p6.y -= .02;\n    p6.z -= .13;\n    float d21 = _cross(p6);\n    d20 = smin(d20,d21,.004);\n    if(d20<d) { d=d20; m=mMETAL; }\n\n    // joiners\n    float d30 = sdRoundBox(pos - vec3(.0,-.327,.85), vec3(.01,.014,.0075), .003);\n    if(d30<d) { d=d30; m=mRUBBER; }\n    float d31 = sdRoundBox(pos - vec3(-.29,.17,.5), vec3(.01,.014,.0075), .003);\n    if(d31<d) { d=d31; m=mRUBBER; }\n    float d32 = sdRoundBox(pos - vec3(.0,-.25,-.95), vec3(.01,.02,.0075), .003);\n    if(d32<d) { d=d32; m=mRUBBER; }\n    float d33 = sdRoundBox(pos - vec3(.0,-.245,-1.), vec3(.01,.014,.0075), .003);\n    if(d33<d) { d=d33; m=mRUBBER; }\n    float d34 = sdRoundBox(pos - vec3(-.39,-.31,.104), vec3(.0075,.023,.014), .003);\n    if(d34<d) { d=d34; m=mRUBBER; }\n    \n    return d;\n}\n\nfloat map_wireaboveroundthing(in vec3 p, out float m)\n{\n    p -= vec3(-.3,.12,-.41);\n    \n    float d = 100000.;\n    \n    // (wire out)\n    float d10 = sdCapsule(p, vec3(.0,.1,.09), vec3(.0,.1,-10.), .010);\n    if(d10<d) { d=d10; m=mBUNDLE; }\n    float d11 = sdCapsule(p, vec3(.0,.1,.09), vec3(.0,.05,1.), .006);\n    if(d11<d) { d=d11; m=mBUNDLE; }\n    float d12 = sdCapsule(p, vec3(.0,.05,1.), vec3(.0,-1.05,10.), .006);\n    if(d12<d) { d=d12; m=mBUNDLE; }\n    float d13 = sdCapsule(p, vec3(.0,.114,.5), vec3(.0,.08,-10.), .0025);\n    if(d13<d) { d=d13; m=mWIRE; }\n\n    // (wire in)\n    float d14 = sdCapsule(p, vec3(.0,.114,.5), vec3(.0,-.43,5.), .0025);\n    if(d14<d) { d=d14; m=mWIRE; }\n\n    // cross intersection\n    p.xy *= ROTm6;\n    float d20 = _cross(p);\n    p *= 1.25;\n    p.y -= .02;\n    p.z -= .13;\n    float d21 = _cross(p);\n    d20 = smin(d20,d21,.004);\n    if(d20<d) { d=d20; m=mMETAL; }\n\n    return d;\n}\n\nfloat map_weirdsinkerthing(in vec3 pos, out float m)\n{\n    float d = 100000.;\n\n    vec3 savepos = pos - vec3(1.8,1.4,0.);\n    vec3 offset = vec3(3.4,.25,0.145);\n    vec3 p1 = (pos * 1.4) - offset;\n    p1.x *= 1.4;\n    vec3 p2 = p1;\n    p1.xy *= ROTm90;\n    float d1 = sdRoundCone(abs(p1) - vec3(0.,.3,0.), .05, .02, .3);\n    float d2 = sdRoundedCylinder(p1, .025, .01, .275);\n    d1 = smin(d1, d2, .01);\n    p2.xy *= ROTm5;\n    float d3 = sdRoundBox(p2 - vec3(.04,-.04,-.01), vec3(.17,.025,.02), .01);\n    d1 = smin(d1, d3, .02);\n    if(d1<d) { d=d1; m=mRUBBER; }\n\n    // (wire out)\n    vec3 p3 = pos - offset / 1.4;\n    float d4 = sdCapsule(p3, vec3(0.,smoothstep(.3,.55,p3.x)*.036,.0), vec3(4.,.036,0.), .008);\n    if(d4<d) { d=d4; m=mBUNDLE; }\n    \n    // (wire in)\n    float d5 = sdCapsule(p3, vec3(-.3,smoothstep(-.3,-.55,p3.x)*.036,.0), vec3(-.63,.036,0.), .008);\n    if(d5<d) { d=d5; m=mBUNDLE; }\n    float d6 = sdTorus(savepos - vec3(0.,-1.185,0.), vec2(.104,.008));\n    if(d6<d) { d=d6; m=mBUNDLE; }\n    \n    // clips\n    float d7 = sdRoundBox(savepos - vec3(1.1,-1.175,.1), vec3(.005,.017,.002), .0005);\n    if(d7<d) { d=d7; m=mRUBBER; }\n    float d8 = sdRoundBox(savepos - vec3(1.125,-1.175,.1), vec3(.005,.017,.002), .0005);\n    if(d8<d) { d=d8; m=mRUBBER; }\n    float d9 = sdRoundBox(savepos - vec3(.11,-1.175,.1), vec3(.01,.017,.002), .0005);\n    if(d9<d) { d=d9; m=mRUBBER; }\n    \n    return d;\n}\n\nfloat map_threewirebox(in vec3 p, out float m)\n{\n    float d = 10000.;\n    p -= vec3(1.,.37,.1);\n    p.xy *= ROTm7;\n    p *= 1.3;\n    vec3 p2 = p;\n    \n    p.x = abs(p.x);\n    p.z *= 1.3;\n    p.z -= .025;\n    float d1 = sdRoundBox(p, vec3(.08,.01,.05), .005);\n    float d2 = sdRoundBox(p - vec3(.035,-.01,0.), vec3(.01,.008,.04), .004);\n    d1 = smin(d1,d2,.01);\n    p.yz *= ROT90;\n    float d3 = sdRoundedCylinder(p - vec3(.04,.0,.0), .004, .005, .06);\n    d1 = smin(d1,d3,.001);\n    float d4 = sdRoundedCylinder(p, .004, .005, .06);\n    d1 = smin(d1,d4,.001);\n   \n    p2.xy *= ROT90;\n    float d5 = sdRoundedCylinder(p2 - vec3(0.,.16,.03), .013, .01, .02);\n    float d6 = sdRoundedCylinder(p2 - vec3(0.,.16,.08), .013, .01, .018);\n    d5 = smin(d5,d6,.01);\n    d1 = min(d1,d5);\n    float d7 = sdRoundedCylinder(p2 - vec3(0.,.09,.08), .009, .05, .04);\n    d1 = min(d1,d7);\n    if(d1<d) { d=d1; m=mMETAL; }\n\n    float d8 = sdRoundedCylinder(p2 - vec3(0.,-.17,.08), .007, .05, .035);\n    if(d8<d) { d=d8; m=mRUBBER; }\n    float d9 = sdRoundedCylinder(p2 - vec3(0.,-.18,.04), .007, .05, .033);\n    if(d9<d) { d=d9; m=mRUBBER; }\n    float d10 = sdRoundedCylinder(p2 - vec3(0.,-.17,.0), .0075, .05, .036);\n    if(d10<d) { d=d10; m=mRUBBER; }\n\n    return d;\n}\n\nfloat map_threewires(in vec3 p2, out float m)\n{\n    float d = 10000.;\n    p2 -= vec3(1.,.37,.1);\n    p2.xy *= ROTm7;\n    p2 *= 1.3;\n    p2.xy *= ROT90;\n\n    float c = (1. - cos(p2.y*7.)) * .125 * .5;\n    float s1 = step(-1.34,p2.y);\n    float s2 = step(-.45,p2.y);\n    float s = s1 * (1.-s2);\n    p2.x += (s * c) - (.125)*s;\n    \n    float ss1 = smoothstep(-.3,-.55,p2.y);\n    float ss2 = smoothstep(-1.3,-1.5,p2.y);\n    float ss = ss1 * (1. - ss2);\n    vec3 p3 = p2;\n    vec3 p4 = p2;\n    vec3 p5 = p2;\n    \n    p2.z -= .025 * ss;\n    p3.z -= -.025 * ss;\n    float d20 = sdCapsule(p2, vec3(0.,.1,.0), vec3(0.,-12.8,0.), .006);\n    if(d20<d) { d=d20; m=mBUNDLE; }\n    p4.x += sin(p4.y*8.)*.01;\n    float d21 = sdCapsule(p4, vec3(0.,.2,.04), vec3(0.,-12.8,.04), .006);\n    if(d21<d) { d=d21; m=mBUNDLE; }\n    p3.x += cos(p3.y*11.)*.005;\n    float d22 = sdCapsule(p3, vec3(0.,.2,.08), vec3(0.,-12.8,.08), .006);\n    if(d22<d) { d=d22; m=mBUNDLE; }\n    \n    p5.z *= .6;\n    float d30 = sdRoundedCylinder(p5 - vec3(0.,-.48,.024), .01, .005, .016);\n    if(d30<d) { d=d30; m=mBUNDLE; }\n    float d31 = sdRoundedCylinder(p5 - vec3(0.,-1.3,.024), .01, .005, .016);\n    if(d31<d) { d=d31; m=mBUNDLE; }\n\n    return d;\n}\n\n\n\n\n\n\n\nfloat map (in vec3 p, out float m, vec3 ro, vec3 rd)\n{\n    float d = 1000000.;\n    float tmpM = -1.;\n    float t;\n\n\n    // insulator\n    t = iBox(ro, rd, vec3(-.25,1.,-.06), vec3(.0,1.15,.06));\n    if(t>0.) \n    {\n        float r = map_insulator(p, tmpM);\n        if(r<d) { d=r; m=tmpM; }\n    }\n    \n    // insulator-wire\n    {\n        float r = map_insulatorwire(p, tmpM);\n        if(r<d) { d=r; m=tmpM; }\n    }\n\n\n    // wire below insulator\n    {\n        float r = map_wirebelowinsulator(p, tmpM);\n        if(r<d) { d=r; m=tmpM; }\n    }\n    \n    // and the wire below that\n    {\n        float r = map_andthewirebelowthat(p, tmpM);\n        if(r<d) { d=r; m=tmpM; }\n    }\n\n    // light\n    t = iBox(ro, rd, vec3(.05,1.3,-.1), vec3(1.9,1.8,1.3));\n    if(t>0.) \n    {\n        float r = map_light(p, tmpM);\n        if(r<d) { d=r; m=tmpM; }\n    }\n\n    // large round thing\n    t = iBox(ro, rd, vec3(-.08,-.5,-.8), vec3(.08,-.2,-.05));\n    if(t>0.) \n    {\n        float r = map_largeroundthing(p, tmpM);\n        if(r<d) { d=r; m=tmpM; }\n    }\n\n    // large round thing's wires and bits\n    {\n        float r = map_largeroundthingwiresetc(p, tmpM);\n        if(r<d) { d=r; m=tmpM; }\n    }\n\n    // wire above the round thing\n    {\n        float r = map_wireaboveroundthing(p, tmpM);\n        if(r<d) { d=r; m=tmpM; }\n    }\n\n    // three-wire box\n    t = iBox(ro, rd, vec3(.8,.35,.0), vec3(1.2,.4,.2));\n    if(t>0.) \n    {\n        float r = map_threewirebox(p, tmpM);\n        if(r<d) { d=r; m=tmpM; }\n    }\n\n    // three wires\n    {\n        float r = map_threewires(p, tmpM);\n        if(r<d) { d=r; m=tmpM; }\n    }\n\n\n\n    if(p.x < -.2)\n        return d;\n    \n\n\n    // complex pole connection\n    t = iBox(ro, rd, vec3(-.1,1.05,-.08), vec3(3.9,1.3,.08));\n    if(t>0.) \n    {\n        float r = map_complexpoleconnection(p, tmpM);\n        if(r<d) { d=r; m=tmpM; }\n    }\n\n    // lightwire\n    {\n        float r = map_lightwire(p, tmpM);\n        if(r<d) { d=r; m=tmpM; }\n    }\n    \n    // near-vertical wires (top-right)\n    {\n        float r = map_nearverticallines(p, tmpM);\n        if(r<d) { d=r; m=tmpM; }\n    }\n    \n    // weird sinker thing\n    {\n        float r = map_weirdsinkerthing(p, tmpM);\n        if(r<d) { d=r; m=tmpM; }\n    }\n\n    // pole\n    t = iBox(ro, rd, vec3(1.68,-3.,-.255), vec3(2.05,4.,.25));\n    if(t>0.) \n    {\n        float r = map_pole(p, tmpM);\n        if(r<d) { d=r; m=tmpM; }\n    }\n    \n    // wire from bottom of pole\n    {\n        float r = map_wirefrombottomofpole(p, tmpM);\n        if(r<d) { d=r; m=tmpM; }\n    }\n\n    // pegs\n    {\n        float r = map_pegs(p, tmpM);\n        if(r<d) { d=r; m=tmpM; }\n    }\n\n    // fusebox\n    t = iBox(ro, rd, vec3(1.6,-.25,-.14), vec3(1.71,-.8,.24));\n    if(t>0.) \n    {\n        float r = map_fusebox(p, tmpM);\n        if(r<d) { d=r; m=tmpM; }\n    }\n\n    // wires to fusebox\n    {\n        float r = map_wirestofusebox(p, tmpM);\n        if(r<d) { d=r; m=tmpM; }\n    }\n\n    return d;\n}\n\nvec3 calcNormal(in vec3 p, in vec3 ro, in vec3 rd)\n{\n    float m;\n\n#ifndef FASTNORMALS\n    const float ep = 0.0001;\n    vec2 e = vec2(1.0,-1.0)*0.5773;\n    return normalize( e.xyy*map( p + e.xyy*ep, m ) + \n\t\t\t\t\t  e.yyx*map( p + e.yyx*ep, m ) + \n\t\t\t\t\t  e.yxy*map( p + e.yxy*ep, m ) + \n\t\t\t\t\t  e.xxx*map( p + e.xxx*ep, m ) );\n#else\n    // from https://www.shadertoy.com/view/Xds3zN\n    vec3 n = vec3(0.0);\n    for( int i=0; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(p+0.0005*e, m, ro, rd);\n      //if( n.x+n.y+n.z>100.0 ) break;\n    }\n    return normalize(n);\n#endif\n                      \n}\n\nfloat castRay( in vec3 ro, in vec3 rd, in float startT, out float m)\n{\n    float t = startT;\n    for (int i=0; i<80; i++ )\n    {\n        vec3 p = ro + t*rd;\n        \n        float h = map(p, m, ro, rd);\n        h *= .65;\n        if( abs(h)<0.001 )\n            break;\n        t += h;\n        if(t>12.0 ) break;\n    }\n    if ( t>12.0 ) m=-1.0;\n\n\n/*\n    if(mod(iTime*20.,2.) > 1.)\n    {\n        float tmp = iBox(ro, rd, vec3(1.68,-3.,-.255), vec3(2.05,4.,.25));\n        if(tmp > 0.){ t = tmp; m = 1.; } else { t = 10000.; m = -1.; }\n    }\n*/\n\n    return t;\n}\n\nvec3 GetColor(vec2 p, vec3 ro, float t, vec3 rd, float m, vec3 sun_pos, vec3 sun_dir, float hitsomething)\n{    \n    vec3 pos; // the collision point\n    vec3 nor; // the normal at the collision point\n    float sun_dif;\n    float bou_dif;\n    float shadow = 0.;\n    if(m > -.5 && m < 4.5)\n    {\n        pos = ro + t*rd;\n        nor = calcNormal(pos, ro, rd);\n        sun_dif = clamp ( dot(nor,sun_dir),0.0,1.0);\n        bou_dif = clamp ( 0.5 + 0.5*dot(nor,vec3(-1.0,.0,.0)), 0.0, 1.0);\n\n        // shadow\n        vec3 lightDirection = normalize(sun_pos - pos);\n        vec3 newRayOrigin = pos + nor * PRECISION;\n        float shadowRayLength = castRay(newRayOrigin, lightDirection, 0., hitsomething);\n        //if (shadowRayLength < length(sun_pos - newRayOrigin))\n        if (hitsomething > -.5)\n        {\n            shadow = .0375;\n        }\n    }\n    \n\n    // apply materials\n    vec3 col;\n    if(m < -.5) // sky\n    {\n        vec2 sun = p + vec2(-1.1,1.4);\n        float r = length(sun) * .2;\n        col = mix(vec3(0.345,.247,.275), vec3(.0196,.0784,.235), r);\n        col += noise(p*389.1234) * .005;\n    }\n    else if(m < .5) // pole\n    {\n        vec3 mat = vec3(.3,.24,.14);\n        col = mat*vec3(4.5,3.5,2.5)*smoothstep(.3,.6,sun_dif)*.1;\n        col += mat*vec3(.35,.3,.6)*bou_dif*.3;\n    }\n    else if(m < 1.5) // metal\n    {\n        float mat = .1;\n        col = mat*vec3(4.5,3.5,3.5)*smoothstep(.3,.6,sun_dif)*.2;\n        col += mat*vec3(.35,.3,.6)*bou_dif*.6;\n    }\n    else if(m < 2.5) // wire\n    {\n        float mat = .1;\n        float sun_dif = clamp ( dot(nor,sun_dir),0.0,1.0);\n        col = mat*vec3(6.0,4.5,3.5)*sun_dif*.1;\n    }\n    else if(m < 3.5) // rubber\n    {\n        float mat = .1;        \n        col = mat*vec3(7.0,3.5,3.5)*sun_dif*.5;//*sun_sha;\n        col += mat*vec3(.2,.2,.5)*bou_dif*.8;\n    }\n    else if(m < 4.5) // bundle\n    {\n        float mat = .05;\n        col = mat*vec3(15.0,4.5,5.0)*sun_dif*.05;\n        col += mat*vec3(.3,.2,.6)*bou_dif*.4;\n    }\n    else/* if(m < 5.5)*/ // light\n    {\n        col = vec3(1.,1.,.95);\n    }\n    /*\n    else // unknown\n    {\n        col = vec3(1.,1.,1.);\n    }\n    */\n    \n    // shadow\n    col -= shadow;\n    \n    // glow\n    p.x *= .75;\n    vec2 light = p - vec2(-.222,.26);\n    float r = length(light);\n    float bloom = clamp(mix(1.04,0.,r),0.,1.);\n    col += pow(bloom,20.) * vec3(1.,1.,.6) * .7;\n\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    const vec3 sun_dir = normalize(vec3(0.8,0.8,-0.1) );\n    const vec3 sun_pos = normalize(vec3(1.,1.,.3)) * 12.; // yeah, the light pos is tweaked for nicer shadows\n    vec2 onefrag = vec2(1./iResolution.x, 1./iResolution.y);\n    float hitsomething;\n    float m = -1.;\n\n    vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n\n#ifdef MOUSESPIN\n    float an = 20.*iMouse.x/iResolution.x;\n#else\n    float an = 20.*.042;\n#endif\n\n    vec3 ro = vec3 (CAMDIST*sin(an), -2.5, CAMDIST*cos(an));\n    vec3 ta = vec3(0.,1.4,0.);\n    \n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(.0,1.,.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n\n#ifndef ANTIALIAS\n    vec3 rd = normalize( p.x*uu + p.y*vv + 2.8*ww );\n    float t = castRay(ro, rd, 4., m);\n    vec3 col = GetColor(p, ro, t, rd, m, sun_pos, sun_dir, hitsomething);\n#else\n    float AA_size = ANTIALIAS_SIZE;\n    float count = 0.;\n    vec2 fragOffset = 15. * onefrag / 2.;\n    vec3 col;\n    for (float aaY = 0.0; aaY < AA_size; aaY++)\n    {\n        for (float aaX = 0.0; aaX < AA_size; aaX++)\n        {\n            vec2 newP = p + vec2(aaX, aaY) * onefrag - fragOffset;\n            vec3 rd = normalize( newP.x*uu + newP.y*vv + 2.8*ww );\n            float t = castRay(ro, rd, 4., m);\n\n            col += GetColor(p,ro,t,rd,m,sun_pos,sun_dir,hitsomething);\n            count += 1.;\n        }\n    }\n    col /= count;\n#endif    \n    \n    col = pow(col,vec3(0.4545)); // gamma correction (1/2.2)\n\n    fragColor = vec4(col,1.0);\n}\n","name":"Image","description":"","type":"image"}]}