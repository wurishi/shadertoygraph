{"ver":"0.1","info":{"id":"fdfcDs","date":"1642884929","viewed":318,"name":"SuperCollider #21 ~ FM Part 1","username":"Yusef28","description":"I first learned of the super collider tutorials from athibaul in the comments of his featured sahder \"Techno Song (sound)\"\nhttps://www.shadertoy.com/view/sls3WM\nThe link to those tutorials is in those comments, and in the sound tab of this shader.\n","likes":8,"published":3,"flags":8,"usePreview":0,"tags":["pulse","wave","super","collider","supercollider"],"hasliked":0,"parentid":"7dXyDf","parentname":"Super Collider #6 [Iters / Bass]"},"renderpass":[{"inputs":[{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n#define TEXTURE_STEP_SIZE 1./16.\n#define LETTER_SIZE 1./20.\n#define FIRST_LETTER 64.\n#define FIRST_NUMBER 48.\n\nvec2 numToCoord(float a){\n    return vec2( mod(a,16.), 15.-floor(a/16.) );\n}\n\nvec3 C(vec2 uv, vec2 start, inout float moveX,float num){\n    moveX += LETTER_SIZE/2.3;\n    if(uv.x < start.x           || \n       uv.x > start.x+LETTER_SIZE || \n       uv.y < start.y           || \n       uv.y > start.y+LETTER_SIZE){\n       return vec3(0.);\n    }\n    \n    uv -= start; uv /= LETTER_SIZE; uv *= TEXTURE_STEP_SIZE;\n    uv += vec2(TEXTURE_STEP_SIZE*numToCoord(num));\n    return textureGrad(iChannel0,uv,dFdx(uv),dFdy(uv)).rrr;\n}\n\nvoid printC(vec2 st, float char, float y, inout float moveX, inout vec3 col){\n    col = mix(col,vec3(1.),\n    C(st,vec2(moveX,y),moveX,FIRST_LETTER+char));\n}\n\nvoid printWord(vec2 st, inout vec2 startPos, float list[20], int size, \n               inout vec3 col){\n               \n    for(int i = 0; i < size; i++){\n        printC(st,list[i],startPos.y,startPos.x,col); \n    }\n    startPos.x = 0.;\n    startPos.y -= 0.08;\n}\n\n//takes a float and prints the first 4 digits\nvoid generateDigits(vec2 uv, inout vec2 start,\n                     float theNumber, inout vec3 col){\n    \n    float count = 1., FN = theNumber, inv = 1./10.;\n    //count digits\n    while(FN >= 10.){count *= 10.; FN *= inv;}\n    FN = theNumber;\n    //before decimal\n    while(count >= 1.){\n            float n = floor(FN / count);\n            col += C(uv, start, start.x, FIRST_NUMBER + n);\n            FN -= n*count;count /= 10.;\n        }\n    //decimal point\n    col += C(uv, start, start.x, FIRST_NUMBER -2.);\n    //after decimal\n    FN = fract(theNumber)*10.;\n    float ones = floor(mod(FN,10.));\n    col += C(uv, start, start.x, FIRST_NUMBER + ones);\n    // moveX += LETTER_SIZE/3.;\n   \n   //for next line\n   start.y -= 0.08;\n   start.x = 0.8;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 col = 0.5 + 0.5*cos(uv.xyy+vec3(0,2,4));\n    vec2 st = uv;\n\n    float t = iTime;\n    float ticc = floor(t);\n    float cHZ = ExpRand2(ticc, 20., carHZMax);\n    float mHZ = ExpRand2(ticc+1934., 20., modHXMax);\n    float mA = floor(ExpRand2(ticc+9234., 20., modAmplMax));\n    float envID = ExpRand(ticc+741., 4., 15.);\n    \n    float carrier_frequency_word[20] = float[20](\n    _c,_a,_r,_r,_i,_e,_r,__,_f,_r,_e,_q,_u,_e,_n,_c,_y,__,__,__\n    );\n    \n    float modulation_frequency_word[20] = float[20](\n    _m,_o,_d,_u,_l,_a,_t,_i,_o,_n,__,_f,_r,_e,_q,_u,_e,_n,_c,_y\n    );\n    \n    float modulation_amplitude_word[20] = float[20](\n    _m,_o,_d,_u,_l,_a,_t,_i,_o,_n,__,_a,_m,_p,_l,_i,_t,_u,_d,_e\n    );\n    float envelope_exponent_word[20] = float[20](\n    _e,_n,_v,_e,_l,_o,_p,_e,__,_e,_x,_p,_o,_n,_e,_n,_t,__,__,__\n    );\n    \n    vec2 wordPos =vec2(0.,1.-0.15);\n    vec2 numberPos =vec2(0.8,1.-0.15);\n    \n    printWord(st,wordPos,carrier_frequency_word,17,col);\n    printWord(st,wordPos,modulation_frequency_word,20,col);\n    printWord(st,wordPos,modulation_amplitude_word,20,col);\n    printWord(st,wordPos,envelope_exponent_word,17,col);\n    \n    generateDigits(st, numberPos, cHZ, col);\n    generateDigits(st, numberPos, mHZ, col);\n    generateDigits(st, numberPos, mA, col);\n    generateDigits(st, numberPos, envID, col);\n    \n    float sound_in_word[20] = float[20](\n    _s,_o,_u,_n,_d,__,_i,_n,__,__,__,__,__,__,__,__,__,__,__,__\n    );\n    \n    wordPos =vec2(0.37,0.15);\n    printWord(st,wordPos,sound_in_word,8,col);\n     \n    \n   \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// Super Collider Tutorials\n// https://www.youtube.com/playlist?list=PLPYzvS8A_rTaNDweXe6PX4CXSGq4iEWYC\n\n/*\n\nStaying true to the end of the tutorial for the \nmost part although I still don't know exactly what \nExpRand is really supposed to do. I have an exponetial random number\ngenerator (two options actually) but I'm still not getting the\nsame kind of range I would expecct so I'll keep playing around \nwith it.\n\nWith text you can actually pick out sounds you\nlike and use them for something.\n*/\n\n\n\nvec2 fm(float t, float carrierHZ, float modHZ, float modAmpl, float envAmp){\n    \n    vec2 carrier, modulator;\n    \n    float env = exp(-fract(t)*envAmp);\n    modulator = vec2(sin(modHZ*t*2.*PI)*modAmpl);\n    carrier   = vec2(sin(carrierHZ*t*2.*PI + modulator));\n    return carrier*0.09*env;\n}\n\nvec2 mainSound( int samp, float time )\n{\n    float t = time;\n    float ticc = floor(t);\n    float cHZ = ExpRand2(ticc, 20., carHZMax);\n    float mHZ = ExpRand2(ticc+1934., 20., modHXMax);\n    float mA = floor(ExpRand2(ticc+9234., 20., modAmplMax));\n    float envID = ExpRand(ticc+741., 4., 15.);\n    return fm(t, cHZ, mHZ, mA, envID);\n}\n\n\n","name":"Sound","description":"","type":"sound"},{"inputs":[],"outputs":[],"code":"#define PI acos(-1.)\n#define DURATION 0.5\n\n#define carHZMax 10000.\n#define modHXMax 10000.\n#define modAmplMax 10000.\n\n\n\nfloat rnd(float a){return fract(sin(a*238.41)*49625.924);}\n\nfloat ExpRand(float a, float low, float high){\n    float seed = pow(rnd(a),10.);\n    float range = high-low;\n    return seed*range + low;\n}\n\nfloat ExpRand2(float id, float low, float high){\n    float lambda = 50.5;\n    float u = rnd(id);\n    float x = clamp( log(1.-u)/(-lambda), 0., 1.);\n    float range = high-low;\n    return x*range + low;\n}\n\n#define _a 1.\n#define _b 2.\n#define _c 3.\n#define _d 4.\n#define _e 5.\n#define _f 6.\n#define _g 7.\n#define _h 8.\n#define _i 9.\n#define _j 10.\n#define _k 11.\n#define _l 12.\n\n#define _m 13.\n#define _n 14.\n#define _o 15.\n#define _p 16.\n#define _q 17.\n#define _r 18.\n#define _s 19.\n#define _t 20.\n#define _u 21.\n#define _v 22.\n#define _w 23.\n#define _x 24.\n#define _y 25.\n#define _z 26.\n#define __ _z+32.+5.","name":"Common","description":"","type":"common"}]}