{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[{"channel":0,"type":"texture","id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"}},{"channel":2,"type":"buffer","id":"4dXGR8","filepath":"/media/previz/buffer00.png","sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"code":"float get_zoom()\n{\n    float zoomfact = texture(iChannel2, (addr_zoom + vec2(0.5, 0.5))/iResolution.xy).r;\n    return zoomfact==0.?1.:zoomfact;\n}\n\nbool get_blinking()\n{\n    return texture(iChannel2, (addr_blink + vec2(0.5, 0.5))/iResolution.xy).r==0.;\n}\n\nfloat get_power()\n{\n    return (get_blinking()?getPowerTime(iTime):1.)*max(0., texture(iChannel2, (addr_power + vec2(0.5, 0.5))/iResolution.xy).r);\n}\n\nbool get_cut()\n{\n    return texture(iChannel2, (addr_cut + vec2(0.5, 0.5))/iResolution.xy).r==0.;\n}\n\nfloat map_floor(vec3 pos)\n{\n    return pos.y;\n}\n\nfloat map_room(vec3 pos)\n{\n   vec3 roomSize2 = roomSize;\n   #ifdef doors\n   roomSize2.xz-= dfSize.y*smoothstep(2.*dfSize.x + 0.01, 2.*dfSize.x - 0.01, pos.y);\n   #endif    \n    \n   float room = -sdRoundBox(pos + vec3(0, -roomSize2.y*0.5 + 0.01, 0.), roomSize2*0.5, 0.);\n   #ifdef doors\n\n   vec3 pos2 = pos;\n   pos2.x = abs(pos.x);\n   room = max(room, -sdRoundBox(pos2 + vec3(-roomSize.z - doorSize.z, -roomSize.y*0.5 + 0.01, 0.), roomSize*0.5, 0.));\n   room = min(room, sdRoundBox(pos2 + vec3(-roomSize.z*0.5 - doorSize.z*0.5, -doorSize.y*0.5 + 0.01, 0.), doorSize.zyx*0.5 + vec3(0.5*dfSize.y, 2.*dfSize.x, 2.*dfSize.x), 0.));\n   room = max(room, -sdRoundBox(pos2 + vec3(-roomSize.z*0.5 - doorSize.z*0.5, -doorSize.y*0.5 + 0.01, 0.), doorSize.zyx*0.5 + vec3(0.5*dfSize.y + 0.01, 0., 0.), 0.));\n   #endif\n    \n   return room;\n}\n\nfloat map_glass(vec3 pos)\n{\n   pos.y-= 0.1;\n    \n   float glass1 = length(pos - bulbPos) - 0.2;\n   if (pos.y<bulbPos.y)\n      glass1 = length(pos.xz) - 0.2*(0.72 + 0.28*cos(11.*(pos.y - bulbPos.y)))*pow(smoothstep(-0.35, -0.3, pos.y - bulbPos.y), 0.22);\n   glass1 = max(glass1, -glass1 - 0.0009);\n   float glass = sdCylinder((pos - bulbPos - vec3(0., -0.275, 0.)), vec2(0.021*(1. - 0.15*smoothstep(-0.27, -0.25, pos.y - bulbPos.y)*cos(135.*(pos.y - bulbPos.y) + 2.2)), 0.05)) - 0.01;\n   glass = smax(glass, abs(pos.z) - 0.017, 0.015);\n   glass = smin(glass, sdCylinder(pos - bulbPos - vec3(0., -0.152, 0.), vec2(0.0055, 0.055)) - 0.007, 0.015);\n   glass = smin(glass, sdEllipsoid(pos - bulbPos - vec3(0., -0.09, 0.), vec3(0.024, 0.005, 0.024)), 0.005);\n   glass = smax(glass, -sdCylinder((pos - bulbPos - vec3(0., -0.24, 0.)).xzy, vec2(0.0105, 0.03)), 0.012);\n   glass = min(glass, glass1);\n    \n   glass = max(glass, -pos.y + bulbPos.y - 0.333);    \n   \n   return glass;\n}\n\nfloat map_screw(vec3 pos)\n{\n   float r1 = 0.077 - 0.0047*smoothstep(0.01, 0., pos.y - bulbPos.y + 0.239);\n   r1*= (1. - 0.65*smoothstep(0.048, 0., pos.y - bulbPos.y + 0.373));\n   float a = atan(pos.x, pos.z);    \n   r1*= 1. - 0.08*(1. - 0.5*sin(275.*(pos.y - bulbPos.y) + a))*(smoothstep(0.01, 0., pos.y - bulbPos.y + 0.26)*smoothstep(0., 0.013, pos.y - bulbPos.y + 0.335));\n    \n   float screw = sdCylinder(pos - bulbPos - vec3(0., -0.3, 0.), vec2(r1, 0.07));\n   screw = smin(screw, sdEllipsoid(pos - bulbPos + vec3(0., 0.37, 0.), vec3(0.024, 0.006, 0.024)), 0.004);\n    \n   return screw;\n}\n\nfloat map_support(vec3 pos)\n{\n   float support = sdEllipsoid(pos, vec3(0.6, 0.12, 0.6));\n   support = smin(support, sdCylinder(pos, vec2(0.042 + 0.065*smoothstep(bulbPos.y - 0.55, bulbPos.y - 0.4, pos.y), bulbPos.y)), 0.22);\n   support = max(support, -support - 0.015);\n   support = max(support, -pos.y + 0.01);\n   support = max(support, pos.y - bulbPos.y + 0.23);\n    \n   support = min(support, sdCylinder(pos - bulbPos - vec3(0., -0.295, 0.), vec2(0.1, 0.045)));\n   support = max(support, -map_screw(pos) + 0.003);\n   \n   if (cut)\n      support = max(support, pos.z + 0.33*(pos.y - bulbPos.y + 0.48));\n    \n   return support;\n}\n\nfloat map_filament(vec3 pos)\n{\n   vec3 fsv = 0.0014*vec3(0., cos(pos.x*1800.), sin(pos.x*1800.));\n   pos.x = abs(pos.x);\n   float filament = sdCylinder(pos - bulbPos - vec3(0.023 + 0.09*smoothstep(0., 0.32, pos.y - bulbPos.y + 0.13), -0.075, 0.), vec2(0.0014, 0.16));\n   filament = min(filament, sdCylinder(pos - bulbPos - vec3(0.013 + 0.3*(pos.y - bulbPos.y), 0.057, 0.05*(pos.y - bulbPos.y)), vec2(0.00032, 0.043)));\n   filament = min(filament, sdCylinder((pos - bulbPos - vec3(0., 0.173 - 2.5*pos.x*pos.x - 0.03/(0.4 + abs(pos.x - 0.043)), 0.) + fsv).yxz, vec2(0.00009, 0.091)));\n   \n   vec3 pos2 = (pos - bulbPos - vec3(0.0413, 0.093, 0.)).zxy;\n   pos2.yz = rotateVec(pos2.yz, 0.29);\n   filament = min(filament, sdTorus(pos2, vec2(0.0047, 0.00032)));\n    \n   return filament;\n}\n\nfloat map_filament_s(vec3 pos)\n{\n   pos.x = abs(pos.x);\n   float filament = sdCylinder((pos - bulbPos - vec3(0., 0.173 - 2.5*pos.x*pos.x - 0.03/(0.4 + abs(pos.x - 0.043)), 0.)).yxz, vec2(0.001, 0.091));\n    \n   //filament = max(filament, pow(length(pos - bulbPos - vec3(0., 0.1, 0.)) - 0.15, 0.67));\n   filament = max(filament, length(pos - bulbPos - vec3(0., 0.12, 0.)) - 0.12);\n    \n   return filament;\n}\n\nfloat map_blamp(vec3 pos)\n{\n   return length(pos - blampPos) - 0.5;   \n}\n      \nvec2 map(vec3 pos, bool inside, bool hasShadow)\n{\n    vec2 res;\n    \n    float filament = map_filament(pos);\n    float glass = map_glass(pos);\n    \n    if (inside)\n    {\n       res = vec2(-glass, GLASS_OBJ);\n       res = opU(res, vec2(filament, FILAMENT_OBJ));   \n    }\n    else\n    {\n       float screw = map_screw(pos);\n       res = vec2(screw, SCREW_OBJ);  \n        \n       if (!hasShadow)\n       {\n          res = opU(res, vec2(filament, FILAMENT_OBJ));           \n          res = opU(res, vec2(glass, GLASS_OBJ));\n           \n          float support = map_support(pos);\n          res = opU(res, vec2(support, SUPPORT_OBJ));           \n           \n          float floor = map_floor(pos);\n          res = opU(res, vec2(floor, FLOOR_OBJ));           \n           \n          float room = map_room(pos);\n          res = opU(res, vec2(room, ROOM_OBJ));\n           \n          float blamp = map_blamp(pos);\n          res = opU(res, vec2(blamp, BLAMP_OBJ));\n       }      \n    }\n    return res;\n}\n\nvec3 getGlassAbsColor(float dist, vec3 color)\n{\n    return pow(color, vec3(0.1 + pow(dist*2.5, 2.)));\n}\n\n// Main tracing function\nvec2 trace(vec3 cam, vec3 ray, float maxdist, bool inside) \n{\n    float t = 0.002;\n    float objnr = 0.;\n    vec3 pos;\n    float dist;\n    \n  \tfor (int i = ZERO; i < 170; ++i)\n    {\n    \tpos = ray*t + cam;\n        vec2 res = map(pos, inside, false);\n        dist = res.x;\n        if (dist>maxdist || abs(dist)<0.0003)\n            break;\n        t+= dist*(0.75 - 0.008*zoom);\n        objnr = abs(res.y);\n  \t}\n  \treturn vec2(t, objnr);\n}\n\n#ifdef shadow\nfloat calcSoftshadow(in vec3 ro, in vec3 rd)\n{\n    float res = 5.0;\n    float tmax = 12.0;  \n    \n    float t = 0.01;\n    for( int i=ZERO; i<25; i++ )\n    {\n\t\tfloat h = map(ro + rd*t, false, true).x;\n        res = min( res, 40.0*h/t );\n        t += clamp( h, 0., 0.80 );\n        if( res<0.0005 || t>tmax ) break;\n    }\n    return clamp(res, 0.0, 1.0);\n}\n#endif\n\n// Fresnel reflectance factor through Schlick's approximation: https://en.wikipedia.org/wiki/Schlick's_approximation\nfloat fresnel(vec3 ray, vec3 norm, float n2)\n{\n   float n1 = 1.; // air\n   float angle = acos(-dot(ray, norm));\n   float r0 = dot((n1-n2)/(n1+n2), (n1-n2)/(n1+n2));\n   float r = r0 + (1. - r0)*pow(1. - cos(angle), 5.);\n   return clamp(r, 0., 0.8);\n}\n\n// From https://www.shadertoy.com/view/lsSXzD, modified\nvec3 GetCameraRayDir(vec2 vWindow, vec3 vCameraDir, float fov)\n{\n\tvec3 vForward = normalize(vCameraDir);\n\tvec3 vRight = normalize(cross(vec3(0.0, 1.0, 0.0), vForward));\n\tvec3 vUp = normalize(cross(vForward, vRight));\n    \n\tvec3 vDir = normalize(vWindow.x * vRight + vWindow.y * vUp + vForward * fov);\n\n\treturn vDir;\n}\n\n#ifdef wall_bump\nfloat getNormal2(vec3 pos, float objnr)\n{\n    if (int(objnr)==ROOM_OBJ && pos.y<roomSize.y - 0.012)\n    {\n        #ifdef doors\n        if ((abs(pos.z)>0.5*doorSize.x + 2.*dfSize.x || pos.y>doorSize.y + 2.*dfSize.x || abs(pos.x)>roomSize.x*1.5) && pos.y>2.*dfSize.x)\n        #endif\n        return -0.0022*noise(pos*58.);\n    }\n}\n#endif\n\nvec3 getNormal(vec3 pos, float e, bool inside)\n{  \n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e2 = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        vec2 mr = map(pos + e*e2, inside, false);\n        n += e2*mr.x;\n        #ifdef wall_bump\n        n += e2*getNormal2(pos + e*e2, mr.y);\n        #endif        \n    }\n    return normalize(n);\n}\n\nfloat getScrewV(vec3 pos)\n{\n   float v = smoothstep(0., 0.001, pos.y - bulbPos.y + 0.354);\n   v*= 1. - smoothstep(0., 0.01, pos.y - bulbPos.y + 0.241)*smoothstep(0.075, 0.074, length(pos.xz));\n   v+= smoothstep(0.001, 0., pos.y - bulbPos.y + 0.368);\n       \n   return v;\n}\n\nvec3 getFloorColor(vec3 pos)\n{\n    #ifdef parquet\n    pos.x+= mod(floor(pos.z/psize.y), 2.)==1.?psize.x*0.5:0.;\n    \n    float pnum = floor(pos.x/psize.x) + 1000.*floor(pos.z/psize.y);\n    vec2 offset = vec2(hash(pnum*851.12), hash(pnum*467.54));\n    vec3 cm = (0.5 + 0.5*hash(pnum*672.75))*floor_color;\n    float sf = 0.8 + 0.4*hash(pnum*218.47);\n    float ra = 0.15*hash(pnum*951.68);\n    \n    pos.xz = rotateVec(pos.xz, ra);\n    return mix(cm, texture(iChannel0, 0.35*sf*pos.xz + offset).rgb, 0.65);\n    #else\n    return floor_color;\n    #endif\n}\n\nvec3 getRoomColor(vec3 pos)\n{\n    vec3 col = pos.y<roomSize.y - 0.0106?walls_color:ceiling_color;\n    \n    #ifdef doors\n    if (abs(pos.z)<0.5*doorSize.x + 2.*dfSize.x && pos.y<doorSize.y + 2.*dfSize.x && abs(pos.x)<roomSize.x*1.5 || pos.y<2.*dfSize.x)\n       col = dframe_color;\n    #endif\n    return col;\n}\n\nvec3 getFilamentColor(vec3 pos, float power)\n{\n    return powerToRGB(power*smoothstep(0.06 - 0.009*power, 0.09 - 0.005*power, pos.y - bulbPos.y));\n}\n\n// Combines the colors\nvec3 getColor(vec3 norm, vec3 pos, int objnr, vec3 ray)\n{\n   if (objnr==FLOOR_OBJ)\n      return getFloorColor(pos);   \n   else if (objnr==SUPPORT_OBJ)\n      return support_color;\n   else if (objnr==SCREW_OBJ)\n      return screw_color*(0.1 + 0.9*getScrewV(pos));\n   else if (objnr==FILAMENT_OBJ)   \n      return filament_color;\n   else if (objnr==ROOM_OBJ)\n      return getRoomColor(pos);\n}\n\n// Shading of the objects pro lamp\nvec3 lampShading(Lamp lamp, vec3 norm, vec3 pos, vec3 ocol, int objnr, int lampnr)\n{   \n    vec3 pl = normalize(lamp.position - pos);\n    float dlp = distance(lamp.position, pos);\n    vec3 pli = pl/pow(1. + lamp.attenuation*dlp, 2.);\n    float dnp = dot(norm, pli);\n      \n    // Diffuse shading\n    vec3 col = ocol*lamp.color*lamp.intensity*smoothstep(-0.1, 1., dnp); //clamp(dnp, 0., 1.);\n    \n    // Softshadow\n    #ifdef shadow\n    col*= shi*calcSoftshadow(pos, normalize(lamp.position - pos)) + 1. - shi;\n    #endif    \n    \n    // Specular shading\n    #ifdef specular\n    if (objnr!=ROOM_OBJ)\n       col+= lamp.color*lamp.intensity*specint*pow(max(0.0, dot(reflect(pl, norm), normalize(pos - campos))), specshin);\n    #endif  \n    \n    return col;\n}\n\n// Shading of the objects over all lamps\nvec3 lampsShading(vec3 norm, vec3 pos, vec3 ocol, int objnr)\n{\n    vec3 col = vec3(0.);\n    for (int l=ZERO; l<lamps.length(); l++)\n       col+= lampShading(lamps[l], norm, pos, ocol, objnr, l);\n    \n    if (objnr==FILAMENT_OBJ)\n       col+= getFilamentColor(pos, get_power());\n    \n    if (objnr==BLAMP_OBJ)       \n       col+= blampColor*(1.04 + 0.14*dot(norm, vec3(-1., 0.5, -1.)));    \n    \n    return col;\n}\n\n// Tracing and rendering a ray\nRenderData trace0(vec3 tpos, vec3 ray, float maxdist, bool inside)\n{\n    vec2 tr = trace(tpos, ray, maxdist, inside);\n    float tx = tr.x;\n    int objnr = int(tr.y);\n    vec3 col;\n    vec3 pos = tpos + tx*ray;\n    vec3 norm;\n    \n    if (tx<maxdist*0.95)\n    {\n        norm = getNormal(pos, normdelta, inside);\n        col = getColor(norm, pos, objnr, ray);\n      \n        // Shading\n        col = col*ambientColor*ambientint + lampsShading(norm, pos, col, objnr);\n    }\n    else\n    {\n        objnr = SKY_OBJ;\n    }\n    return RenderData(col, pos, norm, objnr);\n}\n\n// Sets the position of the camera with the mouse and calculates its direction\nconst float axm = 2.*pi;\nconst float aym = 0.70;\nvoid setCamera()\n{\n   vec2 iMouse2;\n   if (iMouse.x==0. && iMouse.y==0.)\n      iMouse2 = vec2(0.64, 0.32);\n   else\n      iMouse2 = iMouse.xy/iResolution.xy;\n   \n   campos = vec3(8.5, 0., 0.);\n   campos.xy = rotateVec(campos.xy, 0.5 - iMouse2.y*aym + aym*0.5);\n   campos.yz = rotateVec(campos.yz, -iMouse2.y*aym + aym*0.5);\n   campos.xz = rotateVec(campos.xz, iMouse2.x*axm);\n\n   camdir = camtarget - campos;   \n}\n\nvec3 getFilamentHalo(vec3 cam, vec3 ray) \n{\n    float t = length(cam - vec3(0., bulbPos.y + 0.08, 0.)) - 0.2;\n    vec3 pos;\n    float dist;\n    float o = 1000.;\n    \n  \tfor (int i = ZERO; i < 50; ++i)\n    {\n    \tpos = ray*t + cam;\n        float dist = map_filament_s(pos);\n        t+= dist*0.3;\n        o = min(o, max(0., dist));\n  \t}\n  \treturn clamp(0.02/max(0.0015, o)*lamps[0].color*lamps[0].intensity, 0., 10.);\n}\n\nvec3 combineCol(vec3 col1, vec3 col2)\n{\n    return 1. - (1. - clamp(col1, 0., 1.)) * (1. - clamp(col2, 0., 1.));\n    //return max(col1, col2);\n    //return col1 + col2;\n}\n\n// Main render function with reflections and refractions\nvec4 render(vec2 fragCoord)\n{   \n  \tvec2 uv = fragCoord.xy / iResolution.xy; \n  \tuv = uv*2.0 - 1.0;\n  \tuv.x*= iResolution.x / iResolution.y;\n    zoom = get_zoom();\n  \tvec3 ray = GetCameraRayDir(uv, camdir, fov*zoom);\n\n  \tRenderData traceinf = trace0(campos, ray, maxdist, false);\n  \tvec3 col = traceinf.col;\n    \n    vec3 fhalo = 0.8*getFilamentHalo(campos, ray);\n  \n    //return vec4(getFilamentHalo(campos, ray), 1.0);\n    //return vec4(col, 1.0);\n    \n  \tbool inside = false;\n  \tfloat cior = glassMat.ior;\n  \tvec3 glassf = vec3(1.);\n    vec3 refray;\n    vec3 pos0 = traceinf.pos;\n\n    glassf = vec3(1.);\n\n    for (int i=ZERO; i<nbref; i++)\n    {\n        if (traceinf.objnr==GLASS_OBJ)\n        {\t \n            float rf;\n            \n            if(!inside)\n            {\n               refray = reflect(ray, traceinf.norm);\n               rf = fresnel(ray, traceinf.norm, glassMat.ior);\n               RenderData traceinfR = trace0(traceinf.pos, refray, maxdist, false);\n               col = mix(col, traceinfR.col, glassf*rf);\n               col = combineCol(col, 0.7*rf*glassf*getFilamentHalo(traceinf.pos, refray));\n               glassf*= (1. - rf);\n            }\n            \n            cior = inside?1./glassMat.ior:glassMat.ior;\n\n            vec3 ray_r = refract(ray, traceinf.norm, 1./cior);\n            if (length(ray_r)!=0.)\n                inside = !inside;\n            else\n                ray_r = reflect(ray, traceinf.norm);            \n\n            vec3 pos = traceinf.pos;\n\n            traceinf = trace0(pos + 0.0003*ray_r, ray_r, maxdist, inside);\n            traceinf.col*= 0.2 + 0.8*pow(smoothstep(roomSize.x*1.1, roomSize.x*0.5, abs(traceinf.pos.x)), 2.);\n            \n            if (inside)\n                glassf*= getGlassAbsColor(distance(pos, traceinf.pos), glassMat.col_vol);\n            glassf*= glassMat.col_fil;\n            \n            col+= clamp(traceinf.col*glassf, 0., 1.);\n\n            ray = ray_r;\n        }\n        if (traceinf.objnr==SKY_OBJ)\n        {\n            break;\n        }\n        if (traceinf.objnr==SUPPORT_OBJ || traceinf.objnr==SCREW_OBJ)\n        {\n            vec3 metalcol = (traceinf.objnr==SCREW_OBJ?screw_color:support_color);\n            refray = reflect(ray, traceinf.norm);\n           \n            float rf = traceinf.objnr==SCREW_OBJ?0.45*getScrewV(traceinf.pos):0.9;\n            traceinf = trace0(traceinf.pos, refray, maxdist*0.5, false);\n            traceinf.col*= 0.2 + 0.8*pow(smoothstep(roomSize.x*1.1, roomSize.x*0.5, abs(traceinf.pos.x)), 2.);\n           \n            col = clamp(mix(col, metalcol*traceinf.col, rf*glassf), 0., 1.);\n            glassf*= rf*metalcol;\n            col+= glassf*getFilamentHalo(traceinf.pos, refray);\n            ray = refray;\n        }\n        #ifdef floor_reflection        \n        if (traceinf.objnr==FLOOR_OBJ)\n        {\n            refray = reflect(ray, traceinf.norm);\n           \n            float rf = fresnel(ray, traceinf.norm, 1.7);\n            traceinf = trace0(traceinf.pos, refray, maxdist*0.5, false);\n            traceinf.col*= 0.2 + 0.8*pow(smoothstep(roomSize.x*1.1, roomSize.x*0.5, abs(traceinf.pos.x)), 2.);\n           \n            col = clamp(mix(col, traceinf.col, rf*glassf), 0., 1.);\n            \n            glassf*= rf;\n            col+= glassf*getFilamentHalo(traceinf.pos, refray);\n            ray = refray;\n        }        \n        #endif\n    }\n    \n    #ifdef doors\n    col*= 0.2 + 0.8*pow(smoothstep(roomSize.x*1.1, roomSize.x*0.5, abs(pos0.x)), 2.);\n    #endif\n    \n    col = combineCol(col, fhalo);\n    \n  \treturn vec4(col, 1.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{   \n    init(iTime);\n    cut = get_cut();\n    lamps[0].color = powerToRGB(get_power());\n    lamps[0].intensity = pow(get_power(), 1.6);\n    setCamera();\n    \n    // Antialiasing\n    #ifdef antialias\n    vec4 vs = vec4(0.);\n    for (aaj=0;aaj<aasamples ;aaj++)\n    {\n       float oy = float(aaj)*aawidth/max(float(aasamples-1), 1.);\n       for (aai=0;aai<aasamples ;aai++)\n       {\n          float ox = float(aai)*aawidth/max(float(aasamples-1), 1.);\n          vs+= render(fragCoord + vec2(ox, oy));\n       }\n    }\n    fragColor = vs/vec4(aasamples*aasamples);\n    #else\n    fragColor = vec4(render(fragCoord));\n    #endif\n}","name":"Image","description":"","type":"image"},{"outputs":[],"inputs":[],"code":"/*\n\"Incandescent light bulb\" by Emmanuel Keller aka Tambako - October 2019\nLicense Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\nContact: tamby@tambako.ch\n*/\n\n\n#define pi 3.14159265359\n#define ZERO int(min(iTime,0.))\n\n// Switches, you can play with them!\n#define specular\n//#define shadow\n#define floor_reflection\n#define parquet\n#define doors\n//#define wall_bump\n\nstruct Lamp\n{\n  \tvec3 position;\n  \tvec3 color;\n  \tfloat intensity;\n  \tfloat attenuation;\n};\n    \nstruct TransMat\n{\n    vec3 col_vol;\n    vec3 col_dif;\n    vec3 col_fil;\n    vec3 col_dev;\n    float specint;\n    float specshin;\n    float ior;\n};\n\nstruct RenderData\n{\n  \tvec3 col;\n  \tvec3 pos;\n  \tvec3 norm;\n  \tint objnr;\n};\n   \n// Every object of the scene has its ID\n#define SKY_OBJ       0\n#define FLOOR_OBJ     1\n#define GLASS_OBJ     2\n#define SUPPORT_OBJ   3\n#define SCREW_OBJ     4\n#define FILAMENT_OBJ  5\n#define ROOM_OBJ      6\n#define BLAMP_OBJ     7\n\n// Antialias. Change from 1 to 2 or more AT YOUR OWN RISK! It may CRASH your browser while compiling!\n//#define antialias\nconst float aawidth = 0.8;\nconst int aasamples = 3;\n\n// Ambient light\nconst vec3 ambientColor = vec3(1.);\nconst float ambientint = 0.13;\n\n// Specular options\nconst float specint = 0.18;\nconst float specshin = 250.;\n\n// Shadow options\nconst float shi = 0.8;\n\n// Tracing options\nconst float normdelta = 0.0004;\nconst float maxdist = 70.;\nconst int nbref = 12;\n\n// Color options\nconst float gamma = 1.7;\nconst vec3 support_color = vec3(0.95, 0.75, 0.4);\nconst vec3 screw_color = vec3(0.96, 0.98, 1.);\nconst vec3 filament_color = vec3(0.1);\nconst vec3 floor_color = vec3(0.98, 0.87, 0.63);\nconst vec3 walls_color = vec3(0.8, 0.83, 0.85);\n//const vec3 walls_color = vec3(0.8, 0., 0.);\nconst vec3 ceiling_color = vec3(1.1);\nconst vec3 dframe_color = vec3(0.76, 0.6, 0.45);\nconst vec3 blampColor = vec3(0.75, 0.87, 1.);\n\n// Geometry options\nconst vec3 bulbPos = vec3 (0., 3.1, 0.);\nconst vec3 roomSize = vec3(18., 6.5, 18.);\nconst vec3 doorSize = vec3(2.5, 4.8, 0.6);\nconst vec2 dfSize = vec2(0.17, 0.07);\nconst vec2 psize = vec2(2.4, 0.3);\nvec3 blampPos = vec3(0.5*roomSize.x - 1., 0.2, 0.5*roomSize.z - 1.);\n\n// Lamps options\nLamp lamps[2];\n\n// Campera options\nvec3 campos = vec3(0., 0., 8.);\nvec3 camtarget;\nvec3 camdir = vec3(0., 0., 0.);\nfloat fov = 4.5;\n\nTransMat glassMat;\n\nint aai;\nint aaj;\n\nbool cut;\nfloat zoom;\n\nconst vec2 addr_zoom = vec2(5., 5.);\nconst vec2 addr_power = vec2(10., 5.);\nconst vec2 addr_cut = vec2(15., 5.);\nconst vec2 addr_blink = vec2(20., 5.);\n\nvec3 powerToRGB(float power)\n{\n   power = pow(power, 0.6);\n   vec3 col;\n   col.r = smoothstep(0., 0.36, power);\n   col.g = smoothstep(0.08, 0.85, power);\n   col.b = smoothstep(0.27, 1., power);\n    \n   return col;\n}\n\nvoid init(float time)\n{   \n    lamps[0] = Lamp(bulbPos + vec3(0., 0.092, 0.), vec3(1.), 0.9, 0.01);\n    lamps[1] = Lamp(blampPos, blampColor, 0.7, 0.01);\n    \n    glassMat = TransMat(vec3(0.93, 0.99, 0.86),\n                        vec3(0.01, 0.02, 0.02),\n                        vec3(0.998),\n                        vec3(0.3, 0.5, 0.9),\n                        0.25,\n                        45.,\n                        1.47); \n    \n    //camtarget = bulbPos + vec3(0., 0.09, 0.);\n    camtarget = bulbPos + vec3(0., 0.08, 0.);\n}\n\n\nfloat sdRoundBox(vec3 p, vec3 b, float r)\n{\n    vec3 d = abs(p) - b;\n    return length(max(d,0.0)) - r\n         + min(max(d.x,max(d.y,d.z)),0.0);\n}\n\nfloat sdEllipsoid(vec3 p, vec3 r)\n{\n    return (length( p/r ) - 1.0) * min(min(r.x,r.y),r.z);\n}\n\nfloat sdCylinder(vec3 p, vec2 h)\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdTorus(vec3 p, vec2 t)\n{\n    vec2 q = vec2(length(p.xz)-t.x,p.y);\n    return length(q)-t.y;\n}\n\nfloat smin(float a, float b, float k)\n{\n    float h = max(k-abs(a-b),0.0);\n    return min(a, b) - h*h*0.25/k;\n}\n\nfloat smax(float a, float b, float k)\n{\n\tfloat h = clamp( 0.5 + 0.5*(b-a)/k, 0.0, 1.0 );\n\treturn mix( a, b, h ) + k*h*(1.0-h);\n}\n\nvec2 opU(vec2 d1, vec2 d2)\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nvec2 rotateVec(vec2 vect, float angle)\n{\n    vec2 rv;\n    rv.x = vect.x*cos(angle) - vect.y*sin(angle);\n    rv.y = vect.x*sin(angle) + vect.y*cos(angle);\n    return rv;\n}\n\n// 1D hash function\nfloat hash(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 333.33;\n    p *= p + p;\n    return fract(p);\n}\n\n// From https://www.shadertoy.com/view/4sfGzS\nfloat noise(vec3 x)\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    float n = p.x + p.y*157.0 + 113.0*p.z;\n    return mix(mix(mix(hash(n+  0.0), hash(n+  1.0),f.x),\n                   mix(hash(n+157.0), hash(n+158.0),f.x),f.y),\n               mix(mix(hash(n+113.0), hash(n+114.0),f.x),\n                   mix(hash(n+270.0), hash(n+271.0),f.x),f.y),f.z);\n}\n\nfloat getPowerTime(float time)\n{\n    float sv = sin(time*1.3) + 0.8*sin(time*2.4) + 0.6*sin(time*4.25) + 0.52*sin(time*9.7) + 0.38*sin(time*17.3) + 0.26*sin(time*32.7); \n    return smoothstep(-0.8, -0.3, sv);\n}","name":"Common","description":"","type":"common"},{"outputs":[{"channel":0,"id":"4dXGR8"}],"inputs":[{"channel":0,"type":"keyboard","id":"4dXGRr","filepath":"/presets/tex00.jpg","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}},{"channel":1,"type":"buffer","id":"4dXGR8","filepath":"/media/previz/buffer00.png","sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"code":"// This buffer handles the keyboard\n\nconst float KEY_C\t\t= 67.5/256.0;\nconst float KEY_D\t\t= 68.5/256.0;\nconst float KEY_F\t\t= 70.5/256.0;\nconst float KEY_V\t\t= 86.5/256.0;\nconst float KEY_LEFT  = 37.5/256.0;\nconst float KEY_RIGHT = 39.5/256.0;\nconst float KEY_PG_UP   = 33.5/256.0;\nconst float KEY_UP      = 38.5/256.0;\nconst float KEY_PG_DOWN = 34.5/256.0;\nconst float KEY_DOWN    = 40.5/256.0;\n\nconst float min_zoom = 0.15;\nconst float max_zoom = 50.;\nconst float zfact = 1.008;\nconst float tStep = 1.;\nconst float pStep = 0.02;\n\nbool isKeyPressed(float key)\n{\n\treturn texture(iChannel0, vec2(key, 0.25) ).x > .0;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{ \n    float zoom = texture(iChannel1, (addr_zoom + vec2(0.5, 0.5))/iResolution.xy).r;\n    if (zoom==0.)\n         zoom = 2.5;\n    \n    if (isKeyPressed(KEY_UP) && zoom<max_zoom)\n       zoom*= zfact;\n    \n    if (isKeyPressed(KEY_DOWN) && zoom>min_zoom)\n       zoom/= zfact;\n    \n    if (isKeyPressed(KEY_PG_UP) && zoom<max_zoom)\n       zoom*= pow(zfact, 8.);\n    \n    if (isKeyPressed(KEY_PG_DOWN) && zoom>min_zoom)\n       zoom/= pow(zfact, 8.); \n    \n    if (fragCoord==addr_zoom + vec2(0.5, 0.5))\n       fragColor = vec4(zoom, 0., 0., 0.);\n    \n    float power = texture(iChannel1, (addr_power + vec2(0.5, 0.5))/iResolution.xy).r;\n    if (power==0.)\n         power = 1.;    \n    \n    if (isKeyPressed(KEY_LEFT) && power>0.)\n       power-= pStep;\n    \n    if (isKeyPressed(KEY_RIGHT) && power<1.)\n       power+= pStep;\n    \n    if (fragCoord==addr_power + vec2(0.5, 0.5))\n       fragColor = vec4(power, 0., 0., 0.);\n    \n    bool cutSupport = texture(iChannel1, (addr_cut + vec2(0.5, 0.5))/iResolution.xy).r==0.;\n    \n    if (isKeyPressed(KEY_C))\n       cutSupport = true;\n    \n    if (isKeyPressed(KEY_D))\n       cutSupport = false;\n    \n    if (fragCoord==addr_cut + vec2(0.5, 0.5))\n       fragColor = vec4(cutSupport?0.:1., 0., 0., 0.);\n    \n    bool blinking = texture(iChannel1, (addr_blink + vec2(0.5, 0.5))/iResolution.xy).r==0.;\n    \n    if (isKeyPressed(KEY_F))\n       blinking = true;\n    \n    if (isKeyPressed(KEY_V))\n       blinking = false;\n    \n    if (fragCoord==addr_blink + vec2(0.5, 0.5))\n       fragColor = vec4(blinking?0.:1., 0., 0., 0.);      \n}","name":"Buffer A","description":"","type":"buffer"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":true,"mFlagMultipass":true,"mFlagMusicStream":false},"info":{"id":"3sy3DG","date":"1571259999","viewed":355,"name":"Incandescent light bulb","username":"TambakoJaguar","description":"This is my try at a realistic incandescent light bulb.\nUse the mouse to turn around.\nKeyboard:\nUP/DOWN or PGUP/PGDOWN to change the zoom\nLEFT/RIGHT to change the light power\nC/D cut the support and see the whole bulb\nF/V to enable/disable the blink mode","likes":30,"published":1,"flags":48,"usePreview":1,"tags":["lightbulb"],"hasliked":0,"parentid":"","parentname":""}}