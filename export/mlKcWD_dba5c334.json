{"ver":"0.1","info":{"id":"mlKcWD","date":"1700246352","viewed":9,"name":"Fingerprints on glass","username":"Chromaney","description":"Shader for an effect of fingerprints on the back side of \"glass\".","likes":0,"published":1,"flags":32,"usePreview":0,"tags":["2d","organic","noisebased"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Shader for an effect of fingerprints on the back side of \"glass\".\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec2 xy = fragCoord / iResolution.xy;\n    vec2 xyCorrCoeff = iResolution.xy / max(iResolution.x, iResolution.y);\n\n    vec3 col = texture(iChannel1, xy).xyz;\n    vec3 colTrail = texture(iChannel2, xy).xyz;\n    col = max(col, 0.75 * colTrail);\n    \n    vec3 lightL = normalize(vec3(0.02 * cos(TAU * 5.0 * scTime), 0.02 * sin(TAU * 5.0 * scTime), 1.0));\n    \n    vec2 noise = 0.3 * (textureLod(iChannel0, xy * 0.2 + 0.1, 2.0).rg - 0.5);\n    vec3 lightN = normalize(vec3(noise, 1.0));\n    vec3 lightV = normalize(vec3(0.1 * (vec2(0.5, 0.5) - xy) * xyCorrCoeff, 1.0));\n    vec3 lightH = normalize(lightL + lightV);\n    float specInt = dot(lightN, lightH);\n    vec3 specCol = 0.25 * pow(max(specInt, 0.0), 8000.0) * SPEC_COL;\n    \n    col = mix(col, DIFF_COL, 0.25) + specCol;\n    fragColor = vec4(col, 1.0);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define TAU 6.2831853\n#define SAMPLE_LOD 3.0\n#define PRINT_COL vec3(1.0, 0.03, 0.03)\n#define DIFF_COL vec3(0.2, 0.6, 1.0)\n#define SPEC_COL vec3(0.6, 0.8, 1.0)\n#define SAMPLE_NOISE(coord) textureLod(iChannel0, (iResolution.x > iResolution.y) ? coord.xy : coord.yx, SAMPLE_LOD)\n#define scTime (iTime / 100.0)\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Buffer for uniform (hopefully) RGBA noise.\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec4 col = vec4(0.0);\n    if (iFrame == 0){\n        uint k = 835171995U;\n        uint a = uint(fragCoord.x);\n        uint b = uint(fragCoord.y);\n\n        uvec4 res = uvec4(a + k, b + k, a * b, k);\n        res = (res.zxwy * k + res.ywxz) ^ res.w;\n        res = (res.zxwy * k + res.ywxz) ^ res.z;\n        res = (res.zxwy * k + res.ywxz) ^ res.y;\n        res = (res.zxwy * k + res.ywxz) ^ res.x;\n\n        col = vec4(res.xyzw) / float(0xffffffffU);\n    } else {\n        col = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    }\n    fragColor = col;\n}\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// Buffer for fractal noise.\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 noiseUV = fragCoord / iResolution.xy;\n    \n    vec4 col = vec4(0.0);\n    if (iFrame == 0){\n        float randVal = iDate.w;\n        float scale = 1.0;\n        float colScale = 0.0;\n        for (int i = 0; i < 5; i ++){\n            colScale += 1.0 / scale;\n            \n            float baseShift = scale + randVal;\n            vec2 shift = vec2(sin(5.781 * baseShift), cos(5.781 * baseShift));\n            vec4 noise4 = textureLod(iChannel0, noiseUV * scale + shift, 5.0);\n            col += (32.0 * (noise4 - 0.5) + 0.5) / scale;\n            scale *= 2.0;\n        }\n        col /= colScale;\n    } else {\n        col = texture(iChannel1, uv);\n    }\n    fragColor = col;\n}\n","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"// Buffer for \"fingerprints\".\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec2 xy = fragCoord / iResolution.xy;\n    vec2 xyCircScale = iResolution.xy / max(iResolution.x, iResolution.y);\n    \n    xy += (textureLod(iChannel0, xy, SAMPLE_LOD).xy - 0.5) * 0.02;\n    \n    vec3 col = vec3(0.0, 0.0, 0.0); // changes in loop (accumulator)\n    float phase = 3.415 * scTime; // changes in loop\n    \n    for (float texFltIdx = 0.0; texFltIdx < 1.0 - 0.01; texFltIdx += 0.2){\n        // shift values mod 0.2: 0.029, 0.122, 0.173, 0.078\n        \n        vec3 xyc0 = SAMPLE_NOISE(vec2(scTime * 1.0, 0.029 + texFltIdx)).xyz;\n        \n        float colOsc = pow(0.5 + 0.5 * cos(TAU * phase), 6.0); // max when phase = 0.0 + n\n        float stage = floor(phase + 0.5); // changes when phase = 0.5 + n - furthest from above\n        float colMixed = mix(xyc0.z, colOsc, 0.8);\n\n        vec4 pertMtx = (SAMPLE_NOISE(vec2(scTime * 0.73, 0.722 + texFltIdx)) - 0.5) * 0.3;\n        mat2 shape = mat2(1.0 + pertMtx.x, pertMtx.y, pertMtx.z, 1.0 + pertMtx.w);\n        vec2 dir = shape * (xy - xyc0.xy) * xyCircScale * vec2(1.5, 1.0);\n        float dist = length(dir);\n        float linGrad = (0.1 - dist) / 0.1;\n\n        vec4 frqPh = SAMPLE_NOISE(vec2(stage * 0.379, 0.173 + texFltIdx));\n        frqPh.xy = round(frqPh.xy * vec2(5.0, 10.0) + vec2(2.5, 19.5));\n        vec2 circDeform = vec2(0.03, 0.02) * sin(frqPh.xy * atan(dir.y, dir.x) + TAU * frqPh.zw);\n        float circles = linGrad + (circDeform.x + circDeform.y) / (1.0 + 5.0 * linGrad);\n        \n        circles += (SAMPLE_NOISE(vec2(stage * 0.592, 0.478 + texFltIdx) + dir).x - 0.5) * 0.5;\n        \n        circles = pow(sin(TAU * 14.0 * circles) * 0.5 + 0.5, 4.0);\n        circles *= smoothstep(0.2, 1.0, colMixed);\n        \n        float filled = pow(max(linGrad, 0.0), 0.5) * 0.7;\n        float circFillMix = circles + filled - circles * filled;\n        col += smoothstep(0.0, 0.1, 0.1 - dist) * circFillMix * PRINT_COL * colMixed;\n        \n        phase += 0.2;\n    }\n    \n    fragColor = vec4(col, 1.0);\n}\n","name":"Buffer C","description":"","type":"buffer"},{"inputs":[{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"// Buffer for \"fingerprint\" traces.\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec2 xy = fragCoord / iResolution.xy;\n    \n    vec3 col = vec3(0.0, 0.0, 0.0);\n    if (iFrame > 0){\n        col = texture(iChannel1, xy).xyz;\n    }\n    \n    vec3 colAdd = texture(iChannel0, xy).rgb;\n    \n    col *= 0.99;\n    col = mix(col + 1.0 * colAdd, colAdd + 0.25 * col, pow(colAdd, vec3(0.5)));\n    \n    fragColor = vec4(col, 1.0);\n}\n","name":"Buffer D","description":"","type":"buffer"}]}