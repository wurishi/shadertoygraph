{"ver":"0.1","info":{"id":"3tt3WB","date":"1577454099","viewed":268,"name":"Nintendo 64 Logo","username":"Tara","description":"Unfinished\n\nReference: https://www.youtube.com/watch?v=FoNf7senfuk","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","logo","nintendo","n64","rare"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// TODO: Use the actual distance fields for advancing the ray!\n// TODO: We could actually use ray tracing instead maybe.\n// TODO: Fix the letter \"I\".\n\n//#define RENDER_AABB\n//#define RENDER_DEPTH\n//#define ENABLE_FOG\n//#define ANIMATE_CUBES\n\nconst int max_shadow_ray_samples = 32;\nconst int max_ray_samples = 128;\t// TODO: Rename to \"max_view_ray_samples\".\nconst float max_view_distance = 5.0;\t// TODO: Adjust!\n\nconst vec3 color_green = vec3(0.2, 0.8, 0.2);\n\n\nconst vec3 block_dimensions = vec3(0.41, 2.3, 0.41);\nconst vec3 block_spacing = vec3(0.0, 0.0, 7.0);\n\nconst float STEP_SIZE = 0.01;\n\n// Reference: https://s3.amazonaws.com/zeldaspeedruns/app/public/system/images/17/original/N64%20logo%20change.jpg?1397769669\n\n\n//const int CHARACTER_A = 65;\n\nconst int CHARACTER_N = 78;\nconst int CHARACTER_I = 73;\nconst int CHARACTER_T = 84;\nconst int CHARACTER_E = 69;\nconst int CHARACTER_D = 68;\nconst int CHARACTER_O = 79;\nconst int CHARACTER_SPACE = 32;\nconst int CHARACTER_4 = 52;\nconst int CHARACTER_6 = 54;\n\n\n// Source: https://github.com/hpicgs/cgsee/wiki/Ray-Box-Intersection-on-the-GPU\nstruct Ray\n{\n    \n    vec3 origin;\n    vec3 direction;\n    vec3 inv_direction;\n    int sign[3];\n};\n\nRay create_ray(vec3 o, vec3 d)\n{\n    Ray ray;\n    ray.origin = o;\n    ray.direction = d;\n    ray.inv_direction = vec3(1.0) / ray.direction;\n    ray.sign[0] = (ray.inv_direction.x < 0.0) ? 1 : 0;\n    ray.sign[1] = (ray.inv_direction.y < 0.0) ? 1 : 0;\n    ray.sign[2] = (ray.inv_direction.z < 0.0) ? 1 : 0;\n    \n    return(ray);    \n}\n\nvoid intersection_distances_no_if(\n    in Ray ray, in vec3 aabb[2],\n    out float tmin, out float tmax)\n{\n    float tymin, tymax, tzmin, tzmax;\n    tmin = (aabb[ray.sign[0]].x - ray.origin.x) * ray.inv_direction.x;\n    tmax = (aabb[1-ray.sign[0]].x - ray.origin.x) * ray.inv_direction.x;\n    tymin = (aabb[ray.sign[1]].y - ray.origin.y) * ray.inv_direction.y;\n    tymax = (aabb[1-ray.sign[1]].y - ray.origin.y) * ray.inv_direction.y;\n    tzmin = (aabb[ray.sign[2]].z - ray.origin.z) * ray.inv_direction.z;\n    tzmax = (aabb[1-ray.sign[2]].z - ray.origin.z) * ray.inv_direction.z;\n    tmin = max(max(tmin, tymin), tzmin);\n    tmax = min(min(tmax, tymax), tzmax);\n    // post condition:\n    // if tmin > tmax (in the code above this is represented by a return value of INFINITY)\n    //     no intersection\n    // else\n    //     front intersection point = ray.origin + ray.direction * tmin (normally only this point matters)\n    //     back intersection point  = ray.origin + ray.direction * tmax\n}\n\n\n// Source: https://iquilezles.org/articles/distfunctions\nfloat repeated_box(vec3 p, vec3 c)\n{\n    vec3 q = mod(p, c) - 0.5 * c;\n    //return primitve(q);\n    return(0.0);\n}\n\n// Source: https://iquilezles.org/articles/distfunctions\nfloat signed_distance_box_repeating(vec3 p, vec3 box_position, vec3 box_dimensions, vec3 spacing)\n{\n    // Translation:\n    p -= box_position;\n    \n    // Repetition:\n    //const vec3 c = vec3(0.0, 0.0, 2.5);\n    //p = mod(p, c) - 0.5 * c;\n    p = mod(p, spacing) - 0.5 * spacing;\n    \n    \n\tvec3 d = abs(p) - box_dimensions;\n\treturn min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\n// Source: https://iquilezles.org/articles/distfunctions\nfloat signed_distance_box(vec3 p, vec3 box_position, vec3 box_dimensions)\n{\n    // Translation:\n    p -= box_position;\n        \n\tvec3 d = abs(p) - box_dimensions;\n\treturn min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat signed_distance_plane(vec3 p, vec3 plane_normal, float plane_distance)\n{\n    // Project the point onto the plane:\n    return(dot(plane_normal, p) + plane_distance);\n}\n\nvec3 get_surface_color(vec3 point_of_intersection, float surface_height)\n{\n    \n    if(abs(point_of_intersection.x) - surface_height > 0.01)\n    {\n        return(vec3(0.1, 0.17, 1.0) * 5.0);\n    }\n    else if(abs(point_of_intersection.x) - surface_height > 0.01)\n    {\n        return(vec3(0.5, 0.2, 0.2) * 5.0);\n    }\n\n    // TODO: Fix the coordinate offset!\n    float cube_corner_step_z = step(mod(point_of_intersection.z - 0.48, 1.0 / 3.0), 0.025);\n    float cube_corner_step_y = step(mod(point_of_intersection.y - 0.48, 1.0 / 3.0), 0.025);\n\n    vec3 cube_corner_glow = vec3(0.0);\n    cube_corner_glow = mix(cube_corner_glow, vec3(0.5, 0.08, 0.08) * 3.0, cube_corner_step_z);\n    cube_corner_glow = mix(cube_corner_glow, vec3(0.5, 0.08, 0.08) * 3.0, cube_corner_step_y);\n\n    return(cube_corner_glow);\n\n    return(vec3(0.0));\n    return(vec3(surface_height));\n}\n\n/*\nvec3 opTx( vec3 p, mat4 m )\n{\n    vec3 q = inverse(m)*p;\n    return primitive(q);\n}\n*/\n\nvec3 rotate_around_x(vec3 p, float angle)\n{\n    float cs = cos(angle);\n    float sn = sin(angle);\n    \n    mat3 rotation_matrix;\n    rotation_matrix[0] = vec3(cs, -sn, 0.0);\n    rotation_matrix[1] = vec3(sn, cs, 0.0);\n    rotation_matrix[2] = vec3(0.0, 0.0, 1.0);\n    \n    \n    // Shearing:\n    //rotation_matrix;\n    rotation_matrix[0] = vec3(1.0, 0.0, 0.0);\n    rotation_matrix[1] = normalize(mix(vec3(0.0, 1.0, 0.0), vec3(1.0, 0.0, 0.0), 0.3));\n    rotation_matrix[2] = vec3(0.0, 0.0, 1.0);\n        \n    return(inverse(rotation_matrix) * p);\n} \n\nvec3 shear_y(vec3 p, vec3 start, vec3 end, float factor)\n{\n    mat3 rotation_matrix;\n    rotation_matrix[0] = vec3(1.0, 0.0, 0.0);\n    \n    // TODO: PERFORMANCE: Remove normalization!\n    rotation_matrix[1] = normalize(mix(start, end, factor)) * (1.0 + factor * factor);\n    rotation_matrix[2] = vec3(0.0, 0.0, 1.0);\n        \n    return(inverse(rotation_matrix) * p);\n} \n\nvec3 rotate_around_y(vec3 p, float angle)\n{\n    float cs = cos(angle);\n    float sn = sin(angle);\n    \n    mat3 rotation_matrix;\n    rotation_matrix[0] = vec3(cs, 0.0, -sn);\n    rotation_matrix[1] = vec3(0.0, 1.0, 0.0);\n    rotation_matrix[2] = vec3(sn, 0.0, cs);\n        \n    return(inverse(rotation_matrix) * p);\n} \n\nfloat get_geometry_distance(vec3 p, vec3 eye_position)\n{\n    // TODO: PERFORMANCE: Use tiled boxes as much as possible instead?\n    // TODO: PERFORMANCE: Do a ray intersection to the logo's bounding box first.\n    \n    //const float floor_position_y = -2.0;\n    \n    \n    const vec3 floor_normal = normalize(vec3(0.0, 1.0, 0.0));\n    const float floor_distance = -3.0;\n    \n    // Project the point onto the plane:\n    float smallest_distance = 999999.9;\n  \n        \n    \n    // Vertical cubes:\n\tsmallest_distance = min(smallest_distance, signed_distance_box(p, vec3(-1.0, 0.0, 1.0), block_dimensions));\n\tsmallest_distance = min(smallest_distance, signed_distance_box(p, vec3(1.0, 0.0, 1.0), block_dimensions));\n    smallest_distance = min(smallest_distance, signed_distance_box(p, vec3(1.0, 0.0, -1.0), block_dimensions));\n    smallest_distance = min(smallest_distance, signed_distance_box(p, vec3(-1.0, 0.0, -1.0), block_dimensions));\n    \n    // Rotated cubes:\n    //const float rotation_angle = 0.3;\n    const float rotation_angle = 0.485;\n    mat3 rotation_matrix;\n    /*\n    mat3 rotation_matrix = mat3(cos(rotation_angle), sin(rotation_angle), 0.0,\n                               \tcos(rotation_angle - 1.57079632679), sin(rotation_angle - 1.57079632679), 0.0,\n                                0.0, 0.0, 1.0);\n    */\n    /*\n    rotation_matrix[0] = vec3(cos(rotation_angle), sin(rotation_angle), 0.0);\n    rotation_matrix[1] = vec3(cos(rotation_angle - 1.57079632679), sin(rotation_angle - 1.57079632679), 0.0);\n    rotation_matrix[2] = vec3(0.0, 0.0, 1.0);\n    */\n    \n    float cs = cos(rotation_angle);\n    float sn = sin(rotation_angle);\n    rotation_matrix[0] = vec3(cs, -sn, 0.0);\n    rotation_matrix[1] = vec3(sn, cs, 0.0);\n    rotation_matrix[2] = vec3(0.0, 0.0, 1.0);\n    \n    mat4 rotation_matrix2;\n    rotation_matrix2[0] = vec4(cos(rotation_angle), sin(rotation_angle), 0.0, 0.0);\n    rotation_matrix2[1] = vec4(cos(rotation_angle - 1.57079632679), sin(rotation_angle - 1.57079632679), 0.0, 0.0);\n    rotation_matrix2[2] = vec4(0.0, 0.0, 1.0, 0.0);\n    rotation_matrix2[3] = vec4(0.0, 0.0, 0.0, 1.0);\n    \n    const float PI = 3.1415926535897932384626433832795;\n    \n    // TODO: Instead just use shearing?\n    vec3 rotated_p1 = shear_y(p, vec3(0.0, 1.0, 0.0), vec3(1.0, 0.0, 0.0), 0.3);\n    vec3 rotated_p2 = shear_y(p, vec3(0.0, 1.0, 0.0), vec3(-1.0, 0.0, 0.0), 0.3);\n    vec3 rotated_p3 = shear_y(p, vec3(0.0, 1.0, 0.0), vec3(0.0, 0.0, 1.0), 0.3);\n    vec3 rotated_p4 = shear_y(p, vec3(0.0, 1.0, 0.0), vec3(0.0, 0.0, -1.0), 0.3);\n     \n    vec3 rotated_p_side = (rotation_matrix * p.zyx).zyx;\n    //rotated_p_side.x = -rotated_p_side.x;\n    \n    // TODO: Fix rotations.\n    \n    //rotated_p = (inverse(rotation_matrix2) * vec4(p, 1.0)).xyz;\n    \n    //smallest_distance = min(smallest_distance, signed_distance_box(rotated_p1, vec3(1.0, 0.1, 0.0), block_dimensions + vec3(0.0, 0.12, 0.0)));\n\tsmallest_distance = min(smallest_distance, signed_distance_box(rotated_p1, vec3(0.0, 0.0, -1.0), block_dimensions + vec3(0.0, 0.0, 0.0)));\n\t\n    smallest_distance = min(smallest_distance, signed_distance_box(rotated_p2, vec3(0.0, 0.0, 1.0), block_dimensions + vec3(0.0, 0.0, 0.0)));\n\t\n    smallest_distance = min(smallest_distance, signed_distance_box(rotated_p3, vec3(1.0, 0.0, 0.0), block_dimensions + vec3(0.0, 0.0, 0.0)));\n\t\n    smallest_distance = min(smallest_distance, signed_distance_box(rotated_p4, vec3(-1.0, 0.0, 0.0), block_dimensions + vec3(0.0, 0.0, 0.0)));\n\t\n    \n    //smallest_distance = min(smallest_distance, signed_distance_box(rotated_p2, vec3(0.0, 0.0, -1.0), block_dimensions + vec3(0.0, 0.12, 0.0)));\n\t//smallest_distance = min(smallest_distance, signed_distance_box(rotated_p3, vec3(1.0, 0.0, 0.0), block_dimensions + vec3(0.0, 0.12, 0.0)));\n\t//smallest_distance = min(smallest_distance, signed_distance_box(rotated_p4, vec3(-1.0, 0.0, 0.0), block_dimensions + vec3(0.0, 0.12, 0.0)));\n\t//smallest_distance = min(smallest_distance, signed_distance_box(p, vec3(1.0, 0.0, 1.0), block_dimensions));\n    //smallest_distance = min(smallest_distance, signed_distance_box(p, vec3(1.0, 0.0, -1.0), block_dimensions));\n    //smallest_distance = min(smallest_distance, signed_distance_box(p, vec3(-1.0, 0.0, -1.0), block_dimensions));\n    \n    \n    return(smallest_distance);\n}    \n\nfloat compute_ambient_occlusion(vec3 position, vec3 normal, float max_distance, int samples, vec3 eye_position)\n{\n    const float surface_offset = 0.001;\n    const float sample_distance = 0.08;\n    \n    float occlusion = 0.0;\n    \n    //float sample_sum = 0.0;\n    \n    for(int i=0; i<8; ++i)\n    { \n        float sample_offset_distance = surface_offset + float(i) * sample_distance;\n        vec3 sample_position = position + normal * sample_offset_distance;\n        float sample_weight = 1.0 / float(i + 1);\n        //sample_sum += sample_weight;\n        \n        //occlusion += sample_weight * sample_offset_distance - get_geometry_distance(sample_position, eye_position);\n\t\tocclusion += sample_weight * max(sample_offset_distance - get_geometry_distance(sample_position, eye_position), 0.0);\n    }\n    \n    return(1.0 - occlusion);\n}\n\nfloat calculate_shadow(vec3 p, vec3 light_position, vec3 eye_position)\n{    \n    vec3 p_to_light = light_position - p;\n    float p_to_light_distance = length(p_to_light);\n    vec3 n_ray_direction = normalize(p_to_light);\n    \n    p += n_ray_direction * 0.05;\t// Offset\t// TODO: Offset using the normal.\n    \n    float travelled_distance = 0.0;\n    \n    float step_size = p_to_light_distance / float(max_shadow_ray_samples - 1);\t// Incrase the step size so we step over the light.\n        \n    for(int i=0; i<max_shadow_ray_samples; ++i)\n    {\n        travelled_distance += step_size;\n        vec3 sample_point = p + n_ray_direction * travelled_distance;\n        \n        if(get_geometry_distance(sample_point, eye_position) < 0.0)\n        {\n            return(0.0);\n        }\n        \n        if(travelled_distance > p_to_light_distance)\n        {\n            return(1.0);\n        }  \n    }\n    \n    return(0.0);\n}\n\nvec3 calculate_lighting(vec3 p, vec3 eye_position, vec3 light_position, vec3 light_color, vec3 n_normal)\n{\n    float ambient_occlusion = compute_ambient_occlusion(p, n_normal, 0.01, 8, eye_position);\n\n    vec3 p_to_light = light_position - p;\n    vec3 n_light_direction = normalize(p_to_light);\n    vec3 direct_lighting_diffuse = light_color * max(dot(n_light_direction, n_normal), 0.0);\n    float squared_p_to_light_distance = dot(p_to_light, p_to_light);\n    //direct_lighting_diffuse /= squared_p_to_light_distance;\t// Inverse square falloff.\n    \n    // TODO: Add specular.\n    \n    float shadow = 1.0;\n    \n    //if(1.0 / squared_p_to_light_distance > 0.01)\n    {\n    \t//shadow = calculate_shadow(p, light_position, eye_position);\n    }\n            \n    \n    return(shadow * ambient_occlusion * direct_lighting_diffuse);\n\n}  \n\n// Parallax mapping basically:\nvec3 trace_ray(vec3 ray_origin, vec3 ray_direction, inout float depth)\n{\n    \n    /*\n    // Rotate \"ray_origin\":\n    {\n        float cs = cos(iTime);\n        float sn = sin(iTime);\n        \n        mat3 rotation_matrix;\n        rotation_matrix[0] = vec3(cs, 0.0, -sn);\n        rotation_matrix[1] = vec3(0.0, 1.0, 0.0);\n        rotation_matrix[2] = vec3(sn, 0.0, cs);\n        \n        ray_origin = rotation_matrix * ray_origin;\n        ray_direction = rotation_matrix * ray_direction;\n\t}\n    */\n    \n    vec3 eye_position = ray_origin;\n        \n    \n    //float step_size = 0.001;\t// TODO: Base step size on something proper.\n    float step_size = max_view_distance / float(max_ray_samples);\t// TODO: Base step size on something proper.\n    float min_step_size = max_view_distance / float(max_ray_samples);\t// TODO: Base step size on something proper.\n        \n    \n    \n    for(int i=0; i<max_ray_samples; ++i)\n    {\n        float distance_to_nearest_surface = get_geometry_distance(ray_origin, eye_position);\n        step_size = max(distance_to_nearest_surface, STEP_SIZE);\n        \n        //ray_origin += ray_direction * 0.01;\n        //ray_origin += ray_direction * STEP_SIZE;\n        ray_origin += ray_direction * step_size;\n        \n        //depth = distance(ray_origin, eye_position);\t// TODO: Calculate this differently?\n        \n        \n        if(distance_to_nearest_surface <= 0.0)\n        {\n            depth = abs(ray_origin.z - eye_position.z);\n            \n            const float offset = 0.0001;\t// Small enough to hide artifacts but still be correct.\n            \n            vec3 n_normal;\n\t\t\tn_normal.x = get_geometry_distance(ray_origin + vec3(offset, 0.0, 0.0), eye_position) - get_geometry_distance(ray_origin - vec3(offset, 0.0, 0.0), eye_position);            \n\t\t\tn_normal.y = get_geometry_distance(ray_origin + vec3(0.0, offset, 0.0), eye_position) - get_geometry_distance(ray_origin - vec3(0.0, offset, 0.0), eye_position);            \n\t\t\tn_normal.z = get_geometry_distance(ray_origin + vec3(0.0, 0.0, offset), eye_position) - get_geometry_distance(ray_origin - vec3(0.0, 0.0, offset), eye_position);            \n            n_normal = normalize(n_normal);\n            \n            vec3 n_shading_normal;\n            {            \n                const float offset = 0.5;\t// Small enough to hide artifacts but still be correct.\n\n                n_shading_normal.x = get_geometry_distance(ray_origin + vec3(offset, 0.0, 0.0), eye_position) - get_geometry_distance(ray_origin - vec3(offset, 0.0, 0.0), eye_position);            \n                n_shading_normal.y = get_geometry_distance(ray_origin + vec3(0.0, offset, 0.0), eye_position) - get_geometry_distance(ray_origin - vec3(0.0, offset, 0.0), eye_position);            \n                n_shading_normal.z = get_geometry_distance(ray_origin + vec3(0.0, 0.0, offset), eye_position) - get_geometry_distance(ray_origin - vec3(0.0, 0.0, offset), eye_position);            \n                n_shading_normal = normalize(n_shading_normal);\n            }\n            \n            vec3 albedo = vec3(1.0);\n            //vec3 light_position_pink = eye_position - vec3(0.0, 1.0, 2.0);\n            vec3 light_position_pink = eye_position + vec3(0.0, -4.5, -2.0);\n            \n            vec3 light_position_blue = eye_position + vec3(0.0, -1.0, -10.0);\n            \n            vec3 lighting = vec3(0.5);\n            /*\n            lighting += calculate_lighting(ray_origin, eye_position, light_position_pink, light_color_pink, n_normal);\n           \tlighting += calculate_lighting(ray_origin, eye_position, light_position_blue, light_color_blue, n_normal);\n           */\n            const vec3 blue_direction = vec3(0.0, 0.0, 1.0);\n            const vec3 red_direction1 = normalize(vec3(0.0, 0.5, 0.5));\n            const vec3 red_direction2 = normalize(vec3(0.0, 0.5, 0.5));\n            const vec3 red_direction3 = normalize(vec3(-0.5, 0.5, 0.0));\n            const vec3 red_direction4 = normalize(vec3(0.0, 0.5, -0.5));\n            const vec3 red_direction5 = normalize(vec3(-0.5, -0.5, 0.0));\t// Underside 1\n            const vec3 red_direction6 = normalize(vec3(0.5, -0.5, 0.0));\t// Underside 2\n            const vec3 green_direction = normalize(vec3(1.0, 0.0, 0.0));\n            const vec3 green_direction2 = normalize(vec3(0.5, 0.5, 0.0));\n            const vec3 yellow_direction = vec3(0.0, 1.0, 0.0);\n\n            if(abs(dot(n_normal, blue_direction)) > 0.99)\n            {\n                albedo = vec3(0.1, 0.3, 0.8);\n            }\n            if((dot(n_normal, red_direction1)) > 0.9 ||\n              \tdot(n_normal, red_direction5) > 0.9 ||\n              \tdot(n_normal, red_direction6) > 0.9 ||\n               //abs(dot(n_normal, red_direction2)) > 0.9 ||\n               //abs(dot(n_normal, red_direction3)) > 0.9 ||\n               (dot(n_normal, red_direction4)) > 0.9)\n            {\n                albedo = vec3(0.8, 0.0, 0.0);\n            }\n            else if(abs(dot(n_normal, green_direction)) > 0.99  ||\n                    dot(n_normal, green_direction2) > 0.9  ||\n                    abs(dot(n_normal, red_direction2)) > 0.9 ||\n               \t\tabs(dot(n_normal, red_direction3)) > 0.9)\n            {\n                albedo = color_green;\n            }\n            else if(dot(n_normal, yellow_direction) > 0.99)\n            {\n                albedo = vec3(1.0, 0.7, 0.0);\n            }\n\n            // TODO: The normal vector shouldnt rotate!\n            // TODO: Interpolate normals upon intersection!\n            vec3 n_reflection = reflect(n_shading_normal, normalize(ray_direction));\n            //albedo += pow(max(dot(n_reflection, vec3(1.0, 1.0, 1.0)) - 0.5, 0.0), 4.0);\n            albedo += pow(max(dot(n_reflection, normalize(-vec3(0.5, 0.5, 1.0))) - 0.5, 0.0), 4.0) * 15.0;\n            albedo += pow(max(dot(n_reflection, normalize(-vec3(-0.5, 0.5, 1.0))) - 0.5, 0.0), 4.0) * 15.0;\n            \n            //return vec3(shadow);\n            \n            // TODO: I guess we could do some normal rotation to generate the colors instead.\n            //n_normal = pow(n_normal.yzx * 0.5 + vec3(0.5), vec3(10.0));\n            \n            //return vec3(abs(n_normal));\n            //return vec3(n_normal);\n            \n            //return(albedo * lighting);\n            //return(ray_origin);\n            return(albedo * 0.85);\n            \n            \n    \t\treturn(vec3(0.0, 0.5, 0.0));\n        }\n        \n        /*\n        float surface_height = calculate_height(ray_origin);\n        //surface_height = 0.1;\n        if(abs(ray_origin.x) > surface_height)\t// TODO: Do the ABS before entering this loop!\n        {\n            depth = distance(ray_origin, eye_position);\t// TODO: Calculate this differently?\n\n            if(depth >= max_view_distance)\n            {\n                depth = max_view_distance;\n                return(fog_color);\n            }\n\n            return(get_surface_color(ray_origin, surface_height));\n        }\n        */\n    }\n    \n    depth = max_view_distance;\n\n    return(vec3(0.0));\n    return(vec3(0.0, 1.0, 0.0));\n}\n\nvoid rotate_ray(inout vec3 ray_origin, inout vec3 ray_direction)\n{\n    \n    /*\n    // Tilt along X axis:\n    {\n        const float angle = 0.25;\n        float cs = cos(angle);\n        float sn = sin(angle);\n        \n        mat3 rotation_matrix;\n        rotation_matrix[0] = vec3(1.0, 0.0, 0.0);\n        rotation_matrix[1] = vec3(0.0, cs, -sn);\n        rotation_matrix[2] = vec3(0.0, sn, cs);\n        \n        ray_direction = rotation_matrix * ray_direction;\n\t}\n    */\n    \n    // Rotate \"n_ray_direction\":\n    {\n        //const float angle = 0.785398163;\n        const float angle = 0.5;\n        float cs = cos(angle);\n        float sn = sin(angle);\n        \n        mat3 rotation_matrix;\n        rotation_matrix[0] = vec3(1.0, 0.0, 0.0);\n        rotation_matrix[1] = vec3(0.0, cs, -sn);\n        rotation_matrix[2] = vec3(0.0, sn, cs);\n        \n        ray_direction = rotation_matrix * ray_direction;\n\t}\n\n    // Rotate \"ray_origin\":\n    {\n        float cs = cos(-iTime);\n        float sn = sin(-iTime);\n\n        mat3 rotation_matrix;\n        rotation_matrix[0] = vec3(cs, 0.0, -sn);\n        rotation_matrix[1] = vec3(0.0, 1.0, 0.0);\n        rotation_matrix[2] = vec3(sn, 0.0, cs);\n\n        ray_origin = rotation_matrix * ray_origin;\n        ray_direction = rotation_matrix * ray_direction;\n    }\n}\n\nbool intersect_aabb(vec3 ray_origin, vec3 n_ray_direction, out vec3 adjusted_ray_origin)\n{\n    Ray ray = create_ray(ray_origin, n_ray_direction);\n\n    vec3 aabb[2] = vec3[2](vec3(-1.5, -2.3, -1.5),\n                           vec3(1.5, 2.3, 1.5));\n    \n    float tmin;\n    float tmax;\n\n    intersection_distances_no_if(ray, aabb, tmin, tmax);\n    \n    if(tmax > tmin)\n    {\n        adjusted_ray_origin = ray_origin + n_ray_direction * tmin;\n    \treturn(true);\n    } \n    \n    return(false);\n}\n\nconst int letter_count = 10;\t// \"NINTENDO64\" has 10 letters.\nint nintendo_character_codes[letter_count] = int[letter_count](CHARACTER_N,\n                                                                CHARACTER_I,\n                                                                CHARACTER_N,\n                                                                CHARACTER_T,\n                                                                CHARACTER_E,\n                                                                CHARACTER_N,\n                                                                CHARACTER_D,\n                                                                CHARACTER_O,\n                                                                //CHARACTER_SPACE,\n                                                                CHARACTER_6,\n                                                                CHARACTER_4);\n\nvoid draw_text(out vec4 fragColor, vec2 uv)\n{\n    vec2 textblock_top_left = vec2(0.375, 0.4);\n    vec2 textblock_dimensions = vec2(0.9 - 0.45, 0.6 - 0.4);\n    \n    float letter_width = textblock_dimensions.x / float(letter_count);\n    \n    // TODO: This is a placeholder for the actual text:\n    if(uv.x > textblock_top_left.x && uv.x < textblock_top_left.x + textblock_dimensions.x &&\n       uv.y > textblock_top_left.y && uv.y < textblock_top_left.y + textblock_dimensions.y)\n    {\n        vec2 local_uv = uv - textblock_top_left;\n        int letter_index = int(local_uv.x / letter_width);\n        \n        //vec2 letter_local_uv = vec2(float(letter_index) / float(letter_count), local_uv.y / textblock_dimensions.y);\n        vec2 letter_local_uv = vec2(mod(local_uv.x, letter_width) / letter_width, local_uv.y / textblock_dimensions.y);\n        \n        \n        fragColor = vec4(0.0, 0.2, 1.0, 1.0);\n        fragColor.rgb += vec3(pow(abs(sin((uv.x * 0.8 - uv.y) * 12.0 - iTime * 2.0)), 2.0)) * 0.75 * pow(abs(sin(iTime + uv.x * 10.0)), 2.0);\n       // fragColor.rgb = min(fragColor.rgb, vec3(1.0));\n        \n        \n        vec2 clean_uv = uv;\n    \n        int character_code = nintendo_character_codes[letter_index];\t// Pick the proper character code based on the letter index.\n        vec2 character_coordinate = vec2(character_code % 16, 15 - character_code / 16) / 16.0;\n        \n        vec2 letter_atlas_uv = character_coordinate;\n        \n        const float character_size = 1.0 / 16.0;\n        \n        /*\n        if(clean_uv.x > character_coordinate.x && clean_uv.x < character_coordinate.x + character_size &&\n           clean_uv.y > character_coordinate.y && clean_uv.y < character_coordinate.y + character_size)\n        {\n            //fragColor = texture(iChannel0, clean_uv); \n        }\n        else\n        {\n            fragColor *= vec4(0.25);\n        }\n        */\n        \n        /*\n        fragColor = vec4(0.0);\n\t\tfragColor.z = float(letter_index) / float(letter_count);\n        //fragColor.xy = letter_local_uv;\n\t\t*/\n        \n        if(letter_index > 7)\t// Make the \"64\" smaller:\n        {\n            letter_local_uv *= 2.0;\n            letter_local_uv -= vec2(0.0, 1.0);\n            \n            if(letter_index == 8)\n            {\n            \tletter_local_uv.x -= 0.9;\n            }\n            else if(letter_index == 9)\n            {\n            \tletter_local_uv.x += -0.2;\n            }\n        }\n        \n        // Adjust the font size:\n        // Scrunch vertially:\n        letter_local_uv.y = -0.0 + letter_local_uv.y * 1.25;\t// TODO: Adjust offset. It's not correct!\n        \n            \n        // Zoom horizontally:\n        letter_local_uv.x = 0.3 + letter_local_uv.x * 0.4;\n        \n        if(letter_local_uv.x > 0.0 && letter_local_uv.x < 1.0 &&\n           letter_local_uv.y > 0.0 && letter_local_uv.y < 1.0)\n        {\n            float dist = texture(iChannel0, letter_atlas_uv + letter_local_uv * character_size).w;\n            float val = smoothstep(0.52, 0.48, dist);\n            //val = texture(iChannel0, letter_atlas_uv + letter_local_uv * character_size).x;\n            fragColor *= val;\n        }\n        else\n        {\n           fragColor = vec4(0.0);\n        }\n        \n        if(letter_index == 1)\t// Make the \"64\" smaller:\n        {\n            if((letter_local_uv.x > 0.55)||(letter_local_uv.x < 0.455))\n            {\n           \t\tfragColor = vec4(0.0);\n            }\n        }\n        \n        //fragColor = vec4(0.0);\n        \n        return;\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 clean_uv = fragCoord / iResolution.xy;\n    \n    \n    // Downscale to N64 native resolution:\n    clean_uv = round(clean_uv * vec2(640.0, 480.0)) / vec2(640.0, 480.0);\n     \n    /*\n    \n    fragColor = texture(iChannel0, clean_uv); \n    \n    int character_index = CHARACTER_O;\n    vec2 character_coordinate = vec2(character_index % 16, 15 - character_index / 16) / 16.0;\n    const float character_size = 1.0 / 16.0;\n    if(clean_uv.x > character_coordinate.x && clean_uv.x < character_coordinate.x + character_size &&\n       clean_uv.y > character_coordinate.y && clean_uv.y < character_coordinate.y + character_size)\n    {\n    \t//fragColor = texture(iChannel0, clean_uv); \n    }\n    else\n    {\n        fragColor *= vec4(0.25);\n    }\n        \n    \n    return;\n    */\n    \n    //vec2 half_resolution = vec2(iResolution.x * 0.5, iResolution.y);\n    //vec2 half_resolution = iResolution.xy * 0.5;\n    //vec2 distance_to_screen_center = abs(fragCoord.xy - half_resolution);\n    \n    //float dist = 0.075 + 0.9 * (distance_to_screen_center.x / half_resolution.x);\n    /*\n\tvec2 uv;\n    uv.x = (distance_to_screen_center.x / dist) / iResolution.x;\n    uv.y = ((fragCoord.y - half_resolution.y) / dist) / iResolution.x;\n    \n    uv.x -= iTime * 0.1;\n    */\n    // TODO: Reset camera position so it loops (because we are getting precsion issues!).\n    \n    //vec3 ray_origin = vec3(0.0, 0.0, 0.0);\n    \n    float fov_scale_orthographic = 8.0;\n    \n    // Perspective:\n    //vec3 ray_origin = vec3(0.0, 4.0, 4.0);\n    \n    // Orthographic:\n    \n    fov_scale_orthographic = 16.0;\n    vec3 ray_origin_offset = vec3(4.5, 0.0, 0.0);\t// Offset for positioning the rotating \"N\" on the left side of the text.\n    ray_origin_offset.x += 1.0;\n    \n    vec3 ray_origin = vec3((clean_uv.x - 0.5) * fov_scale_orthographic,\n                           2.5 + (clean_uv.y - 0.5) * fov_scale_orthographic,\n                           4.0) + ray_origin_offset;\n    \n    \n    // TODO: Use orthographic projection?\n    \n    //ray_origin.z -= iTime * 3.0;\n    //vec3 n_ray_direction = normalize(vec3(clean_uv * 2.0 - vec2(1.0), -1.0));\t// OpenGL coordinate system. Z pointing outside the screen.\n    //float fov_scale = 1.0;\n    \n    // Perspective:\n   // vec3 n_ray_direction = (vec3((clean_uv * 1.0 - vec2(0.5)) * fov_scale, -1.0));\t// OpenGL coordinate system. Z pointing outside the screen.\n    \n    // Orthographic:\n    vec3 n_ray_direction = vec3(0.0, 0.0, -1.0);\t// OpenGL coordinate system. Z pointing outside the screen.\n    n_ray_direction += vec3(clean_uv * 2.0 - vec2(1.0), 0.0) * 0.75;\t// Add some perspective (the original seems to do so too).\n    \n    rotate_ray(ray_origin, n_ray_direction);\n\n    \n    vec3 adjusted_ray_origin;\n    if(intersect_aabb(ray_origin, n_ray_direction, adjusted_ray_origin))\n    {\n        ray_origin = adjusted_ray_origin;\n    }\n    else\n    {\n        // Early exit\n        fragColor = vec4(0.0);\n    \tdraw_text(fragColor, clean_uv);\n        return;\n    }\n\n    /*\n    // TODO: Why doesn't the rotation work?\n    // TODO: Add the ability to look around using the mouse.\n    float angle = iTime;\n    n_ray_direction.x = cos(angle) * n_ray_direction.x - sin(angle) * n_ray_direction.z;\n    n_ray_direction.z = sin(angle) * n_ray_direction.x + cos(angle) * n_ray_direction.z;\n    //n_ray_direction = normalize(n_ray_direction);\n    */\n    \n    // TODO: Use view plane depth or actual distance?\n    float depth = max_view_distance;\n    vec3 trace_result = trace_ray(ray_origin, n_ray_direction, depth);\n    \n    float normalized_depth = depth / max_view_distance;\n    \n    \n#ifdef RENDER_DEPTH\n    fragColor = vec4(normalized_depth, normalized_depth, normalized_depth, 1.0);\n    return;\n#endif\n    \n    \n\t///fragColor = vec4(uv,0.5+0.5*sin(iTime),1.0);\n\t//fragColor = vec4(uv.xy, 0.5, 1.0);\n    \n    \n    //fragColor.rgb = calculate_texture(uv);\n    \n    //fragColor.rgb =  trace_result * n_ray_direction;\n    fragColor = vec4(trace_result, 1.0);\n    \n    //fragColor = vec4(normalized_depth, normalized_depth, normalized_depth, 1.0);\n    //return;\n    \n\t//fragColor.rgb = mix(vec3(0.0), fog_color, clamp((1.0 - pow(1.0 - normalized_depth, 2.0)) * 1.0, 0.0, 1.0));\n    //return;\n    \n#ifdef ENABLE_FOG\n    //float inverse_depth = 1.0 - dist;\n    //inverse_depth = 1.0 - normalized_depth;\n\n    //fragColor.rgb = mix(fragColor.rgb, fog_color, clamp(pow(inverse_depth, 1.8) * 1.2, 0.0, 1.0));\n\t//fragColor.rgb = mix(fragColor.rgb, fog_color, clamp(pow(normalized_depth, 1.0) * 1.25, 0.0, 1.0));\n    \n    //float mix_factor = 1.0 - pow(1.0 - normalized_depth, 5.0);\n    float mix_factor = pow(normalized_depth, 1.0);\n    mix_factor = max((mix_factor - 0.25) * 1.5, 0.0);\n    fragColor.rgb = mix(fragColor.rgb, fog_color, mix_factor);\n#endif   \n    \n    \n    \n    // Rotate \"ray_origin\":\n    /*\n    {\n        float cs = cos(iTime);\n        float sn = sin(iTime);\n        \n        mat3 rotation_matrix;\n        rotation_matrix[0] = vec3(cs, 0.0, -sn);\n        rotation_matrix[1] = vec3(0.0, 1.0, 0.0);\n        rotation_matrix[2] = vec3(sn, 0.0, cs);\n        \n        ray_origin = rotation_matrix * ray_origin;\n        n_ray_direction = rotation_matrix * n_ray_direction;\n\t}\n    */\n    \n#ifdef RENDER_AABB\n    fragColor = mix(fragColor, vec4(1.0), 0.5);\n#endif\n    draw_text(fragColor, clean_uv);  \n\n    /*\n    float tmin;\n    float tmax;\n\n    Ray ray = create_ray(ray_origin, n_ray_direction);\n    \n    \n    \n    vec3 aabb[2] = vec3[2](vec3(-1.5, -2.0, -1.5),\n        \t\t\t\t   vec3(1.5, 2.0, 1.5));\n    intersection_distances_no_if(ray, aabb, tmin, tmax);\n    if(tmax > tmin)\n    {\n   \t\tfragColor = mix(fragColor, vec4(1.0), 0.5);\n    }\n    */\n    //fragColor.rgb = vec3(detailed_noise_flat(uv * 50.0));\n    \n    \n   \t//fragColor = vec4(0.0);\n    \n}","name":"Image","description":"","type":"image"}]}