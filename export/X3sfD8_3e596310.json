{"ver":"0.1","info":{"id":"X3sfD8","date":"1728331307","viewed":34,"name":"ChatGPT o1 - Screen Raindrops","username":"crxhvrd","description":"Took me something like one hour to get such result","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["rain","raindrops","rainshader","screenraindrops","raindropsshader"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Generated by ChatGPT o1-preview from scratch\n\n//____________________________________________________________________\n\n//  DO WHAT THE FUCK YOU WANT TO PUBLIC LICENSE\n\n// Copyright (C) 2004 Sam Hocevar <sam@hocevar.net>\n\n// Everyone is permitted to copy and distribute verbatim or modified\n// copies of this license document, and changing it is allowed as long\n// as the name is changed.\n\n//            DO WHAT THE FUCK YOU WANT TO PUBLIC LICENSE\n//   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION\n\n//  0. You just DO WHAT THE FUCK YOU WANT TO.\n\n//____________________________________________________________________\n\n// Functions for generating pseudo-random numbers\nfloat hash(float n) {\n    return fract(sin(n) * 43758.5453123);\n}\n\nvec2 hash2(float n) {\n    return fract(sin(vec2(n, n + 1.0)) * vec2(43758.5453123, 22578.1459123));\n}\n\n// Simple noise function\nfloat noise(vec2 p) {\n    return fract(sin(dot(p, vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Normalize pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord / iResolution.xy;\n\n    // Adjust the aspect ratio\n    float aspectRatio = iResolution.x / iResolution.y;\n    vec2 pos = uv;\n    pos.x *= aspectRatio;\n\n    // Background - use a texture or gradient\n    vec3 background = texture(iChannel0, uv).rgb;\n\n    // Initialize the pixel color\n    vec3 color = background;\n\n    // Parameters for drops\n    const float dropRadius    = 0.015;   // base drop radius\n    const float dropLifetime  = 5.0;     // drop lifetime in seconds\n    const float trailLifetime = 2.0;     // trail lifetime after drop disappears\n    const float totalLifetime = dropLifetime + trailLifetime; // total lifetime of drop and trail\n    const int   maxDrops      = 60;      // maximum number of drops on screen\n\n    // Base drop speed (units per second)\n    float baseDropSpeed = 0.05;\n\n    // Air-to-water refraction index\n    float eta = 1.0 / 1.33;\n\n    // Loop through drops\n    for(int i = 0; i < maxDrops; i++)\n    {\n        // Unique seed for each drop\n        float seed = float(i);\n\n        // Generate random start time for drop within totalLifetime\n        float dropStartTime = hash(seed * 12.9898) * totalLifetime * 5.0;\n\n        // Time passed since the drop appeared\n        float timeSinceStart = iTime - dropStartTime;\n\n        // Adjust timeSinceStart to avoid negative values\n        float periods = 10.0 * totalLifetime * 5.0;\n        timeSinceStart = mod(timeSinceStart + periods, totalLifetime * 5.0);\n\n        float age = mod(timeSinceStart, totalLifetime);\n\n        // Check if the drop or trail is within the total lifetime\n        if(age >= 0.0 && age < totalLifetime)\n        {\n            // Calculate the number of cycles for the drop\n            float cycles = floor(timeSinceStart / totalLifetime);\n\n            // Generate random drop position on the screen considering cycles\n            vec2 initialDropPos = hash2((seed + cycles * 1234.5678) * 34.123);\n            initialDropPos.x *= aspectRatio;\n\n            // Generate slight random size variation for the drop on appearance\n            float sizeVariation = 0.2 + 1.2 * hash((seed + cycles * 1234.5678) * 78.233); // Value between 0.2 and 1.4\n            float initialSize = dropRadius * sizeVariation;\n\n            // Generate random speed variation for this drop\n            float speedVariation = 0.2 + 1.2 * hash((seed + cycles * 1234.5678) * 45.67); // Value between 0.2 and 1.4\n\n            // Calculate the drop and trail speeds for this drop\n            float dropSpeed = baseDropSpeed * speedVariation;\n            float trailSpeed = dropSpeed * 0.5; // Initial trail speed is half the drop speed\n\n            // Calculate the drop position\n            vec2 dropPos = initialDropPos;\n            dropPos.y -= age * dropSpeed; // Drop moves over time\n\n            // Render the drop if it is still alive\n            if(age < dropLifetime)\n            {\n                // Calculate the current drop radius based on its age\n                float size = initialSize * (1.0 - (age / dropLifetime));\n\n                // Check if the drop is too small\n                if(size > 0.0)\n                {\n                    // Calculate the distance to the center of the drop\n                    vec2 toCenter = pos - dropPos;\n\n                    // Generate displacement based on position and seed\n                    float displacementStrength = 0.2; // Adjust this value to change displacement magnitude\n                    float displacement = (noise(toCenter * 100.0 + seed) - 0.5) * displacementStrength * size;\n\n                    // Apply displacement to the distance\n                    float dist = length(toCenter) - displacement;\n\n                    // If the pixel is inside the drop\n                    if(dist < size)\n                    {\n                        // Adjust normal with displacement\n                        vec2 displacedCenter = toCenter * (1.0 + displacement / size);\n                        float z = sqrt(size * size - dist * dist);\n                        vec3 normal3D = normalize(vec3(displacedCenter, z));\n\n                        // Incoming ray direction (looking along Z-axis)\n                        vec3 incident = vec3(0.0, 0.0, -1.0);\n\n                        // Calculate the refracted vector\n                        vec3 refracted = refract(incident, normal3D, eta);\n\n                        // Adjust UV coordinates of the refracted ray\n                        vec2 refractedUV = uv + refracted.xy * 0.5; // Adjust the factor to change distortion\n\n                        // Clamp UV coordinates\n                        refractedUV = clamp(refractedUV, 0.0, 1.0);\n\n                        // Get the refracted color\n                        vec3 refractedColor = texture(iChannel0, refractedUV).rgb;\n\n                        // Calculate the Fresnel coefficient\n                        float fresnel = pow(1.0 - dot(-incident, normal3D), 3.0);\n\n                        // Interpolate between the background and refracted color, ignoring transparency\n                        color = mix(color, refractedColor, (1.0 - fresnel));\n\n                        // Add specular highlights with attenuation\n                        float specular = pow(max(dot(reflect(incident, normal3D), vec3(0.0, 0.0, 1.0)), 0.0), 16.0);\n                        specular *= (1.0 - dist / size); // Attenuate the highlight towards the edges\n                        color += vec3(1.0) * specular * 0.3; // Adjust highlight brightness as needed\n                    }\n                }\n            }\n\n            // Render the drop trail\n            // trailStartY moves down at a slower speed\n            float trailStartY = initialDropPos.y - age * trailSpeed; // Trail start moves down at trailSpeed\n            // trailEndY moves down with the drop\n            float trailEndY = initialDropPos.y - age * dropSpeed; // Trail end moves down with the drop\n\n            // Calculate the height of the trail\n            float trailHeight = trailStartY - trailEndY;\n\n            // Check if the pixel is within the vertical range of the trail\n            if(pos.y >= trailEndY && pos.y <= trailStartY)\n            {\n                // Normalize the pixel position along the trail (from 0 to 1)\n                float yNorm = (pos.y - trailEndY) / max(trailHeight, 0.001);\n\n                // Trail width at the current point, considering the rounding at the base\n                float baseRadius = initialSize * 0.5; // Base radius of the trail (half the drop width)\n                float trailWidth;\n\n                if(yNorm <= baseRadius / trailHeight)\n                {\n                    // Lower part of the trail (semi-circle)\n                    float yOffset = yNorm * trailHeight;\n                    float xLimit  = sqrt(baseRadius * baseRadius - (yOffset - baseRadius) * (yOffset - baseRadius));\n                    trailWidth    = xLimit;\n                }\n                else\n                {\n                    // The rest of the trail (tapering line)\n                    float taper = (1.0 - (yNorm - (baseRadius / trailHeight)) / (1.0 - (baseRadius / trailHeight)));\n                    trailWidth = baseRadius * taper;\n                }\n\n                // Horizontal distance from the center of the trail\n                float xDist = abs(pos.x - dropPos.x);\n\n                // Normalize the horizontal distance (from 0 at the center to 1 at the edge)\n                float xNorm = xDist / trailWidth;\n\n                // Calculate alpha for smooth edge horizontally\n                float edgeAlpha = smoothstep(1.0, 0.0, xNorm);\n\n                // Calculate trail transparency based on age\n                float trailAlpha = 1.0;\n\n                if(age >= dropLifetime)\n                {\n                    // Trail fades after the drop disappears\n                    trailAlpha = 1.0 - ((age - dropLifetime) / trailLifetime);\n                }\n\n                // Total alpha for the trail\n                float totalAlpha = edgeAlpha * trailAlpha;\n\n                // If alpha is greater than zero, apply refraction effects\n                if(totalAlpha > 0.01)\n                {\n                    // Normal for refraction effect\n                    vec3 normal3D = vec3((pos.x - dropPos.x) / trailWidth, 0.0, 1.0);\n\n                    // Incoming ray direction\n                    vec3 incident = vec3(0.0, 0.0, -1.0);\n\n                    // Calculate the refracted vector\n                    vec3 refracted = refract(incident, normal3D, eta);\n\n                    // Adjust UV coordinates of the refracted ray\n                    vec2 refractedUV = uv + refracted.xy * 0.9;\n\n                    // Clamp UV coordinates\n                    refractedUV = clamp(refractedUV, 0.0, 1.0);\n\n                    // Get the refracted color\n                    vec3 refractedColor = texture(iChannel0, refractedUV).rgb;\n\n                    // Add refraction effect to the color considering the total alpha\n                    color = mix(color, refractedColor, 0.7 * totalAlpha);\n\n                    // Additional fading or blurring of the trail (optional)\n                    float fade = 0.5 * (1.0 - yNorm);\n                    color = mix(color, refractedColor, fade * 0.2 * totalAlpha);\n                }\n            }\n        }\n    }\n\n    // Output the color to the screen\n    fragColor = vec4(color, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}