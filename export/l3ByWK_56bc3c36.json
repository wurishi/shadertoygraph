{"ver":"0.1","info":{"id":"l3ByWK","date":"1727719267","viewed":26,"name":"torus and sphere hw2","username":"boomix","description":"sdf2hw","likes":1,"published":1,"flags":32,"usePreview":0,"tags":["texturetorus"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dX3Rr","filepath":"/media/a//media/previz/cubemap00.png","previewfilepath":"/media/ap//media/previz/cubemap00.png","type":"cubemap","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 calcNormal(vec3 p) {\n    vec2 e = vec2(0.001, 0.0);\n    vec3 n = vec3(\n        length(p + e.xyy) - length(p - e.xyy),\n        length(p + e.yxy) - length(p - e.yxy),\n        length(p + e.yyx) - length(p - e.yyx)\n    );\n    return normalize(n);\n}\n\nfloat torus(vec3 p, vec2 t) {\n    vec2 q = vec2(length(p.xz) - t.x, p.y);\n    return length(q) - t.y;\n}\n\nfloat sphere(vec3 p, float r) {\n    return length(p) - r;\n}\n\nfloat opUnion(float d1, float d2) {\n    return min(d1, d2);\n}\n\nfloat map(vec3 p) {\n    float d = 1000.0;\n    \n    for (int i = -2; i <= 2; i++) {\n        for (int j = -2; j <= 2; j++) {\n            vec3 torusPos = vec3(float(i) * 3.0, 0.0, float(j) * 3.0);\n            \n            float time = iTime * 2.0 + float(i * j);\n            float bounce = abs(sin(time)) * 1.5;\n            vec3 spherePos = torusPos + vec3(0.0, bounce, 0.0);\n            \n            float dTorus = torus(p - torusPos, vec2(1.0, 0.3));\n            float dSphere = sphere(p - spherePos, 0.3);\n            \n            d = opUnion(d, opUnion(dTorus, dSphere));\n        }\n    }\n    \n    return d;\n}\n\nvec3 lighting(vec3 p, vec3 normal, vec3 lightPos) {\n    vec3 lightDir = normalize(lightPos - p);\n    float diff = max(dot(normal, lightDir), 0.0);\n    return vec3(1.0, 0.8, 0.6) * diff;\n}\n\nfloat raymarch(vec3 ro, vec3 rd) {\n    float dist = 0.0;\n    float d;\n    for (int i = 0; i < 100; i++) {\n        vec3 p = ro + rd * dist;\n        d = map(p);\n        if (d < 0.001) break;\n        dist += d;\n        if (dist > 50.0) break;\n    }\n    return dist;\n}\n\nvec3 triplanar(vec3 p, sampler2D texture1, sampler2D texture2) {\n    vec3 normal = calcNormal(p);\n    \n    vec3 weight = abs(normal);\n    weight /= (weight.x + weight.y + weight.z);\n\n    vec3 torusTexture = texture(texture1, p.yz).rgb;\n    vec3 sphereTexture = texture(texture2, p.xz).rgb;\n\n    return torusTexture * weight.x + sphereTexture * weight.y;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord.xy - iResolution.xy * 0.5) / iResolution.y;\n\n    float camTime = iTime * 0.5;\n\n    vec3 ro = vec3(7.0 * sin(camTime), 3.0 + sin(camTime * 0.5), 7.0 * cos(camTime));\n    vec3 lookAt = vec3(0.0, 0.0, 0.0);\n    vec3 forward = normalize(lookAt - ro);\n    vec3 right = normalize(cross(forward, vec3(0.0, 1.0, 0.0)));\n    vec3 up = cross(right, forward);\n\n    vec3 rd = normalize(forward + uv.x * right + uv.y * up);\n    float dist = raymarch(ro, rd);\n    vec3 color = vec3(0.0);\n\n    if (dist < 50.0) {\n        vec3 p = ro + rd * dist;\n        vec3 normal = calcNormal(p);\n\n        vec3 lightPos = vec3(5.0 * sin(iTime), 5.0, 5.0 * cos(iTime));\n        vec3 lightColor = lighting(p, normal, lightPos);\n\n        vec3 textureColor = triplanar(p, iChannel1, iChannel2);\n\n        color = textureColor * lightColor;\n\n        color *= exp(-0.02 * dist);\n    } else {\n        color = texture(iChannel0, rd).rgb;\n    }\n\n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dX3Rr","channel":0}],"code":"uniform samplerCube cubemap; \n\nvoid mainCubemap(out vec4 fragColor, in vec2 fragCoord, in vec3 rayOri, in vec3 rayDir)\n{\n    vec3 col = texture(cubemap, rayDir).rgb;\n\n    fragColor = vec4(col, 1.0);\n}","name":"Cube A","description":"","type":"cubemap"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\n    vec3 color = vec3(uv.x, 0.5, uv.y);\n\n    float dist = length(uv - vec2(0.5));\n    float circle = smoothstep(0.2, 0.3, dist);\n\n    color = mix(color, vec3(1.0, 0.0, 0.0), circle);\n\n    fragColor = vec4(color, 1.0);\n}","name":"Buffer A","description":"","type":"buffer"}]}