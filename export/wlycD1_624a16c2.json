{"ver":"0.1","info":{"id":"wlycD1","date":"1611080910","viewed":74,"name":"First steps...","username":"kw","description":"Now experimenting in 3d :D","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["3d"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n//first (raymarching) steps... \n\n//distance functions 3d: https://iquilezles.org/articles/distfunctions\n//distance functions 2d: https://iquilezles.org/articles/distfunctions2d\n//fog function: https://iquilezles.org/articles/fog\n//BigWIngs tutorial series helped me a lot: https://youtu.be/PGtv-dBi2wE\n//thanks iq & BigWIngs :)\n\nmat2 Rotate(float a) \n{\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c,-s,s,c);\n}\n\nfloat sdTriangle(in vec2 pos,in float size,in int rotate)//2d\n{\n    if(rotate > 0) pos *= Rotate(3.1415926535897931);\n    const float k = sqrt(3.0);\n    pos.x = abs(pos.x) - size;\n    pos.y = pos.y + size / k;\n    if(pos.x + k * pos.y > 0.0) pos = vec2(pos.x -k * pos.y,-k * pos.x - pos.y) / 2.0;\n    pos.x -= clamp(pos.x,-2.0 * size,0.0);\n    return -length(pos) * sign(pos.y);\n}\n\nvec4 sdSphere(in vec3 pos,in float size,in vec3 color)\n{\n    float sd = length(pos) - size;\n    return vec4(color,sd);\n}\n\nvec4 sdCapsule(in vec3 pos,in vec3 a,in vec3 b,in float size,in vec3 color)\n{\n    vec3 pa = pos - a;\n    vec3 ba = b - a;\n    float h = clamp(dot(pa,ba) / dot(ba,ba),0.0,1.0);\n    return vec4(color,length(pa - ba * h) - size);\n}\n\nfloat Union(in float d1,in float d2,in float k)\n{\n    float h = clamp(0.5 + 0.5 * (d2 - d1) / k,0.0,1.0);\n    return mix(d2,d1,h) - k * h * (1.0 - h);\n}\n\nvec4 Depth(in vec4 a,in vec4 b)\n{\n    if (a.w < b.w){return a;}else {return b;}\n}\n\nvec4 Map(in vec3 ray)\n{\n    vec4 map;\n    vec4 obj;\n    ray.xz *= Rotate(iTime / 10.0);\n    ray.y -= iTime * 10.0;\n    ray.y = mod(ray.y + 0.5 * 4.0,4.0) - 0.5 * 4.0;\n    float fx = 0.2 + max(abs(cos(iTime * 4.0)),0.4);//+ abs(ray.y)\n    vec3 size = vec3(2.0,4.0,0.05 * fx);\n    vec3 c1 = vec3(0.5 * (abs(ray.y) - 0.3),0.2,0.1);\n    vec3 c2 = vec3(0.5 * (ray.y - 0.8),0.2,0.1);\n    vec3 c3 = vec3(0.5 * (0.4 - ray.y - 0.8),0.2,0.1);\n    float u;\n    ray.xz = mod(ray.xz + 0.5 * 15.0,15.0) - 0.5 * 15.0;\n    map = sdCapsule(ray,vec3(0.0,-size.y,0.0),vec3(0.0,size.y,0.0),0.2 * (abs(ray.y) / 4.0),c1);\n    obj = sdSphere(ray,0.2 + max(abs(cos(iTime * 2.0)),0.1),c1);\n    u = Union(map.w,obj.w,1.0);\n    map = Depth(map,obj); \n    map.w = u;\n    obj = sdCapsule(ray,vec3(-size.x,0.0,0.0),vec3(0.0,size.y * fx,0.0),size.z,c2);     \n    map = Depth(map,obj);\n    obj = sdCapsule(ray,vec3(size.x,0.0,0.0),vec3(0.0,size.y * fx,0.0),size.z,c2);   \n    map = Depth(map,obj);\n    obj = sdCapsule(ray,vec3(0.0,0.0,size.x),vec3(0.0,size.y * fx,0.0),size.z,c2);     \n    map = Depth(map,obj);\n    obj = sdCapsule(ray,vec3(0.0,0.0,-size.x),vec3(0.0,size.y * fx,0.0),size.z,c2);   \n    map = Depth(map,obj);\n    obj = sdCapsule(ray,vec3(-size.x,0.0,0.0),vec3(0.0,-size.y * fx,0.0),size.z,c3);     \n    map = Depth(map,obj);\n    obj = sdCapsule(ray,vec3(size.x,0.0,0.0),vec3(0.0,-size.y * fx,0.0),size.z,c3);   \n    map = Depth(map,obj);\n    obj = sdCapsule(ray,vec3(0.0,0.0,size.x),vec3(0.0,-size.y * fx,0.0),size.z,c3);     \n    map = Depth(map,obj);\n    obj = sdCapsule(ray,vec3(0.0,0.0,-size.x),vec3(0.0,-size.y * fx,0.0),size.z,c3);   \n    map = Depth(map,obj);\n    return map;\n}\n\nvec4 Raymarch(in vec3 ro,in vec3 rd,in int steps,in float min,in float max)\n{\n    float sd = 0.0;\n    vec4 obj = vec4(0.0);\n    for(int step = 0;step < steps;step ++) \n    {\n        obj = Map(ro + rd * sd);\n        sd += obj.w;\n        if (sd > max || obj.w < min) break;  \n    }\n    obj.w = sd;\n    return obj;\n}\n\nvec3 Fog(in vec3 rgb,in vec3 color,in float density,in float distance)\n{\n    float exp = 1.0 - exp(-distance * density);\n    return mix(rgb,color,exp);\n}\n\nvec4 Stamp(in vec2 pos,in float size,in vec3 color, in float factor,in int rotate)//2d\n{\n    float sd1 = sdTriangle(pos,size,rotate);\n    float sd2 = sdTriangle(pos,size / 1.8,rotate);\n    float sd = max(sd1,-sd2);\n    sd = smoothstep(factor,-(3.0 / iResolution.y),sd);//;)\n    return vec4(color,sd);\n}\n\nvec3 Draw(in vec3 color,in vec4 obj)//2d\n{\n    return mix(color,obj.rgb,obj.a);\n}\n\nvec3 Camera(in vec2 uv,in vec3 origin,in vec3 lookat,in float fov)\n{\n    vec3 cz = normalize(lookat - origin);\n    vec3 cx = normalize(cross(vec3(0.0,1.0,0.0),cz));\n    vec3 cy = normalize(cross(cz,cx)); \n    return normalize((cx * uv.x) + (cy * uv.y) + (cz * fov));\n}\n\nvec2 Screen(in vec2 pix,in vec3 res)\n{\n    return vec2((pix - (0.5 * iResolution.xy)) / iResolution.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = Screen(fragCoord,iResolution);\n    vec3 ro = vec3(6.0,0.0,-42.0);\n    ro.xz *= Rotate(-iTime / 20.0);\n    ro.xy *= Rotate(iTime / 10.0);\n    vec3 at = vec3(0.0,0.0,0.0);\n    vec3 rd = Camera(uv,ro,at,1.0);\n    vec4 obj = Raymarch(ro,rd,100,0.005,100.0);\n    vec3 color = vec3(0.6 * uv.y,0.4 * (uv.y + 0.4),0.1);\n    if (obj.w <= 100.0){color = obj.rgb - (obj.w / 120.0) + (uv.y / 10.0);}\n    color = Fog(color,vec3(0.1 / (obj.w / 40.0)),0.056,obj.w);\n    vec3 tri_color = color * 1.8;\n    tri_color.g *= 1.8;\n    vec4 tri = Stamp(uv - vec2(0.0,0.12),0.2,tri_color,0.001,0);\n    color = Draw(color,tri);\n    tri_color = color * 1.8;\n    tri_color.b *= 1.8;\n    tri = Stamp(uv - vec2(0.0,-0.12),0.2,tri_color,0.001,1);\n    color = Draw(color,tri);\n    fragColor = vec4(color,1.0);\n}\n","name":"Image","description":"","type":"image"}]}