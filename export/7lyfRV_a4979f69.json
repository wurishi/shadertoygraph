{"ver":"0.1","info":{"id":"7lyfRV","date":"1664834778","viewed":75,"name":"10.03.2022:MightyMorphin","username":"g___r___e___g","description":"Simple raymarching experiment","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["fragtober"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_DIST 3.\n\nvec2 rotate(vec2 p, float angle) {\n  float c = cos(angle), s = sin(angle);\n  return mat2(c, -s, s, c) * p;\n}\n\n// polynomial smooth min - iquilez\n// https://iquilezles.org/articles/smin\nfloat smin(float a, float b, float k) {\n  float h = max( k-abs(a-b), 0.0 )/k;\n  return min( a, b ) - h*h*h*k*(1.0/6.0);\n}\n\nfloat stepLinear(float begin, float end, float t) {\n  return clamp((t - begin)/(end - begin), 0., 1.);\n}\n\nfloat stepReverse(float t) {\n  return stepLinear(0., .5, t) - stepLinear(0.5, 1., t);\n}\n\n// https://thebookofshaders.com/edit.php?log=160909065147\nfloat easeInOutCubic(float t) {\n   if ((t *= 2.0) < 1.0) {\n        return 0.5 * t * t * t;\n    } else {\n        return 0.5 * ((t -= 2.0) * t * t + 2.0);\n    }\n}\n\nfloat scene(vec3 p) {\n  float rAnim = easeInOutCubic(stepReverse(fract(iTime * 0.2)));\n  float dSphere = length(p) - 0.25 * (1. - rAnim);\n  p.xz = rotate(p.xz, iTime * 8.);\n  vec3 boxSize = vec3(0.4, 0.00, 0.4) * (rAnim);\n  float dBox = length(max(vec3(0.), abs(p) - boxSize)) - 0.075;\n  float dMix = smin(dSphere, dBox, 0.4 * (1. - rAnim) + 0.01);\n  return dMix;\n}\n\nvec3 sceneNormal(vec3 p) {\n  vec2 e = vec2(1e-3, 0);\n  return normalize(vec3(\n    scene(p+e.xyy) - scene(p-e.xyy),\n    scene(p+e.yxy) - scene(p-e.yxy),\n    scene(p+e.yyx) - scene(p-e.yyx)\n  ));\n}\n\n// Adapted from BigWing's raymarch starting point\n// https://www.shadertoy.com/view/WtGXDD\nvec3 lookAt(vec2 uv, vec3 origin, vec3 target, float z) {\n    vec3 \n        forward = normalize(target-origin),\n        right = normalize(cross(vec3(0,1,0), forward)),\n        up = cross(forward,right),\n        c = forward*z,\n        i = c + uv.x*right + uv.y*up;\n    return normalize(i);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  // scaling factor\n  float sf = 1. / min(iResolution.x, iResolution.y);\n  vec2 uv = (fragCoord - 0.5*iResolution.xy) * sf;\n  vec3 color = vec3(0.2, 0.5, 0.8);\n\n  vec3 ro = vec3(0.5, 1, 2);\n  vec3 rd = lookAt(uv, ro, vec3(0), 1.5);\n\n  float d = 0.;\n  for (int i = 0; i < 100; i++) {\n    vec3 p = ro + rd * d;\n    float dScene = scene(p);\n    d += dScene;\n    if (d > MAX_DIST || abs(dScene) < 1e-6) break;\n  }\n\n  if (d < MAX_DIST) {\n    vec3 p = ro + rd * d;\n    vec3 n = sceneNormal(p);\n\n    vec3 lightDir = normalize(vec3(1, 2, 0.25));\n    float bounce = -n.y;\n    color = bounce * vec3(0.01, 0.100, 0.200);\n    float dif = dot(n, lightDir);\n    dif = max(0., dif);\n    color = mix(color, vec3(1., 0.4, 0.2), dif);\n    // specular\n    color += pow(dif, 280.) * vec3(1);\n  }\n\n  color = pow(color, vec3(.4545)); // gamma\n\n  fragColor = vec4(color, 1);\n}","name":"Image","description":"","type":"image"}]}