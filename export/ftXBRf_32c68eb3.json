{"ver":"0.1","info":{"id":"ftXBRf","date":"1651182493","viewed":73,"name":"Sphere projection evaluation","username":"batersy","description":"a simple case to show sphere in different projection, also give a non general solution for correction.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["camera","projection"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n * Sphere projection evaluation by batersy\n * Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.\n * Contact: seplanely@gmail.com\n */\n\n// The image show sphere shape in different projection\n// The yellow circle shows Orthographic Projection, while green is Perspective Projection\n\n// They differ a lot, I haven't found a place explain this, so give a explaination myself:\n// Assuming the distance from the camera to sphere center is constant, \n// easy to know the angular range observed is fixed, but in perspective projection for a fixed angle, \n// the farther the object away from screen center, the greater the projection length on the screen,\n// which could be evaluated by [y = tan(x+delta) - tan(x)], \n// where delta is the fixed angle, x is camera ray angle, y will increase rapidly near PI / 2\n\n// I also give a simple solution here, actually only convert from Perspective Projection to Orthographic Projection\n// but this can be restricted in area of Perspective Projection, thus only affects target object.\n// to use this correction, change this define value to 1\n#define DO_CORRECTION 0\n\n#define PI 3.14159265358979323846\n#define TWO_PI 6.28318530717958647692\nfloat fov = PI / 4.0;\nfloat orbitRadius = 0.7;\nfloat sphereRadius = 0.2;\nvec3 lightDirection = normalize(vec3(1));\nvec3 colorOrth = vec3(0,1,1);\nvec3 colorPers = vec3(0,1,0);\n\nmat3 LookAt(vec3 eye, vec3 at) {\n    vec3 zaxis = normalize(eye - at);\n    vec3 up = vec3(0,1,0);\n    vec3 xaxis = normalize(cross(up, zaxis));\n    vec3 yaxis = cross(zaxis, xaxis);\n    return mat3(xaxis, yaxis, zaxis);\n}\n\nfloat raySphIntersect( in vec3 ro, in vec3 rd, in vec4 sph, out vec3 normal ) {\n\tvec3 oc = ro - sph.xyz;\n\tfloat b = dot( oc, rd );\n\tfloat c = dot( oc, oc ) - sph.w*sph.w;\n\tfloat h = b*b - c;\n\tif( h<0.0 ) return -1.0;\n    float x1 = -b - sqrt( h ), x2 = -b + sqrt( h );\n    float t = (x1 > 0.)? x1 : x2;\n    vec3 pos = ro + t * rd;\n    normal = normalize(pos - sph.xyz);\n\treturn t;\n}\n\nvec3 render(vec3 color, vec3 normal) {\n    //return color;\n    return color * dot(lightDirection, normal);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (2.0 * fragCoord.xy - iResolution.xy) / iResolution.y;\n    vec3 color = vec3(0);\n    float phase = iTime * TWO_PI / 10.0;\n    vec3 center = vec3(orbitRadius * cos(phase), orbitRadius * sin(phase), -1.0);\n    vec4 sphere = vec4(center, sphereRadius);\n\n    // orthographic projection\n    vec3 ro = vec3(p.xy, 0);\n    vec3 ta = vec3(p.xy,-1);\n    vec3 rd = normalize(ta - ro);\n    vec3 normal;\n    float t = raySphIntersect(ro, rd, sphere, normal);\n    if(t > 0.0) color += render(colorOrth, normal);\n    \n    // perspective projection\n    phase += PI / 4.0;\n    center = vec3(orbitRadius * cos(phase), orbitRadius * sin(phase), -1.0);\n    sphere = vec4(center, sphereRadius);\n    p.xy *= tan(fov);\n    ro = vec3(0);\n    ta = vec3(0,0,-1);\n    mat3 cam2World = LookAt(ro, ta);\n    rd = cam2World * normalize(vec3(p.xy, -1.0));\n#if DO_CORRECTION\n    t = raySphIntersect(ro, rd, sphere, normal);\n    // Orthographic projection is often inside the perspective projection area(like sphere here), \n    // in which case the verification below ensures only the target object area is processed.\n    if (t > 0.0) {\n        mat3 world2Cam = transpose(cam2World);\n        vec3 inversedPos = world2Cam * rd;\n        vec2 screenPos = -inversedPos.xy / inversedPos.z;\n        ro = vec3(screenPos, ro.z);\n        ta = vec3(screenPos, ta.z);\n        rd = normalize(ta - ro);\n    }\n#endif\n    t = raySphIntersect(ro, rd, sphere, normal);\n    if(t > 0.0) color += render(colorPers, normal);\n\n    // Output to screen\n    fragColor = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"}]}