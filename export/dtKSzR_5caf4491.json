{"ver":"0.1","info":{"id":"dtKSzR","date":"1685914918","viewed":61,"name":"Tutorial Rings Final","username":"samhostettler","description":"kishimisu tutorial with comment descriptions","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["template"],"hasliked":0,"parentid":"dlVSRR","parentname":"Tutorial Rings with notes - B&W"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 palette( float t) {\n    vec3 a = vec3(0.340, 0.320, 0.320);\n    vec3 b = vec3(0.308, 0.308, 0.308);\n    vec3 c = vec3(1.000, 1.000, 1.000);\n    vec3 d = vec3(0.080, 0.020, 0.000);\n    \n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   //set coordinates -1 to 1\n   vec2 uv = fragCoord / iResolution.xy *2.0 -1.;\n   \n   //keep drawings square rather than skewed to fit resolution\n   uv.x *= iResolution.x / iResolution.y;\n   \n   //non-tiled UVs\n   vec2 uv0 = uv;\n   \n   //variable used in \"for loop\"\n   vec3 finalColor = vec3(0.0);\n   \n   float bright = 0.9;\n   \n       \n   for (float i = 0.0; i < 8.; i++){    \n       //Tiles and re-centering 0,0\n       uv= fract(uv * ((sin(iTime*0.074)+1.1)*0.6)) - ((sin(iTime*0.004)+2.1)*0.4);\n\n       //distance from centre\n       float d = length(uv) * exp(-length(sin(uv0 * 1.11)));\n\n       //Colour variable\n       vec3 col = palette(length(uv0) + i * 0.04 + iTime*0.23);\n\n       //0.5 circle size (black inside)\n       //d -= 0.4;\n\n       //Sine circle rings -- mult=num of rings -- div=ring thickness\n       d = sin(d*10. + iTime * 0.38) / 5.;\n\n       //distance from circle edge\n       d = abs(d);\n\n       //threshold with falloff\n       d = smoothstep(0.0, (sin(iTime*sin(1.))*0.1 + 0.2), d);\n\n       //glow\n       d= 0.01 / d;\n\n       //Light areas are now coloured\n       finalColor += col * d * bright;\n       }\n   \n   fragColor = vec4(finalColor, 1.0);\n}","name":"Image","description":"","type":"image"}]}