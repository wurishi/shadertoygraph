{"ver":"0.1","info":{"id":"sd3BzM","date":"1656215548","viewed":141,"name":"d20 particle storm","username":"pb","description":"icosahedral particle storm glowing in yellow red sun","likes":11,"published":1,"flags":32,"usePreview":0,"tags":["3d","glow","icosahedron"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//philip.bertani@gmail.com\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 uv = fragCoord.xy/iResolution.xy;\n\n    //size of one texel in iChannel0\n    vec2 texel = 1./iResolution.xy;\n\n    vec4 total_color;\n    //see 5x5 gaussian weights in Common \n    for (int i=0;i<5;i++){\n        float fi = float(i)-2.;\n        for (int j=0;j<5;j++){ \n            float fj = float(j)-2.;\n            vec4 color = texture(iChannel0, \n                uv + vec2( texel.x*fi,texel.y*fj )  );\n            total_color += color * gk1s[i*5 + j];\n        }\n    }\n    \n    fragColor = vec4(pow(total_color.xyz, vec3(2.)),1.);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"//gaussian_kernel_one_stdev\nfloat[] gk1s = float[] (\n        0.003765,0.015019,0.023792,0.015019,0.003765,\n        0.015019,0.059912,0.094907,0.059912,0.015019,\n        0.023792,0.094907,0.150342,0.094907,0.023792,\n        0.015019,0.059912,0.094907,0.059912,0.015019,\n        0.003765,0.015019,0.023792,0.015019,0.003765 );\n        \n        \n//gaussian_kernel_half_stdev\nfloat[] gkhs = float[] (\n        0.000002,0.000212,0.000922,0.000212,0.000002,\n        0.000212,0.024745,0.107391,0.024745,0.000212,\n        0.000922,0.107391,0.466066,0.107391,0.000922,\n        0.000212,0.024745,0.107391,0.024745,0.000212,\n        0.000002,0.000212,0.000922,0.000212,0.000002 );\n        \n        \n","name":"Common","description":"","type":"common"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define PI 3.14159265;\n\n//hard coded icosahedron vertices for fractal generation\nconst float sqr5 = sqrt(5.);\nconst float p1 = 1./sqr5;\nconst float p2 = 2./sqr5;\nconst float p3 = sqrt( (5.+sqr5)/10. );\nconst float p4 = sqrt( (5.-sqr5)/10. );\nconst float p5 = (5.-sqr5)/10.;\nconst float p6 = (-5.-sqr5)/10.;\nconst float p7 = (5.+sqr5)/10.;\nconst float p8 = (-5.+sqr5)/10.;\n\nvec3[] d20 = vec3[] (\nvec3(1.,0.,0.),\nvec3(p1, p2, 0.),\nvec3(p1, p5, p3),\nvec3(p1, p6, p4),\nvec3(p1, p6, -p4),\nvec3(p1, p5, -p3),\nvec3(-1.,0.,0.),\nvec3(-p1, -p2, 0.),\nvec3(-p1, p8, -p3),\nvec3(-p1, p7, -p4),\nvec3(-p1, p7, p4),\nvec3(-p1, p8, p3)\n);\n\nvec3  ifs_color, center_of_hollow_sphere, center_of_earth;\nfloat ifs_scale; \nint   max_iter;\nfloat angle_time, thetaL, phiL, max_dist, sun_rnd, global_lum;\nvec3  global_light, lightpos;\n\nvec2 de_d20(vec3 z) {\n    \n    vec3 min_vtx;\n    vec3 orig_z = z;\n    int n=0;\n    float min_dist,dist_to_vtx;\n\n    z += .5;\n    z = mod( z - 1.1, 2.2 ) - 1.1;\n\n    ifs_color = vec3(0.);\n\n    for (int i=0; i<100; i++) {\n       \n        if ( i > max_iter ) break;\n\n        min_vtx = d20[0];\n        min_dist=length(z-d20[0]);\n        for (int j=1; j<12; j++) {\n        \n            dist_to_vtx=length(z-d20[j]); \n            if (dist_to_vtx<min_dist) {min_vtx=d20[j]; min_dist=dist_to_vtx;}\n            \n        }\n        \n        z = min_vtx + ifs_scale*(z-min_vtx);\n        \n        n++;\n\n        if ( z.x * z.y > 0. ) ifs_color.x ++;\n        if ( z.y * z.z > 0. ) ifs_color.y ++;\n        if ( z.z * z.x > 0. ) ifs_color.z ++;\n\n    }\n\n    ifs_color /= float(n);\n\n    float dz = pow(ifs_scale, float(n) );\n    //dz is simply the constant Scale factor to the power of number of times used\n\n    float scene_dist = length(z) / dz;  \n    float objid = 0.;\n\n    return vec2( scene_dist, objid );\n}\n\nmat3 rot_xz( float an ) {\n    float can = cos(an);\n    float san = sin(an);\n\n    return mat3( can, 0., -san,\n                 0. , 1.,   0.,\n                 san, 0.,  can );\n\n}   \n\nvec3 sky_color( vec3 dir, vec3 lightpos, vec3 p ) {\n  \n    vec3 skypos  = dir*max_dist - center_of_earth;\n    vec3 sky;\n\n    float ldiff = length( -lightpos - skypos ); \n\n    ldiff *= ldiff;\n\n    float sun_lum  = exp( -ldiff/7e10 );\n    float sun_lum2 = exp( -ldiff/2e8);\n    float sun_lum3 = exp( -ldiff/6e9);\n\n    global_lum = max( min((1.+.85*sin(angle_time)),1.3), 0.);\n    \n    global_light = vec3( sun_lum/2., sun_lum/2., 1.4*sun_lum );\n\n    float global_sun_lum = sun_lum2;\n\n    sky = vec3(sun_lum2,sun_lum2,sun_lum2/2.);\n    sky += (1.-sun_lum)*sky + .5*global_light;\n    sky += (1.-sun_lum)*sky + .7*vec3( sun_lum3, sun_lum3/1.3, 0.);\n\n    return  sky;\n\n}\n\n\nvec3 raymarch(in vec3 from, in vec3 dir) \n{\n\n    float totdist=0.;\n    float dist;\n    vec3  p, col=vec3(0.);\n    float glow = 0.;\n    float glow_threshold = .01*(1.+4.);\n\n    for (int i=0; i<30; i++) {\n\n        {\n            p = from + totdist*dir;\n            dist = de_d20(p).x;\n            totdist+=dist; \n            //not exactly glow anymore but density\n            if (dist<glow_threshold) \n                glow += max(0.,glow_threshold-dist)* exp(-totdist*totdist);\n         }\n \n    }\n\n    //the \"sky\" is always max_dist away\n    vec3 backg = sky_color( dir, lightpos, p );\n\n    col = backg;\n    col += (1.-.4)*glow * backg ;\n    col.r += glow *.1;\n\n\n    return col; \n\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ifs_scale = 1.666 + 2.5;\n    max_iter = 4;\n    max_dist = 100000.;\n    center_of_earth = vec3(0.,-1000.,0.);    \n    \n    mat3 rot;\n    vec3 movement;\n\n    vec2 uv = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n\n    vec3 ro = vec3( 0. );\n        \n    float  focal_point = -1.2;\n\n    rot = rot_xz(.5);\n    vec3   rd =  rot * normalize(vec3(uv,focal_point));\n\n    ro -= rot[2] * iTime/2.;\n\n    angle_time = 0.;\n\n    thetaL    = -angle_time;\n\n    phiL      = 0.;\n    lightpos  = max_dist * \n        vec3( sin(thetaL)*sin(phiL), sin(thetaL)*cos(phiL), cos(thetaL) )  \n        + center_of_earth;        \n\n    center_of_hollow_sphere = ro;\n \n\n    vec3 color = raymarch(ro,rd);\n \n    color = clamp(color,0.,1.);\n    \n    fragColor = vec4(color, 1.);\n}","name":"Buffer A","description":"","type":"buffer"}]}