{"ver":"0.1","info":{"id":"McKyR1","date":"1731509528","viewed":37,"name":"edged streak shader ","username":"congodin","description":"cool 2shader","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["shader","pencil","grain"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float getOutline(vec3 normal, vec3 rayDir, float sphereRadius, vec3 hitPos, vec3 spherePos) {\n    float edgeStrength = 1.0 - abs(dot(normal, rayDir));\n    float noise = fract(sin(dot(hitPos.xy * 10.0, vec2(12.9898, 78.233))) * 43758.5453);\n    edgeStrength = smoothstep(0.3, 0.8, edgeStrength);\n    edgeStrength *= 0.8 + 0.2 * noise;\n    edgeStrength *= 0.8 + 0.2 * sin(iTime * 2.0 + noise * 6.28);\n    float breakup = step(0.7, fract(sin(dot(hitPos.xz * 5.0, vec2(89.233, 23.14159))) * 43758.5453));\n    edgeStrength *= 0.8 + 0.2 * breakup;\n    return edgeStrength;\n}\n\nfloat getShadow(vec3 point, vec3 lightDir, vec3 spherePositions[3], float sphereRadii[3]) {\n    float shadow = 1.0;\n    \n    for(int i = 0; i < 3; i++) {\n        vec3 toSphere = spherePositions[i] - point;\n        float proj = dot(toSphere, lightDir);\n        vec3 closest = point + lightDir * proj;\n        vec3 toClosest = closest - spherePositions[i];\n        \n        float shadowDist = length(toClosest);\n        if(shadowDist < sphereRadii[i] * 1.2 && proj > 0.0) {\n            float shadowEdge = smoothstep(sphereRadii[i] * 1.2, sphereRadii[i] * 0.8, shadowDist);\n            float noise = fract(sin(dot(point.xz * 10.0, vec2(12.9898, 78.233))) * 43758.5453);\n            shadowEdge *= 0.8 + 0.2 * noise;\n            float breakup = step(0.6, fract(sin(dot(point.xz * 5.0, vec2(89.233, 23.14159))) * 43758.5453));\n            shadowEdge *= 0.9 + 0.1 * breakup;\n            shadow = min(shadow, 1.0 - shadowEdge);\n        }\n    }\n    return shadow;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    \n    const int BLUR_STEPS = 8;\n    const float MOTION_INTENSITY = 1.2;\n    float finalResult = 0.0;\n    float finalOutline = 0.0;\n    \n    float timeScale = iTime * 0.3;\n    \n    // Camera setup with complex motion\n    vec3 camPos = vec3(\n        cos(timeScale) * 3.0 + sin(timeScale * 0.7) * 2.0 + cos(timeScale * 1.3) * 0.5,\n        2.0 + sin(timeScale * 0.4) * 0.7 + cos(timeScale * 0.9) * 0.3,\n        sin(timeScale) * 3.0 + cos(timeScale * 0.6) * 2.0 + sin(timeScale * 1.1) * 0.5\n    );\n    \n    vec3 lookAt = vec3(\n        sin(timeScale * 0.25) * 1.0 + cos(timeScale * 0.4) * 0.3,\n        0.8 + sin(timeScale * 0.15) * 0.3 + cos(timeScale * 0.5) * 0.2,\n        cos(timeScale * 0.25) * 1.0 + sin(timeScale * 0.3) * 0.3\n    );\n    \n    // Scene setup\n    vec3 sphere1Pos = vec3(0.0, 1.0, 0.0);\n    vec3 sphere2Pos = vec3(2.0 * sin(timeScale * 0.5), 0.7 + sin(timeScale) * 0.2, 2.0 * cos(timeScale * 0.5));\n    vec3 sphere3Pos = vec3(-1.5 * cos(timeScale * 0.3), 0.5 + cos(timeScale * 0.7) * 0.1, -1.5 * sin(timeScale * 0.3));\n    vec3 spherePositions[3] = vec3[3](sphere1Pos, sphere2Pos, sphere3Pos);\n    float sphereRadii[3] = float[3](0.5, 0.3, 0.2);\n    \n    // Light direction\n    vec3 lightDir = normalize(vec3(sin(timeScale * 0.5), 1.0, cos(timeScale * 0.5)));\n    \n    for(int i = 0; i < BLUR_STEPS; i++) {\n        float timeOffset = float(i) * (MOTION_INTENSITY / float(BLUR_STEPS)) * 0.1;\n        float currentTime = timeScale - timeOffset;\n        \n        // Camera matrices\n        vec3 camTarget = lookAt;\n        vec3 camUp = normalize(vec3(sin(currentTime * 0.1), 1.0, cos(currentTime * 0.1)));\n        vec3 camDir = normalize(camTarget - camPos);\n        vec3 camRight = normalize(cross(camUp, camDir));\n        camUp = cross(camDir, camRight);\n        vec3 rayDir = normalize(camDir + uv.x * camRight + uv.y * camUp);\n        \n        float result = 1.0;\n        bool hitSomething = false;\n        vec3 normal;\n        vec2 streakUV;\n        float streakIntensity = 1.0;\n        float surfaceType = 0.0;\n        float outline = 0.0;\n        \n        // Ground intersection\n        float groundY = sin(currentTime * 0.2 + dot(vec2(camPos.xz), vec2(0.1))) * 0.1;\n        float t_ground = -(camPos.y - groundY) / rayDir.y;\n        vec3 groundHit = camPos + rayDir * t_ground;\n        \n        float nearest_t = 1e10;\n        \n        // Sphere intersections\n        for(int s = 0; s < 3; s++) {\n            vec3 oc = camPos - spherePositions[s];\n            float b = dot(rayDir, oc);\n            float c = dot(oc, oc) - sphereRadii[s] * sphereRadii[s];\n            float h = b * b - c;\n            \n            if(h >= 0.0) {\n                float t_sphere = -b - sqrt(h);\n                if(t_sphere > 0.0 && t_sphere < nearest_t) {\n                    nearest_t = t_sphere;\n                    vec3 hitPos = camPos + rayDir * t_sphere;\n                    normal = normalize(hitPos - spherePositions[s]);\n                    hitSomething = true;\n                    surfaceType = float(s + 1);\n                    \n                    outline = getOutline(normal, rayDir, sphereRadii[s], hitPos, spherePositions[s]);\n                    \n                    float rot = currentTime * (float(s) * 0.2 + 0.1);\n                    mat2 uvRot = mat2(cos(rot), -sin(rot), sin(rot), cos(rot));\n                    streakUV = uvRot * vec2(atan(normal.z, normal.x), acos(normal.y)) * 0.5;\n                }\n            }\n        }\n        \n        // Ground handling\n        if(!hitSomething && t_ground > 0.0) {\n            hitSomething = true;\n            normal = normalize(vec3(\n                sin(groundHit.x * 0.5 + currentTime) * 0.1,\n                1.0,\n                sin(groundHit.z * 0.5 + currentTime) * 0.1\n            ));\n            streakUV = groundHit.xz * 0.3;\n            surfaceType = 0.0;\n            \n            // Ground shadows\n            float groundShadow = getShadow(groundHit, lightDir, spherePositions, sphereRadii);\n            result *= mix(0.4, 1.0, groundShadow);\n            \n            // Shadow hatching\n            if(groundShadow < 0.8) {\n                vec2 shadowUV = groundHit.xz * 0.5;\n                float shadowAngle = -0.785 + sin(currentTime) * 0.2;\n                mat2 shadowRot = mat2(\n                    cos(shadowAngle), -sin(shadowAngle),\n                    sin(shadowAngle), cos(shadowAngle)\n                );\n                shadowUV = shadowRot * shadowUV;\n                \n                float shadowPattern = fract(shadowUV.x * 15.0 - shadowUV.y * 15.0);\n                float shadowNoise = fract(sin(dot(shadowUV * 20.0, vec2(12.9898, 78.233))) * 43758.5453);\n                float shadowBreaks = step(0.6, fract(sin(floor(shadowUV.y * 6.0)) * 43758.5453));\n                \n                float shadowStreak = smoothstep(0.3, 0.7, shadowPattern) * shadowBreaks * shadowNoise;\n                result = mix(result, result * (0.7 + 0.3 * shadowStreak), (1.0 - groundShadow) * 0.7);\n            }\n        }\n        \n        if(hitSomething) {\n            // Apply outline\n            result = mix(result, 0.0, outline);\n            \n            // Apply shadows for spheres\n            if(surfaceType > 0.0) {\n                vec3 hitPos = camPos + rayDir * nearest_t;\n                float shadow = getShadow(hitPos, lightDir, spherePositions, sphereRadii);\n                result *= mix(0.3, 1.0, shadow);\n                \n                if(shadow < 0.8) {\n                    vec2 shadowUV = streakUV * 2.0;\n                    float shadowPattern = fract(shadowUV.x * 20.0 - shadowUV.y * 20.0);\n                    float shadowNoise = fract(sin(dot(shadowUV * 25.0, vec2(12.9898, 78.233))) * 43758.5453);\n                    float shadowBreaks = step(0.7, fract(sin(floor(shadowUV.y * 8.0)) * 43758.5453));\n                    \n                    float shadowStreak = smoothstep(0.4, 0.6, shadowPattern) * shadowBreaks * shadowNoise;\n                    result = mix(result, result * (0.8 + 0.2 * shadowStreak), (1.0 - shadow) * 0.5);\n                }\n            }\n            \n            // Generate main streaks\n            for(float j = 0.0; j < 3.0; j++) {\n                float baseAngle = -0.785 + sin(currentTime) * 0.3;\n                float angle = baseAngle + surfaceType * 0.2;\n                \n                angle += dot(normal.xy, vec2(cos(currentTime), sin(currentTime))) * 1.8;\n                \n                mat2 rot = mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n                vec2 rotUV = rot * streakUV;\n                \n                float speedFactor = 1.0 + sin(currentTime * 1.3 + j) * 0.7;\n                rotUV += currentTime * 0.2 * speedFactor;\n                \n                float grainScale = 25.0 + sin(currentTime) * 5.0;\n                float grain = fract(sin(dot(rotUV * grainScale, vec2(12.9898, 78.233))) * 43758.5453);\n                grain = pow(grain, 1.5);\n                \n                float density = mix(15.0, 30.0, abs(sin(currentTime + surfaceType)));\n                float pattern = fract(rotUV.x * density - rotUV.y * density);\n                \n                float noise1 = fract(sin(dot(rotUV * (20.0 + sin(currentTime) * 8.0), vec2(12.9898, 78.233))) * 43758.5453);\n                float noise2 = fract(sin(dot(rotUV * (15.0 - cos(currentTime) * 5.0), vec2(43.2351, 11.789))) * 23421.5453);\n                float noise = mix(noise1, noise2, 0.5);\n                \n                float breaks = step(0.5 + sin(currentTime) * 0.2,\n                                  fract(sin(floor(rotUV.y * 8.0) + currentTime) * 43758.5453));\n                \n                float streak = smoothstep(0.3, 0.7, pattern) * breaks * (0.6 + 0.4 * noise) * grain;\n                \n                float edgeFactor = smoothstep(-0.2, 0.5, dot(normal, vec3(0.0, 0.0, 1.0)) + 0.5);\n                streak *= edgeFactor * (1.0 + sin(currentTime) * 0.3);\n                \n                float opacity = (0.7 + grain * 0.3) / (j + 1.0) * (1.0 + sin(currentTime * 0.7) * 0.3);\n                result = min(result, mix(1.0, 1.0 - streak, opacity));\n            }\n        }\n        \n        finalResult += result;\n        finalOutline += outline;\n    }\n    \n    finalResult /= float(BLUR_STEPS);\n    finalOutline /= float(BLUR_STEPS);\n    \n    // Final paper texture and grain\n    float paper = fract(sin(dot(uv * (300.0 + sin(timeScale) * 30.0), vec2(12.9898, 78.233))) * 43758.5453);\n    float extraGrain = fract(sin(dot(uv * 500.0, vec2(89.233, 23.14159))) * 87234.5453);\n    \n    finalResult = mix(finalResult, finalResult * paper * (0.8 + 0.2 * extraGrain), 0.15);\n    finalResult = mix(finalResult, 0.0, finalOutline * 0.8);\n    \n    fragColor = vec4(vec3(finalResult), 1.0);\n}\n","name":"Image","description":"","type":"image"}]}