{"ver":"0.1","info":{"id":"slcXzs","date":"1639585532","viewed":39,"name":"Raymarching #Color","username":"mghermida18","description":"Ejemplo de ray marching para la asignatura CCD","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","basic"],"hasliked":0,"parentid":"NttXRB","parentname":"Raymarching #Color Basico"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Funciones de distancia de Inigo Quilez\n// https://iquilezles.org/articles/distfunctions\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat opUnion(vec2 a, vec2 b) {\n    return min(a.x,b.x);\n}\n\n\nvec2 map(in vec3 p) { \n    return vec2(sdSphere(p-vec3(4.0,4.0,0.0), 1.0),1.0);\n}\n\nvec2 raycast( in vec3 ro, in vec3 rd ) {\n    float tmin = 1.0;\n    float tmax = 80.0;\n    \n    float t = tmin;\n    int maxIters = 70;\n    \n    vec2 res = vec2(-1.0);\n    \n    for( int i = 0; i < maxIters && t < tmax ; i++ ) {\n        vec2 h = map( ro + rd*t );\n        if( abs(h.x) < (0.0001*t) ){\n            res = vec2(t,h.y);\n            break;\n        }\n        t = t + h.x;\n    }\n    \n    return res;\n}\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal( in vec3  pos ) // for function f(p)\n{\n    const float h = 0.0001;      // replace by an appropriate value\n    #define ZERO (min(iFrame,0)) // non-constant zero\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(pos+e*h).x;\n    }\n    return normalize(n);\n}\n\nvec3 render(in vec3 ro, in vec3 rd) {\n    \n    vec2 res = raycast(ro,rd);\n    vec3 pos = ro+res.x*rd;\n    float t = res.x;\n    vec3 col = vec3(0.1, 0.1, 0.1);\n    vec3 normal = calcNormal(pos);\n    \n    // Luz\n    if(res.y > -0.5)\n    {\n       vec3  lig = normalize( vec3(0.25, 0.6, -0.6) );\n       vec3 p = vec3(0.2,-0.4,-0.6);\n       vec3 hal = normalize(p-pos);\n       float dif = clamp( dot(normal,p), 0.15, 1.0);\n       //float spe = pow( clamp( dot( normal, hal ), 0.0, 1.0 ),18.0);\n         //         spe *= dif;\n         //         spe *= 0.04+0.96*pow(clamp(1.0-dot(hal,lig),0.0,1.0),5.0);\n                 // spe*=0.1;\n       vec3 mate = vec3(0.63, 0.63, 0.63);\n       col += mate * 1.2*dif*vec3(0.89, 0.83, 0.85);\n       //col += 5.00*spe*vec3(1.30,1.00,0.70);\n    \n    }\n    //col *= exp( -0.0005*t*t*t );\n    return vec3( clamp(col,0.0,1.0) );\n}\n\n// Transformacion de un vector en espacio de la camara, al espacio del mundo.\nmat3 camera2World(in vec3 co, in vec3 ta, float rotation) {\n    vec3 h = vec3(sin(rotation),cos(rotation),0.0);\n    vec3 i = normalize(ta-co);\n    vec3 j = normalize(cross(i,h));\n    vec3 k = cross(j,i);\n    return mat3(j,k,i);                                                                                                                            \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Camara target o objetivo\n    vec3 ta = vec3(4.0,4.0,0.0);\n    // Camara origen (camera-origin)\n    vec3 co = vec3(0.0,0.0,0.0);\n    \n    mat3 ca = camera2World(co,ta,0.0f);\n    \n    vec2 p = (2.0*(fragCoord)-iResolution.xy)/iResolution.y;\n    \n    // Longitud de la lente de la camara.\n    const float fl = 1.5f;\n    \n    vec3 rd = ca * normalize(vec3(p,fl));\n    vec3 col = render(co,rd);\n    //vec3 col = rd.xyz;\n    //vec3 col = vec3(rd.xy,1.0);\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}