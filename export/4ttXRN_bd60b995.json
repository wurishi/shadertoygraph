{"ver":"0.1","info":{"id":"4ttXRN","date":"1478466172","viewed":171,"name":"CloudScapeDan","username":"anprogrammer","description":"Not a very good shader","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["bad"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define EPSILON 0.0001\n\nstruct Intersection\n{\n    float MinDist;\n    float Material;\n};\n\nstruct IntersectionResult\n{\n    float TotalDist;\n    float Material;\n    vec3 HitPos;\n};\n    \nfloat yPlaneDist(vec3 pos, float yAlt)\n{\n    return abs(yAlt - pos.y);\n}\n\nIntersection intersectYPlane(vec3 pos, float yAlt)\n{\n    Intersection ii;\n    float dist = yPlaneDist(pos, yAlt);\n    if (dist < EPSILON)\n    {\n        ii.Material = mod(pos.x, 2.0) < 1.0 != mod(pos.z, 2.0) < 1.0 ? 1.0 : 2.0;\n    }\n    \n    ii.MinDist = dist;\n    return ii;\n}\n\nfloat sphereDist(vec3 pos, vec3 spherePos, float sphereRadius)\n{\n    vec3 diff = spherePos - pos;\n    float dist = length(diff);\n    vec3 dir = diff / dist;\n    return max(dist - sphereRadius, 0.0);\n}\n\nIntersection drawSphere(vec3 pos, vec3 spherePos, float sphereRadius, float material)\n{\n    Intersection ii;\n    float dist = sphereDist(pos, spherePos, sphereRadius);\n    if (dist < EPSILON)\n    {\n        ii.Material = material;\n    }\n    \n    ii.MinDist = dist;\n    return ii;\n}\n\nIntersection mixI(Intersection a, Intersection b)\n{\n    if (a.MinDist < b.MinDist)\n    {\n        return a;\n    }\n    else\n    {\n        return b;\n    }\n}\n\nvec3 getLightPos()\n{\n    float angle = iTime;\n    float radius = 4.0;\n    return vec3(cos(angle)*radius, 3.0 * sin(angle * 3.7) + 2.0, sin(angle)*radius);\n}\n\nIntersection intersectScene(vec3 rayPos)\n{\n\tIntersection ii = drawSphere(rayPos,\n                          vec3(0.0, 0.0, 0.0),\n                          2.0, 4.0);\n    ii = mixI(ii, drawSphere(rayPos,\n                          getLightPos(),\n                          1.0, 3.0));\n    ii = mixI(ii, drawSphere(rayPos,\n                          vec3(5.0, -1.0, 2.0),\n                          1.0, 5.0));\n    ii = mixI(ii, intersectYPlane(rayPos, -2.0));\n    \n    return ii;\n}\n\nIntersectionResult rayMarch(vec3 startPos, vec3 dir, float maxDist)\n{   \n    vec3 rayPos = startPos;\n    \n    IntersectionResult ir;\n    ir.Material = 0.0;\n    ir.TotalDist = maxDist;\n    float totalDist = 0.0;\n    \n    for (int step = 0; step < 150; step++)\n    {\n        Intersection ii = intersectScene(rayPos);\n        if (ii.MinDist < EPSILON || totalDist > maxDist)\n        {\n            ir.TotalDist = min(totalDist, maxDist);\n            ir.HitPos = startPos + dir * totalDist;\n            if (ii.MinDist < EPSILON)\n            {\n                ir.Material = ii.Material;\n            }\n            break;\n        }\n        \n        rayPos += dir * ii.MinDist;\n        totalDist += ii.MinDist;\n    }\n    \n    return ir;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float size = max(iResolution.x, iResolution.y);\n\tvec2 xy = (fragCoord.xy - iResolution.xy * 0.5)  / size * 2.0;\n    vec3 rayDir = normalize(vec3(xy, 1.0));\n    \n    float cameraRadius = 20.0;\n    float cameraAngle = iTime * 0.1;\n    \n    vec3 camPos = vec3(cos(cameraAngle) * cameraRadius, 5.0 + cos(cameraAngle * 4.0), sin(cameraAngle) * cameraRadius);\n    vec3 fwd = normalize(-camPos); //Look at origin\n    vec3 up = vec3(0.0, 1.0, 0.0);\n    vec3 left = cross(up, fwd);\n    \n    float fogDist = 40.0;\n    IntersectionResult ir = rayMarch(camPos, left * rayDir.x + up * rayDir.y + fwd * rayDir.z, fogDist);\n    \n    float angle = iTime;\n    float radius = 4.0;\n    vec3 lightPos = getLightPos();\n    vec3 shadowDir = normalize(lightPos - ir.HitPos);\n    \n    IntersectionResult shadow = rayMarch(ir.HitPos + shadowDir * 0.1, shadowDir, 10.0);\n    float shadowStrength = shadow.TotalDist / 10.0;\n    if (shadow.Material == 3.0)\n    {\n        shadowStrength = 1.0;\n    }\n    \n    shadowStrength *= pow(4.0 / length(lightPos - ir.HitPos), 2.0);\n    \n    vec3 color;\n    if (ir.Material == 1.0)\n    {\n        color = vec3(0.5, 0.5, 0.5);\n    }\n    if (ir.Material == 2.0)\n    {\n        color = vec3(0.9, 0.9, 0.9);\n    }\n    if (ir.Material == 3.0)\n    {\n        color = vec3(1.0, 1.0, 1.0);\n    }\n    if (ir.Material == 4.0)\n    {\n        color = vec3(0.0, 0.0, 1.0);\n    }\n    if (ir.Material == 5.0)\n    {\n        color = vec3(0.0, 1.0, 0.0);\n    }\n    \n    vec3 fogColor = vec3(0.0, 0.0, 0.0);\n    float fogStrength = ir.TotalDist / fogDist;\n    vec3 finalColor = (shadowStrength * 0.7 + 0.3) * color * (1.0 - fogStrength) + fogColor * fogStrength;\n    fragColor = vec4(finalColor, 1.0);\n}","name":"Image","description":"","type":"image"}]}