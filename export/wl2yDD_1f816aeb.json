{"ver":"0.1","info":{"id":"wl2yDD","date":"1594436123","viewed":96,"name":"jep_mandelbrot","username":"Eindacor_DS","description":"mandelbrot set fractal visualization","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["fractal"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec2 getNewZ(vec2 z, vec2 c) {\n    float newY = 2.f * z.x * z.y + c.y;\n    float newX = (z.x * z.x) + (z.y * z.y * -1.f) + c.x;\n    return vec2(newX, newY);\n}\n\nint getIterationsBeforeExplosion(vec2 pos, int iterationLimit) {\n    float magnitudeThreshold = 2.f;\n    float realValue = pos.x;\n    float imaginaryValue = pos.y;\n    vec2 z = vec2(0.f, 0.f);\n    for (int i = 0; i < iterationLimit; i++) {\n        z = getNewZ(z, pos);\n        if (distance(z, vec2(0.f, 0.f)) > magnitudeThreshold) {\n         \treturn i;   \n        }\n    }\n    \n    return iterationLimit;\n}\n\nvec3 getColor(float value) {\n    vec3 red = vec3(1.f, 0.f, 0.f);\n    vec3 green = vec3(0.f, 1.f, 0.f);\n    vec3 blue = vec3(0.f, 0.f, 1.f);\n    \n    if (value < .5f) {\n        return mix(blue, green, value * 2.f);\n    } else {\n        return mix(green, red, (value - .5f) * 2.f);\n    }\n\t\n}\n\nvec2 getRotatedPosition(float currentTime, vec2 pos) {\n    float rotationSpeed = .1f;\n    float viewRotationTime = currentTime * rotationSpeed;\n    mat2 viewRotationMatrix = mat2(\n        cos(viewRotationTime), -sin(viewRotationTime),\n        sin(viewRotationTime), cos(viewRotationTime)\n    );\n    return pos * viewRotationMatrix;\n}\n\nfloat getMagnification(float currentTime) {\n    float totalZoomTime = 21.f;\n    float timeScale = .5f;\n    float adjustedTime = currentTime * timeScale;\n  \n    float zoomTime = mod(adjustedTime, totalZoomTime);\n    if (int(mod(adjustedTime / totalZoomTime, 2.f)) == 1) {\n        zoomTime = totalZoomTime - zoomTime;\n    }\n    \n    return pow(2.f, zoomTime);\n}\n\nvec3 rotateColor(vec3 color) {\n    vec3 deNormalized = (color * 2.f) - vec3(1.f);\n    \n    float xRotationTime = iTime / 2.1f;\n    float yRotationTime = iTime / 2.3f;\n    float zRotationTime = iTime / 2.4f;\n    \n    mat3 rotationXMatrix = mat3(\n        1.f, 0.f, 0.f,\n    \t0.f, cos(xRotationTime), -sin(xRotationTime),\n    \t0.f, sin(xRotationTime), cos(xRotationTime)\n    ); \n    \n    mat3 rotationYMatrix = mat3(\n    \tcos(yRotationTime), 0.f, sin(yRotationTime),\n        0.f, 1.f, 0.f,\n        -sin(yRotationTime), 0.f, cos(yRotationTime)\n    );\n    \n    mat3 rotationZMatrix = mat3(\n    \tcos(zRotationTime), -sin(zRotationTime), 0.f,\n        sin(zRotationTime), cos(zRotationTime), 0.f,\n        0.f, 0.f, 1.f\n    );\n    \n    return ((deNormalized * rotationXMatrix * rotationYMatrix * rotationZMatrix) + vec3(1.f)) / 2.f;\n}\n\n#define antiAlias 2\n//#define SHOW_TARGET\n#define ROTATE_VIEW\n#define INVERT\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float aspectRatio = iResolution.y / iResolution.x;\n    vec2 focalPoint = vec2(0.0495f, .655f);\n    focalPoint = vec2(0.2008f, .555f);\n    focalPoint.x /- aspectRatio;\n    \n    vec3 outColor = vec3(0.f);\n    \n    for (int m=0; m<antiAlias; m++) {\n        for (int n=0; n<antiAlias; n++) {\n            vec2 uv = (fragCoord + vec2(float(m), float(n))/float(antiAlias))/iResolution.xy;\n            vec2 graphPosition = (uv * 2.f - vec2(1.f, 1.f)) / getMagnification(iTime);\n\n            graphPosition.x /= aspectRatio; \n\n#ifdef ROTATE_VIEW\n            graphPosition = getRotatedPosition(iTime, graphPosition);\n#endif\n            graphPosition += focalPoint;\n\n            int iterationLimit = 200;\n            int stableIterations = getIterationsBeforeExplosion(graphPosition, iterationLimit);\n            \n            if (stableIterations >= iterationLimit) {\n\t\t\t\toutColor += vec3(0.f);\n            } else {\n                outColor += rotateColor(vec3(getColor(float(stableIterations) / float(iterationLimit))));\n            }\n        }\n    }\n    \n    outColor /= float(antiAlias*antiAlias);         \n    \n#ifdef SHOW_TARGET\n        float crosshairWidth = 1.f;\n        if ((abs(fragCoord.x - iResolution.x/2.f) < crosshairWidth || abs(fragCoord.y - iResolution.y/2.f) < crosshairWidth)) {\n            outColor = vec3(1.f) - outColor;\n        }\n#endif\n\n#ifdef INVERT\n    fragColor = vec4(vec3(1.f) - outColor, 1.f);\n#else\n    fragColor = vec4(outColor, 1.f);\n#endif\n}","name":"Image","description":"","type":"image"}]}