{"ver":"0.1","info":{"id":"llByzz","date":"1507160193","viewed":3179,"name":"Hexagonal Truchet Weaving","username":"BigWIngs","description":"See code for details. Hope you like!","likes":103,"published":1,"flags":0,"usePreview":0,"tags":["2d","hexagon","truchet","pattern","knot","hexagonal","weave","celtic"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// \"Hexagonal Truchet Weaving\" by Martijn Steinrucken aka BigWings/CountFrolic - 2017\n// Email:countfrolic@gmail.com Twitter:@The_ArtOfCode\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n// Here is my entry to the unoffical ShaderToy truchet competition ;)\n//\n// There are a few examples of hexagonal truchet on ShaderToy but they all seem to\n// incorporate only curves that jump from one edge of the hexagon to an adjacent edge.\n// This solution incorporates all possible curve jump combinations:\n// 111 (the usual one), 113, 122, 223 and 333\n// \n// A few other things of note:\n// * I render the 3 curves per tile separately and layer them randomly, to get the 'weaving' effect.\n// * In order to minimize small circle islands you can get sometimes I weighted the probabilities\n// of tiles so that the highest probability goes to the 223 tile and the lowest to the 111 tile.\n// * I randomly rotate tiles to get more variation.\n// \n// Things that didn't works so well:\n// I tried making proper uv coordinates for the curves, without mirroring down the middle of \n// the curve but so far haven't come up with anything useful because I keep getting curve ends \n// whose uvs don't match with their neighboring tile. This problem is compounded by the fact \n// that I'm rotating every tile randomly to get a more random look. I know that it is \n// impossible to always have perfect matching UVs but I thought I could come up with a decent\n// looking work around but so far no luck. I'm sure at some point someone will come up with \n// something.\n// I don't like all the if statements in my truchet function but this is the best I could come\n// up without without obfuscating the hell out of things. \n//\n// Credits:\n// Iomateron for his explanation of hexagonal tiling:\n// https://www.shadertoy.com/view/MlXyDl\n// Shane for making this uber cool looking truchet effect:\n// https://www.shadertoy.com/view/4td3zj\n// FabriceNeyret2 for cleaning up my mainImage function.\n\n// weights for the different types of tiles.\n// actual weight is weight-previous weight\n#define W111 .1\n#define W113 .2\n#define W122 .4\n#define W223 .8\n#define W333 1.\n\n#define GRID_SIZE 18.\n//#define REWIRE\n#define VARY_WIDTH\nfloat CURVE_WIDTH= .15;\n\n// some functions\n#define sat(x) clamp(x, 0., 1.)\n#define S(a, b, t) smoothstep(a, b, t)\n\n// some constants\n#define I3   0.333333333\t// 1/3\n#define I6   0.166666666\t// 1/6\n#define R3   1.732050807\t// square root of 3\n#define IR3  0.577350269 \t// the inverse of the square root of 3\n#define HIR3 0.288675134\t// half the inverse of the square root of 3\n#define S60  0.866025404\t// sine of 60 degrees\n#define C60  0.5\n\nfloat Remap01(float a, float b, float t) {\n    return (t-a)/(b-a);\n}\n\nfloat N21(vec2 id) { return fract(sin(id.x*324.23+id.y*5604.342)*87654.53); }\n\nvec4 UvCirc(vec2 uv, float radius, float thickness) {\n\tvec2 st = vec2(atan(uv.x, uv.y), length(uv));\n    \n    float t = thickness/2.;\n    float w = .01;\n    \n    float r1 = radius-t;\n    float r2 = radius+t;\n    \n    float mask = S(t+w, t, abs(radius-st.y));\n    float alpha = S(t+.1, t, abs(radius-st.y));\n    alpha = alpha*alpha*mix(.5, 1., mask);\n    \n    return vec4(st.x*radius, st.y, mask, alpha);\n}\n\nvec4 UvBeam(vec2 uv, float thickness) {\n\tfloat t = thickness/2.;\n    float w = .01;\n    float mask = S(t+w, t, abs(uv.y));\n    float alpha = S(t+.1, t, abs(uv.y));\n    alpha = alpha*alpha*(.5+.5*mask);\n    \n    return vec4(uv.x, uv.y, mask,alpha);\n}\n\nvec3 Truchet(vec2 uv, float n) {\n\tuv-= .5;\n    uv.x /= R3;\n    \n    vec4 v1 = vec4(0);\n    vec4 v2 = vec4(0);\n    vec4 v3 = vec4(0);\n    \n    float w = .15;\n    \n    // get random rotation for each tile\n    // since its only six could probably precompute / do some trickery\n    float r = floor(fract(n*5.)*6.)/6.;\n    r *= 6.28;\n    float s = sin(r);\n    float c = cos(r);\n    mat2 rot = mat2(c, -s, s, c);\n    uv *= rot;\n\t\t\n    if(n<W111) {\n        v1 = UvCirc(uv-vec2(0, I3), I6, CURVE_WIDTH);\t\t// jump 1\n    \tv2 = UvCirc(uv-vec2(HIR3, -I6), I6, CURVE_WIDTH);\t// jump 1\n    \tv3 = UvCirc(uv-vec2(-HIR3, -I6), I6, CURVE_WIDTH);\t// jump 1\n    }\n    else if(n<W113) {\n        v1 = UvCirc(uv-vec2(0, I3), I6, CURVE_WIDTH);\t\t// jump 1\n        v2 = UvCirc(uv-vec2(0, -I3), I6, CURVE_WIDTH);\t\t// jump 1\n        v3 = UvBeam(uv, CURVE_WIDTH);\t\t\t\t\t\t// jump 3\n    }\n    else if(n<W122) {\n        v1 = UvCirc(uv-vec2(-HIR3, -I6), I6, CURVE_WIDTH);\t// jump 1\n        v2 = UvCirc(uv-vec2(IR3, 0), .5, CURVE_WIDTH);\t\t// jump 2\n        v3 = UvCirc(uv-vec2(HIR3, .5), .5, CURVE_WIDTH);\t// jump 2\n    }\n    else if(n<W223) {\n        v1 = UvCirc(uv-vec2(IR3, 0), .5, CURVE_WIDTH);\t\t// jump 2\n        v2 = UvCirc(uv-vec2(-IR3, 0), .5, CURVE_WIDTH);   \t// jump 2  \n        v3 = UvBeam(uv, CURVE_WIDTH);\t\t\t\t\t\t// jump 3\n    } else {\n        mat2 rot60 = mat2(C60, -S60, S60, C60);\n    \tmat2 rot60i = mat2(C60, S60, -S60, C60);\n        \n        v1 = UvBeam(uv, CURVE_WIDTH);\t\t\t\t\t\t// jump 3\n \t\tv2 = UvBeam(uv*rot60, CURVE_WIDTH);\t\t\t\t\t// jump 3\n    \tv3 = UvBeam(uv*rot60i, CURVE_WIDTH); \t\t\t\t// jump 3\n    }\n    \n    float d1 = fract(n*10.);\t\t// expand my random number by taking digits\n    float d2 = fract(n*100.);\n    float d3 = fract(n*1000.);\n    float dMin = min(d1, min(d2, d3));\n    \n    // composite in different orders\n    vec4 v = d1<.166 ? mix(v1, mix(v2, v3, v3.a), max(v2.a, v3.a))\n           : d1<.333 ? mix(v1, mix(v3, v2, v2.a), max(v2.a, v3.a))\n           : d1<.5   ? mix(v2, mix(v1, v3, v3.a), max(v1.a, v3.a))\n           : d1<.666 ? mix(v2, mix(v3, v1, v1.a), max(v1.a, v3.a))\n           : d1<.833 ? mix(v3, mix(v1, v2, v2.a), max(v1.a, v2.a))\n           :           mix(v3, mix(v2, v1, v1.a), max(v1.a, v2.a));     \n\n    v.gr*=0.; // mask out some failed uv experiments\n   \n    return vec3(v.rgb);\n}\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    u = ( u / iResolution.x - .5 ) * GRID_SIZE;\n    float t = iTime * .02,\n          S = sin(t), C = cos(t);\n    u *= mat2(-C, S, S, C);\n    u.x += iTime*1.;\n\t\n    #ifdef VARY_WIDTH\n    CURVE_WIDTH = mix(.05, .25, (sin(u.x+sin(u.y))+sin(u.y*.35))*.25+.5);\n    #endif\n    \n    vec2 s = vec2(1.,R3),\n         a = mod(u     ,s)*2.-s,\n         b = mod(u+s*.5,s)*2.-s;\n\n    u /= s;\n    \n    float da = dot(a, a);\n\tfloat db = dot(b, b);\n    \n    vec2 id = da < db \n                  ? floor(u) \n                  : floor(u+=.5)-.5;\n    \n    \n    float n = N21(id);\n    #ifdef REWIRE\n    n = N21(id+vec2(floor(iTime*.1+n)));\n    #endif\n    O = Truchet(fract(u), n).rgbb;\n    \n    float outline = S(.7, 1.2, min(da, db));\n    O.b = max(O.b, outline*.5);\n}\n","name":"Image","description":"","type":"image"}]}