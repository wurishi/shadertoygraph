{"ver":"0.1","info":{"id":"lsXyDH","date":"1488053798","viewed":385,"name":"Boolean Floating Point Logic","username":"MichaelPohoreski","description":"Instructions: Click the mouse button to see a False Coloring: 0.0 = Blue, 0.5 = Green, 1.0 = Red\nTop: Correct Boolean Logic (integer math)\nMiddle: Naive Boolean Logic (floating-point math)\nBottom: Proper Boolean Logic (floating-point math)\n","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["math","boolean","logic","truthtable"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\nBoolean Logic Demo\nMichael Pohoreski aka Michaelangel007 aka mysticreddit\nCopyleft {C} 2017\nhttps://github.com/Michaelangel007/shader_boolean_logic\nVersion 9\n\nDISCLAIMER:\n\n    You are free to use this code as you wish.\n\n    However, if you are going to copy/paste snippets of this code\n    on StackOverflow, StackExchange, Reddit, etc.\n    Please provide a link back to the original source\n    so that people can find updates and bugfixes.\n    Thanks!\n\nIntroduction:\n\n    Boolean Logic or Truth Tables are tradionally defined as integer only.\n    https://en.wikipedia.org/wiki/Truth_table#Binary_operations\n\n    However we _can_ extend this to floating-poing math aka \"fuzzy\" logic.\n\n    This demo shows how to define the boolean operators such as AND, OR, NOT, etc.\n    using floating-poing math when you don't have boolean operators.\n\n    This lets you create all sorts of interesting patterns.\n\n    i.e.\n        Checkerboard = (x XOR y);\n\nAlso see:\n\n Cross Hatch Patterns\n https://www.shadertoy.com/view/MdfyDH\n\n Bart Kosko\n Fuzzy Thinking: The New Science of Fuzzy Logic\n https://www.amazon.com/Fuzzy-Thinking-New-Science-Logic/dp/078688021X/\n*/\n#define MOUSE_DRAG_COMPARE 0 // Change to 1 for static split screen compare\n\n    float   bNOT  ( float a )          { return 1.-a; }\n\n    #define bFALSE                     (        0.                     ) // 0000 0\n    float   bAND  ( float a, float b ) { return a*b;                   } // 0001 1\n    float   bNTHEN( float a, float b ) { return a*(1.-b);              } // 0010 2\n    #define bA                         (        a                      ) // 0011 3\n    float   bNIF  ( float a, float b ) { return (1.-a)*b;              } // 0100 4\n    #define bB                         (        b                      ) // 0101 5\n    float   bXOR  ( float a, float b ) { return a*(1.-b)+(1.-a)*b;     } // 0110 6\n    float   bOR   ( float a, float b ) { return 1.-(1.-a)*(1.-b);      } // 0111 7\n    float   bNOR  ( float a, float b ) { return    (1.-a)*(1.-b);      } // 1000 8\n    float   bXNOR ( float a, float b ) { return 1.-(a*(1.-b)+(1.-a)*b);} // 1001 9\n    #define bNB                        (        1.-b                   ) // 1010 10\n    float   bTHEN ( float a, float b ) { return 1.-(1.-a)*b;           } // 1011 11\n    #define bNA                        (        1.-a                   ) // 1100 12\n    float   bIF   ( float a, float b ) { return 1.-a*(1.-b);           } // 1101 13\n    float   bNAND ( float a, float b ) { return 1.-a*b;                } // 1110 14\n    #define bTRUE                      (        1.                     ) // 1111 15\n\n    /*\n        Sometimes you will seen this alternative definition for XOR:\n\n            float bXOR2( float a, float b ) { return mod(a+b,2.0); }\n\n        Which produces this output:\n\n            0 0  0+0=0\n            0 1  0+1=1\n            1 0  1+0=1\n            1 1  0+0=0\n\n        This is valid for integers but technically doesn't produce\n        \"clean\" floating-point values. See the GitHub README.md for more details.\n    */\n\n// Integer Boolean -- exact when a and b are quantized to 0.0 and 1.0\n// Float   Boolean -- naive implementation\n// =================================\nfloat bBoolean( float op, float a, float b )\n{\n    float g = -1.0;\n\n    if( op == 0.0 ) g = bFALSE;\n    if( op == 1.0 ) g = bAND  ( a, b );\n    if( op == 2.0 ) g = bNTHEN( a, b );\n    if( op == 3.0 ) g = bA;\n    if( op == 4.0 ) g = bNIF  ( a, b );\n    if( op == 5.0 ) g = bB;\n    if( op == 6.0 ) g = bXOR  ( a, b );\n    if( op == 7.0 ) g = bOR   ( a, b );\n    if( op == 8.0 ) g = bNOR  ( a, b );\n    if( op == 9.0 ) g = bXNOR ( a, b );\n    if( op ==10.0 ) g = bNB;\n    if( op ==11.0 ) g = bTHEN ( a, b );\n    if( op ==12.0 ) g = bNA;\n    if( op ==13.0 ) g = bIF   ( a, b );\n    if( op ==14.0 ) g = bNAND ( a, b );\n    if( op ==15.0 ) g = bTRUE;\n\n    return g;\n}\n\n\n// Float   Boolean -- proper implementation\n// ====================\nfloat fBoolean( float op, float a, float b, float gradient )\n{\n    float g = -1.0;\n\n    a = ceil( a );\n    b = ceil( b );\n\n    if( op == 0.0 ) g = bFALSE;\n    if( op == 1.0 ) g = bAND  ( a, b );\n    if( op == 2.0 ) g = bNTHEN( a, b );\n    if( op == 3.0 ) g = bA;\n    if( op == 4.0 ) g = bNIF  ( a, b );\n    if( op == 5.0 ) g = bB;\n    if( op == 6.0 ) g = bXOR  ( a, b );\n    if( op == 7.0 ) g = bOR   ( a, b );\n    if( op == 8.0 ) g = bNOR  ( a, b );\n    if( op == 9.0 ) g = bXNOR ( a, b );\n    if( op ==10.0 ) g = bNB;\n    if( op ==11.0 ) g = bTHEN ( a, b );\n    if( op ==12.0 ) g = bNA;\n    if( op ==13.0 ) g = bIF   ( a, b );\n    if( op ==14.0 ) g = bNAND ( a, b );\n    if( op ==15.0 ) g = bTRUE;\n\n    return g * gradient;\n}\n\nvec3 vBoolean( float op, vec3 a, vec3 b, float gradient )\n{\n    return vec3(\n        fBoolean( op, a.x, b.x, gradient ),\n        fBoolean( op, a.y, b.y, gradient ),\n        fBoolean( op, a.z, b.z, gradient )\n    );\n}\n\n// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n\n// WebGL 2.0: trunc()\nfloat truncate( float x )\n{\n    return x - fract(x);\n}\n\n// WebGL 1.0: fract()\nfloat Fract( float x )\n{\n    return x - floor( x );\n}\n\n// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n\nvec3 hsv2rgb( vec3 c )\n{\n    vec3 K = vec3(3,2,1) / 3.0;\n    vec3 p = abs(fract(c.rrr + K.rgb) * 6.0 - vec3(3));\n    return c.b * mix(K.rrr, clamp(p - K.rrr, 0.0, 1.0), c.g);\n}\n\n// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n\n// Creative Commons CC0 1.0 Universal (CC-0)\n// Based on:\n// https://www.shadertoy.com/view/4sBSWW\n\n/* */ vec2  gvFontSize    = vec2(4.0, 15.0); // Multiples of 4x5 work best\n/* */ vec2  gvPrintCharXY = vec2( 0.0, 0.0 ); // in pixels, NOT normalized\nconst float nPrintDelta = 32.0;\nconst float nPrintShift = 96.0;\n\n// x = ASCII value in decimal\n// Bits are left-to-right, 4x5\nfloat GlyphBin(const in int x)\n{\n    if (x < 47)\n        return // Glyphs added by Michael Pohoreski\n             x==32 ?      0.0\n            :x==33 ? 139778.0 // '!' 0x21\n            :x==38 ? 152154.0 // '&' 0x25\n            :x==42 ?  21072.0 // '*' 0x2A\n            :x==45 ?   3840.0 // '-' 0x2D\n            :/* 46*/      2.0 // '.' 0x2E\n            ;\n    if ((x < 58))\n        return // Mostly original glyphs\n             x==48 ? 480599.0 // '0' 0x30\n            :x==49 ? 143911.0 // '1' // Original: 139810.0\n            :x==50 ? 476951.0 // '2'\n            :x==51 ? 476999.0 // '3'\n            :x==52 ? 350020.0 // '4'\n            :x==53 ? 464711.0 // '5'\n            :x==54 ? 464727.0 // '6'\n            :x==55 ? 476228.0 // '7'\n            :x==56 ? 481111.0 // '8'\n            :/* 57*/ 481095.0 // '9' 0x39\n            ;\n    else\n    if (x < 78)\n        return // Glyphs added by Michael Pohoreski\n             x==61 ?  61680.0 // '=' 0x3D\n            :x==65 ? 434073.0 // 'A' 0x41\n            :x==66 ? 497559.0 // 'B' 0x42\n            :x==67 ? 921886.0 // 'C' 0x43\n            :x==68 ? 498071.0 // 'D' 0x44\n            :x==69 ? 988959.0 // 'E' 0x45\n            :x==70 ? 988945.0 // 'F' 0x46\n            :x==71 ? 925086.0 // 'G' 0x47\n            :x==72 ? 630681.0 // 'H' 0x48\n            :x==73 ? 467495.0 // 'I' 0x49\n            :x==74 ? 559239.0 // 'J' 0x4A\n            :x==75 ? 611161.0 // 'K' 0x4B\n            :x==76 ?  69919.0 // 'L' 0x4C\n            :/* 77*/ 653721.0 // 'M' 0x4D\n            ;\n    else\n    if (x < 91)\n        return // Glyphs added by Michael Pohoreski\n             x==78 ? 638361.0 // 'N' 0x4E\n            :x==79 ? 432534.0 // 'O' 0x4F // width=4, 432534; width=3 152914\n            :x==80 ? 497425.0 // 'P' 0x50\n            :x==81 ? 432606.0 // 'Q' 0x51\n            :x==82 ? 497561.0 // 'R' 0x52\n            :x==83 ? 923271.0 // 'S' 0x53\n            :x==84 ? 467490.0 // 'T' 0x54\n            :x==85 ? 629142.0 // 'U' 0x55\n            :x==86 ? 349474.0 // 'V' 0x56\n            :x==87 ? 629241.0 // 'W' 0x57\n            :x==88 ? 628377.0 // 'X' 0x58\n            :x==89 ? 348706.0 // 'Y' 0x59\n            :/* 90*/ 475671.0 // 'Z' 0x5A\n            ;\n    else\n    if (x < 127 )\n        return\n          x ==101 ?  10006.0 // 'e' 0x65\n         :x ==102 ? 272162.0 // 'f' 0x66\n         :x ==104 ?  70485.0 // 'h' 0x68\n         :x ==105 ? 131618.0 // 'i' 0x69\n         :x ==110 ?    853.0 // 'n' 0x6E\n         :x ==116 ? 141092.0 // 't' 0x74\n         :x ==127 ? 678490.0 //     0x7F\n         :               0.0\n         ;\n    return 0.0;\n}\n\n\n// Returns alpha of character\n// =================================\nfloat CharAlpha( vec2 vFragCoord, float fValue )\n{\n    vec2 vStringCharCoords = (vFragCoord.xy - gvPrintCharXY) / gvFontSize;\n    if ((vStringCharCoords.y < 0.0) || (vStringCharCoords.y >= 1.0)) return 0.0; // backgroundColor;\n    if ( vStringCharCoords.x < 0.0)                                  return 0.0; // backgroundColor;\n\n    fValue += nPrintDelta;\n    float fCharBin = (vStringCharCoords.x < 1.0) ? GlyphBin(int(fValue)) : 0.0;\n\n    // Auto-Advance cursor one glyph plus 1 pixel padding\n    // thus characters are spaced 9 pixels apart\n    float fAdvance = false\n        || (fValue == 42.) // *\n        || (fValue == 73.) // I\n        || (fValue == 84.) // T\n        || (fValue == 86.) // V\n        || (fValue == 89.) // Y\n        || (fValue ==104.) // h\n        || (fValue ==105.) // i\n        || (fValue ==116.) // t\n        ? 0.0 // glyph width has no padding\n        : 1.0;\n    if( fValue == 33.) // !\n        fAdvance = -(gvFontSize.x / 6.0);\n    gvPrintCharXY.x += gvFontSize.x + fAdvance;\n\n    // a = floor(mod((fCharBin / pow(2.0, floor(fract(vStringCharCoords.x) * 4.0) + (floor(vStringCharCoords.y * 5.0) * 4.0))), 2.0));\n    //return mix( backgroundColor, textColor, a );\n\n    return floor(\n        mod(\n            (fCharBin / pow(\n                2.0,\n                floor(fract(vStringCharCoords.x) * 4.0) +\n                (floor(vStringCharCoords.y * 5.0) * 4.0))),\n            2.0\n        )\n    );\n}\n\n/*\nUsage:\n    // void mainImage( out vec4 fragColor, in vec2 fragCoord )\n\n    vec3 colorBG  = vec( 1 );\n    vec3 colorFG  = vec( 0 );\n    vec3 color;\n\n    vec2 centerXY = iResolution.xy * 0.5;\n    gvPrintCharXY = vec2( centerXY );\n\n    float len;\n    float text = text3( len, 65.0, 66.0, 67.0 );\n    color = PutChar( colorBG, colorFG, fragCoord, text ); // \"ABC\"\n\n    text = text3( len, 88.0, 89.0, 90.0 );\n    color = mix(     color  , colorFG, fragCoord, text ); // \"XYZ\"\n\n    fragColor.rgb = color;\n*/\n// =================================\nvec3 PutChar( vec3 vBackgroundColor, vec3 vTextColor, vec2 vFragCoord, float fValue )\n{\n    float a = CharAlpha( vFragCoord, fValue - nPrintDelta );\n    return mix( vBackgroundColor, vTextColor, a );\n}\n\n/*\n   Print a maximum of 3 characters\n       = floating-point 24-bits mantissa / 7-bits/char\n       = 3.42... chars\n*/\n// =================================\nvec3 Print( vec3 vBackgroundColor, vec3 vTextColor, vec2 vFragCoord, float fChars )\n{\n    vec3  color = vBackgroundColor;\n    float bits  = fChars;\n\n    for( int i = 0; i < 3; i++ )\n    {\n        float nChar = mod( bits, nPrintShift );\n        nChar += nPrintDelta;\n        if( nChar < 32.0 )\n            break;\n\n        bits /= nPrintShift;\n        bits = floor( bits );\n\n        color = PutChar( color, vTextColor, vFragCoord, nChar );\n    }\n    return color;\n}\n\n\n// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n\nfloat cell_gradient( vec2 q, float y, float h )\n{\n    return mod( 4.0*(q.y - y), h ) / h;\n}\n\n// Pack 3 chars into 24-bit float mantissa\nfloat text3( out float len, float c1, float c2, float c3 )\n{\n    float s = 1.0;\n    float t = nPrintShift;\n\n    float text     = 0.0;\n    float numChars = 0.0;\n\n    if( c1 > 0.0) { numChars += 1.0; text += s*(c1 - nPrintDelta); s *= t; }\n    if( c2 > 0.0) { numChars += 1.0; text += s*(c2 - nPrintDelta); s *= t; }\n    if( c3 > 0.0) { numChars += 1.0; text += s*(c3 - nPrintDelta); s *= t; }\n//    if( c4 > 0.0) { numChars += 1.0; text += s*(c4 - nPrintDelta); s *= t; }\n\n    len = numChars;\n    return text;\n}\n\nfloat center( float glyphWidth, float numChars )\n{\n    return (glyphWidth - numChars*gvFontSize.x) * 0.5;\n}\n\n#define GRID_HORZ_COLOR if( i < (edgeH / iResolution.y) ) color = colorG* mod( p.x, 2.0 );\n\n// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n\n\n// =================================\nvoid mainImage( out vec4 f, in vec2 p )\n{\n    vec2 q = p / iResolution.xy;\n    bool m;\n\n#if MOUSE_DRAG_COMPARE\n    m = (iMouse.x >= p.x); // left mouse button down\n#else\n    // X seconds, drag mouse right\n    // X seconds, un-drag mouse right\n    #define LEN_SEGMENTS 4.0\n    #define NUM_SEGMENTS 2.0\n\n    float timeR = mod( iTime + 1.0, (LEN_SEGMENTS * NUM_SEGMENTS) );\n    float timeQ = floor( timeR / LEN_SEGMENTS);\n\n    if( timeQ == 0.0 )\n        m = (timeR <= q.x); // 1 second \"unwipe\", 3 seconds static image  \n    else\n    //( timeQ == 1.0 )\n        m = ((timeR - LEN_SEGMENTS) >= q.x); // 1 second \"wipe\", 3 seconds static image\n#endif\n\n    float g;\n\n    float COL = 18.0;\n    float x = floor( q.x * COL );\n    float y;\n    float z = 0.0;\n\n    float w = iResolution.x / COL;\n    float h = 0.25;\n    float statusH = 0.05;\n    float spacerH = (1.0 - statusH - (3.0*h)) / 3.0;\n\n    float a,b;\n    vec3  c,d;\n\n    vec3 colorA = vec3( 1.0, 0.0, 0.0 ); // Red\n    vec3 colorB = vec3( 0.0, 1.0, 0.0 ); // Green\n    vec3 colorT = vec3( 1.0, 1.0, 0.0 ); // Yellow - Status Text\n    vec3 colorF = vec3( 0.0, 0.7, 1.0 ); // HSB( 200, 100, 100 ) = #00AAFF; X Windows: Deep Sky Blue #00BBFF\n    vec3 colorG = m ? vec3( 0.0 ) : vec3( 1.0 );\n    vec3 colorN = vec3( 0.5, 0.5, 1.0 ); // #0 .. #15\n    vec3 colorS = vec3( 1.0 ); // White header background\n\n    vec3 color = colorS;\n\n    float s    = 128.0; // 2nd glyph\n    float t    = s*s; // 3rd glyph\n    float text = 0.0;\n    float prefixGap = (w - gvFontSize.x)*0.5;\n    float len;\n\n    if( iResolution.x > 512. )\n        gvFontSize.x *= 2.0;\n\n    float x0 = fract( q.x * COL );\n    float edgeW = COL / iResolution.x;\n    float edgeH = 12.0; // Magic Number: 1 scanline of h\n\n    if( x0 > (1.0 - edgeW) ) // Vertical Grid has priority\n    {\n        color = colorG * mod( p.y, 2.0 ); // stipple = dotted vertical grid line\n    }\n    else\n    if( q.y >= (1.0 - (gvFontSize.y / iResolution.y)) ) // Normalized Font Height\n    {\n\n        gvPrintCharXY.y = iResolution.y - gvFontSize.y;\n\n            // Show '#'\n            if( x >= 2.0 )\n            {\n                float text = text3( len, 48.0 + (x - 2.0), 0.0, 0.0 ); // '0' .. '9'\n                if( x >= 12.0 )\n                {\n                    text = text3( len, 49.0, (48.0 + x - 12.0), 0.0 );\n                }\n\n                prefixGap = center( w, len );\n                gvPrintCharXY.x = x*w + prefixGap;\n\n                color = Print  ( vec3( 1.0, 1.0, 0.0) , colorN, p, text );\n            }\n    }\n    else\n    if( q.y >= 0.5 + 2.*spacerH ) // top - Quantized integer Boolean\n    {\n        y = 0.5 + 2.*spacerH;\n        float i = cell_gradient( q, y, h ); // monochrome gradient ramp\n\n        // y = 0 at bottom\n        if( q.y <= (y + h*4./4.) ) // 18 columns x 4 rows\n        {\n            if( q.y < (y + h*1./4.) ) { a = 1.; b = 1.; }\nelse        if( q.y < (y + h*2./4.) ) { a = 1.; b = 0.; }\nelse        if( q.y < (y + h*3./4.) ) { a = 0.; b = 1.; }\nelse        if( q.y < (y + h*4./4.) ) { a = 0.; b = 0.; }\n\n            float j = bBoolean( x-2.0, a, b );\n            float k = j;\n\n            if( x == 0.0 ) { color = colorA * a; k = a;       }\n            if( x == 1.0 ) { color = colorB * b; k = b*3./6.; } // green\n            if( x >= 2.0 ) { color = colorF * j; k*=   1./6.; } // sky blue\n\n            if( m )\n              color = hsv2rgb( vec3( fract(2./3. * (1.0 - k)), 1.0, 1.0 ) );\n\n            // horizontal grid lines at bottom of cell\n            GRID_HORZ_COLOR\n        }\n        else\n        {\n            gvPrintCharXY.y = (y + h) * iResolution.y;\n\n            if( x < 2.0 )\n            {\n                text = text3( len, 65.0, 0.0, 0.0 ); // 'A'\n                gvPrintCharXY.x = prefixGap; // x/2 = center\n                color = Print( color, colorA, p, text );\n\n                text = text3( len, 66.0, 0.0, 0.0 ); // 'B'\n                gvPrintCharXY.x = w + prefixGap; // x/2 = center\n                color = Print( color, colorB*0.85, p, text );\n            }\n            else\n            {\n                float col = x - 2.0;\n                vec2  saveSize = gvFontSize;\n                float len = 1.0;\n\n                if( col == 0.0 ) text = text3( len, 70.0,  0.0,  0.0 ); // FALSE '0'=48\n                if( col == 1.0 ) text = text3( len, 65.0, 78.0, 68.0 ); // AND '&'=38\n                if( col == 2.0 ) text = text3( len, 33.0,116.0,104.0 ); // !THEN // prefixGap = gvFontSize.x*0.5;\n                if( col == 3.0 ) text = text3( len, 65.0,  0.0,  0.0 ); // A\n                if( col == 4.0 ) text = text3( len, 33.0,105.0,102.0 ); // !if // prefixGap = gvFontSize.x*0.5; }\n                if( col == 5.0 ) text = text3( len, 66.0,  0.0,  0.0 ); // B\n                if( col == 6.0 ) text = text3( len, 88.0, 79.0, 82.0 ); // XOR\n                if( col == 7.0 ) text = text3( len, 79.0, 82.0,  0.0 ); // OR\n                if( col == 8.0 ) text = text3( len, 78.0, 79.0, 82.0 ); // NOR\n                if( col == 9.0 ) text = text3( len, 88.0, 78.0, 79.0 ); // XNOR\n                if( col ==10.0 ) text = text3( len, 33.0, 66.0,  0.0 ); // !B\n                if( col ==11.0 ) text = text3( len,116.0,104.0,101.0 ); // then\n                if( col ==12.0 ) text = text3( len, 33.0, 65.0,  0.0 ); // !A\n                if( col ==13.0 ) text = text3( len,105.0,102.0,  0.0 ); // IF\n                if( col ==14.0 ) text = text3( len, 78.0, 65.0, 78.0 ); // NAND '&'=33,38\n                if( col ==15.0 ) text = text3( len, 84.0,  0.0,  0.0 ); // TRUE '1'=49\n\n                if( col== 2.0 ) len = 5.0; // !THEN\nelse            if( col== 9.0 ) len = 4.0; // XNOR\nelse            if( col==11.0 ) len = 4.0; // THEN\nelse            if( col==14.0 ) len = 4.0; // NAND\n\n                prefixGap = center( w, len );\n\n                gvPrintCharXY.x = x*w + prefixGap; // x/2 = center on x chars\n\n                color = Print( colorS, colorF, p, text );\n\n                if( col == 2.0 ) // !THEN\n                {\n                    text = text3( len, 101.0, 110.0, 0.0 ); // !TH__ = EN\n                    color = Print( color, colorF, p, text );\n                }\n                if( col == 9.0 ) // XNOR\n                {\n                    text = text3( len, 82.0, 0.0, 0.0 ); // XNO_ = R\n                    color = Print( color, colorF, p, text );\n                }\n                if( col ==11.0 ) // THEN\n                {\n                    text = text3( len, 110.0, 0.0, 0.0 ); // the_ = n\n                    color = Print( color, colorF, p, text );\n                }\n                if( col ==14.0 ) // NAND\n                {\n                    text = text3( len, 68.0, 0.0, 0.0 ); // NAN_ = D\n                    color = Print( color, colorF, p, text );\n                }\n            }\n        }\n    }\n    else\n    if( q.y >= 0.25 + spacerH ) // middle -- Naive floating-point Boolean\n    {\n        y = 0.25 + spacerH;\n        float i = cell_gradient( q, y, h ); // monochrome gradient ramp\n\n        // y = 0 at bottom\n        if( q.y <= (y + h*4./4.) ) // 18 columns x 4 rows\n        {\n            if( q.y < (y + h*1./4.) ) { a = i; b = i; }\nelse        if( q.y < (y + h*2./4.) ) { a = i; b = z; }\nelse        if( q.y < (y + h*3./4.) ) { a = z; b = i; }\nelse        if( q.y < (y + h*4./4.) ) { a = z; b = z; }\n\n            float j = bBoolean( x-2.0, a, b );\n            float k;\n\n            if( x == 0.0 ) { color = colorA * a; k = a; }\n            if( x == 1.0 ) { color = colorB * b; k = b; }\n            if( x >= 2.0 ) { color = colorF * j; k = j; }\n\n            if( m )\n                color = hsv2rgb( vec3( fract(2./3. * (1.0 - k)), 1.0, 1.0 ) );\n\n            // horizontal grid lines at bottom of cell\n            GRID_HORZ_COLOR\n        }\n    }\n    else\n    if( q.y >= 0.0) // bottom - proper gradient Boolean\n    {\n        y  = 0.0;\n        float i = cell_gradient( q, y, h ); // monochrome gradient ramp\n\n        // y = 0 at bottom\n        if( q.y <= (y + h*4./4.) ) // 18 columns x 4 rows\n        {\n            // 18 columns x 4 rows\n            if( q.y < (y + h*1./4.) ) { a = i; b = i; }\nelse        if( q.y < (y + h*2./4.) ) { a = i; b = z; }\nelse        if( q.y < (y + h*3./4.) ) { a = z; b = i; }\nelse        if( q.y < (y + h*4./4.) ) { a = z; b = z; }\n\n            // Alternatively: i = max(a,b) //For the first 8 columns\n            float j = fBoolean( x-2.0, a, b, i );\n\n            if( x == 0.0 ) { color = vec3(a); } // Column  0 = A\n            if( x == 1.0 ) { color = vec3(b); } // Column  1 = B\n            if( x >= 2.0 ) { color = vec3(j); } // Columns 2..18 = Truth Table\n\n            if( m )\n                color = hsv2rgb( vec3( fract(2./3. * (1.0 - color.r)), 1.0, 1.0 ) );\n\n            // horizontal grid lines at bottom of cell\n            GRID_HORZ_COLOR\n        }\n    }\n\n    /*\n        NOTE:\n\n        Color Gradients can be used to verify correct floating-point Boolean Operators\n        show if the output gradient has the same gradient as the input\n\n        i.e.\n\n        When\n\n            a = 0.0 .. 1.0\n            b = 0.0 .. 1.0\n\n        And\n            g = max(a,b)\n\n        Then AND is usually defined as a*b\n        Except this has the wrong gradient due to incorrect scaling.\n\n                         Wrong   Wrong          Wrong    Correct\n            a     b      a*b     a*b/sqrt(a*b)  2.0*a*b  max(a,b)*(ceil(a)*ceil(b))\n            1.00  0.50   0.5     0.7071         2.00     1.00\n            0.75  0.75   0.5625  0.75           1.125    0.75\n            0.5   0.5    0.25    0.50           0.05     0.50\n            0.25  0.25   0.0625  0.25           0.125    0.25\n            0.0   0.75   0.0     NaN            0.0      0.0\n            0.75  0.0    0.0     NaN            0.0      0.0\n    */\n\n    // Slightly dim every other column in the table for readability\n    if( (x >= 2.0 && mod(x,2.0) == 0.0) )\n        color *= 0.95;\n\n    f.rgb = color;\n}","name":"Image","description":"","type":"image"}]}