{"ver":"0.1","info":{"id":"dssBDX","date":"1689249567","viewed":78,"name":"Inversive Dipole WNF Isosurface ","username":"chronos","description":"Inverting the dipole winding number field through a circle.\n\nRead the image tab!","likes":10,"published":1,"flags":32,"usePreview":0,"tags":["number","field","dipole","winding"],"hasliked":0,"parentid":"dssfWj","parentname":"Winding Field Jump Flood SDF"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n\nVersion of a previous shader where the winding number dipoles and sample points are passed through a\ncircle inversion of the plane. Aka a Kelvin transform, aka inversive geometry transform.\n\nOriginal surface on the left, inverted surface on the right.\n\nWhite circle is the inversion circle. It's parameters are in the common tab.\n\nBuffer A computes the inverted winding number field.\nBuffer B computes the distance field of the inverted WNF using jump flood\nBuffer C computes the original winding number field.\nBuffer D computes the distance field of the original WNF using jump flood\n\nDescription from previous shader below:\n\n-------------------------------------------------------------------------------------------------\n\nUsing Jump flood algorithm to create a signed distance field from the isosurface of the dipole winding number field.\n\nThe winding number field is used to create an isosurface from a set of points.\nThen the jump flood algorithm is used to generate an unsigned distance field from the isosurface.\nFinally, the winding number field is used to generate a sign for the distance field.\n\nI haven't seen this method implemented anywhere else yet.\nLet me know if you use this method for something cool!\n\nNote that there are some singularities in the WNF where the dipoles are located!\n\n*/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 color = vec3(0);\n    \n    vec2 uv = (2.*fragCoord - iResolution.xy) / iResolution.y;\n    \n    bool flip = step(0., uv.x + sin(iTime) * iResolution.x/iResolution.y) > 0.5;\n    \n    #if 1\n    vec4 samp = flip ?\n        texelFetch(iChannel1, ivec2(fragCoord), 0):\n        texelFetch(iChannel3, ivec2(fragCoord), 0);\n    float dist = length(samp.rg);\n    color = vec3(.5*(1.+normalize(samp.rg)), dist / 500.);\n    \n    \n    vec4 mouse_samp = \n        flip ? \n        texelFetch(iChannel1, ivec2(iMouse.xy), 0) :\n        texelFetch(iChannel3, ivec2(iMouse.xy), 0);\n    float mouse_dist = length(mouse_samp.rg);\n    float mouse_winding_number = \n        \n        flip ?\n        texelFetch(iChannel0, ivec2(iMouse.xy), 0).b:\n        texelFetch(iChannel2, ivec2(iMouse.xy), 0).b;\n    \n    float inversion_circle = smoothstep(0.01, 0., abs(distance(uv, circle_pos) - circle_radius));\n    \n    float mouse_circle= smoothstep(2., 1., abs(distance(fragCoord.xy, iMouse.xy) - mouse_dist));\n    \n    mouse_winding_number = -sign(mouse_winding_number-.5);\n    vec3 circle_color = max(vec3(-mouse_winding_number, mouse_winding_number, 1.-abs(mouse_winding_number)), 0.);\n    \n    \n    float pixel_winding_number = \n        flip ?\n        -sign(texelFetch(iChannel0, ivec2(fragCoord.xy), 0).b-.5) :\n        -sign(texelFetch(iChannel2, ivec2(fragCoord.xy), 0).b-.5);\n    color = mix(color, 1.-color, (1.+pixel_winding_number)*.5);\n    \n    \n    color = mix(color, circle_color, mouse_circle);\n    \n    color = mix(color, vec3(1),inversion_circle);\n    \n    vec2 line_seg = project_point_to_line_segment(fragCoord, iMouse.xy, iMouse.xy+mouse_samp.rg);\n    \n    const float dir_alpha = 0.5;\n    float dir_indicator = dir_alpha * smoothstep(2.1, 2., distance(fragCoord, line_seg));\n    color = mix(color, vec3(1), dir_indicator);\n    \n    color += dist / 1000.;\n    \n    fragColor = vec4(pow(color, vec3(1./GAMMA)),1.0);\n    \n    #else\n    \n    vec3 samp = texelFetch(iChannel0, ivec2(fragCoord), 0).aaa;\n    color = vec3(samp);\n    fragColor = vec4(pow(color, vec3(1./GAMMA)),1.0);\n    #endif\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.*fragCoord - iResolution.xy) / iResolution.y;\n    vec2 mouse = (2.*iMouse.xy - iResolution.xy) / iResolution.y;\n\n    vec2 query = circle_inversion(uv, circle_pos, circle_radius);\n        \n    const float num_points = 10.;\n\n    float winding_number = 0.;\n    \n    for(float i = 0.; i < num_points; ++i)\n    {\n        float radius = 0.5 + cos(i)*0.25;\n    \n        point p;\n        float angle = (i / num_points) * 2. * PI;\n        p.position = radius * vec2(cos(angle), sin(angle));\n        \n        p.normal = normalize(p.position);                   // Outward pointing normals\n        vec2 offset_point = p.position + p.normal;\n        \n        vec2 inverted_offset_point = circle_inversion(offset_point, circle_pos, circle_radius);\n        \n        vec2 inverted_normal = normalize(inverted_offset_point);\n        \n        p.position = circle_inversion(p.position, circle_pos, circle_radius);\n        p.normal = inverted_normal;\n        \n        p.area = (1. / num_points) * 2. * PI * radius;      // perimeter of circle by number of segments, in place of surface area.\n        winding_number += winding(query, p);\n    }\n    \n    // Mouse interaction\n    if(false)\n    {\n        point p;\n        p.position = mouse;\n        p.normal = normalize(p.position);                   \n        p.area = (1. / num_points) * 2. * PI * length(mouse);\n        winding_number += winding(query, p);\n    }\n    \n    vec2 gradient = vec2(dFdx(winding_number), dFdy(winding_number));\n    float gradient_length = length(gradient);\n    vec2 unit_gradient = normalize(gradient);\n    float level = 0.5; // See page 7, figure 8 of paper\n    float eps = 5. * gradient_length;   // arbitrary small-ish number\n    float iso = smoothstep(level-eps, level, winding_number) * smoothstep(level+eps, level, winding_number);\n        \n    vec3 color = max(vec3(-winding_number, winding_number, 1.-abs(winding_number)), 0.);\n\n    color = mix(color, vec3(1), iso);\n    \n    fragColor = vec4(0., 0., winding_number, iso);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    ivec2 ij = ivec2(fragCoord);\n    \n    const int STEP_FRAMES = 30;\n    if(iFrame % STEP_FRAMES != 0)\n    {\n       fragColor = texelFetch(iChannel1, ij, 0);\n       return;\n    }\n\n    const int N = 9;\n    \n    // pow2, e.g.: 256, 128, 64, 32, 16, 8, 4, 2, 1\n    int jump_size = (1 << N) >> min(iFrame/STEP_FRAMES, N); \n    \n    // Initialize variables\n    float current_dist = 9e9;\n    vec2 current_offset = vec2(0);\n    float current_fill = 0.;\n    \n    if(iFrame == 0)\n    {\n        fragColor = texelFetch(iChannel0, ij, 0);\n        return;\n    }\n    \n    for(int x = -1; x <= 1; ++x)\n    for(int y = -1; y <= 1; ++y)\n    {\n        ivec2 jump = jump_size*ivec2(x,y);\n        ivec2 coord = ij + jump;\n        if(coord.x < 0 || coord.y < 0 || coord.x >= int(iResolution.x) || coord.y >= int(iResolution.y))\n        {\n            continue;\n        }\n\n        vec4 samp = texelFetch(iChannel1, coord, 0);\n\n        bool samp_fill = samp.a >= 0.5;\n        vec2 samp_offset = samp.rg;\n\n        vec2 candidate_offset = vec2(jump) + samp_offset;\n        float candidate_dist = length(candidate_offset);\n\n        if (candidate_dist <= current_dist && samp_fill)\n        {\n            current_dist = candidate_dist;\n            current_offset = candidate_offset;\n            current_fill = 1.;\n        }\n\n    }\n\n    // save offset and fill\n    fragColor = vec4(current_offset, 0., current_fill);\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"const float GAMMA = 2.2;\nconst float PI = 3.14159265359;\n\n\nvec2 project_point_to_line_segment(vec2 point, vec2 a, vec2 b)\n{\n    vec2 ab = b - a;\n    vec2 ap = point - a;\n    return clamp(dot(ap, ab) / dot(ab,ab), 0., 1.) * ab + a;\n}\n\nvec2 circle_inversion(vec2 p, vec2 center, float radius)\n{\n    vec2 offset = (p - center);\n    return center + radius * radius * offset / dot(offset, offset);\n}\n\n\nvec2 circle_pos = vec2(0);\nfloat circle_radius = 0.5;\n\n\nstruct point\n{\n    vec2 position;\n    vec2 normal;   // dipole direction\n    float area;    // represented surface area \n};\n\nfloat winding(vec2 query, point p)\n{\n    // 3D greens function:  -1 / (4. * PI * r), where r = distance(query, point_position)\n    float r = distance(p.position, query);\n    return p.area * dot(p.position - query, p.normal) / (4. * PI * pow(r, 3.));\n}","name":"Common","description":"","type":"common"},{"inputs":[],"outputs":[{"id":"4sXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.*fragCoord - iResolution.xy) / iResolution.y;\n    vec2 mouse = (2.*iMouse.xy - iResolution.xy) / iResolution.y;\n\n    vec2 query = uv;\n        \n    const float num_points = 10.;\n\n    float winding_number = 0.;\n    \n    for(float i = 0.; i < num_points; ++i)\n    {\n        float radius = 0.5 + cos(i)*0.25;\n    \n        point p;\n        float angle = (i / num_points) * 2. * PI;\n        p.position = radius * vec2(cos(angle), sin(angle));\n        p.normal = normalize(p.position);                   // Outward pointing normals\n        p.area = (1. / num_points) * 2. * PI * radius;      // perimeter of circle by number of segments, in place of surface area.\n        winding_number += winding(query, p);\n    }\n    \n    // Mouse interaction\n    if(false)\n    {\n        point p;\n        p.position = mouse;\n        p.normal = normalize(p.position);                   \n        p.area = (1. / num_points) * 2. * PI * length(mouse);\n        winding_number += winding(query, p);\n    }\n    \n    vec2 gradient = vec2(dFdx(winding_number), dFdy(winding_number));\n    float gradient_length = length(gradient);\n    vec2 unit_gradient = normalize(gradient);\n    float level = 0.5; // See page 7, figure 8 of paper\n    float eps = 5. * gradient_length;   // arbitrary small-ish number\n    float iso = smoothstep(level-eps, level, winding_number) * smoothstep(level+eps, level, winding_number);\n        \n    vec3 color = max(vec3(-winding_number, winding_number, 1.-abs(winding_number)), 0.);\n\n    color = mix(color, vec3(1), iso);\n    \n    fragColor = vec4(0., 0., winding_number, iso);\n}","name":"Buffer C","description":"","type":"buffer"},{"inputs":[{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    ivec2 ij = ivec2(fragCoord);\n    \n    const int STEP_FRAMES = 30;\n    if(iFrame % STEP_FRAMES != 0)\n    {\n       fragColor = texelFetch(iChannel1, ij, 0);\n       return;\n    }\n\n    const int N = 9;\n    \n    // pow2, e.g.: 256, 128, 64, 32, 16, 8, 4, 2, 1\n    int jump_size = (1 << N) >> min(iFrame/STEP_FRAMES, N); \n    \n    // Initialize variables\n    float current_dist = 9e9;\n    vec2 current_offset = vec2(0);\n    float current_fill = 0.;\n    \n    if(iFrame == 0)\n    {\n        fragColor = texelFetch(iChannel0, ij, 0);\n        return;\n    }\n    \n    for(int x = -1; x <= 1; ++x)\n    for(int y = -1; y <= 1; ++y)\n    {\n        ivec2 jump = jump_size*ivec2(x,y);\n        ivec2 coord = ij + jump;\n        if(coord.x < 0 || coord.y < 0 || coord.x >= int(iResolution.x) || coord.y >= int(iResolution.y))\n        {\n            continue;\n        }\n\n        vec4 samp = texelFetch(iChannel1, coord, 0);\n\n        bool samp_fill = samp.a >= 0.5;\n        vec2 samp_offset = samp.rg;\n\n        vec2 candidate_offset = vec2(jump) + samp_offset;\n        float candidate_dist = length(candidate_offset);\n\n        if (candidate_dist <= current_dist && samp_fill)\n        {\n            current_dist = candidate_dist;\n            current_offset = candidate_offset;\n            current_fill = 1.;\n        }\n\n    }\n\n    // save offset and fill\n    fragColor = vec4(current_offset, 0., current_fill);\n}","name":"Buffer D","description":"","type":"buffer"}]}