{"ver":"0.1","info":{"id":"lldSzn","date":"1478018566","viewed":554,"name":"Stellated octahedron","username":"decrooks","description":"Stellated octahedron as the sum of dual tetrahedra.","likes":17,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","sdf","tetrahedron","octahedron","stellated"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Created by David Crooks\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n#define TWO_PI 6.283185\n#define PI 3.14159265359\n\nstruct Ray {\n   vec3 origin;\n   vec3 direction;\n};\n\nstruct LightColor {\n\tvec3 diffuse;\n\tvec3 specular;\n};\n    \n    \nstruct Material {\n    LightColor  color;\n    float shininess;\n    float mirror;\n    float refractiveIndex;\n    float opacity;  \n};\n    \n    \nstruct MapValue {\n    float \t  signedDistance;\n    Material  material;\n};\n\nstruct Trace {\n    float    dist;\n    vec3     p;\n    vec3 normal;\n    Ray \t ray;\n    Ray reflection;\n\n    Material material;\n    bool hit;\n};\n    \n\nstruct PointLight {\n    vec3 position;\n    LightColor color;\n};\n    \nstruct DirectionalLight {\n    vec3 direction;\n    LightColor color;\n};\n    \nPointLight  light1,light2,light3;\nDirectionalLight dirLight;\n\nMaterial blackMat,whiteMat,bluishMat,yellowMat,oscMat,tableMat,tableDarkMat;\n\nvec3 rayPoint(Ray r,float t) {\n \treturn r.origin +  t*r.direction;\n}\n\nMapValue intersectObjects( MapValue d1, MapValue d2 )\n{\n    if (d1.signedDistance>d2.signedDistance){\n    \treturn    d1 ;\n    }\n    else {\n        d2.material = d1.material;\n    \treturn d2;\n    }\n}\n\nMapValue addObjects(MapValue d1, MapValue d2 )\n{\n    if (d1.signedDistance<d2.signedDistance) {\n    \treturn    d1 ;\n    }\n    else {\n    \treturn d2;\n    }\n}\n\n\nMapValue subtractObjects( MapValue A, MapValue B )\n{\n    //A-B\n    if (-B.signedDistance>A.signedDistance){\n        B.signedDistance *= -1.0;\n        B.material = A.material;\n    \treturn    B ;\n    }\n    else {\n       \n    \treturn A;\n    }\n}\n\nmat3 rotationMatrix(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat3(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s, \n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  \n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c);\n}\n\n\n//sdCapsule by iq\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\nMapValue plane(vec3 p, vec3 origin, vec3 normal , Material m ){\n    vec3 a = p - origin;\n    MapValue mv;\n    mv.material = m;\n\n    mv.signedDistance = dot(a,normal);\n    return mv;\n}\n\nfloat  plane(vec3 p, vec3 origin, vec3 normal){ \n\treturn dot(p - origin,normal);   \n}\n\n\nfloat tetrahedron(vec3 p, float d) {\n    \n    float dn =1.0/sqrt(3.0);\n\n\n    float mv1 = plane(p,vec3(d,d,d) ,vec3(-dn,dn,dn)) ; \n    float mv2 = plane(p,vec3(d,-d,-d) ,vec3(dn,-dn,dn)) ;\n    float mv3 = plane(p,vec3(-d,d,-d) ,vec3(dn,dn,-dn)) ;\n    float mv4 = plane(p,vec3(-d,-d,d) ,vec3(-dn,-dn,-dn)) ;\n\n\n    //max intersects shapes\n    //So this is the intersection of four planes.\n    return max(max(mv1,mv2),max(mv3,mv4));\n}\n\n\n\n\nfloat octahedron(vec3 p,  float d) {\n  \n    float mv = tetrahedron(p,d);\n    float mv2 = tetrahedron(-p,d);\n\n    return  max(mv,mv2); \n}   \n\nfloat stellatedOctahedron(vec3 p,  float d) {\n  \n    float mv = tetrahedron(p,d);\n    float mv2 = tetrahedron(-p,d);\n\t\n    //The stellated Octahedron is \n    return  min(mv,mv2); \n}   \n\n\nbool tileing(vec2 point)\n{\n    float t = iTime;\n    float h = sqrt(3.0)/2.0;\n   \tvec3 u = vec3(1.0,-0.5,-0.5);\n   \tvec3 v = vec3(0,h,-h);\n    \n    vec3 n = vec3(0.5);\n    \n    float scaleFactor = 5.0;\n    vec2 q = point*scaleFactor + 0.3*iTime;\n    vec3 p = n + q.x*u +q.y*v;\n    \n    p = floor(p);\n    \n    float i = p.x + p.y + p.z;\n    float j = p.x  + p.y;\n    float k = p.x  + p.z;\n    \n    float a = mod(i,2.0);\n    float b = mod(j,2.0);\n    float c = mod(k,2.0);\n        \n    if (a>0.1)\n    {\n        return false;\n    }\n    else {\n        if(b>0.1){\n           if(c>0.1){\n            \treturn false;\n        \t}\n        \telse {\n            \treturn true;\n        \t} \n        }\n        else {\n        \treturn true;\n        }\n    }\n}\n\n\n\nbool octTileing3d(vec2 point)\n{\n    //This pattern takes a slice through a grid of stellated octahedron.\n    //I'm fairly sure there are much more effiecient ways to draw this tiling - e.g. with alternating cubes.\n    //But I think its interesting to use the geomtry of the stellated octahedron.\n    \n    float t = iTime;\n    float h = sqrt(3.0)/2.0;\n   \tvec3 u = vec3(1.0,-0.5,-0.5);\n   \tvec3 v = vec3(0,h,-h);\n    \n    vec3 n = vec3(0.5);\n    float scaleFactor = 2.5;\n    vec2 q = point*scaleFactor;\n    vec3 p = n + q.x*u +q.y*v;\n    \n    vec3 w = mod(p,1.0);\n    w = 2.0*w - vec3(1.0);\n    \n    float o1 = octahedron(w,1.0);\n    float o2 = octahedron(w,0.8);\n    float so1 = stellatedOctahedron(v,1.0);\n    \n    if(o1>0.0){\n        //outside octahedron o1\n        if(so1>0.0){\n            //outside stellatedOctahedron\n            return true;\n        }\n        else{\n            //inside stellatedOctahedron\n           return false; \n        }  \n    }else{\n        //inside octahedron o1\n        if(o2>0.0){\n            //outside octahedron o2\n            return true;\n        }\n        else{\n            //inside octahedron o2\n            return false;\n        }\n    }\n}\n\nMapValue xzPlane( vec3 p ,float y, Material m)\n{\n    MapValue mv;\n    mv.material = m;\n    mv.signedDistance = p.y - y;\n    return mv;\n}\n\n#define USE_OCTAHEDRAL_PATTERN false\n\nMapValue tableTop( vec3 p ,float y, Material m1,Material m2)\n{\n \tMaterial  m;\n    //Draw a pattern on the table top by taking a 2d slice through a 3d checkerboard.\n   \n    bool patternValue;\n    \n    if(USE_OCTAHEDRAL_PATTERN){\n        //This is slow, but its nice that the pattern is based on the geometry of the stellated octahedron. \n        patternValue = octTileing3d(p.xz);\n    }\n    else {\n        //Similar pattern, but faster.\n        patternValue = tileing(p.xz);\n    }\n    \n    if(patternValue){\n        m = m1;\n    }\n    else {\n       m = m2 ;\n    }\n    \n  return xzPlane( p ,y, m);\n}\n\n\n\nMapValue cubeFrame(vec3 p, float d,float thickness, Material m){\n    \n    MapValue mv;\n    mv.material = m;\n\n    float r = d*thickness;\n    float dt = sdCapsule(  p, vec3(d,d,d),vec3(-d,d,d), r );\n    \n    //min adds shapes\n    dt = min(dt,  sdCapsule(  p, vec3(-d,d,d),vec3(-d,-d,d), r ));\n    dt = min(dt,  sdCapsule(  p, vec3(-d,-d,d),vec3(d,-d,d), r ));\n    dt = min(dt,  sdCapsule(  p, vec3(d,-d,d),vec3(d,d,d), r ));\n\n    dt = min(dt,  sdCapsule(  p, vec3(d,d,-d),vec3(-d,d,-d), r ));\n    dt = min(dt,  sdCapsule(  p, vec3(-d,d,-d),vec3(-d,-d,-d), r ));\n    dt = min(dt,  sdCapsule(  p, vec3(-d,-d,-d),vec3(d,-d,-d), r ));\n    dt = min(dt,  sdCapsule(  p, vec3(d,-d,-d),vec3(d,d,-d), r ));\n\n    dt = min(dt,  sdCapsule(  p, vec3(d,d,-d),vec3(d,d,d), r ));\n    dt = min(dt,  sdCapsule(  p, vec3(-d,d,-d),vec3(-d,d,d), r ));\n    dt = min(dt,  sdCapsule(  p, vec3(-d,-d,-d),vec3(-d,-d,d), r ));\n    dt = min(dt,  sdCapsule(  p, vec3(d,-d,-d),vec3(d,-d,d), r ));\n\n    mv.signedDistance = dt;\n\n    return mv;\n}\n\n\nMapValue stellatedOctahedron(vec3 p,float d, Material m) {\n  return MapValue(stellatedOctahedron(p,d),m); \n}\n\nvec3 orbit(float t){\n    return vec3(sin(t),0.0,cos(t));\n}\n\nvoid setMaterials() {\n    vec3 specular = vec3(1.0); \n    float shininess = 16.0;\n    whiteMat = Material(LightColor(0.95*vec3(1.0,1.0,1.0),0.3*vec3(1.0,1.0,1.0)) ,shininess ,0.75,1.0,1.0);\n    tableDarkMat = Material(LightColor(vec3(0.2,0.2,0.35),vec3(0.33,0.33,0.31)) ,shininess ,0.75,1.0,1.0);   \n}\n\n///////////////////////////////////////////////////////////////\n//------------------- Map the scene -------------------------//\n\n\nMapValue map(vec3 p){\n    \n   float t  = iTime;\n   mat3 rotate = rotationMatrix(orbit(0.2*t),0.67*t);\n   vec3 q = rotate*p;\n    \n   MapValue objects = stellatedOctahedron(q,0.5,whiteMat);\n   //Add a frame to show how the stellated octahedron is embedded in a cube\n   objects = addObjects(objects,cubeFrame(q,0.5,0.04,whiteMat));\n   //patterned tabletop\n   objects = addObjects(objects,tableTop(p,-1.0,whiteMat,tableDarkMat));\n   //add a  roof to reflect off\n   objects = addObjects(objects,xzPlane(-p,-2.0,whiteMat));\n    \n   return objects;\n}\n\n////////////////////////////////////////////////////////////\n//------------------- Raytracing -------------------------//\n\n\nvec3 calculateNormal(vec3 p) {\n    float epsilon = 0.001;\n    \n    vec3 normal = vec3(\n                       map(p +vec3(epsilon,0,0)).signedDistance - map(p - vec3(epsilon,0,0)).signedDistance,\n                       map(p +vec3(0,epsilon,0)).signedDistance - map(p - vec3(0,epsilon,0)).signedDistance,\n                       map(p +vec3(0,0,epsilon)).signedDistance - map(p - vec3(0,0,epsilon)).signedDistance\n                       );\n    \n    return normalize(normal);\n}\n\n\nTrace castRay(in Ray ray, float maxDistance){\n    float dist = 0.01;\n    float presicion = 0.001;\n\tvec3 p;\n    MapValue mv;\n    bool hit = false;\n    for(int i=0; i<64; i++){\n    \tp = rayPoint(ray,dist);\n       \tmv = map(p);\n         dist += 0.5*mv.signedDistance;\n        if(mv.signedDistance < presicion)\n        {\n          hit = true; \n            break;\n        } \n         if(dist>maxDistance) break;\n       \n    }\n    return Trace(dist,p,p,ray,ray,mv.material,hit);\n}\n\nTrace traceRay(in Ray ray, float maxDistance) {\n    Trace trace = castRay(ray,maxDistance);\n    trace.normal = calculateNormal(trace.p);\n    trace.reflection = Ray(trace.p,reflect(ray.direction, trace.normal));\n\n    return trace;\n}\n\nfloat castShadow(in Ray ray, float dist){\n    Trace trace = castRay(ray,dist);\n    float maxDist = min(1.0,dist);\n    float result = trace.dist/maxDist;\n   \n    return clamp(result,0.0,1.0);\n}\n\nRay cameraRay(vec3 viewPoint, vec3 lookAtCenter, vec2 p , float d){ \n\tvec3 v = normalize(lookAtCenter -viewPoint);\n    \n    vec3 n1 = cross(v,vec3(0.0,1.0,0.0));\n    vec3 n2 = cross(n1,v);  \n        \n    vec3 lookAtPoint = lookAtCenter + d*(p.y*n2 + p.x*n1);\n                                    \n    Ray ray;\n                    \n    ray.origin = viewPoint;\n   \tray.direction =  normalize(lookAtPoint - viewPoint);\n    \n    return ray;\n}\n\nvec3 diffuseLighting(in Trace trace, vec3 lightColor,vec3 lightDir){\n    float lambertian = max(dot(lightDir,trace.normal), 0.0);\n  \treturn  lambertian * trace.material.color.diffuse * lightColor; \n}\n\n\n\nvec3 cookTorranceSpecularLighting(in Trace trace, vec3 lightColor,vec3 L){\n    //https://en.wikipedia.org/wiki/Specular_highlight#Cook.E2.80.93Torrance_model\n    //https://renderman.pixar.com/view/cook-torrance-shader\n    \n    vec3 V = -trace.ray.direction;\n\n    vec3 H = normalize(L + V);\n    \n    float NdotH = dot(trace.normal, H);\n    float NdotV = dot(trace.normal, V);\n    float VdotH = dot(V ,H );\n    float NdotL = dot(trace.normal , L);\n    \n    float lambda  = 0.25;\n    float F = pow(1.0 + NdotV, lambda);\n    \n    float G = min(1.0,min((2.0*NdotH*NdotV/VdotH), (2.0*NdotH*NdotL/VdotH)));\n    \n    \n   // Beckmann distribution D\n    float alpha = 5.0*acos(NdotH);\n    float gaussConstant = 1.0;\n\tfloat D = gaussConstant*exp(-(alpha*alpha));\n    \n    \n    float c = 1.0;\n    float specular = c *(F*D*G)/(PI*NdotL*NdotV);\n    \n    \n    return specular * trace.material.color.specular * lightColor;\n}\n\n\n\n\nvec3 pointLighting(in Trace trace, PointLight light){\n    vec3 lightDir = light.position - trace.p;\n\tfloat d = length(lightDir);\n  \tlightDir = normalize(lightDir);\n   \n  \tvec3 color =  diffuseLighting(trace, light.color.diffuse, lightDir);\n\n    color += cookTorranceSpecularLighting(trace, light.color.specular, lightDir);\n\n    float  attenuation = 1.0 / (1.0 +  0.1 * d * d);\n    float shadow = castShadow(Ray(trace.p,lightDir),d);\n    color *= attenuation*shadow;\n    return  color;\n}\n\nvec3 directionalLighting(Trace trace, DirectionalLight light){\n\n    vec3 color =  diffuseLighting(trace, light.color.diffuse, light.direction);\n    \n    color += cookTorranceSpecularLighting(trace, light.color.specular, light.direction);\n    \n    float shadow = castShadow(Ray(trace.p,light.direction),3.0);\n    color *= shadow;\n    return  color;\n}\n\n\nvoid setLights(){\n  \tfloat  time = iTime;\n    vec3 specular = vec3(1.0);\n  \tlight1 = PointLight(vec3(cos(1.3*time),1.0,sin(1.3*time)),LightColor( vec3(1.0),specular));\n  \tlight2 = PointLight(vec3(0.7*cos(1.6*time),1.1+ 0.35*sin(0.8*time),0.7*sin(1.6*time)),LightColor(vec3(1.0),specular)); \n  //  light3 = PointLight(vec3(1.5*cos(1.6*time),0.15+ 0.15*sin(2.9*time),1.5*sin(1.6*time)),LightColor(vec3(0.6),specular));\n    //dirLight = DirectionalLight(normalize(vec3(0.0,1.0,0.0)),LightColor(vec3(0.1),vec3(0.5)));\n} \n\n\nvec3 lighting(in Trace trace){\n    vec3 color = vec3(0.01,0.01,0.1);//ambient color\n        \n\tcolor += pointLighting(trace, light1);\n\tcolor += pointLighting(trace, light2) ;\n   // color += pointLighting(trace, light3) ;\n\t//color += directionalLighting(trace, dirLight);\n    \n    return color;\n}\n\n\n\n\n\nvec3 render(vec2 p){\n    vec3 viewpoint = vec3(-1.0,1.7,-2.3);\n    \n    vec3 lookAt = vec3(0.0,-0.1,0.0);\n    \n  \tRay ray = cameraRay(viewpoint,lookAt,p,2.4);\n    vec3 color = vec3(0.0);\n    float frac = 1.0;\n   \n    float d = 0.0;\n    float maxDistance = 10.0;\n    for(int i = 0; i<3; i++) {\n        Trace trace = traceRay(ray,maxDistance);\n        \n \t\tif(i==0) d = trace.dist;\n        maxDistance -= trace.dist;\n    \tcolor += lighting(trace)*(1.0 - trace.material.mirror)*frac;\n        if(!trace.hit) break;\n        \n        frac *= trace.material.mirror;\n        if(frac < 0.1 || maxDistance<0.0) break;\n        ray = trace.reflection;\n    }\n\n   \treturn color;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = (fragCoord - 0.5*iResolution.xy) / iResolution.y;\n    \n  \tsetLights();\n    setMaterials();\n    \n   \tvec3 colorLinear =  render(p);\n    float screenGamma = 2.2;\n    vec3 colorGammaCorrected = pow(colorLinear, vec3(1.0/screenGamma));\n\tfragColor = vec4(colorGammaCorrected,1.0);\n}","name":"Image","description":"","type":"image"}]}