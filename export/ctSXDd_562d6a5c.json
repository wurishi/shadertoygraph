{"ver":"0.1","info":{"id":"ctSXDd","date":"1676765793","viewed":104,"name":"dodecahedral singularity","username":"pb","description":"fork of https://www.shadertoy.com/view/4tGGRV by zackpudil replacing mandelbox with dodecahedral ifs and other coloring and lighting changes.  you will need a high end GPU for this one ","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["fractal","dodecahedron"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// fork of https://www.shadertoy.com/view/4tGGRV by zackpudil\n// zackpudil deserves all the credit for how cool the lighting looks. \n// I replaced the mandelbox with dodecahedron gasket and made some other changes.\n// philip.bertani@gmail.com\n\nint max_iter = 5;  //try increasing if you have a  nice GPU\nfloat ifs_scale = 1.75;\nvec3 ro;\n\n\n//hard coding the vertices for a dodecahedron\nconst float gmh=(sqrt(5.)+1.)/2.;\nconst float gmi=1./gmh;\n\nvec3[] d12 = vec3[]  (\nvec3(1.,1.,1.),\nvec3(1.,1.,-1.),\nvec3(1.,-1,1.),\nvec3(1.,-1,-1.),\nvec3(-1,1.,1.),\nvec3(-1.,1.,-1),\nvec3(-1.,-1.,1.),\nvec3(-1.,-1.,-1.),\nvec3(0.,gmh,gmi),\nvec3(0.,gmh,-gmi),\nvec3(0.,-gmh,gmi),\nvec3(0.,-gmh,-gmi),\nvec3(gmi,0.,gmh),\nvec3(gmi,0.,-gmh),\nvec3(-gmi,0.,gmh),\nvec3(-gmi,0.,-gmh),\nvec3(gmh,gmi,0.),\nvec3(gmh,-gmi,0.),\nvec3(-gmh,gmi,0.),\nvec3(-gmh,-gmi,0.)\n);\n\n\nfloat hash(float n) {\n    return fract(sin(n)*50000.);\n}\n\n\nmat3 rotx(float an) {\n    float cc = cos(an), ss=sin(an);\n    return mat3(1,0.,0.,0.,cc,-ss,0.,ss,cc);\n\n}\n\nmat3 rot(float an) {\n    float cc = cos(an), ss=sin(an);\n    return mat3(cc,0.,-ss,0.,1.,0.,ss,0.,cc);\n\n}\n\n\nfloat de(vec3 z) {\n    \n    vec3 min_vtx;\n    vec3 orig_z = z;\n    int n=0;\n    float min_dist,dist_to_vtx;\n\n\n    for (int i=0; i<100; i++) {\n       \n        if ( i > max_iter ) break;\n\n        float sc = 4.;\n        float w = iTime*1.5;\n        vec3 dd_0 = rot(w)*d12[0]*sc;\n        min_vtx = dd_0;\n        min_dist=length(z-dd_0);\n        for (int j=1; j<20; j++) {\n            vec3 ddj = rot(w)*d12[j]*sc;\n            dist_to_vtx=length(z-ddj); \n            if (dist_to_vtx<min_dist) {min_vtx=ddj; min_dist=dist_to_vtx;}\n            \n        }\n        \n        z = min_vtx + ifs_scale*(z-min_vtx);\n        \n        n++;\n        \n    }\n\n    float dz = pow(ifs_scale, float(n) );\n    \n    float f = (length(z)-.9)/dz;\n    \n    f = max( f, -(length(orig_z-ro)-2.) );\n    \n    return f;\n}\n\nfloat trace(vec3 ro, vec3 rd, float mx) {\n    float t = 0.0;\n    for(int i = 0; i < 80; i++) {\n        float d = de(ro + rd*t);\n        if(d < 0.001 || t >= mx) break;\n        t += d;\n    }\n    \n    if(t < mx) return t;\n    return -1.0;\n}\n\n// Improvement thanks to Shane. vstrace= shadow trace in volumentric loop.\n// less detailed, dithering and breaks quicker.\nfloat vstrace(vec3 ro, vec3 rd, float mx) {\n    float t = 0.1*hash(dot(ro, rd));\n    for(int i = 0; i < 50; i++) {\n        float d = de(ro + rd*t);\n        if(d < 0.01 || t >= mx) break;\n        t += d;\n    }\n    \n    if(t < mx) return t;\n    return -1.0;\n}\n\nvec3 normal(vec3 p, out float e) {\n    vec2 h = vec2(0.001, 0.0);\n    \n    vec3 n1 = vec3(\n        de(p + h.xyy),\n        de(p + h.yxy),\n        de(p + h.yyx)\n\t);\n    \n    vec3 n2 = vec3(\n        de(p - h.xyy),\n        de(p - h.yxy),\n        de(p - h.yyx)\n\t);\n    \n    return normalize(n1 - n2);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n    \n    \n    ro = vec3(0.,0.,2.);\n    vec3 rd = normalize( vec3(uv, -3.));\n    \n    vec3 col = vec3(.3);\n    \n    float t = trace(ro, rd, 30.0);\n    if(t > 0.0) {\n        float edg;\n        vec3 pos = ro + rd*t;\n        vec3 nor = normal(pos, edg);\n        \n        float occ = 1.0;\n        \n        vec3 lig = normalize(-pos);\n        float dis = length(pos);\n        \n        // direct lighting with hard shadows.\n        col += 0.3*clamp(dot(lig, nor), 0.0, 1.0)\n            *step(0.0, -trace(pos + nor*0.001, lig, dis));\n        \n        // indirect lighting with ambient occlusion.\n        col += 0.3*clamp(dot(-lig, nor), 0.0, 1.0)*occ;\n        \n        col *= pos*exp(-t/2.);\n\n    }\n    \n    // volumetric shadows\n    float s = hash(dot(uv, vec2(12.23, 39.343)))*0.05;\n    float vol = 0.0;\n    // need less light strength the closer you are to the light.\n    float e = 0.35*smoothstep(0.0, 3., length(ro));\n    for(int i = 0; i < 90; i++) {\n        if(s > t) break;\n        vec3 pos = ro + rd*s;\n        \n        vec3 lig = normalize(-pos+vec3(0.,0.,-1.5+2.*sin(iTime/2.)));\n        float dis = length( pos);\n        \n        // shadow trace at each position along the march.\n        float l = step(0.0, -vstrace(pos, lig, dis));\n        // light strength is proportional to distance from light.\n        l *= e/dis;\n        \n        vol += l;\n        s += 0.1;\n    }\n    \n    // blue light rays.\n    float cx = 1.+max(0.,sin(iTime*2.));\n    col += .1*vec3(0.4*cx*vol, 0.3*cx*vol, vol/cx);\n    \n\n\tfragColor = vec4(col, 1);\n}","name":"Image","description":"","type":"image"}]}