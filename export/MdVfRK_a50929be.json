{"ver":"0.1","info":{"id":"MdVfRK","date":"1529615963","viewed":171,"name":"CEIG 2018 (3) - Multipass","username":"jcanabald","description":"Multipass rendering tutorial","likes":2,"published":1,"flags":32,"usePreview":0,"tags":["tutorial","ceig"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define frag(i,j) texture(iChannel0, (vec2(i,j)))\n\n// NOISE FUNCTIONS BY IQ\n// ---------------------\nfloat hash( float n ) { return fract(sin(n)*753.5453123); }\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    float n = p.x + p.y*157.0 + 113.0*p.z;\n    return mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                   mix( hash(n+157.0), hash(n+158.0),f.x),f.y),\n               mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                   mix( hash(n+270.0), hash(n+271.0),f.x),f.y),f.z);\n}\n\n// Cloud noise by iq: https://www.shadertoy.com/view/XslGRr\n// takes a input position + and offset vector and returns a density amount\n// derived by summing multiple layers of noise at varying strengths and scales\nfloat cloudNoise(float scale,in vec3 p, in vec3 dir)\n{\n\tvec3 q = p + dir + vec3(0.0, -0.4 * iTime, 0.0); \n    float f;\n\tf  = 0.50000*noise( q ); q = q*scale*2.02 + dir;\n    f += 0.25000*noise( q ); q = q*2.03 + dir;\n    f += 0.12500*noise( q ); q = q*2.01 + dir;\n    f += 0.06250*noise( q ); q = q*2.02 + dir;\n    f += 0.03125*noise( q );\n    return f;\n}\n\n// Sky color\nvec3 skycolor = vec3(0.7, 0.8, 1.0);\n\n// Distance field for the water surface\nfloat sdWater(in vec3 p)\n{\n    // Read data from simulation\n    vec2 tex = 0.5*p.xz/WATER_SCALE + 0.5;\n    vec4 frag = (tex.x < 0.0 || tex.y < 0.0 || tex.x > iResolution.x || tex.y > iResolution.y) ? vec4(0.0) : frag(tex.x, tex.y);\n    return p.y - 3.0*frag.x;\n}\n\n// Volumetric distance field for the c\nfloat sdCloudWater(in vec3 p)\n{\n    // Read data from simulation\n    vec2 tex = 0.5*p.xz/WATER_SCALE + 0.5;\n    vec4 frag = (tex.x < 0.0 || tex.y < 0.0 || tex.x > iResolution.x || tex.y > iResolution.y) ? vec4(0.0) : frag(tex.x, tex.y);\n    return clamp(-p.y + 3.0*frag.x + cloudNoise(2.0, p, vec3(0.1,0.1,0.1)), 0.0, 1.0);\n}\n\nvec2 scene(in vec3 p)\n{\n    return vec2(sdWater(p), 1.0);\n}\n\nvec2 sceneVolume(in vec3 p)\n{\n    return vec2(sdCloudWater(p), 1.0);\n}\n    \n\nvec3 sceneNormal(vec3 p, float eps)\n{\n    float gradX = scene( p + vec3( eps, 0.0, 0.0 ) ).x - scene( p - vec3( eps, 0.0, 0.0 ) ).x;\n    float gradY = scene( p + vec3( 0.0, eps, 0.0 ) ).x - scene( p - vec3( 0.0, eps, 0.0 ) ).x;\n    float gradZ = scene( p + vec3( 0.0, 0.0, eps ) ).x - scene( p - vec3( 0.0, 0.0, eps ) ).x;\n    \n    return normalize( vec3( gradX, gradY, gradZ ) );\n}\n\nvec2 raymarch( vec3 ro, vec3 rd )\n{\n    const float e = 0.1;\t\t// precission\n    const float tmin = 0.0;\t\t// min distance\n    const float tmax = 50.0;\t// max distance\n    \n    float t = tmin;\t\t\t\t// intersection distance\n    float id = -1.0;\t\t\t// material id\n    \n    // raymarching loop\n    for( int i=0; i<40; i++ )\n    {\n        vec2 dm = scene( ro + t*rd );\n        \n        t += dm.x;\n        id = dm.y;\n        \n        if( dm.x < e || t > tmax ) break;\n    }\n    \n    // there is not collision at all\n    if( t > tmax ) id = -1.0;\n    \n    return vec2( t, id );\n}\n\nvec4 raymarchVolume(in vec3 ro, in vec3 rd)\n{\n    vec4 sum = vec4( 0.0 );\n\n\tfloat t=0.0;\n\t\n\tfor( int i=0; i<200; i++ )\n\t{\n\t\tif( sum.a > 0.99 ) break;\n\t\t\n\t\tvec3 pos = ro + t*rd;\n        float d= sceneVolume( pos ).x;\n\t\tvec4 col = vec4(mix( vec3(1.0,1.0,1.1), vec3(0.8,0.,0.10), d ),1.);\n\n\n\t\tcol *= d;\n\n\t\tsum +=  col*(1.0 - sum.a);\t\n\n\t\tt += 0.1;\n\t}\n\n\tclamp( sum.xyz, 0.0, 1.0 );\n    return sum;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 rd = computeRay(fragCoord, ro, iResolution.xy);\n    \n    #ifdef RAYMARCHING\n    \t#ifdef VOLUMETRIC\n        \t// volume raymarching\n        \tvec4 vcolor = raymarchVolume(ro, rd);\n        \tvec3 col = vcolor.xyz + (1. - vcolor.a) * skycolor;\n\t\t#else\n            // raymarching\n            vec2 dm = raymarch(ro, rd);\n\n            vec3 col = vec3(0.92, 0.9, 0.9);\n            if(dm.y > 0.0)\n            {   \n                // Get the intersection point\n                vec3 pos = ro + dm.x*rd;\n                // Normal at intersection point\n                vec3 n = sceneNormal(pos, 0.1);\n                // Light position\n                vec3 light    = normalize(vec3(cos(iTime), -1., sin(iTime)));\n                // Diffuse component\n                float ldotn = max(0., -dot(n, light));\n               \t// Set the diffuse component as main color\n                col = vec3(ldotn);\n            }\n    \t#endif\n    #else\n    \tvec3 col = vec3(4.*(frag(fragCoord.x/iResolution.x, fragCoord.y/iResolution.y).x));\n    #endif\n    \n    fragColor = vec4(col, 1.0); \n\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define frag(i,j) texture(iChannel0, (vec2(i,j))/iResolution.xy)\n\nconst float C = 6.0;\t// wave speed\nconst float dt = 0.1;\t// time step\n\nfloat h;\t\t// heightfield at timestep t\nfloat h_1;\t\t// heightfield at timestep t-1\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    float x = fragCoord.x;\n    float y = fragCoord.y;\n    \n    // Initialization\n    if(iFrame == 0)\n    {\n        // Init the height field to 0\n       \th = 0.0;\n        \n        // Create a bump at the middle of the grid\n        float d = distance(fragCoord.xy, iResolution.xy/2.0);\n        if(d < 20.0)\n        {\n            h = cos(PI*d/40.0);\n            h_1 = h;\n        }\n    }\n    else\n    {\n        // Read previous values\n        vec4 frag = frag(x,y);\n        float hOld = frag.x;\n        float hOld_1 = frag.y;\n        \n        // 3x3 9 point stencil laplacian\n        float x_1 = max(0.0, x - 1.0);\n        float y_1 = max(0.0, y - 1.0);\n        float x1 = min(iResolution.x, x + 1.0);\n        float y1 = min(iResolution.y, y + 1.0);\n        \n        // Compute the wave equation d^2h/dt^2 = C^2 * laplacian(h)\n        // Compute the laplacian using the 5-point discrete stencil\n        vec4 laplacian = (frag(x, y1) + frag(x, y_1) + frag(x_1, y) + frag(x1, y)) \n            - 4.0 * frag(x,y);\n        \n        // Verlet Integration h(t+1) = 2*h(t) - h(t-1) + dt^2 * aceleration(t)\n        float f = 0.01; // friction\n        h = (2. - f)*hOld - (1. - f)*hOld_1 + C*C*laplacian.x*dt*dt;\n        h_1 = hOld;\n    }\n    \n    // Mouse input\n    float d;\n    vec3 pos;\n    if(iMouse.w > 0.0) \n    { \n        #ifdef RAYMARCHING\n        \t// Compute ray-plane intersection produced by the mouse\n        \tvec3 rd = computeRay(iMouse.xy, ro, iResolution.xy);\n        \tfloat t = -dot(vec3(0.0,1.0,0.0), ro)/dot(vec3(0.0,1.0,0.0), rd);\n        \t// Compute the intersection poing\n        \tpos = ro + t*rd;\n        \t// Compute the distance to the intersection point in the texture space.\n    \t\td = distance(iResolution.xy*(0.5*pos.xz/WATER_SCALE+0.5), vec2(x,y));\n        #else\n        \t// Distance from the fragment to the mouse position\n        \td = distance(iMouse.xy, vec2(x,y));\n        #endif\n        \n        // Increase the height at the affected region\n        if(d < 3.0) h += cos(PI*d/6.0)*0.03;\n    }\n    \n    fragColor = vec4(h, h_1, pos.x, pos.z);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define WATER_SCALE 25.0 \n#define PI 3.14159265359\n\n#define RAYMARCHING\n#define VOLUMETRIC\n\n// Camera origin position\nconst vec3 ro = vec3(0.0, 3.0,-12.0);\n// Camera target position\nconst vec3 ta = vec3(0.0, 0.0, 0.0);\n\n// Function that computes a ray direction for an specific pixel and camera position\nvec3 computeRay(in vec2 pos, in vec3 ro, in vec2 size)\n{\n    // Pixel coordinates\n\tvec2 q = pos / size;\n    vec2 p = -1.0 + 2.0*q;\n    // Aspect ratio\n    p.x *= size.x/size.y;\n    // FOV\n    p.x *= tan(0.5 * 45.0);\n    \n    // Compute the three camera vectors\n    // Looking in the -Z axis, Right hand rule\n    vec3 ww = normalize(ro - ta);\t\t\t\t\t\t\t// forward\n    vec3 uu = normalize(cross(vec3(0.0, 1.0, 0.0), ww));\t// right\n    vec3 vv = normalize(cross(ww, uu));\t\t\t\t\t\t// up\n    \n    vec3 rd = normalize(uu * p.x + vv * p.y - 2.0 * ww);\t// direction\n    \n    return rd;\n}","name":"Common","description":"","type":"common"}]}