{"ver":"0.1","info":{"id":"mdKGWh","date":"1678465079","viewed":191,"name":"sampling fork Phylotaxis","username":"Carandiru","description":"fork, thought - really good visualization of sampling, the area sampled, and the resulting effect of the sampling positions.\n + the # of samples doubles every 10s \n + the distance between samples is decreasing for an interval every 10s","likes":6,"published":3,"flags":0,"usePreview":0,"tags":["raytracing","dithering","phylotaxis"],"hasliked":0,"parentid":"dsG3zw","parentname":"Fibonacci Dithering"},"renderpass":[{"inputs":[{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":0,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// fork, thought - really good visualization of sampling, the area sampled, and the resulting effect of the sampling positions.\n// + the # of samples doubles every 10s \n// + the distance between samples is decreasing for an interval every 10s\n\nvec3 eval(vec2 uv, vec2 cen){\n    float sdf = length(uv - cen);\n    // Time varying pixel color\n    float c0 = step(sdf, 0.25);\n    float c1 = 1.0 - step(sdf, 0.15);\n    vec3 col = vec3(1.0 - c0*c1);\n    \n    return col;\n}\n\n//float rand(float co) { return fract(sin(co*(91.3458)) * 47453.5453); }\n//float rand(vec2 co){ return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453); }\n//float rand(vec3 co){ return rand(co.xy+rand(co.z)); }\nvec2 randv2(vec2 co){ \n\n   return( textureLod(iChannel0, (co * iResolution.xy) / 1024.0f, 0.0f).rg - 0.5f );\n   //return vec2(rand(co), rand(co + vec2(7607.0, 6211.0))) - vec2(0.5); \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 pxy = 1.0f /iResolution.xy;\n    vec2 uv = fragCoord*pxy;\n    float md = 2.0;\n\n    vec2 pxm = vec2(1.0, md * iResolution.y / iResolution.x);\n\n\n    vec2 uvm = uv;\n    uvm.x = md * mod(uvm.x, 1.0 / md);\n    uvm -= vec2(0.5, 0.5);\n    uvm *= pxm;\n    \n    int N = 16;\n    const float interval = 10.0f;\n    const float hh = 1.0f;\n    float tt = iTime;\n    \n    N = N * (int(iTime/interval) + 1);\n    float next = mod(iTime,interval);\n    tt = next/interval * tt;\n    //tt /= float(N) / 16.0f; // slow down \n    \n    // prevent performance problem:\n    if ( iTimeDelta > (1.0f/30.0f) )\n        N = 16; // reset\n        \n    if(uv.x < 1.0 / md){\n\n        float c = 0.025;\n        vec2 center = vec2(0.0, 0.0);\n        vec2 _uv = uvm - center;\n        float minDiff = 1.;\n        float index = 0.;\n        vec2 last = vec2(0);\n        \n        for(float i = 1.; i < float(N); i++) {\n            float angle = 137.5009 * i + tt;\n            float radius = c * sqrt(i/tt);\n            float x = last.x = radius * cos(angle) + last.x * hh;\n            float y = last.y = radius * sin(angle) + last.y * hh;\n            \n            vec2 pos = (vec2(x, y) * iResolution.xy + 0.5f) / iResolution.xy;\n            float diff = abs(distance(pos, _uv)) * 60.;\n            if(diff < minDiff) {\n                minDiff = diff;\n                index = i + 1.;\n            }\n        }\n        \n        minDiff = smoothstep(0., .5, minDiff);\n        minDiff = minDiff * minDiff;\n\n        fragColor = vec4(vec3(minDiff), 1);\n    } \n    else{\n \n        vec2 center = vec2(0.0, 0.0);\n        vec2 _uv = uvm - center;\n        float minDiff = 1.;\n        float index = 0.;\n        vec2 last = vec2(0);\n        vec3 col = vec3(0.0);\n        \n        float r = 100.0f / sqrt(float(N));\n       \n        for(float i = 1.; i < float(N); i++) {\n            float angle = 137.5009 * i + randv2(uvm).x + tt;\n            float radius = r * sqrt(i/tt);\n            float x = last.x = radius * cos(angle) + last.x * hh;\n            float y = last.y = radius * sin(angle) + last.y * hh;\n            vec2 pos = (vec2(x, y) + 0.5f) * pxy/pxm;\n            col += eval(uvm + pos, center);\n        }\n        \n        col /= float(N);\n\n        fragColor = vec4(col ,1.0);\n    }\n}","name":"Image","description":"","type":"image"}]}