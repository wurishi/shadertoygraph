{"ver":"0.1","info":{"id":"MscGRM","date":"1449793976","viewed":549,"name":"water simulation","username":"qq456cvb","description":"just a simulation of water, to be continued...","likes":20,"published":1,"flags":0,"usePreview":0,"tags":["water"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[],"code":"const vec3 lightDir = normalize(vec3(0, -0.3, -1));\nconst vec3 lightPos = vec3(0, 2, 4);\nconst float lightPow = 0.5;\n\nconst float ambientLightPow = 0.3;\nconst vec3 planePos = vec3(0, -1, 0);\nconst vec3 planeNormal = vec3(0, 1, 0);\n\nconst vec3 waterPos = vec3(0, 0, 0);\nconst vec3 waterNormal = vec3(0, 1, 0);\nconst float waterDirtiness = 0.4;\n\nconst vec3 white = vec3(1, 1, 1);\nconst vec3 black = vec3(0, 0, 0);\nconst vec3 skyColor = vec3(0.7, 1.0, 1.0);\nconst vec3 waterColor = vec3(176.0/255.0, 224.0/255.0, 230.0/255.0);\n\nconst int NUM_STEPS = 5;\nconst float EPSILON = 0.0001;\n\nconst vec3 refractLightDir = refract(lightDir, waterNormal, 1.0/1.5);\n\nfloat hash( vec2 p ) {\n\tfloat h = dot(p,vec2(127.1,311.7));\t\n    return fract(sin(h)*43758.5453123);\n}\nfloat noise( in vec2 p ) {\n    vec2 i = floor( p );\n    vec2 f = fract( p );\t\n\tvec2 u = f*f*(3.0-2.0*f);\n    return -1.0+2.0*mix( mix( hash( i + vec2(0.0,0.0) ), \n                     hash( i + vec2(1.0,0.0) ), u.x),\n                mix( hash( i + vec2(0.0,1.0) ), \n                     hash( i + vec2(1.0,1.0) ), u.x), u.y);\n}\n\n\nfloat specular(vec3 n,vec3 l,vec3 e,float s) {    \n    return pow(max(dot(reflect(e,n),-l),0.0),s);\n}\n\nfloat map(vec3 p)\n{\n    return p.y - 0.3*noise(p.xz+vec2(iTime));\n}\n\nfloat getHeight(vec3 ori, vec3 dir, out vec3 p)\n{\n\tfloat tm = 0.0;\n    float tx = 1000.0;    \n    float hx = map(ori + dir * tx);\n    if(hx > 0.0) {\n        p = vec3(0, 0, 0);\n        return 0.0;   \n    }\n    float hm = map(ori + dir * tm);    \n    float tmid = 0.0;\n    for(int i = 0; i < NUM_STEPS; i++) {\n        tmid = mix(tm,tx, hm/(hm-hx));                   \n        p = ori + dir * tmid;                   \n    \tfloat hmid = map(p);\n\t\tif(hmid < 0.0) {\n        \ttx = tmid;\n            hx = hmid;\n        } else {\n            tm = tmid;\n            hm = hmid;\n        }\n    }\n    return tmid;\n}\n\nvec3 getNormal(vec3 p, float eps)\n{\n\tvec3 normal;\n    normal.y = map(p);\n    normal.x = map(vec3(p.x+eps, p.y, p.z)) - normal.y;\n    normal.z = map(vec3(p.x, p.y, p.z+eps)) - normal.y;\n    normal.y = eps;\n    return normalize(normal);\n}\n\nbool intersectPlane(out vec3 color, vec3 ori, vec3 dir)\n{\n\tfloat a = dot(dir, planeNormal);\n    if (a > 0.0) {\n        color = white;\n        return false;\n    } else {\n        float dToPlane = dot(ori-planePos, planeNormal);\n        vec3 intersectPt = ori+dir*abs(dToPlane/a);\n        if (fract((floor(intersectPt.x)+floor(intersectPt.z))/2.0) == 0.5)\n        {\n            color = black;\n            color += vec3(specular(planeNormal, refractLightDir, dir, 60.0));\n            color += ambientLightPow*white;\n            color = mix(color, waterColor, waterDirtiness);\n        } else {\n        \tcolor = black;    \n        }\n        return true;\n    }\n}\n\nbool intersectWater(out vec3 color, vec3 ori, vec3 dir)\n{\n\tfloat a = dot(dir, waterNormal);\n    if (a > 0.0) {\n        color = white;\n        return false;\n    } else {\n        \n                                   \n                                   \n        vec3 intersectPt, intersectNormal;\n        getHeight(ori, dir, intersectPt);\n        vec3 dist = intersectPt-ori;\n        intersectNormal = getNormal(intersectPt, dot(dist, dist)*EPSILON);\n        \n        vec3 refractColor, reflectColor;\n        \n        //plane\n        vec3 refractDir = refract(dir, intersectNormal, 1.0/1.5);\n        intersectPlane(refractColor, intersectPt, refractDir);\n        \n        // reflect\n        reflectColor = 80.0* vec3(specular(intersectNormal, lightDir, dir, 100.0));\n        \n        // fresnel\n        float r0 = pow((1.0-1.5)/(1.0+1.5), 2.0);\n        float fresnel = r0+(1.0-r0)*(pow(1.0-abs(dot(dir, intersectNormal)), 5.0));\n                                      \n        color = refractColor*(1.0-fresnel) + reflectColor*fresnel;\n        return true; \n    }\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv*2.0 - 1.0;\n    vec3 ori = vec3(0, 2, 0);\n    vec3 dir = normalize(vec3(uv, 1.0));\n                         \n    vec3 color;\n    intersectWater(color, ori, dir)  ;             \n\tfragColor = vec4(mix(skyColor, color, \n                    smoothstep(0.0, -0.1, dir.y)), 1.0);\n}","name":"","description":"","type":"image"}]}