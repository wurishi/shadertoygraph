{"ver":"0.1","info":{"id":"wtyGWw","date":"1579125346","viewed":379,"name":"dancing robot","username":"monsterkodi","description":"a little modeling and animation experiment","likes":28,"published":1,"flags":0,"usePreview":1,"tags":["sdf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define TOY  1\n\n#ifdef TOY\n#define MAX_STEPS 64\n#define MIN_DIST  0.01\n#define MAX_DIST  80.0\n#else\n#define MAX_STEPS 64\n#define MIN_DIST  0.01\n#define MAX_DIST  100.0\n#endif\n\n#define PI 3.141592653589793\n#define ZERO min(iFrame,0)\n\n#define FLOOR -3.5\n\n#define NONE  0\n#define PLANE 1\n#define BODY  2\n#define BONE  3\n#define BULB  4\n#define PUPL  5\n\nstruct ray {\n    vec3 pos;\n    vec3 dir;\n};\n\nstruct sdf {\n    float dist;\n    vec3  pos;\n    int   mat;\n};\n\nsdf s;\nvec3 camPos;\nvec3 vec0 = vec3(0,0,0);\n\nvec3 pHip;      vec3 pHipT;     vec3 pHipL;     vec3 pHipR;     vec3 pHipUp;    vec3 pHipRotL;      vec3 pHipRotR;\nvec3 pTorsoT;   vec3 pTorsoB;   vec3 pTorsoL;   vec3 pTorsoR;   vec3 pTorsoUp;  vec3 pTorsoRotL;    vec3 pTorsoRotR;\nvec3 pEyeL;     vec3 pEyeR;     vec3 pEyeHoleL; vec3 pEyeHoleR; vec3 pEyeLensL; vec3 pEyeLensR;\nvec3 pArmL;     vec3 pArmR;     vec3 pArmLup;   vec3 pArmLx;    vec3 pArmLz;    vec3 pArmRup;   vec3 pArmRx; vec3 pArmRz;\nvec3 pLegL;     vec3 pLegR;     vec3 pLegLup;   vec3 pLegLx;    vec3 pLegLz;    vec3 pLegRup;   vec3 pLegRx; vec3 pLegRz; \nvec3 pFootL;    vec3 pFootR;    vec3 pFootLup;  vec3 pFootLz;   vec3 pFootRup;  vec3 pFootRz;\nvec3 pHandL;    vec3 pHandR;    vec3 pHandLz;   vec3 pHandRz;   vec3 pHandLup;  vec3 pHandRup;\nvec3 pHead;     vec3 pHeadUp;   vec3 pHeadZ; \nvec3 pArmLud;   vec3 pArmRud;\nvec3 pLegLud;   vec3 pLegRud;\nvec3 pElbowL;   vec3 pElbowR;\nvec3 pPalmL;    vec3 pPalmR;\nvec3 pKneeR;    vec3 pKneeL;\nvec3 pHeelL;    vec3 pHeelR;\nvec3 pToeL;     vec3 pToeR;\nvec3 pSpine;\nvec3 pNeck;\n\nvec4 qHip;      vec4 qNeck; vec4 qSpine; vec4 qTorso; \nvec4 qArmL;     vec4 qArmR; vec4 qHandL; vec4 qHandR;\nvec4 qLegL;     vec4 qLegR; vec4 qFootL; vec4 qFootR;\nvec4 qHead;     vec4 qEyes;\nvec4 qKneeL;    vec4 qKneeR;\nvec4 qElbowL;   vec4 qElbowR;\n\nfloat rad2deg(float r) { return 180.0 * r / PI; }\nfloat deg2rad(float d) { return PI * d / 180.0; }\n\n//  0000000   000   000   0000000   000000000  \n// 000   000  000   000  000   000     000     \n// 000 00 00  000   000  000000000     000     \n// 000 0000   000   000  000   000     000     \n//  00000 00   0000000   000   000     000     \n\nvec4 quatAxisAngle(vec3 axis, float angle)\n{ \n    vec4 qr;\n    float half_angle = deg2rad(angle * 0.5);\n    qr.x = axis.x * sin(half_angle);\n    qr.y = axis.y * sin(half_angle);\n    qr.z = axis.z * sin(half_angle);\n    qr.w = cos(half_angle);\n    return qr;\n}\n\nvec4 quatConj(vec4 q)\n{ \n    return vec4(-q.x, -q.y, -q.z, q.w); \n}\n  \nvec4 quatMul(vec4 q1, vec4 q2)\n{ \n    vec4 qr;\n    qr.x = (q1.w * q2.x) + (q1.x * q2.w) + (q1.y * q2.z) - (q1.z * q2.y);\n    qr.y = (q1.w * q2.y) - (q1.x * q2.z) + (q1.y * q2.w) + (q1.z * q2.x);\n    qr.z = (q1.w * q2.z) + (q1.x * q2.y) - (q1.y * q2.x) + (q1.z * q2.w);\n    qr.w = (q1.w * q2.w) - (q1.x * q2.x) - (q1.y * q2.y) - (q1.z * q2.z);\n    return qr;\n}\n\nvec3 rotate(vec4 quat, vec3 p)\n{\n    vec4 conj = quatConj(quat);\n    vec4 q_tmp = quatMul(quat, vec4(p, 0));\n    return quatMul(q_tmp, conj).xyz;\n}\n\nvec3 rotate(vec4 quat, vec3 o, vec3 p)\n{\n    vec4 conj = quatConj(quat);\n    vec4 q_tmp = quatMul(quat, vec4(p-o, 0));\n    return o + quatMul(q_tmp, conj).xyz;\n}\n\n// 00000000    0000000   000000000  \n// 000   000  000   000     000     \n// 0000000    000   000     000     \n// 000   000  000   000     000     \n// 000   000   0000000      000     \n\nvec3 rotAxisAngle(vec3 position, vec3 axis, float angle)\n{ \n    vec4 qr = quatAxisAngle(axis, angle);\n    vec4 qr_conj = quatConj(qr);\n    vec4 q_pos = vec4(position.x, position.y, position.z, 0);\n    \n    vec4 q_tmp = quatMul(qr, q_pos);\n    qr = quatMul(q_tmp, qr_conj);\n    \n    return vec3(qr.x, qr.y, qr.z);\n}\n\nvec3 rotRayAngle(vec3 position, vec3 ro, vec3 rd, float angle)\n{ \n    return rotAxisAngle(position-ro, rd-ro, angle)+ro;\n}\n\nvec3 rotY(vec3 v, float deg)\n{\n    float rad = deg2rad(deg);\n    float c = cos(rad);\n    float s = sin(rad);\n    return vec3(v.x*c+v.z*s, v.y, v.z*c+v.x*s);\n}\n\nvec3 rotX(vec3 v, float deg)\n{\n    float rad = deg2rad(deg);\n    float c = cos(rad);\n    float s = sin(rad);\n    return vec3(v.x, v.y*c+v.z*s, v.z*c+v.y*s);\n}\n\nvec3 rotZ(vec3 v, float deg)\n{\n    float rad = deg2rad(deg);\n    float c = cos(rad);\n    float s = sin(rad);\n    return vec3(v.x*c+v.y*s, v.y*c+v.x*s, v.z);\n}\n\nvec3 posOnPlane(vec3 p, vec3 a, vec3 n)\n{\n    return p-dot(p-a,n)*n;\n}\n\nvec3 posOnPlane(vec3 p, vec3 n)\n{\n    return p-dot(p,n)*n;\n}\n\nvec3 posOnRay(vec3 ro, vec3 rd, vec3 p)\n{\n    return ro + max(0.0, dot(p - ro, rd) / dot(rd, rd)) * rd;\n}\n\nbool rayIntersectsSphere(vec3 ro, vec3 rd, vec3 ctr, float r)\n{\n    return length(posOnRay(ro, rd, ctr) - ctr) < r;\n}\n\n//  0000000   00000000   \n// 000   000  000   000  \n// 000   000  00000000   \n// 000   000  000        \n//  0000000   000        \n\nfloat opUnion(float d1, float d2) \n{\n    float k = 0.05;\n    float h = clamp(0.5 + 0.5*(d2-d1)/k, 0.0, 1.0);\n    return mix(d2, d1, h) - k*h*(1.0-h);\n}\n\nfloat opUnion(float d1, float k, float d2) \n{\n    float h = clamp(0.5 + 0.5*(d2-d1)/k, 0.0, 1.0);\n    return mix(d2, d1, h) - k*h*(1.0-h);\n}\n\nfloat opDiff(float d1, float d2) \n{\n    float k = 0.05;\n    float h = clamp(0.5 - 0.5*(d2+d1)/k, 0.0, 1.0);\n    return mix(d1, -d2, h) + k*h*(1.0-h); \n}\n\nfloat opDiff(float d1, float k, float d2) \n{\n    float h = clamp(0.5 - 0.5*(d2+d1)/k, 0.0, 1.0);\n    return mix(d1, -d2, h) + k*h*(1.0-h); \n}\n\nfloat opInter(float d1, float d2) \n{\n    float k = 0.05;\n    float h = clamp(0.5 - 0.5*(d2-d1)/k, 0.0, 1.0);\n    return mix(d2, d1, h) + k*h*(1.0-h);\n}\n\n//  0000000  0000000    \n// 000       000   000  \n// 0000000   000   000  \n//      000  000   000  \n// 0000000   0000000    \n\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r)\n{\n    vec3 ab = b-a;\n    vec3 ap = p-a;\n    float t = dot(ab,ap) / dot(ab,ab);\n    t = clamp(t, 0.0, 1.0);\n    vec3 c = a + t*ab;\n    return length(p-c)-r;        \n}\n\nfloat sdTorus(vec3 p, vec3 a, vec3 n, vec2 r)\n{\n    vec3 q = p-a;\n    return length(vec2(length(posOnPlane(q, n))-r.x,abs(dot(n, q))))-r.y;\n}\n\nfloat distToDoublePlane(vec3 p, vec3 n, float d)\n{\n    float dt = dot(p,n);\n    return dt-sign(dt)*d;\n}\n\nfloat sdDoubleTorus(vec3 p, vec3 a, vec3 n, vec3 r)\n{\n    vec3 q = p-a;\n    return length(vec2(length(posOnPlane(q, n))-r.x, distToDoublePlane(n, q, r.z)))-r.y;\n}\n\nfloat sdBend(vec3 p, vec3 a, vec3 n, vec3 d, float side, vec2 r)\n{\n    vec3 q = p-a;\n\n    if (dot(q,side*d) > 0.0) return length(q)-r.y;\n    \n    vec3 c = cross(d,n);\n    vec3 pp = q - r.x*c + side*r.x*d;\n    if (dot(pp,c) > 0.0) return length(pp)-r.y;\n\n    return length(vec2(length(posOnPlane(q, n)-r.x*c)-r.x,abs(dot(n, q))))-r.y;\n}\n\nfloat sdSphere(vec3 p, vec3 a, float r)\n{\n    return length(p-a)-r;\n}\n\nfloat sdPlane(vec3 p, vec3 a, vec3 n)\n{   \n    return dot(n, p-a);\n}\n\nfloat sdHalfSphere(vec3 p, vec3 a, vec3 n, float r)\n{\n    vec3 q = p-a;\n    float dt = dot(q, n);\n    float sd = length(q)-r;\n    if (dt > 0.0)\n    {\n        return sd;\n    }\n    return max(sd,-dt);\n}\n\nfloat sdSocket(vec3 p, vec3 a, vec3 n, float r, float k)\n{\n    vec3 q = p-a;\n    float dp = dot(q, n);\n    float ds = length(q)-r;\n    if (dp > k)\n    {\n        return ds;\n    }\n    else if (ds < -k*2.0)\n    {\n        return -dp+k;\n    }\n\n    return sdTorus(q, k*n, n, vec2(0.997*r-k,k));\n}\n\nfloat sdSocket(vec3 p, vec3 a, vec3 n, float r)\n{\n    return sdSocket(p, a, n, r, 0.05);\n}\n\nfloat sdBearing(vec3 p, vec3 a, vec3 n, float r)\n{\n    return opDiff(sdSphere(p, a, r), sdPlane(p, a, n));\n}\n\n// 00000000    0000000    0000000  00000000  \n// 000   000  000   000  000       000       \n// 00000000   000   000  0000000   0000000   \n// 000        000   000       000  000       \n// 000         0000000   0000000   00000000  \n\nvoid poseDancing()\n{\n    pHip = vec3(-sin(iTime*4.0), 0, 0);\n    \n    vec3 x = vec3(1,0,0);\n    vec3 y = vec3(0,1,0);\n    vec3 z = vec3(0,0,1);\n    \n    float sq = sin(iTime*0.25);\n    float sh = sin(iTime*0.5);\n    float s1 = sin(iTime);\n    float s2 = sin(iTime*2.0);\n    float t2 = sin(iTime*2.0+PI);\n    float s4 = sin(iTime*4.0);\n    float t4 = sin(iTime*4.0+PI);\n    float s8 = sin(iTime*8.0);\n    float s16 = sin(iTime*16.0);\n    \n    vec4 q0 = vec4(0,0,0,1);            \n    vec4 q1 = quatAxisAngle(y, s2*20.0);\n    vec4 q2 = quatAxisAngle(x, s2*20.0-5.0);\n    vec4 q3 = quatAxisAngle(z, t2*10.0-10.0);\n    vec4 q4 = quatAxisAngle(x, t2*10.0);\n    vec4 q5 = quatAxisAngle(y, t4*20.0);\n    vec4 q6 = quatAxisAngle(z, t4*10.0);\n    vec4 q7 = quatAxisAngle(x, s16*3.0);\n    vec4 qh = quatAxisAngle(x, abs(s8)*(sq*20.0+40.0));\n\n    qHip    = quatMul(q2,     q1);  \n    qSpine  = quatMul(qHip,   q4);  \n    qTorso  = quatMul(qHip,   q1); \n    qNeck   = quatMul(q6,     q5);\n    qHead   = quatMul(q7,  qNeck); \n    \n    qArmL   = quatAxisAngle(z, -t2*20.0);\n    qArmR   = quatMul(quatAxisAngle(z,  s4*20.0), q3);\n    qLegR   = quatAxisAngle(z,  s4*20.0);\n    qEyes   = quatAxisAngle(y,  s1*15.0);\n            \n    qFootL  = quatAxisAngle(y, -smoothstep(0.0, 1.0, s4)*(sh*20.0+30.0));\n    qFootR  = quatAxisAngle(y,  smoothstep(0.0, 1.0, t4)*(sq*15.0+25.0));\n            \n    qLegL   = quatMul(qLegR, qFootL);  \n    qLegR   = quatMul(qLegR, qFootR);  \n    \n    qKneeL  = quatMul(qLegL, quatAxisAngle(-x, smoothstep(0.0, 1.0, s4)*(sq*40.0+50.0)));\n    qKneeR  = quatMul(qLegR, quatAxisAngle(-x, smoothstep(0.0, 1.0, t4)*(sq*40.0+50.0)));\n    qElbowL = quatMul(qArmL, quatAxisAngle( x, smoothstep(0.0, 1.0, t4)*(sq*50.0+60.0))); \n    qElbowR = quatMul(qArmR, quatAxisAngle( x, smoothstep(0.0, 1.0, s4)*(sq*50.0+60.0)));\n    \n    qHandR  = quatMul(qh, quatMul(qArmR, qElbowR));\n    qHandL  = quatMul(qh, quatMul(qArmL, qElbowL));\n}\n\nvoid poseNeutral()\n{\n    pHip = vec0;\n    \n    vec4 q = vec4(0,0,0,1);\n    qHip  = q; qNeck = q; qSpine = q; qTorso = q; \n    qArmL = q; qArmR = q; qHandL = q; qHandR = q;\n    qLegL = q; qLegR = q; qFootL = q; qFootR = q;\n    qHead = q; qEyes = q;\n    qKneeL = q; qKneeR = q;\n    qElbowL = q; qElbowR = q;\n}\n\n//  0000000   000   000  000  00     00  \n// 000   000  0000  000  000  000   000  \n// 000000000  000 0 000  000  000000000  \n// 000   000  000  0000  000  000 0 000  \n// 000   000  000   000  000  000   000  \n\nvoid calcAnim()\n{\n    pHipUp   = rotate(qHip, vec3(0,1,0));\n    pHipT    = pHip + pHipUp*0.6;\n    \n    pHipRotL = rotate(qHip, rotZ(vec3(0,1,0),  120.0));\n    pHipRotR = rotate(qHip, rotZ(vec3(0,1,0), -120.0));\n    \n    pHipL    = pHip + 0.6*pHipRotL;\n    pHipR    = pHip + 0.6*pHipRotR;\n    \n    vec3 vs = rotate(qSpine, 0.5*pHipUp);\n    pSpine   = pHipT  + vs;\n    pTorsoB  = pSpine + rotate(qSpine, vs);\n    \n    pTorsoRotL = 1.2*pHipRotL;\n    pTorsoRotR = 1.2*pHipRotR;\n    \n    pTorsoUp = pHipUp;\n    pTorsoT  = pTorsoB + pTorsoUp*1.2;\n    pTorsoR  = pTorsoT + pTorsoRotR;\n    pTorsoL  = pTorsoT + pTorsoRotL;\n    \n    vec3 vn = rotate(qNeck, 0.5*vec3(0,1,0));\n    pNeck    = pTorsoT + vn;\n    pHead    = pNeck   + rotate(qNeck, vn);\n    \n    pEyeL    = pHead + rotate(qHead, vec3( 0.5, 0.45, -1.3));\n    pEyeR    = pHead + rotate(qHead, vec3(-0.5, 0.45, -1.3));\n    pHeadUp  = rotate(qHead, vec3(0,1,0));\n    pHeadZ   = rotate(qHead, vec3(0,0,1));\n    \n    vec3 nZ = rotate(qEyes, vec3(0,0,-1));\n    vec3 eyeCam = normalize(camPos - (pEyeL+pEyeR)*0.5);\n    eyeCam = mix(nZ, eyeCam, dot(nZ, eyeCam));\n    pEyeHoleL = pEyeL+eyeCam*0.25;\n    pEyeHoleR = pEyeR+eyeCam*0.25;\n    pEyeLensL = pEyeL+eyeCam*0.2;\n    pEyeLensR = pEyeR+eyeCam*0.2;\n        \n    pArmLup = rotate(qArmL,   vec3(0,1,0));\n    pArmLud = rotate(qElbowL, vec3(0,1,0));\n    pArmLx  = rotate(qArmL,   vec3(1,0,0));\n    pArmLz  = rotate(qArmL,   vec3(0,0,1));\n    \n    pElbowL = pTorsoL +0.45*pArmLx -1.20*pArmLup;\n    pHandL  = pElbowL -1.15*pArmLud;    \n    \n    pArmRup = rotate(qArmR,   vec3(0,1,0));\n    pArmRud = rotate(qElbowR, vec3(0,1,0));\n    pArmRx  = rotate(qArmR,   vec3(1,0,0));\n    pArmRz  = rotate(qArmR,   vec3(0,0,1));\n    \n    pElbowR = pTorsoR -0.45*pArmRx -1.20*pArmRup;\n    pHandR  = pElbowR -1.15*pArmRud;    \n\n    pHandLz = rotate(qHandL, vec3(-1,0,0));\n    pHandRz = rotate(qHandR, vec3( 1,0,0));\n\n    pHandLup = rotate(qHandL, vec3(0,1,0));\n    pHandRup = rotate(qHandR, vec3(0,1,0));\n    pPalmL  = pHandL - 0.6 * pHandLup;\n    pPalmR  = pHandR - 0.6 * pHandRup;\n\n    pLegLup = rotate(qLegL, vec3(0,1,0));\n    pLegLud = rotate(qKneeL, vec3(0,1,0));\n    pLegLx  = rotate(qLegL, vec3(1,0,0));\n    pLegLz  = rotate(qLegL, vec3(0,0,1));\n    \n    pKneeL  = pHipL +0.45*pLegLx -1.20*pLegLup;\n    pFootL  = pKneeL -1.15*pLegLud;\n\n    pLegRup = rotate(qLegR, vec3(0,1,0));\n    pLegRud = rotate(qKneeR, vec3(0,1,0));\n    pLegRx  = rotate(qLegR, vec3(1,0,0));\n    pLegRz  = rotate(qLegR, vec3(0,0,1));\n    \n    pKneeR  = pHipR -0.45*pLegRx -1.20*pLegRup;\n    pFootR  = pKneeR -1.15*pLegRud;    \n\n    pFootLup = rotate(qFootL, vec3(0,1,0));\n    pFootLz  = rotate(qFootL, vec3(0,0,1));\n    pHeelL   = pFootL -0.75 * pFootLup;\n    pToeL    = pHeelL -0.75 * pFootLz;\n    \n    pFootRup = rotate(qFootR, vec3(0,1,0));\n    pFootRz  = rotate(qFootR, vec3(0,0,1));\n    pHeelR   = pFootR -0.75 * pFootRup;\n    pToeR    = pHeelR -0.75 * pFootRz;    \n}\n\n// 000   000  000  00000000   \n// 000   000  000  000   000  \n// 000000000  000  00000000   \n// 000   000  000  000        \n// 000   000  000  000        \n\nvoid hip()\n{\n    float d = sdSphere(s.pos, pHip, 0.5);\n    \n    d = opUnion(d, sdBearing(s.pos, pHipT, -pHipUp,   0.3));\n    d = opUnion(d, sdBearing(s.pos, pHipL, -pHipRotL, 0.3));\n    d = opUnion(d, sdBearing(s.pos, pHipR, -pHipRotR, 0.3));\n    \n    if (d < s.dist) { s.mat = BODY; s.dist = d; }\n}\n\n//  0000000  00000000   000  000   000  00000000  \n// 000       000   000  000  0000  000  000       \n// 0000000   00000000   000  000 0 000  0000000   \n//      000  000        000  000  0000  000       \n// 0000000   000        000  000   000  00000000  \n\nvoid spine(vec3 pos, vec3 mid, vec3 top)\n{\n    vec3 up = normalize(top-mid);\n    float d = sdBearing(s.pos, mid, up, 0.25);\n\n    if (d > s.dist+0.6) return;\n    \n    d = opUnion(d, sdCapsule(s.pos, mid, top, 0.15));\n    d = opUnion(d, sdSphere (s.pos, top, 0.25));\n\n    d = min    (d, sdSphere (s.pos, mid, 0.22));\n    d = opUnion(d, sdSphere (s.pos, pos, 0.25));\n    d = opUnion(d, sdCapsule(s.pos, pos, mid, 0.15));\n    \n    if (d < s.dist) { s.mat = BONE; s.dist = d; }\n}\n\n// 000000000   0000000   00000000    0000000   0000000   \n//    000     000   000  000   000  000       000   000  \n//    000     000   000  0000000    0000000   000   000  \n//    000     000   000  000   000       000  000   000  \n//    000      0000000   000   000  0000000    0000000   \n\nvoid torso()\n{\n    float d = sdSocket(s.pos, pTorsoT, -pTorsoUp, 1.0, 0.1);\n    \n    if (d > s.dist+0.25) return;\n    \n    d = opUnion(d, sdBearing(s.pos, pTorsoT, -pTorsoUp, 0.3));\n    d = opUnion(d, sdBearing(s.pos, pTorsoB,  pTorsoUp, 0.3));\n    d = opUnion(d, sdBearing(s.pos, pTorsoR, -pTorsoRotR, 0.3));\n    d = opUnion(d, sdBearing(s.pos, pTorsoL, -pTorsoRotL, 0.3));\n    \n    if (d < s.dist) { s.mat = BODY; s.dist = d; }\n}\n\n// 00000000  000   000  00000000  \n// 000        000 000   000       \n// 0000000     00000    0000000   \n// 000          000     000       \n// 00000000     000     00000000  \n\nvoid eye(vec3 pos, vec3 pupil, vec3 lens)\n{\n    float d = sdSphere(s.pos, pos, 0.25);\n    if (d > s.dist) return;\n    \n    d = opDiff(d, 0.01, sdSphere(s.pos, pupil, 0.125));\n\n    if (d < s.dist) { s.mat = BULB; s.dist = d; }\n    \n    d = min(d, sdSphere(s.pos, lens, 0.1));\n    \n    if (d < s.dist) { s.mat = PUPL; s.dist = d; }\n}\n\n// 000   000  00000000   0000000   0000000    \n// 000   000  000       000   000  000   000  \n// 000000000  0000000   000000000  000   000  \n// 000   000  000       000   000  000   000  \n// 000   000  00000000  000   000  0000000    \n\nvoid head()\n{\n    float d = sdSocket(s.pos, pHead, pHeadUp, 1.3, 0.1);\n    \n    if (d > s.dist+0.3) return;\n    \n    d = opUnion(d, sdBearing(s.pos, pHead, pHeadUp, 0.3));\n    d = opUnion(d, sdBearing(s.pos, pEyeL, pHeadZ, 0.33));\n    d = opUnion(d, sdBearing(s.pos, pEyeR, pHeadZ, 0.33));\n\n    if (d < s.dist) { s.mat = BODY; s.dist = d; }\n    \n    eye(pEyeL, pEyeHoleL, pEyeLensL);\n    eye(pEyeR, pEyeHoleR, pEyeLensR);\n}\n\n//  0000000   00000000   00     00  \n// 000   000  000   000  000   000  \n// 000000000  0000000    000000000  \n// 000   000  000   000  000 0 000  \n// 000   000  000   000  000   000  \n\nvoid arm(vec3 pos, float side, vec3 elbow, vec3 hand, vec3 up, vec3 ud, vec3 x, vec3 z)\n{\n    float bb = sdSphere(s.pos, elbow, 2.0);\n    if (bb > s.dist) return;\n     \n    float d = sdSphere(s.pos, pos, 0.25);\n    \n    d = opUnion(d, sdBend(s.pos, pos, z, x, side, vec2(0.45, 0.1)));\n    d = min    (d, sdCapsule(s.pos, elbow+0.75*up, elbow+0.2*up, 0.1));\n         \n    d = opUnion(d, sdTorus(s.pos, elbow, x, vec2(0.2, 0.07)));\n     \n    if (d < s.dist) { s.mat = BONE; s.dist = d; }\n    \n    d = sdCapsule(s.pos, elbow-0.25*ud, elbow-1.0*ud, 0.1);\n\n    d = opUnion(d, sdDoubleTorus(s.pos, elbow, x, vec3(0.2, 0.07, 0.15)));\n    d = opUnion(d, sdBearing(s.pos, hand, ud, 0.3));\n     \n    if (d < s.dist) { s.mat = BONE; s.dist = d; }\n}\n\n// 00000000   0000000    0000000   000000000  \n// 000       000   000  000   000     000     \n// 000000    000   000  000   000     000     \n// 000       000   000  000   000     000     \n// 000        0000000    0000000      000     \n\nvoid foot(vec3 pos, vec3 heel, vec3 toe, vec3 up)\n{\n    float d = sdHalfSphere(s.pos, heel, up, 0.5);\n    \n    if (d > s.dist+0.9) return;\n    \n    d = opUnion(d, 0.1, sdSphere(s.pos, pos, 0.25));\n    d = opUnion(d, sdHalfSphere (s.pos, toe, up, 0.4));\n    \n    d = opUnion(d, 0.02, sdTorus(s.pos, heel, up, vec2(0.53, 0.07)));\n    d = opUnion(d, 0.02, sdTorus(s.pos, toe,  up, vec2(0.43, 0.07)));\n    \n    if (d < s.dist) { s.mat = BODY; s.dist = d; }\n}\n\n// 000   000   0000000   000   000  0000000    \n// 000   000  000   000  0000  000  000   000  \n// 000000000  000000000  000 0 000  000   000  \n// 000   000  000   000  000  0000  000   000  \n// 000   000  000   000  000   000  0000000    \n\nvoid hand(vec3 pos, vec3 palm, vec3 z)\n{    \n    float d = sdSocket(s.pos, palm+z*0.15, -z, 0.5);\n    \n    d = opUnion(d, sdSphere(s.pos, pos, 0.25));\n    \n    if (d < s.dist) { s.mat = BODY; s.dist = d; }\n}\n\n// 00     00   0000000   00000000   \n// 000   000  000   000  000   000  \n// 000000000  000000000  00000000   \n// 000 0 000  000   000  000        \n// 000   000  000   000  000        \n\nfloat map(vec3 p)\n{\n    float planeDist = sdPlane(p, vec3(0,FLOOR,0), vec3(0,1,0));\n   \n    #ifndef TOY\n    if (iCamera.y < FLOOR) { planeDist = 1000.0; }\n    #endif\n     \n    s = sdf(planeDist, p, PLANE);\n         \n    hip  ();\n    spine(pHipT, pSpine, pTorsoB);\n    torso();\n    spine(pTorsoT, pNeck, pHead);\n    head ();\n             \n    arm  (pTorsoR,  1.0, pElbowR, pHandR, pArmRup, pArmRud, pArmRx,  pArmRz);\n    arm  (pTorsoL, -1.0, pElbowL, pHandL, pArmLup, pArmLud, pArmLx,  pArmLz);\n    arm  (pHipR,    1.0, pKneeR,  pFootR, pLegRup, pLegRud, pLegRx, pLegRz);\n    arm  (pHipL,   -1.0, pKneeL,  pFootL, pLegLup, pLegLud, pLegLx, pLegLz);\n    foot (pFootR,        pHeelR,  pToeR,  pFootRup);\n    foot (pFootL,        pHeelL,  pToeL,  pFootLup);\n    hand (pHandR,        pPalmR,  pHandRz);\n    hand (pHandL,        pPalmL,  pHandLz);\n    \n    return s.dist;\n}\n\nvec3 getNormal(vec3 p)\n{\n    vec3 n = vec0;\n    for (int i=ZERO; i<4; i++)\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(p+e*0.0001);\n    }\n    return normalize(n);\n}\n\n// 00     00   0000000   00000000    0000000  000   000  \n// 000   000  000   000  000   000  000       000   000  \n// 000000000  000000000  0000000    000       000000000  \n// 000 0 000  000   000  000   000  000       000   000  \n// 000   000  000   000  000   000   0000000  000   000  \n\nfloat rayMarch(vec3 ro, vec3 rd)\n{\n    float dz = 0.0;\n\n    for (int i = ZERO; i < MAX_STEPS; i++)\n    {\n        vec3 p = ro + dz * rd;\n        float d = map(p);\n        dz += d;\n        if (d < MIN_DIST) return dz;\n        if (dz > MAX_DIST) break;\n    }\n    s.mat = NONE;\n    return dz;\n}\n\n//  0000000  000   000   0000000   0000000     0000000   000   000  \n// 000       000   000  000   000  000   000  000   000  000 0 000  \n// 0000000   000000000  000000000  000   000  000   000  000000000  \n//      000  000   000  000   000  000   000  000   000  000   000  \n// 0000000   000   000  000   000  0000000     0000000   00     00  \n\nfloat hardShadow(vec3 ro, vec3 rd, float mint, float maxt, const float w)\n{\n    if (!rayIntersectsSphere(ro, rd, vec3(0,1.0,0), 5.0))\n    {\n        return 0.0;\n    }\n    \n    for (float t=mint+float(ZERO); t<maxt;)\n    {\n        float h = map(ro+rd*t);\n        if (h < 0.001)\n        {\n            return w;\n        }\n        t+=h;\n    }\n    return 1.0;\n}\n\n// 000      000   0000000   000   000  000000000  \n// 000      000  000        000   000     000     \n// 000      000  000  0000  000000000     000     \n// 000      000  000   000  000   000     000     \n// 0000000  000   0000000   000   000     000     \n\nfloat getLight(vec3 p, vec3 n)\n{\n    float t = 0.0; // sin(iTime*0.2);\n    vec3 lp = rotY(rotX(vec3(0, 10, -10), -10.0 - 20.0*t), 20.0*t);\n    vec3 l = normalize(lp - p);\n \n    float dif = dot(n,l);\n    \n    vec3 off = p+n*2.0*MIN_DIST;\n\n    dif *= hardShadow(off, normalize(lp-off), MIN_DIST, 100.0, 0.5);\n        \n    return clamp(dif, 0.0, 1.0);\n}\n\n// 00     00   0000000   000  000   000  \n// 000   000  000   000  000  0000  000  \n// 000000000  000000000  000  000 0 000  \n// 000 0 000  000   000  000  000  0000  \n// 000   000  000   000  000  000   000  \n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec3 ct;\n    \n    #ifdef TOY\n    \tct = vec0;\n    \tfloat my = -2.0*(iMouse.y/iResolution.y-0.5);\n    \tfloat mx = -2.0*(iMouse.x/iResolution.x-0.5);\n    \tfloat md = -12.5-my*2.5;\n    \tif (iMouse.z <= 0.0)\n    \t{\n        \tmx = sin(iTime*0.2)*0.5;\n    \t\tmy = sin(iTime*0.1)*0.5;\n            md = -12.5-2.5*sin(iTime*0.05);\n            ct.y = 0.4-sin(iTime*0.05)*0.4;\n    \t}\n    \telse\n        {\n            ct.y = 0.35-my*0.35;\n        }\n    \n    \tcamPos = rotAxisAngle(rotAxisAngle(vec3(0,0,md), vec3(1,0,0), 20.0+30.0*my), vec3(0,1,0), 90.0*mx);\n    #else\n        ct = iCenter; \n    \tcamPos = iCamera;\n        camPos.x *= -1.0; \n    \tct.x *= -1.0;\n    #endif\n\n    if (true) poseDancing();\n    else      poseNeutral();\n    calcAnim();\n    \n    vec3 ww = normalize(ct-camPos);\n    vec3 uu = normalize(cross(ww, vec3(0,1,0)));\n    vec3 vv = normalize(cross(uu, ww));\n    \n    vec3 rd = normalize(uv.x*uu + uv.y*vv + 1.0*ww);\n    \n    float d = rayMarch(camPos, rd);\n    int mat = s.mat;\n    \n    vec3  p = camPos + d * rd;\n    vec3  n = getNormal(p);\n    float l = getLight(p,n);\n        \n    vec3 col;\n    \n    if      (mat == NONE)  col = vec3(0,0,0); \n    else if (mat == PLANE) col = vec3(0.2,0.2,0.2); \n    else if (mat == BODY)  col = vec3(1.0,0.0,0.0); \n    else if (mat == BONE)  col = vec3(1.0,1.0,0.0);\n    else if (mat == PUPL)  col = vec3(0.5,0.5,1.0);\n    else col = vec3(1,1,1);\n\n    #ifndef TOY    \n    if (fragCoord.x < 2.5 && (iResolution.y * floor(1000.0/iMs) / 60.0 - fragCoord.y) < 2.0)\n    {\n        l = 1.0-l;\n        col = vec3(1,1,1);\n    }\n    #endif\n    \n    fragColor = vec4(col * l, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}