{"ver":"0.1","info":{"id":"lcsBRj","date":"1724066748","viewed":13,"name":"Colors and light discovery","username":"KivuSupremeKing","description":"For this shader, I wanted to put color to shapes and light, so I will try to use my knowledge on raytracing to imagine how to do it. I will try to not use tutorial for this one (I made it !).","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"mat2 rot2D(float angle)\n{\n    float s = sin(angle);\n    float c = cos(angle);\n    return mat2(c, -s, s, c);\n}\n\n\nfloat sdSphere(vec3 o, float s)\n{\n    return length(o) - s;\n}\n\nfloat sdBox(vec3 p, vec3 b)\n{\n    vec3 q = abs(p) - b;\n    return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);\n}\n\n\nfloat smin( float a, float b, float k )\n{\n    k *= 1.0;\n    float r = exp2(-a/k) + exp2(-b/k);\n    return -k*log2(r);\n}\n\n\nvec3 colorGround(vec3 p)\n{\n    float i = 0.;\n    if (p.x < 0.) i = 1.;\n    float c = float(int(floor(abs(p.x) + i)) % 2);\n    i = 0.;\n    if (p.z < 0.) i = 1.;\n    c += float(int(floor(abs(p.z) + i)) % 2);\n    if (c > 1.0) c = 0.;\n    return vec3(c);\n}\n\nvec3 colorMap(vec3 p)\n{\n    float ground = p.y + .75;\n    float sphere = sdSphere(p - vec3(2, 0, 0), 1.);\n    \n    float minV = min(ground, sphere);\n    \n    if (minV == sphere) return vec3(1, 0, 0);\n    return colorGround(p);\n}\n\n\nvec3 normalGround(vec3 p)\n{\n    return normalize(vec3(0, 1, 0));\n}\n\nvec3 normalSphere(vec3 p, vec3 o)\n{\n    return normalize(p - o);\n}\n\nvec3 normalMap(vec3 p)\n{\n    float ground = p.y + .75;\n    float sphere = sdSphere(p - vec3(2, 0, 0), 1.);\n    \n    float minV = min(ground, sphere);\n    \n    if (minV == sphere) return normalSphere(p, vec3(2, 0, 0));\n    return normalGround(p);\n}\n\n\nfloat map(vec3 p)\n{\n    float ground = p.y + .75;\n    float sphere = sdSphere(p - vec3(2, 0, 0), 1.);\n    \n    return min(ground, sphere);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //initialization\n    vec2 uv = ((fragCoord*2.) - iResolution.xy) / iResolution.y;\n    vec2 m = (iMouse.xy * 2. - iResolution.xy) / iResolution.y;\n    if (iMouse.xy == vec2(0.))\n        m = vec2(0.);\n    float fov = 1.;\n\n    vec3 ro = vec3(0, 0, -3); //ray origin\n    vec3 rd = normalize(vec3(uv * fov, 1)); //ray direction\n    \n    ro.yz *= rot2D(m.y);\n    rd.yz *= rot2D(m.y);\n    \n    ro.xz *= rot2D(m.x);\n    rd.xz *= rot2D(m.x);\n    \n    vec3 color = vec3(1.3 - min(0.2, rd.y / 2.));\n    color *= vec3(0.52, 0.80, 0.92);\n   \n    vec3 normal = vec3(0);\n    \n    \n    float t = 0.; //total distance travelled\n    \n    //lights\n    vec3 lightDir = normalize(vec3(0, -1, 0));\n    vec3 lightColor = vec3(0.5);\n    \n    vec3 lightPoint = normalize(vec3(-2, -0.5, 0));\n    vec3 lightColor2 = vec3(1., 0.8, 0.);\n    \n    vec3 p = vec3(0.);\n    \n    \n    //raymarching\n    for (int i = 0; i < 120; i += 1) {\n        p = ro + rd * t;\n\n        float d = map(p); //current distance\n\n        t += d;\n        \n        if (d < 0.01) {\n            p = ro + rd * t;\n            color = colorMap(p);\n            color += vec3(t / 50.);\n            normal = normalMap(p);\n            break;\n        }\n        \n        if (t > 100.) break; //distance maximum\n    }\n    \n    if (normal != vec3(0)) {\n        float dotV = dot(lightDir, normal) * -1.;\n        if (dotV < 0.) dotV = 0.;\n        \n        vec3 c1 = color * dotV * lightColor;\n        \n        vec3 lightPointDir = normalize(p - lightPoint);\n        dotV = dot(lightPointDir, normal) * -1.;\n        if (dotV < 0.) dotV = 0.;\n        \n        vec3 c2 = color * dotV * lightColor2;\n        \n        color = c1 + c2;\n    }\n\n    fragColor = vec4(color, 1);\n}\n","name":"Image","description":"","type":"image"}]}