{"ver":"0.1","info":{"id":"tl2cWm","date":"1594591514","viewed":100,"name":"Raycasting triangle","username":"IXshader","description":"triangle color interpolated according to its barycentric coordinates","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["triangle","barycentriccoordinates"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.1415926539\n\n//for triangle on plane Ax+By+Cz+d = 0\nbool iTriangle(in vec3 ro,in vec3 rd, in vec3 V[3], out float b[3])\n{\n\t//compute planes normal\n    vec3 vxvy = V[1] - V[0];\n    vec3 vxvz = V[2] - V[0];\n    \n    vec3 N = cross(vxvy,vxvz);\n   \t\n   \tfloat area = length(N);\n    \n    float Ndotrd = dot(N,rd);\n    \n  \t//if parallel\n    if(Ndotrd >= 0.0)\n    {\n\t\treturn false;\n    }\n    float NdotN = dot(N,N);\n  \tfloat d = dot(N,V[0]);\n    \n    float t = (dot(N,ro) + d) / Ndotrd;\n    \n    if(t < 0.0)\n    {\n        return false;\n    }\n    \n    //compute intersection point on the plane\n    vec3 p = ro + t * rd;\n    \n    //inside outside test\n    vec3 C;\n    float u , v , w;\n    \n    //edge 0\n    vec3 edge0 = V[1] - V[0];\n    vec3 vp0 = p - V[0];\n    C = cross(edge0,vp0);\n    if(dot(N,C) < 0.0) return false;\n    \n    //edge 1\n    vec3 edge1 = V[2] - V[1];\n    vec3 vp1 = p - V[1];\n    C = cross(edge1,vp1);\n    if((u =dot(N,C)) < 0.0) return false;\n    \n    //edge 2\n    vec3 edge2 = V[0] - V[2];\n    vec3 vp2 = p - V[2];\n    C = cross(edge2,vp2);\n    if(( v =dot(N,C)) < 0.0) return false;\n    \n    v /= NdotN;\n    u /= NdotN;\n    \n    w = 1.0 - u - v;\n    \n    b[0] = v;\n    b[1] = u;\n    b[2] = w;\n    \n    return true;\n}\n\n\n\n\n\n\nbool iSphere(vec3 ro , vec3 rd, vec4 spr)\n{\n    vec3 rc = ro - spr.xyz;\n    float b = dot(rc,rd);\n    float c = dot(rc,rc) - spr.w*spr.w;\n    \n    float d = b*b - c;\n    \n    if( d > 0.0)\n    {\n\t  return true;\n    }\n\telse\n    {\n\t  return false;\n    }\n\n}\n\nvoid setCamera(out vec3 ro,out vec3 rd,in vec2 uv)\n{\n    vec3 origin= vec3(0.0,0.0,1.0);\n    float fov = 45.0 * PI / 180.0;\n\t\n    vec3 zNear = vec3(0.0,0.0,-1.0);\n    float H = tan(fov*0.5);\n    \n    ro = vec3(uv.x *H,uv.y * H , zNear);\n    rd = normalize(ro - origin);\n    \n    \n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\tuv = -1.0 + 2.0 * uv;\n    uv.x *= iResolution.x / iResolution.y;\n    vec3 ro, rd;\n    \n    setCamera(ro,rd,uv);\n    \n    vec3 v[3];\n    \n    //barycentric coordinates\n    float b[3];\n    v[0] = vec3(0.0,1.0,-2.0);\n    v[1] = vec3(-1.0,-1.0,-2.0);\n    v[2] = vec3(1.0,-1.0,-2.0);\n    \n    vec3 RGB[3];\n    RGB[0] = vec3(1.0,0.0,0.0);\n    RGB[1] = vec3(0.0,1.0,0.0);\n    RGB[2] = vec3(0.0,0.0,1.0);\n    \n    \n    \n    vec3 col = iTriangle(ro,rd,v,b) ? (b[0]*RGB[1] + b[1]*RGB[0]+b[2]*RGB[2]) : vec3(0.0);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}