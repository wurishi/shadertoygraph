{"ver":"0.1","info":{"id":"4XXBWS","date":"1728811062","viewed":89,"name":"caleidoscope light ","username":"nayk","description":"originals https://www.shadertoy.com/view/lXfBzs https://www.shadertoy.com/view/4tyfWy","likes":1,"published":3,"flags":0,"usePreview":0,"tags":["light","star","caleidoscope"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define time (2.*iTime)\n#define res (iResolution)\n#define PI (3.141592)\n#define n1Q(p) p *= 2.*ri(round(atan(p.x, p.y) * 4.) / 4.)\n#define ri(a) mat2(cos(a + asin(vec4(0,1,-1,0))))\n// https://stackoverflow.com/questions/4200224/random-noise-functions-for-glsl\nfloat rand(vec2 co){\n    return fract(sin(dot(co, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nvec3 palette(float t) {\n    vec3 a = vec3(0.5,0.5,0.5);\n    vec3 b = vec3(0.5, 0.5, 0.5);\n    vec3 c = vec3(1.0, 1.0, 1.0);\n    vec3 d = vec3(0.263, 0.416, 0.557);\n    return a + b * cos(6.28318*(c*t+d));\n}\n\nmat2 rot2D(float a) {\n    float c = cos(a);\n    float s = sin(a);\n    return mat2(c, -s, s, c);\n}\n\nvec3 rot3D(vec3 p, vec3 axis, float angle) {\n\treturn mix(dot(axis, p) * axis, p, cos(angle)) \n            + cross(axis, p) * sin(angle);\n}\n\nfloat sdf_box3(vec3 p, vec3 b) {\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\nvec2 hash22(vec2 p) // https://www.shadertoy.com/view/4djSRW Hash without Sine by Dave_Hoskins\n{\n    vec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nfloat sdf_box2(vec2 p, vec2 b) {\n\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat sdf_cross(in vec3 p) {\n\n  float da = sdf_box2(p.xy,vec2(1.0));\n  float db = sdf_box2(p.yz,vec2(1.0));\n  float dc = sdf_box2(p.zx,vec2(1.0));\n  return min(da,min(db,dc));\n}\nfloat happy_star(vec2 uv, float anim)\n{\n    uv = abs(uv);\n    vec2 pos = min(uv.xy/uv.yx, anim);\n    float p = (2.0 - pos.x - pos.y);\n    return (2.0+p*(p*p-1.5)) / (uv.x+uv.y);      \n}\n\nfloat menger(vec3 p) {\n\n    float d = sdf_box3(p, vec3(1.));\n    \n    float s = 1.0;\n    for (int n=0; n<3; n++)\n   n1Q(p.xy);\n      n1Q(p.zy);\n         n1Q(p.zx);\n   p *=rot3D(p, vec3(1.,1.,1.), iTime);\n   \n    for (int m=0; m<3; m++) {\n       n1Q(p.xy);\n        vec3 a = mod(p*s, 2.0)-1.0;\n         \n        s *=5.0;\n        vec3 r = 1.0 - 3.0*abs(a);\n        float c = sdf_cross(r)/s;\n        d = max(d, c);\n    }\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord * 2. - res.xy) / res.y;\n    vec3 ro = vec3(0.);\n    vec3 rd = normalize(vec3(uv, 1.));\n    vec3 col = vec3(0.);\n\n    // animation\n    float a= (time);\n    float j =(time/PI);\n\n      \n \n    \n    // raymarching\n    float c, t = 0.;\n    for (int i = 0; i < 80 && t < 100.; ++i) {\n        float h = menger(ro + rd*t);\n        if (h < 0.001) {\n            c = .2/t;\n            c = smoothstep(0., 1., c);\n            c = pow(c, 1.2);\n            break;\n        }\n        t += h;\n    }\n    \n    col = palette(1.2*c);\n   \n        col *= .23;\n    col = col* vec3(0.5,0.5,0.55)*3.;\n\n    fragColor = vec4(col, 1.);\n     uv *= 2.0 * ( cos(iTime * 2.0) -2.5); // scale\n    float anim = sin(iTime * 12.0) * 0.1 + 1.0;  // anim between 0.9 - 1.1 \n    fragColor*= vec4(happy_star(uv, anim) * vec3(0.5,0.5,0.5)*10., 1.0);\n}","name":"Image","description":"","type":"image"}]}