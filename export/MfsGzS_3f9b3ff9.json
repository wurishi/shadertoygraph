{"ver":"0.1","info":{"id":"MfsGzS","date":"1703213838","viewed":97,"name":"3D Analytic Line Light Primitive","username":"chronos","description":"I call it analytic only because it is the solution to a line integral along the primitive of the rendering equation for the constant BRDF ( ideal diffuse).\nClick and drag to move the light!","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["3d","line","light","diffuse","analytic","neon","primitive"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n\n    3D Analytic Line Light Primitive\n    \n    I call it analytic only because it is the solution to a line integral\n    along the primitive of the rendering equation for the constant BRDF ( ideal diffuse).\n    \n    For this model, the light is not self-occluding. Idk whether that makes physical sense...\n\n    The diffuse reflection and the flux for a given point in empty space is calculated using\n    the analytical solutions for this special case of the rendering equation.\n    \n    The glow calculation should also have an integral over the ray (as well as perhaps a better scattering model),\n    so that part is not fully analytic ( it is numberically integrated along the camera ray, not the light segment)\n    but in the end it is just a bonus effect here.\n    The integral over the light segment primitive for the ground surface is without any numerical integration,\n    and takes into account the cosine term.\n    \n    I demonstrated a 2D version in my previous shader here:\n    https://www.shadertoy.com/view/DlGBWd\n    \n    \n    Click and drag to move the light!\n*/\n\n\nconst float PI = 3.14159265;\n\nfloat sRGBencode(float C_linear) { return C_linear > 0.0031308 ? (1.055 * pow(C_linear, 1./2.4) - 0.055) : (12.92 * C_linear); }\nvec3 sRGBencode(vec3 C_linear) { C_linear = clamp(C_linear, 0., 1.); return vec3(sRGBencode(C_linear.x), sRGBencode(C_linear.y), sRGBencode(C_linear.z)); }\nfloat sRGBdecode(float C_sRGB) { return C_sRGB > 0.04045 ? (pow((C_sRGB + 0.055)/1.055, 2.4) ) : (C_sRGB / 12.92); }\nvec3 sRGBdecode(vec3 C_sRGB) { return vec3(sRGBdecode(C_sRGB.x), sRGBdecode(C_sRGB.y), sRGBdecode(C_sRGB.z)); }\n\n\n// antiderivative wrt t\n// For surface, w/ cosine term\n// https://www.wolframalpha.com/input?i=integral+%28d*t+%2B+e%29+%2F+%28a%5E2+*+t%5E2+%2B+2+*+b+*+t+%2B+c%5E2%29+dt\nfloat anti_derivative(vec3 n, vec3 a, vec3 b, vec3 p, float t)\n{\n    vec3 ab = b-a;\n    vec3 pa = a-p;\n\n    float A = dot(ab, ab);\n    float B = dot(ab, pa);\n    float C = dot(pa, pa);\n    float D = dot( n, ab);\n    float E = dot( n, pa);\n    \n    float denom = sqrt(A * C - B*B);\n    \n    float F = 2. * (A * E - B * D) * atan((A * t + B), denom) / denom + D * log(A * t * t + 2. * B * t + C);\n    \n    return .5 * F / A;\n}\n\n// For surface\nfloat analytic_light_segment(vec3 n, vec3 a, vec3 b, vec3 p)\n{\n    float len_ab = length(b-a);\n    return (anti_derivative(n, a, b, p, 1.) - anti_derivative(n, a, b, p, 0.));\n}\n\n// For \"air\" / glow\nfloat flux_anti_derivative(vec3 a, vec3 b, vec3 p, float t)\n{\n    vec3 ab = b-a;\n    vec3 pa = a-p;\n\n    float A = dot(ab, ab);\n    float B = dot(ab, pa);\n    float C = dot(pa, pa);\n    \n    float discr = A * C - B*B;\n    \n    if(discr <= 0.) return 0.;\n    \n    float denom = sqrt(A * C - B*B);\n    \n    return atan((A * t + B), denom) / denom;\n}\n\n// For \"air\" / glow\nfloat flux(vec3 a, vec3 b, vec3 p)\n{\n    return \n        flux_anti_derivative( a, b, p, 1.)\n        -\n        flux_anti_derivative( a, b, p, 0.);\n}\n\nfloat intersect_floor(vec3 ro, vec3 rd, float floor_height)\n{\n    // Solve (ro + t * rd).y == floor_height\n    if(rd.y >= 0.) return -1.;\n    float t = (floor_height - ro.y) / rd.y;\n    return t;\n}\n\nvec3 seg_proj(vec3 a, vec3 b, vec3 p)\n{\n    return clamp(dot(p-a, b-a)/dot(b-a, b-a), 0., 1.) * (b-a) + a;\n}\n\nfloat seg_dist(vec3 a, vec3 b, vec3 p) { return length(seg_proj(a,b,p) - p); }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.*fragCoord-iResolution.xy) / iResolution.y;\n    vec2 m  = (2.*iMouse.xy-iResolution.xy) / iResolution.y;\n    m *= float(iMouse.z > 0.);\n\n    float aspect = iResolution.x / iResolution.y;\n\n    vec3 color = vec3(0);\n    \n    vec3 light_color = vec3(1. + sin(cos(iTime / 100.)), 1. + sin(iTime / 20.), 2.5 + cos(iTime / 50.));\n\n    vec3 ro = vec3(0., 1.5, 7.);\n    float focal = 3.;\n    vec3 rd = normalize(vec3(uv, -focal));\n    \n    float floor_height = 0.;\n    \n    float floor_t = intersect_floor(ro, rd, floor_height);\n    \n    float intensity = 1.5;\n    \n    vec3 a = vec3( cos(iTime)+ 2.*m.x/aspect, (1.1 + .5 * cos(iTime*.5)) + .5*m.y,  sin(iTime) + sin(iTime/20.));\n    vec3 b = vec3(-cos(iTime)+ 2.*m.x/aspect, (1.1 + .5 * cos(iTime*.5)) - .5*m.y, -sin(iTime) + sin(iTime/20.));\n    \n    if(floor_t > 0.)\n    {\n        vec3 p = ro + floor_t * rd;\n\n        vec3 n = vec3(0, 1, 0);\n        color += light_color * intensity * analytic_light_segment(n, a, b, p);\n    }\n    \n    float t = 0.;\n    vec3 p = ro;\n    const float eps = 1e-3;\n    const float radius = .0135;\n    float glow = 0.0003 * intensity;\n    float min_d = 9e9;\n    float core_brightness = 2.5;\n    for(int i = 0; i < 100; i++)\n    {\n        float d = seg_dist(a, b, p) - radius;\n        min_d = min(d, min_d);\n        color += light_color * glow * flux(a, b, p);\n        \n        if(d < eps)\n        {\n            color += light_color * intensity * core_brightness;\n            break;\n        }\n        t += d;\n        p = rd * t + ro;\n        if(t > 1e6) break;\n    }\n    \n    float softness = 22.5;\n    if(min_d >= eps && min_d < eps * softness) color += core_brightness*light_color * intensity * smoothstep(softness * eps, eps, min_d);\n\n    // I want your eyes to have nice pixels :)\n    color = tanh(color);\n    color = sRGBencode(color);\n    color += -.5/255. + (2.0/255.) * texelFetch(iChannel0, (ivec2(fragCoord)+iFrame*ivec2(iResolution.xy))%ivec2(textureSize(iChannel0, 0)), 0).rgb;    \n    color = clamp(color, 0., 1.);\n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}