{"ver":"0.1","info":{"id":"lt2XDW","date":"1443879366","viewed":390,"name":"StereoProj 3D","username":"Ouid","description":"Stereographic projection of a cube in a plane. A way for me to understand stereographic.\nI'm not used at shader programming and rendering technics. I prefer slowly but readable code to understand mathematics and algorithms involved.","likes":14,"published":1,"flags":0,"usePreview":0,"tags":["cube","stereographic"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Created by Mathieu Simon aka Ouid (2015)\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// ref : https://www.shadertoy.com/view/4sfGzS (noise)\n// ref : https://iquilezles.org/articles/palettes (color)\n\n//#define DEBUG\n\nconst float PI = 3.14159265359;\n\nconst float GOLDEN_RATIO = 1.6180339887498;\n\nconst float DEG_TO_RAD = 0.0174533;\n\nconst float MAX = 10000.0;\n\n#define FOV 25.0\n\n#define WITH_SHADOW 1\n#define WITH_STEREO_NORMAL 0\n\n#define PLANE(_Mat,_Vec3Point,_Vec3Normal) pointAndNormToPlane ( ( (_Mat) * vec4(_Vec3Point,1.0) ).xyz, ( (_Mat) * vec4(normalize(_Vec3Normal),0.0) ).xyz )\n#define CENTRIC_PLANE(_Mat,_dist,_Vec3Normal) pointAndNormToPlane ( ( (_Mat) * vec4(_dist*_Vec3Normal,1.0) ).xyz, ( (_Mat) * vec4(normalize(_Vec3Normal),0.0) ).xyz )\n\n\n//All planes (I'm using /* */ tricks to make new-line)\n//Object(10+x) are used to detect plane and select color\n\n#define COLOR_COUNT 12\n\n#if 0\n// tetrahedron\n\n#define CENTER(_x,_y,_z) (((_x)+(_y)+(_z))/3.0)\n#define P1 vec3(1.0,1.0,1.0)\n#define P2 vec3(1.0,-1.0,-1.0)\n#define P3 vec3(-1.0,1.0,-1.0)\n#define P4 vec3(-1.0,-1.0,1.0)\n\n#define FOREACH_PLANES(_WorldMat,_Call) /*\n*/\t_Call(CENTRIC_PLANE(_WorldMat,1.0,CENTER(P1,P2,P3)), Object(10))/*\n*/\t_Call(CENTRIC_PLANE(_WorldMat,1.0,CENTER(P1,P3,P4)), Object(11))/*\n*/\t_Call(CENTRIC_PLANE(_WorldMat,1.0,CENTER(P1,P2,P4)), Object(12))/*\n*/\t_Call(CENTRIC_PLANE(_WorldMat,1.0,CENTER(P2,P3,P4)), Object(13))\n\n#undef COLOR_COUNT\n#define COLOR_COUNT 4\n    \n#elif 0\n//cube\n\n#define FOREACH_PLANES(_WorldMat,_Call) /*\n*/\t_Call(CENTRIC_PLANE(_WorldMat,1.0,vec3(1.0,0.0,0.0)), Object(10))/*\n*/\t_Call(CENTRIC_PLANE(_WorldMat,1.0,vec3(-1.0,0.0,0.0)), Object(11))/*\n*/\t_Call(CENTRIC_PLANE(_WorldMat,1.0,vec3(0.0,1.0,0.0)), Object(12))/*\n*/\t_Call(CENTRIC_PLANE(_WorldMat,1.0,vec3(0.0,-1.0,0.0)), Object(13))/*\n*/\t_Call(CENTRIC_PLANE(_WorldMat,1.0,vec3(0.0,0.0,1.0)), Object(14))/*\n*/\t_Call(CENTRIC_PLANE(_WorldMat,1.0,vec3(0.0,0.0,-1.0)), Object(15))\n\n#undef COLOR_COUNT\n#define COLOR_COUNT 6\n\n#elif 1 \n//dodecahedron\n    \nconst float GOLDEN_DIST = (GOLDEN_RATIO*GOLDEN_RATIO) / (GOLDEN_RATIO*GOLDEN_RATIO+2.0);\n    \n#define FOREACH_PLANES(_WorldMat,_Call) /*\n*/\t_Call(CENTRIC_PLANE(_WorldMat,GOLDEN_DIST,vec3(GOLDEN_RATIO,1.0,0.0)), Object(10))/*\n*/\t_Call(CENTRIC_PLANE(_WorldMat,GOLDEN_DIST,vec3(-GOLDEN_RATIO,1.0,0.0)), Object(11))/*\n*/\t_Call(CENTRIC_PLANE(_WorldMat,GOLDEN_DIST,vec3(GOLDEN_RATIO,-1.0,0.0)), Object(12))/*\n*/\t_Call(CENTRIC_PLANE(_WorldMat,GOLDEN_DIST,vec3(-GOLDEN_RATIO,-1.0,0.0)), Object(13))/*\n*/\t_Call(CENTRIC_PLANE(_WorldMat,GOLDEN_DIST,vec3(0.0,GOLDEN_RATIO,1.0)), Object(14))/*\n*/\t_Call(CENTRIC_PLANE(_WorldMat,GOLDEN_DIST,vec3(0.0,-GOLDEN_RATIO,1.0)), Object(15))/*\n*/\t_Call(CENTRIC_PLANE(_WorldMat,GOLDEN_DIST,vec3(0.0,GOLDEN_RATIO,-1.0)), Object(16))/*\n*/\t_Call(CENTRIC_PLANE(_WorldMat,GOLDEN_DIST,vec3(0.0,-GOLDEN_RATIO,-1.0)), Object(17))/*\n*/\t_Call(CENTRIC_PLANE(_WorldMat,GOLDEN_DIST,vec3(1.0,0.0,GOLDEN_RATIO)), Object(18))/*\n*/\t_Call(CENTRIC_PLANE(_WorldMat,GOLDEN_DIST,vec3(1.0,0.0,-GOLDEN_RATIO)), Object(19))/*\n*/\t_Call(CENTRIC_PLANE(_WorldMat,GOLDEN_DIST,vec3(-1.0,0.0,GOLDEN_RATIO)), Object(20))/*\n*/\t_Call(CENTRIC_PLANE(_WorldMat,GOLDEN_DIST,vec3(-1.0,0.0,-GOLDEN_RATIO)), Object(21))\n    \n#undef COLOR_COUNT\n#define COLOR_COUNT 12\n    \n#endif\n    \n#define SPHERE_SIZE 2.0\n#define SPHERE_OBJECT_RATIO 1.0\n\n// structures (I love structures, sorry, C/C++ habits)\n\nstruct Ray\n{\n    vec3 m_pos;\t\t\t// start of the ray\n    vec3 m_dir;    \t\t// direction of the ray, intersect functions need \"normalized\" dir\n};\n\nstruct Camera\n{ \n    mat4\tm_matrix;\t// this matrix can be \"Left\" or \"Right\" handed...just used to compute viewRay\n};\n    \nstruct Object\n{\n    int\t\tm_id;\t\t// just an id, to find material after all raycasts\n};\n    \nstruct RaycastResult\n{\n    float\tm_d;\t\t// distance from origin of the ray that cause the result\n\tvec3\tm_pos;\t\t// position of intersection\n\tvec3\tm_normal;\t// normal of intersection\n    Object\tm_object;\t// object intersected\n};\n    \nstruct Lighting\n{\n    vec3\tm_ambient; \t// xyz = color\n    vec2\tm_shading;\n};\n    \nstruct Light\n{\n    vec3\tm_pos;\t\t// position of the light    \n    vec4\tm_spec;\t\t// xyz = color, w = intensity\n};\n    \nstruct World\n{\n    vec4 \tm_sphere; \t// xyz = pos, w = radius\n    vec4\tm_plane;  \t// xyz = normal, w = d = -dot(n,p) { mathematical form : ax+by+cz+d=0 }\n    mat4\tm_cube;   \t// matrix of the object\n    mat4\tm_inverseCube;\n};\n    \nstruct Material\n{\n    vec2\tm_spec;\t\t//x : shininess, y : ratio\n    vec3\tm_color;\n};\n    \n   \n\n// util funcs\n\nfloat maxPerElem ( in vec2 _v )\n{\n    return max(_v.x,_v.y);\n}\n\nfloat maxPerElem ( in vec3 _v )\n{\n    return max(_v.z,maxPerElem(_v.xy));\n}\n\nfloat maxPerElem ( in vec4 _v )\n{\n    return max(_v.w,maxPerElem(_v.xyz));\n}\n    \n\nvoid minRaycastResult ( inout RaycastResult _rayResultMin, in float _min, in float _max, in RaycastResult _curr )\n{\n    if ( _curr.m_d < _min )\n        return;\n    \n    if ( _curr.m_d > _max )\n        return;\n    \n    if ( _curr.m_d > _rayResultMin.m_d )\n        return;\n    \n\t_rayResultMin = _curr;\n}\n\nvoid minRaycastResult ( inout RaycastResult _rayResultMin, in RaycastResult _curr )\n{ \n    if ( _curr.m_d > _rayResultMin.m_d )\n        return;\n    \n    _rayResultMin = _curr;\n}\n\nvoid maxRaycastResult ( inout RaycastResult _rayResultMax, in float _min, in float _max, in RaycastResult _curr )\n{\n    if ( _curr.m_d < _min )\n        return;\n    \n    if ( _curr.m_d > _max )\n        return;\n    \n    if ( _curr.m_d < _rayResultMax.m_d )\n        return;\n    \n\t_rayResultMax = _curr;\n}\n\nvoid maxRaycastResult ( inout RaycastResult _rayResultMax, in RaycastResult _curr )\n{  \n    if ( _curr.m_d < _rayResultMax.m_d )\n        return;\n    \n    _rayResultMax = _curr;\n}\n    \nvec4 appendColor ( in vec4 _color, in vec4 _mul, in vec4 _add, float _ratio )\n{\n    return _color * mix(vec4(1.0),_mul,_ratio) + _ratio * _add;\n}\n\nvec3 appendColor ( in vec3 _color, in vec3 _mul, in vec3 _add, float _ratio )\n{\n    return _color * mix(vec3(1.0),_mul,_ratio) + _ratio * _add;\n}\n\n// from https://www.shadertoy.com/view/4sfGzS\nfloat hash( float n ) { return fract(sin(n)*753.5453123); }\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    float n = p.x + p.y*157.0 + 113.0*p.z;\n    return mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                   mix( hash(n+157.0), hash(n+158.0),f.x),f.y),\n               mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                   mix( hash(n+270.0), hash(n+271.0),f.x),f.y),f.z);\n}\n\nfloat supernoise(in vec3 x)\n{\n    const mat3 m = mat3( 0.00,  0.80,  0.60,\n                    -0.80,  0.36, -0.48,\n                    -0.60, -0.48,  0.64 );\n    float f = 0.0;\n    vec3 q = x;\n    f  = 0.5000*noise( q ); q = m*q*2.01;\n    f += 0.2500*noise( q ); q = m*q*2.02;\n    f += 0.1250*noise( q ); q = m*q*2.03;\n\tf += 0.0625*noise( q ); q = m*q*2.01;\n    \n    return f;\n}\n\nvec3 supernoise(in vec3 p, in float delta)\n{\n    float dx = supernoise(p+delta*vec3(1.0,0.0,0.0)) - supernoise(p-delta*vec3(1.0,0.0,0.0));\n    float dy = supernoise(p+delta*vec3(0.0,1.0,0.0)) - supernoise(p-delta*vec3(0.0,1.0,0.0));\n    float dz = supernoise(p+delta*vec3(0.0,0.0,0.0)) - supernoise(p-delta*vec3(0.0,0.0,1.0));\n    \n    return vec3(dx,dy,dz);\n}\n\nfloat gridXYZ ( in vec3 _pos, in float _size, in float _ceil )\n{\n    vec3 gridPos;\n    gridPos.x = mod(_pos.x/_size+0.5,1.0);\n    gridPos.y = mod(_pos.y/_size+0.5,1.0);\n    gridPos.z = mod(_pos.z/_size+0.5,1.0);\n\n    gridPos = 2.0*abs(gridPos-vec3(0.5));\n\n    float grid = maxPerElem(gridPos);\n \n    return smoothstep(0.0,1.0,pow(grid,15.0));\n}\n\nfloat distRayRay(in vec3 _p1, in vec3 _d1, in vec3 _p2, in vec3 _d2, out float _t1, out float _t2 )\n{\n    vec3 crossNorm = cross(_d1,_d2);\n    float dist = abs(dot(_p2-_p1,crossNorm))/length(crossNorm);\n    \n    _t1 = dot(cross(_p2-_p1,_d2),crossNorm) / dot(crossNorm,crossNorm);\n    _t2 = dot(cross(_p2-_p1,_d1),crossNorm) / dot(crossNorm,crossNorm);\n    \n    return dist;\n}\n\nfloat drawLine ( in Ray _r1, in Ray _r2, in float _dMax )\n{\n    float t1, t2;\n    float dist = distRayRay(_r1.m_pos, _r1.m_dir, _r2.m_pos, _r2.m_dir, t1, t2 );\n    \n    if ( dist > _dMax )\n        return 0.;\n    \n    return 1.0-smoothstep(0.0,1.0,dist/_dMax);\n}\n\nfloat drawSeg ( in Ray _seg1, in Ray _ray, in float _dMax )\n{\n    float t1, t2;\n    float dist = distRayRay(_seg1.m_pos, _seg1.m_dir, _ray.m_pos, _ray.m_dir, t1, t2 );\n    \n    if ( t1 < 0.0 )\n        return 0.0;\n        \n\tif ( t1 > 1.0 )\n        return 0.0;\n    \n    if ( dist > _dMax )\n        return 0.;\n    \n    return 1.0-smoothstep(0.0,1.0,dist/_dMax);\n}\n\nmat4 rotationX ( float _angle )\n{\n    mat4 mat;\n    mat[0] = vec4(1.0,0.0,0.0,0.0);\n    mat[1] = vec4(0.0,cos(_angle),sin(_angle),0.0);\n    mat[2] = vec4(0.0,-sin(_angle),cos(_angle),0.0);\n    mat[3] = vec4(0.0,0.0,0.0,1.0);    \n    return mat;\n}\nmat4 rotationY ( float _angle )\n{\n    mat4 mat;\n    mat[0] = vec4(cos(_angle),0.0,-sin(_angle),0.0);\n    mat[1] = vec4(0.0,1.0,0.0,0.0);\n    mat[2] = vec4(sin(_angle),0.0,cos(_angle),0.0);\n    mat[3] = vec4(0.0,0.0,0.0,1.0);\n    return mat;\n}\nmat4 rotationZ ( float _angle )\n{\n    mat4 mat;\n    mat[0] = vec4(cos(_angle),sin(_angle),0.0,0.0);\n    mat[1] = vec4(-sin(_angle),cos(_angle),0.0,0.0);\n    mat[2] = vec4(0.0,0.0,1.0,0.0);\n    mat[3] = vec4(0.0,0.0,0.0,1.0);\n    return mat;\n}\n\nmat4 scale (vec3 _scale)\n{\n    mat4 mat;\n    mat[0] = vec4(_scale.x,0.0,0.0,0.0);\n    mat[1] = vec4(0.0,_scale.y,0.0,0.0);\n    mat[2] = vec4(0.0,0.0,_scale.z,0.0);\n    mat[3] = vec4(0.0,0.0,0.0,1.0);\n    return mat;\n}\n\nmat4 translate (vec3 _translation)\n{\n    mat4 mat;\n    mat[0] = vec4(1.0,0.0,0.0,0.0);\n    mat[1] = vec4(0.0,1.0,0.0,0.0);\n    mat[2] = vec4(0.0,0.0,1.0,0.0);\n    mat[3] = vec4(_translation,1.0);\n    return mat;\n}\n\n// raycCast funcs\n    \nbool intersectRayPlane(in vec3 _start, in vec3 _dir, in vec4 _plane, in Object _object, out RaycastResult _rayResult )\n{\n    float dotDir = dot (_dir,_plane.xyz);\n    \n    _rayResult.m_d = - ( dot(_start,_plane.xyz) + _plane.w ) / ( dotDir );\n\t_rayResult.m_pos = _start + _dir * _rayResult.m_d;\n\t_rayResult.m_normal = _plane.xyz;\n\t_rayResult.m_object = _object;\n    \n    if ( abs(dotDir)<0.000001 )\n        return false;\n    \n    return true;\n}\n\nvoid intersectRayPlaneRange (in vec3 _start, in vec3 _dir, in vec4 _plane, in Object _object, inout RaycastResult _rayResFront, inout RaycastResult _rayResRear )\n{\n    RaycastResult curr;\n    if ( intersectRayPlane ( _start, _dir, _plane, _object, curr ) )\n    {\n        if ( dot(_dir,_plane.xyz) > 0.0 )\n        {\n            minRaycastResult ( _rayResRear, curr );\n        }\n        else\n        {\n            maxRaycastResult ( _rayResFront, curr );\n        }\n    }\n}\n\nvoid intersectRayPlaneRear (in vec3 _start, in vec3 _dir, in vec4 _plane, in float _min, in float _max, in Object _object, inout RaycastResult _rayResRear )\n{\n    RaycastResult curr;\n    if ( intersectRayPlane ( _start, _dir, _plane, _object, curr ) )\n    {\n        //if ( dot(_dir,_plane.xyz) < 0.0 )\n        {\n            minRaycastResult ( _rayResRear, _min, _max, curr );\n        }\n    }\n}\n\nbool intersectRaySphere(in vec3 _start, in vec3 _dir, in vec4 _sphere, in Object _object, inout RaycastResult _rayResult1, inout RaycastResult _rayResult2 )\n{\n    vec3 centerToStart = _start - _sphere.xyz;\n    float projCenterToStart = dot ( _dir, centerToStart );\n    \n    float b2m4ac = projCenterToStart*projCenterToStart - dot(centerToStart,centerToStart) + _sphere.w*_sphere.w;\n\n    if ( b2m4ac < 0.0 )\n    {\n        return false;\n    }\n    else\n    {\n        _rayResult1.m_d = -projCenterToStart - sqrt(b2m4ac);\n\t\t_rayResult1.m_pos = _start + _rayResult1.m_d * _dir;\t\t\n\t\t_rayResult1.m_normal = normalize(_rayResult1.m_pos-_sphere.xyz);\n\t\t_rayResult1.m_object = _object;\n    \t_rayResult2.m_d = -projCenterToStart + sqrt(b2m4ac);\n\t\t_rayResult2.m_pos = _start + _rayResult2.m_d * _dir;\n\t\t_rayResult2.m_normal = normalize(_rayResult2.m_pos-_sphere.xyz);\n\t\t_rayResult2.m_object = _object;\n        return true;\n    }\n}\n\nvoid initRaycastResult ( inout RaycastResult _rayResult )\n{\n    _rayResult.m_d = MAX;\n    _rayResult.m_object.m_id = 0;    \n}\n\nvoid rayCastSphere ( in World _world, inout RaycastResult _rayResult, in Ray _ray, in float _min, in float _max )\n{\n    RaycastResult rayR1, rayR2;\n    \n\tif ( intersectRaySphere(_ray.m_pos, _ray.m_dir, _world.m_sphere, Object(1), rayR1, rayR2 ) )\n    {\n        minRaycastResult ( _rayResult, _min, _max, rayR1 );\n        minRaycastResult ( _rayResult, _min, _max, rayR2 );\n    }   \n}\n\nvoid rayCastPlane( in World _world, inout RaycastResult _rayResult, in Ray _ray, in float _min, in float _max )\n{\n    RaycastResult rayResult;\n    if ( intersectRayPlane ( _ray.m_pos, _ray.m_dir, _world.m_plane, Object(2), rayResult ) )\n    {\n        minRaycastResult ( _rayResult, _min, _max, rayResult );\n    }    \n}\n\nvec4 pointAndNormToPlane ( in vec3 _p, in vec3 _n )\n{\n    return vec4 ( _n, -dot(_p,_n) );\n}\n\n\n\nvoid rayCastCube ( in World _world, inout RaycastResult _rayResult, in Ray _ray, in float _min, in float _max )\n{  \n    RaycastResult rayResFront, rayResRear;\n    \n    rayResFront.m_d = _min;\n    rayResRear.m_d = _max;\n    \n\t#define INTERSECT_PLANE_RANGE(_Plane,_PlaneId) intersectRayPlaneRange ( _ray.m_pos, _ray.m_dir, _Plane, _PlaneId, rayResFront, rayResRear );\n\tFOREACH_PLANES(_world.m_cube,INTERSECT_PLANE_RANGE)\n        \n    // if front result is far (more than rear) we're outside of the convex\n    if ( rayResFront.m_d > rayResRear.m_d )\n    {\n        return;\n    }\n    \n    minRaycastResult ( _rayResult, _min, _max, rayResFront );\n}\n\nvoid rayCastCubeRear ( in World _world, inout RaycastResult _rayResult, in Ray _ray, in float _min, in float _max )\n{  \n    RaycastResult rayResRear;\n    \n    rayResRear.m_d = _max;\n    \n    // a cube is convex, so we can intersect all planes, this will give us a range of frontal max and rear min\n\t\n\t#define INTERSECT_PLANE_REAR(_Plane,_PlaneId) intersectRayPlaneRear ( _ray.m_pos, _ray.m_dir, _Plane,  _min, _max, _PlaneId, rayResRear );\n\tFOREACH_PLANES(_world.m_cube,INTERSECT_PLANE_REAR)\n    \n    minRaycastResult ( _rayResult, _min, _max, rayResRear );\n}\n\nvoid rayCastWorld ( in World _world, inout RaycastResult _rayResult, in Ray _ray, in float _min, in float _max )\n{\n    //rayCastSphere ( _world, _rayResult, _ray, _min, _max );\n    rayCastPlane ( _world, _rayResult, _ray, _min, _max );\n    rayCastCube ( _world, _rayResult, _ray, _min, _max );\n}\n\n// Stereographic projection\n\nvoid stereographicProj ( in World _world, in vec3 _pos, out RaycastResult _rayResult, out Ray _ray )\n{\n    // this function is basic, with 2 raycasts (from point to sphere, and sphere to cube)\n    // there are a lot of way to optimize it\n    \n    vec3 topSphere = _world.m_sphere.xyz + _world.m_sphere.w * _world.m_plane.xyz;\n    \n    // PTTS : PointToTopSphere\n    Ray rayPTTS; \n    rayPTTS.m_pos = _pos;\n    rayPTTS.m_dir = normalize(topSphere-_pos);\n    \n    RaycastResult rayResultPTTS;\n    initRaycastResult ( rayResultPTTS );\n    \n    rayCastSphere ( _world, rayResultPTTS, rayPTTS, 0.0, MAX);\n    \n    // STC : SphereToCube\n    Ray raySTC; \n    _ray.m_pos = rayResultPTTS.m_pos;\n    _ray.m_dir = normalize ( _world.m_cube[3].xyz - rayResultPTTS.m_pos );\n    \n    initRaycastResult ( _rayResult );\n    \n    rayCastCube ( _world, _rayResult, _ray, -MAX, MAX );\n}\n\n\n\n// standard [image -> screen -> view -> world] funcs\n\nvec2 imageToScreen ( in vec2 _uv )\n{\n    vec2 ratioUV = _uv.xy / iResolution.xy;\n    vec2 ratio = 2.0*iResolution.xy/vec2(min(iResolution.x,iResolution.y));\n    vec2 xy = (ratioUV*2.0-1.0)*ratio;\n    return xy;\n}\n\nvoid screenToWorld ( in Camera _camera, in vec2 _screenPos, float _z, out vec3 _pos )\n{\n    _pos = (_camera.m_matrix * vec4(_screenPos,_z,1.0)).xyz;    \n}\n\nvoid screenToRay ( in Camera _camera, in vec2 _screenPos, out Ray _ray )\n{\n    vec3 rayPoint;\n    \n    //fov is hardcoded here (distance of Z plane)\n    screenToWorld ( _camera, _screenPos, 1.0 / tan ( DEG_TO_RAD * FOV / 2.0), rayPoint );        \n    \n    _ray.m_pos = _camera.m_matrix[3].xyz;\n    _ray.m_dir = normalize(rayPoint-_ray.m_pos);\n}\n\nvoid cameraLookAt ( in vec3 _eye, in vec3 _lookAtPos, in vec3 _up, out Camera _camera )\n{\n    vec3 front = normalize(_lookAtPos-_eye);    \n    vec3 left = normalize(cross(front, _up));\n    vec3 up = normalize(cross(left,front));\n    _camera.m_matrix[0] = vec4(left,0.0);\n    _camera.m_matrix[1] = vec4(up,0.0);\n    _camera.m_matrix[2] = vec4(front,0.0);\n    _camera.m_matrix[3] = vec4(_eye,1.0);\n}\n\n// color funcs\n\nvoid computeMaterial ( in World _world, inout RaycastResult _rayResult, out Material _material )\n{\n    if ( _rayResult.m_object.m_id == 1 )\n    {\n        _material.m_color = vec3(1.0);\n        _material.m_spec = vec2(1.0,0.0);\n    }\n    else if ( _rayResult.m_object.m_id == 2 )\n    {\n        _material.m_color = vec3(0.5);\n        _material.m_spec = vec2(1.0,0.0);\n    }\n    else if ( _rayResult.m_object.m_id >= 10  )\n    {\n        float ratio = mod(float(_rayResult.m_object.m_id-9)+5.0,float(COLOR_COUNT)) / float(COLOR_COUNT);\n        vec3 a = vec3(0.28,0.5,0.5)*1.3;\n        vec3 b = vec3(0.5,0.2,0.5);\n        vec3 c = vec3(1.0,1.0,0.0);        \n        vec3 d = vec3(0.5,0.3, 0.25);\n        \n        //https://iquilezles.org/articles/palettes\n        _material.m_color = a+b*cos(2.0*3.141592*(c*ratio+d));\n        _material.m_spec = vec2(10.0,1.0);\n\n\t\tvec4 localPos = _world.m_inverseCube * vec4(_rayResult.m_pos,1.0);\n\t\t\n        float grid = supernoise(localPos.xyz*20.0);\n        \n        //_rayResult.m_normal = normalize ( _rayResult.m_normal-0.5*supernoise(localPos.xyz*20.0, 0.1));\n        \n        //_material.m_color = appendColor(_material.m_color,vec3(0.90),vec3(-0.),grid); \n\n    }\n    else   \n    {\n        _material.m_color = vec3(0.0);\n        _material.m_spec = vec2(1.0,0.0);\n    }\n    \n    \n}\n\n\nvoid stereographicProjDebug ( in World _world, in Camera _cam, in vec2 _uv, out vec3 _p1, out vec3 _p2, out vec3 _p3 )\n{\n    Ray rayMouse;\n    RaycastResult rayResultMouse;\n    \n    vec2 mouseXY = imageToScreen ( _uv );\n    \n    initRaycastResult ( rayResultMouse );\n    screenToRay (_cam, mouseXY, rayMouse );\n    \n    Ray stDebugRay;\n    RaycastResult stDebugInter, stDebugViaInter;\n    \n    rayCastPlane ( _world, rayResultMouse, rayMouse, 0.0, MAX );\n    \n    // this function is basic, with 2 raycasts (from point to sphere, and sphere to cube)\n    // there are a lot of way to optimize it\n    \n    vec3 topSphere = _world.m_sphere.xyz + _world.m_sphere.w * _world.m_plane.xyz;\n    \n    // PTTS : PointToTopSphere\n    Ray rayPTTS; \n    rayPTTS.m_pos = rayResultMouse.m_pos;\n    rayPTTS.m_dir = normalize(topSphere-rayResultMouse.m_pos);\n    \n    RaycastResult rayResultPTTS;\n    initRaycastResult ( rayResultPTTS );\n    \n    rayCastSphere ( _world, rayResultPTTS, rayPTTS, 0.0, MAX);\n    \n    // STC : SphereToCube\n    Ray raySTC; \n    raySTC.m_pos = rayResultPTTS.m_pos;\n    raySTC.m_dir = normalize ( _world.m_cube[3].xyz - rayResultPTTS.m_pos );\n    \n    RaycastResult resultSTC;\n    initRaycastResult ( resultSTC );\n    \n    rayCastCube ( _world, resultSTC, raySTC, 0.0, MAX );\n    \n    _p1 = rayResultMouse.m_pos;\n    _p2 = rayResultPTTS.m_pos;\n    _p3 = resultSTC.m_pos;\n}\n\n// lighting is black magic for me, just sum up some sort of diffuse + spec things\n\nvec3 computeLighting ( in World _world, in Lighting _lighting, in Light _light, in Material _material, in Ray _viewRay, in RaycastResult _rayResult )\n{\n    vec3 light = normalize( _light.m_pos - _rayResult.m_pos );\n    float dotLight = dot(light,_rayResult.m_normal);\n    float lightIntensity = max(dotLight,0.) * _lighting.m_shading.y + _lighting.m_shading.x;\n    \n    float visibility = 1.0;\n    \n    // shadow (only if light)\n    #if WITH_SHADOW\n    if ( dotLight > 0.01 )\n    {\n        Ray shadowRay;\n        shadowRay.m_pos = _light.m_pos;\n        shadowRay.m_dir = normalize(_rayResult.m_pos - _light.m_pos);\n\n        RaycastResult shadowInter;\n        initRaycastResult ( shadowInter );\n        rayCastWorld ( _world, shadowInter, shadowRay, 0.0, MAX);\n\n        if ( shadowInter.m_object != _rayResult.m_object )\n        {        \n            visibility = _lighting.m_shading.x;\n        } \n    }\n    #endif\n    \n    vec3 color = _material.m_color.xyz * lightIntensity;\n\n    // specular\n    vec3 r = normalize(2.0 * dot(light, _rayResult.m_normal) * _rayResult.m_normal - light);\n    vec3 v = normalize(_viewRay.m_dir);\n\n    float dotSpec = max(dot(r, -v),0.0);\n    float powSpec = clamp(pow(dotSpec,_material.m_spec.x),0.0,1.0);\n    float specular = ( _light.m_spec.w * powSpec * length(color) ) * _material.m_spec.y;\n       \n    \n    return ( color + specular * _light.m_spec.xyz ) * visibility;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t// setup world, cam & light\n    \n    Camera cam;\n    World world;    \n     \n    world.m_sphere = vec4(0.0,SPHERE_SIZE,0.0,SPHERE_SIZE);\n    world.m_plane = vec4(0.0,1.0,0.0,0.0);\n    \n    mat4 rot = rotationZ ( iTime*1.278914) * rotationY(iTime) * rotationX(iTime*0.332567);\n    mat4 inverseRot = rotationX(-iTime*0.332567) * rotationY(-iTime) * rotationZ ( -iTime*1.278914) ;\n    \n    float scaleFactor = SPHERE_OBJECT_RATIO * world.m_sphere.w/sqrt(3.0);\n    world.m_cube = translate (world.m_sphere.xyz) * scale ( vec3(scaleFactor) ) * rot;    \n    world.m_inverseCube = inverseRot * scale ( 1.0/vec3(scaleFactor) ) * translate (-world.m_sphere.xyz);    \n    \n\n    \n    vec2 eye = vec2(0.0);\n    \n#ifndef DEBUG\n    eye = iMouse.xy/iResolution.xy;\n#endif\n    \n    cameraLookAt ( vec3(10.0-20.0*(eye.x),10.0+20.0*(eye.y),10.0), vec3(0.0,1.0,0.0), vec3(0.0,1.0,0.0), cam );\n    \n    // compute raytrace\n    vec2 xy = imageToScreen ( fragCoord );    \n        \n    Ray viewRay;\n    \n    screenToRay ( cam, xy, viewRay );\n    \n    RaycastResult rayResult;\n    initRaycastResult ( rayResult );\n    \n    rayCastWorld ( world, rayResult, viewRay, 0.0, MAX );\n     \n    Material material;   \n    computeMaterial ( world, rayResult, material );   \n    \n    // if plane => stereographicProj to obtain color\n    if ( rayResult.m_object.m_id == 2 )\n    {\n        Ray stRay;\n        RaycastResult stInter;\n        stereographicProj ( world, rayResult.m_pos, stInter, stRay );\n        \n        Material material2 ;\n        computeMaterial ( world, stInter, material2 );\n        \n        material.m_color = material2.m_color;\n        \n        #if WITH_STEREO_NORMAL\n        rayResult.m_normal = -stInter.m_normal;\n        #endif\n    }\n    \n    // render with 2 lights, we can add more lights, but it would be great to add a distance attenuation    \n    \n    // I'm so bad in specular settings and lighting in general, sorry\n    Lighting lighting = Lighting ( vec3(0.15), vec2(0.2,0.3) );\n       \n    Light light1 = Light ( vec3(5.0,10.0,5.00), vec4(vec3(1.0),1.0 ) );\n    Light light2 = Light ( vec3(-10.0,20.0,0.0), vec4(vec3(1.0),1.0 ) );\n    \n    vec3 color = lighting.m_ambient;\n    \n    color += computeLighting (world, lighting, light1, material, viewRay, rayResult );\n    color += computeLighting (world, lighting, light2, material, viewRay, rayResult );\n    \n    fragColor = vec4(clamp(color,0.0,1.0),1.0);\n    \n#ifdef DEBUG\n    \n    vec3 p1, p2, p3;\n    stereographicProjDebug ( world, cam, iMouse.xy, p1, p2, p3 );\n\n    vec3 pa, pb, pc;\n    stereographicProjDebug ( world, cam, iMouse.zw, pa, pb, pc );\n    \n    Ray seg1 = Ray (p1,p2-p1); Ray seg2 = Ray (p2,p3-p2);\n    Ray sega = Ray (pa,pb-pa); Ray segb = Ray (pb,pc-pb);\n    \n    \n    RaycastResult inCubeResult;\n    Ray inCubeRay = Ray ( pc, normalize(p3-pc) );\n    \n    rayCastCubeRear ( world, inCubeResult, inCubeRay, 0.0, MAX );\n    \n    //Ray segInCube = Ray ( pc, inCubeResult.m_pos - pc );\n    \n    inCubeResult.m_d = MAX;    \n       \n    RaycastResult debugR;\n    debugR.m_d = MAX;\n\t\n\t#define INTERSECT_PLANE_REAR_MAX(_Plane,_PlaneId) intersectRayPlaneRear ( inCubeRay.m_pos, inCubeRay.m_dir, _Plane,  0.0, MAX, _PlaneId, debugR );\n\tFOREACH_PLANES(world.m_cube,INTERSECT_PLANE_REAR_MAX)    \n    \n    minRaycastResult ( inCubeResult, 0.0, MAX, debugR );\n    \n\tRay segInCube = Ray ( pc, debugR.m_pos - pc );\n    \n    vec3 onSphere = world.m_sphere.xyz + (normalize(debugR.m_pos-world.m_sphere.xyz))*world.m_sphere.w;\n    float twoRadius = 2.0*world.m_sphere.w;\n    vec3 onPlane = onSphere  * ( twoRadius / (twoRadius - onSphere.y));\n\tonPlane.y = 0.0;\n\n    float lineRatio = 0.0;\n\n\tMaterial materialD ;\n\tcomputeMaterial ( world, inCubeResult, materialD );\n    \n    lineRatio = max ( lineRatio, max( drawSeg ( seg1, viewRay, 0.02 ), drawSeg ( seg2, viewRay, 0.02 ) ) );\n    lineRatio = max ( lineRatio, max( drawSeg ( sega, viewRay, 0.02 ), drawSeg ( segb, viewRay, 0.02 ) ) );\n\n    lineRatio = max ( lineRatio, drawSeg(segInCube, viewRay, 0.02) );\n    lineRatio = max ( lineRatio, drawSeg(Ray(sega.m_pos,(onPlane - sega.m_pos)), viewRay, 0.02) );\n    \n    vec3 lineColor = materialD.m_color;\n    \n    fragColor.xyz = appendColor(fragColor.xyz, lineColor, lineColor, lineRatio );\n#endif\n    \n}\n","name":"Image","description":"","type":"image"}]}