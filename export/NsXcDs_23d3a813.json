{"ver":"0.1","info":{"id":"NsXcDs","date":"1642880961","viewed":204,"name":"Tangled Sierpinski","username":"pb","description":"Sierpinski Gasket tangled in mandelbox parts","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["fractal","mandelbox","sierpinski"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define AA 2  //set to 1 if too slow, increase if you got a phat GPU!\n\n//the story is I have my own webgl browser thingy where I can interactively\n//set all these parameters via javascript, but I am exporting them here\n//so I can show you the interesting ones\nfloat params[38] = float[38]\n(0.,-0.131,0.,0.,1.1,0.,0.11,1.9,1.5, 3.,\n 15.,0.035,-0.6,0.,-2.,0.,0.,4.,5., 4.,\n -0.20,0.6,0.,0.,0.,0.,0.,-2.,0.,0.,\n 0.,0.,0.,2.,-0.01,0.01,0.,0.6);\n\nconst float tmax = 20.0;\nvec3 color;\nvec3 ray_origin;  \nfloat inside_of_sphere( vec3 p, float r ) {\n    return -( length(p) - r ); //negating the usual SDF gets us on the inside\n}\n\nfloat map(vec3 p) {\n\n    // the guts of this came from Space Monolith shadertoy by zackpudil\n    // but I parameterized it to death and changed the coloring and lighting\n    // and found this sierpinski gasket hanging in the columns\n    vec3 orig_p = p;\n\n    p.xy = mod(p.xy + 1.0, 3.0) - 1.0;\n\n    p.z = abs(p.z) - 0.75 - params[24];\n\n    vec4 q = vec4(p, 1.0);\n    \n    float mscale = 2.*(1.+params[1]);\n    float clamp_min = .5 - params[0];\n    float clamp_max = 1. + params[0];\n\n    color = vec3(0.);\n    float color_radius = params[25];\n    float num_iter = 0.;\n    for(int i = 0; i < 100; i++) {\n\n        if ( float(i) > ( params[10] ) ) break;\n\n        float ilength = length(q.xyz);  //using the lagging q.xyz yield nice results\n\n        q.xyz = abs(q.xyz) - vec3(0.3, 1.0, -0.0) + vec3(params[21], params[22], params[23]);\n\n        if (params[29] == 0. ) \n            ilength = length(q.xyz - vec3( params[30], params[31], params[32]) );   \n\n\n        q = mscale*q/clamp( pow(ilength,2.+params[28]), clamp_min, clamp_max) \n            - vec4(1.0+params[34], 0.0+params[35], 0.3+params[36], 0.0);\n\n      \n        // I have found that nice colors can be generated for iterated\n        // systems that send points flying in 3d by keeping count of how \n        // many times an orbit passes through a big block of subspace\n        // then using cosine to transform it - see down below\n        if      ( q.x*q.y > color_radius ) { color.x ++ ; }\n        else if ( q.y*q.z > color_radius ) { color.y ++ ; }\n        else if ( q.z*q.x > color_radius ) { color.z ++ ; }\n        \n\n        num_iter ++;\n    }\n\n    color /= (1. + params[37] * num_iter);\n    \n    return max( abs(q.x + q.y + q.z)/q.w, inside_of_sphere(orig_p - ray_origin, params[13]) );\n\n    //return ( length(q.xyz)/q.w );\n}\n\nfloat march(vec3 ro, vec3 rd) {\n\n    float d = 1.0;\n    float e, t = 0.0;\n\n    ray_origin = ro;  //needed for inside of sphere\n\n    float detail = .001 * (1.+params[20]); //of course detail increases as this variable decreases\n    for(int i = 0; i < 200; i++) {\n        if(abs(d) < e || t >= tmax) break;\n        d = map(ro + rd*t);\n        e = detail * (1.0 + t*4.0);  //tolerance for hitting an object increases with distance to reduce background noise\n        t += d*(0.55 + 0.05*t);\n    }\n    \n    return t;\n}\n\nvec3 normal(vec3 p) {\n    vec2 h = vec2(0.01 * (1.+params[12]), 0.0);\n    vec3 n = vec3(\n        map(p + h.xyy) - map(p - h.xyy),\n        map(p + h.yxy) - map(p - h.yxy),\n        map(p + h.yyx) - map(p - h.yyx)\n    );\n    return normalize(n);\n}\n\n\nfloat hash2(vec2 n) {\n    return fract(sin(dot(n, vec2(27.233, 71.989)))*43758.5453);\n}\n\nfloat calcAO( vec3 pos, vec3 nor ) {\n    float detail = .001;\n\tfloat aodet=detail*8.;  //40.\n\tfloat totao = 0.0;\n  \tfloat sca = 25.0;\n  \tfor( int aoi=0; aoi<40; aoi++ ) {\n        if ( float(aoi) > params[33]) break;\n\t\tfloat hr = aodet*float(aoi*aoi);        \n\t\tvec3 aopos =  nor * hr + pos;\n\t\tfloat dd = map( aopos );\n\t\ttotao += -(dd-hr)*sca;\n\t\tsca *= 0.7;\n    \t}\n    \treturn clamp( 1.0 - 2.*totao, 0.2, 1.0 );\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n\n    vec3 tot = vec3(0.0);\n    \n    //anti aliasing taken from Soft Shadow Variation shadertoy by IQ\n#if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n            // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 uv = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y; \n    \n#else    \n        vec2 uv = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n#endif\n\n\n    vec3 col = vec3(0.); //vec3(1)*step(0.997, hash2(uv));\n    \n    vec3 ro = vec3( 0., 0., max(min(2. + 3.*sin(iTime/3.), 4.),-.5) ); \n \n    float  focal_point = params[14];\n    vec3 rd =  normalize(vec3(uv,focal_point));\n\n    vec3 camera_direction = vec3( 0., 0., 1. );  \n    \n    vec3 ltDir = normalize ( camera_direction + vec3(0.,params[4]+2.*cos(iTime/2.),0.) );  \n\n    float i = march(ro, rd);\n\n    if(i < tmax) {\n\n        vec3 pos = ro + rd*i;\n        vec3 nor = normal(pos);\n\n        col = vec3(0.0);\n\n        float bounce = clamp( 1. + dot( rd, nor ), 0., 1. );\n\n        col += (1.+params[8])*0.1*pow(bounce, 2.0);\n\n        //specular\n        col += (1.0+params[9]) * pow (max (0., dot (ltDir, reflect (rd, nor))), 32.*params[6]);\n\n        float cx = cos(color.x*params[17]);\n        float cy = cos(color.y*params[18]);\n        float cz = cos(color.z*params[19]);\n\n        if ( params[7] != 0. )\n            col += .1 * params[7] * vec3( cx, cy, cz ); \n\n        //fade with distance\n        col *= smoothstep(-8.0, -6.0*(1.+params[27]), -i);\n\n        col *= calcAO( pos, nor );\n\n        col = clamp( col, 0., 1.); \n    }\n\n    col = pow(col, vec3(.4154545 * (1.+params[26])  ) );\n    tot += col;\n    \n#if AA>1\n    }\n    tot /= float(AA*AA); //average color for anti aliasing\n#endif\n    \n    fragColor = vec4(tot, 1.);\n       \n   \n}","name":"Image","description":"","type":"image"}]}