{"ver":"0.1","info":{"id":"stcfWH","date":"1663030136","viewed":66,"name":"Crazy Lamp","username":"jacksonadams","description":"lamp","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["3d"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sfGRn","filepath":"/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","previewfilepath":"/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/**\n    * Shader Assignment 1\n    * Jackson Adams\n    * Computer Graphics\n    *\n    * While the composition is completely my own, many of the elements of this \n      program were based off of the examples in class or taken from iquilezles.org.\n        \n*/\n\n// Rotation function\nmat3 rotateY(float rad) {\n\tfloat c = cos(rad);\n\tfloat s = sin(rad);\n\treturn mat3(\n\t\tc,   0.0, -s,\n\t\t0.0, 1.0, 0.0,\n\t\ts,   0.0, c\n\t);\n}\n\n// Smooth union betweeen shapes\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n    \n// Sphere function\nfloat sdSphere( vec3 p, float s){\n    return length(p) - s;\n}\n\n// Box frame function\nfloat sdBoxFrame( vec3 p, vec3 b, float e )\n{\n      p = abs(p  )-b;\n      vec3 q = abs(p+e)-e;\n      return min(min(\n          length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n          length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n          length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n}\n\n// Vertical capsule function\nfloat sdVerticalCapsule( vec3 p, float h, float r )\n{\n  p.y -= clamp( p.y, 0.0, h );\n  return length( p ) - r;\n}\n\nfloat sdCappedCone(vec3 p, vec3 a, vec3 b, float ra, float rb)\n{\n  float rba  = rb-ra;\n  float baba = dot(b-a,b-a);\n  float papa = dot(p-a,p-a);\n  float paba = dot(p-a,b-a)/baba;\n  float x = sqrt( papa - paba*paba*baba );\n  float cax = max(0.0,x-((paba<0.5)?ra:rb));\n  float cay = abs(paba-0.5)-0.5;\n  float k = rba*rba + baba;\n  float f = clamp( (rba*(x-ra)+paba*baba)/k, 0.0, 1.0 );\n  float cbx = x-ra - f*rba;\n  float cby = paba - f;\n  float s = (cbx<0.0 && cay<0.0) ? -1.0 : 1.0;\n  return s*sqrt( min(cax*cax + cay*cay*baba,\n                     cbx*cbx + cby*cby*baba) );\n}\n\n// Test if a ray hits or misses the shape\nbool testScenePos(vec3 eye, vec3 dir, out vec3 outPos){\n    float t = 0.0;\n    for(int i = 0; i < 60; i ++ ){\n        // Calculate positions from rays\n        vec3 pos = eye + dir * t;\n        \n        // Get distance from positions to shape\n        // This is where the shape is created\n        float dist = opSmoothUnion(\n            sdBoxFrame(rotateY(iTime) * pos, vec3(2.5, 3.7, 2.5), 0.2),\n            opSmoothUnion(\n                sdSphere(rotateY(iTime) * pos + vec3(0, 0, 0), 4.0f),\n                opSmoothUnion(\n                    sdVerticalCapsule(rotateY(iTime) * pos, 10.0f, 0.4f),\n                    sdCappedCone(rotateY(iTime) * pos, vec3(0.0, 6.0, 0.0), vec3(0.0, 13.0, 0.0), 5.0f, 2.0f),\n                    0.9\n                ),\n                0.9\n            ),\n          1.2);\n          \n        // Check if the ray hit the shape\n        if(dist < 0.001){\n            outPos = pos;\n            return true;\n        }\n        t += dist;\n    }\n    return false;\n}\n\n// Noise functions hash and noised were taken from: https://iquilezles.org/articles/gradientnoise/\nvec2 hash( in vec2 x )  \n\n{\n    const vec2 k = vec2( 0.3183099, 0.3678794 );\n    x = x*k + k.yx;\n    return -1.0 + 2.0*fract( 16.0 * k*fract( x.x*x.y*(x.x+x.y)) );\n}\n\n\n// return gradient noise (in x) and its derivatives (in yz)\nvec3 noised( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\n#if 1\n    // quintic interpolation\n    vec2 u = f*f*f*(f*(f*6.0-15.0)+10.0);\n    vec2 du = 30.0*f*f*(f*(f-2.0)+1.0);\n#else\n    // cubic interpolation\n    vec2 u = f*f*(3.0-2.0*f);\n    vec2 du = 6.0*f*(1.0-f);\n#endif    \n    \n    vec2 ga = hash( i + vec2(0.0,0.0) );\n    vec2 gb = hash( i + vec2(1.0,0.0) );\n    vec2 gc = hash( i + vec2(0.0,1.0) );\n    vec2 gd = hash( i + vec2(1.0,1.0) );\n    \n    float va = dot( ga, f - vec2(0.0,0.0) );\n    float vb = dot( gb, f - vec2(1.0,0.0) );\n    float vc = dot( gc, f - vec2(0.0,1.0) );\n    float vd = dot( gd, f - vec2(1.0,1.0) );\n\n    return vec3( va + u.x*(vb-va) + u.y*(vc-va) + u.x*u.y*(va-vb-vc+vd),   // value\n                 ga + u.x*(gb-ga) + u.y*(gc-ga) + u.x*u.y*(ga-gb-gc+gd) +  // derivatives\n                 du * (u.yx*(va-vb-vc+vd) + vec2(vb,vc) - va));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    //vec2 uv = fragCoord/iResolution.xy - vec2(0.5);\n    vec2 uv = ((fragCoord - iResolution.xy/2.0)/(iResolution.xx/2.0));\n\n    // Set background   \n    vec3 col = vec3(1.0, 1.0, 1.0);\n    for(float i = -0.6; i < 1.0; i += 0.05){\n        col *= smoothstep( 0.003, 0.055 + sin(i + iTime * 3.0) * 0.05, abs(uv.x - (i * iResolution.x / iResolution.y)));\n        col *= smoothstep( 0.003, 0.055 + cos(i + iTime * 3.0) * 0.05, abs(uv.y - (i * iResolution.x / iResolution.y)));\n    }\n    \n    \n    // Position & direction vectors\n    vec3 pos, posdy, posdx;\n    vec3 dir = normalize(vec3(uv.x, uv.y, 5));\n    vec3 dirdx = normalize(vec3(uv.x+0.001, uv.y, 5));\n    vec3 dirdy = normalize(vec3(uv.x, uv.y+0.001, 5));\n    vec3 eye = vec3(0, 3.0, -100);\n   \n    // Normal vector\n    vec3 normal = vec3(0, 0, 1);\n    \n    // Colors inside the object\n    if(testScenePos(eye, dir, pos) && testScenePos(eye, dirdx, posdx) && testScenePos(eye, dirdy, posdy)){\n        // Find vector direction slightly downward\n        vec3 CA = normalize(pos - posdy);\n        vec3 BA = normalize(pos - posdx);\n        normal = cross(CA, BA);\n        normal.z = -normal.z;\n        \n        // Color/texture of the object\n        col = normal + sin(iTime)*0.3 + texture(iChannel0, uv +normal.xy+iTime).rgb;\n    }\n    \n    // Moving oise on top of the image\n    vec2 noisePos = (3.0 * fragCoord - iResolution.xy) / iResolution.y;\n    vec3 noiseFinal = noised(40.0 * noisePos * (5.0 - (iTime / 5.0)));\n    \n    \n    // Output to screen\n    fragColor = vec4(col + (0.1 + 0.4 * noiseFinal.xyz), 2.0);\n}","name":"Image","description":"","type":"image"}]}