{"ver":"0.1","info":{"id":"stlfD8","date":"1651003479","viewed":86,"name":"Umptillionth edition of GoL","username":"rucksack","description":"Buffer A starts with a picture and feeds its output back into itself.\nSwap out iChannel1 in buffer A to get a different result.","likes":2,"published":1,"flags":32,"usePreview":0,"tags":["conway","gameoflife"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Change this to < 1 and drag around with the mouse to explore the patterns up close\nconst float scale = 1.0;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 mouse = iMouse.xy/iResolution.xy;\n\n    // Sample GoL\n    vec4 cell = texture(iChannel0, mix(mouse, uv, scale));\n    vec3 col = cell.r * cell.g * vec3(1);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":1,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define T(dx, dy) float(ij.x >= 0. || ij.y >= 0.) * texture(iChannel0, (ij+vec2(dx, dy)/iResolution.xy)).r\n#define LIVE      fragColor = vec4(1, max(age_min, texture(iChannel0, ij).g-age_speed), 0, 0);\n#define DIE       fragColor = vec4(0);\n#define RESURRECT fragColor = vec4(1, 1, 0, 0);\n#define PERSIST   fragColor = texture(iChannel0, ij);\n\nconst float threshold = 0.7;\nconst float age_speed = 0.1;\nconst float age_min   = 0.4;\n\n// Change texture in iChannel1 for different starting point\n\n// This buffer outputs vec4(alive, age, 0, 0)\n\nfloat compmax(vec3 v) {\n    return max(v.x, max(v.y, v.z));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 ij = fragCoord/iResolution.xy;\n    if (iFrame < 10) {\n        // Initialize to contents of a texture\n        fragColor = vec4(float(compmax(texture(iChannel1, ij).rgb) > threshold));\n    } else if (iFrame % 2 == 0) {\n        // Neighbourhood if necessary\n        //mat3 area = mat3(\n        //    T(-1, -1), T(0, -1), T(1, -1),\n        //    T(-1,  0), T(0, 0), T(1,  0),\n        //    T(-1,  1), T(0,  1), T(1,  1)\n        //);\n        // Find number of neighbours and state of yourself\n        float sum = T(-1, -1) + T(-1, 0) + T(-1, 1) + T(0, -1) + T(0, 1) + T(1, -1) + T(1, 0) + T(1, 1);\n        float self = T(0, 0);\n        // Apply rules\n        if (self > 0. && sum < 2.) {\n            DIE // Underpopulation\n        } else if (self > 0. && sum > 1. && sum < 4.) {\n            LIVE // Lives on\n        } else if (self > 0. && sum > 3.) {\n            DIE // Overpopulation\n        } else if (self < 1. && sum > 2. && sum < 4.) {\n            RESURRECT // Reproduction\n        } else {\n            PERSIST\n        }\n    } else {\n        PERSIST\n    }\n}","name":"Buffer A","description":"","type":"buffer"}]}