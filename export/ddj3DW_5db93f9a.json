{"ver":"0.1","info":{"id":"ddj3DW","date":"1667667164","viewed":125,"name":"Mario Mushroom","username":"Mario8664","description":"super mario mushroom","likes":5,"published":1,"flags":32,"usePreview":0,"tags":["raymarching","sdf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dX3zn","filepath":"/media/a/550a8cce1bf403869fde66dddf6028dd171f1852f4a704a465e1b80d23955663.png","previewfilepath":"/media/ap/550a8cce1bf403869fde66dddf6028dd171f1852f4a704a465e1b80d23955663.png","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define DISTANCE 5.0\n#define PI 3.1415926535897932384626\n#define FRESNEL 3.0\n#define AOSTEP 0.1\n#define LIGHT vec3(-1.0, 2.0, -1.0)\n#define SUNSIZE 0.01\n\nvec3 capDown;\nvec3 capRight;\nvec3 capForward;\n\nvec4 opUnion(vec4 d1, vec4 d2)\n{\n    float d = min(d1.w, d2.w);\n    //difference is (1, 0) or (0, 1)\n    vec2 difference = normalize(vec2(abs(d - d1.w), abs(d - d2.w)));\n    vec3 colorMix = difference.x * d2.rgb + difference.y * d1.rgb;\n    return vec4(colorMix, d);\n}\n\nvec4 opSubtraction(vec4 d1, vec4 d2 )\n{\n    d1.w = -d1.w;\n    float d = max(d1.w, d2.w);\n    //difference is (1, 0) or (0, 1)\n    vec2 difference = normalize(vec2(abs(d - d1.w), abs(d - d2.w)));\n    vec3 colorMix = difference.x * d2.rgb + difference.y * d1.rgb;\n    return vec4(colorMix, d);\n}\n\nvec4 opSmoothSubtraction(vec4 d1, vec4 d2, float k)\n{\n    d1.w = -d1.w;\n    float difference = max(k - abs(d1.w - d2.w), 0.0);\n    float d = max(d1.w, d2.w) + difference * difference * 0.25 / k;\n    //colorDifference is between (1, 0) and (0, 1)\n    vec2 colorDifference = vec2(abs(d - d1.w), abs(d - d2.w));\n    colorDifference.x = colorDifference.x / (colorDifference.x + colorDifference.y);\n    colorDifference.y = 1.0 - colorDifference.x;\n    vec3 colorMix = colorDifference.x * d2.rgb + colorDifference.y * d1.rgb;\n    return vec4(colorMix, d);\n}\n\nvec4 sdSphere(vec3 pos, float radius, vec3 color)\n{\n\treturn vec4(color, length(pos) - radius);\n}\n\nvec4 sdCapsule(vec3 pos, vec3 a, vec3 b, float radius,vec3 color)\n{\n  vec3 pa = pos - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  /*     \n          p\n          ↓                 ph = √pa * pa - ah * ah = length(pa - ah)\n      a---h----------b\n  */\n  return vec4(color, length( pa - ba*h ) - radius);\n}\n\nvec4 sdRoundedCylinder(vec3 p, float radius, float roundRadius, float height,vec3 color)\n{\n  vec2 d = vec2( length(p.xz) - 2.0 * radius + roundRadius, abs(p.y) - height);\n  return vec4(color, min(max(d.x,d.y),0.0) + length(max(d,0.0)) - roundRadius);\n}\n\nvec4 getScene(vec3 pos)\n{\n    const vec3 capColor = vec3(0.8, 0.0, 0.0);\n    const vec3 pointColor = vec3(1.0, 1.0, 1.0);\n    const vec3 faceColor = vec3(1.0, 0.85, 0.7);\n    const vec3 eyeColor = vec3(0.0, 0.0, 0.0);\n    \n    //Symmetry\n    vec3 pe = pos;\n    pe.x = abs(pe.x);\n    \n    //cap\n    vec4 s1 = sdSphere(pos - vec3(0.0, 0.3, 0.0), 1.2, capColor);\n    vec4 s2 = sdSphere(pos - capDown * 3.18, 2.8, capColor);\n    vec4 cap = opSmoothSubtraction(s2, s1, 0.75);\n    vec4 s3 = sdSphere(pos - capDown * 0.7, 0.8, capColor);\n    cap = opSmoothSubtraction(s3, cap, 0.25);\n    //face\n    vec4 face = sdRoundedCylinder(pos - vec3(0.0, 0.0, -0.12), 0.37, 0.55, 0.32, faceColor);\n    //point\n    vec4 ps = sdSphere(pos - capDown * 3.18, 3.2, pointColor);\n    vec4 p1 = sdSphere(pos - (capForward * 0.65 - capDown * 0.47), 0.81, pointColor);\n    vec4 p2 = sdSphere(pos - (-capForward * 0.39 - capDown * 0.52), 0.81, pointColor);\n    //dean_the_coder suggests that using symmetry trick\n    vec4 p3 = sdSphere(pe - (capForward * 0.15 -capRight * 0.5 - capDown * 0.5), 0.81, pointColor);\n    //vec4 p3 = sdSphere(pos - (capForward * 0.15 -capRight * 0.5 - capDown * 0.5), 0.81, pointColor);\n    //vec4 p4 = sdSphere(pos - (capForward * 0.15 +capRight * 0.5 - capDown * 0.5), 0.81, pointColor);\n    vec4 p5 = sdSphere(pos - (capForward * 0.15 - capDown * 0.82), 0.81, pointColor);\n    vec4 p = opUnion(p1, p2);\n    p = opUnion(p, p3);\n    //p = opUnion(p, p4);\n    p = opUnion(p, p5);\n    ps = opSubtraction(ps, p);\n    vec4 pSmoothS = sdSphere(pos - vec3(0.0, 0.3, 0.0), 1.21, pointColor);\n    pSmoothS.w = -pSmoothS.w;\n    ps = opSmoothSubtraction(pSmoothS, ps, 0.08);\n    //eye\n    vec4 e1 = sdCapsule(pe, vec3(0.21, -0.4, -0.74),  vec3(0.22, -0.2, -0.76), 0.095, eyeColor);\n    \n    return opUnion(cap, opUnion(face, opUnion(ps, e1)));\n}\n\nvec3 skyBox(vec3 rd)\n{\n    //return texture(iChannel0, rd).xyz;\n    vec3 sky = mix(vec3(1.2), vec3(0.7, 0.8, 1.0), smoothstep(-0.3, 0.7, rd.y));\n    vec3 land = mix(vec3(0.0), vec3(0.2, 0.2, 0.3), smoothstep(-0.9, 0.3, rd.y));\n    vec3 skybox = mix(land, sky, smoothstep(-0.05, 0.1, rd.y));\n    \n    float sun = dot(rd, normalize(LIGHT));\n    sun = (sun - 1.0 + SUNSIZE) / SUNSIZE;\n    sun = clamp(sun, 0.0, 1.0);\n    sun = pow(sun, 5.0);\n    \n    return skybox + sun;\n    //return ceil(rd * 10.0) / 10.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (-iResolution.xy + 2.0*fragCoord) / iResolution.y;\n    //Camera\n    vec2 m = texture(iChannel1, vec2(0.75)).xy;//Camera input\n    vec3 target = vec3(0.0, 0.0, 0.0);//Camera view target\n    float theta = m.x * 2.0 * PI;//Input to y-axis angle(0 ~ 2PI)\n    float fai = -(m.y - 0.5) * 0.8 * PI;//Input to local x-axis angle(-0.4Pi ~ 0.4PI)\n\n    //rotation vector(unit vector)\n    vec3 rotation = vec3(cos(theta), sin(fai) ,sin(theta));\n    rotation.xz *= cos(fai);\n    \n    vec3 cameraPos = rotation * DISTANCE;\n    vec3 cameraForward = normalize(target - rotation);\n    vec3 cameraRight = normalize(cross(cameraForward, vec3(0.0, 1.0, 0.0)));\n    vec3 cameraUp = cross(cameraRight, cameraForward);\n    \n    vec3 ro = cameraPos;\n    vec3 rd = cameraForward * 2.0 + uv.x * cameraRight + uv.y * cameraUp;\n    rd = normalize(rd);\n    \n    float t = 0.0;\n    vec3 pos = ro;\n    vec3 col = skyBox(rd);\n    \n    //uniform\n    capDown = normalize(vec3(0.0, -2.8, -1.3));\n    capRight = normalize(cross(vec3(0.0, 1.0, 0.0), capDown));\n    capForward = cross(capDown, capRight);\n    \n    for(int i = 0; i < 128; i++)\n    {\n    \tvec4 d = getScene(pos);\n        if(abs(d.w)<(0.0001*t))\n        {\n            vec2 offset = vec2(0.001, 0.0);\n            vec3 normal = vec3(getScene(pos + offset.xyy).w - getScene(pos - offset.xyy).w,\n                               getScene(pos + offset.yxy).w - getScene(pos - offset.yxy).w,\n                               getScene(pos + offset.yyx).w - getScene(pos - offset.yyx).w);\n            normal = normalize(normal);\n            //reflection\n            vec3 ref = skyBox(reflect(rd,normal)) * 0.5;\n            //fresnel\n            float fresnel = (1.0 - dot(normal, -rd));\n            fresnel = pow(fresnel, FRESNEL);\n            //diffuse\n            float diffuse = dot(normal, normalize(LIGHT));\n            diffuse = clamp(diffuse, 0.1, 1.0);\n            diffuse = pow(diffuse, 0.5);\n            //specular\n            float specular = clamp(dot(normal,normalize(LIGHT-rd)), 0.0, 1.0);\n            specular = pow(specular, 18.0) * 0.3;\n            //ambient occlusion\n            ro = pos;\n            t = 0.0;\n            float ao = 0.0;\n            for(int j = 0; j < 4; j++)\n            {\n                ao += 1.0 / pow(2.0, float(j)) * (float(j) * AOSTEP - getScene(pos).w);\n                t -= AOSTEP;\n                pos = ro + rd * t;\n            }\n            ao = 1.0 - ao;\n        \tcol = diffuse * d.rgb + ref * fresnel + vec3(0.05) + specular;\n            col *= ao;\n            break;\n        }\n        t += d.w;\n        pos = ro + rd * t;        \n    }\n    \n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void mainImage( out vec4 i, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    vec4 lastil = texture(iChannel0, vec2(0.25));\n    \n    if(uv.x < 0.5)\n    {\n        i = vec4(0.0);\n        vec2 m = i.xy = iMouse.xy / iResolution.xy;\n        if(iMouse.w > 0.5 || iFrame == 0)\n        {\n            lastil.xy = m;\n        }\n        i.xy = m;\n        vec2 offset = (m - lastil.xy) * MOUSE_STEP;\n        i.zw = mix(offset, lastil.zw, 1.0 - MOUSE_LERP * iTimeDelta);\n    }\n    else\n    {\n        if(iFrame == 0)\n        {\n            i = vec4(INIT, 0.0, 0.0);\n        }\n        else\n        {\n            i = texture(iChannel0, vec2(0.75));\n            i.xy += lastil.zw;\n            i.x = fract(i.x);\n            i.y = clamp(i.y, 0.0, 1.0);\n        }\n\n    }\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define MOUSE_LERP 5.0\n#define MOUSE_STEP 0.5\n#define INIT vec2(0.75, 0.5)","name":"Common","description":"","type":"common"}]}