{"ver":"0.1","info":{"id":"fdySRm","date":"1634387366","viewed":180,"name":"Noisy Acc Motion Blur","username":"yunhai","description":"noise idea reference to: https://www.shadertoy.com/view/XlBGRz\nbetter than last time I think\nand add some glow now(method just a little like raymarching fog)\n","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["motionblur"],"hasliked":0,"parentid":"7dVXzz","parentname":"Accumulation Motion Blur"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float GLOW=2.;//0.;\nfloat AMBIENT=.1;\nfloat LIGHT_TENSITY=0.;//1.;\n/*------------OBJ DEFINE------------*/\nconst float TIMES=5.;\n\n\nconst int OBJ_NUM=3;\nconst int ID_BOUND=0;\nconst int ID_BOX=1;\nconst int ID_S=2;\nconst int ID_HIGHCUBE=3;\nvec3 getPos(float t)\n{\n    t*=20.5;\n    return vec3(sin(t*1.2)*2.,cos(t)*.6-.9,sin(t*.5)*7.+7.7)*.1;\n}\nMarchPoint sdf(in vec3 p,float t)\n{\n    float[OBJ_NUM] objSDF;\n    for(int i=0;i<OBJ_NUM;i++)\n        objSDF[i]=INF;\n    objSDF[ID_BOUND]=-sdSphere(p-vec3(0,0,0),MAX_DIST);//Bound\n    \n    /*--------add objects begin--------*/\n    objSDF[ID_BOX]=-sdCube(p-vec3(0,0,.5),vec3(2.,1.,8.2));\n    objSDF[ID_S]=sdSphere(p-getPos(t),.04);\n    /*--------add objects end--------*/\n    \n    MarchPoint tar=MarchPoint(objSDF[ID_BOUND],objSDF[ID_S],ID_BOUND);\n    for(int i=1;i<OBJ_NUM;i++)\n        if(tar.d>objSDF[i])\n            tar.d=objSDF[i],\n            tar.id=i;\n\n    return tar;\n}\nvec3 getNormal(in vec3 p,float t)\n{\n    vec2 e=vec2(0,EPS);\n    float c=sdf(p,t).d;\n    return normalize(vec3(sdf(p+e.yxx,t).d-c,\n                          sdf(p+e.xyx,t).d-c,\n                          sdf(p+e.xxy,t).d-c));\n}\nstruct FragInfo\n{\n    vec3 worldPos,normal,kc;\n    float ao;\n};\nvec3 pixelShade(in FragInfo I)\n{\n    vec3 lightPos=vec3(0.,.4,.8);\n    vec3 pl=lightPos-I.worldPos,ld;\n    float plLen=length(pl);\n    ld=pl/plLen;\n    float tense=LIGHT_TENSITY;\n    vec3 diff=vec3(1)*max(dot(ld,I.normal),0.)/(plLen*plLen)*tense;\n    vec3 amb=vec3(AMBIENT)*((1.-I.ao)*.7+.3);\n    return I.kc*(diff+amb);\n}\nfloat getSomeGlow(float controlRadius,float dist,float tensity)\n{\n    return pow(controlRadius/max(dist,1e-6),tensity);\n}\nMarchHit rayCast(in Ray r,float t)\n{\n    float d=0.,i=0.,l=0.;\n    MarchPoint point;\n    float glow=0.;\n    for(;i<MAX_STEP;i++)\n    {\n        point=sdf(r.o+d*r.d,t);\n        //if(point.id==ID_S)\n            glow+=getSomeGlow(.008,point.sd,1.3)*exp(-point.sd*2.);//glow sphere\n        if(abs(point.d)<MIN_DIST)\n            break;\n        l=i/MAX_STEP;\n        d+=point.d*((1.-l*l*l)*0.7+0.3);\n        if(point.id==ID_BOUND)\n        {\n            d=MAX_DIST;\n            break;\n        }\n    }\n    return MarchHit(d,i,point.id,glow);\n}\nvec4 render(in Ray r,float t)\n{\n    \n    MarchHit h=rayCast(r,t);\n    \n    vec3 pos=r.o+r.d*h.d,nml=getNormal(pos,t);\n    vec3 col=vec3(0);\n    float quickAO=h.marchTimes/MAX_STEP;\n    vec3 sCol=vec3(.1,.5,.8);//vec3(1.,.5,.25);\n    switch (h.id)\n    {\n        case ID_BOUND:\n            break;\n        case ID_BOX:\n            vec3 kc=mix(vec3(1),nml.x*vec3(1,0,0)-nml.x*vec3(0,1,0),\n                        step(.5,abs(nml.x)));kc=max(kc,0.);\n            col=pixelShade(FragInfo(pos,nml,kc,quickAO));\n            break;\n        case ID_S:\n            col=pixelShade(FragInfo(pos,nml,sCol,0.));\n            break;\n    }\n    col=col+h.glow*sCol*GLOW;\n    \n    return vec4(col,quickAO);\n}\nRay genRay(in vec2 C,float t)\n{\n    cam.pos=vec3(0,-.1,-.2);\n    cam.dir=normalize(vec3(sin(t)*.05,0,1.));\n    cam.r=-cross(cam.dir,vec3(0,1,0));\n    cam.u=-cross(cam.r,cam.dir);\n    vec2 uv=(C-iR*.5)/iR.y;\n    Ray r=Ray(cam.pos,normalize(uv.x*cam.r+uv.y*cam.u+1.*cam.dir));\n    return r;\n}\nfloat hash21(vec2 c)\n{\n    return fract(sin(c.x*12.2143+c.y*87.4132)*4321.);\n}\nvoid mainImage( out vec4 O, in vec2 C )\n{\n    float t=iTime;\n    \n\n//blur \n    O=vec4(0);\n    float dc=1./TIMES;\n    for(float i=0.;i<TIMES;i++)\n    {\n        float r=hash21(C+vec2(i)),nt=t+.01*(i+r);\n        O+=render(genRay(C,nt),nt)*dc;\n    }\n    O=1.-exp(-O);//tone map\n    O=pow(O,vec4(.45));//gamma \n    \n    \n    \n    \n#ifdef SHOW_RAYMARCH_STEPS\n    O.rgb=mix(vec3(0,1,0),vec3(1,0,0),O.w);\n#endif\n\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"/*------------Log------------*/\n//updated: QuickAO\n\n/*---------------------------*/\n\n\n\n/*------------Env Settings------------*/\n//#define SHOW_RAYMARCH_STEPS\n/*------------Env Settings------------*/\n#define iR iResolution.xy\n#define iT iTime\n#define iM iMouse\nconst float MAX_DIST=20.;\nconst float MIN_DIST=1e-4;\nconst float MAX_STEP=50.;\nconst float EPS=1e-4;\nconst float INF=1e99;\nconst float PI=3.14159265;\nconst float DTA=PI/180.;\nstruct Ray\n{\n    vec3 o,d;\n};\nstruct Cam\n{\n    vec3 pos,dir;\n    vec3 r,u;\n}cam;\nstruct MarchPoint\n{\n    float d,sd;//sphere dist\n    int id;\n};\nstruct MarchHit\n{\n    float d,marchTimes;\n    int id;\n    float glow;\n};\nmat2x2 getRotMat(float r)\n{\n    r*=DTA;\n    float c=cos(r),s=sin(r);\n    return mat2x2(c,s,-s,c);\n}\nfloat sdCube(vec3 p,vec3 size)\n{\n    vec3 np=abs(p)-size*.5;\n    float o=length(max(np,vec3(0)));\n    float i=min(0.,max(np.x,max(np.y,np.z)));\n    return o+i;\n}\nfloat sdSphere(vec3 p,float s)\n{\n    return length(p)-s;\n}\n","name":"Common","description":"","type":"common"}]}