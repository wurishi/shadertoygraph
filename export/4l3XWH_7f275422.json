{"ver":"0.1","info":{"id":"4l3XWH","date":"1479355805","viewed":277,"name":"Paint Splotches","username":"avarga","description":"Paint splotches spread at different speeds and can't move through each other. The resulting boundary for 2 splotches is part circle, part exponential spiral (yellow shape). More splotches -> more complex. Please send me any cool patterns found!","likes":2,"published":1,"flags":32,"usePreview":0,"tags":["circles","math","simulation","paint","cellular"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MIL 1000000.0\n\n/*\nPaint splotches spread at different speeds and can't move through each other. \nThe resulting boundary for 2 splotches is part circle, part exponential spiral.\nWith even 3 splotches, the equations get really complicated.\n\nEdit the initial conditions in Buf A.\n*/\n\n// speeds for RGBY; make sure speeds are same in Buf A\nvec4 speeds = vec4(0.55, 0.4, 1.0, 0.6);\n\nfloat wave(float x) {\n \treturn (cos(x/4.0)/4.0)+0.75;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tvec4 samp = texture(iChannel0,uv);\n        \n    if (samp[0] < MIL) {\n    \tfragColor = vec4(wave(samp[0]/speeds[0]), 0.0, 0.0, 1.0);\n    } else if (samp[1] < MIL) {\n    \tfragColor = vec4(0.0, wave(samp[1]/speeds[1]), 0.0, 1.0);\n    } else if (samp[2] < MIL) {\n    \tfragColor = vec4(0.0, 0.0, wave(samp[2]/speeds[2]), 1.0);\n    } else if (samp[3] < MIL) {\n        float x = wave(samp[3]/speeds[3]);\n    \tfragColor = vec4(x, x, 0.0, 1.0);\n    } else {\n        fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n    }\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define MIL 1000000.0\n\n// speeds for RGBY; make sure speeds are same in Image\nvec4 speeds = vec4(0.55, 0.4, 1.0, 0.6);\n\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat f(float a, float b) {   \n    return sqrt(abs(0.5-pow(a-b, 2.0)/4.0))+(a+b)/2.0;\n}\nfloat g(float a, float b) {\n    return sqrt(abs(1.0-pow(a-b, 2.0)/2.0))+(a+b)/2.0;\n}\n\nvoid rdot(vec2 p, inout vec4 fragColor, inout vec2 fragCoord) {\n    float len = length(fragCoord-p*vec2(iResolution));\n    if (len <= 2.0) { fragColor.x = len; }\n}\nvoid gdot(vec2 p, inout vec4 fragColor, inout vec2 fragCoord) {\n    float len = length(fragCoord-p*vec2(iResolution));\n    if (len <= 2.0) { fragColor.y = len; }\n}\nvoid bdot(vec2 p, inout vec4 fragColor, inout vec2 fragCoord) {\n    float len = length(fragCoord-p*vec2(iResolution));\n    if (len <= 2.0) { fragColor.z = len; }\n}\nvoid ydot(vec2 p, inout vec4 fragColor, inout vec2 fragCoord) {\n    float len = length(fragCoord-p*vec2(iResolution));\n    if (len <= 2.0) { fragColor.w = len; }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if (iFrame == 0) {        \n        vec4 ret = vec4(MIL, MIL, MIL, MIL);\n\n        // SET INITIAL CONDITIONS HERE //\n        \n        bdot(vec2(0.5, 0.5), ret, fragCoord);\n        ydot(vec2(0.62, 0.5), ret, fragCoord);\n        //gdot(vec2(0.66, 0.5), ret, fragCoord);\n        rdot(vec2(0.4, 0.42), ret, fragCoord);\n        rdot(vec2(0.4, 0.58), ret, fragCoord);\n        \n        fragColor = ret;\n        return;\n    } \n    \n    vec2 uv = fragCoord / ( iResolution.xy);\n    vec4 ret = texture(iChannel0, uv);   \n    \n    if (ret == vec4(MIL, MIL, MIL, MIL)) {\n        vec4 n1 = texture(iChannel0, ( fragCoord + vec2(-1.0,1.0 ) ) / (iResolution.xy));\n        vec4 n2 = texture(iChannel0, ( fragCoord + vec2(0.0,1.0  ) ) / (iResolution.xy));\n        vec4 n3 = texture(iChannel0, ( fragCoord + vec2(1.0,1.0  ) ) / (iResolution.xy));\n        vec4 n4 = texture(iChannel0, ( fragCoord + vec2(1.0,0.0  ) ) / (iResolution.xy));\n        vec4 n5 = texture(iChannel0, ( fragCoord + vec2(1.0,-1.0 ) ) / (iResolution.xy));\n        vec4 n6 = texture(iChannel0, ( fragCoord + vec2(0.0,-1.0 ) ) / (iResolution.xy));\n        vec4 n7 = texture(iChannel0, ( fragCoord + vec2(-1.0,-1.0) ) / (iResolution.xy));\n        vec4 n8 = texture(iChannel0, ( fragCoord + vec2(-1.0,0.0 ) ) / (iResolution.xy));\n\n        float mind = MIL;\n        float mint = float(iFrame)/3.0;\n        int mini = -1;\n        for (int i=0; i<4; i++) {\n            float d = MIL;\n            float sp = speeds[i];\n            d = min(d, f(n2[i], n4[i]));\n            d = min(d, f(n4[i], n6[i]));\n            d = min(d, f(n6[i], n8[i]));\n            d = min(d, f(n8[i], n2[i]));\n            if (d >= MIL) {\n                d = min(d, g(n1[i], n3[i]));\n                d = min(d, g(n3[i], n5[i]));\n                d = min(d, g(n5[i], n7[i]));\n                d = min(d, g(n7[i], n1[i]));\n            }\n            float t = d/sp;\n            if (t < mint) {\n                mind = d;\n                mint = t;\n                mini = i;\n            }\n        }\n        \n        if (mini == 0) {\n            ret[0] = mind;\n        } else if (mini == 1) {\n            ret[1] = mind;\n        } else if (mini == 2) {\n            ret[2] = mind;\n        } else if (mini == 3) {\n            ret[3] = mind;\n        }\n    }\n    \n    fragColor = ret;       \n}\n\n\n\n\n","name":"Buf A","description":"","type":"buffer"}]}