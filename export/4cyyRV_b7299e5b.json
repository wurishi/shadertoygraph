{"ver":"0.1","info":{"id":"4cyyRV","date":"1732065108","viewed":40,"name":"RayTraced Camera System","username":"sadekguerrah2","description":"The Camera System Using LookAt() and prespectiveFov() function made from scratch;\nand how we can get the rayDirection from the modelMatrices.","likes":0,"published":1,"flags":32,"usePreview":0,"tags":["camera","andrays"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n\nconst float FieldOfView = 120.0f ; // In Degree \n\n   vec3 Direction;\n   vec3 CameraPosition = vec3(0,0,-0.3f);\n   vec3 UpVector = vec3(0,1,0);\n\n\n\n   struct rr {\n  vec3 Direction;\n  vec3 Origin;\n  };\n\n  rr ray;\n\n  struct modelMatrix {\n    \n     mat4 viewMatrix;\n     mat4 projectionMatrix;\n     mat4 inverseViewMatrix;\n     mat4 inverseProjectionMatrix;     \n};\n   \n   modelMatrix m;\n\n  \tconst  float m_NearClip = 0.1f;\n\tconst  float m_FarClip = 100.0f;\n\nvoid makeModelMatric() {\n\n  m.viewMatrix = lookAt(Direction , CameraPosition , UpVector );\n  m.projectionMatrix = prespectiveFov(radians(FieldOfView),iResolution.xy,m_FarClip,m_NearClip);\n\n  /*inverse*/\n  m.inverseViewMatrix = inverse(m.viewMatrix);\n  m.inverseProjectionMatrix = inverse(m.projectionMatrix);\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uvCoord = fragCoord/iResolution.xy;\n      vec2 texCoord = uvCoord*2.0f - 1.0f;   ///Space -1...1\n       Direction = texture(iChannel0 , uvCoord).rgb;  \n       \n       makeModelMatric();\n\n       \n       ray.Direction = getRayDirection(texCoord , m.inverseViewMatrix , m.inverseProjectionMatrix );\n       ray.Origin = CameraPosition;\n\n\n    vec3 col = texture(iChannel1 , ray.Direction).rgb;\n\n   \n    // Output to screen\n    fragColor = vec4(col ,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":" mat4 lookAt(vec3 direction , vec3 Center , vec3 UpVector) {\n\n    vec3 x,y,z;\n    \n    direction *= -1.0f;\n    \n   \n    z = Center - direction ; \n    z = normalize(z);\n    \n    x = cross(UpVector,z);\n    x = normalize(x);\n\n    y = cross(z,x);\n     y = normalize(y); \n    \n   \n   \n\n   mat4 product = mat4(x.x,y.x,z.x,0.0f,\n                     x.y,y.y,z.y,0.0f,\n                     x.z,y.z,z.z,0.0f, \n                     dot(-x,direction),dot(-y,direction),dot(-z,direction),1.0f);\nreturn product;   \n}\n\n\nmat4 prespectiveFov(float fov , vec2 screenDimantion, float far, float near) {\n\n    float aspect_ratio = screenDimantion.x / screenDimantion.y;\n\n   float b = 1.0f/(tan(fov/2.0f));\n   float a = b * (1.0f/aspect_ratio);\n   \n   float c = -(far+near)/(far-near);\n   float d = -(2.0f * far * near)/(far-near);\n\n   mat4 product = mat4(a,0,0,0,\n                       0,b,0,0,\n                       0,0,c,d,\n                       0,0,-1,0);\n\n  return product;\n}\n\n\n vec3 getDirection(vec2 mouseDelta) {\n\n   vec3 Direction;\n   mouseDelta += vec2(0,-0.5);\n\n   Direction.x = cos(mouseDelta.x) * cos(mouseDelta.y);\n   Direction.y = sin(mouseDelta.y);\n   Direction.z = sin(mouseDelta.x) * cos(mouseDelta.y); \n\n   return normalize(Direction);\n\n}\n\n\nvec3 getRayDirection(vec2 texCoord, mat4 InvMatrix, mat4 invProjectionMatrix) {\n\n     vec4 target = invProjectionMatrix * vec4(texCoord.xy,1,1);\n  return vec3(InvMatrix * vec4( normalize(target.xyz/target.w) , 0 ));\n}","name":"Common","description":"","type":"common"},{"inputs":[],"outputs":[{"id":"XdfGR8","channel":0}],"code":"\n\n/*Mouse Data Only*/\n\n\n\n\n\n   vec2 MosuePosition;\n\n   void playMouse(out vec3 direction) {\n\n   vec3 mouse = iMouse.xyz;\n     mouse.xy /= iResolution.xy;\n   mouse.xy = mouse.xy * 2.0f - 1.0f ;   \n\n   mouse.x =   mouse.x - iResolution.x/2.0 ;\n\n   mouse.y = - mouse.y - iResolution.y/2.0 ;\n\n  \n   \t\tfloat pitchDelta =  mouse.y * 1.0f;\n\t\tfloat yawDelta =   mouse.x * 1.0f;\n   direction = getDirection(vec2(yawDelta,pitchDelta));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n     vec3 Dir;\n     float isClicked = iMouse.z;\n\n     playMouse(Dir);\n     \n      \n    \n    fragColor = vec4(Dir,isClicked);\n}","name":"Buffer D","description":"","type":"buffer"}]}