{"ver":"0.1","info":{"id":"XdKXWW","date":"1465008611","viewed":159,"name":"Raymarcher WSAO Cube","username":"VoidChicken","description":"A raymarcher with a weird outcome.  World Space Ambient Occlusion = WSAO","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raymarcher"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"mat4 rotationMatrix(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n                0.0,                                0.0,                                0.0,                                1.0);\n}\nfloat map( vec3 p , vec3 b, out float c, out float od)\n{\n  p = vec3(vec4(p,1)*rotationMatrix(vec3(0,1,0), iTime));\n  vec3 d = abs(p+vec3(0,sin(iTime/2.)*5., 0)) - b; \n  float dfI =  max(min(max(d.x,max(d.y,d.z)),0.0) +\n         length(max(d,0.0)), -b.x);\n    c=dfI;\n    od=2.9+p.y;\n  return min( dfI\n     ,\n      \t\n      \tod\n      );\n}\nvec3 b = vec3(3);\nfloat shade( in vec3 ro, in vec3 rd)\n{\n    float k = 8.;\n    float res = 1.0;\n    vec3 r = ro+rd*1.;\n    for( float t=.5; t < 128.; t++)\n    {\n        float blk = 0.;\n        float h = map(r,b,blk,blk);\n        if( h<0.001 )\n            return 0.0;\n        res = min( res, k*h/t );\n        r+=r*h;\n    }\n    return res;\n}\n\nvec3 march(vec3 ro, vec3 rd) {\n    vec3 r = ro;\n    vec3 col = vec3(0);\n    int u = 0;\n    \n    float dfI;\n    float od;\n    bool hasn = false;\n    for (int i = 0; i < 128; i++) {\n        float df = map(r,b,dfI, od);\n        if(df>0.) r+=rd*df;\n        else r+=rd*.1; \n        vec3 AO = min(max(min(1., 1.-abs(min((dfI-od)*5.,1.))),0.),1.)*vec3(.2);\n        if ((od<0.001)&&!hasn) return (texture(iChannel0, r.xz).rgb-AO);//*shade(r,vec3(1,1,1));\n        if (df<0.001) {\n            u++;\n\t\t\tif (dfI==df) hasn=true;\n            \n            col+=((vec3(0, .5, 1))*((df+b.x)/b.x)) ;\n        }\n       \n    }\n    return col/float(u);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tfragColor = vec4(march(vec3(0, 0, -10), vec3(uv-.5,1)),1);\n}","name":"Image","description":"","type":"image"}]}