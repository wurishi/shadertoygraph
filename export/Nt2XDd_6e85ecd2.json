{"ver":"0.1","info":{"id":"Nt2XDd","date":"1628893397","viewed":87,"name":"Nevoke preparty shaderjam","username":"Exca","description":"Nevoke preparty jamming.","likes":3,"published":1,"flags":32,"usePreview":0,"tags":["raymarch","jam"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n  \n\tfragColor = texture(iChannel0, uv);\n\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4sXGzn","filepath":"/media/a/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3","previewfilepath":"/media/ap/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3","type":"music","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"float fft = 0.0;\nfloat fftS = 0.0;\nfloat fftI = 0.0;\nfloat beat = 0.0;\nfloat beatStep = 0.0;\nfloat bm = 0.0;\n\nvec3 cam = vec3(0.0);\n\nvec3 palette( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d)\n{\n  return a + b*cos(6.28318* (c*t+d));\n}\n\nvec3 rotate( vec3 p, float x, float y, float z)\n{\n  mat3 rotx = mat3(1.0, 0.0, 0.0, 0.0, cos(x), -sin(x), 0.0, sin(x), cos(x));\n  mat3 roty = mat3( cos(y), 0.0, sin(y), 0.0, 1.0, 0.0, -sin(y), 0.0, cos(y));\n  mat3 rotz = mat3( cos(z), -sin(z), 0.0, sin(z), cos(z), 0.0, 0.0, 0.0, 1.0);\n  return rotx*roty*rotz*p;\n}\n\nvec3 getcam( vec3 cam, vec3 target, vec2 uv, float fov)\n{\n  vec3 forward = normalize(target - cam);\n  vec3 right = normalize(cross( vec3(0,1,0), forward));\n  vec3 up = normalize( cross(forward, right));\n  \n  return normalize( forward*fov + right * uv.x + up * uv.y);\n}\n\nvec3 repeat( vec3 p, vec3 c) \n{\n  vec3 q = mod(p+0.5*c, c)-0.5*c;\n  return q;\n}\n\nfloat ground(vec3 p, float h)\n{\n  return p.y -h;\n}\n\nfloat sphere(vec3 p, float r)\n{\n  return length(p)-r;\n}\nfloat roundcube( vec3 p, vec3 b, float r)\n{\n  vec3 d = abs(p)-b;\n  return min(max(d.x, max(d.y, d.z)),0.0)+length(max(d,0.0))-r;\n}\n\nfloat prism( vec3 p, vec2 h )\n{\n  vec3 q = abs(p);\n  return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n}\n\nfloat U(float a, float b){\n  return min(a,b);\n}\n\nvec3 map( vec3 p)\n{\n  vec2 id = floor((p.xz+2.0)/4.0-2.0) ;\n  \n  float beatstep = fract( iTime*0.5+(id.x+id.y)/2.0);\n\n  float distsize = length(p-cam);\n  \n  vec3 cp = repeat(p, vec3(4,4, 4));\n  cp = rotate( cp, 0.0, 0.0, id.x+smoothstep(0.0, 1.0,beatstep)*3.14/4.0 + beat*3.14/8.0);  \n  float g = ground(p, -3.0);\n  \n  float pr = prism(cp, vec2(\n  1.20+smoothstep(10.0, 30.0,distsize),\n  0.7+ (sin(id.x+iTime)-cos(id.y-iTime*0.5))+smoothstep(10.0, 30.0,distsize)\n  ));\n  \n  return vec3(U(pr,g),1,1);\n}\n\nvec3 march( vec3 cam, vec3 rd, out vec3 p, out float t, out int steps)\n{\n  t = 0.0;\n  for(int i = 0; i < 140; i++)\n  {\n    steps = i;\n    p = cam + rd*t;\n    \n    vec3 r = map(p);\n    float bx = roundcube(\n      repeat( p + vec3(2.0), vec3(4.0,0,0)),\n      vec3(0.00001,100,100),0.0 );\n    float bz = roundcube(\n      repeat( p + vec3(2.0), vec3(0.0,0,4)),\n      vec3(100,100,0.00001),0.0);\n    float by = roundcube(\n      repeat( p + vec3(2.0), vec3(0.0,4,0)),\n      vec3(100,0.0001,100),0.0);\n    \n    float delta = min(max(0.1, bx), r.x);\n    delta = min( max(0.1, bz), delta);\n    delta = min( max(0.1, by), delta);\n    \n    \n    t += delta;\n    if(r.x < 0.001) return r;\n    \n    if(t > 50.0){ \n      t = 50.0;\n      return vec3(-1);\n    }\n  }\n  return vec3(-1);\n}\n\nvec3 marchInside( vec3 cam, vec3 rd, out vec3 p)\n{\n  float t = 0.0;\n  for(int i = 0; i < 100; i++)\n  {\n    p = cam + rd*t;\n    vec3 r = map(p);\n    t += abs(r.x);\n    if(r.x > 0.001) return r;\n  }\n  t = 100.0;\n  return vec3(-1);\n}\n\n\nvec3 normal( vec3 p )\n{\n  vec3 c = map(p);\n  vec2 e = vec2(0.1, 0.0);\n  return normalize( vec3(\n    map(p+e.xyy).x,\n    map(p+e.yxy).x,\n    map(p+e.yyx).x\n  )-c.x );\n}\n\nfloat light( vec3 p, vec3 l, vec3 n)\n{\n  return max(0.0, dot(n, normalize(l-p)));\n}\n\nvec3 getcol( vec3 p)\n{\n    vec2 id = floor((p.xz+2.0)/4.0-2.0) ;\n    vec3 hitCol = palette( abs(sin(id.x+id.y)), vec3(0.5, 0.5, 0.5), vec3(0.5, 0.5,0.5), vec3(1.0, 1.0, 1.0), vec3(0.90, 0.8,0.4));\n    return hitCol*2.0;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n  \n  vec2 puv = uv;\n  puv -=0.5;\n  puv*=0.95;\n  puv += 0.5;\n  vec3 previous = texture(iChannel0, puv).rgb;\n\tuv -= 0.5;\n\tuv /= vec2(iResolution.y / iResolution.x, 1);\n\n  beat = floor( iTime*2.0);\n  beatStep = fract( iTime*2.0);\n  \n  fft = texture(iChannel1, vec2(0.2,0.5)).r;\n\tfftS = fft;\n\tfftI = fft+iTime;\n\t\n  float bm = mod( beat/4.0, 6.0);\n  \n  \n  vec3 col = vec3(0.);\n  \n  cam = vec3(4,10.0,0);\n  vec3 target = vec3(3,8,0);\n  \n  target = cam + vec3(\n    sin(iTime*0.1)*10.0,\n    cos(iTime*0.25)*10.0,\n    sin(iTime*0.5)*10.0\n  );\n  \n  float fov = 0.8;\n  \n  vec3 l1 = vec3(sin(iTime)*10.0, 10.0, 10.0);\n  \n  vec3 rd = getcam( cam, target, uv, fov);\n  vec3 p = cam;\n  float t = 0.0;\n  int steps = 0;\n  \n  vec3 material = march(cam, rd, p, t, steps);\n  vec3 n = normal(p);\n  if(material.y < -0.5)\n  {\n    //bg\n  }\n  else\n  {\n    vec3 hitCol = getcol(p);\n    \n    col = hitCol*(0.5+.5*light(p,l1,n));\n    \n    \n    vec3 rRD = reflect( rd, n );\n    \n    vec3 pReflect = p;\n    float tReflect = 0.0; int stepsReflect = 0;\n    vec3 reflectMat = march( p+rRD*0.1, rRD, pReflect, tReflect, stepsReflect);\n    \n    if(reflectMat.y < -0.5){\n      col = mix( col, vec3(0.5), 0.5);\n    }\n    else{\n      vec3 refN = normal(pReflect);\n      \n      vec2 id = floor((pReflect.xy+2.0)/4.0-2.0) ;\n    \n      \n      vec3 rc = normalize(pReflect);\n      vec3 rhitCol = getcol(pReflect);\n      \n      col = mix( \n        col, \n        vec3(1.0,0.5, 0.2)*(0.5+0.5*light(pReflect,l1,refN)),\n        0.5);\n    }\n  }\n  \n  vec3 grnd = vec3(0.75 + 0.2*( sin(p.z*10.0+fftI*5.)+sin(p.x*10.0-fftI*20.)));\n  \n  if(p.y < -2.99) col = mix( grnd, col, 1.0);\n  \n  col = mix(col, vec3(0.3, 0.3, 0.3), smoothstep( 30.0, 50.0, t));\n  \n  col = mix(col,col+ (previous-col) * smoothstep(0.1, 0.35,fftS),0.85);\n  \n\tfragColor = vec4(col,1.0);\n\n}","name":"Buffer A","description":"","type":"buffer"}]}