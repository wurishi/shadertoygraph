{"ver":"0.1","info":{"id":"3t2XWd","date":"1567587761","viewed":381,"name":"Star Travel","username":"Draedrus","description":"Wormhole\n\nThanks Kali for his work on https://www.shadertoy.com/view/XlfGRj\nThanks Shane for all his tunneling shaders :)","likes":8,"published":1,"flags":40,"usePreview":0,"tags":["raymarching","path"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//\n// @author: Pierre-Marie Plans\n// I made this tunneling effect learning from Shane codes\n// I began a year ago with another prototype so,\n// if you recognize some parts of your code here\n// please tell me so that I update the comment\n//==================================================\n// Stars texture from Kali\n// https://www.shadertoy.com/view/XlfGRj\n//// Star Nest by Pablo Roman Andrioli\n//// This content is under the MIT License.\n\n#define iterations 17\n#define formuparam 0.53\n\n#define volsteps 20\n#define stepsize 0.1\n\n#define zoom   0.800\n#define tile   0.850\n#define speed  0.010 \n\n#define brightness 0.0015\n#define darkmatter 0.300\n#define distfading 0.730\n#define saturation 0.850\n\n\nvec4 KaliStars(in vec2 uv, in vec3 from, vec3 path, float t, vec3 sp)\n{\n\tvec3 dir=vec3(uv*zoom,1.);\n\tvec3 time=t*sp;\n    from+=vec3(2.,1.0,-2.)*time;\n\n    dir = normalize(dir-path*0.4);\n\t\n\t//volumetric rendering\n\tfloat s=0.1,fade=1.;\n\tvec3 v=vec3(0.);\n\tfor (int r=0; r<volsteps; r++) {\n\t\tvec3 p=from+s*dir*.5;\n\t\tp = abs(vec3(tile)-mod(p,vec3(tile*2.))); // tiling fold\n\t\tfloat pa,a=pa=0.;\n\t\tfor (int i=0; i<iterations; i++) { \n\t\t\tp=abs(p)/dot(p,p)-formuparam; // the magic formula\n\t\t\ta+=abs(length(p)-pa); // absolute sum of average change\n\t\t\tpa=length(p);\n\t\t}\n\t\tfloat dm=max(0.,darkmatter-a*a*.001); //dark matter\n\t\ta*=a*a; // add contrast\n\t\tif (r>6) fade*=1.-dm; // dark matter, don't render near\n\t\t//v+=vec3(dm,dm*.5,0.);\n\t\tv+=fade;\n\t\tv+=vec3(s,s*s,s*s*s*s)*a*brightness*fade; // coloring based on distance\n\t\tfade*=distfading; // distance fading\n\t\ts+=stepsize;\n\t}\n\tv=mix(vec3(length(v)),v,saturation); //color adjust\n\treturn vec4(v*.01,1.);\t\n\t\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord;\n    vec3 eP;\n    vec3 rd = Init(uv, iResolution.xy, iTime, eP);\n    \n    vec4 A = texture(iChannel0, fragCoord/iResolution.xy);\n    \n    vec3 c = vec3(0.0);\n    c = vec3(A.x);\n    \n    c = KaliStars(uv, vec3(1.,.5,0.5), PATH(A.x), iTime, vec3(speed, speed, 0.0)).rgb;\n    vec3 cNear = vec3(0.0);\n    \n    if(A.x<FAR)\n    {\n    \tvec3 N = normalize(unpack(A.ga));\n        vec3 P = eP+rd*A.x;\n        #define X(x) 0.5*(1.0+sin(30.0*(P.z+x)+GT))\n        float s = 0.25*(X(.0) + X(.1) + X(.2) + X(.3));\n        \n        vec3 _c = .4*normalize(P+GT);\n        _c += .3*voronoi3D(P*4.+10.*s);\n    \t_c += vec3(.1, 0.4, 0.3)*pow(max(0.0, sin(4.0*P.z)), 8.*sin(dot(uv, P.xy))+16.);\n        _c *= s;\n        cNear += _c;\n    }\n    vec3 cFar = vec3(0.0);\n    \n    vec3 P = vec3(eP+rd*A.b);\n    c += mix(\n        8.0*0.4*normalize(P+GT)+pow(max(0.0, sin(0.1*P.z+2.0*GT)), 256.0)\n    \t+ 10.0*vec3(.2, 0.8, 0.6)*pow(max(0.0, sin(4.0*P.z)), 64.)\n        , cNear\n        , DEPTH(A.b));\n    c = mix(vec3(0.0), c, pow(DEPTH_NZ(A.x), 32.0));\n    //c += rd;\n    fragColor = vec4(c, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"//\n// @author: Pierre-Marie Plans\n// I made this tunneling effect learning from Shane codes\n// I began a year ago with another prototype so,\n// if you recognize some parts of your code here\n// please tell me so that I update the comment\n\n#define PI 3.1413\n\n#define FAR \t60.0\n#define NEAR \t0.01\n\n#define GT    3.0*iTime\n\n#define RM_ITE 120\n\n#define DEPTH_NZ(d) ((FAR-d)/(FAR-NEAR))\n#define DEPTH(d) (d/(FAR-NEAR))\n\n#define PATH2D(t) vec2(4.*cos(t*0.2)*sin(t*0.05), 4.0*sin(0.5*t))\n\n#define PATH(t) vec3(PATH2D(t), t)\n\n#define POS\t\tPATH(GT)\n#define TAR\t\tPATH(GT+8.5)\n\nvec2 pack(vec3 n)\n{\n    return n.xy*0.5+0.5;\n}\n\nvec3 unpack(vec2 enc)\n{\n    vec3 n;\n    n.xy = enc*2.0-1.0;\n    n.z = sqrt(1.0-dot(n.xy, n.xy));\n    return n;\n}\n\nfloat hash3D(vec3 x) {\n    float h = dot(x, vec3(42.69, 51.42, 34.405));\n\treturn fract(sin(h)*50403.43434);   \n}\n\n// from IQ\nfloat voronoi3D(vec3 uv) {\n    vec3 fl = floor(uv);\n    vec3 fr = fract(uv);\n    float res = 1.0;\n    for(int k=-1;k<=1;k++)\n    for( int j=-1; j<=1; j++ ) {\n        for( int i=-1; i<=1; i++ ) {\n            vec3 p = vec3(i, j, k);\n            float h = hash3D(fl+p);\n            vec3 vp = p-fr+h;\n            float d = dot(vp, vp);\n            \n            res +=1.0/pow(d, 8.0);\n        }\n    }\n    return pow( 1.0/res, 1.0/16.0 );\n}\n\nvec3 Init(inout vec2 uv, in vec2 res, in float iTime, out vec3 eP)\n{\n    uv /= res.xy;\n    uv *= res.x/res.y;\n    uv -= .4;\n    \n    vec2 cuv = -1.0+2.0*uv;\n      \n    eP = POS;\n    vec3 w = normalize(TAR-eP);\n    vec3 u = normalize(cross(w, vec3(0.0, 1.0, 0.0)));\n    vec3 v = normalize(cross(u, w));\n    mat3 evm = mat3(u, v, w);\n    vec3 rd = evm*normalize((vec3(cuv, 1.0)+w));\n    return rd;\n}","name":"Common","description":"","type":"common"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//\n// @author: Pierre-Marie Plans\n// I made this tunneling effect learning from Shane codes\n// I began a year ago with another prototype so,\n// if you recognize some parts of your code here\n// please tell me so that I update the comment\n\nfloat m(vec3 p, float t)\n{\n    \n    float depth = 0.0;\n    \n    // tunneling\n    p.xy -= PATH2D(p.z)\n        +\n        0.4*sin(t)*0.2*sin(20.0*vec2(atan(p.y, p.x), p.z));\n    depth = max(depth, max(0.0, 0.5 - 0.9 * length(p.xy)));\n    \n    \n    return depth;\n}\n\nfloat mr(vec3 p, float t)\n{\n    \n    float depth = FAR;\n    \n    // tunneling\n    p.xy -= PATH2D(p.z);\n    depth = min(depth, 0.3 * length(p.xy));\n    \n    \n    return depth;\n}\n\nvec3 Nrm(vec3 P, float t, float e)\n{\n    vec3 n;\n    n.y = mr(P, t);\n    n.x = mr(P+vec3(e, 0.0, 0.0), t) - n.y;\n\tn.z = mr(P+vec3(0.0, 0.0, e), t) - n.y;\n\tn.y = mr(P+vec3(0.0, e, 0.0), t) - n.y;\n\treturn normalize(n);\n}\n\n#define RAYMARCH(output, ro, rd, t, tmin, tmax, MAP) \\\nfloat output = 0.0;\\\n{\\\n\tfloat tm = tmin;\\\n    for(int i = 0;i<RM_ITE;++i)\\\n    {\\\n        vec3 p = ro+rd*tm;\\\n        float rm = MAP(p, t);\\\n        if(rm<tmin || tm>tmax) break;\\\n        tm += rm*0.5;\\\n    }\\\n    output = min(tm, tmax);\\\n}\\\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord;\n    vec3 eP;\n    vec3 rd = Init(uv, iResolution.xy, iTime, eP);\n\n    // raymarch\n    RAYMARCH(rm, eP, rd, iTime, NEAR, FAR, m)\n    RAYMARCH(rm2, eP+rd*FAR, -rd, iTime, NEAR, FAR-rm+1.0, mr)\n    \n    vec3 N = Nrm(eP+rd*rm, iTime, 0.0001);\n    vec2 pN = pack(N);\n    \n    // Output to screen\n    fragColor = vec4(rm, pN.y, rm2, pN.x);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"//\n// @author: Pierre-Marie Plans\nvec2 mainSound( in int samp, float t )\n{\n    float s = 0.0;\n    s += sin(0.4*t)*(sin(511.*t)\n                     +\n                     sin(714.*t))\n        +0.6*(\n            sin(527.47*t)\n            +sin(4.2831*440.0*t)*exp(-2.0*abs(sin(t)))\n        );\n    \n    s*=0.5;\n    return vec2( 0.25 * PATH2D(t) * s );\n}","name":"Sound","description":"","type":"sound"}]}