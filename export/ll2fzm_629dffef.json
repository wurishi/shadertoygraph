{"ver":"0.1","info":{"id":"ll2fzm","date":"1515187545","viewed":115,"name":"quadratic bezier single root","username":"dahart","description":"inspect the envelope of single real roots for the quadratic bezier cubic formula solver. use mouse to move the middle control point.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["bezier","quadratic","root","single"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n\nfloat det(vec2 a, vec2 b) { return a.x*b.y-b.x*a.y; }\n\nvec2 closestPointInSegment( vec2 a, vec2 b )\n{\n  vec2 ba = b - a;\n  return a + ba*clamp( -dot(a,ba)/dot(ba,ba), 0.0, 1.0 );\n}\n\n// From: http://research.microsoft.com/en-us/um/people/hoppe/ravg.pdf\nvec2 get_distance_vector(vec2 b0, vec2 b1, vec2 b2) {\n\t\n  float a=det(b0,b2), b=2.0*det(b1,b0), d=2.0*det(b2,b1); // ð›¼,ð›½,ð›¿(ð‘)\n  \n  if( abs(2.0*a+b+d) < 1000.0 ) return closestPointInSegment(b0,b2);\n\t\n  float f=b*d-a*a; // ð‘“(ð‘)\n  vec2 d21=b2-b1, d10=b1-b0, d20=b2-b0;\n  vec2 gf=2.0*(b*d21+d*d10+a*d20);\n  gf=vec2(gf.y,-gf.x); // âˆ‡ð‘“(ð‘)\n  vec2 pp=-f*gf/dot(gf,gf); // ð‘â€²\n  vec2 d0p=b0-pp; // ð‘â€² to origin\n  float ap=det(d0p,d20), bp=2.0*det(d10,d0p); // ð›¼,ð›½(ð‘â€²)\n  // (note that 2*ap+bp+dp=2*a+b+d=4*area(b0,b1,b2))\n  float t=clamp((ap+bp)/(2.0*a+b+d), 0.0 ,1.0); // ð‘¡Ì…\n  vec2 bb = mix(mix(b0,b1,t),mix(b1,b2,t),t);\n  return bb;\n}\n\nfloat approx_distance(vec2 p, vec2 b0, vec2 b1, vec2 b2) {\n  return length(get_distance_vector(b0-p, b1-p, b2-p));\n}\n\n#define dd(a) dot(a,a)\nfloat addv(vec2 a) { return a.x + a.y; }\n\n//Find roots using Cardano's method. http://en.wikipedia.org/wiki/Cubic_function#Cardano.27s_method\nvec2 solveCubic2(vec3 a, out float numRoots)\n{\n\tfloat p = (a.y-a.x*a.x/3.)/3.;\n\tfloat p3 = p*p*p;\n\tfloat q = a.x*(2.*a.x*a.x-9.*a.y)/27.+a.z;\n\tfloat d = q*q+4.*p3;\n\tif(d>.0)\n\t{\n\t\tvec2 x = (vec2(1,-1)*sqrt(d)-q)*.5;\n        numRoots = 1.;\n  \t\treturn vec2(addv(sign(x)*pow(abs(x),vec2(1./3.)))-a.x/3.);\n  \t}\n \tfloat v = acos(-sqrt(-1./p3)*q*.5)/3.;\n \tfloat m = cos(v);\n \tfloat n = sin(v)*1.732050808;\n    numRoots = 3.;\n\treturn vec2(m+m,-n-m)*sqrt(-p)-a.x/3.;\n}\n\n//Find roots using Cardano's method. http://en.wikipedia.org/wiki/Cubic_function#Cardano.27s_method\nvec2 solveCubic2a(vec3 a, out float numRoots)\n{\n\tfloat p = a.y-a.x*a.x/3.;\n\tfloat p3 = p*p*p;\n\tfloat q = a.x*(2.*a.x*a.x-9.*a.y)/27.+a.z;\n\tfloat d = q*q+4.*p3/27.;\n\tif(d>.0)\n\t{\n\t\tvec2 x = (vec2(1,-1)*sqrt(d)-q)*.5;\n        numRoots = 1.;\n  \t\treturn vec2(addv(sign(x)*pow(abs(x),vec2(1./3.)))-a.x/3.);\n  \t}\n//    float x = mod(-sqrt(-27./p3)*q*.5+1., 2.)-1.;\n    float x = -sqrt(-27./p3)*q*.5;\n \t//float v = acos(-sqrt(-27./p3)*q*.5)/3.;\n \t//float m = cos(v);\n \t//float n = sin(v)*1.732050808;\n    numRoots = 3.;\n\treturn vec2(2.*(sqrt((1.+x)/8.)+.5), -2.*(sqrt((1.-x)/8.)+.5))*sqrt(-p/3.)-a.x/3.;\n}\n\n// How to solve the equation below can be seen on this image.\n// http://www.perbloksgaard.dk/research/DistanceToQuadraticBezier.jpg\nfloat calculateDistanceToQuadraticBezier(vec2 p, vec2 a, vec2 b, vec2 c, out float numRoots)\n{\n\tb = mix(b+vec2(1e-4),b,abs(sign(b*2.-a-c)));\n\tvec2 A = b-a;\n\tvec2 B = c-b-A;\n\tvec2 C = p-a;\n\tvec2 D = A*2.;\n\tC = clamp((solveCubic2a( vec3(-3.*dot(A,B), dot(C,B)-2.*dd(A), dot(C,A))/-dd(B), numRoots )),0.,1.);\n\ta -= p;\n\treturn sqrt(min(dd((D+B*C.x)*C.x+a),dd((D+B*C.y)*C.y+a)));\n}\n\nfloat remap(float v, float min1, float max1, float min2, float max2) {\n    return min2 + (max2 - min2) * (v - min1) / (max1 - min1);\n}\n\nfloat aaFract(float x) {\n    float dx = 1. * length(fwidth(x));\n    float fx = fract(x), idx = 1. - dx;\n    return (fx < idx) ? fx : remap(fx, idx, 1., fx, 0.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 xy = fragCoord.xy;\n\t\n\tvec2 b0 = vec2(0.4, .5) * iResolution.xy;\n\t//vec2 b1 = vec2(0.5, .75 + .1*sin(iTime)) * iResolution.xy;\n\tvec2 b1 = iMouse.xy;\n\tvec2 b2 = vec2(.6, .5) * iResolution.xy;\n\tvec2 mid = .5*(b0+b2) + vec2(0.0,0.01);\n\t\n    float numRoots;\n\tfloat approx_d = approx_distance(xy, b0, b1, b2);\n    float exact_d = calculateDistanceToQuadraticBezier(xy, b0, b1, b2, numRoots);\n    \n    fragColor = vec4(float(numRoots == 1.), vec2(aaFract(exact_d/20.)), 1.);\n    return;\n    \n    /*\n    float safe_d = float(approx_d < exact_d);\n    float danger_d = 1. - safe_d;\n    \n    if (exact_d < 5.) fragColor = vec4(0.);\n    else {\n        fragColor = vec4(0.);\n        fragColor += danger_d * vec4(1., .1, .1, 1.);\n        fragColor += mod(exact_d/30.,1.) * vec4(.1, 1., .1, 1.);\n        fragColor += mod(approx_d/30.,1.) * vec4(.1, .3, 1., 1.);\n    }\n*/\n}","name":"Image","description":"","type":"image"}]}