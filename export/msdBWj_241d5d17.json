{"ver":"0.1","info":{"id":"msdBWj","date":"1700082940","viewed":24,"name":"Eye1","username":"Rugged","description":"If you move the camera up or down there's a significant fisheye effect. Anyone have a more stable direction per pixel formula to fix this?","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["eye"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sf3Rn","filepath":"/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","previewfilepath":"/media/ap/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3Rr","filepath":"/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","previewfilepath":"/media/ap/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define UP vec3(0., 0., 1.)\n#define FORWARD vec3(1., 0., 0.)\n#define LEFT vec3(1., 0., 0.)\n\nvec4 IrisColor(vec2 uvc){\n    \n    float ang = .1 * atan(uvc.x, uvc.y);\n    \n    \n    vec4 col = vec4(1.);\n    \n    float l = length(uvc);\n    \n    col = vec4(l * texture(iChannel0, vec2(ang)).r);\n    \n    float l2 = l * l;\n    \n    \n    //use desmos to see what this does\n    float f = 2. * (1. - l);\n    float g = 2. * l;\n    \n    col *= clamp(f * g, 0., 1.);\n    \n    \n    //color\n    //col *= 2. * vec4(.2, .5, 1., 1.);\n    col *= 2. * vec4(.6, .9, .1, 1.);\n\n    \n    //pupil\n    col *= mix(0., 1., smoothstep(.0, .1, l2));\n    \n    //noise 1 for offset of radial distance ring noise\n    float n0 = 2. * texture(iChannel0, .3 * vec2(ang)).r;\n    \n    //radial distance ring noise\n    float n = texture(iChannel0, .05 * vec2(l2 + n0)).r;\n    col *= mix(.3, 1., smoothstep(0., 1., n));\n    \n    return col;\n    \n    \n    \n    \n}\n\n\nvec4 eyeSDF(vec3 p, vec3 eyeC, vec3 eyeD){\n    \n    vec4 col = vec4(0.);\n    \n    vec3 pd = p - eyeC;\n    \n    float pL = length(pd);\n        \n        /*\n        if(abs(p.x) < .01 && abs(p.z) < .01){\n            col = vec4(0., p.y, 0., 0.);\n            break;\n        }\n        \n        if(abs(p.y) < .01 && abs(p.z) < .01){\n            col = vec4(p.x, 0., 0., 0.);\n            break;\n        }\n        \n        if(abs(p.x) < .01 && abs(p.y) < .01){\n            col = vec4(0., 0., p.z, 0.);\n            break;\n        }\n        */\n        \n        if(pL - 1. < .01){\n            \n            \n            vec3 N = normalize(pd);\n            \n            float dxN = dot(N, eyeD);\n            \n            \n            \n            //col = vec4(dot(N, vec3(-.57)));\n            \n           \n            vec2 uvc = (p - vec3(-1., 0., 0.)).yz;\n            uvc *= 3.;\n            \n            \n            \n            vec4 ic = IrisColor(uvc);\n            \n            \n            if(length(ic) * dot(p, vec3(-1., 0., 0.)) > 0.){\n                col = mix(ic, vec4(1.), .15);\n            }\n            else{\n                col = mix(vec4(.9), vec4(1., 0., 0., 0.),  pow(1. - texture(iChannel1, .01 * (uvc + 1.)).r, 8.));\n            }\n            \n            \n        }\n        \n        return col;\n}\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 uvc = 2. * (uv - .5);\n    \n    vec2 scale = iResolution.xy / iResolution.y;\n    \n    uv *= scale;\n    uvc *= scale;\n    \n    \n    \n    float uvcl = length(uvc);\n    \n    vec4 col = vec4(0.);\n    \n    \n    col = vec4(0.);//vec4(1. - uvcl, uvc.x, uvc.y, 0.) / 1.73205080757;\n    \n    \n    //sqrt(3.) = 1.73205080757\n    float zDepth = 2.5;\n    vec3 dv = normalize(vec3(zDepth, -uvc.x, uvc.y));\n    \n    mat3 rot;\n    rot[0] = vec3(cos(iTime), -sin(iTime), 0.);\n    rot[1] = vec3(sin(iTime), cos(iTime), 0.);\n    rot[2] = vec3(0., 0., 1.);\n\n    dv *= rot;\n    \n    //ray origins\n    vec3 p;\n    \n    \n    vec3 camD = vec3(cos(iTime), sin(iTime), 0.);\n    vec3 camC = -3. * vec3(cos(iTime), sin(iTime), 0.);\n    \n    //move camera relative up/down\n    camC.z = sin(iTime);\n    \n    //move camera relative right/left\n    //camC.xy += vec2(sin(iTime), -cos(iTime)) * sin(iTime);\n    \n    /*\n    \n    //center of the camera-image plane\n    vec3 imgPlaneCenter = camD + camC;\n    \n    //the right and up vectors of the image plane\n    vec3 imgRight = normalize(cross(camD, UP));\n    vec3 imgUp = normalize(cross(camD, imgRight));\n    \n    \n    \n    \n    \n    \n    vec3 hori = 2. * uvc.x * imgRight;\n    vec3 vert = 2. * -uvc.y * imgUp;\n    \n    p = imgPlaneCenter + hori + vert;\n    \n    \n    \n    //focal length and focal target\n    float focalLength = 100.;\n    vec3 focalTarget = imgPlaneCenter + (focalLength * camD);\n    \n    //direction of rays (direction from origin to focal target)\n    //dv = normalize(focalTarget - p);\n    */\n    \n    p = camC;\n    \n    for(int i = 0; i < 400; i++){\n        p += dv * .01;\n        \n        \n        vec4 c = eyeSDF(p, vec3(0.), vec3(-1., 0., 0.));\n        \n        if(c.x > 0.){\n            col = c;\n            break;\n        }\n        \n        \n        \n        \n    }\n    \n    \n    \n    \n    \n    fragColor = col;\n}","name":"Image","description":"","type":"image"}]}