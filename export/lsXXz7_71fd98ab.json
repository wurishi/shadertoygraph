{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[{"channel":0,"type":"video","id":"Xdf3Rn","filepath":"/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm","sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"}}],"code":"/*--------------------------------------------------------------\n * Shader Tiles: Tesselation of the coordinate space into \n * regular polygons. \n *\n * License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n *\n * https://www.shadertoy.com/user/TheVaporTrail\n * Contact: david (at) TheVaporTrail (dot) com\n * Projects: http://www.TheVaporTrail.com\n *\n * Supported tesselations: Square, Triangle, Hexagon, Octagon\n *\n * These routines work with the idea of a \"tile\", which describes\n * a regular polygon. A tile size is given as the radius of a \n * circle that encloses the polygon. The tile definition has the\n * radius, center, and number of sides. It also has a rotation,\n * direction, inner radius, \"horizontal angle\". (The horizontal\n * angle is the angle between the first vertex and horizontal.)\n *\n * Different tesselation \"styles\" are supported. A style describes\n * the orientations and directions of tiles:\n *   STYLE_MATCHING: All tiles have the same direction and same \n *     starting angle (except alternating triangles are rotated 180)\n *   STYLE_SEAMLESS: Triangles and squares are arranged so that all\n *     vertices 0 are together, vertices 1 are together, etc. The \n *     direction will therefore alternate in adjacent tiles.\n *\n * There are two sets of routines: locate routines and calc routines.\n * Locate routines find a tile given a coordinate and a tile size.\n * Calc routines calculate some piece of information given a tile\n * and a coordinate or other argument.\n *\n * Calc routines:\n *   Vertex \n *   Angle (of point in tile relative to horizontal)\n *   Edge vector\n *   Relative Position\n *   Relative Position UV (0.0<=x<=1.0, 0.0<=y<=1.0)\n *   Contains Point\n *   Distance to Edge\n *   Distance to Closest Edge\n *   Distance to Vertex\n *   Distance to Closest Vertex\n *\n *\n *\n *--------------------------------------------------------------*/\n\n#define DegreeToRad (3.14159/180.0)\n#define Tau (3.14159 * 2.0)\n#define cos30 (0.8660254) /* sqrt(3)/2 */\n\n#define TILE_TRI 0\n#define TILE_SQU 1\n#define TILE_HEX 2\n#define TILE_OCT 3\n\n#define STYLE_MATCHING 0\n#define STYLE_SEAMLESS 1\n\n#define TILE_MAX_SIDES 8\n\n/*--------------------------------------------------------------\n *\n *--------------------------------------------------------------*/\nstruct Tile_t\n{\n\tvec2  center;     // Center of the tile\n\tint   sides;      // Number of sides\n\tfloat len;        // Length of the side\n\tfloat radius;     // Radius to the vertex\n\tfloat inner;      // Radius to closest point on the edge\n\tfloat angle;      // Angle to first vertex\n\tfloat horzangle;  // Angle between canonical first vertex and horizontal \n\tint   direction;  // Rotation direction (+1 or -1)\n};\n\n/*--------------------------------------------------------------\n * Locate (Equilateral) Triangle Tile\n *\n * Canonical tile: vertex zero at 90 degrees, alternating tiles rotated 180 degrees\n *\n * Styles:\n *   MATCHING\n *   SEAMLESS\n *--------------------------------------------------------------*/\nTile_t tile_LocateTriangle(vec2 aCoord, int tileStyle, float radius)\n{\n\tTile_t t;\n\t\n\tfloat sideLen = radius * 2.0 * cos30;\n\t\n\t// Compute the size of a box to contain an equilateral triangle with a side of length=sideLen\n\tvec2 boxSize = vec2(sideLen, sideLen * cos30);\n\n\t// Determine if this is even or odd row. First convert the vertical location to a row number\n\t// Determine if it is an odd or even row\n\t// For odd rows, invert the triangle\n\t// -- This inverts the results when y<0 -- int row = int(aCoord.y/boxSize.y);\n\t// -- This inverts the results when y<0 -- bool evenRow = ((row - 2*(row/2)) == 0);\n\tfloat row = floor(aCoord.y/boxSize.y);\n\tbool evenRow = ((row - 2.0*floor(row/2.0)) < 0.01);\n\t\n\t// Compute the center of the triangle relative to the bottom-left corner of the box\n\t// Note that triangles are inverted for odd rows, so the center is shifted\n\tvec2 ctrAdjA = vec2(boxSize.x * 0.5, boxSize.y * (evenRow?1.0:2.0)/3.0);\n\tvec2 coordA  = aCoord.xy;\n\t// Find the box containing the coord, then compute the triangle center\n\tvec2 boxA    = floor(coordA/boxSize);\n\tvec2 ctrA    = boxA * boxSize + ctrAdjA;\n\t// Triangles are inverted on odd rows\n\tfloat angleA = evenRow ? 90.0 : 270.0;\n\tint   dirA   = 1;\n\t\n    if (tileStyle == STYLE_SEAMLESS)\n    {\n\t\tint idx = int(boxA.x - 3.0 * floor(boxA.x/3.0));\n\t\tdirA = evenRow ? 1 : -1;\n\t\tangleA = 330.0 - float(idx) * 120.0;\n\t\tif (!evenRow)\n\t\t\tangleA = -angleA;\n    }\n    \n    // Same as above, but we shift sideways by half a box\n    // and invert all of the triangles\n\tvec2 shiftB  = vec2(boxSize.x * 0.5, 0.0);\n\tvec2 ctrAdjB = vec2(boxSize.x * 0.5, boxSize.y * (evenRow?2.0:1.0)/3.0);\n\tvec2 coordB  = aCoord.xy + shiftB;\n\tvec2 boxB    = floor((coordB)/boxSize);\n\tvec2 ctrB    = boxB * boxSize - shiftB + ctrAdjB;\n\tfloat angleB = evenRow ? 270.0 : 90.0;\n\tint   dirB   = 1;\n\t\n    if (tileStyle == STYLE_SEAMLESS)\n    {\n\t\tint idx = int(boxB.x - 3.0 * floor((boxB.x)/3.0));\n\t\tdirB = evenRow ? -1 : 1;\n\t\tangleB = 150.0 + float(idx) * 120.0;\n\t\tif (!evenRow)\n\t\t\tangleB = -angleB;\n    }\n\t\n\tbool chooseA = (distance(aCoord, ctrA) < distance(aCoord, ctrB));\n\tvec2 ctr     = (chooseA) ? ctrA : ctrB;\n\tfloat angle  = (chooseA) ? angleA : angleB;\n    int   dir    = (chooseA) ? dirA : dirB;\n\n\tt.center    = ctr;\n\tt.len       = sideLen;\n\tt.sides     = 3;\n\tt.radius    = radius;\n\tt.inner     = sideLen/4.0;\n\tt.angle     = angle;\n\tt.horzangle = -90.0;\n\tt.direction = dir;\n\t\n\t\n\treturn t;\n}\n\n/*--------------------------------------------------------------\n *\n *--------------------------------------------------------------*/\nTile_t tile_LocateHexagon(vec2 aCoord, int tileStyle, float radius)\n{\n\tTile_t t;\n\t\n\tfloat sideLen = radius;\n\t\n\t// Compute the size of a box to contain hexagon with a side of length=sideLen\n\tvec2 boxSize = vec2(sideLen * 3.0, sideLen*cos30*2.0);\n\tfloat hexWidth = sideLen * 2.0;\n\n\t// Convert the vertical location to a row number\n\tfloat row = floor(aCoord.y/boxSize.y);\n\t\n\t// Determine if it is an odd or even row\n\t// For odd rows, invert the triangle\n\tbool evenRow = ((row - 2.0*floor(row/2.0)) < 0.01);\n\t\n\tvec2 ctrAdj = vec2(sideLen, sideLen * cos30);\n\t\n\tvec2 shiftA  = vec2(0.0);\n\tfloat angleA = 0.0;\n\tint   dirA   = evenRow ? 1 : -1;\n\tvec2 coordA  = aCoord.xy + shiftA;\n\tvec2 boxA    = floor(coordA/boxSize);\n\tvec2 ctrA    = boxA * boxSize - shiftA + ctrAdj;\n\tbool hasA    = (coordA.x - boxA.x * boxSize.x < hexWidth);\n\n\tvec2 shiftB  = vec2(sideLen + sideLen * 0.5, sideLen * cos30);\n\tfloat angleB = 0.0;\n\tint   dirB   = evenRow ? 1 : -1;\n\tvec2 coordB  = aCoord.xy + shiftB;\n\tvec2 boxB    = floor((coordB)/boxSize);\n\tvec2 ctrB    = boxB * boxSize - shiftB + ctrAdj;\n\tbool hasB    = (coordB.x - boxB.x * boxSize.x < hexWidth);\n\t\n\tbool chooseA = (!hasB || (hasA && distance(aCoord, ctrA) < distance(aCoord, ctrB)));\n\tvec2 ctr     = (chooseA) ? ctrA : ctrB;\n\tfloat angle  = (chooseA) ? angleA : angleB;\n    int   dir    = (chooseA) ? dirA : dirB;\n\n\tt.center    = ctr;\n\tt.len       = sideLen;\n\tt.sides     = 6;\n\tt.radius    = radius;\n\tt.inner     = sideLen/cos30;\n\tt.angle     = angle;\n\tt.horzangle = -30.0;\n\tt.direction = 1;\n\t\n\treturn t;\n}\n\n/*--------------------------------------------------------------\n *\n *--------------------------------------------------------------*/\nTile_t tile_LocateSquare(vec2 aCoord, int tileStyle, float radius)\n{\n\tTile_t t;\n\t\n\tfloat sideLen = radius*sqrt(2.0);\n\t\n\t// Compute the size of a box \n\tvec2 boxSize = vec2(sideLen, sideLen);\n\n\t// Convert the vertical location to a row number\n\tfloat row = floor(aCoord.y/boxSize.y);\n\t\n\t// Determine if it is an odd or even row\n\tbool evenRow = ((row - 2.0*floor(row/2.0)) < 0.01);\n\t\n\t\n\tfloat angle   = 45.0;\n\tvec2  coord   = aCoord.xy;\n\tvec2  box     = floor(coord/boxSize);\n\tvec2  ctr     = box * boxSize + boxSize/2.0;\n\n\tt.center    = ctr;\n\tt.len       = sideLen;\n\tt.sides     = 4;\n\tt.radius    = radius;\n\tt.inner     = sideLen/2.0;\n\tt.angle     = angle;\n\tt.horzangle = -45.0;\n\tt.direction = 1;\n\t\n\treturn t;\n}\n\n/*--------------------------------------------------------------\n *\n *--------------------------------------------------------------*/\nTile_t tile_LocateOctagon(vec2 aCoord, int tileStyle, float radius)\n{\n\tTile_t t;\n\t\n\tfloat sideLen = radius * 2.0 * sin(Tau/16.0);\n\tfloat inner   = radius * cos(Tau/16.0);\n\t\n\t// Compute the size of a box \n\tvec2 octBoxSize = vec2(inner * 2.0, inner * 2.0);\n\n\tfloat angle   = 360.0/16.0;\n\tvec2  coord   = aCoord.xy;\n\tvec2  box     = floor(coord/octBoxSize);\n\tvec2  ctrOct  = box * octBoxSize + octBoxSize/2.0;\n\n\t// Compute the size of the grid to locate the squares\n\t// The squares are rotated 45 degrees, so the \"width\" is measured across the diagonal..\n\tfloat squRadius   = sideLen / sqrt(2.0);\n\tvec2 squBoxSize   = vec2(squRadius * 2.0 + sideLen);\n\tvec2 shiftB  = vec2(sideLen + squRadius, sideLen + squRadius);\n\tvec2 coordB  = aCoord.xy - shiftB;\n\tvec2 boxB    = floor((coordB)/squBoxSize);\n\tvec2 ctrSqu  = boxB * squBoxSize + shiftB + vec2(squRadius);\n\t// We can use the fact that the sides of the square are diagonal lines with \n\t// slope=+1 or slope=-1 to determine if a point is in the square.\n\tvec2 relPt   = coordB - boxB * squBoxSize - vec2(squRadius);\n\tbool inSqu   = ((abs(relPt.x) + abs(relPt.y)) < squRadius);\n\t//bool hasSqu  = ((coordB.x - boxB.x * squBoxSize.x < squRadius * 2.0) && (coordB.y - boxB.y * squBoxSize.y < squRadius * 2.0));\n\n\tif (inSqu)\n\t{\n\t\tt.center    = ctrSqu;\n\t\tt.len       = sideLen;\n\t\tt.sides     = 4;\n\t\tt.radius    = squRadius;\n\t\tt.inner     = squRadius/sqrt(2.0);\n\t\tt.angle     = 0.0;\n\t\tt.horzangle = 0.0;\n\t\tt.direction = 1;\n\t}\n\telse\n\t{\n\t\tt.center    = ctrOct;\n\t\tt.len       = sideLen;\n\t\tt.sides     = 8;\n\t\tt.radius    = radius;\n\t\tt.inner     = inner;\n\t\tt.angle     = angle;\n\t\tt.horzangle = -360.0/16.0;\n\t\tt.direction = 1;\n\t}\n\t\n\treturn t;\n}\n\n/*--------------------------------------------------------------\n * Locate dispatch routine\n *--------------------------------------------------------------*/\nTile_t tile_Locate(vec2 aCoord, int tileType, int tileStyle, float radius)\n{\n\tTile_t t;\n\t\n\tif (tileType == TILE_TRI)\n\t\tt = tile_LocateTriangle(aCoord, tileStyle, radius);\n\telse if (tileType == TILE_SQU)\n\t\tt = tile_LocateSquare(aCoord, tileStyle, radius);\n\telse if (tileType == TILE_HEX)\n\t\tt = tile_LocateHexagon(aCoord, tileStyle, radius);\n\telse if (tileType == TILE_OCT)\n\t\tt = tile_LocateOctagon(aCoord, tileStyle, radius);\n\t\n\treturn t;\n}\n\n\n/*--------------------------------------------------------------\n *\n *--------------------------------------------------------------*/\nvec2 tile_CalcVertex(Tile_t tile, int vertexIdx)\n{\n\tvec2 pt;\n\tfloat angle;\n\t\n\tangle = DegreeToRad * (tile.angle + float(vertexIdx) * float(tile.direction) * 360.0 / float(tile.sides));\n\t\n\tpt.x = tile.center.x + tile.radius * cos(angle);\n\tpt.y = tile.center.y + tile.radius * sin(angle);\n\t\n\treturn pt;\n}\n\n/*--------------------------------------------------------------\n * Calculate the angle between two vectors, one from the center\n * to the coord and the other between the center and vertex zero\n *--------------------------------------------------------------*/\nfloat tile_CalcAngle(Tile_t tile, vec2 coord)\n{\n\tfloat angle = 0.0;\n\t\n\tangle = atan(coord.y - tile.center.y, coord.x - tile.center.x) / DegreeToRad;\n\t\n\tangle += tile.angle;\n\t\n\tangle *= float(tile.direction);\n\t\n\treturn angle;\n}\n\n/*--------------------------------------------------------------\n *\n *--------------------------------------------------------------*/\nvec2 tile_CalcEdgeVector(Tile_t tile, int vertexIdx)\n{\n\tvec2 vect;\n\t\n\treturn vect;\n}\n\n\n/*--------------------------------------------------------------\n * Calculate the position of a coordinate relative to vertex 0,\n * taking into consideration the direction of the tile.\n * The result is -radius<=x<=radius, -radius<=y<=radius\n *--------------------------------------------------------------*/\nvec2 tile_CalcRelPosition(Tile_t tile, vec2 coord, float twist)\n{\n\tvec2 relPos;\n\t\n\tfloat angle = -(tile.angle + tile.horzangle + twist * float(tile.direction)) *  DegreeToRad;\n\t\n\tfloat cA = cos(angle);\n\tfloat sA = sin(angle);\n\t\n\tmat2 rm = mat2(cA, sA, -sA, cA);\n\t\n\trelPos = coord - tile.center;\n\t\n\trelPos = rm * relPos;\n\t\n\tif (tile.direction == -1)\n\t\trelPos.x = -relPos.x;\n\treturn relPos;\n}\n\n\n/*--------------------------------------------------------------\n * Calculate the relative position, but return values appropriate\n * for a texture lookup.\n *--------------------------------------------------------------*/\nvec2 tile_CalcRelPositionUV(Tile_t tile, vec2 coord, float twist)\n{\n\tvec2 relPos = tile_CalcRelPosition(tile, coord, twist);\n\t\n\tvec2 uv = (relPos + vec2(tile.radius, tile.radius))/(tile.radius * 2.0);\n\t\n\treturn uv;\n}\n\n\n/*--------------------------------------------------------------\n *\n *--------------------------------------------------------------*/\nbool tile_ContainsPoint(Tile_t tile, vec2 coord)\n{\n\tbool contains = true;\n\t\n\treturn contains;\n}\n\n\n/*--------------------------------------------------------------\n * Calculate the distance to a specified edge\n *--------------------------------------------------------------*/\nfloat tile_CalcDistanceToEdge(Tile_t tile, int vertexIdx, vec2 coord)\n{\n\tfloat d;\n\t\n\tvec2 v1 = tile_CalcVertex(tile, vertexIdx);\n\tvec2 v2 = tile_CalcVertex(tile, vertexIdx+1);\n\t//vec2 edgeVec = edgeVector_Tile(tile, vertexIdx);\n\t\n\t// Calc distance to line\n\tvec2 vhat = vec2(v2.y - v1.y, v1.x - v2.x);\n\tvec2 r = v1 - coord;\n\t\n\td = abs(dot(vhat, r))/length(vhat);\n\t\n\treturn d;\n}\n\n/*--------------------------------------------------------------\n * Calculate the distance to the closest edge\n *--------------------------------------------------------------*/\nfloat tile_CalcDistanceToClosestEdge(Tile_t tile, vec2 coord)\n{\n\tfloat closest;\n\tfloat dist;\n\t\n\tclosest = tile_CalcDistanceToEdge(tile, 0, coord);\n\t\n\tfor (int i = 1; i < TILE_MAX_SIDES; i++)\n\t{\n\t\tif (i < tile.sides)\n\t\t{\n\t\t\tdist = tile_CalcDistanceToEdge(tile, i, coord);\n\t\t\tif (dist < closest)\n\t\t\t\tclosest = dist;\n\t\t}\n\t}\n\t\n\treturn closest;\n}\n\n\n/*--------------------------------------------------------------\n *\n *--------------------------------------------------------------*/\nfloat tile_CalcDistanceToVertex(Tile_t tile, int vertexIdx, vec2 coord)\n{\n\tvec2 pt = tile_CalcVertex(tile, vertexIdx);\n\n\treturn distance(coord, pt);\n}\n\n/*--------------------------------------------------------------\n *\n *--------------------------------------------------------------*/\nfloat tile_CalcDistanceToClosestVertex(Tile_t tile, vec2 coord)\n{\n\tfloat closest;\n\tfloat dist;\n\t\n\tclosest = tile_CalcDistanceToVertex(tile, 0, coord);\n\t\n\t\n\tfor (int i = 1; i < TILE_MAX_SIDES; i++)\n\t{\n\t\tif (i < tile.sides)\n\t\t{\n\t\t\tdist = tile_CalcDistanceToVertex(tile, i, coord);\n\t\t\tif (dist < closest)\n\t\t\t\tclosest = dist;\n\t\t\t\t\t\n\t\t}\n\t}\n\t\n\treturn closest;\n}\n\n/*--------------------------------------------------------------\n *\n *--------------------------------------------------------------*/\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t// x position determines size\n\tfloat size = 30.0 + iMouse.x/iResolution.x * 100.0;\n\t\n\t// Locate a tile\n\tTile_t tile = tile_Locate(fragCoord.xy, TILE_TRI, STYLE_SEAMLESS, size);\t\n\n\t// Convert coordinate to a relative position in the tile\n\tvec2 uv = tile_CalcRelPositionUV(tile, fragCoord.xy, 0.0);\n\t\n\t// Texture look-up\n\tfragColor = texture(iChannel0, uv);\n}\n","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"lsXXz7","date":"1398385092","viewed":750,"name":"Kaleidoscope Video","username":"TheVaporTrail","description":"Tiling a surface with seamless video texture. iMouse.x changes tile size.\nSee http://www.TheVaporTrail.com for some documentation\n","likes":14,"published":1,"flags":0,"usePreview":0,"tags":["2d","tessellation"],"hasliked":0,"parentid":"","parentname":""}}