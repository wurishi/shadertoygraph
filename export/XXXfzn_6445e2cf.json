{"ver":"0.1","info":{"id":"XXXfzn","date":"1727908692","viewed":31,"name":"Masked Voronoi","username":"keir","description":"Masked area of voronoi that revels whole cells, rather than clipping them off. Mouse drives the size of the mask.\nBased on https://www.shadertoy.com/view/MslGD8","likes":1,"published":1,"flags":32,"usePreview":0,"tags":["2d","voronoi"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// The MIT License\n// Copyright © 2013 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n// https://www.youtube.com/c/InigoQuilez\n// https://iquilezles.org/\n\n// Based on https://www.shadertoy.com/view/MslGD8\n\n\n\n// The MIT License\n// Copyright © 2018 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Distance to a quadratic bezier segment, which can be solved analyically with a cubic.\n\n// List of some other 2D distances: https://www.shadertoy.com/playlist/MXdSRf\n//\n// and iquilezles.org/articles/distfunctions2d\n\n\n\n\n\nfloat dot2( vec2 v ) { return dot(v,v); }\nfloat cro( vec2 a, vec2 b ) { return a.x*b.y-a.y*b.x; }\nfloat cos_acos_3( float x ) { x=sqrt(0.5+0.5*x); return x*(x*(x*(x*-0.008972+0.039071)-0.107074)+0.576975)+0.5; } // https://www.shadertoy.com/view/WltSD7\n\n\n\nfloat sdBezier( in vec2 pos, in vec2 A, in vec2 B, in vec2 C, out vec2 outQ )\n{    \n    vec2 a = B - A;\n    vec2 b = A - 2.0*B + C;\n    vec2 c = a * 2.0;\n    vec2 d = A - pos;\n\n    // cubic to be solved (kx*=3 and ky*=3)\n    float kk = 1.0/dot(b,b);\n    float kx = kk * dot(a,b);\n    float ky = kk * (2.0*dot(a,a)+dot(d,b))/3.0;\n    float kz = kk * dot(d,a);      \n\n    float res = 0.0;\n    float sgn = 0.0;\n\n    float p  = ky - kx*kx;\n    float q  = kx*(2.0*kx*kx - 3.0*ky) + kz;\n    float p3 = p*p*p;\n    float q2 = q*q;\n    float h  = q2 + 4.0*p3;\n\n\n    if( h>=0.0 ) \n    {   // 1 root\n        h = sqrt(h);\n        vec2 x = (vec2(h,-h)-q)/2.0;\n\n        #if 0\n        // When p≈0 and p<0, h-q has catastrophic cancelation. So, we do\n        // h=√(q²+4p³)=q·√(1+4p³/q²)=q·√(1+w) instead. Now we approximate\n        // √ by a linear Taylor expansion into h≈q(1+½w) so that the q's\n        // cancel each other in h-q. Expanding and simplifying further we\n        // get x=vec2(p³/q,-p³/q-q). And using a second degree Taylor\n        // expansion instead: x=vec2(k,-k-q) with k=(1-p³/q²)·p³/q\n        if( abs(p)<0.001 )\n        {\n            float k = p3/q;              // linear approx\n          //float k = (1.0-p3/q2)*p3/q;  // quadratic approx \n            x = vec2(k,-k-q);  \n        }\n        #endif\n\n        vec2 uv = sign(x)*pow(abs(x), vec2(1.0/3.0));\n        float t = uv.x + uv.y;\n\n\t\t// from NinjaKoala - single newton iteration to account for cancellation\n        t -= (t*(t*t+3.0*p)+q)/(3.0*t*t+3.0*p);\n        \n        t = clamp( t-kx, 0.0, 1.0 );\n        vec2  w = d+(c+b*t)*t;\n        outQ = w + pos;\n        res = dot2(w);\n    \tsgn = cro(c+2.0*b*t,w);\n    }\n    else \n    {   // 3 roots\n        float z = sqrt(-p);\n        #if 0\n        float v = acos(q/(p*z*2.0))/3.0;\n        float m = cos(v);\n        float n = sin(v);\n        #else\n        float m = cos_acos_3( q/(p*z*2.0) );\n        float n = sqrt(1.0-m*m);\n        #endif\n        n *= sqrt(3.0);\n        vec3  t = clamp( vec3(m+m,-n-m,n-m)*z-kx, 0.0, 1.0 );\n        vec2  qx=d+(c+b*t.x)*t.x; float dx=dot2(qx), sx=cro(a+b*t.x,qx);\n        vec2  qy=d+(c+b*t.y)*t.y; float dy=dot2(qy), sy=cro(a+b*t.y,qy);\n        if( dx<dy ) {res=dx;sgn=sx;outQ=qx+pos;} else {res=dy;sgn=sy;outQ=qy+pos;}\n    }\n    \n    return sqrt( res )*sign(sgn);\n}\n\nfloat udSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n\tvec2 pa = p - a;\n\tvec2 ba = b - a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h );\n}\n\n\nfloat mountain_symbol(vec2 p, vec2 noise){\n    p.x = abs(p.x);\n    \n\tvec2 v0 = vec2(0.0,0.5);\n    vec2 v1 = vec2(0.3,-0.2);\n    vec2 v2 = vec2(1.0,-0.6);\n    \n    \n    float scale = 0.3;\n    \n    v0.y += noise.y * scale;\n    v1 += noise * scale;\n    v2 += noise * scale;\n    \n    vec2 kk;\n    float d = sdBezier( p, v0,v1,v2, kk );\n    return d;\n}\n\nvec2 hash( vec2 p )\n{\n    //p = mod(p, 4.0); // tile\n    p = vec2(dot(p,vec2(127.1,311.7)),\n             dot(p,vec2(269.5,183.3)));\n    return fract(sin(p)*18.5453);\n}\n\n\n\nvec3 rgb(float r, float g, float b) {\n\treturn vec3(r / 255.0, g / 255.0, b / 255.0);\n}\n\nvec4 getTexture(vec2 uv){\n    vec4 textureSample = texture(iChannel0, uv);\n\treturn textureSample;\n}\n\n\nvec4 saturate(vec4 value)\n{\n    return clamp(vec4(0.0), vec4(1.0), value);\n}\n\nfloat saturate(float value)\n{\n    return clamp(float(0.0), float(1.0), value);\n}\n\n// return distance, and cell id\nvec4 voronoi( in vec2 p, out vec2 cell, out vec2 cell_uv, out vec2 cell_centeric_uv, float grid_to_voronoi )\n{\n    // float grid_to_voronoi = 0.0;  // 0 is grid, 1 is voronoi\n    float cell_density = (14.0+6.0*sin(0.2*1.0)) * .5;\n    \n    vec4 line_color = vec4(0.0,0.0,0.0,1.0);\n    \n    \n    vec2 x = cell_density * p;\n    vec2 n = floor( x );\n    vec2 f = fract( x );\n    \n    cell_uv = x;\n    vec4 color;\n    vec2 o_center;\n\n\n    float float_max = 3.402823466e+38F;\n    float float_min = -3.402823466e+38F;\n\n    float graphic_line_d = float_max; // big number. Should really be float max\n    vec2 graphic_mask_d = vec2(float_max, float_max);\n\n\tvec3 m = vec3( 8.0 );\n    for( int j=-1; j<=1; j++ )\n    for( int i=-1; i<=1; i++ )\n    {\n        vec2  g = vec2( float(i), float(j) );\n        vec2  o = hash( n + g ) * grid_to_voronoi;\n        vec2  r = g - f + o;\n\t    float d = dot( r, r );\n        if( d < m.x ){\n            m = vec3( d, o );\n            cell_uv = (n + g);\n            cell_centeric_uv = r;\n            o_center = o;            \n        }\n        \n        float symbol = mountain_symbol(r * -2.5, o);\n        \n        // graphic_line_d = min(graphic_line_d, abs(symbol));\n        // graphic_mask_d.x = min(graphic_mask_d.x, symbol);\n        graphic_line_d += symbol;\n        \n    }\n\n    cell = vec2( sqrt(m.x), m.y+m.z);\n    cell_uv = cell_uv / cell_density;\n    \n    // cell_centeric_uv = (cell_centeric_uv + 1.0) / 2.0; // Aligh bottom left of cell\n    cell_centeric_uv = -1.0 * (cell_centeric_uv);\n    \n    float symbol = mountain_symbol(cell_centeric_uv * 2.5, o_center);\n    // color = (d>0.0) ? vec4(0.9,0.6,0.3, 1.0) : vec4(0.65,0.85,1.0, 1.0);\n    // float d = graphic_d;\n    // color = vec4(d,d,d,1.0);\n    // d = smoothstep(0.0, 0.1, d);    \n    // color = vec4(d,d,d,1.0 - d);\n    \n    \n    \n    // Center icon only\n    symbol = graphic_line_d;\n    // color = (graphic_mask_d>0.0) ? vec4(0.9,0.6,0.3, 1.0) : vec4(0.65,0.85,1.0, 0.0);\n    \n    // symbol = graphic_mask_d.x > 0.0 ? 0.0 : symbol;\n    \n    \n    // color = mix( color, line_color, 1.0 - smoothstep(0.0,0.15,symbol));\n    \n    // color = saturate(vec4(graphic_mask_d.x, graphic_mask_d.x, graphic_mask_d.x, 1.0));\n    \n    \n    color = vec4(symbol, symbol, symbol, 1.0);\n    \n    // float bit = graphic_mask_d.x > 0.0 ? 1.0 : 0.0;\n    // color = vec4(bit, bit, bit, 1.0);\n    \n    \n    return color;\n    \n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{      \n\n    // uv from -1. to 1. (times 2) instead of 0. to 1.\n    // and shifted to center (minus 1)\n    vec2 uv = fragCoord / iResolution.xy * 2. - 1.;\n    \n    // correct ratio of x axis\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 p = uv;\n        \n    float mouse_radius = mix(0.5, 5.0, iMouse.x / iResolution.x);\n    float mouse_noise = mix(0.0, 1.0, iMouse.y / iResolution.y);\n    \n    // Background layer\n\tvec4 layer1 = vec4(rgb(210.0, 222.0, 228.0), 1.0);\n    \n    \n   \n    \n    // computer voronoi patterm\n    vec2 cell;\n    vec2 cell_uv;\n    vec2 cell_centeric_uv;\n    vec4 col = voronoi( p, cell, cell_uv, cell_centeric_uv, mouse_noise);\n    \n    // fragColor = vec4(cell, 0.0, 1.0); return;\n    // fragColor = vec4(cell_uv, 0.0, 1.0); return;\n    // fragColor = vec4(cell_centeric_uv, 0.0, 1.0); return;\n    // fragColor = col; return;\n    \n    // fragColor = mix(layer1, col, col.a);\n    // return;\n    \n        \n    // Circle mask\n    float rad = 0.16 * mouse_radius;\n    vec2 pos = vec2(0, 0);\n    float c_mask = length(pos - cell_uv) - rad;\n    float mask = (1.0-smoothstep( 0.08, 0.081, c_mask));\n    \n    \n    vec4 layer3 = col;\n    layer3.a = min(layer3.a, mask);\n    \n    fragColor = mix(layer1, layer3, layer3.a);\n    \n    // fragColor = vec4(getTexture(uv.xy).rgb, 1.0);\n    // fragColor = vec4(p.xy, 0.0, 1.0);\n    \n    // fragColor = vec4(cell_uv, 0.0, 1.0); // Show cell UV\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"/**\n * @author jonobr1 / http://jonobr1.com/\n */\n\n/**\n * Convert r, g, b to normalized vec3\n */\nvec3 rgb(float r, float g, float b) {\n\treturn vec3(r / 255.0, g / 255.0, b / 255.0);\n}\n\nfloat circle(vec2 uv, float radius)\n{\n\treturn dot(uv, uv) - radius;   \n}\n\n\nfloat dot2( vec2 v ) { return dot(v,v); }\nfloat cro( vec2 a, vec2 b ) { return a.x*b.y-a.y*b.x; }\nfloat cos_acos_3( float x ) { x=sqrt(0.5+0.5*x); return x*(x*(x*(x*-0.008972+0.039071)-0.107074)+0.576975)+0.5; } // https://www.shadertoy.com/view/WltSD7\n\nfloat sdBezier( in vec2 pos, in vec2 A, in vec2 B, in vec2 C )\n{    \n    vec2 a = B - A;\n    vec2 b = A - 2.0*B + C;\n    vec2 c = a * 2.0;\n    vec2 d = A - pos;\n    float kk = 1.0/dot(b,b);\n    float kx = kk * dot(a,b);\n    float ky = kk * (2.0*dot(a,a)+dot(d,b)) / 3.0;\n    float kz = kk * dot(d,a);      \n    float res = 0.0;\n    float p = ky - kx*kx;\n    float p3 = p*p*p;\n    float q = kx*(2.0*kx*kx-3.0*ky) + kz;\n    float h = q*q + 4.0*p3;\n    if( h >= 0.0) \n    { \n        h = sqrt(h);\n        vec2 x = (vec2(h,-h)-q)/2.0;\n        vec2 uv = sign(x)*pow(abs(x), vec2(1.0/3.0));\n        float t = clamp( uv.x+uv.y-kx, 0.0, 1.0 );\n        res = dot2(d + (c + b*t)*t);\n    }\n    else\n    {\n        float z = sqrt(-p);\n        float v = acos( q/(p*z*2.0) ) / 3.0;\n        float m = cos(v);\n        float n = sin(v)*1.732050808;\n        vec3  t = clamp(vec3(m+m,-n-m,n-m)*z-kx,0.0,1.0);\n        res = min( dot2(d+(c+b*t.x)*t.x),\n                   dot2(d+(c+b*t.y)*t.y) );\n        // the third root cannot be the closest\n        // res = min(res,dot2(d+(c+b*t.z)*t.z));\n    }\n    return sqrt( res );\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // uv from -1. to 1. (times 2) instead of 0. to 1.\n    // and shifted to center (minus 1)\n    vec2 uv = fragCoord / iResolution.xy;\n    uv-= -0.5;\n    // fragColor = vec4(uv,0.0,1.0);\n    // return;\n\n\n    // Background layer\n\tvec4 layer1 = vec4(rgb(210.0, 222.0, 228.0), 0.0);\n\t\n\n    // Circle\n\tvec3 red = rgb(225.0, 95.0, 60.0);\n\n    vec4 circle = vec4(red.rgb, 0.);\n    if (abs(dot2(uv)) < .4)\n        circle.a = 1.0;\n    \n\tfragColor = circle;\n    \n    fragColor = vec4(uv,0.0,1.0);\n    fragColor = vec4(uv,0.0,1.0);\n    // fragColor = vec4(dot2(uv),0.0,0.0,1.0);\n    // fragColor = vec4(abs(length(uv)) *2.,0.0,0.0,1.0);\n    \n}","name":"Buffer A","description":"","type":"buffer"}]}