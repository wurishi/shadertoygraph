{"ver":"0.1","info":{"id":"wlsczS","date":"1592506174","viewed":158,"name":"TextureCube","username":"Helliaca","description":"uv mapped texture on cube","likes":1,"published":1,"flags":32,"usePreview":0,"tags":["texture"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Constants #######################################################################\n\nconst vec3 cameraPos = vec3(0.0, 0.0, 0.0);\t// Position of the camera in world space\nconst vec3 viewPlane = cameraPos + vec3(0.0, 0.0, 1.0);\t// Position of the view-plane in world space (point that camera is looking at)\n\n#define noHit Hit(false, vec3(0.0), vec3(0.0), vec3(0.0))\n#define eps 0.000001\n\n\n// Structs #########################################################################\n\nstruct Ray {\n    vec3 origin;\n    vec3 dir;\n};\n    \nstruct Light {\n    vec3 pos;\n    vec3 color;\n};\n    \nstruct Tri {\n    vec3 v0;\t\t// Vertices of the triangle\n    vec3 v1;\n    vec3 v2;\n    vec2 uv0;\t\t// UV texture coords of each vertex\n    vec2 uv1;\n    vec2 uv2;\n    bool usebuf1;\t// If true, use iChannel0 as texture, otherwise iChannel1\n};\n    \nstruct Hit {\n    bool hit;\n    vec3 pos;\n    vec3 nrm;\n    vec3 uvw;\t\t// Barycentric coordinates of the hit position inside of the hit triangle\n};\n    \n\n// Scene Objects ####################################################################\n\n// Cube:\nvec3 cube_position = vec3(0.0, 0.0, -4.0);\nTri cube[] = Tri[](\n    //Front face\n    Tri(vec3(-1, -1, -1), vec3(1, -1, -1), vec3(1, 1, -1), vec2(0, 0), vec2(1, 0), vec2(1, 1), false),\n    Tri(vec3(-1, -1, -1), vec3(1, 1, -1), vec3(-1, 1, -1), vec2(0, 0), vec2(1, 1), vec2(0, 1), false),\n    //Left face\n    Tri(vec3(-1, -1, -1), vec3(-1, -1, 1), vec3(-1, 1, 1), vec2(0, 0), vec2(1, 0), vec2(1, 1), false),\n    Tri(vec3(-1, -1, -1), vec3(-1, 1, 1), vec3(-1, 1, -1), vec2(0, 0), vec2(1, 1), vec2(0, 1), false),\n    //Right face\n    Tri(vec3(1, -1, -1), vec3(1, -1, 1), vec3(1, 1, 1), vec2(0, 0), vec2(1, 0), vec2(1, 1), false),\n    Tri(vec3(1, -1, -1), vec3(1, 1, 1), vec3(1, 1, -1), vec2(0, 0), vec2(1, 1), vec2(0, 1), false),\n    //Back face\n    Tri(vec3(-1, -1, 1), vec3(1, -1, 1), vec3(1, 1, 1), vec2(0, 0), vec2(1, 0), vec2(1, 1), true),\n    Tri(vec3(-1, -1, 1), vec3(1, 1, 1), vec3(-1, 1, 1), vec2(0, 0), vec2(1, 1), vec2(0, 1), true),\n    //Top face\n    Tri(vec3(-1, 1, -1), vec3(1, 1, -1), vec3(1, 1, 1), vec2(0, 0), vec2(1, 0), vec2(1, 1), true),\n    Tri(vec3(-1, 1, -1), vec3(1, 1, 1), vec3(-1, 1, 1), vec2(0, 0), vec2(1, 1), vec2(0, 1), true),\n    //Bottom face\n    Tri(vec3(-1, -1, -1), vec3(1, -1, -1), vec3(1, -1, 1), vec2(0, 0), vec2(1, 0), vec2(1, 1), true),\n    Tri(vec3(-1, -1, -1), vec3(1, -1, 1), vec3(-1, -1, 1), vec2(0, 0), vec2(1, 1), vec2(0, 1), true)\n);\n\n// Background walls:\nTri walls[] = Tri[](\n    //Left Wall\n    Tri(vec3(-3.3, -10.0, 0.0), vec3(-3.3, -10.0, -100.0), vec3(-3.3, 10.0, -100.0), vec2(0.0), vec2(0.0), vec2(0.0), false),\n    Tri(vec3(-3.3, -10.0, 0.0), vec3(-3.3, 10.0, -100.0), vec3(-3.3, 10.0, 0.0), vec2(0.0), vec2(0.0), vec2(0.0), false),\n    //Right Wall\n    Tri(vec3(3.3, -10.0, 0.0), vec3(3.3, -10.0, -100.0), vec3(3.3, 10.0, -100.0), vec2(0.0), vec2(0.0), vec2(0.0), false),\n    Tri(vec3(3.3, -10.0, 0.0), vec3(3.3, 10.0, -100.0), vec3(3.3, 10.0, 0.0), vec2(0.0), vec2(0.0), vec2(0.0), false),\n    // Floor\n    Tri(vec3(-3.3, -3.0, 0.0), vec3(3.3, -3.0, 0.0), vec3(3.3, -3.0, -100.0), vec2(0.0), vec2(0.0), vec2(0.0), false),\n    Tri(vec3(-3.3, -3.0, 0.0), vec3(-3.3, -3.0, -100.0), vec3(3.3, -3.0, -100.0), vec2(0.0), vec2(0.0), vec2(0.0), false)\n);\n\n// Lights:\nLight lights[] = Light[](\n    Light(vec3(0.0, 0.0, -1.0), vec3(1.0, 1.0, 1.0)),\n    Light(vec3(-3.0, -1.0, -2.0), vec3(1.0, 0.0, 0.0)),\n    Light(vec3(3.0, 1.0, -2.0), vec3(0.0, 0.8, 0.0))\n);\n\n// Returns true if a ray intersects a plane. Writes intersection position into ipos\nbool RayPlaneIntersect(Ray ray, vec3 normal, vec3 planePos, out vec3 ipos) {\n    // Plane is parallel to ray: (remove abs (and optionally invert normal) for face culling)\n    if(abs(dot(normal, ray.dir)) < eps) return false;\n    \n    float t = (dot(normal, ray.origin) + dot(normal, planePos)) / dot(normal, ray.dir);\n    if(t<0.0) return false; // Plane is behind ray\n        \n    ipos = ray.origin + t*ray.dir; // Intersection point position\n    return true;\n}\n\n// Conducts orientation test within a Plane of specified normal vector\n// Returns true if p lies to the left of l1_l2 (inside of specified plane) otherwise false.\nbool OrientationTest3d(vec3 l1, vec3 l2, vec3 p, vec3 planeNormal, out float b) {\n    vec3 edge = l2 - l1;\t\t\t\t\t// Edge: origin to end\n    vec3 l1_p = p - l1;\t\t\t\t\t\t// Edge: origin to point\n    b = dot(planeNormal, cross(edge, l1_p));// If the normal vector of the plane\n\t//and cross of the two previous vectors are < 0, they point in opposite directions -> p lies to the right of l1_l2\n    return b > 0.0;\n}\n\n// Performs ray-triangle intersection. Returns Hit type\nHit rayTriIntersect(Ray ray, Tri tri) {\n    // Get normal vector of triangle (not normalized)\n    vec3 normal = cross(\n        tri.v1 - tri.v0,\n        tri.v2 - tri.v0\n    );\n    \n    float denom = dot(normal, normal);\n    \n    // Get intersection point with triangle-plane\n    vec3 p = vec3(0.0);\n    if(!RayPlaneIntersect(ray, normal, tri.v0, p)) return noHit;\n    \n    \n    // Check if p is inside or outside of specified triangle\n    float u, v, w;\n    \n    if(!OrientationTest3d(tri.v0, tri.v1, p, normal, w)) return noHit;\n    if(!OrientationTest3d(tri.v1, tri.v2, p, normal, u)) return noHit;\n    if(!OrientationTest3d(tri.v2, tri.v0, p, normal, v)) return noHit;\n    \n    // Normalize for barycentric coordinates\n    u/=denom;\n    v/=denom;\n    w/=denom;\n    \n    return Hit(true, p, normalize(normal), vec3(u, v, (1.0-u-v)));\n}\n\n// Returns a ray through any given fragment coordinate of a virtual camera\nRay cameraRay(vec2 fragCoord) {\n    // Viewplane x-Axis is cross product of global up-Vector and camera forward vector\n    vec3 xvec = normalize(cross(vec3(0.0, 1.0, 0.0), cameraPos-viewPlane));\n    // Viewplane y-Axis is cross product of viewplane x-Axis and camera forward vector\n    vec3 yvec = normalize(cross(xvec, cameraPos-viewPlane));\n    \n    vec2 uv = fragCoord/iResolution.xy; \t// Normalized screen coordiantes [0, 1]\n    uv -= 0.5;\t\t\t\t\t\t\t\t// Screen coordiantes centered [0,1] -> [-0.5, 0.5]\t\n    uv.x *= iResolution.x / iResolution.y; \t// Apply aspect ration of resolution\n    \n    // Get virtual pixel position on virtual screen at viewPlane in world space\n    vec3 vpp = viewPlane + xvec*uv.x + yvec*uv.y;\n    // This gives us the desired ray direction\n    vec3 rayDir = cameraPos - vpp;\n    \n    return Ray(cameraPos, rayDir);\n}\n\n// Rotates a vertex around (1,1,0) axis by iTime rad\nvec3 rotate(vec3 v) {\n    mat3 m = mat3(\n        cos(iTime), 0, -sin(iTime),\n        0, 1, 0,\n        sin(iTime), 0, cos(iTime)\n    ) * mat3(\n        1, 0, 0,\n        0, cos(-iTime), sin(-iTime),\n        0, -sin(-iTime), cos(-iTime)\n    );\n\treturn m*v;\n}\n\n// Rudimentary Phong shading\nvec3 phong(vec3 pos, vec3 nrm, vec3 base_color, Light light) {\n    // Ambient\n    vec3 ambient = 0.01 * base_color * light.color;\t\t\t// ambient color\n  \t\n    // Diffuse\n    vec3 lightDir = normalize(light.pos - pos);\t\t\t\t// Direction of lightsource\n    float diff = abs(dot(nrm, lightDir));\t\t\t\t\t// diffuse factor. We use absolute for 2-sided normals\n    vec3 diffuse = 1.0 * diff * light.color;\t\t\t\t// diffuse color\n\n    // Glossy\n    vec3 viewDir = normalize(cameraPos - pos);\t\t\t\t// View direction\n    vec3 reflectDir = reflect(-lightDir, nrm); \t\t\t\t// Perfect reflectance direction \n    float spec = pow(max(dot(reflectDir, viewDir), 0.0), 32.0); // specular factor. constant shininess of 32\n    vec3 specular = 1.0 * spec * light.color;  // Specular color\n\n    // Attenuation (Const. Lin. Quadratic)\n    float dist = length(light.pos - pos);\n    float attenuation = 1.0f / (0.0 + 0.4 * dist + 0.5 * (dist * dist));\n    \n    // Final result\n    return (ambient + diffuse + specular) * base_color * attenuation;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Rotate the vertex positions over time\n    for(int i=0; i<cube.length(); i++) {\n        cube[i].v0 = cube_position + rotate(cube[i].v0);\n        cube[i].v1 = cube_position + rotate(cube[i].v1);\n        cube[i].v2 = cube_position + rotate(cube[i].v2);\n    }\n    \n    // Get current camera ray\n    Ray ray = cameraRay(fragCoord);\n    \n    vec3 col = vec3(0.0);\n    float closest = 999.0;\n    Hit near;\n    vec3 base_color;\n    \n    // Intersect with all triangles, keep the nearest intersection point\n    for(int i=0; i<cube.length(); i++) {\n        Hit h = rayTriIntersect(ray, cube[i]);\n        if(h.hit && length(h.pos-ray.origin)<closest) {\n            closest = length(h.pos-ray.origin);\n            near = h;\n            vec2 texLoc = cube[i].uv0 * h.uvw.x + cube[i].uv1 * h.uvw.y + cube[i].uv2 * h.uvw.z;\n            \n            if(cube[i].usebuf1) base_color = texture(iChannel0, texLoc).rgb;\n        \telse base_color = texture(iChannel1, texLoc).rgb;\n    \t}\n    }\n    \n    // Do the same for the background walls, but ignore textures\n    for(int i=0; i<walls.length(); i++) {\n        Hit h = rayTriIntersect(ray, walls[i]);\n        if(h.hit && length(h.pos-ray.origin)<closest) {\n            closest = length(h.pos-ray.origin);\n            near = h;\n            base_color = vec3(1.0, 1.0, 1.0);\n    \t}\n    }\n    \n    // Perform phong shading on the nearest hit\n    for(int i=0; i<lights.length(); i++) {\n        col += phong(near.pos, near.nrm, base_color, lights[i]);\n    }\n    \n    fragColor = vec4(col.rgb, 1.);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//Checkers pattern texture\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv = mod(uv*2.0, 1.0);\t// scale of 2.0 -> 4 squares per axis\n    \n    vec3 col = vec3(1.0,1.0,1.0); // default color of black\n    \n    if (uv.x>0.5 ^^ uv.y>0.5) col = vec3(0.0,0.0,0.0); //set white squares with xor operator ^^\n\n    fragColor = vec4(col,1.0);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[{"id":"XsXGR8","channel":0}],"code":"//Dice 6 Texture\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 col = vec3(0.0);\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 ouv = fragCoord/iResolution.xy;\n    \n    // grid of 3x3\n    vec2 uv;\n    uv.y = mod(ouv.y*3.0, 1.0);\n    uv.x = mod(ouv.x*3.0, 1.0);\n    \n    // If we arent in [0.33, 0.66] on the 'original' x axis, draw a circle in this cell\n    if(!(ouv.x>0.33 && ouv.x<0.66) && distance(vec2(0.5, 0.5), uv) < 0.4) col = vec3(1.0);\n    \n    fragColor = vec4(col, 1.0);\n}","name":"Buffer B","description":"","type":"buffer"}]}