{"ver":"0.1","info":{"id":"tl3SzM","date":"1666269525","viewed":160,"name":"PULSAR ","username":"gaz","description":"https://www.youtube.com/watch?v=7T1llQSMj-o&app=desktop","likes":19,"published":1,"flags":32,"usePreview":0,"tags":["video"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage(out vec4 fragColor,in vec2 fragCoord){\n    vec2 uv=fragCoord/iResolution.xy;\n\tfragColor=textureLod(iChannel0,uv,0.0);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define ZERO min(iFrame, 0)\n#define PI acos(-1.0)\n#define PIH PI*0.5\n#define TAU PI*2.0\n\nmat2 rot(float a)\n{\n    float s=sin(a),c=cos(a);\n    return mat2(c,s,-s,c);\n}\n\nmat3 rotX(float a)\n{\n    float s=sin(a),c=cos(a);\n    return mat3(1,0,0,0,c,s,0,-s,c);\n}\n\nmat3 rotY(float a)\n{\n    float s=sin(a),c=cos(a);\n    return mat3(c,0,s,0,1,0,-s,0,c);\n}\n\nmat3 rotZ(float a)\n{\n    float s=sin(a),c=cos(a);\n    return mat3(c,s,0,-s,c,0,0,0,1);\n}\n\nmat3 pointAtX(vec3 d)\n{\n    vec3 up=vec3(0,1,0);\n    vec3 side = normalize(cross(d,up));\n    return inverse(mat3(d,cross(side,d),side));\n}\n\nmat3 pointAtY(vec3 d)\n{\n    vec3 up=vec3(0,0,1);\n    vec3 side = normalize(cross(d,up));\n    return inverse(mat3(side,d,cross(side,d)));\n}\n\nmat3 pointAtZ(vec3 d)\n{\n    vec3 up=vec3(0,1,0);\n    vec3 side = normalize(cross(d,up));\n    return inverse(mat3(side,cross(side,d),d));\n}\n\nvec3 rot3d(vec3 p,vec3 a,float t)\n{\n    vec3 v = cross(a,p);\n    return cross(v, a)*cos(t)+v*sin(t)+a*dot(p, a);   \n}\n\nvec3 hsv(float h,float s,float v)\n{\n    // return mix(vec3(1),clamp((abs(fract(h+vec3(3,2,1)/3.0)*6.0-3.0)-1.0),0.0,1.0),s)*v;\n    return ((clamp(abs(fract(h+vec3(0,2,1)/3.0)*6.0-3.0)-1.0,0.0,1.0)-1.0)*s+1.0)*v;\n}\n\nfloat smax(float a, float b, float k)\n{\n    return log(exp(k * a) + exp(k * b)) / k;\n}\n\nfloat smin( float a, float b, float k )\n{\n\tfloat h = clamp( 0.5 + 0.5*(b-a)/k, 0.0, 1.0 );\n\treturn mix( b, a, h ) - k*h*(1.0-h);\n}\n\nvec2 pFold(vec2 p,float n)\n{\n    float h=floor(log2(n));\n    float a =TAU*exp2(h)/n;\n    for(int i=0;i<int(h)+2;i++)\n    {\n        vec2 v = vec2(-cos(a),sin(a));  \n        p-=2.0*smin(0.0,dot(p,v),0.05)*v;\n        a*=0.5;\n    }\n    return p;\n}\n\nvec2 pMod(vec2 p, float r)\n{\n    float a = mod(atan(p.y, p.x), TAU / r) - 0.5 * TAU / r;\n    return length(p) * vec2(sin(a), cos(a));\n}\n\nfloat noise(vec3 p){\n\tvec3 r=vec3(1,99,999);\n\tvec4 s=dot(floor(p),r)+vec4(0,r.yz,r.y+r.z);\n\tp=smoothstep(0.0,1.0,fract(p));\n\ts=mix(fract(sin(s)*5555.5),fract(sin(s+1.)*5555.5),p.x);\n\ts.xy=mix(s.xz,s.yw,p.y);\n\treturn mix(s.x,s.y,p.z);\n}\n\nfloat fbm(vec3 x)\n{\n \tfloat n=0.0,a=0.5;\n    for(int i=0;i<3;i++)\n    {\n     \tn+=a*noise(x);\n        x+=2.0;\n        a*=0.5;\n    }\n    return n;\n}\n\n// https://www.pouet.net/topic.php?which=7931&page=5\nvec2 opBend(vec2 p, float k, float g) \n{\n    float sgn = sign(k);\n\tfloat r = sgn/max(abs(k),1e-3);\n    k = abs(k);\n\tvec2 d = sgn*vec2(p.x, r-p.y);\n\tfloat a = -atan(d.x, d.y);\n    float b = clamp(a, -g*k, g*k) ;\n\tfloat s = b*r;\n\treturn mix(\n\t\tvec2(s, -sgn*(length(d)-abs(r))),\n\t\tvec2(s, r)-sgn*d*rot(b),\n\t\tabs(sign(a-b))\n\t);  \n}\n\nvec2 opBend(vec2 p, float k)\n{\n    float sgn = sign(k);\n    float r = 1.0/max(abs(k),1e-3);\n    vec2 d= vec2(p.x, r-p.y*sgn);\n    return vec2(atan(d.x,d.y)*r,sgn*(length(d)-r));\n}\n\n\n\nfloat lpNorm(vec2 p, float n)\n{\n\tp = pow(abs(p), vec2(n));\n\treturn pow(p.x+p.y, 1.0/n);\n}\n\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\n","name":"Common","description":"","type":"common"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define MIN(d) if(de>d*SCL[idx]){de=d*SCL[idx];ID=idx;}idx++;\n#define CO ROT[idx]*((p-POS[idx])/SCL[idx])\n\nbool BBflag=true;\n#define BB(bb,off,e)if (BBflag&&any(greaterThan(abs(p), bb)))\\\n\treturn length(max(abs(p-off)-bb,0.0))+float[](0.2,0.0005)[e];\n\n\n#define H float h=3.0+abs(fract(iTime*1.)-0.5)*3.0;\n\n\nint ID;  \nconst int NUM=10;\nfloat SCL[NUM];\nvec3  POS[NUM];\nmat3  ROT[NUM];\nvec3  COL[NUM];\n\nvoid property()\n{\n#define _s SCL[id]\n#define _p POS[id]\n#define _r ROT[id]\n#define _c COL[id]  \n    \n    for(int i=0;i<NUM;i++)\n    {\n        SCL[i]=1.0;\n    \tPOS[i]=vec3(0);\n        ROT[i]=mat3(1);\n        COL[i]=vec3(0.9, 0.6, 0.2);\n    }\n    int id=0;\n    \n    float h=3.0+abs(fract(iTime*1.)-0.5)*3.0;\n\n    // deGround\n    _c=vec3(0.4,0.6,0.2);\n    \n    // deHead\n    id++;\n    _p.y=h+0.5;\n    _s=0.5;\n    \n    // deArm\n    id++;\n    _p.y=h-0.8;\n    \n    // deBody\n    id++;\n}\n\nfloat deGround(vec3 p)\n{\n    return p.y;\n}\n\nfloat deHead(vec3 p)\n{\n    vec3 s=vec3(1,0.7,0.7);\n    float de=sdRoundBox(p,s,0.01);\n    vec2 q=p.xy;\n    q.x=abs(q.x)-0.5;\n    q.y-=0.2;\n    float d2=length(q)-0.2;\n    q=p.xy;\n    q.y-=-0.3;\n    q.x-=clamp(q.x,-0.5,0.5);\n    d2=min(d2,length(q)-0.15);\n    \n    vec2 g=vec2(d2, abs(p.z-s.z)-0.1);   \n    de=max(de,-(length(max(g,0.0))+min(max(g.x,g.y),0.0)-0.02));\n        \n    return de;\n}\n\nvec2 solveCubic(float a, float b, float c)\n{\n    float p = b - a*a / 3.0, p3 = p*p*p;\n    float q = a * (2.0*a*a - 9.0*b) / 27.0 + c;\n    float d = q*q + 4.0*p3 / 27.0;\n    float offset = -a / 3.0;\n    if(d >= 0.0)\n    { \n        float z = sqrt(d);\n        vec2 x = (vec2(z, -z) - q) / 2.0;\n        vec2 uv = sign(x)*pow(abs(x), vec2(1.0/3.0));\n        return vec2(offset + uv.x + uv.y);\n    }\n    float v = acos(-sqrt(-27.0 / p3) * q / 2.0) / 3.0;\n    float m = cos(v), n = sin(v)*sqrt(3.0);\n    return vec2(m + m, -n - m) * sqrt(-p / 3.0) + offset;\n}\n\nvec3 opBezier(vec2 p, vec2 a, vec2 b, vec2 c)\n{   \n    b = mix(b + vec2(1e-4), b, abs(sign(b * 2.0 - a - c)));\n    vec2 A = b - a, B = a - b * 2.0 + c, C = A * 2.0, D = a - p;\n    vec3 k = vec3(3.*dot(A,B),2.*dot(A,A)+dot(D,B),dot(D,A)) / dot(B,B);      \n    vec2 to = solveCubic(k.x, k.y, k.z);\n    vec2 t = clamp(to, 0.0, 1.0);\n    vec2 dp1 = D + (C + B*t.x)*t.x;\n    vec2 dp2 = D + (C + B*t.y)*t.y;\n    float d1 = dot(dp1, dp1);\n    float d2 = dot(dp2, dp2);\n    vec3 h = (d1 < d2) ? vec3(d1, t.x, to.x) : vec3(d2, t.y, to.y);\n    vec2 g = normalize(2.*B*h.y + C);\n    p -= mix(mix(a, b, h.y), mix(b, c, h.y), h.y);\n    float y = g.x*p.y-g.y*p.x;\n    float x = sqrt(abs(h.x-y*y))*sign(h.y-0.5);\n    return vec3(x,y,h.z);\n}\n\nfloat deArm(vec3 p)\n{\n    p.y-=0.8;\n    float f= 1.0-abs(fract(iTime*1.)-0.5)*1.0;\n    float l= 3.0;\n    vec3 bz=opBezier(p.yz,vec2(0),vec2((f-l)/2.0,-max(0.001,asin(f)*0.9)),vec2(f-l,0));\n    float d2=length(max(abs(bz.xy)-vec2(0,0.2),0.0));\n    p.x=abs(p.x)-1.05;\n    vec2 g=vec2(d2,p.x);\n    return  length(max(abs(g)-vec2(0.,0.2),0.0)) -0.02;\n}\n\nfloat deBody(vec3 p)\n{\n    float h= 3.;\n    float h0=h+abs(fract(iTime*1.)-0.5)*3.0;\n    h+=1.5;\n    float x=max(0.001,sqrt(h*h-h0*h0)/4.0);\n    vec3 bz;\n    h0/=4.0;\n    bz=opBezier(p.yz,vec2(0),vec2(h0,x),vec2(h0*2.0,0));\n    float d2=length(max(abs(bz.xy)-vec2(0,0.2),0.0));\n    vec2 g=vec2(d2,p.x);\n    float de= length(max(abs(g)-vec2(0.,0.8),0.0)) -0.02;\n    de=max(de,-(length(max(abs(g)-vec2(0.,0.2),0.0))-0.03));\n    bz=opBezier(p.yz,vec2(h0*2.0,0),vec2(h0*3.,-x),vec2(h0*4.0,0));\n    d2=length(max(abs(bz.xy)-vec2(0,0.2),0.0));\n    g=vec2(d2,p.x);\n    de= min(de,length(max(abs(g)-vec2(0.,0.8),0.0)) -0.02);\n\treturn de;\n}\n\nfloat map(vec3 p)\n{\n    float de=1e9;\n    int idx=0;\n \tMIN(deGround(CO))\n    MIN(deHead(CO))\n    MIN(deArm(CO))\n    MIN(deBody(CO))\n\treturn de;\n}\n\nvec3 doColor(vec3 p)\n{\n    if (ID==0)\n    {\n        float c=2.;\n    p=mod(p,c)-c*0.5;\n    return vec3(sign(p.x*p.z));\n\n    }\n\treturn COL[ID];   \n}\n\nvec3 calcNormal(vec3 p )\n{\n    vec3 n = vec3(0.0);\n    for(int i = ZERO; i < 4; i++)\n    {\n        vec3 e = 0.001*(vec3(9>>i&1, i>>1&1, i&1)*2.0-1.0);\n        n += e * map(p + e);\n    }\n    return normalize(n);\n}\n\nfloat softshadow(in vec3 ro, in vec3 rd)\n{\n\tfloat res = 1.0;\n    float t = 0.05;\n    for(int i = 0; i < 32; i++)\n    {\n\t\tfloat h = map(ro + rd * t);\n        res = min(res, 8.0 * h / t);\n        t += clamp(h, 0.02, 0.1);\n        if(h < 0.001 || t > 5.0) break;\n    }\n    return clamp(res, 0.0, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    property();\n    vec2 uv = (fragCoord*2.0 - iResolution.xy) / iResolution.y;\n    vec3 col = vec3(0.1+0.5*uv.y*uv.y);\n    vec3 ro = vec3(0.0, 4.0,6.5);\n    //ro.xz *= rot(- 0.7);\n    ro.xz *= rot(sin(iTime*0.3) * 1.2);\n    vec3 ta = vec3(0.0,2.5,0.0);\n    vec3 w = normalize(ta-ro);\n\tvec3 u = normalize(cross(w,vec3(0.0,1.0,0.0)));\n\tvec3 rd = mat3(u,cross(u,w),w)*normalize(vec3(uv, 2.0));\n    float t = 0.0, h, maxd = 30.0;\n    for(int i = 0; i < 64; i++)\n    {\n        t += h = map(ro+rd*t);\n        if(h<0.001 || t>maxd) break;\n    }\n    if(t<maxd)\n    {\n        BBflag=false;\n        vec3 p = ro+t*rd;\n        vec3 n = calcNormal(p);\n\t\tcol = doColor(p);\n        vec3 li = normalize(vec3(2.0, 3.0, 3.0));\n        float dif = clamp(dot(n, li), 0.0, 1.0);\n        dif *= softshadow(p, li);\n        dif=0.0;\n        col *= max(dif, 0.3);\n        float rimd = pow(clamp(1.0 - dot(reflect(-li, n), -rd), 0.0, 1.0), 2.5);\n\t\tfloat frn = rimd + 2.2 * (1.0 - rimd);\n    \tcol *= frn*0.8;\n        col *= max(0.5+0.5*n.y, 0.0);\n        col *= exp2(-2.*pow(max(0.0, 1.0-map(p+n*0.3)/0.3),2.0));\n        col += pow(clamp(dot(reflect(rd, n), li), 0.0, 1.0), 60.0);\n        col = mix( col, vec3(0.0), 1.0-exp( -0.001*t*t ) );\n    }\n\tcol = pow(col, vec3(0.6));\n    fragColor = vec4(col, 1.0);\n}\n","name":"Buffer A","description":"","type":"buffer"}]}