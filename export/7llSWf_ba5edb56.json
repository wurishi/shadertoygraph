{"ver":"0.1","info":{"id":"7llSWf","date":"1627783335","viewed":102,"name":"CRT Tofu Shader","username":"NotTofuFood","description":"CRT Shader.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["pixel","tv","crt","old"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xdf3Rn","filepath":"/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm","previewfilepath":"/media/ap/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm","type":"video","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Standard Variables\n\nfloat def_bend = 3.14;\nfloat vignette_size = .2;\nfloat vignette_smoothness = .6;\nfloat vignette_edgeRounding = .8;\nfloat grain_amount = .5;\n\n// Standard shader random function.\n\nfloat rand(vec2 co){\n    return fract(sin(dot(co, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n// Creates proper UV coords so that video is not warped.\n\nvec2 transform_coords(vec2 uv, float bend)\n{\n\tuv -= 0.5;\n    uv *= 1.9;\n    uv.x *= 1. + pow(abs(uv.y)/bend, 2.);\n    uv.y *= 1. + pow(abs(uv.x)/bend, 2.);\n    \n    uv /= 2.;\n    return uv + .5;\n}\n\n// Darkens side of screen, combines with the color via multiplication in order to achieve a bending vignette.\n\nfloat vignette(vec2 uv, float size, float smoothness, float edgeRounding)\n{\n\tuv = (uv-.5) * size;\n    return smoothstep(0., smoothness, 1. - sqrt(pow(abs(uv.x), edgeRounding) + pow(abs(uv.y), edgeRounding)));\n}\n\n\n// Film Grain\n\nfloat grain(float grain_amt, vec2 uv) {\n    return grain_amt+rand(uv * iTime);\n}\n\n// Scanlines, uses trig in order to get uniformed scan lines.\n\nvec3 scanline(vec2 uv) {\n    vec2 color = vec2(sin(uv.y * iResolution.y * 1.), cos(uv.y * iResolution.y * 1.));\n\treturn vec3(color.x, color.y, color.x);\n}\n\n// First, we declare the uv coords, curve it using transform_coords, combine it with our video feed (iChannel0) (if using Unity, use actual game pixels)\n// Then, we add vignette, add in the scanlines, output grain, and we are finished! \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec2 curved_uv = transform_coords(uv, 2.);\n\n\tvec4 final_output = vec4(1.) * texture( iChannel0, transform_coords(uv, 3.14)); \n\n\tfinal_output*=vignette(curved_uv, vignette_size, vignette_smoothness, vignette_edgeRounding);\n\t\n\tfinal_output*=vec4(scanline(curved_uv), 1.);\n\t\n\tfinal_output*=grain(grain_amount,curved_uv);\n\n    fragColor = final_output;\n}\n","name":"Image","description":"","type":"image"}]}