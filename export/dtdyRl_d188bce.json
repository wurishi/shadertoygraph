{"ver":"0.1","info":{"id":"dtdyRl","date":"1699551194","viewed":52,"name":"Non-zero two paths fill (SDF)","username":"Envy24","description":"Shows how to use non-zero fiil to generate signed distance function.\nLMB up     -> shows SDF,\nLMB down -> shows filled (colored) shape.","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["fill","zero","shape","odd","even","non"],"hasliked":0,"parentid":"mtcyzl","parentname":"Non-zero two paths fil (with AA)"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define SCENE_SCALE               ( 1.2 )\n#define AA_UNIT                   ( (SCENE_SCALE*4.0) / iResolution.y  )\n#define SMAA(d)                   ( smoothstep(AA_UNIT, 0., d) )\n\n/* https://www.shadertoy.com/view/DdsGDj */\n#define MOUSE_OFFSET ( iMouse.z > 0. ? iMouse.xy - iResolution.xy * 0.5 : vec2(0) )\nvec2 map_to_centered_ndc(in vec2 SC, in float scale, in vec2 origin, in bool mouse_drag)\n{\n    vec2 M = MOUSE_OFFSET * (mouse_drag == true ? 1. : 0.);\n    return ((2. * (SC - M) - iResolution.xy) / iResolution.y) * scale + origin;\n}\n\nint is_inside_two_path_shape(vec2 P)\n{\n    int winding = 0;\n\n    for (int p = 0; p < path_length; ++p)\n    {      \n        int pn = (p + 1) % path_length;\n    \n        // Check path A.\n        float x1 = pathA[p].x,  y1 = pathA[p].y,\n              x2 = pathA[pn].x, y2 = pathA[pn].y,\n              ratio = (P.y - y1) / (y2 - y1);\n        \n        // Ray intersects with segment?\n        if ( ( (P.y < y1) != (P.y < y2) ) && ( P.x < (x1 + ratio * (x2 - x1)) ) )\n        {\n            // Segment goes down?\n            if (y1 > y2)\n                winding += 1;\n            else\n                winding -= 1;\n        }\n        \n        // Check path B.\n        x1 = pathB[p].x,  y1 = pathB[p].y,\n        x2 = pathB[pn].x, y2 = pathB[pn].y,\n        ratio = (P.y - y1) / (y2 - y1);\n        \n        // Ray intersects with segment?\n        if ( ( (P.y < y1) != (P.y < y2) ) && ( P.x < (x1 + ratio * (x2 - x1)) ) )\n        {\n            // Segment goes down?\n            if (y1 > y2)\n                winding += 1;\n            else \n                winding -= 1;\n        }\n    }\n\n    return int(winding != 0); // Non-zero rule\n}\n\nfloat two_path_SDF(vec2 P)\n{\n    float min_d = min(path_SDF(P, pathA), path_SDF(P, pathB));\n    if (is_inside_two_path_shape(P) == 1)\n        return -min_d;\n    return min_d;\n}\n\n/* https://www.shadertoy.com/view/ddfGz2 */\nvec3 colorize_field(float dist, vec3 color)\n{    \n    float F = 30., freq = F*dist, aa = 1./F, C = 0.7, amp = 0.2, width = F*0.01, //0.3\n          waves_sdf = C + amp*smoothstep(4./iResolution.y, 0., (width+cos(freq)) * aa),\n          exp_raise = 1. - exp(-4.*abs(dist));\n        \n    color = 1.0 - sign(dist) * color; // Change color if dist is negative. \n    color *= exp_raise;               // Attenuate color around edges.     \n    color *= waves_sdf;               // Add waves.\n    \n    return mix(color, vec3(1), smoothstep(4./iResolution.y, 0., abs(dist)) );\n}\n\nfloat L2(vec2 B, vec2 E)\n{\n    vec2 D = E - B;\n    return sqrt(D.x*D.x + D.y*D.y);\n}\nvec3 add_metric(vec2 NDC, vec3 color)\n{\n    float unit = 4.0 / iResolution.y,\n          half_pi = 1.5707963267948966,\n          T = iTime * 0.5;\n          \n    vec2 M = cos(T+vec2(0., -half_pi))*0.5;\n    color = mix(color, vec3(1.0, 1.0, 0.0), smoothstep(unit, 0.0, length(NDC - M) - 0.008));\n    return mix(color, vec3(1.0, 1.0, 0.0), smoothstep(unit, 0.0, abs(L2(NDC, M) - abs(two_path_SDF(M)))));\n}\n\nvoid mainImage( out vec4 O, in vec2 SC )\n{\n    init_paths();\n    //randomizeA(iTime*.2);\n    //randomizeB(iTime*.2);\n\n    vec2 NDC = map_to_centered_ndc(SC, SCENE_SCALE, vec2(0), false),\n         MP = iMouse.xy == vec2(0) ? vec2(0) :\n             map_to_centered_ndc(iMouse.xy, SCENE_SCALE, vec2(0), false);\n    \n    float min_d = two_path_SDF(NDC);\n    \n    vec3 color = vec3(1);\n    \n    if (iMouse.z > 0.)\n    {\n        color = mix( color, normalize(vec3(1,NDC)), SMAA(min_d) );\n    }\n    else\n    {\n        color = colorize_field(min_d, vec3(.1,.4,.7));\n        color = add_metric(NDC, color);\n    }\n\n    O = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"float circleSDF(in vec2 NDC, in vec2 C, in float r) { return length(C - NDC)-r; }\nfloat segmentSDF(in vec2 NDC, in vec2 B, in vec2 E, in float r)\n{\n    vec2 BP = NDC - B, BE = E - B;\n    return length(BP - BE * clamp(dot(BP, BE) / dot(BE, BE), 0.0, 1.0)) - r;\n}\n\nconst int path_length = 8;\nvec2 pathA[path_length];\nvec2 pathB[path_length];\n\nvoid init_paths()\n{\n    pathA[0] = vec2(-0.5, 0.3); \n    pathA[1] = vec2(-0.5, 1);\n    pathA[2] = vec2(0.5, 1);\n    pathA[3] = vec2(0.5, 0.3);\n    \n    pathA[4] = vec2(-0.25, -0.15); \n    pathA[5] = vec2(-0.25, -0.7);\n    pathA[6] = vec2(0.25, -0.7);\n    pathA[7] = vec2(0.25, -0.15);\n    \n    for (int i = 0; i < path_length; ++i)\n    {\n        pathB[i] = pathA[path_length - 1 - i] * vec2(1, -1) + vec2(0, 0.15);\n    }\n}\nfloat path_SDF(vec2 NDC, vec2 path[path_length])\n{\n    float min_d = 9e5;\n    for (int p = 0; p < path_length - 1; ++p)\n    {\n        min_d = min( min_d, segmentSDF(NDC, path[p], path[p + 1], 0.) );\n    }\n    min_d = min( min_d, segmentSDF(NDC, path[path_length - 1], path[0], 0.) );\n    \n    return min_d;\n}\n\n/* \n    Returns random vec2([-1.0; 1.0], [-1.0; 1.0]).\n*/\nvec2 h2to2(\n    const uint x,\n    const uint y)\n{\n    // Pick some seed source values.\n    const uint seed0 = 123u;\n    const uint seed1 = 456u;\n    const uint seed2 = 789u;\n\n    uint value0 = y * seed2 + x;\n    uint value1 = x * seed2 + y;\n\n    // Calculate hash.\n\tvalue0 += seed1; value0 *= 445593459u; value0 ^= seed0;\n    value1 += seed1; value1 *= 445593459u; value1 ^= seed0;\n    \n    // 2.0f / 4294967295.0f = 4.6566128730773926e-10\n\n    return \n        vec2(\n            float(value0 * value0 * value0) * 4.6566128730773926e-10f - 1.0f,\n            float(value1 * value1 * value1) * 4.6566128730773926e-10f - 1.0f);\n}\n\nvoid randomizeA(float time)\n{\n    time *= 0.5;\n    float t = fract(time);\n    uint T = uint(time);\n\n    for (int k = 0; k < path_length; ++k)\n    {\n        uint x = T + uint(k);\n        uint y = 2u * T + uint(k * 2);\n        vec2 c = 1.2*h2to2(x, y);\n        vec2 n = 1.2*h2to2(x + 1u, y + 2u);\n    \n        pathA[k] = c * (1. - t) + n * t;\n    }\n}\nvoid randomizeB(float time)\n{\n    time += 100.;\n    time *= 0.5;\n    float t = fract(time);\n    uint T = uint(time);\n\n    for (int k = 0; k < path_length; ++k)\n    {\n        uint x = T + uint(k);\n        uint y = 2u * T + uint(k * 2);\n        vec2 c = 1.2*h2to2(x, y);\n        vec2 n = 1.2*h2to2(x + 1u, y + 2u);\n    \n        pathB[k] = c * (1. - t) + n * t;\n    }\n}","name":"Common","description":"","type":"common"}]}