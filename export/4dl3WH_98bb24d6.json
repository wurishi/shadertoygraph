{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[{"channel":0,"type":"texture","id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}},{"channel":1,"type":"music","id":"XsXGzn","filepath":"/media/a/29de534ed5e4a6a224d2dfffab240f2e19a9d95f5e39de8898e850efdb2a99de.mp3","sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"}}],"code":"//between 0.0 - 1.0\n#define DayLight 0.3 \n\n//minim 5 for best result\n#define Depth 5 \n\nfloat freqs[4];\nfloat side = 1.;\n\nvec2 p,rv2;\nfloat f0, f1,f2,f3;\n\nvec3 rand3(vec2 fragCoord)\n{\n   vec4 s1 = sin(iTime * 3.3422 + fragCoord.xxxx * vec4(324.324234, 563.324234, 657.324234, 764.324234)) * 543.3423;\n   vec4 s2 = sin(iTime * 1.3422 + fragCoord.yyyy * vec4(567.324234, 435.324234, 432.324234, 657.324234)) * 654.5423;\n   vec4 gPixelRandom = fract(2142.4 + s1 + s2);\n   return normalize( gPixelRandom.xyz - 0.5);\n}\n\nfloat hash( float n ) {\n\treturn fract(sin(n)*43758.5453);}\n\t\nvec2 hash2( float n ) {\n\treturn fract(sin(vec2(n,n+1.0))*vec2(2.1459123,3.3490423));\n}\n\nvec2 randv2;\nvec2 rand2()\n{\n   randv2+= randv2+vec2(1.0,1.0);\n   return vec2( fract(sin(dot(randv2.xy ,vec2(12.9898,78.233))) * 43758.5453),\n      \t\t\tfract(cos(dot(randv2.xy ,vec2(4.898,7.23))) * 23421.631));\n}\n\nvec3 cosineDirection(in vec3 nor, vec2 fragCoord)\n{//return a random direction on the hemisphere\n   vec2 r = rand3(fragCoord).xy*6.283;\n   vec3 dr=vec3(sin(r.x)*vec2(sin(r.y),cos(r.y)),cos(r.x));\n   return (dot(dr,nor)<0.0)?-dr:dr;\n}\n\nvec3 CosineWeightedSampleHemisphere ( vec3 normal, vec2 rnd )\n{\n   float phi = acos( sqrt(1.0 - rnd.x)) ;\n   float theta = 2.0 * 3.14 * rnd.y ;\n\n   vec3 sdir = cross(normal, (abs(normal.x) < 0.5) ? vec3(1.0, 0.0, 0.0) : vec3(0.0, 1.0, 0.0));\n   vec3 tdir = cross(normal, sdir);\n\n   //return vec3(sin(phi) * cos(theta), cos(phi), sin(phi) * sin(theta));\n   return normalize(phi * cos(theta) * sdir + phi * sin(theta) * tdir + sqrt(1.0 - rnd.x) * normal);\n}\n\nvec3 rotateY(vec3 p, float a)\n{\n    float sa = sin(a);\n    float ca = cos(a);\n    vec3 r;\n    r.x = ca*p.x + sa*p.z;\n    r.y = p.y;\n    r.z = -sa*p.x + ca*p.z;\n    return r;\n}\n\nfloat iplane(vec3 p, vec3 planeN, vec3 planePos)\n{\n   return dot(p - planePos, planeN);\n}\n\nfloat sphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nfloat cub(vec3 p,vec3 c, vec3 size)\n{\n   p = p-c;\n   return max(max(abs(p.x) - size.x, abs(p.y) - size.y), abs(p.z) - size.z);\n}\n\nvec2 scene( vec3 p )\n{\n   float f = 100000.0;\n   float id = -1.;\n\n\t//cub light\n\tfloat f1 = cub(p, vec3(0.0, f1*0.5+0.0, 2.0), vec3(0.2, f1*0.5+0.0, 0.1));\n\tif(f1<f) {f = f1; id = 0.;}\t\n\tfloat f2 = cub(p, vec3(1.0, f0*0.5+0.0, 2.0), vec3(0.2, f0*0.5+0.0, 0.1));\n\tif(f2<f) {f = f2; id = 1.;}\t\n\tfloat f3 = cub(p, vec3(-1.0, f3*0.5, 2.0), vec3(0.2, f3*0.5, 0.1));\n\tif(f3<f) {f = f3; id = 2.;}\n\t\n\t//transparent cub\n\tfloat f4 = cub(p, vec3(-1.5, 0.5, 0.0), vec3(0.6,0.5, 0.1));\n\tif(f4<f) {f = f4; id = 3.;}\n\t\n\tfloat n = sin(iTime)*0.5;\n\t//transparent sphere\n\tfloat f10 = sphere(p-vec3(0.0, n, -0.5), 0.5);\n    if(f10<f) {f = f10; id = 10.;}\n\t\n\t//comvex mirror\n\tfloat m = sin(iTime)*1.5;\n\tfloat f11 = sphere(p-vec3(0.0, 0.0, m+2.5), 2.0);\n\tfloat f12 = sphere(p-vec3(0.0, 0.0, m+2.0), 2.3);\n\tf12 = max(f11,-f12);\n\tif(f12<f) {f = f12; id = 11.;}\n\t\n\t//plane\n\tfloat f20 = iplane(p, vec3(0., 1., 0.), vec3(0., -0.0, 0.));\n\tif(f20<f) {f = f20; id = 14.;}\n\n   return vec2(f, id);\n}\n\n// color and power of emisiv\nvec4 getMatColor(float id)\n{\n\tvec4 color = vec4(0.);\n\tif(id==0.) color = vec4(0.2,0.9,0.2, f1*1.3);//cub green\n\tif(id==1.) color = vec4(0.2,0.2,1.0, f0*1.3);//cub blue\n\tif(id==2.) color = vec4(1.0,1.0,0.2, f3*1.3);//cub yelow\n\tif(id==3.) color = vec4(1.0,0.7,0.5, 0);//\n\t\n\tif(id==10.) color = vec4(1.0,1.0,1.0, 0.0);//sphere\n\tif(id==11.) color = vec4(1.0,1.0,1.0, 0.0);//convex mirror\n\tif(id==14.) color = vec4(1.0,1.0,1.0, 0.0);//plan\n\t\n\treturn color;\n}\n\n//rflect/refract - betwen -1.0 - 1.0 and diffuse refl/refr - betwen 0.0 - 1.0\nvec2 getMatRef(float id)\n{\n\tvec2 ref = vec2(0.);\n\tif(id==0.) ref = vec2( 0.0,  0.0);//cub green\n\tif(id==1.) ref = vec2( 0.0,  0.0);//cub blue\n\tif(id==2.) ref = vec2( 0.0,  0.0);//cub yelow\n\tif(id==3.) ref = vec2(-1.0,  0.05);//transparent cub\n\t\n\tif(id==10.) ref = vec2(-1.0,  0.0);//sphere\n\tif(id==11.) ref = vec2( 1.0,  0.0);//convex mirror\n\tif(id==14.) ref = vec2( 0.0,  0.0);//plan\n\t\n\treturn ref;\n}\n\nvec3 sceneNormal( in vec3 pos )\n{\n\tvec3 eps = vec3( 0.001, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t    scene(pos+eps.xyy).x - scene(pos-eps.xyy).x,\n\t    scene(pos+eps.yxy).x - scene(pos-eps.yxy).x,\n\t    scene(pos+eps.yyx).x - scene(pos-eps.yyx).x );\n\treturn normalize(nor);\n}\n\nvec2 raym(vec3 ro, vec3 rd, int maxit, float maxd)\n{\n\tfloat d = 0.002;\n\tvec2 f = vec2(0.0, -1.0);\n\tside = sign(scene(ro+rd*0.001).x);\n\t\n\tfor(int i=0; i<80; i++)\n\t{\n\t\tf = scene(ro+rd*d);\n\t\tif(abs(f.x) < 0.0001 || d > maxd)\n\t\t{\n\t\t\tf.x = d;\n\t\t\tcontinue;//return f;\n\t\t}\n\t\td += f.x*side;\n\t\t//if(d > 5.) {f.x = 1000.;f.y = -1.0; return f;}\n\t}\n\tif(d > maxd) {f.x = 1000.;f.y = -1.0; }\n\treturn f;//vec2(0.0, -1.0);\n}\n\nvec2 castRay( in vec3 ro, in vec3 rd, in float maxd )\n{\n\tfloat precis = 0.001;\n    float h=precis*20.0;\n    float t = 0.0;\n    float m = -1.0;\n\tside = sign(scene(ro+rd*0.01).x);\n    for( int i=0; i<90; i++ )\n    {\n        if( abs(h)<precis||t>maxd ) continue;//break;\n        t += h*side;\n\t    vec2 res =scene( ro+rd*t );\n        h = res.x;\n\t    m = res.y;\n    }\n\n    if( t>maxd ) m=-1.0;\n    return vec2( t, m );\n}\n\nconst vec3 ior=vec3(1.0,1.52,1.0/1.52);\nvec3 getBRDFRay( in vec3 rd, in vec3 n, in vec2 mref, vec2 fragCoord )\n{\n\tfloat q = rd.x+iTime*texture( iChannel0, p*0.8 ).r;\n   //randomly direct the ray in a hemisphere or cone based on reflectivity\n   if( hash(q)*0.0005 > abs(mref.x))\n\t{\n    \t//vec3 dr = normalize(n + rand3(fragCoord) * 0.99);\n\t\tvec3 dr = (cosineDirection(n,fragCoord))*10.1;\n    \treturn (dot(dr,n)<0.0)?-dr:dr;\n\t}\n   else\n   {//return a cone direction for a reflected or refracted ray\n      vec3 refl=reflect(rd,n);\n      vec3 newRay = refl;\n      if(mref.x<0.0)\n      {\n         vec3 refr=refract(rd,n*side,(side>=0.0)?ior.z:ior.y); \n         vec2 ca=vec2(dot(n,rd),dot(n,refr)),ns=(side>=0.0)?ior.xy:ior.yx,nn=vec2(ns.x,-ns.y);\n         if(hash2(q).x>0.5*(pow(dot(nn,ca)/dot(ns,ca),2.0)+pow(dot(nn,ca.yx)/dot(ns,ca.yx),2.0)))\n\t\t\t newRay=refr;\n      }\n\t  return normalize(newRay+cosineDirection(newRay+rand3(fragCoord),fragCoord)*mref.y)*1.5;\n   }\n}\n\nvec2 min2(vec2 d1, vec2 d2){return (d1.x<d2.x)?d1:d2;}//sorts vectors based on .x\n\nvec3 getColor (in vec3 ro, in vec3 rd, in vec2 fragCoord)\n{\n\tvec3 tcolor = vec3(0.0);\n\tvec3 color  = vec3(1.0);\n\tvec3 n = vec3(0.,1.05,0.);\n\tvec3 sundir = vec3(cos(iTime*0.7)*2.5+0.2,0.9,sin(iTime*0.7)*2.5+0.2);\n\tvec2 hit = vec2(0.0,-1.0);\n\n\tfor(int i=0; i<Depth; i++)\n\t{\n\t\thit = raym(ro, rd, 80, 10.);\n\t\t\n\t\tif(hit.y==-1.)\n\t\t{\n\t\t\t\tfloat diff = dot(n,sundir);\n\t\t\t\ttcolor +=  color*diff*vec3(0.9,0.9,1.0)*DayLight;\n\t\t\t\tbreak;\n\t\t}\n\t\t\n\t\tvec4 matcol = getMatColor(hit.y);\n\t\tif(matcol.w>0.) {tcolor +=  color * (matcol.xyz*matcol.w); break;}\n\t\t\n\t\tcolor *= matcol.xyz;\t\n\t\ttcolor +=  color * (matcol.w);\n\t\t\n\t\tro += rd * (hit.x+0.001);\n\t\tn = sceneNormal( ro );\n\t\trd = normalize(getBRDFRay( rd, n, getMatRef(hit.y), fragCoord));\n\t\tro +=rd*0.0001;\n\t}\n\t\n\treturn clamp(tcolor, 0., 1.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    randv2 = fract(cos((fragCoord.xy+fragCoord.yx*vec2(1000.0,1000.0))+vec2(iTime*0.2,iTime*0.2))*10000.0);\n    \n\tvec2 q = fragCoord.xy/iResolution.xy;\n    p = -1.0+2.0*q;\n\tp.x *= iResolution.x/iResolution.y;\n    vec2 mo = iMouse.xy/iResolution.xy;\n\t\t \n\n\t// camera\t\n\tvec3 ro = vec3( -0.5+3.2*cos(0.1*1.5 + 6.0*mo.x), 1.0 + 5.*(mo.y), 0.5 + 3.2*sin(0.1*1.5 + 6.0*mo.x) );\n\tvec3 ta = vec3( -0.5, 0.4, 1.0 );\n\t\n\t// camera tx\n\tvec3 cw = normalize( ta-ro );\n\tvec3 cp = vec3( 0.0, 1.0, 0.0 );\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n\tvec3 rd = normalize( p.x*cu + p.y*cv + 2.5*cw );\n\n\tfreqs[0] = texture( iChannel1, vec2( 0.01, 0.25 ) ).x;\n\tfreqs[1] = texture( iChannel1, vec2( 0.07, 0.25 ) ).x;\n\tfreqs[2] = texture( iChannel1, vec2( 0.15, 0.25 ) ).x;\n\tfreqs[3] = texture( iChannel1, vec2( 0.30, 0.25 ) ).x;\n\t\n\tf0 = pow( clamp( freqs[0]*0.99, 0.0, 1.0 ), 5.0 );\n\tf1 = pow( clamp( freqs[1]*0.99, 0.0, 1.0 ), 5.0 )*1.5;\n\tf3 = pow( clamp( freqs[2]*0.99, 0.0, 1.0 ), 5.0 )*1.5;\n\tf2 = pow( clamp( freqs[3]*0.99, 0.0, 1.0 ), 5.0 );\n\t\n\tvec3 col = vec3(0.0);\n    col = getColor( ro, rd, fragCoord );\n\n    fragColor=vec4( col, 1.0 );\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"4dl3WH","date":"1369385185","viewed":346,"name":"Little PathTracing","username":"predatiti","description":"Many cool stuf : fhttp://www.fractalforums.com/programming/global-illumination-(article)\n","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["procedural"],"hasliked":0,"parentid":"","parentname":""}}