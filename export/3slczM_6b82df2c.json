{"ver":"0.1","info":{"id":"3slczM","date":"1584453487","viewed":767,"name":"Water Flow Prototype","username":"Plati","description":"My first entry in Shadertoy! :)\n\nIt's a tilable physicalized flow shader prototype, using some linear forward movement, curl and box blur for the flow map in the buffer.","likes":32,"published":1,"flags":32,"usePreview":1,"tags":["water","flow","physics","flowmap","tilable"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float sample_offset = 0.005;\n\nfloat get_delta(sampler2D tex, vec2 uv, float offset, bool pattern) {\n\tfloat pyt = 0.707107;\n\tvec2 m = texture(tex, uv).xy;\n\t\n\tvec2 p1, p2, p3, p4;\n\t\n\tif (pattern == true) {\n\t\tp1 = texture(tex, fract( uv + vec2(0.0, -offset))).xy;\n\t\tp2 = texture(tex, fract( uv + vec2(offset, 0.0))).xy;\n\t\tp3 = texture(tex, fract( uv + vec2(0.0, offset))).xy;\n\t\tp4 = texture(tex, fract( uv + vec2(-offset, 0.0))).xy;\n\t}\n\telse {\n\t\tp1 = texture(tex, fract( uv + vec2(offset, -offset) * pyt)).xy;\n\t\tp2 = texture(tex, fract( uv + vec2(offset, offset) * pyt)).xy;\n\t\tp3 = texture(tex, fract( uv + vec2(-offset, offset) * pyt)).xy;\n\t\tp4 = texture(tex, fract( uv + vec2(-offset, -offset) * pyt)).xy;\n\t}\n\t\n\tfloat delta = length(m - p1) + length(m - p2) + length(m - p3) + length(m - p4);\n\t\n\treturn delta;\n}\n\nfloat get_height(sampler2D tex, vec2 uv, float offset) {\n\tfloat height_0 = get_delta(tex, uv, offset * 0.5, true);\n\tfloat height_1 = get_delta(tex, uv, offset * 1.0, false);\n\tfloat height_2 = get_delta(tex, uv, offset * 2.0, true);\n\tfloat height_3 = get_delta(tex, uv, offset * 3.0, false);\n\tfloat height_4 = get_delta(tex, uv, offset * 5.0, true);\n\tfloat height_5 = get_delta(tex, uv, offset * 5.0, false);\n\tfloat height_6 = get_delta(tex, uv, offset * 10.0, true);\n\tfloat height_7 = get_delta(tex, uv, offset * 20.0, false);\n\tfloat height_8 = get_delta(tex, uv, offset * 20.0, true);\n\tfloat height_9 = get_delta(tex, uv, offset * 35.0, false);\n\tfloat height_10 = get_delta(tex, uv, offset * 35.0, true);\n\tfloat height_11 = get_delta(tex, uv, offset * 50.0, false);\n\tfloat height_12 = get_delta(tex, uv, offset * 50.0, true);\n\t\n\tfloat height = (height_0 * 10.0 + height_1 + height_2 + height_3 + height_4 + height_5 + height_6 + height_7 + height_8 + height_9 + height_10 + height_11 + height_12) / 13.0;\n\t\t\n\treturn height;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 uv = fract(fragCoord/iResolution.xy);\n\tvec4 flow_map = texture(iChannel0, uv);\n\tfloat height = get_height(iChannel0, uv, sample_offset);\n\t\n\tfragColor = vec4(height, height, height, 1.0);\n    //fragColor = flow_map;\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"float sample_offset = 1.0;\nfloat forward_modifier = 0.0;\nfloat blur_strength = 0.1;\nfloat blur_offset = 1.0;\nfloat curl_strength = 2.8;\nfloat curl_offset = 1.5;\nfloat radial_force_strength = 0.1;\nfloat radial_force_speed = 1.0;\nbool random_dir_x = false;\nbool random_dir_y = false;\nfloat random_dir_speed = 0.2;\n\nvec2 get_average(sampler2D buffer, vec2 uv, float offset) {\n\tfloat pyt = 0.707107;\n\t\n\tvec2 p1 = texture(buffer, fract( uv + vec2(0.0, -offset) ), 1.0).xy;\n\tvec2 p2 = texture(buffer, fract( uv + vec2(offset, 0.0) ), 1.0).xy;\n\tvec2 p3 = texture(buffer, fract( uv + vec2(0.0, offset) ), 1.0).xy;\n\tvec2 p4 = texture(buffer, fract( uv + vec2(-offset, 0.0) ), 1.0).xy;\n\tvec2 p5 = texture(buffer, fract( uv + vec2(-offset, -offset) * pyt ), 1.0).xy;\n\tvec2 p6 = texture(buffer, fract( uv + vec2(offset, -offset) * pyt ), 1.0).xy;\n\tvec2 p7 = texture(buffer, fract( uv + vec2(offset, offset) * pyt ), 1.0).xy;\n\tvec2 p8 = texture(buffer, fract( uv + vec2(-offset, offset) * pyt ), 1.0).xy;\n\t\n\treturn (p1 + p2 + p3 + p4 + p5 + p6 + p7 + p8) / 8.0;\n}\n\nvec2 get_forward(sampler2D buffer, vec2 uv, float offset, float fadeout) {\n\tfloat forward_fadeout = 0.414 + fadeout / 100.0; //0.414 default\n\tfloat pyt = 0.707107;\n\t\n\tvec2 p1 = texture(buffer, fract( uv + vec2(0.0, -offset) ) ).xy - 0.5;\n\tvec2 p2 = texture(buffer, fract( uv + vec2(offset, -offset) * pyt ) ).xy - 0.5;\n\tvec2 p3 = texture(buffer, fract( uv + vec2(offset, 0.0) ) ).xy - 0.5;\n\tvec2 p4 = texture(buffer, fract( uv + vec2(offset, offset) * pyt) ).xy - 0.5;\n\tvec2 p5 = texture(buffer, fract( uv + vec2(0.0, offset) ) ).xy - 0.5;\n\tvec2 p6 = texture(buffer, fract( uv + vec2(-offset, offset) * pyt) ).xy - 0.5;\n\tvec2 p7 = texture(buffer, fract( uv + vec2(-offset, 0.0) ) ).xy - 0.5;\n\tvec2 p8 = texture(buffer, fract( uv + vec2(-offset, -offset) * pyt) ).xy - 0.5;\n\t\n\tvec2 middle = vec2(0.0, 0.0);\n\t\n\tmiddle.y += clamp(dot(p1, vec2(0.0, 1.0)) * forward_fadeout, 0.0, 1.0);\n\tmiddle.y += clamp(dot(p2, vec2(-pyt, pyt) ) * forward_fadeout, 0.0, 1.0);\n\tmiddle.y += clamp(dot(p8, vec2(pyt, pyt) ) * forward_fadeout, 0.0, 1.0);\n\t\n\tmiddle.x -= clamp(dot(p2, vec2(-pyt, pyt) ) * forward_fadeout, 0.0, 1.0);\n\tmiddle.x -= clamp(dot(p3, vec2(-1.0, 0.0)) * forward_fadeout, 0.0, 1.0);\n\tmiddle.x -= clamp(dot(p4, vec2(-pyt, -pyt) ) * forward_fadeout, 0.0, 1.0);\n\t\n\tmiddle.y -= clamp(dot(p4, vec2(-pyt, -pyt) ) * forward_fadeout, 0.0, 1.0);\n\tmiddle.y -= clamp(dot(p5, vec2(0.0, -1.0)) * forward_fadeout, 0.0, 1.0);\n\tmiddle.y -= clamp(dot(p6, vec2(pyt, -pyt) ) * forward_fadeout, 0.0, 1.0);\n\t\n\tmiddle.x += clamp(dot(p6, vec2(pyt, -pyt) ) * forward_fadeout, 0.0, 1.0);\n\tmiddle.x += clamp(dot(p7, vec2(1.0, 0.0)) * forward_fadeout, 0.0, 1.0);\n\tmiddle.x += clamp(dot(p8, vec2(pyt, pyt) ) * forward_fadeout, 0.0, 1.0);\n\t\n\t// weird drift to the left, compensated by extra tiny vector, removed in Shadertoy version\n\tmiddle = vec2(0.5, 0.5) + middle; // + vec2(0.00015, 0.00015)\n\t\n\treturn middle;\n}\n\nvec2 get_curl(sampler2D buffer, vec2 uv, float offset) {\n\tvec2 middle = vec2(0.0, 0.0);\n\tfloat pyt = 0.707107;\n\t\n\tvec2 p1 = texture(buffer, fract( uv + vec2(0.0, -offset) ), 1.0 ).xy - 0.5;\n\tvec2 p2 = texture(buffer, fract( uv + vec2(0.0, -offset * 2.0) ), 1.0 ).xy - 0.5;\n\tvec2 p3 = texture(buffer, fract( uv + vec2(offset, 0.0) ), 1.0 ).xy - 0.5;\n\tvec2 p4 = texture(buffer, fract( uv + vec2(offset * 2.0, 0.0) ), 1.0 ).xy - 0.5;\n\tvec2 p5 = texture(buffer, fract( uv + vec2(0.0, offset) ), 1.0 ).xy - 0.5;\n\tvec2 p6 = texture(buffer, fract( uv + vec2(0.0, offset * 2.0) ), 1.0 ).xy - 0.5;\n\tvec2 p7 = texture(buffer, fract( uv + vec2(-offset, 0.0) ), 1.0 ).xy - 0.5;\n\tvec2 p8 = texture(buffer, fract( uv + vec2(-offset * 2.0, 0.0) ), 1.0 ).xy - 0.5;\n\t\n\tvec2 p9 = texture(buffer, fract( uv + vec2(offset, -offset) * pyt ), 1.0 ).xy - 0.5;\n\tvec2 p10 = texture(buffer, fract( uv + vec2(offset * 2.0, -offset * 2.0) * pyt ), 1.0 ).xy - 0.5;\n\tvec2 p11 = texture(buffer, fract( uv + vec2(offset, offset) * pyt ), 1.0 ).xy - 0.5;\n\tvec2 p12 = texture(buffer, fract( uv + vec2(offset * 2.0, offset * 2.0) * pyt ), 1.0 ).xy - 0.5;\n\tvec2 p13 = texture(buffer, fract( uv + vec2(-offset, offset) * pyt ), 1.0 ).xy - 0.5;\n\tvec2 p14 = texture(buffer, fract( uv + vec2(-offset * 2.0, offset * 2.0) * pyt ), 1.0 ).xy - 0.5;\n\tvec2 p15 = texture(buffer, fract( uv + vec2(-offset, -offset) * pyt ), 1.0 ).xy - 0.5;\n\tvec2 p16 = texture(buffer, fract( uv + vec2(-offset * 2.0, -offset * 2.0) * pyt ), 1.0 ).xy - 0.5;\n\t\n\tmiddle += ( (p1 - p2) + (p3 - p4) + (p5 - p6) + (p7 - p8) + (p9 - p10) + (p11 - p12) + (p13 - p14) + (p15 - p16) ) * 0.005;\n\t\n\treturn middle;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord/iResolution.xy;\n   \tfloat flow_source = pow(texture(iChannel1, uv).x, 20.0);\n\t\n    vec3 source_direction = vec3(0.0, 0.0, 0.0);\n    \n\tsource_direction.x = sin(iTime * random_dir_speed + source_direction.x) / 3.0 + 0.5;\n\tsource_direction.y = cos(iTime * random_dir_speed + source_direction.y) / 3.0 + 0.5;\n\t\n\tfloat offset = 1.0 / 512.0 * sample_offset;\n\t\n\tvec2 radial_force = vec2(sin(iTime * radial_force_speed) * radial_force_strength / 100.0, cos(iTime * radial_force_speed * 0.83) * radial_force_strength / 100.0);\n\t\n\tvec2 flow_pixel = get_forward(iChannel0, uv + radial_force, offset, forward_modifier) + get_curl(iChannel0, uv, offset * curl_offset) * curl_strength;\n\t\n\tflow_pixel = flow_pixel * (1.0 - blur_strength) + get_average(iChannel0, uv, offset * blur_offset) * blur_strength;\n\t\n\tvec3 output_pixel = vec3(flow_pixel.x, flow_pixel.y, 0.0);\n\t\n\tif (iFrame < 10) {\n\t\tfragColor = vec4(0.5, 0.5, flow_source, 1.0);\n\t}\n\telse {\n\t\tfragColor = vec4((source_direction * flow_source) + output_pixel * (1.0 - flow_source), 1.0);\n\t}\n}","name":"Buffer A","description":"","type":"buffer"}]}