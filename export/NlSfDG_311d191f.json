{"ver":"0.1","info":{"id":"NlSfDG","date":"1653405160","viewed":54,"name":"Fork Question 2 bpaw22 915","username":"bpaw22","description":"Starting point for Question 2 - Basic Shading\n\nDrag mouse for orbit camera.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["shading"],"hasliked":0,"parentid":"XlffR2","parentname":"Question 2 - Basic Shading"},"renderpass":[{"inputs":[{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"///Hi! Thanks so much for all of this fun work!\n\n///The required aspects of this assignment have been implemented. I wanted to touch on the small flavor-adds I included:\n/// - Point light is inside of the red sphere to give the effect of the red sphere being a light source.\n///\n/// - I animated the point light/red sphere combo using a sin/cos combo to animate it in a circle about the y-axis.\n///\n/// - I had time to add an additional feature so I added a \"single+\" ray traced reflection, which required some code consolidation and\n///   refactoring. I tried to comment just enough to describe/explain my thought process.\n///\n\n\n\n///Quick structs for my sanity...\n///NOTE: for speediness, I did not do any optimization eval on how to pack these structs.\n\n// material struct so I can define characteristics on a per-object basis.\nstruct Material\n{\n    vec3 albedo;\n    float shininess;\n    float emissive;\n    float reflectiveness; ///calculated from the shininess; I wanted to put this here so I could do the divide operation only once.\n};\n\n//struct created for directional light definition\nstruct DirectionalLight\n{\n    vec3 col;\n    vec3 dir;\n    float specInt;\n    float diffInt;\n    float ambInt;\n};\n\n//struct created for point light definition\nstruct PointLight\n{\n    vec3 col;\n    vec3 pos;\n    float specInt;\n    float diffInt;\n    float ambInt;\n};\n\n\n\n///Quick global defs of a couple of lights.\n///if we wanted to extend this work, it would be to define a set of directional/point lights.\n\n//A single directional light, per the assignment spec.\nDirectionalLight dLight = DirectionalLight(vec3( 1., 1., 1.), \n                                           vec3(-.5, 1.0, -1.0), \n                                           1., \n                                           .23, \n                                           .1);\n\n//A single point light, per the assignment spec.\nPointLight pLight = PointLight( vec3(.9, .1, .1), \n                                vec3(1., 1., 1.), \n                                1., \n                                1., \n                                1.);\n\n\n// Phong illumination function to be used in the light processing (DoDirLight && DoPointLight).\nvec3 Phong(in vec3 normal, in vec3 viewVector, in vec3 surfacePos, \n            in vec3 nLightDir, in vec3 lightCol, in Material material, \n                in float ambInt, in float diffInt, in float specInt) \n{\n    float dProd = dot(normal, -nLightDir);\n    vec3 reflection = reflect(-nLightDir, normal);\n    \n    vec3 emis = material.emissive * lightCol; //I am treating emissive in a non-PBR way, as the prompt said PBR was not required.\n    vec3 amb = ambInt * lightCol;\n    vec3 diff = max(dProd, 0.0) * diffInt * lightCol;\n    vec3 spec = pow(max(dot(normalize(viewVector), reflection), 0.0), material.shininess) * specInt * lightCol;\n    \n    return emis + amb + diff + spec;\n}\n\n//Quick call for environment mapped reflections. We have this in its own call so we can use it both in the shading of the main\n// ray hit (if the ray cast from our camera hits something), and that of the ray bounce.\nvec3 GetEnviMapAtSurface(vec3 viewDir, vec3 normal)\n{\n    vec3 bounceVec = reflect(normalize(viewDir), normalize(normal));\n    return texture(iChannel0, bounceVec).rgb;\n\n}\n\n//Handles phong illumination for the given directional light, given the material of the object we're trying to illuminate.\nvec3 DoDirLight(in vec3 normal, in vec3 viewVector, in vec3 surfacePos, in Material material, DirectionalLight light)\n{\n    vec3 nLightDir = normalize(light.dir);\n    \n    return Phong(normal, viewVector, surfacePos, nLightDir, light.col, material, light.ambInt, light.diffInt, light.specInt);\n}\n\n//Handles phong illumination for the given point light, given the material of the object we're trying to illuminate.\nvec3 DoPointLight(in vec3 normal, in vec3 viewVector, in vec3 surfacePos, in Material material, in PointLight light)\n{\n    vec3 animatedPosition = vec3(light.pos.x * cos(iTime * 5.), light.pos.y, light.pos.z * sin(iTime * 5.));\n    vec3 nLightDir = normalize(surfacePos - animatedPosition);\n    \n    return Phong(normal, viewVector, surfacePos, nLightDir, light.col, material, light.ambInt, light.diffInt, light.specInt);\n}\n\n//Call to which handles all of the phong-style illumination, per-light. To extend this to handle multiple lights,\n// we could iterate dColor across all DirectionalLight sources in the scene. We would do the same for pointLights.\nvec3 Illuminate(in vec3 normal, in vec3 viewVector, in vec3 surfacePos, in Material material)\n{\n    //normalize!\n    vec3 nNormal = normalize(normal);\n    \n    vec3 dColor = DoDirLight(nNormal, viewVector, surfacePos, material, dLight);\n    vec3 pColor = DoPointLight(nNormal, viewVector, surfacePos, material, pLight);\n    \n    return material.albedo * (dColor + pColor);\n}\n\n//=======================================================================================\nbool RayIntersectAABox  (in vec3 boxMin, in vec3 boxMax, in vec3 rayPos, in vec3 rayDir, out vec3 hitPos, out vec3 normal, inout float maxTime)\n{\n    vec3 boxCenter = (boxMin+boxMax)*0.5;\n\tvec3 roo = rayPos - boxCenter;\n    vec3 rad = (boxMax - boxMin)*0.5;\n\n    vec3 m = 1.0/rayDir;\n    vec3 n = m*roo;\n    vec3 k = abs(m)*rad;\n\t\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\n    vec2 time = vec2( max( max( t1.x, t1.y ), t1.z ),\n                 min( min( t2.x, t2.y ), t2.z ) );\n    \n    // if the time is beyond the maximum allowed bail out (we hit somethign else first!)\n    if (time.x > maxTime)\n        return false;\n    \n    // if time invalid or we hit from inside, bail out\n    if (time.y < time.x || time.x < 0.0)\n        return false;\n\t\n    // calculate surface normal\n    hitPos = rayPos + rayDir * time.x;   \n    vec3 hitPosRelative = hitPos - boxCenter;\n    vec3 hitPosRelativeAbs = abs(hitPosRelative);\n    vec3 distToEdge = abs(hitPosRelativeAbs - rad);\n\n    float closestDist = 1000.0;\n    for(int axis = 0; axis < 3; ++axis)\n    {\n        if (distToEdge[axis] < closestDist)\n        {\n            closestDist = distToEdge[axis];\n            normal = vec3(0.0);\n            if (hitPosRelative[axis] < 0.0)\n                normal[axis] = -1.0;\n            else\n                normal[axis] = 1.0;\n        }\n    }        \n\n    // store the collision time as the new max time\n    maxTime = time.x;\n    return true;\n}\n\n//=======================================================================================\nbool RayIntersectSphere (in vec4 sphere, in vec3 rayPos, in vec3 rayDir, out vec3 hitPos, out vec3 normal, inout float maxTime)\n{\n    if (sphere.w <= 0.0)\n        return false;\n    \n\t//get the vector from the center of this circle to where the ray begins.\n\tvec3 m = rayPos - sphere.xyz;\n\n    //get the dot product of the above vector and the ray's vector\n\tfloat b = dot(m, rayDir);\n\n\tfloat c = dot(m, m) - sphere.w * sphere.w;\n\n\t//exit if r's origin outside s (c > 0) and r pointing away from s (b > 0)\n\tif(c > 0.0 && b > 0.0)\n\t\treturn false;\n\n\t//calculate discriminant\n\tfloat discr = b * b - c;\n\n\t//a negative discriminant corresponds to ray missing sphere\n\tif(discr < 0.0)\n\t\treturn false;\n\n\t//ray now found to intersect sphere, compute smallest t value of intersection\n\tfloat collisionTime = -b - sqrt(discr);\n\n\t//if t is negative, ray started inside sphere so clamp t to zero and remember that we hit from the inside\n\tif(collisionTime < 0.0)\n        return false;\n    \n    // if the time is beyond the maximum allowed bail out (we hit somethign else first!)\n    if (collisionTime > maxTime)\n        return false;\n    \n    // store the collision time as the new max time\n    maxTime = collisionTime;\n    \n\t//compute the point of intersection\n\thitPos = rayPos + rayDir * collisionTime;    \n    \n   \t// calculate the normal\n\tnormal = hitPos - sphere.xyz;\n\tnormal = normalize(normal); \n\n\treturn true;\n}\n\n//I spun this out of the originally provided shade pixel call.\n//I wanted to re-use this work code when calculating my single+ bounce ray traced reflections. \nbool RayTrace(in vec3 rayPos, in vec3 rayDir, out vec3 hitPos, out vec3 normal, out Material material)\n{\n    float maxRayHitTime = 1000.0;\n    bool hit = false;\n    \n    // green box\n    if (RayIntersectAABox(vec3(0.4,-0.3,-0.5), vec3(1.4,0.3,0.5), rayPos, rayDir, hitPos, normal, maxRayHitTime))\n    {\n        hit = true;\n        material.albedo = vec3(0.1, 0.9, 0.1);\n        material.emissive = 0.05;\n        material.shininess = 16.0;\n        material.reflectiveness = material.shininess / 256.;\n    }\n\t\n    // red sphere / point light\n    if (RayIntersectSphere(vec4(pLight.pos.x * cos(iTime * 5.), pLight.pos.y, pLight.pos.z * sin(iTime * 5.), 0.4), rayPos, rayDir, hitPos, normal, maxRayHitTime))\n    {\n        hit = true;\n        material.albedo = pLight.col * .5;\n        material.emissive = 0.1;\n        material.shininess = 8.0;\n        material.reflectiveness = material.shininess / 256.;\n    }\n    \n    // blue sphere\n    if (RayIntersectSphere(vec4(-0.8, 0.4, -0.75, 0.25), rayPos, rayDir, hitPos, normal, maxRayHitTime))\n    {\n        hit = true;\n        material.albedo = vec3(0.1, 0.1, 0.9);\n        material.emissive = 0.1;\n        material.shininess = 16.;\n        material.reflectiveness = material.shininess / 256.;\n    }\n    \n    // BIIIG SPHERRRRRE\n    if (RayIntersectSphere(vec4(0.0, -7., 3.0, 2.0), rayPos, rayDir, hitPos, normal, maxRayHitTime))\n    {\n        hit = true;\n        material.albedo = vec3(0.1, 0.1, 0.1);\n        material.emissive = 0.0;\n        material.shininess = 56.;\n        material.reflectiveness = material.shininess / 256.;\n    }\n    \n    \n    return hit;\n}\n\n// Implementation of single+ bounce raytraced reflections. I say \"single+\" as I sample the cubemap of the hit object, if we _did_ hit\n// an object.\nbool ShadeRayBounce(in vec3 hitNormal, in vec3 sourceRay, in vec3 sourceRayHitPos, out vec3 bounceColor)\n{\n    bool hit;\n    vec3 bPos;\n    vec3 bNorm;\n    vec3 bRay = reflect(sourceRay, hitNormal);\n    Material bMat;\n    \n    //\n    hit = RayTrace(sourceRayHitPos, bRay, bPos, bNorm, bMat);\n    \n    //preload with missed bounce color, if we need to.\n    bounceColor = GetEnviMapAtSurface( sourceRay, hitNormal );\n    \n    if(hit) // we have a ray hit! let's color it appropriately.\n    {\n        bounceColor = Illuminate(bNorm, bRay, bPos, bMat);\n        bounceColor += GetEnviMapAtSurface( bRay, bNorm ) * bMat.reflectiveness;\n    }\n        \n    return hit;\n}\n\n//Renamed this more descriptively identify that this is they ray's entrypoint.\nvec3 ShadeMainPixel (in vec3 normal, in vec3 viewVector, in vec3 surfacePos, Material material)\n{\n\n    vec3 finalColor; \n    \n    //we try to shade a ray bounce. we use that hit boolean to figure out if we need to do a baseline environment mapping pass.\n    bool hit = ShadeRayBounce(normal, viewVector, surfacePos, finalColor);\n    finalColor *= material.reflectiveness;\n    \n    finalColor += Illuminate(normal, viewVector, surfacePos, material);\n\treturn finalColor;\n}\n\n//=======================================================================================\nvoid DoRayTrace(in vec3 rayPos, in vec3 rayDir, inout vec3 pixelColor)\n{\n    vec3 hitPos;    \n    vec3 normal;\n    bool hit = false;\n    Material material;\n    \n    hit = RayTrace(rayPos, rayDir, hitPos, normal, material);\n    \n    if(!hit)\n        return;\n    \n    pixelColor = ShadeMainPixel(normal, rayDir, hitPos, material);\n}\n\n//=======================================================================================\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    //----- camera setup\n    vec2 mouse = iMouse.xy / iResolution.xy;\n\n    vec3 cameraAt \t= vec3(0.0,0.0,0.0);\n\n    float angleX = iMouse.z > 0.0 ? 6.28 * mouse.x : 0.0;\n    float angleY = iMouse.z > 0.0 ? (mouse.y * 6.28) : 0.0;\n\n    vec3 cameraPos\t= (vec3(sin(angleX)*cos(angleY), sin(angleY), cos(angleX)*cos(angleY))) * 4.0;\n\n    vec3 cameraFwd  = normalize(cameraAt - cameraPos);\n    vec3 cameraLeft  = normalize(cross(normalize(cameraAt - cameraPos), vec3(0.0,sign(cos(angleY)),0.0)));\n    vec3 cameraUp   = normalize(cross(cameraLeft, cameraFwd));\n\n    float cameraViewWidth\t= 6.0;\n    float cameraViewHeight\t= cameraViewWidth * iResolution.y / iResolution.x;\n    float cameraDistance\t= 6.0;  // intuitively backwards!    \n    \n\tvec2 rawPercent = (fragCoord.xy / iResolution.xy);\n\tvec2 percent = rawPercent - vec2(0.5,0.5);\n\t\n\tvec3 rayPos;\n\tvec3 rayTarget;\n\t   \n\t// if the mouse button is down do orbit camera\n\tif( iMouse.z > 0.0 ) {\n\t\trayTarget = (cameraFwd * cameraDistance)\n\t\t\t\t  + (cameraLeft * percent.x * cameraViewWidth)\n\t\t          + (cameraUp * percent.y * cameraViewHeight);\n\t\t\n\t\trayPos = cameraPos;\n\t}\n\t// else handle the case of the mouse button not being down\n\telse {\n\t\trayPos = vec3(0.0,3.0,-3.0);\n\t\tvec3 f = normalize(cameraAt - rayPos);\n\t\tvec3 l = normalize(cross(f,vec3(0.0,1.0,0.0)));\n\t\tvec3 u = normalize(cross(l,f));\n\t\t\n\t\trayTarget = (f * cameraDistance)\n\t\t\t\t  + (l * percent.x * cameraViewWidth)\n\t\t          + (u * percent.y * cameraViewHeight);\t\t\n\t}\n    \n\t//----- ray trace\n\tvec3 rayDir = normalize(rayTarget);\n    \n    // initialze ray color to the cube map\n    vec3 pixelColor = texture(iChannel0, rayDir).rgb;\n    \n    // ray trace\n\tDoRayTrace(rayPos, rayDir, pixelColor);\n    \n    // output sRGB corrected pixel\n    pixelColor = pow(pixelColor, vec3(1.0/2.2)); \n    \n    vec2 uv = fragCoord / iResolution.xy;\n    \n\tfragColor = vec4(pixelColor, 1.0);\n}\n\n/*\n\nAdd:\n* point light and directional light (diffuse + specular. Doesn't need to be PBR. Lambert / phong is ok!)\n* ambient lighting\n* emissive lighting\n* environment mapped reflections\n\n* One other feature to make it unique / show off your stuff. Some ideas:\n * shadows\n * Normal or bump mapping\n * ray based reflections\n * anti aliasing\n * lens effects\n * post processing effects\n * warping geometry, more complex geometry\n * animating the camera, lights or geometry.\n * refraction or transparency\n * anything else you can think of\n\n*/","name":"Image","description":"","type":"image"}]}