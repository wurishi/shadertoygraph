{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[],"code":"// ShaderToy Combined Shader\n#define MAX_STEPS 100\n#define MAX_DIST 100.0\n#define SURF_DIST 0.01\n\nfloat gTime = 0.0;\n\n// Palette function for vibrant colors\nvec3 palette(float t) {\n    return mix(vec3(0.2, 0.7, 0.9), vec3(1.0, 0.0, 1.0), t);\n}\n\n// 2D rotation\nmat2 rot(float a) {\n    float c = cos(a), s = sin(a);\n    return mat2(c, s, -s, c);\n}\n\n// Signed distance to a 3D box\nfloat sdBox(vec3 p, vec3 b) {\n    vec3 q = abs(p) - b;\n    return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);\n}\n\n// Box set with motion and dynamic transformation\nfloat box_set(vec3 pos) {\n    vec3 origin = pos;\n\n    // Dynamic motion\n    pos.xy *= rot(gTime * 0.2);\n    pos.z += sin(gTime * 0.5) * 3.0;\n\n    // Combine multiple boxes\n    float d1 = sdBox(pos, vec3(1.0));\n    pos = origin;\n    pos.xz *= rot(gTime * 0.3);\n    float d2 = sdBox(pos, vec3(0.7));\n    \n    return min(d1, d2);\n}\n\n// Star signed distance function for 2D patterns\nfloat sdStar(vec2 p, float r, int n, float m) {\n    float an = 3.141593 / float(n);\n    float en = 3.141593 / m;\n    vec2 acs = vec2(cos(an), sin(an));\n    vec2 ecs = vec2(cos(en), sin(en));\n\n    float bn = mod(atan(p.x, p.y), 2.0 * an) - an;\n    p = length(p) * vec2(cos(bn), abs(sin(bn)));\n    p -= r * acs;\n    p += ecs * clamp(-dot(p, ecs), 0.0, r * acs.y / ecs.y);\n    return length(p) * sign(p.x);\n}\n\n// Raymarching scene map\nfloat map(vec3 pos) {\n    float d = box_set(pos);\n    return d;\n}\n\n// Raymarching function\nvec4 rayMarch(vec3 ro, vec3 rd) {\n    float t = 0.0;\n    vec3 col = vec3(0.0);\n    float d;\n\n    for (int i = 0; i < MAX_STEPS; i++) {\n        vec3 p = ro + rd * t;\n        d = map(p);\n        if (d < SURF_DIST || t > MAX_DIST) break;\n        t += d;\n        \n        // Add color contributions based on palette\n        float c = length(p) * 0.02;\n        col += palette(c) / (100.0 * d);\n    }\n\n    if (d < SURF_DIST) {\n        col *= 2.0; // Brighten near the surface\n    }\n\n    return vec4(col, 1.0 - t * 0.01);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n\n    // Camera setup\n    vec3 ro = vec3(0.0, 0.0, -5.0); // Ray origin\n    vec3 rd = normalize(vec3(uv, 1.0)); // Ray direction\n\n    gTime = iTime; // Time-based motion\n    rd.xy *= rot(sin(iTime * 0.3)); // Add rotation effect\n\n    // Perform raymarching\n    vec4 col = rayMarch(ro, rd);\n\n    // Add star shape overlay for extra complexity\n    float star = smoothstep(0.01, -0.01, sdStar(uv, 0.4, 5, 0.2));\n    col.rgb += star * vec3(1.0, 0.8, 0.5);\n\n    fragColor = col;\n}\n","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"4cKfDK","date":"1734461093","viewed":94,"name":"IceCewb","username":"profmitchell","description":"boxes in circles and stuff","likes":6,"published":3,"flags":0,"usePreview":0,"tags":["glow","box","neon"],"hasliked":0,"parentid":"","parentname":""}}