{"ver":"0.1","info":{"id":"mlSfWD","date":"1694059998","viewed":63,"name":"Yet Another Snake Game","username":"twixuss","description":"More info in comments.","likes":10,"published":1,"flags":48,"usePreview":0,"tags":["game","interactive","snake"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//\n// Game speed and other configurable parameters are in Common tab.\n//\n\nfloat letter(vec2 uv, int code) {\n    ivec2 c = ivec2(code%16,code/16);\n    c.y = 15 - c.y;\n    return texture(iChannel2, clamp(uv,0.0,1.0)/16.f+vec2(c)/16.).x;\n}\n\nfloat lengthsq(vec2 x) { return dot(x,x); }\n\nfloat squircle(vec2 a) {\n    return pow(abs(a.x*a.x*a.x) + abs(a.y*a.y*a.y), 1.0/3.0);\n}\nbool shouldConnect(ivec4 cell, ivec2 guv, ivec4 player) {\n    ivec4 otherCell = ivec4(LOAD(guv));\n    return abs(otherCell.x - cell.x) <= 1 && otherCell.x < player.w;\n}\nfloat smin(float a, float b, float k) {\n\tfloat h = clamp((b - a) / k + 0.5, 0.0, 1.0);\n\treturn b + h * (a - b + k * 0.5f * (h - 1.0));\n}\nvec4 bezier3(vec4 a, vec4 b, vec4 c, float t) {\n    return\n        + 1.0 * a * t * t\n        - 2.0 * b * t * t\n        + 1.0 * c * t * t\n        - 2.0 * a * t\n        + 2.0 * b * t\n        + 1.0 * a\n    ;\n}\nfloat pow2(float x) {return x*x;}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.y;\n    uv.x -= (iResolution.x-iResolution.y)/iResolution.y*0.5;\n\n    if (0.0 > uv.x || uv.x > 1.0) {\n        fragColor = vec4(0);\n        return;\n    }\n        \n    ivec2 guv = ivec2(uv * float(GRID_SIZE));\n    \n    ivec4 cell = ivec4(LOAD(guv));\n    \n    vec4 gsf = LOAD(L_GAMESTATE);\n    ivec4 gs = ivec4(gsf);\n    ivec4 player = ivec4(LOAD(L_PLAYER));\n    ivec4 playerCell = ivec4(LOAD(player.xy));\n    \n    vec2 b = fract(uv*float(GRID_SIZE))*2.0-1.0;\n    \n    vec4 backgroundColor = vec4(0.15 + 0.025 * sin(4.0*dot(uv, vec2(1,-2))) + 0.025 * sin(4.0*dot(uv, vec2(-1,-2))));\n    backgroundColor *= 1.0-lengthsq(fract(uv*float(GRID_SIZE))-0.5);\n    backgroundColor *= 1.5-max(0.0, smoothstep(1.0, 0.0, length(b)))*(cos(clamp(dot(exp(-b-1.0), vec2(1,1))*4.0 - 5.5, -3.1415, +3.1415)) * 0.5 + 0.5);\n    \n    fragColor = backgroundColor;\n    \n    // Food\n    if (cell.y > 0) {        \n        //vec4 foodColor = bezier3(vec4(1,0.5,0,0), vec4(1.1,1.1,0,0), vec4(0.5,1,0,0), dot(b, vec2(0.7))*0.5+0.5);\n        vec4 foodColor = bezier3(vec4(0.5,0.05,0.05,0), vec4(1.5), vec4(0.9,0.1,0.1,0), pow(dot(b, vec2(0.7))*0.5+0.5, 4.0));\n        fragColor = mix(fragColor, foodColor, vec4(smoothstep(0.0, 0.05, 1.0-squircle(b))));\n    }\n    // Snake\n    if (cell.x < player.w) {\n        float m = squircle(b);\n        if (guv.x < GRID_SIZE-1 && shouldConnect(cell, guv + ivec2(+1,0), player)) m = smin(m, squircle(vec2(min(0.0, b.x), b.y)), 0.5);\n        if (guv.x > 0           && shouldConnect(cell, guv + ivec2(-1,0), player)) m = smin(m, squircle(vec2(max(0.0, b.x), b.y)), 0.5);\n        if (guv.y < GRID_SIZE-1 && shouldConnect(cell, guv + ivec2(0,+1), player)) m = smin(m, squircle(vec2(b.x, min(b.y, 0.0))), 0.5);\n        if (guv.y > 0           && shouldConnect(cell, guv + ivec2(0,-1), player)) m = smin(m, squircle(vec2(b.x, max(b.y, 0.0))), 0.5);\n        \n        vec4 bodyColor = vec4(0.2, 0.8, 0.1, 1.0);\n        bodyColor += vec4(0.1, 0.05, 0.0, 0.0) * sin(dot(uv, vec2(2,1)*float(GRID_SIZE)*3.1415*0.5));\n        bodyColor += vec4(0.1, 0.05, 0.0, 0.0) * sin(dot(uv, vec2(1,2)*float(GRID_SIZE)*3.1415*0.707));\n        if (guv == player.xy)\n        {\n            vec2 d = vec2(toDirection(player.z));\n            vec2 o = d;\n            o = vec2(o.y, o.x) * 0.5;\n            bodyColor = mix(vec4(0), bodyColor, vec4(smoothstep(0.1, 0.15, min(length(b - d * 0.4 + o), length(b - d * 0.4 - o)))));\n        }\n        \n        bodyColor += max(0.0, smoothstep(1.0, 0.0, length(b)))*(cos(clamp(dot(exp(b-1.0), vec2(1,1))*4.0 - 5.5, -3.1415, +3.1415)) * 0.5 + 0.5);\n        \n        fragColor = mix(fragColor, bodyColor*(1.0-(m*m)*0.5), vec4(smoothstep(0.1, 0.15, 1.0 - m)));\n    }\n\n#define X(p,l,a) \\\n    else if (fuv == ivec2(p, 0)) { \\\n        fragColor = mix(fragColor, vec4(0), a*letter(tuv+vec2(-0.1,0.1), l)); \\\n        fragColor = mix(fragColor, vec4(1), a*letter(tuv, l)); \\\n    }\n\n    float textT = smoothstep(0.0, 1.0, gsf.z);\n\n    fragColor *= mix(1.0, 0.5, textT);\n    \n    //fragColor = mix(fragColor, vec4(0), vec4(smoothstep(1.0, 1.1, (atan(uv.y-0.5,uv.x-0.5)+3.14)/6.28 + clamp(gsf.w - iTime - 1.0/float(SPEED_FACTOR), 0.0, 1.0))));\n    //clamp(gsf.w - iTime - 1.0/float(SPEED_FACTOR), 0.0, 1.0)\n    \n    if (gs.x != 0) {\n        if (gs.x == 1) {\n\n            // Game Over\n            vec2 tuv = uv*10. - vec2(0.5, 5.5);\n            ivec2 fuv = ivec2(floor(tuv));\n            tuv = fract(tuv);\n            if (false) {}\n            X(0, KG, textT)\n            X(1, KA, textT)\n            X(2, KM, textT)\n            X(3, KE, textT)\n            X(5, KO, textT)\n            X(6, KV, textT)\n            X(7, KE, textT)\n            X(8, KR, textT)\n        } else if (gs.x == 2) {\n\n            // You won\n            vec2 tuv = uv*10. - vec2(1.5, 5.5);\n            ivec2 fuv = ivec2(floor(tuv));\n            tuv = fract(tuv);\n            if (false) {}\n            X(0, KY, textT)\n            X(1, KO, textT)\n            X(2, KU, textT)\n            X(4, KW, textT)\n            X(5, KO, textT)\n            X(6, KN, textT)\n        }\n        \n\n        // Press R\n        vec2 tuv = uv*10. - vec2(1.5, 3.5);\n        ivec2 fuv = ivec2(floor(tuv));\n        tuv = fract(tuv);\n        if (false) {}\n        X(0, KP, textT)\n        X(1, KR, textT)\n        X(2, KE, textT)\n        X(3, KS, textT)\n        X(4, KS, textT)\n        X(6, KR, textT)\n    }\n    \n    float helpT = smoothstep(3.0, 2.0, iTime);\n    \n    if (helpT > 0.0) {\n        {\n            // Use\n            vec2 tuv = uv*10. - vec2(3.5, 8.0);\n            ivec2 fuv = ivec2(floor(tuv));\n            tuv = fract(tuv);\n            if (false) {}\n            X(0, KU, helpT)\n            X(1, KS, helpT)\n            X(2, KE, helpT)\n        }\n        {\n            // Use\n            vec2 tuv = uv*10. - vec2(0.0, 7.0);\n            ivec2 fuv = ivec2(floor(tuv));\n            tuv = fract(tuv);\n            if (false) {}\n            X(0, KW, helpT)\n            X(1, KA, helpT)\n            X(2, KS, helpT)\n            X(3, KD, helpT)        \n            X(4, KSLASH, helpT)        \n            X(5, KA, helpT)        \n            X(6, KR, helpT)        \n            X(7, KR, helpT)        \n            X(8, KO, helpT)        \n            X(9, KW, helpT)        \n            X(10, KS, helpT)        \n        }\n\n    }\n    \n    // Score\n    int score = player.w;\n    \n    int score0 = score % 10;\n    int score1 = (score / 10) % 10;\n    int score2 = (score / 100) % 10;\n    \n    vec2 tuv = uv*10.;\n    ivec2 fuv = ivec2(floor(tuv));\n    tuv = fract(tuv);\n    if (false) {}\n    X(0, K0+score2, 0.25)\n    X(1, K0+score1, 0.25)\n    X(2, K0+score0, 0.25)\n    \n    //fragColor = vec4(fract(gsf.w));\n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Data format:\n//   Grid: \n//     x: uint - frames since head visited this cell.\n//     y: bool - has food.\n//   Game State:\n//     x: 0 - playing\n//        1 - game over\n//        2 - win\n//     y: uint - n updates performed\n//     z: float[0;1] - state transition t\n//     w: float - next update time\n//   Player:\n//     xy: uint     - location\n//     z: uint[0;3] - direction\n//     w: uint      - length\n//   Input:\n//     x: uint - Last pressed key\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 uv = ivec2(fragCoord);\n    if (iFrame == 0 || keyDown(KR)) {\n        if (iFrame == 0)\n            fragColor = vec4(0);\n        else\n            fragColor = LOAD(uv);\n    \n        if (uv.x < GRID_SIZE && uv.y < GRID_SIZE)\n            fragColor = vec4(GRID_SIZE*GRID_SIZE,0,0,0);\n\n        ivec2 startCoord = START_PLAYER_COORD;\n        if (uv == startCoord) {\n            fragColor.x = 0.0;\n        }\n        if (uv == L_PLAYER) {\n            fragColor = vec4(startCoord, 0, START_PLAYER_SIZE);\n        }\n        \n        // Food\n        if (uv == START_FOOD_COORD) {\n            fragColor.y = 1.0;\n        }\n        \n        if (uv == L_GAMESTATE) {\n            fragColor.x = 0.0;\n            fragColor.y = 0.0;\n            if (iFrame == 0) {\n                fragColor.z = 1.0;\n            }\n            fragColor.w = iTime + 1.0 / float(SPEED_FACTOR);\n        }\n        \n        if (uv == L_INPUT) {\n            fragColor = vec4(0);\n        }\n        \n        return;\n    }\n    \n    fragColor = LOAD(uv);\n    \n    vec4 gsf = LOAD(L_GAMESTATE);\n    ivec4 gs = ivec4(gsf);\n    \n    // Do nothing if lost or won\n    if (gs.x != 0) {\n        if (uv == L_GAMESTATE) {\n            // Fade to text\n            fragColor.z = min(1.0, fragColor.z + iTimeDelta);\n        }\n        return;\n    }\n    \n    if (uv == L_GAMESTATE) {\n        // Fade to game\n        fragColor.z = max(0.0, fragColor.z - iTimeDelta);\n    }\n    \n    // Store input so it does not get lost between updates.\n    bool W = keyDown(KW) || keyDown(KUP);\n    bool A = keyDown(KA) || keyDown(KLEFT);\n    bool S = keyDown(KS) || keyDown(KDOWN);\n    bool D = keyDown(KD) || keyDown(KRIGHT);\n    if (uv == L_INPUT) {\n        if (fragColor.y > 0.0) {\n            if (W) fragColor.z = float(KW);\n            if (A) fragColor.z = float(KA);\n            if (S) fragColor.z = float(KS);\n            if (D) fragColor.z = float(KD);\n        } else if (fragColor.x > 0.0) {\n            if (W) fragColor.y = float(KW);\n            if (A) fragColor.y = float(KA);\n            if (S) fragColor.y = float(KS);\n            if (D) fragColor.y = float(KD);\n        } else {\n            if (W) fragColor.x = float(KW);\n            if (A) fragColor.x = float(KA);\n            if (S) fragColor.x = float(KS);\n            if (D) fragColor.x = float(KD);\n        }\n    }\n\n    // Slowmo\n    if (iTime < gsf.w)\n        return;\n    \n    if (uv == L_GAMESTATE) {\n        // Update time\n        fragColor.w += 1.0 / float(SPEED_FACTOR);\n    }\n    \n    ivec4 player = ivec4(LOAD(L_PLAYER));\n    \n    // Update move direction\n    int inp = int(LOAD(L_INPUT).x);\n    W = W || inp == KW;\n    A = A || inp == KA;\n    S = S || inp == KS;\n    D = D || inp == KD;\n    /**/ if (W && player.z != 3) player.z = 1;\n    else if (A && player.z != 0) player.z = 2;\n    else if (S && player.z != 1) player.z = 3;\n    else if (D && player.z != 2) player.z = 0;\n    \n    if (uv.x < GRID_SIZE && uv.y < GRID_SIZE)\n        fragColor.x += 1.0;\n        \n    if (uv == player.xy + toDirection(player.z)) {\n        fragColor.x = 0.0;\n    }\n    \n    player.xy += toDirection(player.z);\n    \n    ivec4 playerCell = ivec4(LOAD(player.xy));\n    \n    // Eat Food\n    if (playerCell.y > 0) {\n        // Add Player Length\n        player.w += 1;\n        \n        // Remove Food\n        if (uv == player.xy) {\n            fragColor.y = 0.;\n        }\n        \n        // Place New Food\n        uint r = timerand();\n        int i;\n        for (i = 0; i < GRID_SIZE*GRID_SIZE; ++i) {\n            r %= uint(GRID_SIZE*GRID_SIZE);\n            ivec2 newFoodPos = ivec2(r%uint(GRID_SIZE), r/uint(GRID_SIZE));\n            ivec4 cell = ivec4(LOAD(newFoodPos));\n            if (cell.x < player.w || cell.y != 0) {\n                r += 1u;\n                continue;\n            }\n            \n            if (uv == newFoodPos) {\n                fragColor.y = 1.0;\n            }\n            break;\n        }\n        if (i == GRID_SIZE*GRID_SIZE) {\n            if (uv == L_GAMESTATE) {\n                fragColor.x = 2.0;\n            }\n        }\n    }\n    \n    // Write player data\n    if (uv == L_PLAYER) {\n        fragColor = vec4(player);\n    }\n    \n    // Update game time\n    if (uv == L_GAMESTATE) {\n        fragColor.y += 1.;\n        // Game Over Condition\n        if (playerCell.x < (player.w-1) || player.x < 0 || player.x >= GRID_SIZE || player.y < 0 || player.y >= GRID_SIZE) {\n            fragColor.x = 1.;\n        }\n    }\n    \n    \n    // Reset the input\n    if (uv == L_INPUT) {\n        fragColor = vec4(fragColor.yz, 0, 0);\n    }\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"//\n// Config\n//\n\n#define GRID_SIZE 10\n#define START_PLAYER_SIZE 4\n#define START_PLAYER_COORD ivec2(0, 3)\n#define START_FOOD_COORD ivec2(1, 1)\n\n// Increase this number to speed up the game.\n#define SPEED_FACTOR 5\n\n// ======================================================================================================================\n\n//\n// Storage locations\n//\n\n#define L_GAMESTATE ivec2(GRID_SIZE+1, 0)\n#define L_PLAYER    ivec2(GRID_SIZE+1, 1)\n#define L_INPUT     ivec2(GRID_SIZE+1, 2)\n\n#define LOAD(L) texelFetch(iChannel0, L, 0)\n\n// \n// Utilities\n//\n\nuint rand(uint x) {\n    const uint k = 3282017729u;\n    x *= k; x ^= k;\n    x *= k; x ^= k;\n    x *= k; x ^= k;\n    x *= k; x ^= k;\n    return x;\n}\n\n// This is not a function because iFrame is not available in common\n#define timerandp(seed) rand(uint(dot(vec3(iFrame, iDate.w, seed), vec3(123, 456, 789))))\n#define timerand() timerandp(0u)\n\nfloat u2f(uint x) {\n    x >>= 9;\n    x |= 0x3f800000u;\n    return uintBitsToFloat(x) - 1.0;\n}\n#define KA 65\n#define KC 67\n#define KD 68\n#define KE 69\n#define KG 71\n#define KM 77\n#define KN 78\n#define KO 79\n#define KP 80\n#define KR 82\n#define KS 83\n#define KU 85\n#define KV 86\n#define KW 87\n#define KY 89\n#define KSLASH 47\n#define K0 48\n#define KLEFT  37\n#define KUP    38\n#define KRIGHT 39\n#define KDOWN  40\n\n#define keyDown(keyCode) (texelFetch(iChannel1, ivec2(keyCode, 1), 0).x > 0.5)\n\nivec2 toDirection(int f) {\n    switch (f) {\n        case 0: return ivec2(1, 0);\n        case 1: return ivec2(0, 1);\n        case 2: return ivec2(-1, 0);\n        default: return ivec2(0,-1);\n    }\n}\n\n","name":"Common","description":"","type":"common"}]}