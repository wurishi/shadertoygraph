{"ver":"0.1","info":{"id":"XtVfzW","date":"1542016691","viewed":158,"name":"Grid & Stochastic Antialiasing","username":"dacruzquen","description":"antialiasing","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["antialiasing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//link : \n\n//Material\nstruct Material\n{\n    float Ka;\n    float Kd;\n    float Ks;\n    float Kn;\n};\n\n//camera parameters\nvec3 cameraPos = vec3(6,4,-5);\nconst vec3 cameraTarget = vec3(3,1,-8);\nconst float cameraFovY = 80.0; // Note: angle is degree\n\n//Sphere parameters\nvec3 spherePos = cameraTarget + vec3(0,1,2);\nconst float sphereRadius = 1.0;\nconst vec3 sphereCol = vec3(1,0,0);\nconst Material sphereMat = Material(0.2,0.7,1.0,50.0);\nconst int sphereId = 1;\n\n//Light parameters\nconst vec3 ambiantCol = vec3(0,0,1);\nconst vec3 lightCol = vec3(1,1,1);\nvec3 lightPos = vec3(8,10,-12);\n\n//Sky parameters\nconst vec3 skyCol = vec3(0);\nconst int skyId = 0;\n\n//Plane parameters\nconst vec3 planePos = vec3(0, 0.1, 0);\nconst vec3 planeNormal = vec3(0,1.0,0);\nconst vec3 planeCol1 = vec3(1.0);\nconst vec3 planeCol2 = vec3(0.4);\nconst Material planeMat = Material(0.2,1.0,0.2,5.0);\nconst int planeId = 2;\n\nconst int PIXEL_SAMPLING_GRID_SIZE = 5;\nconst int PIXEL_SAMPLING_SIZE = 25;\n\nvec2 transform_to_apply(vec2 xy){\n    xy = (2.*xy.xy - iResolution.xy)/iResolution.y;\n    return vec2(xy.x,xy.y);\n}\n\nfloat raySphere(vec3 rayPos, vec3 rayDir, vec3 spherePos, float sphereRadius, out vec3 intersecS, out vec3 normalS)\n{    \n    vec3 diff = rayPos - spherePos;\n    \n    float a = dot(rayDir,rayDir);\n    float b = 2.0 * dot(diff,rayDir);\n    float c = dot(diff,diff) - sphereRadius * sphereRadius;\n    \n    float di = b*b - 4.0*a*c;\n    \n    if(di >= 0.0)\n    {\n        float sdi = sqrt(di);\n        float den = 1.0 / (2.0 * a);\n        float t1 = (-b - sdi) * den;\n        float t2 = (-b + sdi) * den;\n        \n        intersecS = rayPos + t1 * rayDir;\n        normalS = normalize(intersecS - spherePos);\n        \n        return t1;\n    }\n    \n    return -1.;\n}\n\nfloat rayPlane(vec3 rayPos, vec3 rayDir, vec3 planePos, vec3 planeNormal, out vec3 intersecPt, out vec3 normal)\n{\n    if(dot(rayDir,planeNormal)!=0.0)\n    {\n        float t = dot(planePos - rayPos,planeNormal)/dot(rayDir,planeNormal);\n        \n        intersecPt = rayPos + t * rayDir;\n        normal = planeNormal;\n        \n        return t;\n    }\n    return -1.0;\n}\n\nvoid computeCameraRayFromPixel(in vec2 pixCoord, out vec3 rayPos, out vec3 rayDir)\n{\n    rayPos = cameraPos;\n    \n    float f = 1./tan(radians(cameraFovY)/2.);\n    \n    vec3 PT = cameraTarget - cameraPos;\n    vec3 cz = normalize(PT);\n    \n    vec3 PO = f*cz;\n    \n    vec3 cyT = vec3(0,-1.,0);\n    vec3 cxT = cross(cyT,cz);\n    \n    vec3 cx = normalize(cxT);\n    \n    vec3 cy = cross(cz,cx);\n    \n    vec3 OS = pixCoord.x * cx - pixCoord.y * cy;\n    \n    rayDir = normalize(PO+OS);\n}\n\nvec3 computePhongShading(vec3 sphereCol, Material sphereMat,float shadowFactor, vec3 normal, vec3 L, vec3 R, vec3 V)\n{\n    vec3 A = sphereMat.Ka * ambiantCol;\n    vec3 D = sphereMat.Kd * sphereCol * lightCol * max(dot(L,normal),0.0);\n    vec3 S = sphereMat.Ks * lightCol * pow(max(dot(R,V),0.0),sphereMat.Kn);\n    return A+shadowFactor*D+shadowFactor*S;\n}\n\n//The aim of this routine is to find the nearest intersection the ray has with all objects\nfloat computeNearestIntersection(vec3 rayPos, vec3 rayDir, out int objectId, out vec3 intersecI, out vec3 normalI)\n{\n    vec3 intersecS, normalS;\n    float distSphere = raySphere(rayPos, rayDir, spherePos, sphereRadius, intersecS, normalS);\n    vec3 intersecP, normalP;\n    float distPlane = rayPlane(rayPos, rayDir, planePos, planeNormal, intersecP, normalP);\n    if(distSphere > 0.0 && distPlane > 0.0)\n    {\n        float distMin = min(distSphere,distPlane);\n        objectId = (distSphere == distMin) ? sphereId : planeId; \n        intersecI = (distSphere == distMin) ? intersecS : intersecP; ;\n        normalI = (distSphere == distMin) ? normalS : normalP; ;\n        return distMin;\n    }\n    else\n    {\n        if(distSphere > 0.0)\n        {\n            objectId = sphereId;\n            intersecI = intersecS;\n            normalI = normalS;\n            return distSphere;\n        }\n        else if (distPlane > 0.0)\n        {\n            objectId = planeId;\n            intersecI = intersecP;\n            normalI = normalP;\n            return distPlane;\n        }\n        else\n        {\n           \tobjectId = skyId;\n            return -1.0;\n        }\n    }\n}\n\nvec3 getSphereColorAtPoint(vec3 pt)\n{\n    return sphereCol;\n}\n\n//pt is assumed to be on the place surface\nvec3 getPlaneColorAtPoint(vec3 pt)\n{\n    return mod(floor(pt.x*0.5) + floor(pt.z*0.5),2.0) < 1.0 ? planeCol1 : planeCol2;\n}\n\nvec3 getObjectColorAtPoint(int objectId, vec3 pt, out Material objectMat)\n{\n    switch(objectId)\n    {\n        case 0:\n        \treturn skyCol;\n        case 1:\n        \tobjectMat = sphereMat;\n        \treturn getSphereColorAtPoint(pt);\n        case 2:\n        \tobjectMat = planeMat;\n        \treturn getPlaneColorAtPoint(pt);\n    }\n}\nfloat getShadowFactorAtPoint(vec3 I, vec3 N, Material objectMat, vec3 L, float Ldist)\n{\n    I += 0.001*N;\n    int objId;\n    vec3 intersecS, normalS;\n    float d = computeNearestIntersection(I,L,objId,intersecS,normalS);\n    return (d<=0.0 || d>=Ldist)?1.0:objectMat.Ka;\n}\n\nvoid animateScene(float time)\n{\n    const float pi = 3.1415926535;\n    const float rs = 2.0;\n    const float spr = 5.0;\n    float as = 2.0 * pi * time / spr;\n    \n    spherePos = cameraTarget + rs * vec3(-sin(as),0.0,cos(as)) + vec3(0,1,0);\n    \n    lightPos += vec3(0,10.5 + 9.5 * cos(time) - 10.,0);\n    \n    float targetDist = length(cameraTarget - cameraPos);\n    cameraPos -= vec3(0,0,targetDist);\n    cameraPos += targetDist * vec3(sin(time),max(sin(time*0.5),0.),cos(time));\n}\n\nvec3 raycastAtPixelCoord(vec2 pixCoord)\n{\n    vec3 rayPos, rayDir;\n    computeCameraRayFromPixel(pixCoord, rayPos, rayDir);\n    \n    int objectId;\n    vec3 intersecI, normalI;\n    float distI = computeNearestIntersection(rayPos, rayDir, objectId, intersecI, normalI);\n    \n    if(distI <= 0.0)\n        return skyCol;\n    \n    vec3 L = lightPos - intersecI;\n    float Ldist = length(L);\n    L = L / Ldist;\n    \n    vec3 R = 2.0 * dot(normalI,L) * normalI - L;\n    \n    vec3 V = -rayDir;\n    \n    Material objectMat;\n    vec3 objectCol = getObjectColorAtPoint(objectId, intersecI, objectMat);\n    \n    float shadowFactor = getShadowFactorAtPoint(intersecI, normalI, objectMat, L, Ldist);\n    \n    vec3 resCol = computePhongShading(objectCol, objectMat, shadowFactor, normalI, L, R, V);\n    \n    return resCol;\n}\n\n//De facto \"noise\" function, modified to supply two values\n//Taken from: https://www.shadertoy.com/view/4dGXW1\nvec2 noise2(vec2 location, vec2 delta)\n{\n    const vec2 c = vec2(12.9898,78.233);\n    const float m = 43758.5453;\n    return vec2(\n        fract(sin(dot(location + delta, c)) * m),\n        fract(sin(dot(location + vec2(delta.y,delta.x),c)) * m)\n        );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time = iTime;\n    \n    animateScene(time*1.0);\n    \n    //Apply change of coordinates from pixel\n    fragCoord = transform_to_apply(fragCoord.xy);\n    \n    vec3 resCol = vec3(0);\n    \n    //Grid antialiasing\n    \n    /*for (int i=0; i<PIXEL_SAMPLING_GRID_SIZE; i++) \n    {\n        for (int j=0; j<PIXEL_SAMPLING_GRID_SIZE; j++) \n        {\n            vec2 offset = vec2(float(i)/(float(PIXEL_SAMPLING_GRID_SIZE)*800.),float(j)/(float(PIXEL_SAMPLING_SIZE)*600.));\n\t\t\tresCol += raycastAtPixelCoord(fragCoord + offset);\n      \t}\n    }\n    \n    resCol /= float(PIXEL_SAMPLING_GRID_SIZE * PIXEL_SAMPLING_GRID_SIZE);*/\n    \n    //Stochastic antialiasing\n    \n    for (int i=0; i<PIXEL_SAMPLING_SIZE; i++) \n    {\n        vec2 q =  vec2(float(i), float(i));\n        vec2 n = noise2( fragCoord , q );\n        vec2 offset = vec2(n.x/800., n.y/600.);\n\t\tresCol += raycastAtPixelCoord(fragCoord + offset);\n    }\n    resCol /= float(PIXEL_SAMPLING_SIZE);\n    \n    fragColor = vec4(resCol,1);\n}","name":"Image","description":"","type":"image"}]}