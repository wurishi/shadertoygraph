{"ver":"0.1","info":{"id":"fl2fD1","date":"1652225063","viewed":122,"name":"Lemniscates","username":"artyom_stv","description":"Lemniscates with dynamic number of focuses","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["procedural","2d","lemniscate"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Copyright (c) 2022 Artem Starosvetskiy\n// \n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n// \n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n// \n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\n\n// Converts HSV color to RGB.\nvec3 hsv2rgb(vec3 c) {\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n// Returns 2D rotation matrix.\nmat2 rot2(float a) {\n    float c = cos(a);\n    float s = sin(a);\n\n    return mat2(\n        c, -s,\n        s, c\n    );\n}\n\n// Mupliplies complex numbers.\nvec2 complexMul(vec2 lhs, vec2 rhs) {\n    return mat2(\n        lhs.x, -lhs.y,\n        lhs.y, lhs.x\n    ) * rhs;\n}\n\n// Converts polar coordinates (r, phi) to a complex number.\nvec2 complexFromPolar(vec2 polar) {\n    return vec2(cos(polar.y), sin(polar.y)) * polar.x;\n}\n\n// Converts a complex number to polar coordinates (r, phi).\nvec2 complexToPolar(vec2 c) {\n    return vec2(length(c), atan(c.y, c.x));\n}\n\n// Raises a complex number to the given power.\nvec2 complexPow(vec2 c, float p) {\n    vec2 polar = complexToPolar(c);\n    \n    polar.x = pow(polar.x, p);\n    polar.y *= p;\n    \n    return complexFromPolar(polar);\n}\n\n// Returns coordinates of the i'th focus.\n//\n// At time `t` we show `ceil(t + 1)` focuses.\nvec2 focus(int i, float t) {\n    float phiDelta = 6.28318531 / (t + 1.0);\n    float k = float(i);\n    float phi1 = (k > t ? -fract(t) : k) * phiDelta;\n    float phi2 = phi1 * 3.0 + t + 1.0;\n    \n    const float r1 = 0.25;\n    const float r2 = 0.25;\n    \n    return r1 * vec2(cos(phi1), sin(phi1)) + r2 * vec2(cos(phi2), sin(phi2));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - iResolution.xy * 0.5) / iResolution.y;\n    uv *= 1.25;\n    \n    float t = sin(iTime * 0.07 + 5.0);\n    t = (tan(t) / tan(1.0) * 0.5 + t * 0.5) * 0.5 + 0.5;\n    t = mix(3.0, 15.0, t);\n\n    int n = int(t + 2.0);\n    \n    vec2 product = uv - focus(0, t);\n    for (int i = 1; i < n; ++i) {\n        product = complexMul(product, uv - focus(i, t));\n    }\n    // A lemniscate with n focuses is described by the following equation on the complex plane:\n    //   |(z - f[0]) * ... * (z - f[n])| = r^n\n    // But we had to add a fake (invisible) focus to get a smooth animation when a new focus appears. The modified equation:\n    //   |(z - f[0])^eps * (z - f[0]) * ... * (z - f[n])| = r^(n + eps)\n    float eps = smoothstep(0.5, 1.0, fract(t));\n    product = complexMul(product, complexPow(uv - focus(0, t), eps));\n    \n    float r = pow(length(product), 1.0 / (float(n) + eps));\n    float t2 = iTime * 0.1;\n    \n    float h = (r - t2) * 1.3;\n\n    float v = (r - 0.17 - t2) * 30.0;\n    float v1 = pow(sin(v), 8.0);\n    v1 = smoothstep(0.95, 1.0, v1);\n    float v2 = cos((r - 0.17 - t2) * 30.0);\n    v2 = smoothstep(1.5, 0.2, abs(v2) / fwidth(v2) * 0.5);\n    v = mix(v1, v2, 0.5);\n\n    vec3 col = hsv2rgb(vec3(h, 1.0, v));\n\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}