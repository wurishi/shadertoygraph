{"ver":"0.1","info":{"id":"Ns23D3","date":"1618653410","viewed":37,"name":"327_seleznev_v0v5","username":"ArtoriasAbW","description":"RayTracing","likes":0,"published":1,"flags":32,"usePreview":0,"tags":["raytracing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // Output to screen\n    fragColor = texture(iChannel0, uv) / float(iFrame + 1);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGRn","filepath":"/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","previewfilepath":"/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sfGRn","filepath":"/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","previewfilepath":"/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"const vec3 CAMERA_POS = vec3(-1, 2, 6);\n\nconst float INF = 10e10;\n\nvec3 RAND_DIR;\n\n// material types\nconst int DIFFUSE = 1;\nconst int REFLECTION = 2;\nconst int EMISSION = 3;\nconst int REFRACTION = 4;\n\n\nconst float OBJECT_BLUR = 0.07;\n\n// main objects\nconst float mainSphereRadius = 1.0;\nconst vec3 mainSphereCenter = vec3(0, 0, 0);\nconst vec3 mainSphereColor = vec3(1, 1 ,1);//vec3(0.4, 0.8, 1);\n\nconst float internalSphereRadius = 0.99;\nvec3 internalSphereCenter = vec3(0,0,0); \n\nconst int lightsNumber = 3;\n\n\n// Lights\nconst float[] lightRadiuses = float[] (0.4, 0.3, 2.0);\nvec3[] lightCenters = vec3[] (vec3(-2, 1, -1), vec3(2, -0.2, 1), vec3(-5, 1, 2));\nconst vec3[] lightColors = vec3[] (vec3(0.2, 1, 1), vec3(1, 1, 0), vec3(1, 1, 1));\nconst float[] lightIntensity = float[] (0.4, 0.05, 0.4);\n\nconst float GLASS_N = 1.55;\nconst float AIR_N = 1.0;\nconst float INTERNAL_N = 1.0;\n\n\nstruct Cube {\n    vec3 centre;\n    float size;\n    int type;\n};\n\nint CUBE_FACE[6 * 4] = int[6 * 4]\n(0, 1, 3, 2, \n0, 1, 5, 4, \n1, 3, 7, 5, \n3, 2, 6, 7, \n2, 0, 4, 6, \n4, 5, 7, 6);\n\n// Cube types\nconst int WATER = 0;\nconst int LAVA = 1;\nconst int STONE = 2;\n\nconst int CUBE_NUM = 10;\nCube Cubes[CUBE_NUM] = Cube[CUBE_NUM](\nCube(vec3(-0.6, 0.0, 0.0) * 0.5, 0.15, WATER),\nCube(vec3(0.6, 0.0, 0.0) * 0.5, 0.15, WATER),\nCube(vec3(0.0, 0.0, 0.0) * 0.5, 0.15, LAVA),\nCube(vec3(0.0, 0.6, 0.0) * 0.5, 0.15, WATER),\nCube(vec3(0.0, -0.6, 0.0) * 0.5, 0.15, WATER),\nCube(vec3(0.0, -1.2, 0.0) * 0.5, 0.15, WATER),\nCube(vec3(0.0, -1.2, -1.2) * 0.5, 0.15, STONE),\nCube(vec3(0.0, -0.6, -0.6) * 0.5, 0.15, STONE),\nCube(vec3(0.6, -1.2, -1.2) * 0.5, 0.15, STONE),\nCube(vec3(-0.6, -1.2, -1.2) * 0.5, 0.15, STONE));\n\n\n\nfloat sqr(float a) {\n    return a * a;\n}\n\n\n\nfloat triple(vec3 v1, vec3 v2, vec3 v3) {\n    return dot(v1, cross(v2, v3));\n}\n\n\nfloat tracePlane(vec3 pos, vec3 dir, out vec3 normal) {\n    float t = (-1.4 - pos.y) / dir.y;\n    if (t <= 0.0) {\n        return INF;\n     }\n     vec3 worldPos = pos + t * dir;\n     if (dot(worldPos.xz, worldPos.xz) >= 60.0) {\n         return INF;\n     }\n     normal = vec3(0, 1, 0);\n     return t;\n}\n\n\nfloat traceSphere(vec3 pos, vec3 dir, vec3 center, float radius, out vec3 normal) {\n    vec3 point = pos - center;\n    float a = dot(dir, dir);\n    float b = dot(point, dir);\n    float c = dot(point, point) - radius * radius;\n    float D = b * b - a * c;\n    if (D < 0.0) {\n        return INF;\n    }\n    float t = -b - sqrt(D);\n    if (t > 0.0) {\n        normal = normalize(point + t * dir);\n        return t;\n    }\n    t = -b + sqrt(D);\n    if (t > 0.0) {\n        normal = normalize(point + t * dir);\n        return t;\n    }\n    return INF;\n}\n\n\n\nfloat traceSquare(vec3 pos, vec3 dir, vec3 vert[4], vec3 centre, out vec3 norm) {\n    vec3 d1 = vert[1] - vert[0];\n    vec3 d2 = vert[2] - vert[0];\n    norm = normalize(cross(d1, d2));\n    vec3 d0 = pos - vert[0];\n    float a = triple(dir, d1, d2);\n    if (a == 0.0) return INF;\n    float t = - triple(d0, d1, d2) / a;\n    if (t < 0.0) return INF;\n    \n    vec3 worldPos = pos + t * dir;\n    \n    d0 = worldPos - vert[0];\n    vec3 d3 = vert[3] - vert[0];\n    float c1 = dot(d1, d0) / dot(d1, d1);\n    float c3 = dot(d3, d0) / dot(d3, d3);\n    if (c1 < 0.0 || c1 > 1.0 || c3 < 0.0 || c3 > 1.0) return INF;\n    \n    if (dot(vert[0] + 0.01 * norm - centre, vert[0] + 0.01 * norm - centre) < dot(vert[0] - centre, vert[0] - centre)) {\n        norm = -norm;\n    }\n    return t;\n}\n\n\nfloat traceCube(vec3 pos, vec3 dir, float size, vec3 centre, out vec3 norm) {\n    vec3 CUBE_VERT[8] = vec3[8]\n    (vec3(-1, -1, -1) * size + centre,\n    vec3(-1, -1, 1) * size + centre,\n    vec3(1, -1, -1) * size + centre,\n    vec3(1, -1, 1) * size + centre,\n    vec3(-1, 1, -1) * size + centre,\n    vec3(-1, 1, 1) * size + centre,\n    vec3(1, 1, -1) * size + centre,\n    vec3(1, 1, 1) * size + centre);\n    \n    vec3 cur_norm;\n    float t = INF, cur_t;\n    for (int i = 0; i < 6; i++) {\n        vec3 cur_face[4];\n        for (int j = 0; j < 4; j++) {\n            cur_face[j] = CUBE_VERT[CUBE_FACE[i * 4 + j]];\n        }\n        cur_t = traceSquare(pos, dir, cur_face, centre, cur_norm);\n        if (cur_t < t) {\n            t = cur_t;\n            norm = cur_norm;\n        }\n    }\n    \n    return t;\n}\n\n\nfloat traceAllCubes(vec3 pos, vec3 dir, out vec3 norm, out int type) {\n    float t = INF;\n    float curT;\n    vec3 curNorm;\n    for (int i = 0; i < CUBE_NUM; i++) {\n        curT = traceCube(pos, dir, Cubes[i].size, Cubes[i].centre, curNorm);\n        if (curT > 0.0 && curT < t) {\n            t = curT;\n            norm = curNorm;\n            type = Cubes[i].type;\n        }\n    }\n    return t;\n}\n\n\nfloat traceCylinder(vec3 pos, vec3 dir, out vec3 normal) {\n    float t = (-1.0 - pos.y) / dir.y;\n    if (t <= 0.0) {\n        return INF;\n    }\n    vec3 worldPos = t * dir + pos;\n    if (dot(worldPos.xz, worldPos.xz) < 0.8) {\n        normal = vec3(0, 1, 0);\n        return t;\n    }\n    \n    float a = dot(dir.xz, dir.xz);\n    float b = dot(pos.xz, dir.xz);\n    float c = dot(pos.xz, pos.xz) - 0.8;\n    float D = b * b - a * c;\n    if (D < 0.0) {\n        return INF;\n    }\n    t = (-b - sqrt(D)) / a;\n    if (t > 0.0) {\n        worldPos = t * dir + pos;\n        if (worldPos.y <= -1.0) {\n            normal = normalize(vec3(worldPos.x, 0, worldPos.z));\n            return t;\n        }\n    }\n    t = (-b + sqrt(D)) / a;\n    if (t < 0.0) {\n        return INF;\n    }\n    worldPos = t * dir + pos;\n    if (worldPos.y <= -1.0) {\n        normal = normalize(vec3(worldPos.x, 0, worldPos.z));\n        return t;\n    }\n    return INF;\n}\n\nvec3 Occlude(vec3 pos, vec3 target) {\n    vec3 color = vec3(1, 1, 1);\n    vec3 dir = target - pos;\n    float dist = length(dir);\n    dir /= dist;\n    \n    vec3 sphereNormal;\n    float sphT = traceSphere(pos, dir, mainSphereCenter, mainSphereRadius, sphereNormal);\n    if (sphT < dist) {\n       color *= mainSphereColor;\n       \n    }\n    int type;\n    vec3 cubeNorm;\n    vec3 cylNorm;\n    float cylT = traceCylinder(pos, dir, cylNorm);\n    if (cylT < dist) {\n        color *= vec3(0.01, 0.01, 0.01);\n    }\n    return color;\n}\n\nvec3 computeLight(vec3 pos, vec3 color, vec3 normal) {\n    vec3 result = vec3(0, 0, 0);\n    for (int i = 0; i < lightsNumber; ++i) {\n       vec3 toLight = lightCenters[i] - pos;\n       float distSq = dot(toLight, toLight);\n       vec3 att = Occlude(pos, lightCenters[i] + lightRadiuses[i] * RAND_DIR) / distSq;\n       result += color * max(0.0, dot(normal, normalize(toLight))) * att * lightColors[i] * lightIntensity[i] * 15.f;\n    }\n    return result + texture(iChannel0, normal).rgb * 0.1;\n}\n\n\nvec3 refraction(vec3 v, vec3 normal, inout float n1, inout float n2) {\n    if (dot(v, normal) < 0.0) {\n        normal = -normal;\n    }\n    float cosA = dot(v, normal);\n    float sinA = sqrt(1.0 - cosA * cosA);\n    vec3 tang = normalize(v - cosA * normal);\n    float sinB = sinA / n2 * n1;\n    if (sinB > 1.0) { // Total internal reflection\n        return reflect(v, normal);\n    }\n    float cosB = sqrt(1.0 - sinB * sinB);\n    n1 = n2;\n    return sinB * tang + cosB * normal;\n}\n\n\nfloat rand(float frame)\n{\n    return fract(sin( dot(vec3(frame), vec3(12.9898,78.233,45.5432) )) * 43758.5453);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec3 randVals = vec3(rand(float(iFrame)), rand(float(iFrame + 5)), rand(float(iFrame + 15)));\n    RAND_DIR = normalize(randVals - 0.5);\n    vec2 uv = (fragCoord - iResolution.xy * 0.5 + (randVals.xy - 0.5) * 2.0) / iResolution.x;\n    float randValue = rand(dot(vec3(uv, 0), vec3(3.312, 43.312, 43.321)));\n    vec3 front = normalize(-CAMERA_POS);\n    vec3 up = vec3(0, 1, 0);\n    vec3 right = normalize(cross(front, up));\n    up = normalize(cross(right, front));\n    vec3 viewVec = normalize(front + right * uv.x + up * uv.y);\n    vec3 curPos = CAMERA_POS;\n    vec3 curDir = viewVec;\n    vec3 normal, color, worldPos;\n    int materialType = -1;\n    float n1 = AIR_N;\n    float n2 = GLASS_N;\n    vec3 colorMult = vec3(1, 1, 1);\n    float GLASS_R = sqr(AIR_N - GLASS_N) / sqr(AIR_N + GLASS_N);\n    for (int i = 0; i < lightsNumber; ++i) {\n        lightCenters[i] += vec3(0, 1, 0) * randVals.y * 0.06;\n    }\n    for (int i = 0; i < CUBE_NUM; i++) {\n        Cubes[i].centre = Cubes[i].centre + randVals * OBJECT_BLUR;\n    }\n    for (int i = 0; i < 10; ++i) {\n        float t = INF;\n        vec3 planeNormal;\n        float planeT = tracePlane(curPos, curDir, planeNormal);\n        if (planeT < t) {\n            t = planeT;\n            worldPos = t * curDir + curPos;\n            color = texture(iChannel1, worldPos.xz * worldPos.y).rgb;\n            normal = planeNormal;\n            materialType = DIFFUSE;\n        }\n        vec3 sphereNormal;\n        float sphereT = traceSphere(curPos, curDir, mainSphereCenter, mainSphereRadius, sphereNormal);\n        if (sphereT < t) {\n            t = sphereT;\n            normal = sphereNormal;\n            if (randVals.x < GLASS_R * 1.3) {\n                materialType = REFLECTION;\n            } else {\n                colorMult *= mainSphereColor;\n                materialType = REFRACTION;\n                if (dot(curDir, sphereNormal) > 0.0) {\n                    n2 = AIR_N;\n                } else {\n                    n2 = GLASS_N;\n                }\n            }\n        }\n        vec3 internalNormal;\n        float internalT = traceSphere(curPos, curDir, internalSphereCenter, internalSphereRadius, internalNormal);\n        if (internalT < t) {\n            t = internalT;\n            normal = internalNormal;\n            materialType = REFRACTION;\n            if (dot(curDir, internalNormal) > 0.0) {\n                n2 = GLASS_N;\n            } else {\n               n2 = INTERNAL_N;\n            }\n        } \n        \n        vec3 voxelNorm;\n        int type;\n        float voxelT = traceAllCubes(curPos, curDir, voxelNorm, type);\n        if (voxelT < t) {\n            t = voxelT;\n            normal = voxelNorm;\n            materialType = EMISSION;\n            vec3 worldPos = curPos + t * curDir;\n            if (type == LAVA) {\n                color = randValue > 0.7 ? vec3(0.99, 0.263, 0.165) : vec3(0.99, 0.55, 0.1);\n            } else if (type == STONE) {\n                color = texture(iChannel3, worldPos.xz * worldPos.y * 15.0).rgb;\n            } else if (type == WATER) {\n                color = vec3(0.235, 0.267, 0.663);\n            }\n            }\n        vec3 cylNormal;\n        float cylT = traceCylinder(curPos, curDir, cylNormal);\n        if (cylT < t) {\n            t = cylT;\n            materialType = REFLECTION;\n            worldPos = t * curDir + curPos;\n            color = vec3(0.7529, 0.7529, 0.7529);\n            normal = cylNormal;\n        }\n        vec3 lightNormal;\n        for (int i = 0; i < lightsNumber; ++i) {\n            float light1T = traceSphere(curPos, curDir, lightCenters[i], lightRadiuses[i], lightNormal);\n            if (light1T < t) {\n                t = light1T;\n                color = lightColors[i];\n                normal = lightNormal;\n                materialType = EMISSION;\n            }\n        }\n        if (t != INF) {\n            worldPos = t * curDir + curPos;\n            if (materialType == REFLECTION) {\n                colorMult *= color;\n                curDir = reflect(curDir, normal);\n                curPos = worldPos + curDir * 1e-5;\n            } else if (materialType == EMISSION) {\n                fragColor.rgb = color * colorMult;\n                break;\n            } else if (materialType == DIFFUSE) {\n                fragColor.rgb = computeLight(worldPos, color, normal) * colorMult;\n                break;\n            } else if (materialType == REFRACTION) {\n                \n                curDir = refraction(curDir, normal, n1, n2);\n                curPos = worldPos + curDir * 1e-4;\n                \n            }\n        } else {\n            fragColor.rgb = texture(iChannel0, curDir).rgb * colorMult;\n        }\n    }\n    fragColor.rgb = pow(fragColor.rgb, vec3(0.877));\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    fragColor = texture(iChannel0, uv) + texture(iChannel1, uv);\n}","name":"Buffer B","description":"","type":"buffer"}]}