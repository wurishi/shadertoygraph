{"ver":"0.1","info":{"id":"llKyRz","date":"1534942805","viewed":1634,"name":"Ice cavern","username":"Flopine","description":"Having fun with the inside raymarching function of simesgreen : https://www.shadertoy.com/view/Msf3Dj\nCoding in 25 minutes during the semi-finals of Evoke 2018 Shader Showdown.","likes":50,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","volumetric","ice","watercolor"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xdf3zn","filepath":"/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png","previewfilepath":"/media/ap/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Code by Flopine\n\n// Simplified version (with no reflection) \n// of simesgreen shader : https://www.shadertoy.com/view/Msf3Dj\n\n// Thanks to wsmind, leon, XT95, lsdlive, lamogui and Coyhot for teaching me\n// Cookie Collective rulz\n\nconst int maxSteps = 64;\nconst float hitThreshold = 0.01;\nconst float minStep = 0.02;\nconst float PI = 3.14159;\n\n#define time iTime\n\nvec2 moda (vec2 p, float per)\n{\n    float a = atan(p.y,p.x);\n    float l = length(p);\n    a = mod(a-per/2., per)-per/2.;\n    return vec2(cos(a), sin(a))*l;\n}\n\nmat2 rot (float a)\n{\n    return mat2(cos(a),sin(a),-sin(a),cos(a));\n}\n\nfloat beat (float value, float intensity, float frequency) \n{\n    float v = atan(sin(value * 3.14 * frequency) * intensity);\n    return (v + 3.14 / 2.) / 3.14;\n}\n\nfloat sphere(vec3 p, float r)\n{return length(p) - r;}\n\nfloat box( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat odile(vec3 p, float d)\n{return dot(p, normalize(sign(p)))-d;}\n\nfloat cyl(vec3 p, float r, float h)\n{return max(length(p.xz)-r, abs(p.y)-h);}\n\nfloat prim1 (vec3 p)\n{\n    vec3 pp = p;\n    p.xz *= rot(time*0.7);\n  \tp.xz = moda(p.xz, 2.*PI/5.);\n    p.xz *= rot(p.y*0.5);\n    p.x -= .5;\n    float c = cyl(p,0.35,0.8);\n    \n    p = pp;\n    p.xz *= rot(time);\n    p.xy *= rot(time);\n    float od = odile(p,1.- beat(time, 0.3, .5));\n    return min(c,od);\n}\n\n\nfloat scene(vec3 p)\n{  \n  float d;\n  d = sphere(p,.9);\n\td = max(box(p, vec3(1.1)), -d);\n  d  = min(d, prim1(p));\n\n\tvec3 np = p + vec3(0.0, time*0.2, time*0.1);\n  d += texture(iChannel0, -np.xz).r*0.2;\n  d += texture(iChannel0, np.yz).r*0.2;\n\treturn d;\n}\n\n//simesgreen raymarched inside function\nvec3 traceInside(vec3 ro, vec3 rd, out bool hit, out float insideDist)\n{\n    \n    hit = false;\n    insideDist = 0.0;\t\n    vec3 pos = ro;\n    vec3 hitPos = pos;\n    for(int i=0; i<maxSteps; i++)\n    {\n\t\tfloat d = scene(pos);\n\t\td = max(abs(d), minStep) * sign(d);// enforce minimum step size\n\t\t\n\t\tif (d < hitThreshold && !hit) {\n\t\t\t// save first hit\n\t\t\thitPos = pos;\n\t\t\thit = true;\n\t\t}\n\t\t\n\t\tif (d < 0.01) {\n\t\t\t// sum up distance inside\n\t\t\tinsideDist += d;\n\t\t}\n\t\tpos += abs(d)*rd*0.35;\n    }\n    return hitPos;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n  uv -= 0.5;\n  uv /= vec2(iResolution.y / iResolution.x, 1);\n  vec3 translucentColor = vec3(length(uv), 0.2, 0.1);\n     vec3 rd = normalize(vec3(uv, 1));\n    vec3 ro = vec3(0.0, 0.0, -2.8);\n    // trace ray\n    bool hit;\n    float dist;\n    vec3 hitPos = traceInside(ro, rd, hit, dist);\n\n    vec3 rgb = vec3(0.0);\n    if(hit) \n    {\n\t\t// exponential fall-off:\n\t\trgb = exp(-dist*dist*translucentColor);\n     } \n      else \n      {\n        rgb = vec3(1.);\n     }\n\n    fragColor = vec4(pow(rgb,vec3(2.2)),1.);\n}","name":"Image","description":"","type":"image"}]}