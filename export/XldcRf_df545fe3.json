{"ver":"0.1","info":{"id":"XldcRf","date":"1533489671","viewed":452,"name":"Soccer Game","username":"Mourtz","description":"Started as a branchless pseudo-physics solver and ended as a soccer game with an actual goalie.\n\nControls:\nArrow keys - adjust kick's dir.\nSpace + Up/Down - adjust the power.\nR - reset.\nEnter - shoot\n\nPlease don't make fun of the goalie! ;)","likes":9,"published":1,"flags":48,"usePreview":0,"tags":["game","physics","soccer"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":3,"sampler":{"filter":"linear","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// make these 2 if you have a fast computer\n#define LIGHTING 1\n#define AA 1\n\nconst float INF = 5e1f;\n\nconst int RAY_STEPS \t= 256;\nconst int SHADOW_STEPS \t= RAY_STEPS / 3;\n\n//-------------- MATERIALS --------------\n\nconst float MAT_BALL \t= 1.0f,\n\t\t\tMAT_GRASS \t= 2.0f,\n\t\t\tMAT_SKIN \t= 3.0f,\n\t\t \tMAT_BEAM \t= 4.0f,\n          MAT_BLEACHERS = 5.0f;\n\n//-----------------------------------------------------------------------\n\nconst struct Ray{ vec3 o, d; };\nconst struct intersectionIfo{ float mat, t; vec3 pos, normal; };\n\n//-------------------------------------------\n\nvec2 nearest(vec2 a, vec2 b) { return mix(a, b, step(b.x, a.x)); }\n\nvec2 map( in vec3 p )\n{    \n    vec2 res = nearest(\n        vec2(makeGrass(p), MAT_GRASS),\n        vec2(length(p - getVal(iChannel0, tx_ball_pos).zyx) - ball_radius, MAT_BALL)\n    );\n    \n    res = nearest(res, vec2(makeGoal(p), MAT_BEAM));\n    \n    res = nearest(res, vec2(makeGoalie(p, iChannel0, iTime), MAT_SKIN));\n\n\tres = nearest(res, vec2(makeBleachers(p), MAT_BLEACHERS));\n    \n    \n\treturn res;\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    return normalize( e.xyy*map( pos + e.xyy ).x + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx ).x + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy ).x + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx ).x );\n}\n\nbool castRay( Ray r, out intersectionIfo info )\n{\n    float t = 0.7;\n    vec2 res;\n    for( int i=0; i<RAY_STEPS; ++i )\n    {\n\t    float precis = 0.0004*t;\n\t    res = map( r.o+r.d*t );\n        if( res.x<precis || t>INF ) break;\n        t += res.x*0.7;\n    }\n\n    if( t>INF ) return false;\n    \n    info.t = t;\n    info.pos = r.o+r.d*t;\n    info.normal = calcNormal(info.pos);\n    info.mat = res.y - 0.5;\n    \n    return true;\n}\n\nfloat calcSoftshadow( in Ray r )\n{\n\tfloat res = 1.0;\n    float t = 0.02;\n    for( int i=0; i<SHADOW_STEPS; i++ )\n    {\n\t\tfloat h = map( r.o + r.d*t ).x*0.2;\n        res = min( res,24.0*h/t );\n        t += clamp( h, 0.01, 0.05 );\n        if( res<0.001 || t>0.8 ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\nfloat calcAO( in intersectionIfo info )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    \n    for( float i=0.0f; i<5.0f; ++i )\n    {\n        float hr = 0.01 + 0.03*i;\n        vec3 aopos =  info.normal * hr + info.pos;\n        float dd = map( aopos ).x;\n        occ += (hr-dd)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 2.0*occ, 0.0, 1.0 );    \n}\n\n//-------------------------------------------\n\nvec3 render(Ray r){\n    intersectionIfo iNf;\n    float ks = 0.0;\n\tvec3 col = vec3(0.0); \n    \n    {\n        if(!castRay(r, iNf)){\n            return vec3(0.5) + vec3(0.5) * cos(TWO_PI * (vec3(0.315 , 0.408, 0.525) + vec3(0.9, 0.97, 0.8) * clamp(r.d.y * 0.7 + 0.2, 0.3, 1.0)));\n        }\n\n    #define pos iNf.pos\n    #define nor iNf.normal   \n\t#define mat iNf.mat\n        \n        const vec3 lightDir = normalize( vec3(0.4, 0.5, -0.6) );\n        \n        if(mat < MAT_BALL)\n        {\n            col = vec3(1.0);\n            ks = col.x;\n        } else if(mat < MAT_GRASS){\n            col = vec3(0.0, 0.5, 0.0);\n            \n            vec3 q = 8.0*pos;\n            float f;\n            f  = 0.5000*noise( iChannel3, q ); q = m*q*2.01;\n            f += 0.2500*noise( iChannel3, q ); q = m*q*2.02;\n            f += 0.1250*noise( iChannel3, q ); q = m*q*2.03;\n            f += 0.0625*noise( iChannel3, q ); q = m*q*2.01;\n            \n            col *= f;\n            ks = col.x;\n        } else if(mat < MAT_SKIN){\n            col = vec3(0.7, 0.5, 0.3);\n            ks = 0.1;\n        } else if(mat < MAT_BEAM){\n            col = vec3(0.8);\n            ks = 1.0;\n        } else if(mat < MAT_BLEACHERS){\n            col = vec3(nor.y*r.d.y*0.5+0.2);\n            ks = 0.1;\n        }\n\n        // lighting\n        #if LIGHTING > 0\n        \tfloat ndotl = dot( nor, lightDir );\n        \n        \tfloat amb = clamp( 0.5+0.5*nor.y, 0.0, 1.0 );\n            float dif = max(ndotl, 0.001) * calcSoftshadow( Ray(pos, lightDir) );\n            float spec = pow(max(0.0, dot(reflect(r.d, nor), lightDir)), 50.0);\n        \n        #if LIGHTING > 1\n            float occ = calcAO( iNf );\n\n            float bac = clamp( dot( nor, normalize(vec3(-lightDir.x,0.0,-lightDir.z))), 0.0, 1.0 )*clamp( 1.0-pos.y,0.0,1.0);\n\n            vec3 lin = vec3(0.0);\n            lin += 2.00*dif;\n            lin += 0.4*amb*occ;\n            lin += 0.3*bac*occ;\n            col *= lin;\n\n            col += 5.00*spec*vec3(1.15,0.90,0.70)*ks*ks*4.0;\n        \n        #else\n        \tcol = col*(0.4*amb + dif) + 20.0*spec*ks*ks;\n        \n\t\t#endif\n        \n        #endif\n    #undef pos\n    #undef nor\n    #undef mat\n    }\n    \n\treturn col;\n}\n\n// --- access to the image of ascii code c\nvec4 char(vec2 p, int C) {\n    if (p.x<0.|| p.x>1. || p.y<0.|| p.y>1.) return vec4(0,0,0,1e5);\n\n    return textureGrad( iChannel2, p/16. + fract( vec2(C, 15-C/16) / 16. ) , \n                       dFdx(p/16.),dFdy(p/16.) );\n}\n\nvec4 pInt(vec2 p, float n) {\n    vec4 v = vec4(0);\n    if (n < 0.) \n        v += char(p - vec2(-.5,0), 45 ),\n        n = -n;\n\n    for (float i = 3.; i>=0.; i--) \n        n /= 10.,\n        v += char(p - vec2(.5*i,0), 48+ int(fract(n)*10.) );\n    return v;\n}\n\nvoid mainImage( out vec4 C, in vec2 P )\n{\n    ivec2 iP = ivec2(P);\n    uvec3 uiRes = uvec3(iResolution);\n\tvec2 uv = (P/iResolution.xy*2. - 1.);\n    \n    initIsize(uiRes);\n    \n#ifdef display_texel_block\n    C = texelFetch(iChannel0, iP, 0);\n#else\n     \n    const float cdfr = 2.05;\n    \n    // camera\n    vec3 ro = vec3( 2.05, 0.0, 0.0 );\n    vec3 ta = vec3( 0.0, 0.0, 0.0 );\n    \n    // camera-to-world transformation\n    vec3 cw = normalize(ta-ro);\n    vec3 cu = normalize( cross(cw,vec3(0.0, 1.0,0.0)) );\n    vec3 cv = normalize( cross(cu,cw) );\n\n    vec3 tot = vec3(0.0);\n\t#if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(P+o))/iResolution.y;\n\t\t#else    \n        vec2 p = (-iResolution.xy + 2.0*P)/iResolution.y;\n\t\t#endif\n\n        // ray direction\n        vec3 rd = normalize( p.x*cu + p.y*cv + 2.0*cw );\n\n        // render\t\n        vec3 col = render( Ray(ro, rd) );\n\n\t\t// gamma\n        col = pow( col, vec3(0.4545) );\n\n        tot += col;\n\t#if AA>1\n    }\n    tot /= float(AA*AA);\n\t#endif\n\n    // color grading\n    tot = 1.25*pow(tot,vec3(0.65,0.9,1.0) );\n\n    // vignetting    \n    vec2 q = P/iResolution.xy;\n    tot *= 0.3 + 0.7*pow(16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.25);\n\n    vec4 kick = getVal(iChannel0, txKick);\n    \n    //----------------- UI -----------------\n    \n    // power\n    float bl = smoothstep(0.015, 0.0, length(max(abs(uv-vec2(1.0, 0.95))-vec2(kick.w, 0.05),0.0))-0.01);\n    tot = mix(tot, vec3(1.0-uv.x,uv.x*0.5,0.0), bl);\n    \n    // ball\n    float ball_icon = length(uv*vec2(1.0,0.6)-vec2(-0.8, -0.4));\n    tot = mix(tot, vec3(exp(-ball_icon*3.0)), smoothstep(0.0, -0.012, ball_icon - 0.15));\n    \n    // kick direction\n    kick.y \t= -kick.y;\n\tkick.xy -= max(0.0, kick.x*kick.x+kick.y*kick.y - 1.0) * sign(kick).xy*0.3;\n\n    tot = mix(tot, vec3(1.0, 0.0, 0.0), smoothstep(0.0, -0.01, length(uv*vec2(1.0,0.6)-vec2(-0.8, -0.4)-kick.xy*0.11) - 0.02));\n    \n    const float ts = 12.0;  \n    float text = 0.0;\n    //Power\n    text += char((uv-vec2(0.76,0.9))*ts, 80).r;\n    text += char((uv-vec2(0.80,0.9))*ts, 79).r;\n    text += char((uv-vec2(0.84,0.9))*ts, 87).r;\n    text += char((uv-vec2(0.88,0.9))*ts, 69).r;\n    text += char((uv-vec2(0.92,0.9))*ts, 82).r;\n\n    //Score\n    text += char((uv-vec2(-1.00,0.9))*ts, 83).r;\n    text += char((uv-vec2(-0.96,0.9))*ts, 67).r;\n    text += char((uv-vec2(-0.92,0.9))*ts, 79).r;\n    text += char((uv-vec2(-0.88,0.9))*ts, 82).r;\n    text += char((uv-vec2(-0.84,0.9))*ts, 69).r;\n    text += char((uv-vec2(-0.80,0.9))*ts, 58).r;\n\n    // GOAL!\n    if(false){\n        text += char((uv-vec2(-0.40,0.5))*4.0, 71).r;\n        text += char((uv-vec2(-0.28,0.5))*4.0, 79).r;\n        text += char((uv-vec2(-0.16,0.5))*4.0, 65).r;\n        text += char((uv-vec2(-0.04,0.5))*4.0, 76).r;\n        text += char((uv-vec2(+0.04,0.5))*4.0, 33).r;\n        text += char((uv-vec2(+0.10,0.5))*4.0, 33).r;\n        text += char((uv-vec2(+0.16,0.5))*4.0, 33).r;\n    }\n    \n    text += pInt((uv-vec2(-0.76,0.9))*ts, getVal(iChannel0, txGoal).x).r; \n    \n    tot = mix(tot, vec3(1.0), text);\n\n    C = vec4( tot, 1.0 );\n#endif\n    \n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"const float cdEPS = 1e-2f;\n\nconst float air_friction = 0.96;\nconst float grass_bounciness = 0.5;\nconst float goal_bounciness = 0.8;\nconst vec3 gravity = vec3(0.0, -0.01, 0.0);\n\n//-----------------------------------------------------\n\nvoid mainImage( out vec4 C, in vec2 P )\n{\n    ivec2 iP = ivec2(P);\n    uvec2 uiP = uvec2(iP);\n    uvec3 uiRes = uvec3(iResolution);\n    \n\tinitIsize(uiRes);\n    \n    // resolution in the previous pass\n    vec3 oldResolution = iFrame > 0 ? getVal(iChannel0, txResolution).xyz : iResolution;\n    \n    // reset trigger\n    bool reset = iFrame == 0 || (oldResolution != iResolution) || (texelFetch( iChannel3, KEY_R, 0).x > 0.0);\n    \n    if(!isInside(uiP)) discard;\n    \n    // local copies\n    uint frame = 0U;\n\tuint score = 0U;\n    \n    vec3 ball_pos = vec3(0.0, -0.9, 0.0);\n    vec3 ball_vel = vec3(0.0); \n    \n\tvec4  kick\t\t= vec4(0.0, 0.0, -1.0, 0.25);\n    \n    vec3 goalie_pos = vec3(-4.0, 0.0, 0.0);\n    //vec4 goalie_hands = vec4(0.0);\n    //vec3 goalie_jpos = vec3(0.0);\n\n    vec3 goal = vec3(0.0);\n    \n    // fetch data from the buffer if ~reset\n    if(!reset){\n        C = texelFetch(iChannel0, iP, 0);\n\n        \n        frame = uint(getVal(iChannel0, txFrame).x) + 1U;\n        goal = getVal(iChannel0, txGoal).xyz;\n        \n        // kick\n        kick = getVal(iChannel0, txKick);\n        \n        if(goal.y == 0.0){\n            //ball\n            ball_pos = getVal(iChannel0, tx_ball_pos).xyz;\n            ball_vel = getVal(iChannel0, tx_ball_vel).xyz;\n        }\n        kick.xy *= 1.0-goal.z;\n\t\tgoal.yz = vec2(0.0);\n        \n        goalie_pos = getVal(iChannel0, tx_goalie_pos).xyz;\n        //goalie_hands = getVal(iChannel0, tx_goalie_hands);\n        //goalie_jpos = getVal(iChannel0, tx_goalie_jpos).xyz;\n    }\n    \n    //--------------------------------------------------- \n    //  keyboard input\n    //--------------------------------------------------- \n\n    vec2 kPad = vec2(0.0);\n\n    // x-axis\n    if(texelFetch(iChannel3, KEY_RIGHT, 0).x > 0.){\n        --kPad.x;\n    } else if(texelFetch(iChannel3, KEY_LEFT, 0).x > 0.){\n        ++kPad.x;\n    }\n    \n    // y-axis\n    if(texelFetch(iChannel3, KEY_UP, 0).x > 0.){\n        ++kPad.y;\n    } else if(texelFetch(iChannel3, KEY_DOWN, 0).x > 0.){\n        --kPad.y;\n    }\n    \n    // kick\n    if(texelFetch( iChannel3, KEY_SPACE, 0).x > 0.0){\n\t\tkick.w = clamp(kick.w + kPad.y*0.01, 0.25, 1.0 ); \n    } else {\n    \tkick.xy = clamp(kick.xy+kPad.xy*0.05, -1.0, 1.0);\n    }\n    \n    // shoot!\n    if(dot(ball_vel, ball_vel) < 1e-5f){\n        // reset ball\n        goal.y = -sign(ball_pos.z);\n        \n        if(texelFetch( iChannel3, KEY_ENTER, 0).x > 0.0){\n            ball_vel = kick.xyz*kick.w*0.4;\n        } else {\n\t        ball_pos.y = max(ball_pos.y-0.01, -0.9);\n        }\n    } else {\n        ball_vel += gravity;\n    }\n    \n    goalie_pos.z = clamp(ball_pos.x + 0.4*sin(iTime*6.0 + dot(ball_pos.zyx,  kick.xyw)), -1.1, 1.1);\n    \n    //------------- collision detection -------------\n    \n    // w/o bounciness factor\n    #if 0\n    \tfloat sb = step(ball_radius, min(ball_pos.y + 1.0, min(makeGoal(ball_pos.zyx), makeGoalie(ball_pos.zyx, iChannel0, iTime)) ));\n    \tball_vel *= 2.0*sb-1.0;\n    #else\n    \tball_vel *= mix(\n            -goal_bounciness, \n            1.0, \n            step(ball_radius, makeGoal(ball_pos.zyx))\n        );\n    \t\n    \tball_vel *= mix(\n            -goal_bounciness, \n            1.0, \n            step(ball_radius, makeGoalie(ball_pos.zyx, iChannel0, iTime))\n        );\n    \n    \tball_vel.y *= mix(\n            -grass_bounciness, \n           \t1.0,\n            step(-0.9, ball_pos.y)\n        );\n    #endif\n        \n    //------------------------------------------------ \n    \n    ball_vel *= air_friction;\n    ball_pos += ball_vel;\n    \n    // adjust ball's pos in case the hit wasnt registered\n    ball_pos.y = max(ball_pos.y, -0.9-cdEPS);\n\n    // trigger\n    goal += step(ball_pos.z, -4.0) * step(-4.2, ball_pos.z) *\n        step(abs(ball_pos.x), 2.0) *\n        step(ball_pos.y, 1.0);\n    \n    //---------------------------------------------------\n    //  store game state\n    //---------------------------------------------------\n    storeVal(txFrame, uiP, vec4(frame));\n    storeVal(txResolution, uiP, vec4(iResolution, 0.0));\n    storeVal(txGoal, uiP, vec4(goal, 0.0));\n \n    storeVal(tx_ball_pos, uiP, vec4(ball_pos, 0.0));\n    storeVal(tx_ball_vel, uiP, vec4(ball_vel, 0.0));\n    \n    storeVal(txKick, uiP, vec4(kick));\n\n    storeVal(tx_goalie_pos, uiP, vec4(goalie_pos, 0.0));\n    //storeVal(tx_goalie_hands, uiP, goalie_hands);\n    //storeVal(tx_goalie_jpos, uiP, vec4(goalie_jpos, 0.0));\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"//#define display_texel_block\n#define fast_texel_block\n\n//--------------------------\n//----- texel adresses -----\n//--------------------------\n\n/*-------- atts --------*/\nconst uint txFrame \t\t\t= 0U;\nconst uint txResolution \t= 1U;\n\nconst uint txKick \t\t\t= 2U;\nconst uint txGoal\t\t\t= 4U;\n\n/*-------- ball --------*/\nconst float ball_radius\t\t= 0.1;\nconst uint tx_ball_pos\t\t= 5U;\nconst uint tx_ball_vel  \t= 6U;\n\n/*-------- goalie --------*/\nconst uint tx_goalie_pos\t= 7U;\nconst uint tx_goalie_hands\t= 8U;\nconst uint tx_goalie_jpos\t= 9U;\n\n// total texels\nconst uint totalValues \t\t= 10U;\n\n// texels block size\n#ifdef fast_texel_block\n\tconst uvec2 iSize = uvec2(totalValues, 1U);\n\n#define initIsize(uiRes)\n#else\n\tuvec2 iSize;\n\n#define initIsize(uiRes) {\\\n    iSize.y = totalValues/uiRes.x+1U;\\\n\tiSize.x = iSize.y > 1U ? totalValues : totalValues%uiRes.x;\\\n}\n#endif\n\n//-------------------------------------------\n\n#define isInside(p)\t\tbool(iSize.x/p.x & iSize.y/p.y)\n\n#define toLocal(p) \t\tp.x + p.y*iSize.x\n#define toGlobal(p)\t\tuvec2(p%iSize.x, p/iSize.x)\n\n#define storeVal(p, fragCoord, val) if(toGlobal(p) == fragCoord) C = val\n#define getVal(channel, p) \t\t\ttexelFetch(channel, ivec2(toGlobal(p)), 0)\n\n//-------------------------------------------\n\nconst float HALF_PI = 1.5707963267948966192313216916397514;\nconst float PI \t\t= 3.1415926535897932384626433832795028;\nconst float TWO_PI \t= 6.2831853071795864769252867665590057;\n\n//-------------------------------------------\n\n// keyboard mappings\nconst ivec2 KEY_SPACE = ivec2(32, 0);\nconst ivec2 KEY_R  \t  = ivec2(82, 0);\nconst ivec2 KEY_ENTER = ivec2(13, 0);\n\nconst ivec2 KEY_LEFT  = ivec2(37, 0);\nconst ivec2 KEY_UP    = ivec2(38, 0);\nconst ivec2 KEY_RIGHT = ivec2(39, 0);\nconst ivec2 KEY_DOWN  = ivec2(40, 0);\n\n//-------------- PRNG --------------\n\nfloat hash(float n) { return fract(sin(n) * 1e4); }\n\nconst mat3 m = mat3( 0.00,  0.80,  0.60,\n                    -0.80,  0.36, -0.48,\n                    -0.60, -0.48,  0.64 );\n\nfloat noise( sampler2D tex, in vec3 x ){\n    #if 1\n    \n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\tvec2 rg = textureLod( tex, (uv+0.5)/256.0, 0.0).yx;\n\treturn mix( rg.x, rg.y, f.z );\n    \n    #else\n    \n    ivec3 p = ivec3(floor(x));\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\tivec2 uv = p.xy + ivec2(37,17)*p.z;\n\tvec2 rgA = texelFetch( tex, (uv+ivec2(0,0))&255, 0 ).yx;\n    vec2 rgB = texelFetch( tex, (uv+ivec2(1,0))&255, 0 ).yx;\n    vec2 rgC = texelFetch( tex, (uv+ivec2(0,1))&255, 0 ).yx;\n    vec2 rgD = texelFetch( tex, (uv+ivec2(1,1))&255, 0 ).yx;\n    vec2 rg = mix( mix( rgA, rgB, f.x ),\n                   mix( rgC, rgD, f.x ), f.y );\n    return mix( rg.x, rg.y, f.z );\n    \n    #endif\n}\n\n//------------------------------------------------------------------------\n\nfloat length8( vec2 p )\n{\n\tp = p*p*p*p*p*p*p*p;\n\treturn pow( p.x + p.y, 1.0/8.0 );\n}\n\nfloat smin( float a, float b, float k ){\n    float h = clamp(0.5+0.5*(b-a)/k, 0.0, 1.0);\n    return mix(b, a, h) - k*h*(1.0-h);\n}\n\n#define udBox(p, b) length(max(abs(p)-b,0.0)) \n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r ){\n\tvec3 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h ) - r;\n}\n\nfloat makeGrass(in vec3 p){\n\tfloat res = (dot(p,vec3(0.0, 1.0, 0.0)) + 1.0);\n    \n    const float c = 0.05;\n    p.xz = mod(p.xz, c) - c*0.5;\n    res = min(res, length(p-vec3(0.0,-1.0,0.0)) - c*0.75);\n\treturn res;\n}\n\nfloat makeGoal(in vec3 p){\n    float res =    udBox(p-vec3(-4.0, 0.0, -2.0), vec3(0.1, 1.0, 0.1)); \n\tres = min(res, udBox(p-vec3(-4.0, 0.0, 2.0), vec3(0.1, 1.0, 0.1)));\n    res = min(res, udBox(p-vec3(-4.0, 1.0, 0.0), vec3(0.1, 0.1, 2.1)));\n    return res;\n}\n\nfloat makeGoalie(vec3 p, sampler2D tex, float time){\n    vec4 goalie_hands = getVal(tex, tx_goalie_hands);\n    const float bcr = 0.06;\n    \n    p -= getVal(tex, tx_goalie_pos).xyz;\n    \n\tfloat res = sdCapsule(p - vec3(0.0, 0.0, 0.0), vec3(0.0,-0.2,0.0), vec3(0.0,0.3,0.0), bcr);\n    \n    res = min(res, sdCapsule(p - vec3(0.0, 0.0, 0.0), vec3(0.0,-0.2,0.0), vec3(0.0,-0.55,0.3), bcr));\n    res = min(res, sdCapsule(p - vec3(0.0, 0.0, 0.0), vec3(0.0,-0.2,0.0), vec3(0.0,-0.55,-0.3), bcr));\n\n    res = min(res, sdCapsule(p - vec3(0.0, 0.0, 0.0), vec3(0.0,-0.55,0.3), vec3(0.0,-0.85,0.3), bcr));\n    res = min(res, sdCapsule(p - vec3(0.0, 0.0, 0.0), vec3(0.0,-0.55,-0.3), vec3(0.0,-0.85,-0.3), bcr));\n\n    res = min(res, sdCapsule(p - vec3(0.0, 0.0, 0.0), vec3(0.0,0.3,0.0), vec3(0.0,0.2,-0.3), bcr));\n    res = min(res, sdCapsule(p - vec3(0.0, 0.0, 0.0), vec3(0.0,0.3,0.0), vec3(0.0,0.2,0.3), bcr));\n\n    res = min(res, sdCapsule(p - vec3(0.0, 0.0, 0.0), vec3(0.0,0.2,0.3), vec3(0.0,0.5,0.6), bcr));\n    res = min(res, sdCapsule(p - vec3(0.0, 0.0, 0.0), vec3(0.0,0.2,-0.3), vec3(0.0,0.5,-0.6), bcr));\n\n    res = smin(res, length(p-vec3(0.0,0.6,0.0)) - 0.2, 0.15);\n\n\treturn res;\n}\n\nfloat sdTorus82( vec3 p, vec2 t ){\n    vec2 q = vec2(length(p.xz)-t.x,p.y);\n    return length8(q)-t.y;\n}\n\nfloat makeBleachers(vec3 p){\n\tfloat res = sdTorus82(p-vec3(0.0, -0.75, 0.0), vec2(20.0, 0.5));\n\tres = min(res, sdTorus82(p-vec3(0.0, -0.25, 0.0), vec2(20.5, 0.5)));\n    res = min(res, sdTorus82(p-vec3(0.0, 0.25, 0.0), vec2(21.0, 0.5)));\n    res = min(res, sdTorus82(p-vec3(0.0, 0.75, 0.0), vec2(21.5, 0.5)));\n    res = min(res, sdTorus82(p-vec3(0.0, 1.25, 0.0), vec2(22.0, 0.5)));\n    \n    res = smin(res, sdTorus82(p-vec3(0.0, 3.25, 0.0), vec2(26.75-p.y*1.5, 2.0)), 0.5);   \n\treturn res;\n}\n","name":"Common","description":"","type":"common"}]}