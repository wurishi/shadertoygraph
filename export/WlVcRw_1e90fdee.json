{"ver":"0.1","info":{"id":"WlVcRw","date":"1610693423","viewed":70,"name":"Rotational Gradient Noise","username":"tomoe","description":"Values of this hash function is rotated (L: 2D, R: 3D) ","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["bd202101"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"uvec3 k = uvec3(0x456789abu, 0x6789ab45u, 0x89ab4567u);\nconst uint max32 = 0xffffffffu;\nmat2 rot2(float t){\n    return mat2(sin(t),cos(t),-cos(t),sin(t));\n}\nmat3 rotX(float t){\n    return mat3(\n        1.,0.,0.,\n        0.,sin(t),cos(t),\n        0.,-cos(t),sin(t)\n    );\n}\nuvec2 hash22u(uvec2 n) {\n    n ^= (n.yx << 24);\n    n ^= (n.yx >> 1);\n    n *= k.xy;\n    n ^= (n.yx << 1);\n    return n * k.xy;\n}\nvec2 hash22(vec2 p) {\n    uvec2 n = uvec2(p);\n    vec2 v = vec2(hash22u(n)) / vec2(max32);\n    return rot2(iTime)*normalize(2.0 * v - vec2(1.0));\n}\nuvec3 hash33u(uvec3 n) {\n    n ^= (n.yzx << 24);\n    n ^= (n.yzx >> 1);\n    n *= k;\n    n ^= (n.yzx << 1);\n    return n * k;\n}\nvec3 hash33(vec3 p) {\n        uvec3 n = uvec3(p);\n        vec3 v = vec3(hash33u(n)) / vec3(max32);\n        return rotX(iTime) * normalize(2.0 * v - vec3(1.0));\n}\n\nfloat gnoise21(vec2 p) {\n    vec2 f = fract(p);\n    p = floor(p);\n    vec2 g00 = hash22(p);\n    vec2 g01 = hash22(p + vec2(0.0, 1.0));\n    vec2 g10 = hash22(p + vec2(1.0, 0.0));\n    vec2 g11 = hash22(p + vec2(1.0, 1.0));\n    float v00 = dot(g00, f);\n    float v01 = dot(g01, f - vec2(0.0, 1.0));\n    float v10 = dot(g10, f - vec2(1.0, 0.0));\n    float v11 = dot(g11, f - vec2(1.0, 1.0));\n    f = f * f * f * (10.0 - 15.0 * f + 6.0 * f * f);\n    float v = mix(mix(v00, v10, f.x), mix(v01, v11, f.x), f.y);\n    return 0.5 * v + 0.5;\n}\nfloat gnoise31(vec3 p) {\n    vec3 f = fract(p);\n    p= floor(p);\n    vec3 g000 = hash33(p);\n    vec3 g001 = hash33(p + vec3(0.0, 0.0, 1.0));\n    vec3 g010 = hash33(p + vec3(0.0, 1.0, 0.0));\n    vec3 g011 = hash33(p + vec3(0.0, 1.0, 1.0));\n    vec3 g100 = hash33(p + vec3(1.0, 0.0, 0.0));\n    vec3 g101 = hash33(p + vec3(1.0, 0.0, 1.0));\n    vec3 g110 = hash33(p + vec3(1.0, 1.0, 0.0));\n    vec3 g111 = hash33(p + vec3(1.0, 1.0, 1.0));\n    \n    float v000 = dot(g000, f);\n    float v001 = dot(g001, f - vec3(0.0, 0.0, 1.0));\n    float v010 = dot(g010, f - vec3(0.0, 1.0, 0.0));\n    float v011 = dot(g011, f - vec3(0.0, 1.0, 1.0));\n    float v100 = dot(g100, f - vec3(1.0, 0.0, 0.0));\n    float v101 = dot(g101, f - vec3(1.0, 0.0, 1.0));\n    float v110 = dot(g110, f - vec3(1.0, 1.0, 0.0));\n    float v111 = dot(g111, f - vec3(1.0, 1.0, 1.0));\n    f = f * f * f * (10.0 - 15.0 * f + 6.0 * f * f);\n    float xy0 = mix(mix(v000, v100, f.x), mix(v010, v110, f.x), f.y);\n    float xy1 = mix(mix(v001, v101, f.x), mix(v011, v111, f.x), f.y);\n    return 0.5 * mix(xy0, xy1, f.z) + 0.5;\n}\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec2 pos = fragCoord.xy/min(iResolution.x, iResolution.y);\n    pos *= 12.;\n    pos += iTime;\n    vec3 col;\n    if (fragCoord.x < 0.5 * iResolution.x){\n        col = vec3(gnoise21(pos));\n    } else{\n        col = vec3(gnoise31(vec3(pos, iTime)));\n    }\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}