{"ver":"0.1","info":{"id":"mtKcDm","date":"1700328338","viewed":186,"name":"Pyroclastic fireball - HLSL","username":"oleg304","description":"Fireball https://www.shadertoy.com/view/MtXSzS\nHLSL version","likes":15,"published":1,"flags":0,"usePreview":0,"tags":["sun","fireball","redgiant","pyroclastic"],"hasliked":0,"parentid":"MtXSzS","parentname":"Pyroclastic fireball"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// HLSL -> GLSL https://anteru.net/blog/2016/mapping-between-HLSL-and-GLSL/\n#define float2   vec2\n#define float3   vec3\n#define float4   vec4\n#define lerp     mix\n#define atan2    atan\n#define frac     fract\n#define fmod     mod\n#define float2x2 mat2     \n#define mul(a, b) a*b \n#define texSampl 1.\n#define Texture2DSample(iChannel0, texSampl, uv) texture(iChannel0, uv)\n#define ddx dFdx\n#define ddy dFdy\n#define saturate(oo) clamp(oo, 0.0, 1.0)\n\n//--------------------------------------------------------------------------\n\n// port from http://glslsandbox.com/e#8625.0 by Duke \n// Fireball\n// Awd\n// @AlexWDunn\n// Description : Array and textureless GLSL 2D/3D/4D simplex\n//               noise functions.\n//      Author : Ian McEwan, Ashima Arts.\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n//               Distributed under the MIT License. See LICENSE file.\n//               https://github.com/ashima/webgl-noise\n//\n\n\nfloat3 mod289(float3 x) { return x-floor(x*(.00346020761))*289.;}\nfloat4 mod289(float4 x) { return x-floor(x*(.00346020761))*289.;}\nfloat4 permute(float4 x) { return mod289(((x*34.)+1.)* x);}\nfloat4 taylorInvSqrt(float4 r) { return 1.79284291400159-0.85373472095314*r;}\nfloat SphereDist(float3 position) { return length(position)-2.;}\n\nfloat snoise(float3 v) {\n\tfloat2  C = float2(1./6.,1./3.); float4 D = float4(0.,.5,1.,2.);\n\tfloat3 i = floor(v+dot(v,C.yyy)), x0 =v-i+dot(i,C.xxx), g =step(x0.yzx,x0.xyz);\n\tfloat3 l = 1.0-g, i1 =min(g.xyz,l.zxy), i2 =max(g.xyz,l.zxy);\n\tfloat3 x1 = x0-i1+C.xxx, x2 = x0 - i2 + C.yyy, x3 = x0 - D.yyy; // -1.0+3.0*C.x = -0.5 = -D.y\n\ti = mod289(i);\n\tfloat4 p=permute(permute(permute(i.z+float4(0.,i1.z,i2.z,1.))+i.y+float4(0.,i1.y,i2.y,1.))+i.x+float4(0.,i1.x,i2.x,1.));\n\t// Gradients: 7x7 points over a square, mapped onto an octahedron.\n\t// The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n\tfloat n_ =.142857142857; // 1.0/7.0\n\tfloat3  ns =n_*D.wyz-D.xzx;float4 j =p-49.*floor(p*ns.z*ns.z);  //  mod(p,7*7)\n\tfloat4 x_ =floor(j * ns.z), y_ =floor(j-7.*x_), x = x_*ns.x+ns.yyyy, y =y_*ns.x+ns.yyyy;\n\tfloat4 h =1.0-abs(x)-abs(y), b0 = float4(x.xy, y.xy);\n\tfloat4 b1 =float4(x.zw,y.zw), s0 =floor(b0)*2.+1., s1 =floor(b1)*2.+1., sh =-step(h,float4(0.,0.,0.,0));\n\tfloat4 a0 =b0.xzyw+s0.xzyw*sh.xxyy,a1=b1.xzyw+s1.xzyw*sh.zzww;\n\tfloat3 p0 =float3(a0.xy,h.x), p1 =float3(a0.zw, h.y), p2 =float3(a1.xy, h.z), p3 =float3(a1.zw, h.w);\n\tfloat4 norm =taylorInvSqrt(float4(dot(p0,p0),dot(p1,p1),dot(p2,p2),dot(p3,p3)));\n\tp0 *= norm.x; p1 *= norm.y;\tp2 *= norm.z; p3 *= norm.w;\n\tfloat4 m = max(.6-float4(dot(x0,x0),dot(x1,x1),dot(x2,x2),dot(x3,x3)),0.);\n\tm = m * m;\n\treturn 42.*dot(m*m, float4(dot(p0,x0),dot(p1,x1),dot(p2,x2),dot(p3,x3)));\n}\n\nfloat Turbulence(float3 position, float minFreq, float maxFreq, float qWidth) {\n\tfloat value = 0., cutoff = clamp(.5/qWidth,0.,maxFreq), fade, fOut = minFreq;\n\tfor (int i = 1; i >= 0; i--) {\n\t\tif (fOut >=.5*cutoff) break;\n\t\tfOut *= 2.; value += abs(snoise(position*fOut))/fOut;\n\t}\n\tfade = clamp(2.*(cutoff - fOut)/cutoff,0.,1.);\n\tvalue += fade*abs(snoise(position*fOut))/fOut;\n\treturn 1.- value;\n}\n\nfloat4 Shade(float distance) {\n\t// Colour Gradient\n\tfloat4 Color1 = float4(1.,1.,1.,1.), Color2 = float4(1.,.8,.2,1.),\n\tColor3 = float4(1.,.03,.0,1.), Color4 = float4(.05,.02,.02,1.);\n\tfloat c1 = saturate(distance*5.+.5), c2 = saturate(distance*5.), c3 = saturate(distance*3.4-.5);\t\n    float4 a = lerp(Color1, Color2, c1), b = lerp(a, Color3, c2); \n    return lerp(b, Color4, c3);\n}\n\nfloat RenderScene(float3 position, out float distance) {\n\tfloat ampl = 0.06, NoiseFrequency = 4.;\tfloat3 Animation = float3(0.,-3.,.5);\n\tfloat noise = Turbulence(position*NoiseFrequency+Animation*iTime,.1,1.5,.03)*ampl;\n\tnoise = saturate(abs(noise));\n\tdistance = SphereDist(position) - noise;\n\treturn noise;\n}\n\nfloat4 March(float3 rayOrigin, float3 rayStep) {\n\tfloat3 position = rayOrigin;\n\tfloat distance, displacement;\n\tfor (int step = 4; step >= 0; --step) {\n\t\tdisplacement = RenderScene(position,distance);\n\t\tif (distance < .05) break;\n\t\tposition += rayStep*distance;\n\t}\n\treturn lerp(Shade(displacement), float4(0.,0.,0.,0.), float(distance >= 0.5));\n}\n\nbool IntersectSphere(float3 ro, float3 rd, float radius, out float3 intersectPoint) {\n\tfloat3 relDistance = (ro);\n\tfloat b = dot(relDistance, rd), \n    c = dot(relDistance, relDistance)-radius*radius, d =b*b-c;\n\tintersectPoint = ro+rd*(-b-sqrt(d));\n\treturn d >= 0.;\n}\n\nvoid mainImage(out float4 fragColor, in float2 fragCoord) {\n    \n    //float2 iResolution = float2(1.,1.);    \n\tfloat2 p = (fragCoord.xy/iResolution.xy)*2.-1.;\n\tp.x *= iResolution.x/iResolution.y;\n    \n    //float2 iMouse = float2(0.,0.);    \n\tfloat rotx = iMouse.y*.01, roty = -iMouse.x*.01, zoom = 5.;\n\t// camera\n\tfloat3 ro = zoom*normalize(float3(cos(roty),cos(rotx),sin(roty))),\n\tww = normalize(float3(0.,0.,0.)-ro), uu = normalize(cross(float3(0.,1.,0.),ww)),\n\tvv = normalize(cross(ww,uu)), rd = normalize(p.x*uu+p.y*vv+1.5*ww);\n\tfloat4 col = float4(0.,0.,0.,0.); float3 origin; \n\tif(IntersectSphere(ro,rd,2.+0.7,origin)){col = March(origin,rd);}\n\tfragColor = col;\n}","name":"Image","description":"","type":"image"}]}