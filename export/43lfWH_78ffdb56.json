{"ver":"0.1","info":{"id":"43lfWH","date":"1728447261","viewed":29,"name":"Voronoi Noise With SDFs","username":"Ponjee","description":"Voronoi Noise using a signed distance function.\nUse mouse click to change between 2 sdf types. Circular, Triangular.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["voronoi","noise","sdf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float PI = 3.141592653589793238462643383279502884197169399375105820974944592307816406286208998628034825342117067982148086513282306647093844609550582231725359408128481;\n\n// Rotation matrices\nvec2 rotateVec2(vec2 p, float a) {\n    return vec2(\n        p.x*cos(a) - p.y*sin(a), \n        p.x*sin(a) + p.y*cos(a)\n    );\n}\n\nfloat sdCircle( vec2 p, float r )\n{\n    return length(p) - r;\n}\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat sdEquilateralTriangle( in vec2 p, in float r )\n{\n    const float k = sqrt(3.0);\n    p.x = abs(p.x) - r;\n    p.y = p.y + r/k;\n    if( p.x+k*p.y>0.0 ) p = vec2(p.x-k*p.y,-k*p.x-p.y)/2.0;\n    p.x -= clamp( p.x, -2.0*r, 0.0 );\n    return -length(p)*sign(p.y);\n}\n\nfloat sdTriangleSharp(vec2 p, float r) {\n    r *= 2.6/4.5;\n    float a = PI/0.75 - PI/2.0; //2.6179938779914943653855361527329190701643078328125881841457\n    float d1 = dot(p, vec2(cos(-a), sin(-a)))+r;\n    float d2 = -dot(p, vec2(cos(a), sin(a)))+r;\n    float d3 = dot(p, vec2(0.0,1.0))+r;\n    return -min(d1,min(d2,d3));\n}\n\nfloat sdf(vec2 p) {\n    return ( iMouse.z < 0.0 ? sdCircle(p, 0.0) : sdTriangleSharp(p, 0.0) );\n}\n\nfloat smin( float d1, float d2, float k )\n{\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\nfloat exp_sin_lerp(float a, float b, float t, float s) {\n    //float v1 = 0.0 + (0.5 - 0.0) * (1.0 - pow(1.0 - 2.0 * t, s));\n    //float v2 = 0.5 + (1.0 - 0.5) * pow(2.0 * s - 1.0, s);\n    float v1 = 0.0 + (0.5 - 0.0) * pow(2.0 * t, s);\n    float v2 = 0.5 + (1.0 - 0.5) * (1.0 - pow(2.0 - 2.0 * t, s));\n    return a + (b - a) * ( t < 0.5 ?  v1 : v2);\n}\n\nfloat sin_lerp(float a, float b, float t) {\n    float v = sin(mix(-PI/2.0, PI/2.0, t)) * 0.5 + 0.5;\n    return mix(a,b,v);\n}\n\nfloat get_voronoi_2d(vec2 p, float s) {\n    vec4 curr_col = texelFetch(iChannel0, ivec2(round(p)), 0);\n    \n    // 7 8 9   . . .\n    // 4 5 6   . p .\n    // 1 2 3   . . .\n    \n    vec2 p1 = p + vec2(-1.0,-1.0);\n    vec2 p2 = p + vec2( 0.0,-1.0);\n    vec2 p3 = p + vec2( 1.0,-1.0);\n    vec2 p4 = p + vec2(-1.0, 0.0);\n    vec2 p5 = p + vec2( 0.0, 0.0);\n    vec2 p6 = p + vec2( 1.0, 0.0);\n    vec2 p7 = p + vec2(-1.0, 1.0);\n    vec2 p8 = p + vec2( 0.0, 1.0);\n    vec2 p9 = p + vec2( 1.0, 1.0);\n    \n    vec4 cc1 = texelFetch(iChannel0, ivec2(p1), 0);\n    vec4 cc2 = texelFetch(iChannel0, ivec2(p2), 0);\n    vec4 cc3 = texelFetch(iChannel0, ivec2(p3), 0);\n    vec4 cc4 = texelFetch(iChannel0, ivec2(p4), 0);\n    vec4 cc5 = texelFetch(iChannel0, ivec2(p5), 0);\n    vec4 cc6 = texelFetch(iChannel0, ivec2(p6), 0);\n    vec4 cc7 = texelFetch(iChannel0, ivec2(p7), 0);\n    vec4 cc8 = texelFetch(iChannel0, ivec2(p8), 0);\n    vec4 cc9 = texelFetch(iChannel0, ivec2(p9), 0);\n    \n    vec2 dp1 = floor(p1) + cc1.rg;\n    vec2 dp2 = floor(p2) + cc2.rg;\n    vec2 dp3 = floor(p3) + cc3.rg;\n    vec2 dp4 = floor(p4) + cc4.rg;\n    vec2 dp5 = floor(p5) + cc5.rg;\n    vec2 dp6 = floor(p6) + cc6.rg;\n    vec2 dp7 = floor(p7) + cc7.rg;\n    vec2 dp8 = floor(p8) + cc8.rg;\n    vec2 dp9 = floor(p9) + cc9.rg;\n    \n    float c1 = sdf(p - dp1);\n    float c2 = sdf(p - dp2);\n    float c3 = sdf(p - dp3);\n    float c4 = sdf(p - dp4);\n    float c5 = sdf(p - dp5);\n    float c6 = sdf(p - dp6);\n    float c7 = sdf(p - dp7);\n    float c8 = sdf(p - dp8);\n    float c9 = sdf(p - dp9);\n    \n    float d = \n    smin(c1, \n    smin(c2, \n    smin(c3, \n    smin(c4, \n    smin(c5, \n    smin(c6, \n    smin(c7, \n    smin(c8, c9,s)\n    ,s),s),s),s),s),s),s);\n    \n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-vec2(0.5));\n    uv *= 0.03;\n    \n    float value = get_voronoi_2d(uv, 0.0);\n    fragColor = vec4(value);\n}","name":"Image","description":"","type":"image"}]}