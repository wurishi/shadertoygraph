{"ver":"0.1","info":{"id":"cdSGWy","date":"1668065579","viewed":121,"name":"Watching videos","username":"Asif","description":" ","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["video"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sX3Rn","filepath":"/media/a/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv","previewfilepath":"/media/ap/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv","type":"video","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4df3zn","filepath":"/media/a/3405e48f74815c7baa49133bdc835142948381fbe003ad2f12f5087715731153.ogv","previewfilepath":"/media/ap/3405e48f74815c7baa49133bdc835142948381fbe003ad2f12f5087715731153.ogv","type":"video","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGRr","filepath":"/media/a/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm","previewfilepath":"/media/ap/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm","type":"video","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const vec2 eps = vec2(0.0001, 0.0000);\n\nstruct Ray\n{\n    vec3 or;\n    vec3 dir;\n};\n\nstruct Surface\n{\n    vec3 pos;\n    vec3 normal;\n};\n\nvec2 rand(in vec2 s)\n{\n    return  vec2(sin(s.x * 123123.123123), cos(s.y * 32.2343)) * \n            vec2(3.2323, cos(s.x * 2323.323));\n}\n\nfloat map(in vec3 p)\n{\n    const float dl = 100.0;\n\n    return max(\n        min(\n            min(p.y + dl, p.x + dl), \n            -p.x + dl\n        ), \n        p.y - dl\n    );\n}\n\nfloat trace(in Ray ray, in float s, in float e)\n{\n    float depth = s;\n\n    const uint max_step = 512u;\n    for (uint i = 0u; i < max_step; ++i) {\n        float dist = map(ray.or + ray.dir * depth);\n\n        if (dist < eps.x) {\n            return depth;\n        }\n\n        depth += dist;\n\n        if (depth >= e) {\n            return e;\n        }\n    }\n\n    return e;\n}\n\nvec3 calcNormal(in vec3 pos)\n{\n    return normalize(vec3(\n        map(pos + eps.xyy) - map(pos - eps.xyy),\n        map(pos + eps.yxy) - map(pos - eps.yxy),\n        map(pos + eps.yyx) - map(pos - eps.yyx)\n    ));\n}\n\nRay genRay(in vec3 pos, in vec2 frag_coord)\n{\n    vec3 p = vec3(frag_coord - iResolution.xy * 0.5, iResolution.y);\n\n    vec3 ww = normalize(vec3(smoothstep(-0.5, 0.5, cos(iTime * 0.5)) - 0.5, 0.0, 1.0));\n    vec3 uu = normalize(cross(ww, vec3(0.0, 1.0, 0.0)));\n    vec3 vv = cross(uu, ww);\n    \n#if 1\n    return Ray(pos, normalize(p.x * uu + p.y * vv + p.z * ww));\n#else\n    return Ray(pos, normalize(mat3(uu, vv, ww) * p));\n#endif\n}\n\nSurface getSurface(in Ray ray, in float d)\n{\n    vec3 pos = ray.or + ray.dir * d;\n    return Surface(pos, calcNormal(pos));\n}\n\nvec3 getColor(in Surface surface)\n{\n    vec2    df      = surface.pos.yz * 0.02;\n    vec2    uv      = fract(df.yx);\n    int     tex_id  = int(floor(df.x) + floor(df.y)) % 3;\n\n    if (tex_id == 0) {\n        return texture(iChannel0, uv).rgb;\n    } else if (tex_id == 1) {\n        return texture(iChannel1, uv).rgb;\n    } else {\n        return texture(iChannel2, uv).rgb;\n    }\n}\n\nvoid mainImage(out vec4 frag_color, in vec2 frag_coord)\n{\n    const float scene_depth = 10000.0;\n    \n    const vec3  fog_color   = vec3(0.4);\n    const float fog_density = 0.0017;\n\n    vec3 col = fog_color;\n\n    Ray ray = genRay(\n        vec3(0.0, -40.0 + (cos(iTime * 10.0)) * 2.0, iTime * 100.0),\n        frag_coord\n    );\n\n    float d = trace(ray, 0.001, scene_depth);\n\n    if (d < scene_depth) {\n        Surface surface = getSurface(ray, d);\n        col = vec3(0.3);\n\n        if (dot(surface.normal, vec3(1.0, 0.0, 0.0)) > 0.0 || \n            dot(surface.normal, vec3(-1.0, 0.0, 0.0)) > 0.0) {\n            col = getColor(surface);\n        } else {\n            vec3    new_ray_dir = reflect(ray.dir, surface.normal);\n            Ray     new_ray     = Ray(\n                surface.pos + surface.normal * eps.x, \n                new_ray_dir\n            );\n            \n            Surface nsurface;\n            float nd;\n            \n            for (int i = 0; i < 12; ++i) {\n                vec2 rand_res   = rand(vec2(i));\n                new_ray.dir     = new_ray_dir + vec3(rand_res.x, 0.0, rand_res.y) * 0.004;\n                nd              = trace(new_ray, 0.001, scene_depth);\n\n                if (nd < scene_depth) {\n                    nsurface =   getSurface(new_ray, nd);\n                    col      +=  getColor(nsurface);\n                }\n            }\n\n            col /= 12.0;\n        }\n\n        col = mix(fog_color, col, exp(-fog_density * d)) ;\n    }\n\n    frag_color = vec4(col, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}