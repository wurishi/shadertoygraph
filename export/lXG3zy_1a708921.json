{"ver":"0.1","info":{"id":"lXG3zy","date":"1717794500","viewed":76,"name":"LiveArchive #05","username":"Flopine","description":"I'm digging up old shaders made during VJ sessions to archive them here! \n\nChambéry 2020","likes":10,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","pulse","rainbow","orthographic","audioreactive","vj"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sXGRr","filepath":"/media/a/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3","previewfilepath":"/media/ap/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3","type":"music","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Code by Flopine\n\n// Thanks to wsmind, leon, XT95, lsdlive, lamogui, \n// Coyhot, Alkama,YX, NuSan, slerpy, wwrighter \n// BigWings, FabriceNeyret and Blackle for teaching me\n\n// Thanks LJ for giving me the spark :3\n\n// Thanks to the Cookie Collective, which build a cozy and safe environment for me \n// and other to sprout :)  \n// https://twitter.com/CookieDemoparty\n\n//Chambéry 2020\n\n#define time iTime\n\n#define PI acos(-1.)\n#define TAU 6.283185\n#define rot(a) mat2(cos(a),sin(a),-sin(a),cos(a))\n\n#define crep(p,c,l) p=p-c*clamp(round(p/c), -l, l)\n\n#define dt(speed) fract(time*speed)\n\n\nvoid mo (inout vec2 p, vec2 d)\n{\n    p = abs(p)-d;\n    if (p.y>p.x) p = p.yx;\n}\n\nfloat sc (vec3 p, float d)\n{\n    p = abs(p);\n    p = max(p,p.yzx);\n    return min(p.x,min(p.y,p.z))-d;\n}\n\nfloat box (vec3 p, vec3 c)\n{\n    vec3 q = abs(p)-c;\n    return min(0.,max(q.x,max(q.y,q.z)))+length(max(q,0.));\n}\n\nfloat od (vec3 p, float d)\n{return dot(p,normalize(sign(p)))-d;}\n\nvec2 id;\nfloat g1 = 0.;\nfloat SDF (vec3 p)\n{\n    p.yz *= rot(-atan(1./sqrt(2.)));\n    p.xz *= rot(PI/4.);\n\n    float kick = texture(iChannel0, vec2(0.03,0.25)).r;\n\n    float a = floor(dt(0.2)*TAU*4.);\n    p.xz += vec2(cos(a),sin(a));\n\n    mo(p.xz, vec2(2.));\n    p.x -= 1.;\n    mo(p.yz, vec2(0.2));\n    float per2 = 2.; \n    crep(p.y, per2, 2.);\n\n    float per = 1.9; \n    crep(p.xz,per,1.); \n    id = round(p.xz/per)-1.;  \n    float d = max(-sc(p,0.7-kick*0.4),box(p,vec3(0.85)));\n\n    p.y += sin(dt(length(id*2.))*TAU);\n    float o = od(p,0.3);  \n    g1 += 0.01/(0.01+o*o);\n\n    d = min(d,o);\n\n    return d;\n}\n\nvec3 getnorm (vec3 p)\n{\n    vec2 eps = vec2(0.01,0.);\n    return normalize(SDF(p)-vec3(SDF(p-eps.xyy),SDF(p-eps.yxy),SDF(p-eps.yyx)));\n}\n\nvec3 palette (float t, vec3 c, vec3 d)\n{return vec3(0.5)+vec3(0.5)*cos(TAU*(c*t+d));}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.*fragCoord.xy-iResolution.xy) / iResolution.y;\n\n    float detail = 80.-(-1.+2.*texture(iChannel0, vec2(0.0001, 0.25)).r*30.);\n    uv = floor(uv*detail)/detail;\n\n    vec3 ro = vec3(uv*9.,-30.), rd = vec3(0.,0.,1.);\n    vec3 p = ro, col = vec3(0.), l = normalize(vec3(1.,3.,-3.));\n\n    bool hit=false; float shad,d;\n\n    for (float i=0.; i<64.;i++)\n    {\n        d = SDF(p);\n        if (d<0.01)\n        {\n            hit = true;\n            shad = i/64.;\n            break;\n        }\n        p += d*rd*0.8;\n    }\n\n    if (hit)\n    {\n        vec3 n = getnorm(p);\n        float light = dot(n,l)*0.5+0.5;\n        col = vec3(light);\n    }\n    \n    col += g1*palette(length(uv),vec3(1.), vec3(0.,0.6,0.8));\n\n    fragColor = vec4(sqrt(col), 1.0);\n}","name":"Image","description":"","type":"image"}]}