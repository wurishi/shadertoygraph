{"ver":"0.1","info":{"id":"XffcRX","date":"1721358334","viewed":72,"name":"Rosquinhas molhadas","username":"Elsio","description":"Algo de errado não está certo","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["cubemap","glass","refract","object","ashtray","vidro"],"hasliked":0,"parentid":"XflyWH","parentname":"eu ainda nao sei fazer vidro "},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define normal(p) normalize(map(p)-vec3(map(p-e.xyy),map(p-e.yxy),map(p-e.yyx)))\n#define INIT      vec2 r = iResolution.xy, e = vec2(.001, 0); u = vec2(u - .5 * r) / r.y;\n#define rot(a) mat2(cos(a + vec4(0, 11, 33, 0)))\n#define far 100.\n#define t iTime\n\nvec3 glw;\n\n\nfloat box(vec3 p, vec3 s) {\n    vec3 q = abs(p) - s;\n    return length(max(q, 0.)) - length(p.xy)/1.2;\n}\n\nfloat torus(vec3 p, vec3 s) {\n    return length(vec2(length(p.xz) - 1.8, p.y)) - 1.1;\n}\n\nfloat map(vec3 p) {\n    float S, \n          b4, b3, b2, b1, b0, c0,\n          xID0, yID0, zID0, yID1;\n    \n    S     = sign(p.x);\n    p.x   = abs(p.x) - 8.5;\n    b4    = abs(box(p, vec3(8.3, 14, 14))) + .01;\n    p.yz *= rot(iTime * S);\n    \n    S     = sign(p.z);\n    p.z   = abs(p.z) - 6.5;\n    b3    = abs(box(p, vec3(9, 9, 6.3))) + .01;\n    p.xy *= rot(iTime * S);\n    \n    S     = sign(p.y);\n    p.y   = abs(p.y) - 3.5;\n    b2    = abs(box(p, vec3(7, 3.3, 7))) + .01;\n    p.xz *= rot(iTime * S);\n    \n    S     = sign(p.x);\n    p.x   = abs(p.x) - 3.5;\n    b1    = abs(box(p, vec3(3.3, 5, 5))) + .01;\n    p.yz *= rot(iTime * S);\n    \n    S     = sign(p.y);\n    p.y   = abs(p.y) - 1.5;\n    b0    = abs(box(p, vec3(3, 1.3, 3))) + .01;\n    p.xz *= rot(iTime * S);\n    \n    c0 = torus(p, vec3(2, 1, 1));\n    \n    c0 = min(b0, c0);\n    c0 = min(b1, c0);\n    c0 = min(b2, c0);\n    c0 = min(b3, c0);\n    c0 = min(b4, c0);\n    \n    float s, j, d;\n    \n    s = length(p - vec3(2.25, 0, 0.));\n    \n    for(j = 1.; j < 8.; j += j) \n        p *= j * .9, \n        c0 += .1 * abs(dot(sin(p), p/p)) / j;\n    \n    glw += .02 * normalize(p * p) / (s * s);\n    \n    return c0;\n    return min(d, c0);\n}\n\n\n\nvec3 shade(float d, vec3 p, vec3 N, vec3 r) {\n    vec3 ld  = normalize(vec3(3, 2, 4)),\n         col = vec3(.4, .4, .8),\n         bg  = \n               + vec3(1, 1, 8) / 10. \n               + length(r * r) * .5;\n    \n    if(d > far) return bg;\n    \n    float diff, fres, spec, ao, sss;\n    \n    diff = length(N * ld);\n    fres = abs(1. - length(N * r)) * .5;\n    spec = pow(max(dot(reflect(ld, N) * ld, -r), 0.), 6.);\n    ao   = clamp(1. - map(p + N * .1) * 10., 0., 1.) * .1;\n    sss  = smoothstep(0., 1., map(p * ld * 3.)) * 1. + 1.;\n    \n    return col * sss * diff + spec + fres - ao;\n}\n\nvoid mainImage(out vec4 o, vec2 u) {\n    INIT\n    \n    vec3 p = vec3(0, 0, -22),\n         D = normalize(vec3(u, 1)),\n         N, _D, \n         col, cor;\n    \n    float i, d, j, s, \n          io = 1.45, \n          alpha = 1., \n          z = 1.;\n    \n    while(i++ < 8. && d < far) {\n        s = 1.;\n        while(j++ < 133. && s > .01 && d < far) \n            s = z * map(p),\n            p += s * D,\n            d += s;\n        \n        N = z * normal(p);\n        \n        if(z > 0.) \n            col += alpha * (shade(d, p, N, D) - col);\n        \n        _D = D;\n        D = refract(D, N, z > 0. ? 1. / io : io);\n        if(dot(D, D) == 0.) \n            D = reflect(_D, N);\n            \n        p -= .1 * N;\n        alpha *= .1;\n        z = -z;\n    }\n    \n    o.rgb = col + glw;\n}","name":"Image","description":"","type":"image"}]}