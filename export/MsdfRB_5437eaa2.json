{"ver":"0.1","info":{"id":"MsdfRB","date":"1525794066","viewed":96,"name":"PUBG Helmet","username":"senzheng","description":"learn raymarching","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["learn"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sX3zn","filepath":"/media/a/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png","previewfilepath":"/media/ap/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// My First Shadertoy Demo.\n// Based on the tutorials of IQ\n\nvec3 hash( vec3 p ) // replace this by something better\n{\n\tp = vec3( dot(p,vec3(127.1,311.7, 74.7)),\n\t\t\t  dot(p,vec3(269.5,183.3,246.1)),\n\t\t\t  dot(p,vec3(113.5,271.9,124.6)));\n\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\nfloat noise( in vec3 p )\n{\n    vec3 i = floor( p );\n    vec3 f = fract( p );\n\t\n\tvec3 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( mix( dot( hash( i + vec3(0.0,0.0,0.0) ), f - vec3(0.0,0.0,0.0) ), \n                          dot( hash( i + vec3(1.0,0.0,0.0) ), f - vec3(1.0,0.0,0.0) ), u.x),\n                     mix( dot( hash( i + vec3(0.0,1.0,0.0) ), f - vec3(0.0,1.0,0.0) ), \n                          dot( hash( i + vec3(1.0,1.0,0.0) ), f - vec3(1.0,1.0,0.0) ), u.x), u.y),\n                mix( mix( dot( hash( i + vec3(0.0,0.0,1.0) ), f - vec3(0.0,0.0,1.0) ), \n                          dot( hash( i + vec3(1.0,0.0,1.0) ), f - vec3(1.0,0.0,1.0) ), u.x),\n                     mix( dot( hash( i + vec3(0.0,1.0,1.0) ), f - vec3(0.0,1.0,1.0) ), \n                          dot( hash( i + vec3(1.0,1.0,1.0) ), f - vec3(1.0,1.0,1.0) ), u.x), u.y), u.z );\n}\n\n//------------------------------------------------------------------\n\nfloat opS( float d1, float d2 )\n{\n    return max(-d2,d1);\n}\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nfloat opI( float d1, float d2 )\n{\n    return max(d1,d2);\n}\n\nvec3 opRep( vec3 p, vec3 c )\n{\n    return mod(p,c)-0.5*c;\n}\n\nvec3 opTwist( vec3 p )\n{\n    float  c = cos(10.0*p.y+10.0);\n    float  s = sin(10.0*p.y+10.0);\n    mat2   m = mat2(c,-s,s,c);\n    return vec3(m*p.xz,p.y);\n}\n\n//------------------------------------------------------------------\n\nfloat sdPlane( vec3 p )\n{\n\treturn p.y;\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat udRoundBox( vec3 p, vec3 b, float r )\n{\n    return length(max(abs(p)-b,0.0))-r;\n}\n\n\nfloat sdCylinder( vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nmat3 setRotateMat(vec3 yNor) {\n\tvec3 y = normalize(yNor);\n    vec3 ztemp = normalize(vec3(0.0, 0.0, 1.0));\n\tvec3 x = normalize( cross(ztemp, y) );\n\tvec3 z = normalize( cross(y, x) );\n    return mat3( x, y, z );\n}\n\nfloat screw(vec3 p, vec2 h, vec3 yNor) {\n    mat3 rotateMat = setRotateMat(yNor);\n    p = rotateMat*p;\n\tvec2 d = abs(vec2(length(p.xz),p.y)) - h;\n\tfloat result = min(max(d.x,d.y),0.0) + length(max(d,0.0));\n    result = opS(\tresult,\tsdBox( p + vec3(0., -h.y, 0.), vec3(h.x - 0.01, h.y / 5. * 4., h.x/5.) ) \t);\n    result = opS(\tresult,\tsdBox( p + vec3(0., -h.y, 0.), vec3( h.x/5., h.y / 5. * 4.,h.x - 0.01) ) \t);\n\treturn result;\n}\n\nvec2 mask01( vec3 p, vec2 h, float r)\n{\n    const float angle = -0.35;\n    const mat3 rotateMat = mat3( 1.00,  0.00,  0.00,\n                                0.00,  cos(angle), sin(angle),\n                                0.00,  -sin(angle), cos(angle));\n    p = rotateMat * p;\n    p += vec3(0.0, 0.3, 0.0);\n    float d = opS(\tsdCylinder(  p,  h ), sdCylinder(  p,  h + vec2(-r, 0.1))\t);\n    d = opI(d, udRoundBox(\tp+vec3(0., 0., h.x),\tvec3(h.x, h.y-0.15, h.x),\t0.15));\n    \n    vec2 result = vec2(d, 1.0);\n    \n    // 螺丝\n    result = opU(result, vec2(screw(p - vec3(-h.x-0.03, 0.3, 0.0), vec2(0.03, 0.01), vec3(-1., 0., 0.)),\t3.0));\n    result = opU(result, vec2(screw(p - vec3(h.x+0.03, 0.3, 0.0), vec2(0.03, 0.01), vec3(1., 0., 0.)),\t3.0));\n    \n    if (result.y == 1.0)\n    \tresult.x -= 0.02;\n    else\n        result.y = 1.0;\n    return result;\n}\n\nvec2 mask02(vec3 p, vec2 h) {\n    \n    float m = 1.0;\n\t\n    const float angle = -0.35;\n    const mat3 rotateMat = mat3( 1.00,  0.00,  0.00,\n                                0.00,  cos(angle), sin(angle),\n                                0.00,  -sin(angle), cos(angle));\n    p = rotateMat * p;\n    p += vec3(0.0, 0.3, 0.0);\n    float d = sdCylinder(  p,  vec2(h.x, h.y) );\n    d = opI(\td, udRoundBox(\tp+vec3(0., 0., h.x),\tvec3(h.x-0.15, h.y-0.02, h.x),\t0.02)\t);\n    \n    \n    float d2 = sdCylinder(  p,  vec2(h.x+0.2, h.y-0.05) );\n    d2 = opS(d2, sdCylinder(  p,  vec2(h.x-0.025, h.y) ));\n    d2 = opI(\td2, udRoundBox(\tp+vec3(0., 0., h.x),\tvec3(h.x-0.3, h.y-0.05-0.02, h.x),\t0.1)\t);\n    \n    d = opS(d, d2);\n    vec2 result = vec2(d, m);\n    \n    // 螺丝\n    result = opU(result, vec2(screw(p - vec3(-h.x+0.11, 0.06, -0.4), vec2(0.03, 0.01), vec3(-1., 0., 0.)),\t3.0));\n    result = opU(result, vec2(screw(p - vec3(-h.x+0.11, -0.06, -0.4), vec2(0.03, 0.01), vec3(-1., 0., 0.)),\t3.0));\n    result = opU(result, vec2(screw(p - vec3(h.x-0.11, 0.06, -0.4), vec2(0.03, 0.01), vec3(1., 0., 0.)),\t3.0));\n    result = opU(result, vec2(screw(p - vec3(h.x-0.11, -0.06, -0.4), vec2(0.03, 0.01), vec3(1., 0., 0.)),\t3.0));\n    \n    if (result.x == -d2) {\n    \tresult.y = 0.0;\n    }\n    if (result.y != 3.0) {\n    \tresult.x -= 0.01;\n    } else {\n    \tresult.y = 1.0;\n    }\n    \n    return result;\n}\n\nfloat sinPlane(vec3 pos)\n{\n    float phase = 3.7;\n    float amp = 0.32;\n    float freq = 2.4;\n    float offset = 1.;\n    return pos.y - amp*sin(pos.z*freq+phase) - offset;\n}\n\nvec2 map( in vec3 pos )\n{\n    vec2 res = vec2( sdPlane(     pos), 2.0 );\n    // 后脑勺\n    res = opU( res, vec2( opS(sdSphere(    pos-vec3(.0, 1.2, .0), 1.), sinPlane(\tpos)), 1.0 ) );\n    // 眼罩01\n    res = opU( res, mask01(\tpos-vec3(.0, 1.3, -0.1),\tvec2(1.0, 0.46), 0.003) );\n    // 眼罩02\n    res = opU( res, mask02(\tpos-vec3(.0, 1.5, -0.1),\tvec2(1.1, 0.16))\t);\n    \n    return res;\n}\n\nvec2 castRay( in vec3 ro, in vec3 rd )\n{\n    float tmin = 1.0;\n    float tmax = 20.0;\n   \n    \n    float t = tmin;\n    float m = -1.0;\n    for( int i=0; i<64; i++ )\n    {\n\t    float precis = 0.0005*t;\n\t    vec2 res = map( ro+rd*t );\n        if( res.x<precis || t>tmax ) break;\n        t += res.x;\n\t    m = res.y;\n    }\n\n    if( t>tmax ) m=-1.0;\n    return vec2( t, m );\n}\n\n\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n\tfloat res = 1.0;\n    float t = mint;\n    for( int i=0; i<16; i++ )\n    {\n\t\tfloat h = map( ro + rd*t ).x;\n        res = min( res, 8.0*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( h<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    return normalize( e.xyy*map( pos + e.xyy ).x + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx ).x + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy ).x + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx ).x );\n    /*\n\tvec3 eps = vec3( 0.0005, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t    map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n\t    map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n\t    map(pos+eps.yyx).x - map(pos-eps.yyx).x );\n\treturn normalize(nor);\n\t*/\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos ).x;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n\nconst mat3 noiseMat = mat3( 0.00,  0.80,  0.60,\n                    -0.80,  0.36, -0.48,\n                    -0.60, -0.48,  0.64 );\nvec3 render( in vec3 ro, in vec3 rd )\n{ \n    vec3 col = vec3(0.7, 0.9, 1.0) +rd.y*0.8;\n    vec2 res = castRay(ro,rd);\n    float t = res.x;\n\tfloat m = res.y;\n    if( m>-0.5 )\n    {\n        vec3 pos = ro + t*rd;\n        vec3 nor = normalize(calcNormal( pos ) + noise(pos*100.0) / 4.0);\n        vec3 ori_nor = normalize(calcNormal( pos ));\n        vec3 ref = reflect( rd, nor );\n        vec3 ori_ref = reflect( rd, ori_nor );\n        \n        // material        \n        col = vec3(0.03, 0.03, 0.03);\n        if (m == 3.0)\n            col = vec3(0.8, 0.8, 0.8);\n\n        // lighitng        \n        float occ = calcAO( pos, nor );\n\t\tvec3  lig = normalize( vec3(-0.4, 0.7, -0.6) );\n        vec3  hal = normalize( lig-rd );\n\t\tfloat amb = clamp( 0.5+0.5*nor.y, 0.0, 1.0 );\n        float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n        float bac = clamp( dot( nor, normalize(vec3(-lig.x,0.0,-lig.z))), 0.0, 1.0 )*clamp( 1.0-pos.y,0.0,1.0);\n        float dom = smoothstep( -0.1, 0.1, ref.y );\n        float fre = pow( clamp(1.0+dot(nor,rd),0.0,1.0), 2.0 );\n        \n        dif *= calcSoftshadow( pos, lig, 0.02, 2.5 );\n        dom *= calcSoftshadow( pos, ref, 0.02, 2.5 );\n\n\t\tfloat spe = pow( clamp( dot( nor, hal ), 0.0, 1.0 ),36.0)*dif ;\n        \n\t\tvec3 lin = vec3(0.0);\n        lin += 1.30*dif*vec3(1.00,0.80,0.55);\n        lin += 0.40*amb*vec3(0.40,0.60,1.00)*occ;\n        lin += 0.50*dom*vec3(0.40,0.60,1.00)*occ;\n        lin += 0.50*bac*vec3(0.25,0.25,0.25)*occ;\n        lin += 0.25*fre*vec3(1.00,1.00,1.00)*occ;\n        \n        \n        float occ2 = 1.0;\n        float dirt = 1.0;\n        if (m == 1.0 || m == 3.0) {\n        \n            // test dirt\n            vec3 q = 20.0*pos;\n            float f = 0.0;\n            f  = 0.5000*noise( q ); q = noiseMat*q*2.01;\n            f += 0.2500*noise( q ); q = noiseMat*q*2.02;\n            f += 0.1250*noise( q ); q = noiseMat*q*2.03;\n            f += 0.0625*noise( q ); q = noiseMat*q*2.01;\n\n            dirt = clamp(pow(occ, f*3.), 0., 1.);\n\n            q = 4.0*pos;\n            f  = 0.5000*noise( q ); q *= 2.02;\n            f += 0.2500*noise( q ); q *= 2.02;\n            f += 0.2500*noise( q ); q *= 2.02;\n            f += 0.2500*noise( q ); q *= 2.02;\n            f += 0.2500*noise( q ); q *= 2.02;\n            f += 0.2500*noise( q ); q *= 2.02;\n            //f = pow(f, .1);\n\n            occ2 *= 1. - f;\n            occ2 = clamp(occ2, 0., 1.);\n\n            col = mix(col, vec3(1., 0.8, 0.6), pow((1.-occ2), 1.6));\n            col = mix(col, vec3(1.2, 1.2, 1.2), pow((1.-dirt), 1.4));\n        }\n        \n        float fresnel = pow(clamp(dot(ori_ref, rd)+0.3, 0.0, 1.0), 1.2);\n        vec3 ref_col = (pow(texture(iChannel0, ref).xyz,vec3(2.0))- .5) * pow(occ2, 2.2);\n        ref_col = mix(vec3(0.), ref_col, fresnel);\n        lin += 1.2*ref_col;\n\t\tcol = col*lin;\n        \n\t\tcol += 1.00*spe*vec3(1.0,1.0,1.0)*pow(occ2, 6.5);\n\n    \tcol = mix( col, vec3(0.8,0.9,1.0), 1.0-exp( -0.0002*t*t*t ) );\n        \n        // 镜面反射\n        if (m == 0.0) {\n            col = (pow(texture(iChannel0, ori_ref).xyz,vec3(2.0))- .5) * occ2;\n            \n            col = mix(vec3(0.), col, fresnel);\n        }\n        \n        //col = vec3(ref_col);\n        //col = vec3(occ);\n        \n    }\n\n\treturn vec3( clamp(col,0.0,1.0) );\n}\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 mo = iMouse.xy/iResolution.xy;\n\tfloat time = 15.0 + iTime;\n    vec3 tot = vec3(0.0);\n \n    vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n    // camera\t\n    vec3 ro = vec3( 3.*cos(0.3*time + 6.0*mo.x), 0.7 + 2.0*mo.y, 3.*sin(0.3*time + 6.0*mo.x) );\n    vec3 ta = vec3( 0.0, 0.9, 0.0 );\n    // camera-to-world transformation\n    mat3 ca = setCamera( ro, ta, 0.0 );\n    // ray direction\n    vec3 rd = ca * normalize( vec3(p.xy,2.0) );\n\n    // render\t\n    vec3 col = render( ro, rd );\n\n    // gamma\n    col = pow( col, vec3(0.4545) );\n\n    tot += col;\n\n    \n    fragColor = vec4( tot, 1.0 );\n}","name":"Image","description":"","type":"image"}]}