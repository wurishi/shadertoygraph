{"ver":"0.1","info":{"id":"ssXSWs","date":"1619448649","viewed":380,"name":"Atmosphere by Sebastian Lague","username":"playbyan1453","description":"Atmosphere shader that originally written by Sebastian Lague on his YouTube vlog, Updated just fixed the overlay issue i need to learn more about ray tracer.","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["atmosphere"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define inPoints 8\n#define opticalPoints 8\n#define planetPos vec3(0)\n#define radius 1.0\n#define aRadius (radius+1.0)\n#define densityFalloff 1.0\n#define epsilon 1e-4\n#define sunPos normalize(vec3(cos(iTime), 0, sin(-iTime)))\n\nvec2 sphere(vec3 ro, vec3 rd, vec3 p, float r) {\n    vec3 o = ro - p;\n    float a = 1.0;\n    float b = 2.0 * dot(o, rd);\n    float c = dot(o, o) - r * r;\n    float d = b * b - 4.0 * a * c;\n\n    if(d > 0.0) {\n        float s = sqrt(d);\n        float dSN = max(0.0, (-b - s) / (2.0 * a));\n        float dSF = (-b + s) / (2.0 * a);\n\n        if(dSF >= 0.0) {\n            return vec2(dSN, dSF - dSN);\n        }\n    }\n    return vec2(0);\n}\n\nvec3 sphereN(vec3 p, vec3 sph) {\n    return normalize(p-sph);\n}\n\nfloat densityAtPoint(vec3 p) {\n    float heightAboveSurface = length(p-planetPos) - radius;\n    float height01 = heightAboveSurface / (aRadius - radius);\n    float localDensity = exp(-height01 * densityFalloff) * (1.0 - height01);\n    return localDensity;\n}\n\nfloat opticalDepth(vec3 ro, vec3 rd, float rl) {\n    vec3 densityPoint = ro;\n    float stepSize = rl / float(opticalPoints-1);\n    float opticalDepth;\n\n    for(int i = 0; i < opticalPoints; i++) {\n        float localDensity = densityAtPoint(densityPoint);\n        opticalDepth += localDensity * stepSize;\n        densityPoint += rd * stepSize;\n    }\n    return opticalDepth;\n}\n\nfloat light(vec3 ro, vec3 rd, float rl) {\n    vec3 inPoint = ro;\n    float stepSize = rl / float(inPoints-1);\n    float inScatterLight;\n    for(int i = 0; i < inPoints; i++) {\n        float sunRayLength = sphere(inPoint, sunPos, planetPos, aRadius).y;\n        float sunOpticalDepth = opticalDepth(inPoint, sunPos, sunRayLength);\n        float viewOpticalDepth = opticalDepth(inPoint, -rd, stepSize * float(i));\n        float transmittance = exp(-(sunOpticalDepth + viewOpticalDepth));\n        float localDensity = densityAtPoint(inPoint);\n\n        inScatterLight += localDensity * transmittance * stepSize;\n        inPoint += rd * stepSize;\n    }\n    return inScatterLight;\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n    vec2 uv = (2.0*fragCoord.xy-iResolution.xy)/max(iResolution.x, iResolution.y);\n    vec3 at = vec3(0, 0, 0);\n    vec3 ro = vec3(0, 0, -6);\n    vec3 cam_z = normalize(at - ro);\n    vec3 cam_x = normalize(cross(vec3(0, 1, 0), cam_z));\n    vec3 cam_y = cross(cam_z, cam_x);\n    vec3 rd = normalize(uv.x * cam_x + uv.y * cam_y + 2.0 * cam_z);\n\n    vec3 col = vec3(0);\n    vec2 s = sphere(ro, rd, planetPos, radius);\n    vec2 a = sphere(ro, rd, planetPos, aRadius);\n    float tmin = 1e19;\n    if(s.x > 0.0 && tmin > s.x) {\n        tmin = s.x;\n        vec3 sN = sphereN(normalize(ro+rd*tmin), planetPos);\n        col = vec3(max(0.0, dot(sN, sunPos)));\n    }\n    float dtA = min(a.y, tmin-a.x);\n    if(dtA > 0.0 && tmin > a.x) {\n        vec3 inPoint = ro+rd*(a.x-epsilon);\n        float light = light(inPoint, rd, dtA+epsilon*2.0);\n        col = col * (1.0-light) + light;\n    }\n\n    fragColor = vec4(col, 1.0);;\n}","name":"Image","description":"","type":"image"}]}