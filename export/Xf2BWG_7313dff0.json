{"ver":"0.1","info":{"id":"Xf2BWG","date":"1725632998","viewed":34,"name":"Bezier Curve (For character)","username":"NothingToSay","description":"Using Bezier curve to draw character on a street nameplate.","likes":1,"published":1,"flags":32,"usePreview":0,"tags":["bezier"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const int MAX_STEPS = 255;\nconst float MIN_DEPTH = 0.0;\nconst float MAX_DEPTH = 100.0;\nconst float HIT_PRECISION = 0.001;\nconst float EPSILON_OFFSET = 0.0005;\n\nstruct Surface {\n    float sdf;  // Signed distance value\n    vec3 color; // Surface color\n};\n\n// Signed distance function for the floor\nSurface sdfFloor(vec3 position, vec3 color) {\n    float distToFloor = position.y + 1.0;\n    return Surface(distToFloor, color);\n}\n\n// Union of two surfaces\nSurface unionSurfaces(Surface surfaceA, Surface surfaceB) {\n    if (surfaceB.sdf < surfaceA.sdf) {\n        return surfaceB;\n    } else {\n        return surfaceA;\n    }\n}\n\n// Signed distance function for a cylinder\nSurface sdfCylinder(vec3 position, float height, float radius) {\n    vec2 distXZ_Y = abs(vec2(length(position.xz), position.y)) - vec2(radius, height * 0.5);\n    float sdfCylinder = min(max(distXZ_Y.x, distXZ_Y.y), 0.0) + length(max(distXZ_Y, 0.0));\n    return Surface(sdfCylinder, vec3(0.6));\n}\n\n// Signed distance function for a textured box\nSurface sdfTexturedBox(vec3 position, vec3 dimensions) {\n    vec3 distXYZ = abs(position) - dimensions;\n    vec3 boxColor = vec3(0.0, 0.0, 0.3);\n\n    vec2 uv = (position.xy + dimensions.xy) / (2.0 * dimensions.xy);\n\n    // Apply texture if z-coordinate is greater than box's z\n    if (position.z >= dimensions.z) {\n        boxColor = texture(iChannel0, uv).rgb;\n    }\n\n    float sdfBox = length(max(distXYZ, 0.0)) + min(max(distXYZ.x, max(distXYZ.y, distXYZ.z)), 0.0);\n    return Surface(sdfBox, boxColor);\n}\n\n// Scene function that computes the closest distance to any object\nSurface sceneSDF(vec3 position) {\n    vec3 floorColor = vec3(0.1 + 0.7 * mod(floor(position.x) + floor(position.z), 2.0));\n    vec3 signPos = position - vec3(0.0, 0.5, 0.5);\n    vec3 cylinderPos = position - vec3(0.0, -1.0, 0.4);\n\n    Surface floorSurface = sdfFloor(position, floorColor);\n    Surface cylinderSurface = sdfCylinder(cylinderPos, 3.0, 0.1);\n    Surface boxSurface = sdfTexturedBox(signPos, vec3(1.5, 0.75, 0.05));\n\n    floorSurface = unionSurfaces(floorSurface, cylinderSurface);\n    floorSurface = unionSurfaces(floorSurface, boxSurface);\n\n    return floorSurface;\n}\n\n// Ray marching algorithm\nSurface rayMarching(vec3 origin, vec3 direction) {\n    float currentDepth = MIN_DEPTH;\n    Surface closestSurface;\n\n    for (int step = 0; step < MAX_STEPS; step++) {\n        vec3 samplePos = origin + currentDepth * direction;\n        closestSurface = sceneSDF(samplePos);\n        currentDepth += closestSurface.sdf;\n\n        if (closestSurface.sdf < HIT_PRECISION || currentDepth > MAX_DEPTH) {\n            break;\n        }\n    }\n\n    closestSurface.sdf = currentDepth;\n    return closestSurface;\n}\n\n// Compute the normal using finite differences\nvec3 calculateNormal(vec3 position) {\n    vec2 e = vec2(1.0, -1.0) * EPSILON_OFFSET;\n    return normalize(\n        e.xyy * sceneSDF(position + e.xyy).sdf +\n        e.yyx * sceneSDF(position + e.yyx).sdf +\n        e.yxy * sceneSDF(position + e.yxy).sdf +\n        e.xxx * sceneSDF(position + e.xxx).sdf\n    );\n}\n\n// Compute soft shadow\nfloat computeSoftShadow(vec3 origin, vec3 direction, float minDist, float maxDist) {\n    float shadowFactor = 1.0;\n    float depth = minDist;\n\n    for (int i = 0; i < 16; i++) {\n        float sdfValue = sceneSDF(origin + direction * depth).sdf;\n        shadowFactor = min(shadowFactor, 8.0 * sdfValue / depth);\n        depth += clamp(sdfValue, 0.02, 0.10);\n\n        if (sdfValue < 0.001 || depth > maxDist) break;\n    }\n\n    return clamp(shadowFactor, 0.0, 1.0);\n}\n\n// Camera transformation matrix\nmat3 lookAtCamera(vec3 cameraPos, vec3 target) {\n    vec3 forward = normalize(target - cameraPos);\n    vec3 right = normalize(cross(vec3(0.0, 1.0, 0.0), forward));\n    vec3 up = normalize(cross(forward, right));\n\n    return mat3(-right, up, -forward);\n}\n\n// 2D rotation matrix\nmat2 rotate2D(float angle) {\n    float sinAngle = sin(angle);\n    float cosAngle = cos(angle);\n    return mat2(cosAngle, -sinAngle, sinAngle, cosAngle);\n}\n\n// Compute ambient occlusion\nfloat computeAO(vec3 position, vec3 normal) {\n    float occlusion = 0.0;\n    float scale = 1.0;\n\n    for (int i = 0; i < 5; i++) {\n        float stepSize = 0.01 + 0.12 * float(i) / 4.0;\n        vec3 samplePos = normal * stepSize + position;\n        float sdfValue = sceneSDF(samplePos).sdf;\n        occlusion += -(sdfValue - stepSize) * scale;\n        scale *= 0.95;\n    }\n\n    return clamp(1.0 - 3.0 * occlusion, 0.0, 1.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    vec2 mouseCoord = iMouse.xy / iResolution.xy;\n    vec3 backgroundColor = vec3(0.835, 1.0, 1.0);\n    const float PI = 3.14159265359;\n    mouseCoord.y = clamp(0., 0.5, mouseCoord.y);\n    if (mouseCoord == vec2(0.0)) mouseCoord = vec2(0.5); // Default center\n\n    vec3 sceneColor = vec3(0.0);\n    vec3 lookAt = vec3(0.0, 0.0, 2.0);\n    vec3 cameraPos = vec3(0.0, 0.0, 4.0);\n\n    // Adjust camera position based on mouse movement\n    float cameraRadius = 2.0;\n    cameraPos.yz = cameraPos.yz * cameraRadius * rotate2D(mix(-PI / 2.0, PI / 2.0, mouseCoord.y));\n    cameraPos.xz = cameraPos.xz * rotate2D(mix(-PI, PI, mouseCoord.x)) + vec2(lookAt.x, lookAt.z);\n\n    vec3 rayDir = lookAtCamera(cameraPos, lookAt) * normalize(vec3(uv, -1.0)); // Ray direction\n    Surface hitSurface = rayMarching(cameraPos, rayDir);\n\n    if (hitSurface.sdf > MAX_DEPTH) {\n        sceneColor = backgroundColor; // Missed any object\n    } else {\n        sceneColor = hitSurface.color;\n        vec3 hitPoint = cameraPos + rayDir * hitSurface.sdf;\n        vec3 normalVec = calculateNormal(hitPoint);\n\n        vec3 reflection = reflect(rayDir, normalVec);\n        float aoFactor = computeAO(hitPoint, normalVec);\n        vec3 lightDir = normalize(vec3(0.4, 6.0, 4.0));\n        float ambientLight = clamp(0.5 + 0.5 * normalVec.y, 0.0, 1.0);\n        float diffuseLight = clamp(dot(normalVec, lightDir), 0.0, 1.0);\n        float domeLight = smoothstep(-0.1, 0.1, reflection.y);\n        float fresnelEffect = pow(clamp(1.0 + dot(normalVec, rayDir), 0.0, 1.0), 2.0);\n        float specularReflection = pow(clamp(dot(reflection, lightDir), 0.0, 1.0), 16.0);\n\n        diffuseLight *= computeSoftShadow(hitPoint, lightDir, 0.02, 4.0);\n        domeLight *= computeSoftShadow(hitPoint, reflection, 0.02, 4.0);\n\n        vec3 lighting = vec3(0.0);\n        lighting += 1.30 * diffuseLight * vec3(1.00, 0.80, 0.55);\n        lighting += 2.00 * specularReflection * vec3(1.00, 0.90, 0.70) * diffuseLight;\n        lighting += 0.40 * ambientLight * vec3(0.40, 0.60, 1.00) * aoFactor;\n        lighting += 0.50 * domeLight * vec3(0.40, 0.60, 1.00) * aoFactor;\n        lighting += 0.25 * fresnelEffect * vec3(1.00, 1.00, 1.00) * aoFactor;\n\n        sceneColor *= lighting;\n    }\n\n    // Apply fog\n    sceneColor = mix(sceneColor, backgroundColor, 1.0 - exp(-0.0002 * hitSurface.sdf * hitSurface.sdf * hitSurface.sdf));\n    sceneColor = pow(sceneColor, vec3(1.0 / 2.2)); // Gamma correction\n    fragColor = vec4(sceneColor, 1.0); // Output color\n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Returns the alpha value of a line, indicating its transparency\nfloat drawCurvedLine(vec2 uv, vec2 start, vec2 end, float startThickness, float endThickness, float curvature) {\n    // Normalize UV coordinates to the range [0, 1]\n    vec2 p = uv;\n    \n    // Compute the direction and distance from start to end\n    vec2 dir = end - start;\n    float lineLength = length(dir); // Length of the line segment\n    vec2 normDir = dir / lineLength; // Normalized direction vector\n\n    // Calculate the control point for the curve, controlling the line's curvature\n    vec2 controlPoint = (start + end) * 0.5 + vec2(-normDir.y, normDir.x) * curvature;\n\n    // Compute the closest point on the Bézier curve to the UV coordinate\n    float t = clamp(dot(p - start, normDir) / lineLength, 0.0, 1.0);\n    vec2 curvePos = mix(mix(start, controlPoint, t), mix(controlPoint, end, t), t);\n\n    // Interpolate thickness based on the line's start and end thickness\n    float thickness = mix(startThickness, endThickness, t);\n\n    // Calculate the perpendicular distance from the UV coordinate to the curve\n    vec2 perpDir = vec2(-normDir.y, normDir.x); // Perpendicular direction vector\n    float distPerp = abs(dot(p - curvePos, perpDir)); // Distance from the point to the line\n\n    // Compute the distance along the line segment, and clamp it within the segment's bounds\n    float distAlongLine = dot(p - start, normDir);\n    float cappedDist = clamp(distAlongLine, 0.0, lineLength);\n    \n    // Alpha is 1 if inside the line segment, otherwise a smooth transition based on the perpendicular distance\n    float lineAlpha = smoothstep(thickness * 0.5, thickness * 0.5 + 0.005, distPerp);\n    float capAlpha = smoothstep(-0.001, 0.001, abs(distAlongLine - cappedDist));\n        \n    // Return the maximum of the line's alpha and the end caps' alpha\n    return max(lineAlpha, capAlpha);\n}\n\n// Compute the SDF (Signed Distance Field) for a curved line\nfloat sdfCurvedLine(vec2 uv, vec2 start, vec2 end, float startThickness, float endThickness, float curvature) {\n    // Normalize UV coordinates to the range [0, 1]\n    vec2 p = uv;\n    \n    // Compute the direction and distance from start to end\n    vec2 dir = end - start;\n    float lineLength = length(dir);  // Length of the line segment\n    vec2 normDir = dir / lineLength; // Normalized direction vector\n\n    // Calculate the control point for the curve, controlling the line's curvature\n    vec2 controlPoint = (start + end) * 0.5 + vec2(-normDir.y, normDir.x) * curvature;\n\n    // Compute the closest point on the Bézier curve to the UV coordinate\n    float t = clamp(dot(p - start, normDir) / lineLength, 0.0, 1.0);\n    vec2 curvePos = mix(mix(start, controlPoint, t), mix(controlPoint, end, t), t);\n\n    // Interpolate thickness based on the line's start and end thickness\n    float thickness = mix(startThickness, endThickness, t);\n\n    // Calculate the distance from the point to the curve\n    float distToCurve = length(p - curvePos) - thickness * 0.5;\n\n    return distToCurve; // Return the SDF value, representing the distance to the line\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Normalize coordinates to [0, 1]\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    // Define start and end points, thickness, and curvature\n    vec2 start = vec2(0.4, 0.3);\n    vec2 end = vec2(0.4, 0.5);\n    float startThickness = 0.05;\n    float endThickness = 0.01;\n    float curvature = 0.02;\n    \n    // Calculate the distance field for the curved line\n    float dist = sdfCurvedLine(uv, start, end, startThickness, endThickness, curvature);\n    \n    // Compute another line segment distance for combination\n    dist = min(dist, sdfCurvedLine(uv, start, vec2(0.6, 0.3), startThickness, endThickness, curvature));\n    \n    // Use smoothstep for anti-aliasing\n    float alpha = smoothstep(0.005, 0.0, dist); // Control alpha gradient\n    \n    vec3 color = vec3(0.0, 0.0, 253.0 / 255.0); // Line color\n    color = mix(color, vec3(1.0, 1.0, 1.0), alpha); // Blend with background color\n    \n    fragColor = vec4(color, 1.0); // Output color\n}\n","name":"Buffer A","description":"","type":"buffer"}]}