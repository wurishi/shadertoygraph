{"ver":"0.1","info":{"id":"wtjfWh","date":"1598912967","viewed":386,"name":"simple matrix transform test","username":"benhardy","description":"test to sanely use matrix multiplication in glsl. yay!","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["matrix","affine"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"struct Light {\n    vec3 position;\n    vec3 color;\n};\n\nconst Light light1 = Light(vec3(4,5,1), vec3(1,1,1));\n\n/**\n * Affine transformation matrix constructors\n */\nmat4 translation(vec3 v) {\n    return mat4(1,0,0,-v.x, 0,1,0,-v.y, 0,0,1,-v.z, 0,0,0,1);\n}\n\nmat4 rotateZ(float angle) {\n    float c= cos(angle), s=sin(angle);\n    return mat4(c,s,0,0, -s,c,0,0, 0,0,1,0, 0,0,0,1);\n}\n    \n/**\n * Raymarching parameters\n */\n#define MAX_DIST 100.0\n#define MAX_STEP 500\n#define STEP_RATIO 0.350\n#define EPSILON 0.001\n\n/**\n * Scene object identifiers\n */\n#define ID_SPHERE 1\n#define ID_PLANE  2\n#define ID_POLE   3\n#define ID_LIGHT  4\n#define ID_LIGHTPOST  5\n\n/**\n * Handy colour and vector constants\n */\nconst vec3 X = vec3(1,0,0);\nconst vec3 Y = vec3(0,1,0);\nconst vec3 Z = vec3(0,0,1);\nconst vec3 RED = vec3(1,0,0);\nconst vec3 YELLOW = vec3(1,1,0);\nconst vec3 CYAN = vec3(0,1,1);\nconst vec3 BLUE = vec3(0,0,1);\nconst vec3 WHITE = vec3(1,1,1);\nconst vec3 BLACK = vec3(0,0,0);\nconst mat4 IDENTITY_TRANSFORM = mat4(1,0,0,0, 0,1,0,0, 0,0,1,0, 0,0,0,1);\n\n/**\n * Measure the distance to the closest scene object.\n *\n * Input Parameters:\n *   where - the point from which we measure the distance\n *\n * Output Parameters:\n *   dist_out - the resulting measured distance to the closest object\n *   localPosition_out - the \"where\" point, transformed into the closest object's\n *                coordinate space, used for pigmenting later on\n * Return Value:\n *   The id of the closest object\n */\nint measure(vec3 where, bool forShadow, out float dist_out, out vec3 localPosition_out) {\n    float rolling = 3.0*sin(iTime* 0.49);\n    mat4 sphereTran = translation(Y*1.0 + X * rolling) * rotateZ(-rolling);\n        \n    vec3 sphereLocal = vec3(mod(where.xz+5.0,10.0) - 5.0, where.y).xzy;\n    sphereLocal = (vec4(sphereLocal,1)* sphereTran).xyz;\n    vec3 planeLocal = (vec4(where,1)* IDENTITY_TRANSFORM).xyz;\n\n    // mod then reflect pole space along diagonal axes, forming a 3d grid\n    vec3 poleLocal = where + vec3(5,-0.1,5);\n    poleLocal = abs(mod(poleLocal+5.0, 10.0) -5.0);\n    poleLocal.xz = vec2(max(poleLocal.x,poleLocal.z),min(poleLocal.x,poleLocal.z));\n    poleLocal.xy = vec2(min(poleLocal.x,poleLocal.y),max(poleLocal.x,poleLocal.y));\n    \n    // main pole beam\n    float poleMain = length(poleLocal.xz) - 0.1;\n    // spheres at joints where poles meet\n    float poleJoint = length(poleLocal) - 0.2;\n    // little cylinder cap where pole meets joint\n    float poleCon = max(poleMain, poleJoint) - 0.1;\n    // resulting pole assembly\n    float pole = min(poleCon, min(poleMain, poleJoint));\n    \n    float sphere = length(sphereLocal) - 1.0; // radius\n    float plane = planeLocal.y;\n    \n    vec3 lightLocal = where - light1.position;\n    float light = length(lightLocal)-0.5;\n    float lightpost = max(lightLocal.y+0.1,length(lightLocal.xz) - 0.1);\n    lightpost = min(lightpost, max(light-0.05, lightpost-0.25));\n    // bands around light globe\n    lightLocal.xz = abs(lightLocal.xz);\n    lightLocal.xz = vec2(max(lightLocal.x,lightLocal.z),min(lightLocal.x,lightLocal.z));\n    lightpost = min(lightpost, length(vec2(length(lightLocal.xy) - 0.5, lightLocal.z))-0.025);\n\n    dist_out = MAX_DIST;\n    int id = 0;\n    if (sphere < dist_out) {\n        localPosition_out = sphereLocal;\n        dist_out = sphere;\n        id = ID_SPHERE;\n    } \n    if (plane < dist_out) {\n        dist_out = plane;\n        localPosition_out = planeLocal;\n\t    id = ID_PLANE;\n    }\n    if (pole < dist_out) {\n        dist_out = pole;\n        localPosition_out = poleLocal;\n\t    id = ID_POLE;\n    }\n    if (light < dist_out && !forShadow) {\n        dist_out = light;\n        localPosition_out = lightLocal;\n\t    id = ID_LIGHT;\n    }\n    if (lightpost < dist_out && !forShadow) {\n        dist_out = lightpost;\n        localPosition_out = lightLocal;\n\t    id = ID_LIGHTPOST;\n    }\n    if (light < dist_out && !forShadow) {\n        dist_out = light;\n        localPosition_out = lightLocal;\n\t    id = ID_LIGHT;\n    }\n    return id;\n}\n\n#define NORMAL_DELTA 0.001\n\nvec3 calculateNormal(vec3 where) {\n    vec3 before, after;\n    vec3 junk;\n    measure(where - X * NORMAL_DELTA, false, before.x, junk);\n    measure(where + X * NORMAL_DELTA, false, after.x, junk);\n    measure(where - Y * NORMAL_DELTA, false, before.y, junk);\n    measure(where + Y * NORMAL_DELTA, false, after.y, junk);\n    measure(where - Z * NORMAL_DELTA, false, before.z, junk);\n    measure(where + Z * NORMAL_DELTA, false, after.z, junk);\n    return normalize(after-before);\n}\n\n/**\n * Checkerboard pigment. Color can either be color1 or color2 depending on where.\n */\nvec3 pigment_checker(vec3 where, vec3 color1, vec3 color2) {\n    where = floor(where);\n    return ((int(where.x) ^ int(where.y) ^ int(where.z)) & 1) > 0 ? color1 : color2;\n}\n\nbool trace(vec3 start, vec3 direction, in float maxDist, in bool forShadow,\n           out int who, \n           out float travel,\n           out float closest,\n           out vec3 finalPos, \n           out vec3 objectLocalPosition) {\n    int step;\n    int target;\n    float dist;\n    who = 0;\n    bool hit = false;\n    \n    travel = 0.0;\n    vec3 where = start;\n    closest = MAX_DIST;\n    \n    for (step = 0; travel < maxDist && step < MAX_STEP; step++) {\n\t\twhere = start + travel * direction;\n\t    float twistFactor = 0.003 * sin(iTime*0.49) * travel;\n\t    mat2 twist = mat2(cos(twistFactor), sin(twistFactor), \n                      -sin(twistFactor), cos(twistFactor));\n        finalPos = vec3(where.xy * twist, where.z);\n        int target = measure(finalPos, forShadow, dist, objectLocalPosition);\n        if (dist < closest) {\n            closest = dist;\n            who = target;\n        }\n        if (dist < EPSILON) {\n            hit = true;\n            break;\n        }\n        travel += dist * STEP_RATIO;\n    }\n    return hit;\n}\n\n/**\n * main shader entry point.\n */\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 screenPos = (fragCoord / iResolution.xy -0.5) * vec2(1, iResolution.y/iResolution.x);\n    vec3 eye = vec3(38.0*sin(iTime*0.1),3.0+1.0*cos(iTime*0.19),16.0*cos(iTime*0.1));\n    vec3 lookAt = vec3(0,1,0);\n    vec3 look = normalize(lookAt - eye);\n    \n    vec3 upSuggested = vec3(0,1,0);\n    vec3 right = cross(upSuggested, look);\n    vec3 up = cross(look, right);\n    mat4 cameraTran = mat4(right.xyz,0, up.xyz,0, look.xyz,0, eye.xyz,1);\n    //vec3 ray = normalize(vec4(screenPos,1,1) * cameraTran).xyz;\n    vec3 ray = normalize(look + screenPos.x*right + screenPos.y*up);\n    float travel = 0.0;\n    vec3 where = eye;\n    int who;\n    vec3 finalPos, objectLocalPosition;\n    float closest;\n\tbool hit = trace(eye, ray, MAX_DIST, false, who, closest, travel, finalPos, objectLocalPosition);\n    // determine pigment\n\tvec3 pigment = vec3(0);\n    vec3 col = BLACK;\n    if (hit) {\n        switch(who) {\n            case ID_SPHERE:\n                pigment = pigment_checker(objectLocalPosition, vec3(0.9,0.1,0.1), vec3(0.9,0.9,0.1));\n                break;\n            case ID_PLANE:\n                pigment = pigment_checker(objectLocalPosition, vec3(0.1,0.1,0.05), vec3(0.9,0.9,0.9));\n                break;\n            case ID_POLE:\n                pigment = vec3(0.1,0.9,0.8);\n                break;\n            case ID_LIGHT:\n                pigment = WHITE;\n                break;\n            case ID_LIGHTPOST:\n                pigment = BLACK;\n                break;\n        }\n        vec3 toLight = light1.position - finalPos;\n        vec3 lightDir = normalize(toLight);\n        // light power follows inverse square law\n        float lightDist = length(toLight);\n        float lightPower = 100.0 / (1.0+pow(lightDist, 2.0));\n        vec3 normal = calculateNormal(finalPos);\n        int shadowSourceId = 0;\n        float lightFar = 0.0;\n        vec3 finalLightPos;\n        vec3 junk;\n\n        // perform trace for shadow\n        hit = trace(finalPos-EPSILON*ray, lightDir, lightDist, true, shadowSourceId, closest, lightFar, finalLightPos, junk);\n        // if our shadow test ray hits something on its way to the \n        // light, other than the light then the light is blocked\n        if (hit && shadowSourceId > 0) {\n            lightPower = 0.0;\n        }\n        float normalDot = dot(normal, lightDir);\n        float diffuse = 0.9 * lightPower * clamp(normalDot, 0.0, 1.0);\n        float ambient = who != ID_LIGHT ? 0.1 : 1.0;\n\n        vec3 reflected = normal * 2.0 * normalDot - lightDir;\n        vec3 toEye = normalize(-ray);\n        float specular = pow(max(0.0, dot(toEye, reflected)), 32.0);\n\n\n        col = pigment * (ambient + diffuse);  // for now\n        col += vec3(specular, specular, specular);\n    }\n    // Output to screen\n    fragColor = vec4(clamp(col,0.0,1.0),1.0);\n}","name":"Image","description":"","type":"image"}]}