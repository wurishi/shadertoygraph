{"ver":"0.1","info":{"id":"McGSDW","date":"1715527274","viewed":71,"name":"Atmospheric Re-entry","username":"GarlicGraphix","description":"Playing around with noise/buffers.","likes":10,"published":1,"flags":32,"usePreview":0,"tags":["fire","space","planet","spaceship"],"hasliked":0,"parentid":"4cdXzj","parentname":"GarlicGraphix Raymarch Template"},"renderpass":[{"inputs":[{"id":"XdfGRn","filepath":"/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","previewfilepath":"/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    //uv.x += random(vec2(iTime))*0.03;\n    \n    vec4 flame = clamp(texture(iChannel1, uv), 0.0, 1.0);\n    vec4 capsule = clamp(texture(iChannel0, uv), 0.0, 1.0);\n    \n    vec4 col = flame + capsule;\n    col = clamp(col, 0.0, 1.0);\n    \n    vec4 stars = vec4(floor(random(uv*0.01+ vec2(iTime*0.0000001, 0.0))+0.002));\n    stars *= vec4(0.9, 0.7, 0.1, 1.0);\n    \n    uv.y -= 0.6*uv.x-0.2;\n    uv.x -= iTime*0.1;\n    \n    vec4 ground = vec4(0.0);\n    if (uv.y<=0.1) {\n        ground = vec4(0.9, 0.6, 0.0, 1.0)*(1.0-uv.y*10.0);\n    }\n    if (length(col) < 1.0001) {\n        col += mix(vec4(1.0), stars, uv.y*4.0);\n        col = mix(col, ground, texture(iChannel3, uv-iTime*0.05).r);\n    }\n    float colourCount = 4.0;\n    col *= colourCount;\n    col = floor(col);\n    col /= colourCount;\n    fragColor = col;\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4sXGRn","filepath":"/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","previewfilepath":"/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\n\n//Object definition\nfloat getDist(vec3 ray, int state) {\n    if (state == OBJ_GROUP_0) {\n        float cone = sdCappedCone(ray, 0.4, 0.6, 0.25);\n        ray.y += 0.2;\n        ray.y*= 1.5;\n        ray.xy *= rot2D(PI);\n        float shield = sdSolidAngle(ray, vec2( sqrt(3.0)/2.0,1.0/2.0), 0.65);\n        return opSmoothUnion(cone, shield, 0.1);\n    } else if (state == OBJ_GROUP_1) {\n        return 1000.0;\n    } else if (state == OBJ_GROUP_2) {\n        return 1000.0;\n    } else if (state == OBJ_GROUP_3) {\n        return 1000.0;\n    } else {\n        return 0.0;\n    }\n}\n\n//From Art of Code\nvec3 getNormal(vec3 p, int state) {\n    vec2 e = vec2(.001, 0);\n    vec3 n = getDist(p, state) - \n        vec3(getDist(p-e.xyy, state), getDist(p-e.yxy, state),getDist(p-e.yyx, state));\n    \n    return normalize(n);\n}\n\n// textures objeccts based on ray\nvec4 textureObj(vec3 ray, int state) {\n    vec3 colXZ;\n    vec3 colXY;\n    vec3 colYZ;\n    if (state == OBJ_GROUP_0) {\n        colXZ = texture(iChannel0, ray.xz * 0.25 + 0.5).rgb;\n        colXY = texture(iChannel0, ray.xy * 0.5 + 0.5).rgb;\n        colYZ = texture(iChannel0, ray.yz * 0.5 + 0.5).rgb;\n    } else if (state == OBJ_GROUP_1) {\n        colXZ = texture(iChannel1, ray.xz * 0.25 + 0.5).rgb;\n        colXY = texture(iChannel1, ray.xy * 0.5 + 0.5).rgb;\n        colYZ = texture(iChannel1, ray.zy * 0.5 + 0.5).rgb;\n    } else if (state == OBJ_GROUP_2) {\n        colXZ = texture(iChannel2, ray.xz * 0.25 + 0.5).rgb;\n        colXY = texture(iChannel2, ray.xy * 0.5 + 0.5).rgb;\n        colYZ = texture(iChannel2, ray.zy * 0.5 + 0.5).rgb;\n    } else {\n        colXZ = texture(iChannel3, ray.xz * 0.25 + 0.5).rgb;\n        colXY = texture(iChannel3, ray.xy * 0.5 + 0.5).rgb;\n        colYZ = texture(iChannel3, ray.zy * 0.5 + 0.5).rgb;\n    }\n    \n    vec3 normal = getNormal(ray, state);\n    float alpha = 1.0;\n    if (normal.g <= 0.0) {\n        alpha = 0.0;\n    }\n    return vec4(colXZ * abs(normal.y) + colXY * abs(normal.z) + colYZ * abs(normal.x), alpha)*(1.0-normal.g);\n    //return abs(getNormal(ray, state));\n}\n//Returns colour of object\nvec4 raymarch(vec3 origin, vec3 ray) {\n    float totDist = 0.0;\n    int iterations = 80;\n    vec4 colour = vec4(1.0);\n    \n    for (int i = 0; i < iterations; i++) {\n        vec3 pos = origin + ray * totDist;\n        float group0 = getDist(pos, OBJ_GROUP_0);\n        float group1 = getDist(pos, OBJ_GROUP_1);\n        float group2 = getDist(pos, OBJ_GROUP_2);\n        float group3 = getDist(pos, OBJ_GROUP_3);\n        float dist = group0;\n        dist = min(dist, group1);\n        dist = min(dist, group2);\n        dist = min(dist, group3);\n        \n        totDist += dist;\n        \n        if (dist <= 0.001) {\n            if (dist == group0) {\n                colour = textureObj(pos, OBJ_GROUP_0);\n            } else if (dist == group1) {\n                colour = textureObj(pos, OBJ_GROUP_1);\n            } else if (dist == group2) {\n                colour = textureObj(pos, OBJ_GROUP_2);\n            } else {\n                colour = textureObj(pos, OBJ_GROUP_3);\n            }\n            \n            break;\n        } else if (dist >= 100.0 || i == 79) {\n            iterations = i;\n            colour = vec4(vec3(0.0), 1.0);\n            break;\n        }\n    }\n    \n    vec3 finalRay = origin + ray * totDist;\n    return clamp(colour, 0.0, 1.0);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // uv made for raymarching\n    vec2 uv = (fragCoord *2. - iResolution.xy) / iResolution.y;\n    \n    // Camera Definition\n    vec3 origin = vec3(0.0, 0.0, 0.0);\n    vec3 ray = normalize(vec3(uv*0.2, 1.0));\n    \n    // Camera Rotation\n    \n    float randTime = 0.0;\n    \n    float zTrans = -7.5+sin(iTime) + random(vec2(randTime))*0.05;\n    origin.z += zTrans;\n    \n    float xTrans = 0.5 + random(vec2(randTime))*0.05;\n    origin.x += xTrans;\n    \n    float xyRot = PI/4.0 + random(vec2(randTime))*0.05;\n    origin.xy *= rot2D(xyRot);\n    ray.xy *= rot2D(xyRot);\n    \n    float zyRot = random(vec2(randTime))*0.05;;\n    origin.zy *= rot2D(zyRot);\n    ray.zy *= rot2D(zyRot);\n    \n    float xzRot = iTime;\n    origin.xz *= rot2D(xzRot);\n    ray.xz *= rot2D(xzRot);\n\n    // Time varying pixel color\n    vec4 col = raymarch(origin, ray);\n\n    // Output to screen\n    fragColor = col;\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define PI 3.14159\n#define OBJ_GROUP_0 0\n#define OBJ_GROUP_1 1\n#define OBJ_GROUP_2 2\n#define OBJ_GROUP_3 3\nfloat random (in vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))\n                 * 43758.5453123);\n}\nmat2 rot2D(float angle) {\n    float c = cos(angle);\n    float s = sin(angle);\n    \n    return mat2(c, -s, s, c);\n}\n\nvec3 proj(vec3 u, vec3 v) {\n    return v*(dot(u, v)/ dot(v, v));\n}\n\n//Signed distance & smooth union from Inigo Quilez\n//License : MIT\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat dot2( in vec3 v ) { return dot(v,v); }\n\nfloat sdSphere( vec3 ray, float size ) {\n  return length(ray)-size;\n}\n\nfloat sdBox( vec3 ray, vec3 dimensions ) {\n  vec3 q = abs(ray) - dimensions;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdPlane( vec3 ray, vec3 normal, float height ) {\n  normal = normalize(normal);\n  return dot(ray,normal) + height;\n}\n\nfloat sdCappedCone( vec3 p, float h, float r1, float r2 )\n{\n  vec2 q = vec2( length(p.xz), p.y );\n  vec2 k1 = vec2(r2,h);\n  vec2 k2 = vec2(r2-r1,2.0*h);\n  vec2 ca = vec2(q.x-min(q.x,(q.y<0.0)?r1:r2), abs(q.y)-h);\n  vec2 cb = q - k1 + k2*clamp( dot(k1-q,k2)/dot2(k2), 0.0, 1.0 );\n  float s = (cb.x<0.0 && ca.y<0.0) ? -1.0 : 1.0;\n  return s*sqrt( min(dot2(ca),dot2(cb)) );\n}\n\nfloat sdSolidAngle( vec3 p, vec2 c, float ra )\n{\n  // c is the sin/cos of the angle\n  vec2 q = vec2( length(p.xz), p.y );\n  float l = length(q) - ra;\n  float m = length(q - c*clamp(dot(q,c),0.0,ra) );\n  return max(l,m*sign(c.y*q.x-c.x*q.y));\n}\n\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"XdfGRn","filepath":"/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","previewfilepath":"/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec4 capsuleCol = texture(iChannel0, uv);\n    vec3 noise = vec3(\n        random(uv + vec2(iTime, 0.0)),\n        random(uv + vec2(0.0, iTime)),\n        random(uv + vec2(iTime, iTime))\n    );\n    vec3 targetCol;\n    if (capsuleCol.a <= 0.4) {\n        targetCol = vec3(0.9, 0.7, 0.2);\n    } else {\n        targetCol = vec3(100.0);\n    }\n    \n    vec4 col;\n    vec4 variation = vec4(0.0);\n    \n    if (length(targetCol-noise) < 0.4) {\n        col = vec4(noise*targetCol, 0.0);\n    } else {\n        col = texture(iChannel1, uv*0.98)-0.001;\n        col.a = 1.0;\n    }\n    col = clamp(col, 0.0, 1.0);\n    \n    if (length(col) >= 0.4) {\n        variation = 0.001*texture(iChannel2, uv - vec2(iTime, iTime));\n    }\n    \n    fragColor = col + variation;\n}","name":"Buffer B","description":"","type":"buffer"}]}