{"ver":"0.1","info":{"id":"Nlc3z7","date":"1635859022","viewed":98,"name":"Angular Lighting","username":"spalmer","description":"uh, I just discovered a way to get a normal from the thing, and, combined with a better combine operator, we can get some really cheap \"lit\" shaded rendering without any ray marching or equation root solving.","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["lighting","shading","normal","perspective"],"hasliked":0,"parentid":"sdGXzK","parentname":"Angular Distance"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// fork of Angular Distance http://shadertoy.com/view/sdGXzK\n\n// hey I figured out how to get a sort of gradient,\n// perhaps I can do lighting after all?  sweet!\n\n// still no actual marching or root solving!!!\n\nvoid mainImage(out vec4 o, vec2 p)\n{\n    vec2 r = iResolution.xy;\n    vec3 d = normalize(vec3(p - .5*r, r.y));\n    float n = 5., h = 9e9, k = h, nearest = 9e9, edge = 9e9\n    , radius = 1.2; //, z = .5\n    for (float i = 1.; i > 0.; i -= 1./n) {\n        vec3 a = vec3(0,0,9) + vec3(3.*sin(vec3(0,11,7) + .3*iTime + vec3(3,4,5) * .1*iTime + 6.*i)); // animate dot pos relative eye\n       #if 1\n        float e = dot(d, a);\n        float vv = dot(a, a) - e * e;\n       #else\n        vec3 v = cross(d, a);\n        float vv = dot(v, v);\n       #endif\n        // need sqrt    :(      TODO move this outside the loop\n        float ve = sqrt(vv) - radius;\n        float aa = dot(a, a); // d^2 to point\n        // HACK inefficiently computed per-pixel sorting\n        aa = pow(sqrt(aa) - radius * sqrt(1. - pow(sqrt(vv)/radius, 2.)), 2.);\n        //h = min(h, vv); // minimum is not the best operator to use to combine them!\n        // poof out a bit so auto derivative has something to work with, barely helps  :(\n        if (ve <= 0.) //2./r.y) // only consider if ray hits disc\n        //if (edge >= ve) // keep most inside edge perspective-wise\n        //if (h >= vv) // keep nearest to ray!\n        edge = min(edge, ve);\n        if (aa < nearest)  // keep nearest to camera!\n        {\n            // but if it's not completely covering pixel, keep some bg\n            h = vv; nearest = aa;\n        }\n        //else\n        //{\n            // behind, but if the foreground edge is low coverage,\n            // should be able to see this through the blur, so blend behind            \n        //}\n        // while this sort of works, I suspect need to \n        // blend by edge distance here instead.\n        // For now I'm just going to stop here,\n        // since I've made some progress, and\n        // shrink the edge antialiasing so it's not so noticeable.\n        // TODO I still need to go back and nail the AA down 100% pixel perfect!\n    }\n    // since it's just radial distances, it's not very good for lighting!\n    // can maybe fake some rounded appearance by reshaping the distances near 0.\n    // turns out, I can!\n    // or by use of auto derivatives in clever way.  That works too!\n    // HACK normal! surely not 100% correct...  but holds up fairly well\n    // the flickeries in the normal at the edge are due to the\n    // cutoff threshold in the loop, no info outside the disc for\n    // the derivative computation to work with... will fix TODO\n    vec3 N = vec3(dFdx(h), dFdy(h), 0.) * .5 \n        / (radius) // sqrt ? nah\n        * r.y * inversesqrt(nearest);\n    N.z = sqrt(max(0., 1. - dot(N.xy, N.xy)));\n    // pretty sure it's oriented wrong, like z here is negated...\n    // but my light is also wrong!  ;)\n    // I suspect that I could obtain some of this info from the components\n    // of the original cross product with camera ray...\n    // I bet if I mess with this just a bit more, \n    // I can straighten out the math to something\n    // based on sqrt(1. - s*s) sine-to-cosine\n    // after correcting for perspective and accounting for radius\n    // but so far I just threw something together and got lucky\n    // once I do... I can also get a sort of radial distance estimate\n    // which I can use for bumping the height of the discs out\n    // so they sort better with each other, instead of popping \n    // the nearest disc to the front.\n    h = sqrt(h); // sqrt outside loop doesn't pay off here, since we had to do one in the loop anyway - wah!\n    // FIXME this \"inverted mask\" is way too complicated\n    // combined w gamma from original toy... <sigh> extra sqrt for no reason\n    //o = vec4(pow(max(0., (sqrt(h) - radius) * .15 * r.y + 1.), .45)); // sharp antialiased edge looks better blended, doesn't exhibit overlapping problems\n    //o = 1.-o; // now a mask so I can test some quick derivative lighting\n    // hey didn't I just track the actual edge in the loop?  DUH\n    o = vec4(clamp(-edge * r.y / 4., 0., 1.));\n    N = normalize(N);\n    vec3 L = normalize(vec3(.6,.5,.7));\n    float nl = max(.04, dot(N,L));\n    o *= mix(1., nl, cos(.1*iTime)*cos(.1*iTime)); // show lighting\n    o.rgb *= mix(vec3(1), N * .5 + .5, cos(.2*iTime)*cos(.2*iTime)); // show normals\n    o = pow(o, vec4(1./2.2));\n}\n // FIXME the antialiasing is actually wrong/imprecise, \n // isn't based on pixels but angles?\n // in a way, that's sort of cool, since I\n // think it can be used to get some free\n // depth-of-field defocus effects","name":"Image","description":"","type":"image"}]}