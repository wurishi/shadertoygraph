{"ver":"0.1","info":{"id":"ftyyDw","date":"1661529970","viewed":65,"name":"moebius non-euclidean patch","username":"sasha_sortai","description":"testing the addition of a non-euclidean patch near the origin, studying its optical properties.\nsee comments for more detail.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["raytracing","raymarching","noneuclidean"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n#define STEPS 50\n\nstruct state{\n    vec3 position;\n    vec3 direction;\n};\n\nstate addd(state, float);\nbool crosses_anomaly(vec3, vec3);\nstate redirect(state);\nfloat SDE(vec3);\nvec3 gradSDE(vec3);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 sc = (fragCoord-iResolution.xy*0.5)*2.0/min(iResolution.x,iResolution.y);\n    \n    vec3 col = vec3(sc,0);\n    \n    vec3 cam = vec3(-3,sin(iTime*0.2)*1.2,cos(iTime*0.2)*2.0);\n    vec3 fo = normalize(vec3(10,0,0)-cam);\n    vec3 ri = normalize(cross(fo,vec3(0,0,1)));\n    vec3 up = cross(ri,fo);\n    \n    state st; st.position = cam; st.direction = normalize(fo+ri*sc.x+up*sc.y);\n    \n    float d;\n    int i;\n    for (i = 0; i<STEPS; i++) {\n        d = SDE(st.position);\n        if (d<=0.001) break;\n        st = addd(st,d);\n    }\n    if (i==STEPS) col = vec3(0);\n    else col = gradSDE(st.position)*0.5+vec3(0.5);\n    \n    fragColor = vec4(col,1.0);\n}\n\nstate addd(state p, float d) {\n    vec3 npos = p.position + p.direction*d;\n    if (crosses_anomaly(p.position, npos)) return redirect(p);\n    p.position = npos;\n    return p;\n}\n\nbool crosses_anomaly(vec3 p, vec3 q) {\n    if (dot(q.xy,q.xy)<1.0 && abs(q.z)<1.0) return true;\n    if (dot(p.xy,q.xy)>0.0) return false;\n    vec3 dif = q-p;\n    if (dif==vec3(0)) return false;\n    vec2 ortho = p.xy - dif.xy*dot(dif.xy,p.xy)/dot(dif.xy,dif.xy);\n    if (dot(ortho,ortho)<1.0) {\n        if (dif.z==0.0) return abs(p.z)<1.0;\n        if (dif.z>0.0) {\n            dif.z *= -1.0;\n              p.z *= -1.0;\n        }\n        if (p.z<=-1.0) return false;\n        if (p.z>=1.0) {\n            vec2 intp = p.xy - dif.xy*(p.z-1.0)/dif.z;\n            if (dot(intp,intp)<1.0) return true;\n            if (dot(intp,p.xy)<1.0) return false;\n        }\n        vec2 intm = p.xy - dif.xy*(p.z+1.0)/dif.z;\n        return dot(intm,intm)<1.0 || dot(intm,p.xy)<1.0;\n    }\n    return false;\n}\n\nstate redirect(state p) {\n    vec3 pos = p.position;\n    vec3 dir = p.direction;\n    state res;\n    if (pos.z>=1.0 && dir.z<0.0) {\n        vec2 intp = pos.xy - dir.xy*(pos.z-1.0)/dir.z;\n        if (dot(intp,intp)<1.0) {\n            res.position = vec3(intp,-1);\n            res.direction = dir;\n            return res;\n        }\n    } if (pos.z<=-1.0 && dir.z>0.0) {\n        vec2 intm = pos.xy - dir.xy*(pos.z+1.0)/dir.z;\n        if (dot(intm,intm)<1.0) {\n            res.position = vec3(intm,1);\n            res.direction = dir;\n            return res;\n        }\n    }\n    vec3 ort2 = pos - dir*dot(dir.xy,pos.xy)/dot(dir.xy,dir.xy);\n    vec3 hit = ort2 - dir*sqrt(1.0-dot(ort2.xy,ort2.xy))/length(dir.xy);\n    vec3 moedir = vec3(dot(hit.xy,dir.xy),dot(vec2(-hit.y,hit.x),dir.xy),dir.z);\n    float th = moedir.y/moedir.x;\n    float dh = sqrt(th*th+1.0)*moedir.z;\n    res.position = vec3(-cos(th)*hit.xy-sin(th)*vec2(-hit.y,hit.x),mod(hit.z+dh+1.0,2.0)-1.0);\n    res.direction = vec3(-moedir.x*res.position.xy+moedir.y*vec2(-res.position.y,res.position.x),dir.z);\n    return res;\n}\n\nfloat SDE(vec3 p) {\n    float sph = distance(p,vec3(10,0,0))-4.0;\n    float tor;\n    {\n        vec3 q = vec3(p.xy,abs(p.z)-1.0);\n        vec3 qp = vec3(normalize(q.xy),0);\n        tor = distance(q,qp)-0.025;\n    }\n    return min(sph,tor);\n}\n\nvec3 gradSDE(vec3 p) {\n    vec3 del = vec3(0.0005,0,0);\n    return normalize(vec3(\n        SDE(p+del.xyz)-SDE(p-del.xyz),\n        SDE(p+del.zxy)-SDE(p-del.zxy),\n        SDE(p+del.yzx)-SDE(p-del.yzx)\n    ));\n}","name":"Image","description":"","type":"image"}]}