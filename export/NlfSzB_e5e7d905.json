{"ver":"0.1","info":{"id":"NlfSzB","date":"1625917048","viewed":131,"name":"Fork Fractal lines of symmetry","username":"CryHam","description":"Showing no lines of symmetry on a simple fractal.\nWith mouse input:\n- Click mouse for a different fractal start location.\n- Left-right goes back/forward in time.\n- Up is more iterations, down less.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["2d","fractal","trippy"],"hasliked":0,"parentid":"Md2GRc","parentname":"Fractal lines of symmetry"},"renderpass":[{"inputs":[],"outputs":[],"code":"// CryHam Fork of: Fractal lines of symmetry https://www.shadertoy.com/view/Md2GRc\n// No lines and mouse input\n\nvec3 hsv(in float h, in float s, in float v)\n{\n\treturn mix(vec3(1.0), clamp((abs(fract(h + vec3(3, 2, 1) / 3.0) * 6.0 - 3.0) - 1.0), 0.0 , 1.0), s) * v;\n}\n\nvec3 formula(in vec2 p, in vec2 c)\n{\n\tfloat n   = (iMouse.x == 0.f) ? 2.4f : 1.5f + (3.f * iMouse.x / iResolution.x);\n\tint iters = (iMouse.y == 0.f) ? 20  : 5 + int(32.f * iMouse.y / iResolution.y);\n\n\tfloat time = iTime * 0.04;  // color change speed\n\tvec3 col = vec3(0);\n\tfloat t = 1.0;\n\tfloat dpp = dot(p, p);\n\tfloat lp = sqrt(dpp);\n\tfloat r = smoothstep(0.0, 0.2, lp);\n\t\n\tfor (int i = 0; i < iters; i++)\n    {\n\t\t// The transformation\n\t\tp = abs(mod(p/dpp + c, n) - n/2.0);\n\t\t\n\t\tdpp = dot(p, p);\n\t\tlp = sqrt(dpp);\n\n#if 1  // 1 NO LINES, 0 for lines\n\t\t// Get constant width lines with fwidth()\n\t\tfloat nd = fwidth(dpp);\n\t\tfloat md = fwidth(lp);\n\t\tt *= smoothstep(0.0, 0.015, abs((n/2.0-p.x)/nd*n))\n\t\t   * smoothstep(0.0, 0.015, abs((n/2.0-p.y)/nd*n))\n\t\t   * smoothstep(0.0, 0.015, abs(p.x/md))\n\t\t   * smoothstep(0.0, 0.015, abs(p.y/md));\n#else\n\t\t// Shade the lines of symmetry black\n\t\t// Variable width lines\n\t\tt *= smoothstep(0.0, 0.01, abs(n/2.0-p.x)*lp)\n\t\t   * smoothstep(0.0, 0.01, abs(n/2.0-p.y)*lp)\n\t\t   * smoothstep(0.0, 0.01, abs(p.x)*2.0) \n\t\t   * smoothstep(0.0, 0.01, abs(p.y)*2.0);\n#endif\n\n\t\t// Fade out the high density areas, they just look like noise\n\t\tr *= smoothstep(0.0, 0.2, lp);\n\t\t\n\t\t// Add to colour using hsv\n\t\tcol += hsv(1.0 - max(p.x, p.y) + t*2.0 + time, 2.0-lp+t, r);\n\t\t\n\t}\n\treturn (-cos(col/4.0)*0.5 + 0.5)*(t);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = -1.0 + 2.0 * fragCoord.xy / iResolution.xy;\n\tp.x *= iResolution.x / iResolution.y;\n\tp *= 2.0;\n    \n\tconst vec2 e = vec2(0.06545465634, -0.05346356485);\n\tvec2 c = iTime*e * 0.3f;  // speed\n\t//c = 8.0*iMouse.xy/iResolution.xy;\n    \n\tconst float blursamples = 4.0;\n\tfloat sbs = sqrt(blursamples);\n\tfloat mbluramount = 1.0/iResolution.x/length(e)/blursamples*2.0;\n\tfloat aabluramount = 1.0/iResolution.x/sbs*4.0;\n    \n\tvec3 col = vec3(0.0);\n\tfor (float b = 0.0; b < blursamples; b++)\n    {\n\t\tcol += formula(\n\t\t\tp + vec2(mod(b, sbs)*aabluramount, b/sbs*aabluramount), \n\t\t\tc + e*mbluramount*b);\n\t}\n\tcol /= blursamples;\n\tfragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}