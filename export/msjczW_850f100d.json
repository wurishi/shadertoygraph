{"ver":"0.1","info":{"id":"msjczW","date":"1718758561","viewed":65,"name":"smooth mirror function ","username":"gltracy","description":"linearly interpolating f'(x) by x/h within the range (0, h)\nfor better methods, see https://www.shadertoy.com/view/dllGDX\nwhich uses f(g(x)), where g'(x) = 0 at x = 0","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["smooth"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define time iTime\n\n// ---- change scale here ----\nfloat scale = 4.0;\n\nfloat fx(float x) {\n    return x * x * x - x * x * 4.0 + x * 2.0 + 3.0;\n}\n\n// integral of f\nfloat Fx(float x) {\n    return x * x * x * x / 4.0 - x * x * x * 4.0 / 3.0 + x * x + 3.0 * x;\n}\n\n// ---- change function here -----\nfloat function( vec2 v ) {\n    v.x = abs(v.x);   \n    float f = fx(v.x);\n    return v.y - f;\n}\n\nfloat function_smooth( vec2 v, float h ) {\n\n    v.x = abs(v.x);\n    \n    float f = fx(v.x);\n    float F = Fx(v.x);\n    \n    //f * (1 - x/h) - F/(-h) [v.x, h]\n    //f' * (1 - x/h) + f/(-h) - f/(-h)\n    \n    if (v.x < h) {\n        f -= fx(v.x) * (1.0 - v.x / h) + Fx(v.x) / h - Fx(h)/h;\n    }\n    \n    return v.y - f;\n}\n\n\nvec2 grad( vec2 p, float h ) {\n\tvec2 step = vec2( h, 0.0 );\n\t\n\treturn vec2(\n\t\tfunction( p + step.xy ) - function( p - step.xy ),\n\t\tfunction( p + step.yx ) - function( p - step.yx )\n\t) / ( h * 2.0 );\n\t\t\n}\n\nfloat value( float v, float size ) {\n\treturn 1.0 - 1.0 / ( max( abs( v / size ) - 1.0, 0.0 ) + 1.0 );\n}\n\nfloat grid( vec2 p, float width ) {\n\tp += width * 0.5;\n\t\n\tfloat grid_width = 1.0;\n\tfloat k = 1.0;\n\t\n\tk *= step( width * 2.0, abs( p.x ) );\n\tk *= step( width * 2.0, abs( p.y ) );\n\t\n\tgrid_width *= 0.25;\n\tk *= min( step( width, abs( floor( p.x / grid_width + 0.5 ) * grid_width - p.x ) ) + 0.75, 1.0 );\n\tk *= min( step( width, abs( floor( p.y / grid_width + 0.5 ) * grid_width - p.y ) ) + 0.75, 1.0 );\n\n\treturn k;\t\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat width = 1.0 / min( iResolution.x, iResolution.y );\n\tvec2 control = mix( iResolution.xy * 0.5, iMouse.xy, 1.0 - step( iMouse.z, 0.0 ) );\n    control += vec2(0.0, -60.4);\n\tvec2 uv = ( fragCoord.xy - control ) * width * 2.0;\n\t\n\tfragColor = vec4(\n        grid( uv, width ) *\n        value( function(uv * scale), width * scale ) *\n        value( function_smooth(uv * scale, 0.8), width * scale ) *\n        value( function_smooth(uv * scale, 1.2), width * scale ) *\n        value( function_smooth(uv * scale, 1.6), width * scale ) *\n        value( function_smooth(uv * scale, 2.0), width * scale ) *\n        value( function_smooth(uv * scale, 2.4), width * scale ) *\n        value( function_smooth(uv * scale, 3.6), width * scale )\n        );\n}","name":"Image","description":"","type":"image"}]}