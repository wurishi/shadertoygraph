{"ver":"0.1","info":{"id":"MlGcDd","date":"1538142496","viewed":193,"name":"Periodic Grid Based Falloff","username":"Markyparky56","description":"Calculates the value for circular falloff for each grid square, at multiple grid resolutions then \"blends\" by taking the highest value of the set. ","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["periodic","falloff","gridbased"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Converted from: https://codepen.io/sachmata/post/elegant-pairing\n/*function elegantPair(x, y) {\n  return (x >= y) ? (x * x + x + y) : (y * y + x);\n}*/\nfloat elegantPair(vec2 p)\n{\n\treturn (p.x >= p.y) ? (p.x*p.x + p.x + p.y) : (p.y * p.y + p.x);\n}\n\n// Borrowed from: https://stackoverflow.com/questions/4200224/random-noise-functions-for-glsl#4275343\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\n// Stolen from: https://www.shadertoy.com/view/4djSRW\n#define HASHSCALE1 .1031\nfloat hash11(float p)\n{\n\tvec3 p3  = fract(vec3(p) * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord/* - iResolution.xy * 0.5*/)/min(iResolution.x, iResolution.y);\n    //uv = (fragCoord)/iResolution.xy;\n       \n    const vec4 period = vec4(32.0, 16.0, 8.0, 4.0);\n    const vec4 oneOverPeriodSqrd = vec4(1.)/vec4(period*period);\n    vec4 seeds = vec4(42.42, 123.321, 1337.7331, 316.613);\n    \n    vec4 uv01, uv23;\n    uv01 = vec4((uv) * period.x, (uv) * period.y);\n    uv23 = vec4((uv) * period.z, (uv) * period.w);\n      \n    vec4 uv01f = vec4(floor(uv01.xy), floor(uv01.zw));\n    vec4 uv23f = vec4(floor(uv23.xy), floor(uv23.zw));\n    uv01f = vec4(mod(uv01f.xy, period.x), mod(uv01f.zw, period.y));\n    uv23f = vec4(mod(uv23f.xy, period.z), mod(uv23f.zw, period.w));\n    vec4 ids = vec4( elegantPair(uv01f.xy)\n                   , elegantPair(uv01f.zw)\n                   , elegantPair(uv23f.xy)\n                   , elegantPair(uv23f.zw));\n    ids *= oneOverPeriodSqrd;\n    \n    vec4 perm = vec4( rand(vec2(ids.x, -ids.x)+seeds.xy)\n                    , rand(vec2(ids.y, -ids.y)+seeds.zw)\n                    , rand(vec2(ids.z, -ids.z)+seeds.zx)\n                    , rand(vec2(ids.w, -ids.w)+seeds.wy));\n    const vec4 permThreshold = vec4(0.3, 0.25, 0.45, 0.75);\n                     \n    vec4 falloff = vec4( 0.15 - dot(fract(uv01.xy) - 0.5, fract(uv01.xy) - 0.5) // Reduced falloff threshold to 0.15\n                       , 0.20 - dot(fract(uv01.zw) - 0.5, fract(uv01.zw) - 0.5) // Reduced falloff threshold to 0.20\n                       , 0.25 - dot(fract(uv23.xy) - 0.5, fract(uv23.xy) - 0.5)\n                       , 0.25 - dot(fract(uv23.zw) - 0.5, fract(uv23.zw) - 0.5));\n    \n    falloff = vec4( (perm.x < permThreshold.x && perm.y < permThreshold.y && perm.z < permThreshold.z && perm.w < permThreshold.w) ? 4.0*falloff.x : 0.0\n                  , (perm.y < permThreshold.y && perm.z < permThreshold.z && perm.w < permThreshold.w) ? 4.0*falloff.y : 0.0\n                  , (perm.z < permThreshold.z && perm.w < permThreshold.w) ? 4.0*falloff.z : 0.0\n                  , (perm.w < permThreshold.w) ? 4.0*falloff.w : 0.0);\n                   \n    const bool colourise = true;\n    float v;\n    \n    v = max(falloff.x, max(falloff.y, max(falloff.z, falloff.w)));\n        \n    vec3 col = vec3(v, (perm.x+perm.y+perm.z+perm.w) / 8., ids.z); // This is overriden by the colourise step if set to true\n    \n    // Add some interesting colours\n    //if(colourise) col = cos(vec3(col.x*((ids.w+1.)*((period.w+1.))), vec2(uv.yx))+vec3(iTime,-iTime,iTime)); // Some very interesting colours\n    if(colourise) col = vec3(v*hash11(ids.w), v*hash11(ids.w+0.1), v*hash11(ids.w+0.2));    \n    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}