{"ver":"0.1","info":{"id":"XslBzj","date":"1497002994","viewed":119,"name":"Perpetual circles motion","username":"farious","description":"A way to create perpetual 2d circle motion.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["procedural","2d"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/* Old implementation\nfloat circle(vec2 c, float r, vec2 p) {\n    vec2 o = c - p;\n    return 1.0 - step(r*r, o.x*o.x + o.y*o.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // This is for shader toy only\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv.y *= iResolution.y /iResolution.x;\n    \n    // This is what matters\n    float bit = 0.0;\n    float r = 0.1 * 0.5;\n    \n    for(float i = -50. + mod(iTime, r * 100.); i < 50. ; i++) {\n        bit += circle(vec2(r + i*5.0*r, 0.5), r, uv);\n    }\n    bit *= (uv.x > 0.7 ? 0. : 1.);\n    bit = (bit > 0. ? 1.:0.);\n\n    fragColor =  vec4(bit);\n}\n*/\n\n/// FabriceNeyret2 suggested implementation\n//#define circle(c, r, p) 1.-smoothstep(0., 1./iResolution.y, length(c-(p)) - r )\n//#define circle2(c, r, p) smoothstep(1./iResolution.y, 0., length(c-(p)) - r )\n\n\nfloat circle(vec2 c, float r, vec2 p) {\n    return 1. - smoothstep(0., 1./iResolution.y, length(c-(p)) - r );\n}\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n\tfloat pw = 1.0;// abs(sin(iTime * .5));\n\tU /= iResolution.x;\n\n    float r = .05 * .5,   l = 3.*r,\n          t = mod(iTime * 4., iResolution.x) * 0.5,\n          i = floor ( U.x/l + 0.5 - t ) + t, b = 0.;\n    \n    b = circle( vec2( i*l, .5), r, U) * float(U.x < pw) * smoothstep(0., 2.*r, U.x) *(1.-U.x);\n   \tb *= step(r, i*l) * step(r, pw - i*l);\n    O = vec4(b);\n}","name":"Image","description":"","type":"image"}]}