{"ver":"0.1","info":{"id":"Xt2GDG","date":"1432019308","viewed":280,"name":"Doorways","username":"luutifa","description":"I wanted to add bumps and textures, maybe reflections and refine the distfield a bit, but really had to finish this for school.","likes":10,"published":1,"flags":0,"usePreview":0,"tags":["raymarch","lighting"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[],"code":"#ifdef GL_ES\n    precision highp float;\n#endif\n\n#define PI 3.14159265\n#define EPSILON 0.001\n#define ITERATIONS 30\n#define MAX_MARCH_LEN 30.0\n#define NUM_POINTLIGHTS 3\nvec3 cam = vec3(0.0, 1.7+sin(iTime)*0.1, sin(iTime*0.6)*0.2);\nvec3 normal;\nvec4 light_p_coord[NUM_POINTLIGHTS]; //W is bool visibility\nvec3 light_p_color[NUM_POINTLIGHTS];\n\nmat3 getXRotMat(float a) {\n    return mat3(\n         1.0,  0.0,     0.0,\n         0.0,  cos(a), -sin(a),\n         0.0,  sin(a),  cos(a)\n    );\n}\n\nmat3 getYRotMat(float a) {\n    return mat3(\n         cos(a),  0.0,  sin(a),\n         0.0,     1.0,  0.0,\n        -sin(a),  0.0,  cos(a)\n    );\n}\n\nmat3 getZRotMat(float a) {\n    return mat3(\n         cos(a), -sin(a),  0.0,\n         sin(a),  cos(a),  0.0,\n         0.0,     0.0,     1.0\n    );\n}\n\nfloat smin( float a, float b, float k ) {\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat box(vec3 p, vec3 b) {\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat plane(vec3 pos) {\n    return pos.y;\n}\n\nfloat sphere(vec3 pos, float r) {\n    return length(pos)-r;\n}\n\n/*-------------------------------------------------------------------*/\n\nfloat wallWithDoor(vec3 pos) {\n    float doorW = 1.2;\n    float doorH = 2.0;\n    \n    float wall = box(pos, vec3(20.0, 10.0, 0.2));\n    //pos.x = mod(pos.x, 10.0)-5.0;\n    float door = min(\n            box(pos, vec3(doorW, doorH*2.0, 40.0)),\n            sphere(pos-vec3(0.0, doorH*2.0, 0.0), doorW)\n    );\n    float door2 = min(\n            box(pos-vec3(6.0, 0.0, 0.0), vec3(doorW, doorH*2.0, 40.0)),\n            sphere(pos-vec3(6.0, doorH*2.0, 0.0), doorW)\n    );\n    \n    return max(\n        wall,\n        -min(\n            door,\n            door2\n        )\n    );\n}\n\nfloat scene(vec3 pos) {\n    return smin(\n        plane(pos),\n        min(\n            wallWithDoor(pos-vec3(-0.2, 0.0, 6.0)),\n            wallWithDoor(getYRotMat(PI/2.0)*(pos-vec3(3.0, 0.0, 9.0)))\n        ),\n        0.1\n    );\n}\n\n/*---------------------------------------------------------------------------*/\n\nvec3 getGradient(vec3 p) {\n    vec2 e = vec2(EPSILON, 0.0);\n    return (vec3(scene(p+e.xyy), scene(p+e.yxy), scene(p+e.yyx)) - scene(p)) / e.x;\n}\n\nvec3 march(vec3 origin, vec3 direction) {\n    float t=EPSILON;\n    float dist;\n    for (int i=0; i<ITERATIONS; i++) {\n        dist = scene(origin+direction*t);\n        t += dist;\n        if (dist<EPSILON)\n            break;\n        if (t>MAX_MARCH_LEN)\n            break;\n    }\n    return origin + direction*t;\n}\n\nfloat softShadow(vec3 origin, vec3 direction, float mint, float maxt, float k) {\n    float l = 1.0;\n    float t = mint;\n    float dist;\n    for(int i=0;i<ITERATIONS;i++)\n    {\n        dist = scene(origin + direction*t);\n        if(dist<EPSILON)\n            return 0.0; //If hits a surface, fragment is completely shadowed\n        t += dist;\n        l = min(l, k*dist/t);\n        if(t > maxt)\n            break;\n    }\n    return l;\n}\n\nvec3 pointLight(vec3 pos, vec3 lpos, vec3 lcol) {\n    float diff = max(dot(normalize(pos-lpos), -normal), 0.0);\n    float dist = 1.0/(length(pos-lpos));\n    float shadow = softShadow(pos, normalize(lpos-pos), 0.1, length(lpos-pos), 30.0);\n    return dist * diff * lcol * shadow;\n}\n\nvec3 lighting(vec3 pos) {\n    vec3 l = vec3(0.0);\n    for (int i=0; i<NUM_POINTLIGHTS; i++) {\n        vec3 lcoord = light_p_coord[i].xyz;\n        l += pointLight(pos, lcoord, light_p_color[i]);\n        \n        if (light_p_coord[i].w > 0.5) {\n            if (length(pos-cam) > length(lcoord-cam))\n                l += pow(max(dot(normalize(cam-lcoord), -normalize(pos-cam)), 0.0), 2000.0)*light_p_color[i];\n        }\n    }\n    return l;\n    \n}\n\nvec3 getPicture(vec2 screenPos) {\n    vec3 pos = march(cam, getZRotMat(sin(iTime*0.2)*0.04)*getYRotMat(-0.2)*normalize(vec3(screenPos, 1.0)));\n    normal = normalize(getGradient(pos));\n    return lighting(pos);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    light_p_coord[0] = vec4(sin(iTime*0.331)*0.5-2.0, 2.0, 9.0+cos(iTime*0.42), 0.0);\n    light_p_color[0] = vec3(1.0, 0.6, 0.1)*2.8;\n    \n    //This light for fake GI :D\n    light_p_coord[1] = vec4(0.2, sin(iTime*0.64)*0.4+3.0, 3.0, 0.0);\n    light_p_color[1] = normalize(vec3(1.0, 0.7, 0.3))*0.8;\n    \n    light_p_coord[2] = vec4(3.0+sin(iTime*0.4)*3.0, 1.5+sin(iTime*0.6654)*0.3, 6.0+cos(iTime*0.4)*3.0, 1.0);\n    light_p_color[2] = vec3(0.2, 0.9, 0.4)*(sin(iTime*3.0)*0.2+0.8)*(sin(iTime*5.0)*0.3+0.6)*(cos(iTime*0.6)*0.2+1.0);\n\n    fragColor = vec4(getPicture((2.0*fragCoord.xy - iResolution.xy)/iResolution.y)*1.3, 1.0);\n}\n","name":"","description":"","type":"image"}]}