{"ver":"0.1","info":{"id":"Xtfyzr","date":"1503034609","viewed":291,"name":"Simple ray tracer","username":"Lazzux","description":"A very simple ray tracer I created for a game math article. Should work with OpenGL ES 1.0.","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["raytracing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n// Settings\nvec3 cameraPos = vec3(0, 0, 80);\nconst int maxReflections = 5;\nconst float timeScale = 0.125;\n\n// Update this if you remove or add spheres\nconst int sphereCount = 5;\n\n// Supersampling. 1 -> 1 sample per pixel, 2 -> 2x2=4 samples per pixel, 3 -> 3x3=9, and so on\nconst int SS = 3;\n\nconst vec2 subpixelsize = vec2(1.0) / float(SS);\nconst vec2 halfSubpixelSize = 0.5 * subpixelsize;\nconst vec3 numbers = vec3(0.0, 1.0, 2.0);\nconst float invSSMultiplier = 1.0 / float(SS*SS);\n\nvoid sphere(vec3 spherePos, float sphereSize, vec3 rayDirection, vec3 rayOrigin, out float t, out vec3 sphereNormal)\n{\n    // Default values for ray missing the sphere\n    t = -1.0;\n    sphereNormal = vec3(0.0);\n    \n    //float radius2 = sphereSize * sphereSize;\n    vec3 rayToSphere = spherePos - rayOrigin;\n    \n    // Closest point on ray to the sphere center\n    float tca = dot(rayToSphere, rayDirection);\n    \n    // Distance squared from the closest point on ray to the sphere center\n    float d2 = dot(rayToSphere, rayToSphere) - tca * tca; \n    \n    // Ray misses the sphere\n    //if (d2 > radius2) return; \n    if (d2 > sphereSize) return; \n    \n    // Distance from the first intersection point to the closest point on ray to the sphere center\n    //float thc = sqrt(radius2 - d2);\n    float thc = sqrt(sphereSize - d2);\n    \n    // Find the two intersection points of a sphere\n    t = tca - thc; \n    \n    // Check if t is behind the sphere\n    if (t < 0.0) {\n        return;\n    }\n    \n    // Calculate normal of the sphere by calculating a vector from the sphere center to the intersection point on the ray\n    vec3 pointAlongRay = t * rayDirection + rayOrigin;\n    sphereNormal = normalize( pointAlongRay - spherePos );\n}\n\nvoid cast_ray_to_scene(\n    vec3 spheres[sphereCount],\n    vec3 sphereColors[sphereCount],\n    float sphereSizes[sphereCount],\n    vec3 ray,\n    vec3 rayOrigin,\n    out vec3 rayColor)\n{\n    // Default ray color tint (white for the background)\n    rayColor = vec3(1.0);\n    float reflectionAmount = 1.0;\n    \n    // Loop until too many reflections or until we have used up all the usable distance from the ray\n    for(int currentReflection = 0; currentReflection < maxReflections + 1; currentReflection++)\n    {\n        vec3 foundColor = rayColor;\n        vec3 reflectionNormal = -numbers.xxy;\n        float lowestT, t;\n        vec2 uv = numbers.xx;\n        \n        // Use a very high default value\n        lowestT = 999999.9;\n        reflectionAmount = 1.0;\n        \n        // Go through all the spheres\n        for(int i = 0; i < sphereCount; i++)\n        {\n            vec3 sphereNormal;\n            \n            // Calculate t and normal of the sphere\n            sphere(spheres[i], sphereSizes[i], ray, rayOrigin, t, sphereNormal);\n            \n            // If the ray did hit something and it wasn't behind the ray and it was closer than the result before\n            if(t > 0.0 && t < lowestT)\n            {\n                // Set the new closest depth value\n                lowestT = t;\n                \n                // Use the given normal as the normal for the fragment\n                reflectionNormal = sphereNormal;\n                \n                // Use the color of the sphere as current sphere color\n                foundColor = sphereColors[i];\n            }\n        }\n        \n        if(lowestT < 99999.0)\n        {\n            reflectionAmount = max(0.0, reflectionAmount * 0.25 - 0.0001);\n        }\n        \n        // Accumulate the color from the many reflections\n        rayColor = mix(rayColor * foundColor, rayColor, reflectionAmount);\n        \n        //rayColor = rayColor * foundColor;\n        \n        // Check if the ray did not hit anything (which means an end of life for a ray)\n        if(lowestT > 99999.0 || currentReflection == maxReflections)\n        {\n            vec3 texel = texture(iChannel0, ray).rgb;\n            \n            vec3 sharpReflection = pow(texel, vec3(0.7));\n            vec3 specular = vec3(0.0);\n            \n            if(currentReflection > 0)\n            {\n                specular = pow(texel, vec3(4.0)); // Adds bright ambient light on reflective surfaces\n            }\n                        \n            // Calculate surface light\n            rayColor = sharpReflection * rayColor + specular;\n                        \n            break;\n        }\n        \n        // Calculate new ray origin\n        rayOrigin += ray * lowestT;\n                \n        // Get a new ray by reflecting the current one from the hit object\n        ray = reflect(ray, reflectionNormal);\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float scaledTime = iTime * timeScale;\n    \n    // Calculate some values for the rotations and other animation\n    float cosTime = cos(scaledTime);\n    float sinTime = sin(scaledTime);\n    float cosTime2 = cos(scaledTime*0.23);\n    float sinTime2 = sin(scaledTime*0.23);\n    float sinTime3 = sin(scaledTime*1.23);\n    float fastSin = sin(iTime * 2.0);\n    float fastCos = cos(iTime * 3.0);\n    float fastSin2 = sin(iTime * 3.0);\n    \n    // Rotation matrix\n    mat3 rot = mat3(\n    \tvec3(1, 0, 0),\n        vec3(0, cosTime2, -sinTime2),\n        vec3(0, sinTime2, cosTime2)\n    ) * mat3(\n    \tvec3(cosTime, 0, sinTime),\n        vec3(0, 1, 0),\n        vec3(-sinTime, 0, cosTime)\n    ) * mat3(\n    \tvec3(cosTime2, -sinTime2, 0),\n        vec3(sinTime2, cosTime2, 0),\n        vec3(0, 0, 1)\n    );\n    \n    mat3 rot2 = mat3(\n    \tvec3(1, 0, 0),\n        vec3(0, cosTime, -sinTime),\n        vec3(0, sinTime, cosTime)\n    ) * mat3(\n    \tvec3(cosTime, 0, sinTime),\n        vec3(0, 1, 0),\n        vec3(-sinTime, 0, cosTime)\n    ) * mat3(\n    \tvec3(cosTime2, -sinTime2, 0),\n        vec3(sinTime2, cosTime2, 0),\n        vec3(0, 0, 1)\n    );\n        \n    // Define sphere positions\n    vec3 spheres[sphereCount];\n    spheres[0] = vec3(-7.0, -7.0, sinTime);\n    spheres[1] = vec3(7.0, -7.0, sinTime2);\n    spheres[2] = vec3(0, 7.0 * (sinTime3 + 5.0) * 0.25, sinTime3);\n    spheres[3] = vec3(sinTime3, sinTime2, sinTime) * 5.0;\n    spheres[4] = vec3(sinTime2, sinTime, sinTime3) * 7.0;\n    /*spheres[5] = vec3(sinTime, sinTime2, sinTime) * 9.0;\n    spheres[6] = vec3(sinTime2, sinTime3 * 2.0, sinTime2) * 18.0;\n    spheres[7] = vec3(sinTime3, sinTime, sinTime3) * 17.0;\n    spheres[8] = vec3(cosTime * 2.0, cosTime, cosTime) * 7.0;\n    spheres[9] = vec3(cosTime2, cosTime2, cosTime2) * 15.0;\n    spheres[10] = vec3(cosTime2, cosTime2, sinTime * 2.0) * 10.0;\n    spheres[11] = vec3(fastSin, fastCos, fastSin2) * 17.0;*/\n    \n    // Define sphere colors\n    vec3 sphereColors[sphereCount];\n    sphereColors[0] = vec3(1.0, 0.01, 0.01);\n    sphereColors[1] = vec3(0.01, 1.0, 0.01);\n    sphereColors[2] = vec3(0.01, 0.01, 1.0);\n    sphereColors[3] = vec3(1.0, 1.0, 1.0);\n    sphereColors[4] = vec3(0.01, 0.01, 0.01);\n    /*sphereColors[5] = vec3(0.3, 0.8, 0.8);\n    sphereColors[6] = vec3(0.8, 0.3, 0.8);\n    sphereColors[7] = vec3(0.8, 0.8, 0.3);\n    sphereColors[8] = vec3(0.1, 1.0, 0.1);\n    sphereColors[9] = vec3(0.3, 0.3, 1.0);\n    sphereColors[10] = vec3(1.0, 0.1, 0.1);\n    sphereColors[11] = vec3(fastSin, fastCos, fastSin2);*/\n    \n    // Define sphere sizes\n    float sphereSizes[sphereCount];\n    sphereSizes[0] = 2.5;\n    sphereSizes[1] = 4.5;\n    sphereSizes[2] = 1.5;\n    sphereSizes[3] = 5.0;\n    sphereSizes[4] = 1.0;\n    /*sphereSizes[5] = 2.5;\n    sphereSizes[6] = 2.5;\n    sphereSizes[7] = 2.5;\n    sphereSizes[8] = 2.5;\n    sphereSizes[9] = 2.5;\n    sphereSizes[10] = 2.5;\n    sphereSizes[11] = 2.5;*/\n    \n    cameraPos = rot * cameraPos;\n    \n    // Rotate and move spheres\n    for(int i = 0; i < sphereCount; i++)\n    {\n        spheres[i] = rot2 * spheres[i] + cameraPos;\n        sphereSizes[i] *= sphereSizes[i]; // square the sizes for optimizations\n    }\n    \n    vec3 rayColor;\n    vec3 finalColor;\n    \n    vec2 halfRes = iResolution.xy * 0.5;\n    vec2 invRes = 1.0 / iResolution.xy;\n    vec2 aspectRatio = vec2(1.0, iResolution.y / iResolution.x);\n    vec2 invCoord = fragCoord.xy * invRes;\n    vec2 invHalfRes = halfRes * invRes;\n    vec2 uvOrigin = invCoord - invHalfRes;\n        \n    for(int x = 0; x < SS; x++)\n    for(int y = 0; y < SS; y++)\n    {\n        // Basically convert the fragCoord.xy to a better suited value for the ray origin\n        vec2 subPixelOffset = (subpixelsize * vec2(x, y) - halfSubpixelSize) * invRes;\n        vec2 uv = (uvOrigin + subPixelOffset) * aspectRatio;\n\n        // Create the ray direction\n        vec3 ray = rot * normalize(vec3(uv, 1.0));\n\n        // Set the ray origin (based on position on the screen)\n        vec3 rayOrigin = vec3(uv, 0);\n\n        // Cast the ray\n        cast_ray_to_scene(\n            spheres,\n            sphereColors,\n            sphereSizes,\n            ray,\n            rayOrigin,\n            rayColor);\n\n        finalColor += rayColor;\n    }\n    \n    // Output the final color\n    fragColor = vec4(finalColor * invSSMultiplier, 1.0);\n    \n}\n","name":"Image","description":"","type":"image"}]}