{"ver":"0.1","info":{"id":"7dcSRM","date":"1632835554","viewed":507,"name":"Geometric Wave","username":"Flopine","description":"Still exploring repetition trick presenting by Blackle, this time with size variation and translation! It still contains some artefacts, reduced by marching slower","likes":25,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","palette","polar","repetiion"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Code by Flopine\n\n// Thanks to wsmind, leon, XT95, lsdlive, lamogui, \n// Coyhot, Alkama,YX, NuSan, slerpy, wwrighter \n// BigWings, FabriceNeyret and Blackle for teaching me\n\n// Thanks LJ for giving me the spark :3\n\n// Thanks to the Cookie Collective, which build a cozy and safe environment for me \n// and other to sprout :)  \n// https://twitter.com/CookieDemoparty\n\n\n// Still exploring repetition trick presenting by Blackle on Perfect Pistons <3 \n// https://youtu.be/I8fmkLK1OKg\n// https://www.shadertoy.com/view/WtXcWB\n\n\n#define PI acos(-1.)\n#define TAU (2.*PI)\n\n#define rot(a) mat2(cos(a),sin(a),-sin(a),cos(a))\n#define palette(t,c) (vec3(.8)+vec3(.7)*cos(TAU*(c*t+vec3(0.8,0.1,0.2))))\n\n#define dt(sp) fract(iTime*sp)\n\n// iq's website: https://iquilezles.org/articles/distfunctions\nfloat sdVerticalCapsule( vec3 p, float h, float r )\n{\n  p.y -= clamp( p.y, 0.0, h );\n  return length( p ) - r;\n}\n\nvec2 edge (vec2 p)\n{\n    vec2 p2 = abs(p);\n    return (p2.x > p2.y) ? vec2((p.x<0.)?-1.:1., 0.) : vec2(0., (p.y<0.)?-1.:1.);\n}\n\nfloat palt;\nfloat SDF (vec3 p)\n{\n    p.yz *= rot(-atan(1./sqrt(2.)));\n    p.xz *= rot(PI/4.);\n    \n    vec2 center = floor(p.xz)+.5,\n    neighbour = center + edge(p.xz-center);\n    palt = atan(center.y,center.x);\n    \n    float a = palt-(dt(.5)*TAU), \n    radius = length(center),\n    \n    py = sin(length(center)+dt(.25)*TAU)*.5+.5, \n    size = clamp(sin(a+radius)*.5+.5,0.08,0.4),\n\n    me = length(p-vec3(center.x,py,center.y))-size,\n    // has to be the sum of all possible spheres\n    next = sdVerticalCapsule(p-vec3(neighbour.x,0.,neighbour.y),1.,0.4); \n\n    return min(me,next);\n}\n\nvec3 getnorm (vec3 p)\n{\n    vec2 eps = vec2(0.01,0.);\n    return normalize(SDF(p)-vec3(SDF(p-eps.xyy),SDF(p-eps.yxy),SDF(p-eps.yyx)));\n}\n\nfloat AO (float eps, vec3 p, vec3 n)\n{return clamp(SDF(p+eps*n)/eps,0.,1.);}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.*fragCoord-iResolution.xy)/iResolution.y;\n    \n    vec3 ro = vec3(uv*4.,-30.), rd=vec3(0.,0.04,1.),p=ro,\n    col=vec3(0.), l=normalize(vec3(1.,2.,-2.));\n\n    bool hit=false;\n    for(float i=0.;i<100.;i++)\n    {\n        float d = SDF(p);\n        if (d<0.001)\n        {\n            hit=true;break;\n        }\n        p += d*rd;\n    }\n\n    if (hit)\n    {\n        vec3 n = getnorm(p);\n        float light = max(dot(n,l),0.15),\n        ao = AO(0.1,p,n)+AO(0.25,p,n)+AO(0.8,p,n);\n        \n        col = palette(abs(palt)/PI,1.)*light*ao/3.;\n    }\n\n    fragColor = vec4(sqrt(col),1.0);\n}","name":"Image","description":"","type":"image"}]}