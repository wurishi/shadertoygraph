{"ver":"0.1","info":{"id":"ft2BRm","date":"1651939248","viewed":72,"name":"huangyouyou","username":"ryoryo","description":"The hairband of Bella, and its name is huangyouyou!\n","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","sdf","asoul"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define tMin 0.01\n#define tMax 150.\n#define rayMarchTime 256\n#define epsilon 0.01\n#define PI 3.141592653589\n#define kd vec3(1.)\n#define ka vec3(0.1)\n#define ks vec3(0.1)\n\nint getLightNum()\n{\n    int lightNum = 3;\n    return lightNum;\n}\n\nstruct Light{\n    vec3 lightPos;\n    vec3 lightColor;\n    float lightInten;\n};\n\nLight getLight(int lightIndex)\n{\n    Light light1 = Light(vec3(50., 50., 50.), vec3(1., 1., 1.), 4000.);\n    Light light2 = Light(vec3(-50., 50., 0.), vec3(1., 1., 1.), 4000.);\n    Light light3 = Light(vec3(50., 50., -50.), vec3(1., 1., 1.), 4000.);\n\n\n    Light[] lights = Light[](light1, light2, light3);\n\n    return lights[lightIndex];\n}\n\nLight getAmbLight()\n{\n    Light ambLight = Light(vec3(0.), vec3(0.03, 0.018, 0.018), 10.2);\n    return ambLight;\n}\n\nvec2 fixUV(in vec2 c)\n{\n    return 1. * (2. * c - iResolution.xy) / min(iResolution.x, iResolution.y);\n}\n\nmat3 setCamera(vec3 ta, vec3 ro, float cr)\n{\n    vec3 z = normalize(ta - ro);\n    vec3 cp = vec3(sin(cr), cos(cr), 0.);\n    vec3 x = normalize(cross(z, cp));\n    vec3 y = cross(x, z);\n\n    return mat3(x, y, z);\n}\n\nfloat sdfSphere(in vec3 p, in float radius)\n{\n    float d = length(p) - radius;\n\n    return d;\n}\n\nfloat sdfBox(in vec3 p, in vec3 b)\n{\n    vec3 q = abs(p) - b;\n    float d = length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);\n    \n    return d;\n}\n\nfloat sdfPlane(in vec3 p)\n{\n    return p.y;\n}\n\nfloat sdfEllipsoid( in vec3 p, in vec3 r ) \n{\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n\n    return k0*(k0-1.0)/k1;\n}\n\nfloat sdfCappedTorus(in vec3 p, in vec2 sc, in float ra, in float rb)\n{\n    p.x = abs(p.x);\n    float k = (sc.y*p.x>sc.x*p.y) ? dot(p.xy,sc) : length(p.xy);\n    return sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;\n}\n\nfloat sdfLink( vec3 p, float le, float r1, float r2 )\n{\n    vec3 q = vec3( p.x, max(abs(p.y)-le,0.0), p.z );\n    return length(vec2(length(q.xy)-r1,q.z)) - r2;\n}\n\n// http://iquilezles.org/www/articles/smin/smin.htm\nfloat smin( float a, float b, float k )\n{\n    float h = max(k-abs(a-b),0.0);\n    return min(a, b) - h*h*0.25/k;\n}\n\n// http://iquilezles.org/www/articles/smin/smin.htm\nfloat smax( float a, float b, float k )\n{\n    k *= 1.4;\n    float h = max(k-abs(a-b),0.0);\n    return max(a, b) + h*h*h/(6.0*k*k);\n}\n\nvec3 rotZ(vec3 pos, float a) {\n    mat3 mat = mat3(cos(a),-sin(a),0.0,\n                    sin(a),cos(a),0.0,\n                    0.0,0.0,1.0);\n    return pos * mat;\n               \n}\n\nvec3 rotX(vec3 pos, float a) {\n    mat3 mat = mat3(1.0,0.0,0.0,\n                    0.0,cos(a),-sin(a),\n                    0.0,sin(a),cos(a));\n    return pos * mat;\n}\n\nvec3 rotY(vec3 pos, float a) {\n    mat3 mat = mat3(cos(a),0.0,sin(a),\n                    0.0,1.0,0.0,\n                    -sin(a),0.0,cos(a));\n    return pos * mat;\n}\n\nfloat sdfSwing(in vec3 p)\n{\n    float d;\n    vec3 height = vec3(0., -23., 0.);\n    vec3 x = vec3(-0.7, 0., 0.);\n    p = p + height + x;\n    vec3 p0 = p;\n    float middle = sdfLink(p0-vec3(-0.2, 0.41,0.1), 0.58, 0.4, 0.2);\n    middle = smin(middle, sdfLink(p0-vec3(-0.2, 0.41,-0.1), 0.58, 0.4, 0.2), 0.1);\n    middle = smin(middle, sdfLink(p0-vec3(-0.2, 0.41,-0.3), 0.58, 0.4, 0.2), 0.1);\n    middle = smin(middle, sdfLink(p0-vec3(-0.2, 0.41,-0.5), 0.58, 0.4, 0.2), 0.1);\n    middle = smin(middle, sdfLink(p0-vec3(-0.2, 0.41,-0.7), 0.58, 0.4, 0.2), 0.1);\n    \n    vec3 p1 = p - vec3(0., 3., 4.);\n    p1 = rotY(p1, 1.5);\n    p1 = rotZ(p1, 0.9);\n    \n    d = sdfEllipsoid(p1, vec3(2., 5., 3.));\n    d = smax(d, sdfBox(p1, vec3(3., 5., 0.3)), 0.5);\n    d = smax(d, -sdfEllipsoid(p1 - vec3(-2.2,5.9,0.), vec3(2., 5., 3.)), 0.5);\n    d = smin(d, middle, 0.1);\n\n    vec3 p2 = p - vec3(0., 2.5, -5.0);\n    p2 *= vec3(1., 1., -1.);\n    p2 = rotY(p2, 1.5);\n    p2 = rotZ(p2, 1.1);\n    \n    float d1 = sdfEllipsoid(p2, vec3(2., 5., 3.));\n    d1 = smax(d1, sdfBox(p2, vec3(3., 5., 0.3)), 0.5);\n    d1 = smax(d1, -sdfEllipsoid(p2 - vec3(-2.2,5.9,0.), vec3(2., 5., 3.)), 0.5);\n\n    d = smin(d, d1, 0.1);\n\n    return d;\n}\n\n\nfloat sdfHairBand(in vec3 p)\n{\n    float d;\n\n    float angle = PI/2.;\n    vec2 sc = vec2(sin(angle),cos(angle));\n    vec3 scale = vec3(1., 0.9, 1.);\n    float sd = 0.1;\n\n    d = sdfSwing(p-vec3(0.3,0.,0.));\n    \n\n    p = p * vec3(1., 0.9, 1.);\n    p = rotY(p, PI/2.) - vec3(0., 0.0, -0.9);\n    float ra = 20.;\n    float rb = 0.3;\n    float band =   sdfCappedTorus(rotX(p, 0.03)-vec3(0.,0.,0.), sc, ra, rb);\n    band = smin(band, sdfCappedTorus(rotX(p, 0.0225)-vec3(0.,0.,0.1), sc, ra, rb), sd);\n    band = smin(band, sdfCappedTorus(rotX(p, 0.015)-vec3(0.,0.,0.2), sc, ra, rb), sd);\n    band = smin(band, sdfCappedTorus(rotX(p, 0.0075)-vec3(0.,0.,0.3), sc, ra, rb), sd);\n    band = smin(band, sdfCappedTorus(rotX(p, -0.0)-vec3(0.,0.,0.4), sc, ra, rb), sd);\n    band = smin(band, sdfCappedTorus(rotX(p, -0.0075)-vec3(0.,0.,0.5), sc, ra, rb), sd);\n    band = smin(band, sdfCappedTorus(rotX(p, -0.015)-vec3(0.,0.,0.6), sc, ra, rb), sd);\n    band = smin(band, sdfCappedTorus(rotX(p, -0.0225)-vec3(0.,0.,0.7), sc, ra, rb), sd);\n    band = smin(band, sdfCappedTorus(rotX(p, -0.03)-vec3(0.,0.,0.8), sc, ra, rb), sd);\n \n    \n    d = smin(d, band, 0.1);\n    \n    \n    return d;\n}\n\n\n\n\nvec2 map(in vec3 p)\n{\n    float materialID;\n\n    float hairBand = sdfHairBand(p - vec3(0., 2., 0.));\n    float hairSwing = sdfSwing((p - vec3(0., 2., 0.) -vec3(-0.2,11.,0.)) * vec3(2., 2., 2.)) /2.;\n    float box = sdfBox(p-vec3(0., -30., 0.), vec3(30.));\n\n    float d = smin(box, hairSwing, 0.1);\n    \n    d = min(d, hairBand);\n\n    if (d == hairBand)\n    {\n        materialID = 1.;\n    }\n    else if (d == hairSwing)\n    {\n        materialID = 2.;\n    }\n    else if (d == box)\n    {\n        materialID = 3.;\n    }\n    else\n    {\n        materialID = 0.;\n    }\n\n    return vec2(d, materialID);\n}\n\n\n\nvec3 calcNormal(in vec3 p)\n{\n    const vec2 k = vec2(1, -1);\n    return normalize(k.xyy * map( p + k.xyy * epsilon ).x + \n                     k.yyx * map( p + k.yyx * epsilon ).x + \n                     k.yxy * map( p + k.yxy * epsilon ).x + \n                     k.xxx * map( p + k.xxx * epsilon ).x);\n}\n\n\nvec3 getColor(in float materialID, in vec3 ro, in vec3 rd, in float t)\n{\n    vec3 color;\n    vec3 pos = ro + t * rd;\n    if (materialID == 1.) //hairband\n    {\n        color = vec3(218., 81., 73.)/255.;\n        \n    }\n    else if (materialID == 2.) //hairSwing\n    {\n        color = vec3(130., 25., 25.)/255.;\n        \n    }\n    else if (materialID == 3.) //box\n    {\n        vec2 uv = pos.xz;\n\n        return vec3(mod(floor(uv.x/6.) + floor(uv.y/6.), 2.0) < 1.0 ? 1.0 : 0.4);\n    }\n    else //background\n    {\n        color = vec3(0.7);\n    }\n\n    return color;\n}\n\nvec2 rayIntersect(in vec3 ro, in vec3 rd, out vec3 normal)\n{\n    \n    float t = tMin;\n    for (int i = 0; i < rayMarchTime; i++)\n    {\n        vec3 p = ro + t * rd;\n        normal = calcNormal(p);\n        vec2 temp = map(p);\n        float d = abs(temp.x);\n        float materialID = temp.y;\n        if (t >= tMax || d <= epsilon)\n        {\n            return vec2(t, materialID);\n        }\n        t += d;\n    }\n}\n\nvec3 surfaceRendering(in vec3 ro, in vec3 rd, in float t, in vec3 normal, in float materialID)\n{\n    vec3 color = vec3(0.);\n    int lightNum = getLightNum();\n    Light ambLight = getAmbLight();\n    vec3 ambient = ka * ambLight.lightInten * ambLight.lightColor;\n\n    vec3 p = ro + t * rd;\n    for (int i = 0; i < lightNum; i++)\n    {\n        Light light = getLight(i);\n        vec3 v = normalize(-t * rd);\n        vec3 vl = light.lightPos - p;\n        float r2 = pow(length(vl), 2.);\n        vec3 h = normalize(v + vl);\n        vec3 n = normal;\n        vec3 l = normalize(light.lightPos - p);\n        float nh = max(0., dot(n, h));\n\n        vec3 diffuse = kd * light.lightInten / r2 * max(0., dot(n, l)) * light.lightColor;\n        vec3 specular = ks * light.lightInten / r2 * pow(nh, 150.) * light.lightColor;\n\n        color += diffuse + specular;\n    }\n    color += ambient;\n    color *= getColor(materialID, ro, rd, t);\n\n    return color;\n}\n\nvec3 renderer(vec2 uv)\n{\n    vec3 ro = vec3(50. * sin(iTime/5.), 30., 50. * cos(iTime/5.));\n    vec3 ta = vec3(0.);\n    mat3 cam = setCamera(ta, ro, 0.);\n    vec3 rd = normalize(cam * vec3(uv, 1.));\n\n    vec3 color = vec3(0.);\n    vec3 normal;\n    vec2 temp = rayIntersect(ro, rd, normal);\n    float t = temp.x;\n    float materialID = temp.y;\n\n    if(t < tMax)\n    {\n        color = surfaceRendering(ro, rd, t, normal, materialID);\n    }\n    else\n    {\n        color = getColor(0., ro, rd, t);\n    }\n\n    return color;\n\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\n    vec2 uv = fixUV(fragCoord);\n   \tvec3 color = renderer(uv);\n\n    fragColor = vec4(color, 1.);\n\n}","name":"Image","description":"","type":"image"}]}