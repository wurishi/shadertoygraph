{"ver":"0.1","info":{"id":"3lt3D8","date":"1576189829","viewed":151,"name":"Reflection Testing","username":"NivBehar","description":"Reflection","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","reflection"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"# define MaxSteps 1000\n# define time iTime\n# define PI 3.141592654\n# define NumberOfReflections 10\n\nvec3 LightPos = vec3(5., 7., -5.);\nvec2 N22(vec2 p)\n{\n    vec3 a = fract(p.xyx*vec3(123.34, 234.34, 345.65));\n    a += dot(a, a+34.45);\n    return fract(vec2(a.x*a.y, a.y*a.z));\n}\nfloat sdBox(vec3 p, vec3 s) \n{\n  vec3 q = abs(p) - s;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\nfloat sdRoundBox( vec3 p, vec3 s, float r )\n{\n  vec3 q = abs(p) - s;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\nfloat sdTorus(vec3 p, vec2 r)\n{\n    float x = length(p.xz)-r.x;\n    return length(vec2(x, p.y)-r.y);\n}\nfloat HexDist(vec2 p) {\n\tp = abs(p);\n    \n    float c = dot(p, normalize(vec2(1.,1.73)));\n    c = max(c, p.x);\n    \n    return c;\n}\nvec4 HexCoords(vec2 UV) \n{\n    \tvec2 r = vec2(1., 1.73);\n    vec2 h = r*.5;\n    \n    vec2 a = mod(UV, r)-h;\n    vec2 b = mod(UV-h, r)-h;\n    \n    vec2 gv = dot(a, a) < dot(b,b) ? a : b;\n    \n    float x = atan(gv.x, gv.y);\n    float y = .5-HexDist(gv);\n    vec2 id = UV - gv;\n    return vec4(x, y, id.x,id.y);\n}\nvec2 GetSphereUV(vec3 p, float r)\n{\n    vec3 n = normalize(p);\n    float x = atan(n.x, n.z)/(2.*PI) + 0.5;\n    float y = 0.5 + 0.5*n.y;\n    return vec2(x,y);\n}\nfloat sdSphere( vec3 p, float r ) {\n  return length(p)-r;\n}\nfloat sdSphereHex( vec3 p, float r ) {\n\tvec2 sUV = GetSphereUV(p, r);\n    vec4 h = HexCoords(sUV*vec2(6.,3.) + 10.);\n    float sphereDist = length(p)-r;\n    float sphereHex = sphereDist + 0.002*sin(h.y*10.)*cos(h.x*10.);//*sin(time*2.5);\n    return mix(sphereHex, sphereDist, 0.5 + 0.5*sin(time*0.367));\n}\nvec3 RotX (vec3 p, float speed)\n{   \n    float ss = sin(speed), cc = cos(speed);\n    return vec3(p.x, p.y*cc + p.z*-ss,  p.y*ss + p.z*cc);\n}\nvec3 RotY (vec3 p, float speed)\n{   \n    float ss = sin(speed), cc = cos(speed);\n    return vec3(p.x*cc + p.z*ss, p.y, p.x*-ss + p.z*cc);\n}\nvec3 RotZ (vec3 p, float speed)\n{   \n    float ss = sin(speed), cc = cos(speed);\n    return vec3(p.x*cc  + p.y*-ss, p.x*ss + p.y*cc, p.z);\n}\nfloat smin( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); \n}\nvec3 spherePos() {\n    return vec3(0.,1.05 + 0.15*sin(time),0.);\n}\nvec2 GetDist(vec3 p) // return vec2(min Distance, Object ID)\n{\n    //sky (a BIG sphere)\n    vec3 skyPos = vec3(0.,0.,0.);\n    float skyRad = 200.;\n    float skyDist = -sdSphere(p-skyPos, skyRad);\n    float skyID = 0.;\n    \n    vec2 res = vec2(skyDist, skyID);    \n    \n    //ground\n    float groundDist = p.y;\n    float groundID = 1.;\n    \n    // sphere (big HexSphere)\n    float sphereRad = 0.2;\n\tvec3 spherePosNew = p-spherePos();\n    //spherePosNew.x = fract(spherePosNew.x+1.)-0.5;\n    spherePosNew.y = fract(spherePosNew.y+1.)-0.5;\n    float sphereDist = sdSphereHex(spherePosNew, sphereRad);\n    \n    // box\n    vec3 boxSize = vec3(0.5,0.05,0.5);\n    vec3 boxPos = vec3(0.,0.5,0.);\n    //float boxDist = dBox(p - boxPos, boxSize);\n    vec3 boxPosNew = p - boxPos;\n    //boxPosNew.x = fract(boxPosNew.x+1.)-0.5;\n    //boxPosNew.z = fract(boxPosNew.z+1.)-0.5;\n    boxPosNew.y = sin(fract(boxPosNew.y+1.))-0.5;\n    float boxDist = sdRoundBox(boxPosNew, boxSize, 0.015);\n\n    // sphere2 (small sphere)\n    float sphere2Rad = 0.1;\n    vec3 sphere2Pos = vec3(0.4*sin(time),1.1 + 0.4*cos(time*0.3),0.4*cos(time));\n    vec3 sphere2PosNew = p-sphere2Pos;\n    //sphere2PosNew.x = fract(sphere2PosNew.x+1.)-0.5;\n    sphere2PosNew.y = fract(sphere2PosNew.y+1.)-0.5;\n    float sphere2Dist = sdSphere(sphere2PosNew, sphere2Rad);\n    \n    //box + spheres\n    float boxSphereDist = min(boxDist, sphereDist);\n    float boxSphereID = 2.;\n    boxSphereDist = min(boxSphereDist, sphere2Dist);\n    \n    if(groundDist < res.x)\n        res = vec2(groundDist, groundID);\n    if(boxSphereDist < res.x) \n        res = vec2(boxSphereDist, boxSphereID);\n\n    return res;\n}\nvec2 RayMarch(vec3 ro, vec3 rd, int steps) \n{\n    vec2 dS;\n    float dO;\n    vec3 p;  \n    for(int i = 0; i<steps; i++)\n    {\n        p = ro + rd * dO;\n        dS = GetDist(p);\n        if(abs(dS.x) < 0.0001) {break; }\n        dO += dS.x;\n    }     \n    return vec2(dO,dS.y);\n}\nvec3 GetNormal(vec3 p)\n{\n    float d = GetDist(p).x;\n    vec2 e = vec2(.01, 0.);\n \n    vec3 n = d-vec3(GetDist(p-e.xyy).x, \n                        GetDist(p-e.yxy).x, \n                        GetDist(p-e.yyx).x);\n    return normalize(n);\n}\nfloat GetLight(vec3 p, vec3 lightpos, int steps)\n{\n    float lightpower = 1.4;\n    float shadowstrength = 0.6;\n    vec3 l = normalize(lightpos - p);\n    vec3 n = GetNormal(p);\n    float dif = clamp(dot(n, l*lightpower), 0., 1.);\n    float d = (RayMarch(p + n*0.01, l, steps)).x;\n    if(d < length(lightpos-p)) {dif *= shadowstrength;}\n    return dif;\n}\nvec3 groundCol(vec3 p)\n{\n    vec3 col = vec3(1.,1.,1.);\n    p.xz *= 10.;\n    float squares = smoothstep(-0.5, -0.4, sin(p.x)*cos(p.z));\n    return col*squares;\n}\nvec3 skyCol(vec3 p)\n{\n    vec3 col;\n    float x = atan(p.x, p.z);\n    float y = atan(length(p.xz)-1., p.y);\n    float a = cos(y + 92.1);\n    col = vec3(0., 0.8078, 0.8196);\n    col *= vec3(a,a,1.);\n    return col;\n}\nvec3 applyFog( vec3  rgb, float distance) \n{\n    float b = 1.;\n    float fogAmount = 1.0 - exp( -distance*b );\n    vec3  fogColor  = vec3(0.5,0.6,0.7);\n    return mix( rgb, fogColor, fogAmount );\n}\nvec3 applyFog( in vec3  rgb,      // original color of the pixel\n               in float distance, // camera to point distance\n               in vec3  rayOri,   // camera position\n               in vec3  rayDir )  // camera to point vector\n{\n    float b = 0.3;\n    float c = 0.2;\n    float fogAmount = c * exp(-rayOri.y*b) * (1.0-exp( -distance*rayDir.y*b ))/rayDir.y;\n    vec3  fogColor  = vec3(0.7,1.,1.);\n    return mix( rgb, fogColor, fogAmount );\n}\nfloat specularReflection(vec3 p, vec3 rd, vec3 lightPos, float intensity, float shininessVal)\n{\n    vec3 N = GetNormal(p);\n    vec3 L = normalize(lightPos - p);\n    float lambertian = max(dot(L, N), 0.0);\n    float specular = 0.;\n  \tif(lambertian > 0.0) {\n        vec3 R = reflect(-L, N);      // Reflected light vector\n        vec3 V = normalize(-rd); // Vector to viewer\n        // Compute the specular term\n        float specAngle = max(dot(R, V), 0.0);\n        specular = pow(specAngle, shininessVal);\n  \t}\n    return specular * intensity;\n}\nvec3 GetCol(vec3 ro, vec3 rd, vec2 d, vec3 p, int refNum) // refNum for reflection number\n{\n\t//vec3 LightPos = vec3(5., 7., -5.);\n    float dif = GetLight(p, LightPos, MaxSteps);\n    float spRef = specularReflection(p, rd, LightPos, 1., 1000.);\n    vec3 col = vec3(0.,0.,0.);\n    \n    if(d.y == 0.) // sky col\n        col = skyCol(p);\n    \n    if(d.y == 1.) // ground col\n        col = groundCol(p)*dif;\n    \n    int refMarchSteps = MaxSteps;\n    while(refNum > 0)\n    {\n        refMarchSteps /= 2;\n        if(d.y == 2.) // boxSphere col + reflection\n        {\n            vec3 n = GetNormal(p);\n            rd = normalize(reflect(rd,n)); // reflect does: rd - 2.0 * dot(n, rd) * n\n            ro = p + rd*0.001;\n            d = RayMarch(ro, rd, MaxSteps);\n            p = ro + rd*d.x;\n            float reflectDif = GetLight(p, LightPos, refMarchSteps);\n            //float reflectSpRef = specularReflection(p, rd, LightPos, 0.5, 1000.);\n\n            if(d.y == 0.) // sky col\n                col = skyCol(p);\n\n            if(d.y == 1.) // ground col\n                col = groundCol(p)*reflectDif;\n            if(d.y == 2. && refNum == 1) // color for the last reflection\n                col = vec3(0);\n            col = applyFog(col, d.x, ro, rd);\n            //col += vec3(0.2,0.2,0.);\n            col *= vec3(1.9,1.4,1.); // color adjustment\n            col = 0.75*col*dif + 0.25*col;\n            col += spRef;\n        }\n        refNum -= 1;\n        \n    }\n    //col= col*dif;\n    \n    return col;\n}\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n    vec3 col = vec3(0.,0.,0.);\n \n    vec3 lookat = vec3(0.,1.,0.);\n\n    float zoom = 0.5;\n    \n    vec2 mou = 5.*(iMouse.xy-.5*iResolution.xy)/iResolution.y;\n    mou.y += 2.;\n    mou.y = max(0.01, mou.y);\n    vec3 ro = vec3(1.,5.,1.);//vec3(mou,-1.);\n    ro.x += mou.x;\n    ro.y = mou.y;\n    ro.z = mou.y;\n\n    vec3 F = normalize(lookat-ro); // Forward\n    vec3 R = normalize(cross(vec3(0., 1., 0.), F)); //Right\n    vec3 U = cross(F, R); //Up\n\n    vec3 C = ro + F*zoom;\n    vec3 I = C + uv.x*R + uv.y*U;\n    vec3 rd = normalize(I-ro);\n\n    vec2 d = RayMarch(ro,rd, MaxSteps); // d.y = Object ID\n    vec3 p = ro + rd*d.x;\n    \n    col = GetCol(ro,rd,d,p,NumberOfReflections);\n    col = applyFog(col, d.x,ro, rd);\n\n    fragColor = vec4(col,0.1);\n}","name":"Image","description":"","type":"image"}]}