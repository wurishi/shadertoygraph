{"ver":"0.1","info":{"id":"MtXBWr","date":"1511604296","viewed":293,"name":"Equaliser | Bangers","username":"Sedawrath","description":"Good meme","likes":4,"published":1,"flags":64,"usePreview":0,"tags":["equaliser","bangers"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsSXz1","filepath":"https://soundcloud.com/dylan-veprek/too-filthy-melbourne-edition-vol8-old-school-set-2703-4456","previewfilepath":"https://soundcloud.com/dylan-veprek/too-filthy-melbourne-edition-vol8-old-school-set-2703-4456","type":"musicstream","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//\nvec2 CorrectAspectRatio(vec2 vec, vec2 iRes)\n{\n    vec = (( vec / iRes.xy) * 2.0) - 1.0;\n    vec.x *= iRes.x / iRes.y;\n    return vec;\n}\n\n//\nconst float INVERSE_MAX_UINT = 1.0 / 4294967295.0;\n \n// The GPU version of rand()\nfloat rand(uint seed, float range)\n{\n    uint i = (seed ^ 12345391u) * 2654435769u;\n    i ^= (i << 6u) ^ (i >> 26u);\n    i *= 2654435769u;\n    i += (i << 5u) ^ (i >> 12u);\n    return float(range * float(i)) * INVERSE_MAX_UINT;\n}\n \n// Helper function for rand()\nfloat ra(uint seed)\n{\n    return rand(seed++, 2.0) - 1.0;\n}\n\nfloat sdSphereBlur(vec2 uv, vec2 p, float r, float b) {\n    \n    float d = length(uv-p);\n    return smoothstep(r, r - b, d);\n}\n\nvec3 ColouringA(vec2 uv, vec2 p, float iMd, float mixer, float wave)\n{\n    uv = uv-p;\n    \n    uint seed = uint((iTime + iMd) * 10.);\n\tvec3 c = vec3(0);\n    // generate random values -1 to 1\n    vec3 r = vec3(ra(seed++), ra(seed++), ra(seed++));\n    \n    r = (r / .5) * (sin(10./iTime) + 1.0);\n\n    // Warps perspective of colours\n    c.r = r.r * (uv.x + sin(r.r + iTime));\n    c.g = r.g * (uv.y + tan(r.b + iTime));\n    c.b = c.r + r.b / sin(iTime);\n\n    c /= length(c)  * sin(iTime);\n\n    c.r /= mod(c.g, c.r);\n    c.g /= mod(c.b, c.g);\n    c.b /= mod(c.r, c.b);\n    c -= c.r * sin(0.5/r.b);\n    \n    if(mixer==1.0) {\n        r -= (r / .5) * (sin(1./iTime) + 1.0);\n\n        // Warps perspective of colours\n        c.r = r.r / length(sin(iTime)/uv.x) / sin(r.r) * wave;\n        c.g = r.g * length(tan(iTime)/uv.y) / cos(r.g * length(uv*wave)) * wave;\n\n        c = cos(-0.5/r);\n        c *= 0.001;\n    }\n    return c;\n}\n\nfloat GenerateBalls(vec2 uv, float mixer, float wave)\n{\n    float m = 0.0;\n    float maxS = 20.0 - (10.0 * mixer);\n    for(float i = 0.0; i < maxS; i+=1.0) {\n\t\t\n        float ang = (i/maxS) * (2. * 3.14) + mixer * (.1 * (tan(length(uv) / pow(iTime, wave))));\n        ang += sin(iTime);\n        float z =  1.5 * wave + (mixer * 1.0);\n        float cen = (i-(maxS/2.)) * 0.1;\n\n        float x = z * sin(ang);\n        float y = z * cos(ang);\n        vec2 p = vec2(x,y);\n        m += sdSphereBlur(uv, p, 0.12 + mixer * z/1.0, 0.1 + (mixer * 0.01));\n    }\n    \n    return m;\n}\n \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // UV definition\n    float m = 0.0;\n    vec3 c = vec3(0.0);\n    \n    //\n\tvec2 uv = CorrectAspectRatio(fragCoord.xy, \tiResolution.xy);\n    vec2 cP = vec2(iResolution.x,iResolution.y)/2. + vec2(sin(iTime), cos(iTime));\n    vec2 iM = CorrectAspectRatio(cP, iResolution.xy);\n    float iMDelta = length(iM.xy - uv.xy);\n    \n    vec2 p = vec2(0.0);\n    \n    int tx = int(uv.x/512.0);\n    float freq = texelFetch( iChannel0, ivec2(tx,1), 0 ).x;\n    float wave = texelFetch( iChannel0, ivec2(tx,0), 0 ).x;\n    float mixer = ((freq > 0.39) && (wave > 0.8)) ? 1.0 : 0.0;\n    \n    //wave = mix(wave, pow(wave, exp(wave)), mixer);\n    \n    \n    c = ColouringA(uv, p, iMDelta, mixer, wave);\n    m = GenerateBalls(uv, mixer, wave);\n    \n    for(float i = 0.; i < 10.; i+= 1.0)\n   \t\tm += GenerateBalls(uv * (i * .75), mixer, wave);\n    \n    m = m - 1.0;// - (wave + mixer) * 1.;\n    //m += 1.0;\n    c = (c*m) + 1.0;\n    \n    \n\tfragColor = vec4(c,1.0);\n}","name":"Image","description":"","type":"image"}]}