{"ver":"0.1","info":{"id":"DlVBDD","date":"1702082911","viewed":15,"name":"Fork UCSD CSE 1 zhxie 905","username":"zhxie","description":"This is a homework template for a homework for UCSD CSE 167.","likes":0,"published":1,"flags":32,"usePreview":0,"tags":["boids"],"hasliked":0,"parentid":"ddtyDs","parentname":"UCSD CSE 167 Boids template"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Smooth HSV2RGB from https://www.shadertoy.com/view/MsS3Wc\nvec3 hsv2rgb(in vec3 c)\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n\trgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec4 color = vec4(0.5, 0.5, 0.5, 1.0);\n    // Loop over all boids\n    vec4 bcolor = vec4(0.0, 0.0, 0.0, 1.0);\n    bool hit = false;\n    for (int i = 0; i < NUM_BOIDS; i++) {\n        ivec2 tex_pos = ivec2(i % int(iChannelResolution[0].x),\n                                                i / int(iChannelResolution[0].x));\n        vec4 pos_vel = texelFetch(iChannel0, tex_pos, 0);\n        if (distance(fragCoord, pos_vel.xy) < BOIDS_SIZE) {\n            vec3 rgb = hsv2rgb(vec3((float(i)+0.5) / float(NUM_BOIDS), 1.0, 0.9));\n            bcolor += vec4(rgb, 1.0);\n            hit = true;\n        }\n    }\n    if (hit) {\n        color = bcolor;\n    }\n\n    // Output to screen\n    fragColor = color;\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":1,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    if (iFrame == 0) {\n        // initialize the buffer\n        vec4 pos_vel = texture(iChannel1, fragCoord/iChannelResolution[1].xy);\n        pos_vel.xy = iResolution.xy / 2.0 + (pos_vel.xy - 0.5) * iResolution.xy * 0.2;\n        pos_vel.zw = (pos_vel.zw - 0.5) * iResolution.xy * 1.0;\n        fragColor = pos_vel;\n        return;\n    }\n    ivec2 iFragCoord = ivec2(fragCoord);\n    // \n    vec4 pos_vel = texelFetch(iChannel0, iFragCoord, 0);\n    vec2 pos = pos_vel.xy;\n    vec2 vel = pos_vel.zw;\n    \n    // ID of the current Boid\n    int my_id = int(iFragCoord.y) * int(iResolution.x) + int(iFragCoord.x);\n\n    // Implement Boids here\n    float D_RIGHT = iResolution.x - D_LEFT;\n    float D_BOTTOM = iResolution.y - D_TOP;\n    int a = 0;\n    \n    //----------------------------F_s-------------------------------------------\n    \n    float Ns_count = 0.0;\n    vec2 F_s_sum;\n    F_s_sum.x = 0.0;\n    F_s_sum.y = 0.0;\n    for (int i = 0; i < NUM_BOIDS; i++) {\n        ivec2 tex_pos_tmp = ivec2(i % int(iChannelResolution[0].x),\n                                                i / int(iChannelResolution[0].x));\n        vec4 pos_vel_tmp = texelFetch(iChannel0, tex_pos_tmp, 0);\n        vec2 pos_tmp = pos_vel_tmp.xy;\n        vec2 vel_tmp = pos_vel_tmp.zw;\n        if (pos_tmp == pos) {\n            continue;\n        }\n        \n        if (distance(pos, pos_tmp) < D_S) {\n            Ns_count += 1.0;\n            //F_s_sum.x += pos.x - pos_tmp.x;\n            //F_s_sum.y += pos.y - pos_tmp.y;\n            F_s_sum += pos - pos_tmp;\n        }\n    }\n    \n    vec2 F_s;\n    if (Ns_count == 0.0) {\n        F_s.x = 0.0;\n        F_s.y = 0.0;\n    }\n    else {\n        F_s.x = F_s_sum.x / Ns_count;\n        F_s.y = F_s_sum.y / Ns_count;\n    }\n    \n    \n    //----------------------------F_c&F_a------------------------------------------\n    \n    float Nv_count = 0.0;\n    vec2 pos_sum;\n    pos_sum.x = 0.0;\n    pos_sum.y = 0.0;\n    vec2 vel_sum;\n    vel_sum.x = 0.0;\n    vel_sum.y = 0.0;\n    for (int i = 0; i < NUM_BOIDS; i++) {\n        ivec2 tex_pos_tmp = ivec2(i % int(iChannelResolution[0].x),\n                                                i / int(iChannelResolution[0].x));\n        vec4 pos_vel_tmp = texelFetch(iChannel0, tex_pos_tmp, 0);\n        vec2 pos_tmp = pos_vel_tmp.xy;\n        vec2 vel_tmp = pos_vel_tmp.zw;\n        if (pos_tmp == pos) {\n            continue;\n        }\n        \n        if (distance(pos, pos_tmp) < D_V) {\n            Nv_count += 1.0;\n            pos_sum += pos_tmp;\n            vel_sum += vel_tmp;\n        }\n    }\n    \n    vec2 p_avg;\n    vec2 v_avg;\n    if (Nv_count == 0.0) {\n        p_avg.x = 0.0;\n        p_avg.y = 0.0;\n        v_avg.x = 0.0;\n        v_avg.y = 0.0;\n    }\n    else {\n        p_avg.x = pos_sum.x / Nv_count;\n        p_avg.y = pos_sum.y / Nv_count;\n        v_avg.x = vel_sum.x / Nv_count;\n        v_avg.y = vel_sum.y / Nv_count;\n    }\n    \n    vec2 F_c;\n    F_c = p_avg - pos;\n    \n    vec2 F_a;\n    F_a = v_avg - vel;\n    \n\n    //----------------------------F_b------------------------------------------\n    \n    float x1, x2, y1, y2;\n    x1 = pos.x < D_LEFT ? 1.0 : 0.0;\n    x2 = pos.x > D_RIGHT ? 1.0 : 0.0;\n    y1 = pos.y < D_TOP ? 1.0 : 0.0;\n    y2 = pos.y > D_BOTTOM ? 1.0 : 0.0;\n    \n    vec2 F_b;\n    F_b.x = x1 - x2;\n    F_b.y = y1 - y2;\n    \n    //----------------------------F------------------------------------------\n    vec2 F;\n    F = ALPHA_S * F_s + ALPHA_C * F_c + ALPHA_A * F_a + ALPHA_B * F_b;\n    //F = ALPHA_S * F_s + ALPHA_C * F_c + ALPHA_A * F_a;\n    \n    vel += F;\n    if (length(vel) > 0.0) {\n        if (length(vel) > S_MAX) {\n            vel = vel * (S_MAX / length(vel));\n        }\n        if (length(vel) < S_MIN) {\n            vel = vel * (S_MIN / length(vel));\n        }\n    }\n    \n    pos += vel * 1.0;\n    \n    fragColor = vec4(pos, vel);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define NUM_BOIDS 200\n#define BOIDS_SIZE 10.0\n#define S_MAX 10.0\n#define S_MIN 5.0\n#define D_S 30.0\n#define ALPHA_S 0.02\n#define D_V 150.0\n#define ALPHA_A 0.03\n#define ALPHA_C 0.001\n#define D_LEFT 200.0\n#define D_TOP 160.0\n#define ALPHA_B 0.5","name":"Common","description":"","type":"common"}]}