{"ver":"0.1","info":{"id":"WtlGRf","date":"1557138558","viewed":347,"name":"Reflectionsion Raymarching","username":"Hendiadyoin","description":"Raymarching-shader with recursive reflections\nPlease click in the Center of the screen to get a propper view\n\nNotes:\n- work on a more realistic way to show the light","likes":10,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MaxSteps 1000\n#define MinDist .0005\n#define MaxDist 100.\n\n#define PI 3.1415926535897931\n\n//diffuse factor\n#define dc .9\n//reflection factor\n#define rc .1\n#define reflection_cutof 0.000000001\n\n#define glight vec3(sin(iTime)*1.9,.5,cos(iTime)*1.9+6.)\n\nfloat getDist(vec3 p){\n    //a sphere with repeating x.axis f=3\n\tfloat dist = length(mod(p+vec3(1.5,0,0),vec3(3,0,0))\n                        -vec3(0,1,6)-vec3(1.5,0,0)) - 1.;\n    //the plane\n    dist = min(dist,p.y);\n    \n    return dist;\n}\n\nvec3 estNormal(vec3 p){\n\tvec2 sstep = vec2(.001,0);\n    float gradx = getDist(p+sstep.xyy)-getDist(p-sstep.xyy);\n    float grady = getDist(p+sstep.yxy)-getDist(p-sstep.yxy);\n    float gradz = getDist(p+sstep.yyx)-getDist(p-sstep.yyx);\n    \n\treturn normalize(vec3(gradx,grady,gradz));\n}\n\nfloat castRay(vec3 ro,vec3 rd){\n\tfloat dist = 0.;\n    for(int i = 1;i<MaxSteps;i++){\n    \tfloat d = getDist(ro + dist*rd);\n        if(d<MinDist) break;\n        dist += d;\n        if(dist > MaxDist) break;\n    }\n    return dist;\n}\n\nfloat getDiff(vec3 p,vec3 light){ //defuse lighting\n\tvec3 lv = normalize(light-p);\n    vec3 n = estNormal(p);\n    float rd = castRay(p+n*MinDist*2.,lv);\n    float b = (dot(n,lv));\n    if(rd<length(light-p)){\n    \tb*=.1;\n    }\n    return max(b,0.); \n}\n\nfloat FresnelReflectAmount ( vec3 p, vec3 vr)\n{// n1:refl, n2:refr ,incident:vr\n    \tvec3 normal = estNormal(p);\n\t\tfloat n1 = 2.;\n    \tfloat n2 = 1.7;\n        // Schlick aproximation\n        float r0 = (n1-n2) / (n1+n2);\n        r0 *= r0;\n        float cosX = -dot(normal, vr);\n        if (n1 > n2)\n        {\n            float n = n1/n2;\n            float sinT2 = n*n*(1.0-cosX*cosX);\n            // Total internal reflection\n            if (sinT2 > 1.0)\n                return 1.0;\n            cosX = sqrt(1.0-sinT2);\n        }\n        float x = 1.0-cosX;\n        float ret = r0+(1.0-r0)*x*x*x*x*x;\n \n        // adjust reflect multiplier for object reflectivity\n        ret = (rc + (1.0-rc) * ret);\n        return ret;\n}\n\nfloat getRefl(vec3 p,vec3 vr, vec3 light){//reflective ligthing\n    float c = 0.;\n    float fact = 1.;\n    for(;;){\n        if (fact<0.000000001)\n            break;\n        vec3 n = estNormal(p);\n   \t\tp += n*MinDist;\n    \tfloat s = dot(n,vr);\n        \n    \tvec3 r = normalize(vr - 2. * s * n);\n    \t\n    \tfloat d = castRay(p,r);\n    \t\n        \n        if(d>length(light-p)){\n    \t\tc += pow(smoothstep(.5,.0,length(r-normalize(light-p))),5.);\n        }\n        if(d>MaxDist) break;\n        fact*= rc;\n    \tvr = normalize((p+r*d)-p);\n        p = p+r*d;\n       \n        \n   \t\tc += getDiff(p,light)*dc*fact;\n    }\n    return c;\n    \n}\n\n\nfloat getBright(vec3 p,vec3 vr,vec3 light){//general lighting\n\tfloat diff = getDiff(p,light);\n    float refl = getRefl(p,vr, light);\n\tfloat b = diff*dc + refl;\n    //float sp = spec(p,vr);\n    return clamp(b,0.,1.);\n}\n\nmat3 mouseRotX(){\n    float th = -(iMouse.x/iResolution.x-.5)*PI;\n\treturn mat3(cos(th),0,sin(th),\n               0,1,0,\n               -sin(th),0,cos(th));\n}\nmat3 mouseRotY(){\n    float th = (1.-iMouse.y/iResolution.y-.5)*PI;\n\treturn mat3(1,0,0,\n               0,cos(th),-sin(th),\n               0,sin(th),cos(th));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    // Normalized pixel coordinates (from -.5 to .5)\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec3 light = glight;\n        \n    vec3 col = vec3(0);\n    \n    vec3 ro = vec3(0,2,0);\n    vec3 rd = normalize(vec3(uv,1))*mouseRotX()*mouseRotY();\n    \n    float d = castRay(ro,rd);\n    //coloring\n    if(d<MaxDist){\n        col = vec3(getBright(ro+rd*d,rd,light));\n    }\n    if(d>length(ro-light))\n    col += pow(smoothstep(0.1,.0,length(rd-normalize(light-ro))),5.);\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n} ","name":"Image","description":"","type":"image"}]}