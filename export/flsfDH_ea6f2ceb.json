{"ver":"0.1","info":{"id":"flsfDH","date":"1650850003","viewed":92,"name":"olympic logo","username":"YutingYang","description":"This is a combination of a compiler-generated GLSL program for the Olympic logo shader with optimized parameters to best match the original Olympic logo, and manual written functions to animate the shader.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["2d","olympic"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// This is a combination of a compiler-generated GLSL program for the Olympic logo shader with optimized parameters to best match the original Olympic logo, and manual written functions to animate the shader.\n// Optimized parameters and code generated using paper:\n// Aùõø: Autodiff for Discontinuous Programs ‚Äì Applied to Shaders \n// Github: https://github.com/yyuting/Adelta\n\n// The olympic logo shader written in the DSL:\n// https://github.com/yyuting/Adelta/blob/main/apps/render_test_finite_diff_olympic_vec_optional_update.py\n\n// The reference Olympic logo:\n// https://en.wikipedia.org/wiki/Olympic_Games#/media/File:Olympic_rings_without_rims.svg\n\n// random walk function from \n// https://www.shadertoy.com/view/WtGfW1\n// https://www.shadertoy.com/view/WtGfDh\n\n\n#define width 960.\n#define height 480.\n\n    \n\n// If true, aspect ratio in the original optimization will be preserved, but extra space outside original FOV might reveal artifact.\n// If false, FOV is the same as original optimization, but aspect ratio will not be preserved.\n#define preserve_aspect_ratio true\n\n// Change this value between 1, 2, 3 for different animation\n// The animation function is human readable and can be found in animate_params()\nint animate_type = 3;\n\n// Smaller factor will zoom in the rendering, larger factor will zoom out\nfloat scale_factor = 1.;\n\n// Optimized parameters by the compiler\n#define X float[](643.7202955362956, 479.50384852020954, 315.2890215773546, 151.084224187857, 807.9212368759073, 309.4281545317152, 169.07619679560676, 309.41879370628016, 169.06849551330885, 169.07322484969052, 151.59339379736082, 151.62550758438215, 151.59607418008437, 151.6049708941682, 151.583176599896, 0.8239717341875831, 0.8237292494583229, 0.8240250154516823, 0.8240528539213584, 0.8240983926758118, -7.027175132803092, 4.448052837898505, -6.954448065779967, 5.556369038858407, 6.397276512368194, 0.001902319975243418, 0.0007860306201746641, 0.9874733116926384, 0.0009327867768653731, 0.9332421613340376, 0.651288630088722, 0.0011618021626761605, 0.6942831293932826, 0.5063242813546726, 0.20117508519188615, 0.31913615091217157, 0.0006172779330198109, 0.19303220567100657, 0.7847435293645989, 0.3061989148014966)\n\n\n#define ring_1_pos_0_idx 0\nfloat ring_1_pos_0 = X[ring_1_pos_0_idx]; // Green\n\n#define ring_2_pos_0_idx 1\nfloat ring_2_pos_0 = X[ring_2_pos_0_idx]; // Black\n\n#define ring_3_pos_0_idx 2\nfloat ring_3_pos_0 = X[ring_3_pos_0_idx]; // Yellow\n\n#define ring_5_pos_0_idx 3\nfloat ring_5_pos_0 = X[ring_5_pos_0_idx]; // Blue\n\n#define ring_7_pos_0_idx 4\nfloat ring_7_pos_0 = X[ring_7_pos_0_idx]; // Red\n\n#define ring_1_pos_1_idx 5\nfloat ring_1_pos_1 = X[ring_1_pos_1_idx];\n\n#define ring_2_pos_1_idx 6\nfloat ring_2_pos_1 = X[ring_2_pos_1_idx];\n\n#define ring_3_pos_1_idx 7\nfloat ring_3_pos_1 = X[ring_3_pos_1_idx];\n\n#define ring_5_pos_1_idx 8\nfloat ring_5_pos_1 = X[ring_5_pos_1_idx];\n\n#define ring_7_pos_1_idx 9\nfloat ring_7_pos_1 = X[ring_7_pos_1_idx];\n\n#define ring_1_radius_idx 10\nfloat ring_1_radius = X[ring_1_radius_idx];\n\n#define ring_2_radius_idx 11\nfloat ring_2_radius = X[ring_2_radius_idx];\n\n#define ring_3_radius_idx 12\nfloat ring_3_radius = X[ring_3_radius_idx];\n\n#define ring_5_radius_idx 13\nfloat ring_5_radius = X[ring_5_radius_idx];\n\n#define ring_7_radius_idx 14\nfloat ring_7_radius = X[ring_7_radius_idx];\n\n#define ring_1_radius_scale_idx 15\nfloat ring_1_radius_scale = X[ring_1_radius_scale_idx];\n\n#define ring_2_radius_scale_idx 16\nfloat ring_2_radius_scale = X[ring_2_radius_scale_idx];\n\n#define ring_3_radius_scale_idx 17\nfloat ring_3_radius_scale = X[ring_3_radius_scale_idx];\n\n#define ring_5_radius_scale_idx 18\nfloat ring_5_radius_scale = X[ring_5_radius_scale_idx];\n\n#define ring_7_radius_scale_idx 19\nfloat ring_7_radius_scale = X[ring_7_radius_scale_idx];\n\n#define ring_1_tilt_idx 20\nfloat ring_1_tilt = X[ring_1_tilt_idx];\n\n#define ring_2_tilt_idx 21\nfloat ring_2_tilt = X[ring_2_tilt_idx];\n\n#define ring_3_tilt_idx 22\nfloat ring_3_tilt = X[ring_3_tilt_idx];\n\n#define ring_5_tilt_idx 23\nfloat ring_5_tilt = X[ring_5_tilt_idx];\n\n#define ring_7_tilt_idx 24\nfloat ring_7_tilt = X[ring_7_tilt_idx];\n\n#define ring_1_col_0_idx 25\nfloat ring_1_col_0 = X[ring_1_col_0_idx];\n\n#define ring_2_col_0_idx 26\nfloat ring_2_col_0 = X[ring_2_col_0_idx];\n\n#define ring_3_col_0_idx 27\nfloat ring_3_col_0 = X[ring_3_col_0_idx];\n\n#define ring_5_col_0_idx 28\nfloat ring_5_col_0 = X[ring_5_col_0_idx];\n\n#define ring_7_col_0_idx 29\nfloat ring_7_col_0 = X[ring_7_col_0_idx];\n\n#define ring_1_col_1_idx 30\nfloat ring_1_col_1 = X[ring_1_col_1_idx];\n\n#define ring_2_col_1_idx 31\nfloat ring_2_col_1 = X[ring_2_col_1_idx];\n\n#define ring_3_col_1_idx 32\nfloat ring_3_col_1 = X[ring_3_col_1_idx];\n\n#define ring_5_col_1_idx 33\nfloat ring_5_col_1 = X[ring_5_col_1_idx];\n\n#define ring_7_col_1_idx 34\nfloat ring_7_col_1 = X[ring_7_col_1_idx];\n\n#define ring_1_col_2_idx 35\nfloat ring_1_col_2 = X[ring_1_col_2_idx];\n\n#define ring_2_col_2_idx 36\nfloat ring_2_col_2 = X[ring_2_col_2_idx];\n\n#define ring_3_col_2_idx 37\nfloat ring_3_col_2 = X[ring_3_col_2_idx];\n\n#define ring_5_col_2_idx 38\nfloat ring_5_col_2 = X[ring_5_col_2_idx];\n\n#define ring_7_col_2_idx 39\nfloat ring_7_col_2 = X[ring_7_col_2_idx];\n\n// Manual written animation funciton, human readable\nvoid animate_params() {\n    \n    if (animate_type == 1) {\n        // rings will fly in\n        float end_time = 3.;\n                \n        if (iTime <= end_time) {\n            \n            // Blue ring\n            vec2 blue_start = vec2(-X[ring_5_radius_idx]);\n            vec2 blue_vel = (vec2(X[ring_5_pos_0_idx], \n                                  X[ring_5_pos_1_idx]) - blue_start) / end_time;\n                             \n            ring_5_pos_0 = blue_start.x + iTime * blue_vel.x;\n            ring_5_pos_1 = blue_start.y + iTime * blue_vel.y;\n            \n            // Black ring\n            vec2 black_start = vec2(X[ring_2_pos_0_idx], -X[ring_2_radius_idx]);\n            vec2 black_vel = (vec2(X[ring_2_pos_0_idx], \n                                   X[ring_2_pos_1_idx]) - black_start) / end_time;\n                                    \n            ring_2_pos_0 = black_start.x + iTime * black_vel.x;\n            ring_2_pos_1 = black_start.y + iTime * black_vel.y;\n            \n            // Yellow ring\n            vec2 yellow_start = vec2(-X[ring_3_radius_idx], height + X[ring_3_radius_idx]);\n            vec2 yellow_vel = (vec2(X[ring_3_pos_0_idx], \n                                    X[ring_3_pos_1_idx]) - yellow_start) / end_time;\n            ring_3_pos_0 = yellow_start.x + iTime * yellow_vel.x;\n            ring_3_pos_1 = yellow_start.y + iTime * yellow_vel.y;\n            \n            // Green ring\n            vec2 green_start = vec2(width, height) + X[ring_1_radius_idx];\n            vec2 green_vel = (vec2(X[ring_1_pos_0_idx], \n                                   X[ring_1_pos_1_idx]) - green_start) / end_time;\n            ring_1_pos_0 = green_start.x + iTime * green_vel.x;\n            ring_1_pos_1 = green_start.y + iTime * green_vel.y;\n            \n            // Red ring\n            vec2 red_start = vec2(width + X[ring_7_radius_idx], -X[ring_7_radius_idx]);\n            vec2 red_vel = (vec2(X[ring_7_pos_0_idx], \n                                 X[ring_7_pos_1_idx]) - red_start) / end_time;\n            ring_7_pos_0 = red_start.x + iTime * red_vel.x;\n            ring_7_pos_1 = red_start.y + iTime * red_vel.y;\n                                 \n        } else {\n        animate_type = 2;\n        }\n    } \n    \n    if (animate_type == 2) {\n        // splined random walk on ring pos\n        // random walk from \n        // https://www.shadertoy.com/view/WtGfW1\n        // https://www.shadertoy.com/view/WtGfDh\n        \n        // how often do we sample random walk\n        float interpolate_t = 0.1;\n        float offset_scale = 4.;\n        float time = iTime;\n        \n        // for paper figure\n        //offset_scale = 20.;\n        //time = 0.1;\n        \n        int base = int(floor(time / interpolate_t));\n        float t = (time - float(base) * interpolate_t) / interpolate_t;\n        \n        for (int idx = 0; idx < 5; idx++) {\n            vec2 p0 = randwalk_fast(base, uint(idx));\n            vec2 p1 = randwalk_fast(base + 1, uint(idx));\n            \n            vec2 offset = p0 * (1. - t) + p1 * t;\n            offset *= offset_scale;\n            \n            if (idx == 0) {\n                ring_5_pos_0 = X[ring_5_pos_0_idx] + offset.x;\n                ring_5_pos_1 = X[ring_5_pos_1_idx] + offset.y;\n            } else if (idx == 1) {\n                ring_2_pos_0 = X[ring_2_pos_0_idx] + offset.x;\n                ring_2_pos_1 = X[ring_2_pos_1_idx] + offset.y;\n            } else if (idx == 2) {\n                ring_3_pos_0 = X[ring_3_pos_0_idx] + offset.x;\n                ring_3_pos_1 = X[ring_3_pos_1_idx] + offset.y;\n            } else if (idx == 3) {\n                ring_1_pos_0 = X[ring_1_pos_0_idx] + offset.x;\n                ring_1_pos_1 = X[ring_1_pos_1_idx] + offset.y;\n            } else {\n                ring_7_pos_0 = X[ring_7_pos_0_idx] + offset.x;\n                ring_7_pos_1 = X[ring_7_pos_1_idx] + offset.y;\n            }\n        }\n    }\n    \n    if (animate_type == 3) {\n        // values for paper\n        float thick_scale = 1.4;\n        float pos_offset = 60.;\n\n        float vel = 1.;\n\n        thick_scale = 1. + min(iTime / vel, 1.) * 0.4;\n        pos_offset = min(iTime / vel, 1.) * 60.;\n        \n        thick_scale = 1.2 - cos(iTime / vel) * 0.2;\n        pos_offset = 30. - cos(iTime / vel) * 30.;\n\n        ring_1_radius_scale /= thick_scale;\n        ring_2_radius_scale /= thick_scale;\n        ring_3_radius_scale /= thick_scale;\n        ring_5_radius_scale /= thick_scale;\n        ring_7_radius_scale /= thick_scale;\n\n        ring_7_pos_0 -= 2. * pos_offset;\n        ring_3_pos_0 += pos_offset;\n        ring_5_pos_0 += 2. * pos_offset;\n        ring_1_pos_0 -= pos_offset;\n    }\n    \n}\n                    \n// Compiler generated program, less readable\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n    fragCoord.y = iResolution.y - fragCoord.y;\n    \n    float current_u;\n    float current_v;\n    \n    if (preserve_aspect_ratio) {\n        float max_scale = max(width / iResolution.x, height / iResolution.y) * scale_factor;\n        \n        vec2 padding = (vec2(width, height) - max_scale * iResolution.xy) / 2.;\n        \n        current_u = fragCoord.x * max_scale + padding.x;\n        current_v = fragCoord.y * max_scale + padding.y;\n    } else {\n        current_u = fragCoord.x / iResolution.x * width;\n        current_v = fragCoord.y / iResolution.y * height;\n    }\n\n                animate_params();\n    \n    \n    float var00016 = ((current_u)-(float(ring_7_pos_0)));\n    float var00014 = pow(var00016, float(2));         \n    float var00017 = ((current_v)-(float(ring_7_pos_1)));\n    float var00015 = pow(var00017, float(2));         \n    float var00013_dist2_ring_7 = ((var00014)+(var00015));\n    float var00012_dist_ring_7 = pow(var00013_dist2_ring_7, float(0.5));\n    float var00011_cond0_diff_ring_7 = ((var00012_dist_ring_7)-(float(ring_7_radius)));\n    bool var00009_cond0_ring_7 = ((var00011_cond0_diff_ring_7)<(float(0)));\n    float var00019 = ((float(ring_7_radius))*(float(ring_7_radius_scale)));\n    float var00018_cond1_diff_ring_7 = ((var00012_dist_ring_7)-(var00019));\n    bool var00010_cond1_ring_7 = ((var00018_cond1_diff_ring_7)>(float(0)));\n    bool var00007 = ((var00009_cond0_ring_7)&&(var00010_cond1_ring_7));\n    float var00021_phase_raw_ring_7 = ((var00016)*(float(ring_7_tilt)));\n    float var00037 = ((current_u)-(float(ring_5_pos_0)));\n    float var00035 = pow(var00037, float(2));         \n    float var00038 = ((current_v)-(float(ring_5_pos_1)));\n    float var00036 = pow(var00038, float(2));         \n    float var00034_dist2_ring_5 = ((var00035)+(var00036));\n    float var00033_dist_ring_5 = pow(var00034_dist2_ring_5, float(0.5));\n    float var00032_cond0_diff_ring_5 = ((var00033_dist_ring_5)-(float(ring_5_radius)));\n    bool var00030_cond0_ring_5 = ((var00032_cond0_diff_ring_5)<(float(0)));\n    float var00040 = ((float(ring_5_radius))*(float(ring_5_radius_scale)));\n    float var00039_cond1_diff_ring_5 = ((var00033_dist_ring_5)-(var00040));\n    bool var00031_cond1_ring_5 = ((var00039_cond1_diff_ring_5)>(float(0)));\n    bool var00028 = ((var00030_cond0_ring_5)&&(var00031_cond1_ring_5));\n    float var00026_phase_raw_ring_5 = ((var00037)*(float(ring_5_tilt)));\n    float var00056 = ((current_u)-(float(ring_3_pos_0)));\n    float var00054 = pow(var00056, float(2));         \n    float var00057 = ((current_v)-(float(ring_3_pos_1)));\n    float var00055 = pow(var00057, float(2));         \n    float var00053_dist2_ring_3 = ((var00054)+(var00055));\n    float var00052_dist_ring_3 = pow(var00053_dist2_ring_3, float(0.5));\n    float var00051_cond0_diff_ring_3 = ((var00052_dist_ring_3)-(float(ring_3_radius)));\n    bool var00049_cond0_ring_3 = ((var00051_cond0_diff_ring_3)<(float(0)));\n    float var00059 = ((float(ring_3_radius))*(float(ring_3_radius_scale)));\n    float var00058_cond1_diff_ring_3 = ((var00052_dist_ring_3)-(var00059));\n    bool var00050_cond1_ring_3 = ((var00058_cond1_diff_ring_3)>(float(0)));\n    bool var00047 = ((var00049_cond0_ring_3)&&(var00050_cond1_ring_3));\n    float var00045_phase_raw_ring_3 = ((var00056)*(float(ring_3_tilt)));\n    float var00074 = ((current_u)-(float(ring_2_pos_0)));\n    float var00072 = pow(var00074, float(2));         \n    float var00075 = ((current_v)-(float(ring_2_pos_1)));\n    float var00073 = pow(var00075, float(2));         \n    float var00071_dist2_ring_2 = ((var00072)+(var00073));\n    float var00070_dist_ring_2 = pow(var00071_dist2_ring_2, float(0.5));\n    float var00069_cond0_diff_ring_2 = ((var00070_dist_ring_2)-(float(ring_2_radius)));\n    bool var00067_cond0_ring_2 = ((var00069_cond0_diff_ring_2)<(float(0)));\n    float var00077 = ((float(ring_2_radius))*(float(ring_2_radius_scale)));\n    float var00076_cond1_diff_ring_2 = ((var00070_dist_ring_2)-(var00077));\n    bool var00068_cond1_ring_2 = ((var00076_cond1_diff_ring_2)>(float(0)));\n    bool var00065 = ((var00067_cond0_ring_2)&&(var00068_cond1_ring_2));\n    float var00063_phase_raw_ring_2 = ((var00074)*(float(ring_2_tilt)));\n    float var00092 = ((current_u)-(float(ring_1_pos_0)));\n    float var00090 = pow(var00092, float(2));         \n    float var00093 = ((current_v)-(float(ring_1_pos_1)));\n    float var00091 = pow(var00093, float(2));         \n    float var00089_dist2_ring_1 = ((var00090)+(var00091));\n    float var00088_dist_ring_1 = pow(var00089_dist2_ring_1, float(0.5));\n    float var00087_cond0_diff_ring_1 = ((var00088_dist_ring_1)-(float(ring_1_radius)));\n    bool var00085_cond0_ring_1 = ((var00087_cond0_diff_ring_1)<(float(0)));\n    float var00095 = ((float(ring_1_radius))*(float(ring_1_radius_scale)));\n    float var00094_cond1_diff_ring_1 = ((var00088_dist_ring_1)-(var00095));\n    bool var00086_cond1_ring_1 = ((var00094_cond1_diff_ring_1)>(float(0)));\n    bool var00083 = ((var00085_cond0_ring_1)&&(var00086_cond1_ring_1));\n    float var00081_phase_raw_ring_1 = ((var00092)*(float(ring_1_tilt)));\n    float var00082 = float(-10000.0);\n    float var00096_phase_diff_ring_1 = ((var00081_phase_raw_ring_1)-(var00082));\n    bool var00084_cond2_ring_1 = ((var00096_phase_diff_ring_1)>(float(0)));\n    bool var00080_cond_all_ring_1 = ((var00083)&&(var00084_cond2_ring_1));\n    float var00079_phase_ring_1 = bool(var00080_cond_all_ring_1) ? var00081_phase_raw_ring_1 : var00082;\n    float var00064 = var00079_phase_ring_1;\n    float var00078_phase_diff_ring_2 = ((var00063_phase_raw_ring_2)-(var00064));\n    bool var00066_cond2_ring_2 = ((var00078_phase_diff_ring_2)>(float(0)));\n    bool var00062_cond_all_ring_2 = ((var00065)&&(var00066_cond2_ring_2));\n    float var00061_phase_ring_2 = bool(var00062_cond_all_ring_2) ? var00063_phase_raw_ring_2 : var00064;\n    float var00046 = var00061_phase_ring_2;\n    float var00060_phase_diff_ring_3 = ((var00045_phase_raw_ring_3)-(var00046));\n    bool var00048_cond2_ring_3 = ((var00060_phase_diff_ring_3)>(float(0)));\n    bool var00044_cond_all_ring_3 = ((var00047)&&(var00048_cond2_ring_3));\n    float var00043_phase_ring_3 = bool(var00044_cond_all_ring_3) ? var00045_phase_raw_ring_3 : var00046;\n    float var00042 = var00043_phase_ring_3;\n    float var00027 = var00042;\n    float var00041_phase_diff_ring_5 = ((var00026_phase_raw_ring_5)-(var00027));\n    bool var00029_cond2_ring_5 = ((var00041_phase_diff_ring_5)>(float(0)));\n    bool var00025_cond_all_ring_5 = ((var00028)&&(var00029_cond2_ring_5));\n    float var00024_phase_ring_5 = bool(var00025_cond_all_ring_5) ? var00026_phase_raw_ring_5 : var00027;\n    float var00023 = var00024_phase_ring_5;\n    float var00022 = var00023;\n    float var00020_phase_diff_ring_7 = ((var00021_phase_raw_ring_7)-(var00022));\n    bool var00008_cond2_ring_7 = ((var00020_phase_diff_ring_7)>(float(0)));\n    bool var00004_cond_all_ring_7 = ((var00007)&&(var00008_cond2_ring_7));\n    vec3 var00005 = vec3(float(float(ring_7_col_0)), float(float(ring_7_col_1)), float(float(ring_7_col_2)));\n    vec3 var00099 = vec3(float(float(ring_5_col_0)), float(float(ring_5_col_1)), float(float(ring_5_col_2)));\n    vec3 var00103 = vec3(float(float(ring_3_col_0)), float(float(ring_3_col_1)), float(float(ring_3_col_2)));\n    vec3 var00106 = vec3(float(float(ring_2_col_0)), float(float(ring_2_col_1)), float(float(ring_2_col_2)));\n    vec3 var00109 = vec3(float(float(ring_1_col_0)), float(float(ring_1_col_1)), float(float(ring_1_col_2)));\n    vec3 var00111 = vec3(float(float(1)), float(float(1)), float(float(1)));\n    vec3 var00110 = var00111;\n    vec3 var00108_col_ring_1 = bool(var00080_cond_all_ring_1) ? var00109 : var00110;\n    vec3 var00107 = var00108_col_ring_1;\n    vec3 var00105_col_ring_2 = bool(var00062_cond_all_ring_2) ? var00106 : var00107;\n    vec3 var00104 = var00105_col_ring_2;\n    vec3 var00102_col_ring_3 = bool(var00044_cond_all_ring_3) ? var00103 : var00104;\n    vec3 var00101 = var00102_col_ring_3;\n    vec3 var00100 = var00101;\n    vec3 var00098_col_ring_5 = bool(var00025_cond_all_ring_5) ? var00099 : var00100;\n    vec3 var00097 = var00098_col_ring_5;\n    vec3 var00006 = var00097;\n    vec3 var00003_col_ring_7 = bool(var00004_cond_all_ring_7) ? var00005 : var00006;\n    vec3 var00002 = var00003_col_ring_7;\n    vec3 var00001 = var00002;\n    vec3 var00000 = var00001;\n    \n        fragColor = vec4(var00000, 1.0);\n        return;\n    }","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"\n//////  COMPLEX ARITHMETIC  ///////////////////////////////////////////////////\nconst float pi = 3.1415927;\nvec2 compmul(vec2 a, vec2 b){return vec2(a.x*b.x-a.y*b.y,a.x*b.y+a.y*b.x);}\nvec2 compsin(float x){return vec2(cos(x),sin(x));}\nvec2 compinv(vec2 a){return vec2(1,-1)*a/dot(a,a);}\n/*\n\nFast implicit random walk 2\nCreated by Theron Tarigo, 2021\nhttps://www.shadertoy.com/view/WtGfW1\n\nRandom walk (brownian motion) implies integration to know particle position as\na function of time, but a recursive solution can provide a qualitatively and\nstatistically equivalent result.\n\nAnimation of https://www.shadertoy.com/view/WtGfDh\n\n*/\n\nfloat comparg(vec2 a){return atan(a.y,a.x);}\nvec2 comppow(vec2 a, float n){return compsin(comparg(a)*n)*pow(dot(a,a),n/2.);}\nvec2 compconj(vec2 a){return vec2(a.x,-a.y);}\n\nvec4 compmul(vec4 a, vec2 b){return vec4(compmul(a.xy,b),compmul(a.zw,b));}\n\n// https://www.shadertoy.com/view/WttXWX\n// --- triple32 from Chris Wellons https://nullprogram.com/blog/2018/07/31/\nuint triple32(uint x)\n{\n    x ^= x >> 17;\n    x *= 0xed5ad4bbU;\n    x ^= x >> 11;\n    x *= 0xac4c1b51U;\n    x ^= x >> 15;\n    x *= 0x31848babU;\n    x ^= x >> 14;\n    return x;\n}\n\nvec2 rnd2_gaussian(uint seed) {\n  uint r = triple32(seed);\n  uvec2 r2 = (uvec2(r)>>uvec2(0,16))&0xFFFFu;\n  vec2 U = vec2(r2+1u)/float(0x10000u);\n  U = sqrt(abs(2.*log(U.x)))*compsin(2.*pi*U.y);\n  return U;\n}\n\nvec2 randwalk_dumb (int i, uint seed) {\n  vec2 x = vec2(0.);\n  for (int j=0; j<i; j++) {\n    x+= rnd2_gaussian(uint(j)+0xda6cu*seed);\n  }\n  return x;\n}\n\nvec2 randwalk_fast (int i, uint seed) {\n  vec2 x = vec2(0.);\n  for (int j=1; j<2; j++) {\n    uint n = uint(i)>>j;\n    uint k = uint(i)-(uint(n)<<j);\n    float l = 1.-abs(1.-float(k)*exp2(-float(j))*2.);\n    x+=rnd2_gaussian(((2u*n+1u)<<(j-1))+0xda6cu*seed)*l*exp2(.5*float(j)-1.);\n  }\n  return x;\n}","name":"Common","description":"","type":"common"}]}