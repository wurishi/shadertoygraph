{"ver":"0.1","info":{"id":"wt23z1","date":"1558567069","viewed":253,"name":"Traced Columns","username":"Hamneggs","description":"A *very* long time ago there was something like this on the site. I can't find it anymore, and I decided to make something similar to test out tracing over marching. (I didn't quite escape raymarching though).","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["raytracing","raytracing","ray","tracing","interior","columns","boxes","dystopian","novels"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","previewfilepath":"/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/**\n * This just traces through a field of cubes that make a box, plus two\n * extra cubes plus lightsources.\n */\n\n// #define ENABLE_SHADOWS /* Compute intensive */\n#define ENABLE_NORMAL_MAPPING\n#define ENABLE_SPECULAR\n\n#define MAT_REFLECTANCE 3.0\n#define BRIGHTNESS 10.0\n#define ID_NONE 0.0\n#define ID_TUNNEL 1.0\n#define ID_LIGHT1 2.0\n#define ID_LIGHT2 4.0\n#define LIGHT1_COLOR vec3(.8,.05,.667)\n#define LIGHT2_COLOR vec3(.05,.05,2.0)\n\n/*\n\tCreates and orientates ray origin and direction vectors based on a\n\tcamera position and direction, with direction and position encoded as\n\tthe camera's basis coordinates.\n*/\nvoid camera(in vec2 uv, in vec3 cp, in vec3 cd, in float f, out vec3 ro, out vec3 rd)\n{\n\tro = cp;\n\trd = normalize((cp + cd*f + cross(cd, vec3(0,1,0))*uv.x + vec3(0,1,0)*uv.y)-ro);\n}\n\n/**\n * Minimum of two 2D vectors.\n */\nvec2 min2( in vec2 a, in vec2 b )\n{\n    if (a.x < b.x) return a;\n    else return b;\n}\n\n/**\n * Minimum of two 3D vectors.\n */\nvec3 min4( in vec3 a, in vec3 b )\n{\n    if (a.x < b.x) return a;\n    else return b;\n}\n\n/**\n * Minimum of two 4D vectors.\n */\nvec4 min4( in vec4 a, in vec4 b )\n{\n    if (a.x < b.x) return a;\n    else return b;\n}\n\n/**\n * Takes the minimum of two intersections.\n */\nvoid minInt(in float distA,  in vec3 normA,  in vec2 uvA,\n            in float distB,  in vec3 normB,  in vec2 uvB,\n            out float distM, out vec3 normM, out vec2 uvM)\n{\n    if ( distA < distB ) { distM = distA; normM = normA; uvM = uvA; }\n    else                 { distM = distB; normM = normB; uvM = uvB; }\n}\n\n/**\n * That random function off of SF.\n */\nfloat rand( in vec2 co )\n{\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\n\n/**\n * 3D version.\n */\nfloat rand3( in vec3 co )\n{\n    return fract(sin(dot(co ,vec3(12.9898,78.233,-53.1234))) * 43758.5453);\n}\n\n/**\n * Sorta the usual FBM, but without using a noise texture and adding\n * high frequency noise at the end.\n */\nfloat fbm( in vec2 x )\n{\n    float r = texture(iChannel0, x     ).x*.5;\n    r += texture(iChannel0, x*2.0 ).x*.25;\n    r += texture(iChannel0, x*4.0 ).x*.125;\n    r += texture(iChannel0, x*8.0 ).x*.0625;\n    r += rand(x)*.0325;\n    return r;\n}\n    \n\n/**\n * Reference function for light positions.\n */\nvec3 lightpos1() { return vec3(sin(iTime*.5)*3., cos(iTime), 2.+sin(iTime)); }\nvec3 lightpos2() { return vec3(sin(iTime)*3.0, -cos(iTime*.5)*.5, 0); }\n\n/**\n * A kinda sorta smoothsquare function.\n */\nfloat smoothSquare(in float x) { return smoothstep(.3, .7, pow(sin(x),2.)); }\n\n/**\n * IQ Really nailed this one.\n */\nmat4 translate( float x, float y, float z )\n{\n    return mat4( 1.0, 0.0, 0.0, 0.0,\n\t\t\t\t 0.0, 1.0, 0.0, 0.0,\n\t\t\t\t 0.0, 0.0, 1.0, 0.0,\n\t\t\t\t x,   y,   z,   1.0 );\n}\n\n/**\n * IQ's sphere intersection.\n */\nvec2 iSphere( in vec3 ro, in vec3 rd, in vec3 ce, float ra )\n{\n    vec3 oc = ro - ce;\n    float b = dot( oc, rd );\n    float c = dot( oc, oc ) - ra*ra;\n    float h = b*b - c;\n    if( h < 0.0 ) return vec2(99999.0); // no intersection\n    h = sqrt( h );\n    return vec2( -b-h, -b+h );\n}\n\n/**\n * IQ's Box intersection.\n */\nfloat iBox( in vec3 row, in vec3 rdw, in mat4 txx, in mat4 txi, in vec3 rad, out vec3 oN, out vec2 oU ) \n{\t\t\t\t \n    // convert from world to box space\n    vec3 rd = (txx*vec4(rdw,0.0)).xyz;\n    vec3 ro = (txx*vec4(row,1.0)).xyz;\n\n\n    // ray-box intersection in box space\n    vec3 m = 1.0/rd;\n    vec3 s = vec3((rd.x<0.0)?1.0:-1.0,\n                  (rd.y<0.0)?1.0:-1.0,\n                  (rd.z<0.0)?1.0:-1.0);\n    vec3 t1 = m*(-ro + s*rad);\n    vec3 t2 = m*(-ro - s*rad);\n\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n\t\n    if( tN>tF || tF<0.0) return 99999.0;\n\n    // compute normal (in world space), face and UV\n    if( t1.x>t1.y && t1.x>t1.z ) { oN=txi[0].xyz*s.x; oU=ro.yz+rd.yz*t1.x; }\n    else if( t1.y>t1.z   )       { oN=txi[1].xyz*s.y; oU=ro.zx+rd.zx*t1.y; }\n    else                         { oN=txi[2].xyz*s.z; oU=ro.xy+rd.xy*t1.z; }\n\n    return tN; // maybe min(tN,tF)?\n}\n\n\n/**\n * A simplified version.\n */\n#ifdef ENABLE_SHADOWS\nfloat iBoxSimple( in vec3 row, in vec3 rdw, in mat4 txx, in vec3 rad ) \n{\t\t\t\t \n    vec3 rd = (txx*vec4(rdw,0.0)).xyz;\n    vec3 ro = (txx*vec4(row,1.0)).xyz;\n\n    vec3 m = 1.0/rd;\n    vec3 s = vec3((rd.x<0.0)?1.0:-1.0,\n                  (rd.y<0.0)?1.0:-1.0,\n                  (rd.z<0.0)?1.0:-1.0);\n    vec3 t1 = m*(-ro + s*rad);\n    vec3 t2 = m*(-ro - s*rad);\n\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n\t\n    if( tN>tF || tF<0.0) return 99999.0;\n\n    return tN;\n}\n#endif // ENABLE_SHADOWS\n\n/**\n * Takes a ray, walks it forward, and see if it intersects\n * any columns near it.\n */\nvoid tunnel( in vec3 ro, in vec3 rd, out float dist, out vec3 n, out vec2 uv )\n{\n    dist = 9999999.0; // nearest intersection distance, normal, and UV.\n    n = vec3(0,1,0);\n    uv = vec2(0);\n    \n    float intersect = 0.0; // Did we hit something?\n    \n    vec3 p = ro; // Copy of the ray origin.\n    \n    // March the ray forward.\n    for(float i = 0.0; i < 9.0; ++i)\n    {\n        for(int x = -1; x < 2; ++x) // Left and right neighbors.\n        for(int z = -1; z < 2; ++z) // Front and back neighbors.\n        {\n            \n            \n            vec3 off = vec3(x,0,z); // Create an offset vector.\n\n\t\t\t\n            vec3 g = floor(p); // Floor the ray position.\n\n            // Get the columns' height.\n            float h_b = .5*smoothSquare(.25*iTime + 3.14*rand(off.xz-g.xz)    );\n            float h_t = .5*smoothSquare(.25*iTime + 3.14*rand(off.xz-g.xz-1.0));\n            float h_l = .5*smoothSquare(.25*iTime + 3.14*rand(off.xz-g.yz)    );\n            float h_r = .5*smoothSquare(.25*iTime + 3.14*rand(off.xz-g.yz-1.0));\n            float h_f = .5*smoothSquare(.25*iTime + 3.14*rand(off.xz-g.xy)    );\n            float h_d = .5*smoothSquare(.25*iTime + 3.14*rand(off.xz-g.xy-1.0)); // derriere for back, since b is taken for \"bottom\".\n            \n            // Create the required translation matrices.\n            mat4 t_b = translate(off.x-g.x-.5,  3.0+h_b, off.z-g.z-.5); \n            mat4 t_t = translate(off.x-g.x-.5, -3.0-h_t, off.z-g.z-.5); \n            mat4 t_l = translate(-4.0-h_l, off.x-g.y-.5, off.z-g.z-.5); \n            mat4 t_r = translate( 4.0+h_r, off.x-g.y-.5, off.z-g.z-.5); \n            mat4 t_f = translate(off.x-g.x-.5, off.z-g.y-.5, -4.0-h_f); \n            mat4 t_d = translate(off.x-g.x-.5, off.z-g.y-.5,  4.0+h_d);\n            \n            // And their inverses.\n            mat4 t_bi = inverse(t_b), t_ti = inverse(t_t), t_li = inverse(t_l);\n            mat4 t_ri = inverse(t_r), t_fi = inverse(t_f), t_di = inverse(t_d);\n            \n            vec3 n_b, n_t, n_l, n_r, n_f, n_d; \t\t // Places to store surface normals.\n            vec2 uv_b, uv_t, uv_l, uv_r, uv_f, uv_d; // And more places to store UVs.\n\n            // Finally we can check some intersections.\n            float dist_b = iBox(p, rd, t_b, t_bi, vec3(.5), n_b, uv_b) + i;\n            float dist_t = iBox(p, rd, t_t, t_ti, vec3(.5), n_t, uv_t) + i;\n            float dist_l = iBox(p, rd, t_l, t_li, vec3(.5), n_l, uv_l) + i;\n            float dist_r = iBox(p, rd, t_r, t_ri, vec3(.5), n_r, uv_r) + i;\n            float dist_f = iBox(p, rd, t_f, t_fi, vec3(.5), n_f, uv_f) + i;\n            float dist_d = iBox(p, rd, t_d, t_di, vec3(.5), n_d, uv_d) + i;\n            \n            // Find the nearest intersection.\n            minInt( dist, n, uv, dist_t, n_t, uv_t, dist, n, uv );\n            minInt( dist, n, uv, dist_b, n_b, uv_b, dist, n, uv );\n            minInt( dist, n, uv, dist_l, n_l, uv_l, dist, n, uv );\n            minInt( dist, n, uv, dist_r, n_r, uv_r, dist, n, uv );\n            minInt( dist, n, uv, dist_f, n_f, uv_f, dist, n, uv );\n            minInt( dist, n, uv, dist_d, n_d, uv_d, dist, n, uv );\n        }\n        \n        // All boxes have a grid size of 1, and ||rd|| = 1.\n        // This allows us to use our marching step index as the distance\n        // traveled from origin.\n        p += rd;\n    }\n    \n    // Now it's time to get the two feature cubes in the middle.\n    \n    vec3 n_f1, n_f2; // Surface normals.\n    vec2 uv_f1, uv_f2; // Texcoords.\n    \n    // Translation matrices.\n    mat4 t_f1 = translate(-.6,-.6,-.6); mat4 t_f1i = inverse(t_f1);\n    mat4 t_f2 = translate( .6, .6, .6); mat4 t_f2i = inverse(t_f2);\n    \n    // Check for intersection.\n    float dist_f1 = iBox(ro, rd, t_f1, t_f1i, vec3(.5), n_f1, uv_f1);\n    float dist_f2 = iBox(ro, rd, t_f2, t_f2i, vec3(.5), n_f2, uv_f2);\n    \n    // Factor them into the equation.\n    minInt( dist, n, uv, dist_f1, n_f1, uv_f1, dist, n, uv );\n    minInt( dist, n, uv, dist_f2, n_f2, uv_f2, dist, n, uv );\n    \n    // Perturb the surface normal.\n    #ifdef ENABLE_NORMAL_MAPPING\n    p = ro+dist*rd;\n    vec2 texCoord = uv+rand3(floor(p)); \n    vec3 diff = vec3(fbm(texCoord), fbm(texCoord+12348.3), 0);\n    diff = 2.0*diff - 1.0;\n    diff *= .125;\n    vec3 an = abs(n);\n    if( an.x > .5 ) \t n = normalize(n+diff.zxy*sign(n.x));\n    else if( an.y > .5 ) n = normalize(n+diff.xzy*sign(n.y));\n    else\t\t\t\t n = normalize(n+diff.xyz*sign(n.z));\n    #endif // ENABLE_NORMAL_MAPPING\n}\n\n/**\n * Traces a ray through the field. This trace function includes\n * two spheres for the light soruces.\n */\nvoid trace( in vec3 ro, in vec3 rd, out float id, out float dist, out vec3 n, out vec2 uv)\n{\n    tunnel(ro, rd, dist, n, uv);\n    float si1 = iSphere(ro, rd, lightpos1(), .05).x;\n    float si2 = iSphere(ro, rd, lightpos2(), .05).x;\n   \t\n    vec2 minElement = vec2(9999999.0, ID_NONE);\n    minElement = min2(minElement, vec2(dist, ID_TUNNEL));\n    minElement = min2(minElement, vec2(si1,  ID_LIGHT1));\n    minElement = min2(minElement, vec2(si2,  ID_LIGHT2));\n   \tdist = minElement.x;\n    id = minElement.y;\n            \n}\n\n/**\n * Marches a ray forward through a simplified geometry field, since\n * we don't need the UV or normal vector of where the shadow ray\n * collides.\n */\n#ifdef ENABLE_SHADOWS\nvoid tunnelShadow( in vec3 ro, in vec3 rd, out float dist )\n{\n    dist = 9999999.0;    \n   \tint face;\n    float intersect = 0.0;\n    vec3 p = ro;\n    \n    for(float i = 0.0; i < 9.0; ++i)\n    {\n        for(int x = -1; x < 2; ++x)\n        for(int z = -1; z < 2; ++z)\n        {\n            vec3 off = vec3(x,0,z);\n            vec3 g = floor(p);\n\n            float h_b = .5*smoothSquare(.25*iTime + 3.14*rand(off.xz-g.xz)    );\n            float h_t = .5*smoothSquare(.25*iTime + 3.14*rand(off.xz-g.xz-1.0));\n            float h_l = .5*smoothSquare(.25*iTime + 3.14*rand(off.xz-g.yz)    );\n            float h_r = .5*smoothSquare(.25*iTime + 3.14*rand(off.xz-g.yz-1.0));\n            float h_f = .5*smoothSquare(.25*iTime + 3.14*rand(off.xz-g.xy)    );\n            float h_d = .5*smoothSquare(.25*iTime + 3.14*rand(off.xz-g.xy-1.0));\n            \n            mat4 t_b = translate(off.x-g.x-.5,  3.0+h_b, off.z-g.z-.5); \n            mat4 t_t = translate(off.x-g.x-.5, -3.0-h_t, off.z-g.z-.5); \n            mat4 t_l = translate(-4.0-h_l, off.x-g.y-.5, off.z-g.z-.5); \n            mat4 t_r = translate( 4.0+h_r, off.x-g.y-.5, off.z-g.z-.5); \n            mat4 t_f = translate(off.x-g.x-.5, off.z-g.y-.5, -4.0-h_f); \n            mat4 t_d = translate(off.x-g.x-.5, off.z-g.y-.5,  4.0+h_d);\n\n            float dist_b = iBoxSimple(p, rd, t_b, vec3(.5)) + i;\n            float dist_t = iBoxSimple(p, rd, t_t, vec3(.5)) + i;\n            float dist_l = iBoxSimple(p, rd, t_l, vec3(.5)) + i;\n            float dist_r = iBoxSimple(p, rd, t_r, vec3(.5)) + i;\n            float dist_f = iBoxSimple(p, rd, t_f, vec3(.5)) + i;\n            float dist_d = iBoxSimple(p, rd, t_d, vec3(.5)) + i;\n            \n            dist = min(dist, dist_b);\n            dist = min(dist, dist_t);\n            dist = min(dist, dist_l);\n            dist = min(dist, dist_r);\n            dist = min(dist, dist_f);\n            dist = min(dist, dist_d);\n        }\n        p += rd;\n    }\n    mat4 t_f1 = translate(-.6,-.6,-.6);\n    mat4 t_f2 = translate( .6, .6, .6);\n    \n    float dist_f1 = iBoxSimple(ro, rd, t_f1, vec3(.5));\n    float dist_f2 = iBoxSimple(ro, rd, t_f2, vec3(.5));\n    \n    dist = min(dist, dist_f1);\n    dist = min(dist, dist_f2);\n}\n#endif // ENABLE_SHADOWS\n\n/**\n * Traces a shadow ray through the distance field.\n */\n#ifdef ENABLE_SHADOWS\nvoid traceShadow( in vec3 ro, in vec3 rd, out float dist)\n{\n    tunnelShadow(ro, rd, dist);\n}\n#endif // ENABLE_SHADOWS\n\n/*\n\tOren-Nayar reflectance modeling. I use this everywhere. Just looks good.\n*/\nfloat orenNayar( in vec3 n, in vec3 v, in vec3 ldir )\n{\n    float r2 = pow(MAT_REFLECTANCE, 2.0);\n    float a = 1.0 - 0.5*(r2/(r2+0.57));\n    float b = 0.45*(r2/(r2+0.09));\n\n    float nl = dot(n, ldir);\n    float nv = dot(n, v);\n\n    float ga = dot(v-n*nv,n-n*nl);\n\n\treturn max(0.0,nl) * (a + b*max(0.0,ga) * sqrt((1.0-nv*nv)*(1.0-nl*nl)) / max(nl, nv));\n}\n\n/**\n * Models a point light.\n */\nvec3 pointLight( in vec3 p, in vec3 n, in vec3 lp, in vec3 rd, in vec3 texel, in vec3 lc )\n{\n    \n    vec3 ld = lp-p; \t\t\t\t\t\t\t\t// Direction of light.\n    float dist = length(ld); \t\t\t\t\t\t// Distance to the light.\n    ld = normalize(ld); \t\t\t\t\t\t\t// Normalize for correct trig.\n    float base = orenNayar(n, rd, ld)*BRIGHTNESS; \t// Base lighting coefficient.\n    float falloff = clamp(1.0/(dist*dist),0.0,1.0); // Quadratic coefficient.\n    \n    // Specular.\n    #ifdef ENABLE_SPECULAR\n    vec3 reflection = normalize(reflect(rd,n));\n    float specular = clamp(pow(clamp(dot(ld, reflection),0.0,1.0),25.0),0.0,1.0);\n    #else\n    float specular = 0.0;\n    #endif // ENABLE_SPECULAR\n    \n    // Optionally do shadows.\n    #ifdef ENABLE_SHADOWS\n    float shadowDist;\n    traceShadow(p+ld*.01, ld, shadowDist);\n    float shadow = smoothstep(dist*.99, dist*1.01,shadowDist);\n    #else\n    float shadow = 1.0;\n    #endif // ENABLE_SHADOWS\n    \n    return lc*specular*shadow + base*falloff*shadow*lc*texel + lc*.0125;\n}\n\n/**\n * Lights the entire scene by tracing both point lights.\n */\nvec3 lightScene( in vec3 p, in vec3 n, in vec3 rd, in vec3 texel )\n{\n    \n    return clamp( pointLight(p, n, lightpos1(), rd, texel, LIGHT1_COLOR) +\n              \t  pointLight(p, n, lightpos2(), rd, texel, LIGHT2_COLOR),\n              \t  vec3(0),vec3(1) );\n}\n\n/**\n * Takes it a step further by coloring based on object ID.\n */\nvec3 shade( in vec3 p, in vec3 n, in vec3 rd, in float dist, in float id )\n{\n    if(id == ID_NONE) return vec3(0);\n    else if(id == ID_TUNNEL) return vec3( lightScene(p+rd*dist, n, rd, vec3(1)) );\n    else if(id == ID_LIGHT1) return LIGHT1_COLOR*BRIGHTNESS*2.0;\n    else if(id == ID_LIGHT2) return LIGHT2_COLOR*BRIGHTNESS*2.0;\n    else return vec3(0);\n}\n\n/**\n * Some quick tonemapping and vignetting.\n */\nvec4 postProcess( in vec3 c, in vec2 uv )\n{\n    float vig = 1.0-dot(uv,uv)*.6;\n    c = pow(clamp(c, 0., 1.), vec3(.4545));\n    return vec4(c*vig,1);\n}\n\n/**\n * Entrypoint.\n */\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy - 0.5;\n\tuv.x *= iResolution.x/iResolution.y; //fix aspect ratio\n    \n    // Set up the camera.\n    \n    // Position.\n    vec3 cp =  vec3(3.0*cos(iTime*.5), sin(iTime*.25), 3.0*sin(iTime*.25));\n    \n    // Direction.\n    vec3 cd = normalize(vec3(-cos(iTime*.5), .5*cos(iTime*.25), -sin(iTime*.25)));\n    \n    // Places to store results.\n    vec3 p, d;\n    \n    // Create the view ray.\n    camera(uv, cp, cd, .667, p, d);\n    \n    // Do the traces.\n    float id; float dist; vec3 n; vec2 texCoord;\n    trace(p, d, id, dist, n, texCoord);\n    \n    // Shade the point.\n    vec3 c = shade(p, n, d, dist, id);\n    \n    \n    \n    // Based on the results of that trace, we shade accordingly.\n    fragColor = postProcess(c, uv);\n}","name":"Image","description":"","type":"image"}]}