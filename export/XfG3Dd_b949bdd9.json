{"ver":"0.1","info":{"id":"XfG3Dd","date":"1713402101","viewed":114,"name":"Deep Vein Thrombosis Type Beat","username":"FatLenny","description":"With help from @kishimisu youtube tutorial for raymarching","likes":8,"published":1,"flags":4,"usePreview":0,"tags":["3d","raymarching","raymarching","fractal","tutorial","reactive","music","colorful","visualizer","trippy","phychedelic"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdXGRr","filepath":"/presets/mic.png","previewfilepath":"/presets/mic.png","type":"mic","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Fork of \"Liminal Drops V1\" by FatLenny. https://shadertoy.com/view/lcV3Dc\n// 2024-04-17 19:44:46\n\n// Fork of \"Liminal Drops\" by FatLenny. https://shadertoy.com/view/Xcc3zN\n// 2024-04-17 19:21:00\n\n// Fork of \"Basic Raymarching Shader\" by None. https://shadertoy.com/view/-1\n// 2024-03-26 05:42:39\n\n    //DEFINING OBJECTS IN OUR SCENE\n\n    // this function takes a 3D point as input and returns the distance to the nearest object in the scene\n\n\nfloat sdSphere(vec3 p, float s) {\n   \n    \n    // for now, returns distance to a sphere of radius 1.0 located at the origin\n    return length(p) - s;  \n    \n}\n\nfloat sdCube( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat sdOct( vec3 p, float s )\n{\n  p = abs(p);\n  float m = p.x+p.y+p.z-s;\n  vec3 q;\n       if( 3.0*p.x < m ) q = p.xyz;\n  else if( 3.0*p.y < m ) q = p.yzx;\n  else if( 3.0*p.z < m ) q = p.zxy;\n  else return m*0.57735027;\n    \n  float k = clamp(0.5*(q.z-q.y+s),0.0,s); \n  return length(vec3(q.x,q.y-s+k,q.z-k)); \n}\n\nmat2 rot2d(float angle){\n    float s = sin(angle);\n    float c = cos(angle);\n    return mat2(c, -s, s, c);\n}\n\nvec3 rot3d(vec3 p, vec3 axis, float angle)\n{\n    return mix(dot(axis, p) * axis, p, cos(angle))\n               + cross(axis, p) *sin(angle);\n}\n\n//SMOOTH COMBINING OF SHAPES WHERE K IS SMOOTHIG FACTOR\nfloat smin( float d1, float d2, float k )\n{\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\nfloat ssub( float d1, float d2, float k )\n{\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h);\n}\n\nfloat sint( float d1, float d2, float k )\n{\n    float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.0-h);\n}\n\nvec3 palette(in float t)\n{\n\n    vec4 sound = texture(iChannel0,vec2(.6,.2));\n\n    float it = iTime;\n    float its = iTime*0.1;\n    float itvs = iTime*0.01;\n    /*                  //THE ILLNESS\n    vec3 a = vec3(0.821, 0.328, 0.242);\n    vec3 b = vec3(0.659*sin(cos(its))-0.1, 0.481*cos(it)*0.7, 0.896);\n    vec3 c = vec3(0.918, 0.594, 0.517);\n    vec3 d = vec3(2.820+it*0.1, 3.026+it*0.1, -0.273+it*0.1);\n    */\n    \n    /*//HOT FLASHES\n    vec3 a = vec3(0.821, 0.328, 0.242);\n    vec3 b = vec3(0.659*cos(it), 0.481*cos(it), 0.896);\n    vec3 c = vec3(0.918, 0.594, 0.517);\n    vec3 d = vec3(2.820+it*0.1, 3.026+it*0.1, -0.273+it*0.1);\n    */\n   \n    /*                  // UV NIGHTMARE\n    vec3 a = vec3(0.821, 0.328, 0.242);\n    vec3 b = vec3(0.659, 0.481, 0.896);\n    vec3 c = vec3(0.612, 0.340, 0.296);\n    vec3 d = vec3(4.608+iTime*0.1,  0.135,                4.526-iTime*0.001);\n    */\n     \n    \n    // DEEP GLOW\n    vec3 a = vec3(0.821,           0.328-smoothstep(0.0, 1.8, sound.x*0.6), 0.242);\n    vec3 b = vec3(0.761*cos(its),  0.639-cos(smoothstep(0.3, 1.8, sound.x*0.6)), 0.761*cos(its)-smoothstep(0.0, 1.5, sound.x));\n    vec3 c = vec3(0.817,           0.438+cos(smoothstep(0., 1., sound.x*0.6)), 1.042*cos(smoothstep(0.0, 1.5, sound.x*0.2)));\n    vec3 d = vec3(4.608+iTime*0.1, 0.135+smoothstep(0.0, 1.5, sound.x), 4.526-iTime*0.001-smoothstep(0.3, 1.5, sound.x));\n    \n    \n    \n    /*            // NEON GREEN SUNSET\n    vec3 a = vec3(0.514, 0.739, 0.286); \n    vec3 b = vec3(0.561, 0.639, 0.261);\n    vec3 c = vec3(1.117, 0.438, 1.042);\n    vec3 d = vec3(4.608+its, 0.135+its, 4.526+its);\n    */\n    \n    /*              // COLORES!\n    vec3 a = vec3(0.514, 0.739, 0.286); \n    vec3 b = vec3(0.561, 0.639, 0.261);\n    vec3 c = vec3(0.9*cos(its), 0.938+cos(its)*0.8, 0.542);\n    vec3 d = vec3(4.608+its, 0.135+its, 4.526+its);\n    */\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nfloat map(vec3 p) {\n    vec2 mp = (iMouse.xy * 2.0 - iResolution.xy) / iResolution.y;// Normalize mouse position to fit canvas\n    vec4 sound = texture(iChannel0,vec2(.6,.2)); \n    \n    \n    //vec3 cg = p;\n    //cg.y += 3.5;\n    //cg.xz = fract(cs.xz) - 0.5;\n    \n    //float cubeground = sdCube(cg, vec3(1.0));\n    vec3 ct = p;// Vector used to transform the cube\n\n    vec3 fc = ct;// Vector used to fractalize the cube\n    vec3 fp = p;// Vector used to fractalize the scene\n    \n    \n    ct.y += iTime;\n    \n    \n    ct.z -= iTime * 0.8+cos(smoothstep(0.1, 1.5, sound.x)*0.1);\n    \n    vec3 ct2 = ct;\n    ct2.z += 0.5;\n    \n    vec3 ct3 = ct2;\n    ct3.z -= iTime*1.2 + 0.5;\n    //vec3 ct4 = p;\n    vec3 ct4 = ct;\n    ct4.z += iTime*2.0;\n    \n    ct = mod(ct, 1.0) - 0.5;\n    ct2 = mod(ct2, 1.0) - 0.5;\n    ct3.xy = mod(ct3.xy, 1.0) - 0.5;\n    ct3.z = mod(ct3.z, 4.0) - 2.0;\n    ct4.xy = mod(ct4.xy, 2.0) - 1.0;\n    ct4.z = mod(ct4.z, 4.0) - 2.0;\n    \n    //ct.yz *= rot2d(iTime);// Rotate around x axis\n    //ct.xz *= rot2d(iTime);// Rotate around y axis\n    ct.xy *= rot2d(iTime*2.0);// Rotate around z axis\n       \n    ct2.xy *= -rot2d(iTime*2.0);\n    //ct3.xy *= rot2d(-iTime*1.0);\n    ct3.yz *= rot2d(+iTime*2.0);// Rotate around x axis\n    ct3.xz *= rot2d(+iTime*2.0);// Rotate around y axis\n    ct4.xy *= rot2d(+iTime*2.0);\n    ct4.yz *= rot2d(+iTime*2.0);\n    // Order of operations for transformations is important because you will get a \n    // different outcome depending on the order they are applied in\n   \n    \n    \n   \n    float cube = sdOct(ct, 0.15);\n    float cube2 = sdOct(ct2, 0.2+smoothstep(0.1, 1.8, sound.x));\n    float cube3 = sdOct(ct3, 0.1);\n    float cube4 = sdOct(ct4, 0.69+sound.x);\n    float torus1 = sdTorus(ct4, vec2(0.2, 0.08+sin(iTime)*0.05));\n    \n    \n    float ground = p.y + 4.5;// The ground is wherever is directly under the ray, ot its y position plus an offset\n\n    float shapes;\n\n    shapes = smin(cube, ground, 0.5);\n    shapes = smin(cube2, shapes, 0.5);\n    shapes = smin(cube3, shapes, 0.4);\n    //shapes = smin(cube4, shapes, 0.2+sound.x);\n    shapes = smin(torus1, shapes, 0.0);\n  \n    return shapes;// Combining all of our shapes and the ground with smoothing \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    vec4 sound = texture(iChannel0,vec2(.6,.2));\n    \n    vec2 mp = (iMouse.xy * 2.0 - iResolution.xy) / iResolution.y;\n    \n    \n    float fov = 2.2+mp.y+cos(iTime*0.1)*0.1-2.0;\n    \n    // INITIALIZATION FOR RAYMARCHING\n\n    // fragCoord holds coords of every pixel\n    vec2 uv =(fragCoord *2.0 - iResolution.xy) / iResolution.y; \n    \n    // Normalize mouse position to fit canvas\n    vec2 mp2 = (iMouse.zw * 2.0 - iResolution.xy) / iResolution.y;\n    \n    // corresponds to the camera's curent position in our world\n    vec3 ro = vec3(0, 0, -3);// Ray origin \n  \n    // we can use UV as x and y coords because we decided to alignd the world x and y axis with our UV coords\n    // this allows each pizel to have a unique direction spreading out from the center of our screen\n    // this effectively creates a virtual canvas to project the world to\n    // Step 1: \n    // vec3 rayDirection = vec3(uv, 1);\n    \n    // now we normalize the vectors to ensure they all have a length of 1.0 which is crucial for distance calcs    \n    // step 2:\n    vec3 rd = normalize(vec3(uv * fov, 1)); // Ray direction\n\n    // this represents the final pixel color once we have completed the raymarch\n    vec3 col = vec3(0.0);   \n    \n    //create a float to keep track of the current distance the point has traveled from rayOrigin \n    float dt = 0.0;// Distance traveled\n    \n    // CAMERA ROTATION\n    \n    // Vertical rotation\n    ro.yz *= rot2d(smoothstep(0.0, 1.7, sound.x)*0.1);\n    rd.yz *= rot2d(smoothstep(0.0, 1.7, sound.x)*0.1);\n    ro.yz *= rot2d(0.0);\n    rd.yz *= rot2d(0.0);\n    \n    // Horizontal rotation\n    //ro.xz *= rot2d(-mp.x*2.0);\n    //rd.xz *= rot2d(-mp.x*2.0);\n    //ro.xz *= rot2d(-mp2.y*4.0-45.0);\n    //rd.xz *= rot2d(-mp2.y*4.0-45.0);\n    \n    // END OF INITIALIZATION\n\n    // BEGIN RAYMARCHING\n    \n    // i represents the current raymarching step with a max of 80 iterations\n    // the max iterations affects the QUALITY of the result and the PERFORMANCE\n    // too few steps may not allow the ray to reach an object, while too many will impast shader performance\n    // this parameter needs to be adjusted to fit your specific scene\n    int i;\n    for(i = 0; i < 80; i++)\n    {\n    \n        // create a vec3 that indicates the position along the ray based on its distance from the origin\n        // we use this point to compute the distance to the closest object in the scene\n        // the point starts at the ray's origin because distTraveled is initialized to 0.0\n        // we do this using signed distance functions (SDF)\n        // info on SDF related to raymarching: https://iquilezles.org/articles/distfunctions/\n        vec3 p = ro + rd * dt;// Position along ray\n\n        p.xy *= rot2d(0.2*dt *cos(iTime*0.1)*3.0);\n\n        p.y += sin(dt+iTime)*0.2+smoothstep(0.2, 1.8, sound.x); // Wiggle Ray\n\n        // use mapDistance function to get the distance to the scene given our current position along the ray\n        // this value represents the distance the point can travel in any direction until encountering an object\n        float ds = map(p); // Distance to scene\n\n        // here we are \"marching\" the ray forward based on the distance we got from getDistance()\n        // in other words we are calculating the distance to the closest object in the scene\n        // we then use this distance to \"safely\" march the ray forward, knowing we will not hit an object at that distance\n        // now we repeat the for loop until we either hit an object or exceed the max marching steps we set \n        dt += ds;\n        \n        // This stuups the raymarching when the distance to the object is so small that we nonnot need to do 80 iterations\n        // withouy this the max number of iterations would be performed every time and could greatly reduce performance \n        // if the threshold is set too high, you will lose deatil\n        // if too low the performance gains will be negligible\n        //finalColor = vec3(i) / 80.0;\n        if (ds < 0.001) break;\n        \n        // stops loop early if the ray has travaeled too far by putting a cap on the distance it is allowed to travel\n        if (dt > 100.0) break;\n        \n        // we can combine the previous 2 checks into one line: if(distanceToScene < 0.001 || distTraveled > 100.0) break;\n        \n    }\n    \n    //COLORING\n    \n    // this outputs a greyscale image based on distance from the origin\n    // by default this will display any value greater than 1 as pureb white, so we need to fix that\n    // we can either move the camera closer to the objects or divide distTraveled by an arbitrary number until we can see things\n    // here I am using the divide by an arbitrary number method\n    col = palette(dt * 0.002 + float(i)*0.008+smoothstep(0.3, 2.5, sound.x)*0.01);\n     \n    // fragColor holds RGB and alpha values of a pixel\n    // we use finalColor as the output of our shader instead of displaying the UV coords like it normally would\n    fragColor = vec4(col, 1);\n\n}","name":"Image","description":"","type":"image"}]}