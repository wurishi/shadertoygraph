{"ver":"0.1","info":{"id":"msfGWM","date":"1666208618","viewed":42,"name":"Double slit - waves (no sim)","username":"jean80it","description":"Double slit with waves (no simulation - this is just to illustrate the phenomenon)","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["waves","doubleslit"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// This shader is part of several I wrote to create animations\n// to support a presentation about Quantum Electrodynamics.\n// it is not supposed to be \"proof\" for anything, but to provide \n// good visualization of some concepts to help intuition.\n\n\n#define PI 3.1415926\n\n#define sqr(x) (x * x)\n\n#define deg2rad(x) (x * PI / 180.0)\n\n#define rad2deg(x) (x * 180.0 / PI)\n\nvec2 translate(vec2 p, vec2 newPos)\n{\n    return p - newPos;\n}\n\nvec2 rotate(vec2 p, float a)\n{\n    mat2 r = mat2(\n        cos(a), sin(a),\n        -sin(a), cos(a)\n        );\n        \n    return p * r;\n}\n\nfloat sdTriangleIsosceles( in vec2 p, in vec2 q )\n{\n    p.x = abs(p.x);\n    vec2 a = p - q*clamp( dot(p,q)/dot(q,q), 0.0, 1.0 );\n    vec2 b = p - q*vec2( clamp( p.x/q.x, 0.0, 1.0 ), 1.0 );\n    float s = -sign( q.y );\n    vec2 d = min( vec2( dot(a,a), s*(p.x*q.y-p.y*q.x) ),\n                  vec2( dot(b,b), s*(p.y-q.y)  ));\n    return -sqrt(d.x)*sign(d.y);\n}\n\nfloat sdEllipse(vec2 p, vec2 r)\n{\n    return length(p * r.x / r) - r.x;\n}\n\nfloat sdRect(vec2 p, vec2 size) \n{\n    vec2 d = abs(p) - size / 2.0;\n    return max(d.x, d.y);\n}\n\nfloat sdVector(in vec2 p, in float len, in float thickness, in float appPointR, vec2 arrowHeadSize)\n{\n    vec2 arrowLineSize = vec2(thickness, len);\n    float c = sdRect(p - vec2(0.0, (arrowLineSize.y - arrowHeadSize.y) / 2.0), arrowLineSize - vec2(0.0, arrowHeadSize.y));\n    c = min(c, sdEllipse(p, vec2(appPointR)));\n    c = min(c, sdTriangleIsosceles(p - vec2(0.0, arrowLineSize.y), vec2(arrowHeadSize.x, -arrowHeadSize.y)));\n    \n    return c;\n}\n\nfloat sdSimpleRoundedBox( in vec2 p, in vec2 b, float r)\n{\n    vec2 q = abs(p)-b+r;\n    return min(max(q.x,q.y),0.0) + length(max(q,0.0)) - r;\n}\n\nvec3 drawSd(float d, inout vec3 prevCol, vec3 newCol, float aaTransitionWidth)\n{\n    prevCol = mix(prevCol, newCol, smoothstep(aaTransitionWidth, 0.0, d));\n    return prevCol;\n}\n\nvec3 drawSd(float d, inout vec3 prevCol, vec3 newCol, float mask, float aaTransitionWidth)\n{\n    prevCol = mix(prevCol, newCol, clamp(mask, 0.0, 1.0) * smoothstep(aaTransitionWidth, 0.0, d));\n    return prevCol;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float invY = 1.0 / iResolution.y;\n    vec2 uv = fragCoord * invY;\n    vec2 center = vec2(iResolution.x * invY * 0.5, 0.5);\n    float aaTransitionWidth = 1.0 / (min(iResolution.x, iResolution.y)) * 2.0;\n    \n    float thickness = 0.01;\n\n    vec2 halfGapSize = vec2(0.0, 0.2);\n\n    float animTimeToStop = 15.0;\n\n    //float t = smoothstep(10.0, 9.0, iTime) * iTime * 2.0;\n    float t = clamp(iTime, 0.0, animTimeToStop) * 2.0;\n    float freq = 80.0;\n\n    vec3 colObstacle = vec3(0.3, 0.3, 1.0);\n    vec3 colScreen = vec3(1.0, 0.3, 0.3);\n\n    // waves:\n    \n    // linear wave on left, offset so peaks/troughs coincide with right\n    float rWaveHeight = sin((uv.x - center.x) * freq - t);  \n    \n    // inteference on the right\n    float lWaveHeight =  \n            sin(-t + distance(center + halfGapSize, uv) * freq) + \n            sin(-t + distance(center - halfGapSize, uv) * freq);\n\n    //vec3 col = // right and left sides of screen show different waves\n    //    ((uv.x < center.x) ? \n    //    vec3(rWaveHeight) :\n    //    vec3(lWaveHeight)) * 0.5 + 0.5;  // bring back to 0.0 -> 1.0 interval\n\n    vec3 col = // right and left sides of screen show different waves\n        vec3(mix(rWaveHeight, // smooth transition in center\n            lWaveHeight, \n            clamp((uv.x - center.x) * 20.0, 0.0, 1.0)) * 0.5 + 0.5);  // bring back to 0.0 -> 1.0 interval\n\n\n    // upper obstacle\n    drawSd(\n        sdSimpleRoundedBox(translate(uv, center + halfGapSize) - vec2(0.0, 0.3), vec2(0.01, 0.29), 0.01), \n        col, \n        colObstacle, \n        1.0, \n        aaTransitionWidth);\n\n    // lower obstacle\n    drawSd(\n        sdSimpleRoundedBox(translate(uv, center - halfGapSize) + vec2(0.0, 0.3), vec2(0.01, 0.29), 0.01), \n        col, \n        colObstacle, \n        1.0, \n        aaTransitionWidth);\n\n    // center obstacle\n    drawSd(\n        sdSimpleRoundedBox(translate(uv, center), vec2(0.01, halfGapSize.y - 0.02), 0.01), \n        col, \n        colObstacle, \n        1.0, \n        aaTransitionWidth);\n\n    // back projection screen\n    drawSd(\n        sdSimpleRoundedBox(translate(uv, vec2(center.x * 2.0 - 0.01, center.y)), vec2(0.01, 1.0), 0.01), \n        col, \n        colScreen, \n        clamp(iTime - animTimeToStop + 1.0, 0.0, 0.5), \n        aaTransitionWidth);\n\n    // arrow\n    float osc = sin(iTime * 4.0) * 0.05;\n    drawSd(\n        sdVector(rotate(translate(uv, vec2(center.x * 2.0 - 0.3, 0.7) + vec2(-osc, osc)), deg2rad(225.0)), 0.2, thickness, thickness * 0.5, vec2(0.02, 0.04)), \n        col, \n        colScreen, \n        clamp(iTime - animTimeToStop + 1.0, 0.0, 1.0), \n        aaTransitionWidth);\n    \n\n\n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}