{"ver":"0.1","info":{"id":"Mtsczj","date":"1510142246","viewed":314,"name":"Converging Lens","username":"Ultraviolet","description":"Model of a converging lens, including multiple intra-reflections.\nMouse X controls glass refraction index, Y controls absorbance (useful for identifying intra-reflections).","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["reflection","raycasting","refraction","lens"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define GAMMA 2.2\n\n#define MAX_DEPTH 5\n\nconst float width = .1;\nconst float s1Rad = 5.0;\nvec3 s1Pos = vec3( s1Rad*cos(asin(1.0/s1Rad)) - .5*width, 0.0, 0.0);\nconst float s2Rad = 2.0;\nvec3 s2Pos = vec3(-s2Rad*cos(asin(1.0/s2Rad)) + .5*width, 0.0, 0.0);\n\nvec3 glassColor = vec3(147.0,112.0,219.0)/255.0;\n\nvec3 doGamma(vec3 col)\n{\n    return pow(col, vec3(1.0/GAMMA));\n}\n\nvec3 undoGamma(vec3 col)\n{\n    return pow(col, vec3(GAMMA));\n}\n\nvec3 getWorld(vec3 dir)\n{\n    return undoGamma(texture(iChannel0, dir).rgb);\n}\n\n// see: https://en.wikipedia.org/wiki/Fresnel_equations\nfloat fresnel(vec3 i, vec3 r, vec3 n, float eta1, float eta2)\n{\n    float a0 = eta2 * dot(-i, n);\n    float a1 = eta1 * dot(r, -n);\n    float Rs = (a0-a1)/(a0+a1);\n    Rs = Rs*Rs;\n    \n    float b0 = eta2 * dot(r, -n);\n    float b1 = eta1 * dot(-i, n);\n    float Rp = (b0-b1)/(b0+b1);\n    Rp = Rp*Rp;\n    \n    float R = 0.5*(Rs+Rp);\n    \n    //return Rs;\n    return Rp;\n    //return R;\n}\n\n\n\nbool interSphere(vec3 ro, vec3 rd, vec3 c, float r, out vec2 inter)\n{    \n    float delta;\n    \n    delta = pow(dot(rd, ro) - dot(c,rd), 2.0) - (dot(c, c)+dot(ro,ro)-2.*dot(c, ro)-r*r);\n    \n    if(delta < 0.0)\n    {\n        inter = vec2(1.0, -1.0);\n    \treturn false;\n    }\n    delta = sqrt(delta);\n    inter.x = dot(c, rd) - dot(rd, ro) - delta;\n    inter.y = inter.x + 2.0*delta;\n    return true;\n}\n\nbool interCylindre(vec3 ro, vec3 rd, vec3 o, vec3 d, float r, out vec2 inter)\n{\n    vec3 A = rd - d*dot(rd,d)/dot(d,d);\n    vec3 B = ro - o - d*dot(ro-o,d)/dot(d,d);\n    \n    float delta = dot(A,B)*dot(A,B) - dot(A,A)*(dot(B,B)-r*r);\n    \n    if(delta<0.0)\n    {\n        inter = vec2(1.0, -1.0);\n    \treturn false;\n    }\n    delta = sqrt(delta);\n    inter.x = (-dot(A,B)-delta)/dot(A,A);\n    inter.y = (-dot(A,B)+delta)/dot(A,A);\n    \n    vec2 temp = vec2(min(inter.x, inter.y), max(inter.x, inter.y));\n    inter = temp;\n    return true;\n}\n\nbool intervInter(in vec2 inter1, in vec2 inter2, out vec2 inter)\n{\n    inter.x = max(inter1.x, inter2.x);\n    inter.y = min(inter1.y, inter2.y);\n    \n    return inter.x < inter.y;\n}\n\nbool getRayIntersection(vec3 ro, vec3 rd, out vec3 inter, out vec3 norm)\n{\n    vec2 interv1, interv2, interv3;\n    interSphere(ro, rd, s1Pos, s1Rad, interv1);\n    interSphere(ro, rd, s2Pos, s2Rad, interv2);\n    interCylindre(ro, rd, vec3(0.0), vec3(1.0, 0.0, 0.0), 1.0, interv3);\n    vec2 interv;\n    if(!intervInter(interv1, interv2, interv))\n        return false;\n    if(!intervInter(interv, interv3, interv))\n        return false;\n    \n    float t = interv.x >0.0? interv.x:interv.y;\n    \n    if (t < 0.0)\n        return false;\n    \n    inter = ro + t*rd;\n    \n    /*\n    if(min(abs(t-interv1.x), abs(t-interv1.y)) < min(abs(t-interv2.x), abs(t-interv2.y)))\n    \tnorm = normalize(inter-s1Pos);\n    else\n    \tnorm = normalize(inter-s2Pos);\n\t/*/\n    if(inter.x > width*.5)\n        norm = normalize(inter-s2Pos);\n    else if(inter.x < -width*.5)\n        norm = normalize(inter-s1Pos);\n    else\n        norm = normalize(vec3(0.0, inter.yz));\n    //*/\n    \n    return true;\n}\nvec3 getRayDirection(vec2 screenPosition, vec3 origin, vec3 lookingAt, vec3 up, float fov)\n{\n    vec3 d = normalize(lookingAt - origin);\n    vec3 right = normalize(cross(d, up));\n    \n    return normalize(screenPosition.x * right + screenPosition.y * up + 1.0 / tan(radians(fov / 2.0)) * d);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    float freq = 0.15;\n    vec3 cameraPosition = 1.5 * vec3(cos(iTime*freq), 0.0, sin(iTime*freq));\n    vec3 cameraUp = vec3(0.0, 1.0, 0.0);\n    vec3 cameraLookingAt = vec3(0.0);\n    \n    vec3 color = vec3(0.0);\n    \n    float aa_level = 3.0;\n    float numRays = aa_level*aa_level;\n    \n    \n    float absorbtion = iMouse.y/iResolution.y;\n    float eta1 = 1.0;\n    float eta2 = 3.0*iMouse.x/iResolution.x;\n    //eta2 = 1.5;\n    \n    if(iMouse.y < 1.0)\n        absorbtion = 0.2;\n    if(iMouse.x < 1.0)\n        eta2 = 1.5;\n    \n    for (float i = 0.0; i < numRays; i++)\n    {\n        vec2 aa = vec2(i/aa_level, mod(i, aa_level))/aa_level;\n        \n\t\tvec2 position = (2.0 * (fragCoord + aa) - iResolution.xy) / iResolution.y;\n        \n        vec3 rayOrigin = cameraPosition;\n        vec3 rayDirection = getRayDirection(position, cameraPosition, cameraLookingAt, cameraUp, 90.0);\n        \n        vec3 v;\n        \n        vec3 pt;\n        vec3 normal;\n        bool inter = getRayIntersection(rayOrigin, rayDirection, pt, normal);\n        \n        \n        if(inter)\n        {\n            vec3 reflection = reflect(rayDirection, normal);            \n            vec3 refraction = refract(rayDirection, normal, eta1 / eta2);\n            float f = fresnel(rayDirection, refraction, normal, eta1, eta2);\n            //f = 1.0;\n\n        \tvec3 pt2;\n            \n            v = getWorld(reflection) * f;\n            f = 1.0-f;\n            \n            vec3 org = refraction;\n            vec3 dst;\n            vec3 nrm;\n            float l = 0.0;\n            for(int kk=0; kk<50; ++kk)\n            {\n                if(f < 0.01)\n                    break;\n                \n                getRayIntersection(pt + org*0.0001, org, pt2, nrm);\n                \n                dst = refract(org, -nrm, eta2 / eta1);\n                l += length(pt2-pt);\n                \n                float ff = fresnel(org, dst, -nrm, eta2, eta1);\n                v += f*(1.0-ff) * mix(getWorld(dst), glassColor, 1.0-exp(-absorbtion * l));\n                f *= ff;\n                \n                org = reflect(org, -nrm);\n                pt = pt2;\n            }\n        }\n        else\n        {\n        \tv = getWorld(rayDirection);\n        }\n        \n        color += v / numRays;\n    }\n    \n    fragColor = vec4(doGamma(color), 1.0);\n}","name":"Image","description":"","type":"image"}]}