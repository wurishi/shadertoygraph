{"ver":"0.1","info":{"id":"7l2XD1","date":"1627934482","viewed":210,"name":"Camera to hexagons","username":"TambakoJaguar","description":"An alternative version to my previous shader (https://www.shadertoy.com/view/stSSWz) which is a kind of special screen mirroring the camera picture with flipping RGB hexagons! Use the mouse to zoom and move horizontally!","likes":5,"published":1,"flags":2,"usePreview":0,"tags":["camera","hexagons"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sf3zn","filepath":"/presets/webcam.png","previewfilepath":"/presets/webcam.png","type":"webcam","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n\"Camera to hexagons\" by Emmanuel Keller aka Tambako - July 2021\nLicense Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\nContact: tamby@tambako.ch\n*/\n\n// Switches, you can play with them!\n#define specular\n#define border\n#define specrot\n#define antialias\n\n\n#define pi 3.14159265359\n\n// Antialias. Change from 1 to 2 or more AT YOUR OWN RISK! It may CRASH your browser while compiling!\nconst float aawidth = 0.9;\nconst int aasamples = 3;\n\n// Ambient light\nconst vec3 ambientColor = vec3(0.8, 0.9, 1.);\nconst float ambientint = 0.07;\n\n// Specular options\nconst float specint = 0.16;\nconst float specshin = 250.;\n\n// Tracing options\nconst float normdelta = 0.03;\nconst float maxdist = 8000.;\n\n// Geometry options\nconst float bg_height = 0.07;\nconst float hex_height = 0.06;\nconst float bg_width = 0.08;\nconst float gap_width = 0.055;\nconst float borderpos = 0.22;\nconst float borderwidth = 0.07;\nconst float borderheight = 0.2;\n\nconst float imagescale = 800.;\n\nconst float gen_scale = 0.15;\n\n// Color options\nconst float gamma = 1.3;\nconst vec3 sky_color = vec3(0.);\nconst vec3 background_color = vec3(0.07, 0.08, 0.09);\n\n// Campera options\nvec3 campos;\nvec3 camtarget;\nvec3 camdir;\nfloat fov = 13.;\n\nfloat imaspect = 2.;\n\nstruct DirLamp\n{\n  vec3 direction;\n  vec3 color;\n  float intensity;\n};\n\nstruct RenderData\n{\n  \tvec3 col;\n  \tvec3 pos;\n  \tvec3 norm;\n  \tint objnr;\n};\n\nvec3 colors[3];\n   \n// Every object of the scene has its ID\n#define SKY_OBJ         0\n#define BACKGROUND_OBJ  1\n#define HEXAGONS_OBJ    2\n    \nDirLamp lamps[1];\n\nint aai;\nint aaj;\n\nfloat curtime;\n\nvoid init()\n{    \n    lamps[0] = DirLamp(vec3(0.01, 1., 0.02), vec3(1., 1., 1.), 3.5);\n    //lamps[1] = DirLamp(vec3(2., 3., -4.), vec3(1., 1., 1.), 1.3);\n    //lamps[2] = DirLamp(vec3(2., -1., 4.), vec3(0.65, 0.72, 1.), 1.2);\n    \n    curtime = iTime;    \n}\n\n// Union operation from iq\nvec2 opU(vec2 d1, vec2 d2)\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nvec2 rotateVec(vec2 vect, float angle)\n{\n    vec2 rv;\n    rv.x = vect.x*cos(angle) - vect.y*sin(angle);\n    rv.y = vect.x*sin(angle) + vect.y*cos(angle);\n    return rv;\n}\n\n// (2d cell id, distance to border, distance to center)\nvec4 hexagon(vec2 p) \n{\n\tvec2 q = vec2(p.x*2.0*0.5773503, p.y + p.x*0.5773503);\n\t\n\tvec2 ppi = floor(q);\n\tvec2 pf = fract(q);\n\n\tfloat v = mod(ppi.x + ppi.y, 3.0);\n\n\tfloat ca = step(1.0,v);\n\tfloat cb = step(2.0,v);\n\tvec2  ma = step(pf.xy,pf.yx);\n\t\n    // distance to borders\n\tfloat e = dot( ma, 1.0-pf.yx + ca*(pf.x+pf.y-1.0) + cb*(pf.yx-2.0*pf.xy) );\n\n\t// distance to center\t\n\tp = vec2( q.x + floor(0.5+p.y/1.5), 4.0*p.y/3.0 )*0.5 + 0.5;\n\tfloat f = length( (fract(p) - 0.5)*vec2(1.0,0.85) );\t\t\n\t\n\treturn vec4(ppi + ca - cb*ma, e, f);\n}\n\nfloat getAngle(vec4 h)\n{\n    int colnr = int(mod(h.x, 3.));\n    vec2 impos0;\n\n    vec2 impos = 0.85*vec2(-h.x, imaspect*(0.5*h.x - h.y))/imagescale + vec2(0.5, 0.5);\n    \n    vec3 camcol = texture(iChannel0, impos).rgb;\n    //vec3 camcol = vec3 (1., 0.8, 0.6);\n    float angle;\n    if (colnr==0) angle = 0.5*pi*(1. - clamp(1.1*pow(camcol.r, 1.7), 0., 1.));\n    if (colnr==1) angle = 0.5*pi*(1. - clamp(1.1*pow(camcol.g, 1.2), 0., 1.));\n    if (colnr==2) angle = 0.5*pi*(1. - clamp(1.1*pow(camcol.b, 1.4), 0., 1.));\n\n    return angle;\n}\n\nfloat map_background(vec3 pos)\n{\n   vec4 h = hexagon(pos.xz);\n   \n   float bg = max(abs(pos.x)>0.5*imagescale || abs(pos.z)>0.285*imagescale?0.:h.z - bg_width/2., abs(pos.y) - bg_height/2.);\n   bg = max(bg, abs(pos.x) - 0.505*imagescale);\n   bg = max(bg, abs(pos.z) - 0.29*imagescale);\n   \n   return bg;\n}\n\nfloat map_hexagons(vec3 pos)\n{\n   vec3 pos0 = pos;\n   \n   vec4 h0 = hexagon(pos.xz);\n   \n   #ifdef specrot\n   float colnr = mod(h0.x, 3.);\n   pos.xz = rotateVec(pos.xz, colnr*pi/3.);\n   vec4 h = hexagon(pos.xz);\n   #else\n   vec4 h = h0;\n   #endif\n   \n   float lpx = pos.x - h.x*0.866025;\n   float lpz = pos.z - h.y*1.5;\n   vec3 pos2 = vec3(lpx, pos.y, lpz);\n   \n   float angle = getAngle(h0); \n   pos2.xy = rotateVec(pos2.xy, angle);\n   vec4 h2 = hexagon(vec2(pos2.x, pos.z - h.x*1.5));\n   \n   #ifdef border\n   float borderhf = (1. - borderheight*smoothstep(borderpos, borderpos + borderwidth, h2.z))*(1. - 1.2*smoothstep(0.14, 0.115, h2.z)); \n   #else\n   float borderhf = 1.;\n   #endif\n   \n   float hex = max(-h2.z + bg_width/2. + gap_width, abs(pos2.y) - hex_height/2.*borderhf);\n   hex = h2.x==0.?hex:1000.;\n   hex = max(hex, abs(pos0.x) - 0.5*imagescale);\n   hex = max(hex, abs(pos0.z) - 0.285*imagescale);\n   \n   return hex;\n}\n\nvec2 map(vec3 pos)\n{\n    float background = map_background(gen_scale*pos);\n    vec2 res = vec2(background, BACKGROUND_OBJ);\n    \n    float hexagons = map_hexagons(gen_scale*pos);\n    res = opU(res, vec2(hexagons, HEXAGONS_OBJ)); \n    \n    return res;\n}\n\n// Main tracing function\nvec2 trace(vec3 cam, vec3 ray, float maxdist) \n{\n    float t = campos.y - 5.;\n    float objnr = 0.;\n    vec3 pos;\n    float dist;\n    \n  \tfor (int i = 0; i < 180; ++i)\n    {\n    \tpos = ray*t + cam;\n        vec2 res = map(pos);\n        dist = res.x;\n        if (dist>maxdist || cam.y<2.)\n            break;\n        t+= dist*1.8;\n        objnr = abs(res.y);\n  \t}\n  \treturn vec2(t, objnr);\n}\n\nvec3 getNormal(vec3 pos, float e)\n{  \n    vec3 n = vec3(0.0);\n    for( int i=0; i<4; i++ )\n    {\n        vec3 e2 = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e2*map(pos + e*e2).x;\n    }\n    return normalize(n);\n}\n\n// Gets the color of the sky\nvec3 getSkyColor(vec3 ray)\n{ \n    return sky_color;\n}\n\nvec3 getHexagonColor(vec4 h, vec3 pos)\n{\n    colors[0] = vec3(0.85, 0., 0.);\n    colors[1] = vec3(0., 0.7, 0.);\n    colors[2] = vec3(0.1, 0.12, 1.);\n    \n    int colnr = int(mod(h.x, 3.));\n    \n    float lpx = pos.x - h.x*0.866025;\n    float lpz = pos.z - h.x*1.5;\n    vec2 pos2 = vec2(lpx, pos.y);\n   \n    float angle = getAngle(h);\n    pos2 = rotateVec(pos2, angle);\n    vec4 h2 = hexagon(vec2(pos2.x, lpz));\n    \n    vec3 col = colors[colnr];\n    //col*= 1. - 1.2*smoothstep(0.2, 0.1, h2.z);\n    \n    return col;\n}\n\n// Combines the colors\nvec3 getColor(vec3 norm, vec3 pos, int objnr, vec3 ray)\n{\n   if (objnr==BACKGROUND_OBJ)\n      return background_color;\n   else if (objnr==HEXAGONS_OBJ)\n   {\n      vec4 hex = hexagon(gen_scale*pos.xz);\n      return getHexagonColor(hex, gen_scale*pos);\n   }\n   else\n      return getSkyColor(ray);\n}\n\n// Shading of the objects pro lamp\nvec3 lampShading(DirLamp lamp, vec3 norm, vec3 pos, vec3 ocol, int objnr, int lampnr)\n{\n\tvec3 pl = normalize(lamp.direction);\n      \n    // Diffuse shading\n    vec3 col = ocol*lamp.color*lamp.intensity*clamp(dot(norm, pl), 0., 1.);\n    \n    // Specular shading\n    #ifdef specular\n    if (dot(norm, lamp.direction) > 0.0)\n        col+= lamp.color*lamp.intensity*specint*pow(max(0.0, dot(reflect(pl, norm), normalize(pos - campos))), specshin);\n    #endif\n    \n    return col;\n}\n\n// Shading of the objects over all lamps\nvec3 lampsShading(vec3 norm, vec3 pos, vec3 ocol, int objnr)\n{\n    vec3 col = vec3(0.);\n    for (int l=0; l<lamps.length(); l++)\n        col+= lampShading(lamps[l], norm, pos, ocol, objnr, l);\n    \n    return col;\n}\n\n\n// From https://www.shadertoy.com/view/lsSXzD, modified\nvec3 GetCameraRayDir(vec2 vWindow, vec3 vCameraDir, float fov)\n{\n\tvec3 vForward = normalize(vCameraDir);\n\tvec3 vRight = normalize(cross(vec3(0.0, 1.0, 0.0), vForward));\n\tvec3 vUp = normalize(cross(vForward, vRight));\n    \n\tvec3 vDir = normalize(vWindow.x * vRight + vWindow.y * vUp + vForward * fov);\n\n\treturn vDir;\n}\n\n// Sets the position of the camera with the mouse and calculates its direction\nvoid setCamera()\n{\n   vec2 iMouse2;\n   \n   if (iMouse.x==0. && iMouse.y==0.)\n      iMouse2 = vec2(0.5, 1.);\n   else\n      iMouse2 = iMouse.xy/iResolution.xy;\n  \n   campos = vec3((1. - iMouse2.y)*0.86*(iMouse2.x - 0.5)*imagescale, (7. + pow(iMouse2.y, 2.5)*(imagescale - 7.))*fov/3.2,  0.)/gen_scale;\n   camdir = vec3(0., -1., -0.001);\n}\n\n// Tracing and rendering a ray\nRenderData trace0(vec3 tpos, vec3 ray, float maxdist)\n{\n    vec2 tr = trace(tpos, ray, maxdist);\n    float tx = tr.x;\n    int objnr = int(tr.y);\n    vec3 col;\n    vec3 pos = tpos + tx*ray;\n    vec3 norm;\n    \n    if (tx<maxdist)\n    {\n        norm = getNormal(pos, normdelta);\n        col = getColor(norm, pos, objnr, ray);\n      \n        // Shading\n        col = col*ambientColor*ambientint + lampsShading(norm, pos, col, objnr);\n    }\n    else\n    {\n        objnr = SKY_OBJ;\n        col = getSkyColor(ray);\n    }\n    col*= pow(smoothstep(maxdist, maxdist*0.3, tx), 0.5);\n    return RenderData(col, pos, norm, objnr);\n}\n\n// Main render function with reflections and refractions\nvec4 render(vec2 fragCoord)\n{   \n  \tvec2 uv = fragCoord.xy / iResolution.xy; \n  \tuv = uv*2.0 - 1.0;\n  \tuv.x*= iResolution.x / iResolution.y;\n    float fov2 = fov;\n    \n    #ifdef captmode\n    if (num_key>0)\n    {\n        fov2*= 3.;\n        uv.x+= 2.*(iResolution.x / iResolution.y)*(mod(float(num_key - 1), 3.) - 1.);\n        uv.y+= 2.*(float((num_key - 1)/3) - 1.);\n    }\n    #endif\n    \n  \tvec3 ray = GetCameraRayDir(uv, camdir, fov2);\n  \tRenderData traceinf = trace0(campos, ray, maxdist/gen_scale);\n  \tvec3 col = traceinf.col;\n    \n  \treturn vec4(pow(col, vec3(gamma)), 1.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{   \n    init();\n    setCamera();\n    \n    // Antialiasing\n    #ifdef antialias\n    vec4 vs = vec4(0.);\n    for (aaj=0;aaj<aasamples ;aaj++)\n    {\n       float oy = float(aaj)*aawidth/max(float(aasamples-1), 1.);\n       for (aai=0;aai<aasamples ;aai++)\n       {\n          float ox = float(aai)*aawidth/max(float(aasamples-1), 1.);\n          vs+= render(fragCoord + vec2(ox, oy));\n       }\n    }\n    fragColor = vs/vec4(aasamples*aasamples);\n    #else\n    fragColor = vec4(render(fragCoord));\n    #endif\n}","name":"Image","description":"","type":"image"}]}