{"ver":"0.1","info":{"id":"WdVyRz","date":"1602131976","viewed":111,"name":"Raytracing Engine Test","username":"Dominexis","description":"Finally got around to messing with 3D space! :D\n\nWASD controls your horizontal movement. Space makes you go up, X makes you go down, C makes you go faster. Arrow keys control the camera.","likes":2,"published":1,"flags":48,"usePreview":0,"tags":["3d","raytracing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sXGRn","filepath":"/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","previewfilepath":"/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float sphere( in vec3 sphere_pos, in float radius, in vec3 pos, in vec3 ray )\n{\n    // Initialize values\n    \n    float a = dot(ray-pos, ray-pos);\n    float b = 2.0*dot(pos-sphere_pos, ray-pos);\n    float c = dot(pos, pos) + dot(sphere_pos, sphere_pos) - 2.0*dot(pos, sphere_pos) - radius*radius;\n    \n    \n    \n    // Compute distance\n    \n    float dist = 10000.0;\n    if( b*b - 4.0*a*c >= 0.0 )\n    {\n    \tfloat dist_1 = ( -b + sqrt(b*b - 4.0*a*c) )/2.0*a;\n        float dist_2 = ( -b - sqrt(b*b - 4.0*a*c) )/2.0*a;\n        dist_1 = step(0.01, dist_1)*dist_1 + step(dist_1, 0.01)*10000.0;\n        dist_2 = step(0.01, dist_2)*dist_2 + step(dist_2, 0.01)*10000.0;\n        dist = min(dist_1, dist_2);\n    }\n    \n    return dist;\n}\n\n\n\nfloat plane( in vec4 plane, in vec3 pos, in vec3 ray )\n{\n\t// Compute distance\n    \n    float dist = -(dot(plane.xyz, pos) + plane.w)/dot(plane.xyz, ray-pos);\n    return step(0.01, dist)*dist + step(dist, 0.01)*10000.0;\n}\n\n\n\nfloat checker( in vec2 pos )\n{\n\treturn mod(floor(pos.x) + floor(pos.y),2.0);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Initialize values\n    \n    vec2 uv = ( 2.0*fragCoord.xy - iResolution.xy )*vec2(-1.0, 1.0)/iResolution.y;\n    vec3 pos = texture(iChannel0, vec2(0.0, 0.0)).xyz;\n    vec2 angle = texture(iChannel0, vec2(10.0/iResolution.x, 0.0)).xy;\n    \n    \n    \n    // Calculate ray\n    \n    float fov = 0.8;\n    vec3 ray = vec3(\n    \tcos(angle.x)*cos(angle.y) - sin(angle.x)*uv.x*fov - cos(angle.x)*sin(angle.y)*uv.y*fov,\n        sin(angle.x)*cos(angle.y) + cos(angle.x)*uv.x*fov - sin(angle.x)*sin(angle.y)*uv.y*fov,\n        sin(angle.y) + cos(angle.y)*uv.y*fov );\n    ray = ray/length(ray) + pos;\n    \n    \n    \n    // Sphere 1\n    \n    vec3 sphere_pos_1 = vec3( 2.0, 0.0, 0.1 );\n    float sphere_radius_1 = 1.0;\n    float sphere_dist_1 = sphere( sphere_pos_1, sphere_radius_1, pos, ray );\n    vec3 sphere_color_1 = ((ray-pos)*sphere_dist_1 + pos - sphere_pos_1 + 1.0)/2.0;\n    \n    // Sphere 2\n    \n    vec3 sphere_pos_2 = vec3( 0.0, 0.0, 5.0 );\n    float sphere_radius_2 = 2.0;\n    float sphere_dist_2 = sphere( sphere_pos_2, sphere_radius_2, pos, ray );\n    vec3 sphere_color_2 = (ray-pos)*sphere_dist_2 + pos - sphere_pos_2;\n    sphere_color_2 = texture(iChannel1, vec2( atan(sphere_color_2.y,sphere_color_2.x)/6.2831, atan(sphere_color_2.z,length(sphere_color_2.xy))/3.1415 + 1.5707 )).xyz;\n    \n    // Plane\n    \n    float plane_dist = plane( vec4( 0.0, 0.0, 1.0, 1.0 ), pos, ray );\n    vec3 plane_color = (checker( (ray.xy-pos.xy)*plane_dist + pos.xy )+2.0)*vec3( 0.0, 1.0, 0.0 )/4.0;\n    \n    // Sky\n    \n    float sky_dist = 1000.0;\n    vec3 sky_color = vec3( 0.52, 0.8, 0.92 );\n    \n    \n    \n    // Get minimum distance\n    \n    float dist =\n        min(sky_dist,\n        min(sphere_dist_2,\n        min(sphere_dist_1, plane_dist)));\n    \n    sky_dist = (1.0 - step(sky_dist, dist))*sky_dist;\n    \n    // Assign pixel\n    \n    fragColor = vec4(\n          step(sphere_dist_1, dist)*sphere_color_1\n        + step(sphere_dist_2, dist)*sphere_color_2\n        + step(plane_dist, dist)*plane_color\n        + step(sky_dist, dist)*sky_color, 1.0 );\n    \n    \n    \n    // Sun\n    \n    vec3 sun = vec3( cos(iTime*0.1), 0.0, sin(iTime*0.1) );\n    sun /= length(sun);\n    vec3 sun_color = step(sky_dist, dist)*vec3(\n        step(0.999, dot(ray-pos, sun)),\n        step(0.999, dot(ray-pos, sun)),\n        step(0.999, dot(ray-pos, sun)));\n    \n    // Compute exposure vector\n    \n    pos = (ray-pos)*dist + pos;\n    vec3 exposure =\n          step(sphere_dist_1, dist)*(pos-sphere_pos_1)\n        + step(sphere_dist_2, dist)*(pos-sphere_pos_2)\n        + step(plane_dist, dist)*vec3(0.0, 0.0, 1.0)\n        + step(sky_dist, dist)*vec3(sun.xy*0.25, 0.75+sun.z*0.25);\n    exposure /= length(exposure);\n    \n    \n    \n    // Find obstruction for shadow\n    \n    ray = pos+sun;\n    \n    sphere_dist_1 = sphere( sphere_pos_1, sphere_radius_1, pos, ray );\n    sphere_dist_2 = sphere( sphere_pos_2, sphere_radius_2, pos, ray );\n    plane_dist = plane( vec4( 0.0, 0.0, 1.0, 1.0 ), pos, ray );\n    \n    // Get minimum distance\n    \n    dist =\n        min(sky_dist,\n        min(sphere_dist_2,\n        min(sphere_dist_1, plane_dist)));\n    \n    \n    \n    // Compute light\n    \n    float light = max( dot(exposure, sun), 0.0 )*step(sky_dist, dist)*0.85 + 0.15;\n    fragColor.xyz = fragColor.xyz*light + sun_color;\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Initialize values\n    \n    vec3 pos = texture(iChannel0, vec2(0.0, 0.0)).xyz;\n    vec2 angle = texture(iChannel0, vec2(10.0/iResolution.x, 0.0)).xy;\n    \n    float pos_speed = 0.04;\n    float angle_speed = 0.04;\n    \n    \n    \n    // Apply angle offset\n    \n    vec2 angle_offset = vec2(\n    \ttexture( iChannel1, vec2( 37.0/256.0, 0.0 ) ).x\n      - texture( iChannel1, vec2( 39.0/256.0, 0.0 ) ).x,\n        texture( iChannel1, vec2( 38.0/256.0, 0.0 ) ).x\n      - texture( iChannel1, vec2( 40.0/256.0, 0.0 ) ).x);\n    \n    angle_offset /= length(angle_offset) + step( length(angle_offset), 0.5 );\n    angle += angle_offset*angle_speed;\n    angle.y = clamp( angle.y, -1.5707, 1.5707 );\n    \n    \n    \n    // Apply position offset\n    \n    vec3 pos_offset = vec3( \n        texture( iChannel1, vec2( 87.0/256.0, 0.0 ) ).x\n      - texture( iChannel1, vec2( 83.0/256.0, 0.0 ) ).x, \n        texture( iChannel1, vec2( 68.0/256.0, 0.0 ) ).x\n      - texture( iChannel1, vec2( 65.0/256.0, 0.0 ) ).x,\n        texture( iChannel1, vec2( 32.0/256.0, 0.0 ) ).x\n      - texture( iChannel1, vec2( 88.0/256.0, 0.0 ) ).x);\n    \n    pos_offset /= length(pos_offset) + step( length(pos_offset), 0.5 );\n    \n    pos_offset = vec3(\n        cos(angle.x)*pos_offset.x + sin(angle.x)*pos_offset.y,\n        sin(angle.x)*pos_offset.x - cos(angle.x)*pos_offset.y,\n        pos_offset.z );\n    pos += pos_offset*pos_speed*(texture( iChannel1, vec2( 67.0/256.0, 1.0 ) ).x*7.0 + 1.0);\n    \n    \n    \n    // Write to buffer\n    \n    fragColor = vec4( step(fragCoord.x, 5.0)*pos + step(5.0, fragCoord.x)*vec3(angle, 0.0), 1.0 );\n}","name":"Buffer A","description":"","type":"buffer"}]}