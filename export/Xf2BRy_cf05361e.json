{"ver":"0.1","info":{"id":"Xf2BRy","date":"1725118248","viewed":19,"name":"basic diffuse lighting","username":"dragonmuffin","description":"basic diffuse lighting","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["3d"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const int MAX_STEPS = 50;\nconst float FAR = 300.;\nconst float EPS = 0.001;\nconst vec3 CAM_POS = vec3(0.);\n//const vec3 LIGHT_POS = vec3(2., 0., 0.);\n\nfloat SphereSdf(in vec3 center, in float radius, in vec3 crd) {\n    return length(crd-center)-radius;\n}\n\nfloat SceneSdf(in vec3 crd) {\n    return SphereSdf(vec3(0.,1.,0.), .1, crd);\n}\n\nvec3 calc_norm(in vec3 p) {\n    const float eps = 0.001;\n    const vec2 h = vec2(eps,0);\n    return normalize(vec3(SceneSdf(p+h.xyy)-SceneSdf(p-h.xyy),\n                          SceneSdf(p+h.yxy)-SceneSdf(p-h.yxy),\n                          SceneSdf(p+h.yyx)-SceneSdf(p-h.yyx)));\n}\n\nfloat RayMarch(in vec3 start, in vec3 orientation) {\n    vec3 pos = start;\n    float dist;\n    float depth = 0.;\n    for(int i=0;i<MAX_STEPS;i++) {\n        dist = SceneSdf(pos);\n        if(dist<EPS || depth>FAR) {\n            break;\n        }\n        depth += dist;\n        pos = start + orientation * depth;\n    }\n    return depth;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec3 LIGHT_POS = vec3(3.*sin(iTime*3.),3.*cos(iTime*3.),0.);\n    vec2 uv = fragCoord/iResolution.xy-0.5;\n    uv.x *= iResolution.x/iResolution.y;\n    vec3 orientation = normalize(vec3(uv.x,1.,uv.y));\n    float dpt = RayMarch(CAM_POS,orientation);\n    if(dpt>FAR) {\n        fragColor = vec4(0.,0.,0.,1.);\n        return;\n    }\n    vec3 pos = CAM_POS + orientation * dpt;\n    vec3 norm = calc_norm(pos);\n    vec3 lo = normalize(LIGHT_POS - pos); // light orientation\n    vec3 col = vec3(dot(norm,lo));\n    fragColor = vec4(col,1.);\n}\n\n","name":"Image","description":"","type":"image"}]}