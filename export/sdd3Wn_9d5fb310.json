{"ver":"0.1","info":{"id":"sdd3Wn","date":"1629593696","viewed":72,"name":"Rational number error","username":"sgi2000","description":"From left to right is a number axis ranging from 0.0 to 0.5.\nBy colour and filled graph is a visualization of error of how this number can be approximated by a rational number, whose denominator is less-equal than  N. N can be changed by mouse click.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["math","number","graph","rationalnumber"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// DESCRIPTION\n// Important note. Function Fun doesn't calculate\n// absolute error of approximation by rational number,\n// but rather an error relative to a step 1/q.\n\n\n// Function we visualize.\n// For given x returns the distance to the closest\n// rational number with denominator not greater than N.\nfloat Fun(float x, int N)\n{\n    float yMin = 1.f;\n    for (int i = 1; i <= N; i++) {\n        float y = abs(x * float(i) - floor(x * float(i) + 0.5f));\n        yMin = min(yMin, y);\n    }\n    return yMin;\n}\n\n\n// coordMin and coordMax define a rectangle cell.\n// funLeft and funRight are function values at left and right border of this rectangle.\n// Returns a part of the cell that is below a function, which is approximated as a segment.\nfloat EvalCell(vec2 coordMin, vec2 coordMax, float funLeft, float funRight)\n{\n    float y0 = (funLeft - coordMin.y) / (coordMax.y - coordMin.y);\n    float y1 = (funRight - coordMin.y) / (coordMax.y - coordMin.y);\n    float yMin = min(y0, y1);\n    float yMax = max(y0, y1);\n    \n    float w = 0.5f;\n    if (yMax < 0.f) {\n       w = 0.f;// function lies fully below the cell\n    } else if (yMin > 1.f) {\n       w = 1.f;// function lies fully above the cell\n    } else {\n        w = 0.0f;\n        float a = max(0.f, yMin);\n        float b = min(1.f, yMax);\n        w += a;\n        w += 0.5f*(b-a)*(b-a)/(yMax-yMin);\n        w += (b-a)*(yMax-b)/(yMax-yMin);\n    }\n    return w;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    int N = int(iMouse.x * 100.f / iResolution.x + 1.f);\n    float xRange = 0.5;\n    // Since the more rational numbers you use, the less is the error, graph is scaled vertically by N.\n    // Note. This isn't obvious, since it is a relative error and is actually proven by a theorem.\n    float yRange = 1.0 / float(N);\n    vec2 pixelToCoord = vec2(xRange, yRange) / iResolution.xy;\n\n    // rectangle of a pixel\n    vec2 coordMin = (fragCoord - vec2(0.5)) * pixelToCoord;\n    vec2 coordMax = (fragCoord + vec2(0.5)) * pixelToCoord;\n\n    float w = 0.0f;\n    const float subStep = 0.01f;\n    float funLeft = Fun(coordMin.x, N);\n    float funAvg = funLeft;\n    // supersample cycle\n    for (float f = 0.0; f < 1.0f; f += subStep) {\n        vec2 subCoordMin, subCoordMax;\n        subCoordMin.y = coordMin.y;\n        subCoordMax.y = coordMax.y;\n        subCoordMin.x = coordMin.x + f * (coordMax.x - coordMin.x);\n        subCoordMax.x = coordMin.x + (f + subStep) * (coordMax.x - coordMin.x);\n        float funRight = Fun(subCoordMax.x, N);\n        w += EvalCell(subCoordMin, subCoordMax, funLeft, funRight) * subStep;\n        funLeft = funRight;\n        funAvg += funLeft;\n    }\n    funAvg *= subStep * float(N);\n\n    float intensity = funAvg;\n    vec3 col = mix(vec3(0), vec3(1) * intensity, w);\n\n    // gamma correction\n    col = pow(col,vec3(1.f/2.2f));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}