{"ver":"0.1","info":{"id":"ltt3WB","date":"1471428012","viewed":397,"name":"Golden Menger Sponge Ray-Tracer","username":"pixartist","description":"- Move via WASD & Mouse look (Hold LMB to use mouse look)\n- Switches to Simple drawing mode during movment\n- Starts raytracing when not moving","likes":7,"published":1,"flags":48,"usePreview":0,"tags":["fractal","raytracer","ray","menger","pathtracer","sponge","tracer","path","controls","freelook"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec4 col = texture(iChannel0, uv);\n\tfragColor = vec4(col.rgb / col.a, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"const float lightBrightness = 24.0; \nconst float lightSize = 0.5;\nconst float mengerIterations = 6.0;\nconst float lightBounces = 9.0;\n\n\n\n\n//seed for random algorithm\nuvec3 seed;\nconst float steps = 600.0;\nconst float minStep = 0.0001;\nconst float nrmStep = 0.0001;\nfloat jitter;\n//enables reflective mode..\n#define reflective\n//global uv coordinate\nvec2 uv;\n//helper for RNG\n#define uv2 uv+vec2(72.12, -12.423457)*mod(iTime, 23.12639)\n\n//mmmhh PIE\nconst float PI = 3.14159265359;\n\n\n//ray struct\nstruct Ray\n{\n    vec3 o;\n    vec3 d;\n};\nstruct Res\n{\n    float iter;\n    vec4 val;\n    vec3 lastRes;\n    bool maxIter;\n   \n};\nstruct Hit\n{\n    vec3 p;\n    float iter;\n    vec3 nrm;\n     float light;\n    bool failed;\n};\n//reads data from input buffer (for controls)\nvec4 readData(int x, int y)\n{\n    return texture(iChannel1, (vec2(x,y) + vec2(0.5)) / iResolution.xy);\n}\n\n//iq's int hash\nfloat hash( uint n ) \n{\n    // integer hash copied from Hugo Elias\n\tn = (n << 13U) ^ n;\n    n = n * (n * n * 15731U + 789221U) + 1376312589U;\n    \n    // floating point conversion from https://iquilezles.org/articles/sfrand\n    return uintBitsToFloat( (n>>9U) | 0x3f800000U ) - 1.0;\n}\n\nfloat rand() \n{ \n    float s = hash( seed.x + 1920U*seed.y + (1920U*1080U)*uint(iFrame) );\n    seed.y = seed.x;\n    seed.x = seed.z;\n    seed.z = uint(s * 1920.0);\n    return s;\n}\n//returns a random direction vector inside the hemisphere of the given normal\nvec3 rndDirHemisphere(vec3 n)\n{\n    float r2 = rand();\n    float phi = 2.0*PI*rand();\n    float sina = sqrt(r2);\n    float cosa = sqrt(1. - r2);\n    vec3 w = normalize(n), u = normalize(cross(w.yzx, w)), v = cross(w, u);\n\treturn (u*cos(phi) + v*sin(phi)) * sina + w * cosa;\n}\n//returns a random direction vector inside the hemisphere of the given normal mixed with the given normal by a factor\nvec3 weightedRndDirHemisphere(vec3 n, float randomness)\n{\n    return mix(n, rndDirHemisphere(n), randomness);\n}\n\nfloat sp(vec3 p, float sc, float s, vec3 sh)\n{\n    return length(sin((p+sh)/sc)) - s;\n}\nfloat smoothFract(float v)\n{\n    return smoothstep(0.0, 0.5, abs(fract(v) - 0.5));\n}\nvec3 nrmFract(vec3 v)\n{\n    return 2.0 * abs(fract(v)-0.5);\n}\nvec3 smoothFract(vec3 v)\n{\n    return smoothstep(0.0, 1.0, nrmFract(v));\n}\nfloat minMax(vec3 v)\n{\n    float k1 = max(v.x, v.y);\n    float k2 = max(v.y, v.z);\n    float k3 = max(v.z, v.x);\n\treturn min(k1, min(k2, k3));\n}\nfloat modScale(vec3 v, float s)\n{\n    v *= s;\n    v = abs(mod(v + 1.0, 2.0) - 1.0);\n\tfloat k = minMax(v);\n    return -(k-(1.0/3.0))/s;\n}\nRes fr(vec3 p)\n{\n    Res res;\n    res.maxIter = false;\n    res.iter = 0.0;\n    vec3 v = p*0.5;\n    float n = 1.0;\n    float am = 0.0;\n    float s = 1.0;\n    for(float i = 0.0; i < mengerIterations; i+=1.0)\n    {\n        am = max(am, modScale(v, s));\n        s*=3.0;\n    }\n    res.val.x = am;\n    return res;\n}\nvec3 nrm(vec3 p)\n{\n    vec3 s = vec3(nrmStep, 0.0, 0.0);\n    return normalize(vec3(\n        fr(p + s).val.x - fr(p-s).val.x,\n        fr(p + s.yxy).val.x - fr(p-s.yxy).val.x,\n        fr(p + s.yyx).val.x - fr(p-s.yyx).val.x));\n}\nHit map(Ray r)\n{\n    const float maxStep = 500.0;\n\tHit hit;\n    hit.iter = 0.0;\n    hit.p = vec3(0.0);\n    hit.nrm = vec3(0.0);\n    hit.light = 0.0;\n    hit.failed = true;\n    float d = 0.0;\n    Res res;\n    for(float i = 0.0; i < maxStep; i++)\n    {\n        vec3 p = r.o + r.d * d;\n        vec3 ll =(mod(p + 3.0, 4.0) - 3.0);\n        float sD = length(ll);\n        if(sD <= 0.0)\n            return hit;\n        vec3 sn = normalize(ll);\n        sD -= lightSize;\n\t\tif(sD < 0.0)\n        {\n            hit.iter = i / maxStep;\n            hit.p = p - r.d*d;\n            hit.nrm = sn;\n            hit.light = 1.0;\n            hit.failed = true;\n            return hit;\n        }\n        res = fr(p);\n        if(res.val.x < minStep)\n        {\n            hit.iter = i / maxStep;\n            hit.nrm = nrm(p);\n            hit.p = p + hit.nrm * 0.01;\n            hit.failed = false;\n            return hit;\n\n        }\n       \td += abs(min(res.val.x, sD / abs(dot(r.d, sn))));// * (1.0 + (i / maxStep) * 5.0);\n    }\n    return hit; \n}\nHit mapShort(Ray r)\n{\n    const float maxStep = 200.0;\n\tHit hit;\n    hit.iter = 0.0;\n    hit.p = vec3(0.0);\n    hit.nrm = vec3(0.0);\n    hit.light = 0.0;\n    hit.failed = true;\n    float d = 0.0;\n    Res res;\n    for(float i = 0.0; i < maxStep; i++)\n    {\n        vec3 p = r.o + r.d * d;\n        vec3 ll =(mod(p + 3.0, 4.0) - 3.0);\n        float sD = length(ll);\n        if(sD <= 0.0)\n            return hit;\n        vec3 sn = normalize(ll);\n        sD -= lightSize;\n\t\tif(sD < 0.0)\n        {\n            hit.iter = i / maxStep;\n            hit.p = p - r.d*d;\n            hit.nrm = sn;\n            hit.p = p + hit.nrm* 0.01;\n            hit.light = 1.0;\n            hit.failed = true;\n            return hit;\n        }\n        res = fr(p);\n        if(res.val.x < minStep)\n        {\n            hit.iter = i / maxStep;\n            \n            hit.nrm = nrm(p);\n            hit.p = p + hit.nrm * 0.01;\n            hit.failed = false;\n            return hit;\n\n        }\n       \td += abs(min(res.val.x, sD / abs(dot(r.d, sn))));// * (1.0 + (i / maxStep) * 5.0);\n    }\n    return hit;\n}\n//creates a view\nRay makeView(vec3 p, vec3 up, vec3 tgt)\n{\n    float f = iResolution.x / iResolution.y;\n    vec3 dir = normalize(tgt - p);\n    up = normalize(up);\n    vec3 right = cross(dir, up);\n    Ray res;\n    vec3 uv3 = right * (uv.x - 0.5) * f + up * (uv.y - 0.5);\n    res.o = (p + uv3) * 0.01;\n    res.d = dir + uv3 * 2.0;\n    res.d = normalize(weightedRndDirHemisphere(res.d, 0.002));\n    /*\n    float focalLength = 0.5;\n    float aperture = 0.00002;\n    Ray midRay;\n    midRay.o = p * 0.01;\n    midRay.d = dir;\n    Hit h = map(midRay);\n    float d = length(h.p);\n   // if(d < 20.0)\n    {\n        focalLength = d*0.01;\n        //aperture /= 1.0 / (1.0 + d);\n    }\n    \n    \n     //Focal Point\n    vec3 focalPoint  = res.d * focalLength;\n    \n    //Pick random point on Aperture\n    float randomAngle       = rand() * PI * 2.0;\n    float randomRadius      = pow(rand(), 1.0) * aperture;\n    vec3  randomAperturePos = (cos(randomAngle)*right+sin(randomAngle)*up)*sqrt(randomRadius);\n    \n    //Point on Aperture to Focal Point\n    res.d = normalize(focalPoint-randomAperturePos);\n    res.o += randomAperturePos;\n    \n   */\n    \n    return res;\n}\n//init is called at the start (after uv was set)\nvoid init(vec2 fragCoord)\n{\n    uvec2 p = uvec2(fragCoord);\n    seed = uvec3(p.x, p.y, 0U);\n    jitter = 3.0/iResolution.x;\n}\n//main\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    uv = fragCoord.xy / iResolution.xy;\n    vec4 self = texture(iChannel0, uv);\n\tinit(fragCoord);\n    vec4 pos = readData(0,0);\n    vec4 fw = readData(0,1);\n    if(pos.a > 0.0 || fw.a > 0.0)\n    {\n        jitter = 0.0;\n        self = vec4(0.0);\n    }\n    vec3 up = cross(fw.xyz, -cross(fw.xyz, vec3(0.0, 1.0, 0.0)));\n    Ray v = makeView(\n        pos.xyz,\n        up,\n        pos.xyz + fw.xyz\n    );\n    \n    //RAYTRACE HERE\n    Hit h;\n    const float dif = .06;\n    vec3 color = vec3(0.0);\n    float m = 1.0;\n\t#ifdef reflective\n    for(float i = 0.0; i < lightBounces; i++) \n    {\n        if(i < 1.0)\n        {\n            h = map(v);\n            color = mix(color, vec3(h.light * lightBrightness), m);\n        }\n        else \n        {\n            h = mapShort(v);\n            color = mix(color, vec3(h.light * lightBrightness, h.light * lightBrightness*0.75, h.light * lightBrightness*0.2), m);\n        }\n        \n        if(pos.a > 0.0 || fw.a > 0.0)\n        {\n            color = vec3(h.iter * 5.0, 0.5 * dot(normalize(vec3(1.0)), h.nrm) + 0.5,  0.5 * dot(-v.d, h.nrm) + 0.5);\n            break;\n        } \n        if(h.light > 0.0 || h.failed)\n            break;\n        v.o = h.p;\n        v.d = normalize(weightedRndDirHemisphere(reflect(v.d, h.nrm),  dif));\n\n\n        m *= 0.8;\n\n    }\n    #else\n    for(float i = 0.0; i < 3.0; i++) \n    {\n        if(i < 1.0)\n        {\n            h = map(v);\n            color = mix(color, vec3(h.light * lightBrightness), m);\n        }\n        else\n        {\n            h = mapShort(v);\n            color = mix(color, vec3(h.light * lightBrightness, h.light * lightBrightness*0.75, h.light * lightBrightness*0.2), m);\n        }\n        \n        if(pos.a > 0.0 || fw.a > 0.0)\n        {\n            color = h.nrm;\n            break;\n        }\n        if(h.light > 0.0 || h.failed)\n            break;\n        v.o = h.p;\n        v.d = weightedRndDirHemisphere(reflect(v.d, h.nrm),  1.0);\n\n\n        m *= 0.8;\n\n    }\n    #endif\n    \n    \n    //float light = (1.0 + dot(normalize(vec3(1.0, 1.0, 1.0)), h.nrm)) * 0.5;\n    //float cam = (1.0 + dot(v.d, h.nrm)) * 0.5;\n    //vec3 color = vec3(light, cam, 0.0);\n    fragColor = self + vec4(color , 1.0);\n}","name":"Buf A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"//This program is for controls / keyboard and mouse input\nconst float PI = 3.14159265359;\nconst float speed = 1.5;\nint kA=65,kB=66,kC=67,kD=68,kE=69,kF=70,kG=71,kH=72,kI=73,kJ=74,kK=75,kL=76,kM=77,kN=78,kO=79,kP=80,kQ=81,kR=82,kS=83,kT=84,kU=85,kV=86,kW=87,kX=88,kY=89,kZ=90;\nint k0=48,k1=49,k2=50,k3=51,k4=52,k5=53,k6=54,k7=55,k8=56,k9=57;\nint kSpace=32,kLeft=37,kUp=38,kRight=39,kDown=40,kCtrl=17;\nfloat ReadKeyFloat(int key)\n{\n\tfloat keyVal = texture( iChannel0, vec2( (float(key)+.5)/256.0, .25 ) ).x;\n\treturn keyVal;\n}\nvec4 readData(int x, int y)\n{\n    return texture(iChannel1, (vec2(x,y) + vec2(0.5)) / iResolution.xy);\n}\nbool checkPos(int x, int y, vec2 fc)\n{\n    return int(fc.x) == x && int(fc.y) == y;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec4 self = texture(iChannel1, uv);\n    self.a = 0.0;\n\tif(iFrame < 5)\n    {\n        if(checkPos(0,0,fragCoord))\n    \t{\n            //set your initial position\n        \tself = vec4(85.0, -20.0, 140.0, 1.0);\n        }\n        else\n        {\n            //and direction here\n            self = vec4(-2.0, -0.3 ,1.0, 1.0);\n        }\n    }\n\n    //Position with WASD, space and ctrl\n    if(checkPos(0,0,fragCoord))\n    {\n        vec3 fw = readData(0, 1).rgb;\n        if(ReadKeyFloat(kW) > 0.0)\n        {\n            self += vec4(fw * speed, 1.0);\n        }\n        if(ReadKeyFloat(kS) > 0.0)\n        {\n            self -= vec4(fw * speed, -1.0);\n        }\n        if(ReadKeyFloat(kA) > 0.0)\n        {\n            vec3 right = cross(fw, vec3(0.0, 1.0, 0.0));\n            self -= vec4(right * speed, -1.0);\n        }\n        if(ReadKeyFloat(kD) > 0.0)\n        {\n            vec3 right = cross(fw, vec3(0.0, 1.0, 0.0));\n            self += vec4(right * speed, 1.0);\n        }\n        if(ReadKeyFloat(kSpace) > 0.0)\n        {\n            self += vec4(0.0, speed, 0.0, 1.0);\n        }\n        if(ReadKeyFloat(kCtrl) > 0.0)\n        {\n            self += vec4(0.0, -speed, 0.0, 1.0);\n        }\n    }\n    //Direction by mouse\n    else if(checkPos(0,1,fragCoord))\n    {\n        if(iMouse.z > 0.0)\n        {\n            float x = (iMouse.x / iResolution.x) * PI * 2.0 * 2.0;\n            float y = (iMouse.y / iResolution.y) * PI;\n            vec3 d = vec3(cos(x), -cos(y) * 1.5, sin(x));\n            self = vec4(normalize(d), 1.0);\n        }\n        else\n        {\n            self.a = 0.0;\n        }\n    }   \n    fragColor = self;\n}","name":"Buf B","description":"","type":"buffer"}]}