{"ver":"0.1","info":{"id":"XdcczN","date":"1518519501","viewed":219,"name":"1D Fluid Simulation","username":"Ultraviolet","description":"This shader performs a 1D fluid simulation, in the spirit of [url]https://www.shadertoy.com/view/4lScRG[/url].\nTop : velocity, bottom: arbitrary quantity.\nClick to set values.\n","likes":5,"published":1,"flags":32,"usePreview":0,"tags":["fluid","1d"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Display\n// see https://www.shadertoy.com/view/4d3cRN\n\n#define BG_COLOR vec3(.9)\n#define FG_COLOR vec3(.8)\n#define ST_COLOR vec3(.1)\n\nfloat PointSegDistance(vec2 p, vec2 a, vec2 b)\n{\n\tvec2 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h );\n}\n\nfloat V(int n)\n{\n    return texelFetch(iChannel0, ivec2(n, 0),0).r;\n}\n\nfloat P(int n)\n{\n    return texelFetch(iChannel1, ivec2(n, 0),0).r;\n}\n\nfloat Pgrad(int n)\n{\n    return (P(n+1)-P(n-1))/2.;\n}\n\nfloat divV(int n)\n{\n    return 2.*V(n)-V(n-1)-V(n+1);\n}\n\nfloat divV_(int n)\n{\n    return texelFetch(iChannel2, ivec2(n, 0),0).r;\n}\n\nfloat V_(int n)\n{\n    return texelFetch(iChannel3, ivec2(n, 0),0).r;\n}\n\nfloat Q(int n)\n{\n    return texelFetch(iChannel0, ivec2(n, 0),0).y;\n}\n\nfloat val0(int n)\n{\n    //return V_(n);\n    //return divV_(n);\n    //return P(n);\n    //return Pgrad(n);\n    return V(n);\n    //return divV(n);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    int x = int(fragCoord.x);\n    float dx = 1./iResolution.x;\n    \n    float v = mapSpeed(val0(x));\n    vec2 p  = vec2(uv.x   , v       );\n    vec2 pp = vec2(uv.x+dx, mapSpeed(val0(x+1)));\n    vec2 pm = vec2(uv.x-dx, mapSpeed(val0(x-1)));\n    \n    if(x == 0)\n        pm = pp;\n    if(x == int(iResolution.x)-1)\n        pp = pm;\n        \n    float dp = min(PointSegDistance(uv,p, pp),PointSegDistance(uv,p, pm));\n    \n    float stroke_alpha = clamp(mix(1., 0., dp * iResolution.y), 0., 1.);\n    float bg_alpha = clamp((v-uv.y)* iResolution.y, -1., 1.)*.5+.5;\n    bg_alpha *= clamp((uv.y-mapSpeed(0.))* iResolution.y, 0., 1.);\n    \n    float bg_alpha_2 = clamp((-v+uv.y)* iResolution.y, -1., 1.)*.5+.5;\n    bg_alpha_2 *= clamp(-(uv.y-mapSpeed(0.))* iResolution.y, 0., 1.);\n    \n    bg_alpha += bg_alpha_2;\n        \n    vec3 c = mix(BG_COLOR, FG_COLOR, bg_alpha);\n    c = mix(c, ST_COLOR, stroke_alpha);\n    \n    \n    \n    \n    \n    v = mapQuantity(Q(x));\n    p  = vec2(uv.x   , v       );\n    pp = vec2(uv.x+dx, mapQuantity(Q(x+1)));\n    pm = vec2(uv.x-dx, mapQuantity(Q(x-1)));\n    \n    if(x == 0)\n        pm = pp;\n    if(x == int(iResolution.x)-1)\n        pp = pm;\n        \n    dp = min(PointSegDistance(uv,p, pp),PointSegDistance(uv,p, pm));\n    \n    stroke_alpha = clamp(mix(1., 0., dp * iResolution.y), 0., 1.);\n    bg_alpha = clamp((v-uv.y)* iResolution.y, -1., 1.)*.5+.5;\n    \n    c = mix(c, FG_COLOR, bg_alpha);\n    c = mix(c, ST_COLOR, stroke_alpha);\n    \n    c = mix(vec3(0.), c, clamp(abs(uv.y-.5)*iResolution.y - 1., 0., 1.));\n    \n    \n    \n    \n    fragColor = vec4(c, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\n// Velocity and quantity advection \n// Note: expressed in px.s-1\n// See more at https://www.shadertoy.com/view/ls3yWr\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    ivec2 ifragCoord = ivec2(floor(fragCoord));\n    \n    // We only use the first row of pixels\n\n    if(ifragCoord.y != 0)\n    {\n        if(ifragCoord == ivec2(0,1))\n            fragColor = iMouse;\n        else\n            fragColor = vec4(0.);\n        return;\n    }\n    \n    // Initialization\n    if(iFrame == 0)\n    {\n        float x = fragCoord.x/iResolution.x;\n        float dx = 1./(iResolution.x-1.);\n        \n        float spd = .1*sin(x*10.*3.1415);\n        \n        float val = abs(sin(x*35.)*sin(x*10.));\n        \n        fragColor = vec4(spd, val, 0., 0.);\n        return;\n    }\n    \n    float val = 0.;\n    float spd = 0.;\n    float weight = 0.;\n    \n    if(iMouse.z < .5)\n    {\n        // neighboring pixels are checked (depending on the max values of v.dt across the whole system)\n        int N = 1;\n        for(int i=-N; i<=N; ++i)\n        {        \n            vec4 buf = texelFetch(iChannel0, ifragCoord+ivec2(i,0), 0);\n\n            float v = buf.x;\n            float q = buf.y;\n\n            float disp = v*dt + float(i);\n\n            if(abs(disp) < 1.)\n            {\n                float w = (1.-abs(disp));\n                val += q*w;\n                spd += v*w;\n                weight += w;\n            }\n        }\n        spd /= weight;\n    }\n    else\n    {\n        vec4 buf = texelFetch(iChannel0, ifragCoord, 0);\n        spd = buf.x;\n        val = buf.y;\n        \n        \n        //if(abs(fragCoord.x - iMouse.x) < 1.)\n        {\n    \t\tvec4 prevMouse = texelFetch(iChannel1, ivec2(0,1),0);\n            if(iMouse.y/iResolution.y < .5)\n            {\n                if(prevMouse.z < .5)\n                {\n                    if(abs(fragCoord.x - iMouse.x) < 1.)\n                \t\tval = unMapQuantity(iMouse.y/iResolution.y);\n                }\n                else\n                {\n                    float t = (fragCoord.x - prevMouse.x)/(iMouse.x - prevMouse.x);\n                    if(0.<t && t<1.)\n                        val = unMapQuantity(mix(prevMouse.y/iResolution.y, iMouse.y/iResolution.y, t));\n                }\n            }\n            else\n            {\n                if(prevMouse.z < .5)\n                {\n                    if(abs(fragCoord.x - iMouse.x) < 1.)\n                \t\tspd= unMapSpeed(iMouse.y/iResolution.y);\n                }\n                else\n                {\n                    float t = (fragCoord.x - prevMouse.x)/(iMouse.x - prevMouse.x);\n                    if(0.<t && t<1.)\n                \t\tspd= unMapSpeed(mix(prevMouse.y/iResolution.y, iMouse.y/iResolution.y, t));\n                }\n            }\n        }\n    }\n    \n    \n    /*\n    if(iMouse.y/iResolution.y > .5 && iMouse.z > .5 && abs(iMouse.x-fragCoord.x)/iResolution.x < brushRadius)\n        spd += dt * brushIntensity * smoothstep(0.,1.,1.-abs(iMouse.x-fragCoord.x)/iResolution.x / brushRadius)*sign(iMouse.y/iResolution.y - .75);\n    \n    \n    if(iMouse.y/iResolution.y < .5 && iMouse.z > .5 && abs(iMouse.x-fragCoord.x)/iResolution.x < brushRadius)\n        val += dt * brushIntensity * smoothstep(0.,1.,1.-abs(iMouse.x-fragCoord.x)/iResolution.x / brushRadius);\n    */\n    \n    //*\n    if(ifragCoord.x == 0 || ifragCoord.x == int(iResolution.x)-1)\n    {\n        spd = 0.;\n    }\n\t//*/\n    \n    \n    fragColor = vec4(spd, val, 0., 0.);\n}","name":"Buf A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"\n// Divergence Computation\n// Note: expressed in s-1\n\n// Note : Divergence is the right hand side of the Poisson equation:\n//   ∇²P = ∇.U*\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord)\n{\n    ivec2 ifragCoord = ivec2(floor(fragCoord));\n    \n    if(ifragCoord.y != 0)\n    {\n        fragColor = vec4(0.);\n        return;\n    }\n    \n\tfloat vm = texelFetch(iChannel0,ifragCoord-ivec2(1,0),0).x;\n\tfloat vp = texelFetch(iChannel0,ifragCoord+ivec2(1,0),0).x;\n    \n    float dx = 1.;///(iResolution.x-1.);\n    float div = (vp-vm)/(2.*dx);\n    \n    fragColor = vec4(div,0,0,1);\n}","name":"Buf B","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"\n// Pressure computation\n// Note : expressed in Pascals\n// \n\n\nfloat valO(int n)\n{\n    return texelFetch(iChannel0, ivec2(n, 0),0).r;\n}\n\nfloat valR(int n)\n{\n    return texelFetch(iChannel1, ivec2(n, 0),0).r;\n}\n\n/*\n\n// Single-step Jacobi method\n// see https://www.shadertoy.com/view/XscczN\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 ifragCoord = ivec2(floor(fragCoord));\n    \n    if(ifragCoord.y != 0)\n    {\n        fragColor = vec4(0.);\n        return;\n    }\n    \n    int x = ifragCoord.x;\n    float F = valO(x);\n    \n    if(ifragCoord.x == 0 || ifragCoord.x == int(iResolution.x)-1)\n    {\n        float U = valO(x);\n        fragColor = vec4(U, 0., 0., 0.);\n        return;\n    }\n    \n    float Up = valR(x+1);\n    float Um = valR(x-1);\n    \n    float U = (F+(Up+Um))/2.;\n    \n    fragColor = vec4(U, 0., 0., 0.);\n}\n//*/\n\n/*\n\n// Direct method\n// see https://www.shadertoy.com/view/XstczN\n\nfloat InverseLaplaceCoefficient(int N, int i, int j)\n{\n    i++;\n    j++;\n    \n    if (j==1)\n    {\n      return float(N-i);\n      //return float(N-i)/float(N-1);\n    }\n    \n    if (j==N)\n    {\n      return float(i-1);\n      //return float(i-1)/float(N-1);\n    }\n    \n    if (i==1 || i==N)\n    {\n      return 0.;\n    }\n\n    i = N-i+1;\n\n    if (i+j> N+1)\n    {\n      int k=i;\n      i=N-j+1;\n      j=j+(i-k);\n    }\n\n    return float(j-1+(i-2)*(j-1));\n    //return float(j-1+(i-2)*(j-1))/float(N-1);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 ifragCoord = ivec2(floor(fragCoord));\n    \n    //if(ifragCoord.y != 0)\n    if(ifragCoord.y > 0)\n    {\n        fragColor = vec4(0.);\n        return;\n    }\n    \n    int i = ifragCoord.x;\n    int N = int(iResolution.x);\n    float U = 0.;\n    \n    float scale = 1. + (fragCoord.y-.5)*iResolution.x;\n    \n    //scale = pow(10., fragCoord.y-.5);\n    \n    for(int j=0; j<N; ++j)\n    {\n        U += InverseLaplaceCoefficient(N, i, j) * (valO(j)*scale);\n    }\n    \n    U /= float(N-1)*scale;\n    \n    fragColor = vec4(U, 0., 0., 0.);\n}\n\n//*/\n\n\n//*\n\n// 20 steps Jacobi method using a preconputed mask\n// see https://www.shadertoy.com/view/lstyz4\n\nfloat rhsSteps(int n)\n{\n    float res = 0.;\n    res += valO(n-20) * 1.;\n    res += valO(n-19) * 40.;\n    res += valO(n-18) * 780.;\n    res += valO(n-17) * 9880.;\n    res += valO(n-16) * 91390.;\n    res += valO(n-15) * 658008.;\n    res += valO(n-14) * 3838380.;\n    res += valO(n-13) * 18643560.;\n    res += valO(n-12) * 76904685.;\n    res += valO(n-11) * 273438880.;\n    res += valO(n-10) * 847660528.;\n    res += valO(n- 9) * 2311801440.;\n    res += valO(n- 8) * 5586853480.;\n    res += valO(n- 7) * 12033222880.;\n    res += valO(n- 6) * 23206929840.;\n    res += valO(n- 5) * 40225345056.;\n    res += valO(n- 4) * 62852101650.;\n    res += valO(n- 3) * 88732378800.;\n    res += valO(n- 2) * 113380261800.;\n    res += valO(n- 1) * 131282408400.;\n    res += valO(n+ 0) * 137846528820.;\n    res += valO(n+ 1) * 131282408400.;\n    res += valO(n+ 2) * 113380261800.;\n    res += valO(n+ 3) * 88732378800.;\n    res += valO(n+ 4) * 62852101650.;\n    res += valO(n+ 5) * 40225345056.;\n    res += valO(n+ 6) * 23206929840.;\n    res += valO(n+ 7) * 12033222880.;\n    res += valO(n+ 8) * 5586853480.;\n    res += valO(n+ 9) * 2311801440.;\n    res += valO(n+10) * 847660528.;\n    res += valO(n+11) * 273438880.;\n    res += valO(n+12) * 76904685.;\n    res += valO(n+13) * 18643560.;\n    res += valO(n+14) * 3838380.;\n    res += valO(n+15) * 658008.;\n    res += valO(n+16) * 91390.;\n    res += valO(n+17) * 9880.;\n    res += valO(n+18) * 780.;\n    res += valO(n+19) * 40.;\n    res += valO(n+20) * 1.;\n    res /= 1099511627776.;\n    \n    return res;\n}\n\nfloat lhsSteps(int n)\n{\n    float res = 0.;\n    res += valR(n-20) * 1.;\n    res += valR(n-19) * 40.;\n    res += valR(n-18) * 780.;\n    res += valR(n-17) * 9880.;\n    res += valR(n-16) * 91390.;\n    res += valR(n-15) * 658008.;\n    res += valR(n-14) * 3838380.;\n    res += valR(n-13) * 18643560.;\n    res += valR(n-12) * 76904685.;\n    res += valR(n-11) * 273438880.;\n    res += valR(n-10) * 847660528.;\n    res += valR(n- 9) * 2311801440.;\n    res += valR(n- 8) * 5586853480.;\n    res += valR(n- 7) * 12033222880.;\n    res += valR(n- 6) * 23206929840.;\n    res += valR(n- 5) * 40225345056.;\n    res += valR(n- 4) * 62852101650.;\n    res += valR(n- 3) * 88732378800.;\n    res += valR(n- 2) * 113380261800.;\n    res += valR(n- 1) * 131282408400.;\n    res += valR(n+ 0) * 137846528820.;\n    res += valR(n+ 1) * 131282408400.;\n    res += valR(n+ 2) * 113380261800.;\n    res += valR(n+ 3) * 88732378800.;\n    res += valR(n+ 4) * 62852101650.;\n    res += valR(n+ 5) * 40225345056.;\n    res += valR(n+ 6) * 23206929840.;\n    res += valR(n+ 7) * 12033222880.;\n    res += valR(n+ 8) * 5586853480.;\n    res += valR(n+ 9) * 2311801440.;\n    res += valR(n+10) * 847660528.;\n    res += valR(n+11) * 273438880.;\n    res += valR(n+12) * 76904685.;\n    res += valR(n+13) * 18643560.;\n    res += valR(n+14) * 3838380.;\n    res += valR(n+15) * 658008.;\n    res += valR(n+16) * 91390.;\n    res += valR(n+17) * 9880.;\n    res += valR(n+18) * 780.;\n    res += valR(n+19) * 40.;\n    res += valR(n+20) * 1.;\n    res /= 1099511627776.;\n    \n    return res;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 ifragCoord = ivec2(floor(fragCoord));\n    \n    if(ifragCoord.y != 0)\n    {\n        fragColor = vec4(0.);\n        return;\n    }\n    \n    int x = ifragCoord.x;\n    float U = rhsSteps(x) + lhsSteps(x);\n    \n    fragColor = vec4(U, 0., 0., 0.);\n}\n\n//*/","name":"Buf C","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"// Gradient subtraction\n\n// Note: This allows the velocity field to be divergence-free\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    ivec2 ifragCoord = ivec2(floor(fragCoord));\n    \n    if(ifragCoord.y != 0)\n    {\n        fragColor = vec4(0.);\n        return;\n    }\n    \n    vec2 r = iResolution.xy;\n    \n    vec4 buf = texelFetch(iChannel1, ifragCoord, 0);\n    float v = buf.x;\n    \n    if(iMouse.z < .5)\n    {\n        float pm = texelFetch(iChannel0,ifragCoord-ivec2(1,0),0).x;\n        float pp = texelFetch(iChannel0,ifragCoord+ivec2(1,0),0).x;\n\n        float dx = 1.;///(iResolution.x-1.);\n        float grad = -(pp-pm)/(2.*dx);\n\n    \tv -= grad;\n    }\n    \n    float q = buf.y;\n    \n    \n    fragColor = vec4(v, q, 0., 0.);\n}","name":"Buf D","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"float brushRadius = .02;\nfloat brushIntensity = .01;\nfloat dt = 1.;\n//#define dx\t(1./(iResolution.x-1.))\n//#define N \tint(iResolution.x)\n\n\nfloat mapSpeed(float speed)\n{\n    return speed*.25+.75;\n}\n\nfloat unMapSpeed(float speed)\n{\n    return 4.*(speed-.75);\n}\n\nfloat mapQuantity(float q)\n{\n    return q*.5;\n}\n\nfloat unMapQuantity(float q)\n{\n    return q*2.;\n}","name":"Common","description":"","type":"common"}]}