{"ver":"0.1","info":{"id":"7tsBRj","date":"1651151321","viewed":196,"name":"Cartoon-like water reflections","username":"martinlaxenaire","description":"Basic cartoon-like water reflections shader with 2D perlin noise","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["water"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//\tClassic Perlin 2D Noise \n//\tby Stefan Gustavson\n//\nvec4 permute(vec4 x) {\n  return mod(((x*34.0)+1.0)*x, 289.0);\n}\n\nvec2 fade(vec2 t) {return t*t*t*(t*(t*6.0-15.0)+10.0);}\n\nfloat cnoise(vec2 P){\n    vec4 Pi = floor(P.xyxy) + vec4(0.0, 0.0, 1.0, 1.0);\n    vec4 Pf = fract(P.xyxy) - vec4(0.0, 0.0, 1.0, 1.0);\n    Pi = mod(Pi, 289.0); // To avoid truncation effects in permutation\n    vec4 ix = Pi.xzxz;\n    vec4 iy = Pi.yyww;\n    vec4 fx = Pf.xzxz;\n    vec4 fy = Pf.yyww;\n    vec4 i = permute(permute(ix) + iy);\n    vec4 gx = 2.0 * fract(i * 0.0243902439) - 1.0; // 1/41 = 0.024...\n    vec4 gy = abs(gx) - 0.5;\n    vec4 tx = floor(gx + 0.5);\n    gx = gx - tx;\n    vec2 g00 = vec2(gx.x,gy.x);\n    vec2 g10 = vec2(gx.y,gy.y);\n    vec2 g01 = vec2(gx.z,gy.z);\n    vec2 g11 = vec2(gx.w,gy.w);\n    vec4 norm = 1.79284291400159 - 0.85373472095314 * \n    vec4(dot(g00, g00), dot(g01, g01), dot(g10, g10), dot(g11, g11));\n    g00 *= norm.x;\n    g01 *= norm.y;\n    g10 *= norm.z;\n    g11 *= norm.w;\n    float n00 = dot(g00, vec2(fx.x, fy.x));\n    float n10 = dot(g10, vec2(fx.y, fy.y));\n    float n01 = dot(g01, vec2(fx.z, fy.z));\n    float n11 = dot(g11, vec2(fx.w, fy.w));\n    vec2 fade_xy = fade(Pf.xy);\n    vec2 n_x = mix(vec2(n00, n01), vec2(n10, n11), fade_xy.x);\n    float n_xy = mix(n_x.x, n_x.y, fade_xy.y);\nreturn 2.3 * n_xy;\n}\n\n\nvec2 rotateVec2ByAngle(float angle, vec2 vec) {\n    return vec2(\n        vec.x * cos(angle) - vec.y * sin(angle),\n        vec.x * sin(angle) + vec.y * cos(angle)\n    );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    \n    float PI = 3.141592;\n    \n    vec2 frequency = vec2(4.5, 11.5);\n    vec2 naturalFrequency = vec2(125.0, 125.0);\n    vec2 lightFrequency = vec2(2.0, 3.5);\n    \n    // modify this from -1 to 1 to change orientation\n    float sideStrength = 0.0;\n\n    vec2 wavesUv = rotateVec2ByAngle(sideStrength * PI, uv) * frequency;\n\n    float mainFlow = (1.0 - sideStrength) * iTime * 0.01 * 60.0;\n    float sideFlow = sideStrength * iTime * 0.01 * 60.0;\n\n    wavesUv.x -= sideFlow;\n    wavesUv.y += mainFlow;\n\n    // make light areas travel towards the user\n    float waveLightStrength = cnoise(wavesUv);\n\n    // make small waves with noise\n    vec2 naturalNoiseUv = rotateVec2ByAngle(sideStrength * PI, uv * naturalFrequency);\n    float naturalStrength = cnoise(naturalNoiseUv);\n\n    // apply a threshold to get small waves moving towards the user\n    float waveStrength = step(0.75, clamp(waveLightStrength - naturalStrength, 0.0, 1.0));\n\n    // a light mowing backward to improve overall effect\n    float light = cnoise(uv * lightFrequency + vec2(iTime * 60.0 * -0.0015));\n\n    // get our final waves colors\n    vec4 color = vec4(1.0);\n    color.rgb = mix(vec3(0.0), vec3(1.0), 1.0 - step(waveStrength, 0.01));\n\n    // exagerate effect\n    float increasedShadows = pow(abs(light), 1.75);\n    color *= 0.9 * increasedShadows;\n    \n\n    vec4 water = vec4(0.329, 0.784, 0.878, 1.0);\n\n    // Output to screen\n    fragColor = water + color;\n}","name":"Image","description":"","type":"image"}]}