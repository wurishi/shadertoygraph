{"ver":"0.1","info":{"id":"wlsXR2","date":"1563616645","viewed":280,"name":"sacred tunnel","username":"ukeyshima","description":"sacred tunnel","likes":5,"published":1,"flags":8,"usePreview":0,"tags":["raymaeching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"precision mediump float;\n#define PI 3.141592\n#define A 0.2\n\nconst vec3 cPos = vec3(0.0, 0.0, -9.0);\nconst vec3 cDir = vec3(0.0, 0.0, 1.0);\nconst vec3 cUp = vec3(0.0, 1.0, 0.0);\nconst vec3 cSide = vec3(1.0,0.0,0.0);\nconst float depth = 1.0;\nconst vec3 lPos = vec3(10.0,10.0,-10.0);\n\nvec3 rotate(vec3 p, float angle, vec3 axis){\n    vec3 a = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float r = 1.0 - c;\n    mat3 m = mat3(\n        a.x * a.x * r + c,\n        a.y * a.x * r + a.z * s,\n        a.z * a.x * r - a.y * s,\n        a.x * a.y * r - a.z * s,\n        a.y * a.y * r + c,\n        a.z * a.y * r + a.x * s,\n        a.x * a.z * r + a.y * s,\n        a.y * a.z * r - a.x * s,\n        a.z * a.z * r + c\n    );\n    return m * p;\n}\n\nvec2 pmod(vec2 p, float r) {\nfloat a = mod(atan(p.x,p.y),PI*2./r)-0.5*PI*2./r;\n    return length(p)*vec2(sin(a),cos(a));\n}\n\nfloat sequence(int s,float time){\n  float n =mod(time,A);\n  for(int i=0;i<16;i++){\n    if((s>>(int(time/A)-i)%16&1)==1)break;\n    n+=A;\n  }\n  return n;\n}\n\n\nfloat distFunc(vec3 p) {     \n   p.xy+=sequence(0xCCCC,iTime);\n       \n  p=rotate(p,sin(iTime*1.3)/5.0,vec3(0.,1.,0.0));\n  p=rotate(p,cos(iTime*1.7)/2.0,vec3(1.,0.,0.0));\n  p=rotate(p,iTime/2.0,vec3(0.,0.,1.0));\n  p.y+=sin(iTime);\n  p.z+=cos(iTime/2.);\n  p.x+=tan(iTime/4.0)*2.0;  \n  p.yz = pmod(p.yz,11.0);\n  float q = 1.8;\n  p.y = mod(p.y, 6.0) - 3.0;\n  p.xz = mod(p.xz, 3.0) - 1.5;\n  for (float i = 0.0; i < 8.0; i++) {\n    p = abs(p) - vec3(3.9 * mix(0.8, 0.2,\n                                smoothstep(abs(mod(iTime*10.0, 100.0) - 50.0),\n                                           0.0, 1.0)),\n                      0.5,1.2);\n    float s = clamp(length(p)*(sin(iTime/2.0)/2.0+1.5), 0.13, 0.95);\n    p = p / s;\n    p -= vec3(0.2, 1.9, 0.1) * exp(-i);\n    q /= s;\n  }\n  return length(p / q);\n}\n\nvec3 getNormal(vec3 p) {\n  float d = 0.001;\n  return normalize(\n      vec3(distFunc(p + vec3(d, 0.0, 0.0)) - distFunc(p + vec3(-d, 0.0, 0.0)),\n           distFunc(p + vec3(0.0, d, 0.0)) - distFunc(p + vec3(0.0, -d, 0.0)),\n           distFunc(p + vec3(0.0, 0.0, d)) - distFunc(p + vec3(0.0, 0.0, -d))));\n}\n\nvec3 rayMarching(vec3 color, vec2 p) {  \n  vec3 ray = normalize(cSide * p.x + cUp * p.y + cDir * depth);\n  vec3 rPos = cPos;\n  float rLen = 0.0;\n  float maxDist = 20.0;\n  for (float i = 0.0; i < 60.0; i++) {\n    float distance = distFunc(rPos);\n    if (abs(distance) < 0.03) {      \n      vec3 normal = getNormal(rPos);\n      vec3 lVec = normalize(lPos - rPos);\n      float diffuse = clamp(dot(normal, lVec), 0.1, 1.0)+0.5;\n      color = (vec3(0.6 * sin(rPos.z + iTime / 50.0 - 5.0),\n                    0.2 * cos(rPos.y + iTime / 70.0 - 2.0),\n                    0.2 * cos(rPos.z * iTime / 80.0)) *\n                   diffuse+0.4);\n                   \n      break;\n    }    \n    color+=0.0005/distance*(vec3(0.8 * sin(rPos.z + iTime / 50.0 - 5.0),\n                    0.2 * cos(rPos.y + iTime / 70.0 - 2.0),\n                    0.3 * cos(rPos.z * iTime / 80.0)) +\n                   0.5);;\n    rLen += distance;\n    if (rLen > maxDist) {\n      break;\n    }\n    rPos = cPos + rLen * ray;\n  }\n  return color;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 p =\n      (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n  vec3 color = rayMarching(vec3(0.0), p);  \n  fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define A 0.2\nfloat kick(float time,float a) {\n    return sin(3.1425*a*time-5.0*exp(-100.0*time))*exp(-time*10.6);\n}\nfloat sequence(int s,float time){\n  float n =mod(time,A);\n  for(int i=0;i<16;i++){\n    if((s>>(int(time/A)-i)%16&1)==1)break;\n    n+=A;\n  }\n  return n;\n}\nvec2 mainSound( in int samp, float time ){    \n \t  return vec2(\n       2.8*kick(sequence(0xCCCC,time),100.0)*(abs(sin(time*10.0))*5.0+5.0)\n     );\n}","name":"Sound","description":"","type":"sound"}]}