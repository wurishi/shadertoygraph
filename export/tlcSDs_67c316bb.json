{"ver":"0.1","info":{"id":"tlcSDs","date":"1582029341","viewed":268,"name":"Law of cosines.","username":"Logos","description":"Plate of Pythagorean theorem generalisation.\n\nThe triangle in the middle is \"generator\".\nOrange squares illustrates the law of cosines.\nGrey ones illustrates the law I do not know.","likes":22,"published":1,"flags":0,"usePreview":0,"tags":["theorem","phytagorean","generalisation","lawofcosines"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Created by Robert Śmietana (Logos) - 18.02.2020\n// Bielsko-Biała, Poland, UE, Earth, Sol, Milky Way, Local Group, Laniakea :)\n\n\n//--- program parameters ---//\n\n#define ANIMATION_SPEED\t\t\t0.5427\n#define LINE_WIDTH\t\t\t\t0.12\n\n\n//--- final color procedure ---//\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    \n    //--- precalculations ---//\n    \n    float\ttime\t\t= ANIMATION_SPEED * iTime;\t\t// current time\n\tfloat\tscale\t\t= 12.0;\t\t\t\t\t\t\t// global scale\n\tfloat\tlwidth\t\t= LINE_WIDTH;\t\t\t\t\t// all lines width\n\tfloat\tawidth\t\t= 2.0*scale / iResolution.y;\t// used for antialiasing\n\tvec3\tcolor\t\t= vec3(1.0);\t\t\t\t\t// output color\n\tfloat\td\t\t\t= 1e9;\t\t\t\t\t\t\t// minimal SDF distance\n\n    // point coordinates\n    vec2\tp\t\t\t= scale*(2.0*fragCoord.xy - iResolution.xy) / iResolution.y;\n    \n    // mouse coordinates (not used in this shader - for educational purposes)\n    vec2\tm\t\t\t= scale*(2.0*iMouse.xy    - iResolution.xy) / iResolution.y;\n\n    \n    //--- build and draw the source triangle ---//\n    \n    t0[0] = rotate(vec2(-3.0, 0.0), time);\t// try m.y instead of 0.0 :)\n    t0[1] = rotate(vec2(+3.0, 0.0), time);\t// try another possibilities ;)\n    t0[2] = rotate(vec2(+3.0*cos(time), -abs(10.0*sin(time))), time);\n    \n    // fill triangle\n    if (isInsideTriangle(p, t0[0], t0[1], t0[2])) color = vec3(1.0, 0.11, 0.05);\n    \n    // stroke triangle\n    color = mix(vec3(0.0), color, smoothstep(lwidth - awidth, lwidth + awidth, d));\n    \n    \n    //--- set first 3 squares around source triangle ---//\n    \t\t\t\t\t \n    s1[3] = t0[0]; s2[2] = t0[1]; s2[3] = t0[1];\n    s3[2] = t0[2]; s3[3] = t0[2]; s1[2] = t0[0];\n\n    \n    //--- build and draw consecutive squares ---//\n    \n    for (int i = 0; i < 4; i++)\n    {\n        // generate new population of 3 bigger squares\n        generateSquares(s1[3], s2[2], s2[3], s3[2], s3[3], s1[2]);\n\n        // choose color\n        vec3 c = 0 == i % 2? vec3(1.0, 0.7, 0.4) : vec3(0.9);\n\n        // fill 3 squares\n        if (isInsideQuadrangle(p, s1[0], s1[1], s1[2], s1[3])) color = c;\n        if (isInsideQuadrangle(p, s2[0], s2[1], s2[2], s2[3])) color = c;\n        if (isInsideQuadrangle(p, s3[0], s3[1], s3[2], s3[3])) color = c;\n        \n        // pre-stroke 3 squares\n        d = min(d, dSegment(p, s1[0], s1[1])); d = min(d, dSegment(p, s1[1], s1[2]));\n        d = min(d, dSegment(p, s1[2], s1[3])); d = min(d, dSegment(p, s1[3], s1[0]));\n        \n        d = min(d, dSegment(p, s2[0], s2[1])); d = min(d, dSegment(p, s2[1], s2[2]));\n        d = min(d, dSegment(p, s2[2], s2[3])); d = min(d, dSegment(p, s2[3], s2[0]));\n        \n        d = min(d, dSegment(p, s3[0], s3[1])); d = min(d, dSegment(p, s3[1], s3[2]));\n        d = min(d, dSegment(p, s3[2], s3[3])); d = min(d, dSegment(p, s3[3], s3[0]));\n    }\n\n    // stroke color is black, do stroke\n    color = mix(vec3(0.0), color, smoothstep(lwidth - awidth, lwidth + awidth, d));\n    \n    \n    //--- save final color ---//\n    \n    fragColor = vec4(color, 1.0);\n    \n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"//--- points depot ---//\n\nvec2 t0[3];\t// source triangle\n\nvec2 s1[4];\t// 1st surrounding square\nvec2 s2[4];\t// 2nd surrounding square\nvec2 s3[4];\t// 3rd surrounding square\n\n\n//--- auxiliary functions ---//\n\n\n// distance to mathematical segmant of line (without thickness)\nfloat dSegment(vec2 p, vec2 a, vec2 b)\n{\n    vec2 pa = p - a;\n    vec2 ba = b - a;\n    float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n\n    return length(pa - ba * h);\n}\n\n\n// 2D cross product\nvec2 cross2(vec2 a, vec2 b)\n{\n\treturn vec2(b.y - a.y, a.x - b.x);\n}\n\n\n// 2D cross product\nfloat cross2d(vec2 a, vec2 b)\n{\n\treturn a.x * b.y - a.y * b.x;\n}\n\n\n// rotates point in 2D plane\nvec2 rotate(vec2 p, float angle)\n{\n\tfloat ca = cos(angle);\n    float sa = sin(angle);\n\t\n    return p*mat2(ca, sa, -sa, ca);\n}\n\n\n// returns if point p is inside triangle ABC\nbool isInsideTriangle(vec2 p, vec2 A, vec2 B, vec2 C)\n{\n    vec3 s = vec3\n    (\n\t\tcross2d(B - A, p - A),\n\t\tcross2d(C - B, p - B),\n\t\tcross2d(A - C, p - C)\n    );\n\n    return all(greaterThan(s, vec3(0.0))) || all(lessThan(s, vec3(0.0)));\n}\n\n\n// returns if points p is inside quadrangle ABCD\nbool isInsideQuadrangle(vec2 p, vec2 A, vec2 B, vec2 C, vec2 D)\n{\n    vec4 s = vec4\n    (\n\t\tcross2d(B - A, p - A),\n\t\tcross2d(C - B, p - B),\n\t\tcross2d(D - C, p - C),\n\t\tcross2d(A - D, p - D)\n    );\n\n    return all(greaterThan(s, vec4(0.0))) || all(lessThan(s, vec4(0.0)));\n}\n\n\n// generates new population of squares based on old ones\nvoid generateSquares(vec2 v1, vec2 v2, vec2 v3, vec2 v4, vec2 v5, vec2 v6)\n{\n    s1[0] = v2;\n    s1[1] = v1;\n    s1[2] = v1    + cross2(v2, v1);\n    s1[3] = s1[2] + (v2 - v1);\n\n    s2[0] = v4;\n    s2[1] = v3;\n    s2[2] = v3    + cross2(v4, v3);\n    s2[3] = s2[2] + (v4 - v3);\n\n    s3[0] = v6;\n    s3[1] = v5;\n    s3[2] = v5    + cross2(v6, v5);\n    s3[3] = s3[2] + (v6 - v5);\n}\n","name":"Common","description":"","type":"common"}]}