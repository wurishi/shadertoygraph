{"ver":"0.1","info":{"id":"ftXcW2","date":"1648678978","viewed":186,"name":"Alien Orb Tutorial","username":"deliaev","description":"from https://www.youtube.com/watch?v=ESUy11kc3y8\n\nwith some added curl noise","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","godrays","orb","gyroid"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .001\n\n#define S smoothstep\n#define T iTime\n#define TAU 6.281\n\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat sdBox(vec3 p, vec3 s) {\n    p = abs(p)-s;\n\treturn length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.);\n}\n\nfloat range(float oldValue, float oldMin, float oldMax, float newMin, float newMax) {\n    float oldRange = oldMax - oldMin;\n    float newRange = newMax - newMin;\n    return (((oldValue - oldMin) * newRange) / oldRange) + newMin;\n}\n\nvec3 range(vec3 oldValue, vec3 oldMin, vec3 oldMax, vec3 newMin, vec3 newMax) {\n    vec3 v;\n    v.x = range(oldValue.x, oldMin.x, oldMax.x, newMin.x, newMax.x);\n    v.y = range(oldValue.y, oldMin.y, oldMax.y, newMin.y, newMax.y);\n    v.z = range(oldValue.z, oldMin.z, oldMax.z, newMin.z, newMax.z);\n    return v;\n}\n\nfloat cnoise(vec3 v) {\n    float t = v.z * 0.3;\n    v.y *= 0.8;\n    float noise = 0.0;\n    float s = 0.5;\n    noise += range(sin(v.x * 0.9 / s + t * 10.0) + sin(v.x * 2.4 / s + t * 15.0) + sin(v.x * -3.5 / s + t * 4.0) + sin(v.x * -2.5 / s + t * 7.1), -1.0, 1.0, -0.3, 0.3);\n    noise += range(sin(v.y * -0.3 / s + t * 18.0) + sin(v.y * 1.6 / s + t * 18.0) + sin(v.y * 2.6 / s + t * 8.0) + sin(v.y * -2.6 / s + t * 4.5), -1.0, 1.0, -0.3, 0.3);\n    return noise;\n}\n\nfloat BallGyroid(vec3 p) {\n    p.yz *= Rot(T*.2);\n    p *= 10.;\n    return abs(cnoise(p)*dot(sin(p), cos(p.yzx))/10.)-.02;\n}\n\nfloat smin(float a, float b, float k) {\n    float h = clamp(.5+.5*(b-a)/k, 0.,1.);\n    return mix(b,a,h) - k*h*(1.-h);\n}\n\nfloat GetDist(vec3 p) {\n    float ball = length(p) - 1.;\n    ball = abs(ball) - 0.02;\n    float g = BallGyroid(p);\n    \n    ball = smin(ball, g, -.03);\n    \n    float ground = p.y + 1.;\n    p *= 5.;\n    p.z += T;\n    p.y += sin(p.z)*.5;\n    float y = abs(dot(sin(p), cos(p.yzx)))*.1;\n    ground += y;\n    \n    float d = min(ball, ground*.9);\n    \n    return d;\n}\n\nfloat RayMarch(vec3 ro, vec3 rd) {\n\tfloat dO=0.;\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = GetDist(p);\n        dO += dS;\n        if(dO>MAX_DIST || abs(dS)<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i);\n    return d;\n}\n\nfloat Hash21(vec2 p) {\n    p = fract(p*vec2(123.34, 254.98));\n    p += dot(p, p+45.6);\n    return fract(p.x*p.y);\n}\n\nfloat Glitter(vec2 p, float a) {\n    p *= 10.;\n    vec2 id = floor(p);\n    \n    p = fract(p)-.5;\n    float n = Hash21(id); //noise\n    float d = length(p);\n    float m = S(.5*n, .0, d); \n    m *= pow(sin(a+fract(n*10.)*TAU)*.5+.5, 100.);\n    return m;\n}\n\nvec3 RayPlane(vec3 ro, vec3 rd, vec3 p, vec3 n) {\n    float t = dot(p-ro, n)/dot(rd, n);\n    t = max(0., t);\n    return ro + rd*t;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\tvec2 m = iMouse.xy/iResolution.xy;\n    float cds = dot(uv, uv); //center distance squared\n\n    vec3 ro = vec3(0, 3, -3)*.6;\n    ro.yz *= Rot(-m.y*3.14+1.);\n    ro.y = max(-.9, ro.y);\n    ro.xz *= Rot(-m.x*6.2831 + T*.3);\n    \n    vec3 rd = GetRayDir(uv, ro, vec3(0,0.,0), 1.);\n    vec3 col = vec3(0);\n   \n    float d = RayMarch(ro, rd);\n\n    if(d<MAX_DIST) {\n        vec3 p = ro + rd * d;\n        vec3 n = GetNormal(p);\n        vec3 r = reflect(rd, n);\n        vec3 lightDir = -normalize(p);\n        float dif = dot(n, lightDir)*.5+.5;\n        float cd = length(p);\n        \n        col = vec3(dif);\n        \n        if (cd > 1.035) {\n            //col *= vec3(1,0,0);\n            float s = BallGyroid(-lightDir);\n            float w = cd * .02;\n            float shadow = S(-w, w, s);\n            col *= shadow*.9+.1;\n            \n            p.z -= T*0.01;\n            col += Glitter(p.xz*6., dot(ro, vec3(2))-T)*2.*shadow;\n            col /= cd*cd;\n        } else {\n            float sss = S(.1, 0., cds); \n            sss *= sss;\n            \n            //float s = BallGyroid(p+sin(p*10.+T*.001)*.02);\n            //sss *= S(-.01, 0., s);\n            col += sss*vec3(1., .1, .2);\n        }\n    }\n    \n    // center light\n    float light = .005/cds;\n    vec3 lightCol = vec3(1., .8, .7);\n    col += light*S(.0, .5, d-2.) * lightCol;\n    // center light glare\n    float s = BallGyroid(normalize(ro));\n    col += light*.5*S(.0, .08, s) * lightCol;\n    \n    //volumetrics\n    vec3 pp = RayPlane(ro, rd, vec3(0), normalize(ro));\n    float sb = BallGyroid(normalize(pp));\n    sb *= S(0., .4, cds);\n    col += max(0.,sb*2.);\n    \n    col = pow(col, vec3(.4545));\t// gamma correction\n    col *= 1. - cds*.5;\n    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}