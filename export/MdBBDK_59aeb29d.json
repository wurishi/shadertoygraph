{"ver":"0.1","info":{"id":"MdBBDK","date":"1502389925","viewed":597,"name":"raymarching-tests","username":"bytearray","description":"facncy and trippy :D","likes":3,"published":1,"flags":64,"usePreview":0,"tags":["3d","raymarching","visualization"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"lsXSD2","filepath":"https://soundcloud.com/dodo-ahmed-611/macklemore-ryan-lewis-cant-hold-us-feat-ray-dalton","previewfilepath":"https://soundcloud.com/dodo-ahmed-611/macklemore-ryan-lewis-cant-hold-us-feat-ray-dalton","type":"musicstream","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.1415926535897932384626433832795\n#define MAX_MARCHING_STEPS 100\n#define EPSILON 0.0001\n#define start 0.1\n#define end 100.0\n\nvec3 bug = vec3(0);\n\n\nfloat sphere(in vec3 pos, in float r)\n{\n    return length(pos) - r;\n}\n\nfloat box( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat soundSphere(vec3 pos, float r)\n{\n    float ry = atan(pos.x / pos.z);\n    float rx = atan(pos.y / pos.z);\n    \n    int a = int(fract((ry / PI / 4. + .5) * 3.) * 512.);\n    int b = int(fract((rx / PI / 4. + .5) * 3.) * 512.);\n    \n    float freq = texelFetch( iChannel0, ivec2(0, 0), 0).x; \n    float wave = texelFetch( iChannel0, ivec2(0, 1), 0).x;\n    //bug.r = float(a);\n    float disp = wave / 10. + freq;\n    \n    return length(pos) - r - disp;\n}\n\n\nvoid intersect(inout float distA, float distB)\n{\n    distA = max(distA, distB);\n}\n\nvoid combine(inout float distA, float distB)\n{\n    distA = min(distA, distB);\n}\n\nvoid difference(inout float distA, float distB)\n{\n    distA = max(-distA, distB);\n}\n\n//pos, layer direction, layer gap, laver offet, ball size\nfloat layer(vec3 p, vec3 d, vec3 g, vec3 o, float s)\n{\n    p += mod(d * iTime + o, g);\n    vec3 q = mod(p, vec3(g))-0.5*vec3(g);\n    return sphere(q, s);\n}\n\nfloat sdf(vec3 pos)\n{\n    float b = 10000.;\n    float u = .4;\n    float s = .33;\n    float k = .5;\n    \n    combine(b, layer(pos, vec3( 0., 0., s ), vec3(u*3.), vec3(0., u , 0.), k));\n    combine(b, layer(pos, vec3( 0., s , 0.), vec3(u*3.), vec3(u , 0., 0.), k));\n    combine(b, layer(pos, vec3( s , 0., 0.), vec3(u*3.), vec3(0., 0., u ), k));\n    combine(b, layer(pos, vec3( 0., 0.,-s ), vec3(u*3.), vec3(0., -u, 0.), k));\n    combine(b, layer(pos, vec3( 0.,-s , 0.), vec3(u*3.), vec3(-u, 0., 0.), k));\n    combine(b, layer(pos, vec3(-s , 0., 0.), vec3(u*3.), vec3(0., 0., -u), k));\n    \n    difference(b, soundSphere(pos, 1.));\n    return b;\n}\n\nfloat ray(vec3 eye, vec3 dir)\n{\n    float depth = start;\n\tfor (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        \n        float dist = sdf(eye + depth * dir);\n        \n        if (dist < EPSILON) {\n            return depth;\n        }\n        depth += dist;\n\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n\nvec3 estimateNormal(vec3 p)\n{\n    return normalize(vec3(\n        sdf(vec3(p.x + EPSILON, p.y, p.z)) - sdf(vec3(p.x - EPSILON, p.y, p.z)),\n        sdf(vec3(p.x, p.y + EPSILON, p.z)) - sdf(vec3(p.x, p.y - EPSILON, p.z)),\n        sdf(vec3(p.x, p.y, p.z  + EPSILON)) - sdf(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\nmat4 viewMatrix(vec3 eye, vec3 center, vec3 up)\n{\n\tvec3 f = normalize(center - eye);\n\tvec3 s = normalize(cross(f, up));\n\tvec3 u = cross(s, f);\n\treturn mat4(\n\t\tvec4(s, 0.0),\n\t\tvec4(u, 0.0),\n\t\tvec4(-f, 0.0),\n\t\tvec4(0.0, 0.0, 0.0, 1)\n\t);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = vec2(fragCoord.x / iResolution.y, fragCoord.y / iResolution.y);\n    uv.x += (1. - iResolution.x / iResolution.y) / 2.;\n    vec2 st = uv - vec2(.5);\n    \n    vec3 eye = vec3(sin(iTime)*7., cos(iTime)*5., 4.);\n    vec3 dir = vec3(st / 2., -1.);\n    \n    mat4 mat = viewMatrix(eye, vec3(0.), vec3(0., 1., 0.));\n    dir = (mat * vec4(dir, 1.)).xyz;\n    \n    float depth = ray(eye, dir);\n    if(!(depth >= end - EPSILON))\n    {\n        vec3 hit = eye + dir * depth;\n    \tvec3 norm = estimateNormal(hit);\n        \n        fragColor = vec4(norm+vec3(.5), 1.);\n    }\n    else\n    {\n        fragColor = vec4(0);\n    }\n    fragColor.rgb += bug;\n}\n","name":"Image","description":"","type":"image"}]}