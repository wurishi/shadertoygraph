{"ver":"0.1","info":{"id":"X3VGWm","date":"1717738031","viewed":149,"name":"Fibonacci Sphere Color Palette","username":"SL0ANE","description":"画像素画的时候实在不会配色，还是算出来吧","likes":7,"published":1,"flags":48,"usePreview":0,"tags":["3d","raymarching","distancefield","sdf","cartoon","palette","fibonacci"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dX3zn","filepath":"/media/a/550a8cce1bf403869fde66dddf6028dd171f1852f4a704a465e1b80d23955663.png","previewfilepath":"/media/ap/550a8cce1bf403869fde66dddf6028dd171f1852f4a704a465e1b80d23955663.png","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"# define ALBEDO_COLOR vec4(0.9, 0.7, 0.1, 1.0)\n# define SMOOTHNESS 0.8\n# define METALLIC 0.4\n# define SSS_COLOR vec4(0.9, 0.4, 0.5, 1.0)\n# define SSS_RANGE 0.8\n# define SSS_STRENGTH 0.8\n\n# define LIGHT_DIRECTION normalize(vec3(0.0, -0.6, 0.0) + vec3(-cos(iTime + 0.2), 0.0, sin(iTime + 0.2)))\n# define LIGHT_COLOR vec4(1.0, 0.98, 0.94, 1.0)\n# define LIGHT_STRENGTH 1.0\n\n# define AMBIENT_UP_COLOR vec4(0.6, 0.7, 0.8, 1.0)\n# define AMBIENT_DOWN_COLOR vec4(0.3, 0.3, 0.8, 1.0)\n# define AMBIENT_STRENGTH 1.0\n\n# define RIM_LIGHT_COLOR vec4(0.9, 0.6, 0.8, 1.0)\n# define RIM_LIGHT_STRENGTH 1.0\n\n# define MAPPING_NUM 64\n# define OUTLINE_COLOR vec4(1.0, 1.0, 1.0, 1.0)\n\n# define CUBEMAP\n\n# define DIFFUSE_STEP 3.0\n# define SPECULAR_STEP 2.0\n\n# define BACKGROUND_COLOR (getAmbient(vec3(0.0, 0.0, 1.0)) + getAmbient(vec3(0.0, 0.0, -1.0)) + getAmbient(vec3(1.0, 0.0, 0.0)) + getAmbient(vec3(-1.0, 0.0, 0.0)) + getAmbient(vec3(0.0, -1.0, 0.0)) + getAmbient(vec3(0.0, 1.0, 0.0))) / 6.0f * 0.618\n\n\n# define MAX_DISTANCE 1024.0\n# define MIN_STEP 64\n# define MAX_STEP 512\n# define MIN_DIS_SHADOW 0.064\n# define SLOANE_COLOR vec4(0.98, 0.52, 0.52, 1.0)\n\n// Pre\nObjectInfo sceneSolidMap(vec3 point, vec3 view, float pixelSize, bool castShadow, bool withMat, inout float outlineDis);\nMaterial sceneBaseMaterial(vec3 point, float len);\nvec3 getColorAtPos(vec3 pos, vec3 ray, vec3 front, float len, vec2 screenCoord, float pixelSize, float dis, inout vec3 normal, bool outlineHit, float disWhenHit, float lenWhenHit);\n\n// Camera Config\nfloat cameraFov = 60.0f;\n\n// Outline Config\nfloat outlineStrength;\nfloat outlineThreshold = 0.05;\n\n// Bone\n\nvec3 positionLocal_Camera = vec3(0.0, 0.0, 0.0);\nvec4 rotationLocal_Camera = vec4(0.0, 0.0, 0.0, 1.0);\nvec3 positionWorld_Camera;\nvec4 rotationWorld_Camera;\n\nvec3 positionLocal_Root = vec3(0.0, 0.0, 7.0);\nvec4 rotationLocal_Root = vec4(0.0, 0.0, 0.0, 1.0);\nmat4 transform_Root;\n\n// Util\nvec3 getSolidNormal(vec3 point, float pixelSize)\n{\n    vec3 deltaX = vec3(pixelSize, 0.0, 0.0) / 4.0;\n    vec3 deltaY = vec3(0.0, pixelSize, 0.0) / 4.0;\n    vec3 deltaZ = vec3(0.0, 0.0, pixelSize) / 4.0;\n    \n    float outlineDis;\n    \n    float x = sceneSolidMap(point + deltaX, vec3(0.0), pixelSize, false, false, outlineDis).dis - sceneSolidMap(point - deltaX, vec3(0.0), pixelSize, false, false, outlineDis).dis;\n    float y = sceneSolidMap(point + deltaY, vec3(0.0), pixelSize, false, false, outlineDis).dis - sceneSolidMap(point - deltaY, vec3(0.0), pixelSize, false, false, outlineDis).dis;\n    float z = sceneSolidMap(point + deltaZ, vec3(0.0), pixelSize, false, false, outlineDis).dis - sceneSolidMap(point - deltaZ, vec3(0.0), pixelSize, false, false, outlineDis).dis;\n    \n    return normalize(vec3(x, y, z));\n}\n\nfloat shadow(vec3 ro, vec3 rd, float mint, float maxt)\n{\n    float t = mint;\n    float outlineDis;\n    \n    while(t < maxt)\n    {\n        float h = sceneSolidMap(ro + rd * t, vec3(0.0), 0.0, true, false, outlineDis).dis;\n        if(h < TOLERANCE)\n            return 0.0;\n        t += h;\n    }\n    return 1.0;\n}\n\nfloat outlineMin(float a, float b)\n{\n    if(a > MAX_DISTANCE) return a;\n    if(b > MAX_DISTANCE) return b;\n    return min(a, b);\n}\n\n// Object\n\n\n\n// Project\n\nObjectInfo sceneSolidMap(vec3 point, vec3 view, float pixelSize, bool castShadow, bool withMat, inout float outlineDis)\n{\n    ObjectInfo info = ObjectInfo(0.0,\n                      Material(\n                      ALBEDO_COLOR,\n                      SSS_COLOR,\n                      vec4(0.0),\n                      vec3(0.0),\n                      vec3(0.0),\n                      vec3(0.0),\n                      SMOOTHNESS, METALLIC, SSS_RANGE, SSS_STRENGTH, 1));\n                      \n    vec3 transPoint = (transform_Root * vec4(point, 1.0)).xyz;\n    info.dis = distance(transPoint, vec3(0.0)) - 1.0;\n                      \n    outlineDis = info.dis;\n    \n    return info;\n}\n\nvec3 march(vec3 start, vec3 ray, vec3 front, vec2 screenCoord, float pixelSize, inout vec3 pos, inout vec3 normal, inout float len)\n{\n    len = 0.0;\n    float dis = 0.0;\n    vec3 curPos = vec3(0.0);\n    \n    ObjectInfo curSolidInfo;\n    ObjectInfo lastSolidInfo;\n    \n    float stepDis;\n    \n    int stepCount = 0;\n    \n    float curPixelSize;\n    float disWhenHit = 65535.0;\n    float lenWhenHit;\n    float disForRealHit = 65535.0;\n    float lenForRealHit;\n    bool outlineHitFlag = false;\n    float outlineDis;\n    \n    float theta = dot(ray, front);\n    \n    int outlineHit = 0;\n\n    while(len < MAX_DISTANCE && stepCount <= MAX_STEP)\n    {\n        curPos = len * ray + start;\n        pos = curPos;\n        \n        curPixelSize = len * theta * pixelSize;\n        \n        lastSolidInfo = curSolidInfo;\n        curSolidInfo = sceneSolidMap(curPos, front, curPixelSize, false, false, outlineDis);\n        \n        dis = curSolidInfo.dis;\n        \n        if(dis < curPixelSize)\n        {\n            break;\n        }\n        \n        if(outlineHit == 0)\n        {\n            // 第一次到范围内\n            if(outlineDis <= curPixelSize * outlineStrength) outlineHit = 1;\n            \n            float currentDis = outlineDis / curPixelSize;\n            lenWhenHit = len;\n            disWhenHit = currentDis;\n        }\n        else if(outlineHit == 1)\n        {\n            if(outlineDis > MAX_DISTANCE)\n            {\n                outlineHit = 0;\n            }\n            else if(outlineDis <= curPixelSize * outlineStrength)\n            {\n                float currentDis = outlineDis / curPixelSize;\n                \n                if(disWhenHit > currentDis)\n                {\n                    lenWhenHit = len;\n                    disWhenHit = currentDis;\n                }\n            }\n            else\n            {\n                outlineHit = 0;\n                outlineHitFlag = true;\n                if(disWhenHit < disForRealHit)\n                {\n                    disForRealHit = disWhenHit;\n                    lenForRealHit = lenWhenHit;\n                }\n            }\n        }\n\n        stepDis = dis;\n        len += stepDis;\n        stepCount += 1;\n    }\n    \n    vec3 outputColor = getColorAtPos(pos, ray, front, len, screenCoord, curPixelSize, dis, normal, outlineHitFlag, disForRealHit, lenForRealHit);\n    return outputColor;\n}\n\nvec3 getAmbient(vec3 normal)\n{\n    vec3 ambientColor;\n    \n#ifdef CUBEMAP\n    ambientColor = textureLod(iChannel0, normal, 0.0).rgb;\n    ambientColor *= AMBIENT_STRENGTH;\n#else\n    float factor = dot(vec3(0.0, 1.0, 0.0), normal);\n    factor = factor * 0.5 + 0.5;\n    ambientColor = mix(AMBIENT_DOWN_COLOR.rgb, AMBIENT_UP_COLOR.rgb,factor);\n#endif\n    \n    return ambientColor;\n}\n\nMaterial sceneBaseMaterial(vec3 point, vec3 view, float pixelSize, float len, vec2 screenCoord)\n{\n    if(len >= MAX_DISTANCE) {\n        Material outMat;\n        outMat.color0.rgb = BACKGROUND_COLOR;\n        outMat.index = 0;\n        return outMat;\n    } \n    \n    float outlineDis;\n    return sceneSolidMap(point, view, pixelSize, false, true, outlineDis).material;\n}\n\nvec3 fibonacciSphereMap(vec3 inputVector, int numPoints) {\n    float phi = 3.14159265359 * (3.0 - sqrt(5.0));\n    vec3 bestPoint = vec3(0.0);\n    float maxDot = -1.0;\n    for (int i = 0; i < numPoints; ++i) {\n        float y = 1.0 - float(i) / float(numPoints - 1) * 2.0;\n        float r = sqrt(1.0 - y * y);\n        float theta = float(i) * phi;\n\n        vec3 point = vec3(cos(theta) * r, y, sin(theta) * r);\n        float dotProduct = dot(normalize(inputVector), point);\n        \n        if (dotProduct > maxDot) {\n            maxDot = dotProduct;\n            bestPoint = point;\n        }\n    }\n    return bestPoint;\n}\n\nvec3 defaultShading(Material material, vec3 pos, vec3 normal, vec3 view)\n{\n    vec3 mappedNormal = fibonacciSphereMap(normal, MAPPING_NUM);\n    \n    float expSmoothness = pow(2.7, 5.0 * material.t0 + 1.0);\n    float lightLevel = dot(-mappedNormal, LIGHT_DIRECTION);\n    float diffuseCache = dot(-normal, LIGHT_DIRECTION);\n    lightLevel = clamp(lightLevel, 0.0, 1.0);\n    \n    vec3 subsurfaceColor = mix(material.color0.rgb, material.color1.rgb, smoothstep(1.0 - material.t2, 1.0, (1.0 - lightLevel) * material.t3));\n    \n    lightLevel = pow(lightLevel, 1.0 / 2.2);\n    lightLevel = multiStep(lightLevel, DIFFUSE_STEP, 0.0, 0.0);\n    \n    vec3 diffuse = subsurfaceColor * LIGHT_COLOR.rgb * lightLevel * LIGHT_STRENGTH;\n    \n    float res_0 = dot(normalize(mix(LIGHT_DIRECTION, view, 0.5)), -normal);\n    lightLevel = pow(clamp(res_0, 0.0, 1.0), expSmoothness);\n    lightLevel = pow(lightLevel, 1.0 / 2.2);\n    lightLevel = multiStep(lightLevel, SPECULAR_STEP, 0.0, 0.0);\n    \n    vec3 reflectColor = mix(vec3(1.0), material.color0.rgb, material.t1);\n    vec3 specular = reflectColor * LIGHT_COLOR.rgb *lightLevel * material.t0 * LIGHT_STRENGTH;\n    \n    lightLevel = pow(1.0 + dot(view, normal), 1.6) * smoothstep(0.5, -0.6, diffuseCache);\n    lightLevel = multiStep(lightLevel, 2.0, 0.0, 0.0);\n    vec3 fresnel = lightLevel * reflectColor * RIM_LIGHT_COLOR.rgb * RIM_LIGHT_STRENGTH;\n    \n    return (diffuse + specular + fresnel) + getAmbient(mappedNormal) * reflectColor;\n}\n\nvec3 getColorAtPos(vec3 pos, vec3 ray, vec3 front, float len, vec2 screenCoord, float pixelSize, float dis, inout vec3 normal, bool outlineHit, float disWhenHit, float lenWhenHit)\n{\n    Material material = sceneBaseMaterial(pos, front, pixelSize, len, screenCoord);\n    vec4 outlineColor = vec4(0.0);\n    \n    if(outlineHit)\n    {\n        float outlineThreshold = mix(0.0, outlineStrength, clamp((len - lenWhenHit) / outlineThreshold, 0.0, 1.0));\n        outlineColor = vec4(OUTLINE_COLOR.rgb, clamp(outlineThreshold - disWhenHit - 0.25, 0.0, 1.0));\n    }\n    \n    vec3 solidColor = vec3(0.0);\n    if(material.index == 0) solidColor = material.color0.rgb;\n    else\n    {\n        normal = getSolidNormal(pos, pixelSize);\n        solidColor = defaultShading(material, pos, normal, ray);\n    }\n    \n    return mix(solidColor, outlineColor.rgb, outlineColor.a);\n}\n\nvoid update()\n{\n    outlineStrength = max(3.0, 6.0 * pow(iResolution.x / 800.0, 0.5));\n    float angle;\n    \n    // 相机\n    positionWorld_Camera = positionLocal_Camera;\n    rotationWorld_Camera = rotationLocal_Camera;\n    \n    \n    // 根\n    angle = -PI / 32.0;\n    rotationLocal_Root = quaternionMul(load(POINTER_ROT), rotationLocal_Root);\n    transform_Root = createModelInverseMat(quaternionMul(load(POINTER_ROT), rotationLocal_Root), positionLocal_Root);\n    \n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    update();\n    \n    vec2 uv = (fragCoord.xy - iResolution.xy / 2.0) / iResolution.x;\n    float delta = 1.0 / iResolution.x;\n    float tanFov = tan(cameraFov / 360.0 * PI);\n    vec3 ray = normalize(vec3(uv, 0.5 / tanFov));\n    \n    // 平面距离为1时，每个像素对应的大小\n    float pixelSize = 2.0 * tanFov / iResolution.x;\n    vec3 front = rotatePoint(vec3(0.0, 0.0, 1.0), vec3(0.0), rotationWorld_Camera);\n    ray = rotatePoint(ray, vec3(0.0), rotationWorld_Camera);\n    \n    vec3 pos;\n    vec3 normal;\n    float len;\n    \n    vec4 color = vec4(march(positionWorld_Camera, ray, front, fragCoord / iResolution.xy, pixelSize, pos, normal, len), 1.0);\n    fragColor = color;\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"# define PI 3.1415926535897932384626433832795\n# define FAI 1.618033988749\n# define TOLERANCE 0.0001\n\n# define POINTER_ROT ivec2(0, 1)\n# define POINTER_TIME ivec2(0, 2)\n# define POINTER_PRESS ivec2(0, 3)\n# define POINTER_MOUSE ivec2(0, 4)\n# define POINTER_RESETCAM ivec2(0, 5)\n\n# define store(P, V) if (all(equal(ivec2(fragCoord), P))) fragColor = V\n# define load(P) texelFetch(iChannel2, ivec2(P), 0)\n\n# define keyToggle(ascii)  ( texelFetch(iChannel3,ivec2(ascii,2),0).x > 0.)\n# define keyClick(ascii)   ( texelFetch(iChannel3,ivec2(ascii,1),0).x > 0.)\n# define keyDown(ascii)    ( texelFetch(iChannel3,ivec2(ascii,0),0).x > 0.)\n\n# define QUA_ZERO vec4(0.0, 0.0, 0.0, 1.0)\n# define DEFAULT_INFO ObjectInfo(65535.0, Material( vec4(1.0, 1.0, 1.0, 1.0), vec4(0.0), vec4(0.0), vec3(0.0), vec3(0.0), vec3(0.0), 0.0, 0.0, 0.0, 1));\n# define DEFAULT_MAT mat4(1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, -8.0, 1.0)\n// Structure\nstruct Material\n{\n    vec4 color0;\n    vec4 color1;\n    vec4 color2;\n    vec3 vect0;\n    vec3 vect1;\n    vec3 vect2;\n    // #0: smoothness, fresnel, sssrange, sssstrength\n\tfloat t0;\n    float t1;\n    float t2;\n    float t3;\n    int index;\n};\n\nstruct ObjectInfo\n{\n\tfloat dis;\n    Material material;\n};\n\n// Util\nvec3 applyTransform(vec3 origin, vec3 trans_x, vec3 trans_y, vec3 trans_z)\n{\n    return origin.x * trans_x + origin.y * trans_y + origin.z * trans_z;\n}\n\nfloat multiStep(float value, float level, float minValue, float offset)\n{\n    if(level <= 1.0) return 1.0;\n    \n    float curLevel = value * level;\n    float curOffset = floor(curLevel) / (level - 1.0);\n    curLevel = floor(curLevel + mix(offset, 0.0, curOffset));\n    \n    curOffset = curLevel / (level - 1.0);\n    curLevel += mix(minValue, 1.0, curOffset);\n    curLevel = curLevel / level;\n    \n    return curLevel;\n}\n\nfloat dot2(vec2 v)\n{\n    return dot(v, v);\n}\n\nfloat dot2(vec3 v)\n{\n    return dot(v, v);\n}\n\nfloat cro( in vec2 a, in vec2 b ) { return a.x*b.y - a.y*b.x; }\n\nvec4 conjugate(vec4 q) {\n    return vec4(-q.x, -q.y, -q.z, q.w);\n}\n\nvec4 quaternionInverse(vec4 q) {\n    return conjugate(q) / dot(q, q);\n}\n\nvec3 sss( float ndl, float ir )\n{\n    float pndl = clamp( ndl, 0.0, 1.0 );\n    float nndl = clamp(-ndl, 0.0, 1.0 );\n\n    return vec3(pndl) + \n           vec3(1.0,0.1,0.0)*0.250*(1.0-pndl)*(1.0-pndl)*pow(1.0-nndl,3.0/(ir+0.001))*clamp(ir-0.04,0.0,1.0);\n}\n\nvec4 quaternionMul(vec4 left, vec4 right)\n{\n    float w = left.w*right.w - left.x*right.x - left.y*right.y - left.z * right.z;\n    float x = left.w*right.x + left.x*right.w + left.z*right.y - left.y * right.z;\n    float y = left.w*right.y + left.y*right.w + left.x*right.z - left.z * right.x;\n    float z = left.w*right.z + left.z*right.w + left.y*right.x - left.x * right.y;\n    \n    return vec4(x, y, z, w);\n}\n\nvec4 quaternionLerp(vec4 starting, vec4 ending, float t)\n{\n    float cosa = starting.x *ending.x + starting.y * ending.y + starting.z *ending.z  + starting.w * ending.w;\n    \n    if (cosa < 0.0) \n    {\n        ending.x = -ending.x;\n        ending.y = -ending.y;\n        ending.z = -ending.z;\n        ending.w = -ending.w;\n        cosa = -cosa;\n    }\n    \n    float k0, k1;\n     \n    if (cosa > 0.9995f) \n    {\n        k0 = 1.0 - t;\n        k1 = t;\n    }\n    else \n    {\n        float sina = sqrt(1.0 - cosa * cosa);\n        float a = atan(sina, cosa);\n        k0 = sin((1.0 - t) * a) / sina;\n        k1 = sin(t * a) / sina;\n    }\n    \n    vec4 result;\n    \n    result.x = starting.x * k0 + ending.x * k1;\n    result.y = starting.y * k0 + ending.y * k1;\n    result.z = starting.z * k0 + ending.z * k1;\n    result.w = starting.w * k0 + ending.w * k1;\n    \n    return result;\n}\n\nvec3 rotatePoint(vec3 p, vec3 center, vec4 q) {\n    vec4 pQuaternion = vec4(p - center, 0.0);\n\n    vec4 rotatedP = quaternionMul(quaternionMul(q , pQuaternion), conjugate(q));\n    vec3 rotatedPoint = rotatedP.xyz;\n    \n    rotatedPoint += center;\n    \n    return rotatedPoint;\n}\n\nmat4 createModelMat(vec4 q, vec3 offset)\n{\n    float qx2 = q.x * q.x;\n    float qy2 = q.y * q.y;\n    float qz2 = q.z * q.z;\n\n    float qxqy = q.x * q.y;\n    float qxqz = q.x * q.z;\n    float qxqw = q.x * q.w;\n    float qyqz = q.y * q.z;\n    float qyqw = q.y * q.w;\n    float qzqw = q.z * q.w;\n    \n    return mat4(1.0 - 2.0 * (qy2 + qz2), 2.0 * (qxqy - qzqw),     2.0 * (qxqz + qyqw),     0.0,\n                2.0 * (qxqy + qzqw),     1.0 - 2.0 * (qx2 + qz2), 2.0 * (qyqz - qxqw),     0.0,\n                2.0 * (qxqz - qyqw),     2.0 * (qyqz + qxqw),     1.0 - 2.0 * (qx2 + qy2), 0.0,\n                offset.x,                offset.y,                offset.z,                1.0);\n}\n\nmat4 createModelInverseMat(vec4 q, vec3 offset)\n{\n    return createModelMat(quaternionInverse(q), vec3(0.0)) * mat4(1.0,       0.0,       0.0,       0.0,\n                0.0,       1.0,       0.0,       0.0,\n                0.0,       0.0,       1.0,       0.0,\n                -offset.x, -offset.y, -offset.z, 1.0);\n}\n\nfloat onion( in float sdf, in float thickness )\n{\n    return abs(sdf)-thickness;\n}\n\nfloat sint( float d1, float d2, float k )\n{\n    float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.0-h);\n}\n\nfloat smin(float a, float b, float k)\n{\n    float h = max(k - abs(a - b), 0.0);\n    return min(a, b) - h * h * 0.25 / k;\n}\n\nfloat ssub(float a, float b, float k)\n{\n    float h = clamp( 0.5 - 0.5 * (b + a) / k, 0.0, 1.0 );\n    return mix(a, -b, h) + k * h * (1.0 - h);\n}\n\nfloat xor( float a, float b )\n{\n    return max( min(a,b), -max(a,b) );\n}\n\nfloat sub(float d1, float d2)\n{\n    return max(d1, -d2);\n}\n\nuint murmurHash12(uvec2 src) {\n    const uint M = 0x5bd1e995u;\n    uint h = 1190494759u;\n    src *= M; src ^= src>>24u; src *= M;\n    h *= M; h ^= src.x; h *= M; h ^= src.y;\n    h ^= h>>13u; h *= M; h ^= h>>15u;\n    return h;\n}\n\nfloat hash12(vec2 src) {\n    uint h = murmurHash12(floatBitsToUint(src));\n    return uintBitsToFloat(h & 0x007fffffu | 0x3f800000u) - 1.0;\n}\n\nuint murmurHash11(uint src) {\n    const uint M = 0x5bd1e995u;\n    uint h = 1190494759u;\n    src *= M; src ^= src>>24u; src *= M;\n    h *= M; h ^= src;\n    h ^= h>>13u; h *= M; h ^= h>>15u;\n    return h;\n}\n\nfloat hash11(float src) {\n    uint h = murmurHash11(floatBitsToUint(src));\n    return uintBitsToFloat(h & 0x007fffffu | 0x3f800000u) - 1.0;\n}\n\nuvec2 murmurHash22(uvec2 src) {\n    const uint M = 0x5bd1e995u;\n    uvec2 h = uvec2(1190494759u, 2147483647u);\n    src *= M; src ^= src>>24u; src *= M;\n    h *= M; h ^= src.x; h *= M; h ^= src.y;\n    h ^= h>>13u; h *= M; h ^= h>>15u;\n    return h;\n}\n\nvec2 hash22(vec2 src) {\n    uvec2 h = murmurHash22(floatBitsToUint(src));\n    return uintBitsToFloat(h & 0x007fffffu | 0x3f800000u) - 1.0;\n}\n\nfloat perlin(float p, float freq, float rep, float offset)\n{\n    p += offset / freq;\n    p *= freq;\n    \n\tvec2 i = vec2(floor(p)) + vec2(0.0, 1.0);\n    i = mod(i, vec2(rep * freq));\n\tfloat f = fract(p);\n\tfloat u = f * f * (3.0 - 2.0 * f);\n\treturn mix(hash11(i.x), hash11(i.y), u);\n}\n\nObjectInfo objectMin(ObjectInfo a, ObjectInfo b)\n{\n    if(a.dis < b.dis ) return a;\n    else return b;\n}\n\nMaterial objectMix(Material a, Material b, float k)\n{\n    Material outMat = a;\n    outMat.color0 = mix(a.color0, b.color0, k);\n    outMat.color1 = mix(a.color1, b.color1, k);\n    outMat.color2 = mix(a.color2, b.color2, k);\n    outMat.vect0 = mix(a.vect0, b.vect0, k);\n    outMat.vect1 = mix(a.vect1, b.vect1, k);\n    outMat.vect2 = mix(a.vect2, b.vect2, k);\n\toutMat.t0 = mix(a.t0, b.t0, k);\n    outMat.t1 = mix(a.t1, b.t1, k);\n    outMat.t2 = mix(a.t2, b.t2, k);\n    \n    return outMat;\n}\n\nObjectInfo objectSmoothMin(ObjectInfo a, ObjectInfo b, float k)\n{\n    float h = max(k - abs(a.dis - b.dis), 0.0);\n    ObjectInfo outInfo = a;\n    float rate;\n    if(a.dis < b.dis) rate = a.dis / b.dis * 0.5;\n    else rate = 1.0 - b.dis / a.dis * 0.5;\n    outInfo.material = objectMix(a.material, b.material, rate);\n    outInfo.dis = min(a.dis, b.dis) - h * h * 0.25 / k;\n    \n    return outInfo;\n}\n\nObjectInfo objectSmoothMinWithoutBlend(ObjectInfo a, ObjectInfo b, float k)\n{\n    float h = max(k - abs(a.dis - b.dis), 0.0);\n    ObjectInfo outInfo = a;\n    if(a.dis < b.dis) outInfo.material = a.material;\n    else outInfo.material = b.material;\n    \n    outInfo.dis = min(a.dis, b.dis) - h * h * 0.25 / k;\n    return outInfo;\n}\n\nfloat opExtrusion( in vec3 p, in float sdf, in float h )\n{\n    vec2 w = vec2( sdf, abs(p.z) - h );\n  \treturn min(max(w.x,w.y),0.0) + length(max(w,0.0));\n}\n\n// 3D Shape\n\nfloat sdEllipsoid(vec3 p, vec3 sdf_pos, vec3 sdf_rad)\n{\n    vec3 transPoint = p - sdf_pos;\n    float k0 = length(transPoint / sdf_rad);\n    float k1 = length(transPoint / (sdf_rad * sdf_rad));\n    return k0 * (k0-1.0) / k1;\n}\n\nfloat sdCapsule( vec3 p, vec3 sdf_pos_0, vec3 sdf_pos_1, float sdf_rad)\n{\n    vec3 pa = p - sdf_pos_0, ba = sdf_pos_1 - sdf_pos_0;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - sdf_rad;\n}\n\nfloat sdPlane( vec3 p, vec3 sdf_pos, vec3 sdf_normal)\n{\n    return dot(p - sdf_pos, sdf_normal);\n}\n\nfloat sdRoundCone( vec3 p, vec3 sdf_pos_0, vec3 sdf_pos_1, float sdf_rad_0, float sdf_rad_1 )\n{\n    vec3  ba = sdf_pos_1 - sdf_pos_0;\n    float l2 = dot(ba,ba);\n    float rr = sdf_rad_0 - sdf_rad_1;\n    float a2 = l2 - rr*rr;\n    float il2 = 1.0/l2;\n    \n    vec3 pa = p - sdf_pos_0;\n    float y = dot(pa,ba);\n    float z = y - l2;\n    float x2 = dot2( pa*l2 - ba*y );\n    float y2 = y*y*l2;\n    float z2 = z*z*l2;\n\n    float k = sign(rr)*rr*rr*x2;\n    if( sign(z)*a2*z2>k ) return  sqrt(x2 + z2)        *il2 - sdf_rad_1;\n    if( sign(y)*a2*y2<k ) return  sqrt(x2 + y2)        *il2 - sdf_rad_0;\n                          return (sqrt(x2*a2*il2)+y*rr)*il2 - sdf_rad_0;\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"# define RECOVER_TIME 2.0\n# define SENSITIVE 1.0\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 curRot = load(POINTER_ROT);\n    float time = load(POINTER_TIME).x;\n    float press = load(POINTER_PRESS).x;\n    vec4 mouse = load(POINTER_MOUSE);\n    float reset = load(POINTER_RESETCAM).x;\n    if(curRot == vec4(0.0)) curRot = vec4(0.0, 0.0, 0.0, 1.0);\n    \n    if(iMouse.z > 0.0)\n    {\n        if(press < 1.0)\n        {\n            press = 1.0;\n            mouse = iMouse;\n        }\n        \n        vec2 curAng = vec2(PI * SENSITIVE * (iMouse.x - mouse.x) / iResolution.x, PI * SENSITIVE * (mouse.y - iMouse.y) / iResolution.x); \n        curRot = quaternionMul(quaternionMul(vec4(sin(curAng.y / 2.0), 0.0, 0.0, cos(curAng.y / 2.0)), vec4(0.0, sin(curAng.x / 2.0), 0.0, cos(curAng.x / 2.0))), curRot);\n        mouse = iMouse;\n        \n        time = 0.0;\n        reset = 0.0;\n    }\n    else if(keyDown(81)) {\n        float curAng = -PI * SENSITIVE * iTimeDelta;\n        curRot = -quaternionMul(vec4(0.0, 0.0, sin(curAng / 2.0), cos(curAng / 2.0)), curRot);\n        reset = 0.0;\n        time = 0.0;\n    }\n    else if(keyDown(69)) {\n        float curAng = PI * SENSITIVE * iTimeDelta;\n        curRot = -quaternionMul(vec4(0.0, 0.0, sin(curAng / 2.0), cos(curAng / 2.0)), curRot);\n        reset = 0.0;\n        time = 0.0;\n    }\n    else if(keyClick(82)) {\n        reset = 1.0;\n        time = 0.0;\n    }\n    else\n    {\n        press = 0.0;\n        time += iTimeDelta;\n    }\n    \n    if(reset > 0.0) {\n        float progress = time / RECOVER_TIME;\n        curRot = quaternionLerp(curRot, vec4(0.0, 0.0, 0.0, 1.0), clamp(progress, 0.0, 1.0));\n        time += iTimeDelta;\n        \n        if(progress >= 1.0) reset = 0.0;\n    }\n    \n    store(POINTER_ROT, curRot);\n    store(POINTER_TIME, vec4(time));\n    store(POINTER_PRESS, vec4(press));\n    store(POINTER_MOUSE, mouse);\n    store(POINTER_RESETCAM, vec4(reset));\n}","name":"Buffer B","description":"","type":"buffer"}]}