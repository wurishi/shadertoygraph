{"ver":"0.1","info":{"id":"lXtXD4","date":"1719074477","viewed":60,"name":"chemical heartbeat","username":"garrisonhh","description":"stumbled across a really cool pattern while attempting to figure out hexagonal noise.","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["noise","glitch","hexagonal"],"hasliked":0,"parentid":"l3tXD4","parentname":"hex noise"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"precision highp int;\nprecision highp float;\n\nconst float TAU = 6.283185307179586;\n\nconst uint MAX_UINT = 2147483647u;\nconst uint FNV_PRIME = 2166136261u;\n\nconst float HEX_SIZE_PIX = 2e-2;\nconst float TIME_DILATION = 0.2;\nconst float CAMERA_CIRCLE_RADIUS = 1.0;\nconst float CAMERA_CIRCLE_SPEED = 0.1;\nconst float CAMERA_WAVE_AMPLITUDE = 0.25;\nconst float CAMERA_WAVE_SPEED = 0.33;\nconst float WARP_GRID_SIZE = 0.2;\nconst float WARP_CLAMP = 1.7;\nconst float WARP_AMPLITUDE = 0.015;\nconst float WARP_SPEED = 1.5;\nconst vec3 COLOR_A = vec3(58.0, 1.0, 92.0) / vec3(255.0);\nconst vec3 COLOR_B = vec3(201.0, 100.0, 128.0) / vec3(255.0);\nconst vec3 COLOR_C = vec3(59.0, 206.0, 172.0) / vec3(255.0);\nconst vec3 COLOR_D = vec3(17.0, 0.0, 28.0) / vec3(255.0);\n\n// glitch here\nfloat roundDown(float x) {\n    return x - abs(fract(x));\n}\n\n// found on stackoverflow lol\nfloat rand(vec2 co){\n    return fract(sin(dot(co, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n// pixel to axial (q, r)\nvec2 axialFromPixel(vec2 pixel) {\n    vec2 axial = vec2(\n        (sqrt(3.0) / 3.0) * pixel.x - (1.0 / 3.0) * pixel.y,\n        (2.0 / 3.0) * pixel.y\n    );\n    return axial / vec2(HEX_SIZE_PIX);\n}\n\n// round axial to integer boundaries\nvec2 axialRound(vec2 axial) {\n    float axial_s = -axial.x - axial.y;\n\n    float q = roundDown(axial.x);;\n    float r = roundDown(axial.y);\n    float s = roundDown(axial_s);\n\n    float q_diff = abs(q - axial.x);\n    float r_diff = abs(r - axial.y);\n    float s_diff = abs(s - axial_s);\n\n    if (q_diff > r_diff && q_diff > s_diff) {\n        q = -r - s;\n    } else if (r_diff > s_diff) {\n        r = -q - s;\n    }\n\n    return vec2(q, r);\n}\n\nvec2 cameraOffset() {\n    float circle_value = iTime * CAMERA_CIRCLE_SPEED;\n    vec2 circle_pos = vec2(cos(circle_value), sin(circle_value));\n    \n    float wave_value = iTime * CAMERA_WAVE_SPEED;\n    circle_pos *= CAMERA_CIRCLE_RADIUS + cos(wave_value) * CAMERA_WAVE_AMPLITUDE;\n\n    return circle_pos;\n}\n\nfloat zoomyWarp(vec2 uv) {\n    vec2 pos = uv / WARP_GRID_SIZE;\n    vec2 a = floor(pos);\n    vec2 b = vec2(a.x + 1.0, a.y);\n    vec2 c = vec2(a.x, a.y + 1.0);\n    vec2 d = vec2(a.x + 1.0, a.y + 1.0);\n    \n    float hash_a = rand(a);\n    float hash_b = rand(b);\n    float hash_c = rand(c);\n    float hash_d = rand(d);\n    \n    vec2 diff = pos - a;\n    \n    float value = mix(\n        mix(hash_a, hash_b, diff.x),\n        mix(hash_c, hash_d, diff.x),\n        diff.y\n    );\n    \n    return value;\n}\n\nvec2 zoomy(vec2 uv) {\n    float warp = zoomyWarp(uv);\n    warp += iTime * WARP_SPEED;\n    \n    float smoothed = (1.0 + cos(warp * TAU)) / 2.0;\n    float clamped = (smoothed * (1.0 + WARP_CLAMP * 2.0)) - WARP_CLAMP;\n    float value = clamp(0.0, 1.0, clamped);\n\n    vec2 dir = vec2(cos(value), sin(value));\n    return uv + dir * WARP_AMPLITUDE;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // get input coordinate\n    vec2 uv = (fragCoord / min(iResolution.x, iResolution.y)) - 0.5;\n    uv += cameraOffset();\n    uv = zoomy(uv);\n    \n    // convert coord to hash\n    vec2 axial_uv = axialFromPixel(uv);\n    vec2 axial_hex = axialRound(axial_uv);\n    float hash = rand(axial_hex);\n\n    // convert hash to color value\n    float value = fract(hash + iTime * TIME_DILATION);\n    value = smoothstep(0.0, 1.0, value);\n    value = (1.0 + cos(value * TAU)) / 2.0;\n\n    vec3 color_left = mix(\n        mix(COLOR_A, COLOR_B, value),\n        mix(COLOR_B, COLOR_C, value),\n        value\n    );\n    vec3 color_right = mix(\n        mix(COLOR_B, COLOR_C, value),\n        mix(COLOR_C, COLOR_D, value),\n        value\n    );\n    vec3 color = mix(color_left, color_right, value);\n\n    // color = vec3(zoomyWarp(uv));\n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}