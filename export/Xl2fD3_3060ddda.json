{"ver":"0.1","info":{"id":"Xl2fD3","date":"1517406460","viewed":470,"name":"sdf font - cos(mos);","username":"netgrind","description":"font developed for the branding of cos(mos); my new music project -> https://sinefool.bandcamp.com/album/etherealnet\nfont is chilling out in buffer A :)\nmouse x -> thickness\nmouse y -> thickness wobble","likes":7,"published":1,"flags":96,"usePreview":0,"tags":["music","text","font","cosmos"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 c1 = texture(iChannel0, fragCoord/iResolution.xy);\n    vec4 c2 = texture(iChannel1, fragCoord/iResolution.xy)*.5;\n    fragColor = max(c2,c1*2.)*.5;//abs(mod(c2+c1+1., 2.)-1.);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// inspired by and using some code from https://www.shadertoy.com/view/lddXzM by Andre\n// Font created by cale bradbury @netgrind.net - 2017\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\n#define line1 _  c_ o_ s_ brR m_ o_ s_ brL sc crlf e_ t_ h_ e_ r_ e_ a_ l_ n_ e_ t_\n\nvec2 size = vec2(1., -1.);\nvec2 edge = vec2(1., 0.);\nvec2 xLine = vec2(0., 0.);\nvec4 spacing = vec4(3., 2.25, 1.5, 3.5);\nfloat textWidth = .3;\n\n//font shapes\n\nfloat circle(vec2 uv){\n\treturn abs(length(uv)-size.x);   \n}\nfloat circleS(vec2 uv){\n\treturn abs(length(uv)-size.x*.5);   \n}\n\nfloat vert(vec2 uv){\n\treturn length(vec2(uv.x,max(0.,abs(uv.y)-size.x)));   \n}\nfloat halfvert(vec2 uv){\n\treturn length(vec2(uv.x,max(0.,abs(uv.y)-size.x*.5)));   \n}\nfloat hori(vec2 uv){\n\treturn length(vec2(max(0.,abs(uv.x)-size.x),uv.y));   \n}\nfloat halfhori(vec2 uv){\n\treturn length(vec2(max(0.,abs(uv.x)-size.x*.5),uv.y));   \n}\nfloat diag(vec2 uv){\n\treturn length(vec2(max(0.,abs((uv.y-uv.x))-size.x*2.),uv.y+uv.x));   \n}\nfloat halfdiag(vec2 uv){\n\treturn length(vec2(max(0.,abs(uv.x-uv.y)-size.x),uv.y+uv.x));   \n}\n\n// Here is the alphabet\nfloat aa(vec2 uv) {\n    float x = circle(uv);\n    x = mix(x, min(vert(uv-edge), vert(uv+edge)), step(uv.y, 0.));\n    x = min(x, hori(uv-xLine));\n    return x;\n}\nfloat bb(vec2 uv) {\n    float x = vert(uv+edge);\n    x = min(x, hori(uv-edge.yx));\n    x = min(x, hori(uv+edge.yx));\n    x = min(x, hori(uv-xLine));\n    x = mix(min(circleS(uv-size.xx*.5),circleS(uv-size*.5)),x, step(uv.x, .5));\n    return x;\n}\nfloat cc(vec2 uv) {\n    float x = circle(uv);\n    float p = .8;\n    float a = atan(uv.x, abs(uv.y));\n    a = smoothstep(.7, 1.5707, a);\n   \tx += a;\n    uv.y = -abs(uv.y);\n    x = min(length(uv+size.x*vec2(-cos(p), sin(p))), x);\n    return x;\n}\nfloat dd(vec2 uv) {\n    float x = vert(uv+edge);\n    x = min(x, hori(uv+edge.yx));\n    x = min(x, hori(uv-edge.yx));\n    x = mix(circle(uv),x, step(uv.x, 0.));\n    return x;\n}\nfloat ee(vec2 uv) {\n    float x = cc(uv);\n    x = mix(circle(uv), x, step(uv.y, 0.));\n    x = min(x, hori(uv));\n    return x;\n}\nfloat ff(vec2 uv) {\n   \tfloat x = vert(uv+edge);\n    x = min(x, hori(uv-edge.yx));\n    x = mix(circle(uv), x, step(min(-uv.x, uv.y), 0.));\n    x = min(x, halfhori(uv+edge*.5));\n    return x;\n}\nfloat gg(vec2 uv) {\n    float x = cc(uv);\n    x = mix(x, circle(uv), step(uv.y, 0.));\n    x = min(x, halfhori(uv-edge*.5));\n    return x;\n}\nfloat hh(vec2 uv) {\n    float x = vert(abs(uv)-edge);\n    x = min(x, hori(uv));\n    //x = min(x, circle(uv+edge.yx));\n    //x = mix(x, min(length(uv-size.xy), length(uv-size.yy)), step(uv.y, size.y));\n    return x;\n}\nfloat ii(vec2 uv) {\n    return hh(uv.yx);\n}\nfloat jj(vec2 uv) {\n    float x = vert(uv-edge);\n    x = min(x, length(uv+edge));\n    x = mix(x, circle(uv), step(uv.y, 0.));\n    return x;\n}\nfloat kk(vec2 uv) {\n    uv.y = abs(uv.y);\n    float x = circle(uv-edge.yx);\n    x = mix( length(uv-size.xx),x,step(uv.y, size.x)); \n    x = mix(x,min(vert(uv+edge), hori(uv)), step(uv.x, 0.));\n    return x;\n}\nfloat ll(vec2 uv) {\n    return min(vert(uv+edge), hori(uv+edge.yx));\n}\nfloat mm(vec2 uv) {\n    uv.x = abs(uv.x);\n    float x = vert(uv-edge);\n    x = min(x, halfvert(uv-edge.yx*.5));\n    x = mix( circleS(uv-size.xx*.5),x, step(uv.y, 0.5));\n    return x;\n}\nfloat nn(vec2 uv) {\n    float x = circle(uv);\n    x = mix(min(vert(uv-edge), vert(uv+edge)), x, clamp(ceil(uv.y), 0., 1.));\n    return x;\n}\nfloat oo(vec2 uv) {\n    return circle(uv);\n}\nfloat pp(vec2 uv) {\n    float x = hori(uv);\n    x = min(x, hori(uv-edge.yx));\n    x = mix( circleS(uv+size.yy*.5),x, step(uv.x, size.x*.5));\n    x = min(x, vert(uv+edge));\n    return x;\n}\nfloat qq(vec2 uv) {\n    float x = circle(uv);\n    x = min(x, halfdiag(uv-size.xy*.5));\n    return x;\n}\nfloat rr(vec2 uv) {\n    float x = min(hori(uv-edge.yx), vert(uv+edge));\n    x = mix(x, circle(uv), step(0., min(-uv.x, uv.y)));\n    return x;\n}\nfloat ss(vec2 uv) {\n    float x = hori(uv-edge.yx);\n    x = min(x, halfhori(uv));\n    vec2 u = uv;\n    u+=vec2(-size.y*.5, size.y*.5);\n    x = mix(circleS(u),x, step(-edge.x*.5, uv.x));\n    \n    float x2 = hori(uv+edge.yx);\n    x2= min(x2, halfhori(uv));\n    u = uv;\n    u-=vec2(-size.y*.5, size.y*.5);\n    x2 = mix(x2,circleS(u),step(edge.x*.5, uv.x));\n    \n    return min(x,x2);\n}\nfloat tt(vec2 uv) {\n    /*float x = min(hori(uv+edge.yx), vert(uv+edge));\n    x = mix( circle(uv),x, step(0., max(uv.x, uv.y)));\n    x = min(halfhori(uv+edge*.5), x);*/\n    float x = min(vert(uv), hori(uv-edge.yx));\n    return x;\n}\nfloat uu(vec2 uv) {\n    uv.x = abs(uv.x);\n    float x = mix(circle(uv), vert(uv-edge),  step(0., uv.y));\n    return x;\n}\nfloat vv(vec2 uv) {\n    uv.x = abs(uv.x);\n    float p = .5;\n    uv *= mat2(cos(p), -sin(p), sin(p), cos(p));\n    float x = vert(uv-edge*.5);\n    return x;\n}\nfloat ww(vec2 uv) {\n    uv.y = -uv.y;\n    return mm(uv);\n}\nfloat xx(vec2 uv) {\n    return diag(abs(uv)*vec2(-1., 1.));\n}\nfloat yy(vec2 uv) {\n    uv.x = abs(uv.x);\n    float x = min(halfvert(uv+edge.yx*.5), circle(uv-edge.yx));\n    x = mix(x, length(uv-size.xx), step(size.x, uv.y));\n    return x;\n}\nfloat zz(vec2 uv) {\n    float x = min(hori(uv-edge.yx), hori(uv+edge.yx));\n    uv.x = -uv.x;\n    return min(x, diag(uv));\n}\nfloat bracketRight(vec2 uv){\n    uv.x-=size.x*1.5;\n    float p = 1.3;\n    uv.y = abs(uv.y);\n    float a = atan(uv.x, uv.y);\n    float x = abs(length(uv)-size.x*2.);\n    uv.y = -uv.y;\n    x = mix(x, length(uv+vec2(cos(p), sin(p))*size.x*2.), step(-.3, a));\n    return x;\n}\nfloat bracketLeft(vec2 uv){\n    uv.x = -uv.x;\n    return bracketRight(uv);\n}\nfloat semicolon(vec2 uv){\n    float y = length(uv-edge.yx);\n    uv+= vec2(size.x*.5, size.x*.75);\n    float x = circleS(uv);\n    float z = min(length(uv-edge.xy*.5),length(uv+edge.yx*.5));\n    x = mix(z, x, step(max(uv.y, -uv.x),0.));\n    x = min(x, y);\n    return x;\n}\n\n//Render char if it's up\n#define ch(l)  x=min(x,l(uv+vec2(spacing.x*nr, 0.)));nr-=size.x;\n\n//Make it a bit easier to type text\n#define a_ ch(aa);\n#define b_ ch(bb);\n#define c_ ch(cc);\n#define d_ ch(dd);\n#define e_ ch(ee);\n#define f_ ch(ff);\n#define g_ ch(gg);\n#define h_ ch(hh);\n#define i_ ch(ii);\n#define j_ ch(jj);\n#define k_ ch(kk);\n#define l_ ch(ll);\n#define m_ ch(mm);\n#define n_ ch(nn);\n#define o_ ch(oo);\n#define p_ ch(pp);\n#define q_ ch(qq);\n#define r_ ch(rr);\n#define s_ ch(ss);\n#define t_ ch(tt);\n#define u_ ch(uu);\n#define v_ ch(vv);\n#define w_ ch(ww);\n#define x_ ch(xx);\n#define y_ ch(yy);\n#define z_ ch(zz);\n#define brR ch(bracketRight);\n#define brL ch(bracketLeft);\n#define sc ch(semicolon);\n\n//Space\n#define _ nr--;\n//Space\n#define _half nr-=.5;\n\n//Next line\n#define crlf uv.y += spacing.w; nr = 0.;\n\n\nconst int iterations =32;\nconst float dist_eps = .0001;\nconst float ray_max = 400.0;\nconst float fog_density = 0.01;\n\nfloat fField(vec3 p);\n\nvec3 dNormal(vec3 p)\n{\n   const vec2 e = vec2(0.01,0.0);\n   return normalize(vec3(\n      fField(p + e.xyy) - fField(p - e.xyy),\n      fField(p + e.yxy) - fField(p - e.yxy),\n      fField(p + e.yyx) - fField(p - e.yyx) ));\n}\n\nvec4 trace(vec3 ray_start, vec3 ray_dir)\n{\n   float ray_len = 0.0;\n   vec3 p = ray_start;\n   for(int i=0; i<iterations; ++i) {\n   \t  float dist = fField(p);\n      //if (dist < dist_eps) break;\n      if (ray_len > ray_max) return vec4(0.0);\n      p += dist*ray_dir;\n      ray_len += dist;\n   }\n   return vec4(p, 1.0);\n}\n\nvec3 shade(vec3 ray_start, vec3 ray_dir)\n{\n    vec4 hit = trace(ray_start, ray_dir);\n    \n  \tvec3 light_dir1 = normalize(vec3(1., 0.3, 1.));\n\n   float ray_len;\n   vec3 color;\n   if (hit.w == 0.0) {\n      ray_len = 1e16;\n      color = vec3(.0);\n   } else {\n      vec3 dir = hit.xyz - ray_start;\n      vec3 norm = dNormal(hit.xyz);\n    \n      float diffuse = max(0.0, dot(norm, light_dir1));\n      diffuse = clamp(diffuse, 0.0, 1.);\n      ray_len = distance(hit.xyz,ray_start);\n   \n      vec3 base_color = vec3(1.);\n\n       color.rgb = max((diffuse)*base_color, vec3(0.))+.3;\n   }\n   return color;\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord)\n{\n   vec2 uv = (fragCoord.xy - iResolution.xy*0.5) / iResolution.y;\n   float ang, si, co;\n   ang =0.;\n    float cam_dist = 20.;\n\n   vec3 pos = vec3(0., cam_dist,0.);\n   vec3 dir = normalize(vec3(uv.x,-1.,uv.y));\n   \n   \n   textWidth = .3+iMouse.x/iResolution.x;\n   vec3 color = shade(pos, dir);\n   fragColor = vec4(color, 1.);\n}\n\n\n// Rotate around a coordinate axis (i.e. in a plane perpendicular to that axis) by angle <a>.\n// Read like this: R(p.xz, a) rotates \"x towards z\".\n// This is fast if <a> is a compile-time constant and slower (but still practical) if not.\nvoid pR(inout vec2 p, float a) {\n\tp = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\n\nfloat text( vec3 pos )\n{\n    \n    vec3 p = pos;\n    pR(p.xy, iTime);\n    \n    pos.x+=15.;\n    pos.z-= 2.;\n    \n   // pR(pos.xy, sin(iTime)*.1);\n    //TODO optimize\n    spacing.y = spacing.x*.5;\n    spacing.z = 1./spacing.x;\n    \n    float x = 100.;\n    float nr = 0.;\n    vec2 uv = pos.xz; \n    float width = textWidth;\n    line1;\n    width+=sin(iTime*3.1415-length(pos.xz))*width*(iMouse.y/iResolution.y);\n    x = length(vec2(x, pos.y));\n    x-=width;\n    \n    \n    return x;\n        \n}\n\nfloat fField(vec3 p){\n    return text(p);\n    \n}\n","name":"Buf A","description":"","type":"buffer"},{"inputs":[{"id":"Md2Xzm","filepath":"https://soundcloud.com/cosine-of-moss/etherealnet-preview","previewfilepath":"https://soundcloud.com/cosine-of-moss/etherealnet-preview","type":"musicstream","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"//worley hacked from https://www.shadertoy.com/view/MllXRN by Lallis\n\n#define time iTime*0.25\n#define PI 3.14159265359\n\nmat3 rot(vec3 ang)\n{\n\tmat3 x = mat3(1.0,0.0,0.0,0.0,cos(ang.x),-sin(ang.x),0.0,sin(ang.x),cos(ang.x));\n\tmat3 y = mat3(cos(ang.y),0.0,sin(ang.y),0.0,1.0,0.0,-sin(ang.y),0.0,cos(ang.y));\n\tmat3 z = mat3(cos(ang.z),-sin(ang.z),0.0,sin(ang.z),cos(ang.z),0.0,0.0,0.0,1.0);\n\treturn x*y*z;\n}\n\nfloat noise3D(vec3 p)\n{\n\treturn fract(sin(dot(p ,vec3(12.,78.333,126.))) * 43758.);\n}\n\nfloat worley3D(vec3 p)\n{\t\t\t\t\t \t\t\t\t\t \n\tfloat r = 3.0;\n    vec3 f = floor(p);\n    vec3 x = fract(p);\n\tfor(int i = -1; i<=1; i++)\n\t{\n\t\tfor(int j = -1; j<=1; j++)\n\t\t{\n\t\t\tfor(int k = -1; k<=1; k++)\n\t\t\t{\n                vec3 q = vec3(float(i),float(j),float(k));\n    \t\t\tvec3 v = q + vec3(noise3D((q+f)*1.11), noise3D((q+f)*1.14), noise3D((q+f)*1.17)) - x;\n    \t\t\tfloat d = dot(v, v);\n\t\t\t\tr = min(r, d);\n\t\t\t}\n\t\t}\n\t}\n    return sqrt(r);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord.xy/iResolution.xy;\n\tvec2 p = uv*2.0-1.0;\n    p*=sin(time*.1)*.25-.75;\n    float d = length(p);\n    p = abs(p);\n\tp.x*=(iResolution.x/iResolution.y);\n\tvec3 col = vec3(0.1,0.2,0.3);\n    vec3 ro = vec3(0.0,0.0,-1.0);\n    vec3 rd = normalize(vec3(p,0.0)-ro);\n    vec3 ang = vec3((sin(time+d*cos(time*.666)*4.)*.1), cos(time-p.y*2.)*.1, 0.);\n    rd.x+=texture(iChannel0, vec2(abs(rd.x*.2), 0.)).r*.1;\n    rd.y*=1.-texture(iChannel0, vec2(abs(rd.y*.1), 0.)).r*.5;\n    ro*=rot(ang);\n    rd*=rot(ang);\n    vec3 rp = ro;\n    float t = 1.0;\n    float w;\n    float ww;\n    vec3 add;\n    \n    rp = ro + rd*(12.0*(sin(length(p)-time-sin(time))+1.5)+0.5);\n    w = worley3D(rp+vec3(0.0,0.0,time));\n    ww = w*w*w*w*w*w*(4.0/distance(rp,ro));\n    add = vec3(0.12,0.35,0.5)*5.;\n    col = mix(col, add , ww);\n    \n\tcol = pow(col, vec3(3.));\n    rp = ro + rd*(8.0);\n    w = worley3D(rp+vec3(0.0,0.0,time));\n    ww = w*w*w*w*w*w*(2.0/distance(rp,ro));\n    add = vec3(0.0,1.65,1.0)*5.;\n    col = mix(col, add , ww);\n    \n    rp = ro + rd*(12.0);\n    w = worley3D(rp+vec3(0.0,0.0,time));\n    ww = w*w*w*w*w*w*(2.0/distance(rp,ro));\n    add = vec3(1.0,0.81,0.0)*15.;\n    col = mix(col, add , ww);\n    \n\tfragColor = vec4(col*rot(ang*.05),1.0);\n}","name":"Buf B","description":"","type":"buffer"}]}