{"ver":"0.1","info":{"id":"llyGWc","date":"1477082518","viewed":192,"name":"Soft n Mushy","username":"Xafer","description":"Some sort of underwater scene or something","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["perlin","grass"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define NEAR 0.01\n#define FAR 10.0\n\n#define STEP_SIZE 0.6\n#define MAX_ITER 200\n#define DELTA 0.005\n#define A_SPEED 0.1\n#define CAM_DIST 3.0\n\n#define RECAST_MAX 5\n\n#define GLOW_POWER 6.0\n#define GLOW_COLOR vec3(0.2,0.4,0.4)\n#define GRASS_SIZE vec2(0.005,0.4)\n\n#define SKY_COLOR vec3(0.1,0.3,0.4)\n\n#define ONE 0.00390625\n#define ONEHALF 0.001953125\n\n#define PIXEL_SCALE 1.0\n\nfloat fade(float t) {\n  // return t*t*(3.0-2.0*t); // Old fade, yields discontinuous second derivative\n  return t*t*t*(t*(t*6.0-15.0)+10.0); // Improved fade, yields C2-continuous noise\n}\n\nfloat noise(vec2 P)\n{\n  vec2 Pi = ONE*floor(P)+ONEHALF; // Integer part, scaled and offset for texture lookup\n  vec2 Pf = fract(P);             // Fractional part for interpolation\n\n  // Noise contribution from lower left corner\n  vec2 grad00 = texture(iChannel0, Pi).rg * 4.0 - 1.0;\n  float n00 = dot(grad00, Pf);\n\n  // Noise contribution from lower right corner\n  vec2 grad10 = texture(iChannel0, Pi + vec2(ONE, 0.0)).rg * 4.0 - 1.0;\n  float n10 = dot(grad10, Pf - vec2(1.0, 0.0));\n\n  // Noise contribution from upper left corner\n  vec2 grad01 = texture(iChannel0, Pi + vec2(0.0, ONE)).rg * 4.0 - 1.0;\n  float n01 = dot(grad01, Pf - vec2(0.0, 1.0));\n\n  // Noise contribution from upper right corner\n  vec2 grad11 = texture(iChannel0, Pi + vec2(ONE, ONE)).rg * 4.0 - 1.0;\n  float n11 = dot(grad11, Pf - vec2(1.0, 1.0));\n\n  // Blend contributions along x\n  vec2 n_x = mix(vec2(n00, n01), vec2(n10, n11), fade(Pf.x));\n\n  // Blend contributions along y\n  float n_xy = mix(n_x.x, n_x.y, fade(Pf.y));\n\n  // We're done, return the final noise value.\n  return n_xy;\n}\n\nfloat tnoise(vec3 p)\n{\n    return (noise(p.xz/5.0) + (noise(p.xz/2.0))/12.0)*4.0;\n}\n\nvec3 displaceTerrain(vec3 p)\n{\n    p.y += tnoise(p) ;\n    return p;\n}\n\nvec3 displaceGrass(vec3 p)\n{\n    p = displaceTerrain(p);\n    p.x += sin(p.z + p.y*3.0 + iTime/2.0)/8.0 * (p.y*3.0) + cos(p.x + p.y*6.0 + iTime*3.0)/20.0 * (p.y*6.0);\n    p.y -= abs(sin(p.x*20.01124 + p.z*24.0241)/20.0);\n    \n    p.x += sin(p.z*12.042)*0.04 +  sin(p.z*9.1230)*0.06;\n    p.z += sin(p.x*9.612)*0.03 +  sin(p.x*13.3231)*0.055;\n    \n    return p;\n}\n\nfloat sdGrassField(vec3 p)\n{\n    vec3 q = displaceTerrain(p);\n    \n    vec3 grassDist = vec3(0.05,0,0.05);\n\tvec3 pg = displaceGrass(p) + grassDist * 0.5;\n\tvec3 k = floor (pg / grassDist);\n\tpg -= grassDist * (k + 0.5);\n    \n    vec2 b = GRASS_SIZE;\n    \n    float g = length(max(abs(pg)-vec3(b,0.001),0.0));\n    float f = -q.y;\n    \n    return min(f,g);\n}\n\nfloat sdSphere(vec3 p)\n{\n    p += vec3(0,0,0);\n    return length(p) - 1.0;\n}\n\nfloat map(vec3 p)\n{\n    return sdGrassField(p);//min(sdSphere(p),);\n}\n\nfloat getLightFactor(vec3 p,vec3 normal)\n{\n    vec3 lightPos = vec3(0,-2.0,iTime);\n    vec3 lp = p - lightPos;\n    float power = 3.0;\n    float intensity = max(1.0-length(lp)/power,0.0);\n    float dist = 1.0-dot(normalize(lp),normal);\n    \n    float factor = intensity*dist;\n        \n    return factor;\n}\n\nvec3 castRay(vec3 pos, vec3 dir)\n{\n    //Initialize RayMarching\n    vec3 p = pos;\n    float rl = 0.0;\n    \n    vec3 color = vec3(0);//Output color\n    \n    float near = FAR;\n    float iters = 0.0;\n    \n    //March\n    for(int i = 0; i < MAX_ITER; i++)\n    {\n        near = map(p);//Nearest surface distance\n        \n        rl += near;\n        if(near <= DELTA || rl > FAR)//If the ray hits something\n        {\n            break;\n        }\n        p += STEP_SIZE*near*dir;//March forward\n        iters++;\n    }\n    \n    if(near >= DELTA)//If the point is outside a volume\n    {\n        vec3 a = SKY_COLOR;\n        vec3 b = GLOW_COLOR;\n        float n = pow(iters/float(MAX_ITER), 1.0/GLOW_POWER);\n        color = mix(a,b,n);\n    }\n    else\n    {\n        vec2 delta = vec2 (DELTA, 0.0);\n\t\tvec3 normal = normalize (vec3 (\n\t\t\tmap (p + delta.xyy) - map (p - delta.xyy),\n\t\t\tmap (p + delta.yxy) - map (p - delta.yxy),\n\t\t\tmap (p + delta.yyx) - map (p - delta.yyx)));\n        \n        float lightFactor = getLightFactor(p,normal);\n        \n        vec3 sky = GLOW_COLOR;\n        \n        vec2 ss = p.xz*2.0;\n        \n        color = vec3(texture(iChannel0, mod(ss.xy/30.0,vec2(1))).r/1.7,texture(iChannel0, mod(ss.xy/30.0,vec2(1))).g/1.5,0);\n        color = mix(color,sky/3.0,1.0-lightFactor);\n        float fog = clamp(rl / FAR,0.0,1.0);\n        color = mix(color,GLOW_COLOR,fog);\n    }\n   \t\n    //color += vec3(pow(iters/float(MAX_ITER), 1.0/GLOW_POWER));\n    //fog\n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //Pixel scaling. Coulda done that somewhere else to prevent rendering the same pixel\n    vec2 fc;\n    fc.x = floor(fragCoord.x/PIXEL_SCALE)*PIXEL_SCALE;\n    fc.y = floor(fragCoord.y/PIXEL_SCALE)*PIXEL_SCALE;\n    \n    //Setting up screen-correct uv\n\tvec2 uv = ( fc.xy / iResolution.xy ) * 2.0 - vec2( 1 );\n    uv.x *= iResolution.x/iResolution.y;\n    \n    //Setting up rotation\n    float sa = sin( iTime * A_SPEED );\n    float ca = cos( iTime * A_SPEED );\n    \n    //Creating ray\n    vec3 or = vec3(sa*CAM_DIST,0,-ca*CAM_DIST + iTime);\n    or.y = -tnoise(or)-1.3;\n    vec3 di = -normalize(vec3(uv.x,uv.y,-1.0));\n    \n    //Rotating orientation\n    mat3 r;\n    r[0] = vec3(ca,0,sa);\n    r[1] = vec3(0,1,0);\n    r[2] = vec3(-sa,0,ca);\n    di = r*di;\n    \n    vec3 color = castRay(or,di);\n    \n\tfragColor = vec4(color,1);\n}","name":"Image","description":"","type":"image"}]}