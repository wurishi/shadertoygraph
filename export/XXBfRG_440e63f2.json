{"ver":"0.1","info":{"id":"XXBfRG","date":"1730063774","viewed":67,"name":"foggy lights","username":"ebajec","description":"foggy","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["fog"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float PI = 3.141592654;\nconst float inf = 1e9;\nconst float epsilon = 0.0001;\n\nvec4 quat_mult(vec4 q1, vec4 q2) {\n    return vec4(\n        q1.w * q2.x + q1.x * q2.w + q1.y * q2.z - q1.z * q2.y, \n        q1.w * q2.y - q1.x * q2.z + q1.y * q2.w + q1.z * q2.x, \n        q1.w * q2.z + q1.x * q2.y - q1.y * q2.x + q1.z * q2.w, \n        q1.w * q2.w - q1.x * q2.x - q1.y * q2.y - q1.z * q2.z  \n    );\n}\n\nvec3 rotate(vec3 v, vec3 axis, float angle)\n{\n    vec4 exp_q = vec4(cos(angle/2.0),sin(angle/2.0)*axis);\n    vec4 exp_q_conj = vec4(exp_q.x,-exp_q.yzw);\n    vec4 v_p = vec4(0.0,v);\n\n    vec4 result = quat_mult(quat_mult(exp_q,v_p),exp_q_conj);\n    \n    return result.yzw;\n}\n\nvec3 palette(float t) {\n    float b = 0.7*cos(2.0*PI*t);\n    return clamp(vec3(0.5 - b,0.8 - b,2.0 + b),0.0,1.0);\n}\n\nfloat dot2(vec3 v) {return dot(v,v);}\n\nstruct Result\n{\n    float d; \n    vec3 c;\n};\n\nResult torus(vec3 p,vec3 c, vec2 t, float phase) \n{\n    p = rotate(p-c,normalize(vec3(0,0,1.0)),phase + iTime);\n    \n    float r = length(p.xz) - t.x;\n    float theta = atan(p.z,p.x);\n    float phi = atan(p.y,r);\n    vec2 q = vec2(r, p.y);  // Flatten to 2D on the xz-plane, then offset by major radius\n    \n    Result result;\n    result.d = length(q) - t.y;\n    result.c = palette(phi/(2.0*PI));\n    return result;\n}\n\nResult sphere(vec3 p, vec3 o , float r)\n{\n    vec3 d = p-o;\n    \n    float s_dist = sqrt(d.x*d.x + d.y*d.y + d.z*d.z);\n   \n    float value = s_dist-r;\n    \n  \n    Result result;\n    result.d = value;\n    result.c = vec3(1.0,0.0,0.0);\n    return result;\n}\n\nResult sdf(vec3 v)\n{   \n    Result res; \n    res.d = inf;\n    res.c = vec3(1.0);\n    \n\n    Result rs = sphere(v,vec3(2.3*sin(iTime),2.3*cos(iTime),0.0),0.5);\n    \n    if (rs.d < res.d) res = rs;\n    \n    Result rt = torus(v,vec3(0,0,0),vec2(1.0,0.2),0.4);; \n    if (rt.d < res.d) res = rt;\n    \n    return res;\n\n}\n\nstruct SurfacePoint\n{\n    vec3 p;\n    vec3 n;\n    vec3 c;\n};\n\nvec3 sdf_grad(vec3 p)\n{\n    const float h = 0.0001;\n    const float denom = 1.0/(h);\n    \n    float v = sdf(p).d;\n    \n    float delx = denom*(sdf(p + vec3(h,0,0)).d - v);\n    float dely = denom*(sdf(p + vec3(0,h,0)).d - v);\n    float delz = denom*(sdf(p + vec3(0,0,h)).d - v);\n    \n    vec3 grad = vec3(delx,dely,delz);\n    return grad;\n}\n\nSurfacePoint march_ray(vec3 o, vec3 ray, float max_dist)\n{\n    const int max_steps = 60;\n    int steps = 0;\n\n    SurfacePoint S = SurfacePoint(o,vec3(0),vec3(0));\n    \n    // Intersect ray; \n    float dist_min = inf;\n    \n    vec3 integral = vec3(0);\n    \n    for (int i = 0 ; i < max_steps; i++)\n    {\n        Result result = sdf(S.p);\n        float dist = result.d;\n        if (dist < dist_min) dist_min = dist;\n        if (dist <= epsilon) break;\n        S.p += dist*ray;   \n        S.c = result.c;\n        \n        if (dot2(o-S.p) > max_dist*max_dist) \n        {\n            S.c = vec3(0);\n            return S;\n        }\n    }\n    \n    S.n = normalize(sdf_grad(S.p));\n    S.p += epsilon*S.n;\n    \n    return S;\n}\n\nstruct RadianceField\n{\n    vec3 v;\n    vec3 c;\n    float f;\n};\n\nRadianceField Ls(vec3 p)\n{\n    vec3 c1 = vec3(0,1.5,0);\n    vec3 c2 = vec3(0,-1.5,0);\n    Result rs = sphere(p,c1,0.1); \n    Result rt = sphere(p,c2,0.1);\n    \n    vec3 d1 = normalize(c1-p);\n    vec3 d2 = normalize(c2-p);\n    \n    SurfacePoint r1 = march_ray(p,d1,1000.0);\n    SurfacePoint r2 = march_ray(p,d2,1000.0);\n    \n    float m1 = dot2(r1.p-p) > dot2(c1-p) ? 1.0 : 0.0;\n    float m2 = dot2(r2.p-p) > dot2(c2-p) ? 1.0 : 0.0;\n    \n    float f1 = 4.0*pow(sin(iTime),2.0)/(1.0 + rs.d*rs.d);\n    float f2 = 4.0*pow(cos(iTime),2.0)/(1.0 + rt.d*rt.d);\n    \n    vec3 color = 1.0*vec3(1.0,0.0,0.0)*m1*f1 \n               +1.0*vec3(0.1,0.1,1)*m2*f2;\n    \n    vec3 dir = normalize(m1*f1*d1 + m2*f2*d2);\n    \n    return RadianceField(dir,color,f1+f2);\n}\n\n\nfloat sig_s(vec3 p)\n{\n    vec3 c = 2.0*vec3(0,0.0,2.0);\n    float r = length(p-c);\n    float a = 2.0;\n    float b = 2.0;\n    float er = exp(-r);\n    return 0.1;\n}\nfloat sig_a(vec3 p)\n{\n    return 0.1;//*clamp(p.y,0.0,1.0);\n}\n\nfloat sig_t(vec3 p)\n{\n    return sig_a(p) + sig_s(p);\n}\n\nvec3 dL(vec3 L, vec3 p,vec3 dir) \n{\n    RadianceField f = Ls(p);\n    return -sig_t(p)*L + sig_s(p)*f.c;\n}\n\nfloat fsmooth(float t)\n{\n    return (1.0+t*t)/4.0;\n}\n\nSurfacePoint integrate_light(vec3 o, vec3 ray, float max_dist)\n{\n    const int max_steps = 200;\n    int steps = 0;\n\n    SurfacePoint S = march_ray(o,ray,max_dist);\n    \n    bool intersects = dot2(S.c) > epsilon;\n    \n    float s_max = length(S.p-o);\n    float s = 0.0;\n    \n    vec3 P = intersects ? S.p : o;\n\n    vec3 L0 = vec3(0);\n    vec3 L1 = L0;\n    \n    vec3 integral = vec3(0);\n    \n    for (int i = 0 ; i < max_steps; i++)\n    {         \n        RadianceField field = Ls(P);\n        \n        if (field.f < 0.01) break;\n        \n        float mult = 0.1/field.f;\n        \n        float ds = mult;  \n        \n        P += (intersects ? -1.0 : 1.0) * ds*ray; \n        s += ds;\n        \n        L1 = L0 + ds*dL(L0,P,ray);\n        \n        integral += 0.5*(L0 + L1)*ds*exp(-sig_t(P)*s);\n        \n        L0 = L1; \n        \n        if (s >= s_max) break;\n    }\n    \n    if (intersects)\n    {\n        RadianceField rad = Ls(S.p);\n        float incidence =  max(dot(rad.v,S.n),0.0);\n        S.c = S.c*rad.c*incidence;\n    }\n        \n    S.c += integral;\n\n    return S;\n}\n\nmat3 view(vec3 normal)\n{\n\tvec3 basis[3];\n\n\tnormal = normalize(normal);\n\tbasis[2] = normal;\n\tbasis[0] = normalize(cross(normal, vec3(0,0,1)));\n\tbasis[1] = cross(basis[0], basis[2]);\n\n\treturn mat3(basis[0],basis[1],basis[2]);\n}\n\n\nconst float max_dist = 1000.0;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    float aspect = iResolution.y/iResolution.x;\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    float t = 0.0;\n    \n    vec3 o = 4.0*vec3(cos(t),sin(t),0.86);\n    vec3 n = -o;\n    o += vec3(0,0,0);\n    mat3 coords = view(n);\n    vec2 sp = (2.0*uv - vec2(1.0,1.0))*vec2(1.0,aspect);\n    vec3 ray = normalize(coords[2] + sp.x*coords[0]+ sp.y * coords[1]);\n    \n    SurfacePoint S = integrate_light(o,ray,1000.0);\n    vec3 color = S.c;\n  \n    // Output to screen\n    fragColor = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"}]}