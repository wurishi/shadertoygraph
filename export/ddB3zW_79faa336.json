{"ver":"0.1","info":{"id":"ddB3zW","date":"1667296127","viewed":69,"name":"Volumetric Lightmap Vis","username":"ShadingKnight","description":"try to use sdf instancing for volumetric lightmap visualization.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["sdf","visualization","probe"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"struct Ray\n{\n    vec3 origin;\n    vec3 dir;\n};\n\nstruct Sphere\n{\n    vec3 center;\n    float radius;\n};\n\nstruct Camera\n{\n    vec3 pos;\n    vec3 target;\n};\n\nbool displayUVW = false;\nfloat vlmCellSize = 1.0f;\nvec3 vlmDimension = vec3(10.0, 10.0, 10.0);\n\nvec3 positionToUVW(vec3 posW)\n{\n    vec3 volumeSize = vlmCellSize * vlmDimension;\n    vec3 uvw = posW / volumeSize;\n    return uvw;\n}\n\nCamera createCamera(in float time)\n{\n    Camera camera;\n    float an = 0.3 + 1.0 * time;\n\tcamera.pos = vec3(float(5.0f)*4.*sin(an),60.0,float(5.0f) * 4.*cos(an));\n    camera.target = 0.5f * vlmCellSize * vlmDimension;\n    return camera;\n}\n\nmat3 createCameraMatrix(Camera camera)\n{\n    vec3 ww = normalize(camera.target - camera.pos);\n    vec3 uu = normalize(cross(ww, vec3(sin(0.0), cos(0.0), 0.0)));\n    vec3 vv = normalize(cross(uu, ww));\n    return mat3(uu, vv, ww);\n}\n\nRay createCameraRay(vec2 p, Camera camera)\n{\n    Ray cameraRay;\n    cameraRay.origin = camera.pos;\n    mat3 camMat = createCameraMatrix(camera);\n\tcameraRay.dir = normalize(camMat * vec3(p.xy,8.0));\n    return cameraRay;\n}\n\n// https://iquilezles.org/articles/distfunctions/\nvec3 opRepLim(in vec3 p, in float c, in vec3 l)\n{\n    return c * clamp(round(p / c), vec3(0.0f), l);\n}\n\nfloat sdSphere(vec3 pos, Sphere sphere)\n{\n    return length(pos - sphere.center) - sphere.radius;\n}\n\nfloat map(vec3 p)\n{     \n    Sphere sphere;\n    sphere.center = opRepLim(p, vlmCellSize, vlmDimension - vec3(1.0, 1.0, 1.0));\n    sphere.radius = 0.25 * vlmCellSize;\n    float res = sdSphere(p, sphere);\n    return res;\n}\n\nvec3 sampleAmbientCube(vec3 ambientCubeCoeff[6], vec3 n)\n{\n    vec3 dirSquared = n * n;\n    vec3 result\n        = dirSquared.x * (n.x < 0.0 ? ambientCubeCoeff[0].xyz : ambientCubeCoeff[1].xyz)\n        + dirSquared.y * (n.y < 0.0 ? ambientCubeCoeff[2].xyz : ambientCubeCoeff[3].xyz)\n        + dirSquared.z * (n.z < 0.0 ? ambientCubeCoeff[4].xyz : ambientCubeCoeff[5].xyz);\n\n    return result;\n}\n\nvec3 ambientCube[6] = vec3[6](vec3(1.0), vec3(0.8), vec3(0.2), vec3(0.7), vec3(0.3), vec3(0.0));\n\nvec3 shade( in vec3 pos, in vec3 nor, in vec3 rd, in float dis)\n{\n    vec3 uvw = positionToUVW(pos);\n    if (displayUVW)\n    {\n        return uvw;\n    }\n    vec3 lin = sampleAmbientCube(ambientCube, nor);\n    return lin;\n}\n\nstruct RayQuery\n{\n    bool valid;\n    float t;\n};\n\nRayQuery raycast(Ray ray)\n{\n    const float tMax = 200.0;\n\n    RayQuery result;\n    result.valid = true;\n    result.t = 0.0;\n\n    for(int i = 0; i < 70; i++)          \n    {\n        if (result.t > tMax)\n        {\n            result.valid = false;\n            return result;\n        }\n\n        float h = map(ray.origin + ray.dir * result.t);\n        if (h < (0.0001 * result.t))\n        {\n            return result;\n        }\n        result.t += h;\n    }\n\n    return result;\n}\n\nvec3 calcNormal(in vec3 pos)\n{\n    const float eps = 0.002;\n\n    const vec3 v1 = vec3( 1.0, -1.0, -1.0);\n    const vec3 v2 = vec3(-1.0, -1.0, 1.0);\n    const vec3 v3 = vec3(-1.0, 1.0, -1.0);\n    const vec3 v4 = vec3( 1.0, 1.0, 1.0);\n\n\treturn normalize(v1 * map(pos + v1 * eps) + \n\t\t\t\t\t  v2 * map(pos + v2 * eps) + \n\t\t\t\t\t  v3 * map(pos + v3 * eps) + \n\t\t\t\t\t  v4 * map(pos + v4 * eps));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (-iResolution.xy + 2.0 * fragCoord.xy) / iResolution.y;\n    vec2 m = iMouse.xy / iResolution.xy;\n    \n    Camera cam = createCamera(iTime);\n    Ray ray = createCameraRay(p, cam);\n\n    vec3 col = vec3(0.0);\n    \n    RayQuery query = raycast(ray);\n    if (query.valid)\n    {\n        vec3 pos = ray.origin + query.t * ray.dir;\n        vec3 nor = calcNormal(pos);\n\n        col = shade(pos, nor, ray.dir, query.t);\n    }\n    \n\tcol = pow(clamp(col, 0.0, 1.0), vec3(0.4545));\n\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}