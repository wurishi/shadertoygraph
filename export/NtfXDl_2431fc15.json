{"ver":"0.1","info":{"id":"NtfXDl","date":"1626759788","viewed":216,"name":"Voxel Tunnel Example","username":"Yusef28","description":"First Voxel shader:\n- Branchless DDA\n- Diffuse & Specular Lighting \n\nIt's a pretty barebones example. The coloring is not entirely correct but it'll do for now. [Fixed!]","likes":12,"published":1,"flags":0,"usePreview":0,"tags":["3d","raymarching","raycasting","voxel"],"hasliked":0,"parentid":"-1","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","previewfilepath":"/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//////////////////////////////////////////////////////\n// Voxel Tunnel Example By Yusef28\n// Purpose: Demonstrates Voxel DDA + Voxel Lighting\n// Well commented and fit for some educational purposes\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// 20-07-2021\n\n// Listening to: Com Truise - Diluted (Compilation Mix)\n\nmat2 rot(float a){\n    float si = sin(iTime);\n    float cs = cos(iTime);\n    return mat2(cs,-si,si,cs);\n}\nfloat sdSphere(vec3 p, float d) { return length(p) - d; } \n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) +\n         length(max(d,0.0));\n}\n\t\nfloat hash31( vec3 p )\n{\n\tp = vec3( dot(p,vec3(127.1,311.7, 74.7)),\n\t\t\t  dot(p,vec3(269.5,183.3,246.1)),\n\t\t\t  dot(p,vec3(113.5,271.9,124.6)));\n\n\treturn fract(sin(p.x+p.y+p.z)*43758.5453123);\n}\nfloat g = 0.;\nbool map(vec3 c) {\n\tvec3 p = floor(vec3(c)) + vec3(0.5);\n\tfloat d = min(max(-sdSphere(p, 7.5), sdBox(p, vec3(6.0))), -sdSphere(p, 25.0));\n    float tunnel = (10. - length(p.xy + vec2(sin(p.z/8.)*6., 0.)));\n    d = max(d, tunnel);\n    if(min(d,tunnel) == tunnel){\n        if(hash31(floor(p)) < 0.2){\n            g += 1./pow(d,1.);\n        }\n    }\n    \n\treturn d < 0.0;\n}\n\n\nvec2 rotate2d(vec2 v, float a) {\n\tfloat sinA = sin(a);\n\tfloat cosA = cos(a);\n\treturn vec2(v.x * cosA - v.y * sinA, v.y * cosA + v.x * sinA);\t\n}\n\n//putting the raycasting in a function so I can use it\n//for other things\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t// Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-iResolution.xy*0.5)/iResolution.xy;\n    //We need the same basic things as for ray casting\n    //but in 3d now\n    \n    //cam origin, cam direction\n    vec3 co = vec3(0.,0.,iTime*6.);\n    vec3 cd = vec3(0.,0.,0.8);\n   // cd.x = sin(co.z/16.)/5.;\n    //projection plane origin(not used? and direction 90 deg to cam dir\n    vec3 po = cd;\n    vec3 pd = cd;\n    //here we can't use the simple perpendicular to cd vector\n    //because we are in 3d, so we really need to develope a set of \n    //basis vectors for this one. Nothing fancy\n    //instead of this: pd.*mat2(0.,-1.,1.,0.);\n    //we'll have this:\n    //decide on a up, we'll be cheap and say it's y = 1.\n    vec3 up = vec3(0.,1.,0.);\n    //right will be a vector perpendicular to both our cd and current up\n    vec3 right = cross(up,cd);\n    //up was just a placeholder for a vector in that plane\n    //the actual up is found by crossing to get a new perpendicular\n    //vector in that plane\n    up = cross(right,cd);\n    //good cd,up,right is our basis and we'll use right and up\n    //as our projection plane very soon\n    \n    //ray origin\n    vec3 rayPos = co;\n    //and ray dir which sums the right and up components based on percentage\n    //the current pixel is along that axis from origin\n    //and a focal length which will just be the cd with a scalar maybe\n    vec3 rayDir = right*uv.x + up*uv.y + cd;\n    rayDir = normalize(rayDir);\n\n\t    \n     vec3 deltaDist = abs(1./rayDir + 0.0001);\n    //the starting int positions for every component\n    //pushing away by 0.5 in every direction which we'll correct later\n    //to give us floor/ceil with less hastle as other methods\n    vec3 mapPos = vec3(floor(rayPos) + 0.5);\n    //sign gives us either 1, -1, or 0?\n    //so it's will allow movements by one unit in or require directions\n    vec3 rayStep = sign(rayDir);\n    vec3 sideDist = ((mapPos - rayPos) + 0.5*(sign(rayDir)))*deltaDist*sign(rayDir);\n\tbvec3 mask;\n\tfloat h;\n    \n\tfor (float i = 0.; i < 124.; i++) {\n        //if we hit something break\n\t\tif (map(mapPos)) break;\n            \n            //we haven't so we get our mask which is just\n            //finding which of the 3 components is closest to us so we can\n            //make a step in that direction\n            //the min will give for y=2,z=3,x=1 -> 2, 1, 1\n            //less than will give True,False,False, always just one true\n            mask = lessThanEqual(sideDist.xyz, min(sideDist.yzx, sideDist.zxy));\n\t\t\t//we use mask to update side and start in a branchless manner\n            //by masking out what we want to leave unchanged\n            //step in the chosen direction by one unit\n            sideDist += vec3(mask) * deltaDist;\n            //step along the ray for the chosen ray component, by it's delta\n            //with the right direction\n\t\t\tmapPos += vec3(mask) * rayStep;\n            \n            //and this I was using as a sort of faux distance\n            //to set a far plane\n            h++;\n\t}\n\t\n    //The next few lines I found in shanes voxel shader \n    //which apparently came from iq\n    //this first line...\n    vec3 tCube = (mapPos - rayPos - 0.5*sign(rayDir))/rayDir;\n\t//is the calculation for a perpedicular distance from the\n    //projection plane to the closest side on a given voxel\n    //Here is an example from a 2.5 d raycaster:https://lodev.org/cgtutor/raycasting.html\n    //The code is:\n    //if (side == 0) perpWallDist = (mapX - posX + (1 - stepX) / 2) / rayDirX;\n    //else perpWallDist = (mapY - posY + (1 - stepY) / 2) / rayDirY;\n    //the only difference between that and what we use,\n    //beside it being 3d, is Lode Vandevenne uses branching.\n    float t = max(tCube.x,max(tCube.y,tCube.z));\n    //This is important. Why can't we just use the euclidean distance?\n    //I don't know but we wont. We'll use this.\n    \n    //Now we can do all the texturing, lighting(norm is -mask*sign(rd))\n    //reflections etc that shane does!\n    \n    //this gives us our point in the world after raycasting\n    vec3 vPos = rayPos + t*rayDir;\n    \n    //this gives us a good -0.5 to 0.5 coord for texturing\n    vec3 fVPos = fract(vPos)-0.5;\n   \n    //for texture\n    float scale = 4.;\n    vec3 color;\n    \n    //for box borders\n    float thickness = 0.4;\n    float outLine;\n    vec3 outLineCol = vec3(0.2);\n    \n    //for specific color\n    float id = hash31(mapPos);\n    vec3 idCol = 0.65+0.5*cos(vec3(4.,2.,1.)/4.+ id*10.);\n    \n    //I could have done this branchless\n    \n\tif (mask.x) {\n\t\tcolor = idCol*texture(iChannel0,fVPos.yz/scale).rrr;\n        outLine = smoothstep(0.05,0.07,max(abs(fVPos.y),abs(fVPos.z))-thickness);\n        color = mix(color, outLineCol,outLine);\n\t}\n\tif (mask.y) {\n\t\tcolor = idCol*texture(iChannel0,fVPos.xz/scale).rrr;\n        outLine = smoothstep(0.05,0.07,max(abs(fVPos.x),abs(fVPos.z))-thickness);\n        color = mix(color, outLineCol,outLine);\n\t}\n\tif (mask.z) {\n\t\tcolor = idCol*texture(iChannel0,fVPos.xy/scale).rrr;\n        outLine = smoothstep(0.05,0.07,max(abs(fVPos.x),abs(fVPos.y))-thickness);\n        color = mix(color, outLineCol,outLine);\n\t}\n     \n    //we know what the normal is\n    vec3 norm = -vec3(mask)*sign(rayDir);\n    \n    //The following Lighting calculations\n    //are based on Shane's\n    //let's throw a light it\n    vec3 lightPos = co + vec3(0.,0.,5.);\n    //light direction\n    vec3 lDir = lightPos - vPos;\n    //dist to light for atten\n    float lDist = max(length(lDir), 0.001);\n    lDir/=lDist;\n    //attenuation, one of a few common approximations\n    float attn = 5./(0.2*lDist+ 0.1*lDist);\n    //the diffuse lighting (how much light hit's the normal we are seeing)\n    //(the normal our ray has hit I mean)\n    float diff = max(dot(lDir,norm),0.0);\n    //specular(how much light bounces off the normal surface\n    //in our direction (we flip light direction since it's hitting the \n    //surface here. And -rayDir because it's heading towards us\n    float specPow = 5. + 15.*outLine;\n    float spec = pow(max(dot(reflect(-lDir,norm),-rayDir), 0.), specPow );\n    \n    //add everything together to create the color\n    color = (diff*color*2. + spec*vec3(0.9,0.6,0.3)*1.)*attn;\n    color = mix( clamp(color, 0., 1.), vec3(0.), smoothstep(50., 85., t));\n    \n\tfragColor.rgb = color;\n}","name":"Image","description":"","type":"image"}]}