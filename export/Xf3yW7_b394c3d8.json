{"ver":"0.1","info":{"id":"Xf3yW7","date":"1731186179","viewed":182,"name":"cube edge detection","username":"dottedboxguy","description":"it's possible to make the edge detection smooth, but for how i'll be using it later, i need it to be pure space partitioning, i think.\nnote that it's about as expensive as calculating the normal to your shape, though it only works for 90deg angles","likes":6,"published":3,"flags":0,"usePreview":0,"tags":["sdf","edge"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\nraymarching from wlf3WX\n*/\n\n#define PI 3.14159265359\n\nvoid pR(inout vec2 p, float a) {\n    p = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\n#define saturate(x) clamp(x, 0., 1.)\n\nfloat sstep(float t) {\n\treturn sin(t * PI - PI / 2.) * .5 + .5;\n}\n\nfloat sdBox(vec3 p, vec3 b){\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdSphere(vec3 p, float r){\n    return length(p) - r;\n}\n\nfloat opSub( float d1, float d2 ){\n    return max(-d1,d2);\n}\n\nfloat sdShape(vec3 p){\n    float s = 2.4; \n    return sdBox(p, 1.+.4*vec3(cos(s*iTime), sin(s*iTime), cos(s*iTime+4.)));\n}\n\n\nfloat fsign(float x){return 2.*round(.5+.5*sign(x))-1.;}\nfloat max2(vec2 v){return max(v.x, v.y);}\nfloat max3(vec3 v){return max(max(v.x, v.y), v.z);}\n\nfloat sdEdgeDetect(vec3 p, float edge_size, out vec3 color){\n\n    const float eps = .001;\n    \n    float d = sdShape(p);\n    vec3 offset = vec3(0., edge_size, 0.);\n    float N = sdShape(p-offset.xzy);\n    float S = sdShape(p+offset.xzy);\n    float E = sdShape(p+offset.yxz);\n    float W = sdShape(p-offset.yxz);\n    float U = sdShape(p-offset);\n    float D = sdShape(p+offset);\n    \n    float NS = max(N, S);\n    float EW = max(E, W);\n    float UD = max(U, D);\n\n    \n    if (max(max(NS, EW), UD)>eps){color = vec3(0., 0., 1.);}\n    \n    if (NS>eps&&EW>eps || UD>eps&&EW>eps || UD>eps&&NS>eps)\n        {color = vec3(0., 1., 0.);}\n        \n    //zigzag edge detection, idk if it'll be useful for anything, but it exists\n    //vec2 diag = max(max(vec2(U,D), vec2(E,W)), vec2(N,S));\n    //if (diag.x>eps&&diag.y>eps){color = vec3(0., .5, .5);}\n    \n    if (UD>eps&&NS>eps&&EW>eps)\n        {color = vec3(1., 0., 0.);}\n    \n    return d;\n}\n\nfloat map(vec3 p, out vec3 color){\n    \n    float scale = .5;\n    float s = .2;\n    float ry = mix(sstep(sstep(sstep(mod(iTime * s, 1.)))), mod(iTime * s, 1.), .3) * PI * 2.;\n    float rx = sin(iTime * .33) * .2;\n\n    if (iMouse.z > 0.) {\n        ry = (.5 - iMouse.x / iResolution.x) * PI * 4.;\n    \trx = (.5 - iMouse.y / iResolution.y) * PI * 3.;\n        //scale = 2.;\n    }\n    \n    pR(p.yz, rx);\n    pR(p.xz, ry);\n    \n    p /= scale;\n    \n    \n    float edge_size = .2 + .15*cos(.3*iTime);\n    float d = opSub(sdSphere(p-vec3(1.), 1.5), sdEdgeDetect(p, edge_size, color));\n    \n    \n   \treturn d * scale;\n}\n\nconst int NORMAL_STEPS = 6;\nvec3 calcNormal(vec3 pos){\n    vec3 eps = vec3(.0001,0,0);\n    vec3 nor = vec3(0);\n    float invert = 1.;\n    vec3 garb;\n    for (int i = 0; i < NORMAL_STEPS; i++){\n        nor += map(pos + eps * invert, garb) * eps * invert;\n        eps = eps.zxy;\n        invert *= -1.;\n    }\n    return normalize(nor);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 p = (-iResolution.xy + 2. * fragCoord.xy) / iResolution.y;\n    \n    vec3 camPos = vec3(0,0,3.2);\n    vec3 rayDirection = normalize(vec3(p,-4));\n    \n    vec3 rayPosition = camPos;\n    float rayLength = 0.;\n    float dist = 0.;\n    bool bg = false;\n    vec3 col = vec3(.1);\n    vec3 albedo = vec3(1.);\n    vec3 buffer = vec3(0.);\n\n    for (int i = 0; i < 150; i++) {\n        dist = map(rayPosition, albedo);\n        rayLength += dist;\n        rayPosition = camPos + rayDirection * rayLength;\n\n        if (abs(dist) < .0001) {\n        \tbreak;\n        }\n        \n        if (rayLength > 10.) {\n            bg = true;\n            break;\n        }\n    }\n    \n    if ( ! bg) {\n        vec3 n = calcNormal(rayPosition);\n        vec3 lp = vec3(-.5,.5,.5);\n        float l = max(dot(lp, n), 0.);\n        vec3 ld = normalize(lp - rayPosition);\n        l += .02;\n        l += pow(max(0., 1. + dot(n, rayDirection)), 3.) * .05;\n        col = albedo * l;\n        col = pow(col, vec3(1./2.2));\n    }\n\n    fragColor = vec4(col,1);\n}\n","name":"Image","description":"","type":"image"}]}