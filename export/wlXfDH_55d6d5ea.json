{"ver":"0.1","info":{"id":"wlXfDH","date":"1596582413","viewed":215,"name":"(WIP) Cellular Automata","username":"sotrh","description":"GLSL implementation of basic cellular automata. This only does one step ATM, as cellular automata requires saving state in between","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["procedural"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float nrand (vec2 uv) {\n    return fract(sin(dot(uv, vec2(12.9898,78.233))) * 43758.5453123);\n}\n\nfloat srand(vec2 uv) {\n    return nrand(uv) * 2.0 - 1.0;\n}\n\nfloat isAlive(vec2 uv) {\n    if (nrand(uv) > 0.5) {\n        return 1.0;\n    } else {\n        return 0.0;\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 cellSize = 1.0 / iResolution.xy * 32.0;\n    vec2 uv = floor(fragCoord * cellSize);\n    \n    float cell = isAlive(uv);\n    float aliveNeighbors = \n        isAlive(uv + vec2(-cellSize.x, 0.0))         + // Top Left\n        isAlive(uv + vec2(-cellSize.x, cellSize.y))  + // Left\n        isAlive(uv + vec2(-cellSize.x, -cellSize.y)) + // Bottom Left\n        isAlive(uv + vec2(0.0, -cellSize.y))         + // Bottom\n        isAlive(uv + vec2(cellSize.x, -cellSize.y))  + // Bottom Right\n        isAlive(uv + vec2(cellSize.x, 0.0))          + // Right\n        isAlive(uv + vec2(cellSize.x, cellSize.y))   + // Top Right\n        isAlive(uv + vec2(0.0, cellSize.y))            // Top\n    ;\n    \n    float cell1 = cell;\n    if (aliveNeighbors > 4.0) {\n        cell1 = 0.0;\n    } /*else if (aliveNeighbors > 2.0) {\n        cell1 = 1.0;\n    } //*/\n    \n    float t = sin(iTime) * 0.5 + 0.5;\n    vec3 col = vec3(mix(cell, cell1, t));\n    \n    fragColor = vec4(col, 1);\n}","name":"Image","description":"","type":"image"}]}