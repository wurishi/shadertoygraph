{"ver":"0.1","info":{"id":"WdX3WX","date":"1547586787","viewed":152,"name":"Shading halftone","username":"caseymacneil","description":"Halftone using lighting as a mask. Building off my other shader, I made this specifically to try this lighting not to show off raymarching.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","sdf","celshading","halftone"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAXSTEPS 512\n#define MAXDIST 200.\n// uncomment for cel shading\n//#define CELSHADING\n\nfloat sdSphere(vec3 p, float r)\n{\n\treturn length(p) - r;\n}\n\nfloat sdPlane(vec3 p, vec3 n)\n{\n\tn = normalize(n);\n\treturn dot(p, n.xyz)+1.;\n}\n\nvec3 opRep(vec3 p, vec3 r)\n{\n\treturn mod(abs(p),r)-.5*r;\n}\n\nfloat map(vec3 p)\n{\n\treturn min(sdSphere(opRep(vec3(0.0,0.,0.0)-p,vec3(10.,0.,10.)),1.0),sdPlane(vec3(0.,0.,0.)-p,vec3(0.,-1.,0.)));\n}\n\nvec3 calcNormal(in vec3 p)\n{\n    const float eps = 0.0001;\n    const vec2 h = vec2(eps,0);\n    return normalize( vec3(map(p+h.xyy) - map(p-h.xyy),\n                           map(p+h.yxy) - map(p-h.yxy),\n                           map(p+h.yyx) - map(p-h.yyx) ) );\n}\n\n// soft shadow function by iq\n//https://iquilezles.org/articles/rmshadows\nfloat softshadow( in vec3 ro, in vec3 rd, float mint, float maxt, float k )\n{\n    float res = 1.0;\n    float ph = 1e20;\n    for( float t=mint; t < maxt; )\n    {\n        float h = map(ro + rd*t);\n        if( h<0.001 )\n            return 0.0;\n        float y = h*h/(2.0*ph);\n        float d = sqrt(h*h-y*y);\n        res = min( res, k*d/max(0.0,t-y) );\n        ph = h;\n        t += h;\n    }\n    return res;\n}\n//\n\n// taken from https://www.shadertoy.com/view/lsKcDD\nfloat calcAO(vec3 p, vec3 n)\n{\n\tfloat occ = 0.;\n    float sca = 1.;\n    for(int i = 0; i < 5; i++)\n    {\n        float h = 0.00 + 0.15*float(i)/4.0;\n        float d = map(p + h*n);\n        occ += (h-d)*sca;\n        sca *= .95;\n    }\n    return clamp(1. - 1.5 * occ, 0.1, 1.);\n}\n\nfloat CalcHalfTone(vec2 uv, float NDotL, float s, float r)\n{\n    \n\tvec2 st = uv * iResolution.xy * s;\n    \n    vec2 f = fract(st);\n    \n    float rr = r * NDotL;\n    float d = distance(f,vec2(.5,.5));\n\tfloat dh = smoothstep(d,1.,0.5); // smooth\n    float h = 1.-(distance(f,vec2(.5,.5)) < rr ? 0. : 1.); // not smooth\n    return dh;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    // set up camera\n    vec2 sp =  (2.0*fragCoord.xy-iResolution.xy) / iResolution.y;\n    vec3 ro = vec3(sin(iTime*.5)*2.,3.,4.);\n    vec3 rd = normalize(vec3(sp,-2.));\n    //\n\t\n    vec3 lightDir = normalize(vec3(sin(iTime),sin(iTime*2.)*.5 + .75,cos(iTime)));\n\n    vec3 col = vec3(0.3,0.5,0.8);\n   \t\n    // sun\n    col += vec3(pow(max(dot(rd,lightDir),0.),80.));\n    \n    float t = 0.;\n    \n    for(int i = 0; i < MAXSTEPS; i++)\n    {\n    \tvec3 p = ro + rd * t;\n        float d = map(p);\n        \n        if(t > MAXDIST) break;\n        \n        // draw\n        if(d < 0.001)\n        {\n            vec3 n = calcNormal(p);\n            float NDotL = dot(n,lightDir); \n            \n            #ifdef CELSHADING\n            \tif(NDotL <= 0.) NDotL = 0.0;\n            \telse if(NDotL <= .25) NDotL = .25;\n            \telse if(NDotL <= .5) NDotL = .5;\n            \telse NDotL = 1.;\n\t\t\t#endif\n                \n            //float shadow = softshadow(p,lightDir,.1,16.,16.)+.4;\n            \n            // fresnel\n            float NDotV = dot(n, rd); \n            float fscale= 2.;\n            float fpow  =2.;\n            float fbump = -.7;\n            float f = 1.-pow(NDotV,fpow) * fscale;\n            f = max(f+fbump,0.);\n            \n            float occ = calcAO(p,n);\n            \n            float shadow = softshadow(p,lightDir,.1,16.,16.)+.4;\n            \n        \tcol = vec3(NDotL) * shadow;\n            \n            // \"materials\"\n            if(p.y > -.9)\n            \tcol += vec3(CalcHalfTone(uv,NDotL,.16,.8)) * NDotL * NDotL;\n            else col *= vec3(1.0,.5,.5);\n            //col = n;\n            break;\n        }\n        \n        t += d;\n    }\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}