{"ver":"0.1","info":{"id":"Xdc3Dn","date":"1448842851","viewed":227,"name":"nd raytrace","username":"ndeboar","description":"Simple raytracer, mostly based off http://www.scratchapixel.com/","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raytrace"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xdf3zn","filepath":"/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png","previewfilepath":"/media/ap/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png","type":"texture","channel":0,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[],"code":"// hou to glsl\n// camera is buggered, z looks more like focal length, the rest look super odd too.\n// everything needs y inverted as well, thats odd\n\n\nconst float PI = 3.141592653589793238462643383;\n\nfloat tNear = 10000000.0; //max cam ray dist\n\n\nstruct sphere\n{\n\tfloat rad;\n    vec3 P;\n    vec3 N;\n    vec3 uv;\n};\n    \nstruct plane\n{\n    vec3 P;\n    vec3 N;\n    vec3 uv;\n};\n    \nsphere sphereSurfData(vec3 Phit,sphere iSphere)\n{\n    //normal\n\tvec3 Nhit = Phit - iSphere.P; \n\tNhit = normalize(Nhit);    \n    //uvs\n    vec3 tex = vec3(0,0,0);\n    tex.x = (1.0 + atan(Nhit.z, Nhit.x) / PI) * 0.5; \n    tex.y = acos(Nhit.y) / PI; \n    return sphere(iSphere.rad, iSphere.P, Nhit, tex);\n}\n\n\nfloat intersectPlane(plane iPlane, vec3 l0, vec3 l) \n{ \n    float t = 0.0;\n    float denom = dot(iPlane.N, l); \n    if (denom > 1e-6) { \n        vec3 p0l0 = iPlane.P - l0; \n        t = dot(p0l0, iPlane.N) / denom; \n        return (t); \n    } \n \n    return (0.0); \n} \n\n    \nfloat intersectSphere( vec3 orig, vec3 dir, sphere iSphere) \n{ \n    float t = 0.0;\n    float radius2 = iSphere.rad * iSphere.rad;\n    float t0, t1, temp; \n    // geometric solution\n    vec3 L = iSphere.P - orig; \n    float tca = dot(L,dir); \n    if (tca < 0.0)\n        return 0.0; \n    float d2 = dot(L,L) - tca * tca; \n    if (d2 > radius2) return 0.0; \n    float thc = sqrt(radius2 - d2); \n    t0 = tca - thc; \n    t1 = tca + thc; \n    \n    if (t0 > t1)\n    {\n        temp = t0;\n     \tt0 = t1;\n        t1 = temp;\n    } \n \n    if (t0 < 0.0) { \n        t0 = t1; // if t0 is negative, let's use t1 instead \n        if (t0 < 0.0) return 0.0; // both t0 and t1 are negative \n    } \n\n    t = t0; \n    \n\n    return t; \n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //scene\n    mat4 cameraToWorld = mat4(1, 0, 0, 0,\n                              0, 1, 0, 0,\n                              0, 0, 1, 0,\n                              0, 0, 0, 1);\n\tfloat fov = 50.00; \n\n    \n    //render\n    vec3 buff;\n    vec2 tex;   \n    float scale = tan(radians(fov * 0.5)); \n    float imageAspectRatio = iResolution.x / iResolution.y;   \n    \n    //camera rays\n    \n    //orig is the camera to world\n    vec3 orig =  vec4(vec4(0,0,0,1) * cameraToWorld).xyz;\n    \n    //dir ray towards a pixel, in world\n    float x = (2.0 * (float(fragCoord.x) + 0.5) / float(iResolution.x) - 1.0) * scale; \n    float y = (1.0 - 2.0 * (float(fragCoord.y) + 0.5) / float(iResolution.y)) * scale * 1.0 / imageAspectRatio; \n    vec3 dir = vec4(vec4(x,y,-1,1) * cameraToWorld).xyz;\n    dir = normalize(dir);\n    \n\t//one plane supported for now\n    \n    plane ground = plane(vec3(0,0.46,0),vec3(0,1,0),vec3(0,0,0));\n    \n    float intersect = intersectPlane(ground, orig, dir);\n    \n    if(intersect > 0.0 && intersect < tNear)\n    {\n    \ttNear = intersect;\n    \tvec3 Phit = orig + dir * intersect;\n        float texMult =1.0;\n        tex.x = Phit.x * texMult;\n        tex.y = Phit.z * texMult;\n        vec3 texchur1 = vec3(1,1,1);\n        if (mod(tex.y * texMult,1.0) > 0.5)\n            texchur1 *= vec3(0,0,0);\n        if (mod(tex.x * texMult,1.0) > 0.5)\n            texchur1 *= vec3(0,0,0);\n        \n        \n        //vec3 texchur1 = mod(tex.y * texMult,1.0) * vec3(1.0,1.0,1.0);\n\n        \n        //buff = vec3(0,0,0) + max(dot(ground.N,vec3(sin(iTime),0,0.5)),0.0) ;\n        buff = texchur1;\n    }\n    sphere spheres[2];\n    \n    spheres[0] = sphere(0.5,vec3(1.0, 0, sin(iTime) * 8.0 -5.0), vec3(0,0,0), vec3(0,0,0));\n    spheres[1] = sphere(0.5,vec3(0, 0, -4), vec3(0,0,0), vec3(0,0,0));\n    \n    for(int i = 0; i <= 1; i++)\n    {\n        float intersect = intersectSphere(orig,dir,spheres[i]);\n\n        if(intersect > 0.0 && intersect < tNear)\n        {\n            tNear = intersect;\n            vec3 Phit = orig + dir * intersect;\n            \n            \n            //get normals,uvs\n            sphere sphereI = sphereSurfData(Phit, spheres[i]);\n\t\t\t\n            \n            buff = vec3(0,0,0) + max(dot(sphereI.N,vec3(sin(iTime),0,0.5)),0.0);\n        }\n\n    }\n    fragColor= vec4(buff, 1);\n}\n\n\n\n//////intersect plane\n/*\n\n    vec3 planeP = vec3(1.0,sin(iTime),1.0);\n    vec3 planeN = vec3(0.5,1,1);\n    float intersect = intersectPlane(planeN, planeP, orig, dir);\n    if(intersect > 0.0)\n    {\n        vec3 Phit = orig + dir * intersect;\n        float texMult =0.08;\n        tex.x = Phit.x * texMult;\n        tex.y = Phit.z * texMult;\n        vec3 texchur1 = texture(iChannel0,vec2(tex.x *3.0,tex.y*3.0)).rgb;\n    \t//fragColor= dot(planeN,vec3(sin(iTime),0,0.5)) * vec4(1,1,1,1);\n        //fragColor = vec4(Phit.z *-1.0 /10.0,0,0,1);\n        fragColor = vec4(texchur1,1.0);\n*/\n\n    //////currently just intersect a single sphere\n    /*\n    float intersect = intersectSphere(orig,dir,1000.0,sphereR, sphereP);\n    \n    if(intersect > 0.0)\n    {\n        //normal\n        vec3 Phit = orig + dir * intersect;\n        vec3 Nhit = Phit - sphereP; \n        Nhit = normalize(Nhit); \n        \n        //uvs\n        tex.x = (1.0 + atan(Nhit.z, Nhit.x) / PI) * 0.5; \n        tex.y = acos(Nhit.y) / PI; \n        vec3 texchur1 = texture(iChannel0,vec2(tex.x *3.0,tex.y*3.0)).rgb;\n        \n        //lambert\n        fragColor =  vec4(texchur1,1.0) * max(dot(Nhit,vec3(sin(iTime),0,0.5)),0.0);\n    }    \n\t*/","name":"","description":"","type":"image"}]}