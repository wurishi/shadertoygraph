{"ver":"0.1","info":{"id":"DsyyRh","date":"1695807700","viewed":52,"name":"Interactable Mandelbrot set","username":"carlosroxo1","description":"Use the mouse to drag the fractal around or move with WASD\nZoom in n out using the keyboard keys or 'E' and 'Q'\nSpacebar resets the zoom","likes":1,"published":1,"flags":48,"usePreview":0,"tags":["2d","fractal","mouse","mandelbrot","complex","keyboard","interactable"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Created by me :)\n//\n// I was bored of waiting for python to render and I didn't want to set up OpenGL either, here is the result!\n//\n// I sourced the loadValue and storeValue functions from the Pac-Man game: https://www.shadertoy.com/view/Ms3XWN\n// I hope the creator won't be mad\n// Full credit to the original creator for these functions.\n//\n// The rest of the code was patched up by me, feel free to use any part of it as needed.\n// If you think a part of the code is inefficient, ugly or some other nuisance, I welcome feedback.\n// Enjoy!\n\n\nvec4 loadValue( in ivec2 re )\n{\n    return texelFetch( iChannel0, re, 0 );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Define the coordinates for the current pixel\n    vec2 resolution = iResolution.xy;\n    vec2 p = (2.0 * fragCoord - resolution) / min(resolution.x, resolution.y);\n    \n    \n    // Load saved values\n    ivec2 ifragCoord = ivec2( fragCoord-0.5 );\n    vec2 offset      = loadValue( txOffset ).xy;\n    vec2 mouseLast   = loadValue( txMouseLast ).xy;\n    float zoom       = loadValue( txZoom ).x;\n    \n    \n    // Map pixel coordinates to the Mandelbrot set's complex plane\n    int MAX_ITER = 1024;\n    Complex c;\n    c.real = p.x/zoom - offset.x;\n    c.imag = p.y/zoom - offset.y;\n\n\n    // Check if the current complex number is inside the Mandelbrot set\n    int count = isInsideMandelbrot(c, MAX_ITER);\n\n\n    // Map the number of iterations to a color gradient with a log scale\n    vec3 color;\n    if (count == MAX_ITER) {\n        color = vec3(0.0); // Inside the set (black)\n    } else {\n        // Apply a logarithm to the count for a log scale\n        float logCount = log(float(count) + 1.0) / log(float(MAX_ITER) + 1.0);\n        color = vec3(logCount, logCount * logCount, 1.0 - logCount); // Color gradient (change this for different colors)\n    }\n\n\n    // Output the color\n    fragColor = vec4(color, 1.0);\n}\n\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"const ivec2 txOffset    = ivec2(31, 1);\nconst ivec2 txMouseLast = ivec2(31, 3);\nconst ivec2 txZoom      = ivec2(31, 5);\n\n\nstruct Complex {\n    float real;\n    float imag;\n};\n\n\nComplex addC(Complex a, Complex b) {\n    Complex result;\n    result.real = a.real + b.real;\n    result.imag = a.imag + b.imag;\n    return result;\n}\n\nComplex multiplyC(Complex a, Complex b) {\n    Complex result;\n    result.real = a.real * b.real - a.imag * b.imag;\n    result.imag = a.real * b.imag + a.imag * b.real;\n    return result;\n}\n\nfloat absC(Complex c) {\n    return length(vec2(c.real, c.imag));\n}\n\nint isInsideMandelbrot(Complex c, int MAX_ITER) {\n    Complex z = c;\n    for (int i = 0; i < MAX_ITER; i++) {\n        z = addC(multiplyC(z, z), c); // Mandelbrot iteration formula\n        if (absC(z) > 2.0) {\n            return i; // If |z| > 2, it's not in the Mandelbrot set\n        }\n    }\n    return MAX_ITER;\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"vec4 loadValue( in ivec2 re )\n{\n    return texelFetch( iChannel0, re, 0 );\n}\n\nvoid storeValue( in ivec2 re, in vec4 va, inout vec4 fragColor, in ivec2 fragCoord )\n{\n    fragColor = ( re.x==fragCoord.x && re.y==fragCoord.y ) ? va : fragColor;\n}\n\nconst int KEY_SPACE = 32;\nconst int KEY_UP    = 38;\nconst int KEY_DOWN  = 40;\nconst int KEY_W     = 87;\nconst int KEY_A     = 65;\nconst int KEY_S     = 83;\nconst int KEY_D     = 68;\nconst int KEY_Z     = 90;\nconst int KEY_X     = 88;\nconst int KEY_Q     = 81;\nconst int KEY_E     = 69;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Define the coordinates for the current pixel\n    vec2 resolution = iResolution.xy;\n    vec2 p = (2.0 * fragCoord - resolution) / min(resolution.x, resolution.y);\n    vec4 m = iMouse / iResolution.x;\n        \n    // Load saved values\n    ivec2 ifragCoord = ivec2( fragCoord-0.5 );\n    vec2 offset      = loadValue( txOffset ).xy;\n    vec2 mouseLast   = loadValue( txMouseLast ).xy;\n    float zoom       = loadValue( txZoom ).x;\n    \n    // Initialize zoom value\n    if (zoom==0.0){\n        zoom = 1.0;\n    }\n    \n    // Capture mouse events\n    if( m.w>0.0 ) // button click\n\t{\n        mouseLast.x = m.x;\n        mouseLast.y = m.y;\n    }\n    else if( m.z>0.0 ) // button is down\n\t{\n        offset.x = offset.x + (m.x - mouseLast.x) * 2.0*resolution.x/resolution.y / zoom;\n        offset.y = offset.y + (m.y - mouseLast.y) * 2.0*resolution.x/resolution.y / zoom;\n        mouseLast.x = m.x;\n        mouseLast.y = m.y;\n\t}\n    \n    // move with keyboard\n    float zoomSpeed = 2.0;\n    float moveSpeed = 3.0;\n    if( texelFetch( iChannel1, ivec2(KEY_UP,0), 0 ).x>0.5 )    zoom = zoom*(1.0+iTimeDelta*2.0);\n    if( texelFetch( iChannel1, ivec2(KEY_DOWN, 0), 0 ).x>0.5 ) zoom = zoom/(1.0+iTimeDelta*2.0);\n    if( texelFetch( iChannel1, ivec2(KEY_E,0), 0 ).x>0.5 )     zoom = zoom*(1.0+iTimeDelta*2.0);\n    if( texelFetch( iChannel1, ivec2(KEY_Q, 0), 0 ).x>0.5 )    zoom = zoom/(1.0+iTimeDelta*2.0);\n    if( texelFetch( iChannel1, ivec2(KEY_W, 0), 0 ).x>0.5 ) offset.y -= moveSpeed*iTimeDelta/zoom;\n    if( texelFetch( iChannel1, ivec2(KEY_A, 0), 0 ).x>0.5 ) offset.x += moveSpeed*iTimeDelta/zoom;\n    if( texelFetch( iChannel1, ivec2(KEY_S, 0), 0 ).x>0.5 ) offset.y += moveSpeed*iTimeDelta/zoom;\n    if( texelFetch( iChannel1, ivec2(KEY_D, 0), 0 ).x>0.5 ) offset.x -= moveSpeed*iTimeDelta/zoom;\n    if( texelFetch( iChannel1, ivec2(KEY_SPACE,0), 0 ).x>0.5 ) zoom = 1.0;\n    \n    // Save loaded values\n    fragColor = vec4(0.0);\n    storeValue( txOffset,    vec4(offset, 0.0, 0.0),    fragColor, ifragCoord );\n    storeValue( txMouseLast, vec4(mouseLast, 0.0, 0.0), fragColor, ifragCoord );\n    storeValue( txZoom,      vec4(zoom, 0.0, 0.0, 0.0), fragColor, ifragCoord );\n}","name":"Buffer A","description":"","type":"buffer"}]}