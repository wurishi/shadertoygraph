{"ver":"0.1","info":{"id":"lsfBWn","date":"1495605717","viewed":124,"name":"âˆ‡","username":"haldean","description":"messing around with signed distance fields and \"fog\"","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["3d"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float hit_tol = 1e-5;\n\nstruct hit\n{\n    vec3 p;\n    float d;\n    bool hit;\n    int mat;\n};\n    \nstruct ray\n{\n    vec3 s;\n    vec3 d;\n};\n    \nvoid reset(inout hit h)\n{\n    h.p = vec3(0.);\n    h.d = 1e10;\n    h.hit = false;\n    h.mat = 0;\n}\n\nvoid sdf_sphere(inout hit h, vec3 center, float rad)\n{\n    float d = length(h.p - center) - rad;\n    h.d = d;\n}\n\nvoid sdf_plane(inout hit h, vec3 pos, vec3 n)\n{\n    float d = dot(h.p - pos, n);\n    h.d = d;\n}\n\nvoid sdf_cyl(inout hit h, vec3 pos, vec3 ax, float rad)\n{\n    vec3 rel = h.p - pos;\n    float ap = dot(ax, rel);\n    vec3 axp = ap * ax;\n    float r = length(rel - axp);\n    float d = r - rad;\n    h.d = d;\n}\n\nvoid csg_intersect(inout hit h0, in hit h1)\n{\n    if (h0.d >= h1.d)\n        return;\n    h0 = h1;\n}\n\nvoid csg_subtract(inout hit h0, in hit h1)\n{\n    if (h0.d >= -h1.d)\n        return;\n    h0 = h1;\n    h0.d = -h0.d;\n}\n\nvoid csg_union(inout hit h0, in hit h1)\n{\n    if (h0.d <= h1.d)\n        return;\n    h0 = h1;\n}\n\nvoid csg_blend(inout hit h0, in hit h1, float k)\n{\n    // in the case where h0.d and h1.d are the same, this is 0.5. As h0.d gets larger, this\n    // decreases, and v.v. When the two diverge by more than k, this is either 0 or 1.\n    float blend = clamp(0.5 + 0.5 * (h1.d - h0.d) / k, 0.0, 1.0);\n    // when blend is 0.5, this works out to d - k / 4; you get a radius of k / 4\n    // when you're exactly the same distance from the two hits.\n    float d = mix(h1.d, h0.d, blend) - k * blend * (1.0 - blend);\n    h0.d = d;\n}\n\nvoid sdf(inout hit h, vec3 pos)\n{\n    h.p = pos;\n    \n    hit h0, h1;\n    h0.p = pos;\n    h1.p = pos;\n    \n    sdf_sphere(h, vec3(0., 0., 10.), 2.5 + 0.4 * sin(1.4 * iTime));\n    \n    sdf_cyl(h0, vec3(0., 0., 10.), vec3(sin(iTime), 0., cos(iTime)), 1.);\n\tsdf_sphere(h1, vec3(0., 0., 10.), 4.5);\n    csg_intersect(h0, h1);\n    \n    csg_blend(h, h0, 1.); h.mat = 1;\n\n    sdf_plane(h0, vec3(-4., 0., 0.), vec3(1., 0., 0.)); h0.mat = 0; csg_union(h, h0);\n    sdf_plane(h0, vec3(4., 0., 0.), vec3(-1., 0., 0.)); h0.mat = 0; csg_union(h, h0);\n    sdf_plane(h0, vec3(0., -3., 0.), vec3(0., 1., 0.)); h0.mat = 2; csg_union(h, h0);\n\n    h.hit = h.d < hit_tol;\n}\n\nvoid send(inout hit h, ray r)\n{\n    float t = 0.5;\n    for (int i = 0; i < 128; i++)\n    {\n        sdf(h, r.s + t * r.d);\n        if (h.hit)\n        \treturn;\n        t += h.d;\n        continue;\n    }\n    h.hit = false;\n}\n\nfloat shadow(ray r, vec3 light)\n{\n    float t = 0.5;\n    float shadow = 1.;\n    float dist = length(light - r.s);\n    hit lh;\n    for (int i = 0; i < 64; i++)\n    {\n        if (t >= dist)\n            break;\n        reset(lh);\n        sdf(lh, r.s + t * r.d);\n        if (lh.hit)\n            return 0.;\n        t += lh.d;\n        shadow = min(shadow, 8. * lh.d / t);\n    }\n    return clamp(shadow, 0., 1.);\n}\n\nfloat ao(in hit h, vec3 n)\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    hit aoh;\n    for (int i = 0; i < 8; i++)\n    {\n        float hr = 0.6 * float(i) / 5.0 + 0.01;\n        vec3 aopos = n * hr + h.p;\n        \n        reset(aoh);\n        sdf(aoh, aopos);\n\n        occ += (aoh.d - hr) * -sca;\n        sca *= 0.90;\n    }\n    return clamp(1.0 - 0.2 * occ, 0.0, 1.0 );    \n}\n\nvec4 light(hit h, vec3 n, vec3 light, vec4 color)\n{\n    ray r;\n    r.d = normalize(light - h.p);\n    r.s = h.p;\n    float sh = shadow(r, light);\n\n    vec4 diffuse = clamp(dot(n, r.d), 0., 1.) * color;\n    \n    vec3 refl = normalize(2. * dot(r.d, n) * n - r.d);\n    vec3 view = normalize(-h.p);\n    float spec = h.mat == 1\n        ? pow(clamp(dot(view, refl), 0., 1.), 10.)\n        : 0.;\n    vec4 specc = spec * vec4(1., 1., 1., 1.);\n    \n    return clamp(sh * (diffuse + spec),\n                 vec4(0., 0., 0., 1.),\n                 vec4(1., 1., 1., 1.));\n}\n\nvec3 normal(in vec3 pos)\n{\n    vec2 e = vec2(1.0, -1.0) * 0.5773 * 0.0005;\n    vec3 n = vec3(0., 0., 0.);\n    hit h;\n    sdf(h, pos + e.xyy); n += e.xyy * h.d;\n    sdf(h, pos + e.yyx); n += e.yyx * h.d;\n    sdf(h, pos + e.yxy); n += e.yxy * h.d;\n    sdf(h, pos + e.xxx); n += e.xxx * h.d;\n    return normalize(n);\n}\n\nvoid mainImage(out vec4 color, in vec2 fragCoord)\n{\n    float mw = max(iResolution.x, iResolution.y);\n    vec2 uv = 2.0 * (fragCoord.xy - iResolution.xy / 2.0) / mw;\n    ray r;\n    r.s = vec3(-uv, -0.8);\n    r.d = normalize(-r.s);\n    \n    hit h;\n    reset(h);\n    send(h, r);\n    if (!h.hit)\n    {\n        color = vec4(0.08, 0, 0.1, 1.0);\n    }\n    else\n    {\n        vec4 mat =\n            h.mat == 0 ? vec4(0., .6, 1., 1.) :\n            h.mat == 1 ? vec4(1., 1., 1., 1.) : \n        \th.mat == 2 ? vec4(0., .6, .9, 1.) :\n        \tvec4(0.);\n        vec4 amb = vec4(0.05, 0.03, 0.01, 1.0);\n        vec3 norm = normal(h.p);\n        vec4 dif = light(h, norm, vec3(0, 10., 7.), vec4(1., .3, .6, 1.));\n        vec4 dif2 = light(h, norm, vec3(2., 7., 4.), vec4(0.4, 0.4, 0.1, 1.));\n        float aos = ao(h, norm);\n        color = (amb + aos * (dif + dif2)) * mat;\n    }\n    \n    float fog = pow(clamp(length(h.p - r.s) / 40., 0., 1.), 1.2);\n    color =\n        (1. - fog) * color +\n        fog * vec4(0.7, 0.66, 0.68, 1.);\n}","name":"Image","description":"","type":"image"}]}