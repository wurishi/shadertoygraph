{"ver":"0.1","info":{"id":"ll3cz4","date":"1531749881","viewed":103,"name":"pattern14072018","username":"edapx","description":"orchids, flowers, patterns","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["patterns","flowers","orchids"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#ifdef GL_ES\nprecision mediump float;\n#endif\n\n#define PI 3.14159265358979323846\n#define TWO_PI 6.28318530718\n\n// bool ops\nfloat merge(float d1, float d2){\n\treturn min(d1, d2);\n}\n\nfloat smoothMerge(float d1, float d2, float k){\n    float h = clamp(0.5 + 0.5*(d2 - d1)/k, 0.0, 1.0);\n    return mix(d2, d1, h) - k * h * (1.0-h);\n}\n\nfloat substract(float d1, float d2){\n\treturn max(-d1, d2);\n}\n\nfloat intersect(float d1, float d2){\n\treturn max(d1, d2);\n}\n\n\nfloat ellipseDist(vec2 p, float radius, vec2 dim){\n  vec2 pos = p;\n  pos.x = p.x / dim.x;\n  pos.y = p.y / dim.y;\n  return length(pos) - radius;\n}\n\nfloat circleDist(vec2 p, float radius){\n  return length(p) - radius;\n}\n\nmat2 rotate2dm(float _angle){\n    return mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle));\n}\n\n\nvec2 rotate2D (vec2 _st, float _angle) {\n    _st -= 0.5;\n    _st =  rotate2dm(_angle) * _st;\n    _st += 0.5;\n    return _st;\n}\n\nfloat when_eq(float x, float y) {\n  return 1.0 - abs(sign(x - y));\n}\n\nvec2 tile (vec2 _st, float _zoom) {\n    _st *= _zoom;\n    return fract(_st);\n}\n\nfloat orcSepals(vec2 toCenter, float resize, float defX, float defY,\nfloat grow, float nPetals, float smoothness){\n    float angle = atan(toCenter.y,toCenter.x) + 0.5;\n    float deformOnY = toCenter.y * defY;\n    float deformOnX = abs(toCenter.x) * defX;\n    float radius = length(toCenter)*resize * (grow+deformOnY+deformOnX);\n\n    float f = cos(angle*nPetals);\n    return smoothstep(f, f+smoothness,radius);\n}\n\nfloat lip(vec2 pos, vec2 oval, vec2 ovalSub,float radius, float offset){\n  float A = ellipseDist(pos, radius, oval);\n  vec2 posB = pos;\n  posB.y += offset;\n  float B = ellipseDist(posB, radius, ovalSub);\n  float p = smoothMerge(B, A, 0.5);\n  return p;\n}\n\nfloat orcColumn(vec2 pos, vec2 oval, vec2 ovalSub,float radius, float offset){\n  float A = ellipseDist(pos, radius, ovalSub);\n  vec2 posB = pos;\n  posB.y -= offset;\n  float B = ellipseDist(posB, radius, oval);\n  float p = substract(B,A);\n  posB.y += 0.035;\n  float cone = ellipseDist(posB, radius, vec2(0.055, 0.30));\n  p = smoothMerge(cone,p, 0.4);\n  float s = ellipseDist(posB, radius, vec2(0.2, 0.20));\n  return p;\n}\n\nvec2 rotateTilePattern(vec2 _st){\n    _st *= 2.0;\n    float index = 0.0;\n    index += step(1., mod(_st.x,2.0));\n    index += step(1., mod(_st.y,2.0))*2.0;\n    _st = fract(_st);\n    //  Rotate cell 1 by 90 degrees\n    float rad = PI*0.5 * when_eq(index, 1.);\n    _st = rotate2D(_st,rad);\n    //  Rotate cell 2 by -90 degrees\n    rad = PI*-0.5 * when_eq(index, 2.);\n    _st = rotate2D(_st,rad);\n    //  Rotate cell 3 by 180 degrees\n    rad = PI * when_eq(index, 3.);\n    _st = rotate2D(_st,rad);\n    return _st;\n}\n\nfloat flip(float v, float pct){\n  return mix(v, 1. - v, pct);\n}\n\nfloat rectSDF(vec2 pos, vec2 dim){\n  vec2 _st = pos*2. - 1.;\n  return max(abs(_st.x/dim.x),\n             abs(_st.y/dim.y));\n\n}\n\nfloat fillSmooth(float sdfVal, float size, float smoothness){\n  return smoothstep(size, size+smoothness,sdfVal);\n}\n\nfloat strokeSmoot(float x, float pos, float width, float smtness){\n  return smoothstep(pos, pos+smtness,x+ width*0.5) -\n         smoothstep(pos, pos+smtness,x- width*0.5);\n\n}\n\nfloat rand(vec2 uv){\n    return fract(sin(dot(uv, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n  // General parameters\n  float smoothness = 0.03;\n  vec3 olive = vec3(0.482, 0.5, 0.29);//1\n  vec3 green = vec3(0, 0.498, 0.352);\n  vec3 red = vec3(0.952, 0.227, 0.152);//5\n  vec3 orange = vec3(0.843, 0.615, 0.184);//3\n  vec3 yellow = vec3(0.956, 0.898, 0.247); //\n\n  // Tiling\n  vec2 st = fragCoord/iResolution.xy;\n  st.x *= iResolution.x / iResolution.y;\n  vec2 stBg = tile(st,3.0);\n  stBg = rotateTilePattern(stBg);\n  vec2 orcSt = tile(st,2.0);\n\n  stBg = rotate2D(stBg,-PI*iTime*0.15);\n\n  // Background\n  float sdf = rectSDF(stBg, vec2(.3,1.));\n  float rect = fillSmooth(sdf, 0.7, smoothness);\n  float diag = (stBg.x+stBg.y) * 0.5;\n  float diagLine = strokeSmoot(diag, 0.5, 0.02,smoothness);\n  float rectAndLine = flip(rect, diagLine);\n  vec3 bgCol = mix(green, olive, rectAndLine);\n\n  // Orchid parameters. The orchid is composed by sepals, petals, lip and column\n  orcSt+=vec2(-0.5, -0.5);\n  //column parameters\n  float colResize = 0.45;\n  vec2 posCol = orcSt;\n  posCol.y += 0.035;\n  float colYoffset = -0.051;\n  float powerCol = 2.;\n  vec2 colRatio = vec2(0.7*colResize, 0.7*colResize);\n  vec2 colSubRatio = vec2(0.9*colResize, 0.9*colResize);\n  float colRadius = 0.52*colResize;\n  // sepals parameters\n  float addSmoothnessToSetals = 2.9;\n  float deformX = 0.;\n  float deformY = 0.;\n  float resizePetals = 11.9;\n  float powerSepals = 2.0;\n  float nPetals = 3.;\n  float growSepals = exp2(length(orcSt)) * 0.19;\n  float nPetalsLat = 2.;\n  float deformXLat = 0.0;\n  float deformYLat = -0.0;\n  float resizePetalsLat = 21.9;\n  float powerLat = 2.3;\n  vec2 latPos = orcSt*rotate2dm(TWO_PI/2.4);\n  float growLaterals = pow(length(orcSt), powerLat);\n  // lip parameter\n  vec2 posLip = orcSt;\n  posLip.y += 0.18;\n  float lipResize = 0.6;\n  float lipYoffset = 0.05;\n  vec2 lipRatio = vec2(0.19*lipResize, 0.45*lipResize);\n  vec2 smallLipRatio = vec2(0.3*lipResize, 0.15*lipResize);\n  float lipRadius = 1.*lipResize;\n\n  float column = orcColumn(posCol*rotate2dm(TWO_PI/2.),\n                        colRatio,\n                        colSubRatio,\n                        colRadius, colYoffset);\n  float sepals = orcSepals(orcSt,\n                        resizePetals,\n                        deformX,\n                        deformY, growSepals, nPetals,\n                        smoothness+addSmoothnessToSetals);\n  float latPetals = orcSepals(latPos,\n                        resizePetalsLat,\n                        deformXLat,\n                        deformYLat, growLaterals, nPetalsLat,\n                        smoothness+addSmoothnessToSetals);\n  float lip = lip(posLip,\n                      lipRatio,\n                      smallLipRatio,\n                      lipRadius, lipYoffset);\n\n  float orchids = merge(latPetals, sepals);\n  orchids = merge(orchids, lip);\n  orchids = substract(column, orchids);\n  // this angle is using while creating the colors\n  float angle = atan(orcSt.y,orcSt.x) + 0.5;\n\n  // Sepals color:\n  sepals = fillSmooth(sepals,0.09,smoothness+0.005);\n  vec3 sepalsColor = mix(yellow, olive,rand(orcSt));\n  vec3 orcColor = mix(sepalsColor, bgCol, sepals);\n\n  // Lip color:\n  // 1) create the space coord for the points\n  vec2 lipSt = orcSt;\n  lipSt = fract(lipSt *= 20.);\n  lipSt -=vec2(0.5,0.5);\n  // 2 create the color pois\n  float points = circleDist(lipSt, 0.1);\n  points = smoothstep(points, points+0.05, 0.2);\n  vec3 colorPoints = mix(orange, olive, points);\n  // 3 mix the color with the orchid\n  lip = fillSmooth(lip,0.09,smoothness+0.005);\n  orcColor = mix(colorPoints, orcColor, lip);\n\n  // Petals color\n  latPetals = fillSmooth(latPetals,0.09,smoothness+0.005);\n  vec3 latPetalsColor = mix(yellow,red, sin(angle * 40.0));\n  latPetalsColor = mix(latPetalsColor, red, abs(orcSt.x)*2.7);\n  orcColor = mix(latPetalsColor,orcColor,latPetals);\n\n  //column color\n  column = fillSmooth(column,0.01,0.02);\n  vec3 columnColor = orange - red * (orcSt.y *2.);\n  orcColor = mix(columnColor, orcColor, column);\n\n  fragColor = vec4(vec3(orcColor),1.0);\n}","name":"Image","description":"","type":"image"}]}