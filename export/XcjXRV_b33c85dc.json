{"ver":"0.1","info":{"id":"XcjXRV","date":"1708039022","viewed":523,"name":"Cornell Radiosity","username":"Mathis","description":"Improving my radiosity shader (in a new shader, heh)\n\nControls:\niMouse.x interpolates between classic cornell lightsource, two emissive walls and sunlight\niMouse.y controls the sunlight angle","likes":49,"published":1,"flags":32,"usePreview":0,"tags":["box","cornell","radiosity"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dX3Rr","filepath":"/media/a//media/previz/cubemap00.png","previewfilepath":"/media/ap//media/previz/cubemap00.png","type":"cubemap","channel":3,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\nCornell box with some spheres and radiosity\n    Bilinear interpolation with first order extrapolation to improve texture boundaries\n    Radiosity with proper formfactors and binary visibility test\n    \n\nSome cool notes:\n    Scene can be completely dynamic, but temporal multibounce flickers a lot when patches move\n    Temporal multibounce is cool but introduces ghosting as usual\n        Both these problems can be reduced by removing temporal history based on\n        movement, light or other changes\n    No flag for invalid patches\n        When patches partially intersects geometry the sampling position might land inside geometry\n        leading to artifacts, both for interpolation and for light transport\n            Can be fixed but not implemented here\n\nControls:\n    iMouse.x interpolates between classic cornell lightsource, two emissive walls and sunlight\n    iMouse.y controls the sunlight angle\n*/\n\n\n\nvec3 acesFilm(vec3 x) {\n    return clamp((x*(2.51*x+0.03))/(x*(2.43*x+0.59)+0.14),0.,1.);\n}\n\nvec4 textureCube(vec2 UV, float LOD) {\n    //Samples the cubemap\n    float Sign = -mod(floor(UV.y*I1024),2.)*2.+1.;\n    vec3 D = vec3(vec2(UV.x,mod(UV.y,1024.))*I512-1.,Sign);\n    if (UV.y>4096.) D = D.xzy;\n    else if (UV.y>2048.) D = D.zxy;\n    return textureLod(iChannel3,D,LOD);\n}\n\nvec3 SamplePatch(vec2 UV, vec4 mm) {\n    if (UV.x<mm.x) {\n        float PixelIndex = floor(UV.x+1.)+floor(UV.y)*64.;\n        vec3 tmpc = textureCube(vec2(floor(mod(PixelIndex+0.5,32.))*32.,floor((PixelIndex+0.5)*I32)*32.)+16.,5.).xyz;\n        PixelIndex = floor(UV.x+2.)+floor(UV.y)*64.;\n        return max(vec3(0.),2.*tmpc-\n               textureCube(vec2(floor(mod(PixelIndex+0.5,32.))*32.,floor((PixelIndex+0.5)*I32)*32.)+16.,5.).xyz);\n    }\n    if (UV.x>mm.x+mm.z) {\n        float PixelIndex = floor(UV.x-1.)+floor(UV.y)*64.;\n        vec3 tmpc = textureCube(vec2(floor(mod(PixelIndex+0.5,32.))*32.,floor((PixelIndex+0.5)*I32)*32.)+16.,5.).xyz;\n        PixelIndex = floor(UV.x-2.)+floor(UV.y)*64.;\n        return max(vec3(0.),2.*tmpc-\n               textureCube(vec2(floor(mod(PixelIndex+0.5,32.))*32.,floor((PixelIndex+0.5)*I32)*32.)+16.,5.).xyz);\n    }\n    if (UV.y<mm.y) {\n        float PixelIndex = floor(UV.x)+floor(UV.y)*64.+64.;\n        vec3 tmpc = textureCube(vec2(floor(mod(PixelIndex+0.5,32.))*32.,floor((PixelIndex+0.5)*I32)*32.)+16.,5.).xyz;\n        PixelIndex = floor(UV.x)+floor(UV.y)*64.+128.;\n        return max(vec3(0.),2.*tmpc-\n               textureCube(vec2(floor(mod(PixelIndex+0.5,32.))*32.,floor((PixelIndex+0.5)*I32)*32.)+16.,5.).xyz);\n    }\n    if (UV.y>mm.y+mm.w) {\n        float PixelIndex = floor(UV.x)+floor(UV.y)*64.-64.;\n        vec3 tmpc = textureCube(vec2(floor(mod(PixelIndex+0.5,32.))*32.,floor((PixelIndex+0.5)*I32)*32.)+16.,5.).xyz;\n        PixelIndex = floor(UV.x)+floor(UV.y)*64.-128.;\n        return max(vec3(0.),2.*tmpc-\n               textureCube(vec2(floor(mod(PixelIndex+0.5,32.))*32.,floor((PixelIndex+0.5)*I32)*32.)+16.,5.).xyz);\n    }\n    float PixelIndex = floor(UV.x)+floor(UV.y)*64.;\n    return textureCube(vec2(floor(mod(PixelIndex+0.5,32.))*32.,floor((PixelIndex+0.5)*I32)*32.)+16.,5.).xyz;\n}\n\nvec3 InterpolatePatches(vec2 UV, vec4 MinMax) {\n    //Interpolates patches\n    vec3 OUT = vec3(0.);\n    \n    //Nearest\n    /*\n    float PixelIndex = floor(UV.x)+floor(UV.y)*64.;\n    OUT = textureCube(vec2(floor(mod(PixelIndex+0.5,32.))*32.,floor((PixelIndex+0.5)*I32)*32.)+16.,5.).xyz;\n    //*/\n    \n    //Bilinear\n    //*\n    if (DFBox(UV-vec2(48.,24.),vec2(16.,31.))<0.) {\n        //Spherical surface\n        float theta = UV.x-48.;\n        float thetaf = floor(theta);\n        float thetar = 1.+ceil(30.*sin(thetaf/15.*PI));\n        float uvy = 24.+(UV.y-24.)*thetar-0.5;\n        if (uvy<24.) uvy += thetar;\n        float PixelIndex = floor(UV.x)+floor(uvy)*64.;\n        vec3 C00 = textureCube(vec2(floor(mod(PixelIndex+0.5,32.))*32.,floor((PixelIndex+0.5)*I32)*32.)+16.,5.).xyz;\n        uvy = 24.+(UV.y-24.)*thetar+0.5;\n        if (uvy>24.+thetar) uvy -= thetar;\n        PixelIndex = floor(UV.x)+floor(uvy)*64.;\n        vec3 C01 = textureCube(vec2(floor(mod(PixelIndex+0.5,32.))*32.,floor((PixelIndex+0.5)*I32)*32.)+16.,5.).xyz;\n        vec3 C0 = mix(C00,C01,fract(uvy));\n        //Mext theta\n        thetar = 1.+ceil(30.*sin((thetaf+1.)/15.*PI));\n        uvy = 24.+(UV.y-24.)*thetar-0.5;\n        if (uvy<24.) uvy += thetar;\n        PixelIndex = floor(UV.x)+1.+floor(uvy)*64.;\n        C00 = textureCube(vec2(floor(mod(PixelIndex+0.5,32.))*32.,floor((PixelIndex+0.5)*I32)*32.)+16.,5.).xyz;\n        uvy = 24.+(UV.y-24.)*thetar+0.5;\n        if (uvy>24.+thetar) uvy -= thetar;\n        PixelIndex = floor(UV.x)+1.+floor(uvy)*64.;\n        C01 = textureCube(vec2(floor(mod(PixelIndex+0.5,32.))*32.,floor((PixelIndex+0.5)*I32)*32.)+16.,5.).xyz;\n        vec3 C1 = mix(C00,C01,fract(uvy));\n        //Output\n        return mix(C0,C1,fract(UV.x));\n    } else {\n        //Quad surface\n        vec2 buv = UV-0.5;\n        vec2 fuv = fract(buv);\n        vec3 C0 = SamplePatch(buv,MinMax);\n        vec3 C1 = SamplePatch(buv+vec2(1.,0.),MinMax);\n        vec3 C2 = SamplePatch(buv+vec2(0.,1.),MinMax);\n        vec3 C3 = SamplePatch(buv+vec2(1.),MinMax);\n        return mix(mix(C0,C1,fuv.x),mix(C2,C3,fuv.x),fuv.y);\n    }\n    //*/\n    \n    //Output\n    return OUT;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec3 Output = vec3(0.);\n    //Sunlight\n    vec2 Mouse = texture(iChannel0,vec2(0.5,64.5)*IRES).xy;\n    float Interp = max(0.,1.-max(0.,(Mouse.x*IRES.x-0.125)*8.));\n    float MouseAngle = -(Mouse.y*IRES.y-0.5)*PI*1.75-PI;\n    vec3 SunDir = normalize(vec3(sin(MouseAngle),0.85,cos(MouseAngle)));\n    //Primary ray\n    vec3 Dir = normalize(vec3((fragCoord*IRES*2.-1.)*(ASPECT*CFOV),1.))*vec3(-1.,1.,1.);\n    HIT Pixel = Trace(CameraPos,Dir,iTime);\n    if (Pixel.v.x>-0.5) {\n        //Geometry\n        if (Pixel.v.x<64.) {\n            //Diffuse\n            vec4 PixelAttr = texture(iChannel0,Pixel.v.xy*IRES);\n            //Direct light\n            Output += floatToVec3(PixelAttr.w)*8.;\n            vec3 PPos = CameraPos+Dir*Pixel.v.z;\n            vec3 PatchN = normalize(floatToVec3(PixelAttr.y)*2.-1.);\n            if (DFBox(Pixel.v.xy-vec2(48.,24.),vec2(16.,31.))<0.) PatchN = normalize(PPos-DSP);\n            if (dot(PatchN,SunDir)>0. && Trace(PPos,SunDir,iTime).v.x<-1.5) {\n                Output += vec3(1.,0.8,0.6)*dot(PatchN,SunDir)*3.*Interp;\n            }\n            //Indirect light\n            Output.xyz += InterpolatePatches(Pixel.v.xy,Pixel.m);\n            //Color\n            Output *= floatToVec3(PixelAttr.z);\n        } else {\n            //Specular\n            Output.xyz = vec3(0.);\n            vec3 PPos = CameraPos+Dir*Pixel.v.z;\n            vec3 PixelN = normalize(PPos-vec3(0.75,0.225,0.7));\n            vec3 RDir = reflect(Dir,PixelN);\n            HIT RHit = Trace(PPos,RDir,iTime);\n            if (RHit.v.x>-0.5) {\n                vec4 RAttr = texture(iChannel0,RHit.v.xy*IRES);\n                //Direct light\n                Output += floatToVec3(RAttr.w)*8.;\n                vec3 RPPos = PPos+RDir*RHit.v.z;\n                vec3 RPatchN = normalize(floatToVec3(RAttr.y)*2.-1.);\n                if (DFBox(RHit.v.xy-vec2(48.,24.),vec2(16.,31.))<0.) RPatchN = normalize(RPPos-DSP);\n                if (dot(RPatchN,SunDir)>0. && Trace(RPPos,SunDir,iTime).v.x<-1.5) {\n                    Output += vec3(1.,0.8,0.6)*dot(RPatchN,SunDir)*3.*Interp;\n                }\n                //Indirect light\n                Output.xyz += InterpolatePatches(RHit.v.xy,RHit.m);\n                //Color\n                Output *= floatToVec3(RAttr.z);\n            }\n        }\n    }\n    //Output\n    fragColor = vec4(pow(acesFilm(max(vec3(0.),Output)),vec3(0.45)),1.);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"//Constants\nconst float FOV = radians(90.);\nconst vec3 DSP = vec3(0.3125 ,0.21,0.35);\nconst vec3 CameraPos = vec3(0.5,0.501,-0.5);\nconst float LightCoeff = 8.;\nconst float ILightCoeff = 1./LightCoeff;\nconst float CFOV = tan(FOV*0.5);\nconst float PI = 3.141592653;\nconst float HPI = PI*0.5;\nconst float IPI = 1./PI;\nconst float PI2 = PI*2.;\nconst float IPI2 = 0.5/PI;\nconst float ToRadians = PI/180.;\nconst float I3 = 1./3.;\nconst float I12 = 1./12.;\nconst float I16 = 1./16.;\nconst float I24 = 1./24.;\nconst float I32 = 1./32.;\nconst float I48 = 1./48.;\nconst float I64 = 1./64.;\nconst float I128 = 1./128.;\nconst float I256 = 1./256.;\nconst float I512 = 1./512.;\nconst float I1024 = 1./1024.;\nconst float I2048 = 1./2048.;\nconst vec2 eps = vec2(0.00025,0.);\n//RES\n#define RES iChannelResolution[0].xy\n#define IRES (1./iChannelResolution[0].xy)\n#define ASPECT vec2(RES.x/RES.y,1.)\n#define RESOff max(mod(iChannelResolution[0].xy,8.),vec2(0.,1.))\n\nstruct HIT { vec3 v; vec4 m; };\n\n//SDF\nfloat DFBox(vec3 p, vec3 b) {\n    vec3 d = abs(p-b*0.5)-b*0.5;\n    return min(max(d.x,max(d.y,d.z)),0.)+length(max(d,0.));\n}\n\nfloat DFBoxC(vec3 p, vec3 b) {\n    vec3 d = abs(p)-b;\n    return min(max(d.x,max(d.y,d.z)),0.)+length(max(d,0.));\n}\n\nfloat DFBox(vec2 p, vec2 b) {\n    vec2 d = abs(p-b*0.5)-b*0.5;\n    return min(max(d.x,d.y),0.)+length(max(d,0.));\n}\n\nfloat DFBoxC(vec2 p, vec2 b) {\n    vec2 d = abs(p)-b;\n    return min(max(d.x,d.y),0.)+length(max(d,0.));\n}\n\nfloat DFDisk(vec3 p) {\n    float d = length(p.xz-0.5)-0.35;\n    vec2 w = vec2(d,abs(p.y));\n    return min(max(w.x,w.y),0.)+length(max(w,0.));\n}\n\nfloat DFLine(vec3 p, vec3 a, vec3 b) {\n    vec3 ba = b-a;\n    float k = dot(p-a,ba)/dot(ba,ba);\n    return length((a+clamp(k,0.,1.)*(b-a))-p);\n}\n\nfloat DFLine(vec2 p, vec2 a, vec2 b) {\n    vec2 ba = b-a;\n    float k = dot(p-a,ba)/dot(ba,ba);\n    return length((a+clamp(k,0.,1.)*(b-a))-p);\n}\n\nfloat DFCylinder(vec3 p, float r, float h) {\n    vec2 d = vec2(length(p.xz)-r,abs(p.y)-h);\n    return min(max(d.x,d.y),0.)+length(max(d,0.));\n}\n\nfloat DFCone(vec3 p, float CR, float h) {\n    //Credit: iq\n    vec2 q = h*vec2(CR,-1.);\n    vec2 w = vec2(length(p.xz),p.y);\n    vec2 a = w-q*clamp(dot(w,q)/dot(q,q),0.,1.);\n    vec2 b = w-q*vec2(clamp( w.x/q.x,0.,1.),1.);\n    float k = sign(q.y);\n    float d = min(dot(a,a),dot(b,b));\n    float s = max(k*(w.x*q.y-w.y*q.x),k*(w.y-q.y));\n    return sqrt(d)*sign(s);\n}\n\nfloat DFPlane(vec3 p, vec3 p0, vec3 p1, vec3 p2) {\n    //Intersects a plane\n    vec3 Normal = normalize(cross(p1-p0,p2-p0));\n    vec3 tp = vec3(dot(p-p0,normalize(p1-p0)),dot(p-p0,normalize(p2-p0)),dot(p-p0,Normal));\n    return DFBox(tp-vec3(0.,0.,-0.005),vec3(length(p1-p0),length(p2-p0),0.01));\n}\n\nvec2 Rotate(vec2 p, float ang) {\n    float c = cos(ang), s = sin(ang);\n    return vec2(p.x*c-p.y*s,p.x*s+p.y*c);\n}\n\nvec2 Repeat0(vec2 p, float n) {\n    float ang = 2.*3.14159/n;\n    float sector = clamp(floor(atan(p.x,p.y)/ang+0.5),5.,7.);\n    p = Rotate(p,sector*ang);\n    return p;\n}\n\nvec2 Repeat1(vec2 p, float n) {\n    float ang = 2.*3.14159/n;\n    float sector = clamp(floor(atan(p.x,p.y)/ang+0.5),-10.,10.);\n    p = Rotate(p,sector*ang);\n    return p;\n}\n\nfloat smin(float a, float b, float k) {\n    //https://iquilezles.org/articles/smin\n    float h = max(k-abs(a-b),0.)/k;\n    return min(a,b)-h*h*h*k*(1.0/6.0);\n}\n\nmat3 TBN(vec3 N) {\n    vec3 Nb,Nt;\n    if (abs(N.y)>0.999) {\n        Nb = vec3(1.,0.,0.);\n        Nt = vec3(0.,0.,1.);\n    } else {\n    \tNb = normalize(cross(N,vec3(0.,1.,0.)));\n    \tNt = normalize(cross(Nb,N));\n    }\n    return mat3(Nb.x,Nt.x,N.x,Nb.y,Nt.y,N.y,Nb.z,Nt.z,N.z);\n}\n\nvec3 TBN(vec3 N, out vec3 O) {\n    O = ((abs(N.y)<=0.999)?normalize(cross(N,vec3(0.,1.,0.))):vec3(1.,0.,0.));\n    return normalize(cross(O,N));\n}\n\nvec3 RandSample(vec2 v) {\n    float r = sqrt(1.-v.x*v.x);\n    float phi = 2.*3.14159*v.y;\n    return vec3(cos(phi)*r,sin(phi)*r,v.x);\n}\n\nvec3 RandSampleCos(vec2 v) {\n    float theta = sqrt(v.x);\n    float phi = 2.*3.14159*v.y;\n    float x = theta*cos(phi);\n    float z = theta*sin(phi);\n    return vec3(x,z,sqrt(max(0.,1.-v.x)));\n}\n\nvec3 SchlickFresnel(vec3 r0, float angle) {\n    //Schlick Fresnel approximation\n    return r0+(1.-r0)*pow(1.-angle,5.);\n}\n\nvec3 BRDF_GGX(vec3 w_o, vec3 w_i, vec3 n, float alpha, vec3 F0) {\n    vec3 h = normalize(w_i+w_o);\n    float a2 = alpha*alpha;\n    float D = a2/(PI*pow(pow(dot(h,n),2.)*(a2-1.)+1.,2.));\n    vec3 F = F0+(1.-F0)*pow(1.-dot(n,w_o),5.);\n    float k = a2*0.5;\n    float G = 1./((dot(n,w_i)*(1.-k)+k)*(dot(n,w_o)*(1.-k)+k));\n    vec3 OUT = F*(D*G*0.25);\n    return ((isnan(OUT)!=bvec3(false))?vec3(0.):OUT);\n}\n\nfloat IntegrateQuad(vec3 P, vec3 N, vec3 p0, vec3 p1, vec3 p2, vec3 p3) {\n    //Returns the cosine integral over a quad\n    //*\n    vec3 v0 = normalize(p0-P);\n    vec3 v1 = normalize(p1-P);\n    vec3 v2 = normalize(p2-P);\n    vec3 v3 = normalize(p3-P);\n    float ret = abs(dot(N,normalize(cross(v0,v1)))*acos(dot(v0,v1))+\n                    dot(N,normalize(cross(v1,v2)))*acos(dot(v1,v2))+\n                    dot(N,normalize(cross(v2,v3)))*acos(dot(v2,v3))+\n                    dot(N,normalize(cross(v3,v0)))*acos(dot(v3,v0)));\n    return ((isnan(ret))?0.:ret);\n    //*/\n    \n    //Paper: https://ieeexplore.ieee.org/abstract/document/4121581\n    //Solid angle\n    /*\n    vec3 a = p0-P;\n    vec3 b = p1-P;\n    vec3 c = p2-P;\n    vec3 d = p3-P;\n    float al = length(a);\n    float bl = length(b);\n    float cl = length(c);\n    float dl = length(d);\n    return 2.*(atan(dot(a,cross(b,c))/(al*bl*cl+dot(a,b)*cl+dot(a,c)*bl+dot(b,c)*al))+\n               atan(dot(a,cross(c,d))/(al*cl*dl+dot(a,c)*dl+dot(a,d)*cl+dot(c,d)*al)));\n    //*/\n}\n\nvec3 ARand23(vec2 uv) {\n    //Analytic random\n    return fract(sin(uv.x*uv.y)*vec3(403.125,486.125,513.432)+cos(dot(uv,vec2(13.18273,51.2134)))*vec3(173.137,261.23,203.127));\n}\n\nfloat ARand21(vec2 uv) {\n    //Analytic random\n    return fract(sin(uv.x*uv.y)*403.125+cos(dot(uv,vec2(13.18273,51.2134)))*173.137);\n}\n\nvec3 APlane(vec3 P, vec3 D, vec3 Tan, vec3 Bit, vec3 Nor, vec2 Size) {\n    float NorDot = dot(Nor,D);\n    float PDot = dot(Nor,P);\n    if (sign(NorDot*PDot)<-0.5) {\n        float t = -PDot/NorDot;\n        vec2 Hit2 = vec2(dot(P+D*t,Tan),dot(P+D*t,Bit));\n        if (DFBox(Hit2,Size)<0.) return vec3(Hit2,t);\n    }\n    return vec3(-1.);\n}\n\nvec2 ABox(vec2 origin, vec2 dir, vec2 bmin, vec2 bmax) {\n    vec2 tMin = (bmin-origin)*dir;\n    vec2 tMax = (bmax-origin)*dir;\n    vec2 t1 = min(tMin,tMax);\n    vec2 t2 = max(tMin,tMax);\n    return vec2(max(t1.x,t1.y),min(t2.x,t2.y));\n}\n\nvec2 ABox(vec3 origin, vec3 dir, vec3 bmin, vec3 bmax) {\n    vec3 tMin = (bmin-origin)*dir;\n    vec3 tMax = (bmax-origin)*dir;\n    vec3 t1 = min(tMin,tMax);\n    vec3 t2 = max(tMin,tMax);\n    return vec2(max(max(t1.x,t1.y),t1.z),min(min(t2.x,t2.y),t2.z));\n}\n\nfloat ABoxfar(vec2 origin, vec2 dir, vec2 bmin, vec2 bmax) {\n    vec2 tMin = (bmin-origin)*dir;\n    vec2 tMax = (bmax-origin)*dir;\n    vec2 t2 = max(tMin,tMax);\n    return min(t2.x,t2.y);\n}\n\nvec2 ABoxfarNormal(vec2 origin, vec2 dir, vec2 bmin, vec2 bmax) {\n    vec2 tMin = (bmin-origin)*dir;\n    vec2 tMax = (bmax-origin)*dir;\n    vec2 t2 = max(tMin,tMax);\n    vec2 signdir = (max(vec2(0.),sign(dir))*2.-1.);\n    if (t2.x<t2.y) return vec2(signdir.x,0.);\n    else return vec2(0.,signdir.y);\n}\n\nvec3 ABoxfarNormal(vec3 origin, vec3 dir, vec3 bmin, vec3 bmax, out float dist) {\n    vec3 tMin = (bmin-origin)*dir;\n    vec3 tMax = (bmax-origin)*dir;\n    vec3 t2 = max(tMin,tMax);\n    dist = min(min(t2.x,t2.y),t2.z);\n    vec3 signdir = (max(vec3(0.),sign(dir))*2.-1.);\n    if (t2.x<min(t2.y,t2.z)) return vec3(signdir.x,0.,0.);\n    else if (t2.y<t2.z) return vec3(0.,signdir.y,0.);\n    else return vec3(0.,0.,signdir.z);\n}\n\nvec2 ABoxNormal(vec3 origin, vec3 dir, vec3 bmin, vec3 bmax, out vec3 N) {\n    vec3 tMin = (bmin-origin)*dir;\n    vec3 tMax = (bmax-origin)*dir;\n    vec3 t1 = min(tMin,tMax);\n    vec3 t2 = max(tMin,tMax);\n    vec3 signdir = -(max(vec3(0.),sign(dir))*2.-1.);\n    if (t1.x>max(t1.y,t1.z)) N = vec3(signdir.x,0.,0.);\n    else if (t1.y>t1.z) N = vec3(0.,signdir.y,0.);\n    else N = vec3(0.,0.,signdir.z);\n    return vec2(max(max(t1.x,t1.y),t1.z),min(min(t2.x,t2.y),t2.z));\n}\n\nvec3 ABoxNormal(vec3 origin, vec3 dir, vec3 bmin, vec3 bmax) {\n    vec3 tMin = (bmin-origin)*dir;\n    vec3 tMax = (bmax-origin)*dir;\n    vec3 t1 = min(tMin,tMax);\n    vec3 t2 = max(tMin,tMax);\n    vec3 signdir = -(max(vec3(0.),sign(dir))*2.-1.);\n    if (t1.x>max(t1.y,t1.z)) return vec3(signdir.x,0.,0.);\n    else if (t1.y>t1.z) return vec3(0.,signdir.y,0.);\n    else return vec3(0.,0.,signdir.z);\n}\n\nvec3 floatToVec3(float v) {\n    //Returns vec3 from int\n    int VPInt = floatBitsToInt(v);\n    int VPInt1024 = VPInt%1024;\n    int VPInt10241024 = ((VPInt-VPInt1024)/1024)%1024;\n    return vec3(VPInt1024,VPInt10241024,((VPInt-VPInt1024-VPInt10241024)/1048576))*I1024;\n}\n\nfloat vec3ToFloat(vec3 v) {\n    //Returns \"int\" from vec3 (10 bit per channel)\n    ivec3 intv = min(ivec3(floor(v*1024.)),ivec3(1023));\n    return intBitsToFloat(intv.x+intv.y*1024+intv.z*1048576);\n}\n\nvec2 floatToVec2(float v) {\n    //Returns vec3 from int\n    int VPInt = floatBitsToInt(v);\n    int VPInt16k = VPInt%1048576;\n    return vec2(VPInt16k,((VPInt-VPInt16k)/1048576)%1048576);\n}\n\nfloat vec2ToFloat(vec2 v) {\n    //Returns \"int\" from vec3 (10 bit per channel)\n    ivec2 intv = min(ivec2(floor(v*1048576.)),ivec2(1048575));\n    return intBitsToFloat(intv.x+intv.y*1048576);\n}\n\nvec2 floatToVec2WM(float v) {\n    return vec2(fract(v),floor(v));\n}\n\nfloat vec2ToFloatWM(vec2 v) {\n    return min(v.x,0.99999)+floor(v.y);\n}\n\nfloat TraceSphere(vec3 p, vec3 d, float r) {\n    float P = 2.*dot(p,d);\n    float Q = dot(p,p)-r*r;\n    float pow2 = P*P*0.25-Q;\n    if (P<0. && pow2>0.) {\n        float t = -P*0.5-sqrt(pow2);\n        vec3 hitp = p+d*t;\n        return t;\n    } else {\n        return -1.;\n    }\n}\n\nHIT Trace(vec3 P, vec3 D, float Time) {\n    //Ray tracing\n    vec3 ID = 1./D;\n    HIT OUT = HIT(vec3(-2.,-2.,1000000),vec4(0.));\n    \n    //Floor\n    if (max(-P.y,D.y)<0.) {\n        float t = -P.y/D.y;\n        if (DFBox(P.xz+D.xz*t,vec2(1.))<0.) {\n            OUT = HIT(vec3((P+D*t).xz*24.,t),vec4(0.,0.,24.,24.));\n        }\n    }\n    //Ceiling\n    if (max(P.y-1.,-D.y)<0.) {\n        float t = -(P.y-1.)/D.y;\n        if (t<OUT.v.z && DFBox(P.xz+D.xz*t,vec2(1.))<0.) {\n            OUT = HIT(vec3(vec2(24.,0.)+(P+D*t).xz*24.,t),vec4(24.,0.,24.,24.));\n        }\n    }\n    \n    \n    //X Walls\n    if (max(-P.x,D.x)<0.) {\n        //Red wall\n        float t = -P.x/D.x;\n        if (t<OUT.v.z && DFBox(P.zy+D.zy*t,vec2(1.))<0.) {\n            OUT = HIT(vec3(vec2(0.,24.)+(P.zy+D.zy*t)*24.,t),vec4(0.,24.,24.,24.));\n        }\n    }\n    if (max(P.x-1.,-D.x)<0.) {\n        //Green wall\n        float t = -(P.x-1.)/D.x;\n        if (t<OUT.v.z && DFBox(P.zy+D.zy*t,vec2(1.))<0.) {\n            OUT = HIT(vec3(vec2(24.,24.)+(P.zy+D.zy*t)*24.,t),vec4(24.,24.,24.,24.));\n        }\n    }\n    \n    //Z Walls\n    if (max(P.z-1.,-D.z)<0.) {\n        float t = -(P.z-1.)/D.z;\n        vec2 tuv = (P.xy+D.xy*t)*24.-vec2(8.,0.);\n        if (t<OUT.v.z && DFBox(tuv,vec2(16.,24.))<0.) {\n            OUT = HIT(vec3(vec2(48.,0.)+tuv,t),vec4(48.,0.,16.,24.));\n        }\n    }\n    \n    \n    //Sphere diffuse\n    vec3 RP = P-DSP;\n    float spherehit = TraceSphere(RP,D,0.2);\n    if (spherehit>-0.5 && spherehit<OUT.v.z) {\n        vec3 hitp = RP+D*spherehit;\n        float theta = atan(length(hitp.xz),hitp.y);\n        theta = theta*IPI*16.;\n        float thetaFloor = floor(theta);\n        float YRes = 1.+ceil(30.*sin(thetaFloor/15.*PI));\n        float phiUV = (atan(hitp.x,hitp.z)*IPI*0.5+0.5)*YRes;\n        OUT = HIT(vec3(vec2(48.,24.)+vec2(theta,phiUV/YRes),spherehit),vec4(-1.));\n    }\n    \n    //Sphere specular\n    spherehit = TraceSphere(P-vec3(0.75,0.225,0.7),D,0.225);\n    if (spherehit>-0.5 && spherehit<OUT.v.z) {\n        OUT = HIT(vec3(vec2(65.5),spherehit),vec4(-1.));\n    }\n    \n    \n    \n    RP = P-vec3(4.*I24,0.,13.*I24);\n    RP.xz = Rotate(RP.xz,-0.8);\n    vec3 RD = D; RD.xz = Rotate(RD.xz,-0.8);\n    if (max(RP.z,-RD.z)<0.) {\n        //Front\n        float t = -RP.z/RD.z;\n        vec2 tuv = (RP.xy+RD.xy*t)*24.;\n        if (t<OUT.v.z && DFBox(tuv,vec2(12.,16.))<0.) {\n            OUT = HIT(vec3(vec2(0.,48.)+tuv,t),vec4(0.,48.,12.,16.));\n        }\n    }\n    if (max(-RP.z+2.*I24,RD.z)<0.) {\n        //Back\n        float t = -(RP.z-2.*I24)/RD.z;\n        vec2 tuv = (RP.xy+RD.xy*t)*24.;\n        if (t<OUT.v.z && DFBox(tuv,vec2(12.,16.))<0.) {\n            OUT = HIT(vec3(vec2(12.,48.)+tuv,t),vec4(12.,48.,12.,16.));\n        }\n    }\n    if (max(RP.x,-RD.x)<0.) {\n        //Side +\n        float t = -RP.x/RD.x;\n        vec2 tuv = (RP.zy+RD.zy*t)*24.;\n        if (t<OUT.v.z && DFBox(tuv,vec2(2.,16.))<0.) {\n            OUT = HIT(vec3(vec2(24.,48.)+tuv,t),vec4(24.,48.,2.,16.));\n        }\n    }\n    if (max(-RP.y+0.66666666666,RD.y)<0.) {\n        //Side +\n        float t = -(RP.y-0.66666666666)/RD.y;\n        vec2 tuv = (RP.xz+RD.xz*t)*24.;\n        if (t<OUT.v.z && DFBox(tuv,vec2(12.,2.))<0.) {\n            OUT = HIT(vec3(vec2(26.,48.)+tuv.yx,t),vec4(26.,48.,2.,12.));\n        }\n    }\n    \n    //Output\n    return OUT;\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//Patches: attributes\n\nvoid UpdateMouse(inout vec4 Output, vec4 Mouse) {\n    //Updates the last frame mouse\n    if (Mouse.z>0.) {\n        if (Output.w==0.) {\n            Output.w = 1.;\n            Output.xy = Mouse.zw;\n        }\n    } else Output.w = 0.;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec4 Output = vec4(0.);\n    //Actual mouse logic\n    vec4 CurrentMouse = texture(iChannel0,vec2(1.5,64.5)*IRES);\n    UpdateMouse(CurrentMouse,iMouse);\n    //Animation mouse\n    vec4 Mouse4 = texture(iChannel0,vec2(0.5,64.5)*IRES);\n    vec2 Mouse;\n    if (CurrentMouse.w==0.) {\n        Mouse4.z += iTimeDelta;\n        float AT = max(0.,Mouse4.z+4.);\n        Mouse = vec2(cos(AT*0.17)*0.5+0.5,cos((cos(AT*0.6+1.95)*0.5+0.5)*PI)*0.286+0.5)*RES;\n    } else {\n        Mouse = iMouse.xy;\n    }\n    //Output\n    if (length(fragCoord-vec2(1.5,64.5))<0.7) {\n        //Actual mouse\n        Output = ((iFrame<2)?vec4(0.):CurrentMouse);\n    } else if (length(fragCoord-vec2(0.5,64.5))<0.7) {\n        //Animation mouse\n        Output.xyz = vec3(Mouse,Mouse4.z);\n    } else if (DFBox(fragCoord,vec2(64.*2.,64.))<0.) {\n        //Patch attributes\n        Output = vec4(-1.);\n        vec2 UV = vec2(mod(fragCoord.x,64.),fragCoord.y);\n        //Patch\n        vec3 PatchP = vec3(0.);\n        vec3 PatchN = vec3(0.);\n        vec3 PatchC = vec3(0.98);\n        vec3 PatchL = vec3(0.); //Not initialized\n        \n        //Floor\n        if (DFBox(UV,vec2(24.))<0.) {\n            //Ground\n            PatchP = vec3(UV.x*I24,0.,UV.y*I24);\n            PatchN = vec3(0.,1.,0.);\n        } else if (DFBox(UV-vec2(24.,0.),vec2(24.))<0.) {\n            //Ceiling\n            PatchP = vec3((UV.x-24.)*I24,1.,UV.y*I24);\n            PatchN = vec3(0.,-1.,0.);\n            if (Mouse.x>RES.x*0.75) {\n                if (DFBox(vec2(UV.x-24.,UV.y)-8.,vec2(8.,cos(iTime)*0.+8.))<0.)\n                    PatchL = vec3(5.5*min(1.,(Mouse.x*IRES.x-0.75)*16.));\n            }\n        } else if (DFBox(UV-vec2(0.,24.),vec2(24.))<0.) {\n            //X = 0\n            PatchP = vec3(0.,(UV.y-24.)*I24,UV.x*I24);\n            PatchN = vec3(1.,0.,0.);\n            float Interp = max(0.,1.-abs(Mouse.x*IRES.x-5.*0.125)*8.);\n            PatchC = mix(vec3(0.98,0.15,0.15),vec3(1.,0.2,0.05),Interp);\n            PatchL = vec3(5.*Interp);\n        } else if (DFBox(UV-vec2(24.,24.),vec2(24.))<0.) {\n            //X = 1\n            PatchP = vec3(1.,(UV.y-24.)*I24,(UV.x-24.)*I24);\n            PatchN = vec3(-1.,0.,0.);\n            float Interp = max(0.,1.-abs(Mouse.x*IRES.x-3.*0.125)*8.);\n            PatchC = mix(vec3(0.2,0.98,0.2),vec3(0.3,1.,0.3),Interp);\n            PatchL = vec3(2.*Interp);\n        } else if (DFBox(UV-vec2(48.,0.),vec2(16.,24.))<0.) {\n            //Z = 1\n            PatchP = vec3((UV.x-48.+8.)*I24,UV.y*I24,1.);\n            PatchN = vec3(0.,0.,-1.);\n        }\n        if (DFBox(UV-vec2(48.,24.),vec2(16.,31.))<0.) {\n            //Sphere diffuse\n            vec2 SUV = UV-vec2(48.,24.);\n            float theta = floor(SUV.x)/15.*PI;\n            float circum = ceil(30.*sin(theta))+1.;\n            if (SUV.y<circum) {\n                float phi = (SUV.y/circum)*2.*PI;\n                PatchN = vec3(vec2(-sin(phi),-cos(phi))*sin(theta),cos(theta)).xzy;\n                PatchP = DSP+PatchN*0.2;\n            }\n        }\n        if (DFBox(UV-vec2(0.,48.),vec2(12.,16.))<0.) {\n            //Rotated box Z front\n            PatchN = vec3(0.7173560909,0.,-0.69670670934);\n            vec3 PatchTan = vec3(-PatchN.z,0.,PatchN.x);\n            PatchP = vec3(4.*I24,0.,13.*I24)+PatchTan*(UV.x*I24)+vec3(0.,(UV.y-48.)*I24,0.);\n        }\n        if (DFBox(UV-vec2(12.,48.),vec2(12.,16.))<0.) {\n            //Rotated box Z back\n            PatchN = vec3(-0.7173560909,0.,0.69670670934);\n            vec3 PatchTan = vec3(PatchN.z,0.,-PatchN.x);\n            PatchP = vec3(4.*I24,0.,13.*I24)+PatchN*I24*2.+PatchTan*((UV.x-12.)*I24)+vec3(0.,(UV.y-48.)*I24,0.);\n        }\n        if (DFBox(UV-vec2(24.,48.),vec2(2.,16.))<0.) {\n            //Rotated box Z side\n            PatchN = vec3(-0.69670670934,0.,-0.7173560909);\n            vec3 PatchTan = vec3(PatchN.z,0.,-PatchN.x);\n            PatchP = vec3(4.*I24,0.,13.*I24)+PatchTan*((UV.x-24.)*I24)+vec3(0.,(UV.y-48.)*I24,0.);\n        }\n        if (DFBox(UV-vec2(26.,48.),vec2(2.,12.))<0.) {\n            //Rotated box Y top\n            PatchN = vec3(-0.7173560909,0.,0.69670670934);\n            vec3 PatchTan = vec3(PatchN.z,0.,-PatchN.x);\n            PatchP = vec3(4.*I24,16.*I24,13.*I24)+PatchN*((UV.x-26.)*I24)+PatchTan*((UV.y-48.)*I24);\n            PatchN = vec3(0.,1.,0.);\n        }\n        \n        //Output\n        if (fragCoord.x>64.) {\n            Output.xyz = PatchP;\n        } else {\n            Output = vec4(vec3ToFloat(PatchP),\n                          vec3ToFloat(PatchN*0.5+0.5),\n                          vec3ToFloat(PatchC),\n                          vec3ToFloat(PatchL*0.125));\n        }\n    } else discard;\n    fragColor = Output;\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dX3Rr","filepath":"/media/a//media/previz/cubemap00.png","previewfilepath":"/media/ap//media/previz/cubemap00.png","type":"cubemap","channel":3,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dX3Rr","channel":0}],"code":"vec4 textureCube(vec2 UV) {\n    //Samples the cubemap\n    float Sign = -mod(floor(UV.y*I1024),2.)*2.+1.;\n    vec3 D = vec3(vec2(UV.x,mod(UV.y,1024.))*I512-1.,Sign);\n    if (UV.y>4096.) D = D.xzy;\n    else if (UV.y>2048.) D = D.zxy;\n    return textureLod(iChannel3,D,0.);\n}\n\nvec4 textureCube(vec2 UV, float LOD) {\n    //Samples the cubemap\n    float Sign = -mod(floor(UV.y*I1024),2.)*2.+1.;\n    vec3 D = vec3(vec2(UV.x,mod(UV.y,1024.))*I512-1.,Sign);\n    if (UV.y>4096.) D = D.xzy;\n    else if (UV.y>2048.) D = D.zxy;\n    return textureLod(iChannel3,D,LOD);\n}\n\nvoid mainCubemap(out vec4 fragColor, in vec2 fragCoord, in vec3 rayOri, in vec3 rayDir) {\n    vec4 Output = texture(iChannel3,rayDir);\n    vec2 UV; vec3 aDir = abs(rayDir);\n    if (aDir.z>max(aDir.x,aDir.y)) {\n        //Z-side\n        UV = floor(((rayDir.xy/aDir.z)*0.5+0.5)*1024.)+0.5;\n        if (rayDir.z<0.) UV.y += 1024.;\n    } else if (aDir.x>aDir.y) {\n        //X-side\n        UV = floor(((rayDir.yz/aDir.x)*0.5+0.5)*1024.)+0.5;\n        if (rayDir.x>0.) UV.y += 2048.;\n        else UV.y += 3072.;\n    } else {\n        //Y-side\n        UV = floor(((rayDir.xz/aDir.y)*0.5+0.5)*1024.)+0.5;\n        if (rayDir.y>0.) UV.y += 4096.;\n        else UV.y += 5120.;\n    }\n    if (UV.y<4096.) {\n        Output = vec4(0.);\n        //Patch attributes\n        float CurrentFrame = float(iFrame);\n        float PatchIndex = floor(UV.x*I32)+floor(UV.y*I32)*32.;\n        vec2 PatchUV = vec2(floor(mod(PatchIndex+0.5,64.))+0.5,floor((PatchIndex+0.5)*I64)+0.5);\n        vec4 PatchAttr = texture(iChannel0,PatchUV*IRES);\n        if (PatchAttr.w>-0.5) {\n            //Valid current patch\n            vec3 PatchP = texture(iChannel0,(PatchUV+vec2(64.,0.))*IRES).xyz;\n            vec3 PatchN = normalize(floatToVec3(PatchAttr.y)*2.-1.);\n            vec2 SPatchUVFloor = floor(mod(UV,32.))*2.;\n            for (float uvx=0.5; uvx<2.; uvx++) {\n                for (float uvy=0.5; uvy<2.; uvy++) {\n                    vec3 SLight = vec3(0.);\n                    vec2 SPatchUV = SPatchUVFloor+vec2(uvx,uvy);\n                    vec4 SPatchAttr = texture(iChannel0,SPatchUV*IRES);\n                    if (SPatchAttr.w>-0.5) {\n                        vec3 SPatchP = texture(iChannel0,(SPatchUV+vec2(64.,0.))*IRES).xyz;\n                        vec3 SPatchN = normalize(floatToVec3(SPatchAttr.y)*2.-1.);\n                        vec3 SRP = SPatchP-PatchP;\n                        if (dot(SRP,SRP)>0.0005 && min(dot(SRP,PatchN),dot(-SRP,SPatchN))>0.) {\n                            //Potentially visible\n                            if (Trace(PatchP,normalize(SRP),iTime).v.z<length(SRP)-I1024) {\n                                //At least partially occluded\n                                continue;\n                            }\n                            //Direct light\n                            SLight += texture(iChannel1,SPatchUV*IRES).xyz;\n                            //Temporal indirect light (0.97 factor is used to reduce 1 sample visibility bias)\n                            float PixelIndex = floor(SPatchUV.x)+floor(SPatchUV.y)*64.;\n                            vec2 PixelIndexUV = vec2(floor(mod(PixelIndex+0.5,32.))*32.,floor((PixelIndex+0.5)*I32)*32.)+16.;\n                            SLight += textureCube(PixelIndexUV,5.).xyz*0.97;\n                            //Formfactor\n                            vec3 STan; vec3 SBit = TBN(SPatchN,STan);\n                            vec3 sp0 = SPatchP+(-STan-SBit)*I48;\n                            vec3 sp1 = SPatchP+(STan-SBit)*I48;\n                            vec3 sp2 = SPatchP+(STan+SBit)*I48;\n                            vec3 sp3 = SPatchP+(-STan+SBit)*I48;\n                            sp0 -= PatchN*min(0.,dot(PatchN,sp0-PatchP));\n                            sp1 -= PatchN*min(0.,dot(PatchN,sp1-PatchP));\n                            sp2 -= PatchN*min(0.,dot(PatchN,sp2-PatchP));\n                            sp3 -= PatchN*min(0.,dot(PatchN,sp3-PatchP));\n                            float FormFactor = max(0.,IntegrateQuad(PatchP,PatchN,sp0,sp1,sp2,sp3));\n                            Output.xyz += SLight*floatToVec3(SPatchAttr.z)*FormFactor;\n                        }\n                    }\n                }\n            }\n            //Formfactor constant\n            Output.xyz *= 1024.*IPI*0.5;\n        }\n    } else discard;\n    //Output\n    fragColor = Output;\n}","name":"Cube A","description":"","type":"cubemap"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"//Patches: sun rays\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec4 Output = vec4(0.);\n    if (DFBox(fragCoord,vec2(256.))<0.) {\n        //Shadow ray atlas\n        vec2 PatchUV = floor(fragCoord*0.25)+0.5;\n        vec4 PatchAttr = texture(iChannel0,PatchUV*IRES);\n        if (PatchAttr.w>-0.5) {\n            //Valid current patch\n            vec3 PatchP = texture(iChannel0,(PatchUV+vec2(64.,0.))*IRES).xyz;\n            vec3 PatchN = normalize(floatToVec3(PatchAttr.y)*2.-1.);\n            vec3 PatchTan; vec3 PatchBit = TBN(PatchN,PatchTan);\n            vec3 ShadowPos = PatchP+PatchN*0.0001+(PatchTan*(mod(fragCoord.x,4.)-2.)+PatchBit*(mod(fragCoord.y,4.)-2.))*0.25*I24;\n            //Sun\n            vec2 Mouse = texture(iChannel0,vec2(0.5,64.5)*IRES).xy;\n            float MouseAngle = -(Mouse.y*IRES.y-0.5)*PI*1.75-PI;\n            vec3 SunDir = normalize(vec3(sin(MouseAngle),0.85,cos(MouseAngle)));\n            if (dot(PatchN,SunDir)>0. && Trace(ShadowPos,SunDir,iTime).v.x<-1.5) {\n                //Visible\n                Output.xyz = vec3(1.,0.8,0.6)*dot(PatchN,SunDir)*3.;\n            }\n        }\n    }\n    fragColor = Output;\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"//Patches: emissive + direct light\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    if (DFBox(fragCoord,vec2(64.))<0.) {\n        vec2 LODUV = floor(fragCoord)*4.+1.;\n        vec3 DirectLight = (texture(iChannel1,LODUV*IRES).xyz+\n                     texture(iChannel1,(LODUV+vec2(0.,2.))*IRES).xyz+\n                     texture(iChannel1,(LODUV+vec2(2.,0.))*IRES).xyz+\n                     texture(iChannel1,(LODUV+2.)*IRES).xyz)*0.25;\n        vec3 EmissiveLight = floatToVec3(texture(iChannel0,fragCoord*IRES).w)*8.;\n        vec2 Mouse = texture(iChannel0,vec2(0.5,64.5)*IRES).xy;\n        float Interp = max(0.,1.-max(0.,(Mouse.x*IRES.x-0.125)*8.));\n        fragColor = vec4(EmissiveLight+DirectLight*Interp,1.);\n    } else {\n        discard;\n    }\n}","name":"Buffer C","description":"","type":"buffer"}]}