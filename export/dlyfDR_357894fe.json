{"ver":"0.1","info":{"id":"dlyfDR","date":"1701974303","viewed":115,"name":"Concentric sdf triangles","username":"Chriscamplin","description":"concentric sdf curved triangles, coloured and shaded using techniques from Xor's shader: https://www.shadertoy.com/view/ctGyWK","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["sdf","concentric"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// learning from Xor: https://www.shadertoy.com/view/ctGyWK\n#define PI 3.14159265359\n\nmat2 rotate(float angle) {\n    return mat2(cos(angle/4.+vec4(0,11,33,0)));\n}\n\nfloat roundSquareSdf(vec2 uv, float radius, float angle ) {\n\n   return max(length(uv-=rotate(angle)*clamp(uv*rotate(angle),-radius,radius)),.1);\n}\n\n// https://iquilezles.org/articles/distfunctions2d/\nfloat sdEquilateralTriangle( in vec2 p, in float r, in float angle )\n{\n    const float k = sqrt(3.0);\n    p.x = abs(p.x) - r;\n    p.y = p.y + r/k;\n    if( p.x+k*p.y>0.0 ) p = vec2(p.x-k*p.y,-k*p.x-p.y)/2.0;\n    p.x -= clamp( p.x, -2.0*r, 0.0 );\n    return max(-length(p*rotate(angle))*sign(p.y),.1);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //Initialize hue \n    vec4 hue; \n    \n    //Uvs and resolution for scaling\n    vec2 res=iResolution.xy;\n    vec2 uv=(fragCoord+fragCoord-res)/res.y;\n    \n    vec4 color = vec4(0.);\n    \n    //Alpha, length, angle and iterator/radius\n    float Alpha;\n    float angle;\n    float t = iTime*.5;\n    float s = abs(sin((PI*2.) * (iTime - 0.75) / 8.) / 2.0) + 0.5;\n    for(float i=1.5;i>.036;i-=.1) {\n        //Smoothly rotate a half at a time from xor\n        //        a-=sin(a-=sin(a=(iTime+i)*4.)),\n\n        angle-=sin(angle-=sin(angle=(t+i)*8.));\n        // update UV inside the loop\n        uv=(fragCoord+fragCoord-res)/res.x;\n        //uv*=mat2(1.5,1.5,-1,1);\n        uv*=rotate(i+angle+t);\n        //Compute rounded triangle SDF\n        float triangle = sdEquilateralTriangle(uv, i, angle+iTime);\n\n        //Compute anti-aliased alpha using SDF from Xor\n        float Alpha=min((triangle-.1)*res.y*res.x*.2,.9);\n        //Pick layer color from xor\n        fragColor=mix(hue=sin(i/.1+angle/3.+vec4(-2,2,8,0))*.3+.7,fragColor,Alpha);\n       //Soft shading from xor\n       fragColor*=mix(hue/hue,hue+.089*Alpha*uv.y/triangle,.109/triangle);\n    }\n    \n    \n}","name":"Image","description":"","type":"image"}]}