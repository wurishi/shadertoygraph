{"ver":"0.1","info":{"id":"clSBDD","date":"1694026852","viewed":40,"name":"sphere with light and shadow","username":"tomcat7479","description":"Draw a three-dimensional sphere with shadows and light","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["3d","sdf","softshadow"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define min_iter_distance 0.1\n#define max_iter_distance 200.0\n#define iter_count 200\n#define iter_precision 1e-4\n#define PI 3.1415926\n#define N 3\n\nvec2 fix(in vec2 fragCoord) {\n    return (2.0 * fragCoord.xy - iResolution.xy) / min(iResolution.x, iResolution.y);\n}\n\nfloat sdfSphere(vec3 p, vec3 center, float radius) {\n    return length(p - center) - radius;\n}\n\nfloat compose(vec3 p, vec3 center, float radius) {\n    float d = sdfSphere(p, center, radius);\n    return min(d, p.y + radius);\n}\n\nmat3 setCamera(vec3 model_pos, vec3 ray_pos, float cr) {\n    vec3 z = normalize(model_pos - ray_pos);\n    vec3 cp = vec3(sin(cr), cos(cr), 0.0); \n    vec3 x = normalize(cross(z, cp)); \n    vec3 y = cross(x, z);\n    return mat3(x, y, z);\n}\n\nvec3 calNormal(vec3 p, vec3 center, float radius) {\n    const float h = 1e-4;\n    const vec2 k = vec2(1.0, -1.0);\n    vec3 part1 = k.xyy * compose(p + k.xyy * h, center, radius);\n    vec3 part2 = k.yyx * compose(p + k.yyx * h, center, radius);\n    vec3 part3 = k.yxy * compose(p + k.yxy * h, center, radius);\n    vec3 part4 = k.xxx * compose(p + k.xxx * h, center, radius);\n    return normalize(part1 + part2 + part3 + part4);\n}\n\nfloat rayMarch(vec3 ray_o, vec3 ray_d, vec3 center, float radius) {\n    float t = min_iter_distance;\n    for (int i = 0; i < iter_count; i++) {\n        vec3 p = ray_o + t * ray_d;\n        float d = compose(p, center, radius);\n        if (d < iter_precision) {\n            break;\n        }\n        t += d;\n    }\n    return t;\n}\n\n// float softShadow(vec3 ray_o, vec3 ray_d, vec3 center, float radius, float k) {\n//     float res = 1.0;\n//     for (float t = min_iter_distance; t < max_iter_distance;) {\n//         vec3 p = ray_o + t * ray_d;\n//         float h = compose(p, center, radius);\n//         if (h < 0.001) {\n//             return 0.0;\n//         }\n//         res = min(res, k * h / t);\n//         t += h;\n//     }\n//     return res;\n// }\n\nfloat softShadow(vec3 ray_o, vec3 ray_d, vec3 center, float radius, float k) {\n    float res = 1.0;\n    float ph = 1e20;\n    for (float t = min_iter_distance; t < max_iter_distance; ) {\n        vec3 p = ray_o + t * ray_d;\n        float h = compose(p, center, radius);\n        if (h < 0.001) {\n            return 0.0;\n        }\n        float y = h * h / (2.0 * ph);\n        float d = sqrt(h * h - y * y);\n        res = min(res, k * d / max(0.0, t - y));\n        ph = h;\n        t += h;\n    }\n    return res;\n}\n\nvec3 render(in vec2 uv) {\n    float amb_strength = 0.32;\n    float diff_strength = 0.89;\n    float spec_strength = 0.71;\n    float brightness = 100.0;\n    float model_radius = 0.8;\n    vec3 light_color = vec3(1.0);\n    vec3 light_pos = vec3(2.0, 3.0, 2.0);\n    vec3 model_color = vec3(0.84, 0.55, 0.1);\n    vec3 model_center = vec3(0.0, 0.0, 0.0);\n    vec3 ray_o = vec3(4.0 * cos(iTime), 1.0, 4.0 * sin(iTime));\n\n    if (iMouse.z > 0.01) {\n        float theta = iMouse.x / iResolution.x * 2.0 * PI;\n        ray_o = vec3(2.0 * cos(theta), 1.0, 2.0 * sin(theta));\n    }\n\n    mat3 camera = setCamera(vec3(0.0), ray_o, 0.0);\n    vec3 ray_d = normalize(camera * vec3(uv, 1.0));\n    float d = rayMarch(ray_o, ray_d, model_center, model_radius);\n    vec3 color = vec3(0.0);\n    if (d < max_iter_distance) {\n        vec3 p = ray_o + d * ray_d;\n        vec3 n = normalize(calNormal(p, model_center, model_radius));\n\n        vec3 ambient = model_color * light_color * amb_strength;\n\n        float diff_cos = clamp(dot(n, normalize(light_pos - p)), 0.0, 1.0);\n        p += iter_precision * n;\n        float shadow_d = softShadow(p, normalize(light_pos - p), model_center, model_radius, 1.0);\n        diff_cos *= shadow_d;\n        vec3 diffuse = light_color * diff_cos * diff_strength;\n\n        vec3 refL = normalize(reflect(light_pos - p, n));\n        float spec_cos = clamp(dot(refL, ray_d), 0.0, 1.0);\n        vec3 specular = light_color * pow(spec_cos, brightness) * spec_strength;\n\n        color = ambient + diffuse + specular;\n    }\n    return sqrt(color);\n}\n\nvec3 after_smooth(in vec2 fragCoord) {\n    vec3 color = vec3(0.0);\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            vec2 offset = 2.0 * (vec2(float(i), float(j)) / float(N) - 0.5);\n            vec2 uv = fix(fragCoord + offset);\n            color += render(uv);\n        }\n    }\n    return color / float(N * N);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    fragColor = vec4(after_smooth(fragCoord), 1.0);\n}","name":"Image","description":"","type":"image"}]}