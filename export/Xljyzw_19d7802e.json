{"ver":"0.1","info":{"id":"Xljyzw","date":"1507931738","viewed":148,"name":"Twisty Cube!","username":"Fading_Pixel","description":"See tags.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raymarch","art","cool"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 RotY(vec3 p, float rot) {\n    float rad = length(p.xz);\n    float thet = atan(p.x,p.z)+rot;\n    float x = cos(thet)*rad;\n    float z = sin(thet)*rad;\n    return vec3(x,p.y,z);\n}\nvec3 RotX(vec3 p, float rot) {\n    float rad = length(p.yz);\n    float thet = atan(p.y,p.z)+rot;\n    float y = cos(thet)*rad;\n    float z = sin(thet)*rad;\n    return vec3(p.x,y,z);\n}\nvec3 interp(vec3 a, vec3 b, float val) {\n    return a + ((b-a)*val);\n}\nfloat CSDF(vec3 p3,float sl2, float IT) {\n    vec3 a = RotX(p3,(p3.x*sin(IT*4.0))*0.6);\n    vec3 b = RotY(a,(p3.y*sin(IT*4.0))*0.6);\n    vec3 p = b;\n    //p = RotY(p3,p3.y*sin(IT*4.0));\n    float sl = sl2;\n    sl /= 2.0;\n    vec3 p2 = abs(p) - vec3(sl,sl,sl);\n    float iD = min(max(p2.x, max(p2.y, p2.z)), 0.0);\n    float oD = length(max(p2, 0.0));\n    return iD + oD - 0.2;\n    //return length(max(abs(p)-sl,0.0));\n}\nfloat SDF(vec3 p, float IT) {\n    return CSDF(p,1.0,IT);\n}\nvec2 SDMarch(vec3 d, vec3 e, float IT) {\n    float depth = 0.0;\n    for (int i = 0; i < 200; i++) {\n        float dist = SDF(e+(depth*d), IT);\n        if (dist < 0.001) {\n            return vec2(dist,depth);\n        }\n        depth += dist;\n        if (depth > 50.0) {\n            return vec2(100.0,100.0);\n        }\n    }\n    return vec2(100.0,100.0);\n}\nvec3 getNorm(vec3 p, float IT) {\n    return normalize(vec3(\n        SDF(vec3(p.x + 0.001, p.y, p.z), IT) - SDF(vec3(p.x - 0.001, p.y, p.z), IT),\n        SDF(vec3(p.x, p.y + 0.001, p.z), IT) - SDF(vec3(p.x, p.y - 0.001, p.z), IT),\n        SDF(vec3(p.x, p.y, p.z  + 0.001), IT) - SDF(vec3(p.x, p.y, p.z - 0.001), IT)\n    ));\n}\nvec3 getLight(vec3 p, vec3 source, float IT) {\n    vec3 amb = vec3(0.1,0.0,0.0);\n    amb = (getNorm(p, IT) + vec3(1.0)) / 2.0;\n    vec3 norm = getNorm(p, IT);\n    vec3 vec = normalize(source-p);\n    if (dot(vec,norm) < 0.0) {\n        return amb;\n    }\n    float l = 1.5;\n    //clamp(vec3((l-length(p-source))/l,0.0,0.0),0.0,1.0)\n    return amb + (vec3(1.0,1.0,1.0)*dot(vec,norm));\n}\nvec3 Dir(vec2 FC) {\n    vec2 RC = FC-(iResolution.xy/2.0);\n    float Z = iResolution.y / tan(radians(45.0) / 2.0);\n    return normalize(vec3(RC,-Z));\n}\nmat4 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat4(\n        vec4(s, 0.0),\n        vec4(u, 0.0),\n        vec4(-f, 0.0),\n        vec4(0.0, 0.0, 0.0, 1)\n    );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    //(sin(iTime)+cos(iTime))*6.5\n\tvec3 e = vec3(sin(iTime)*5.0,cos(iTime)*3.0,(sin(iTime)+cos(iTime))*6.5);\n    vec3 d = (viewMatrix(e,vec3(0.0, 0.0, 0.0),vec3(0.0, 1.0, 0.0)) * vec4(Dir(fragCoord),0.0)).xyz;\n    vec3 l = vec3(sin(iTime)*1.5,sin(iTime+10.0)*1.5,1.5);\n    //l = vec3(iMouse.x/iResolution.x,iMouse.y/iResolution.y,0.8);\n    vec2 m = SDMarch(d,e,iTime);\n    float dist = m.x;\n    vec3 p = e + (m.y*d);\n    //p = vec3(0.0,0.0,0.8);\n    vec3 light = getLight(p,l,iTime);\n    vec3 light2 = getLight(p,l,iTime);\n    light /= (m.y*m.y)/50.0;\n    light = vec3(clamp(light.x,0.0,light2.x),clamp(light.y,0.0,light2.y),clamp(light.z,0.0,light2.z));\n    if (dist < 0.001) {\n        fragColor = vec4(light,1.0);\n    } else {\n        fragColor = vec4(0.0,0.0,0.0,1.0);\n    }\n}","name":"Image","description":"","type":"image"}]}