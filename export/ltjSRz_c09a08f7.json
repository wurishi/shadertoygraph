{"ver":"0.1","info":{"id":"ltjSRz","date":"1441302352","viewed":469,"name":"CRT.001","username":"Pier","description":"First version of crt emulation.","likes":10,"published":1,"flags":0,"usePreview":0,"tags":["crt"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sX3Rn","filepath":"/media/a/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv","previewfilepath":"/media/ap/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv","type":"video","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[],"code":"// Created by Eugenio Parodi - Pier/2015\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// Basic Crt Emulation 1.0\n\n\nconst float PI = 3.1415926535897932384626433832795;\n\n#define HORIZONTAL_RESOLUTION 200.0\n#define VERTICAL_RESOLUTION 120.0\n\nvec2 crt(vec2 coord, float bend)\n{\n\t// put in symmetrical coords\n\tcoord = (coord - 0.5) * 2.0;\n\n\tcoord *= 1.1;\t\n\n\t// deform coords\n\tcoord.x *= 1.0 + pow((abs(coord.y) / bend), 2.0);\n\tcoord.y *= 1.0 + pow((abs(coord.x) / bend), 2.0);\n\n\t// transform back to 0.0 - 1.0 space\n\tcoord  = (coord / 2.0) + 0.5;\n\n\treturn coord;\n}\n\n/* \n\tgetCrtCoord \n\t\tin: screenPos (0.0  ->  1.0)\n\t\t    size = pixel size\n\t\tout: vec3 : x = crt x position\n\t\t          : y = crt y position\n\t\t          : z = radius of the affected area\n */\nvec3 getCrtCoord(vec2 screenPos, float size, float bend){\n    float xd = screenPos.x - 0.5;\n    float yd = screenPos.y - 0.5;\n    \n    float x = screenPos.x + xd * pow(abs(yd),bend);\n    float y = screenPos.y + yd * pow(abs(xd),bend);\n    \n    return vec3(x,y,size);\n}\n\nvec3 getColorText(vec2 pos){\n    float vPos = floor(VERTICAL_RESOLUTION    * pos.y);\n    float hPos = floor(HORIZONTAL_RESOLUTION * pos.x);\n    \n    float x = hPos / HORIZONTAL_RESOLUTION;\n    float y = vPos / VERTICAL_RESOLUTION;\n    \n    if (x<0.0 || x>1.0 ||y<0.0||y>1.0)\n        return vec3(0,0,0);\n    else\n        return texture(iChannel0,vec2(x,y),-16.0).xyz;\n}\n\nvec3 getLinearColorText(vec2 pos){\n    float vPos = floor(VERTICAL_RESOLUTION    * pos.y);\n    float hPos = floor(HORIZONTAL_RESOLUTION * pos.x);\n    float hFra = fract(HORIZONTAL_RESOLUTION * pos.x);\n    \n    \n    float xa = (hPos-1.0) / HORIZONTAL_RESOLUTION;\n    float xb =  hPos      / HORIZONTAL_RESOLUTION;\n    float y = vPos / VERTICAL_RESOLUTION;\n    \n    if (xa<0.0||xa>1.0||xb<0.0||xb>1.0||y<0.0||y>1.0)\n        return vec3(0,0,0);\n    else{\n        vec3 ca = texture(iChannel0,vec2(xa,y),-16.0).xyz;\n        vec3 cb = texture(iChannel0,vec2(xb,y),-16.0).xyz;\n        return mix(ca,cb,hFra);\n    }\n}\n\n#define BLUR_W  3\n#define BLUR_H  3\n\nvec3 blur(vec2 pos,vec2 size){\n    float g[9];\n    g[0]=0.077847; g[1]=0.123317; g[2]=0.077847;\n\tg[3]=0.123317; g[4]=0.195346; g[5]=0.123317;\n\tg[6]=0.077847; g[7]=0.123317; g[8]=0.077847;\n    \n    vec3 ret = vec3(0,0,0);\n    \n    for (int x=0;x<BLUR_W;x++){\n        for (int y=0;y<BLUR_H;y++){\n            ret += g[x+y*BLUR_W] * getColorText(pos+vec2(x-BLUR_W/2,y-BLUR_H/2)*size);\n        }\n    }\n\treturn ret;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{     \n    vec3 coord = getCrtCoord((fragCoord.xy / iResolution.xy),1.5/length(iResolution.xy),2.5);\n    \n    vec3 color  = getColorText(coord.xy);\n    vec3 lcolor = getLinearColorText(coord.xy);\n    vec3 bcolor = blur(coord.xy,vec2(1.0/HORIZONTAL_RESOLUTION,1.0/VERTICAL_RESOLUTION));\n    \n    /* Cromatic Distortion */\n    vec2 rdist   = vec2(10.0 * sin(iTime),0)*coord.z;\n    vec2 gdist   = vec2(0,10.0 * sin(iTime))*coord.z;\n    vec2 bdist   = vec2(-10.0 * sin(iTime),0)*coord.z;\n    vec3 dcolor = vec3(0,0,0);\n    dcolor.x    = getColorText(coord.xy + rdist).x;\n    dcolor.y    = getColorText(coord.xy + gdist).y;\n    dcolor.z    = getColorText(coord.xy + bdist).z;\n    \n    float luminance  = (0.2126*lcolor.x + 0.7152*lcolor.y + 0.0722*lcolor.z);    \n        \n    /* Basic Shadowmask */\n    float mx = mod(floor(fragCoord.x + fragCoord.y/2.0),3.0);\n    \n    vec3 shadowMask = vec3(1.0,1.0,1.0);\n    \n#if 1\n    /* CMY */\n    if (mx == 0.0) shadowMask = vec3(1.0,1.0,luminance);\n    if (mx == 1.0) shadowMask = vec3(luminance,1.0,1.0);\n    if (mx == 2.0) shadowMask = vec3(1.0,luminance,1.0);\n# else\n    /* RGB */\n    if (mx == 0.0) shadowMask = vec3(1.0,luminance,luminance);\n    if (mx == 1.0) shadowMask = vec3(luminance,1.0,luminance);\n    if (mx == 2.0) shadowMask = vec3(luminance,luminance,1.0);\n#endif\n    \n    /* ScanLine */\n    /* \n\t\tI'm using Cos to generate the scanline\n\t\tconsidering the pixel height I'm trying to \n\t\tcalculate the area below the sin function.\n\t\tIntegral ( Cos(x) + 1 dx ) = Sin(x) + x + C\n\t*/\n    \n    float sa = PI + 2.0*PI*( (coord.y-0.0) * VERTICAL_RESOLUTION );\n    float sb = PI + 2.0*PI*( (coord.y+coord.z*2.0) * VERTICAL_RESOLUTION );\n    float sinFunc = 0.5 * (\n        (sin(sb) + sb ) -\n        (sin(sa) + sa ) ) / (sb - sa);\n    float minScanline = pow(sinFunc,luminance);\n    float maxScanline = pow(sinFunc,0.1);\n    float scanline = pow(sinFunc,mix(10.0,0.001,luminance));\n    /* Tests */\n    //fragColor = vec4(/* shadowMask * */ scanline * color,1.0);\n    //fragColor = vec4(luminance,luminance,luminance,1.0);\n    //fragColor = vec4(scanline,scanline,scanline,1.0);\n    //fragColor = vec4(shadowMask * scanline,1.0);\n    //fragColor = vec4(shadowMask * scanline * color,1.0);\n    //fragColor = vec4(bcolor,1.0);\n    // fragColor = vec4(shadowMask * scanline * color + pow(bcolor,vec3(4,4,4)) ,1.0);\n    fragColor = vec4(shadowMask * scanline * dcolor + pow(bcolor,vec3(4,4,4)) ,1.0);\n}","name":"","description":"","type":"image"}]}