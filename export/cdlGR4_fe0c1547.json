{"ver":"0.1","info":{"id":"cdlGR4","date":"1665754335","viewed":114,"name":"Caustics Disco Ball Geometric","username":"LoganOracio","description":"Some Disco balls caustics","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["caustics"],"hasliked":0,"parentid":"stKfWt","parentname":"Caustics Disco Balls"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// LIGHT\n#define exposition 1.0\n\n// SCENE\n#define nombre_de_boule 2\n#define separation_boule 0.08\n#define boule_speed_diff 0.2\n#define vit_rot 0.15\n\n// CAUSTICS\n#define size 0.15\n#define feather 0.06\n#define chromatic_aberation .0028\n#define deformation 0.65\n#define random_rotation 0.2\n\n// NOISE\n#define noise_scale 4.0\n#define noise_strength 0.5\n#define noise_sharpness 2.0\n#define noise_shape_intensity 0.03\n#define noise_shape_scale 9.0\n\nconst float pi = 3.1415926535897932384626433832;\nmat2 rotate(float a) {\n\tfloat s = sin(a);\n\tfloat c = cos(a);\n\treturn mat2(c, -s, s, c);\n}\nuvec4 murmurHash42(uvec2 src) {\n    const uint M = 0x5bd1e995u;\n    uvec4 h = uvec4(1190494759u, 2147483647u, 3559788179u, 179424673u);\n    src *= M; src ^= src>>24u; src *= M;\n    h *= M; h ^= src.x; h *= M; h ^= src.y;\n    h ^= h>>13u; h *= M; h ^= h>>15u;\n    return h;\n}\nvec4 hash42(vec2 src) {\n    uvec4 h = murmurHash42(floatBitsToUint(src));\n    return uintBitsToFloat(h & 0x007fffffu | 0x3f800000u) - 1.0;\n}\n#define MOD3 vec3(.1031,.11369,.13787)\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * MOD3);\n    p3 += dot(p3, p3.yxz+19.19);\n    return -1.0 + 2.0 * fract(vec3((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y, (p3.y+p3.z)*p3.x));\n}\nfloat noise(vec3 p)\n{\n    vec3 pi = floor(p);\n    vec3 pf = p - pi;\n    \n    vec3 w = pf * pf * (3.0 - 2.0 * pf);\n    \n    return \tmix(\n        \t\tmix(\n                \tmix(dot(pf - vec3(0, 0, 0), hash33(pi + vec3(0, 0, 0))), \n                        dot(pf - vec3(1, 0, 0), hash33(pi + vec3(1, 0, 0))),\n                       \tw.x),\n                \tmix(dot(pf - vec3(0, 0, 1), hash33(pi + vec3(0, 0, 1))), \n                        dot(pf - vec3(1, 0, 1), hash33(pi + vec3(1, 0, 1))),\n                       \tw.x),\n                \tw.z),\n        \t\tmix(\n                    mix(dot(pf - vec3(0, 1, 0), hash33(pi + vec3(0, 1, 0))), \n                        dot(pf - vec3(1, 1, 0), hash33(pi + vec3(1, 1, 0))),\n                       \tw.x),\n                   \tmix(dot(pf - vec3(0, 1, 1), hash33(pi + vec3(0, 1, 1))), \n                        dot(pf - vec3(1, 1, 1), hash33(pi + vec3(1, 1, 1))),\n                       \tw.x),\n                \tw.z),\n    \t\t\tw.y);\n}\nfloat smax(float a, float b, float k)\n{\n    return log(exp(k*a)+exp(k*b))/k;\n}\nfloat stereo(vec2 uv, vec2 position, float speedoffset, float spread)\n{\n    uv *= 0.3;\n    uv += position;\n    uv *= rotate(iTime*vit_rot*speedoffset);\n    \n    uv = normalize(uv)/(spread*length(uv)+0.08);\n    \n    vec4 rand = hash42(floor(uv*8.0));\n    vec2 offset = vec2(rand.x*cos(mix(-3.1415,3.1415,rand.y)),rand.x*sin(mix(-3.1415,3.1415,rand.y)));\n    \n    vec2 temp = mod(uv*8.0,1.0)+offset*0.2;\n    \n    temp -= .5;\n    temp *= rotate((rand.a-.5)*random_rotation);\n    temp.x *= deformation;\n    \n    float len = smax(abs(temp.x),abs(temp.y),20.0)+noise(vec3(temp*noise_shape_scale,rand.z*-1000.0))*noise_shape_intensity;\n    temp = mod(uv*4.0,1.0);\n    return (pow(1.0+noise(vec3(temp*noise_scale,rand.z*1000.0)),noise_sharpness)*noise_strength)*mix(0.0,mix(0.8,1.0,rand.z)*smoothstep(size+feather,size-feather,len),clamp(10.0*(1.0-max(abs(temp.x-.5),abs(temp.y-.5))*2.0),0.0,1.0));\n}\n\nvec3 layer(vec2 uv, vec2 position, float speedoffset)\n{\n    return vec3(stereo(uv,position,speedoffset,1.0-chromatic_aberation),stereo(uv,position,speedoffset,1.0),stereo(uv,position,speedoffset,1.0+chromatic_aberation));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy-.5;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    vec3 color = vec3(0.0);\n    \n    for(int i = 0; i < nombre_de_boule; i++)\n    {\n        color += layer(uv,vec2(mix(-separation_boule,separation_boule,float(i)/float(nombre_de_boule-1)),-0.3),1.0+boule_speed_diff*float(i));\n    }\n    \n    fragColor = vec4(log(color+1.0)*exposition,1.0);\n}","name":"Image","description":"","type":"image"}]}