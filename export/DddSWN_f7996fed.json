{"ver":"0.1","info":{"id":"DddSWN","date":"1679843051","viewed":101,"name":"Weekly Shader 3 : Pixsort Noise","username":"LoganOracio","description":"Some Verticaly Pixel Sorted Noise\nNothing too fancy","likes":3,"published":1,"flags":32,"usePreview":0,"tags":["noise"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nfloat luminance(vec3 color) {\n  return dot(color, vec3(0.299, 0.587, 0.114));\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 ir = 1.0/iResolution.xy;\n\n    vec3 pix = vec3(0.0);\n    float l = 0.0;\n    for(int i = 0; i < int(iResolution.y-fragCoord.y); i++)\n    {\n        vec3 n = texture(iChannel0,uv.xy+vec2(0.0,float(i))*ir).xyz;\n        float ln = luminance(n);\n        if(ln>l)\n        {\n            pix = n; l = ln;\n        }\n    }\n\n    fragColor = vec4(pix,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"uint murmurHash12(uvec2 src) {\n    const uint M = 0x5bd1e995u;\n    uint h = 1190494759u;\n    src *= M; src ^= src>>24u; src *= M;\n    h *= M; h ^= src.x; h *= M; h ^= src.y;\n    h ^= h>>13u; h *= M; h ^= h>>15u;\n    return h;\n}\nfloat hash12(vec2 src) {\n    uint h = murmurHash12(floatBitsToUint(src));\n    return uintBitsToFloat(h & 0x007fffffu | 0x3f800000u) - 1.0;\n}\n\nfloat lerp(float x, float y, float v)\n{\n    if(v<=0.0) return x;\n    else if(v>=1.0) return y;\n    else\n    { \n        return (y - x) * (((v * 6.0 - 15.0) * v + 10.0) * v * v * v) + x;\n    }\n}\nvec2 random_gradient(vec2 uv)\n{\n    float angle = hash12(uv)*2.0*3.14159265358979;\n    return vec2(cos(angle),sin(angle));\n}\nfloat dot_gradient(vec2 i, vec2 uv)\n{\n    vec2 d = uv - i;\n    vec2 grad = random_gradient(vec2(i.x,i.y));\n    return d.x*grad.x + d.y*grad.y;\n}\nfloat pnoise(vec2 uv)\n{\n    vec2 fr = fract(uv);\n    vec2 fl = floor(uv);\n    \n    float n0 = dot_gradient(fl,uv);\n    float n1 = dot_gradient(fl+vec2(1.0,0.0),uv);\n    float o0 = lerp(n0,n1,uv.x-fl.x);\n    \n    n0 = dot_gradient(fl+vec2(0.0,1.0),uv);\n    n1 = dot_gradient(fl+vec2(1.0,1.0),uv);\n    float o1 = lerp(n0,n1,uv.x-fl.x);\n    \n    return lerp(o0,o1,uv.y-fl.y);\n}\nfloat cloud(vec2 uv, float lsep, float ssep, float asep, int oct, float anim)\n{\n    float sum = 0.0;\n    for(int i = 0; i < oct; i++)\n    {\n        float fi = float(i+1);\n        float fip = fi*1.57079632679;\n        sum += pnoise(pow(fi,asep)*anim*vec2(cos(fip),sin(fip))+uv*pow(fi,ssep))/pow(fi,lsep);\n    }\n    return sum;\n}\nvec3 cloud3(vec2 uv, float lsep, float ssep, float asep, int oct, float anim)\n{\n    return vec3(cloud(uv+479.156,lsep,ssep,asep,oct,anim),cloud(uv,lsep,ssep,asep,oct,anim),cloud(uv-732.156,lsep,ssep,asep,oct,anim));\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    \n    fragColor = vec4(cloud3(uv*2.0,2.0,2.0,2.0,7,iTime*0.2)*0.5+0.5,1.0);\n}","name":"Buffer A","description":"","type":"buffer"}]}