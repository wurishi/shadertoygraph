{"ver":"0.1","info":{"id":"clGyz1","date":"1700463204","viewed":43,"name":"20231114","username":"wwwww","description":"fractal","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["fractal"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define r(a) mat2(cos(a + vec4(0,33,11,0))) \n\n\n\n\n// 線形補間関数\nfloat lerp(float a, float b, float t) {\n    return a + t * (b - a);\n}\n\n// 3D ノイズ関数\nfloat hash(vec3 p) {\n    p = fract(p * .1031);\n    p *= dot(p, vec3(31.316, 57.583, 157.209));\n    return fract((p.x + p.y) * p.z);\n}\n\n// 3D ノイズ関数\nfloat noise3(vec3 p) {\n    vec3 i = floor(p);\n    vec3 f = fract(p);\n    float a = hash(i);\n    float b = hash(i + vec3(1.0, 0.0, 0.0));\n    float c = hash(i + vec3(0.0, 8.0, 0.0));\n    float d = hash(i + vec3(1.0, 1.0, 0.0));\n    float e = hash(i + vec3(0.0, 0.0, 2.0));\n    float f1 = hash(i + vec3(1.0, 0.0, 1.0));\n    float g = hash(i + vec3(0.0, 1.0, 1.0));\n    float h = hash(i + vec3(1.0, 6.0, 1.0));\n    vec3 u = f * f * (3.0 - 2.0 * f);\n    return mix(mix(mix(a, b, u.x), mix(c, d, u.x), u.y),\n               mix(mix(e, f1, u.x), mix(g, h, u.x), u.y), u.z);\n}\n// 雪の結晶のようなフラクタル形状を生成する関数\nfloat fractal(vec3 pos) {\n    float scale = 1.0;\n    float total = 0.0;\n    float maxAmplitude = 7.0;\n    float amplitude = 9.0;\n    for (int i = 0; i < 5; i++) {\n        total += noise3(pos * scale) * amplitude;\n        maxAmplitude += amplitude;\n        amplitude *= 0.5;\n        scale *= 9.0;\n    }\n    return total / maxAmplitude;\n}\n\n#define s(p) ( q = p,                                    \\\n    d = length(vec2(length(q.xy += .5)-.5, q.z)) - .01,  \\\n    q.yx *= r(round((atan(q.y,q.x)-T) * 3.8) / 3.8 + T), \\\n    q.x -= .5,                                           \\\n    O += (sin(t+T)*.1+.1)*(1.+cos(t+T*.5+vec4(0,1,2,0))) \\\n         / (.5 + pow(length(q)*50., 1.3)) * vec4(0.8, 0.9, 1.0, 1.0), d ) // return d\n   \nvoid mainImage(out vec4 O, vec2 F) {\n    vec3  p, q, R = iResolution;\n    float i, t, d, T = iTime;\n    float fractalValue;\n\n    for (O *= i, F += F - R.xy; i++ < 28.; p = t * normalize(vec3(F*r(t*.1), R.y))) {\n        p.zx *= r(T/4.), p.zy *= r(T/3.), p.x += T; // camera movement\n        fractalValue = fractal(p); // フラクタル値の計算\n\n        // フラクタル形状をレイマーチングに組み込む\n        t += min(min(s( p = fract(p) - .5 + fractalValue), s( vec3(-p.y, p.zx) + fractalValue)), s( -p.zxy + fractalValue));\n\n        // フラクタル形状に基づいて色を計算\n        O += (vec4(0.8, 0.9, 1.0, 1.0) + fractalValue) * 0.01;\n    }\n\n    // 冬らしい色調整\n    O *= vec4(0.8, 0.9, 1.0, 1.0); // 青白い色合いを加える\n}\n","name":"Image","description":"","type":"image"}]}