{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[{"channel":0,"type":"buffer","id":"4sXGR8","filepath":"/media/previz/buffer02.png","sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}},{"channel":1,"type":"buffer","id":"XsXGR8","filepath":"/media/previz/buffer01.png","sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"code":"\nvec3 rotate(vec3 p, vec3 axis, float angle) {\n    return mix(dot(p, axis) * axis, p, cos(angle)) + sin(angle) * cross(axis, p);\n}\n\nfloat getSpheresSDFUnique(vec3 p) {\n    vec3 voxelPos = worldToVoxel(p.xyzz).xyz;\n    ivec3 basePos = ivec3(floor(voxelPos));\n    \n    vec4 distances = vec4(FLOAT_INF);\n    uvec4 indices = uvec4(uint(-1));\n\n    float shapeD = 9999.0;\n    for(int z = -1; z <= 1; z++) {     \n        for(int y = -1; y <= 1; y++) {   \n            for(int x = -1; x <= 1; x++) {\n                ivec3 sampleCoord = basePos + ivec3(x, y, z);\n\n                uvec4 fetchedClosest = fetchClosest3D(vec3(sampleCoord), iChannel1);\n                for (int j = 0; j < 2; j++) {\n                    uint index = fetchedClosest[j];\n                    if(index == uint(-1)) { continue; }\n                    if (index == uint(-1) || any(equal(indices, uvec4(index)))) {\n                        continue;\n                    } \n\n                    vec4 e = texelFetch(iChannel0, ivec2(index, 0), 0);\n                    float dist = length(e.xyz - p) - e.w;\n\n                    if (dist < distances[0]) {\n                        distances = vec4(dist, distances.xyz);\n                        indices = uvec4(index, indices.xyz);\n                    } else if (dist < distances[1]) {\n                        distances = vec4(distances.x, dist, distances.yz); \n                        indices = uvec4(indices.x, index, indices.yz);\n                    } else if (dist < distances[2]) {\n                        distances = vec4(distances.xy, dist, distances.z); \n                    } else if (dist < distances[3]) {\n                        distances = vec4(distances.xyz, dist);             \n                    }\n              }\n            }\n        }\n    }\n\n    for(int i = 0; i < 4; i++) {\n    shapeD = smin(distances[i], shapeD, 0.05 - smoothstep(0.0, 1.0, sin((iTime + 1.0) * 0.5)) * 0.009);\n    }\n\n    return shapeD;\n}\n\n\nfloat getSpheresSDF(vec3 p) {\n    vec3 voxelPos = worldToVoxel(p.xyzz).xyz;\n    ivec3 basePos = ivec3(floor(voxelPos));\n\n    float shapeD = 9999.0;\n    for(int z = -1; z <= 1; z++) {     \n        for(int y = -1; y <= 1; y++) {   \n            for(int x = -1; x <= 1; x++) {\n                ivec3 sampleCoord = basePos + ivec3(x, y, z);\n\n                uvec4 fetchedClosest = fetchClosest3D(vec3(sampleCoord), iChannel1);\n                for (int j = 0; j < 2; j++) {\n                    uint sphereIdx = fetchedClosest[j];\n                    if(sphereIdx == uint(-1)) { continue; }\n\n                    vec4 e = texelFetch(iChannel0, ivec2(sphereIdx, 0), 0);\n                    e.w += pow(1.0 - e.w, 8.0) * 0.005;\n                    float nd = length(e.xyz - p) - e.w;\n                    shapeD = smin(nd, shapeD, 0.0125 - smoothstep(0.0, 1.0, sin((iTime + 1.0) * 0.5)) * 0.009);\n              }\n            }\n        }\n    }\n\n\n\n    return shapeD;\n}\n\n\nfloat raymarchMap(vec3 ro, vec3 rd, bool groundTruth) {\n    float t = 0.0;\n    for(int i = 0; i < 32; i++) {\n        vec3 p = ro + rd * t;\n        \n        float shapeD = !groundTruth ? 1e4 : scene(p) + 0.015;\n        \n        if(!groundTruth) {\n            shapeD = min(getSpheresSDF(p), shapeD);\n        }\n        \n        if(shapeD < 0.005) \n            return t;\n        \n        t += shapeD;\n        \n        if(t > 6.0) \n            break;  \n    }\n    return t;\n}\n\nvec3 getNormal(vec3 p) {\n\tfloat d = scene(p);\n    vec2 e = vec2(.01, 0);\n    \n    vec3 n = d - vec3(\n        scene(p-e.xyy),\n        scene(p-e.yxy),\n        scene(p-e.yyx));\n    \n    return normalize(n);\n}\n\nvec3 getSpheresNormal(vec3 p) {\n\tfloat d = getSpheresSDF(p);\n    vec2 e = vec2(.01, 0);\n    \n    vec3 n = d - vec3(\n        getSpheresSDF(p-e.xyy),\n        getSpheresSDF(p-e.yxy),\n        getSpheresSDF(p-e.yyx));\n    \n    return normalize(n);\n}\n\nvec3 shade( in vec3 p, in vec3 n, in vec3 ro, in vec3 rd, vec3 lp) {\t\t\n\tfloat latt = pow(length(lp - p) * 2.0, 2.5) * 2.25;\n    vec3 ld = normalize(vec3(2.0));\n\tvec3 diff = vec3(0.2,.5,1.) * (max(dot(n, ld),0.) ) ;\n    vec3 col =  diff * 0.5;\n\tfloat trans =  pow( clamp( dot(-rd, -ld+n), 0., 1.), 1.) + 1.0;\n\tcol += vec3(1.0,.2,.35) * (trans / latt );\n    col += vec3(specular(p, rd, n, lp)) * 0.1;\n    col += smoothstep(1., 0.6, dot(-rd, n)) * 0.1;\n\n\treturn col;\n}\n\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy * 2.0 - 1.0;\n\n\n    vec2 center   = vec2(0.5, 0.0);\n    vec2 uvLeft   = uv + center;\n    vec2 uvRight  = uv - center;\n\n    float aspect = iResolution.x / iResolution.y;\n    uvLeft.x  *= aspect;\n    uvRight.x *= aspect;\n\n    bool isLeftSide = (fragCoord.x < 0.5 * iResolution.x);\n\n    bool groundTruth = isLeftSide;\n\n    vec2 uvCam = isLeftSide ? uvLeft : uvRight;\n    vec2 mouse = (iMouse.xy - 0.5 * iResolution.xy) / iResolution.y;\n\n    vec3 rd = normalize(vec3(uvCam, -1.5));\n    vec3 ro = vec3(0.0, 0.0, 2.0);\n\n    float yrot = 0.0;\n    float zrot =  sin(iTime * 2.0) * 0.25;\n    if (iMouse.z > 0.0) {\n        yrot += -4.0 * mouse.y;\n        zrot = 4.0 * mouse.x;\n    }\n    rd = rotate(rd, vec3(1, 0, 0), yrot);\n    ro = rotate(ro, vec3(1, 0, 0), yrot);\n    rd = rotate(rd, vec3(0, 1, 0), zrot);\n    ro = rotate(ro, vec3(0, 1, 0), zrot);\n    \n\n    float t = raymarchMap(ro, rd, groundTruth);\n\n    if(t > 6.0) {\n        fragColor = vec4(0.5, 0.5, 1.0, 1.0) * pow(length(uvCam), 0.33) * 0.5 * (hash(uvCam) * 0.1 + 0.9);\n        return;\n    }\n\n    vec3 p   = ro + rd * t;    \n    //vec3 nor =  isLeftSide ? getNormal(p) : getSpheresNormal(p);  \n    vec3 nor =   getNormal(p);\n    vec3 lp =  vec3(0.0, 0.095, 0.125);\n\n    vec3 col = shade(p, nor, vec3(0.0), normalize(vec3(-1.5, uvCam)), lp);\n    \n    float rim = pow(clamp(1.0 - dot(nor, -rd), 0.0, 1.0), 3.0);\n    col += vec3(0.5, 0.7, 1.0)*rim*0.25;\n\n    fragColor = vec4(col, 1.0);\n}\n","name":"Image","description":"","type":"image"},{"outputs":[{"channel":0,"id":"4dXGR8"}],"inputs":[{"channel":0,"type":"buffer","id":"4dXGR8","filepath":"/media/previz/buffer00.png","sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}},{"channel":1,"type":"buffer","id":"XsXGR8","filepath":"/media/previz/buffer01.png","sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"code":"float getAvailableSpaceSDF(vec3 p, int currentIndex) {\n    float shapeSDF = scene(p);\n    \n    uvec4 fetchedClosest = fetchClosest3D(worldToVoxel(p.xyzz).xyz, iChannel1);\n\n    for(int i = 0; i < 4; i++) {\n        uint sphereIdx = fetchedClosest[i];\n        if(sphereIdx == uint(-1)) { continue; }\n        vec4 circle = texelFetch(iChannel0, ivec2(sphereIdx, 0), 0);\n        if(circle.w <= 0.0) continue;\n\n        float currentCircleSDF = length(p - circle.xyz) - circle.w * 1.0;\n        shapeSDF = max(-currentCircleSDF, shapeSDF);\n    }\n    \n    \n    for(int i = 0; i < (currentIndex % 4); i++) {\n        vec4 circle = texelFetch(iChannel0, ivec2(i, 0), 0);\n        if(circle.w <= 0.0) continue;\n        \n        float currentCircleSDF = length(p - circle.xyz) - circle.w * 1.0;\n        \n        shapeSDF = max(-currentCircleSDF, shapeSDF);\n    }\n    \n    return shapeSDF;\n}\n\nvec4 gtSDG(vec3 pos) {\n    float eps = 0.02;\n    vec3 n;\n    float d = scene(pos);\n    n.x = scene(vec3(pos.x + eps, pos.y, pos.z)) - d;\n    n.y = scene(vec3(pos.x, pos.y + eps, pos.z)) - d;\n    n.z = scene(vec3(pos.x, pos.y, pos.z + eps)) - d;\n\n    return vec4(n, d);\n}\n\nvec3 availableSpaceSDG(vec3 pos, int currentIndex) {\n    float eps = 0.02;\n    vec3 n;\n    float d = getAvailableSpaceSDF(pos, currentIndex);\n    n.x = getAvailableSpaceSDF(vec3(pos.x + eps, pos.y, pos.z), currentIndex) - d;\n    n.y = getAvailableSpaceSDF(vec3(pos.x, pos.y + eps, pos.z), currentIndex) - d;\n    n.z = getAvailableSpaceSDF(vec3(pos.x, pos.y, pos.z + eps), currentIndex) - d;\n\n    return n;\n}\n\nvec3 snapToMedialAxis(vec3 candidate, int currentIndex) {\n    vec3 pos = candidate;\n    float s = 0.1;   \n    float alpha = 0.1;  \n    float beta = 0.5;    \n\n    for(int iter = 0; iter < 32; iter++) {\n        vec3 g = gtSDG(pos).xyz; //availableSpaceSDG(pos, currentIndex).xyz;\n        float mg = length(g);        \n        if(mg < 1e-4) break; \n        \n        vec3 dir = g / mg;\n        \n        float currentSDF = getAvailableSpaceSDF(pos, currentIndex);        \n        float stepSize = s;\n        bool stepAccepted = false;\n\n        while(stepSize > 1e-4) {\n            vec3 newPos = pos - stepSize * dir;            \n            float newSDF = getAvailableSpaceSDF(newPos, currentIndex);\n            \n            if(newSDF <= currentSDF - alpha * stepSize * mg) {\n                pos = newPos;\n                stepAccepted = true;\n                break;\n            }\n            \n            stepSize *= beta;\n        }\n        \n        if(!stepAccepted) {\n            break;\n        }\n        \n        s = stepSize;\n    }\n    \n    return pos;\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord.xy / iResolution.xy) * 2.0 - 1.0;\n    \n    if(fragCoord.y > 0.5) {\n        fragColor = vec4(0.0);\n        return;\n    }\n    \n    \n    int circleIndex = int(fragCoord.x);\n    \n    if(circleIndex >= N_SPHERES) {\n        fragColor = vec4(0.0);\n        return;\n    }\n    \n    vec4 oldData = texelFetch(iChannel0, ivec2(circleIndex, 0), 0);\n    vec3 center = oldData.xyz;\n    float radius = oldData.w;\n    \n    if(circleIndex > iFrame) {\n        fragColor = oldData;\n        return;\n    }\n    \n    srand(ivec2(fragCoord), iFrame);\n    if(circleIndex == iFrame && iFrame < N_SPHERES) {\n        float bestScore = -1.0;\n        vec3 bestPos = randomOnSphere() * frand();\n        \n        for(int c = 0; c < 16; c++) {\n            vec3 candidate;\n            float spaceSDF = 0.0;\n            \n            candidate = bestPos + randomOnSphere() * frand() * frand() * mix(0.05, 1.0, float(c) / 7.0);\n            spaceSDF = getAvailableSpaceSDF(candidate, circleIndex);\n\n            if(spaceSDF > 0.1) {\n                vec3 g = availableSpaceSDG(candidate, circleIndex);\n                candidate -= g * spaceSDF * 1.001;\n            }\n                        \n            float score = -spaceSDF;\n            \n            vec3 snapped = snapToMedialAxis(candidate, circleIndex);\n            float snappedSpaceSDF = getAvailableSpaceSDF(snapped, circleIndex);\n            float snappedScore = -snappedSpaceSDF;\n            \n            if(snappedSpaceSDF < 0.0 && snappedScore > score) {\n                candidate = snapped;\n                score = snappedScore;\n            }\n            \n            \n            if(score > bestScore) {\n                bestScore = score;\n                bestPos = candidate;\n            }\n        }\n        \n        if(bestScore > MIN_RADIUS) {\n            center = bestPos;\n            radius = max(bestScore, MIN_RADIUS);\n        } else {\n            center = vec3(0.0);\n            radius = 0.0;\n        }\n    }\n    fragColor = vec4(center, radius);\n}\n","name":"Buffer A","description":"","type":"buffer"},{"outputs":[{"channel":0,"id":"XsXGR8"}],"inputs":[{"channel":0,"type":"buffer","id":"4sXGR8","filepath":"/media/previz/buffer02.png","sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}},{"channel":1,"type":"buffer","id":"XsXGR8","filepath":"/media/previz/buffer01.png","sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"code":"\nvoid fetchAndSortClosest3D(\n    inout vec4 distances, \n    inout uvec4 indices,\n    in vec3 samplePoint,\n    in vec3 voxelCenter\n) {\n    uvec4 ids = fetchClosest3D(samplePoint, iChannel1);\n    \n    for (int i = 0; i < 4; i++) {\n        sortClosest(distances, indices, ids[i], voxelCenter, iChannel0);\n    }\n}\n\n\nfloat randomFloat(inout uint state) {\n    state ^= state >> 16;\n    state *= 0x7feb352dU;\n    state ^= state >> 15;\n    state *= 0x846ca68bU;\n    state ^= state >> 16;\n    return float(state) / 4294967296.0;\n}\n\nvec3 randomDir3D(inout uint state) {\n    float z  = randomFloat(state) * 2.0 - 1.0;  // range [-1,1]\n    float az = randomFloat(state) * PI2;\n    float r  = sqrt(1.0 - z * z);\n    float x  = r * cos(az);\n    float y  = r * sin(az);\n    return vec3(x, y, z);\n}\n\nuint rngSeed = 314159265u;\nuint xorshift(in uint value) {\n    value ^= value << 13;\n    value ^= value >> 17;\n    value ^= value << 5;\n    return value;\n}\nuint nextUint() {\n    rngSeed = xorshift(rngSeed);\n    return rngSeed;\n}\nfloat nextFloat() {\n    return float(nextUint()) / float(uint(-1));\n}\n\nuint murmur3( in uint u )\n{\n  u ^= ( u >> 16 ); u *= 0x85EBCA6Bu;\n  u ^= ( u >> 13 ); u *= 0xC2B2AE35u;\n  u ^= ( u >> 16 );\n\n  return u;\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    ivec2 fc = ivec2(fragCoord);\n    ivec2 maxSize = ivec2(slicesPerRow * iResolution3D.x);\n    if (any(greaterThanEqual(fc, maxSize))) {fragColor = vec4(0.0); return; }\n  \n    ivec3 cellCoord = from2D(fc, iResolution3D); \n    vec3 voxelCenter = vec3(cellCoord) + 0.5; \n    \n    vec4 bestDistances = vec4(FLOAT_INF);\n    uvec4 closestIndices = uvec4(uint(-1));\n    \n    if (iFrame == 0) {\n        closestIndices = uvec4(nextUint(), nextUint(), nextUint(), nextUint()) % 63u;\n    }\n    \n    uint seed = uint(iFrame) + uint(fragCoord.x) + uint(fragCoord.y);\n    float rad = 3.0;\n\n    fetchAndSortClosest3D(bestDistances, closestIndices, voxelCenter, voxelCenter);\n    fetchAndSortClosest3D(bestDistances, closestIndices, voxelCenter + randomDir3D(seed) * rad, voxelCenter);\n    fetchAndSortClosest3D(bestDistances, closestIndices, voxelCenter + randomDir3D(seed) * rad, voxelCenter);\n    fetchAndSortClosest3D(bestDistances, closestIndices, voxelCenter + randomDir3D(seed) * rad, voxelCenter);\n    fetchAndSortClosest3D(bestDistances, closestIndices, voxelCenter + randomDir3D(seed) * rad, voxelCenter);\n\n    rngSeed = murmur3(uint(fragCoord.x)) ^ murmur3(floatBitsToUint(fragCoord.y)) ^ murmur3(floatBitsToUint(iTime));\n\n    for (int i = 0; i < 16; i++) {\n        sortClosest(bestDistances, closestIndices, nextUint() % PARTICLE_COUNT, voxelCenter, iChannel0);\n    }\n    \n\n    fragColor = uintBitsToFloat(closestIndices);\n}\n","name":"Buffer B","description":"","type":"buffer"},{"outputs":[{"channel":0,"id":"4sXGR8"}],"inputs":[{"channel":0,"type":"buffer","id":"4dXGR8","filepath":"/media/previz/buffer00.png","sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    int j = int(fragCoord.x);\n    vec4 circle = texelFetch(iChannel0, ivec2(j, 0), 0);\n    float fun = smoothstep(0.0, 1.0, sin(iTime * 0.5));\n    vec3 animation = vec3(sin(iTime + float(j) * 2.0), cos(iTime + float(j) * 3.0), cos(iTime * 2.0 + float(j) * 4.0)) * 0.3 * fun * smoothstep(8.0, 12.0, iTime);\n    circle.xyz += animation;\n    circle.w *= mix(1.1, 0.4, fun);\n    fragColor = circle;\n}","name":"Buffer C","description":"","type":"buffer"},{"outputs":[],"inputs":[],"code":"#define N_SPHERES 666\n#define MIN_RADIUS 0.005\n#define PI 3.14159265359\n\nint seed = 93726;\nint randInt() { seed = seed*0x343fd + 0x269ec3; return (seed>>16)&32767; }\nfloat frand() { return float(randInt())/32767.0; }\n\nvoid srand( ivec2 p, int frame ) {\n    int n = frame;\n    n = (n<<13)^n; n = n*(n*n*15731+789221)+1376312589; \n    n += p.y;\n    n = (n<<13)^n; n = n*(n*n*15731+789221)+1376312589;\n    n += p.x;\n    n = (n<<13)^n; n = n*(n*n*15731+789221)+1376312589;\n    seed = n;\n}\n\nvec3 randomOnSphere( void ) {\n    float theta = (6.283185 / 32767.0) * float(randInt());\n    float u = (2.0 / 32767.0) * float(randInt()) - 1.0;\n    return vec3(sqrt(max(0.0, 1.0 - u * u)) * vec2(cos(theta), sin(theta)), u);\n}\n\n\nfloat hash(vec2 p) {\n return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);   \n}\n\n\nfloat smin(float a, float b, float k) \n{\n    float h = max(k - abs(a - b), 0.0) / k;\n    return min(a, b) - h*h*k*0.25;\n}\n\n\nvec3 erot(vec3 p, vec3 ax, float ro) {\n    return mix(dot(p,ax)*ax,p,cos(ro))+sin(ro)*cross(ax,p);\n}\n\n//https://www.shadertoy.com/view/3lGcWt\nfloat scene(vec3 pp) {\n    vec3 p = pp.zxy;\n    // early skip if outside\n    if (length(p) > 3.0) {\n        return length(p)-2.8;\n    }\n    //neural networks can be really compact... when they want to be\n    vec4 f0_0=sin(p.y*vec4(.00,.00,.00,.01)+p.z*vec4(1.20,-.11,-.05,-3.66)+p.x*vec4(-2.55,.14,-4.41,-.07)+vec4(-3.04,-3.15,-1.75,-4.00));\n    vec4 f0_1=sin(p.y*vec4(-.00,-.00,-2.96,-.00)+p.z*vec4(2.84,-.30,-1.07,-2.13)+p.x*vec4(.10,-.38,-.75,-.36)+vec4(-.49,3.12,1.50,3.14));\n    vec4 f0_2=sin(p.y*vec4(2.96,.00,-.00,.00)+p.z*vec4(-1.08,.00,-1.10,-.47)+p.x*vec4(-.76,.00,1.15,-.15)+vec4(-4.79,-1.57,-2.81,-3.25));\n    vec4 f0_3=sin(p.y*vec4(-.00,-.01,.00,.00)+p.z*vec4(2.89,3.26,2.06,.47)+p.x*vec4(2.78,3.55,-2.21,-3.80)+vec4(4.83,2.15,1.87,-2.77));\n    vec4 f1_0=sin(mat4(.10,3.36,-1.58,.75,.19,1.62,-.59,.23,-.26,.84,-.26,-.33,-.21,-.13,.07,-.32)*f0_0+\n        mat4(-.46,-2.33,.84,-.20,-1.29,-1.43,.93,-1.44,-.62,-.91,-.46,-1.05,-.21,1.57,1.21,.60)*f0_1+\n        mat4(-.62,-.92,-.45,-1.06,.03,.19,.10,-.54,.08,-.27,-.26,-.05,-.22,.86,-.40,-.02)*f0_2+\n        mat4(-.22,.02,.20,.08,.56,.05,-.24,.70,.46,.51,1.51,.98,-.82,-1.18,.37,-.84)*f0_3+\n        vec4(.72,.15,-1.14,2.07))/1.0+f0_0;\n    vec4 f1_1=sin(mat4(-.64,1.09,-.42,.08,.85,.28,-.17,-.14,-1.07,-.40,-.00,.02,-.44,-.54,-.36,.03)*f0_0+\n        mat4(1.26,.21,-.40,.05,-1.70,-2.36,.13,-.00,.45,.33,.33,1.92,-.74,.09,-.65,-.11)*f0_1+\n        mat4(.46,.32,.32,-1.91,-.25,-.29,.51,.31,.68,.20,-1.91,.07,.91,.19,-.16,.17)*f0_2+\n        mat4(-1.12,.16,1.30,-.02,-.59,.43,1.29,.00,.07,-.20,-.06,.01,1.29,-.03,-.25,-.05)*f0_3+\n        vec4(-.84,-.53,2.27,-1.30))/1.0+f0_1;\n    vec4 f1_2=sin(mat4(.26,.07,-.40,.47,.04,.38,.43,.50,.05,.64,.33,.13,-.20,.26,-.10,.70)*f0_0+\n        mat4(1.03,.15,.12,-.31,-.39,-.69,-1.47,-1.35,-.88,-.27,1.67,1.13,-.16,-.16,.49,-1.24)*f0_1+\n        mat4(-.88,-.30,1.66,1.14,-.58,-.57,-.15,.38,-1.43,.23,-.05,-.47,-.54,.18,.16,.43)*f0_2+\n        mat4(-.78,.92,.32,-.52,-.74,.53,.43,-.35,1.08,-.74,-.26,-1.09,.64,-.39,.15,.62)*f0_3+\n        vec4(2.06,2.87,.46,-1.97))/1.0+f0_2;\n    vec4 f1_3=sin(mat4(-.32,-1.03,.15,.20,-.19,-.88,.04,-.05,-.44,-.43,1.02,.10,-.02,.17,-.07,-.33)*f0_0+\n        mat4(.06,2.45,-.25,-.22,-.01,-.53,-.12,-.22,.28,.87,-.06,.50,.60,-2.04,-.66,.09)*f0_1+\n        mat4(.29,.85,-.06,.50,.07,-.59,-.61,-.33,-.84,-.81,-.56,.47,-.06,-.17,.42,-.32)*f0_2+\n        mat4(-.77,1.29,.42,-.11,-.69,.91,-.05,.14,-.01,-.41,-1.55,.52,1.10,-.05,-.21,.27)*f0_3+\n        vec4(1.25,2.26,3.59,1.23))/1.0+f0_3;\n    vec4 f2_0=sin(mat4(-.37,1.93,1.64,-.27,-.75,-.24,-.37,-.18,1.51,-1.23,1.02,.27,-.83,.14,.57,.20)*f1_0+\n        mat4(1.66,.53,.54,.55,.37,-3.52,1.62,1.72,-.07,-.29,.15,.23,-.21,1.43,-.13,.21)*f1_1+\n        mat4(-.02,-.52,.14,.25,-.59,1.12,-.75,-.14,-.58,-.34,-.62,.31,-.58,1.11,.92,-.04)*f1_2+\n        mat4(-.17,-1.10,.31,-.94,-.96,.35,-.06,-.12,.38,-1.48,1.04,.27,-.47,1.09,-1.76,1.23)*f1_3+\n        vec4(.78,-1.51,-1.70,-.30))/1.4+f1_0;\n    vec4 f2_1=sin(mat4(1.92,-1.36,.28,1.21,.56,.98,-.21,-.71,.89,-.41,.31,1.48,.47,.09,-.72,-.13)*f1_0+\n        mat4(-.40,-.59,.50,1.09,-.88,.45,.23,-.72,-.09,-.26,-.04,.54,.47,-.20,.02,-.45)*f1_1+\n        mat4(-.21,-.27,-.06,.52,2.09,1.19,.96,.36,-.26,.02,.38,-.69,.42,-.43,-.72,.01)*f1_2+\n        mat4(2.63,.06,-.27,1.52,.53,.47,.07,.11,-.55,-.86,.10,.00,.07,1.05,.50,-.32)*f1_3+\n        vec4(-2.37,5.12,-1.09,-2.25))/1.4+f1_1;\n    vec4 f2_2=sin(mat4(.81,-.14,1.10,.17,.12,-.24,.31,-.08,.81,-.35,-.47,.16,.18,-.27,-.46,.32)*f1_0+\n        mat4(.27,.19,-.66,.24,.74,-.93,-2.85,.28,.11,.15,.26,.86,.32,-.02,.07,.01)*f1_1+\n        mat4(.08,.15,.21,.86,.69,.03,.11,.35,.01,-.31,-.80,-1.88,-.62,.30,.73,1.16)*f1_2+\n        mat4(.76,-.16,1.54,1.22,.13,.27,1.36,.66,-.33,-.12,-.83,-.93,1.23,.06,.11,-1.64)*f1_3+\n        vec4(-2.71,-1.53,.42,-.07))/1.4+f1_2;\n    vec4 f2_3=sin(mat4(-.16,-1.51,-.23,-.90,-.11,-.62,-.74,.63,1.37,-.79,.58,-.96,-.41,-.16,.00,.56)*f1_0+\n        mat4(-.18,.35,.01,-1.15,.07,1.33,1.03,1.26,.18,.63,.29,-.81,.61,.39,-.66,.70)*f1_1+\n        mat4(.12,.60,.35,-.86,.21,-.86,.17,-.52,-.03,.47,-.53,.57,-1.34,.21,1.09,-.35)*f1_2+\n        mat4(.56,-2.60,.27,-.68,.56,-1.01,-.05,.31,-.34,.71,-.07,-.36,-.32,1.49,-1.82,1.04)*f1_3+\n        vec4(-.41,.70,-.56,-1.46))/1.4+f1_3;\n    float d = dot(f2_0,vec4(.02,-.01,-.02,-.06))+\n        dot(f2_1,vec4(-.02,-.04,-.07,-.03))+\n        dot(f2_2,vec4(-.06,-.16,.03,.02))+\n        dot(f2_3,vec4(.06,-.03,-.04,.03))+\n        0.040;\n   // limit to inside unit sphere as neural sdf is not really defined\n   return max(d,length(p)-1.) - 0.015;\n}\n\n\nfloat G1V ( float dotNV, float k ) {\n    return 1.0 / (dotNV*(1.0 - k) + k);\n}\n\nfloat GGX(vec3 N, vec3 V, vec3 L, float roughness, float F0) {\n        float alpha = roughness*roughness;\n    vec3 H = normalize (V + L);\n\n    float dotNL = clamp (dot (N, L), 0.0, 1.0);\n    float dotNV = clamp (dot (N, V), 0.0, 1.0);\n    float dotNH = clamp (dot (N, H), 0.0, 1.0);\n    float dotLH = clamp (dot (L, H), 0.0, 1.0);\n\n    float D, vis;\n    float F;\n\n    float alphaSqr = alpha*alpha;\n    float pi = 3.1415926535;\n    float denom = dotNH * dotNH *(alphaSqr - 1.0) + 1.0;\n    D = alphaSqr / (pi * denom * denom);\n\n    float dotLH5 = pow (1.0 - dotLH, 5.0);\n    F = F0 + (1.0 - F0)*(dotLH5);\n\n    float k = alpha / 0.1;\n    vis = G1V (dotNL, k) * G1V (dotNV, k);\n\n    return D * F * vis;\n}\n\nfloat specular(vec3 p, vec3 rd, vec3 n, vec3 lp) {\n    vec3 ld = normalize(lp - p);\n    float roughness = 0.375;\n    return GGX(n,-rd, ld,roughness, 0.2);\n}\n\n#define PI2      6.28318531\n#define FLOAT_INF uintBitsToFloat(0x7f800000u)\nconst ivec3 iResolution3D = ivec3(64);\n\n\nconst uint PARTICLE_COUNT = uint(N_SPHERES);\nconst int slicesPerRow = 8;\n\nvec4 worldToVoxel(vec4 raw) {\n    return (raw + 3.0) * (1.0 / 6.0) * vec4(iResolution3D.x);\n}\n\nvec4 decodeEntity3D(sampler2D sampler, uint particleIndex)  {\n    ivec2 texCoord = ivec2(particleIndex, 0);\n    vec4 raw = texelFetch(sampler, texCoord, 0);\n\n    return worldToVoxel(raw);\n}\n\nivec3 to3D(uint flatId, ivec3 volumeSize) {\n    int x = int(flatId % uint(volumeSize.x));\n    int yz = int(flatId / uint(volumeSize.x));\n    int y = yz % volumeSize.y;\n    int z = yz / volumeSize.y;\n    return ivec3(x, y, z);\n}\n\nuint to1D(ivec3 coord, ivec3 volumeSize) {\n    return uint(coord.x) \n         + uint(coord.y) * uint(volumeSize.x)\n         + uint(coord.z) * uint(volumeSize.x * volumeSize.y);\n}\n\n\nivec2 to2D(uint flatId, ivec3 volumeSize) {\n    ivec3 c3D = to3D(flatId, volumeSize);\n    int sliceIndex = c3D.z;\n    int row = sliceIndex / slicesPerRow;\n    int col = sliceIndex % slicesPerRow;\n    return ivec2(c3D.x + col * volumeSize.x, c3D.y + row * volumeSize.y);\n}\n\n\nivec3 from2D(ivec2 texCoord, ivec3 volumeSize) {\n    int col = texCoord.x / volumeSize.x;\n    int x = texCoord.x % volumeSize.x;\n    int y = texCoord.y % volumeSize.y;\n    int z = col + (texCoord.y / volumeSize.y) * slicesPerRow;\n    return ivec3(x, y, z);\n}\n\n\nuvec4 fetchClosest3D(vec3 position, sampler2D voroBuffer) {\n    ivec3 ipos = ivec3(clamp(floor(position), vec3(0.0), vec3(iResolution3D) - 1.0));\n    \n    uint flatId = to1D(ipos, iResolution3D);\n    ivec2 texCoord2D = to2D(flatId, iResolution3D);\n    \n    return floatBitsToUint(texelFetch(voroBuffer, texCoord2D, 0));\n}\n\nvoid sortClosest(\n        inout vec4 distances,\n        inout uvec4 indices, \n        uint index,\n        vec3 center,\n        sampler2D iChannel0\n        ) {\n    if (index == uint(-1) || any(equal(indices, uvec4(index)))) {\n        return;\n    } \n\n    vec4 e = decodeEntity3D(iChannel0, index);\n    float dist = length(center - e.xyz) - e.w;\n    \n    if (dist < distances[0]) {\n        distances = vec4(dist, distances.xyz);\n        indices = uvec4(index, indices.xyz);\n    } else if (dist < distances[1]) {\n        distances = vec4(distances.x, dist, distances.yz); \n        indices = uvec4(indices.x, index, indices.yz);\n    } else if (dist < distances[2]) {\n        distances = vec4(distances.xy, dist, distances.z); \n        indices = uvec4(indices.xy, index, indices.z);\n    } else if (dist < distances[3]) {\n        distances = vec4(distances.xyz, dist);             \n        indices = uvec4(indices.xyz, index);\n    }\n}\n","name":"Common","description":"","type":"common"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":true,"mFlagMusicStream":false},"info":{"id":"M3cyWH","date":"1735001606","viewed":1507,"name":"SDF Sphere Packing","username":"luckyballa","description":"Sphere Packing + 3D Voronoi Tracking \n\n2D version - https://www.shadertoy.com/view/lfKfWK","likes":64,"published":1,"flags":32,"usePreview":1,"tags":["3d","raymarching","sdf","sphere","packing","medialaxis","medial"],"hasliked":0,"parentid":"","parentname":""}}