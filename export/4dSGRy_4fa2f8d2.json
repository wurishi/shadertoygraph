{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[{"channel":0,"type":"texture","id":"4sf3Rn","filepath":"/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}},{"channel":1,"type":"texture","id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}},{"channel":2,"type":"texture","id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"code":"// Inspired by iq raymarched toys\n// Created by Ramon Viladomat\n\n#define STEP_REDUCTION 0.5\n\n#define SHIELD_DIMENSIONS vec3(0.65,1.0,0.025)\n\n#define SHIELD_IRON_RADIUS 0.2\n\n#define DRAWING_MARGIN vec2(0.1,0.2)\n\n#define ARROW2_ANGLE 0.52\n#define ARROW3_ANGLE 1.2\n\n#define SNAKE_SEGMENTS 6.0\n\n#define EPSILON 0.001\n\n////////////////////////////\n// IQ DISTANCE PRIMITIVES //\n////////////////////////////\n\nfloat sdCylinderH( vec3 p, vec2 h )\n{\n  \treturn max( length(p.xy)-h.x, abs(p.z)-h.y );\n}\n\nfloat sdSphere( vec3 p, float radius)\n{\n  \treturn length(p)-radius;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  \tvec3 d = abs(p) - b;\n  \treturn min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sdTriPrismV( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    return max(q.y-h.y,max(q.x*0.866025+p.z*0.5,-p.z)-h.x*0.5);\n}\n\n////////////////\n// MORPHOLOGY //\n////////////////\n\nvec2 mapBg( in vec3 p) \n{\n\treturn vec2(min(-p.z+0.3,min(p.y+1.0,p.x+1.0)),3.0);\n}\n\nfloat mapBasicShieldBody( in vec3 p )\n{\n\tfloat body = sdBox(p,SHIELD_DIMENSIONS);\n  \tfloat cornerClip = dot(vec3(0.707106,0.707106,0.0),p) - 1.12;\n\treturn max(body,cornerClip);\n}\n\nvec2 mapShieldBody( in vec3 p )\n{\n  \tfloat basicDist = mapBasicShieldBody( p );\n\t\n\t// scale the shape down and move it back in order to create the inner borders\n\tvec3 q = p*1.05;\n\tfloat removeDist = mapBasicShieldBody( q - vec3(0.0,0.0,0.03) ); \n\t\t\n \treturn vec2(max(-removeDist,basicDist),1.0);\n}\n\nvec2 mapShieldFrontDetails( in vec3 p )\n{\n\tp.y -= 0.33; \n\tp.z = -p.z;\n\t\n\t//mirror through the y=x axis (only works for first quadrant\n\tfloat pmin = min(p.x,p.y);\n\tvec3 q = vec3(pmin,pmin,p.z);\n\tq.x += abs(p.x - p.y);\n\t\n\tfloat dist1 = sdTriPrismV(q-vec3(0.60,0.60,0.025), vec2(0.025,0.085));\n\tfloat dist2 = sdTriPrismV(q-vec3(0.55,0.55,0.025), vec2(0.025,0.085));\n\t\n\treturn vec2(min(dist1,dist2),2.0);\n}\n\nvec2 mapShieldIron( in vec3 p )\n{\n  \tfloat sphere = sdSphere(p,SHIELD_IRON_RADIUS);\n  \tfloat clipPlane = p.z;\n  \treturn vec2(max(sphere,clipPlane),2.0);\n}\n\nvec2 map( in vec3 p )\n{\n\tvec2 res = mapBg( p );\n\t\n\t//shield deformation\n\tvec3 q = vec3(abs(p.xy),p.z);\n  \tq.z -= 0.3*abs(p.x*p.x);\n\t\n\tvec2 shieldBody = mapShieldBody( q );\n\tvec2 frontDetails = mapShieldFrontDetails( q );\n\tvec2 shieldCenter = mapShieldIron( q );\n\t\t\n\tif( shieldBody.x<res.x ) res=shieldBody;\n\tif( frontDetails.x<res.x ) res=frontDetails;\n\tif( shieldCenter.x<res.x ) res=shieldCenter;\t\n\t\n\treturn res;\n}\n\n///////////////\n// MATERIALS //\n///////////////\n\nfloat getArrowValue(in vec2 localPos, in float arrowWidth, in float arrowthres, in float slope)\n{\n\tfloat arrowValue = mix(arrowWidth,-slope * localPos.x + slope,clamp((localPos.x-arrowthres)*100.0,0.0,1.0));\n\treturn min(max(arrowValue - localPos.y,0.0)*100.0,1.0);\n}\n\nvec4 calcBodyFrontColor(in vec3 pos)\n{\n\tvec2 shieldPos = abs(pos.xy)/(SHIELD_DIMENSIONS.xy - DRAWING_MARGIN);\n\t\n\tfloat whiteFactor = 0.0;\n\t\n\twhiteFactor = max(length(shieldPos)-1.0,0.0);\n\t\n\t//DrawArrow\n\tvec2 refDirX = 0.9*vec2(cos(ARROW2_ANGLE),sin(ARROW2_ANGLE));\t\n\tvec2 refDirY = vec2(-refDirX.y,refDirX.x);\n\tvec2 remappedPos = abs(vec2(dot(shieldPos,refDirX),dot(shieldPos,refDirY)));\n\t\t\n\twhiteFactor = max(getArrowValue(shieldPos,0.03,0.88,0.5),getArrowValue(remappedPos,0.03,0.88,0.5));\n\t\n\t//SnakeArrow\n\trefDirX = 0.88*vec2(cos(ARROW3_ANGLE),sin(ARROW3_ANGLE));\t\n\trefDirY = vec2(-refDirX.y,refDirX.x);\n\tremappedPos = vec2(dot(shieldPos,refDirX),dot(shieldPos,refDirY));\n\t\n\tfloat displacementFactor = mod(floor(remappedPos.x*SNAKE_SEGMENTS),2.0);\n\tremappedPos = abs(remappedPos - displacementFactor*vec2(0.0,-0.05));\n\t\t\n\t//blade \n\tvec2 bladePos = 0.9*shieldPos.yx-vec2(0.0,0.002);\n\tfloat blade = getArrowValue(bladePos,0.055,0.88,0.45)* min(max(bladePos.y,0.0)*100.0,1.0);\n\t\n\twhiteFactor = max(whiteFactor,max(getArrowValue(remappedPos,0.03,0.88,0.5), blade));\n\t\n\t//black red bg\n\t\n    float angle = atan(pos.x,pos.y);\n    float dist = sqrt(pos.x*pos.x+pos.y*pos.y)/(0.2*pow(0.5*sin(angle*40.0) + 0.5,0.15) + 0.2);\n\tfloat degradation = clamp(pow(texture(iChannel0,pos.xy).r,2.0),0.0,1.0);\n\t\n\twhiteFactor *= 1.0 - degradation;\n\n\tvec4 redbg = mix(vec4(0.12,0.025,0.025,0.01),vec4(0.09,0.0,0.0,0.0),1.0-smoothstep(0.9,1.0,dist));\n\tvec4 shieldColor = mix(redbg * (0.8 + degradation*0.2),vec4(0.2,0.2,0.2,0.01),whiteFactor);\n\treturn mix(vec4(0.05,0.05,0.05,0.3),shieldColor,max(sign(length(pos.xy) - 0.3),0.0));\n}\n\nvec4 calcBodyRearColor(in vec3 pos)\n{\n\tfloat zdepth = (pos.z - 0.3*pos.x*pos.x);\n\tfloat segment = floor(pos.x*8.0);\n\tvec4 wood = vec4(texture(iChannel1,vec2(pos.y +(segment*0.2),pos.x)).rgb*0.5,0.0);\n\tfloat aotiles = 1.0 - pow(abs((mod(pos.x,0.125)-0.0625)/0.0625),5.0);\n\treturn mix(wood*((aotiles*0.8)+0.2),vec4(0.0,0.0,0.0,0.1),zdepth/0.025);\n}\n\nvec4 calcBodyColor( in vec3 pos, in vec3 nor)\n{\t\n\tvec4 frontColor = calcBodyFrontColor(pos); \n\tvec4 rearColor = calcBodyRearColor(pos);\n\n\tfloat faceSelector = max(dot(nor,vec3(0.0,0.0,1.0)),0.0);\n\treturn mix(frontColor,rearColor,faceSelector);\n}\n\nvec4 calcColorBg( in vec3 pos )\n{\n\tvec3 q = pos * 0.5;\n\t\n\tfloat groundwaterFactor = pow(texture(iChannel0,q.xz*0.1).r,1.5);\n\tvec4 ground = vec4(vec3(0.1),0.0) * texture(iChannel2,q.xz);\n\tground = mix(ground,vec4(0.0,0.0,0.05,0.2),groundwaterFactor*0.5);\n\t\n\tfloat smashedMat = (1.0 - pow(texture(iChannel0,q.xy).r,10.0)); \n\tvec4 wall1 = mix(vec4(0.15,0.12,0.05,0.2),vec4(0.2,0.17,0.11,0.5),smashedMat);\n\t\n\tvec4 wall2 = 0.2*texture(iChannel1,q.yz);\n\twall2.w = 0.05;\n\t\n\treturn mix(ground,mix(wall2,wall1,clamp(sign(pos.x+0.99),0.0,1.0)),clamp(sign(pos.y+0.99),0.0,1.0));\n}\n\nvec4 calcColor( in vec3 pos, in vec3 nor, float matID )\n{\n\tvec4 material = vec4(0.0);\n\n\t     if( matID<1.5 ) material = calcBodyColor(pos,nor); \n\telse if( matID<2.5 ) material = vec4(0.05,0.05,0.05,0.3);\n\telse if( matID<3.5 ) material = calcColorBg(pos);\n\t\t\n\treturn material;\n}\n\n//////////////////////\n// MAIN RAY/SHADING //\n//////////////////////\n\nvec2 intersect( in vec3 ro, in vec3 rd )\n{\n\tvec2 res = vec2( 2.0*EPSILON, -1.0);\n    float t = 0.0;\n    for( int i=0; i<150; i++ )\n    {\n\t\tif( abs(res.x)<EPSILON ) continue;\n\t\tres = map( ro+rd*t );\n        t += res.x*STEP_REDUCTION;\n    }\n    if (res.x > EPSILON) res.y = -1.0; \n\tres.x = t;\n    return res;\n}\n\nvec3 calcNormal( in vec3 pos) \n{\n    vec3 e = vec3(0.0,EPSILON,0.0);\n\tfloat d = map(pos).x;\n    return normalize(vec3( map(pos+e.yxx).x-d, map(pos+e.xyx).x-d, map(pos+e.xxy).x-d) );\t\n}\n\nfloat softShadow( in vec3 ro, in vec3 rd, float mint, float k )\n{\n    float res = 1.0;\n    float t = mint;\n    for( int i=0; i<45; i++ )\n    {\n        float h = map(ro + rd*t).x;\n        res = min( res, k*h/t );\n        t += clamp( h, 0.04, 0.1 );\n    }\n    return clamp(res,0.0,1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = -1.0 + 2.0 * fragCoord.xy / iResolution.xy;\n    p.x *= iResolution.x/iResolution.y;\n\t\n\t// Compute Camera\n\tvec2 mousePos = iMouse.xy/iResolution.xy;\n\t\n\t//move camera when clicking\n\tfloat camFactor = mix(0.5*(sin(-iTime*0.2)+1.0),mousePos.x,clamp(iMouse.z,0.0,1.0));\n\t\n\tfloat camAngle = 3.1415 -0.5*3.1415*camFactor;\n\tfloat camDist = 2.0+((1.0-mousePos.y)*2.0); \n\t\n    vec3 camPosition = camDist*normalize(vec3(sin(camAngle), 0.5, cos(camAngle)));\n    vec3 camTarget\t = vec3( 0.0, 0.0, 0.0 );\n    vec3 camFront \t = normalize( camTarget - camPosition );\n    vec3 camRight \t = normalize( cross(camFront,vec3(0.0,1.0,0.0) ) );\n    vec3 camUp \t\t = normalize( cross(camRight,camFront));\n    vec3 rayDir \t = normalize( p.x*camRight + p.y*camUp + 2.0*camFront );\n\n\t// light compute (fake fire light)\n\tvec3 lightPos1 = vec3(0.5*cos(iTime*.16)+2.0,0.5*sin(iTime)+2.5,-2.0);\n\tvec3 lightColor1 = vec3(1.0,0.7,0.3);\n\n\tvec3 ran = vec3(texture(iChannel0,lightPos1.xy).r,texture(iChannel0,lightPos1.yz).r,texture(iChannel0,lightPos1.zx));\n\tvec3 ranVariation = ran*sin(iTime);\n\tlightPos1 += 0.3*ranVariation;\n\tlightColor1.y += 0.25*((ranVariation.y)+1.0);\n\tlightColor1 *= 0.9+(0.2*ranVariation.x);\n\t\n\t// Start Ray\n    vec3 finalcolor = vec3(0.0);\n\tfloat attenuation = 1.0;\n\tfor( int reflectCount=0; reflectCount<2; reflectCount++ )\n\t{\n\t\t// Compute color for single ray\n    \tvec2 tmat = intersect(camPosition,rayDir);\n\n        if (tmat.y > -0.5)\n        {\n            // results extraction\n            vec3 position \t= camPosition + tmat.x*rayDir;\n            vec3 normal \t= normalize(calcNormal(position));\n            vec3 reflDir \t= reflect(rayDir,normal);\n\n            // lights and materials \n            vec4 materialColor \t= calcColor( position, normal, tmat.y );\n\n            float ambient  \t\t= 0.7 + 0.3*normal.y;\n            vec3 ambientColor \t= ambient*materialColor.rgb;\n\n            //light 1\n            vec3 lightDir1 \t= normalize(lightPos1 - position);\n\n            float diffuse1  = max(dot(normal,lightDir1),0.0);\n            float specular1 = pow(clamp(dot(lightDir1,reflDir),0.0,1.0),3.0);\n            float shadow1   = softShadow( position, lightDir1, 0.01, 10.0 );\n\n            vec3 diffuseColor1 = diffuse1*lightColor1*materialColor.rgb;\n            vec3 specularColor1 = specular1*materialColor.w*lightColor1;\n            vec3 ilumColor1 = shadow1*(diffuseColor1 + specularColor1);\n\n            // mixing lights\n            finalcolor += attenuation*mix(ambientColor,ilumColor1,0.8);\n\n            // prepare next ray for reflections \n            rayDir = reflDir;\n            attenuation *= 2.0*materialColor.w;\n            camPosition = position + EPSILON*normal;\n        }\n        else\n        {\n            finalcolor += attenuation*vec3(0.05,0.05,0.05); \n            attenuation = 0.0; \n        }\n\t}\n\t\n\t// desaturation, gamma correction and simple vignette\n\tfinalcolor = pow(mix( finalcolor, vec3(dot(finalcolor,vec3(0.33))), 0.3 ), vec3(0.45));\n\tfinalcolor *= mix(1.0,0.6,length(p)*0.5);\n\t\n    fragColor = vec4( finalcolor,1.0 );\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"4dSGRy","date":"1389880423","viewed":853,"name":"Roman Shield","username":"Ramocles","description":"Ray marched roman legionnaire shield with reflections. Toy inspired by all iq raymarched scenes. Hope you enjoy it.\n\nMouse controls rotation(X) and zoom(Y). ","likes":10,"published":1,"flags":0,"usePreview":0,"tags":["procedural","3d","raymarching","distancefield","scene"],"hasliked":0,"parentid":"","parentname":""}}