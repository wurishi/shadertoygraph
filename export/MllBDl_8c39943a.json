{"ver":"0.1","info":{"id":"MllBDl","date":"1514400618","viewed":396,"name":"Circular cantor dust","username":"chadiik","description":"Circular cantor dust","likes":29,"published":1,"flags":32,"usePreview":0,"tags":["circles","cantor"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 texel = 1. / iResolution.xy;\n    vec2 texelX = vec2(texel.x, 0.);\n    \n    vec4 color = vec4(0.);\n    float size = 7.;\n    for(float y = -floor(size * .5); y < ceil(size * .5); y += 1.){\n        for(float x = -floor(size * .5); x < ceil(size * .5); x += 1.){\n        \tcolor += texture(iChannel0, uv + vec2(texel.x * x, texel.y * y));\n    \t}\n    }\n    color /= size * size;\n    \n    color.rgb = clamp(color.rgb * .5, 0., 1.) + 1.5 * vec3(texture(iChannel1, uv).a);\n    \n    //color.rgb = vec3(texture(iChannel1, uv).a);\n    \n\tfragColor = color;\n    return;\n    \n\tuv = fragCoord.xy / iResolution.xy;\n    \n    color = texture(iChannel0, uv, 1.);\n    color += texture(iChannel0, uv);\n    color /= 2.;\n    \n    color.rgb = clamp(color.rgb * .5, 0., 1.) + 1.5 * vec3(texture(iChannel1, uv).a);\n    \n\tfragColor = color;\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define STROKE_THICKNESS 0.001\n#define STROKE_THICKNESS_2 vec2(STROKE_THICKNESS)\n#define RATIO vec2(iResolution.x / iResolution.y, 1.)\n#define RADIUS_LIMIT .002\n\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvec2 rotate2D(vec2 uv, float angle, vec2 offset)\n{\n    uv -= offset;\n    uv = mat2(cos(angle), -sin(angle),\n              sin(angle), cos(angle)) * uv;\n    uv += offset;\n    return uv;\n}\n\nfloat segment(vec2 p, vec2 a, vec2 b) {\n    // by Vinicius Graciano Santos - vgs/2014\n\t// https://www.shadertoy.com/view/lsBSDz\n    vec2 ab = b - a;\n    vec2 ap = p - a;\n    float k = clamp(dot(ap, ab)/dot(ab, ab), 0.0, 1.0);\n    return 1. - smoothstep(0.0, .5/iResolution.y, length(ap - k*ab) - 0.001);\n}\n\nfloat circle(vec2 uv, vec2 center, float radius)\n{\n    float d = distance(uv, center);\n    float dr = abs(d - radius);\n    return 1. - smoothstep(0., STROKE_THICKNESS, dr * .5);\n}\n\nfloat circleRec(vec2 uv, vec2 center, float radius)\n{\n    float cIntensity = clamp((.1 + RADIUS_LIMIT) / radius, 0., 1.);\n    return cIntensity * circle(uv, center, radius);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time = iTime;\n    vec2 uv = (fragCoord.xy / iResolution.xy - vec2(.25, 0.)) * RATIO;\n    vec2 center = vec2(.5, .5);\n    float radius = .48;\n    int depth = 1;\n    float curve = time * .01 + pow(sin(clamp(\n        \t(time - 3.) / .5, 0., 1.5707963268)\n        ), 2.) +\n        .05 * (sin(time * 2.) + time * 2.) - 1.5;\n    float t = abs(curve * clamp(time - 62.25, 0., 1.) * curve * .1);\n    uv = uv - ((vec2(.5) - uv) * (.2 + sin(t * 10.) * .2));\n    t = fract(t * .1503);\n    float c = circleRec(uv, center, radius);\n    while(radius >= RADIUS_LIMIT){\n        depth *= 2;\n        radius *= .5;\n        float fd = float(depth);\n        vec2 offset = vec2(-radius * (fd + 1.), 0.);\n        \n        vec2 lastnc;\n        for(int i = 0; i < depth; i++){\n            float fi = float(i);\n            offset.x += radius * 2.;\n            vec2 nc = center + offset;\n            float a = curve * \n                \t(fi - (fd * .5) + \n\t\t\t\t\t\tpow(t * 2. * (1. + fi), .5)\n                    );\n            vec2 ruv = rotate2D(uv, -a, center);\n            vec2 rnc = rotate2D(nc, -a, center);\n\n    \t\tc += circleRec(uv, rnc, radius);\n            \n            \n            if(depth > 128){\n                if(i == 0) lastnc = rnc;\n                else c += segment(uv, lastnc, rnc) * .15;\n                lastnc = rnc;\n            }\n\t\t\t\n    \t}\n    }\n    \n    float colorKey = c;\n    vec3 color = vec3(colorKey);\n    float ct = t * 2.;\n    fragColor = vec4(abs(cos(rand(uv) + ct * .5)), abs(sin(rand(color.rg) + ct + .7)), abs(tan(rand(color.gb) + ct)), colorKey);\n}","name":"Buf A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec4 map = texture(iChannel0, uv);\n    vec4 buffer = texture(iChannel1, uv);\n    \n    vec3 color = map.rgb * map.a + .93 * buffer.rgb;\n    fragColor = vec4(clamp(color, 0., 2.), map.a);\n}","name":"Buf B","description":"","type":"buffer"}]}