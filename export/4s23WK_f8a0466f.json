{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[{"channel":0,"type":"texture","id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}},{"channel":1,"type":"texture","id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"code":"float noise(vec3 p);\nfloat noise(vec2 p);\n\nvec2 Rot(vec2 p, float t) {\n\tfloat c = cos(t); float s = sin(t);\n\treturn vec2(p.x*c+p.y*s,\n\t\t\t\t-p.x*s+p.y*c);\n}\nvec2 RotCS(vec2 p, float c, float s) {\n\treturn vec2( p.x*c+p.y*s,\n\t\t\t\t-p.x*s+p.y*c);\n}\nfloat pot(vec2 pos)\n{\n\tfloat t = iTime*.1;\n\n\tvec3 p = vec3(pos+vec2(iTime*.4,0.),t);\n\t\n\tfloat n = noise(p);\n\tn += 0.5 *noise(p*2.13);\n\tn += 3. * noise(pos*0.333);\n\t\n\treturn n;\n}\n\nvec2 field(vec2 pos)\n{\n\tfloat s = 1.5;\n\tpos *= s;\n\t\n\tfloat n = pot(pos);\n\t\n\tfloat e = 0.1;\n\tfloat nx = pot(vec2(pos+vec2(e,0.)));\n\tfloat ny = pot(vec2(pos+vec2(0.,e)));\n\t\n\treturn vec2(-(ny-n),nx-n)/e;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) \n{\n\tfloat lod = 0.;\n\t\n\tvec2 uv = fragCoord.xy;\n\tuv /= iResolution.xy;\n\tuv.x *= iResolution.x/iResolution.y;\n\tuv.y = 1. - uv.y;\n\tvec2 src_uv = uv;\n\t\n\tvec3 d = vec3(0.);\n\tvec3 e = vec3(0.);\n\tfor (int i=0; i<25; i++)\n\t{\n\t\td += texture(iChannel0,uv+iTime*0.05,lod).xyz;\n\t\te += texture(iChannel0,-uv.yx*3.+iTime*0.0125,lod).xyz;\n\t\t\n\t\tvec2 new_uv = field(uv)*.00625*.5;\n\t\n\t\tlod += length(new_uv)*5.;\n\t\tuv += new_uv;\n\t}\n\t\n\n\tvec3 c = texture(iChannel0,uv*.1+iTime*0.025,lod).xyz;\n\n\td *= (1./50.);\n\te *= (1./50.);\n\tc = mix(c,d,length(d));\n\tc = mix(c,e,length(e));\n\n\tfragColor = vec4( c,1);\n\n}\n\n\n\n/* Created by Nikita Miropolskiy, nikat/2013\n * This work is licensed under a \n * Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n * http://creativecommons.org/licenses/by-nc-sa/3.0/\n *  - You must attribute the work in the source code \n *    (link to https://www.shadertoy.com/view/XsX3zB).\n *  - You may not use this work for commercial purposes.\n *  - You may distribute a derivative work only under the same license.\n */\n\n/* discontinuous pseudorandom uniformly distributed in [-0.5, +0.5]^3 */\nvec3 random3(vec3 c) {\n\tfloat j = 4096.0*sin(dot(c,vec3(17.0, 59.4, 15.0)));\n\tvec3 r;\n\tr.z = fract(512.0*j);\n\tj *= .125;\n\tr.x = fract(512.0*j);\n\tj *= .125;\n\tr.y = fract(512.0*j);\n\tr = r-0.5;\n\t\n\t//rotate for extra flow!\n\tfloat t = -iTime*.5;\n\tr.xy = Rot(r.xy,t);\n\n\t\n\treturn r;\n}\n\n/* skew constants for 3d simplex functions */\nconst float F3 =  0.3333333;\nconst float G3 =  0.1666667;\n\n/* 3d simplex noise */\nfloat noise(vec3 p) {\n\t /* 1. find current tetrahedron T and its four vertices */\n\t /* s, s+i1, s+i2, s+1.0 - absolute skewed (integer) coordinates of T vertices */\n\t /* x, x1, x2, x3 - unskewed coordinates of p relative to each of T vertices*/\n\t \n\t /* calculate s and x */\n\t vec3 s = floor(p + dot(p, vec3(F3)));\n\t vec3 x = p - s + dot(s, vec3(G3));\n\t \n\t /* calculate i1 and i2 */\n\t vec3 e = step(vec3(0.0), x - x.yzx);\n\t vec3 i1 = e*(1.0 - e.zxy);\n\t vec3 i2 = 1.0 - e.zxy*(1.0 - e);\n\t \t\n\t /* x1, x2, x3 */\n\t vec3 x1 = x - i1 + G3;\n\t vec3 x2 = x - i2 + 2.0*G3;\n\t vec3 x3 = x - 1.0 + 3.0*G3;\n\t \t\n\t /* 2. find four surflets and store them in d */\n\t vec4 w, d;\n\t \n\t /* calculate surflet weights */\n\t w.x = dot(x, x);\n\t w.y = dot(x1, x1);\n\t w.z = dot(x2, x2);\n\t w.w = dot(x3, x3);\n\t \n\t /* w fades from 0.6 at the center of the surflet to 0.0 at the margin */\n\t w = max(0.6 - w, 0.0);\n\t \n\t /* calculate surflet components */\n\t d.x = dot(random3(s), x);\n\t d.y = dot(random3(s + i1), x1);\n\t d.z = dot(random3(s + i2), x2);\n\t d.w = dot(random3(s + 1.0), x3);\n\t \n\t /* multiply d by w^4 */\n\t w *= w;\n\t w *= w;\n\t d *= w;\n\t \n\t /* 3. return the sum of the four surflets */\n\t return dot(d, vec4(52.0));\n}\n\n\n//iq 2d simplex noise\n\nvec2 hash( vec2 p )\n{\n\tp = vec2( dot(p,vec2(127.1,311.7)),\n\t\t\t  dot(p,vec2(269.5,183.3)) );\n\n\tvec2 h = -1.0 + 2.0*fract(sin(p)*43758.5453123);\n\n#if 1\t\n\t//extra rotations for more flow!\n\tfloat t = -iTime*0.7;\n\tfloat co = cos(t); float si = sin(t);\t\n\th = RotCS(h,co,si);\n#endif\n\treturn h;\n}\n\n\nfloat noise( in vec2 p )\n{\n    const float K1 = 0.366025404; // (sqrt(3)-1)/2;\n    const float K2 = 0.211324865; // (3-sqrt(3))/6;\n\n\tvec2 i = floor( p + (p.x+p.y)*K1 );\n\t\n    vec2 a = p - i + (i.x+i.y)*K2;\n    vec2 o = (a.x>a.y) ? vec2(1.0,0.0) : vec2(0.0,1.0); //vec2 of = 0.5 + 0.5*vec2(sign(a.x-a.y), sign(a.y-a.x));\n    vec2 b = a - o + K2;\n\tvec2 c = a - 1.0 + 2.0*K2;\n\n#if 1\t\n\t//even more extra rotations for more flow!\n\tfloat t = iTime*.5;\n\tfloat co = cos(t); float si = sin(t);\t\n\ta = RotCS(a,co,si);\n\tb = RotCS(b,co,si);\n\tc = RotCS(c,co,si);\n#endif\n\t\n    vec3 h = max( 0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\n\n\tvec3 n = h*h*h*h*vec3( dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0)));\n\n    return dot( n, vec3(70.0) );\n\t\n}\n","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"4s23WK","date":"1393581125","viewed":7936,"name":"Swirly Thing","username":"Antonalog","description":"Trying to make a flowy looking fluid out of various curl noise functions (courtesy of nikat and iq, thanks!)","likes":144,"published":1,"flags":0,"usePreview":0,"tags":["noise","curl","simplex","flow"],"hasliked":0,"parentid":"","parentname":""}}