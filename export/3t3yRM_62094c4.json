{"ver":"0.1","info":{"id":"3t3yRM","date":"1608793187","viewed":72,"name":"RayMarch_Sphere\t_Cube","username":"sunyuxiang","description":"learning","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["learning"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//这里是最大步进多少次\n#define MAX_STEPS 100\n//这里是距离大于多少就不继续步进检测了\n#define MAX_DIST 100.\n// 这里是距离小于多少就不继续步进检测了\n#define SURFACE_DIST .01\n\n\nmat2 Rot(float a){\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat Cube(vec3 p, vec3 pos, vec3 s)\n{\n \treturn length(max(abs(p-pos)-s, 0.0));   \n}\n\n//=Base===========================================================\n\nfloat GetDist(vec3 postion){\n    //先定义物体\n    vec3 my_sphere_postion = vec3(0.1,1,5);\n    float my_sphere_radius = 1.0;\n    \n    float my_plane = 0.;\n    \n    vec3 my_cube_postion = vec3(1,2,15);\n    vec3 my_cube_size = vec3(0.5,0.5,0.5);\n    my_cube_postion.xz *= Rot(iTime);\n    \n    //操作物体\n    \n    \n    //在计算距离\n    float sphereDist = length(postion-my_sphere_postion)-my_sphere_radius;\n    sphereDist=abs(sphereDist)-0.10;\n    float planeDist = dot(postion, normalize(vec3(0,1,0))) + my_plane ;\n    float cubeDist = Cube(postion, my_cube_postion, my_cube_size);\n    \n    //比较距离得到安全的下次前进距离\n    float safe_going_distance = min(sphereDist, planeDist);\n    safe_going_distance = min(safe_going_distance, cubeDist);\n    return safe_going_distance;\n}\n\n\nfloat RayMarch(vec3 ray_position,vec3 ray_direction){\n    float total_distance = 0.;\n    for(int i =0; i<MAX_STEPS;i++){\n        vec3 p = ray_position + total_distance*ray_direction;\n        float current_distance = GetDist(p);\n        total_distance += current_distance;\n        //注意这里是累加的，考虑到没有检测到物体的射线肯定会跑很远，返回距离很大。\n        //所以屏幕像素就会发白，而检测到的就会相对黑\n        if(current_distance<SURFACE_DIST || total_distance>MAX_DIST) \n            break;\n        }\n        return total_distance;\n    }\n\n//=Light===============================================================\n//需要算出normal vector 和light vector\nvec3 GetNormal(vec3 Pixel_Position){\n    vec2 e = vec2(.01,0);\n    float d = GetDist(Pixel_Position);\n    vec3 n = d-vec3(\n        GetDist(Pixel_Position-e.xyy),\n        GetDist(Pixel_Position-e.yxy),\n        GetDist(Pixel_Position-e.yyx));\n    return normalize(n);\n    }\n    \nfloat GetLight(vec3 Pixel_Position){\n    vec3 lightPos = vec3(0, 10, -1);\n    lightPos.xz += vec2(sin(iTime),cos(iTime))*3.;\n    vec3 l = normalize(lightPos-Pixel_Position);\n    vec3 n = GetNormal(Pixel_Position);\n    //注意这里得到了一个-1->1的值，但是0以下的都黑掉了\n    float diffuse = clamp(dot(n,l),0.,1.);\n    float d=RayMarch(Pixel_Position+n*SURFACE_DIST*2.,l);\n    if (d<length(lightPos-Pixel_Position)) diffuse*=.6;\n    return diffuse;\n    }\n    \n//=Composite===============================================================\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   \n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    \n    //-960/1080,540/1080                  960/1080,540/1080\n    //+---------------------------------------------------+\n    //|                                                   |\n    //|                                                   |\n    //|                                                   |\n    //|                                                   |\n    //|                                                   |\n    //|                                                   |\n    //|                                                   |\n    //|                                                   |\n    //|                                                   |\n    //|                                                   |\n    //|                                                   |\n    //|                                                   |\n    //+---------------------------------------------------+\n    //-960/1080,-540/1080               960/1080 ,-540/1080\n\n\n    vec3 col = vec3(0);\n    \n    vec3 camera_position = vec3(0,1,0);\n    \n    vec3 camera_direction = normalize(vec3(uv.x, uv.y,1));\n    \n    float total_distance = RayMarch(camera_position,camera_direction);\n    \n    vec3 Pixel_Position = camera_position+camera_direction*total_distance;\n    float diffuse = GetLight(Pixel_Position);\n    \n    \n    col = vec3(diffuse);\n    \n    //check normal\n    //col = GetNormal(p);\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}