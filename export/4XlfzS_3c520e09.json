{"ver":"0.1","info":{"id":"4XlfzS","date":"1728564961","viewed":188,"name":"Blackjack!","username":"krax","description":"Blackjack!\nI have yet to see someone attempt this in shadertoy, so I reckon I'd be the first!\n\n","likes":13,"published":3,"flags":32,"usePreview":0,"tags":["game","card","blackjack"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":1,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n\nBlackjack!\nI have yet to see someone attempt this in shadertoy, so I reckon I'd be the first!\n\nAs part of writing this, I came up with a better way of shuffling cards on the GPU.\n(Or more specifically shadertoy).\nIf you're interested it's in Common, search for \"Hash based shuffle\".\n\nActually most of the drawing, backend and layout logic is in Common.\nThe games logic is housed in `Buffer A`.\n\nIf the cards are too small, change ZOOM_LEVEL in `Common`.\n\nEnjoy!\n\n*/\n\nvec2 getCardOffset(uint index, uint num)\n{\n    uint d = max(1u, min(5u, num));\n    return vec2(float(index % 5u) * 1.1 + float(5u - d) * 0.5, float(index / 5u) * 0.2);\n}\n\nvec4 drawDancingDeck(vec4 back, vec2 uv, Layout l, float eventTimer)\n{\n    if (back.w < 1.0)\n    {\n\n        float t0 = eventTimer * -0.1;\n\n        const float timescale = 0.01;\n        const float yscale = 0.25;\n        const float xscale = 0.5;\n        const float freq = 6.0;\n        const float pi = 3.14159265359;\n        const float halfpi = 1.57079632679;\n        const float threehalfspi = 4.71238898038;\n\n        // The dance animation is:\n        // [\n        //      0.5  * sin(6 * t),\n        //      0.25 * cos(t)\n        // ]\n        //\n        // Where t is:\n        //     even: max(0, t0 - id * 0.01) - pi * 0.5\n        //     odd:  1.5 * pi - max(0, t0 - id * 0.01)\n\n        vec2 dStart = uv - l.deckCardStartUv;\n\n        // Early out if we're outside the renderable region.\n        if ((dStart.y < -yscale) || (dStart.x < -xscale) || (dStart.y > (yscale + l.cardLocalDim.y)) ||\n            (dStart.x > (xscale + l.cardLocalDim.x))\n\n        )\n        {\n            return back;\n        }\n\n        // Calc visible on screen (based upon animation)\n        // t0 - x * 0.01 - pi <= 0\n        uint startid = uint(clamp((t0 - pi) / timescale, 0.0, 53.0));\n\n        // t0 - x * 0.01 >= 0\n        // adding 1 card bias + ensure first card\n        // is always visible\n        uint endid = uint(clamp(t0 / timescale + 1.0, 1.0, 53.0));\n\n        // TODO:\n        // We should be able to infer\n        // what cards would potentially\n        // be under this pixel by\n        // using acos with y (or something)\n\n        // Range of cards that are valid for processing.\n        // uvec2 odd = uvec2(startid | 1u, endid   | 1u);\n        // uvec2 even = uvec2(startid + (startid & 1u), endid  + (endid & 1u));\n\n        // Precalculate these, just to make math faster later on.\n        vec2 danceCardBaseUv = bboxSpace(dStart, l.cardLocalUv);\n        vec2 danceCardOffsetScale = vec2(1.0) / l.cardLocalDim;\n\n        for (uint i = startid; i < endid; ++i)\n        {\n            uint card = FETCH_SC_STATE(1u + i);\n            float t = max(0.0, t0 - float(i) * 0.01);\n\n            // draw even\n            if ((i & 1u) == 1u)\n            {\n                t = t - halfpi;\n            }\n\n            // draw odd\n            else\n            {\n                t = threehalfspi - t;\n            }\n\n            vec2 anim = vec2(sin(t * freq) * xscale, cos(t) * yscale);\n            back = drawCard(back, danceCardBaseUv - anim * danceCardOffsetScale, card);\n        }\n    }\n    return back;\n}\n\nvoid drawPlayArea(vec2 uv, Layout l, inout vec4 fragColor)\n{\n\n    int gameState = GAME_STATE_WAITING;\n    int playerState = 0;\n    int dealerState = 0;\n    float eventTimer = 0.0;\n\n    {\n        vec4 gameStateRaw = FETCH_GLOBAL_STATE(GLOBAL_STATE_GAME_X);\n        gameState = int(gameStateRaw.x);\n        playerState = int(gameStateRaw.y);\n        dealerState = int(gameStateRaw.z);\n        eventTimer = gameStateRaw.w / EVENT_TIMER_DEAL_AMOUNT;\n    }\n\n    // Draw scores and such\n    if (bboxTest(uv, l.playerScoreBarUv) || bboxTest(uv, l.dealerScoreBarUv))\n    {\n        fragColor = vec4(0.1, 0.1, 0.1, 1.0);\n        \n        uvec4 totalScores = uvec4(FETCH_GLOBAL_STATE(GLOBAL_STATE_TOTAL_SCORE_X));\n        uvec4 scores = uvec4(FETCH_GLOBAL_STATE(GLOBAL_STATE_SCORE_X));\n\n        uint toEncode = 0xffffffffu;\n        vec4 encodeBbox = vec4(0.);\n        vec3 renderCol = vec3(0.9);\n        bool center = true;\n\n        if (bboxTest(uv, l.playerTotalScoreUv))\n        {\n            toEncode = totalScores.x;\n            encodeBbox = l.playerTotalScoreUv;\n            center = false;\n            \n            if (playerState == GAME_STATE_WON)\n            {\n                renderCol = vec3(0.0, 1.0, 0.0);\n            }\n        }\n        else if (bboxTest(uv, l.dealerTotalScoreUv))\n        {\n            toEncode = totalScores.y;\n            encodeBbox = l.dealerTotalScoreUv;\n            center = false;\n\n            if (dealerState == GAME_STATE_WON)\n            {\n                renderCol = vec3(0.0, 1.0, 0.0);\n            }\n        }\n        else if (bboxTest(uv, l.playerScoreUv))\n        {\n            uint playerScore = calcHandValue(scores.x, scores.y);\n            \n            toEncode = playerScore;\n            encodeBbox = l.playerScoreUv;\n            if (gameState == GAME_STATE_END)\n            {\n                if (playerState == GAME_STATE_WON)\n                {\n                    renderCol = vec3(0.0, 1.0, 0.0);\n                }\n                else if (playerState == GAME_STATE_LOST)\n                {\n                    renderCol = vec3(1.0, 0.0, 0.0);\n                }\n            }\n        }\n        // Don't render the dealers score until after the game is done\n        else if ((gameState == GAME_STATE_END) && bboxTest(uv, l.dealerScoreUv))\n        {\n            uint dealerScore = calcHandValue(scores.z, scores.w);\n\n            toEncode = dealerScore;\n            encodeBbox = l.dealerScoreUv;\n            if (dealerState == GAME_STATE_WON)\n            {\n                renderCol = vec3(0.0, 1.0, 0.0);\n            }\n            else if (dealerState == GAME_STATE_LOST)\n            {\n                renderCol = vec3(1.0, 0.0, 0.0);\n            }\n        }\n\n        if (toEncode != 0xffffffffu)\n        {\n            uint scoreEnc = simpleEncodeDigits(toEncode, center);\n            uint bitSigned = sampleEncodedNumber(scoreEnc, bboxSpace(uv, encodeBbox));\n            if (bitSigned != 0u)\n            {\n                fragColor.xyz = renderCol;\n            }\n        }\n    }\n\n    // Render player cards\n    {\n        bool playerCardsMoving = gameState == GAME_STATE_DEAL_P_CARD;\n        uint numPlayerCards = FETCH_PC_STATE(0);\n\n        if (playerCardsMoving)\n        {\n            // peek into the future!\n            uint index = FETCH_SC_STATE(0);\n            uint card = FETCH_SC_STATE(1u + index);\n            vec2 off = mix(l.playerCardStartUv + getCardOffset(0u, numPlayerCards + 1u) * l.cardLocalDim,\n                           l.deckCardStartUv, eventTimer);\n            vec2 drawUv = bboxSpace(uv - off, l.cardLocalUv);\n            fragColor = drawCard(fragColor, drawUv, card);\n        }\n\n        for (uint ix = 0u; ix < numPlayerCards; ++ix)\n        {\n            // draw backwards\n            uint v = numPlayerCards - ix - 1u;\n            uint card = FETCH_PC_STATE(1u + v);\n\n            vec2 off = getCardOffset(ix, numPlayerCards);\n            if (playerCardsMoving)\n            {\n                off = mix(getCardOffset(ix + 1u, numPlayerCards + 1u), off, eventTimer);\n            }\n\n            if (playerState == GAME_STATE_WON)\n            {\n                float s = min(1.0, -eventTimer);\n                off.y += sin(float(ix) + iTime * 10.0) * 0.5 * s;\n                off.x += cos(float(ix) + iTime * 5.0) * 0.1 * s;\n            }\n\n            vec2 drawUv = bboxSpace(uv - l.playerCardStartUv - off * l.cardLocalDim, l.cardLocalUv);\n            fragColor = drawCard(fragColor, drawUv, card);\n        }\n    }\n\n    // Render dealers cards\n    {\n        uint numDealerCards = FETCH_DC_STATE(0);\n        if (gameState == GAME_STATE_END)\n        {\n            for (uint ix = 0u; ix < numDealerCards; ++ix)\n            {\n                // draw backwards\n                uint v = numDealerCards - ix - 1u;\n                uint card = FETCH_DC_STATE(1u + v);\n                vec2 off = getCardOffset(ix, numDealerCards);\n                if (dealerState == GAME_STATE_WON)\n                {\n                    float s = min(1.0, -eventTimer);\n                    off.y += sin(float(ix) + iTime * 10.0) * 0.5 * s;\n                    off.x += cos(float(ix) + iTime * 5.0) * 0.1 * s;\n                }\n\n                vec2 drawUv = bboxSpace(uv - l.dealerCardStartUv - off * l.cardLocalDim, l.cardLocalUv);\n                fragColor = drawCard(fragColor, drawUv, card);\n            }\n        }\n        else\n        {\n            bool dealerCardsMoving = gameState == GAME_STATE_DEAL_D_CARD;\n            if (dealerCardsMoving)\n            {\n                vec2 off = mix(l.dealerCardStartUv + getCardOffset(0u, numDealerCards + 1u) * l.cardLocalDim,\n                               l.deckCardStartUv, eventTimer);\n                vec2 drawUv = bboxSpace(uv - off, l.cardLocalUv);\n                fragColor = drawCardBack(fragColor, drawUv);\n            }\n\n            for (uint ix = 0u; ix < numDealerCards; ++ix)\n            {\n                // draw backwards\n                vec2 off = getCardOffset(ix, numDealerCards);\n                if (dealerCardsMoving)\n                {\n                    off = mix(getCardOffset(ix + 1u, numDealerCards + 1u), off, eventTimer);\n                }\n                vec2 drawUv = bboxSpace(uv - l.dealerCardStartUv - off * l.cardLocalDim, l.cardLocalUv);\n                fragColor = drawCardBack(fragColor, drawUv);\n            }\n        }\n    }\n\n    if (gameState == GAME_STATE_END)\n    {\n        fragColor = drawDancingDeck(fragColor, uv, l, eventTimer);\n    }\n\n    // Draw the deck\n    else\n    {\n        fragColor = drawCardBack(fragColor, bboxSpace(uv - l.deckCardStartUv, l.cardLocalUv));\n    }\n    \n    if(fragColor.w <= 1.0)\n    {\n        float k = sin(uv.y * 20.0 + cos(uv.x * 10.));\n        float b = float(k > 0.0);\n        vec3 c = mix(vec3(0.1, 0.2, 0.3),\n                     vec3(0.1, 0.2, 0.4),\n                     b);\n        fragColor = mergeUnder(vec4(c, 1.0), fragColor);\n    }\n}\n\nvoid getButtonStateCols(uint state, out vec3 fg, out vec3 bg)\n{\n    if (state == BUTTON_STATE_NONE)\n    {\n        fg = vec3(0.8274);\n        bg = vec3(0.1686);\n    }\n    else if ((state == BUTTON_STATE_DOWN) || (state == BUTTON_STATE_CLIK))\n    {\n        fg = vec3(0.0, 0.8353, 1.0);\n        bg = vec3(0.2509, 0.02745, 0.4706);\n    }\n    // BUTTON_STATE_DISABLED\n    else\n    {\n        fg = vec3(0.8352);\n        bg = vec3(0.5667);\n    }\n}\n\nvoid drawButtons(vec2 uv, Layout l, inout vec4 fragColor)\n{\n    uvec4 buttonStates = uvec4(FETCH_GLOBAL_STATE(GLOBAL_STATE_BUTTONS_X));\n    vec3 fg = fragColor.xyz;\n    vec3 bg = fragColor.xyz;\n    vec2 innerUv = vec2(0.0);\n    uint sampleCoord = 0xd0d0d0d0u;\n\n    if (bboxTest(uv, l.newGameUv))\n    {\n        getButtonStateCols(buttonStates.x, fg, bg);\n        vec2 buttonLocal = bboxSpace(uv, l.newGameUv);\n\n        if (l.mobileButtons)\n        {\n            innerUv = buttonLocal + vec2(0.05, 0.0);\n            sampleCoord = 0xbeu;\n        }\n        else\n        {\n            buttonLocal = buttonLocal * vec2(4.0, 1.0) - vec2(1.5 / 4.0, -0.05);\n            if ((buttonLocal.x > 0.0) && (buttonLocal.x < 3.0))\n            {\n                uint idx = uint(buttonLocal.x);\n                innerUv = vec2(fract(buttonLocal.x), buttonLocal.y);\n                sampleCoord = 0xd0a7b5beu;\n                sampleCoord >>= (8u * idx);\n            }\n        }\n    }\n    else if (bboxTest(uv, l.hitMeUv))\n    {\n        getButtonStateCols(buttonStates.y, fg, bg);\n        vec2 buttonLocal = bboxSpace(uv, l.hitMeUv);\n\n        if (l.mobileButtons)\n        {\n            innerUv = buttonLocal + vec2(0.05, 0.0);\n            sampleCoord = 0xb8u;\n        }\n        else\n        {\n            buttonLocal = buttonLocal * vec2(4.0, 1.0) - vec2(1.5 / 4.0, -0.05);\n            if ((buttonLocal.x > 0.0) && (buttonLocal.x < 3.0))\n            {\n                uint idx = uint(buttonLocal.x);\n                innerUv = vec2(fract(buttonLocal.x), buttonLocal.y);\n                sampleCoord = 0xd0a4b9b8u;\n                sampleCoord >>= (8u * idx);\n            }\n        }\n    }\n    else if (bboxTest(uv, l.standUv))\n    {\n        getButtonStateCols(buttonStates.z, fg, bg);\n        vec2 buttonLocal = bboxSpace(uv, l.standUv);\n\n        if (l.mobileButtons)\n        {\n            innerUv = buttonLocal + vec2(0.05, 0.0);\n            sampleCoord = 0xa3u;\n        }\n        else\n        {\n            buttonLocal = buttonLocal * vec2(4.0, 1.0) - vec2(0.0, -0.05);\n            if ((buttonLocal.x > 0.0) && (buttonLocal.x < 4.0))\n            {\n                uint idx = uint(buttonLocal.x);\n                innerUv = vec2(fract(buttonLocal.x), buttonLocal.y);\n                sampleCoord = 0xb4bea4a3u;\n                sampleCoord >>= (8u * idx);\n            }\n        }\n    }\n\n    {\n        float v = 0.0;\n        if (bboxTest(innerUv, vec2(0., 1.).xxyy))\n        {\n            sampleCoord &= 0xffu;\n            vec2 p = (vec2(sampleCoord & 15u, sampleCoord >> 4) + innerUv * 1.1 - 0.1) * .0625;\n            v = texture(iChannel1, p).x;\n        }\n        fragColor.xyz = mix(bg, fg, v);\n    }\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    // fragColor.xyz = texture(iChannel1, uv).xyz;\n    // return;\n    Layout l = processLayout(iResolution.xy);\n    uv *= l.normUvParams;\n\n    fragColor = vec4(0.0);\n\n    // Menu inputs\n    if (bboxTest(uv, l.controlsBackUv))\n    {\n        fragColor.xyz = vec3(0.1);\n        drawButtons(uv, l, fragColor);\n    }\n\n    // Game area\n    else\n    {\n        drawPlayArea(uv, l, fragColor);\n    }\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// Quality settings\n#define ENABLE_AA 1\n\n// Increase this to make the cards bigger\n// Max is 2.0\n#define ZOOM_LEVEL  0.0\n\n#define USE_PARALLEL_SHUFFLE 1\n\n// Incredibly unlikely, but it is technically\n// possible when doing a shuffle for a hash collision\n// to occur, causing two cards to have the same value.\n#define PREVENT_SHUFFLE_COLLISION 0\n\n#define SUITE_HEART 0u\n#define SUITE_DIAMOND 1u\n#define SUITE_SPADE 2u\n#define SUITE_CLUB 3u\n\n#define CARD_ASPECT_RATIO 1.3968253968253967\n#define CARD_INV_ASPECT_RATIO 0.7159090909090909\n\n// GL = Y starts at the bottom\n// DX = Y starts at the top\n#ifndef Y_STARTS_AT_BOTTOM\n#define Y_STARTS_AT_BOTTOM 1\n#endif\n\nuint simpleHash32(uvec3 Seed)\n{\n    uint hx = (0xb543c3a6u ^ Seed.x);\n    uint hy = (0x526f94e2u ^ Seed.y);\n    uint hxy = hx * hy;\n    uint hz0 = 0x53c5ca59u ^ (hxy >> 5u);\n    uint hz1 = (0x74743c1bu ^ Seed.z);\n    uint h = hz0 * hz1;\n    return h;\n}\n\n// Merge A under B\nvec4 mergeUnder(vec4 A, vec4 B)\n{\n    return A * (1.0 - B.w) + B;\n}\n\nbool bboxTest(vec2 uv, vec4 bbox)\n{\n    return (uv.x > bbox.x) && (uv.x < bbox.z) && (uv.y > bbox.y) && (uv.y < bbox.w);\n}\n\nvec2 bboxSpace(vec2 uv, vec4 bbox)\n{\n    return (uv - bbox.xy) / (bbox.zw - bbox.xy);\n}\n\n// Unpack a card, given it's id.\nvoid unpackCard(uint cardId, out uint value, out uint type)\n{\n    value = cardId % 13u + 1u;\n    type = cardId / 13u;\n}\n\n// Calculate the value of a hand.\n// This takes into account the duality\n// of aces, so they are 11, unless\n// doing so would overflow 21.\nuint calcHandValue(uint valueWithoutAces, uint numAces)\n{\n    uint value = valueWithoutAces + numAces;\n\n    // There can only be one max value ace.\n    // 11 + 11 = 22, which would bust.\n    if ((value <= 11u) && (numAces > 0u))\n    {\n        value += 10u;\n    }\n\n    return value;\n}\n\nfloat drawSuiteShapeRaw(vec2 uv, uint type)\n{\n    uv = uv * 2.0 - 1.0;\n    uv.y *= CARD_ASPECT_RATIO;\n\n    if (type == SUITE_SPADE)\n    {\n        uv.y -= 0.1;\n        float d = abs(uv.x) * uv.y * -1.1 - abs(uv.x) - uv.y * uv.y + 0.5;\n\n        uv *= 2.0;\n        uv.y += 1.5;\n        float d2 = abs(uv.x) * uv.y * -1.1 - abs(uv.x) - uv.y * uv.y + 0.5;\n        return max(d, d2);\n    }\n    if (type == SUITE_HEART)\n    {\n        return abs(uv.x) * uv.y - dot(uv, uv) + 0.4;\n    }\n    if (type == SUITE_DIAMOND)\n    {\n        return dot(-abs(uv), vec2(1.5, 1.2)) + 1.0;\n    }\n\n    // if(type == SUITE_CLUB)\n    {\n\n        // I won't lie to you, most of the clubs generation is\n        // yolo at best, logic and reason went out the window\n        // in favour of eye-balling the output and playing with\n        // numbers almost randomly until it looked ok.\n\n        // left / right balls\n        float y1 = uv.y;\n        y1 *= -y1;\n        vec2 x12 = uv.xx + vec2(-0.45, 0.45);\n        x12 *= -x12;\n\n        // middle ball\n        float y2 = uv.y - 0.5;\n        y2 *= -y2;\n\n        float x2 = -uv.x * uv.x;\n\n        // Three balls merged:\n        //    -x² + -(y - 0.5)²\n        //    -(x - 0.45)² + -y²\n        //    -(y + 0.45)² + -y²\n        float d = max(x2 + y2, max(x12.x + y1, x12.y + y1)) + 0.1;\n\n        // Does the weird-ish middle shape.\n        // don't ask\n        float dex = 15.0 * x2 + (y1 * 1.5) + 0.7;\n        d = max(d, d - dex * max(x12.x + y1, x12.y + y1));\n\n        // Rounded tail (basically a spade)\n        uv.y += 0.4;\n        uv *= 2.0;\n        float d3 = abs(uv.x) * uv.y * -1.3 - abs(uv.x) - uv.y * uv.y + 0.5;\n\n        d = max(d, d3);\n        return d;\n    }\n}\n\nfloat drawSuiteShape(vec2 uv, uint type)\n{\n    // Early out, corner is always not signed.\n    if ((uv.x == 0.) && (uv.y == 0.))\n    {\n        return 0.;\n    }\n\n#if !ENABLE_AA\n    // Clubs does whack crap stuff OOB\n    // AA filters this later\n    if ((max(abs(uv.x - 0.5), abs(uv.y - 0.5)) > 0.4))\n    {\n        return 0.0;\n    }\n#endif // !ENABLE_AA\n\n    float d = drawSuiteShapeRaw(uv, type);\n\n#if ENABLE_AA\n    float aa = fwidth(d) * 0.5;\n    // Remove artefacts at uv borders, when AA is enabled\n    if ((max(abs(uv.x - 0.5), abs(uv.y - 0.5)) > 0.4))\n    {\n        return 0.0;\n    }\n    if (aa > 1.0)\n    {\n        return 0.0;\n    }\n    d = smoothstep(-aa, aa, d);\n#else  // ENABLE_AA\n    d = float(d > 0.0);\n#endif // ENABLE_AA\n    return d;\n}\n\nvec2 calcCardInnerSuiteUvAdj(vec2 uv, uint value, float row, float col)\n{\n    // no pattern for ace, 2 or 3\n    if (value < 4u)\n    {\n        return vec2(0.);\n    }\n\n    // 6 - 8 have a middle (so need a bit of spacing)\n    if ((value >= 6u) && (value <= 8u) && (row >= 1.0) && (row <= 2.0))\n    {\n        uv.y = uv.y - 1.5 + row;\n        return uv;\n    }\n\n    // flip after halfway point\n    if (row < 2.0)\n    {\n        uv.y = 1.0 - uv.y;\n    }\n\n    // 9 - 10 have everything\n    if ((value == 9u) || (value == 10u))\n    {\n        return uv;\n    }\n\n    // JQK have only left-up and right-down patterns.\n    if (value >= 11u)\n    {\n        if (((col == 2.0) && (row == 0.0)) || ((col == 0.0) && (row == 3.0)))\n        {\n            return uv;\n        }\n        return vec2(0.0);\n    }\n\n    // 4 - 10 have top and bottom\n    if ((row == 0.0) || (row == 3.0))\n    {\n        return uv;\n    }\n\n    return vec2(0.);\n}\n\nvec2 calcCardInnerSuiteUvMid(vec2 uv, uint value, float row)\n{\n    // no pattern for 4, 6 or JQK\n    if ((value >= 11u) || (value == 4u) || (value == 6u))\n    {\n        return vec2(0.);\n    }\n\n    // ace, 3, 5 and 9 have a middle (so need a bit of spacing)\n    if (((value & 1u) == 1u) && (value != 7u))\n    {\n\n        if ((row >= 1.0) && (row <= 2.0))\n        {\n            uv.y = uv.y - 1.5 + row;\n            return uv;\n        }\n\n        // ace, 5 and 9 have nothing but middle\n        if (value != 3u)\n        {\n            return vec2(0.);\n        }\n\n        // 3 has up and down, aligned to 4\n        if (row < 2.0)\n        {\n            uv.y = 1.0 - uv.y;\n        }\n        return uv;\n    }\n\n    // The rest of these have an annoying shift\n    uv.y = row + uv.y + 0.5;\n    row = floor(uv.y);\n    uv.y = fract(uv.y);\n\n    if (row == 3.0)\n    {\n        return uv;\n    }\n    if ((value != 7u) && (row == 1.0))\n    {\n        return uv;\n    }\n\n    return vec2(0.);\n}\n\nvec2 calcCardInnerSuiteUv(vec2 uv, uint value)\n{\n    vec2 result = vec2(0.);\n\n    uv.x = uv.x * 3.0;\n    float col = floor(uv.x);\n    uv.x = fract(uv.x);\n\n    uv.y *= 4.0;\n    float row = floor(uv.y);\n    uv.y = fract(uv.y);\n\n    // left and right coloumn are always identical (except for JQK)\n    if (col != 1.0)\n    {\n        result = calcCardInnerSuiteUvAdj(uv, value, row, col);\n    }\n    else\n    {\n        result = calcCardInnerSuiteUvMid(uv, value, row);\n    }\n\n    // aspect ratio\n    result.x = result.x * 4.0 / 3.0 - 0.5 / 3.0;\n\n    return result;\n}\n\n// Adapted from: `Encoding and drawing numbers`\n//               https://www.shadertoy.com/view/dtjXWK\n//\n//\n// .###. ..#.. .###. ##### #...# ##### .#### ##### .###. .###.\n// #..## .##.. #...# ....# #...# #.... #.... ....# #...# #...#\n// #.#.# ..#.. ...#. ..##. #...# ####. ####. ...#. .###. #...#\n// ##..# ..#.. ..#.. ....# .#### ....# #...# ..#.. #...# .####\n// #...# ..#.. .#... #...# ....# ....# #...# ..#.. #...# ....#\n// .###. .###. ##### .###. ....# ####. .###. ..#.. .###. .###.\n//\n// #..## .#### .###. #...# .###. .....\n// #.#.# ....# #...# #..#. #...# .....\n// #.#.# ....# #...# ###.. #...# .....\n// #.#.# ....# #...# #..#. ##### .....\n// #.#.# #...# #..#. #...# #...# .....\n// #.##. .###. .##.# #...# #...# .....\n\nuint numberPixels[16] = uint[16](\n#if !Y_STARTS_AT_BOTTOM\n    0x1d19d72eu, 0x1c4210c4u, 0x3e22222eu, 0x1d18321fu, 0x210f4631u, 0x1f083c3fu, 0x1d18bc3eu, 0x0842221fu, 0x1d18ba2eu,\n    0x1d0f462eu, 0x1b5ad6b9u, 0x1d18421eu, 0x2c98c62eu, 0x23149d31u, 0x231fc62eu, 0x00000000u\n#else\n    0x1d9ace2eu, 0x0862108eu, 0x1d14105fu, 0x3f06422eu, 0x2318fa10u, 0x3e17c20fu, 0x3c17c62eu, 0x3f041084u, 0x1d17462eu,\n    0x1d18fa0eu, 0x335ad6adu, 0x3d08422eu, 0x1d18c536u, 0x2293a631u, 0x1d18fe31u, 0x00000000u\n#endif\n);\n\nstruct RepBuffer\n{\n    uint data;\n    uint index;\n};\n\nRepBuffer RepBuffer_init()\n{\n    RepBuffer repBuffer;\n    repBuffer.data = 0u;\n    repBuffer.index = 0u;\n    return repBuffer;\n}\n\nvoid RepBuffer_push(inout RepBuffer repBuffer, uint value)\n{\n    repBuffer.data |= ((~value) & 15u) << (4u * repBuffer.index++);\n}\n\nuint RepBuffer_remainingSpace(RepBuffer repBuffer)\n{\n    return 8u - repBuffer.index;\n}\n\nuint RepBuffer_get(RepBuffer repBuffer)\n{\n    return ~repBuffer.data;\n}\n\nvoid RepBuffer_rev(inout RepBuffer repBuffer)\n{\n    uint i = repBuffer.index;\n    uint k = 0u;\n\n    for (uint i = 1u; i <= repBuffer.index; ++i)\n    {\n        k |= ((repBuffer.data >> (4u * (repBuffer.index - i))) & 15u) << (4u * (i - 1u));\n    }\n\n    repBuffer.data = k;\n}\n\nvoid RepBuffer_center(inout RepBuffer repBuffer)\n{\n    repBuffer.data <<= (4u * ((8u - repBuffer.index) >> 1));\n}\n\nuint simpleEncodeDigits(uint n, bool center)\n{\n    RepBuffer repBuffer = RepBuffer_init();\n\n    n = min(n, 99999999u);\n\n    if (n == 0u)\n    {\n        RepBuffer_push(repBuffer, 0u);\n    }\n    while (n > 0u)\n    {\n        RepBuffer_push(repBuffer, n % 10u);\n        n /= 10u;\n    }\n    RepBuffer_rev(repBuffer);\n    \n    if (center)\n    {\n        RepBuffer_center(repBuffer);\n    }\n\n    return RepBuffer_get(repBuffer);\n}\n\nuint sampleEncodedDigit(uint encodedDigit, vec2 uv)\n{\n    if (uv.x < 0. || uv.y < 0. || uv.x >= 1. || uv.y >= 1.)\n        return 0u;\n    uvec2 coord = uvec2(uv * vec2(5., 6.));\n    return (numberPixels[encodedDigit] >> (coord.y * 5u + coord.x)) & 1u;\n}\n\n// 8 character variant\nuint sampleEncodedNumber(uint encodedNumber, vec2 uv)\n{\n    // Extract the digit ID by scaling the uv.x value by 8 and clipping\n    // the relevant 4 bits.\n    uv.x *= 8.0;\n    uint encodedDigit = (encodedNumber >> (uint(uv.x) * 4u)) & 0xfu;\n\n    // Put the U in between then [0, 1.2] range, the extra 0.2 is add a\n    // logical 1px padding.\n    // (6/5, where 5 is the number of pixels on the x axis)\n    uv.x = fract(uv.x) * 1.2;\n\n    return sampleEncodedDigit(encodedDigit, uv);\n}\n\nfloat drawCardType(vec2 uv, uint value)\n{\n    // Ace gets a little redirection\n    if (value == 1u)\n    {\n        value = 14u;\n    }\n    float v = float(sampleEncodedDigit(value, uv));\n    return v;\n}\n\n// Card drawing logic, draws under whatever\n// has already been rendered to prevent overdraw.\nvec4 drawCard(vec4 back, vec2 uv, uint value, uint type)\n{\n    if (bboxTest(uv, vec2(0.0, 1.0).xxyy) && (back.w < 1.0))\n    {\n        vec2 ndcRd = uv * 2.0 - 1.0;\n        ndcRd = ndcRd * ndcRd;\n        ndcRd = ndcRd * ndcRd;\n        ndcRd = ndcRd * ndcRd;\n        ndcRd = ndcRd * ndcRd;\n        ndcRd = ndcRd * ndcRd;\n\n        float edgeDf = 1.0 - ndcRd.x - ndcRd.y;\n\n#if ENABLE_AA\n        float aa = fwidth(edgeDf);\n        float border = smoothstep(-aa, aa, edgeDf);\n#else  // ENABLE_AA\n        float border = float(edgeDf > 0.0);\n#endif // ENABLE_AA\n\n        if (border > 0.0)\n        {\n            vec2 typeUv = vec2(0.0);\n            vec2 valueUv = vec2(0.0);\n            vec3 outCol = vec3(1.0);\n\n            vec3 typeCol = type < 2u ? vec3(1.0, 0.0, 0.0) : vec3(0.0);\n\n            // Tint interior\n            outCol = mix(outCol, typeCol, smoothstep(0.00, 1.15, 0.1 - abs(edgeDf - 1.0)));\n\n            // Outline\n            outCol = mix(outCol, vec3(0.0), float(edgeDf < 0.7) * 0.5);\n\n            // Inner\n            if ((min(uv.x, uv.y) > 0.15) && (max(uv.x, uv.y) < 0.85))\n            {\n                typeUv = calcCardInnerSuiteUv((uv - 0.15) * 1.4285714285714286, value);\n                if (value >= 11u)\n                {\n                    if ((min(uv.x, uv.y) > 0.4) && (max(uv.x, uv.y) < 0.6))\n                    {\n                        valueUv = (uv - 0.4) * 5.;\n                    }\n                }\n            }\n            // Outer\n            else\n            {\n                // Mirror top/left with bottom/right, for that classic\n                // rotated value / suite look.\n                vec2 outerUv = uv;\n                if (outerUv.y < 0.5)\n                {\n                    outerUv = 1.0 - outerUv;\n                }\n\n                if ((outerUv.x > 0.05) && (outerUv.x < 0.15))\n                {\n                    if ((outerUv.y > 0.85) && (outerUv.y < 0.95))\n                    {\n                        valueUv = (outerUv - vec2(0.05, 0.85)) / (0.15 - 0.05);\n                    }\n                    else if ((outerUv.y > 0.75) && (outerUv.y < 0.85))\n                    {\n                        typeUv = (outerUv - vec2(0.05, 0.75)) / (0.15 - 0.05);\n                    }\n                }\n\n                // Draw a happy border for JQK\n                outCol = mix(outCol, typeCol, smoothstep(-0.05, 0.05, 0.1 - abs(edgeDf - 0.6)));\n            }\n\n            if ((valueUv.x != 0.0) && (valueUv.y != 0.0))\n            {\n                outCol = mix(outCol, typeCol, drawCardType(valueUv, value));\n            }\n            else\n            {\n                outCol = mix(outCol, typeCol, drawSuiteShape(typeUv, type));\n            }\n\n            vec4 outValue = vec4(outCol, 1.0);\n#if ENABLE_AA\n            outValue *= border;\n#endif // ENABLE_AA\n            back = mergeUnder(outValue, back);\n        }\n    }\n\n    return back;\n}\n\nvec4 drawCard(vec4 back, vec2 uv, uint cardId)\n{\n    uint value = 0u;\n    uint type = 0u;\n    unpackCard(cardId, value, type);\n    return drawCard(back, uv, value, type);\n}\n\nvec4 drawCardBack(vec4 back, vec2 uv)\n{\n    if (bboxTest(uv, vec2(0.0, 1.0).xxyy) && (back.w < 1.0))\n    {\n        vec2 ndcRd = uv * 2.0 - 1.0;\n        ndcRd = ndcRd * ndcRd;\n        ndcRd = ndcRd * ndcRd;\n        ndcRd = ndcRd * ndcRd;\n        ndcRd = ndcRd * ndcRd;\n        ndcRd = ndcRd * ndcRd;\n\n        float edgeDf = 1.0 - ndcRd.x - ndcRd.y;\n\n#if ENABLE_AA\n        float aa = fwidth(edgeDf);\n        float border = smoothstep(-aa, aa, edgeDf);\n#else  // ENABLE_AA\n        float border = float(edgeDf > 0.0);\n#endif // ENABLE_AA\n\n        if (border > 0.0)\n        {\n            vec2 typeUv = vec2(0.0);\n            vec2 valueUv = vec2(0.0);\n            vec3 outCol = vec3(1.0);\n\n            // abstract pattern.\n            float d = abs(cos((uv.x * 2.0 - 1.0) * (uv.y * 2.0 - 1.0) * 25.0));\n            outCol = vec3(smoothstep(0., 1.0, d));\n\n            vec4 outValue = vec4(outCol, 1.0);\n#if ENABLE_AA\n            outValue *= border;\n#endif // ENABLE_AA\n            back = mergeUnder(outValue, back);\n        }\n    }\n\n    return back;\n}\n\n// Hash based shuffle\n// ------------------\n//\n// Trying to use Fisher-Yates, in the\n// context of outputting an id to\n// a pixel, would result in each thread\n// having to store 52 (or 13) registers.\n// Which would be and excessive amount of\n// register pressure.\n// Unless you process a value each frame,\n// which would then take a boring amount\n// of time to resolve.\n//\n// Instead this takes a different approach.\n// Each element calculates a hash for itself,\n// then counts how many other elements have\n// a smaller hash.\n// This results in it's, new id.\n//\n// It has the same ALU cost as Fisher-Yates,\n// since a random number needs to be generated\n// for each element, but reduces register use.\n\nuint hash_shuffle_id(uint id, uvec3 seed)\n{\n    uint h = simpleHash32(uvec3(id ^ seed.x, seed.yz));\n\n#if PREVENT_SHUFFLE_COLLISION\n    h <<= 6;\n    h |= id;\n#endif // PREVENT_SHUFFLE_COLLISION\n\n    return h;\n}\n\nuint hash_shuffle(uint id, uint num, uvec3 seed)\n{\n    uint h = hash_shuffle_id(id, seed);\n    uint idx = 0u;\n    for (uint i = 0u; i < num; ++i)\n    {\n        if (hash_shuffle_id(i, seed) < h)\n        {\n            ++idx;\n        }\n    }\n    return idx;\n}\n\nuint shuffle_52(uint i, uvec3 seed)\n{\n    return hash_shuffle(i, 52u, seed);\n}\n\n// Two part parallel shuffle\n// -------------------------\n//\n// First pass is 13 short.\n// Second pass is 4 wide.\n//\n// Derived from the factors of 52\n// (number of playing cards).\n//\n// Logically you can think of this as:\n// 1. Shuffling in suit in parallel.\n// 2. Shuffling suit type in parallel.\n//\n// This does add a bit of determinism,\n// every 13th card will be a different\n// type of suite, however practically,\n// this probably doesn't matter.\n\nuint shuffle_13(uint i, uvec3 seed)\n{\n    return hash_shuffle(i, 13u, seed);\n}\n\n// Fisher-Yates, for 4 elements\n// with the result stored in a single\n// uint to minimize register pressure.\nuint shuf4_swap(uint v, uint i, uint j)\n{\n    i <<= 1;\n    j <<= 1;\n    uint x = ((v >> i) ^ (v >> j)) & 3u;\n    v = ((x << i) | (x << j)) ^ v;\n    return v;\n}\n\n// Out index: 2:2:2:2\nuint shuffle_4_packed(uint seed)\n{\n    uint v = 228u;\n\n    v = shuf4_swap(v, 0u, seed & 3u);\n    v = shuf4_swap(v, 1u, (seed >> 2) % 3u + 1u);\n    v = shuf4_swap(v, 2u, 2u + ((seed >> 7) & 1u));\n    return v;\n}\n\nuint shuffle_4(uint i, uvec3 seed)\n{\n    uint v = shuffle_4_packed(simpleHash32(seed));\n    uint idx = (v >> (i << 1)) & 3u;\n    return idx;\n}\n\nuint shuffle_13_4(uint i, uvec3 seed)\n{\n    // Resolve whichever suite we're swapping with\n    uint shuf4_id = i / 13u;\n    uint shuf13_id = i % 13u;\n    uint outer = shuffle_4(shuf4_id, seed + shuf13_id ^ seed.x);\n\n    // Use that suites seed, so we are swapping as part\n    // of it's array.\n    uint inner = shuffle_13(shuf13_id, seed ^ (outer * 1313u));\n\n    return inner + outer * 13u;\n}\n\nuint shuffle_deck(uint i, uvec3 seed)\n{\n#if USE_PARALLEL_SHUFFLE\n    return shuffle_13_4(i, seed);\n#else  // USE_PARALLEL_SHUFFLE\n    return shuffle_52(i, seed);\n#endif // USE_PARALLEL_SHUFFLE\n}\n\n// Test for ensuring shuffling looks\n// correct, pink is true shuffle,\n// cyan is split-parallel shuffle\nvec3 shuffle_test(vec2 uv, uvec3 seed)\n{\n    uv.y *= 2.0;\n\n    uint i = uint(uv.x * 52.0);\n    uint j = uint(fract(uv.y) * 52.0);\n\n    uint idx = 0u;\n    vec3 col = vec3(0.);\n\n    // True shuffle\n    if (uv.y >= 1.0)\n    {\n        col = vec3(1., 0., 1.);\n        idx = shuffle_52(i, seed);\n    }\n\n    // Parallel shuffle\n    else\n    {\n        col = vec3(0., 1., 1.);\n        idx = shuffle_13_4(i, seed);\n    }\n\n    float J = float(idx >= j);\n    return col * J;\n}\n\n// Process the layout, given the aspect\n// ratio and what have you, make sure\n// buttons, where text goes and where\n// cards go makes sense.\n\nvec2 normalisedUvParams(vec2 res)\n{\n    vec2 result = vec2(1.);\n    if (res.x >= res.y)\n    {\n        result.x = res.x / res.y;\n    }\n    else\n    {\n        result.y = res.y / res.x;\n    }\n    return result;\n}\n\nstruct Layout\n{\n    vec2 normUvParams;\n    vec4 controlsBackUv;\n\n    bool mobileButtons;\n    vec4 newGameUv;\n    vec4 hitMeUv;\n    vec4 standUv;\n    vec4 playAreaUv;\n\n    vec4 playerScoreBarUv;\n    vec4 playerTotalScoreUv;\n    vec4 playerScoreUv;\n\n    vec4 dealerScoreBarUv;\n    vec4 dealerTotalScoreUv;\n    vec4 dealerScoreUv;\n\n    vec4 cardLocalUv;\n    vec2 cardLocalDim;\n    vec2 playerCardStartUv;\n    vec2 dealerCardStartUv;\n    vec2 deckCardStartUv;\n};\n\nLayout processLayout(vec2 res)\n{\n    Layout l;\n\n    l.normUvParams = normalisedUvParams(res);\n\n    // Interface on the right\n    if (res.x >= res.y)\n    {\n        l.controlsBackUv = vec4(l.normUvParams.x - 0.3, 0., l.normUvParams.x, 1.0);\n\n        vec2 btnUBase = vec2(l.normUvParams.x - 0.25, l.normUvParams.x - 0.05);\n        float btnAspect = 1.0 / 3.0;\n        float btnHeight = (btnUBase.y - btnUBase.x) * btnAspect;\n        float btnPadding = btnHeight * 2.5;\n\n        l.mobileButtons = false;\n        l.newGameUv = vec4(btnUBase.x, 0.9 - btnHeight, btnUBase.y, 0.9);\n\n        l.hitMeUv = vec4(btnUBase.x, 0.5 - btnHeight - btnPadding * 0.5, btnUBase.y, 0.5 - btnPadding * 0.5);\n\n        l.standUv = vec4(btnUBase.x, 0.5 - btnHeight + btnPadding * 0.5, btnUBase.y, 0.5 + btnPadding * 0.5);\n\n        l.playAreaUv = vec4(0., 0., l.controlsBackUv.x, 1.0);\n    }\n\n    // At the bottom (phone fullscreen)\n    else\n    {\n        l.controlsBackUv = vec4(0., 0., 1.0, 0.2);\n\n        float buttonPadding = 0.05;\n        vec2 buttonSize = l.controlsBackUv.ww - 2.0 * buttonPadding;\n\n        l.mobileButtons = true;\n        l.newGameUv = vec4(buttonPadding, buttonPadding, buttonSize + buttonPadding);\n\n        l.hitMeUv =\n            vec4(0.5 - buttonSize.x * 0.5, buttonPadding, 0.5 + buttonSize.x * 0.5, buttonSize.y + buttonPadding);\n\n        l.standUv =\n            vec4(1.0 - buttonSize.x - buttonPadding, buttonPadding, 1.0 - buttonPadding, buttonSize.y + buttonPadding);\n\n        l.playAreaUv = vec4(0.0, l.controlsBackUv.w, 1.0, l.normUvParams.y);\n    }\n\n    // Player score\n    l.playerScoreBarUv =\n        vec4(l.playAreaUv.xy, l.playAreaUv.z, l.playAreaUv.y + (l.playAreaUv.w - l.playAreaUv.y) * 0.05);\n\n    float scoreBarWidth = l.playerScoreBarUv.z - l.playerScoreBarUv.x;\n    float scoreBarHeight = l.playerScoreBarUv.w - l.playerScoreBarUv.y;\n    float scorePadding = min(scoreBarWidth, scoreBarHeight) * 0.2;\n\n    l.playerScoreUv.xy = l.playerScoreBarUv.xy + scorePadding;\n    l.playerScoreUv.z = l.playerScoreUv.x + (scoreBarHeight - 2.0 * scorePadding) * 6.0;\n    l.playerScoreUv.w = l.playerScoreBarUv.w - scorePadding;\n\n    l.playerTotalScoreUv = l.playerScoreUv;\n\n    // Center score\n    float scoreOffset = (scoreBarWidth - (l.playerScoreUv.z - l.playerScoreUv.x)) * 0.5;\n    l.playerScoreUv.xz += scoreOffset;\n\n    // Dealer score\n    float dealerScoreYDelta = l.playAreaUv.w - scoreBarHeight - l.playerScoreBarUv.y;\n    l.dealerScoreBarUv = l.playerScoreBarUv + vec4(0.0, dealerScoreYDelta, 0.0, dealerScoreYDelta);\n    l.dealerScoreUv = l.playerScoreUv + vec4(0.0, dealerScoreYDelta, 0.0, dealerScoreYDelta);\n    \n    l.dealerTotalScoreUv = l.playerTotalScoreUv + vec4(0.0, dealerScoreYDelta, 0.0, dealerScoreYDelta);\n    \n    vec4 cardAreaUv = vec4(l.playerScoreBarUv.xw, l.dealerScoreBarUv.zy);\n\n    // Practically allocating more than we need.\n    const float numCardsWidth = 7.0;\n    const float numCardsHeight = (6.0 - min(2.0, ZOOM_LEVEL));\n\n    vec2 cardAreaUvDim = cardAreaUv.zw - cardAreaUv.xy;\n\n    l.cardLocalUv.xy = vec2(0.0);\n\n    // This logic is kind of broken.\n    if ((CARD_INV_ASPECT_RATIO * numCardsWidth / cardAreaUvDim.x) >\n        (CARD_ASPECT_RATIO * numCardsHeight / cardAreaUvDim.y))\n    {\n        l.cardLocalUv.w = cardAreaUvDim.x * CARD_ASPECT_RATIO / numCardsWidth;\n        l.cardLocalUv.z = l.cardLocalUv.w * CARD_INV_ASPECT_RATIO;\n    }\n    else\n    {\n        l.cardLocalUv.z = cardAreaUvDim.y * CARD_INV_ASPECT_RATIO / numCardsHeight;\n        l.cardLocalUv.w = l.cardLocalUv.z * CARD_ASPECT_RATIO;\n    }\n\n    l.cardLocalDim = l.cardLocalUv.zw;\n    l.cardLocalUv.zw += l.cardLocalUv.xy;\n\n    // Center cards\n    float pdCardStartU = (cardAreaUv.z + cardAreaUv.x) * 0.5 - 1.1 * 5.0 * l.cardLocalDim.x * 0.5;\n\n    l.playerCardStartUv = cardAreaUv.xy + vec2(pdCardStartU, l.cardLocalDim.y * 0.1);\n    l.dealerCardStartUv = cardAreaUv.xw + vec2(pdCardStartU, l.cardLocalDim.y * -1.1);\n    l.deckCardStartUv = (cardAreaUv.xy + cardAreaUv.zw - l.cardLocalDim) * 0.5;\n\n    return l;\n}\n\n#define EVENT_TIMER_DEAL_AMOUNT 0.3\n\n#define GAME_STATE_MAX_X 53\n#define GAME_STATE_MAX_Y 5\n\n#define GAME_STATE_GLOBAL_STATE_Y 0\n#define GLOBAL_STATE_GAME_X 0\n#define GLOBAL_STATE_TIME_X 1\n#define GLOBAL_STATE_BUTTONS_X 2\n#define GLOBAL_STATE_TOTAL_SCORE_X 3\n#define GLOBAL_STATE_SCORE_X 4\n\n#define GAME_STATE_SHUFFLED_CARDS_Y 1\n#define GAME_STATE_PLAYER_CARDS_Y 2\n#define GAME_STATE_DEALER_CARDS_Y 3\n\n#define FETCH_GAME_STATE(X, Y) (texelFetch(iChannel0, ivec2(int(X), int(Y)), 0))\n#define FETCH_GLOBAL_STATE(X) FETCH_GAME_STATE(X, GAME_STATE_GLOBAL_STATE_Y)\n#define FETCH_SC_STATE(X) uint(FETCH_GAME_STATE(X, GAME_STATE_SHUFFLED_CARDS_Y).x)\n#define FETCH_PC_STATE(X) uint(FETCH_GAME_STATE(X, GAME_STATE_PLAYER_CARDS_Y).x)\n#define FETCH_DC_STATE(X) uint(FETCH_GAME_STATE(X, GAME_STATE_DEALER_CARDS_Y).x)\n\n#define GAME_STATE_WAITING 0\n#define GAME_STATE_END 1\n#define GAME_STATE_DEAL_P_CARD 2\n#define GAME_STATE_DEAL_D_CARD 3\n\n#define GAME_STATE_PLAYING 0\n#define GAME_STATE_STANDING 1\n#define GAME_STATE_LOST 2\n#define GAME_STATE_WON 3\n#define GAME_STATE_DRAW 4\n\n#define BUTTON_STATE_NONE 0u\n#define BUTTON_STATE_DOWN 1u\n#define BUTTON_STATE_CLIK 2u\n#define BUTTON_STATE_DISABLED 3u\n\nuint updateButtonState(vec2 mouseUv, bool down, vec4 bbox, uint prevState)\n{\n    if (prevState == BUTTON_STATE_DISABLED)\n    {\n        return BUTTON_STATE_DISABLED;\n    }\n    if (prevState == BUTTON_STATE_CLIK)\n    {\n        return BUTTON_STATE_NONE;\n    }\n\n    // if previous state was down, if it's no longer down\n    if (!down && (prevState == BUTTON_STATE_DOWN))\n    {\n        return BUTTON_STATE_CLIK;\n    }\n    if (down && bboxTest(mouseUv, bbox))\n    {\n        return BUTTON_STATE_DOWN;\n    }\n    return BUTTON_STATE_NONE;\n}\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// This buffer controls all regular game logic.\n\nvoid mainImage(out vec4 fragColor, in vec2 fcoord)\n{\n    fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n\n    ivec2 coord = ivec2(fcoord);\n    if ((coord.x > GAME_STATE_MAX_X) || (coord.y > GAME_STATE_MAX_Y))\n    {\n        return;\n    }\n\n    Layout l = processLayout(iResolution.xy);\n\n    int gameState = GAME_STATE_WAITING;\n    int playerState = 0;\n    int dealerState = 0;\n    float eventTimer = 0.0;\n\n    {\n        vec4 gameStateRaw = FETCH_GLOBAL_STATE(GLOBAL_STATE_GAME_X);\n        gameState = int(gameStateRaw.x);\n        playerState = int(gameStateRaw.y);\n        dealerState = int(gameStateRaw.z);\n        eventTimer = gameStateRaw.w - iTimeDelta;\n    }\n    \n    int ogGameState = gameState;\n\n    // Make sure this is always kept in sync\n    if (playerState == GAME_STATE_LOST)\n    {\n        dealerState = GAME_STATE_WON;\n        gameState = GAME_STATE_END;\n    }\n    if (dealerState == GAME_STATE_LOST)\n    {\n        playerState = GAME_STATE_WON;\n        gameState = GAME_STATE_END;\n    }\n\n    uvec4 scores = uvec4(FETCH_GLOBAL_STATE(GLOBAL_STATE_SCORE_X));\n\n    // Handle input\n    uvec4 buttonStates = uvec4(FETCH_GLOBAL_STATE(GLOBAL_STATE_BUTTONS_X));\n    bool mouseDown = (iMouse.z > 0.0) || (iMouse.w > 0.0);\n    vec2 mouseUv = (iMouse.xy / iResolution.xy) * l.normUvParams;\n\n    // Disable buttons when events are taking place or game has ended\n    if ((eventTimer > 0.0) || (gameState == GAME_STATE_END) || (playerState == GAME_STATE_STANDING))\n    {\n        buttonStates.y = BUTTON_STATE_DISABLED;\n        buttonStates.z = BUTTON_STATE_DISABLED;\n    }\n    else\n    {\n        if (buttonStates.y == BUTTON_STATE_DISABLED)\n        {\n            buttonStates.y = BUTTON_STATE_NONE;\n        }\n        if (buttonStates.z == BUTTON_STATE_DISABLED)\n        {\n            buttonStates.z = BUTTON_STATE_NONE;\n        }\n    }\n\n    // new game\n    buttonStates.x = updateButtonState(mouseUv, mouseDown, l.newGameUv, buttonStates.x);\n    // hitme\n    buttonStates.y = updateButtonState(mouseUv, mouseDown, l.hitMeUv, buttonStates.y);\n    // stand\n    buttonStates.z = updateButtonState(mouseUv, mouseDown, l.standUv, buttonStates.z);\n\n    // Timer updates\n    float prevTime = FETCH_GLOBAL_STATE(GLOBAL_STATE_TIME_X).x;\n    float curTime = prevTime + iTimeDelta;\n\n    bool bNewGame = (iFrame == 0) || (buttonStates.x == BUTTON_STATE_CLIK);\n\n    if (bNewGame)\n    {\n        // Create a shuffled deck.\n        if (coord.y == GAME_STATE_SHUFFLED_CARDS_Y)\n        {\n            // Zero the current card index.\n            if (coord.x == 0)\n            {\n                return;\n            }\n\n            uvec3 seed = floatBitsToUint(iDate.yzw) ^ uint(iFrame);\n            // We _could_, so each pixel stores 4 values, but that would make\n            // indexing a lot more complicated.\n            uint shuffled = shuffle_deck(uint(coord.x - 1), seed);\n            fragColor.x = float(shuffled);\n            return;\n        }\n\n        // Zero everything, that isn't the global state\n        else if (coord.y != GAME_STATE_GLOBAL_STATE_Y)\n        {\n            return;\n        }\n\n        // Reset global timer.\n        curTime = 0.0;\n        prevTime = 0.0;\n\n        // Deal a card to the player\n        gameState = GAME_STATE_DEAL_P_CARD;\n        playerState = GAME_STATE_PLAYING;\n        dealerState = GAME_STATE_PLAYING;\n        eventTimer = EVENT_TIMER_DEAL_AMOUNT;\n\n        scores = uvec4(0u);\n    }\n\n    // As a starting point, copy back whatever is\n    // currently stored.\n    fragColor = texelFetch(iChannel0, coord, 0);\n\n    bool dealPlayerNewCard = false;\n    bool dealDealerNewCard = false;\n\n    if (gameState == GAME_STATE_DEAL_P_CARD)\n    {\n        if (playerState == GAME_STATE_STANDING)\n        {\n            gameState = GAME_STATE_DEAL_D_CARD;\n            eventTimer = EVENT_TIMER_DEAL_AMOUNT;\n        }\n        else if (eventTimer <= 0.0)\n        {\n            dealPlayerNewCard = true;\n            gameState = GAME_STATE_DEAL_D_CARD;\n            eventTimer = EVENT_TIMER_DEAL_AMOUNT;\n        }\n    }\n    else if (gameState == GAME_STATE_DEAL_D_CARD)\n    {\n        if (dealerState == GAME_STATE_STANDING)\n        {\n            gameState = GAME_STATE_WAITING;\n        }\n        else if (eventTimer <= 0.0)\n        {\n            dealDealerNewCard = true;\n            gameState = GAME_STATE_WAITING;\n\n            // Keep giving the dealer cards\n            if (playerState == GAME_STATE_STANDING)\n            {\n                gameState = GAME_STATE_DEAL_D_CARD;\n                eventTimer = EVENT_TIMER_DEAL_AMOUNT;\n            }\n        }\n    }\n\n    // Someone is getting a card.\n    if (dealPlayerNewCard || dealDealerNewCard)\n    {\n        uint index = FETCH_SC_STATE(0);\n        uint card = FETCH_SC_STATE(1u + index);\n        int outY = dealPlayerNewCard ? GAME_STATE_PLAYER_CARDS_Y : GAME_STATE_DEALER_CARDS_Y;\n\n        // Increment the pointer\n        if ((coord.y == GAME_STATE_SHUFFLED_CARDS_Y) && (coord.x == 0))\n        {\n            fragColor.x = float(index + 1u);\n        }\n\n        // Write back new card\n        else\n        {\n            if (coord.y == outY)\n            {\n                uint pindex = uint(FETCH_GAME_STATE(0, outY).x);\n                if (coord.x == 0)\n                {\n                    fragColor.x = float(pindex + 1u);\n                }\n                else if (coord.x == int(pindex + 1u))\n                {\n                    fragColor.x = float(card);\n                }\n            }\n        }\n\n        // Calculate the player (or dealers) new hand\n        uint cardValue = 0u;\n        uint cardType = 0u;\n        unpackCard(card, cardValue, cardType);\n\n        if (cardValue <= 1u) // Ace\n        {\n            if (dealPlayerNewCard)\n            {\n                scores.y += 1u;\n            }\n            else\n            {\n                scores.w += 1u;\n            }\n        }\n        else\n        {\n            uint addon = (cardValue < 11u) ? cardValue : 10u;\n            if (dealPlayerNewCard)\n            {\n                scores.x += addon;\n            }\n            else\n            {\n                scores.z += addon;\n            }\n        }\n    }\n\n    // Handle user input\n    if ((buttonStates.y == BUTTON_STATE_CLIK) && (playerState != GAME_STATE_STANDING))\n    {\n        gameState = GAME_STATE_DEAL_P_CARD;\n        eventTimer = EVENT_TIMER_DEAL_AMOUNT;\n    }\n    else if (buttonStates.z == BUTTON_STATE_CLIK)\n    {\n        playerState = GAME_STATE_STANDING;\n        gameState = GAME_STATE_DEAL_P_CARD;\n        eventTimer = EVENT_TIMER_DEAL_AMOUNT;\n    }\n\n    uint playerScore = calcHandValue(scores.x, scores.y);\n    uint dealerScore = calcHandValue(scores.z, scores.w);\n\n    if ((playerScore == 21u) || (dealerScore > 21u))\n    {\n        playerState = GAME_STATE_WON;\n        dealerState = GAME_STATE_LOST;\n        gameState = GAME_STATE_END;\n    }\n    else if ((dealerScore == 21u) || (playerScore > 21u))\n    {\n        playerState = GAME_STATE_LOST;\n        dealerState = GAME_STATE_WON;\n        gameState = GAME_STATE_END;\n    }\n    else if (gameState != GAME_STATE_END)\n    {\n        if (dealerScore >= 17u)\n        {\n            dealerState = GAME_STATE_STANDING;\n        }\n        else if ((playerState == GAME_STATE_STANDING) && (dealerScore > playerScore))\n        {\n            dealerState = GAME_STATE_STANDING;\n        }\n    }\n\n    if ((playerState == GAME_STATE_STANDING) && (dealerState == GAME_STATE_STANDING))\n    {\n        if (dealerScore < playerScore)\n        {\n            playerState = GAME_STATE_WON;\n            dealerState = GAME_STATE_LOST;\n        }\n        else if (dealerScore > playerScore)\n        {\n            playerState = GAME_STATE_LOST;\n            dealerState = GAME_STATE_WON;\n        }\n        else\n        {\n            playerState = GAME_STATE_DRAW;\n            dealerState = GAME_STATE_DRAW;\n        }\n\n        gameState = GAME_STATE_END;\n    }\n\n    // Visually disable buttons for this frame\n    if ((eventTimer > 0.0) || (gameState == GAME_STATE_END) || (playerState == GAME_STATE_STANDING))\n    {\n        buttonStates.y = BUTTON_STATE_DISABLED;\n        buttonStates.z = BUTTON_STATE_DISABLED;\n    }\n\n    // Update the global state\n    if (coord.y == GAME_STATE_GLOBAL_STATE_Y)\n    {\n        if (coord.x == GLOBAL_STATE_GAME_X)\n        {\n            fragColor = vec4(float(gameState), float(playerState), float(dealerState), eventTimer);\n        }\n        else if (coord.x == GLOBAL_STATE_TIME_X)\n        {\n            fragColor = vec4(prevTime, curTime, iTimeDelta, 0.0);\n        }\n        else if (coord.x == GLOBAL_STATE_BUTTONS_X)\n        {\n            fragColor = vec4(buttonStates);\n        }\n        else if (coord.x == GLOBAL_STATE_TOTAL_SCORE_X)\n        {\n            if ((ogGameState != gameState) && (gameState == GAME_STATE_END))\n            {\n                if (playerState == GAME_STATE_WON)\n                {\n                    fragColor.x += 1.0;\n                }\n                else if(dealerState == GAME_STATE_WON)\n                {\n                    fragColor.y += 1.0;\n                }\n            }\n        }\n        else if (coord.x == GLOBAL_STATE_SCORE_X)\n        {\n            fragColor = vec4(scores);\n        }\n\n        return;\n    }\n}","name":"Buffer A","description":"","type":"buffer"}]}