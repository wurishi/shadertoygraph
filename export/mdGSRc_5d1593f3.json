{"ver":"0.1","info":{"id":"mdGSRc","date":"1681399310","viewed":183,"name":"Pawn Materials","username":"xor_swap","description":"All the materials I learned so far and also pearl.","likes":7,"published":1,"flags":0,"usePreview":1,"tags":["3d","raymarching","reflection","refraction"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n// Cristian A. aka @swap_xor on twitter\n// I make cool stuff, follow me and checkout\n// https://github.com/cristian-5\n\n// materials:\n\n#define obj vec2\n\nconst int DISTANCE = 0;\nconst int MATERIAL = 1;\n\nconst int GLASS = 0;\nconst int OPAQUE_GLASS = 1;\nconst int GOLD = 2;\nconst int SILVER = 3;\nconst int BLACK_GOLD = 4;\nconst int PEARL = 5;\nconst int BLACK_GLASS = 6;\nconst int RUBY = 7;\n\n// primitives:\n\nfloat sphere(vec3 p, vec3 o, float r) {\n\treturn length(p - o) - r;\n}\n\nfloat capsule(vec3 p, vec3 a, vec3 b, float r) {\n\tvec3 ab = b - a;\n\tvec3 ap = p - a;\n\tfloat t = dot(ab, ap) / dot(ab, ab);\n\tt = clamp(t, 0.0, 1.0);\n\tvec3 c = a + t * ab;\n\treturn length(p - c) - r;\n}\n\nfloat cylinder(vec3 p, vec3 a, vec3 b, float r) {\n\tvec3 ab = b - a;\n\tvec3 ap = p - a;\n\tfloat t = dot(ab, ap) / dot(ab, ab);\n\tvec3 c = a + t * ab;\n\tfloat x = length(p - c) - r;\n\tfloat y = (abs(t - 0.5) - 0.5) * length(ab);\n\tfloat e = length(max(vec2(x, y), 0.0)); // exterior distance\n\tfloat i = min(max(x, y), 0.0); // interior distance\n\treturn e + i;\n}\n\nfloat cylinder(vec3 p, vec3 b, float h, float r) {\n\treturn cylinder(p, b, vec3(b.x, b.y + h, b.z), r);\n}\n\nfloat box(vec3 p, vec3 s) {\n    p = abs(p) - s;\n\treturn length(max(p, 0.0)) + min(max(p.x, max(p.y, p.z)), 0.0);\n}\n\n// objects:\n\nfloat pawn(vec3 p, vec3 b) {\n    float y = b.y + 1.5 - p.y;\n    float base = cylinder(p, vec3(b.x, b.y, b.z), 0.05, 0.365) / 2.2;\n    float belly = cylinder(p, vec3(b.x, b.y + 0.3, b.z), - 0.3,\n        0.35 * (sin(y * 6.0 - 0.1) + 0.03)\n    );\n    float neck = cylinder(p, vec3(b.x, b.y + 0.775, b.z), - 0.04, 0.26 * y);\n    float separator = cylinder(p, vec3(b.x, b.y + 0.33, b.z), vec3(b.x, b.y + 0.29, b.z), 0.275);\n    float body = capsule(p, vec3(b.x, b.y + 1.0, b.z), vec3(b.x, b.y + 0.3, b.z),\n        (p.y < b.y || p.y > b.y + 1.5) ? 0.0 : clamp(0.25 * pow(y * 0.8, 2.4), 0.0, 1.5)\n\t);\n    float head = sphere(p, vec3(b.x, b.y + 1.0, b.z), 0.22);\n    return min(base, min(head, min(neck, min(separator, min(body, belly)))));\n}\n\n// scene:\n\nobj scene(vec3 p) {\n    obj m = vec2(10000000.0);\n    int n = 8, h = n / 2;\n    \n    while (n-- > 0) {\n        float _p = pawn(p, vec3(\n            1.26 - float(n % h),\n            n < h ? -1.0 : 0.5, // y\n            0 // z\n        ));\n        if (_p < m[DISTANCE]) {\n            m[DISTANCE] = _p;\n            m[MATERIAL] = float(n);\n        }\n    }\n    return m;\n}\n\nconst int   MAX_STEPS = 100;\nconst float MAX_DIST  = 100.0;\nconst float SURF_DIST = 0.01;\n\nobj march(in vec3 ro, in vec3 rd, float side) {\n\tfloat d0 = 0.0;\n    obj ds = obj(0.0);\n\tfor (int i = 0; i < MAX_STEPS; i++) {\n\t\tvec3 p = ro + rd * d0;\n\t\tds = scene(p) * side; // outside or inside (1, -1)\n\t\td0 += ds[DISTANCE];\n\t\tif (d0 >= MAX_DIST || abs(ds[DISTANCE]) <= SURF_DIST) break;\n\t}\n\treturn obj(d0, ds[MATERIAL]);\n}\n\nvec3 normal(vec3 p) {\n\tfloat d = scene(p)[DISTANCE];\n\tvec2 e = vec2(0.01, 0.0);\n\tvec3 n = d - vec3(\n\t\tscene(p - e.xyy)[DISTANCE],\n\t\tscene(p - e.yxy)[DISTANCE],\n\t\tscene(p - e.yyx)[DISTANCE]\n\t); // n is a point close to p;\n\treturn normalize(n);\n}\n\nvec3 direction(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l - p),\n         r = normalize(cross(vec3(0, 1, 0), f)),\n         u = cross(f, r),\n         c = f * z,\n         i = c + uv.x * r + uv.y * u;\n    return normalize(i);\n}\n\nmat2 rotation(float a) {\n    float s = sin(a), c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\nvec3 reflection(vec3 rd, vec3 n, float d, vec3 color) {\n    vec3 r = reflect(rd, n);\n    vec3 t = texture(iChannel0, r).rgb;\n    return vec3(d) * t * color;\n}\n\n// reflection with chromatic aberration:\nvec3 reflection(vec3 rd, vec3 n, float d, vec3 color, float ca) {\n    vec3 t;\n    t.r = texture(iChannel0, reflect(rd - ca, n)).r;\n    t.g = texture(iChannel0, reflect(rd, n)).g;\n    t.b = texture(iChannel0, reflect(rd + ca, n)).b;\n    return vec3(d) * t * color;\n}\n\nvec3 refraction(vec3 p, vec3 rd, vec3 n, float ior, float d) {\n    vec3 reflo = texture(iChannel0, reflect(rd, n)).rgb; // reflection outside\n    vec3 ri = refract(rd, n, 1.0 / ior);    // refraction inside\n    vec3 e = p - n * SURF_DIST * 3.0;       // enter point\n    float i = march(e, ri, -1.0)[DISTANCE]; // raymarch the inside\n    e = e + ri * i;                         // exit point\n    vec3 en = - normal(e);                  // exit normal\n\n    vec3 ro, t = vec3(0);\n    // total internal reflection with chromatic aberation \n    // dot(ro, ro) is like length(ro) or x = 0 & y = 0 & z = 0\n    const float ca = 0.01;                  // chromatic aberration\n    \n    // red split:\n    ro = refract(ri, en, ior - ca); // refraction outside\n    t.r = texture(iChannel0,\n        dot(ro, ro) == 0.0 ? reflect(ri, en) : ro\n    ).r;\n    \n    // green split:\n    ro = refract(ri, en, ior); // refraction outside\n    t.g = texture(iChannel0,\n        dot(ro, ro) == 0.0 ? reflect(ri, en) : ro\n    ).g;\n    \n    // blue split:\n    ro = refract(ri, en, ior + ca); // refraction outside\n    t.b = texture(iChannel0,\n        dot(ro, ro) == 0.0 ? reflect(ri, en) : ro\n    ).b;\n\n    t *= exp(-i * d); // add density and color\n    \n    // outside reflection\n    float fresnel = pow(1.0 + dot(rd, n), 5.0);\n\n    return mix(t, reflo, fresnel);\n}\n\nfloat random(float co) { return fract(sin(co * (91.3458)) * 47453.5453); }\nfloat random(vec2 co) { return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453); }\nfloat random(vec3 co) { return random(co.xy + random(co.z)); }\n\nvec3 fragment(in vec2 uv) {\n    vec2 m = iMouse.xy / iResolution.xy;\n    vec3 ro = vec3(0, 3, - 4);\n    ro.yz *= rotation(- m.y * 3.14 - 0.5);\n    ro.xz *= rotation(- m.x * 6.2831 + sin(iTime / 9.5) * 3.0);\n    vec3 rd = direction(uv, ro, vec3(0, 0.5, 0), 1.0);\n    obj d = march(ro, rd, 1.0);\n    vec3 color = texture(iChannel0, rd).rgb;\n    if (d[0] < MAX_DIST) {\n        vec3 p = ro + rd * d[DISTANCE];\n        vec3 n = normal(p);\n        float diffuse = dot(n, normalize(vec3(1, 2, 3))) * 0.5 + 0.5;\n        switch (int(d[MATERIAL])) {\n            case BLACK_GOLD: color = reflection(rd, n, diffuse, vec3(0.08)); break;\n            case GOLD:\n                color = reflection(rd, n, diffuse, vec3(\n                    1.0 - 0.1 * abs(sin(p.x) / 2.0), // red\n                    1.0 - 0.5 * abs(cos(p.y)), // green\n                    0 // blue\n                ));\n            break;\n            case SILVER: color = reflection(rd, n, diffuse, vec3(0.8)); break;\n            case BLACK_GLASS: {\n                const float ior = 1.45; // glass index of refraction\n                color = refraction(p, rd, n, ior, 1.0) * 0.1;\n            } break;\n            case GLASS: {\n                const float ior = 1.45; // glass index of refraction\n                color = refraction(p, rd, n, ior, 0.1);\n            } break;\n            case OPAQUE_GLASS: {\n                const float ior = 1.45; // glass index of refraction\n                //n *= 0.5 + sin(iTime) * 0.5; // disappearing glass\n                rd *= 2.0;\n                color = refraction(p, rd, n, ior, 0.1);\n                color += reflection(rd, n, diffuse, vec3(1)) * 0.8;\n                color /= 2.0;\n                color += 0.2;\n            } break;\n            case PEARL: {\n                const float ior = 1.45; // glass index of refraction\n                rd *= 2.0;\n                // pearl is just reflection with high chromatic aberration:\n                color = reflection(rd, n, diffuse, vec3(1), 0.2);\n                color += 0.2;\n            } break;\n            case RUBY: {\n                const float ior = 1.7; // index of refraction\n                color = vec3(0.7, 0, 0);\n                color *= refraction(p, rd, n, ior, 0.8);\n            } break;\n        }\n    }\n    color = pow(color, vec3(0.4545)); // gamma correction\n\treturn color;\n}\n\nvoid mainImage(out vec4 color, in vec2 coord) {\n\tvec2 uv = (coord - 0.5 * iResolution.xy) / iResolution.y;\n\tcolor = vec4(fragment(uv), 1.0);\n}\n\n#undef obj\n","name":"Image","description":"","type":"image"}]}