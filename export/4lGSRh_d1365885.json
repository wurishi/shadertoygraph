{"ver":"0.1","info":{"id":"4lGSRh","date":"1482868029","viewed":545,"name":"2D Lighting with SDFs","username":"ZeBestNickname","description":"Primary intent was to learn how to do 2d lighting with signed distance fields. Added some lights and music to make it look less boring","likes":8,"published":1,"flags":32,"usePreview":0,"tags":["2dlighting"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sXGzn","filepath":"/media/a/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3","previewfilepath":"/media/ap/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3","type":"music","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define EPSILON 0.00001\n#define CHECKER_SIZE = 100;\n\n#define NEIGHBOURHOOD_SIZE 4\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float ambient = 0.3;\n    float aspect = max(iResolution.x, iResolution.y);\n    \n    float half_y = iResolution.y / (aspect * 2.0);\n    float half_x = iResolution.x / (aspect * 2.0);\n    \n    \n    vec2 LIGHT_POS_1 = vec2(half_x + cos(iTime) / 2.0, half_y);\n    vec2 LIGHT_POS_2 = vec2(0.33, half_y + cos(iTime) / 3.0);\n    vec2 LIGHT_POS_3 = vec2(0.66, half_y - cos(iTime) / 3.0);\n    \n    vec4 LIGHT_COL_1 = vec4(0.9, 0.9, 0.05, 0.1);\n    vec4 LIGHT_COL_2 = vec4(0.9, 0.05, 0.9, 0.1);\n    vec4 LIGHT_COL_3 = vec4(0.05, 0.9, 0.9, 0.1);\n    \n\tvec2 uv = fragCoord.xy / aspect;\n    \n    vec2 pixel_size = vec2(1.0, 1.0) / aspect;\n\t\n    vec2 checker_res = iResolution.xy / 100.0;\n    vec2 div = uv / checker_res;\n    \n    bool black = mod(fragCoord.x, 10.0) <= 1.0 || mod(fragCoord.y, 10.0) <= 1.0;\n    vec4 final_col = black ? vec4(0.4, 0.4, 0.4, 1.0) : vec4(0.9, 0.9, 0.9, 1.0);\n    final_col *= ambient;\n    \n    vec4 curr_d = texture(iChannel0, uv);\n    \n    float d = curr_d.x;\n    float d_to_light1 = length(uv - LIGHT_POS_1);\n    float d_to_light2 = length(uv - LIGHT_POS_2);\n    float d_to_light3 = length(uv - LIGHT_POS_3);\n    \n    float obs_max = length(pixel_size) * 3.0;\n    float obs_t = min(obs_max, abs(d)) / obs_max;\n    \n    vec4 obstacle_col = (1.0 - obs_t) * vec4(0.1, 0.1, 0.1, 1.0) + obs_t * vec4(0.6, 0.1, 0.1, 1.0);\n\n    final_col = d <= EPSILON ? obstacle_col : final_col;\n    \n    float counter_l1 = 0.0;\n    float counter_l2 = 0.0;\n    float counter_l3 = 0.0;\n\n    for(int x = -NEIGHBOURHOOD_SIZE; x <= NEIGHBOURHOOD_SIZE; ++x){\n        for(int y = -NEIGHBOURHOOD_SIZE; y <= NEIGHBOURHOOD_SIZE; ++y){\n            vec4 tex = texture(iChannel0, uv + vec2(x, y) * pixel_size);\n            counter_l1 += tex.y;\n            counter_l2 += tex.z;\n            counter_l3 += tex.w;\n        }\n    }\n    \n    vec2 sound_pixel_size = vec2(1.0, 1.0) / vec2(512.0, 2.0);\n    \n    float l1_intensity = texture(iChannel1, vec2(0.0, 0.0) * sound_pixel_size).x;\n    float l2_intensity = texture(iChannel1, vec2(150.0, 0.0) * sound_pixel_size).x;\n    float l3_intensity = texture(iChannel1, vec2(300, 0.0) * sound_pixel_size).x;\n    \n    vec4 lit_l1 = LIGHT_COL_1 * max(0.0, min(1.0, (0.2 * l1_intensity * l1_intensity) / sqrt(d_to_light1)));\n    vec4 lit_l2 = LIGHT_COL_2 * max(0.0, min(1.0, (0.2 * l2_intensity) / sqrt(d_to_light2)));\n    vec4 lit_l3 = LIGHT_COL_3 * max(0.0, min(1.0, (0.2 * l3_intensity) / sqrt(d_to_light3)));\n\n    vec4 unlit = final_col * ambient;\n    \n    float tot = float((NEIGHBOURHOOD_SIZE * 2 + 1) * (NEIGHBOURHOOD_SIZE * 2 + 1));\n    \n    float t1 = counter_l1 / tot;\n    float t2 = counter_l2 / tot;\n    float t3 = counter_l3 / tot;\n\n    vec4 c1 = t1 * lit_l1;\n    vec4 c2 = t2 * lit_l2;\n    vec4 c3 = t3 * lit_l3;\n\n    fragColor = final_col + c1 + c2 + c3;\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define MAX_ITERATIONS 75\n#define EPSILON 0.00001\n\nfloat circleSDF(vec2 p, vec2 center, float rad){\n\treturn length(p - center) - rad;\n}\n\nfloat squareSDF(vec2 p, vec2 b)\n{\n  \tvec2 d = abs(p) - b;\n  \treturn min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\nfloat scene(vec2 p){\n    p.y += iTime * 0.2;\n    \n    float orig_x = p.x;\n\n    vec2 c = vec2(0.33, 0.33);\n    p = mod(p, c) - 0.5 * c ;\n    \n    vec2 rotated_p;\n    \n    float theta = 0.0;\n    \n    if(orig_x < 0.33){\n        theta = iTime;\n    }\n    else if(orig_x > 0.66){\n        theta = -iTime;;\n    }\n\n    rotated_p.x = p.x * cos(theta) - p.y * sin(theta);\n    rotated_p.y = p.y * cos(theta) + p.x * sin(theta);\n    \n    float square_offset = 0.05 * sin(iTime);\n    float d = squareSDF(vec2(rotated_p.x, rotated_p.y + square_offset), vec2(0.06, 0.02));\n    \n    d = max(-d, circleSDF(p, vec2(0.0, 0.0), 0.05));\n    //d = circleSDF(p, vec2(0.0, 0.0), 0.05);\n    \n    return d;\n}\n\nbool pathToLight(vec2 p, vec2 lp, out float d){\n    float d_to_light = length(lp - p);\n\tvec2 dir = normalize(lp - p);\n    \n    \n    float curr_d = scene(p);\n    d = curr_d;\n    \n    vec2 curr_pos = p + dir * curr_d;\n    \n    for(int i = 0; i < MAX_ITERATIONS; ++i){\n        float curr_length = length(curr_pos - p);\n        \n        if(curr_length > d_to_light){\n        \treturn true;\n        }\n        \n        if(curr_d <= EPSILON){\n        \treturn false;\n        }\n        \n        curr_d = scene(curr_pos);\n        curr_pos = curr_pos + dir * curr_d;\n    }\n    \n    return true;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    float aspect = max(iResolution.x, iResolution.y);\n    \n    float half_y = iResolution.y / (aspect * 2.0);\n    float half_x = iResolution.x / (aspect * 2.0);\n    \n    vec2 LIGHT_POS_1 = vec2(half_x + cos(iTime) / 2.0, half_y);\n    vec2 LIGHT_POS_2 = vec2(0.33, half_y + cos(iTime) / 3.0);\n    vec2 LIGHT_POS_3 = vec2(0.66, half_y - cos(iTime) / 3.0);\n    \n    float d;\n    \n    bool path1 = pathToLight(uv, LIGHT_POS_1, d);\n    bool path2 = pathToLight(uv, LIGHT_POS_2, d);\n    bool path3 = pathToLight(uv, LIGHT_POS_3, d);\n    \n    fragColor = vec4(d, path1 ? 1.0 : 0.0, path2 ? 1.0 : 0.0, path3 ? 1.0 : 0.0);\n}","name":"Buf A","description":"","type":"buffer"}]}