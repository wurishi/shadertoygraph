{"ver":"0.1","info":{"id":"ldyyRD","date":"1521175491","viewed":126,"name":"Green Hills (Raymarch)","username":"Isaac175","description":"This is my first GLSL shader ever, so I don't really know if it's working right or not :\\ Anyway, hope you enjoy! Btw, It'd be great if you could help me clean up my code. Thanks!","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["raymarch","laggy","firstpost"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Name: Kinda Failed Raymarcher?\n// (c) Isaac C. 2018. (you can use any functions here, just do something different with them)\n\n#ifdef GL_ES\nprecision lowp float;\n#endif\n\n#define PI 3.14159265358979\n#define ACCELI 4.\n#define ELI 4.\n#define QUALITY 16\n\n// 1/(1+2^x)\n//--------------------------------------------------\n// hash function\nvec3 hash3( vec2 p ) {\n    vec3 q = vec3( dot(p,vec2(127.1,311.7)),\n                   dot(p,vec2(269.5,183.3)),\n                   dot(p,vec2(419.2,371.9)) );\n    return fract(sin(q)*43758.5453);\n}\n//--------------------------------------------------\n// iqnoise //original algorithm by Íñigo Quílez\nfloat iqnoise( in vec2 x) {\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n    float k = 1.;\n    float va = 0.0;\n    float wt = 0.0;\n    for (int j=-2; j<=2; j++) {\n        for (int i=-2; i<=2; i++) {\n            float ww = pow( 1.0-smoothstep(0.0,1.414,\n                    sqrt(dot(vec2(float(i),float(j)) - f +\n                   hash3(p + vec2(float(i),float(j))).xy,\n                             vec2(float(i),float(j)) - f +\n                   hash3(p + vec2(float(i),float(j))).xy))), k );\n            va +=  hash3(p + vec2(float(i),float(j))).z*ww;\n            wt += ww;\n        }\n    }\n    return va/wt;\n}\n//--------------------------------------------------\n//fbm\nfloat fbm (in vec2 x) {\n\tfloat f = 0.;\n    float w = .5;\n    for (int i=0; i<5; i++) {\n        f += w*iqnoise(x*1.5/*+u_time*/); x *= 2.05;\n        w *= .5;\n    }\n    return f;\n}\n//--------------------------------------------------\n// sdSphere\nfloat sdSphere(in vec3 p, in float size)\n{\n  return length(p)-size;\n}\n//--------------------------------------------------\n// sdNoisePlane\n// The part that generates the texture for the plane\nfloat sdPlaneN(in vec3 p, in float height, in float nHeight, in vec2 nSeed) {\n    return p.z-((fbm(vec2(p/*+u_time/5.*/))*nHeight)+height);\n\t// p.x+0./*u_time/*nSeed.x*/,p.y+u_time/10./*nSeed.y*/\n}\n// The way this works is interesting\n// it checks whether or not it is within range of the texture,\n// and if it is, it then returns the texture height\nfloat sdPlane(in vec3 p, in float height, in float nHeight, in vec2 nSeed) {\n    if (0.>p.z-(height+nHeight)) {\n        return sdPlaneN(p,height,nHeight, nSeed);\n    }\n    return p.z-(height+nHeight);\n}\n//--------------------------------------------------\n// converting radian trig functions to degrees\n// sin\nfloat degSin(in float x) {\n    return sin(x*PI/180.);\n}\n// cos\nfloat degCos(in float x) {\n    return cos(x*PI/180.);\n}\n//--------------------------------------------------\n// sigmoid\nfloat sigmoid(in float x) {\n    return 2./(1.+pow(1.05,x));\n}\n//--------------------------------------------------\n// cast ray\nfloat castRay(in vec3 cam, in vec2 uv) {\n    float distance = 0.; // distance from the camera\n    float radius = 0.; // distance from nearest shape\n    float oRadius = radius;\n    vec3 p = cam;\n    uv = uv*2.-2.; // adjusting the viewing fulcrum\n    vec3 mult = vec3(degSin(uv.x), // finding out the slope rates\n                     degCos(uv.x),\n                     degSin(uv.y));\n    for (int i = 0; i < QUALITY; i++) {\n        oRadius = radius;\n        radius = sdPlane(p,-2.,1.,vec2(0.,0.)); // finding the distance to the plane\n        if (radius < 0.) {\n            for (int j = 0; j < 1; j++) {\n                oRadius = abs(oRadius) * .5;\n                radius = sdPlane(p,-2.,1.,vec2(0.,0.)); // finding the distance to the plane\n                if (radius < 0.) {\n                    oRadius *= -1.;\n                }\n                distance += oRadius; // getting closer to 0\n                p = cam+(mult*distance); // moving the point\n                if (abs(radius) < ACCELI) {\n                    //return 1.-float(i+j)/float(QUALITY);\n                    return sigmoid(distance); // returns more 'exact' distance\n                }\n            }\n            //return 1.-float(i+8)/float(QUALITY);\n        \treturn sigmoid(distance);\n        }\n\t\t    if (radius < ELI) {\n            radius = ELI;\n        }\n        distance += radius;\n        p = cam+(mult*distance);\n    }\n\treturn 0.;\n}\n//--------------------------------------------------\n// main loop\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 st = ((iMouse.xy/iResolution.xy)-1.)*2.;\n    st = vec2(st.x,st.y/1.5);\n    vec2 uv = fragCoord.xy/iResolution.xy;\n\tfloat x = castRay(vec3(st.x,iTime/10.,st.y+.15),uv);\n    //x = fbm(uv);\n    fragColor = vec4(0.,x,x/2.,1.0);\n}\n","name":"Image","description":"","type":"image"}]}