{"ver":"0.1","info":{"id":"7tXcRj","date":"1649882566","viewed":190,"name":"Procedurally generated landscape","username":"5197denis","description":"Terrain raymarching + atmosphere + clouds","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","terrain","sdf","clouds","landscape","scattering","atmosphere","rayleigh","ridgedmultifractal","mie"],"hasliked":0,"parentid":"fs2yW3","parentname":"Terrain + Atmos + Clouds"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Author: Denis Leitner\n// Title: Procedurally generated landscape in fragment shader\n// Master Thesis \n// VUT FIT Brno, 2022\n\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n//#define LOW_QUALITY\n\n// ============= Performance/quality tweaking parameters =================== \n\n#ifndef LOW_QUALITY\n// default quality\n\n    // terrain rendering\n    #define MAX_RENDERING_DISTANCE 150.0e3\n    #define MAX_MARCHING_STEPS 400\n    #define MAX_MARCHING_STEPS_SHADOW 100\n    \n    // texturing\n    #define TEXTURE_LOW_QUALITY 0\n    #define TEXTURE_FILTERING 0\n    #define FILTERING_SAMPLES 4\n    \n    // atmosphere rendering\n    #define ATMOS_STEPS 64\n    #define ATMOS_LIGHT_STEPS 16\n    \n    // cloud rendering\n    #define CLOUD_STEPS 64\n    #define CLOUD_LIGHT_STEPS 6\n    \n#else\n// low quality - no clouds\n\n    // terrain rendering\n    #define MAX_RENDERING_DISTANCE 75.0e3\n    #define MAX_MARCHING_STEPS 300\n    #define MAX_MARCHING_STEPS_SHADOW 80\n    \n    // texturing\n    #define TEXTURE_LOW_QUALITY 1\n    #define TEXTURE_FILTERING 0\n    #define FILTERING_SAMPLES 4\n    \n    // atmosphere rendering\n    #define ATMOS_STEPS 24\n    #define ATMOS_LIGHT_STEPS 8\n    \n    // cloud rendering\n    #define CLOUD_STEPS 0\n    #define CLOUD_LIGHT_STEPS 0\n#endif\n\n// ========================================================================== \n\n\n\n// ====================== Cloud params ===================================\n\n#define CLOUDS_SCALE 0.1e-3\n#define CLOUDS_HEIGHT 8000.0\n#define CLOUDS_SPEED vec3(0.25, 0.037, 0.0)*0.5\n#define CLOUDS_THICKNESS 3500.0\n#define CLOUD_SMOOTHNESS 0.65\n#define CLOUD_COVERAGE 0.5\n#define DENSITY 1.0\n#define ABSORPTION 5.e-5\n#define SCATTERING 7.e-4\n#define SUN_INTENSITY_CLOUDS 20.0\n#define AMBIENT_LIGHT_STRENGTH_CLOUDS 5.0\n\n\n// energy conservative scattering integration based on https://www.shadertoy.com/view/XlBSRz\n// bool (0 | 1)\n#define IMPROVED_INTEGRATION 1\n\n// randomly offsets starting position of the ray to eliminate banding artefacts\n// bool (0 | 1)\n#define RANDOM_RAY_OFFSET 1\n\n// Clouds phase function params\n#define FORWARD_SCATTERING_G 0.8\n#define BACKWARD_SCATTERING_G 0.5\n#define INTERPOLATION 0.5\n\n// ========================================================================\n\n\n// ====================== Terrain params ==================================\n\n// === Ridged fractal ===\n#define SCALE 0.075e-3\n#define TERRAIN_OFFSET vec2(12.5e3, 37.1e3)\n#define TERRAIN_AMPLITUDE 4.4e3 \n#define SMOOTHNESS 1.3\n#define SMOOTH_RIDGES 1\n\n// === Hybrid fractal ===\n/*#define SCALE 0.1e-3\n#define TERRAIN_OFFSET vec2(12.5e3, 37.1e3)\n#define TERRAIN_AMPLITUDE 2.3e3\n#define SMOOTHNESS 0.25*/\n\n#define OCTAVES 10\n#define OCTAVES_SHADOW 7\n#define OCTAVES_NORMAL 12\n\n// ========================================================================\n\n\n// bool (0 | 1)\n#define MOVING_CAM 1\n#define CAM_HEIGHT 2300.0\n#define CAM_SPEED  1200.0\n\n#define CAM_ANGLE_Y radians(-15.0)\n#define CAM_ANGLE_X radians(90.0)\n\nconst vec3 CamDir = normalize( vec3(sin(CAM_ANGLE_X)*cos(CAM_ANGLE_Y), \n                                   sin(CAM_ANGLE_Y),\n                                   cos(CAM_ANGLE_X)*cos(CAM_ANGLE_Y) ));\n\n// =================== Sun position in the sky =============================\n\n#define SUN_ANGLE_Y radians(25.0)\n#define SUN_ANGLE_X radians(-145.0)\n\n// ========================================================================\n\n\nconst float SunIntensityGround = 1.5; // 1.5 - (0.7*CLOUD_COVERAGE);\nconst vec3 Light = normalize( vec3(sin(SUN_ANGLE_X)*cos(SUN_ANGLE_Y), \n                                   sin(SUN_ANGLE_Y),\n                                   cos(SUN_ANGLE_X)*cos(SUN_ANGLE_Y) ));\n\n// rendering consts\n#define MIN_DIST 0.001\n#define SHADOW_SOFTNESS 32.0 \n\n#define FAR_PLANE (MAX_RENDERING_DISTANCE)\n#define NEAR_PLANE 1.0\n\n#define PI 3.14159\n#define PI2 6.28318531\n#define FLT_MAX 3.402823466e+38\n\n// Trick by Inigo Quilez to prevent loop unrolling\n// decreases compilation time and might increases performance on some GPUs\n// see comment section in https://www.shadertoy.com/view/4ttSWf\n#define ZERO (min(iFrame,0))\n\nvec3 camPosition;\nvec2 pixelCoord;\n\nstruct Sphere\n{\n\tvec3 center;\n\tfloat radius;\n};\n\nstruct Ray\n{\n\tvec3 origin;\n\tvec3 dir;\n};\n\nstruct Atmosphere\n{\n    float planetRadius;\n    float atmosphereRadius;\n    vec3 scatteringR;\n    vec3 scatteringM;\n    \n    // atmosphere thickness if atmosphere was uniform density \n    float Hr;  // for Rayleigh scattering\n    float Hm;  // for Mie scattering\n};\n\n// Rayleigh scattering coefficients \n// for rgb wavelengths at sea level [m^(-1)]\nconst vec3 scatteringR = vec3(5.5e-6, 13.5e-6, 33.1e-6); \n\n// Mie scattering coefficients \n// for rgb wavelengths at sea level [m^(-1)]\nconst vec3 scatteringM = vec3(21e-6);\n\n// Mie extinction coefficients\n// for rgb wavelengths at sea level [km^(-1)]\nconst vec3 extinctionM = scatteringM*1.1;\n\n// scale height values for Rayleigh and Mie scattering\nconst float Hr = 8e3;\nconst float Hm = 1.2e3;\n\n#define PLANET_RADIUS 6360e3\n#define ATMOSPHERE_RADIUS 6420e3\n\n// Credit: https://jcgt.org/published/0009/03/02/\n// hash function for generating 32-bit unsigned integers\nuint hashPCGu(uint x)\n{\n    uint state = x * 747796405u + 2891336453u;\n    uint word = ((state >> ((state >> 28u) + 4u)) ^ state) * 277803737u;\n    return (word >> 22u) ^ word;\n}\n\n#define UINT_MAX float(0xffffffffu)\n\nfloat hashPCG(vec2 x)\n{\n    x += 3250000.;\n    x = abs(x);\n    uvec2 p = uvec2(floor(x));\n    return float(hashPCGu(149u*p.x ^ 233u*p.y)) / UINT_MAX;\n    //return float(hashPCGu(p.x + hashPCGu(p.y))) / UINT_MAX;\n}\n\n// Generates 2D vector for gradient noise\nvec2 gradientPCG(vec2 x)\n{\n    //x += 3250000.;\n    x = abs(x);\n    uvec2 p = uvec2(floor(x));\n    \n#if 1\n    float valX = float(hashPCGu(149u*p.x ^ 233u*p.y));\n    float valY = float(hashPCGu(97u*p.x ^ 193u*p.y));\n#else    \n    float valX = float(hashPCGu(p.x + hashPCGu(p.y)));\n    float valY = float(hashPCGu(97u*p.x + hashPCGu(193u*p.y)));\n#endif\n\n    return normalize((vec2(valX, valY)/UINT_MAX)*2.-1.);\n}\n\nfloat hashPCG(vec3 x)\n{\n    x += 3250000.;\n    x = abs(x);\n    uvec3 p = uvec3(floor(x));\n    return float(hashPCGu(149u*p.x ^ 233u*p.y ^ 157u*p.z)) / UINT_MAX;\n}\n\n\n// Credit: https://www.shadertoy.com/view/4dXBRH\n// Returns value and a derivative of a value noise for given point\nvec3 vnoised(vec2 p)\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\n    // quintic interpolation\n    vec2 u = f*f*f*(f*(f*6.0-15.0)+10.0);\n    vec2 du = 30.0*f*f*(f*(f-2.0)+1.0); \n    \n    float va = hashPCG( i + vec2(0.0,0.0) );\n    float vb = hashPCG( i + vec2(1.0,0.0) );\n    float vc = hashPCG( i + vec2(0.0,1.0) );\n    float vd = hashPCG( i + vec2(1.0,1.0) );\n\n    float k0 = va;\n    float k1 = vb - va;\n    float k2 = vc - va;\n    float k4 = va - vb - vc + vd;\n\n    return vec3( va+(vb-va)*u.x+(vc-va)*u.y+(va-vb-vc+vd)*u.x*u.y, // value\n                 du*(u.yx*(va-vb-vc+vd) + vec2(vb,vc) - va) );     // derivative  \n}\n\n// Credit: https://www.shadertoy.com/view/4dXBRH\n// Returns value noise in range <0; 1> for given point\nfloat vnoise(vec2 p)\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\n    // quintic interpolation\n    vec2 u = f*f*f*(f*(f*6.0-15.0)+10.0);\n    \n    float va = hashPCG( i + vec2(0.0,0.0) );\n    float vb = hashPCG( i + vec2(1.0,0.0) );\n    float vc = hashPCG( i + vec2(0.0,1.0) );\n    float vd = hashPCG( i + vec2(1.0,1.0) );\n    \n    float k0 = va;\n    float k1 = vb - va;\n    float k2 = vc - va;\n    float k4 = va - vb - vc + vd;\n\n    return (va+(vb-va)*u.x+(vc-va)*u.y+(va-vb-vc+vd)*u.x*u.y);\n}\n\n// Credit: https://www.shadertoy.com/view/4dXBRH\n// Returns value noise in range <-1; 1> for given point\nfloat vnoise2(vec2 p)\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\n    // quintic interpolation\n    vec2 u = f*f*f*(f*(f*6.0-15.0)+10.0);\n\n    float va = hashPCG( i + vec2(0.0,0.0) )*2.0 - 1.0;\n    float vb = hashPCG( i + vec2(1.0,0.0) )*2.0 - 1.0;\n    float vc = hashPCG( i + vec2(0.0,1.0) )*2.0 - 1.0;\n    float vd = hashPCG( i + vec2(1.0,1.0) )*2.0 - 1.0;\n    \n    float k0 = va;\n    float k1 = vb - va;\n    float k2 = vc - va;\n    float k4 = va - vb - vc + vd;\n\n    return (va+(vb-va)*u.x+(vc-va)*u.y+(va-vb-vc+vd)*u.x*u.y);\n}\n\n// Credit: https://goeden.tistory.com/131\nvec2 random(vec2 st){\n    float x = fract(sin(dot(st*25., vec2(17.34,50.13)))*84239.523);\n    float y = fract(cos(dot(st*25., vec2(28.13,39.49)))*94820.475);\n  \n    return vec2(x, y) *2. -1.; // range -1 ~ 1\n}\n\n// Credit: https://goeden.tistory.com/131\nfloat gnoise(vec2 st)\n{\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n    \n    vec2 v1 = i;\n    vec2 v2 = i + vec2(1., 0.);\n    vec2 v3 = i + vec2(0., 1.);\n    vec2 v4 = i + vec2(1., 1.);\n    \n#if 0\n    vec2 r1 = random(v1);\n    vec2 r2 = random(v2);\n    vec2 r3 = random(v3);\n    vec2 r4 = random(v4);\n#else\n    vec2 r1 = gradientPCG(v1);\n    vec2 r2 = gradientPCG(v2);\n    vec2 r3 = gradientPCG(v3);\n    vec2 r4 = gradientPCG(v4);\n#endif\n    // f = smoothstep(0., 1., f);\n    f = f*f*f*(f*(f*6.-15.)+10.);\n    \n    float d1 = dot(r1, st-v1);\n    float d2 = dot(r2, st-v2);\n    float d3 = dot(r3, st-v3);\n    float d4 = dot(r4, st-v4);\n    \n    float bot = mix(d1, d2, f.x);\n    float top = mix(d3, d4, f.x);\n    float ret = mix(bot, top, f.y);\n    \n    return ret; // range -1 ~ 1\n}\n\n// Credit: https://www.shadertoy.com/view/XdXGW8\nvec2 grad( ivec2 z ) \n{\n    // 2D to 1D\n    int n = z.x+z.y*11111;\n\n    // Hugo Elias hash\n    n = (n<<13)^n;\n    n = (n*(n*n*15731+789221)+1376312589)>>16;\n\n    // Perlin style vectors\n    n &= 7;\n    vec2 gr = vec2(n&1,n>>1)*2.0-1.0;\n    return ( n>=6 ) ? vec2(0.0,gr.x) : \n           ( n>=4 ) ? vec2(gr.x,0.0) :\n                              gr;                          \n}\n\n// Credit: https://www.shadertoy.com/view/XdXGW8\nfloat gnoise1( in vec2 p )\n{\n    ivec2 i = ivec2(floor( p ));\n    vec2 f =  fract( p );\n\t\n\tvec2 u = f*f*(3.0-2.0*f);\n    //vec2 u = f*f*f*(f*(f*6.-15.)+10.);\n\n\n    return mix( mix( dot( grad( i+ivec2(0,0) ), f-vec2(0.0,0.0) ), \n                     dot( grad( i+ivec2(1,0) ), f-vec2(1.0,0.0) ), u.x),\n                mix( dot( grad( i+ivec2(0,1) ), f-vec2(0.0,1.0) ), \n                     dot( grad( i+ivec2(1,1) ), f-vec2(1.0,1.0) ), u.x), u.y);\n}\n\n// Value noise with 3D input\n// Credit: https://www.shadertoy.com/view/4sfGzS\nfloat vnoise3(vec3 x)\n{\n    vec3 i = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    return mix(mix(mix( hashPCG(i+vec3(0,0,0)), \n                        hashPCG(i+vec3(1,0,0)),f.x),\n                   mix( hashPCG(i+vec3(0,1,0)), \n                        hashPCG(i+vec3(1,1,0)),f.x),f.y),\n               mix(mix( hashPCG(i+vec3(0,0,1)), \n                        hashPCG(i+vec3(1,0,1)),f.x),\n                   mix( hashPCG(i+vec3(0,1,1)), \n                        hashPCG(i+vec3(1,1,1)),f.x),f.y),f.z);\n}\n\n// Computes fractional Brownian motion\nfloat fbm(vec2 p, int numOctaves, float H)\n{\n    float G = exp2(-H);\n    float f = 1.0;\n    float a = 1.0;\n    float t = 0.0;\n    \n    for( int i=0; i<numOctaves; i++ )\n    {\n        float n = vnoise(f*p);\n        t += a*n;\n        f *= 2.0;\n        a *= G;\n    }\n    return t;\n}\n\nfloat fbmRock(vec3 p, int numOctaves, float H)\n{\n    float f = 1.0;\n    float a = 0.5;\n    float t = 0.0;\n    \n    for( int i=ZERO; i<numOctaves; i++ )\n    {\n        float n = (-1.0 + 2.0*vnoise3(f*p));\n        //n *= n;\n        t += a*n;\n        f *= 2.;\n        a = pow(f, -H);\n    }\n    return 0.5+0.5*t;\n}\n\n// high quality rock texture\nvec3 rockTexture(vec3 p)\n{\n    const vec3 colRock = vec3(0.14, 0.1, 0.08);\n    \n    vec3 q = 0.5*vec3( fbmRock( p + vec3(0.0,0.0,0.0), 6, 0.5 ),\n                       fbmRock( p + vec3(7.3,11.37,17.91), 6, 0.5 ),\n                       fbmRock( p + vec3(5.2,1.3,3.7), 6, 0.5 ) );\n    \n    float rock = fbmRock(p + 4.0*q, 6, 0.5);\n    \n    vec3 col = 2.0*colRock*rock;\n    col = mix(col, vec3(0.15, 0.15, 0.15), dot(q.x,q.x));\n    col = mix(col, vec3(0.02, 0.02, 0.02), q.y*q.y);\n    //col = mix(col, vec3(0.3, 0.2, 0.2), 0.25*dot(q, q));\n    \n    return col;\n}\n\n// fast rock texture\nvec3 rockTextureLow(vec3 p)\n{\n    const vec3 colRock = vec3(0.14, 0.1, 0.08);\n    const int octaves = 7;\n    const float smoothness = 0.5;\n    float rock = fbmRock( p + vec3(0.0,0.0,0.0), octaves, smoothness);\n    \n    return rock*colRock;\n}\n\nfloat fbm2(vec2 p, int numOctaves, float H)\n{\n    float G = exp2(-H);\n    float f = 1.0;\n    float a = 1.0;\n    float t = 0.0;\n    \n    for( int i=0; i<numOctaves; i++ )\n    {\n        float n = vnoise2(f*p);\n        t += a*n;\n        f *= 2.0;\n        a *= G;\n    }\n    return t;\n}\n\nfloat fbmCloud(vec3 p)\n{\n    p = CLOUDS_SCALE*p + iTime*CLOUDS_SPEED+vec3(camPosition.x, 0.0, camPosition.z)*CLOUDS_SCALE;\n    float G = exp2(-CLOUD_SMOOTHNESS);\n    float f = 1.0;\n    float a = 0.5;\n    float t = 0.0;\n    \n    for( int i=ZERO; i<6; i++ )\n    {\n        float n = vnoise3(f*p);\n        t += a*n;\n        f *= 2.5789f;\n        a *= G;\n    }\n    \n    //t = clamp(1.0*t, 0.0, 1.0);\n    \n    t *= 0.6;\n    \n    float cov = 0.6 - 0.35*CLOUD_COVERAGE;\n    \n    t *= smoothstep (cov, cov+0.05, t);\n    //t = clamp(t, 0.0, 1.0);\n    \n    return t*DENSITY;\n}\n\nfloat hybridFractal(vec2 p, int numOctaves)\n{\n    const float H = SMOOTHNESS;\n    const float G = exp2(-H);\n    float f = 2.0;       // frequency of noise\n    float a = G;         // amplitude of noise\n    float t = 0.0;       // accumulated noise\n    \n    float n = vnoise(p);\n    t += n;\n    \n    float weight = n;\n        \n    for( int i=1; i<numOctaves; i++ )\n    {\n        weight = clamp(weight, 0.0, 1.0);\n        n = vnoise(f*p);\n        t += weight*a*n;\n        \n        f *= 2.0;        // doubling the frequency\n        a *= G;\n        weight *= n;\n    }\n    return t;\n}\n\nfloat hybridFractal1(vec2 p, int numOctaves)\n{\n    const float H = SMOOTHNESS;\n    const float G = exp2(-H);\n    float f = 1.0;       // frequency of noise\n    float a = pow(f, -H);         // amplitude of noise\n    float t = 0.0;       // accumulated noise\n    \n    // add first octave\n    t = a * vnoise(p);\n    float weight = t;\n    \n    for( int i=1; i<numOctaves; i++ )\n    {\n        weight = min(weight, 1.0);\n        \n        f *= 2.0;        // doubling the frequency\n        a = pow(f, -H); \n        \n        float n = a * vnoise(f*p);\n        t += weight*n;\n        weight *= n;\n    }\n    return t;\n}\n\nfloat hybridFractal2(vec2 p, int numOctaves)\n{\n    const float H = SMOOTHNESS;\n    const float offset = 0.7;\n    float f = 1.0;          // frequency of noise\n    float a = pow(f, -H);   // amplitude of noise\n    float result = 0.0;     // accumulated noise\n    \n    // add first octave\n    result = a * ( gnoise(p) + offset );\n    float weight = result;\n    \n    for( int i=1; i<numOctaves; i++ )\n    {\n        weight = min(weight, 1.0);\n        \n        f *= 2.0;        // doubling the frequency\n        a = pow(f, -H); \n        \n        float n = a * ( gnoise(f*p) + offset );\n        result += weight*n;\n        weight *= n;\n    }\n    return result;\n}\n\nfloat ridgedFractal(vec2 p, int numOctaves)\n{\n    const float offset = 1.0;\n    const float gain = 2.1;\n    float f = 1.0;       // frequency of the noise\n    float a = 1.0;       // amplitude of noise\n    float result = 0.0;  // accumulated noise\n    \n    // add first octave\n    float signal = abs(gnoise(p));\n    \n    const float smoothingEdge0 = -0.005;\n    const float smoothingEdge1 = 0.015;\n    \n    #if SMOOTH_RIDGES\n        // smooth out sharp ridges\n        signal *= smoothstep(smoothingEdge0, smoothingEdge1, signal);\n    #endif\n    signal = offset - signal;\n    signal *= signal;\n    \n    result = signal * a;\n    \n    float weight = 1.0;\n    \n    for( int i=1; i<numOctaves; i++ )\n    {\n        weight = signal * gain;\n        weight = clamp(weight, 0.0, 1.0);\n        \n        f *= 2.03;\n        a = pow(f, -SMOOTHNESS); \n        \n        signal = abs(gnoise(f*p));\n        \n        #if SMOOTH_RIDGES\n            // smooth out sharp ridges\n            signal *= smoothstep(smoothingEdge0, smoothingEdge1, signal);\n        #endif\n        \n        signal = offset - signal;\n        signal *= signal;\n            \n        signal *= weight;\n        result += signal * a;\n    }\n    return result;\n}\n\n// finds intersection of the ray with the sphere from outside the sphere\nfloat intersectRaySphereOutside(Ray ray, Sphere sphere)\n{\n\tvec3 oc = ray.origin - sphere.center;\n\tfloat a = dot(ray.dir, ray.dir);\n\tfloat b = dot(oc, ray.dir);\n\tfloat c = dot(oc, oc) - sphere.radius*sphere.radius;\n\tfloat discriminant = b*b - a*c;\n\tif (discriminant < 0.0)\n\t{\n\t\t// no intersection\n\t\treturn -1.0;\n\t}\n\telse\n\t{\n\t\tfloat t = (-b - sqrt(b*b - a*c)) / a;\n\t\tif (t > NEAR_PLANE)\n\t\t\treturn t;\n\t\telse\n\t\t\treturn -1.0;\n\t}\n}\n\n// finds intersection of the ray with the sphere from inside the sphere\nfloat intersectRaySphereInside(Ray ray, Sphere sphere)\n{\n\tvec3 oc = ray.origin - sphere.center;\n\tfloat a = dot(ray.dir, ray.dir);\n\tfloat b = dot(oc, ray.dir);\n\tfloat c = dot(oc, oc) - sphere.radius*sphere.radius;\n\tfloat discriminant = b*b - a*c;\n\tif (discriminant < 0.0)\n\t{\n\t\t// no intersection\n\t\treturn -1.0;\n\t}\n\telse\n\t{\n\t\tfloat t = (-b + sqrt(b*b - a*c)) / a;\n\t\tif (t > NEAR_PLANE)\n\t\t\treturn t;\n\t\telse\n\t\t\treturn -1.0;\n\t}\n}\n\nvec3 rayPointAtParameter(Ray r, float t)\n{\n\treturn (r.origin + r.dir*t);\n}\n\nfloat sphereSDF(vec3 center, float radius, vec3 point)\n{\n\treturn length(point - center) - radius;\n}\n\nfloat terrainMap(vec2 point, int octaves)\n{\n    point += camPosition.xz*SCALE;\n\n    //return hybridFractal2(vec2(point), octaves);\n    return ridgedFractal(vec2(point), octaves)-0.6;\n}\n\nfloat sceneSDF(vec3 point, bool shadow)\n{\n    float h = terrainMap( (point.xz+TERRAIN_OFFSET)*SCALE, (shadow ? OCTAVES_SHADOW : OCTAVES) );\n    h *= TERRAIN_AMPLITUDE;\n\n\tfloat dist = sphereSDF(vec3(0.0), PLANET_RADIUS+h, point);\n    //float dist = point.y - radius;  // flat planet\n\n    return dist;\n}\n\nvec3 estimateNormal(vec3 p, float epsilon, bool shading) {\n\tvec3 n;\n    p.xz += TERRAIN_OFFSET;\n    p.xz *= SCALE;\n    epsilon *= SCALE;\n    //epsilon = MinDist*0.5;\n    int numOctaves = shading ? OCTAVES_NORMAL : OCTAVES;\n\tn = vec3( terrainMap(vec2(p.x-epsilon, p.z), numOctaves) - terrainMap(vec2(p.x+epsilon, p.z), numOctaves), \n              2.0f*epsilon,\n              terrainMap(vec2(p.x,p.z-epsilon), numOctaves) - terrainMap(vec2(p.x,p.z+epsilon), numOctaves) );\n              \n\treturn normalize(n);\n}\n\nfloat softShadow(vec3 point, float epsilon, int steps)\n{\n\tRay r;\n\tr.dir = Light;\n\t//r.origin = point + r.dir*TERRAIN_AMPLITUDE*0.1;\n\tr.origin = point;\n\n\tfloat res = 1.0;\n    \n\tfloat depth = epsilon;\n    \n\tfor (int i = 0; i < steps; i++) \n\t{\n\t\tvec3 samplePoint = rayPointAtParameter(r, depth);\n\t\tfloat dist = sceneSDF(samplePoint, true);\n\t\tif (dist < epsilon) \n\t\t{\n\t\t\t// Point is in full shadow\n\t\t\treturn 0.0;\n\t\t}\n\t\tres = min(res, SHADOW_SOFTNESS*dist/depth);\n\n\t\t// Move along the shadow ray\n\t\tdepth += clamp(dist, 1.0+depth*0.1, 50.0);\n        //depth += clamp(dist, epsilon, 50.0);\n\n        if (res < 0.01)\n        {\n            break;\n        }\n\t}\n\treturn clamp(res, 0.0, 1.0);\n}\n\nfloat cubeTexture(vec3 p)\n{\n    vec3 a = fract(p);\n    \n    float x = smoothstep(0.05, 0.1,  a.x);\n    float y = smoothstep(0.05, 0.1,  a.y);\n    float z = smoothstep(0.05, 0.1,  a.z);\n    \n    return z*x;\n    return x*y*z;\n    \n}\n\nvec3 getTerrainTexture(vec3 point, vec3 N, float pointHeight)\n{\n    vec3 color = vec3(0.0);\n    \n    const vec3 colSnow = vec3(0.95, 0.95, 1.0);\n    const vec3 colGround = vec3(0.05, 0.2, 0.02);\n    \n    vec3 coordRock = (point)*SCALE*295.*1.0;\n    coordRock.xz *= 0.1;\n    coordRock.y *= 0.3;    // 0.8\n    \n    #if TEXTURE_LOW_QUALITY\n        coordRock *= 2.;\n        vec3 colRock = rockTextureLow(coordRock);\n    #else\n        vec3 colRock = rockTexture(coordRock);\n    #endif\n    \n    \n    float rand = fbm(point.xz*SCALE*75.7, 7, 0.5);\n    //float snow = smoothstep(0.15*rand, 0.5, N.y);\n    float snow = smoothstep(0.15*rand, 0.5, N.y);\n    \n    //float rock = 1.0-smoothstep(1800., 2000.0, height);\n    \n    color = mix(colRock, colSnow, snow);\n    \n    return color;\n}\n\n// Credit: https://www.iquilezles.org/www/articles/filtering/filtering.htm\n// Returns filtered texture\nvec3 getTerrainTextureFiltered(vec3 coord, vec3 ddx, vec3 ddy, vec3 N, float height)\n{\n    vec3 diffX = ddx-coord;\n    vec3 diffY = ddy-coord;\n    \n    const float detail = 4.0;\n    \n    int sx = 1 + int(clamp( detail*length(diffX), 0.0, float(FILTERING_SAMPLES-1) ));\n    int sy = 1 + int(clamp( detail*length(diffY), 0.0, float(FILTERING_SAMPLES-1) ));\n\n\tvec3 no = vec3(0.0);\n\n    for( int j=ZERO; j<FILTERING_SAMPLES; j++ )\n        for( int i=ZERO; i<FILTERING_SAMPLES; i++ )\n        {\n            if( j<sy && i<sx )\n            {\n                vec2 st = vec2(float(i), float(j)) / vec2(float(sx),float(sy));\n                no += getTerrainTexture(coord + st.x*(diffX) + st.y*(diffY), N, height);\n            }\n        }\n\n\treturn no / float(sx*sy);\n}\n\n\n// Three light setup: direct sunlight, ambient skylight and indirect sunlight\n// Based on https://iquilezles.org/articles/outdoorslighting\n// Returns shaded color of the terrain\nvec3 shade(vec3 point, vec3 N, vec3 color, vec3 lightColor, float epsilon)\n{      \n    //float shadow = softShadow(point+Light*SCALE*0.01, MinDist, MaxMarchingStepsShadow);\n    float shadow = softShadow(point+N*0.01, MIN_DIST, MAX_MARCHING_STEPS_SHADOW);\n    \n    // direct light from sun\n    float sun = clamp(dot(Light, N), 0.0, 1.0);\n    \n    // ambient light from sky\n    float sky = clamp(0.5 + 0.5*N.y, 0.0, 1.0);\n    \n    // approximation of indirect sunlight\n    float indirect = clamp(dot(N, normalize(Light*vec3(-1.0,0.0,-1.0)) ), 0.0, 1.0);\n    \n    // compute overall light\n    vec3 light = sun*SunIntensityGround*lightColor*shadow;\n    //light += sky*ambientLight;\n    light += sky*vec3(0.16,0.20,0.28);\n    \n    light += indirect*0.2*lightColor;\n    \n    return light*color;\n}\n\n// Returns density gradient for clouds\n// Density is lower in bottom and top parts of the clouds\nfloat cloudHeightGradient(float height)\n{\n    const float edge = 0.35*CLOUDS_THICKNESS;\n    return smoothstep(0.0, edge, height-CLOUDS_HEIGHT)*\n           smoothstep(0.0, edge, CLOUDS_HEIGHT+CLOUDS_THICKNESS-height);\n}\n\nfloat cloudTransmittance(Ray r, Atmosphere planetAtmos)\n{\n    const float extinction = ABSORPTION + SCATTERING;\n    Sphere clouds = Sphere(vec3(0., 0., 0.), planetAtmos.planetRadius+CLOUDS_HEIGHT);\n    float transmittance = 1.0;\n    \n    float tMin = intersectRaySphereInside(r, clouds);\n    clouds.radius += CLOUDS_THICKNESS;\n    float tMax = intersectRaySphereInside(r, clouds);\n    \n    float dist = tMax - tMin;\n    float stepLength = dist / 3.0;\n    float tCurrent = tMin;\n            \n    for (int i = 0; i < 3; i++)\n    {\n        vec3 samplePosition = rayPointAtParameter(r, tCurrent);\n            \n        float density = fbmCloud(samplePosition);\n           \n        /*if (density <= 0.001)\n        {\n            return 0.0;\n        }*/\n        \n        float height = length(samplePosition) - planetAtmos.planetRadius;\n        density *= cloudHeightGradient(height);\n        \n        float extinctionCoeff = max(0.000000001, density*extinction);\n            \n        transmittance *= exp(-extinctionCoeff*stepLength);\n        tCurrent += stepLength;\n    }\n    \n    return transmittance;\n}\n\nvec3 atmosphereScattering(Ray r, float tMin, float tMax, Atmosphere planetAtmos, out vec3 rayTransmittance)\n{\n    Sphere atmosphere = Sphere(vec3(0., 0., 0.), \n                                planetAtmos.atmosphereRadius);\n    \n    vec3 scatteringCoeffR = planetAtmos.scatteringR;\n    vec3 scatteringCoeffM = planetAtmos.scatteringM;\n    //int steps = STEPS;       \n    //int lightSteps = LIGHT_STEPS;\n\n    // find intersection with atmosphere\n    float atmosphereIntersectionT = intersectRaySphereInside(r, atmosphere);\n    \n    tMax = min(tMax, atmosphereIntersectionT);\n    \n    float stepLength = (tMax-tMin) / float(ATMOS_STEPS);\n    float halfStep = stepLength*0.5;\n    \n    float tCurrent = tMin;\n    float mu = dot(r.dir, Light);  // cosine of an angle between light direction and view direction\n    float muSquared = mu*mu;\n    \n    vec3 rayleighSum, mieSum = vec3(0.0);\n    float opticalDepthR, opticalDepthM = 0.0;\n    \n    const float g = 0.76;     // determines anisotropy of mie scattering \n    const float gSquared = g*g;\n    \n    const float rConst = 3. / (16.*PI);\n    const float mConst = 3. / (8.*PI);\n    \n    float phaseR = rConst * (1.+muSquared);  // Rayleigh phase function\n    float phaseM = mConst * ( (1.-gSquared)*(1.+muSquared) ) / \n                   ( (2.+gSquared)*pow(1.+gSquared-2.*g*mu, 1.5) );  // Mie phase function\n                   \n    for (int i = 0; i < ATMOS_STEPS; i++) \n    {\n        vec3 samplePosition = rayPointAtParameter(r, tCurrent+halfStep);\n        float height = length(samplePosition) - planetAtmos.planetRadius;\n        \n        float hr = exp(-height / planetAtmos.Hr) * stepLength;\n        float hm = exp(-height / planetAtmos.Hm) * stepLength; \n        opticalDepthR += hr; \n        opticalDepthM += hm; \n        \n        Ray rayToLight = Ray(samplePosition, Light);\n        \n        float tMaxLight = intersectRaySphereInside(rayToLight, atmosphere);\n        float tCurrentLight = 0.0;\n        \n        float stepLengthLight = tMaxLight / float(ATMOS_LIGHT_STEPS);\n        float halfStepLight = stepLengthLight*0.5;\n        \n        float opticalDepthLightR, opticalDepthLightM = 0.0;\n        \n        for ( int j = 0 ; j < ATMOS_LIGHT_STEPS; ++j)\n        {\n            vec3 samplePositionLight = rayToLight.origin + \n                    (tCurrentLight+halfStepLight)*rayToLight.dir;\n                    \n            float heightLight = length(samplePositionLight) - planetAtmos.planetRadius;\n            \n            opticalDepthLightR += exp(-heightLight / planetAtmos.Hr) * stepLengthLight;\n            opticalDepthLightM += exp(-heightLight / planetAtmos.Hm) * stepLengthLight; \n            tCurrentLight += stepLengthLight;\n        }\n        \n        vec3 tau = scatteringCoeffR * (opticalDepthR + opticalDepthLightR) + extinctionM * (opticalDepthM + opticalDepthLightM); \n        vec3 attenuation = exp(-tau);\n        rayleighSum += attenuation * hr; \n        mieSum += attenuation * hm; \n        tCurrent += stepLength;\n    }\n    rayTransmittance = exp(-(scatteringCoeffR*opticalDepthR + extinctionM*opticalDepthM));\n    \n    return (rayleighSum * scatteringCoeffR * phaseR + mieSum * scatteringCoeffM * phaseM) * 20.0; \n}\n\n// Computes Henyey-Greenstein phase function\nfloat henyeyGreenstein(float cosViewLight, float g)\n{\n    float gg = g * g;\n\treturn (1. - gg) / (4.*PI * pow(1. + gg - 2. * g * cosViewLight, 1.5));\n}\n\n// Computes transmittance of light coming to the given point \n// through cloud layer of given atmosphere\nfloat marchToLight(vec3 point, Atmosphere planetAtmos)\n{\n\tRay r = Ray(point, Light);\n\t\n    Sphere clouds = Sphere(vec3(0., 0., 0.), \n                                planetAtmos.planetRadius+CLOUDS_HEIGHT);\n                                \n    // find intersections with bounding spheres of clouds\n    //float tInner = intersectRaySphereOutside(r, clouds);\n    clouds.radius += CLOUDS_THICKNESS;\n    float tOuter = intersectRaySphereInside(r, clouds);\n    \n    float tMin = 0.0;\n    //float tMax = min(tInner, tOuter);\n    float tMax = tOuter;\n    \n    const int steps = CLOUD_LIGHT_STEPS;\n    float stepLength = tMax / float(steps);\n\n\tfloat tCurrent = 0.0f;\n    float transmittance = 1.0;\n    const float extinction = ABSORPTION + SCATTERING;\n\n\tfor (int i = 0; i < steps; i++)\n    {\n        vec3 samplePosition = r.origin + tCurrent*r.dir;\n        float height = length(samplePosition) - planetAtmos.planetRadius;\n        \n        float density = fbmCloud(samplePosition)*cloudHeightGradient(height);\n        \n        // low density - no need to compute transmittance\n        if (density <= 0.001)\n        {\n            tCurrent += stepLength;\n            continue;\n        }\n        \n        float extinctionCoeff = max(0.000000001, density*extinction);\n        \n        transmittance *= exp(-extinctionCoeff*stepLength);\n        \n        if (transmittance < 0.02) break;\n        tCurrent += stepLength;\n    }\n    \n\treturn transmittance;\n}\n\n// Returns phase function of the clouds\nfloat phaseFunction(vec3 view, vec3 light, float forwardG, float backwardG, float a)\n{\n    // cosine of an angle between light direction and view direction\n    float mu = dot(view, light);\n    \n    // 2-lobe Henyey-Greenstein phase function\n    return mix(henyeyGreenstein(mu, forwardG), henyeyGreenstein(mu, -backwardG), a);\n}\n\n// Exponential integral\nfloat Ei(float z)\n{\n    return 0.5772156649015328606065 + log( 1e-4 + abs(z) ) + z * \n           (1.0 + z * (0.25 + z * ( (1.0/18.0) + z * ( (1.0/96.0) + z * (1.0/600.0) ) ) ) );\n}\n\n// Credit: http://patapom.com/topics/Revision2013/Revision%202013%20-%20Real-time%20Volumetric%20Rendering%20Course%20Notes.pdf\n// Computes approximation of ambient light in clouds\nvec3 computeAmbientColor(float height, float extinctionCoeff, vec3 ambientColor)\n{\n    float distToTop = CLOUDS_HEIGHT + CLOUDS_THICKNESS - height;\n    float a = -extinctionCoeff * distToTop;\n    vec3 isotropicScatteringTop = ambientColor * max(0.0, exp(a) - a*Ei(a));\n    \n    float distToBottom = height - CLOUDS_HEIGHT;\n    a = -extinctionCoeff * distToBottom;\n    vec3 isotropicScatteringBottom = ambientColor * max(0.0, exp(a) - a*Ei(a));\n    return AMBIENT_LIGHT_STRENGTH_CLOUDS*(isotropicScatteringTop+isotropicScatteringBottom) / (4.*PI);\n}\n\nvec4 renderClouds(Ray r, float depth, Atmosphere planetAtmos, vec3 lightColor, vec3 ambientLight)\n{\n    int steps = CLOUD_STEPS;\n    \n    if (steps <= 0) return vec4(0.0, 0.0, 0.0, 1.0);\n    \n    Sphere clouds;\n    float height = length(r.origin) - planetAtmos.planetRadius;\n    \n    // find intersections with boundaries of cloud layer\n    float tMin, tMax;\n    \n    if ( height < (CLOUDS_HEIGHT+CLOUDS_THICKNESS) )\n    {\n        clouds = Sphere(vec3(0., 0., 0.), planetAtmos.planetRadius+CLOUDS_HEIGHT);\n        // camera is below or inside the clouds\n        \n        if ( height < CLOUDS_HEIGHT )\n        {\n            // camera is below the clouds\n            tMin = intersectRaySphereInside(r, clouds);\n            clouds.radius += CLOUDS_THICKNESS;\n            tMax = intersectRaySphereInside(r, clouds);\n        }\n        else\n        {\n            // camera is inside the clouds\n            tMin = 0.0;\n            \n            float inner = intersectRaySphereOutside(r, clouds);\n            clouds.radius += CLOUDS_THICKNESS;\n            float outer = intersectRaySphereInside(r, clouds);\n            \n            if (inner < 0.0) tMax = outer;\n            else if (outer < 0.0) tMax = inner;\n            else tMax = min(inner, outer);\n        }\n    }\n    else\n    {\n        // camera is above the clouds\n        clouds = Sphere(vec3(0., 0., 0.), planetAtmos.planetRadius+CLOUDS_HEIGHT+CLOUDS_THICKNESS);\n        \n        tMin = intersectRaySphereOutside(r, clouds);\n        \n        if (tMin < 0.0) return vec4(-1.0);\n        clouds.radius -= CLOUDS_THICKNESS;\n        tMax = intersectRaySphereOutside(r, clouds);\n    }\n    \n    // terrain occludes clouds\n    if (depth < tMin) return vec4(-1.0);\n    \n    //if (tMin > FAR_PLANE) return vec4(-1.0);\n\n    float stepLength = (tMax-tMin) / float(steps);\n    //const float stepLength = 45.;\n    \n    float tCurrent = tMin;\n    float transmittance = 1.0;\n    vec3 lightAmount = vec3(0.0);\n    const float extinction = ABSORPTION + SCATTERING;\n    float phaseVal = phaseFunction(r.dir, Light, FORWARD_SCATTERING_G, BACKWARD_SCATTERING_G, INTERPOLATION);\n    \n    vec3 ambient = mix(lightColor, ambientLight, 0.3);\n    \n    #if RANDOM_RAY_OFFSET\n        // randomly offset ray to eliminate banding artefacts\n        tCurrent += stepLength * (hashPCG(pixelCoord)*2.0 - 1.0);\n    #endif\n    \n    while (tCurrent <= tMax)\n    {\n        vec3 samplePosition = r.origin + tCurrent*r.dir;\n        \n        float density = fbmCloud(samplePosition);\n        \n        // low density - no need to compute lighting\n        if (density <= 0.001)\n        {\n            tCurrent += stepLength;\n            continue;\n        }\n        \n        height = length(samplePosition) - planetAtmos.planetRadius;\n        density *= cloudHeightGradient(height);\n        \n        float extinctionCoeff = max(0.000000001, density*extinction);\n        \n        // amount of light coming from sun to this point\n\t\tvec3 incomingLight = marchToLight(samplePosition, planetAtmos)*lightColor*SUN_INTENSITY_CLOUDS;\n        float stepTransmittance = exp(-extinctionCoeff*stepLength);\n                \n        vec3 amb = computeAmbientColor(height, extinctionCoeff, ambient);\n        \n        // amount of light scattered toward camera\n        vec3 scatteredL =  SCATTERING*density * (incomingLight*phaseVal + amb);\n#if IMPROVED_INTEGRATION\n        // integrate scattered light along current segment\n        scatteredL = (scatteredL - scatteredL * stepTransmittance) / extinctionCoeff;\n#else\n        // amount of light scattered toward camera\n        scatteredL *=  stepLength;\n#endif       \n\t\tlightAmount += transmittance * scatteredL;\n        \n        transmittance *= stepTransmittance;\n        \n        if (transmittance < 0.02) break;\n        tCurrent += stepLength;\n    }\n    \n    //if (transmittance < 1.0)\n    {\n        // atmosphere scattering in front of the cloud\n        vec3 rayTransmittance = vec3(0.0);\n        vec3 atmosphereColor = atmosphereScattering(r, NEAR_PLANE, tMin, planetAtmos, rayTransmittance);\n        lightAmount = lightAmount*rayTransmittance+atmosphereColor;\n    }\n    \n    return vec4(lightAmount, transmittance);\n}\n\nfloat renderSun(float mu)\n{\n    float oneMuSquared = 1.0 + mu*mu;\n    \n    float s = 0.999;\n    float sSquared = s*s;\n    float phaseS = 0.1193662 * ( (1.-sSquared)*oneMuSquared ) / \n                   ( (2.+sSquared)*pow(1.+sSquared-2.*s*mu, 1.5) );\n    //float phaseS = .1193662 * (1. - s2) * opmu2 / ((2. + s2) * pow(1. + s2 - 2.*s*mu, 1.5));\n    return phaseS;\n}\n\nbool trace(Ray r, out float intersectionDist)\n{\n\tfloat totalDist = NEAR_PLANE;\n\tint steps = 0;\n    intersectionDist = FLT_MAX;\n\n    //r.origin += vec3(camPosition.x, 0.0, camPosition.z);\n\n    float dist = 0.0;\n\n\tfloat epsilon = MIN_DIST;\n\tfloat epsilonModified = epsilon;\n\n\tfor (steps = 0; steps < MAX_MARCHING_STEPS; steps++) \n\t{\n\t\tvec3 samplePoint = r.origin + totalDist * r.dir;\n\t\tdist = sceneSDF(samplePoint, false);\n        \n\t\tif (dist < epsilonModified) \n\t\t{\n\t\t\t// Ray is inside the terrain\n                        \n            // interpolation of previous and current point\n            intersectionDist = totalDist;//mix(totalDist, oldTotalDist, 0.5);\n            \n            // intersection with terrain was found\n            return true;\n\t\t}\n        \n        //vec3 N = estimateNormal(samplePoint, epsilonModified*0.001, false);\n        \n        // Move along the view ray\n        totalDist += dist*0.4;\n        //totalDist += dist*0.5*smoothstep(-0.2, 0.5, N.y); // slow down in steep areas\n        \n        if (totalDist >= FAR_PLANE) \n        {\n\t\t\t// there is no intersection with terrain\n            return false;\n\t\t}\n        \n        epsilonModified = epsilon*totalDist;\n\t}\n    \n    // maximal number of ray marching steps was evaluated,\n    // no intersection with terrain was found\n    return false;\n}\n\nmat3 camera() \n{\n\tvec3 cd = CamDir;          // camera direction\n\tvec3 cr = normalize(cross(vec3(0, 1, 0), cd)); // camera right\n\tvec3 cu = normalize(cross(cd, cr));            // camera up\n\t\n\treturn mat3(cr, cu, -cd);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    float t = iTime;\n\n    /*sunAngleY = radians(iTime*0.5-5.0);\n    sunAngleX = radians(10.0);\n    Light = normalize( vec3(sin(sunAngleX)*cos(sunAngleY), \n                                   sin(sunAngleY),\n                                   cos(sunAngleX)*cos(sunAngleY) ));*/\n\n    pixelCoord = fragCoord.xy;\n\tvec2 dimensions = iResolution.xy;\n\n\tif (pixelCoord.x > dimensions.x || pixelCoord.y > dimensions.y)\n\t\treturn;\n        \n    const Atmosphere earthAtmos = Atmosphere(PLANET_RADIUS, ATMOSPHERE_RADIUS, scatteringR, scatteringM, Hr, Hm);    \n        \n    vec3 offset = vec3(0., earthAtmos.planetRadius, 0.);\n    vec3 rayTransmittance = vec3(0.0);\n    \n#if MOVING_CAM\n    camPosition = vec3(t*CAM_SPEED, CAM_HEIGHT+earthAtmos.planetRadius, 0.0);\n    vec3 ro = vec3(0, camPosition.y, 0.0);\n    \n    float terrainH = 0.0;\n    const int numSamples = 4;\n    const float stepLen = 2.0*CAM_SPEED / float(numSamples);\n    float s = 0.0;\n    for (int i = 0; i < numSamples; i++) \n    {\n        terrainH += TERRAIN_AMPLITUDE*terrainMap( (ro.xz+TERRAIN_OFFSET)*SCALE + s, 6);\n        s += stepLen;\n    }\n    ro.y += terrainH / float(numSamples);\n    camPosition.y = ro.y;\n    vec3 lookAt = normalize(ro+CamDir); //vec3(100.0, -20., 52.0);\n#else\n    camPosition = vec3(11e3, CAM_HEIGHT+earthAtmos.planetRadius, 2e3);\n    vec3 ro = vec3(0.0, camPosition.y, 0.0);\n    //vec3 lookAt = ro + normalize(vec3(1.0, .5, 1.0)); //vec3(sin(0.5*t), -0.4, cos(0.5*t));\n    vec3 lookAt = ro+CamDir;\n#endif\n    mat3 cameraMat = camera();\n    vec3 rd = cameraMat * normalize(vec3(uv, -1)); // ray direction\n    \n\tRay r = Ray(ro, rd);\n    float intersectionDist = -1.0;\n    \n    // get color of the light by computing atmosphere scattering in the direction of the Sun\n    vec3 lightColor = vec3(1.0, 1.0, 1.0);\n    vec3 tmp = atmosphereScattering(Ray(ro, Light), NEAR_PLANE, FLT_MAX, earthAtmos, rayTransmittance);\n    lightColor *= rayTransmittance;\n    \n    // get color of the ambient light by computing atmosphere scattering in the up direction\n    vec3 ambientLight = atmosphereScattering(Ray(ro, normalize(ro)), NEAR_PLANE, FLT_MAX, earthAtmos, rayTransmittance);\n    //ambientColor = vec3(1.0)-exp(-ambientColor);\n    ambientLight = normalize(ambientLight);\n    \n    // find intersection with terrain\n    bool intersection = trace(r, intersectionDist);\n    \n    vec3 color = vec3(0.0);\n    float epsilonModified = MIN_DIST * clamp(intersectionDist, NEAR_PLANE, FAR_PLANE);\n    \n    if (intersection)\n    {\n        vec3 terrainColor = vec3(0.0);\n        // shade terrain\n        vec3 samplePoint = r.origin + intersectionDist * r.dir;\n        float sampleHeight = length(samplePoint)-earthAtmos.planetRadius;\n        \n        // normal vector of a given surface point\n        vec3 N = estimateNormal(samplePoint, epsilonModified, true);\n    \n        samplePoint += vec3(camPosition.x, 0.0, camPosition.z);\n        #if TEXTURE_FILTERING\n            vec3 posX = samplePoint + dFdx(samplePoint);\n            vec3 posY = samplePoint + dFdy(samplePoint);\n            terrainColor = getTerrainTextureFiltered(samplePoint, posX, posY, N, sampleHeight);\n        #else\n            terrainColor = getTerrainTexture(samplePoint, N, sampleHeight);\n        #endif\n        samplePoint -= vec3(camPosition.x, 0.0, camPosition.z);\n        \n        color = shade(samplePoint, N, terrainColor, lightColor, epsilonModified);\n    }\n    \n    // render atmospheric scattering\n    rayTransmittance = vec3(0.0);\n    vec3 atmosphereColor = atmosphereScattering(r, NEAR_PLANE, intersectionDist, earthAtmos, rayTransmittance);\n    \n    float sunAngle = dot(r.dir, Light);\n    float sun = 2.0*renderSun(sunAngle); // (10000.0*smoothstep(0.9995, 1.01, sunAngle));\n    vec4 clouds = renderClouds(r, intersectionDist, earthAtmos, lightColor, ambientLight);\n    \n    color = (intersectionDist < FAR_PLANE) ? \n                (color*rayTransmittance + atmosphereColor) :\n                (atmosphereColor + clouds.a*sun*lightColor);\n        \n    if (clouds.a > 0.0)\n        color = color*clouds.a + clouds.xyz;\n    \n    const float exposure = 1.0;\n    const float oneOverGamma = 0.454546; // 1.0/2.2;\n  \n    // exposure tone mapping\n    vec3 mapped = vec3(1.0) - exp(-color * exposure);\n    // gamma correction \n    mapped = pow(mapped, vec3(oneOverGamma));\n\n\tcolor = mapped;\n    \n    // Output to screen\n    fragColor = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"}]}