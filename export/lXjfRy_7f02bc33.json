{"ver":"0.1","info":{"id":"lXjfRy","date":"1729631499","viewed":114,"name":"sunbursted","username":"pb","description":"just boring old 2d fractal, no animation because it jacks up the iteration count, play with params and explore, fullscreen it","likes":15,"published":1,"flags":32,"usePreview":0,"tags":["fractal","mandelbrot","exponentialfunction"],"hasliked":0,"parentid":"NlBBzw","parentname":"mandelexp"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//philip.bertani@gmail.com\n//see buffer A please\n\nvoid mainImage(out vec4 O, vec2 u) {\n\n    vec2 R = iResolution.xy,\n        uv = u/R;\n\n    O *= 0.;\n\n    float[] gk1s = float[](\n        0.003765, 0.015019, 0.023792, 0.015019, 0.003765,\n        0.015019, 0.059912, 0.094907, 0.059912, 0.015019,\n        0.023792, 0.094907, 0.150342, 0.094907, 0.023792,\n        0.015019, 0.059912, 0.094907, 0.059912, 0.015019,\n        0.003765, 0.015019, 0.023792, 0.015019, 0.003765\n    );\n\n    //golfed by fabriceneyret2\n    for (int k; k < 25; k++)      \n        O += gk1s[k] * texture(iChannel0, uv + ( vec2(k%5,k/5) - 2. ) / R );\n          \n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// philip.bertani@gmail.com\n\nvec2 zz( in vec2 z ) {\n    //classic z squared iteration here\n    return vec2(z.x*z.x-z.y*z.y, 2.*z.x*z.y);\n}\n\nvec2 expz( in vec2 z ) {\n    //exponential function here\n    return vec2( exp(z.x)*cos(z.y), exp(z.x)*sin(z.y) );\n}\nvoid mainImage0( out vec4 fragColor, in vec2 fragCoord )\n{\n    //vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 uv = (2.0*fragCoord-iResolution.xy)/iResolution.y;    \n        \n    //we want to start in a particular rectangle in complex plane\n    vec2 center = vec2(2.3238,1.8445);\n    vec2 width  = vec2( .0006, .00055);\n    \n    vec2 final_uv = uv * width + center ; \n    \n    float max_iter=1600., mix_factor=.02848, infinity=1e6;\n    vec3  julia_freq = vec3(  -51.,\n                              -12.6,\n                              70. );\n\n    vec4 qq = vec4(0); //counts orbit in 4 quadrants\n    \n    vec2 wgt=vec2(mix_factor, 1.-mix_factor);\n    \n    vec2 iter=final_uv, new_iter;\n    \n    float r=.462,an=4.2446;  //the Julia set params, play with it\n    vec2 jc = vec2(r*cos(an),r*sin(an));\n    \n    float escape_value = 0.;\n    for ( float i=0.; i<max_iter; i++ ) {\n    \n        new_iter = wgt.x * zz(iter) + wgt.y*expz(iter) + jc;\n        iter = new_iter;\n        \n        float distance = new_iter.x*new_iter.x + new_iter.y*new_iter.y;\n\n        //keep track if how many times the orbit is in \n        //the various 4 quadrants (for coloring)\n        if (new_iter.x >= 0.0) {\n            if (new_iter.y >= 0.0) {\n                qq[0] ++;\n            }\n            else {\n                qq[1] ++;\n            }\n        }\n        else {\n            if (new_iter.y >= 0.0) {\n                qq[2] ++;\n            }\n            else {\n                qq[3] ++;\n            }\n        }\n        \n        //the usual distance bigger than some large number check\n        //NOT using distance estimator here\n        if ( distance > infinity ) {\n            escape_value = i;\n            break;\n        }\n         \n    }\n    \n    if ( escape_value != 0. ) {\n        vec3 qx = vec3( qq[0]*julia_freq[0], \n                        qq[1]*julia_freq[1],\n                        qq[2]*julia_freq[2]\n                       );\n        \n        fragColor = vec4( cos( qx / escape_value ), 1. ); \n    }\n    else {\n        fragColor = vec4( vec3(0.), 1. );\n    }\n    \n\n}\n\n//FabriceNeyret2 antialiasing trick\nvoid mainImage(out vec4 O, vec2 U) {\n    mainImage0(O,U);\n    if ( fwidth(length(O)) > .01 ) {  // difference threshold between neighbor pixels\n        vec4 o;\n        for (int k=0; k < 9; k+= k==3?2:1 )\n          { mainImage0(o,U+vec2(k%3-1,k/3-1)/3.); O += o; }\n        O /= 9.;\n        //O.b++;                        // uncomment to see where the oversampling occurs\n    }\n}","name":"Buffer A","description":"","type":"buffer"}]}