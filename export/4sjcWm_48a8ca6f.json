{"ver":"0.1","info":{"id":"4sjcWm","date":"1493421867","viewed":127,"name":"Cube : Extrusion","username":"JCDjcd","description":"This is a very simple extruded cube displayed by ray-tracing method.\nThe intersections ray/cube are found by solving 3x3-matrix linear equations.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["cube"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//--------------------------------------------------------------------------\n// Intersect between line (point P, direction n)\n// and parallelogram (AB and AC are adjacent vertexes).\n// The return value is the value t such that the intersection point is P+t.n\nfloat intersect(in vec3 A,in vec3 B,in vec3 C,in vec3 P,in vec3 n)\n{\n    // ==========\n    //  STEP #1\n    // ==========\n    // First step is the computation of the intersection between the plan and the line.\n    // The line is parametrized with one parameter t      : P + t.n\n    // The plan is parametrized with two parameters (p,q) : A + p.AB + q.AC\n    vec3 u = B-A;\n    vec3 v = C-A;\n    vec3 w = -n;\n    vec3 s = P-A; // 's' stands for second member of the equation (see below)\n    \n    //\n    // Solve the equation p.u + q.v + t.w = s\n    // The intersect is within the plan (AB,AC) and on the line P+t.n\n    // That equation is linear :\n    //\n    //                   ( p )\n    //                   ( q )  <-- unkown\n    //                   ( t )\n    //\n    // ( u.x  v.x  w.x ) (s.x)\n    // ( u.y  v.y  w.y ) (s.y)\n    // ( u.z  v.z  w.z ) (s.z)\n    // \n    // To solve the 3x3 matrix, we use determinant and co-matrix.\n    //\n    float det \t= u.x*v.y*w.z\n        \t\t+ v.x*w.y*u.z\n        \t\t+ w.x*u.y*v.z\n              \t- w.x*v.y*u.z\n        \t\t- v.x*u.y*w.z\n        \t\t- u.x*w.y*v.z;\n    if(abs(det) < 1e-6) // line and plan are parallel\n        return -1000.0;\n    float cm_ux = v.y*w.z-v.z*w.y;\n    float cm_vx = u.z*w.y-u.y*w.z;\n    float cm_wx = u.y*v.z-u.z*v.y;\n    float cm_uy = v.z*w.x-v.x*w.z;\n    float cm_vy = u.x*w.z-u.z*w.x;\n    float cm_wy = u.z*v.x-u.x*v.z;\n    float cm_uz = v.x*w.y-v.y*w.x;\n    float cm_vz = u.y*w.x-u.x*w.y;\n    float cm_wz = u.x*v.y-u.y*v.x;\n    \n    // Now it is easy to solve because the inverse of the matrice\n    // is the transpose of the co-matrix divided by the determinant.\n    float p = (cm_ux*s.x+cm_uy*s.y+cm_uz*s.z)/det;\n    float q = (cm_vx*s.x+cm_vy*s.y+cm_vz*s.z)/det;\n    float t = (cm_wx*s.x+cm_wy*s.y+cm_wz*s.z)/det;\n\n    // ==========\n    //  STEP #2\n    // ==========\n    // The second step consists on checking if the intersection point\n    // is within the cube side (parallelogram ABDC, see below).\n    if(p >= 0.0 && p <= 1.0 && q >= 0.0 && q <= 1.0) // belongs to the cube's side\n    {\n        // Let's have a funny cube where we extruded a cross.\n        // The cross is defined by two ellipsis.\n        float e \t= 20.0; // ellipsis parameter\n        float r2 \t= 0.15; // square radius of the ellipsis\n        // Compute coordinated from the middle of the square :\n        float x = p-0.5;\n        float y = q-0.5;\n        // Rotate by 45Â° the coordinate in order to have the ellipsis\n        // axis along the diagonal of the square :\n        float rx = (x+y)*0.70710678;\n        float ry = (x-y)*0.70710678;\n        if(rx*rx+e*ry*ry<r2)\n            return -1000.0; // no intersection of the extruded part\n        else if(e*rx*rx+ry*ry<r2)\n            return -1000.0; // no intersection of the extruded part\n        else\n    \t\treturn t; // intersection!!\n    }\n    else // does not belong to the cube's side\n    {\n        return -1000.0;\n    }\n} // intersect()\n\n//--------------------------------------------------------------------------\nstruct CubeSide\n{\n    // Cube side :\n    //    A ___ B\n    //    |     |\n    //    |     |\n    //    C ___ D\n    // \n    // The point D is not used. The points of the cube's side are :\n    // x.AB + y.AC for all 0 <= x <= 1 and 0 <= y <= 1\n    // \n    vec3 A;\n    vec3 B;\n    vec3 C;\n    vec4 color;\n}; // struct CubeSide\n    \n//--------------------------------------------------------------------------\nvec4 compute(in vec3 P, in vec3 n)\n{\n    // Definition of the cube :\n    CubeSide sides[6];\n    \n\t// top and bottom sides\n    sides[0].A \t\t= vec3(-1.0,-1.0,-1.0);\n    sides[0].B \t\t= vec3( 1.0,-1.0,-1.0);\n    sides[0].C \t\t= vec3(-1.0, 1.0,-1.0);\n    sides[0].color \t= vec4( 0.0, 0.0, 1.0 ,1.0); \t// blue\n    sides[1].A \t\t= vec3(-1.0,-1.0, 1.0);\n    sides[1].B \t\t= vec3( 1.0,-1.0, 1.0);\n    sides[1].C \t\t= vec3(-1.0, 1.0, 1.0);\n    sides[1].color \t= vec4( 1.0, 1.0, 0.0, 1.0); \t// yellow\n\t// front and rear sides\n    sides[2].A \t\t= vec3(-1.0,-1.0,-1.0);\n    sides[2].B \t\t= vec3(-1.0, 1.0,-1.0);\n    sides[2].C \t\t= vec3(-1.0,-1.0, 1.0);\n    sides[2].color \t= vec4( 1.0, 0.0, 0.0, 1.0); \t// red\n    sides[3].A \t\t= vec3( 1.0,-1.0,-1.0);\n    sides[3].B \t\t= vec3( 1.0, 1.0,-1.0);\n    sides[3].C \t\t= vec3( 1.0,-1.0, 1.0);\n    sides[3].color \t= vec4( 0.0, 1.0, 1.0, 1.0); \t// cyan\n\t// left and right sides\n    sides[4].A \t\t= vec3(-1.0,-1.0,-1.0);\n    sides[4].B \t\t= vec3( 1.0,-1.0,-1.0);\n    sides[4].C \t\t= vec3(-1.0,-1.0, 1.0);\n    sides[4].color \t= vec4( 0.0, 1.0, 0.0, 1.0); \t// green\n    sides[5].A \t\t= vec3(-1.0, 1.0,-1.0);\n    sides[5].B \t\t= vec3( 1.0, 1.0,-1.0);\n    sides[5].C \t\t= vec3(-1.0, 1.0, 1.0);\n    sides[5].color \t= vec4( 1.0, 0.0, 1.0, 1.0); \t// magenta\n\t\n    // We need to compute the color of the neareast points\n    // (intersections between ray (parametrized by t) and cube sides).\n    float t_min \t= 1000.0; // put starting current minimum t far away...\n    vec4  color \t= vec4(0.0,0.0,0.0,1.0); // black for the background\n    int   i;\n    for(i=0;i<6;i++) // loop on each cube sides\n    {\n        // Compute the intersection with that side.\n        // If behing the observer direction, don't take it into account.\n    \tfloat t = intersect(sides[i].A,sides[i].B,sides[i].C,P,n);\n        if(t > 0.0 && t < t_min)\n        {\n            t_min = t;\n            color = sides[i].color;\n        }\n    } // for()\n\n    return color;\n} // compute()\n\n//--------------------------------------------------------------------------\n// Rotation along z-axis.\nvec3 Rz(in vec3 u,float alpha)\n{\n    float c = cos(alpha);\n    float s = sin(alpha);\n    float x = c*u.x-s*u.y;\n    float y = s*u.x+c*u.y;\n    float z = u.z;\n    return vec3(x,y,z);\n} // Rz()\n\n//--------------------------------------------------------------------------\n// Rotation along y-axis.\nvec3 Ry(in vec3 u,float alpha)\n{\n    float c = cos(alpha);\n    float s = sin(alpha);\n    float z = s*u.z+c*u.x;\n    float x = c*u.z-s*u.x;\n    float y = u.y;\n    return vec3(x,y,z);\n} // Ry()\n\n//--------------------------------------------------------------------------\nvoid mainImage(out vec4 fragColor,vec2 fragCoord)\n{\n    // Get min/max of the resolution (in most case the width).\n    float m \t\t= min(iResolution.x,iResolution.y);\n    // Center the viewport (cube's center is (0,0,0)).\n\tvec2 uv \t\t= (fragCoord.xy / m - vec2(0.5,0.5))*4.5;\n    // Before doing the rotation, the ray pass through that pixel defined by (x,y,0)\n    // and ray'direction is in the z-direction (0,0,0).\n    // The point is put back of -5 unit in the z-direction to observe the cube from outside.\n    vec3 P \t\t\t= vec3(uv.x,uv.y,-5.0);\n    vec3 n      \t= vec3(0.0,0.0,1.0);\n    // Now perform the rotation of the observer.\n    // Two angles for respectively the rotations along y- and the z-direction.\n    // Periods are 10 seconds and 3 seconds.\n    float alpha1\t= iTime*3.1415926535*2.0/10.0;\n    float alpha2\t= iTime*3.1415926535*2.0/3.0;\n    P \t\t\t\t= Ry(P,alpha1);\n    P \t\t\t\t= Rz(P,alpha2);\n    n\t \t\t\t= Ry(n,alpha1);\n    n \t\t\t\t= Rz(n,alpha2);\n    // Compute the color of the intersection (if exists) between the ray and the cube.\n\tfragColor \t\t= compute(P,n);\n} // mainImage()\n\n","name":"Image","description":"","type":"image"}]}