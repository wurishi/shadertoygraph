{"ver":"0.1","info":{"id":"NtdGzX","date":"1636460277","viewed":52,"name":"PR_TaiChi","username":"RhymelessPoet","description":"旋转的太极图","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["2d"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// uniform vec3      iResolution;           // viewport resolution (in pixels)\n// uniform float     iTime;                 // shader playback time (in seconds)\n// uniform float     iTimeDelta;            // render time (in seconds)\n// uniform int       iFrame;                // shader playback frame\n// uniform float     iChannelTime[4];       // channel playback time (in seconds)\n// uniform vec3      iChannelResolution[4]; // channel resolution (in pixels)\n// uniform vec4      iMouse;                // mouse pixel coords. xy: current (if MLB down), zw: click\n// uniform samplerXX iChannel 0..3;          // input channel. XX = 2D/Cube\n// uniform vec4      iDate;                 // (year, month, day, time in seconds)\n// uniform float     iSampleRate;           // sound sample rate (i.e., 44100)\nfloat pi = radians(180.0);\n\nvec4 TaiChi(vec2 c, float r, mat3 rotation, vec2 p);\n\nfloat Divide(vec2 c, float r, mat3 rotation, vec2 p);\n\nfloat All(vec2 o, float r, vec2 p);\n\nfloat Cathode(vec2 c, float r, vec2 p);\n\nfloat Anode(vec2 c, float r, vec2 p);\n\nfloat circle(vec2 c, float r, vec2 p);\n\nmat3 Rotate2D(float theta)\n{\n    return mat3(cos(theta), -sin(theta), 0.0,\n                sin(theta), cos(theta), 0.0,\n                0.0, 0.0, 1.0);\n}\n\nmat3 Transform2D(vec2 c)\n{\n    mat3 transform2D = mat3(1.0, 0.0, 0.0, \n                            0.0, 1.0, 0.0,\n                            c.x, c.y, 1.0);\n    return transform2D;\n}\n\n\nmat3 Rotate2D(vec2 c, float theta)\n{\n    mat3 rotation2D = Transform2D(c) * Rotate2D(theta) * Transform2D(-c);\n    return rotation2D;\n}\n\nfloat V2Angle2D(vec2 l, vec2 r)\n{\n    float value = dot(l, r) / (length(l) * length(r));\n    value = min(max(-1.0, value), 1.0);\n    return acos(value);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord;\n    float theta = iTime * pi / 4.0;\n    vec2 c = iResolution.xy / 2.0;\n    mat3 rotation = Rotate2D(c, theta);\n    // Output to screen\n    vec4 taichi = TaiChi(c, 200.0, rotation, uv);\n    fragColor = mix(vec4(0.1, 0.3, 0.5, 1.0), taichi, taichi.a);\n}\n\nvec4 TaiChi(vec2 c, float r, mat3 rotation, vec2 p)\n{\n    vec4 YinColor = vec4(0.0, 0.0, 0.0, 1.0);\n    vec4 YangColor = vec4(1.0, 1.0, 1.0, 1.0);\n\n    float isAll = All(c, r, p);\n    float div = Divide(c, r, rotation, p);\n    vec3 cathodeC3D = rotation * vec3(c.x + r / 4.0, c.y, 1.0);\n    vec3 anodeC3D = rotation * vec3(c.x - r / 4.0, c.y, 1.0);\n    vec2 cathodeC = cathodeC3D.xy;\n    vec2 anodeC = anodeC3D.xy;\n    float oder = 12.0;\n    float isCathode = Cathode(cathodeC, oder, p);\n    float isAnode = Anode(anodeC, oder, p);\n    float isYin = (1.0 - div) * isAll + isCathode - isAnode;\n    float isYang = div * isAll - isCathode + isAnode;\n\n    return isYin * YinColor + isYang * YangColor;\n}\n\nfloat All(vec2 o, float r, vec2 p)\n{\n    float dis = circle(o, r, p);\n    return 1.0 - smoothstep(-1.0, 1.0, dis);\n}\n\nfloat Divide(vec2 c, float r, mat3 rotation, vec2 p)\n{\n    vec3 lf3D = rotation * vec3(c.x, c.y - r, 1.0);\n    vec3 rh3D = rotation * vec3(c.x, c.y + r, 1.0);\n    vec3 nor3D = rotation * vec3(c.x - r, c.y, 1.0);\n    vec2 lf = lf3D.xy;\n    vec2 rh = rh3D.xy;\n    vec2 nor = nor3D.xy;\n    vec2 pv = p - c;\n    vec2 lfv = lf - c;\n    vec2 rhv = rh - c; \n    vec2 norv = nor - c;\n    \n    float thetaLf = V2Angle2D(lfv, pv);\n    float thetaRh = V2Angle2D(rhv, pv);\n    float thetaNor = V2Angle2D(norv, pv);\n    \n    float rhoLf = thetaLf * r / pi;\n    float rhoRh = thetaRh * r / pi;\n\n    float disLf = rhoLf - length(pv);\n    float disRh = length(pv) - rhoRh;\n    float isYangLf = smoothstep(-1.0, 1.0, disLf);\n    float isYangRh = smoothstep(-1.0, 1.0, disRh);\n\n    float isLf = step(pi / 2.0 , thetaNor);\n    return isLf * isYangLf + (1.0 - isLf) * isYangRh; \n}\n\nfloat Cathode(vec2 c, float r, vec2 p)\n{\n    float dis = circle(c, r, p);\n    return 1.0 - smoothstep(-1.0, 1.0, dis);\n}\n\nfloat Anode(vec2 c, float r, vec2 p)\n{\n    float dis = circle(c, r, p);\n    return 1.0 - smoothstep(-1.0, 1.0, dis);\n}\n\nfloat circle(vec2 o, float r, vec2 p)\n{\n    return length(p-o) - r;\n}","name":"Image","description":"","type":"image"}]}