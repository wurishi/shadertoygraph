{"ver":"0.1","info":{"id":"Dd3yW4","date":"1695039944","viewed":102,"name":"CNJ_SA2023_final_2D_demo","username":"abazen","description":"Demo shader for the SIGGRAPH Asia 2023 conference track paper ``Curl Noise Jittering'' by Andreas Bærentzen, Jeppe  Revall Frisvad, and Jonas Martinez.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["worley","proceduraltexture","jittering"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// ---------------------------------------------------------\n// Demo Program for the conference track SIGGRAPH Asia paper \n// ``Curl Noise Jittering'' by Andreas Bærentzen, Jeppe \n// Revall Frisvad, and Jonas Martinez.\n//\n// This shader can be used to generate all four images from \n// Figure 5 in the paper.\n//\n// Click and hold mouse button to switch from curl noise \n// jittering to normal jittering.\n//\n// By commenting in/out various lines, it is possible to\n// activate other features.\n//\n// Copyright (C) 2023, Andreas Bærentzen, Jeppe Revall \n// Frisvad, and Jonas Martinez.\n//\n// This program is free software: you can redistribute it \n// and/or modify it under the terms of the GNU Affero \n// General  Public License as published by the Free Software \n// Foundation, either version 3 of the License, or (at your \n// option) any later version.\n//\n// This program is distributed in the hope that it will be \n// useful,but WITHOUT ANY WARRANTY; without even the implied \n// warrantyof MERCHANTABILITY or FITNESS FOR A PARTICULAR \n// PURPOSE. See the GNU Affero General Public License for \n// more details.\n//\n// You should have received a copy of the GNU Affero General \n// Public License along with this program. If not, see \n// <https://www.gnu.org/licenses/>.\n// ---------------------------------------------------------\n\n\nconst float PI = 3.141592653589793;\n\n// Map a 2D point to a random 2D vector\n// This hashing function is adapted from the paper: \n// M. Teschner, B. Heidelberger, M. Müller, D. Pomeranerts, \n// M. Gross, \"Optimized Spatial Hashing for Collision Detection \n// of Deformable Objects\", Vision, Modeling, Visualization \n// VMV 2003\nvec2 hash2d(int si, int sj) {\n\tuint p1 = 73856093u;\n\tuint p2 = 19349663u;\n\tuint p3 = 83492791u;\n\tuint K = 93856263u;\n\tuint i = uint(si);\n\tuint j = uint(sj);\n\tuint h1 = ((i * p1) ^ (j * p2)) % K;\n\tuint h2 = ((j * p1) ^ (i * p3)) % K;\n\treturn vec2(h1,h2) / float(K) - 0.5;\n}\n\n// Compute the gradient of Perlin Noise\nvec2 perlin_noise_grad( vec2 x ) {\n\tvec2 i = floor(x);\n\tvec2 f = x-i;\n\n\tvec2 u = f*f*f*(f*(f*6.0-15.0)+10.0);\n\tvec2 du = 30.0*f*f*(f*(f-2.0)+1.0);\n    \n\tvec2 ga = hash2d(int(i.x), int(i.y));\n\tvec2 gb = hash2d(int(i.x)+1, int(i.y));\n\tvec2 gc = hash2d(int(i.x), int(i.y)+1);\n\tvec2 gd = hash2d(int(i.x)+1, int(i.y)+1);\n    \n\tfloat va = dot( ga, f - vec2(0.0,0.0) );\n\tfloat vb = dot( gb, f - vec2(1.0,0.0) );\n\tfloat vc = dot( gc, f - vec2(0.0,1.0) );\n\tfloat vd = dot( gd, f - vec2(1.0,1.0) );\n\n\tvec2 grd =  ga + u[0]*(gb-ga) + u[1]*(gc-ga) + u[0]*u[1]*(ga-gb-gc+gd) + (vec2(u[1],u[0])*(va-vb-vc+vd) + vec2(vb,vc) - va)*du;\n\treturn grd;\n}\n\n// Approximate number of cells in a horizontal row.\n// Increase to see more cells\nfloat N_cells = 20.0;\n// change to 25 for resolution of bottom row of Figure 5.\n\n// Step length used for streamline tracing (t)\n// Increase this to make point placement more random, decrease to make regular.\nfloat step_len = 1.1; // Useful range approx [0-4]\n\n// Inverse of noise scale (1.0/s). If s is big, the noise changes slowly.\nfloat inv_noise_scale = 1.0/2.9;\n\n// Returns a vector in the Curl Noise vector field\nvec2 V(in vec2 x, int offset_index) {\n    vec2 g = perlin_noise_grad(x*N_cells*inv_noise_scale);\n    return vec2(-g.y, g.x);\n}\n\n// Use fourth order Runge-Kutta to trace a streamline for a given\n// time step. Note that since the vector field is the curl noise\n// vector field, this function is where the actual jittering takes\n// place.\nvec2 RK4(in vec2 x, int offset_index) {\n    float dt = step_len/(N_cells);\n\tvec2 a = dt * V(x, offset_index);\n\tvec2 b = dt * V(x+a/2.0, offset_index);\n\tvec2 c = dt * V(x+b/2.0, offset_index);\n\tvec2 d = dt * V(x+c, offset_index);\n    return x + (a+2.0*b+2.0*c+d)/6.0;\n}\n\n\n// Compute Worley noise by Curl Noise Jittering a set of points \n// (the vertices of a regular triangle mesh)\nvec4 worley_noise(vec2 uv)\n{\n    vec2 delta = vec2(1.0/N_cells, sin(PI/3.0)/N_cells);\n    vec2 pt = uv/delta;\n    int cellj = int(round(pt.y));\n    if (cellj%2==1)\n        pt.x -= 0.5;\n    int celli = int(round(pt.x));\n\n    vec4 d = vec4(100000.0);\n    for (int i = celli-2; i <= celli+2; i++) {\n        for (int j = cellj-2; j <= cellj+2; j++) {\n            vec2 cell_jitt = delta*vec2(float(i)+(abs(j%2)==1?0.5:0.0),j);\n            if (iMouse.z<=0.0) {\n                // curl noise jittering (right column of Figure 5)\n                cell_jitt = RK4(cell_jitt,0);\n            }else{\n                //random jittering (left column of Figure 5)\n                cell_jitt += (1.0/N_cells) * hash2d(i,j);\n            }\n            float d0 = distance(cell_jitt, uv);\n            if (d0 < d.x) { d.y=d.x; d.x=d0; d.zw = cell_jitt;}\n            else if (d0<d.y) {d.y=d0;}\n        }\n    }\n    return d;\n}\n\n// Viridis approximation, Jerome Liard, August 2016\n// https://www.shadertoy.com/view/XtGGzG\nfloat saturate( float x ) { return clamp( x, 0.0, 1.0 ); }\nvec3 viridis_quintic( float x )\n{\n\tx = saturate( x );\n\tvec4 x1 = vec4( 1.0, x, x * x, x * x * x ); // 1 x x2 x3\n\tvec4 x2 = x1 * x1.w * x; // x4 x5 x6 x7\n\treturn vec3(\n\t\tdot( x1.xyzw, vec4( +0.280268003, -0.143510503, +2.225793877, -14.815088879 ) ) + dot( x2.xy, vec2( +25.212752309, -11.772589584 ) ),\n\t\tdot( x1.xyzw, vec4( -0.002117546, +1.617109353, -1.909305070, +2.701152864 ) ) + dot( x2.xy, vec2( -1.685288385, +0.178738871 ) ),\n\t\tdot( x1.xyzw, vec4( +0.300805501, +2.614650302, -12.019139090, +28.933559110 ) ) + dot( x2.xy, vec2( -33.491294770, +13.762053843 ) ) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.x;\n    // To unfreeze time, uncomment the line below and comment out the line above.\n    //vec2 uv = fragCoord/iResolution.x + iTime*iTime * vec2(0.01,0.005);\n\n    vec4 d = worley_noise(uv);\n\n    //cell-like Worley noise (shader corresponding to Figure 5 top row)\n    fragColor.rgb = vec3(viridis_quintic(d.x / length(vec2(1.0 / N_cells))));\n    fragColor.rgb += 0.25*vec3(1.0-smoothstep(0.003,0.005, d.x),0,0);\n\n    // Multi-colored Worley (shader corresponding to Figure 5 bottom row)\n    // fragColor.rgb = vec3(fract(3.0*d.zw*N_cells),0.25) + vec3(.25);\n    // fragColor.rgb += vec3(-1.2) * smoothstep(0.18 / N_cells, 0.1 / N_cells, d.y-d.x);\n\n}","name":"Image","description":"","type":"image"}]}