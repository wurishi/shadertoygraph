{"ver":"0.1","info":{"id":"ddXfDn","date":"1688613829","viewed":47,"name":"aether/whoa","username":"aetherclouds","description":"my first attempt at these","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["blank"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// play with these parameters!! \nconst float mouseFac = 300.;\nconst float sinSize = 5.;\nconst float sinSpeed = .1;\nconst float uvSize = .9;\nconst float colorSpeed = -.1;\nconst float colorSize = .7;\nconst float detailLevel = 4.;\nconst float detailType = .7;\nconst float detailColOffset = -.2;\nconst float detailColDepth = 1.;\nconst float sidescrollSpeed = 0.05;\nconst float parallaxDepth = .3;\nconst float distWarp = 2.;\n\n// SNIPPET FROM https://iquilezles.org/articles/palettes/\nvec3 palette(in float t)\n{\n    /*\n    vec3 a = vec3(0.5, 0.5, 0.5);\n    vec3 b = vec3(0.5, 0.5, 0.5);\n    vec3 c = vec3(2.0, 1.0, 0.0);\n    vec3 d = vec3(0.50, 0.20, 0.25); \n    */\n    \n    vec3 a = vec3(0.5, 0.5, 0.5);\n    vec3 b = vec3(0.5, 0.5, 0.5);\n    vec3 c = vec3(1.0, 1.0, 1.0);\n    vec3 d = vec3(0.263, 0.416, 0.557);\n    \n\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    float lowSide = min(iResolution.x, iResolution.y);\n    vec3 finalColor = vec3(0., 0., 0.);\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv0 = (fragCoord*2.-iResolution.xy)/lowSide/uvSize;\n    float d0 = length(uv0);\n\n    vec2 uv = uv0;\n    // go right\n    uv[0] += iTime*sidescrollSpeed;\n    uv -= vec2(iMouse.xy) / mouseFac;\n    for (float i=1.; i<=detailLevel; i++) {\n        // we'll already have moved the previous uv by some offset,\n        // so we actually \"compensate\", pulling it back to the center\n        vec2 mouseCompensate = iMouse.xy/mouseFac*-parallaxDepth*(i-1.);\n        // TODO: doesn't look seamless, not sure how 2 fix\n        // uv = fract((uv/detailType)-mouseCompensate)-.5;\n        uv = fract((uv/detailType))-.5;\n\n        float d = length(uv);\n        // \"box\" distance\n        float dq = max(abs(uv[0]), abs(uv[1]));\n\n        vec3 col = palette((d0 + i*detailColOffset - iTime*colorSpeed)/colorSize);\n        d = sin(d*sinSize+(iTime*sinSpeed+d0*distWarp));\n        // boxxy look\n        // d = sin(dq*sinSize+(iTime*sinSpeed+d0*distWarp));\n\n        // d = d/2.+.5; // normalize sine; [-1, 1] -> [0, 1]\n        d = abs(d);\n        // d = smoothstep(0.3, 0.7, d);\n        d = .1/d;\n\n        // THIS IS GLITCHY but looks cool\n        // col = palette(d + iTime + i*detailColOffset - iTime*colorSpeed);\n        col *= pow(d, 1.3);\n        // because we're adding, create \"depth\" to avoid col > 1\n        finalColor += col/(i*detailColDepth);\n    }\n\n    // Output to screen\n    fragColor = vec4(finalColor, 1.);\n}","name":"Image","description":"","type":"image"}]}