{"ver":"0.1","info":{"id":"Mt3cz2","date":"1533198028","viewed":144,"name":"isPrime XOR triplets","username":"rodolphito","description":"Riding the recent prime XOR wave...\n\nMouse is camera, WASD is movement, arrow key layout define available in Buf A. Look at like 33 in Image, try commenting it out to see Pythagorean triplets.","likes":4,"published":1,"flags":48,"usePreview":0,"tags":["coprime"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","previewfilepath":"/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Copyright (c) 2018 rodolphito\n\nconst int MAX_RAY_STEPS = 100;\nconst float FAR = float(MAX_RAY_STEPS) / sqrt(3.0);\nconst float INVFAR = 1.0/FAR;\n\nint GCD(int a, int b)\n{\n    for (int i = 0; i < 32; i++)\n    {\n        if (b != 0)\n        {\n            int t = b;\n            b = a % b;\n            a = t;\n        }\n        else break;\n    }\n    return a;\n}\nbool isPrime(int num)\n{\n    if (num <= 1) return false;\n    if (num % 2 == 0 && num > 2) return false;\n    for(int i = 3; i < int(floor(sqrt(float(num)))); i += 2)\n        if(num%i == 0) return false;\n    return true;\n}\n\nbool getVoxel(ivec3 v)\n{\n    v = abs(v);\n    return isPrime(v.x^v.y^v.z);\n    //return GCD(GCD(v.x,v.y),v.z)!=1;\n    float len = length(vec3(v));\n    return abs(len - float(int(len))) < 0.00001;\n}\n\nvoid mainImage(out vec4 color,vec2 co)\n{\n\tvec4 uv = (vec4(co,iMouse.xy)-0.5*iResolution.xyxy)/iResolution.x;\n    vec4 rot = texelFetch(iChannel0, ROT, 0);\n    vec4 pos = texelFetch(iChannel0, POS, 0);\n    if (length(iMouse.xy) < 10.0)\n    {\n        pos = vec4(4.01,sin(iTime)*4.0+4.0,iTime*5.0,0.0);\n        rot = vec4(-sin(iTime*0.5)*0.6,cos(iTime*0.3)*0.3,0.0,0.0);\n    }\n\tvec3 rd = r(vec3(uv.xy, 0.5), -rot.xy);\n\tvec3 ro = pos.xyz;\n\tvec2 mo = 10.0*uv.zw;\n\trd = normalize(rd);\n\t\n\tvec3 voxel = floor(ro);\n\tvec3 id = 1.0 / rd;\n\tvec3 rs = sign(rd);\n\tvec3 sh = (step(rd,vec3(0.0))-ro)*id;\n\tvec3 sd = (max(rs,0.0) - fract(ro)) * id;\n\tvec3 mk = vec3(0.0);\n\tvec3 hit = vec3(0.0);\n\tint i;\n\tfloat t = miss;\n    // Good old voxel traversal\n    // offset by .5 to save some adds\n\tfor (i = 0; i < MAX_RAY_STEPS; i++)\n\t{\n        // using min here because faaast\n\t\tmk = step(sd,min(sd.yzx,sd.zxy)) * rs;\n\t\tsd += mk * id;\n\t\tvoxel += mk;\n\t\tif (getVoxel(ivec3(voxel)))\n\t\t{\n\t\t\tvec3 vt = voxel*id+sh;\n\t\t\tt = max(max(vt.x, vt.y), vt.z);\n\t\t\thit = ro+rd*t;\n            break;\n\t\t}\n\t}\n    vec3 col;\n    vec3 fog = vec3(0.7,0.8,0.9);\n    vec3 light = normalize(vec3(0.4,0.2,0.7));\n    \n    if (i == MAX_RAY_STEPS) col = fog;\n    else\n    {\n        vec3 normal = mk;\n        vec3 tex = texture(iChannel1, 0.5*vec2(dot(normal.yzx, hit), dot(normal.zxy, hit))).rgb;\n        tex *= tex;\n        float ndotv = dot(rd,normal);\n        float fresnel = 1.0 - abs(ndotv);\n        // Hacky fresnel (should be pow 5)\n        fresnel *= fresnel; fresnel *= fresnel;\n        // Hacky Lambert-wrapped lighting\n        col = tex*vec3(0.5 + 0.5*dot(normal, light));\n        // Fresnel is fog colored\n        col += fresnel * fog * 0.6;\n        float ff = min(1.0, t*INVFAR);\n        // Pow 4 fog falloff to maximize visibility\n        ff *= ff; ff *= ff;\n        col = mix(col.rgb,fog,vec3(ff));\n    }\n    // Hacky gamma correction (should be pow .4545)\n    color = vec4(sqrt(col),1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Nothing interesting here, move along...\n// Just camera and movement stuff.\n#define MOUSESENS 8.0\n#define SPEED 0.1\n#define BOOST 0.1\n#define KEY_X texture(iChannel1,vec2(88.5/256.0,0.25)).x\n#define SHIFT texture(iChannel1,vec2(16.5/256.0,0.75)).x\n#define SPACE texture(iChannel1,vec2(32.5/256.0,0.25)).x\n\n#define QWERTY\n\n#if defined(QWERTY)\n#define KEY_W texture(iChannel1,vec2(87.5/256.0,0.25)).x\n#define KEY_A texture(iChannel1,vec2(65.5/256.0,0.25)).x\n#define KEY_S texture(iChannel1,vec2(83.5/256.0,0.25)).x\n#define KEY_D texture(iChannel1,vec2(68.5/256.0,0.25)).x\n#define KEYLF texture(iChannel1,vec2(37.5/256.0,0.25)).x\n#define KEYUP texture(iChannel1,vec2(38.5/256.0,0.25)).x\n#define KEYRT texture(iChannel1,vec2(39.5/256.0,0.25)).x\n#define KEYDN texture(iChannel1,vec2(40.5/256.0,0.25)).x\n#else\n#define KEYLF texture(iChannel1,vec2(65.5/256.0,0.25)).x\n#define KEYUP texture(iChannel1,vec2(87.5/256.0,0.25)).x\n#define KEYRT texture(iChannel1,vec2(68.5/256.0,0.25)).x\n#define KEYDN texture(iChannel1,vec2(83.5/256.0,0.25)).x\n#define KEY_W texture(iChannel1,vec2(38.5/256.0,0.25)).x\n#define KEY_A texture(iChannel1,vec2(37.5/256.0,0.25)).x\n#define KEY_S texture(iChannel1,vec2(40.5/256.0,0.25)).x\n#define KEY_D texture(iChannel1,vec2(39.5/256.0,0.25)).x\n#endif\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord)\n{\n    ivec2 texel = ivec2(fragCoord);\n    if (texel != POS && texel != ROT) discard;\n    vec4 rot = texelFetch(iChannel0, ROT, 0);\n    vec4 pos = texelFetch(iChannel0, POS, 0);\n    pos.w = max(step(0.0,iMouse.z) - pos.w,0.0);\n    if (texel == ROT)\n    {\n        vec2 mouse = iMouse.xy / iResolution.xy;\n        rot.zw += (mouse - rot.zw) * pos.w;\n        rot.xy += (mouse - rot.zw) * step(0.0,iMouse.w) * MOUSESENS;\n        rot.xy += vec2(KEYRT-KEYLF,KEYUP-KEYDN) * MOUSESENS * 0.003;\n        fragColor = rot;\n    }\n\telse if (texel == POS)\n    {\n        pos.xyz += r(vec3(KEY_D - KEY_A, SPACE - KEY_X, KEY_W - KEY_S),-rot.xy) * (BOOST * SHIFT + SPEED);\n        fragColor = pos;\n    }\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define POS ivec2(0,0)\n#define ROT ivec2(1,0)\n//#define NEWTON_RAPHSON\n\n// The Pi Vector (0,π/2,π,2π)\nvec4 pi = vec4(0,2,4,8)*atan(1.0);\n\n// The Third Vector (0,1/3,2/3,1)\nvec4 it = vec4(0.0,1.0,2.0,3.0)/3.0;\n\n// Very far away\nfloat miss = 9e9;\n\n// Solve a linear equation (Oof, so difficult...)\nfloat linear(float a, float b)\n{\n\treturn -b/a;\n}\n\n// Solve a quadratic (This is a little easier!)\nvec2 quadratic(float a, float b, float c)\n{\n\tfloat d = b*b - 4.0*a*c;\n\tif (d < 0.0) return vec2(miss);\n\td = sqrt(d)*sign(b);\n\tb = -0.5*(b + d);\n\treturn vec2(b/a, c/b);\n}\n\n// Solve a cubic (Piece of cake!)\nvec3 _cubic(float a, float b, float c, float d)\n{\n\t// abs(a) > abs(d) is guaranteed\n    // I could use a little help here...\n    // These constants were chosen by looking at artifacts\n    // and adjusting numbers until most of them were gone.\n    // The gyroid happens to behave nicely, but try any\n    // other potential and you will start seeing missing\n    // 'faces' in many places. I need a robust cubic solver.\n    if (abs(d) < 1e-7) return vec3(quadratic(a, b, c), miss); \n\tif (abs(a) < 0.005) return vec3(quadratic(b, c, d), miss);\n\tfloat tmp = 1.0/a;\n    a = b*tmp*it.y;\n    b = c*tmp;\n    c = d*tmp;\n\tfloat q = a*a - b*it.y;\n\tfloat r = a*a*a - 0.5*(a*b - c);\n\tfloat r2 = r*r;\n    float q3 = q*q*q;\n\tif (r2 < q3)\n\t{\n        vec3 f,f1,f2,t = -2.0*sqrt(q)*cos(acos(r*inversesqrt(q3))*it.y + it.z*pi.xzw) - a;\n        #if defined(NEWTON_RAPHSON)\n        // Newton Raphson\n        f = t*t*t+3.0*a*t*t+b*t+c;\n        f1 = 9.0*t*t+a*t+b;\n        //f2 = 18.0*t+a;\n        t -= f/f1;\n        //t -= (2.0*f*f1)/(2.0*f1*f1-f*f2);\n        #endif\n        return t;\n\t}\n\telse\n\t{\n\t\tfloat e = pow(abs(r) + sqrt(r2-q3), it.y);\n\t\tfloat f,f1,f2,t = -a-(e + q/e)*sign(r);\n        #if defined(NEWTON_RAPHSON)\n        // Newton Raphson, but modified with multiplicity 3\n        f = t*t*t+3.0*a*t*t+b*t+c;\n        f1 = 9.0*t*t+a*t+b;\n        //f2 = 18.0*t+a;\n        t -= 3.0*f/f1;\n        //t -= (2.0*f*f1)/(2.0*f1*f1-f*f2);\n        #endif\n        return vec3(t, miss, miss);\n\t}\n}\n\nvec3 cubic(float a, float b, float c, float d)\n{\n    // Avoid calling cubic with small a\n\tif (abs(a) > abs(d)) return _cubic(a,b,c,d);\n\telse return 1.0/_cubic(d,c,b,a);\n}\n\n// Rotation function\nvec3 r(vec3 v, vec2 r)\n{\n\tvec2 c = cos(r);\n\tvec2 s = sin(r);\n\tfloat ypz = v.y*s.y + v.z*c.y;\n\treturn vec3(v.x*c.x - s.x*ypz,\n\t\t\t\tv.y*c.y - v.z*s.y,\n\t\t\t\tv.x*s.x + c.x*ypz);\n}","name":"Common","description":"","type":"common"}]}