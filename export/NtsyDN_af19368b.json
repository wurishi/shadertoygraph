{"ver":"0.1","info":{"id":"NtsyDN","date":"1648050270","viewed":79,"name":"Exercice Raymarching","username":"Ghostmoonk","description":"Exercice","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Remerciement Ã  Soren Pichot pour le code\n\n#define PI 3.14\n\nmat2 rot(float a){\n    float c = cos(a);\n    float s = sin(a);\n    return mat2(c, -s, s, c);\n}\n\nvec2 opSub2(vec2 d1,vec2 d2) { return(-d1.x > d2.x) ? -d1 : d2;}\n\nfloat sdCappedCylinder( vec3 p, float h, float r )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdSphere(vec3 pos, float r){\n    return length(pos) - r;\n}\n\nfloat Union(float d1, float d2){\n    return min(d1,d2);\n}\n\nvec2 opUnion2(vec2 d1, vec2 d2){\n    return(d1.x < d2.x) ? d1 : d2;\n}\n\nfloat sdPlane( vec3 p, vec3 n, float h )\n{\n  // n must be normalized\n  return dot(p,n) + h;\n}\n\nfloat sdBox(vec3 p , vec3 b){\n    vec3 q = abs(p) - b;\n    return length(max(q, .0)) + min(max(q.x, max(q.y, q.z)), 0.0);\n}\n\nvec2 Map(vec3 pos){\n    pos.xy *= rot(3.14 + iTime/1.0);\n\n    vec2 volume = vec2(.0);\n    vec2 floor = vec2(sdBox(pos, vec3(2.0,2.0,0.1)),0.0);\n    vec2 rail1 = vec2(sdBox(pos+vec3(0.5,0.0,-0.3),vec3(.1,2.0,0.1)),1.0);\n    vec2 rail2 = vec2(sdBox(pos+vec3(-0.5,0.0,-0.3),vec3(.1,2.0,0.1)),1.0);\n    \n    //pos.zx *= rot(3.14/2.0);\n    volume = opUnion2(floor, rail2);\n    volume = opUnion2(volume, rail1);\n    \n    for(int wood = 0; wood < 4; wood++){\n        vec2 woodBox = vec2(sdBox(pos + vec3(.0, .35 + float(wood) - 4.0/2. + float(wood) * .05,.0),vec3(.8,.2,0.2)),2.0);\n        \n        volume = opUnion2(volume, woodBox);\n    }\n    \n    pos.z += -.75;\n    //Train\n    vec2 train = vec2(.0);\n    vec2 main = vec2(sdBox(pos + vec3(.0,1.0,-1.5), vec3(.5,.5,.5)),3.0);\n    vec2 bottom = vec2(sdBox(pos + vec3(.0,0.0,-0.5), vec3(.5,2.0,.5)),3.0);\n    vec2 front = vec2(sdCappedCylinder(pos + vec3(.0,-.5,-1.5),.4,1.2));\n    vec3 tempPos = pos;\n    tempPos.yz *= rot(3.14/2.0);\n    vec2 top = vec2(sdCappedCylinder(tempPos + vec3(.0,2.,-1.25),.2,.1));\n    vec2 topAbove = vec2(sdCappedCylinder(tempPos + vec3(.0,2.2,-1.25),.3,.05));\n    vec2 topAboveInSide = vec2(sdCappedCylinder(tempPos + vec3(.0,2.3,-1.25),.2,.1));\n    topAbove = opSub2(topAboveInSide, topAbove);\n    train = main;\n    \n    vec2 topCylinder1 = vec2(sdCappedCylinder(tempPos + vec3(.0,2.0,-.55),.1,.10));\n    vec2 topCylinder2 = vec2(sdCappedCylinder(tempPos + vec3(.0,2.0,-.05),.1,.10));\n    train = opUnion2(train, front);\n    train = opUnion2(train, bottom);\n    train = opUnion2(train, top);\n    train = opUnion2(train, topAbove);\n    train = opUnion2(train,opUnion2(topCylinder1,topCylinder2));\n    volume = opUnion2(volume,train);\n    \n    tempPos.xy *= rot(3.14/2.0);\n    //Wheels\n    float maxWheels = 3.0;\n    for(int i = 0; i < 2; i++){\n        for(int wheel = 0; wheel < int(maxWheels); wheel++){\n            vec2 wheelShape = vec2(sdCappedCylinder(tempPos + vec3(.0,-.5 + float(i),-maxWheels/2. + float(wheel) + float(wheel)/maxWheels),.5,.2));\n            volume = opUnion2(volume, wheelShape);\n        }\n    }\n\n    //volume = floor;\n    return volume;\n}\n\nvec2 CastRay(vec3 ro, vec3 rd){\n    \n    float contact = 0.0;\n    \n    for(int m = 0; m < 64; m++)\n    {\n        vec2 ray = Map(ro + rd * contact);\n        \n        if(ray.x < (0.0001 * contact)){\n            return vec2(float(m)/64., ray.y);\n        }\n        contact += ray.x;\n    }\n    \n    return vec2(-1.0,.0); \n}\n\nvec3 render(vec3 ro, vec3 rd){\n    \n    vec2 contact = CastRay(ro, rd);\n    vec3 col = vec3(1.0);\n    \n    if(contact.x == -1.){\n        col = vec3(0.0);\n    }\n    else{\n        \n        col = vec3(1.0);\n        if(contact.y == 0.0){\n            col = vec3(0.5,1.0,0.0);\n        }\n        if(contact.y == 1.0){\n            col = vec3(1.0,1.0,1.0);\n        }\n        if(contact.y == 2.0){\n            col = vec3(.8,0.5,0.0);\n        }\n        float depth = vec3(1.0 - contact.x).r;\n        col *= depth;\n        //col = vec3(1.0 - contact.x) * vec3(sin(1.0 - iTime) /2.0 + .5,sin(iTime - 1.0) / 2.0 + .5,0.0);\n    }\n    \n    return col ;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = 2.0 * fragCoord/iResolution.xy  - 1.0;\n    uv.x *= iResolution.x/iResolution.y;\n\n    vec3 col = vec3(0.);\n    \n    vec3 camPos = vec3(0.0,5.0,5.0);\n    float Pi4 = PI;\n    //Rotate by x \n    /*camPos = mat3(\n        vec3(1.0,0.0,0.0),\n        vec3(0.0, cos(Pi4), -sin(Pi4)),\n        vec3(0.0, sin(Pi4), cos(Pi4))) * camPos;*/\n        \n    //Rotate by y\n    /*camPos = mat3(\n        vec3(cos(Pi4),0.0,sin(Pi4)),\n        vec3(0.0, 1.0 , 0.0),\n        vec3(-sin(Pi4), 0.0, cos(Pi4))) * camPos;*/\n        \n    //Rotate by z\n    /*camPos = mat3(\n        vec3(cos(Pi4),-sin(Pi4),0.0),\n        vec3(sin(Pi4), cos(Pi4) , 0.0),\n        vec3(0.0, 0.0, 1.0)) * camPos;*/\n        \n    vec3 camTarget = vec3(0.0,0.0,0.0);\n    \n    vec3 forward = normalize(camTarget - camPos);\n    vec3 right = normalize(cross(vec3(0.0, -1.0, 0.0), forward));\n    vec3 up = normalize(cross(forward, right));\n    vec3 viewDir = normalize(uv.x * right + uv.y * up + 2.0 * forward);\n    \n    col = render(camPos, viewDir);\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}