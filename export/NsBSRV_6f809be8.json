{"ver":"0.1","info":{"id":"NsBSRV","date":"1620539244","viewed":67,"name":"Gradient-based Distance Demo","username":"jllusty","description":"Uses the gradient-based distance approximation to solutions of an implicit function for illustration.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["gradient","distance","hsv","superellipse","superfunction"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// super formula\nfloat superformula(in vec2 x, float a, float b, float m, float n1, float  n2, float n3)\n{\n    float r = length(x);\n    float ang = atan(x.y,x.x);\n    float t1 = pow(abs(cos(m*ang/4.)/a), n2);\n    float t2 = pow(abs(sin(m*ang/4.)/a), n3);\n    return r - pow(t1+t2,-1./n1);\n}\n\n// super ellipse\nfloat superellipse(in vec2 x, float a, float b, float m, float n)\n{\n    return pow(abs(x.x/a),m) + pow(abs(x.y/b),n) - 1.0;\n}\n// some interesting examples\nfloat f1(in vec2 x) {\n    return superellipse(x, 1.0, 1.0, 2.0, 2.0);\n}\nfloat f2(in vec2 x) {\n    return superellipse(x, 1.0, 1.0, 1.0, 1.0);\n}\nfloat f3(in vec2 x) {\n    return superformula(x, 1.0, 1.0, 16., 0.5, 0.5, 16.);\n}\n\n// interpolating functions, Hat Functions\nfloat l1(float t) {\n    return max(1.-abs(t+1.),0.);\n}\nfloat l2(float t) {\n    return max(1.-abs(t),0.);\n}\nfloat l3(float t) {\n    return max(1.-abs(t-1.),0.);\n}\n\n// reinterpret time\nfloat retime(float time) {\n    float x = 6.-12.*abs(fract(time/12.)-0.5);\n    float y = max(1.-abs(x),0.)+max(1.-abs(x-1.),0.)-max(1.-abs(x-5.),0.)-max(1.-abs(x-6.),0.);\n    return -y;\n}\n\n// implicit function f(x,y) = 0\nfloat f(vec2 x)                                 \n{\n    // interpolate between our examples\n    float t = retime(iTime);\n    return l1(t)*f1(x) + l2(t)*f2(x) + l3(t)*f3(x);\n}\n\n// approximate gradient\nvec2 grad( in vec2 x )\n{\n    vec2 h = vec2( 0.01, 0.0 );\n    return vec2( f(x+h.xy) - f(x-h.xy),\n                 f(x+h.yx) - f(x-h.yx) )/(2.0*h.x);\n}\n\n// Smooth HSV to RGB conversion \nvec3 hsv2rgb_smooth( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n\trgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n\n// main function\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // convert pixel coords to scaled normalized coordinates\n    vec2 uv = 2.0*(2.0*fragCoord-iResolution.xy)/iResolution.y;\n\n    // evaluation the implicit form f(x,y) at our coordinate\n    float v = f(uv);\n    // evaluate the gradient\n    vec2  g = grad(uv);\n    // distance approximation\n    float de = abs(v)/length(g);\n    \n    // interpolate between two colorings\n    // coloring 1: rainbow distance to curve\n    float H = fract(de);\n    float S = 1.;\n    float V = 1.;\n    vec3 rgb1 = hsv2rgb_smooth(vec3(H,S,V));\n    // coloring 2: black if we close to curve\n    float dt = smoothstep(.1,.5,1.-2.*abs(fract(retime(iTime))-0.5));\n    float eps = 0.05;\n    vec3 rgb2 = vec3(smoothstep(1.*eps,2.*eps,de));\n    // interpolation\n    vec3 color = mix(rgb2,rgb1,dt);\n    \n    // output color\n    fragColor = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"}]}