{"ver":"0.1","info":{"id":"MtS3RK","date":"1548095411","viewed":270,"name":"The one ring","username":"Dave","description":"raytracing","likes":16,"published":1,"flags":0,"usePreview":1,"tags":["notag"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","previewfilepath":"/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"struct EL\n{\n    float x, y, rx, ry, dx, dy;\n};\n\nmat3 myInverse( mat3 m )\n{\n    mat3 res;\n    res[0][0] = m[0][0];\n    res[0][1] = m[1][0];\n    res[1][0] = m[0][1];\n    res[1][1] = m[1][1];\n    vec2 t = mat2( res ) * vec2( -m[2][0], -m[2][1] );\n    res[2] = vec3( t, 1.0 );\n    return res;\n}\n\nfloat toEL( in vec2 v, in EL el )\n{\n    mat3 m = mat3(\n        el.dx, el.dy, 0.0,\n        -el.dy, el.dx, 0.0,\n        el.x, el.y, 1.0 );\n    mat3 mi = myInverse( m );\n\n    vec2 t = ( mi * vec3( v, 1.0 ) ).xy;\n    return t.x * t.x / ( el.rx * el.rx ) + t.y * t.y / ( el.ry * el.ry ) - 1.0;\n}\n\nfloat toDash1( vec2 uv )\n{\n\tEL ael[12];\n\tael[0] = EL( 110.0, 117.0, 8.8, 200.3, 0.966, -0.259 );\n\tael[1] = EL( 90.0, 39.0, 72.2, 242.6, 0.966, -0.259 );\n\tael[2] = EL( 161.0, 306.0, 5.0, 11.0, 0.966, -0.259 );\n\tael[3] = EL( 152.0, 278.0, 4.0, 6.0, 1.000, 0.000 );\n\tael[4] = EL( 32.0, 276.0, 112.0, 118.0, 1.000, 0.000 );\n\tfloat d = toEL( uv, ael[0] );\n\td = max( d, -toEL( uv, ael[1] ) );\n\td = min( d, toEL( uv, ael[2] ) );\n\td = min( d, toEL( uv, ael[3] ) );\n    return d;\n}\n\nfloat toDash3( vec2 uv )\n{\n\tEL ael[8];\n\tael[0] = EL( 32.0, 276.0, 112.0, 118.0, 1.000, 0.000 );\n\tael[1] = EL( -17.0, 250.0, 159.0, 163.0, 1.000, 0.000 );\n\tael[2] = EL( 65.0, 362.0, 100.0, 100.0, 1.000, 0.000 );\n\tael[3] = EL( 138.0, 296.0, 4.3, 12.3, 0.966, 0.259 );\n\tael[4] = EL( 243.0, 207.0, 100.0, 126.5, 0.940, -0.342 );\n\tael[5] = EL( 238.0, 140.0, 125.4, 193.2, 0.951, -0.309 );\n\tael[6] = EL( 278.0, 295.0, 100.0, 100.0, 1.000, 0.000 );\n\tael[7] = EL( 180.0, 283.0, 5.7, 9.8, 0.866, -0.500 );\n\tfloat d = toEL( uv, ael[0] );\n\td = max( d, -toEL( uv, ael[1] ) );\n\td = max( d, -toEL( uv, ael[2] ) );\n\td = min( d, toEL( uv, ael[3] ) );\n\td = min( d, toEL( uv, ael[4] ) );\n\td = max( d, -toEL( uv, ael[5] ) );\n\td = max( d, -toEL( uv, ael[6] ) );\n\td = min( d, toEL( uv, ael[7] ) );\n    d = min( d, toDash1( uv ) );\n\treturn d;    \n}\n\nfloat toCharC( vec2 uv )\n{\n    float d = toEL( uv, EL( 106.0, 102.0, 76.0, 100.0, 0.96, -0.25 ) );\n    d = max( d, -toEL( uv, EL( 118.0, 105.0, 71.0, 90.0, 0.97, -0.20 ) ) );\n    d = min( d, toEL( uv, EL( 151.0, 177.0, 10.4, 15.8, -0.788, -0.615 ) ) );\n    return d;\n}\n\nfloat toCharC1( vec2 uv )\n{\n\tfloat d = toEL( uv, EL( 98.0, 100.0, 78.8, 105.5, 0.866, -0.500 ) );\n\td = max( d, -toEL( uv, EL( 88.0, 94.0, 70.0, 95.4, 0.858, -0.513 ) ) );\n\td = min( d, toEL( uv, EL( 46.0, 22.0, 12.0, 19.8, 0.755, 0.656 ) ) );\n\treturn d;\n}\n\nfloat toCharp( vec2 uv )\n{\n    float d = toEL( uv, EL( -303.0, 201.0, 357.0, 379.0, 1.0, 0.0 ) );\n    d = max( d, -toEL( uv, EL( -353.0, 218.0, 410.0, 408.0, 1.0, 0.0 ) ) );\n    d = min( d, toEL( uv, EL( 389.0, 21.0, 359.0, 351.0, 1.0, 0.0 ) ) );\n    d = max( d, -toEL( uv, EL( 435.0, -16.0, 411.0, 404.0, 1.0, 0.0 ) ) );\n    d = min( d, toEL( uv, EL( 145.0, 100.0, 100.0, 100.0, 1.0, 0.0 ) ) );\n    d = max( d, -toEL( uv, EL( 182.0, 90.0, 139.0, 112.0, 1.0, 0.0 ) ) );\n    d = min( d, toEL( uv, EL( 95.0, 68.0, 49.0, 141.0, 0.92, -0.39 ) ) );\n    d = max( d, -toEL( uv, EL( 71.0, 28.0, 51.5, 180.2, 0.92, -0.39 ) ) );\n    return d;\n}\n\nfloat toCharZ( vec2 uv )\n{\n\tEL ael[4];\n\tael[0] = EL( 100.0, 86.0, 87.4, 123.6, 0.799, -0.602 );\n\tael[1] = EL( 67.0, 66.0, 81.6, 147.1, 0.719, -0.695 );\n\tael[2] = EL( 65.0, -174.0, 100.0, 194.2, 0.819, -0.574 );\n\tael[3] = EL( 41.0, -173.0, 104.4, 194.5, 0.739, -0.674 );\n\tfloat d = toEL( uv, ael[0] );\n\td = max( d, -toEL( uv, ael[1] ) );\n\td = min( d, toEL( uv, ael[2] ) );\n\td = max( d, -toEL( uv, ael[3] ) );\n\treturn d;\n}\n\nfloat toCharw( vec2 uv )\n{\n\tEL ael[8];\n\tael[0] = EL( 120.0, -80.0, 74.8, 359.8, 0.875, -0.485 );\n\tael[1] = EL( 117.0, -50.0, 81.7, 390.5, 0.883, -0.469 );\n\tael[2] = EL( 95.0, 101.0, 66.5, 103.5, 0.940, -0.342 );\n\tael[3] = EL( 109.0, 117.0, 52.8, 95.3, 0.914, -0.407 );\n\tael[4] = EL( 215.0, 101.0, 66.8, 103.1, 0.940, -0.342 );\n\tael[5] = EL( 224.0, 116.0, 52.6, 95.7, 0.914, -0.407 );\n\tael[6] = EL( 385.0, 136.0, 100.0, 100.0, 1.000, 0.000 );\n\tael[7] = EL( 388.0, 108.0, 100.0, 146.7, 0.966, -0.259 );\n\tfloat d = toEL( uv, ael[0] );\n\td = max( d, -toEL( uv, ael[1] ) );\n\td = min( d, toEL( uv, ael[2] ) );\n\td = max( d, -toEL( uv, ael[3] ) );\n\td = min( d, toEL( uv, ael[4] ) );\n\td = max( d, -toEL( uv, ael[5] ) );\n\td = min( d, toEL( uv, ael[6] ) );\n\td = max( d, -toEL( uv, ael[7] ) );\n\treturn d;\n}\n\nfloat toCharTilda( vec2 uv )\n{\n\tEL ael[3];\n\tael[0] = EL( 255.0, -7.0, 619.0, 209.0, 1.000, 0.000 );\n\tael[1] = EL( 116.0, -43.0, 1030.2, 229.2, 0.999, 0.052 );\n\tael[2] = EL( 301.0, 125.0, 371.9, 66.7, 0.974, 0.225 );\n\tfloat d = toEL( uv, ael[0] );\n\td = max( d, -toEL( uv, ael[1] ) );\n\td = max( d, -toEL( uv, ael[2] ) );\n\treturn d;\n}\n\nfloat toCharj( vec2 uv )\n{\n\tEL ael[2];\n\tael[0] = EL( -63.0, -82.0, 83.0, 329.0, 0.848, -0.530 );\n\tael[1] = EL( -98.0, -106.0, 88.7, 340.7, 0.829, -0.559 );\n\tfloat d = toEL( uv, ael[0] );\n\td = max( d, -toEL( uv, ael[1] ) );\n\treturn d;\n}\n\nfloat toCurl( vec2 uv )\n{\n\tEL ael[7];\n\tael[0] = EL( 204.0, 181.0, 100.0, 271.1, 0.904, -0.428 );\n\tael[1] = EL( 191.0, 148.0, 92.6, 277.2, 0.912, -0.409 );\n\tael[2] = EL( 284.0, 301.0, 60.0, 60.0, 1.000, 0.000 );\n\tael[3] = EL( 391.0, 38.0, 146.0, 302.2, 0.978, -0.208 );\n\tael[4] = EL( 288.0, 317.0, 45.0, 67.3, 0.996, -0.087 );\n\tael[5] = EL( 256.0, 335.0, 17.0, 16.0, 1.000, 0.000 );\n\tael[6] = EL( 110.0, 99.0, 100.0, 100.0, 1.000, 0.000 );\n\tfloat d = toEL( uv, ael[0] );\n\td = max( d, -toEL( uv, ael[1] ) );\n\td = min( d, toEL( uv, ael[2] ) );\n\td = max( d, -toEL( uv, ael[3] ) );\n\td = max( d, -toEL( uv, ael[4] ) );\n\td = min( d, toEL( uv, ael[5] ) );\n\td = max( d, -toEL( uv, ael[6] ) );\n\treturn d;\n}\n\nfloat toCurl2( vec2 uv )\n{\n\tEL ael[4];\n\tael[0] = EL( 193.0, 89.0, 100.0, 355.7, 0.919, -0.394 );\n\tael[1] = EL( 198.0, 77.0, 100.0, 375.2, 0.914, -0.405 );\n\tael[2] = EL( 112.0, 14.0, 385.0, 187.0, 1.000, 0.000 );\n\tael[3] = EL( 321.0, 408.0, 11.0, 19.1, 0.164, 0.986 );\n\tfloat d = toEL( uv, ael[0] );\n\td = max( d, -toEL( uv, ael[1] ) );\n\td = max( d, -toEL( uv, ael[2] ) );\n\td = min( d, toEL( uv, ael[3] ) );\n\treturn d;\n}\n\nfloat toCharh( vec2 uv )\n{\n\tEL ael[4];\n\tael[0] = EL( 9.0, 14.0, 81.4, 220.5, 0.821, -0.571 );\n\tael[1] = EL( -7.0, -3.0, 78.9, 214.6, 0.839, -0.545 );\n\tael[2] = EL( -57.0, 182.0, 100.0, 100.0, 1.000, 0.000 );\n\tael[3] = EL( 104.0, -100.0, 196.0, 99.9, 0.970, 0.242 );\n\tfloat d = toEL( uv, ael[0] );\n\td = max( d, -toEL( uv, ael[1] ) );\n\td = max( d, -toEL( uv, ael[2] ) );\n\td = max( d, -toEL( uv, ael[3] ) );\n    d = min( d, toCharC1( uv + vec2( -110.0, 0.0 ) ) );\n    d = min( d, toCurl( uv + vec2( -20.0, 0.0 ) ) );\n\treturn d;\n}\n\nfloat toCharpm( vec2 uv )\n{\n\tEL ael[8];\n\tael[0] = EL( 273.0, -7.0, 100.0, 224.2, 0.875, -0.485 );\n\tael[1] = EL( 264.0, -20.0, 88.4, 225.2, 0.866, -0.500 );\n\tael[2] = EL( 139.0, -3.0, 100.0, 227.4, 0.875, -0.485 );\n\tael[3] = EL( 131.0, -16.0, 85.9, 229.6, 0.875, -0.485 );\n\tael[4] = EL( 305.0, -126.0, 417.0, 130.0, 1.000, 0.000 );\n\tael[5] = EL( -21.0, -86.0, 100.0, 313.6, 0.906, -0.423 );\n\tael[6] = EL( -38.0, -105.0, 88.2, 323.4, 0.899, -0.438 );\n\tael[7] = EL( -99.0, 58.0, 100.0, 261.7, 0.899, -0.438 );\n\tfloat d = toEL( uv, ael[0] );\n\td = max( d, -toEL( uv, ael[1] ) );\n\td = min( d, toEL( uv, ael[2] ) );\n\td = max( d, -toEL( uv, ael[3] ) );\n\td = max( d, -toEL( uv, ael[4] ) );\n\td = min( d, toEL( uv, ael[5] ) );\n\td = max( d, -toEL( uv, ael[6] ) );\n\td = max( d, -toEL( uv, ael[7] ) );\n    d = min( d, toCharTilda( vec2( uv + vec2( -135.0, 190.0 ) ) ) );\n\treturn d;\n}\n\nfloat toTilda2( vec2 uv )\n{\n    EL ael[4];\n\tael[0] = EL( 148.0, 43.0, 224.0, 158.0, 1.000, 0.000 );\n\tael[1] = EL( 156.0, 35.0, 266.0, 151.0, 1.000, 0.000 );\n\tael[2] = EL( 293.0, 267.0, 100.0, 100.0, 1.000, 0.000 );\n\tael[3] = EL( 290.0, 287.0, 118.0, 113.0, 1.000, 0.000 );\n\tfloat d = toEL( uv, ael[0] );\n\td = max( d, -toEL( uv, ael[1] ) );\n\td = min( d, toEL( uv, ael[2] ) );\n\td = max( d, -toEL( uv, ael[3] ) );\n    return d;\n}\n\nfloat toCharE1( vec2 uv )\n{\n\tEL ael[8];\n\tael[0] = EL( 172.0, 51.0, 132.0, 146.0, 1.000, 0.000 );\n\tael[1] = EL( 189.0, 57.0, 126.7, 133.2, 1.000, 0.017 );\n\tael[2] = EL( 271.0, 92.0, 146.8, 79.4, 0.755, 0.656 );\n\tael[3] = EL( 261.0, 110.0, 158.9, 89.5, 0.766, 0.643 );\n\tael[4] = EL( 223.0, -5.0, 59.6, 68.0, 0.999, 0.052 );\n\tael[5] = EL( 209.0, -8.0, 54.0, 65.0, 1.000, 0.000 );\n\tael[6] = EL( 212.0, 20.0, 62.2, 41.6, 0.982, 0.191 );\n\tael[7] = EL( 210.0, 20.0, 44.1, 34.5, 0.956, 0.292 );\n\tfloat d = toEL( uv, ael[0] );\n\td = max( d, -toEL( uv, ael[1] ) );\n\td = min( d, toEL( uv, ael[2] ) );\n\td = max( d, -toEL( uv, ael[3] ) );\n\td = min( d, toEL( uv, ael[4] ) );\n\td = max( d, -toEL( uv, ael[5] ) );\n\td = min( d, toEL( uv, ael[6] ) );\n\td = max( d, -toEL( uv, ael[7] ) );\n    d = min( d, toTilda2( uv ) );\n    d = min( d, toCurl( uv ) );\n\treturn d;\n}\n\nfloat toCharE2( vec2 uv )\n{\n\tEL ael[8];\n\tael[0] = EL( 172.0, 51.0, 132.0, 146.0, 1.000, 0.000 );\n\tael[1] = EL( 189.0, 57.0, 126.7, 133.2, 1.000, 0.017 );\n\tael[2] = EL( 271.0, 92.0, 146.8, 79.4, 0.755, 0.656 );\n\tael[3] = EL( 261.0, 110.0, 158.9, 89.5, 0.766, 0.643 );\n\tael[4] = EL( 223.0, -5.0, 59.6, 68.0, 0.999, 0.052 );\n\tael[5] = EL( 209.0, -8.0, 54.0, 65.0, 1.000, 0.000 );\n\tael[6] = EL( 212.0, 20.0, 62.2, 41.6, 0.982, 0.191 );\n\tael[7] = EL( 210.0, 20.0, 44.1, 34.5, 0.956, 0.292 );\n\tfloat d = toEL( uv, ael[0] );\n\td = max( d, -toEL( uv, ael[1] ) );\n//\td = min( d, toEL( uv, ael[2] ) );\n//\td = max( d, -toEL( uv, ael[3] ) );\n\td = min( d, toEL( uv, ael[4] ) );\n\td = max( d, -toEL( uv, ael[5] ) );\n\td = min( d, toEL( uv, ael[6] ) );\n\td = max( d, -toEL( uv, ael[7] ) );\n    d = min( d, toTilda2( uv ) );\n    d = min( d, toCurl( uv ) );\n\treturn d;\n}\n\nfloat toCharY2( vec2 uv )\n{\n\tEL ael[8];\n\tael[0] = EL( 120.0, -80.0, 74.8, 359.8, 0.875, -0.485 );\n\tael[1] = EL( 117.0, -50.0, 81.7, 390.5, 0.883, -0.469 );\n\tael[2] = EL( 95.0, 101.0, 66.5, 103.5, 0.940, -0.342 );\n\tael[3] = EL( 109.0, 117.0, 52.8, 95.3, 0.914, -0.407 );\n\tael[4] = EL( 215.0, 101.0, 66.8, 103.1, 0.940, -0.342 );\n\tael[5] = EL( 224.0, 116.0, 52.6, 95.7, 0.914, -0.407 );\n\tael[6] = EL( 385.0, 136.0, 100.0, 100.0, 1.000, 0.000 );\n\tael[7] = EL( 388.0, 108.0, 100.0, 146.7, 0.966, -0.259 );\n\tfloat d = toEL( uv, ael[0] );\n\td = max( d, -toEL( uv, ael[1] ) );\n\td = min( d, toEL( uv, ael[4] ) );\n\td = max( d, -toEL( uv, ael[5] ) );\n    d = min( d, toTilda2( uv + vec2( -100.0, -15.0 ) ) );\n    d = min( d, toCurl( uv + vec2( -170.0, 0.0 ) ) );\n    d = min( d, toCurl2( uv + vec2( -80.0, 0.0 ) ) );\n\treturn d;\n}\n\nfloat toPeriod( vec2 uv )\n{\n\tEL ael[1];\n\tael[0] = EL( 40.0, 23.0, 21.0, 22.0, 1.000, 0.000 );\n    float d = toEL( uv, ael[0] );\n\treturn d;\n}\n\nfloat toCharC2( vec2 uv )\n{\n\tEL ael[6];\n\tael[0] = EL( 88.0, 80.0, 81.9, 278.4, 0.914, -0.407 );\n\tael[1] = EL( 89.0, 59.0, 87.8, 292.0, 0.914, -0.407 );\n\tael[2] = EL( -51.0, 15.0, 40.0, 124.9, 0.945, -0.328 );\n\tael[3] = EL( 98.0, 100.0, 78.4, 105.8, 0.866, -0.500 );\n\tael[4] = EL( 88.0, 94.0, 70.9, 95.2, 0.866, -0.500 );\n\tael[5] = EL( 46.0, 22.0, 11.6, 16.4, 0.755, 0.656 );\n\tfloat d = toEL( uv, ael[0] );\n\td = max( d, -toEL( uv, ael[1] ) );\n\td = max( d, -toEL( uv, ael[2] ) );\n\td = min( d, toEL( uv, ael[3] ) );\n\td = max( d, -toEL( uv, ael[4] ) );\n\td = min( d, toEL( uv, ael[5] ) );\n\treturn d;\n}\n\nfloat toCharY3( vec2 uv )\n{\n\tEL ael[6];\n\tael[0] = EL( 23.0, -51.0, 77.6, 268.1, 0.934, -0.358 );\n\tael[1] = EL( 6.0, -62.0, 77.5, 273.0, 0.921, -0.391 );\n\tael[2] = EL( 75.0, 77.0, 60.5, 74.5, 0.993, -0.121 );\n\tael[3] = EL( 78.0, 95.0, 55.8, 82.7, 0.993, -0.122 );\n\tael[4] = EL( -27.0, 82.0, 44.2, 126.6, 0.951, -0.309 );\n\tael[5] = EL( -37.0, 57.0, 49.4, 138.5, 0.968, -0.253 );\n\tfloat d = toEL( uv, ael[0] );\n\td = max( d, -toEL( uv, ael[1] ) );\n\td = min( d, toEL( uv, ael[2] ) );\n\td = max( d, -toEL( uv, ael[3] ) );\n\td = min( d, toEL( uv, ael[4] ) );\n\td = max( d, -toEL( uv, ael[5] ) );\n\treturn d;\n}\n\nfloat toSmallTilda( vec2 uv )\n{\n\tEL ael[4];\n\tael[0] = EL( 168.0, 126.0, 178.0, 84.0, 1.000, 0.000 );\n\tael[1] = EL( 196.0, 84.0, 302.9, 120.3, 1.000, 0.017 );\n\tael[2] = EL( 177.0, 295.0, 189.0, 95.0, 1.000, 0.000 );\n\tael[3] = EL( 106.0, 310.0, 337.2, 104.9, 1.000, -0.017 );\n\tfloat d = toEL( uv, ael[0] );\n\td = max( d, -toEL( uv, ael[1] ) );\n\td = min( d, toEL( uv, ael[2] ) );\n\td = max( d, -toEL( uv, ael[3] ) );\n\treturn d;\n}\n\nfloat toCharE3( vec2 uv )\n{\n\tEL ael[7];\n\tael[0] = EL( 170.0, 229.0, 100.0, 244.3, 0.909, -0.418 );\n\tael[1] = EL( 201.0, 253.0, 102.4, 268.7, 0.887, -0.462 );\n\tael[2] = EL( 66.0, -136.0, 100.0, 153.6, 0.921, -0.391 );\n\tael[3] = EL( 79.0, -126.0, 87.3, 142.4, 0.921, -0.391 );\n\tael[4] = EL( 118.0, -126.0, 54.0, 69.8, 0.891, -0.454 );\n\tael[5] = EL( 116.0, -142.0, 47.9, 61.1, 0.866, -0.500 );\n\tael[6] = EL( 75.0, -157.0, 12.8, 11.8, 0.946, -0.326 );\n\tfloat d = toEL( uv, ael[0] );\n\td = max( d, -toEL( uv, ael[1] ) );\n\td = min( d, toEL( uv, ael[2] ) );\n\td = max( d, -toEL( uv, ael[3] ) );\n\td = min( d, toEL( uv, ael[4] ) );\n\td = max( d, -toEL( uv, ael[5] ) );\n\td = min( d, toEL( uv, ael[6] ) );\n\treturn d;\n}\n\nfloat toCharq( vec2 uv )\n{\n\tEL ael[8];\n\tael[0] = EL( 120.0, -80.0, 74.8, 359.8, 0.875, -0.485 );\n\tael[1] = EL( 117.0, -50.0, 81.7, 390.5, 0.883, -0.469 );\n\tael[2] = EL( 215.0, 101.0, 66.8, 103.1, 0.940, -0.342 );\n\tael[3] = EL( 224.0, 116.0, 52.6, 95.7, 0.914, -0.407 );\n\tfloat d = toEL( uv, ael[0] );\n\td = max( d, -toEL( uv, ael[1] ) );\n\td = min( d, toEL( uv, ael[2] ) );\n\td = max( d, -toEL( uv, ael[3] ) );\n    d = min( d, toSmallTilda( uv + vec2( -50.0, 0.0 ) ) );\n\treturn d;\n}\n\nfloat toCharm( vec2 uv )\n{\n\tEL ael[9];\n\tael[0] = EL( 273.0, -7.0, 100.0, 224.2, 0.875, -0.485 );\n\tael[1] = EL( 264.0, -20.0, 88.4, 225.2, 0.866, -0.500 );\n\tael[2] = EL( 139.0, -3.0, 100.0, 227.4, 0.875, -0.485 );\n\tael[3] = EL( 131.0, -16.0, 85.9, 229.6, 0.875, -0.485 );\n\tael[4] = EL( 305.0, -126.0, 417.0, 130.0, 1.000, 0.000 );\n\tael[5] = EL( -21.0, -86.0, 100.0, 313.6, 0.906, -0.423 );\n\tael[6] = EL( -38.0, -105.0, 88.2, 323.4, 0.899, -0.438 );\n\tael[7] = EL( -99.0, 58.0, 100.0, 261.7, 0.899, -0.438 );\n\tael[8] = EL( 95.0, -110.0, 195.0, 101.0, 1.000, 0.000 );\n\tfloat d = toEL( uv, ael[0] );\n\td = max( d, -toEL( uv, ael[1] ) );\n\td = min( d, toEL( uv, ael[2] ) );\n\td = max( d, -toEL( uv, ael[3] ) );\n\td = max( d, -toEL( uv, ael[4] ) );\n\td = min( d, toEL( uv, ael[5] ) );\n\td = max( d, -toEL( uv, ael[6] ) );\n\td = max( d, -toEL( uv, ael[7] ) );\n\td = max( d, -toEL( uv, ael[8] ) );\n    d = min( d, toCharTilda( vec2( uv + vec2( -135.0, 190.0 ) ) ) );\n\treturn d;\n}\n\nfloat toCharp2( vec2 uv )\n{\n\tfloat d = toEL( uv, EL( 145.0, 100.0, 100.0, 100.0, 1.0, 0.0 ) );\n    d = max( d, -toEL( uv, EL( 182.0, 90.0, 139.0, 112.0, 1.0, 0.0 ) ) );\n    d = min( d, toEL( uv, EL( 95.0, 68.0, 49.0, 141.0, 0.92, -0.39 ) ) );\n    d = max( d, -toEL( uv, EL( 71.0, 28.0, 51.5, 180.2, 0.92, -0.39 ) ) );\n    d = min( d, toCharj( uv + vec2( 70.0, 0.0 ) ) );\n    return d;\n}\n\nfloat toQuotes( vec2 uv )\n{\n\tEL ael[11];\n\tael[0] = EL( -61.0, 222.0, 153.0, 95.1, 0.643, -0.766 );\n\tael[1] = EL( -34.0, 239.0, 175.2, 119.3, 0.755, -0.656 );\n\tael[2] = EL( -185.0, 208.0, 128.7, 48.4, 0.500, -0.866 );\n\tael[3] = EL( -175.0, 152.0, 52.9, 170.0, 0.899, 0.438 );\n\tael[4] = EL( -250.0, 295.0, 13.0, 11.0, 1.000, 0.000 );\n\tael[5] = EL( 4.0, 98.0, 10.0, 8.0, 1.000, 0.000 );\n\tael[6] = EL( -77.0, 68.0, 87.3, 25.0, 1.000, 0.000 );\n\tael[7] = EL( -82.0, 75.0, 96.0, 22.0, 0.999, -0.052 );\n\tael[8] = EL( -180.0, 84.0, 44.7, 7.5, 0.777, -0.629 );\n\tael[9] = EL( -216.0, 103.0, 11.0, 11.0, 1.000, 0.000 );\n\tael[10] = EL( -5.0, 61.0, 12.0, 9.8, 0.914, 0.407 );\n\tfloat d = toEL( uv, ael[0] );\n\td = max( d, -toEL( uv, ael[1] ) );\n\td = min( d, toEL( uv, ael[2] ) );\n\td = max( d, -toEL( uv, ael[3] ) );\n\td = min( d, toEL( uv, ael[4] ) );\n\td = min( d, toEL( uv, ael[5] ) );\n\td = min( d, toEL( uv, ael[6] ) );\n\td = max( d, -toEL( uv, ael[7] ) );\n\td = min( d, toEL( uv, ael[8] ) );\n\td = min( d, toEL( uv, ael[9] ) );\n\td = min( d, toEL( uv, ael[10] ) );\n\treturn d;\n}\n\nfloat texScriptF( vec2 uv )\n{\n    uv.x -= uv.y * 0.15;\n    float d = toQuotes( uv + vec2( -180.0, 0.0 ) );\n    d = min( d, toCharC( uv + vec2( -200.0, 0.0 ) ) );\n    d = min( d, toDash3( uv + vec2( -200.0, 0.0 ) ) );\n    d = min( d, toCharp( uv + vec2( -340.0, 0.0 ) ) );\n    d = min( d, toCharC1( uv + vec2( -480.0, 0.0 ) ) );\n    d = min( d, toCharC1( uv + vec2( -630.0, 0.0 ) ) );\n    d = min( d, toCharZ( uv + vec2( -760.0, 0.0 ) ) );\n    d = min( d, toDash3( uv + vec2( -760.0, 0.0 ) ) );\n    d = min( d, toCharw( uv + vec2( -960.0, 0.0 ) ) );\n    d = min( d, toCharTilda( uv + vec2( -960.0, 0.0 ) ) );\n    d = min( d, toCharj( uv + vec2( -1230.0, 0.0 ) ) );\n    d = min( d, toCharC1( uv + vec2( -1320.0, 0.0 ) ) );\n    d = min( d, toCharC1( uv + vec2( -1470.0, 0.0 ) ) );\n    d = min( d, toCharh( uv + vec2( -1590.0, 0.0 ) ) );\n    d = min( d, toCharpm( uv + vec2( -1820.0, 0.0 ) ) );\n    d = min( d, toCharj( uv + vec2( -2190.0, 0.0 ) ) );\n    d = min( d, toCharC1( uv + vec2( -2280.0, 0.0 ) ) );\n    d = min( d, toDash3( uv + vec2( -2280.0, 0.0 ) ) );\n    d = min( d, toCharE1( uv + vec2( -2450.0, 0.0 ) ) );\n    d = min( d, toCharY2( uv + vec2( -2670.0, 0.0 ) ) );\n    d = min( d, toPeriod( uv + vec2( -3000.0, 0.0 ) ) );\n    \n    d = min( d, toCharC( uv + vec2( -3400.0, 0.0 ) ) );\n    d = min( d, toDash3( uv + vec2( -3400.0, 0.0 ) ) );\n    d = min( d, toCharp( uv + vec2( -3540.0, 0.0 ) ) );\n    d = min( d, toCharC1( uv + vec2( -3680.0, 0.0 ) ) );\n    d = min( d, toCharC1( uv + vec2( -3830.0, 0.0 ) ) );\n    d = min( d, toCharZ( uv + vec2( -3960.0, 0.0 ) ) );\n    d = min( d, toDash3( uv + vec2( -3960.0, 0.0 ) ) );\n    d = min( d, toCharw( uv + vec2( -4160.0, 0.0 ) ) );\n    d = min( d, toCharTilda( uv + vec2( -4160.0, 0.0 ) ) );\n    d = min( d, toCharw( uv + vec2( -4510.0, 0.0 ) ) );\n    d = min( d, toCharTilda( uv + vec2( -4510.0, 0.0 ) ) );\n    d = min( d, toCharpm( uv + vec2( -4770.0, 0.0 ) ) );\n    d = min( d, toCharTilda( uv + vec2( -4920.0, -70.0 ) ) );\n    d = min( d, toDash1( uv + vec2( -4920.0, -50.0 ) ) );\n    d = min( d, toCharj( uv + vec2( -5140.0, 0.0 ) ) );\n    d = min( d, toCharC1( uv + vec2( -5230.0, 0.0 ) ) );\n    d = min( d, toDash3( uv + vec2( -5230.0, 0.0 ) ) );\n    d = min( d, toCharE2( uv + vec2( -5420.0, 0.0 ) ) );\n    d = min( d, toQuotes( vec2( -uv.x, uv.y ) + vec2( 5760.0, 0.0 ) ) );\n\n\n    d = min( d, toCharC( uv + vec2( -6200.0, 0.0 ) ) );\n    d = min( d, toDash3( uv + vec2( -6200.0, 0.0 ) ) );\n    d = min( d, toCharp( uv + vec2( -6340.0, 0.0 ) ) );\n    d = min( d, toCharC1( uv + vec2( -6480.0, 0.0 ) ) );\n    d = min( d, toCharC1( uv + vec2( -6630.0, 0.0 ) ) );\n    d = min( d, toCharZ( uv + vec2( -6760.0, 0.0 ) ) );\n    d = min( d, toDash3( uv + vec2( -6760.0, 0.0 ) ) );\n    d = min( d, toCharw( uv + vec2( -6960.0, 0.0 ) ) );\n    d = min( d, toCharTilda( uv + vec2( -6960.0, 0.0 ) ) );\n    d = min( d, toCharC2( uv + vec2( -7260.0, 0.0 ) ) );\n    d = min( d, toCharY3( uv + vec2( -7440.0, 0.0 ) ) );\n    d = min( d, toCharq( uv + vec2( -7460.0, 0.0 ) ) );\n    d = min( d, toDash3( uv + vec2( -7590.0, 0.0 ) ) );\n    d = min( d, toCharj( uv + vec2( -7740.0, 0.0 ) ) );\n    d = min( d, toCharC1( uv + vec2( -7830.0, 0.0 ) ) );\n    d = min( d, toDash3( uv + vec2( -7800.0, 0.0 ) ) );\n    d = min( d, toCharE1( uv + vec2( -8000, 0.0 ) ) );\n    d = min( d, toCharY2( uv + vec2( -8220.0, 0.0 ) ) );\n    d = min( d, toPeriod( uv + vec2( -8550.0, 0.0 ) ) );\n    \n    d = min( d, toCharw( uv + vec2( -9000.0, 0.0 ) ) );\n    d = min( d, toCharTilda( uv + vec2( -9000.0, 0.0 ) ) );\n    d = min( d, toDash3( uv + vec2( -9050.0, 0.0 ) ) );\n    d = min( d, toCurl2( uv + vec2( -9180.0, 0.0 ) ) );\n    d = min( d, toCharpm( uv + vec2( -9260.0, 0.0 ) ) );\n    d = min( d, toCharh( uv + vec2( -9630.0, 0.0 ) ) );\n\td = min( d, toCharE3( uv + vec2( -9920.0, 0.0 ) ) );\n    d = min( d, toCharm( uv + vec2( -10030.0, 0.0 ) ) );\n    d = min( d, toCurl( uv + vec2( -10150.0, 0.0 ) ) );\n    d = min( d, toCharC( uv + vec2( -10430.0, 0.0 ) ) );\n    d = min( d, toDash1( uv + vec2( -10430.0, 0.0 ) ) );\n    d = min( d, toCharp( uv + vec2( -10560.0, 0.0 ) ) );\n    d = min( d, toDash1( uv + vec2( -10650.0, 0.0 ) ) );\n    d = min( d, toCharq( uv + vec2( -10620.0, 0.0 ) ) );\n    d = min( d, toCharY3( uv + vec2( -10940.0, 0.0 ) ) );\n    d = min( d, toCharp2( uv + vec2( -11130.0, 0.0 ) ) );\n    d = min( d, toSmallTilda( uv + vec2( -11080.0, 200.0 ) ) );\n    d = min( d, toSmallTilda( uv + vec2( -11080.0, -50.0 ) ) );\n    d = min( d, toDash1( uv + vec2( -11100.0, 0.0 ) ) );\n    d = min( d, toCharj( uv + vec2( -11310.0, 0.0 ) ) );\n    d = min( d, toCharC1( uv + vec2( -11400.0, 0.0 ) ) );\n    d = min( d, toDash3( uv + vec2( -11380.0, 0.0 ) ) );\n    d = min( d, toCharE1( uv + vec2( -11600.0, 0.0 ) ) );\n    \n    if ( d <= 0.0 ) return 1.0;\n    else return 0.0;\n}\n\n/*\nconst float Pi = 3.14159;\n\nstruct HitInfo_t\n{\n    float d;\n    int mat;\n    vec2 uv;\n};\n\nfloat toTorus( float R, float r, vec3 v )\n{\n    return length( vec2( length( v.xz ) - R, v.y ) ) - r;\n}\n\nfloat atan2( float y, float x )\n{\n    const float eps = 0.0001;\n    if ( x > eps ) return atan( y / x );\n    else if ( y >= 0.0 && x < -eps ) return atan( y / x ) + Pi;\n    else if ( y < 0.0 && x < -eps ) return atan( y / x ) - Pi;\n    else if ( abs( x ) < eps ) return Pi * 0.5 * sign( y );\n    else return 0.0;\n}\n\nHitInfo_t toTheRing( vec3 v )\n{\n    HitInfo_t res;\n    float dr = length( v.xz ) - 6.0;\n    float a = atan2( length( v.xz ) - 4.0, v.y );\n    if ( a < 0.0 ) a += Pi * 2.0;\n    float r = min( abs( v.y * 0.94 ) + 0.15, 3.0 );  //a / ( Pi * 2.0 ) + 0.5;\n    res.mat = 1;\n    res.uv.x = atan2( v.x, v.z ) / ( Pi * 2.0 );\n    res.uv.y = a;\n//    res.d = length( vec2( dr, v.y ) ) - r;\n    v.y *= 0.4;\n    res.d = length( vec2( dr, v.y ) ) - 0.8;\n    return res;\n}\n\nHitInfo_t toDesk( vec3 v )\n{\n    HitInfo_t res;\n    res.uv = v.xz;\n    res.mat = 2;\n    res.d = v.y;\n    return res;\n}\n\nHitInfo_t opU( HitInfo_t h1, HitInfo_t h2 )\n{\n    if ( h1.d < h2.d ) return h1;\n    else return h2;\n}\n\nHitInfo_t map( vec3 v )\n{\n    return opU( toTheRing( v ), toDesk( v ) );\n}\n\nvec3 calcNormal( vec3 pos )\n{\n\tvec3 eps = vec3( 0.001, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t    map(pos+eps.xyy).d - map(pos-eps.xyy).d,\n\t    map(pos+eps.yxy).d - map(pos-eps.yxy).d,\n\t    map(pos+eps.yyx).d - map(pos-eps.yyx).d );\n\treturn normalize(nor);\n}\n\nvec3 texCheckers( vec2 uv )\n{\n    float t = floor( uv.x ) + floor( uv.y );\n    return mod( t, 2.0 ) < 1.0 ? vec3( 1.0 ) : vec3( 0.0 );\n}\n\nvec3 texRing( vec2 uv )\n{\n    return vec3( 1.0, 1.0, 0.0 );\n}\n*/\n\nstruct RayHitInfo_t\n{\n    float t;\n    vec3 x;\n    vec3 n;\n};\n   \n/*\nvoid rayHitTorus( vec3 vantage, vec3 direction, float R, float S, out RayHitInfo_t rh )\n{\n    vantage = vantage.xzy;\n    direction = direction.xzy;\n\n    float T = 4.0 * R * R;\n    float G = T * (direction.x*direction.x + direction.y*direction.y);\n    float H = 2.0 * T * (vantage.x*direction.x + vantage.y*direction.y);\n    float I = T * (vantage.x*vantage.x + vantage.y*vantage.y);\n    float J = dot( direction, direction );\n    float K = 2.0 * dot(vantage, direction);\n    float L = dot( vantage, vantage) + R*R - S*S;\n\n    vec4 su;\n    int numRealRoots = SolveQuarticEquation(J*J,2.0*J*K,2.0*J*L + K*K - G,2.0*K*L - H,L*L - I,su);\n\n    if ( numRealRoots == 2 )\n        rh.t = min( su.x, su.y );\n    else if ( numRealRoots == 4 )\n    {\n        float a = min( su.x, su.y );\n        float b = min( su.z, su.w );\n        rh.t = min( a, b );\n    }\n    else\n    {\n        rh.t = -1.0;\n        rh.x = rh.n = vec3( 0.0 );\n        return;\n    }\n    \n    rh.x = vantage + direction * rh.t;\n    \n    float a = 1.0 - R / length( rh.x.xy );\n    rh.n = normalize( vec3( a * rh.x.x, a * rh.x.y, rh.x.z ) );\n    rh.n = rh.n.xzy;\n}\n*/\n\nfloat sqr( float f )\n{\n    return f * f;\n}\n\nvoid swap( inout float a, inout float b )\n{\n    float tmp = a;\n    a = b;\n    b = tmp;\n}\n\nvoid  sort3( inout float a, inout float b, inout float c) // make: a <= b <= c\n{\n\tfloat t;\n\tif( a>b ) swap(a,b);\t// now a<=b\n\tif( c<b ) {\n\t\tswap(b,c);\t\t\t// now a<=b, b<=c\n\t\tif( a>b ) swap(a,b);// now a<=b\n\t}\n}\n\nfloat N4Step(float x, float a,float b,float c,float d)\n{\n\tfloat fxs= ((4.0*x+3.0*a)*x+2.0*b)*x+c;\t// f'(x)\n\tif (fxs == 0.0) return x;\t//return 1e99; <<-- FIXED!\n\tfloat fx = (((x+a)*x+b)*x+c)*x+d;\t// f(x)\n\treturn x - fx/fxs;\n} \n\nvoid  CSqrt( float x, float y, out float a, out float b) // returns:  a+i*s = sqrt(x+i*y)\n{\n\tfloat r  = sqrt(x*x+y*y);\n\tif( y==0.0 ) { \n\t\tr = sqrt(r);\n\t\tif(x>=0.0) { a=r; b=0.0; } else { a=0.0; b=r; }\n\t} else {\t\t// y != 0\n\t\ta = sqrt(0.5*(x+r));\n\t\tb = 0.5*y/a;\n\t}\n}\n\nfloat _root3 ( float x )\n{\n    float s = 1.;\n    while ( x < 1. )\n    {\n        x *= 8.;\n        s *= 0.5;\n    }\n    while ( x > 8. )\n    {\n        x *= 0.125;\n        s *= 2.;\n    }\n    float r = 1.5;\n    r -= 1./3. * ( r - x / ( r * r ) );\n    r -= 1./3. * ( r - x / ( r * r ) );\n    r -= 1./3. * ( r - x / ( r * r ) );\n    r -= 1./3. * ( r - x / ( r * r ) );\n    r -= 1./3. * ( r - x / ( r * r ) );\n    r -= 1./3. * ( r - x / ( r * r ) );\n    return r * s;\n}\n\nfloat root3 ( float x )\n{\n    if ( x > 0.0 ) return _root3 ( x ); else\n    if ( x < 0.0 ) return-_root3 (-x ); else\n    return 0.;\n}\n\nint SolveP3(float a,float b,float c,out vec4 x) {\t// solve cubic equation x^3 + a*x^2 + b*x + c = 0\n\tfloat a2 = a*a;\n    float q  = (a2 - 3.0*b)/9.0; \n\tfloat r  = (a*(2.0*a2-9.0*b) + 27.0*c)/54.0;\n\n    float r2 = r*r;\n\tfloat q3 = q*q*q;\n\tfloat A,B;\n\tif (r2 <= (q3 + 1e-14)) {\n\t\tfloat t=r/sqrt(q3);\n\t\tif( t<-1.0) t=-1.0;\n\t\tif( t> 1.0) t= 1.0;\n        t=acos(t);\n        a/=3.0; q=-2.0*sqrt(q);\n        x[0]=q*cos(t/3.0)-a;\n        x[1]=q*cos((t+6.28318530717958648)/3.0)-a;\n        x[2]=q*cos((t-6.28318530717958648)/3.0)-a;\n        return(3);\n    } else {\n        A =-root3(abs(r)+sqrt(r2-q3)); \n\t\tif( r<0.0 ) A=-A;\n\t\tB = (A==0.0? 0.0 : B=q/A);\n\n\t\ta/=3.0;\n\t\tx[0] =(A+B)-a;\n        x[1] =-0.5*(A+B)-a;\n        x[2] = 0.5*sqrt(3.)*(A-B);\n\t\tif(abs(x[2])<1e-14) { x[2]=x[1]; return(2); }\n        return(1);\n    }\n}\n\nint SolveP4Bi(float b, float d, out vec4 x)\t// solve equation x^4 + b*x^2 + d = 0\n{\n\tfloat D = b*b-4.0*d;\n\tif( D>=0.0 ) \n\t{\n\t\tfloat sD = sqrt(D);\n\t\tfloat x1 = (-b+sD)/2.0;\n\t\tfloat x2 = (-b-sD)/2.0;\t// x2 <= x1\n\t\tif( x2>=0.0 )\t\t\t\t// 0 <= x2 <= x1, 4 real roots\n\t\t{\n\t\t\tfloat sx1 = sqrt(x1);\n\t\t\tfloat sx2 = sqrt(x2);\n\t\t\tx[0] = -sx1;\n\t\t\tx[1] =  sx1;\n\t\t\tx[2] = -sx2;\n\t\t\tx[3] =  sx2;\n\t\t\treturn 4;\n\t\t}\n\t\tif( x1 < 0.0 )\t\t\t\t// x2 <= x1 < 0, two pair of imaginary roots\n\t\t{\n\t\t\tfloat sx1 = sqrt(-x1);\n\t\t\tfloat sx2 = sqrt(-x2);\n\t\t\tx[0] =    0.0;\n\t\t\tx[1] =  sx1;\n\t\t\tx[2] =    0.0;\n\t\t\tx[3] =  sx2;\n\t\t\treturn 0;\n\t\t}\n\t\t// now x2 < 0 <= x1 , two real roots and one pair of imginary root\n\t\t\tfloat sx1 = sqrt( x1);\n\t\t\tfloat sx2 = sqrt(-x2);\n\t\t\tx[0] = -sx1;\n\t\t\tx[1] =  sx1;\n\t\t\tx[2] =    0.0;\n\t\t\tx[3] =  sx2;\n\t\t\treturn 2;\n\t} else { // if( D < 0 ), two pair of compex roots\n\t\tfloat sD2 = 0.5*sqrt(-D);\n\t\tCSqrt(-0.5*b, sD2, x[0],x[1]);\n\t\tCSqrt(-0.5*b,-sD2, x[2],x[3]);\n\t\treturn 0;\n\t} // if( D>=0 ) \n}\n\nint   SolveP4De(float b, float c, float d, out vec4 x)\t// solve equation x^4 + b*x^2 + c*x + d\n{\n\tif( abs(c)<1e-14*(abs(b)+abs(d)) ) return SolveP4Bi(b,d,x); // After that, c!=0\n\n\tint res3 = SolveP3( 2.0*b, b*b-4.0*d, -c*c, x);\t// solve resolvent\n\t// by Viet theorem:  x1*x2*x3=-c*c not equals to 0, so x1!=0, x2!=0, x3!=0\n\tif( res3>1 )\t// 3 real roots, \n\t{\t\t\t\t\n\t\tsort3(x[0], x[1], x[2]);\t// sort roots to x[0] <= x[1] <= x[2]\n\t\t// Note: x[0]*x[1]*x[2]= c*c > 0\n\t\tif( x[0] > 0.0) // all roots are positive\n\t\t{\n\t\t\tfloat sz1 = sqrt(x[0]);\n\t\t\tfloat sz2 = sqrt(x[1]);\n\t\t\tfloat sz3 = sqrt(x[2]);\n\t\t\t// Note: sz1*sz2*sz3= -c (and not equal to 0)\n\t\t\tif( c>0. )\n\t\t\t{\n\t\t\t\tx[0] = (-sz1 -sz2 -sz3)/2.0;\n\t\t\t\tx[1] = (-sz1 +sz2 +sz3)/2.0;\n\t\t\t\tx[2] = (+sz1 -sz2 +sz3)/2.0;\n\t\t\t\tx[3] = (+sz1 +sz2 -sz3)/2.0;\n\t\t\t\treturn 4;\n\t\t\t}\n\t\t\t// now: c<0\n\t\t\tx[0] = (-sz1 -sz2 +sz3)/2.0;\n\t\t\tx[1] = (-sz1 +sz2 -sz3)/2.0;\n\t\t\tx[2] = (+sz1 -sz2 -sz3)/2.0;\n\t\t\tx[3] = (+sz1 +sz2 +sz3)/2.0;\n\t\t\treturn 4;\n\t\t} // if( x[0] > 0) // all roots are positive\n\t\t// now x[0] <= x[1] < 0, x[2] > 0\n\t\t// two pair of comlex roots\n\t\tfloat sz1 = sqrt(-x[0]);\n\t\tfloat sz2 = sqrt(-x[1]);\n\t\tfloat sz3 = sqrt( x[2]);\n\n\t\tif( c>0.0 )\t// sign = -1\n\t\t{\n\t\t\tx[0] = -sz3/2.0;\t\t\t\t\t\n\t\t\tx[1] = ( sz1 -sz2)/2.0;\t\t// x[0]±i*x[1]\n\t\t\tx[2] =  sz3/2.0;\n\t\t\tx[3] = (-sz1 -sz2)/2.0;\t\t// x[2]±i*x[3]\n\t\t\treturn 0;\n\t\t}\n\t\t// now: c<0 , sign = +1\n\t\tx[0] =   sz3/2.0;\n\t\tx[1] = (-sz1 +sz2)/2.0;\n\t\tx[2] =  -sz3/2.0;\n\t\tx[3] = ( sz1 +sz2)/2.0;\n\t\treturn 0;\n\t} // if( res3>1 )\t// 3 real roots, \n\t// now resoventa have 1 real and pair of compex roots\n\t// x[0] - real root, and x[0]>0, \n\t// x[1]±i*x[2] - complex roots, \n\t// x[0] must be >=0. But one times x[0]=~ 1e-17, so:\n\tif (x[0] < 0.0) x[0] = 0.0;\n\tfloat sz1 = sqrt(x[0]);\n\tfloat szr, szi;\n\tCSqrt(x[1], x[2], szr, szi);  // (szr+i*szi)^2 = x[1]+i*x[2]\n\tif( c>0.0 )\t// sign = -1\n\t{\n\t\tx[0] = -sz1/2.0-szr;\t\t\t// 1st real root\n\t\tx[1] = -sz1/2.0+szr;\t\t\t// 2nd real root\n\t\tx[2] = sz1/2.0; \n\t\tx[3] = szi;\n\t\treturn 2;\n\t}\n\t// now: c<0 , sign = +1\n\tx[0] = sz1/2.0-szr;\t\t\t// 1st real root\n\tx[1] = sz1/2.0+szr;\t\t\t// 2nd real root\n\tx[2] = -sz1/2.0;\n\tx[3] = szi;\n\treturn 2;\n}\n\nint SolveP4(float a,float b,float c,float d, out vec4 roots)\n{\n\tfloat d1 = d + 0.25*a*( 0.25*b*a - 3.0/64.0*a*a*a - c);\n\tfloat c1 = c + 0.5*a*(0.25*a*a - b);\n\tfloat b1 = b - 0.375*a*a;\n\tint res = SolveP4De( b1, c1, d1,roots);\n\tif( res==4) { roots[0]-= a/4.0; roots[1]-= a/4.0; roots[2]-= a/4.0; roots[3]-= a/4.0; }\n\telse if (res==2) { roots[0]-= a/4.0; roots[1]-= a/4.0; roots[2]-= a/4.0; }\n\telse             { roots[0]-= a/4.0; roots[2]-= a/4.0; }\n\t// one Newton step for each real root:\n\tif( res>0 )\n\t{\n\t\troots[0] = N4Step(roots[0], a,b,c,d);\n\t\troots[1] = N4Step(roots[1], a,b,c,d);\n\t}\n\tif( res>2 )\n\t{\n\t\troots[2] = N4Step(roots[2], a,b,c,d);\n\t\troots[3] = N4Step(roots[3], a,b,c,d);\n\t}\n\treturn res;\n}\n\nvoid rayHitTorus( vec3 O, vec3 Dir, float R, float S, out RayHitInfo_t rh )\n{\n    O = O.xzy;\n    Dir = Dir.xzy;\n\n    float r2 = sqr( S );\n\tfloat R2 = sqr( R );\n\n\tfloat a4 = sqr( dot( Dir, Dir ) );\n\tfloat a3 = 4.0 * dot( Dir, Dir ) * dot( O, Dir );\n\tfloat a2 = 4.0 * sqr( dot( O, Dir ) ) + 2.0 * dot( Dir, Dir ) * ( dot( O, O ) - r2 - R2 ) + 4.0 * R2 * sqr( Dir.z );\n\tfloat a1 = 4.0  * dot( O, Dir ) * ( dot( O, O ) - r2 - R2 ) + 8.0 * R2 * O.z * Dir.z;\n\tfloat a0 = sqr( dot( O, O ) - r2 - R2 ) + 4.0 * R2 * sqr( O.z ) - 4.0 * R2 * r2;\n\n\ta3 /= a4; a2 /= a4; a1 /= a4; a0 /= a4;\n\n\tvec4 su;\n\tint numRealRoots = SolveP4( a3, a2, a1, a0, su );\n\n    if ( numRealRoots == 2 )\n        rh.t = min( su.x, su.y );\n    else if ( numRealRoots == 4 )\n    {\n        float a = min( su.x, su.y );\n        float b = min( su.z, su.w );\n        rh.t = min( a, b );\n    }\n    else\n    {\n        rh.t = -1.0;\n        rh.x = rh.n = vec3( 0.0 );\n        return;\n    }\n    \n    rh.x = O + Dir * rh.t;\n    \n    float a = 1.0 - R / length( rh.x.xy );\n    rh.n = normalize( vec3( a * rh.x.x, a * rh.x.y, rh.x.z ) );\n/*\trh.n = vec3(\n\t\t4.0 * rh.x.x * ( sqr( rh.x.x ) + sqr( rh.x.y ) + sqr( rh.x.z ) - r2 - R2 ),\n\t\t4.0 * rh.x.y * ( sqr( rh.x.x ) + sqr( rh.x.y ) + sqr( rh.x.z ) - r2 - R2 ),\n\t\t4.0 * rh.x.z * ( sqr( rh.x.x ) + sqr( rh.x.y ) + sqr( rh.x.z ) - r2 - R2 ) + 8.0 * R2*rh.x.z\n\t);\n    rh.n = normalize( rh.n );*/\n\n    \n    rh.x = rh.x.xzy;\n    rh.n = rh.n.xzy;\n}\n\nfloat rayHitSphere( vec3 vo, vec3 vd, vec3 o, float r, bool bOut, out vec3 x, out vec3 n )\n{\n    float a = dot( vd, vd );\n    float b = 2.0 * dot( vd, vo - o );\n    float c = dot( vo - o, vo - o ) - r * r;\n    float d = b * b - 4.0 * a * c;\n    if ( d < 0.0 ) return -1.0;\n    d = sqrt( d );\n    float t1 = ( -b + d ) / ( 2.0 * a );\n    float t2 = ( -b - d ) / ( 2.0 * a );\n    float t = bOut ? max( t1, t2 ) : min( t1, t2 );\n    if ( t < 0.0 ) return t;\n    x = vo + vd * t;\n    n = normalize( x - o );\n    if ( bOut ) n = -n;\n    return t;\n}\n\nconst float Rout = 10.0;\nconst float Rin = 8.8;\nconst float Rmid = ( Rout + Rin ) * 0.5;\nconst float Rheight = 1.5;\nconst float torusr = ( Rout - Rin ) * 0.5;\nconst float torusR = sqrt( Rmid * Rmid - Rheight * Rheight );\nconst float tableY = -Rheight - torusr;\n\nvoid rayHitOuter( vec3 vo, vec3 vd, out RayHitInfo_t rh )\n{\n    const float fMaxY = Rheight / torusR * Rout;\n    \n    rh.t = rayHitSphere( vo, vd, vec3( 0.0 ), Rout, false, rh.x, rh.n );\n    if ( rh.t > 0.0 )\n        if ( abs( rh.x.y ) > fMaxY ) rh.t = -1.0;\n}\n\nvoid rayHitInner( vec3 vo, vec3 vd, out RayHitInfo_t rh )\n{\n    rh.t = rayHitSphere( vo, vd, vec3( 0.0 ), Rin, true, rh.x, rh.n );\n    if ( rh.t > 0.0 )\n        if ( abs( rh.x.y ) > Rheight ) rh.t = -1.0;\n}\n\nRayHitInfo_t unite( RayHitInfo_t rh1, RayHitInfo_t rh2 )\n{\n    if ( rh1.t >= 0.0 )\n    {\n        if ( rh2.t >= 0.0 )\n        {\n            if ( rh1.t < rh2.t ) return rh1;\n            else return rh2;\n        }\n        else return rh1;\n    }\n    else return rh2;\n}\n\nvoid rayHitBorder( vec3 vo, vec3 vd, out RayHitInfo_t rh )\n{\n    RayHitInfo_t rh1;\n    rayHitTorus( vo + vec3( 0, Rheight, 0 ), vd, torusR, torusr, rh ); rh.x.y -= Rheight;\n    rayHitTorus( vo - vec3( 0, Rheight, 0 ), vd, torusR, torusr, rh1 ); rh1.x.y += Rheight;\n    rh = unite( rh, rh1 );\n}\n\nfloat rayHitRing( vec3 vo, vec3 vd, out vec3 x, out vec3 n )\n{\n    RayHitInfo_t rh, rh1;\n    \n    rayHitOuter( vo, vd, rh );\n    rayHitInner( vo, vd, rh1 );\n    rh = unite( rh, rh1 );\n    rayHitBorder( vo, vd, rh1 );\n    rh = unite( rh, rh1 );\n    \n    x = rh.x;\n    n = rh.n;\n    \n    return rh.t;\n}\n\nfloat rayHitTable( vec3 vo, vec3 vd, out vec3 x, out vec3 n )\n{\n    if ( vd.y > 0.001 ) return -1.0;\n    float dy = tableY - vo.y;\n    float t = dy / vd.y;\n    x = vo + vd * t;\n    n = vec3( 0, 1, 0 );\n    if ( abs( x.x ) > 40.0 || abs( x.z ) > 40.0 ) return -1.0;\n    return t;\n}\n\n\nvec3 ld = normalize( vec3( -1.0, -1.0, 0.0 ) );\nvec3 vCamPos;\n\nvec3 schlick( vec3 s, float lh )\n{\n\treturn s + ( 1.0 - s ) * pow( 1.0 - lh, 5.0 );\n}\n\nvec3 FresnelTerm( vec3 F0, float cosA )\n{\n\tfloat t = pow( 1.0 - cosA, 5.0 );\n\treturn F0 + ( 1.0 - F0 ) * t;\n}\n\nvec3 FresnelLerp( vec3 F0, vec3 F90, float cosA )\n{\n\tfloat t = pow( 1.0 - cosA, 5.0 );\n\treturn mix( F0, F90, t );\n}\n\nfloat SmithVisibilityTerm( float NdotL, float NdotV, float k )\n{\n\tfloat gL = NdotL * ( 1.0 - k ) + k;\n\tfloat gV = NdotV * ( 1.0 - k ) + k;\n\treturn 1.0 / (gL * gV + 1e-5);\n}\n\nfloat SmithBeckmannVisibilityTerm( float NdotL, float NdotV, float roughness )\n{\n\tfloat c = 0.797884560802865;\n\tfloat k = roughness * roughness * c;\n\treturn SmithVisibilityTerm (NdotL, NdotV, k);\n}\n\nfloat NDFBlinnPhongNormalizedTerm( float NdotH, float n )\n{\n\tfloat normTerm = (n + 2.0) * (0.5/3.14159);\n\n\tfloat specTerm = pow( NdotH, n );\n\treturn specTerm * normTerm;\n}\n\nfloat RoughnessToSpecPower( float roughness )\n{\n\tfloat m = max( 1e-4, roughness * roughness );\n\tfloat n = ( 2.0 / ( m * m ) ) - 2.0;\n\tn = max( n, 1e-4 );\n\treturn n;\n}\n\nvec3 brdf( vec3 diffColor, vec3 specColor, float reflectivity, float roughness, vec3 normal, vec3 viewDir,\n\tvec3 lightDir, vec3 lightColor,\n\tvec3 globalSpecular, vec3 globalDiffuse )\n{\n    vec3 halfDir = normalize( viewDir + lightDir );\n    float nl = max( dot( lightDir, normal ), 0.0 );\n    float nh = max( dot( normal, halfDir ), 0.0 );\n    float nv = max( dot( normal, viewDir ), 0.0 );\n    float lh = max( dot( lightDir, halfDir ), 0.0 );\n    float lv = max( dot( lightDir, viewDir ), 0.0 );\n\n    \n\tfloat v = SmithBeckmannVisibilityTerm( nl, nv, roughness );\n\tfloat d = NDFBlinnPhongNormalizedTerm( nh, RoughnessToSpecPower( roughness ) );\n    \n\tfloat nlPow5 = pow( 1.0 - nl, 5.0 );\n\tfloat nvPow5 =pow( 1.0 - nv, 5.0 );\n\tfloat Fd90 = 0.5 + 2.0 * lh * lh * roughness;\n\tfloat disneyDiffuse = ( 1.0 + ( Fd90 - 1.0 ) * nlPow5 ) * ( 1.0 + ( Fd90 - 1.0 ) * nvPow5);\n\n\tfloat specularTerm = ( v * d ) * ( 3.14159 / 4.0 );\n    specularTerm = max( specularTerm * nl, 0.0 );\n\n\tfloat diffuseTerm = disneyDiffuse * nl;\n\n\tfloat realRoughness = roughness * roughness;\n\tfloat surfaceReduction = 1.0 / ( realRoughness * realRoughness + 1.0 );\n    \n\tfloat grazingTerm = clamp( 1.0 - roughness + reflectivity, 0.0, 1.0 );\n    vec3 color =\tdiffColor * ( globalDiffuse + lightColor * diffuseTerm )\n                    + specularTerm * lightColor * FresnelTerm( specColor, lh )\n\t\t\t\t\t+ surfaceReduction * globalSpecular * FresnelLerp( specColor, vec3( grazingTerm ), nv );\n    \n    return color;\n}\n\nfloat hash(vec2 p)\n{\n    p  = 50.0*fract( p*0.3183099 );\n    return -1.0+2.0*fract( p.x*p.y*(p.x+p.y) );\n}\n\nfloat noise( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n\tvec2 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( hash( i + vec2(0.0,0.0) ), \n                     hash( i + vec2(1.0,0.0) ), u.x),\n                mix( hash( i + vec2(0.0,1.0) ), \n                     hash( i + vec2(1.0,1.0) ), u.x), u.y);\n}\n\nfloat fire( vec2 uv )\n{\n    const int numSteps = 3;\n    float result = 0.0;\n    const float k1 = 4.0, k2 = 3.0;\n    mat2 m = mat2( k1, k2, -k2, k1 );\n    for( int i = 0; i < numSteps; i++ )\n    {\n        uv = uv * m;\n        uv.y -= iTime * 3.0;\n        result += noise( uv );\n    }\n    result /= float( numSteps );\n    \n    return result;\n}\n\nvec3 fireColor( float f )\n{\n    vec3 result;\n    result.r = min( f * 5.0, 1.0 );\n    result.g = min( f * 2.5, 1.0 );\n    result.b = f * 0.25;\n    return result;\n}    \n\nfloat g_fTransition = 0.0;\nfloat g_fScriptTransition = 0.0;\n\nvec3 getEnv( vec3 d )\n{\n    vec3 result;\n/*    if ( d.y < 0.0 )\n        result = texture( iChannel1, d.xz * 0.05 ).rgb;\n    else*/ result = texture( iChannel0, d ).rgb;\n//    result = mix( result, fireColor( fire( d.xy ) ), g_fTransition );\n    return result;\n}\n\nconst vec3 c_vRingColor = vec3(1.000, 0.766, 0.336);\nconst vec3 c_vLightDir = normalize( vec3( 1.0, -1.0, 0.0 ) );\nconst vec3 c_vLightColor = vec3( 1.2 );\nconst vec3 c_vLightAmbient = vec3( 0.2 );\nconst float c_fRingSpecular = 0.5;\nconst float c_fRingSpecPower = 20.0;\n\nvec3 simpleRingMaterial( vec3 x, vec3 vd, vec3 n )\n{\n    float d = max( dot( -c_vLightDir, n ), 0.0 );\n    vec3 c = ( c_vLightColor * c_vRingColor ) * d;\n\tvec3 r = normalize( reflect( vd, n ) );\n\tfloat spec = pow( max( dot( r, -c_vLightDir ), 0.0 ), c_fRingSpecPower ) * c_fRingSpecular;\n    vec3 color = c + c_vLightAmbient + vec3( spec );\n    vec3 env = texture( iChannel0, r ).rgb;\n    return mix( color, env, 0.9 );\n}\n\nvec3 simpleTableMaterial( vec3 x, vec3 vd, vec3 n )\n{\n    vec3 color = texture( iChannel1, x.xz * 0.05 ).rgb;\n    float ao = clamp( abs( length( x ) - Rmid ), 0.0, 1.0 );\n    return color * ao;\n}\n\nvec3 renderReflection( vec3 vo, vec3 vd )\n{\n    vec3 posRing, nRing;\n    float tRing = rayHitRing( vo, vd, posRing, nRing );\n    vec3 posTable, nTable;\n    float tTable = rayHitTable( vo, vd, posTable, nTable );\n    if ( tRing < 0.0 && tTable < 0.0 )\n        return texture( iChannel0, vd ).rgb;\n    if ( tTable < 0.0 || ( tRing > 0.0 && tRing < tTable ) )\n        return simpleRingMaterial( posRing, vd, nRing );\n    return simpleTableMaterial( posTable, vd, nTable );\n}\n\nvec3 ringMaterial( vec3 x, vec3 vd, vec3 n )\n{\n    vec3 albedoRing = vec3( 0.2, 0.2, 0.0 );\n    vec3 albedoScript = vec3( 0.0 );\n    vec3 specRing = c_vRingColor;\n    vec3 specScript = vec3( 1.0, 0.9, 0.7);\n    albedoScript = specScript;\n\n    vec3 albedo = albedoRing;\n    vec3 specColor = specRing;\n    float reflectivity = 0.2;\n    float roughness = 0.01;\n    vec3 emissive = vec3( 0.0 );\n\n    vec2 uv;\n    uv.x = atan( x.z, x.x ) / 3.14159;\n    uv.y = x.y / Rheight * 0.5;\n    float vMin = -0.45;\n    float vMax = 0.45;\n    if ( uv.y > vMin && uv.y < vMax )\n    {\n        uv.x = ( uv.x + 1.0 ) * 0.5;\n        uv.y = 1.0 - ( uv.y - vMin ) / ( vMax - vMin );\n        float s = texScriptF( uv * vec2( 12500.0, -800.0 ) + vec2( 0.0, 450.0 ));\n        \n//        s *= clamp( clamp( noise( uv * 16.0 ), 0.0, 1.0 ) - 1.0 + g_fScriptTransition * 2.0, 0.0, 1.0 );\n                 \n//\t\talbedo = mix( albedoRing, albedoScript, s );\n//        specColor = mix( specRing, specScript, s );\n        roughness = mix( roughness, 0.9, s );\n        reflectivity = mix( reflectivity, 0.1, s );\n        emissive = vec3( 0.9, 0.9, 0.5 ) * s;\n    }\n    \n\tfloat ao = clamp( ( x.y - tableY ) / ( torusr + Rheight * 0.5 ), 0.0, 1.0 );\n    \n\n/*    vec3 view = normalize( vCamPos - x );\n    vec3 r = reflect( vd, n );\n    vec3 env, table, tableN;\n    if ( r.y < 0.0 && rayHitTable( x, r, table,tableN ) >= 0.0 )\n    {\n        env = texture( iChannel1, table.xz * 0.05 ).rgb;\n    }\n    else env = getEnv( r );\n    */\n    vec3 env = renderReflection( x, reflect( vd, n ) );\n\n    vec3 color = brdf( albedo, specColor, reflectivity, roughness, n, vd, \n    \tc_vLightDir, c_vLightColor, env, vec3( 0.2 ) ) * ao + emissive;\n    \n//    color = r * 0.5 + vec3( 0.5 );\n//    color = n * 0.5 + vec3( 0.5 );\n//    color = vec3( 0.0, 0.0, ( x.y + tableY ) );\n    \n    return color;\n}\n\nvec3 render2( vec3 vo, vec3 vd )\n{\n    vec3 x, n;\n    float dr = rayHitRing( vo, vd, x, n );\n    if ( dr > 0.0 )\n    {\n        return ringMaterial( x, vd, n );\n    }\n    \n    vec3 result;\n    float dt = rayHitTable( vo, vd, x, n );\n    if ( dt >= 0.0 )\n    {\n        result = texture( iChannel1, x.xz * 0.05 ).rgb;\n    }\n    else result = texture( iChannel0, vd ).rgb;\n//    result = mix( result, fireColor( fire( vd.xy ) ), g_fTransition );\n    return result;\n}\n\nvec3 render3( vec3 vo, vec3 vd )\n{\n    vec3 posRing, nRing;\n    float tRing = rayHitRing( vo, vd, posRing, nRing );\n    vec3 posTable, nTable;\n    float tTable = rayHitTable( vo, vd, posTable, nTable );\n    if ( tRing < 0.0 && tTable < 0.0 )\n        return texture( iChannel0, vd ).rgb;\n    \n    if ( tTable < 0.0 || ( tRing > 0.0 && tRing < tTable ) ) // ring\n    {\n//        vec3 r = renderReflection( posRing, reflect( vd, nRing ) );\n        return ringMaterial( posRing, vd, nRing );\n    }\n    else // table\n    {\n        vec3 r = renderReflection( posTable, reflect( vd, nTable ) );\n        float shadowK = rayHitRing( posTable, -c_vLightDir, posRing, nRing ) < 0.0 ? 1.0 : 0.75;\n        vec3 color = simpleTableMaterial( posTable, vd, nTable ) * shadowK;\n        return color = mix( color, r, 0.05 );\n    }\n}\n\nfloat transition( float fTime )\n{\n    return clamp( sin( ( fTime - 3.0 ) * 0.2 ) * 2.0 + 1.5, 0.0, 1.0 );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = -1.0 + 2.0*fragCoord.xy / iResolution.xy;\n    p.x *= iResolution.x/iResolution.y;\n\n    g_fTransition = transition( iTime );\n    g_fScriptTransition = transition( iTime - 2.0 );\n\n    vec3 vCamDir = normalize( vec3( 0, -1, 1 ) );\n    vCamDir.y =  -0.5 + sin( iTime * 0.1 ) * 0.15;\n    vCamDir.x = sin( -iTime / 4.0 );\n    vCamDir.z = cos( -iTime / 4.0 );\n    vCamDir = normalize( vCamDir );\n    vec3 vCamUp = vec3( 0, 1, 0 );\n    vec3 vCamRight = normalize( cross( vCamUp, vCamDir ) );\n    vCamUp = normalize( cross( vCamDir, vCamRight ) );\n    vCamPos = vec3( 0, 0, 0 ) - vCamDir * 25.0;\n\n\tvec3 vd = normalize( vCamDir * 2.0 + vCamRight * p.x + vCamUp * p.y );\n    \n    vec3 color = render3( vCamPos, vd );\n    \n    fragColor = vec4( color, 1.0 );\n}\n","name":"Image","description":"","type":"image"}]}