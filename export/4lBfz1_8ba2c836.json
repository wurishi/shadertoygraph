{"ver":"0.1","info":{"id":"4lBfz1","date":"1514546697","viewed":153,"name":"3DTunnel","username":"Turtlesoup","description":"A 3D tunnel thingy made from messing about with shadertoy. Use keyboard to move camera position.","likes":3,"published":1,"flags":48,"usePreview":0,"tags":["3d","tunnel","keyboard"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdXGzn","filepath":"/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","previewfilepath":"/media/ap/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// --------------------\n// \t\tRendering\n// --------------------\n\n// Render Constants\nconst float BG_ILLUMINATION = 5.0f;\nconst float BG_SCROLL_SPEED = 0.5f;\n\n// Texture Register\nconst vec2 TX_CAMERA_POS \t= vec2(0.0,0.0);\n\n// Program State\nstruct ProgramState\n{\n    vec4 cameraPos;\n} state;\n\nvec4 loadValue(vec2 texel)\n{\n    return texelFetch(iChannel1, ivec2(texel.x, texel.y), 0 );\n}\n\nvoid loadProgramState()\n{\n    state.cameraPos = loadValue(TX_CAMERA_POS);\n}\n\n\n\n\n// UI Utils\n// digit data by P_Malin (https://www.shadertoy.com/view/4sf3RN)\n// converted to LUT and integer logic by iq\nconst int[] font = int[]( \n    7 + 5*16 + 5*256 + 5*4096 + 7*65536,\n    2 + 2*16 + 2*256 + 2*4096 + 2*65536,\n    7 + 1*16 + 7*256 + 4*4096 + 7*65536,\n    7 + 4*16 + 7*256 + 4*4096 + 7*65536,\n    4 + 7*16 + 5*256 + 1*4096 + 1*65536,\n    7 + 4*16 + 7*256 + 1*4096 + 7*65536,\n    7 + 5*16 + 7*256 + 1*4096 + 7*65536,\n    4 + 4*16 + 4*256 + 4*4096 + 7*65536,\n    7 + 5*16 + 7*256 + 5*4096 + 7*65536,\n    7 + 4*16 + 7*256 + 5*4096 + 7*65536 );\n                          \nint SampleDigit(const in int n, const in vec2 vUV)\n{\n    vec2 q = abs(vUV-0.5);\n    if( max(q.x,q.y)>0.5 ) return 0;\n    \n\n    ivec2 p = ivec2(floor(vUV * vec2(4.0, 5.0)));\n    int   i = p.x + p.y*4;\n    \n    return (font[n]>>i) & 1;\n}\n\nint PrintInt( in vec2 uv, in int value )\n{\n    int res = 0;\n    \n    int maxDigits = (value<10) ? 1 : (value<100) ? 2 : 3;\n    int digitID = maxDigits - 1 - int(floor(uv.x));\n    \n    if( digitID>=0 && digitID<maxDigits )\n    {\n        int div = (digitID==0) ? 1 : (digitID==1) ? 10 : 100;\n        res = SampleDigit( (value/div) % 10, vec2(fract(uv.x), uv.y) );\n    }\n\n    return res;\n}\n\n\n// Main\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    vec3 color;\n    vec2 uv = (-iResolution.xy + 2.0*fragCoord.xy) / iResolution.y;\n    \n    loadProgramState();\n    \n    // Player/Camera Position\n    float xPos = state.cameraPos.x;\n    float yPos = state.cameraPos.y;\n    vec2 camPos = vec2(0.5, 0.5) - vec2(xPos, yPos);\n    \n    // Scrolling Background Rendering\n\tvec2 fragPos = ( fragCoord.xy / iResolution.xy ) - camPos;\t\n    float fov = 1.0;\n\tfloat scaling = 1.0;\n\t\n\tvec3 p = vec3(fragPos.x, fov, fragPos.y);\n\t\n\tvec2 sVertical = vec2(p.x/p.z, p.y/p.z) * scaling;\n\tvec2 sHorizontal = vec2(p.y/p.x, p.z/p.x) * scaling;\n\t\n\tfloat bgScrollSpeed = iTime * BG_SCROLL_SPEED;\n\tif(fragPos.y > 0.0)\n\t{\n\t\tbgScrollSpeed = -bgScrollSpeed;\n    }\n    \n\tif(sVertical.x < -scaling)\n\t{\n\t\tfloat tx = mod(sHorizontal.x + bgScrollSpeed, 1.0);\n        float ty = mod(sHorizontal.y, 1.0);\n        color = texture(iChannel2, vec2(tx, ty)).rgb;\n\t\tcolor *= min(abs(p.x) * BG_ILLUMINATION, 1.0f);\n\t}\n\telse if(sVertical.x > scaling)\n\t{\n        float tx = mod(sHorizontal.x - bgScrollSpeed, 1.0);\n        float ty = mod(sHorizontal.y, 1.0);\n        color = texture(iChannel2, vec2(tx, ty)).rgb;\n\t\tcolor *= min(abs(p.x) * BG_ILLUMINATION, 1.0f);\n\t}\n\telse\n\t{\n        float tx = mod(sVertical.x, 1.0);\n        float ty = mod(sVertical.y - bgScrollSpeed, 1.0);\n        color = texture(iChannel2, vec2(tx, ty)).rgb;\n\t\tcolor *= min(abs(p.z) * BG_ILLUMINATION, 1.0f);\n\t}\n    \n    // UI Rendering\n    int score = int(abs(xPos) * 100.0f); // TEMP\n    float scoreFragColor = float(PrintInt((uv-vec2(-1.5,0.8))*10.0, score));\n    color = mix(color, vec3(1.0,0.0,1.0), scoreFragColor);\n    \n    int health = int(abs(yPos) * 100.0f); // TEMP\n    float heathFragColor = float(PrintInt((uv-vec2(-1.5,0.5))*10.0, health));\n    color = mix(color, vec3(1.0,0.0,0.0), heathFragColor);\n    \n    // Final Frag Colour\n\tfragColor = vec4(vec3(color), 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// --------------------\n// \t\t  Logic\n// --------------------\n\nconst float KEY_LEFT  \t\t\t= 37.5f / 256.0f;\nconst float KEY_UP    \t\t\t= 38.5f / 256.0f;\nconst float KEY_RIGHT \t\t\t= 39.5f / 256.0f;\nconst float KEY_DOWN  \t\t\t= 40.5f / 256.0f;\nconst float KEY_SPACE \t\t\t= 32.5f / 256.0f;\n\nconst float MOVE_SPEED\t\t\t= 0.01f;\n\n\n// Texture Register\nconst vec2 TX_CAMERA_POS \t\t= vec2(0.0,0.0);\n\n// Program State\nstruct ProgramState\n{\n    vec4 cameraPos;\n} state;\n\nvec4 loadValue(vec2 texel)\n{\n    return texelFetch(iChannel1, ivec2(texel.x, texel.y), 0 );\n}\n\nvoid loadGameState()\n{\n    state.cameraPos = loadValue(TX_CAMERA_POS);\n}\n\nvec4 saveState(vec2 fragCoord)\n{\n    vec4 fragColor;\n    \n    fragCoord = floor(fragCoord);\n    \n    if(fragCoord == TX_CAMERA_POS)\n    {\n    \tfragColor = state.cameraPos;\n    }\n    \n    return fragColor;\n}\n\n// Main\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragCoord = floor(fragCoord);\n    \n    loadGameState();\n    \n    // Key inputs\n    bool keyLeft  \t= texture( iChannel0, vec2( KEY_LEFT, .25 ) ).x > .5;\n    bool keyRight \t= texture( iChannel0, vec2( KEY_RIGHT, .25 ) ).x > .5;\n    bool keyUp  \t= texture( iChannel0, vec2( KEY_UP, .25 ) ).x > .5;\n    bool keyDown \t= texture( iChannel0, vec2( KEY_DOWN, .25 ) ).x > .5;\n    bool keySpace \t= texture( iChannel0, vec2( KEY_SPACE, .25 ) ).x > .5;\n    \n    // Player Movement\n    if(fragCoord == TX_CAMERA_POS)\n    {\t\n        float xPos = state.cameraPos.x;\n        float yPos = state.cameraPos.y;\n        if(keyLeft)\n        {\n            xPos -= MOVE_SPEED;\n            if(xPos < -0.5)\n            {\n                xPos = -0.5;\n            }\n        }\n        else if(keyRight)\n        {\n            xPos += MOVE_SPEED;\n            if(xPos > 0.5)\n            {\n                xPos = 0.5;\n            }\n        }\n\n        if(keyUp)\n        {\n            yPos += MOVE_SPEED;\n            if(yPos > 0.5)\n            {\n                yPos = 0.5;\n            }\n        }\n        else if(keyDown)\n        {\n            yPos -= MOVE_SPEED;\n            if(yPos < -0.5)\n            {\n                yPos = -0.5;\n            }\n        }\n\n        // Update Player Position in State\n        state.cameraPos.x = xPos;\n        state.cameraPos.y = yPos;\n    }\n    \n    \n    fragColor = saveState(fragCoord);\n}","name":"Buf A","description":"","type":"buffer"}]}