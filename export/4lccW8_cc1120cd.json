{"ver":"0.1","info":{"id":"4lccW8","date":"1532328709","viewed":393,"name":"Distance function & tessellation","username":"barakchamo","description":"Distance function & tessellation","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["voronoi","distance","function","manhattan","minkowski","tessellation","euclidean","chebyshev","weight"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/* Euclidean distance */\n/* https://en.wikipedia.org/wiki/Euclidean_distance */ \nfloat euclideanDistance(float p1, float p2) {\n\tfloat d1 = (p1 - p2);\n\treturn sqrt(pow(d1, 2.0));\n}\n\nfloat euclideanDistance(vec2 p1, vec2 p2) {\n\tfloat d1 = (p1.x - p2.x);\n\tfloat d2 = (p1.y - p2.y);\n\treturn sqrt(pow(d1, 2.0) + pow(d2, 2.0));\n}\n\nfloat euclideanDistance(vec3 p1, vec3 p2) {\n\tfloat d1 = (p1.x - p2.x);\n\tfloat d2 = (p1.y - p2.y);\n\tfloat d3 = (p1.z - p2.z);\n\treturn sqrt(pow(d1, 2.0) + pow(d2, 2.0) + pow(d3, 2.0));\n}\n\n/* Manhattan distance */\n/* https://en.wikipedia.org/wiki/Taxicab_geometry */ \nfloat manhattanDistance(float p1, float p2) {\n\tfloat d1 = abs(p1 - p2);\n\treturn d1;\n}\n\nfloat manhattanDistance(vec2 p1, vec2 p2) {\n\tfloat d1 = abs(p1.x - p2.x);\n\tfloat d2 = abs(p1.y - p2.y);\n\treturn d1 + d2;\n}\n\nfloat manhattanDistance(vec3 p1, vec3 p2) {\n\tfloat d1 = abs(p1.x - p2.x);\n\tfloat d2 = abs(p1.y - p2.y);\n\tfloat d3 = abs(p1.z - p2.z);\n\treturn d1 + d2 + d3;\n}\n\n/* Minkowski distance */\n/* https://en.wikipedia.org/wiki/Minkowski_distance */ \nfloat minkowskiDistance(float p1, float p2, float power) {\n\tfloat d1 = pow(abs(p1 - p2), power);\n\treturn pow(d1, 1.0 / power);\n}\n\nfloat minkowskiDistance(vec2 p1, vec2 p2, float power) {\n\tfloat d1 = pow(abs(p1.x - p2.x), power);\n\tfloat d2 = pow(abs(p1.y - p2.y), power);\n\treturn pow(d1 + d2, 1.0 / power);\n}\n\nfloat minkowskiDistance(vec3 p1, vec3 p2, float power) {\n\tfloat d1 = pow(abs(p1.x - p2.x), power);\n\tfloat d2 = pow(abs(p1.y - p2.y), power);\n\tfloat d3 = pow(abs(p1.z - p2.z), power);\n\treturn pow(d1 + d2 + d3, 1.0 / power);\n}\n\n/* Chebyshev distance */\n/* https://en.wikipedia.org/wiki/Chebyshev_distance */ \nfloat chebyshevDistance(float p1, float p2) {\n\tfloat d1 = abs(p1 - p2);\n\treturn d1;\n}\n\nfloat chebyshevDistance(vec2 p1, vec2 p2) {\n\tfloat d1 = abs(p1.x - p2.x);\n\tfloat d2 = abs(p1.y - p2.y);\n\treturn max(d1, d2);\n}\n\nfloat chebyshevDistance(vec3 p1, vec3 p2) {\n\tfloat d1 = abs(p1.x - p2.x);\n\tfloat d2 = abs(p1.y - p2.y);\n\tfloat d3 = abs(p1.z - p2.z);\n\treturn max(d1, max(d2, d3));\n}\n\n\n\n\n/* Tesselation Demo Fragment Shader */\n/* Try this at: shadertoy link */\nuniform float uTime;\n\nvec2 hash( vec2 p ) {\n\tp = vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))); \n\treturn fract(sin(p)*18.5453);\n}\n\nfloat random (vec2 st) {\n    return fract(sin(dot(st.xy, vec2(12.9898, 78.233))) * 43758.5453123);\n}\n\n/* distance tesselation */\nvec2 tessellate( in vec2 x, in float wf ) {\n    vec2 n = floor( x );\n    vec2 f = fract( x );\n\n\t// weight factor\n\tfloat w = random(n) * wf;\n\n\t// MODIFY THIS:\n\t// Maximum distance for distance function\n\t// 2.0 and up should cover the whole distance\n\t// Less will form distance bubbles\n\tvec2 m; \n\tm = vec2( 2.0 );\n\t// m = vec2( 0.5 );\n\n\t// Cover a unit range around the point\n    for( int j=-1; j<=1; j++ )\n    for( int i=-1; i<=1; i++ )\n    {\n\t\t// distance point (edges of the unit square around the point)\n        vec2  g = vec2( float(i), float(j) );\n\n\t\t// random point inside the unit square\n\t\t// Basically, random point inside the tile\n        vec2  o = hash( n + g );\n\n\t\t// move the point around the tile based on sin(time);\n\t    vec2  r = g - f + (0.5+0.5*sin(iTime+6.2831*o));\n\t\tfloat w = random(o) * wf;\n\n\t\t// Get the vector's distance from origin\n\t\t// This is similar to the self dot product operation dot(r,r);\n\t\tfloat d;\n\n\t\t// MODIFY THIS: try using different functions\n\t\t//d = euclideanDistance(vec2(0), r);\n\t\t// d = manhattanDistance(vec2(0), r);\n\t\td = minkowskiDistance(vec2(0), r, 2.0 + sin(iTime * 1.0));\n\t\t// d = chebyshevDistance(vec2(0), r);\n\n\t\t// Additively weight the distance\n\t\td += w;\n\n        if( d<m.x )\n            m = vec2( d, o );\n    }\n \n\t// Return point distance\n    return m;\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 st = fragCoord/iResolution.y;\n\n\t// MODIFY THIS:\n\t// Tile the coordinate space\n\tst *= 5.0;\n\t\n\t// MODIFY THIS:\n\t// Weight factor applied to a random weight coefficient in the tesselation function\n\t// https://en.wikipedia.org/wiki/Weighted_Voronoi_diagram\n\tfloat weightFactor = (1.0 + sin(iTime / 2.0)) / 2.0;\n\n\t// Generate tessellate pattern\n\tvec2 c = tessellate( st, weightFactor );\n\t\n\t// Colorize\n    vec3 col = 0.5 + 0.5 * cos( 3.0 + c.y * 3.0 + c.x + vec3(1.5,1.0,0.5) );\t\n    \n\t// Add distance-based gradient\n\tcol *= clamp(1.0 - 0.2 * pow(c.x, 2.0), 0.0,1.0);\n    \n\t// Draw points\n\tcol -= (1.0-smoothstep( 0.01, 0.05, c.x));\n\t\n    fragColor = vec4( col, 1.0 );\n}","name":"Image","description":"","type":"image"}]}