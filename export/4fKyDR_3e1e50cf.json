{"ver":"0.1","info":{"id":"4fKyDR","date":"1731711437","viewed":84,"name":"Parameter SDF Gradient Descent","username":"chronos","description":"Visualizing the distance field as a scalar field over the parameter space of a line segment and a quadratic Bernstein-Bezier curve.","likes":14,"published":1,"flags":0,"usePreview":0,"tags":["3d","sdf","visualization","bezier","space","distance","curve","field","decasteljau","bernstein","parameter"],"hasliked":0,"parentid":"MfGyDR","parentname":"Parameter Space Distance Field"},"renderpass":[{"inputs":[{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n    Parameter SDF Gradient Descent by chronos\n    --------------------------------------------------------\n    \n    Forked shader, but extended with a gradient descent optimization run that\n    tries to find a local minimum distance between the curve and segment.\n    \n    --------------------------------------------------------\n    self link: https://www.shadertoy.com/view/4fKyDR\n    \n    Forked shader description:\n    ------------------------------------------------------------\n        Parameter Space Distance Field Visualization by chronos\n        --------------------------------------------------------\n\n        Interactive, click and drag in inset.\n\n        plots distance, gradient and contours for distance between a line segment\n        and quadratic Bernstein Bezier curve over the parameter space.\n        X-axis: Line segment parameter\n        Y-Axis: Bezier curve parameter\n    ------------------------------------------------------------\n*/\nfloat sRGBencode(float C_linear) { return C_linear > 0.0031308 ? (1.055 * pow(C_linear, 1./2.4) - 0.055) : (12.92 * C_linear); }\nvec3 sRGBencode(vec3 C_linear) { C_linear = clamp(C_linear, 0., 1.); return vec3(sRGBencode(C_linear.x), sRGBencode(C_linear.y), sRGBencode(C_linear.z)); }\n\n\nfloat seg(vec3 a, vec3 b, vec3 p)\n{\n    b-=a; p-=a;\n    return length(clamp(dot(p,b)/dot(b,b), 0., 1.)*b - p);\n}\n\nfloat seg(vec2 a, vec2 b, vec2 p)\n{\n    b-=a; p-=a;\n    return length(clamp(dot(p,b)/dot(b,b), 0., 1.)*b - p);\n}\n\nvec3 deCasteljau(vec3 a, vec3 b, vec3 c, float t)\n{\n    return mix(\n        mix(a, b, t),\n        mix(b, c, t),\n        t\n    );\n}\n\nfloat map(vec3 A, vec3 B, vec3 C0, vec3 C1, vec3 C2, vec2 p)\n{\n    float dist = distance(mix(A, B, p.x), deCasteljau(C0, C1, C2, p.y));\n    return dist;\n}\n\nvec2 grad(vec3 A, vec3 B, vec3 C0, vec3 C1, vec3 C2, vec2 p)\n{\n    float eps = 0.001;\n    return normalize(vec2(\n        (map(A, B, C0, C1, C2, p+vec2(1,0)*eps)-map(A, B, C0, C1, C2, p+vec2(-1,0)*eps)),\n        (map(A, B, C0, C1, C2, p+vec2(0,1)*eps)-map(A, B, C0, C1, C2, p+vec2( 0,-1)*eps))\n    ))\n    ;\n}\n\nvec3 draw_inset(vec3 C0, vec3 C1, vec3 C2, vec3 A, vec3 B, vec2 uv, vec2 mouse)\n{\n    float seg_t = uv.x;\n    float bez_t = uv.y;\n    \n    // Evaluate Bezier curve and line segment:\n    vec3 C = deCasteljau(C0, C1, C2, bez_t);\n    vec3 P = mix(A, B, seg_t);\n    \n    float dist = distance(P, C);\n    \n    // This should be updated if the scene changes:\n    float min_dist = 0.6;\n    float max_dist = 1.5;\n    \n    float remapped_dist = clamp((dist-min_dist)/(max_dist-min_dist), 0., 1.);\n    \n    vec2 gradient = vec2(dFdx(dist), dFdy(dist));\n\n    float hue = atan(gradient.y, gradient.x);\n    vec3 gradient_color = (vec3(cos(hue), sin(hue), 0.) * max(1.-length(gradient), 0.) + vec3(0,0, sqrt(max(1.-dot(gradient,gradient), 0.))) )*.5 + .5;\n    \n    float perceptual_brightness = pow(remapped_dist, 3.);\n    \n    vec3 color = perceptual_brightness * gradient_color;\n    \n    // Draw topograpic / contour plot\n    const float freq = 17.76125;\n    float ps = length(fwidth(freq * dist));\n    color *= (smoothstep(0.5+.5*ps,0.5+1.5*ps, fract(freq * dist)) + smoothstep(0.5-.5*ps,0.5-1.5*ps, fract(freq * dist)))*.6+.4;\n    \n    // Draw mouse parameter position\n    ps = 2./iResolution.y;\n    color = mix(color, vec3(0,0,0), smoothstep(ps, -ps, length(mouse-uv)-0.03));\n    color = mix(color, vec3(1), smoothstep(ps, -ps, length(mouse-uv)-0.02));\n    \n    int max_steps = 15;\n    vec2 q = mouse;\n    for(int i = 0; i < max_steps; i++)\n    {\n        float dist = map(A, B, C0, C1, C2, q);\n        vec2 grad = grad(A, B, C0, C1, C2, q);\n        \n        vec2 p = clamp(q-.05*dist*grad, 0., 1.);\n        \n        color=mix(color, vec3(1), .5*smoothstep(ps, -ps, seg(q,p,uv)-0.005));\n        color=mix(color, vec3(max_steps-1-i,0,i)/float(max_steps), .75*smoothstep(ps, -ps, length(p-uv)-0.025));\n        color=mix(color, vec3(0), smoothstep(ps, -ps, abs(length(p-uv)-0.025)-0.005));\n        \n        q = p;\n    }\n    \n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 color = vec3(0);\n    \n    vec2 uv = (2.*fragCoord-iResolution.xy)/iResolution.y;\n    vec2 mouse = (2.*iMouse.xy-iResolution.xy)/iResolution.y;\n    \n    // Camera parameters\n    float focal = 2.;\n    vec3 rd = normalize(vec3(uv, -focal));\n    vec3 ro = vec3(0, 1, 2.*focal);\n    \n    float time = iTime*.6;\n    float c = cos(time), s = sin(time);\n    mat3 R = mat3( c,0,s, 0,1,0,  -s,0,c );\n    \n    // Idle mouse animation\n    if(length(iMouse.xy) < 10.)\n    {\n        time = iTime*.8;\n        c = cos(time), s = sin(time);\n        mouse = vec2(c, s) * .35 + vec2(1, .5);\n    }\n   \n    // Rotate camera\n    rd *= R;\n    ro *= R;\n   \n    float eps = 1e-3;\n    \n    // Line segment endpoints\n    vec3 A = vec3(0.5,1.5,0.5);\n    vec3 B = vec3(-.5,0.5,-.5);\n    \n    // Bernstein-Bezier curve controlpoints\n    vec3 C0 = vec3(-1,.75,-1);\n    vec3 C1 = vec3(-2,.5,2);\n    vec3 C2 = vec3( 1,.25,1);\n    \n    // Use gradient descent to find a local minimum:\n    // Written to match the optimization in draw_inset, so if any of them change, the other\n    // Has to be updated to match. Should ideally be refactored, but I'm lazy :)\n    int max_steps = 15;\n    vec2 q = mouse;\n    for(int i = 0; i < max_steps; i++)\n    {\n        float dist = map(A, B, C0, C1, C2, q);\n        vec2 grad = grad(A, B, C0, C1, C2, q);\n        \n        vec2 p = clamp(q-.05*dist*grad, 0., 1.);   \n        q = p;\n    }\n    \n    // Evaluate segment and cuve at local minimum:\n    vec3 P_min =  mix(A, B, clamp(q.x, 0., 1.));\n    vec3 C_min =  deCasteljau(C0, C1, C2, clamp(q.y, 0., 1.));\n    \n    // Render scene\n    float min_t = 9e9;\n    float t = 0.;\n    for(int i = 0; i < 100; i++)\n    {\n        vec3 p = rd * t + ro;\n        \n        float d = seg(A, B, p)-0.01;\n        d = min(d, length(p-A)-0.02);\n        d = min(d, length(p-B)-0.02);\n        \n        d = min(d, length(p-C0)-0.02);\n        d = min(d, length(p-C2)-0.02);\n        \n        \n        vec3 AB = mix(A,B, clamp(mouse.x-.5, 0., 1.));\n        vec3 C = deCasteljau(C0, C1, C2, clamp(mouse.y, 0., 1.));\n        d = min(d, length(p-AB)-0.03);\n        d = min(d, length(p-C)-0.03);\n        d = min(d, seg(AB, C, p)-0.01);\n        d = min(d, seg(P_min, C_min, p)-0.01);\n        \n        vec3 C_prev = C0;\n        for(float x = 0.1; x <= 1.01; x+=0.1)\n        {\n            C = deCasteljau(C0, C1, C2, x);\n            d = min(d, seg(C_prev, C, p)-0.01);\n            C_prev = C;\n        }\n        \n        if(d < eps)\n        {\n            color += 1.;\n            min_t = t;\n            break;\n        }\n        \n        t += d;\n    }\n    \n    \n    // Draw ground plane:\n    \n    t = -ro.y/rd.y;\n    if(t >= 0. && t < min_t)\n    {\n        vec3 p = rd * t + ro;\n        vec2 tex_uv = fract(p.xz*.5+.5);\n        vec3 tex = pow(texture(iChannel3, tex_uv).rgb, vec3(2.2));\n        color += tex * step(abs(p.x),1.)* step(abs(p.z),1.);\n    }\n    \n    \n    // Draw inset\n    {\n        uv.x -= .5; mouse.x-=.5;\n        if(uv.x>= 0. && uv.y >= 0. && uv.x <= 1. && uv.y <= 1.)\n        {\n            color = draw_inset(C0, C1, C2, A, B, uv, clamp(mouse, 0., 1.));\n        }\n    }\n\n    fragColor = vec4(sRGBencode(color), 1);\n}","name":"Image","description":"","type":"image"}]}