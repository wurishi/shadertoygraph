{"ver":"0.1","info":{"id":"4d3fWX","date":"1592583091","viewed":2097,"name":"Light Propagation","username":"Mathis","description":"Light Propagation Volumes with anisotropic voxels.\nImplemented temporal injection of sunlight, multiple bounces and emissive/skylight/sunlight.\n\nControls:\nMouse to look around\nWASD to move\nSpace if you gotta go fast\n, and . to rotate the sun","likes":65,"published":1,"flags":48,"usePreview":1,"tags":["global","illumination","light","voxel","propagation","radiosity"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":3,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Light Propagation Volumes with anisotropic voxels\n\nfloat Schlick(float R0, float COS) {\n    //Schlick approximation\n    return R0+(1.-R0)*pow(1.-COS,5.);\n}\n\nvec4 MIXL(vec2 f, vec2 bvt, out vec3 NC) {\n    vec3 C12,C22,C32,C42;\n    vec4 CC1=texture(iChannel1,bvt*ires);\n    vec4 CC2=texture(iChannel1,(bvt+vec2(1.,0.))*ires);\n    vec4 CC3=texture(iChannel1,(bvt+vec2(0.,1.))*ires);\n    vec4 CC4=texture(iChannel1,(bvt+vec2(1.,1.))*ires);\n    vec3 C11=ReadV(CC1.xyz,C12);\n    vec3 C21=ReadV(CC2.xyz,C22);\n    vec3 C31=ReadV(CC3.xyz,C32);\n    vec3 C41=ReadV(CC4.xyz,C42);\n    NC=mix(mix(C12*(1.-CC1.w),C22*(1.-CC2.w),f.x),mix(C32*(1.-CC3.w),C42*(1.-CC4.w),f.x),f.y);\n    return vec4(mix(mix(C11*(1.-CC1.w),C21*(1.-CC2.w),f.x),mix(C31*(1.-CC3.w),C41*(1.-CC4.w),f.x),f.y),\n        mix(mix((1.-CC1.w),(1.-CC2.w),f.x),mix((1.-CC3.w),(1.-CC4.w),f.x),f.y)+0.01);\n}\n\nvec3 MIX(vec3 f, vec2 bvt1, vec2 bvt2, out vec3 NC) {\n    /*\n\t//Nearest\n    vec3 C=ReadV(texture(iChannel1,bvt1*ires).xyz,NC);\n    return C;\n\t//*/\n    \n    //*\n    //Linear\n\tvec3 NC1,NC2;\n    vec4 PC1=MIXL(f.xy,bvt1,NC1);\n    vec4 PC2=MIXL(f.xy,bvt2,NC2);\n    NC=mix(NC1.xyz,NC2.xyz,f.z)/mix(PC1.w,PC2.w,f.z);\n    return mix(PC1.xyz,PC2.xyz,f.z)/mix(PC1.w,PC2.w,f.z);\n\t//*/\n}\n\nvec3 SampleLPV(vec3 P, vec3 N) {\n    vec3 f=fract(P-vec3(0.5,0.5,0.5));\n    vec2 pvt1=PToUV(P+vec3(-0.5,-0.5,-0.5));\n    vec2 pvt2=PToUV(P+vec3(-0.5,-0.5,0.5));\n    vec3 vDS=N.xyz*N.xyz;\n    vec3 xC,yC,zC,CC;\n    xC=MIX(f,pvt1,pvt2,CC); xC=((N.x>0.)?xC:CC);\n    yC=MIX(f,pvt1+vec2(0.,64.),pvt2+vec2(0.,64.),CC); yC=((N.y>0.)?yC:CC);\n    zC=MIX(f,pvt1+vec2(0.,128.),pvt2+vec2(0.,128.),CC); zC=((N.z>0.)?zC:CC);\n    return xC*vDS.x+yC*vDS.y+zC*vDS.z;\n}\n\nvec3 Integral(vec3 P, vec3 N) {\n    vec3 Tann,Bitt;\n    Tann=NT(N,Bitt);\n    return SampleLPV(P,N).xyz*SAFram+\n    (SampleLPV(P,Bitt).xyz+SampleLPV(P,-Bitt).xyz+\n    SampleLPV(P,Tann).xyz+SampleLPV(P,-Tann).xyz)*SASida;\n}\n\nbool SRay(vec3 pos, vec3 dir, out Hit R) {\n    vec3 IDir=1./dir; vec3 fp,lfp; vec4 C;\n    float FAR=boxfar(pos,1./dir,vec3(0.),vec3(32.));\n    float dist=0.;\n    bool OUTSIDE=Box(pos,vec3(32.))>0.;\n    if (OUTSIDE) {\n        vec2 B=box(pos,1./dir,vec3(0.),vec3(32.));\n        if (B.x>0. && B.y>B.x) {\n            dist=B.x+0.01;\n        } else {\n            return false;\n        }\n    } else {\n        //Initial voxel\n        fp=floor(pos);\n        dist+=boxfar(pos,IDir,fp,fp+1.)+0.0001;\n        lfp=fp;\n    }\n    //Ray tracing\n    for (int i=0; i<100; i++) {\n        if (dist>FAR) break;\n        R.P=pos+dir*dist;\n        fp=floor(R.P);\n        C=texture(iChannel0,(PToUV(R.P)+vec2(0.,1.))*ires);\n        if (C.w>0.) {\n            R.D=dist;\n            R.N=lfp-fp;\n            R.C=((OUTSIDE && i==0)?vec3(0.):C.xyz);\n            R.Mat=C.w-1.;\n            return true;\n        }\n        dist+=boxfar(R.P,IDir,fp,fp+1.)+0.0001;\n        lfp=fp;\n    }\n    return false;\n}\n\nvec3 DirectLight(vec3 P, vec3 N, vec3 LD) {\n    float SunDot=dot(LD,N); Hit Shad;\n    return ((SunDot<0.)?vec3(0.):SunColor*(SunDot*0.8*(1.-float(SRay(P,LD,Shad)))));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n//Light direction\n    vec3 LD=texture(iChannel0,vec2(5.5,0.5)*ires).xyz;\n//Camera\n    vec2 uv=fragCoord.xy/iResolution.xy;\n    float Rot=-(iMouse.x/iResolution.x)*3.14*3.;\n\tvec3 Pos=texture(iChannel0,vec2(3.5,0.5)*ires).xyz;\n    mat3 MM=TBN(texture(iChannel0,vec2(2.5,0.5)*ires).xyz);\n    vec3 Dir=normalize(vec3((uv*2.-1.)*(Aspect*1.1),1.)*MM);\n//Trace\n    vec3 Color=vec3(0.);\n    Hit Pixel;\n    if (SRay(Pos,Dir,Pixel)) {\n        if (Pixel.Mat==1.) {\n            Color=Pixel.C;\n        } else {\n            //Normal map\n            vec2 RV=mix(texture(iChannel3,(((Pixel.P.xz+vec2(0.,floor(Pixel.P.y*10.)*71.))*10.)+0.5)/1024.).xz,\n                texture(iChannel3,(((Pixel.P.xz+vec2(0.,floor(Pixel.P.y*10.+1.)*71.))*10.)+0.5)/1024.).xz,\n                fract(Pixel.P.y*10.))*vec2(3.14159*2.,1.);\n            vec3 NN=normalize(vec3(vec2(sin(RV.x),cos(RV.x))*RV.y,0.)*TBN(Pixel.N)*0.1+Pixel.N);\n            //Direct Light\n            Color=DirectLight(Pixel.P+Pixel.N*0.01,Pixel.N,LD);\n            //Indirect Light\n            Color+=Integral(Pixel.P+Pixel.N*0.5,-NN);\n            //Reflections\n            vec3 RC=vec3(0.);\n            vec3 RD=reflect(Dir,NN);\n            if (dot(Pixel.N,RD)<0.) RD=reflect(RD,Pixel.N);\n            vec3 RP=Pixel.P+Pixel.N*0.01;\n            Hit RHit;\n            if (SRay(RP,RD,RHit)) {\n                if (RHit.Mat==1.) {\n                    RC=RHit.C;\n                } else {\n                    RC=DirectLight(RHit.P,RHit.N,LD);\n                    //Indirect Light\n                    RC+=Integral(RHit.P+RHit.N*0.5,-RHit.N);\n                    RC*=RHit.C;\n                }\n            } else  {\n                RC=SkyColor*(-RD.y*0.5+1.)+SunColor*pow(max(0.,dot(LD,RD)),24.);\n            }\n            Color=mix(Color,RC,Schlick(0.05,dot(-Dir,Pixel.N)));\n            //Color\n            Color=Color*Pixel.C;\n        }\n    } else {\n        Color=SkyColor*(1.-Dir.y*0.5)+SunColor*pow(max(0.,dot(LD,Dir)),24.);\n    }\n    //Color=ReadVP(texture(iChannel1,uv).xyz);\n    fragColor=vec4(pow(1.-exp(-1.3*Color),vec3(0.45)),1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"//SETTINGS\nconst float VoxelisationDist=0.353;\n//CONSTANTS\nconst vec2 eps=vec2(0.0005,0.);\nconst float i32=1./32.;\nconst float SAFram=0.24145316170843;\nconst float SASida=0.18443362850791;\nconst float i9=1./0.999;\nconst vec3 Offsets[3]=vec3[3](vec3(1.,0.,0.),vec3(0.,1.,0.),vec3(0.,0.,1.));\nconst vec2 Offsets2[9]=vec2[9](vec2(0.,0.),vec2(0.25,0.25),vec2(0.,0.25),vec2(-0.25,0.25),\n                              vec2(0.25,0.),vec2(-0.25,0.),vec2(0.25,-0.25),vec2(0.,-0.25),vec2(-0.25,-0.25));\n//Resolution\n#define ires 1./iResolution.xy\n#define Aspect vec2(iResolution.x/iResolution.y,1.)\n//Sun\n#define SunColor vec3(1.,0.9,0.7)*4.5\n//Sky\n#define SkyColor vec3(0.1,0.3,0.8)\n\nstruct DF { lowp vec3 c; highp float d; float Mat; };\nstruct Hit { vec3 P; vec3 N; vec3 C; float D; float Mat; };\n\nfloat Box(vec3 p, vec3 b) {\n    vec3 d=abs(p-b*0.5)-b*0.5;\n    return min(max(d.x,max(d.y,d.z)),0.)+length(max(d,0.));\n}\n\nfloat BoxC(vec3 p, vec3 b) {\n    vec3 d=abs(p)-b;\n    return min(max(d.x,max(d.y,d.z)),0.)+length(max(d,0.));\n}\n\nvec2 Rotate(vec2 p, float ang) {\n    float c=cos(ang), s=sin(ang);\n    return vec2(p.x*c-p.y*s,p.x*s+p.y*c);\n}\n\nvec2 Repeat(vec2 p, float n) {\n    float ang=2.*3.14159/n;\n    float sector=floor(atan(p.x,p.y)/ang+0.5);\n    p=Rotate(p,sector*ang);\n    return p;\n}\n\nfloat Plane(vec3 p, vec3 n, float offs) {\n  return dot(p,n)-offs;\n}\n\nfloat Line(vec3 p, vec3 a, vec3 b) {\n    vec3 ba=b-a;\n    float k=dot(p-a,ba)/dot(ba,ba);\n    return length((a+clamp(k,0.,1.)*(b-a))-p);\n}\n\nfloat smin(float a, float b, float k) {\n    float h=clamp(0.5+0.5*(b-a)/k,0.,1.);\n    return mix(b,a,h)-k*h*(1.-h);\n}\n\nvoid minn(inout DF df, DF a) {\n    df.d=((a.d<=df.d)?a.d:df.d);\n    df.c=((a.d<=df.d)?a.c:df.c);\n    df.Mat=((a.d<=df.d)?a.Mat:df.Mat);\n}\n\nvoid maxx(inout DF df, DF a) {\n    if (a.d>=df.d) df=a;\n}\n\nDF SDF(vec3 p, float Time) {\n    DF df=DF(vec3(1.),p.y-1.,0.);\n    //Yttre väggar\n \tdf.d=min(df.d,Box(p-vec3(0.,1.,0.),vec3(1.,6.,18.))); //Sida\n    df.d=min(df.d,Box(p-vec3(0.,1.,0.),vec3(32.,10.,1.))); //Bakre sida\n    df.d=min(df.d,Box(p-vec3(31.,1.,0.),vec3(1.,6.,18.))); //Andra sida\n    df.d=min(df.d,Box(p-vec3(13.,1.,18.),vec3(32.-13.,6.,1.))); //Främre sida vit\n    //Grönt rum\n    df.d=min(df.d,Box(p-vec3(0.,1.,18.),vec3(8.,6.,1.))); //Framför grön\n    df.d=min(df.d,Box(p-vec3(7.,1.,8.),vec3(1.,6.,10.))); //Bredvid grön\n    \tdf.d=min(df.d,Box(p-vec3(7.,1.,1.),vec3(1.,6.,5.))); //Bredvid grön liten\n    \t//Stänger\n    \tdf.d=min(df.d,Box(p-vec3(0.,7.,14.),vec3(8.,1.,1.)));\n    \tdf.d=min(df.d,Box(p-vec3(0.,7.,11.),vec3(8.,1.,1.)));\n    \tdf.d=min(df.d,Box(p-vec3(0.,7.,8.),vec3(8.,1.,1.)));\n    \tdf.d=min(df.d,Box(p-vec3(0.,7.,5.),vec3(8.,1.,1.)));\n    \t//Objekt på golvet\n    \tif (Box(p-vec3(2.,1.,8.),vec3(6.,3.,6.))<0.) {\n            df.d=min(df.d,Box(p-vec3(3.,1.,9.),vec3(1.,1.,1.)));\n            df.d=min(df.d,Box(p-vec3(4.,1.,12.),vec3(1.,2.,1.)));\n    \t}\n    //Closed rum\n    df.d=min(df.d,Box(p-vec3(20.,1.,12.),vec3(1.,6.,6.))); //Sida\n    df.d=min(df.d,Box(p-vec3(19.,6.,9.),vec3(12.,1.,10.))); //Tak\n        //df.d=min(df.d,Box(p-vec3(2.,12.,2.),vec3(28.,1.,20.)));\n    //Sfär linje\n    vec3 rp=p-vec3(14.,5.,1.);\n    minn(df,DF(vec3(1.,0.1,0.1),length(vec3(rp.x,rp.y,fract(rp.z*0.125)*8.-4.))-3.5,0.));\n    //Färgade väggar\n    minn(df,DF(vec3(0.,1.,0.),Box(p-vec3(1.,1.,17.),vec3(6.,6.,1.)),0.)); //Främre sida grön\n    \t//Bord\n    \tminn(df,DF(vec3(0.8,0.5,0.3),Box(p-vec3(3.,1.,3.),vec3(1.,2.,1.)),0.));\n    \tminn(df,DF(vec3(0.8,0.5,0.3),Box(p-vec3(2.,3.,2.),vec3(3.,1.,3.)),0.));\n   \tminn(df,DF(vec3(0.,1.,1.),Box(p-vec3(30.,1.,12.),vec3(1.,3.,6.)),1.)); //Emissive\n    \tminn(df,DF(vec3(1.),Box(p-vec3(28.,4.,12.),vec3(3.,1.,6.)),0.)); //Blocker över\n    \tminn(df,DF(vec3(1.),Box(p-vec3(27.,1.,14.),vec3(1.,2.,2.)),0.)); //Blocker framför\n    //Return\n\treturn df;\n}\n\nmat3 TBN(vec3 N) {\n    vec3 Nb,Nt;\n    if (abs(N.y)>0.999) {\n        Nb=vec3(1.,0.,0.);\n        Nt=vec3(0.,0.,1.);\n    } else {\n    \tNb=normalize(cross(N,vec3(0.,1.,0.)));\n    \tNt=normalize(cross(Nb,N));\n    }\n    return mat3(Nb.x,Nt.x,N.x,Nb.y,Nt.y,N.y,Nb.z,Nt.z,N.z);\n}\n\nvec3 NT(vec3 N, out vec3 Bit) {\n    if (abs(N.y)>0.999) {\n        Bit=vec3(1.,0.,0.);\n        return vec3(0.,0.,1.);\n    } else {\n    \tBit=normalize(cross(N,vec3(0.,1.,0.)));\n    \treturn normalize(cross(Bit,N));\n    }\n}\n\nvec3 StoreV(vec3 a, vec3 b) {\n    a=clamp(a,0.,1.); b=clamp(b,0.,1.); //Behövs?\n    return floor(a*1000.)+b*0.999;\n}\n\nvec3 ReadV(vec3 v, out vec3 NC) {\n    NC=fract(v)*i9;\n    return floor(v)*0.001; //returnerar positiva sidans färg\n}\n\nvec3 ReadVP(vec3 v) { return floor(v)*0.001; }\nvec3 ReadVN(vec3 v) { return fract(v)*i9; }\n\nvec2 PToUV(vec3 p) {\n    float ZZ=((p.z<16.)?0.:32.);\n    return vec2(floor(p.x)+floor(mod(p.z,16.))*32.,floor(p.y)+ZZ)+0.5;\n}\n\nfloat boxfar(vec3 origin, vec3 dir, vec3 bmin, vec3 bmax) {\n    vec3 tMin=(bmin-origin)*dir;\n    vec3 tMax=(bmax-origin)*dir;\n    vec3 t2=max(tMin,tMax);\n    return min(min(t2.x,t2.y),t2.z);\n}\n\nvec2 box(vec3 origin, vec3 dir, vec3 bmin, vec3 bmax) {\n    vec3 tMin=(bmin-origin)*dir;\n    vec3 tMax=(bmax-origin)*dir;\n    vec3 t1=max(tMin,tMax);\n    vec3 t2=min(tMin,tMax);\n    return vec2(max(max(t2.x,t2.y),t2.z),min(min(t1.x,t1.y),t1.z));\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//Vars + voxelized scen\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec4 Color=texture(iChannel0,fragCoord.xy/iResolution.xy);\n    if (iFrame==0) { //Initialization\n        if (fragCoord.x<10. && fragCoord.y<1.) { //Store vars\n            if (fragCoord.x<1.) Color=vec4(0.,0.,0.,0.); //Mouse\n            else if (fragCoord.x<2.) Color=vec4(-0.2,2.5,0.,0.); //Player Eye (Angles)\n            else if (fragCoord.x<3.) Color=vec4(0.,0.,0.,1.); //Player Eye (Vector)\n            else if (fragCoord.x<4.) Color=vec4(1.5,2.7,16.5,1.); //Player Pos\n            else if (fragCoord.x<5.) Color=vec4(0.2,4.,0.,1.); //Sun angles\n            else if (fragCoord.x<6.) Color=vec4(0.,0.,0.,1.); //Sun direction\n        }\n    } else { //Update\n\t\tif (fragCoord.x<10. && fragCoord.y<1.) { //Update vars\n            if (fragCoord.x<1.) { //Mouse\n                if (iMouse.z>0.) { //Börjat klicka\n                    if (Color.w==0.) {\n                    \tColor.w=1.;\n                    \tColor.xy=iMouse.zw;\n                    }\n                } else Color.w=0.;\n            } else if (fragCoord.x<2.) { //Player Eye (Angles)\n                vec4 LMouse=texture(iChannel0,vec2(0.5,0.5)*ires);\n                if (LMouse.w==0.)  Color.zw=Color.xy;\n                if (LMouse.w==1.) {\n                \t//Y led\n                \tColor.x=Color.z+(iMouse.y-LMouse.y)*0.01;\n                \tColor.x=clamp(Color.x,-2.8*0.5,2.8*0.5);\n                \t//X led\n                \tColor.y=Color.w-(iMouse.x-LMouse.x)*0.02;\n               \t\tColor.y=mod(Color.y,3.1415926*2.);\n                }\n            } else if (fragCoord.x<3.) { //Player Eye (Vector)\n                vec3 Angles=texture(iChannel0,vec2(1.5,0.5)*ires).xyz;\n                Color.xyz=normalize(vec3(cos(Angles.x)*sin(Angles.y),\n                  \t\t\t   \t\t\tsin(Angles.x),\n                  \t\t\t   \t\t\tcos(Angles.x)*cos(Angles.y)));\n            } else if (fragCoord.x<4.) { //Player Pos\n                float Speed=8.*iTimeDelta;\n                \tif (texelFetch(iChannel1,ivec2(32,0),0).x>0.) Speed=24.*iTimeDelta;\n                vec3 Eye=texture(iChannel0,vec2(2.5,0.5)*ires).xyz;\n                if (texelFetch(iChannel1,ivec2(87,0),0).x>0.) Color.xyz+=Eye*Speed; //W\n                if (texelFetch(iChannel1,ivec2(83,0),0).x>0.) Color.xyz-=Eye*Speed; //S\n                vec3 Tan=normalize(cross(vec3(Eye.x,0.,Eye.z),vec3(0.,1.,0.)));\n                if (texelFetch(iChannel1,ivec2(65,0),0).x>0.) Color.xyz-=Tan*Speed; //A\n                if (texelFetch(iChannel1,ivec2(68,0),0).x>0.) Color.xyz+=Tan*Speed; //D\n            } else if (fragCoord.x<5.) { //Sun angle\n                if (texelFetch(iChannel1,ivec2(188,0),0).x>0.) Color.y+=0.02;\n                if (texelFetch(iChannel1,ivec2(190,0),0).x>0.) Color.y-=0.02;\n            } else if (fragCoord.x<6.) { //Sun direction\n                vec2 Angles=texture(iChannel0,vec2(4.5,0.5)*ires).xy;\n                Color=vec4(normalize(vec3(cos(Angles.y),1.,sin(Angles.y))),1.);\n            }\n        } else if (fragCoord.x<512. && fragCoord.y<32.*2.+1.) { //Voxelisering\n            vec2 FUV=floor(fragCoord-vec2(0.,1.));\n            //vec2 uv=vec2(FUV.x+0.5,mod(FUV.y,64.)+1.5)*ires;\n            float AddZ=((fract(fragCoord.y*i32*0.5)<0.5)?0.:16.);\n            vec3 Pos=vec3(floor(fract(FUV.x*i32)*32.),floor(mod(FUV.y,32.))\n                      ,floor(FUV.x*i32)+AddZ)+0.5;\n            DF Voxel=SDF(Pos,iTime);\n        \tColor=((Voxel.d<VoxelisationDist)?vec4(Voxel.c,1.+Voxel.Mat):vec4(0.));\n        }\n    }\n    fragColor=Color;\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"//Indirect Light LPV\n\nfloat ShadowRay(vec3 pos, vec3 dir) {\n    vec3 IDir=1./dir; vec3 cp,fp; vec4 C;\n    float dist=0.;\n    float FAR=boxfar(pos,1./dir,vec3(0.),vec3(32.));\n    for (int i=0; i<48; i++) {\n        if (dist>FAR) break;\n        cp=pos+dir*dist;\n        fp=floor(cp);\n        C=texture(iChannel0,(PToUV(cp)+vec2(0.,1.))*ires);\n        if (C.w>0.) return 0.;\n        dist+=boxfar(cp,IDir,fp,fp+1.)+0.001;\n    }\n    return 1.;\n}\n\nvec3 PropagateAXIS(vec3 P, vec4 N, vec4 Tan, vec4 Bit, out vec3 LightN) {\n    vec2 CUV; vec3 LightP=vec3(0.); vec3 CYN,CXN,CYP,CXP; vec4 CC; vec3 BCN=vec3(0.);\n    //Negative\n    if (Box(P+N.xyz,vec3(32.))<0.) {\n        CUV=PToUV(P+N.xyz);\n        CC=texture(iChannel1,(CUV+vec2(0.,N.w))*ires);\n        LightN+=ReadVN(CC.xyz)*(CC.w*(1.-SAFram)+SAFram);\n        CYP=ReadV(texture(iChannel1,(CUV+vec2(0.,Tan.w))*ires).xyz,CYN);\n        CXP=ReadV(texture(iChannel1,(CUV+vec2(0.,Bit.w))*ires).xyz,CXN);\n        LightN+=(CYP+CYN+CXP+CXN)*SASida;\n    \tBCN=texture(iChannel0,(CUV+vec2(0.,1.))*ires).xyz;\n    } else\n        LightN=vec3(0.);\n    //Positive\n    if (Box(P-N.xyz,vec3(32.))<0.) {\n        CUV=PToUV(P-N.xyz);\n        CC=texture(iChannel1,(CUV+vec2(0.,N.w))*ires);\n        LightP+=ReadVP(CC.xyz)*(CC.w*(1.-SAFram)+SAFram);\n        CYP=ReadV(texture(iChannel1,(CUV+vec2(0.,Tan.w))*ires).xyz,CYN);\n        CXP=ReadV(texture(iChannel1,(CUV+vec2(0.,Bit.w))*ires).xyz,CXN);\n        LightP+=(CYP+CYN+CXP+CXN)*SASida;\n    } else\n        LightP=vec3(0.);\n    //Add bounce light\n    \tLightN+=LightP*BCN*0.99;\n    \tLightP+=LightN*texture(iChannel0,(CUV+vec2(0.,1.))*ires).xyz*0.99;\n    //Return\n    return LightP;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec4 Color=vec4(0.);\n    float Occ=0.;\n    vec3 CCN=vec3(0.); vec3 CCP=vec3(0.);\n    if (fragCoord.x<512. && fragCoord.y<32.*6.) { //Voxelisering\n        vec2 FUV=floor(fragCoord);\n        vec2 uv=vec2(FUV.x+0.5,mod(FUV.y,64.)+0.5)*ires;\n        //Voxel position\n        float AddZ=((fract(FUV.y*i32*0.5)<0.5)?0.:16.);\n        vec3 Pos=vec3(floor(fract(FUV.x*i32)*32.),floor(mod(FUV.y,32.))\n                      ,floor(FUV.x*i32)+AddZ)+0.5;\n        //Voxelisation\n        \t//One-point isotropic voxelisation\n        DF VoxelColor=SDF(Pos,iTime);\n        if (VoxelColor.d<VoxelisationDist) {\n            Occ=(VoxelisationDist-max(0.,VoxelColor.d))/VoxelisationDist;\n            //Inject direct light\n            if (VoxelColor.Mat==1.) {\n                 //Emissive\n                Color=vec4(StoreV(VoxelColor.c,VoxelColor.c),Occ);\n            } else if (VoxelColor.Mat==0.) {\n                //Är väggvoxel\n                \n                /*\n                //Binary sun-occlusion\n                vec3 Normal=Offsets[int(floor(fragCoord.y/64.))];\n                vec3 SunDir=texture(iChannel0,vec2(5.5,0.5)*ires).xyz;\n                float SunDot=dot(SunDir,Normal);\n                if (SunDot>0.)\n                    CCP=SunColor*(SunDot*ShadowRay(Pos+Normal,SunDir));\n               \telse\n                    CCN=SunColor*(-SunDot*ShadowRay(Pos-Normal,SunDir));\n                Color=vec4(StoreV(CCP*VoxelColor.c,CCN*VoxelColor.c),Occ);\n\t\t\t\t//*/\n                \n                //*\n                //Temporal sun-occlusion\n                vec3 Normal=Offsets[int(floor(fragCoord.y/64.))];\n                vec3 Bit; vec3 Tan=NT(Normal,Bit);\n                vec2 TOffset2=Offsets2[int(mod(float(iFrame),9.))];\n                vec3 TOffset3=TOffset2.x*Tan+TOffset2.y*Bit;\n                vec3 SunDir=texture(iChannel0,vec2(5.5,0.5)*ires).xyz;\n                float SunDot=dot(SunDir,Normal);\n                if (SunDot>0.)\n                    CCP=SunColor*(SunDot*ShadowRay(Pos+Normal+TOffset3,SunDir));\n               \telse\n                    CCN=SunColor*(-SunDot*ShadowRay(Pos-Normal+TOffset3,SunDir));\n                vec3 LCCN; vec3 LCCP=ReadV(texture(iChannel1,fragCoord.xy*ires).xyz,LCCN);\n                Color=vec4(StoreV((CCP*VoxelColor.c+LCCP*9.)/10.,(CCN*VoxelColor.c+LCCN*9.)/10.),Occ);\n\t\t\t\t//*/\n            }\n        } else {\n            //Propagate light\n            if (fragCoord.y<64.) { //X-sidor\n                CCP=PropagateAXIS(Pos,vec4(1.,0.,0.,0.),\n                \tvec4(0.,1.,0.,64.),vec4(0.,0.,1.,128.),CCN);\n            } else if (fragCoord.y<128.) { //Y-sidor\n                CCP=PropagateAXIS(Pos,vec4(0.,1.,0.,64.),\n                \tvec4(1.,0.,0.,0.),vec4(0.,0.,1.,128.),CCN);\n        \t\t//Injicering av skylight\n            \tCCP+=SkyColor*ShadowRay(Pos+vec3(0.,0.55,0.),vec3(0.,1.,0.))*0.075;\n            } else { //Z-sidor\n                CCP=PropagateAXIS(Pos,vec4(0.,0.,1.,128.),\n                \tvec4(0.,1.,0.,64.),vec4(1.,0.,0.,0.),CCN);\n            }\n            Color=vec4(StoreV(CCP,CCN),Occ);\n        }\n        fragColor=Color;\n    } else fragColor=vec4(0.,0.,0.,1.);\n}","name":"Buffer B","description":"","type":"buffer"}]}