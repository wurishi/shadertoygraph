{"ver":"0.1","info":{"id":"lljczV","date":"1509442708","viewed":566,"name":"plotting: continuous interval","username":"hornet","description":"random test on forcing a continuous plot by checking neighbourhood-interval.\n\n( see also https://www.shadertoy.com/view/4sB3zz )","likes":10,"published":1,"flags":0,"usePreview":0,"tags":["interval"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sf3Rn","filepath":"/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","previewfilepath":"/media/ap/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","type":"texture","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float f( float x, int idx )\n{\n    float t = x + sin(iTime);\n\n    if ( idx == 2 )\n    \treturn sin(t*t*t)*sin(t);\n    else if ( idx == 1 )\n    \treturn step( fract(t), 0.5 ) - 0.5;\n    else\n    {\n        //return fract(t);\n        //return 0.1 * tan( t );\n        return texture(iChannel0, vec2(0.2*t,0.5)).r - 0.5;\n    }\n}\n\nfloat eval_step( vec2 uv, int idx )\n{\n    //note: evaluate function at pixel-edges\n    //      +-------+\n\t//      |       |\n\t//      x0  x  x1\n\t//      |       |\n\t//      +-------+\n    float dx = 0.5 * dFdx( uv.x );\n    float x0 = uv.x - dx;\n    float x1 = uv.x + dx;\n    float y0 = f( x0, idx );\n    float y1 = f( x1, idx );\n\n    //note: determine if center is within the interval, y0 < uv.y < y1\n    float mn = min(y0,y1);\n    float mx = max(y0,y1);\n    float w = dFdy(uv.y);\n    float c = step( mn-w, uv.y ) * step( uv.y, mx+w );\n\n    return c;\n}\n\nfloat sd_segment(vec2 p, vec2 a, vec2 b)\n{\n    vec2 ab=b-a,ap=p-a;\n    return length(ap-ab*clamp(dot(ab,ap)/dot(ab,ab), 0.0, 1.0));\n}\nfloat eval_dist( vec2 uv, int idx )\n{\n    //note: evaluate function at pixel-edges\n    //      +-------+\n\t//      |       |\n\t//      x0  x  x1\n\t//      |       |\n\t//      +-------+\n    float dx = 0.5 * dFdx( uv.x );\n    float x0 = uv.x - dx;\n    float x1 = uv.x + dx;\n    float y0 = f( x0, idx );\n    float y1 = f( x1, idx );\n\n    //note: calculate distance to line-segment (x0,y0)<->(x1,y1)\n    //      +-------+\n\t//      |    /-x1\n    //      |  -x   |\n\t//     x0-/     |\n\t//      +-------+\n    float d = sd_segment( uv, vec2(x0,y0), vec2(x1,y1) );\n    return smoothstep( dFdy(uv.y), 0.0, d );\n}\n\n\nfloat eval( vec2 uv, int idx )\n{\n    //return eval_step( uv, idx );\n    return eval_dist( uv, idx );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.y;\n    int idx = int(  floor( 3.0*uv.y ) );\n    uv = vec2(uv.x, fract( uv.y*3.0) );\n    uv = vec2(8.0,3.0) * (uv - vec2(0.0, 0.5));\n    uv += vec2( 0.2 * cos(iTime), 0.2 * sin(1.1*iTime) );\n\n    float c = eval( uv, idx );\n\n    vec3 col = vec3( 0.125 + 0.65 * c );\n        \n\tfragColor = vec4( col, 1.0 );\n}\n","name":"Image","description":"","type":"image"}]}