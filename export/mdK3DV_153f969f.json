{"ver":"0.1","info":{"id":"mdK3DV","date":"1679086132","viewed":166,"name":"Sphere light approx(no clipping)","username":"Poisson","description":"Approximated sphere light attenuation function without clipping.","likes":12,"published":1,"flags":0,"usePreview":0,"tags":["3d","raytracing","raytracer","ray","attenuation","light","sphere","approximation","occlusion","analytical"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// sphere light attenuation, no clipping\n\n// ray sphere intersection function\n// thanks to iq: https://iquilezles.org/articles/intersectors/\nfloat sphIntersect(vec3 ro, vec3 rd, vec4 sph) {\n    vec3 oc = ro - sph.xyz;\n    float b = dot(oc, rd);\n    float c = dot(oc, oc) - sph.w*sph.w;\n    float h = b*b - c;\n    \n    if (h<0.) return -1.;\n    h = sqrt(h);\n    return -b - h;\n}\n\n// approximated sphere attenuation function, no clipping\n// code by me, but inspired by this article:http://www.cemyuksel.com/research/pointlightattenuation/\n// if you want exact sphere attenuation, just take 1 - sphere occlusion\nfloat sphAtten(vec3 p, vec3 n, vec4 sph) {\n    vec3 r = sph.xyz - p;\n    float l = length(r);\n    float nl = dot(n,r/l);\n    float dl = l / sqrt(l*l + sph.w*sph.w);\n    \n    return 3./4.*3.141592 * nl*(1.-dl);\n}\n\nfloat hash(float n) {return fract(sin(n)*43758.5453123);}\n\nint technique;\n\n// rendering\nvec3 render(vec3 ro, vec3 rd) {\n    vec4 sph = vec4(cos(iTime-1.), .7+.5*sin(iTime), cos(iTime+3.), .5);\n\n    vec3 col = vec3(0); // background\n        \n    float t = 1e10; // final distance\n    vec3 n; // normal\n        \n    // sphere\n    float t1 = sphIntersect(ro, rd, sph);\n    if (t1>0.) {\n        t = t1;\n        vec3 p = ro + rd*t;\n        n = (p - sph.xyz) / sph.w;\n    }\n    \n    // plane\n    float t2 = (-.5-ro.y) / rd.y;\n    if (t2>0. && t2<t) {\n        t = t2;\n        n = vec3(0,1,0);\n    }\n    \n    if (t<1e10) { // we hit the surface\n        vec3 p = ro + rd*t; // hit point\n        \n        float att = sphAtten(p, n, sph);\n        if (technique==0) { // multisampling\n            vec4 rrr = textureLod(iChannel0, gl_FragCoord.xy/iChannelResolution[0].xy, 0.);\n        \n            att = 0.;\n            const int N = 384;\n\n            for (int i=0; i<N; i++) {\n                float seed = float(i)+rrr.x*32.385;\n                float u = hash(seed+2.);\n                float v = hash(seed+45.2);\n\n                float a = 6.2831853*v;\n                float b = u*2.-1.0;\n                vec3 rr = vec3(sqrt(1.-b*b)*vec2(cos(a),sin(a)),b);\n\n                att += step(0.,sphIntersect(p, normalize(n+rr), sph));\n            }\n            att /= float(N);\n        } else { // analytical sphere attenuation\n            att = sphAtten(p, n, sph);\n        }\n        \n        if (length(p-sph.xyz)<sph.w+.001) att = 1.; // sphere\n                \n        col = 3.*vec3(.3,.6,1)*att;\n    }\n        \n    return 1.5*col/(1.+col); // tonemapping\n}\n\n// camera function\nmat3 setCamera(vec3 ro, vec3 ta) {\n    vec3 w = normalize(ta - ro);\n    vec3 u = normalize(cross(w, vec3(0,1,0)));\n    vec3 v = cross(u, w);\n    return mat3(u, v, w);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // normalized mouse coordinates\n    vec2 m = iMouse.z>0. ? iMouse.xy / iResolution.xy :\n                           vec2(.5,0);\n    // normalized pixel coordinates\n    vec2 q = fragCoord / iResolution.xy;\n    technique = q.x<m.x ? 1 : 0;\n  \n    vec2 p = (fragCoord - .5*iResolution.xy) / iResolution.y;\n\n    vec3 ro = vec3(0,1,-4); // ray origin\n    vec3 ta = vec3(0); // target\n    mat3 ca = setCamera(ro, ta); // camera matrix\n    vec3 rd = ca * normalize(vec3(p,1.5)); // ray direction\n    \n    vec3 col = render(ro, rd); // render\n    col = pow(col, vec3(.4545)); // gamma correction\n\n    // red line\n    float e = 1./iResolution.y;\n    col = mix(col, vec3(1,0,0), smoothstep(e, 0., abs(q.x-m.x)));\n\n    // vignette\n    col *= .5+.5*pow(16. * q.x*q.y*(1.-q.x)*(1.-q.y), .1);\n\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}