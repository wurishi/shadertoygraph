{"ver":"0.1","info":{"id":"mlKczw","date":"1700162633","viewed":48,"name":"MPR Trace Support Function 2D","username":"spalmer","description":"trying to understand [url]http://shadertoy.com/view/dlVyzh[/url] and [url]http://www.shadertoy.com/view/dtVyzz[/url] by converting to 2D, comparing with [url]http://shadertoy.com/view/MsjSWR[/url]","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["experiment","mpr","gjk"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// trying various experiments in 2D to understand this GJK/MPR tracing thing better\n\n// seems what I want to try to do is, find a way to \n// surf the surface normal from any point on the surface\n// back toward the query ray, refining the distance as it goes,\n// until it stops making progress.  \n// For convex objects, such a strategy should work!\n// in 2D it should be really simple since we can just decide\n// whether to proceed toward the left, or the right, depending\n// on the angle the estimate point surface normal makes with \n// the query ray direction.\n\n// all the lateral shifting business seems like kind of a red herring,\n// all it does is counter-shift the object center.\n// not sure what any of that has to do with surface normals, yet.\n// obtaining good distances seems reliant on finding precise surface normals.\n// idk if outer corner distances would ever truly work on sharp featured objects like true boxes.\n// maybe it doesn't matter.  But I want to estimate distance to hit... \n// so long as I can find an intersecting point on the surface, I can just measure distance.\n\n#define IZERO min(0, iFrame)\n\nstruct Circle { vec2 c; float h; }; // center, halfdiameter = radius\n\nstruct Box { vec2 c; vec2 h; float r; }; // center, halfextent, rotation radians\n// a 2D superprim that can be most any shape\nstruct RoundBox { vec2 c; vec2 h; float r; float poof; }; // center, halfextent, rotation radians, poof radius\n\nmat2 spin(float r)\n{\n    return mat2(cos(vec4(0,1,-1,0) * acos(0.) + r));\n}\n\nvec2 supMax(vec2 d, vec2 a, vec2 b)\n{\n    return dot(d,a) > dot(d,b) ? a : b;\n}\n\n#if 0 \n// did not get this working well (YET!)\n// was trying scalar support functions\n// got lost trying to gain perspective\n// TODO I intend to come back to this part!\nfloat support(Circle s, vec2 q)\n{\n    return -dot(q, s.c) - s.h;\n}\n\nfloat support(Box s, vec2 q)\n{\n    // rotate q and s.c by s.r\n    mat2 m = spin(s.r);\n    q = m * q; //q *= m; //\n    s.c = m * s.c; //s.c *= m; //\n    vec2 g = -q * s.c;\n    g = abs(g);\n    float f = max(g.x, g.y); //-dot(q, s.c); //\n    return f - dot(q, sign(q) * s.h);\n}\n// TODO roundbox\n\nfloat overlap(vec2 p)\n{\n    vec2 r = iResolution.xy, d0 = vec2(0,1), d1 = -d0, d2 = d0.yx, d3 = -d2;\n    float t0, t1;\n    \n    Circle s0 = Circle(r * vec2(.25,.5) - p, r.y * .2);\n    t0 = support(s0, d0);\n    t1 = support(s0, d1);\n    if (t0 < 0. && t1 < 0.) {\n        t0 = support(s0, d2);\n        t1 = support(s0, d3);\n        if (t0 < 0. && t1 < 0.) {\n            t0 = support(s0, -normalize(s0.c));\n            if (t0 < 0.)\n                return 1.;\n        }\n    }\n    \n    Box s1 = Box(r * vec2(.75,.6) - p, r * vec2(.2, .1), iTime * .1);\n    t0 = support(s1, d0);\n    t1 = support(s1, d1);\n    if (t0 < 0. && t1 < 0.) {\n        t0 = support(s1, d2);\n        t1 = support(s1, d3);\n        if (t0 < 0. && t1 < 0.) {\n            t0 = support(s1, -normalize(s1.c));\n            if (t0 < 0.)\n                return 1.;\n        }\n    }\n    \n    return 0.;\n}\n\nvoid mainImage(out vec4 o, vec2 v)\n{\n    o = vec4(1);\n    o = vec4(overlap(v));\n}\n\n// so far I have it detecting the 'shadow' of the shape, sort of its bounds;\n// rotation isn't working, can't see any slope on the near surface yet.\n// the circle is hacked enough to kind of work, at least.\n\n#elif 1\n\n// trying kastorp's way, perhaps in 2D I can understand it\n// hard to convert to 2D without breaking it,\n// must convert the \"2D MPR\" it uses internally to a kind of \"1D MPR\" :)\n\n// hey I got it working, ... had to do hacks.\n// it's still basically hard-coded for 'up' direction +Y\n\nvec2 lsupport(RoundBox s, vec2 q)\n{\n    mat2 m = spin(s.r);\n    return m * (sign(q * m) * max(s.h - s.poof, 0.)) + s.c + q * s.poof;\n}\n// unnormalized!! refactored 3x copies\nvec2 segnormal(vec2 a, vec2 b)\n{\n    return (b - a).yx * vec2(-1, 1);\n}\n\nbool check(vec2 p, vec2 v) \n{\n    return p.x < 0. && v.x < 0.;\n}\n\nbool nastyhacks = false;\n\n// no need to deal with reorienting shape to match ray because here, ray always points straight up anyway.\nbool rayVsSupport(vec2 p, vec2 d, RoundBox o, out vec2 normal, out float depth, inout float debug)\n{\n    depth = 3.4e38; // miss\n    vec2 s[2]; // a simplex\n    s[0] = lsupport(o, vec2( 1, 0)) - p;\n    s[1] = lsupport(o, vec2(-1, 0)) - p;\n    if (s[0].x * s[1].x > 0.)\n        return false; // shape doesn't overlap on x at all\n    // that should give us the widest portal ever!\n    vec2 v;\n    if (s[0].x < s[1].x) { vec2 tmp = s[0]; s[0] = s[1]; s[1] = tmp; } // swap\n    // we know s[0] is on the right and s[1] is on the left, both on the lower side of the object (facing the ray origin)\n    // zero is bracketed by s[1].x and s[0].x\n    \n    const float tolerance = 1e-6;\n    // needs lots of refinement\n    // essentially a simplicial binary search, angular? in 1D\n    for (int i = IZERO + 7; i-- > 0; ) {\n        v = normalize(segnormal(s[0], s[1])); // compute estimated normal vector of tri (splits angle)\n        vec2 sd = lsupport(o, v) - p;\n        if (dot(v, sd) - dot(v, s[0]) < tolerance)\n            break;\n        // tighten bracket\n        if (sd.x < 0.) { if (sd.x > s[1].x) s[1] = sd; }\n        else { if (sd.x < s[0].x) s[0] = sd; } // trying to get closer to zero than we were\n\t}\n    \n    v = normalize(segnormal(s[0], s[1])); // final normal\n    depth = dot(s[0], v) / dot(d, v);\n    normal = v;\n    if (depth > 0.) return false;\n    return true; // query p was inside shape\n}\n\n// in 3d there was this rmi business handling mapping onto the ray axis.\n     //vec2 ord = rmi[2], oc = o.c, v;   \n    // whatever happened to ord to make it become +Y, do same thing to o.c - oro?\n    // basically, also transforms o.c to be relative to ray\n    //o.c = cross(cross(ord, oro - oc), ord);\n    //shape.c = p - dot(p, o.c);\n   //if (s[0].x <= 0.)\n    //    return false;\n    //debug = min(debug, distance(/*s[0] +*/ p, abs(iMouse.xy))); // TODO some debugging points, would need to run the algo 2x probably for it to make sense\n    //depth = (s[0].y + s[1].y) * .5 - p.y;\n    //return true; // HACK\n    //v = vec2((s[1] - s[0]).yx * vec2(-1,1));\n    //if (dot(v, s[0]) >= 0.) {\n    //    v = -v;\n    //    vec2 tmp = s[0]; s[0] = s[1]; s[1] = tmp; // swap\n    //}\n     //if (segnormal(s[0], s[1]).y > 0.) discard; //return false; // ok at least I have it pointing back down at the ray origin\n    //s[2] = lsupport(o, v);\n    //if (dot(s[2].xy, v.xy) <= 0.)\n    //    return false;\n    /*\n    // refines silhouettes; ensure we find a portal\n    for (int i = IZERO + 4; ; ) {\n        else if (dot(v = segnormal(s[0], s[1]), s[1]) < 0.)\n        { s[0] = s[1]; }\n        else break; // query in angle -> intersection!\n        \n        s[1] = lsupport(o, v) - p;    \n        if (dot(s[1], v) <= 0. || --i == 0)\n            return false;\n    }\n    */\n        //if (sd.y + p.y - o.c.y > 0.) nastyhacks = true; // FIXME should not be finding points on far side of shape\n        /*\n        // xd = query left of xd line (perp dots = cross2d)\n        bool ad = check(sd.xy, s[0].xy),\n             bd = check(sd.xy, s[1].xy);\t\t\n        // Choose triangle that intersects y-axis furthest in y direction\n             if ( bd) { s[0] = sd; }\n        else if (!ad) { s[1] = sd; }\n        else break; //discard; // Should not happen\n        */\n    //if (dot(s[0], v) < 0.) depth = -depth; //(s[0].y+s[1].y)*.5 - p.y;\n    //depth = dot(o.c - p, d) - s[0].y - dot(s[0], v) / -v.y;\n    //depth = dot(s[0], v); //length((s[0]+s[1])*.5); // unreliable estimate HACK\n\nvec2 pixel; // more HACK for debug ray\n\nfloat dist(inout vec4 o, vec2 p, vec2 d, inout float debug, bool inverthack)\n{\n    vec2 r = iResolution.xy;\n    float t = r.x;\n    \n    float inv = inverthack ? -1. : 1.;\n    \n    RoundBox s2 = RoundBox(r * vec2(.5, .5) + vec2(0, 0) * inv, r * vec2(.2, .15), \n                            iTime * .1 * inv, r.y * .1);\n\n    vec2 n;\n    bool hit = rayVsSupport(p, d, s2, n, t, debug);\n    if (iMouse.z >= 0. && /*hit && */!inverthack && abs(p.x - abs(iMouse.x)) < 1.5 && t > abs(iMouse.y) && pixel.y < t)\n        nastyhacks = true;\n    return t;\n}\n    //if (hit) nastyhacks = true;\n    //if (!hit) t = 3.4e38; // we don't care if p was inside, do we?\n\n// shoot rays out the bottom of screen, see where they hit the 2D scene (the lower side of it anyway)\n// TODO then shoot them from the top too!  ;)  maybe sides\nvoid mainImage(out vec4 o, vec2 v)\n{\n    o = vec4(1);\n    pixel = v; // debug hacks\n    vec2 r = iResolution.xy;\n    float debug = 3.4e38;\n    float l = dist(o, vec2(v.x, 0), vec2(0, 1), debug, false);\n    bool hit = l <= r.y;\n    float l2 = dist(o, vec2(v.x, 0), vec2(0, 1), debug, true);\n    // think this antialiases the top and bottom;\n    // nothing I can do about the sides with the hack top&bottom only scan I do here\n    float t = max(v.y - (r.y - l2), l - v.y) + 0.;\n    o.rgb *= mix(clamp(t, 0., 1.), 1., .1);\n    if (nastyhacks) o.g *= .1;\n    o = sqrt(o);\n}\n    //o.g *= mix(clamp(debug + 1., 0., 1.), 1., .1);\n    //if (v.y >= l) //if (hit) //\n    //    o.rgb *= 0.1;\n    //float l2 = dist(o, vec2(v.x, r.y-1.), vec2(0, -1), debug, false); // oh yeah we can't trace any direction but 'up'\n    //if (r.y - v.y >= l2) //if (hit) //\n    //    o.rgb *= 0.1;\n    //if (v.y <= r.y - l2 && v.y >= l) //if (hit) //\n        //o.rgb *= 0.1;\n\n    //Circle s0 = Circle(r * vec2(.25,.5) - p, r.y * .2);\n    //t = min(t, rayVsSupport(d, s0));\n    \n    //Box s1 = Box(r * vec2(.75,.6) - p, r * vec2(.2, .1), iTime * .1);\n    //t = min(t, rayVsSupport(d, s1));\n/*\n    \n// local support\nvec2 lsupport(Circle s, vec2 q)\n{\n    return normalize(q) * s.h;\n}\n\nvec2 lsupport(Box s, vec2 q)\n{\n    return sign(q) * s.h;\n}\n// similar but handles rotation and the center offset\nvec2 rsupport(Circle s, vec2 q) \n{\n    s.c = s.c - q * dot(q, s.c); //cross2(cross2(q,s.c),q) // cross way makes no sense in 2d\n    return lsupport(s, q) + s.c;\n}\n\nvec2 rsupport(Box s, vec2 q)\n{ \n    s.c = s.c - q * dot(q, s.c);\n    mat2 r = spin(s.r);\n    vec2 b = lsupport(s, r * q);   \n    return (b + r * s.c) * r;\n}\n*/ /*\n// here ro is always the origin vec2(0,0), s.c is relative the origin\n// and we can assume (for now) that d = vec2(0,1)\nfloat rayVsSupport(vec2 d, Circle s)\n{\n    vec2 t = rsupport(s, d);\n    float x = dot(s.c, d) - _; // _ is supposed to be some scalar, distance of some sort\n    vec2 n; // idk where to get n yet; for me it'll be the perp of some 2d segment\n    return t.y + t.x*n.x / n.y; // kastorp perspective correction hack\n}\n//    depth = _s.a.z + dot(_s.a.xy, normal.xy) / normal.z; // kastorp hack to correct for perspective\n\nfloat rayVsSupport(vec2 d, Box s)\n{\n    vec2 t = rsupport(s, d);\n    return dot(s.c, d) - t;\n}\n*///float rayVsSupport(vec2 d, RoundBox s)\n//{\n//    vec2 t = lsupport(s, d);\n//    return dot(s.c, d) + dot(t, d);\n//}\n\n// TODO try shoot rays out bottom of screen, see where they hit 2D scene (lower side of it anyway)\n// TODO then shoot them from the top too!  ;)  maybe sides\n\n#else\n\n// working 2D MPR based on demofox http://shadertoy.com/view/MsjSWR\n\nvec2 bcenter;\nvec2 bextent;\nfloat bpoof;\n\nvec2 lsupport(RoundBox s, vec2 q)\n{\n    mat2 m = spin(s.r);\n    return m * (sign(q * m) * max(s.h - s.poof, 0.)) + s.c + q * s.poof;\n}\n\n// think we must only use one convex support fn at a time, in any MPR loop,\n// so FIXME should run one MPR loop per object, not do them all at once\n//vec2 center;\n//float cradius;\n// local support\n//vec2 lsupport(Circle s, vec2 q)\n//{\n//    return normalize(q) * s.h + s.c;\n//}\n\n//vec2 lsupport(Box s, vec2 q)\n//{\n//    mat2 m = spin(s.r);\n//    return m * (sign(q * m) * s.h) + s.c;\n//}\n    //vec2 r = iResolution.xy;\n    //Circle s0 = Circle(center, cradius); // p subtracted elsewhere\n    //vec2 t0 = lsupport(s0, q);\n    //debugpointdist = min(debugpointdist, distance(t0, pixel));\n  //t0 - p; //supMax(q, t0, t1) - p;\n    //center = r * vec2(.25, .5); // circle pos\n    //cradius = r.y * .2;\n\nfloat debugpointdist;\nvec2 pixel; // for debugging only\n\nvec2 Support(vec2 q, vec2 p)\n{\n    q = normalize(q); // sanity check\n   \n    RoundBox s1 = RoundBox(bcenter, bextent, iTime * .1, bpoof);\n    vec2 t1 = lsupport(s1, q);\n    debugpointdist = min(debugpointdist, distance(t1, pixel));\n    return t1 - p;\n}\n// since it subtracts p, everything returned by Support is \"relative to the origin\" with p at the origin\n\n// perpdot, cross2\nbool LineSide(vec2 a, vec2 b, vec2 q)\n{\n    b -= a; q -= a;\n\treturn 0. < b.x * q.y - b.y * q.x;\n}\n\nvec2 PointInside(vec2 p)\n{\n    const float rh = sqrt(.5);\n    return .25 * (\n        Support(vec2(-1,-1) * rh, p) +\n        Support(vec2(-1, 1) * rh, p) +\n        Support(vec2( 1,-1) * rh, p) +\n        Support(vec2( 1, 1) * rh, p));\n}\n    //return vec2(-.04) + bcenter - p;\n\n// apparently p is to be considered the 'origin' internally to this function\nfloat MPR(in vec2 p, out bool containsP, out vec2 finalPortalNormal)\n{\n    containsP = false;\n    // portal discovery\n    \n    // obtain a point that we know lies somewhere deep within B-A (or at least B)\n    vec2 pointInside = PointInside(p);\n    debugpointdist = min(debugpointdist, distance(pointInside + p, pixel) - 2.);\n    \n    // get support point in direction to origin.\n    vec2 toP = dot(pointInside, pointInside) < 1e-6 \n        ? vec2(1,0)\n        : normalize( - pointInside);\n    vec2 s0 = Support(toP, p);\n    \n    // a support point in perpendicular direction.  Since there are two possibilities,\n    // take point towards origin instead of away (dot product > 0)\n    vec2 sA = normalize(s0 - pointInside);\n   \n    bool lineSideA = LineSide(pointInside, vec2(0), s0);\n    if (lineSideA)\n        sA = vec2( sA.y,-sA.x);\n    else\n        sA = vec2(-sA.y, sA.x);\n     // HACK judging from the debug output, the perpendicular isn't the greatest heuristic here\n    sA = (sA + normalize(s0 - pointInside)) * sqrt(.5); // my modification; choose 45 degrees instead of 90\n    //sA = sA * .5 + normalize(s0 - pointInside) * sqrt(.75); // my modification; choose 30 degrees instead of 90\n    vec2 s1 = Support(sA, p);\n    bool lineSideB = LineSide(pointInside, vec2(0), s1);\n    \n    // above may not have found a valid portal, so go through some portal discovery\n    // in case it didn't.\n    for (int i = 4 + IZERO; i-- > 0; ) {\n        // remember how many discovery loops we've done\n        //loopCountDiscovery = i + 1;        \n        \n        // we are done when A and B are on different sides of the origin, relative\n        // to our inside point.\n    \tif (lineSideA != lineSideB)\n            break;\n        \n        // find a new support point that is perpendicular to direction to supportB\n        s0 = s1;\n        vec2 s2 = normalize(s1 - pointInside);\n        if (lineSideA)\n        \ts2 = vec2( s2.y,-s2.x);\n        else\n            s2 = vec2(-s2.y, s2.x);\n        s1 = Support(s2, p);\n        lineSideB = LineSide(pointInside, vec2(0), s1);\n    }\n    \n    // if failed to find a valid portal in number of loops alotted, exit\n    if (lineSideA == lineSideB)\n        return 9e9;\n    \n    // have 3 points that form an angle & know p lies in this angle.\n    vec2 n;\n    // portal refinement, hella slow compile times without IZERO\n    for (int i = 8 + IZERO; i-- > 0; ) {\n\n        // get a normal to the portal and get a support point along that normal.\n        // make sure the normal is pointing away from the pointinside\n        vec2 portal = s1 - s0;\n\t\tn = normalize(vec2(portal.y, -portal.x));\n        if (dot(n, s0 - pointInside) < 0.)\n            n = -n;        \n        vec2 s2 = Support(n, p);\n        \n        // if the origin is on the outside of this 2d plane, we have a miss\n        if (dot(n, s2) < dot(n, vec2(0)))\n            return 9e9;\n        \n        // if our new support point is the same as one of our old support points, bail out.\n        if (length(s0 - s2) < .001 || length(s1 - s2) < .001)\n            break;\n        \n        // the line from the center to the new support point bisects our angle.\n        // We need to see which side the origin is in, and make that be our new angle\n        // for the next iteration.\n        if (LineSide(pointInside, s2, s1) ==\n            LineSide(pointInside, s2, vec2(0))) {\n\t\t\t//angle containing origin is made from the points:\n            //s2, s1 from pointInside\n            s0 = s2;\n\t\t} else {\n\t\t\t//angle containing origin is made from the points:\n            //s2, s0 from pointInside\n            s1 = s2;\n        }  \n    }\n    \n    // success!  either max loops, or quit early due to lack of progress.\n\n    // Calculate penetration distance of query into shape.\n\tvec2 portal = s1 - s0;\n    n = normalize(vec2(portal.y, -portal.x));\n    if (dot(n, s0 - pointInside) < 0.)\n        n = -n;        \n    \n    containsP = true;\n    finalPortalNormal = n;\n    return dot(n, s0); // distance, -depth\n}\n\nvoid mainImage(out vec4 o, vec2 v)\n{\n    o = vec4(1);\n    pixel = v;\n    vec2 r = iResolution.xy;    \n    bcenter = r * vec2(.6,.5);\n    bextent = r.y * vec2(.45, .15);\n    bpoof = bextent.y * .75; //r.y * .1;\n    vec2 n;\n    bool hit;\n    float l = MPR(v, hit, n);\n    float shade = clamp(1. - .5 * l, 0., 1.);\n    if (hit) // antialiasing really does help but can only obtain normal if there was a 'hit'\n        o.rgb *= mix(shade, 1., .1);\n    debugpointdist = 9e9;\n    vec2 Q = r * vec2(.9,.51); // debug Query pos\n    if (iMouse.z >= 0.) Q = abs(iMouse.xy);\n    bool hitb;\n    float x = MPR(Q, hitb, n);\n    o.g *= clamp(debugpointdist - 1.5, 0., 1.); //1. - debugpointdist; // - 3.;\n    if (length(v - Q) < 5.) o *= vec4(.9, .6, .1, 1);\n    o = sqrt(o);\n}\n// MPR in 2D based on demofox; not a 'raycast' but is the algo used internally to the 3d raycasting variant,\n// good for showing what's going on in that process.\n#endif\n","name":"Image","description":"","type":"image"}]}