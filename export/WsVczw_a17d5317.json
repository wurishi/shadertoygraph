{"ver":"0.1","info":{"id":"WsVczw","date":"1602490552","viewed":91,"name":"Psuedoinverse point in triangle","username":"copperbotte","description":"Simple point-in-triangle test. Probably more complex than it needs to be.\n\nBased on a post from blackpawn:\nhttps://blackpawn.com/texts/pointinpoly/","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["simple","math","triangle"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n//point in tri\n//projects point onto a plane defined by tri,\n//then reprojects it onto a new coordinate system defined by said triangle as bases.\n//if the point lies within a right triangle of lengths 1,1, its in the triangle.\n//this is equivelant to the barycentric technique.\n//\n//based on this post from blackpawn, re-derived to find underlying psuedoinverse.\n//https://blackpawn.com/texts/pointinpoly/\n\nbool inTri(in vec3 point, in mat3 tri)\n{\n    //move space toward first vertex\n    //maybe use a mul?\n    point -= tri[0];\n    tri -= mat3(tri[0],tri[0],tri[0]);\n    //v1 -= v0;\n    //v2 -= v0;\n    //vt -= v0;\n    \n    //using v1 and v2 as a basis, find a vector normal to both to build a plane\n    vec3 norm = normalize(cross(tri[1], tri[2]));\n    \n    //find the projection of vt onto the normal\n    float proj = dot(point, norm);\n    \n    //if(proj * proj < 0.01) // point is not on plane of triangle\n    //    return false;\n    \n    //move point onto plane of triangle\n    point -= norm * proj;\n    \n    //v1 and v2 form a basis space, whose linear combination is vt. vt = a*v1 + b*v2.\n    //Since vt is guaranteed to be on the plane between the two, its psuedoinverse is its inverse.\n    //moore-penrose psuedoinverse: (MT*M)^-1 * MT = M+\n    \n    mat2x3 space = mat2x3(tri[1], tri[2]); // can this be truncated from tri?\n    mat3x2 st = transpose(space);\n    mat2x2 inv = st * space;\n    \n    //if the inverse's inputs has no determinant, it covers no area, and has no inverse.\n    if(determinant(inv) == 0.0)\n        return false;\n    \n    mat3x2 mpi = inverse(inv) * st;\n    vec2 mpipt = mpi * point; // move into basis space\n    \n    //if the point does not lie within the unit triangle, it misses.\n    if(mpipt.x < 0.0)\n        return false;\n    if(mpipt.y < 0.0)\n        return false;\n    if(1.0 < dot(mpipt, vec2(1,1)))\n       return false;\n    return true;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec2 xy = uv * 2.0 - 1.0;\n    xy.y *= iResolution.y / iResolution.x;\n    \n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos((iTime+uv.xyx+vec3(0,2,4))*1.0);\n\n    vec3 vb[3] = vec3[3](\n    \tvec3(-0.5,-0.5,0.0),\n        vec3(0.5,-0.5,0.0),\n        vec3(0.0,0.5,0.0)\n    );\n    \n    if(inTri(vec3(xy,0.0), mat3(vb[0], vb[1], vb[2])))\n       col = vec3(1,1,1);\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}