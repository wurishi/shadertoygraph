{"ver":"0.1","info":{"id":"4f3BRl","date":"1733356218","viewed":55,"name":"Broken refraction attempt","username":"akr51","description":"Anyone know how to do refraction properly? This is a hack and looks bad at some angles. ","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["refraction"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Number of scene \"objects\"\n#define NSO 3\n// Iterations\n#define ITR 120\n// Max ray travel distance\n#define DST 90.0\n// Collision with surface  \n#define SRF 0.0001\n// Epsilon for normal\n#define EPS vec2(0.0001, -0.0001)\n// 2D rotation which can be used in 3D by rotating\n// about plane. E.G xy is about z axis.\n#define RT(X) mat2(cos(X), -sin(X), sin(X), cos(X))\n\nfloat box(vec3 sp, vec3 d)\n{\n\n\n    sp = abs(sp) - d;\n    return max(max(sp.y, sp.x), sp.z);\n\n\n}\n\n\nvec2 map(vec3 sp)\n{\n\n    float dst[NSO];\n    float id = 0.0;\n    \n    dst[0] = sp.y + 1.0;\n    \n    \n    vec3 spw = sp;\n    for (int i = 0; i < 4; i++) {\n        \n        sp = abs(sp) - vec3(2, 2.68, 0);\n        sp.xy *= RT(2.94);\n    \n    }\n    dst[1] = box(sp, vec3(1, 2, 1));\n    \n    spw.y -= 3.0;\n    spw.z += 4.0;\n    spw.xy *= RT(iTime);\n    spw.zy *= RT(iTime * 0.5);\n    dst[2] = box(spw, vec3(1.5));\n    \n    for (int i = 1; i < NSO; i++)\n    {\n    \n        if (dst[i] < dst[0])\n        {\n        \n            dst[0] = dst[i];\n            id = float(i);\n            \n        }\n    \n    }\n    \n    return vec2(dst[0] * 0.7, id);\n}\n\n\nvec2 mrch(vec3 ro, vec3 rd, float s)\n{\n\n    float d0 = 0.0;\n    float id = 0.0;\n    for (int i = 0; i < ITR; i++)\n    {\n        \n        vec3 sp = ro + rd * d0;\n        vec2 ds = map(sp) * s;\n        if (d0 > DST || abs(ds.x) < SRF) break;\n        d0 += ds.x;\n        id = ds.y;\n\n\n    }\n    \n    if (d0 > DST) d0 = 0.0;\n    return vec2(d0, id);\n}\n\n\nvec3 nml(vec3 sp)\n{\n\n    return normalize(EPS.xyy * map(sp + EPS.xyy).x +\n                     EPS.yyx * map(sp + EPS.yyx).x +\n                     EPS.yxy * map(sp + EPS.yxy).x +\n                     EPS.xxx * map(sp + EPS.xxx).x);\n\n}\n\n\nvoid mainImage(out vec4 c_out, in vec2 uu)\n{\n    vec2 rr = iResolution.xy;\n    vec2 uv = (uu + uu - rr) / rr.y;\n    \n    float f = length(uv);\n    vec3 clr = (1.0 - vec3(f * 0.5, f * 0.25, f * 0.125)) * 0.001;\n    vec3 bgc = clr;\n    // camera\n    vec3 ro = vec3(sin(3.44) * 7.0, 5.5, cos(3.44) * 7.0);\n    vec3 w = normalize(vec3(0) - ro);\n    vec3 u = normalize(cross(w, vec3(0, 1, 0)));\n    vec3 v = normalize(cross(u, w));\n    vec3 rd = normalize(mat3(u, v, w) * vec3(uv, 1.0));\n    // light position\n    vec3 lp = vec3(0, 6.2, -8.0);\n    // color of scene objects\n    vec3 clrs[NSO] = vec3[NSO](\n        vec3(0.01, 0.005, 0.09) * 1.9,\n        vec3(abs(sin(iTime)) * 4.0, abs(cos(iTime + uv.x)), 0.0),\n        vec3(1.0)\n    );\n   \n    // march scene\n    vec2 sc = mrch(ro, rd, 1.0);\n    // distance to scene object\n    float d = sc.x;\n    // scene object id\n    int id = int(sc.y);\n    // if hit scene object\n    if (d > 0.0)\n    {\n        // hit object color\n        vec3 amb = clrs[id];\n        // point in 3-space (3D) where surface collision occurs\n        vec3 sp = ro + rd * d;\n        // surface normal - used in lighting calculations\n        vec3 n = nml(sp);\n        \n        // direction of light (must be normalized)\n        vec3 ld = normalize(lp - sp);\n        \n        // refraction\n        if (id == 2) {\n        \n        \n        \n            float ior = 1.5;\n            vec3 ri = refract(rd, n, 1.0 / ior);\n            vec3 pe = sp - n * SRF * 3.0;\n            float di = mrch(pe, ri, -1.0).x;\n            vec3 xp = pe + ri * di;\n            vec3 xn = nml(xp);\n            vec3 re = refract(ri, xn, ior);\n            \n            if (length(re) == 0.0) {\n            \n                re = reflect(ri, xn);\n            \n            }\n            \n            // This is a stupid AF hack\n            vec2 rsc = mrch(xp + 0.9, re, 1.0);\n            // pretty sure this is incorrect\n            sp = xp + re * d;\n            id = int(rsc.y);\n            // And so is this\n            if (id == 2) id = 0;\n            amb = clrs[id];\n            n = nml(sp);\n            \n            \n        \n        }\n        \n  \n        // ambient occlusion NuSan\n        float ao = clamp(map(sp + n * 0.5).x / 0.5, 0.0, 1.0);\n\n        // diffuse\n        float df = max(0.0, dot(n, ld));\n        // specular\n        float spc = pow(max(dot(reflect(-ld, n), -rd), 0.0), 100.0);\n        clr = amb * ao * df + spc;\n        clr = mix(clr, bgc, 1.0 - exp(-0.0001 * pow(d, 3.0)));\n        \n    \n    }\n    \n    c_out = vec4(pow(clr, vec3(0.45)), 1.0);\n}","name":"Image","description":"","type":"image"}]}