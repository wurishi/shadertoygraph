{"ver":"0.1","info":{"id":"43lBzS","date":"1728713804","viewed":82,"name":"Wave guide phased array","username":"Fuergu","description":"I'm not sure how to remove the reflection of the screen boundary, which seems to be unavoidable with this simulation method","likes":6,"published":1,"flags":32,"usePreview":0,"tags":["2d","wave","simulation","optics","waveguide","phasedarray"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/******************************************************************************/\n//     It should be possible in theory, but the practical effect is not obvious. \n//     It can also be seen that the wave propagation is very sensitive to the tiny \n// structure of the waveguide, and the sawtooth caused by insufficient resolution \n// may significantly affect the accuracy of the wave separation. \n//     So, I recommend doing this full-screen.In bigger resolution, you may\n// also need to turn \"dt\" bigger in Common.\n\n//    Also, I'm not sure how to remove the reflection of the screen boundary, \n// which seems to be unavoidable with this simulation method\n/******************************************************************************/\n//                    Go To Common for Controls\n/******************************************************************************/\n\n\nfloat boundaries(vec2 p,vec2 uv) {\n        // 定义显示区域的边界\n        float left = 0.;\n        float right = Xsize;\n        //Ysize = 1.-Ysize;\n        float top = 1.-Ysize/2.;\n        float bottom = Ysize/2.;\n        // 检查当前 UV 是否在指定区域内\n        if (uv.x >= left && uv.x <= right && uv.y >= bottom && uv.y <= top) {\n            // 计算在 iChannel0 中的纹理坐标\n            vec2 texCoord = (uv - vec2(left, bottom)) / vec2(right - left, top - bottom);\n            vec4 boundaryColor = texture(iChannel1, texCoord);\n            if (boundaryColor.r>.1){\n                return 1.0;\n            }else{return 0.0;}\n        }\n        if (uv.x >= right && uv.x <= right+outPutLength) {\n        // 取 right - 1 列的颜色\n        vec2 texCoord = vec2(right+1., (uv.y - bottom) / (top - bottom));\n        vec4 boundaryColor = texture(iChannel1, texCoord);\n        return boundaryColor.r > .1 ? 1.0 : 0.0;  // 应用相同颜色\n        }\n        if((uv.y<=bottom || uv.y>=top)&& uv.x<right) return 1.;\n        return 0.0;\n}\n\n\nconst vec3 wallColor = vec3(0.000,0.024,0.341);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 p = fragCoord / iResolution.y;\n\n    vec4 tex = texture(iChannel0, uv);\n    float field = (tex.x/AMP+1.)*.5; // map (-1, 1) range into (0, 1)\n\t//vec3 col = mix(vec3(field), wallColor, boundaries(p,uv));\n    field = .9*(field+0.05);\n    vec3 a = vec3(0.660, 0.560, 0.680);\n    vec3 b = vec3(0.718, 0.438, 0.720);\n    vec3 c = vec3(0.520, 0.800, 0.520);\n    vec3 d = vec3(-0.430, -0.397, -0.083);\n    vec3 col = palette(clamp(field,0.,1.), a, b, c, d);\n    col = pow(col,vec3(4.));\n    col = mix(col, wallColor, boundaries(p,uv));\n    \n    //pased array area\n    float d1 = sdBox(uv-vec2(Xsize+outPutLength/2.,.5), vec2(0.02,(1.-Ysize)/.6*.31)); // 计算距离场\n    float d2 = sdBox(uv-vec2(Xsize+outPutLength/2.,.5), vec2(0.03,(1.-Ysize)/.6*.32)); // 计算距离场\n    float box = max(-d1,d2);\n    if(box<.001)col.g+=2.;\n    \n    \n    fragColor = vec4(col, 1.0);    \n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"float boundaries(vec2 p,vec2 uv) {\n        float left = 0.;\n        float right = Xsize;\n        float top = 1.-Ysize/2.;\n        float bottom = Ysize/2.;\n        if (uv.x >= left && uv.x <= right && uv.y >= bottom && uv.y <= top) {\n            vec2 texCoord = (uv - vec2(left, bottom)) / vec2(right - left, top - bottom);\n            vec4 boundaryColor = texture(iChannel1, texCoord);\n            if (boundaryColor.r>.1){\n                return 1.0;\n            }else{return 0.0;}\n        }\n        if (uv.x >= right && uv.x <= right+outPutLength) {\n        vec2 texCoord = vec2(right+1., (uv.y - bottom) / (top - bottom));\n        vec4 boundaryColor = texture(iChannel1, texCoord);\n        return boundaryColor.r > .1 ? 1.0 : 0.0;  \n        }\n        if((uv.y<=bottom || uv.y>=top)&& uv.x<right) return 1.;\n        return 0.0;\n}\n\n// Fork of \"2D Wave Equation Simulation\" by vug. https://shadertoy.com/view/3d3yzj\n// 2024-10-10 08:59:44\n\n// nine-point compact stencil of Laplacian operator\nconst float[9] stencil = float[](\n  .05, .20, .05,\n  .20, -1., .20,\n  .05, .20, .05\n);\n\n// relative coordinates of 9x9 grid points\nconst vec2[9] grid = vec2[9](\n    vec2(-1.0,  1.0), vec2(0.0,  1.0), vec2(1.0,  1.0),\n    vec2(-1.0,  0.0), vec2(0.0,  0.0), vec2(1.0,  0.0),\n    vec2(-1.0, -1.0), vec2(0.0, -1.0), vec2(1.0, -1.0)\n);\n\nvec4 sample1(sampler2D channel, vec2 uv) {\n    // Boundary conditions for walls inside.\n    // ellipse in the middle\n    vec2 p = uv * vec2(1. * iResolution.x / iResolution.y, 1.0);\n    return mix(texture(channel, uv), vec4(0.0, 0.0, 0.0, 1.), boundaries(p,uv));\n}\n\n// values of a field stored in a texture on the grid\nfloat[9] getField(sampler2D channel, vec2 uv) {\n\tvec2 px = 1.0 / iResolution.xy;\n    float[9] field;\n    for (int i = 0; i < 9; i++) {\n        vec2 r = uv + px * grid[i];\n        field[i] = sample1(channel, r).x;\n    }\n    return field;\n}\n\n// Laplacian of a field\nfloat laplacian(float[9] samples) {\n    float sum = 0.0;\n    for (int i=0; i<9; i++) {\n        sum += stencil[i] * samples[i];\n    }\n    return sum;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 p = fragCoord / iResolution.y;\n    vec3 col = vec3(0.0);\n    \n    // initial conditions\n    if (iFrame == 0) {       \n        fragColor = vec4(col, 1.0);\n        return;\n    }\n\n    // Red channel stores current field values\n    // Green channel stores previous field values (in time)\n    vec2 tex = sample1(iChannel0, uv).rg;\n    float u = tex.r;\n    float u1 = tex.g;       \n   \n    float[9] field = getField(iChannel0, uv);\n\n    // Determine the speed of wave propagation based on the region\n    float delay = 0.; // Default speed\n    if (uv.x >= Xsize && uv.x <= Xsize+outPutLength) {\n    // add linear delay to C(light speed)\n        delay = clamp(map(uv.y,.5-(Ysize/2.),.5+(Ysize/2.)+.1,0.,.8),0.,.8); \n    }\n    float speed = C-delay;\n    \n    // Wave motion calculation with modified speed\n    float val = 0.;\n    //if(fragCoord.x<2.||fragCoord.x>iResolution.x-2.||fragCoord.y<2.||fragCoord.y>iResolution.y-2.)\n    //{speed*=0.;}\n    \n    val = 2.0 * u - u1 + speed * dt * laplacian(field); // Include speed in the calculation\n    val *= DAMP;\n\n    // Calculate distance from mouse\n    vec2 mousePos = iMouse.xy / iResolution.xy;\n    mousePos = vec2(0.,.5);\n    float halfSize = 0.03; // Half the size of the square\n\n    // Check if inside the square\n    bool isInSquare = (abs(p.x - mousePos.x) <= halfSize) && (abs(p.y - mousePos.y) <= halfSize);\n    \n    // Source condition\n    if (isInSquare) {\n        float t = float(iFrame*SIMspeed);\n        val = AMP * sin(FREQUENCY * t);\n    }\n    //if(fragCoord.x<2.||fragCoord.x>iResolution.x-2.)val*=0.;\n    fragColor = vec4(val, u, laplacian(field), 1.0);\n    //if(fragCoord.x<2.||fragCoord.x>iResolution.x-2.)fragColor.rgba*=0.;\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"// Wave simulation settings\nfloat C = 1.; // wave speed <= 2\nfloat dt= 2.;\n\nfloat FREQUENCY = 0.2; // emission frequency\nfloat DAMP = 1.; // 1.0 for infinite waves\nfloat AMP = 2.;\nint SIMspeed = 2;\n\n// Wave guide size\nfloat Ysize = .4;\nfloat Xsize = .4;\n\n// Phase delay area\nfloat outPutLength = .05;\n\n//From iq's artical\nfloat sdBox(in vec2 p, in vec2 b) {\n    vec2 d = abs(p) - b;\n    return length(max(d, 0.0)) + min(max(d.x, d.y), 0.0);\n}\n// https://www.shadertoy.com/view/MdcfDj\nfloat hash_Tong(uvec2 q)\n{\n\tq *= uvec2(1597334677U, 3812015801U);\n    uint n = q.x ^ q.y;\n    n = n * (n ^ (n >> 15));\n    return float(n) * (1.0/float(0xffffffffU));\n}\nfloat map(float value, float fromMin, float fromMax, float toMin, float toMax) {\n    return toMin + (value - fromMin) * (toMax - toMin) / (fromMax - fromMin);\n}\n// by iq, https://iquilezles.org/articles/palettes/\nvec3 palette( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.283185*(c*t+d) );\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.);\n    vec2 uv = fragCoord / iResolution.xy;\n    float waveguide = texture(iChannel0,uv).b;\n    \n    fragColor += vec4(vec3(waveguide),1.);\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[],"outputs":[{"id":"4sXGR8","channel":0}],"code":"//use binary tree as the wave guide\n//Fork of https://www.shadertoy.com/view/ltKcW1\nvoid mainImage( out vec4 o, in vec2 c ) \n{\n    \n    vec2 w = 2.*(c/iResolution.xy - .5);\n    w.x*=.5;\n    w.x+=.5;\n    w.y*=.25;\n    w.y+=.25;\n    float t = 1.0, T = t + 1.0,\n          u = w.y * T, // 互换 w.x 和 w.y\n          v = w.x * w.x - t / 4.0, // 互换 w.x 和 w.y\n          l = v * 4.0, \n          m = pow(2.0, floor(l) + 1.001), \n          b = u * m, \n          x = (floor(b) + 0.5 + 0.25 * sign(fract(b) - 0.5) * smoothstep(0.0, 1.0, fract(l))) / m / T,\n          d = abs(x - w.y) - 0.01; // 互换 x 的比较\n    o = o-o+smoothstep(-0.001, -.0001, d);\n}","name":"Buffer C","description":"","type":"buffer"}]}