{"ver":"0.1","info":{"id":"MdGfRc","date":"1529768285","viewed":174,"name":"Frieze Groups","username":"ptrgags","description":"I found a way to represent all 7 frieze groups in a shader.\n\nSee https://en.wikipedia.org/wiki/Frieze_group for more information on Frieze symmetry groups.\n\nFrom bottom to top, the frieze groups are:\np1, p11g, p1m1, p2, p2mg, p11m, p2mm","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["math","tiling","frieze"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define THICKNESS 0.1\n#define PATTERN_CENTER 0.5\n\n#define AND min\n#define OR max\n#define NOT(x) (1.0 - (x))\n\nfloat motif(vec2 uv) {\n    float dist = max(uv.x, uv.y);\n    float far = smoothstep(PATTERN_CENTER, PATTERN_CENTER + THICKNESS, dist);\n    float near = smoothstep(PATTERN_CENTER, PATTERN_CENTER - THICKNESS, dist);\n    return NOT(OR(far, near));\n}\n\nfloat divider(vec2 uv) {\n    return smoothstep(0.9, 0.99, uv.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // make the strips move. Unfortunately\n    // This has to be done before the tile_2D call\n    // hence the floor() call.\n    float x_speed = 0.05 * (floor(uv.y * 7.0) + 1.0);\n    uv.x = uv.x - (x_speed * iTime);\n    \n    // Define the rows.\n    Tile strips = tile_2D(uv, vec2(20.0, 7.0));\n    \n    Tile frieze;\n    \n    if (strips.id.y < 1.0) {\n        frieze = frieze_p1(strips);\n    } else if (strips.id.y < 2.0) {\n        frieze = frieze_p11g(strips);\n    } else if (strips.id.y < 3.0) {\n        frieze = frieze_p1m1(strips);\n    } else if (strips.id.y < 4.0) {\n        frieze = frieze_p2(strips);\n    } else if (strips.id.y < 5.0) {\n        frieze = frieze_p2mg(strips);\n    } else if (strips.id.y < 6.0) {\n        frieze = frieze_p11m(strips);\n    } else if (strips.id.y < 7.0) {\n        frieze = frieze_p2mm(strips);\n    }\n    \n    vec4 color = vec4(1.0, 0.5, 0.0, 1.0);\n    vec4 line_color = vec4(0.0, 0.0, 1.0, 1.0);\n    \n    vec4 image = color * motif(frieze.uv);\n    image = mix(image, line_color, divider(strips.uv));\n    \n    \n    fragColor = image;\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// Tile space in two directions at once =============\nstruct Tile {\n    vec2 uv;\n    vec2 id;\n    // Also keep track of parity, this is important\n    // for reflection operations\n    vec2 parity;\n};\n    \nTile tile_2D(vec2 uv, vec2 n) {\n    Tile result;\n    result.uv = fract(uv * n);\n    result.id = floor(uv * n);\n    result.parity = mod(result.id, 2.0);\n    return result;\n}\n\n// ==================================================\n\n// Flip odd-numbered cells. This produces a mirroring\n// effect. This works in both directions at once,\n// so set a component of enabled to 0.0 to disable flipping.\n// otherwise, set it to 1.0\nTile flip(Tile t, vec2 parity, vec2 enabled) {\n    Tile result = t;\n    \n    // Right side up and flipped\n    vec2 uv = t.uv;\n    vec2 flipped = 1.0 - uv;\n    \n    // Disregard the parity for any component of\n    // enabled that is 0.0\n    vec2 flip_mask = enabled * parity;\n    \n    // flip the tile.\n    result.uv = mix(uv, flipped, flip_mask);\n    return result;\n}\n\n// ====================================================\n// All 7 symmetry groups can be generated from the above rules!\n// Each of these assume we have already tiled the screen\n// horizontally.\n\n// No additional symmetry\nTile frieze_p1(Tile t) {\n    return t;\n}\n\n// Flip every other cell vertically to simulate\n// a glide reflection.\nTile frieze_p11g(Tile t) {\n    return flip(t, t.parity.xx, vec2(0.0, 1.0));\n}\n\n// Mirror every other cell horizontally.\nTile frieze_p1m1(Tile t) {\n    return flip(t, t.parity.xx, vec2(1.0, 0.0));\n}\n\n// Flip every other cell both horizontally and vertically\nTile frieze_p2(Tile t) {\n    return flip(t, t.parity.xx, vec2(1.0, 1.0));\n}\n\n// Subdivide the tile horizontally and rotate around the center\n// also flip horizontally.\nTile frieze_p2mg(Tile t) {\n    Tile result;\n    Tile flipped = flip(t, t.parity.xx, vec2(1.0, 0.0));\n    Tile subdivided = tile_2D(flipped.uv, vec2(2.0, 1.0));\n    Tile sub_flipped = flip(subdivided, subdivided.parity.xx, vec2(1.0, 1.0));\n    \n    // We want the id and parity of the main cell, but\n    // the UV of the subdivided cell.\n    result = flipped;\n    result.uv = sub_flipped.uv;\n    return result;\n}\n\n// Subdivide the tile and flip vertically.\nTile frieze_p11m(Tile t) {\n    Tile result;\n    Tile subdivided = tile_2D(t.uv, vec2(2.0, 2.0));\n    Tile sub_flipped = flip(subdivided, subdivided.parity.yy, vec2(0.0, 1.0));\n    \n    // We want the id and parity of the main cell, but\n    // the UV of the subdivided cell.\n    result = t;\n    result.uv = sub_flipped.uv;\n    return result;\n}\n\n// Subdivide the tile and flip in both directions.\nTile frieze_p2mm(Tile t) {\n    Tile result;\n    Tile subdivided = tile_2D(t.uv, vec2(2.0, 2.0));\n    Tile sub_flipped = flip(subdivided, subdivided.parity, vec2(1.0, 1.0));\n    \n    // We want the id and parity of the main cell, but\n    // the UV of the subdivided cell.\n    result = t;\n    result.uv = sub_flipped.uv;\n    return result;\n}","name":"Common","description":"","type":"common"}]}