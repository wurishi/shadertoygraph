{"ver":"0.1","info":{"id":"7t2GWd","date":"1625010323","viewed":191,"name":"kuwahara exploring","username":"aksel","description":"implementation of the kuwahara filter algorithm. highly un-optimized. mostly just to figure out how the alg works","likes":3,"published":1,"flags":32,"usePreview":0,"tags":["filter","computervision","processing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const int FILTER_SIZE = 9;\nconst int j = FILTER_SIZE/ 2 + 1; // row/col size (filter is a square)\nconst int ftot = FILTER_SIZE * FILTER_SIZE;\n\nvec4 avg_col_region(in float xmin,\n    in float xmax, in float ymin, in float ymax) \n{\n    vec4 tot_col = vec4(0.f);\n    float tot = 0.f;\n    for (float ay = ymin; ay <= ymax; ++ay) {\n        for (float ax = xmin; ax <= xmax; ++ax) {\n            tot_col += texture(iChannel1, vec2(ax, ay)/iResolution.xy);\n            tot += 1.f;\n        }\n    }\n    \n    return tot_col / tot;\n}\n\n// use bufA brightness to determine region\nvec2 avg_sigma_region(in float xmin,\n    in float xmax, in float ymin, in float ymax) \n{\n    const int amt = j*j + 1;\n    float a[ftot];\n    \n    int ai = 0;\n    float asum = 0.f; // total brightness val in region 'a'\n    \n    for (float ay = ymin; ay <= ymax; ++ay) {\n        for (float ax = xmin; ax <= xmax; ++ax) {\n            float pav = texture(iChannel0, vec2(ax, ay)/iResolution.xy)[2];\n            \n            a[ai] = pav;\n            ai += 1;\n            \n            // for getting avg\n            asum += pav;\n        }\n    }\n    float a_avg = asum / float(ai); // calc avg\n    float atot_std = 0.f; // total for std dev\n    for (int ak = 0; ak < (j*j); ++ak) {\n        float val = a[ak] - a_avg;\n        atot_std += (val * val);\n    }\n    float var = (atot_std * atot_std) / float(j*j);\n    float sigma = sqrt(var); // std deviation\n    \n    return vec2(a_avg, sigma); // average and std dev of region\n}\n\n// use raw img RGB to determine region\nvec4 avg_sigma_region2(in float xmin,\n    in float xmax, in float ymin, in float ymax) \n{\n    const int amt = j*j + 1;\n    vec3 a[ftot];\n    \n    int ai = 0;\n    vec3 asum = vec3(0.f); // total brightness val in region 'a'\n    \n    for (float ay = ymin; ay <= ymax; ++ay) {\n        for (float ax = xmin; ax <= xmax; ++ax) {\n            vec3 pav = texture(iChannel1, vec2(ax, ay)/iResolution.xy).rgb;\n            \n            a[ai] = pav;\n            ai += 1;\n            \n            // for getting avg\n            asum += pav;\n        }\n    }\n    vec3 a_avg = asum / float(ai); // calc avg\n    vec3 atot_std = vec3(0.f); // total for std dev\n    for (int ak = 0; ak < (j*j); ++ak) {\n        vec3 val = a[ak] - a_avg;\n        atot_std += (val * val);\n    }\n    vec3 var = (atot_std * atot_std) / float(j*j);\n    float sigma = sqrt(var.r) + sqrt(var.g) + sqrt(var.b); // std deviation\n    \n    return vec4(a_avg, sigma); // average and std dev of region\n}\n\n// uses avg_sigma_region2\nvec4 kuwahara2(in vec4 col, in vec2 uv) {\n    vec4 regions[4];\n    \n    regions[0] = avg_sigma_region2(uv.x - float(j-1),\n                                     uv.x,\n                                     uv.y - float(j-1),\n                                     uv.y);\n    regions[1] = avg_sigma_region2(uv.x,\n                                     uv.x + float(j-1),\n                                     uv.y - float(j-1),\n                                     uv.y);\n    regions[2] = avg_sigma_region2(uv.x - float(j-1),\n                                     uv.x,\n                                     uv.y,\n                                     uv.y + float(j-1));\n    regions[3] = avg_sigma_region2(uv.x,\n                                     uv.x + float(j-1),\n                                     uv.y,\n                                     uv.y + float(j-1));\n    vec4 min_region = regions[0];\n    int min_region_idx = 0;\n    for (int i = 1; i < 4; ++i) {\n        if (regions[i][3] < min_region[3]) {\n            min_region = regions[i];\n            min_region_idx = i;\n        }\n    }\n    \n    return vec4(min_region.rgb, 1.f);\n}\n\nvec4 kuwahara(in vec4 col, in vec2 uv) {\n    vec2 regions[4];\n    \n    regions[0] = avg_sigma_region(uv.x - float(j-1),\n                                     uv.x,\n                                     uv.y - float(j-1),\n                                     uv.y);\n    regions[1] = avg_sigma_region(uv.x,\n                                     uv.x + float(j-1),\n                                     uv.y - float(j-1),\n                                     uv.y);\n    regions[2] = avg_sigma_region(uv.x - float(j-1),\n                                     uv.x,\n                                     uv.y,\n                                     uv.y + float(j-1));\n    regions[3] = avg_sigma_region(uv.x,\n                                     uv.x + float(j-1),\n                                     uv.y,\n                                     uv.y + float(j-1));\n    vec2 min_region = regions[0];\n    int min_region_idx = 0;\n    for (int i = 1; i < 4; ++i) {\n        if (regions[i][1] < min_region[1]) {\n            min_region = regions[i];\n            min_region_idx = i;\n        }\n    }\n    \n    vec4 final_col = vec4(0.f);\n                     \n    if (min_region_idx == 0) {\n        final_col = avg_col_region(uv.x - float(j-1),\n                                     uv.x,\n                                     uv.y - float(j-1),\n                                     uv.y);\n    }\n    else if (min_region_idx == 1) {\n        final_col = avg_col_region(uv.x,\n                                     uv.x + float(j-1),\n                                     uv.y - float(j-1),\n                                     uv.y);\n    }\n    else if (min_region_idx == 2) {\n        final_col = avg_col_region(uv.x - float(j-1),\n                                     uv.x,\n                                     uv.y,\n                                     uv.y + float(j-1));\n    }\n    else if (min_region_idx ==3 ) {\n        final_col = avg_col_region(uv.x,\n                                     uv.x + float(j-1),\n                                     uv.y,\n                                     uv.y + float(j-1));\n    }\n\n    return final_col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord.xy/iResolution.xy;\n\n    // Output to screen\n    \n    vec4 col = texture(iChannel0, uv);\n    vec4 l = texture(iChannel1, uv);\n    vec4 lg = vec4(texture(iChannel1, uv)[2]);\n    vec4 k = kuwahara(col, fragCoord.xy);\n    vec4 k2 = kuwahara2(col, fragCoord.xy);\n    \n    fragColor = k2;\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// from http://lolengine.net/blog/2013/01/13/fast-rgb-to-hsv\nvec3 rgb2hsv(in vec4 rgb) {\n    float r = rgb[0];// / 255.f;\n    float g = rgb[1];// / 255.f;\n    float b = rgb[2];// / 255.f;\n    float rgb_max = max(r, max(g,b));\n    float rgb_min = min(r, min(g,b));\n    float delta = rgb_max - rgb_min;\n    \n    float h, s, v = 0.f;\n\n    // sat and val\n    s = delta / (rgb_max + 1e-20f);\n    v = rgb_max;\n\n    // compute hue\n    float hue;\n    if (r == rgb_max) hue = (g - b) / (delta + 1e-20f);\n    else if (g == rgb_max) hue = 2.f + (b - r) / (delta + 1e-20f);\n    else hue = 4.f + (r - g) / (delta + 1e-20f);\n    if (hue < 0.f) hue += 6.f;\n    \n    h = hue * (1.f / 6.f);\n    \n    return vec3(h,s,v);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Output to screen\n    vec4 col = vec4(rgb2hsv(texture(iChannel0, uv)),1.f);\n    fragColor = col;\n}","name":"Buffer A","description":"","type":"buffer"}]}