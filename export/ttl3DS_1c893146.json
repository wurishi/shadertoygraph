{"ver":"0.1","info":{"id":"ttl3DS","date":"1557524681","viewed":416,"name":"Black & White Gears","username":"fizzer","description":"This was my original sketch for the 'gears' in this 4kb demo: [url]http://www.pouet.net/prod.php?which=81000[/url]. My original plan was too ambitious so it all had to be cut down a lot. I didn't clean up this code yet, because it's a sketch. Sorry.","likes":42,"published":1,"flags":32,"usePreview":0,"tags":["gears","sketch","cogs"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 t=uv*2.-1.;\n    t.y*=iResolution.y/iResolution.x;\n\n    float r=max(1.,abs(uv.y-.5)*40.);\n\n    fragColor=vec4(0);\n\n    if(abs(t.y)<.45)\n    {\n        float ws=0.;\n        float time=iTime;\n\n        for(int y=-16;y<=+16;++y)\n        {\n            for(int x=-16;x<=+16;++x)\n            {\n                if(float(x*x+y*y)<r*r)\n                {\n                    float w=1.;\n                    ivec2 p=ivec2(fragCoord)+ivec2(x,y);\n                    fragColor += texelFetch(iChannel0,p,0);\n                    ws+=w;\n                }\n            }\n        }\n\n        fragColor/=ws;\n\n        fragColor.rgb*=1.-(pow(abs(t.x),4.)+pow(abs(t.y*2.),4.))*.2;\n\n\n        fragColor.rgb=pow(fragColor.rgb,vec3(1./2.2));\n        fragColor.rgb+=noise(t.xy)/100.;\n    }\n    fragColor.a=1.;\n}\n\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\nvec2 intersectSphere(vec3 ro, vec3 rd)\n{\n    float a = dot(rd, rd), b = 2. * dot(rd, ro),\n        c = dot(ro, ro) - 1., desc = b * b - 4. * a * c;\n\n    if (desc < 0.)\n        return vec2(-1);\n\n    c = sqrt(desc);\n\n    return (-b + vec2(-c, c)) / (2. * a);\n}\n\nvec2 box(vec3 ro,vec3 rd,vec3 sz)\n{\n    vec3 t0 = (sz*-sign(rd) - ro) / rd,\n        t1 = (sz*sign(rd) - ro) / rd;\n\n    return vec2(max(t0.x, max(t0.y, t0.z)),min(t1.x, min(t1.y, t1.z)));\n}\n\nvec3 envmap(vec3 p)\n{\n    vec3 nc=vec3(step(fract(atan(p.y+p.z,p.x)*1.),.1))*.2;\n    for(int i=0;i<10;++i)\n        nc=mix(nc,vec3(.5+.5*cos(float(i)/3.))*2.,smoothstep(0.,.01,\n                                                             dot(normalize(vec3(cos(float(i)*7.5),sin(float(i)*2.),cos(float(i)*3.)+.5)),\n                                                                 normalize(p))-\n                                                             mix(.8,1.,pow(.5+.5*cos(float(i)*5.),.5))));\n    return (nc+.1)+pow(length(cos(p*10.)),2.)*.1;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 t=uv*2.-1.;\n    t.y*=iResolution.y/iResolution.x;\n\n    vec2 fc=fragCoord;\n    int samplenum=0;\n\n    fragColor.rgb=vec3(0);\n\n    if(abs(t.y)<.45)\n    {\n        // anti-aliasing loop\n        for(int y=0;y<3;++y)\n        {\n            for(int x=0;x<3;++x)\n            {\n                vec2 p=t.xy+vec2(.001*float(x)/2.5,.001*float(y)/2.5);\n\n                float time=iTime+noise(fc+float(samplenum)*99.)*.03;\n\n                // gears scene\n\n                vec3 ro=vec3(0.,0.2,5.);\n                vec3 rd=normalize(vec3(p.yx,-6.8));\n\n                float tcell=mod(floor(time/4.),6.)-7.;\n                ro+=cos(tcell*vec3(1,3,5))*.25;\n\n                float ax=cos(tcell)*.4,ay=sin(tcell)*.4;\n\n                float a=ay+pi/2.-1.25;\n                mat2 m=rotmat(a);\n\n                ro.xz*=m;\n                rd.xz*=m;\n\n                a=ax+pi/2.+.1;\n                m=rotmat(a);\n\n                ro.xy*=m;\n                rd.xy*=m;\n\n                a=4.1*0.;\n                m=rotmat(a);\n\n                ro.xz*=m;\n                rd.xz*=m;\n\n                vec3 nearNorm=vec3(-1);\n                float nearT=2e1;\n                float nearS=1.;\n\n                vec3 localP;\n\n                float ss=1.;\n\n                // random gears\n                for(int i=0;i<5;++i)\n                {\n                    vec3 org=vec3(cos(float(i))*1.3,cos(float(i)*2.)*.55,cos(float(i)*5.)*1.3),\n                        outn,  ro2=ro-org,rd2=rd;\n\n                    a=4.1+time/1.*(1.-float(i&1)*2.);\n                    m=rotmat(a);\n\n                    ro2.xz*=m;\n                    rd2.xz*=m;\n\n                    float shad=1.;\n\n                    float t;\n                    // single gear intersection\n                    {\n\n                        // first cylinder\n                        vec2 is=intersectSphere(ro2*vec3(1,0.0,1),rd2*vec3(1,0.0,1));\n                        vec3 nearNorm=vec3(0);\n                        float nearT=1e4;\n\n                        float innerRad=.85;\n                        float depth=.03;\n\n                        int N=12;\n\n                        if(is.x<is.y)\n                        {\n                            vec2 ois=is;\n                            vec2 pt=vec2((-depth-ro2.y)/rd2.y, (+depth-ro2.y)/rd2.y);\n\n                            nearNorm=(pt.x<is.y && pt.y>is.x && pt.x>is.x)?vec3(0,-sign(rd2.y),0):vec3(ro2.xz+is.x*rd2.xz,0).xzy;\n\n                            vec3 onearnorm=nearNorm;\n\n                            is.x=max(is.x,pt.x);\n                            is.y=min(is.y,pt.y);\n\n                            if(is.x<is.y)\n                            {\n                                // single gear teeth\n\n                                for(int i=0;i<N;++i)\n                                {\n                                    vec3 ro3=ro2,rd3=rd2;\n\n                                    float a=float(i)/float(N)*pi;\n                                    mat2 m=rotmat(a);\n\n                                    ro3.xz*=m;\n                                    rd3.xz*=m;\n\n                                    float w=.1;\n\n                                    vec2 b=box(ro3,rd3,vec3(w,depth,4));\n\n                                    vec2 is2=vec2(max(is.x,b.x), min(is.y,b.y));\n\n                                    if(is2.x<is2.y && is2.x<nearT)\n                                    {\n                                        if(length(ro3.xz+rd3.xz*is2.x)<.999)\n                                        {\n                                            vec3 rp=ro3+rd3*is2.x,\n                                                arp = abs(rp) / vec3(w,depth,4) / 2.;\n\n                                            nearNorm= step(arp.yzx, arp) * step(arp.zxy, arp) * sign(rp);\n                                            nearNorm.xz*=rotmat(-a);\n                                        }\n                                        else\n                                            nearNorm=onearnorm;\n                                        nearT=is2.x;\n                                    }\n                                }\n                            }\n\n                            // second cylinder\n                            vec2 is2=intersectSphere(ro2*vec3(1,0,1)/innerRad,rd2*vec3(1,0,1)/innerRad);\n\n                            pt=vec2((+depth*2.-ro2.y)/rd2.y, (-depth*2.-ro2.y)/rd2.y);\n\n                            if(pt.x>pt.y)\n                                pt=pt.yx;\n\n                            is2.x=max(is2.x,pt.x);\n                            is2.y=min(is2.y,pt.y);\n\n                            if(is2.x<is2.y && is2.x<nearT)\n                            {\n                                nearNorm=vec3(ro2.xz+is.x*rd2.xz,0).xzy;\n                                nearT=is2.x;\n\n                                if(abs(nearT-pt.x)<1e-3)\n                                {\n                                    nearNorm=vec3(0,-sign(rd2.y),0);\n                                }\n\n                                vec3 rp=ro2+rd2*nearT;\n                            }\n\n                            outn=nearNorm;\n                        }\n\n                        vec3 rp=ro2+rd2*nearT;\n\n                        if(length(rp.xz)<.9)\n                            outn.xz+=normalize(rp.xz)*cos(length(rp.xz)*600.)*.3;\n\n                        rp.xz*=rotmat(-(floor(atan(rp.x,rp.z)/(pi*2.)*float(N)*2.+1.)-.5)/float(N)/2.*(pi*2.));\n\n                        // shadowing\n                        shad=(.25+smoothstep(0.,.1,length((rp-vec3(0,0,.85))*vec3(.5,1.,2)))) * \n                            (.25+smoothstep(0.,.12,length((rp-vec3(0,0,.95))*vec3(1.5,1.,.5))));\n\n                        t=nearT;\n                    }\n\n\n                    if(t>0.&&t<nearT)\n                    {\n                        nearS=shad;\n                        nearT=t;\n                        nearNorm=outn;\n                        nearNorm.xz*=transpose(m);\n                        localP=ro2*1.+rd2*t;\n                    }\n                }\n\n                // giant axel\n\n                vec2 is2=intersectSphere(ro*vec3(2,0,2)-vec3(-1,0,-2.2),rd*vec3(2,0,2));\n\n                if(is2.x<is2.y && is2.x<nearT)\n                {\n                    nearNorm=vec3(ro.xz+is2.x*rd.xz,0).xzy;\n                    nearT=is2.x;\n                    nearS=1.3;\n                    localP=ro*1.+rd*nearT;\n                }\n\n                nearNorm=normalize(nearNorm);\n\n                ro=ro+rd*nearT;\n\n                nearS*=mix(.3,1.,smoothstep(0.,.05,distance(ro, vec3(vec2(-.5,-1.1) +  normalize(ro.xz-vec2(-.5,-1.1)) * .5, -.4).xzy)));\n\n                // shadows cast downwards from gears\n\n                for(int i=0;i<6;++i)\n                {\n                    vec3 org=vec3(cos(float(i))*1.3,cos(float(i)*2.)*.55,cos(float(i)*5.)*1.3),\n                        rp2=ro-org;\n\n                    ss*=max(mix(.2,1.,smoothstep(0.,.12,length(rp2.xz)-1.)),smoothstep(-.1,.04,-rp2.y));\n                }\n\n                fragColor.rgb+=envmap(-reflect(rd,nearNorm).yxz)*nearS*mix(.25,1.,max(0.,1.+dot(rd,nearNorm)))*\n                    mix(.86,1.,smoothstep(.28,.3,smoothNoise2(localP.xz*75.)))*\n                    mix(.14,2.5,smoothstep(-.5,2.,sin(ro.z*3.-1.5)))*ss;\n\n\n                ++samplenum;\n            }\n        }\n\n        fragColor.rgb*=pow(clamp(iTime/6.,0.,1.),.75);\n\n        fragColor.rgb*=vec3(1.+.05*smoothNoise2(t.xy*400.))/9.;\n        fragColor.rgb=clamp(fragColor.rgb,0.,1.);\n    }\n}\n\n\n\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"float pi=3.14159265358979323;\n\nfloat hash(float n)\n{\n    return fract(sin(n)*43758.5453);\n}\n\nfloat noise(vec2 p)\n{\n    return hash(p.x + p.y*57.0);\n}\n\nfloat smoothNoise2(vec2 p)\n{\n    vec2 p0 = floor(p + vec2(0.0, 0.0));\n    vec2 p1 = floor(p + vec2(1.0, 0.0));\n    vec2 p2 = floor(p + vec2(0.0, 1.0));\n    vec2 p3 = floor(p + vec2(1.0, 1.0));\n\n    vec2 pf = smoothstep(0.0, 1.0, fract(p));\n\n    return mix( mix(noise(p0), noise(p1), pf.x), \n               mix(noise(p2), noise(p3), pf.x), pf.y);\n}\n\nfloat fbm2(vec2 p)\n{\n    float f=0.,x=.5;\n    for(int i=0;i<5;++i)\n    {\n        f+=smoothNoise2(p)*x;\n        x*=.5;\n        p*=2.;\n    }\n    return f;\n}\n\nmat2 rotmat(float a)\n{\n    return mat2(cos(a),sin(a),-sin(a),cos(a));\n}\n","name":"Common","description":"","type":"common"}]}