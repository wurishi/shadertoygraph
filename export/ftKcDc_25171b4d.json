{"ver":"0.1","info":{"id":"ftKcDc","date":"1662540661","viewed":289,"name":"Rotating sdf tori","username":"exucutional","description":"MIPT - Gamedev - Graphics - Homework - 1","likes":15,"published":1,"flags":0,"usePreview":0,"tags":["sdf","hw","graphics","mipt"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const int TRACE_MAX_STEPS = 255;\nconst float TRACE_MAX_DIST = 10.;\nconst float TRACE_EPSILON = .001;\nconst float NORMAL_EPSILON = .001;\nconst vec3 eye = vec3(0., 0., 5.);\n//const vec3 light = vec3(0.0, 1.0, 3.0);\n\nmat3 rotateX(float angle)\n{\n    float c = cos(angle);\n    float s = sin(angle);\n    return mat3(\n        vec3(1, 0, 0),\n        vec3(0, c, -s),\n        vec3(0, s, c)\n    );\n}\n\nmat3 rotateY(float angle)\n{\n    float c = cos(angle);\n    float s = sin(angle);\n    return mat3(\n        vec3(c, 0, s),\n        vec3(0, 1, 0),\n        vec3(-s, 0, c)\n    );\n}\n\nmat3 rotateZ(float angle)\n{\n    float c = cos(angle);\n    float s = sin(angle);\n    return mat3(\n        vec3(c, -s, 0),\n        vec3(s, c, 0),\n        vec3(0, 0, 1)\n    );\n}\n\nfloat length8(in vec2 p)\n{\n    return pow(pow(abs(p.x), 8.)+pow(abs(p.y), 8.), 1./8.);\n}\n\nfloat lengthInf(in vec2 p)\n{\n    return max(abs(p.x), abs(p.y));\n}\n\nfloat intersectSDF(float d1, float d2)\n{\n    return max(d1, d2);\n}\n\nfloat unionSDF(float d1, float d2)\n{\n    return min(d1, d2);\n}\n\nfloat differenceSDF(float d1, float d2) {\n    return max(d1, -d2);\n}\n\nfloat sphereSDF(in vec3 p, in vec3 c, in float r)\n{\n    return length(p-c)-r;\n}\n\nfloat boxSDF(in vec3 p, in vec3 size)\n{\n    vec3 pt = abs(p)-size;\n\n    return length(max(pt, .0)) + min(max(pt.x, max(pt.y, pt.z)), .0);\n}\n\nfloat torusSDF( in vec3 pos, in vec2 t )\n{\n    vec3 pt = pos;\n    vec2 q  = vec2(length8(pt.xz)-t.x, pt.y);\n    return length8(q) - t.y;\n}\n\nfloat sceneSDF(in vec3 p, in mat3 m)\n{\n    vec3 q = p*m;\n    float s = .25*sin(iTime);\n    float scene = 1.;\n    mat3 rot = rotateX(-.785)*rotateY(.25*iTime)*rotateZ(s);\n    mat3 rot_i = mat3(1);\n    for (float i = 0.; i < 11.; i++)\n    {\n        if (mod(i, 2.) == 0.)\n            rot_i *= rotateX(.5*iTime); \n        else \n            rot_i *= rotateZ(.5*iTime);\n        scene = unionSDF(scene, torusSDF(q*rot*rot_i, vec2(1.-.1*i, .05)));\n    }\n    return scene;\n}\n\nvec3 traceSDF(in vec3 from, in vec3 dir, out bool hit, in mat3 m)\n{\n    vec3 p = from;\n    float totalDist = 0.;\n    hit = false;\n    for (int steps = 0; steps < TRACE_MAX_STEPS; steps++)\n    {\n        float dist = sceneSDF(p, m);\n        if (dist < TRACE_EPSILON)\n        {\n            hit = true;\n            break;\n        }\n        totalDist += dist;\n        if (totalDist > TRACE_MAX_DIST)\n            break;\n        p += .8*dir*dist;\n    }\n    return p;\n}\n\nvec3 calcNormal(vec3 p, float d, in mat3 m)\n{\n    float e = max(d*.5, NORMAL_EPSILON);\n    return normalize(vec3(\n        sceneSDF(p+vec3(e, 0, 0), m)-sceneSDF(p-vec3(e, 0, 0), m),\n        sceneSDF(p+vec3(0, e, 0), m)-sceneSDF(p-vec3(0, e, 0), m),\n        sceneSDF(p+vec3(0, 0, e), m)-sceneSDF(p-vec3(0, 0, e), m)\n    ));\n}\n\nfloat ambientOcclusion(in vec3 pos, in vec3 normal, mat3 m)\n{\n    float occ = .0;\n    float sca = 1.;\n    for (int i = 0; i < 5; i++)\n    {\n        float h = .01+.12*float(i)/4.;\n        float d = sceneSDF(pos+h*normal, m);\n        occ += (h-d)*sca;\n        sca *= .95;\n        if (occ > .35) \n            break;\n    }\n    return clamp(1.-3.*occ, 0., 1.)*(.5+.5*normal.y);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    //vec3 mouse = vec3(iMouse.x/iResolution.xy - 0.5, iMouse.z);\n    //mat3 m = rotateX(6.0 * mouse.y) * rotateY(6.0 * mouse.x);\n    mat3 m = mat3(1);\n    vec2 uv = 5.*(fragCoord-.5*iResolution.xy)/max(iResolution.x, iResolution.y);\n    vec3 dir = normalize(vec3(uv, 0)-eye);\n    bool hit;\n    vec3 p = traceSDF(eye, dir, hit, m);\n    vec4 color = vec4(.1, .1, .1, 1);\n    vec3 light = vec3(2.*sin(0.5*iTime), 2.*cos(0.5*iTime), 1)*rotateX(-.785);\n    if (hit)\n    {\n        vec3 l = normalize(light - p);\n        vec3 n = calcNormal(p, .001, m);\n        float nl = max(.0, dot(n, l));\n        \n        vec3 v = normalize(eye - p);\n        vec3 h = normalize(l + v);\n        float hn = max(.0, dot(h, n));\n        float sp = pow(hn, 100.);\n        \n        vec4 colorDiffuse = vec4(1, .5, 0, 1);\n        vec4 colorPhong = vec4(1);\n        vec4 colorAbmient = vec4(1, .5, 0, 1);\n        color = colorDiffuse*vec4(nl)\n            + colorPhong*sp\n            + .25*colorAbmient*ambientOcclusion(p, n, m);\n    }\n    fragColor = color;\n}","name":"Image","description":"","type":"image"}]}