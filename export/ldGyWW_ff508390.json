{"ver":"0.1","info":{"id":"ldGyWW","date":"1522410495","viewed":14064,"name":"Not a lifestyle choice","username":"shau","description":"glowing stuff","likes":52,"published":1,"flags":0,"usePreview":0,"tags":["3d"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Created by SHAU - 2018\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//-----------------------------------------------------\n\n#define T iTime\n#define PI 3.141592\n#define FAR 100.0\n#define EPS 0.005\n#define ZERO (min(iFrame,0))\n\n#define ROOF 1.0\n#define FLOOR 2.0\n#define PILLAR 3.0\n#define PILLAR_LIGHT 4.0\n#define SPHERE 5.0\n\n#define PARTITION_SIZE 30.0\n\n#define CA vec3(0.5, 0.5, 0.5)\n#define CB vec3(0.5, 0.5, 0.5)\n#define CC vec3(1.0, 1.0, 1.0)\n#define CD vec3(0.0, 0.33, 0.67)\n\nstruct Scene {\n    float t; //distance to surface\n    float id; //id of surface\n    vec3 n; //surface normal\n    float li; //light\n    float em; //emissive\n    float ref; //reflection\n};\n\nfloat rand(vec2 p) {return fract(sin(dot(p, vec2(12.9898,78.233))) * 43758.5453);}\nmat2 rot(float x) {return mat2(cos(x), sin(x), -sin(x), cos(x));}\nvec3 camPos() {return vec3(0.0, 0.0, T * 4.0);}\nfloat sphereMotion(float z) {return sin(z * 0.1);}\n//IQ cosine palattes\n//https://iquilezles.org/articles/palettes\nvec3 palette(float t, vec3 a, vec3 b, vec3 c, vec3 d) {return a + b * cos(6.28318 * (c * t + d));}\nvec3 glowColour() {return palette(T * 0.1, CA, CB, CC, CD);}\n\n//IQs noise\nfloat noise(vec3 rp) {\n    vec3 ip = floor(rp);\n    rp -= ip; \n    vec3 s = vec3(7, 157, 113);\n    vec4 h = vec4(0.0, s.yz, s.y + s.z) + dot(ip, s);\n    rp = rp * rp * (3.0 - 2.0 * rp); \n    h = mix(fract(sin(h) * 43758.5), fract(sin(h + s.x) * 43758.5), rp.x);\n    h.xy = mix(h.xz, h.yw, rp.y);\n    return mix(h.x, h.y, rp.z); \n}\n\n\n//IQs distance functions\nfloat sphIntersect(vec3 ro, vec3 rd, vec4 sph) {\n    vec3 oc = ro - sph.xyz;\n    float b = dot(oc, rd);\n    float c = dot(oc, oc) - sph.w * sph.w;\n    float h = b * b - c;\n    if (h < 0.0) return 0.0;\n    h = sqrt(h);\n    return -b - h;\n}\n\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r) {\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp(dot(pa,ba) / dot(ba, ba), 0.0, 1.0);\n    return length(pa - ba * h) - r;\n}\n\nfloat sdBox(vec3 p, vec3 b) {\n    vec3 d = abs(p) - b;\n    return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));\n}\n\n//neat trick from Shane\nvec2 nearest(vec2 a, vec2 b){ \n    float s = step(a.x, b.x);\n    return s * a + (1. - s) * b;\n}\nvec4 nearest(vec4 a, vec4 b) {\n   float s = step(a.w, b.w);\n   return s * a + (1. - s) * b;       \n}\n\n//returns sphere center and distance\nvec4 nearestSphere(vec3 rp) {\n    \n    vec4 near = vec4(vec3(0.0), FAR);\n\n    float z = camPos().z; \n    z = z - mod(z, PARTITION_SIZE) - mod(T * 10.0, PARTITION_SIZE); //start partitioning behind camera\n    \n    for (int i=ZERO; i<5; i++) {\n    \tvec3 c = vec3(sphereMotion(z), -1.6, z);\n        near = nearest(near, vec4(c, length(rp - c) - 0.8));\n        z += PARTITION_SIZE;\n    }\n    \n    return near;\n}\n\nvec3 map(vec3 p) {\n     \n    float sphere = nearestSphere(p).w;   \n    \n    p.xz = mod(p.xz,12.0) - 6.0;\n    p = abs(p);\n    \n    float box = sdBox(p, vec3(2.9, 1.4, 2.9));\n    float light = min(sdCapsule(p,vec3(3.0,1.5,3.0),vec3(0.0, 1.5,3.0),0.05),\n                      sdCapsule(p,vec3(3.0,1.5,3.0),vec3(3.0, 1.5,0.0),0.05));\n    light = min(light,sdCapsule(p,vec3(3.0,1.5,3.0),vec3(3.0,-1.5,3.0),0.05));\n\n    vec2 near = nearest(vec2(box,PILLAR), vec2(light,PILLAR_LIGHT));\n    near = nearest(near, vec2(sphere,SPHERE));\n    \n    return vec3(near,light);\n}\n\nvec3 normal(vec3 p) \n{  \n    vec4 n = vec4(0.0);\n    for (int i=ZERO; i<4; i++) \n    {\n        vec4 s = vec4(p, 0.0);\n        s[i] += EPS;\n        n[i] = map(s.xyz).x;\n    }\n    return normalize(n.xyz-n.w);\n}\n\nvec3 bump(vec3 rp, vec3 n) {\n    vec2 e = vec2(EPS, 0.0);\n    float nz = noise(rp);\n    vec3 d = vec3(noise(rp + e.xyy) - nz, noise(rp + e.yxy) - nz, noise(rp + e.yyx) - nz) / e.x;\n    n = normalize(n - d * 0.2 / sqrt(0.1));\n    return n;\n}\n\nfloat spherePattern(vec3 rp, vec3 bc) {\n    rp -= bc;\n    rp.xy *= rot(0.5 * sphereMotion(bc.z));\n    rp.xz *= rot(0.5 * sphereMotion(bc.z + PI * PARTITION_SIZE));\n    rp.yz *= rot(-T * 12.0);\n    rp.xz = abs(rp.xz);  \n    float pattern = step(0.4, rp.x) * step(rp.x, 0.6);\n    pattern *= step(0.3, rp.z);\n    return pattern;\n}\n   \nvec3 march(vec3 ro, vec3 rd) {\n \n    float t = 0.0;\n    float id = 0.0;\n    float li = 0.0;\n    \n    for (int i=ZERO; i<98; i++) {\n        vec3 rp = ro + rd * t;\n        vec3 ns = map(rp);\n        if (abs(ns.x)<EPS) {\n            id = ns.y;\n            break;\n        }\n        \n        li += 0.1/(1.0 + ns.z*ns.z*100.0);\n        \n        vec4 nearSphere = nearestSphere(rp);\n        vec3 srd = normalize(nearSphere.xyz - rp);\n        float st = sphIntersect(rp, srd, vec4(nearSphere.xyz, 0.8));\n        vec3 srp = rp + srd * st;\n\n        li += spherePattern(srp, nearSphere.xyz) * (0.1/(1.0 + st*st*6.0));\n       \n        t += ns.x * 0.8;\n        if (t>FAR) break;\n        \n    }\n    \n    return vec3(t, id, li);\n}\n\nScene drawScene(vec3 ro, vec3 rd) {\n    \n\tfloat mint = FAR;\n    vec3 minn = vec3(0.0);\n    float id = 0.0;\n    \n    vec3 fo = vec3(0.0, -2.4, 0.0);\n    vec3 fn = vec3(0.0, 1.0, 0.0);\n    vec3 co = vec3(0.0, 2.4, 0.0);\n    vec3 cn = vec3(0.0, -1.0, 0.0);\n    \n    float ft = dot(fo - ro,fn)/dot(rd,fn);\n    float ct = dot(co - ro,cn)/dot(rd,cn);\n\n    if (ft > 0.0 && ft < FAR) {\n        mint = ft;\n        minn = fn;\n        id = FLOOR;\n    }\n    \n    if (ct > 0.0 && ct < mint) {\n        mint = ct;\n        minn = cn;\n        id = ROOF;\n    }\n    \n    vec3 st = march(ro, rd);\n    if (st.x > 0.0 && st.x < mint) {\n        mint = st.x;\n        minn = normal(ro + rd * st.x);\n        id = st.y;\n    }\n    \n    return Scene(mint, id, minn, st.z, 0.0, 0.0);\n}\n\nvoid surfaceDetail(vec3 ro, vec3 rd, inout Scene scene) {\n \n    //ray surface intersection\n    vec3 rp = ro + rd * scene.t;\n    \n    if (scene.id == ROOF) {        \n        scene.n = bump((rp + T * 0.4) * 4.0, scene.n);\n    }\n    \n    if (scene.id == SPHERE) {\n        vec4 ns = nearestSphere(rp);\n        if (spherePattern(rp, ns.xyz) > 0.0) {\n            //light\n            scene.em = 1.0;\n        }        \n    }\n    \n    if (scene.id == PILLAR_LIGHT) {   \n        scene.em = 1.0;\n    }\n    \n    if (scene.id == FLOOR || scene.id == ROOF || scene.id == PILLAR) {\n        scene.ref = 0.003;    \n    }\n}\n\nvoid setupCamera(vec2 uv, inout vec3 ro, inout vec3 rd) {\n\n    ro = camPos();\n    vec3 lookAt = ro + vec3(0.0, 0.0 , 6.0);\n    \n    float FOV = PI / 4.0;\n    vec3 forward = normalize(lookAt - ro);\n    vec3 right = normalize(vec3(forward.z, 0.0, -forward.x)); \n    vec3 up = cross(forward, right);\n\n    rd = normalize(forward + FOV * uv.x * right + FOV * uv.y * up);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n    vec3 pc = vec3(0.0);\n\tvec3 gc = glowColour();\n    \n    vec2 uv = (fragCoord.xy - iResolution.xy * 0.5) / iResolution.y;\n\tvec3 ro, rd, roo, rdo;\n    setupCamera(uv, ro, rd);\n\n    roo = ro;\n    rdo = rd;\n    float to = 0.0;\n    float tt = 0.0;\n    float la = 0.0;\n    float ref = 0.0;\n    \n    for (int i=ZERO; i<3; i++) {\n        \n        Scene scene = drawScene(ro, rd);\n\n        tt += scene.t;\n        \n        if (i == 0) to = scene.t;\n        \n        if (scene.id == 0.0) break;\n\n        la += scene.li; \n        \n        surfaceDetail(ro, rd, scene);   \n        \n        if (scene.em == 1.0) {\n            pc = vec3(1.) / (1. + tt * tt * ref); //light\n            break;\n        }\n        \n        //setup for next loop\n        ref += scene.ref;\n        ro = ro + rd * (scene.t - EPS); //pull back from surface\n        rd = reflect(rd, scene.n); //reflect ray direction   \n    }\n    \n    pc += gc * la;\n    \n    gc = mix(gc, gc.xzy, 0.25 - rdo.y * 0.25);\n    pc = mix(gc, pc, 1.0 / (to * to / FAR + 1.0));\n    \n    fragColor = vec4(sqrt(clamp(pc * 1.0, 0.0, 1.0)), 1.0);\n}","name":"Image","description":"","type":"image"}]}