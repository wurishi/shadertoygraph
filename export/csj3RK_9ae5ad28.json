{"ver":"0.1","info":{"id":"csj3RK","date":"1667885007","viewed":144,"name":"TensorPatterns","username":"Boogaloo","description":"A system for RGB tensor automata, inspired by NeuralPatterns.io","likes":4,"published":1,"flags":32,"usePreview":0,"tags":["automata","cellular","tensor"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n       \n\tfragColor = texture(iChannel0, uv);;\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XdXGzn","filepath":"/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","previewfilepath":"/media/ap/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"mat3 mats[9];\n\nfloat cutit(float inp){\nreturn clamp(inp, 0., 1.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n//The configuration tensor (change these values for different patterns):\nmats[0] = mat3(-0.7400355862573462, 0.09195941356421322, 0.20832079579789742, -0.9493322706528842, -0.9353269300557103, -0.4512439088043181, 0.22181087265816135, -0.4207003180523756, -0.7096349107496656);\nmats[1] = mat3(-0.3593630771690748, 0.847880976810603, 0.15207915243869996, -0.34002177586212734, -0.829924457668904, -0.6961793725248837, -0.5534435216927556, -0.6174522396565092, -0.4115926561809944);\nmats[2] = mat3(0.9419359424547409, 0.3461395032800114, 0.8830595226904494, 0.4296418886333082, 0.7340652849072962, -0.4504949597583925, -0.7414375029802158, -0.7748727322122373, 0.22701370737996274);\nmats[3] = mat3(-0.8217733005588657, 0.9815975659031582, -0.48368504678811, -0.06374782731460926, -0.6397804083069729, -0.844797194120227, 0.8192021351962899, 0.9596809061706919, 0.2841798024186939);\nmats[4] = mat3(0.9694591675354609, -0.3071436508322456, 0.9702094347461689, -0.1997245196554145, -0.08225788625205688, -0.5742453598006474, 0.6853587754894899, 0.28492349700453046, 0.8015498432413319);\nmats[5] = mat3(-0.7225008086790854, -0.5859556128349177, 0.19256424774971803, -0.4140199273204752, 0.699797917120099, 0.34515195120241526, -0.5150739401466771, 0.763631905020983, -0.49057207202436115);\nmats[6] = mat3(-0.13052935773000285, -0.04165289330515787, 0.04291093547807989, -0.40277368970114025, 0.41600218991297266, -0.6176976088347224, -0.10257900431631128, -0.5690171289142514, -0.9643831855574765);\nmats[7] = mat3(0.31736083232571355, -0.20367377150290067, -0.6535641790878475, 0.27948008545614367, 0.4983753597806333, -0.21872657206931168, -0.5805997742615678, -0.20337093768015135, -0.2512122137600563);\nmats[8] = mat3(-0.5363351499808982, 0.5733872854808937, 0.5145267556686419, 0.5345075273404136, 0.4867769087339844, -0.49909924809332074, 0.2683803554093509, -0.5290976931618221, -0.9695775515435574);\n    \n    vec2 uv = fragCoord.xy / iResolution.xy;\n\n    vec3 rtot = vec3(0.,0.,0.);\n    \n    int ind = 0;\n    \n    \n//the convolution kernel is just the Moore neighborhood of a given cell\n//take the RGB values as vectors and apply a matrix transform specified via the configuration tensor, then sum\n    for(float i = -1.0; i <= 1.0; i += 1.0)\n    {\n        for( float j = -1.0; j <= 1.0; j += 1.0)\n        {\n        \tvec2 offset = vec2(i, j) / iResolution.xy;\t\t \n        \trtot += mats[ind]*texture(iChannel0, uv + offset).rgb;\n            ind++;\n        }\n    }\n    \n//inverse Gaussian activation function    \n    vec3 rfin = vec3(cutit(-1./pow(2., (pow(rtot.x, 2.)))+1.), cutit(-1./pow(2., (pow(rtot.y, 2.)))+1.), cutit(-1./pow(2., (pow(rtot.z, 2.)))+1.));\n \n//initialize random colors for each cell    \n    if(iFrame < 10) { \n        rfin = vec3(texture(iChannel1, fragCoord.xy / iResolution.xx));\n    }\n\n//paint on pixels manually with the mouse\n    if(iMouse.z > 0.0 && abs(fragCoord.x-iMouse.x)<1.0 && abs(fragCoord.y-iMouse.y)<1.0){\n    rfin = vec3(1.0,1.0,1.0);\n    }\n    \n    \n    \n    fragColor = vec4(rfin,1.0);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"//anti-flicker buffer\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;    \n    vec4 col1 = texture(iChannel0, uv);\n    vec4 col2 = texture(iChannel1, uv);\n    fragColor = (col1+col2)*.55;\n}","name":"Buffer B","description":"","type":"buffer"}]}