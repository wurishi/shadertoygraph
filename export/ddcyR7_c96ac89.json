{"ver":"0.1","info":{"id":"ddcyR7","date":"1694857790","viewed":41,"name":"Raymarched Terrain (noise)","username":"pugly","description":"figured out how to do materials & shadows :>\nthere is something weird going on with the shadows of the terrain being circles at some points in time, perhaps it's my noise algorithm?\nalso some really basic AA, there's gotta be a better way though","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["terrain","raymarch"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.1415926\n#define AA 1\n\nconst vec3 CAMERA_POS = vec3(3.,0.5,0.);\nconst float FOCAL_LENGTH = 1.2;\n\nfloat random(in vec2 p) {\n    return fract(sin(dot(p, vec2(12.23245, 78.4672))) * 42342.87592);\n}\n\nfloat noise(in vec2 p) {\n\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n    \n    float a = random(i);\n    float b = random(i + vec2(1., 0.));\n    float c = random(i + vec2(0., 1.));\n    float d = random(i + vec2(1., 1.));\n    \n    vec2 u = smoothstep(0., 1., f);\n    \n    return mix(a, b, u.x) +\n        (c - a) * u.y * (1.0-u.x) +\n        (d - b) * u.x * u.y;\n}\n\nmat2 rot(in float a) {\n    float s = sin(a),\n          c = cos(a);\n    return mat2(c,-s,s,c);\n}\n\nfloat sdSphere(in vec3 p, in float r) {\n    return length(p) - r;\n}\n\nvec4 map(in vec3 p) {\n    \n    vec4 o = vec4(p.y + noise(p.xz)+1., vec3(floor(2.*fract(p.x*10.))*floor(2.*fract(p.z*10.)),0.322,0.114));\n    vec4 s = vec4(sdSphere(p + vec3(0.,0.2, 1.), .6), vec3(.7,0.027,0.027));\n    if (o.x > s.x) o = s;\n    \n    s = vec4(sdSphere(p + vec3(0.,0.1, 0.), .3), vec3(0.286,0.333,0.671));\n    if (o.x > s.x) o = s;\n    \n    return o;\n}\n\nvec4 intersect(in vec3 ro, in vec3 rd) {\n\n    vec4 h = vec4(1.);\n    \n    float t = 0.,\n          maxd = 20.;\n          \n    for (int i = 0; i < 40; i++) {\n        if (t > maxd || h.x < .001) break;\n        \n        t += h.x;\n        h = map(ro + rd*t);\n    }\n    \n    if (t > maxd) t = -1.;\n    return vec4(t, h.yzw);\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n    vec3 eps = vec3(0.0002,0.0,0.0);\n\n\treturn normalize( vec3(\n           map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n           map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n           map(pos+eps.yyx).x - map(pos-eps.yyx).x ) );\n}\n\nvec3 light(in vec3 p, in vec3 mat, in vec3 sunDir) {\n    vec3 l = vec3(0.);\n    \n    vec3 n = calcNormal(p);\n    \n    //sun\n    float sun = clamp(dot(n, sunDir), 0., 1.);\n    float sh = -intersect(p + n*0.0002, sunDir).x; \n    l = mat * vec3(1.000,0.961,0.541) * sun * clamp(sh,0.,1.);\n    \n    //sky\n    float sky = clamp(0.5 + 0.5 * dot(n, vec3(0.,1.,0.)), 0., 1.);\n    l += mat * vec3(0.494,0.839,0.969) * sky;\n    \n    return l;\n}\n\nvec4 render(in vec3 ro, in vec3 rd, in vec2 p) {\n\n    vec3 final = vec3(0.);\n    \n    vec3 sunDir = normalize(vec3(cos(iTime),.4,sin(iTime)));\n    \n    vec4 t = intersect(ro, rd);\n    \n    // background sky\n    float sun = clamp( dot (rd, sunDir), 0., 1.);\n\n    final = vec3(0.494,0.839,0.969) - rd.y*0.4*vec3(0.063,0.227,0.557) + 0.12*0.5;\n    final += 0.2*vec3(1.000,0.584,0.078)*pow( sun, 5.0 ); \n    final += 0.3*vec3(1.000,0.925,0.102)*pow( sun, 60.0 ); \n    \n    if (t.x > 0.) {\n        vec3 p = ro + rd*t.x;\n        final = light(p, t.yzw, sunDir);\n    } else {\n\n    }\n\n    return vec4(final, 1.);\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec4 col = vec4(0);\n    vec2 st = (2.*fragCoord.xy - iResolution.xy) / iResolution.y;\n    vec2 mouse = (2.*iMouse.xy - iResolution.xy) / iResolution.y;\n    \n    vec3 ro = CAMERA_POS;\n    ro.x += mouse.y*3.;\n    \n    //anti aliasing, grabs four corners\n    #if AA == 1\n    vec2 off = 4./iResolution.xy;\n    vec3 rd = normalize(vec3(st - vec2(off.x,off.y+.2), FOCAL_LENGTH));\n    rd.xz *=  rot(-2.*mouse.x * PI / 2. - PI);\n    col += render(ro, rd, st);\n    col /= 2.;\n    \n    rd = normalize(vec3(st - vec2(off.x+2./iResolution.x,off.y+.2), FOCAL_LENGTH));\n    rd.xz *=  rot(-2.*mouse.x * PI / 2. - PI);\n    col += render(ro, rd, st);\n    col /= 2.;\n    \n    rd = normalize(vec3(st - vec2(off.x,2./iResolution.y + off.y+.2), FOCAL_LENGTH));\n    rd.xz *=  rot(-2.*mouse.x * PI / 2. - PI);\n    col += render(ro, rd, st);\n    col /= 2.;\n    \n    rd = normalize(vec3(st - vec2(off.x+2./iResolution.x,2./iResolution.y + off.y+.2), FOCAL_LENGTH));\n    rd.xz *=  rot(-2.*mouse.x * PI / 2. - PI);\n    col += render(ro, rd, st);\n    col /= 2.;\n    //no anti aliasing\n    #else\n    vec3 rd = normalize(vec3(st - vec2(0.,.2), FOCAL_LENGTH));\n    rd.xz *=  rot(-2.*mouse.x * PI / 2. - PI);\n    col = render(ro, rd, st);\n    #endif\n    \n    col = (col - vec4(.5)) * 1.2 + 0.2 + .2;\n    fragColor = pow(col, vec4(1./1.4));\n}","name":"Image","description":"","type":"image"}]}