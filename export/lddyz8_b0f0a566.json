{"ver":"0.1","info":{"id":"lddyz8","date":"1518140931","viewed":79,"name":"HW3 Paw Metaballs","username":"ChloeSnyder","description":"HW3","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["hw3"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14159265359\n#define deg2rad PI / 180.0\n\nconst int MAX_MARCHING_STEPS = 300;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float EPSILON = 0.0001;\n\n// iq\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat sphereSDF(vec3 samplePoint) {\n    return length(samplePoint) - 1.0;\n}\n\n// modified from jamie wong\nvec3 scaleOp(vec3 samplePoint, vec3 scale)\n{\n\treturn (samplePoint / scale);\n}\n\nfloat metaball(float angle, vec3 p, float amplitude)\n{\n    // body of paw pad\n    float blob_x = sin(angle) * cos(2.0*float(iTime) + angle) * amplitude;\n    float blob_y = cos(angle) * cos(2.0*float(iTime) + angle) * amplitude;\n    //paw prints are spheres rotating in a circle\n    float offsetX = (amplitude * .4) * sin(angle);\n    float offsetY = (amplitude * .4) * cos(angle);\n    //calculate displacement for point\n    float x = blob_x + offsetX;\n    float y = blob_y + offsetY;\n    p += vec3(x, y, 0.0);\n    p = scaleOp(p, vec3(.09, .09, .09));\n    return sphereSDF(p) * .09;\n}\n\n\nfloat sceneSDF(vec3 samplePoint) {\n    float dist = MAX_DIST;\n    int numBalls = 7;\n    for (int i = 0; i < numBalls; i++) {\n        float amplitude = 0.4;\n        float angle = float(i) * 360.0 / float(numBalls) * deg2rad;\n        float metaball = metaball(angle, scaleOp(samplePoint, vec3(1.5, 1.5, 1.5)), amplitude);\n        dist = smin(dist, metaball, 0.15);\n    }\n    return dist-.01;\n}\n\n// Jamie wong\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < EPSILON) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n            \n// Jamie Wong\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 dir = rayDirection(45.0, iResolution.xy, fragCoord);\n    vec3 eye = vec3(0.0, 0.0, 5.0);\n    float dist = shortestDistanceToSurface(eye, dir, MIN_DIST, MAX_DIST);\n    \n    \n    if (dist > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n        fragColor = vec4(1.0, 1.0, 1.0, 1.0);\n\t\treturn;\n    }\n    \n    fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n}","name":"Image","description":"","type":"image"}]}