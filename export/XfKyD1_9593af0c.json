{"ver":"0.1","info":{"id":"XfKyD1","date":"1731805927","viewed":134,"name":"Crystal Tunnel","username":"Nekodigi","description":"The crystal grows, forms veins, then shatters.\nInspired by this work, created one with more transient animation and pale coloring.\n","likes":17,"published":1,"flags":0,"usePreview":1,"tags":["voronoi","tunnel","camera","fog","vignette","dissolve","crystal"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","previewfilepath":"/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Based on https://www.shadertoy.com/view/MscSDB\n//Feedback\n\n//* Fog relatively easy to test.\n\n\n//! Surface too flatP\n//? Particle? Fog?\n//! Focus to important point. \n//? The tip light? Directional Blur\n//! Post Processing\n//? Bloom. Motion Blur\n//* Not Nessesary but suggestion comes below\n//! Gradient sky to give direction > Brushed Metal\n//! Guidance path > Light Columns > Flying into Ditigal World\n//! Rock texture with > Sphere FBM\n//! Move light in XY direction\n//! 3D noise color & size jitter\n//! DoF for near object\n//! Kuwahara\n//! Spiral texture | offset of value > https://www.shadertoy.com/view/4d3Gzn\n\n//! Overwrap object unclear\n//? Star? Fog? > Full Scene Radial Blur > Chinese Ink-wash Painting\n//! Give impression of depth\n//! Paper like texture? * Lamp like texture with shadow\n//! Edge detection was good but noisy\n//? https://www.shadertoy.com/view/4dfGzs\n//! Realistic Reflection *Shadow for now\n//? https://www.shadertoy.com/view/Xds3zN\n//! Motion Blur * expensive\n//! Dynamic Movement. * Z axis more tilt\n//? Smoothstep ?Transform\n//! Need antialias\n//! Voronoi cell distorted\n//! Don't leave empty black background.\n//! Add more detail\n//? Funnel\n\n//* References\n//Outline/Color/Camera : Cellular Tiled Tunnel(https://www.shadertoy.com/view/MscSDB)\n//Fog : Outline 2020 Freestyle Live code(https://www.shadertoy.com/view/tsBBzG)\n//Shadow : Soft Shadow Variation(https://www.shadertoy.com/view/lsKcDD)\n//Color Correction : Echeveria II(https://www.shadertoy.com/view/WtGXWm)\n\n\n\n#define FOG_D 0.04\n#define SKY_COL vec3(0.027,0.349,0.522)//vec3(0.231,0.51,0.965)\n#define FOG_COL vec3(0.49,0.827,0.988)\n\nvec3 camPos;\n#define PI 3.14159265358979\n#define FAR 50. // Maximum allowable ray distance.\n#define ZERO (min(iFrame,0))\n\n// 2x2 matrix rotation.\nmat2 rot2(float a){\n    \n    float c = cos(a); float s = sin(a);\n\treturn mat2(c, s, -s, c);\n}\n\nfloat drawSphere(in vec3 p){   \n    p = fract(p)-.5;    \n    \n    return dot(p, p);\n}\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat cellTile(in vec3 p){\n    \n    // Draw four overlapping objects (spheres, in this case) at various positions throughout the tile.\n    vec4 v, d; \n    d.x = drawSphere(p - vec3(.81, .62, .53));\n    p.xy = vec2(p.y-p.x, p.y + p.x)*.7071;\n    d.y = drawSphere(p - vec3(.39, .2, .11));\n    p.yz = vec2(p.z-p.y, p.z + p.y)*.7071;\n    d.z = drawSphere(p - vec3(.62, .24, .06));\n    p.xz = vec2(p.z-p.x, p.z + p.x)*.7071;\n    d.w = drawSphere(p - vec3(.2, .82, .64));\n\n    v.xy = min(d.xz, d.yw), v.z = min(max(d.x, d.y), max(d.z, d.w)), v.w = max(v.x, v.y); \n   \n    d.x =  min(v.z, v.w) - min(v.x, v.y); // Maximum minus second order, for that beveled Voronoi look. Range [0, 1].\n    //d.x =  min(v.x, v.y);\n        \n    return (d.x*2.66); // Normalize... roughly.\n}\nint cellTileID(in vec3 p){\n    \n    int cellID = 0;\n    \n    // Storage for the closest distance metric, second closest and the current\n    // distance for comparisson testing.\n    vec3 d = (vec3(.75)); // Set the maximum.\n    \n    // Draw some overlapping objects (spheres, in this case) at various positions on the tile.\n    // Then do the fist and second order distance checks. Very simple.\n    d.z = drawSphere(p - vec3(.81, .62, .53)); if(d.z<d.x) cellID = 1;\n    d.y = max(d.x, min(d.y, d.z)); d.x = min(d.x, d.z);\n    \n    p.xy = vec2(p.y-p.x, p.y + p.x)*.7071;\n    d.z = drawSphere(p - vec3(.39, .2, .11)); if(d.z<d.x) cellID = 2;\n    d.y = max(d.x, min(d.y, d.z)); d.x = min(d.x, d.z);\n    \n    \n    p.yz = vec2(p.z-p.y, p.z + p.y)*.7071;\n    d.z = drawSphere(p - vec3(.62, .24, .06)); if(d.z<d.x) cellID = 3;\n    d.y = max(d.x, min(d.y, d.z)); d.x = min(d.x, d.z);\n   \n    p.xz = vec2(p.z-p.x, p.z + p.x)*.7071; \n    d.z = drawSphere(p - vec3(.2, .82, .64)); if(d.z<d.x) cellID = 4;\n    d.y = max(d.x, min(d.y, d.z)); d.x = min(d.x, d.z);\n    return cellID;\n    \n}\n// The path is a 2D sinusoid that varies over time, depending upon the frequencies, and amplitudes.\nvec2 path(in float z){ float s = sin(z/24.)*cos(z/16.); float s2 = sin(z/47.)*cos(z/31.); return vec2(s*9., s2*18.); }\n\nfloat map(vec3 p){\n    p.xy -= path(p.z);\n    float rz = p.z - camPos.z;//relative z\n    float celld = cellTile(p/2.5); // The tunnel surface.\n    //tube\n    //float ind = - 1.0+ length(p.xy);\n    //float outd = -1.2 + length(p.xy);\n    float start = 40.;\n    float rzs = clamp(start-rz, 0., start);\n    float scale = rzs/start*2.;\n    float ind = sdBox(p.xy, vec2(1.0, 1.0)*scale);\n    float outd = sdBox(p.xy, vec2(1.2, 1.2)*scale);\n    float d = max(-ind, outd);\n    d-=celld;//add voronoi cell bump to wall\n    float dissolve = max(rzs, 0.);//how far dissolve start, how fast dissolve progress\n    d += pow(dissolve*0.025, 4.);\n    //d += dissolve;\n    return d;\n\n}\n\n\n// Basic raymarcher.\nvec2 trace(in vec3 ro, in vec3 rd){\n\n    float t = 0.0, h;\n    float iter = 0.;\n    for(int i = 0; i < 96; i++){\n        h = map(ro+rd*t);\n        // Note the \"t*b + a\" addition. Basically, we're putting less emphasis on accuracy, as\n        // \"t\" increases. It's a cheap trick that works in most situations... Not all, though.\n        if(abs(h)<0.002*(t*.125 + 1.) || t>FAR) break; // Alternative: 0.001*max(t*.25, 1.)\n        t += h*.8;\n        iter += FOG_D;\n        iter *= 0.97;\n    }\n\n    return vec2(min(t, FAR), iter);\n    \n}\n\nvec3 calcNormal(in vec3 p){\n\n    // Note the slightly increased sampling distance, to alleviate artifacts due to hit point inaccuracies.\n    vec2 e = vec2(0.0025, -0.0025); \n    return normalize(e.xyy * map(p + e.xyy) + e.yyx * map(p + e.yyx) + e.yxy * map(p + e.yxy) + e.xxx * map(p + e.xxx));\n}\nfloat calculateAO( in vec3 p, in vec3 n )\n{\n\tfloat ao = 0.0, l;\n    const float maxDist = 2.;\n\tconst float nbIte = 6.0;\n\t//const float falloff = 0.9;\n    for( float i=1.; i< nbIte+.5; i++ ){\n    \n        l = (i*.75 + fract(cos(i)*45758.5453)*.25)/nbIte*maxDist;\n        \n        ao += (l - map( p + n*l ))/(1.+ l);// / pow(1.+l, falloff);\n    }\n\t\n    return clamp(1.- ao/nbIte, 0., 1.);\n}\n// https://iquilezles.org/articles/rmshadows\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n    // bounding volume\n    float tp = (0.8-ro.y)/rd.y; if( tp>0.0 ) tmax = min( tmax, tp );\n\n    float res = 1.0;\n    float t = mint;\n    for( int i=ZERO; i<24; i++ )\n    {\n\t\tfloat h = map( ro + rd*t );\n        float s = clamp(8.0*h/t,0.0,1.0);\n        res = min( res, s );\n        t += clamp( h, 0.01, 0.2 );\n        if( res<0.004 || t>tmax ) break;\n    }\n    res = clamp( res, 0.0, 1.0 );\n    return res*res*(3.0-2.0*res);\n}\n\nfloat curve(in vec3 p, in float w){\n\n    vec2 e = vec2(-1., 1.)*w;\n    \n    float t1 = map(p + e.yxx), t2 = map(p + e.xxy);\n    float t3 = map(p + e.xyx), t4 = map(p + e.yyy);\n    \n    return 0.125/(w*w) *(t1 + t2 + t3 + t4 - 4.*map(p));\n}\nvec3 sss( float ndl, float ir )\n{\n    float pndl = clamp( ndl, 0.0, 1.0 );\n    float nndl = clamp(-ndl, 0.0, 1.0 );\n\n    return vec3(pndl) + \n#ifndef SIMPLE_APPROX\n           vec3(1.0, 1.0, 1.0)*0.2*(1.0-pndl)*(1.0-pndl)*pow(1.0-nndl,3.0/(ir+0.001))*clamp(ir-0.04,0.0,1.0);\n#else\n           vec3(1.0, 1.0, 1.0)*0.7*pow(clamp(ir*0.75-nndl,0.0,1.0),2.0);\n#endif\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\t\n\n\t// Screen coordinates.\n\tvec2 uv = (fragCoord - iResolution.xy*0.5)/iResolution.y;\n\t\n\t// Camera Setup.\n\tvec3 lookAt = vec3(0.0, 0.0, iTime*6.);  // \"Look At\" position.\n\tcamPos = lookAt + vec3(0.0, 0.1, -0.5); // Camera position, doubling as the ray origin.\n    // Light positioning. One is a little behind the camera, and the other is further down the tunnel.\n \tvec3 light_pos = camPos + vec3(0.0, 0.125, 4.125);// Put it a bit in front of the camera.\n\tvec3 light_pos2 = camPos + vec3(0.0, 0.0, 8.0);// Put it a bit in front of the camera\n\tlookAt.xy += path(lookAt.z);\n\tcamPos.xy += path(camPos.z);\n\tlight_pos.xy += path(light_pos.z);\n\tlight_pos2.xy += path(light_pos2.z);\n\n    // Using the above to produce the unit ray-direction vector.\n    float FOV = PI/3.; // FOV - Field of view.\n    vec3 forward = normalize(lookAt-camPos);\n    vec3 right = normalize(vec3(forward.z, 0., -forward.x )); \n    vec3 up = cross(forward, right);\n    // rd - Ray direction.\n    vec3 rd = normalize(forward + FOV*uv.x*right + FOV*uv.y*up);\n    // Swiveling the camera from left to right when turning corners.\n    rd.xy = rot2( path(lookAt.z).x/16. )*rd.xy;\n    // Standard ray marching routine.\n    vec2 tr = trace(camPos, rd);\n    float t = tr.x;\n    // The final scene color. Initated to black.\n\tvec3 sceneCol = SKY_COL;\n\t\n\t// The ray has effectively hit the surface, so light it up.\n\tif(t < FAR){\n\t\n    \t\n    \t// Surface position and surface normal.\n\t    vec3 sp = t * rd+camPos;\n\t    vec3 sn = calcNormal(sp);\n        // Texture scale factor.\n        const float tSize0 = 1./1.; \n\t    \n\t    // Ambient occlusion.\n\t    float ao = calculateAO(sp, sn);\n    \t\n    \t// Light direction vectors.\n\t    vec3 ld = light_pos-sp;\n\t    vec3 ld2 = light_pos2-sp;\n        vec3 ld3 = up;\n        // vec3 lc = vec3(0.976,0.451,0.086);\n        // vec3 lc2 = vec3(0.918,0.702,0.031);\n        // vec3 lc3 = vec3(0.055,0.647,0.914);\n        vec3 lc = vec3(1., 0., 0.);\n        vec3 lc2 = vec3(0., 1., 0.);\n        vec3 lc3 = vec3(0., 0., 1.);\n\n        // Distance from respective lights to the surface point.\n\t    float lDdist = max(length(ld), 0.001);\n\t    float lDdist2 = max(length(ld2), 0.001);\n    \t\n    \t// Normalize the light direction vectors.\n\t    ld /= lDdist;\n\t    ld2 /= lDdist2;\n\t    float atten = 1./(1. + lDdist*.125 + lDdist*lDdist*.05);\n        float atten2 =  1./(1. + lDdist2*.125 + lDdist2*lDdist2*.05);\n    \t// Ambient light.\n\t    vec3 ambience = vec3(0.2);\n\n    \t// Diffuse lighting.\n\t    float diff = max( dot(sn, ld), 0.0);\n\t    float diff2 = max( dot(sn, ld2), 0.0);\n        float diff3 = max( dot(sn, ld3), 0.0);\n    \t// Specular lighting.\n\t    float spec = pow(max( dot( reflect(-ld, sn), -rd ), 0.0 ), 32.);\n\t    float spec2 = pow(max( dot( reflect(-ld2, sn), -rd ), 0.0 ), 32.);\n    \t// Curvature.\n\t    float crv = clamp(curve(sp, 0.125)*0.5+0.5, .0, 1.);\n\t    // Fresnel term. Good for giving a surface a bit of a reflective glow.\n        float fre = pow( clamp(dot(sn, rd) + 1., .0, 1.), 4.);\n        \n        vec3 texCol_ = vec3(1.);//tex3D(iChannel0, sp*tSize0, sn);\n        vec3 spp = sp;\n        spp.xy -= path(spp.z);\n        int id = cellTileID(spp/2.5);\n        if(id == 1) texCol_ = vec3(0.506,0.549,0.973);\n        if(id == 2) texCol_ = vec3(0.263,0.22,0.792);\n        if(id == 3) texCol_ = vec3(0.118,0.106,0.294);\n        if(id == 4) texCol_ = vec3(0.78,0.824,0.996);\n        //vec3 texCol = sss(dot(sn, ld), crv)*texCol_;\n        //texCol += sss(dot(sn, ld2), crv)*texCol_;\n        vec3 texCol = texCol_;\n        // Darkening the crevices. Otherwise known as cheap, scientifically-incorrect shadowing.\t\n\t    float shading =  crv*0.75+0.25; \n        float shadow = calcSoftshadow(sp, ld, 0.02, 0.8);\n        float shadow2 = calcSoftshadow(sp, ld2, 0.02, 0.8);\n        float shadow3 = calcSoftshadow(sp, ld3, 0.02, 2.5);\n\n        diff *= shadow;\n        diff2 *= shadow2;\n        diff3 *= shadow3;\n        // Shiny.\n        sceneCol = texCol * ambience;\n        sceneCol += (texCol*(diff + spec)*lc)*atten;\n        sceneCol += (texCol*(diff2 + spec2)*lc2)*atten2;\n        sceneCol += (texCol*(diff3)*lc3);\n        sceneCol += fre*0.2;\n        // Shading.\n        sceneCol *= ao*(2.-shading*0.5);\n\n        \n        // Drawing the lines on the surface.  \n        float edge = (curve(sp, 0.03)-5.)*1.; //reduce noise by subtraction\n        sceneCol = edge > 0. ? vec3(0.3451, 0.3451, 0.3451) * sceneCol : sceneCol;   \n        //sceneCol *= -clamp(abs(curve(sp, 0.01)), .0, 1.)*.9 + 1.;  //  lines.\n        //sceneCol *= 1. - smoothstep(0., 4., abs(curve(sp, 0.0125)))*vec3(.82, .85, .88); // Darker.\n\t}\n    float fog = pow(tr.y, 3.);\n    sceneCol = sceneCol*(1.-fog*0.5)+FOG_COL*fog;\n    //gamma\n    sceneCol = pow( sceneCol, vec3(0.4545) );\n\n    vec2 uv2 = fragCoord.xy / iResolution.xy;\n    uv2 *=  1.0 - uv2.yx;   //vec2(1.0)- uv.yx; -> 1.-u.yx; Thanks FabriceNeyret !\n    float vig = uv2.x*uv2.y * 15.0; // multiply with sth for intensity\n    vig = pow(vig, 0.25); // change pow for modifying the extend of the  vignette\n    sceneCol *= vig;\n\tfragColor = vec4(sqrt(clamp(sceneCol, 0., 1.)), 1.0);\n}","name":"Image","description":"","type":"image"}]}