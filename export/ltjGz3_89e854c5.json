{"ver":"0.1","info":{"id":"ltjGz3","date":"1431067304","viewed":159,"name":"Nat's Mandelbrot Set","username":"NattyBumppo","description":"A simple implementation of a Mandelbrot set","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["fractal"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[],"code":"const int iterations = 30;\nconst float largeNumber = 10000.0;\nconst float supersampleDivisions = 2.0;\n\n// Takes a complex number and takes it through one more iteration\n// of the Mandelbrot equation\nvec2 iterate(vec2 zn, vec2 c)\n{\n    // Break down into real and imaginary parts and perform the necessary\n    // math, then reassemble\n    float znReal = zn[0];\n    float znImag = zn[1];\n    \n    vec2 znext;\n    \n    // Real part of zn*zn + c\n    znext[0] = znReal * znReal - znImag * znImag + c[0];\n    // Imaginary part of zn*zn + c\n    znext[1] = 2.0 * znReal * znImag + c[1];\n    \n    return znext;\n}\n\nbool checkConvergence(vec2 c)\n{\n    // zn will be the current iteration's value for\n    // the Mandelbrot equation, but its first value\n    // is zero\n    vec2 zn = vec2(0.0, 0.0);\n    for (int i = 0; i < iterations; i++)\n    {\n    \tzn = iterate(zn, c);\n    }\n    \n    if (length(zn) < largeNumber)\n    {\n        return true;\n    }\n    else\n    {\n     \treturn false;   \n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    // We'll accumulate color as we go... we'll go from blue to black\n    fragColor = vec4(0.0, 0.0, 1.0, 1.0);\n    \n    // We're going to antialias this point, so we'll actually super-sample around it\n    for (float xIncrement = 0.0; xIncrement < 1.0; xIncrement += 1.0/supersampleDivisions)\n    {\n        for (float yIncrement = 0.0; yIncrement < 1.0; yIncrement += 1.0/supersampleDivisions)\n        {\n            float x = fragCoord.x - 0.5 + xIncrement;\n            float y = fragCoord.y - 0.5 + yIncrement;\n            \n            // The complex number for this point will really just be our\n            // x and y coordinates, scaled down to -2 to 2 (then rescaled to be square)\n            vec2 c = (vec2(x, y) / iResolution.xy) * 4.0 - 2.0;\n            c = vec2(c[0], c[1]*(iResolution.y/iResolution.x));\n            // Apply offset from where the mouse is positioned\n            c = (vec2(c[0], c[1]));       \n            \n            // Check if iterating this pixel causes it to converge or diverge\n            bool converges = checkConvergence(c);\n\n            if (converges)\n            {\n                float colorIncrement = 1.0/(supersampleDivisions*supersampleDivisions);\n                fragColor += vec4(0.0, 0.0, -colorIncrement, 1.0);\n            }\n        }\n    }\n    \n}","name":"","description":"","type":"image"}]}