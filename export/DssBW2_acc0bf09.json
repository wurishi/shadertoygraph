{"ver":"0.1","info":{"id":"DssBW2","date":"1689184871","viewed":81,"name":"Dipole Winding Number Field","username":"chronos","description":"Trying to visualize the winding number field of dipole points. See code for reference paper.\nGreen: positive\nRed: Negative\nWhite: iso-surface","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["number","field","dipole","winding"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Reference: \n/*\nFast Winding Numbers for Soups and Clouds\nGAVIN BARILL, NEIL G. DICKSON, RYAN SCHMIDT, DAVID I.W. LEVIN and ALEC JACOBSON\nhttps://www.dgp.toronto.edu/projects/fast-winding-numbers/fast-winding-numbers-for-soups-and-clouds-siggraph-2018-barill-et-al.pdf\n*/\n\nconst float GAMMA = 2.2;\nconst float PI = 3.14159265359;\n\nstruct point\n{\n    vec2 position;\n    vec2 normal;   // dipole direction\n    float area;    // represented surface area \n};\n\nfloat winding(vec2 query, point p)\n{\n    // 3D greens function:  -1 / (4. * PI * r), where r = distance(query, point_position)\n    float r = distance(p.position, query);\n    return p.area * dot(p.position - query, p.normal) / (4. * PI * pow(r, 3.));\n}\n\n/*\n// attempt to write a 2D version, didn't really work...\nfloat winding(vec2 query, point p)\n{\n    // 2D greens function: log(r) / (2. * PI), where r = sqrt(x^2 + y^2)\n    // Gradient: (x, y) / (x^2 + y^2)\n    vec2 offset = p.position - query;\n    return p.area * dot(offset, p.normal) / dot(offset, offset);\n}\n*/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.*fragCoord - iResolution.xy) / iResolution.y;\n\n    vec2 query = uv;\n        \n    const float num_points = 10.;\n\n    float winding_number = 0.;\n    \n    for(float i = 0.; i < num_points; ++i)\n    {\n        float radius = 0.5;\n    \n        point p;\n        float angle = (i / num_points) * 2. * PI;\n        p.position = radius * vec2(cos(angle), sin(angle));\n        p.normal = normalize(p.position);                   // Outward pointing normals\n        p.area = (1. / num_points) * 2. * PI * radius;      // perimeter of circle by number of segments, in place of surface area.\n        winding_number += winding(query, p);\n    }\n    \n    float level = 0.5; // See page 7, figure 8 of paper\n    float eps = 0.2;   // arbitrary small-ish number\n    float iso = smoothstep(level-eps, level, winding_number) * smoothstep(level+eps, level, winding_number);\n    \n    // Sigmoid to remap [-inf, inf] to [-1, 1]\n    winding_number = tanh(winding_number);\n    \n    vec3 color = max(vec3(-winding_number, winding_number, 1.-abs(winding_number)), 0.);\n\n    color = mix(color, vec3(1), iso);\n\n    fragColor = vec4(pow(color, vec3(1./GAMMA)),1.0);\n}","name":"Image","description":"","type":"image"}]}