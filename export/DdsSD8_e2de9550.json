{"ver":"0.1","info":{"id":"DdsSD8","date":"1668811208","viewed":264,"name":"[phreax] deep meditation","username":"phreax","description":"Based on my previous experiment:\n\nhttps://shadertoy.com/view/dssSRn\n\nGreat write up here: https://www.osar.fr/notes/logspherical/","likes":31,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","fractal","neon","sacredgeometry","logpolar","graphicdesign"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/* Creative Commons Licence Attribution-NonCommercial-ShareAlike \n   phreax 2022\n*/\n\n#define PI 3.141592\n#define TAU \t(PI * 2.0)\n#define HEX_COS (0.86602540378443 * 0.5)\n#define HEX_TAN (0.57735026918962 * 0.5)\n#define SIN(x) (sin(x)*.5+.5)\n\n#define LINE_WIDTH 0.0001\n#define MESH_DENSITY 90.\n#define LAYER_DISTANCE 6.5\n#define hue(v) ( .6 + .6 * cos( 6.3*(v) + vec3(0,23,21) ) )\n\n\nfloat tt, g_mat, bd;\nvec3 ro;\n\nmat2 rot2(float a) { return mat2(cos(a), sin(a), -sin(a), cos(a)); }\n\nfloat dHex(vec2 p) {\n    p = abs(p);\n    float c = dot(p, normalize(vec2(1, 1.73)));\n    return max(c, p.x);\n}\n\n// from the book of shaders\nfloat dTri(vec2 p) {\n\n  float a = atan(p.x,p.y)+PI;\n  float r = TAU/float(3);\n\n  // Shaping function that modulate the distance\n  float d = cos(floor(.5+a/r)*r-a)*length(p);\n  return d;\n}\n\nfloat hexRing(vec2 p, float r, float s, float blur) {\n    float d = dHex(p) - r ;\n    float c = 1.-smoothstep(0., s, abs(d)-blur);\n    return c;\n}\n\nfloat triRing(vec2 p, float r, float s, float blur) {\n\n    float d = dTri(p) - r ;\n    float c = 1.-smoothstep(0., s, abs(d)-blur);\n    return c;\n}\n\nfloat ring(vec2 p, float r, float s, float blur) {\n\n    float d = length(p) - r ;\n    float c = 1.-smoothstep(0., s, abs(d)-blur);\n    return c;\n}\n\n\nvec2 pmod(vec2 pos, float num, out float id)\n{\n    float angle = atan(pos.x, pos.y) + PI / num;\n    float split = TAU / num;\n    id = floor(angle / split);\n\tangle = id * split;\n    return rot2(angle) * pos;\n}\n\n\n// by Nusan\nfloat curve(float t, float d) {\n  t/=d;\n  return mix(floor(t), floor(t)+1., pow(smoothstep(0.,1.,fract(t)), 20.));\n}\n\n\nvec3 repeat(inout vec3 p, vec3 size) {\n\tvec3 c = floor((p + size*0.5)/size);\n\tp = mod(p + size*0.5, size) - size*0.5;\n\treturn c;\n}\n\nfloat repeat(inout float p, float size) {\n\tfloat c = floor((p + size*0.5)/size);\n\tp = mod(p + size*0.5, size) - size*0.5;\n\treturn c;\n}\n\n// from iq\nfloat sdPill( vec3 p, vec3 a, vec3 b, float r )\n{\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\n\n// distance to lines for the background\nvoid mapStars(vec2 uv, out vec3 near, out vec3 neighbor)\n{\n    vec2 point;\n    near = vec3(1e+4);\n\n    for(float y=-1.0; y<=1.0; y+=2.0)\n    {\n        point = vec2(0.0, HEX_COS + y * HEX_TAN * 0.25);\n        float dist = distance(uv, point);\n        near = near.z < dist ? near : vec3(point, dist);\n    }\n    \n    for(float x=-1.0; x<=1.0; x+=2.0)\n    {\n\t    for(float y=-1.0; y<=1.0; y+=2.0)\n        {\n            for(float both=-1.0; both<=1.0; both+=2.0)\n            {\n                point = vec2(x * 0.125, HEX_COS + y * HEX_COS * 0.5);\n                point.x += both * 0.5     * 0.125 * -x;\n                point.y += both * HEX_TAN * 0.125 * -y;\n                float dist = distance(uv, point);\n                near = near.z < dist ? near : vec3(point, dist);\n            }\n        }\n    }\n    \n    neighbor = vec3(1e+4);\n    \n    for(float y=-1.0; y<=1.0; y+=2.0)\n    {\n        point = vec2(0.0, HEX_COS + y * HEX_TAN * 0.25);\n        if(near.xy != point)\n        {\n            vec2 center = (point + near.xy) * 0.5;\n            float dist = dot(uv - center, normalize(near.xy - point));\n            neighbor = neighbor.z < dist ? neighbor : vec3(point, dist);\n        }\n    }\n    \n    for(float x=-1.0; x<=1.0; x+=2.0)\n    {\n\t    for(float y=-1.0; y<=1.0; y+=2.0)\n        {\n            for(float both=-1.0; both<=1.0; both+=2.0)\n            {\n                point = vec2(x * 0.125, HEX_COS + y * HEX_COS * 0.5);\n                point.x += both * 0.5     * 0.125 * -x;\n                point.y += both * HEX_TAN * 0.125 * -y;\n                \n                if(near.xy != point)\n                {\n                    vec2 center = (point + near.xy) * 0.5;\n                    float dist = dot(uv - center, normalize(near.xy - point));\n                    neighbor = neighbor.z < dist ? neighbor : vec3(point, dist);\n                }\n            }\n        }\n    }\n}\n\nvec2 toLogPolar(vec2 p) {\n    return vec2(log(length(p)), atan(p.y/p.x));\n}\n\nfloat starPattern(vec2 uv) {\n\n\n    vec2 uvb = uv;\n    float width = 0.0001 + mix(0.03, 0., pow(dot(uv, uv), .3));\n    \n    // log polar transform\n    uv = toLogPolar(uv*.01)*2.5;\n    uv.x += -.2*tt;\n    \n    uv = vec2(mod(uv.x, 1.0) - 0.5,\n         mod(uv.y, HEX_COS * 2.0) - HEX_COS);\n    \n    // rot tiling\n    float id;\n    \n    // change the patterns switching angles on a radial/time base\n    float reps = 5.;\n    float t = .07*(tt+6.);\n    float modid = (mod(floor(.1*length(uv)-t), reps)+3.)*2.;\n    float modt = pow(smoothstep(.0, .3, abs(fract(.1*length(uvb)-t)-.5)), 500.);\n    \n    //float alpha = mix(modid, mod(modid+2., 16.)+6., modt);\n    float alpha = mix(6., 18., modt);\n    //alpha = 18.;\n    uv = pmod(uv, alpha, id);\n       \n    // scene\n    vec3 near, neighbor;\n    mapStars(uv, near, neighbor);\n \n    // draw\n    float line = (1.0 - smoothstep(0.0, width, neighbor.z));\n    \n    return line;\n}\n\n\nvec3 kalei(vec3 p) {\n\n    p.x = abs(p.x) - 2.5;\n    \n    \n    vec3 q = p;\n\n    q.y -= .5;\n    q.y += .4*sin(tt);\n    p.y += .3*sin(p.z*3.+.5*tt);\n    float at = length(q) - .01;\n    for(float i=0.; i < 6.; i++) {     \n        p.x = abs(p.x) - 1.5;\n  \n        p.xz *= rot2(1.-exp(-p.z*.14*i)+.2*tt+.1*at);\n        p.xy *= rot2(sin(2.*i)+.2*tt);\n       // p.xz -= .4*sin(tt);\n     \n        p.y += 1.-exp(-p.z*.1*i);\n    }\n    p.x = abs(p.x) + 2.5;\n    \n        \n    return p;\n}\n\n\n// from iq\nfloat opSmoothIntersection( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.0-h); \n}\n\n\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); \n}\n    \nfloat map(vec3 p) {\n    //p.xz *= rot2(PI*.5);\n\n    vec3 bp = p;\n\n    // glowing interior \n    // basically its a kifs fractal of a log polar line mesh (conscentric spheres)\n    p.yz *= rot2(-PI*.25);\n    p = kalei(p);\n    \n    // map to log-spherical\n    float r = length(p);\n    p = vec3(log(r),\n             acos(p.z / r),\n             atan(p.y, p.x));\n   \n\n    // some heuristic computation to compensate the log scaling\n    float shrink = 1./abs(p.y-PI) + 1./abs(p.y) - 1./PI;\n    \n    float scale = floor(MESH_DENSITY)/PI; \n    // scale -= 15.*SIN(tt);\n    p *= scale;\n    \n    p.x -= tt;\n    p.y -= .7;\n    \n    vec3 id = repeat(p, vec3(LAYER_DISTANCE, .5, .5));\n\n    p.yz *= rot2(.25*PI);\n    p.x *= shrink;\n     \n    //p.x = abs(p.x) - .5;\n  \n    g_mat = bp.y*.6+id.x+abs(bp.x*.2);\n    \n    float w = LINE_WIDTH;\n    float d = length(p.xz) - w;\n    d = min(d, length(p.xy) - w);\n    d *= r/(scale*shrink);\n\n    // body\n    bp.z *= .5;\n    bp.z -= .75;\n    \n    vec3 bp1 = bp;\n    bp1.x *= mix(1., 3., smoothstep(1.15, 1.3, bp1.y));\n    r = mix(1.2, .8, smoothstep(1.1, -0.0, abs(bp1.y)-.2));\n    bd = sdPill(bp1, vec3(0, -.14, 0), vec3(0, .7, 0), r);\n    \n    // head\n    bp1 = bp;\n    bp1.x *= 1.;\n    bd = opSmoothUnion(bd, length(bp1-vec3(0, 2.61, 0))-.6, 1.5);\n    \n    // legs\n    bp1 = bp;\n    bp1.z *= .6;\n    bp1.z -= .6;\n    bp1.x = -abs(bp1.x);\n    \n    vec3 p1 = vec3(0, -1.3, 0);\n    vec3 p2 = vec3(-1.4, -0.8, -1.3);\n    r = mix(.5, .31, dot(bp1, normalize(p2-p1)));\n    bd = opSmoothUnion(bd, sdPill(bp1, p1, p2, r), .5);\n    \n    // arms\n    bp1 = bp;\n    bp1.z *= .5;\n    bp1.z -= .1;\n    bp1.x = -abs(bp1.x);\n    p1 = vec3(-1.15, 1.2, -.1);\n    p2 = vec3(-1.4, -0.85, -.2);\n    r = .13;\n    bd = opSmoothUnion(bd, sdPill(bp1, p1, p2, r), .4);\n   \n    // return bd*.5;\n    \n    // intersect body volume with the fractal\n    d = opSmoothIntersection(d, bd-.4, .5);\n    \n    return d*.5;\n}\n\n\nvec2 moda(vec2 p, float repetitions) {\n\tfloat angle = 2.*PI/repetitions;\n\tfloat a = atan(p.y, p.x) + angle/2.;\n\ta = mod(a,angle) - angle/2.;\n\treturn vec2(cos(a), sin(a))*length(p);\n}\n\nvec3 rings(vec2 uv) {\n    float rings = 0.;\n    vec2 uvr = uv;\n    uvr *= 1.2;\n\n    float triSize   = 0.286;\n    float hexSize   = 0.5;\n    float circleSize=.143;\n    float lineWidth = 0.0015;\n    float blur      = 0.001;\n    float glow      = .3;\n    float animr     = 1.;\n    vec3  ringc     = vec3(0.761,0.851,1.000);\n\n\n    #ifdef KALEI\n    for(float i=0.; i< 3.; i++) {\n        uvr = abs(uvr) - triSize;\n        uvr *= rot2(cos(uvr.x+tt));\n    }\n\n    #endif\n\n    rings += hexRing(uvr, hexSize, lineWidth, blur); \n    rings += glow*hexRing(uvr, hexSize, lineWidth*5., blur); //glow\n\n    vec2 uv0 = uvr;\n    uv0 *= rot2(-PI*animr*curve(tt, 2.));\n    rings += hexRing(uv0, hexSize*.5, lineWidth, blur);\n    rings += glow*hexRing(uv0, hexSize*.5, lineWidth*5., blur);\n\n    vec2 uv1 = uvr;\n\n\n    uv1 *= rot2(PI*animr*(curve(tt, 2.)));\n    rings += triRing(uv1, .286, lineWidth, blur);\n\n    rings += glow*triRing(uv1, .286, lineWidth*5., blur); // glow\n    vec2 uv2 = uvr;\n\n    uv2 *= rot2(PI-animr*PI*((curve(tt, 2.))));\n    rings += triRing(uv2, triSize, lineWidth, blur);\n    rings += glow*triRing(uv2, triSize, lineWidth*5., blur); // glow\n\n    vec2 uv3 = uvr;\n    //uv3.y += .27;\n\n    uv3 *= rot2(PI*.5);\n    uv3 *= rot2(PI*animr*curve(tt, 2.));\n\n    uv3 = moda(uv3, 6.);\n    uv3.x -= mix(triSize, .576, abs(mod(curve(tt, 2.), 2.)-1.));\n    rings += ring(uv3, circleSize, lineWidth, blur);\n    rings += glow*ring(uv3, circleSize, lineWidth*5., blur);\n    //  rings += .3*ring(uv3, circleSize, lineWidth*8., blur);\n\n    vec3 col = .6*mix(ringc, hue(-tt+length(uv)*2.+.5*PI), .5)*rings*mix(.0, .5, SIN(tt*PI));\n    return col;\n}\n\nvec3 chakras(vec2 uv) {\n\n    vec3 cols[7] = vec3[](vec3(0.608,0.020,1.000), \n                            vec3(0.169,0.059,1.000),\n                            vec3(0.000,0.800,1.000),\n                            vec3(0.035,1.000,0.020),                        \n                            vec3(0.984,1.000,0.161),\n                            vec3(1.000,0.463,0.020),\n                            vec3(1.000,0.000,0.000));\n    float offs[7] = float[](.48, .355, .24, .12, 0., -.1, -.19);\n    vec3 col = vec3(0);\n    \n    for(int i = 0; i < 7; i++) {\n    \n        vec2 coords = uv - vec2(0, offs[i]);\n        float anim = .1+.9*SIN(-4.*tt+2.*PI*float(i)/7.);\n        //anim = 1.;\n        col += cols[i]*mix(1., .0, \n                           smoothstep(0., .28, pow(length(coords), .2)-.2))*anim;\n        \n    }\n    \n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n    \n    //uv *= rot2(PI*.5);\n    vec3 rd = normalize(vec3(uv, .7)),\n         lp = vec3(0.,2., -15);\n         \n    ro = vec3(0, 0.0, -4.);\n         \n    vec3 p = ro;\n    vec3 col = vec3(0);\n    \n    float t, d = 0.1;\n    \n    tt = .3*iTime;\n    \n    float mat = 0.;\n    vec2 e = vec2(0.0035, -0.0035);\n     \n    vec3 al = vec3(0);\n    vec3 bg = vec3(0.016,0.086,0.125);\n  \n    for(float i=.0; i<80.; i++) {\n    \n        d = map(p);\n        mat = g_mat;\n\n        if(t > 7.) break;\n        \n        t += max(.01, abs(d));\n        p += rd*d;\n        \n        // shading\n        if(d < 0.006) {\n          \n           al = hue(mat*.4)*.9;\n           // al = getPal(7, mat*.4);\n          // al = vec3(1);\n           col +=  al/exp(t*.6);\n\n        }  \n        if(abs(bd-.04) < 0.0005 && bd < 0.04) {\n             col +=  1.1-exp(-bd*bd*50.);\n        }\n        \n     \n    } \n    \n    if(dot(col, col) < 0.001) {\n        col += bg*mix(.3, 1.1, (1.-pow(dot(uv, uv), .5)));\n        float stars = starPattern(uv);\n        col +=  stars*0.6*(.1+.9*hue(-tt+length(uv))*(mix(.1, .2, SIN(length(uv)*1.5+tt))));\n        col += .7*rings(uv);\n    }\n    \n    col = .8*col+1.5*chakras(uv);\n    col *= mix(.1, 1., (1.5-pow(dot(uv, uv), .2))); // vignette\n    col = pow(col, vec3(.6)); // gamma\n\n    fragColor = vec4(col, 1.0 - t * 0.3);\n}","name":"Image","description":"","type":"image"}]}