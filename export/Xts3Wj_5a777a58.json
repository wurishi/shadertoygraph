{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[],"code":"//Raymarches and renders the function given in f\n\n//Global variables\nvec3 cpos = vec3(80.0, 0.0, 80.0);\nvec3 up = vec3(0.0, 1.0, 0.0);\nvec3 look_at = vec3(0.0, 0.0, 0.0);\n\nvec3 right;\nvec3 front;\n\nfloat max_dist = 120.0;\n////////////////////////////////////\n\n\nfloat snoise(vec3);\n\n//Function to render\n//Change this to render something else!\nfloat f(vec3 pos){\n    \n    \n    //f(x, z) = -(x^2+z^2)/5;\n    return -(3.0*pos.x+pos.z*pos.z)/15.0; \n    \n    //f(x, z) = -(x^2+z^2)+sin(x)+cos(z);\n \t//return -(pos.x*pos.x+pos.z*pos.z)/10.0+sin(pos.x*cos(iTime))+cos(pos.z*sin(iTime/3.0)); \n    \n    //cool\n \t//return -(30.0*pos.x*pos.x+pos.y*pos.z)/10.0+sin(pos.x)+cos(pos.z); \n}\n\nfloat sincos(vec3 pos){\n    return (sin(pos.x*cos(iTime))+cos(pos.z*sin(iTime/3.0)));\n}\n\n    \n//Helper function\nfloat mapFunction(vec3 pos){\n    //Enmantlad hyperboloid -> kon -> tvÃ¥mantlad hyperboloid\n    //return (pos.x*pos.x+pos.z*pos.z-pos.y*pos.y)/10.0-(80.0-14.0*iTime);\n    \n    \n    return 10.0+(pos.x*pos.x+pos.z*pos.z-pos.y*pos.y)/10.0;//-(80.0-14.0*iTime)+5.0*sincos(pos);\n    \n    //Paraboloid\n    //return pos.y+(pos.x*pos.x+pos.z*pos.z*(1.0-iTime/10.0))/10.0;\n    \n    \n    //return pos.y+(pos.x*pos.x+pos.z*pos.z*(1.0-iTime/10.0))/10.0+3.0*sincos(pos);\n    \n    //return length(pos) - 16.0; //map as sphere with radius 6\n    \n    //Paraboloid + sin/cos\n    //return pos.y - f(pos);\t\t//map f as y = f(x, z)\n}\n\n\n\nvoid move_cam(){\n    vec3 cpos2 = cpos;\n    //Move camera\n    cpos2.x *= cos(iTime);\n    cpos2.z *= sin(iTime);\n    \n    \n    //Makes sure camera isn't in a wall\n    //Get rid of bounce by lerping\n    for(int i=0; i<20; i++){\n        if(mapFunction(cpos2)>0.0)\n            continue;\n    \tcpos2.x = cpos.x*cos(iTime+float(i)/2.0);\n    \tcpos2.z = cpos.z*sin(iTime+float(i)/2.0);\n    }\n    \n    cpos = cpos2;\n    \n    \n    //Set camera vectors\n    look_at.y += 3.0*sin(iTime);\n}\n\n\n\n\n//////////////////////\n//Raymarches the function given in function\n//which is mapped as a distance field in map_function \n\n//Raymarch this ray\n//March along ray until mapFunction(pos+ray*t) < 0\nfloat raymarch(vec3 pos, vec3 ray){\n    float t = 0.2; \t\t//Start time\n    float lim = 0.0;\n\tfloat lt = 0.0;\n\tfloat lh = 0.0;\n\t//int i;\n    for(int i=0; i<160; i++ )\n    {\n\t    float h = mapFunction( pos+ray*t );\n        //if( h<(0.001*t) || t>maxd ) break;\n        //if( h<0 || t>maxd ) break;\n        if( h<lim || t>max_dist ) {\n            if(t<max_dist)\n\t\t\t\tt = mix(t, lt, -h/(lh-h)); //Interpolera t\n\t\t\tcontinue;\n\t\t}\n\t\tlh = h;\n\t\tlt = t;\n        t += h*0.1+0.01*t;\n        //t += max_dist/160.0;\n    }\n\n    if( t>max_dist ) t=-1.0;\n    return t;\n}\n\n//Calculate normal\n//Gradient somethingsomething\nvec3 nor( in vec3 pos, in float t )\n{\n    vec3 eps = vec3( max(0.02,0.001*t),0.0,0.0);\n\treturn normalize( vec3(\n           mapFunction(pos+eps.xyy) - mapFunction(pos-eps.xyy),\n           mapFunction(pos+eps.yxy) - mapFunction(pos-eps.yxy),\n           mapFunction(pos+eps.yyx) - mapFunction(pos-eps.yyx) ) );\n\n}\n\n//Calculate ray for this point of the screen\n//Based on where it is compared to the center of screen\nvec3 getRay(vec2 fragCoord){\n    vec2 center = iResolution.xy/2.0;//Center of screen\n\tvec2 point = (fragCoord.xy - center)/center; // Point compared to mid-screen\n    \n\tfloat angle = atan(point.y, point.x);\n\tfloat len = length(point);\n\tfloat frontMul = 1.0;\n\tvec3 ray = frontMul * front + sin(angle) * len * up + cos(angle) * len * right;\n\tnormalize(ray);\n\treturn ray;\n}\n\n//Calculate sky color (modeled as some kind of gradient)\nvec3 sky_color(vec3 vec){\n \tfloat val = dot(vec, vec3(0.0, 1.0, 0.0));\n    vec3 res = vec3(0.6, 0.6, 0.9);\n    res.x += (sin(vec.x)+cos(vec.y)+sin(vec.z-vec.y))/1.0;\n    res.y += snoise(vec+iTime/20.0)/5.0;\n    res *= (val/2.0+1.0);\n    return res;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 sun_pos = vec3(1000.0);\n    \n    move_cam();\n    \n    //Set camera vectors\n    front = normalize(-cpos+look_at);\n    right = normalize(cross(up, front));\n    up = normalize(up);\n    \n    \n    vec3 ray = getRay(fragCoord);\n    \n    vec3 color = vec3(0.0, 0.0, 0.0);\n    \n    float t =  raymarch(cpos, ray);\n    if(t>0.0){//Did we find an intersection?\n    \tvec3 point = cpos+t*ray;\n        vec3 normal = nor(point, t);\n        \n        //light/shading\n        //amb + diff + spec + sky\n        float amb = 0.0;\n        vec3 ambc = vec3(0.8, 0.8, 0.99);\n        \n        sun_pos = normalize(sun_pos-cpos);\n        float sun = clamp( dot( normal, sun_pos ), 0.0, 1.0 );\n        vec3 sunc = vec3(1.0, 1.0, 0.2);\n        \n \t\tfloat specular = pow(clamp( dot( normalize(reflect(ray, normal)), sun_pos ), 0.0, 1.0 ), 30.0);\n        \n        float sky = 1.0;\n        vec3 skyc = sky_color(normal);\n        \n        //float fog = t/max_dist;\n        //vec3 fogc = vec3(00);\n        \n        \n     \tcolor = (1.0+specular)*(amb*ambc + sun*sunc + sky*skyc)/3.0;\n    }\n   \telse\n        color = vec3(sky_color(ray));\n    \n    fragColor = vec4(color, 1.0);\n}\n\n\n\n//3d simplex noise below\n\n\n\n\n\n//\n// Description : Array and textureless GLSL 2D/3D/4D simplex \n//               noise functions.\n//      Author : Ian McEwan, Ashima Arts.\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n//               Distributed under the MIT License. See LICENSE file.\n//               https://github.com/ashima/webgl-noise\n// \n\n\nvec3 mod289(vec3 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289(vec4 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute(vec4 x) {\n     return mod289(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nfloat snoise(vec3 v)\n  { \n  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\n// First corner\n  vec3 i  = floor(v + dot(v, C.yyy) );\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n// Other corners\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min( g.xyz, l.zxy );\n  vec3 i2 = max( g.xyz, l.zxy );\n\n  //   x0 = x0 - 0.0 + 0.0 * C.xxx;\n  //   x1 = x0 - i1  + 1.0 * C.xxx;\n  //   x2 = x0 - i2  + 2.0 * C.xxx;\n  //   x3 = x0 - 1.0 + 3.0 * C.xxx;\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n  vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\n\n// Permutations\n  i = mod289(i); \n  vec4 p = permute( permute( permute( \n             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n           + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) \n           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n// Gradients: 7x7 points over a square, mapped onto an octahedron.\n// The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n  float n_ = 0.142857142857; // 1.0/7.0\n  vec3  ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4( x.xy, y.xy );\n  vec4 b1 = vec4( x.zw, y.zw );\n\n  //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\n  //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n  vec3 p0 = vec3(a0.xy,h.x);\n  vec3 p1 = vec3(a0.zw,h.y);\n  vec3 p2 = vec3(a1.xy,h.z);\n  vec3 p3 = vec3(a1.zw,h.w);\n\n//Normalise gradients\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n// Mix final noise value\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), \n                                dot(p2,x2), dot(p3,x3) ) );\n  }\n","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"Xts3Wj","date":"1426019993","viewed":137,"name":"Flervariabel-visualisering","username":"Nilax","description":"-","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["3dvisualizefunctions"],"hasliked":0,"parentid":"","parentname":""}}