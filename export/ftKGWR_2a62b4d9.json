{"ver":"0.1","info":{"id":"ftKGWR","date":"1637498184","viewed":103,"name":"color drop","username":"Ornibulon","description":"smooth sdf color mixing test","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["sdf","color"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float PI = 3.14159265;\n\n\nfloat rand(float k, float seed){\n    return sin(k*seed*seed);\n}\n\n\nmat3 rotMatrix(vec3 rotation){\n    rotation *= PI/180.;\n    float rx = rotation.x;\n    float ry = rotation.y;\n    float rz = rotation.z;\n    \n    mat3 rotationX = mat3( 1      , 0      , 0      ,\n                           0      , cos(rx),-sin(rx),\n                           0      , sin(rx), cos(rx));\n                          \n    mat3 rotationY = mat3( cos(ry), 0      , sin(ry),\n                          0       , 1      , 0      ,\n                          -sin(ry), 0      , cos(ry));\n                          \n    mat3 rotationZ = mat3( cos(rz),-sin(rz), 0      ,\n                           sin(rz), cos(rz), 0      ,\n                           0      , 0      , 1      );\n                           \n    return rotationX * rotationY * rotationZ;\n}\n\n\nvec4 opSmoothUnion( vec4 d1, vec4 d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2.x-d1.x)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n    \n\nvec4 sphere(vec3 p, vec3 center, vec3 color, float s){\n    vec4 valcolor = vec4(0, 0, 0, 0);\n    \n    float value = length(p - center)-s;\n    \n    valcolor.x = value;\n    valcolor.yzw = color;\n    \n    return valcolor;\n}\n\n\nvec4 plane(vec3 p, vec3 normal, vec3 color, float h)\n{\n    vec4 valcolor = vec4(0, 0, 0, 0);\n    \n    float value = dot(p,normal) + h;\n    \n    valcolor.x = value;\n    valcolor.yzw = color; \n    \n    return valcolor;\n}\n\n\nvec4 sdf(in vec3 p){\n\n    float random0 = rand(1000., float(int(iTime/2.)));\n    float random1 = rand(2000., float(int(iTime/2.)));\n    float h = 8. - 13.*pow((iTime/2. - float(int(iTime/2.))),2.);\n    \n    float random2 = rand(5000., float(int(iTime/2.+0.5)));\n    float random3 = rand(7000., float(int(iTime/2.+0.5)));\n    float h2 = 8. - 13.*pow((iTime/2.+0.5 - float(int(iTime/2.+0.5))),2.);\n\n    return opSmoothUnion(sphere(p, vec3(2.*random0,2.*random1+2.,h), vec3(1,0,1), 1.),\n           opSmoothUnion(sphere(p, vec3(2.*random2,2.*random3+2.,h2), vec3(0,1,1), 1.),\n                         plane(p, vec3(0,0,1), vec3(1,1,1), 1.), 2.5), 2.5);\n}\n/*\nvec4 sdf(in vec3 p){\n    return sphere(p, vec3(0,0,0), vec3(1,1,0), 1.);\n}*/\n\n\n\nbool sdfIntersect(out vec3 position, out vec3 normal, out vec3 color, in vec3 rayOri, in vec3 rayDir){\n    int maxStep = 1000;\n    int dichoSteps = 12;\n\n    vec3 rayPosA = rayOri;\n    vec3 rayPosB = rayOri;\n    vec4 sdfValueA = sdf(rayOri)+0.01;\n    vec4 sdfValueB = sdfValueA;\n    \n    // sphere-tracing\n    int count = 0;\n    while (sdfValueB.x > 0.){\n        rayPosA = rayPosB; \n        rayPosB += (sdfValueB.x + 0.001) * rayDir;\n        //rayPosB += 0.01 * rayDir;\n        \n        sdfValueA = sdfValueB;\n        sdfValueB = sdf(rayPosB);\n        \n        if (count > maxStep || sdfValueB.x > 10.){\n            return false;\n        }\n        \n        count += 1;\n    }\n    \n    // end with dichotomy\n    vec3 rayPosAB = (rayPosA + rayPosB)/2.;\n    vec4 sdfValueAB = sdf(rayPosAB);\n    for (int i; i<dichoSteps; i++){\n        if (sdfValueAB.x > 0.){\n            rayPosA = rayPosAB;\n            sdfValueA = sdfValueAB;\n        } else {\n            rayPosB = rayPosAB;\n            sdfValueB = sdfValueAB;\n        }\n        \n        rayPosAB = (rayPosA + rayPosB)/2.;\n        sdfValueAB = sdf(rayPosAB);\n    }\n\n    position = rayPosAB;\n    \n    float epsilon = 0.0001;\n    normal = vec3(sdf(position+vec3(epsilon, 0, 0)).x - sdf(position+vec3(-epsilon, 0, 0)).x,\n                  sdf(position+vec3(0, epsilon, 0)).x - sdf(position+vec3(0, -epsilon, 0)).x,\n                  sdf(position+vec3(0, 0, epsilon)).x - sdf(position+vec3(0, 0, -epsilon)).x);\n                  \n    normal = normalize(normal);\n\n    color = sdfValueB.yzw;\n    \n    return true;\n}\n\n\nfloat light(vec3 lightPos, vec3 objPos, vec3 normal){\n    vec3 lightDir = normalize(lightPos - objPos);\n    \n    vec3 position2 = vec3(0,0,0);\n    vec3 normal2 = vec3(0,0,0);\n    vec3 color2 = vec3(0,0,0);\n    \n    vec3 rayOri = objPos;\n    vec3 rayDir = lightDir;\n    \n    bool intersect = sdfIntersect(position2, normal2, color2, rayOri, rayDir);\n    \n    if (intersect && length(position2 - objPos)>0.0001){\n        return 0.;\n    }\n    \n    return max(0.,dot(lightDir, normal));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n    vec2 uv = fragCoord/iResolution.xy - vec2(0.5, 0.5);\n    \n    float aspectRatio = iResolution.y/iResolution.x;\n    \n    vec2 sensorSize = vec2(16., 9.);//aspectRatio*16.);\n    float focal = 10.;\n    \n    \n    vec3 position = vec3(0,0,0);\n    vec3 normal = vec3(0,0,0);\n    vec3 color = vec3(0,0,0);\n    \n    vec3 rayOri = vec3(0, -5, 0);\n    vec3 rayDir = normalize(vec3(sensorSize.x*uv.x, focal, sensorSize.y*uv.y));\n    \n    bool intersect = sdfIntersect(position, normal, color, rayOri, rayDir);\n    \n    vec3 col = vec3(uv.y/3.,uv.y/2.,uv.y);\n    if (intersect){\n        col = color * vec3(1,1,1) * (light(vec3(6,-1,8), position, normal));\n        //col = (normal + vec3(1,1,1))/2.;\n    }\n\n\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}