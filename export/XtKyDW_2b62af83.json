{"ver":"0.1","info":{"id":"XtKyDW","date":"1536266688","viewed":251,"name":"Frametime Overlay - Noise","username":"bkeinert","description":"Visual variant of [url=https://www.shadertoy.com/view/MlGcWD]MlGcWD[/url] by FabriceNeyret2.\n gold (red) / classical2 (yellow) / classical3 (green) / DH2 (cyan) / DH3 (blue) / IQ/GlibC 3 (magenta) / IQ/GlibC 3-vec3 (grey).\nConfiguration in [b]Common[/b].\n","likes":5,"published":1,"flags":32,"usePreview":0,"tags":["noise","random","overlay","benchmark","frametime"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// See \"Common\" for configuration options / credits etc.\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 tc = fragCoord/iResolution.xy;\n\n    // Average over 2*n + 1 samples\n    // Algorithm color: v.xyz / frametime in ms: v.w\n    float n = 1.0;\n    vec4 v = vec4(0, 0, 0, 0);\n    for (float i = -n; i <= n; ++i) {\n        v += texture(iChannel0, tc*vec2(1.0, 0.0) + vec2(i, 0.0)/iResolution.xy);\n    }\n    v /= (2.0*n+1.0);\n\n\tfloat scale = SCALE_MAX_MS;\n\n#ifdef ADAPTIVE_SCALING\n    // Adapative scaling\n    //if (iFrame > ADAPTIVE_SCALING_FRAMES){\n    \tscale =  max(texture(iChannel0, vec2(1.0, 1.0)).w * 2.0, 1.0);\n    //}\n#endif\n\n\t// Run benchmark\n    fragColor.xyz = clamp(runAlgorithmBenchmark(getAlgorithmId(iFrame), fragCoord, iTime), 0.0, 0.25);\n   \n    // Draw colored \"bars\"\n    if (tc.y < v.w/scale){\n    \tfragColor = mix(clamp(fragColor, 0.0, 1.0), vec4(v.xyz, 1.0), 0.35);\n    }\n    \n    // 90 Hz (green)\n    if (abs(tc.y - (1000.0/90.0)/scale) <= 0.5/iResolution.y) {\n       \tfragColor = mix(fragColor, vec4(0,1.0,0,0), 0.95);\n    }\n\n    // 60 Hz (yellow)\n    if (abs(tc.y - (1000.0/60.0)/scale) <= 0.5/iResolution.y) {\n       \tfragColor = mix(fragColor, vec4(1.0,1.0,0,0), 0.95);\n    }\n    \n    // 30 Hz (orange)\n    if (abs(tc.y - (1000.0/30.0)/scale) <= 0.5/iResolution.y) {\n       fragColor = mix(fragColor, vec4(1,0.5,0,0), 0.95);\n    }\n    \n    // 15 Hz (red)\n    if (abs(tc.y - (1000.0/15.0)/scale) <= 0.5/iResolution.y) {\n       fragColor = mix(fragColor, vec4(1,0,0,0), 0.95);\n    }    \n\n    // 5 ms grid\n    if (abs((mod(tc.y*scale, 5.0) - 5.0)/(2.5*scale)) <= 0.5/iResolution.y) {\n       fragColor = mix(fragColor, vec4(0.5,0.5,0.5,0.5), 0.5);\n    }  \n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    ivec2 id = ivec2(fragCoord);\n    \n    // Use one line (y == 0) of buffer A\n    if (id.y == 0) {\n        if (id.x == int(iResolution.x)-1) {\n            // Insert current algorithm color and frametime (in ms) on the right\n    \t\tvec3 color = getAlgorithmColor(getAlgorithmId(iFrame));\n        \tfragColor = vec4(color, iTimeDelta*1000.0);\t\n        } else {\n            if (int(iResolution.x) - id.x > iFrame) {\n                fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n            } else {\n            \t// Shift values from previous frames to the left\n    \t\t\tfragColor = texture(iChannel0, (vec2(id) + vec2(1.5, 0.0))/iResolution.xy);\n            }\n        }\n    } else {\n#ifdef ADAPTIVE_SCALING\n        // Average timings over #ADAPTIVE_SCALING frames for adaptive scaling\n        if (all(equal(id, ivec2(iResolution.xy)-1))) {\n            float s = 0.0;\n            int numFrames = min(iFrame, ADAPTIVE_SCALING_FRAMES);\n            for (int i = 0; i < numFrames; ++i) {\n            \ts += texture(iChannel0, vec2(1.0 - (float(i) + 0.5)/iResolution.x, 0.0)).w;\n            }\n            s /= float(numFrames);\n            fragColor = vec4(s,s,s,s);\n        } else {\n        \t// Ignore all other fragments\n\t\t\tdiscard;\n        }\n#else\n        // Ignore all other fragments\n        discard;\n#endif\n    }\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"// Frametime Overlay - bkeinert 2018\n// See https://www.shadertoy.com/view/MtKcWh\n\n// Configuration\n#define ITERATIONS_PER_ALGORITHM 10000\n//#define ITERATIONS_PER_ALGORITHM 2000\n#define FRAMES_PER_ALGORITHM 50\n#define ALGORITHMS 8\n#define SCALE_MAX_MS 100.0\n#define ADAPTIVE_SCALING\n#define ADAPTIVE_SCALING_FRAMES 25\n\n\n\n// Credit for the thought-provoking impulse goes to tholzer:\n// \"I wonder, if there is in general a possibility to visualize the runtime of two tests... \"\n// -- tholzer, 2018-09-04 comment of https://www.shadertoy.com/view/XtVcDh\n\n// --------------------------------\n// Copy & paste from https://www.shadertoy.com/view/MlGcWD\n// by FabriceNeyret2\n// --------------------------------\n// BEGIN MlGcWD\n// --------------------------------\n\n\n// uncomment target noise to test at the end\n\n//precision lowp    float;\n\n// --- \"Gold Noise random generator\" by dcerisano. https://shadertoy.com/view/ltB3zD\n// claims:\n// - based on the Golden Ratio, PI and the Square Root of Two\n// - superior distribution\n// - fastest noise generator function\n// - works with all chipsets (including low precision)\n\n//precision lowp    float;\nfloat PHI = 1.61803398874989484820459 * 00000.1; // Golden Ratio   \nfloat PI  = 3.14159265358979323846264 * 00000.1; // PI\nfloat SQ2 = 1.41421356237309504880169 * 10000.0; // Square Root of Two\n\nfloat gold_noise(in vec2 coordinate, in float seed){\n    return fract(tan(distance(coordinate*(seed+PHI), vec2(PHI, PI)))*SQ2);\n}\n\n// --- classical hash\n#define hash(p) fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453)\n#define hash3(p) fract(sin(dot(p, vec3(12.9898, 78.233, -2.347))) * 43758.5453)\n\n// --- Dave_Hoskins https://www.shadertoy.com/view/4djSRW\n#define HASHSCALE1 .1031\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n// --- IQ int hash II https://www.shadertoy.com/view/XlXcW4\nconst uint k = 1103515245U;  // GLIB C\nvec3 Ghash( uvec3 x )\n{\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    \n    return vec3(x) / float(0xffffffffU);\n}\n\n// -----------------------------------------------\n\n// --------------------------------\n// END MlGcWD\n// --------------------------------\n\n#define _PHI_ (sqrt(5.0)*0.5 + 0.5)\nfloat F(float n) {\n\treturn round(pow(_PHI_, n) / sqrt(5.0));\n}\n\n// Experimental, broken. Really broken.\nfloat rnd12exp(vec2 p) {\n    vec3 magic = F(5.0)*vec3(_PHI_, PI, sqrt(2.0));\n\tvec3 t  = fract(p.yxy*magic + p.xyx);\n    t = t*F(12.0) + t.xzy;\n    return fract(t.z*t.y + t.x);\n}\n\nint getAlgorithmId(int frame) {\n\treturn (frame/FRAMES_PER_ALGORITHM) % ALGORITHMS;\n}\n\nvec3 getAlgorithmColor(int id) {\n\tvec3 colors[] = vec3[](\n        vec3(0.85,0,0),\n        vec3(0.85,0.85,0),\n        vec3(0,0.85,0),\n        vec3(0,0.85,0.85),\n        vec3(0,0,0.85),\n        vec3(0.85,0.0,0.85),\n    \tvec3(0.5,0.5,0.5),\n        vec3(0.75,0.75,0.75)\n    );\n    return colors[id];\n}\n\n#define LOOP_U_t(X) {\\\n    float numIterations =  float(ITERATIONS_PER_ALGORITHM);\\\n\tfor(float i = 0.0; i < numIterations; i++) {\\\n        vec2 U = fragCoord+i; \\\n        float t = time+i; \\\n        O += X;\\\n    }}\n\n\nvec3 runAlgorithmBenchmark(int id, vec2 fragCoord, float time) {\n    // from https://www.shadertoy.com/view/MlGcWD\n    vec3 O = vec3(0,0,0);\n    switch (id) {\n        case 0:\n        \tLOOP_U_t(gold_noise(U, t));     // gold, float\n        \tbreak;\n        case 1:\n        \tLOOP_U_t(hash(U + t));          // classical2, float\n        \tbreak;\n        case 2:\n        \tLOOP_U_t(hash3(vec3(U, t)));    // classical3, float\n        \tbreak;\n        case 3:\n        \tLOOP_U_t(hash12(U + t));        // DH2, int\n        \tbreak;\n        case 4:\n        \tLOOP_U_t(hash13(vec3(U, t)));   // DH3, int\n        \tbreak;\n        case 5:\n        \tLOOP_U_t(Ghash(uvec3(U, t)).x); // IQ/GlibC 3, int\n        \tbreak;\n        case 6:\n        \tLOOP_U_t(Ghash(uvec3(U, t)));   // IQ/GlibC 3, int -> vec3\n        \tbreak;\n        case 7:\n        \tLOOP_U_t(rnd12exp(U + t));      // experimental\n        \tbreak;\n\n\n    }\n    /*\n\tOLD BENCHMARK\n    if (id == 0) {\n  \t\tfor(int i=0; i < ITERATIONS_PER_ALGORITHM; i++)\n            O  += gold_noise(fragCoord+float(i), time+float(i));      // gold, float\n    } else if (id == 1) {\n    \tfor(int i=0; i < ITERATIONS_PER_ALGORITHM; i++)\n            O  += hash(fragCoord+ time+float(i));            // classical2, float\n    } else if (id == 2) {\n    \tfor(int i=0; i < ITERATIONS_PER_ALGORITHM; i++)\n            O  += hash3(vec3(fragCoord+float(i), time+float(i)));     // classical3, float\n    } else if (id == 3) {\n    \tfor(int i=0; i < ITERATIONS_PER_ALGORITHM; i++)\n            O  += hash12(fragCoord+ time+float(i));          // DH2, int\n    } else if (id == 4) {\n    \tfor(int i=0; i < ITERATIONS_PER_ALGORITHM; i++)\n            O  += hash13(vec3(fragCoord+float(i), time+float(i)));    // DH3, int\n    }  else if (id == 5) {\n    \tfor(int i=0; i < ITERATIONS_PER_ALGORITHM; i++)\n            O  += Ghash(uvec3(fragCoord+float(i), time+float(i))).x;  // IQ/GlibC 3, int\n    }\n    */\n    return O.xyz;\n}","name":"Common","description":"","type":"common"}]}