{"ver":"0.1","info":{"id":"4XsGRr","date":"1707117942","viewed":268,"name":"Balrog - DOS 256b exe gfx","username":"pestis","description":"This is the prototype shader for Balrog - a 256 byte executable graphics for DOS, made for lovebyte 2024 by pestis / brainlez Coders!\n\nhttps://www.pouet.net/prod.php?which=96014\n\nhttps://demozoo.org/graphics/337749/","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","kaleidoscopicifs","executablegraphics"],"hasliked":0,"parentid":"-1","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const int STEPS = 20;\nconst float BIG = 403.;\nconst float BIGZ = BIG/384.*2.;\nconst int ITERS = 23;\nconst float MINDIST = .0001;\nconst float CAM_X = .00;\nconst float CAM_Y =.61;\nconst float CAM_Z = 36.7;\nconst float LEVEL = 1.;\nconst float XMULT = 1.5;\nconst float COLORMULT = 3.14592;\nconst float COLORSCALE = 0.0549857728183;\nconst float XDIV = 2.0006;\nconst float RSCALE = pow(2.,1./3.); // this doesn't actually have to be exactly this number\nconst float RDIV = pow(RSCALE,float(ITERS));\nconst float GLOWAMOUNT = 0.0549857728183;\nconst float GLOWDECAY = 1e4;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    vec2 ray = vec2((fragCoord - 0.5 * iResolution.xy) / iResolution.xy);        \n    ray.y = -ray.y;\n    ray.xy *= vec2(512,384); // this is actually what we have on DOS: the screen coordinates\n    \n    vec3 p = vec3(CAM_X,CAM_Y,CAM_Z);\n    int i;\n    float glow = 0.0;\n    \n\n    for(i = 0; i < STEPS; i++) {                                                             \n       \n       vec3 t = p;                               \n       // o is the amount of rotation in the kaleidoscopic IFS. we vary it depending on the point\n       // in space\n       float o = cos(p.x*XMULT)/XDIV;\n       float r = 0.;\n\n       // r is the weird part: instead of length(t) or length(t)^2, we compute \"cumulative r-squared\"\n       // which is RSCALE^(ITERS-1)*t[0].x^2 + ... + RSCALE*t[ITERS-2].x^2 + t[ITERS-1].x^2\n       // Looks like some euclidian distance still. RSCALE was added because otherwise the noisy\n       // later iterations made the whole thing look like a mess.\n       for(int j=0;j<ITERS;j++){                    \n          t.x = abs(t.x - round(t.x)); // abs is folding, t.x - round(t.x) is domain repetition               \n          t.x += t.x; // domain scaling\n          r *= RSCALE;          \n          r += t.x*t.x;\n          t.xyz = t.yzx; // shuffle coordinates so next time we operate on previous y etc.\n          t.x += t.z * o; // rotation, but using very poor math\n          t.z -= t.x * o;               \n       }\n       \n       float dist = sqrt(r/RDIV)-LEVEL;  // this is something like a SDF of a ball       \n       glow += GLOWAMOUNT/(1.+dist*dist*GLOWDECAY); // add some glow every step\n  \n       p.xy += ray.xy * dist/BIG; // the math emulates what are actually doing on DOS\n       p.z += dist/BIGZ;                                \n       if (dist < MINDIST) break;\n    }    \n    \n    float s =  float(i)*COLORSCALE;\n    \n    vec3 col = vec3(s*s)+cos(p*COLORMULT)*glow; // s*s to adjust the contrast   \n    // clamping colors on DOS is very expensive so we do abs(sin(...)) to get to 0..1 range\n    fragColor = vec4(abs(sin(col)),1.0); \n}","name":"Image","description":"","type":"image"}]}