{"ver":"0.1","info":{"id":"wdcGDB","date":"1569269867","viewed":957,"name":"SDF Collision","username":"mmacklin","description":"ShaderToy for associated I3D paper: \n\nLocal Optimization for Robust Signed Distance Field Collision\n\nPaper: https://mmacklin.com/sdfcontact.pdf\nVideo: https://www.youtube.com/watch?v=icU6Bm-HZ-E\n","likes":9,"published":1,"flags":0,"usePreview":1,"tags":["sdf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define USE_GRADIENT_DESCENT 0\n#define USE_FRANK_WOLFE 0\n#define USE_GOLDEN_SECTION_SEARCH 1\n\n//---------------------------------------------------------------------\n// Distance routines (courtesy Inigo Quilez https://iquilezles.org)\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,vec2(0))) + min(max(d.x,d.y),0.0);\n}\n\nfloat sdCircle( vec2 p, float radius)\n{\n\treturn length(p)-radius;   \n}\n\nfloat sdLine( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nfloat sdHorseshoe( in vec2 p, in vec2 c, in float r, in vec2 w )\n{\n    p.x = abs(p.x);\n    float l = length(p);\n    p = mat2(-c.x, c.y, \n              c.y, c.x)*p;\n    p = vec2((p.y>0.0)?p.x:l*sign(-c.x),\n             (p.x>0.0)?p.y:l );\n    p = vec2(p.x,abs(p.y-r))-w;\n    return length(max(p,0.0)) + min(0.0,max(p.x,p.y));\n}\n\nfloat sdUnevenCapsule( vec2 p, float r1, float r2, float h )\n{\n    p.x = abs(p.x);\n    float b = (r1-r2)/h;\n    float a = sqrt(1.0-b*b);\n    float k = dot(p,vec2(-b,a));\n    if( k < 0.0 ) return length(p) - r1;\n    if( k > a*h ) return length(p-vec2(0.0,h)) - r2;\n    return dot(p, vec2(a,b) ) - r1;\n}\n\nfloat sdScene(vec2 x)\n{\n   \t//float d = sdBox(x, vec2(0.5));      \n    \n    float angle = 0.3;    \n    float d = sdHorseshoe(x, vec2(sin(angle), cos(angle)), 0.6, vec2(0.6, 0.25));\n    \n    \n    //float d = sdUnevenCapsule(x+vec2(0.0, 0.5), 0.1, 0.5, 1.0);\n    \n    return d;\n}\n\nvec2 sdSceneGrad(vec2 x)\n{\n\tvec2 dfdx;\n    float eps = 0.001;\n\t\n    dfdx.x = sdScene(x + vec2(eps, 0.0)) - sdScene(x + vec2(-eps, 0.0));\n\tdfdx.y = sdScene(x + vec2(0.0, eps)) - sdScene(x + vec2(0.0, -eps));\n    dfdx /= 2.0*eps;\n\n    return dfdx;\n}\n\n//----------------------------------------------------\n// Drawing routines\n\nfloat isocontour(float s, float width, float freq)\n{\n    return smoothstep(1.0-width, 1.0, abs(sin(s*freq)));\n}\n\nfloat zerocontour(float d, float width)\n{\n    return 1.0-smoothstep(0.0, width, abs(d));\n}\n\nvec3 gradient(float d, vec3 a, vec3 b, float scale)\n{\n    if (d < 0.0)\n        return mix(vec3(1.0, 1.0, 0.3), vec3(1.0, 0.2, 0.0), -1.5*d/scale);\n    else\n        return mix(vec3(0.0, 0.1, 0.80), vec3(0.3, 0.6, 1.0), min(1.0, 0.5*d/scale));\n}\n\nvoid blend(inout vec3 dest, vec4 src)\n{\n\tdest = dest*(1.0-src.w) + src.xyz;\n}\n\n\nvec4 circle(vec2 x, vec2 c, float radius)\n{\n    float d = length(x-c);\n    vec3 col = vec3(0.0);\n    \n    if (d < radius)\n        col = vec3(1.0);\n    \n    float alpha = zerocontour(d-radius, 0.01);\n    col *= 1.0-alpha;\n    \n    return vec4(col, alpha);\n\n}\n\n//----------------------------------------------------\n// Entry point\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 col = vec3(0.0);\n    \n    float zoom = 2.0;    \n    vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y*zoom;  \n\tvec2 mouse = (-iResolution.xy + 2.0*iMouse.xy)/iResolution.y*zoom;  \n    \n    float sdf = sdScene(p);\n    \n    // line\n    vec2 a = vec2(-0.0, 1.0) + mouse;\n    vec2 b =  vec2(1.0, -0.0) + mouse;\n    \n    float dline = sdLine(p, a, b);\n       \n    // barycentric coordinates\n    float u = 0.5;\n    float v = 1.0-u;\n        \n    // initial guess\n    vec2 x = u*a + v*b;\n    \n    col = vec3(1.0);\n    \n    col = gradient(sdf, vec3(0.0, 0.0, 1.0), vec3(1.0, 0.0, 1.0), 0.5)*0.8;\n    \n# if USE_GOLDEN_SECTION_SEARCH\n\n    float gr = (sqrt(5.0) + 1.0)/2.0;\n\n    u = 0.0;\n    v = 1.0;\n\n    float c = v - (v - u) / gr;\n    float d = u + (v - u) / gr;    \n\n#endif\n    \n    for (int i=0; i < 32; ++i)\n    {\n\n#if USE_GRADIENT_DESCENT        \n        \n        // projected gradient descent\n\t    vec2 dfdx = sdSceneGrad(x);               \n        float dfdu = dot(dfdx, a - b);\n       \n    \tconst float alpha = 0.05;\n\n\t\tu -= alpha*dfdu;\n\n        // projection\n\t    u = max(u, 0.0);\n        u = min(u, 1.0);\n        v = 1.0-u;\n\n\t\tx = u*a + v*b;\n#endif\n        \n#if USE_FRANK_WOLFE\n        \n        // Franke-Wolfe\n        vec2 dfdx = sdSceneGrad(x);\n        float da = dot(a, dfdx);\n        float db = dot(b, dfdx);\n        \n        vec2 s;\n        if (da < db)\n            s = a;\n        else\n            s = b;\n        \n        float gamma = 0.3*2.0/(float(i)+2.0);\n        \n        x = (1.0-gamma)*x + gamma*s;\n#endif\n\t    \n        \n#if USE_GOLDEN_SECTION_SEARCH\n        \n        // Golden Section Search\n\t\tfloat mid = (v + u) / 2.0;\n\n\t\tx = mid*a + (1.0-mid)*b;\n        \n        if (sdScene(a*c + b*(1.0-c)) < sdScene(a*d + b*(1.0-d)))\n            v = d;\n        else\n            u = c;\n\n        c = v - (v - u) / gr;\n        d = u + (v - u) / gr;                \n        \n#endif\n        \n        // visualize iterates\n        col += vec3(circle(p, x, 0.1))*vec3(0.0, 0.2, 0.0);\n    }\n          \n    col *= 1.0-isocontour(sdf, 0.01, 40.0)*0.2;\n    col *= 1.0-zerocontour(sdf, 0.01);\n\n    col *= vec3(1.0)-zerocontour(dline, 0.01);\n    blend(col, circle(p, a, 0.05));\n    blend(col, circle(p, b, 0.05));\n   \n    \n    // mouse cursor\n    //col += circle(p, mouse, 0.1)*vec3(0.4, 0.0, 0.0);    \n    \n    // closest point on line\n    blend(col, circle(p, x, 0.05));\n        \n    // closest point on the sdf\n    vec2 cp = x - sdSceneGrad(x)*sdScene(x);    \n    blend(col, circle(p, cp, 0.05));\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","name":"Image","description":"","type":"image"}]}