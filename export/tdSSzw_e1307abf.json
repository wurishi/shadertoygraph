{"ver":"0.1","info":{"id":"tdSSzw","date":"1553387215","viewed":540,"name":"Jump flood buddhabrot","username":"rory618","description":"Using just jump flood with a list of two nearset orbits to draw a buddhabrot, r to reset and swap between inverse buddhabrot","likes":15,"published":1,"flags":48,"usePreview":0,"tags":["particles","sort"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Deterministic particle sorting algorithm\n//using 7 stage 3x3 strided sorting stages split over 2 frames, in total just 36 or 27 calls to texelFetch per frame\n//Non recurrent, each frame is computed independent of the last, particles can jump around quickly with no adverse effects\n//Running at half speed, takes two frames to draw the image. I'm starting to like this approach, d 30 fps on shadertoy\n//feels a lot more than twice as powerful.\n//All that is done is getting particles to the closest pixel.\n//Particles affecting more than a single pixel are out of scope here for now.\n\n//Still no gaurentee that a pixel doesnt come up empty when there is a particle there, but chances of that happening\n//are reduced compared to previous approaches\n\n//See https://www.shadertoy.com/view/XsjyRm for another use of strided sort\n\n//No spatial decorrelation, sorting directly in image space to make for easy drawing of big particles.\n\n\n//Rendering in buf A\nvoid mainImage( out vec4 O, in vec2 I )\n{\n    #define T(a,b) texelFetch(iChannel0, ivec2(I)+ivec2(a,b),0)\n    O=T(0,0);\n    O=vec4(O.xyz/O.w,1);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//Simple newtonian particles\n//Use O.w for render pass\n\n//Uncomment to see the decorrelated image that is getting rendered\n//#define show_decorrelated\n\n//Drawing a particle\n//Need another pass or bigger output pass to draw bigger particles\n//For now just light up the pixel it lands in\n\n\n\n\nvoid mainImage( out vec4 O, in vec2 I )\n{\n    vec2 uv = I/R.xy;\n    vec3 r = rand3(IHash3(iFrame,I.x,I.y));\n    vec2 c = 1.*randn(r.xy);\n    vec2 z = vec2(0);\n    int j;\n    //Find a convergent or divergent orbit\n    for(j = 0;  j < 512; j++) {\n        z = mat2(z, -z.y, z.x) * z + c;\n        if(dot(z,z)>1e3){\n            break;\n        }\n    }\n    //After finding it, pick a random starting point somewhere in the orbit\n    //Then the next 16 points from that starting point will get drawn\n    //Too expensive to draw length 512 orbits all at once, but reasonable to do\n    //draw 8 iterations per particle at once, and just precalculate a starting point\n    //once per particle\n    if ((j!=512 == (texelFetch(iChannel3, ivec2(82,2),0).x>.5) ) && j > 48) {\n        \n        int n = int(r.z*float(j-16));\n    \tvec2 z = vec2(0);\n        for(j = 0;  j < n; j++) {\n        \tz = mat2(z, -z.y, z.x) * z + c;\n        }\n        \n        //Save a particle as a C value defining the orbit, and a start value at iteration n\n        O = (n<1)?vec4(0):vec4(c,z);\n    } else {\n        O = vec4(0);             \n    }\n    \n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define R iResolution\n#define iR ivec3(R)\n#define uR uvec3(R)\n#define IHash3(x,y,z) IHash(int(x)^IHash(int(y)^IHash(int(z))))\n#define dot2(o) dot((o),(o))\n#define tx(ch,p,R) texelFetch(ch, Zmod(p,iR.xy),0)\n\n//Roboust/universal integer modulus function\n#define Zmod(x,y) (((x)+(y)+(y)+(y))-(((x)+(y)+(y)+(y))/(y))*(y))\n//#define Zmod(x,y) ((x+y*10)%y)\n\nfloat packVec2(vec2 x){\n    return uintBitsToFloat(packSnorm2x16(x/10.));\n}\nvec2 umpackVec2(float x){\n    return unpackSnorm2x16(floatBitsToUint(x))*10.;\n}\n\nbool inbounds(vec2 x, vec2 y){\n    return (x.x>0.&&x.y>0.&&x.x<y.x&&x.y<y.y);\n}\n\n//RNG\nint IHash(int a){\n\ta = (a ^ 61) ^ (a >> 16);\n\ta = a + (a << 3);\n\ta = a ^ (a >> 4);\n\ta = a * 0x27d4eb2d;\n\ta = a ^ (a >> 15);\n\treturn a;\n}\n\nfloat Hash(int a){\n\treturn float(IHash(a)) / float(0x7FFFFFFF);\n}\nvec4 rand4(int seed){\n    return vec4(Hash(seed^0x34F85A93),\n                Hash(seed^0x85FB93D5),\n                Hash(seed^0x6253DF84),\n                Hash(seed^0x25FC3625));\n}\nvec3 rand3(int seed){\n    return vec3(Hash(seed^0x348CD593),\n                Hash(seed^0x8593FD5),\n                Hash(seed^0x62A5D384));\n}\nvec2 rand2(int seed){\n    return vec2(Hash(seed^0x348C5F93),\n                Hash(seed^0x8593D5BB));\n}\n\n\nvec2 randn(vec2 randuniform){\n    vec2 r = randuniform;\n    r.x = sqrt(-2.*log(1e-9+abs(r.x)));\n    r.y *= 6.28318;\n    r = r.x*vec2(cos(r.y),sin(r.y));\n    return r;\n}\n\n\n\n\n\n//Distance to mandelbrot set orbit\nfloat orbitDist(vec2 start, vec2 c, vec2 p, int iters){\n    float d = 1e9;\n    vec2 z = start;\n    int j = 0;\n    for(j = 0;  j < iters; j++) {\n        z = mat2(z, -z.y, z.x) * z + c;\n        d = min(d,length(z-p));\n        //if(dot(z,z)>1e3)\n        //    return d;\n    }\n    return(d);\n    \n}\n\nvec2 Ptoc(vec2 p, vec3 R){\n    return (p-R.xy/2.)/R.y*2. + vec2(-.25,0);\n}\n\n//Define a particle as a vec 4 containing the C value for an orbit and the initial z value\nfloat score(vec4 p, vec2 I, vec3 R){\n    if( p==vec4(0)) return 1e9;\n    \n    \n   \n    return max(0.,orbitDist(p.zw, p.xy, Ptoc(I,R), 8)*R.y-1.);\n}\n\nvoid updateRank(vec4 t, inout vec4 O, inout float s, vec2 I, vec3 R){\n    float sp = score(t,I,R);\n    if(sp<s){\n        s=sp;\n        O=t;\n    }\n}\n\n//Update ranking, save a list of two particle xy indices. O.xy is better particle, O.zw is a different not as good one\n/*void updateRank2x(vec2 t, inout vec4 O, inout float s0, inout float s1, vec2 I, vec3 R){\n    float sp = score(t,I,R);\n    if(sp<s0){\n        //Shift down the line\n        s1=s0;\n        O.zw=O.xy;\n        s0=sp;\n        O.xy=t;\n    } else if(sp<s1){\n        //Bump off the bottom one\n        s1=sp;\n        O.zw=t;\n        \n    }\n}*/","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"//Strided sort summarry:\n//Each pass looks at 9 xy locations stored in the previous pass and selects the closest one\n//The locations sampled are arranged in a 3x3 with the center located at I, and the spacing\n//a power of 3\n//Total 7 passes over two frames sized large to small\n//A->B->C->D->B->C->D->Image\n//Spacing 3^6 ..., 3^1, 3^0\n//I think this gives an optimal data path from each pixel to each other pixel under the constraint of 7 passes\n\n//In each buffer, the pixel to get drawn at index is saved in xy and the exact particle location is saved in zw.\n//For more complex particles zw should instead be a pointer to the particle\n//zw is unused for sorting, sort only based on xy\n\n\n//large to small\nvoid mainImage( out vec4 O, in vec2 I )\n{\n    //Split frames into two stages\n    int stage = iFrame%7;\n    \n    int size = (int[](729, 243, 81, 27, 9, 3, 1))[stage]; //729=3^6\n    float s0;\n    //init with top left corner and center\n    if(stage==0){\n        vec4 t0 = tx(iChannel0, ivec2(I)-size,R);\n                                                                         \n        s0 = score(t0,I,R);\n        \n        O=t0==vec4(0)?vec4(0):t0;\n        \n    } else {\n        O = tx(iChannel1, ivec2(I)-size,R );\n        s0 = score(O,I,R);\n    }\n    for(int i = 1; i < 9; i++){\n        if(stage==0){\n        \tvec4 t = tx(iChannel0,ivec2(I)-size+size*ivec2(i/3,i%3),R);\n            \n            updateRank(t,O,s0,I,R);\n            \n        } else {\n        \tvec4 t;\n            t = tx(iChannel1,ivec2(I)-size+size*ivec2(i/3,i%3),R); \n            updateRank(t,O,s0,I,R);\n        }\n        \n    }\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"void splat(inout vec3 O, vec2 I, vec4 p){\n    \n    float d2 = score(p,I,R);//max(0.,dot2(ip-p)-12.);\n    //COlor points based on the starting point associated with the particle\n    O += float(d2<0.5) *abs(cos(.2*p.zww*vec3(3,4,5)));\n    \n}\n\nvoid mainImage( out vec4 O, in vec2 I )\n{\n    vec2 uv = I/R.xy;\n    vec2 r = rand2(IHash3(iFrame,I.x,I.y));\n    \n    O = vec4(0,0,0,1);\n    \n    \n    \n    //for(int i = 0; i < 9; i++){\n        vec4 t = texelFetch(iChannel0,ivec2(I),0);\n        \n        splat(O.xyz,I,t);\n    //}\n    \n    //Accumulate over time\n    \n    int stage = iFrame%7;\n    if(stage!=6){\n        O = texelFetch(iChannel1,ivec2(I),0);\n    }\n    else {\n        O += texelFetch(iChannel1,ivec2(I),0);\n    }\n    if(texelFetch(iChannel3, ivec2(82,1),0).x>.5){O*=0.;}\n    //O.w = texelFetch(iChannel1,ivec2(I),0).w*10.;\n}","name":"Buffer C","description":"","type":"buffer"}]}