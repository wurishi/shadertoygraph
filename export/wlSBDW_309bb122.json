{"ver":"0.1","info":{"id":"wlSBDW","date":"1705683702","viewed":116,"name":"Capsule Mercury","username":"mathieu_h","description":"sadawsedgh","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["capsulerandomblob"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sfGRn","filepath":"/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","previewfilepath":"/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sfGzn","filepath":"/media/a/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png","previewfilepath":"/media/ap/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float MAX_TRACE_DISTANCE = 15.0;           // max trace distance\nconst float INTERSECTION_PRECISION = .005;        // precision of the intersection\nconst int NUM_OF_TRACE_STEPS = 10;\n\nconst float capture01 = 2189.59;\n\t\nvec3 startPoints[ 25 ];\nvec3 endPoints[ 25 ];\n\nfloat seed;\nvec2 m;\n\nfloat epsilon = 0.1;\n\nfloat fbm( vec3 p, vec3 n )\n{\n\tp *= 0.15;\n\tfloat x = texture( iChannel0, p.yz ).x;\n\tfloat y = texture( iChannel0, p.zx ).x;\n\tfloat z = texture( iChannel0, p.xy ).x;\n\treturn x*abs(n.x) + y*abs(n.y) + z*abs(n.z);\n}\n\nmat3 calcLookAtMatrix( in vec3 ro, in vec3 ta, in float roll )\n{\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(sin(roll),cos(roll),0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    return mat3( uu, vv, ww );\n}\n\nvoid doCamera( out vec3 camPos, out vec3 camTar, in float time, in float mouseX )\n{\n    float an = 0.3 + 10.0*mouseX;\n\tcamPos = vec3(3.5*sin(an),1.0,3.5*cos(an));\n    camTar = vec3(0.0,0.0,0.0);\n}\n\n\nfloat smin( float a, float b, float k ){\n    \n    float res = exp( -k*a ) + exp( -k*b );\n    return -log( res )/k;\n    \n}\n\nvec2 opU( vec2 d1, vec2 d2 ){\n    \n\treturn (d1.x<d2.x) ? d1 : d2;\n    \n}\n\nfloat opBlend( vec2 d1, vec2 d2 ){\n\n    return smin( d1.x , d2.x , 8.);\n    \n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\nfloat sdPlane( vec3 p )\n{\n\treturn p.y;\n}\n\nfloat rand(vec2 co)\n{\n  return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\n\nvec2 map( vec3 pos ){  \n    \n   \tvec2 res = vec2( 10., 0.0 );\n    \n    pos += (texture(iChannel2, mod(pos.xy, 10.)).rgb)*0.001;\n    pos += (texture(iChannel2, mod(pos.yz, 10.)).rgb)*0.001;\n    pos += (texture(iChannel2, mod(pos.xz, 10.)).rgb)*0.001;\n    \n    for( int i = 0; i < 25; i++ )\n    {\n        vec3 sp = texture( iChannel0 , vec2( float( i ) / 25. , .2 + sin( seed * .00005 ) * .1 )).xyz;\n        vec3 ep = texture( iChannel0 , vec2( float( i ) / 25. , .4 + sin( seed * .0001 ) * .1 )).xyz;\n\n        sp.x =( rand( sp.xy ) - .5 ) * 2.;\n        sp.y =( rand( sp.zy ) - .5 ) * 2.;\n        sp.z =( rand( sp.xz ) - .5 ) * 2.;\n       \n        ep.x =( rand( ep.xy ) - .5 ) * 2.;\n        ep.y =( rand( ep.zy ) - .5 ) * 2.;\n        ep.z =( rand( ep.xz ) - .5 ) * 2.;\n\n\n    \tfloat intersection = sdCapsule( pos , sp * 1. , ep * 1.  , .08 );\n    \tvec2 res2 = vec2( intersection ,  float( i ) + 1.);\n    \tres.x = opBlend( res ,  res2 );\n    }    \n   \treturn res;    \n}\n\nvec2 calcIntersection( in vec3 ro, in vec3 rd )\n{    \n    float h =  INTERSECTION_PRECISION*2.0;\n    float t = 0.0;\n\tfloat res = -1.0;\n    float id = -1.;\n    \n    for( int i=0; i< NUM_OF_TRACE_STEPS ; i++ )\n    {        \n        if( h < INTERSECTION_PRECISION || t > MAX_TRACE_DISTANCE ) break;\n\t   \tvec2 m = map( ro+rd*t );\n        h = m.x;\n        t += h;\n        id = m.y;        \n    }\n    if( t < MAX_TRACE_DISTANCE ) res = t;\n    if( t > MAX_TRACE_DISTANCE ) id =-1.0;    \n    return vec2( res , id );    \n}\n\nvec3 calcNormal( in vec3 pos ){\n    \n\tvec3 eps = vec3( 0.001, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t    map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n\t    map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n\t    map(pos+eps.yyx).x - map(pos-eps.yyx).x );\n\treturn normalize(nor);\n}\n\n\nfloat softshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n\tfloat res = 1.0;\n    float t = mint;\n    for( int i=0; i<50; i++ )\n    {\n\t\tfloat h = map( ro + rd*t ).x;\n        res = min( res, 20.*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( h<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n\n}\n\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.612*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos ).x;\n        occ += -(dd-hr)*sca;\n        sca *= 0.5;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n\nvoid WorldNormal (in vec2 p, out vec3 position, out vec3 normal, out float depth , out mat3 camMat)\n{\n    vec3 ro, ta;\n    doCamera( ro, ta, 0.0, iTime*0.3 );\n    camMat = calcLookAtMatrix( ro, ta, 0.0 );\n\tvec3 rd = normalize( camMat * vec3(p.xy, 1.5 ));\n    vec2 res = calcIntersection( ro , rd  );\n    vec3 pos = ro + rd * res.x;\n    \n    pos = (pos);\n    depth = length(pos);\n    position = pos;\n    normal = calcNormal(pos);\n    \n    if (depth * 0.6 > 1.0) depth = 0.0;\n    depth *= .7;\n    depth *= 1.0 - dot(p,p)*6.0;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    \n\tvec2 uv = fragCoord.xy / iResolution.xy;    \n    vec2 p = (-iResolution.xy + 2.0*fragCoord.xy)/iResolution.y;\n    m = iMouse.xy/iResolution.xy;\n    \n    float t = iTime;\n    seed = t;\n    \n    for( int i = 0; i < 25; i++ ){\n    \tstartPoints[i].x = sin( float(i) * t * .01  ); \n        startPoints[i].y = sin( float(i) * t * .01 * .2 );   \n       \tstartPoints[i].z = sin( float(i) * t * .01 * .5 );        \n        endPoints[i].x = sin( float(i)* t * .01  * 3. ); \n        endPoints[i].y = cos( float(i)* t * .01  * 1.2 );   \n       \tendPoints[i].z = cos( float(i)* t * .01  * .5 );        \n    }\n    \n    mat3 camMat;\n    vec3 col, pos, nor;\n    float d;\n\tWorldNormal(p, pos, nor, d, camMat);\n    col = inverse(camMat) * nor;\n    col = texture(iChannel1, col.xyz).rgb;\n    col *= pow(calcAO(pos, nor),1.9);\n    //col = vec3(d);\n    fragColor = vec4(col ,1.0);    \n}","name":"Image","description":"","type":"image"}]}