{"ver":"0.1","info":{"id":"XX3SDr","date":"1719125092","viewed":29,"name":"Fork iscg-2022- tktm04 562","username":"tktm04","description":"example","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["example"],"hasliked":0,"parentid":"fljfDc","parentname":"iscg-2022-example-raytracing"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// 単純なレイトレーシングの雛形\n\nstruct Ray\n{\n    vec3 org;\n    vec3 dir;\n};\n\nstruct Hit\n{\n    float distanceToHitpoint;\n    vec3 normal;\n};\n\n\n// 各種パラメータの例\n\nfloat FilmWidth() { return iResolution.x / 100.0; }\nfloat FilmHeight() { return iResolution.y / 100.0;  }\nfloat FilmDistance() { return 8.0; }\n\nvec3 CameraFrom() { return vec3(0.0, 0.0, 5.0); }\nvec3 CameraTo() { return vec3(0.0, 0.0, 0.0); }\nvec3 CameraUp() { return vec3(0.0, 1.0, 0.0); }\n\nfloat LargeFloat() { return 1e+6; }\n\n// 正規直交基底を計算する関数の例\nvoid createOrthoNormalBasis(\n    vec3 from, vec3 to, vec3 up,\n    out vec3 u, out vec3 v, out vec3 w, out vec3 e\n)\n{\n    w = normalize(from - to);\n    u = normalize(cross(up, w));\n    v = cross(w, u);\n    e = from;\n    // TODO: ベクトル正規化normalize()や外積cross()を用いて実装する。\n}\n\nvec3 convertToCameraCoordinateSystem(\n    vec2 pixelCoordinate\n)\n{\n    float x  = FilmWidth() * (1.0 - 2.0 * (pixelCoordinate.x + 0.5)/ iResolution.x);\n    float y = FilmHeight() * (1.0 - 2.0 * (pixelCoordinate.y + 0.5)/ iResolution.y);\n    float z = -FilmDistance();\n    // TODO: ピクセル座標をカメラ座標系に変換する。\n    return vec3(x, y, z);\n}\n\nRay generateCameraRay(\n    vec2 pixelCoordinate\n)\n{\n    // TODO: 以下を実装する。\n    // 1. ピクセル座標をカメラ座標系に変換\n    vec3 u, v, w, e;\n    createOrthoNormalBasis(CameraFrom(), CameraTo(), CameraUp(), u, v, w, e);\n    // 2. カメラパラメータからカメラ座標系の正規直交基底を計算。\n    vec3 cameraCoordinate = convertToCameraCoordinateSystem(pixelCoordinate);\n    // 3. ピクセル座標を基底を用いてワールド座標系に変換\n    vec3 rayDirection = (cameraCoordinate.x * u + cameraCoordinate.y * v + cameraCoordinate.z * w + e);\n    // 4. カメラレイを計算。\n    \n    Ray ray;\n    ray.org = e;\n    ray.dir = normalize(rayDirection);\n    return ray;\n}\n\nbool intersectToSphere(\n    vec3 center, float radius, Ray ray,\n    out Hit hit\n)\n{\n    // TODO: レイと球の交差判定を実装する。\n    // 二次方程式の解の計算に帰着する。\n    \n    vec3 co = ray.org - center;\n    \n    // 係数\n    float a = dot(ray.dir, ray.dir); \n    float b = 2.0 * dot(ray.dir, co); \n    float c = dot(co, co) - radius * radius;\n    \n    //判別式\n    float D = b * b - 4.0 * a * c;\n    \n    if (D < 0.0){\n        return false;\n    }\n    \n    float t = (-b - sqrt(D))/ (2.0  * a);\n    if (t < 0.0) {\n        t = (-b + sqrt(D)) / (2.0 * a);\n    }\n    if (t < 0.0) {\n        return false;\n    }\n    \n    \n    // 交点の情報を設定\n    hit.distanceToHitpoint = t;\n    hit.normal = normalize(ray.org + ray.dir * t - center); // 交点での法線\n    \n    return true;\n}\n\nbool intersect(Ray ray, out Hit hit)\n{\n    hit.distanceToHitpoint = LargeFloat();\n   \n    // TODO: intersectToSphere を用いて具体的な球との交差判定を行う。\n    vec3 sphereCen = vec3(0.0, 0.0, -1.0);\n    float shpereRad = 1.0;\n    \n    if (intersectToSphere(sphereCen, shpereRad , ray, hit)) {\n        return true; // 交差があれば true を返す\n    }\n\n    return false; // 交差がなければ false を返す\n}\n\nvec3 shade(Ray ray, Hit hit) {\n\n    return vec3(1.0, 1.0, 1.0);\n\n    // ライトの方向\n    vec3 lightDirection = normalize(vec3(0.0, 1.0, -1.0));\n\n    // 素材の色\n    vec3 materialColor = vec3(1.0, 1.0, 1.0);\n\n    // 拡散反射\n    float diff = max(dot(hit.normal, lightDirection), 0.0);\n\n    // 光の色と強度\n    vec3 lightColor = vec3(1.0, 1.0, 1.0); \n\n    vec3 color = materialColor * lightColor * diff;\n\n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    Ray ray = generateCameraRay(fragCoord);\n     \n    Hit hit;\n    if (intersect(ray, hit))\n    {\n        fragColor = vec4(shade(ray, hit), 1.0);\n    }\n    else\n    {\n        fragColor = vec4(1.0, 0.0, 0.0, 1.0);\n    }\n    // fragColor = vec4(1.0);\n}","name":"Image","description":"","type":"image"}]}