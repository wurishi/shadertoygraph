{"ver":"0.1","info":{"id":"4XtXz7","date":"1718877543","viewed":254,"name":"hilbert curve","username":"shadertoyjiang","description":"hilbert curve\n希尔伯特曲线\n参照 https://www.shadertoy.com/view/MljyRd\n","likes":38,"published":1,"flags":0,"usePreview":0,"tags":["curve","hilbert"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// 2024年6月20日                                 \n// hilbert curve\n// 参照 https://www.shadertoy.com/view/MljyRd\n\nint iter=3;\n\n#define rot(a) mat2(cos(a), -sin(a), sin(a), cos(a))\n\nfloat dln(in vec3 a, in vec3 b, in vec3 p){b-=a; p-=a;float h = clamp(dot(p,b)/dot(b,b), 0., 1.);return length(p - b * h);}\n\n\nvec4 clr=vec4(0);\n\nvoid cclr(vec3 p, float sid, float fan)\n{\n        float alp = atan(p.y,p.x)/(3.1415926535*.5)+1.;\n        alp =(alp-.5)*fan+.5;\n        sid += alp;\n        float spd = 25.,\n              nt = pow(8.,float(iter)) ,\n              t1= (mod(iTime*1., 1.+ nt/spd)-1.)*spd,\n              t2= (mod(iTime+nt/2./spd, 1.+ nt/spd)-1.)*spd;\n        clr *= 0.;\n        clr += 1.*exp(- .5 *abs(sid-t1) )*vec4(-5,5,2,1);\n        clr += 1.*exp(- .5 *abs(sid-t2) )*vec4(5,2,-5,1);\n}\n\nfloat sdcubeedge(vec3 p)\n{\n        vec3 a = abs(p) ,\n             m = 1.-step(a,a.yzx )*step(a,a.zxy );\n        return length( max(abs(a-2.)-.02, 0.)*m );\n}\n\nvec2 hrbt(vec3 p)\n{// 皮亚诺曲线（希尔伯特 hilbert curve） \n        //p = p*1./dot(p,p);\n        float d1 = length(max(abs(p)-2., 0.));\n       // if(d1>.3)return vec2(d1,999.);\n        float k = 1.;\n        float d3 = sdcubeedge(p);\n        #define fx vec3(1,0,0)\n        #define fy vec3(0,1,0)\n        #define fz vec3(0,0,1) \n        vec3 f[9]=vec3[9](fx, fz, -fy,-fz, fx, fz, fy, -fz, fy);\n        int  t[8]=int[](3,4,0,7,2,5,1,6);\n        int ind;\n        float sid=0.,fan=1.;\n        \n        //iter= 3  ;\n        \n        for(int i=0;i < iter; i++)       \n        {        \n                ind = int( .5+dot(vec3(1,2,4), sign(p)*.5+.5)  );\n                vec3 rx = f[t[ind]  ],\n                     ry = f[t[ind]+1],\n                     rz = cross(rx,ry),\n                     tx;\n                sid = sid * 8. + (float(t[ind])-3.5)*fan+3.5;// 就是反号倒序\n                if((ind<4)&&(ind!=2)) rz=-rz;\n                if((ind==0)||(ind==2)||(ind==5)||(ind==6)){tx=-rx, rx=-ry, ry=tx; fan=-fan;}\n                \n                \n                p = (p - sign(p))*2.;\n                k = k * 2.;\n                p = p*mat3(rx,ry,rz);\n        }\n        \n        vec3 q=min(abs(p+2.),abs(2.-p));\n        float d4 = min(q.x, min(q.y, q.z))/k;\n        if(d1>0.6)d4=1e3;\n        p-=vec3(-2,2,0);\n        cclr(p, sid, fan);\n        float d2= length(vec2(length(p.xy)-2.,p.z))- 1. ;\n        \n        if((sid==0.)||(int(sid+.5)==(1<<iter*3)-1)){\n               p+=vec3(-2,2,0); //p+=fx*1.;;    \n               d2 = min(length(p)-1.2, dln(p*0., -fx*5., p)-1.);\n        }\n        d2 = d2/k;\n        if(d3<d2)d2=d3,clr=vec4(8, 1.8,.0,.4)*.2;\n        return vec2(d2,d4);\n        //return max(d1, d2/k);\n}\n\nvec2 map(vec3 p)\n{\n        float t = (iTime-10.)*.2;\n        vec2 ms = iMouse.xy/iResolution.xy*6.28;\n        p.xy *= rot(t *1.2);p.yz *= rot(-t *.7);p.xz *= rot(t *.5);\n        p.xz *= rot(ms.x);\n        p.yz *= rot(ms.y);\n        return hrbt(p);\n        //return h2(p);\n}\n\n\nfloat softshadow(vec3 ro, vec3 rd )\n{\n   float res = 1.;\n   float t = .01, k= 1.8 ;\n   for(int i =0;i<25 && t<1.5;i++)\n   {              \n               float h = map(ro + rd * t).x;\n               if(h<.001)return 0.;               \n               res = min(res, k*h/t);\n               t += h;\n   }\n   return res * .5 + .5;\n}\n\n\nvoid mainImage(out vec4 O, vec2 U)\n{\n        O = vec4(.4);\n        vec2 R = iResolution.xy,\n             u = (U+U +.1- R) / R.y;\n        vec3 eye = vec3(0, 0, -7),\n             dir = normalize(vec3(u, 2)),\n             sun = 5. * ( .0*cos(iTime+vec3(7,11,13)) + vec3(-1,2,-5)/3.74 ),\n             eps = vec3(0, .0001, 0),\n             nor, p;\n        float  t=0.;\n        vec2 e;\n        for(int i=0; i<148 ;i++)\n        {\n                if(t>13.)break;\n                p = eye + dir * t;\n                e = map(p);\n                //e.x=min(e.x,e.y);\n                vec4 clrf=clr;\n                if( e.x<.01 )\n                {       // phong 光照模型\n                        nor = normalize(vec3(map(p+eps.yxx).x, map(p+eps).x, map(p+eps.xxy).x)-e.x); \n                        vec3  sp = normalize(sun-p), ep=normalize(eye-p);\n                        float ln = max(0., dot(nor,sp)),               // light norm\n                              er = max(0., dot(ep, reflect(-sp,nor))); // eye ray\n                        float ambt=.3, difu=.6, spec=80.;\n                        float shd=softshadow(p-dir*e.x,normalize(sun-p));\n                        //vec4  lightClr = vec4(1,.6,0,1).yyxw*.8+.3; O = clrf+lightClr * (ambt - er*.3 + difu*ln + pow(er, spec))*shd;\n                        vec4  lightClr = vec4(1.2,1.9,0,1)*.6+.1; O = clrf.xwww *5. +.5*lightClr * (ambt - er*.3 + difu*ln + pow(er, spec));\n                        O*=shd;\n                        O *= exp(-.1*(t+eye.z+2.));\n                        break;\n                }\n                t += min(e.x, max(e.y,.1)); // safe\n                //t += e.x * .5;// fast\n        }\n}\n\n\n\n\n","name":"Image","description":"","type":"image"}]}