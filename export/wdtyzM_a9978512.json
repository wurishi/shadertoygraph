{"ver":"0.1","info":{"id":"wdtyzM","date":"1600692206","viewed":392,"name":"Slime Mold (Draw with Mouse)","username":"resontone","description":"Control: Left Click + Drag\n\nSlime will grow at the edges of the wiped region.\n\nA version of the reaction-diffusion model. Feed and kill rates depend on the location on the screen.","likes":3,"published":1,"flags":32,"usePreview":0,"tags":["interactive","diffusion","reaction"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Output to screen\n    \n    //Inverts, darkens, and raises contrast of colour\n    fragColor = (1.-(texture(iChannel0, uv).xyxw * 2. - 0.3));\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//-----------------------------------------------------------------------------------\n//REACTION DIFFUSION SHADER\n//This shader implements a version of the reaction-diffusion model\n//It takes about 30-40 seconds to settle in\n//See https://en.wikipedia.org/wiki/Reaction%E2%80%93diffusion_system for more details\n//-----------------------------------------------------------------------------------\n\nconst float TWO_PI = 6.28318530718;\n\n\n//Random number generator\nfloat rand2(vec2 co){\n    return fract(sin(dot(co ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\n\n/*//Convenience function for sampling pixel colour\nvec4 cell( in ivec2 p )\n{\n    // do wrapping\n    ivec2 r = ivec2(textureSize(iChannel0, 0));\n    p = (p+r) % r;\n    \n    // fetch texel\n    return (texelFetch(iChannel0, p, 0 ));\n}*/\n\n\n\n\n//Convenience function for sampling pixel colour\n//PixelCoord = from 0. to 1.\nvec4 cellGLES2( in vec2 pixelCoord)\n{\n    // do wrapping\n    ivec2 r = ivec2(iResolution.x, iResolution.y);\n    \n    if(pixelCoord.x > 1. || pixelCoord.y > 1. || pixelCoord.x < 0. || pixelCoord.y < 0.)\n    {\n     \treturn(vec4(0.));   \n    }\n    \n    pixelCoord = fract(pixelCoord);\n    \n    // fetch texel\n    return (texture(iChannel0, pixelCoord, 0.));\n}\n\n\n//For chemical A\nfloat A_next(float A, float laplace, \n            float diffusion_rate_A, float B, float feed_rate, float delta_time)\n{\n    return(A + (diffusion_rate_A*laplace - A*B*B + feed_rate*(1.-A))*delta_time);\n}\n\n//For chemical B\nfloat B_next(float B, float laplace, \n            float diffusion_rate_B, float A, float kill_rate, float feed_rate, float delta_time)\n{\n    \n    return(B + (diffusion_rate_B*laplace + A*B*B - (kill_rate+feed_rate)*B)*delta_time);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 px = ivec2( fragCoord );\n    \n    vec2 uv_screen = fragCoord/iResolution.xy;\n    vec2 uv = (fragCoord-iResolution.xy*0.5)/iResolution.y;\n    vec2 pixelSize = 1./iResolution.xy;\n    \n\t//Output colour\n   \tvec4 col; \n    \n    \n   \t//The rates at which the two chemicals disperse\n    float diffusion_rate_A = 0.2;\n    float diffusion_rate_B = 0.1;  \n   \n    /*=======================================================================\n    //Setting kill rate and feed rate based on the location on the screen\n\tstripes \t\tk = 0.06\tf = 0.035\n    spots \t\t\tk = 0.0625 \tf = 0.035\n\tspiral waves \tk = 0.0475\tf = 0.0118\n    //=======================================================================*/\n    float kill_rate = 0.06;\n    float feed_rate = 0.035;\n    \n    \n    kill_rate = mix(0.0475, kill_rate, uv_screen.x);\n    feed_rate = mix(feed_rate, 0.0118, uv_screen.y);\n \n    feed_rate = mix(feed_rate, 0.035, 0.5+atan(uv.x, uv.y)/TWO_PI);\n    kill_rate = mix(kill_rate, 0.0625, 0.5+atan(uv.x, uv.y)/TWO_PI);\n    \n    \n    \n    //stability is always a risk with bigger timesteps\n    //we also don't want it to change too slowly\n    //1. is a good compromise\n    float timeDelta = 1.; \n    \n\n    //INITIALISING\n    if(iFrame < 10)\n    {\n        //g represents the quantity of chemical A\n        col.g = 1.;\n        //b represents the quantity of chemical B\n        col.b = 0.;\n        \n        //Noise\n        if(rand2(uv) > 0.9)\n       \t{\n            col.g = 0.5 + rand2(uv_screen+1.) * 0.02 - 0.01;\n        \tcol.b = 0.25 + rand2(uv_screen+2.) * 0.02 - 0.01;\n        }\n        col.w = 1.;\n\n    } \n    //EVERY FRAME AFTER\n    else\n    {\n        //CALCULATING THE LAPLACE FUNCTION\n        //The g (or y) component of the cell represents the quantity of chemical A in the cell \n        //The b (or z) component of the cell represents the quantity of chemical B in the cell \n        \n        //The laplace weights\n        float laplace_diag_weight = 0.05;\n        float laplace_edge_weight = 0.2;\n        float laplace_center_weight = 1.;\n        \n        //Following weights should sum to 2.. This roughly simulates gravity\n        float below_weight = 1.;\n        float above_weight = 1.;\n        \n        \n        //Laplace function is a weighted average of the neighbours minus a weighted version of the current cell\n        vec3 weightedNeigbourAverage = \n            laplace_edge_weight*(above_weight*cellGLES2(uv_screen + vec2(0.,-1.)*pixelSize)\n               + below_weight*cellGLES2(uv_screen + vec2(0.,1.)*pixelSize)\n               + cellGLES2(uv_screen + vec2(-1.,0.)*pixelSize)\n               + cellGLES2(uv_screen + vec2(1.,0.)*pixelSize)).xyz\n       \t\t+ laplace_diag_weight*(above_weight*cellGLES2(uv_screen + vec2(1.,-1.)*pixelSize)\n               + below_weight*cellGLES2(uv_screen + vec2(1.,1.)*pixelSize)\n               + below_weight*cellGLES2(uv_screen + vec2(-1.,1.)*pixelSize)\n               + above_weight*cellGLES2(uv_screen + vec2(-1.,-1.)*pixelSize)).xyz;\n        \n        vec4 currentCell = cellGLES2(uv_screen);\n        \n        \n        vec3 laplace = weightedNeigbourAverage - laplace_center_weight*currentCell.xyz;\n\t\tlaplace *= 2.;\n        \n        //CALCULATING THE NEW COLOUR VALUES\n        //Green represents chemical A\n        //Blue represents chemical B\n        col.g = A_next(currentCell.y, laplace.y, diffusion_rate_A, currentCell.z, feed_rate, timeDelta);\n       \tcol.b = B_next(currentCell.z, laplace.z, diffusion_rate_B, currentCell.y, kill_rate, feed_rate, timeDelta);\n    }\n    \n    if(iMouse.z > 0.5)\n    {\n    \n        \n        if(length((fragCoord.xy - iMouse.xy)/iResolution.y) < 0.05)\n        {\n            if(length((fragCoord.xy - iMouse.xy)/iResolution.y) > 0.0485)\n            {\n                col.g = 0.5;\n                col.b = 0.25;\n            }\n        }\n    }\n    \n    //Red is only for display purposes, and is not part of the reaction.\n    //Red does not represent a chemical\n    col.r = mix(col.g, 1.0-col.b, 0.5);\n    fragColor = col;\n}","name":"Buffer A","description":"","type":"buffer"}]}