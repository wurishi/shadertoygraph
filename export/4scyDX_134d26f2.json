{"ver":"0.1","info":{"id":"4scyDX","date":"1520646284","viewed":363,"name":"Apollonianscopic KIFS Deep Remix","username":"Loadus","description":"Deeper remix of the Apollonianscopic KIFS by gPlatl. ","likes":10,"published":1,"flags":0,"usePreview":0,"tags":["ifs","kaleidoscope"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n// Apollonianscopic kifs remix\n\n// original creator wyatt, https://www.shadertoy.com/view/Xdcyzl\n// Apollonianscopic version gPlatl https://www.shadertoy.com/view/4scyRs\n\n// Tags: apollonian, kifs, fractal, fractal, inversion, koleidoscope\n\nmat3 m;\nfloat k;\nmat3 rot (vec3 s) {\n\tfloat \tsa = sin(s.x),\tca = cos(s.x),\n\t\t\tsb = sin(s.y),\tcb = cos(s.y),\n\t\t\tsc = sin(s.z),\tcc = cos(s.z);\n\treturn mat3 (\n\t\t\tvec3(cb*cc, -cb*sc, sb),\n\t\t\tvec3(sa*sb*cc+ca*sc, -sa*sb*sc+ca*cc, -sa*cb),\n\t\t\tvec3(-ca*sb*cc+sa*sc, ca*sb*sc+sa*cc, ca*cb));\n}\n\nvec3 app (vec3 v) {\n\tfor (int i = 0; i < 10; i++)\n        v = abs(k*m*v/dot(v,v)*0.5-0.5)*2.-1.; \n    return v;\n}\n\nvec3 ap (vec3 v) {\n\tfor (int i = 0; i < 10; i++)\n        v = abs(k*m*v/dot(v,v)*0.5-0.5)*2.-1.; \n    return v;\n}\n\nvec3 norm (vec3 p) {\n\t\tvec2 e = vec2 (.05,0.);\n    \tvec3 g = ap(p);\n\t\treturn normalize(vec3(\n\t\t\t\tap(p+e.xyy).x - g.x,\n\t\t\t\tap(p+e.yxy).y - g.y,\n\t\t\t\tap(p+e.yyx).z - g.z));\n}\n\nfloat SCurve (float value, float amount, float correction) {\n\n\tfloat curve = 1.0; \n\n    if (value < 0.5)\n    {\n\n        curve = pow(value, amount) * pow(2.0, amount) * 0.5; \n    }\n        \n    else\n    { \t\n    \tcurve = 1.0 - pow(1.0 - value, amount) * pow(2.0, amount) * 0.5; \n    }\n\n    return pow(curve, correction);\n}\n\nconst float PI = 3.14159265359;\n\n//----------------------------------------------------------------\nvoid smallKoleidoscope(inout vec2 uv, float ka)\n{\n  float angle = abs (mod (atan (uv.x, uv.y), 2.0 * ka) - ka) + 0.01*iTime;\n  uv = length(uv) * vec2(cos(angle), sin(-angle));\n}\n//----------------------------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n    vec2 uv = fragCoord.xy/iResolution.xy*2.-1.;\n    uv.x *= iResolution.x/iResolution.y;\n\n    vec2 mp = vec2(0.1, 0.1); //iMouse.xy / iResolution.xy;\n    uv *= 0.2 + 10. * mp.x;\n    float sideCount = -7.0; //1.0 + round(mp.y * 11.0);\n    smallKoleidoscope (uv, PI / sideCount);\n    \n    float t = 0.015 * iTime;\n    m = rot(t + vec3(2, 3, 5));\n    k = 1.3 + 0.1 * sin(0.008 * iTime);\n    vec3 v = (0.5 + 0.25 * sin(0.003 * iTime)) * m * vec3(2.0 * uv, 0);\n    vec3 col = sin(app(v + iTime * 0.0001)) * 0.5 + 0.5;\n    \n    col = col * 0.8 + 0.2 * (sin(norm(v)) * 0.5 + 0.5);\n    col = col * 0.7 + 0.1;\n\n    \n    \tfloat gm = 1.0/2.2;\n    \tcol = vec3(pow(col.r, gm), pow(col.g, gm), pow(col.b, gm));\n    \tcol.r = SCurve(col.g * 0.3 + col.r * 0.7, 6.0, 2.2);\n    \tcol.g = SCurve(col.g * 0.5 + col.b * 0.5, 4.0, 2.2);\n    \tcol.b = SCurve(col.g * 0.3 + col.b * 0.7, 2.0, 2.2);\n    \n        col.g = col.g * 0.9 + 0.1;\n        col.b = col.b * 0.7 + 0.3;\n  \n    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}