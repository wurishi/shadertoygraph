{"ver":"0.1","info":{"id":"Wd2yDK","date":"1587351810","viewed":95,"name":"Day5: Raymarching 101","username":"fluxatron","description":"Just learning how to ray march in shader toy. \n\nBased on Ray Marching for Dummies: https://www.youtube.com/watch?v=PGtv-dBi2wE","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS 200\n#define MAX_DIST 200.0\n#define SURFACE_DIST 0.005\n\n// TYPES ///////////////////////////////////////////////////////////////////////////////////////////////////\nstruct Ray\n{\n    vec3 Origin;\n    vec3 Direction;\n};\n/*struct Material\n{\n    vec3 Color;\n};\nstruct Hit\n{\n    vec3 Point;\n    float Distance;\n    Material Material;\n};*/\nstruct Light\n{\n    vec3 Pos;\n    vec3 Color;\n    float Intensity;\n};\n    \n    \nstruct Hit\n{\n    float Dist;\n    vec3 Color;\n};\n    \n// FUNCS ///////////////////////////////////////////////////////////////////////////////////////////////////\n    \nHit GetDist(vec3 p)\n{\n    Hit closest;\n    \n    // Pivot\n    /*{\n        vec3 col = vec3(0.5,0.5,0.5);\n        vec4 shape = vec4(0,0,0, 0.25); // pos,radius\n        float dist = length(p - shape.xyz) - shape.w;\n       \n        closest.Dist = dist;\n        closest.Color = col;\n    }*/\n    \n    // Sphere X\n    {\n        vec3 col = vec3(1,0,0);\n        vec4 shape = vec4(-1.2,0,0, 0.5); // pos,radius\n        float dist = length(p - shape.xyz) - shape.w;\n       \n        //if (dist < closest.Dist)\n        {\n            closest.Dist = dist;\n        \tclosest.Color = col;\n        }\n    }\n    \n    \n    // Sphere Y\n    {\n        vec3 col = vec3(0,1,0);\n        vec4 shape = vec4(0,0,0, .5); // pos,radius\n        float dist = length(p - shape.xyz) - shape.w;\n\n        if (dist < closest.Dist)\n        {\n            closest.Dist = dist;\n            closest.Color = col;\n        }\n    }\n    \n    // Sphere Z\n    {\n        vec3 col = vec3(0,0,1);\n        vec4 shape = vec4(1.2,0,0, .5); // pos,radius\n        float dist = length(p - shape.xyz) - shape.w;\n\n        if (dist < closest.Dist)\n        {\n            closest.Dist = dist;\n            closest.Color = col;\n        }\n    }\n    \n    // Plane\n    {\n        vec3 col = vec3(.5,.5,.5);\n        float dist = p.y+0.5; // ground at y=0\n\n        if (dist < closest.Dist)\n        {\n            closest.Dist = dist;\n            closest.Color = col;\n        }\n    }\n    \n    return closest;\n}\n\nHit RayMarch(Ray r)\n{\n    Hit lastHit;\n    float totalDist = 0.0;\n    \n    for (int i=0; i<MAX_STEPS; i++)\n    {\n        vec3 p = r.Origin + totalDist*r.Direction;\n        lastHit = GetDist(p);\n        totalDist += lastHit.Dist;\n        if (totalDist < SURFACE_DIST || totalDist > MAX_DIST) \n            break;\n    }\n    \n    lastHit.Dist = totalDist;\n    \n    return lastHit;\n}\n\nvec3 GetNormal(vec3 p)\n{\n    float d = GetDist(p).Dist;\n    float offset = 0.01;\n    vec3 n = d - vec3(\n        GetDist(p - vec3(offset,0,0)).Dist,\n        GetDist(p - vec3(0,offset,0)).Dist,\n        GetDist(p - vec3(0,0,offset)).Dist\n        );\n    \n    return normalize(n);\n}\n\nvec3 GetLight(vec3 p, Light light)\n{\n    vec3 lightNormal = normalize(light.Pos-p);\n    vec3 surfNormal = GetNormal(p);\n    \n    // Light\n    float strength = clamp(dot(surfNormal, lightNormal), 0., 1.);\n\n    // Shadow\n    Ray shadow;\n    shadow.Origin = p + surfNormal*SURFACE_DIST*2.;\n    shadow.Direction = lightNormal;\n    if(RayMarch(shadow).Dist < length(light.Pos-p)) strength = 0.0;\n    \n    return light.Intensity * light.Color * strength;\n}\n\nvec3 ACESFitted(vec3 color);\n\n\n// MAIN ////////////////////////////////////////////////////////////////////////////////////////////////////\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.yy; // map to center:(0, 0), topright:(aspect/2, 0.5)\n    \n    // Camera\n    Ray r;\n    r.Origin = vec3(0,0.75,-5);\n    r.Direction = normalize(vec3(uv.x, uv.y-0.25, 2));\n    \n    \n    // Hit scene\n    Hit hit = RayMarch(r);\n    vec3 p = r.Origin + r.Direction*hit.Dist; // intersection point\n    \n    \n    // Direct Light\n    vec3 directLight = vec3(0);\n    {\n        Light l1;\n        l1.Pos = vec3(0, 2, 0) + 5.0 * vec3(sin(iTime), 1.0, cos(iTime));\n        l1.Color = vec3(1.0,0.6,0.5);\n        l1.Intensity = 1.0;\n\n        Light l2;\n        l2.Pos = vec3(5, 5, -5);\n        l2.Color = vec3(1.0,0.7,0.5);\n        l2.Intensity = 0.5;\n\n        directLight += hit.Color * GetLight(p, l1);\n    \t//directLight += GetLight(p, l2);\n    }\n    \n    \n    // Ambient Light\n    vec3 ambient = hit.Color * 0.8*vec3(0.02,0.02,0.08);\n    \n    \n    // Compose colour\n    vec3 col = ambient + vec3(directLight);\n    \n    \n    // Post\n    col *= 1.0; // exposure bias\n  \tcol = ACESFitted(col); // tonemap \n   \tcol = pow(col, vec3(1.0/2.2)); // gamma\n    \n    \n\tfragColor = vec4(col,1.0);\n}\n\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n// ACES Tonemap: https://github.com/TheRealMJP/BakingLab/blob/master/BakingLab/ACES.hlsl\nconst mat3 ACESInputMat = mat3(\n\t0.59719, 0.07600, 0.02840, \n\t0.35458, 0.90834, 0.13383,\n\t0.04823, 0.01566, 0.83777\n);\nconst mat3 ACESOutputMat = mat3(\n\t 1.60475, -0.10208, -0.00327,\n\t-0.53108,  1.10813, -0.07276,\n\t-0.07367, -0.00605,  1.07602\n);\nvec3 RRTAndODTFit(vec3 v)\n{\n\tvec3 a = v * (v + 0.0245786) - 0.000090537;\n\tvec3 b = v * (0.983729 * v + 0.4329510) + 0.238081;\n\treturn a / b;\n}\nvec3 ACESFitted(vec3 color)\n{\n\tcolor = ACESInputMat * color;\n\tcolor = RRTAndODTFit(color);\n\tcolor = ACESOutputMat * color;\n\tcolor = clamp(color,0.0,1.0);\n\treturn color;\n}\n","name":"Image","description":"","type":"image"}]}