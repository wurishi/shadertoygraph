{"ver":"0.1","info":{"id":"flsczS","date":"1648220768","viewed":273,"name":"True Volumetric Fog Balls","username":"Hyeve","description":"A better demonstration of the volumetrics that my raymarcher is capable of handling. The only thing changing in this scene is how refractive the balls are, nothing else. Unfortunately, it's very sensitive to artifacts in the SDF, so only a simple scene :(","likes":12,"published":1,"flags":0,"usePreview":0,"tags":["3d","raymarching","transparency","volumetric","fog"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n#define DTR 0.01745329\n#define rot(a) mat2(cos(a),sin(a),-sin(a),cos(a))\n\nvec2 uv;\nvec3 cp,cn,cr,ro,rd,ss,oc,cc,gl,vb;\nvec4 fc;\nfloat tt,cd,sd,io,oa,td,tc;\nint es=0,ec;\n\nvec3 lattice(vec3 p, int iter, float an)\n{\n\t\tfor(int i = 0; i < iter; i++)\n\t\t{\n\t\t\tp.xy *= rot(an*DTR);\n\t\t\tp = abs(p) - 1.;\n\t\t\tp.xy *= rot(-an*DTR);\n\t\t\tp.xz *= rot(an*DTR);\n\t\t}\n\t\treturn p;\n}\n\nfloat mp(vec3 p)\n{\n\t\tvec3 pp=p;\n\t\t\n\t\tp.xz*=rot(tt*0.1);\n\t\tp.xy*=rot(tt*0.1);\n\n\t\tp=lattice(p,6,2.);\n\t\n\t\tsd = length(p) - 0.9;\n\t\n\t\tfloat an = pow(1. - pow(sin(tt*0.3)*0.5+0.5, 5.), 10.);\n\t\n\t\tsd=abs(sd)-0.001;\n\n\t\tif(sd<0.001)\n\t\t{\n\t\t\toc=normalize(pp*pp*vec3(0.2,0.,0.8));\n\t\t\tio=1.05 - an * 0.05;\n\t\t\toa=0.;\n\t\t\tss=vec3(0);\n\t\t  vb=vec3(1.,2.4,1.5+length(pp)*0.4);\n\t\t\tec=2;\t\n\t\t}\n\t\treturn sd;\n}\n\nvoid tr(){vb.x=0.;cd=0.;for(tc=0.;tc<512.;tc++){mp(ro+rd*cd);cd+=sd;td+=sd;if(sd<0.0001||cd>128.)break;}}\nvoid nm(){mat3 k=mat3(cp,cp,cp)-mat3(.001);cn=normalize(mp(cp)-vec3(mp(k[0]),mp(k[1]),mp(k[2])));}\n\nvoid px()\n{\n  cc=vec3(0.6,0.6,0.6)+length(pow(abs(rd+vec3(0,0.5,0)),vec3(3)))*0.3+gl/tc;\n  vec3 l=vec3(0.9,0.7,0.5);\n  if(cd>128.){oa=1.;return;}\n  float df=clamp(length(cn*l),0.,1.);\n  vec3 fr=pow(1.-df,3.)*mix(cc,vec3(0.4),0.5);\n\tfloat sp=(1.-length(cross(cr,cn*l)))*0.2;\n\tfloat ao=min(mp(cp+cn*0.3)-0.3,0.3)*0.4;\n  cc=mix((oc*(df+fr+ss)+fr+sp+ao+gl/tc),oc,vb.x);\n}\n\nvoid render(vec2 frag, vec2 res, float time, out vec4 col)\n{\n\ttt=mod(time, 260.);\n  uv=vec2(frag.x/res.x,frag.y/res.y);\n  uv-=0.5;uv/=vec2(res.y/res.x,1);\n  ro=vec3(0,0,-12);rd=normalize(vec3(uv,1));\n  \n\tfor(int i=0;i<25;i++)\n  {\n\t\ttr();cp=ro+rd*cd;\n    nm();ro=cp-cn*0.01;\n    cr=refract(rd,cn,i%2==0?1./io:io);\n    if(length(cr)==0.&&es<=0){cr=reflect(rd,cn);es=ec;}\n    if(max(es,0)%3==0&&cd<128.)rd=cr;es--;\n\t\tif(vb.x>0.&&i%2==1)oa=pow(clamp(cd/vb.y,0.,1.),vb.z);\n\t\tpx();fc=fc+vec4(cc*oa,oa)*(1.-fc.a);\t\n\t\tif((fc.a>=1.||cd>128.))break;\n  }\n  col = fc/fc.a;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    render(fragCoord.xy,iResolution.xy,iTime,fragColor);\n} ","name":"Image","description":"","type":"image"}]}