{"ver":"0.1","info":{"id":"MfjGzD","date":"1704489101","viewed":101,"name":"A Cloud of Spheres","username":"kastorp","description":"wait 20 sec for data loading...\n\n\n","likes":8,"published":1,"flags":48,"usePreview":0,"tags":["pointcloud","sorting","jfa"],"hasliked":0,"parentid":"ftlfD8","parentname":"Pixel XOR Sorting 4x"},"renderpass":[{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[],"code":"// \"A cloud of Spheres\" by Kastorp\n//-----------------------------\n//  wait 20 sec for data load\n//\n//  buffer A: Spheres XOR Sorting by grid position\n//  buffer B: for each grid cell, get number of spheres, initial position and last position\n//  buffer C: use JFA to get distance from the closest non empty grid cell\n//  image: Voxel traversal  with distance acceleration. \n//         For every grid cell, iterate over the contained spheres\n//\n//  keys:\n//   \n//    A: toggle data loading on/off (get a bit of framerate after data is loaded)\n//    B: debug buffer A cloud sorting (if sorting is completed, there should not be white dots)\n//    C: shadows on/off\n//    D: lattice on/off\n//    E: restart sorting\n//    F: show spheres crossing grid border\n//    SPACE: zoom\n//\n//-----------------------------------------\n\n\n\nfloat map(vec3 p){\n    \n    vec3 c=vec3(convM.x,convM.y,convM.z*convM.w)*.5;\n    p+=c;\n    vec4 t= texelFetch(iChannel0,ivec2(to2d(floor(p.xyz))),0);\n    vec4 d1 = T(vec3(p.xy,floor(p.z))),\n         d2 = T(vec3(p.xy,ceil(p.z))),        \n         d= mix(d1,d2,fract(p.z)); //trilinear interpolation\n         d.w= d.w-1.; \n    return min(-sdBox(p-c,c),(d.w));\n   \n}\n\nvec3 calcN(vec3 p,float t) {\n\n    float h = .002*t;\n\tvec3 n = vec3(0);\n\tfor (int i = min(iFrame, 0); i < 4; i++) {\n\t\tvec3 e = .5773 * (2. * vec3((((i + 3) >> 1) & 1), (i >> 1) & 1, i & 1) - 1.);\n\t\tn += e * map(p + e * h);\n\t}\n\treturn normalize(n);\n  \n}\n\nfloat ray(vec3 ro, vec3 rd,float st, out vec3 n, out vec3 seed) {\nif( key(68,2))   {\n    //lattice\n\tvec3 p;\n    n=vec3(0);\n\tfloat d = .001;\n\tfor (float i = 0.; i <st; i++) {\n\t\tp = ro + rd * d;\n\t\tfloat h = map(p);\n\t\tif (abs(h) < .001  )break;\n        if(d >convM.x*20.) return 1e5;\n\t\td += h;\n\t}\n    seed= floor(ro+rd*d);\n    n=calcN(ro+rd*d,d) ;\n    return d;\n}else{\n    //spheres\n     n=vec3(0);\n     ivec2 R=ivec2(RR);  \n    vec3 ird =1.0/rd;\n    float isize = 1.;       \n    vec3 p,mpos,rpos;\n    float t= 0.;\n    int ah=( key(70,2)?1:0);\n    \n    for ( float i=0.; i<(st); i++ ) {\n         p = ro + t*rd - .499*isize ;\n         mpos= floor(p/isize +.5) *isize ; \n         rpos=p-mpos;\n         vec4 td=texelFetch(iChannel0,ivec2(to2d(floor(mpos+convM.x*.5))),0);\n         if(td.w>3.) t+=td.w-2.; // advance using SDF\n         else{\n             //voxel traversal\n             vec3 t2 = -ird*rpos +abs(ird)*vec3(.5)*isize;\n             float d = min( min( t2.x, t2.y ), t2.z ); \n             float tim=1e5;\n             vec3 ni;\n             for(int m =0;m<=ah;m++){ //trick: advance a step to catch spheres near border\n                 vec3 sh=(m>0?vec3(0,1,0):vec3(0));\n                 vec4 data  =texelFetch(iChannel2,ivec2(to2d(floor(sh+mpos+convM.x*.5))),0);\n                 bool hit = data.w>0.;\n                 if (hit) { //there's something inside the cell \n                      if(data.w<80.){\n                        \n                        for(int j =0;j<int(data.w) ;j++){ //iterate spheres inside cell\n                            if(m>0 && j>int(data.x-data.y)) break;// if tangent grid, check only border spheres\n                            int k = int(data.y)+ j;\n                            vec4 sp=texelFetch(iChannel1,ivec2(k%R.x,k/R.x),0);\n                            vec3 s =sp.xyz *convM.x -floor(convM.x*.5) ;\n                           // s=mpos+hash32(vec2(j,k));\n                            vec2 ti =iSphere(ro -s,rd,.1*sp.w,ni);\n                            if(ti.x!=-1.&& ti.x<tim) { tim=ti.x;n=-ni; seed=s;}\n                        }\n                        if(tim<1e5) {return tim;}\n\n                      }\n                     else {\n                         //more than 80 spheres --> display as cube\n                          rpos= abs(fract(ro+t*rd) -.5);\n                          n= -step(rpos.yzx,rpos)*step(rpos.zxy,rpos)*sign(rd);\n                         seed=mpos; \n                         return t;\n                     } \n                 }\n                 \n             }\n             t+=d+.0001; //next cell\n         }\n         if(t >convM.x*1.) return 1e5; // no hit\n    }\n    return 1e5;\n}\n}\n\n\n\nvec3 color(vec3 seed ){\n    return vec3(hash(seed.xy+14.), hash(seed.yz*2.1-17.), hash(seed.zx*1.4)) * .9 + .1;\n}\n\n//Iq\nvec3 vignette(vec3 c, vec2 fc) {\n\tvec2 q = fc.xy / iResolution.xy;\n\tc *=  .5 + .5 * pow(16. * q.x * q.y * (1. - q.x) * (1. - q.y), .4);\n\treturn c;\n}\n\nvec3 getRayDir(vec3 ro, vec3 lookAt, vec2 uv) {\n\tvec3 f = normalize(lookAt - ro),\n\t\t r = normalize(cross(vec3(0,1., 0), f));\n\treturn normalize(f + r * uv.x + cross(f, r) * uv.y);\n}\n\nvec3 render(vec3 ro, vec3 rd) {\n    vec3 n;\n    vec3 seed;\n    float d=ray(ro,rd,120.,n,seed);\n    vec3 p=ro+d*rd;\n    \n    vec3 c=vec3(convM.x,convM.z*convM.w,convM.y)*.5;    \n    vec3 col= sdBox(p,c)>-.2?vec3(0.145,0.302,0.333):color(seed); \n    vec3 ld = normalize( vec3(6.,6.,18.) );\n\n\tfloat ao = 1.,\n\tl1 = .5 + .5 * dot(ld, n),\n\tspe = max(0., dot(rd, reflect(ld, n))) * .2,\n\tfre = smoothstep(.7, 1., 1. + dot(rd, n));\n    if( key(67,2))   { \n        float ds=ray(p+.005*n, ld,50.,n,seed);\n        l1 *= .3+ .7* step(-.2,sdBox(p+ld*ds,c));\n    }    \n\tvec3 lig = clamp(l1 * ao + spe,0.,5.) * vec3(4.)*mix(.3, .4, fre)  ;\n      \n\treturn mix(vec3(.01,.01,.02), col*lig,exp(-d*d * .00002));\n}\n\n\nvoid mainImage(out vec4 O, vec2 fc)\n{\t\n    ivec2 R=ivec2(RR);\n    setM(convM,iResolution.xy);\n    if( key(66,2)) { //debug buffer A\n        int j = (int(fc.x) + int(fc.y)*R.x)+1;\n        ivec2 fcp= ivec2(j%R.x,j/R.x);\n        \n        vec4 pa=texelFetch(iChannel1, ivec2(fc),0),\n             pb=texelFetch(iChannel1, ivec2(fcp),0);\n        O =pa*pa.w;\n        pa.xyz=floor(pa.xyz*convM.x);pa.xyz=floor(pb.xyz*convM.x);\n        pa.w=float(pa.w>0.); pb.w=float(pb.w>0.); \n        bool cmp= compare(pa,pb);\n    \n        if(cmp) O=vec4(1); //highligth unordered spheres\n        return;       \n    }\n    \n    \n    vec2 m=3.14*(iMouse.xy/iResolution.xy-.5);\n    float t=iTime*.3;\n\tvec3 ro = ( iMouse.x>0.)? convM.x*.4*vec3(cos(m.x)*cos(m.y),sin(m.y),sin(m.x)*cos(m.y)):vec3(cos(t),1,sin(t))*convM.x*.3;\t\n\tvec2 uv = (fc - .5 * iResolution.xy) / iResolution.y;\n    if( iMouse.x<=0.) uv*=(.6+.4*sin(t*.3));\n    else if( key(32,0))  uv=uv/8.; //zoom\n\tO = vec4(vignette(pow(render(ro, getRayDir(ro, vec3(0), uv)), vec3(.4)), fc), 0);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//Spheres XOR Sorting by grid position\n//https://www.shadertoy.com/view/ftlfD8\n\n\n#define D 4 //if FPS<60, use D=2\n#define SW(a,b)  { if(compareB(v[a],v[b])) {vec4 t = v[a]; v[a] =v[b]; v[b] = t; } }\n\n\n\nvec4[2*D] sort(vec4[2*D] v){\n    SW(0,1); SW(2,3); SW(0,2); SW(1,3); SW(1,2); \n#if D>2\n    SW(4,5); SW(6,7); SW(4,6); SW(5,7); SW(5,6);\n    SW(0,4); SW(1,5); SW(1,4); SW(2,6); SW(3,7); \n    SW(3,6); SW(2,4); SW(3,5); SW(3,4);\n#endif\n    return v;\n}\n\nvec3 gaussian(vec3 r)\n{\n    float a=.14, ia = 1.0 / a, K = 2.0 / (3.1416 * a);\n    r=r*2.-1.;\n\tvec3 y = vec3(log(1.0 - r.x*r.x),log(1.0 - r.y*r.y),log(1.0 - r.z*r.z));\n\tvec3 z = K + 0.5 * y;\n\treturn sign(r) *vec3(\n        sqrt(sqrt(z.x*z.x - y.x * ia) - z.x), \n        sqrt(sqrt(z.y*z.y - y.y * ia) - z.y),\n        sqrt(sqrt(z.z*z.z - y.z * ia) - z.z)\n        );\n}\n\nvoid mainImage( out vec4 O, in vec2 U )\n{   \n\n    if(key(65,2)) {O = texelFetch(iChannel0, ivec2(U),0);return;}\n    \n     ivec2 R=ivec2(RR);\n     setM(convM,iResolution.xy);\n    //if(any(greaterThan(U,RR))) discard;\n    if(iFrame<1 ||  key(69,0)){\n        O=vec4(0);\n         //O.xyz=gaussian(hash32(U*.119))*.25+.5; O.w=.5;\n         O.xyz= hash32(U*.119)*.4+.3; O.w=float(length(O.xyz-.5)<.15)* step(hash12(U+.77),.3);\n         //O.xyz= hash32(U*.119)*.3+.35; O.w=.2;\n         float id =float( int(U.y)*R.y+int(U.x));\n         //if(id<RR.x*RR.y/32.) O=vec4(vec3(.5)+.2*vec3(id/(RR.x*RR.y/32.)-.5,cos(id/100.*6.2832),sin(id/100.*6.2832)),.5);\n         //if(id>RR.x*RR.y*.48)  O=vec4(.5 ,max(hash32(U*.117),vec3(.01)));\n         float t=hash12(U*.117)*6.283,r=floor(hash12(U*.217)*200.)/200.*.2+.17;\n         if(id<RR.x*RR.y/32.) O=vec4(.5+cos(t)*r,.51,.5+sin(t)*r,.5);\n         //if(O.w==0.) O=vec4(0);\n        //if(id<24000.){ //fibonacci sphere distibution\n        //   float y = 1. - (id / (24000. - 1.)) * 2.,               \n        //   th = 3.1416* (sqrt(5.) - 1.) * id;\n        //   O=vec4(vec2(cos(th),sin(th))* sqrt(1. - y * y),y,0)*.2 +vec4(.5,.5,.5,1.5);        \n        //}\n        return;\n    }        \n   \n    \n    int l= int(log2(RR.x*RR.y))-2, //maximum xor level\n        z=(iFrame/2)%l,zz=1<<z, //current xor level; also zz=1<<(2*z) works, with z<=l/2\n        ii = (int(U.x) + int(U.y)*R.x), //current position\n        i=ii/zz, //xor position\n        s= ((i&D)/D == (iFrame&1)) ?0:1, //sorting side s=0 left, S=1 right\n        m= s*D +(i&(D-1)), //relative position in sort array\n        h= min(i -(i&(D-1)),i -(i&(D-1))-s*D) ; //first position in array  \n                \n    vec4[2*D] P; //sorting array\n    for(int k=0;k<2*D;k++){\n         int j=(h+k)*zz + (ii%zz); //k-th absolute position\n         P[k]=texelFetch(iChannel0,ivec2(j%R.x,j/R.x),0); //fill with previous values \n    }\n    \n    if(h>=0 && (h+D)*zz  < ((R.x*R.y)&((1<<24)-D*zz)))  O =sort(P)[m]; ///sort only if inside boundaries\n    else O=vec4(P[m]);   //otherwise keep order\n    \n}\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"\n#define RR iResolution.xy \n#define key(a,b) texelFetch(iChannel3, ivec2(a,b),0).x>.5\n//never without those\nfloat sdBox( in vec3 p, in vec3 b )\n{\n    vec3 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(max(d.x,d.y),d.z),0.0);\n}\n\nvec2 iSphere( in vec3 ro, in vec3 rd, float ra ,out vec3 oNor)\n{\n    float b = dot( ro, rd );\n    float h = b*b - dot( ro, ro ) + ra*ra;\n    if( h<0. ) return vec2(-1); // no intersection\n    h = sqrt( h );\n    oNor =-normalize(ro-(b+h)*rd);\n    return h-b < 0. ? vec2(-1) : -b-h>=0. ?  vec2(-b-h,+b-h): vec2(0.);\n\n}\n\n//---------------------------------\n// Hoskins hash without sine from http://shadertoy.com/view/4djSRW\n\nfloat hash(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.zyx + 31.32);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec3 hash32(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//--------------------------\n//helper functions\n\nvec4 convM; //x,y,zx,zy\n\nvec3 to3d(vec2 c){\n   return  vec3(mod(c.x,convM.x),mod(c.y,convM.y),floor(c.x/convM.x)+ floor(c.y/convM.y)*convM.z);\n\n} \n\nvec2 to2d(vec3 c){\n    vec4 p1 = vec4( mod(c.x,convM.x),mod(c.y,convM.y),floor(mod(c.z,convM.z)),floor(c.z/convM.z));\n    return vec2(p1.x +p1.z*convM.x,p1.y +p1.w*convM.y);\n} \n\n\nvoid setM(inout vec4  convM, vec2 R){\n    float l = floor(pow(R.x*R.y,.33));\n    //l=exp2(ceil(log2(l)));\n    convM= vec4(l,l,floor(R.x/l),floor(R.y/l) );\n}\n\n#define T(p) Tex(iChannel0, iResolution.xy,p)\nvec4 Tex(sampler2D ch,vec2 R, vec3 p){\n    return texture(ch, to2d(p) / R);\n}\n\n bool compare(vec4 a,vec4 b) { \n    vec4 pa=floor(a*convM.x),pb=floor(b*convM.x); \n    pa.w=float(a.w>0.); pb.w=float(b.w>0.);     \n    return  (pa.w<pb.w) || (pa.w==pb.w && pa.x<pb.x) || (pa.w==pb.w && pa.x==pb.x && pa.y< pb.y) || (pa.w==pb.w && pa.x==pb.x && pa.y== pb.y && pa.z<pb.z); \n    //alternative sort\n   // return  (pa.x<pb.x)  || (pa.x==pb.x && pa.y< pb.y) || (pa.x==pb.x && pa.y== pb.y && pa.z<pb.z) || (pa.x==pb.x && pa.y== pb.y && pa.z==pb.z &&  pa.w<pb.w);\n\n }\n \nbool  compareB(vec4 a,vec4 b) { \n    vec4 pa=floor(a*convM.x),pb=floor(b*convM.x); \n    pa.w=float(a.w>0.); pb.w=float(b.w>0.); \n    if(pa.w==pb.w && pa.x==pb.x && pa.y== pb.y && pa.z==pb.z){\n        vec4 fa =abs(fract(a*convM.x)-.5),fb =abs(fract(b*convM.x)-.5);\n        int ba= int(max(max(fa.x,fa.y),fa.z)>.4), bb= int(max(max(fb.x,fb.y),fb.z)>.4);\n        return ba>bb;\n    }else \n    return  (pa.w<pb.w) || (pa.w==pb.w && pa.x<pb.x) || (pa.w==pb.w && pa.x==pb.x && pa.y< pb.y) || (pa.w==pb.w && pa.x==pb.x && pa.y== pb.y && pa.z<pb.z); \n }","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"//BUFFER B: grid indexing\n// for each grid cell, get number of spheres, initial position and last position\n//-------------------------------------------------\n\nvoid mainImage( out vec4 O, in vec2 U )\n{\n\n   if( key(65,2)) {O = texelFetch(iChannel1, ivec2(U),0);return;}\n   O=vec4(0);\n   ivec2 R=ivec2(RR);\n   setM(convM,iResolution.xy);  \n   vec3 p=floor(to3d(U)); //the grid position\n   \n   int id = R.x*R.y/2,sz=id;\n#if 1   \n   //bisection search for  a value in the current grid\n   for(int i=0;i<30;i++){\n       vec4 t =floor(texelFetch(iChannel0,ivec2(id%R.x,id/R.x),0)*convM.x);\n     \n       bool cmp0=  (t.w>0. && t.x==p.x && t.y== p.y && t.z==p.z);\n       bool cmp1= compare(t,vec4(p,1)); \n       bool cmp2= compare(vec4(p,1),t); \n   \n       if(cmp0) {O=vec4(id)/float(R.x*R.y); break;} ///found\n       else if(cmp1) {id= id-sz/2;sz/=2;}\n       else if(cmp2) {id= id+sz/2;sz/=2;}\n       else {O=vec4(0); return;} //unordered\n       \n       if(sz==0) break;\n   }\n   \n   if(O.x>0.){\n       //if found, get initial and last position\n        int id1,id2,id3;\n        int S=max(sz*8,64);\n        for(int i=0;i<S;i++){\n           id1=id-i;\n           \n           vec3 t =floor(texelFetch(iChannel0,ivec2(id1%R.x,id1/R.x),0).xyz*convM.x );\n           bool cmp=  (t.x==p.x && t.y== p.y && t.z==p.z);\n           if(!cmp) break;\n        }\n        for(int i=0;i<S;i++){\n           id2=id+i;\n           \n           vec3 t =floor(texelFetch(iChannel0,ivec2(id2%R.x,id2/R.x),0).xyz*convM.x );\n           bool cmp=  (t.x==p.x && t.y== p.y && t.z==p.z);\n           if(!cmp) break;\n        } \n        for(int i=0;i<S;i++){\n            id3=id1+i+1; \n            vec3 t =floor(texelFetch(iChannel0,ivec2(id3%R.x,id3/R.x),0).xyz*convM.x );         \n            vec3 fa =abs(fract(texelFetch(iChannel0,ivec2(id3%R.x,id3/R.x),0).xyz*convM.x)-.5);\n            bool isBorder=max(max(fa.x,fa.y),fa.z)>.4;\n            bool cmp=  (t.x==p.x && t.y== p.y && t.z==p.z);\n            if(!isBorder || !cmp) break;\n        }\n        \n        O=vec4(id3,id1+1,id2,id2-id1);\n        if(id1>id || id2<id ||id3>id2) O=vec4(0);\n   }\n#else\n    //alternative algorithm, which is actually slower\n\n   //bisection search for lower offset\n   for(int i=0;i<30;i++){\n       vec4 t =floor(texelFetch(iChannel0,ivec2(id%R.x,id/R.x),0)*convM.x);\n     \n       bool cmp0=  (t.w>0. && t.x==p.x && t.y== p.y && t.z==p.z);\n       bool cmp1= compare(t,vec4(p,1)); \n       bool cmp2= compare(vec4(p,1),t); \n   \n       \n       if(cmp0 || cmp1) {id= id-sz/2;sz/=2;}\n       else if(cmp2) {id= id+sz/2;sz/=2;}\n       \n       if(sz==0) break;\n   }\n   int id1=id;\n   id = R.x*R.y/2,sz=id;\n   \n   //bisection search for higher offset\n   for(int i=0;i<30;i++){\n       vec4 t =floor(texelFetch(iChannel0,ivec2(id%R.x,id/R.x),0)*convM.x);\n     \n       bool cmp0=  (t.w>0. && t.x==p.x && t.y== p.y && t.z==p.z);\n       bool cmp1= compare(t,vec4(p,1)); \n       bool cmp2= compare(vec4(p,1),t); \n   \n       \n       if( cmp1) {id= id-sz/2;sz/=2;}\n       else if(cmp0 || cmp2) {id= id+sz/2;sz/=2;}\n       \n       if(sz==0) break;\n   }\n   int id2=id;\n   O=vec4(id2>id1,id1,id2-1,id2-id1-1);\n#endif   \n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"//BUFFER C: use jfa to get distance from the closest non empty grid celle\n//--------------------------------------------------------------\n\n// JFA steps to do (resolution should be a power of 2)\nint maxSteps;// = 13;\n\n// frames between steps.  1 = full speed.\nconst int frameStepDelay = 1; //5; //15; //50; //\n\nfloat sqr(vec3 v) { return dot(v, v); }\n\nvec3 StepJFA(vec3 p, int level)\n{\n    level = maxSteps - 1 - level; // reverse order: coarse to fine works much better\n    level = clamp(level, 0, maxSteps);\n    vec3 best = vec3(-1000);\n    float bestd2 = 3e38,\n    w = float(1 << level);   \n    for (float z = -w; z <= w; z+= w)\n    for (float y = -w; y <= w; y += w)\n    for (float x = -w; x <= w; x += w) {\n        vec3 c=vec3(x,y,z);\n        if(all(lessThan(c+p,vec3(convM.x,convM.y,convM.z*convM.w))) && all(greaterThanEqual(c+p,vec3(0)))) {\n        \n            vec3 seed = T(c + p).xyz;\n            if (seed.x >= 0.) {\n                float d2 = sqr(seed -  p);\n                if (bestd2 > d2) {\n                    bestd2 = d2;\n                    best = seed;\n                }\n            }\n        }\n    }\n    return best;\n}\n\nbool isSeed(vec3 p)\n{   \n   vec2 U = to2d(p);\n   vec4 t = texelFetch(iChannel1, ivec2(U),0);\n   return t.w>0.;  \n}\n            \nvoid mainImage(out vec4 o, vec2 fc) // fragCoord\n{\n    if( key(65,2)) {o = texelFetch(iChannel0, ivec2(fc),0);return;}\n    if(max(fc.x,fc.y)<1.){o=vec4(iResolution.xyxy);return;}\n    vec3 seed;\n    ivec2 R=ivec2(RR);\n   \n    setM(convM,iResolution.xy);\n    maxSteps=int(log2(convM.x))+3;\n    int f = iFrame ;\n    vec3 pos =to3d(fc);\n    \n    if(isSeed(pos)) seed= floor(pos);\n    else if (f == 0 || key(69,0) || iResolution.x!=texelFetch(iChannel0,ivec2(0),0).x) {\n        seed =  vec3(-1);\n    } \n    else  seed =  StepJFA(pos, f  - 1);\n    \n    o = vec4(seed, length(pos-seed)); // output data has closest seed location in xy\n}","name":"Buffer C","description":"","type":"buffer"}]}