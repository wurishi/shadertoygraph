{"ver":"0.1","info":{"id":"ddfXD4","date":"1668890145","viewed":173,"name":"raymarch + dithering","username":"garrisonhh","description":":)","likes":12,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","dithering"],"hasliked":0,"parentid":"msXXD4","parentname":"figuring out raymarching"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// --- world ---\nstruct Sphere {\n    vec3 pos;\n    float radius;\n    vec3 color;\n};\n\n\nconst int SPHERE_COUNT = 3;\nconst Sphere[] SPHERES = Sphere[SPHERE_COUNT](\n    Sphere(vec3(0.0, 0.0, 70.0), 20.0, vec3(1.0, 0.4, 0.0)),\n    Sphere(vec3(20.0, 0.0, 50.0), 10.0, vec3(0.0, 0.75, 0.0)),\n    Sphere(vec3(-10.0, 10.0, 60.0), 8.0, vec3(0.5, 0.1, 1.0))\n);\n\n// --- raymarch impl ---\nconst int ITERATIONS = 100;\nconst float RENDER_DIST = 100.0;\nconst float HIT_EPSILON = 0.1;\n\nstruct HitResult {\n    bool hit;\n    vec3 color;\n    vec3 normal;\n    float dist;\n};\n\nHitResult raymarch(vec3 pos, vec3 dir) {\n    float travelled = 0.0;\n\n    for (int i = 0; i < ITERATIONS; ++i) {\n        // find closest safe move distance\n        float closest_dist = RENDER_DIST;\n        \n        for (int j = 0; j < SPHERE_COUNT; ++j) {\n            Sphere sphere = SPHERES[j];\n            float dist = distance(pos, sphere.pos) - sphere.radius;\n            \n            // test for hit\n            if (dist < HIT_EPSILON) {\n                vec3 normal = normalize(pos - sphere.pos);\n                return HitResult(true, sphere.color, normal, travelled);\n            }\n            \n            closest_dist = min(dist, closest_dist);\n        }\n        \n        // hit, iterate\n        pos += dir * closest_dist;\n        travelled += closest_dist;\n        \n        // check if outside of range\n        if (travelled > RENDER_DIST) {\n            break;\n        }\n    }\n\n    // no hit\n    return HitResult(false, vec3(0), vec3(0), travelled);\n}\n\n\n// --- main ---\nconst float POV = 0.5;\nconst float CAMERA_DIST = 1.0 / tan(POV); // distance of camera to screen\nconst vec3 ILLUM_DIR = normalize(vec3(0.1, 0.8, 0.1)); // global illumination\nconst int PIXEL_SCALE = 3; \n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // pixelate coordinate\n    ivec2 pixel_coord = ivec2(fragCoord) / PIXEL_SCALE;\n    vec2 rel_coord = float(PIXEL_SCALE) * (vec2(pixel_coord) + vec2(0.5)) / iResolution.xy;\n\n    // calculate coord scaled to [-1.0, 1.0] and adjusted to resolution\n    vec2 coord = rel_coord * 2.0 - vec2(1.0);\n    coord.y = -coord.y;\n    coord.y *= iResolution.y / iResolution.x;\n    \n    // raymarch\n    vec3 dir = normalize(vec3(coord.x, coord.y, CAMERA_DIST));\n    HitResult res = raymarch(vec3(0), dir);\n    \n    // determine color\n    fragColor = vec4(0, 0, 0, 1);\n    \n    if (res.hit) {\n        float lum = 1.0 - dot(ILLUM_DIR, res.normal);\n        fragColor.xyz = res.color * lum;\n    }\n    \n    // postprocess\n    fragColor.rgb = paletteProcess(fragColor.rgb, pixel_coord);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// https://lospec.com/palette-list/highlighter-24\nconst int PALETTE_COUNT = 24;\nconst vec3[] PALETTE = vec3[PALETTE_COUNT](\n    vec3(0.09019607843137255, 0.09019607843137255, 0.09803921568627451),\n    vec3(0.3568627450980392, 0.23137254901960785, 0.5058823529411764),\n    vec3(0.5607843137254902, 0.5411764705882353, 0.7294117647058823),\n    vec3(0.7372549019607844, 0.36470588235294116, 0.8666666666666667),\n    vec3(1.0, 0.37254901960784315, 0.807843137254902),\n    vec3(1.0, 0.7764705882352941, 0.8627450980392157),\n    vec3(0.5529411764705883, 0.26666666666666666, 0.3137254901960784),\n    vec3(0.8901960784313725, 0.4627450980392157, 0.3176470588235294),\n    vec3(1.0, 0.7725490196078432, 0.6784313725490196),\n    vec3(0.6509803921568628, 0.15294117647058825, 0.1803921568627451),\n    vec3(0.8745098039215686, 0.25882352941176473, 0.36470588235294116),\n    vec3(1.0, 0.6078431372549019, 0.3254901960784314),\n    vec3(1.0, 0.9294117647058824, 0.0),\n    vec3(0.6745098039215687, 0.8823529411764706, 0.10196078431372549),\n    vec3(0.25098039215686274, 0.6666666666666666, 0.42745098039215684),\n    vec3(0.25882352941176473, 0.4117647058823529, 0.2235294117647059),\n    vec3(0.12941176470588237, 0.21176470588235294, 0.6823529411764706),\n    vec3(0.11764705882352941, 0.47843137254901963, 0.807843137254902),\n    vec3(0.13333333333333333, 0.8352941176470589, 0.8117647058823529),\n    vec3(0.34901960784313724, 1.0, 0.8470588235294118),\n    vec3(0.25882352941176473, 0.27450980392156865, 0.2901960784313726),\n    vec3(0.40784313725490196, 0.43137254901960786, 0.4588235294117647),\n    vec3(0.7137254901960784, 0.7137254901960784, 0.7137254901960784),\n    vec3(1.0, 1.0, 1.0)\n);\n\nconst ivec2 DITHER_SIZE = ivec2(2, 2);\nconst int PATTERN_COUNT = 5;\nconst uint[] PATTERNS = uint[PATTERN_COUNT](\n    // each is a bitmask of width DITHER_SIZE.x * DITHER_SIZE.y\n    0x0u,\n    0x8u,\n    0x9u,\n    0x7u,\n    0xFu\n);\n\nvec3 paletteProcess(vec3 color, ivec2 pixel) {\n    // find the 2 closest colors\n    const vec3 color0 = PALETTE[0];\n    float dist0 = distance(color, color0);\n    vec3[] close_colors = vec3[2](color0, color0);\n    float[] close_dists = float[2](dist0, dist0);\n\n    for (int i = 1; i < PALETTE_COUNT; ++i) {\n        float dist = distance(color, PALETTE[i]);\n        \n        if (dist < close_dists[0]) {\n            close_dists[1] = close_dists[0];\n            close_dists[0] = dist;\n            close_colors[1] = close_colors[0];\n            close_colors[0] = PALETTE[i];\n        }\n    }\n    \n    // find dither pattern\n    float dither_diff = pow(close_dists[0] / (close_dists[0] + close_dists[1]), 3.0);\n    int dither_pattern = int(round(dither_diff * float(PATTERN_COUNT)));\n \n    // get pattern bit from dither pattern + pixel pos\n    ivec2 dither_pos = pixel % DITHER_SIZE;\n    int pattern_bit = dither_pos.y * DITHER_SIZE.x + dither_pos.x;\n    \n    // calculate color based on pattern bit\n    uint dither_scalar = (PATTERNS[dither_pattern] >> pattern_bit) & 1u;\n    return close_colors[0] + float(dither_scalar) * (close_colors[1] - close_colors[0]);\n}","name":"Common","description":"","type":"common"}]}