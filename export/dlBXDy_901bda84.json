{"ver":"0.1","info":{"id":"dlBXDy","date":"1676514995","viewed":162,"name":"Potted plant","username":"ianertson","description":"A potted plant!\nUse the mouse to look around :)","likes":11,"published":1,"flags":0,"usePreview":0,"tags":["3d","raytracing","raymarching","raymarch","rays","raytrace","plant","pottedplant"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","previewfilepath":"/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// set to something above 1 to get rid of the noise :)\n#define AA_SAMPLES 0\n\n// global illumination (very bad and expensive)\n// Also needs AA_SAMPLES to be above 1 to look somewhat good.\n#define GI_BOUNCES 0\n\n#define NEAR 0.003\n#define FAR 100.0\n#define STEPS 86\n#define ZERO (min(0, int(iTime)))\n#define ZEROF (min(0.0, iTime))\n#define SAMPLE(var, id_) if(id_ != data.skip && var < dist) { data.id = id_; dist = var; }\n#define adot(a, b) (abs(dot(a, b)))\n#define rgb(a, b, c) (vec3(a, b, c)/255.0)\n\nstruct Material {\n    float rough;\n    vec3 spec;\n};\n\n#define NEW_MATERIAL Material(0.99315, vec3(1.0))\n\n#define ID_NONE 0\n#define ID_GROUND 1\n#define ID_BOX 2\n#define ID_POT 3\n#define ID_STICK 4\n#define ID_FLOWER 5\n\nstruct Data {\n    vec3 p;\n    vec3 n;\n    vec2 uv;\n    vec2 uvSp;\n    float d;\n    int id;\n    int skip;\n    Material m;\n};\n\n#define NEW_DATA Data(vec3(0.0), vec3(0.0), vec2(0.0), vec2(0.0), FAR, 0, 0, NEW_MATERIAL)\n\n#define LIGHT_AMBIENT 0\n#define LIGHT_POINT 1\n\nstruct Light {\n    vec3 p;\n    vec3 c;\n    float s;\n    int type;\n};\n\nvec3 getLightDir(in Light light, in vec3 p) {\n    if (light.type == LIGHT_AMBIENT) return normalize(light.p);\n    return normalize(light.p - p);\n}\n\nvec3 getLightAtt(in Light light, in vec3 p, in vec3 n) {\n    vec3 L = getLightDir(light, p);\n    float NdotL = max(0.0, dot(n, L));\n    if (light.type == LIGHT_AMBIENT) return light.c * light.s * NdotL;\n    float d = distance(light.p, p);\n    float amp = pow(light.s, 2.0) / max(0.0001, pow(d, 2.0));\n    return light.c * NdotL * amp;\n}\n\n\nfloat potSDF(vec3 p, float s, float h, float r) {\n    float w = 0.5 - (p.y);\n    \n    float a = max(length(p) - r, 0.0) - dot((p*0.6)-vec3(0, -0.3, 0), vec3(0, w, 0));\n    a = max(a, p.y-h);\n    \n    p.y -= 0.01;\n    float b = max(length(p) - (r-0.03), 0.0) - dot((p*0.6)-vec3(0, -0.3, 0), vec3(0, w, 0));\n    b = max(b, p.y-h);\n    \n    return max(a, -b);\n}\n\nfloat lineSDF(vec3 p, vec3 a, vec3 b, float t) {\n    vec3 ba = b - a;\n    vec3 pa = p - a;\n    float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    return length((pa - h * ba))-t;\n}\n\nfloat stickSDF(vec3 p, vec3 a, vec3 b, float t) {\n    p.x -= cos(p.y*TAU)*0.02;\n    p.z += sin(p.y*TAU)*0.02;\n    t -= textureLod(iChannel3, vec2(p.y*TAU)/256., 0.0).r*0.016;\n    vec3 ba = b - a;\n    vec3 pa = p - a;\n    float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    return length((pa - h * ba))-t;\n}\n\n\nfloat boxSDF(in vec3 p, in vec3 s) {\n  p = abs(p) - s;\n  return length(max(p, 0.)) + min(max(p.x, max(p.y, p.z)), 0.);\n}\n\nfloat groundSDF(in vec3 p) {\n    return p.y;\n}\n\nvec3 snoise(vec3 p) {\n    vec3 n1 = textureLod(iChannel3, vec2(p.x, p.y)/256., 0.0).xyz;\n    vec3 n2 = fract((n1*p.z)*10.02381)*0.03;\n    return (n1 + n2) /2.0;\n}\n\nvec3 snoise(vec3 p, float freq) {\n    float amp = 1.0;\n    float div = 0.0;\n    vec3 n = vec3(0.0);\n    \n    n += amp * snoise(p*freq); div += amp; amp /= 2.0; freq *= 2.0;\n    n += amp * snoise(p*freq); div += amp; amp /= 2.0; freq *= 2.0;\n    n += amp * snoise(p*freq); div += amp; amp /= 2.0; freq *= 2.0;\n    \n    return n / div;\n}\n\nfloat flowerSDF(in vec3 p, float r) {\n\n    vec3 n = snoise(p, 24.0);\n    \n    n = n * 2.0 - 1.0;\n    \n    p += n*0.05;\n    \n    float d = length(p) - r;\n    return d;\n}\n\nfloat getDist(inout Data data, in vec3 p) {\n    float dist = FAR;\n    \n    float ground = groundSDF(p);\n\n    vec3 boxPosA = vec3(0, 0.5, 0.);\n    vec3 boxSizeA = vec3(0.5, 0.8, 0.5);\n    \n    \n    float offset = 1.0 / 0.9;\n    vec3 boxSizeB = (boxSizeA*vec3(0.9, 1.5, 0.9)) + vec3(0, 0, 0);\n    vec3 boxPosB = boxPosA + vec3(0, 0.25, -0.2);\n    \n    boxPosB += vec3(0, (boxSizeA.y-boxPosA.y)+0.2, 0);\n    \n    float box = boxSDF(p - boxPosA, boxSizeA);\n    float box2 = boxSDF(p - (boxPosB - vec3(0, boxSizeB.y*0.5, 0)), vec3(boxSizeB.x, boxSizeB.y*0.5, boxSizeB.z));\n    box = max(box, -box2);\n\n    float pot = potSDF(p - vec3(0, 0.26, 0), 2.1, 0.1, 0.1);\n    \n    float stick1 = stickSDF(p - vec3(0, 0, 0.0), vec3(0.0, 0.0, 0.0), vec3(0.0, 0.7, 0.0), 0.02);\n    \n    float flower1 = flowerSDF(p - vec3(0.0, 0.68, 0.01), 0.12);\n    \n    p -= vec3(0.0, 0.3, 0.0);\n    p.xy *= rot(radians(20.));\n    float stick2 = stickSDF(p - vec3(0.0, 0.0, 0.0), vec3(0.0, -0.1, 0.0), vec3(0.0, 0.3, 0.0), 0.02);\n    float stick = min(stick1, stick2);\n    \n    float flower2 = flowerSDF(p - vec3(0.0, 0.3, 0.0), 0.09);\n    \n    float flower = min(flower1, flower2);\n    \n    SAMPLE(ground, ID_GROUND);\n    SAMPLE(box, ID_BOX);\n    SAMPLE(pot, ID_POT);\n    SAMPLE(stick, ID_STICK);\n    SAMPLE(flower, ID_FLOWER);\n\n    \n    return dist;\n}\n\nvec3 getNormal(inout Data data, in vec3 p) {\n    vec2 e = vec2(0.001, 0.0);\n    return normalize(getDist(data, p) - vec3(\n        getDist(data, p - e.xyy),\n        getDist(data, p - e.yxy),\n        getDist(data, p - e.yyx)\n    ));\n}\n\nvec2 getUv(inout Data data, in vec3 p) {\n    vec3 n = data.n;\n    vec2 uv = vec2(0.0);\n    uv = mix(uv, p.xy, adot(n, vec3(0, 0, 1)));\n    uv = mix(uv, p.xz, adot(n, vec3(0, 1, 0)));\n    uv = mix(uv, p.yz, adot(n, vec3(1, 0, 0)));\n    \n    data.uvSp = sphereUv(p);\n    \n    return uv;\n}\n\nbool march(inout Data data, in vec3 ro, in vec3 rd) {\n    float dist = 0.0;\n    \n    for (int i = ZERO; i < STEPS; i++) {\n        vec3 p = ro+rd*dist;\n        float next = getDist(data, p);\n        dist += next;\n        \n        if (abs(next) <= NEAR) break;\n        if (abs(dist) >= FAR) return false;\n    }\n    \n    vec3 p = ro+rd*dist;\n    data.p = p;\n    data.d = dist;\n    data.n = getNormal(data, p);\n    data.uv = getUv(data, p);\n    \n    return true;\n}\n\nfloat getShadow(int skip, in vec3 ro, in vec3 rd, in float near, in float far) {\n    Data data = NEW_DATA;\n    data.skip = skip;\n    float dist = 0.0;\n    \n    for (int i = ZERO; i < STEPS; i++) {\n        vec3 p = ro+rd*dist;\n        float next = getDist(data, p);\n        dist += next;\n        \n        if (abs(next) <= NEAR || abs(dist) >= far) break;\n    }\n    dist = abs(dist);\n    if (dist >= far) return 1.0;\n    \n    #if GI_BOUNCES > 0\n    return clamp(dist / max(0.0001, 0.9+near), 0.0, 1.0);\n    #else\n    return dist / max(0.0001, near);\n    #endif\n}\n\nvec3 potTexture(in vec2 uv) {\n    float n = texNoise2D(iChannel3, uv, 34.0, 1.28315, 0.0);\n    return vec3(n);\n}\n\nvec3 getAlbedoPot(inout Data data) {\n    vec2 uv = data.uvSp;\n    vec3 col = potTexture(uv);\n    float l = luma(col);\n    \n    \n    float d = 0.002;\n    \n    vec3 n = normalize(l - vec3(\n        luma(potTexture(uv + vec2(d, 0))),\n        luma(potTexture(uv + vec2(0, d))),\n        0.7\n    ));\n    \n    data.n = normalize(mix(data.n, n,clamp(dot(n, data.n), 0.0, 1.0)));\n    \n    data.m.rough = luma(col);\n    \n    return col;\n}\n\nvec3 getAlbedoGround(inout Data data) {\n    vec3 col = vec3(0.0);\n    vec2 uv = data.uv;\n    \n    float depth = max(0.0, data.d-NEAR);\n    float lod = smoothstep(0.0, 0.1, depth/FAR)*6.;\n    \n    col += textureLod(iChannel0, uv, lod).rgb;\n    vec3 n = getNormal(\n        iChannel0,\n        uv,\n        0.06,\n        0.3,//0.5,\n        lod*0.5\n    );\n    \n   // n = fixBump(data.n, n);\n    //n = vec3(n.z, n.y, n.x);\n    n = normalize(n);\n   \n    data.m.rough = max(0.0, 1.0 - luma(col));\n    \n    data.n = normalize(mix(data.n, n,clamp(dot(n, data.n), 0.0, 1.0)));\n    \n    return col;\n}\n\nvec3 getAlbedoBox(inout Data data) {\n    vec3 col = vec3(0.0);\n    vec2 uv = data.uv;\n    \n    float depth = max(0.0, data.d-NEAR);\n    float lod = smoothstep(0.0, 0.1, depth/FAR)*6.;\n    \n    col += textureLod(iChannel2, uv, lod).rgb;\n    vec3 n = getNormal(\n        iChannel2,\n        uv,\n        0.06,\n        0.5,\n        lod*0.5\n    );\n    data.m.rough = max(0.0, 1.0 - luma(col));\n    data.n = normalize(mix(data.n, n, 0.5*clamp(dot(n, data.n), 0.0, 1.0)));\n    return col;\n}\n\nvec3 getAlbedoStick(inout Data data) {\n    vec3 col = vec3(0.0);\n    vec2 uv = data.uv;\n    col += textureLod(iChannel2, uv, 0.0).rgb;\n    \n   \n    data.m.rough = 0.9;\n    data.m.spec = vec3(0.01);\n    \n    return (col*col*col)/M_PI;\n}\n\nvec3 getAlbedoFlower(inout Data data) {\n    vec3 col = vec3(0.0);\n    vec2 uv = data.uvSp*1.5;\n    \n    vec3 c1 = rgb(8, 132, 2);\n    vec3 c2 = rgb(112, 154, 46);\n    vec3 c3 = rgb(29, 60, 50);\n    \n    vec3 n = textureLod(iChannel3, uv, 0.0).xyz;\n    \n    col = mix(col, c1, n.x);\n    col = mix(col, c2, n.y);\n    col = mix(col, c3, n.z);\n    \n    data.m.rough = clamp(pow(dot(n, n), 1.2)+0.5, 0.03, 1.0);\n    data.m.spec = vec3(luma(col));\n    \n    return col;\n}\n\nvec3 getAlbedo(inout Data data) {\n    switch (data.id) {\n        case ID_GROUND: return getAlbedoGround(data); break;\n        case ID_BOX: return getAlbedoBox(data); break;\n        case ID_POT: return getAlbedoPot(data); break;\n        case ID_STICK: return getAlbedoStick(data); break;\n        case ID_FLOWER: return getAlbedoFlower(data); break;\n    }\n    \n    return vec3(0.48);\n}\n\n\nvec3 getSky(in vec3 ro, in vec3 rd) {\n    return texture(iChannel1, normalize(rd)).rgb;\n}\n\n\nvec3 forEachLight(inout Data data, in Light light, in vec3 ro, in vec3 rd) {\n    vec3 L = getLightDir(light, data.p);\n    vec3 col = vec3(0.0);\n    vec3 albedo = getAlbedo(data);\n    vec3 diffuse = albedo / M_PI;\n    vec3 p = data.p;\n    vec3 n = data.n;\n    vec3 ref = reflect(L, n);\n    vec3 H = normalize(vec3(L + rd));\n    float VdotR = max(0.0, dot(rd, ref));\n    float NdotV = abs(dot(n, rd));\n    float spec = pow(VdotR, 32.0) / M_PI;\n    \n    vec3 att = getLightAtt(light, p, n);\n    \n    float shadow = 1.0;\n    shadow = getShadow(0, p+(n*NEAR*2.), L, data.d, FAR);\n    \n    col += (diffuse + (spec * data.m.spec)) * att * shadow;\n    \n    return col;\n}\n\n#define NUM_LIGHTS 2\n\n#if GI_BOUNCES > 0\nvec3 renderGI(vec3 p, vec3 n, in Light lights[NUM_LIGHTS]) {\n  vec3 col = vec3(0.0);\n  vec3 ro = p;\n  vec3 op = p;\n  int skip = 0;\n  float rsum = 0.0;\n  for (int i = ZERO; i < GI_BOUNCES; i++) {\n\n      float r1 = rand(vec2(p.x*p.z, p.y), 3.2915 + 32.0*(float(i) / float(GI_BOUNCES)));\n      float r2 = rand(vec2(p.y*p.z, p.x), 7.9326 + 32.0*(float(i) / float(GI_BOUNCES)));\n      vec3 Nt = vec3(0);\n      vec3 Nb = createCoordinateSystem(n, Nt);\n\n      vec3 samp = uniformSampleHemisphere(r1, r2);\n\n      vec3 dir = vec3(\n        samp.x * Nb.x + samp.y * n.x + samp.z * Nt.x,\n        samp.x * Nb.y + samp.y * n.y + samp.z * Nt.y,\n        samp.x * Nb.z + samp.y * n.z + samp.z * Nt.z\n      );\n\n      vec3 ro = op;\n      vec3 rd = dir;\n\n      rsum += r1;\n\n      Data nextData = NEW_DATA;\n     nextData.skip = skip;\n      if (march(nextData, ro, rd)) {\n          for (int j = ZERO; j < NUM_LIGHTS; j++) {\n              Light light = lights[j];\n              col += forEachLight(nextData, light, ro, rd);\n          }\n      } else {\n  \n          break;\n      }\n      skip = nextData.id;\n\n      p += nextData.p;\n  }\n\n  col /= float(GI_BOUNCES);\n  rsum /= float(GI_BOUNCES);\n\n  return (( col));;\n}\n#endif\n\n\n\nvec3 render(inout Data data, in vec3 ro, in vec3 rd) {\n    vec3 col = vec3(0.0);\n    \n    Light lights[NUM_LIGHTS];\n    lights[0] = Light(vec3(1, 2, -3), vec3(0.97, 0.87, 0.77), 1., LIGHT_AMBIENT);\n    lights[1] = Light(vec3(0, 0.34, -0.05), vec3(0.97, 0.6, 0.5), 1.6, LIGHT_POINT);\n    \n\n    float rough = 0.0;\n    vec3 prev = vec3(0.299, 0.587, 0.114);\n    float hitDist = FAR;\n    vec3 ogRd = rd;\n    vec3 ogRo = ro;\n    vec3 p = vec3(0.0);\n    vec3 n = vec3(0.0);\n    bool hit = false;\n    vec3 albedo = vec3(0.0);\n    int id = 0;\n    for (int j = ZERO; j < 2; j++) {\n        float l = j > 0 ? (luma(prev)*2.) : 1.0;\n        if (march(data, ro, rd)) {\n            hit = true;\n            if (j <= 0) { hitDist = data.d; p = data.p; n = data.n; id = data.id; }\n            vec3 reflectance = vec3(0.0);\n            for (int i = ZERO; i < NUM_LIGHTS; i++) {\n                Light light = lights[i];\n                vec3 next = forEachLight(data, light, ro, rd) * l;\n                reflectance += (next / (1.0 + float(j))) * max(0.0, 1.0 - rough);\n            }\n            \n           \n            \n            col += reflectance;\n            prev = reflectance;\n            ro = data.p;\n            rd = reflect(rd, data.n);\n            data.skip = data.id;\n            rough = data.m.rough;\n        } else {\n            col += l * (getSky(ro, rd) * max(0.0, 1.0 - rough)) / (1.0 + float(j));\n            break;\n        }\n    }\n    \n    rd = ogRd;\n    ro = ogRo;\n    #if GI_BOUNCES > 0\n    if (hit) {      \n      col += renderGI(p, n, lights);\n \n    }\n    #endif\n    \n    Light light = lights[1];\n    vec3 L = getLightDir(light, ro);\n    float VdotL = max(0.0, dot(rd, L));\n   \n    // some nasty depth trickery to keep the \"light fog\" inside the pot.\n    float jj = distance(ro, light.p)-hitDist;\n    float k = max(0.0, 1.0 - smoothstep(2.5 - jj, 2.8 + jj, hitDist*jj));\n    col += pow(VdotL, max(16.0, 800.-(410.0*(1.0/max(0.2, distance(ro, light.p)))))) * light.c * light.s * max(0.0, 1.0 - k) * 3.;\n   \n   \n    float depth = hitDist / FAR;\n    \n    float dotup = max(0.0, dot(rd, vec3(0, 1, 0)));\n    col += depth * max(0.0, 1.0 - (dotup*2.));\n    \n    return col;\n}\n\nvoid getRay(in vec2 uv, in vec2 m, inout vec3 ro, inout vec3 rd) {\n    ro = vec3(0, 0.5, -2.6);\n    rd = normalize(vec3(uv.xy, 1.0));\n    \n    \n    if (iMouse.z > 0.01) {\n        ro.yz *= rot(m.y*TAU);\n        ro.xz *= rot(m.x*TAU);\n        \n        rd.yz *= rot(m.y*TAU);\n        rd.xz *= rot(m.x*TAU);\n    } else {\n        float t = T * 0.5;\n        ro.z += (0.5+(0.5*cos(t)))*2.;\n        ro.x += sin(t)*0.5;\n        rd = look(uv, vec3(0.0, 0.5, 0.0), ro);   \n    }\n    \n    ro.y = max(0.2, ro.y);\n}\n\nvoid mainImage( out vec4 O, in vec2 fc )\n{\n    vec3 col = vec3(0.0);\n    vec2 uv = (fc-0.5*R.xy)/R.y;\n    vec2 m = (iMouse.xy-0.5*R.xy)/R.y;\n    \n    vec3 ro = vec3(0.0);\n    vec3 rd = vec3(0.0);\n    \n    \n    #if AA_SAMPLES > 0\n     for(float i=ZEROF; i < float(AA_SAMPLES); i++) {\n       for(float j=ZEROF; j < float(AA_SAMPLES); j++) {\n        vec2 deltaUV = (vec2(i, j) / float(AA_SAMPLES) - 0.5) / R.y;\n        uv.xy += deltaUV / 2.0;\n        getRay(uv, m, ro, rd);\n        Data data = NEW_DATA;\n        col += render(data, ro, rd);\n      }\n    }\n    col /= float(AA_SAMPLES*AA_SAMPLES);\n    #else\n    getRay(uv, m, ro, rd);\n    Data data = NEW_DATA;\n    col += render(data, ro, rd);\n\n    #endif\n    col += (col*luma(col))/M_PI;\n    col /= vec3(1.0) + col;\n    col = pow(col, vec3(1.0 / 2.2));\n    \n    O = vec4(col, 1.0);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define R iResolution.xy\n#define T (iTime+6.)\n#define M_PI (3.1416)\n#define TAU (M_PI * 2.0)\n\nmat2 rot(float a) { float s = sin(a); float c = cos(a); return mat2(c, s, -s, c); }\n\nvec3 getNormal(\n    sampler2D tex,\n    vec2 uv,\n    float detail,\n    float z,\n    float lod\n) {\n    #define TEXEL(CH, UV) dot(textureLod(CH, UV, lod).rgb, vec3(0.299, 0.587, 0.114))\n    float l = TEXEL(tex, uv);\n    float d = fwidth(l)*detail;\n    \n    vec3 n = normalize(l - vec3(\n        TEXEL(tex, uv + vec2(d, 0)),\n        TEXEL(tex, uv + vec2(0, d)),\n        (z > 0.0 ? z : TEXEL(tex, uv + vec2(d, d)))\n    ));\n //   n.z = z;\n    #undef TEXEL\n    return n;\n}\n\n\nfloat luma(vec3 color) {\n  return dot(color, vec3(0.299, 0.587, 0.114));\n}\n\n\nvec3 texHash33(sampler2D ch, vec3 p, float div, float seed, vec2 lod) {\n    return textureLod(ch, (vec2(p.x, p.y) +\n        div*(textureLod(ch, (vec2((p.y*p.z), p.z)+seed)/div, lod.x).xy*2.0-1.0))/div, lod.y).xyz;\n}\n\nvec3 texNoise(sampler2D tex, vec3 p, float seed, vec2 lod) {\n    vec3 id = floor(p);\n    vec3 lv = fract(p);\n    lv = lv * lv * (3.0 - 2.0 * lv);\n\n    float div = 256.0;//vec2(textureSize(tex, 0).xy).y;\n\n    return mix(\n        mix(mix(\n              texHash33(tex, id + vec3(0, 0, 0), div, seed, lod),\n              texHash33(tex, id + vec3(1, 0, 0), div, seed, lod), lv.x),\n          mix(texHash33(tex, id + vec3(0, 1, 0), div, seed, lod),\n              texHash33(tex, id + vec3(1, 1, 0), div, seed, lod), lv.x),\n          lv.y),\n        mix(mix(\n              texHash33(tex, id + vec3(0, 0, 1), div, seed, lod),\n              texHash33(tex, id + vec3(1, 0, 1), div, seed, lod), lv.x),\n          mix(texHash33(tex, id + vec3(0, 1, 1), div, seed, lod),\n              texHash33(tex, id + vec3(1, 1, 1), div, seed, lod), lv.x),\n          lv.y),\n        lv.z\n    );\n}\n\nvec3 texNoise(sampler2D tex, vec3 p, float freq, float seed, vec2 lod) {\n    float div = 0.0;\n    float amp = 1.0;\n    vec3 n = vec3(0.0);\n    n += amp * texNoise(tex, p*freq, seed, lod); div += amp; amp /= 2.0; freq *= 2.0;\n    n += amp * texNoise(tex, p*freq, seed, lod); div += amp; amp /= 2.0; freq *= 2.0;\n    n += amp * texNoise(tex, p*freq, seed, lod); div += amp; amp /= 2.0; freq *= 2.0;\n    n += amp * texNoise(tex, p*freq, seed, lod); div += amp; amp /= 2.0; freq *= 2.0;\n    return n / div;\n}\n\nfloat texNoise2D(sampler2D tex, vec2 uv, float freq, float seed, float lod) {\n    vec3 p = vec3(uv.x, uv.y, 1.0 /(0.0002315+uv.x+uv.y));\n    vec3 n = texNoise(tex, p, freq, seed, vec2(lod));\n    return (n.x+n.y+n.z)/3.0;\n}\n\n\nvec3 dullen(vec3 c, float amnt) {\n    vec3 dull = c / M_PI;\n    dull += 1.0 / M_PI;\n    return mix(c, dull, amnt);\n}\n\n\nvec2 sphereUv(vec3 p) {\n    vec2 uv = vec2(0.0);\n    uv.y = acos(p.x);\n    uv.x = atan(p.y, p.z);\n    uv = uv * 2.0 - 1.0;\n    uv.x = 0.5 + uv.x / (M_PI);\n    uv.y = 0.5 - uv.y / M_PI;\n    return uv;\n}\n\nvec3 look(vec2 uv, vec3 point, vec3 ro) {\n  vec3 lookAt = point;\n  float zoom = 1.;\n  vec3 camForward = normalize(lookAt - ro);\n  vec3 camRight = -cross(camForward, vec3(0, 1, 0));\n  vec3 camUp = -cross(camRight, camForward);\n  vec3 screenCenter = ro + camForward * zoom;\n  vec3 screenIntersection = screenCenter + uv.x * camRight + uv.y * camUp;\n  return normalize(screenIntersection - ro);\n}\n\nvec3 createCoordinateSystem(vec3 N, inout vec3 Nt)\n{\n    if (abs(N.x) > abs(N.y)) {\n        Nt = vec3(N.z, 0, -N.x) / sqrt(N.x * N.x + N.z * N.z);\n    } else {\n        Nt = vec3(0, -N.z, N.y) / sqrt(N.y * N.y + N.z * N.z);\n    }\n    return cross(N, Nt);\n}\n\nvec3 uniformSampleHemisphere(float r1, float r2)\n{\n    float theta = sqrt(1. - r1 * r1);\n    float phi = 2. * M_PI * r2;\n    return vec3(cos(phi) * theta, r1, sin(phi) * theta);\n}\n\nfloat rand(vec2 p, float seed) {\n    uvec2 y = uvec2(floatBitsToUint(p.x), floatBitsToUint(p.y));\n    uint s = floatBitsToUint(seed);\n    uvec2 w = (~y) >> 3U;\n    y ^= (y << 17U);\n    y ^= (y >> 7U) << s;\n    y ^= (y << 5U);\n    y ^= (w << y);\n    \n    uint xx = (y.x << ~w.x)>>3U;\n    uint yy = (y.y << ~w.y)>>3U;\n    \n    uint n = 3818U * ((xx + yy) ^ ((xx << 17U) ^ (yy << 17U)));\n    return float(n) / float(0xFFFFFFFFU);\n}","name":"Common","description":"","type":"common"}]}