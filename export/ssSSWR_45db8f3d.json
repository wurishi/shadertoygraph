{"ver":"0.1","info":{"id":"ssSSWR","date":"1619986728","viewed":151,"name":"Neon Rupture","username":"Hyeve","description":"No complex geometry here, only clever lighting and reflections :>","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["3d","raymarching","reflections"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define NMAT mat(vec3(0.1), 1., 0., 0., 0.)\n\n#define rot(a) mat2(cos(a), -sin(a), sin(a), cos(a))\n\nstruct mat\n{\n    vec3 col;\n    float diff;\n    float spec;\n    float refl;\n    float fres;\n};\n\nstruct obj\n{\n    float sdf;\n    mat mat;\n};\n\nstruct hit\n{\n    float rdf;\n    vec3 pos;\n    mat mat;\n};\n\nfloat box(vec3 p, vec3 s)\n{\n    vec3 q = abs(p) - s;\n    return min(max(q.x,max(q.y,q.z)),0.) + length(max(q, 0.));\n}\n\nobj om(obj a, obj b)\n{\n    if(a.sdf < b.sdf) {return a;} else {return b;}\n}\n\nobj scene(vec3 p)\n{\n   \n    float stepp = (sin(iTime/4.)*0.5+0.5)*16.+1.;\n    \n    mat A = mat(vec3(cos(iTime/2.)*0.5+0.5,sin(iTime/8.)*0.5+0.5,sin(iTime/4.)*0.5+0.5),1.,1.,1.,1.);\n    mat B = mat(vec3(1),1.,1.,0.2,1.);\n    \n    B.col = mix(vec3(3.,0.6,0.6), vec3(0.,2.,2.),fract(stepp));\n    \n    p.xy *= rot(iTime/8.);\n    \n    float outbox = box(p,vec3(30));\n    float outfill = box(p,vec3(29));\n    \n    p.xy *= rot(-iTime/2.);\n    p.xz *= rot(iTime/2.);\n    \n    float shell = max(-outfill,outbox);\n    float centre = box(p,vec3(1.5)) - 0.5;\n    \n    obj outer = obj(shell,A);\n    obj cube = obj(centre,B);\n    \n    return om(outer,cube);\n}\n\n\nhit trace(vec3 ro, vec3 rd)\n{\n    float d = 0.;\n    vec3 p;\n    obj s;\n    for(int i = 0; i < 256; i++)\n    {\n        p = ro + rd * d; \n        s = scene(p);\n        d += s.sdf;\n        if(s.sdf < 0.001) return hit(d, p, s.mat);\n        if(d > 128.) break;\n    }\n    return hit(-1., vec3(0), NMAT);\n}\n\nvec3 normal(hit h)\n{\n    vec2 e = vec2(0.001, 0.);\n    float d = scene(h.pos).sdf;\n    vec3 n = d - vec3(scene(h.pos - e.xyy).sdf, scene(h.pos - e.yxy).sdf, scene(h.pos - e.yyx).sdf);\n    return normalize(n);\n}\n\nvec3 lit(hit o, vec3 rd)\n{\n    vec3 n = normal(o);\n    \n    //fake diffuse lighting - purely distance-based. Creates a really nice soft effect though!\n    float diff = pow(1. - o.rdf/128.,5.) * o.mat.diff;\n    float fres = pow(1. - abs(dot(n,rd)), 4.) * o.mat.fres;\n    float spec = pow(max(dot(reflect(rd, n), -rd), 0.),10.) * o.mat.spec;\n    vec3 col = o.mat.col * (diff + fres) + spec;\n    return col;\n}\n\nvec3 col(vec3 ro, vec3 rd)\n{\n    mat ret = NMAT;\n    vec3 rfo = ro, rfd = rd;\n    float mxamnt = 1.;\n\n    float refl = (sin(iTime/4.)*0.5+0.5)*16.+1.;\n\n    for(float i = 0.; i < refl; i++)\n    {\n        hit h = trace(rfo, rfd);\n        ret.col = mix(ret.col, lit(h, rfd), mxamnt);\n        if(h.mat.refl <= 0.) break;       \n        vec3 n = normal(h);  \n        rfd = reflect(rfd, n);\n        rfo = h.pos + n * 0.001 * 2.;\n        mxamnt = clamp(mxamnt - (1. - h.mat.refl), 0., 1.);\n    }\n    \n    return ret.col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy)/iResolution.y;\n\n    float stepp = (sin(iTime/4.)*0.5+0.5)*16.+1.;\n\n    vec3 ro = vec3(0,0,-10. + stepp * 0.3);\n    \n    //uncomment for camera movement around the centre cube\n    //ro.yz *= rot(iTime/4.);\n    \n    vec3 rd = normalize(vec3(uv.x,uv.y, 1.));\n    \n    // Output to screen\n    fragColor = vec4(col(ro,rd),1.0);\n    \n    //this line shows what the scene looks like with no reflections\n    //fragColor = vec4(lit(trace(ro,rd),rd),1.0);\n}","name":"Image","description":"","type":"image"}]}