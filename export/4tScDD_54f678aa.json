{"ver":"0.1","info":{"id":"4tScDD","date":"1508511016","viewed":117,"name":"Simple edge detection ","username":"tale3d","description":"Simple edge detection kernel. It was used as a teaching material for the unit \"Artificial intelligence and computer vision\"","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["imageprocessing","teachingmaterial"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//An example of simple image processing\n\n//We are working with simple 3*3 kernel centered in the given pixel.\n//Different kernels define different effects. Edge detection by default, but blur/sharpen also available\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t//kernels for different effects, name implies its purpose\n    const float edgeDetectKernel[9] = float[9](-1., -1., -1.,-1., 8., -1.,-1., -1., -1.);\n    const float gaussianBlurKernel[9] = float[9](0.045, 0.122, 0.045, 0.122, 0.332, 0.122, 0.045, 0.122, 0.045);\n    const float unsharpenKernel[9] = float[9](-1., -1., -1., -1., 9., -1., -1., -1., -1.);\n    const float sharpnessKernel[9] = float[9](0.,-1.,0.,-1.,5.,-1.,0.,-1.,0.);\n    \n    //coordinates of x and y in the kernel\n    const float xKernel[9] = float[9](-1., 0., 1., -1., 0., 1., -1., 0., 1.);\n    const float yKernel[9] = float[9](-1., -1., -1., 0., 0., 0., 1., 1., 1.);\n    \n    \n    vec2 uv  = fragCoord.xy / iResolution.xy;\n    //the size of 1 pixel in texture coordinates\n    float pixX = 1.0/iResolution.x; \n    float pixY = 1.0/iResolution.y;\n\n    float height = 0.5+0.5*cos(iTime);  //moving line\n\n    //the effect is working as following: we are doing weighted summation of the pixels' intensity in kernel\n    //doing that in black and white, while for some effects we can do in r/g/b as well\n    vec4 colorSum = vec4(0);\n    for (int i = 0; i < 9; i++) //9=3*3, kernel size is pre-defined\n    {\n        vec4 color = texture(iChannel0, vec2(uv.x+pixX*xKernel[i], uv.y+pixY*yKernel[i])); //getting pixel colour from the texture\n        float intensity = color.x*0.3+color.y*0.59+color.z*0.11; //convert to black and white\n        colorSum += vec4(intensity)*edgeDetectKernel[i]; //weighted summation\n    }\n\n    \n    if (uv.y > height) \n    {\n        //converting to black and white and drawing the unchanged pixel if we are above the moving line\n        vec4 color = texture(iChannel0, uv); \n        float intensity = color.x*0.3+color.y*0.59+color.z*0.11;\n        fragColor = vec4(intensity);\n    }\n    else \n        //drawing the processed pixel if we are below the moving line\n        fragColor = colorSum;\n    \n\n    //moving line\n    if (abs(uv.y - height)<0.001) fragColor=vec4(0.);\n    vec4 color = texture(iChannel0, vec2(uv.x, height));\n}","name":"Image","description":"","type":"image"}]}