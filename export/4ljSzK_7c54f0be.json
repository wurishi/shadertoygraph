{"ver":"0.1","info":{"id":"4ljSzK","date":"1446415276","viewed":118,"name":"coding dojo 2.2","username":"pmilian","description":"dojo ","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["dojo"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sXGRn","filepath":"/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","previewfilepath":"/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[],"code":"const float zNear = 1.0;\nconst float zFar  = 400.0;\n\n\nfloat sphere(vec3 m, vec3 sphereCenter, float radius) {\n    float displacementFactor = 0.8 + cos(iTime/2.0)* 0.4;\n    float displacement = sin(displacementFactor*m.x)*sin(displacementFactor*m.y)*sin(displacementFactor*m.z);\n    \n    return length(m - sphereCenter) - radius;// + displacement;\n}\n\nfloat map(in vec3 m) {\n    vec3 sphereCenter1 = vec3(cos(iTime)*4.0, 0.0, +20.0);\n    vec3 sphereCenter2 = vec3(-cos(iTime)*4.0, 0.0, +20.0);\n\n    float d1 = sphere(m, sphereCenter1, 4.0);\n    float d2 = sphere(m, sphereCenter2, 3.0);\n    \n    return min(d1, d2);\n}\n\nbool intensity(in vec3 m, out vec3 normal) {\n    vec3 c1 = vec3(cos(iTime)*2.0, 0.0, +20.0);\n    vec3 c2 = vec3(-cos(iTime)*4.0, 1.0, +20.0);\n    vec3 c3 = vec3(0.0, cos(iTime)*4.0, +20.0);\n    vec3 c4 = vec3(sin(iTime)*2.0, sin(iTime)*2.0, +20.0);\n    \n    float d1 = length(m - c1);\n    float d2 = length(m - c2);\n    float d3 = length(m - c3);\n    float d4 = length(m - c4);\n    \n    float i1 = 1.0 / (d1 * d1);\n    float i2 = 1.0 / (d2 * d2);\n    float i3 = 1.0 / (d3 * d3);\n    float i4 = 1.0 / (d4 * d4);\n    \n    vec3 n1 = normalize(m - c1);\n    vec3 n2 = normalize(m - c2);\n    vec3 n3 = normalize(m - c3);\n    vec3 n4 = normalize(m - c4);\n    \n    float i = i1 + i2 + i3 + i4;\n    \n    normal = normalize(\n        n1 * i1 / i\n        + n2 * i2 / i\n        + n3 * i3 / i\n        + n4 * i4 / i);\n    \n    return (i1 + i2 + i3 + i4) >= 0.5;\n    \n}\n\nbool rayMarching(in vec3 origin, in vec3 ray, out vec3 m, out vec3 normal) {\n    \n    float\tmarchingDist = 0.0;\n    float \tnbIter \t\t = 0.0;\n\n    for(int i = 0; i < 500; i++) {\n        \n        m = origin + ray * marchingDist;    \n        \n    \tfloat dist = map(m);\n        \n        if(intensity(m, normal)) {\n            return true;\n        }\n        else {\n            marchingDist += 0.1;\n            \n            if(marchingDist >= zFar) {\n                break;\n            }\n        }\n    }\n    \n\treturn false;    \n}\n\n\nvec4 computeColor(in vec3 ray, in vec3 m, in vec3 normal, in vec3 light, in vec3 eye) {\n    \n    vec3 lightRay = normalize(m - light);\n    float diffuse = dot(normal, -lightRay);\n    \n    vec3 reflectedLight  = reflect(lightRay, normal);\n    float hilight \t\t = pow(max(dot(reflectedLight, -ray),0.0), 20.0);\n    \n    vec3 diffuseComponent = vec3(1.0, 0.0, 0.0) * diffuse;\n    vec3 hilightComponent = vec3(1.0, 1.0, 1.0) * hilight;    \n    vec3 ambiantComponent = vec3(0.2, 0.0, 0.0);       \n    \n    vec3 reflectray = reflect(m-eye, normal);\n    vec3 envmap \t= texture( iChannel0, reflectray).xyz;\n    \n    vec3 sphereColor = diffuseComponent + hilightComponent + ambiantComponent;\n    \n    return vec4(mix(sphereColor, envmap, 0.0), 1.0);\n}\n\n\nvec3 computeNormal(in vec3 pos)\n{\n\tvec3 eps = vec3( 0.001, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t     map(pos+eps.xyy) - map(pos-eps.xyy),\n\t     map(pos+eps.yxy) - map(pos-eps.yxy),\n\t     map(pos+eps.yyx) - map(pos-eps.yyx));\n\treturn normalize(nor);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float \tratio \t\t\t= iResolution.x/iResolution.y;\n    vec3 \tviewportCoord \t= vec3(fragCoord.xy/iResolution.y - vec2(ratio/2.0, 0.5), zNear);\n    \n    vec3\teye\t\t\t\t= vec3(0.0, 0.0, 0.0);\n    vec3\tray\t\t\t\t= normalize(viewportCoord-eye);\n    vec3\tlight\t\t\t= vec3(-15.0*cos(iTime), 25.0*cos(iTime/3.0), -5.0);\n    \n    vec3\tm;\n    vec3\tnormal;\n    \n    if(rayMarching(eye, ray, m, normal)) {\n        \n        //vec3 normal = computeNormal(m);\n        \n        fragColor = computeColor(ray, m, normal, light, eye);\n    }\n    else {\n        vec3 s = eye + ray * 22.0 / ray.z;\n        vec3 lightRay = normalize(s - light);\n        \n        vec4 color = texture(iChannel1, fragCoord.xy / iResolution.xy);\n        \n        if (rayMarching(light, lightRay, m, normal)) {\n        \tfragColor = mix(color, vec4(0.0, 0.0, 0.0, 1.0), 0.5);\t   \n        } else {\n\t        fragColor = texture(iChannel1, fragCoord.xy / iResolution.xy);\n        }\n    }\n}","name":"","description":"","type":"image"}]}