{"ver":"0.1","info":{"id":"dsfyDS","date":"1687277796","viewed":53,"name":"Riemann zeta over complex plane","username":"johnhearn","description":"Magnitude of zeta function (red) and its zeros (white). Riemann hypothesis says that all such zeros are on the critical line (green). Evaluated using prop 1 from this paper: http://numbers.computation.free.fr/Constants/Miscellaneous/zetaevaluations.pdf","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["zeta","riemann"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define pi 3.141592653\n\n// Greater then 47 increases overflow errors\nconst int n = 47;\n\nvec2 zeta(vec2 s) {\n    if (length(s-vec2(1.0,0.)) < 0.01) return vec2(1.,1.); // simple pole\n\n    float[n+1] c;\n    c[0] = 1./float(n);\n    for (int j=0;j<=n-1;j++) {\n      c[j+1] = c[j] * float(n+j)*float(n-j)*4. / float(2*j+2) / float(2*j+1);\n    }\n\n    float[n+1] d;\n    d[n] = float(n)*c[n];\n    for (int k=n-1;k>=0;k--) {\n      d[k] = d[k+1] + float(n)*c[k];\n    } \n\n    vec2 zeta = vec2(0.);\n    for (int k=1;k<=n;k++) {\n        vec2 num = vec2(((k%2==0)?-1.:1.)*d[k], 0);\n        vec2 denom = cx_pow(float(k), s);\n        zeta += cx_div(num, denom);\n    }\n\n    zeta /= d[0];\n    vec2 p2 = vec2(1.,0.) - cx_pow(2., vec2(1.,0.)-s);\n    zeta = cx_div(zeta, p2 );\n\n    return zeta;\n}\n\n// Just the magnitude\nvec3 color1(vec2 z){\n    return vec3(cx_abs(z)/2., 0., 0.);\n}\n\n// Colour the angle\nvec3 color2(vec2 z){\n    return vec3(cx_abs(z), (cx_arg(z)+pi)/pi/2., 0.);\n}\n\nfloat smoothticky(vec2 P, float w) {\n    vec2 A = vec2(-w/2., round(P.y));\n    vec2 PA = P-A;\n    float h = clamp(0.,1.,PA.x/w);\n    return length(PA - h*vec2(w,0.));\n}\n\nfloat smoothtickx(vec2 P, float w) {\n    vec2 A = vec2(round(P.x), w/2.);\n    vec2 PA = P-A;\n    float h = clamp(0.,1.,PA.y/w);\n    return length(PA - h*vec2(0., w));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float zoom = min(iTime, 60.);\n    vec2 scale = vec2(zoom/300.+1.,zoom+1.);\n    vec2 translate = vec2(0.5,0);\n    vec2 s = scale * 2. * (fragCoord/iResolution.xy - 0.5) + translate;\n\n    vec2 z = zeta(s);\n    vec3 col = color1(z);\n    \n    vec2 R = vec2(3.,2.)*scale/iResolution.xy;\n    // critical line\n    if (abs(s.x - 0.5) < 2.*R.x) col = vec3(.5,.5,0.);\n    // axis\n    col += smoothstep(2.*R.x, 0., abs(s.x));\n    col += smoothstep(2.*R.y, 0., abs(s.y));\n    // ticks\n    if (length(s) > .5) {\n   /*\n    // smooth minor y ticks\n    col+= smoothstep(4.*R.x, 3.*R.x, smoothticky(s, 3.*R.x));\n    \n    // minor x ticks\n    col+= smoothstep(2.*R.y, 1.*R.y, smoothtickx(s, 3.*R.y));\n   */ \n    // smooth minor ticks\n         if (abs(s.y - round(s.y)) < 1.*R.y) col += smoothstep(4.*R.x, 3.*R.x, abs(s.x));\n    else if (abs(s.x - round(s.x)) < 1.*R.x) col += smoothstep(6.*R.y, 4.*R.y, abs(s.y));\n         if (abs(s.x) < 3.*R.x) col += smoothstep(2.*R.y, 1.*R.y, abs(s.y - round(s.y)));\n    else if (abs(s.y) < 4.*R.x) col += smoothstep(6.*R.y, 4.*R.y, abs(s.x - round(s.x)));\n\n    // major ticks\n         if (abs(s.y/10. - round(s.y/10.)) < 2./10.*R.y) col += smoothstep(8.*R.x, 6.*R.x, abs(s.x));\n    else if (abs(s.x/10. - round(s.x/10.)) < 2./10.*R.x) col += smoothstep(8.*R.y, 6.*R.y, abs(s.y));\n    \n    }\n    \n    // zeros\n    if (length(z) < .2) col = vec3(1.-10.*length(z));\n    \n    fragColor = vec4(col,1.);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// Complex functions from \n// https://gist.github.com/DonKarlssonSan/f87ba5e4e5f1093cb83e39024a6a5e72\n\n#define cx_mul(a, b) vec2(a.x*b.x-a.y*b.y, a.x*b.y+a.y*b.x)\n#define cx_div(a, b) vec2(((a.x*b.x+a.y*b.y)/(b.x*b.x+b.y*b.y)),((a.y*b.x-a.x*b.y)/(b.x*b.x+b.y*b.y)))\n#define cx_modulus(a) length(a)\n#define cx_conj(a) vec2(a.x, -a.y)\n#define cx_arg(a) atan(a.y, a.x)\n#define cx_sin(a) vec2(sin(a.x) * cosh(a.y), cos(a.x) * sinh(a.y))\n#define cx_cos(a) vec2(cos(a.x) * cosh(a.y), -sin(a.x) * sinh(a.y))\n#define cx_sub(a, b) vec2(a.x - b.x, a.y - b.y)\n#define cx_add(a, b) vec2(a.x + b.x, a.y + b.y)\n#define cx_abs(a) length(a)\n\n// float raised to complex power\nvec2 cx_pow(float n, vec2 s) {\n    float ln = log(n);\n    float R = exp(s.x*ln);\n    float a = cos(s.y*ln);\n    float b = sin(s.y*ln);\n    return R*vec2(a, b);\n}\n","name":"Common","description":"","type":"common"}]}