{"ver":"0.1","info":{"id":"WdyXRV","date":"1574377868","viewed":363,"name":"[TWITCH] Morpha","username":"Flopine","description":"This shader is heavily inspired by Zelda Ocarina Of Time Water Temple boss ;) \nMade it during a live on twitch you can see here: https://www.twitch.tv/flopine","likes":13,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","proceduraltexture","faketransparency"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Code by Flopine\n// Thanks to wsmind, leon, XT95, lsdlive, lamogui, Coyhot, Alkama and YX for teaching me\n// Thanks LJ for giving me the love of shadercoding :3\n\n// Thanks to the Cookie Collective, which build a cozy and safe environment for me \n// and other to sprout :)  https://twitter.com/CookieDemoparty\n\n#define PI 3.141592\n#define time iTime\n\nfloat hash21 (vec2 x)\n{return fract(sin(dot(x,vec2(12.4,14.5)))*1245.2);}\n\nmat2 rot (float a)\n{return mat2(cos(a),sin(a),-sin(a),cos(a));}\n\nfloat stmin (float a, float b, float k, float n)\n{\n    float st = k/n;\n    float u = b-k;\n    return min(min(a,b), 0.5*(u+a+abs(mod(u-a+st,2.*st)-st)));\n}\n\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nvoid mo (inout vec2 p, vec2 d)\n{\n    p = abs(p)-d;\n    if (p.y>p.x) p = p.yx;\n}\n\nfloat box (vec3 p, vec3 c)\n{\n    vec3 q = abs(p)-c;\n    return min(0., max(q.x,max(q.y,q.z)))+length(max(q,0.));\n}\n\nfloat cyl (vec3 p, float r, float h)\n{return max(length(p.xy)-r,abs(p.z)-h);}\n\nfloat cap (vec3 p, vec3 a, vec3 b, float r)\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\nfloat g1 = 0.;\nfloat sphe (vec3 p ,float r)\n{\n    float d = length(p)-r;\n    g1 += 0.1/(0.1+d*d);\n    return d;\n}\n\nfloat spikes (vec3 p)\n{\n    float per = 1.2;\n    p.y -= 6.5;\n    p.y = abs(p.y)-5.;\n\n    vec3 pp = p;\n    p.z = abs(p.z)-13.;\n    p.x = mod(p.x, per)-per*0.5;\n    float s1 = cyl(p, .1 + p.z * 0.2,2.);\n\n    p = pp;\n    p.x = abs(p.x)-13.;\n    p.z = mod(p.z, per)-per*0.5;\n    float s2 = cyl(p.yzx, .1 + p.x * 0.2,2.); \n    return min(s2,s1);\n}\n\nfloat room (vec3 p)\n{\n    float b1 = -box(p, vec3(15.,12.,15.));\n\n    p.y += 6.;\n    float b2 = max(-box(p, vec3(10.,15.,10.)),box(p,vec3(15.,6.,15)));\n\n    p.xz = abs(p.xz)-5.;\n    float b3 = box(p, vec3(2.,6., 2.));\n\n    return stmin(b3,stmin(b2,b1, 1., 3.), 1., 4.);\n}\n\nfloat water (vec3 p)\n{\n    p.y += sin(length(p.xz*2.)-time*3.)*0.2 + 1.;\n    return max(p.y,box(p, vec3(10.,15.,10.)));\n}\n\nfloat morpha (vec3 p)\n{\n    p.xz *= rot(sin(p.y*0.2));\n    p.x -= 0.5;\n    p.x += sin(p.y*0.7+time);\n    p.z += cos(p.y+time*0.8);\n    return min(sphe(p-vec3(0.,4.+sin(time)*3.,0.),.5),abs(cap(p, vec3(0.,-5.,0.),vec3(0.,7.,0.), 1.))-0.3);\n}\n\nint mat_id;\nfloat SDF (vec3 p)\n{\n    float wm = smin(water(p), morpha(p), 2.);\n    float r = room(p);\n    float s = spikes(p);\n    float d = min(wm,stmin(r,s,0.3,3.));\n\n    if(d == r) mat_id = 1;\n    if(d == wm) mat_id = 2;\n    if (d == s) mat_id = 3;\n\n    return d;\n}\n\nvec3 getcam (vec3 ro, vec3 ta, vec2 uv)\n{\n    vec3 f = normalize(ta-ro);\n    vec3 l = normalize(cross(vec3(0.,1.,0.),f));\n    vec3 u = normalize(cross(f,l));\n    return normalize(f*0.8 + l*uv.x + u*uv.y);\n}\n\nvec3 getnorm (vec3 p)\n{\n    vec2 eps = vec2(0.01,0.);\n    return normalize(SDF(p)-vec3(SDF(p-eps.xyy),SDF(p-eps.yxy),SDF(p-eps.yyx)));\n}\n\nfloat lighting (vec3 n, vec3 l)\n{return dot(n,l)*0.5+0.5;}\n\nvec3 dalle (vec2 uv)\n{\n    uv *= 5.;\n    uv = fract(uv)-.5;\n    uv = abs(uv);\n    float c = step(max(uv.x, uv.y),0.43)*step(0.2, max(uv.x, uv.y));\n    uv = fract(uv)-.5;\n    float s = step(length(uv), 0.07);\n    float mask = c + s;\n    return mix(vec3(0.02,0.,0.1),vec3(0.1,0.4,0.6),mask);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n    uv -= 0.5;\n    uv /= vec2(iResolution.y / iResolution.x, 1);\n\n    float dither = hash21(uv);\n\n    vec3 ro = vec3(10.,5.,-13.),\n        p = ro,\n        tar = vec3(0.,2.,0.),\n        rd = getcam(ro,tar,uv),\n        l = normalize(vec3(-5.,5.,-2.)),\n        col = vec3(0.);\n\n    float shad = 0.;\n\n    for (float i=0.; i<64.; i++)\n    {\n        float d = SDF(p);\n        if (mat_id == 1 || mat_id == 3)\n        {\n            if (d<0.01)\n            {\n                shad = i/64.;\n                break;\n            }\n        }\n        if (mat_id == 2)\n        {\n            d = max(abs(d)-0.1, 0.04);\n        }\n        d *= 0.9+dither*0.02;\n        p += d*rd;\n    }\n\n    float t = length(p*2.);\n\n    vec3 n = getnorm(p);\n    if (mat_id == 1)\n    {\n        col = dalle(p.xz*.08);\n        col *=  lighting(n,l);\n    } \n    if (mat_id == 3)\n    {\n        col = vec3(0.9);\n        col *= lighting(n,l);\n    }  \n    if (mat_id == 2) \n    {\n        col = (1.-shad)*vec3(0.5,.8,0.8);\n    }\n    col *= vec3(1.-shad);\n    col += g1*vec3(0.8,clamp(length(p),0.,0.3),0.8)*0.5;\n\n    col = mix(col, vec3(0.2,0.5,0.4), 1.-exp(-0.001*t*t));\n\n    fragColor = vec4(col,1.);\n}","name":"Image","description":"","type":"image"}]}