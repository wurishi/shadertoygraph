{"ver":"0.1","info":{"id":"4cfSWX","date":"1707732460","viewed":20,"name":"[inspirnathan] 03 - 2Dshapes&mix","username":"hrst4","description":"[inspirnathan] 03 - 2Dshapes&mix","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["inspirnathan"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// This a french translation of the highly educational Nathan Vaughn's tutorials.\n// Un grand merci à lui !\n// his website: https://inspirnathan.com/\n// original:\n// from https://inspirnathan.com/posts/50-shadertoy-tutorial-part-4\n\n#define PART 7\n\n/*\nBonjour, chers amis ! Dans les deux derniers tutoriels, nous avons appris à dessiner \ndes formes 2D sur le canvas à l'aide de Shadertoy. \nDans cet article, j'aimerais discuter d'une meilleure approche pour dessiner des formes 2D,\nafin que nous puissions facilement ajouter plusieurs formes au canevas.\nNous apprendrons également à modifier la couleur de fond indépendamment des couleurs des \nformes.\n\n# La fonction Mix\n\nAvant de poursuivre, jetons un coup d'œil à la fonction mix. \nCette fonction nous sera particulièrement utile lorsque nous rendrons plusieurs \nformes 2D dans la scène.\n\nLa fonction mix interpole linéairement entre deux valeurs.\nDans d'autres langages de shaders tels que HLSL, cette fonction est connue sous le nom \nde lerp.\n\nL'interpolation linéaire de la fonction mix(x, y, a) est basée sur la formule suivante :\n\nx * (1 - a) + y * a\n\nx = first value\ny = second value\na = value that linearly interpolates between x and y\n\nConsidérez le troisième paramètre, a, comme un curseur qui vous permet\nde choisir des valeurs entre x et y.\n\nLa fonction mix est très utilisée dans les shaders. \nC'est un excellent moyen de créer des dégradés de couleurs. Prenons un exemple :\n*/\n\n#if PART == 1\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy; // <0, 1>\n\n    float interpolatedValue = mix(.0, 1., uv.x);\n    vec3 col = vec3(interpolatedValue);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n\n/*\nDans le code ci-dessus, nous utilisons la fonction mix pour obtenir une valeur\ninterpolée par pixel de l'écran sur l'axe x. \nEn utilisant la même valeur sur les canaux rouge, vert et bleu, \nnous obtenons un dégradé qui va du noir au blanc, avec des nuances de gris entre les deux.\n\nNous pouvons également utiliser la fonction de mix sur l'axe Y :\n*/\n\n#elif PART == 2\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy; // <0, 1>\n\n    float interpolatedValue = mix(.0, 1., uv.y);\n    vec3 col = vec3(interpolatedValue);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n\n/*\nEn utilisant ces connaissances, nous pouvons créer un dégradé coloré \ndans notre pixel shader. \nDéfinissons une fonction spécifique pour définir la couleur d'arrière-plan de la toile.\n\nCela produira un dégradé froid entre les nuances de violet et de cyan.\n\n*/\n\n#elif PART == 3\n\nvec3 getBackgroundColor(vec2 uv) {\n    uv += 0.5; // remap uv from <-0.5,0.5> to <0,1>\n    vec3 gradientStartColor = vec3(1., 0., 1.);\n    vec3 gradientEndColor = vec3(0., 1., 1.);\n    return mix(gradientStartColor, gradientEndColor, uv.y); // gradient goes from bottom to top\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy; // <0, 1>\n    uv -= 0.5; // <-0.5,0.5>\n    uv.x *= iResolution.x/iResolution.y; // fix aspect ratio\n\n    vec3 col = getBackgroundColor(uv);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n\n/*\nLorsque la fonction mix est utilisée sur des vecteurs, elle utilise le troisième paramètre pour interpoler\nchaque vecteur sur la base de ses composantes. \nLa fonction d'interpolation sera exécutée pour la composante rouge (ou composante x) du vecteur \ngradientStartColor et la composante rouge du vecteur gradientEndColor. \nLa même tactique sera appliquée aux canaux vert (composante y) et bleu (composante z) de chaque vecteur.\n\nNous avons ajouté 0,5 à la valeur de uv car, dans la plupart des cas,\nnous travaillerons avec des valeurs de uv comprises entre un nombre négatif et un nombre positif.\nSi nous passons une valeur négative dans le fragColor final, elle sera bloquée à zéro.\nNous éloignons la plage des valeurs négatives afin d'afficher la couleur dans toute sa gamme.\n*/\n\n/*\n# Une autre manière pour dessiner des formes 2D\n\nDans les tutoriels précédents, nous avons appris à utiliser les SDF 2D pour créer des formes 2D\ntelles que des cercles et des carrés. Cependant, les fonctions sdfCircle et sdfSquare\nrenvoyaient une couleur sous la forme d'un vecteur vec3.\n\nEn règle générale, les SDF renvoient une valeur float et non vec3. \nN'oubliez pas que \"SDF\" est un acronyme pour \"signed distance fields\" (champs de distance signés). \nNous nous attendons donc à ce qu'ils renvoient une distance de type float. \nDans les SDF 3D, c'est généralement le cas, mais dans les SDF 2D, \nje trouve qu'il est plus utile de renvoyer un ou zéro selon que le pixel se trouve à l'intérieur \nou à l'extérieur de la forme, comme nous le verrons plus tard.\n\nLa distance est relative à un point, généralement le centre de la forme.\nSi le centre d'un cercle se trouve à l'origine (0, 0), nous savons que tout point situé sur \nle bord du cercle est égal au rayon du cercle, d'où l'équation :\n\nx^2 + y^2 = r^2\n\nOr, when rearranged,\nx^2 + y^2 - r^2 = 0\n\nwhere x^2 + y^2 - r^2 = distance = d\n\nSi la distance est supérieure à zéro, nous savons que nous sommes à l'extérieur du cercle.\nSi la distance est inférieure à zéro, nous sommes à l'intérieur du cercle.\nSi la distance est exactement égale à zéro, nous sommes à la limite du cercle. \n\nC'est là que la partie \"signée\" du \"champ de distance signé\" entre en jeu.\n\nLa distance peut être négative ou positive selon que la coordonnée du pixel se trouve à l'intérieur\nou à l'extérieur de la forme.\n\nDans la partie 2 de cette série de tutoriels, nous avons dessiné un cercle bleu à l'aide du code suivant :\n\n*/\n\n#elif PART == 4\n\nvec3 sdfCircle(vec2 uv, float r) {\n  float x = uv.x;\n  float y = uv.y;\n  \n  float d = length(vec2(x, y)) - r;\n  \n  return d > 0. ? vec3(1.) : vec3(0., 0., 1.);\n  // draw background color if outside the shape\n  // draw circle color if inside the shape\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = fragCoord/iResolution.xy; // <0,1>\n  uv -= 0.5;\n  uv.x *= iResolution.x/iResolution.y; // fix aspect ratio\n  \n  vec3 col = sdfCircle(uv, .2);\n\n  // Output to screen\n  fragColor = vec4(col,1.0);\n}\n\n/*\nLe problème de cette approche est que nous sommes obligés de dessiner un cercle de couleur\nbleue et un arrière-plan de couleur blanche.\n\nNous devons rendre le code un peu plus abstrait, afin de pouvoir dessiner les couleurs de l'arrière-plan\net de la forme indépendamment l'une de l'autre. \nCela nous permettra de dessiner plusieurs formes dans la scène et de sélectionner la couleur\nque nous voulons pour chaque forme et pour l'arrière-plan.\n\nExaminons une autre façon de dessiner le cercle bleu :\n*/\n\n#elif PART == 5\n\nfloat sdfCircle(vec2 uv, float r, vec2 offset) {\n  float x = uv.x - offset.x;\n  float y = uv.y - offset.y;\n\n  return length(vec2(x, y)) - r;\n}\n\nvec3 drawScene(vec2 uv) {\n  vec3 col = vec3(1.);\n  float circle = sdfCircle(uv, 0.1, vec2(0, 0));\n  \n  col = mix(vec3(0, 0, 1), col, step(0., circle));\n  \n  return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = fragCoord/iResolution.xy; // <0, 1>\n  uv -= 0.5; // <-0.5,0.5>\n  uv.x *= iResolution.x/iResolution.y; // fix aspect ratio\n\n  vec3 col = drawScene(uv);\n\n  // Output to screen\n  fragColor = vec4(col,1.0);\n}\n\n/*\nDans le code ci-dessus, nous faisons abstraction de certaines choses. \nNous avons une fonction drawScene qui sera responsable du rendu de la scène, \net la fonction sdfCircle renvoie maintenant un flottant qui représente la \"distance signée\"\nentre un pixel sur l'écran et un point sur le cercle.\n\nNous avons appris à connaître la fonction step dans la partie 2.\nElle renvoie une valeur de un ou de zéro en fonction de la valeur du second paramètre.\nEn fait, les fonctions suivantes sont équivalentes :\n\nfloat result = step(0., circle);\nfloat result = circle > 0. ? 1. : 0.;\n\nSi la valeur de la \"distance signée\" est supérieure à zéro, cela signifie que le point se trouve à l'intérieur du cercle. Si la valeur est inférieure ou égale à zéro, cela signifie que le point se trouve à l'extérieur ou sur le bord du cercle.\n\nDans la fonction drawScene, nous utilisons la fonction mix pour mélanger\nla couleur blanche de l'arrière-plan avec la couleur bleue.\nLa valeur de circle déterminera si le pixel est blanc (le fond) ou bleu (le cercle).\nEn ce sens, nous pouvons utiliser la fonction mix comme un \"interrupteur\" qui basculera entre la couleur\nde la forme et la couleur de l'arrière-plan en fonction de la valeur du troisième paramètre.\n\nL'utilisation d'un SDF de cette manière nous permet de dessiner la forme uniquement \nsi le pixel se trouve à une coordonnée située à l'intérieur de la forme. \nDans le cas contraire, il doit dessiner la couleur qu'il avait auparavant.\n\nAjoutons un carré légèrement décalé par rapport au centre.\n\nL'utilisation de la fonction mix avec cette approche nous permet\nde rendre facilement plusieurs formes 2D dans la scène !\n\n*/\n\n#elif PART == 6\n\nfloat sdfCircle(vec2 uv, float r, vec2 offset) {\n  float x = uv.x - offset.x;\n  float y = uv.y - offset.y;\n  \n  return length(vec2(x, y)) - r;  \n}\n\nfloat sdfSquare(vec2 uv, float size, vec2 offset) {\n  float x = uv.x - offset.x;\n  float y = uv.y - offset.y;\n\n  return max(abs(x), abs(y)) - size;\n}\n\nvec3 drawScene(vec2 uv) {\n  vec3 col = vec3(1);\n  float circle = sdfCircle(uv, 0.1, vec2(0, 0));\n  float square = sdfSquare(uv, 0.07, vec2(0.1, 0));\n  \n  col = mix(vec3(0, 0, 1), col, step(0., circle));\n  col = mix(vec3(1, 0, 0), col, step(0., square));\n  \n  return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = fragCoord/iResolution.xy; // <0, 1>\n  uv -= 0.5; // <-0.5,0.5>\n  uv.x *= iResolution.x/iResolution.y; // fix aspect ratio\n\n  vec3 col = drawScene(uv);\n\n  // Output to screen\n  fragColor = vec4(col,1.0);\n}\n\n/*\n# Arrière-plan personnalisé et formes 2D multiples\n\nAvec les connaissances que nous avons acquises, nous pouvons facilement personnaliser\nnotre arrière-plan tout en laissant la couleur de nos formes intacte.\nAjoutons une fonction qui renvoie une couleur de dégradé pour l'arrière-plan \net utilisons-la en tête de la fonction drawScene.\n\n*/\n#elif PART == 7\nvec3 getBackgroundColor(vec2 uv) {\n    uv += 0.5; // remap uv from <-0.5,0.5> to <0,1>\n    vec3 gradientStartColor = vec3(1., 0., 1.);\n    vec3 gradientEndColor = vec3(0., 1., 1.);\n    return mix(gradientStartColor, gradientEndColor, uv.y); // gradient goes from bottom to top\n}\n\nfloat sdfCircle(vec2 uv, float r, vec2 offset) {\n  float x = uv.x - offset.x;\n  float y = uv.y - offset.y;\n  \n  return length(vec2(x, y)) - r;\n}\n\nfloat sdfSquare(vec2 uv, float size, vec2 offset) {\n  float x = uv.x - offset.x;\n  float y = uv.y - offset.y;\n  return max(abs(x), abs(y)) - size;\n}\n\nvec3 drawScene(vec2 uv) {\n  vec3 col = getBackgroundColor(uv);\n  float circle = sdfCircle(uv, 0.1, vec2(0, 0));\n  float square = sdfSquare(uv, 0.07, vec2(0.1, 0));\n  \n  col = mix(vec3(0, 0, 1), col, step(0., circle));\n  col = mix(vec3(1, 0, 0), col, step(0., square));\n  \n  return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = fragCoord/iResolution.xy; // <0, 1>\n  uv -= 0.5; // <-0.5,0.5>\n  uv.x *= iResolution.x/iResolution.y; // fix aspect ratio\n\n  vec3 col = drawScene(uv);\n\n  // Output to screen\n  fragColor = vec4(col,1.0);\n}\n\n/*\n# Conclusion\n\nDans cette leçon, nous avons créé une belle œuvre d'art numérique. \nNous avons appris à utiliser la fonction de mélange pour créer un dégradé de couleurs \net à l'utiliser pour rendre des formes les unes au-dessus des autres ou au-dessus d'un calque d'arrière-plan. \nDans la prochaine leçon, je parlerai d'autres formes 2D que nous pouvons dessiner, \ntelles que des coeurs et des étoiles.\n*/\n\n\n\n\n#endif","name":"Image","description":"","type":"image"}]}