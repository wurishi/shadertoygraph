{"ver":"0.1","info":{"id":"Xc33DX","date":"1712230514","viewed":71,"name":"Breathing balls","username":"augub","description":"My first 3d fractal shader","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["3d","fractal"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float EPS = 0.001;\nint ITER = 200; // Keeping this low creates a cool glossy effect. 200 is 'better'\nfloat MAX_DIST = 40.0;\nint REC_DEPTH = 3;\nvec3 light = vec3(30., 60., -10.);\n\nmat3 rotationMatrix(float angleX, float angleY, float angleZ) {\n    float cx = cos(angleX);\n    float sx = sin(angleX);\n    float cy = cos(angleY);\n    float sy = sin(angleY);\n    float cz = cos(angleZ);\n    float sz = sin(angleZ);\n\n    mat3 rotationX = mat3(1.0, 0.0, 0.0, 0.0, cx, -sx, 0.0, sx, cx);\n\n    mat3 rotationY = mat3(cy, 0.0, sy, 0.0, 1.0, 0.0, -sy, 0.0, cy);\n\n    mat3 rotationZ = mat3(cz, -sz, 0.0, sz, cz, 0.0, 0.0, 0.0, 1.0);\n\n    // Combine rotation matrices for x, y, and z axes\n    return rotationX * rotationY * rotationZ;\n}\n\nfloat inf = 1e20;\n\nfloat maxcomp(in vec3 v) {\n    return max(v.x, max(v.y, v.z));\n}\n\nfloat minel(vec3 v) {\n    return min(v.x, min(v.y, v.z));\n}\nfloat maxel(vec3 v) {\n    return -minel(-v);\n}\n\nfloat smoothmax(float a, float b, float l) {\n    return log2(exp2(a * l) + exp2(b * l)) / l;\n}\n\nfloat smoothmin(float a, float b, float l) {\n    return -smoothmax(-a, -b, l);\n}\n\nfloat smin(float a, float b, float k) {\n    float h = clamp(0.5 + 0.5 * (a - b) / k, 0.0, 1.0);\n    return mix(a, b, h) - k * h * (1.0 - h);\n}\n\nvec3 possign(vec3 v) {\n    vec3 s = sign(v);\n    return s + (1. - abs(s));\n}\n\nfloat sdBox(vec3 p, vec3 b) {\n    vec3 q = abs(p) - b;\n    return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);\n}\n\n\nvec3 map(vec3 p) {\n\n    mat3 rot = rotationMatrix(0., iTime / 3., 0.);\n    p = inverse(rot) * p;\n    p = p / 2.;\n\n    float r = 1.;\n    float radius = 1.5 + sin(iTime) / 7.;\n    //float d = length(p) - radius;\n    float d = sdBox(p, vec3(1.0) + sin(iTime) / 2.);\n    vec3 k = p;\n    vec3 res = vec3(d, 1., 0.);\n    for (int i = 0; i < REC_DEPTH; i++) {\n        r *= 3.;\n        vec3 id = round(k);\n        vec3 edge_helper = min(abs(id), 1.);\n        float in_edge = maxel(edge_helper) - minel(edge_helper);\n        vec3 edge_offset = in_edge * (edge_helper - 1.) * possign(k);\n        k = (k - clamp(id, -1., 1.) + edge_offset) * 3.;\n        //float d_k = (length(k) - radius) / r;\n\n        float d_k = (sdBox(k, vec3(1.0) + sin(iTime) / 2.)) / r;\n        if (d_k < d) {\n            d = smin(d, d_k, 1. /30.);\n            res = vec3(d, 1.0, (1. + float(i)) / float(REC_DEPTH));\n        } else {\n            d = smin(d, d_k, 1. / 30.);\n            res = vec3(d, 1.0, res.z);\n        }\n    }\n    return res;\n}\n\nvec3 normal(vec3 p) {\n    vec2 e = vec2(EPS, 0.0);\n    return normalize(\n        map(p).x - vec3(map(p - e.xyy).x, map(p - e.yxy).x, map(p - e.yyx).x));\n}\n\nstruct RayMarchResult {\n    vec3 position;\n    vec3 normal;\n    float elemID;\n};\n\nfloat softshadow(in vec3 ro, in vec3 rd, float mint, float maxt, float k) {\n    float res = 1.0;\n    float t = mint;\n    for (int i = 0; i < 256 && t < maxt; i++) {\n        float h = map(ro + rd * t).x;\n        if (abs(h) < 0.001)\n            return 0.0;\n        res = min(res, k * h / t);\n        t += h;\n    }\n    return res;\n}\n\nvec4 rayMarch(vec3 ro, vec3 rd) {\n    // ro: ray origin\n    // rd: ray direction\n    float t = 0.0;\n    vec4 res = vec4(0.);\n\n    for (int i = 0; i < ITER; i++) {\n        vec3 p = ro + rd * t;\n        vec3 map_result = map(p);\n        float dist = map_result.x;\n        if (abs(dist) < EPS) {\n            res.xyz = p;\n            res.w = map_result.z;\n            return res;\n        } else if (t > MAX_DIST) {\n            break;\n        }\n        t += dist;\n    }\n    res.xyz = vec3(0.);\n    return res;\n}\n\nstruct View {\n    vec3 pixel;\n    vec3 cam;\n};\n\nView get_view(in vec2 uv) {\n\n    // Camera position\n    vec3 cam = vec3(0., 0., 0.);\n\n    // Screen distance\n    float screen_distance = 2.;\n\n    // Pixel position\n    vec3 pixel = normalize(vec3(uv, screen_distance));\n\n    // Viewing angle\n    vec3 angle = vec3(0.5, -0.4, 0.);\n\n    // Get a rotation matrix\n    mat3 rotation = rotationMatrix(angle.x, angle.y, angle.z);\n\n    // Rotate the pixel\n    pixel = pixel * rotation;\n\n    // Translate the pixel and camera\n    float dist = 10.;\n    vec3 translation = dist * normalize(vec3(3.3, 4.3, -8.));\n    pixel += translation;\n    cam += translation;\n\n    // Rotate around the center\n    mat3 rotation2 = rotationMatrix(0., iTime / 3., 0.);\n    vec3 center = vec3(0., 0., 0.);\n    // pixel = pixel * rotation2 + center;\n    // cam = cam * rotation2 + center;\n    View view;\n    view.pixel = pixel;\n    view.cam = cam;\n    return view;\n}\n\nvec4 get_color(in vec4 march) {\n    vec4 fragCol = vec4(1.);\n    if (march.xyz == vec3(0.)) {\n        fragCol = vec4(1., 1., 1., 1.);\n        return fragCol;\n    }\n\n    // Get a color based on the element ID\n    float elemID = march.w;\n    fragCol = vec4(elemID, 1. - elemID, 1., 1.0);\n\n    // Calculate the light direction\n    vec3 l = normalize(light - march.xyz);\n\n    // Compute the angle between the normal and the light direction\n    vec3 n = normal(march.xyz);\n    float angle = dot(normalize(l), normalize(n));\n    float illumination = smoothstep(-1., 1., angle);\n    fragCol *= illumination;\n\n    return fragCol;\n}\n\nfloat random(vec2 st) {\n    return fract(sin(dot(st.xy, vec2(12.9898, 78.233))) * 43758.5453123);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n    // Normalized coordinates\n    vec2 uv = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n\n    View view = get_view(uv);\n\n    vec3 dir = normalize(view.pixel - view.cam);\n\n    // Raymarching to find the surface\n    vec4 from_pixel = rayMarch(view.pixel, dir);\n\n    fragColor = get_color(from_pixel);\n    if (fragColor.xyz == vec3(1., 1., 1.)) {\n        return;\n    }\n\n    // Calculate the first surface in the direction of the light source\n    vec3 n = normal(from_pixel.xyz);\n    vec3 l = normalize(light - from_pixel.xyz);\n\n    vec3 above_surface = from_pixel.xyz + 1.01 * EPS * n;\n    float shadow;\n    if (fragColor.xyz != vec3(1., 1., 1.)) {\n        shadow = softshadow(above_surface, l, 0.01, 100., 10.);\n    } else {\n        shadow = 1.;\n    }\n    fragColor.xyz *= smoothstep(-0.5, 0.5, shadow);\n\n    // Compute surface to mirror\n    if (fragColor.xyz != vec3(1., 1., 1.)) {\n        vec3 from_dir = dir;\n        vec3 norm = n;\n        vec3 from_surface = above_surface;\n        for (int i = 0; i < 4; i += 1) {\n            vec3 reflected_dir =\n                normalize(from_dir - 2. * dot(from_dir, norm) * norm);\n            vec4 mirroring = rayMarch(from_surface, reflected_dir);\n            vec4 color = get_color(mirroring);\n            fragColor = 0.7 * fragColor + 0.3 * color;\n            float p = 0.5;\n            fragColor =\n                fragColor + p * smoothstep(0.95, 1.0, dot(norm, normalize(l)));\n            if (color.xyz == vec3(1., 1., 1.)) {\n                break;\n            }\n            from_dir = reflected_dir;\n            norm = normal(mirroring.xyz);\n            from_surface = mirroring.xyz + 1.01 * EPS * norm;\n        }\n    }\n    fragColor.w = 1.0;\n}","name":"Image","description":"","type":"image"}]}