{"ver":"0.1","info":{"id":"MdcyWB","date":"1588528759","viewed":61,"name":"negative lights 2","username":"Azorlogh","description":"If negative light was a thing.\n\nA fixed light source and a rotating negative light source.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["negativelights"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float PI = 3.14159265358979323846;\n\nvec3 rotateXY(vec3 v, float a) {\n\tfloat c = cos(a), s = sin(a);\n\treturn mat3(\n\t\tc, s, 0,\n\t\t-s, c, 0,\n\t\t0, 0, 1\n\t)*v;\n}\nvec3 rotateXZ(vec3 v, float a) {\n\tfloat c = cos(a), s = sin(a);\n\treturn mat3(\n\t\tc, 0, s,\n\t\t0, 1, 0,\n\t\t-s, 0, c\n\t)*v;\n}\nvec3 rotateYZ(vec3 v, float a) {\n\tfloat c = cos(a), s = sin(a);\n\treturn mat3(\n\t\t1, 0, 0,\n\t\t0, c, s,\n\t\t0, -s, c\n\t)*v;\n}\n\n// Operations\nfloat opU(float a, float b) { return min(a,b); }\nfloat opI(float a, float b) { return max(a,b); }\nfloat opD(float a, float b) { return max(a, -b); }\n\n// Transformations\nvec3 deform( vec3 p )\n{\n    p.xyz += .300*sin(  2.0*p.zxy );\n    p.xyz += 0.450*sin(  4.0*p.zxy );\n    p.xyz += 0.250*sin(  8.0*p.zxy );\n    return p;\n}\n\n// Distance functions\nfloat sphereSDF(vec3 p, float r) { return length(p)-r; }\nfloat boxSDF( vec3 p, vec3 b ) { vec3 d = abs(p) - b; return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0)); }\nfloat planeSDF( vec3 p, vec4 n ) { return dot(p,n.xyz) + n.w; }\nfloat torusSDF( vec3 p, vec2 t ) { vec2 q = vec2(length(p.xz)-t.x,p.y); return length(q)-t.y; }\n\n// Scene\nfloat sceneSDF(vec3 p) {\n    return opU(\n        torusSDF(p+vec3(-.5,-.8,-.5), vec2(1.,.5))*.1,\n        planeSDF(p, normalize(vec4(0,1,0,2)))\n    );\n}\n\n\n\n/////////////////////////////////////////////////\n\n// Marching\n\n#define EPSILON 1e-4\n#define MAX_STEPS 512\n#define tmin 0.\n#define tmax 1e2\n\nvec3 getNormal( in vec3 pos ) {\n    vec2 e = vec2(0.001, -0.001);\n    return normalize(\n        e.xyy * sceneSDF(pos + e.xyy) + \n        e.yyx * sceneSDF(pos + e.yyx) + \n        e.yxy * sceneSDF(pos + e.yxy) + \n        e.xxx * sceneSDF(pos + e.xxx));\n}\n\nfloat shadow(vec3 ro, vec3 rd, float lightDist) {\n    float t = EPSILON;\n    float penumbra = 1e8;\n    for (int i=0; i<MAX_STEPS; i++) {\n        float dist = sceneSDF(ro+rd*t);\n        if (dist < EPSILON) {\n            return 0.;\n        }\n        penumbra = min(penumbra, 64.*dist/t);\n        t += dist;\n        if (t > lightDist) {\n            return smoothstep(penumbra, 0., .1);\n        }\n    }\n    return 0.;\n}\n\nfloat march(vec3 ro, vec3 rd) {\n    float t = tmin;\n    for (int i=0; i<MAX_STEPS; i++) {\n        float dist = sceneSDF(ro+rd*t);\n        if (dist < EPSILON) {\n            return t;\n        }\n        if (dist > tmax) {\n            return -1.;\n        }\n        t += dist;\n    }\n    return -1.;\n}\n\nfloat marchSphere(vec3 ro, vec3 rd, vec3 pos, float rad) {\n    float t = tmin;\n    for (int i=0; i<MAX_STEPS; i++) {\n        float dist = length(ro+rd*t + pos)-rad;\n        if (dist < EPSILON) {\n            return t;\n        }\n        if (dist > tmax) {\n            return -1.;\n        }\n        t += dist;\n    }\n    return -1.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time = iTime*.3;\n    \n    vec3 lightDir = normalize(vec3(1,1,1));\n\tvec3 darkDir  = normalize(vec3(cos(time),1./sqrt(3.),sin(time)));\n    \n    vec2 pos = (fragCoord - iResolution.xy/2.) / (iResolution.y/2.);\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    \n    vec3 ro = vec3(0.,1,6.);\n    vec3 rd = normalize(vec3(pos, -1));\n    \n    \n    vec3 col;\n    \n    float tl = marchSphere(ro, rd, vec3(1,1,1)*-10., .2);\n    float td = marchSphere(ro, rd, vec3(cos(time),1,sin(time))*-10., .2);\n                           \n    if (tl != -1.) {fragColor = vec4(1,1,1,1); return;}\n    if (td != -1.) {fragColor = vec4(0,0,0,1); return;}\n    \n    float t = march(ro, rd);\n    if (t != -1.) {\n        vec3 p = ro+rd*t;\n        vec3 n = getNormal(p);\n        \n        vec3 sro = p+lightDir*10.;\n        vec3 srd = -normalize(lightDir);\n        float penumbra = shadow(sro, srd, 8.);\n        \n        float diff = max(dot(n, lightDir), 0.);\n        col += vec3(diff*penumbra);\n        \n        sro = p+darkDir*10.;\n        srd = -normalize(darkDir);\n        penumbra = shadow(sro, srd, 8.);\n        \n        diff = max(dot(n, darkDir), 0.);\n        col -= vec3(diff*penumbra);\n    }\n    \n    col = tanh(col)*.5+.5;\n\n    fragColor = vec4(col,1);\n}","name":"Image","description":"","type":"image"}]}