{"ver":"0.1","info":{"id":"3ttyzM","date":"1608683089","viewed":202,"name":"Unstable radiation","username":"Diapsid","description":"Trying to take an existing code I made and see if I can get it to look like a quasi-crystal","likes":9,"published":1,"flags":0,"usePreview":0,"tags":["pattern"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define M_PI = 3.14159265\n\n\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nfloat smoothClamp(float x, float a, float b)\n{\n    float t = clamp(x, a, b);\n    return t != x ? t : b + (a - b)/(1. + exp((b - a)*(2.*x - a - b)/((x - a)*(b - x))));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float PI = 3.14159263;\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    float freq;\n    float radius;\n    float t;\n    float rot;\n    int numEl;\n    float scale = 1.; //how bright the image is. set very high for pure B/W, set lower for grayscale\n\n    t = iTime*0.007*60.; //a timing constant\n    freq = 90.; //busyness of screen\n    radius = 0.8*cos(t*0.012)+2.; //radius of circle of points\n    rot = 0.02; //how fast the screen rotates\n    numEl = 6; //number of radiators on ring\n    \n\n    \n    float col = 0.;\n    if(numEl%2==0){ //if the number of radiators is even, it'll be lined up well\n    for(int i = 0; i<numEl; i++){\n    uv = fragCoord/iResolution.xy; //reset coordinate plane\n    uv.x *= iResolution.x/iResolution.y; //scale coordinates\n    uv.x -= 0.5*iResolution.x/iResolution.y; //move origin\n    uv.y-=0.5; //move origin\n    uv.x-=radius*cos(2.*3.14159*float(i)/float(numEl)-rot*t); //move to each point on ring\n    uv.y-=radius*sin(2.*3.14159*float(i)/float(numEl)-rot*t);\n    \n    col+=(scale/float(numEl))*cos(freq*length(uv)-t); //sum up the field magnitude at each point due to each radiator\n    //0.77 is a scaling factor. Set higher for wider color range.\n    }\n    }\n    \n    else{ //if number of radiators is odd, the ring needs to be rotated to be vertically symmetric\n    \n    for(int i = 0; i<numEl; i++){\n    uv = fragCoord/iResolution.xy;\n    uv.x *= iResolution.x/iResolution.y;\n    uv.x -= 0.5*iResolution.x/iResolution.y;\n    uv.y-=0.5;\n    uv.x-=radius*cos(2.*3.14159*float(i)/float(numEl)-rot*t+PI/2.);\n    uv.y-=radius*sin(2.*3.14159*float(i)/float(numEl)-rot*t+PI/2.);\n    \n    col+=(scale/float(numEl))*cos(freq*length(uv)-t);\n    }  \n    }\n    uv = fragCoord/iResolution.xy;\n    uv.y-=60.;\n    //uv.x-=10.;\n    \n    col-=0.35;\n    col+=1.*smoothClamp((scale*1.)*(cos(freq*0.02*length(uv.y)-t*1.)), 0.0, 0.6);//change the constants in this for different effects\n    col=1.*abs(col); //icy. uncomment to defrost\n   \n    vec3 col2 = pal(col, vec3(0.5, 0.5, 0.5),\n                        \tvec3(0.5, 0.5, 0.5),\n                        \tvec3(1.0, 1.0, 1.0),\n                        \tvec3(0.0, 0.1, 0.2));\n    \n    fragColor = vec4(vec3(col2), 1);\n}","name":"Image","description":"","type":"image"}]}