{"ver":"0.1","info":{"id":"XXB3WD","date":"1708439534","viewed":124,"name":"cute volumetric marble thing","username":"BluBloos","description":"my first go at volumetric rendering","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["volumetricrendering"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float R = 0.25;\nvec3 mid = vec3(0.5,0.5,0.5);\n\n// TODO: learn this.\nfloat perlinNoise(vec2 point) {\n    // Define lattice points\n    vec2 p = floor(point);\n    vec2 f = fract(point);\n    \n    // Interpolation function (could be improved with a smoother step function)\n    f = f*f*(3.0-2.0*f);\n    \n    // Hash function to generate pseudo-random gradients\n    float n = p.x + p.y * 57.0;\n    vec2  gradients[4] = vec2[](vec2(1,0), vec2(-1,0), vec2(0,1), vec2(0,-1));\n    float g00 = dot(gradients[int(mod(n, 4.0))], f - vec2(0,0));\n    float g10 = dot(gradients[int(mod(n + 1.0, 4.0))], f - vec2(1,0));\n    float g01 = dot(gradients[int(mod(n + 57.0, 4.0))], f - vec2(0,1));\n    float g11 = dot(gradients[int(mod(n + 58.0, 4.0))], f - vec2(1,1));\n    \n    // Interpolate between gradients\n    float gx0 = mix(g00, g10, f.x);\n    float gx1 = mix(g01, g11, f.x);\n    float gxy = mix(gx0, gx1, f.y);\n    \n    // Map result to [0, 1]\n    return 0.5 * gxy + 0.5;\n}\n\n\n// TODO: learn this.\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n// GLSL function to compute the angle between two vec3 vectors\nfloat angleBetweenVectors(vec3 v1, vec3 v2) {\n    // Normalize both vectors to ensure accurate angle calculation\n    vec3 v1Norm = normalize(v1);\n    vec3 v2Norm = normalize(v2);\n    \n    // Compute the dot product\n    float dotProd = dot(v1Norm, v2Norm);\n    \n    // Clamp dotProd to the range [-1.0, 1.0] to avoid NaN errors due to floating point inaccuracies\n    dotProd = clamp(dotProd, -1.0, 1.0);\n    \n    // Calculate the angle between the vectors in radians\n    float angle = acos(dotProd);\n    \n    // If you need the angle in degrees, uncomment the following line\n    // angle = degrees(angle);\n    \n    return angle;\n}\n\nfloat objectSdf(vec3 p)\n{\n    vec3 pp = p - mid;\n    \n    float x = abs(angleBetweenVectors( vec3(0.0,0.0,1.0), p));\n    float k =50.0;\n    float f=1.0;\n    \n        float sd = (R+sin(k*x-f*iTime)*R*0.1) - length(pp);\n    return sd;\n}\n\nvec3 objectColor(vec3 p)\n{\n    vec3 pp = p - mid;\n    float sr = length(pp)/R;\n\n    float f=1.0;\n    float noise = perlinNoise(p.xy * p.z*f); // 'scale' adjusts the noise frequency\n    \n   \n    float hue = noise;// map to degrees\n    // Convert HSV to RGB\n    // Assuming full saturation (1.0) and value (1.0) for vivid colors\n    vec3 color = hsv2rgb(vec3(hue*7.0, 1.0, 0.04));\n    \n    return color;    \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float aspect = iResolution.x / iResolution.y;\n\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy * vec2(aspect,1.0);\n\n    vec3 bgC = vec3(0.0, 0.0, 0.0);\n    vec3 sC = vec3(1.0,0.0,0.0);\n    float A = 1.0;\n    vec3 C = vec3(0.0, 0.0,0.0);\n    \n    \n    int count = 100;\n    float rayStepLen = 1.0/float(count);\n    \n    for ( int i = (count-1); i >=0; i-- )\n    {\n        // there exists a sphere; that's what we're sampling.\n        // and maybe there is a sinusoid on the radius of the sphere.\n        // we'll assume there is a directional light right in front of cam.\n        \n        // NOTE: notice that we sample the [0,1] space in xyz.\n        float z = rayStepLen*(float(i)+0.5); // sample the middle of the voxel.\n        float x = uv.x;\n        float y = uv.y;\n        \n        vec3 p = vec3(x,y,z);\n        \n        // we shall represent the object with an SDF.\n        // at the core, the \"solidness\" of the object goes up; it's more opaque.\n        // \n        float sd = objectSdf(p);\n        \n        C += objectColor(p) * A; // accumulate color.\n        //C = objectColor(p);\n        \n        // negative outside, positive inside, and zero on surface.\n        float Aj = max(0.0,sd/R*0.5);\n        A = A * (1.0-Aj);\n        \n    }\n    \n    A = 1.0 - A;\n    \n    // NOTE: we perform in-house blending.\n    fragColor = vec4(C*A+(1.0-A)*bgC, 1.0);\n}","name":"Image","description":"","type":"image"}]}