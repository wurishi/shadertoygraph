{"ver":"0.1","info":{"id":"dsBcD1","date":"1687656283","viewed":170,"name":"fragment shader sphere wave","username":"beffell","description":"IS_RAY_MARCHINGフラグを変更することで、\nレイマーチングとコリジョンの方式の切り替えができます。\n\n参考：\nhttps://www.shadertoy.com/view/ltsXzl\nhttps://www.shadertoy.com/view/4tcGDr\n","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["wave"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sX3zn","filepath":"/media/a/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png","previewfilepath":"/media/ap/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n    IS_RAY_MARCHING = true：レイマーチング（低パフォーマンス）\n    IS_RAY_MARCHING = false：コリジョン（高パフォーマンス）\n*/\n\nconst bool IS_RAY_MARCHING = false;\nconst int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float EPSILON = 0.001;\nconst float PI = 3.14159265359;\nconst float FLT_MAX = 3.402823466e+38;\n\n//球の距離関数\nfloat sphereSDF(vec3 p, float r) {\n    return length(p) - r;\n}\n\n//線と球の衝突座標取得関数\nfloat raySphereCollision (vec3 sphere, float radius, vec3 rayPos, vec3 rayDir)\n{\n\tvec3 m = rayPos - sphere.xyz;\n\n\tfloat b = dot(m, rayDir);\n\tfloat c = dot(m, m) - radius * radius;\n\tif(c > 0.0 && b > 0.0){\n\t\treturn MAX_DIST;\n    }\n\n\tfloat discr = b * b - c;\n\tif(discr < 0.0){\n\t\treturn MAX_DIST;\n    }\n\n\tfloat collisionTime = -b - sqrt(discr);\n\tif(collisionTime < 0.0){\n\t\tcollisionTime = -b + sqrt(discr);\n    }\n\n    return collisionTime;\n}\n\nfloat distanceSphereWave(vec3 cameraPos, vec3 rayDir, float depth) {\n    float balls = FLT_MAX;\n    for(float distance = 0.1; distance <= 2.0; distance += 0.2){\n        for(float radian = 0.0; radian < PI * 2.0; radian += PI / 10.0){\n            vec3 trans = vec3(0, 0, 0);\n            trans.x = sin(radian) * distance;\n            trans.z = cos(radian) * distance;\n            trans.y = abs(sin(iTime + distance)) * 0.8;\n            float radius = trans.y * 0.02;\n            if(IS_RAY_MARCHING){\n                vec3 samplePoint = cameraPos + depth * rayDir;\n                balls = min(balls, sphereSDF(samplePoint - trans, radius));\n            }else{\n                balls = min(balls, raySphereCollision(trans, radius, cameraPos, rayDir));\n            }\n        }\n    }\n\n    return balls;\n}\n\nfloat rayMarching(vec3 cameraPos, vec3 rayDir) {\n    float depth = MIN_DIST;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = distanceSphereWave(cameraPos, rayDir, depth);\n        if (dist < EPSILON) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= MAX_DIST) {\n            return MAX_DIST;\n        }\n    }\n    return MAX_DIST;\n}\n\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\nmat3 viewMatrix(vec3 cameraPos, vec3 center, vec3 up) {\n    vec3 f = normalize(center - cameraPos);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 viewDir = rayDirection(60.0, iResolution.xy, fragCoord);\n\n    vec2 mouse = iMouse.xy / iResolution.xy;\n    float angleX = iMouse.z > 0.0 ? PI * 2.0 * mouse.x : PI + iTime * 0.25;\n    float angleY = iMouse.z > 0.0 ? mouse.y : 0.5;\n    vec3 cameraPos = (vec3(sin(angleX)*cos(angleY), sin(angleY), cos(angleX)*cos(angleY))) * 5.0;\n    vec3 lookat = vec3(0.0, 0.5, 0.0);\n\n    mat3 viewToWorld = viewMatrix(cameraPos, lookat, vec3(0.0, 1.0, 0.0));\n    vec3 rayDir = viewToWorld * viewDir;\n\n    float dist = MAX_DIST;\n    if(IS_RAY_MARCHING){\n        dist = rayMarching(cameraPos, rayDir);\n    }else{\n        dist = distanceSphereWave(cameraPos, rayDir, 0.0);\n    }\n\n    if (dist > MAX_DIST - EPSILON) {\n        fragColor = vec4(texture(iChannel0, rayDir).rgb, 1.0);\n\t\treturn;\n    }\n    fragColor = vec4(1,1,1,1);\n}","name":"Image","description":"","type":"image"}]}