{"ver":"0.1","info":{"id":"WdySDW","date":"1574713751","viewed":74,"name":"filtering, mitchell, separable","username":"hornet","description":"comparing radial and separable evaluations of the mitchell-netravali filter, see http://mentallandscape.com/Papers_siggraph88.pdf\nsee also https://www.shadertoy.com/view/4sGcRW\nnote that a gaussian-filter is \"actually\" separable, producing the same result","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["filtering"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//note: range [-2;2]\n//note: not normalized\nfloat Mitchell1D(float x)\n{\n    //const float B = 0.0; //Catmull-Rom?\n\tconst float B = 1.0/3.0; //Mitchell\n\tconst float C = 0.5 * (1.0-B);\n\tx = abs( 2.0 * x );\n    if ( x > 2.0 )\n        return 0.0;\n\tif (x > 1.0)\n\t\treturn ((-B - 6.0*C) * x*x*x + (6.0*B + 30.0*C) * x*x + (-12.0*B - 48.0*C) * x + (8.0*B + 24.0*C)) * (1.0/6.0);\n\telse\n\t\treturn ((12.0 - 9.0*B - 6.0*C) * x*x*x + (-18.0 + 12.0*B + 6.0*C) * x*x + (6.0 - 2.0*B)) * (1.0/6.0);\n}\nfloat FilterMitchell_sep(vec2 p, vec2 r)\n{\n    p /= r;\n    return Mitchell1D(p.x) * Mitchell1D(p.y);\n}\nfloat FilterMitchell_rad(vec2 p, vec2 r)\n{\n    p /= r;\n    return Mitchell1D( length(p) ); //note: radius version...\n}\n\n// =======================\n\nfloat Gaussian( float x )\n{\n\tconst float alpha = 4.0;\n\tconst float expv = exp(-alpha); //note: radius = 1.0\n    return max(0.0, (exp(-alpha * x * x) - expv));\n    //return max(0.0, (exp(-alpha * x * x) - expv) / (1.0-expv)); //note: normalisation-factor to always get f(0)=1\n}\nfloat FilterGaussian_sep(vec2 p, vec2 radius )\n{\n    p /= radius;\n\treturn Gaussian(p.x) * Gaussian(p.y);\n}\nfloat FilterGaussian_rad(vec2 p, vec2 radius )\n{\n    p /= radius;\n    \n    return Gaussian( length(p) );\n}\n\nfloat filter_sep( vec2 p, vec2 r )\n{\n    return FilterMitchell_sep( p, r );\n    //return FilterGaussian_sep( p, r );\n}\nfloat filter_rad( vec2 p, vec2 r )\n{\n    return FilterMitchell_rad( p, r );\n    //return FilterGaussian_rad( p, r );\n}\n\n// =======================\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 ssuv = fragCoord/iResolution.xy;\n\tvec2 uv = 2.0 * fragCoord.xy / iResolution.xx;\n    if ( uv.y > 1.0 )\n    {\n        float aspect = iResolution.x / iResolution.y;\n        float y = 0.5 * aspect;\n        float h = 1.0 - y;\n        \n        vec2 luv = vec2( fract(uv.x), (ssuv.y-y)/h);\n        luv.y = luv.y/0.7-0.2;\n        \n        float x = -1.0+2.0*luv.x;\n        float f;\n        if ( ssuv.x < 0.5 )\n            f = filter_sep( vec2(x,0.0), vec2(1.0,1.0) );\n        else\n            f = filter_rad( vec2(x,0.0), vec2(1.0,1.0) );\n\n        float z = step( abs(luv.y-0.0), 0.5*dFdy(luv.y) );\n        fragColor = vec4( mix( vec3(0.85), vec3(0.5), z ), 1.0 );\n\n        float v = step( abs(luv.y-f), 0.5*dFdy(luv.y) );\n        fragColor = vec4( mix( fragColor.rgb, vec3(0.0), v ), 1.0 );\n        \n        return;\n    }\n    uv = fract(uv);\n    //fragColor = vec4( uv, 0, 1 ); return;\n\n    const vec2 r = vec2(0.5);\n    const vec2 ctr = vec2(0.5, 0.5 );\n    vec2 p = uv - ctr;\n    float v;\n    if ( ssuv.x < 0.5 )\n    {\n        v = filter_sep( p, r );\n    }\n    else\n\t{\n        v = filter_rad( p, r );\n    }\n\n    fragColor = 0.5 + vec4(vec3(10.0 * abs(v) ), 1.0 );\n    fragColor.rgb *= (v<0.0) ? vec3(1.0, 0.0, 0.25 ) : vec3(0, 0.5, 1.0 );\n    \n    float t = abs(fract( 10.0*v + iTime )-0.5);\n    t = min( 1.0, max( 0.0, t/0.3+0.7) );\n    \n    fragColor = clamp( fragColor, 0.0, 1.0 );\n    fragColor.rgb = mix( fragColor.rgb, vec3(0.0), 1.0-t );\n}\n","name":"Image","description":"","type":"image"}]}