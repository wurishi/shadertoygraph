{"ver":"0.1","info":{"id":"3dXXW7","date":"1605656850","viewed":59,"name":"image_transform_test","username":"alfredo_giani","description":"some tests on math operations on images","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["imageprocessing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n#define NS 3\n\n#define LUT_size 150\n#define T_scan 50\n    \n\nfloat bezier_1D(float t, float x0, float x1, float x2, float x3)   \n    \n{\n    float x;\n    \n    x = pow(1.0 - t,3.0)*x0 + 3.0*pow(1.0 - t,2.0)*t*x1 + 3.0*(1.0 - t)*pow(t,2.0)*x2 + pow(t,3.0)*x3;\n    \n    return x;\n    \n}\n\n\nvec2 bezier_xy(float t, vec2 p0, vec2 p1, vec2 p2, vec2 p3)   \n    \n{\n    \n    vec2 result;\n    \n    result.x = \tbezier_1D(t, p0.x, p1.x, p2.x, p3.x);\n    result.y = \tbezier_1D(t, p0.y, p1.y, p2.y, p3.y);\n    \n    return result;\n    \n    \n}\n\n\nfloat binary_chop(float x, float x0, float x1, float x2, float x3, float tolerance){\n    \n   \n    float left_t = 0.0, right_t =1.0; \n    float mid_t = 0.5;\n    \n    float left_x = bezier_1D(left_t, x0, x1, x2, x3);\n    float right_x = bezier_1D(right_t,x0, x1, x2, x3);\n    float mid_x = bezier_1D(mid_t, x0, x1, x2, x3);\n    \n    \n    int maxiter = 10000, iter_count = 0;\n    \n    float error = 1000.0;\n    \n    while(iter_count < maxiter){\n        \n        \n        if( abs(x - mid_x) <= tolerance)\n        \treturn mid_t;\n    \n        else if( abs(x - left_x) <= tolerance)\n            return left_t;\n\n        else if( abs(x - right_x) <= tolerance)\n            return right_t;\n         \n            \n        else{\n\n            if ( (x > min(left_x,mid_x)) && (x < max(left_x,mid_x)) )\n\n                right_t = mid_t;\n            \tmid_t = 0.5*(left_t + right_t);\n\n\n            if ( (x > min(right_x,mid_x)) && (x < max(right_x,mid_x)) )\n\n                left_t = mid_t;\n            \tmid_t = 0.5*(left_t + right_t);\n            \n            \n            left_x = bezier_1D(left_t, x0, x1, x2, x3);\n            right_x = bezier_1D(right_t,x0, x1, x2, x3);\n            mid_x = bezier_1D(mid_t, x0, x1, x2, x3);\n            \n            \n        }\n        \n        \n        iter_count++;\n        \n    }\n    \n\n    return -1.0;\n\t\n    \n}\n \n\n\n\n// find the index of the containing segment. x is supposed to be strictly monotonic so there is only one segment \n// that contains x, and this is determined by x0 and x3\n\n\nint return_containing_index(float x,vec2 p0[3], vec2 p1[3], vec2 p2[3], vec2 p3[3])\n{\n    int index =0;\n    \n    for(int i = 0; i < 3; i++){\n        \n        index = i;\n        if( ( x >=min(p0[i].x,p3[i].x) ) && ( x <= max(p0[i].x,p3[i].x) ) ){\n           break;\n        }\n    }\n    return index;\n\n\n}\n\n\nfloat find_t_approximant(float x,float x0, float x1, float x2, float x3)\n{\n    \n    float tolerance = 0.001;\n    \n    \n    // binary chop           \n    \n    float t = binary_chop(x, x0, x1, x2, x3, tolerance);\n    \n           \n    return t;\n    \n}\n\nfloat lut_getValue(vec2 xy_t[LUT_size], float x){\n    \n    \n    for(int i = 0; i < LUT_size - 1;i ++){\n     \n        if( ! ( (xy_t[i].x <= x) ^^ (x < xy_t[i+1].x))){\n            \n            float w1 = abs((x - xy_t[i].x)/(xy_t[i+1].x - xy_t[i].x));\n            float w0 = 1.0 - w1;\n            \n             \n            return w0*xy_t[i].y + w1*xy_t[i + 1].y;\n        }\n    }\n    if(xy_t[LUT_size -1].x == x){\n        return xy_t[LUT_size -1].y;\n    }\n    return -100.0;\n}\n\n\nfloat chop_getValue(float x, vec2 p0[3], vec2 p1[3], vec2 p2[3], vec2 p3[3]){\n    \n    // find the segment that contains x\n        \n    int index = return_containing_index(x,p0, p1, p2, p3);\n    \n    float t = find_t_approximant(x, p0[index].x, p1[index].x, p2[index].x, p3[index].x);\n        \n        //rad = t ==-1.0? 1.0: t;//float(index)/3.0;//bezier_1D(t, p0[index].y, p1[index].y, p2[index].y, p3[index].y);\n\n\treturn bezier_1D(t, p0[index].y, p1[index].y, p2[index].y, p3[index].y);//t; //float(index)/3.0; //-1.0;\n\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   \n    \n    \n    vec2 p0[3], p1[3], p2[3], p3[3];\n    \n    \n    p0[0].x =  0.000000;\n    p0[0].y =  0.000000;\n    p1[0].x =  0.023795;\n    p1[0].y =  0.326981;\n    p2[0].x =  0.163915;\n    p2[0].y =  0.937128;\n    p3[0].x =  0.221984;\n    p3[0].y =  0.935179;\n    p0[1].x =  0.221984;\n    p0[1].y =  0.935179;\n    p1[1].x =  0.287324;\n    p1[1].y =  0.932852;\n    p2[1].x =  0.294501;\n    p2[1].y =  0.268533;\n    p3[1].x =  0.436698;\n    p3[1].y =  0.270860;\n    p0[2].x =  0.436698;\n    p0[2].y =  0.270860;\n    p1[2].x =  0.660946;\n    p1[2].y =  0.271006;\n    p2[2].x =  0.804181;\n    p2[2].y =  0.989497;\n    p3[2].x =  1.0;\n    p3[2].y =  1.0;\n    \n    \n    vec2 xy_t[LUT_size];\n    int t_step = 1;\n        \n\t  \n    for(int nseg = 0; nseg <3; nseg++){\n   \n        for(int t =0;t <=T_scan; t+=t_step){\n        \txy_t[t + T_scan*nseg] = bezier_xy(float(t)/float(T_scan),p0[nseg],p1[nseg],p2[nseg],p3[nseg]);\n        }\n    }\n\n    \n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    //float rad =sqrt(pow(uv.x-0.5,2.0) + pow(uv.y-0.5,2.0)); \n    \n    \n    float rad;\n    \n    \n    #define EDGE_INC 0.005\n    \n    \n    if(uv.y >0.75 + EDGE_INC)        \n             rad = uv.x;\n\n    else if((uv.y >(0.5+EDGE_INC) ) && (uv.y <=(0.75-EDGE_INC) )){\n\n\n        rad = lut_getValue(xy_t,uv.x);\n\n    }\n    else if((uv.y >(0.25+EDGE_INC)) && (uv.y <=(0.5-EDGE_INC)))\n        rad = chop_getValue(uv.x,p0, p1, p2, p3);\n\n    else if((uv.y >(0.00+EDGE_INC)) && (uv.y <=(0.25-EDGE_INC)))\n        rad = uv.x;\n        \n    else\n        rad = -1.0;\n\n        \n    \n    vec3 col;\n    \n    if(rad ==100.0){\n        \n        col = vec3(0.0,rad,0.0);\n    }\n    else if(rad <0.0){\n        \n        col = vec3(0.0,0.0,1.0);\n    }\n    else if(rad > 1.0)\n        col = vec3(1.0, 0.0, 0.0);\n    else\n       \tcol = vec3(rad,rad, rad);     \n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}