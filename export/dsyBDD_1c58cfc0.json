{"ver":"0.1","info":{"id":"dsyBDD","date":"1698227469","viewed":102,"name":"Simple Diamond SDF","username":"denosya","description":"Very simple SDF for a diamond shape (approximation)","likes":5,"published":1,"flags":0,"usePreview":1,"tags":["personnaltoolbox"],"hasliked":0,"parentid":"cdKBDz","parentname":"Diamond Logo"},"renderpass":[{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float radius = 3.;\nconst float subdivision = 8.;\nconst float bottom_height = 4.;\nconst float top_height = 3.;\nconst float top_cut = 0.33;\nconst vec3 refraction_index = vec3(1.15, 1.16, 1.17);\n\n\nvec3 angularRepeat(vec3 m, float n) {\n   \n  float astep  = 2.*3.1415/n; \n  float origin = -astep*0.5;\n  float angle  = atan(m.z, m.x) - origin;\n\n  angle = origin + mod(angle, astep);\n\n  float r = length(m.xz);\n\n  return vec3(cos(angle)*r, m.y, sin(angle)*r);\n}\n\nfloat sdDiamond(vec3 m) {\n\n    m = angularRepeat(m, subdivision);\n\n    vec2 p = m.xy;\n\n    const float h1 = bottom_height;\n    const float h2 = top_height;\n\n    const vec2 origin = vec2(radius,0);\n    const vec2 normal1 = normalize(vec2(h1,-radius));\n    const vec2 normal2 = normalize(vec2(h2,radius));\n    \n    float d1 = dot(p-origin, normal1);\n    float d2 = dot(p-origin, normal2);    \n    \n    float d = max(d1, d2);\n    float vdist = max(m.y - h2*top_cut, -h1-m.y);\n    \n    return max(d, vdist);\n}\n\nfloat map(in vec3 m) {\n\n    m.y -= 1.;\n\n    return sdDiamond(m);\n}\n\nbool rayMarching(in vec3 ro, in vec3 rd, out vec3 m) {\n\n    const float maxMarch = 30.0;\n\n    float\tmarchingDist = 0.0;\n    float \tnbIter \t\t = 0.0;\n\n    for(int i = 0; i<50; i++) {\n        \n        m = ro + rd * marchingDist;    \n        \n    \tfloat dist = map(m);\n        \n        if(dist < 0.01) {\n            return true;\n        }\n        else {\n            marchingDist += dist;\n            \n            if(marchingDist >= maxMarch) {\n                break;\n            }\n        }\n    }\n    \n\treturn false;    \n}\n\n\nvec3 computeNormal(in vec3 pos) { // iq\n\tvec3 eps = vec3( 0.01, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t     map(pos+eps.xyy) - map(pos-eps.xyy),\n\t     map(pos+eps.yxy) - map(pos-eps.yxy),\n\t     map(pos+eps.yyx) - map(pos-eps.yyx));\n\treturn normalize(nor);\n}\n\nmat3 animateView() {\n    float angle = iTime*0.5;\n    float cosa = cos(angle);\n    float sina = sin(angle);\n    \n    return mat3(vec3(cosa, 0., sina), vec3(0., 1., 0.), vec3(-sina, 0., cosa));\n}\n\nvec4 run(in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - iResolution.xy * 0.5) / iResolution.y;\n    vec3 m;\n\n    vec3 ro = vec3(0,0,-10);\n    vec3 rd\t= normalize(vec3(uv.xy, 0.85));\n\n    mat3 transfo = animateView();\n\n    ro = transfo * ro;\n    rd = transfo * rd;\n\n    vec3 light = vec3(1,0,0);\n\n    if(rayMarching(ro, rd, m)) {\n    \n        vec3 normal = computeNormal(m);\n        vec3 refl = reflect(rd, normal);\n        \n        vec3 refr1R = refract(rd, normal, 1./refraction_index.r);        \n        vec3 refr1G = refract(rd, normal, 1./refraction_index.g);                \n        vec3 refr1B = refract(rd, normal, 1./refraction_index.b);                        \n        \n        vec3 ro2R = m + refr1R * 10.;\n        vec3 ro2G = m + refr1G * 10.;\n        vec3 ro2B = m + refr1B * 10.;        \n        \n        vec3 m2R, m2G, m2B; \n        \n        rayMarching(ro2R, -refr1R, m2R);\n        rayMarching(ro2G, -refr1G, m2G);\n        rayMarching(ro2B, -refr1B, m2B);        \n        \n        vec3 normal2R = computeNormal(m2R);\n        vec3 normal2G = computeNormal(m2G);\n        vec3 normal2B = computeNormal(m2B);        \n        \n        vec3 refr2R = refract(refr1R, -normal2R, refraction_index.r);        \n        vec3 refr2G = refract(refr1G, -normal2G, refraction_index.g);        \n        vec3 refr2B = refract(refr1B, -normal2B, refraction_index.b);                \n        \n        if(dot(refr2R, refr2R)==0.) refr2R = reflect(refr1R, -normal2R); \n        if(dot(refr2G, refr2G)==0.) refr2G = reflect(refr1G, -normal2G); \n        if(dot(refr2B, refr2B)==0.) refr2B = reflect(refr1B, -normal2B);               \n\n        float refractionR = texture(iChannel0, refr2R).r;\n        float refractionG = texture(iChannel0, refr2G).g;\n        float refractionB = texture(iChannel0, refr2B).b;        \n        \n        vec4 refraction = vec4(refractionR, refractionG, refractionB, 1.);\n        vec4 reflection = texture(iChannel0, refl);        \n        \n        float reflectivity = pow(1.0-dot(-rd, normal), 4.0);\n        \n        return mix(refraction, reflection, reflectivity);\n    }\n    else {\n        return texture(iChannel0, rd);\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n    vec4 p0 = run(fragCoord + vec2(+0.0,+0.0));\n    vec4 p1 = run(fragCoord + vec2(+0.5,+0.5));\n    vec4 p2 = run(fragCoord + vec2(+0.5,-0.5));\n    vec4 p3 = run(fragCoord + vec2(-0.5,+0.5));\n    vec4 p4 = run(fragCoord + vec2(-0.5,-0.5));\n\n    fragColor = (p0+p1+p2+p3+p4) / 5.;\n}\n    \n    ","name":"Image","description":"","type":"image"}]}