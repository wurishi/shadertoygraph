{"ver":"0.1","info":{"id":"lsd3D2","date":"1452448848","viewed":2401,"name":"Untitled 07","username":"floz","description":"Love touch to end this everyday week of shadertoy","likes":21,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","heart","repeat","love"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[],"code":"#define PI 3.141592654\n#define EPSILON 0.0000001\n#define AMPLITUDE 0.52\n#define SPEED 0.05\n#define rgb(r,g,b) (vec3(r,g,b)/255.)\n\n//------------------------------------------------------------------ VISUAL QUALITY\n#define RAYMARCHING_STEP 65\n#define RAYMARCHING_JUMP 1.\n\n//------------------------------------------------------------------ DEBUG\n//#define RENDER_DEPTH\n//#define RENDER_NORMAL\n//#define RENDER_AO\n\n//------------------- FORMULAS/MAGIC\n\nfloat length2( vec2 p )\n{\n\treturn sqrt( p.x*p.x + p.y*p.y );\n}\nfloat length6( vec2 p )\n{\n\tp = p*p*p; p = p*p;\n\treturn pow( p.x + p.y, 1.0/6.0 );\n}\nfloat length8( vec2 p )\n{\n\tp = p*p; p = p*p; p = p*p;\n\treturn pow( p.x + p.y, 1.0/8.0 );\n}\n\nvec4 vec4pow( in vec4 v, in float p ) {\n    // Don't touch alpha (w), we use it to choose the direction of the shift\n    // and we don't want it to go in one direction more often than the other\n    return vec4(pow(v.x,p),pow(v.y,p),pow(v.z,p),v.w); \n}\n\nvec4 permute(vec4 x){return mod(x*x*34.0+x,289.);}\n\nfloat snoise(vec3 v){\n  const vec2  C = vec2(0.166666667, 0.33333333333) ;\n  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n  vec3 i  = floor(v + dot(v, C.yyy) );\n  vec3 x0 = v - i + dot(i, C.xxx) ;\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min( g.xyz, l.zxy );\n  vec3 i2 = max( g.xyz, l.zxy );\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy;\n  vec3 x3 = x0 - D.yyy;\n  i = mod(i,289.);\n  vec4 p = permute( permute( permute(\n\t  i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n\t+ i.y + vec4(0.0, i1.y, i2.y, 1.0 ))\n\t+ i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n  vec3 ns = 0.142857142857 * D.wyz - D.xzx;\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);\n  vec4 x_ = floor(j * ns.z);\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = floor(j - 7.0 * x_ ) *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n  vec4 b0 = vec4( x.xy, y.xy );\n  vec4 b1 = vec4( x.zw, y.zw );\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n  vec3 p0 = vec3(a0.xy,h.x);\n  vec3 p1 = vec3(a0.zw,h.y);\n  vec3 p2 = vec3(a1.xy,h.z);\n  vec3 p3 = vec3(a1.zw,h.w);\n  vec4 norm = inversesqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m * m;\n  return .5 + 12.0 * dot( m, vec4( dot(p0,x0), dot(p1,x1),dot(p2,x2), dot(p3,x3) ) );\n}\n\n// Maximum/minumum elements of a vector\nfloat vmax(vec2 v) {\n\treturn max(v.x, v.y);\n}\n\nfloat vmax(vec3 v) {\n\treturn max(max(v.x, v.y), v.z);\n}\n\nfloat vmax(vec4 v) {\n\treturn max(max(v.x, v.y), max(v.z, v.w));\n}\n\nfloat hash( float n ){//->0:1\n\treturn fract(sin(n)*3538.5453);\n}\n\nfloat smin( float a, float b )\n{\n    float k = .1;\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat displacement( vec3 p, float v ) {\n  float f = iTime * -0.5 + sin( iTime * 2. ) * 1.4;\n  return sin( 20. * sin( cos( f ) ) *p.x)*sin( 10. *sin( cos( f ) ) *p.y)*sin( 30. * sin( cos( f ) ) *p.z);\n}\n\n// Repeat around the origin by a fixed angle.\n// For easier use, num of repetitions is use to specify the angle.\nfloat pModPolar(inout vec2 p, float repetitions, float dis) {\n\tfloat angle = 2.*PI/repetitions;\n\tfloat a = atan(p.y+0.0000001, p.x+0.0000001) + angle/2.;\n\tfloat r = length(p);\n\tfloat c = floor(a/angle);\n\ta = mod(a,angle) - angle/2.;\n\tp = vec2(cos(a), sin(a))*r + 0.0000001;\n\t// For an odd number of repetitions, fix cell index of the cell in -x direction\n\t// (cell index would be e.g. -5 and 5 in the two halves of the cell):\n\tif (abs(c) >= (repetitions/2.)) c = abs(c);\n\treturn c;\n}\n\n// Repeat around the origin by a fixed angle.\n// For easier use, num of repetitions is use to specify the angle.\nfloat pModPolar(inout vec2 p, float repetitions) {\n\tfloat angle = 2.*PI/repetitions;\n\tfloat a = atan(p.y+0.0000001, p.x+0.0000001) + angle/2.;\n\tfloat r = length(p);\n\tfloat c = floor(a/angle);\n\ta = mod(a,angle) - angle/2.;\n\tp = vec2(cos(a), sin(a))*r + 0.0000001;\n\t// For an odd number of repetitions, fix cell index of the cell in -x direction\n\t// (cell index would be e.g. -5 and 5 in the two halves of the cell):\n\tif (abs(c) >= (repetitions/2.)) c = abs(c);\n\treturn c;\n}\n\n// Repeat space along one axis. Use like this to repeat along the x axis:\n// <float cell = pMod1(p.x,5);> - using the return value is optional.\nfloat pMod1(inout float p, float size) {\n\tfloat halfsize = size*0.5;\n\tfloat c = floor((p + halfsize)/size);\n\tp = mod(p + halfsize, size) - halfsize;\n\treturn c;\n}\n\nvec2 pMod2(inout vec2 p, vec2 size) {\n\tvec2 c = floor((p + size*0.5)/size);\n\tp = mod(p + size*0.5,size) - size*0.5;\n\treturn c;\n}\n\n\n// Repeat only a few times: from indices <start> to <stop> (similar to above, but more flexible)\nfloat pModInterval1(inout float p, float size, float start, float stop) {\n\tfloat halfsize = size*0.5;\n\tfloat c = floor((p + halfsize)/size);\n\tp = mod(p+halfsize, size) - halfsize;\n\tif (c > stop) { //yes, this might not be the best thing numerically.\n\t\tp += size*(c - stop);\n\t\tc = stop;\n\t}\n\tif (c <start) {\n\t\tp += size*(c - start);\n\t\tc = start;\n\t}\n\treturn c;\n}\n\n\nfloat opS( float d1, float d2 )\n{\n    return max(-d1,d2);\n}\n\nfloat opU( float d1, float d2 )\n{\n    return min(d1,d2);\n}\n\nvec3 postEffects( in vec3 col, in vec2 uv, in float time )\n{    \n\t// vigneting\n    //col *= .9 + .2 * snoise( vec3( sin( iTime + uv.x ), cos( iTime + uv.y ), 0. ) );\n\tcol *= 0.4+0.7*pow( 16.0*uv.x*uv.y*(1.0-uv.x)*(1.0-uv.y), 0.5 );\n    //col += col * .05 * snoise( vec3( -uv.x * 400., uv.y * 400. , iTime * 2. ) );\n    \n    return col;\n}\n\n//------------------- CAMERA STUFF\n\nvec3 orbit(float phi, float theta, float radius)\n{\n\treturn vec3(\n\t\tradius * sin( phi ) * cos( theta ),\n\t\tradius * cos( phi ),\n\t\tradius * sin( phi ) * sin( theta )\n\t);\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n\treturn mat3( cu, cv, cw );\n}\n\n//------------------- PRIMITIVES\n\nvec2 rotate2D(vec2 p, float a) {\n return p * mat2(cos(a), -sin(a), sin(a),  cos(a));\n}\n\nfloat pyramid( vec3 p, float h) {\n\tvec3 q=abs(p);\n\treturn max(-p.y, (q.x*1.5+q.y *.75+q.z*1.5-h)/3.0 );\n}\n\nfloat sphere( vec3 p, float r ) {\n\treturn length( p ) - r;\n}\n\n// Box: correct distance to corners\nfloat fBox(vec3 p, vec3 b) {\n\tvec3 d = abs(p) - b;\n\treturn length(max(d, vec3(0))) + vmax(min(d, vec3(0)));\n}\n\nfloat dot2( in vec3 v ) { return dot(v,v); }\nfloat udTriangle( vec3 p, vec3 a, vec3 b, vec3 c )\n{\n    vec3 ba = b - a; vec3 pa = p - a;\n    vec3 cb = c - b; vec3 pb = p - b;\n    vec3 ac = a - c; vec3 pc = p - c;\n    vec3 nor = cross( ba, ac );\n\n    return sqrt(\n    (sign(dot(cross(ba,nor),pa)) +\n     sign(dot(cross(cb,nor),pb)) +\n     sign(dot(cross(ac,nor),pc))<2.0)\n     ?\n     min( min(\n     dot2(ba*clamp(dot(ba,pa)/dot2(ba),0.0,1.0)-pa),\n     dot2(cb*clamp(dot(cb,pb)/dot2(cb),0.0,1.0)-pb) ),\n     dot2(ac*clamp(dot(ac,pc)/dot2(ac),0.0,1.0)-pc) )\n     :\n     dot(nor,pa)*dot(nor,pa)/dot2(nor) );\n}\n\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    return max(q.z-h.y,max((q.x*0.866025+q.y*0.5),q.y)-h.x);\n}\n\nfloat pModSingle1(inout float p, float size) {\n\tfloat halfsize = size*0.5;\n\tfloat c = floor((p + halfsize)/size);\n\tif (p >= 0.)\n\t\tp = mod(p + halfsize, size) - halfsize;\n\treturn c;\n}\n\nfloat sdTorus82( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length2(p.xz)-t.x,p.y);\n  return length8(q)-t.y;\n}\n\nfloat sdTorus88( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length8(p.xz)-t.x,p.y);\n  return length8(q)-t.y;\n}\n\nfloat sdCappedCylinder( vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n//------------------- MAP\n\nfloat repeatObj( vec3 p ) {\n    \n    float res;\n    \n    vec3 op = p;\n    \n    vec2 pi = vec2( 0., 0. );\n\n    float idx1 = pModPolar( op.xy, 16., .0 );\n    op.x -= 2.5;\n    \n    op.xy = rotate2D( op.xy, PI * .45 + idx1 );\n    \n    \n    float idx2 = pModInterval1( op.y, .425, -2., 2. );\n    \n    float idx3 = pModInterval1( op.z, .17, -2., 2. );\n    //op.xy = rotate2D( op.xy, PI * .05 * sin( idx3 + p.x * p.y + iTime ) );\n    \n    float obj =  fBox( op, vec3( .75, .05, 0.025 ) );\n    return obj;\n}\n\nvec3 color;\n\nfloat map( in vec3 p ) {\n    \n\tfloat r;\n    \n    vec3 op = p;\n    op.y -= 1.8;\n    pMod1( op.z, 2. );\n    float obj = sdHexPrism( op, vec2( 1.5, .4 ) );\n    \n    r = obj;\n    \n    obj = sdHexPrism( op, vec2( 1.2, 1.5 ) );\n    obj = opS( obj, r );\n    \n    op = p;\n    op.y -= 1.8;\n    pMod1( op.z, 2. );\n    r = repeatObj( op );\n    obj = opU( r, obj );\n    \n    r = obj;\n    \n    \n    ////\n    \n    op = p;\n    op.x -= .25;\n    op.y -= 2.;\n    \n    pMod1( op.z, 4. );\n    op.xz = rotate2D( op.xz, PI * .5);\n    op.xy = rotate2D( op.xy, PI * .5);\n    obj = sdCappedCylinder( op, vec2( .25, .05 ) );\n    \n    //r = obj;\n    float r2 = obj;\n    \n    op = p;\n    op.x += .25;\n    op.y -= 2.;\n    pMod1( op.z, 4. );\n    op.xz = rotate2D( op.xz, PI * .5);\n    op.xy = rotate2D( op.xy, PI * .5);\n    obj = sdCappedCylinder( op, vec2( .25, .05 ) );\n    \n    r2 = opU( r2, obj );\n    \n    op = p;\n    op.y -= 1.78;\n    op.z -= 4.;\n    op.xy = rotate2D( op.xy, PI * .5);\n    pMod1( op.z, 4. );\n    op.yz = rotate2D( op.yz, PI * .5);\n    op.zx = rotate2D( op.zx, PI * .25);\n    obj = fBox( op, vec3( .27, .05, .27 ) );\n    \n    op = p;\n    op.y -= 2.32;\n    op.z -= 4.;\n    op.xy = rotate2D( op.xy, PI * .5);\n    pMod1( op.z, 4. );\n    op.yz = rotate2D( op.yz, PI * .5);\n    float objSub = fBox( op, vec3( .27, .5, .27 ) );\n    \n    obj = opS( objSub, obj );\n    r2 = opU( r2, obj );\n    \n    ////\n    \n    float dist = distance( -op, p );\n    float dist2 = distance( op, p );\n    \n    if( dist < dist2 ) { \n        color = rgb( 235., 56., 52. ); \n    } else {\n        color = vec3( 1., 1., 1. );\n    }\n    \n    r = opU( r, r2 );\n    \n    return r;\n}\n\n//------------------- RAYMARCHING\n\n#ifdef RENDER_DEPTH\nfloat castRay( in vec3 ro, in vec3 rd, inout float depth ) {\n#else\nfloat castRay( in vec3 ro, in vec3 rd ) {\n#endif\n    float t = 0.;\n    float res;\n    for( int i = 0; i < RAYMARCHING_STEP; i++ ) {\n        vec3 pos = ro + rd * t;\n        res = map( pos );\n        if( res < .01 || t > 100. ) break;\n        t += res * RAYMARCHING_JUMP;\n        #ifdef RENDER_DEPTH\n\t\tdepth += 1./float(RAYMARCHING_STEP);\n\t\t#endif\n    }\n    return t;\n}\n\nvec3 calcNormal(vec3 pos) {\n    float eps = 0.001;\n\tconst vec3 v1 = vec3( 1.0,-1.0,-1.0);\n\tconst vec3 v2 = vec3(-1.0,-1.0, 1.0);\n\tconst vec3 v3 = vec3(-1.0, 1.0,-1.0);\n\tconst vec3 v4 = vec3( 1.0, 1.0, 1.0);\n\treturn normalize( v1 * map( pos + v1*eps ) +\n    \t              v2 * map( pos + v2*eps ) +\n        \t          v3 * map( pos + v3*eps ) +\n            \t      v4 * map( pos + v4*eps ) );\n}\n\nfloat calcAO( in vec3 p, in vec3 n, float maxDist, float falloff ){\n\tfloat ao = 0.0;\n\tconst int nbIte = 6;\n\tfor( int i=0; i<nbIte; i++ )\n\t{\n\t\tfloat l = hash(float(i))*maxDist;\n\t\tvec3 rd = n*l;\n\t\tao += (l - map( p + rd )) / pow(1.+l, falloff);\n\t}\n\treturn clamp( 1.-ao/float(nbIte), 0., 1.);\n}\n\n// calculate local thickness\n// base on AO but : inverse the normale & inverse the color\nfloat thickness( in vec3 p, in vec3 n, float maxDist, float falloff )\n{\n\tfloat ao = 0.0;\n\tconst int nbIte = 6;\n\tfor( int i=0; i<nbIte; i++ )\n\t{\n\t\tfloat l = hash(float(i))*maxDist;\n\t\tvec3 rd = -n*l;\n\t\tao += (l + map( p + rd )) / pow(1.+l, falloff);\n\t}\n\treturn clamp( 1.-ao/float(nbIte), 0., 1.);\n}\n    \nvec3 sundir = normalize( vec3(-1.5,2.,-1.5) );\n\nvec3 addLight( in vec3 posLight, in vec3 colLight, in vec3 nor, in vec3 pos, in vec3 ref, in float radius, in float specRatio ) {\n    float thi = thickness(pos, nor, 6., 1.5);\n    \n    float intens = max( dot( nor, posLight ), 0. );\n    float dist = length( posLight - pos );\n    float att = clamp(1.0 - dist*dist/(radius*radius), 0.0, 1.0);\n    att *= att;\n    float specular = pow( clamp( dot( ref, posLight ), 0., 1.0 ), 16. );\n    vec3 col = colLight * intens * att;\n    col += specular * .5 * att * specRatio * thi;\n    return col;\n}  \n    \nvec3 render( in vec3 ro, in vec3 rd, in vec2 uv ) {     \n    // sky\n    vec3 colBg = mix(rgb(255,212,166), rgb(204,235,255), uv.y);\n    // sun\n    vec2 spos = uv - vec2(0.15, 0.4);\n    float sun = exp(-45.*dot(spos,spos));\n    vec3 scol = rgb(255,155,102) * sun * ( 0.8 + 0.1 * sin( iTime ) );\n    colBg += scol;\n    colBg = mix(0.8*rgb(235,56,52), colBg, smoothstep(-0.1,0.3,uv.y));\n    colBg = pow(colBg,vec3(1.3));\n    \n    #ifdef RENDER_DEPTH\n\tfloat depth = 0.;\n    float t = castRay( ro, rd, depth );\n    #else\n    float t = castRay( ro, rd );\n    #endif\n    \n    #ifdef RENDER_DEPTH\n    return vec3( depth / 5., depth, depth );\n    #endif\n    \n    vec3 pos = ro + t * rd;\n    vec3 nor = calcNormal( pos );\n    \n    #ifdef RENDER_NORMAL\n    return nor;\n    #endif\n    \n    float ao = calcAO( pos, nor, 10., 1.2 );\n    #ifdef RENDER_AO\n    return vec3( ao );\n    #endif\n    \n    //vec3 light = vec3( 1.5, 1., 1. );\n    \n    vec3 ref = reflect( rd, nor );\n    \n    vec3 col = colBg;\n    if( t < 9. ) {\n        //col = rgb( 100, 177, 66 );\n        //col = color * max( dot( ref, sundir ), 0. );\n        col = color;\n    }\n    \n    //col = colBg;\n    // top blue light\n    //col += addLight( vec3( .3, 5.,1. -iTime ), vec3( .498, .898, .952 ), nor, pos, ref, 6., 1. );\n    // right green dark\n    //col += addLight( vec3( 4.2, 1.5, 1. -iTime ), vec3( 0.06, .407, .27 ), nor, pos, ref, 6.25, 0. );\n    // bottom right blue light\n    //col += addLight( vec3( 5., -2., 1.85 -iTime ), vec3( 0.082, .443, .541 ), nor, pos, ref, 6., 0. );\n    // bottom left red\n    col += addLight( vec3( -4., 0., 1.85 -iTime ), vec3( 0.79, .168, .015 ), nor, pos, ref, 6., 0.25 );\n    \n    col += addLight( vec3( 0., 1.5, 1.5 -iTime ), vec3( 1., .0, 0. ), nor, pos, ref, 3.5, 0.5 );\n    \n    //col += .35 * addLight( vec3( 0.21, 2.85, .0 ), vec3( 1., 0.79, .16 ), nor, pos, ref, 4., .0 );\n   \n    //col += .1 * vec3( 1., 0.4, 0.2 ) * abs( pow( sun, 3. ) );\n    //col += 2.1 * vec3( 1., 0.79, .16 ) * abs( pow( sun, 3. ) );\n    col *= ao;\n    \n    col += addLight( vec3( .3, 6.,1. -iTime ), vec3( 1., 0., 0. ), nor, pos, ref, 6., 1. );\n    col = mix( col, colBg, 1. - exp( -.0435 * t * t ) );\n   // col = mix( col, colBg, 1. - exp( -.0495 * t * t ) );\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = -1. + 2. * uv;\n    p.x *= iResolution.x / iResolution.y;\n    \n    //vec2 m = iMouse.xy/iResolution.xy;\n    \n    // Camera\n\t//vec3 ro = orbit( PI/2. - 3.2,PI/2.,-1.8 );\n\t//vec3 ta  = vec3( EPSILON, +.4, .5 );\n    float radius = 4.6;\n    vec3 ro = orbit(PI/2.-.5,PI/2. + .0 + iTime * .0,radius);\n    ro.z -= iTime;\n    vec3 ta = vec3( EPSILON );\n    ta.z -= iTime;\n    ta.y = 1.5;\n   \n    // Camera to world transformation\n    mat3 ca = setCamera( ro, ta, EPSILON );\n    \n    // Ray direction\n    vec3 rd = ca * normalize( vec3( p.xy, 1. ) );\n    \n    // Raymarching\n    vec3 c = render( ro, rd, uv );\n    c.r = smoothstep(0.0, 1.0, c.r);\n\tc.g = smoothstep(0.0, 1.0, c.g - 0.1);\n\tc.b = smoothstep(-0.3, 1.3, c.b);\n    c = postEffects( c, uv, 0. );\n    fragColor = vec4( c, 1. );\n}","name":"","description":"","type":"image"}]}