{"ver":"0.1","info":{"id":"7dyfRR","date":"1657542006","viewed":98,"name":"Glitchy house of mirrors","username":"rodgzilla","description":"a glitchy effect I came up with by randomly modifying some formula.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","kifs","cylinder"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define time (.3 * iTime + 17.)\n#define ZPOS -00.\n\nvec3 glow = vec3(0, 0, 0);\n\nmat2 rot2d(float a){\n  float c = cos(a), s = sin(a);\n  \n  return mat2(c, s, -s, c);\n}\n\nfloat cyl(vec3 p, vec3 c){\n  return length(p.xy - c.xy) - c.z;\n}\n\n\nvec3 kifs(vec3 p, float tmin, float tmax, float m1, float m2, float s, float r, float it) {\n  float t = floor(time * .5) + smoothstep(tmin, tmax, fract(time * .5));\n\n  for (float i = 0.; i < it; i++) {\n    p.xy *= rot2d(t * m1 + i);\n    p.yz *= rot2d(t * m2 - i);\n    p = abs(p);\n    p -= s;\n    s *= r;\n  }\n  \n  return p;\n}\n\n\nvec3 repeat(vec3 p, vec3 r) {\n  vec3 q = mod(p, r) - .5 * r;\n  return q;\n}\n\n\nfloat at = 0.;\nfloat map(vec3 p) {\n  vec3 orig_p = p;\n  float d = 1000.;\n  float t1 = floor(time) + smoothstep(15. / 30., 20. / 30., fract(time));\n  float t2 = floor(time) + smoothstep(20. / 30., 25. / 30., fract(time));\n  float t3 = floor(time) + smoothstep(25. / 30., 30. / 30., fract(time));\n\n  p.xy = p.xy * rot2d(p.z * 0.005 * sin(0.25 * t1));\n  p.yz = p.yz * rot2d(p.x * 0.0015 * cos(0.3 * t2));\n  p.xy = p.xy * rot2d(p.z * 0.0019 * sin(0.15 * t3));\n  p = kifs(p, 0., .23, .12, .2, 0.2, 2., 4.);\n  p = kifs(p, 0.27, .5, .2, .1, 0.2, 2., 3.);\n  \n  float w1 = 0.5 * sin(time * 0.01) + 0.5;\n  float w2 = 0.5 * sin(time * 0.011) + 0.5;\n  float w3 = 0.5 * sin(time * 0.017) + 0.5;\n\n  float r = 50.;\n  p = repeat(p, vec3(r, r, r));\n\n  \n  d = min(d, cyl(p.xyz - vec3(5, 5, 0), vec3(1., 1., 2.)));\n  d = min(d, cyl(p.xxx - vec3(5, 5, 0), vec3(1., 1., 2. + (mod(p.z, 1.)))));\n  d = min(d, cyl(p.yzx - vec3(5, 5, 0), vec3(1., 1., 2.)));\n  d = min(d, cyl(p.zxy - vec3(5, 5, 0), vec3(1., 1., 2.)));\n\n  at += 1. / (d * 2.1);\n  \n  return d;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n  uv -= 0.5;\n  uv /= vec2(iResolution.y / iResolution.x, 1);\n\n  vec3 col = vec3(0);\n  vec3 ro = vec3(0, 0, ZPOS);\n  vec3 rd = normalize(vec3(uv.x, uv.y, 1.));\n  rd.xy *= rot2d(time * 0.1);\n  rd.yz *= rot2d(time * 0.2);\n  float d = 0.;\n  vec3 glow = vec3(0);\n\n  for (int i = 0; i < 100; i++) {\n    vec3 p = ro + d * rd;\n    float ds = map(p);\n    \n    if (ds < 0.01 || ds > 50.) {\n      break;\n    }\n    d += ds * 1.;\n    glow += .01 * at * vec3(\n      .75 * (1. + .25 * sin(p.y * .05)), \n      .33 * (1. + .3 * cos(p.x * 0.2)), \n      .4  * (1. + 0.4 * cos(p.z * 0.1))\n    );\n  }\n  \n  vec3 p = ro + d * rd;\n  vec2 e = vec2(0.01, 0);\n  vec3 n = normalize(map(p) - \n    vec3(\n      map(p - e.xyy),\n      map(p - e.yxy),\n      map(p - e.yyx)\n    )\n  );\n\n  vec3 lp = vec3(0., 0., ZPOS);\n  vec3 tl = lp - p;\n  vec3 tln = normalize(tl);\n  float dif = dot(tln, n);\n  \n  col = vec3(dif);\n  col = dif * glow;\n  fragColor = vec4(col, 1.);\n}","name":"Image","description":"","type":"image"}]}