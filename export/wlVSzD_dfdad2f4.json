{"ver":"0.1","info":{"id":"wlVSzD","date":"1582338764","viewed":296,"name":"sdf goose/dog fur","username":"xuanji","description":"fur","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["fur"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const int max_iterations = 45;\nconst float stop_threshold = 0.001;\nconst float grad_step = 0.001;\nconst float clip_far = 4.0;\nconst float PI = 3.14159265359;\n\nconst float furDepth = 0.25;\nconst int furLayers = 50;\nconst float rayStep = furDepth * 2.0 / float(furLayers);\nconst float furThreshold = 0.1;\n\n\nfloat mod289(float x){return x - floor(x * (1.0 / 289.0)) * 289.0;}\nvec4 mod289(vec4 x){return x - floor(x * (1.0 / 289.0)) * 289.0;}\nvec4 perm(vec4 x){return mod289(((x * 34.0) + 1.0) * x);}\n\nfloat noise3(vec3 p){\n    vec3 a = floor(p);\n    vec3 d = p - a;\n    d = d * d * (3.0 - 2.0 * d);\n\n    vec4 b = a.xxyy + vec4(0.0, 1.0, 0.0, 1.0);\n    vec4 k1 = perm(b.xyxy);\n    vec4 k2 = perm(k1.xyxy + b.zzww);\n\n    vec4 c = k2 + a.zzzz;\n    vec4 k3 = perm(c);\n    vec4 k4 = perm(c + 1.0);\n\n    vec4 o1 = fract(k3 * (1.0 / 41.0));\n    vec4 o2 = fract(k4 * (1.0 / 41.0));\n\n    vec4 o3 = o2 * d.z + o1 * (1.0 - d.z);\n    vec2 o4 = o3.yw * d.x + o3.xz * (1.0 - d.x);\n\n    return o4.y * d.y + o4.x * (1.0 - d.y);\n}\n\n\nfloat sdEllipsoid( vec3 p, vec3 r ) {\n  float k0 = length(p/r);\n  float k1 = length(p/(r*r));\n  return k0*(k0-1.0)/k1;\n}\n\nvec3 rotateY(vec3 p, float a) {\n    float sa = sin(a);\n    float ca = cos(a);\n    return vec3(ca*p.x + sa*p.z, p.y, -sa*p.x + ca*p.z);\n}\n\nfloat sdBox( vec3 p, vec3 b ) {\n  p = rotateY(p, 10.0);\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n\nfloat smin_poly( float a, float b, float k ) {\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat map(vec3 p) {\n    vec3 tp = p - vec3(0.0,0.0,0.0);\n    float s1 = sdEllipsoid(tp, vec3(1.0, 1.4, 1.0));\n    float s2 = sdEllipsoid(tp, vec3(5.0, 0.5, 0.5));\n\n    //return sdBox(p, vec3(1.0));\n    return smin_poly(s1,s2,1.0);\n}\n\n\nvec3 gradient(vec3 p) {\n    return normalize(vec3(\n        map(vec3(p.x + grad_step, p.y, p.z)) - map(vec3(p.x - grad_step, p.y, p.z)),\n        map(vec3(p.x, p.y + grad_step, p.z)) - map(vec3(p.x, p.y - grad_step, p.z)),\n        map(vec3(p.x, p.y, p.z  + grad_step)) - map(vec3(p.x, p.y, p.z - grad_step))\n    ));\n}\n\n// higher iterations => smaller steps per iteration. more accurate but very expensive\n// 1 iteration is enough for convex shapes\nvec3 descent(vec3 pos) {\n    vec3 dir = gradient(pos);\n    for (int i=0; i<1; i++) {\n        pos -= 1.0*map(pos)*dir;\n    }\n    return pos;\n}\n\nfloat furDensity(vec3 pos) {\n\t\n    // 10.0 => hair curl variation scale\n    // 80.0 => hair diameter size\n    vec3 samplePoint = descent(pos) + map(pos)*noise3(10.0*pos);\n    float density = smoothstep(furThreshold, 1.0, noise3(80.0*samplePoint));\n\n    vec3 p = pos;\n    float r = map(pos)+1.0;\n    float t = (r - (1. - furDepth)) / furDepth;\n\n    t = 1.0-t;\n\n    return density * t;;\n\n}\n\nvec3 furNormal(vec3 pos, float density) {\n    float eps = 0.0001;\n    vec3 n;\n    n.x = furDensity( vec3(pos.x + eps, pos.y, pos.z)) - density;\n    n.y = furDensity( vec3(pos.x, pos.y + eps, pos.z)) - density;\n    n.z = furDensity( vec3(pos.x, pos.y, pos.z + eps)) - density;\n    return normalize(n);\n}\n\n\nvec3 furShade(vec3 pos, vec3 lightColor, vec3 lightPos, vec3 eye, float density) {\n\n    vec3 v = normalize(lightPos - pos);\n    vec3 n = furNormal(pos, density);\n    vec3 ev = normalize(pos - eye);\n    vec3 h = reflect(ev, n);\n\n    float diff = max(0.0, dot(v, n)) + 0.4;\n    float spec = pow(max(0.0, dot(v, h)), 64.);\n\n    float r = map(pos)+1.0;\n    float t = (r - (1. - furDepth)) / furDepth;        \n    t = clamp(t, 0.4, 1.0);\n\n    diff = mix(diff, 1., 0.5);\n\n    return lightColor * t * (diff + 1.9 * spec);\n}\n\t\n\n\nfloat ray_marching( vec3 origin, vec3 dir, float end ) {\n\n    float depth = 0.0;\n    float dist = 0.1;\n\n    for ( int i = 0; i < max_iterations; i++ ) \t\t{\n        if ( dist < stop_threshold || depth > end ) break;\n        dist = map( origin + dir * depth );\n        depth += dist;\n    }\n\n    return depth;\n}\n\n\n\nvec3 ray_dir( float fov, vec2 size, vec2 pos ) {\n    vec2 xy = pos - size * 0.5;\n\n    float cot_half_fov = tan(radians( 90.0 - fov * 0.5 ));\t\n    float z = size.y * 0.5 * cot_half_fov;\n\n    return normalize( vec3( xy, z ) );\n}\n\nvec4 furSampleCol(vec3 pos, vec3 eye, vec3 rd, vec3 lightColor) {\n\n    vec4 c = vec4(0.0);\n\n    for(int i=0; i<furLayers; i++) {\n        float density = furDensity(pos);\n        vec4 sampleCol;\n        sampleCol.a = furDensity(pos);\n        if( c.a > 0.99 ) break;\n        if (sampleCol.a > 0.) {\n            sampleCol.rgb = sampleCol.a * furShade(\n                pos, \n                lightColor, \n                vec3(0.0), \n                eye, \n                density\n            );\n            c = c + sampleCol * (1.0 - c.a);\n        }\n        pos += rd * rayStep;\n    }\n    \n    return c;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\t\t\t\n    vec3 ro = vec3( .0, .0, -2.8 );\n    vec3 rd = ray_dir(60.0, iResolution.xy, fragCoord.xy );\n\n    // bgColor\n    vec3 bgColor = vec3(0.5,0.0,0.5);\n    vec3 color;\n\n    float data = ray_marching( ro, rd, clip_far );\n    if ( data < clip_far ) {\n\n        vec3 pos = ro + rd * data;\n\n        vec4 c = furSampleCol(pos, ro, rd, vec3(1.0));\n        \n\t\t// composite color with bgColor\n        float alpha = c.a;\n       \tcolor = alpha*c.xyz/alpha + (1.0-alpha)*bgColor;\n\n    } else {\n        color = bgColor;\n    }\n\n    fragColor = vec4(color, 1.0 );\n} ","name":"Image","description":"","type":"image"}]}