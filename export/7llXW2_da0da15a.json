{"ver":"0.1","info":{"id":"7llXW2","date":"1626897755","viewed":206,"name":"Tamby's LCD Simulator","username":"TambakoJaguar","description":"A \"small\" simulation of a LCD 7-segment display, which took more time as initially planed! ;)\nComments welcome! :)","likes":19,"published":1,"flags":32,"usePreview":0,"tags":["animation","digit","display","7segment","lcd","simulator"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tfragColor = texture(iChannel0,uv);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"/*\n\"Tambys LCD Simulator\" by Emmanuel Keller aka Tambako - July 2021\nLicense Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\nContact: tamby@tambako.ch\n\nToDo:\n   * Dot shadow\n   * Improve frame\n   * Transparence gradient\n   * Defines\n   * More realistic colors\n   * Background gradient\n   * Texture in BG2\n   * LCD remanence (use buffers)\n   * Rounded design\n   * Improve compile times (modulo x pos)\n   * Minus sign\n   - Improve rounded digits\n   * Comments\n   - Move light direction with mouse?\n*/\n\n// Switches, you can play with them!\n#define slant             // Slant (italic) digits\n#define shadows           // Shadow of the digits\n#define border            // Draws a border around the LCD display\n#define shading           // Add relief shading on the LCD display and border\n#define bgtexture         // Adds a rough texture on the border\n//#define remanence         // Creates a remanence effect on the LCD (the segments need a short time to switch on and off)\n#define rounded_digits    // Another design of the digits\n//#define test            // Tests the display, shows 8 everywhere!\n\n#define MOD3 vec3(.1143,.12369,.13787)\n\nconst float s_bluriness = 1./2500.;       // Bluriness of the border of the segments (a good value creates some anti-aliasing)\nconst float s_spacing = 0.0027;           // Spacing between the segments\nconst float s_width = 0.17;               // Width of a segment in proportion to the segment of a digit\nconst float d_width = 0.075;              // Width of a digit\nconst float d_height = 0.141;             // Height of a digit\nconst float d_spacing = 0.37;             // Additional spacing between the digits\nconst float d_slant = 0.15;               // Slant (italic) factor\nconst float n_border = 0.35;              // Space between the digits and the border\n\nconst float lcd_on_transp = 0.79;         // Transparency of the LCD when the segment is on\nconst float lcd_off_transp = 0.05;        // Transparency of the LCD when the segment is off\nconst float lcd_transp_gradient = 0.11;   // Transparency gradient factor over the axis x\nconst float lcd_remanence = 0.45;         // Remanence factor of the LCD\n\nconst float b_textint = 0.22;             // Height of the texture on the border\nconst float b_textscale = 180.;           // Scale of the texture on the border\n\nconst vec2 shadow_offset = vec2(0.011, -0.004); // Offset of the shadow\nconst float shadow_int = 0.33;            // Intensity of the shadow\nconst float shadow_bluriness = 1./120.;   // Blurriness of the shadow\n\nconst vec2 offset = vec2(0.09, 0.18);     // Offset of the display\n\nconst int nb_digits = 8;                  // Number of digits\nconst int n_precision = 2;                // Number of digits after the decimal point\n\nconst vec3 d_color = vec3(0.1, 0.13, 0.23);      // Color of the LCD digits\n//const vec3 bg_color = vec3(0.75, 0.8, 0.77);\nconst vec3 bg_color = vec3(0.71, 0.76, 0.73);    // Color of the back of the LCD\n//const vec3 bg_color2 = vec3(0.9, 0.85, 0.73);\nconst vec3 bg_color2 = vec3(0.43, 0.51, 0.63);   // Color of the border\n\nfloat dsw;\n\n#ifdef bgtexture\n// Hash function\nfloat hash(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * MOD3);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract(p3.x * p3.y * p3.z);\n}\n\n// Simple texture function\nfloat noise(vec2 p)\n{\n\tvec2 f = fract(p);\n    p = floor(p);\n    f = f*f*(3.0-2.0*f);\n    float res = mix(mix(hash(p),\n\t\t\t\t\t\thash(p + vec2(1.0, 0.0)), f.x),\n\t\t\t\t\tmix(hash(p + vec2(0.0, 1.0)),\n\t\t\t\t\t\thash(p + vec2(1.0, 1.0)), f.x), f.y);\n    return res;\n}\n\n// Noise with 4 \"harmonics\"\nfloat mnoise(vec2 p)\n{\n    return noise(p) + 0.7*noise(p*1.34) + 0.6*noise(p*2.46) + 0.4*noise(p*3.75);\n}\n\n// Relief noise\nfloat mnoiser(vec2 p)\n{\n    return mnoise(p) - mnoise(p + vec2(0.1, -0.1));\n}\n#endif\n\n#ifdef border\n// Gives back values needed to create the border of the LCD display\nvec3 number_box(vec2 pos, vec2 offset)\n{\n    vec2 pos2 = pos - offset;\n    vec3 box;\n    \n    #ifdef slant\n    float ew = d_slant*d_height;\n    #else\n    float ew = 0.;\n    #endif\n\n    box.x = max(-pos2.x - n_border*d_width, pos2.x - float(nb_digits)*d_width - float(nb_digits - 1)*d_width*d_spacing - n_border*d_width - ew);\n    box.y = max(-pos2.y - n_border*d_width, pos2.y - d_height - n_border*d_width);  \n    \n    float boxz1 = -pos2.x - n_border*d_width>-pos2.y - n_border*d_width?-1.:1.;\n    float boxz2 = -pos2.x - d_height - n_border*d_width + float(nb_digits)*d_width + float(nb_digits - 1)*d_width*d_spacing + ew>-pos2.y - n_border*d_width?-1.:1.;\n    box.z = pos2.y<0.?boxz1:boxz2; \n   \n    return box;\n}\n#endif\n\n// Basic function for a vertical segment\nfloat segment_v0(vec2 pos, vec2 offset, int stype, bool shadow)\n{\n    vec2 pos2 = pos - offset - (shadow?shadow_offset:vec2(0.));\n    float bluriness = shadow?shadow_bluriness:0.5/iResolution.y;\n    float bluriness2 = bluriness*1.4;\n\n    float seg = smoothstep(-bluriness, bluriness, pos2.x)*smoothstep(dsw + bluriness, dsw - bluriness, pos2.x);\n    #ifdef rounded_digits\n    if (stype==1)\n        seg*= max(2.*smoothstep(0.5*d_height + 0.2*dsw, 0.5*d_height - 1.9*dsw, pos2.y) - 1., smoothstep(dsw*2. + bluriness, dsw*2. - bluriness, length(pos2 + vec2(dsw, -0.5*d_height + 1.5*dsw))));\n    else\n    {\n        if (stype==4)\n            seg*= smoothstep(d_height*0.5 + bluriness2, d_height*0.5 - bluriness2, 2.*pos2.x + pos2.y - dsw*0.5 - d_height*0.05 + s_spacing);    \n        else\n            seg*= smoothstep(d_height*0.5 + bluriness2, d_height*0.5 - bluriness2, pos2.x + pos2.y - dsw*0.5 + s_spacing);    \n    }\n    \n    if (stype==2)\n        seg*= max(shadow?(2.*smoothstep(-dsw, 2.*dsw, pos2.y)-1.):(pos2.y>2.*dsw?1.:-1.), smoothstep(dsw*2. + bluriness, dsw*2. - bluriness, length(pos2 + vec2(dsw, -2.*dsw))));\n    else\n    {\n        if (stype==3)\n           seg*= smoothstep(-bluriness2, bluriness2, -2.*pos2.x + pos2.y + d_height*0.065 - s_spacing);\n        else\n           seg*= smoothstep(-bluriness2, bluriness2, -pos2.x + pos2.y - s_spacing);\n    }\n    \n    if (stype==3)\n        seg*= max(shadow?(2.*smoothstep(-dsw, 2.*dsw, pos2.y)-1.):(pos2.y>2.*dsw?1.:-1.), smoothstep(dsw*2. + bluriness, dsw*2. - bluriness, length(pos2 + vec2(-2.*dsw, -2.*dsw))));   else\n    {\n        if (stype==2)\n            seg*= smoothstep(-bluriness2, bluriness2, 2.*pos2.x + pos2.y - dsw - s_spacing);\n        else\n            seg*= smoothstep(-bluriness2, bluriness2, pos2.x + pos2.y - dsw - s_spacing);\n    }\n    \n    if (stype==4)\n        seg*= max(pos2.y<0.5*d_height - 1.5*dsw?1.:-1., smoothstep(dsw*2. + bluriness, dsw*2. - bluriness, length(pos2 + vec2(-2.*dsw, -0.5*d_height + 1.5*dsw))));\n    else\n    {\n        if (stype==1)\n            seg*= smoothstep(d_height*0.5 + bluriness2, d_height*0.5 - bluriness2, - 2.*pos2.x + pos2.y + dsw*0.5 + s_spacing);\n        else\n            seg*= smoothstep(d_height*0.5 + bluriness2, d_height*0.5 - bluriness2, - pos2.x + pos2.y + dsw*0.5 + s_spacing);\n    }\n    #else\n    seg*= smoothstep(-bluriness2, bluriness2, pos2.x + pos2.y - dsw - s_spacing);\n    seg*= smoothstep(-bluriness2, bluriness2, -pos2.x + pos2.y - s_spacing);\n    seg*= smoothstep(d_height*0.5 + bluriness2, d_height*0.5 - bluriness2, pos2.x + pos2.y - dsw*0.5 + s_spacing);\n    seg*= smoothstep(d_height*0.5 + bluriness2, d_height*0.5 - bluriness2, - pos2.x + pos2.y + dsw*0.5 + s_spacing);    \n    #endif\n    \n    return seg;\n}\n   \n// Vertical segment with shadow\nfloat segment_v(vec2 pos, vec2 offset, int stype)\n{\n    float seg = segment_v0(pos, offset, stype, false);\n\n    #ifdef shadows\n    seg = max(seg, shadow_int*segment_v0(pos, offset, stype, true));\n    #endif\n   \n    return seg;\n}\n\n// Basic function for a horizontal segment\nfloat segment_h0(vec2 pos, vec2 offset, int stype, bool shadow)\n{\n    vec2 pos2 = pos - offset - (shadow?shadow_offset:vec2(0.));\n    float bluriness = shadow?shadow_bluriness:0.5/iResolution.y;\n    float bluriness2 = bluriness*1.4; \n\n    float seg = smoothstep(-bluriness, bluriness, pos2.y)*smoothstep(dsw + bluriness, dsw - bluriness, pos2.y);\n    #ifdef rounded_digits\n    if(stype!=2)\n    {\n        if (stype==3)\n        {\n            seg*= smoothstep(-bluriness2, bluriness2, pos2.x + pos2.y - dsw - s_spacing);\n            seg*= smoothstep(d_width + bluriness2, d_width - bluriness2, pos2.x - pos2.y + dsw + s_spacing);\n        }\n        else\n        {\n            seg*= smoothstep(-bluriness2, bluriness2, 2.*pos2.x + pos2.y - dsw - d_height*0.07 - s_spacing);\n            seg*= smoothstep(d_width + bluriness2, d_width - bluriness2, 2.*pos2.x - pos2.y + 2.*dsw - d_width*0.95 + s_spacing);       \n        }\n    }\n    else\n    {\n        seg*= max(2.*smoothstep(0.5*dsw, 2.2*dsw, pos2.x)*smoothstep(d_width - 0.5*dsw, d_width - 2.2*dsw, pos2.x)-1.,\n              max(smoothstep(dsw*2. + bluriness, dsw*2. - bluriness, length(pos2 + vec2(-2.*dsw, -2.*dsw))),\n                  smoothstep(dsw*2. + bluriness, dsw*2. - bluriness, length(pos2 + vec2(-d_width + 2.*dsw, -2.*dsw)))));\n    }\n    if(stype!=1)\n    {\n        if (stype==3)\n        {\n            seg*= smoothstep(-bluriness2, bluriness2, pos2.x - pos2.y - s_spacing);\n            seg*= smoothstep(d_width + bluriness2, d_width - bluriness2, pos2.x + pos2.y + s_spacing);\n        }\n        else\n        {\n            seg*= smoothstep(-bluriness2, bluriness2, 2.*pos2.x - pos2.y - d_height*0.09 - s_spacing);\n            seg*= smoothstep(d_width + bluriness2, d_width - bluriness2, 2.*pos2.x + pos2.y +dsw - d_width*0.96 + s_spacing);        \n        }\n    }\n    else\n    {\n        seg*= max(pos2.x>2.*dsw && pos2.x<d_width - 2.*dsw?1.:-1.,\n              max(smoothstep(dsw*2. + bluriness, dsw*2. - bluriness, length(pos2 + vec2(-2.*dsw, dsw))),\n                  smoothstep(dsw*2. + bluriness, dsw*2. - bluriness, length(pos2 + vec2(-d_width + 2.*dsw, dsw)))));\n    }\n    #else\n    seg*= smoothstep(-bluriness2, bluriness2, pos2.x + pos2.y - dsw - s_spacing);\n    seg*= smoothstep(-bluriness2, bluriness2, pos2.x - pos2.y - s_spacing);\n    seg*= smoothstep(d_width + bluriness2, d_width - bluriness2, pos2.x - pos2.y + dsw + s_spacing);\n    seg*= smoothstep(d_width + bluriness2, d_width - bluriness2, pos2.x + pos2.y + s_spacing);\n    #endif\n    \n    return seg;\n}\n\n// Horizontal segment with shadow\nfloat segment_h(vec2 pos, vec2 offset, int stype)\n{\n    float seg = segment_h0(pos, offset, stype, false);\n\n    #ifdef shadows\n    seg = max(seg, shadow_int*segment_h0(pos, offset, stype, true));\n    #endif\n   \n    return seg;\n}\n\n// Draws a specific segment\nfloat segment(int s, vec2 pos)\n{\n    if (s==0) return segment_h(pos, vec2(0., d_height - dsw), 1);\n    if (s==1) return segment_v(pos, vec2(d_width*(1. -s_width), d_height*0.5 - dsw*0.5), 1);\n    if (s==2) return segment_v(pos, vec2(d_width*(1. -s_width), 0.), 2);\n    if (s==3) return segment_h(pos, vec2(0., 0.), 2);\n    if (s==4) return segment_v(pos, vec2(0., 0.), 3);\n    if (s==5) return segment_v(pos, vec2(0., d_height*0.5 - dsw*0.5), 4);\n    if (s==6) return segment_h(pos, vec2(0., d_height*0.5 - dsw*0.5), 3);\n}\n\n// Basic function for the point\nfloat spoint0(vec2 pos, vec2 offset, bool shadow)\n{\n    vec2 pos2 = pos - offset - (shadow?shadow_offset:vec2(0.));\n    float bluriness = shadow?shadow_bluriness*0.7:0.5/iResolution.y;   \n    float r = dsw*0.5;\n    \n    float spoint = smoothstep(r + bluriness, r - bluriness, length(pos2));\n    \n    return spoint;\n}\n\n// Point with shadow\nfloat spoint(vec2 pos, vec2 offset)\n{\n    float spoint = spoint0(pos, offset, false);\n\n    #ifdef shadows\n    spoint = max(spoint, shadow_int*0.65*spoint0(pos, offset, true));\n    #endif\n   \n    return spoint;\n}\n\n// Draws a specific digit\nfloat digit(int s, bool point, vec2 pos, vec2 offset, float xpos)\n{\n    vec2 pos2 = pos - offset;\n\n    // Gets every segment\n    float sa = segment(0, pos2);\n    float sb = segment(1, pos2);\n    float sc = segment(2, pos2);\n    float sd = segment(3, pos2);\n    float se = segment(4, pos2);\n    float sf = segment(5, pos2);\n    float sg = segment(6, pos2);\n    \n    float sall = max(max(max(max(max(max(sa, sb), sc), sd), se), sf), sg);\n    float pointv = spoint(pos2, vec2(d_width + dsw*0.4, dsw*0.4));\n    \n    #ifdef test\n    return max(sall, pointv)*lcd_on_transp;\n    #endif\n    \n    // Combines the segments together to form a digit\n    float digit;\n    if (s==-1) digit = sg;\n    if (s==0) digit = max(max(max(max(max(sa, sb), sc), sd), se), sf);\n    if (s==1) digit = max(sb, sc);\n    if (s==2) digit = max(max(max(max(sa, sb), sd), se), sg);\n    if (s==3) digit = max(max(max(max(sa, sb), sc), sd), sg);\n    if (s==4) digit = max(max(max(sb, sc), sf), sg);\n    if (s==5) digit = max(max(max(max(sa, sc), sd), sf), sg);\n    if (s==6) digit = max(max(max(max(max(sa, sc), sd), se), sf), sg);\n    if (s==7) digit = max(max(sa, sb), sc);\n    if (s==8) digit = sall;\n    if (s==9) digit = max(max(max(max(max(sa, sb), sc), sd), sf), sg);\n    \n    if (point)\n        digit = max(digit, pointv);\n        \n    // Calculates the transparency\n    float lcdxpos = xpos - 0.5*float(nb_digits)*d_width - 0.5*float(nb_digits - 1)*d_width*d_spacing;\n    float lcd_off_transp2 = lcd_off_transp + lcdxpos*lcd_transp_gradient;\n    float lcd_on_transp2 = lcd_on_transp + lcdxpos*lcd_transp_gradient*2.2;\n\n    return max(sall, pointv)*lcd_off_transp2 + digit*(lcd_on_transp2 - lcd_off_transp2);\n}\n\n// Gets the digit value of a certain position of a number\nint ncut(float val, int p, int nbp)\n{\n    bool neg = val<0.;\n    float val2 = abs(val)/pow(10., float(p));\n    // Shows minus sign or not\n    if (val2<1. && p>nbp)\n        return val2>(p-nbp>1?.1:.01) && neg?-1:-2;\n    return int(mod(abs(val)/pow(10., float(p)), 10.));\n}\n\n// Displays a number on the LCD display\nfloat number(float val, int nbp, vec2 pos, vec2 offset)\n{\n    float val2 = val*pow(10., float(nbp));\n    vec2 pos2 = pos - offset;\n    \n    #ifdef slant\n    pos2.x-= d_slant*pos2.y;\n    #endif\n    \n    float sp = d_width*(1. + d_spacing);\n    \n    /*float d3 = digit(ncut(val2, 5, nbp), nbp==5, pos2, vec2(0., 0.));\n    float d4 = digit(ncut(val2, 4, nbp), nbp==4, pos2, vec2(sp, 0.));\n    float d5 = digit(ncut(val2, 3, nbp), nbp==3, pos2, vec2(2.*sp, 0.));\n    float d6 = digit(ncut(val2, 2, nbp), nbp==2, pos2, vec2(3.*sp, 0.));\n    float d7 = digit(ncut(val2, 1, nbp), nbp==1, pos2, vec2(4.*sp, 0.));\n    float d8 = digit(ncut(val2, 0, nbp), false, pos2, vec2(5.*sp, 0.));\n    return max(max(max(max(max(d3, d4), d5), d6), d7), d8);*/\n    \n    // Using modulo is much better, compile times are much smaller! :)\n    vec2 pos2m = pos2;\n    pos2m.x = pos2.x<0.?-1.:mod(pos2.x, sp);\n    int nbn = int(pos2.x/sp) + 1;\n    float nb;\n    if (nbn>0 && nbn<=nb_digits)\n        nb = digit(ncut(val2, nb_digits-nbn, nbp), nbp==nb_digits-nbn && nbp!=nbn, pos2m, vec2(0.4/iResolution.y, 0.), pos2.x);\n    \n    return nb;\n}\n\n// Displays the border of the LCD display\nvec3 draw_border(vec2 pos)\n{\n    #ifdef border\n    vec3 nbox = number_box(pos, offset);\n    float nbox2 = smoothstep(s_bluriness, -s_bluriness, nbox.x)*smoothstep(s_bluriness, -s_bluriness, nbox.y);\n    \n    #ifdef shading\n    vec3 bg_colors = bg_color*(0.72 + 0.28*smoothstep(0.15, -0.15, nbox.x)*smoothstep(0.06, -0.06, nbox.y));\n    bg_colors*= (0.75 + 0.25*smoothstep(0.015, -0.015, nbox.x)*smoothstep(0.009, -0.009, nbox.y));\n    bg_colors*= (1. + 0.04*sin(17.*(pos.x - 0.5) + 1.8*pos.y));\n    bg_colors*= (1. - 0.02*sin(11.*pos.x - 3.5*pos.y));\n    \n    vec3 bg_color2s1 = bg_color2*(1. - 0.52*min(smoothstep(0.008, -0.008, nbox.x), smoothstep(0.008, -0.008, nbox.y)));\n    vec3 bg_color2s2 = bg_color2*(1. + 0.76*min(smoothstep(0.008, -0.008, nbox.x), smoothstep(0.008, -0.008, nbox.y)));\n    vec3 bg_color2s = (nbox.z<0.?bg_color2s1:bg_color2s2);\n    \n    #ifdef bgtexture\n    bg_color2s*= (1. + b_textint*mnoiser(b_textscale*pos));\n    #endif\n\n    #else\n    vec3 bg_color2s = bg_color2;\n    vec3 bg_colors = bg_color;\n    #endif\n    \n    vec3 bgcol = mix(bg_color2s, bg_colors, nbox2);\n    #else\n    vec3 bgcol = bg_color;\n    #endif\n    \n    return bgcol;\n}\n\n// Main image function, draws everything!\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xx;\n    \n    dsw = d_width*s_width;\n    \n    vec3 bgcol = draw_border(uv);\n    \n    //float val = iTime;\n    float val = pow(10., iTime*0.06) - 1.0;\n    float lcd_num = number(val, n_precision, uv, offset);\n    \n    vec3 col = mix(bgcol, d_color, lcd_num);\n    \n    // Handles the remanence\n    #ifdef remanence\n\tvec2 uv2 = fragCoord.xy / iResolution.xy;\n\tvec3 bufcolor = texture(iChannel0,uv2).rgb;\n    if (iFrame>0)\n        col = mix(bufcolor, col, lcd_remanence);\n    #endif\n\n    fragColor = vec4(col, 1.0);\n}","name":"Buffer A","description":"","type":"buffer"}]}