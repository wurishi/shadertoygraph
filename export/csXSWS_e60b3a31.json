{"ver":"0.1","info":{"id":"csXSWS","date":"1669503061","viewed":329,"name":"Bubble Clusters 2D","username":"stb","description":"Bubble clusters. Not fast!\n'R' to reset with new bubble arrangement.\nMouse to move the largest bubble.","likes":28,"published":1,"flags":48,"usePreview":1,"tags":["2d","bubbles","minimal"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n\n    Bubble Clusters 2D\n    2022 stb\n    Image input:\n        iChannel0 = BufA\n    \n    This shader makes bubble clusters. It doesn't run quickly, and it might even give you only 1 fps,\n    depending on your hardware.\n    \n    It extends from this shader: https://www.shadertoy.com/view/DdsXW4 (Double Bubble)\n    \n    Going to 3D from here will not be easy, as I will need to keep the framerate higher if I ever\n    wish to do some raymarching, not to mention rendering nice reflections and such.\n    \n    Change 9/22/2023: temporarily disabled everything in Buf A to see if the long compile time flag changes automatically.\n    \n*/\n\nvoid mainImage( out vec4 fo, in vec2 fc ) {\n    fo = vec4(1.-texture(iChannel0, fc/iResolution.xy).rrr, 1.);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"/*\n\n    Bubble Clusters 2D\n    2022 stb\n    Buf A inputs:\n        iChannel0 = BufA\n        iChannel1 = Keyboard\n    \n*/\n\n\n//~~~ changeable defines ~~~//\n\n#define NB 10     // number of bubbles\n#define BT .05    // tinest bubble size\n#define BL .25    // largest bubble size\n#define Th .0065  // line thickness (alt: 2.5/res.y)\n#define Sp 1.     // speed of bubbles interacting (lower values are less jumpy)\n\n//~~~ end changeable defines ~~~//\n\n\n// Self-contained line function. Not the best; not the worst (maybe).\nfloat line(in vec2 p, vec2 p0, vec2 p1) {\n    vec2 d = normalize(p1-p0);\n    float l = .5 * length(p1-p0);\n    p -= p0;\n    if(length(p0-p1)>0.) {\n        p = mat2(d.y, d.x, -d.x, d.y) * p;\n        p.y = max(0., abs(p.y-l)-l);\n    }\n    return length(p);\n}\n\n// find the intersection of 2 lines\nvec2 LineLine_Intersect(vec2 A, vec2 B, vec2 C, vec2 D) {\n    float MAB = (A.y-B.y) / (A.x-B.x);\n    float MCD = (C.y-D.y) / (C.x-D.x);\n    float IAB = B.y - MAB * B.x;\n    float ICD = D.y - MCD * D.x;\n    float IX = (ICD-IAB) / (MAB-MCD);\n    return vec2(IX, MAB * IX + IAB);\n}\n\n// find an intersection point between 2 circles (two are possible, only one is used)\n// 1st point, 1st radius, 2nd point, 2nd radius\nvec2 Get_CC_Intersection(vec2 p0, float r0, vec2 p1, float r1) {\n\tfloat d = length(p1-p0);\n\tfloat a = (r0*r0-r1*r1+d*d) / (2.*d);\n\tfloat h = sqrt(r0*r0-a*a);\n\tvec2 p2 = p0 + a * (p1-p0) / d;\n\treturn vec2(p2.x + h*(p0.y-p1.y) / d, p2.y - h*(p0.x-p1.x) / d);\n}\n\n// I=index=this pixel=can't go more than lowest screen width\nvec4 getPixel(int I) {\n    return texelFetch(iChannel0, ivec2(I, 0), 0);\n}\n\n// hash without sine: https://www.shadertoy.com/view/4djSRW\n//#define MOD3 vec3(.1031, .11369, .13787) // int range\n#define MOD3 vec3(443.8975, 397.2973, 491.1871) // uv range\nvec2 hash21(float p) {\n\tvec3 p3 = fract(vec3(p) * MOD3);\n\tp3 += dot(p3, p3.yzx + 19.19);\n\treturn fract(vec2((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y));\n}\n\nvoid mainImage( out vec4 fo, in vec2 fc ) {\n\tvec2 res = iResolution.xy;\n\tvec2 p = (fc-res/2.) / res.y;\n    \n    float f = 1., f2, f3 = 1.;\n    \n    // bubble array\n    vec3 B[NB];\n    \n    // initialize bubbles at the beginning or when pressing 'r'\n    if(iFrame==0 || texture(iChannel1, vec2(82.5/256., .2)).r > 0.) {\n\n        for(int i=0; i<NB; i++) {\n\n            // random positions and radii\n            vec2 H = hash21(float(i)+mod(10.*iDate.w, 100.));\n\n            // save bubble with random position and radius (based on i to ensure no equal sizes)\n            B[i] = vec3(vec2(1.2, .6)*(H-.5), mix(BT, BL, float(i) / float(NB)));\n\n        }\n    }\n\n    // do bubble stuff\n    else {\n\n        // retrieve data stored in buffer and place it into bubble array\n        for(int i=0; i<NB; i++)\n            B[i] = getPixel(i).rgb;\n\n        // mouseplay for last circle \n        if(iMouse.z>0.) B[NB-1].xy = (iMouse.xy-res/2.)/res.y;\n\n        // loop through each bubble\n        // slow\n        //for(int i=0; i<NB; i++) {\n        \n        // spalmer's fix for long compilation times\n        for(int i=min(0, iFrame); i<NB; i++) {\n\n            // image value for each bubble; will be drawn to screen\n            f2 = length(p-B[i].xy)-B[i].z;\n\n            // loop through other bubbles\n            for(int io=0; io<NB; io++) {\n\n                // prevent evaluating bubble against itself\n                if(i!=io) {\n                \n                    vec2 V = B[io].xy - B[i].xy;\n                    // move bubbles toward  each other\n                    if(length(V)<B[io].z+B[i].z)\n                        B[i].xy += Sp * .00001 * normalize(V) / B[i].z;\n                        \n                    // move bubbles away from each other\n                    //else\n                    if(length(V)*2.<B[io].z+B[i].z)\n                        B[i].xy -= Sp * .0001 * normalize(V) / B[i].z;\n                        \n                    // attempt to prevent bubbles getting trapped in other bubbles\n                    if(length(V)<(B[io].z))\n                        B[i].xy -= Sp * .002 * normalize(V);\n                    \n                    \n                    // inner wall calculations\n                    \n                    // positions and radii for this bubble/that bubble\n                    vec2 P0=B[i].xy, P1=B[io].xy;\n                    float R0=B[i].z, R1=B[io].z;\n                    \n                    // one circle-circle intersection \n                    vec2 IP = Get_CC_Intersection(P0, R0, P1, R1);\n\n                    // get angle vector between intersecting circles\n                    vec2 PIP0 = normalize(IP-P0);\n                    vec2 PIP1 = normalize(IP-P1);\n                    vec2 TrDir = normalize(PIP0+PIP1);\n                    \n                    // reverse TrDir if that bubble's radius > this bubble's radius\n                    if(R1>R0) TrDir = -TrDir;\n\n                    // find center of circle describing iinner wall (intersection from IP ro axis between circles)\n                    vec2 WC = LineLine_Intersect(P0, P1, IP, IP-vec2(TrDir.y, -TrDir.x));\n                    \n                    // find radius of curved inner wall\n                    float WR = length(WC-IP);\n                    \n                    // add a wall to f2 by taking a chunk out of it\n                    if(B[i].z<B[io].z)\n                        f2 = max(f2, (length(p-WC)-WR)+Th);\n                    else\n                        f2 = max(f2, -(length(p-WC)-WR)+Th);\n                }\n                \n            } // end loop through other bubbles\n\n            // add walls to f\n            f = min(f, f2);\n            \n            // combine current bubbles into outer hull\n            f3 = min(f3, length(p-B[i].xy)-B[i].z-4.*Th);\n\n        } // end loop through each bubble\n\n    }\n    \n    // add outer hull to f\n    f = min(f, -f3);\n\n    // antialising for all lines\n    float aa = 1.33/res.y;\n    f = smoothstep(-aa, aa, f);\n    \n    \n    // save bubble info as pixels\n    if(fc.y<1. && fc.x<float(NB)){\n        for(int i=0; i<NB; i++)\n            //if(i<1+int(fc.x))\n             if(i==int(fc.x)) // from spalmer\n                fo = vec4(B[i], 1.);\n\n    }\n    \n    // draw bubbles\n    else\n        fo = vec4(vec3(f), 1.);\n}","name":"Buffer A","description":"","type":"buffer"}]}