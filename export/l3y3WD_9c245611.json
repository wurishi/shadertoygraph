{"ver":"0.1","info":{"id":"l3y3WD","date":"1718429695","viewed":71,"name":"EM field of a bouncing charge","username":"Urbanowicz","description":"https://www.feynmanlectures.caltech.edu/I_28.html","likes":1,"published":1,"flags":32,"usePreview":0,"tags":["model"],"hasliked":0,"parentid":"4XKGRm","parentname":"Complex amplitudes in 3D"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 fromLinear(vec3 linearRgb) {\n    bvec3 cutoff = lessThan(linearRgb, vec3(0.0031308));\n    vec3 higher = vec3(1.055) * pow(linearRgb, vec3(1.0 / 2.4)) - vec3(0.055);\n    vec3 lower = linearRgb * vec3(12.92);\n\n    return mix(higher, lower, cutoff);\n}\n\nvec3 colorize(float u) {\n    return clamp(vec3(u, 0, -u), 0.0, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 scr = ivec2(gl_FragCoord.xy);\n    vec4 u = texelFetch(iChannel0, scr, 0);\n\n    float i = dot(u.xy, u.xy)*1e2;\n    if (iMouse.z > 0.0) {\n        i = ( (scr.x + scr.y) % 2 == 0 ? u.y : u.x )*1e1;\n    }\n\n    fragColor = vec4(fromLinear(colorize(i)), 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void rnd_init() {\n    rnd_seed = hash2(uvec3(gl_FragCoord.xy, iFrame));\n}\n\nstruct V1 {\n    float x;\n    float dx;\n    float d2x;\n};\n\nV1 dconst(float x) {\n    return V1(\n        x,\n        0.0,\n        0.0\n    );\n}\n\nV1 dvar(float x) {\n    return V1(\n        x,\n        1.0,\n        0.0\n    );\n}\n\nV1 dadd(V1 a, V1 b) {\n    return V1(\n        a.x + b.x,\n        a.dx + b.dx,\n        a.d2x + b.d2x\n    );\n}\n\nV1 dsub(V1 a, V1 b) {\n    return V1(\n        a.x - b.x,\n        a.dx - b.dx,\n        a.d2x - b.d2x\n    );\n}\n\nV1 dmul(V1 a, V1 b) {\n    return V1(\n        a.x * b.x,\n        a.dx * b.x + a.x * b.dx,\n        a.d2x * b.x + 2.0 * a.dx * b.dx + a.x * b.d2x\n    );\n}\n\nV1 dsin(V1 i) {\n    return V1(\n        sin(i.x),\n        cos(i.x) * i.dx,\n        -sin(i.x) * i.dx * i.dx + cos(i.x) * i.d2x // u'v + uv'\n    );\n}\n\nV1 dsqrt(V1 i) {\n    return V1(\n        sqrt(i.x),\n        0.5 * inversesqrt(i.x) * i.dx, // x^1/2 ' = 1/2*x^-1/2 * x'\n        -0.25 * inversesqrt(i.x) / i.x * i.dx + 0.5 * inversesqrt(i.x) * i.d2x // 1/2*x^-1/2 * y '= -0.25*x^-3/2*y + 0.5*x^-1/2*y'\n    );\n}\n\nV1 dinvsqrt(V1 i) {\n    return V1(\n        inversesqrt(i.x),\n        -0.5 * inversesqrt(i.x) / i.x * i.dx, // x^-1/2 ' = -1/2 * x^-1/2 / x * x'\n        0.75 * inversesqrt(i.x) / i.x / i.x * i.dx -0.5 * inversesqrt(i.x) / i.x * i.d2x // (-0.5*x^-3/2)' * x' + (-0.5*x^-3/2) * x''\n    );\n}\n\nstruct V2 {\n    V1 x;\n    V1 y;\n};\n\nconst float C = 4.0;\n\nV2 chargePos(V1 t) {\n    const float w = 2.0 * PI;\n\n    return V2(\n        dadd(dconst(0.5), dmul(dconst(0.05), dsin(dmul(dconst(w * (C / 2.0 + 0.)), t)))),\n        dadd(dconst(0.5), dmul(dconst(0.05), dsin(dmul(dconst(w * C / 2.0), t))))\n    );\n}\n\nV1 sqdist(V2 pos, vec2 xy) {\n    V1 ex = dsub(pos.x, dconst(xy.x));\n    V1 ey = dsub(pos.y, dconst(xy.y));\n    return dadd(dmul(ex, ex), dmul(ey, ey));\n}\n\nvec2 charge(vec2 xy, float t) {\n    float dt = 0.0;\n    for (int i = 0; i < 4; i++) {\n        V1 f = dsub(dsqrt(sqdist(chargePos(dsub(dconst(t), dvar(dt))), xy)), dmul(dconst(C), dvar(dt)));\n        dt -= f.x / f.dx;\n    }\n\n    V2 ret = chargePos(dvar(t - dt));\n    V1 d2 = sqdist(ret, xy);\n    ret.x.x -= xy.x;\n    ret.y.x -= xy.y;\n\n    float r = sqrt(d2.x);\n\n    V1 inv = dinvsqrt(d2);\n    V1 fx = dmul(ret.x, inv);\n    V1 fy = dmul(ret.y, inv);\n\n    V1 ax = dmul(fx, dmul(inv, inv));\n    V1 ay = dmul(fy, dmul(inv, inv));\n\n    return (\n        vec2(ax.x, ay.x)\n        + r / C * vec2(ax.dx, ay.dx)\n        + vec2(fx.d2x, fy.d2x) / (C*C)\n    );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    rnd_init();\n    vec4 prev = 0.*texelFetch(iChannel0, ivec2(gl_FragCoord.xy), 0);\n\n    vec2 xy = (gl_FragCoord.xy - iResolution.y*0.5) / iResolution.y*32.0;\n\n    vec2 cr = charge(xy, iTime);\n\n    if (!(all(isnan(cr)) || all(isinf(cr)))) {\n        prev.a += 1.0;\n        prev.xy += (cr - prev.xy) / prev.a;\n    }\n\n    fragColor = prev;\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"// http://www.burtleburtle.net/bob/c/lookup3.c\n#define rot(x,k) (((x)<<(k)) | ((x)>>(32-(k))))\n\n#define final(a,b,c) \\\n{ \\\n    c ^= b; c -= rot(b,14); \\\n    a ^= c; a -= rot(c,11); \\\n    b ^= a; b -= rot(a,25); \\\n    c ^= b; c -= rot(b,16); \\\n    a ^= c; a -= rot(c,4);  \\\n    b ^= a; b -= rot(a,14); \\\n    c ^= b; c -= rot(b,24); \\\n}\n\nuint hash2(uvec3 v) {\n    uvec3 i = uvec3(0xdeadbeefu + (2u<<2u) + v.z);\n\n    i.xy += v.xy;\n    final(i.x, i.y, i.z);\n    return i.z;\n}\nuint hash0(uint initval) {\n    uvec3 i = uvec3(0xdeadbeefu + (0u<<2u) + initval);\n\n    final(i.x, i.y, i.z);\n    return i.z;\n}\n// http://www.burtleburtle.net/bob/c/lookup3.c\n\n// Construct a float with half-open range [0:1] using low 23 bits.\n// All zeroes yields 0.0, all ones yields the next smallest representable value below 1.0.\nfloat floatConstruct( uint m ) {\n    const uint ieeeMantissa = 0x007FFFFFu; // binary32 mantissa bitmask\n    const uint ieeeOne      = 0x3F800000u; // 1.0 in IEEE binary32\n\n    m &= ieeeMantissa;                     // Keep only mantissa bits (fractional part)\n    m |= ieeeOne;                          // Add fractional part to 1.0\n\n    float  f = uintBitsToFloat( m );       // Range [1:2]\n    return f - 1.0;                        // Range [0:1]\n}\n\nuint rnd_seed;\n\nfloat rnd_uniform() {\n    rnd_seed = hash0(rnd_seed);\n    return floatConstruct(rnd_seed);\n}\n#define PI 3.1415926535897932384626433\nvec2 rnd_normal() {\n    float phi = 2.0 * PI * rnd_uniform();\n    return sqrt(-2.0 * log(rnd_uniform())) * vec2(cos(phi), sin(phi));\n}\n\nvec2 mult(vec2 a, vec2 b) {\n    return vec2(\n        a.x * b.x - a.y * b.y,\n        a.x * b.y + a.y * b.x\n    );\n}\n\nvec2 conj(vec2 n) {\n    return vec2(n.x, -n.y);\n}\n","name":"Common","description":"","type":"common"}]}