{"ver":"0.1","info":{"id":"lf2yDc","date":"1723124957","viewed":52,"name":"Antialiasing and ellipses 2","username":"avilapa","description":"Bilinear (top left), Trilinear (bottom left), Anistropic (right). Cylindrical tunnel version of https://www.shadertoy.com/view/XfjyRR","likes":1,"published":1,"flags":32,"usePreview":0,"tags":["aliasing","filtering","ellipse","anisotropic","eigenvalues"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Based on: https://www.shadertoy.com/view/Ms2SWW\n//\n// Flat plane + ellipse info: https://www.shadertoy.com/view/XfjyRR\n\n#define PI 3.14159265358979323846264338327950288\n#define INV_PI (1.0 / PI)\n\n#define QUICK_METHOD\n\n#define ANISOTROPY_X 16\n\n#if defined(QUICK_METHOD)\nvoid GetGradientEllipse(vec2 duvdx, vec2 duvdy, \n    out vec2 majorAxis, out vec2 minorAxis, out float majorAxisLength, out float minorAxisLength)\n{\n    majorAxis = duvdx;\n    minorAxis = duvdy;\n    majorAxisLength = length(majorAxis);\n    minorAxisLength = length(minorAxis);\n    \n    if (majorAxisLength < minorAxisLength)\n    {\n        vec2 tmp = majorAxis;\n        majorAxis = minorAxis;\n        minorAxis = tmp;\n        float tmpL = majorAxisLength;\n        majorAxisLength = minorAxisLength;\n        minorAxisLength = tmpL;\n    }\n}\n#else\nvoid GetGradientEllipse(vec2 duvdx, vec2 duvdy, \n    out vec2 majorAxis, out vec2 minorAxis, out float majorAxisLength, out float minorAxisLength)\n{\n    // Construct the Jacobian matrix that describes the inverse transformation of the UV coordinates \n\t// to screen-space.\n    mat2 J = mat2(duvdx, duvdy);\n    J = inverse(J);\n    J = transpose(J)*J;\n    float a = J[0][0];\n    float b = J[0][1];\n    float c = J[1][0];\n    float d = J[1][1];\n    \n    // Note: We compute the eigenvalues and eigenvectors of the matrix, which correspond to the major and \n\t// minor axis of the ellipse describing the projected pixel footprint in texture space. \n\t// For 2x2 matrices, we can use a neat trick to find the two roots of the quadratic formula corresponding\n\t// to its eigenvalues 'λ', by exploiting the fact that we can directly find out the mean 'm' and product\n    // 'p' of them. The trace of a matrix (sum of it's diagonals) is equal to the sum of its eigenvalues,\n    // therefore the half trace is their mean, while the determinant of the matrix (a * d - b * c) is equal\n    // to the product of its eigenvalues. Knowing these, the quadratic formula reduces to:\n    //\n\t//     λ = m ± √(m² - p)\n    //\n    // 3blue1brown 2021 - A quick trick for computing eigenvalues | Chapter 15, Essence of linear algebra\n\t// https://youtu.be/e50Bj7jn9IQ?si=ERvTvnY-Gxp04Pa3\n    float t = a + d;\n\t// Note: Reworked floating point precision fix discussed in https://www.shadertoy.com/view/4lXfzn.\n\tfloat m = t * 0.50000062500117187744141159058819;\n    float p = determinant(J);\n    float root = sqrt(m * m - p);\n    \n    // Eigenvalues\n    float L0 = m - root;\n    float L1 = m + root;\n    // Eigenvectors\n    // Note: We know the ellipse's axes are eigenvectors for our transformation. To find them, we use\n\t// a free choice of variable in one of our vector components to greatly simplify finding a matching \n\t// secondary component (generalized eigenvector).\n    vec2 A0 = vec2(L0 - d, c);\n    vec2 A1 = vec2(L1 - d, c);\n    \n  \t// Note: The eigenvalues are equivalent to the squared length of the ellipse's axes in screen space.\n    majorAxisLength = inversesqrt(L0);\n    minorAxisLength = inversesqrt(L1);\n    // Note: The unit eigenvectors scaled by the lengths give us the ellipse's axes.\n    majorAxis = normalize(A0) * majorAxisLength;\n    minorAxis = normalize(A1) * minorAxisLength;\n}\n#endif\n\nvec4 textureAniso(sampler2D tex, vec2 uv)\n{\n    // The projected footprint under an infinitesimal pixel represented as a circle is, in most cases, an \n    // ellipse (see https://www.shadertoy.com/view/ltXfRr for a neat demonstration of this). In order to\n    // find out how stretched or compressed the texture will be under a pixel, we analyze the ellipse's\n    // axes, and take ANISOTROPY_X many samples along the length of it's long axis to get an antialiased\n    // (filtered) result.\n    vec2 majorAxis, minorAxis;\n    float majorAxisLength, minorAxisLength;\n    GetGradientEllipse(dFdx(uv), dFdy(uv), majorAxis, minorAxis, majorAxisLength, minorAxisLength);\n    \n    float lod = log2(minorAxisLength * iResolution.y);\n    if ((majorAxisLength / minorAxisLength) > float(ANISOTROPY_X))\n    {\n        lod = log2(minorAxisLength / float(ANISOTROPY_X) * iResolution.y);\n    }\n    \n    // Sample across ellipse major axis\n    const float kStep = 1.0 / float(ANISOTROPY_X);\n    vec4 result = vec4(0);\n    for (int i = -ANISOTROPY_X / 2; i < ANISOTROPY_X / 2; ++i)\n    {\n        float step = (float(i) + 0.5) * kStep;\n        result += textureLod(tex, uv + majorAxis * step, lod);\n    }\n    \n    return result / float(ANISOTROPY_X);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Normalized screen coordinates\n    vec2 coord = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n    // Angle of each pixel to the center of the screen\n    float angle = atan(coord.y, coord.x);\n    // Cylinder tunnel\n    float r = length(coord);    \n    vec2 uv = vec2(0.5 / r, angle * INV_PI * 2.0) + 0.03 * iTime;\n\n    if (coord.x < 0.0)\n    {\n        if (coord.y > 0.0)\n        {\n            // Bilinear Filtering\n            fragColor = vec4(textureLod(iChannel0, uv, 0.).rgb, 1);\n        }\n        else\n        {\n            // Trilinear Filtering\n            fragColor = vec4(texture(iChannel0, uv).rgb, 1);\n        }\n    }\n    else\n    {\n        // Anisotropic Filtering\n        fragColor = vec4(textureAniso(iChannel0, uv).rgb, 1);\n    }\n    \n    fragColor = pow(fragColor, vec4(1.0 / 2.2));\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Create checkerboard texture\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.y;\n    ivec2 tiles = ivec2(uv * 8.0) % 2;\n    fragColor = vec4(vec3(tiles.x == tiles.y), 1.0);\n}","name":"Buffer A","description":"","type":"buffer"}]}