{"ver":"0.1","info":{"id":"7lcGWB","date":"1636712202","viewed":294,"name":"[zznewclear13] Cornell Box NEE","username":"zznewclear13","description":"Cornell box path tracing with:\n1 random sample per pixel,\nnext event estimation (1 random sample towards light),\nmax depth of 4,\nggx brdf,\ntemporal accumulation.","likes":5,"published":1,"flags":32,"usePreview":0,"tags":["pathtracing","ggx","nexteventestimation"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Post-processing\n\n// Narkowicz 2015, \"ACES Filmic Tone Mapping Curve\"\nvec3 Tonemap_ACES(const vec3 x) {\n    const float a = 2.51;\n    const float b = 0.03;\n    const float c = 2.43;\n    const float d = 0.59;\n    const float e = 0.14;\n    return (x * (a * x + b)) / (x * (c * x + d) + e);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  \n    vec2 uv = fragCoord / iResolution.xy;\n    vec3 color = texture(iChannel0, uv).rgb;\n\n    color = Tonemap_ACES(color);\n    color = pow(color, vec3(0.4545));\n\n    fragColor = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"//BRDF model comes from https://google.github.io/filament/Filament.html\n\n#define DegToRad 0.01745329252\n#define INFINITY 1e10\n#define EPSILON 0.0001\n\n#define PI 3.14159265359\n#define INV_PI 0.31830988618\n#define SQRT2_2 0.70710678118\n\n#define DEFAULT_REFLECTANCE 0.04\n\n/////////////////////////////////////////\n//             Structures              //\n/////////////////////////////////////////\n\nstruct Camera\n{\n    vec3 position;\n    vec3 target;\n    vec3 upVec;\n    float fovy;\n};\n\nstruct Ray\n{\n    vec3 origin;\n    vec3 direction;\n};\n\nstruct Triangle\n{\n    int materialID;\n    vec3 v0;\n    vec3 v1;\n    vec3 v2;\n};\n\nstruct Sphere\n{\n    int materialID;\n\n    vec3 center;\n    float radius;\n};\n\nstruct Quad\n{\n    int materialID;\n    \n    vec3 p;\n    vec3 w;\n    vec3 l;\n};\n\nstruct Intersection\n{\n    vec3 position;\n    vec3 normal;\n};\n\nstruct Material\n{\n    int materialType;\n    vec3 baseColor;\n    float roughness;\n    float metallic;\n};\n\n/////////////////////////////////////////\n//            Ray Tracing              //\n/////////////////////////////////////////\n\n//Random functions\nfloat seed;\nfloat GetRandom(){return fract(sin(seed++)*43758.5453123);}\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nRay InitRay(Camera camera, vec2 fragCoord, vec2 resolution)\n{\n    vec3 forward = normalize(camera.target - camera.position);\n    vec3 right = normalize(cross(camera.upVec, forward));\n    vec3 up = cross(forward, right);\n       \n    float randomA = GetRandom();\n    float randomB = GetRandom();\n    vec2 realFragCoord = fragCoord + vec2(randomA, randomB) - 0.5;\n    realFragCoord = realFragCoord * 2.0 - resolution.xy;\n    \n    vec2 uv = tan(camera.fovy * DegToRad * 0.5) * (realFragCoord / resolution.yy);\n    vec3 rayDir = normalize(right * uv.x + up * uv.y + forward);\n    \n    return Ray(camera.position, rayDir);\n}\n\nbool SolveQuadratic(float a, float b, float c, out float x0, out float x1)\n{\n    float discriminant = b * b - 4.0 * a * c;\n    if(discriminant < 0.0){ return false;}\n    \n    float rootDisc = sqrt(discriminant);\n    float q = (b > 0.0) ? -0.5 * (b + rootDisc) : -0.5 * (b - rootDisc);\n    float temp0 = q / a;\n    float temp1 = c / q;\n    if (temp1 > temp0)\n    {\n        x0 = temp0;\n        x1 = temp1;   \n    }\n    else\n    {\n        x0 = temp1;\n        x1 = temp0;\n    }\n    return true;  \n}\n\nbool RayTriangleIntersect(Ray ray, Triangle triangle, out float t, out Intersection intersection)\n{\n    vec3 edge1 = triangle.v1 - triangle.v0;\n    vec3 edge2 = triangle.v2 - triangle.v0;\n    vec3 h = cross(ray.direction, edge2);\n    float a = dot(edge1, h);\n    if(abs(a) < EPSILON) {return false;}\n    \n    float f = 1.0 / a;\n    vec3 s = ray.origin - triangle.v0;\n    float u = f * dot(s, h);\n    //I modified this a little bit to ensure there could be an intersection near edges\n    //original:\n    //if(u < 0.0 || u > 1.0) {return false;}\n    if(u < -EPSILON || u > 1.0 + EPSILON) {return false;}\n    \n    vec3 q = cross(s, edge1);\n    float v = f * dot(ray.direction, q);\n    //origin:\n    //if(v < 0.0 || (u + v) > 1.0) {return false;}\n    if(v < -EPSILON || (u + v) > 1.0 + EPSILON) {return false;}\n    \n    t = f * dot(edge2, q);\n    if(t < EPSILON) {return false;}\n    \n    intersection.position = ray.origin + t * ray.direction;\n    intersection.normal = normalize(cross(edge1, edge2));\n    return true;\n}\n\nbool RaySphereIntersect(Ray ray, Sphere sphere, out float t, out Intersection intersection)\n{\n    bool hasIntersection = false;\n    \n    float t0, t1;\n    vec3 l = ray.origin - sphere.center;\n    float a = dot(ray.direction, ray.direction);\n    float b = 2.0 * dot(ray.direction, l);\n    float c = dot(l, l) - sphere.radius * sphere.radius;\n    if (!SolveQuadratic(a, b, c, t0, t1)) {return false;}\n    \n    if(t1 > 0.0)\n    {\n        t = t1;\n        hasIntersection = true;\n    }\n    \n    if(t0 > 0.0)\n    {\n        t = t0;\n        hasIntersection = true;\n    }\n    \n    intersection.position = ray.origin + t * ray.direction;\n    intersection.normal = normalize(intersection.position - sphere.center);\n    return hasIntersection;\n}\n\nbool LightRay(Quad light, Intersection intersection, int j, int k, float ratio, out Ray lightRay, out vec3 rayTarget)\n{\n    float randomA = GetRandom();\n    float randomB = GetRandom();\n    rayTarget = light.p + light.w * (float(j) + randomA) * ratio + light.l * (float(k) + randomB) * ratio;\n    vec3 lightNormal = cross(light.w, light.l);\n    lightRay.direction = normalize(rayTarget - intersection.position);\n    lightRay.origin = intersection.position + lightRay.direction * 0.01;  \n    \n    bool hasLight = (dot(lightRay.direction, lightNormal) < 0.0);\n    return hasLight;\n}\n\nvec3 SampleHemiSphere()\n{\n    float theta = acos(GetRandom());\n    float phi = 2.0 * PI * GetRandom();\n    float sinTheta = sin(theta);\n\n    return vec3(cos(phi) * sinTheta, sin(phi) * sinTheta, cos(theta));\n}\n\nRay GetRandomRay(vec3 lastRayDir, vec3 position, vec3 normal, float roughness)\n{\n    Ray ray;\n    \n    vec3 s = SampleHemiSphere();\n    s.z = abs(s.z);\n    \n    vec3 w = normal;\n    vec3 u, v;\n    if(abs(dot(normal, vec3(0.0, 1.0, 0.0))) <= SQRT2_2)\n    {\n        u = normalize(cross(vec3(0.0, 1.0, 0.0), w));\n        v = cross(w, u);\n    }\n    else\n    {\n        v = normalize(cross(w, vec3(1.0, 0.0, 0.0)));\n        u = cross(v, w);\n    }\n    ray.direction = s.x * u + s.y * v + s.z * w;\n    ray.origin = position + ray.direction * 0.001;\n    \n    return ray;    \n}\n\n/////////////////////////////////////////\n//                BRDF                 //\n/////////////////////////////////////////\n\n// Bruce Walter et al. 2007. Microfacet Models for Refraction through Rough Surfaces. Proceedings of the Eurographics Symposium on Rendering.\nfloat D_GGX(float NoH, float roughness) {\n    float a = NoH * roughness;\n    float k = roughness / (1.0 - NoH * NoH + a * a);\n    return k * k * INV_PI;\n}\n\n// Eric Heitz. 2014. Understanding the Masking-Shadowing Function in Microfacet-Based BRDFs. Journal of Computer Graphics Techniques, 3 (2).\nfloat V_SmithGGXCorrelated(float NoV, float NoL, float roughness) {\n    float a2 = roughness * roughness;\n    float GGXV = NoL * sqrt(NoV * NoV * (1.0 - a2) + a2);\n    float GGXL = NoV * sqrt(NoL * NoL * (1.0 - a2) + a2);\n    return 0.5 / (GGXV + GGXL);\n}\n\n// Christophe Schlick. 1994. An Inexpensive BRDF Model for Physically-Based Rendering. Computer Graphics Forum, 13 (3), 233â€“246.\nfloat F_Schlick(float LoH, float f0, float f90) {\n    return f0 + (f90 - f0) * pow(1.0 - LoH, 5.0);\n}\n\nvec3 F_Schlick(float LoH, vec3 f0, vec3 f90) {\n    return f0 + (f90 - f0) * pow(1.0 - LoH, 5.0);\n}\n\nvec3 F_Schlick(float LoH, vec3 f0) {\n    return f0 + (vec3(1.0) - f0) * pow(1.0 - LoH, 5.0);\n}\n\nvec3 F0(vec3 baseColor, float metallic) {\n    return DEFAULT_REFLECTANCE * (1.0 - metallic) + baseColor * metallic;\n}\n\n// Specular BRDF\nvec3 Fr(float NoV, float NoL, float NoH, float LoH, float roughness, vec3 f0) {\n    float D = D_GGX(NoH, roughness);\n    vec3 F = F_Schlick(LoH, f0);\n    float V = V_SmithGGXCorrelated(NoV, NoL, roughness);\n    return D * F * V;\n}   \n\nfloat Fd_Lambert() {\n    return INV_PI;\n}\n\n// Diffuse BRDF\n// Brent Burley. 2012. Physically Based Shading at Disney. Physically Based Shading in Film and Game Production, ACM SIGGRAPH 2012 Courses.\nfloat Fd_Burley(float NoV, float NoL, float LoH, float roughness) {\n    float f90 = 0.5 + 2.0 * roughness * LoH * LoH;\n    float lightScatter = F_Schlick(NoL, 1.0, f90);\n    float viewScatter = F_Schlick(NoV, 1.0, f90);\n    return lightScatter * viewScatter * INV_PI;\n}\n\nvec3 EvaluateBRDF(vec3 wi, vec3 wo, Material material, vec3 normal)\n{\n    vec3 h = normalize(wi + wo);\n    float NdotV = abs(dot(normal, wo)) + 1e-5;\n    float NdotL = max(dot(normal, wi), 0.0);\n    float NdotH = max(dot(normal, h), 0.0);\n    float LdotH = max(dot(wi, h), 0.0);\n    \n    float roughness = material.roughness * material.roughness;\n    vec3 f0 = F0(material.baseColor, material.metallic);\n    vec3 diffuse = material.baseColor * (1.0 - material.metallic);\n\n    vec3 fr = Fr(NdotV, NdotL, NdotH, LdotH, roughness, f0);    \n    vec3 fd = Fd_Burley(NdotV, NdotL, LdotH, roughness) * diffuse;    \n    \n    return (fr + fd) * NdotL;\n}\n\nvec3 EvaluateBRDF(vec3 wi, vec3 wo, Quad light, float dist, Material material, vec3 normal)\n{\n    vec3 h = normalize(wi + wo);\n    float NdotV = abs(dot(normal, wo)) + 1e-5;\n    float NdotL = max(dot(normal, wi), 0.0);\n    float NdotH = max(dot(normal, h), 0.0);\n    float LdotH = max(dot(wi, h), 0.0);\n    \n    float roughness = material.roughness * material.roughness;\n    vec3 f0 = F0(material.baseColor, material.metallic);\n    vec3 diffuse = material.baseColor * (1.0 - material.metallic);\n    \n    vec3 fr = Fr(NdotV, NdotL, NdotH, LdotH, roughness, f0);\n    vec3 fd = Fd_Burley(NdotV, NdotL, LdotH, roughness) * diffuse;\n    \n    vec3 lightNormal = cross(light.w, light.l);\n    float area = length(lightNormal);\n    lightNormal = normalize(lightNormal);\n    float G = dot(-wi, lightNormal) * NdotL / (dist * dist);\n    G = max(G, 0.0);\n    \n    return (fr + fd) * G * area;\n}\n\n","name":"Common","description":"","type":"common"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//Cornell box path tracing with:\n//    1 random sample per pixel,\n//    next event estimation (1 random sample towards light),\n//    max depth of 4\n//    and ggx brdf.\n\n#define MAX_TRACE_DEPTH 4\n\n#define CUBE_COUNT 1\n#define WALL_COUNT 5\n#define SPHERE_COUNT 1\n#define LIGHT_COUNT 1\n\nTriangle triangles[CUBE_COUNT * 12 + WALL_COUNT * 2 + LIGHT_COUNT * 2];\nQuad lights[LIGHT_COUNT];\nSphere spheres[SPHERE_COUNT];\nMaterial materials[6];\n\nvoid QuadToTriangle(Quad quad, inout int offset)\n{\n    int materialID = quad.materialID;\n    vec3 p0 = quad.p;\n    vec3 p1 = quad.p + quad.w;\n    vec3 p2 = quad.p + quad.l;\n    vec3 p3 = p1 + quad.l;\n    \n    triangles[offset    ] = Triangle(materialID, p0, p1, p2);\n    triangles[offset + 1] = Triangle(materialID, p1, p3, p2);\n    \n    offset += 2;\n}\n\nvoid CubeToTriangle(int materialID, vec3 center, vec3 xAxis, vec3 size, inout int offset)\n{\n    vec3 u = normalize(xAxis);\n    vec3 w = normalize(cross(u, vec3(0.0, 1.0, 0.0)));\n    vec3 v = cross(w, u);\n    \n    mat3 uvw = mat3(u * size.x, v * size.y, w * size.z) * 0.5;\n    \n    vec3 p0 = center + uvw * vec3(-1, -1, -1);\n    vec3 p1 = center + uvw * vec3(1, -1, -1);\n    vec3 p2 = center + uvw * vec3(1, -1, 1);\n    vec3 p3 = center + uvw * vec3(-1, -1, 1);\n    \n    vec3 p4 = center + uvw * vec3(-1, 1, -1);\n    vec3 p5 = center + uvw * vec3(1, 1, -1);\n    vec3 p6 = center + uvw * vec3(1, 1, 1);\n    vec3 p7 = center + uvw * vec3(-1, 1, 1);\n    \n    triangles[offset    ] = Triangle(materialID, p0, p1, p2);\n    triangles[offset + 1] = Triangle(materialID, p0, p2, p3);\n    \n    triangles[offset + 2] = Triangle(materialID, p0, p5, p1);\n    triangles[offset + 3] = Triangle(materialID, p0, p4, p5);\n    \n    triangles[offset + 4] = Triangle(materialID, p0, p3, p7);\n    triangles[offset + 5] = Triangle(materialID, p0, p7, p4);\n    \n    triangles[offset + 6] = Triangle(materialID, p6, p2, p1);\n    triangles[offset + 7] = Triangle(materialID, p6, p1, p5);\n\n    triangles[offset + 8] = Triangle(materialID, p6, p5, p4);\n    triangles[offset + 9] = Triangle(materialID, p6, p4, p7);\n    \n    triangles[offset + 10] = Triangle(materialID, p6, p7, p3);\n    triangles[offset + 11] = Triangle(materialID, p6, p3, p2);\n    \n    offset += 12;\n}\n\n\nvoid MakeScene()\n{\n    //floor\n    triangles[0] = Triangle(1, vec3(-6.0, 0.0, -6.0), vec3(-6.0, 0.0, 6.0), vec3(6.0, 0.0, -6.0));\n    triangles[1] = Triangle(1, vec3(-6.0, 0.0, 6.0), vec3(6.0, 0.0, 6.0), vec3(6.0, 0.0, -6.0));\n    \n    //ceil\n    triangles[2] = Triangle(1, vec3(-6.0, 10.0, -6.0), vec3(6.0, 10.0, -6.0), vec3(-6.0, 10.0, 6.0));\n    triangles[3] = Triangle(1, vec3(-6.0, 10.0, 6.0), vec3(6.0, 10.0, -6.0), vec3(6.0, 10.0, 6.0));\n    \n    //left wall\n    triangles[4] = Triangle(2, vec3(-6.0, 0.0, -6.0), vec3(-6.0, 10.0, -6.0), vec3(-6.0, 0.0, 6.0));\n    triangles[5] = Triangle(2, vec3(-6.0, 10.0, -6.0), vec3(-6.0, 10.0, 6.0), vec3(-6.0, 0.0, 6.0));\n\n    //right wall\n    triangles[6] = Triangle(3, vec3(6.0, 0.0, -6.0), vec3(6.0, 0.0, 6.0), vec3(6.0, 10.0, -6.0));\n    triangles[7] = Triangle(3, vec3(6.0, 10.0, -6.0), vec3(6.0, 0.0, 6.0), vec3(6.0, 10.0, 6.0));\n    \n    //back wall\n    triangles[8] = Triangle(1, vec3(-6.0, 0.0, 6.0), vec3(-6.0, 10.0, 6.0), vec3(6.0, 0.0, 6.0));\n    triangles[9] = Triangle(1, vec3(-6.0, 10.0, 6.0), vec3(6.0, 10.0, 6.0), vec3(6.0, 0.0, 6.0));\n        \n    int offset = 10;\n    //cube 10-21\n    CubeToTriangle(4, vec3(-2.0, 3.0, 3.0), vec3(1.0, 0.0, 0.5), vec3(4.0, 8.0, 4.0), offset);\n    \n    //sphere\n    spheres[0] = Sphere(5, vec3(2.0, 2.0, 0.0), 2.0);\n    \n    //light 22-23\n    lights[0] = Quad(0, vec3(-2.0, 9.5, -2.0), vec3(4.0, 0.0, 0.0), vec3(0.0, 0.0, 4.0));\n    QuadToTriangle(lights[0], offset);\n    \n    //materials\n    materials[0] = Material(0, vec3(5.0, 5.0, 5.0), 0.0, 0.0);\n    materials[1] = Material(1, vec3(0.7, 0.7, 0.4), 0.9, 0.0);\n    materials[2] = Material(1, vec3(1.0, 0.0, 0.0), 0.9, 0.0);\n    materials[3] = Material(1, vec3(0.0, 1.0, 0.0), 0.9, 0.0);\n    materials[4] = Material(1, vec3(0.7, 0.7, 0.4), 0.2, 0.7);\n    materials[5] = Material(1, vec3(1.0, 0.64, 0.05), 0.6, 0.9);\n}\n\nbool TraceScene(Ray ray, out Intersection intersection, out int materialID)\n{\n    float d = INFINITY;\n    bool hasHit = false;\n    for(int i = 0; i < triangles.length(); i++)\n    {\n        float t;\n        Intersection tempIntersection;\n        bool isHit = RayTriangleIntersect(ray, triangles[i], t, tempIntersection);\n        if(isHit && t < d)\n        {\n            d = t;\n            hasHit = true;\n            \n            materialID = triangles[i].materialID;\n            intersection = tempIntersection;\n        }\n    }\n    \n    for(int i = 0; i < spheres.length(); i++)\n    {\n        float t;\n        Intersection tempIntersection;\n        bool isHit = RaySphereIntersect(ray, spheres[i], t, tempIntersection);\n        if(isHit && t < d)\n        {\n            d = t;\n            hasHit = true;\n            \n            materialID = spheres[i].materialID;\n            intersection = tempIntersection;\n        }\n    }\n\n    return hasHit;\n}\n\nbool TraceLight(Ray ray, int lightMaterialID)\n{\n    float d = INFINITY;\n    int materialID = -1;\n    for(int i = 0; i < triangles.length(); i++)\n    {\n        float t;\n        Intersection tempIntersection;\n        bool isHit = RayTriangleIntersect(ray, triangles[i], t, tempIntersection);\n        if(isHit && t < d)\n        {\n            d = t;\n            \n            materialID = triangles[i].materialID;\n        }\n    }\n    \n    for(int i = 0; i < spheres.length(); i++)\n    {\n        float t;\n        Intersection tempIntersection;\n        bool isHit = RaySphereIntersect(ray, spheres[i], t, tempIntersection);\n        if(isHit && t < d)\n        {\n            d = t;\n            \n            materialID = spheres[i].materialID;\n        }\n    }\n    return materialID == lightMaterialID;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 color = vec3(0.0);\n    \n    seed = hash12(fragCoord) + iTime;\n    float randomValue = GetRandom();\n\n    Camera camera = Camera(vec3(0.0, 4.0, -12.0), vec3(0.0, 4.0, 0.0), vec3(0.0, 1.0, 0.0), 45.0);\n    Ray ray = InitRay(camera, fragCoord, iResolution.xy);\n    MakeScene();\n    \n    Intersection intersection;\n    int materialID;\n    vec3 brdf = vec3(1.0);\n    int depth = 0;\n    while(true)\n    {\n        bool hasHit = TraceScene(ray, intersection, materialID);\n        depth ++;\n        if(hasHit)\n        {       \n            Material material = materials[materialID];\n\n            if(material.materialType == 0)\n            {\n                if(depth == 1){color = material.baseColor;}\n                break;\n            }\n            else if (depth > MAX_TRACE_DEPTH)\n            {\n                break;\n            }\n            else\n            {      \n                vec3 lastRayDir = ray.direction;\n                ray = GetRandomRay(lastRayDir, intersection.position, intersection.normal, material.roughness);              \n                vec3 indirectBRDF = EvaluateBRDF(ray.direction, -lastRayDir, material, intersection.normal);\n                \n                vec3 directBRDF = vec3(0.0);\n                for(int i = 0; i < lights.length(); i++)\n                {\n                    float randomA = GetRandom();\n                    float randomB = GetRandom();\n                    vec3 lightTarget = lights[i].p + lights[i].w * randomA + lights[i].l * randomB;\n                    \n                    vec3 lightOrigin = intersection.position + 0.001 * intersection.normal;\n                    vec3 lightDirection = normalize(lightTarget - lightOrigin);\n                    \n                    Ray lightRay = Ray(lightOrigin, lightDirection);\n                    float dist = length(lightTarget - lightRay.origin);\n                    int lightMaterialID = lights[i].materialID;\n                    bool isShaded = TraceLight(lightRay, lightMaterialID);\n                    \n                    if(isShaded)\n                    {\n                        directBRDF += EvaluateBRDF(lightRay.direction, -lastRayDir, lights[i], dist, material, intersection.normal) * materials[lightMaterialID].baseColor;\n                    }\n                }\n                \n                color += brdf * directBRDF;\n                brdf *= 2.0 * PI * indirectBRDF;    \n            }              \n        }\n        else\n        {\n            break;\n        }      \n    }\n  \n    fragColor = vec4(color, 1.0);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"//Accumulate history colors\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 color = vec4(0.0, 0.0, 0.0, 1.0);\n    \n    if(iFrame == 0)\n    {\n        fragColor = color; return;\n    }\n    \n    vec2 uv = fragCoord / iResolution.xy;\n    vec3 bufferA = texture(iChannel0, uv).rgb;\n    vec4 bufferB = texture(iChannel1, uv);\n    \n    if(iMouse.z > 0.0)\n    {\n        fragColor = vec4(bufferA, 1.0);\n    }\n    else\n    {\n        bufferB.a += 1.0;\n        color.rgb = mix(bufferB.rgb, bufferA, 1.0 / bufferB.a);\n        fragColor = vec4(color.rgb, bufferB.a);\n    }\n\n}","name":"Buffer B","description":"","type":"buffer"}]}