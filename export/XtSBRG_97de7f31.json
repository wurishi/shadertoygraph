{"ver":"0.1","info":{"id":"XtSBRG","date":"1516153420","viewed":139,"name":"Bezier_Test_1/16","username":"PGrad","description":"2D graph visualization and cubic bezier curves","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["grid","bezier","graphing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void drawAxis(inout vec3 color, float pos, float width, float x) {\n\tcolor *= smoothstep(0., width, abs(x - pos));\n}\n\nvoid drawLine(inout vec3 color, vec3 line_color, float width, vec2 slope, float shift, vec2 coord) {\n\tcolor = mix(line_color, color, \n                     smoothstep(0., width, abs(slope.x * coord.x + slope.y * coord.y + shift) / \n                                       sqrt(pow(slope.x, 2.) + pow(slope.y, 2.)))\n                );\n}\n\nfloat dist(vec2 x, vec2 y) {\n\treturn sqrt(pow(x.x - y.x, 2.) + pow(x.y - y.y, 2.));\n}\n\n//Cubic bezier curve\nvoid cubic_bezier(inout vec3 color, vec3 spl_color, float width, \n                  vec2 b0, vec2 b1, vec2 b2, vec2 b3, vec2 coord) {\n\tfloat t = -1., d = 0.;\n    vec2 pt;\n    float tmax = 2., tincr = .01;\n    for(; t < tmax; t += tincr) {\n    \tpt = b0 * pow(1. - t, 3.) + b1 * 3. * t * pow(1. - t, 2.) + \n             b2 * 3. * pow(t, 2.) * (1. - t) + b3 * pow(t, 3.);\n        d = dist(pt, coord);\n        if(d < width) {\n        \tcolor = spl_color;\n            break;\n        }\n    }\n}\n\nfloat lambert(vec3 n, vec3 l) {\n\treturn clamp(dot(n, l), 0., 1.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 chunk = iResolution.xy / vec2(13., 7.); \n\tvec2 shift = vec2(chunk.x * .5, chunk.y * .5);\n    vec2 uv = (fragCoord.xy - shift) / iResolution.xy;\n    vec2 subdiv = (fragCoord.xy + shift) / chunk;\n    vec3 lightPos = vec3(0., 2., 0.);\n    vec3 light = normalize(lightPos - vec3(uv.x, 0., uv.y)); \n    vec3 n = vec3(0., 1., 0.);\n    //Use XOR to make a grid. For visualization, think of\n    //a binary matrix with alternating 1 and 0 on each row and column\n    //for x and y\n    //x0y0 x1y0 x0y0\n    //x0y1 x1y1 x0y1\n    //x0y0 x1y0 x0y0\n    int swtch = (int(subdiv.x) % 2) ^ (int(subdiv.y) % 2);\n    vec3 color = vec3(.5 - .1 * float(swtch));\n    float width = 2.;\n    drawAxis(color, shift.x, width, fragCoord.x);\n    drawAxis(color, shift.y, width, fragCoord.y);\n    drawLine(color, vec3(1., 0., 0.), .01, vec2(-1., 1.), 0., uv);\n    cubic_bezier(color, vec3(0., 0., 1.), .01,\n                 vec2(.2, .3), vec2(.4, .5), vec2(.6, .5), vec2(.8, .7),\n                 uv);\n    cubic_bezier(color, vec3(0., 1., 0.), .01,\n                 vec2(.2, .4), vec2(.4, .6), vec2(.6, .4), vec2(.8, .6),\n                 uv);\n    color *= lambert(n, light);\n    fragColor = vec4(color, 1.);\n}","name":"Image","description":"","type":"image"}]}