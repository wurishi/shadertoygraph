{"ver":"0.1","info":{"id":"ftVXzz","date":"1641080769","viewed":93,"name":"Pascal's Triangle Colorized","username":"tomviolin","description":"Computes Pascal's Triangle w/ values stored in columns 1 digit per pixel. Inspired by the figure at https://tinyurl.com/5asyzc2w but generalized to any base and colorized. The last digits of each row form the waterfall. Try other bases, set on Common tab.","likes":6,"published":1,"flags":32,"usePreview":0,"tags":["triangles","pascal","arbitraryprecision","binomials"],"hasliked":0,"parentid":"NtGSRz","parentname":"Pascal's Triangle II"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //if ((iFrame % 1000) < 10) {\n    //    fragColor = vec4(1);\n    //    return;\n    //}\n    float d = trunc(iResolution.y/2.0)+0.5;\n    vec2 fcm = (fragCoord-vec2(0,d))/MAG+vec2(0,d);\n\n    vec2 pos = fcm.xy / iResolution.xy;\n    float v=texture(iChannel0, pos).r/float(BASE);\n    fragColor.rgb = v==0.0?BACKGROUND:hsv2rgb(vec3(\n            v*HUE_FACTOR+HUE_OFFSET,\n            1.0,\n            (v==0.0)?0.0:1.0)\n        );\n    fragColor.a=1.;\n    //fragColor.r = mod(fragColor.r,10.0);\n    //fragColor = vec4(1,0,0,1);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 pos = (fragCoord.xy) / iResolution.xy;\n    float pxm1 = (fragCoord.x-1.0)/iResolution.x;\n    float pym1 = (fragCoord.y-1.0)/iResolution.y;\n    float a=0.0,b=0.0,c=0.0,d=0.0;\n    fragColor=texture(iChannel0,pos);\n    if (iFrame < 1) {\n        if (fragCoord.y == 0.5 && fragCoord.x==0.5){\n            fragColor = vec4(1,0,0,1);\n        } else {\n            fragColor = vec4(0,0,0,1);\n        }\n    } else if (iFrame % INTERVAL == 0) {\n        a = (fragCoord.x==0.5)?0.0:texture(iChannel0,vec2(pxm1,pos.y)).r;\n        b = texture(iChannel0,pos).r;\n        if (fragCoord.y>0.5) {\n            c = fragCoord.x<=0.5?0.0:texture(iChannel0,vec2(pxm1,pym1)).r;\n            d = texture(iChannel0,vec2(pos.x,pym1)).r;\n        }\n        fragColor.r = trunc(mod(a+b+(c+d)/float(BASE),float(\n        BASE)));\n    }\n   \n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"precision highp float;\n\n// Pascal's Triangle with arbitrary precision\n// and numerical base.\n// Copyright (c) 2022 Tom Hansen <tomh@uwm.edu>\n\n\n// numerical base: \n// 10=decimal, 2=binary, 8=octal,etc.\n\n#define BASE 5\n\n// other bases which produce interesting results;\n// prime numbers produce Sierpinski's triangles\n// with BASE triangles per triangle side.\n//\n// #define BASE 5\n// #define BASE 7\n\n// Base 2 (binary) produces\n// perfect Sierpinski triangles.\n//\n// #define BASE 2\n//\n// example of a non-integer \"base\":\n// square root of 2 produces a very irregular\n// shape to the digits but still produces\n// perfect Sierpinski's triangles\n//\n// #define BASE (sqrt(2.0)+.0000000597)\n//\n// In practice a very small offset has to be\n// added to sqrt(2) to produce the digits.\n\n\n// magnify the rendering \n#define MAG 4.0\n\n// Alternate MAG setting\n// this setting causes the \"camera\" to zoom in\n// and out.\n// #define MAG (sin(float(iFrame)/100.)*6.+8.)\n\n\n// VIZR setting of 0 chooses the least significant\n// digits to be sampled and waterfalled.\n// VIZR of 1 samples the second last digit,\n// and so on.\n//\n#define VIZR 0\n\n// these settings control the mapping from\n// digits to rendered pixel colors\n#define HUE_OFFSET 0.1 // (float(iFrame) / 10000.)\n#define HUE_FACTOR 2.0\n#define BACKGROUND (vec3(0))\n\n// controls speed. Normally\n// the calculations are way too fast to be seen and appreciated.\n// INTERVAL defines the frame interval between calculation updates.\n// INTERVAL of 6 gives 10 updates per second, assuming a 60 fps display.\n\n#define INTERVAL 6\n\nvec3 hsv2rgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float d = trunc(iResolution.y/2.0)+0.5;\n    if (fragCoord.y>d){\n        fragColor = texture(iChannel0, (fragCoord-vec2(0.,d+1.))/iResolution.xy);\n    } else if (fragCoord.y == d) {\n        fragColor = texture(iChannel0, vec2(fragCoord.x,float(VIZR)+0.5)/iResolution.xy);\n    }\n    if (fragCoord.y <= d) {\n        fragColor = texture(iChannel1,(fragCoord+vec2(0,iFrame % INTERVAL == 0?1:0))/iResolution.xy);\n    }\n}","name":"Buffer B","description":"","type":"buffer"}]}