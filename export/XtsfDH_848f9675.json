{"ver":"0.1","info":{"id":"XtsfDH","date":"1511805475","viewed":199,"name":"Quartic roots","username":"dahart","description":"Just for fun & to get a feel for how bad it is, this is an attempt to use the analytic quartic formula for ray tracing quadratic curves. And... it's pretty bad. :) All the fuzzy dots are false hits due to numeric instability.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["bezier","quadratic","quartic","roots"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nconst float tau = 6.28318;\nconst float inf = 99999.0;\n\nconst bool curves = true;\nconst bool spheres = true;\n\nconst int curveLen = 15;\nvec3 pts[curveLen];\n\nfloat solveQuadratic(float a, float b, float c) \n{ \n    float x0, x1;\n    float discr = b * b - 4.0 * a * c; \n    if (discr < 0.0) return inf; \n    else if (discr == 0.0) x0 = x1 = - 0.5 * b / a; \n    else { \n        float q = (b > 0.0) ? \n            -0.5 * (b + sqrt(discr)) : \n            -0.5 * (b - sqrt(discr)); \n        x0 = q / a; \n        x1 = c / q; \n    } \n    return (x0 >= 0.0 && x0 < x1) ? x0 : ((x1 >= 0.0) ? x1 : inf);\n}\n\nfloat sphereHit(vec3 sc, float sr, vec3 ro, vec3 rd) {\n    \n    float a = dot(rd, rd);\n    vec3 L = ro - sc;\n    float b = 2.0 * dot(rd, L);\n    //float c = dot(ro, ro) - 2.0 * dot(sc, ro) + dot(sc, sc) - sr * sr;\n    float c = dot(L, L) - sr * sr;\n    //return solveQuadratic(a, b, c);\n    float discrim = b*b - 4.0*a*c;\n\n    if (discrim < 0.0) return inf;\n    //return min(-b-sqrt(discrim)\n    return (-b - sqrt(discrim)) / (2.0 * a);\n}\n\nvec3 sphereNormal(vec3 sc, float sr, vec3 p) {\n    return normalize(p - sc);\n}\n\n\n// https://www.gamedev.net/forums/topic/451048-best-way-of-solving-a-polynomial-of-the-fourth-degree/\n//----------------------------------------------------------------------------\n// bool solveQuartic(double &a, double &b, double &c, double &d, double &e, double &root)\n// {\n//     // When a or (a and b) are magnitudes of order smaller than C,D,E\n//     // just ignore them entirely. \n//     if(a == 0.0 || abs(a/b) < 1.0e-6 || abs(a/c) < 1.0e-6)\n//         return solveCubic(b, c, d, e, root);\n\n//     // Uses Ferrari's Method\n//     double aa = a*a, aaa=aa*a, bb=b*b, bbb=bb*b;\n//     double alpha = -3.0*bb/(8.0*aa)   + c/a, alpha2 = alpha * alpha;\n//     double beta  =    bbb/(8.0*aaa) + b*c/(-2.0*aa) + d/a;\n//     double gamma = -3.0*bbb*b/(256.0*aaa*a) + c*bb/(16.0*aaa) + b*d/(-4.0*aa) + e/a;\n\n//     if(beta == 0.0)\n//     {\n//         root = b/(-4.0*a) + sqrt(0.5 * (-alpha + sqrt(alpha2 + 4.0*gamma)));\n//         return true;\n//     }\n//     else\n//     {\n//         std::complex<double> P = -alpha2/12.0 - gamma;\n//         std::complex<double> Q = -alpha2*alpha/108.0 + alpha*gamma/3.0 - beta*beta/8.0;\n//         std::complex<double> R = Q*0.5 + sqrt(Q*Q*0.25 + P*P*P/27.0);\n//         std::complex<double> U = pow(R, 1.0/3.0);\n//         std::complex<double> y = -5.0*alpha/6.0 - U;\n//         if(U != 0.0) y += P/(3.0*U);\n//         std::complex<double> W = sqrt(alpha + y + y);\n\n//         std::complex<double> aRoot;\n//         bool foundRealRoot = false;\n\n//         double firstPart = b/(-4.0*a);\n//         std::complex<double> secondPart = -3.0*alpha - 2.0*y;\n//         std::complex<double> thirdPart = 2.0*beta/W;\n\n//         aRoot = firstPart + 0.5 * (-W - sqrt(secondPart + thirdPart));\n//         if(abs(aRoot.imag()) < 1.0e-10 && aRoot.real() >= 0.0) \n//         {\n//             root = aRoot.real();\n//             foundRealRoot = true;\n//         }\n\n//         aRoot = firstPart + 0.5 * (-W + sqrt(secondPart + thirdPart));\n//         if(abs(aRoot.imag()) < 1.0e-10 && aRoot.real() >= 0.0 &&\n//              (!foundRealRoot || aRoot.real() < root))\n//         {\n//             root = aRoot.real();\n//             foundRealRoot = true;\n//         }\n\n//         aRoot = firstPart + 0.5 * (W - sqrt(secondPart - thirdPart));\n//         if(abs(aRoot.imag()) < 1.0e-10 && aRoot.real() >= 0.0 &&\n//              (!foundRealRoot || aRoot.real() < root))\n//         {\n//             root = aRoot.real();\n//             foundRealRoot = true;\n//         }\n\n//         aRoot = firstPart + 0.5 * (W + sqrt(secondPart - thirdPart));\n//         if(abs(aRoot.imag()) < 1.0e-10 && aRoot.real() >= 0.0 &&\n//              (!foundRealRoot || aRoot.real() < root))\n//         {\n//             root = aRoot.real();\n//             foundRealRoot = true;\n//         }\n\n//         return foundRealRoot;\n//     }\n// }\n\n\n\nfloat qbHit(vec3 A3, vec3 B3, vec3 C3, float r, vec3 ro, vec3 rd, mat3x3 cam) {\n    float drd = dot(rd, cam[2]);\n\n    vec3 Aro = A3 - ro;\n    float dA3 = dot(Aro, cam[2]);\n    float nrdA = dA3 / drd;    \n    vec3 At = A3 - rd * nrdA;\n    vec2 A = vec2(dot(At, cam[0]), dot(At, cam[1]));\n    \n    vec3 Bro = B3 - ro;\n    float dB3 = dot(Bro, cam[2]);\n    float nrdB = dB3 / drd;    \n    vec3 Bt = B3 - rd * nrdB;\n    vec2 B = vec2(dot(Bt, cam[0]), dot(Bt, cam[1]));\n    \n    vec3 Cro = C3 - ro;\n    float dC3 = dot(Cro, cam[2]);\n    float nrdC = dC3 / drd;    \n    vec3 Ct = C3 - rd * nrdC;\n    vec2 C = vec2(dot(Ct, cam[0]), dot(Ct, cam[1]));\n    \n#if 0\n    // debug draw the control points\n    if (length(A) < 1.5*r) return 0.0;\n    if (length(B) < 1.5*r) return 0.0;\n    if (length(C) < 1.5*r) return 0.0;\n#endif\n    \n#if 0\n    // This section is attempting to normalize all coords, to improve numeric stability\n    // It didn't work\n    \n    vec2 cpRoMin = min(min(A, B), C);\n    vec2 cpRoMax = max(max(A, B), C);\n    vec2 cpWidth = cpRoMax - cpRoMin;\n    float oneOverMaxWidth = 1.0 / max(cpWidth.x, cpWidth.y);\n    //oneOverMaxWidth *= 0.001;\n    \n    A *= oneOverMaxWidth;\n    B *= oneOverMaxWidth;\n    C *= oneOverMaxWidth;\n    r *= oneOverMaxWidth;\n#endif\n            \n#if 0\n    // This section is debug-drawing a sampled version of the curve\n    \n    for (float u = 0.0; u <= 1.0; u += r/2.0) {\n        float iu = 1.0 - u;\n\n        //vec3 x3 = iu*iu*A3 + u*iu*B3 + u*u*C3;\n        //if (dot(normalize(x3-ro), rd) > 0.9999) return 0.0;\n        \n        vec2 x = iu*iu*A + 2.0*u*iu*B + u*u*C;\n        if (length(x) < r) return 0.0;\n    }\n\n    return inf;\n#endif\n    \n    vec2 f = A + C - B;\n    vec2 g = B - 2.0 * A;\n    vec2 h = A;\n    \n    float a = dot(f, f);\n    float b = 2.0 * dot(f, g);\n    float c = 2.0 * dot(f, h) + dot(g, g);\n    float d = 2.0 * dot(g, h);\n    float e = dot(h, h) - r * r;\n    \n    float a2 = a * a;\n    float b2 = b * b;\n    float c2 = c * c;\n    float d2 = d * d;\n    float e2 = e * e;\n    \n#if 1\n    // This is the naive straightfoward computation of the discriminant\n    // this is numerically unstable, especially when tracing at angles\n    // near the plane of the curve\n    \n    float delta = \n        256.0 * a*a2 * e*e2 \n        - 192.0 * a2 * b * d * e2 \n        - 128.0 * a2 * c2 * e2\n        + 144.0 * a2 * c * d2 * e \n        - 27.0 * a2 * d2*d2\n        + 144.0 * a * b2 * c * e2\n        - 6.0 * a * b2 * d2 * e\n        - 80.0 * a * b * c2 * d * e\n        + 18.0 * a * b * c * d*d2\n    \t+ 16.0 * a * c2*c2 * e\n        - 4.0 * a * c*c2 * d2\n    \t- 27.0 * b2*b2 * e2\n    \t+ 18.0 * b*b2 * c * d * e\n        - 4.0 * b*b2 * d*d2\n    \t- 4.0 * b2 * c*c2 * e\n        + b2 * c2 * d2;\n#endif\n    \n#if 0\n    // this section is attempting to factor common parts of the expression\n    // to improve numeric stability\n    // It didn't work\n    \n    float delta = \n        \n        a2 * (\n            e2 * (\n                256.0 * a * e \n                - 192.0 * b * d \n                - 128.0 * c2\n            )\n        \t+ d2 * (\n                144.0 * c * e \n        \t\t- 27.0 * d2\n            )\n        )\n        \n        + a * (\n            6.0 * b2 * (\n                24.0 * c * e2\n        \t\t- d2 * e\n            )\n        \t+ 18.0 * b * c * d*d2\n    \t\t+ 4.0 * c2 * (\n                4.0 * c2 * e\n        \t\t- c * d2\n        \t\t- 20.0 * b * d * e // out of order\n            )\n        )\n        \n    \t+ b2 * (\n            b * (\n                -27.0 * b * e2\n                + 18.0 * c * d * e\n                - 4.0 * d*d2\n            )\n    \t\t- 4.0 * c*c2 * e\n        \t+ (c2 * d2)\n        );\n#endif    \n    \n    float P = 8.0 * a * c - 3.0 * b2;\n    float R = b*b2 + 8.0 * d * a2 - 4.0 * a * b * c;\n    float d0 = c2 - 3.0*b*d + 12.0*a*e;\n    float D = 64.0*a*a2*e - 16.0*a2*c2 + 16.0*a*b2*c - 16.0*a2*b*d - 3.0*b2*b2;\n    float d1 = 2.0 * c*c2 - 9.0*b*c*d + 27.0*b2*e + 27.0*a*d2*d2 - 72.0*a*c*e;\n\n    float p = P / (8.0 * a2);\n    float q = R / (8.0 * a*a2);\n    //float Q = pow(0.5 * (d1 + sqrt(d1*d1 - 4.0*d0*d0*d0)), 1.0/3.0);\n    float Q = pow(0.5 * (d1 + sqrt(-27.0*delta)), 1.0/3.0);\n    float S = 0.5 * sqrt( -2.0 * p / 3.0 + (1.0/(3.0*a))*(Q+d0/Q) );\n    \n    if (delta < 0.0) {\n        // 2 distinct real roots, 2 complex conjugate roots\n        float x = inf, xp;\n        float pre = -b / (4.0*a);\n        float dis1 = -4.0 * S*S - 2.0*p;\n        float dis2 = q/S;\n        if (dis1 + dis2 >= 0.0) {\n            xp = pre - S - 0.5 * sqrt(dis1 + dis2);\n            //if (xp > 0.0 && xp < x && xp < 1.0) x = xp;\n            if (xp < x) x = xp;\n            xp = pre - S + 0.5 * sqrt(dis1 + dis2);\n//            if (xp > 0.0 && xp < x && xp < 1.0) x = xp;\n            if (xp < x) x = xp;\n        }\n        if (dis1 - dis2 >= 0.0) {\n            xp = pre + S - 0.5 * sqrt(dis1 - dis2);\n//            if (xp > 0.0 && xp < x && xp < 1.0) x = xp;\n            if (xp < x) x = xp;\n            xp = pre + S + 0.5 * sqrt(dis1 - dis2);\n//            if (xp > 0.0 && xp < x && xp < 1.0) x = xp;\n            if (xp < x) x = xp;\n        }\n        return 0.1;\n    }\n    \n        return inf;\n#if 0\n    else if (delta > 0.0) {\n        if (P < 0.0 && D < 0.0) {\n            // 4 real roots\n            return inf;//0.1;\n        }\n        else {\n            // all complex roots... ignore!\n            return inf;\n        }\n    }\n    else { // delta == 0.0\n        // ignore until needed\n        return inf;\n    }\n    \n    return inf;\n#endif\n}\n\nfloat qbCurveHit(vec3[curveLen] pts, int n, float r, vec3 ro, vec3 rd, mat3x3 cam) {\n    float minT = inf;\n    vec3 a, c;\n    for (int i = 2; i < n; i++) {\n        a = 0.5 * (pts[i-2] + pts[i-1]);\n        c = 0.5 * (pts[i-1] + pts[i]);\n        float t = qbHit(a, pts[i-1], c, r, ro, rd, cam);\n        if (t >= 0.0 && t < minT) {\n            minT = t;\n            return minT;// debug -- bail early on first hit. remove when t is real\n        }\n    }\n    return minT;\n}\n\nvec3 trace1( mat3x3 cam, vec3 ro, vec3 rd, float time )\n{\n    vec3 color;\n    const int ns = 10;\n    float fns = float(ns);\n    float mint = 9999.0;\n    float sr = 1.0;\n\n    for (int i = 0; i < ns; i++) \n    {\n        float fi = float(i);\n        float fni = fi / fns;\n        float d = 3.0 * sin(time * fni + fi);\n        vec3 sc=vec3(d*cos(tau*fni+time*10.0*fni)+sin(time*10.0), \n                     d*sin(tau*fni+time*10.0*fni), \n                     d*sin(0.5*tau*fni+time*fni*1.4142)+cos(time*10.0));\n\n        float t = sphereHit(sc, sr, ro, rd);\n        if (t > mint) continue;\n        mint = t;\n        \n        vec3 hit = rd * t + ro;\n        vec3 normal = sphereNormal(sc, sr, hit);\n        \n        float dup    = 1.0 * dot(normal, cam[1]) + 0.0;\n        float ddown  = 1.0 * dot(normal, -cam[1]) + 0.0;\n        float dright = 1.0 * dot(normal, cam[0]) + 0.0;\n        float dfwd   = 1.0 * dot(normal, -cam[2] ) + 0.0;\n        float z = mod(2.0 * /*length(hit)*/hit.z, 1.0);\n\n        vec3 refl = reflect(rd, normal);\n\n        color = vec3(dright, dup, dfwd);\n        //color = vec4(z, z, z);\n        \n        // specular\n        float spec = pow(dot(refl, cam[1]), 20.0);\n        if (spec > 0.0) color += vec3(spec, spec, spec);\n\n        //color = normal;\n        //float j = t/10.0; color = vec3(j, j, j);\n        //color = vec3(mod(hit.x, 1.0), mod(hit.y, 1.0), 0.0);\n    }\n\n    if (mint > 999.0)\n    {\n        color = vec3(0.0, 0.75+0.25*sin(iTime), 1.0);\n    }\n    return color;\n}\n\nvec3 trace0( mat3x3 cam, vec3 ro, vec3 rd, float time )\n{\n    vec3 color;\n    const int ns = 10;\n    float fns = float(ns);\n    float mint = 9999.0;\n    float sr = 1.0;\n\n    if (spheres) for (int i = 0; i < ns; i++) \n    {\n        float fi = float(i);\n        float fni = fi / fns;\n        float d = 3.0 * sin(time * fni + fi);\n        vec3 sc=vec3(d*cos(tau*fni+time*10.0*fni)+sin(time*10.0), \n                     d*sin(tau*fni+time*10.0*fni), \n                     d*sin(0.5*tau*fni+time*fni*1.4142)+cos(time*10.0));\n        \n        float t = sphereHit(sc, sr, ro, rd);\n        if (t > mint) continue;\n        mint = t;\n        \n        vec3 hit = rd * t + ro;\n        vec3 normal = sphereNormal(sc, sr, hit);\n        \n        float dup    = 1.0 * dot(normal, cam[1]) + 0.0;\n        float ddown  = 1.0 * dot(normal, -cam[1]) + 0.0;\n        float dright = 1.0 * dot(normal, cam[0]) + 0.0;\n        float dfwd   = 1.0 * dot(normal, -cam[2] ) + 0.0;\n        float z = mod(2.0 * /*length(hit)*/hit.z, 1.0);\n\n        vec3 refl = reflect(rd, normal);\n\n        color = vec3(dright, dup, dfwd);\n        //color = vec4(z, z, z);\n        color = 0.5 * color + 0.5 * trace1(cam, hit, -refl, time);\n        \n        // specular\n        float spec = pow(dot(refl, cam[1]), 20.0);\n        if (spec > 0.0) color += vec3(spec, spec, spec);\n\n        //color = normal;\n        //float j = t/10.0; color = vec3(j, j, j);\n        //color = vec3(mod(hit.x, 1.0), mod(hit.y, 1.0), 0.0);\n    }\n    \n    if (curves) {\n        float db = 0.0;\n        float dd = 1.0;\n                \n        for (int i = 0; i < curveLen; i++) {\n            float fi = float(i);\n            pts[i] = vec3(1.5 * sin(fi), fi*1.0 - 6.0, 1.5 * cos(fi));\n        }\n        \n        int i = 0;\n        for (float ox = -db; ox <= db + dd/2.0; ox += dd) {\n        for (float oy = -db; oy <= db + dd/2.0; oy += dd) {\n        for (float oz = -db; oz <= db + dd/2.0; oz += dd, i++) {\n#if 0\n            float qbt = qbHit(\n                vec3(-2.0+ox, -2.0+oy, 0.0+oz), \n                vec3(-1.0+ox, 2.0+oy+2.0*sin(10.0*tau*time+float(i)), 0.0+oz), \n                vec3(2.0+ox, -2.0+oy, 0.0+oz), \n                0.05, ro, rd, cam);\n#else\n            float qbt = qbCurveHit(pts, curveLen, 0.05, ro, rd, cam);\n            //float qbCurveHit(vec3[] pts, int n, float r, vec3 ro, vec3 rd, mat3x3 cam) {\n#endif\n            if (qbt < mint) {\n                mint = qbt;\n                color = vec3(0.0, 0.0, 0.0);\n            }\n        }\n        }\n        }\n    }\n\n    if (mint > 999.0)\n    {\n        color = vec3(0.0, 0.75+0.25*sin(iTime), 1.0);\n    }\n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time = (iMouse.z > 0.0) ? iMouse.x / iResolution.x :  iTime / 10.0;\n    vec3 ro = vec3(10.0*sin(tau * time), 0.0, 10.0*cos(tau * time));\n    vec2 uv = 2.0 * fragCoord.xy / iResolution.xy - vec2(1.0, 1.0);\n    uv.x *= iResolution.x / iResolution.y;\n    vec3 up = vec3(0.0, 1.0, 0.0);\n    vec3 lookat = vec3(0.0, 0.0, 0.0);\n    vec3 fwd   = normalize(lookat - ro);\n    vec3 right = normalize(cross(fwd, up));\n    vec3 camup = normalize(cross(right, fwd));\n    vec3 rd = normalize(fwd + 0.5 * (uv.x * right + uv.y * up));\n    \n    fragColor = vec4(trace0(mat3x3(right, camup, fwd), ro, rd, time), 1.0);\n}\n","name":"Image","description":"","type":"image"}]}