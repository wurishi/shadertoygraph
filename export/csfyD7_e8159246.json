{"ver":"0.1","info":{"id":"csfyD7","date":"1686928925","viewed":40,"name":"Parallel Science Basic","username":"romeosoft","description":"Parallel Science Basic.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["math","parallelscience"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n                          .-''--.\n                         _`>   `\\.-'<\n                      _.'     _     '._\n                    .'   _.='   '=._   '.\n                    >_   / /_\\ /_\\ \\   _<\n                      / (  \\o/\\\\o/  ) \\\n                      >._\\ .-,_)-. /_.<\n                          /__/ \\__\\\n                            '---'  \n            \n          “If I can’t picture it, I can’t understand it.”\n*/\n\nconst real R = 1.0;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (-iResolution.xy + 2.0*fragCoord.xy) / iResolution.y;;\n\n    vec3 cor = BLACK;\n    \n    crd3 c = UC; c.o = -UZ * 8.0; // Camera Coordinate\n    \n    vec3 p = p_x_c(vec3(uv,0),c);\n    {// sphere\n    \n        real rd = length(crossdot(p, c.uz));\n        if(rd < R)\n        {\n           vec3 light = v_x_q(normalize(UX+UY+UZ), angax_q(iTime, UY));\n\n           vec3 puz = c.uz * (dot(p, c.uz) - sqrt(R*R-rd*rd));\n           vec3 ov = p-puz;\n\n           cor = WHITE * dot(ov, light);\n        }\n    }\n    \n    // Output to screen\n    fragColor = vec4(cor, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"/** \t       \t     $ Parallel Science $\n*\n* Parallel science is a scientific principle that develops independently and explains\n* phenomena using different methods from mainstream scientific principles.\n* It includes independently developed mathematical tools and independent interpretations\n* of physical phenomena. \n* Here are some basic parts of the code, including mathematical foundations and \n* fundamental principles, which will be gradually improved in the future.\n* \n*               % Everything for visualization %\n*/\n\n#define PI 3.14156\n#define real float\n#define imag float\n#define quat quaternion\n#define crd3 coord3\n\n#define CSCREEN vec2(0.5,0.5)\n\n#define BLACK vec3(0,0,0)\n#define WHITE vec3(1,1,1)\n#define RED vec3(1,0,0)\n#define GREEN vec3(0,1,0)\n#define BLUE vec3(0,0,1)\n#define YELLOW vec3(1,1,0)\n#define GREY vec3(0.5,0.5,0.5)\n\n#define XYZ0 vec3(0,0,0)\n#define UX vec3(1,0,0)\n#define UY vec3(0,1,0)\n#define UZ vec3(0,0,1)\n#define UC crd3(UX, UY, UZ, XYZ0)\n\n// ---------------------------------------------------------\n// Quaternion:\n// Quaternions are real mathematics numbers, \n// meaning there is number theory behind them.\n// ---------------------------------------------------------\nstruct quaternion\n{\n    real w, x, y, z;\n};\nquaternion angax_q(real ang, vec3 ax)\n{\n    quaternion q;\n    real halfang = 0.5 * ang;\n    real fsin = sin(halfang);\n    q.w = cos(halfang);\n    q.x = fsin * ax.x;\n    q.y = fsin * ax.y;\n    q.z = fsin * ax.z;\n    return q;\n}\nquaternion wv_q(real w, vec3 v)\n{\n   return quaternion(w, v.x,v.y,v.z);\n}\n// v x q\nvec3 v_x_q(vec3 v, quaternion q)\n{\n    // nVidia SDK implementation\n    vec3 uv, uuv;\n    vec3 qvec = vec3(q.x, q.y, q.z);\n    uv = cross(qvec, v);\n    uuv = cross(qvec, uv);\n    uv = uv * (2.0f * q.w);\n    uuv = uuv * 2.0f;\n\n    return v + uv + uuv;\n}\n// q x q\nquaternion q_x_q(quaternion q1, quaternion q2)\n{\n    quaternion q;\n\n    q.w = q1.w * q2.w - q1.x * q2.x - q1.y * q2.y - q1.z * q2.z;\n    q.x = q1.w * q2.x + q1.x * q2.w + q1.y * q2.z - q1.z * q2.y;\n    q.y = q1.w * q2.y + q1.y * q2.w + q1.z * q2.x - q1.x * q2.z;\n    q.z = q1.w * q2.z + q1.z * q2.w + q1.x * q2.y - q1.y * q2.x;\n    return q;\n}\nquaternion exp_q(quaternion q)\n{\n    vec3 v = vec3(q.x,q.y,q.z);\n    real r = length(v);\n    real tr = exp(q.w);\n    return wv_q(tr * cos(r), normalize(v) * (tr*sin(r)));\n}\n\n// ---------------------------------------------------------\n// Coordinate System:\n// A coordinate system in three-dimensional space \n// consists of an origin plus three orientation axes\n// c++ version : \n// https://github.com/panguojun/Coordinate-system-transformation\n// ---------------------------------------------------------\nstruct coord3\n{\n    vec3 ux, uy, uz; // three axial unit vectors\n    vec3 o;          // origin\n};\ncoord3 uxyz_c(vec3 _ux, vec3 _uy, vec3 _uz)\n{\n    coord3 c;\n    c.ux = _ux;\n    c.uy = _uy;\n    c.uz = _uz;\n    c.o = XYZ0;\n    return c;\n}\ncoord3 uxy_c(vec3 _ux, vec3 _uy)\n{\n    coord3 c;\n    c.ux = _ux;\n    c.uy = _uy;\n    c.uz = cross(_ux,_uy);\n    c.o = XYZ0;\n    return c;\n}\ncoord3 norm_c(coord3 c)\n{\n    c.ux = normalize(c.ux);\n    c.uy = normalize(c.uy);\n    c.uz = normalize(c.uz);\n    return c;\n}\n// p x c\nvec3 p_x_c(vec3 p, coord3 c)\n{\n    return c.ux * p.x + c.uy * p.y + c.uz * p.z + c.o;\n}\ncoord3 c_x_q(coord3 c, quat q)\n{\n    return coord3(\n        v_x_q(c.ux, q), v_x_q(c.uy, q), v_x_q(c.uz, q),\n        c.o);\n}\n// p / c\nvec3 p_z_c(vec3 p, coord3 c)\n{\n    vec3 v = p - c.o;\n    return vec3(dot(v, c.ux), dot(v, c.uy), dot(v, c.uz));\n}\nreal c_ax_dot(vec3 v, coord3 c)\n{\n    return dot(v, c.ux + c.uy + c.uz);\n}\nvec3 c_ax_cross(coord3 a, coord3 b)\n{\n    return vec3(\n        dot(a.uy, b.uz) - dot(a.uz, b.uy),\n        dot(a.uz, b.ux) - dot(a.ux, b.uz),\n        dot(a.ux, b.uy) - dot(a.uy, b.ux)\n    );\n}\ncoord3 c_flipx(coord3 c)\n{\n    c.ux = -c.ux;\n    return c;\n}\ncoord3 c_flipy(coord3 c)\n{\n    c.uy = -c.uy;\n    return c;\n}\ncoord3 c_flipz(coord3 c)\n{\n    c.uz = -c.uz;\n    return c;\n}\n\n// ---------------------------------------------------------\n// GRAD, DT\n// ---------------------------------------------------------\n#define delta_d 0.001\n#define delta_t 0.001\n\n#define GRAD_V(Fai, p, t) \\\n        vec3((Fai(p + vec3(delta_d,0.0,0.0), t) - Fai(p, t)) / delta_d,\\\n        (Fai(p + vec3(0.0,delta_d,0.0), t) - Fai(p, t)) / delta_d, \\\n        (Fai(p + vec3(0.0,0.0,delta_d), t) - Fai(p, t)) / delta_d)\n\n#define GRAD_C(A, p, t) \\\n        uxyz_c( \\\n        (A(p + vec3(1.0,0.0,0.0) * delta_d, t) - A(p, t)) / delta_d, \\\n        (A(p + vec3(0.0,1.0,0.0) * delta_d, t) - A(p, t)) / delta_d, \\\n        (A(p + vec3(0.0,0.0,1.0) * delta_d, t) - A(p, t)) / delta_d)\n\n#define DT(A, p, t) (A(p,t + delta_t) - A(p, t)) / delta_t\n\n// ---------------------------------------------------------\n// Space-Time Vector:\n// ---------------------------------------------------------\nstruct time\n{\n    float tr;          // real time（Expansion time）\n    float ti;          // imagine time（Phase time）\n};\nstruct space_time\n{\n    vec3 n;\n    time t;\n};\nvec3 space_time_v(space_time st)\n{\n    return st.n * exp(st.t.tr) * cos(st.t.ti);\n}\n\n// ---------------------------------------------------------\n// Vector Math\n// ---------------------------------------------------------\nvec3 crossdot(vec3 v1, vec3 v2) {\n    vec3 result;\n    result.x = v1.y * v2.z - v1.z * v2.y;\n    result.y = v1.z * v2.x - v1.x * v2.z;\n    result.z = v1.x * v2.y - v1.y * v2.x;\n    return result;\n}","name":"Common","description":"","type":"common"}]}