{"ver":"0.1","info":{"id":"csSfRR","date":"1689317633","viewed":50,"name":"Escape Time Box 2","username":"AlwaysElise","description":"what if a fractal and a raymarched sdf had a child, and that child had reflection\n\nand also some artifacts bc sdf reflections just kinda do that when you curve the rays due to the discrete iteration steps","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["sdf","fractals","2amlogic"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float box( vec3 p, vec3 size )\n{\n    vec3 d = abs( p ) - size;\n    return min( 0., max( d.x, max( d.y, d.z ) ) ) +\n        length( max(d, 0.) );\n}\n\nvec2 r2( vec2 i, float a )\n{\n    return vec2( i.x * cos(a) + i.y * sin(a), i.x * -sin(a) + i.y * cos(a) );\n}\n\nconst float MIN_THRESH = 0.001;\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 rayDirection = normalize( vec3( uv - 0.5, 0.5 ) );\n    vec3 position = vec3( 0., 0., -5. );\n    \n    rayDirection.xz = r2( rayDirection.xz, iTime*.15 );\n    position.xz = r2( position.xz, -iTime*.15 );\n    \n    float minDist = 0.;\n    int i = 0;\n    for( ; i < 100; i++ )\n    {\n        minDist = box(position, vec3( 1., 0.5, 1. ));\n        if( minDist < MIN_THRESH || minDist > 100.0 )\n            break;\n        rayDirection.xy = r2( rayDirection.xy, minDist );\n        float param_cycle = (150.-abs(mod(iTime+120., 600.)-300.f))*0.01;\n        rayDirection -= position * param_cycle * 0.1;\n        rayDirection = normalize(rayDirection);\n        position += minDist * rayDirection;\n    }\n   vec3 col = vec3( 0., 0., 0. );\n    if( minDist < MIN_THRESH )\n        col.rgb = (vec3( position.xyz )*.5+.5)* vec3( float(75-i)/75.);;\n    if( minDist > 100. )\n        col.rgb = vec3(1.,1.,1.)* vec3( float(75-i)/75.);\n    \n    for( int j = 0; j < 5; j++ ) {\n    if( minDist < MIN_THRESH ){\n        float collisionT = 0.;\n        i = 0;\n        vec3 rOld = rayDirection;\n        float incidence = 0.;\n        \n        vec3 pOff = abs(position) - vec3( 1., .5, 1. );\n        if(pOff.x > max(pOff.y, pOff.z)) {\n            collisionT = abs(pOff.x) / abs(rayDirection.x);\n            rayDirection.x = -rayDirection.x;\n            incidence = 1./abs(rayDirection.x);\n            }\n        if(pOff.y > max(pOff.x, pOff.z)) {\n            collisionT = abs(pOff.y) / abs(rayDirection.y);\n            rayDirection.y = -rayDirection.y;\n            incidence = 1./abs(rayDirection.y);\n            }\n        if(pOff.z > max(pOff.x, pOff.y)) {\n            collisionT = abs(pOff.z) / abs(rayDirection.z);\n            rayDirection.z = -rayDirection.z;\n            incidence = 1./abs(rayDirection.z);\n            }\n        position += collisionT * rOld;\n        position += MIN_THRESH * 2. * incidence * rayDirection;\n        for( ; i < 100; i++ )\n        {\n            minDist = box(position, vec3( 1., 0.5, 1. ));\n            if( minDist < MIN_THRESH || minDist > 100.0 )\n                break;\n            rayDirection.xy = r2( rayDirection.xy, minDist );\n            float param_cycle = (150.-abs(mod(iTime+120., 600.)-300.f))*0.01;\n            rayDirection -= position * param_cycle * 0.1;\n            rayDirection = normalize(rayDirection);\n            position += minDist * rayDirection;\n        }\n        if( minDist < MIN_THRESH )\n            col.rgb += (vec3( position.xyz )*.5+.5)* vec3( float(75-i)/75.) * pow(.5, float(j));\n        if( minDist > 100. )\n            col.rgb += (vec3(1.,1.,1.))* vec3( float(75-i)/75.) * pow(.5, float(j));\n    }\n    }\n    \n    \n    col *= 0.8;\n\tfragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}