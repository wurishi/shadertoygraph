{"ver":"0.1","info":{"id":"XdKGWm","date":"1454834191","viewed":1232,"name":"Dila's Raymarch Tutorial","username":"Lucanio","description":"This is dila's tutorial https://www.youtube.com/watch?v=yxNnRSefK94 I added the things he says in the video as comments","likes":24,"published":1,"flags":0,"usePreview":0,"tags":["procedural","3d","raymarching","tutorial"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//map function, core of all the ray marching shaders. They return a scalar value, given a 3D point.\nfloat map(vec3 p){\n    //instancing:\n    // you transform the space so it's a repeating coordinate system\n    vec3 q = fract(p) * 2.0 -1.0;\n    \n  \t//sphere map function is the length of the point minus the radius\n    //it's negative on the inside of the sphere and positive on the outside and 0 on the surface.\n    float radius = .25;\n \treturn length(q) - radius;   \n}\n\n//we use a numerical marching algorithim called trace\n//o = origin\n//r = ray to march along\n//t = intersection along the ray\nfloat trace(vec3 o, vec3 r){\n    float t = 0.0;\n    for (int i =0; i <32; i++){\n        //origin + ray*t = where we are along the ray;\n        // we step along the ray in variable length segments, \n     \tvec3 p = o+r*t;   \n        //until we gradual converge on the intersection and evaluate the map function at that point\n        float d=map(p);\n        //we add that to t\n        // the smaller the 0.5 value, the less accurate the map function is\n        t += d * 0.5;\t\n    }\n     return t;\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    //transform the cordinates to -1 to 1, instead of 0 to 1\n    uv = uv * 2.0 - 1.0;\n    //correct the aspect ratio\n    uv.x *= iResolution.x / iResolution.y;\n    \n    //r = ray\n    // it needs to be normalized so it doesn't poke through the geometry when it's really close to the camera\n    //the z cordinate is 1.0, that's how you project the 2D coordinate into 3D space, \n    //you just decide the z value, which determines the field of view of the camera\n    // smaller z = higher fov. 1.0 = 90 degrees\n    vec3 r = normalize(vec3(uv,1.0));\n    \n    //rotation around the y axis\n    //you have to look up on wikipedia what this is\n    float the= iTime*.25;\n    r.xz *= mat2(cos(the), -sin(the), sin(the), cos(the));\n    \n    // the sphere is at (0.0,0.0,0.0)\n    vec3 o = vec3(0.0,0.0, iTime);\n    \n    //trace from the origin along the ray to find the intersection from our map function\n    float t = trace(o, r);\n    // simple fogging funcition to darken things the further away they are\n    float fog = 1.0 / (1.0 + t * t * 0.1);\n    \n    vec3 fc = vec3(fog);\n    \n\tfragColor = vec4(fc,1.0);\n}","name":"Image","description":"","type":"image"}]}