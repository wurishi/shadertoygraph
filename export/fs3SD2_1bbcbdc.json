{"ver":"0.1","info":{"id":"fs3SD2","date":"1635326421","viewed":96,"name":"howthenameistaken","username":"gunzes","description":"kurwa litosci","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["noise"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.y-vec2(0.888888,0.5);\n    //uv.y -= .1;\n    uv *= 2.;\n    \n    float noise1d1 = noise1D(uv.x*65.)*.1;\n    float noise1d2 = noise1D(uv.y*15.);\n    //noise1d1 *= noise1d2;\n    //uv.x += ((noise1d1-.5)*2.)*.01;\n    //uv.y += ((noise1d2-.5)*2.)*.01;\n    \n    float timeRemapped = (((sin(iTime))*.5)+.5)*1.;  \n    float timeSin = sin(iTime);\n    float timeCos = cos(iTime);\n    \n   // uv *= rotate(timeRemapped*3.1); \n     \n    vec2 uv2 = abs(uv*.15*150.*(noise1d1*sin(iTime*1.21)));\n    \n    \n    vec2 uv3 = (uv*.15*50.);\n    //uv2 *= rotate(iTime*.5);\n    \n    vec2 uvSquareRot1 = uv*1.7;\n    vec2 uvSquareRot2 = uv*2.2;\n    vec2 uvSquareRot3 = uv*2.;\n    \n    //uv2 *= rotate(iTime*-.5);    \n    //uv3 *= rotate(iTime*.15);\n    \n\n    vec3 col = vec3(.0);\n    vec3 blue = vec3(0.,.5,1.);\n    vec3 green = vec3(0.,.7,0.);\n    vec3 red = vec3(1.,0.,0.);\n    //col += vec3(vec2(noise2D(uv2)),0.);\n    float noise1 = noise2D(vec2(uv2.x+iTime,uv2.y)) *\n                  noise2D(vec2(-uv2.x+iTime,uv2.y)) *\n                  noise2D(vec2(-uv2.x,-uv2.y+iTime)) *\n                  noise2D(vec2(uv2.x,-uv2.y+iTime))\n                  ;\n    float noise2 = noise2D(vec2(uv3.x+iTime,uv3.y)) *\n                  noise2D(vec2(-uv3.x+iTime,uv3.y)) *\n                  noise2D(vec2(-uv3.x,-uv3.y+iTime)) *\n                  noise2D(vec2(uv3.x,-uv3.y+iTime))\n                  ;\n    //jazda\n    uv2.x += noise1*1.5;\n    \n    float noise3x = noise2D(vec2(uv2.x*1.+iTime*1.1+iTime));\n    noise3x += noise2D(vec2(uv2.x*2.));\n    float noise3y = noise2D(vec2(uv3.y*1.+iTime*5.));\n    \n    \n    //float noise3 = noise2D(vec2(uv3.y*2.));             \n    \n    float time = iTime*-2.5;\n    \n    \n    \n    //uvSquareRot1.y += noise1*3.5;\n    //uvSquareRot2.y += noise1*3.5;\n    //uvSquareRot3.y += noise1*3.5;\n    \n    //col = vec3(length(uv * noise * 2.));\n    col = 1.-col;\n    \n    uvSquareRot1.y += ((noise3x-.5)*.2)*10.* timeSin;\n    uvSquareRot2.y += ((noise3x-.5)*.2)*10.* timeSin; \n    uvSquareRot3.y += ((noise3x-.5)*.2)*10.* timeSin;\n    \n   // uvSquareRot1.x *= (timeSin*3.)+2.;\n\n    uvSquareRot1.x += ((noise3y-.5)*.2)*5.* timeCos*3.;\n    uvSquareRot2.x += ((noise3y-.5)*.2)*5.* timeCos*2.; \n    uvSquareRot3.x += ((noise3y-.5)*.2)*5.* timeCos*1.;\n    \n    uvSquareRot1 *= rotate(1. * time*.1 *noise1d1*15.); ///////////////////////\n    uvSquareRot2 *= rotate(-1. * time*.5);\n    uvSquareRot3 *= rotate(1. * time*.25 );\n    \n    \n    \n\n    \n    \n    col *= (drawSquare(uvSquareRot1,.55+noise1,.2) - drawSquare(uvSquareRot1,.55*.99 + noise1,.01)) * blue*.7 +\n           (drawSquare(uvSquareRot1,1.+noise1,.2) - drawSquare(uvSquareRot1,1.*.9 + noise1,.01)) * blue*.1 +\n           (drawSquare(uvSquareRot2,.5+noise1,.1)- drawSquare(uvSquareRot2,.5*.9 + noise1,.01)) * blue *.5 +\n           (drawSquare(uvSquareRot3,.35+noise1,.3) - drawSquare(uvSquareRot3,.35*.9 + noise1,.01)) * blue *1. +\n           drawSquare(uvSquareRot3,.1+noise1,.05);\n           \n    \n    col += vec3(pow(col.x,1.5));\n    col += vec3(pow(col.y,.9));\n    col += vec3(pow(col.z,3.5));\n    \n   /*     if (col.x > .1) {\n        \n        col.x -= noise3;\n    }\n    */\n    \n    //col = vec3(noise3);\n\n\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n    \n    \n    \n    \n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"//random\n\nfloat rand(vec2 coord){\n    return fract(sin(dot(coord,vec2(12.9898,78.233)))*\n        43758.5453123);\n}\n\n\n//noise1d\n\nfloat noise1D(float coord){\n\n    float cellId = floor(coord);\n    float cellFraction = fract(coord);\n    //return clamp(mix(rand(vec2(cellId)),rand(vec2(cellId+1.)),smoothstep(0.,1.,cellFraction)),0.,1.);\n    //return mix(rand(vec2(cellId)),rand(vec2(cellId+1.)),cellFraction);\n    return rand(vec2(cellId));\n}\n\n//noise2d\n\nfloat noise2D(vec2 coord){\n    vec2 id = floor(coord);\n    vec2 fraction = fract(coord);\n    //4 punkty kwadratu\n    float a = rand(id);\n    float b = rand(id + vec2(1.,0.));\n    float c = rand(id + vec2(0.,1.));\n    float d = rand(id + vec2(1.,1.));\n    \n    //interpolacja\n    vec2 smoothCorners = smoothstep(0.,1.,fraction);\n    //vec2 smoothCorners = fraction*fraction*(3.0-2.0*fraction)\n    \n    //mix kornerow\n    return mix(a,b,smoothCorners.x) +\n           (c - a) * smoothCorners.y * (1.- smoothCorners.x) +\n           (d - b) * smoothCorners.x * smoothCorners.y;\n}\n\n//rysowanie kwadratow \n\n\nfloat drawSquare (vec2 coord, float a, float blur){\n    float band1 = smoothstep(a+blur,a-blur,coord.x);\n    float band2 = smoothstep(-a-blur,-a+blur,coord.x);\n    float band3 = smoothstep(a+blur,a-blur,coord.y);\n    float band4 = smoothstep(-a-blur,-a+blur,coord.y);\n    return band1*band2*band3*band4;\n}\n\n//rotate\n\nmat2 rotate(float angle){\n    \n    return mat2(cos(angle), -sin(angle),\n                sin(angle), cos(angle));\n\n}","name":"Common","description":"","type":"common"}]}