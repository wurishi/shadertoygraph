{"ver":"0.1","info":{"id":"dsVfzW","date":"1698005560","viewed":56,"name":"00LightIntensityDiscussion","username":"foodini","description":"A simple demo of the difference between linear and exponential intensity. RGB colors are NOT LINEAR!!! We have considerably better differential sensitivity in the darker intensities, so RGB is biased to have more detail there.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["gamma"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\nClick anywhere. The gamma-correction value is set by the mouse's\nvertical position and the RGB input value is set by the mouse's\nhorizontal position.\n\nThe top curve (and the top half of the margins) shows a LINEARLY\nINCREASING TRUE BRIGHTNESS as the mouse moves from left to right.\nHowever, your eyes see less detail in linearly increasing \nbrightness as the brightness gets higher. Let me see if I can \nmake that clear:\n\nIf I'm in a room with nothing in it except for a single light\nsource, and I cannot see the light source, the only indication I\nget of how much light there is is from how much light is bouncing\noff the walls and into my eyes. Let's say the light is a single\ncandle and I add another candle. I would easily be able to tell\nif you added another candle, right?\n\nLet's say we started, instead, with a 100-Watt lightbulb. If I\nadd a single candle to that, there would be no way for me to tell\nthat the lighting in the room had increased BY THE SAME AMOUNT as\nit had when I added a candle to another candle. BUT, if I added\na second light bulb to the first, I WOULD PERCIEVE THE SAME\nINCREASE IN LIGHTING AS I DID WHEN I ADDED ONE CANDLE TO ANOTHER.\n\nThis is why RGB space is the way it is. The difference in output\nphotons as RGB goes from, say, (1, 1, 1) to (5, 5, 5) is FAR LESS\nthan going from (251, 251, 251) to (255, 255, 255). But we\nperceive the same amount of change between them.\n\n*/\n\nvec2 coords_to_uv(vec2 coords) {\n    return (coords - (iResolution.xy / 2.0)) / iResolution.y * 2.0;\n}\n\nvec2 coords_to_xy(vec2 coords) {\n    vec2 uv = coords_to_uv(coords);\n    vec2 xy = (uv + 1.0) / 2.0;\n    xy.x = max(0.0, xy.x);\n    xy.x = min(1.0, xy.x);\n    return xy;\n}\n\nvec2 mouse_to_xy() {\n    return coords_to_xy(iMouse.xy);\n}\n\nfloat linear_intensity(float x, float gamma) {\n    return pow(x, 1.0/gamma);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // NOTE!!!\n    // This is not my usual coordinate system. uv.y ranges from -1.0->1.0!!!\n    vec2 uv = coords_to_uv(fragCoord);\n    \n    vec2 mouse_uv = coords_to_uv(iMouse.xy);\n    vec2 mouse_xy = mouse_to_xy();\n    vec2 xy = coords_to_xy(fragCoord);\n    float gamma = 1.7 + (mouse_xy.y) * 0.6;\n    \n    // Draw the background color\n    if(abs(uv.x) < 1.0) {\n        fragColor = vec4(xy.y);\n    } else {\n        if(uv.y <= 0.0) {\n            fragColor = vec4(mouse_xy.x);\n        } else {\n            fragColor = vec4(linear_intensity(mouse_xy.x, gamma));\n        }\n    }\n\n    if(abs(uv.x) > 1.0) {\n        return;\n    }\n    \n    // Draw the x==y line\n    if(abs(xy.x - xy.y) < 0.006) {\n        fragColor = vec4(fract(length(xy) * 20.0));\n    }\n\n    // Draw the Gamma curve\n    for(float x=0.0; x<=1.0; x+=0.002) {\n        vec2 curve_pos = vec2(x, linear_intensity(x, gamma));\n\n        if(length(xy-curve_pos) < 0.006) {\n            fragColor = vec4(fract(uv.x * 20.0));\n        }\n    }\n    // Draw the vertical cursor\n    if(abs(xy.x - mouse_xy.x) < 0.006) {\n        fragColor = vec4(fract(uv.y * 20.0));\n    }\n\n    // Print the rgb intensity for the current mouse position\n    init_printing(vec2(0.55, -0.80), 0.05);\n    fragColor += print(iChannel0, int[](_R, _G, _B, _COLON, _SPACE, _SPACE), uv).xxxx;\n    fragColor += print(iChannel0, mouse_xy.x*255.0, uv, 0).xxxx;\n    newline();\n    fragColor += print(iChannel0, int[](_gamma, _R, _G, _B, _COLON, _SPACE), uv).xxxx;\n    fragColor += print(iChannel0, linear_intensity(mouse_xy.x, gamma)*255.0, uv, 0).xxxx;\n    newline();\n    fragColor += print(iChannel0, int[](_gamma, _COLON, _SPACE, _SPACE, _SPACE), uv).xxxx;\n    fragColor += print(iChannel0, gamma, uv, 2).xxxx;\n\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"/*\nd88888b  .d88b.  d8b   db d888888b .d8888.\n88'     .8P  Y8. 888o  88 `~~88~~' 88'  YP\n88ooo   88    88 88V8o 88    88    `8bo.\n88~~~   88    88 88 V8o88    88      `Y8b.\n88      `8b  d8' 88  V888    88    db   8D\nYP       `Y88P'  VP   V8P    YP    `8888Y'\n*/\n\n//TODO:\n//* Have the float's width take an ivec2 in printf %5.12f fashion.\n\n#define DC(name, val) const int name = val\n\nDC(_NULL,127); //I may want as non-null since the font has a character there.\n\nDC(_SPACE,32); DC(_BANG,33); DC(_QUOTE,34); DC(_HASH,35); \nDC(_DOLLAR,36); DC(_PERCENT,37); DC(_AMPERSAND,38); DC(_APOSTROPHE,39); \nDC(_PREN,40); DC(_NERP,41); DC(_STAR,42); DC(_PLUS,43); \nDC(_COMMA,44); DC(_MINUS,45); DC(_PERIOD,46); DC(_SLASH,47);\n\nDC(_0,48); DC(_1,49); DC(_2,50); DC(_3,51);\nDC(_4,52); DC(_5,53); DC(_6,54); DC(_7,55);\nDC(_8,56); DC(_9,57); DC(_COLON,58); DC(_SEMICOLON,59);\nDC(_LFTANGL,60); DC(_EQUAL,61); DC(_RGTANGL,62); DC(_QUESTION,63);\n\nDC(_AT,64); DC(_A,65); DC(_B,66); DC(_C,67); \nDC(_D,68); DC(_E,69); DC(_F,70); DC(_G,71); \nDC(_H,72); DC(_I,73); DC(_J,74); DC(_K,75); \nDC(_L,76); DC(_M,77); DC(_N,78); DC(_O,79); \n\nDC(_P,80); DC(_Q,81); DC(_R,82); DC(_S,83); \nDC(_T,84); DC(_U,85); DC(_V,86); DC(_W,87); \nDC(_X,88); DC(_Y,89); DC(_Z,90); DC(_LFTSQR,91); \nDC(_BACKSLASH,92); DC(_RGTSQR,93); DC(_CARET,94); DC(_UNDERSCORE,95); \n\nDC(_GRAVE,96); DC(_a,97); DC(_b,98); DC(_c,99); \nDC(_d,100); DC(_e,101); DC(_f,102); DC(_g,103); \nDC(_h,104); DC(_i,105); DC(_j,106); DC(_k,107); \nDC(_l,108); DC(_m,109); DC(_n,110); DC(_o,111); \n\nDC(_p,112); DC(_q,113); DC(_r,114); DC(_s,115); \nDC(_t,116); DC(_u,117); DC(_v,118); DC(_w,119); \nDC(_x,120); DC(_y,121); DC(_z,122); DC(_LFTSQUIG,123); \nDC(_PIPE,124); DC(_RGTSQUIG,125); DC(_TILDE,126);\n\nDC(_alpha,128); DC(_beta,129); DC(_gamma,130); DC(_delta,131); \nDC(_epsilon,132); DC(_theta,133); DC(_lambda,134); DC(_mu,135); \nDC(_xi,136); DC(_pi,137); DC(_rho, 138); DC(_sigma,139); \nDC(_tau,140); DC(_phi,141); DC(_psi,142); DC(_omega,143); \n\nDC(_GAMMA,144); DC(_DELTA,145); DC(_THETA,146); DC(_LAMBDA,147); \nDC(_PI,148); DC(_SIGMA,149); DC(_PHI,150); DC(_PSI,151); \nDC(_OMEGA,152); DC(_INFINITY,153); DC(_FORTE,154); DC(_degrees,155); \nDC(_INTEGRAL, 156); DC(_PARTIAL_DIFF, 157); DC(_NABLA,158); DC(_SQRT, 159); \n\n                     DC(_GNAB,161); DC(_CENT,162); DC(_POUND,163); \nDC(_VECTOR_OUT,164); DC(_YEN,165); DC(_BROKEN_PIPE,166); DC(_CONTOUR_INTEGRAL,167); \n                     DC(_COPYRIGHT,169); DC(_superscript_a,170); DC(_LEFT_SHIFT,171); \n                                         DC(_REGISTERED,174); DC(_OVERBAR,175); \n                                         \nDC(_DEGREES, 176); DC(_PLUSMINUS,177); DC(_superscript2,178); DC(_superscript3,179); \nDC(_ACCENT, 180); DC(_MU,181); DC(_PARAGRAPH,182); DC(_DOT,183);\n                  DC(_superscript_1,185); DC(_superscript_0,186); DC(_RIGHT_SHIFT,187); \nDC(_QUARTER,188); DC(_HALF,189); DC(_THREE_QUARTERS,190); DC(_NOITSEUQ,191); \n\n\n\n\nvec4 print_char(sampler2D font_channel, int c, float size, vec2 char_pos, vec2 uv) {\n    //This took me a while to get my brain around: uv and char_pos are in the same\n    //vector space. What that space is is irrelevant. It can be fragCoord, a\n    //square-pixel uv, a 0->1 by 0->1 uv, a -1->1 by -1->1 uv, or anything else. The\n    //only thing that matters is whether uv is within a box \"size\" units on a side.\n    //Check to make sure that uv lies within the extents of the character to be printed:\n\n    //font_uv_offset goes from -1.0->1.0 in both dimensions and is the position \n    //within the rendered character of uv.\n    vec2 font_uv_offset = (uv - char_pos) / size;\n    \n    if(font_uv_offset.x < -1.0 ||\n       font_uv_offset.x >  1.0 ||\n       font_uv_offset.y < -1.0 ||\n       font_uv_offset.y >  1.0) {\n        return vec4(0.0);\n    }\n    \n    \n    float row = float(15 - c/16);\n    float col = float(c%16);\n    \n    const float half_char_width = 1.0/32.0;\n    const float char_width = 1.0/16.0;\n    \n    vec2 font_uv = \n        vec2(half_char_width + char_width * col, half_char_width + char_width * row); \n    font_uv += font_uv_offset * half_char_width;\n    \n    return texture(font_channel, font_uv);\n}\n\nconst float log10 = log(10.0);\nint digits(int i) {\n    i = abs(i);\n    int retval = 0;\n    //TODO: this might be faster as a for loop with a break because of the way\n    //      for loops are unrolled? It would certainly be faster with a binary\n    //      search of ifs.\n    do {\n        retval++;\n        i /= 10;\n    } while(i > 0);\n    return retval;\n}\n\nvec4 print_int(sampler2D font_channel, int i, float size, vec2 pos, vec2 uv, \n               bool right, out int count) {\n    vec4 retval = vec4(0.0);\n    bool neg = i<0;\n    i = abs(i);\n    \n    if(!right) {\n        pos.x += size * (float(digits(i) - 1));\n        if(neg) {\n            pos.x += size;\n        }\n    }\n\n    count = 0;\n    do {\n        int c = 48 + i%10;\n        i /= 10;\n        retval += print_char(font_channel, c, size, pos, uv);\n        pos.x -= size;\n        count ++;\n    } while(i > 0);\n\n    if(neg) {\n        retval += print_char(font_channel, 45, size, pos, uv);\n        count++;\n    }\n    return retval;\n}\nvec4 print_int(sampler2D font_channel, int i, float size, vec2 pos, vec2 uv, \n               bool right) {\n    int _count;\n    return print_int(font_channel, i, size, pos, uv, right, _count);\n}\n\nvec4 print_float(sampler2D font_channel, float f, float size, vec2 pos, vec2 uv, \n                 bool right, int frac_digits, out int count) {\n    vec4 retval = vec4(0.0);\n    count = 0;\n    bool neg = false;\n\n    if(f < 0.0) {\n        neg = true;\n        f = abs(f);\n    }\n    \n    int frac_int = int(0.001 + fract(f) * pow(10.0, float(frac_digits)));\n    int mant_int = int(f);\n    \n    if(!right) {\n        int width = (neg?1:0) + digits(mant_int);\n        if(frac_digits > 0) {\n            width += 1 + frac_digits;\n        }\n        pos.x += size * float(width-1);\n\n        //retval += print_int(font_channel, digits(frac_int), size/2.0, pos + vec2(0.0, size), uv, true, tmp); \n    }\n    \n    \n    if(frac_digits > 0) {\n        retval += print_int(font_channel, frac_int, size, pos, uv, true, count);\n        pos.x -= size * float(count);\n        while(count < frac_digits) {\n            retval += print_char(font_channel, 48, size, pos, uv);\n            pos.x -= size;\n            count ++;\n        }\n        retval += print_char(font_channel, 46, size, pos, uv);\n        pos.x -= size;\n    }\n    int printed;\n    retval += print_int(font_channel, mant_int, size, pos, uv, true, printed);\n    count += printed;\n    if(neg) {\n        pos.x -= size * float(printed);\n        retval += print_char(font_channel, 45, size, pos, uv);\n        count ++;\n    }\n   \n    return retval;\n}\nvec4 print_float(sampler2D font_channel, float f, float size, vec2 pos, vec2 uv, \n                 bool right, int frac_digits) {\n    int _count;\n    return print_float(font_channel, f, size, pos, uv, right, frac_digits, _count);\n}\n\nfloat accumulating_left;\nvec2 accumulating_pos;\nfloat accumulating_size;\nvoid init_printing(vec2 pos, float size) {\n    accumulating_pos = pos;\n    accumulating_left = pos.x;\n    accumulating_size = size;\n}\n\nvoid newline() {\n    accumulating_pos.x = accumulating_left;\n    accumulating_pos.y -= accumulating_size*1.5;\n}\n\nconst float tab_width = 8.0;\nvoid tab() {\n    float x = accumulating_pos.x;\n    float printed = (x-accumulating_left)/accumulating_size;\n    float dx = tab_width - mod(printed, tab_width);\n    accumulating_pos.x += accumulating_size * dx;\n}\n\nvec4 print(sampler2D font_channel, int i, vec2 uv) {\n    int printed;\n    vec4 retval;\n    retval = print_int(font_channel, i, accumulating_size, accumulating_pos, uv, false, printed);\n    accumulating_pos.x += float(printed) * accumulating_size;\n    \n    return retval;\n}\n\nvec4 print(sampler2D font_channel, float f, vec2 uv, int frac_digits) {\n    int printed;\n    vec4 retval;\n    //return print_float(font_channel, f, size, pos, uv, right, frac_digits, _count);\n    retval = print_float(font_channel, f, accumulating_size, accumulating_pos, \n                         uv, false, frac_digits, printed);\n    accumulating_pos.x += float(printed+1) * accumulating_size;\n    \n    return retval;\n}\n\n#define DECL_PRINT_STRING(len) \\\nvec4 print(sampler2D font_channel, int c[len], vec2 uv) { \\\n    vec4 retval; \\\n    for(int i=0; i<len; i++) { \\\n        retval += print_char(font_channel, c[i], accumulating_size, accumulating_pos, uv); \\\n        accumulating_pos.x += accumulating_size; \\\n    } \\\n    return retval; \\\n}\n\nDECL_PRINT_STRING(5)\nDECL_PRINT_STRING(6)","name":"Common","description":"","type":"common"}]}