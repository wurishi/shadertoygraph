{"ver":"0.1","info":{"id":"fsfSDl","date":"1619405827","viewed":156,"name":"Fork GIT sewonist 428","username":"sewonist","description":"\"Generalized Impressionistic Texture\" ala Ken Musgrave: p 322 of Texturing And Modelling: A Procedural Approach.\nA painterly plasma.","likes":9,"published":1,"flags":0,"usePreview":0,"tags":["noise","fbm","multifractal"],"hasliked":0,"parentid":"Mdj3RV","parentname":"GIT"},"renderpass":[{"inputs":[],"outputs":[],"code":"//1. Go fullscreen\n//2. Take drugs now\n\n//iq noise fn\nfloat hash( float n )\n{\n    return fract(sin(n)*43758.5453);\n}\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\n    f = f*f*(3.0-2.0*f);\n    float n = p.x + p.y*57.0 + 113.0*p.z;\n    return mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                   mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\n               mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                   mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\n}\n\n//x3\nvec3 noise3( in vec3 x)\n{\n\treturn vec3( noise(x+vec3(123.456,.567,.37)),\n\t\t\t\tnoise(x+vec3(.11,47.43,19.17)),\n\t\t\t\tnoise(x) );\n}\n\n//http://dept-info.labri.fr/~schlick/DOC/gem2.ps.gz\nfloat bias(float x, float b) {\n\treturn  x/((1./b-2.)*(1.-x)+1.);\n}\n\nfloat gain(float x, float g) {\n\tfloat t = (1./g-2.)*(1.-(2.*x));\t\n\treturn x<0.5 ? (x/(t+1.)) : (t-x)/(t-1.);\n}\n\n\nmat3 rotation(float angle, vec3 axis)\n{\n    float s = sin(-angle);\n    float c = cos(-angle);\n    float oc = 1.0 - c;\n\tvec3 sa = axis * s;\n\tvec3 oca = axis * oc;\n    return mat3(\t\n\t\toca.x * axis + vec3(\tc,\t-sa.z,\tsa.y),\n\t\toca.y * axis + vec3( sa.z,\tc,\t\t-sa.x),\t\t\n\t\toca.z * axis + vec3(-sa.y,\tsa.x,\tc));\t\n}\n\nvec3 fbm(vec3 x, float H, float L, int oc)\n{\n\tvec3 v = vec3(0);\n\tfloat f = 1.;\n\tfor (int i=0; i<10; i++)\n\t{\n\t\tif (i >= oc) break;\n\t\tfloat w = pow(f,-H);\n\t\tv += noise3(x)*w;\n\t\tx *= L;\n\t\tf *= L;\n\t}\n\treturn v;\n}\n\nvec3 smf(vec3 x, float H, float L, int oc, float off)\n{\n\tvec3 v = vec3(1);\n\tfloat f = 1.;\n\tfor (int i=0; i<10; i++)\n\t{\n\t\tif (i >= oc) break;\n\t\tv *= off + f*(noise3(x)*2.-1.);\n\t\tf *= H;\n\t\tx *= L;\n\t}\n\treturn v;\t\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tuv.x *= iResolution.x / iResolution.y;\n\t\n\tfloat time = iTime * 1.276;\n\t\n\tfloat slow = time*0.002;\n\tuv *= 1. + .5*slow*sin(slow*10.);\n\t\n\tfloat ts = time*0.37;\n\t//float change = gain(fract(ts),0.0008)+floor(ts);\t//flick to a different view \n\tfloat change = 7.01;\n    \n\tvec3 p = vec3(uv*.2,slow+change);\t\t\t\t\t//coordinate + slight change over time\n\t\n\tvec3 axis = 4. * fbm(p, 0.5, 2., 8);\t\t\t\t//random fbm axis of rotation\n\t\n\tvec3 colorVec = 0.5 * 5. * fbm(p*0.3,0.5,2.,7);\t\t//random base color\n\tp += colorVec;\n\t\n//\tfloat mag = 4e5;\t//published, rather garish?\n\tfloat mag = 0.75e5; //still clips a bit\n//\tmag = mag * (1.+sin(2.*3.1415927*ts)*0.75);\n\tvec3 colorMod = mag * smf(p,0.7,2.,8,.2);\t\t\t//multifractal saturation\n\tcolorVec += colorMod;\n\t\n\tcolorVec = rotation(3.*length(axis)+slow*10.,normalize(axis))*colorVec;\n\t\n\tcolorVec *= 0.1;\n\t\t\t\n\tcolorVec = colorVec * (1. + length(colorVec));\t//tone it all up a bit\n\t\n\tcolorVec = pow(colorVec,vec3(1./2.2));\t\t//gamma\n\tfragColor = vec4(colorVec,1.0);\n}","name":"Image","description":"","type":"image"}]}