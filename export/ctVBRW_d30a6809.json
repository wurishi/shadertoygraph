{"ver":"0.1","info":{"id":"ctVBRW","date":"1701886027","viewed":51,"name":"ShadowRealm","username":"bolvan","description":"ðŸ˜µ","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["rotationnoise"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 palette( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d ) {\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nmat4 rotationX( in float angle ) {\n\treturn mat4(\t1.0,\t\t0,\t\t\t0,\t\t\t0,\n\t\t\t \t\t0, \tcos(angle),\t-sin(angle),\t\t0,\n\t\t\t\t\t0, \tsin(angle),\t cos(angle),\t\t0,\n\t\t\t\t\t0, \t\t\t0,\t\t\t  0, \t\t1);\n}\n\nmat4 rotationY( in float angle ) {\n\treturn mat4(\tcos(angle),\t\t0,\t\tsin(angle),\t0,\n\t\t\t \t\t\t\t0,\t\t1.0,\t\t\t 0,\t0,\n\t\t\t\t\t-sin(angle),\t0,\t\tcos(angle),\t0,\n\t\t\t\t\t\t\t0, \t\t0,\t\t\t\t0,\t1);\n}\n\nmat4 rotationZ( in float angle ) {\n\treturn mat4(\tcos(angle),\t\t-sin(angle),\t0,\t0,\n\t\t\t \t\tsin(angle),\t\tcos(angle),\t\t0,\t0,\n\t\t\t\t\t\t\t0,\t\t\t\t0,\t\t1,\t0,\n\t\t\t\t\t\t\t0,\t\t\t\t0,\t\t0,\t1);\n}\n\nfloat rand(vec3 p) {\n    return fract(sin(dot(p, vec3(12.345, 67.89, 412.12))) * 42123.45) * 2.0 - 1.0;\n}\n\nfloat valueNoise(vec3 p) {\n    vec3 u = floor(p);\n    vec3 v = fract(p);\n    vec3 s = smoothstep(0.0, 1.0, v);\n    \n    float a = rand(u);\n    float b = rand(u + vec3(1.0, 0.0, 0.0));\n    float c = rand(u + vec3(0.0, 1.0, 0.0));\n    float d = rand(u + vec3(1.0, 1.0, 0.0));\n    float e = rand(u + vec3(0.0, 0.0, 1.0));\n    float f = rand(u + vec3(1.0, 0.0, 1.0));\n    float g = rand(u + vec3(0.0, 1.0, 1.0));\n    float h = rand(u + vec3(1.0, 1.0, 1.0));\n    \n    return mix(mix(mix(a, b, s.x), mix(c, d, s.x), s.y),\n               mix(mix(e, f, s.x), mix(g, h, s.x), s.y),\n               s.z);\n}\n\nfloat surfaceNoise(vec3 p) {\n    vec3 q = p;\n    const int octaves = 10;\n    float weight = 0.5;\n    float ret = 0.0;\n\n    for(int i = 0; i < octaves; i++) {\n        ret += weight * valueNoise(q);\n        q = (rotationZ(iTime + length(q)) * vec4(q, .0)).xyz;\n        q *= 3.8;\n        weight *= .7;\n    }\n\n    return clamp(ret, 0., 1.);\n}\n\nfloat twistNoise(vec3 p) {\n    vec3 q = p;\n    const int octaves = 10;\n    vec3 hui = vec3(2.);\n    float weight = .5;\n    float ret = .0;\n\n    for(int i = 0; i < octaves; i++) {\n        ret += weight * valueNoise(p + hui);\n        hui *= 1.2;\n        weight *= .7;\n    }\n\n    return clamp(ret, 0., 1.);\n}\n\nfloat sdBox(vec3 p, vec3 b) {\n    vec3 q = abs(p) - b;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nvec2 map(vec2 st) {\n    vec2 ss = st / iResolution.xy;\n    ss.x *= iResolution.x / iResolution.y;\n    return ss;\n}\n\nfloat graveSd(vec3 p) {\n    float boxDistance = sdBox(p, vec3(.3, 2., .3));\n    float boxDistance2 = sdBox(p + vec3(0., .7, 0.), vec3(1.3, .3, .3));\n    return min(boxDistance, boxDistance2);\n}\n\nvec3 normalGraveSd(vec3 p) {\n    vec3 b0P = vec3(.3, 2., .3);\n    vec3 b1P = vec3(1.3, .3, .3);\n    vec3 b0C = p;\n    vec3 b1C = p + vec3(0., .7, 0.);\n\n    float boxDistance = sdBox(b0C, b0P);\n    float boxDistance2 = sdBox(b1C, b1P);\n\n    vec3 rP = boxDistance < boxDistance2 ? b0P : b1P;\n    vec3 rC = boxDistance < boxDistance2 ? b0C : b1C;\n\n    vec3 f = abs(rP - rC);\n    vec3 s = rP - rC;\n\n    float e = 0.;\n\n    if (f.x < f.y && f.x < f.z) {\n        return s.x < 0. ? vec3(1., e, e) : vec3(-1., e, e);\n    } else if (f.y < f.z && f.y < f.x) {\n        return s.y < 0. ? vec3(e, 1., e) : vec3(e, -1., e);\n    } else {\n        return s.z < 0. ? vec3(e, e, 1.) : vec3(e, e, -1.);\n    }\n\n    return f;\n}\n\nfloat hui1(float t) {\n    float x = 2. * fract(t) - 1.0;\n    float xxx = 1.0 - pow(abs(x), 3.0);\n\n    return xxx;\n}\n\nvec3 graveRaymarch(vec3 ro, vec3 rd) {\n    float distance = 0.;\n    float e = 0.00001;\n\n    for(int i = 0; i < 150; i++) {\n        vec3 nRd = (rotationX(surfaceNoise(rd)) * vec4(rd, 0.)).xyz;\n        nRd = rd;\n        vec3 p = ro + nRd * distance;\n        float ttt = iTime;\n        vec3 rotP = (rotationZ((valueNoise(2.01 * p + ttt))) * vec4(p, 0.)).xyz;\n        rotP = (rotationX(valueNoise(23.01 * rotP + ttt)) * vec4(rotP, 0.)).xyz;\n        rotP = (rotationY((valueNoise(13.1 * rotP + ttt))) * vec4(rotP, 0.)).xyz;\n        rotP = mix(rotP, p, hui1(iTime * 0.2 + 0.8));\n        float graveDistance = graveSd(rotP);\n\n        distance += graveDistance;\n        if (graveDistance < e) {\n            vec3 normal = normalize(normalGraveSd(rotP));\n            vec3 light = normalize(vec3(0.1765, 0.6549, 0.9725));\n            float lightness = abs(dot(light, normal));\n            float hui = clamp(lightness, 0.1, .7) + 0.5;\n            vec3 ssss = palette(iTime * 0.1, vec3(0.8, 0.5, 0.4), vec3(0.2, 0.4, 0.2), vec3(2.0, 1.0, 1.0), vec3(0.00, 0.25, 0.25));\n            vec3 color = ssss * hui;\n            vec3 col = mix(color, vec3(0.2353, 1.0, 0.0), 0.5 * surfaceNoise(p));\n            return col;\n        }\n        if (distance > 7.) {\n            break;\n        }\n    }\n\n    return vec3(0.098, 0.0784, 0.0784);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 orSt = fragCoord.xy;\n    vec2 st = fragCoord.xy/iResolution.xy;\n    st.x *= iResolution.y / iResolution.x;\n\n    const float pi = 3.14;\n    st.x *= iResolution.x/iResolution.y;\n    st -= vec2(0.5);\n    st *= 2.;\n\n    float aceleration = hui1(iTime * 0.2 + 0.5) - 0.5;\n    float aa = (3. * iTime + 2. * aceleration) * 0.4;\n    vec3 cPos = vec3(5. * cos(aa), 0., 5. * sin(aa));\n    st = map(orSt);\n\n    vec3 hui = vec3(st.x - 1.8 * iResolution.y / iResolution.x, st.y - 0.5, 1.);\n    vec3 rotHui = (rotationY(aa + pi / 2.) * vec4(hui, .0)).xyz;\n    vec3 dir = normalize(rotHui);\n    vec3 color = graveRaymarch(cPos, dir);\n\n    fragColor = vec4(color, 1.); \n}\n\n","name":"Image","description":"","type":"image"}]}