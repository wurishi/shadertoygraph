{"ver":"0.1","info":{"id":"ddKXWD","date":"1684166685","viewed":111,"name":"The Compact YCoCg Frame Buffer","username":"LVutner","description":"Demo","likes":1,"published":1,"flags":32,"usePreview":0,"tags":["thecompactycocgframebuffer"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":1,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Utility\n//emulation: webgl doesnt have gather\nvec4 textureGather(sampler2D s_tex, vec2 texcoord, int index)\n{\n    vec2 gather_offsets[4];\n    gather_offsets[0] = vec2(0.0, rcp_resolution.y);\n    gather_offsets[1] = vec2(rcp_resolution.x, rcp_resolution.y);\n    gather_offsets[2] = vec2(rcp_resolution.x, 0.0);\n    gather_offsets[3] = vec2(0.0, 0.0);\n                \n    vec4 out_gather = vec4(0.0);\n\n    //Set the fucking channel order\n    switch(index) \n    {\n        case 0: //R\n            out_gather.x = textureLod(s_tex, texcoord + gather_offsets[0], 0.0).x;\n            out_gather.y = textureLod(s_tex, texcoord + gather_offsets[1], 0.0).x;\n            out_gather.z = textureLod(s_tex, texcoord + gather_offsets[2], 0.0).x;\n            out_gather.w = textureLod(s_tex, texcoord + gather_offsets[3], 0.0).x;\n            break;\n        case 1: //G\n            out_gather.x = textureLod(s_tex, texcoord + gather_offsets[0], 0.0).y;\n            out_gather.y = textureLod(s_tex, texcoord + gather_offsets[1], 0.0).y;\n            out_gather.z = textureLod(s_tex, texcoord + gather_offsets[2], 0.0).y;\n            out_gather.w = textureLod(s_tex, texcoord + gather_offsets[3], 0.0).y;\n            break;\n        case 2: //B\n            out_gather.x = textureLod(s_tex, texcoord + gather_offsets[0], 0.0).z;\n            out_gather.y = textureLod(s_tex, texcoord + gather_offsets[1], 0.0).z;\n            out_gather.z = textureLod(s_tex, texcoord + gather_offsets[2], 0.0).z;\n            out_gather.w = textureLod(s_tex, texcoord + gather_offsets[3], 0.0).z;\n            break;\n        case 3: //A\n            out_gather.x = textureLod(s_tex, texcoord + gather_offsets[0], 0.0).w;\n            out_gather.y = textureLod(s_tex, texcoord + gather_offsets[1], 0.0).w;\n            out_gather.z = textureLod(s_tex, texcoord + gather_offsets[2], 0.0).w;\n            out_gather.w = textureLod(s_tex, texcoord + gather_offsets[3], 0.0).w;\n            break;\n    }\n    return out_gather;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 pixel_position = fragCoord.xy;\n    vec2 texcoord = pixel_position * rcp_resolution;\n\n\t//Sample center and neighbor (cross)\n    vec3 offset = vec3(1.0, -1.0, 0.0);\n    vec2 ycocgdata[5];\n\n#ifdef WEBGL_DOESNT_SUCK\n    vec4 lumaCenter = textureGather(iChannel0, texcoord, 0);\n    vec4 chromaCenter = textureGather(iChannel0, texcoord, 1); \n    vec4 lumaNeighbor = textureGather(iChannel0, texcoord + offset.yy * rcp_resolution, 0);\n    vec4 chromaNeighbor = textureGather(iChannel0, texcoord + offset.yy * rcp_resolution, 1); \n\n    ycocgdata[0] = vec2(lumaNeighbor.y, chromaNeighbor.y);\n    ycocgdata[1] = vec2(lumaNeighbor.z, chromaNeighbor.z);\n\tycocgdata[3] = vec2(lumaCenter.z, chromaCenter.z);\n\tycocgdata[4] = vec2(lumaCenter.x, chromaCenter.x);\n#else\n    ycocgdata[0] = texture(iChannel0, texcoord).xy;\n    ycocgdata[1] = texture(iChannel0, texcoord + vec2(offset.zy) * rcp_resolution).xy;\n\tycocgdata[2] = texture(iChannel0, texcoord + vec2(offset.yz) * rcp_resolution).xy;\n\tycocgdata[3] = texture(iChannel0, texcoord + vec2(offset.xz) * rcp_resolution).xy;\n\tycocgdata[4] = texture(iChannel0, texcoord + vec2(offset.zx) * rcp_resolution).xy;\n#endif\n\n\t//Reconstruction\n    vec3 unpacked_color;\n    unpacked_color.xy = ycocgdata[0].xy;\n    unpacked_color.z = filterd(\n        ycocgdata[0].x, \n        vec4(ycocgdata[1].x, ycocgdata[2].x, ycocgdata[3].x, ycocgdata[4].x),\n        vec4(ycocgdata[1].y, ycocgdata[2].y, ycocgdata[3].y, ycocgdata[4].y));\n\n\t//Decode\n    uvec2 interleaved_position = uvec2((pixel_position.xy)) % 2u;\n    bool checkerboard = (interleaved_position.x == interleaved_position.y);\n    unpacked_color.rgb = checkerboard ? unpacked_color.xyz : unpacked_color.xzy;\n\n    //Debug\n    vec3 rgb_color = texcoord.x < 0.5 ? texture(iChannel1, texcoord).xyz : YCoCg2RGB(unpacked_color);\n\n    // Output to screen\n    fragColor = vec4(rgb_color, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"vec2 pack_color(vec3 rgb_color, vec2 pixel_position)\n{\n    //RGB to YCoCg\n    vec3 ycocg_color = RGB2YCoCg(rgb_color);\n\n\t//Encode B\n    uvec2 interleaved_position = uvec2(pixel_position.xy) % 2u;\n    bool checkerboard = (interleaved_position.x == interleaved_position.y);\n    return checkerboard ? ycocg_color.xy : ycocg_color.xz;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 pixel_position = fragCoord.xy;\n    vec2 texcoord = pixel_position * rcp_resolution;\n\n    //Sample RGB color\n    vec3 rgb_color = texture(iChannel0, texcoord).xyz;\n\n    //Encode\n    vec2 encoded_color = pack_color(rgb_color, pixel_position);\n\n    //Output\n    fragColor = vec4(encoded_color, 0.0, 1.0);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define rcp_resolution (1.0/iResolution.xy)\n#define WEBGL_DOESNT_SUCK\n\nvec3 RGB2YCoCg(vec3 c)\n{\n    vec2 c2c4 = vec2(0.5, 0.25);\n\treturn vec3(dot(c.xyz, vec3(c2c4.yxy)), dot(c.xz, vec2(c2c4.x, -c2c4.x)), dot(c.xzy, vec3(-c2c4.yy, c2c4.x)));\n}\n\nvec3 YCoCg2RGB(vec3 c)\n{\n\treturn clamp(vec3(c.x + c.y - c.z, c.x + c.z, c.x - c.y - c.z), 0.0, 1.0);\n}\n\n//Edge-directed filter from \"The Compact YCoCg Frame Buffer\" paper\nfloat filterd(float center_luminance, vec4 neighboor_luminance, vec4 neighboor_chrominance)\n{\n    vec4 w = 1.0 - step(30.0 / 255.0, abs(neighboor_luminance - center_luminance));\n    float W = w.x + w.y + w.z + w.w;\n\n    //handle the special case where all the weights are zero\n    w.x = (W == 0.0) ? 1.0 : w.x; \n\tW = (W == 0.0) ? 1.0 : W;\n    return dot(neighboor_chrominance, w) * (1.0 / W);\n}\n","name":"Common","description":"","type":"common"}]}