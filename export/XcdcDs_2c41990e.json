{"ver":"0.1","info":{"id":"XcdcDs","date":"1731355954","viewed":32,"name":"TP Informatique graphique 24/25","username":"abdelkarimbencheikh","description":"TP d'informatique graphique partie synthèse d'image\nBENCHEIKH Abdelkarim","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["ucbl","mif02"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Modeling - 2024.09.15\n// Eric Galin\n\nstruct Ray{\n    vec3 o;// Origin\n    vec3 d;// Direction\n};\n\nstruct Val {\n  float v; // Signed distance\n  int c; // Cost\n};\n\n// Compute point on ray\n// ray : The ray\n//   t : Distance\nvec3 Point(Ray ray,float t)\n{\n    return ray.o+t*ray.d;\n}\n\n// Random direction in a hemisphere\n// seed : Integer seed, from 0 to N\n//    n : Direction of the hemisphere\nvec3 Hemisphere(int seed,vec3 n)\n{\n    float a=fract(sin(176.19*float(seed)));// Uniform randoms\n    float b=fract(sin(164.19*float(seed)));\n    \n    float u=2.*3.1415*a;// Random angle\n    float v=acos(2.*b-1.);// Arccosine distribution to compensate at poles\n    \n    vec3 d=vec3(cos(u)*cos(v),sin(u)*cos(v),sin(v));// Direction\n    if(dot(d,n)<0.){d=-d;}// Hemisphere\n    \n    return d;\n}\n\n// Camera -------------------------------------------------------------------------------\n\n// Rotation matrix around z axis\n// a : Angle\nmat3 Rz(float a)\n{\n  float sa=sin(a);float ca=cos(a);\n  return mat3(ca,sa,0.,-sa,ca,0.,0.,0.,1.);\n}\n\n// Compute the ray\n//      m : Mouse position\n//      p : Pixel\nRay CreateRay(vec2 m,vec2 p)\n{\n  float a=3.*3.14*m.x;\n  float le=3.5;\n  \n  // Origin\n  vec3 ro=vec3(37.,0.,15.);\n  ro*=Rz(a);\n  \n  // Target point\n  vec3 ta=vec3(0.,0.,1.);\n  \n  // Orthonormal frame\n  vec3 w=normalize(ta-ro);\n  vec3 u=normalize(cross(w,vec3(0.,0.,1.)));\n  vec3 v=normalize(cross(u,w));\n  vec3 rd=normalize(p.x*u+p.y*v+le*w);\n  return Ray(ro,rd);\n}\n\nVal applyNoise(vec3 p, Val obj, float freq, float amp) {\n    obj.v += sin(p.x * amp) * sin(p.y * amp) * sin(p.z * amp) * freq;\n    return obj;\n}\n\nVal addBumps(vec3 p, Val obj) {\n    return applyNoise(p, obj, .1, 2.1);\n}\n\n\n// Primitives -------------------------------------------------------------------------------\n\n// Sphere\n// p : point\n// c : center of skeleton\n// r : radius\nVal Sphere(vec3 p,vec3 c,float r)\n{\n    float dist = length(p - c) - r;\n    return Val(dist, 1);\n}\n\n// Boite\n// p : point\n// b : vecteur des dimensions de la boite (longeur, largeur, hauteur)\nVal Box(vec3 p, vec3 b)\n{\n    vec3 q = abs(p ) - b;\n    return Val((length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0)), 1);\n}\n// Tore\n// p : point\n// t : vecteur du rayon du tore\nVal Tore( vec3 p, vec2 t)\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return Val(length(q)-t.y, 1);\n}\n// Ellipsoïde\n// p : point\n// r : vecteur de rayon de l'ellipsoide\nVal Ellipsoide(vec3 p, vec3 r)\n{\n  float k0 = length(p/r);\n  float k1 = length(p/(r*r));\n  return Val(k0*(k0-1.0)/k1, 1);\n}\n// Cylindre\n// p : point\n// h : hauteur du cylindre\n// r : rayon du cylindre\nVal Cylindre( vec3 p, float h, float r )\n{\n  vec2 d = abs(vec2(length(p.xy),p.z)) - vec2(r,h);\n  return Val(min(max(d.x,d.y),0.0) + length(max(d,0.0)),1 );\n}\n\n// Plane \n// p : point\n// n : Normal of plane\n// o : Point on plane\nVal Plane(vec3 p, vec3 n, vec3 o)\n{\n    return Val(dot((p-o),n),1);\n}\n\n// Operators\n\n// Union\n// a,b : field function of left and right sub-trees\nVal Union(Val a,Val b)\n{\n  return Val(min(a.v,b.v),a.c+b.c+1);\n}\n// Intersection\nVal Intersection(Val a, Val b) {\n    return Val(max(a.v, b.v), a.c + b.c + 1);\n}\n// Difference\nVal Difference(Val a, Val b) {\n    return Val(max(-a.v, b.v), a.c + b.c + 1);\n}\n\n// Opérateur de transformation affine\n// Translation\n// p : point\n// t : vecteur de translation\nvec3 translate(vec3 p, vec3 t) {\n    return p - t;\n}\n// Scaling\n// p : point\n// s : facteur de scaling\nvec3 scale(vec3 p, float s) {\n    return p / s;\n}\n// Rotation\nmat2 rot2d(float angle) {\n    float s = sin(angle);\n    float c = cos(angle);\n    return mat2(c, -s, s, c);\n}\n\n// Custom objects\nVal createHammer(vec3 p) {\n  p.yz *= rot2d(-.45);\n  Val hammer = Cylindre(p, 3., 0.8);\n  vec3 rotated_p = p;\n  rotated_p.yz *= rot2d(.45);\n  Val box = Box(p + vec3(0., 0.2, -2.9), vec3(1., 2., 0.8));\n  Val box2 = Box(rotated_p + vec3(0., 0.6, -4.6), vec3(1.2));\n  Val cylindre2 = Cylindre(p + vec3(0., 0., +2.6), 0.9, 0.9);\n  hammer = Union(cylindre2, hammer);\n  hammer = Union(hammer, box);\n  hammer = Difference(box2, hammer);\n\n  return hammer;\n}\n\nVal createRobotHead(vec3 p) {\n  Val scene = Sphere(p, vec3(0.), 4.);\n  Val ellipsoide = Ellipsoide(p, vec3(2., 4.5, 2.));\n  Val tore = Tore(p + vec3(-0., 3., 0.), vec2(1., 1.));\n  Val tore2 = Tore(p + vec3(-0., -3., 0.), vec2(1., 1.));\n  Val cylindre1 = Cylindre(p + vec3(0., 2., -4.), 1.6, 0.2);\n  Val cylindre2 = Cylindre(p + vec3(0., -2., -4.), 1.6, 0.2);\n  Val sphere = Sphere(p, vec3( 0., 2., 5.6), 0.4);\n  Val sphere2 = Sphere(p, vec3( 0., -2., 5.6), 0.4);\n  scene = Union(scene, ellipsoide);\n  scene = Union(scene, tore);\n  scene = Union(scene, tore2);\n  scene = Union(scene, cylindre1);\n  scene = Union(scene, cylindre2);\n  scene = Union(scene, sphere);\n  scene = Union(scene, sphere2);\n\n  return scene;\n}\n// Potential field of the object\n// p : point\nVal object(vec3 p)\n{\n  Val cylindre1 = Cylindre(p + vec3(+6, 0., 1.), 3., 2.);\n  Val cylindre2 = Cylindre(p + vec3(+6, -5., 1.), 3., 2.);\n  \n  Val v = Plane(p,vec3(0.,0.,1.),vec3(0.0,0.0,-4.0));\n  v = Union(cylindre1, v);\n  v = Union(v, cylindre2);\n  Val tore = Tore(p + vec3(0., 0., 1.), vec2(2, 1));\n  Val tore2 = Tore(p + vec3(0., -5., 1.), vec2(2, 1));\n  tore = Union(tore, tore2);\n  Val ellipsoide = Ellipsoide(p + vec3(-7., 0., 1.), vec3(3., 2., 2.));\n  Val ellipsoide2 = Ellipsoide(p + vec3(-7., -5., 1.), vec3(3., 2., 2.));\n  ellipsoide = Union(ellipsoide, ellipsoide2);\n  Val boite = Box(p + vec3(+12., 0., 0.5), vec3(2., 2., 2.));\n  Val boite2 = Box(p + vec3(+12., -5., 0.5), vec3(2., 2., 2.));\n  boite = Union(boite, boite2);\n  Val hammer = createHammer(p + vec3(-12., 0., 0.));\n  Val hammer2 = createHammer(p + vec3(-12., -5., 0.));\n  hammer = Union(hammer, hammer2);\n  v = Union(v, hammer);\n  v = Union(v, tore);\n  v = Union(v, boite);\n  v = Union(v, ellipsoide);\n  vec3 rotated_p = p;\n  rotated_p.xz *= rot2d(45.);\n\n  v = Union(v, boite);\n  return v;\n}\n\n// Analysis of the scalar field -----------------------------------------------------------------\n\nconst int Steps=200;// Number of steps\nconst float Epsilon=.01;// Marching epsilon\n\n// Object normal\n// p : point\nvec3 ObjectNormal(vec3 p)\n{\n  const float eps=.001;\n  vec3 n;\n  Val val=object(p);\n  float v=val.v;\n  n.x=object(vec3(p.x+eps,p.y,p.z)).v-v;\n  n.y=object(vec3(p.x,p.y+eps,p.z)).v-v;\n  n.z=object(vec3(p.x,p.y,p.z+eps)).v-v;\n  return normalize(n);\n}\n\n// Trace ray using ray marching\n// ray : The ray\n//   e : Maximum distance\n//   h : hit\n//   s : Number of steps\n//   c : cost\nbool SphereTrace(Ray ray,float e,out float t,out int s,out int c)\n{\n  bool h=false;\n  \n  // Start at the origin\n  t=0.0;\n  c=0;\n  \n  for(int i=0;i<Steps;i++)\n  {\n    s=i;\n    vec3 p=Point(ray,t);\n    Val val=object(p);\n    float v=val.v;\n    c+=val.c;\n    // Hit object\n    if(v<0.)\n    {\n      h=true;\n      break;\n    }\n    // Move along ray\n    t+=max(Epsilon,v);\n    // Escape marched too far away\n    if(t>e)\n    {\n      break;\n    }\n  }\n  return h;\n}\n\n\n// Lighting -------------------------------------------------------------------------------\n\n// Background color\n// ray : Ray \nvec3 background(Ray ray)\n{\n  return mix(vec3(.45,.55,.99),vec3(.65,.69,.99),ray.d.z*.5+.5);\n}\n\n// Shadowing\n// p : Point\n// n : Normal\n// l : Light direction\nfloat softshadow( in vec3 ro, in vec3 rd, float mint, float maxt, float k )\n{\n    float res = 1.0;\n    float t = mint;\n    for( int i=0; i<256 && t<maxt; i++ )\n    {\n        float h = object(ro + rd*t).v;\n        if( h<0.001 )\n            return 0.0;\n        res = min( res, k*h/t );\n        t += h;\n    }\n    return res;\n}\n\nvec3 PhongLight(vec3 p, vec3 n, Ray eye, vec3 lightDir){\n    vec3 lightSource = normalize(lightDir - p);\n    vec3 lightning = vec3(0.0, 0.0, 0.0); \n    vec3 modelColor = vec3(1.0, 1.0, 1.0);\n    modelColor = vec3(0.75);\n    vec3 lightColor = vec3(1.0, 1.0, 1.0); \n\n    // Ambient\n    float ambient = 0.20;\n\n    // Diffuse\n    float diffuseStrength = max(0.0, dot(lightSource, n));\n    vec3 diffuse = diffuseStrength * lightColor;\n\n    // Specular\n    vec3 viewSource = normalize(eye.d);\n    vec3 reflectSource = normalize(reflect(lightSource, n));\n\n    vec3 halfwayVector = normalize(viewSource + reflectSource);\n    float specularStrength = max(0., dot(halfwayVector, reflectSource));\n    specularStrength = pow(specularStrength, 64.);\n    vec3 specular = specularStrength * lightColor;\n    \n    float shadow= softshadow(p + n*0.3, lightSource, 1., 50., 32.);\n\n    lightning = ambient * 1. + shadow*(diffuse * 1.0 + specular* 1.0);\n    \n    vec3 color = lightning * modelColor;\n    return color;\n}\n\n// Shading according to the number of steps in sphere tracing\n// n : Number of steps\nvec3 ShadeSteps(int n,int m)\n{\n  float t=float(n)/(float(m));\n  return.5+mix(vec3(.05,.05,.5),vec3(.65,.39,.65),t);\n}\n\n// Image\nvoid mainImage(out vec4 color,in vec2 pxy)\n{  \n  // Convert pixel coordinates\n    vec2 pixel=(-iResolution.xy+2.*pxy)/iResolution.y;\n\n    // Mouse\n    vec2 m=iMouse.xy/iResolution.xy;\n    \n    // Camera\n    Ray ray=CreateRay(m,pixel);\n    ray.o += vec3(0., 0., -1.);\n    // Trace ray\n    \n    // Hit and number of steps\n    float t=0.0;\n    int s=0;\n    int c;\n    bool hit=SphereTrace(ray,100.,t,s,c);\n    \n    // Shade background\n    vec3 rgb=background(ray);\n    rgb=vec3(0.);\n    \n    \n    if(hit)\n    {\n      // Position\n      vec3 p=Point(ray,t);\n      \n      // Compute normal\n      vec3 n=ObjectNormal(p);\n      \n      // Shade object with light\n      rgb = PhongLight(p, n, ray, vec3(20.,20.,14.));\n    }\n    \n    // Uncomment this line to shade image with false colors representing the number of steps\n    // rgb=ShadeSteps(s,Steps);\n    \n    // Uncomment this line to shade cost\n    // rgb=ShadeSteps(c,500);\n    color=vec4(rgb,1.);\n}\n\n","name":"Image","description":"","type":"image"}]}