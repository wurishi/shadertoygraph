{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"precision highp float;\nprecision highp int; \n\nconst float PI = 3.14159265359;\n\nint T(vec3 o,vec3 d, out float t, out vec3 n){\n\n    t=10000.;\n    int m=0;\n    float p=-o.z/d.z;\n    if(.01<p)\n    {\n      t=p;\n      n=vec3(0,0,1);\n      m=1;\n    }\n\n    //The world is encoded in G, with 9 lines and 19 columns\n\n    //     for(i k=19;k--;)  //For each columns of objects\n    //   for(i j=9;j--;)   //For each line on that columns\n\n    // if(G[j]&1<<k){ //For this line j, is there a sphere at column i ?\n\n    // There is a sphere but does the ray hits it ?\n\t\n\n\t\n\tconst int numSpheres = 3;\n\tvec2 spheres[numSpheres];\n\tfor (int i = 0; i<numSpheres; i++)\n\t{\n\t\tspheres[i].x = 8.*float(i);\t\n\t\tspheres[i].y = 3.*sin(iTime+float(i)*PI/3.);\n\t}\n\t\t\n\tfor (int i = 0;i<numSpheres; i++)\n\t{\n   \t    vec3 p2=o+vec3(-spheres[i].x,0.,-spheres[i].y-4.);\n    \tfloat b=dot(p2,d);\n        float c= dot(p2,p2) - 1.;\n        float q = b*b-c;\n\n        //Does the ray hit the sphere ?\n        if(q>0.){\n        //It does, compute the distance camera-sphere\n        float s=-b-sqrt(q);\n\n        if(s<t && s>.01)\n        {\n        // So far this is the minimum distance, save it. And also\n          // compute the bouncing ray vector into 'n'  \n            t=s,\n            n=normalize(p2+d*t),\n            m=2;\n        }\n      }\n    }\n    return m;\n}\n\nconst float PI_2_DIV_3 = 1.0471975512;\n\nvec3 S(in vec3 o,in vec3 d, vec2 uv)\n{\n  float t;\n  vec3 n;\n\n  vec3 cumulated_color = vec3(0.); \n\n  //Search for an intersection ray Vs World.\n  int m=T(o,d,t,n);\n  float attenuationFactor = 1.0;\n  \n  float f = 0.;\t\n  for(int i = 0; i<3; i++) //Max recursivity - 3 bounces  \n  {\n    if(0==m) // m==0\n    {\n      return ( cumulated_color + attenuationFactor * vec3(.7,.6,1)*pow(1.-d.z,4.));\n    }\n\n    vec3 h = o+d*t;                    // h = intersection coordinate\n    vec3 l = normalize(vec3(9.,9.,16.)+h*-1.);  // 'l' = direction to light (with random delta for soft-shadows).\n    vec3 r = d+n*(dot(n,d)*-2.);               // r = The half-vector\n\n    //Calculated the lambertian factor\n    float b=dot(l,n);\n\n    //Calculate illumination factor (lambertian coefficient > 0 or in shadow)?\n    if(b<0.||T(h,l,t,n) !=0)\n      b=0.;\n\n    // Calculate the color 'p' with diffuse and specular component \n    float p= 0.;\n    if (b!=0.)\n    {\n      p = pow(dot(l,r),99.);\n    }\n\n    if(m==1){   \n\n      h=h*.2; //No sphere was hit and the ray was going downward: Generate a floor color\n      float cond =  (float(ceil(h.x + iTime)+ceil(h.y+iTime)));\n      //if odd\n      if (fract(cond/2.) == 0.)\n        return (cumulated_color+attenuationFactor *vec3(3.,1.,1.)*(b*0.2+0.1));\n      else\n        return (cumulated_color+attenuationFactor*vec3(3.,3.,3.)*(b*0.2+0.1));\n    }\n    cumulated_color += attenuationFactor*vec3(p);\n    attenuationFactor *= 0.5;\n    o = h;\n    d = r;\n    m=T(h,r,t,n);\n\tf++;\n  }\n  return vec3(0.0);\n}\n\nconst float inv_256 = 0.00390625;\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    vec2 uv = fragCoord.xy / iResolution.xy; //some optimization here to do\n    vec3 g=normalize(vec3(-6.,-16.,0.));       // Camera direction\n    vec3  a=normalize(cross(g,vec3(0.,0.,1.)))*.002; // Camera up vector...Seem Z is pointing up :/ WTF !\n    vec3  b=normalize(cross(a,g))*.002;        // The right vector, obtained via traditional cross-product\n    vec3  c=(a+b)*-256.+g;       \n    vec3 p= vec3(13,13,13);     // Default pixel color is almost pitch black\n    highp vec3 t=a*0.5*99.+b*0.5*99.; \n    p=64.*S(vec3(17.,16.,8.)+t,normalize(t*-1.+(a*(fragCoord.x)+b*(fragCoord.y)+c)*16.), uv)*3.5+p; // +p for color accumulation\t\n    fragColor = vec4(p * inv_256,1.0);  \n    \n} ","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"MdX3Ws","date":"1381581840","viewed":576,"name":"Basic Business Card Ray-tracer ","username":"benito_luna","description":"Full version here : https://www.shadertoy.com/view/MsX3Wf\nBut there are some issues on windows when unrolling the loops.\nI just throw 1 ray from the camera for each pixel. Strong aliasing appears and soft shadows are lost\n","likes":9,"published":1,"flags":0,"usePreview":0,"tags":["raytracer"],"hasliked":0,"parentid":"","parentname":""}}