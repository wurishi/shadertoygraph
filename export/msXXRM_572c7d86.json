{"ver":"0.1","info":{"id":"msXXRM","date":"1668624677","viewed":177,"name":"Poste de Double Sens","username":"panna_pudi","description":"tomato","likes":16,"published":1,"flags":32,"usePreview":0,"tags":["3d","fbm"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec3 col = texture(iChannel2, uv).rgb;\n    col = pow(col, vec3(0.4545));\n\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"const float PI = acos(-1.);\nconst float TAU = 2. * PI;\n\nvec2 _min(vec2 a, vec2 b) {\n    if (a.x < b.x)\n        return a;\n    return b;\n}\n\nvec3 erot(vec3 p, vec3 ax, float a) {\n    return mix(dot(ax, p) * ax, p, cos(a)) + cross(ax, p) * sin(a);\n}\n\nmat3 orto_basis(vec3 z) {\n    z = normalize(z);\n    vec3 up = abs(z.y) > 0.999 ? vec3(0, 0, 1) : vec3(0, 1, 0);\n    vec3 x = normalize(cross(up, z));\n    return mat3(x, cross(z, x), z);\n}\n\nfloat time;\nfloat sd_box(vec3 p, vec3 h) {\n    p = abs(p) - h;\n    return length(max(p, 0.)) + min(0., max(p.x, max(p.y, p.z)));\n}\n\nmat2 rot(float angle) {\n    return mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n}\n\nfloat noise(vec3 pos) {\n    float wav = 0.0;\n    vec3 dir = vec3(1, 1, -1.5);\n    float amp = 1.0;\n    float freq = 0.5;\n    mat3 rotm = orto_basis(vec3(1, 0, -2));\n    int iter = 11;\n    for (int i = 0; i < iter; i++) {\n        dir *= rotm;\n        float x = dot(dir, pos) * freq;\n        float wave = exp(sin(x) - 1.0) * amp;\n        wav += wave;\n        freq *= 1.30;\n        pos -= dir * wave * .2 * cos(x);\n        amp *= 0.9;\n    }\n    float wavSum = -(pow(0.9, float(iter)) - 1.) * 4.5;\n    return wav / wavSum;\n}\n\nvec2 map(vec3 p) {\n    vec3 pp = p;\n    p.x = abs(p.x) - .9;\n    p.zx *= rot(1.95);\n\n    float d = length(p) - 0.5;\n    float t = cos(time * TAU);\n\n    float small_rad = 0.1, big_rad = 0.5;\n    float ring = length(p.xy) - big_rad;\n    // p.z += sin(ring);\n    vec2 tube = vec2(ring, p.z);\n\n    float angle = atan(p.y, p.x);\n\n    tube *= rot(time * TAU * 2.);\n\n    vec2 g = vec2(cos(angle), sin(angle));\n    float noise = noise(vec3(g * 4., tube.x * 6.) * sign(p.x));\n\n    d = length(tube) - small_rad;\n\n    d -= noise * 0.10;\n    d -= 0.07;\n    \n    pp = erot(pp, normalize(vec3(3, -1, 2) * (t * 0.5 + 0.5 + 0.001)),\n              (time * TAU) * 8.);\n    return _min(vec2(d, 1.), vec2(sd_box(pp, vec3(0.15)) - 0.001, 2.));\n}\n\nvec3 norm(vec3 p, float s) {\n    vec2 off = vec2(s, 0);\n    return normalize(\n        vec3(map(p + off.xyy).x, map(p + off.yxy).x, map(p + off.yyx).x) -\n        vec3(map(p - off.xyy).x, map(p - off.yxy).x, map(p - off.yyx).x));\n}\n\nvec2 trace(vec3 ro, vec3 rd) {\n    float t = 0.001;\n    for (int i = 0; i < 50; i++) {\n        vec3 pos = ro + rd * t;\n        vec2 d = map(pos);\n        if (abs(d.x) < 0.001) {\n            return vec2(t, d.y);\n        }\n        t += d.x;\n        if (t > 10.)\n            break;\n    }\n    return vec2(-1.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = (fragCoord - iResolution.xy * 0.5) / iResolution.y;\n\n    vec3 col = vec3(0.);\n    float duration = 7.;\n    time = mod(iTime * 0.75, duration) / duration;\n\n    vec3 rd = normalize(vec3(0., 0., 1.));\n    vec3 ro = vec3(0., 0., -1.0) + vec3(uv * 1.2, 0.);\n\n    vec2 t = trace(ro, rd);\n    float fblend = 0.;\n\n    if (t.y > 0.) {\n        vec3 pos = ro + rd * t.x;\n        vec3 nor = norm(pos, 0.001);\n        fblend = 1. - smoothstep(-.2, .2, abs(dot(rd, nor)) - .1);\n\n        if (t.y > 1.5) {\n            col = .7 + .6 * cos(vec3(6, 2, 4) * 5.3 + cos(time * TAU * 10.) +\n                                nor.z * 3.);\n        }\n\n        float edge = 0.01 * clamp(80.0 / iResolution.y, 0.5, 1.2);\n        float edgeAmount = length(norm(pos, 0.001) - norm(pos, edge));\n        if (t.y > 1.5) {\n            col = mix(col, vec3(0.), smoothstep(-0.2, 0.2, edgeAmount));\n        } else {\n            col += smoothstep(0.10, 0.4, edgeAmount) * 1.;\n            float fres =\n                clamp((pow(1. - max(0.0, dot(-nor, rd)), 5.0)), 0.0, 1.0);\n            col += vec3(0.5) * fres;\n            col *= dot(nor, rd) * .5 + 0.55;\n        }\n    }\n\n    vec4 precol = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    float blend = (iFrame < 2) ? 1. : 1./(1. + fblend * 10.); \n    fragColor = mix(precol, vec4(clamp(col, 0., 1.), 1), blend);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"/**\n* Creative Commons CC0 1.0 Universal (CC-0)\n*\n* A basic TAA implementation based on the variance clipping technique by Marco Salvi (Nvidia).\n*\n*/\n\n#define TEXTURE_CURRENT iChannel0\n#define TEXTURE_PREV iChannel1\n\nconst ivec2 offsets[8u] = ivec2[]\n(\n    ivec2(-1,-1), ivec2(-1, 1), \n\tivec2(1, -1), ivec2(1, 1), \n\tivec2(1, 0),  ivec2(0, -1), \n\tivec2(0, 1),  ivec2(-1, 0)\n);\n\nconst float gaussian[8u] = float[]\n(\n    .0625, .0625,\n    .0625, .0625,\n    .125,  .125,\n    .125,  .125\n);\n\nvec3 RGBToYCoCg(vec3 RGB)\n{\n    float Y = dot(RGB, vec3(1, 2,  1))  * .25;\n    float Co= dot(RGB, vec3(2, 0, -2))  * .25 + (.5 * 256./255.);\n    float Cg= dot(RGB, vec3(-1, 2, -1)) * .25 + (.5 * 256./255.);\n    return vec3(Y, Co, Cg) * (1. / (1. + Y)); // tonemap\n}\n\nvec3 YCoCgToRGB(vec3 YCoCg)\n{\n    YCoCg *= 1. / (1. - YCoCg.x); // tonemap\n\tfloat Y= YCoCg.x;\n\tfloat Co= YCoCg.y - (.5 * 256. / 255.);\n\tfloat Cg= YCoCg.z - (.5 * 256. / 255.);\n\tfloat R= Y + Co - Cg;\n\tfloat G= Y + Cg;\n\tfloat B= Y - Co - Cg;\n\treturn vec3(R, G, B);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 tuv = 2.*(fragCoord / iResolution.y-0.5*iResolution.xy/iResolution.y);\n    if(abs(tuv.x)<0.68){fragColor=textureLod(iChannel0,uv,0.);return;}\n    vec3 currentBuffer = RGBToYCoCg(textureLod(TEXTURE_CURRENT, uv, 0.).rgb);\n    vec3 historyBuffer = RGBToYCoCg(textureLod(TEXTURE_PREV, uv, 0.).rgb);\n\n    vec3 mean = currentBuffer;\n    vec3 variance = currentBuffer * currentBuffer;\n    vec3 filtered = currentBuffer * .25;\n    \n    // Marco Salvi's Implementation (by Chris Wyman)\n    for(int i = 0; i < 8; i++)\n    {\n        vec3 neighborTexel = RGBToYCoCg(texelFetch(TEXTURE_CURRENT, ivec2(fragCoord.xy) + offsets[i], 0).rgb);\n        mean += neighborTexel;\n        variance += neighborTexel * neighborTexel;\n        filtered += neighborTexel * gaussian[i];\n    }\n    \n    mean /= 9.;\n    variance /= 9.;\n    const float stDevMultiplier = 1.5;\n\tvec3 sigma = sqrt(abs(variance - mean * mean));\n\tvec3 colorMin = min(filtered, mean - stDevMultiplier * sigma);\n\tvec3 colorMax = max(filtered, mean + stDevMultiplier * sigma);\n    \n    historyBuffer = clamp(historyBuffer, colorMin, colorMax);\n    \n    vec3 outColor = mix(historyBuffer, filtered, .05);\n\n\tfragColor = vec4(YCoCgToRGB(outColor), 1.);\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"//2 channel motion blur\n\n#define SAMPLES_LOCK 18\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 tuv = 2.*(fragCoord / iResolution.y-0.5*iResolution.xy/iResolution.y);\n    if(abs(tuv.x)<0.68){fragColor=textureLod(iChannel1,uv,0.);return;}\n    vec4 newc = texture(iChannel1, fragCoord.xy / iResolution.xy);\n    vec4 xsample = texture(iChannel2, fragCoord.xy / iResolution.xy);\n    \n    float next = xsample.w + float(1.f);\n    float prev = xsample.w;\n    float divisor = prev / next;\n    xsample.xyz = xsample.xyz * vec3(divisor) + newc.xyz * (1.0f - divisor);\n    xsample.w = min(next, float(SAMPLES_LOCK-1));\n    \n    fragColor = xsample;\n}\n","name":"Buffer C","description":"","type":"buffer"}]}