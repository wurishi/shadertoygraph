{"ver":"0.1","info":{"id":"MdSBzG","date":"1500869811","viewed":226,"name":"Palette Concept","username":"kushquad","description":"Inspired by the SIGGRAPH 2017 paper by Maria (Masha) Shugrina, Jingwan Lu, and Stephen DiVerdi.\nwww.youtube.com/watch?v=kapQfn7K0fQ\nConcept for the Qt implementation - allows artists to create their colour gamuts/gradients instead of a colour wheel","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["antialiasing","gradient","metaball","palette"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Inspired by the SIGGRAPH 2017 paper by Maria (Masha) Shugrina, Jingwan Lu, and Stephen DiVerdi.\n// https://www.youtube.com/watch?v=kapQfn7K0fQ&feature=share\n\n#define NUM_BLOBS 3\n\n// Define all colours and positions of the nuclei\nvec4 colors[NUM_BLOBS] = vec4[](vec4(1.0, 0.0, 0.0, 1.0), vec4(0.2, 0.9, 1.0, 1.0), vec4(0.9, 0.8, 0.2, 1.0));\nvec3 positions[NUM_BLOBS] = vec3[](vec3(100, 100, 50), vec3(200, 200, 50), vec3(150, 100, 30));\n\n// Define background colour\nvec4 backgroundcol = vec4(1.0, 1.0, 1.0, 1.0);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    // Implement mouse behavior - find closest control point to move around\n    vec2 mouse = iMouse.xy;\n    \n    float mindist = 100000000.0;\n    int minindex = -1;\n    for(int i=0; i<NUM_BLOBS; i++)\n    {\n    \tfloat dist = distance(positions[i].xy, mouse.xy);   \n        if(dist<mindist)\n        {\n    \t\tminindex = i;\n        \tmindist = dist;\n        }\n    }\n    if(mouse.xy != vec2(0.0, 0.0))\n        positions[minindex].xy = mouse.xy;\n       \n    // Metaball computation\n    float contribution = 0.0;\n    \n    // Gradient computation\n    vec4 weight_num = vec4(0.0, 0.0, 0.0, 1.0);\n    float weight_denom = 0.0;\n    \n    for(int i=0; i<NUM_BLOBS; i++)\n    {\n       \t// Calculate gradient based on distance from nuclei\n        float dist = distance(positions[i].xy, fragCoord.xy);\n        float fraction = positions[i].z/dist;\n        float temp = 1.0/(dist*dist);\n        weight_num += temp*colors[i];\n        weight_denom += temp;\n        \n        // Metaball contribution for this nuclei\n        contribution += fraction;\n    }\n    \n    // Pixel within metaball classification\n    if(contribution>1.0)\n    \tfragColor = weight_num/weight_denom;\n    else\n        // Antialiasing computation\n        fragColor = mix(backgroundcol, weight_num/weight_denom, smoothstep(0.0,1.0, clamp(contribution-0.96, 0.0, 1.0)/0.04));\n}\n","name":"Image","description":"","type":"image"}]}