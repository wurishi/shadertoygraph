{"ver":"0.1","info":{"id":"DsVcWt","date":"1696745919","viewed":31,"name":"Failed attempt at tesseract","username":"tytr","description":"Blargh","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["sad","tesseract","failure"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec4 generateNeonColor(vec4 baseColor) {\n    // Calculate luminance of the base color\n    float luminance = dot(baseColor.rgb, vec3(0.299, 0.587, 0.114));\n    float threshold = 0.1;  // Luminance threshold; adjust as needed\n\n    if(luminance < threshold)\n        return baseColor;\n        \n    // Define a neon palette\n    vec4 neonPalette[3];\n    neonPalette[0] = vec4(1.0, 0.0, 0.5, 1.0); // Neon Pink\n    neonPalette[1] = vec4(0.0, 1.0, 1.0, 1.0); // Neon Cyan\n    neonPalette[2] = vec4(0.0, 1.0, 0.0, 1.0); // Neon Green\n    \n    // Use iTime to oscillate between colors in the palette\n    float phase = mod(iTime, 3.0); // Oscillate between 0 and 1 over 3 seconds\n    int index1 = int(mod(iTime, 3.0));\n    int index2 = (index1 + 1) % 3;\n    \n    vec4 neonColor = mix(neonPalette[index1], neonPalette[index2], phase);\n    \n    // Blend the neon color with the base color\n    return mix(baseColor, neonColor, 0.5); // 0.5 is a blending factor; you can adjust this\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord/iResolution.xy) * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec4 finalCol = vec4(0.0);\n    \n    for (int i = 0; i < 2; i++) {\n        uv = fract(uv * 1.5) - 0.5;\n        \n        vec4 col = vec4(0.0);\n\n        const float s = 0.4;\n        vec4 tesseractVertices[16];\n        for (int i = 0; i < 8; ++i) {\n            tesseractVertices[i] = s * vec4((i & 1) == 0 ? -1.0 : 1.0,\n                                          (i & 2) == 0 ? -1.0 : 1.0,\n                                          (i & 4) == 0 ? -1.0 : 1.0,\n                                          -1.0);\n            tesseractVertices[i + 8] = s * vec4(tesseractVertices[i].xyz, 1.0);\n        }\n\n        float t = iTime;\n        mat4 rotation4D = mat4(\n            cos(t), -sin(t), 0.0, 0.0,\n            sin(t), cos(t), 0.0, 0.0,\n            0.0, 0.0, cos(t * 0.5), -sin(t * 0.5),\n            0.0, 0.0, sin(t * 0.5), cos(t * 0.5)\n        );\n\n        for (int i = 0; i < 16; ++i) {\n            tesseractVertices[i] = rotation4D * tesseractVertices[i];\n        }\n\n        const int edges[48] = int[](\n            0, 1, 1, 2, 2, 3, 3, 0,\n            4, 5, 5, 6, 6, 7, 7, 4,\n            0, 4, 1, 5, 2, 6, 3, 7,\n            8, 9, 9, 10, 10, 11, 11, 8,\n            12, 13, 13, 14, 14, 15, 15, 12,\n            8, 12, 9, 13, 10, 14, 11, 15\n        );\n\n        for (int i = 0; i < 32; i += 2) {\n            vec3 a = tesseractVertices[edges[i]].xyz / (2.5 - tesseractVertices[edges[i]].w);\n            vec3 b = tesseractVertices[edges[i+1]].xyz / (2.5 - tesseractVertices[edges[i+1]].w);\n\n            vec2 ab = b.xy - a.xy;\n            vec2 pa = a.xy - uv;\n            vec2 pb = b.xy - uv;\n\n            float h = clamp(dot(pa, ab) / dot(ab, ab), 0.0, 1.0);\n            float d = length(pa - ab*h);\n\n            if(d < 0.005)\n                col += vec4(0.5 + (a+b)*0.25, 1.0); // average color of endpoints for now\n        }\n        \n        finalCol += col;\n    }\n    \n    vec4 genColor = generateNeonColor(finalCol);\n\n\n    fragColor = min(genColor, vec4(1.0)); // Ensure we don't exceed 1.0 due to overlapping lines\n}\n","name":"Image","description":"","type":"image"}]}