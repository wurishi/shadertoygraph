{"ver":"0.1","info":{"id":"4ccXzB","date":"1714052003","viewed":60,"name":"4 center ellipse","username":"celifan","description":"Approximating ellipse by circular arcs.  \nAs described here [url=https://paulbourke.net/geometry/ellipsecirc/figure2.png][Four Center Ellipse][/url]\n- Green ground truth.\n- Red approximation.","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["approximation","ellipse"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//**************\n// Approximating ellipse by circular arcs.  \n// *************\n\n// For convenience positions are expressed as integers in a [_n x _n] grid \nconst float s = 1.0; //  grid width in normalize pix coordinates\nconst float _n = 12.0; // grid num subdivision.\n\n// transformation to apply to vec2 in [_n X _n ] -->  normalize pix coordinates\n#define O (vec2(_ar/2.0,.1))\n#define V(x,y) (vec2(float(x),float(y))*s/_n)\n#define S(x) ((float(x))*s/_n) \n//\nconst float PI = 3.1415926;\nfloat _ar; //aspect ratio.\nfloat _pixSize ;\nconst float _lw =1.0; // default line width in pixels\nconst float _ps =3.0; // default point size in pixels\n\n// default colors.\nconst vec3 _c0 = vec3(.95,.92,.9);\nconst vec3 _c1 =  vec3(0.4,0.4,0.4);\nconst vec3 _cBlue = vec3(0.0,0.36,1.0);\nconst vec3 _c2 = vec3(.9,.9,.9);\nconst vec3 _pc = vec3( .9,0.3,0.0); \nfloat _f ;\n#define CS(a) vec2(cos(a), sin(a))\n\n// cs = vec2(cos(rotAngle), sin(rotAngle));\nvec2 R(vec2 v, vec2 cs)\n{\n    return mat2(cs.x, cs.y, -cs.y, cs.x)*v;\n}\n\n// signed distance to segment\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\n// solid stroke for the boundary of shape described by sd\nvoid strokeSolid( float sd, vec3 color,float lineWidth ,inout vec3 pixel  )\n{\n   \n    lineWidth = mix( lineWidth/1.1, lineWidth*1.1,_f);\n    pixel =  mix(pixel,color, (1.0 - sqrt(smoothstep((lineWidth-1.0)*_pixSize,_pixSize*(lineWidth +.5), abs(sd)))));\n}\n\n// draw an arc given a circle and 2 points.\nvoid drawArc(vec2 p, float r,float lineWidth, vec2 c, vec2 p1, vec2 p2,\n             vec3 color,\n             inout vec3 pixel, bool inv )\n{\n   vec2 cp1 = p1-c;\n   vec2 cp2 = p2-c;\n   bool noRange =dot(cp1,cp1)<1e-6;\n   bool visible =  (noRange || dot(vec2(cp1.y, -cp1.x),p-c)<0.0);\n\n   visible = visible && ( noRange || dot(vec2(cp2.y, -cp2.x),p-c)>0.0);\n   visible = inv ? !visible : visible;\n   //visible =true;\n   if(visible)\n   {\n   float d = length(p-c)-r;\n   //pixel =  d<0.0 ? vec3(0.0,0.5,0.3)*.5 : pixel;\n   float d1=abs(d)/length(vec2(dFdx(d),dFdy(d))/_pixSize);\n   strokeSolid(d1,color,lineWidth,pixel); \n   //\n   }\n}\n\n\nvoid drawSegment(vec2 p, vec2 a, vec2 b,float lineWidth,\n                 vec3 color,\n                 inout vec3 pixel )\n{\n \n   float d =    sdSegment(p,a, b );\n   strokeSolid(d, color, lineWidth,pixel);\n}\n\n// draw a line with default line width and color\n#define DS(p,a,b,pixel)\\\ndrawSegment(p,a,b,_lw, _c1,pixel) \n\nvoid drawPoint(vec2 p, float pointSize, vec3 color, inout vec3 pixel )\n{\n   float sd =length(p);\n   pixel =  mix(pixel, color, (1.0 -sqrt(smoothstep((pointSize-1.0)*_pixSize, _pixSize*(pointSize +.5), abs(sd))))); \n}\n\n// Draw point with default linewidth & color & ptSize\n#define DP(p,pixel)\\\n    drawPoint(p,_ps,_pc,pixel)\n\nvoid draw(vec2 p, inout vec3 pixel)\n{\n    \n    vec2 anim = iMouse.xy == vec2(0.0) ? abs(.7*vec2(sin(iTime),cos(iTime))):vec2(0.0);\n    vec2 sc = max(iMouse.xy == vec2(0.0)?vec2(0.01)*_ar:vec2(1e-4),anim +iMouse.xy/iResolution.y);\n    \n    //drawSegment(p,vec2(_ar/2.0-S(1), S(1)),vec2(_ar/2.0+mp.x+S(1),S(1)),_lw*3.0, _pc,pixel);\n    //DP(p-(mo),pixel);\n                   \n    //\n    vec2 p0 =   V(2,2);\n    vec2 p1 =   V(2,2)+vec2(sc.x,0.0);\n    vec2 p2 =  V(2,2)+sc;\n    vec2 p3 =   V(2,2)+ vec2(0.0,sc.y);\n    \n    \n    vec2 c = vec2((p0+p1+p2+p3)/4.0);\n    vec2 a=vec2(p1.x,c.y);\n    vec2 b= vec2(c.x,p2.y);\n    \n    vec2 m= (p3-p0)*.5;// minor axis\n    vec2 M= (p1-p0)*.5;// major axis.\n    float ld= length(M)-length(m);\n    vec2 d = b+ normalize(a-b)*ld;\n   \n    vec2 mda = (a+d)/2.0;\n    vec2 ad = a-d;\n    vec2 adp = vec2(ad.y,-ad.x);\n    //\n    float ab = dot(vec2(0.0,1.0), c-mda)/dot(vec2(0.0,1.0),adp);\n    vec2 c0 = mda + adp*ab;\n    //\n    ab = dot(vec2(1.0,0.0),c-mda)/dot(vec2(1.0,0.0),adp);\n    vec2 c1 = mda+adp*ab;\n   \n    //if ( sc.y>.1)\n    {\n        //show geometric construction \n       \n        DP(p-p0,pixel); DS(p,p0,p1,pixel);\n        DP(p-p1,pixel); DS(p,p1,p2,pixel);\n        DP(p-p2,pixel); DS(p,p2,p3,pixel);\n        DP(p-p3,pixel); DS(p,p3,p0,pixel);\n        //\n        DP(p-c,pixel);\n        DP(p-a,pixel);\n        DP(p-b,pixel);\n        DS(p,a,b,pixel);\n        DP(p-d,pixel);\n        DP(p-mda,pixel);\n        \n        DS(p,c, c+vec2(1.0,0.0)*sc.x,pixel);\n        DS(p,c,c+vec2(0.0,-1.0)*sc.y,pixel);\n        DP(p-c0,pixel);\n        DP(p-c1,pixel);\n        DS(p,  mda, c1,pixel);\n    }\n    // ground truth.\n    p/= sc;\n    float d1 = length(p-c/sc)-.5;\n    d1 = abs(d1)/length(vec2(dFdx(d1),dFdy(d1))/_pixSize);\n    strokeSolid(d1,vec3(0.0,1.0,0.0),_lw,pixel);\n    p*=sc;\n    // approximaion.\n    p-=c;\n    p=abs(p);\n    p+=c;\n    drawArc(p, length(a-c0),_lw, c0, a,mda,vec3(1.0,0.0,0.0),pixel,false);\n    drawArc(p, length(b-c1),_lw, c1, mda,b,vec3(1.0,0.0,0.0),pixel,false);\n    \n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates\n    vec2 p2 =  fragCoord.xy/iResolution.y;\n    _ar = iResolution.x/iResolution.y;\n    _pixSize = 1.0/iResolution.y;\n  \n    // draw\n    vec3 pixel = vec3(.1);\n    draw(p2,pixel);\n       \n    // Output to screen\n    fragColor = vec4(pixel,1.0);\n}","name":"Image","description":"","type":"image"}]}