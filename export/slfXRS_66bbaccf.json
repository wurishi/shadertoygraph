{"ver":"0.1","info":{"id":"slfXRS","date":"1625926685","viewed":110,"name":"Fork Alien Skies animated","username":"CryHam","description":"Some galaxy like fractals. Added time animation.\nClick mouse for a different fractal start location.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["procedural","fractal"],"hasliked":0,"parentid":"Msl3Rs","parentname":"Alien Skies"},"renderpass":[{"inputs":[],"outputs":[],"code":"// CryHam Fork of Alien Skies by gleurop in 2013-08-29\n// https://www.shadertoy.com/view/Msl3Rs\n// added animation from time\n//#define ALT_COLOR\n\nfloat iSphere(in vec3 ro, in vec3 rd, in vec4 sph) // From iq\n{\n    // a sphere centered at the origin has equation |xyz| = r\n    // meaning, |xyz|^2 = r^2, meaning <xyz, xyz> = r^2\n    // now, xyz = ro + t*rd, therefore |ro|^2+t^2 + 2<ro, rd> t - r^2 = 0\n    // which is a quadratic equation, so\n\n    vec3 oc = ro - sph.xyz;\n    float b = dot(oc, rd);\n    float c = dot(oc,oc) - sph.w*sph.w;\n    float h = b*b - c;\n    if(h <0.0) return -1.0; //no intersection\n\n    //pick smaller one(i.e, close one)\n    //not (-b+sqrt(h)) /2\n\t//Edited: actually pick larger one\n    float t = (-b + sqrt(h));\n    return t;\n}\n\nvec2 rotate(vec2 v, float a) {\n\treturn vec2(cos(a)*v.x + sin(a)*v.y, -sin(a)*v.x + cos(a)*v.y);\n}\n\nvec3 hsv(in float h, in float s, in float v) {\n\treturn mix(vec3(1.0), clamp((abs(fract(h + vec3(3, 2, 1) / 3.0) * 6.0 - 3.0) - 1.0), 0.0 , 1.0), s) * v;\n}\n\nvec3 toSpherical(in vec3 c)\n{\n\tfloat r = length(c);\n\treturn vec3(r, acos(c.z/r), atan(c.y,c.x));\n}\n\nvec3 toCartesian(in vec3 s)\n{\n\tfloat sy = sin(s.y);\n\treturn s.x * vec3(sy*cos(s.z), sy*sin(s.z), cos(s.y));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = -1.0 + 2.0 * fragCoord.xy / iResolution.xy;\n\tuv.x *= iResolution.x / iResolution.y;\n\tvec3 ro = toCartesian(vec3(1.0, iTime*0.01, iTime*0.01419+0.5));\n\tvec3 cd = normalize(-ro);\n\tvec3 u = normalize(vec3(-ro.z, 0, ro.x));\n\tvec3 v = cross(u, cd);\n\tvec3 rd = normalize(u*uv.x + v*uv.y + cd*exp(sin(iTime*0.013)*0.5+0.5)*2.0);\n\tvec4 color = vec4(0);\n\tfloat it = 0.0;\n\t\n    vec2 ms = iMouse.xy / iResolution.xy;\n    vec2 m = vec2(0.7f + iTime * 0.01312f, 1.f + iTime * 0.01231f);  m+=ms;\n\tm *= 3.1415;\n\tmat2 r1 = mat2(cos(m.x),  sin(m.x),\n\t\t\t\t   -sin(m.x), cos(m.x));\n\tmat2 r2 = mat2(cos(m.y),  sin(m.y),\n\t\t\t\t   -sin(m.y), cos(m.y));\n\t\n\tfor (int i = 0; i < 32; i++) {\n\t\tfloat d = iSphere(ro, rd, vec4(0,0,0,1.0-float(i)/100.0));\n\t\tvec3 p = ro+rd*d;\n\t\tro = p * 9.0;\n\t\tro.xy *= r1;\n\t\tro.yz *= r2;\n\t\tro = abs(ro-1.0);\n\t\trd = normalize(ro);\n#ifdef ALT_COLOR\n\t\tcolor += vec4(hsv(float(i)/10.0, dot(p, rd), 1.0), 1.0);\n#else\n\t\tcolor += vec4(hsv(float(i)/10.0+length(ro), dot(p, rd), 1.0), 1.0);\n#endif\n\t}\n\tcolor = sin(color)*0.5+0.5;\n\tfragColor = color;\n}","name":"Image","description":"","type":"image"}]}