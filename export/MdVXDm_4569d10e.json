{"ver":"0.1","info":{"id":"MdVXDm","date":"1464884171","viewed":347,"name":"Frozen Trees","username":"zackpudil","description":"Some pseudo randomly generated frozen trees.  The frozen looks comes from the heavy influence of the Fresnel term in the lighting equation.","likes":15,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","distancefields"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nconst float tmax = 50.0;\n\nfloat hash(float n) {\n\treturn fract(sin(n)*43758.5453);\n}\n\n// old school typical perlin noise.\nfloat noise(vec3 g) {\n\tvec3 p = floor(g);\n\tvec3 f = fract(g);\n\n\tf = f*f*(3.0 - 2.0*f);\n\tfloat n = p.x + p.y*57.0 + p.z*113.0;\n\n\tfloat x = mix(hash(n + 0.0), hash(n + 1.0), f.x);\n\tfloat y = mix(hash(n + 57.0), hash(n + 58.0), f.x);\n\tfloat z = mix(hash(n + 113.0), hash(n + 114.0), f.x);\n\tfloat w = mix(hash(n + 170.0), hash(n + 171.0), f.x);\n\n\treturn mix(mix(x, y, f.y), mix(z, w, f.y), f.z);\n}\n\nfloat noise(vec2 g) {\n\tvec2 p = floor(g);\n\tvec2 f = fract(g);\n\n\tf = f*f*(3.0 - 2.0*f);\n\tfloat n = p.x + p.y*57.0;\n\n\tfloat x = mix(hash(n + 0.0), hash(n + 1.0), f.x);\n\tfloat y = mix(hash(n + 57.0), hash(n + 58.0), f.x);\n\treturn mix(x, y, f.y);\n}\n\nconst mat2 m2 = mat2(\n\t 0.80, 0.60, -0.60, 0.80\n);\n\nfloat fbm(vec2 p) {\n\tfloat f = 0.0;\n\n\tf += 0.5000*noise(p); p *= m2*2.01;\n\tf += 0.2500*noise(p); p *= m2*2.03;\n\tf += 0.1250*noise(p); p *= m2*2.05;\n\tf += 0.0625*noise(p);\n\tf /= 0.9375;\n\n\treturn f;\n}\n\nconst mat3 m3 = mat3(\n\t 0.00,  0.80,  0.60,\n\t-0.80,  0.36, -0.48,\n\t-0.60, -0.48,  0.64\n);\n\nfloat fbm(vec3 p) {\n\tfloat f = 0.0;\n\n\tf += 0.5000*noise(p); p *= 2.01;\n\tf += 0.2500*noise(p); p *= 2.03;\n\tf += 0.1250*noise(p); p *= 2.05;\n\tf += 0.0625*noise(p);\n\tf /= 0.9375;\n\n\treturn f;\n}\n\nvoid rotate(inout vec2 p, float a) {\n\tfloat s = sin(a);\n\tfloat c = cos(a);\n\n\tp = mat2(c, s, -s, c)*p;\n}\n\nfloat segment(vec3 p, vec3 a, vec3 b) {\n\tvec3 pa = p - a;\n\tvec3 ba = b - a;\n\n\tfloat h = clamp(dot(pa, ba)/dot(ba, ba), 0.0, 1.0);\n\n\treturn length(pa - ba*h);\n}\n\nfloat map(vec3 p) {\n    // p = position for trees, q = flat, un-modified space.\n\tvec3 q = p;\n    \n    // update the y coord to match the plan.\n\tp.y -= 2.0*noise(0.15*q);\n\n    // a repetition of trees.\n\tp.z = mod(p.z + 6.0, 12.0) - 6.0;\n\tp.x = mod(p.x + 12.0, 24.0) - 12.0;\n\n    // rotate the points in space randomly, relative to the tree origin.\n\trotate(p.xy, 0.1*noise(p.xz));\n\trotate(p.yz, 0.2*noise(p.xz));\n\n    // some factors for mirroring (only mirror at a certain p.y value)\n\tfloat g = smoothstep(1.0, 5.0, p.y);\n\tfloat s = smoothstep(-10.0, 0.0, -p.y);\n\tp.xz = -abs(p.xz) + g*s*0.5*p.y; // mirror.\n\n    // udpate the xz coords based on original displacement.\n\tp.xz += vec2(g*s*0.5*p.y);\n\tg = smoothstep(2.0, 7.0, p.y);\n\ts = smoothstep(-10.0, 2.0, -p.y);\n\tp.xz = -abs(p.xz) + g*s*0.5*p.y; // rinse and repeat.\n\n\tp.xz += vec2(g*s*0.5*p.y); // rinse\n\tg = smoothstep(3.0, 10.0, p.y);\n\ts = smoothstep(-30.0, 1.0, -p.y);\n\tp.xz = -abs(p.xz) + g*s*0.5*p.y; // and repeat.\n\n\treturn min(\n\t\tsegment(p, vec3(0, -3, 0), vec3(0, 5.5, 0)) - 0.5 \n\t\t\t+ 0.20*smoothstep(1.0, 5.0, p.y) // update the radius of the segment\n\t\t\t+ 0.25*smoothstep(2.0, 7.0, p.y) // based on the height of the \n\t\t\t+ 0.35*smoothstep(3.0, 10.0, p.y), // geomertry.\n        // just a plane with noise deformations.\n\t\tq.y + 1.0 - 2.0*noise(0.15*q));\n}\n\n// typical ray marcher.\nfloat march(vec3 ro, vec3 rd) {\n\tfloat t = 0.0;\n\n\tfor(int i = 0; i < 250; i++) {\n\t\tfloat d = map(ro + rd*t);\n\t\tif(abs(d) < 0.01 || t >= tmax) break;\n\t\tt += d*0.25;\n\t}\n\n\treturn t;\n}\n\nvec3 normal(vec3 p) {\n\tvec2 h = vec2(0.001, 0.0);\n\tvec3 n = vec3(\n\t\tmap(p + h.xyy) - map(p - h.xyy),\n\t\tmap(p + h.yxy) - map(p - h.yxy),\n\t\tmap(p + h.yyx) - map(p - h.yyx)\n\t);\n\n    // typical fbm-valued bumb maping.\n\tvec3 b = vec3(0);\n\tif(p.y + 1.0 - 2.0*noise(0.15*p) > 0.1) {\n        // trees, no Y varanice.\n\t\tvec3 f = vec3(10.0, 0.1, 10.0);\n\n\t\tb += 0.5*vec3(\n\t\t\tfbm(p*f + h.xyy) - fbm(p*f - h.xyy),\n\t\t\tfbm(p*f + h.yxy) - fbm(p*f - h.yxy),\n\t\t\tfbm(p*f + h.yyx) - fbm(p*f - h.yyx)\n\t\t);\n\t} else {\n\t\tfloat f = 1.0;\n\t\tb += 0.1*vec3(\n\t\t\tfbm(f*(p + h.xyy)) - fbm(f*(p - h.xyy)),\n\t\t\tfbm(f*(p + h.yxy)) - fbm(f*(p - h.yxy)),\n\t\t\tfbm(f*(p + h.yyx)) - fbm(f*(p - h.yyx))\n\t\t);\n\t}\n\n\treturn normalize(n + b);\n}\n\nfloat shadow(vec3 p, vec3 l) {\n\tfloat res = 1.0;\n\tfloat t = 0.5;\n\n\tfor(int i = 0; i < 100; i++) {\n\t\tfloat d = map(p + l*t);\n\t\tt += d*0.50;\n        // iq's soft shadow formul.\n\t\tres = min(res, 32.0*d/t);\n\t\tif(abs(d) < 0.001 || t >= tmax) break;\n\t}\n\n\treturn clamp(res, 0.0, 1.0);\n}\n\nmat3 camera(vec3 eye, vec3 lat) {\n\tvec3 ww = normalize(lat - eye);\n\tvec3 uu = normalize(cross(vec3(0, 1, 0), ww));\n\tvec3 vv = normalize(cross(ww, uu));\n\n\treturn mat3(uu, vv, ww);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 uv = -1.0 + 2.0*(fragCoord/iResolution.xy);\n\tuv.x *= iResolution.x/iResolution.y;\n\n    // sky/background color;\n\tvec3 col = mix(vec3(0.0, 0.6, 1.0), vec3(1), smoothstep(0.2, 1.0, fbm(5.0*uv)));\n\n    // construct primary rays.\n\tvec3 ro = vec3(10.0, 5.0, iTime);\n\tvec3 rd = normalize(camera(ro, ro + vec3(-15.0, -3.0, 3))*vec3(uv, 1.97));\n\n    // march, till intersection or max hit.\n\tfloat i = march(ro, rd);\n\tif(i < tmax) { // if intersection distance is less than max we hit something.\n\n        // geometry. intersection position, surface normal.\n        vec3 pos = ro + rd*i; \n\t\tvec3 nor = normal(pos);\n\n        // lighting vars, light direction, shadow, diffuse.\n\t\tvec3 lig = normalize(vec3(0.8, 0.5, -0.6));\n\t\tfloat sha = shadow(pos, lig) + 0.5*step(-0.9, pos.y - 2.0*noise(0.15*pos)); // hack to get the internal shadows to be less obtrusive.\n\t\tfloat dif = clamp(dot(lig, nor), 0.0, 1.0)*sha;\n\n\t\tcol  = 0.2*vec3(1); // ambient\n\t\tcol += 0.7*dif; //diffuse\n\n\t\tif(pos.y + 1.0 - 2.0*noise(0.15*pos) > 0.1) {\n\t\t\tcol *= vec3(0.6, 0.5, 0.2); // trees are just a brown color.\n\t\t} else {\n\t\t\tvec3 mat = vec3(0.1, 0.4, 0.1); // ground is green mixed with white.\n\t\t\tmat = mix(mat, vec3(2.0), smoothstep(0.0, 1.0, 2.0*smoothstep(0.4, 1.0, fbm(1.0*pos))));\n\t\t\tcol *= mat;\n\t\t}\n\n        // freznel term, cranked up to 11 to get the frozen look.\n\t\tcol += 2.0*pow(clamp(1.0 + dot(rd, nor), 0.0, 1.0), 2.0)*sha;\n\t}\n\n\tfragColor = vec4(col, 1);\n}","name":"Image","description":"","type":"image"}]}