{"ver":"0.1","info":{"id":"ft3GDX","date":"1636799748","viewed":206,"name":"Ray Marching Techniques","username":"playbyan1453","description":"This technique if not careful can be heavy. Regular technique breaks down at bigger displacement, the relaxing one it looks smooth with less artifact.\nLeft (Common), Right (New).","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","sdf","relaxing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define STEPS 256\n#define MIN_T 1e-4\n#define MAX_T 8.0\n\nfloat map(vec3 p) {\n    return (length(p) - 1.0)+(sin(8.0*p.x)*sin(8.0*p.y)*sin(8.0*p.z))*0.5;\n}\n\nvec3 normal(vec3 p) {\n    const float e = MIN_T;\n    const vec2 h = vec2(1,-1);\n    return normalize(h.xyy*map(p + h.xyy*e)+\n                     h.yyx*map(p + h.yyx*e)+\n                     h.yxy*map(p + h.yxy*e)+\n                     h.xxx*map(p + h.xxx*e));\n}\n\n// Common technique, total of nearest distance.\nfloat raymarch(vec3 ro, vec3 rd) {\n    float t = 0.0;\n    for(int i = 0; i < STEPS; i++) {\n        float d = map(ro + rd * t);\n        t += d;\n        if(d < MIN_T || t > MAX_T) break;\n    }\n    return t;\n}\n\n/* // Original code, it was a better soft shadow from iq\n// It was modified to get better intersection\nfloat hraymarch(vec3 ro, vec3 rd) {\n    float t = 0.0;\n    float pd = 1e19;\n    float steps = 0.0;\n    for(int i = 0; i < STEPS; i++) {\n        float d = map(ro + rd * t);\n        float y = d*d/(2.0*pd);\n        float h = sqrt(d*d-y*y);\n        pd = d;\n        t += min(d, h/max(0.0, t-y));\n        if(d < MIN_T || t > MAX_T) break;\n    }\n    return t;\n}*/\n\n// Good quality but slower in some cases.\n// Relaxing Ray Marcher : https://erleuchtet.org/~cupe/permanent/enhanced_sphere_tracing.pdf\nfloat hraymarch(vec3 ro, vec3 rd) {\n    float t = 0.0;\n    float relax = 0.25;\n    float last_d = 0.0;\n    float last_dt = 0.0;\n    for(int i = 0; i < STEPS; i++) {\n        if(t > MAX_T) break;\n        float d = map(ro + rd * t);\n        if(relax != 1.0 && last_dt > abs(last_d) + abs(d)) {\n            t += (1.0 - relax) * last_dt;\n            relax = 1.0;\n            continue;\n        }\n        if(d < MIN_T) break;\n        t += relax * d;\n        last_dt = relax * d;\n        last_d = d;\n    }\n    return t;\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n    vec2 uv = (2.0*fragCoord.xy-iResolution.xy)/max(iResolution.x, iResolution.y);\n    vec3 at = vec3(0, 0, 0);\n    vec3 ro = vec3(cos(iTime*0.25)*3.0, 2, sin(iTime*0.25)*3.0);\n    vec3 z = normalize(at - ro);\n    vec3 x = normalize(cross(vec3(0, 1, 0), z));\n    vec3 y = cross(z, x);\n    vec3 rd = normalize(uv.x * x + uv.y * y + 1.0 * z);\n    float t = uv.x < 0.0 ? raymarch(ro, rd) : hraymarch(ro, rd);\n    vec3 p = ro + rd * t;\n    vec3 nor = normal(p);\n    vec3 col = t < MAX_T ? vec3(nor.y*0.5+0.5) : vec3(rd.y*0.5+0.5);\n\n    fragColor = vec4(sqrt(col)*smoothstep(0.0005, 0.005, abs(uv.x)), 1.0);\n}","name":"Image","description":"","type":"image"}]}