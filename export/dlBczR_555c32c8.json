{"ver":"0.1","info":{"id":"dlBczR","date":"1691395287","viewed":6,"name":"maptest","username":"woodelf","description":"just test, 这个参数比较不错，frequency = 10， amplitude = 0.2， iteration = 1","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["test"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\n\nfloat snoise(vec2 v) {\n    const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,  // -1.0 + 2.0 * C.x\n                        0.024390243902439); // 1.0 / 41.0\n    vec2 i  = floor(v + dot(v, C.yy) );\n    vec2 x0 = v -   i + dot(i, C.xx);\n    vec2 i1;\n    i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n    vec4 x12 = x0.xyxy + C.xxzz;\n    x12.xy -= i1;\n    i = mod289(i); // Avoid truncation effects in permutation\n    vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n        + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\n    m = m*m ;\n    m = m*m ;\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n    m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n    vec3 g;\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n    return 130.0 * dot(m, g);\n}\n\nfloat fractal_snoise(vec2 v, float iter)\n{\n    float ret = 0.;\n    float vPower = pow(2., iter);\n    //float vPower = exp2(iter);\n    float weightBase = (vPower/2.)/(vPower - 1.);\n    for (float i=0.; i< iter ; i++)\n    {\n        ret += snoise(v)*weightBase;\n        weightBase /= 2.;\n        v*=2.;\n    }\n    return ret;\n}\n\nfloat InCircle(vec2 center, float r, vec2 coord)\n{\n    if (distance(center, coord) < r)\n        return 1.0;\n    else\n        return 0.0;\n}\n\nvec2 Warp(vec2 uv, float frequency, float amplitude, int iter)\n{\n    vec2 posX = vec2(uv*frequency);\n    vec2 posY = vec2(uv*frequency+frequency);\n    \n    vec2 offset;\n    float fIter = float(iter);\n    offset.x = fractal_snoise(posX, 4.);\n    offset.y = fractal_snoise(posY, 4.);\n    vec2 judgePos = uv + offset * amplitude;\n    \n    return judgePos;\n}\n\nvec2 GetJudgePos(vec2 uv)\n{\n    float frequency = 10.;\n    float amplitude = 0.2;\n    float frqMulti = 1.2;\n    float amplMulti = 1.;\n    int iteration = 1;\n    \n    vec2 judgePos = uv;\n    for (int i = 0; i < iteration; i++)\n    {\n        judgePos = Warp(judgePos, frequency, amplitude, i+1);\n        frequency *= frqMulti;\n        amplitude *= amplMulti;\n    }\n    \n    return judgePos;\n}\n\n\n//void mainImage( out vec4 fragColor, in vec2 fragCoord )\n//{\n//    // Normalized pixel coordinates (from 0 to 1)\n//    vec2 uv = fragCoord/iResolution.xy;\n//    float xMulti = iResolution.x/iResolution.y;\n//    uv.x *= xMulti;\n//    \n//    vec2 judgePos = GetJudgePos(uv);\n//    \n//    vec2 center = vec2(0.5* xMulti, 0.5);\n//    float col = InCircle(center, 0.35, judgePos);\n//\n//    // Output to screen\n//    fragColor = vec4(col, col, col, 1.0);\n//}\n\n\nmat2 rotate2d(float angle){\n    return mat2(cos(angle),-sin(angle),\n                sin(angle),cos(angle));\n}\n\nbool InEllipse(vec2 center, float rMin, float rateLongShort, float angle, vec2 coord)\n{\n    float rMax = rMin * rateLongShort;\n    vec2 local = rotate2d(angle) * (coord - center);\n    local.x /= rMin;\n    local.y /= rMax;\n    if (length(local) < 1.)\n        return true;\n    else\n        return false;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    float xMulti = iResolution.x/iResolution.y;\n    uv.x *= xMulti;\n    \n    vec2 judgePos = GetJudgePos(uv);\n    \n    int count = 4;\n    float col = 0.;\n    vec2 seed1 = vec2(29.1, 78.9);\n    vec2 seed2 = vec2(17.3, 8.6);\n    vec2 seed3 = vec2(66.2, 30.5);\n    vec2 seed4 = vec2(15.2, 10.6);\n    vec2 seed5 = vec2(6.8, 17.5);\n    for (int i=0; i< count; i++)\n    {\n        float v1 = snoise(seed1 * (float(i)+ 1.)) * 0.5 + 0.5;\n        float v2 = snoise(seed2 * (float(i)+ 1.)) * 0.5 + 0.5;\n        float v3 = snoise(seed3 * (float(i)+ 1.)) * 0.5 + 0.5;\n        float v4 = snoise(seed4 * (float(i)+ 1.)) * 0.5 + 0.5;\n        float v5 = snoise(seed5 * (float(i)+ 1.)) * 0.5 + 0.5;\n        \n        if (InEllipse(vec2(fract(v1)*xMulti, fract(v2)), v3*0.5 + 0.1, v4*2.+1., v5* 360., judgePos))\n        {\n            col = 1.;\n            break;\n        }\n    }\n    \n    \n    // Output to screen\n    fragColor = vec4(col, col, col, 1.0);\n}","name":"Image","description":"","type":"image"}]}