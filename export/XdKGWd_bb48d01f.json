{"ver":"0.1","info":{"id":"XdKGWd","date":"1470846257","viewed":225,"name":"First SDF","username":"Cubeleo","description":"I'm finally trying to warp into the world of SDF.","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["sdf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_DEPTH 10\n\n#define MAT_BACKGROUND    0\n#define MAT_GREY_DIFFUSE  1\n#define MAT_CHROME        3\n#define MAT_WAVY_MIRROR   4\n\nint intersectionMaterial;\nfloat intersectionT;\nvec3 intersectionPoint;\nvec3 intersectionNormal;\n\n\nfloat dSphere(vec3 p, float radius)\n{\n    return length(p) - radius;\n}\n\nfloat dBox(vec3 p, vec3 dimensions)\n{\n\tvec3 d = abs(p) - dimensions;\n\treturn min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat dRoundedBox(vec3 p, vec3 dimensions, float radius)\n{\n    return dBox(p, dimensions) - radius;\n}\n\n\nvec2 test(vec2 distMat, float newDist, int newMat)\n{\n    if (newDist < distMat.x)\n    {\n        distMat = vec2(newDist, float(newMat));\n    }\n    \n    return distMat;\n}\n\nvec3 quatMult(vec4 q, vec3 v)\n{\n\treturn v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);\n}\n\nvec4 quatAxisAngle(vec3 axis, float angle)\n{\n    angle *= .5;\n    float s = sin(angle), c = cos(angle);\n    \n    return vec4(normalize(axis) * s, c);\n}\n\nvec2 d(vec3 p)\n{\n    vec3 transformed;\n    vec2 result;\n    \n    result = vec2(dSphere(p - vec3(0, 10, 0), 1.), MAT_GREY_DIFFUSE);\n    result = test(result, dSphere(p - vec3(1. + .5 * sin(3.*iTime), 8. + .5 * sin(5.*iTime), -.75), .3), MAT_GREY_DIFFUSE);\n    result = test(result, dSphere(p - vec3(-1, 10.2, 2.), .7), MAT_CHROME);\n    transformed = quatMult(quatAxisAngle(vec3(0, 0, 1), 2. * iTime), p - vec3(3, 10.2, .4));\n    result = test(result, dBox(transformed, vec3(.7)), MAT_GREY_DIFFUSE);\n    transformed = quatMult(quatAxisAngle(vec3(.5), iTime), p - vec3(-3, 10.2, .4));\n    result = test(result, dRoundedBox(transformed, vec3(.7, .6, .4), 0.4), MAT_GREY_DIFFUSE);\n\tresult = test(result, dBox(p - vec3(0, 0, -3.2), vec3(15, 15, 2)), MAT_WAVY_MIRROR);\n\t\n\treturn result;\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n\tvec3 eps = vec3( 0.01, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t    d(pos+eps.xyy).x - d(pos-eps.xyy).x,\n\t    d(pos+eps.yxy).x - d(pos-eps.yxy).x,\n\t    d(pos+eps.yyx).x - d(pos-eps.yyx).x );\n\treturn normalize(nor);\n}\n\n#define MAX_STEPS 100\n#define MARCH_EPSILON .001\n#define MAX_T 100.\n\nvoid IntersectScene(vec3 origin, vec3 direction)\n{\n    intersectionT = 0.;\n    \n    int ii;\n    for (ii = 0; ii < MAX_STEPS && intersectionT < MAX_T; ++ii)\n    {\n        vec3 pos = origin + direction * intersectionT;\n        \n        vec2 distMat = d(pos);\n        \n        if (distMat.x < MARCH_EPSILON)\n        {\n            if (intersectionT < MAX_T)\n            {\n\t            intersectionMaterial = int(distMat.y);\n\t\t\t\tintersectionNormal = calcNormal(pos);\n            \tintersectionPoint = pos;\n            }\n            \n            break;\n        }\n        \n        intersectionT += distMat.x;\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat aspect = iResolution.x / iResolution.y;\n\t\n\tvec2 uv = vec2(aspect, 1.) * (fragCoord.xy / iResolution.xy - .5);\n\t\n    vec2 mouseUV = iMouse.z <= 0. ? vec2(0) : ((iMouse.xy / iResolution.xy) - 0.5);\n\tvec3 origin = vec3(-4. * mouseUV.x, 0, -4. * mouseUV.y);\n\t\n\tvec3 direction = vec3(uv.x, 1.25, uv.y);\n\tdirection = normalize(direction);\n\t\n\tvec3 color = vec3(0);\n\t\n\tbool tracing = true;\n\tfor (int i = 0; i < MAX_DEPTH; ++i)\n\t{\n\t\tintersectionMaterial = MAT_BACKGROUND;\n\t\n\t\tIntersectScene(origin, direction);\n\t\t\n\t\tif (intersectionMaterial == MAT_BACKGROUND)\n\t\t{\n\t\t\tfloat backdrop = clamp(dot(direction, vec3(0, .7, .7)), 0., 1.);\n\t\t\tcolor = backdrop * vec3(.6, .6, .9);\n\t\t\t\n\t\t\ttracing = false;\n\t\t}\n\t\telse if (intersectionMaterial == MAT_GREY_DIFFUSE)\n\t\t{\n\t\t\tcolor += .02;\n\t\t\t\n\t\t\tfloat lightDot = dot(intersectionNormal, normalize(vec3(5000, -5000, 10000)));\n\t\t\t\n\t\t\tif (lightDot > 0.)\n\t\t\t{\n\t\t\t\tcolor += .8 * lightDot;\n\t\t\t}\n\t\t\n\t\t\ttracing = false;\n\t\t}\n\t\telse if (intersectionMaterial == MAT_CHROME)\n\t\t{\n\t\t\torigin = intersectionPoint + intersectionNormal * .001;\n\t\t\tdirection = reflect(direction, intersectionNormal);\n\t\t}\n\t\telse if (intersectionMaterial == MAT_WAVY_MIRROR)\n\t\t{\n\t\t\torigin = intersectionPoint + intersectionNormal * .001;\n\t\t\tdirection = reflect(direction, normalize(intersectionNormal + .01 * sin(10.*intersectionPoint + 2.*iTime)));\n\t\t}\n\t\t\n\t\tif (!tracing) break;\n\t}\n\n\tfragColor = vec4(pow(color, vec3(1./2.2)), 1.0);\n}\n\n","name":"Image","description":"","type":"image"}]}