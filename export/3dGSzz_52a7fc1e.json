{"ver":"0.1","info":{"id":"3dGSzz","date":"1573215195","viewed":239,"name":"shell","username":"skaplun","description":"SSAO taken here https://www.shadertoy.com/view/4ltSz2","likes":10,"published":1,"flags":32,"usePreview":0,"tags":["raymarch","ssao","multipass"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define FARCLIP 3.\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    //fragColor = mix(vec4(1.), texture(iChannel1, fragCoord.xy/iResolution.xy), step(texture(iChannel0, fragCoord.xy/iResolution.xy).a, FARCLIP));\n    fragColor = pow(max(1.4 - texture(iChannel0, fragCoord.xy/iResolution.xy).a, 0.), 4.)\n              * mix(vec4(1.), texture(iChannel1, fragCoord.xy/iResolution.xy), step(texture(iChannel0, fragCoord.xy/iResolution.xy).a, FARCLIP));\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define MAX_MARCHING_STEPS 128\n#define MIN_FLOAT 1e-6\n#define MAX_FLOAT 1e6\n#define EPSILON 0.0001\n#define THICKNESS .005\n\nconst float PI = acos(-1.);\n\nmat2 rotate(in float r) { float c=cos(r), s=sin(r); return mat2(c, -s, s, c); }\nvec2 rotate(in vec2 p, in float r) { return rotate(r) * p; }\nvec3 rotate(in vec3 p, in vec3 r) {\n    vec3 q = p;\n    q.xy = rotate(q.xy, r.z);\n    q.yz = rotate(q.yz, r.x);\n    q.zx = rotate(q.zx, r.y);\n    return q;\n}\n\nfloat opSubtraction( float d1, float d2 ) { return max(-d1,d2); }\nvec4 opSubtraction(vec4 d1, vec4 d2){\n    if (-d1.x >= d2.x)\n        return d1;\n    else\n        return d2;\n}\nvec4 opMin(vec4 d1, vec4 d2){\n    if (d1.x < d2.x)\n        return d1;\n    else\n        return d2;\n}\n\nfloat shell(vec3 p, float rad){\n    return opSubtraction(rotate(p, vec3(0., .75, 0.)).z,\n                         opSubtraction(p.x,\n                                       opSubtraction(length(p) - rad + THICKNESS,\n                                                     length(p) - rad - THICKNESS)));\n}\n\nfloat world(vec3 p){\n  \tp = rotate(p, vec3(0., -iTime * 3., 0.));\n    float dist = MAX_FLOAT;\n    for(float i=1.; i>=.35; i-=THICKNESS * 10.){\n    \tdist = min(dist, shell(rotate(p, vec3(0., -i * 8., 0.)), i));\n        if(dist <= 0.)\n            return dist;\n    }\n    return dist;\n}\n\nfloat march(vec3 eye, vec3 marchingDirection){\n    const float precis = .001;\n    float t = 0.0;\n\tfloat l = 0.0;\n    for(int i=0; i<MAX_MARCHING_STEPS; i++){\n\t    vec3 p = eye + marchingDirection * t;\n        float hit = world(p);\n        if(hit < precis) return t;\n        t += hit;\n    }\n    return -1.;\n}\n\n//Could be calculated analitycally\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        world(vec3(p.x + EPSILON, p.y, p.z)) - world(vec3(p.x - EPSILON, p.y, p.z)),\n        world(vec3(p.x, p.y + EPSILON, p.z)) - world(vec3(p.x, p.y - EPSILON, p.z)),\n        world(vec3(p.x, p.y, p.z  + EPSILON)) - world(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n#define FARCLIP 3.\n\nvec4 color(vec3 camPos, vec3 localViewDir, mat3 cam2worldMatrix){\n    vec4 col;    \n    vec3 pos = camPos;\n    vec3 rayDir = cam2worldMatrix * localViewDir;\n    \n    float dis = march(pos, rayDir);\n    if(dis >= 0.){\n        pos += rayDir * dis;\n\n        vec3 nor = estimateNormal(pos);\n        nor = inverse(cam2worldMatrix) * nor;\n        nor.z *= -1.0;\n\n        float zDelta = localViewDir.z;\n        zDelta *= dis / FARCLIP;\n        \n        col = vec4(nor, zDelta);\n    }else{\n        col = vec4(FARCLIP + 1.);\n    }\n    \n    return col;\n}\n\nmat3 SetCamera(vec3 ro, vec3 ta, float cr){\n\tvec3 cw = normalize(ta - ro);\n\tvec3 cp = vec3(sin(cr), cos(cr), 0.0);\n\tvec3 cu = normalize(cross(cw, cp));\n\tvec3 cv = normalize(cross(cu, cw));\n    return mat3(cu, cv, cw);\n}\n\nvec4 render(in vec2 fragCoord){\n\tvec2 uv = (2. * fragCoord.xy - iResolution.xy)/iResolution.y;\n    vec2 mouse = iMouse.xy/iResolution.xy * PI * 2.;\n    vec3 camPos = vec3(1.9 * cos(mouse.x), 0., 1.9 * sin(mouse.x));\n    vec3 camLookAt = vec3(0.);\n    mat3 cam2worldMatrix = SetCamera(camPos, camLookAt, 0.0);\n    vec3 localViewDir = normalize(vec3(uv, 1.5));\n    return color(camPos, localViewDir, cam2worldMatrix);\n}\n\n#define AA 1\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    //vec2 uv = fragCoord/iResolution.xy;\n    fragColor = vec4(0.);\n    for(int y = 0; y < AA; ++y)\n        for(int x = 0; x < AA; ++x){\n            fragColor += render(fragCoord + vec2(x, y) / float(AA));\n        }\n    \n    fragColor /= float(AA * AA);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"#define COUNT 64\n#define FARCLIP 3.\n#define BIAS .1\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\tvec2 uv = fragCoord.xy / iResolution.xy;    \n\n    vec4 norz = texture(iChannel0, uv);\n    float depth = norz.w * FARCLIP;\n    float radius = .05;\n    float scale = radius / depth;\n    \n    float ao = 0.0;\n    for(int i = 0; i < COUNT; i++){\n        vec2 randUv = (fragCoord.xy + 23.71 * float(i)) / iChannelResolution[1].xy;\n        vec3 randNor = texture(iChannel1, randUv).xyz * 2.0 - 1.0;\n        if(dot(norz.xyz, randNor) < 0.0)\n            randNor *= -1.0;\n        \n        vec2 off = randNor.xy * scale;\n        vec4 sampleNorz = texture(iChannel0, uv + off);\n        float depthDelta = depth - sampleNorz.w * FARCLIP;\n        \n        vec3 sampleDir = vec3(randNor.xy * radius, depthDelta);        \n        float occ = max(0.0, dot(normalize(norz.xyz), normalize(sampleDir)) - BIAS) / (length(sampleDir) + 1.0);\n        ao += 1.0 - occ;\n    }\n    ao /= float(COUNT);\n    \n    fragColor = vec4(vec3(ao), 1.0);\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"float normpdf(in float x, in float sigma){\n\treturn 0.39894*exp(-0.5*x*x/(sigma*sigma))/sigma;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec3 c = texture(iChannel0, fragCoord.xy / iResolution.xy).rgb;\n\tfragColor = vec4(c, 1.0);\n    //if(texture(iChannel1, fragCoord.xy / iResolution.xy).r >= 0.)\n    //if(false)\n    {\n\t\t//declare stuff\n\t\tconst int mSize = 5;\n\t\tconst int kSize = (mSize-1)/2;\n\t\tfloat kernel[mSize];\n\t\tvec3 final_colour = vec3(0.0);\n\t\t\n\t\t//create the 1-D kernel\n\t\tfloat sigma = 5.;\n\t\tfloat Z = 0.0;\n\t\tfor (int j = 0; j <= kSize; ++j){\n\t\t\tkernel[kSize+j] = kernel[kSize-j] = normpdf(float(j), sigma);\n\t\t}\n\t\t\n\t\t//get the normalization factor (as the gaussian has been clamped)\n\t\tfor (int j = 0; j < mSize; ++j){\n\t\t\tZ += kernel[j];\n\t\t}\n\t\t\n\t\t//read out the texels\n\t\tfor (int i=-kSize; i <= kSize; ++i){\n\t\t\tfor (int j=-kSize; j <= kSize; ++j){\n\t\t\t\tfinal_colour += kernel[kSize+j]*kernel[kSize+i]*texture(iChannel0, (fragCoord.xy+vec2(float(i),float(j))) / iResolution.xy).rgb;\n\t\n\t\t\t}\n\t\t}\n        fragColor = vec4(final_colour/(Z*Z), 1.);\n    }\n}","name":"Buffer C","description":"","type":"buffer"}]}