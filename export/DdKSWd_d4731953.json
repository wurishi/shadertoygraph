{"ver":"0.1","info":{"id":"DdKSWd","date":"1681804210","viewed":186,"name":"ShaderMerging","username":"Luking","description":"Merging two shaders, one of them with mouse input. Looks like a game.\n\nbased on https://stackoverflow.com/questions/61522849/shadertoy-how-to-mix-add-multiply-any-two-shaders\nhttps://www.shadertoy.com/view/ltcGDl\nhttps://www.shadertoy.com/view/ldSBRc","likes":8,"published":1,"flags":32,"usePreview":0,"tags":["shader","merge"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//based on https://stackoverflow.com/questions/61522849/shadertoy-how-to-mix-add-multiply-any-two-shaders\n// combined using\n//  shader1 https://www.shadertoy.com/view/ltcGDl\n//  shader2 https://www.shadertoy.com/view/ldSBRc\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uvA = fragCoord / iChannelResolution[0].xy;\n    vec2 uvB = fragCoord / iChannelResolution[1].xy;\n\n    // Output to screen\n    // Fragment is the sum of both gradients: red to green\n    fragColor = texture(iChannel0, uvA) + texture(iChannel1, uvB);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//originally https://www.shadertoy.com/view/ltcGDl\n\n//thank for https://www.shadertoy.com/view/MdX3Rr by iq\n\n#define PI 3.14159265359\n\n\nvec2 hash( vec2 p )\n{\n\tp = vec2( dot(p,vec2(127.1,311.7)),\n\t\t\t  dot(p,vec2(269.5,183.3)) );\n\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\nfloat noise( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n\tvec2 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( dot( hash( i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ), \n                     dot( hash( i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\n                mix( dot( hash( i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ), \n                     dot( hash( i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);\n}\n\nfloat terrainH( in vec2 p)\n{\n\n    //small\n\tfloat valS = noise(p * 0.5) + 0.5;//0~1\n    valS = 1.0 - abs(valS - 0.5) * 2.0;\n    valS = pow(valS,2.0);\n\n    //middle\n    float valM = noise(p * 0.26) + 0.5;//0~1\n    valM = 1.0 - abs(valM - 0.5) * 2.0;\n    valM = pow(valM,2.0);\n    \n    //big\n    float valB = smoothstep(0.0,1.0,noise(p * 0.2) + 0.5);//0~1\n\n    float val = valS * 0.01 + valM * 0.19 + valB * 0.8;\n\n    return val * 1.3 - 0.3;\n}\n\nfloat softShadow(in vec3 ro, in vec3 rd )\n{\n    // real shadows\t\n    float res = 1.0;\n    float t = 0.001;\n\tfor( int i=0; i<40; i++ )\n\t{\n\t    vec3  p = ro + t*rd;\n        float h = p.y - terrainH( p.xz );\n\t\tres = min( res, 16.0*h/t );\n\t\tt += h;\n\t\tif( res<0.01 ||p.y>(200.0) ) break;\n\t}\n\treturn clamp( res, 0.0, 1.0 );\n}\n\n\nfloat interesct( in vec3 ro, in vec3 rd, in float tmin, in float tmax )\n{\n    float t = tmin;\n\tfor( int i=0; i<128; i++ )\n\t{\n        vec3 pos = ro + t*rd;\n\t\tfloat h = pos.y - terrainH( pos.xz );\n\t\tif( h<(0.002*t) || t>tmax ) break;\n\t\tt += 0.5*h;\n\t}\n\treturn t;\n}\n\n\nvec3 calcNormal( in vec3 pos, float t )\n{\n    vec2  eps = vec2( 0.002*t, 0.0 );\n    return normalize( vec3( terrainH(pos.xz-eps.xy) - terrainH(pos.xz+eps.xy),\n                            2.0*eps.x,\n                            terrainH(pos.xz-eps.yx) - terrainH(pos.xz+eps.yx) ) );\n}\n\nvec3 render( in vec3 ro, in vec3 rd )\n{   \n    vec3 lightDir = normalize( vec3(-0.8,0.3,-0.3) );\n    vec3 lightColor = vec3(1.0);\n    vec3 sandColor = vec3(0.9,0.70,0.4);\n    vec3 ambientColor = vec3(0.5);\n\n    float tmin = 1.0;\n    float tmax = 30.0;\n    float t = interesct(ro,rd,tmin,tmax);\n\n    vec3 col;\n    if(t>tmax){\n        vec3 sky0 = vec3(0.8,0.7,0.5) * 1.2;\n        vec3 sky1 = vec3(0.4,0.6,0.8) * 1.2;\n        col = mix(sky0,sky1,pow(max(rd.y + 0.15,0.0),0.5));\n        col += vec3(pow(max(dot(rd,lightDir),0.0),50.0));\n    }\n    else{\n        vec3 pos = ro + t*rd;\n        \n        float shadow = softShadow(pos + lightDir *0.01,lightDir);\n        \n        vec3 normal = calcNormal( pos, t );\n        normal = normalize(normal + vec3(sin(pos.x * 100.0 + sin(pos.z * 31.0) + sin(pos.y) * 200.0) * 0.02,0,0));\n        vec3 viewDir = -rd;\n\n        float lambertian = max(dot(lightDir,normal), 0.0);\n\n        float shininess =  20.0;\n        vec3 halfDir = normalize(lightDir + viewDir);\n        float specAngle = max(dot(halfDir, normal), 0.0);\n        float specular1 = pow(specAngle, shininess);\n        float specular2 = pow(specAngle, shininess / 2.0) * noise(pos.xz * 10000.0) * 1.0f;// * pow(texture(iChannel0,pos.xz * 10.0).x,3.0);\n\n        vec3 diff = sandColor * lambertian * lightColor;\n        vec3 spec = (specular1 *0.3 + specular2 * 0.2) * lightColor;\n        vec3 ambient = ambientColor * sandColor;\n        col = shadow * (diff + spec) + ambient;\n\n    }\n    \n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time = iTime * 0.5;\n    //float yaw = time;//iMouse.x * 0.05;\n    //float pitch = 1.2;//clamp(iMouse.y * 2.0 /iResolution.y,-PI * 0.5,PI * 0.5);\n    \n    float yaw;\n    float pitch;\n    \n    if(iMouse.x == 0.0 && iMouse.y == 0.0){\n    \tyaw = time;\n    \tpitch = 1.2;        \n    }\n    else{\n        yaw = iMouse.x * 0.05;\n    \tpitch = clamp(iMouse.y  * 2.0 /iResolution.y,-PI * 0.5,PI * 0.5);\n    }\n    \n    vec2 p0 = fragCoord.xy / iResolution.xy;\n    p0.x *= iResolution.x/iResolution.y;\n    \n    vec3 ro = 1.1*vec3(2.5*sin(0.25*yaw),2.5 * cos(pitch),2.5*cos(0.25*yaw));\n    vec3 ww = normalize(vec3(0.0) - ro);\n    vec3 uu = normalize(cross( vec3(0.0,1.0,0.0), ww ));\n    vec3 vv = normalize(cross(ww,uu));\n    vec3 rd = normalize( p0.x*uu + p0.y*vv + 2.5*ww );\n\n    vec3 col = render( vec3(time,1.8,0.0), rd );\n    \n    fragColor = vec4(col,1);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[{"id":"XsXGR8","channel":0}],"code":"//originally https://www.shadertoy.com/view/ldSBRc\n\nfloat getBox(vec2 st, float left, float bottom, float width, float height) {\n    float sm = 0.002;\n    float x_range = smoothstep(left - sm, left, st.x) - smoothstep(left + width, left + width + sm, st.x);\n    float y_range = smoothstep(bottom - sm, bottom, st.y) - smoothstep(bottom + height,bottom + height + sm, st.y);\n    \n    return x_range * y_range;\n}\n\nfloat getCircle(vec2 st, vec2 center, float radius, float thickness, float sm) {\n    float distance = distance(st, center);\n    return smoothstep(radius, radius + sm, distance) - smoothstep(radius + thickness, radius + thickness + sm, distance);\n}\n\nfloat getDottedCircle(vec2 st, vec2 center, float radius, float thickness, float sm) {\n    float distance = distance(st, center);\n    float circle = smoothstep(radius, radius + sm, distance) - smoothstep(radius + thickness, radius + thickness + sm, distance);\n    \n    vec2 vector = center - st;\n    float angle = atan(vector.y, vector.x);\n    angle = ((angle * 0.5) + (3.14 * 0.5)) / 3.14;\n    circle *= step(8., mod(floor(angle / 0.001), 10.0));\n    \n    return circle;\n}\n\nmat2 rotate(in float angle) {\n    return mat2(\n                cos(angle), -sin(angle), \n                sin(angle), cos(angle)\n    \t\t);\n}\n\nvec2 getRotation(vec2 st, vec2 origin, float angle) {\n    vec2 rotatedCoord = st - vec2(origin);\n    rotatedCoord = rotate(angle) * rotatedCoord;\n    rotatedCoord += vec2(origin);\n    \n    return rotatedCoord;\n}\n\nmat2 scale(in float x, in float y) {\n    return mat2(\n        \t\tx, 0.0, \n                0.0, y\n        \t);\n}\n\nvec2 getScaling(vec2 st, vec2 origin, float x, float y) {\n    vec2 scaledCoord = st - vec2(origin);\n    scaledCoord = scale(x, y) * scaledCoord;\n    scaledCoord += vec2(origin);\n    \n    return scaledCoord;\n}\n\nfloat getInnetDial(vec2 st, float center, float radius) {\n \tfloat lineThickness = 0.002;\n    float sm = 0.003;\n    \n    float circle2 = getCircle(st, vec2(center), radius - 0.015, lineThickness, sm);\n    circle2 *= step(st.x, -0.254);\n    \n    float circle2dash1 = getBox(st, -0.254, 0.134, 0.100, lineThickness);\n    circle2 += circle2dash1;\n    float circle2dash1_2 = getBox(st, -0.204, 0.134, 0.052, lineThickness * 2.);\n    circle2 += circle2dash1_2;\n    float circle2dash2 = getBox(st, -0.288, 0.068, 0.031, lineThickness);\n    circle2 += circle2dash2;\n    float circle2dash2_2 = getBox(st, -0.247, 0.068, 0.096, lineThickness);\n    circle2 += circle2dash2_2;\n    float circle2dash3 = getBox(st, -0.350, 0.0, 0.215, lineThickness);\n    circle2 += circle2dash3;\n    float circle2dash3_2 = getBox(st, -0.19, 0.0, 0.055, lineThickness * 2.);\n    circle2 += circle2dash3_2;\n    float circle2dash3_3 = getBox(st, -0.36, 0.0, lineThickness * 2., lineThickness * 2.);\n    circle2 += circle2dash3_3;\n    float circle2dash4 = getBox(st, -0.288, -0.068, 0.031, lineThickness);\n    circle2 += circle2dash4;\n    float circle2dash4_2 = getBox(st, -0.247, -0.068, 0.096, lineThickness);\n    circle2 += circle2dash4_2;\n    \n    float circle2dash5 = getBox(st, -0.13, 0.0, 0.01, lineThickness);\n    circle2 += circle2dash5;\n    float circle2dash5_1 = getBox(st, -0.12, -0.03, lineThickness, 0.06);\n    circle2 += circle2dash5_1;\n    float circle2dash5_2 = getBox(st, -0.118, 0.03, 0.01, lineThickness);\n    circle2 += circle2dash5_2;\n    float circle2dash5_3 = getBox(st, -0.118, -0.03, 0.01, lineThickness);\n    circle2 += circle2dash5_3;\n    \n    return circle2;\n}\n\nfloat getSideLine(vec2 st, float left, float top, float lineThickness) {\n    float lineEdgeLength = 0.008;\n    float sideLine = getBox(st, left, top, lineThickness, 0.236);\n    sideLine += getBox(st, left + lineThickness, top + 0.234, lineEdgeLength, lineThickness);\n    sideLine += getBox(st, left + lineThickness, top, lineEdgeLength, lineThickness);\n    sideLine += getBox(st, left + lineThickness + 0.006, 0.0, lineThickness, lineThickness);\n    \n    return sideLine;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 st = fragCoord.xy / iResolution.xy;\n    st -= 0.5;\n    st.x *= iResolution.x/iResolution.y;\n\tfragColor = vec4(st,0.5+0.5*sin(iTime),1.0);\n    \n    float center = 0.0;\n    float radius = 0.3;\n    float sm = 0.003;\n    float lineThickness = 0.002;\n    float angle = atan(st.y, st.x);\n    angle = (angle + 3.1416) / (2.0 * 3.1416);\n\n    vec3 color = vec3(0.);\n    \n    st = getRotation(st, vec2(center), -iTime);\n    float circle1 = getCircle(st, vec2(0.), radius, lineThickness, sm);\n    circle1 *= (step(st.x, -0.25) + step(0.25, st.x));\n    st = getRotation(st, vec2(center), iTime);\n    \n    \n    \n    float dottedCircle = getDottedCircle(st, vec2(center), radius + 0.015, lineThickness + 0.002, sm);\n    dottedCircle *= (\n        (step(0.02, angle) - step(0.08, angle)) +\n        (step(0.09, angle) - step(0.16, angle)) +\n        (step(0.32, angle) - step(0.4, angle)) +\n        (step(0.41, angle) - step(0.48, angle)) +\n        \n        (step(0.52, angle) - step(0.59, angle)) +\n        (step(0.6, angle) - step(0.66, angle)) +\n        (step(0.83, angle) - step(0.89, angle)) +\n        (step(0.9, angle) - step(0.98, angle))\n    );\n    \n    float timeFactor = 3.14 * 0.2 * cos(iTime * 0.5);\n    st = getRotation(st, vec2(center), timeFactor);\n    float dial1 = getDottedCircle(st, vec2(center), radius + 0.04, lineThickness + 0.01, sm);\n    \n    float dial2 = getDottedCircle(st, vec2(center), radius + -0.04, lineThickness + 0.01, sm);\n    dial2 += getDottedCircle(st, vec2(center), radius + -0.02, lineThickness + 0.001, sm);\n    st = getRotation(st, vec2(center), -timeFactor);\n    \n    \n    dial1 *= (step(0.662, angle) - step(0.84, angle));\n    dial2 *= (step(0.682, angle) - step(0.82, angle));\n    \n    \n    float sideLine = getSideLine(st, -0.4, -0.116, 0.002);\n    st = getScaling(st, vec2(0.0), -1.0, 1.0);\n    sideLine += getSideLine(st, -0.4, -0.116, 0.002);\n    st = getScaling(st, vec2(0.0), -1.0, 1.0);\n    \n    st = getRotation(st, vec2(center), 3.14 * 0.1 * sin(iTime));\n    \n    float innerDial = getInnetDial(st, center, radius);\n    st = getScaling(st, vec2(0.0), -1.0, 1.0);\n    innerDial += getInnetDial(st, center, radius);\n    st = getScaling(st, vec2(0.0), -1.0, 1.0);\n    \n    \n    st = getRotation(st, vec2(center), 3.14 / 4.);\n    float box = getBox(st, -0.068, -0.057, 0.004, 0.115);\n    box += getBox(st, 0.066, -0.057, 0.004, 0.115);\n    box += getBox(st, -0.057, 0.070, 0.115, 0.004);\n    box += getBox(st, -0.057, -0.070, 0.115, 0.004);\n    box -= getBox(st, -0.036, -0.036, 0.072, 0.072);\n    \n    box += getBox(st, -0.05, -0.05, 0.006, 0.006);\n    box += getBox(st, 0.048, -0.05, 0.006, 0.006);\n    box += getBox(st, 0.048, 0.046, 0.006, 0.006);\n    box += getBox(st, -0.05, 0.046, 0.006, 0.006);\n    \n    float innerBox = getBox(st, -0.04, -0.04, 0.08, 0.08);\n    innerBox -= getBox(st, -0.036, -0.036, 0.072, 0.072);\n    innerBox += getBox(st, -0.07, -0.07, 0.006, 0.006);\n    innerBox += getBox(st, 0.066, -0.07, 0.006, 0.006);\n    innerBox += getBox(st, 0.066, 0.066, 0.006, 0.006);\n    innerBox += getBox(st, -0.07, 0.066, 0.006, 0.006);\n    st = getRotation(st, vec2(center), -3.14 / 4.);\n    \n    st = getRotation(st, vec2(center), -3.14 * 0.1 * sin(iTime));\n    \n    float sideMarks = step(18., mod(floor((st.y + 0.1 * sin(iTime)) / 0.002), 20.0));\n    sideMarks *= (\n        (step(-0.44, st.x) - step(-0.415, st.x)) +\n        (step(0.415, st.x) - step(0.44, st.x))\n    );\n    sideMarks *= (step(-0.12, st.y) - step(0.12, st.y));\n    \n    float sideMarksBox = getBox(st, -0.45, -0.015, 0.04, 0.03);\n    sideMarksBox -= getBox(st, -0.448, -0.013, 0.036, 0.026);\n    st = getScaling(st, vec2(0.0), -1.0, 1.0);\n    sideMarksBox += getBox(st, -0.45, -0.015, 0.04, 0.03);\n    sideMarksBox -= getBox(st, -0.448, -0.013, 0.036, 0.026);\n    st = getScaling(st, vec2(0.0), -1.0, 1.0);\n    \n    sideMarksBox += getBox(st, -0.0025, 0.33, 0.005, 0.005);\n    sideMarksBox += getBox(st, -0.0025, 0.25, 0.005, 0.005);\n    \n    box *= (0.2 + 0.8 * pow(abs(sin(iTime * 4.)), 2.));\n\n    color += vec3(1.000,0.345,0.287) * circle1;\n    color += vec3(0.39,0.61,0.65) * dottedCircle;\n    color += vec3(0.39,0.61,0.65) * dial1;\n    color += vec3(0.39,0.61,0.65) * dial2;\n    color += vec3(0.39,0.61,0.65) * innerDial;\n    color += vec3(0.39,0.61,0.65) * sideLine;\n    color += vec3(0.39,0.61,0.65) * sideMarks;\n    color += vec3(0.39,0.61,0.65) * sideMarksBox;\n    color += vec3(0.995,0.425,0.003) * box;\n    color += vec3(0.96, 0.98, 0.8) * innerBox;\n    \n    fragColor = vec4(color,1.0);\n}","name":"Buffer B","description":"","type":"buffer"}]}