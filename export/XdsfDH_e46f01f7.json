{"ver":"0.1","info":{"id":"XdsfDH","date":"1496097587","viewed":88,"name":"mattdw-raytracer","username":"mattdw","description":"raytracer experimental","likes":1,"published":1,"flags":32,"usePreview":0,"tags":["scene"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define DATA_BUFFER iChannel0\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    fragColor = texture(DATA_BUFFER, uv);\n  \n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define BUFFER iChannel0\n#define SPHERE_COUNT 6\n#define LIGHT_COUNT 3\n#define BOUNCE_MAX 4\n\nstruct Material {\n    vec3 diffuse;\n    float reflectivity;\n} material;\n\nstruct Sphere {\n    vec3 pos;\n    float radius;\n    Material material;\n} sphere;\n    \nstruct Ray {\n    vec3 start;\n    vec3 dir;\n} ray;\n\nstruct Light {\n    vec3 pos;\n    vec3 intensity;\n} light;\n\n\nbool intersectRaySphere(in Ray r, in Sphere s, inout float t) {\n    \n    float A = dot(r.dir, r.dir);\n    \n    vec3 dist = r.start - s.pos;\n    \n    float B = 2.0 * dot(r.dir, dist);\n    \n    float C = dot(dist, dist) - (s.radius * s.radius);\n    \n    float discr = B * B - 4.0 * A * C;\n    \n    \n    if (discr < 0.0) {\n        return false;\n    } else {\n        float sqrtdiscr = sqrt(discr);\n        float t0 = (-B + sqrtdiscr)/2.0;\n        float t1 = (-B - sqrtdiscr)/2.0;\n        \n        if (t0 > t1) {\n            t0 = t1;\n        }\n       \n        if (t0 > 0.001 && t0 < t) {\n            t = t0;\n            return true;\n        } else {\n            return false;\n        }\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    //uv.y /= 1.7;\n    uv.y = uv.y / 1.7 + 0.15;\n    vec4 c = texture(BUFFER, uv);\n    \n    Material mats[5];\n    mats[0].diffuse = vec3(1.0);\n    mats[0].reflectivity = 0.07;\n    \n    mats[1].diffuse = vec3(0.3, 0.25, 0.1);\n    mats[1].reflectivity = 0.1;\n    \n    mats[2].diffuse = vec3(0.1, 0.3, 0.7);\n    mats[2].reflectivity = 0.05;\n    \n    mats[3].diffuse = vec3(0.05);\n    mats[3].reflectivity = 0.05;\n    \n    mats[4].diffuse = vec3(.97, .97, .99);\n    mats[4].reflectivity = 0.95;\n\n    Sphere s[SPHERE_COUNT];\n    s[0].pos = vec3(0.5, 0.5, 0.5);\n    s[0].radius = 0.1;\n    s[0].material = mats[0];\n\n    s[1].pos = vec3(0.5 + sin(iTime * 1.0) * 0.3, 0.25, 0.25);\n    s[1].radius = 0.1;\n    s[1].material = mats[1];\n    \n    s[2].pos = vec3(0.55, 0.55 + sin(iTime) * 0.2, 0.55 + cos(iTime) * 0.2);\n    s[2].radius = 0.1;\n    s[2].material = mats[2];\n    \n    s[3].pos = vec3(0.56 + sin(iTime * 0.4) * 0.4, 0.55, 0.55 + cos(iTime * 0.4) * 0.3);\n    s[3].radius = 0.15;\n    s[3].material = mats[4];\n    \n    s[4].pos = vec3(0.5, 0.5, 13.);\n    s[4].radius = 1.;\n    s[4].material = mats[3];\n    \n    s[5].pos = vec3(1.0, 0.5, -1.1);\n    s[5].radius = 1.;\n    s[5].material = mats[3];\n    \n    Light lights[LIGHT_COUNT];\n    lights[0].pos = vec3(0.3, 0., 0.);\n    lights[0].intensity = vec3(0.5);\n    \n    lights[1].pos = vec3(.5 + sin(iTime)* -2., 2., .5 + cos(iTime) * 2.);\n    lights[1].intensity = vec3(0.25, 0.15, 0.2);\n    \n    lights[2].pos = vec3(0.25, 0.75, 1.0);\n    lights[2].intensity = vec3(1.0, 2.0, 2.0);\n    \n    \n    vec4 finalColor = vec4(0., 0., 0., 1.);\n\tint sampleCount = 0;\n    for (int rx=-1; rx<2; rx+=2) {\n        for (int ry=-1; ry<2; ry+=2) {\n    \n            Ray r;\n            r.start = vec3(\n               uv.x + float(rx) * (.25 / iResolution.x),\n               uv.y + float(ry) * (.25 / iResolution.y),\n               0.0\n            );\n            r.dir = vec3(0.0, 0.0, 1.0);\n            vec3 origDir = r.dir.xyz;\n\n            float coef = 1.0;\n            int level = 0;\n            fragColor = vec4(0.,0.,0.,1.);\n\n            for (int bounceCount=0; bounceCount < BOUNCE_MAX; bounceCount++) {\n                int hitSphereIndex = -1;\n                Sphere hitSphere;\n                bool rayHit = false;\n\n                float t;\n                t = 1000.0;\n                for (int i=0; i<SPHERE_COUNT; i++) {\n                    bool hit = intersectRaySphere(r, s[i], t);\n                    if (hit) {\n                        hitSphereIndex = i;\n                        hitSphere = s[i];\n                        rayHit = true;\n                    }\n                }\n\n                if (!rayHit) break;\n\n                vec3 scaled = r.dir * t;\n                vec3 newStart = r.start + scaled;\n                vec3 normal = newStart - hitSphere.pos;\n                float temp = dot(normal, normal);\n                if (temp == 0.0) {\n                    fragColor = vec4(0.0);\n                    break;\n                }\n\n                temp = 1.0 / sqrt(temp);\n                normal = normal * temp;\n\n                Material currentMat = hitSphere.material;\n                float schlick = 1.45 + (1. - 1.45) * pow(1. - dot(origDir, normal), 5.);\n                schlick = clamp(schlick, 0., 1.);\n                // split coef into reflective and diffuse parts\n                float refl = clamp(schlick * coef, currentMat.reflectivity, 1.0);\n                float diff = coef - refl;\n                //fragColor.rgb = vec3(refl);\n                coef = refl;\n\n                for (int lightIndex=0; lightIndex < LIGHT_COUNT; lightIndex++) {\n                    Light currentLight = lights[lightIndex];\n\n                    vec3 dist = currentLight.pos - newStart;\n                    if (dot(normal, dist) <= 0.0) continue;\n\n                    Ray lightRay;\n                    lightRay.start = newStart;\n                    lightRay.dir = (1.0/t) * dist;\n\n\n                    float lambert = dot(lightRay.dir, normal);\n                    //fragColor.rgb += lambert * currentLight.intensity * currentMat.diffuse;\n\n                    fragColor.rgb += lambert * diff * currentLight.intensity * currentMat.diffuse;\n                    //fragColor.rgb = vec3(schlick);\n                }\n\n                //coef *= currentMat.reflectivity;\n\n                r.start = newStart;\n                float reflection = 2.0 * dot(r.dir, normal);\n                vec3 tmp = reflection * normal;\n                r.dir = r.dir - tmp;\n                //r.dir += (texture(iChannel1, uv + iTime * 0.1).rgb - 0.4) * 0.1;\n                level += 1;\n\n                if (coef <= 0.0) {\n                    break;\n                }   \n            }\n\n            if (fragColor.r < 0.) {\n                fragColor.r = 0.;\n            }\n\n            //fragColor = mix(c, fragColor, 0.5);\n            finalColor = ((finalColor * float(sampleCount)) + fragColor) / float(sampleCount + 1);\n            sampleCount++;\n            \n        }\n    }\n    fragColor = finalColor;\n}\n","name":"Buf A","description":"","type":"buffer"}]}