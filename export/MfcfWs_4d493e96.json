{"ver":"0.1","info":{"id":"MfcfWs","date":"1733618296","viewed":27,"name":"Convergencia ","username":"as7rea","description":"único.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["fractal","luz","animacin"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Normalización de coordenadas con la resolución proporcionada por el entorno\nvec2 normalizeCoordinates(vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;  // Normaliza las coordenadas al rango [0, 1]\n    uv = uv * 2.0 - 1.0;                   // Escala al rango [-1, 1]\n    uv.x *= iResolution.x / iResolution.y; // Ajuste de proporción\n    return uv;\n}\n\nvec3 createFractal(vec2 uv) {\n    vec3 color = vec3(0.0); // Color inicial\n    float scale = 1.0;      // Escala inicial\n\n    for (int i = 0; i < 5; i++) {           // Bucle para iterar el fractal\n        uv = abs(uv) / dot(uv, uv) - 1.0;   // Transformación fractal\n        float dist = length(uv);            // Distancia al origen\n        color += vec3(\n            sin(dist * 10.0), \n            cos(dist * 15.0), \n            sin(dist * 20.0)\n        ) / scale;                          // Color basado en la distancia\n        scale *= 1.5;                       // Incremento de escala\n    }\n\n    color = color * 0.8 + vec3(0.3, 0.1, 0.05) * length(uv); // Ajuste de tonos\n    return color;\n}\n\nvec3 lightingEffect(vec2 uv) {\n    vec3 pos = vec3(uv, 1.0);                                  // Espacio 3D\n    float light = max(0.0, dot(normalize(pos), vec3(0.0, 0.0, 1.0))); // Luz basada en normal\n    return vec3(light) * 0.5;                                  // Intensidad de luz\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = normalizeCoordinates(fragCoord); // Coordenadas normalizadas\n    float t = iTime * 0.5;                     // Control de animación\n    float offset = sin(t) * 0.5;               // Separación animada\n\n    vec3 color1 = createFractal(uv + vec2(0.0, offset)); // Fractal desplazado hacia arriba\n    vec3 color2 = createFractal(uv - vec2(0.0, offset)); // Fractal desplazado hacia abajo\n\n    vec3 background = mix(vec3(0.02, 0.03, 0.05), vec3(0.0), uv.y); // Gradiente de fondo\n    vec3 finalColor = background + color1 + color2;                 // Mezcla final\n\n    fragColor = vec4(finalColor + lightingEffect(uv), 1.0);          // Salida final\n}\n","name":"Image","description":"","type":"image"}]}