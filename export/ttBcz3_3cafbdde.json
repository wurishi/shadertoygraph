{"ver":"0.1","info":{"id":"ttBcz3","date":"1594935243","viewed":354,"name":"Boiling Plasma Bowl","username":"sirleto","description":"To practice i made a variation on iq's Hell shader: https://www.shadertoy.com/view/MdfGRX\nintentionally i removed all tricks hiding visual shortcommings, so i can see the banding artifacts, etc. dithering would hide most problems.","likes":30,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//sirleto 2020-07-16\n//To practice i made a variation on iq's Hell shader: https://www.shadertoy.com/view/MdfGRX\n//intentionally i removed all tricks hiding visual shortcommings, \n//so i can see the banding artifacts, etc. dithering would hide most problems.\n//License from my side is CCBY Attribution only\n\n//nearly original from iq\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\t\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\tvec2 rg = textureLod( iChannel0, (uv+ 0.5)/256.0, 0.0 ).yx;\n\treturn mix( rg.x, rg.y, f.z );\n}\n\n//nearly original from iq, modifed some values and removed finer octaves\n//which make my result now appear more smooth (more blurred) than iq's original\nvec4 map( vec3 p )\n{\n\tfloat den = 0.5 - p.y;\n\n    // twist space\t\n\tfloat co = cos(den - 0.0125*iTime);\n\tfloat si = sin(den - 0.00125*iTime);\n\tp.xz = mat2(co,-si,si,co)*p.xz;\n    \n    // smoke\t\n\tfloat f;\n\tvec3 q = p                          - vec3(0.0,1.0,0.0)*iTime*0.11;\n    f  = 0.50000*noise( q ); q = q*2.01 - vec3(0.0,1.0,0.0)*iTime*0.12;\n    f += 0.25000*noise( q ); q = q*2.02 - vec3(0.0,1.0,0.0)*iTime*0.13;\n    f += 0.12500*noise( q ); q = q*2.03 - vec3(0.0,1.0,0.0)*iTime*0.14;\n    f += 0.06250*noise( q );\n\n\tden = clamp( den + 4.25*f, 0.0, 1.0 );\n    den*=den;\n\t\n\tvec3 col = mix( vec3(0.9,0.8,1.0), vec3(0.065,0.075,0.25), sqrt(den)-0.2 );\n\t\n\treturn vec4( col, den );\n}\n\n//added sphere shape, which i also learned from one of inigos shaders\nfloat sphere(vec3 p, vec4 spr)\n{\n\treturn length(spr.xyz-p) - spr.w;\n}\n\n//checking the sphere with an IF is definitely not the smartest step performance wise speaking, \n//still running both great on my older office notebook aswell as latest nvida RTX card.\nvec3 raymarch( in vec3 ro, in vec3 rd )\n{\n\tvec4 sum = vec4( 0.0 );\n\n\tfloat t = 0.0;\n   \n\tfor( int i=0; i<200; i++ )\n\t{\n\t\tif( sum.a > 0.99 ) break;\n\t\t\n\t\tvec3 pos = ro + t*rd;\n        vec3 sphere_pos = pos * 1.1 + 0.1 * pos * noise(pos);\n        \n        float insideSphere = sphere(sphere_pos, vec4(0,1.5,0,2.5));\n        \n    \tif(insideSphere < 0.0)\n        {   \n            vec4 col = map( pos );\n\n            col.xyz *= mix( 3.1*vec3(0.99,0.01,1.0), vec3(0.5,0.6,0.55), clamp( (pos.y-0.1)/1.6, 0.0, 1.0 ) );\n\n            col.a *= 0.9;\n            col.rgb *= col.a;\n\n            sum = sum + col*(1.0 - sum.a);\t\n        }\n        \n\t\tt += 0.04;\n\t}\n\n\treturn clamp( sum.xyz, 0.0, 1.0 );\n}\n\n//intentionally very clean and empty scene just on black and without much stylishness\n//(no vignetting, no multipass postprocess, no bloom etc, neither somewhere inside the marching2color function nor added as post)\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 q = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0*q;\n    p.x *= iResolution.x/ iResolution.y;\n\t\n    vec2 mo = iMouse.xy / iResolution.xy;\n    if( iMouse.w<=0.00001 ) mo=vec2(0.0);\n\t\n    // camera\n    float dist = 5.0;\n    float rot_x = sin(mo.x*1.5) * dist;\n    float rot_y = cos(-mo.y*1.5) * dist * 0.7;\n    vec3 ro = vec3(rot_x, dist*1.2 - rot_y + dist * 0.3, dist-abs(rot_x));\n\tvec3 ta = vec3(0, 1.5, 0);\n\tfloat cr = .0;\n\t\n\t// build ray\n    vec3 ww = normalize( ta - ro);\n    vec3 uu = normalize(cross( vec3(sin(cr),cos(cr),0.0), ww ));\n    vec3 vv = normalize(cross(ww,uu));\n    vec3 rd = normalize( p.x*uu + p.y*vv + 2.0*ww );\n\t\n    // raymarch\t\n\tvec3 col = raymarch( ro, rd );\n\t\n\t// contrast\t\n\tcol = col*col*(2.0-col);\n\tcol *= pow( 100.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.1 );\n\t\n    fragColor = vec4( col, 1.0 );\n}\n","name":"Image","description":"","type":"image"}]}