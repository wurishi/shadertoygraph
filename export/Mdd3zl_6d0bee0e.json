{"ver":"0.1","info":{"id":"Mdd3zl","date":"1452587596","viewed":348,"name":"Metaball snake","username":"TambakoJaguar","description":"I tried to program this \"Metaball snake\" which follows a double sinus curve, but it is extremely slow. Do you have any idea how to optimize the code? Thanks for any help.","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["3d","raymarching","test","snake","hexagon","sinus","shapes","fresnel","mataballs","floorreflection"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","previewfilepath":"/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4df3Rr","filepath":"/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","previewfilepath":"/media/ap/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3Rr","filepath":"/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","previewfilepath":"/media/ap/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[],"code":"/*\n\"Sine metaballs\" by Emmanuel Keller aka Tambako - December 2015\nLicense Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\nContact: tamby@tambako.ch\n*/\n\n#define pi 3.141593\n\nstruct Lamp\n{\n  vec3 position;\n  vec3 color;\n  float intensity;\n  float attenuation;\n};\n\nstruct RenderData\n{\n  vec3 col;\n  vec3 pos;\n  vec3 norm;\n  int objnr;\n};\n    \nconst int nbBalls = 10;\nconst float bSize0 = 1.;\nconst float btShift = 0.26;\nconst float btSFact = 0.94;\nconst float bmovamp = 1.8;\n    \nLamp lamps[3];\n\nvec3 campos = vec3(0., 3., 15.);\nvec3 camdir = vec3(0., -0.29, -1.);\nfloat fov = 2.8;\n\nconst vec3 ambientColor = vec3(0.1, 0.4, 0.9);\nconst float ambientint = 0.17;\n\nvec3 colors[3];\n\n//#define shadow\n#define floorref\n#define ambocc\n#define specular\nconst float specint = 0.27;\nconst float specshin = 11.;\nconst float aoint = 1.5;\nconst float shi = 0.8;\nconst float shf = 0.9;\n\nconst float normdelta = 0.002;\nconst float maxdist = 80.;\n\nconst float flpos = 3.2;\n\nvec4 hex;\nconst float hexts = 1.9;\nconst float hexth = 0.1;\nconst float hexbw = 0.15;\n\n// Antialias. Change from 1 to 2 or more AT YOUR OWN RISK! It may CRASH your browser while compiling!\nconst float aawidth = 0.8;\nconst int aasamples = 1;\n\nvec2 rotateVec(vec2 vect, float angle)\n{\n    vec2 rv;\n    rv.x = vect.x*cos(angle) + vect.y*sin(angle);\n    rv.y = vect.x*sin(angle) - vect.y*cos(angle);\n    return rv;\n}\n\n// From https://www.shadertoy.com/view/Xd2GR3\nvec4 hexagon(vec2 p) \n{\n\tvec2 q = vec2( p.x*2.0*0.5773503, p.y + p.x*0.5773503 );\n\t\n\tvec2 ppi = floor(q);\n\tvec2 pf = fract(q);\n\n\tfloat v = mod(ppi.x + ppi.y, 3.0);\n\n\tfloat ca = step(1.0,v);\n\tfloat cb = step(2.0,v);\n\tvec2  ma = step(pf.xy,pf.yx);\n\t\n    // distance to borders\n\tfloat e = dot( ma, 1.0-pf.yx + ca*(pf.x+pf.y-1.0) + cb*(pf.yx-2.0*pf.xy) );\n\n\t// distance to center\t\n\tp = vec2( q.x + floor(0.5+p.y/1.5), 4.0*p.y/3.0 )*0.5 + 0.5;\n\tfloat f = length( (fract(p) - 0.5)*vec2(1.0,0.85) );\t\t\n\t\n\treturn vec4( ppi + ca - cb*ma, e, f );\n}\n\nvec3 getHexagonColor(vec4 hex, float nbcols, vec3 pos)\n{\n    colors[0] = vec3(.95, .88, .75);\n    colors[1] = vec3(.6, .7, .8);\n    colors[2] = vec3(.75, .95, .3);\n    \n    int colnr = int(mod(hex.x, nbcols));\n    /*vec3 color = vec3(mod(colnr, 3.)==0., mod(colnr, 3.)==1., mod(colnr, 3.)==2.);\n    if (colnr>2.)\n        color = vec3(1.) - color;\n    \n    vec3 color2 = vec3(0.5*color.r + 0.3*color.g + 0.7*color.b,\n                       0.3*color.r + 0.7*color.g + 0.4*color.b,\n                       0.8*color.r + 0.5*color.g + 0.3*color.b);*/\n    \n    vec3 color2 = colnr==0?colors[0]*(0.25 + 0.75*texture(iChannel0, 0.2*pos.xz).rgb):(colnr==1?\n                           colors[1]*(0.25 + 0.75*texture(iChannel1, 0.2*pos.xz).rgb):\n                           colors[2]*(0.25 + 0.75*texture(iChannel2, 0.2*pos.xz).rgb));\n    \n    return color2;\n}\n\nfloat getHexagonHeight(vec4 hex, float borderw)\n{\n    return -1. + 2.*smoothstep(-borderw, borderw, hex.z);\n    //return -2.5 + 2.*smoothstep(-borderw, borderw, hex.z) + 0.5*pow(smoothstep(0., borderw*2.7, hex.w), 2.);\n}\n\nvec3 getObjPosition(float time)\n{    \n   float x = sin(time*1.05);\n   float y = .8*sin(time);\n   float z = sin(time*1.15 + radians(90.));\n    \n   x+= .2*sin(time*2.5 + radians(45.));\n   y+= .4*sin(time*1.5 + radians(20.));\n   z+= .3*sin(time*2.2);\n\n   x+= .03*sin(time*4.5 + radians(10.));\n   y+= .05*sin(time*4.2 + radians(90.));\n   z+= .07*sin(time*5.5);\n\n   return vec3(x, y, z);\n}\n\nfloat floorm(vec3 pos)\n{\n  \thex = hexagon(pos.xz/hexts);\n   \tfloat hexy = hex.x-2.*hex.y;\n   \tfloat h = hexth*(getHexagonHeight(hex, hexbw) - 1.);\n    return hexy<32.?pos.y + flpos - h:500.;\n}\n\n// From https://www.shadertoy.com/view/ld2GRz\nfloat sdMetaBalls(vec3 pos, bool nofloor)\n{\n\tfloat m = 0.0;\n\tfloat p = 0.0;\n\tfloat dmin = 1e20;\n\t\t\n\tfloat h = 1.0; // track Lipschitz constant\n\t\n\tfor( int i=0; i<nbBalls; i++ )\n\t{\n\t\t// bounding sphere for ball\n        float fact = pow(btSFact, float(i));\n        vec3 oPos = bmovamp*getObjPosition(iTime - float(i)*btShift*fact);\n        float db = distance( oPos , pos );\n        float size = bSize0*fact;\n        if( db < size )\n    \t{\n    \t\tfloat x = db/size;\n    \t\tp += 1.0 - x*x*x*(x*(x*6.0-15.0)+10.0);\n\t    \tm += 1.0;\n    \t\th = max( h, 0.5333*size );\n\t    }\n\t    else // bouncing sphere distance\n\t    {\n    \t\tdmin = min( dmin, db - size );\n    \t}\n\t}\n    float d = dmin + 0.1;\n\t\n\tif( m>0.5 )\n\t{\n\t\tfloat th = 0.2;\n\t\td = h*(th-p);\n\t}\n\t\n\treturn min(d, nofloor?100.:floorm(pos));\n}\n\nfloat map(vec3 pos, bool nofloor)\n{\n    return sdMetaBalls(pos, nofloor);\n    \n    float d = 0.;\n    for (int b=0; b<nbBalls; b++)\n    {\n        vec3 oPos = bmovamp*getObjPosition(iTime - float(b)*btShift); //iTime\n        float size = (bSize0 - 1.)*pow(btSFact, float(b));\n        d+= size/dot(pos - oPos, pos - oPos);\n    }   \n    return min(1. - d, nofloor?100.:floorm(pos));\n}\n\nfloat trace(vec3 cam, vec3 ray, float maxdist, bool nofloor) \n{\n    float t = 2.;\n  \tfor (int i = 0; i < 75; ++i)\n    {\n    \tvec3 pos = ray*t + cam;\n    \tfloat dist = map(pos, nofloor);\n        if (dist>maxdist || abs(dist)<0.02)\n            break;\n        t+= dist*(t>20.?1.:0.6);\n  \t}\n  \treturn t;\n}\n\n// From https://www.shadertoy.com/view/ld2GRz\nvec3 norMetaBalls(vec3 pos, float e)\n{\n\tvec3 nor = vec3( 0.0, e, 0.0 );\n\t\t\n\tfor( int i=0; i<nbBalls; i++ )\n\t{\n        float fact = pow(btSFact, float(i));\n        vec3 oPos = bmovamp*getObjPosition(iTime - float(i)*btShift*fact);\n        float db = distance( oPos , pos );\n        float size = bSize0*fact;\n\t\tfloat x = clamp( db/size, 0.0, 1.0 );\n\t\tfloat p = x*x*(30.0*x*x - 60.0*x + 30.0);\n\t\tnor += normalize( pos - oPos ) * p / size;\n\t}\n\t\n\treturn normalize( nor );\n}\n\n// From https://www.shadertoy.com/view/MstGDM\nvec3 getNormal(vec3 pos, float e)\n{\n    if (pos.y>-flpos + 0.1)\n        return norMetaBalls(pos, e);\n    \n    vec2 q = vec2(0, e);\n    return normalize(vec3(floorm(pos + q.yxx) - floorm(pos - q.yxx),\n                          floorm(pos + q.xyx) - floorm(pos - q.xyx),\n                          floorm(pos + q.xxy) - floorm(pos - q.xxy)));\n}\n\nvec3 floor_color(vec3 pos)\n{\n    return getHexagonColor(hex, 3., pos);\n}\n\nvec3 obj_color(vec3 norm, vec3 pos)\n{\n    float cp = dot(cross(norm.xyz, norm.zxy), norm.yzx) - 0.2;\n    return mix(vec3(1., 1., 0.), vec3(1., 0., 1.), cp);\n}\n\nvec3 sky_color(vec3 ray)\n{\n    return ambientColor + vec3(0.4, 0.3, 0.05)*2.8*(0.53-atan(ray.y)); \n}\n\n// From https://www.shadertoy.com/view/Xds3zN;\nfloat softshadow(vec3 ro, vec3 rd, float mint, float tmax)\n{\n\tfloat res = 1.0;\n    float t = mint;\n    for(int i=0; i<16; i++)\n    {\n    \tfloat h = map(ro + rd*t, true);\n        res = min( res, 8.0*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( h<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\nfloat hash( float n ){\n\treturn fract(sin(n)*3538.5453);\n}\n\nfloat calcAO( in vec3 p, in vec3 n, float maxDist, float falloff ){\n\tfloat ao = 0.0;\n\tconst int nbIte = 5;\n\tfor( int i=0; i<nbIte; i++ )\n\t{\n\t\tfloat l = hash(float(i))*maxDist;\n\t\tvec3 rd = n*l;\n\t\tao += (l - map( p + rd, false )) / pow(1.+l, falloff);\n\t}\n\treturn clamp( 1.35*(1.-ao/float(nbIte)), 0., 1.);\n}\n\n// Fresnel reflectance factor through Schlick's approximation: https://en.wikipedia.org/wiki/Schlick's_approximation\nfloat fresnel(vec3 ray, vec3 norm, float n2)\n{\n   float n1 = 1.; // air\n   float angle = acos(-dot(ray, norm));\n   float r0 = dot((n1-n2)/(n1+n2), (n1-n2)/(n1+n2));\n   float r = r0 + (1. - r0)*pow(1. - cos(angle), 5.);\n   return r;\n}\n\nvec3 lampShading(Lamp lamp, vec3 norm, vec3 pos, vec3 ocol)\n{\n\tvec3 pl = normalize(lamp.position - pos);\n    float dlp = distance(lamp.position, pos);\n    vec3 pli = pl/pow(1. + lamp.attenuation*dlp, 2.);\n      \n    // Diffuse shading\n    vec3 col = ocol*normalize(lamp.color)*lamp.intensity*clamp(dot(norm, pli), 0., 1.);\n    \n    // Specular shading\n    #ifdef specular\n    if (dot(norm, lamp.position - pos) > 0.0)\n        col+= vec3(1., 0.7, 0.3)*normalize(lamp.color)*lamp.intensity*specint*pow(max(0.0, dot(reflect(pl, norm), normalize(pos - campos))), specshin);\n    #endif\n    \n    // Softshadow\n    #ifdef shadow\n    col*= shi*softshadow(pos, normalize(lamp.position - pos), shf, 6.) + 1. - shi;\n    #endif\n    \n    return col;\n}\n\nvec3 lampsShading(vec3 norm, vec3 pos, vec3 ocol)\n{\n    vec3 col = vec3(0.);\n    for (int l=0; l<3; l++) // lamps.length()\n        col+= lampShading(lamps[l], norm, pos, ocol);\n    \n    return col;\n}\n\n// From https://www.shadertoy.com/view/lsSXzD, modified\nvec3 GetCameraRayDir(vec2 vWindow, vec3 vCameraDir, float fov)\n{\n\tvec3 vForward = normalize(vCameraDir);\n\tvec3 vRight = normalize(cross(vec3(0.0, 1.0, 0.0), vForward));\n\tvec3 vUp = normalize(cross(vForward, vRight));\n    \n\tvec3 vDir = normalize(vWindow.x * vRight + vWindow.y * vUp + vForward * fov);\n\n\treturn vDir;\n}\n\nRenderData trace0(vec3 tpos, vec3 ray, bool nofloor)\n{\n    float tx = trace(tpos, ray, maxdist, nofloor);\n    vec3 col;\n    int objnr;\n    \n    vec3 pos = tpos + tx*ray;\n    vec3 norm;\n    if (tx<maxdist*0.65)\n    {\n        norm = getNormal(pos, normdelta);\n\n        // Coloring\n        if (pos.y<=-flpos+0.025)\n        {\n           col = floor_color(pos);\n           objnr = 1;\n        }\n        else\n        {\n           col = obj_color(norm, pos);\n           objnr = 2;\n        }\n      \n        // Shading\n        col = ambientColor*ambientint + lampsShading(norm, pos, col);\n        \n        // Ambient occlusion\n        #ifdef ambocc\n        col*= 1. - aoint + aoint*vec3(calcAO(pos, norm, 7., 1.1));\n        //col = vec3(calcAO(pos, norm, 7., 1.1));\n        #endif\n  }\n  else\n  {\n      // Sky\n      col = sky_color(ray);\n      objnr = 3;\n  }\n  return RenderData(col, pos, norm, objnr);\n}\n\nvec4 render(vec2 fragCoord)\n{\n  lamps[0] = Lamp(vec3(-1., 4.5, 10.), vec3(1., 1., 1.), 7.5, 0.1);\n  lamps[1] = Lamp(vec3(9., -0.5, 6.), vec3(1.0, 0.98, 0.9), 3.8, 0.1);\n  lamps[2] = Lamp(vec3(-8., 1.8, -5.), vec3(1.0, 0.7, 0.7), 2., 0.1);\n    \n  vec2 uv = fragCoord.xy / iResolution.xy; \n  uv = uv*2.0 - 1.0;\n  uv.x*= iResolution.x / iResolution.y;\n\n  vec3 ray = GetCameraRayDir(uv, camdir, fov);\n    \n  RenderData traceinf = trace0(campos, ray, false);\n  vec3 col = traceinf.col;\n  #ifdef floorref\n  if (traceinf.objnr==1)\n  {\n     RenderData traceinf_floor = trace0(traceinf.pos, reflect(ray, traceinf.norm), true);\n     float r = 1.2*clamp(fresnel(ray, traceinf.norm, 2.1), 0.0, 0.3);\n     col = mix(col, traceinf_floor.col, r);\n     //col = traceinf_floor.col;\n  }\n  #endif\n\n  return vec4(col, 1.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Antialiasing\n    vec4 vs = vec4(0.);\n    for (int j=0;j<aasamples ;j++)\n    {\n       float oy = float(j)*aawidth/max(float(aasamples-1), 1.);\n       for (int i=0;i<aasamples ;i++)\n       {\n          float ox = float(i)*aawidth/max(float(aasamples-1), 1.);\n          vs+= render(fragCoord + vec2(ox, oy));\n       }\n    }\n    fragColor = vs/vec4(aasamples*aasamples);    \n}","name":"","description":"","type":"image"}]}