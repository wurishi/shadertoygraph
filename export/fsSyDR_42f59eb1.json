{"ver":"0.1","info":{"id":"fsSyDR","date":"1643309650","viewed":98,"name":"Couloir","username":"Pimak","description":"Couloir montrant les différents shaders effectués durant le cours\nTrès demandant en terme de GPU\n\nOn peut retirer les sphères tournant autour de la sphère pour augmenter les FPS en commentant la ligne 717\nOu alors modifier leurs nombres ligne 25","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raytracing"],"hasliked":0,"parentid":"NsSyWR","parentname":"Square de début"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Constants\n#define PI 3.1415926538\n#define INFINITY 10000000000000000000000000000000000000000.\n#define EPSILON 0.00001\n\n//Max array size, should stay small but still bigger than every array size\n#define BIG_NUMBER 18\n\n//Object types\n#define SPHERE_TYPE 1\n#define CYLINDRE_TYPE 2\n#define PLAN_TYPE 3\n#define SQUARE_TYPE 4\n#define SQUARE_NEW_TYPE 5\n#define TILED_PLAN_TYPE 6\n#define SQUARE_BOUNCING_TYPE 7\n#define SQUARE_BLUERED_TYPE 8\n#define SQUARE_SOLAR_SYSTEM_TYPE 9\n#define CIRCLE_TYPE 10\n#define PORTAL_TYPE 11\n\n//Arguments\n#define REFLECTION_FACTOR .9\n#define REFLECTION_MAX 5.\n#define SPHERE_COUNT 5\n#define SPHERE_ORBIT 1.2\n#define SPHERE_SIZE .3\n\nstruct Camera {\n    vec3 Obs;\n    vec3 View;\n    vec3 Up;\n    vec3 Horiz;\n    float H;\n    float W;\n    float z;\n};\n\nstruct Ray {\n    vec3 Origin;\n    vec3 Dir;\n};\n\nstruct Light {\n    vec3 Center;\n    vec3 color;\n};\n\nstruct Lights{\n    Light[BIG_NUMBER] list;\n    int size;\n};\n\nvoid addLight(inout Lights lights, in Light light){\n    if (!(lights.size>0)){\n        lights.size = 0;\n    }\n    lights.list[lights.size] = light;\n    lights.size += 1;\n}\n\nCamera camera(in vec3 Obs, in vec3 LookAt, in float aperture) {\n    Camera C;\n    C.Obs = Obs;\n    C.H = iResolution.y;\n    C.W = iResolution.x;\n    C.z = C.H / (2.* tan(aperture/2.));\n    C.View = normalize(LookAt-Obs);\n    C.Horiz = cross(vec3(0.,0.,1.), C.View );\n    C.Up = cross(C.View, C.Horiz);\n    \n    return C;\n}\n\nRay launch(in Camera C, in vec2 XY) {\n   Ray r;\n   r.Origin = C.Obs;\n   r.Dir = C.z * C.View + (XY.x - C.W/2.) * C.Horiz + (XY.y - C.H/2.) * C.Up;\n   return r;\n}\n\nstruct Object {\n    int type;\n    vec3 Center;\n    float R;\n    vec3 n;\n    float h;\n    vec3 color;\n    vec3 otherColor;\n    bool reflecting;\n    vec3 u;\n    vec3 v;\n    vec3 Center2;\n    vec3 n2;\n};\n\nstruct Objects{\n    Object[BIG_NUMBER] list;\n    int size;\n};\n\nvoid addObject(inout Objects objects, in Object object){\n    if (!(objects.size > 0)){\n        objects.size = 0;\n    }\n    objects.list[objects.size] = object;\n    objects.size +=1;\n}\n\nObject Sphere(vec3 center, float rayon, vec3 color, bool reflecting){\n    Object o;\n    o.type = SPHERE_TYPE;\n    o.Center = center;\n    o.R = rayon;\n    o.color = color;\n    o.otherColor = color;\n    o.reflecting = reflecting;\n    return o;\n}\n\nObject Sphere(vec3 center, float rayon, vec3 color, vec3 otherColor, bool reflecting){\n    Object o = Sphere(center, rayon, color, reflecting);\n    o.otherColor = otherColor;\n    return o;\n}\n\nObject Cylindre(vec3 center, float rayon, vec3 n, float h, vec3 color, bool reflecting){\n    Object o;\n    o.type = CYLINDRE_TYPE;\n    o.Center = center;\n    o.R = rayon;\n    o.n = n;\n    o.h = h;\n    o.color = color;\n    o.otherColor = color;\n    o.reflecting = reflecting;\n    return o;\n}\n\nObject Cylindre(vec3 center, float rayon, vec3 n, float h, vec3 color, vec3 otherColor, bool reflecting){\n    Object o = Cylindre(center, rayon, n, h,  color,reflecting);\n    o.otherColor = otherColor;\n    return o;\n}\n\nObject Plan(vec3 Center, vec3 n, vec3 color, bool reflecting){\n    Object o;\n    o.type = PLAN_TYPE;\n    o.Center = Center;\n    o.n = normalize(n);\n    o.color = color;\n    o.otherColor = color;\n    o.reflecting = reflecting;\n    return o;\n}\n\nObject TiledPlan(vec3 Center, vec3 u, vec3 v, vec3 color1, vec3 color2){\n    Object o;\n    o.type = TILED_PLAN_TYPE;\n    o.Center = Center;\n    o.n = normalize(cross(u,v));\n    o.u = u;\n    o.v = v;\n    o.color = color1;\n    o.otherColor = color2;\n    o.reflecting = false;\n    return o;\n}\n\nObject Square(vec3 Center, vec3 u, vec3 v, vec3 color, bool reflecting){\n    Object o;\n    o.type = SQUARE_TYPE;\n    o.Center = Center;\n    o.n = normalize(cross(u,v));\n    o.u = u;\n    o.v = v;\n    o.color = color;\n    o.otherColor = color;\n    o.reflecting = reflecting;\n    return o;\n}\n\nObject Square(vec3 Center, vec3 u, vec3 v, vec3 color, vec3 otherColor, bool reflecting){\n    Object o = Square(Center, u, v, color, reflecting);\n    o.otherColor = otherColor;\n    return o;\n}\n\nObject NewSquare(vec3 Center, vec3 u, vec3 v){\n    Object o = Square(Center, u, v, vec3(0,0,0), false);\n    o.type = SQUARE_NEW_TYPE;\n    return o;\n}\n\nObject BouncingBallsSquare(vec3 Center, vec3 u, vec3 v){\n    Object o = Square(Center, u, v, vec3(0,0,0), false);\n    o.type = SQUARE_BOUNCING_TYPE;\n    return o;    \n}\n\nObject BlueRedSquare(vec3 Center, vec3 u, vec3 v){\n    Object o = Square(Center, u, v, vec3(0,0,0), false);\n    o.type = SQUARE_BLUERED_TYPE;\n    return o;    \n}\n\nObject SolarSystemSquare(vec3 Center, vec3 u, vec3 v){\n    Object o = Square(Center, u, v, vec3(0,0,0), false);\n    o.type = SQUARE_SOLAR_SYSTEM_TYPE;\n    return o;    \n}\n\nObject Circle(vec3 Center, vec3 n, float R, vec3 color, bool reflecting){\n    Object o;\n    o.type = CIRCLE_TYPE;\n    o.Center = Center;\n    o.n = n;\n    o.R = R;\n    o.color = color;\n    o.otherColor = color;\n    o.reflecting = reflecting;\n    return o;\n}\n\nObject Portal(vec3 Center1, vec3 Center2, vec3 n1, vec3 n2, float R){\n    Object o;\n    o.type = PORTAL_TYPE;\n    o.Center = Center1;\n    o.Center2 = Center2;\n    o.n = normalize(n1);\n    o.n2 = normalize(n2);\n    o.R = R;\n    o.reflecting = true;\n    vec3 k = vec3(0,0,1);\n    vec3 i = vec3(1,0,0);\n    if ((length(cross(n1,k)) != 0.) || (length(cross(n2,k)) != 0.)){\n        o.u = k;\n    } else if ((length(cross(n1,i)) != 0.) || (length(cross(n2,i)) != 0.)){\n        o.u = i;\n    } else {\n        o.u = vec3(0,1,0);\n    }\n    return o;\n}\n\nbool intersect_sphere(in Ray R, in Object o, out float t){\n    float a = dot(R.Dir, R.Dir);\n    float b = 2.* dot(R.Dir, R.Origin - o.Center);\n    float c = dot(R.Origin - o.Center, R.Origin - o.Center) - o.R*o.R;\n    float Delta = b*b-4.*a*c;\n    if (Delta>0.){\n        t = (-b - sqrt(Delta))/(2.*a);\n        if (t>EPSILON){\n            return true;\n        }\n        t = (-b + sqrt(Delta))/(2.*a);\n        if (t>EPSILON){\n            return true;\n        }\n    }\n    t = INFINITY;\n    return false;\n}\n\nbool intersect_cylindre(in Ray R, in Object o, out float t){\n    vec3 n = normalize(o.n);\n    vec3 A = R.Origin - o.Center;\n    \n    float a = pow(length(R.Dir - dot(R.Dir, n) * n), 2.);\n    float b = 2.*dot(R.Dir - dot(R.Dir,n)*n , A - dot(A, n)*n);\n    float c = pow(length(A- dot(A, n) *n ),2.) - pow(o.R, 2.);\n    \n    \n    float Delta = b*b-4.*a*c;\n    if (Delta>0.){\n        t = (-b - sqrt(Delta))/(2.*a);\n        vec3 M = R.Origin + t * R.Dir;\n        if (t>EPSILON && 0.<dot(M-o.Center, n) && dot(M-o.Center, n) < o.h){\n            return true;\n        }\n        t = (-b + sqrt(Delta))/(2.*a);\n        M = R.Origin + t * R.Dir;\n        if (t>EPSILON && 0.<dot(M-o.Center, n) && dot(M-o.Center, n) < o.h){\n            return true;\n        }\n    }\n    t = INFINITY;\n    return false;\n}\n\nbool intersect_plan(in Ray R, in Object o, out float t){\n    t = INFINITY;\n    if (dot(R.Dir, o.n) == 0.){\n        return false;\n    }\n    t = dot(o.Center - R.Origin, o.n)/ dot(R.Dir, o.n);\n    if (t<EPSILON){\n        t = INFINITY;\n        return false;\n    }\n    return true;\n}\n\nbool toTheRight(in vec2 A, in vec2 B, in vec2 M){\n    float l = (A.y-B.y)*(M.x-A.x);\n    float r = (B.x-A.x)*(M.y-A.y);\n    return l+r>=0.;\n}\n\nbool intersect_square(in Ray R, in Object o, out float t){\n    if (!(intersect_plan(R, o, t))){\n        return false;\n    }\n    vec3 n = o.n;\n    if (dot(R.Dir, n)>0.){\n        n = -n;\n    }\n    vec3 M = R.Origin + R.Dir*t;\n    vec2 A;\n    vec2 B;\n    vec2 C;\n    vec2 D;\n    vec2 M2;\n    float nx = abs(n.x);\n    float ny = abs(n.y);\n    float nz = abs(n.z);\n    if (nx > ny && nx > nz){\n        A = o.Center.yz;\n        B = (o.Center + o.u).yz;\n        C = (o.Center + o.v).yz;\n        D = (o.Center + o.u + o.v).yz;\n        M2 = M.yz;\n    } else if (ny >= nx && ny >= nz){\n        A = o.Center.xz;\n        B = (o.Center + o.u).xz;\n        C = (o.Center + o.v).xz;\n        D = (o.Center + o.u + o.v).xz;\n        M2 = M.xz;\n    } else {\n        A = o.Center.xy;\n        B = (o.Center + o.u).xy;\n        C = (o.Center + o.v).xy;\n        D = (o.Center + o.u + o.v).xy;\n        M2 = M.xy;\n    }\n    return toTheRight(A, B, M2) && toTheRight(B,D, M2) && toTheRight(D, C, M2) && toTheRight(C, A, M2);\n}\n\nbool intersect_circle(in Ray R, in Object o, out float t){\n    if (!(intersect_plan(R, o, t))){\n        return false;\n    }\n    \n    vec3 M = R.Origin + R.Dir*t;\n    if (length(o.Center - M)<o.R){\n        return true;\n    }\n    t = INFINITY;\n    return false;\n}\n\nbool intersect_portal(in Ray R, in Object o, out float t){\n    float t1;\n    bool b1 = intersect_circle(R,o, t1);\n    float t2;\n    bool b2 = intersect_circle(R, Circle(o.Center2, o.n2, o.R, vec3(0.), false), t2);\n    t = min(t1,t2);\n    return b1 || b2;\n}\n\nbool intersect_object(in Ray R, in Object o, out float t){\n    if (o.type == SPHERE_TYPE){\n        return intersect_sphere(R,o,t);\n    }\n    if (o.type == CYLINDRE_TYPE){\n        return intersect_cylindre(R,o,t);\n    }\n    if (o.type == PLAN_TYPE || o.type == TILED_PLAN_TYPE){\n        return intersect_plan(R,o,t);\n    }\n    if (o.type == SQUARE_TYPE || \n        o.type == SQUARE_NEW_TYPE || \n        o.type == SQUARE_BOUNCING_TYPE || \n        o.type == SQUARE_BLUERED_TYPE || \n        o.type == SQUARE_SOLAR_SYSTEM_TYPE){\n        return intersect_square(R,o,t);\n    }\n    if (o.type == CIRCLE_TYPE){\n        return intersect_circle(R,o,t);\n    }\n    if (o.type == PORTAL_TYPE){\n        return intersect_portal(R,o,t);\n    }\n    \n    return false;\n}\n\nbool intersect_objects(in Ray R, in Objects objects, out float t, out Object o){\n    t = INFINITY;\n    Object oCurrent;\n    float tCurrent;\n    for (int i=0; i<objects.size; i++){\n        oCurrent = objects.list[i];\n        if (intersect_object(R, oCurrent, tCurrent) ){\n            if (tCurrent < t){\n                t = tCurrent;\n                o = oCurrent;\n            }\n        }\n    }\n    return t<INFINITY;\n}\n\nvec3 normal_sphere(vec3 M, Object o){\n    return normalize(M - o.Center);\n}\n\nvec3 normal_cylindre(vec3 M, Object o){\n    vec3 n = normalize(o.n); \n    vec3 CM = M - o.Center;\n    return normalize(CM - dot(CM, n) * n);\n}\n\nvec3 normal(vec3 M, Object o){\n    if (o.type == SPHERE_TYPE){\n        return normal_sphere(M,o);\n    }\n    if (o.type == CYLINDRE_TYPE){\n        return normal_cylindre(M,o);\n    }\n    if (o.type == PLAN_TYPE  || o.type == SQUARE_TYPE || o.type == SQUARE_NEW_TYPE || o.type == CIRCLE_TYPE){\n        return o.n;\n    }\n    return vec3(1,0,0);\n}\n\nRay portal_hopping(in Ray R, in Object o, in vec3 M){\n    Ray r;\n    vec3 n1 = o.n;\n    vec3 n2 = o.n2;\n    vec3 u1 = normalize(o.u - dot(o.u, n1) * n1);\n    vec3 u2 = normalize(o.u - dot(o.u, n2) * n2);\n    vec3 v1 = cross(n1, u1);\n    vec3 v2 = cross(n2, u2);\n    if (length(o.Center - M) < o.R){\n        vec3 C1M = M - o.Center;\n        r.Origin = o.Center2 + dot(C1M,n1)*n2 + dot(C1M,u1)*u2 + dot(C1M,v1)*v2;\n        r.Dir = dot(R.Dir,n1)*n2 + dot(R.Dir,u1)*u2 + dot(R.Dir,v1)*v2;\n    } else {\n        vec3 C2M = M - o.Center2;\n        r.Origin = o.Center + dot(C2M,n2)*n1 + dot(C2M,u2)*u1 + dot(C2M,v2)*v1;\n        r.Dir = dot(R.Dir,n2)*n1 + dot(R.Dir,u2)*u1 + dot(R.Dir,v2)*v1;\n    }\n    //r.Dir = R.Dir;\n    return r;\n}\n\nRay reflect_object(in Ray R, in Object o, in vec3 M){\n    if (o.type == PORTAL_TYPE){\n        return portal_hopping(R, o, M);\n    }\n    Ray r;\n    r.Origin = M;\n    vec3 n = normal(M, o);\n    r.Dir = R.Dir - 2. * dot(R.Dir, n) * n;\n    return r;\n}\n\nvec3 getColor_classic(in Lights lights, in vec3 M, in Object o, in bool outSide, in Objects objects, in float reflectionMultiplier){\n    vec3 n = normal(M, o);\n    vec3 objectColor = o.color;\n    if (outSide){\n        n = -n;\n        objectColor = o.otherColor;\n    }\n    \n    vec3 color = vec3(0);\n    float t;\n    \n    for (int i=0; i<lights.size; i++){\n        Light L = lights.list[i];\n        Ray r;\n        r.Origin = M;\n        r.Dir = L.Center - M;\n        Object oInter;\n        bool intersects = intersect_objects(r, objects, t, oInter);\n        if (!intersects || t>1.){\n            vec3 l = L.Center - M;\n            if (dot(n,l)>0.){\n                color += objectColor * L.color * dot(n, l) / (length(n)*length(l));\n            }\n        }\n        \n    }\n    color.x = min(color.x, 1.);\n    color.y = min(color.y, 1.);\n    color.z = min(color.z, 1.);\n    \n    color *= reflectionMultiplier;\n    return color;\n}\n\nvec3 getColor_newSquare(in vec3 M, in Object o, in Objects objects, in float reflectionMultiplier){\n    vec3 AM = M - o.Center;\n    float Mu = dot(AM, normalize(o.u))/length(o.u);\n    float Mv = dot(AM, normalize(o.v))/length(o.v);\n    vec2 uv = vec2(Mu,Mv);\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    return col * reflectionMultiplier;\n}\n\nvec3 getColor_bouncingBalls(in vec3 M, in Object o, in float reflectionMultiplier){\n    vec3 AM = M - o.Center;\n    float Mu = dot(AM, normalize(o.u))/length(o.u);\n    float Mv = dot(AM, normalize(o.v))/length(o.v);\n    vec2 uv = vec2(Mu,Mv);\n    return bouncingBalls(uv, iTime) * reflectionMultiplier;\n}\n\nvec3 getColor_bluered(in vec3 M, in Object o, in float reflectionMultiplier){\n    vec3 AM = M - o.Center;\n    float Mu = dot(AM, normalize(o.u))/length(o.u);\n    float Mv = dot(AM, normalize(o.v))/length(o.v);\n    vec2 uv = vec2(Mu,Mv);\n    return blueSquare(uv) * reflectionMultiplier;\n}\n\nvec3 getColor_solarsystem(in vec3 M, in Object o, in float reflectionMultiplier){\n    vec3 AM = M - o.Center;\n    float Mu = dot(AM, normalize(o.u))/length(o.u);\n    float Mv = dot(AM, normalize(o.v))/length(o.v);\n    vec2 uv = vec2(Mu,Mv);\n    return solarSystem(uv, iTime) * reflectionMultiplier;\n}\n\nvec3 getColor_tiledPlan(in Lights lights, in vec3 M, in Object o, in Objects objects, in float reflectionMultiplier){\n    vec3 n = o.n;\n    vec3 objectColor = o.color;\n    vec3 AM = M - o.Center;\n    float Mu = dot(AM, normalize(o.u))/length(o.u);\n    float Mv = dot(AM, normalize(o.v))/length(o.v);\n    if (((mod(Mu,2.)<=1.)&&(mod(Mv,2.)<=1.)) ||\n        ((mod(Mu,2.)>=1.)&&(mod(Mv,2.)>=1.))){\n        objectColor = o.otherColor;\n    }\n    \n    vec3 color = vec3(0);\n    float t;\n    \n    for (int i=0; i<lights.size; i++){\n        Light L = lights.list[i];\n        Ray r;\n        r.Origin = M;\n        r.Dir = L.Center - M;\n        Object oInter;\n        bool intersects = intersect_objects(r, objects, t, oInter);\n        if (!intersects || t>1.){\n            vec3 l = L.Center - M;\n            if (dot(n,l)>0.){\n                color += objectColor * L.color * dot(n, l) / (length(n)*length(l));\n            }\n        }\n        \n    }\n    color *= reflectionMultiplier;\n    return color;\n}\n\nvec3 getColor(in Lights lights, in vec3 M, in Object o, in bool outSide, in Objects objects, in float reflectionMultiplier){\n    if (o.type == SPHERE_TYPE || o.type == CYLINDRE_TYPE || o.type == PLAN_TYPE || o.type == SQUARE_TYPE || o.type == CIRCLE_TYPE){\n        return getColor_classic(lights, M, o, outSide, objects, reflectionMultiplier);\n    }\n    \n    if (o.type == SQUARE_NEW_TYPE){\n        return getColor_newSquare(M, o, objects, reflectionMultiplier);\n    }\n    \n    if (o.type == TILED_PLAN_TYPE){\n        return getColor_tiledPlan(lights, M, o, objects, reflectionMultiplier);\n    }\n    \n    if (o.type == SQUARE_BOUNCING_TYPE){\n        return getColor_bouncingBalls(M,o, reflectionMultiplier);\n    }\n    \n    if (o.type == SQUARE_BLUERED_TYPE){\n        return getColor_bluered(M,o, reflectionMultiplier);\n    }\n    \n    if (o.type == SQUARE_SOLAR_SYSTEM_TYPE){\n        return getColor_solarsystem(M, o, reflectionMultiplier);\n    }\n    \n    return vec3(1);\n}\n\nvec3 getColor(in Ray R, in Objects objects, in Lights lights){\n    Object o;\n    o.reflecting = true;\n    float t;\n    float reflectionMultiplier = 1.;\n    while(o.reflecting && reflectionMultiplier >pow(REFLECTION_FACTOR, 5.)){\n        if (!intersect_objects(R, objects, t, o)){\n            return vec3(0.4)*reflectionMultiplier;\n        }\n        if (o.reflecting){\n            vec3 M = R.Origin + t * R.Dir;\n            R = reflect_object(R, o, M);\n            reflectionMultiplier *= REFLECTION_FACTOR;\n        }\n    }\n    if (reflectionMultiplier<=pow(REFLECTION_FACTOR, REFLECTION_MAX)){\n        return vec3(0.);\n    }\n    \n    //L'objet non réfléchissant que l'on voit est o\n    vec3 M = R.Origin + t * R.Dir;\n    vec3 n = normal(M, o);\n    bool outSide = dot(R.Dir, n)>0.;\n    \n    return getColor(lights, M, o, outSide, objects, reflectionMultiplier);    \n}\n\nvec3 rotate(vec3 gravityCenter, float angular, vec3 posInit, vec3 axis){\n    mat3 I = mat3(1.);\n    vec3 u = normalize(axis);\n    mat3 W = mat3(0, u.z, -u.y ,\n                  -u.z, 0 , u.x,\n                  u.y,-u.x, 0); \n    mat3 rot = I + sin(angular)*W + (1.-cos(angular)) * W * W;\n    return gravityCenter + rot*posInit;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    float temps = mod(iTime, 33.);\n    \n    vec3 cameraPosition = vec3(-5. + temps, 0., 2.2);\n    if (temps>13.){\n        cameraPosition = vec3(8, -(temps-13.)/2., 2.2);\n    }\n    \n    vec3 cameraDirection = normalize(vec3(1,0,0));\n    if (temps > 11. && temps < 17.){\n        cameraDirection = vec3(cos(-(temps-11.)*PI/8.),sin(-(temps-11.)*PI/8.),0);\n    }\n    if (temps >= 17. && temps <25.){\n        cameraDirection = vec3(cos(-3.*PI/4.), sin(-3.*PI/4.), 0);\n    }\n    if (temps >=25. && temps <27.){\n        cameraDirection = vec3(cos(temps* PI/8. + PI/8.),sin(temps* PI/8. + PI/8.),0);\n    }\n    if (temps >= 27.){\n        cameraDirection = vec3(0,-1, 0);\n    }\n    \n    \n    Camera C = camera(\n        cameraPosition,\n        cameraPosition+normalize(cameraDirection),\n        50.0*PI/180.       \n    );\n    Ray R = launch(C , fragCoord);\n   \n    Objects objects;\n    \n    //Sol \n    addObject(objects, TiledPlan(vec3(0,0,0), vec3(1,0,0), vec3(0,1,0), vec3(.8), vec3(0)));\n    \n    //Plafond\n    addObject(objects, TiledPlan(vec3(0,0,4), -vec3(4,0,0), vec3(0,4,0), vec3(253./255., 241./255., 184./255.), vec3(240./255., 210./255., 160./255.)));\n    \n    //Mur Droit\n    addObject(objects, Square(vec3(-2, 2, 0), vec3(12, 0, 0), vec3(0,0,4), vec3( 0.7,0.7,0.7), vec3(0,1,0), false));\n    \n    //Mur Gauche\n    addObject(objects, Square(vec3(-2, -2, 0), vec3(8, 0, 0), vec3(0,0,4), vec3( 0,0,1), vec3( 0.7,0.7,0.7), false));\n    \n    //Carré changeant de couleur\n    addObject(objects, NewSquare(vec3(-1,-1.999, 1), vec3(2,0,0), vec3(0,0,2)));\n    \n    //2 balles rebondissantes dans un carré\n    addObject(objects, BouncingBallsSquare(vec3(2,-1.999, 1), vec3(2,0,0), vec3(0,0,2)));\n    \n    //carré bleu dans carré rouge\n    addObject(objects, BlueRedSquare(vec3(-1,1.999,1), vec3(2,0,0),vec3(0,0,2)));\n    \n    //Système solaire en 2D\n    addObject(objects, SolarSystemSquare(vec3(2,1.999,1), vec3(2,0,0),vec3(0,0,2)));\n    \n    //Sphere au centre de la première pièce\n    addObject(objects, Sphere(vec3(1,0,1), 0.4, vec3(1,1,0),true));\n    \n    //pylône dans le coin\n    addObject(objects, Cylindre(vec3(9,1,0), .4, vec3(0,0,1), 4., vec3(0,0,1), false));\n    \n    //Portail\n    addObject(objects, Portal(vec3(-5, 0, 2), vec3(8,-10,2), vec3(-1,0,0), vec3(0,1,0), 1.5));\n        \n    //Mur du fond\n    addObject(objects, Square(vec3(10,2,0),  vec3(0,0,4), vec3(0,-12,0),vec3(1,0,0), vec3(0,1,0), false));\n    \n    //Première sphère\n    Object S = Sphere(vec3(5,-6,1), 0.5, vec3(1), false);\n    addObject(objects, S);\n    \n    // Sphères qui orbitent\n    vec3 axe = vec3(0., 0., 1.);\n\n    for (int i = 0 ; i < SPHERE_COUNT ; i++){\n\n        float angle = float(i) * 2.* PI / float(SPHERE_COUNT);      \n\n        vec3 init = SPHERE_ORBIT * vec3(1., 0., 0.);\n        vec3 color = vec3(.5+ .5 * cos(angle), .5+ .5*cos(angle+2.*PI/3.), .5+ .5*cos(angle+ 4.*PI/3.));\n        //vec3 p = rotate(S.Center, iTime+angle, init, axe);\n        vec3 p = S.Center + SPHERE_ORBIT * vec3(cos(iTime+angle), sin(iTime+angle), 0);\n        addObject(objects,Sphere(p, SPHERE_SIZE ,color, false));\n    }\n    \n    \n    \n    Lights lights;\n    \n    addLight(lights, Light(vec3(-1,0,3.6), vec3(1,1,1)));\n    addLight(lights, Light(vec3(8,-2,3.6), vec3(1)));\n    addLight(lights, Light(vec3(-10,-2,3.6), vec3(1,1,0)));\n    addLight(lights, Light(vec3(7, -12, 3.6), vec3(0,1,1)));\n    \n    vec3 color = getColor(R, objects, lights);\n    fragColor = vec4(color, 1.);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"float bound(float x, float xmin, float xmax){\n    float size = xmax - xmin;\n    float rebounds = floor((x-xmin)/size);\n    float xout = x - rebounds * size;\n    if (abs(rebounds/2. - floor(rebounds/2.)) > 0.) {\n        xout = xmax + xmin - xout;\n    }\n    return xout;\n}\n\nbool circle(vec2 p, float r, vec2 center){\n\n    //return true if p is inside the circle centered on center and radius r\n    \n    return length(p-center)<r;\n}\n\nvec3 bouncingBalls(in vec2 uv, float iTime){\n    vec3 col = vec3(0,.6,.6);\n\n    vec2 v0 = vec2(0.5,0.4);\n    \n    vec2 pos = iTime*v0;\n    \n    float r = 0.1;\n    \n    vec2 mins = vec2(0.+r, 0. + r);\n    vec2 maxs = vec2(1.-r, 1.- r);\n    \n    pos.x = bound(pos.x, mins.x, maxs.x);\n    pos.y = bound(pos.y, mins.y, maxs.y);\n    \n    \n    if (circle(uv, r, pos)){\n        col = vec3(1,1,1);\n    }\n    \n    vec2 v1 = vec2(0.3, 0.7);\n    vec2 pos1 = iTime*v1;\n    \n    \n    pos1.x = bound(pos1.x, mins.x, maxs.x);\n    pos1.y = bound(pos1.y, mins.y, maxs.y);\n    \n    if (circle(uv, r, pos1)){\n        col = vec3(0,0,0);\n    }\n    return col;\n}\n\nvec3 blueSquare(in vec2 uv){\n    float xmin = 0.25;\n    float xmax = 0.75;\n    \n    float ymin = 0.25;\n    float ymax = 0.75;\n    \n    vec3 col = vec3(1,0,0);\n    \n    if( xmin < uv.x && uv.x < xmax && ymin < uv.y && uv.y < ymax){\n        col = vec3(0,0,1);\n    }\n    return col;\n}\n\nvec3 solarSystem(in vec2 uv, in float iTime){\n    float theta = iTime;\n    float R1 = 0.;\n    float r1 = 0.1;\n    \n    float phi = 2.0*iTime;\n    float R2 = 0.3;\n    float r2 = 0.05;\n    \n    float rho = 5.0*iTime;\n    float R3 = 0.09;\n    float r3 = 0.03;\n    \n    vec2 C1 = vec2(0.5 + R1*cos(theta) , 0.5 + R1*sin(theta) );\n    \n    vec2 C2 = C1 + vec2(R2*cos(phi) ,R2*sin(phi) );\n    \n    vec2 C3 = C2 + vec2(R3*cos(rho) , R3*sin(rho) );\n    \n    vec3 col = vec3(0,0,1);\n    if (length(uv-C1) <r1){\n        col= vec3(1,1,0);\n    }\n    if (length(uv-C2)<r2){\n        col = vec3(0,1,0);\n    }\n    if (length(uv-C3) < r3){\n        col = vec3(1,0,0);\n    }\n    return col;\n}\n\n","name":"Common","description":"","type":"common"}]}