{"ver":"0.1","info":{"id":"XdVGzG","date":"1455128815","viewed":122,"name":"Simple raymarching -mw","username":"mw","description":"Raymarch experiment","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raymarch"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n#define PI 3.141592653589\n#define TRUE_UP vec3(0.0, 1.0, 0.0)\n#define EPSILON 0.01\n#define MAX_STEPS 50\n#define FOV 45.0\n\n/**\n * Vanilla camera definition\n */\nstruct Camera {\n    vec3 up;\n    vec3 right;\n    vec3 forward;\n    vec3 position;\n    vec3 center;\n    vec3 xPlane;\n    vec3 yPlane;\n};\n\n/** \n * Simple parametric ray type\n */\nstruct Ray {\n    vec3 o; // origin\n    vec3 d; // direction\n};\n\n    \n/**\n * Intersection test type\n */\nstruct Test {\n\tbool hit;\n    vec3 normal;\n    int steps;\n};\n\nCamera camera(vec3 position, vec3 lookAt)\n{\n    Camera cam;\n    cam.position = position;\n    cam.forward  = normalize(lookAt - position);\n    cam.right    = normalize(cross(TRUE_UP, cam.forward));\n    cam.up       = normalize(cross(cam.forward, cam.right));\n    cam.center   = cam.position + cam.forward;\n    float aspect = iResolution.x / iResolution.y;\n    float phi    = tan(FOV * PI / 180.0);\n    float theta  = phi * aspect;\n    cam.xPlane   = cam.right * theta;\n    cam.yPlane   = cam.up * phi;\n    return cam;\n}\n\nRay spawnRay(Camera cam, vec2 pixel)\n{\n    vec2 uv = (2.0 * (pixel.xy / iResolution.xy)) - 1.0;\n    vec3 worldPos = cam.center + (uv.x * cam.xPlane) + (uv.y * cam.yPlane);\n    Ray ray;\n    ray.o = cam.position;\n    ray.d = normalize(worldPos - ray.o);\n    return ray;\n}\n\n// --------------------------------------------------------------------------\n\nfloat sphere(vec3 p, float radius) \n{\n\treturn length(p) - radius;   \n}\n\nfloat sphere_default(vec3 p) \n{\n\treturn sphere(p, 1.0);\n}\n\nfloat box(vec3 p, vec3 b)\n{\n\treturn length(max(abs(p) - b, 0.0));\n}\n\nfloat box_default(vec3 p)\n{\n    return mod(box(p, vec3(1.0, 1.0, 1.0)), 4.0);\n}\n\n// Shamelessly borrowed from\n// https://iquilezles.org/articles/distfunctions\nfloat torus(vec3 p, vec2 t, bool repeat)\n{\n    p.x = mod(p.x, 6.0) - 3.0;\n    p.z = mod(p.z, 6.0) - 3.0;\n    \n    vec2 q = vec2(length(p.xz)-t.x,p.y);\n\treturn length(q)-t.y;\n}\n\nfloat torus_default(vec3 p)\n{\n  return torus(p, vec2(2.0, 0.5), true);\n}\n\n// --------------------------------------------------------------------------\n\nvec3 calc_normal(vec3 hit) {\n\tfloat nx = torus_default(vec3(hit.x + EPSILON, hit.yz)) - \n               torus_default(vec3(hit.x - EPSILON, hit.yz));\n    float ny = torus_default(vec3(hit.x, hit.y + EPSILON, hit.z)) - \n               torus_default(vec3(hit.x, hit.y - EPSILON, hit.z));\n    float nz = torus_default(vec3(hit.xy, hit.z + EPSILON)) - \n               torus_default(vec3(hit.xy, hit.z - EPSILON));\n    return normalize(vec3(nx, ny, nz));\n}\n\n// --------------------------------------------------------------------------\n\n// Apply Phong shading to the given color based on the provided surface normal\nvec3 phong(vec3 color, vec3 light, vec3 normal)\n{\n    return (color * 0.1) + // Ambient\n           (color * 0.125 * max(0.0, dot(normal, light))); // Diffuse\n}\n\n// --------------------------------------------------------------------------\n\nTest raymarch(Ray ray)\n{\n    float t = 0.0;\n    Test test;\n    test.hit = false;\n    test.normal = vec3(0.0, 0.0, 0.0);\n    test.steps = 0;\n\n    for (int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ray.o + (ray.d * t);\n        test.steps = i;\n        float nearest = torus_default(p);\n        if (nearest < EPSILON) {\n            test.hit    = true;\n            test.normal = calc_normal(p);\n            return test;\n        }\n        t += nearest;\n    }\n\n\treturn test;    \n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv        = (10.0 * iMouse.xy / iResolution.xy) - 5.0;\n    float animPos  = float(iFrame) / 10.0;\n    vec3 position  = vec3(0.0, 10.0*sin(animPos / 10.0), animPos);\n    vec3 lookat    = vec3(40.0*cos(animPos / 10.0), 0.0, animPos + 5.0);\n    Camera cam     = camera(position, lookat);\n    vec3 light     = vec3(-1.0, 5.0, -4.0);\n    Ray ray        = spawnRay(cam, fragCoord.xy);\n    \n    Test test = raymarch(ray);\n    if (test.hit) {\n        fragColor = vec4(phong(vec3(1.0, 0.0, 0.0), light, test.normal), 1.0);\n    } else {\n    \tfragColor = vec4(0.0, 0.5, 0.5, 1.0);    \n    }   \n}\n","name":"Image","description":"","type":"image"}]}