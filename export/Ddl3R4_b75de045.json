{"ver":"0.1","info":{"id":"Ddl3R4","date":"1665747468","viewed":134,"name":"Polar Unit Circle 2","username":"ChunderFPV","description":"Mouse x to polar transform.","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["math","graph","plot","polar","transform","trigonometry"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define R iResolution.xy\n#define M iMouse\n#define PI 3.14159265358979\n#define CST(a) vec3(cos(a), sin(a), tan(a))\n#define L(v,w) smoothstep(w*min(fwidth(v), 1.), 0., abs(v)) // line\n#define CL(r) step(max(0., r), min(r, 1.)) // clamp line\n#define P(u,r) max(0., 1.-length(u/fwidth(u)/r)) // point\n\n// quick funcs (wave, length, point)\n#define Q1(v) L(abs(y)-abs(v), lw)\n#define Q2(v) L(a-x, lw)*CL(abs(v))*b\n#define Q3(v) P(vec2(a-x, abs(y)-abs(v)), pr)*b\n\nvoid mainImage( out vec4 RGBA, in vec2 XY )\n{\n    vec2 m = M.xy/R*2.-1.; // mouse coords\n    float s  = 5.,  // scale\n          lw = 1.5, // line radius\n          pr = 3.,  // point radius\n          ss = 3.,  // snap strength (less is more)\n          snap = round(m.x*ss)/ss;\n    if (mod(snap, 1.) < .01) m.x = snap; // snap to int when close\n    float a = mod(iTime, PI*2.)-PI; // time (arc)\n    vec2 uv = (XY-.5*R)/R.y*s; // screen coords\n    \n    // cartesian to polar\n    uv = uv*(1.-abs(m.x))+vec2(atan(uv.x, uv.y*sign(m.x))*abs(m.x), length(uv)*m.x);\n    \n    vec3 c = vec3(0); // bg color\n    vec2 g = abs(fract(uv+.5)-.5)/fwidth(uv)/lw; // grid\n    c += max(0., 1.-min(g.x, g.y))*.06; // grid lines\n    c += max(0., 1.-max(g.x, g.y)); // grid points\n    \n    // colors\n    vec3 c_cos = vec3(0., .5, 1.),\n         c_sin = vec3(1., 0., 0.),\n         c_tan = vec3(.9, .7, .5),\n         c_sec = vec3(.1, .7, .7),\n         c_csc = vec3(.9, .6, .9),\n         c_cot = vec3(1., .4, 0.);\n    \n    float x = uv.x,\n          y = uv.y;\n    vec3 w = CST(x),\n         v = CST(a);\n    \n    // arc length\n    c.g += L(abs(y)-1., lw)*CL(x/a);\n    \n    // waves\n    c += Q1(w.x)*c_cos;\n    c += Q1(w.y)*c_sin;\n    c += Q1(w.z)*c_tan;\n    c += Q1(1./w.x)*c_sec;\n    c += Q1(1./w.y)*c_csc;\n    c += Q1(1./w.z)*c_cot;\n    \n    // lengths\n    float b = .5; // brightness\n    c += Q2(y/w.x)*c_cos;\n    c += Q2(y/w.y)*c_sin;\n    c += Q2(y/w.z)*c_tan;\n    c += Q2(y*w.x)*c_sec;\n    c += Q2(y*w.y)*c_csc;\n    c += Q2(y*w.z)*c_cot;\n    \n    // points\n    b = 2.;\n    c -= Q3(v.x);\n    c -= Q3(v.y);\n    c -= Q3(v.z);\n    c -= Q3(1./v.x);\n    c -= Q3(1./v.y);\n    c -= Q3(1./v.z);\n    \n    RGBA = vec4(exp(log(c)/2.2), 1.);\n}","name":"Image","description":"","type":"image"}]}