{"ver":"0.1","info":{"id":"XfSyzy","date":"1729457054","viewed":66,"name":"Shiny mandelbulb","username":"moloxe","description":"Just a shiny mandelbulb","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["mandelbulb"],"hasliked":0,"parentid":"lclcDX","parentname":"Lucid dream"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float sdScene(vec3 p) {\n    float rotX = iTime / 2.;\n    if(iMouse.x > 0.) rotX = iMouse.x / 100.;\n    p *= rotation(vec3(\n        rotX,\n        0.,\n        PI/2.\n    ));\n    float power = 4.;\n    if(iMouse.y > 0.) power = iMouse.y / 40.;\n    float d = sdMandelbulb(p, power);\n    return d;\n}\n\nvec3 calcNormal(vec3 p) {\n    const float eps = 1e-4;\n    vec3 h = vec3(eps, 0.0, 0.0);\n    return normalize(vec3(\n        sdScene(p + h.xyy) - sdScene(p - h.xyy),\n        sdScene(p + h.yxy) - sdScene(p - h.yxy),\n        sdScene(p + h.yyx) - sdScene(p - h.yyx)\n    ));\n}\n\n\n\nfloat calcLight(vec3 ro, vec3 p) {\n    vec3 normal = calcNormal(p);\n    vec3 dir = normalize(ro - p);\n    float lambert = dot(normal, dir);\n    return lambert * .5 + pow(lambert, 256.);\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy * 2. - 1.;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec3 ro = vec3(0., 0., 5.);\n    vec3 rd = normalize(vec3(uv, -3.));\n \n    vec4 c = vec4(0);\n    float z = 0.;\n    for(int i = 0; i < 128 && z < 10.; i++) {\n        vec3 p = ro + z * rd;\n        float d = sdScene(p);\n        if(d < 1e-3) {\n            c.rgb = vec3(calcLight(ro, p));\n            break;\n        }\n        z += d;\n    }\n    \n  \n    fragColor = c;\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define PI 3.14159265\n\nfloat sdTerrain(vec3 p) {\n  float height = cos(p.x) + cos(p.y) + cos(p.z);\n  return sin(p.z) - height;\n}\n\nfloat opSmoothSubtraction(float d1, float d2, float k) {\n  float h = clamp( 0.5 - 0.5 * (d2+d1) / k, 0., 1.);\n  return mix(d2, -d1, h) + k * h * (1. - h);\n}\n\nmat3 rotationY(float angle) {\n  float c = cos(angle);\n  float s = sin(angle);\n  return mat3(\n     c, 0.,  s,\n    0., 1., 0.,\n    -s, 0.,  c\n  );\n}\n\nmat3 rotationX(float angle) {\n  float c = cos(angle);\n  float s = sin(angle);\n  return mat3(\n    1., 0., .0,\n    0.,  c, -s,\n    0.,  s,  c\n  );\n}\n\nmat3 rotationZ(float angle) {\n  float c = cos(angle);\n  float s = sin(angle);\n  return mat3(\n     c, -s, 0.,\n     s,  c, 0.,\n    0., 0., 1.\n  );\n}\n\nmat3 rotation(vec3 angles) {\n  float cx = cos(angles.x);\n  float sx = sin(angles.x);\n  float cy = cos(angles.y);\n  float sy = sin(angles.y);\n  float cz = cos(angles.z);\n  float sz = sin(angles.z);\n\n  mat3 rotX = mat3(\n    1., 0., 0.,\n    0., cx, -sx,\n    0., sx, cx\n  );\n\n  mat3 rotY = mat3(\n    cy, 0., sy,\n    0., 1., 0.,\n    -sy, 0., cy\n  );\n\n  mat3 rotZ = mat3(\n    cz, -sz, 0.,\n    sz, cz, 0.,\n    0., 0., 1.\n  );\n\n  return rotZ * rotY * rotX;\n}\n\nvec3 toSpherical(vec3 p) {\n  float r = length(p);\n  float theta = acos(p.z / r);\n  float phi = atan(p.y, p.x);\n  return vec3(r, theta, phi);\n}\n\nfloat sdMandelbulb(vec3 p, float power) {\n  const int maxIter = 20;\n\n  vec3 zeta = p;\n  float dr = 1.0;\n  float r = 0.0;\n  for (int _ = 0; _ < maxIter; _++) {\n\n    vec3 spherical = toSpherical(zeta);\n    r = spherical.x;\n    if (r > 2.0) {\n      break;\n    }\n\n    dr = pow(r, power - 1.0) * power * dr + 1.0;\n\n    float theta = spherical.y * power;\n    float phi = spherical.z * power;\n    float sinTheta = sin(theta);\n\n    float powx = pow(r, power) * sinTheta * cos(phi);\n    float powy = pow(r, power) * sinTheta * sin(phi);\n    float powz = pow(r, power) * cos(theta);\n\n    zeta.x = powx + p.x;\n    zeta.y = powy + p.y;\n    zeta.z = powz + p.z;\n  }\n  return 0.4 * log(r) * r / dr;\n}\n","name":"Common","description":"","type":"common"}]}