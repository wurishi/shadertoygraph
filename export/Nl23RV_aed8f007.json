{"ver":"0.1","info":{"id":"Nl23RV","date":"1624453412","viewed":178,"name":"Voxel Traversal 2D B","username":"spalmer","description":"a simple fast DDA testbed","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["dda"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// fork of older toy, Voxel Traversal 2D https://shadertoy.com/view/wt3SW8\n// see that for some of my inspirations.\n// Thanks, unnick, ocb, stb, kastorp, fb39ca4, glk7!\n// but truly got almost completely rewritten in the process.\n// I'm still not completely done refactoring, golfing, cleaning.\n\n// precalculated unchanging stuff\nstruct Trace2 // describes a ray trace\n{\n\tvec2 ro; // ray origin position \n\tvec2 rd; // ray direction, normalized\n\tvec2 dd; // 1/abs(rd)\n\tivec2 sd; // sign(rd)\n\tfloat t0; // range start\n\tfloat t1; // range end\n};\n\n// iteration state\nstruct DDA2\n{\n\tvec2 st; // t of next axis boundary // TODO rename nt or something distinct\n\tivec2 mp; // current cell index\n\tfloat t; // current trace at\n};\n\n// st was originally supposed to track fractional coordinates (of current Trace location)\n// but it morphed into the set of decision variables, which in this case\n// are the t index of the next intersection with that axis' grid line/plane cell boundary\n\n// originally was tracking steps; robust enough now that is not necessary.\n//\tint nsteps; // steps remaining\n\t// slightly wrong.  besides, I want to avoid the need for calculating upper bound on number of steps, as it is erroneous, and in theory shouldn't be necessary, if the algo is reliable enough and the trace far distance was set reasonably.  Just use distance, check if t >= t1!\n\t//ivec2 iad = ivec2(ceil(ad));\n\t//dda.nsteps = iad.x + iad.y + 1;// + 1; //1 + int(dot(ad, vec2(1))); // steps remaining upper limit to cover desired distance\n\n// globals for debug display of stepping\nfloat cd;\nvec2 pixel;\nivec2 qi; // query pixel grid cell coordinate\nbool celltouchesline = false;\n\nbool Traverse(DDA2 dda, Trace2 tr)\n{\n\tbool r = dda.t < tr.t1;\n\tif (r) {\n        if (dda.t > 0.) // no dot at ray origin please\n            cd = min(cd, distance(pixel, tr.ro + tr.rd * dda.t));\n        if (qi == dda.mp)\n            celltouchesline = true; // color cell later\n\t}\n\treturn r;\n}\n\nint Next(inout DDA2 dda, Trace2 tr)\n{\n\tint s = dda.st.x <= dda.st.y ? 0 : 1; // which cell boundary is closer?\n\tdda.t = dda.st[s]; // update total distance traversed\n\tdda.st[s] += tr.dd[s]; // step to next boundary \n\tdda.mp[s] += tr.sd[s]; // move, which way? to next cell\n\treturn s;\n}\n\nvoid Setup(vec2 pa, vec2 pb, out DDA2 dda, out Trace2 tr)\n{\n\ttr.ro = pa;\n\ttr.rd = pb - pa;\n\tvec2 ad = abs(tr.rd);\n    // sign() is somewhat buggy, can sometimes produce values *slightly* below 1.0 in magnitude, which convert to integer zero... many workarounds\n\ttr.sd = ivec2(sign(tr.rd) * 1.001); //ivec2(round(sign(tr.rd))); // sign seems slightly bugged?!\n\ttr.t1 = length(tr.rd); // could use ad but abs isn't necessary here\n\ttr.t0 = 0.;\n\ttr.rd /= tr.t1; //tr.rd = normalize(tr.rd); //\n\tad /= tr.t1;\n\ttr.dd = vec2(1) / max(ad, 1e-32); // will be effectively infinity where rd was 0, so only use when actually crossing between cells\n\tdda.t = 0.;\n\tdda.mp = ivec2(floor(tr.ro)); // current cell index\n\tdda.st = tr.ro - vec2(dda.mp); //fract(tr.ro);\n\tdda.st = (.5 - dda.st) * vec2(tr.sd) + .5;\n\t// compensate when starting precisely on an integer (grid cell boundary) going in negative direction, would be otherwise off by one\n\tivec2 sot = ivec2(equal(dda.st, vec2(0))); // mask for on cell boundary (integer)\n\tdda.mp += sot * min(tr.sd, ivec2(0)); // factor mask for negative directions\n\tdda.st += vec2(sot); // step cannot be zero.  If start on boundary, just go to next one!\n\tdda.st *= tr.dd;\n}\n\nvec2 Scan(inout DDA2 dda, Trace2 tr, out ivec2 n)\n{ \n    float ot = dda.t;\n\tint s;\n\twhile (Traverse(dda, tr))\n\t\ts = Next(dda, tr);\n\tn = ivec2(0);\n\tn[s] = -tr.sd[s]; // avoid negating zeroes\n\treturn vec2(ot, dda.t);\n}\n\nfloat ScanDDA2(vec2 a, vec2 b)\n{\n    DDA2 dda;\n    Trace2 tr;\n    Setup(a, b, dda, tr);\n    ivec2 n;\n    return Scan(dda, tr, n).y;\n}\n\n// iq's line segment distance, trimmed & renamed\n// just so I can see the mouse ray\nfloat seg(vec2 p, vec2 a, vec2 b)\n{\n\tp -= a; b -= a; return length(p - b *\n\t\tclamp(dot(p, b) / dot(b, b), 0., 1.));\n}\n\nconst int grid = 4;\nconst float scale = 1.1 * float(grid-1);\n\nvec2 StoQ(vec2 s, vec2 r)\n{\n    return (s+s-r) * scale / r.y; // + .5;\n}\n\nvoid overlay(inout vec3 o, vec3 c, float a)\n{\n    o = mix(o, c, clamp(a, 0., 1.));\n}\n\nvoid mainImage(out vec4 o, vec2 p)\n{\n    float a = .2 * iTime;\n    vec2 R = iResolution.xy\n    ,  q = StoQ(p, R)\n    , m0 = StoQ(abs(iMouse.zw), R)\n    , m1 = StoQ(iMouse.xy, R)\n    ;\n    if (iMouse.z <= 0.) {\n        m0 = .1 * vec2(sin(a * 5.), cos(a * 7.)) * sin(a * 4.); //vec2(0); //.5); //\n        m1 = m0 + .9 * float(grid-1)*vec2(vec2(sin(a), cos(a)));\n    }\n    qi = ivec2(floor(q)); // gridcell\n    celltouchesline = false;\n    pixel = q; cd = 3e38;\n    float l = ScanDDA2(m0, m1);\n    vec2 hp = m0 + normalize(m1 - m0) * l;\n    vec3 c = mix(vec3(.9), vec3(1), float((qi.x^qi.y)&1)); // checks bg\n    if (celltouchesline) c.rb *= .8;\n    overlay(c, vec3(0,.4,0), 1. - .5*R.y/scale * seg(q, m0, m1)); // segment\n    //overlay(c, vec3(.2,.2,0), .5 - .5*R.y/scale * (distance(hp, q) - .05)); // final point\n    float dotsize = .05; //dot(iMouse, vec4(1)) == 0. ? .05 : .03;\n    float dotthick = .01;\n    overlay(c, vec3(0,0,.0), .5 - .5*R.y/scale*(abs(cd - dotsize)-dotthick)); //(.5 - cd / scale * R.y)); // closest intersection point\n//    c = sqrt(c); // gamma - blending probably not quite right without it\n    o = vec4(c, 1);\n}\n\n","name":"Image","description":"","type":"image"}]}