{"ver":"0.1","info":{"id":"4d3SzB","date":"1460056970","viewed":328,"name":"Smoking stuff II","username":"waterhead","description":"Simple ray marching for objects, combined with blurred feedback buffer in order to create a very basic smoke-like impression. First ray marching / buffer attempt, feedback welcome!","likes":10,"published":1,"flags":32,"usePreview":0,"tags":["raymarching","postprocessing","blur","feedback","buffer"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Enable to see feedback contents buffer only\n// #define SHOW_FLAMES_ONLY\n\n// Structure:\n// - Buf A draws raymarched grayscale objects\n// - Buf B masks Buf A contents != 0.0 via texture into Buf B, and feedbacks/blurs/moves them (in grayscale)\n// - Image merges Buf B and Buf A, while colorizing both\n\n#define twopi (2.0 * 3.1415926)\nvec3 hsv2rgb (vec3 hsv) {\n\t// hsv2rgb from https://www.shadertoy.com/view/ldtGDn\n\thsv.yz = clamp (hsv.yz, 0.0, 1.0);\n\treturn hsv.z*(0.63*hsv.y*(cos(twopi*(hsv.x + vec3(0.0, 2.0/3.0, 1.0/3.0))) - 1.0) + 1.0);\n}\n\nvec3 generateBlurColor(float v) {\n    float v2 = v * 0.39;\n\n    return vec3(-0.31 + v2, v, 1.0);\n}\n\nvec3 generateObjectColor(float v) {\n    float v2 = v * 0.79;\n\n    return hsv2rgb(vec3(0.59 - v*0.20, 1.0 - v, 0.9));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\n    #ifdef SHOW_FLAMES_ONLY\n        vec3 rgb = hsv2rgb(generateBlurColor(texture(iChannel1, uv).x));\n\n    \tfragColor = vec4(rgb, 1.0);\n    #else\n        float objectColor = texture(iChannel0,uv).x;\n\n        if (objectColor > 0.0) {\n            fragColor = vec4(generateObjectColor(objectColor), 1.0);\n        } else {\n\t        vec3 rgb = hsv2rgb(generateBlurColor(texture(iChannel1, uv).x));\n\n            fragColor = vec4(rgb, 1.0);\n        }\n    #endif\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"vec3 lightDir = -vec3(0.0, 0.5, 1.0);\n\nmat3 setCamera(in vec3 position, in vec3 viewAt, float rotation) {\n    vec3 direction = normalize(viewAt - position);\n    vec3 up = vec3(sin(rotation), cos(rotation),0.0);\n    vec3 cu = normalize(cross(direction, up));\n    vec3 cv = normalize(cross(cu, direction));\n    return mat3(cu, cv, direction);\n}\n\n// distance functions by iq, see\n// https://iquilezles.org/articles/distfunctions\n\nfloat dot2( in vec3 v ) { return dot(v,v); }\n\nfloat udTriangle( vec3 p, vec3 a, vec3 b, vec3 c )\n{\n    vec3 ba = b - a; vec3 pa = p - a;\n    vec3 cb = c - b; vec3 pb = p - b;\n    vec3 ac = a - c; vec3 pc = p - c;\n    vec3 nor = cross( ba, ac );\n\n    return sqrt(\n    (sign(dot(cross(ba,nor),pa)) +\n     sign(dot(cross(cb,nor),pb)) +\n     sign(dot(cross(ac,nor),pc))<2.0)\n     ?\n     min( min(\n     dot2(ba*clamp(dot(ba,pa)/dot2(ba),0.0,1.0)-pa),\n     dot2(cb*clamp(dot(cb,pb)/dot2(cb),0.0,1.0)-pb) ),\n     dot2(ac*clamp(dot(ac,pc)/dot2(ac),0.0,1.0)-pc) )\n     :\n     dot(nor,pa)*dot(nor,pa)/dot2(nor) );\n}\n\n\nfloat aircraft(vec3 position, vec3 translate) {\n    float w=1.0, d=2.8;\n    \n    return\n        min(\n            min(\n                udTriangle(\n                    position,\n                    vec3(translate.x, translate.y, translate.z+0.6),\n                    vec3(translate.x-w, translate.y-0.5, translate.z-d),\n                    vec3(translate.x, translate.y, translate.z-d)),\n\n                udTriangle(\n                    position,\n                    vec3(translate.x, translate.y, translate.z+0.6),\n                    vec3(translate.x+w, translate.y-0.5, translate.z-d),\n                    vec3(translate.x, translate.y, translate.z-d))),\n\n        udTriangle(\n            position,\n            vec3(translate.x, translate.y, translate.z+0.6),\n            vec3(translate.x-w, translate.y-0.5, translate.z-d),\n            vec3(translate.x+w, translate.y-0.5, translate.z-d)));\n}\n\nvec2 scene(in vec3 location) {\n    float w=0.4, d=0.8;\n    \n    return vec2(\n        min(\n            min(\n                aircraft(location, vec3(0.0)),\n                aircraft(location, vec3(-1.9, -1.2, -2.4))\n            ),\n        \n        \taircraft(location, vec3(1.9, -1.2, -2.4))\n        ));\n}\n\nvec2 castRay(in vec3 camPosition, in vec3 ray) {\n    float tmin = 1.0;\n    float tmax = 21.0;\n    \n    float precis = 0.01;\n    float t = tmin;\n    float m = -1.0;\n    \n    for(int i=0; i<50; i++) {\n        vec2 res = scene(camPosition + ray*t);\n        if( res.x<precis || t>tmax ) break;\n        t += res.x;\n        m = res.y;\n    }\n\n    if( t>tmax ) m=-1.0;\n    \n    return vec2( t, m );\n}\n\nvec3 getNormalAt(in vec3 location) {\n    vec3 epsilon = vec3( 0.001, 0.0, 0.0 );\n    \n    vec3 it = vec3(\n        scene(location + epsilon.xyy).x - scene(location - epsilon.xyy).x,\n        scene(location + epsilon.yxy).x - scene(location - epsilon.yxy).x,\n        scene(location + epsilon.yyx).x - scene(location - epsilon.yyx).x);\n    \n    return normalize(it);\n}\n\nfloat light(in vec3 p, in vec3 n, in vec3 dir) {\n    vec3 ldir=normalize(lightDir);\n    float sh=1.;\n    float diff=max(0.,dot(ldir,-n))+.1*max(0.,dot(normalize(dir),-n));\n    vec3 r = reflect(ldir,n);\n    float spec=max(0.,dot(dir,-r))*sh;\n    return diff+pow(spec,20.)*.7;   \n}\n\nvec3 march(vec3 camPosition, vec3 ray) {\n    vec2 hit = castRay(camPosition, ray);\n    \n    if (hit.y >= 0.0) {\n        vec3 location = camPosition + hit.x * ray;\n        vec3 normal = getNormalAt(location);\n\n        return vec3(light(location, normal, ray));\n    }\n    \n    return vec3(0.0, 0.0, 0.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 pelSize = vec2(1.0) / iResolution.xy,\n    \t uv = -1.0 + 2.0 * fragCoord.xy / iResolution.xy; uv.x *= iResolution.x/iResolution.y;\n\n    float camRange = 4.0,\n    \t  camDistance = sin(iTime * 0.93) * camRange + (5.7 + camRange);\n    \n    vec3 camPosition = vec3(-sin(iTime) * 5.0,\n                            4.0,\n                            camDistance),\n        \n         camLookAt = vec3(0.0, 1.0, -2.0);\n\n    lightDir = camLookAt - camPosition;\n    \n    mat3 cam = setCamera(camPosition, camLookAt, 0.0);\n\n    vec3 ray = cam * normalize(vec3(uv.xy, 3.0));\n    \n    fragColor = vec4(march(camPosition, ray), 1.0);\n}","name":"Buf A","description":"","type":"buffer"},{"inputs":[{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 pelSize = vec2(1.0) / iResolution.xy;\n    vec2 uv = fragCoord / iResolution.xy;\n\n    float objectColor = texture(iChannel0, uv).x;\n    float lastColor = texture(iChannel1, uv).x;\n\t\n    float speed = 0.6 * iResolution.x / 800.0;\n    \n    float offsetH = -(0.5 - uv.x) * 3.0 + sin(uv.y + iTime) * 4.0;\n\n    float up, lighten, lum, damper = 1.0;\n\n    if (objectColor > 0.0) {\n        damper = clamp( 0.0, 1.0, \n                        2.0 * texture(iChannel2, uv * vec2(iResolution.x/iResolution.y,1.0) + \n                                        vec2(0.0, -fract(iTime * 0.3))).x);\n    }\n\n\t#define grab(u,v) texture(iChannel1, vec2(u, v)).x\n    \n    up =    0.25 * grab(uv.x + pelSize.x * speed * (offsetH - 1.0), uv.y - pelSize.y * 2.2 * speed) +\n            0.5  * grab(uv.x + pelSize.x * speed * (offsetH),       uv.y - pelSize.y * 2.2 * speed) +\n            0.25 * grab(uv.x + pelSize.x * speed * (offsetH + 1.0), uv.y - pelSize.y * 2.2 * speed);\n    \n    lum = min(1.0, damper * (up + objectColor));\n    \n    lum *= pow(0.992, ((1.0 / iTimeDelta) / 60.0));\n    \n    fragColor = vec4(lum, lum, lum, 1.0);\n}","name":"Buf B","description":"","type":"buffer"}]}