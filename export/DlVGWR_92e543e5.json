{"ver":"0.1","info":{"id":"DlVGWR","date":"1683811339","viewed":56,"name":"amaze 2023 shader workshop","username":"PudgePacket","description":"amaze 2023 shader workshop","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["amaze"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float square(vec2 uv, vec2 bottomLeft, vec2 topRight) {\n    if (\n        uv.x > bottomLeft.x &&\n        uv.x < topRight.x && \n        uv.y > bottomLeft.y &&\n        uv.y < topRight.y\n    ){\n        return 1.;\n    } else {\n        return 0.;\n    }\n}\n\nmat2 rot(float a) {\n    float c = cos(a);\n    float s = sin(a);\n    return mat2(c, -s, s, c);\n}\n\n// Thanks IQ :)\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n    \nfloat opSmoothSubtraction( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); }\n\n#define sat(a) clamp(a, 0., 1.)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    // shift coordinates so 0.0,0.0 is middle\n    uv = uv - 0.5;\n    // correct for aspect ratio\n    uv.x *= iResolution.x / iResolution.y;\n    uv *= 2.;\n    \n    vec2 rep = vec2(1);\n    uv = mod(uv, rep) - rep * 0.5;\n    \n    vec3 col = vec3(0.0, 0.0, 0.0);\n    \n    vec2 center = vec2(0.0, 0.0);\n    \n    // 2D SDF = distance(center, uv) - 0.2\n\n    float myDist = (distance(center, uv) - 0.2);\n    myDist = abs(myDist) - 0.05;\n    myDist = abs(myDist) - 0.01;\n    \n    float timePulse = sin(iTime * 2.5) * 0.5;\n    float timePulse2 = cos(iTime * 2.5) * 0.5;\n    \n    float myDist2 = distance(vec2(timePulse * 0.2 + 0.2, timePulse2 * 0.2), uv) - 0.2;\n    myDist = opSmoothUnion(myDist, myDist2, 0.02);\n    \n    myDist = opSmoothUnion(myDist, \n        distance(vec2(timePulse2 * 0.2 - 0.2, timePulse * 0.2), uv) - 0.2,\n        0.02\n    );\n    myDist = opSmoothSubtraction(myDist, \n        distance(vec2(0.0, 0.0), uv) - 0.4,\n        0.02\n    );\n    \n    myDist = abs(myDist) - 0.001;\n    \n    float myDist3 = distance(vec2(-0.2, 0.), uv) - 0.2;\n    \n    // Only myDist3\n    // myDist = max(myDist, myDist3);\n    \n    // Remove myDist3\n    // myDist = max(myDist, -myDist3);\n    \n    \n    float mask =\n        // uncomment to invert colours\n        1. -\n        sat(myDist * iResolution.x * 0.5);\n    col = vec3(1., 0.2, 0.3) * mask;\n        \n    \n    /*\n    if (distance(center, uv) < 0.3) {\n        col = vec3(0.2, 0.4, 0.5);\n    } else {\n        col = vec3(1.0, 0.0, 0.0);\n    }\n    */\n    \n    fragColor = vec4(col, 1.0);\n    \n    return;\n   \n}\n\nvoid foo(out vec4 fragColor, in vec2 fragCoord) {\n vec2 uv = fragCoord/iResolution.xy;\n uv *= rot(0.5);\n    uv *= 1.5;\n    uv += vec2(sin(iTime*2.)*0.2, sin(iTime)* 0.2);\n\n    vec3 col = vec3(0.0, 0.0, 0.0);\n    \n    //float normalizedSine = sin(iTime * 5.) * 0.5 + 0.5;\n    //normalizedSine = abs(sin(iTime * 2.));\n    \n    float sqrPulse = abs(sin(iTime));\n    float small = 0.1;// + sqrPulse * 0.25;\n    float large = 0.5;// - sqrPulse * 0.25;\n    \n  //  if (uv.x > small && uv.x < large && uv.y > small && uv.y < large) {\n    //    col = vec3(1.0, 0.0, 0.0);\n   // } else {\n    //    col = vec3(0.0, 0.5, 0.5);\n   // }\n    \n    vec2 bottomLeft = vec2(small, small);\n    vec2 topRight = vec2(large, large);\n    vec2 uvShift = vec2(abs(sin(iTime)) * 0.2, abs(sin(iTime * 2.)) * 0.2);\n    vec3 sqC = vec3(0., 0., 1.) * square(uv + uvShift, bottomLeft, topRight);\n    \n    // col += sqC;\n    col += vec3(0., 0., 1.) * square(uv, bottomLeft, topRight);\n    \n   // if (uv.y < 0.5) {\n    //    col += vec3(0.,0.,0.5);\n   // } else {\n    //    col -= vec3(0.5,0.5,0.0);\n   // }\n    \n\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}