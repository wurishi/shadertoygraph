{"ver":"0.1","info":{"id":"ltBGzt","date":"1431355309","viewed":900,"name":"Distance field drawing methods","username":"104","description":"Exploring different ways to draw a filled AA circle. Most people are using smoothstep() to draw filled 2D geometry but I also like other falloff curves, especially 1/d (shown by default).","likes":28,"published":1,"flags":0,"usePreview":0,"tags":["2d","distancefield","circle"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[],"code":"// Recommended:\n// ---------------------\n//#define SMOOTHSTEP\n#define DIV\n//#define SIGN\n\n// Not recommended:\n// ---------------------\n//#define POW\n//#define FLOOR\n\n\nvec4 circle(vec2 uv, vec2 origin, float radius, vec4 color)\n{\n    float d = length(uv - origin) - radius;// distance from uv to the edge of the circle.\n    \n    // VERY VIABLE:-------------------------\n    \n    // using smoothstep() is idiomatic, fast, and clean (no bleeding).\n    #ifdef SMOOTHSTEP\n    float a = 1.0 -smoothstep(0.,0.006, d);\n    #endif\n    \n    // using a divide gives a very long falloff, so it bleeds which I think is pretty.\n    #ifdef DIV\n    const float amount = 300.0;// bigger number = more accurate / crisper falloff.\n    float a = clamp(1.0 / (clamp(d, 1.0/amount, 1.0)*amount), 0.,1.);\n    #endif\n\n    // using sign() which gives 1 50% AA value. it's cheap, but kind of ugly.\n    #ifdef SIGN\n\tconst float epsilon = 0.0007;\n    if(abs(d) <= epsilon) d = 0.;// is there a way to optimize this out?\n    float a = (sign(-d) + 1.0) / 2.0;\n    #endif\n\n    // NOT SO VIABLE:-------------------------\n    \n    // using pow() to crispen edges. pretty, but I think smoothstep has about the same effect and is cheaper..\n    #ifdef POW\n    float a = pow(clamp(1.0 - d,0.,1.),200.0);\n    #endif\n    \n    // you can also use floor() to create a sharp edge, but you'll have to first\n    // go through the DIV method above. floor just eliminates the smoothness and bleeding.\n    // Not very useful...\n    #ifdef FLOOR\n    const float amount = 100000.0;// bigger number = more accurate\n    float a = floor( clamp(1.0 / (clamp(d, 1.0/amount, 1.0)*amount), 0.,1.) );\n    #endif\n\n    return vec4(color.rgb, color.a * a);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.yy;\n    \n    // background color\n    fragColor = vec4(1.0);\n\n    // red circle\n    vec4 c1 = circle(uv, vec2(0.5 +((sin(iTime*0.75)+1.)/3.), 0.5), 0.3, vec4(.85,0.,0.,1));\n\tfragColor = mix(fragColor, c1, c1.a);\n\n    // blue circle\n    vec4 c2 = circle(uv, vec2(0.5 +((cos(iTime*0.85)+1.)/2.), 0.5), 0.2, vec4(.2,0.,0.8,1));\n\tfragColor = mix(fragColor, c2, c2.a);\n}\n","name":"","description":"","type":"image"}]}