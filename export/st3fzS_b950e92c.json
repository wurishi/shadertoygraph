{"ver":"0.1","info":{"id":"st3fzS","date":"1663332023","viewed":125,"name":"Camera Movement with Keyboard","username":"Renslay","description":"Camera handling with keyboard.\nWASD for moving around, arrows for camera rotation.","likes":3,"published":1,"flags":48,"usePreview":0,"tags":["raymarching","camera","keyboard"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Constants\nconst int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float PRECISION = 0.001;\nconst float EPSILON = 0.0005;\n\nstruct Surface {\n    float sd; // signed distance value\n    vec3 col; // color\n};\n\n// As seen on https://iquilezles.org/articles/distfunctions/\nSurface sdBox( vec3 p, vec3 b, vec3 offset, vec3 col)\n{\n  p = p - offset;\n  vec3 q = abs(p) - b;\n  float d = length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n  return Surface(d, col);\n}\n\nSurface sdFloor(vec3 p, vec3 col) {\n  float d = p.y + 1.;\n  return Surface(d, col);\n}\n\nSurface minWithColor(Surface obj1, Surface obj2) {\n  if (obj2.sd < obj1.sd) return obj2;\n  return obj1;\n}\n\nSurface sdScene(vec3 p) {\n  vec3 floorColor = vec3(1. + 0.7*mod(floor(p.x) + floor(p.z), 2.0));\n  Surface co = sdFloor(p, floorColor);\n  co = minWithColor(co, sdBox(p, vec3(1), vec3(-4, 0, -4), vec3(1, 0.2, 0.2))); // left cube\n  co = minWithColor(co, sdBox(p, vec3(1), vec3(0, 0, -4), vec3(0.2, 1, 0.2))); // center cube\n  co = minWithColor(co, sdBox(p, vec3(1), vec3(4, 0, -4), vec3(0.2, 0.2, 1))); // right cube\n  return co;\n}\n\nSurface rayMarch(vec3 ro, vec3 rd, float start, float end) {\n  float depth = start;\n  Surface co; // closest object\n\n  for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n    vec3 p = ro + depth * rd;\n    co = sdScene(p);\n    depth += co.sd;\n    if (co.sd < PRECISION || depth > end) break;\n  }\n  \n  co.sd = depth;\n  \n  return co;\n}\n\nvec3 calcNormal(in vec3 p) {\n    vec2 e = vec2(1, -1) * EPSILON;\n    return normalize(\n      e.xyy * sdScene(p + e.xyy).sd +\n      e.yyx * sdScene(p + e.yyx).sd +\n      e.yxy * sdScene(p + e.yxy).sd +\n      e.xxx * sdScene(p + e.xxx).sd);\n}\n\nmat3 camera(vec3 cameraPos, vec3 lookAtPoint) {\n\tvec3 cd = normalize(lookAtPoint - cameraPos); // camera direction\n\tvec3 cr = normalize(cross(vec3(0, 1, 0), cd)); // camera right\n\tvec3 cu = normalize(cross(cd, cr)); // camera up\n\t\n\treturn mat3(-cr, cu, -cd);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n  vec2 mouseUV = iMouse.xy/iResolution.xy; // Range: <0, 1>\n  vec3 backgroundColor = vec3(0.835, 1, 1);\n\n  vec3 col = vec3(0);\n  \n  // Camera position is stored on texel position (0,0)\n  // Camera direction is stored on texel position (1,0)\n  vec3 camPos = texelFetch(iChannel0, ivec2(0, 0), 0).xyz;\n  vec3 camDir = texelFetch(iChannel0, ivec2(1, 0), 0).xyz;\n  \n  vec3 lp = camPos + camDir;\n  vec3 rd = camera(camPos, lp) * normalize(vec3(uv, -1)); // ray direction\n\n  Surface co = rayMarch(camPos, rd, MIN_DIST, MAX_DIST); // closest object\n\n  if (co.sd > MAX_DIST) {\n    col = backgroundColor; // ray didn't hit anything\n  } else {\n    vec3 p = camPos + rd * co.sd; // point on cube or floor we discovered from ray marching\n    vec3 normal = calcNormal(p);\n    vec3 lightPosition = vec3(2, 8, 7);\n    vec3 lightDirection = normalize(lightPosition - p);\n\n    float dif = clamp(dot(normal, lightDirection), 0.3, 0.6); // diffuse reflection\n\n    col = dif * co.col + backgroundColor * .2; // Add a bit of background color to the diffuse color\n  }\n\n  // Output to screen\n  fragColor = vec4(col, 1.0);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"const int KEY_W = 87;\nconst int KEY_A = 65;\nconst int KEY_S = 83;\nconst int KEY_D = 68;\n\nconst int KEY_UP    = 38;\nconst int KEY_LEFT  = 37;\nconst int KEY_DOWN  = 40;\nconst int KEY_RIGHT = 39;\n\nconst float PI = 3.14159265359;\n\nconst vec3 INITIAL_CAM_POS = vec3(-7, 4, 1);\nconst vec3 INITIAL_CAM_DIR = vec3(1, -0.7, -1);\n\nconst float MOVE_SPEED = 10.0; // Change this to change the movement speed\nconst float ROT_SPEED = 2.0 * PI / 5.0; // Change this to change the rotation speed\n\nconst float TOLERANCE = 0.1; // To avoid Gimbal lock\n\n// Rotation matrix around the Y axis\nmat3 rotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, 0, s),\n        vec3(0, 1, 0),\n        vec3(-s, 0, c)\n    );\n}\n\n// Rotation matrix around the X axis\nmat3 rotateX(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(1, 0, 0),\n        vec3(0, c, -s),\n        vec3(0, s, c)\n    );\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    \n    // The return value: either a camera position or a direction\n    vec3 res = vec3(0);\n    \n    // Ask the camera position and the direction from the previous frame\n    // Camera position is stored on texel position (0,0)\n    // Camera direction is stored on texel position (1,0)\n    vec3 camPos = texelFetch(iChannel0, ivec2(0, 0), 0).xyz;\n    vec3 camDir = texelFetch(iChannel0, ivec2(1, 0), 0).xyz;\n\n    // Trick to initialize camera position and direction at the beginning\n    // to whatever we want\n    if (camDir == vec3(0.0)) camPos = INITIAL_CAM_POS;\n    if (camDir == vec3(0.0)) camDir = normalize(INITIAL_CAM_DIR);\n    \n    // In both cases we have to know the \"right\" direction,\n    // where \"front\" is camDir, and \"up\" is (0,1,0)\n    vec3 camRightDir = normalize(cross(vec3(0, 1, 0), camDir));\n\n    // Camera position change\n    if (int(fragCoord.x) == 0) {\n    \n        // The amount we want to move forward/backward\n        float stepForward = texelFetch(iChannel1, ivec2(KEY_W, 0), 0).r -\n                texelFetch(iChannel1, ivec2(KEY_S, 0), 0).r;\n        // Adjust to speed\n        stepForward *= iTimeDelta * MOVE_SPEED;\n        \n        // The amount we want to step left/right\n        float stepSideways = texelFetch(iChannel1, ivec2(KEY_A, 0), 0).r -\n                texelFetch(iChannel1, ivec2(KEY_D, 0), 0).r;\n        // Adjust to speed\n        stepSideways *= iTimeDelta * MOVE_SPEED;\n\n        // Change the camera position and set the return value\n        camPos += stepForward * camDir + stepSideways * camRightDir;\n        res = camPos;\n    }\n    \n    // Camera direction change\n    if (int(fragCoord.x) == 1) {\n\n        // The amount we want to turn left/right\n        float rotY = texelFetch(iChannel1, ivec2(KEY_RIGHT, 0), 0).r -\n                texelFetch(iChannel1, ivec2(KEY_LEFT, 0), 0).r;\n        // Adjust to speed\n        rotY *= iTimeDelta * ROT_SPEED;\n\n        // The amount we want to turn ud/down\n        float rotX = texelFetch(iChannel1, ivec2(KEY_DOWN, 0), 0).r -\n                texelFetch(iChannel1, ivec2(KEY_UP, 0), 0).r;\n        // Adjust to speed\n        rotX *= iTimeDelta * ROT_SPEED;\n        \n        // Rotate the camera along the Y axis\n        camDir = rotateY(rotY) * camDir;\n\n        // Save camDir (see down below)\n        vec3 camDirBeforeRotX = camDir;\n        \n        // Rotate the camera along the \"right\" axis (camRightDir)\n        // This is done by Rodrigues' rotation formula:\n        // https://en.wikipedia.org/wiki/Rodrigues%27_rotation_formula\n        camDir = camDir * cos(rotX) + cross(camRightDir, camDir)*sin(rotX) + camRightDir*dot(camRightDir, camDir)*(1. - cos(rotX));\n        \n        // If camDir is too close to down or up, things can be messy due to Gimbal lock\n        // To avoid this, we restore camDir to the previous value\n        if (distance(camDir, vec3(0, -1, 0)) < TOLERANCE\n                || distance(camDir, vec3(0, 1, 0)) < TOLERANCE)\n            camDir = camDirBeforeRotX;\n        \n        // To avoid accumulating numeric errors due to the rotations\n        camDir = normalize(camDir);\n        \n        // Set the return value\n        res = camDir;\n    }\n    \n    fragColor = vec4(res, 1.0);\n}","name":"Buffer A","description":"","type":"buffer"}]}