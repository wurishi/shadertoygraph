{"ver":"0.1","info":{"id":"3t2SWc","date":"1567336359","viewed":197,"name":"Inside Mengers Pyramid","username":"96logda","description":"All pyramids in this shader was made by using Menger Sponge fractal algorithm.","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["fractal","reflection","shadow","marching","menger","ao","sponge","mengersponge","world","pyramid"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGRn","filepath":"/media/a/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg","previewfilepath":"/media/ap/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dX3Rr","filepath":"/media/a//media/previz/cubemap00.png","previewfilepath":"/media/ap//media/previz/cubemap00.png","type":"cubemap","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Copyright (c) 2019-09-09-01 - 2019-09-08 by Angelo Logahd\n//Portfolio: https://angelologahd.wixsite.com/portfolio\n\n#define PI\t\t\t\t\t3.14\n\n#define saturate(x) \t\tclamp(x, 0.0, 1.0)\n#define dot2(x) \t\t\tdot(x, x)\n\n#define PYRAMID_1\t0\n#define PYRAMID_2   1\n#define PYRAMID_3\t2\n#define PYRAMID_4\t3\n#define PYRAMID_5\t4\n#define PYRAMID_6\t5\n#define PYRAMID_7\t6\n#define PYRAMID_8\t7\n#define PYRAMID_9\t8\n#define PYRAMID_10\t9\n\n//Change this line to see different pyramids\n#define PYRAMID_TYPE PYRAMID_8\n\n#if PYRAMID_TYPE == PYRAMID_1 || PYRAMID_TYPE == PYRAMID_2 || PYRAMID_TYPE == PYRAMID_5 || PYRAMID_TYPE == PYRAMID_9 || PYRAMID_TYPE == PYRAMID_10\n#define MENGER_ITERATIONS\t2\n#else\n#define MENGER_ITERATIONS\t3\n#endif\n\n#define SOFT_SHADOW_STEPS \t16\n\n#define INTERSECT_STEPS\t\t500\n#define INTERSECT_MIN_DIST\t0.0001\n#define INTERSECT_MAX_DIST\t100.0\n\n\nvec2 rotate2D(vec2 p, float angle)\n{\n    float sRot = sin(angle);\n    float cRot = cos(angle);\n    return p * cRot + p.yx * sRot * vec2(-1.0, 1.0);\n}\n\nfloat sdPlane(vec3 p, float height)\n{\n   \treturn p.y - height;\n}\n\nfloat pyramidPrism(vec3 p, float radius, float height, vec2 xyShapeMul)\n{\n     #if PYRAMID_TYPE == PYRAMID_1\n     return max(p.z - height, max(p.x * xyShapeMul.x + p.y * xyShapeMul.y, p.y) - radius);\n     #else\n     vec3 q = abs(p);\n     return max(q.z - height, max(q.x * xyShapeMul.x + q.y * xyShapeMul.y, q.y) - radius);\n     #endif\n}\n\nfloat hexPrism(vec3 p, float radius, float height, vec2 xyShapeMul)\n{\n     vec3 q = abs(p);\n     return max(q.z-height, max((q.x * xyShapeMul.x + q.y * xyShapeMul.y), q.y) - radius);\n}\n\nfloat hexDiamondPrism(vec3 p, float radius, float height)\n{\n     return hexPrism(p, radius, height, vec2(0.5, 0.95));\n}\n\nfloat ramp(vec3 p, vec2 size)\n{\n     return hexPrism(vec3(p), size.x, size.y, vec2(0.5, 0.8)); \n}\n\nvec4 opU(vec4 d1, vec4 d2)\n{\n     return (d1.x < d2.x) ? d1 : d2;\n}\n\nvec4 map(in vec3 p)\n{\t\n    float ground = sdPlane(p, 1.8);\n    \n    #if   PYRAMID_TYPE == PYRAMID_1\n    p.xz = mod(p.xz + 1.0, 2.0) -1.0;\n    p.y  = mod(p.y  + 1.0, 2.0) - 1.0;\n    p = -abs(p);\n    #elif PYRAMID_TYPE == PYRAMID_2\n    p.xz = mod(p.xz + 1.0, 2.0) -1.0;\n    p.y  = mod(p.y  + 1.0, 2.0) - 1.0;\n    p = abs(p);\n    #else\n    p.xz = mod(p.xz + 1.0, 2.0) - 1.0;\n    p.y  = mod(p.y  + 1.0, 2.0) - 1.0;\n    #endif\n    \n    #if   PYRAMID_TYPE == PYRAMID_1\n    p = -abs(p);\n    #elif PYRAMID_TYPE == PYRAMID_2\n    p = abs(p);\n    #endif\n    \n    #if PYRAMID_TYPE == PYRAMID_1\n    float d = pyramidPrism(p, 0.5, 0.5, vec2(0.5));\n    #elif PYRAMID_TYPE == PYRAMID_2 || PYRAMID_TYPE == PYRAMID_10\n    float d = pyramidPrism(p, 0.55, 2.5, vec2(0.5));\n    #elif PYRAMID_TYPE == PYRAMID_7\n    float d = pyramidPrism(p, 0.45, 2.5, vec2(0.5));\n    #else\n    float d = pyramidPrism(p, 0.8, 2.5, vec2(0.7));\n    #endif\n\n    vec4 res = vec4(d, 1.0, 0.0, 2.0);\n\t \n    #if\t  PYRAMID_TYPE == PYRAMID_3\n    float s = 1.68;\n    #elif PYRAMID_TYPE == PYRAMID_4\n    float s = 1.6;\n    #else\n    float s = 1.0;\n    #endif\n    for(int i = 0; i < MENGER_ITERATIONS; ++i)\n    {\n        #if   PYRAMID_TYPE == PYRAMID_2\n        vec3 a = mod(p * s, 3.0) - 1.0;\n        #else\n        vec3 a = mod(p * s, 2.0) - 1.0;\n        #endif\n        \n        #if   PYRAMID_TYPE == PYRAMID_1\n        s *= 10.0;\n        #elif PYRAMID_TYPE == PYRAMID_2 || PYRAMID_TYPE == PYRAMID_3\n        s *= 11.0;\n        #elif PYRAMID_TYPE == PYRAMID_9\n        s *= 12.0;\n        #elif PYRAMID_TYPE == PYRAMID_10\n        s *= 20.0;\n        #else\n        s *= 3.0;\n        #endif\n        \n        vec3  r  = abs(1.0 - 3.0 * abs(a));\n        float da = max(r.x, r.y);\n        float db = max(r.y, r.z);\n        float dc = max(r.z, r.x);\n        \n        #if PYRAMID_TYPE == PYRAMID_4\n        float c = (min(da, min(db, dc)) - 1.05) / s;\n        #elif  PYRAMID_TYPE == PYRAMID_6\n        float c = (min(da, min(db, dc)) - 0.85) / s;\n        #else\n        float c = (min(da, min(db, dc)) - 1.00) / s;\n        #endif\n\n        if(c > d)\n        {\n            d = c;\n            res = vec4(d, min(res.y, 0.2 * da * db * dc), 0.0, 1.0);\n        }\n    }\n    \n    #if PYRAMID_TYPE == PYRAMID_8\n    float d2 = pyramidPrism(p - vec3(0.0, 0.45, 0.0), 0.15, 0.5, vec2(0.5));\n    res = min(res, vec4(d2, 1.0, 0.0, 2.0));\n    \n    // Right Wall\n    float d3 = pyramidPrism(p - vec3(0.0, 0.0, 1.8), 0.5, 1.0, vec2(1.0));\n    res = min(res, vec4(d3, 1.0, 0.0, 2.0));\n    \n    // Left Wall\n    float d4 = pyramidPrism(p - vec3(0.0, 0.0, -1.8), 0.5, 1.0, vec2(1.0));\n    res = min(res, vec4(d4, 1.0, 0.0, 2.0));\n    \n    //.....................................................................\n    //\t\t\t\t\t\t\t\tLeft\n    //.....................................................................\n    float d5 = ramp(p + vec3(0.2, 0.2, 0.7), vec2(0.03));\n    res = min(res, vec4(d5, 1.0, 0.0, 2.0));\n    \n    float d6 = hexDiamondPrism(p + vec3(0.2, 0.159, 0.7), 0.01, 0.01);\n    res = min(res, vec4(d6, 1.0, 0.0, 2.0));\n    \n    float d7 = ramp(p + vec3(-0.2, 0.2, 0.7), vec2(0.03));\n    res = min(res, vec4(d7, 1.0, 0.0, 2.0));\n    \n    float d8 = hexDiamondPrism(p + vec3(-0.2, 0.159, 0.7), 0.01, 0.01);\n    res = min(res, vec4(d8, 1.0, 0.0, 2.0));\n    //.....................................................................\n    \n    //.....................................................................\n    //\t\t\t\t\t\t\t\tRight\n    //.....................................................................\n    float d9  = ramp(p + vec3(0.2, 0.2, -0.7), vec2(0.03));\n    res = min(res, vec4(d9, 1.0, 0.0, 2.0));\n    \n    float d10 = hexDiamondPrism(p + vec3(0.2, 0.159, -0.7), 0.01, 0.01);\n    res = min(res, vec4(d10, 1.0, 0.0, 2.0));\n    \n    float d11 = ramp(p + vec3(-0.2, 0.2, -0.7), vec2(0.03));\n    res = min(res, vec4(d11, 1.0, 0.0, 2.0));\n    \n    float d12 = hexDiamondPrism(p + vec3(-0.2, 0.159, -0.7), 0.01, 0.01);\n    res = min(res, vec4(d12, 1.0, 0.0, 2.0));\n    //.....................................................................   \n    #endif\n    \n    return opU(res, vec4(ground, 1.0, 0.0, -0.5));\n}\n\nvec4 intersect(in vec3 ro, in vec3 rd)\n{\n    float t = 0.0;\n    vec4 res = vec4(-1.0);\n    vec4 h = vec4(1.0);\n    for (int i = 0; i < INTERSECT_STEPS; i++ )\n    {\n\t\tif(h.x < INTERSECT_MIN_DIST || t > INTERSECT_MAX_DIST) \n\t\t{\n\t    \tbreak;\n\t\t}\n\t\n        h = map(ro + rd * t);\n        res = vec4(t, h.yzw);\n        t += h.x;\n    }\n\n    if (t > INTERSECT_MAX_DIST) \n    {\n\t\tres = vec4(-1.0);\n    }\n    \n    return res;\n}\n\nfloat softshadow(in vec3 ro, in vec3 rd)\n{\n    float res = 1.0;\n    float t = 0.0;\n    for (int i = 0; i < SOFT_SHADOW_STEPS; ++i)\n    {\n\t\tvec3 pos = ro + rd * t;\n        float h = map(pos).x;\n        res = min(res, float(SOFT_SHADOW_STEPS) * h / t);\n        if(res < 0.0001)\n\t\t{\n\t    \tbreak;\n\t\t}\n        t += clamp(h, 0.01, 0.2);\n    }\n    return saturate(res);\n}\n\nvec3 calcNormal(in vec3 pos)\n{\n    vec3 eps = vec3(0.0001, 0.0, 0.0);\n    vec3 n;\n    n.x = map(pos + eps.xyy).x - map(pos - eps.xyy).x;\n    n.y = map(pos + eps.yxy).x - map(pos - eps.yxy).x;\n    n.z = map(pos + eps.yyx).x - map(pos - eps.yyx).x;\n    return normalize(n);\n}\n\nvec3 texture3D(sampler2D texChannel, in vec3 p, in vec3 normal)\n{\n    normal = max(abs(normal), 0.001);\n    normal /= (normal.x + normal.y + normal.z);  \n    return (texture(texChannel, p.yz) * normal.x + \n            texture(texChannel, p.zx) * normal.y +\n            texture(texChannel, p.xy) * normal.z).rgb;\n}\n\nvec3 GetMaterialColor(in vec3 p, in vec3 normal, float materialID)\n{ \n     if (materialID > 0.0)\n     {\n         #if   PYRAMID_TYPE == PYRAMID_3\n     \t vec3 texRGB = texture3D(iChannel0, p * 10.0, normal);     \n     \t return texRGB * 0.45 * vec3(1.0, 0.35, 1.0);\n         #elif PYRAMID_TYPE == PYRAMID_4\n         vec3 texRGB = texture(iChannel2, p * normal).rgb * 2.0;\n         return texRGB * 0.45 * vec3(1.0, 0.35, 1.0);\n         #else\n         vec3 texRGB = texture3D(iChannel0, p * 5.0, normal);\n         vec3 cracks = texture3D(iChannel1, p * 5.0, normal).rgb;\n         //texRGB = mix(texRGB, cracks, 0.35); //Cracks\n     \t return texRGB * 0.45 * vec3(1.0, 0.35, 1.0);\n         #endif\n     }\n     //Floor\n     else if (materialID == -0.5)\n     {\n         #if   PYRAMID_TYPE == PYRAMID_3\n     \t vec3 texRGB1 = texture(iChannel0, p.xz * 3.5, 0.0).rgb;\n         vec3 texRGB2 = texture(iChannel1, p.xz).rgb;\n         vec3 texRGB  = mix(texRGB1, texRGB2, 0.5);\n     \t return texRGB * 0.25 * vec3(1.0, 0.35, 1.0);\n         #elif PYRAMID_TYPE == PYRAMID_4\n         return texture(iChannel0, p.xz * 25.0).rgb;\n         #elif PYRAMID_TYPE == PYRAMID_8 || PYRAMID_TYPE == PYRAMID_9\n         return texture(iChannel1, p.xz * 5.0).rgb * vec3(0.5, 0.15, 0.0);\n         #else\n         vec3 texRGB = texture(iChannel0, p.xz * 3.5, 0.0).rgb;\n     \t return texRGB * 0.2 * vec3(1.0, 0.35, 1.0);\n         #endif\n     }\n     return vec3(0.0);\n}\n\nvec3 render(in vec3 ro, in vec3 rd)\n{\n    vec3 color = vec3(0.0);\n    vec4 res = intersect(ro, rd);\n    if(res.x > 0.0)\n    {\n        const vec3 light = vec3(0.0, 0.0, -0.03);\n        \n        vec3 pos = ro + res.x * rd; \n        vec3 normal = calcNormal(pos);\n        \n        float occ = res.y;\n        float shadow = softshadow(pos + 0.01 * normal, light);\n        \n        vec3 baseColor = GetMaterialColor(pos, normal, res.w);\n        vec3 ambient = vec3(0.2) * baseColor;      \n\n        vec3 diffuse = baseColor * shadow * occ;\n        color = diffuse + (ambient * occ);\n    }\n\n    #if PYRAMID_TYPE == PYRAMID_3 || PYRAMID_TYPE == PYRAMID_4 || PYRAMID_TYPE == PYRAMID_5 || PYRAMID_TYPE == PYRAMID_7 || PYRAMID_TYPE == PYRAMID_8 || PYRAMID_TYPE == PYRAMID_9\n    color *= 0.5;\n    #endif\n    \n    return pow(color, vec3(0.4545));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) \n{\n    vec2 p = 2.0 * (fragCoord.xy / iResolution.xy) - 1.0;\n    p.x *= iResolution.x / iResolution.y;\n\t \n    vec2 mouseXY = iMouse.xy / iResolution.xy;\n    \n    // camera\n    vec3 ro = vec3(15.0, 2.9, -2.0);\n    vec3 ww = normalize(vec3(0.0, mouseXY.y * 5.0 * PI, 0.0) - ro); \n    ww.xz = rotate2D(ww.xz, iMouse.x * 2.0 * PI);\n    vec3 uu = normalize(cross(vec3(0.0, 1.0, 0.0), ww));\n    vec3 vv = normalize(cross(ww, uu));\n    vec3 rd = normalize(p.x * uu + p.y * vv + 2.0 * ww);\n    rd.xz = rotate2D(rd.xz, PI * 2.0);\n\n    ro.x -= iTime * 0.1; //Camera movement\n    \n    #if PYRAMID_TYPE == PYRAMID_1 || PYRAMID_TYPE == PYRAMID_2 || PYRAMID_TYPE == PYRAMID_10\n    vec3 color = vec3(0.2);\n    color -= vec3(0.3, 0.3, 0.9);\n \tcolor += render(ro + vec3(0.0, -1.0, 0.0), rd);\n    #else\n    vec3 color = vec3(0.0);\n \tcolor += render(ro + vec3(0.0, -1.0, 0.0), rd);\n    color += render(ro + vec3(0.0,  1.0, 0.0), rd);\n    color -= vec3(0.18, 0.15, 0.8);\n    #endif\n    \n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dX3Rr","channel":0}],"code":"\nvoid mainCubemap( out vec4 fragColor, in vec2 fragCoord, in vec3 rayOri, in vec3 rayDir )\n{\n    fragColor.rgb = rayDir * rayDir;\n    fragColor.a = 1.0;\n}","name":"Cube A","description":"","type":"cubemap"}]}