{"ver":"0.1","info":{"id":"M3c3Ds","date":"1717130142","viewed":64,"name":"Bezier Curves!","username":"Data_chan","description":"A simple bezier curve thingy. I wanted to test out my new line drawing code, and wanted to make a bezier curve function. 3rd control point is controlled by the mouse.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["bezier","utility","demo"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 newUV = uv*100.0;\n    \n    vec4 out_color;\n    \n    float t = fract(float(iFrame)/(60.0*5.0));\n    \n    vec2[4] points;\n    \n    points = vec2[4](\n    vec2(0.0, 0.0),\n    vec2(50.0, 0.0),\n    vec2(((iMouse.xy)/iResolution.xy)*100.0),\n    vec2(100.0, 100.0)\n    );\n    \n    t = float(cubicBezierPoint(points, t).x/100.0);\n    \n    vec2 out_point = cubicBezierPoint(points, t);\n    \n    out_color = vec4(distance(vec2(fragCoord), (out_point/100.0)*vec2(iResolution.xy)))/10.0;\n    \n    out_color = vec4(clamp(out_color.x, 0.0, 1.0)-(cubicBezierLine(points, t, newUV, 0.2, 64 ))*0.5);\n    \n    // Output to screen\n    fragColor = vec4(out_color);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"vec2 cubicBezierPoint( vec2[4] points, float t )\n{\n\n    return vec2(mix(\n                                mix(\n                                    mix(points[0], points[1], t),\n                                    mix(points[1], points[2], t)\n                                , t),\n                                mix(\n                                    mix(points[1], points[2], t),\n                                    mix(points[2], points[3], t)\n                                , t),\n                                t));\n}\n\nfloat drawLine( vec2 point1, vec2 point2, vec2 sampleCoord, float lineThickness)\n{\n    //Input Guide:\n    //vec2 point1 - Coordinate of first point.\n    //vec2 point2 - Coordinate of second point.\n    //vec2 sampleCoord - Coordinate of pixel. The function checks if this coordinate is in the line.\n    //float lineThickness - Thickness of the line.\n    \n    \n    //we get the slope from point 1 to point 2 then normalize it\n    vec2 slope = normalize(point2-point1);\n    \n    float inLine;\n    \n    //distance from the pixel to the 2nd point\n    inLine = float(distance(sampleCoord, point2));\n    \n    //We calculate wether the point is on the line. Both points are calculated seperately, because each one returns a ray.\n    //We can combine the two results to get a line segment. You could also replace the max( with min( to get an infinite line\n    inLine = max(\n                float(distance((((distance(sampleCoord, point2))*slope)+sampleCoord), point2)),  \n                float(distance((((distance(sampleCoord, point1))*(slope*-1.0))+sampleCoord), point1))\n                );\n    \n    //turn the line gradient into a solid shape\n    inLine = float(lessThan(vec2(inLine), vec2(lineThickness)).x);\n    \n    return inLine;\n}\n\nfloat cubicBezierLine( vec2[4] points, float t, vec2 sampleCoord, float lineThickness, int steps )\n{\n    float out_value;\n    \n    for (int j = 0; j<(steps); j+= 1) {\n    \n    out_value = out_value+drawLine(cubicBezierPoint(points, float(j)/float(steps)), cubicBezierPoint(points, float(j+1)/float(steps)), sampleCoord, lineThickness);\n    \n    };\n    \n    return clamp(out_value, 0.0, 1.0);\n}","name":"Common","description":"","type":"common"}]}