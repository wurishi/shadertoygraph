{"ver":"0.1","info":{"id":"cdj3DV","date":"1668798711","viewed":401,"name":"That scan thing in modern games ","username":"Oneleven","description":"Press R3\nWell actually, use mouse to rotate.","likes":24,"published":1,"flags":0,"usePreview":0,"tags":["terrain","scan"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define T iTime\n#define pix 2.0/iResolution.y\n\n//Terrain Noise\n#define FREQUENCY 0.20\n#define OCTAVES 5.0\n#define AMPLITUDE 3.0\n#define GAIN 0.6\n#define LACUNARITY 2.0\n\n//Raymarch\n#define EPSILON 1e-4\n#define MAX_STEPS 64\n#define MAX_DIST 90.0\n\n//FabriceNeyret2 + IQ hash\n//https://www.shadertoy.com/view/fsKBzw\nfloat hash( vec2 f ) {   \n    uvec2 x = uvec2( floatBitsToUint(f.x), floatBitsToUint(f.y) ),\n          q = 1103515245U * ( x>>1U ^ x.yx    );\n    return float( 1103515245U * (q.x ^ q.y>>3U) ) / float(0xffffffffU);\n}\n\n//Hash without Sine by \"Dave_Hoskins\"\n//https://www.shadertoy.com/view/4djSRW\nvec2 hash21(float p)\n{\n\tvec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nfloat vNoise(vec2 uv)\n{\n    vec2 index = floor(uv);\n    uv = fract(uv);\n    uv = smoothstep(0., 1., uv);\n    \n    float x1 = mix(hash(index), hash(index + vec2(1., 0.)), uv.x);\n    float x2 = mix(hash(index + vec2(0., 1.)), hash(index + vec2(1)), uv.x);\n    return mix(x1, x2, uv.y);\n}\n\n\nfloat fbm(vec2 uv) \n{\n    float frequency = FREQUENCY; \n    float amplitude = AMPLITUDE;\n    float value = 0.;\n    for (float i = 0.; i < OCTAVES; i++)\n    {\n        value += vNoise(uv * frequency) * amplitude;\n        amplitude *= GAIN;\n        frequency *= LACUNARITY;\n    }\n    return value;\n}\n\nvec3 normal(vec3 p)\n{\n    float eps = 0.001;\n    return normalize(vec3(fbm(vec2(p.x - eps, p.z)) - fbm(vec2(p.x + eps, p.z)),\n                          2. * eps,\n                          fbm(vec2(p.x, p.z - eps)) - fbm(vec2(p.x, p.z + eps))));\n}\n\n\n//Thanks alro! :)\n//Binary search for 0 crossing given two points on either side of the surface\nfloat bisection(vec3 start, vec3 rayDir, float near_, float far_){\n    float midpoint = (far_ + near_) * 0.5;\n    //Sample point\n    vec3 p = vec3(0);\n    float near = near_;\n    float far = far_;\n    float height = 0.0;\n    //Difference between sample point and terrain heights\n    float diff = 0.0;\n    \n    for(int i = 0; i < 8; i++){\n        p = start + rayDir * midpoint;\n        height = fbm(vec2(p.x, p.z));\n        diff = p.y - height;\n        \n        if(abs(diff) < EPSILON){\n        \tbreak;\n        }else{\n            \n            if(diff < EPSILON){\n                //Point is below terrain\n                //Search first half\n                far = midpoint;\n            }else{\n                //Point is above terrain\n                //Search second half\n                near = midpoint;\n            }\n            midpoint = (far + near) * 0.5;\n        }\n    }\n    return midpoint;\n}\n\nfloat getIntersection(vec3 start, vec3 rayDir, float maxDist){\n\t//Distance between sample points. Set according to previous sample\n    float stepSize = 0.0;\n    //Height of the terrain\n    float height = 0.0;\n    //Length of the ray\n    float dist = 0.0;\n    //Difference between sample point and terrain heights\n    float diff = 0.0;\n    \n    for(int i = 0; i < MAX_STEPS; i++){\n        //Sample point\n        vec3 p = start + rayDir * dist;\n        \n        //The height of the terrain at the xz coordinates of the sample point\n        height = fbm(vec2(p.x, p.z));\n        diff = abs(p.y - height);\n        //If sample point is close enough to the terrain, return distance\n        if(diff < EPSILON){\n            return dist;\n        }\n        //If height of sample point is less than the height of the terrain,\n        //the ray has hit the terrain. Use bisection to find the 0 crossing\n        if(p.y < height){\n        \tdist = bisection(start, rayDir, dist - stepSize, dist);\n            return dist;\n        }\n        \n        //Static step size misses features and leads to banding. \n        //Set the step size to a fraction of the distance above the terrain.\n        //Could also have a small step size which increases with distance, giving \n        //detailed results close to the camera and reaching far. However, \n        //this approach is used in many shaders and seems to give best results\n        stepSize = diff * 0.5;\n        \n        //Increment ray\n        dist += stepSize;\n        \n        if(dist > MAX_DIST){\n        \treturn MAX_DIST;\n        }\n    }\n    return dist;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy)/iResolution.x;\n    \n    //camera tutorial by BigWIngs (ArtOfCode)\n    //https://www.youtube.com/watch?v=PBxuVlp7nuM&t=130s\n    float mX = iMouse.x/iResolution.x * 2.0 * 3.141592;\n    float mY = iMouse.y/iResolution.y * 30.0;\n    vec3 offset = vec3(T*2., 0., 0.);\n    vec3 ro = vec3(sin(mX) * (30. -mY), mY + 10., cos(mX) * (30. - mY)) + offset;\n    vec3 lp = vec3(0., 1., 0.) + offset;\n    \n    vec3 f = normalize(lp - ro);\n    vec3 r = normalize(cross(vec3(0., 1., 0.), f));\n    vec3 u = cross(f, r);\n    vec3 rd = f + r * uv.x + u * uv.y;\n    \n    float dist = getIntersection(ro, rd, MAX_DIST);\n    vec3 pp = ro + rd * dist;\n    vec3 n = normal(pp);\n    \n    //scan distance relative to pulse origin\n    float sD = distance(floor((lp.xz)/8.0)*8.0, vec2(pp.x, pp.z)); \n    \n    vec3 col = vec3(0);\n    //pulse\n    float pR = mod(T*30., 120.); //pulseRadius\n    float m1 = smoothstep(pR + 2., pR, sD); //mask\n    col += smoothstep(pR - 10., pR, sD) * vec3(0.0, 0.7, 1.) * m1;\n    \n    //stripes\n    col += mix(vec3(0.4, 0.0, 0.), vec3(0., 0.25, 0.55), smoothstep(0.4, 0.8, dot(n, vec3(0.,1.,0.)))) //color\n         * smoothstep(0.85, 1., abs(fract(sD * 3.0) - 0.5) * 2.0) //stripes shape\n         * m1 * smoothstep(pR - 80., pR - 40., sD); //masks\n         \n    //point\n    //\"The simplest 3D\" by BigWIngs https://www.youtube.com/watch?v=dKA5ZVALOhs\n    vec3 p = lp + vec3(0., 5., 0.);\n    col += vec3(smoothstep(0.3, 0.3 - pix*20.0, length(cross(p - ro, rd))/length(rd)));\n    \n    //terrain\n    col += vec3(fbm(vec2(pp.x, pp.z))) * GAIN/AMPLITUDE * smoothstep(8., 0., distance(p.xz, vec2(pp.x, pp.z))) * vec3(0.0, 0.1, 0.4);\n    \n    //fade scan with distance\n    col = mix(col, vec3(0.0, -0.2, 0.), smoothstep(MAX_DIST - 50.0, MAX_DIST, dist));\n    \n    //background\n    col +=vec3(0.0, 0.0, 0.15);\n    fragColor = vec4(col, 1.);\n}","name":"Image","description":"","type":"image"}]}