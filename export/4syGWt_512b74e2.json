{"ver":"0.1","info":{"id":"4syGWt","date":"1456905391","viewed":1253,"name":"Parametric Octree","username":"Panoptics","description":"An implementation of  https://www.researchgate.net/publication/2395157_An_Efficient_Parametric_Algorithm_for_Octree_Traversal modified for webgl (can't use array indexed lookup without resorting to tomfoolery, so have to use branches in proc_subvoxel_n )","likes":11,"published":1,"flags":0,"usePreview":0,"tags":["raycast","octree"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const vec3 dimensions = vec3(16.0);\nconst vec3 zero = vec3(0);\nconst vec3 one = vec3(1.0);\nconst ivec3 iX = ivec3(1,2,4);\n\nint count =0;\nvec3 op0,op1;\nvec3 rayInvert;\nfloat s, c;\n\nint hsum(ivec3 i){return (i.x+i.y+i.z);}\nbvec3 arithXOR(bvec3 a, bvec3 b){return notEqual(a,b);}\nivec3 convert_index(bvec3 i){return ivec3(i)*iX;}\nint convert_plane(bvec3 p){return hsum(convert_index(p));}\nint convert_planeXOR(bvec3 p){return hsum(convert_index(arithXOR(p,bvec3(rayInvert.zyx))));}\n#define rotate(p, a) mat2(c=cos(a), s=-sin(a), -s, c) * p\n\nint get_entry_plane(vec3 t0, vec3 tm){\n    vec3 test   = step( t0.yzz,t0.xxy);\n    vec3 mixed  =  mix( t0.zzz, t0.xxx, test.yyy );\n    vec3 mixed2 =  mix( t0.zzz, t0.yyy, test.zzz );\n    vec3 comb   =  mix( mixed2, mixed,  test.xxx );\n    vec3 plane  = step( tm.zyx, comb );\n    return convert_plane( bvec3(plane) );\n}\n\nint get_exit_plane(const vec3 t1){\n    vec3 test = step(t1.yzz,t1.xxy);\n    return int(mix( test.yy*2.0, test.zz+1.0, test.xx ).x);\n}\n\nint dostuff(int i, const bvec3 axis, const vec3 t1, const vec3 tm){\n    if (i==7) return 8;\n//  o = convert_planeXOR(toggle.zyx); // Flip index back to world coordinates\n    vec3 t2 = mix(tm,t1,vec3(axis));\n    vec3 test = step(t2.yzz,t2.xxy);\n    int ep = int(mix( test.yy*2.0, test.zz+1.0, test.xx ).x);\n    return ep;\n}\n\n// This looks dirty now compared to the glsl version\n// but it works\nint proc_subvoxel_n(const int cursor, const vec3 t0, const vec3 t1, const vec3 tm, inout vec3 op0, inout vec3 op1){\n    int i;\n    if (cursor==0){\n        op0 = t0; \n        op1 = tm; \n        i= dostuff(0,bvec3(0,0,0), t1, tm);\n        if (i==0) i=4;\n        else if (i==1) i=2;\n        else i=1;\n    }\n    if (cursor==1){\n        op0 = vec3(t0.xy,tm.z); \n        op1 = vec3(tm.xy,t1.z); \n        i= dostuff(1,bvec3(false,false,true), t1, tm);\n        if (i==0) i=5;\n        else if (i==1) i=3;\n        else i=8;\n    }\n    if (cursor==2){\n        op0 = vec3(t0.x,tm.y,t0.z); \n        op1 = vec3(tm.x,t1.y,tm.z); \n        i= dostuff(2,bvec3(false,true,false), t1, tm);\n        if (i==0) i=6;\n        else if (i==1) i=8;\n        else i=3;\n    }\n    if (cursor==3){\n        op0 = vec3(t0.x,tm.yz); \n        op1 = vec3(tm.x,t1.yz); \n        i= dostuff(3,bvec3(false,true,true), t1, tm);\n        if (i==0) i=7;\n        else i=8;\n    }\n    if (cursor==4){\n        op0 = vec3(tm.x,t0.yz); \n        op1 = vec3(t1.x,tm.yz); \n        i= dostuff(4,bvec3(true,false,false), t1, tm);\n        if (i==0) i=8;\n        else if (i==1) i=6;\n        else i=5;\n    }\n    if (cursor==5){\n        op0 = vec3(tm.x,t0.y,tm.z); \n        op1 = vec3(t1.x,tm.y,t1.z); \n        i= dostuff(5,bvec3(true,false,true), t1, tm);\n        if (i==1) i=7;\n        else i=8;\n    }\n    if (cursor==6){\n        op0 = vec3(tm.xy,t0.z); \n        op1 = vec3(t1.xy,tm.z); \n        i= dostuff(6,bvec3(true,true,false), t1, tm);\n        if (i==2) i=7;\n        else i=8;\n    }\n    if (cursor==7){\n        op0 = tm; \n        op1 = t1; \n        i= dostuff(7,bvec3(true,true,true), t1, tm);\n        i=8;\n    }\n    return i;\n}\n\nvoid proc_node_last(vec3 t0, vec3 t1){\n    vec3 tm = 0.5 * (t0+t1);\n    int cursor = get_entry_plane(t0,tm);\n    for (int id=0; id<4;id++)\n    {\n        cursor = proc_subvoxel_n(cursor,t0,t1,tm,op0,op1);\n        count++;\n        if (cursor==8) break;\n    }\n}\n\n\n\nvec4 proc_node_1(vec3 t0, vec3 t1){\n    vec3 tm = 0.5 * (t0+t1);\n    int currentNode = get_entry_plane(t0,tm);\n\n    int cursor = currentNode;\n\n    for (int id=0; id<4;id++)\n    {\n        cursor = proc_subvoxel_n(cursor,t0,t1,tm,op0,op1);\n        proc_node_last(op0,op1);\n        count++;\n        if (cursor>=8) break;\n    }\n\n   return (vec4(count)/16.0);\n}\n\nvec4 proc_node(vec3 t0, vec3 t1){\n    //if (any(lessThan(t1,zero)))\n    //    return vec4(1.0);\n    // Midpoint\n    vec3 tm = 0.5 * (t0+t1);\n    int currentNode = get_entry_plane(t0,tm);\n\n    int cursor = currentNode;\n\n    for (int id=0; id<4;id++)\n    {\n        \n        cursor = proc_subvoxel_n(cursor,t0,t1,tm,op0,op1);\n        proc_node_last(op0,op1);\n        \n        count++;\n        if (cursor>=8) break;\n    }\n\n   return (vec4(count)/32.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 res    = iResolution.xy;\n    vec2 uv     = (fragCoord-.5*res) / res.y;\n    vec2 mPos   = 13.5 * (iMouse.xy-.5*res) / res.y;\n    \n    vec3 camPos = vec3(25.25,25.0,0.0)+vec3(mPos.y,0.0,-mPos.x);\n    vec3 rayDir = normalize(vec3(uv, 1.));\n    \n    rayDir.yz = rotate(rayDir.yz, -.720);\n    rayDir.xz = rotate(rayDir.xz, -1.70);\n    \n    rayInvert = vec3(lessThan(rayDir,zero));\n    vec3 rayDirNorm = mix( rayDir, -rayDir, (rayInvert));\n    vec3 origNorm = mix( camPos.xyz, -camPos.xyz, (rayInvert));\n    \n    vec3 rayInv = 1.0/rayDirNorm;\n    vec3 tmin = rayInv*(-dimensions-origNorm);\n    vec3 tmax = rayInv*(dimensions-origNorm);\n\n    vec3 hmax = max( max( tmin, tmin.yzx), tmin.zxy);\n    vec3 hmin = min( min( tmax, tmax.yzx), tmax.zxy);\n\n    if ( hmax.x < hmin.x && hmin.x>0.0 ){\n        fragColor= proc_node(tmin,tmax);\n    }else{\n        fragColor = vec4(.60);\n    }\n}","name":"Image","description":"","type":"image"}]}