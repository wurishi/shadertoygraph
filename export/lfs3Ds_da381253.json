{"ver":"0.1","info":{"id":"lfs3Ds","date":"1703706812","viewed":72,"name":"greek pot","username":"Efim","description":"for shape pot used larme curve:  https://mathcurve.com/courbes2d/larme/larme.shtml","likes":16,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","sdf","pattern","greek"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI  3.14159265359\n#define TAU 6.28318530718\n#define rot(f) mat2(cos(f), -sin(f), sin(f), cos(f))\n\n\nconst float dist_infin = 10.0;\n#define nn 128\nconst float eps = 0.001;\n\nvec3 sdfColor;\nvec3 resColor;\nvec3 col1 = vec3(.2);\nvec3 col2 = vec3(0.4745098039215686, 0.26666666666666666, 0.23137254901960785);\nvec3 col3 = vec3(1., 0.8431, 0.);\nfloat resReflect = 0.5;\nfloat sdfReflect;\n\nfloat mtime = 0.;\n//https://mathcurve.com/courbes2d/larme/larme.shtml\nfloat larme2(vec2 p, float a)\n{\n    float k = 0.3;\n    p.x += a*(k - 0.95)/2.0;\n    float zoom = 1.;\n    float x = clamp(p.x, -a*0.95, a*k);\n    float f = acos(x/a);\n    float y = a*sin(f)*pow(sin(f/2.), 2.)*zoom;\n    float d = length(p - vec2(x, y));\n    if (abs(p.y) < abs(y))\n    {\n        sdfReflect = 0.;\n        sdfColor = col2;\n    }\n    else\n    {\n        sdfReflect = 0.05;\n        sdfColor = col1;\n    }\n    \n    f = acos(k);\n    y = a*sin(f)*pow(sin(f/2.), 2.)*zoom;\n    float y2 = clamp(p.y, -y, y);\n    float d2 = length(p - vec2(k*a, y2));\n    if (d2 < d)\n    {\n        d = d2;\n        if (p.x > x)\n        {\n            sdfReflect = 0.05;\n            sdfColor = col1;\n        }\n        else\n        {\n            sdfReflect = 0.;\n            sdfColor = col2;\n        }\n    }\n    return d;\n}\nfloat larme(vec3 p, float a)\n{\n    float l = length(p.xy);\n    float d = larme2(vec2(p.z, l), a);\n    return d*0.3 - 0.02;\n}\n\n\nfloat men2(vec2 p)\n{\n    p*=vec2(8., 11.);\n    vec2 a = floor(p);\n    float res = 1.0;\n    if (a.y == 0. || a.y == 10.)\n        res = 0.0;\n    a.y = a.y - 2.;\n    float mx, mi;\n    \n    if (mod(a.y, 2.) == 0.)\n    {\n        float h = abs(3.-a.y);\n        float d = (a.y <=2.)? 0.:1.;\n        mi = 5.-h-d;\n        mx = 5.+h-2.*d;\n        if (a.x <= mx && a.x >= mi) \n            res = 0.;\n    }    \n    if (mod(a.x, 2.) == 0.)\n    {\n        mx = 0.;\n        mi = 1.;\n        if (a.x <= 4.)\n        {\n            float h = 3.-a.x;\n            mi = clamp(2.-h, 0., 6.);\n            mx = 3.+ h;\n\n        }\n\n        if (a.x == 6.0)\n        {\n            mi = 3.;\n            mx = 6.;\n        }\n\n        if (a.y <= mx && a.y >= mi) \n            res = 0.;\n        \n    }\n    \n    return res;\n}\n\n\n\n//https://www.shadertoy.com/view/4ljBWd\nfloat greekwave(vec2 U)\n{\n    U = fract(U)-.5;                           // local tile coords in [-.5,.5]Â²\n    \n    float v, d = length(U),                    // distance to tile center\n          t = 4.5*PI,                          // note the time delay with position\n          a = t * max(0.,.5-d );               // angle ~time, and decrease with d\n    U *= rot(a);   // rotate frame by angle(t,d)\n    v = U.y;   \n    float O = smoothstep(-1.,1.,v*500. );  \n    return O;     \n}\n\n\nfloat men3(vec2 p)\n{\n    p*=vec2(6.,7.);\n    vec2 a = floor(p);\n    float res = 1.0;\n    if (a.y == 0. || a.y == 6.)\n        res = 0.;\n    if (a.x == 0. && a.y < 6. && a.y > 2.)    \n        res = 0.;\n    if (a.y == 2. && (a.x < 2. || a.x == 5.))    \n        res = 0.;\n    if (a.y == 4. && a.x >= 2. && a.x <=4.)    \n        res = 0.;\n    if (a.x == 3. && a.y < 4.)    \n        res = 0.;\n    return res;    \n}\n\n\nfloat map(vec3 p) {\n    p.yz *= rot(-PI/2.);\n    p.yz *= rot(mtime/2.);\n    p.xz *= rot(mtime);\n    \n    \n    \n    \n    \n    float a = 3.;\n    float d = larme(p, a);\n\n    if (d <= 10.0*eps && sdfColor == col1)\n    {\n        float n = 20., dlon = TAU/n, lon = mod(atan(p.y, p.x), TAU), dx = fract(lon/dlon);\n        float k = 0.3;\n        p.z += a*(k - 0.95)/2.0;\n        float h = clamp(p.z, -a*0.95, a*k);\n        if (h > -a*0.9 && h < -a*0.8)\n        {\n            float dy = (h + a*0.9)/0.1/a, r = men2(vec2(1.-dx, dy));\n            if (r == 0.)\n            {\n                sdfReflect = 0.5;\n                sdfColor = col3;\n            }\n        }\n\n        if (h > -a*0.8 && h < -a*0.7)\n        {\n            float dy = (h + a*0.8)/0.1/a, r = greekwave(vec2(1.-dx, dy));\n            if (r == 1.)\n            {\n                sdfReflect = 0.5;\n                sdfColor = col3;\n            }\n        }\n        if (h > -a*0.7 && h < -a*0.5)\n        {\n            float dy = (h + a*0.7)/0.2/a, r = men2(vec2(1.-dx, dy));\n            if (r == 1.)\n            {\n                sdfReflect = 0.5;\n                sdfColor = col3;\n            }\n        }\n\n        if (h > a*0.2 && h < a*0.3)\n        {\n            float dy = (h - a*0.2)/0.1/a, r = men3(vec2(dx, dy));\n            if (r == 0.)\n            {\n                sdfReflect = 0.5;\n                sdfColor = col3;\n            }\n        }\n\n        \n    }\n\n\n    resColor = sdfColor;\n    resReflect = sdfReflect;\n    return d;\n}\n\n\nvec3 csky(vec3 p) {\n    float n = 6., m = 6., dlat = PI / n, dlon = TAU / m;\n    float lon = mod(atan(p.y, p.x), TAU), lat = atan(length(p.xy), p.z);\n    float fo = fract(lon / dlon), fa = fract(lat / dlat);\n\n    float pst = fo * fa * (1. - fo) * (1. - fa);\n    pst=pow(pst, 2.);\n\n    pst = smoothstep(0.0, pow(0.0625, 2.), pst);\n    pst = clamp(pst, 0.1, 1.0);\n    return vec3(pst);\n}\n\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal(in vec3 pos) {\n    const float h = 0.0001; // replace by an appropriate value\n    const vec2 k = vec2(1, -1);\n    return normalize(k.xyy * map(pos + k.xyy * h) +\n        k.yyx * map(pos + k.yyx * h) +\n        k.yxy * map(pos + k.yxy * h) +\n        k.xxx * map(pos + k.xxx * h));\n}\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l - p), r = normalize(vec3(f.z, 0, -f.x)), u = cross(f, r), c = f * z, i = c + uv.x * r + uv.y * u;\n    return normalize(i);\n}\n\n#if HW_PERFORMANCE==0\n#define AA 1\n#else\n#define AA 2\n#endif\n\n//#define AA 2\n\nvec3 calccolor(vec3 col, vec3 rd, vec3 light, vec3 nor) {\n    float d = dot(rd, nor);\n    nor *= -sign(d);\n    float difu = dot(nor, light);\n    col *= clamp(difu, 0.3, 1.0);\n    return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec3 light = normalize(vec3(1.0, -1.0, -1.)); //light\n    vec2 mo = vec2(0.0, 0.0);\n    mtime = iTime;\n    if  (iMouse.z > 0.0)\n    {\n        mo = (-iResolution.xy + 2.0 * (iMouse.xy)) / iResolution.y;\n        mtime = 0.;\n    }\n    vec3 ro = vec3(0.0, 0.0, 6.0); // camera\n    //camera rotation\n    ro.yz *= rot(mo.y * PI);\n    ro.xz *= rot(-mo.x * TAU);\n\n    const float fl = 1.5; // focal length\n    float dist = dist_infin;\n\n    vec3 b1 = vec3(0.23529411764705882, 0.4235294117647059, 0.7725490196078432), b2 = vec3(0.3686274509803922, 0.5725490196078431, 0.8941176470588236);\n    vec3 bg = mix(b2, b1*b1, fragCoord.y / iResolution.y);   \n    //vec3 bg = vec3(0.);\n    //antialiasing\n    vec3 tot = vec3(0.0);\n    for(int m = 0; m < AA; m++) for(int n = 0; n < AA; n++) {\n            vec2 o = vec2(float(m), float(n)) / float(AA) - 0.5;\n            vec2 p = (-iResolution.xy + 2.0 * (fragCoord + o)) / iResolution.y;\n            vec3 rd = GetRayDir(p, ro, vec3(0, 0., 0), fl); //ray direction\n            vec3 col = bg; // background  \n            //==========================raymatch=============================\n            float td = 0.;\n            vec3 pos = vec3(0.);\n            for(int i = 0; i < nn; i++) {\n                pos = ro + rd * td;\n                float h = map(pos);\n                if(h < eps || td >= dist_infin)\n                    break;\n                td += h;\n            }\n            if(td < dist_infin) {\n                col = resColor;\n                vec3 nor = calcNormal(pos);\n\n                //reflection\n\n                vec3 psk = reflect(rd, nor);\n                vec3 c2 = csky(psk);\n\n                col = calccolor(col, -rd, light, nor);\n                col = mix(col, c2, resReflect);\n\n                //col += c2*0.1;\n\n            }\n            //==========================raymatch=============================\n            tot += col;\n        }\n    tot = tot / float(AA);\n    //tot = pow(tot, vec3(0.7)) / float(AA);\n    //antialiasing\n    fragColor = vec4(tot, 1.0);\n}","name":"Image","description":"","type":"image"}]}