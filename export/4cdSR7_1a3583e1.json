{"ver":"0.1","info":{"id":"4cdSR7","date":"1713806959","viewed":85,"name":"Ray marching SDFs (CSCI 444/544)","username":"tolgacan","description":"For the CSCI 444/544 course. Adapted from Inigo Quilez's Greek Temple: https://www.shadertoy.com/view/ldScDh and https://www.youtube.com/watch?v=-pdSjBPH3zM","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["raymarch","sdf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float f(vec3 p, vec3 sc, float sr)\n{\n    if (p.x > -6.0 && p.x < 6.0)\n      p.x = mod(p.x+2.0,4.0)-2.0;\n    if (p.z<-6.0)\n      p.z = mod(p.z+4.0,8.0)-10.0;\n\n    //sr = 3.0+2.5*sin(p.y*30.0)*0.5*sin(p.x*3.0)*0.5*sin(p.z*3.0);\n    \n    sr = sr-0.09*p.y;\n    sr-=0.1*pow((0.5+0.5*sin(10.0*atan(p.x-sc.x,p.z-sc.z))),2.0);\n    sr+=0.1*pow((0.5+0.5*sin(6.0*p.y-sc.y)),0.2)-0.1;\n\n    float d = length(p.xz - sc.xz) - sr;\n    \n    d = max(d,p.y-3.0);\n    d = max(d,-p.y-3.0);\n\n    return d;\n}\n\n\n// from: https://iquilezles.org/articles/normalsSDF/\nvec3 calcNormal(vec3 p, vec3 sc, float sr) // for function f(p)\n{\n    const float h = 0.0001; // replace by an appropriate value\n    const vec2 k = vec2(1,-1);\n    return normalize( k.xyy*f( p + k.xyy*h, sc, sr ) +\n                      k.yyx*f( p + k.yyx*h, sc, sr ) +\n                      k.yxy*f( p + k.yxy*h, sc, sr ) +\n                      k.xxx*f( p + k.xxx*h, sc, sr ) );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float aspect = iResolution.x/float(iResolution.y);\n    float hwidth = aspect;\n   \n    vec2 p = fragCoord/iResolution.xy;\n   \n    vec3 rayo = vec3 (0,0,0);\n    vec3 rayd = normalize(vec3(-hwidth+(p.x*2.0*hwidth),-1.0+(p.y*2.0),-2.0));\n   \n    vec3 sphereC = vec3(0.0,0.0,-10.0);\n    float sphereR = 1.0;\n   \n    float total_distance_traveled = 0.0;\n    const int NUMBER_OF_STEPS = 64;\n    const float MINIMUM_HIT_DISTANCE = 0.001;\n    const float MAXIMUM_TRACE_DISTANCE = 1000.0;\n\n    vec3 col = vec3(0.6,0.6,1.0);\n    for (int i = 0; i < NUMBER_OF_STEPS; ++i)\n    {\n        vec3 current_position = rayo + total_distance_traveled * rayd;\n        float distance_to_sphere = f(current_position, sphereC, sphereR);\n        if (distance_to_sphere < MINIMUM_HIT_DISTANCE)\n        {\n            vec3 n = calcNormal(current_position, sphereC, sphereR); //normalize(current_position-sphereC);\n            vec3 lightPos = vec3(5.0,10.0,10.0);\n            vec3 l = normalize(lightPos - current_position);\n            col = dot(n,l)*vec3(1.0,0.8,0.2);\n        }\n        if (total_distance_traveled > MAXIMUM_TRACE_DISTANCE)\n        {\n            break;\n        }\n        total_distance_traveled += distance_to_sphere;\n    }\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}