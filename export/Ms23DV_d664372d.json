{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[{"channel":0,"type":"texture","id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}},{"channel":1,"type":"texture","id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"code":"#define VER2\n\n#define FARCLIP 35.0\n#define MARCHSTEPS 90\n#define AOSTEPS    5\n#define SHSTEPS    10\n#define SHPOWER    3.25\n\n#define AMBCOL     vec3(1.0,1.0,1.0)\n#define DIFCOL     vec3(1.0,1.0,1.0)\n#define BACCOL     vec3(1.0,1.0,1.0)\n#define SPECOL     vec3(1.0,1.0,1.0)\n\nvec3 tps;\n/***********************************************/\nfloat hash(float n) { \n\treturn fract(sin(n)*43758.5453123); \n}\n\nfloat noise2(vec2 x) {\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\tfloat n = p.x + p.y*57.0;\n    return mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n               mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y);\n}\n/***********************************************/\nvec3 opU(vec3 a, vec3 b) {\n\treturn mix(a, b, step(b.x, a.x));\n}\n/***********************************************/\nvec3 DE(vec3 p) {\n    vec3 q=p;\n    \n    float anim=iTime;\n    //ballz\n//    float s= noise2(floor(q.xz*0.5)+anim)*0.75 ;\n    float s= floor( noise2(floor(q.xz*0.5)+anim)*0.75 *1000. )/1000.;\n        p.y+=0.0+s*2.0;\n        p.xz=mod(p.xz,2.0)-0.5*2.0;\n    float r=0.5-s*0.5;\n    float d=length(p)-r;\n#ifdef VER2    \n    float bd=length(p)-0.7;\n#endif    \n    vec3 ballz=vec3(length(p)-r, 2.0, s);\n    \n    //floor\n    float ss=noise2(q.xz*1.5*0.1+anim)*0.5;\n    q.y+=0.5+ss;\n#ifndef VER2    \n    q.xz=mod(q.xz,2.0)-0.5*2.0;\n    float bd=length(q)-0.7;\n#endif    \n    vec3 wave=vec3(max(q.y,-bd), 1.0, 0.0);    \n\n\n    tps=wave.x>ballz.x?tps=p:tps=q;\n\n\treturn opU(ballz,wave);\n}\n/***********************************************/\nvec3 normal(vec3 p) {\n\tvec3 e=vec3(0.01,-0.01,0.0);\n\treturn normalize( vec3(\te.xyy*DE(p+e.xyy).x +\te.yyx*DE(p+e.yyx).x +\te.yxy*DE(p+e.yxy).x +\te.xxx*DE(p+e.xxx).x));\n}\n/***********************************************/\nfloat calcAO(vec3 p, vec3 n ){\n\tfloat ao = 0.0;\n\tfloat sca = 1.0;\n\tfor (int i=0; i<AOSTEPS; i++) {\n        \tfloat h = 0.01 + 0.05*float(i);\n        \tfloat dd = DE( n * h + p ).x;\n        \tao += -(dd-h)*sca;\n        \tsca *= 0.75;\n    \t}\n    return clamp( 1.0 - 2.0*ao, 0.0, 1.0 );\n}\n/***********************************************/\nfloat calcSh( vec3 ro, vec3 rd, float s, float e, float k ) {\n\tfloat res = 1.0;\n    for( int i=0; i<SHSTEPS; i++ ) {\n    \tif( s>e ) break;\n        float h = DE( ro + rd*s ).x;\n        res = min( res, k*h/s );\n    \ts += 0.02*SHPOWER;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n/***********************************************/\nvec3 tex3D(vec3 pos, vec3 nor, sampler2D s) {\n\treturn texture( s, pos.yz).xyz*abs(nor.x)+\n\t       texture( s, pos.xz).xyz*abs(nor.y)+\n\t       texture( s, pos.xy).xyz*abs(nor.z);\n}\n/***********************************************/\nvoid rot( inout vec3 p, vec3 r) {\n\tfloat sa=sin(r.y); float sb=sin(r.x); float sc=sin(r.z);\n\tfloat ca=cos(r.y); float cb=cos(r.x); float cc=cos(r.z);\n\tp*=mat3( cb*cc, cc*sa*sb-ca*sc, ca*cc*sb+sa*sc,\tcb*sc, ca*cc+sa*sb*sc, -cc*sa+ca*sb*sc,\t-sb, cb*sa, ca*cb );\n}\n/***********************************************/\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 p = -1.0 + 2.0 * fragCoord.xy / iResolution.xy;\n    p.x *= iResolution.x/iResolution.y;\t\n\tvec3 ta = vec3(0.0, 0.0, 0.0);\n\tvec3 ro =vec3(-2.0, 0.0, -13.0);\n\tvec3 lig=normalize(vec3(-1.0, 2.0, 0.0));\n\t\n\tvec2 mp=iMouse.xy/iResolution.xy;\n\trot(ro,vec3(mp.x,mp.y,0.0));\n\trot(lig,vec3(mp.x,mp.y,0.0));\n\n\tvec3 cf = normalize( ta - ro );\n    vec3 cr = normalize( cross(cf,vec3(0.0,1.0,0.0) ) );\n    vec3 cu = normalize( cross(cr,cf));\n\tvec3 rd = normalize( p.x*cr + p.y*cu + 2.5*cf );\n\n\tvec3 col=vec3(0.0);\n\t/* trace */\n\tvec3 d=vec3(0.0);\t\n\tfloat f=0.0;\n\tvec3 hit;\n\tfor(int i=0; i<MARCHSTEPS; i++) {\n\t\thit=ro+rd*f;\n\t\td=DE(hit);\n\t\tf+=d.x;\n\t\tif( d.x<0.0 || f>FARCLIP ) break;\n\t}\n\td.x=f;\n\t/* draw */\n\tif( f<FARCLIP ) {\n\t\tvec3 nor=normal(hit);\n\n\t\tif (d.y==1.0) col= tex3D(tps*0.1,nor,iChannel0)*0.5;\n\t\tif (d.y==2.0) {\n\t\t    if (d.z<0.05) col=vec3(1.0,0.84,0.77); else col=vec3(0.2,0.5,1.0);\n\t\t    col*=(2.0-d.z*2.)*tex3D(tps*2.0,nor,iChannel1);\n\t\t}\n\t\t\n\t\t\tfloat amb= 2.0;\t\t\n    \t    float dif= clamp(dot(nor, lig), 0.0,1.0);\n        \tfloat bac= clamp(dot(nor,-lig), 0.0,1.0);\n    \t    float spe= pow(clamp( dot( lig, reflect(rd,nor) ), 0.0, 1.0 ) ,16.0 );\n        \tfloat ao= calcAO(hit, nor);\n    \t    float sh= calcSh(hit, lig, 0.01, 2.0, 4.0);\n    \t    \n    \t    col *= 0.5*amb*AMBCOL*ao + 0.4*dif*DIFCOL*sh + 0.1*bac*BACCOL*ao;\n    \t\tcol += 0.5*pow(spe,1.0)*SPECOL*sh;\n    \t\tcol = clamp(col,0.0,1.0);\n    \n    col/=exp(0.08*f); col*=2.2;\t\t\n\t}\n\t\n\t\n\t\n\tfragColor = vec4( col, 1.0 );\n}\n","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"Ms23DV","date":"1393881840","viewed":672,"name":"Whack a Mole","username":"avix","description":"hit em !\nuse mouse to look around.","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["procedural","3d","raymarch","repetition"],"hasliked":0,"parentid":"","parentname":""}}