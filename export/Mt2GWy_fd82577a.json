{"ver":"0.1","info":{"id":"Mt2GWy","date":"1432178077","viewed":126,"name":"distance field test","username":"mrspeaker","description":"raymarch test","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raymarch"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[],"code":"#define max_distance 20.0\n#define epsilon 0.005\n#define max_steps 25\n#define FOV 75.0\n\nfloat sphere(vec3 p, float s){\n  return length(p) - s;\n}\n\nfloat box(vec3 p, vec3 b) {\n  return length(max(abs(p) - b, 0.0));\n}\n\nfloat smin( float a, float b, float k ) {\n    float res = exp(-k * a) + exp(-k * b);\n    return -log(res) / k;\n}\n\nvec3 rep( vec3 p, vec3 c ) {\n  return mod(p, c) - 0.5 * c;\n}\n\nfloat distance(vec3 point) {\n  vec3 p = rep(point, vec3(2,2,4));\n  return smin(\n    smin(sphere(p, 0.5), box(p, vec3(1.0, 0.01, 0.1)), 24.0),\n    box(p, vec3(0.01, 1.0, 0.1)), 24.0);\n}\n\nfloat raymarch(vec3 ray_origin, vec3 ray_direction) {\n  float d = 0.0;\n  \n  for (int i = 0; i < max_steps; i++) {\n    vec3 new_point = ray_origin + ray_direction * d;\n    float s = distance(new_point);\n    if (s < epsilon) return d;\n    d += s;\n    if (d > max_distance) return max_distance;\n  }\n  return max_distance;\n}\n\nvec3 get_normal(vec3 point) {\n  float d0 = distance(point);\n  float dX = distance(point-vec3(epsilon, 0.0, 0.0));\n  float dY = distance(point-vec3(0.0, epsilon, 0.0));\n  float dZ = distance(point-vec3(0.0, 0.0, epsilon));\n    \n  return normalize(vec3(dX - d0, dY - d0, dZ -d0));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = ((2.0 * fragCoord.xy) - iResolution.xy) / min(iResolution.x, iResolution.y);\n  uv *= tan (radians (FOV)/2.0);\n  \n  vec3 eye_pos = vec3(0.0, sin(iTime) * 0.7, 3.0 * mod(iTime / 5.0, 4.0));\n  \n  vec3 up = vec3(0.0, 1.0, 0.0);\n  vec3 forward = vec3(0.0, 0.0, 1.0);\n  vec3 right = cross(up, forward);  \n \n  vec3 ray_dir = normalize(up * uv.y + right * uv.x + forward);\n  float d = raymarch(eye_pos, ray_dir);   \n  \n  if (d < max_distance) {\n    vec3 point = eye_pos + ray_dir * d;\n    vec3 point_normal = get_normal(point);\n    vec3 light = eye_pos + vec3(\n      sin(iTime) * 55.0,\n      cos(iTime) * 44.0,\n      -15.0);\n    vec3 light_dir = -normalize(light - point);\n    float dotp_diffuse = max(0.0, dot(light_dir, point_normal)) * 0.8;\n    float fog = 1.0 / (d / 2.0);\n    fragColor = vec4(1.0, 0.95, 0.85, 1.0) * dotp_diffuse * fog;\n  } else {      \n    fragColor = vec4(0.0);  \n  }\n}","name":"","description":"","type":"image"}]}