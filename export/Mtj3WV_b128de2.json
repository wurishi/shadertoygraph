{"ver":"0.1","info":{"id":"Mtj3WV","date":"1432735467","viewed":163,"name":"1st ray marching","username":"Ultraviolet","description":"First attempt to ray marching.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sf3Rn","filepath":"/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","previewfilepath":"/media/ap/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n\n#define PI 3.1415972\n\nconst float dMin = 0.0;\nconst float dMax = 100.0;\nconst float stp = .1;\n\n\nvec3 lightDir = normalize(vec3(0, -1, -0.3));\n\nvec3 sunColor = vec3(1.0, 1.0, 1.0);\nvec3 airColor = vec3(0.5, 0.8, 1.0);\nvec3 horizonColor = vec3(1.0, 1.0, 0.8);\n\nfloat perlinTexture(in vec2 pos)\n{\n    const float N = 5.0;\n    \n    vec2 pos2 = pos;\n    \n    float ind = 0.0;\n    float ampl = 1.0;\n    \n    for(float n = 0.0; n < N; n ++)\n    {\n    \tind += texture(iChannel0, pos / iChannelResolution[0].x).x * ampl;\n    \n        ampl *= 0.5;\n        pos *= 2.0;\n    }\n    \n    return ind / (1.0 - pow(0.5, N+1.0)) * 0.5;\n}\n\nfloat terrainHeight(vec2 pos)\n{\n    return perlinTexture(pos);\n}\n\nvec3 terrainNormal(vec2 pos)\n{\n    //return vec3(0.0, 0.0, 1.0);\n    \n    float dt = stp;\n    float dx = (terrainHeight(pos + vec2(dt, .0)) - terrainHeight(pos - vec2(dt, .0))) / 2.0 / dt;\n    float dy = (terrainHeight(pos + vec2(.0, dt)) - terrainHeight(pos - vec2(.0, dt))) / 2.0 / dt;\n    \n    vec3 normal = cross(normalize(vec3(1.0, .0, dx)), normalize(vec3(.0, 1.0, dy)));\n    normal = normalize(normal);\n    \n    return normal;\n}\n\nvec3 terrainColor(in vec3 ro, in vec3 rd, in float dist)\n{\n//    vec3 pos = ro + dist * rd;\n//    return vec3(abs(dot(terrainNormal(pos.xy), lightDir)));\n    \n    vec3 pos = ro + dist * rd;\n    vec3 normal = terrainNormal(pos.xy);\n    \n    return vec3(terrainHeight(pos.xy));\n    return vec3(pos.xy, 0.5);\n    return terrainNormal(pos.xy);\n    return vec3(dot(terrainNormal(pos.xy), vec3(0.0, 0.0, 1.0)));\n    \n    vec3 rockColor = vec3(0.5);\n    vec3 grassColor = vec3(0.1, 0.9, 0.1);\n    vec3 snowColor = vec3(1.0);\n    \n    float snowCoeff = exp((pos.z - 1.1) * 15.0); \tsnowCoeff  = clamp(snowCoeff , 0.0, 1.0);\n    float slopeCoeff = 1.0;//exp(-1.0 * (normal.z - 0.5)); \t\tslopeCoeff = clamp(slopeCoeff, 0.0, 1.0);\n    float distCoeff = exp(-60.0 / dist); \t\t\tdistCoeff  = clamp(distCoeff , 0.0, 1.0);\n    float lightCoeff = abs(dot(normal, -lightDir)); lightCoeff = clamp(lightCoeff, 0.0, 1.0);\n    lightCoeff = 0.1 + lightCoeff * 0.9;\n    \n    //return vec3(slopeCoeff);\n    \n    vec3 col = mix(snowColor, grassColor, 1.0 - snowCoeff);\n    col = mix(col, rockColor, 1.0 - slopeCoeff);\n    \n    col *= lightCoeff;\n    \n    col = mix(col, horizonColor, distCoeff);\n        \n    return col;\n}\n\nvec3 skyColor(in vec3 ro, in vec3 rd)\n{\n    float sunFactor = max(-dot(rd, lightDir), 0.0);\n    float horizonFactor = 1.0 - rd.z;\n        \n    float sun = exp((sunFactor - 1.0) * 100.0);\n    float horizon = exp((horizonFactor - 1.0) * 10.0);\n    \n    return mix(mix(sunColor, airColor, 1.0-sun), horizonColor, horizon);\n}\n\n\nvec3 castRay(in vec3 ro, in vec3 rd)\n{\n    \n    //return vec3(terrainHeight(rd.yz * 100.0));    \n    //return (terrainNormal(rd.yz * 100.0) + 1.0)/2.0;\n    \n    float stp_loc = stp;\n    \n    float dd = dMin;\n    \n    for(float d = dMin; d < dMax; d += stp)\n    {\n        vec3 pos = ro + d * rd;\n        if(pos.z <= terrainHeight(pos.xy))\n        {\n            //return vec3(0.0);\n            // return vec3(pos.z);\n            //return vec3(abs(dot(terrainNormal(pos.xy), lightDir)));\n            return terrainColor(ro, rd, d - stp * 0.5);\n        }\n        \n        //dd += stp_loc;\n        //stp_loc += stp / 10.0;\n    }\n    \n    return skyColor(ro, rd);\n}\n\n\nmat3 idMatrix()\n{\n    return mat3(\n        1.0, 0.0, 0.0, \n        0.0, 1.0, 0.0, \n        0.0, 0.0, 1.0);\n}\n\nmat3 crossProdMatrix(in vec3 v)\n{\n    return mat3(\n         0.0, -v.z,  v.y,\n    \t v.z,  0.0, -v.x,\n    \t-v.y,  v.x,  0.0);\n}\n\nmat3 tensProdMatrix(in vec3 v)\n{\n    return mat3(\n        v.x * v.x, v.y * v.x, v.z * v.x,\n    \tv.x * v.y, v.y * v.y, v.z * v.y,\n    \tv.x * v.z, v.y * v.z, v.z * v.z);\n}\n\nmat3 rotationMatrix(vec3 axis, float angle)\n{\n    return idMatrix() * cos(angle) + crossProdMatrix(axis) * sin(angle) + tensProdMatrix(axis) * (1.0 - cos(angle));\n}\n\nmat3 polarTransformation(float longitude, float latitude)\n{\n    vec3 X = vec3(1,0,0);\n    vec3 Y = vec3(0,1,0);\n    vec3 Z = vec3(0,0,1);\n    \n    mat3 m = rotationMatrix(Z, longitude);\n    Y = m * Y;\n    \n    m = rotationMatrix(Y, latitude) * m;\n    X = m * X;\n    Z = m * Z;\n    \n    return mat3(X, Y, Z);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 ro = vec3(0, -5, 10); // ray origin\n    \n    float longitude = iMouse.x / iResolution.x * 2.0 * PI;//0.0;//\n    float latitude = iMouse.y / iResolution.y * PI - 0.5 * PI;\n    \n    mat3 m = polarTransformation(longitude, latitude);\n    \n    vec3 X = m * vec3(1,0,0);\n    vec3 Y = m * vec3(0,1,0);\n    vec3 Z = m * vec3(0,0,1);\n    \n    //ro = -X * 5.0 + vec3(0,0,5.0);\n    \n    float ratio = iResolution.x / iResolution.y;\n    \n    float focal_length = 0.5;  // equivalent of a 5mm focal length for a 1m wide display\n    float angle = asin(focal_length);\n    //float angle = PI * 0.4;\n    \n    float alpha_d = (fragCoord.x / iResolution.x - 0.5) * angle;\n    float beta_d  = (fragCoord.y / iResolution.y - 0.5) * angle / ratio;\n    \n    \n    mat3 m2 = polarTransformation(alpha_d, beta_d);\n    \n    vec3 rd = m * m2 * vec3(1,0,0);\n    \n    vec3 col = castRay(ro, rd);\n    \n\tfragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}