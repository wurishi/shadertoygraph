{"ver":"0.1","info":{"id":"XlsBWB","date":"1513238891","viewed":265,"name":"Rainbow Sandwich II","username":"Ultraviolet","description":"Crossover of [url=https://www.shadertoy.com/view/Mllfzl]Isopleth[/url] and [url=https://www.shadertoy.com/view/ltsBzl]Rainbow Sandwich[/url].\n","likes":16,"published":1,"flags":32,"usePreview":0,"tags":["cube","rainbow","box","absorption"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n#define PI\t\t\t\t3.1415926535\n#define SQRT2\t\t\t0.707\n\n#define ABSORBANCE\t\t1.0\n#define LIGHT_DIR\t\tnormalize(vec3(cos(-iTime*.3+PI*.5), 1.0, sin(-iTime*.3+PI*.5)))\n#define CAM_SPEED\t\t.3\n#define CAM_POS \t\tvec3(4.*cos(-iTime*CAM_SPEED), 4.0, 4.*sin(-iTime*CAM_SPEED))\n\nconst int KEY_LEFT  = 37;\nconst int KEY_UP    = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN  = 40;\nconst int KEY_A     = 65;\nconst int KEY_B     = 66;\nconst int KEY_C     = 67;\nconst int KEY_D     = 68;\nconst int KEY_E     = 69;\nconst int KEY_F     = 70;\nconst int KEY_G     = 71;\nconst int KEY_H     = 72;\nconst int KEY_I     = 73;\nconst int KEY_J     = 74;\nconst int KEY_K     = 75;\nconst int KEY_L     = 76;\nconst int KEY_M     = 77;\nconst int KEY_N     = 78;\nconst int KEY_O     = 79;\nconst int KEY_P     = 80;\nconst int KEY_Q     = 81;\nconst int KEY_R     = 82;\nconst int KEY_S     = 83;\nconst int KEY_T     = 84;\nconst int KEY_U     = 85;\nconst int KEY_V     = 86;\nconst int KEY_W     = 87;\nconst int KEY_X     = 88;\nconst int KEY_Y     = 89;\nconst int KEY_Z     = 90;\nconst int KEY_SPACE = 32;\n\n#define KEY_PRESSED(KEY) !(texelFetch( iChannel1, ivec2(KEY,2), 0 ).x>0.5)\n\n\n// strait from https://iquilezles.org/articles/boxfunctions\n// added a parameter for the far intersection normal computation\nvec2 boxIntersection( vec3 ro, vec3 rd, vec3 boxSize, mat4 txx, out vec3 outNormal, out vec3 outNormal2 )\n{\n    // convert from ray to box space\n    vec3 rdd = (txx*vec4(rd,0.0)).xyz;\n    vec3 roo = (txx*vec4(ro,1.0)).xyz;\n\n    vec3 m = 1.0/rd;\n    vec3 n = m*roo;\n    vec3 k = abs(m)*boxSize;\n\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n\n    if( tN > tF || tF < 0.0) return vec2(-1.0); // no intersection\n\n    outNormal = -sign(rdd)*step(t1.yzx,t1.xyz)*step(t1.zxy,t1.xyz);\n    \n    vec3 d = abs(roo+rdd*tF);\n    outNormal2 = -sign(rdd)*vec3(d.x>d.y&&d.x>d.z?1.:0., d.y>d.x&&d.y>d.z?1.:0., d.z>d.y&&d.z>d.x?1.:0.);\n\n    return vec2( tN, tF );\n}\n\n\nfloat getVal(in vec3 p)\n{\n    vec4 val0 = texture(iChannel0, p.xz*.5+vec2(.5));\n    p.y *= .5;\n    \n    //return p.y;\n    //return length(p*vec3(1.,2.,1.)-vec3(1., 1., -1.));\n    //return min(min(length(p*vec3(1.,2.,1.)-vec3(1., 1., -1.)), length(p*vec3(1.,2.,1.)-vec3(1., 0., 1.))),length(p*vec3(1.,2.,1.)-vec3(-1., 1., 0.)));\n    \n    //return mix(val0.x, val0.z, p.y);\n    \n    \n    //float t = mod(3.*p.y, 1.);\n    //t = smoothstep(0., 1., t);\n    \n    if(p.y<1./3.)\n        //return mix(val0.x, val0.y, p.y*3.);\n        return mix(val0.x, val0.y, smoothstep(0., 0.333, p.y));\n    \n    if(p.y<2./3.)\n        //return mix(val0.y, val0.z, (p.y-1./3.)*3.);\n        return mix(val0.y, val0.z, smoothstep(0.333, 0.666, p.y));\n    \n    //return mix(val0.z, val0.w, (p.y-2./3.)*3.);\n    return mix(val0.z, val0.w, smoothstep(0.666, 1., p.y));\n}\n\n\nvec3 getNorm(in vec3 p)\n{\n    vec2 d = vec2(0.01, 0.);\n    \n    return vec3(getVal(p+d.xyy)-getVal(p), getVal(p+d.yxy)-getVal(p), getVal(p+d.yyx)-getVal(p));\n}\n\n\nvec3 render(in vec3 ro, in vec3 rd)\n{\n    \n    float t = (-0.-ro.y)/rd.y;\n    \n    //t = 100.0;\n    \n    \n    if(t<0. || rd.y >0.)\n    \tt = 10000.;\n    \n    vec3 col = mix(vec3(0.9), vec3(0.5,0.6,0.9), 1.-exp(-0.05*t));\n    \n    vec3 n, n2;    \n    \n    vec3 size = vec3(1.);\n    mat4 txx = mat4(1., 0., 0., 0., 0., 1., 0., 0., 0., 0., 1., 0., 0. , -1., 0., 1.);\n    \n    \n    float iso_[6] = float[](0.083, 0.25, 0.416, 0.583, 0.75, 0.916);\n    vec3  color[6]     = vec3[](\n        vec3(1., 0., 0.),\n        vec3(SQRT2, SQRT2, 0.), \n        vec3(0., 1., 0.), \n        vec3(0., SQRT2, SQRT2), \n        vec3(0., 0., 1.), \n        vec3(SQRT2, 0., SQRT2));\n    \n    \n    \n    //*\n    if(t < 100.)\n    {\n    \tvec3 roo = ro+rd*t;\n    \tvec3 rdd = LIGHT_DIR;\n        vec3 lightCol = vec3(1.);\n        \n        \n        vec2 tnf = boxIntersection(roo, rdd, size, txx, n, n2);\n\n        float t_min = max(0., tnf.x), t_max = tnf.y;\n        float depth = max(0., t_max-t_min);\n        float dt = 0.01;\n        if(depth > 0.)\n        {\n            for(float t = t_max; t>t_min; t -= dt)\n            {\n                vec3 p = roo + rdd*t;\n                float val = getVal(p);\n                int k = int(val*6.)%6;\n                vec3 cur_col = color[k];\n                lightCol = mix(lightCol, vec3(0.), 1.-exp(-dt*ABSORBANCE*cur_col));\n            }\n        }\n        \n    \tcol *= lightCol;\n    }\n\t//*/\n    \n    \n    \n    \n    vec2 tnf = boxIntersection(ro, rd, size, txx, n, n2);\n    \n    float t_min = max(0., tnf.x), t_max = min(t, tnf.y);\n    float depth = max(0., t_max-t_min);\n    float dt = 0.01;\n    if(depth > 0.)\n    {\n        for(float t = t_max; t>t_min; t -= dt)\n        {\n            vec3 p = ro + rd*t;\n            float val = getVal(p);\n            int k = int(val*6.)%6;\n            vec3 cur_col = color[k];\n            col = mix(col, cur_col, 1.-exp(-dt*ABSORBANCE));\n            //col = mix(col, col*cur_col, 1.-exp(-dt*ABSORBANCE));\n            //col = mix(col, vec3(0.), 1.-exp(-dt*ABSORBANCE*cur_col));\n        }\n    }\n    \n    \n    return col;\n}\n\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (-iResolution.xy + 2.0*fragCoord.xy)/ iResolution.y;\n        \n    float phi = (iMouse.x-0.5)/iResolution.x * PI * 2.0;\n    float psi = -((iMouse.y-0.5)/iResolution.y-0.5) * PI;\n    \n    \n    vec3 ro = 5.0*vec3(cos(phi)*cos(psi), sin(psi), sin(phi)*cos(psi));\n    if(iMouse.z < 0.5)\n        ro = CAM_POS;\n    vec3 ta = vec3(0., .5, .0);\n    mat3 m = setCamera(ro, ta, 0.0);\n\t\n    float zoom = 2.;\n    //zoom = iMouse.y/iResolution.y * 5.;\n    vec3 rd = m*normalize(vec3(p, zoom));\n    \n    // scene rendering\n    vec3 col = render( ro, rd);\n    \n    // gamma correction\n    col = sqrt(col);\n\n    fragColor = vec4(col, 1.0);\n    \n    //fragColor = texture(iChannel0, fragCoord.xy/iResolution.xy);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\n\n\n// Cloud parameters\n\nconst mat3 m = mat3( 0.00,  0.80,  0.60,\n                    -0.80,  0.36, -0.48,\n                    -0.60, -0.48,  0.64 );\n\nfloat hash(vec3 p)\n{\n    p  = fract( p*0.3183099+.1 );\n\tp *= 17.0;\n    return fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\n}\n\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    return mix(mix(mix( hash(p+vec3(0,0,0)), \n                        hash(p+vec3(1,0,0)),f.x),\n                   mix( hash(p+vec3(0,1,0)), \n                        hash(p+vec3(1,1,0)),f.x),f.y),\n               mix(mix( hash(p+vec3(0,0,1)), \n                        hash(p+vec3(1,0,1)),f.x),\n                   mix( hash(p+vec3(0,1,1)), \n                        hash(p+vec3(1,1,1)),f.x),f.y),f.z);\n}\n\nfloat noiseMulti( in vec3 pos)\n{\n    vec3 q = pos;\n    float f  = 0.5000*noise( q ); q = m*q*2.01;\n    f += 0.2500*noise( q ); q = m*q*2.02;\n    f += 0.1250*noise( q ); q = m*q*2.03;\n    f += 0.0625*noise( q ); q = m*q*2.01;\n\n    float w = 0.5000+0.25+0.125+0.0625;\n    return f/w;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy*4.;\n    float speed = 0.5;\n    fragColor = vec4(noise(vec3(uv, iTime*speed)), \n                     noise(vec3(uv + vec2(100.0), iTime*speed)), \n                     noise(vec3(uv + vec2(200.0), iTime*speed)), \n                     noise(vec3(uv + vec2(300.0), iTime*speed)));\n    \n    /*\n    fragColor = vec4(noiseMulti(vec3(uv, iTime*speed)), \n                     noiseMulti(vec3(uv + vec2(100.0), iTime*speed)), \n                     noiseMulti(vec3(uv + vec2(200.0), iTime*speed)), \n                     noiseMulti(vec3(uv + vec2(300.0), iTime*speed)));\n\t//*/\n}","name":"Buf A","description":"","type":"buffer"}]}