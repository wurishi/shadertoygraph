{"ver":"0.1","info":{"id":"MXffW8","date":"1728853712","viewed":37,"name":"Perlin Noise 2D 0934","username":"Ponjee","description":"Basic Perlin Noise shader","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["2d","noise","perlin"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float PI = 3.141592653589793238462643383279502884197169399375105820974944592307816406286208998628034825342117067982148086513282306647093844609550582231725359408128481;\n\n//float exp_sin_lerp(float a, float b, float t, float s) {\n//    //float v1 = 0.0 + (0.5 - 0.0) * (1.0 - pow(1.0 - 2.0 * t, s));\n//    //float v2 = 0.5 + (1.0 - 0.5) * pow(2.0 * s - 1.0, s);\n//    float v1 = 0.0 + (0.5 - 0.0) * pow(2.0 * t, s);\n//    float v2 = 0.5 + (1.0 - 0.5) * (1.0 - pow(2.0 - 2.0 * t, s));\n//    return a + (b - a) * ( t < 0.5 ?  v1 : v2);\n//}\n\nfloat sin_lerp(float a, float b, float t) {\n    float v = sin(mix(-PI/2.0, PI/2.0, t)) * 0.5 + 0.5;\n    return mix(a,b,v);\n}\n\nfloat get_perlin_2d(vec2 p) {\n    vec2 curr_pos = p;\n    vec4 curr_col = texelFetch(iChannel0, ivec2(round(curr_pos)), 0);\n    \n    float xmin = floor(curr_pos.x);\n    float xmax = xmin+1.0;\n    float ymin = floor(curr_pos.y);\n    float ymax = ymin+1.0;\n    \n    vec4 cc1 = texelFetch(iChannel0, ivec2(xmin, ymin), 0);\n    vec4 cc2 = texelFetch(iChannel0, ivec2(xmax, ymin), 0);\n    vec4 cc3 = texelFetch(iChannel0, ivec2(xmin, ymax), 0);\n    vec4 cc4 = texelFetch(iChannel0, ivec2(xmax, ymax), 0);\n    \n    vec2 g1 = cc1.rg*2.0-1.0;\n    vec2 d1 = curr_pos - vec2(xmin, ymin);\n    vec2 g2 = cc2.rg*2.0-1.0;\n    vec2 d2 = curr_pos - vec2(xmax, ymin);\n    vec2 g3 = cc3.rg*2.0-1.0;\n    vec2 d3 = curr_pos - vec2(xmin, ymax);\n    vec2 g4 = cc4.rg*2.0-1.0;\n    vec2 d4 = curr_pos - vec2(xmax, ymax);\n    \n    float dp1 = dot(d1,g1);\n    float dp2 = dot(d2,g2);\n    float dp3 = dot(d3,g3);\n    float dp4 = dot(d4,g4);\n    \n    float s = 2.0;\n    \n    float lx1 = sin_lerp(dp1, dp2, curr_pos.x-xmin);\n    float lx2 = sin_lerp(dp3, dp4, curr_pos.x-xmin);\n    \n    float d = sin_lerp(lx1, lx2, curr_pos.y-ymin);\n    \n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.x;\n    uv /= 0.03;\n    \n    float l = 1.0;\n    \n    float value = get_perlin_2d(uv)*0.5+0.5;\n    fragColor = vec4(mod(value, l) * (1.0/l));\n}","name":"Image","description":"","type":"image"}]}