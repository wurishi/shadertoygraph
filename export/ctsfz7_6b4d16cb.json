{"ver":"0.1","info":{"id":"ctsfz7","date":"1693126407","viewed":40,"name":"e logo","username":"Aman","description":"eleutherai","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["logo","ml"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14159\n\n// Bezier polyline from https://www.shadertoy.com/view/ftdGDB\n// by Thomas Stehle\n\nconst int CAPACITY = 6; // Control polygon capacity\nconst float INF   = 1000000.0;\nconst float SQRT3 = 1.732050807568877;\n\n// Cross-product of two 2D vectors\nfloat cross2(in vec2 a, in vec2 b) {\n    return a.x*b.y - a.y*b.x;\n}\n\n// Clamp a value to [0, 1]\nfloat saturate(in float a) {\n    return clamp(a, 0.0, 1.0);\n}\nvec3 saturate(in vec3 a) {\n    return clamp(a, 0.0, 1.0);\n}\n\n// Minimum of the absolute of two values\nfloat abs_min(float a, float b) {\n    return abs(a) < abs(b) ? a : b;\n}\n\n// SDF for a line segment\nfloat sdf_line(in vec2 p, in vec2 a, in vec2 b) {\n    float h = saturate(dot(p - a, b - a) /\n                       dot(b - a, b - a));\n    return length(p - a - h * (b - a));\n}\n\n// Like the SDF for a line but partitioning space into positive and negative\nfloat sdf_line_partition(in vec2 p, in vec2 a, in vec2 b) {\n    vec2 ba = b - a;\n    vec2 pa = p - a;\n    float h = saturate(dot(pa, ba) / dot(ba, ba));\n    vec2 k = pa - h * ba;\n    vec2 n = vec2(ba.y, -ba.x);\n    return (dot(k,n) >= 0.0) ? length(k) : -length(k);\n}\n\n// Signed distance to a quadratic BÃ©zier curve\n// Mostly identical to https://www.shadertoy.com/view/MlKcDD\n// with some additions to combat degenerate cases.\nfloat sdf_bezier(in vec2 pos, in vec2 A, in vec2 B, in vec2 C) {\n    const float EPSILON = 1e-3;\n    const float ONE_THIRD = 1.0 / 3.0;\n\n    // Handle cases where points coincide\n    bool abEqual = all(equal(A, B));\n    bool bcEqual = all(equal(B, C));\n    bool acEqual = all(equal(A, C));\n    \n    if (abEqual && bcEqual) {\n        return distance(pos, A);\n    } else if (abEqual || acEqual) {\n        return sdf_line_partition(pos, B, C);\n    } else if (bcEqual) {\n        return sdf_line_partition(pos, A, C);\n    }\n    \n    // Handle colinear points\n    if (abs(dot(normalize(B - A), normalize(C - B)) - 1.0) < EPSILON) {\n        return sdf_line_partition(pos, A, C);\n    }\n    \n    vec2 a = B - A;\n    vec2 b = A - 2.0*B + C;\n    vec2 c = a * 2.0;\n    vec2 d = A - pos;\n\n    float kk = 1.0 / dot(b,b);\n    float kx = kk * dot(a,b);\n    float ky = kk * (2.0*dot(a,a)+dot(d,b)) * ONE_THIRD;\n    float kz = kk * dot(d,a);\n\n    float res = 0.0;\n    float sgn = 0.0;\n\n    float p = ky - kx*kx;\n    float p3 = p*p*p;\n    float q = kx*(2.0*kx*kx - 3.0*ky) + kz;\n    float h = q*q + 4.0*p3;\n\n    if (h >= 0.0) {\n        // One root\n        h = sqrt(h);\n        vec2 x = 0.5 * (vec2(h, -h) - q);\n        vec2 uv = sign(x) * pow(abs(x), vec2(ONE_THIRD));\n        float t = saturate(uv.x + uv.y - kx) + EPSILON;\n        vec2 q = d + (c + b*t) * t;\n        res = dot(q, q);\n        sgn = cross2(c + 2.0*b*t, q);\n    } else {\n        // Three roots\n        float z = sqrt(-p);\n        float v = acos(q/(p*z*2.0)) * ONE_THIRD;\n        float m = cos(v);\n        float n = sin(v) * SQRT3;\n        vec3 t = saturate(vec3(m+m,-n-m,n-m)*z-kx) + EPSILON;\n        vec2 qx = d + (c+b*t.x)*t.x;\n        float dx = dot(qx, qx);\n        float sx = cross2(c+2.0*b*t.x, qx);\n        vec2 qy = d + (c+b*t.y)*t.y;\n        float dy = dot(qy, qy);\n        float sy = cross2(c+2.0*b*t.y, qy);\n        res = (dx < dy) ? dx : dy;\n        sgn = (dx < dy) ? sx : sy;\n    }\n    \n    return sign(sgn) * sqrt(res);\n}\n\n// Signed distance to a segment of a control polygon\nfloat sdf_control_segment(in vec2 p, in vec2 A, in vec2 B, in vec2 C) {\n    return abs_min(sdf_line(p, A, B), sdf_line(p, B, C));\n}\n\n// Signed distance to a control polygon\n// Identifies and returns distance to the closest segment.\nfloat sdf_control_polygon(in vec2 p, in vec2 controlPoly[CAPACITY], in int controlPolySize, out vec2 closest[3]) {\n    // Cycle through segments and track the closest\n    float d = INF;\n    float ds = 0.0;\n\n    // First n-2 segments\n    vec2 c = 0.5 * (controlPoly[0] + controlPoly[1]);\n    vec2 prev = c;\n    for (int i = 1; i < controlPolySize - 1; ++i) {\n        prev = c;\n        c = 0.5 * (controlPoly[i] + controlPoly[i+1]);\n        ds = sdf_control_segment(p, prev, controlPoly[i], c);\n        if (abs(ds) < abs(d)) {\n            closest[0] = prev;\n            closest[1] = controlPoly[i];\n            closest[2] = c;\n            d = ds;\n        }\n    }\n\n    // Last-but-one segment\n    prev = c;\n    c = 0.5 * (controlPoly[controlPolySize-1] + controlPoly[0]);\n    ds = sdf_control_segment(p, prev, controlPoly[controlPolySize-1], c);\n    if (abs(ds) < abs(d)) {\n        closest[0] = prev;\n        closest[1] = controlPoly[controlPolySize-1];\n        closest[2] = c;\n        d = ds;\n    }\n\n    // Last segment\n    prev = c;\n    c = 0.5 * (controlPoly[0] + controlPoly[1]);\n    ds = sdf_control_segment(p, prev, controlPoly[0], c);\n    if (abs(ds) < abs(d)) {\n        closest[0] = prev;\n        closest[1] = controlPoly[0];\n        closest[2] = c;\n        d = ds;\n    }\n    \n    // Return distance\n    return d;\n}\n\n// Signed distance to a quadratic Bezier shape made from a given control polygon\nfloat sdf_bezier_shape(in vec2 p, in vec2 controlPoly[CAPACITY], in int controlPolySize) {\n    // Determine closest segment in control polygon\n    vec2 closest[3];\n    sdf_control_polygon(p, controlPoly, controlPolySize, closest);\n\n    // Refine by determining actual distance to curve of closest segment\n    return sdf_bezier(p, closest[0], closest[1], closest[2]);\n}\n\n\nfloat opExtrusion( in vec3 p, float d, in float h )\n{\n    vec2 w = vec2( d, abs(p.z) - h );\n    return min(max(w.x,w.y),0.0) + length(max(w,0.0));\n}\n\nmat2 rot2d(in float angle) {\n    return mat2(cos(angle), sin(angle),\n               -sin(angle), cos(angle));\n}\n\n\nfloat sdf(vec3 p, in vec2 controlPoints[CAPACITY]) {\n    p.y *= -1.0;\n    float t = iTime * 0.2;\n    t = mod(t, 1.2);\n    t = clamp(t, 0.0, 1.0);\n        \n    t = t * 2.0 * 3.14159;\n    float t2 = (iTime * 0.2 + 10.0) * 0.2;\n    t2 = clamp(sin(t) * 2.0, 0.0, 0.5) * 2.0 * 3.14159;\n    float t3 = (iTime * 0.2 + 20.0) * 0.2;\n    t3 = clamp(sin(t) * 2.0, 0.0, 0.5) * 2.0 * 3.14159;\n    vec2 pOuter = p.xy;\n    //pOuter = rot2d(t) * pOuter;\n    vec3 xOuter = p;\n    vec3 xInner = p;\n    vec3 xInner2 = p;\n    xOuter.xz = rot2d(t) * xOuter.xz;\n    xInner.xy = rot2d(t2) * xInner.xy;\n    float dOuter = opExtrusion(xOuter, sdf_bezier_shape(pOuter, controlPoints, 6), 0.1);\n    dOuter = max(dOuter, -(length(p.xy) - 0.89));\n    vec2 pInner = p.xy * vec2(1.0, -1.0);\n    pInner = rot2d(t2) * pInner;\n    float dInner = opExtrusion(xInner, sdf_bezier_shape(pInner * 1.3, controlPoints, 6) / 1.3, 0.1);\n    dInner = max(dInner, -(length(pInner * 1.3) - 0.89) / 1.3);\n    vec2 pInner2 = pInner * vec2(1.0, -1.0);\n    pInner2 = rot2d(t3) * pInner2;\n    float dInnermost = opExtrusion(p, sdf_bezier_shape(pInner2 * 1.3 * 1.3, controlPoints, 6) / (1.3 * 1.3), 0.1);\n    return min(min(dOuter, dInner), dInnermost);\n}\n\n\nbool march(vec3 ro, vec3 rd, out vec3 outPos, in vec2 controlPoly[CAPACITY]) {\n    float tot = 0.0;\n    for(int i = 0; i < 60; i++) {\n       float d = sdf(ro, controlPoly);\n       ro += d * rd;\n       tot += d;\n       if(d < (0.001 * tot)) {\n           outPos = ro;\n           return true;\n       }\n    }\n    outPos = ro;\n    return false;\n}\n\nvec3 estimateNormal(vec3 x, in vec2 controlPoly[CAPACITY]) {\n    vec2 k = vec2(1.0, -1.0);\n    float h = 0.00001;\n    return normalize(k.xyy * sdf(x + h * k.xyy, controlPoly)\n                    +k.yyx * sdf(x + h * k.yyx, controlPoly)\n                    +k.yxy * sdf(x + h * k.yxy, controlPoly)\n                    +k.xxx * sdf(x + h * k.xxx, controlPoly));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    // Time varying pixel color\n    \n    const float equiAngle = 3.14159 / 3.0;\n    const mat2 halfTriRot = mat2(cos(equiAngle), sin(equiAngle),\n                                -sin(equiAngle), cos(equiAngle));\n    const mat2 triRot = halfTriRot * halfTriRot;\n    const float off = 0.3;\n    // Control polygon\n    const int SIZE = 6;\n    vec2 controlPoints[CAPACITY];\n    controlPoints[0] = vec2(0.0, 1.0);\n    controlPoints[1] = halfTriRot * vec2(0.0, 1.0 + off);\n    controlPoints[2] = triRot * vec2(0.0, 1.0);\n    controlPoints[3] = triRot * halfTriRot * vec2(0.0, 1.0 + off);\n    controlPoints[4] = triRot * triRot * vec2(0.0, 1.0);\n    controlPoints[5] = triRot * triRot * halfTriRot * vec2(0.0, 1.0 + off);\n\n\n    vec3 ro = vec3(0.0, 0.0, -2.0);\n    vec3 rd = normalize(vec3(uv, 1.0));\n    vec3 hitPos;\n    \n    vec3 col = vec3(0.0);\n    \n    if (march(ro, rd, hitPos, controlPoints)) {\n        col = vec3(1.0);\n        vec3 lightPos = vec3(1.0, 1.0, -1.0);\n        vec3 normal = estimateNormal(hitPos, controlPoints);\n        float d = sdf(hitPos, controlPoints);\n        vec3 lcol = d > 0.0 ? vec3(1.0, 0.0, 0.0) : vec3(0.0, 0.0, 1.0);\n        col = vec3(1.0) * (0.4 * dot(normal, lightPos) + 0.5);\n    } \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}