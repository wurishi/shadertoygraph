{"ver":"0.1","info":{"id":"Dd3fRB","date":"1697294737","viewed":62,"name":"imgabor","username":"altunenes","description":"I know it looks creepy :D \na more simple version of this (inspiration): :) \n\nhttps://www.shadertoy.com/view/DdcBRS by @shadertoyjiang, 2023\n\ndrag the mouse for orientation :) ","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["gabor"],"hasliked":0,"parentid":"cs3BWM","parentname":"gabor patch"},"renderpass":[{"inputs":[{"id":"4df3zn","filepath":"/media/a/3405e48f74815c7baa49133bdc835142948381fbe003ad2f12f5087715731153.ogv","previewfilepath":"/media/ap/3405e48f74815c7baa49133bdc835142948381fbe003ad2f12f5087715731153.ogv","type":"video","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float PI = 3.1415926535897932384626433832795;\nfloat lambda = 0.01;  // wavelength\nfloat psi = 0.01;     // phase offset\nfloat sigma = 0.01;   // standard deviation of Gaussian\nfloat gamma = 0.01;   // spatial aspect ratio\n\nvec3 applyGabor(vec2 uv, float theta)\n{\n    float xp = uv.x * cos(theta) - uv.y * sin(theta);\n    float yp = uv.x * sin(theta) + uv.y * cos(theta);\n\n    float envelope = exp(-((xp*xp) + (gamma*gamma * yp*yp)) / (2.0 * sigma * sigma));\n    float carrier = cos(2.0 * PI * xp / lambda + psi);\n    \n    float gabor = envelope * carrier;\n    return vec3(gabor);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    float filterSize = 12.0; //increase size if you trust your gpu\n    float stepSize = 1.0;    //decrease this if you trust your gpu \n    \n    vec3 filteredColor = vec3(0.0);\n    \n\nfor(int i = 0; i < 8; ++i)\n{\n    float theta = PI/1.0 + float(i) * PI/1.0; //orientation\n    //float theta = float(i) * PI / 1.0; first version. this is important for patches\n\n\n    vec3 accum = vec3(0.0);\n    \n    for(float x = -filterSize; x <= filterSize; x += stepSize)\n    {\n        for(float y = -filterSize; y <= filterSize; y += stepSize)\n        {\n            vec2 offset = vec2(x, y) / iResolution.xy;\n            vec3 gaborColor = applyGabor(offset, theta);\n            vec3 imageColor = texture(iChannel0, uv + offset).rgb;\n            accum = max(accum, gaborColor * imageColor);\n        }\n    }\n    filteredColor = max(filteredColor, accum);\n}\n    \n    fragColor = vec4(filteredColor, 1.0);\n}\n\n\n/*-------------FIRST VERSION (MORE PLAIN WAY TO APPLY GABOR)-----------\n\n\nconst float PI = 3.1415926535897932384626433832795;\n\n// Gabor Function Parameters\nfloat lambda = 0.015;  // wavelength\nfloat theta;  // orientation (with mouse ;=) )\nfloat psi = 0.2;     // phase offset\nfloat sigma = 0.5;   // standard deviation of Gaussian\nfloat gamma = 1.0;   // spatial aspect ratio\nvec3 applyGabor(vec2 uv)\n{\n    float xp = uv.x * cos(theta) - uv.y * sin(theta);\n    float yp = uv.x * sin(theta) + uv.y * cos(theta);\n    float psi = mod(iTime, 2.0 * PI);  // Phase offset pulsates between 0 and 2PI\n\n    float envelope = exp(-((xp*xp) + (gamma*gamma * yp*yp)) / (2.0 * sigma * sigma));\n    float carrier = cos(2.0 * PI * xp / lambda + psi);\n    \n    float gabor = envelope * carrier;\n    vec3 colorModulation = vec3(0.5) + vec3(0.1) * cos(1.5 * PI * xp / lambda + vec3(0, 2, 4));  \n    \n    return vec3(gabor);\n    //or use custom colors: (uncomment)\n    //return vec3(gabor)*colorModulation;\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    theta = iMouse.x / iResolution.x * PI;\n    \n    // filter size and step size for convolution\n    float filterSize = 8.0;\n    float stepSize = 1.0; \n    \n    vec3 filteredColor = vec3(0.0);\n    for(float x = -filterSize; x <= filterSize; x += stepSize)\n    {\n        for(float y = -filterSize; y <= filterSize; y += stepSize)\n        {\n            vec2 offset = vec2(x, y) / iResolution.xy;\n            vec3 gaborColor = applyGabor(offset);\n            vec3 imageColor = texture(iChannel0, uv + offset).rgb;\n            filteredColor += gaborColor * imageColor;\n        }\n    }\n    \n    fragColor = vec4(filteredColor, 1.0);\n}\n\n*/","name":"Image","description":"","type":"image"}]}