{"ver":"0.1","info":{"id":"tscBWB","date":"1605978091","viewed":171,"name":"Twig Distance","username":"nr4","description":"My try at a distance function to tree-ish objects. Has some discontinuities because neighbours with different depth are not handled correctly. But I'm not sure whether that is even possible to do correctly without paying an immense computational price.","likes":12,"published":1,"flags":0,"usePreview":0,"tags":["2d","fractal","sdf","tree","distance","twig"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/** Twig Distance\n    Copyright (C) 2020  Alexander Kraus <nr4@z10.info>\n\n    This program is free software: you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with this program.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\nconst float pi = 3.14159;\nconst vec3 c = vec3(1.,0.,-1.);\n\nvoid dlinesegment(in vec2 x, in vec2 p1, in vec2 p2, out float d)\n{\n    vec2 da = p2-p1;\n    d = length(x-mix(p1, p2, clamp(dot(x-p1, da)/dot(da,da),0.,1.)));\n}\n\nvoid dtwig(in vec2 x, in vec2 p1, in vec2 p2, out float d)\n{\n    float N = 3.;\n    \n    // Root branch\n    dlinesegment(x, p1, p2, d);\n    \n    // \"Recursion\"\n    for(float j=0.; j<5.; j+=1.)\n    {\n        float l = length(p2-p1),\n        du = .05*l, // Upper and lower offset in y axis\n        w0 = .34*l, // Width of the lower side twig\n        w1 = .01*l, // Width of the upper side twig\n        dy = .15*l; // y difference of the side twigs\n    \n    \t// Determine basis and Gram matrix.\n        vec2 dp = p2-p1,\n            b1 = normalize(dp),\n            b2 = b1.yx*c.xz;\n        mat2 G = mat2(b1.yx, b2.yx);\n\t\t\n        //Set up Householder matrix\n        mat2 H = mat2(1.) - 2.*outerProduct(b2, b2);\n\t\t\t\n        // Mirror coordinates if necessary to reduce dlinesegment calls\n        if(dot(x-p1,b2) < 0.) x = H * (x-p1)+p1;\n        \n        // Set up inner modulo to avoid recursion branching problems\n        vec2 a = G * (x-p1);\n        \n        float dyy = .5*mix(0.,dy, a.x/w0),\n            en = (l-2.*du)/N;\n        \n        float da = mod(a.y-dyy-du+.5*(l-2.*du+dyy)/N, (l-2.*du+dyy)/N)+dyy+du-.5*(l-2.*du+dyy)/N,\n            i = ((a.y-da)*N/(l-2.*du+dyy));\n        i = min(max(i,0.),N-1.);\n\n        // Actual branch distance\n        dlinesegment(x, p1 + du*b1 + i*en*b1, p1 + (du+dy)*b1 + mix(w0,w1, i/N)*b2 + i*en*b1, da);\n        d = min(d,da);\n            \n        // Mix branches for accurate distance function\n        float ip1 = min(max(i+1.,0.),2.),\n            im1 = min(max(i-1.,0.),2.);\n        \n        dlinesegment(x, p1 + du*b1 + ip1*en*b1, p1 + (du+dy)*b1 + mix(w0,w1, ip1/N)*b2 + ip1*en*b1, da);\n        d = min(d,da);\n            \n        dlinesegment(x, p1 + du*b1 + im1*en*b1, p1 + (du+dy)*b1 + mix(w0,w1, im1/N)*b2 + im1*en*b1, da);\n        d = min(d,da);\n        \n        // Transform the points p1,p2 down one depth level\n        vec2 p1p = p1 + du*b1 + i*en*b1,\n        \tp2p = p1 + (du+dy)*b1 + mix(w0,w1, i/N)*b2 + i*en*b1;\n        \n        p1 = p1p;\n        p2 = p2p;\n    }\n}\n\nfloat sm(in float d)\n{\n    return smoothstep(1.5/iResolution.y, -1.5/iResolution.y, d);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // As always, ignore the drawing code. :)\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    float d;\n    dtwig(uv, \n          -mix(.1,.5,.5+.5*sin(2.*iTime))*vec2(cos(iTime), sin(iTime)), \n          mix(.1,.5,.5+.5*sin(2.*iTime))*vec2(cos(iTime), sin(iTime)), \n          d);\n    \n    d = abs(d)-.00125;\n    float interval = clamp(.03 * (d-mod(d,.025))/.025, 0., 1.);\n    vec3 col = mix(vec3(1.00,0.90,0.68), vec3(0.98,0.64,0.67), 2.*interval);\n    if(interval > .5) col = mix(col, vec3(0.54,0.80,0.80), 2.*(interval-.5));\n    col = mix(col, c.yyy, sm(d));\n    \n    col = mix(col, .4*c.xxx, sm(abs(mod(d+.0125,.025)-.0125)-.001));\n\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}