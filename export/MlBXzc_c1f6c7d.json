{"ver":"0.1","info":{"id":"MlBXzc","date":"1445398881","viewed":263,"name":"[CIS565 2015F] Basic RayMarching","username":"queenkong","description":"Acknowledgement:\nhttps://www.shadertoy.com/view/Xds3zN\nhttps://iquilezles.org/articles/terrainmarching/terrainmarching.htm\nhttp://graphics.cs.williams.edu/courses/cs371/f14/reading/implicit.pdf","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[],"code":"// 0 = None, 1 = Position, 2 = Normals, 3 = Steps\n#define DEBUG 3\n#define SPHERE_TRACE 1\n\n/*****************Distance estimators from iq***************/\n//https://www.shadertoy.com/view/Xds3zN\n\nfloat sdTerrain( vec3 p )\n{\n    //https://iquilezles.org/articles/terrainmarching\n\treturn p.y - 0.5 * sin(p.x) * sin(p.z);\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sdCylinder( vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdCone( in vec3 p, in vec3 c )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    float d1 = -q.y-c.z;\n    float d2 = max( dot(q,c.xy), q.y);\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  return length( vec2(length(p.xz)-t.x,p.y) )-t.y;\n}\n\nfloat unionDistance(float d1, float d2) {\n\treturn min(d1, d2);\n}\n\n//construct scene and estimate distance\nvec2 estimateDistance(in vec3 point) {\n    \n    float d1 = sdSphere(point + vec3(-0.5, -0.6, 0), 0.15);\n    float d2 = sdBox(point, vec3(0.2, 0.2, 0.2));\n    float d3 = sdCone(point + vec3(1.2, -0.2, -0.1),\n                     vec3 (0.7, 0.3, 0.7));\n    float d4 = sdTerrain(point + vec3(0, 0.5, 0));\n    float d5 = sdCylinder(point + vec3(-1.0, 0.1, 0.5),\n                         vec2(0.2, 0.8));\n    \n    float nearest = unionDistance(d5, \n                                  unionDistance(unionDistance(d3,d4),\n                                  unionDistance(d1,d2)));\n    float col = 0.0;\n    \n    if (nearest == d1) {\n        col = 1.0;\n    } else if(nearest == d2) {\n        col = 2.0;\n    } else if(nearest == d3){\n        col = 3.0;\n    } else if(nearest == d4){\n        col = 4.0;\n    } else {\n        col = 3.0;\n    }\n    return vec2(nearest, col);\n}\n\n//http://graphics.cs.williams.edu/courses/cs371/f14/reading/implicit.pdf\n//McGuire 11.5\nvec3 transform(in vec3 point, in vec3 trans, in vec3 rot_axis,\n               in float rot_angle, in vec3 scale) {\n    \n\tmat4 trans_mat = mat4(1.0, 0.0, 0.0, 0.0,\n                          0.0, 1.0, 0.0, 0.0,\n                          0.0, 0.0, 1.0, 0.0,\n                          -trans.x, -trans.y, -trans.z, 1.0);\n\n    mat4 scale_mat = mat4(1.0/scale.x, 0.0, 0.0, 0.0,\n                          0.0, 1.0/scale.y, 0.0, 0.0,\n                          0.0, 0.0, 1.0/scale.z, 0.0,\n                          0.0, 0.0, 0.0, 1.0);\n\n    vec4 new_point = vec4(point.x, point.y, point.z, 1.0);\n    new_point = scale_mat * trans_mat * new_point;\n    return vec3(new_point.x, new_point.y, new_point.z);\n}\n\nvec3 naiveRayMarch(in vec3 ro, in vec3 rd) {\n    const float maxDistance = 100.0;\n    const float dt = 0.01;\n    int steps = 0;\n    for (float t = 0.0; t < maxDistance; t += dt) {\n     steps++;\n     //t += dt;\n     vec3 point = ro + rd * t;\n     float intersected = estimateDistance(point).x;\n     if(intersected < 0.0) {\n        return vec3(t, steps, estimateDistance(point).y);\n     }\n    }\n    return vec3(-1);\n}\n\nvec3 sphereTrace(in vec3 ro, in vec3 rd) {\n    const float epsilon = 0.00001;\n    const float minStep = 0.01;\n    const int maxSteps = 100;\n    \n    float t = 0.0;\n    float dt = estimateDistance(ro + rd * t).x;\n    int steps = 0;\n    float col;\n    for (int i = 0; i <= maxSteps; i++ ) {\n        steps++;\n        dt = estimateDistance(ro + rd * t).x;\n        t += max(dt, minStep);\n        if (dt < epsilon) {\n            col = estimateDistance(ro + rd * t).y;\n            break;\n        }   \n    }\n    return vec3(t, steps, col);\n}\n\n\nvec3 calcNormal(in vec3 pos)\n{\n\tfloat eps = 0.0001;\n    vec3 posx = vec3(pos.x + eps, pos.y, pos.z);\n    vec3 posy = vec3(pos.x, pos.y + eps, pos.z);\n    vec3 posz = vec3(pos.x, pos.y, pos.z + eps);\n\tvec3 nor = vec3(estimateDistance(pos).x - estimateDistance(posx).x,\n                    estimateDistance(pos).x - estimateDistance(posy).x,\n                    estimateDistance(pos).x - estimateDistance(posz).x);\n\treturn normalize(nor);\n}\n\n\n/******************LIGHTING***************************/\n\n//lambert\nvec3 lambert(in vec3 point, in vec3 normal, in vec3 mat_color) {\n\tvec3 light_pos = vec3(0.0, -10, -4);\n    float diffuse_term = 0.7;\n    \n    return mat_color * diffuse_term * max(0.0,dot(normal, normalize(light_pos - point)));\n}\n\n\n//soft shadow\nfloat softshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n\tfloat res = 1.0;\n    float t = mint;\n    for( int i=0; i < 16; i++ )\n    {\n\t\tfloat h = estimateDistance(ro + rd*t).x;\n        res = min( res, 3.0 * h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( h<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n\n}\n\n\n/******************* RENDER ***************/\nvec3 render(in vec3 ro, in vec3 rd, in vec2 pixel) {\n  \n    vec3 marched_ray;\n    vec3 BG = vec3(0.7);\n    \n    if (SPHERE_TRACE == 1) {\n    \tmarched_ray = sphereTrace(ro, rd);\n    } else {\n        marched_ray = naiveRayMarch(ro, rd);\n    }\n    \n    vec3 point = ro + rd * marched_ray.x;\n \n  \n    if (DEBUG == 1) {\t\n        //debug image with distance to surface\n        return point;\n    } else if (DEBUG == 2){\t\n        //debug image with normals\n        return calcNormal(point);        \n    } else if (DEBUG == 3) {\t\n        //debug image with distance to surface\n        return vec3(0.0, marched_ray.y/255.0, marched_ray.y/255.0);\n    } else {\n        //render the image\n        if(marched_ray.x > 0.0) {\n            \n           if(SPHERE_TRACE == 1 && marched_ray.y >= 50.0){\n              return BG;\n           } \n            \n            vec3 col = vec3(0.7);\n            if(marched_ray.z == 1.0) {\n                col = vec3(0.1, 0, 0.8);\n            } else if (marched_ray.z == 2.0) {\n                col = vec3(0, 1, 1);\n            } else if (marched_ray.z == 3.0) {\n                col = vec3(0.7, 0, 0);\n            } else {\n                col = vec3(0.5);\n            }\n            \n            return lambert(point, calcNormal(point), col) * \n                vec3(softshadow(point, ro, 0.01, 50.0));\n         } else {\n           return BG;\n         }\n    }\n \n}\n\nmat3 setCamera(in vec3 ro, in vec3 ta, float cr) {\n    // Starter code from iq's Raymarching Primitives\n    // https://www.shadertoy.com/view/Xds3zN\n\n    vec3 cw = normalize(ta - ro);\n    vec3 cp = vec3(sin(cr), cos(cr), 0.0);\n    vec3 cu = normalize(cross(cw, cp));\n    vec3 cv = normalize(cross(cu, cw));\n    return mat3(cu, cv, cw);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Starter code from iq's Raymarching Primitives\n    // https://www.shadertoy.com/view/Xds3zN\n\n    vec2 q = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * q;\n    p.x *= iResolution.x / iResolution.y;\n    vec2 mo = iMouse.xy / iResolution.xy;\n\n    float time = 15.0 + iTime;\n\n    // camera\n    vec3 ro = vec3(\n            -0.5 + 3.5 * cos(0.1 * time + 6.0 * mo.x),\n            1.0 + 2.0 * mo.y,\n            0.5 + 3.5 * sin(0.1 * time + 6.0 * mo.x));\n    vec3 ta = vec3(-0.5, -0.4, 0.5);\n\n    // camera-to-world transformation\n    mat3 ca = setCamera(ro, ta, 0.0);\n\n    // ray direction\n    vec3 rd = ca * normalize(vec3(p.xy, 2.0));\n\n    // render\n    vec3 col = render(ro, rd, fragCoord);\n\n    col = pow(col, vec3(0.3545));\n\n    fragColor = vec4(col, 1.0);\n}\n\n\n","name":"","description":"","type":"image"}]}