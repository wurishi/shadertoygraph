{"ver":"0.1","info":{"id":"ws2XRd","date":"1555051558","viewed":448,"name":"ClockOfClocks","username":"msingdahl","description":"A clock made up of many smaller clocks\n\nBased on the artwork \"a million times\" by humans since 1982.\nhttps://www.humanssince1982.com/a-million-times-at-changi","likes":21,"published":1,"flags":0,"usePreview":0,"tags":["clock","reproduction"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14159265359\n#define TAU 6.28318530718f\n// For only clock animation set to 1.\n#define NumberOfAnimations 5.\n\nconst vec2 o[11] = vec2[11](\n    vec2(359.9,180.), \t//vertical 0\n    vec2(90.,270.), \t//horizontal 1\n    vec2(359.9,90.), \t//bottomLeftCorner 2\n    vec2(90.,180.),\t\t//topLeftCorner 3\n    vec2(270.,180.), \t//topRightCorner 4\n    vec2(359.9,270.), \t//bottomRightCorner 5\n    vec2(135,135),    \t//\"hidden\" 6\n    vec2(359.9,359.9),\t//botStump 7\n    vec2(180,180),\t\t//topStump 8\n    vec2(90,90),\t\t//leftStump 9\n    vec2(270,270)\t\t//rightStump 10\n    );\n\nconst vec2 numbers[4*8*10] = vec2[4*8*10](\n    o[2],o[1],o[1],o[5],\n    o[0],o[2],o[5],o[0],\n    o[0],o[0],o[0],o[0],\n    o[0],o[0],o[0],o[0],\n    o[0],o[0],o[0],o[0],\n    o[0],o[0],o[0],o[0],\n    o[0],o[3],o[4],o[0],\n    o[3],o[1],o[1],o[4],\n    //ONE\n    o[6],o[6],o[2],o[5],\n    o[6],o[6],o[0],o[0],\n    o[6],o[6],o[0],o[0],\n    o[6],o[6],o[0],o[0],\n    o[6],o[6],o[0],o[0],\n    o[6],o[6],o[0],o[0],\n    o[6],o[2],o[4],o[0],\n    o[6],o[3],o[1],o[4],\n    //TWO\n    o[2],o[1],o[1],o[5],\n    o[0],o[2],o[1],o[4],\n    o[0],o[0],o[6],o[6],\n    o[0],o[3],o[1],o[5],\n    o[3],o[1],o[5],o[0],\n    o[6],o[6],o[0],o[0],\n    o[2],o[1],o[4],o[0],\n    o[3],o[1],o[1],o[4],\n    //THREE\n    o[2],o[1],o[1],o[5],\n    o[3],o[1],o[5],o[0],\n    o[6],o[6],o[0],o[0],\n    o[2],o[1],o[4],o[0],\n    o[3],o[1],o[5],o[0],\n    o[6],o[6],o[0],o[0],\n    o[2],o[1],o[4],o[0],\n    o[3],o[1],o[1],o[4],\n    //FOUR\n    o[6],o[6],o[2],o[5],\n    o[6],o[6],o[0],o[0],\n    o[6],o[6],o[0],o[0],\n    o[2],o[1],o[4],o[0],\n    o[0],o[2],o[5],o[0],\n    o[0],o[0],o[0],o[0],\n    o[0],o[0],o[0],o[0],\n    o[3],o[4],o[3],o[4],\n    //FIVE\n    o[2],o[1],o[1],o[5],\n    o[3],o[1],o[5],o[0],\n    o[6],o[6],o[0],o[0],\n    o[2],o[1],o[4],o[0],\n    o[0],o[2],o[1],o[4],\n    o[0],o[0],o[6],o[6],\n    o[0],o[3],o[1],o[5],\n    o[3],o[1],o[1],o[4],\n    //SIX\n    o[2],o[1],o[1],o[5],\n    o[0],o[2],o[5],o[0],\n    o[0],o[0],o[0],o[0],\n    o[0],o[3],o[4],o[0],\n    o[0],o[2],o[1],o[4],\n    o[0],o[0],o[6],o[6],\n    o[0],o[3],o[1],o[5],\n    o[3],o[1],o[1],o[4],\n    //SEVEN\n    o[6],o[6],o[2],o[5],\n    o[6],o[6],o[0],o[0],\n    o[6],o[6],o[0],o[0],\n    o[6],o[6],o[0],o[0],\n    o[6],o[6],o[0],o[0],\n    o[6],o[6],o[0],o[0],\n    o[2],o[1],o[4],o[0],\n    o[3],o[1],o[1],o[4],\n    //EIGHT\n    o[2],o[1],o[1],o[5],\n    o[0],o[2],o[5],o[0],\n    o[0],o[0],o[0],o[0],\n    o[0],o[3],o[4],o[0],\n    o[0],o[2],o[5],o[0],\n    o[0],o[0],o[0],o[0],\n    o[0],o[3],o[4],o[0],\n    o[3],o[1],o[1],o[4],\n    //NINE\n    o[2],o[1],o[1],o[5],\n    o[0],o[2],o[5],o[0],\n    o[3],o[4],o[0],o[0],\n    o[2],o[1],o[4],o[0],\n    o[0],o[2],o[5],o[0],\n    o[0],o[0],o[0],o[0],\n    o[0],o[3],o[4],o[0],\n    o[3],o[1],o[1],o[4]\n    );\n\n//https://gist.github.com/itsmrpeck/be41d72e9d4c72d2236de687f6f53974\nfloat lerpRadians(float a, float b, float lerpFactor) // Lerps from angle a to b (both between 0.f and TAU), taking the shortest path\n{\n    float result;\n    float diff = b - a;\n    if (diff < -PI)        // lerp upwards past TAU\n    {\n        b += TAU;\n        result = mix(a, b, lerpFactor);\n        if (result >= TAU)\n        {\n            result -= TAU;\n        }\n    }\n    else if (diff > PI)        // lerp downwards past 0\n    {\n        b -= TAU;\n        result = mix(a, b, lerpFactor);\n        if (result < 0.f)\n        {\n            result += TAU;\n        }\n    }\n    else         // straight lerp\n    {\n        result = mix(a, b, lerpFactor);\n    }\n\n    return result;\n}\n\nfloat when_gt(float x, float y) {\n  return max(sign(x - y), 0.0);\n}\n\nfloat when_lt(float x, float y) {\n  return max(sign(y - x), 0.0);\n}\n\nvec2 getRotation(int x, int y, int n) {\n\treturn numbers[((4 * y) + x) + (n * 32)];\n}\n\nfloat distanceToSegment( in vec2 p, in vec2 a, in vec2 b ) \n{\n    //Iq's function (I use this for smooth lines)\n\tvec2 pa = p-a;\n\tvec2 ba = b-a;\n\tfloat h = clamp(dot(pa,ba)/dot(ba,ba),0.0,1.0);\n\treturn length( pa - ba*h );\n}\n\nint getNumber(int time, int digit)\n{\n    float d = mod(float(digit), 2.);\n    int t = int(mod(float(time),10.0) * (1.0 - d));\n    t += (time / 10) * int(d);\n    \n    return t;\n}\n\nvec2 displayTimeWithWave(in vec2 uv, in vec2 id,in float frac)\n{    \n    id.x -= 10.;\n    id.y += 4.;\n    vec2 rotation = vec2(0,0);\n\tvec2 nextRotation = vec2(0,0);\n    float time = iDate.w - 1.;\n    float nextTime = time + 1.;\n    \n    float check = 0.;\n    \n    //digits\n    for(int i =0; i < 3; i++){\n        for(int j = 0; j < 2; j++){\n            check = when_gt(id.x, -1.0) * when_lt(id.x, 4.)* when_gt(id.y, -1.0) * when_lt(id.y,8.);\n            \n            rotation += getRotation(int(id.x), int(id.y), getNumber(int(mod(time, 60.)),j)) \n                * check;\n\n            nextRotation += getRotation(int(id.x), int(id.y), getNumber(int(mod(nextTime, 60.)), j))\n                * check;\n\n            id.x += 4.;\n        }\n        id.x += 2.;\n        time = floor(time / 60.);\n        nextTime = floor(nextTime / 60.);\n    }\n    \n    //colons\n    id.x -=13.;\n    for(int i = 0; i < 2; i++) {\n        check = when_gt(id.x, 0.0) * when_lt(id.x, 3.)* when_gt(id.y, 1.0) * when_lt(id.y,6.);\n        rotation.x += (270. + 180. * id.x) * check;\n        nextRotation.x += (270. + 180. * id.x) * check;\n        rotation.y += (0. + 180. * id.y) * check;\n        nextRotation.y += (0. + 180. * id.y) * check;\n        id.x -=10.;\n    }    \n    \n    //reset id for animation\n   \tid = floor(uv);   \n    \n    //lerp between current time and next time(time+1)\n    float clockLerp = clamp(mod(iDate.w * 2.,2.),0.,1.);\n    float h = mix(rotation.x, nextRotation.x, clockLerp);\n    float m = mix(rotation.y, nextRotation.y, clockLerp);\n    \n    //animate the non clock part\n    float animLerp = mod(id.x * .035 + id.y * .035 + frac,2.);\n    h += (90. + id.x * 0. - animLerp * 360. ) * (1. - clamp(rotation.x,0.,1.));\n    m += (270. + id.y * 0. + animLerp * 360. ) * (1. - clamp(rotation.y,0.,1.));\n    \n    float radianHour = radians(mod(h,360.));\n    float radianMinute = radians(mod(m,360.));\n    \n    return vec2(radianHour,radianMinute);\n}\n\nvec2 waveAnimation(in vec2 uv, in vec2 id, in float frac)\n{\n    float animLerp = mod(id.x * .035 + id.y * .035 + (frac - 1.0),2.);\n    float h = (90. + id.x * 0. - animLerp * 360. );\n    float m = (-90. + id.y * 0. + animLerp * 360. );\n    \n    float radianHour = radians(mod(h,360.));\n    float radianMinute = radians(mod(m,360.));\n    \n    return vec2(radianHour,radianMinute);\n}\n\nvec2 boxAnimation(in vec2 uv, in vec2 id, in float frac)\n{    \n    vec2 rotation = vec2(0,0);\n    \n    float h = (90. + id.x * 180. + frac * 360. );\n    float m = (0. - id.y * 180. + frac * 360. );\n      \n    float radianHour = radians(mod(h,360.));\n    float radianMinute = radians(mod(m,360.));\n    \n    return vec2(radianHour,radianMinute);\n}\n\nvec2 boxAnimation2(in vec2 uv, in vec2 id, in float frac)\n{    \n    vec2 rotation = vec2(0,0);\n    \n    float h = (90. + id.x * 180. + frac * 360. );\n    float m = (0. - id.y * 180. - frac * 360. );\n       \n    float radianHour = radians(mod(h,360.));\n    float radianMinute = radians(mod(m,360.));\n    \n    return vec2(radianHour,radianMinute);\n}\n\nvec2 diamondAnimation(in vec2 uv, in vec2 id, in float frac)\n{   \n    vec2 rotation = vec2(0,0);\n    \n    float h = 45. + clamp((frac*34.) - (abs(id.x)) - (abs(id.y)),0.,34.) * 11.25;\n    float m = -135. + clamp((frac*34.) - (abs(id.x)) - (abs(id.y)),0.,34.) * 11.25;\n       \n    float radianHour = radians(mod(h,360.));\n    float radianMinute = radians(mod(m,360.));\n    \n    return vec2(radianHour,radianMinute);\n}\n\n// Animation transition code\n// Lifted from Klems, https://www.shadertoy.com/view/ll2SWW\nvec2 getAnimation(int fx, vec2 uv, vec2 id, float frac) \n{\n \tvec2 value = vec2(0,0);\n    fx = int(mod(float(fx), NumberOfAnimations));\n    if(fx == 0) value = displayTimeWithWave(uv,id,frac);\n    else if(fx == 1) value = boxAnimation(uv,id,frac);\n   \telse if(fx == 2) value = boxAnimation2(uv,id,frac);\n    else if(fx == 3) value = diamondAnimation(uv,id,frac);\n    else value = waveAnimation(uv,id,frac);\n    \n    return value;   \n}\n\nvec2 getFinalRotation(in vec2 uv, in vec2 id) \n{\n    float animationTime = 5.;\n    float segue = .8; \n    int fx = int(iDate.w / animationTime);\n    float frac = mod(iDate.w, animationTime)/ animationTime;\n   \n\tvec2 valueA = getAnimation(fx, uv, id, frac - segue);\n    vec2 valueB = getAnimation(fx - 1, uv, id, (1. - segue) + frac);\n    \n    return vec2(lerpRadians(valueB.x,valueA.x,smoothstep(segue,1.0,frac)),\n                lerpRadians(valueB.y,valueA.y,smoothstep(segue,1.0,frac)));   \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord.xy -.5 * iResolution.xy)/iResolution.y;\n    uv*= 22.;\n      \n   \tfloat p = 20./min(iResolution.x, iResolution.y);\n    \n    //draw circles\n    vec2 gv = fract(uv) - 0.5;   \n    float d = length(gv);\n    float outerCircle = smoothstep(0.485 + p, 0.485 - p, d);\n    float innerCircle = smoothstep(0.445 - p, 0.445 + p, d);\n\tvec3 col = vec3(1,1,1);\n\n    //Get rotation\n   \tvec2 id = floor(uv);   \n    vec2 radian = getFinalRotation(uv,id);\n    \n    //draw clock hands\n    col -= smoothstep(1.0-p, 1.0+p,1. - ((distanceToSegment(gv, vec2(0.),vec2(sin(radian.x),cos(radian.x))*.4) - .04)));\n    col -= smoothstep(1.0-p, 1.0+p,1. - ((distanceToSegment(gv, vec2(0.),vec2(sin(radian.y),cos(radian.y))*.3) - .04)));\n    \n    col -= ((innerCircle * outerCircle) * .3);\n    //debug\n    //col = vec3(radian.x/(PI*2.),0,0);\n    \n    //white border and darken\n    col += 2. * (1. - (when_gt(id.x, -18.0) * when_lt(id.x, 17.)* when_gt(id.y, -8.0) * when_lt(id.y,7.)));\n   \tcol = clamp(col,0.,1.);\n    col -= .1;\n\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}