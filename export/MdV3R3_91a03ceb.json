{"ver":"0.1","info":{"id":"MdV3R3","date":"1457191483","viewed":350,"name":"Anpanman","username":"ming","description":"Anpanman is the main character of a Japanese picture book series and the background music is the corresponding theme song.","likes":8,"published":1,"flags":8,"usePreview":0,"tags":["raymarching","sound","ibl","anpanman"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sf3Rn","filepath":"/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","previewfilepath":"/media/ap/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4sX3zn","filepath":"/media/a/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png","previewfilepath":"/media/ap/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\nconst float PI = 3.14159265359;\n\n// reference: https://iquilezles.org/articles/distfunctions\nfloat sdPlane(vec3 p, vec4 n)\n{\n\t// n must be normalized\n\treturn dot(p, n.xyz) + n.w;\n}\n\nfloat sdSphere(vec3 p, float s)\n{\n\treturn length(p)-s;\n}\n\nfloat sdEllipsoid(in vec3 p, in vec3 r)\n{\n    return (length(p/r) - 1.0) * min(min(r.x,r.y),r.z);\n}\n\nfloat udRoundBox(vec3 p, vec3 b, float r)\n{\n  return length(max(abs(p)-b,0.0))-r;\n}\n\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r)\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\nvec2 opU(vec2 d1, vec2 d2)\n{\n\treturn vec2(\n        min(d1.x, d2.x), \n        d1.x < d2.x ? d1.y : d2.y\n    );\n}\n\nvec2 opS(vec2 d1, vec2 d2)\n{\n    return vec2(\n        max(-d1.x, d2.x),\n        -d1.x > d2.x ? d1.y : d2.y\n    );\n}\n\nvec2 opI(vec2 d1, vec2 d2)\n{\n    return vec2(\n        max(d1.x, d2.x),\n        d1.x > d2.x ? d1.y : d2.y\n    );\n}\n\nfloat smin_polynomial(float a, float b, float k)\n{\n    float h = clamp(0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix(b, a, h ) - k*h*(1.0-h);\n}\n\nvec2 opBlend(vec2 d1, vec2 d2)\n{\n    return vec2(\n        smin_polynomial(d1.x, d2.x, 16.), \n        d1.x < d2.x ? d1.y : d2.y\n    );\n}\n\n//2D texture based 3 component 1D, 2D, 3D noise\nvec3 noise(float p){return texture(iChannel0,vec2(p/iChannelResolution[0].x,.0)).xyz;}\nvec3 noise(vec2 p){return texture(iChannel0,p/iChannelResolution[0].xy).xyz;}\nvec3 noise(vec3 p){float m = mod(p.z,1.0);float s = p.z-m; float sprev = s-1.0;if (mod(s,2.0)==1.0) { s--; sprev++; m = 1.0-m; };return mix(texture(iChannel0,p.xy/iChannelResolution[0].xy+noise(sprev).yz).xyz,texture(iChannel0,p.xy/iChannelResolution[0].xy+noise(s).yz).xyz,m);}\n\nvec3 noise(float p, float lod){return texture(iChannel0,vec2(p/iChannelResolution[0].x,.0),lod).xyz;}\nvec3 noise(vec2 p, float lod){return texture(iChannel0,p/iChannelResolution[0].xy,lod).xyz;}\nvec3 noise(vec3 p, float lod){float m = mod(p.z,1.0);float s = p.z-m; float sprev = s-1.0;if (mod(s,2.0)==1.0) { s--; sprev++; m = 1.0-m; };return mix(texture(iChannel0,p.xy/iChannelResolution[0].xy+noise(sprev,lod).yz,lod).xyz,texture(iChannel0,p.xy/iChannelResolution[0].xy+noise(s,lod).yz,lod).xyz,m);}\n\nfloat hash( float n )//->0:1\n{\n    return fract(sin(n)*3538.5453);\n}\n\nvec3 hash3( float n )\n{\n    return fract(sin(vec3(n,n+1.0,n+2.0))*vec3(13.5453123,31.1459123,37.3490423));\n}\n\n\nfloat pow2(float v)\n{\n    return v * v;\n}\n\n\nfloat pow4(float v)\n{\n    return v * v * v * v;\n}\n\nvec3 pow4(vec3 v)\n{\n    return v * v * v * v;\n}\n\n\nvec3 geoTranslate(vec3 pos, vec3 t)\n{\n\treturn pos - t;\n}\n\nvec3 geoScale(vec3 pos, vec3 s)\n{\n    return pos * (1. / s);\n}\n\n/*\nmat3 rotate_x(float a){float sa = sin(a); float ca = cos(a); return mat3(1.,.0,.0,    .0,ca,sa,   .0,-sa,ca);}\nmat3 rotate_y(float a){float sa = sin(a); float ca = cos(a); return mat3(ca,.0,sa,    .0,1.,.0,   -sa,.0,ca);}\nmat3 rotate_z(float a){float sa = sin(a); float ca = cos(a); return mat3(ca,sa,.0,    -sa,ca,.0,  .0,.0,1.);}\n\nvec3 geoRotateX(vec3 pos, float a)\n{\n    vec3 ret = pos;\n    ret *= rotate_x(a);\n    return ret;\n}\n  \nvec3 geoRotateY(vec3 pos, float a)\n{\n    vec3 ret = pos;\n    ret *= rotate_y(a);\n    return ret;\n}\n*/\n\nvec3 geoRotateX(vec3 p, float a)\n{\n    float sa = sin(a);\n    float ca = cos(a);\n    return vec3(p.x, ca*p.y - sa*p.z, sa*p.y + ca*p.z);\n}\n\nvec3 geoRotateY(vec3 p, float a)\n{\n    float sa = sin(a);\n    float ca = cos(a);\n    return vec3(ca*p.x + sa*p.z, p.y, -sa*p.x + ca*p.z);\n}\n                \nvec3 geoCheapBendWithX(vec3 p, float amount)\n{\n    float c = cos(amount * p.x);\n    float s = sin(amount * p.x);\n    mat2  m = mat2(c,-s, s, c);\n    vec3  q = vec3(m * p.xy, p.z);\n    return q;\n}\n\nvec3 geoCheapBendWithY(vec3 p, float amount)\n{\n    float c = cos(amount * p.y);\n    float s = sin(amount * p.y);\n    mat2  m = mat2(c,-s, s, c);\n    vec3  q = vec3(m * p.xy, p.z);\n    return q;\n}\n\n\nfloat animationTime = 0.;\n\nstruct Material\n{\n\tvec3 albedo;\n\tfloat roughness;\n    float metallicness;\n    float bumpness;\n};\n\n#define MAT_BG 0.\n#define MAT_FACE 1.\n#define MAT_FACE_DARK 2.\n#define MAT_EYE MAT_FACE_DARK\n#define MAT_BROW MAT_FACE_DARK\n#define MAT_MOUTH 3.\n#define MAT_NOSE 4.\n#define MAT_DIMPLE 5.\n#define MAT_FLOOR 6.\n\nMaterial sceneMaterial(float m)\n{\n    Material ret;\n    ret.albedo = vec3(0.);\n    ret.metallicness = 1.;\n    ret.roughness = 0.;\n    ret.bumpness = 0.;\n    \n    if (m == MAT_FACE)\n    {\n        ret.albedo = vec3(253., 178., 127.) / 255.;\n        ret.metallicness = 0.;\n        ret.roughness = 1.0;\n        ret.bumpness = 0.5;\n    }\n    else if (m == MAT_FACE_DARK)\n    {\n        ret.albedo = 1.2 * vec3(91., 29., 33.) / 255.;\n        ret.metallicness = 0.2;\n        ret.roughness = .5;\n        \n    }\n    else if (m == MAT_MOUTH)\n    {\n        ret.albedo = vec3(227., 10., 23.) / 255.;\n        ret.metallicness = 0.0;\n        ret.roughness = 1.0;\n        \n    }\n    else if (m == MAT_NOSE)\n    {\n        ret.albedo = vec3(227., 10., 23.) / 255.;\n        ret.metallicness = 1.0;\n        ret.roughness = 0.5;\n    }\n    else if (m == MAT_DIMPLE)\n    {\n        ret.albedo = vec3(252., 65., 29.) / 255.;\n        ret.metallicness = 0.5;\n        ret.roughness = 0.5;\n    }\n    \n    ret.albedo += .2;\n    \n    return ret;\n}\n\n\nvec2 sceneHead(vec3 pos)\n{\n    vec2 dRet;\n    \n    float displacement = texture(iChannel0, pos.xy * 1.).r * .003;\n    \n    // face\n    float HEAD_RAD = 2.;\n    {\n        vec3 p = pos;\n        p = geoTranslate(p, vec3(0, HEAD_RAD, 0));\n        dRet.x = sdSphere(p, HEAD_RAD) + displacement;\n        dRet.y = MAT_FACE;\n    }\n    // nose\n    float NOSE_RAD = .45;\n    vec3 NOSE_POS = vec3(0., HEAD_RAD - .32, HEAD_RAD - .25);\n    \n    {\n        vec3 p = pos;\n        p = geoTranslate(p, NOSE_POS);\n        \n        float d = sdSphere(p, NOSE_RAD);\n        float m = MAT_NOSE;\n        dRet = opU(vec2(d, m), dRet);\n    }\n    \n    // left eye\n    vec2 EYE_RAD = vec2(.125, .03);\n    vec3 EYE_SCL = vec3(1., 1.2, 1.);\n    vec3 EYE_L_POS = vec3(-.5, HEAD_RAD + .2, HEAD_RAD - .07);\n    vec3 EYE_R_POS = vec3( .5, HEAD_RAD + .2, HEAD_RAD - .07);\n    {\n        vec3 p = pos;\n        p = geoTranslate(p, EYE_L_POS);\n        \n        vec3 p1 = p;\n        float d1 = sdEllipsoid(p1, EYE_SCL* EYE_RAD.x);\n        \n        vec3 p2 = geoCheapBendWithX(p, -1.2);\n        float d2 = sdCapsule(p2, vec3(-EYE_RAD.x, 0, -EYE_RAD.y), vec3(EYE_RAD.x, 0, EYE_RAD.y), EYE_RAD.y);\n        \n        float m = MAT_EYE;\n        float d = mix(d2, d1, animationTime);\n        dRet = opS(vec2(d, m), dRet);\n    }\n    // right eye\n    {\n        vec3 p = pos;\n        p = geoTranslate(p, EYE_R_POS);\n        \n        vec3 p1 = p;\n        float d1 = sdEllipsoid(p1, EYE_SCL* EYE_RAD.x);\n        \n        vec3 p2 = geoCheapBendWithX(p, -1.2);\n        float d2 = sdCapsule(p2, vec3(-EYE_RAD.x, 0, EYE_RAD.y), vec3(EYE_RAD.x, 0, -EYE_RAD.y), EYE_RAD.y);\n        \n        float m = MAT_EYE;\n        float d = mix(d2, d1, animationTime);\n        dRet = opS(vec2(d, m), dRet);\n    }\n    \n    float blowOpen = animationTime * .5 + .5;\n    \n    float BROW_LENGTH = .6;\n    float BROW_RAD = .05;\n    vec3 BROW_L_POS = vec3(-.5, HEAD_RAD + .5, HEAD_RAD - .13);\n    vec3 BROW_R_POS = vec3( .5, HEAD_RAD + .5, HEAD_RAD - .13);\n    \n    // left brow\n    {\n        vec3 p = pos;\n        p = geoTranslate(p, BROW_L_POS);\n        p = geoCheapBendWithX(p, -3. * (blowOpen * .5 + .5));\n        float d = sdCapsule(p, vec3(-BROW_LENGTH * .5, 0, -BROW_RAD), vec3(BROW_LENGTH * .5, 0, BROW_RAD), BROW_RAD);\n        float m = MAT_BROW;\n        dRet = opS(vec2(d, m), dRet);\n    }\n    \n    // right brow\n    {\n        vec3 p = pos;\n        p = geoTranslate(p, BROW_R_POS);\n        p = geoCheapBendWithX(p, -3. * (blowOpen * .5 + .5));\n        float d = sdCapsule(p, vec3(-BROW_LENGTH * .5, 0,  BROW_RAD), vec3(BROW_LENGTH * .5, 0, -BROW_RAD), BROW_RAD);\n        float m = MAT_BROW;\n        dRet = opS(vec2(d, m), dRet);\n    }\n    \n    \n    float DIMPLE_RAD = .45;\n    vec3 DIMPLE_L_POS = vec3(-.6, HEAD_RAD - .32, HEAD_RAD - .35);\n    vec3 DIMPLE_R_POS = vec3( .6, HEAD_RAD - .32, HEAD_RAD - .35);\n    \n    // left dimple\n    {\n        vec3 p = pos;\n        p = geoTranslate(p, DIMPLE_L_POS);\n        \n        float d = sdSphere(p, DIMPLE_RAD);\n        float m = MAT_DIMPLE;\n        dRet = opU(vec2(d, m), dRet);\n    }\n    \n    // right dimple\n    {\n        vec3 p = pos;\n        p = geoTranslate(p, DIMPLE_R_POS);\n        \n        float d = sdSphere(p, DIMPLE_RAD);\n        float m = MAT_DIMPLE;\n        dRet = opU(vec2(d, m), dRet);\n    }\n    \n    // mouth\n    float MOUTH_RAD = .07;\n    float MOUTH_LENGTH = 1.2;\n    vec3 MOUTH_POS = vec3(0, HEAD_RAD - 1., HEAD_RAD - 0.4);\n    \n   \tfloat mouthOpen = animationTime * .5 + .5;\n    {\n        vec3 p = pos;\n        p = geoTranslate(p, MOUTH_POS);\n        vec3 p1 = geoCheapBendWithX(p,  0.75);\n        vec3 beg = vec3(-MOUTH_LENGTH * .5, 0,  .13);\n        vec3 end = vec3( MOUTH_LENGTH * .5, 0, .13);\n        float d1 = sdCapsule(p1, beg, end, MOUTH_RAD);\n        float m1 = MAT_MOUTH;\n        \n        vec3 p2 = p + vec3(0., 0, -.2);\n        float d2 = sdEllipsoid(p2, vec3(.6, .3, .3));\n        float m2 = MAT_MOUTH;\n        \n        dRet = opS(mix(vec2(d2, m1), vec2(d1, m1), mouthOpen), dRet);\n    }\n    \n    return dRet;\n}\n\nvec2 scene(vec3 pos)\n{\n\tvec3 HEAD_POS = vec3(0, .0, 0);\n    vec3 HEAD_SCL = vec3(1., .98, .98);\n    vec2 dRet;\n    \n    {\n        vec3 p = pos;\n        p = geoTranslate(p, HEAD_POS);\n        p = geoScale(p, HEAD_SCL);\n        //p = geoRotateY(p, sin(iTime * .125) * .25 * 3.1415926);\n     \n        dRet = sceneHead(p);\n    }\n    return dRet;\n}\n\n// calculate scene normal using forward differencing\nfloat edge = 0.0;\n/*\nvec3 normal(vec3 p) { \n\tvec3 e = vec3(0.0,det*5.,0.0);\n\n\tfloat d1=de(p-e.yxx),d2=de(p+e.yxx);\n\tfloat d3=de(p-e.xyx),d4=de(p+e.xyx);\n\tfloat d5=de(p-e.xxy),d6=de(p+e.xxy);\n\tfloat d=de(p);\n\tedge=abs(d-0.5*(d2+d1))+abs(d-0.5*(d4+d3))+abs(d-0.5*(d6+d5));//edge finder\n\tedge=min(1.,pow(edge,.5)*15.);\n\treturn normalize(vec3(d1-d2,d3-d4,d5-d6));\n}\n*/\nvec3 sceneNormal( in vec3 p, float d )\n{\n\tvec3 eps = vec3(0.0001, 0.0, 0.0);\n    \n    float d1 = scene(p+eps.xyy).x, d2 = scene(p-eps.xyy).x;\n    float d3 = scene(p+eps.yxy).x, d4 = scene(p-eps.yxy).x;\n    float d5 = scene(p+eps.yyx).x, d6 = scene(p-eps.yyx).x;\n    \n    edge = abs(d-0.5*(d2+d1))+abs(d-0.5*(d4+d3))+abs(d-0.5*(d6+d5));//edge finder\n\tedge = min(1.,pow(edge,.5)*15.);\n    \n\treturn vec3(\n\t\td1 - d2,\n\t\td3 - d4,\n\t\td5 - d6\n\t);\n}\n\nvec3 randomSphereDir(vec2 rnd)\n{\n\tfloat s = rnd.x*PI*2.;\n\tfloat t = rnd.y*2.-1.;\n\treturn vec3(sin(s), cos(s), t) / sqrt(1.0 + t * t);\n}\n\nvec3 randomHemisphereDir(vec3 dir, float i)\n{\n\tvec3 v = randomSphereDir( vec2(hash(i+1.), hash(i+2.)) );\n\treturn v * sign(dot(v, dir));\n}\n\n// ao function from https://www.shadertoy.com/view/4sdGWN\nfloat sceneOcclusion( in vec3 p, in vec3 n, float maxDist, float falloff )\n{\n\tconst int nbIte = 6;\n    \n    float ao = 0.0;\n\t\n    for (int i=0; i<nbIte; i++)\n    {\n        float l = hash(float(i)) * maxDist;\n        vec3 rd = n * l;\n        \n        ao += (l - scene(p + rd).x) / pow(1.+l, falloff);\n    }\n\t\n    return clamp( 1.-ao/float(nbIte), 0., 1.);\n}\n\n// lighting function https://www.shadertoy.com/view/4sX3R2\nvec3 sceneDiffuseLighting(vec3 nor, float occl, float roughness, float hashOffset)\n{\n    vec3 col = vec3(0.0);\n    \n    for( int i = 0; i < 32; i++ )\n    {\n        //vec3 rr = normalize(-1.0 + 2.0*hash3(float(i)*123.5463) + hashOffset);\n        //rr = normalize( nor + 7.0*rr );\n        //rr = rr * sign(dot(nor,rr));\t\t\t\t\t\t\t  \n\t\t\n        vec3 rr =  normalize(nor + 7.0 * randomHemisphereDir(nor, float(i)*123.5463));\n        \n        vec3 r1 = textureLod(iChannel1, rr, 5.0).xyz;\n        vec3 r0 = textureLod(iChannel1, rr, 1.0).xyz;\n        \n        col += pow(mix(r0, r1, roughness), vec3(2.2) ) * dot(rr,nor) * occl;\n    }\n    \n    return col / 32.0;\n    \n}\n\nvec3 sceneSpecularLighting(vec3 nor, vec3 viewDir, float occl, float roughness, float metallicness)\n{\n    float fren = clamp(1. + dot(viewDir, nor), 0., 1.);\n    fren = pow(fren, 5.0);\n    fren = metallicness + (1.-metallicness) * fren;\n    \n    vec3 dir = reflect(viewDir, nor);\n    vec3 r1 = textureLod(iChannel1, dir, 3.0).xyz;\n    vec3 r0 = textureLod(iChannel1, dir, 0.0).xyz;\n    \n    return mix(r0, r1, roughness) * fren * occl;\n}\n\nstruct Ray\n{\n\tvec3 org;\n\tvec3 dir;\n};\n\nconst int RAY_MARCH_STEPS = 32;\n\n\nbool raymarch(Ray ray, out vec3 hitPos, out vec2 hitInfo)\n{\n\tconst float hitThreshold = 0.0001;\n\n\tbool hit = false;\n\thitPos = ray.org;\n    \n\tvec3 pos = ray.org;\n\n\tfor (int i = 0; i < RAY_MARCH_STEPS; i++)\n\t{\n\t\tvec2 s = scene(pos);\n\n\t\tif (s.x < hitThreshold)\n\t\t{\n            hit = true;\n\t\t\thitPos = pos;\n\t\t\thitInfo = s;\n\t\t\tbreak;\n\t\t}\n\t\tpos += s.x * ray.dir;\n\t}\n    \n\treturn hit;\n}\n\n\nvec4 background(Ray ray)\n{\n    vec4 c1 = vec4(.8, .9, 1., 1.);\n    vec4 c2 = vec4(1., 1., 1., 1.);\n    float t = ray.dir.y;\n    t = smoothstep(0., .8, t);\n    return mix(c1, c2, t);\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 ndcXY = fragCoord.xy / iResolution.xy;\n    ndcXY = -1.0 + 2.0 * ndcXY;\n\tndcXY.x *= iResolution.x / iResolution.y;\n    \n    float t = (.5 + sin(iTime * .5) / 32.) * PI;\n    animationTime = (sin(PI * .25 + iTime * 2.) * .5 + .5);\n\t\n    \n    // construct the ray in world space\n\tRay ray;\n    ray.org = vec3(cos(t), 0, sin(t)) * 6.0 + vec3(0., 2., 0.);\n\tvec3 ta = vec3(0., ray.org.y + .1, 0.);\n\t\n\t// camera-to-world transformation\n    mat3 ca = setCamera(ray.org, ta, 0.0);\n    \n    // ray direction\n\tray.dir = ca * normalize(vec3(ndcXY.xy, 2.0));\n\t\n\tvec3 sceneWsPos;\n    vec2 sceneInfo;\n    \n\tif (raymarch(ray, sceneWsPos, sceneInfo))\n\t{\n\t\t// our ray hit the scene, shade it with a point light\n        Material mtl = sceneMaterial(sceneInfo.y);\n        \n        vec3 sceneWsNrm = normalize(sceneNormal(sceneWsPos, sceneInfo.x));\n        \n        float sceneOccl = sceneOcclusion(sceneWsPos, sceneWsNrm, 16., .25);\n        sceneOccl *= pow2(sceneOcclusion(sceneWsPos, sceneWsNrm, 8., .5));\n        float hashOffset = 0.;//dot(sceneWsPos, vec3(1.));\n        vec3 color = mtl.albedo * (sceneOccl * .5 + sceneDiffuseLighting(sceneWsNrm, sceneOccl, mtl.roughness, hashOffset));\n        \n        vec3 viewDir = normalize(ray.dir);\n          \n        sceneOccl = sceneOcclusion(sceneWsPos, reflect(viewDir, sceneWsNrm), 8., .5);\n        color += sceneSpecularLighting(sceneWsNrm, viewDir, sceneOccl, mtl.roughness, mtl.metallicness);\n        \n        fragColor = vec4(color, 1.);\n        //fragColor = vec4(sceneOccl, sceneOccl, sceneOccl, 1.);\n\t}\n\telse\n\t{\n\t\tfragColor = background(ray);\n\t}\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"XsfGRr","channel":0}],"code":"// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\nfloat note( float freq, float time )\n{\n    freq = 440.0*pow(freq/440.0,1.003); // spread\n    \n    float ft = freq*time;\n    \n    float ph = 1.0;\n    ph *= sin(6.2831*ft);\n    ph *= 0.2+0.8*max(0.0,6.0-0.01*freq);\n    ph *= exp(-ft*0.2);\n    \n    float y = 0.0;\n    y += 0.70*sin(1.00*6.2831*ft+ph)*exp(-0.5*0.007*ft);\n    y += 0.20*sin(2.01*6.2831*ft+ph)*exp(-0.5*0.011*ft);\n    y += 0.10*sin(3.01*6.2831*ft+ph)*exp(-0.5*0.015*ft);\n    /*\n    y += 0.16*sin(4.01*6.2831*ft+ph)*exp(-0.5*0.018*ft);\n    y += 0.13*sin(5.01*6.2831*ft+ph)*exp(-0.5*0.021*ft);\n    y += 0.10*sin(6.01*6.2831*ft+ph)*exp(-0.5*0.027*ft);\n    y += 0.09*sin(8.01*6.2831*ft+ph)*exp(-0.5*0.030*ft);\n    y += 0.07*sin(9.01*6.2831*ft+ph)*exp(-0.5*0.033*ft);\n\t*/\n    \n    y *= clamp( time/0.002, 0.0, 1.0 ); // suppress the responds after time / 0.002\n\n\treturn y;\n}\n\n//----------------------------------------------------------------------------------------\n\n#define D(a) b+=float(a);if(t>b)x=b;\n#define MUTE(dur) {w += float(dur);}\n#define N(dur, freq) {x = t; b = 0.0; D(w) y += f * note( freq, tint*(t-x) ); w += float(dur);}\n#define Nu(dur, freq) N(dur, freq * 2.)\n#define Nuu(dur, freq) N(dur, freq * 4.)\n#define Nd(dur, freq) N(dur, freq * .5)\n#define Ndd(dur, freq) N(dur, freq * .25)\n\n#define Gs3 207.65\n#define A3\t220.00\n#define Bb3 233.08\n#define B3\t246.94\n#define\tC4\t261.63\n#define\tCs4 277.18\n#define\tD4\t293.66\n#define\tEb4 311.13\n#define\tE4\t329.63\n#define\tF4\t349.23\n#define\tGb4 369.99\n#define G4\t392.00\n#define Gs4 415.30\n\n#define _1 Gs3 * s\n#define _2 Bb3 * s\n#define _3 C4 * s\n#define _4 Cs4 * s\n#define _4s D4 * s\n#define _5 Eb4 * s\n#define _5s E4 * s\n#define _6 F4 * s\n#define\t_6s Gb4 * s\n#define _7 G4 * s\n\n\n//----------------------------------------------------------------------------------------\n// https://www.youtube.com/watch?v=meAgRanQjmQ\n//#define tint 0.144\n#define tint 0.083\n#define PART_A 1\n#define PART_B 1\n#define PART_C 1\n#define PART_D 1\n\n#define HAS_CHANNEL_1 1\n#define HAS_CHANNEL_2 1\n#define HAS_CHANNEL_3 1\n\n#if HAS_CHANNEL_1\nfloat doChannel1( float t )\n{\n    float x = 0.0;\n    float y = 0.0;\n    float b = 0.0;\n    float w = 0.0;\n    float s = 1.0;\n    float f = 1.0;\n    t /= tint;\n        \n#if PART_A\n    f = 2.0;\n    Nu(4, _3) Nu(4, _3) Nu(4, _1) MUTE(4)\n    N(4, _6) N(2, _6) N(2, _7) Nu(4, _1) N(4, _6)\n    Nu(6, _2) Nu(2, _3) Nu(4, _2) Nu(4, _1)\n    N(4, _7) N(4, _6) N(4, _5) MUTE(4)\n        \n    Nu(4, _3) Nu(4, _3) Nu(4, _1) MUTE(4)\n    N(4, _6) N(2, _6) N(2, _7) Nu(4, _1) N(4, _6)\n    Nu(6, _2) Nu(2, _3) Nu(4, _2) N(4, _7)\n    Nu(12, _1) MUTE(4)\n#endif \n\n#if PART_B\n    // channel 3 solo\n    f = 0.;\n    MUTE(16. * 8.)\n#endif\n        \n#if PART_C\n    f = 1.0;\n    //0:22 Nan no tame ni umarete...\n    N(4, _1) N(2, _3) N(2, _4) N(4, _5) N(4, _1*2.)\n    N(4, _6) N(2, _5) N(2, _4) N(4, _5) MUTE(4)\n    N(4, _4) N(2, _3) N(2, _2) N(4, _3) N(4, _1) \n    N(2, _2) N(2, _1) N(2, _2) N(2, _3) N(4, _2) MUTE(4)\n        \n    //0:28 Kotaerarenai nante...   \n    N(2, _1) N(2, _2) N(2, _3) N(2, _4) N(4, _5) N(4, _1*2.)\n    N(4, _6) N(2, _5) N(2, _4) N(4, _5) MUTE(4)\n    N(4, _4) N(2, _3) N(2, _2) N(4, _3) N(4, _1) \n    N(2, _2) N(2, _1) N(2, _2) N(2, _3) N(4, _1) MUTE(4)\n#endif\n        \n#if PART_D\n    //0:34 Ima wo ikiru koto de...\n    f = 0.5;\n    N(2, _2) N(2, _3) N(4, _2) N(2, _2) N(2, _3) N(4, _2)\n    N(4, _2) N(4, _5) N(4, _2) MUTE(4)\n        \n    //0:36 atsui kokoro moeru...\n    f = 1.0;\n    N(2, _3) N(2, _4) N(4, _3) N(2, _3) N(2, _4) N(4, _3)\n    N(4, _3) N(4, _6) N(4, _3) MUTE(4)\n\n    //0:38 dakara kimi wa ikunda...\n    f = 2.0;\n    N(2, _5) N(2, _6) N(4, _5) N(2, _5) N(2, _6) N(4, _5)\n    N(4, _5) Nu(4, _1)  N(4, _5) Nu(4, _3) \n    Nu(4, _2) N(4, _6) Nu(6, _2) Nu(2, _1)\n    N(12, _7) MUTE(4)\n#endif\n        \n    return y;\n}\n#endif\n\n#if HAS_CHANNEL_2\nfloat doChannel2( float t )\n{\n    float x = 0.0;\n    float y = 0.0;\n    float b = 0.0;\n    float w = 0.0;\n    float s = 1.0;\n    float f = 1.0;\n    t /= tint;\n    \n#if PART_A\n    s = .5;\n    N(4, _1) MUTE(4) Nd(4, _3) MUTE(4)\n    Nd(4, _4) MUTE(4) Nd(4, _4) MUTE(4)\n    Nd(4, _4s) MUTE(4) Nd(4, _4s) MUTE(4)\n    Nd(4, _5) MUTE(4) Nd(4, _2) Nd(4, _5)\n    \n    Nd(4, _1) MUTE(4) Nd(4, _3) MUTE(4)\n    Nd(4, _4) MUTE(4) Nd(4, _4) MUTE(4)\n    Nd(4, _4s) MUTE(4) Nd(4, _5) Nd(4, _7)\n    N(4, _1) Nd(4, _5) Nd(4, _1) MUTE(4)\n    \n#endif\n\n#if PART_B\n    // channel 3 solo\n    s = .5;\n    \n    MUTE(16. * 2.)\n    \n    N(4, _2) Nd(2, _6) Nd(2, _6) N(4, _2) N(4, _6)\n    N(4, _5) N(2, _2) N(2, _2) N(2, _5) N(2, _2) N(2, _5) N(2, _7)\n        \n    MUTE(16. * 2.)\n\n    N(2, _4) N(2, _3) N(2, _4) N(2, _5) N(2, _3) N(2, _1) N(2, _2) N(2, _3)\n    N(2, _2) Nd(2, _6) Nd(2, _7) N(2, _1) Nd(4, _7) N(2, _5) MUTE(2)\n        \n#endif\n        \n#if PART_C\n    s = .5;\n    N(4, _1) MUTE(4) Nd(4, _7) MUTE(4)\n    N(4, _1) MUTE(4) Nd(4, _5) MUTE(4)\n    N(4, _1) MUTE(4) Nd(4, _5) MUTE(4)\n    Nd(4, _6) MUTE(4) Nd(4, _7) Nd(4, _5)\n        \n    N(4, _1) MUTE(4) Nd(4, _7) MUTE(4)\n    N(4, _1) MUTE(4) Nd(4, _5) MUTE(4)\n    N(4, _1) MUTE(4) Nd(4, _5) MUTE(4)\n    Nd(4, _6) MUTE(4) N(4, _2) Nd(4, _5)\n#endif\n        \n#if PART_D\n    s = 2.;\n    f = .5;\n    Nd(16, _6) Nd(16, _7)\n        \n    f = 1.;   \n    Nd(16, _7) N(16, _1)\n        \n    f = 2.;\n    N(16, _2) N(12, _3) N(4, _1) \n    Nd(16, _7) MUTE(16)\n        \n#endif\n        \n    return y;\n}\n\n#endif\n\n#if HAS_CHANNEL_3\nfloat doChannel3( float t )\n{\n    float x = 0.0;\n    float y = 0.0;\n    float b = 0.0;\n    float w = 0.0;\n    float s = 1.0;\n    float f = 1.0;\n    t /= tint;\n    \n#if PART_A\n    s = 1.;\n    f = 1.0;\n    N(4, _3) N(2, _3) N(2, _4) N(4, _5) N(4, _3)\n    \n    //s = .5;\n    f = 1.0;\n    N(16, _4)\n    N(16, _4s)\n    N(8, _5) N(4, _5) N(4, _3)\n    \n    s = 2.;\n    f = 1.0;\n    N(4, _3) N(2, _3) N(2, _4) N(4, _5) N(4, _3)\n    \n    //s = .5;\n    f = 1.0;\n    N(16, _4)\n    N(16, _4s)\n    N(8, _5) N(4, _5) N(4, _1)\n    \n#endif\n\n#if PART_B\n    // SOLO\n    f = 2.0;\n    s = 2.;\n    N(8, _4) N(8, _3) \n    N(2, _4) N(2, _3) N(2, _4) N(2, _5) N(4, _3) N(4, _2)\n    \n    MUTE(16.0 * 2.0)\n    \n    s = 2.;\n    N(8, _4) N(8, _3) \n    N(2, _4) N(2, _3) N(2, _4) N(2, _5) N(4, _3) N(4, _2)\n    \n    MUTE(16.0 * 2.0)\n    \n#endif\n        \n#if PART_C\n    MUTE(16. * 2.)\n        \n    f = 0.5;\n    s = 2.;\n    N(8, _4) N(8, _3)\n    MUTE(8) N(4, _2) N(4, _5)\n        \n    MUTE(16. * 2.)\n        \n    s = 2.;\n    N(8, _4) N(8, _3)\n    MUTE(16)\n#endif        \n        \n#if PART_D\n    s = 2.;\n    \n    f = 0.5;\n    MUTE(16 + 7)\n    N(1, _1) N(1, _2) N(1, _3) N(1, _4) N(1, _5) N(1, _4) N(1, _3) N(1, _2) N(1, _1)\n    \n    f = 1.0;\n    MUTE(16 + 7)\n    N(1, _5) N(1, _6) N(1, _7) Nu(1, _1) Nu(1, _2) Nu(1, _1) N(1, _7) N(1, _6) N(1, _5)\n    \n    f = 2.0;\n    MUTE(16 + 7)\n    Nu(1, _1) Nu(1, _2) Nu(1, _3) Nu(1, _4) Nu(1, _5) Nu(1, _4) Nu(1, _3) Nu(1, _2) Nu(1, _1)\n    \n    MUTE(9) N(1, _7) Nu(1, _2) Nu(1, _5)\n        \n#endif\n        \n    return y;\n}\n\n#endif\n\n// https://www.shadertoy.com/view/ldfSW2\n// randomize\nfloat nse(float x)\n{\n\treturn fract(sin(x * 110.082) * 19871.8972);\n\t//return fract(sin(x * 110.082) * 13485.8372);\n\n}\n\n// bad 909-ish open hihat\nfloat hat(float tb)\n{\n\ttb = fract(tb / 4.0) * 0.5;\n\tfloat aa = 4.0;\n\t//tb = sqrt(tb * aa) / aa;\n\treturn nse(sin(tb * 4000.0) * 0.0001) * smoothstep(0.0, 0.01, tb - 0.25) * exp(tb * -5.0);\n}\n\nvec2 mainSound( in int samp, float time )\n{\n    //const float songLength = 14.0;\n    const float songLength = 42.5;\n    time = mod( time, songLength );\n\n    vec2 y = vec2(0.);\n    \n    #if HAS_CHANNEL_1\n    y.xy += vec2(doChannel1(time));\n    #endif\n    \n    #if HAS_CHANNEL_2\n    y.x += doChannel2(time);\n    #endif\n    \n    #if HAS_CHANNEL_3\n    y.y += doChannel3(time);\n    #endif\n    \n    y *= .125;\n\treturn y;\n}\n","name":"Sound","description":"","type":"sound"}]}