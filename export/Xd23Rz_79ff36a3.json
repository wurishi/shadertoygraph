{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[{"channel":0,"type":"texture","id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}},{"channel":1,"type":"cubemap","id":"4dX3zn","filepath":"/media/a/550a8cce1bf403869fde66dddf6028dd171f1852f4a704a465e1b80d23955663.png","sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"}}],"code":"#define ON_EVOLVING_CIRCLE 66.0\nvec4 determine_ray_color(float angle,vec2 uv ,vec3 center){\n\t\n\t/*Fuzzy color setup*/\n\tvec4 outer_color =  vec4(1.0, 0.0, 0.0, 0.0);\n    vec4 inner_color = vec4(1.0, 1.0, 0.75, 1.0);\n    float inner_radius = 0.25*iResolution.x*iResolution.y*cos(iTime);\n\tfloat outer_radius = 0.45*iResolution.x*iResolution.y*sin(iTime);\n\n\t\n\tvec4 p;\n\t//vec4 effect_color = vec4(1.0,1.0,0.5*sin(iTime),1.0);\n\tfloat dist = distance(uv,center.xy);\n\tvec4 effect_color =  mix( inner_color, outer_color,    smoothstep( inner_radius, outer_radius, dist) );\n\tvec4 back_color = vec4(0.0,0.0,0.0,0.0);//vec4(uv,0.5+0.5*sin(iTime),1.0);\n\t/*change 10.0 to change ray switch speed*/\n\tfloat random_number = iTime*iTime/10.0; /*Put fragCoord.x*/\n\t\n\tif(/*fract(abs(angle)*0.4) > 0.4*/floor(mod(angle,2.0)) == 1.0){\n\t\t\tif(floor(mod(random_number,2.0)) == 0.0)\n\t\t\t\tp =  back_color;\n\t\t\telse\n\t\t\t\tp = effect_color;\n\t}\n\telse{\n\t\t\tif(floor(mod(random_number,2.0)) == 1.0)\n\t\t\t\tp =  back_color;\n\t\t\telse\n\t\t\t\tp = effect_color;\t\n\t}\n\treturn p;\n}\nmat4 rotationMatrix(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n                0.0,                                0.0,                                0.0,                                1.0);\n}\nvec4 evolve_circle(vec3 center,float radius,vec3 point,float ring_size){\n\tvec4 res = vec4(1.0,0.5+0.5*sin(iTime),0.0,0.0);//vec4(0.0,1.0,0.0,0.0);\n\t\n\tfloat dist = distance(center,point);\n\n\tfloat max_radius = iResolution.x/2.0;\n\t\n\tfloat w = iTime;\n\tfloat sine = sin(w);\n\tif(sine >= 0.0)\n\t\tradius = abs(sine)*max_radius+radius;\n\telse{\n\t\tradius = abs(1.0+sine)*max_radius+radius;\n\t}\n\t\n\t\n\tif(dist > radius && dist <= radius + ring_size)\n\t\tres.w = ON_EVOLVING_CIRCLE;\n\treturn res;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tvec3 center = vec3(iResolution.x*0.5,iResolution.y*0.5,1.0);\n\tfloat radius = iResolution.x/10.0;\n\tvec3 point = vec3 ( fragCoord.xy, 0.);\n\tfloat dist = distance(center,point);\n\tvec2 line_ptr_size = vec2(radius/3.0,radius/3.0);\n\t\n\tvec3 evolving_center = center;\n\tfloat evolving_radius = radius;\n\tfloat evolving_ring_size = 12.0;\n\t\n\tfloat random_number = sin(iTime);\n\n\tfloat mouse_dist_from_center;\n\t\n\tif(dist < radius){ \n\t\t//mouse_dist_from_center = distance(iMouse.xy,center.xy);\n\t\tif( mouse_dist_from_center > radius){\n\t\t\t\t/*The mouse is outside the sphere*/\n\n\t\t}\n\t\telse{/*Inside the sphere*/\n\t\t\tmat4 rot = rotationMatrix(point, random_number );\n\t\t\tmat3 rot_3 = mat3(rot[0],rot[1],rot[2]);\n\t\t\tvec3 rotated = ((rot_3*point)/102.40);\n\t\t\tfragColor = texture(iChannel0, rotated.xy);\n\t\t\tfragColor = vec4(1.0 - fragColor.r,random_number *fragColor.g,0.6*fragColor.b,fragColor.a);\n\t\t\treturn;\n\t\t}\n\t}\n\telse if (dist >=  radius  && dist < iResolution.x){\n\t\t/*Draw rays*/\n\t\tvec2 p = -1.0 + 2.0 * uv.xy;\n\t\tfloat angle = dot(normalize(vec3(p,0.0)),normalize(vec3(center)));\n\t\tangle = degrees(angle);\n\t\tfragColor = determine_ray_color(angle,uv,center);\n\t\t\n\t}\n\telse\n\t\tfragColor = vec4(0.0,0.0,0.0,0.0);//uv,0.5+0.5*sin(iTime),1.0);\n\t\n\tvec4 res = evolve_circle(evolving_center,evolving_radius,point,evolving_ring_size);\n\tif(res.w == ON_EVOLVING_CIRCLE)\n\t\tfragColor = res;\n\n\t\n\treturn;\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"Xd23Rz","date":"1382804790","viewed":141,"name":"epilepsy","username":"gclkaze","description":"Ray vectors flowing from the center of the sphere","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["fract"],"hasliked":0,"parentid":"","parentname":""}}