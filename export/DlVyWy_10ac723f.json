{"ver":"0.1","info":{"id":"DlVyWy","date":"1701961257","viewed":78,"name":"ReflectionTest_v1","username":"kastanileel","description":"Testing reflections in raymarching. Also rotating SDFs when intersecting smoothly looks awesome!","likes":9,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","distancefield","reflection","rotation"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define maxBounces 6\n#define maxMarchingSteps 100\n#define hitThreshold 0.0001\nfloat INFINITY = 1.0 / 0.0001;\nvec3 globalLight = vec3(3.0, 2.0, 1.0);\nvec3 camera = vec3(0., 1., 3.);\n\n\n\nstruct HitInfo{\n    int hitID;\n    vec3 hitPoint;\n    vec3 normal;\n};\n\nstruct Material {\n    vec3 Ka;\n    vec3 Kd;\n    vec3 Ks;\n    float Ns;\n    float Ni;\n    float d;\n};\n\nconst int maxMaterials = 10;\nMaterial materials[maxMaterials];\n\nvec2 sdOctahedron( vec3 p, float s){\n  int sdfId = 0;\n  p = abs(p);\n  float sdfEvaluation = (p.x+p.y+p.z-s)*0.57735027;\n\n \n  return vec2(sdfEvaluation, sdfId);\n}\n\nvec2 sdfSphere(vec3 p, vec3 center, float radius){\n int sdfId = 1;\n \n float sdfEvaluation = length(p-center) - radius;\n \n return vec2(sdfEvaluation, sdfId);\n\n}\n\nvec3 rotateVectorY(vec3 inputVector, float rotation){\n    vec3 erg = vec3(0.);\n    \n    erg.x = cos(rotation) * inputVector.x + sin(rotation) * inputVector.z;\n    erg.y = inputVector.y;\n    erg.z = -sin(rotation) * inputVector.x + cos(rotation) * inputVector.z;\n\n    return erg;\n\n}\n\nfloat smin(float a, float b, float k) {\n    float h = max(k - abs(a - b), 0.0) / k;\n    return min(a, b) - h * h * k * (1.0 / 4.0);\n}\n\n\nvec2 sdfAll(vec3 p){\n\n   // vec2 oct = sdOctahedron(p - vec3(0.,sin(iTime *2. *.2), 0.), .6);\n    vec2 oct = sdOctahedron(rotateVectorY(p - vec3(-0.2, 0., 0.), iTime), .7);\n    vec2 sphere = sdfSphere(p, vec3(sin(iTime*0.8)/2. + .8, 0.1, 0.1), .5);\n    \n    float smoothDistance = smin(oct.x, sphere.x, 0.2);\n   \n    \n    // evaluate which sdf is the closest\n    vec2 erg = vec2(0.0);\n    if(sphere.x < oct.x)\n        erg = sphere;\n    else\n        erg = oct;\n    \n    erg.x = smoothDistance;\n    return erg;\n}\n\nvec3 getNormal(vec3 p){\n\n    vec3 offset = vec3(0.0001, 0., 0.);\n    \n    float gradientX = sdfAll(p + offset.xyy).x - sdfAll(p - offset.xyy).x;\n    float gradientY = sdfAll(p + offset.yxy).x - sdfAll(p - offset.yxy).x;\n    float gradientZ = sdfAll(p + offset.yyx).x - sdfAll(p - offset.yyx).x;\n    \n    return normalize(vec3(gradientX, gradientY, gradientZ));\n}\n\n\n//ro = rayOrigin rd = rayDistance\nHitInfo rayMarch(vec3 ro, vec3 rd){\n\n     float totalMarchedDist = 0.;\n    \n     vec3 currentRayPos;\n     vec3 normal;\n     \n     int nearestSDFid = -1;\n     bool hit = false;\n     for(int i = 0; i < maxMarchingSteps; i ++)\n    {\n        //march along ray\n        currentRayPos = ro + totalMarchedDist * rd;\n        \n        //smallest distance to closest object\n        vec2 sdfEvaluation = sdfAll(currentRayPos);\n        float distToSDF = sdfEvaluation.x;\n        \n        //move rayPosition nearer to sdf\n        totalMarchedDist += distToSDF;\n        \n        \n        if(distToSDF < hitThreshold){  \n            nearestSDFid = int(sdfEvaluation.y);\n            normal = getNormal(currentRayPos);              \n            hit = true;\n            break;\n        }\n        \n     }\n             \n     return HitInfo(nearestSDFid, currentRayPos, normal);\n}\n\nvec3 phongModel(vec3 hitPoint, vec3 normal, int objectID, bool isShadowed){\n\n     Material mat = materials[objectID];\n     \n     vec3 ambientColor = mat.Ka;\n     \n     if(isShadowed)\n         return ambientColor;\n         \n     vec3 lightDir = normalize(globalLight - hitPoint);\n     \n     vec3 diffuseColor = max(0.0, dot(lightDir, normal))* mat.Kd;\n     \n     vec3 specularColor = pow(max(0.0, dot(reflect(lightDir,normal), normalize(hitPoint - camera))), mat.Ns) * mat.Ks;\n     \n     return ambientColor + diffuseColor + specularColor;\n     \n}\n\nvoid initMaterials() {\n    materials[0] = Material(vec3(0.1, 0.05, 0.0), vec3(0.4, 0.2, 0.0), vec3(.7), 5.0f, 1.0, 0.0);\n    materials[1] = Material(vec3(0.0, 0.05, 0.2), vec3(0.0, 0.4, 0.7), vec3(.5), 5.0f, 1.0, 0.0);\n    \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    initMaterials();\n    vec2 uv = 2.* fragCoord/iResolution.xy -1.;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    //origin of rays\n    vec3 ro = camera;\n    //normalized direction of rays\n    vec3 rd = normalize(vec3(uv, 0.) - ro);\n    \n    vec3 pixelColor = vec3(0.0);\n    vec3 attenuation = vec3(1.0);\n  \n    for(int i = 1; i <= maxBounces; i ++){\n        HitInfo hit = rayMarch(ro, rd);\n        if(hit.hitID != -1){\n           Material mat = materials[hit.hitID];\n    \n            // Update ray origin and direction for next bounce\n            ro = hit.hitPoint + hit.normal * 0.001;\n            rd = reflect(rd, hit.normal);\n            \n            // calculate shadowRay\n            vec3 lightDir = normalize(globalLight - hit.hitPoint );\n            HitInfo shadowInfo = rayMarch(ro, lightDir);\n            \n            // calculate color based on phong light model\n            vec3 hitPointColor = phongModel(hit.hitPoint, hit.normal, hit.hitID, shadowInfo.hitID != -1);\n            \n           \n            pixelColor += hitPointColor * attenuation;\n\n            \n            attenuation *= (mat.Ks);\n            \n            // handle refraction\n            // only if not fully opague\n            if(mat.d < 1.0f){\n            }\n        }\n        \n        else {\n            // Ray did not hit an object\n            // apply background color\n            pixelColor +=  texture(iChannel0, rd).rgb * attenuation;\n            break; // Exit loop if no hit\n        }\n    }\n    \n    \n    fragColor = vec4(pixelColor,1.0);\n}\n","name":"Image","description":"","type":"image"}]}