{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[{"channel":0,"type":"video","id":"Xdf3Rn","filepath":"/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm","sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"}}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\t\n\tvec4 base;\n\t\n\tfloat scaledT = iTime * 5.0;\n\t//vec2 targ = vec2(sin(scaledT), cos(scaledT));\n\t\n\t//base = vec4(1.0) * float(distance(targ, uv));\n\t\t\n\tbase = texture(iChannel0, uv);\n\t\n\tvec4 color = base;\n\t// NOTE: The effect works more interestingly with higher maxiters, but long loops tend to crash WebGL\n\t// or at least be slow. Feel free to increase it, but don't be surprised if it crashes.\n\tconst int maxiters = 100;\n\tint iters = int(mod(scaledT, float(maxiters)));\n\tfor (int i = 0; i < maxiters; i++)\n\t{\n\t\tcolor *= 0.8 + (clamp((float(i < iters)) + (1.0/float(iters))  * vec4(vec2(iResolution.x * dFdx(color.rg)), vec2(iResolution.y * dFdy(color.ba)))\n\t\t\t\t\t  , 0.0, 1.0) * 0.25);\n\t}\n\t\n\t\n\tfragColor = color;\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"4sfGDj","date":"1379085511","viewed":726,"name":"Fundefined behaviour!","username":"XMPPwocky","description":"Does it work on your hardware?\n","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["glitchy"],"hasliked":0,"parentid":"","parentname":""}}