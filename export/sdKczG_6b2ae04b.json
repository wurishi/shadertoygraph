{"ver":"0.1","info":{"id":"sdKczG","date":"1655114075","viewed":128,"name":"Plaything 20220613","username":"daeken","description":"Just messing around","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["playing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\ntrue =>shadertoy\n\n{\n    @vec2 uniform =iResolution\n    @float uniform =iTime\n    @vec2 varying =fragCoord\n    \n    :m resolution iResolution ;\n    :m time iTime ;\n    fragCoord 2 / 1 - [ resolution .xy \\/ 1 ] * =real-position\n} {\n    @vec2 uniform =resolution\n    @float uniform =time\n    @vec2 varying =position\n    position 2 / 1 - [ resolution .xy \\/ 1 ] * =real-position\n} shadertoy cif\n\n:m ->fragColor =$gl_FragColor ;\n\n{ + - * / } //{ (| operator |)\n    { = => } //{ (| assignment |)\n            `{ (| value variable |)\n                        *variable\n                        value\n                    ,operator\n                        &,assignment\n                        variable\n                    concat\n                call\n            }\n            operator assignment concat\n        def-prefix\n    }\n}\n:p min= (| variable |) *variable min &= variable concat call ;\n:p max= (| variable |) *variable max &= variable concat call ;\n\n:m when (| block cond |) block { } cond if ;\n:m cwhen (| block cond |) cond ~*block ;\n\n: smin (| a b k |)\n    k a b - abs - 0 max k / =h\n    a b min [ h h k 1 4 / ] \\* -\n;\n\n: sdif (| d1 d2 k |)\n    0.5 !d2 d1 + * k / - 0 1 clamp =h\n    d2 d1 neg h mix [ k h 1 h - ] \\* +\n;\n\n: sint (| d1 d2 k |)\n    0.5 !d2 d1 - * k / - 0 1 clamp =h\n    d2 d1 h mix [ k h 1 h - ] \\* +\n;\n\n:m union \\min ;\n:m mat-union \\{ (| $a $b |) a b a .x b .x < select } ;\n:m smooth-union (| list k |) list \\{ k smin } list union k 0 != select ;\n\n:m difference \\{ (| d1 d2 |) d2 neg d1 max } ;\n:m smooth-difference (| list k |) list \\{ swap k sdif } list difference k 0 != select ;\n\n:m intersection \\max ;\n:m smooth-intersection (| list k |) list \\{ k sint } list intersection k 0 != select ;\n\n:m scale (| block factor p |) p factor / *block factor * ;\n\n:m repeat (| block c p |) p .5 c * + c mod .5 c * - *block ;\n\n:m onion (| sdf thickness |) sdf abs thickness - ;\n\n:m store !drop ;\n\n:m apply (| funcs value |) funcs /{ value *_ } ;\n\n:m rotate (| $p angle |)\n        { cos sin }\n            &*angle\n            { angle store }\n            angle is-block?\n        cif\n    apply =[ c s ]\n    [\n        p .x c * p .y s * -\n        p .x s * p .y c * +\n    ]\n;\n\n:m scoped (| block p |) p *block ;\n\n:m round .5 + floor ;\n\n:m noise-permute (| x |)\n\tx 34 * 1 + x * 289 mod\n;\n\n:m pnoise-fade (| t |)\n\tt 6 * 15 - t * 10 + t * t * t *\n;\n\n: pnoise-2d (| v |)\n\tv .xyxy floor [ 0 0 1 1 ] + 289 mod =Pi\n\tv .xyxy fract [ 0 0 1 1 ] - =Pf\n\n\tPi .xzxz noise-permute Pi .yyww + noise-permute =>i\n\ti 41 / fract 2 * 1 - =gx\n\tgx abs .5 - =gy\n\tgx !round - =gx\n\n\t[ gx .x gy .x ] =>g00\n\t[ gx .y gy .y ] =>g10\n\t[ gx .z gy .z ] =>g01\n\t[ gx .w gy .w ] =>g11\n\n\tgx gx * gy gy * + sqrt inversesqrt =norm\n\tg00 norm .x * Pf .xy dot =>n00\n\tg10 norm .z * Pf .zy dot =>n10\n\tg01 norm .y * Pf .xw dot =>n01\n\tg11 norm .w * Pf .zw dot =>n11\n\n\tPf .xy pnoise-fade =fade_xy\n\t[ n00 n01 ] [ n10 n11 ] fade_xy .x mix =n_x\n\tn_x .x.y fade_xy .y mix 2.3 *\n;\n\n: map-scene (| p |)\n    [ p length .45 p 75 * sin \\+ * - 0 ]\n;\n\n: diffuse-mat (| p mat |)\n    [ 1 p 10 * [ 3 2 ] time .5 * rotate + 2 * pnoise-2d 0 ] p !pnoise-2d .5 * + length 100 * 1 + sin abs *\n;\n\n{ (| p |) p !length sin time 3 / p length + cos + rotate } real-position scoped =real-position\n\nreal-position map-scene =[ dist mat ]\n\nreal-position mat diffuse-mat =color\n\n0.015 0 dist smoothstep =smooth\n\n[ color smooth * 1 ] ->fragColor\n*/\n\nvec2 map_scene_vec2_vec2(vec2 arg_0);\nfloat pnoise_2d_float_vec2(vec2 arg_0);\nvec3 diffuse_mat_vec3_float_vec2(vec2 arg_1, float arg_0);\n\nvec2 map_scene_vec2_vec2(vec2 arg_0) {\n\tvec2 tmp_1;\n\ttmp_1 = sin((arg_0) * (75.));\n\treturn vec2((length(arg_0)) - ((0.45) * (((tmp_1).x) + ((tmp_1).y))), 0.);\n}\n\nfloat pnoise_2d_float_vec2(vec2 arg_0) {\n\tvec4 Pi;\n\tvec4 Pf;\n\tvec4 gx;\n\tvec4 gy;\n\tvec4 norm;\n\tvec2 fade_xy;\n\tvec2 n_x;\n\tPi = mod((floor((arg_0).xyxy)) + (vec4(0., 0., 1., 1.)), 289.);\n\tPf = (fract((arg_0).xyxy)) - (vec4(0., 0., 1., 1.));\n\tgx = ((fract((mod(((((mod(((((Pi).xzxz) * (34.)) + (1.)) * ((Pi).xzxz), 289.)) + ((Pi).yyww)) * (34.)) + (1.)) * ((mod(((((Pi).xzxz) * (34.)) + (1.)) * ((Pi).xzxz), 289.)) + ((Pi).yyww)), 289.)) / (41.))) * (2.)) - (1.);\n\tgy = (abs(gx)) - (0.5);\n\tgx = (gx) - (floor((gx) + (0.5)));\n\tnorm = inversesqrt(sqrt(((gx) * (gx)) + ((gy) * (gy))));\n\tfade_xy = ((((((((Pf).xy) * (6.)) - (15.)) * ((Pf).xy)) + (10.)) * ((Pf).xy)) * ((Pf).xy)) * ((Pf).xy);\n\tn_x = mix(vec2(dot((vec2((gx).x, (gy).x)) * ((norm).x), (Pf).xy), dot((vec2((gx).z, (gy).z)) * ((norm).y), (Pf).xw)), vec2(dot((vec2((gx).y, (gy).y)) * ((norm).z), (Pf).zy), dot((vec2((gx).w, (gy).w)) * ((norm).w), (Pf).zw)), (fade_xy).x);\n\treturn (mix((n_x).x, (n_x).y, (fade_xy).y)) * (2.3);\n}\n\nvec3 diffuse_mat_vec3_float_vec2(vec2 arg_1, float arg_0) {\n\tfloat tmp_3;\n\tfloat c;\n\tfloat s;\n\ttmp_3 = (iTime) * (0.5);\n\tc = cos(tmp_3);\n\ts = sin(tmp_3);\n\treturn (vec3(1., pnoise_2d_float_vec2((((arg_1) * (10.)) + (vec2(((3.) * (c)) - ((2.) * (s)), ((3.) * (s)) + ((2.) * (c))))) * (2.)), 0.)) * (abs(sin(((length((arg_1) + ((pnoise_2d_float_vec2(arg_1)) * (0.5)))) * (100.)) + (1.))));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 real_position;\n\tfloat tmp_0;\n\tfloat c;\n\tfloat s;\n\tvec2 tmp_2;\n\tfloat dist;\n\tfloat mat;\n\tvec3 color;\n\tfloat smoothed;\n\treal_position = (fragCoord / iResolution.xy * 2. - 1.) * vec2(iResolution.x / iResolution.y, 1.0);\n\ttmp_0 = (sin(length(real_position))) + (cos(((iTime) / (3.)) + (length(real_position))));\n\tc = cos(tmp_0);\n\ts = sin(tmp_0);\n\treal_position = vec2((((real_position).x) * (c)) - (((real_position).y) * (s)), (((real_position).x) * (s)) + (((real_position).y) * (c)));\n\ttmp_2 = map_scene_vec2_vec2(real_position);\n\tdist = (tmp_2).x;\n\tmat = (tmp_2).y;\n\tcolor = diffuse_mat_vec3_float_vec2(real_position, mat);\n\tsmoothed = smoothstep(0.015, 0., dist);\n\tfragColor = vec4((color) * (smoothed), 1.);\n}","name":"Image","description":"","type":"image"}]}