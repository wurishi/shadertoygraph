{"ver":"0.1","info":{"id":"dsf3z4","date":"1665733781","viewed":129,"name":"Luma Toon","username":"Empio","description":"Fairly standard toon shader that uses luminance instead of HSV.\nMouse X controls edge thickness.\nMouse Y controls the value required to reach maximum edge.\nMost of the shader could be one pass, it's just split up for readability.","likes":6,"published":1,"flags":32,"usePreview":0,"tags":["toon","multipass"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Blur and Output\n\n// mip blur blends the image to soften the grainy edges\n// that occur where the posterise level changes\n// without losing too much detail\n#define MIP_BLUR\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n\n    #ifdef MIP_BLUR\n    \n    vec3 posterised = vec3(0, 0, 0);\n    float total = 0.0;\n    \n    for (int i = 0; i < 4; i++)\n    {\n        // lower res mips contribute less to the final colour\n        float strength = 1.0 / float(2 << i);\n        posterised += textureLod(iChannel1, uv, float(i)).rgb * strength;\n        total += strength;\n    }\n    \n    // scale the accumulated colour back to 1.0\n    posterised /= total;\n    \n    #else\n    \n    vec3 posterised = texture(iChannel1, uv).rgb;\n    \n    #endif\n    \n    vec3 sobel = texture(iChannel0, uv).rgb;\n    float sobelThreshold = 0.5;\n    \n    // control sobel threshold with mouse Y\n    if (iMouse.z > 0.0)\n        sobelThreshold = iMouse.y / iResolution.y;\n        \n    float sobelStrength = smoothstep(0.0, sobelThreshold, dot(sobel, sobel));\n    \n    vec3 col = mix(posterised, vec3(0, 0, 0), sobelStrength);\n\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XdfGRr","filepath":"/media/a/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm","previewfilepath":"/media/ap/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm","type":"video","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Texture to Buffer\n// stores a selected texture in a buffer\n// this is simply for convenience so that changing the texture here affects every other pass\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    vec3 col = texture(iChannel0, uv).rgb;\n    \n    fragColor = vec4(col, 1.0);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// Sobel Filter\n\nconst vec2 SOBEL_KERNEL[9] = vec2[]\n(\n    vec2(1, 1), vec2(0, 2), vec2(-1, 1),\n    vec2(2, 0), vec2(0, 0), vec2(-2, 0),\n    vec2(1, -1), vec2(0, -2), vec2(-1, -1)\n);\n\nvec3 Sobel(vec2 uv)\n{\n    // distance to travel from current pixel for each sample\n    // affects edge thickness\n    float pixelStep = 1.5;\n    \n    // control pixel step with mouse x\n    if (iMouse.z > 0.0)\n        pixelStep = iMouse.x / iResolution.x * 4.0;\n\n    vec2 pixelSize = pixelStep / iResolution.xy;\n\n    vec3 sx = vec3(0, 0, 0);\n    vec3 sy = vec3(0, 0, 0);\n    \n    for (int y = -1, z = 0; y <= 1; y++)\n    {\n        for (int x = -1; x <= 1; x++, z++)\n        {\n            vec2 offset = vec2(x, y) * pixelSize;\n            vec3 tex = textureLod(iChannel0, uv + offset, 0.0).rgb;\n            vec2 sobel = SOBEL_KERNEL[z];\n            sx += tex * sobel.x;\n            sy += tex * sobel.y;\n        }\n    }\n    \n    return sx * sx + sy * sy;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    vec3 col = Sobel(uv);\n    \n    fragColor = vec4(col, 1.0);\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"// Luma Posterise\n// quantises the colour by its luminance\n// cheaper than RGB to HSV\n\nconst float LUMA_STEPS = 8.0;\n\nfloat Luma(vec3 col)\n{\n    return dot(col, vec3(0.299, 0.587, 0.114));\n}\n\nvec3 Posterise(vec3 col)\n{\n    float luma = Luma(col);\n    float posterise = round(luma * LUMA_STEPS) / LUMA_STEPS;\n    \n    // need to divide by the luma as simply multiplying\n    // by the posterise level would make the image darker\n    float lighting = posterise / luma;\n    \n    // using a squared lighting value to create greater\n    // changes in lighting at higher luminance values\n    return col * lighting * lighting;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    // sampling a lower res lod to 'blobify' the level changes\n    // too much can cause bleeding outside the outline\n    vec3 col = Posterise(textureLod(iChannel0, uv, 1.5).rgb);\n    \n    fragColor = vec4(col, 1.0);\n}","name":"Buffer C","description":"","type":"buffer"}]}