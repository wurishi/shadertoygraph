{"ver":"0.1","info":{"id":"4ty3zh","date":"1472941283","viewed":108,"name":"[OLD] Ray-Marching","username":"Sabouh","description":"An exemple of ray-marching\nScene contains 3 planes and 2 spheres\nYou can move around using your mouse","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*Inspired by inigo quilez's articles \n https://iquilezles.org/articles/distfunctions\n + Romain Vergne's lectures http://maverick.inria.fr/~Romain.Vergne/blog/\n Shader : Ray-Marching\n Author : Sabouh\n*/\n \n//to get a higher float precision\nprecision highp float;\nconst float PI = 3.1415926535897932384626433832795;\nconst int PLANE_NB = 3;\nconst int SPHERE_NB = 2;\nconst int OBJ_NB = PLANE_NB + SPHERE_NB;\nconst int MAX_NB = 10;\nconst float MAX_VALUE = 100.;\nconst int MAX_INT_VALUE = 100;\nconst vec4 background = vec4(1.,1.,1.,1.);\n\n//*******************************Tools**************************\n//Structures definition\n\n//MarchingPack\nstruct MarchingPack{\n\tfloat dist;\n\tfloat index;\n\tbool hit;\n\t\n};\n\n//Ray\nstruct Ray{\n\tvec3 o; //origin\n\tvec3 d; //direction\n};\n\n//Camera\nstruct Camera{\n\tvec3 e;//eye\n    vec3 r;//right\n    vec3 u;//up\n    vec3 v;//view\n\t\n};\n\nstruct Color{\n\tvec4 c;\n};\n\n//Plane\nstruct Plane{\n\tvec3 n; //normal\n\tfloat d; //offset\n};\n\n//Sphere\nstruct Sphere{\n\tvec3 c; //center\n\tfloat r; //rayon\n};\n\n\n//Distance operations\n\n//union\nvec2 opU(vec2 d1,vec2 d2){\n\treturn d1.x<d2.x ? d1 : d2; //if d1.x < d2.x return d1 else d2\n}\n\n//substraction\nfloat opS(float d1, float d2){\n\treturn max(-d1,d2);\n}\n\n//intersection\nfloat opI(float d1,float d2){\n\treturn max(d1,d2);\n}\n\n\n//Init\nvec4 getColor(float index){\n\tif(index == 1.){\n\t\treturn vec4(0.,1.,1.,1.); //cyan\n\t}else if(index == 2.){\n\t\treturn vec4(0.,1.,0.,1.); //green\n\t}else if(index == 3.){\n\t\treturn vec4(0.,0.,1.,1.); //blue\n\t}else if(index == 4.){\n\t\treturn vec4(1.,0.,0.,1.); //red\n\t}else if(index == 5.){ \n\t\treturn vec4(1.,1.,0.,0.); //yellow\n\t}else{\n\t\treturn background;//ERROR WHITE\n\t\t\n\t}\n}\n\nvec4 createSphere(vec3 c, float r, float phi, float teta){\n\tfloat x,y,z;\n\tx = c.x + r*sin(phi)*cos(teta);\n\ty = c.y + r*sin(phi)*sin(teta);\n\tz = c.z + r*cos(phi);\n    return vec4(x,y,z,r);\n    \n}\n\nvec4 getObject(float index){\n    vec4 res ;\n\tif(index == 1.){\n\t\tres =  vec4(0.,0.,1.,0.); //Plan (x,y)\n\t}else if(index == 2.){\n\t\tres = vec4(1.,0.,0.,0.); //Plan (y,z)\n\t}else if(index == 3.){\n\t\tres = vec4(0.,1.,0.,0.); //Plan (x,z)\n\t}else if(index == 4.){;\n\t\tres = createSphere(vec3(2.,2.,2.),1., PI/2., PI/2.*iTime); \n\t}else if(index == 5.){ \n\t\tres = createSphere(vec3(2.,2.,2.), 0.8,PI/2.*iTime, PI); \n\t}else{\n\t\tvec4 res = vec4(MAX_VALUE,MAX_VALUE,MAX_VALUE,MAX_VALUE);//ERROR \n\t\t\n\t}\t\n    return res;\n}\n\n\nfloat fPlane(Ray r,float t,vec4 n){\n    vec3 norma = normalize(n.xyz);\n    vec3 norm = n.xyz;\n    vec3 pos = r.o +r.d*t;\n    vec3 Q = norma*n.w ; //Q is on Plane\n    \n    if(dot(r.d,norm ) == 0.){\n       if(dot(r.o-Q,norm)==0.){\n        \treturn 0.;\n       }else{\n        \treturn MAX_VALUE;\n       }\n    }else{\n        if(dot(Q-r.o,norm)  /dot(r.d,norm) < 0.){\n            return MAX_VALUE;\n        }else if(dot(Q-pos,norm) == 0.){\n            return 0.;\n        }else{\n    \t\treturn  ( dot(Q-r.o,norm)  /dot(r.d,norm) ) -t;\n        }\n    }\n        \n}\n\nfloat fSphere(Ray r, float t,vec4 o){\n    vec3 pos = r.o+r.d*t;\n    if(dot(o.xyz-pos,r.d) >=0.){\n            return distance(o.xyz,pos) - o.w ;\n    }else{\n        if(length(o.xyz-pos) <= o.w ){\n            return distance(o.xyz,pos) - o.w ;\n        }else{\n            return MAX_VALUE;\n        }\n    }\n}\n\nvec2 map(Ray r,float t){\n\tvec2 res =  vec2(  fPlane(r,t,getObject(1.)  ),1.) ;\n\tfor(int i = 2;i<= OBJ_NB;i++){\n\t\tif(i<=PLANE_NB){\n\t\t\tres = opU(res, vec2(  fPlane(r,t,getObject(float(i))) ,float(i)) );\n\t\t}else{\n\t\t\tres = opU(res, vec2( fSphere(r,t,getObject(float(i)) ),float(i)) );\t\t\n\t\t}\n\t}\n\treturn res;\n}\n\nvec4 displayColor(vec3 pos,float dist, float index,float D){\n\t\n\t\n    if(mod(iTime,3.) <1.){\n    \t//color map\n\t\treturn getColor(index);\n    }else if(mod(iTime,3.) <2. ){\n    \t//height map\n        float h = dist/(D);\n     \treturn vec4(h,h,h,1.);\n    }else{\n    \t//normal map\n    \tif(index <= float(PLANE_NB)){\n        \treturn vec4((getObject(index)).xyz,1.0) ;\n    \t}else{\n        \tvec3 n = pos - getObject(index).xyz;\n\t\t\treturn vec4(n,1.0);\n    \t}\n    }\n\t\n}\n\n//ray Marching Algorithme\nMarchingPack rayM(Ray r){\n\t\n\tfloat j;\n\tfloat t = 0.00;\n\tvec2 d;\n\tfloat epsilon = 0.002;\n\tvec3 pos;\n\tfor(int i = 0; i< MAX_INT_VALUE;i++){\n        pos = r.o+ r.d*t;\n\t\td = map(r,t);\n\t\t\n        if( d.x <= epsilon){\n\t\t\tMarchingPack mp = MarchingPack(t,d.y,true);\n\t\t\treturn mp;\n        }\n        \n\t\t\n\t\tt = t + d.x;\t\n\t}\n    \n\tMarchingPack mp = MarchingPack(t,d.y,false);\n\treturn mp;\t\n\t\n\t\n}\n//RayMarching\nvec4 rayMarching(vec2 fragCoord){\n\t//cast a ray w/ camera\n\t\n\t//(x,y) in range [-1;1] \n\tfloat x = (2.*fragCoord.x - iResolution.x )/iResolution.x;\n\tfloat y = (2.*fragCoord.y - iResolution.y )/iResolution.y;\n    \n\tfloat xMouse = (2.*iMouse.x - iResolution.x )/iResolution.x;\n\tfloat yMouse = (2.*iMouse.y - iResolution.y )/iResolution.y;\n\t\n\t//camera\n\tCamera c;\n    vec3 u1;\n\t//c.e = vec3(xMouse,yMouse,-2.);//mouse\n\tc.e = vec3(xMouse*10.,yMouse*10.,5.);//mouse\n\tc.v = normalize(-c.e);\n\tu1 = vec3(0.,1.,0.);\n\tc.r = normalize(cross(c.v,u1));\n\tc.u = normalize(cross(c.r,c.v));\n\t\n\t//Ray\n\tRay r;\n\tfloat D = 1./tan(PI/4.);\n\tr.o = c.e;\n\tvec3 rd = x*c.r + y *c.u+ D*c.v;\n\tr.d = normalize(rd);\n\t\n\tMarchingPack rmp = rayM(r);\n    vec3 pos = r.o+r.d*rmp.dist;\n\tif(rmp.hit){\n\t\treturn displayColor(pos,rmp.dist,rmp.index,c.e.z*2.);\n\t}else{\n\t\treturn background;\n\t}\n    \n    \n}\n\n\n\n//************************Application********************************************\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\t  \n\tfragColor = rayMarching(fragCoord);\n    \n}","name":"Image","description":"","type":"image"}]}