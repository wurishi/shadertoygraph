{"ver":"0.1","info":{"id":"dtBSDt","date":"1676762347","viewed":93,"name":"hexagon sampler","username":"jperl","description":"this is for sampling in a hexagonally-indexed grid","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["2d"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord)/iResolution.x;\n    float SCALE = 400.f;\n    \n    vec2 xy = uv * SCALE;\n\n    // grid color\n    //vec2 sub_xy = mod(xy, vec2(1.0f));\n    //vec3 col = vec3(sub_xy.x, 0.0f, sub_xy.y);\n    \n    // hexagon props\n    float h = 40.f; // height\n    float a = 1.1f; // aspect ratio\n    float w = a * h; // width\n    float c = w - 0.5f * h; // width of central rectangular portion\n    \n    // width of subtile\n    int wc = int(c) + int(w - c) / 2;\n    // height of subtile\n    int hc = int(h) / 2;\n    \n    // sampled position\n    int xh = int(xy.x); // SCALE * iMouse.x / iResolution.x;\n    int yh = int(xy.y); // SCALE * iMouse.y / iResolution.x;\n    \n    \n    \n    // x-tile index\n    int ig = xh/wc;\n    // x-tile is odd\n    int uo = ig & 1;\n    \n    // y-tile index\n    int jg = yh/hc;\n    // y-tile is odd\n    int vo = jg & 1;\n    \n    \n    // x-offset relative to start of this tile\n    int ui = xh - wc * ig;\n    \n    // y-offset relative to start of this tile\n    int vj = yh - hc * jg;\n    \n    // y-offset is below the lower-left slope of hexagon in this tile\n    int ao = (ui < (hc - vj - 1) / 2) ? 1 : 0;\n\n    // y-offset is below the upper-left slope of hexagon in this tile\n    int bo = (ui < vj / 2) ? 1 : 0;\n    \n    // hexagon x-index is even\n    bool xeven = false;\n    \n    /* longform with branching\n    if (vo == 0.0f && uo == 0.0f) {\n        xeven = (ao == 0.0f);\n    }\n    \n    if (vo == 0.0f && uo == 1.0f) {\n        xeven = (bo == 1.0f);\n    }\n    \n    if (vo == 1.0f && uo == 1.0f) {\n        xeven = (ao == 1.0f);\n    }\n    \n    if (vo == 1.0f && uo == 0.0f) {\n        xeven = (bo == 0.0f);\n    }\n    */\n    \n    // integer representations\n    int uoi = int(uo);\n    int voi = int(vo);\n    int aoi = int(ao);\n    int boi = int(bo);\n    \n    // boolean logic with less branching\n    \n    /*\n    if (!bool(voi)) {\n        xeven = !bool(uoi | aoi) || bool(uoi & boi);\n    }\n    \n    if (bool(voi)) {\n        xeven = bool(uoi & aoi) || !bool((uoi | boi));\n    }\n    */\n    \n    // no branching\n    \n    // xeven = (!bool(voi) && (!bool(uoi | aoi) || bool(uoi & boi))) || (bool(voi) && (bool(uoi & aoi) || !bool((uoi | boi))));\n    \n    // conditional looks nicer\n    xeven = bool(voi) ? (bool(uoi & aoi) || !bool(uoi | boi)) : (!bool(uoi | aoi) || bool(uoi & boi));\n    \n    // hexagon x-index\n    int i;\n    // hexagon y-index\n    int j;\n    \n    // width of two tiles (column period)\n    int rw = 2 * wc;\n    \n    // height of two tiles is just height of hexagon (row period)\n    int rh = int(h);\n    \n    if (xeven) {\n        i = 2 * (xh / rw);\n        j = yh / rh;\n    } else {\n        i = 2 * ((wc + xh) / rw) - 1;\n        j = (hc + yh) / rh;\n    }\n    \n    vec3 col = vec3(float(i) / 10.f, 0.0f, float(j) / 10.f);\n\n    //if (abs(xy.x - xh) < 5.0f && abs(xy.y - yh) < 5.f) {\n    //    col = vec3(0.0f);\n    //}\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}