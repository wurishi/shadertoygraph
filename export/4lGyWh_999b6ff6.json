{"ver":"0.1","info":{"id":"4lGyWh","date":"1536041748","viewed":249,"name":"Pipe Maze","username":"nr4","description":"Maze from tiled pipes. 2D for simplicity. Working on drawing connected pipes in the same color :)","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["2d","maze","tiles"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/* Pipe Maze\n * Copyright (C) 2018  Alexander Kraus <nr4@z10.info>\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <https://www.gnu.org/licenses/>.\n */\n\n// Update 1: Simplified line(.) by using dot product with normalized orthogonal projection\n\nconst vec3 c = vec3(1.,0.,-1.);\nconst float pi = acos(-1.);\n\n// Hash function\nfloat rand(vec2 a0)\n{\n    return fract(sin(dot(a0.xy, vec2(12.9898,78.233)))*43758.5453);\n}\n\n// Distance to line segment\nfloat line(vec2 x, vec2 p1, vec2 p2, float w)\n{\n    vec2 d = normalize(p2-p1);\n    return abs(dot(x-p1, d.yx*c.zx))-w;\n}\n\n// Distance to circle\nfloat circle(vec2 x, float r)\n{\n    return length(x)-r;\n}\n\n// Distance to stroke for any object\nfloat stroke(float d, float w)\n{\n    return abs(d)-w;\n}\n\n// Add objects to scene with proper antialiasing\nvec4 add(vec4 sdf, vec4 sda)\n{\n    return vec4(\n        min(sdf.x, sda.x), \n        mix(sda.gba, sdf.gba, smoothstep(-1.5/iResolution.y, 1.5/iResolution.y, sda.x))\n    );\n}\n\n// Check if specific connector near y is connected\nvec2 connected(vec2 y, vec2 i)\n{\n    float d1 = .25*pi, d2 = .5*pi,\n        p0 = atan(y.y,y.x),\n        phi = mod(p0+d1, d2)-d1, \n        j = mod(round((p0-phi)/d2), 4.),\n        edge = rand(mod(i,100.)+.5*j);\n    return vec2(j, edge);\n}\n\n// Distance to tiled pipes\nvec4 pipes(vec2 x, float d)\n{\n    x += .25*iTime*c.yx;\n    float cp = .5, co = 0.;\n    \n    // Determine cell coordinates and cell index\n    vec2 y = mod(x, d)-.5*d,\n        i = round((x-y)/d + .5),\n        k = connected(y,i);\n    vec4 sdf = c.xyyy;\n    \n    // Compute pipes\n    if(round(mod(i.x+i.y,2.)) == 0.)\n    {\n        // Half of them can be random!\n        if(k.y >= cp) co = 1.;\n    }\n    else\n    {\n        // Choose orientation and number of connectors matching to neighbours\n        vec2 top = connected(c.yz, i+c.yx),\n            right = connected(c.zy, i+c.xy),\n            bottom = connected(c.yx, i+c.yz),\n            left = connected(c.xy, i+c.zy);\n        if(\n            ((bottom.y >= cp) && (k.x == 3.)) ||\n            ((left.y >= cp) && (k.x == 2.)) ||\n            ((top.y >= cp) && (k.x == 1.)) ||\n            ((right.y >= cp) && (k.x == 0.))\n        )\n            co = 1.;\n    }\n\n    // Draw\n    if(co == 1.)\n    \tsdf = add(sdf, vec4(line(y, c.yy, .5*d*vec2(cos(.5*k.x*pi), sin(.5*k.x*pi)), .175*d), .2*c.xxx));\n    sdf = add(sdf, vec4(circle(y, .25*d), .2*c.xxx));\n    \n    return add(sdf, vec4(stroke(sdf.x, .05*d), c.xxx));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord/iResolution.yy-.5;\n    vec4 s = pipes(uv, .025);\n\tvec3 col = s.gba*smoothstep(1.5/iResolution.y, -1.5/iResolution.y, s.x);\n\tfragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}