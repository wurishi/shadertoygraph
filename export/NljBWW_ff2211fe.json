{"ver":"0.1","info":{"id":"NljBWW","date":"1692813015","viewed":202,"name":"Dune field","username":"kajbostrom","description":"Dunes are tricky, I gave up on emulating physical effects closer (like critical slope / asymmetric ridges)\nMouse controls \"wind angle\"\nResolution sensitivity should be fixed now, hopefully","likes":26,"published":1,"flags":32,"usePreview":0,"tags":["noise","terrain","filter","curl","gabor","dunes","desert"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Heightfield rendering - adapted from TekF @ https://www.shadertoy.com/view/WtlSR7\n\nconst float heightScale = .05;\nconst int numSlices = 128;\nconst float cameraPitch = .4;\nconst float cameraDistance = 2.2;\nconst vec3 cameraVelocity = vec3(-.1,0,.03); // this really helps hide aliasing problems\nconst float zoom = 1.4;\n/*\nconst float cameraPitch = .3;\nconst float cameraDistance = .7;\nconst float zoom = .8;\n*/\n\nconst vec3 lightDirection = vec3(-3,1,2);\nconst vec3 lightTint = vec3(1);\nconst vec3 shadeTint = vec3(.06,.08,.13)*1.5;\n\nconst vec3 baseColour = vec3(0.63, 0.36, 0.23);\n\nvec4 Sample( vec2 uv )\n{\n    uv = uv*vec2(iResolution.y/iResolution.x,1)+.5;\n    vec4 tap = texture(iChannel0,uv);\n    if ( min(uv.x,uv.y) < 0. || max(uv.x,uv.y) > 1. ) tap.x = -1.;\n\treturn tap;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec3 cameraTarget = vec3(0,-heightScale*.3,0);\n    float cameraOrbit = 0.3 + iTime*0.2;\n    vec3 cameraPosition =\n        cameraTarget + (\n            vec3(cos(cameraOrbit),0,sin(cameraOrbit))*cos(cameraPitch) + vec3(0,sin(cameraPitch),0)\n        )*cameraDistance;\n\n    vec2 screenPosition = (fragCoord-iResolution.xy*.5)/iResolution.x;\n    vec3 ray = vec3(screenPosition,1.2*zoom);\n    \n    vec3 cameraK = normalize(cameraTarget-cameraPosition);\n    vec3 cameraI = normalize(cross(vec3(0,1,0),cameraK));\n    vec3 cameraJ = cross(cameraK,cameraI);\n\n    ray = ray.x*cameraI + ray.y*cameraJ + ray.z*cameraK;\n    ray = normalize(ray);\n\n    fragColor = vec4(.5);\n    vec3 lightDir = normalize(lightDirection);\n    float sampleDistance = .7/iResolution.y;\n    vec2 sampleOffset = vec2(0,sampleDistance);\n    vec4 prevTap = vec4(0);\n    \n    for ( int i=0; i < numSlices; i++ )\n    {\n        float f = 1. - float(i)/float(numSlices-1);\n        \n        // intersect ray with horizontal plane at top of height field\n        float t = ((f-.5)*heightScale-cameraPosition.y)/ray.y;\n        vec3 position = cameraPosition + ray*t;\n\n        vec2 uv = position.xz;\n\n\t\tvec4 tap = Sample(uv);\n        \n        if ( tap.x > f )\n        {\n            if (prevTap.x == -1.) {\n                fragColor.rgb = vec3(0.);\n            } else {\n                // estimate dot product with surface normal\n                vec2 positionX = position.xz + sampleOffset.yx;\n                vec2 positionZ = position.xz + sampleOffset.xy;\n                vec2 uvX = positionX;\n                float heightX = Sample(uvX).x;\n                vec2 uvZ = positionZ;\n                float heightZ = Sample(uvZ).x;\n\n                float height = tap.x * heightScale;\n                heightX *= heightScale;\n                heightZ *= heightScale;\n\n                vec3 n = normalize(\n                        cross( vec3(positionZ,heightZ).xzy - vec3(position.xz,height).xzy,\n                               vec3(positionX,heightX).xzy - vec3(position.xz,height).xzy )\n                    );\n\n                float light = max(0.,dot(n,lightDir));\n\n                vec3 shade = shadeTint*mix(.3,1.,n.y)*pow(fragColor.a,.25);\n\n                vec3 ground = baseColour;\n                fragColor.rgb = ground;\n\n                fragColor.rgb *= mix( shade, lightTint, light );\n                }\n            break;\n        } else {\n            prevTap = tap;\n        }\n    }\n    \n    fragColor.rgb = pow(fragColor.rgb,vec3(1./2.2));\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Anisotropic noise with spatially varying frequency and curl-based domain warping\n\n#define CURL 1\n\n#define MIN_FREQ 0.75\n\n#define M_PI 3.1415926536\n#define CELL_SIZE 60.\n// Number of gabor splats per grid cell\n#define SPLATS 8\n\n// Kernel settings\n#define mouseAngle ((.125+iMouse.y/768.0)*2.*M_PI)\n#define w0 vec2(cos(mouseAngle),sin(mouseAngle))\n\n#define SCROLL vec2(40., 20.)\n\nconst float kernelTrunc = exp(-M_PI);\nconst float kernelRenorm = 1.0 / (1.0 - kernelTrunc);\n\nconst float maxWavelength = 1.0/MIN_FREQ;\nconst float minWavelength = maxWavelength/8.;\n\n// Gabor noise kernel\nfloat h(vec2 x, float f) {\n    float r = length(x);\n    return kernelRenorm * max(0., exp(-M_PI*r*r) - kernelTrunc) * cos(2.*M_PI*f*dot(x, w0));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 U)\n{\n\n    U += iTime*SCROLL;\n    \n    float f = 0.;\n    \n    /////////////////////////\n    // Shallow FBM for curl noise + Gabor frequency variation\n    #if CURL\n    vec2 uv = U/iResolution.y;\n    float s = 1.0;\n    float a = 0.02;\n    float LACUNARITY = 1.6;\n    for (int i = 0; i < 6; ++i) {\n        vec4 n = bccNoiseDerivatives_XYZ(vec3(s*uv, s*2.));\n        // Domain warping based on curl field\n        uv += a*vec2(-n.y, n.x);\n        // value-based attenuation to spatially vary peak turbulence frequency\n        a *= n.w*0.4+0.5;\n        s *= LACUNARITY;\n        // Accumulate ridged noise value to control Gabor frequency\n        f += n.w*n.w/s;\n    }\n    U = uv * 640.0;\n    #endif\n    //\n    /////////////////////////\n    \n    f = smax(MIN_FREQ, f*8., 8.);\n    \n    // Gabor noise\n    // adapted from VinceTavernier's tilable Gabor noise @ https://www.shadertoy.com/view/ltByWc\n    \n    noise_prng prng;\n\n\tivec2 ccell = ivec2(U/CELL_SIZE);\n\n    float v = 0.;\n    \n    ivec2 disp;\n    int D = 1;\n    for (disp.x = -D; disp.x <= D; disp.x++)\n    {\n        for (disp.y = -D; disp.y <= D; disp.y++)\n        {\n            // The current cell being considered\n            ivec2 cell = ccell + disp;\n            // Center of this cell in pixels\n            vec2 center = CELL_SIZE*(vec2(cell) + .5);\n            // Seed the random generator for the current cell\n            uint seed = hash(hash(uint(cell.x)) + uint(cell.y+1));\n            noise_prng_srand(prng, seed);\n            // Loop over splats\n            for (int i = 0; i < SPLATS; i++)\n            {\n                // The location of this splat\n                vec2 loc = center + CELL_SIZE/2. * noise_prng_rand2_1_1(prng);\n                // The weight of this splat, [-1, 1]\n                float w = 2.*noise_prng_uniform_0_1(prng)-1.;\n                \n                // Distance to this splat\n                vec2 x = (U - loc)/CELL_SIZE;\n                v += w * h(x, f);\n            }\n        }\n    }\n    \n    float wavelength = 1.0/f;\n    \n    float heightScale = (wavelength - minWavelength)/(maxWavelength - minWavelength);\n    heightScale = smax(0., heightScale, 32.);\n\n    // Normalize by variance and map to [0, 1]\n    v = .5*v/(2.*sqrt(float(SPLATS)*.25*exp(-2.*M_PI*f*f/(CELL_SIZE*CELL_SIZE))))+.5;\n    v *= heightScale;\n    fragColor = vec4(smax(0., smin(1., v, 8.), 8.));\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"////////////////// K.jpg's Smooth Re-oriented 8-Point BCC Noise //////////////////\n//////////////////// Output: vec4(dF/dx, dF/dy, dF/dz, value) ////////////////////\n\n// Borrowed from Stefan Gustavson's noise code\nvec4 permute(vec4 t) {\n    return t * (t * 34.0 + 133.0);\n}\n\n// Gradient set is a normalized expanded rhombic dodecahedron\nvec3 grad(float hash) {\n    \n    // Random vertex of a cube, +/- 1 each\n    vec3 cube = mod(floor(hash / vec3(1.0, 2.0, 4.0)), 2.0) * 2.0 - 1.0;\n    \n    // Random edge of the three edges connected to that vertex\n    // Also a cuboctahedral vertex\n    // And corresponds to the face of its dual, the rhombic dodecahedron\n    vec3 cuboct = cube;\n    cuboct[int(hash / 16.0)] = 0.0;\n    \n    // In a funky way, pick one of the four points on the rhombic face\n    float type = mod(floor(hash / 8.0), 2.0);\n    vec3 rhomb = (1.0 - type) * cube + type * (cuboct + cross(cube, cuboct));\n    \n    // Expand it so that the new edges are the same length\n    // as the existing ones\n    vec3 grad = cuboct * 1.22474487139 + rhomb;\n    \n    // To make all gradients the same length, we only need to shorten the\n    // second type of vector. We also put in the whole noise scale constant.\n    // The compiler should reduce it into the existing floats. I think.\n    grad *= (1.0 - 0.042942436724648037 * type) * 3.5946317686139184;\n    \n    return grad;\n}\n\n// BCC lattice split up into 2 cube lattices\nvec4 bccNoiseDerivativesPart(vec3 X) {\n    vec3 b = floor(X);\n    vec4 i4 = vec4(X - b, 2.5);\n    \n    // Pick between each pair of oppposite corners in the cube.\n    vec3 v1 = b + floor(dot(i4, vec4(.25)));\n    vec3 v2 = b + vec3(1, 0, 0) + vec3(-1, 1, 1) * floor(dot(i4, vec4(-.25, .25, .25, .35)));\n    vec3 v3 = b + vec3(0, 1, 0) + vec3(1, -1, 1) * floor(dot(i4, vec4(.25, -.25, .25, .35)));\n    vec3 v4 = b + vec3(0, 0, 1) + vec3(1, 1, -1) * floor(dot(i4, vec4(.25, .25, -.25, .35)));\n    \n    // Gradient hashes for the four vertices in this half-lattice.\n    vec4 hashes = permute(mod(vec4(v1.x, v2.x, v3.x, v4.x), 289.0));\n    hashes = permute(mod(hashes + vec4(v1.y, v2.y, v3.y, v4.y), 289.0));\n    hashes = mod(permute(mod(hashes + vec4(v1.z, v2.z, v3.z, v4.z), 289.0)), 48.0);\n    \n    // Gradient extrapolations & kernel function\n    vec3 d1 = X - v1; vec3 d2 = X - v2; vec3 d3 = X - v3; vec3 d4 = X - v4;\n    vec4 a = max(0.75 - vec4(dot(d1, d1), dot(d2, d2), dot(d3, d3), dot(d4, d4)), 0.0);\n    vec4 aa = a * a; vec4 aaaa = aa * aa;\n    vec3 g1 = grad(hashes.x); vec3 g2 = grad(hashes.y);\n    vec3 g3 = grad(hashes.z); vec3 g4 = grad(hashes.w);\n    vec4 extrapolations = vec4(dot(d1, g1), dot(d2, g2), dot(d3, g3), dot(d4, g4));\n    \n    // Derivatives of the noise\n    vec3 derivative = -8.0 * mat4x3(d1, d2, d3, d4) * (aa * a * extrapolations)\n        + mat4x3(g1, g2, g3, g4) * aaaa;\n    \n    // Return it all as a vec4\n    return vec4(derivative, dot(aaaa, extrapolations));\n}\n\n// Rotates domain, but preserve shape. Hides grid better in cardinal slices.\n// Good for texturing 3D objects with lots of flat parts along cardinal planes.\nvec4 bccNoiseDerivatives_XYZ(vec3 X) {\n    X = dot(X, vec3(2.0/3.0)) - X;\n    \n    vec4 result = bccNoiseDerivativesPart(X) + bccNoiseDerivativesPart(X + 144.5);\n    \n    return vec4(dot(result.xyz, vec3(2.0/3.0)) - result.xyz, result.w);\n}\n\n//////////////////////////////// End BCC noise code ////////////////////////////////\n\n\nstruct noise_prng\n{\n    uint x_;\n};\n    \nvoid noise_prng_srand(inout noise_prng this_, in uint s)\n{\n    this_.x_ = s;\n}\n\nuint noise_prng_rand(inout noise_prng this_)\n{\n    return this_.x_ *= 3039177861u;\n}\n\nfloat noise_prng_uniform_0_1(inout noise_prng this_)\n{\n    return float(noise_prng_rand(this_)) / float(4294967295u);\n}\n\nvec2 noise_prng_rand2_1_1(inout noise_prng this_)\n{\n    return -1.+2.*vec2(noise_prng_uniform_0_1(this_),\n                       noise_prng_uniform_0_1(this_));\n}\n\nuint hash(uint x)\n{\n    x = ((x >> 16) ^ x) * 0x45d9f3bu;\n    x = ((x >> 16) ^ x) * 0x45d9f3bu;\n    x = ((x >> 16) ^ x);\n    return x;\n}\n\nfloat smin(float a, float b, float k)\n{\n    return -log2(exp2(-k*a) + exp2(-k*b))/k;\n}\n\nfloat smax(float a, float b, float k)\n{\n    return log2(exp2(k*a) + exp2(k*b))/k;\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// Morphological filter to sharpen crests\n\n#define K 16\n#define R 0.025\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 p = (R / float(K)) * iResolution.yy/iResolution.xy;\n\t\n    float f = texture(iChannel0, uv).x;\n    \n    float iK = 1.0/float(K);\n    #if 1\n    for (int x = -K; x <= K; ++x) {\n        for (int y = -K; y <= K; ++y) {\n            vec2 d = vec2(x, y);\n            vec2 off = p * d; // striding samples a little is OK since the source is smooth\n            d *= iK;\n            float b = dot(d, d);\n            b *= b;\n            vec4 s = texture(iChannel0, uv + off);\n            f = min(f, s.x + b);\n        }\n    }\n    #endif\n    \n\t\n\tfragColor = vec4(f, f, f, 1.0);\n}","name":"Buffer B","description":"","type":"buffer"}]}