{"ver":"0.1","info":{"id":"ws3yzH","date":"1600372705","viewed":48,"name":"glasstoast","username":"dirkadirkadan","description":"Glass on toast","likes":0,"published":1,"flags":32,"usePreview":0,"tags":["pathtracing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   \tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec4 tex = texture(iChannel0, uv);\n    fragColor = tex.rgba;// / float(iFrame);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define EPS .01\n#define SAMPLES 1.\n#define MAX_DISTANCE 100.\n#define LIGHT_INTENSITY 6.\n#define LIGHT_COLOR vec3(1.);\n#define STEP .399\n\nvec3 ldir = normalize (vec3(-.8, -.7, .1));\nvec3 amb = vec3(.0);\n\n#define ITERATIONS 500\n\n#define FLOOR   \t\t2\n#define FLORETS \t\t3\n#define GLASS\t\t\t4\n\nint matid;\n\nfloat dist_test(float current_min_dist, float test_distance, int mat)\n{\n    float d = current_min_dist;\n    \n    if (test_distance < current_min_dist)\n    {\n        d = test_distance;\n        matid = mat;\n    }\n    \n    return d;\n\n}\n\n\nmat3 material(vec3 p)\n{\n    mat3 m;\n    \n    m[0] = vec3(1.);\n    m[1].x = 0.;\n    m[1].y = 1.;\n    m[1].z = 0.;\n        \n    if (matid == FLOOR)\n    {\n        m[0] = texture(iChannel0, .9*p.xz).rgb;\n        m[1].x = .18;\n        m[1].x = .072990099760925;\n        m[1].y = .565000412293199;\n    }\n        \n    else if (matid == FLORETS)\n    {\n        vec3 green = vec3(0., .7, 0.);\n        vec3 cray = clamp(vec3(sin(p.z+p.x), cos(p.z*3.), sin(p.y*p.z)), .0, 1.);\n        m[0] = mix(green, cray, clamp(sin(8.2*(p.x+p.y)), .0, 1.));\n        m[1].x = 0.;\n        m[1].y = .4999006;\n    }\n    \n    else if (matid == GLASS) {\n        m[0] = vec3(.8999, .999, .89997);\n        m[1].x = .879499970005990099999999980090089998;\n        m[1].y = .1599999899006;\n        m[1].z = .777702;\n    }\n    \n    return m;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0))\n         + min(max(d.x,max(d.y,d.z)),0.0); // remove this line for an only partially signed sdf \n}\n\nfloat glassbox(vec3 z) {\n    z.xz = mod(z.xz, 4.0) - 2.0;\n    vec3 q = abs(z- vec3(0, 0, -2.)) - vec3(1.);\n    return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0) - 0.0;\n}\n\nfloat glassball(vec3 z) {\n    vec3 pos = vec3(0.0, 0.5, 0.0);\n    z.xz = mod(z.xz, 4.0) - 2.0;\n    float r = 1.0;\n    return abs(length(z-pos) - r);\n}\n\n\nfloat de(vec3 z)\n{\n    float flr = z.y + .3 - texture(iChannel0, .9*z.xz).b*.002;\n    float rep = 2.0;\n    //flr = 10.0;\n\n    float tri = 20.0;//(length(z) ) * pow(Scale, -float(n));\n    \n    //float ball = glassball(z);\n    float ball = glassball(z);\n\n    float d = 10000.;\n    d = dist_test(d, tri, FLORETS);\n    d = dist_test(d, flr, FLOOR);\n    d = dist_test(d, ball, GLASS);\n\n    return d;\n}\n\nvec3 norm(vec3 p)\n{\n    float d = de(p);\n    \n    float x = de(vec3(p.x+EPS, p.y, p.z)) - d;\n    float y = de(vec3(p.x, p.y+EPS, p.z)) - d;\n    float z = de(vec3(p.x, p.y, p.z+EPS)) - d;\n\n    return normalize(vec3(x,y,z));\n}\n\n\nvec2 hash2( const float n ) {\n\treturn fract(sin(vec2(n,n+1.))*vec2(43758.5453123));\n}\nvec2 hash2( const vec2 n ) {\n\treturn fract(sin(vec2( n.x*n.y, n.x+n.y))*vec2(25.1459123,312.3490423));\n}\nvec3 hash3( const vec2 n ) {\n\treturn fract(sin(vec3(n.x, n.y, n+2.0))*vec3(36.5453123,43.1459123,11234.3490423));\n}\n\n\nvec2 rv2;\n\n\n#ifndef M_PI\n#define M_PI                (3.1415926535897932384626433832795)\n#endif\n\nvec2 seed;\n\nvec2 rand2n() {\n    seed+=vec2(-1,1);\n\t// implementation based on: lumina.sourceforge.net/Tutorials/Noise.html\n    return vec2(fract(sin(dot(seed.xy ,vec2(12.9898,78.233))) * 43758.5453),\n\t\tfract(cos(dot(seed.xy ,vec2(4.898,7.23))) * 23421.631));\n}\n \nvec3 ortho(vec3 v) {\n    //  See : http://lolengine.net/blog/2013/09/21/picking-orthogonal-vector-combing-coconuts\n    return abs(v.x) > abs(v.z) ? vec3(-v.y, v.x, 0.0)  : vec3(0.0, -v.z, v.y);\n}\n\nvec3 getSampleBiased(vec3  dir, float power) {\n\tdir = normalize(dir);\n\tvec3 o1 = normalize(ortho(dir));\n\tvec3 o2 = normalize(cross(dir, o1));\n\tvec2 r = rand2n();\n\tr.x=r.x*2.*M_PI;\n\tr.y=pow(r.y,1.0/(power+1.0));\n\tfloat oneminus = sqrt(1.0-r.y*r.y);\n\treturn cos(r.x)*oneminus*o1+sin(r.x)*oneminus*o2+r.y*dir;\n}\n \nvec3 getSample(vec3 dir) {\n\treturn getSampleBiased(dir,0.0); // <- unbiased!\n}\n\nvec3 bounce(vec3 rd, vec3 nrm, mat3 material)\n{\n    float reflectance = material[1].x;\n\n    rd = reflect(rd,nrm);\n    rd = reflectance*rd + (1.-reflectance)*getSample(nrm);\n    rd = normalize(rd);\n \n    return rd;\n    return reflect(rd, nrm);\n}\n\nvec3 newRayDirection(vec3 rd, vec3 n, mat3 mat)\n{  \n    float transmission = mat[1].z;\n    float ray_weight = 50.0;\n    float factor = 1.0/(ray_weight+1.0);\n    vec3 refracc = factor*(ray_weight*rd + bounce(-rd, -n, mat));\n    refracc = refract(rd, n, .55);\n    vec3 dir = (1.-transmission)*bounce(rd, n, mat) + transmission * refracc;\n    return dir;   \n}\n\nvec3 computeColor(vec3 origin_color, mat3 material)\n{\n    float transmission = material[1].z;\n    vec3 color = origin_color;\n    color = transmission * 1.0 * origin_color * material[0] + \n        \t(1.0-transmission)*material[0]*origin_color;\n    float albedo = transmission + (1.0-transmission)*material[1].y;\n    return color * 2.0 * albedo;\n}\n\nvec3 computeNewRayPosition(vec3 ro, vec3 pt, vec3 rd, mat3 mat)\n{\n//    return pt;\n  return pt + rd*EPS*64.31;\n}\n\nvoid march(vec3 ro, vec3 rd, vec2 uv, out vec3 col)\n{\n    vec3 orig_ro = ro;\n    float d = 0.;\n    \n    bool hit = false;\n    vec3 pt = orig_ro;\n\n    vec3 lo = vec3(0.);\n    float last_s=10000.0;\n    for (int i = 0; i < ITERATIONS; i++)\n    {\n//        pt = ro + rd * d;\n        \n        float s = de(pt);        \n        float stp = STEP;\n        if (s > last_s ) \n         {\n            stp = .999;\n        }\n        \n        if (s < 20.*EPS) {\n            stp *= .4;\n        }\n\n          last_s = s;\n        \n        d += stp*s;\n        pt = ro+rd*d;\n        \n        if (s < EPS)\n        {\n            if (!hit) lo = LIGHT_INTENSITY * LIGHT_COLOR; hit = true;           \n            mat3 mat = material(pt);            \n            vec3 n = norm(pt);            \n            lo = computeColor(lo, mat);\n\t\t\trd = newRayDirection(rd, n, mat);\n            normalize(rd);\n            ro = computeNewRayPosition(ro, pt, rd, mat);\n            pt = ro;\n\n            lo *= dot(n, rd);\n            d = 0.;\n            \n        }\n        \n        if (s > MAX_DISTANCE)\n        {\n            break;\n        }\n    }\n    \n    float mr = 1.;\n    vec3 sky = vec3(mr, clamp(sqrt(uv.y+.3), 0.4, mr), 1.);\n    vec3 fogclr = vec3(.6);\n                           \n    col = hit ? clamp(amb+lo*clamp(dot(ldir,-rd),0.,10.)*1.,0.,10.) : sky;\n    float final_dist = length(pt-orig_ro);\n    float fog = exp(-pow(final_dist,.3) * 5.2512570555525052);\n    if (hit) col = mix(col, fogclr, fog);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (2.*fragCoord.xy - iResolution.xy)/iResolution.y;\n    \n    rv2 = hash2(iTime);\n  \n    // Time varying pixel color\n    vec3 col = vec3(0.);\n    \n    float blur = .0;\n        \n    vec3 ro = vec3(.5, 1.08, 2.0);\n    vec3 rd = normalize(vec3(uv*(1.-blur)+rv2*blur, -1.));\n\n    vec3 acc = vec3(0.);\n    \n    vec3 prev_col = vec3(0.);\n    \n    float th = -texture(iChannel1, vec2(0.)).x*9.5;\n    th = 0.0;\n    float ct = cos(th);\n    float st = sin(th);\n    mat2 rot = mat2(ct, -st, st, ct);\n    rd.xz = rot * rd.xz;\n    \n    for (int i = 0; i < int(SAMPLES); i++)\n    {\n        prev_col = col;\n\t    seed = uv * (float(i) + iTime + 1.0);\n\t    rv2 = hash2(iTime+float(i)*rv2);\n        march(ro, rd, uv, col);\n\t\tacc += max(prev_col, col);\n    }\n    \n    acc /= SAMPLES;\n    \n    float qual = .99;\n    qual = clamp(qual, 0.01, 0.99999999);\n    \n    vec4 outcol = texture(iChannel1, fragCoord.xy / iResolution.xy) * qual + vec4(acc,0.)* (1.-qual);\n\n    if (iFrame == 0) outcol = vec4(.5);\n\n    fragColor = outcol;\n//    fragColor = vec4(texture(iChannel1, vec2(0.)).z/200.);\n}\n\n\n","name":"Buffer A","description":"","type":"buffer"}]}