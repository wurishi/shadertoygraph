{"ver":"0.1","info":{"id":"msySDW","date":"1682486576","viewed":72,"name":"Orthographic RayMarcher Template","username":"dansh0","description":"Basic raymarching of primitives with orthographic camera to improve my graphics work.\nGoal here is to set up an orthographic raymarcher template for me to be able to fork projects from quickly.\nNot trying to optimize or minify at this point.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","phong","camera","orthographic"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS 10000\n#define MAX_DIST 200.\n#define MIN_DIST 0.0001\n#define DOTS_PER_MM 10.\n#define NORM_EPS 0.001\n#define PI 3.141592\n\n// PARAMS\nfloat scale = 5.; // Geo scale\nfloat cameraDist = 50.; // Camera distance from center\nvec3 objCol = vec3(1.0, 1.0, 1.0); // Base material color\nvec3 lightCol = vec3(1.0, 1.0, 1.0); // Light color\nvec3 lightPos = vec3(50.); // Light source position\nfloat ambiStrength = 0.4; // Ambient light strength\nfloat diffStength = 0.3; // Diffuse light strength\nfloat specStrength = 0.3; // Specular light strength\nfloat specPow = 4.0; // Specular light power (spread)\n\n// MATH TOOLS\n\n// Vector Component Max\nfloat vmax(vec3 vec) {\n\treturn max(max(vec.x, vec.y), vec.z);\n}\n\n// Smooth Max\nfloat smoothMax(float distA, float distB, float factor) {\n    return log(exp(factor * distA) + exp(factor * distB)) / factor;\n}\n\n// Smooth Min\nfloat smoothMin(float distA, float distB, float factor) {\n    return -smoothMax(-distA, -distB, factor);\n}\n\n\n// GEOMETRY\n\n// Box\nfloat distBox(vec3 point, vec3 center, float halfSideLen, float edgeRadius) {\n    vec3 transPoint = (point - center);\n    vec3 cheapDist = abs(transPoint) - (halfSideLen - edgeRadius);\n    return length(max(cheapDist, vec3(0.))) + vmax(min(cheapDist, vec3(0.))) - edgeRadius;\n}\n    \n// Sphere\nfloat distSphere(vec3 point, vec3 center, float radius) {\n    vec3 transPoint = (point - center);\n    return length(transPoint) - radius;\n}\n    \n\n// GEOMETRY COMBINATIONS\n\n// Distance Function Combine\nfloat distCombine( vec3 position ) {\n    \n    // geometry\n    float sphere = distSphere( position, vec3(0.), scale*3.);\n    float box = distBox( position, vec3(0., 0., scale*3.*sin(0.1*iTime)), scale*4.0, scale*0.05);\n    return smoothMax(sphere, box, 0.8);\n    \n}     \n\n    \n// RAY TOOLS\n    \n// Ray March\nfloat marcher(vec3 position, vec3 direction) {\n    float dist = 0.;\n    for (int iStep=0; iStep<MAX_STEPS; iStep++) {\n        float safeMarchDist = distCombine(position);\n        if (safeMarchDist > MIN_DIST && dist < MAX_DIST) {\n            position += safeMarchDist * direction;\n            dist += safeMarchDist;\n        } else {\n            return dist;\n        }\n    }\n    return 0.;\n}\n    \n// Normal Test\nvec3 marchNormal(vec3 position, vec3 direction) {\n    float xChange = marcher(position + vec3(NORM_EPS, 0, 0), direction) - marcher(position - vec3(NORM_EPS, 0, 0), direction);\n    float yChange = marcher(position + vec3(0, NORM_EPS, 0), direction) - marcher(position - vec3(0, NORM_EPS, 0), direction);\n    float zChange = marcher(position + vec3(0, 0, NORM_EPS), direction) - marcher(position - vec3(0, 0, NORM_EPS), direction);\n    return normalize( vec3(xChange, yChange, zChange) );\n}\n\n\n// CAMERA TOOLS\n\n// Orbit Controls\nvec3 orbitControls(float cameraDist, vec2 sphericalAngles) {\n    // spherical angles is x = theta -PI to PI and y = phi -PI/2 to PI/2\n    float xPos = cameraDist * cos(sphericalAngles.x) * sin(sphericalAngles.y);\n    float zPos = cameraDist * sin(sphericalAngles.x) * sin(sphericalAngles.y);\n    float yPos = cameraDist * cos(sphericalAngles.y);\n    return vec3(xPos, yPos, zPos);  \n}    \n\n\n// Camera Fragment Position (Orthographic)\nvec3 orthoFragPos(vec3 cameraPos, vec3 cameraDir, vec2 cameraSize, vec2 fragCoord) {\n    vec3 initialUp = vec3(0.0, 1.0, 0.0);\n    if (cameraDir.x == 0.0 && cameraDir.z == 0.0 && cameraDir.y != 0.0) {\n        initialUp = vec3(0.0, 0.0, 1.0);\n    }\n    vec2 offset = ((fragCoord / iResolution.xy) * cameraSize) - (cameraSize * 0.5);\n    vec3 rightChange = normalize(cross(cameraDir, initialUp));\n    vec3 upChange = normalize(cross(rightChange, cameraDir));\n    vec3 worldOffset = offset.x * rightChange + offset.y * upChange;\n    return cameraPos + worldOffset;\n}\n\n    \n// MAIN\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Background color default\n    vec3 col = vec3(0.0);\n    \n    // Init camera\n    vec2 cameraSize = iResolution.xy / DOTS_PER_MM;\n    \n    // Mouse effects on camera\n    vec2 mouseUV = iMouse.xy / iResolution.xy;\n    vec2 mouseAngles = vec2(mouseUV.x * (2.* PI), mouseUV.y * PI);\n    vec3 cameraPos = orbitControls(cameraDist, mouseAngles);\n    vec3 cameraDir = normalize(-cameraPos);\n    vec3 fragPos = orthoFragPos(cameraPos, cameraDir, cameraSize, fragCoord);\n    \n    // Animated Light Source\n    vec2 lightSphericalPos = vec2(iTime*0.5, iTime*0.2);\n    lightPos = orbitControls(cameraDist, lightSphericalPos);\n    \n    // Ray March\n    float objDist = marcher(fragPos.xyz, cameraDir);\n    vec3 objPos = fragPos + cameraDir * objDist;\n    \n    if (objDist < MAX_DIST) {\n        // Find Normal\n        vec3 normal = marchNormal(fragPos.xyz, cameraDir);\n        // objCol = abs(normal);\n        \n        // Ambient Lighting\n        vec3 ambiLight = lightCol * ambiStrength;\n        \n        // Diffuse Lighting\n        vec3 diffDir = normalize(lightPos - objPos);\n        vec3 diffLight = lightCol * diffStength * max(dot(normal, diffDir), 0.0);\n        \n        // Specular Lighting\n        vec3 reflDir = reflect(-diffDir, normal);\n        float specFact = pow(max(dot(-cameraDir, reflDir), 0.0), specPow);\n        vec3 specLight = lightCol * specStrength * specFact;\n        \n        // Phong Combined Lighting\n        vec3 combLight = ambiLight + diffLight + specLight;\n        col = combLight * objCol;\n\n    }\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n    \n}","name":"Image","description":"","type":"image"}]}