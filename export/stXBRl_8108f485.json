{"ver":"0.1","info":{"id":"stXBRl","date":"1666304411","viewed":111,"name":"Double slit - particles","username":"jean80it","description":"particle simulation to show what the double slit experiment would look like if light was made of particles","likes":4,"published":1,"flags":32,"usePreview":0,"tags":["particles","doubleslit"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// This shader is part of several I wrote to create animations\n// to support a presentation about Quantum Electrodynamics.\n// it is not supposed to be \"proof\" for anything, but to provide \n// good visualization of some concepts to help intuition.\n\n\n#define N 300\n#define P_STRIDE 100\n#define VEL_LEN 0.007\n\n#define PI 3.1415926\n#define TAU 6.2831852\n\n#define FLOATMAX 1000.0\n#define R 0.007\n#define PART_HARDNESS 0.7\n\n#define sqr(x) (x * x)\n\n#define SLITSY1 0.35\n#define SLITSY2 0.37\n#define SLIT1X1 0.3\n#define SLIT1X2 0.4\n#define SLIT2X1 0.6\n#define SLIT2X2 0.7\n\nvec2 translate(vec2 p, vec2 newPos)\n{\n    return p - newPos;\n}\n\nfloat sdSimpleRoundedBox( in vec2 p, in vec2 b, float r)\n{\n    vec2 q = abs(p)-b+r;\n    return min(max(q.x,q.y),0.0) + length(max(q,0.0)) - r;\n}\n\nvec3 drawSd(float d, inout vec3 prevCol, vec3 newCol, float aaTransitionWidth)\n{\n    prevCol = mix(prevCol, newCol, smoothstep(aaTransitionWidth, 0.0, d));\n    return prevCol;\n}\n\nvec3 drawSd(float d, inout vec3 prevCol, vec3 newCol, float mask, float aaTransitionWidth)\n{\n    prevCol = mix(prevCol, newCol, clamp(mask, 0.0, 1.0) * smoothstep(aaTransitionWidth, 0.0, d));\n    return prevCol;\n}\n\nvec4 loadPStatus(int idx)\n{\n    // fetch particle data\n    vec2 fPos = vec2(float(idx % P_STRIDE) + 0.5, float(idx / P_STRIDE) + 0.5) / iResolution.xy;\n    vec4 pack = texture(iChannel0, fPos);\n    \n    // unpack3\n    vec2 pos = pack.xy;\n    pack.z *= TAU;\n    vec2 vel = VEL_LEN * vec2(cos(pack.z), sin(pack.z));\n    \n    return vec4(pos, vel);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    float aaTransitionWidth = 1.0 / (min(iResolution.x, iResolution.y)) * 2.0;\n    vec2 uv = fragCoord.xy / iResolution.x;\n    vec2 size = vec2(iResolution.x / iResolution.y, 1.0);\n    vec2 center = size * 0.5;\n    vec2 pos = uv;\n    \n    //if (pos.y > 0.5)\n    if (((pos.y > SLITSY1) && (pos.y < SLITSY2)) && \n        ((pos.x < SLIT1X1) || ((pos.x > SLIT1X2) && (pos.x < SLIT2X1)) || (pos.x > SLIT2X2)))\n    {\n        fragColor = vec4(1);\n        return;\n    }\n    \n    float mind = FLOATMAX;\n    vec2 minPos = vec2(0,0);\n    \n    // for current fragment, consider distance from all particles\n    for (int i = 0; i < N; ++i)\n    {    \n        // fetch currently considered particle\n        vec4 s = loadPStatus(i);\n        vec2 pos = s.xy;\n        vec2 vel = s.zw;\n        \n        float dist = distance(pos, uv);\n        \n        if (dist < mind)\n        {\n            mind = dist;\n            minPos = pos;\n        }\n    }\n    \n    vec3 back = clamp(sqrt(mix(sqr(vec3(0.25, 0.2, 0.1)), sqr(vec3(0.1, 0.22, 0.3)), uv.y + uv.x / 2.0)), 0.0, 1.0);\n    \n    float redF = distance(minPos + vec2(R) / 4.0, uv) / R;\n    vec3 red1Col = vec3(1.0, 0.0, 0.0);\n    vec3 red2Col = vec3(1.0, 0.7, 0.8);\n    vec3 red = mix(red2Col, red1Col, redF);\n    \n    \n    float back_mask = smoothstep(R, R * PART_HARDNESS, mind);\n    vec3 col = mix(back, red, back_mask);\n\n    drawSd(\n        sdSimpleRoundedBox(translate(uv, vec2(0.27, center.y)), vec2(0.08, 0.01), 0.01), \n        col, \n        vec3(1.0, 0.3, 0.3), \n        min(iTime * 0.5 - 1.5, 0.4), \n        aaTransitionWidth);\n\n    drawSd(\n        sdSimpleRoundedBox(translate(uv, vec2(0.74, center.y)), vec2(0.08, 0.01), 0.01), \n        col, \n        vec3(1.0, 0.3, 0.3), \n        min(iTime * 0.5 - 1.5, 0.4), \n        aaTransitionWidth);\n\n    fragColor = vec4(col, 1.0); \n    \n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// This shader is part of several I wrote to create animations\n// to support a presentation about Quantum Electrodynamics.\n// it is not supposed to be \"proof\" for anything, but to provide \n// good visualization of some concepts to help intuition.\n\n\n#define N 300\n#define VEL_LEN 0.007\n#define P_STRIDE 100\n\n#define PI 3.1415926\n#define TAU 6.2831852\n\n#define SLITSY1 0.35\n#define SLITSY2 0.37\n#define SLIT1X1 0.3\n#define SLIT1X2 0.4\n#define SLIT2X1 0.6\n#define SLIT2X2 0.7\n\n// cheap \"stretch and fold\" for pseudo-random\nfloat rand(vec2 co)\n{\n    return fract(sin(dot(co, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n// we're going to store \nvec4 loadPStatus(int idx)\n{\n    // fetch particle data\n    vec2 fPos = vec2(float(idx % P_STRIDE) + 0.5, float(idx / P_STRIDE) + 0.5) / iResolution.xy;\n    vec4 pack = texture(iChannel0, fPos);\n    \n    // unpack\n    vec2 pos = pack.xy;\n    pack.z *= TAU;\n    vec2 vel = VEL_LEN * vec2(cos(pack.z), sin(pack.z));\n    \n    return vec4(pos, vel);\n}\n\nvec4 storePStatus(vec2 pos, vec2 vel)\n{\n    // re-pack\n    return vec4(pos.x, \n            pos.y,  \n            fract((atan(vel.y, vel.x) + TAU)/ TAU), \n            1.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    // get idx from tex position\n    int idx = (int(fragCoord.x) + int(fragCoord.y) * P_STRIDE);\n    \n    if ((int(fragCoord.x) >= P_STRIDE) || (idx >= N))\n    {\n        fragColor = vec4(0.0);\n        return;\n    }\n\n    vec4 s;\n    vec2 pos;\n    vec2 vel;\n    \n    // fetch currently considered particle\n    s = loadPStatus(idx);\n        \n    pos = s.xy;\n    vel = s.zw;\n    \n    // respawning of particles that are out of bound\n        \n    if ((iFrame < 1) ||  // it,s first frame, so we have to init, OR\n        (pos.y >= 1.0) || (pos.x <= 0.0) || (pos.x >= 1.0) || (pos.y <= 0.0) ||  // particle is out of screen, OR\n        (((pos.y > SLITSY1) && (pos.y < SLITSY2)) && \n         ((pos.x < SLIT1X1) || ((pos.x > SLIT1X2) && (pos.x < SLIT2X1)) || (pos.x > SLIT2X2))) )\n    {   \n        pos = vec2(0.5, 0.02);\n        float a = float(idx) * PI / float(N);\n        vel = VEL_LEN * vec2(cos(a), sin(a));\n        if (iFrame < 1)\n            pos = pos + vel * 30.0 * rand(vec2(idx));\n    }\n    else\n    {\n       // update position\n       pos += vel * 0.5;\n    }\n    \n    \n    fragColor = storePStatus(pos, vel);\n}\n\n\n","name":"Buffer A","description":"","type":"buffer"}]}