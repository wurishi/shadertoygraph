{"ver":"0.1","info":{"id":"DtGBDw","date":"1702166248","viewed":76,"name":"Monte Carlo Halation (needs fix)","username":"Nguyen2007","description":"Based on https://youtu.be/eLJODjlG5dA?si=1GbEWAEhuoximlzl\nText display https://www.shadertoy.com/view/4sBfRd\nFor my raytracer","likes":0,"published":3,"flags":32,"usePreview":0,"tags":["bloom","montecarlo","film"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":1,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\nCredits in the description\nI did this effect based on what I understand in the video\nSo it could be crude\nIf I have any mistake or misunderstand, please tell me in the comments\n\nSee the mainImage in Buffer A\n*/\n\nvec3 tone(vec3 v)\n{\n    mat3 m = mat3(.84, .04, .04,\n                  .08, .88, .08,\n                  .08, .08, .88);\n    \n    v = clamp(log2(m * v) / 16.5 + .756, 0., 1.);\n    \n    v = v * v * (v * v * (15.5 * v * v - 40.14 * v + 31.96) - 6.868 * v + .4298) + .1191 * v - .00232;\n  \n    v = inverse(m) * pow(v, vec3(2, 2.5, 3));\n    \n    return mix(1.055 * pow(v, vec3(1) / 2.4) - .055, v * 12.92, lessThan(v, vec3(.0031308)));\n}\n\nvoid mainImage(out vec4 O, vec2 I)\n{\n    O = vec4(tone(texture(iChannel0, I / R.xy).xyz), 1);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"precision highp float;\nprecision highp int;\n\n#define R iResolution\n#define PI  (acos(-1.))\n#define TAU (2. * PI)\n\nfloat sqr(float x) {return x * x;}\n\nuvec4 seed;\n\nvec4 PCG(inout uvec4 v)\n{\n    v = v * 1664525u + 1013904223u;\n    \n    v.x += v.y * v.w;\n    v.y += v.z * v.x;\n    v.z += v.x * v.y;\n    v.w += v.y * v.z;\n    \n    v ^= v >> 16u;\n    \n    v.x += v.y * v.w;\n    v.y += v.z * v.x;\n    v.z += v.x * v.y;\n    v.w += v.y * v.z;\n    \n    return vec4(v) / 4294967296.;\n}\n\n#define hash  hash4.x\n#define hash2 hash4.xy\n#define hash3 hash4.xyz\n#define hash4 PCG(seed)\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":1,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"vec3 char(vec2 p, int c) \n{\n    if (p.x < 0. || p.x > 1. || p.y < 0. || p.y > 1.) return vec3(0);\n    p /= 16.;\n    return textureGrad(iChannel1, p + fract(vec2(c, 15 - c / 16) / 16.), dFdx(p), dFdy(p)).xxx;\n}\n\n#define C(c) col += char(p, c + 64); p.x -= .5;\n\nvec3 color(vec2 p)\n{\n    p -= .5;\n    p.x *= R.x / R.y * 1.1;\n    p *= 5.;\n    p += vec2(2.25, .5);\n    \n    vec3 col = vec3(0);\n    \n    C(8)\n    C(1)\n    C(12)\n    C(1)\n    C(20)\n    C(9)\n    C(15)\n    C(14)\n    \n    return 10. * col;\n}\n\nvec2 offset() // Uniform sampling then trace to a plane\n{\n    float a = hash * TAU;\n    return sqrt(1. / sqr(hash) - 1.) * vec2(sin(a) / R.x * R.y, cos(a));\n}\n\nvoid mainImage(out vec4 O, vec2 I)\n{\n    O = R.xyxy;\n    if (ivec2(I) == ivec2(0)) return;\n    \n    seed = uvec4(I, iFrame, iTime);\n    \n    vec2 uv = (I + hash2) / R.xy;\n    \n    vec3 col = vec3(1);\n    \n    // Halation\n    {\n        float localDiff  = .001,\n              globalDiff = .3,\n              amplify    = .8,\n              hue        = .2;\n\n        amplify++;\n\n        if(1. / hash < amplify)\n        {\n            float g = globalDiff,\n            \n            rw = 1. + g + g * g,\n            tw = rw * (1. + hue);\n            \n            vec2 o1 =           offset() * localDiff,\n                 o2 = 2. * o1 + offset() * localDiff,\n                 o3 = 2. * o2 + offset() * localDiff;\n\n            if(hash < rw / tw) col = vec3(tw, 0, 0);\n            else               col = vec3(0, tw, 0), o1 *= 1.5, o2 *= 1.5, o3 *= 1.5;\n            \n            float ref = rw * hash;\n\n            if     (ref < 1.)     uv += o1; // Local         | assume that light rays pass through/reflect\n            else if(ref < 1. + g) uv += o2; // Global iter 1 | off the color sensitive layer and then scatter\n            else                  uv += o3; // Global iter 2 | diffusely at the anti halation layer\n        }\n\n        col *= amplify;\n    }\n    \n    col *= color(uv);\n    \n    O = vec4(col, 1);\n    \n    if (texelFetch(iChannel0, ivec2(0), 0).xy == R.xy)\n    {\n        vec4 pre = texture(iChannel0, I / R.xy);\n\t         pre.a /= pre.a + 1.;\n        \n        O = vec4(mix(pre.rgb, col, pre.a), pre.a);\n    }\n}","name":"Buffer A","description":"","type":"buffer"}]}