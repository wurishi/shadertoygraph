{"ver":"0.1","info":{"id":"3ddSRn","date":"1588520265","viewed":75,"name":"RayMarching1234","username":"Danchyg1337","description":"Balls...","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_DIST 100\n#define SURF_DIST .01\n#define MAX_RAY 1000.\n#define SP_NUM 15\n#define CP_NUM 3\n#define TR_NUM 2\n#define CB_NUM 1\n\nstruct Sphere{\n\tvec3 col;\n    vec3 pos;\n    float rad;\n};\n    \nstruct Capsule{\n\tvec3 pos1;\n    vec3 pos2;\n    float rad1;\n    float rad2;\n    vec3 col; \n};\n\nstruct Torus{\n    vec3 pos;\n\tfloat inrad;\n    float rrad;\n    vec3 col;\n\tvec3 dir;\n};\n    \nstruct Cube{\n\tvec3 pos;\n    float size;\n    vec3 col;\n};\n\nfloat dayTime = 1.;\n    \nfloat dCube(vec3 p, Cube c);\nfloat dTorus(vec3 p, Torus t);\nfloat dCapsule(vec3 p, Capsule c);\nfloat dSphere(vec3 p, Sphere s);\nfloat dSky(vec3 p, float d);\nbool isCube(vec3 p, Cube c);\nbool isTorus(vec3 p, Torus t);\nbool isCapsule(vec3 p, Capsule c);\nbool isSphere(vec3 p, Sphere s);\nbool isSky(vec3 p, float d);\nvec3 GetColor(vec3 p, float light);\nfloat GetLight(vec3 p, vec3 ro);\nvec3 GetNormal(vec3 p);\nfloat GetDist(vec3 p);\nfloat RayMarch(vec3 ro, vec3 rd);\nmat2 Rot(float a);\n\nSphere spheres[SP_NUM];\nCapsule capsules[CP_NUM];\nTorus tors[TR_NUM];\nCube cubes[CB_NUM];\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    dayTime = (1.+sin(iTime)/2.)*3.;\n    vec2 uv = (fragCoord-iResolution.xy*.5)/iResolution.y;\n\t\n\n    \n    for(int t=0;t<SP_NUM;t++){\n    \tSphere s;\n        s.col = vec3((1.+sin(iTime*float(t)))/2., (1.+cos(iTime*float(t)))/2., 1);\n        s.pos = vec3(-7+t, 1, 8);\n        s.rad = .8;\n        spheres[t] = s;\n    }\n    \n    for(int t=0;t<CP_NUM;t++){\n    \tCapsule c;\n    \tc.pos1 = vec3(0, 3+t, 8);\n        c.pos2 = vec3(4, 3+t, 8);\n        c.rad1 = .01;\n        c.rad2 = 1.5;\n        c.col = vec3(1, 0, 1);\n        capsules[t] = c;\n    }\n    \n    for(int t = 0;t<TR_NUM;t++){\n    \tTorus tor;\n        tor.pos = vec3(1.5*float(t+1), 1.5*float(t+1), 3);\n        tor.inrad = 3.;\n        tor.rrad = .7;\n        tor.col = vec3(1.+cos(iTime*float(t+1)/2.), 1.+sin(iTime*float(t+1))/2., 1.+cos(iTime*float(t+1))/2.);\n        tor.dir = normalize(vec3(1, 0, 0));  \t\t\t\t\t\t\t\t\t\t//should be normalized!!\n        tors[t] = tor;\n    }\n    \n    for(int t = 0;t<CB_NUM;t++){\n    \tCube c;\n        c.pos = vec3(-4, 1, 3);\n        c.size = .7;\n        c.col = vec3(0, 1, 0);\n        cubes[t] = c;\n    }\n    vec3 ro = vec3(0, 7, -8);\n    vec3 rd = normalize(vec3(uv.x, uv.y, 1));\n    float rm = RayMarch(ro, rd);\n    vec3 p = ro + rd*rm;\n    float light = GetLight(p, ro);\n    vec3 col = GetColor(p, light);\n\n    fragColor = vec4(col,1.0);\n}\n\nmat2 Rot(float a){\n\tfloat s = sin(a);\n\tfloat c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat GetDist(vec3 p){\n    float minm = length(p-spheres[0].pos) - spheres[0].rad;\n    for(int t=1;t<SP_NUM;t++){\n        minm = min(minm, dSphere(p, spheres[t]));\n    }\n    for(int t=0;t<CP_NUM;t++){\n        minm = min(minm, dCapsule(p, capsules[t]));\n    }\n    for(int t=0;t<TR_NUM;t++){\n        minm = min(minm, dTorus(p, tors[t]));\n    }\n    for(int t=0;t<CB_NUM;t++){\n        minm = min(minm, dCube(p, cubes[t]));\n    }\n    float plane = dot(p, vec3(0, 1, 0));\n    float sky = dSky(p, 100.);\n    return min(min(plane, sky), minm);\n}\n\nfloat RayMarch(vec3 ro, vec3 rd){\n\tfloat d0 = 0.;\n    for(int t=0;t<MAX_DIST;t++){\n    \tvec3 p = ro + rd * d0;\n    \td0 += GetDist(p);\n        if(d0 < SURF_DIST || d0 > MAX_RAY) break;\n    }\n\treturn d0;\n}\n\nvec3 GetNormal(vec3 p){\n    float d2 = GetDist(p);\n\tvec2 offs = vec2(.01, 0.);\n\tvec3 d = d2 - vec3(GetDist(p-offs.xyy), \n                  GetDist(p-offs.yxy),\n                  GetDist(p-offs.yyx));\n    return normalize(d);\n}\n\nfloat GetLight(vec3 p, vec3 ro){\n\tvec3 sun = vec3(sin(iTime) * 8., 18, cos(iTime) * 8.);\n\tvec3 sd  = normalize(sun - p);\n    vec3 n = GetNormal(p);\n    float light = clamp(dot(sd, n), 0., 1.);\n    \n    vec3 lts = normalize(reflect(p - ro, n));\n    float phong = pow(max(dot(lts, sd), 0.), 32.);\n    \n    float sl = length(sun - p);\n    float rm = RayMarch(sun, sd*-1.);\n    float final = light + phong;\n    if(!(sl - rm > -.3 && sl- rm < SURF_DIST)) final *= .5;\n    return final;\n    \n}\n\nvec3 GetColor(vec3 p, float light){\n    vec3 sunCol = vec3(0.97, 1, 0.85);\n    vec3 skyCol = vec3(.13,.20,.35);\n    sunCol *= light / dayTime;\n\tfor(int t=0;t<SP_NUM;t++){\n    \tif(isSphere(p, spheres[t]) ) return spheres[t].col*sunCol;\n    }\n    for(int t=0;t<CP_NUM;t++){\n    \tif(isCapsule(p, capsules[t]) ) return capsules[t].col*sunCol;\n    }\n    for(int t=0;t<CP_NUM;t++){\n    \tif(isTorus(p, tors[t]) ) return tors[t].col*sunCol;\n    }\n    for(int t=0;t<CB_NUM;t++){\n    \tif(isCube(p, cubes[t]) ) return cubes[t].col*sunCol;\n    }\n    if(isSky(p, 100.)) return (smoothstep(600., 45., p.y)*vec3(.0,.61,.79) + (smoothstep(60., 35., p.y) * vec3(.87,.80,.67)) + (smoothstep(35., 0., p.y) * smoothstep(75., 0., abs(p.x)) * vec3(.5,.18,.12) * 4.)) / dayTime;\n\treturn sunCol;\n}\n\nbool isSphere(vec3 p, Sphere s){\n    float l = dSphere(p, s);\n\tif(l < SURF_DIST*2. && l> -.3) return true;\n    return false;\n}\n\nbool isCapsule(vec3 p, Capsule c){\n    float l = dCapsule(p, c);\n    if(l < SURF_DIST*2. && l> -.3) return true;\n\treturn false;\n}\n\nbool isTorus(vec3 p, Torus t){\n\tfloat l = dTorus(p, t);\n    if(l < SURF_DIST*2. && l> -.3) return true;\n\treturn false;\n}\n\nbool isCube(vec3 p, Cube c){\n\tfloat l =  dCube(p, c);\n    if(l < SURF_DIST*2. && l> -.3) return true;\n\treturn false;\n}\n\nbool isSky(vec3 p, float d){\n    float l =  dSky(p, d);\n\tif(l < SURF_DIST*2. && l> -.3) return true;\n\treturn false;\n}\n\nfloat dSky(vec3 p, float d){\n\tfloat u = d - p.y;\n\tfloat f = d - p.z; \n\treturn min(u, f);\n}\n\nfloat dSphere(vec3 p, Sphere s){\n\treturn length(p-s.pos) - s.rad;\n}\n\nfloat dCapsule(vec3 p, Capsule c){\n\tvec3 cp = p - c.pos1;\n    vec3 cl = c.pos2 - c.pos1;\n    cl.zy *= Rot(iTime);\n    cl.zx *= Rot(iTime);\n    float cd = clamp(dot(cp, cl) / dot(cl, cl), 0., 1.);\n    vec3 cp2 = c.pos1 + cl * cd;\n    float radMX = max(c.rad1, c.rad2);\n    float radMN = min(c.rad1, c.rad2);\n    float radD = radMX - radMN;\n    return length(cp2-p) - ((radMN + smoothstep(0., 1., cd) * radD));\n}\n\nfloat dTorus(vec3 p, Torus t){\n    vec3 tp = p - t.pos;\n    tp.xy *= Rot(iTime);\n    //tp.zx *= Rot(iTime);\n\tvec2 q = vec2(length(tp.xz)-t.inrad,tp.y);\n\treturn length(q)-t.rrad;\n}\n\nfloat dCube(vec3 p, Cube c){\n\tvec3 cp = p - c.pos;\n    cp.zy *= Rot(iTime);\n    cp.zx *= Rot(iTime);\n    return length(max(abs(cp) - c.size, 0.));\n}\n","name":"Image","description":"","type":"image"}]}