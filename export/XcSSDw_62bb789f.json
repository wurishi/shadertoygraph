{"ver":"0.1","info":{"id":"XcSSDw","date":"1706378915","viewed":135,"name":"volumetric rainbow tunnel /mouse","username":"timmaffett","description":"mouse modifys tunnel diameter\nÂ trying to understand the math behind dda.","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["tutorial","voxel","cubes","dda","sub900ch"],"hasliked":0,"parentid":"XdfGRn","parentname":"Apple"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Fork of \"volumetric DDA 2\" by Elsio. https://shadertoy.com/view/MfBXDW\n// 2024-01-27 18:06:20\n\n#define Q(z) P((z), .2, 3., .3, 2., 0.)\n#define P(z, a, b, c, d, e) vec3(sin(z * a) * b, cos(z * c) * d - e, z)\n#define border(q, mask)                                          \\\n            vec3(.4 + smoothstep(.0, .1 / R.y,                  \\\n                          R.y / (.48 - dot(max(q.yzx, q.zxy), mask))))\n\nbool glass;\nfloat map(vec3 p){\n    float \n        t1 = length(p - P(p.z, .2, 1., .3, 4., 1.)),   \n        t2 = length(p - P(p.z, .3, 3., .2, 1., 1.)),\n        ret = \n            1.5 - min(                                              \n                      length(p - Q(p.z)),                           \n                      min(t1, t2)\n                  );\n                  \n    glass = t1 < t2;\n    return ret;\n}\n\n#define r33(p) fract(sin(p * vec3(124,245.32,1234.343))*2234.3)\n#define r31(p) fract(sin(dot(p, vec3(124,245.32,1234.343)))*2234.3)\n//#define volCol(p) r33(p+1.) * cos(t + 6.3 * r31(p*.1)) * 3.\n#define volCol(p) vec3(1.75, 0, 0) * cos(t + 6.3 * r31(p*.06)) * 1. + .6\n\n\nvec3 hsb2rgb( in vec3 c )\n{\n    vec3 rgb = clamp(abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),\n                             6.0)-3.0)-1.0,\n                     0.0,\n                     1.0 );\n    rgb = rgb*rgb*(3.0-2.0*rgb);\n    return (c.z * mix( vec3(1.0), rgb, c.y));\n}\n\n\n\nvoid mainImage(out vec4 o, vec2 u) {\n    float t = 2. * iTime, res = .125, z;\n    vec3 R = iResolution,\n         norm, mask, side, p, q, border, volum = vec3(5,5,7) / 7., \n         ro = Q(t),\n         fw = normalize(Q(t + 1.) - ro),\n         rt = vec3(fw.z, 0, -fw.x),\n         D = fw + mat2x3(rt, cross(fw, rt)) \n                    * (u - .5 * R.xy) / R.y / 1.2; // (!)\n    \n     vec2 mouse = (iMouse.xy == vec2(0.)) ? vec2(1.0) : iMouse.xy/iResolution.xy;\n    \n    \n    ro /= res;\n    p = floor(ro);\n    side = (p - ro + .5) / D + .5 / abs(D);\n    \n    int i, far = 220;\n    while (q = p * res, i++ < far){\n        if(map(q) < mouse.x-mouse.y) {\n            //if(r31(p*.3) < .1) {\n            // altering x,y and z factors \n                volum *= hsb2rgb(vec3(q.x+(2.7*(p.x+p.y+p.z)/(p.z+p.y+0.1)*34.+p.z*34.0),0.9,1.)); //volCol(p);\n            //}\n            //else \n            break;\n        }\n        \n        side += mask / abs(D);\n        mask = step(side, side.yzx) * step(side, side.zxy);\n        p += norm = mask * sign(D);\n    }\n\n    z = dot(side, mask);\n    q = abs(fract(ro + z * D) - .5);\n    \n    const float blackEdgeWidthFactor = 1.085;\n    o.rgb = ((volum)+   //0.35 brighten (and give color to black edges) //(glass?.5:-.5)\n             0.35*( 12./ z))    // depth brightness\n             *( 32./ z) // depth shadow\n            *border(q, blackEdgeWidthFactor*mask) // black cube edges /face shadow\n            ;\n}\n\n","name":"Image","description":"","type":"image"}]}