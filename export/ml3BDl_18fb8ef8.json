{"ver":"0.1","info":{"id":"ml3BDl","date":"1701729922","viewed":29,"name":"Greer's Mandelbrot Experiments","username":"PlasmaPig13","description":"Just Mandelbrot + variants with weird colourings","likes":2,"published":1,"flags":16,"usePreview":0,"tags":["2d","fractal","mandelbrot","unique","colouring"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"precision highp float;\n\nfloat zoom = 1000.; //10000\nbool anim = true;\nbool pan = false;\nvec2 centre = vec2(0.1664,0.6374); // nice: (0.13,0.66), (0.4,0.22)\nfloat iters = 20000.;\nfloat PI = 3.141592653589793238462643383;\nfloat TAU = 6.28318530717958647692528676;\nfloat limitsq = 200.;\n\nfloat param0 = 0.741;\nfloat param1 = 0.602;\nfloat param2 = -0.279;\n\n// Time is iTime\n\nfloat maxim(float a, float b) {\n    return (abs(a-b) + a+b)/2.;\n}\n\nvec3 v_to_c_0(float v, bool inv) {\n\n    float v10 = 13.*v;\n\n    float wiggle = 0.25; // 0 - 0.5, default: 0.25\n    float wonk = 0.; // 0 - 1, default: 0\n    \n    float r = 0.5+wiggle*sin(TAU*(v10-2.*wonk))+(0.5-wiggle)*sin(TAU*v);\n    float g = 0.5+wiggle*sin(TAU*(v10+1./3.-wonk))+(0.5-wiggle)*sin(TAU*(v+1./3.));\n    float b = 0.5+wiggle*sin(TAU*(v10+2./3.))+(0.5-wiggle)*sin(TAU*(v+2./3.));\n    \n    float m = maxim(maxim(r,g),b);\n    \n    r = r*(4.-4.*m)/((6.*wiggle+1.)*m);\n    g = g*(4.-4.*m)/((6.*wiggle+1.)*m);\n    b = b*(4.-4.*m)/((6.*wiggle+1.)*m);\n    \n    if (inv) {\n        float m2 = maxim(maxim(r,g),b);\n        float m3 = maxim(maxim(m2-r,m2-g),m2-b);\n        r = 1. + (r - m2 - m3)/2.;\n        g = 1. + (g - m2 - m3)/2.;\n        b = 1. + (b - m2 - m3)/2.;\n    }\n    \n    float rsat = 1.; // 0 - 1, defult: 1\n    float gsat = 0.7; // 0 - 1, default: 1\n    float bsat = 0.7; // 0 - 1, default: 1\n    \n    float rbri = 0.9; // 0 - 2, defult: 1\n    float gbri = 1.1; // 0 - 2, defult: 1\n    float bbri = 1.1; // 0 - 2, defult: 1\n    \n    float rcont = 3.; // 0 - ∞, defult: 1\n    float gcont = 1.; // 0 - ∞, defult: 1\n    float bcont = 1.; // 0 - ∞, defult: 1\n    \n    float rbias = 0.6; // 0 - 1, defult: 0.5\n    float gbias = 0.7; // 0 - 1, defult: 0.5\n    float bbias = 0.7; // 0 - 1, defult: 0.5\n    \n    r = (r*rsat + (1.-rsat)/2.)*rbri;\n    g = (g*gsat + (1.-gsat)/2.)*gbri;\n    b = (b*bsat + (1.-bsat)/2.)*bbri;\n    \n    float rP = pow(2.,rcont);\n    float rX = pow(2.,rcont*r);\n    float rB = pow(2.,rcont*rbias);\n    float rC = (2.*rP-rB-rB*rP)/(2.*rB-3.-rP);\n    float gP = pow(2.,gcont);\n    float gX = pow(2.,gcont*g);\n    float gB = pow(2.,gcont*gbias);\n    float gC = (2.*gP-gB-gB*gP)/(2.*gB-3.-gP);\n    float bP = pow(2.,bcont);\n    float bX = pow(2.,bcont*b);\n    float bB = pow(2.,bcont*bbias);\n    float bC = (2.*bP-bB-bB*bP)/(2.*bB-3.-bP);\n    \n    r = (rP+rC)*(1.-(1.+rC)/(rX+rC))/(rP-1.);\n    g = (gP+gC)*(1.-(1.+gC)/(gX+gC))/(gP-1.);\n    b = (bP+bC)*(1.-(1.+bC)/(bX+bC))/(bP-1.);\n    \n    return vec3(r,g,b);\n}\n\nfloat activate(float zx, float zy) {\n    return sin(5.*sin(log(zx))+5.*sin(log(zy))-2.)+sin(5.*sin(log(zy))+5.*sin(log(zx))+2.);\n}\n\nvec2 fractal(vec2 uv) {\n    float t;\n    \n    float cx = uv.x;\n    float cy = uv.y;\n    float zx = 0.;\n    float zy = 0.;\n    float nzx = 0.;\n    float nzy = 0.;\n    float z2x = 0.;\n    float z2y = 0.;\n    float nz2x = 0.;\n    float nz2y = 0.;\n    \n    float trapa = 2.05;\n    \n    float trapx = cos(trapa/5.)-1.;\n    float trapy = sin(trapa/5.);\n    \n    float diverx = cx;\n    float divery = cy;\n    \n    float minv;\n    float maxv;\n    float avg = 0.;\n    float ev;\n    float i = 0.;\n    \n    float trapmi = i;\n    float trap = (trapx-z2x)*(trapx-z2x) + (trapy-z2y)*(trapy-z2y);\n    float trapmin, trapmin2, trapmin3;\n    if (trap != 0.) { \n        trapmin = trap;\n        trapmin2 = 1000.+trap;\n        trapmin3 = 2000.+trap;\n    } else {\n        trapmin = 1000.;\n        trapmin2 = 2000.;\n        trapmin3 = 3000.;\n    }\n    \n    float divergmi = i;\n    float diverg = (cx-z2x)*(cx-z2x) + (cy-z2y)*(cy-z2y);\n    float divergmin, divergmin2, divergmin3;\n    if (diverg != 0.) {\n        divergmin = diverg;\n        divergmin2 = 1000.+diverg;\n        divergmin3 = 2000.+diverg;\n    } else {\n        divergmin = 1000.;\n        divergmin2 = 2000.;\n        divergmin3 = 3000.;\n    }\n    \n    while (z2x*z2x+z2y*z2y < limitsq && i < iters) {\n        \n        t = 0.;\n        nzx = (zx*zx - zy*zy)*(1.-t) + (zx*zx*zx - 3.*zx*zy*zy)*t + cx;\n        nzy = (2.*zx*zy)*(1.-t) + (3.*zx*zx*zy - zy*zy*zy)*t + cy;\n        zx = nzx;\n        zy = nzy;\n        \n        t = 1.;\n        nz2x = (z2x*z2x - z2y*z2y)*(1.-t) + (z2x*z2x*z2x - 3.*z2x*z2y*z2y)*t + zx;\n        nz2y = (2.*z2x*z2y)*(1.-t) + (3.*z2x*z2x*z2y - z2y*z2y*z2y)*t + zy;\n        z2x = nz2x;\n        z2y = nz2y;\n        \n        ev = activate(z2x, z2y);\n        minv = min(minv, ev);\n        maxv = max(maxv, ev);\n        avg += ev;\n        i += 1.;\n        \n        float trap = (trapx-z2x)*(trapx-z2x) + (trapy-z2y)*(trapy-z2y);\n        if (trap < trapmin && trap != 0.) {\n            trapmin3 = trapmin2;\n            trapmin2 = trapmin;\n            trapmin = trap;\n            trapmi = i;\n        } else if (trap < trapmin2 && trap != 0.) {\n            trapmin3 = trapmin2;\n            trapmin2 = trap;\n        } else if (trap < trapmin3 && trap != 0.) {\n            trapmin3 = trap;\n        }\n        \n        float diverg = (cx-z2x)*(cx-z2x) + (cy-z2y)*(cy-z2y);\n        if (diverg < divergmin && diverg != 0.) {\n            divergmin3 = divergmin2;\n            divergmin2 = divergmin;\n            divergmin = diverg;\n            divergmi = i;\n        } else if (diverg < divergmin2 && diverg != 0.) {\n            divergmin3 = divergmin2;\n            divergmin2 = diverg;\n        } else if (diverg < divergmin3 && diverg != 0.) {\n            divergmin3 = diverg;\n        }\n    }\n    avg = avg/iters;\n    \n    float dist_of_act_z = (avg-minv)/(maxv-minv);\n    float traphalo = 1./(sqrt(trapmin)+1.);\n    float traphalo2 = 1./(sqrt(trapmin2)+1.);\n    float traphalo3 = 1./(sqrt(trapmin3)+1.);\n    float diverghalo = 1./(sqrt(divergmin)+1.);\n    float diverghalo2 = 1./(sqrt(divergmin2)+1.);\n    float diverghalo3 = 1./(sqrt(divergmin3)+1.);\n    float trapbounds = (trapmin/trapmin2)/(trapmin2/trapmin3);\n    float divergbounds = (divergmin/divergmin2)/(divergmin2/divergmin3);\n    float v = (diverghalo/4. + diverghalo2/4. + diverghalo3/4. + traphalo/4. + traphalo2/4. + traphalo3/4. + divergbounds/64. + trapbounds/64. + dist_of_act_z/1.) + 0.62;\n    \n    return vec2(v, z2x*z2x+z2y*z2y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 mouse = iMouse.xy;\n    \n    float zo;\n    if (anim) {\n        zo = 0.7+zoom*(pow(2.,12.)-1.)/1000000.;\n    } else {\n        zo = zoom;\n    }\n    \n    if (pan) {\n        centre = -3.*vec2((2.*mouse.x-iResolution.x)/iResolution.y,2.*mouse.y/iResolution.y-1.)/zo + centre;\n    }\n   \n    vec2 uv = vec2((2.*fragCoord.x-iResolution.x)/iResolution.y,2.*fragCoord.y/iResolution.y-1.)/zo + centre;\n    \n    float v = 0.;\n    bool mag = false;\n    vec2 f0 = fractal(uv);\n    v += f0.x;\n    mag = (f0.y < limitsq)^^mag;\n    \n    vec3 col;\n    \n    if (mag) {\n        col = vec3(v_to_c_0(v+0.5,true));\n    }\n    else {\n        col = vec3(v_to_c_0(v,false));\n    }\n    \n    //if ((uv.x-trapx)*(uv.x-trapx) + (uv.y-trapy)*(uv.y-trapy) < 0.0004) {\n    //    col = vec3(1,1,1);\n    //}\n\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}