{"ver":"0.1","info":{"id":"lcBfWw","date":"1724996750","viewed":16,"name":"Points Animation","username":"mtx","description":"Animated points from texture pixels ","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["texture","points"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sf3Rn","filepath":"/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","previewfilepath":"/media/ap/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Shadertoy Shader\n// - Render points from texture on canvas\n// - Animate points over time\n\n// Shader inputs\n//uniform sampler2D iChannel0;  // Texture with encoded points\n//uniform vec3 iResolution;     // Resolution of the screen\n//uniform float iTime;          // Time for animation\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalize fragment coordinates\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\n    \n    // Initialize color to black\n    fragColor = vec4(0.0);\n\n    // Number of points to sample (width of the texture)\n    int pointCount = int(textureSize(iChannel0, 0).x);\n    float t = iTime * 0.2;\n    // Iterate through points stored in the texture\n    for (int i = 0; i < pointCount; i++)\n    {\n        // Get the texture coordinate for the current point\n        float texCoordX = float(i) / float(pointCount);\n        vec2 texCoord = vec2(texCoordX, 0.5);\n\n        // Retrieve the point's RGB values (representing XYZ coordinates)\n        vec3 point = texture(iChannel0, texCoord).rgb;\n        // Normalize the RGB values from [0, 255] to [0, 1]\n        // point /= 255.0;\n        // Apply some animation to the points (using sine wave for smooth motion)\n        float timeOffset = float(i) * 0.1;\n        vec2 animatedPoint = point.xy + vec2(cos(t + timeOffset), sin(t + timeOffset)) * 0.25;\n        //vec2 animatedPoint = point.xy;\n\n        // Map XYZ to screen coordinates (Z is ignored for simplicity)\n        // vec2 screenPos = animatedPoint.xy * iResolution.xy ;\n        vec2 screenPos = vec2(\n            (animatedPoint.x - 0.5) * iResolution.x + iResolution.x / 2.0,\n            (animatedPoint.y) * iResolution.y + iResolution.y / 2.0\n        );\n        // Adjust points to be centered on the screen\n        // vec2 screenPos = (animatedPoint.xy - 0.5) * iResolution.xy + iResolution.xy * 0.5;\n\n        // Calculate distance between the current fragment and the point\n        float distance = length(screenPos - fragCoord.xy);\n        \n        // If the fragment is near the point, color it\n        float pointSize = 8.0;  // Adjust point size here\n        if (distance < pointSize)\n        {\n            fragColor = vec4(1.0);  // Set the color to white\n        }\n    }\n}\n","name":"Image","description":"","type":"image"}]}