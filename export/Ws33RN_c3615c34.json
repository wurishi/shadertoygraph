{"ver":"0.1","info":{"id":"Ws33RN","date":"1567889211","viewed":99,"name":"Reflection testing","username":"TheRomanOne","description":"Testing out some reflections","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["reflection","mirror"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_DEPTH 3\n\n#define B1 0\n#define B2 1\n#define B3 2\n#define BALL 3\n#define FLOOR 4\n#define WALL 5\n\n/*struct Object\n{\n    float dist;\n    vec3 col;\n    vec3 pos;\n};*/\n\nfloat blobThing(vec3 p, vec3 pos, float ofst)\n{\n    p-= pos;\n    float time = iTime/3.;\n    float t = 10.;\n    vec3 cPos = vec3(-t*sin(time), 0, 0);\n    float d = sphere(p, cPos, 2.);\n    vec3 pp = p;\n    \n    vec3 wPos = vec3(t*sin(time), 0, 0);\n    pp -= wPos;\n    pp.yz *= rot(iTime * 53. + ofst);\n    pp.xz *= rot(iTime * 137.5952 + ofst);\n    pp += wPos;\n\n    float w = box(pp, wPos, vec3(1.));    \n    \n    return opSmoothUnion(d, w, 15.);;   \n}\n\nvec2 map(vec3 p)\n{\n    float pOfst = 180./3.;\n    float pace = iTime*100.;\n    \n    vec3 pos1 = vec3(0);\n    vec3 pp = p;\n    pp -= pos1;\n    pp.y -= 3.;\n    pp.xz *= rot(pace);\n    pp += pos1;\n    float d1 = blobThing(pp, pos1, 0.);\n    \n    vec3 pos2 = vec3(0);\n    pp = p;\n    pp -= pos2;\n    pp.y += 3.;\n    pp.xz *= rot(2.*pOfst + pace);\n    pp += pos2;\n    float d2 = blobThing(pp, pos2, -25.625);\n    \n    vec3 pos6 = vec3(0);\n    pp = p;\n    pp -= pos6;\n    pp.xz *= rot(pOfst + pace);\n    pp += pos6;\n    float d6 = blobThing(pp, pos6, -5.25);\n    \n    vec3 pos3 = vec3(0, 1, 0);\n    float d3 = sphere(p, pos3, 5.);\n    \n    float g = 2., g2 = 10.;\n    float d4 = p.y + 15. + 2.*sin(p.x/g)*cos(p.z/g);\n    d4 += 5.*sin(iTime/2. + p.x/g2)*cos(iTime*1.5 + p.z/g2);\n    \n    float d5 = p.z - 5.;\n    \n    vec2 d = vec2(B1, d1);\n    \n    if(d2 < d.y)\n        d = vec2(B2, d2);\n    \n    if (d3 < d.y)\n        d = vec2(BALL, d3);\n    \n    if (d4 < d.y)\n        d = vec2(FLOOR, d4);\n    \n    /*if (d5 < d.y)\n        d = vec2(WALL, d5);*/\n    \n    if (d6 < d.y)\n        d = vec2(B3, d6);\n\t\n    return d;\n}\n\nvec3 getNormal(vec3 p)\n{\n \treturn normalize(vec3(\n        map(p + vec3(EPS, 0, 0)).y - map(p - vec3(EPS, 0, 0)).y,\n        map(p + vec3(0, EPS, 0)).y - map(p - vec3(0, EPS, 0)).y,\n        map(p + vec3(0, 0, EPS)).y - map(p - vec3(0, 0, EPS)).y\n        ));\n}\n\nfloat lighting(vec3 r)\n{\n    vec3 normal = getNormal(r);\n    \n    vec3 light = normalize(vec3(1, 1, -.7));\n    \n    float c = max(0.2, dot(normal, light));\n    \n    return c;\n}\n\nvec3 getColor(int n)\n{\n    if(n == B1)\n        return vec3(1, 0, 0);\n    else if(n == B2)\n        return vec3(0, 1, 0);\n    else if(n == B3)\n        return vec3(0, 0, 1);\n    else if(n == BALL)\n    {\n        vec3 c = vec3(.1, .5, .7);\n        c.xz *= rot(iTime*100.);\n        c.zy *= rot(-iTime*27.674);\n        return c;\n        //return vec3(0);\n        \n    }else if(n == FLOOR)\n        return vec3(.5, .5, .7);\n        //return vec3(0);\n    else if(n == WALL)\n        return vec3(.5, .5, .7);\n}\n\nvec4 march(vec3 ro, vec3 rd)\n{\n    vec4 data;\n    bool bounce = true;\n    \n    for(int i = 0; i < MAX_DEPTH && bounce; i++)\n    {\n        float d, dst;\n        vec3 ray = ro + d * rd;\n        \n        for(int j = 0; j < 256; j++)\n        {\n            ray = ro + d * rd;\n            vec2 rawData = map(ray);\n                        \n            if(rawData.y < EPS)\n            {\n                int obj = int(rawData.x);\n                vec3 initColor = getColor(obj) * lighting(ray);\n                \n                if(obj == BALL || obj == FLOOR)\n                    data.xyz += initColor;\n                else\n                {\n                    data.xyz += initColor;\n                    bounce = false;\n                }\n                \n                data.w = d;\n                \n                ro = ro + d * rd * .99;\n                rd = getNormal(ray);\n                d = 0.;\n                break;\n            }else if(d > MAX_DIST) break;   \n            \n            d += rawData.y * .5;\n        }\n    }\n    \n    //data.xyz /= float(MAX_DEPTH);\n    return data;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\tuv -= .5;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    vec3 ro = vec3(0, 17, -20);\n    //ro.yz *= rot(iMouse.y);\n    //ro.xz *= rot(iMouse.x);\n    ro.yz *= rot(10.*sin(iTime));\n    ro.xz *= rot(iTime*10.);\n    vec3 ta = vec3(0);\n    vec3 fw = normalize(ta - ro);\n    vec3 ri = normalize(vec3(fw.z, 0, -fw.x));\n    vec3 up = cross(fw, ri);\n    \n    float FOV = 1.1;\n    vec3 rd = mat3x3(ri, up, fw) * vec3(uv * FOV, 1);\n    \n    vec4 d = march(ro, rd);\n    vec3 col;\n\t\n    if(d.w < MAX_DIST)\n        col = d.xyz;\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define EPS 0.01\n#define MAX_DIST 1000.\n#define PI 3.141592654\n\nmat2x2 rot(float deg)\n{\n    float ang = deg * PI / 180.;\n    float s = sin(ang), c = cos(ang);\n    return mat2x2(c, s, -s, c);\n}\n\nfloat sphere(vec3 p, vec3 pos, float rad)\n{\n \treturn length(p - pos) - rad;   \n}\n\nfloat wall(vec3 p)\n{\n    //p.yz *= rot(iMouse.x);\n    \n    vec4 n = vec4(0, 1, 0, 0);\n    return dot(p,n.xyz) + n.w;\n}\n\n// From iq's website\n// https://iquilezles.org/articles/distfunctions\nfloat dot2( in vec3 v ) { return dot(v,v); }\nfloat quad( vec3 p,  vec3 pos, vec2 size)\n{\n    vec3 a = pos + vec3(1, -1, 0) * vec3(size, 0);\n    vec3 b = pos + vec3(1, 1, 0) * vec3(size, 0);\n    vec3 c = pos + vec3(-1, 1, 0) * vec3(size, 0);\n    vec3 d = pos + vec3(-1, -1, 0) * vec3(size, 0);\n        \n    vec3 ba = b - a; vec3 pa = p - a;\n    vec3 cb = c - b; vec3 pb = p - b;\n    vec3 dc = d - c; vec3 pc = p - c;\n    vec3 ad = a - d; vec3 pd = p - d;\n    vec3 nor = cross( ba, ad );\n\n    return sqrt(\n    (sign(dot(cross(ba,nor),pa)) +\n     sign(dot(cross(cb,nor),pb)) +\n     sign(dot(cross(dc,nor),pc)) +\n     sign(dot(cross(ad,nor),pd))<3.0)\n     ?\n     min( min( min(\n     dot2(ba*clamp(dot(ba,pa)/dot2(ba),0.0,1.0)-pa),\n     dot2(cb*clamp(dot(cb,pb)/dot2(cb),0.0,1.0)-pb) ),\n     dot2(dc*clamp(dot(dc,pc)/dot2(dc),0.0,1.0)-pc) ),\n     dot2(ad*clamp(dot(ad,pd)/dot2(ad),0.0,1.0)-pd) )\n     :\n     dot(nor,pa)*dot(nor,pa)/dot2(nor) );\n}\n\nfloat box( vec3 p, vec3 pos, vec3 size )\n{\n    p -= pos;\n  \tvec3 d = abs(p) - size;\n  \treturn length(max(d,0.0)) + min(max(d.x,max(d.y,d.z)),0.0);\n}\n\nfloat opSmoothUnion( float d1, float d2, float k )\n{\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}","name":"Common","description":"","type":"common"}]}