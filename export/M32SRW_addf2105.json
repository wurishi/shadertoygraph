{"ver":"0.1","info":{"id":"M32SRW","date":"1710336676","viewed":40,"name":"shuriken-2024","username":"leborgnekevin","description":"shuriken go vrouum","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["shuriken"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 Rect(vec2 uv, vec4 size, float blur, vec2 position, vec3 color){\n    uv -= position;\n    \n    float left = smoothstep(size.x - blur, size.x + blur, uv.x);\n    float right = smoothstep(size.y + blur, size.y - blur, uv.x);\n    \n    float up = smoothstep(size.z - blur, size.z + blur, uv.y);\n    float down = smoothstep(size.w + blur, size.w - blur, uv.y);\n    \n    \n    return (left * right * up * down) * color;\n}\nfloat sdCircle(in vec2 p, in float r)\n{\n    return length(p) - r;\n}\n\nvec2 rot2d(vec2 uv, float t)\n{\n\n\n    return vec2(uv.x * sin(t) + uv.y * cos(t), uv.x * cos(t) - uv.y * sin(t));\n\n}\nfloat shuriken2D(vec2 uv)\n{\n    \n    uv = rot2d(uv, iTime * 0.25);\n    \n    // shuriken\n    vec2 ruv = rot2d(uv, -0.8);\n    float ax = abs(ruv.x);\n    float ay = abs(ruv.y);\n    \n    vec2 rruv = rot2d(uv, -2.555);\n    float bx = abs(rruv.x);\n    float by = abs(rruv.y);\n    \n    float j = -0.7;\n    \n    vec2 ruvi = rot2d(uv, 0.25);\n    float cx = abs(ruvi.x);\n    float cy = abs(ruvi.y);\n    \n    return smoothstep(-1.49, -1.51, max(abs(ax), abs(ay)) + j * max(abs(bx), abs(by)) - 2.0)\n    - smoothstep(0.41, 0.35, max(abs(cx), abs(cy)));\n    \n\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Calcul de la position du shuriken\n    vec2 uv = fragCoord.xy / iResolution.xy * 2.0 - 1.0;\n    uv.x *= (iResolution.x / iResolution.y);    \n    uv *= 12.0;\n\n    float initialCercleSpeed = .5;\n    float circleSIze = 1.;\n    \n    // Vitesse de rotation des cercles\n    float circleSpeed1 = initialCercleSpeed; // Sens horaire\n    float circleSpeed2 = -initialCercleSpeed; // Sens anti-horaire\n    float circleSpeed3 = initialCercleSpeed; // Sens horaire\n    float circleSpeed4 = -initialCercleSpeed; // Sens anti-horaire\n    \n    // Calcul de la position des cercles\n    float circleDistance = 5.; // Distance entre le shuriken et les cercles\n  \n    vec2 circleCenter1 = vec2(cos(iTime * circleSpeed1) * circleDistance, sin(iTime * circleSpeed1) * circleDistance);\n    vec2 circleCenter2 = vec2(cos(iTime * circleSpeed2) * circleDistance, sin(iTime * circleSpeed2) * circleDistance) ;\n    vec2 circleCenter3 = vec2(cos(iTime * circleSpeed3+3.14) * circleDistance, sin(iTime * circleSpeed3) * circleDistance);\n    vec2 circleCenter4 = vec2(cos(iTime * circleSpeed4+3.14) * circleDistance, sin(iTime * circleSpeed4) * circleDistance) ;\n    \n    vec2 circleUV1 = uv - circleCenter1; // Ajustement de la position du cercle par rapport au centre\n    vec2 circleUV2 = uv - circleCenter2;\n    vec2 circleUV3 = uv - circleCenter3;\n    vec2 circleUV4 = uv - circleCenter4;\n    \n    // Calcul de la couleur du shuriken\n    vec4 shurikenFragColor = vec4(vec3(shuriken2D(uv)), 1.0);\n    \n   \n    vec2 buv = fragCoord.xy / iResolution.xy * 2.0 - 1.0;\n    buv *= 0.5;   \n    buv.y += cos(cos(iTime/2.0 + buv.x));\n    float gradient = (buv.y + 0.5) * 0.5;\n    vec3 backgroundColor1 = vec3(0., 0.1, 0.3); \n    vec3 backgroundColor2 = vec3(0.4, 0., .0);\n    vec3 backgColour = mix(backgroundColor1, backgroundColor2, gradient); // Interpolation linéaire des couleurs\n    vec3 backgroundFragColor = Rect(vec2(buv.x, buv.y), vec4(-1., 1, -0.5, 0.1), 0.001, vec2(0., 0.5), backgColour); \n    vec4 backgroundFragColorVec4 = vec4(backgroundFragColor, 1.0); // Convertit la couleur en vec4\n    \n\n    // Calcul de la couleur des cercles (gradient)\n    float distanceFromCenter1 = length(circleUV1); // Distance from the center of circle 1\n    float distanceFromCenter2 = length(circleUV2); // Distance from the center of circle 2\n    float distanceFromCenter3 = length(circleUV3); // Distance from the center of circle 3\n    float distanceFromCenter4 = length(circleUV4); // Distance from the center of circle 4\n\n    float colorVariation1 = sin(iTime) * 0.5 + 0.3;\n    float colorVariation2 = cos(iTime) * 0.5 + 0.3;\n    vec3 circleColorBase1 = vec3(0., 0., colorVariation2); \n    vec3 circleColorBase2 = vec3(colorVariation1, 0., .0);\n    \n    \n    vec3 circleColor1 = mix(circleColorBase2, circleColorBase1, distanceFromCenter1 / circleSIze); // Interpolate between background colors based on distance from center\n    vec3 circleColor2 = mix(circleColorBase2, circleColorBase1, distanceFromCenter2 / circleSIze);\n    vec3 circleColor3 = mix(circleColorBase2, circleColorBase1, distanceFromCenter3 / circleSIze);\n    vec3 circleColor4 = mix(circleColorBase2, circleColorBase1, distanceFromCenter4 / circleSIze);\n    \n    vec4 circleFragColor1 = vec4(circleColor1, 1.0);\n    vec4 circleFragColor2 = vec4(circleColor2, 1.0);\n    vec4 circleFragColor3 = vec4(circleColor3, 1.0);\n    vec4 circleFragColor4 = vec4(circleColor4, 1.0);\n\n    // Mélange des couleurs en fonction des conditions\n    fragColor = mix(shurikenFragColor, backgroundFragColorVec4, step(shuriken2D(uv), 0.0));\n    fragColor = mix(fragColor, circleFragColor1, step(sdCircle(circleUV1, circleSIze), 0.0));\n    fragColor = mix(fragColor, circleFragColor2, step(sdCircle(circleUV2, circleSIze), 0.0));\n    fragColor = mix(fragColor, circleFragColor3, step(sdCircle(circleUV3, circleSIze), 0.0));\n    fragColor = mix(fragColor, circleFragColor4, step(sdCircle(circleUV4, circleSIze), 0.0));\n}\n\n\n","name":"Image","description":"","type":"image"}]}