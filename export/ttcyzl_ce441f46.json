{"ver":"0.1","info":{"id":"ttcyzl","date":"1609724160","viewed":379,"name":"ShaderRoyale#3_CubesInMyMind","username":"lechuga","description":" 2do lugar - Hogmanay Party Shader Royale\n\ni change some stuff, so it's not totally the original, but the shapes reminds the same.\n\nI dedicate this to zozo uwu ;\n\nTwitch stream here -> https://www.twitch.tv/videos/856735468\n\nThank you all for support me !","likes":10,"published":1,"flags":0,"usePreview":0,"tags":["cubes","shader","purple","reflect","neurons","royale"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sf3Rn","filepath":"/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","previewfilepath":"/media/ap/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Licensed by a Vison\n\n#define time mod(iTime, 25.)\n#define m -texture(iChannel0, vec2(0.001, 1.)).x * 2.2\n#define t1 time*10.\n#define rot(a) mat2(cos(a), sin(a) ,-sin(a), cos(a))\n#define pi acos(-1.)\n#define tau pi*2.\n\nfloat rand(vec2 uv){\n  return fract(sin(dot(uv*.23244*uv.yx*.15756, vec2(234534.4234234)))*2345653.23423423);\n}\nconst float rep = 100.;\n\nfloat acumNeu = 1.;\n//const float rep5 = 60.;\nfloat base (inout vec3 p, inout float id){\n  vec3 p1 = p;\n  vec2 g = floor(p1.xy/rep-.5);\n  id = rand(g+4.324);\n  \n  p1.y += t1*1.5;\n  //p1.xz *= rot(tau+id*2.7);\n  p1.zy *= rot(tau+id*9.7);\n  \n  p1.x += sin(p1.y * 0.144+t1*.05) * 2.-.5;\n  p1.z += sin(p1.y*0.96554+t1*.06)*.5-.5;\n  p1.xz = (fract(p1.xz/rep-.5)-.5)*rep;\n  \n  //p1.x = abs(p1.x)-18.;\n  \n  p = p1;\n  float neu = length(p1.xz)-.6*sin(time+p1.x)*sin(time+p1.y)*sin(time+p1.z)*.5-.5;\n  \n  acumNeu += 1./(.1+neu*neu);\n  return neu;\n}\n\nfloat smin(float a, float b, float k){\n  float h = max(k-abs(a-b), 0.)/k;\n  return min(a, b)-pow(h, 3.)*k*(1.0/6.0);\n}\n\nfloat neurons(vec3 p){\n  vec3 p1 = p;\n  float id;\n  float d = base(p1, id);\n  p1.y -= t1*1.5;\n  float e = length(p1)-4.5-id m m m * sin(p1.x+t1)*sin(p1.y+t1-id)*sin(p1.z+t1)*.5-.5;\n  \n  return smin(d, e, 10.);\n}\n\nfloat acum1 = .0;\nconst float rep3 = 50.;\nconst float MAX_DIST = 70.;\n\n\nfloat sb(vec3 p, vec3 s){\n  vec3 q = abs(p)-s m;\n  return max(max(q.y, q.z), q.x);\n}\nconst float rep2 = 35.;\n\n\n\nbool coli = false;\nfloat cubs(vec3 p){\n  float d = neurons(p);\n  vec3 p1 = p;\n  \n  vec2 g = floor(p1.xz/rep2-.5);\n  float id = rand(g+4.324);\n  p1.xz *= rot(time*.013234235*id*id);\n  p1.yz *= rot(time*.02342345*id*id);\n  p1 -= vec3(id*6.+time*2., id*3.5, id*6.);\n  p1 = (fract(p1/rep2-.5)-.5)*rep2;\n  \n  // ---------- This is not part of the original-----------\n  p1.zy *= rot(time*2.+id);\n \n  // ---------- end----------------------------------------\n  \n\n  p1 = abs(p1)-.3 m m; // MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\n  \n  \n  \n  p1.xz -= time*.1;\n  p1.xz *= rot(time*id*.45);\n  p1.yz *= rot(time*id*.55);\n  //p1.x += sin(time)*5.5-.5;\n  p1 -= vec3(id*4., id*2., id*.2);\n  float b = sb(p1, vec3(.5, .1, 1.)+(id*2.))*.68+sin(t1+id*2.)*.5-.5;\n  b *= .85;\n  acum1 += .8/(5.+b*b*b);\n  coli = b < 50.;\n  \n  p1.y -= 10.5+t1;\n  d = smin(max(d, p1.y-5.2), b, 10.);\n  \n  return d;\n}\n\n\nbool coli2 = false;\nfloat laststand(vec3 p){\n  float d = cubs(p);\n  // not idea how to contine... mmmmm m mm mm m m m\n  \n  vec3 p1 = p;\n  \n  // woa... what have i done o_o\n  /*\n  float dd = pow(p1.z*60002.234234, 8.);\n  p1.x += sin(time+dd*2.)*2.;\n  p1.z += sin(time+dd*1.3254)*4.;\n  float rrr = 50.-sin(time+p1.x*2.)*sin(time+p1.y)*cos(p1.z+time)*.25-.0001 m m m m m m m m;\n  float cil = length(p1.xy)-rrr ;\n  //coli2 = cil < .5;\n  p = p1;\n  */\n  // didn't finish this, out of ideas :'c ggwp\n  return d;\n}\n\n#define map(p) laststand(p)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n  uv -= 0.5;\n  uv /= vec2(iResolution.y / iResolution.x, 1);\n\n\n  vec3 s = vec3(-7.0001, -6.0001, -6.), r = normalize(vec3(-uv, .56 m*.025));\n  s.yz -= t1*2.;\n  //s.yz *= rot(sin(time)*.15);\n  \n  //s.xy *= rot(cos(time+s.z/pi)*.01);\n  //s.zx *= rot(cos(time+s.x/pi)*.01);\n\n  //s.z -= t1;\n  //\n  \n  vec3 p = s, col = vec3(0.);\n  float i = 0.;\n  const float MAX = 80.;\n  const vec2 off = vec2(0.145645, 0.);\n  vec3 n;    \n  for(; i < MAX; i++){\n    float d = map(p);\n    if(abs(d) < 0.001){\n      \n      n = normalize(d-vec3(map(p-off.xyy), map(p-off.yxy) , map(p-off.yyx)));\n      if(coli || coli2){\n        r = reflect(n,r);\n        d+=20.5;\n        //d*=.1;\n      }\n      else break;\n    }\n    if(d > MAX) break;\n    p+=d*r;\n  }\n  \n  n = normalize(map(p)-vec3(map(p-off.xyy), map(p-off.yxy) , map(p-off.yyx)));\n  vec3 l = normalize(vec3(-1.));\n  //col += 1.-i/MAX;\n  col += clamp(dot(n, l), 0., 1.);\n  col += acum1*vec3(0.14, .32, .66)*.38;\n  col += acumNeu*vec3(1., 0., 0.)*.96;\n  \n  col *= 1.-max(length(p-s)/MAX_DIST*0.25, 0.);\n\n  \n  col -= smoothstep(0., 1.,col)/tau;\n\n  \n  //col += rand(uv);\n  fragColor = vec4(col,1.0);\n    \n}","name":"Image","description":"","type":"image"}]}