{"ver":"0.1","info":{"id":"XssyRM","date":"1487473145","viewed":493,"name":"Rippling Normals","username":"Frizzil","description":"Distort normals via a trochoid function, giving the appearance of a watery rippling effect. Could be thought of as on orthographic projection of a rippling surface from above.","likes":13,"published":1,"flags":0,"usePreview":0,"tags":["water","normal","ripple","trochoid"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":2,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sX3zn","filepath":"/media/a/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png","previewfilepath":"/media/ap/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nconst vec3 luma = vec3( 0.2125, 0.7154, 0.0721 );\nconst float lumaSum = luma.x + luma.y + luma.z;\n\nconst vec3 eyeDir = vec3( 0.0, 0.0, 1.0 );\nconst vec3 lightDir = normalize( vec3( 0.3, 0.2, 1.0 ) );\nconst mat3 eyeToIrrTransform = mat3(\n    1.0, 0.0, 0.0,\n    0.0, 1.0, 0.0,\n    0.0, 0.0, 1.0\n);\n\nconst float dirLightStrength = 0.6;\nconst float envLightStrength = 0.4;\nconst float specWeight = 0.01;\nconst float specPow = 20.0;\n\nconst float matScrollPerSec = 0.03;\nconst float invMatNormalScale = 0.03;\nconst vec3 matColorA = vec3( 0.25, 0.27, 0.17 );\nconst vec3 matColorB = vec3( 1.00, 0.9, 0.78 );\nconst float matColorAEnd = 0.8;\n\nconst bool useSine = false;\n\nconst float waveHeight = 10.0;\nconst float wavePerDistance = 0.1;\nconst float wavePerSecond = -3.5;\nconst float trochoidA = 0.55;\nconst int trochoidApproxIts = 6;\n\n///////////////////////////////////////\n\nfloat getMaterialHeight( vec2 uv )\n{\n    return dot( texture( iChannel0, uv ).rgb, luma ) / lumaSum;\n}\n\nvec3 getMaterialNormal( vec2 uv )\n{\n    vec3 offset = vec3( vec2(1.0) / iChannelResolution[0].xy, 0.0 );\n    float matHeightX0 = getMaterialHeight( uv - offset.xz );\n    float matHeightX1 = getMaterialHeight( uv + offset.xz );\n    float matHeightY0 = getMaterialHeight( uv - offset.zy );\n    float matHeightY1 = getMaterialHeight( uv + offset.zy );\n    return normalize( vec3(\n        (matHeightX1 - matHeightX0) * 0.5,\n        (matHeightY1 - matHeightY0) * 0.5,\n        invMatNormalScale ) );\n}\n\n//////////////////////////////////////\n// Wave inputs\n\nfloat getWaveX( vec2 coord )\n{\n    float radius = length( coord );\n    return wavePerDistance * radius + wavePerSecond * iTime;\n}\n\nvec2 getWaveXGrad( vec2 coord, float waveX )\n{\n    float radius = length( coord );\n    return coord * (wavePerDistance / radius);\n}\n\n//////////////////////////////////////\n// Sine wave\n\nfloat getSineWave( vec2 coord )\n{\n    float waveX = getWaveX( coord );\n    return waveHeight * sin( waveX );\n}\n\nvec2 getSineWaveGrad( vec2 coord )\n{\n    float waveX = getWaveX( coord );\n    vec2 waveXGrad = getWaveXGrad( coord, waveX );\n    return waveHeight * cos( waveX ) * waveXGrad;\n}\n\n\n//////////////////////////////////////\n// Trochoid wave\n// Reference: https://www.shadertoy.com/view/MtSSDG\n\n#define TR_C(x)  a*cos((x)-t)\n#define TR_S(x)  a*sin((x)-t)\n#define TR_X0(x,xx)     (x)-TR_C(xx)\n#define TR_X0_D(dx,xx,dxx)  (dx)+TR_S(xx)*(dxx)\n\nfloat trochoid(float x)\n{\n    const float t = 0.0;\n    const float a = trochoidA;\n    \n    float xx = TR_X0(x, x);\n    for (int i = 1; i < trochoidApproxIts; ++i)\n        xx = TR_X0(x, xx);\n    \n    return TR_S(xx);\n}\n\nvec2 trochoidD(float x, vec2 dx)\n{\n    const float t = 0.0;\n    const float a = trochoidA;\n    \n    vec2 dxx = TR_X0_D(dx, x, dx);\n    float xx = TR_X0(x, x);\n    \n    for (int i = 1; i < trochoidApproxIts; ++i)\n    {\n        dxx = TR_X0_D(dx, xx, dxx);\n        xx = TR_X0(x, xx);\n    }\n    \n    return TR_C(xx) * dxx;\n}\n\nfloat getTrochoidWave( vec2 coord )\n{\n    float waveX = getWaveX( coord );\n    return waveHeight * trochoid( waveX );\n}\n\nvec2 getTrochoidWaveGrad( vec2 coord )\n{\n    float waveX = getWaveX( coord );\n    vec2 waveXGrad = getWaveXGrad( coord, waveX );\n    return waveHeight * trochoidD( waveX, waveXGrad );\n}\n\n///////////////////////////////////////////\n\n\nvec3 chainNormalByHeightGrad( vec3 normal, vec2 heightGrad )\n{\n    normal.xy -= heightGrad * normal.z;\n    return normalize( normal );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 screenPos = fragCoord.xy;\n    vec2 mousePos = iMouse.y <= 0.0 ? iResolution.xy * 0.5 : iMouse.xy;\n    \n    vec2 matUv = screenPos * (iChannelResolution[0].xy / iResolution.xx) / 400.0 + iTime * matScrollPerSec;\n    float albedoWeight = smoothstep( 0.0, matColorAEnd, dot( luma, texture( iChannel0, matUv ).rgb ) / lumaSum );\n    vec3 albedo = mix( matColorA, matColorB, albedoWeight );\n    vec3 normal = getMaterialNormal( matUv );\n    \n    vec2 waveIn = (screenPos - mousePos) * (iChannelResolution[0].xy / iResolution.xx);\n    vec2 waveGrad = useSine ? getSineWaveGrad( waveIn ) : -getTrochoidWaveGrad( waveIn );\n    vec3 normalW = chainNormalByHeightGrad( normal, waveGrad );\n    vec3 reflectW = reflect( eyeDir, normalW );\n    \n    // Do energy-conserving Blinn-Phong\n    vec3 directLighting;\n    {\n        vec3 halfW = normalize( lightDir + eyeDir );\n        float cosNL = clamp( dot( normalW, lightDir ), 0.0, 1.0 );\n        float cosNH = clamp( dot( normalW, halfW ), 0.0, 1.0 );\n        vec3 directDiffuse = cosNL * albedo;\n        vec3 directSpec = vec3( 1.0 ) * pow( cosNH, specPow ) * ((specPow + 8.0) * 0.125);\n        directLighting = dirLightStrength * mix( directDiffuse, directSpec, specWeight );\n    }\n    \n    // Uhhh whatever model these radiance/irradiance maps are supposed to be\n    vec3 environmentLighting;\n    {\n        vec3 envDiffuse = albedo * texture( iChannel1, eyeToIrrTransform * normalW ).rgb;\n        vec3 envSpecular = texture( iChannel2, eyeToIrrTransform * reflectW ).rgb;\n        environmentLighting = envLightStrength * mix( envDiffuse, envSpecular, specWeight );\n    }\n    \n    fragColor.rgb = directLighting + environmentLighting;\n    //fragColor.rgb = vec3( 0.5 + 0.5 * getTrochoidWave( waveIn ) / waveHeight );\n    fragColor.a = 1.0;\n}","name":"Image","description":"","type":"image"}]}