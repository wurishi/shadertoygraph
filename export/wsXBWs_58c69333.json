{"ver":"0.1","info":{"id":"wsXBWs","date":"1589258239","viewed":538,"name":"Sphere Inversion of Objects","username":"blackle","description":"inverting an SDF using knighty's normalization trick. see the conversation here: https://www.shadertoy.com/view/tdfBW2","likes":16,"published":3,"flags":0,"usePreview":0,"tags":["3d","sdf","inversion"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//CC0 1.0 Universal https://creativecommons.org/publicdomain/zero/1.0/\n//To the extent possible under law, Blackle Mori has waived all copyright and related or neighboring rights to this work.\n\n//uncomment to enable SDF resampling, see comment inside ifdef\n//#define RESAMPLE_SDF\n\n\nfloat box(vec3 p, vec3 d) {\n    vec3 q = abs(p)-d;\n    return length(max(q, 0.)) + min(0., max(q.x,max(q.y,q.z)));\n}\n\nfloat linedist(vec3 p, vec3 a, vec3 b) {\n    float k = dot(p-a,b-a)/dot(b-a,b-a);\n    return distance(p,mix(a,b,clamp(k,0.,1.)));\n}\n\n//multiplication by the quaternion (.5,.5,.5,.5), see https://www.shadertoy.com/view/wdXBD2\nvec4 rot4d(vec4 p) {\n    return vec4(dot(p,vec4(1)), p.yzw + p.zwy - p.wyz - p.xxx)/2.;\n}\n\nfloat box(vec4 p, vec4 d) {\n    vec4 q = abs(p)-d;\n    return length(max(q, 0.)) + min(0., max(max(q.x,q.w),max(q.y,q.z)));\n}\n\nfloat weirdshape_1(vec3 p) {\n    vec4 p4d = vec4(p, 0.);\n    p4d = rot4d(p4d);\n    return box(p4d, vec4(.1));\n}\n\nfloat weirdshape_2(vec3 p) {\n    vec4 p4d = vec4(p, 0.);\n    p4d = rot4d(p4d);\n    p4d = sqrt(p4d*p4d+0.0001); //smooth abs\n    p4d = rot4d(p4d);\n    p4d = rot4d(p4d);\n    return box(p4d, vec4(.1));\n}\n\nvec3 erot(vec3 p, vec3 ax, float ro) {\n    return mix(dot(p,ax)*ax,p,cos(ro)) + sin(ro)*cross(ax,p);\n}\n\nfloat scene2(vec3 p) {\n    p -= vec3(0.,0.,0.5);\n    p = erot(p, vec3(0,1,0), iTime);\n    p = erot(p, vec3(0,0,1), iTime/2.);\n    p = erot(p, vec3(1,0,0), iTime/3.);\n    float time = iTime*0.674;\n    float mixval_a = smoothstep(-.25,.25,sin(time));\n    float mixval_b = smoothstep(-.15,.15,sin(time/2.));\n    float bx = box(p, vec3(0.1));\n    float ln = linedist(p, vec3(0.1), vec3(-0.1))-.05;\n    float weird_1 = weirdshape_1(p);\n    float weird_2 = weirdshape_2(p);\n    return mix(mix(ln, bx, mixval_a), mix(weird_2, weird_1, mixval_a), mixval_b);\n}\n\nvec3 circle_invert(vec3 p) {\n    return p/dot(p,p);\n}\n\nfloat fix_dist(vec3 p, float d) {\n    //normalize the inverted distance. thanks @knighty!\n\treturn dot(p,p)*d/(1.+length(p)*abs(d));\n}\n\nfloat scene(vec3 p) {\n    p += vec3(0,0,2.5);\n\tfloat d = scene2(circle_invert(p));\n\td = fix_dist(p, d);\n\n#ifdef RESAMPLE_SDF\n    for (int i = 0; i < 5; i++) {\n        vec3 circ_front = circle_invert(p-normalize(p)*d);\n        vec3 circ_back = circle_invert(p+normalize(p)*d);\n        //resample the SDF at the true center of the inverted circle centered at p of radius d.\n        //this improves the SDF quality by a very small amount and is not needed.\n        //I just decided to keep it here because it does indeed improve thngs\n    \tvec3 p_new = (circ_front + circ_back)/2.;\n\t\td = scene2(p_new);\n\t\td = fix_dist(p, d);\n    }\n#endif\n\n    //the SDF goes to zero at the origin, which is a concequence of the circle inversion\n    //to prevent a sphere from appearing there, we intersect with a sphere around our inverted object\n\treturn max(d-0.05, length(p-vec3(0,0,2.5))-1.5);\n}\n\nvec3 norm(vec3 p) {\n    mat3 k = mat3(p,p,p)-mat3(0.001);\n    return normalize(scene(p) - vec3(scene(k[0]),scene(k[1]),scene(k[2])));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    vec2 mouse = (iMouse.xy-0.5*iResolution.xy)/iResolution.y;\n\n    vec3 cam = normalize(vec3(1.4,uv));\n    vec3 init = vec3(-4,0,-.3);\n\n    float yrot = 0.35;\n    float zrot = 0.;\n    if (iMouse.z > 0.) {\n        yrot += -4.*mouse.y;\n        zrot += 4.*mouse.x;\n    }\n    cam = erot(cam, vec3(0,1,0), yrot);\n    init = erot(init, vec3(0,1,0), yrot);\n    cam = erot(cam, vec3(0,0,1), zrot);\n    init = erot(init, vec3(0,0,1), zrot);\n\n    vec3 p = init;\n    bool hit = false;\n    //raymarching\n    for (int i = 0; i < 160 && !hit; i++) {\n        float dist = scene(p);\n        hit = dist*dist < 1e-6;\n        p += dist*cam;\n    }\n    //shading\n    vec3 n = norm(p);\n    vec3 r = reflect(cam,n);\n    float fact1 = length(sin(r*2.)*0.5+0.5)/sqrt(3.);\n    float fact2 = length(sin(-r*3.)*0.5+0.5)/sqrt(3.);\n    vec3 col1 = vec3(0.1,0.2,0.8)*fact1 + pow(fact1, 10.);\n    vec3 col2 = vec3(0.5,0.2,0.1)*fact2 + pow(fact2, 10.);\n    fragColor.xyz = sqrt(hit ? col1+col2 : vec3(0.01));\n}","name":"Image","description":"","type":"image"}]}