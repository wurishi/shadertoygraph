{"ver":"0.1","info":{"id":"XscSWH","date":"1459348312","viewed":750,"name":"Q*bert-ify","username":"pov","description":"My first shader :)\n\nTransform your video/image into a isometric 3d cube map like in q*bert.","likes":16,"published":1,"flags":2,"usePreview":0,"tags":["3d","cube","qbert","isometric"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sf3zn","filepath":"/presets/webcam.png","previewfilepath":"/presets/webcam.png","type":"webcam","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float light = 1.15;\nconst float dark = 0.85;\n\nbool tri(const vec2 p1, const vec2 p2, const vec2 p3, const vec2 p)\n{\n    float alpha = ((p2.y - p3.y)*(p.x - p3.x) + (p3.x - p2.x)*(p.y - p3.y)) /\n        ((p2.y - p3.y)*(p1.x - p3.x) + (p3.x - p2.x)*(p1.y - p3.y));\n\n    float beta = ((p3.y - p1.y)*(p.x - p3.x) + (p1.x - p3.x)*(p.y - p3.y)) /\n       ((p2.y - p3.y)*(p1.x - p3.x) + (p3.x - p2.x)*(p1.y - p3.y));\n\n    float gamma = 1.0 - alpha - beta;\n    \n    return (alpha >= 0.0 && beta >= 0.0 && gamma >= 0.0);      \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //fragColor = vec4(0.0, 0.0, 0.0, 0.0); return;\n    \n    float cellFactor = floor(clamp(iResolution.x/30., 20., 100.)/6.)*6.;\n    vec2 cellSize = vec2(cellFactor, cellFactor*1.5);\n    float zoom = max(iResolution.x/iChannelResolution[0].x, iResolution.y/iChannelResolution[0].y);\n\n    vec2 cell = vec2(mod(fragCoord.x, cellSize.x), mod(fragCoord.y, cellSize.y));\n    vec2 norm = cell.xy / cellSize;\n    vec2 res = vec2(0.0, 0.0);\n    float bright = 1.0;\n    \n    //1\n    if (tri(vec2(0.0,0.0), vec2(1.0,0.0), vec2(0.5,0.125), norm)) {res = vec2(0.5, -0.125); bright = light;}\n    //2\n    else if (tri(vec2(0.0,0.0), vec2(0.5,0.125), vec2(0.0,.375), norm)) {res = vec2(0.0, 0.375); bright = dark;}\n    else if (tri(vec2(0.5,0.125), vec2(0.5,0.5), vec2(0.0,.375), norm)) {res = vec2(0.0, 0.375); bright = dark;}\n    //3\n    else if (tri(vec2(1.0,0.0), vec2(1.0,.375), vec2(0.5,0.125), norm)) {res = vec2(1.0, 0.375);}\n    else if (tri(vec2(0.5,0.125), vec2(0.5,0.5), vec2(1.0,.375), norm)) {res = vec2(1.0, 0.375);}\n    //4\n    else if (tri(vec2(0.0,.375), vec2(0.0,.625), vec2(0.5,0.5), norm)) {res = vec2(0.0, 0.375); bright = light;}\n    //5\n    else if (tri(vec2(1.0,.375), vec2(1.0,.625), vec2(0.5,0.5), norm)) {res = vec2(1.0, 0.375); bright = light;}\n    //6\n    else if (tri(vec2(0.5,0.5), vec2(0.0,.625), vec2(0.0,1.0), norm)) {res = vec2(0.5, 0.875);}\n    else if (tri(vec2(0.0,1.0), vec2(0.5,0.875), vec2(0.5,0.5), norm)) {res = vec2(0.5, 0.875);}\n    //7\n    else if (tri(vec2(0.5,0.5), vec2(1.0,.625), vec2(1.0,1.0), norm)) {res = vec2(0.5, 0.875); bright = dark;}\n    else if (tri(vec2(1.0,1.0), vec2(0.5,0.875), vec2(0.5,0.5), norm)) {res = vec2(0.5, 0.875); bright = dark;}\n    //8\n    else if (tri(vec2(0.0,1.0), vec2(1.0,1.0), vec2(0.5,0.875), norm)) {res = vec2(0.5, 0.875); bright = light;}\n        \n    fragColor = vec4(0.0,0.0,0.0,0.0);\n    for(float i = -1.5; i<1.5; i+=1.0)\n    {\n        for (float j = -1.5; j<1.5; j+=1.0)\n        {\n            fragColor += clamp(texture(\n                iChannel0, \n                vec2(\n                    ((floor(fragCoord.x/cellSize.x)+res.x)*cellSize.x+i)/iChannelResolution[0].x,\n                    ((floor(fragCoord.y/cellSize.y)+res.y)*cellSize.y+j)/iChannelResolution[0].y\n                ) / zoom\n            )*bright, 0.0, 1.0);\n        }\n    }\n    fragColor = clamp(fragColor / 9.0, 0.0, 1.0);\n    \n    //vec2 uv = fragCoord.xy/iResolution.xy;\n    //uv.x = uv.x/(iChannelResolution[0].x/iChannelResolution[0].y)*(iResolution.x/iResolution.y);\n    \n    //fragColor = texture(iChannel0, uv);\n}","name":"Image","description":"","type":"image"}]}