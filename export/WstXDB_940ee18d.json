{"ver":"0.1","info":{"id":"WstXDB","date":"1572803986","viewed":568,"name":"Surface Area Calculator","username":"PrzemyslawZaworski","description":"Shader computes ratio between blue area and window surface in percents.\nSee \"Common\" for better performance and lower quality.","likes":5,"published":1,"flags":32,"usePreview":0,"tags":["math","geometry","cartography"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// fuction PrintValue from: https://www.shadertoy.com/view/4sBSWW\nfloat PrintValue( vec2 vStringCoords, float fValue, float fMaxDigits, float fDecimalPlaces )\n{       \n    if ((vStringCoords.y < 0.0) || (vStringCoords.y >= 1.0)) return 0.0;   \n    bool bNeg = ( fValue < 0.0 );\n\tfValue = abs(fValue);  \n\tfloat fLog10Value = log2(abs(fValue)) / log2(10.0);\n\tfloat fBiggestIndex = max(floor(fLog10Value), 0.0);\n\tfloat fDigitIndex = fMaxDigits - floor(vStringCoords.x);\n\tfloat fCharBin = 0.0;\n\tif(fDigitIndex > (-fDecimalPlaces - 1.01)) \n    {\n\t\tif(fDigitIndex > fBiggestIndex) \n        {\n\t\t\tif((bNeg) && (fDigitIndex < (fBiggestIndex+1.5))) fCharBin = 1792.0;\n\t\t} \n        else \n        {\t\t\n\t\t\tif(fDigitIndex == -1.0) \n            {\n\t\t\t\tif(fDecimalPlaces > 0.0) fCharBin = 2.0;\n\t\t\t} \n            else \n            {\n                float fReducedRangeValue = fValue;\n                if(fDigitIndex < 0.0) { fReducedRangeValue = fract( fValue ); fDigitIndex += 1.0; }\n\t\t\t\tfloat fDigitValue = (abs(fReducedRangeValue / (pow(10.0, fDigitIndex))));\n                int x = int(floor(mod(fDigitValue, 10.0)));\n                fCharBin = x==0?480599.0:x==1?139810.0:x==2?476951.0:x==3?476999.0:x==4?350020.0:x==5?464711.0:x==6?464727.0:x==7?476228.0:x==8?481111.0:x==9?481095.0:0.0;\n\t\t\t}\n        }\n\t}\n    return floor(mod((fCharBin / pow(2.0, floor(fract(vStringCoords.x) * 4.0) + (floor(vStringCoords.y * 5.0) * 4.0))), 2.0));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 vColour = vec3(0.0);\n\tvec2 vFontSize = vec2(48.0, 60.0);\n    float k = texelFetch(iChannel0,ivec2(0,0),0).r;\n\tvColour = mix( vColour, vec3(1.0, 1.0, 1.0), PrintValue( (fragCoord - vec2(iResolution.x-500.0, 30.0)) / vFontSize, k, 6.0, 2.0));\n    float source = texture(iChannel1,fragCoord.xy/iResolution.xy).r;\n\tfragColor = vec4(vColour.xyz,1.0) + vec4(0,0,source,1);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// Larger value = better performance and lower quality\nfloat accuracy = 1.0;","name":"Common","description":"","type":"common"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"float hash (vec3 n) \n{ \n\treturn fract(sin(dot(n, vec3(95.43583, 93.323197, 94.993431))) * 65536.32);\n}\n\nfloat noise (vec3 n)\n{\n    vec3 base = floor(n * 64.0) * 0.015625;\n    vec3 dd = vec3(0.015625, 0.0, 0.0);\n    float a = hash(base);\n    float b = hash(base + dd.xyy);\n    float c = hash(base + dd.yxy);\n    float d = hash(base + dd.xxy);\n    vec3 p = (n - base) * 64.0;\n    float t = mix(a, b, p.x);\n    float tt = mix(c, d, p.x);\n    return mix(t, tt, p.y);\n}\n\nfloat detail (vec3 n)\n{\n    vec3 base = vec3(n.x, n.y, floor(n.z * 64.0) * 0.015625);\n    vec3 dd = vec3(0.015625, 0.0, 0.0);\n    vec3 p = (n - base) *  64.0;\n    float front = noise(base + dd.yyy);\n    float back = noise(base + dd.yyx);\n    return mix(front, back, p.z);\n}\n\nfloat fbm(vec3 n)\n{\n    float total = 0.0;\n    float m1 = 1.0;\n    float m2 = 0.1;\n    for (int i = 0; i < 5; i++)\n    {\n        total += detail(n * m1) * m2;\n        m2 *= 2.0;\n        m1 *= 0.5;\n    }\n    return total;\n}\n\nvec3 surface (vec3 n)\n{\n\treturn vec3(fbm((5.0 * n) + fbm((5.0 * n) * 3.0 - 1000.0) * 0.05),0,0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    float color = clamp(vec4(vec3((surface(vec3(uv*5.0,iTime)*0.02)-1.0)),1.0).r,0.0,1.0);\n    if (color<0.5)\n        fragColor = vec4(0,0,0,1);\n    else\n        fragColor = vec4(1,1,1,1);\n    //fragColor = mix (vec4(0,0,0,1), vec4(1,1,1,1),step(uv.x,sin(iTime)*0.5+0.5));\n}","name":"Buf A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float counter = 0.0;\n    if (fragCoord.x < 1.0)\n    {\n        for (float i=0.0; i<iResolution.x/accuracy; i++)\n        {\n            float c = texelFetch(iChannel0,ivec2(i*accuracy,fragCoord.y),0).r;\n            if (c>0.5) counter++;\n        }\n    }\n    fragColor = vec4(counter,0.0,1.0,1.0);\n}","name":"Buf B","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float counter = 0.0;\n    if (fragCoord.x < 1.0 && fragCoord.y < 1.0)\n    {\n        for (float i=0.0; i<iResolution.y/accuracy; i++)\n        {\n            float c = texelFetch(iChannel0,ivec2(0,i*accuracy),0).r;\n            counter = counter + c;\n        }\n    }\n    float percent = counter / (iResolution.x / accuracy * iResolution.y / accuracy) * 100.0;\n    fragColor = vec4(percent,0.0,1.0,1.0);\n}","name":"Buf C","description":"","type":"buffer"}]}