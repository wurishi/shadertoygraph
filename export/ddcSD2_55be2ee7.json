{"ver":"0.1","info":{"id":"ddcSD2","date":"1681113797","viewed":583,"name":"20230409_0mix section1","username":"0b5vr","description":"A music from \"0b5vr GLSL Techno Live Set\", my WebGL 64K Intro appeared in Revision 2023.\nhttps://youtu.be/3lOptjAeA2w\n\nThis should also work on my GLSL music live coding environment:\nhttps://0b5vr.com/wavenerd/\n","likes":13,"published":1,"flags":40,"usePreview":0,"tags":["audio","techno"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// A music from \"0b5vr GLSL Techno Live Set\", my WebGL 64K Intro appeared in Revision 2023.\n// https://youtu.be/3lOptjAeA2w\n\n// This should also work on my GLSL music live coding environment:\n// https://0b5vr.com/wavenerd/\n\n// Section1: https://shadertoy.com/view/ddcSD2\n// Section2: https://shadertoy.com/view/mdGXWD\n// Section3: https://shadertoy.com/view/dsGXWD\n// Section4: https://shadertoy.com/view/msGXWD\n\n// ** Music shader code is in \"Common\" tab **\n\nconst float SQRT2 = sqrt( 2.0 );\nconst float INV_SQRT2 = 1.0 / SQRT2;\n\nfloat plot( vec2 p ) {\n  int MAX_SAMPLES = min( 1024, int( iResolution.x ) );\n  float d = 2.0 / iResolution.y;\n  \n  float sum = 0.0;\n  for ( int i = 0; i < MAX_SAMPLES; i ++ ) {\n    vec2 s = texelFetch( iChannel0, ivec2( i, 0 ), 0 ).xy * mat2( -0.5, 0.5, 0.5, 0.5 );\n    float r = length( p - s );\n    sum += smoothstep( d, 0.0, r - 0.003 );\n  }\n  return sum;\n}\n\nfloat bgPattern( vec2 p ) {\n  float d = 2.0 / iResolution.y;\n\n  float rect = 0.0;\n  rect += smoothstep( 2.0 * d, 0.0, abs( p.x + p.y ) ) * smoothstep( 2.0 * d, 0.0, abs( p.x - p.y ) - 0.95 );\n  rect += smoothstep( 2.0 * d, 0.0, abs( p.x - p.y ) ) * smoothstep( 2.0 * d, 0.0, abs( p.x + p.y ) - 0.95 );\n  rect += smoothstep( 2.0 * d, 0.0, abs( abs( p.x + p.y ) - 1.0 ) ) * smoothstep( 2.0 * d, 0.0, abs( p.x - p.y ) - 1.0 );\n  rect += smoothstep( 2.0 * d, 0.0, abs( abs( p.x - p.y ) - 1.0 ) ) * smoothstep( 2.0 * d, 0.0, abs( p.x + p.y ) - 1.0 );\n  rect += smoothstep( 2.0 * d, 0.0, abs( p.x ) ) * smoothstep( d, 0.0, abs( p.y ) - 0.95 );\n  return min( rect, 1.0 );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 uv = fragCoord / iResolution.xy;\n  vec2 p = 2.0 * uv - 1.0;\n  p.x *= iResolution.x / iResolution.y;\n  \n  float shape = 0.0;\n  \n  shape += plot( p );\n  shape += 0.1 * bgPattern( p );\n\n  fragColor = vec4( vec3( shape ), 1.0 );\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define saturate(i) clamp(i,0.,1.)\n#define clip(i) clamp(i,-1.,1.)\n#define linearstep(a,b,x) saturate(((x)-(a))/((b)-(a)))\n#define lofi(i,m) (floor((i)/(m))*(m))\n#define tri(p) (1.-4.*abs(fract(p)-0.5))\n#define p2f(i) (exp2(((i)-69.)/12.)*440.)\n#define repeat(i,n) for(int i=0;i<(n);i++)\n\nconst float pi=acos(-1.);\nconst float tau=2.*pi;\nconst float p4=exp2(5./12.);\nconst float p5=exp2(7./12.);\nconst float b2t=60./140.;\nconst float t2b=1./b2t;\nconst uint uint_max=0xffffffffu;\n\nuvec3 pcg3d(uvec3 v){\n  v=v*1145141919u+1919810u;\n  v.x+=v.y*v.z;\n  v.y+=v.z*v.x;\n  v.z+=v.x*v.y;\n  v^=v>>16u;\n  v.x+=v.y*v.z;\n  v.y+=v.z*v.x;\n  v.z+=v.x*v.y;\n  return v;\n}\n\nvec3 pcg3df(vec3 v){\n  uvec3 r=pcg3d(floatBitsToUint(v));\n  return vec3(r)/float(uint_max);\n}\n\nmat2 r2d(float x){\n  float c=cos(x),s=sin(x);\n  return mat2(c,s,-s,c);\n}\n\nmat3 orthbas(vec3 z){\n  z=normalize(z);\n  vec3 x=normalize(cross(vec3(0,1,0),z));\n  vec3 y=cross(z,x);\n  return mat3(x,y,z);\n}\n\nvec3 cyclic(vec3 p,float pump){\n  vec4 sum=vec4(0);\n  mat3 rot=orthbas(vec3(2,-3,1));\n\n  repeat(i,5){\n    p*=rot;\n    p+=sin(p.zxy);\n    sum+=vec4(cross(cos(p),sin(p.yzx)),1);\n    sum*=pump;\n    p*=2.;\n  }\n\n  return sum.xyz/sum.w;\n}\n\nvec2 orbit(float t){\n  return vec2(cos(tau*t),sin(tau*t));\n}\n\nvec2 shotgun(float t,float spread,float snap){\n  vec2 sum=vec2(0);\n  repeat(i,64){\n    vec3 dice=pcg3df(vec3(i));\n\n    float partial=exp2(spread*dice.x);\n    partial=mix(partial,floor(partial+.5),snap);\n\n    sum+=vec2(sin(tau*t*partial))*r2d(tau*dice.y);\n  }\n  return sum/64.;\n}\n\nfloat cheapfiltersaw(float phase,float k){\n  float wave=mod(phase,1.);\n  float c=.5+.5*cos(pi*saturate(wave/k));\n  return (wave+c)*2.-1.-k;\n}\n\nvec2 boxmuller(vec2 xi){\n  float r=sqrt(-2.*log(xi.x));\n  float t=xi.y;\n  return r*orbit(t);\n}\n\nvec2 cheapnoise(float t){\n  uvec3 s=uvec3(t*256.);\n  float p=fract(t*256.);\n\n  vec3 dice;\n  vec2 v=vec2(0);\n\n  dice=vec3(pcg3d(s))/float(uint_max)-vec3(.5,.5,0);\n  v+=dice.xy*smoothstep(1.,0.,abs(p+dice.z));\n  dice=vec3(pcg3d(s+1u))/float(uint_max)-vec3(.5,.5,1);\n  v+=dice.xy*smoothstep(1.,0.,abs(p+dice.z));\n  dice=vec3(pcg3d(s+2u))/float(uint_max)-vec3(.5,.5,2);\n  v+=dice.xy*smoothstep(1.,0.,abs(p+dice.z));\n\n  return 2.*v;\n}\n\nvec2 mainAudio(vec4 time){\n  vec2 dest=vec2(0);\n\n  float sidechain=1.;\n\n  { // kick\n    float t=time.x;\n    sidechain=smoothstep(0.,1E-3,b2t-t)*smoothstep(0.,.8*b2t,t);\n\n    {\n      float env=linearstep(0.4,0.15,t);\n\n      // { // hi pass like\n      //   env*=exp(-50.*t);\n      // }\n\n      dest+=.6*env*tanh(2.*sin(\n        300.*t-20.*exp(-40.*t)\n        -5.*exp(-400.*t)\n      ));\n    }\n  }\n\n  { // sub kick\n    float t=mod(time.x-.25*b2t,.25*b2t);\n\n    float zc=linearstep(0.,.002,t)*linearstep(0.,.002,.25*b2t-t);\n    float env=exp(-10.*t);\n    float wave=sin(310.*t-2.*exp(-80.*t));\n    dest+=.5*sidechain*zc*env*wave;\n  }\n\n  { // low freq noise\n    float t=time.x;\n\n    vec2 wave=cyclic(vec3(200.*t),3.).xy;\n    dest+=.14*sidechain*wave;\n  }\n\n  { // hihat\n    float t=mod(time.x-.5*b2t,1.*b2t);\n    float env=exp(-20.*t);\n    dest+=.18*env*tanh(8.*shotgun(5400.*t,1.4,.0));\n  }\n\n  { // ride\n    float t=mod(time.y,.5*b2t);\n\n    dest+=.1*sidechain*tanh(10.*shotgun(3200.*t,3.4,.1))*exp(-10.*t);\n  }\n\n  { // perc\n    float tp=mod(time.y,2.*b2t);\n    float t=mod(mod(tp,.75*b2t),.5*b2t);\n    float st=(tp-t)*4.*t2b;\n\n    float tone=fract(.3+st*.422);\n    vec2 wave=cyclic(\n      32.*vec3(orbit(exp2(6.+2.*tone)),exp2(4.+3.*tone)*t),\n      1.5\n    ).xy;\n\n    float env=mix(\n      exp(-30.*t),\n      exp(-5.*t),\n      0.2\n    );\n    dest+=.4*sidechain*env*tanh(2.*wave);\n  }\n\n  { // clav\n    float t=mod(mod(time.y,2.25*b2t),.5*b2t);\n\n    float wave=sin(17000.*t);\n    dest+=.2*exp(-t*200.)*vec2(wave)*r2d(1.4);\n  }\n\n  { // rim\n    float t=mod(mod(time.y-.25*b2t,1.25*b2t),.5*b2t);\n\n    float env=exp(-300.*t);\n    dest+=.3*env*tanh(4.*(\n      +tri(t*400.-.5*env)\n      +tri(t*1500.-.5*env)\n    ))*vec2(1,-1);\n  }\n\n  { // noise\n    float t=mod(time.z,32.*b2t);\n    float tt=500.0*exp(-.2*t);\n    float tt2=500.0*exp(-.2*(t+.00005*(1.-exp(-.2*t))));\n    vec2 wave=cheapnoise(tt)-cheapnoise(tt2);\n    dest+=.1*sidechain*wave;\n  }\n\n  { // dual vco\n    vec2 sum=vec2(0);\n\n    repeat(i,7){\n      float fi=float(i);\n\n      const float freqs[3]=float[](560.,1200.,240.);\n      const float times[3]=float[](.25,.75,1.5);\n\n      repeat(j,3){\n        float t=mod(time.z-times[j]*b2t-.5*b2t*fi,2.*b2t);\n        vec2 wave=vec2(0);\n        wave+=sin(tau*freqs[j]*t);\n        wave+=1.5*sin(2.0*tau*freqs[j]*t+wave); // osc 2\n        sum+=exp(-30.*max(t-.05,0.))*exp(-2.*fi)*wave*r2d(fi+10.*time.w);\n      }\n    }\n\n    dest+=.1*sum;\n  }\n\n  return clip(1.3*tanh(dest));\n}\n","name":"Common","description":"","type":"common"},{"inputs":[],"outputs":[],"code":"const float BPM = 140.0;\nconst float BPS = BPM / 60.0;\n\nvec2 mainSound( int samp, float _time ) {\n  int BEAT = int( iSampleRate / BPS );\n  int BAR = 4 * BEAT;\n  int SIXTEEN_BAR = 64 * BEAT;\n\n  vec4 time = vec4( samp % ivec4( BEAT, BAR, SIXTEEN_BAR, 0x7fffffff ) ) / iSampleRate;\n\n  return mainAudio( time );\n}\n","name":"Sound","description":"","type":"sound"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"const float BPM = 140.0;\nconst float BPS = BPM / 60.0;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  if ( fragCoord.y > 1.0 ) {\n    fragColor = vec4( 0.0 );\n  } else {\n    float BEAT = 1.0 / BPS;\n    float BAR = 4.0 * BEAT;\n    float SIXTEEN_BAR = 64.0 * BEAT;\n\n    vec4 time = mod( vec4( iTime - fragCoord.x / iSampleRate ), vec4( BEAT, BAR, SIXTEEN_BAR, 1E9 ) );\n\n    vec2 s = mainAudio( time );\n\n    fragColor = vec4( s, 0.0, 1.0 );\n  }\n}","name":"Buffer A","description":"","type":"buffer"}]}