{"ver":"0.1","info":{"id":"DtjGR3","date":"1673619111","viewed":42,"name":"Raymarcher__","username":"Antoine54652","description":"yeh","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//raymarcher\nconst float MAX_DIST = 20.0;\nconst int STEPS = 150;\n\n//background\nconst vec3 BACKGROUND = vec3(0.15, 0.35, 1.0);\nconst float BACKGROUND_LIGHT_INTENSITY = 0.1;\n\n//light\nconst float RADIUS_OF_LIGHT = 3.0;\n\n//mouse\nconst float RADIUS_MOUSE = 2.0;\n\n//other data\nconst float PI = 3.141592;\nconst float ZOOM = 1.0;\n\n//plan\nconst vec3 COLOR_P = vec3(0.25, 0.45, 0.5);\nconst vec3 POS_P = vec3(0.0);\nconst vec3 NORMALE_P = normalize(vec3(0, 1.0, 0));\n\n//blue ball\nconst vec3 COLOR_S1 = vec3(0.06, 0.04, 1);\nconst vec3 POS_S1 = vec3(0.0);\nconst float SIZE_S1 = 0.5;\n\n//red ball\nconst vec3 COLOR_S2 = vec3(0.3, 0.04, 0.06);\nconst vec3 POS_S2 = vec3(0.1, 0.45, -0.1);\nconst float SIZE_S2 = 0.2;\n\n//yellow torus\nconst vec3 COLOR_T = vec3(1.0, 0.4, 0.0);\nconst vec3 POS_T = vec3(0.0, 0.2, 0.1);\nconst vec3 ROT_T = normalize(vec3(0.0, 0.2, 0.5));\nconst float RAY_T = 0.8;\nconst float THICKNESS_T = 0.1;\n\n//orange cylinder\nconst vec3 COLOR_C = vec3(1.0, 0.2, 0.1);\nconst vec3 POS_C = vec3(0.6, 0.3, 0.4);\nconst vec3 ROT_C = vec3(0.1, 0.4, 0.3);\nconst vec2 SIZE_C = vec2(0.12, 0.4);\nconst float SMOOTH_C = 0.30;\n\n//pink box\nconst vec3 COLOR_B = vec3(0.96, 0.41, 0.6);\nconst vec3 POS_B = vec3(-0.65, 0.5, 0.0);\nconst vec3 ROT_B = vec3(0.0, 0.5, 0.2);\nconst vec3 SIZE_B = vec3(0.2);\nconst float SMOOTH_B = 0.05;\n\n//fonction de rotation\nvec3 rotateX(vec3 p, float a){\n  float sa = sin(a), ca = cos(a);\n  return vec3(p.x, ca * p.y - sa * p.z, sa * p.y + ca * p.z);\n}\nvec3 rotateY(vec3 p, float a){\n  float sa = sin(a),   ca = cos(a);\n  return vec3(ca * p.x + sa * p.z, p.y, -sa * p.x + ca * p.z);\n}\nvec3 rotateZ(vec3 p, float a){\n  float sa = sin(a),   ca = cos(a);\n  return vec3(ca * p.x - sa * p.y, sa * p.x + ca * p.y, p.z);\n}\n\nvec3 rotate(vec3 p, vec3 a){\n    p = rotateX(p, a.x);\n    p = rotateY(p, a.y);\n    p = rotateZ(p, a.z);\n    return p;\n}\n\n\n//signed function field\nvec4 Plane(vec3 p, vec3 n, vec3 c){\n    return vec4(c, dot(p, n));\n}\n\nvec4 Sphere(vec3 p, float r, vec3 c){\n    return vec4(c, length(p) - r); //rgb=>color, a=>distance\n}\n\nvec4 Torus(vec3 p, vec3 rot, float r, float t, vec3 c){\n    p = rotate(p, rot);\n    return vec4(c, length(vec2(length(p.xz)-r, p.y)) - t);\n}\n\nvec4 Cylender(vec3 p, vec3 rot, vec2 size, float smoo, vec3 c){\n    p = rotate(p, rot);\n\n    float dX = length(p.xz) - size.x;\n    float dY = abs(p.y) - size.y;\n    \n    float dE = length(vec2(max(dX, 0.0), max(dY, 0.0)));\n    float dI = min(max(dX, dY), 0.0);\n    \n    float d = dE + dI;\n\n    return vec4(c, d - smoo * 0.1);\n}\n\nvec4 Box(vec3 p, vec3 rot, vec3 size, float smoo, vec3 c){\n    p = rotate(p, rot);\n    \n    vec3 diff = abs(p) - size;\n    \n    float dE = length(max(diff, 0.0));\n    float dI = min(max(diff.x, max(diff.y, diff.z)), 0.0);\n    \n    float d = dE + dI;\n\n    return vec4(c, d - smoo * 0.1);\n}\n\nvec4 substract(vec4 obj1, vec4 obj2){\n    return max(obj1, -obj2);\n}\n\nvec4 intersection(vec4 obj1, vec4 obj2){\n    return max(obj1, obj2);\n}\n\nvec4 minDist(vec4 a, vec4 b){\n    return a.a < b.a ? a : b;\n}\n\n\n//calculate the min distance object\nvec4 scene(vec3 p){\n    vec4 P = Plane(p - POS_P, NORMALE_P, COLOR_P);\n    vec4 obj = P;\n    \n    vec4 S1 = Sphere(p - POS_S1, SIZE_S1, COLOR_S1);\n    vec4 S2 = Sphere(p - POS_S2, SIZE_S2, COLOR_S2);\n    S1 = substract(S1, S2);\n    obj = minDist(obj, S1);\n    \n    vec4 T = Torus(p - POS_T, ROT_T, RAY_T, THICKNESS_T, COLOR_T);\n    obj = minDist(obj, T);\n    \n    vec4 C = Cylender(p - POS_C, ROT_C, SIZE_C, SMOOTH_C, COLOR_C);\n    obj = minDist(obj, C);\n    \n    vec4 B = Box(p - POS_B, ROT_B, SIZE_B, SMOOTH_B, COLOR_B);\n    obj = minDist(obj, B);\n    \n    return obj;\n}\n\n//raymarching\nvec4 march(vec3 rO, vec3 rD){\n    vec3 cP = rO; //current point\n    float d = 0.0;\n    vec4 s = vec4(0.0);\n    \n    for(int i = 0; i < STEPS; i++){\n        cP = rO + rD * d;\n        s = scene(cP);\n        d += s.a;\n        if(s.a < 0.001){\n            break;\n        }\n        if(d > MAX_DIST){\n            s.rgb = BACKGROUND;\n            break;\n        }\n    }\n    s.a = d;\n    return s;\n}\n\n//calulate the normale of a pixel\nvec3 normal(vec3 p){\n    float dP = scene(p).a;\n    vec2 eps = vec2(0.01, 0.0);\n    \n    float dX = scene(p + eps.xyy).a - dP; //diff of distance between p and the pts at 0.01x next\n    float dY = scene(p + eps.yxy).a - dP; //diff of distance between p and the pts at 0.01y next\n    float dZ = scene(p + eps.yyx).a - dP; //diff of distance between p and the pts at 0.01z next\n    \n    return normalize(vec3(dX, dY, dZ));\n}\n\nfloat lighting(vec3 p, vec3 n){\n    vec3 lP = vec3(cos(iTime) * RADIUS_OF_LIGHT, 1.0, sin(iTime) * RADIUS_OF_LIGHT); //position de la lumiere\n    vec3 lD = lP - p; //direction of the light\n    vec3 lN = normalize(lD); //direction normalize\n    \n    if(march(p + n * 0.01, lN).a < length(lD)) // if the distance is bigger than the norme of the direction (if it's the background)\n        return 0.0; //no lighting\n    \n    return max(0.0, dot(n, lN)); //else we return the dot product between the normale and the direction of the light form of nb positive\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - (iResolution.xy * 0.5)) / iResolution.y;\n    \n    vec2 mouse = iMouse.xy / iResolution.xy;\n    \n    float initAngle = -(PI * 0.5);\n    \n    vec3 rO = vec3(cos(mouse.x * 3.0 * PI + initAngle) * RADIUS_MOUSE, tan(mouse.y * PI * 0.4 + 0.1), sin(mouse.x * 3.0 * PI + initAngle) * RADIUS_MOUSE);\n    vec3 target = vec3(0, 0, 0);\n    \n    vec3 fwd = normalize(target - rO); //vector foreward\n    vec3 side = normalize(cross(vec3(0, 1.0, 0), fwd)); //cross product => return a vector perpendicular at two vectors\n    vec3 up = normalize(cross(fwd, side));\n    \n    vec3 rD = normalize(ZOOM * fwd + side * uv.x + up * uv.y); //vector where the camera is pointing\n    \n    \n    vec4 s = march(rO, rD); //raymarching, rgb=>color, a=> distance\n    float d = s.a; //distance\n    vec3 col = mix(vec3(1.0), BACKGROUND, pow(uv.y + 0.5, 0.6 + mouse.y)); //linear interpollation between white and the background color in terms of uv.y\n    \n    if(d < MAX_DIST){\n        vec3 p = rO + rD * d; //pts touch\n    \n        col = s.rgb;\n        vec3 nor = normal(p);\n        float l = lighting(p, nor);\n        \n        vec3 amb_backg = nor.y * BACKGROUND * BACKGROUND_LIGHT_INTENSITY;\n    \n        col *= (l + amb_backg);\n        col = pow(col, vec3(0.4545)); //gamma curve correction\n\n    }\n    \n    fragColor = vec4(col.rgb, 1.0);\n}","name":"Image","description":"","type":"image"}]}