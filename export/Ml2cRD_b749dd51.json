{"ver":"0.1","info":{"id":"Ml2cRD","date":"1507848816","viewed":578,"name":"Curve Fitting 2","username":"twenkid","description":"A modified version of the shader by Dave_Hoskins - different curve fitting modes are cycling in order to show the differences. More parameters extracted as variables (for blobs/points diameter, line thickness). To be continued.","likes":17,"published":1,"flags":64,"usePreview":0,"tags":["curvefitting"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"MlsSzr","filepath":"https://soundcloud.com/claude-debussy/clair-de-lune","previewfilepath":"https://soundcloud.com/claude-debussy/clair-de-lune","type":"musicstream","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Modified version of the curve fitting example by Dave_Hoskins:\n//Tags: curvefitting\n//Created by Dave_Hoskins in 2013-Sep-16\n//https://www.shadertoy.com/view/MsXGDj\n//\n//The modified version: Todor Arnaudov, 2017-Oct-12\n//Instead of #defines-s, different curve fitting modes\n//are cycled automatically in order to make the differences apparent.\n\n\n//#define Use_Linear\n//#define Use_Cosine\n//#define Use_Smoothstep\n//#define Use_Cubic\n//#define Use_ThirdOrderSpline\n//#define Use_Catmull_Rom\n\n// The functions use the following format:\n\n// v0----v1--x--v2----v3\n\n// Where 'x' is the fractional diff betweeen v1 and v2.\n\n//--------------------------------------------------------------------------------\n//  1 out, 1 in...\n\nint Use_Linear = 0;\nint Use_Cosine =1;\nint Use_Smoothstep = 2;\nint Use_Cubic = 3;\nint Use_ThirdOrderSpline=4;\nint Use_Catmull_Rom=5;\n\nint mode = 0;     //current mode\nint maxmode = 5;  //number of modes\nint divider = 11; //the mode changes on each divider-frame\nfloat blob = 0.033, line = 0.03;\nfloat skew = 8.0, contour = 0.03;\n\n\n#define HASHSCALE .1031\n\n\nfloat Hash(float p)\n{\n\tvec3 p3  = fract(vec3(p) * HASHSCALE);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//--------------------------------------------------------------------------------\nfloat Cubic(float x, float v0,float v1, float v2,float v3) \n{\n\tfloat p = (v3 - v2) - (v0 - v1);\n\treturn p*(x*x*x) + ((v0 - v1) - p)*(x*x) + (v2 - v0)*x + v1;\n}\n\n//--------------------------------------------------------------------------------\nfloat Catmull_Rom(float x, float v0,float v1, float v2,float v3) \n{\n\tfloat c2 = -.5 * v0\t+ 0.5*v2;\n\tfloat c3 = v0\t\t+ -2.5*v1 + 2.0*v2 + -.5*v3;\n\tfloat c4 = -.5 * v0\t+ 1.5*v1 + -1.5*v2 + 0.5*v3;\n\treturn(((c4 * x + c3) * x + c2) * x + v1);\n\t\n//\tOr, the same result with...\n//\tfloat x2 = x  * x;\n//\tfloat x3 = x2 * x;\n//\treturn 0.5 * ( ( 2.0 * v1) + (-v0 + v2) * x +\n//                  (2.0 * v0 - 5.0 *v1 + 4.0 * v2 - v3) * x2 +\n//                  (-v0 + 3.0*v1 - 3.0 *v2 + v3) * x3);\n\n\t\n}\n\n//--------------------------------------------------------------------------------\nfloat ThirdOrderSpline(float x, float L1,float L0, float H0,float H1) \n{\n\treturn \t\t  L0 +.5 *\n\t\t\tx * ( H0-L1 +\n\t\t\tx * ( H0 + L0 * -2.0 +  L1 +\n\t\t\tx * ((H0 - L0)* 9.0\t + (L1 - H1)*3.0 +\n\t\t\tx * ((L0 - H0)* 15.0 + (H1 - L1)*5.0 +\n\t\t\tx * ((H0 - L0)* 6.0\t + (L1 - H1)*2.0 )))));\n}\n\n//--------------------------------------------------------------------------------\nfloat Cosine(float x, float v0, float v1) \n{\n\tx = (1.0-cos(x*3.1415927)) * .5;\n\treturn (v1-v0)*x + v0;\n}\n\n//--------------------------------------------------------------------------------\nfloat Linear(float x, float v0, float v1) \n{\n\treturn (v1-v0)*x + v0;\n}\n\n//--------------------------------------------------------------------------------\nfloat Smoothstep(float x, float v0, float v1) \n{\n\tx = x*x*(3.0-2.0*x);\n\treturn (v1-v0)*x + v0;\n}\n\n//================================================================================\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy; // vec2(0.001, 0.002) ...\n\tuv.x *= iResolution.x/iResolution.y; //aspect ratio\n\t\n\t//float pos = (iTime*.5+uv.x) * 4.0;\n    float pos = (iTime*.5+uv.x) * skew; //10.0;\n    //pos = texture(iChannel0, vec2(floor(pos), 0.0) / iResolution.xy).x;\n    //pos = texture(iChannel0, vec2(uv.x, 0.0) / iResolution.xy).x*100.0;\n    //pos = texture(iChannel0, vec2(uv.x, uv.y)).x*iResolution.x; // / iResolution.xy).x*100.0;\n    //pos = texture(iChannel0, vec2(uv.x, uv.y)/ iResolution.xy).x*200.; // / iResolution.xy).x*100.0;\n    \n\tfloat x  = fract(pos);\n\tfloat v0 = Hash(floor(pos));\n\tfloat v1 = Hash(floor(pos)+1.0);\n\tfloat v2 = Hash(floor(pos)+2.0);\n\tfloat v3 = Hash(floor(pos)+3.0);\n\tfloat f;\n         \n    mode=(iFrame/divider)%maxmode;\n    \n\t/*\n#ifdef Use_Linear\n\tf = Linear(x, v1, v2);\n#elif defined Use_Cosine\n\tf = Cosine(x, v1, v2);\n#elif defined Use_Smoothstep\n\tf = Smoothstep(x, v1, v2);\n#elif defined Use_Cubic\n\tf = Cubic(x, v0, v1, v2, v3);\n#elif defined Use_Catmull_Rom\n\tf = Catmull_Rom(x, v0, v1, v2, v3);\n#elif defined Use_ThirdOrderSpline\n\tf = ThirdOrderSpline(x, v0, v1, v2, v3);\n#endif\n*/\n    switch(mode){\n        case 0: f = Linear(x, v1, v2); break;\n        case 1: f = Cosine(x, v1, v2); break;\n        case 2: f = Smoothstep(x, v1, v2); break;\n        case 3: f = Cubic(x, v0, v1, v2, v3);break;\n        case 4: f = Catmull_Rom(x, v0, v1, v2, v3); break;\n        case 5: f = ThirdOrderSpline(x, v0, v1, v2, v3); break;\n    }\n    \n\n    //line = 0.03, ...\n\t// Blobs...\n\tf = line / abs(f-uv.y); //When f - uv.y is bigger, f gets smaller\n\t//float d =  blob/length((vec2(((uv.x)/9.0*.25), uv.y)-vec2(x+.03, v1)) * vec2(.25,1.0));\n    float d =  blob/length((vec2(((uv.x)/9.0*.25), uv.y)-vec2(x+contour, v1)) * vec2(0.25,1.0));\n    //first half of the blob\n\n\tf = max(f, d*d); //When f is zero, take d and vice-verse\n    \n    \n\t//d = blob/length((vec2(((uv.x)/9.0*.25), uv.y)-vec2(x-.97, v2)) * vec2(.25,1.0));\n    d = blob/length((vec2(((uv.x)/9.0*.25), uv.y)-vec2(x-(1.0-contour), v2)) * vec2(.25,1.0));\n    //second half of the blob\n\tf = max(f, d*d); //When f is zero, take d and vice-verse\n    \n\n    vec3 col = vec3(1.0 - sin(iTime), 0.2 + cos(iTime)/6.0, 0.5 - sin(iTime)/5.0);\n\t//fragColor = vec4(vec3(1.0,.2, .05) * f, 1.0);    \n    fragColor = vec4(col * f, 1.0);\n}","name":"Image","description":"","type":"image"}]}