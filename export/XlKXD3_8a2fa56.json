{"ver":"0.1","info":{"id":"XlKXD3","date":"1486211119","viewed":676,"name":"Smoothstep/haversine/linear","username":"ConorStokes","description":"Expands won3d's https://www.shadertoy.com/view/MlGXD3 to show haversine as well as smoothstep and bilinear (smoothstep, followed by haversine, followed by bilinear)","likes":6,"published":3,"flags":0,"usePreview":0,"tags":["filtering","linear","smoothstep","haversine"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Based on won3d's smoothstep filter example (https://www.shadertoy.com/view/MlGXD3)\n// Which was in turn based on hornet's bicubic filter example (https://www.shadertoy.com/view/MtVGWz)\n\nvec4 sampleLevel0( vec2 uv )\n{\n    return texture( iChannel0, uv, -10.0 );\n}\n\n\nvec4 SampleSmoothlinear( vec2 uv, vec2 texSize )\n{\n    // Round  down the sample location to get the exact center of our \"starting\" texel\n    // The starting texel will be at location [1, 1] in the grid, where [0, 0] is the\n    // top left corner.\n    vec2 samplePos = uv * texSize;\n    vec2 texPos1 = floor(samplePos - 0.5) + 0.5;\n\n    // Compute the fractional offset from our starting texel to our original sample.\n    vec2 f = samplePos - texPos1;\n\n    // !!! smoothstep fractional offsets. Cheaper things would likey work as well but \n    // this is simple as a PoC.\n    f = smoothstep(vec2(0.0), vec2(1.0), f);\n    \n    // That's it!\n    return sampleLevel0((texPos1 + f)/texSize);\n}\n\n\nvec4 SampleHaversinelinear( vec2 uv, vec2 texSize )\n{\n    // Round  down the sample location to get the exact center of our \"starting\" texel\n    // The starting texel will be at location [1, 1] in the grid, where [0, 0] is the\n    // top left corner.\n    vec2 samplePos = uv * texSize;\n    vec2 texPos1 = floor(samplePos - 0.5) + 0.5;\n\n    // Compute the fractional offset from our starting texel to our original sample.\n    vec2 f = samplePos - texPos1;\n\n    // !!! change smoothstep to haversine\n    f = ( vec2( 1.0 ) - cos( f * 3.141592) ) * 0.5;\n    \n    // That's it!\n    return sampleLevel0((texPos1 + f)/texSize);\n}\n\n//note: uniform pdf rand [0;1[\nvec3 hash32n(vec2 p)\n{\n\tp  = fract(p * vec2(5.3987, 5.4421));\n    p += dot(p.yx, p.xy +  vec2(21.5351, 14.3137));\n\treturn fract(vec3(p.x * p.y * 95.4307, p.x * p.y * 97.5901, p.x * p.y * 93.8369));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    vec2 sample_uv = uv;\n    sample_uv.x = mod( sample_uv.x, 0.33333 );\n   \tsample_uv += 0.01 * vec2( cos(iTime), sin(iTime) );\n    sample_uv *= (iMouse.z>0.0)? iMouse.x * 0.001 : 0.06125;\n    \n    vec4 samplev;\n    if ( uv.x < 0.3333 )\n    \tsamplev = SampleSmoothlinear( sample_uv, iChannelResolution[0].xy );\n    else if ( uv.x < 0.66667 )\n        samplev = SampleHaversinelinear( sample_uv, iChannelResolution[ 0 ].xy );\n    else\n        samplev = sampleLevel0( sample_uv );\n\n    fragColor = samplev;\n    fragColor -= step(abs(uv.x-0.3333), 0.001);\n    fragColor -= step(abs(uv.x-0.6667), 0.001);\n    fragColor.rgb += (hash32n(uv+fract(iTime))+hash32n(uv+0.1337*fract(iTime))-1.0)/255.0; //dither output\n}","name":"Image","description":"","type":"image"}]}