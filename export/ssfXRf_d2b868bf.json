{"ver":"0.1","info":{"id":"ssfXRf","date":"1619243742","viewed":107,"name":"Reversible Cellular Automata","username":"interstice","description":"Implementation of the reversible cellular automaton 'Critters', and some variants. Click while paused to edit cells. See 'common' for alternate CA rules & other settings.","likes":5,"published":1,"flags":32,"usePreview":0,"tags":["ca","critters","reversibleca"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = pixelSize*floor(fragCoord/pixelSize) + 0.5;\n    fragColor = vec4(texture(iChannel0, uv / iResolution.xy).rgb, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 timeVec = texture(iChannel0, fragCoord);\n    \n    float prevTime = timeVec.x;\n    float timeDelta = iTime - prevTime;\n    float measuredTime = timeVec.z + timeDelta;\n    float measureCounter;\n    if (measuredTime > timeStep){\n        measuredTime = measuredTime - timeStep;\n        if (timeStep == 0.0){\n            measuredTime = 0.0;\n        }\n        measureCounter = 1.0;\n    }\n    else{\n        \n        measureCounter = 0.0;\n    }\n    fragColor = vec4(iTime, timeDelta, measuredTime, measureCounter);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 grid_max = ivec2(floor(iResolution.xy/pixelSize));\n    grid_max = grid_max - (grid_max%2); //grid must have even size\n    ivec2 grid_int = ivec2(floor(fragCoord/pixelSize));\n    \n    vec2 grid_uv = (pixelSize * vec2(grid_int) + 0.5)/iResolution.xy;\n    \n    if (grid_int.x >= grid_max.x || grid_int.y >= grid_max.y) {\n        return; //leave top or bottom row uncolored if odd\n    }\n    \n    if(iFrame == 0){\n        int init_val = initializer(grid_int, grid_max);\n        if (init_val == 1){\n            fragColor = vec4(1.0, 1.0, 1.0, 1.0);\n        }\n        else{\n            fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n        }\n        return;\n    }\n    \n    //Mouse editing\n    vec2 pixel = vec2(1.0)/iResolution.xy;\n    pixel *= pixelSize;\n    \n    vec2 mouseUV = pixelSize*floor(iMouse.xy/pixelSize) + 0.5;\n    mouseUV /= iResolution.xy;\n    \n    bool written = (iMouse.z > 0.0) && (abs(grid_uv.x - mouseUV.x) < pixel.x/2.0) && (abs(grid_uv.y - mouseUV.y) < pixel.y/2.0);\n    \n    if(written)\n    {\n    \tfragColor = vec4(1.0 - texture(iChannel0, grid_uv).xyz, texture(iChannel0, grid_uv).w);\n        return;\n    }\n    \n    \n    vec4 timeVec = texture(iChannel1, grid_uv);\n    \n    //If the shader is paused / if a discrete time step hasn't passed\n    if (!(timeVec.y > 0.0 && timeVec.w >0.0) ) {\n        //do nothing\n        fragColor = texture(iChannel0, grid_uv);\n        return;\n        \n    }\n    \n    int timestep_parity = int(texture(iChannel0, grid_uv).w); \n    ivec2 grid_parity = ivec2(1) - 2*(grid_int%2);\n    \n    int[4] neighbour_values;\n    //Evolution Rule\n    for (int i = 0; i <= 1; i++){\n        for (int j = 0; j <= 1; j++){\n            ivec2 neighbour_int = grid_int + timestep_parity * grid_parity * ivec2(i, j);\n            neighbour_int = (neighbour_int+grid_max)%grid_max; //% is not modulus\n            vec2 neighbour_uv = (vec2(neighbour_int) * pixelSize + 0.5)/iResolution.xy;\n            neighbour_values[i*2 + j] = int(texture(iChannel0, neighbour_uv).x);\n        }\n    }\n    \n    int next_value = transition_rule(neighbour_values, timestep_parity, grid_parity);\n    \n    fragColor = vec4(vec3(float(next_value)), -1.0 * float(timestep_parity));\n    \n    \n\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"const float pixelSize = 6.0; //pixel-block \nconst float timeStep = 0.0; //take a step every X seconds\n\n//#define transition_rule trivial_rule\n//#define transition_rule critters_original\n#define transition_rule critters_modified\n//#define transition_rule highlander\n\n//#define initializer big_square\n//#define initializer two_squares\n#define initializer random_square\n//#define initializer random_uniform\n\n\nfloat rand(vec2 co){ //\"standard\" random function with added ad-hoc time dependency(possibly broken)\n    float time_sum =  100.0 * iDate.y + 10.0 * iDate.z + iDate.w;\n    time_sum = time_sum - 100.0 * floor(time_sum/100.0);\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453 * time_sum);\n}\n\nint trivial_rule(int[4] neighbour_values, int timestep_parity, ivec2 grid_parity)\n{\n    return neighbour_values[3];\n}\n\n//Original 'Critters' transition rule\nint critters_original(int[4] neighbour_values, int timestep_parity, ivec2 grid_parity)\n{\n    int neighbour_sum = 0;\n    for (int i = 0; i <= 1; i++){\n        for (int j = 0; j <= 1; j++){\n            neighbour_sum += neighbour_values[i*2 + j];\n        }\n    }\n    \n    if (neighbour_sum == 0 || neighbour_sum == 1 || neighbour_sum == 4){\n        return 1 - neighbour_values[0];\n    }\n    if (neighbour_sum == 2){\n        return neighbour_values[0];\n    }\n    if (neighbour_sum == 3){\n        return 1 - neighbour_values[3];\n    }\n}\n\n//Critters rule modified to preserve 'live' count at every timestep. Less flickery animation too.\n//breaking invariance of the rule over time however: \n//now the rule changes depending on the timestep being odd or even\nint critters_modified(int[4] neighbour_values, int timestep_parity, ivec2 grid_parity){\n    \n    int neighbour_sum = 0;\n    for (int i = 0; i <= 1; i++){\n        for (int j = 0; j <= 1; j++){\n            neighbour_sum += neighbour_values[i*2 + j];\n        }\n    }\n    //odd time step\n    if (timestep_parity == -1){\n        if (neighbour_sum == 0 || neighbour_sum == 1 || neighbour_sum == 4){\n            return neighbour_values[0];\n        }\n        if (neighbour_sum == 2){\n            return 1 - neighbour_values[0];\n        }\n        if (neighbour_sum == 3){\n            return neighbour_values[3];\n        }\n        \n    }\n    //even time step\n    if (timestep_parity == 1){\n        if (neighbour_sum == 0 ||neighbour_sum == 4 || neighbour_sum == 3){\n            return neighbour_values[0];\n        }\n        if (neighbour_sum == 2){\n            return 1 - neighbour_values[0];\n        }\n        if (neighbour_sum == 1){\n            return neighbour_values[3];\n        }\n    }\n    \n}\n\n\n//Virgo & Ikegami's modified 'highlander' rule, exhibiting 'conservation of genki'\n//Source: https://direct.mit.edu/isal/proceedings/alife2014/530/98985\nint highlander(int[4] neighbour_values, int timestep_parity, ivec2 grid_parity){\n\n    int neighbour_sum = 0;\n    for (int i = 0; i <= 1; i++){\n        for (int j = 0; j <= 1; j++){\n            neighbour_sum += neighbour_values[i*2 + j];\n        }\n    }\n    \n    if (neighbour_sum == 0 ||neighbour_sum == 4){\n        return neighbour_values[0];\n    }\n    if (neighbour_sum == 2){\n        return 1 - neighbour_values[0];\n    }\n    \n    if (neighbour_sum == 1){ //get from clockwise neighbour in square\n        int orientation =  grid_parity.x * grid_parity.y;\n        return neighbour_values[(3 + orientation)%3];\n    }\n    \n    if (neighbour_sum == 3){ //counterclockwise neighbour\n        int orientation =  grid_parity.x * grid_parity.y;\n        return neighbour_values[(3 - orientation)%3];\n    }\n    \n\n}\n\n\n\n//Initializers. Return 1 if the square is filled at init, 0 otherwise\nint big_square(ivec2 grid_int, ivec2 grid_max){\n    ivec2 grid_center = grid_max/2;\n    int rad = min(grid_max.x, grid_max.y)/8;\n    if (abs(grid_int.x - grid_center.x) < rad && abs(grid_int.y - grid_center.y) < rad){\n        return 1;\n    }\n    return 0;\n\n}\n\nint two_squares(ivec2 grid_int, ivec2 grid_max){\n    \n    ivec2 center_one;\n    center_one.x = grid_max.x/3;\n    center_one.y = grid_max.y/2;\n    ivec2 center_two;\n    center_two.x = 2 * grid_max.x/3;\n    center_two.y = grid_max.y/2;\n    \n    int rad_one = min(grid_max.x, grid_max.y)/10;\n    int rad_two = min(grid_max.y, grid_max.y)/12;\n    \n    if( (abs(grid_int.x - center_one.x) <  rad_one && abs(grid_int.y - center_one.y) < rad_one) ||\n        (abs(grid_int.x - center_two.x) <  rad_two && abs(grid_int.y - center_two.y) < rad_two) ){\n        return 1;\n    }\n    \n    return 0;\n\n}\n\n\nint random_square(ivec2 grid_int, ivec2 grid_max){\n    \n    ivec2 grid_center = grid_max/2;\n    int rad = min(grid_max.x, grid_max.y)/6;\n    if (abs(grid_int.x - grid_center.x) < rad && abs(grid_int.y - grid_center.y) < rad){\n        \n        if (rand(vec2(grid_int)) > 0.5){\n            return 1;\n        }\n    }\n    return 0;\n    \n\n}\n\n\nint random_uniform(ivec2 grid_int, ivec2 grid_max){\n\n    if (rand(vec2(grid_int)) > 0.3){\n        return 1;\n    }\n    return 0;\n}\n\n\n\n","name":"Common","description":"","type":"common"}]}