{"ver":"0.1","info":{"id":"XltGR7","date":"1468434287","viewed":1178,"name":"(Very Basic) Cel Shading","username":"rreno","description":"Trying out basic cel shading. I like how the edges turned out. I don't quite get how though so I've got some more reading to do. I also don't know how to animate or antialias either so I'll put that on the To Learn list.\n","likes":12,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","celshading","toonshading"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//\n// (Very Basic) Cel Shading by rreno\n//\n\n//Adapted from the raymarching algorithm tutorial at reddit.com/r/twotriangles\n//and iq's distance functions at \n//https://iquilezles.org/articles/distfunctions\n\n\n#define MAX_ITER\t100\n#define MAX_DIST\t10.0\n#define EPSILON\t\t0.001\n\n\nfloat torus(vec3 pos, vec2 t)\n{\n    vec2 q = vec2(length(0.80*pos.xz + 1.75) - 2.75*t.x, 1.25*pos.y);\n    return 1.1*length(q) - t.y;\n}\n\nfloat distFunc(vec3 pos)\n{\n    vec2 t = vec2(0.88);\n    return torus(pos, t);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 camOrigin\t= vec3(2.0);\n    vec3 camTarget\t= vec3(0.0);\n    vec3 upDir\t\t= vec3(0.0, 1.0, 0.0);\n    \n    vec3 camDir\t\t= normalize(camTarget - camOrigin);\n    vec3 camRight\t= normalize(cross(upDir, camOrigin));\n    vec3 camUp\t\t= cross(camDir, camRight);\n    \n    //place origin at center of screen & correct aspect ratio\n    vec2 screenPos = -1.0 + 2.0 * fragCoord.xy / iResolution.xy;\n    screenPos.x *= iResolution.x / iResolution.y;\n    \n    vec3 rayDir = normalize(camRight * screenPos.x + camUp * screenPos.y + camDir);\n    \n    //Raymarching loop\n    float totalDist = 0.0;\n    vec3 pos = camOrigin;\n    float dist = EPSILON;\n    \n    for (int i = 0; i < MAX_ITER; i++) {\n        if (dist < EPSILON || totalDist > MAX_DIST) {\n            break;\n        }\n        \n        dist = distFunc(pos);\n        totalDist += dist;\n        pos += dist * rayDir;\n        \n    }\n    if (dist < EPSILON) {\t\t\t\t//the ray hit the object\n    \tvec2 eps = vec2(0.0, EPSILON);\n    \tvec3 normal = normalize(vec3(\n       \t\t\tdistFunc(pos + eps.yxx) - distFunc(pos - eps.yxx),\n       \t\t\tdistFunc(pos + eps.xyx) - distFunc(pos - eps.xyx),\n       \t\t\tdistFunc(pos + eps.xxy) - distFunc(pos - eps.xxy)));\n    \n    \tfloat diffuse = max(0.0, dot(-rayDir, normal));\n    \tfloat specular = pow(diffuse, 128.0);\n        float lighting = diffuse + specular;\n        float toonMap;\n        \n        //map lighting information to discrete values\n        if (lighting < 0.256) {\n            toonMap = 0.195;\n        } else if (lighting < 0.781) {\n            toonMap = 0.781;\n        } else {\n            toonMap = 0.900;\n        }\n        vec3 color = vec3(toonMap);\n        fragColor = vec4(color, 1.0);\n    } else {\t\t\t\t\t\t//the ray didn't hit anything\n        fragColor = vec4(0.5, 0.7, 0.7, 1.0);\n    }\n}","name":"Image","description":"","type":"image"}]}