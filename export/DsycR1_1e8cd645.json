{"ver":"0.1","info":{"id":"DsycR1","date":"1696016985","viewed":172,"name":"2d vector field flow","username":"MJVville","description":"Displays the flow of a two-dimensional vector field or first-order system of differential equations. Intended to emulate https://anvaka.github.io/fieldplay","likes":9,"published":1,"flags":48,"usePreview":0,"tags":["math","particles","flow","vectorfield"],"hasliked":0,"parentid":"Ds3yWj","parentname":"Deterministic Nyan Particles"},"renderpass":[{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":2,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Go to the Common tab for settings\n\n// Particle system wholly based on fenix's project \"Deterministic Nyan Particles\" https://www.shadertoy.com/view/Ds3yWj\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec4 col = texture(iChannel0, uv);\n    fragColor = vec4(col.rgb, 1.);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// ---------------------------------------------------------------------------------------\n//\tParticle simulation\n// ---------------------------------------------------------------------------------------\n\nvoid mainImage( out vec4 O, vec2 fragCoord )\n{\n    uvec2 ufc = uvec2(fragCoord);\n    \n    computeMaxParticles();\n    uint index = ufc.x + ufc.y * uint(R.x); // \"1D array\" index\n    uint id = index / NUM_PARTICLE_DATA_TYPES; // which particle\n    uint dataType = index - id * NUM_PARTICLE_DATA_TYPES; // which field of particle structure\n    if (id >= g_MaxParticles) return;\n    \n    fxParticle p = fxGetParticle(id);\n    fxState s = fxGetState();\n    \n    if (dataType >= POS)\n        O = updateParticle(s, p, id, dataType, iFrame);\n    else\n        O = voronoiParticle(s, p, id, dataType);\n}\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"// The vector field\nvec2 field(vec2 p) {\n    float x = p.x;\n    float y = p.y;\n\n    // Enter your own vector field here\n    ////////////////////////////\n    float vx = 0.5*x - y - 0.5*(pow(x, 3.) + pow(y, 2.)*x);\n    float vy = x + 0.5*y - 0.5*(pow(y, 3.) + pow(x, 2.)*y);\n    ////////////////////////////\n    \n\treturn vec2(vx, vy);\n}\n\n// Options\nconst vec3 BACK_COLOR = vec3(0.);\nconst vec3 PAR_COLOR = vec3(1.);\nconst uint IDEAL_MAX_PARTICLES = 3000U;\nconst float INTEGRAL_TIMESTEP = 0.005;\nconst float PARTICLE_SIZE = .002;\nconst float FADEOUT_SPEED = 0.99;\nconst float PARTICLE_RESET_PROBABILITY = 0.015;\n\nconst bool COLOR_BY_VELOCITY = true;\nconst float EXPECTED_MAXIMUM_SPEED = 5.; // Determines brightness of particles if color_by_velocity is on\n\n// Viewing window\nconst vec2 CENTER = vec2(0., 0.);\nconst float SCALE = 1.5;\n\n////////////////////////////////////////////////////////////////////////\n\n#define R iResolution.xy\n\nconst float PI = 3.141592653589793;\n\nvec2 imageToMathCoords(vec2 coords, vec2 res)\n{\n    vec2 newCoords = (coords/res - 0.5)*2.*SCALE;\n    newCoords.x *= res.x/res.y;\n    newCoords += CENTER;\n    return newCoords;\n}\n\nvec2 mathToImageCoords(vec2 coords, vec2 res)\n{\n    vec2 newCoords = coords-CENTER;\n    newCoords.x *= res.y/res.x;\n    return (newCoords*0.5/SCALE + 0.5)*res;\n}\n\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n// PERSISTENT STATE\n\nstruct fxState\n{\n    float res; // tracks resolution changes\n    int frame; // simulation frame\n    bool init; // first initialization run\n};\n\n#define fxGetState() fxGetStateImpl(iChannel1)\nfxState fxGetStateImpl(sampler2D sampler)\n{\n    vec4 data = texelFetch(sampler, ivec2(0), 0);\n    \n    fxState s;\n    s.res = data.x;\n    s.frame = floatBitsToInt(data.z);\n    s.init = data.w != 0.;\n    \n    return s;\n}\n\nvec4 fxPutState(fxState s)\n{\n    return vec4(s.res, 0, intBitsToFloat(s.frame), s.init ? 1 : 0);\n}\n\nbool fxIsStatePixel(vec2 u)\n{\n    return ivec2(u) == ivec2(0);\n}\n\n//returns the ids of the four closest particles from the input\n#define fxGetClosest(X) fxGetClosestImpl(iChannel1, X)\nuvec4 fxGetClosestImpl(sampler2D sampler, ivec2 xy)\n{\n    return floatBitsToUint(texelFetch(sampler, xy, 0));\n}\n\n// UTILITIES\n\nuvec4 hash(uvec4 x){\n    x = ((x >> 16u) ^ x.yzwx) * 0x45d9f3bu;\n    x = ((x >> 16u) ^ x.yzwx) * 0x45d9f3bu;\n    x = ((x >> 16u) ^ x.yzwx) * 0x45d9f3bu;\n    x = ((x >> 16u) ^ x.yzwx) * 0x45d9f3bu;\n    //x = (x >> 16u) ^ x;\n    return x;\n}\n\n//hashing noise by IQ\nfloat hash( int k ) {\n    uint n = uint(k);\n\tn = (n << 13U) ^ n;\n    n = n * (n * n * 15731U + 789221U) + 1376312589U;\n    return uintBitsToFloat( (n>>9U) | 0x3f800000U ) - 1.0;\n}\n\n// Integer Hash - II by iq\n// https://www.shadertoy.com/view/XlXcW4\nconst uint k = 1103515245U;  // GLIB C\n\nvec3 hash3( uvec3 x )\n{\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    \n    return vec3(x)*(1.0/float(0xffffffffU));\n}\n\nfloat length2(vec2 v) { return dot(v, v); }\nfloat sqr(float x) { return x * x; }\n\nfloat fxLinePointDist(vec2 a, vec2 b, vec2 p)\n{\n    p -= a, b -= a;\n    float h = clamp(dot(p, b) / dot(b, b), 0., 1.);// proj coord on line\n    return sqrt(length2(p - b * h)); // squared dist to segment\n}\n\n// https://iquilezles.org/articles/distfunctions2d/\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\n// https://iquilezles.org/articles/distfunctions2d/\nfloat sdArc( in vec2 p, in vec2 sc, in float ra, float rb )\n{\n    // sc is the sin/cos of the arc's aperture\n    p.x = abs(p.x);\n    return ((sc.y*p.x>sc.x*p.y) ? length(p-sc*ra) : \n                                  abs(length(p)-ra)) - rb;\n}\n\nmat2 rot2(float a)\n{\n    vec2 sc = vec2(sin(a), cos(a));\n    return mat2(sc.y, sc.x, -sc.x, sc.y);\n}\n\n// insert new particle at distance d_ with index i_ into i, d arrays, sorting by d\nvoid insertionSort(inout uvec4 i, inout vec4 d, uint i_, float d_)\n{\t\n    if(any(equal(uvec4(i_),i))) return;\n    if     (d_ < d[0])             \n        i = uvec4(i_,i.xyz),    d = vec4(d_,d.xyz);\n    else if(d_ < d[1])             \n        i = uvec4(i.x,i_,i.yz), d = vec4(d.x,d_,d.yz);\n    else if(d_ < d[2])            \n        i = uvec4(i.xy,i_,i.z), d = vec4(d.xy,d_,d.z);\n    else if(d_ < d[3])           \n        i = uvec4(i.xyz,i_),    d = vec4(d.xyz,d_);\n}\n\n// SCENE FUNCTIONS\n\n// scene (walls) signed distance field, for rendering and collision\nfloat sdScene(vec2 p, vec2 res)\n{\n    const float theta = 2.35;\n    const vec2 sc = vec2(sin(theta), cos(theta));\n    float d = sdArc((p * vec2(1, -1)), sc, 0.45, 0.01);\n    d = min(d, sdBox((p - vec2(-1.195, .794)) * rot2(-.5), vec2(1, .01)));\n    d = min(d, sdBox((p - vec2( 1.195, .794)) * rot2(.5), vec2(1, .01)));\n    return d;\n}\n\n// the outward normal of the scene at a point\nvec2 normScene(vec2 p, vec2 res)\n{\n\tconst vec2 d = vec2(.001, 0);\n    \n   \tfloat x1 = sdScene(p + d.xy, res); \n    float x0 = sdScene(p - d.xy, res); \n    float dx = x1 - x0;\n    \n    float y1 = sdScene(p + d.yx, res); \n    float y0 = sdScene(p - d.yx, res); \n    float dy = y1 - y0;\n    \n\treturn normalize(vec2(dx, dy));\n}\n\n// PARTICLE STRUCTURE\n\n#define UL_NEIGHBORS 0U\n#define UR_NEIGHBORS 1U\n#define LL_NEIGHBORS 2U\n#define LR_NEIGHBORS 3U\n#define POS 4U\n#define UV 5U\n#define COLOR 6U\n#define NUM_PARTICLE_DATA_TYPES 7U\n\nuint g_MaxParticles = 0U;\n\n// must be called in each buffer before g_MaxParticles is correct\n#define computeMaxParticles() computeMaxParticlesImpl(R)\nvoid computeMaxParticlesImpl(vec2 res)\n{\n    g_MaxParticles = min(IDEAL_MAX_PARTICLES, uint(res.x * res.y) / NUM_PARTICLE_DATA_TYPES);\n}\n\n//returns the location of the particle within the particle buffer corresponding with the input id \n#define fxLocFromID(X, Y) fxLocFromIDImpl(int(R.x), X, Y)\nivec2 fxLocFromIDImpl(uint width, uint id, uint dataType)\n{\n    uint index = id * NUM_PARTICLE_DATA_TYPES + dataType;\n    return ivec2(index % width, index / width);\n}\n\nstruct fxParticle\n{\n    vec2 pos;     // position\n    vec2 prev;     // position in the previous frame\n    float size;\n    vec3 color;\n    vec2 uv;\n    \n    uvec4 nbs[4]; // neighbors\n};\n\n//get the particle corresponding to the input id\n#define fxGetParticle(X) fxGetParticleImpl(iChannel0, uint(R.x), X)\nfxParticle fxGetParticleImpl(sampler2D sampler, uint resolutionWidth, uint id)\n{\n    vec4 data0 = texelFetch(sampler, fxLocFromIDImpl(resolutionWidth, id, UL_NEIGHBORS), 0);\n    vec4 data1 = texelFetch(sampler, fxLocFromIDImpl(resolutionWidth, id, UR_NEIGHBORS), 0);\n    vec4 data2 = texelFetch(sampler, fxLocFromIDImpl(resolutionWidth, id, LL_NEIGHBORS), 0);\n    vec4 data3 = texelFetch(sampler, fxLocFromIDImpl(resolutionWidth, id, LR_NEIGHBORS), 0);\n    vec4 data4 = texelFetch(sampler, fxLocFromIDImpl(resolutionWidth, id, POS), 0);\n    vec4 data5 = texelFetch(sampler, fxLocFromIDImpl(resolutionWidth, id, UV), 0);\n    vec4 data6 = texelFetch(sampler, fxLocFromIDImpl(resolutionWidth, id, COLOR), 0);\n\n    fxParticle p;\n    p.nbs[0] = floatBitsToUint(data0);\n    p.nbs[1] = floatBitsToUint(data1);\n    p.nbs[2] = floatBitsToUint(data2);\n    p.nbs[3] = floatBitsToUint(data3);\n    p.pos = data4.xy;\n    p.prev = data4.zw;\n    p.size = data6.w;\n    p.color = data6.xyz;\n    p.uv = data5.xy;\n    \n    return p;\n}\n\nvec4 fxSaveParticle(fxParticle p, uint dataType)\n{    \n    switch(dataType)\n    {\n    case UL_NEIGHBORS:\n        return uintBitsToFloat(p.nbs[0]);\n    case UR_NEIGHBORS:\n        return uintBitsToFloat(p.nbs[1]);\n    case LL_NEIGHBORS:\n        return uintBitsToFloat(p.nbs[2]);\n    case LR_NEIGHBORS:\n        return uintBitsToFloat(p.nbs[3]);\n    case UV:\n        return vec4(p.uv, 0., 0.);\n    case POS:  \n        return vec4(p.pos, p.prev);\n    case COLOR:  \n        return vec4(p.color, p.size);\n    }\n}\n\n#define fxGetParticleData(X, Y) fxGetParticleDataImpl(iChannel0, uint(R.x), X, Y)\nvec4 fxGetParticleDataImpl(sampler2D sampler, uint resolutionWidth, uint id, uint dataType)\n{\n    return texelFetch(sampler, fxLocFromIDImpl(resolutionWidth, id, dataType), 0);\n}\n\n#define updateParticle(A, B, C, D, frame) updateParticleImpl(A, B, C, D, R, iChannel0, frame)\nvec4 updateParticleImpl(fxState s, fxParticle p, uint id, uint dataType, vec2 res, sampler2D par, int frame)\n{\n    float chance = hash(int(id + uint(frame)));\n    if (chance < PARTICLE_RESET_PROBABILITY || s.init)\n    {\n        // set the particle to a random position\n        \n        vec3 h1 = hash3((id) * uvec3(3, 6, 9));\n        \n        h1.xy = imageToMathCoords(h1.xy, vec2(1., 1.));\n        h1.x *= res.x/res.y;\n\n        p.pos = h1.xy;\n        p.prev = p.pos;\n        p.size = PARTICLE_SIZE;\n        p.color = PAR_COLOR;\n    }\n    else\n    {\n        // advance the particle along the flow of the vector field\n    \n        vec2 vel = field(p.pos);\n        p.prev = p.pos;\n            \n        p.pos = p.pos + INTEGRAL_TIMESTEP*vel;\n    }\n    \n    if (COLOR_BY_VELOCITY)\n    {\n        vec2 vel = field(p.pos);\n        \n        float brightness = clamp(sqrt(pow(vel.x, 2.) + pow(vel.y, 2.))/EXPECTED_MAXIMUM_SPEED, 0.1, 1.);\n        if (brightness < 0.001)\n            p.color = vec3(0.1);\n        else\n            p.color = hsv2rgb(vec3(atan(vel.y, vel.x)/(2.*PI) + 0.5, 1., brightness));\n    }\n    \n    return fxSaveParticle(p, dataType);\n}\n\n// PARTICLE NEIGHBOR UPDATE\n\nbool iscoincidence(uvec4 bestIds, uint currentId, uint id)\n{\n    return id == -1U || id >= g_MaxParticles ||\n      \tid == currentId ||\n        any(equal(bestIds,uvec4(id)));\n}\n\nvoid sort0(sampler2D par, uint wd, inout uvec4 bestIds, inout vec4 bestDists, uint currentId, uint searchId, uint dataType, vec2 myPos)\n{\n    if(iscoincidence(bestIds, currentId, searchId)) return; //particle already sorted\n    \n    vec2 nbX = fxGetParticleDataImpl(par, wd, searchId, POS).xy; \n\n    vec2 dx = nbX - myPos;\n    uint dir = uint(2.*(atan(dx.y, dx.x)+PI)/PI); \n\n    if(dir != dataType) return; //not in this sector\n    \n    float t = length2(dx);\n    \n    insertionSort(bestIds, bestDists, searchId, t);\n}\n\n#define voronoiParticle(A, B, C, D) voronoiParticleImpl(iChannel0, iChannel1, R, A, B, C, D)\nvec4 voronoiParticleImpl(sampler2D par, sampler2D vor, vec2 res, fxState s, fxParticle p, uint id, uint dataType)\n{\n    uvec4 closest = fxGetClosestImpl(vor, ivec2(mathToImageCoords(p.pos, res)));\n    uvec4 bestIds = uvec4(-1);\n    vec4 bestDists = vec4(1e6);\n\n    if (s.frame > 0)\n    {\n        for (int i = 0; i < 4; ++i)\n        {\n            sort0(par, uint(res.x), bestIds, bestDists, id, p.nbs[0][i], dataType, p.pos);\n            sort0(par, uint(res.x), bestIds, bestDists, id, p.nbs[1][i], dataType, p.pos);\n            sort0(par, uint(res.x), bestIds, bestDists, id, p.nbs[2][i], dataType, p.pos);\n            sort0(par, uint(res.x), bestIds, bestDists, id, p.nbs[3][i], dataType, p.pos);\n            sort0(par, uint(res.x), bestIds, bestDists, id, closest[i], dataType, p.pos);\n        }\n\n        uint searchIterations = 4U;\n        for(uint k = 0U; k < searchIterations; k++)\n        {\n            //random hash. We should make sure that two pixels in the same frame never make the same hash!\n            float h = hash3(uvec3(id + k, id * k, k * uint(s.frame))).x;\n            //pick random id of particle\n            uint s = uint(mod(h*34534.0, float(g_MaxParticles)));\n            sort0(par, uint(res.x), bestIds, bestDists, id, s, dataType, p.pos);  //sort this\n        }\n    }\n    \n    return uintBitsToFloat(bestIds);\n}\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"// ---------------------------------------------------------------------------------------\n//\tParticle simulation\n// ---------------------------------------------------------------------------------------\n\nvoid mainImage( out vec4 O, vec2 fragCoord )\n{\n    uvec2 ufc = uvec2(fragCoord);\n    \n    computeMaxParticles();\n    uint index = ufc.x + ufc.y * uint(R.x); // \"1D array\" index\n    uint id = index / NUM_PARTICLE_DATA_TYPES; // which particle\n    uint dataType = index - id * NUM_PARTICLE_DATA_TYPES; // which field of particle structure\n    if (id >= g_MaxParticles) return;\n    \n    fxParticle p = fxGetParticle(id);\n    fxState s = fxGetState();\n    \n    if (dataType >= POS)\n        O = updateParticle(s, p, id, dataType, iFrame);\n    else\n        O = voronoiParticle(s, p, id, dataType);\n}\n","name":"Buffer C","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"// ---------------------------------------------------------------------------------------\n//\tVoronoi tracking buffer and persistent state\n// ---------------------------------------------------------------------------------------\n\nvec4 voronoiScreen(fxState s, vec2 u);\nvec4 updateState(fxState s);\n\nvoid mainImage(out vec4 O, vec2 u)\n{\n    fxState s = fxGetState();\n    computeMaxParticles();\n\n    if (fxIsStatePixel(u))\n        O = updateState(s);\n    else\n        O = voronoiScreen(s, u);\n}\n\nvec4 updateState(fxState s)\n{\n    if (iFrame <= 2 || R.x * R.y != abs(s.res))\n    {\n        s.res = -R.x * R.y;\n        s.frame = -1;\n        s.init = true;\n    }\n    else\n    {\n        s.res = abs(s.res);\n        s.frame++;\n        s.init = false;\n    }\n\n    return fxPutState(s);\n}\n\n// find the squared distance from the screen position to a particular particle\nfloat distance2Particle(uint id, vec2 u)\n{\n    fxParticle v = fxGetParticle(id);\n    \n    return min(length2(v.pos - u), length2(v.prev - u));\n}\n\n// get all the existing neighbors of a cell and consider them as possible improvements for ourselves\nvoid sortNbs(uvec4 old, vec2 p, inout uvec4 new, inout vec4 dis)\n{\n    for (int j = 0; j < 4; j++)\n    {\n        uint id = old[j];\n        if (id == -1U || id >= g_MaxParticles) break;\n        float dis2 = distance2Particle(id, p);\n        insertionSort( new, dis, id, dis2 );\n    }\n}\n\nvec4 voronoiScreen(fxState s, vec2 u)\n{\n\tvec2 p = imageToMathCoords(u, R);\n    uvec4 new = uvec4(-1); // the four new closest particles\n    vec4 dis = vec4(1e6);  // the distances of the four newest particles\n\n    if (s.frame > 0)\n    {\n        uvec4 old = fxGetClosest(ivec2(u));\n                \n        sortNbs(old, p, new, dis); // start with our previous frame's values, and look up the distances\n        \n        int SEARCH_STEPS = int(2e4 / R.y);\n        const float SEARCH_RANGE = 20.;\n\n        for(int i = 0; i < SEARCH_STEPS; ++i)\n        {\n            vec2 h = hash3(uvec3(u, s.frame * 4 + i)).xy - .5;\n\n            sortNbs(fxGetClosest(ivec2(u + vec2(h * SEARCH_RANGE))), p, new, dis);\n        }\n\n        // random searching to kick start the process\n        float h = hash3(uvec3(u, s.frame)).x;\n        uint id = uint(h*float(g_MaxParticles));\n        insertionSort(new, dis, id, distance2Particle(id, p));\n    }\n    \n    return uintBitsToFloat(new);\n}","name":"Buffer D","description":"","type":"buffer"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// ---------------------------------------------------------------------------------------\n//\tRendering particles onto Buffer B, and fading out old frame\n// ---------------------------------------------------------------------------------------\n\nvoid renderParticle(fxParticle v, vec2 p, uint id, float sc, inout vec4 tempColor)\n{\n    float d = fxLinePointDist(v.pos, v.prev, p);\n    vec3 color = v.color;\n    \n    if (d <= v.size*sc) {\n        tempColor.xyz = clamp(tempColor.xyz + color, 0.0, 1.0);\n    }\n}\n\nvoid mainImage(out vec4 O, vec2 u)\n{\n    computeMaxParticles();\n\n    vec2 p = imageToMathCoords(u, R);\n\n    uvec4 old = fxGetClosest(ivec2(u));\n    fxState s = fxGetState();\n\n    // render particles\n    vec4 tempColor = vec4(BACK_COLOR, 1.);\n    for (int i = 0; i < 4; ++i)\n    {\n        uint id = old[i];\n        if (id == -1U || id >= g_MaxParticles) break;\n        fxParticle v = fxGetParticle(id);\n        renderParticle(v, p, id, SCALE, tempColor);\n    }\n    \n    vec2 uv = u.xy / R.xy;\n    vec4 col = texture(iChannel2, uv);\n    vec4 currentColor = vec4(col.rgb, 1.);\n    O = clamp(tempColor + currentColor*FADEOUT_SPEED ,0.,1.);\n\n}\n","name":"Buffer B","description":"","type":"buffer"}]}