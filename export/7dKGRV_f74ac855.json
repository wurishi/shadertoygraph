{"ver":"0.1","info":{"id":"7dKGRV","date":"1631830401","viewed":116,"name":"Alhambra Kings Hall  tiling I","username":"curena","description":"Islamic Start Patterns: Sala de Los Reyes, Alhambra, Granada, Spain (ilustration of wallpaper groups and symmetry in general). ","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["symmetry","islamicstarpattern","alhambra"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// ISLAMIC STAR PATTERNS\n// Alhambra, Sala de los Reyes (Kings Hall)\n// If you ignore colours, this is clearly p6m\n//\n// Carlos Ure√±a, Sept. 2021\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n// -----------------------------------------------------------------------------------\n\n\n// ------------------------------------------------------------------------------------\n// configurable constants (visualization)\n\nconst int   nspp_root       = 7 ;   // root of the number of samples per pixel \nconst float vis_wcc_sx      = 7.0 ; // visible region in world coordinates, size in X\n\nbool schematic_view = false ; // set to true to highlight fundamental region and reflection axes\n\n// ------------------------------------------------------------------------------------\n// configurable constants (tiling shape)\n\n\nconst float color_bands_width = 0.15 ;  // just guessing ...\n\n\n// ------------------------------------------------------------------------------------\n// computed or fixed constants \n\nconst int   nspp        = nspp_root*nspp_root; // number of samples per pixel\nconst float nspp_root_f = float(nspp_root);    // root of number of samples per pixel (as a float)\n\nconst float cos_60 = 0.5 ;\nconst float sin_60 = 0.86602540378 ; // sqrt(1-cos_60*cos_60)\nconst float cos_30 = sin_60 ;\nconst float sin_30 = cos_60 ;\n\nconst float pi            = 3.14159265359 ;\nconst float root_of_2     = 1.41421356237 ;\nconst float root_of_2_inv = 1.0/root_of_2 ;\n\n\n// -------------------------------------------------------------------------------\n// mirror reflection of 'p' around and axis through two points 'q1' and 'q2'\n// (only for points in the halfplane to the right of the line from p1 to p2)\n// 'mirror_count' is increased only when 'p' is in the right halfplane\n\nvec2 MirrorPP( vec2 p, vec2 q1, vec2 q2, inout int mirror_count )\n{\n \tvec2   s = q2-q1 ,\n           n = normalize(vec2( s.y, -s.x )) ;\n    float  d = dot(p-q1,n) ;\n\n    if ( 0.0 <= d )\n    {\n       mirror_count = mirror_count+1; \n       return p-2.0*d*n ;\n    }\n    else\n       return p ;\n}\n\n// -------------------------------------------------------------------------------\n// mirror reflection of 'p' around and axis through point 'q' and parallel to \n// normalized vector 'n'\n// (only for points in the halfplane to the right of the axis)\n// 'mirror_count' is increased only when 'p' is in the right halfplane\n\nvec2 CondMirrorRightPN( vec2 p, vec2 q, vec2 n, inout int mirror_count )\n{\n \tvec2   m = vec2( n.y, -n.x ) ; // perpendicular to n, to the right side\n    float  d = dot( p-q, m ) ;\n    float  b = step( 0.0, d ) ;\n    \n    mirror_count = mirror_count + int(b) ;\n    return p-2.0*b*d*m ;\n}\n\n//-------------------------------------------------------------------------------------\n// returns the signed distance between a point 'p' and the line through 'q' parallel\n// to normalized vector 'n'.\n// The distance is positive to the right of the line, negative to the left\n\nfloat SignedDistancePN( vec2 p, vec2 q, vec2 n )\n{\n    return dot( p-q, vec2( n.y, -n.x ) );\n}\n\n//-------------------------------------------------------------------------------------\n// returns true iif 'p' is on the left side of the line through 'a' towards 'b' \n// returns false for the right side\n\nbool IsOnLeftSide( vec2 p, vec2 a, vec2 b )\n{\n   // use dot product of b-a and vector to the left direction\n   return 0.0 <= dot( p-a, vec2( a.y-b.y, b.x-a.x ) )  ;\n}\n\n//-------------------------------------------------------------------------------------\n// Compute pattern color at a point given in WCC\n\nvec4 PatternWCC( in vec2 point_wcc )\n{\n    // counters for the number of mirror transformations performed to take the point to the fundamental region\n    int    \n          msc1 = 0 ,\n          msc2 = 0 ,\n          msc3 = 0 ,\n          msc4 = 0 ;\n    \n    // (t1,t2) --> translation symmetries vectors (both are normalized)\n    vec2  t1  = vec2( 1.0, 0.0 ),\n          t2  = vec2( cos_60, sin_60 );\n          \n    // compute pct = point coordinates in the translation vectors base\n    // (this code is generic, can be optimized and simplified for particular cases of (t1,t2), as this\n    \n    float d = dot(t1,t2);   // == cos_60 == 0.5 \n    \n    vec2 t1_dual  = t1-d*t2,      \n         t2_dual  = t2-d*t1 ;        \n    vec2 pct      = vec2( dot( point_wcc, t1_dual ), dot( point_wcc, t2_dual ));   \n    vec2 pct_inte = floor( pct );\n    vec2 pct_frac = pct - pct_inte ;\n    \n    // compute pc1 = point back in cartesian coordinates, inside de translation subgroup fundamental region\n    \n    vec2 pc1 = pct_frac.x*t1 + pct_frac.y*t2 ; \n    \n    // compute pfr = corresponding point in the group's fundamental region\n    // we take the point 'pc1' to the fundamental region by using conditional mirror reflections\n    vec2 pc2 = CondMirrorRightPN( pc1, vec2( 1.0, 0.0 ),        vec2( -cos_60,  sin_60 ), msc1 ); // diagonal of translation fundamental region\n    vec2 pc3 = CondMirrorRightPN( pc2, vec2( 0.5, 0.0 ),        vec2(  0.0,     1.0 ),    msc2 ); // vertical bisector of equilateral triangle\n    vec2 pc4 = CondMirrorRightPN( pc3, vec2( 1.0, 0.0 ),        vec2( -cos_30,  sin_30 ), msc3 ); // \"downward\" bisector  of equilateral triangle\n    vec2 pfr = CondMirrorRightPN( pc4, vec2( cos_30, sin_30 ),  vec2( -cos_30, -sin_30 ), msc4 ); // \"uppward\" bisector of equilateral triangle\n    \n    // w = half widths of color bands\n    float w = color_bands_width/2.0 ;\n    \n    // compute distances to axes for the four bands \n    \n    float d1 = SignedDistancePN( pfr, vec2( 1.0, 0.0 ), vec2(  -1.0,    0.0 ) );\n    float d2 = SignedDistancePN( pfr, vec2( 0.0, 0.0 ), vec2(  cos_30,  sin_30 ) );\n    float d3 = SignedDistancePN( pfr, vec2( 0.0, 0.0 ), vec2( -cos_30,  sin_30 ) );\n    float d4 = SignedDistancePN( pfr, vec2( 0.0, 0.0 ), vec2(  cos_60,  sin_60 ) );\n    float d5 = SignedDistancePN( pfr, vec2( 1.0, 0.0 ), vec2(  cos_30, -sin_30 ) );\n    float d6 = SignedDistancePN( pfr, vec2( 0.5, 0.0 ), vec2(  cos_60, -sin_60 ) );\n    \n    // compute hemispaces inclusion\n    \n    bool h1 = d1 <= w ;\n    bool h2 = d2 <= w ;\n    bool h3 = d3 <= w ;\n    bool h4 = d4 <= w ;\n    bool h5 = d5 <= w ;\n    bool h6 = 0.0 <= d6 ;\n    \n    // compute \"color\" regions inclusions\n    bool inr1 = h1 && (! h2) && h6;\n    bool inr2 = h3 || h4 ;\n    bool inr3 = (! h1) && h2 && (! h5) ;\n    \n    // compute color for schematic view\n    if ( schematic_view )\n    {\n       bool in_color = inr1 || inr2 || inr3 ;\n       bool fundm    = (msc1 == 0 ) && (msc2 == 0) && (msc3 == 0) && (msc4 == 0) \n                        && (int(pct_inte.x) == 0) && (int(pct_inte.y) == 0);\n                        \n       float d7 = 0.5-pfr.x ;\n       float d = min( d1, min( d2, d7) );\n       const float ew = 0.004 ;\n       \n       if ( d < ew*0.5 )\n          return vec4( 0.7, 0.5, 0.5, 1.0 ); // fund. region edges\n          \n       if ( fundm )\n       {\n          if ( in_color )\n              return vec4( 0.8, 0.0, 0.0, 1.0 );\n          else \n              return vec4( 0.95, 0.9, 0.9, 1.0 );\n       }\n       if ( in_color )\n           return vec4( 0.6, 0.6, 0.6, 1.0 );\n           \n       return vec4( 1.0, 1.0, 1.0, 1.0 );\n    }\n    \n    \n    \n    if ( inr1 )\n    {\n        bool blue ; // true iif color is blue, false if color is black\n        \n        if ( msc1 == 0 )\n           blue = ( msc4 == 0  ); \n        else \n           blue = ( msc4 > 0 && msc2 == 0);     \n            \n        if ( blue )\n          return vec4( 0.0, 0.0, 0.8, 1.0 ); // horizontal bands from star center to star center (blue)\n        else\n          return vec4( 0.0, 0.0, 0.0, 1.0 ); // diagonal bands from star center to star center (black)\n    }\n    else if ( inr2 )\n    {    \n        return vec4( 0.0, 0.0, 0.0, 1.0 ); // stars (black)\n    }\n    else if ( inr3 )\n    {\n        if ( 0 < msc1 )\n           return vec4( 0.9, 0.6, 0.0, 1.0 ); // orange-yellow regions\n        else\n           return vec4( 0.0, 0.4, 0.0, 1.0 ) ; // dark green regions\n    }\n    else \n        return vec4( 1.0, 0.96, 0.9, 1.0 ); // background, almost white but with a slight reddish hue\n    \n}\n\n\n//-------------------------------------------------------------------------------------\n// Compute anti-aliased pixel colors for a point given in device coordinates\n// point_dcc = integer pixel coordinates, starting at zero (device coordinates)\n\nvec4 AAPixelColor( in vec2 point_dcc )\n{\n    vec4 sum  = vec4( 0.0, 0.0, 0.0, 1.0 ); // sum of samples colours \n     \n    for( int i = 0 ; i < nspp_root ; i++ )\n    for( int j = 0 ; j < nspp_root ; j++ )\n    {\n       // compute sample position in device coordinates, then in world coordinates\n       vec2 sample_dcc = point_dcc + (vec2(float(i)+0.5,float(j)+0.5)/nspp_root_f) ;\n       vec2 sample_wcc = vis_wcc_sx*(sample_dcc-0.5*iResolution.xy)/iResolution.xx ;\n       \n       // add this sample color to 'sum'\n       sum = sum + PatternWCC( sample_wcc ); \n    }\n    return sum/float(nspp_root*nspp_root) ;\n}\n//-------------------------------------------------------------------------------------\n// main function\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    fragColor = AAPixelColor( fragCoord ) ;\n    \n}","name":"Image","description":"","type":"image"}]}