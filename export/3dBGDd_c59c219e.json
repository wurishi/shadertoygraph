{"ver":"0.1","info":{"id":"3dBGDd","date":"1550242501","viewed":357,"name":"precision error on sinh & asinh","username":"FabriceNeyret2","description":"top to bottom:  ( grey = 0 )\nsinh ,   asinh ,   sinh(x) + sinh(-x) ,  same with optimizer off ,  asinh(x) + asinh(-x) ,  sinh(asinh(x)) - x  \n- sinh(x) undefined for x > 88  but if lucky optimiz\n- sinh(x) & asinh(x) have very poor symmetry ( x<0 wrong )","likes":3,"published":3,"flags":0,"usePreview":0,"tags":["precision","ieee","bug","gpu","glslerror"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// why you should always do\n// #define asinh(z) ( sign(z) * asinh(abs(z)) )\n\n#define Z min(0.,iTime) // forbid expression optimizing\n\n// explanation  asinh(z) = log ( z+ sqrt( z*z + 1 ) )\n// but log precision is very asymmetrical on negative vs positive branch\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 R = iResolution.xy,\n         U = u - .5*R;\n    \n    int i = int(6.*u.y/R.y);\n    float x = U.x,\n          y = mod(6.*u.y,R.y) - .5*R.y;\n    \n    O = vec4(\n          i==5 ? float( 10.*y <  sinh(x)          )\n        : i==4 ? float( .1 *y < asinh(x)          )\n        : i==3 ? .5+ 1e9*(  sinh(x)  + sinh(-x)   )\n        : i==2 ? .5+ 1e9*(  sinh(x+Z)+ sinh(-x+Z) )\n        : i==1 ? .5+ 1e2*( asinh(x)  + asinh(-x)  )\n        : i==0 ? .5 +    ( sinh(asinh(x)) - x     )\n        : 0.);\n\n    //O = .5+vec4(sinh(asinh(x))+sinh(asinh(-x)));\n    \n    if ( mod(x,100.) == .5 )       O = vec4(0,0,1,0); // x-tick every 100\n    if ( x == .5 )                 O = vec4(0,1,0,0); // x/y axis\n    if ( abs(y+.5) < 3. && i > 3 ) O = vec4(0,1,0,0);\n    if ( int(y+.5*R.y) < 6 )       O = vec4(1,0,0,0); // separators\n}","name":"Image","description":"","type":"image"}]}