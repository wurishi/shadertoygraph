{"ver":"0.1","info":{"id":"3s3XWX","date":"1593414730","viewed":74,"name":"Raymarching Reflection Test","username":"OfficeBatman","description":"A shader demonstrating raymarching with reflections and basic shadows","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","reflections"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MaxDist 30.\n#define SurfDist .003\n#define MaxIter 200\n#define Background vec3(.1,.1,.25)\n\nbool raymarch(vec3,vec3,out float,out int);\nfloat sdf(vec3);\nvec3 color(vec3,vec3,int);\n\nbool raymarch(vec3 ro, vec3 rd, out float dist, out int iter) {\n    dist = 0.;\n    for (iter = 0; iter < MaxIter; iter++) {\n    \tvec3 p = ro + dist * rd;\n        float delta = sdf(p);   \n        dist += delta*.75;\n        if (delta < SurfDist) return true;\n        if (dist > MaxDist) return false; \n    }\n    return false;\n}\n\nvec3 normal(vec3 p) {\n\tconst vec2 e = vec2(.01,.0);\n    float d0 = sdf(p);\n    return normalize(vec3(\n        sdf(p+e.xyy) - d0,\n        sdf(p+e.yxy) - d0,\n        sdf(p+e.yyx) - d0 ));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    // Normalized pixel coordinates (from -.5 to .5 on y)\n    vec2 uv = (fragCoord-iResolution.xy*.5)/iResolution.y;\n    \n    float t = iTime/10. + iMouse.x/iResolution.x*7.;\n    float k = iMouse.y/iResolution.y*1.2-1.;\n    float cs = cos(t), sn = sin(t);\n    float cs2 = cos(k), sn2 = sin(k);\n    \n    vec3 rd = vec3(uv,1.);\n    rd.yz *= mat2(cs2,sn2,-sn2,cs2);\n    rd.xz *= mat2(cs,sn,-sn,cs);\n    vec3 ro = vec3(0,1.7,-5);\n    ro.yz *= mat2(cs2,sn2,-sn2,cs2);\n    ro.xz *= mat2(cs,sn,-sn,cs);\n    \n    float d;\n    int i;\n    vec3 col;\n    \n    //\tAntialiasing I think\n    const float J = .5;\n    for (float x = 0.; x < 1.; x+=J) {\n        for (float y = 0.; y < 1.; y+=J) {\n            vec2 a = (vec2(x,y)-vec2(.5))/iResolution.xy;\n            vec3 c;\n            vec3 rd_ = normalize(rd+vec3(a,0));\n            if (raymarch(ro, rd_, d, i)) {\n                vec3 p = ro + d*rd_;\t//\tfirst pass point\n                c = color(p, rd, i);\n                c = mix(c, Background, d/MaxDist);\t//\tAdd fog\n            } else {\n                c = Background;   \n            }\n            col += c;\n        }\n    }\n    col /= 1./J/J; \n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n\nfloat sdfobj1(vec3 p) {\n    const float c = 3.;\n    p -= vec3(0,1.5,0);\n    p = mod(p+0.5*c,c)-0.5*c; \n    return length(p)-1.; \n}\n\nfloat sdf(vec3 p) {\n\treturn min(p.y, sdfobj1(p));   \n}\n\nvec3 simpleColor(vec3 p, vec3 n, int i) {\n\tconst vec3 lp = vec3(3.5,2,-1);\n    vec3 ld = normalize(lp - p);\n    vec3 col = vec3(1); \n    if (sdfobj1(p) < SurfDist*4.) {\n        if (fract(dot(floor(p), vec3(.5))) > .001) {\n            col *= vec3(.8,.5,.9);\n        }\n        col *= vec3(i)/20.;\n    }\t// else col *= vec3(1);\n    col *= vec3(clamp(.3+.5*dot(n,ld), 0., 1.));\n        \n    //return max(vec3(0),min(vec3(1),col));\n    return col;\n}\n\n//\tcolor based on point light(no cast shadows), reflection, and sdf\nvec3 color(vec3 p, vec3 rd, int i) {\n    vec3 n = normal(p);\n    vec3 col = simpleColor(p,n,i);\n    \n    vec3 rflct = reflect(rd,n);\n    float d;\n    int i2;\n    if (!(p.y < SurfDist*2.)/*&&false*/) {\n        if (raymarch(p+n*SurfDist*2., rflct, d, i2)) {\n            vec3 p2 = p + d*rflct;\t//\tsecond pass point\n            vec3 n2 = normal(p2);\n            vec3 col2 = simpleColor(p2,n2,i2);\n            col *= mix(vec3(1), col2, .5);\n        } else col *= Background;\n    }\n        \n    return max(vec3(0),min(vec3(1),col));\n}","name":"Image","description":"","type":"image"}]}