{"ver":"0.1","info":{"id":"MfcyRf","date":"1730951301","viewed":130,"name":"Cosmic Serpent 3D","username":"orblivius","description":"Cosmic Serpent 3D Visualizer:  Demonstratates how to inexpensive to CPU produce glow effect by superimposing 2D and 3D computations","likes":6,"published":3,"flags":32,"usePreview":0,"tags":["fft","audio","demo","visualizer","3dand2d"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Cosmic Serpent 3D visualizer by Orblivius\n\n// Demonstratates how to inexpensively \n// produce glow effect by superimposing 2D and 3D computations\n\n// Hint: Use mouse to control the angle at the serpent\n// To do: fix palette skewing bug (to retain solid rainbow gradient)\n\n//   GIT: https://github.com/mewza/\n// Email: orblivius@protonmail.com\n\n//Sources used: https://shadertoy.com/view/wlfcR2\n//              https://shadertoy.com/view/XdjyRm\n\n#define ANIMATION_SPEED 1.5\n#define MOVEMENT_SPEED 1.0\n#define MOVEMENT_DIRECTION vec2(0.0, -1.0)\n\n#define SIZE_MOD 1.05\n#define ALPHA_MOD 0.8\n\n#define STEPS 20.\n\n#define ENABLE_RADIAL_BLUR \n#define ENABLE_BACK_GLOW\n\n#define OUTER_GLOW_LEN .1\n#define INNER_GLOW_LEN  .1\n#define GLOW_BRIGHTNESS 1.5\n#define GLOW_THRESH 1.2\n#define SMOKE_COLOR vec3(0.0, 0.43, 1.81) * 0.85\n\n#define ORANGE  (1.+cos(inUV.y*2.+.8 + vec3(0,1,2)))\nmakeStrF(printTime)   _S _p _e _e _d _COL __ _num_ _endNum             \n\nvec4 cam = vec4(0);\n\nfloat hash1_2(in vec2 x)\n{\n \treturn fract(sin(dot(x, vec2(52.127, 61.2871))) * 521.582);   \n}\n\nvec2 hash2_2(in vec2 x)\n{\n    return fract(sin(x * mat2(20.52, 24.1994, 70.291, 80.171)) * 492.194);\n}\n\n//Simple interpolated noise\nvec2 noise2_2(vec2 uv)\n{\n    //vec2 f = fract(uv);\n    vec2 f = smoothstep(0.0, 1.0, fract(uv));\n    \n \tvec2 uv00 = floor(uv);\n    vec2 uv01 = uv00 + vec2(0,1);\n    vec2 uv10 = uv00 + vec2(1,0);\n    vec2 uv11 = uv00 + 1.0;\n    vec2 v00 = hash2_2(uv00);\n    vec2 v01 = hash2_2(uv01);\n    vec2 v10 = hash2_2(uv10);\n    vec2 v11 = hash2_2(uv11);\n    \n    vec2 v0 = mix(v00, v01, f.y);\n    vec2 v1 = mix(v10, v11, f.y);\n    vec2 v = mix(v0, v1, f.x);\n    \n    return v;\n}\n\n//Simple interpolated noise\nfloat noise1_2(in vec2 uv)\n{\n    vec2 f = fract(uv);\n    //vec2 f = smoothstep(0.0, 1.0, fract(uv));\n    \n \tvec2 uv00 = floor(uv);\n    vec2 uv01 = uv00 + vec2(0,1);\n    vec2 uv10 = uv00 + vec2(1,0);\n    vec2 uv11 = uv00 + 1.0;\n    \n    float v00 = hash1_2(uv00);\n    float v01 = hash1_2(uv01);\n    float v10 = hash1_2(uv10);\n    float v11 = hash1_2(uv11);\n    \n    float v0 = mix(v00, v01, f.y);\n    float v1 = mix(v10, v11, f.y);\n    float v = mix(v0, v1, f.x);\n    \n    return v;\n}\n\n\nfloat layeredNoise1_2(in vec2 uv, in float sizeMod, in float alphaMod, in int layers, in float animation)\n{\n \tfloat noise = 0.0;\n    float alpha = 1.0;\n    float size = 1.0;\n    vec2 offset;\n    for (int i = 0; i < layers; i++)\n    {\n        offset += hash2_2(vec2(alpha, size)) * 10.0;\n        \n        //Adding noise with movement\n     \tnoise += noise1_2(uv * size + iTime * animation * 8.0 * MOVEMENT_DIRECTION * MOVEMENT_SPEED + offset) * alpha;\n        alpha *= alphaMod;\n        size *= sizeMod;\n    }\n    \n    noise *= (1.0 - alphaMod)/(1.0 - pow(alphaMod, float(layers)));\n    return noise;\n}\n\n//Rotates point around 0,0\nvec2 rotate(in vec2 point, in float deg)\n{\n \tfloat s = sin(deg);\n    float c = cos(deg);\n    return mat2(s, c, -c, s) * point;\n}\n\n//Cell center from point on the grid\nvec2 voronoiPointFromRoot(in vec2 root, in float deg)\n{\n  \tvec2 point = hash2_2(root) - 0.5;\n    float s = sin(deg);\n    float c = cos(deg);\n    point = mat2(s, c, -c, s) * point * 0.66;\n    point += root + 0.5;\n    return point;\n}\n\n//Voronoi cell point rotation degrees\nfloat degFromRootUV(in vec2 uv)\n{\n \treturn iTime * ANIMATION_SPEED * (hash1_2(uv) - 0.5) * 2.0;   \n}\n\n\nvec4 particleImage(in vec2 fragCoord )\n{\n    vec2 uv = (2.0 * fragCoord - iResolution.xy) / iResolution.x;\n    \n    float vignette = 1.0 - smoothstep(0.4, 1.4, length(uv + vec2(0.0, 0.3)));\n    \n    \n    float smokeIntensity = layeredNoise1_2(uv * 10.0 + iTime * 4.0 * MOVEMENT_DIRECTION * MOVEMENT_SPEED, 1.7, 0.7, 6, 0.2);\n    smokeIntensity *= pow(1.0 - smoothstep(-1.0, 1.6, uv.y), 2.0); \n    vec3 smoke = smokeIntensity * SMOKE_COLOR * 0.8 * vignette;\n    \n    //Cutting holes in smoke\n   // smoke *= pow(layeredNoise1_2(uv * 4.0 + iTime * 0.5 * MOVEMENT_DIRECTION * MOVEMENT_SPEED, 1.8, 0.5, 3, 0.2), 2.0) * 1.5;\n    \n    \n    vec3 col = SMOKE_COLOR * 0.2;//smoke\n\t//col *= vignette;\n  \n    float lightStrength = 0.1;\n    \n    col = smoothstep(-0.08 - lightStrength, 1.0, col);\n\n    return vec4(col, 1.0);\n}\n\n\nvec4 blurEffect( sampler2D sourceImage, vec2 inUV, vec2 innerPoint ){\n    \n    vec2 targetVector = innerPoint - inUV;\n    float shineFactor = 1. - length(targetVector) / sqrt(2.);\n    \n    //shineFactor*= (sin(iTime) +1.)/2.;\n    \n    vec4 result = texture(sourceImage, inUV);\n    \n    // Turn on to overlay blur over texture\n    bool textureOverlay = true;\n    \n    cam = texelFetch(iChannel2,  ivec2(1,1), 0);\n     \n   \n    float speed = cam.w;\n    vec2 p = cam.xy;\n    float angle = PI/2.;\n\tfloat a = atan(p.y, p.x) + angle/120.;\n\tfloat r = length(p);\n\tfloat c = floor(a/angle);\n\ta = mod(a,angle) - angle/2.;\n\tp = vec2(cos(a), sin(a))*r;\n    \n    float radius = 0.5;\n    float dx = length(p.xy) - .25;\n    targetVector = vec2(dx*2., max(dx, (p.y))-.5) + inUV;\n    \n    \n      float dstep = 1./STEPS;\n#ifdef ENABLE_RADIAL_BLUR\n        for(float dist = 0.0; dist < 1.; dist += dstep) {\n            vec2 tardist = targetVector * dist;\n           \n            vec4 blurTex = GLOW_BRIGHTNESS * (texture(sourceImage, inUV - tardist * OUTER_GLOW_LEN)\n\n#ifdef ENABLE_BACK_GLOW\n            + texture(sourceImage, inUV + tardist * INNER_GLOW_LEN)  \n#endif\n            ) / STEPS;\n            vec4 partCol = particleImage(inUV - tardist);\n            result += max(GLOW_THRESH-(dist),.1) * blurTex;\n        }\n#else\n       \n#endif\n   \n   result.rgb += ORANGE * printTime(inUV+vec2(0,0), speed, 2);\n   return result;    \n}\n\nvec3 ACES(vec3 x){\n    float a = 2.5;\n    float b = 0.03;\n    float c = 2.4;\n    float d = 0.6;\n    float e = 0.14;\n    return clamp((x*(a*x+b))/(x*(c*x+d)+e), 0.0, 1.0);\n}\n\nfloat luma(vec3 color) {\n  return dot(color, vec3(0.299, 0.587, 0.114));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec2 m = iMouse.xy;\n    m =  vec2(m.x,m.y*.5);\n    vec2 innerPoint = m / iResolution.xy;\n\n    vec4 starfield = texture(iChannel2, uv);\n    vec4 blurTex, blurCol = blurTex = blurEffect(iChannel0, uv, innerPoint);\n    \n    vec4 colorTex = texture(iChannel1,uv);\n    fragColor =  blurCol + colorTex*1.05  + starfield;\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4sXGRr","filepath":"/media/a/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3","previewfilepath":"/media/ap/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3","type":"music","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Cosmic Serpent 3D visualizer by Orblivius\n\n// Demonstratates how to inexpensively \n// produce glow effect by superimposing 2D and 3D computations\n\n// Hint: Use mouse to control the angle at the serpent\n// To do: fix palette skewing bug (to retain solid rainbow gradient)\n\n//   GIT: https://github.com/mewza/\n// Email: orblivius@protonmail.com\n\n//Sources used: https://shadertoy.com/view/wlfcR2\n//              https://shadertoy.com/view/XdjyRm\n\n#define ORANGE  (1.+cos(vScreenUV.y*1.+.7 + vec3(0,1,2)))\n\nfloat fParticleSize = 0.0001;\nfloat fParticleLength = 0.6 / 60.0;\nfloat fBrightness = .8;\nconst float EPSILON = 1e-5;\n\n// Number of angular segments\nfloat fSteps = 50.0;\n\n// Min and Max star position radius. Min must be present to prevent stars too near camera\nfloat fMinDist = 0.8;\nfloat fMaxDist = 20.0;\n\nfloat fRepeatMin = 1.0;\nfloat fRepeatMax = 1.0;\n\n// fog density\nfloat fDepthFade = 2.;\n\n float iCamRotX = 0.;\n float iCamRotY = 0.;\n float iCamRotZ = 0.;\n\nvec3 gDeltaPos = vec3(0);\n\n\nfloat afFrequencies[NUM];\n\nconst float epsilon = 0.0001;\nconst float maxT = 50.0;\n\nconst float RADIUS = 2.5;\n\nconst int circleTiles = NUM;\nconst vec3 CUBESIZE = vec3(0.015);\nconst float lightAttenuation = 1.;\n\nvec2 mouse = vec2(0);\n\n// Calculate matrix for camera looking at a specific target\n\nfloat luma(vec3 color) {\n  return dot(color, vec3(0.299, 0.587, 0.114));\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n\treturn mat3( cu, cv, cw );\n}\nfloat vmax(vec3 v) {\n\treturn max(max(v.x, v.y), v.z);\n}\n\nfloat fC(vec3 p, float r, float height) {\n\tfloat d = length(p.xz) - r;\n\td = max(d, abs(p.y) - height);\n\treturn d;\n}\n\nfloat fB(vec3 p, vec3 b) {\n\tvec3 d = abs(p) - b;\n\treturn length(max(d, vec3(0))) + vmax(min(d, vec3(0)));\n}\nfloat sdPlane( vec3 p )\n{\n\treturn p.y;\n}\n\nfloat pModPolar(inout vec2 p, float repetitions) {\n\tfloat angle = 2.*PI/repetitions;\n\tfloat a = atan(p.y, p.x) + angle/2.;\n\tfloat r = length(p);\n\tfloat c = floor(a/angle);\n\ta = mod(a,angle) - angle/2.;\n\tp = vec2(cos(a), sin(a))*r;\n\t\n    if (abs(c) >= (repetitions/2.)) c = abs(c);\n\treturn c;\n}\n\n\nfloat cubeCircle(vec2 uv, vec3 point, float radius, int count, vec3 cubeSize)\n{\n\tfloat c = pModPolar(point.xz, float(NUM));\n\tfloat index = mod(float(NUM)+c, float(NUM)/2.);\n    \n    vec3 p = point - vec3(radius,0,0);\n    float f = .5 * pow(afFrequencies[int(index)],SCALE);\n\t\n    return fB(p,  vec3(min(cubeSize.x,.5), min(cubeSize.y+f,.5), min(cubeSize.z,.5))); //d; //fC(point-vec3(radius,0,0), 0.02, f);\n}\n\nvec3 getMaterialColor(vec3 point)\n{\n\tfloat c = pModPolar(point.xz, float(NUM));\n    float index = mod(float(NUM)+c, float(NUM)/2.);\n\n\treturn vec3(0.0+pow(afFrequencies[int(index)], 1.3));\n}\n\nvec3 hsv2rgb(vec3 c){\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n\n//#define ENABLE_SHADOWS\n#define ENABLE_OCCLUSION \n\n//\tCalculates distance to nearest object given a point\nfloat distFunc( vec2 uv, vec3 point, vec3 cubeSize )\n{\n\t//\tparameters\n\n\t//\tdistance to floor plane\n\t// float planeDist = sdPlane(point);\n\n\t//\tdistances to the cube circles\n\tfloat cubesCircleBigDist = cubeCircle(uv, point, RADIUS, circleTiles, cubeSize);\n\t\n\t//\treturn closest object\n\treturn cubesCircleBigDist; //min(cubesCircleBigDist, planeDist);\n}\n\nvec3 getNormal( vec2 uv, in vec3 pos , in vec3 cubesize)\n{\n\t// IQ\n\tvec2 e = vec2( 1.0, -1.0 ) * 0.0001;\n\treturn normalize( e.xyy*distFunc( uv, pos + e.xyy, cubesize  ) +\n\te.yyx*distFunc( uv, pos + e.yyx, cubesize) +\n\te.yxy*distFunc( uv, pos + e.yxy, cubesize) +\n\te.xxx*distFunc( uv, pos + e.xxx, cubesize) );\n}\n\n\nfloat ambientOcclusion(vec2 uv, vec3 point, float delta, int samples, vec3 cubesize)\n{\n\tvec3 normal = getNormal(uv, point,cubesize);\n\tfloat occ = 0.;\n\tfor(float i = 1.; i < float(samples); ++i)\n\t{\n\t\tocc += (.2/i) * (i * delta - distFunc(uv, point + i * delta * normal,cubesize));\n\t}\n\t//occ = clamp(occ, 0., 1.);\n\treturn 1. - occ;\n}\n\nfloat softshadow(vec2 uv, const vec3 origin, in vec3 dir, in float mint, in float tmax, float k, vec3 cubesize)\n{\n\tfloat res = 1.0;\n\tfloat t = mint;\n\tfor( int i=0; i<16; i++ )\n\t{\n\t\tfloat h = distFunc( uv, origin + dir*t,cubesize );\n\t\tres = min( res, k*h/t );\n\t\tt += clamp( h, 0.02, 0.10 );\n\t\tif( h<0.001 || t>tmax ) break;\n\t}\n\treturn clamp( res, 0.0, 1.0 );\n}\n\n\nfloat min_comp(in vec4 comps) {\n    return min(comps.x, min(comps.y, comps.z));\n}\n\nvec4 getShadeColor( vec2 uv, vec3 point, vec3 normal, vec3 camP, vec3 camDir, vec3 cubesize)\n{\n\t//\tCalculate ID for each segment of the circular rotation\n\tfloat c = pModPolar(point.xz, float(NUM));\n    float index = mod(float(NUM) + c, float(NUM)/2.);\n  \n    float freq =  afFrequencies[int(index)];\n    vec4 col =  .3 + vec4( hsv2rgb(vec3(c*0.006, 1., .25 + min(pow(freq,3.5),.5))),1.);\n    //clamp(pow(freq,2.),.02,.7))),1.)\n\t\n    //\tlight relative to camera position \n\tvec3 lightPosition = vec3(sin(iTime),2.,cos(iTime));\n\n\t//\tSpecular highlight2factor\n\tfloat materialShininess = 50.;\n\tvec4 materialSpecularColor = 1.25 * col * col;\n\n\t//\tOutput color\n\tvec4 outputColor = vec4(0);\n    \n\t//\tCalculate eye vector and its reflection\n\t\n\tvec3 surfaceToCamera = normalize(camP - point);\n    vec3 surfaceToLight = normalize(lightPosition - point);\n\n\t//\tsurface color\n\tvec4  surfaceColor = vec4(getMaterialColor(point),.5);\n\n\t//\tambient component\n    vec4 lightColor = 1.3 * materialSpecularColor; // col * col;\n    vec4 ambientColor = surfaceColor * lightColor; \n\n\t//\tdiffuse component\n\tfloat diffuseCoefficient = max(0., dot(normal, surfaceToLight.rgb));\n\tvec4 diffuseColor = diffuseCoefficient * surfaceColor * lightColor;\n\n\t//\tspecular component\n\tfloat specularCoefficient = 1.; \n\tif(diffuseCoefficient > 0.0) {\n        specularCoefficient = pow(max(0.0, dot(surfaceToCamera, reflect(-surfaceToLight.rgb, normal))), materialShininess);\n\t}\n\tvec4 specularColor =  materialSpecularColor * lightColor;\n\n\t//\tlight attenuation (falloff based on distance, fog)\n\tfloat distanceToLight = length(lightPosition - point);\n\tfloat attenuation = 1. / (1. + lightAttenuation * pow(distanceToLight, 2.));\n\n\t//\tsoft shadows (optional)\n\t//float shadow = 0.5;\n\t//shadow = max(0.1, softshadow(point, surfaceToLight, .1, 2.0, 10.,cubesize));\n\t\n\t//\tambient occlusion (optional)\n\n\tvec4 occ = vec4(ambientOcclusion(uv, point, 0.001, 10, cubesize));\n\n    outputColor = attenuation *  mix( mix(ambientColor , diffuseColor, 0.5), specularColor, .5); // + specularColor\n    outputColor *= 1./(pow(occ,vec4(2.)));\n\n    return outputColor; \n}\n\nfloat getGlow(float radius, float dist, float intensity)\n{\n    return pow(radius / max(dist, EPSILON), intensity);\n}\n\n\nfloat raymarch(in vec2 uv, in vec3 ro, in vec3 rd, in vec3 cubesize, out vec4 color, inout float glow) \n{\n    vec4 integral = vec4(0.0);\n    float curr = 0.0;\n    const float step_ratio = .45;\n    vec4 curr_sdf = vec4(distFunc(uv, ro, cubesize));\n   \n    color = vec4(0); \n    float dist1, dist = dist1 = step_ratio * min_comp(curr_sdf);\n    vec4 next_sdf = vec4(distFunc(uv, ro + rd * dist, cubesize));\n     vec3 norm, norm1 = norm = getNormal(uv, ro + rd * dist, cubesize);\n     \n    float total_dist = dist;\n    const vec4 thresh = vec4(0.0004);\n \n    for (int i = 0; i < 90; ++i) \n    {\n        curr_sdf = next_sdf;\n        dist = step_ratio * min_comp(curr_sdf);\n        total_dist += dist;\n        vec3 rod = ro + total_dist * rd;\n        next_sdf = vec4(distFunc(uv, rod, cubesize));\n        // norm = getNormal(ro + total_dist * rd, cubesize);\n        \n        glow += getGlow(1e-4, dist, 0.5);\n        \n        vec4 mid = 0.25 * (curr_sdf + next_sdf);\n   \n        integral += dist * (0.5/ max(thresh, curr_sdf) +  0.5 / max(thresh, mid ) +  0.35 / max(thresh, next_sdf));\n \n      // color +=  getShadeColor(uv, rod, norm, ro, rd, cubesize);;\n\n       if (min_comp(next_sdf) < 3.0e-4|| total_dist > maxT) \n       {\n            norm = getNormal(uv, ro + rd * total_dist, cubesize);\n            color +=  getShadeColor(uv, ro + rd * total_dist, norm, ro, rd, cubesize);\n            return total_dist; \n       }\n    }\n    norm = getNormal(uv, ro + rd * total_dist, cubesize);\n    color += getShadeColor(uv, ro + rd * total_dist,  norm, ro, rd, cubesize);\n        \n    return total_dist; \n}\n\n\nvoid xn()\n{\n    // Get FFT values from texture\n    for (int i = 0; i < afFrequencies.length(); i++)\n    {\n        afFrequencies[i] = texture( iChannel0, vec2(float(i)/float(afFrequencies.length()), 0.0) ).x;\n    }\n}\n\n\n\nmat2 rot(float a)\n\n{\n    float c=cos(a),s=sin(a);\n    return mat2(c,-s,s,c);\n}\n\nfloat map(vec3 p)\n{\n    float dist = 100.;\n\n    float t = iTime;\n    float a = 1.;\n     float inc = 1./8.;\n    float x= 0.01;\n    for (float i = 0.; i < 8.; ++i)\n    {\n        float ff = 2.*texture(iChannel0, vec2(x,0.25)).r;\n        x += inc;\n        vec3 e = vec3(.2-.2*ff*sin(i+iTime),.0,0);\n        p.xz = abs(p.xz)-.5*a;\n        p.xz *= rot(t*a);\n        p.yz *= rot(t*a);\n        p = p - clamp(p, -e, e);\n        dist = min(dist, length(p)-.01);\n        a /= 1.8;\n    }\n\n    return dist;\n}\n\nvec3 getResult(vec2 fragCoord, vec3 pos, vec3 ray)\n{\n    vec2 uv = (fragCoord-iResolution.xy/2.)/iResolution.y;\n    vec3 color = vec3(0); \n    \n    float dist = 100.;\n    float total = 0.;\n    float shade = 1.;\n\n    for (shade = 1.; shade > 0.; shade -= 1./60.)\n    {\n        dist = map(pos);\n        if (dist < .001) break;\n        pos += ray * dist;\n        total += dist;\n        if (total > 10.) return color;\n    }\n    if (total < 10. && shade > .01)\n    {\n        vec2 e = vec2(.001,0);\n        vec3 normal = normalize(dist-vec3(map(pos+e.xyy),map(pos+e.yxy),map(pos+e.yyx)));\n        vec3 tint = 0.5 + 0.5 * cos(vec3(1,2,3)+length(pos)*2.+iTime);\n        float light = dot(reflect(ray, normal), normalize(vec3(0,1,-1)));\n        color = tint*shade+pow(max(light,0.), 4.);\n    }\n    return color;\n}\n\nvec3 aces_approx(vec3 v) {\n  v = max(v, 0.0);\n  v *= 0.6;\n  float a = 2.51;\n  float b = 0.03;\n  float c = 2.43;\n  float d = 0.59;\n  float e = 0.14;\n  return clamp((v*(a*v+b))/(v*(c*v+d)+e), 0.0, 1.0);\n}\n  \nfloat Random(float x)\n{\n\treturn fract(sin(x * 123.456) * 23.4567 + sin(x * 345.678) * 45.6789 + sin(x * 456.789) * 56.789);\n}\n\nvec3 GetParticleColour( const in vec3 vParticlePos, const in float fParticleSize, const in vec3 vRayDir )\n{\t\t\n\tvec2 vNormDir = normalize(vRayDir.xy);\n\tfloat d1 = dot(vParticlePos.xy, vNormDir.xy) / length(vRayDir.xy);\n\tvec3 vClosest2d = vRayDir * d1;\n\t\n\tvec3 vClampedPos = vParticlePos;\n\t\n\tvClampedPos.z = clamp(vClosest2d.z, vParticlePos.z - fParticleLength, vParticlePos.z + fParticleLength);\n\t\n\tfloat d = dot(vClampedPos, vRayDir);\n\t\n\tvec3 vClosestPos = vRayDir * d;\n\t\n\tvec3 vDeltaPos = gDeltaPos = vClampedPos - vClosestPos;\t\n\n\tfloat fClosestDist = length(vDeltaPos) / fParticleSize;\n\t\n\tfloat fShade = \tclamp(1.0 - fClosestDist, 0.0, 1.0);\n\t\t\n\tfShade = fShade * exp2(-d * fDepthFade) * fBrightness;\n\t\n\treturn vec3(fShade);\n}\n\nvec3 GetParticlePos( const in vec3 vRayDir, const in float fZPos, const in float fSeed )\n{\n\tfloat fAngle = atan(vRayDir.x, vRayDir.y);\n\tfloat fAngleFraction = fract(fAngle / (3.14 * 2.0));\n\t\n\tfloat fSegment = floor(fAngleFraction * fSteps + fSeed) + 0.5 - fSeed;\n\tfloat fParticleAngle = fSegment / fSteps * (3.14 * 2.0);\n\n\tfloat fSegmentPos = fSegment / fSteps;\n\tfloat fRadius = fMinDist + Random(fSegmentPos + fSeed) * (fMaxDist - fMinDist);\n\t\n\tfloat tunnelZ = vRayDir.z / length(vRayDir.xy / fRadius);\n\t\n\ttunnelZ += fZPos;\n\t\n\tfloat fRepeat = fRepeatMin + Random(fSegmentPos + 0.1 + fSeed) * (fRepeatMax - fRepeatMin);\n\t\n\tfloat fParticleZ = (ceil(tunnelZ / fRepeat) - 0.5) * fRepeat - fZPos;\n\t\n\treturn vec3( sin(fParticleAngle) * fRadius, cos(fParticleAngle) * fRadius, fParticleZ );\n}\n\nvec3 Starfield( const in vec3 vRayDir, const in float fZPos, const in float fSeed )\n{\t\n\tvec3 vParticlePos = GetParticlePos(vRayDir, fZPos, fSeed);\n\t\n\treturn GetParticleColour(vParticlePos, fParticleSize, vRayDir);\t\n}\n\nvec3 RotateX( const in vec3 vPos, const in float fAngle )\n{\n    float s = sin(fAngle);\n    float c = cos(fAngle);\n    \n    vec3 vResult = vec3( vPos.x, c * vPos.y + s * vPos.z, -s * vPos.y + c * vPos.z);\n    \n    return vResult;\n}\n\nvec3 RotateY( const in vec3 vPos, const in float fAngle )\n{\n    float s = sin(fAngle);\n    float c = cos(fAngle);\n    \n    vec3 vResult = vec3( c * vPos.x + s * vPos.z, vPos.y, -s * vPos.x + c * vPos.z);\n    \n    return vResult;\n}\n\nvec3 RotateZ( const in vec3 vPos, const in float fAngle )\n{\n    float s = sin(fAngle);\n    float c = cos(fAngle);\n    \n    vec3 vResult = vec3( c * vPos.x + s * vPos.y, -s * vPos.x + c * vPos.y, vPos.z);\n    \n    return vResult;\n}\n\nvoid rotateAxis(inout vec2 p, float a)\n{\n\tp = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\n\nvec3 calcCameraRayDir(float fov, vec2 fragCoord, vec2 resolution)\n{\n\tfloat tanFov = tan(fov / 2.0 * PI / 180.0) / resolution.x;\n\tvec2 p = tanFov * (fragCoord * 2.0 - resolution.xy);\n\tvec3 rayDir = normalize(vec3(p.x, p.y, 1.0));\n\trotateAxis(rayDir.yz, iCamRotX);\n\trotateAxis(rayDir.xz, iCamRotY);\n\trotateAxis(rayDir.xy, iCamRotZ);\n\treturn rayDir;\n}\n\nvoid populateSoundArray()\n{\n    for (int i = 0; i < afFrequencies.length(); i++)\n    {\n        afFrequencies[i] = texture( iChannel0, vec2(float(i)/float(afFrequencies.length()), 0.0) ).x;\n    }\n}\nvec3 ACES(vec3 x){\n    float a = 2.5;\n    float b = 0.03;\n    float c = 2.4;\n    float d = 0.6;\n    float e = 0.14;\n    return clamp((x*(a*x+b))/(x*(c*x+d)+e), 0.0, 1.0);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-iResolution.xy/2.)/iResolution.y*5.;\n    populateSoundArray();\n    \n    mouse = iMouse.xy/iResolution.xy;\n    float time  = -.2 * iTime*2.;\n    float amp = 2.*PI;\n    float scl = amp*1.;\n    float offs = -3.;\n    vec3 camP = vec3((amp+offs)*sin(time)+scl*(offs+2.+mouse.x)*cos(time), scl/2.-scl*mouse.y , (amp+offs)*cos(time) - scl*(offs+2.+mouse.x)*sin(time));\n   \n\tmouse.x *= 20.;\n    mouse.y *= 20.;\n   \n\t//\tAlways look at center\n\tvec3 target = vec3(0);\n\tmat3 cameraMatrix = setCamera( camP, target, 0.0 );\n\tvec2 p = (-iResolution.xy + 2.*gl_FragCoord.xy)/iResolution.y;\n   \n\tvec3 camDir = cameraMatrix * normalize( vec3(p.xy, 2.0) );\n    \n    //\tSet up ray\n\tvec3 point=vec3(0);\t\t// Set in trace()\n\n    fragColor = vec4(0);\n    \n\t//\tInitialize color\n\tvec4 color = vec4(0);\n    float count = float(NUM);\n    vec4 col = vec4(0);\n    bool hit = false;\n  \n  \n    fragColor = vec4(0);\n    float t = 0.0;\n    float glow = 0.0;\n    vec3 norm = getNormal(uv, point, CUBESIZE );\n    t = raymarch(uv, camP, camDir, CUBESIZE, col, glow);\n\n    if (t < maxT)\n    {\n       hit = true;\n       color = 2. * col * glow;\n    }\n    \n    color.rgb += max(luma(color.rgb) - 1.0, 0.0);\n    color.rgb = ACES(color.rgb);\n   \n   color.rgb += max(luma(color.rgb) - 1.1, 0.0);\n  // color.rgb = ACES(color.rgb);\n    if (fragCoord.x <= 2. && fragCoord.y <= 2.)\n        fragColor = vec4(camDir,time);\n    else \n        fragColor = vec4(color.rgb ,1.); \n  \n  }\n\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// Cosmic Serpent 3D visualizer by Orblivius\n\n// Demonstratates how to inexpensively \n// produce glow effect by superimposing 2D and 3D computations\n\n// Hint: Use mouse to control the angle at the serpent\n// To do: fix palette skewing bug (to retain solid rainbow gradient)\n\n//   GIT: https://github.com/mewza/\n// Email: orblivius@protonmail.com\n\n//Sources used: https://shadertoy.com/view/wlfcR2\n//              https://shadertoy.com/view/XdjyRm\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = vec2(fragCoord.xy / (iResolution.xy / 2.0));\n    vec2 halfpixel = 0.5 / (iResolution.xy / 2.0);\n    float offset = 5.0;\n\n    vec4 sum = texture(iChannel0, uv) * 4.0;\n    sum += texture(iChannel0, uv - halfpixel.xy * offset);\n    sum += texture(iChannel0, uv + halfpixel.xy * offset);\n    sum += texture(iChannel0, uv + vec2(halfpixel.x, -halfpixel.y) * offset);\n    sum += texture(iChannel0, uv - vec2(halfpixel.x, -halfpixel.y) * offset);\n\n    fragColor = sum / 8.0;\n}\n","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"// Cosmic Serpent 3D visualizer by Orblivius\n\n// Demonstratates how to inexpensively \n// produce glow effect by superimposing 2D and 3D computations\n\n// Hint: Use mouse to control the angle at the serpent\n// To do: fix palette skewing bug (to retain solid rainbow gradient)\n\n//   GIT: https://github.com/mewza/\n// Email: orblivius@protonmail.com\n\n//Sources used: https://shadertoy.com/view/wlfcR2\n//              https://shadertoy.com/view/XdjyRm\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = vec2(fragCoord.xy / (iResolution.xy * 2.0));\n    vec2 halfpixel = 0.5 / (iResolution.xy * 2.0);\n    float offset = 5.0;\n\n    vec4 sum = texture(iChannel0, uv +vec2(-halfpixel.x * 2.0, 0.0) * offset);\n    \n    sum += texture(iChannel0, uv + vec2(-halfpixel.x, halfpixel.y) * offset) * 2.0;\n    sum += texture(iChannel0, uv + vec2(0.0, halfpixel.y * 2.0) * offset);\n    sum += texture(iChannel0, uv + vec2(halfpixel.x, halfpixel.y) * offset) * 2.0;\n    sum += texture(iChannel0, uv + vec2(halfpixel.x * 2.0, 0.0) * offset);\n    sum += texture(iChannel0, uv + vec2(halfpixel.x, -halfpixel.y) * offset) * 2.0;\n    sum += texture(iChannel0, uv + vec2(0.0, -halfpixel.y * 2.0) * offset);\n    sum += texture(iChannel0, uv + vec2(-halfpixel.x, -halfpixel.y) * offset) * 2.0;\n\n    fragColor = sum / 12.0;\n}","name":"Buffer C","description":"","type":"buffer"},{"inputs":[],"outputs":[{"id":"XdfGR8","channel":0}],"code":"// Cosmic Serpent 3D visualizer by Orblivius\n\n// Demonstratates how to inexpensively \n// produce glow effect by superimposing 2D and 3D computations\n\n// Hint: Use mouse to control the angle at the serpent\n// To do: fix palette skewing bug (to retain solid rainbow gradient)\n\n//   GIT: https://github.com/mewza/\n// Email: orblivius@protonmail.com\n\n//Sources used: https://shadertoy.com/view/wlfcR2\n//              https://shadertoy.com/view/XdjyRm\n\n#define PASS_COUNT 2\n#define ORANGE  (1.+cos(vScreenUV.y*12.+.7 + vec3(0,1,2)))\n\nfloat fParticleSize = 0.015;\nfloat fParticleLength = 0.9 / 60.0;\nfloat fBrightness = 2.5;\n\n\n// Number of angular segments\nfloat fSteps = 121.0;\n\n// Min and Max star position radius. Min must be present to prevent stars too near camera\nfloat fMinDist = 0.8;\nfloat fMaxDist = 5.0;\n\nfloat fRepeatMin = 1.0;\nfloat fRepeatMax = 2.0;\n\n// fog density\nfloat fDepthFade = 0.9;\n\n float iCamRotX = 0.;\n float iCamRotY = 0.;\n float iCamRotZ = 0.;\n\nvec3 gDeltaPos = vec3(0);\n\n\n\nfloat Random(float x)\n{\n\treturn fract(sin(x * 123.456) * 23.4567 + sin(x * 345.678) * 45.6789 + sin(x * 456.789) * 56.789);\n}\n\nvec3 GetParticleColour( const in vec3 vParticlePos, const in float fParticleSize, const in vec3 vRayDir )\n{\t\t\n\tvec2 vNormDir = normalize(vRayDir.xy);\n\tfloat d1 = dot(vParticlePos.xy, vNormDir.xy) / length(vRayDir.xy);\n\tvec3 vClosest2d = vRayDir * d1;\n\t\n\tvec3 vClampedPos = vParticlePos;\n\t\n\tvClampedPos.z = clamp(vClosest2d.z, vParticlePos.z - fParticleLength, vParticlePos.z + fParticleLength);\n\t\n\tfloat d = dot(vClampedPos, vRayDir);\n\t\n\tvec3 vClosestPos = vRayDir * d;\n\t\n\tvec3 vDeltaPos = vClampedPos - vClosestPos;\t\n\n\tfloat fClosestDist = length(vDeltaPos) / fParticleSize;\n\t\n\tfloat fShade = \tclamp(1.0 - fClosestDist, 0.0, 1.0);\n\t\t\n\tfShade = fShade * exp2(-d * fDepthFade) * fBrightness;\n\t\n\treturn vec3(fShade);\n}\n\nvec3 GetParticlePos( in vec3 vRayDir, const in float fZPos, const in float fSeed )\n{\n  \n\tfloat fAngle = atan(vRayDir.x, vRayDir.y);\n\tfloat fAngleFraction = fract(fAngle / (3.14 * 2.0));\n\t\n\tfloat fSegment =  floor(fAngleFraction * fSteps + fSeed) + 0.5 - fSeed;\n\tfloat fParticleAngle = fSegment / fSteps * (3.14 * 2.0);\n\n\tfloat fSegmentPos = fSegment / fSteps;\n\tfloat fRadius = fMinDist + Random(fSegmentPos + fSeed) * (fMaxDist - fMinDist);\n\t\n\tfloat tunnelZ = vRayDir.z / length(vRayDir.xy / fRadius);\n\t\n\ttunnelZ += fZPos;\n\t\n\tfloat fRepeat = fRepeatMin + Random(fSegmentPos + 0.1 + fSeed) * (fRepeatMax - fRepeatMin);\n\t\n\tfloat fParticleZ = (ceil(tunnelZ / fRepeat) - 0.5) * fRepeat - fZPos;\n\t\n\treturn vec3( sin(fParticleAngle) * fRadius, cos(fParticleAngle) * fRadius, fParticleZ );\n}\n\nvec3 Starfield( const in vec3 vRayDir, const in float fZPos, const in float fSeed )\n{\t\n\tvec3 vParticlePos = GetParticlePos(vRayDir, fZPos, fSeed);\n\t\n\treturn GetParticleColour(vParticlePos, fParticleSize, vRayDir);\t\n}\n\nvec3 RotateX( const in vec3 vPos, const in float fAngle )\n{\n    float s = sin(fAngle);\n    float c = cos(fAngle);\n    \n    vec3 vResult = vec3( vPos.x, c * vPos.y + s * vPos.z, -s * vPos.y + c * vPos.z);\n    \n    return vResult;\n}\n\nvec3 RotateY( const in vec3 vPos, const in float fAngle )\n{\n    float s = sin(fAngle);\n    float c = cos(fAngle);\n    \n    vec3 vResult = vec3( c * vPos.x + s * vPos.z, vPos.y, -s * vPos.x + c * vPos.z);\n    \n    return vResult;\n}\n\nvec3 RotateZ( const in vec3 vPos, const in float fAngle )\n{\n    float s = sin(fAngle);\n    float c = cos(fAngle);\n    \n    vec3 vResult = vec3( c * vPos.x + s * vPos.y, -s * vPos.x + c * vPos.y, vPos.z);\n    \n    return vResult;\n}\n\nvoid rotateAxis(inout vec2 p, float a)\n{\n\tp = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\n\nvec3 calcCameraRayDir(float fov, vec2 fragCoord, vec2 resolution)\n{\n\tfloat tanFov = tan(fov / 2.0 * PI / 180.0) / resolution.x;\n\tvec2 p = tanFov * (fragCoord * 2.0 - resolution.xy);\n\tvec3 rayDir = normalize(vec3(p.x, p.y, 1.0));\n\trotateAxis(rayDir.yz, iCamRotX);\n\trotateAxis(rayDir.xz, iCamRotY);\n\trotateAxis(rayDir.xy, iCamRotZ);\n\treturn rayDir;\n}\n// Change this to change repetition interval\n\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n\treturn mat3( cu, cv, cw );\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-iResolution.xy/2.)/iResolution.y*5.;\n  \n    // Fill arrays for sound things\n    \n   \n\t//\tSet up Camera\n    vec2 mouse = 1.-iMouse.xy/iResolution.xy;\n    if (iMouse.z < 0.0 && iMouse.w < 0.0)\n    {\n      // mouse.xy = -iMouse.zw;\n        //_iMouse.xy = tex.xy;\n    }\n    \n\n    vec2 vScreenUV = fragCoord.xy / iResolution.xy;\n\n\tvec2 vScreenPos = vScreenUV * 2.0 - 1.0;\n\tvScreenPos.x *= iResolution.x / iResolution.y;\n\n\tvec3 vRayDir = normalize(vec3(vScreenPos, 1.0));\n\n\tvec3 vEuler = vec3(0.5 + sin(iTime * 0.2) * 0.125, 0.5 + sin(iTime * 0.1) * 0.125, iTime * 0.1 + sin(iTime * 0.3) * 0.5);\n\t\t\t\n\t//if(iMouse.z > 0.0)\n\t{\n\t\tvEuler.x = ((iMouse.y / iResolution.y) * 2.0 - 1.0);\n\t\tvEuler.y = ((iMouse.x / iResolution.x) * 2.0 - 1.0);\n\t\tvEuler.z = 0.0;\n\t}\n\t\t\n\tvRayDir = RotateX(vRayDir, vEuler.x);\n\tvRayDir = RotateY(vRayDir, vEuler.y);\n\tvRayDir = RotateZ(vRayDir, vEuler.z);\n\t\n\tfloat fShade = 0.0;\n\t\t\n\tfloat a = 0.2;\n\tfloat b = 10.0;\n\tfloat c = 1.0; \n\tfloat fZPos =  5.0 + iTime * c + 2.*sin(iTime * a) * b;\n\tfloat fSpeed = c + a * b * cos(a * iTime);\n\t\n\tfParticleLength = 0.25 * fSpeed / 60.0;\n\t\n\tfloat fSeed = 0.0;\n\tvec3 vResult = mix(vec3(0.005, 0.0, 0.01), vec3(0.01, 0.005, 0.0), vRayDir.y * 0.5 + 0.5);\n\t\n\tfor(int i=0; i<PASS_COUNT; i++)\n\t{\n\t\tvResult += Starfield(vRayDir, fZPos, fSeed);\n\t\tfSeed += 2.234;\n\t}\n   // vResult += ORANGE * printTime(vScreenPos+vec2(-.5,-.9), fSpeed, 2);\n     \n   if (fragCoord.x <= 2. && fragCoord.y <= 2.)\n       fragColor = vec4(vResult,fSpeed);\n   else \n     fragColor = vec4(vResult, 1.);\n        \n  // fragColor = vec4(color.rgb + vResult.rgb,1.); //vec4(color.rgb,  clamp((t-6.0)/15.0, 0., 1.));\n   //+ (1.-hitP)*vResult, clamp((t-6.0)/15.0, 0.0, 1.0));\n    // fragColor.rgb = mix(fragColor.rgb*((objectHit?0.:1.)), colo*colo,.5);\n  }\n  \n  \n","name":"Buffer D","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"// Cosmic Serpent 3D visualizer by Orblivius\n\n// Demonstratates how to inexpensively \n// produce glow effect by superimposing 2D and 3D computations\n\n// Hint: Use mouse to control the angle at the serpent\n// To do: fix palette skewing bug (to retain solid rainbow gradient)\n\n//   GIT: https://github.com/mewza/\n// Email: orblivius@protonmail.com\n\n//Sources used: https://shadertoy.com/view/wlfcR2\n//              https://shadertoy.com/view/XdjyRm\n\n\n/*** Settings ***/\n\n#define FONT_TEXTURE iChannel3 // Set to the iChannel containing the alphabet texture\n\n#define SPACING 1.          // Horizontal character spacing [1 - 2.5]\n\n#define SCALE  2.\n\n#define PI 3.14159265\n#define NUM 160\n#define ITER 100\n\n/* ### How to use this shader ? ###\n   \n   === Setup ===\n   \n   0. Copy the content of the \"Common\" tab inside your shader\n   1. Make sure the FONT_TEXTURE #define is set to the iChannel \n      containing the alphabet texture\n   \n   === Declare String ===\n   \n   2. Use makeStr to declare a new string (needs to be done outside any function)\n   3. Write your text using _ before each char, and __ for spaces\n   4. Finish your string with the _end keyword\n   \n       makeStr(printExample) _A _n _o _t _h _e _r __ _E _x _a _m _p _l _e    _end\n          \n   === Print String ===\n   \n   5. Call the new function by passing it your uvs. It returns a grayscale value.\n   \n       finalCol += printExample(uv);\n   \n   - Note that you are responsible for scaling/offsetting the uvs \n     to control the text placement before calling the function.\n   \n   - If you want to print float or integer variables, see below.\n   \n   \n   ###### Printing variables ######\n   \n   In order to print int & float variables, you can call two other functions instead of makeStr:\n   \n     - makeStrI (for integers) & makeStrF (for floats).\n     \n   [ IMPORTANT ]: When using makeStrI or makeStrF, you MUST use _endNum instead of _end \n                  to terminate a string.\n                  \n                  If you're seeing many errors when trying to compile, it's probably\n                  because you're using the wrong terminator for the current string type (_end/_endNum)\n   \n   === Declare Strings ===\n   \n   - In both cases, the variable will be displayed at the position of the _num_ keyword:\n   \n       makeStrI(print_my_int)   _M _y __ _I _n _t _e _g _e _r       _num_            _endNum\n       makeStrF(print_my_float) _F _l _o _a _t  _num_  _A _d _d _i _t _i _o _n _a _l _endNum\n   \n    - print_my_int   will be (vec2 uv, int num)\n    - print_my_float will be (vec2 uv, float num, int number_of_decimals)\n      \n   === Print Strings ===\n\n       print_my_int(uv, 42);          // will print \"My Integer 42\"\n       print_my_float(uv, 42.123, 2); // will print \"Float 42.12 Additional\"\n       \n    - A limitation of this version compared to the previous one is that you can only display\n      one variable per string definition (so only one _num_ keyword is allowed per string).\n   \n   === Debug variables without makeStr ===\n  \n   A handy thing you can do in your Image tab is to create \n   the following debugInt & debugFloat helpers:\n  \n       makeStrF(debugFloat) _num_ _endNum\n       makeStrI(debugInt) _num_ _endNum\n       \n   Defining these two helpers allow to quickly debug int/float variables, \n   without the need to create a full string definition every time using makeStr().\n \n      color += debugInt(uv, 42);\n      color += debugFloat(uv, 3.14, 2);\n \n \n   ### Characters available ###\n   \n   uppercase: _A _B _C ...\n   lowercase: _a _b _c ...\n   digits   : _0 _1 _2 ...\n   special  : _ADD _SUB _DOT ... (see \"Special Characters\" below)\n   \n   \n   ### Javascript string generator helper ###\n    \n    Even if this framework allow for easier string editing, it can still be a bit tedious to create\n    long strings with special characters, so I've also made a javascript function that you can run\n    in your developer console to easily create strings:\n\n    function createString(str) {\n        const special_chars = {\n            \" \": \"_\", \"!\": \"EX\", \"\\\"\":\"DBQ\", \"#\": \"NUM\", \"$\": \"DOL\", \"%\": \"PER\",  \"&\": \"AMP\", \n            \"\\'\":\"QT\", \"(\": \"LPR\", \")\": \"RPR\", \"*\": \"MUL\", \"+\": \"ADD\", \",\": \"COM\", \"-\": \"SUB\", \n            \".\": \"DOT\", \"/\": \"DIV\", \":\": \"COL\", \";\": \"SEM\", \"<\": \"LES\", \"=\": \"EQ\", \">\": \"GE\", \n            \"?\": \"QUE\", \"@\": \"AT\", \"[\": \"LBR\", \"\\\\\": \"ANTI\", \"]\": \"RBR\",  \"_\": \"UN\", \n        };\n        const num = str.indexOf('_num_');\n        const end = num == -1 ? ' _end' : ' _endNum';\n        str = str.replace('_num_', '').split('').map(e =>  '_' + (special_chars[e] || e));\n        if (num != -1) str = str.slice(0, num).concat( '_num_', str.slice(num));\n        return str.join(' ') + end;\n    }\n\n    Usage (static): \n        > createString(\"Hello World!\") \n        '_H _e _l _l _o __ _W _o _r _l _d _EX _end'\n           \n    Usage (variable): \n        > createString(\"My Number is _num_!\")\n        '_M _y __ _N _u _m _b _e _r __ _i _s __ _num_ _EX _endNum'\n*/\n\n// Special characters\n#define __    32,\n#define _EX   33, // \" ! \"\n#define _DBQ  34, // \" \" \"\n#define _NUM  35, // \" # \"\n#define _DOL  36, // \" $ \"\n#define _PER  37, // \" % \"\n#define _AMP  38, // \" & \"\n#define _QT   39, // \" ' \"\n#define _LPR  40, // \" ( \"\n#define _RPR  41, // \" ) \"\n#define _MUL  42, // \" * \"\n#define _ADD  43, // \" + \"\n#define _COM  44, // \" , \"\n#define _SUB  45, // \" - \"\n#define _DOT  46, // \" . \"\n#define _DIV  47, // \" / \"\n#define _COL  58, // \" : \"\n#define _SEM  59, // \" ; \"\n#define _LES  60, // \" < \"\n#define _EQ   61, // \" = \"\n#define _GE   62, // \" > \"\n#define _QUE  63, // \" ? \"\n#define _AT   64, // \" @ \"\n#define _LBR  91, // \" [ \"\n#define _ANTI 92, // \" \\ \"\n#define _RBR  93, // \" ] \"\n#define _UN   95, // \" _ \"\n\n// Digits\n#define _0 48,\n#define _1 49,\n#define _2 50,\n#define _3 51,\n#define _4 52,\n#define _5 53,\n#define _6 54,\n#define _7 55,\n#define _8 56,\n#define _9 57,\n// Uppercase\n#define _A 65,\n#define _B 66,\n#define _C 67,\n#define _D 68,\n#define _E 69,\n#define _F 70,\n#define _G 71,\n#define _H 72,\n#define _I 73,\n#define _J 74,\n#define _K 75,\n#define _L 76,\n#define _M 77,\n#define _N 78,\n#define _O 79,\n#define _P 80,\n#define _Q 81,\n#define _R 82,\n#define _S 83,\n#define _T 84,\n#define _U 85,\n#define _V 86,\n#define _W 87,\n#define _X 88,\n#define _Y 89,\n#define _Z 90,\n// Lowercase\n#define _a 97,\n#define _b 98,\n#define _c 99,\n#define _d 100,\n#define _e 101,\n#define _f 102,\n#define _g 103,\n#define _h 104,\n#define _i 105,\n#define _j 106,\n#define _k 107,\n#define _l 108,\n#define _m 109,\n#define _n 110,\n#define _o 111,\n#define _p 112,\n#define _q 113,\n#define _r 114,\n#define _s 115,\n#define _t 116,\n#define _u 117,\n#define _v 118,\n#define _w 119,\n#define _x 120,\n#define _y 121,\n#define _z 122,\n\n// ======  utils  ======\n\n#define print_char(i) \\\n    texture(FONT_TEXTURE, u + vec2(float(i)-float(x)/SPACING + SPACING/8., 15-(i)/16) / 16.).r\n\n// ======  makeStr()  ======\n\n// Function start\n#define makeStr(func_name)                               \\\n    float func_name(vec2 u) {                            \\\n        if (u.x < 0. || abs(u.y - .03) > .03) return 0.; \\\n        const int[] str = int[](                         \\\n\n// Function end\n#define _end  0);                                        \\\n    int x = int(u.x * 16. * SPACING);                    \\\n    if (x >= str.length()-1) return 0.;                  \\\n    return print_char(str[x]);                           \\\n}\n\n\n// -------------------------------------------------------------------\n//    If you only plan to display static characters (no variables) \n//    you don't need to include anything below this disclaimer\n// -------------------------------------------------------------------\n\n// ======  makeStrFloat() & makeStrInt() ======\n\n#define log10(x) int(ceil(.4342944819 * log(x + x*1e-5)))\n#define _num_ 0); const int[] str2 = int[]( \n\n// makeStrFloat() start\n#define makeStrF(func_name)                              \\\n    float func_name(vec2 u, float num, int dec) {        \\\n        if (u.x < 0. || abs(u.y - .03) > .03) return 0.; \\\n        const int[] str1 = int[](\n\n// makeStrInt() start\n#define makeStrI(func_name)                              \\\n    float func_name(vec2 u, int num_i) {                 \\\n        if (u.x < 0. || abs(u.y - .03) > .03) return 0.; \\\n        float num = float(num_i);                        \\\n        const int dec = -1;                              \\\n        const int[] str1 = int[](\n\n// makeStrFloat & makeStrInt end\n#define _endNum  0);                            \\\n    const int l1 = str1.length() - 1;           \\\n    int x = int(u.x * 16. * SPACING);           \\\n    if (x < l1) return print_char(str1[x]);     \\\n    int neg = 0;                                \\\n    if (num < 0.) {                             \\\n        if (x == l1) return print_char(45);     \\\n        num = abs(num);                         \\\n        neg = 1;                                \\\n    }                                           \\\n    int pre = neg + max(1, log10(num));         \\\n    int s2 = l1 + pre + dec + 1;                \\\n    if (x >= s2) {                              \\\n        if (x >= s2+str2.length()-1) return 0.; \\\n        int n2 = str2[x - s2];                  \\\n        return print_char(n2);                  \\\n    }                                           \\\n    float d = float(l1 + pre - x);              \\\n    if (d == 0.) return print_char(46);         \\\n    d = pow(10., d < 0.  ? ++d : d);            \\\n    int n = 48 + int(10.*fract(num/.999999/d)); \\\n    return print_char(n);                       \\\n}\n\n/* === Curious about how makeStrI() and makeStrF() work ? ===\n\nHere is a broken-down and commented version of the following syntax:\n\n    makeStrF(print_string_with_float) _H _e _l _l _o _num_ _W _o _r _l _d _endNum\n    \nThis will translate exactly to the following code:\n\nfloat print_string_with_float(vec2 u, float num, int decimals) \n{\n    if (u.x < 0. || abs(u.y - .03) > .03) return 0.;\n    \n    // The number (num) will be displayed between these two strings.\n    // The separation is handled by the #define \"_num_\"\n    const int[] str1 = int[]( _H _e _l _l _o  0);\n    const int[] str2 = int[]( _W _o _r _l _d  0);\n    \n    const int str1_length = str1.length() - 1;\n    \n    int x = int(u.x * 16. * SPACING);\n    \n    // Print char from 1st string (before number)\n    if (x < str1_length) {\n        int n1 = str1[x];\n        return print_char(n1);\n    }\n    \n    // Handle negative numbers\n    int is_negative = 0;\n    if (num < 0.) {        \n        // Print a minus sign\n        if (x == str1_length) return print_char(45);\n        \n        num = abs(num);\n        is_negative = 1;\n    }\n        \n    int digit_count = is_negative + max(1, log10(num)); // Number of characters before decimal point\n    int num_length  = digit_count + decimals + 1;       // Total number of characters for the number\n    int str2_start  = str1_length + num_length;\n    \n    // Print char from 2nd string (after number)\n    if (x >= str2_start) {\n        const int str2_length = str2.length() - 1;\n        int n2 = str2[x - str2_start];\n        if (x >= str2_start + str2_length) return 0.; // right bound\n        return print_char(n2);\n    }\n        \n    // Print the decmial separator (dot)\n    if (x == str1_length + digit_count) {\n        return print_char(46);\n    }\n    \n    // Get current digit\n    int digit_index = x - str1_length;\n    if (digit_index > digit_count) {\n        // Offset by 1 for digits located after the decimal point\n        digit_index--;\n    }\n    float exponent = float(digit_count - digit_index);\n    int n = 48 + int(10.*fract(num/.999999/pow(10., exponent)));\n        \n    // Print digit\n    return print_char(n);\n}\n*/","name":"Common","description":"","type":"common"}]}