{"ver":"0.1","info":{"id":"MtVcDw","date":"1536670862","viewed":254,"name":"triangle distance","username":"magician0809","description":"distance and direction of triangle","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["triangle","distance"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define DENS 16.\n#define ROT_SPEED 0.1\n\nfloat dot2(vec2 v)\n{\n    return dot(v, v);\n}\n\nfloat cross2(vec2 v0, vec2 v1)\n{\n    return v0.x * v1.y - v0.y * v1.x;\n}\n\nfloat proj01(vec2 src, vec2 dst)\n{\n    return dot(src, dst) / dot2(dst);\n}\n\nvec2 segmentDistance(vec2 dp, vec2 sd)\n{\n    float lp = proj01(dp, sd);\n    lp = clamp(lp, 0.0, 1.0);\n    return dp - lp * sd;\n}\n\nvec2 triangleDistance(vec2 p, vec2 tri[3])\n{\n    vec2 dn = segmentDistance(p - tri[0], tri[1] - tri[0]);\n    vec2 n1 = segmentDistance(p - tri[1], tri[2] - tri[1]);\n    vec2 n2 = segmentDistance(p - tri[2], tri[0] - tri[2]);\n    if (dot2(n1) < dot2(dn)) dn = n1;\n    if (dot2(n2) < dot2(dn)) dn = n2;\n    return dn;\n}\n\nbool inTriangle(vec2 p, vec2 tri[3])\n{\n    float c0 = cross2(p - tri[0], p - tri[1]);\n    float c1 = cross2(p - tri[1], p - tri[2]);\n    float c2 = cross2(p - tri[2], p - tri[0]);\n    return c0 * c1 >= 0.0 && c1 * c2 >= 0.0 && c2 * c0 >= 0.0;\n}\n\nfloat drawSegment(vec2 uv, vec2 sp, vec2 sq, float thinkness)\n{\n    vec2 pp = uv - sp;\n    vec2 pq = sq - sp;\n    float lp = proj01(pp, pq);\n    vec2 dn = pp - lp * pq;\n    float sw = dot2(dn);\n    return step(sw, thinkness * thinkness)\n         * step(0.0, lp)\n         * step(lp, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 ouv = fragCoord / iResolution.xy;\n    float aspect = iResolution.x / iResolution.y;\n    vec2 cp = vec2((aspect - 1.0) * 0.5 + 0.5, 0.5);\n    float pu = 1.0 / iResolution.y;\n    vec2 uv = fragCoord / iResolution.y;\n    vec2 ms = iMouse.xy / iResolution.y;\n    \n    //generate triangle\n    float cs = cos(iTime * ROT_SPEED);\n    float sn = sin(iTime * ROT_SPEED);\n    mat2 mr = mat2(cs,sn,-sn,cs);\n    vec2 tri[3];\n    tri[0] = mr * vec2(-0.4, 0.25) + cp;\n    tri[1] = mr * vec2(0.1, -0.4) + cp;\n    tri[2] = mr * vec2(0.1, 0.15) + cp;\n    \n    //distance per pixel\n    bool inConvex = inTriangle(uv, tri);\n    float dist = length(triangleDistance(uv, tri));\n    float fd = fract(dist * DENS);\n    vec4 col = inConvex ? vec4(0.35, 0.5, 0.65, 1.0) : vec4(0.5, 0.5, 0.5, 1.0);\n    col.r = smoothstep(col.a, 0.0, abs(fd - col.r));\n    col.g = smoothstep(col.a, 0.0, abs(fd - col.g));\n    col.b = smoothstep(col.a, 0.0, abs(fd - col.b));\n    col *= 1.0 - step(dist, pu) * 0.5;\n    \n    //distance segment\n    vec2 dn = triangleDistance(ms, tri);\n    float s = drawSegment(uv, ms, ms - dn, pu);\n    col *= 1.0 - s * 0.5;\n    \n    //vignette effect\n    col *= smoothstep(0.7, 0.1, length(vec2(0.5) - ouv));\n    \n    //final\n    fragColor = vec4(col.rgb, 1);\n}","name":"Image","description":"","type":"image"}]}