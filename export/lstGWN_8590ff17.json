{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[{"channel":0,"type":"texture","id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"}},{"channel":1,"type":"texture","id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"}},{"channel":2,"type":"texture","id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"}}],"code":"/*\n\"Page Turning\" by Emmanuel Keller aka Tambako - December 2015\nLicense Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\nContact: tamby@tambako.ch\n*/\n\nconst float pi = 3.14159;\nconst float twopi = 6.28319;\n\nconst float e0 = 0.018;\nconst float ppow = 2.0;\n\nconst float bcolorMix = 0.67;\nconst float maxBcolVal = 0.4;\n\nconst float diffint = 1.2;\nconst float ambientt = 0.1;\nconst float ambientb = 0.4;\n\nconst vec2 specpos = vec2(0.85, -0.2);\nconst float specpow = 5.;\nconst float specwidth = 0.4;\nconst float specint = 0.6;\n\nconst vec2 shadowoffset = vec2(0.07, -0.04);\nconst float shadowsmoothness = 0.012;\nconst float shadowint = 0.25;\n\nconst float aawidth = 0.7;\nconst int aasamples = 3;\n\nconst bool showpoints = false;\nconst bool colors = false;\nconst bool anim = true;\n\n//#define swap_x\n\n// Simple \"random\" function\nfloat random(float co)\n{\n    return fract(sin(co*12.989) * 43758.545);\n}\n\nvec4 getPagebackColor()\n{\n    \n    float cn;\n    if (iMouse.x==0. && iMouse.y==0. && anim)\n        cn = floor(iTime/3.5);\n    else\n        cn = 1.0;\n    vec4 pagebackColor;\n    pagebackColor.r = maxBcolVal*random(cn + 263.714);\n    pagebackColor.g = maxBcolVal*random(cn*4. - 151.894);\n    pagebackColor.b = maxBcolVal*random(cn*7. + 87.548);\n    pagebackColor.a = 1.0;\n    return pagebackColor;\n}\n\nvec2 rotateVec(vec2 vect, float angle)\n{\n    float xr = vect.x*cos(angle) + vect.y*sin(angle);\n    float yr = vect.x*sin(angle) - vect.y*cos(angle);\n    return vec2(xr, yr);\n}\n\n// Curl function on the axis bottom left corner - corner of the sheet\nfloat pageFunction(float x, float e)\n{\n    return pow(pow(x, ppow) - e, 1./ppow);\n}\n\n// Derivate of the curl function for light calculations\nfloat pageFunctionDer(float x, float e)\n{\n    return pow(x, ppow - 1.)/pow(pow(x, ppow) - e, (ppow - 1.)/ppow);\n}\n\nvec4 turnPage(vec2 fragCoord)\n{\n\t// General calculations\n    vec2 uv = fragCoord.xy / iResolution.yy;\n    float ratio = iResolution.x/iResolution.y;\n    \n    // As long as one doesn't click on the canvas, the animation runs\n    vec2 mpoint;\n    bool firstcycle;\n    \n    vec4 Mouse2 = iMouse;\n    #ifdef swap_x\n    Mouse2.x = iResolution.x - Mouse2.x;\n    #endif\n    \n    if (iMouse.x==0. && iMouse.y==0. && anim)\n    {\n        firstcycle = mod(iTime/3.5, 2.)<1.;\n        mpoint = vec2(mod(iTime/3.5, 1.)*iResolution.x*2.0, pow(mod(iTime/3.5, 1.), 2.5)*iResolution.y/1.2 + 8.*smoothstep(0., 0.07, mod(iTime/3.5, 1.)));\n    }\n    else\n    {\n        mpoint = Mouse2.xy;\n        firstcycle = true;\n    }\n    vec2 midmpoint = mpoint*0.5;\n    float mdist = distance(fragCoord, mpoint);\n    float e = e0*pow(mdist/iResolution.y, 2.) + 0.02*e0*smoothstep(0., 0.12, mdist/iResolution.y);\n    float angle = - atan(mpoint.x/mpoint.y) + pi*0.5;\n    \n    vec2 uv2 = uv;\n    #ifdef swap_x\n    uv2.x = ratio - uv2.x;\n    #endif\n    \n    vec2 uvr = rotateVec(uv2 - midmpoint/iResolution.yy, angle);\n    \n    float pagefunc = pageFunction(uvr.x, e);\n    vec2 uvr2 = vec2(pagefunc, uvr.y); \n    vec2 uvr3 = rotateVec(uvr2, -angle) - vec2(1., -1.)*midmpoint/iResolution.yy;\n    \n    vec2 uvr2b = vec2(-pagefunc, uvr.y); \n    vec2 uvr3b = rotateVec(uvr2b, -angle) - vec2(1., -1.)*midmpoint/iResolution.yy;\n    \n    #ifdef swap_x\n    uvr3b.x = ratio - uvr3b.x;\n    #endif\n        \n    vec4 i; \n    // Turned page\n    if (uvr.x>0. && uvr3b.y>0.)\n    {\n        vec2 uvcorr = vec2(ratio, 1.);\n        vec2 uvrcorr = rotateVec(uvcorr - midmpoint/iResolution.yy, angle);\n        float pagefunccorr = pageFunction(uvrcorr.x, e);\n        vec2 uvrcorr2 = vec2(-pagefunccorr, uvrcorr.y); \n        vec2 uvrcorr3 = rotateVec(uvrcorr2, -angle) - vec2(1., -1.)*midmpoint/iResolution.yy;\n    \n        float pagefuncder = pageFunctionDer(uvr.x, e);\n        float intfac = 1. - diffint*(1. - 1./pagefuncder);\n\n        if(uvr3.x>=0. || uvr3.y<=0.)\n        {\n            // Top of the turned page           \n        \tfloat mdists = distance(fragCoord, mpoint)*0.7 - 55.;\n        \tfloat es = e0*pow(mdists/iResolution.y, 2.) + 0.02*e0*smoothstep(0., 0.08, mdist/iResolution.y);\n        \tvec2 uvrs = rotateVec(uv2 - midmpoint/iResolution.yy - shadowoffset, angle);\n        \tfloat pagefuncs = pageFunction(uvrs.x + 0.015, es - 0.001);\n        \tvec2 uvr2s = vec2(pagefuncs, uvrs.y); \n        \tvec2 uvr3s = rotateVec(uvr2s, -angle) - vec2(1., -1.)*midmpoint/iResolution.yy;\n        \tfloat shadow = 1. - (1. - smoothstep(-shadowsmoothness, shadowsmoothness, uvr3s.x))*(1. - smoothstep(shadowsmoothness, -shadowsmoothness, uvr3s.y));\n            \n            float difft = intfac*(1. - ambientt) + ambientt;\n        \tdifft = difft*(shadow*shadowint + 1. - shadowint)/2. + mix(1. - shadowint, difft, shadow)/2.;\n            if (firstcycle)\n                i = difft*(colors?vec4(1., 0.3, 0.3, 1.):texture(iChannel0, mod((uvr3b - uvrcorr3)/vec2(-ratio, 1.), 1.)));\n            else\n                i = difft*(colors?vec4(1., 0.3, 0.3, 1.):texture(iChannel1, mod((uvr3b - uvrcorr3)/vec2(-ratio, 1.), 1.)));\n        }\n        else\n        {\n            // Bottom of the turned page\n            float diffb = intfac*(1. - ambientb) + ambientb;\n        \tfloat spec = pow(smoothstep(specpos.x - 0.35, specpos.x, intfac)*smoothstep(specpos.x + 0.35, specpos.x, intfac), specpow);\n        \tspec*= specint*pow(1. - pow(clamp(abs(uvr.y - specpos.y), 0., specwidth*2.), 2.)/specwidth, specpow);\n\t\t\tif (firstcycle)\n                i = diffb*(colors?vec4(0.3, 1.0, 0.3, 1.):mix(texture(iChannel0, mod((uvr3 - uvrcorr3)/vec2(-ratio, 1.), 1.)), getPagebackColor(), bcolorMix));\n            else\n                i = diffb*(colors?vec4(0.3, 1.0, 0.3, 1.):mix(texture(iChannel1, mod((uvr3 - uvrcorr3)/vec2(-ratio, 1.), 1.)), getPagebackColor(), bcolorMix));\n            //i = diffb*(colors?vec4(0.3, 1.0, 0.3, 1.):texture(iChannel1, mod((uvr3 - uvrcorr3)/vec2(-ratio, 1.), 1.)), vec4(0.3, 0., 0., 1.));\n         \ti = mix(i, vec4(1.0), spec);\n        }\n    }\n    else\n    {\n        // \"Background\" with simple shadow\n\n        vec2 mpointbg = vec2(0.2, 0.01);\n        vec2 midmpointbg = mpointbg*0.5;\n        float mdistbg = distance(fragCoord, mpointbg);\n        float ebg = e0*pow(mdistbg/iResolution.y, 2.) + 0.01*e0*smoothstep(0., 0.12, mdistbg/iResolution.y);\n        float anglebg = 0.001; //- atan(mpointbg.x/mpointbg.y) + pi*0.5;\n        vec2 uvrbg = rotateVec(uv - midmpointbg/iResolution.yy, anglebg);\n        //float pagefuncbg = mix(uvrbg.x, pageFunction(uvrbg.x, ebg), clamp(uvrbg.x*5., 0., 1.));\n        float pagefuncbg;\n        if (uvrbg.x<0.15)\n           pagefuncbg = uvrbg.x;\n        else\n           pagefuncbg = mix(uvrbg.x, pageFunction(uvrbg.x, ebg), smoothstep(mpoint.x/iResolution.x + 0.1, mpoint.x/iResolution.x, uvrbg.x));\n        \n        vec2 uvr2bbg = vec2(-pagefuncbg, uvrbg.y); \n        vec2 uvr3bbg = rotateVec(uvr2bbg, -anglebg) - vec2(1., -1.)*midmpointbg/iResolution.yy;\n        vec2 uvcorrbg = vec2(ratio, 1.);\n        vec2 uvrcorrbg = rotateVec(uvcorrbg - midmpointbg/iResolution.yy, anglebg);\n        float pagefunccorrbg = pageFunction(uvrcorrbg.x, ebg);\n        vec2 uvrcorr2bg = vec2(-pagefunccorrbg, uvrcorrbg.y); \n        vec2 uvrcorr3bg = rotateVec(uvrcorr2bg, -anglebg) - vec2(1., -1.)*midmpointbg/iResolution.yy;       \n        float pagefuncderbg = pageFunctionDer(uvrbg.x, ebg);\n        float intfacbg = 1. - diffint*(1. - 1./pagefuncderbg);\n        float difftbg = intfacbg*(1. - ambientt) + ambientt;\n        \n        if (firstcycle) \n            i = colors?difftbg*vec4(0.3, 0.3, 1., 1.):texture(iChannel1, mod((uvr3bbg - uvrcorr3bg)/vec2(-ratio, 1.), 1.));\n        else\n            i = colors?difftbg*vec4(0.3, 0.3, 1., 1.):texture(iChannel0, mod((uvr3bbg - uvrcorr3bg)/vec2(-ratio, 1.), 1.));\n        float bgshadow = 1. + shadowint*smoothstep(-0.08+shadowsmoothness*4., -0.08, uvr3b.y) - shadowint;\n        \n        if (uvr3b.y<0.)\n           i*= bgshadow;\n    }\n    return i;\n}\n \nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Antialiasing\n    vec4 vs = vec4(0.);\n    for (int j=0;j<aasamples ;j++)\n    {\n       float oy = float(j)*aawidth/max(float(aasamples-1), 1.);\n       for (int i=0;i<aasamples ;i++)\n       {\n          float ox = float(i)*aawidth/max(float(aasamples-1), 1.);\n          vs+= turnPage(fragCoord + vec2(ox, oy));\n       }\n    }\n    vec4 i = vs/vec4(aasamples*aasamples);    \n    \n    // Show the mouse points. Was only used for development\n    vec4 ocol; \n    if (showpoints)\n    {\n        float ratio = iResolution.x/iResolution.y;\n        vec2 mpoint = iMouse.xy;\n        vec2 midmpoint = iMouse.xy*0.5;\n        float mdist = distance(fragCoord, mpoint);\n        float midmdist = distance(fragCoord, midmpoint);\n        \n        ocol = mix(i, vec4(1., 0., 0., 1.), smoothstep(6., 4., mdist));\n        ocol = mix(ocol, vec4(1., 1., 0., 1.), smoothstep(6., 4., midmdist));\n    }\n    else\n        ocol = i;\n        \n    fragColor = ocol;\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"lstGWN","date":"1450049230","viewed":3456,"name":"Page turning","username":"TambakoJaguar","description":"Drag your mouse over the image and you will see how the page is turning while moving.\nThere is a pseudo-shading with diffuse, specular and shadow.\nI needed time to tweak the formulas and its values.\nPlease tell me what you think.","likes":60,"published":1,"flags":0,"usePreview":0,"tags":["test","shadow","curl","fun","pseudo3d","page","turning","images"],"hasliked":0,"parentid":"","parentname":""}}