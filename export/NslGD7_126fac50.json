{"ver":"0.1","info":{"id":"NslGD7","date":"1616105368","viewed":92,"name":"psychedelic trippy visual","username":"avartation","description":"psychedelic trippy visual ))","likes":3,"published":1,"flags":32,"usePreview":0,"tags":["psychedelictrip"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sfGRn","filepath":"/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","previewfilepath":"/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define pi 3.14159265359\n\nfloat get_angle(vec2 center, vec2 uv) {\n    vec2 dist = uv - center;\n    float alpha = acos(dist.x/length(dist));\n    alpha /= 2.*pi;\n    alpha = sign(dist.y)*alpha + (-sign(dist.y)+1.)/2.;\n    return alpha;\n}\n\nbool point_is_on_line(vec2 point, vec2 line_p1, vec2 line_p2, float line_width) {\n    float a = (line_p1.y - line_p2.y) / (line_p1.x - line_p2.x);\n    float b = line_p1.y - a * line_p1.x;    \n    return (\n        abs(point.y - point.x * a - b) < line_width &&\n        point.x >= min(line_p1.x, line_p2.x) - 0.001 &&\n        point.x <= max(line_p1.x, line_p2.x) + 0.001\n    );\n}\n\nfloat parabola(float x, float strength) {\n    return pow(x, strength);\n}\n\n\nconst vec3 eye_color = vec3(125./255., 144./255., 176./255.);\n\nconst float eye_radius = 0.065;\nconst float eye_black_radius = 0.029;\nconst float eye_brightness = 0.2;\nconst float eye_rotation_speed = 0.03;\nconst float eye_white_diameter = 0.187;\nconst float eye_white_wave = 0.2;\nconst float blink_speed = 2.;\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec4 rgba = texture(iChannel0, uv);\n    vec3 col = vec3(0.); // rgba.rgb;\n    \n    uv = fragCoord/iResolution.x;\n    vec2 center = vec2(0.5, 0.5*iResolution.y/iResolution.x);\n    \n    \n    ///////////////////////\n    //     White eye     //\n    ///////////////////////\n    \n    float limi1 = parabola(1.7*(uv.x-center.x), 1.9) + 0.21;\n    float limi2 = -parabola(1.7*(uv.x-center.x), 1.9) + 0.35;\n    \n    limi1 = mix(mix(limi1, center.y, eye_white_wave), limi1, (sin(1.5*iTime)*0.5+0.5));\n    limi2 = mix(mix(limi2, center.y, eye_white_wave), limi2, (sin(1.5*iTime)*0.5+0.5));\n    \n    float blink_ratio = step(0.,sin(0.25*blink_speed*iTime)) * step(0.,sin(0.5*blink_speed*iTime)) * (1.-(cos(blink_speed*iTime)*0.5+0.5));    \n    limi1 = mix(limi1, mix(limi1, center.y, 0.4), blink_ratio);\n    limi2 = mix(limi2, mix(limi1, center.y, 0.4), blink_ratio);\n    \n    if (uv.y > limi1 && uv.y < limi2) {\n        col = vec3(1.);\n        \n        float _eye_black_radius = eye_black_radius - (sin(iTime)*0.5+0.5) * 0.014;\n\n        float dist = length(uv - center);\n        float angle = get_angle(center, uv);\n        if (dist > eye_radius - _eye_black_radius && \n            dist < eye_radius) \n        {\n            uv = vec2(mod(uv.x + eye_rotation_speed * iTime, 1.), mod(angle + eye_rotation_speed * iTime, 1.));\n            col = 1.5 * eye_color * texture(iChannel1, uv).rgb;\n            col = (col + eye_brightness) / (1. + eye_brightness);\n        } \n        else if (dist <= eye_radius - _eye_black_radius) {\n            col = vec3(0.);\n        }\n    }\n    col = mix(col, rgba.rgb, rgba.a);\n\n    \n    ///////////////////////////\n    ///////////////////////////\n    \n    vec2 t_point1 = vec2(0.39, 0.2);\n    vec2 t_point2 = vec2(0.61, 0.2);\n    vec2 t_point3 = vec2(0.5, 0.4);\n    \n    for (float i=0.; i < 10.; ++i) {        \n        t_point1 -= center;\n        t_point2 -= center;\n        t_point3 -= center;\n\n        t_point1 *= 1.3;\n        t_point2 *= 1.3;\n        t_point3 *= 1.3;        \n        \n        t_point1 += center;\n        t_point2 += center;\n        t_point3 += center;\n        \n        if (point_is_on_line(uv, t_point1, t_point2, 0.0015)) {\n            col = mix(col, vec3(1.), rgba.a);\n        }\n        if (point_is_on_line(uv, t_point2, t_point3, 0.003)) {\n            col = mix(col, vec3(1.), rgba.a);\n        }\n        if (point_is_on_line(uv, t_point1, t_point3, 0.003)) {\n            col = mix(col, vec3(1.), rgba.a);\n        }\n    }\n    \n    fragColor = vec4(col,1.);\n}\n\n\n\n\n\n\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define pi 3.14159265359\n\nfloat get_angle(vec2 center, vec2 uv) {\n    vec2 dist = uv - center;\n    float alpha = acos(dist.x/length(dist));\n    alpha /= 2.*pi;\n    alpha = sign(dist.y)*alpha + (-sign(dist.y)+1.)/2.;\n    return alpha;\n}\n\nvec3 hsv2rgb(vec3 c) {\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n\nconst float radius = 0.12;\nconst float radius_speed = 0.4;\nconst float radius_power = 0.02;\nconst float linewidth = 0.0007;\n\nconst float wave_speed = 6.;\nconst float wave_rotation_speed = 1.3;\nconst float wave_power = 0.01;\nconst float wave_count = 8.;\n\nconst float color_speed = 0.1;\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    uv -= 0.5;\n    uv *= 0.997;\n    uv += 0.5;\n    \n    vec4 rgba = texture(iChannel0, uv);\n    vec3 col = 0.999 * rgba.rgb;\n    float alpha = rgba.a;\n\n    \n    uv = fragCoord/iResolution.x;\n    vec2 center = vec2(0.5, 0.5*iResolution.y/iResolution.x);\n    float dist = length(uv - center);    \n    \n    float angle = get_angle(center, uv);\n    float _power = acos(cos(wave_speed * iTime))/pi - 0.5;\n    _power = wave_power * sign(_power) * pow(_power, 0.8);\n    \n    float _radius = radius_power * sin(radius_speed * iTime) + (\n        radius + \n        _power *\n        sin(2.*pi * wave_count * angle + wave_rotation_speed * iTime)\n    );\n    \n    if (dist > _radius - linewidth && \n        dist < _radius + linewidth) \n    {\n        col = hsv2rgb(vec3(mod(angle + color_speed * iTime,1.),1.,1.));\n        alpha = 1.;\n    }\n    \n    fragColor = vec4(col, alpha);\n}\n\n\n\n\n\n\n\n","name":"Buffer A","description":"","type":"buffer"}]}