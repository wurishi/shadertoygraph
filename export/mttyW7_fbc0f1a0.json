{"ver":"0.1","info":{"id":"mttyW7","date":"1699315893","viewed":44,"name":"2 B buffers","username":"TwentySeven","description":"What","likes":0,"published":1,"flags":48,"usePreview":0,"tags":["glitch"],"hasliked":0,"parentid":"flSBDz","parentname":"Basic Ray Marching Sphere"},"renderpass":[{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// Flying camera code...\n// by David Hoskins\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n#define TAU 6.28318530718\n\n\nconst float KEY_W\t\t= 87.5/256.0;\nconst float KEY_A\t\t= 65.5/256.0;\nconst float KEY_S\t\t= 83.5/256.0;\nconst float KEY_D\t\t= 68.5/256.0;\nconst float KEY_LEFT  = 37.5/256.0;\nconst float KEY_UP    = 38.5/256.0;\nconst float KEY_RIGHT = 39.5/256.0;\nconst float KEY_DOWN  = 40.5/256.0;\n\nconst float KEY_SPACE\t= 32.5/256.0;\nconst float KEY_SHIFT\t= 16.5/256.0;\n\n\nvec2 clickStoreA = vec2(4.0,  0.0);\nvec2 camStore = vec2(0.0,  0.0);\nvec2 rotationStore\t= vec2(1.,  0.);\nvec2 mouseStore = vec2(2.,  0.);\nvec2 startStore\t\t= vec2(3.,  0.);\nvec2 timeStore = vec2(6.0,  0.0);\n\n\nbool isKeyPressed(float key)\n{\n\treturn texture( iChannel2, vec2(key, 0.25) ).x > .0;\n}\nfloat isInside( vec2 p, vec2 c ) { vec2 d = abs(p-0.5-c) - 0.5; return -max(d.x,d.y); }\nvec4 loadValue4( in vec2 re )\n{\n    return texture( iChannel1, (0.5+re) / iChannelResolution[1].xy, -100.0 );\n}\nvec3 loadValue3( in vec2 re )\n{\n    return texture( iChannel1, (0.5+re) / iChannelResolution[1].xy, -100.0 ).xyz;\n}\nvec2 loadValue2( in vec2 re )\n{\n    return texture( iChannel1, (0.5+re) / iChannelResolution[1].xy, -100.0 ).xy;\n}\nfloat loadValue1( in vec2 re )\n{\n    return texture( iChannel1, (0.5+re) / iChannelResolution[0].xy, -100.0 ).x;\n}\nfloat loadValueA1( in vec2 re )\n{\n    return texture( iChannel0, (0.5+re) / iChannelResolution[0].xy, -100.0 ).x;\n}\n\nvoid storeValue4( in vec2 re, in vec4 va, inout vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = ( isInside(fragCoord, re) > 0.0 ) ? va : fragColor;\n}\nvoid storeValue3( in vec2 re, in vec3 va, inout vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = ( isInside(fragCoord, re) > 0.0 ) ? vec4(va, 0.0) : fragColor;\n}\n\nvoid storeValue2( in vec2 re, in vec2 va, inout vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = ( isInside(fragCoord, re) > 0.0 ) ? vec4(va, .0, .0) : fragColor;\n}\nvoid storeValue1( in vec2 re, in float va, inout vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = ( isInside(fragCoord, re) > 0.0 ) ? vec4(va, .0, .0, .0) : fragColor;\n}\nvec2 rot2D(inout vec2 p, float a)\n{\n    return cos(a)*p - sin(a) * vec2(p.y, -p.x);\n}\n\nmat3 RotationMatrix(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat3(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c);\n}\n\nvoid mainImage( out vec4 fragColour, in vec2 fragCoord )\n{\n   \tfragColour = vec4(0);\n    \n    \n\tvec2 tempStart \t= loadValue2(startStore);\n\tfloat click \t= loadValueA1(clickStoreA);\n    float time \t\t= loadValue1(timeStore);\n    \n    vec3 camPos;\n    vec2 rot;\n    if (iFrame == 0)\n    {\n        camPos = vec3(0.5,0.5,0.5);\n        rot = vec2(.0, 0.);\n    }else\n    {\n        camPos = loadValue3(camStore);\n        rot \t\t= loadValue2(rotationStore);\n    }\n\n\n    vec4 mouse = iMouse /iResolution.xyxy;\n    \n    if (click > 0.0)\n    {\n    \ttempStart = mouse.xy;// First clicked\n    }\n    if (mouse.z > 0.0)\n    \trot += mouse.xy - tempStart;\n    \n    \n\tstoreValue2(startStore, tempStart,  fragColour, fragCoord);\n\tstoreValue2(rotationStore, rot,  fragColour, fragCoord);\n    \n    rot*= TAU;\n    mat3 mX = RotationMatrix(vec3(1.0, .0, .0), -rot.y);\n    mat3 mY = RotationMatrix(vec3(.0, 1.0, 0.0), -rot.x);\n    mX = mY * mX;\n    \n       \n    \n \n\t\n    time = iTime - time;\n    float speed = time*256.;\n    if (isKeyPressed(KEY_SPACE) || isKeyPressed(KEY_SHIFT)) speed*=2.0;\n    if (isKeyPressed(KEY_W) || isKeyPressed(KEY_UP))\n\t{\n\t\tcamPos += mX * vec3(0,0,1)* speed;\n\t}\n    if (isKeyPressed(KEY_S) || isKeyPressed(KEY_DOWN))\n\t{\n\t\tcamPos += mX * vec3(0,0,-1)* speed;\n    }\n  \tif (isKeyPressed(KEY_D) || isKeyPressed(KEY_RIGHT))\n\t{\n\t\tcamPos += mX * vec3(1,0,0)* speed;\n\t}\n\tif (isKeyPressed(KEY_A) || isKeyPressed(KEY_LEFT))\n\t{\n\t\tcamPos += mX * vec3(-1,0,0) * speed;\n\t}\n    storeValue3(camStore, camPos,  fragColour, fragCoord);\n    storeValue1(timeStore, iTime,  fragColour, fragCoord);\n            \n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n\n#define TAU 6.28318530718\n#define STORE_DE\nvec3 CSize;vec4 eStack[2];vec4 dStack[2];vec2 fcoord;vec2 camStore = vec2(0.0,  0.0);vec2 rotationStore\t= vec2(1.,  0.);vec2 mouseStore = vec2(2.,  0.);vec3 loadValue3( in vec2 re ){return texture( iChannel0, (0.5+re) / iChannelResolution[0].xy, -100.0 ).xyz;}vec2 loadValue2( in vec2 re ){return texture( iChannel0, (0.5+re) / iChannelResolution[0].xy, -100.0 ).xy;}mat3 RotationMatrix(vec3 axis, float angle){\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat3(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c);\n}\nfloat GetSceneDistance(vec3 point){\n    vec4 set1 = vec4(0, 0., 6, 1.); // (xyz, radius)\n    vec4 set2 = vec4(3, 0., 6, 1.); // (xyz, radius)\n    \n    point = vec3(mod(point.x,16.)-4.,point.y,point.z);\n    \n    float sphere_dist1 = box(point-set1.xyz,vec3(set2.w));\n    float sphere_dist2 = length(point - set2.xyz)-set2.w;\n    float plane_dist = point.y + 1.; \n    float tor = torus(point-vec3(4,4,4),vec2(2.,1.));\n    float d = min(min(sphere_dist1,sphere_dist2), min(plane_dist,tor)); \n    \n    return d; \n}\nfloat RayMarch(vec3 ray_origin, vec3 ray_dir){\n    float d = 0.; \n    for(int i = 0; i < MAX_STEPS; i++)\n    {\n        vec3 p = ray_origin + ray_dir * d;\n        float ds = GetSceneDistance(p); \n        d += ds; \n        if(d > MAX_DIST || ds < EPS) \n            break;  // hit object or out of scene\n    }\n    return d; \n}\nvec3 GetNormal(vec3 point){\n    float d = GetSceneDistance(point); \n    vec2 e = vec2(0.01, 0); \n    vec3 n = d - vec3(\n        GetSceneDistance(point - e.xyy),\n        GetSceneDistance(point - e.yxy),\n        GetSceneDistance(point - e.yyx)\n    );\n    \n    return normalize(n); \n}\nfloat GetLight(vec3 point,vec3 light_pos){    \n\n     \n    vec3 to_light = normalize(light_pos - point); \n    vec3 normal = GetNormal(point); \n    \n    float intensity = 0.6;\n    float light = intensity * clamp(dot(to_light, normal), 0., 1.); \n    \n    float d = RayMarch(point+normal*2.*EPS, to_light);\n    \n    if (d < length(light_pos - point))\n        light *= 0.6;\n    \n    return light;\n}\n\nfloat reflection(inout vec3 pos,inout vec3 dir,inout float d,inout vec3 n,inout vec3 p, inout vec3 lpos){\n    pos =pos+dir*d;\n    dir =reflect(dir,n);\n    d = RayMarch(pos+(n*0.003), dir);\n    p = (pos) + (d) * (dir);\n    n=GetNormal(p);\n\n    return GetLight(p,lpos);\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 cameraPos= (loadValue3(camStore).xyz)*vec3(1,-1,1);\n    vec2 mou = loadValue2(rotationStore);\n\n    mou*= TAU;\n    mat3 mZ = RotationMatrix(vec3(.0, .0, 1.0), 0.);\n    mat3 mX = RotationMatrix(vec3(1.0, 0.0, .0), -mou.y);\n    mat3 mY = RotationMatrix(vec3(.0, 1.0, 0.0), mou.x);\n\n    vec3 pos = cameraPos/64.;\n\n    // Normalized pixel coordinates (from -0.5 to 0.5)\n    vec2 uv = (fragCoord - .5*iResolution.xy)/iResolution.x;\n\tvec3 dir = normalize( vec3( uv, 1. ) )*mX*mY;\n    // Time varying pixel color\n\n\n    float d = RayMarch(pos, dir);\n    \n    vec3 p = pos + d * dir; \n        float h = hash(vec3(p));\n        vec3 k = (hash3(vec3(fragCoord.xy,iTime))-0.5);\n    vec3 n = GetNormal(p)+(k/25.);\n   vec3 lightpos = vec3(0,10,0)+k ;\n    float diffuse_light = GetLight(p,lightpos); \n   \n\n   \n    vec3 color = vec3(.5,.5,.5);\n\n\n\n    float bounce_light;\nfor(int i=0;i<1;i++){\nbounce_light += reflection(pos,dir,d,n,p,lightpos); \n}\n\n     vec3 col = vec3((diffuse_light*color)+(bounce_light*color/2.));\n\n    col = pow(col, vec3(0.4545)); // Gamma correction\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"vec2 clickStore\t= vec2(4.,  0.);\n\nfloat isInside( vec2 p, vec2 c ) { vec2 d = abs(p-0.5-c) - 0.5; return -max(d.x,d.y); }\n\nfloat loadValue1( in vec2 re )\n{\n    return texture( iChannel0, (0.5+re) / iChannelResolution[0].xy, -100.0 ).x;\n}\n\nvoid storeValue1( in vec2 re, float va, inout vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = ( isInside(fragCoord, re) > 0.0 ) ? vec4(va, .0, .0, .0) : fragColor;\n}\nvoid mainImage( out vec4 fragColour, in vec2 fragCoord )\n{\n\n\tfragColour = vec4(0);\n    float click = 0.0;\n    float oldClick = loadValue1(clickStore);\n    if (iFrame == 0) oldClick = 0.0;\n        \n    if (iMouse.z > 0.0)\n   \t{\n      if (oldClick == .0)\n        click = 1.0;\n    }\n  \n\tstoreValue1(clickStore, click,  fragColour, fragCoord);\n\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// Flying camera code...\n// by David Hoskins\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n#define TAU 6.28318530718\n\n\nconst float KEY_W\t\t= 87.5/256.0;\nconst float KEY_A\t\t= 65.5/256.0;\nconst float KEY_S\t\t= 83.5/256.0;\nconst float KEY_D\t\t= 68.5/256.0;\nconst float KEY_LEFT  = 37.5/256.0;\nconst float KEY_UP    = 38.5/256.0;\nconst float KEY_RIGHT = 39.5/256.0;\nconst float KEY_DOWN  = 40.5/256.0;\n\nconst float KEY_SPACE\t= 32.5/256.0;\nconst float KEY_SHIFT\t= 16.5/256.0;\n\n\nvec2 clickStoreA = vec2(4.0,  0.0);\nvec2 camStore = vec2(0.0,  0.0);\nvec2 rotationStore\t= vec2(1.,  0.);\nvec2 mouseStore = vec2(2.,  0.);\nvec2 startStore\t\t= vec2(3.,  0.);\nvec2 timeStore = vec2(6.0,  0.0);\n\n\nbool isKeyPressed(float key)\n{\n\treturn texture( iChannel2, vec2(key, 0.25) ).x > .0;\n}\nfloat isInside( vec2 p, vec2 c ) { vec2 d = abs(p-0.5-c) - 0.5; return -max(d.x,d.y); }\nvec4 loadValue4( in vec2 re )\n{\n    return texture( iChannel1, (0.5+re) / iChannelResolution[1].xy, -100.0 );\n}\nvec3 loadValue3( in vec2 re )\n{\n    return texture( iChannel1, (0.5+re) / iChannelResolution[1].xy, -100.0 ).xyz;\n}\nvec2 loadValue2( in vec2 re )\n{\n    return texture( iChannel1, (0.5+re) / iChannelResolution[1].xy, -100.0 ).xy;\n}\nfloat loadValue1( in vec2 re )\n{\n    return texture( iChannel1, (0.5+re) / iChannelResolution[0].xy, -100.0 ).x;\n}\nfloat loadValueA1( in vec2 re )\n{\n    return texture( iChannel0, (0.5+re) / iChannelResolution[0].xy, -100.0 ).x;\n}\n\nvoid storeValue4( in vec2 re, in vec4 va, inout vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = ( isInside(fragCoord, re) > 0.0 ) ? va : fragColor;\n}\nvoid storeValue3( in vec2 re, in vec3 va, inout vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = ( isInside(fragCoord, re) > 0.0 ) ? vec4(va, 0.0) : fragColor;\n}\n\nvoid storeValue2( in vec2 re, in vec2 va, inout vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = ( isInside(fragCoord, re) > 0.0 ) ? vec4(va, .0, .0) : fragColor;\n}\nvoid storeValue1( in vec2 re, in float va, inout vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = ( isInside(fragCoord, re) > 0.0 ) ? vec4(va, .0, .0, .0) : fragColor;\n}\nvec2 rot2D(inout vec2 p, float a)\n{\n    return cos(a)*p - sin(a) * vec2(p.y, -p.x);\n}\n\nmat3 RotationMatrix(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat3(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c);\n}\n\nvoid mainImage( out vec4 fragColour, in vec2 fragCoord )\n{\n   \tfragColour = vec4(0);\n    \n    \n\tvec2 tempStart \t= loadValue2(startStore);\n\tfloat click \t= loadValueA1(clickStoreA);\n    float time \t\t= loadValue1(timeStore);\n    \n    vec3 camPos;\n    vec2 rot;\n    if (iFrame == 0)\n    {\n        camPos = vec3(0.5,0.5,0.5);\n        rot = vec2(.0, 0.);\n    }else\n    {\n        camPos = loadValue3(camStore);\n        rot \t\t= loadValue2(rotationStore);\n    }\n\n\n    vec4 mouse = iMouse /iResolution.xyxy;\n    \n    if (click > 0.0)\n    {\n    \ttempStart = mouse.xy;// First clicked\n    }\n    if (mouse.z > 0.0)\n    \trot += mouse.xy - tempStart;\n    \n    \n\tstoreValue2(startStore, tempStart,  fragColour, fragCoord);\n\tstoreValue2(rotationStore, rot,  fragColour, fragCoord);\n    \n    rot*= TAU;\n    mat3 mX = RotationMatrix(vec3(1.0, .0, .0), -rot.y);\n    mat3 mY = RotationMatrix(vec3(.0, 1.0, 0.0), -rot.x);\n    mX = mY * mX;\n    \n       \n    \n \n\t\n    time = iTime - time;\n    float speed = time*256.;\n    if (isKeyPressed(KEY_SPACE) || isKeyPressed(KEY_SHIFT)) speed*=2.0;\n    if (isKeyPressed(KEY_W) || isKeyPressed(KEY_UP))\n\t{\n\t\tcamPos += mX * vec3(0,0,1)* speed;\n\t}\n    if (isKeyPressed(KEY_S) || isKeyPressed(KEY_DOWN))\n\t{\n\t\tcamPos += mX * vec3(0,0,-1)* speed;\n    }\n  \tif (isKeyPressed(KEY_D) || isKeyPressed(KEY_RIGHT))\n\t{\n\t\tcamPos += mX * vec3(1,0,0)* speed;\n\t}\n\tif (isKeyPressed(KEY_A) || isKeyPressed(KEY_LEFT))\n\t{\n\t\tcamPos += mX * vec3(-1,0,0) * speed;\n\t}\n    storeValue3(camStore, camPos,  fragColour, fragCoord);\n    storeValue1(timeStore, iTime,  fragColour, fragCoord);\n            \n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define MAX_STEPS 256\n#define MAX_DIST 100.\n#define EPS .001\nfloat hash(vec3 p3)\n{\n\tp3  = fract(p3 * .10311);\n    p3 += dot(p3, p3.zyx + 31.32);\n    return fract((p3.x + p3.y) * p3.z);\n}\nvec3 hash3(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n\n}\nfloat box( vec3 p, vec3 b ){\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\nfloat sphere(vec3 p, float r) {\n\n    //a sphere of radius 1.\n    return length(p) - r;\n}\nfloat torus( vec3 p, vec2 t ){\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}","name":"Common","description":"","type":"common"}]}