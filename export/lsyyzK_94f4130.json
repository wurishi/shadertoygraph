{"ver":"0.1","info":{"id":"lsyyzK","date":"1522593583","viewed":497,"name":"Doodling #4: Structures","username":"lsdlive","description":"Things I did before the Revision 2018 to train shader showdown (but showmatch were cancelled).\n\nVarious utilities code from iq, lj, mercury, shane, aiekick & balkhan.","likes":22,"published":1,"flags":0,"usePreview":0,"tags":["tunnel","raymarch"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// @lsdlive\n\nfloat dt =0.;\nvec2 path(float t) {\n\tfloat a = sin(t*.2 + 1.5), b = sin(t*.2);\n\treturn vec2(a*2., a*b);\n}\n\nmat2 r2d(float a) {\n\tfloat c = cos(a), s = sin(a);\n\treturn mat2(c, s, -s, c);\n}\n\nvoid amod(inout vec2 p, float m) {\n\tfloat a = mod(atan(p.x, p.y) - m*.5, m) - m*.5;\n\tp = vec2(cos(a), sin(a)) * length(p);\n}\n\nvoid mo(inout vec2 p, vec2 d) {\n\tp.y = abs(p.y) - d.x;\n\tp.x = abs(p.x) - d.y;\n\tif (p.y > p.x) p.xy = p.yx;\n}\n\nfloat sc(vec3 p, float s) {\n\tp = abs(p);\n\tp = max(p, p.yzx);\n\treturn min(p.x, min(p.y, p.z)) - s;\n}\n\nfloat od(vec3 p, float s) {\n\treturn dot((p),normalize(sign(p)))-s;\n}\n\nfloat rep(float p, float m) {\n\treturn mod(p-m*.5, m) - m*.5;\n}\n\nfloat g = 0.;\nfloat id=0.;\nfloat de(vec3 p) {\n    p.xy -= path(p.z);\n    \n   // float s1 = length(p-vec3(0, 0, 2.+dt+sin(iTime))) -.2 - sin(iTime)*.1;\n    vec3 q = p;\n    q -= vec3(0, 0, 2.+dt+sin(iTime));\n    q.xz*=r2d(iTime);\n    q.xy*=r2d(iTime);\n    float s1 = od(q, .2- sin(iTime)*.1);\n    \n    q = p;\n    q.xy*=r2d(q.z*.1);\n    amod(q.xy, 4./6.28);\n    q.x = abs(q.x) - 3.;\n    float cyl = length(q.xy) - .3;\n    \n    \n    p.xy *= r2d(iTime*.4);\n    \n    //p.y += 2.;\n    \n    //p.xy *= r2d(p.z*.4);\n    \n    \n    amod(p.xy, 12./6.28);\n    mo(p.xy, vec2(2, 2.));\n    //mo(p.zy, vec2(.04, .7));\n    \n    p.xy *= r2d(p.z*.2);\n    \n    p.z = rep(p.z, 1.);\n    \n    \n    amod(p.xy, .785);\n    \n    //p.x = abs(p.x) - 1.;\n\tmo(p.xy, vec2(.8, .4));\n    \n    float sc2 = sc(p, .5);\n    \n    p.xy *= r2d(3.14*.25);\n    \n    float d = sc(p, .3);\n    d = max(d, -sc2);\n    d = min(d, s1);\n    if(d<cyl) {\n        id = 1.;\n        //d= d;\n    }else {\n        id = 2.;\n       // d= cyl;\n    }\n\tg += .01 / (.02 + d*d);\n\treturn d;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec2 uv = fragCoord / iResolution.xy - .5;\n\tuv.x *= iResolution.x / iResolution.y;\n\n\tdt = iTime * 6.;\n\tvec3 ro = vec3(0, 0, -3. + dt);\n\tvec3 ta = vec3(0, 0, dt);\n\n\tro.xy += path(ro.z);\n\tta.xy += path(ta.z);\n\n\tvec3 fwd = normalize(ta - ro);\n\tvec3 left = cross(vec3(0, 1, 0), fwd);\n\tvec3 up = cross(fwd, left);\n\n\tvec3 rd = normalize(fwd + left*uv.x + up*uv.y);\n\n\tvec3 p;\n\tfloat ri, t = 0.;\n\tfor (float i = 0.; i < 1.; i += .01) {\n\t\tri = i;\n\t\tp = ro + rd*t;\n\t\tfloat d = de(p);\n\t\tif (d < .001) break;\n\t\tt += d*.3;\n\t}\n\tvec3 bg = vec3(.2, .1, .2);\n\tvec3 col = mix(vec3(1., .0, .0), bg, uv.x+ri);\n    /*if(id == 2.)*/ col.g += sin(p.z*.1)*.4; \n       // col = mix(vec3(.3, .1+sin(p.z)*.3, .2), bg, ri);\n\tcol += g*.03;\n\tcol = mix(col, bg, 1. - exp(-.01*t*t));\n\n\tfragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}