{"ver":"0.1","info":{"id":"fsK3RG","date":"1631737459","viewed":94,"name":"OK_Parcours_3_Exo_2","username":"AVKOR","description":"Reprendre le shader développé lors de la démo, et se l'approprier en ajoutant :\n- D'autres sphères dans la scène\n- D'autres lights\n- En colorant les différentes sphères.\n*********************\n Controls: Mouse, Keys: ArrowLeft/Right, ArrowUp/Down, +/-\n","likes":0,"published":1,"flags":48,"usePreview":0,"tags":["artline"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dX3Rn","filepath":"/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg","previewfilepath":"/media/ap/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// is_shadow_smooth = true;  35fps for samples_per_pixel = 200;\n// is_shadow_smooth = true;  60fps for samples_per_pixel = 100;\n// is_shadow_smooth = false;  60fps\n\n\n//convert uv\nvec2 convert_uv(vec2 xy)\n{\n    return (2.*xy - iResolution.xy)/iResolution.x;\n}\n\nvoid initRandomGenerator(vec2 uv){\n    seed = uint(uv.y*iResolution.x + uv.x)+uint(iFrame)*uint(iResolution.x)*uint(iResolution.y);\n}\n\nvec3 background(Ray r)\n{\n    return mix(vec3(1., 1., 1.), vec3(0.5, 0.7, 1.), 0.5*(r.direction.y + 1.));\n}\n\n// set color\nvec3 set_color(vec3 intersection_to_object, vec3 normal_to_surface, vec3 light_direction, Light light, int i0)\n{\n    // initial color\n    vec3 color = vec3(0.);\n\n    // ambiance\n    color += objects[i0].ambient * light.ambient;\n\n    // find if light is not hiden by the rest\n    float min_distance = MAX_DISTANCE;\n    int i = find_closest(Ray(intersection_to_object, light_direction), min_distance, i0);\n    if (i >= 0 && i != i0) return color;\n\n    // diffuse\n    float diffusion = clamp(dot(light_direction, normal_to_surface), 0., 1.);\n    if (objects[i].type == TEXSPHERE)\n    {\n        objects[i].color = texture(iChannel0, \n            vec2(0.5 - 0.5 * atan(normal_to_surface.z, normal_to_surface.x) / M_PI,\n                -acos(normal_to_surface.y) / M_PI)).xyz;\n    }\n\n    // specular\n    vec3 intersection_to_camera = normalize(camera.look_from - intersection_to_object);\n    float specular = pow(clamp(dot(normal_to_surface, normalize(light_direction + intersection_to_camera)), 0., 1.), objects[i].shininess);\n    \n    return color + diffusion * objects[i].color * light.color + specular * objects[i].specular * light.specular;\n}\nvec3 ray_color(Ray ray)\n{\n    vec3 intersection_to_object, normal_to_surface, light_position, v1, v2;\n\n    // initial color\n    vec3 color = vec3(0.);\n\n    float min_distance;\n    int i;\n    \n    reflecnance = 1.;\n\n    // main loop\n    for (int depth = 0; depth < MAX_DEPTH; depth++)\n    {\n        // find closest object\n        min_distance = MAX_DISTANCE;\n        if ((i = find_closest(ray, min_distance, -1)) < 0)\n        {\n            if(depth == 0)\n            {\n                // background\n                color = background(ray);\n            }\n            break;\n        }\n\n        intersection_to_object = param_ray(ray, min_distance);\n        normal_to_surface = normal(intersection_to_object, i);\n\n        // apply color and light\n        for (int l = 0; l < lights.length(); l++)\n        {\n            // for light smoothing\n            light_position = lights[l].position;\n\n#if is_shadow_smooth == 1\n            // perform light smoothing\n            light_position += dlight * random_in_unit_sphere();\n#endif\n\n            color += reflecnance*set_color(intersection_to_object, normal_to_surface,\n                            normalize(light_position - intersection_to_object), lights[l], i);\n            reflecnance *= objects[i].reflecnance;\n        }\n        ray.position = intersection_to_object;\n        ray.direction = reflect(ray.direction, normal_to_surface);\n    }\n    \n    return color;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    Ray ray;\n    vec2 offset, uv;\n    initRandomGenerator(fragCoord);\n\n    // change the position of second light\n    lights[1].position.xy = 5. * convert_uv(iMouse.xy);\n\n    // change the position of first sphere\n    objects[0].position.z = -0.5*(1. + cos(iTime));\n    // change the position of second sphere\n    objects[1].position.y = 0.25 + 0.5*cos(1.5 * iTime);\n    objects[1].position.z += -1. + 1.5 * sin(iTime);\n    // change the position of third sphere\n    objects[2].position.xy += vec2(0.1 + 0.25*cos(1.8 * iTime), -0.1 + 0.35*cos(1.2 * iTime));\n    \n    // camera\n    // load camera parameters\n    vec3 cam_storage = fetchData(iChannel1, DISTANCE_ADDR).rgb;\n    float\n        focal_length = cam_storage.r,\n        hangle = radians(cam_storage.g),\n        vangle = radians(cam_storage.b);\n    vec3 horizontal, vertical;\n    // change camera\n    camera.look_from = camera.look_at + focal_length*vec3(cos(vangle)*sin(hangle), sin(vangle), cos(vangle)*cos(hangle));\n    camera.vup = vec3(-sin(vangle)*sin(hangle), cos(vangle), -sin(vangle)*cos(hangle));\n\n    // a ray from camera on uv\n    ray = Ray(camera.look_from, normalize(camera.look_at - camera.look_from));\n\n    horizontal = viewport_width * cross(ray.direction, camera.vup);\n    vertical = cross(horizontal, ray.direction);\n\n\n    vec3 color = vec3(0.);\n    for (int s = 0; s < samples_per_pixel; s++)\n    {\n        // Normalized pixel coordinates (from -1 to 1 for horizontal)\n        // Antialiasing\n        uv = convert_uv(fragCoord + vec2 (random_midle(), random_midle()));\n        offset = random_in_unit_disk();\n\n        // launch the ray from the camera\n        ray.position = camera.look_from + camera.lens_radius * (offset.x*horizontal + offset.y*vertical);\n        ray.direction = normalize(camera.look_at + uv.x*horizontal + uv.y*vertical - ray.position);\n        color += ray_color(ray);\n\n    }\n    color /= float(samples_per_pixel);\n    \n    // Output to screen\n    fragColor = vec4(color, 1.);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"const ivec2 DISTANCE_ADDR = ivec2(0, 0);\n\n// buf - iChannel to read from\n// addr - the data address in the form of an ivec2 (vector containing two integers)\n#define fetchData(buf, addr) texelFetch(buf, addr, 0)\n\n// buf_pos - fragment position (fragCoord)\n// addr - the data address in the form of an ivec2\n// storeData() just evaluates if the data address matches the fragment position\n// in which case the data should be stored in fragColor.\n#define storeData(buf_pos, addr) ivec2(buf_pos) == addr\n\n#define KEY_LEFT   37\n#define KEY_UP     38\n#define KEY_RIGHT  39\n#define KEY_DOWN   40\n#define KEY_MINUS 107\n#define KEY_PLUS  109\n\n// Antialiasing parameters\n// sample number\n#define samples_per_pixel 100\n// for light smoothing\n#define is_shadow_smooth 1\n//#define is_shadow_smooth false\n// parameter for spatial blur\n#define dlight 0.07\n// camera parameters\n#define viewport_width 2.0\n\n\n// object types\n// plane\n#define PLANE      0\n// sphere\n#define SPHERE     1\n// textured sphere\n#define TEXSPHERE  2\n\n// background color\n#define BACKGROUND vec3(0.5, 0.6, 1.)\n\n#define M_PI 3.14159265358979323846264338327950288\n\n#define MAX_DISTANCE 100.\n#define MAX_DEPTH 3\n\n/////////////////////////////////////////////////////////////////////\n// Object declarations\n/////////////////////////////////////////////////////////////////////\n// object Ray\nstruct Ray {\n    vec3 position;\n    vec3 direction;\n};\nvec3 param_ray(Ray ray, float t)\n{\n    return ray.position + t * ray.direction;\n}\n\n// object Camera\nstruct Camera {\n    float lens_radius; // apperture/viewport_width/2\n    vec3 look_from;\n    vec3 look_at;\n    vec3 vup;\n};\n\n// object Object\nstruct Object {\n    // type = 0 - plane\n    // type = 1 - sphere\n    // type = 2 - textured sphere\n    int type;\n    float radius;\n    vec3 position;\n    vec3 color;\n    vec3 ambient;\n    float shininess;\n    vec3 specular;\n    float reflecnance;\n};\n\n// object Light\nstruct Light {\n    vec3 position;\n    vec3 color;\n    vec3 ambient;\n    vec3 specular;\n};\n/////////////////////////////////////////////////////////////////////\n    \nfloat reflecnance;\n\n\n/////////////////////////////////////////////////////////////////////\n// function for generation of random numbers https://www.shadertoy.com/view/Nsf3Ws\n/////////////////////////////////////////////////////////////////////\nuint seed = 0u;\nvoid hash(){\n    seed ^= 2747636419u;\n    seed *= 2654435769u;\n    seed ^= seed >> 16;\n    seed *= 2654435769u;\n    seed ^= seed >> 16;\n    seed *= 2654435769u;\n}\n\nfloat random(){\n    hash();\n    return float(seed)/4294967295.0;\n}\n/////////////////////////////////////////////////////////////////////\nfloat random_midle()\n{\n    return 2. * random() - 1.;\n}\nvec2 random_in_unit_disk()\n{\n    float phi = 2.*M_PI*random(),\n    rho = sqrt(random());\n    return rho*vec2(cos(phi), sin(phi));\n}\nvec3 random_in_unit_sphere()\n{\n    float phi = 2.*M_PI*random(),\n    theta = acos(2.*random() - 1.),\n    rho = pow(random(), 1./3.);\n    return rho*vec3(cos(theta)*cos(phi), cos(theta)*sin(phi), sin(theta));\n}\n\n\n/////////////////////////////////////////////////////////////////////\n// Object initialisations\n/////////////////////////////////////////////////////////////////////\n// camera initialisation\nCamera camera = Camera(0.05, vec3(0., 0., 10.), vec3(0., 0., -1.5), vec3(0., 1., 0.));\n\n// array of lights\nLight[2] lights = Light[](\n    Light(vec3(1.1, 1., 1.), 0.7 * vec3(1., 1., 0.5), 0.1 * vec3(1.), vec3(1.)),\n    Light(vec3(0., 0., 3.), 0.6 * vec3(0.5, 1., 1.), 0.1 * vec3(0.5, 1., 1.), vec3(0.5, 1., 1.))\n);\n\n// array of objects (spheres and planes)\nObject[] objects = Object[4](\n    Object(SPHERE, 0.3, vec3(0.3, 0.1, -2.), vec3(1., 0., 0.), vec3(1., 0., 0.), 50., vec3(1.), 0.5),\n    Object(SPHERE, 0.3, vec3(-0.2, -0.1, -1.), vec3(0., 1., 0.), vec3(0., 1., 0.), 30., vec3(1.), 0.5),\n    Object(TEXSPHERE, 0.3, vec3(-0.5, 0.1, -1.), vec3(0., 0., 1.), vec3(0., 0., 1.), 20., vec3(1.), 0.5),\n//    Object(PLANE, 0.,  vec3(0., 0., -10.), vec3(0.), vec3(0.), 20., vec3(.1)),\n    Object(SPHERE, 100.,  vec3(0., -101., 0.), vec3(0.5), vec3(0.5), 10., vec3(.1), 0.5) // ground\n);\n/////////////////////////////////////////////////////////////////////\n\n\n// find distance to an object\nfloat distance_to_object(Ray ray, int i)\n{\n    vec3 Ro = objects[i].position - ray.position;\n    switch(objects[i].type)\n    {\n        case PLANE:\n            return Ro.z / ray.direction.z;\n        case SPHERE:\n        case TEXSPHERE:\n            float b = dot(ray.direction, Ro);\n            float discriminant = b*b + objects[i].radius*objects[i].radius - dot(Ro, Ro);\n\n            if (discriminant < 0.) return -1.;\n\n            // solution of square equaion\n            return b - sqrt(discriminant);\n    }\n}\n\n\n// find closest object\nint find_closest(Ray ray, inout float min_distance, int i0)\n{\n    // distance to object from camera\n    float distance;\n    \n    for (int i = 0; i < objects.length(); i++)\n    {\n        if(i == i0) continue;\n        distance = distance_to_object(ray, i);\n        if ((distance > 0.) && (min_distance > distance))\n        {\n            min_distance = distance;\n            i0 = i;\n        }\n    }\n    return i0;\n}\n\nvec3 normal(vec3 intersection_to_object, int i)\n{\n    switch(objects[i].type)\n    {\n        case PLANE:\n            return vec3(0., 0., 1.);\n        case SPHERE:\n        case TEXSPHERE:\n            return normalize(intersection_to_object - objects[i].position);\n    }\n}\n\n\nvoid basis(vec3 direction, out vec3 base1, out vec3 base2)\n{\n    if (dot(direction, vec3(1., 0., 0.)) == 1. )\n    {\n        base1 = vec3(0., 1., 0.);\n        base2 = vec3(0., 0., 1.);\n    }\n    else\n    {\n        base1 = normalize(cross(vec3(1., 0., 0.), direction));\n        base2 = normalize(cross(base1, direction));\n    }\n}\n\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n// fragColor.r for storing the distance\n// fragColor.g for storing the horizontal angle\n// fragColor.b for storing the vertical angle\n    if (storeData(fragCoord, DISTANCE_ADDR))\n        if (iFrame == 0)\n        {\n            // initialization\n            fragColor = vec4(5.0, 15.0, 10.0, 0.0); // Initial value (distance, horizontal angle, vertical angle, unused)\n        }\n        else\n        {\n            // no mouse\n            bool is_hmouse = false;\n            bool is_vmouse = false;\n\n            // Load value from previous frame\n            fragColor = fetchData(iChannel0, DISTANCE_ADDR);\n\n            // Update:\n            // get mouse swipe\n            vec4 m = iMouse;\n            vec2 move = abs(m.zw) - m.xy;\n            /*\n            is_hmouse = m.z > 0. && abs(move.y) < abs(move.x); // button is down\n            is_vmouse = m.z > 0. && abs(move.x) < abs(move.y); // button is down\n            */\n\n            if (texelFetch( iChannel1, ivec2(KEY_PLUS, 0), 0).x == 1.0)\n            {\n                // When the PLUS is pressed increase the distance\n                fragColor.r = clamp(fragColor.r + 0.1, 1., 20.0);\n            }\n            if (texelFetch( iChannel1, ivec2(KEY_MINUS, 0), 0).x == 1.0)\n            {\n                // When the MINUS is pressed reduce the distance\n                fragColor.r = clamp(fragColor.r - 0.1, 1., 20.0);\n            }\n            if (texelFetch( iChannel1, ivec2(KEY_UP, 0), 0).x == 1.0  || (is_vmouse && move.y > 0.) )\n            {\n                // When the UP is pressed increase the vertical angle\n                fragColor.b = clamp(fragColor.b + 2., 0.0, 90.0);\n            }\n            if (texelFetch( iChannel1, ivec2(KEY_DOWN, 0), 0).x == 1.0  || (is_vmouse && move.y < 0.) )\n            {\n                // When the DOWN is pressed reduce the vertical angle\n                fragColor.b = clamp(fragColor.b - 2., 0.0, 90.0);\n            }\n            if (texelFetch( iChannel1, ivec2(KEY_RIGHT, 0), 0).x == 1.0 || (is_hmouse && move.x > 0.) )\n            {\n                // When the RIGHT is pressed increase the angle\n                fragColor.g += 2.;\n                fragColor.g = (fragColor.g > 180.0)? -180. : fragColor.g;\n            }\n            if (texelFetch( iChannel1, ivec2(KEY_LEFT, 0), 0).x == 1.0 || (is_hmouse && move.x < 0.) )\n            {\n                // When the LEFT is pressed reduce the angle\n                fragColor.g -= 2.;\n                fragColor.g = (fragColor.g < -180.0)? 180. : fragColor.g;\n            }\n        }\n}","name":"Buffer A","description":"","type":"buffer"}]}