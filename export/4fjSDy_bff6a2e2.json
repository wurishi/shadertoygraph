{"ver":"0.1","info":{"id":"4fjSDy","date":"1707717106","viewed":972,"name":"Alice","username":"SL0ANE","description":"角色出自漫画《勇者传》","likes":51,"published":1,"flags":48,"usePreview":1,"tags":["procedural","3d","raymarching","distancefield","sdf","cartoon","manga","anime","girl"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"# define MAX_DISTANCE 1024.0\n# define MIN_STEP 64\n# define MAX_STEP 512\n# define MIN_DIS_SHADOW 0.064\n# define BACKGROUND_COLOR vec4(0.89, 0.4, 0.42, 1.0)\n# define SLOANE_COLOR vec4(0.98, 0.52, 0.52, 1.0)\n\n# define LIGHT_DIRECTION vec3(-1.0, -0.5, 2.0)\n# define LIGHT_COLOR vec4(1.0, 0.98, 0.94, 1.0)\n# define LIGHT_STRENGTH 1.0\n# define AMBIENT_COLOR vec4(0.4, 0.3, 0.7, 1.0)\n\n# define BLINK_THRESHOLD 0.16\n# define FRAMERATE 12.0\n\n# define SKIN_COLOR (vec4(251.0, 209.0, 192.0, 255.0) / 255.0)\n// Pre\nObjectInfo sceneSolidMap(vec3 point, bool castShadow, bool withMat, out float outlineDis);\nMaterial sceneBaseMaterial(vec3 point, float len);\nvec4 atmosphereShading(vec4 backGroundColor, vec4 LightColor, vec4 ShadowColor, Material material, vec3 normal);\nvec4 getColorAtPos(vec3 pos, vec3 ray, float len, vec2 screenCoord, float pixelSize, float dis, inout vec3 normal, bool outlineHit, float disWhenHit, float lenWhenHit);\n\n// Camera Config\nfloat cameraFov = 26.0f;\n\n// Outline Config\nfloat outlineStrength;\nfloat outlineThreshold = 0.05;\n\n// Bone\n\nvec3 positionLocal_Camera = vec3(0.0, 0.0, 0.0);\nvec4 rotationLocal_Camera = vec4(0.0, 0.0, 0.0, 1.0);\nvec3 positionWorld_Camera;\nvec4 rotationWorld_Camera;\n\nvec3 positionLocal_Root = vec3(0.1, 0.48, 21.0);\nvec4 rotationLocal_Root = vec4(0.0, 0.0, 0.0, 1.0);\nvec3 positionWorld_Root;\nvec4 rotationWorld_Root;\n\nvec3 positionLocal_Pin = vec3(-0.25, 0.7, -0.75);\nvec4 rotationLocal_Pin = vec4(-0.329, -0.259, -0.094, 0.903);\nvec3 positionWorld_Pin;\nvec4 rotationWorld_Pin;\n\nvec3 positionLocal_Scarf = vec3(0.0, -1.6, 0.2);\nvec4 rotationLocal_Scarf = vec4(0.105, 0.0, 0.0, 0.995);\nvec3 positionWorld_Scarf;\nvec4 rotationWorld_Scarf;\n\nstruct FacialInfo\n{\n    vec3 skinColor;\n    vec3 skinShadeColor;\n    vec3 blushColor;\n    float blushFactor;\n    \n    vec3 eyeBallColor;\n    vec3 eyeBallSecondColor;\n    float eyeBallEmmision;\n    float eyeBallSecondEmmision;\n    \n    vec3 lashColor;\n    vec3 browColor;\n    \n    vec3 hairColor;\n    vec3 hairHighlightColor;\n    \n    vec2 leftEyeBallPos;\n    float leftEyeBallScale;\n    vec2 rightEyeBallPos;\n    float rightEyeBallScale;\n    \n    float leftUpLidPos;\n    float leftDownLidPos;\n    float rightUpLidPos;\n    float rightDownLidPos;\n    \n    vec2 leftBrowStart;\n    vec2 leftBrowEnd;\n    vec2 leftBrowDir;\n    vec2 rightBrowStart;\n    vec2 rightBrowEnd;\n    vec2 rightBrowDir;\n    \n    float lipBend;\n    \n};\n\nFacialInfo defaultFacialInfo = FacialInfo(\n    vec3(251.0, 209.0, 184.0) / 255.0,\n    vec3(200.0, 140.0, 150.0) / 255.0,\n    vec3(216.0, 102.0, 102.0) / 255.0,\n    0.4,\n    \n    vec3(0.3, 0.2, 0.24),\n    vec3(0.89, 0.2, 0.22),\n    0.1,\n    0.8,\n    \n    vec3(0.3, 0.2, 0.24),\n    vec3(0.3, 0.2, 0.24),\n    \n    vec3(236.0, 79.0, 62.0) / 255.0,\n    vec3(255.0, 223.0, 162.0) / 255.0,\n    \n    vec2(-0.25, -0.125),\n    1.0,\n    vec2(-0.4, -0.125),\n    1.0,\n    \n    0.04,\n    0.05,\n    0.04,\n    0.05,\n    \n    vec2(-1.0, -0.8),\n    vec2(1.0, 0.2),\n    vec2(-0.3, 0.5),\n    vec2(1.0, -0.8),\n    vec2(-1.0, 0.2),\n    vec2(0.3, 0.5),\n    \n    // vec2(-1.0, -0.8),\n    // vec2(1.0, 0.2),\n    // vec2(-0.3, 0.5),\n    // vec2(1.0, -0.8),\n    // vec2(-1.0, 0.2),\n    // vec2(0.3, 0.5),\n    \n    0.5\n);\n\n// Util\nvec3 getSolidNormal(vec3 point, float pixelSize)\n{\n    vec3 deltaX = vec3(pixelSize, 0.0, 0.0) / 4.0;\n    vec3 deltaY = vec3(0.0, pixelSize, 0.0) / 4.0;\n    vec3 deltaZ = vec3(0.0, 0.0, pixelSize) / 4.0;\n    \n    float outlineDis;\n    \n    float x = sceneSolidMap(point + deltaX, false, false, outlineDis).dis - sceneSolidMap(point - deltaX, false, false, outlineDis).dis;\n    float y = sceneSolidMap(point + deltaY, false, false, outlineDis).dis - sceneSolidMap(point - deltaY, false, false, outlineDis).dis;\n    float z = sceneSolidMap(point + deltaZ, false, false, outlineDis).dis - sceneSolidMap(point - deltaZ, false, false, outlineDis).dis;\n    \n    return normalize(vec3(x, y, z));\n}\n\nvec3 getRoughSolidNormal(vec3 point, float curDis, float pixelSize)\n{\n    vec3 deltaX = vec3(pixelSize, 0.0, 0.0) / 4.0;\n    vec3 deltaY = vec3(0.0, pixelSize, 0.0) / 4.0;\n    vec3 deltaZ = vec3(0.0, 0.0, pixelSize) / 4.0;\n    \n    float outlineDis;\n    \n    float x = sceneSolidMap(point + deltaX, false, false, outlineDis).dis - curDis;\n    float y = sceneSolidMap(point + deltaY, false, false, outlineDis).dis - curDis;\n    float z = sceneSolidMap(point + deltaZ, false, false, outlineDis).dis - curDis;\n    \n    return normalize(vec3(x, y, z));\n}\n\nfloat softshadow(vec3 ro, vec3 rd, float mint, float maxt, float k)\n{\n    float res = 1.0;\n    float t = mint;\n    float outlineDis;\n    \n    while(t < maxt)\n    {\n        float h = sceneSolidMap(ro + rd * t, true, false, outlineDis).dis;\n        if(h < TOLERANCE)\n            return 0.0;\n        res = min(res, k * h/t);\n        t += h;\n    }\n    return res;\n}\n// Object\n\nObjectInfo animeHead(vec3 p, vec3 sdf_pos, vec4 sdf_rot, float sdf_scale, FacialInfo facialInfo, bool castShadow, bool withMat, out float outlineDis)\n{\n    ObjectInfo info = ObjectInfo(0.0,\n                      Material(\n                      vec4(facialInfo.skinColor, 1.0),\n                      vec4(facialInfo.skinShadeColor, 1.0),\n                      vec4(0.0),\n                      vec3(0.0),\n                      vec3(0.0),\n                      vec3(0.0),\n                      0.0, 4.0, 0.2, 0.0, 0.0, 2));\n    \n    vec3 transPoint = (p - sdf_pos) / sdf_scale;\n    transPoint = rotatePoint(transPoint, vec3(0), quaternionInverse(sdf_rot));\n    \n    float baseSd =  ssub(\n                    smin(\n                    smin(\n                    // 鼻子\n                    ssub(\n                    ssub(\n                         sdEllipsoid(transPoint, vec3(0.0, -0.05, -0.16), vec3(0.02, 0.08, 0.07)),\n                         sdEllipsoid(transPoint, vec3(-0.08, 0.12, -0.22), vec3(0.11, 0.32, 0.1)),\n                    0.008),\n                         sdEllipsoid(transPoint, vec3(0.08, 0.12, -0.22), vec3(0.11, 0.32, 0.1)),\n                    0.008),\n                    // 鼻子\n    \n                    // 大致的轮廓\n                    ssub(\n                    smin(sdEllipsoid(transPoint, vec3(0.0, 0.04, -0.025), vec3(0.16, 0.16,0.18)), // 额头\n                         sdRoundCone(transPoint, vec3(0.0, -0.075, -0.05), vec3(0.0, -0.18, -0.12), 0.12, 0.02), // 下颚 \n                    0.04),\n                         sdSphere(transPoint, vec3(0.0, -0.7, 0.18), 0.56), // 下颚切除\n                    0.02),\n                    0.02),\n                    smin(\n                        sdEllipsoid(transPoint, vec3(0.04, -0.07, -0.09), vec3(0.04, 0.04, 0.03)), // 脸颊\n                        sdEllipsoid(transPoint, vec3(-0.04, -0.07, -0.09), vec3(0.04, 0.04, 0.03)), // 脸颊\n                    0.001),\n                    0.09),\n                    // 大致的轮廓\n                   \n                    // 眼眶\n                    smin(\n                        sdEllipsoid(transPoint, vec3(0.11, -0.03, -0.2), vec3(0.03, 0.02, 0.02)), // 脸颊\n                        sdEllipsoid(transPoint, vec3(-0.11, -0.03, -0.2), vec3(0.03, 0.02, 0.02)),\n                    0.02),\n                    0.12);\n    \n    // 眼白\n    float iBackLeftSd = smin(\n                         sdEllipsoid(transPoint, vec3(0.08, -0.022, -0.13), vec3(0.032, 0.03, 0.06)),\n                         sdEllipsoid(transPoint, vec3(0.07, -0.042, -0.13), vec3(0.028, 0.04, 0.06)),\n                        0.07);\n    float iBackRightSd = smin(\n                         sdEllipsoid(transPoint, vec3(-0.08, -0.022, -0.13), vec3(0.032, 0.03, 0.06)),\n                         sdEllipsoid(transPoint, vec3(-0.07, -0.042, -0.13), vec3(0.028, 0.04, 0.06)),\n                        0.07);\n    float iBackSd = min(iBackLeftSd, iBackRightSd);\n    \n   \n    // 眼珠\n    vec3 iCursor = vec3(0.00, -0.02, -0.03);\n    vec3 iBallCenter = vec3(0.07, -0.036, -0.135) + vec3(facialInfo.leftEyeBallPos, 0.0) * 0.03;\n    vec3 iBallZ = normalize(iBallCenter - iCursor);\n    vec3 iBallX = normalize(cross(iBallZ, vec3(0.0, 1.0, 0.0)));\n    vec3 iBallY = -normalize(cross(iBallZ, iBallX));\n    vec3 iBallHighlightCenter = iBallCenter + applyTransform(vec3(0.022, -0.015, 0.002), iBallX, iBallY, iBallZ) * facialInfo.leftEyeBallScale;\n    \n    vec3 iBallTransLeftPoint = transPoint - iBallCenter;\n    iBallTransLeftPoint = applyTransform(iBallTransLeftPoint, iBallX, iBallY, iBallZ);\n    \n    float iBallLeftSd = sdEllipsoid(iBallTransLeftPoint, vec3(0.0), vec3(0.036 * facialInfo.leftEyeBallScale, 0.04 * facialInfo.leftEyeBallScale, 0.005));\n    \n    \n    vec3 iBallHighlightLeftTransPoint = transPoint - iBallHighlightCenter;\n    iBallHighlightLeftTransPoint = applyTransform(iBallHighlightLeftTransPoint, iBallX, iBallY, iBallZ);\n    \n    float iBallHighlightSd = sdEllipsoid(iBallHighlightLeftTransPoint, vec3(0.0), vec3(0.015 * facialInfo.leftEyeBallScale, 0.007 * facialInfo.leftEyeBallScale, 0.0025));\n    \n    \n    iBallCenter = vec3(-0.07, -0.036, -0.135) + vec3(facialInfo.rightEyeBallPos, 0.0) * 0.03;\n    iBallZ = normalize(iBallCenter - iCursor);\n    iBallX = normalize(cross(iBallZ, vec3(0.0, 1.0, 0.0)));\n    iBallY = -normalize(cross(iBallZ, iBallX));\n    iBallHighlightCenter = iBallCenter + applyTransform(vec3(0.022, -0.015, 0.002), iBallX, iBallY, iBallZ) * facialInfo.rightEyeBallScale;\n    \n    vec3 iBallTransRightPoint = transPoint - iBallCenter;\n    iBallTransRightPoint = applyTransform(iBallTransRightPoint, iBallX, iBallY, iBallZ);\n    \n    float iBallRightSd = sdEllipsoid(iBallTransRightPoint, vec3(0.0), vec3(0.036 * facialInfo.rightEyeBallScale, 0.04 * facialInfo.rightEyeBallScale, 0.005));\n    float iBallSd = min(iBallLeftSd, iBallRightSd);\n    \n    \n    vec3 iBallHighlightRightTransPoint = transPoint - iBallHighlightCenter;\n    iBallHighlightRightTransPoint = applyTransform(iBallHighlightRightTransPoint, iBallX, iBallY, iBallZ);\n    \n    iBallHighlightSd = min(iBallHighlightSd, sdEllipsoid(iBallHighlightRightTransPoint, vec3(0.0), vec3(0.015 * facialInfo.rightEyeBallScale, 0.007 * facialInfo.rightEyeBallScale, 0.0025)));\n    \n    // 眼皮\n    float iLidSd;\n    \n    iCursor = vec3(0.00, -0.0, -0.04);\n    vec3 iLidCenter = vec3(0.068, -0.0, -0.126);\n    iBallZ = normalize(iLidCenter - iCursor);\n    iBallX = normalize(cross(iBallZ, vec3(0.0, 1.0, 0.0)));\n    iBallY = -normalize(cross(iBallZ, iBallX));\n    \n    vec3 iLidTrasPoint = transPoint - iLidCenter;\n    iLidTrasPoint = applyTransform(iLidTrasPoint, iBallX, iBallY, iBallZ);\n    \n    float iLidBaseSd = sdEllipsoid(iLidTrasPoint, vec3(0.0), vec3(0.062, 0.1, 0.029));\n    iLidBaseSd = onion(iLidBaseSd, 0.005);\n    iLidBaseSd = sub(iLidBaseSd, sdBox(iLidTrasPoint, vec3(0.0, 0.5, 0.11), vec3(0.8, 0.8, 0.02)));\n    float iLidLeftUpSd = ssub(iLidBaseSd, sdSphere(transPoint, vec3(0.068, mix(-0.15, -0.185, facialInfo.leftUpLidPos), -0.126), mix(0.17, 0.14, facialInfo.leftUpLidPos)), 0.005);\n    float iLidLeftDownSd = sint(sdSphere(transPoint, vec3(0.068, mix(-0.32, -0.185, facialInfo.leftDownLidPos), -0.126), mix(0.23, 0.14, facialInfo.leftDownLidPos)), iLidBaseSd, 0.005);\n    \n    iLidSd = min(iLidLeftUpSd, iLidLeftDownSd);\n    \n    iLidCenter.x = -iLidCenter.x;\n    iBallZ = normalize(iLidCenter - iCursor);\n    iBallX = normalize(cross(iBallZ, vec3(0.0, 1.0, 0.0)));\n    iBallY = -normalize(cross(iBallZ, iBallX));\n    \n    iLidTrasPoint = transPoint - iLidCenter;\n    iLidTrasPoint = applyTransform(iLidTrasPoint, iBallX, iBallY, iBallZ);\n    \n    iLidBaseSd = sdEllipsoid(iLidTrasPoint, vec3(0.0), vec3(0.062, 0.1, 0.029));\n    iLidBaseSd = onion(iLidBaseSd, 0.005);\n    iLidBaseSd = sub(iLidBaseSd, sdBox(iLidTrasPoint, vec3(0.0, 0.5, -0.11), vec3(0.8, 0.8, 0.11)));\n    float iLidRightUpSd = ssub(iLidBaseSd, sdSphere(transPoint, vec3(-0.068, mix(-0.15, -0.185, facialInfo.rightUpLidPos), -0.126), mix(0.17, 0.14, facialInfo.rightUpLidPos)), 0.005);\n    float iLidRightDownSd = sint(sdSphere(transPoint, vec3(-0.068, mix(-0.32, -0.185, facialInfo.rightDownLidPos), -0.126), mix(0.23, 0.14, facialInfo.rightDownLidPos)), iLidBaseSd, 0.005);\n    \n    iLidSd = min(iLidSd, min(iLidRightUpSd, iLidRightDownSd));\n    \n    // 睫毛\n    float iLashSd;\n    \n    float tempFactor = 4.3;\n    float tempCos = cos(tempFactor * transPoint.x);\n    float tempSin = sin(tempFactor * transPoint.x);\n    mat2  tempMat = mat2(tempCos, -tempSin, tempSin ,tempCos);\n    vec3  iLashTransPoint = transPoint - vec3(0.0, 0.0, -0.185 - 0.01 * facialInfo.leftUpLidPos * (0.7 - facialInfo.leftUpLidPos));\n    iLashTransPoint.xz = tempMat * iLashTransPoint.xz;\n    \n    float iLashLeftUpSd = sub(sdCircle(iLashTransPoint.xy,\n                                 facialInfo.leftUpLidPos <= 0.5 ?\n                                 mix(vec2(0.09, -0.032), vec2(0.09, -0.11), facialInfo.leftUpLidPos * 2.0):\n                                 mix(vec2(0.09, -0.11), vec2(0.09, -0.145), facialInfo.leftUpLidPos * 2.0 - 1.0),\n                                 facialInfo.leftUpLidPos <= 0.5 ?\n                                 mix(0.052, 0.103, facialInfo.leftUpLidPos * 2.0):\n                                 mix(0.103, 0.103, facialInfo.leftUpLidPos * 2.0 - 1.0)\n                                 ),\n                               sdCircle(iLashTransPoint.xy,\n                                 facialInfo.leftUpLidPos <= 0.5 ?\n                                 mix(vec2(0.085, -0.05), vec2(0.092, -0.318), facialInfo.leftUpLidPos * 2.0):\n                                 mix(vec2(0.092, -0.318), vec2(0.09, -0.34), facialInfo.leftUpLidPos * 2.0 - 1.0),\n                                 facialInfo.leftUpLidPos <= 0.5 ?\n                                 mix(0.06, 0.3, facialInfo.leftUpLidPos * 2.0):\n                                 mix(0.3, 0.29, facialInfo.leftUpLidPos * 2.0 - 1.0)\n                                 ));\n    tempFactor = 0.006;\n    vec2 tempFlat = vec2(iLashLeftUpSd, abs(iLashTransPoint.z) - tempFactor);\n    iLashLeftUpSd = min(max(tempFlat.x,tempFlat.y),0.0) + length(max(tempFlat, 0.0));\n    \n    \n    iLashTransPoint = transPoint - vec3(0.0, 0.0, -0.185 - 0.01 * facialInfo.rightUpLidPos * (0.7 - facialInfo.rightUpLidPos));\n    iLashTransPoint.xz = tempMat * iLashTransPoint.xz;\n    \n    float iLashRightUpSd = sub(sdCircle(iLashTransPoint.xy,\n                                 facialInfo.rightUpLidPos <= 0.5 ?\n                                 mix(vec2(-0.09, -0.032), vec2(-0.09, -0.11), facialInfo.rightUpLidPos * 2.0):\n                                 mix(vec2(-0.09, -0.11), vec2(-0.09, -0.145), facialInfo.rightUpLidPos * 2.0 - 1.0),\n                                 facialInfo.rightUpLidPos <= 0.5 ?\n                                 mix(0.052, 0.103, facialInfo.rightUpLidPos * 2.0):\n                                 mix(0.103, 0.103, facialInfo.rightUpLidPos * 2.0 - 1.0)\n                                 ),\n                               sdCircle(iLashTransPoint.xy,\n                                 facialInfo.rightUpLidPos <= 0.5 ?\n                                 mix(vec2(-0.085, -0.05), vec2(-0.092, -0.318), facialInfo.rightUpLidPos * 2.0):\n                                 mix(vec2(-0.092, -0.318), vec2(-0.09, -0.34), facialInfo.rightUpLidPos * 2.0 - 1.0),\n                                 facialInfo.rightUpLidPos <= 0.5 ?\n                                 mix(0.06, 0.3, facialInfo.rightUpLidPos * 2.0):\n                                 mix(0.3, 0.29, facialInfo.rightUpLidPos * 2.0 - 1.0)\n                                 ));\n    \n    tempFactor = 0.006;\n    tempFlat = vec2(iLashRightUpSd, abs(iLashTransPoint.z) - tempFactor);\n    iLashRightUpSd = min(max(tempFlat.x,tempFlat.y),0.0) + length(max(tempFlat, 0.0));\n    \n    iLashSd = min(iLashRightUpSd, iLashLeftUpSd);\n    if(castShadow) iLashSd = 65535.0;\n    \n    // 嘴巴\n    float mouthSd;\n    \n    tempFactor = 8.0;\n    tempCos = cos(tempFactor * transPoint.x);\n    tempSin = sin(tempFactor * transPoint.x);\n    tempMat = mat2(tempCos, -tempSin, tempSin ,tempCos);\n    vec3  mouthTransPoint = transPoint - vec3(0.0, -0.16, -0.145);\n    mouthTransPoint.xz = tempMat * mouthTransPoint.xz;\n    \n    tempFactor = 14.0 + (facialInfo.lipBend > 0.0 ? 22.0 : 11.0) * facialInfo.lipBend;\n    tempCos = cos(tempFactor * transPoint.x);\n    tempSin = sin(tempFactor * transPoint.x);\n    tempMat = mat2(tempCos, -tempSin, tempSin ,tempCos);\n    mouthTransPoint.xy = tempMat * mouthTransPoint.xy;\n    \n    mouthSd = sdVesicaSegment(mouthTransPoint, vec3(0.07, 0.0, 0.0), vec3(-0.07, 0.0, 0.0), 0.006);\n    \n    // 头发\n    float hairCutout = sint(sdEllipsoid(transPoint, vec3(0.0, -0.15, -0.25), vec3(0.24, 0.28, 0.2)),\n                           sdEllipsoid(transPoint, vec3(-0.15, -0.36, -0.35), vec3(0.5, 0.5, 0.6)), 0.005);\n    float hairBaseSd = sint(\n                       sub(\n                       sint(sdEllipsoid(transPoint, vec3(0.0, 0.0, 0.03), vec3(0.2, 0.23, 0.28)),\n                           sdEllipsoid(transPoint, vec3(0.0, 0.14, 0.11), vec3(0.32, 0.4, 0.32)), 0.05),\n                       hairCutout),\n                       sdEllipsoid(transPoint, vec3(0.0, 0.03, -0.1), vec3(0.3, 0.24, 0.3)), 0.05);\n                       \n    vec3 hairBaseMap = normalize(transPoint - vec3(0.0, 0.0, -0.1));\n    vec2 hairBaseUV = vec2(atan(hairBaseMap.z, hairBaseMap.x) / (PI * 2.0) + 0.5,\n                           atan(hairBaseMap.y, sqrt(hairBaseMap.x * hairBaseMap.x + hairBaseMap.z * hairBaseMap.z)) / PI + 0.5);\n                           \n    float hairBaseBias = voronoiAndHide(hairBaseUV, vec2(32.0, 1.0), vec2(1.0, 65535.0), vec2(4.0), vec2(0.0), vec2(0.5, 0.5), 0.4)\n                         * smoothstep(0.9, 0.5, hairBaseUV.y) * smoothstep(0.3, 0.2, abs(fract(hairBaseUV.x - 0.25) - 0.5));\n    hairBaseSd -= 0.005 * smoothstep(0.0, 0.4, hairBaseBias);\n    \n    tempFactor = 0.5;\n    tempCos = cos(tempFactor * transPoint.x);\n    tempSin = sin(tempFactor * transPoint.x);\n    tempMat = mat2(tempCos, -tempSin, tempSin ,tempCos);\n    vec3  hairHornTransPoint = transPoint - vec3(0.0, 0.0, 0.0);\n    hairHornTransPoint.xy = tempMat * hairHornTransPoint.xy;\n    float hairLeftHorn = sdRoundCone(hairHornTransPoint, vec3(-0.08, -0.12, -0.02), vec3(-0.32, -0.06, 0.06), 0.054, 0.001);\n    float hairRightHorn = sdRoundCone(hairHornTransPoint, vec3(0.08, -0.12, -0.02), vec3(0.32, -0.06, 0.06), 0.054, 0.001);\n    \n    tempFactor = 0.5;\n    tempCos = cos(tempFactor * transPoint.z);\n    tempSin = sin(tempFactor * transPoint.z);\n    tempMat = mat2(tempCos, -tempSin, tempSin ,tempCos);\n    hairHornTransPoint = transPoint - vec3(0.0, 0.0, 0.0);\n    hairHornTransPoint.zy = tempMat * hairHornTransPoint.zy;\n    float hairBackHorn = sdRoundCone(hairHornTransPoint, vec3(0.0, -0.12, 0.05), vec3(0.0, -0.06, 0.3), 0.054, 0.001);\n                           \n    float hairSd = smin(hairBaseSd, min(min(hairLeftHorn, hairRightHorn), hairBackHorn), 0.003);\n    \n    // info.dis = baseSd;         \n    info.dis = ssub(baseSd, iBackSd, 0.003);\n    info.dis = smin(info.dis, mouthSd, 0.005);\n    info.dis = smin(info.dis, iLidSd, 0.0005);\n    float skinSd = info.dis;\n    info.dis = min(info.dis, hairSd);\n    outlineDis = info.dis;\n    info.dis = min(info.dis, min(iBallSd, iBallHighlightSd));\n    info.dis = min(info.dis, iLashSd);\n    \n    // info.dis = hairSd;\n    \n    \n    // 部分部位屏蔽描边\n    if(iBackSd <= 0.02) outlineDis = 65535.0;\n   \n    \n    vec3 cenVector = normalize(transPoint);\n    float offset = iTime * 1.0;\n    \n    if(withMat)\n    {   \n        // Based on shape\n        if(info.dis == iBallSd)\n        {\n            vec2 uv;\n            if(iBallLeftSd < iBallRightSd)\n            {\n                uv = iBallTransLeftPoint.xy / (vec2(0.036, 0.04) * facialInfo.leftEyeBallScale);\n                info.material.vect0 = normalize(vec3(0.3, 0.0, -1.0));\n            }\n            else\n            {\n                uv = iBallTransRightPoint.xy / (vec2(0.036, 0.04) * facialInfo.rightEyeBallScale);\n                info.material.vect0 = normalize(vec3(-0.3, 0.0, -1.0));\n            }\n            \n            info.material.vect1 = vec3(1.0, 0.0, 0.0);\n            info.material.vect2 = vec3(0.0, -1.0, 0.0);\n            \n            info.material.vect0 = rotatePoint(info.material.vect0, vec3(0), sdf_rot);\n            info.material.vect1 = rotatePoint(info.material.vect1, vec3(0), sdf_rot);\n            info.material.vect2 = rotatePoint(info.material.vect2, vec3(0), sdf_rot);\n            \n            info.material.color0 = vec4(facialInfo.eyeBallColor, facialInfo.eyeBallEmmision);\n            info.material.color1 = vec4(facialInfo.eyeBallSecondColor, facialInfo.eyeBallSecondEmmision);\n            info.material.color2 = vec4(uv, 0.6, 0.4);\n            \n            info.material.index = 4;\n        }\n        else if(info.dis == iLashSd)\n        {\n            info.material.color0 = vec4(facialInfo.lashColor, 1.0);\n            info.material.vect0 = normalize(transPoint - vec3(0.09, 0.0, 0.0));\n            \n            info.material.vect0 = rotatePoint(info.material.vect0, vec3(0), sdf_rot);\n            info.material.index = 5;\n        }\n        else if(info.dis == iBallHighlightSd)\n        {\n            info.material.color0 = vec4(1.0, 1.0, 1.0, 1.0);\n            info.material.index = 0;\n        }\n        else if(iBackSd < 0.0 && baseSd < 0.0)\n        {\n            info.material.color0 = vec4(0.96, 1.0, 0.99, 1.0);\n            info.material.color1 = vec4(0.87, 0.8, 0.85, 1.0);\n            // 覆写法线\n            if(iBackLeftSd < iBackRightSd)\n            {\n                info.material.vect0 = normalize(vec3(0.3, 0.0, -1.0));\n            }\n            else\n            {\n                info.material.vect0 = normalize(vec3(-0.3, 0.0, -1.0));\n            }\n            \n            info.material.vect1 = vec3(0.0, 1.0, 0.0);\n            info.material.t0 = dot(vec3(0.0, 1.0, 0.0), normalize(vec3(0.00, -0.02, -0.006) - vec3(0.0, transPoint.y, 0.0))) / 2.0 + 0.5;\n            info.material.t1 = 0.75; // 自发光\n            \n            info.material.vect0 = rotatePoint(info.material.vect0, vec3(0), sdf_rot);\n            info.material.vect1 = rotatePoint(info.material.vect1, vec3(0), sdf_rot);\n            info.material.index = 3;\n        }\n        else if(info.dis == hairSd)\n        {\n            info.material.color0 = vec4(facialInfo.hairColor, 1.0);\n            info.material.index = 6;\n            \n            if(abs(info.dis - hairBaseSd) <= 0.005 && abs(info.dis - hairCutout) > 0.005)\n            {\n                info.material.t3 = hairBaseUV.y;\n                info.material.t4 = hairBaseUV.x;\n                info.material.color1 = vec4(facialInfo.hairHighlightColor, 1.0);\n                info.material.color2 = vec4(0.5, 0.8, 0.05, 0.1);\n                info.material.vect0 = vec3(0.0, 1.0, 0.0);\n                \n                info.material.vect0 = rotatePoint(info.material.vect0, vec3(0), sdf_rot);\n            }\n            else info.material.t3 = -1.0;\n        }\n        \n        else\n        {\n            // Unrelated to shapes\n            \n            \n            // 嘴巴勾线\n            if(mouthTransPoint.z < 0.0 && mouthTransPoint.x < 0.032 && mouthTransPoint.x > -0.032 && info.dis == skinSd)\n            {\n                float mouthline = mouthTransPoint.y + 16.0 * mouthTransPoint.x * mouthTransPoint.x - 0.007;\n                float mouthlineThick = 0.006 * clamp(abs(mouthTransPoint.x) / 0.028 - 0.02, 0.0, 1.0);\n                if(mouthline < mouthlineThick && mouthline > 0.00)\n                {\n                    info.material.color0 = mix(vec4(0.3, 0.2, 0.24, 1.0), info.material.color0, smoothstep(0.002, 0.0, min(mouthlineThick - mouthline, mouthline)));\n                }\n            }\n            \n            \n            if(transPoint.z < 0.0 && info.dis == skinSd)\n            {\n                // 眉毛\n                float sdBrow;\n                tempFactor = 3.0;\n                tempCos = cos(tempFactor * transPoint.x);\n                tempSin = sin(tempFactor * transPoint.x);\n                tempMat = mat2(tempCos, -tempSin, tempSin ,tempCos);\n                vec3  browTransPoint = transPoint;\n                browTransPoint.xz = tempMat * browTransPoint.xz;\n            \n                vec2 leftBrowCenter = vec2(0.042, 0.045) - vec2(0.0, 1.0) * 0.01 * facialInfo.leftUpLidPos;\n                vec2 leftBrowStart = facialInfo.leftBrowStart * 0.027 + leftBrowCenter;\n                vec2 leftBrowEnd = facialInfo.leftBrowEnd * 0.027 + leftBrowCenter;\n                vec2 leftBrowDir = facialInfo.leftBrowDir * 0.027 + leftBrowCenter;\n                float leftBrowPos = (browTransPoint.x - leftBrowStart.x) / (leftBrowEnd.x - leftBrowStart.x);\n                float leftBrowDis = sdBezier(browTransPoint.xy, leftBrowStart, leftBrowDir, leftBrowEnd);\n                float leftBrowThick = 0.004 * 4.0 * leftBrowPos * (1.0 - leftBrowPos) * (1.0 - leftBrowPos);\n                \n                if(leftBrowDis < leftBrowThick && leftBrowPos > 0.0 && leftBrowPos <= 1.0)\n                    info.material.color0 = mix(vec4(facialInfo.browColor, 1.0), info.material.color0, smoothstep(leftBrowThick - 0.0015, leftBrowThick, leftBrowDis));\n                \n                \n                vec2 rightBrowCenter = vec2(-0.042, 0.045) - vec2(0.0, 1.0) * 0.01 * facialInfo.rightUpLidPos;\n                vec2 rightBrowStart = facialInfo.rightBrowStart * 0.027 + rightBrowCenter;\n                vec2 rightBrowEnd = facialInfo.rightBrowEnd * 0.027 + rightBrowCenter;\n                vec2 rightBrowDir = facialInfo.rightBrowDir * 0.027 + rightBrowCenter;\n                float rightBrowPos = (browTransPoint.x - rightBrowStart.x) / (rightBrowEnd.x - rightBrowStart.x);\n                float rightBrowDis = sdBezier(browTransPoint.xy, rightBrowStart, rightBrowDir, rightBrowEnd);\n                float rightBrowThick = 0.004 * 4.0 * rightBrowPos * (1.0 - rightBrowPos) * (1.0 - rightBrowPos);\n                \n                if(rightBrowDis < rightBrowThick && rightBrowPos > 0.0 && rightBrowPos <= 1.0)\n                    info.material.color0 = mix(vec4(facialInfo.browColor, 1.0), info.material.color0, smoothstep(rightBrowThick - 0.0015, rightBrowThick, rightBrowDis));\n                \n                \n                // 腮红\n                float sdBlush = min(sdEllipsoid(transPoint, vec3(-0.09, -0.09, -0.13), vec3(0.07, 0.06, 0.07)),\n                                    sdEllipsoid(transPoint, vec3(0.09, -0.09, -0.13), vec3(0.07, 0.06, 0.07)));\n                                    \n                if(sdBlush < 0.0)\n                {\n                    info.material.color0.rgb = mix(info.material.color0.rgb, facialInfo.blushColor, smoothstep(0.0, -0.06, sdBlush) * facialInfo.blushFactor);\n                }\n                \n            }\n        }\n        \n    }\n    \n    info.dis *= sdf_scale;\n    outlineDis *= sdf_scale;\n    \n    return info;\n}\n\nObjectInfo hairPin(vec3 p, vec3 sdf_pos, vec4 sdf_rot, float sdf_scale, bool withMat, out float outlineDis)\n{\n    ObjectInfo info = ObjectInfo(0.0,\n                      Material(\n                      vec4(1.0, 0.98, 0.91, 1.0),\n                      vec4(0.0),\n                      vec4(0.0),\n                      vec3(0.0),\n                      vec3(0.0),\n                      vec3(0.0),\n                      0.0, 4.0, 0.2, 0.0, 0.0, 7));\n    \n    vec3 transPoint = (p - sdf_pos) / sdf_scale;\n    transPoint = rotatePoint(transPoint, vec3(0), quaternionInverse(sdf_rot));\n    \n    float tempFactor = 4.0;\n    float tempCos = cos(tempFactor * transPoint.y);\n    float tempSin = sin(tempFactor * transPoint.y);\n    mat2  tempMat = mat2(tempCos, -tempSin, tempSin ,tempCos);\n    transPoint -= vec3(0.0, 0.02, -0.1);\n    transPoint.yz = tempMat * transPoint.yz;\n    \n    info.dis = sdTriangleIsosceles(transPoint.xy, vec2(0.0), vec2(0.032, -0.08));\n    \n    vec2 tempFlat = vec2(info.dis, abs(transPoint.z) - 0.003);\n    info.dis = min(max(tempFlat.x,tempFlat.y),0.0) + length(max(tempFlat, 0.0));\n    info.dis -= 0.003;\n    outlineDis = info.dis;\n    \n    info.dis *= sdf_scale;\n    outlineDis *= sdf_scale;\n    \n    return info;\n}\n\nObjectInfo scarf(vec3 p, vec3 sdf_pos, vec4 sdf_rot, float sdf_scale, bool withMat, out float outlineDis)\n{\n    ObjectInfo info = ObjectInfo(0.0,\n                      Material(\n                      vec4(0.28, 0.24, 0.32, 1.0),\n                      vec4(0.0),\n                      vec4(0.0),\n                      vec3(0.0),\n                      vec3(0.0),\n                      vec3(0.0),\n                      0.0, 4.0, 0.2, 0.0, 0.0, 7));\n    \n    vec3 transPoint = (p - sdf_pos) / sdf_scale;\n    transPoint = rotatePoint(transPoint, vec3(0), quaternionInverse(sdf_rot));\n    \n    float tempFactor = 1.0;\n    float tempCos = cos(tempFactor * transPoint.x);\n    float tempSin = sin(tempFactor * transPoint.x);\n    mat2  tempMat = mat2(tempCos, -tempSin, tempSin ,tempCos);\n    transPoint.xy = tempMat * transPoint.xy;\n    \n    info.dis = smin(sdEllipsoid(transPoint, vec3(0.0), vec3(0.17, 0.1, 0.19)),\n                    sdEllipsoid(transPoint, vec3(0.0, -0.16, 0.02), vec3(0.19, 0.16, 0.23)), 0.05);\n    info.dis = onion(info.dis, 0.005);\n    info.dis = ssub(info.dis, sdBox(transPoint, vec3(0.0, 0.11, 0.0), vec3(0.4, 0.07, 0.4)), 0.002);\n    info.dis = ssub(info.dis, sdBox(transPoint, vec3(0.0, -0.26, 0.0), vec3(0.4, 0.12, 0.4)), 0.002);\n    outlineDis = info.dis;\n    \n    if(withMat)\n    {\n        float sdLine = sdBox(transPoint, vec3(0.0, -0.056, 0.0), vec3(0.4, 0.02, 0.4));\n        info.material.color0.rgb = mix(info.material.color0.rgb, defaultFacialInfo.hairColor, smoothstep(0.002, 0.0, sdLine));\n    }\n    \n    info.dis *= sdf_scale;\n    outlineDis *= sdf_scale;\n    \n    return info;\n}\n\n// Project\n\nfloat outlineMin(float a, float b)\n{\n    if(a > MAX_DISTANCE) return a;\n    if(b > MAX_DISTANCE) return b;\n    return min(a, b);\n}\n\nObjectInfo sceneSolidMap(vec3 point, bool castShadow, bool withMat, out float outlineDis)\n{\n    float headOutline;\n    ObjectInfo headInfo = animeHead(point, positionWorld_Root, rotationWorld_Root, 8.0, defaultFacialInfo, castShadow, withMat, headOutline);\n    float pinOutline;\n    ObjectInfo pinInfo = hairPin(point, positionWorld_Pin, rotationWorld_Pin, 8.0, withMat, pinOutline);\n    float scarfOutline;\n    ObjectInfo scarfInfo = scarf(point, positionWorld_Scarf, rotationWorld_Scarf, 8.0, withMat, scarfOutline);\n    \n    ObjectInfo info = objectMin(objectMin(headInfo, pinInfo), scarfInfo);\n    outlineDis = outlineMin(outlineMin(headOutline, pinOutline), scarfOutline);\n    \n    return info;\n}\n\nvec4 march(vec3 start, vec3 ray, vec3 front, vec2 screenCoord, float pixelSize, inout vec3 pos, inout vec3 normal, inout float len)\n{\n    len = 0.0;\n    float dis = 0.0;\n    vec3 curPos = vec3(0.0);\n    \n    ObjectInfo curSolidInfo;\n    ObjectInfo lastSolidInfo;\n    \n    ObjectInfo curVolInfo;\n    ObjectInfo lastVolInfo;\n    \n    float stepDis;\n    \n    int stepCount = 0;\n    float threshold_0;\n    \n    float curPixelSize;\n    float disWhenHit = 65535.0;\n    float lenWhenHit;\n    float disForRealHit = 65535.0;\n    float lenForRealHit;\n    bool outlineHitFlag = false;\n    float outlineDis;\n    \n    float theta = dot(ray, front);\n    \n    int outlineHit = 0;\n\n    while(len < MAX_DISTANCE && stepCount <= MAX_STEP)\n    {\n        curPos = len * ray + start;\n        pos = curPos;\n        \n        curPixelSize = len * theta * pixelSize;\n        threshold_0 = curPixelSize * 1.0;\n        \n        lastSolidInfo = curSolidInfo;\n        curSolidInfo = sceneSolidMap(curPos, false, false, outlineDis);\n        \n        dis = curSolidInfo.dis;\n        \n        if(dis < threshold_0)\n        {\n            break;\n        }\n        \n        if(outlineHit == 0)\n        {\n            // 第一次到范围内\n            if(outlineDis <= curPixelSize * outlineStrength) outlineHit = 1;\n            \n            float currentDis = outlineDis / curPixelSize;\n            lenWhenHit = len;\n            disWhenHit = currentDis;\n        }\n        else if(outlineHit == 1)\n        {\n            if(outlineDis > MAX_DISTANCE)\n            {\n                outlineHit = 0;\n            }\n            else if(outlineDis <= curPixelSize * outlineStrength)\n            {\n                float currentDis = outlineDis / curPixelSize;\n                \n                if(disWhenHit > currentDis)\n                {\n                    lenWhenHit = len;\n                    disWhenHit = currentDis;\n                }\n            }\n            else\n            {\n                outlineHit = 0;\n                outlineHitFlag = true;\n                if(disWhenHit < disForRealHit)\n                {\n                    disForRealHit = disWhenHit;\n                    lenForRealHit = lenWhenHit;\n                }\n            }\n        }\n\n        stepDis = dis * 0.9;\n        len += stepDis;\n        stepCount += 1;\n    }\n    \n    vec4 outputColor = getColorAtPos(pos, ray, len, screenCoord, curPixelSize, dis, normal, outlineHitFlag, disForRealHit, lenForRealHit);\n    \n    return outputColor;\n}\n\nMaterial sceneBaseMaterial(vec3 point, float len, vec2 screenCoord)\n{\n    if(len >= MAX_DISTANCE) {\n        Material outMat;\n        outMat.color0 = BACKGROUND_COLOR;\n        outMat.index = 0;\n        return outMat;\n    } \n    \n    float outlineDis;\n    return sceneSolidMap(point, false, true, outlineDis).material;\n}\n\nvoid update()\n{\n    outlineStrength = 3.0 * pow(iResolution.x / 800.0, 0.5);\n    float angle;\n    \n    // 相机\n    positionWorld_Camera = positionLocal_Camera;\n    rotationWorld_Camera = rotationLocal_Camera;\n    \n    \n    // 根\n    positionWorld_Root = positionLocal_Root;\n    \n    angle = -PI / 32.0;\n    rotationLocal_Root = quaternionMul(load(POINTER_ROT), quaternionMul(vec4(sin(angle / 2.0), 0.0, 0.0, cos(angle / 2.0)), rotationLocal_Root));\n    angle = PI / 6.0;\n    rotationLocal_Root = quaternionMul(rotationLocal_Root, quaternionMul(vec4(0.0, sin(angle / 2.0), 0.0, cos(angle / 2.0)), rotationLocal_Root));\n    rotationWorld_Root = rotationLocal_Root;\n    \n    // 发卡\n    positionWorld_Pin = rotatePoint(positionLocal_Pin + positionWorld_Root, positionWorld_Root, rotationWorld_Root);\n    rotationWorld_Pin = quaternionMul(rotationWorld_Root, rotationLocal_Pin);\n    \n    // 围巾\n    positionWorld_Scarf = rotatePoint(positionLocal_Scarf + positionWorld_Root, positionWorld_Root, rotationWorld_Root);\n    rotationWorld_Scarf = quaternionMul(rotationWorld_Root, rotationLocal_Scarf);\n    \n    // 表情\n    float frameTime = floor(iTime * FRAMERATE) / FRAMERATE;\n    float blinkFactor;\n    float biinkTimeline = 2.55 * frameTime;\n    float blinkTime = floor(biinkTimeline);\n    if(hash11(blinkTime) > BLINK_THRESHOLD) blinkFactor = -1.0;\n    else blinkFactor = -cos(fract(biinkTimeline) * 2.0 * PI);\n    \n    defaultFacialInfo.rightUpLidPos = blinkFactor * 0.5 + 0.5;\n    defaultFacialInfo.rightDownLidPos = defaultFacialInfo.rightUpLidPos;\n    defaultFacialInfo.leftUpLidPos = defaultFacialInfo.rightUpLidPos;\n    defaultFacialInfo.leftDownLidPos = defaultFacialInfo.rightUpLidPos;\n    // defaultFacialInfo.lipBend = sin(2.0 * iTime);\n    \n    // 眼珠\n    vec3 front = vec3(0.0, 0.0, -1.0);\n    vec3 headLeft = vec3(1.0, 0.0, 0.0);\n    vec3 headUp = vec3(0.0, 1.0, 0.0);\n    \n    headLeft = rotatePoint(headLeft, vec3(0), quaternionInverse(rotationWorld_Root));\n    float horOffset = dot(headLeft, front);\n    \n    defaultFacialInfo.leftEyeBallPos.x = mix(0.5, -0.5, horOffset / 2.0 + 0.5);\n    defaultFacialInfo.rightEyeBallPos.x = mix(-0.5, 0.5, -horOffset / 2.0 + 0.5);\n    \n    headUp = rotatePoint(headUp, vec3(0), quaternionInverse(rotationWorld_Root));\n    float verOffset = dot(headUp, front);\n    \n    defaultFacialInfo.leftEyeBallPos.y = mix(0.6, -0.6, verOffset / 2.0 + 0.5);\n    defaultFacialInfo.rightEyeBallPos.y = mix(0.6, -0.6, verOffset / 2.0 + 0.5);\n    \n}\n\nvec4 defaultShading(vec3 lightDir, float strength, vec4 lightColor, vec4 shadowColor, Material material, vec3 pos, vec3 normal, vec3 view)\n{\n    float expSmoothness = pow(2.7, 5.0 * material.t0 + 1.0);\n    \n    float shodow = softshadow(pos, -lightDir, MIN_DIS_SHADOW, MAX_DISTANCE, 24.0);\n    float lightLevel = clamp(dot(-normal, lightDir), 0.0, 1.0);\n    \n    lightLevel = multiStep(lightLevel, 3.0, 0.0, 0.0) * multiStep(shodow, 3.0, 0.0, 0.0);\n    \n    vec4 diffuse = material.color0 * mix(shadowColor, lightColor, lightLevel) * strength;\n    \n    float res_0 = dot(normalize(mix(lightDir, view, 0.5)), -normal);\n    lightLevel = pow(clamp(res_0, 0.0, 1.0), expSmoothness);\n    \n    vec4 specular = lightColor * lightLevel * shodow * material.t0 * strength;\n    \n    float fresnelLevel = pow(1.0 + dot(view, normal), material.t1);\n    // fresnelLevel = multiStep(fresnelLevel, 2.0, 0.0, 0.0);\n    \n    vec4 fresnel = material.t2 * fresnelLevel * material.color0 * lightColor * strength;\n    \n    return diffuse + specular + fresnel;\n}\n\nvec4 hairShading(vec3 lightDir, float strength, vec4 lightColor, vec4 shadowColor, Material material, vec3 pos, vec3 normal, vec3 view)\n{\n    float expSmoothness = pow(2.7, 5.0 * material.t0 + 1.0);\n    \n    float shodow = softshadow(pos, -lightDir, MIN_DIS_SHADOW, MAX_DISTANCE, 24.0);\n    float diffuseLevel = clamp(dot(-normal, lightDir), 0.0, 1.0);\n    \n    float lightLevel = multiStep(diffuseLevel, 3.0, 0.0, 0.0) * multiStep(shodow, 3.0, 0.0, 0.0);\n    \n    vec4 diffuse = material.color0 * mix(shadowColor, lightColor, lightLevel) * strength;\n    \n    float res_0 = dot(normalize(mix(lightDir, view, 0.5)), -normal);\n    lightLevel = pow(clamp(res_0, 0.0, 1.0), expSmoothness);\n    \n    vec4 specular = lightColor * lightLevel * shodow * material.t0 * strength;\n    \n    float fresnelLevel = pow(1.0 + dot(view, normal), material.t1);\n    \n    vec4 fresnel = material.t2 * fresnelLevel * material.color0 * lightColor * strength;\n    \n    vec4 baseLighting = diffuse + specular + fresnel;\n    \n    float highlightFactor = dot(material.vect0, lightDir) / 2.0 + 0.5;\n    float v = (material.t3 - mix(material.color2.x, material.color2.y, highlightFactor)) / mix(material.color2.z, material.color2.w, highlightFactor);\n    if(v < 0.0 || v > 1.0) return baseLighting;\n    float u = material.t4;\n    float highlightThreshold = mix(0.0, 0.5, diffuseLevel);\n    float highlight = smoothstep(highlightThreshold, highlightThreshold - 0.05, voronoiAndHide(vec2(u, v), vec2(36.0, 1.0), vec2(1.0, 65535.0), vec2(8.0, 0.5), vec2(0.0), vec2(1.0, 0.0), 0.3));\n    \n    \n    \n    return mix(baseLighting, material.color1, highlight);\n}\n\nvec4 skinShading(vec3 lightDir, float strength, vec4 lightColor, Material material, vec3 pos, vec3 normal, vec3 view)\n{\n    float expSmoothness = pow(2.7, 5.0 * material.t0 + 1.0);\n    \n    float shodow = softshadow(pos, -lightDir, MIN_DIS_SHADOW, MAX_DISTANCE, 24.0);\n    float lightLevel = clamp(dot(-normal, lightDir), 0.0, 1.0);\n    \n    lightLevel = multiStep(lightLevel, 2.0, 0.0, 0.0) * multiStep(shodow, 2.0, 0.0, 0.0);\n    \n    vec4 diffuse = material.color0 * mix(material.color1, lightColor, lightLevel) * strength;\n    \n    float res_0 = dot(normalize(mix(lightDir, view, 0.5)), -normal);\n    lightLevel = pow(clamp(res_0, 0.0, 1.0), expSmoothness);\n    \n    vec4 specular = lightColor * lightLevel * shodow * material.t0 * strength;\n    \n    float fresnelLevel = pow(1.0 + dot(view, normal), material.t1);\n    // fresnelLevel = multiStep(fresnelLevel, 2.0, 0.0, 0.0);\n    \n    vec4 fresnel = material.t2 * fresnelLevel * material.color0 * lightColor * strength;\n    \n    return diffuse + specular + fresnel;\n}\n\nvec4 eyeLashShading(vec3 lightDir, float strength, vec4 lightColor, vec4 shadowColor, Material material, vec3 pos, vec3 view)\n{\n    float lightLevel = clamp(dot(-material.vect0, lightDir), 0.0, 1.0);\n    lightLevel = multiStep(lightLevel, 2.0, 0.0, 0.0);\n    \n    vec4 diffuse = material.color0 * mix(shadowColor, lightColor, lightLevel) * strength;\n    \n    return diffuse;\n}\n\nvec4 whiteShading(vec3 lightDir, float strength, vec4 lightColor, vec4 shadowColor, Material material, vec3 pos, vec3 view)\n{\n    float lightLevel = mix(clamp(dot(-material.vect0, lightDir), 0.0, 1.0), 1.0, material.t1);\n    \n    vec4 outColor = mix(material.color1, material.color0, clamp(material.t0 + dot(-material.vect1, lightDir), 0.0, 1.0));\n    vec4 diffuse = outColor * mix(shadowColor, lightColor, lightLevel) * strength;\n    \n    return diffuse;\n}\n\nvec4 eyeBallShading(vec3 lightDir, float strength, vec4 lightColor, vec4 shadowColor, Material material, vec3 pos, vec3 view)\n{\n    vec2 uv = material.color2.xy;\n    vec2 center = uv / vec2(1.0, 0.56) - vec2(0.0, -1.0) + material.color2.zw * vec2(dot(view, material.vect1), dot(view, material.vect2));\n    \n    vec2 polarUV;\n    polarUV.x = atan(center.y, center.x) / (2.0 * PI) + 0.5;\n    polarUV.y = length(center);\n            \n    float factor = smoothstep(0.9, 0.75, polarUV.y);\n                        \n    polarUV.x = atan(uv.y, uv.x) / (2.0 * PI) + 0.5;\n    polarUV.y = length(uv);\n            \n    factor *= smoothstep(0.9, 0.85, polarUV.y);\n            \n    float lightLevel = mix(clamp(dot(-material.vect0, lightDir), 0.0, 1.0), 1.0, mix(material.color0.w, material.color1.w, factor));\n    \n    vec4 outColor = vec4(mix(material.color0.xyz, material.color1.xyz, factor), 1.0);\n    \n    vec4 diffuse = outColor * mix(shadowColor, lightColor, lightLevel) * strength;\n    \n    return diffuse;\n}\n\nvec4 getColorAtPos(vec3 pos, vec3 ray, float len, vec2 screenCoord, float pixelSize, float dis, inout vec3 normal, bool outlineHit, float disWhenHit, float lenWhenHit)\n{\n    Material material = sceneBaseMaterial(pos, len, screenCoord);\n    vec4 outlineColor = vec4(0.0);\n    \n    if(outlineHit)\n    {\n        float outlineThreshold = mix(0.0, outlineStrength, clamp((len - lenWhenHit) / outlineThreshold, 0.0, 1.0));\n        // if(outlineThreshold > disWhenHit) return OUTLINE_COLOR.rgb;\n        outlineColor = vec4(vec3(0.3, 0.2, 0.24), clamp(outlineThreshold - disWhenHit - 0.25, 0.0, 1.0));\n    }\n    \n    vec4 solidColor = vec4(0.0);\n    if(material.index == 0) solidColor = material.color0;\n    else\n    {\n        normal = getSolidNormal(pos, pixelSize);\n    \n        if(material.index == 2) solidColor = skinShading(normalize(LIGHT_DIRECTION), LIGHT_STRENGTH, LIGHT_COLOR, material, pos, normal, ray);\n        else if(material.index == 3) solidColor = whiteShading(normalize(LIGHT_DIRECTION), LIGHT_STRENGTH, LIGHT_COLOR, AMBIENT_COLOR, material, pos, ray);\n        else if(material.index == 4) solidColor = eyeBallShading(normalize(LIGHT_DIRECTION), LIGHT_STRENGTH, LIGHT_COLOR, AMBIENT_COLOR, material, pos, ray);\n        else if(material.index == 5) solidColor = eyeLashShading(normalize(LIGHT_DIRECTION), LIGHT_STRENGTH, LIGHT_COLOR, AMBIENT_COLOR, material, pos, ray);\n        else if(material.index == 5) solidColor = eyeLashShading(normalize(LIGHT_DIRECTION), LIGHT_STRENGTH, LIGHT_COLOR, AMBIENT_COLOR, material, pos, ray);\n        else if(material.index == 6) solidColor = hairShading(normalize(LIGHT_DIRECTION), LIGHT_STRENGTH, LIGHT_COLOR, AMBIENT_COLOR, material, pos, normal, ray);\n        else solidColor = defaultShading(normalize(LIGHT_DIRECTION), LIGHT_STRENGTH, LIGHT_COLOR, AMBIENT_COLOR, material, pos, normal, ray);\n    }\n    \n    return mix(solidColor, outlineColor, outlineColor.a);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    update();\n    \n    vec2 uv = (fragCoord.xy - iResolution.xy / 2.0) / iResolution.x;\n    float delta = 1.0 / iResolution.x;\n    float tanFov = tan(cameraFov / 360.0 * PI);\n    vec3 ray = normalize(vec3(uv, 0.5 / tanFov));\n    // 平面距离为1时，每个像素对应的大小\n    float pixelSize = 2.0 * tanFov / iResolution.x;\n    vec3 front = rotatePoint(vec3(0.0, 0.0, 1.0), vec3(0.0), rotationWorld_Camera);\n    ray = rotatePoint(ray, vec3(0.0), rotationWorld_Camera);\n    \n    vec3 pos;\n    vec3 normal;\n    float len;\n    \n    vec4 color = march(positionWorld_Camera, ray, front, fragCoord / iResolution.xy, pixelSize, pos, normal, len);\n    // color.rgb = pow(color.rgb, vec3(1.0 / 2.2));\n    \n    fragColor = color;\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"# define PI 3.1415926535897932384626433832795\n# define TOLERANCE 0.0001\n\n# define POINTER_ROT ivec2(0, 1)\n# define POINTER_TIME ivec2(0, 2)\n# define POINTER_PRESS ivec2(0, 3)\n# define POINTER_MOUSE ivec2(0, 4)\n# define POINTER_RESETCAM ivec2(0, 5)\n\n# define store(P, V) if (all(equal(ivec2(fragCoord), P))) fragColor = V\n# define load(P) texelFetch(iChannel2, ivec2(P), 0)\n\n# define keyToggle(ascii)  ( texelFetch(iChannel3,ivec2(ascii,2),0).x > 0.)\n# define keyClick(ascii)   ( texelFetch(iChannel3,ivec2(ascii,1),0).x > 0.)\n# define keyDown(ascii)    ( texelFetch(iChannel3,ivec2(ascii,0),0).x > 0.)\n\n# define QUA_ZERO vec4(0.0, 0.0, 0.0, 1.0)\n// Structure\nstruct Material\n{\n    vec4 color0;\n    vec4 color1;\n    vec4 color2;\n    vec3 vect0;\n    vec3 vect1;\n    vec3 vect2;\n    // #0: smoothness, fresnelPower, fresnelScale\n\tfloat t0;\n    float t1;\n    float t2;\n    float t3;\n    float t4;\n    int index;\n};\n\nstruct ObjectInfo\n{\n\tfloat dis;\n    Material material;\n};\n\n// Util\nvec3 applyTransform(vec3 origin, vec3 trans_x, vec3 trans_y, vec3 trans_z)\n{\n    return origin.x * trans_x + origin.y * trans_y + origin.z * trans_z;\n}\n\nfloat multiStep(float value, float level, float minValue, float offset)\n{\n    if(level <= 1.0) return 1.0;\n    \n    float curLevel = value * level;\n    float curOffset = floor(curLevel) / (level - 1.0);\n    curLevel = curLevel + mix(offset, 0.0, curOffset);\n    float curLevelCache = curLevel;\n    float downLevel = round(curLevel - 1.0);\n    float upLevel = downLevel + 1.0;\n    \n    float curLevelFirst = curLevel - downLevel;\n    float aaf = fwidth(curLevelFirst);\n    \n    curLevelFirst = downLevel >= 0.0 ? mix(downLevel, upLevel, smoothstep(1.0 - aaf, 1.0, curLevelFirst)) : upLevel;\n    \n    downLevel = floor(curLevel);\n    upLevel = downLevel + 1.0;\n    \n    float curLevelSecond = curLevel - downLevel;\n    aaf = fwidth(curLevelSecond);\n    \n    curLevelSecond = upLevel < level ? mix(downLevel, upLevel, smoothstep(1.0 - aaf, 1.0, curLevelSecond)) : downLevel;\n    \n    curLevel = min(curLevelFirst, curLevelSecond);\n    \n    curOffset = curLevel / (level - 1.0);\n    curLevel += mix(minValue, 1.0, curOffset);\n    curLevel = curLevel / level;\n    \n    return clamp(curLevel, 0.0, 1.0);\n}\n\nfloat dot2(vec2 v)\n{\n    return dot(v, v);\n}\n\nfloat dot2(vec3 v)\n{\n    return dot(v, v);\n}\n\nvec4 conjugate(vec4 q) {\n    return vec4(-q.x, -q.y, -q.z, q.w);\n}\n\nvec4 quaternionInverse(vec4 q) {\n    return conjugate(q) / dot(q, q);\n}\n\nvec3 sss( float ndl, float ir )\n{\n    float pndl = clamp( ndl, 0.0, 1.0 );\n    float nndl = clamp(-ndl, 0.0, 1.0 );\n\n    return vec3(pndl) + \n           vec3(1.0,0.1,0.0)*0.250*(1.0-pndl)*(1.0-pndl)*pow(1.0-nndl,3.0/(ir+0.001))*clamp(ir-0.04,0.0,1.0);\n}\n\nvec4 quaternionMul(vec4 left, vec4 right)\n{\n    float w = left.w*right.w - left.x*right.x - left.y*right.y - left.z * right.z;\n    float x = left.w*right.x + left.x*right.w + left.z*right.y - left.y * right.z;\n    float y = left.w*right.y + left.y*right.w + left.x*right.z - left.z * right.x;\n    float z = left.w*right.z + left.z*right.w + left.y*right.x - left.x * right.y;\n    \n    return vec4(x, y, z, w);\n}\n\nvec4 quaternionLerp(vec4 starting, vec4 ending, float t)\n{\n    float cosa = starting.x *ending.x + starting.y * ending.y + starting.z *ending.z  + starting.w * ending.w;\n    \n    if (cosa < 0.0) \n    {\n        ending.x = -ending.x;\n        ending.y = -ending.y;\n        ending.z = -ending.z;\n        ending.w = -ending.w;\n        cosa = -cosa;\n    }\n    \n    float k0, k1;\n    \n    if (cosa > 0.9995f) \n    {\n        k0 = 1.0 - t;\n        k1 = t;\n    }\n    else \n    {\n        float sina = sqrt(1.0 - cosa * cosa);\n        float a = atan(sina, cosa);\n        k0 = sin((1.0 - t) * a) / sina;\n        k1 = sin(t * a) / sina;\n    }\n    \n    vec4 result;\n    \n    result.x = starting.x * k0 + ending.x * k1;\n    result.y = starting.y * k0 + ending.y * k1;\n    result.z = starting.z * k0 + ending.z * k1;\n    result.w = starting.w * k0 + ending.w * k1;\n    \n    return result;\n}\n\nvec3 rotatePoint(vec3 p, vec3 center, vec4 q) {\n    vec4 pQuaternion = vec4(p - center, 0.0);\n\n    vec4 rotatedP = quaternionMul(quaternionMul(q , pQuaternion), conjugate(q));\n    vec3 rotatedPoint = rotatedP.xyz;\n    \n    rotatedPoint += center;\n    \n    return rotatedPoint;\n}\n\nfloat onion( in float sdf, in float thickness )\n{\n    return abs(sdf)-thickness;\n}\n\nfloat sint( float d1, float d2, float k )\n{\n    float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.0-h);\n}\n\nfloat smin(float a, float b, float k)\n{\n    float h = max(k - abs(a - b), 0.0);\n    return min(a, b) - h * h * 0.25 / k;\n}\n\nfloat ssub(float a, float b, float k)\n{\n    float h = clamp( 0.5 - 0.5 * (b + a) / k, 0.0, 1.0 );\n    return mix(a, -b, h) + k * h * (1.0 - h);\n}\n\nfloat sub(float d1, float d2)\n{\n    return max(d1, -d2);\n}\n\nfloat xor(float d1, float d2)\n{\n    return max(min(d1,d2),-max(d1,d2));\n}\n\nuint murmurHash12(uvec2 src) {\n    const uint M = 0x5bd1e995u;\n    uint h = 1190494759u;\n    src *= M; src ^= src>>24u; src *= M;\n    h *= M; h ^= src.x; h *= M; h ^= src.y;\n    h ^= h>>13u; h *= M; h ^= h>>15u;\n    return h;\n}\n\nfloat hash12(vec2 src) {\n    uint h = murmurHash12(floatBitsToUint(src));\n    return uintBitsToFloat(h & 0x007fffffu | 0x3f800000u) - 1.0;\n}\n\nuint murmurHash11(uint src) {\n    const uint M = 0x5bd1e995u;\n    uint h = 1190494759u;\n    src *= M; src ^= src>>24u; src *= M;\n    h *= M; h ^= src;\n    h ^= h>>13u; h *= M; h ^= h>>15u;\n    return h;\n}\n\nfloat hash11(float src) {\n    uint h = murmurHash11(floatBitsToUint(src));\n    return uintBitsToFloat(h & 0x007fffffu | 0x3f800000u) - 1.0;\n}\n\nuvec2 murmurHash22(uvec2 src) {\n    const uint M = 0x5bd1e995u;\n    uvec2 h = uvec2(1190494759u, 2147483647u);\n    src *= M; src ^= src>>24u; src *= M;\n    h *= M; h ^= src.x; h *= M; h ^= src.y;\n    h ^= h>>13u; h *= M; h ^= h>>15u;\n    return h;\n}\n\nvec2 hash22(vec2 src) {\n    uvec2 h = murmurHash22(floatBitsToUint(src));\n    return uintBitsToFloat(h & 0x007fffffu | 0x3f800000u) - 1.0;\n}\n\nfloat perlin(float p, float freq, float rep, float offset)\n{\n    p += offset / freq;\n    p *= freq;\n    \n\tvec2 i = vec2(floor(p)) + vec2(0.0, 1.0);\n    i = mod(i, vec2(rep * freq));\n\tfloat f = fract(p);\n\tfloat u = f * f * (3.0 - 2.0 * f);\n\treturn mix(hash11(i.x), hash11(i.y), u);\n}\n\nfloat perlin(vec2 p, vec2 freq, vec2 rep, vec2 offset)\n{\n    p += offset / freq;\n    p *= freq;\n    vec4 gridSet = floor(p.xyxy) + vec4(0.0, 0.0, 1.0, 1.0);\n    vec4 dirSet = fract(p.xyxy) - vec4(0.0, 0.0, 1.0, 1.0);\n    // 必要时保证噪声在连接处连续\n    gridSet = mod(gridSet, (rep * freq).xyxy);\n    \n    vec2 gridLevel_00 = hash22(gridSet.xy) * 2.0 - 1.0;\n    vec2 gridLevel_01 = hash22(gridSet.xw) * 2.0 - 1.0;\n    vec2 gridLevel_10 = hash22(gridSet.zy) * 2.0 - 1.0;\n    vec2 gridLevel_11 = hash22(gridSet.zw) * 2.0 - 1.0;\n    \n    float product_00 = dot(gridLevel_00, dirSet.xy);\n    float product_01 = dot(gridLevel_01, dirSet.xw);\n    float product_10 = dot(gridLevel_10, dirSet.zy);\n    float product_11 = dot(gridLevel_11, dirSet.zw);\n    \n    float t_0 = pow(dirSet.x, 3.0) * (6.0 * pow(dirSet.x, 2.0) - 15.0 * dirSet.x + 10.0);\n    float t_1 = pow(dirSet.y, 3.0) * (6.0 * pow(dirSet.y, 2.0) - 15.0 * dirSet.y + 10.0);\n    \n    // return dirSet.x;\n    return mix(mix(product_00, product_10, t_0), mix(product_01, product_11, t_0), t_1);\n}\n\nfloat voronoi(vec2 p, vec2 freq, vec2 rep, vec2 offset, vec2 bias) {\n    p *= freq;\n    p += offset;\n    vec2 point = floor(p);\n    vec2 f = fract(p);\n    float res = 0.0;\n    for (int j = -1; j <= 1; j++) {\n        for (int i = -1; i <= 1; i++) {\n            vec2 b = vec2(i, j);\n            vec2 pos = mod(point + b, rep * freq);\n            vec2 r = vec2(b) - f + hash22(pos);\n            res += 1.0 / pow(dot(r, r), 8.0);\n        }\n    }\n    return pow(1.0 / res, 0.0625);\n}\n\nfloat voronoiAndHide(vec2 p, vec2 freq, vec2 rep, vec2 offset, vec2 bias, vec2 factor, float posibility) {\n    p *= freq;\n    p += offset;\n    vec2 point = floor(p);\n    vec2 f = fract(p);\n    float res = 0.0;\n    for (int j = -1; j <= 1; j++) {\n        for (int i = -1; i <= 1; i++) {\n            vec2 b = vec2(i, j);\n            vec2 pos = mod(point + b, rep * freq) + bias;\n            vec2 r = vec2(b) - f + hash22(pos) * factor;\n            if(hash12(pos + vec2(123.0, 456.0)) < posibility) res += 0.0;\n            else res += 1.0 / pow(dot(r, r), 8.0);\n        }\n    }\n    return clamp(pow(1.0 / res, 0.0625), 0.0, 1.0);\n}\n\nfloat fbm(vec2 x, float H, vec2 freq, vec2 rep, vec2 offset, int numOctaves)\n{    \n    float G = exp2(-H);\n    float f = 1.0;\n    float a = 1.0;\n    float t = 0.0;\n    for( int i=0; i < numOctaves; i++ )\n    {\n        t += a * perlin(f * x, freq, f * rep, offset / freq);\n        f *= 2.0;\n        a *= G;\n    }\n    return t;\n}\n\nObjectInfo objectMin(ObjectInfo a, ObjectInfo b)\n{\n    if(a.dis < b.dis ) return a;\n    else return b;\n}\n\n// Shape 2D\n\nfloat sdCircle(vec2 p, vec2 sdf_pos, float r)\n{\n    vec2 transPoint = p - sdf_pos;\n    return length(transPoint) - r;\n}\n\nfloat sdTriangleIsosceles(vec2 p, vec2 sdf_pos, vec2 q)\n{\n    p.x = abs(p.x);\n    vec2 a = p - q*clamp( dot(p,q)/dot(q,q), 0.0, 1.0 );\n    vec2 b = p - q*vec2( clamp( p.x/q.x, 0.0, 1.0 ), 1.0 );\n    float s = -sign( q.y );\n    vec2 d = min( vec2( dot(a,a), s*(p.x*q.y-p.y*q.x) ),\n                  vec2( dot(b,b), s*(p.y-q.y)  ));\n    return -sqrt(d.x)*sign(d.y);\n}\n\nfloat sdBezier( in vec2 pos, in vec2 A, in vec2 B, in vec2 C)\n{    \n    vec2 a = B - A;\n    vec2 b = A - 2.0*B + C;\n    vec2 c = a * 2.0;\n    vec2 d = A - pos;\n    float kk = 1.0/dot(b,b);\n    float kx = kk * dot(a,b);\n    float ky = kk * (2.0*dot(a,a)+dot(d,b)) / 3.0;\n    float kz = kk * dot(d,a);      \n    float res = 0.0;\n    float p = ky - kx*kx;\n    float p3 = p*p*p;\n    float q = kx*(2.0*kx*kx-3.0*ky) + kz;\n    float h = q*q + 4.0*p3;\n    if( h >= 0.0) \n    { \n        h = sqrt(h);\n        vec2 x = (vec2(h,-h)-q)/2.0;\n        vec2 uv = sign(x)*pow(abs(x), vec2(1.0/3.0));\n        float t = clamp( uv.x+uv.y-kx, 0.0, 1.0 );\n        res = dot2(d + (c + b*t)*t);\n    }\n    else\n    {\n        float z = sqrt(-p);\n        float v = acos( q/(p*z*2.0) ) / 3.0;\n        float m = cos(v);\n        float n = sin(v)*1.732050808;\n        vec3  t = clamp(vec3(m+m,-n-m,n-m)*z-kx,0.0,1.0);\n        \n        float d1 = dot2(d+(c+b*t.x)*t.x);\n        float d2 = dot2(d+(c+b*t.y)*t.y);\n        if(d1 < d2) \n        {\n            res = d1;\n        }\n        else\n        {\n            res = d2;\n        }\n    }\n    return sqrt( res );\n}\n\n// Shape\nfloat sdSphere(vec3 p, vec3 sdf_pos, float sdf_rad)\n{\n    vec3 transPoint = p - sdf_pos;\n    return distance(transPoint, vec3(0)) - sdf_rad;\n}\n\nfloat sdEllipsoid(vec3 p, vec3 sdf_pos, vec3 sdf_rad)\n{\n    vec3 transPoint = p - sdf_pos;\n    float k0 = length(transPoint / sdf_rad);\n    float k1 = length(transPoint / (sdf_rad * sdf_rad));\n    return k0 * (k0-1.0) / k1;\n}\n\nfloat sdCapsule(vec3 p, vec3 sdf_pos_0, vec3 sdf_pos_1, float sdf_rad)\n{\n    vec3 pa = p - sdf_pos_0, ba = sdf_pos_1 - sdf_pos_0;\n    float h = clamp(dot(pa, ba)/dot(ba, ba), 0.0, 1.0);\n    return length( pa - ba*h ) - sdf_rad;\n}\n\nfloat sdRoundCone( vec3 p, vec3 sdf_pos_0, vec3 sdf_pos_1, float sdf_rad_0, float sdf_rad_1 )\n{\n  vec3  ba = sdf_pos_1 - sdf_pos_0;\n  float l2 = dot(ba,ba);\n  float rr = sdf_rad_0 - sdf_rad_1;\n  float a2 = l2 - rr*rr;\n  float il2 = 1.0/l2;\n    \n  vec3 pa = p - sdf_pos_0;\n  float y = dot(pa,ba);\n  float z = y - l2;\n  float x2 = dot2( pa*l2 - ba*y );\n  float y2 = y*y*l2;\n  float z2 = z*z*l2;\n\n  float k = sign(rr)*rr*rr*x2;\n  if( sign(z)*a2*z2>k ) return  sqrt(x2 + z2)        *il2 - sdf_rad_1;\n  if( sign(y)*a2*y2<k ) return  sqrt(x2 + y2)        *il2 - sdf_rad_0;\n                        return (sqrt(x2*a2*il2)+y*rr)*il2 - sdf_rad_0;\n}\n\nfloat sdCutHollowSphere( vec3 p, vec3 sdf_pos, float sdf_rot, float r, float h, float t )\n{\n  vec3 transPoint = p - sdf_pos;\n  \n  float w = sqrt(r*r-h*h);\n  \n  vec2 q = vec2( length(transPoint.xy), -transPoint.z);\n  return ((h*q.x<w*q.y) ? length(q-vec2(w,h)) : \n                          abs(length(q)-r) ) - t;\n}\n\nfloat sdBox( vec3 p, vec3 sdf_pos, vec3 b )\n{\n  vec3 transPoint = p - sdf_pos;\n  vec3 q = abs(transPoint) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdVesicaSegment( in vec3 p, in vec3 a, in vec3 b, in float w )\n{\n    vec3  c = (a+b)*0.5;\n    float l = length(b-a);\n    vec3  v = (b-a)/l;\n    float y = dot(p-c,v);\n    vec2  q = vec2(length(p-c-y*v),abs(y));\n    \n    float r = 0.5*l;\n    float d = 0.5*(r*r-w*w)/w;\n    vec3  h = (r*q.x<d*(q.y-r)) ? vec3(0.0,r,0.0) : vec3(-d,0.0,d+w);\n \n    return length(q-h.xy) - h.z;\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"# define RECOVER_TIME 2.0\n# define SENSITIVE 1.0\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 curRot = load(POINTER_ROT);\n    float time = load(POINTER_TIME).x;\n    float press = load(POINTER_PRESS).x;\n    vec4 mouse = load(POINTER_MOUSE);\n    if(curRot == vec4(0.0)) curRot = vec4(0.0, 0.0, 0.0, 1.0);\n    \n    if(iMouse.z > 0.0)\n    {\n        if(press < 1.0)\n        {\n            press = 1.0;\n            mouse = iMouse;\n        }\n        \n        vec2 curAng = vec2(PI * SENSITIVE * (iMouse.x - mouse.x) / iResolution.x, PI * SENSITIVE * (mouse.y - iMouse.y) / iResolution.x);\n        time = 0.0;\n        curRot = quaternionMul(vec4(sin(curAng.y / 2.0), 0.0, 0.0, cos(curAng.y / 2.0)), vec4(0.0, sin(curAng.x / 2.0), 0.0, cos(curAng.x / 2.0)));\n\n    }\n    else\n    {\n        press = 0.0;\n        curRot = quaternionLerp(curRot, vec4(0.0, 0.0, 0.0, 1.0), clamp(time / RECOVER_TIME, 0.0, 1.0));\n        time += iTimeDelta;\n    }\n    \n    store(POINTER_ROT, curRot);\n    store(POINTER_TIME, vec4(time));\n    store(POINTER_PRESS, vec4(press));\n    store(POINTER_MOUSE, mouse);\n}","name":"Buffer B","description":"","type":"buffer"}]}