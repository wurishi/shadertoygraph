{"ver":"0.1","info":{"id":"lX23Rz","date":"1708147763","viewed":78,"name":"Crumbling Breach 3 (voronoi SDF)","username":"Cellulose","description":"Sampling a cheaper hexagonal voronoi pattern as a signed distance function.\nClick to test the SDF.  It's a lower bound (min/max CSG of edges), not exact.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["voronoi","sdf"],"hasliked":0,"parentid":"l3fGzl","parentname":"Crumbling Breach 2 (voronoi SDF)"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float rand(vec2 co){\n    return fract(sin(dot(co, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nvec2 rot90(vec2 v)    {return vec2(-v.y, v.x);}\n\nvec2 project(vec2 a, vec2 b)    {return b * (dot(a,b) / dot(b,b));}\nvec2 project_abs(vec2 a, vec2 b)    {return b * (abs(dot(a,b)) / dot(b,b));}\nvec2 reject (vec2 a, vec2 b)    {return a - project(a,b);}\n\n\n// Special thanks to Amit Patel, Red Blob Games\n// https://www.redblobgames.com/grids/hexagons/#pixel-to-hex\nvec2 hex_round(vec2 hax)\n{\n    vec3 frac = vec3(hax, -hax.x-hax.y), qrs = round(frac), diff = abs(qrs-frac);\n    if (diff.x > max(diff.y, diff.z)) return vec2(-qrs.y-qrs.z, qrs.y);\n    else if (diff.y > diff.z)         return vec2(qrs.x, -qrs.x-qrs.z);\n    else                              return vec2(qrs.xy);\n}\nconst float _r3 = sqrt(3.0), _r3d3 = _r3/3.0, _r3d6 = _r3/6.0;\nvec2 xy_to_hex(vec2 xy)    {return vec2(dot(xy, vec2(.5, -_r3d6)), xy.y*_r3d3);}\nvec2 hex_to_xy(vec2 hx)    {return vec2(dot(hx, vec2(2.0, 1.0)),   hx.y*_r3);}\n\n\nconst float FARAWAY = 65000.0;\n\nvec2 voro_point(ivec2 cell)\n{\n    vec2 cen = hex_to_xy(vec2(cell));\n    float ang = rand(.81*cen) * 6.2831853072;\n    \n    // Limiting offset to <=60% of hexagon's inner radius seems to ensure\n    // that the nearest point will always come from a 7-hex cluster.\n    float mag = /* .6 * */ rand(cen);\n    return cen + mag * vec2(cos(ang), sin(ang));\n}\n\nstruct VoroCell\n{\n    vec2  pos;\n    ivec2 cell;\n    vec2  point;\n    float distSq;\n};\n\nvoid voro_test(inout VoroCell voro, ivec2 cell)\n{\n    vec2 point = voro_point(cell);\n    vec2 delta = point-voro.pos;\n        \n    float distSq = dot(delta,delta);\n    if (distSq < voro.distSq)\n    {\n        voro.distSq = distSq;\n        voro.cell = cell;\n        voro.point = point;\n    }\n}\n\n\nconst vec2 CENTER = vec2(14,8);\n\nvec2 cameraShift()\n{\n    return 50.0 * vec2(cos(.01*iTime), sin(.01*iTime));\n}\n\nfloat widen_factor(vec2 pos)\n{\n    //return 0.0;\n    \n    //*/\n    float circle_rad = (5.0 + 3.0 * sin(iTime));\n    float circle_dist = distance(pos, CENTER + cameraShift());\n    \n    float x = 1.0 - clamp(circle_dist / circle_rad, 0.0, 1.0);\n\n    return 2.0 * (x * x * (3.0f - 2.0f * x));\n}\n\nconst ivec2 hex_search[13] = ivec2[13](ivec2(0,0),\n    ivec2(+1,0),ivec2(+1,-1),ivec2(0,+1),\n    ivec2(-1,0),ivec2(-1,+1),ivec2(0,-1),\n    ivec2(+2,-1),ivec2(+1,+1),ivec2(-1,+2),\n    ivec2(-2,+1),ivec2(-1,-1),ivec2(+1,-2));\n\nfloat voronoi_sdf(vec2 pos)\n{\n    // Find the hexagon we're inside (in a regular hexgrid)\n    ivec2 hex = ivec2(hex_round(xy_to_hex(pos)));\n    \n    // We'll search for the hex whose random voronoi point is closest.\n    VoroCell near;\n    near.pos = pos;\n    near.distSq = FARAWAY;\n    near.cell = hex;\n    \n    // We consider the hexagon we're in and its 7 neighbors.\n    for (int i = 0; i < 13; ++i)\n    {\n        voro_test(near, hex+hex_search[i]);\n    }\n    \n    // Then assess voronoi's signed distance function by checking each edge.\n    \n    vec2 nearest = near.point;\n    \n    float dist_to_nearest_cell = -FARAWAY;\n    float dist_to_another_cell =  FARAWAY;\n    \n    vec2 center = CENTER+cameraShift();\n    \n    for (int i = 0; i < 13; ++i)\n    {\n        ivec2 cell = hex+hex_search[i];\n        if (cell == near.cell) continue;\n        \n        vec2 pt = voro_point(cell);\n        \n        vec2 mid = .5 * (nearest.xy + pt.xy), orth = rot90(pt.xy - nearest.xy);\n        vec2 diff = pos-mid;\n\n        vec2 proj = project(diff, orth);\n        float this_edge_sdf = -length(diff-proj);\n\n        // Decide the nature of the crack-widening.\n        vec2 widen_pt = mid;\n        widen_pt += .5*proj; //narrower further away\n        widen_pt -= .5 * project_abs(normalize(orth), mid-center); // wider radial\n\n        float widen = widen_factor(widen_pt);\n        dist_to_another_cell = min(widen-this_edge_sdf, dist_to_another_cell);\n        dist_to_nearest_cell = max(widen+this_edge_sdf, dist_to_nearest_cell);\n\n        this_edge_sdf += widen;\n    }\n    \n    return min(dist_to_nearest_cell, dist_to_another_cell);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.y;\n    \n    uv *= 16.0;\n    vec2 mousePos = 16.0 * iMouse.xy/iResolution.y;\n    //uv.y = 1.2 * uv.y - .1;\n    \n    \n    {\n        uv += cameraShift();\n        mousePos += cameraShift();\n    }\n    \n    //*\n    {\n        //vec2 distort = ;\n        uv       += .03 * cos(3.0*sin(dot(uv.yx, vec2(1.8, 1.55))));\n        mousePos += .03 * cos(3.0*sin(dot(mousePos.yx, vec2(1.8, 1.55))));\n    } //*/\n    \n    \n    float dist = voronoi_sdf(uv);\n    \n    dist *= .75; // for visual consistency with previous draft\n    \n    float mouse_dist = voronoi_sdf(mousePos);\n    \n    vec3 col = max(vec3(0), vec3(1.0 + float(dist > 0.0), exp2(dist*5.0), exp2(dist)) - vec3(1));\n    \n    if (dist < 0.0)\n    {\n        float capdist = -dist;\n        vec3 normal = normalize(vec3(dFdx(capdist), dFdy(capdist), dFdx(uv.x)));\n        col += .25 * dot(normal, vec3(.48, -.6, .64));\n    }\n    \n\n    float mouse_ring = mouse_dist - length(uv-mousePos);\n    if (mouse_ring > 0.0 && mouse_ring < 0.2) col = vec3(.3,.6,1);\n    \n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n","name":"Image","description":"","type":"image"}]}