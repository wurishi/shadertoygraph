{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"//Cheap orthonormal basis by nimitz\n//http://orbit.dtu.dk/fedora/objects/orbit:113874/datastreams/file_75b66578-222e-4c7d-abdf-f7e255100209/content\n//via: http://psgraphics.blogspot.pt/2014/11/making-orthonormal-basis-from-unit.html\n\n//I doubt this is needed on gpu, let me know if you need this for it to work.\n//#define HANDLE_SINGULARITY\n\n#define ITR 80\n#define FAR 10.\n#define time iTime\n\nmat2 mm2(in float a){float c = cos(a), s = sin(a);return mat2(c,-s,s,c);}\n\nfloat map(vec3 p)\n{\n\tp.x += sin(p.z*5.+sin(p.y*5.))*0.3;\n    return (length(p)-1.)*0.7;\n}\n\nfloat march(in vec3 ro, in vec3 rd)\n{\n\tfloat precis = 0.001;\n    float h=precis*2.0;\n    float d = 0.;\n    for( int i=0; i<ITR; i++ )\n    {\n        if( abs(h)<precis || d>FAR ) break;\n        d += h;\n\t    float res = map(ro+rd*d);\n        h = res;\n    }\n\treturn d;\n}\n\nvec3 normal(const in vec3 p)\n{  \n    vec2 e = vec2(-1., 1.)*0.005;   \n\treturn normalize(e.yxx*map(p + e.yxx) + e.xxy*map(p + e.xxy) + \n\t\t\t\t\t e.xyx*map(p + e.xyx) + e.yyy*map(p + e.yyy) );   \n}\n\n//http://orbit.dtu.dk/fedora/objects/orbit:113874/datastreams/file_75b66578-222e-4c7d-abdf-f7e255100209/content\nvoid basis(in vec3 n, out vec3 f, out vec3 r)\n{\n    #ifdef HANDLE_SINGULARITY\n    if(n.z < -0.999999)\n    {\n        f = vec3(0 , -1, 0);\n        r = vec3(-1, 0, 0);\n    }\n    else\n    {\n    \tfloat a = 1./(1. + n.z);\n    \tfloat b = -n.x*n.y*a;\n    \tf = vec3(1. - n.x*n.x*a, b, -n.x);\n    \tr = vec3(b, 1. - n.y*n.y*a , -n.y);\n    }\n    #else\n    float a = 1./(1. + n.z);\n    float b = -n.x*n.y*a;\n    f = vec3(1. - n.x*n.x*a, b, -n.x);\n   \tr = vec3(b, 1. - n.y*n.y*a , -n.y);\n    #endif\n}\n\n//from iq (https://www.shadertoy.com/view/4slGz4)\nvec3 dLine(in vec3 ro, in vec3 rd, in vec3 a, in vec3 b)\n{\n\tvec3 ba = b - a;\n\tvec3 oa = ro - a;\n\tfloat oad  = dot( oa,  rd );\n\tfloat dba  = dot( rd, ba );\n\tfloat baba = dot( ba, ba );\n\tfloat oaba = dot( oa, ba );\n\t\n\tvec2 th = vec2( -oad*baba + dba*oaba, oaba - oad*dba ) / (baba - dba*dba);\n\t\n\tth.x = max(th.x, 0.);\n\tth.y = clamp(th.y, 0., 1.);\n\t\n\tvec3 p = a + ba*th.y;\n\tvec3 q = ro + rd*th.x;\n\t\n\treturn vec3( length( p-q ), th );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n\tvec2 p = fragCoord.xy/iResolution.xy-0.5;\n\tp.x*=iResolution.x/iResolution.y;\n\tvec2 mo = iMouse.xy / iResolution.xy-.5;\n    mo = (mo==vec2(-.5))?mo=vec2(0.8,0.1):mo;\n\tmo.x *= iResolution.x/iResolution.y;\n\t//camera\n\tvec3 ro = vec3(0.,0.,4.5);\n    vec3 rd = normalize(vec3(p,-1.5));\n    vec3 rd2 = vec3(0,0.,-1);\n    mat2 mx = mm2(mo.x*6.);\n    mat2 my = mm2(mo.y*6.); \n    ro.xz *= mx;rd.xz *= mx;rd2.xz *= mx;\n    ro.xy *= my;rd.xy *= my;rd2.xy *= my;\n\t\n    vec3 ligt = normalize( vec3(-.5, 0.2, -0.2) );\n    vec3 lcol = vec3(1.00,0.90,0.75);\n    float rdl = clamp(dot(rd,ligt),0.,1.);\n    vec3 col = lcol*pow(rdl,50.) + vec3(0.1,0.2,0.3)*0.5;\n    \n\tfloat rz = march(ro,rd);\n    \n    if ( rz < FAR )\n    {\n        vec3 pos = ro+rz*rd;\n        vec3 nor= normal(pos);\n        float dif = clamp( dot(nor, ligt), 0., 1. );\n        float bac = clamp( dot(nor, -ligt),0., 1.);\n        float spe = pow(clamp(dot(reflect(rd,nor), ligt), 0., 1.),100.);\n        float fre = 0.6*pow( clamp(1. + dot(nor,rd),0.0,1.0), 2.);\n        vec3 brdf = 1.0*vec3(0.10,0.11,0.13);\n        brdf += 2.*bac*vec3(0.15,0.15,0.15);\n        brdf += 1.50*dif*lcol;\n        col = vec3(0.3,0.3,0.3);\n        col = col*brdf + col*spe + fre*col;\n    }\n    \n    \n    vec3 pdir = vec3(0.5773);\n    pdir.xz *= mm2(time*0.3);\n    pdir.zy *= mm2(time*.44);\n    float rz2 = march(pdir*3.,-pdir);\n    vec3 bpos = pdir*3.+rz2*-pdir;\n\t\n    vec3 nor= normal(bpos);\n    vec3 r = vec3(0);vec3 f = vec3(0);\n    basis(nor,f,r);\n    \n    vec3 g = dLine(ro,rd,bpos,bpos+nor);\n    float occ = step(g.y, rz)*0.5+0.5;\n    col = max(col,smoothstep(-2.5,1.,sin(g.z*120.))*occ*vec3(.3,.3,1)*(1.-smoothstep(0.0,.03,g.x)));\n\n    g = dLine(ro,rd,bpos,bpos+f);\n    occ = step(g.y, rz)*0.5+0.5;\n    col = max(col,smoothstep(-2.5,1.,sin(g.z*120.))*occ*vec3(1.,.2,.2)*(1.-smoothstep(0.0,.03,g.x)));\n\n    g = dLine(ro,rd,bpos,bpos+r);\n    occ = step(g.y, rz)*0.5+0.5;\n    col = max(col,smoothstep(-2.5,1.,sin(g.z*120.))*occ*vec3(.2,1,.2)*(1.-smoothstep(0.0,.03,g.x)));\n    \n\tfragColor = vec4( col, 1.0 );\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"4sSSW3","date":"1416258459","viewed":1449,"name":"Cheap orthonormal basis","username":"nimitz","description":"Orthonormal basis without normalization. Mouse enabled.","likes":56,"published":1,"flags":0,"usePreview":0,"tags":["technique","tangent","orthonormal"],"hasliked":0,"parentid":"","parentname":""}}