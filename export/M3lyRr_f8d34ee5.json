{"ver":"0.1","info":{"id":"M3lyRr","date":"1725769323","viewed":8,"name":"hyperbola number two","username":"hyunjeong","description":"variations on the graph of -xy=1","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["graph"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 palette( float t ){\n    vec3 a = vec3(0.5, 0.5, 0.5);\n    vec3 b = vec3(0.5, 0.5, 0.5);\n    vec3 c = vec3(1.0, 1.0, 1.0);\n    vec3 d = vec3(0.00, 0.33, 0.67);\n//    0.5, 0.5, 0.5\t\t0.5, 0.5, 0.5\t1.0, 1.0, 1.0\t0.00, 0.33, 0.67\n\n    return a + b*cos( 6.28318*(c*t+d));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from -1 to 1), then undid stretching\n    vec2 uv = fragCoord/iResolution.xy*2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    \n    //keeping track of the original coordinates\n    vec2 uv0 = uv;\n    \n    //repetition. basically restarts the inputs from 0 to 1 by taking fractional part\n    //i think this is what i want to modify, changing the sign depending on quadrant.\n    //like note the sign of x * y\n    uv = fract(uv);\n    uv -= 0.5;\n    \n    //taking in quadrant. \n    float s = (uv.x/abs(uv.x))*(uv.y/abs(uv.y));\n\n    \n    //multiply by the sign of the quadrant. so get -1/x in some and 1/x in others.\n    vec2 p = uv;\n    float l= 5.*p.x*(s*p.y) - 1.0;\n    \n    \n    //plugging in the distance from the curve to the palette function\n    vec3 col = palette(l);\n   \n    //brings some of the far out squares back to 0 periodically\n    l = sin(l*10. - iTime)/10.;\n\n    //absolute value so black is only on the square\n    l = abs(l);\n    \n    //step function for cutoff\n    //l = smoothstep(0.0,0.1, l);\n    \n    // inverting color\n    l = 0.02/l;\n\n    col *= l;\n\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}