{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[{"channel":0,"type":"buffer","id":"4dXGR8","filepath":"/media/previz/buffer00.png","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}},{"channel":1,"type":"buffer","id":"XsXGR8","filepath":"/media/previz/buffer01.png","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"code":"void mainImage(out vec4 o, in vec2 p) {\n    o.rgb = texture(iChannel1, p/iResolution.xy).rgb;\n    o.a = 1.0;\n}\n","name":"Image","description":"","type":"image"},{"outputs":[],"inputs":[],"code":"const float PI = radians(180.);\nconst float SQ3 = sqrt(3.);\nconst float INF = 1e10;\n\n// Simulation\nconst int N = 32;\nconst int NUM_STRINGS = 4;\nconst float DT = 0.5;\nconst vec2 ALPHA = vec2(0, 0.35);\nconst float MASS = 0.5;\nconst float DAMPING = 0.0015;\nconst float COUPLING = 0.0003;\n\n// Rendering\nconst vec3 RGB[5] = vec3[5](\n    vec3(1.0, 0.05, 0.3),\n    vec3(0.3, 0.05, 1.0),\n    vec3(1.0, 0.3, 0.05),\n    vec3(0.05, 0.3, 1.0),\n    vec3(0.05, 1.0, 0.3));\nconst float GLOW = 1.5;\nconst float R0 = 0.015;\nconst float R1 = 1.0;\nconst float DMAX = 1.5;\nconst float DECAY = 100.;\n","name":"Common","description":"","type":"common"},{"outputs":[{"channel":0,"id":"4dXGR8"}],"inputs":[{"channel":0,"type":"buffer","id":"4dXGR8","filepath":"/media/previz/buffer00.png","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"code":"// CC0: Coupled String Oscillators\n//  Feel free to use in your experiments.\n//\n// Simulates the motion of masses in iChannel0.\n//  .xy = current\n//  .zw = previous\n\nfloat pluck(float x, float x0) {\n    return min(x/x0, (1.-x)/(1.-x0));\n}\n\nvec2 p2q(vec2 p) {\n    vec2 q = p/iResolution.xy*2. - 1.;\n    return q * iResolution.xy/iResolution.yy;\n}\n\nvoid mainImage(out vec4 o, in vec2 p) {\n    ivec2 pp = ivec2(p - 0.5);\n\n    if (pp.x > N-1 || pp.y > NUM_STRINGS)\n        return;\n     \n    // initial state\n    if (iFrame == 0) {\n        float x = float(pp.x)/float(N-1); // 0..1\n        float x0 = mix(0.1, 0.9, float(pp.y)/float(NUM_STRINGS));\n        o.xy = vec2(0, pluck(x, x0));\n        if (pp.y > 0) o.y = 0.;\n        o.y += 0.01*sin(x*1234.56);\n        o.zw = o.xy;\n        return;\n    }\n    \n    vec4 cc = texelFetch(iChannel0, pp, 0); // .xy=curr, .zw=prev\n    vec2 rr = texelFetch(iChannel0, pp + ivec2(1,0), 0).xy;\n    vec2 ll = texelFetch(iChannel0, pp - ivec2(1,0), 0).xy;\n    \n    vec2 T = rr + ll - 2.*cc.xy; // Hooke's law\n    T += ALPHA*(rr - ll)*T; // the Fermi-Pasta-Ulam model\n    T += COUPLING*texelFetch(iChannel0, ivec2(pp.x, (pp.y+1) % NUM_STRINGS), 0).xy;\n\n    // external force\n    if (iMouse.z > 0.) {\n        vec2 m = iMouse.xy / iResolution.xy;\n        m.y = m.y*2. - 1.;\n        T.y += 0.01*m.y;\n    }\n    \n    o.zw = cc.xy; // prev <- curr\n    o.xy = 2.*cc.xy - cc.zw;\n    o.xy += (T*DT*DT + 0.5*DT*DAMPING*cc.zw)/MASS;\n    o.xy /= 1.0 + 0.5*DAMPING*DT/MASS;\n    o = clamp(o,vec4(-DMAX),vec4(DMAX));\n    \n    if (pp.x == 0 || pp.x == N-1)\n        o.xy = vec2(0);\n}\n","name":"Buffer A","description":"","type":"buffer"},{"outputs":[{"channel":0,"id":"XsXGR8"}],"inputs":[{"channel":0,"type":"buffer","id":"4dXGR8","filepath":"/media/previz/buffer00.png","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}},{"channel":1,"type":"buffer","id":"XsXGR8","filepath":"/media/previz/buffer01.png","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"code":"// CC0: Coupled String Oscillators\n//  Feel free to use in your experiments.\n//\n// Renders the mesh defined by iChannel0 coords.\n\nfloat bezierSDF(vec2 pos, vec2 A, vec2 B, vec2 C){    \n    vec2 a = B - A;\n    vec2 b = A - 2.0*B + C;\n    vec2 c = a * 2.0;\n    vec2 d = A - pos;\n\n    float kk = 1.0 / dot(b,b);\n    float kx = kk * dot(a,b);\n    float ky = kk * (2.0*dot(a,a)+dot(d,b)) / 3.0;\n    float kz = kk * dot(d,a);      \n\n    float res = 0.0;\n\n    float p = ky - kx*kx;\n    float p3 = p*p*p;\n    float q = kx*(2.0*kx*kx - 3.0*ky) + kz;\n    float h = q*q + 4.0*p3;\n\n    if(h >= 0.0){ \n        h = sqrt(h);\n        vec2 x = (vec2(h, -h) - q) / 2.0;\n        vec2 uv = sign(x)*pow(abs(x), vec2(1.0/3.0));\n        float t = uv.x + uv.y - kx;\n        t = clamp( t, 0.0, 1.0 );\n\n        // 1 root\n        vec2 qos = d + (c + b*t)*t;\n        res = length(qos);\n    }else{\n        float z = sqrt(-p);\n        float v = acos( q/(p*z*2.0) ) / 3.0;\n        float m = cos(v);\n        float n = sin(v)*1.732050808;\n        vec3 t = vec3(m + m, -n - m, n - m) * z - kx;\n        t = clamp( t, 0.0, 1.0 );\n\n        // 3 roots\n        vec2 qos = d + (c + b*t.x)*t.x;\n        float dis = dot(qos,qos);\n        \n        res = dis;\n\n        qos = d + (c + b*t.y)*t.y;\n        dis = dot(qos,qos);\n        res = min(res,dis);\n\n        qos = d + (c + b*t.z)*t.z;\n        dis = dot(qos,qos);\n        res = min(res,dis);\n\n        res = sqrt( res );\n    }\n    \n    return res;\n}\n\nfloat lineSDF(vec2 p, vec2 a, vec2 b) {\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nfloat i2x(int i) {\n    float x = float(i)/float(N-1)*2. - 1.;\n    return x * iResolution.x/iResolution.y;\n}\n\nint x2i(float x) {\n    x /= iResolution.x/iResolution.y;\n    x = x*0.5 + 0.5;\n    return int(round(x * float(N-1)));\n}\n\nvec2 pos2(sampler2D ch0, int i, int s) {\n    vec2 xy = texelFetch(ch0, ivec2(i,s), 0).xy;\n    return vec2(i2x(i), 0) + R1*xy;\n}\n\nfloat sdf(sampler2D ch0, vec2 q, int s) {\n    //return bezierSDF(q, vec2(-0.5, 0), vec2(0, 0.3), vec2(0.4, -0.1));\n\n    float d = INF;\n    float dx = i2x(1) - i2x(0);\n    int i0 = x2i(q.x);\n    \n    for (int i = i0 - 1; i <= i0 + 1; i++) {\n        vec2 cc = pos2(ch0, i, s);\n        vec2 ll = pos2(ch0, i-1, s);\n        vec2 rr = pos2(ch0, i+1, s);\n    \n        d = min(d, bezierSDF(q, (ll+cc)/2., cc, (cc+rr)/2.));\n    }\n    \n    //d = min(d, lineSDF(q, ll, cc));\n    //d = min(d, lineSDF(q, cc, rr));\n    \n    return d;\n}\n\nvec3 draw(vec2 q, int s) {\n    float d = sdf(iChannel0, q, s);\n    vec3 col = RGB[s % RGB.length()];\n    return pow(R0/d, GLOW) * col;\n}\n\nvec2 p2q(vec2 p) {\n    vec2 q = p/iResolution.xy*2. - 1.;\n    return q * iResolution.xy/iResolution.yy;\n}\n\nvoid mainImage(out vec4 o, in vec2 p) {\n    vec2 q = p2q(p);\n\n    o.rgb = vec3(0);\n    for (int s = 0; s < NUM_STRINGS; s++)\n      o.rgb += draw(q, s);\n      \n    o.rgb = pow(o.rgb, vec3(0.4545));\n    //o.rgb += exp(-iTimeDelta*DECAY)*texture(iChannel1, p/iResolution.xy).rgb;\n}\n","name":"Buffer B","description":"","type":"buffer"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":true,"mFlagMusicStream":false},"info":{"id":"XcKfWD","date":"1734058048","viewed":33,"name":"Coupled String Oscillators","username":"prasound","description":"Non-linear string oscillators coupled in a round-robin manner:\nu1''=T(u1)+u2    u2''=T(u2)+u3     u3''=T(u3)+u1\nEventually they find a dynamically stable \"spinning\" structure.","likes":1,"published":1,"flags":32,"usePreview":0,"tags":["oscillator"],"hasliked":0,"parentid":"lcGBWW","parentname":"Piano String"}}