{"ver":"0.1","info":{"id":"clyGDh","date":"1684483183","viewed":286,"name":"[zznewclear13] Float Toy","username":"zznewclear13","description":"Recreate Evan Wallace's [url=https://evanw.github.io/float-toy/]Float Toy[/url].\nThis shader shows the value and bit representation of floating-point numbers.\nUse mouse to toggle bits on and off.\nNote the value may not be precise.","likes":29,"published":1,"flags":32,"usePreview":1,"tags":["float","floatingpoint"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// [zznewclear13] Float Toy\n// Recreate Evan Wallace's [url=https://evanw.github.io/float-toy/]Float Toy[/url].\n// This shader shows the value and bit representation of floating-point numbers.\n// Use mouse to toggle bits on and off. Rewind to generate random float numbers.\n// Note the value may not be precise.\n// Inspired by [url=https://evanw.github.io/float-toy/]Float Toy[/url].\n// https://en.wikipedia.org/wiki/Single-precision_floating-point_format\n\n// WARNING: Highly unoptimized code, confusing namings, random spacing, magic numbers, and bad comments (if any).\n// Maybe I'll clean this up later...\n\n#define LOG_10_2 0.301029996\n#define LOG_E_10 2.30258509\n\n// Comment this line to see the theoretical value of inf and nans.\n#define ENABLE_INF_AND_NAN\n\nconst vec3 backgroundColor = vec3(0.98f, 0.97f, 0.94f);\nconst vec3 frameColor = vec3(0.21f, 0.19f, 0.27f);\nconst vec2 textSize = vec2(16.0f, 18.0f);\nconst vec3 signColor = vec3(0.73f, 0.73f, 1.0f);\nconst vec3 expColor = vec3(0.73f, 1.0f, 0.73f);\nconst vec3 fracColor = vec3(1.0f, 0.73f, 0.73f);\nconst float valueOffset = 50.0f;\nconst vec2 valueSize = vec2(25.0f, 30.0f);\nconst float valueGap = 12.0f;\nconst float expRatio = 0.5f;\n    \nfloat sdBox(vec2 p, vec2 c, vec2 b)\n{\n    vec2 d = abs(p-c) - b;\n    return max(d.x, d.y);\n}\n\nfloat drawBox(vec2 fragCoord, vec2 size)\n{\n    float scaleFactor = iResolution.y / referenceRes.y;\n    float sdB = sdBox(fragCoord, vec2(0.0f, size.y * 0.5f), size * 0.5f);\n    float boxAlpha = smoothstep(1.5f/scaleFactor, 0.0f, sdB);\n    return boxAlpha;\n}\n\n// I modified FabriceNeyret2's `char` function\n// Calculate ddxy manually because my `p` may not be continuous.\n// https://www.shadertoy.com/view/llySRh\nvec4 char(vec2 p, int c, vec4 ddxy) \n{\n    if (p.x<0.|| p.x>1. || p.y<0.|| p.y>1.) return vec4(0,0,0,1e5);\n\treturn textureGrad(iChannel1, p/16. + fract( vec2(c, 15-c/16) / 16. ), ddxy.xy, ddxy.zw );\n}\n\nfloat drawChar(vec2 textUV, int c, vec2 size, float thickness, float scaleFactor)\n{\n    vec2 ddxy = 1.0f / 16.0f / size / scaleFactor;\n    float sdText = char(textUV, c, vec4(ddxy.x, 0.0f, 0.0f, ddxy.y)).w;\n    float fontThickness = thickness + 1.0f * (scaleFactor-1.0f);\n    float textAlpha = smoothstep(0.5f + fontThickness*0.01f + 1.5f/size.y/scaleFactor, 0.5f + fontThickness*0.01f, sdText);\n    return textAlpha;\n}\n\nvec3 drawBit(vec2 fragCoord, vec2 size, float thickness, vec3 backgroundColor, bool isOne)\n{\n    float scaleFactor = iResolution.y / referenceRes.y;\n    float sdFrame = sdBox(fragCoord, size * 0.5f, size * 0.5f);\n    float frameAlpha = smoothstep(-0.75f/scaleFactor, +0.75f/scaleFactor, sdFrame + thickness);\n  \n    vec2 textCoord = fragCoord + textSize * 0.5f - size * 0.5f;\n    vec2 textUV = textCoord / textSize;\n    int c = isOne ? 49 : 48;\n    float textAlpha = drawChar(textUV, c, textSize, -4.5f, scaleFactor);\n    \n    frameAlpha = max(frameAlpha, textAlpha);\n    return mix(backgroundColor, frameColor, frameAlpha);\n}\n\nfloat drawBackground(vec2 fragCoord, vec2 size, float thickness)\n{\n    float scaleFactor = iResolution.y / referenceRes.y;\n    size = size * vec2(32.0f, 1.0f);\n    float sdFrame = sdBox(fragCoord, vec2(0.0f), size * 0.5f);\n    float backgroundAlpha = smoothstep(0.75f/scaleFactor, -0.75f/scaleFactor, sdFrame - thickness);\n    return backgroundAlpha;\n}\n\nfloat loadFromTexel(uint y, uint x)\n{\n    return texelFetch(iChannel0, ivec2(x, y), 0).r;\n}\n\nbool getBit(uint x)\n{\n    return floatBitsToUint(loadFromTexel(0u, x)) == 0u;\n}\n\nvec3 getBitColor(float bit)\n{\n    return bit==0.0f?signColor:bit<=8.0f?expColor:fracColor;\n}\n\nvoid getAllBits(float floatVal, out uint signBits, out uint expBits, out uint fracBits, out uint floatBits)\n{\n    // why ~ here?\n    floatBits = ~floatBitsToUint(floatVal);\n    signBits = (floatBits >> 31) & 0x1u;\n    expBits = (floatBits >> 23) & 0x000000FFu;\n    fracBits = (floatBits & 0x007FFFFFu) | 0x3F800000u;  \n}\n\nfloat getSignBitsLength(uint signBits)\n{\n    return signBits == 1u ? 2.0f : 1.0f;\n}\n\nfloat getExpBitsLength(uint expBits, out float signLength)\n{\n    signLength = expBits >= 127u ? 0.0f : 1.0f;\n    int iExpBits = abs(int(expBits) - 127);\n    float numberLength = iExpBits >= 100 ? 3.0f : iExpBits >= 10 ? 2.0f : 1.0f;\n    \n    return signLength + numberLength;\n}\n\nfloat getFracBitsLength(uint fracBits)\n{\n    return 2.0f + 8.0f;\n}\n\nfloat drawSignBits(vec2 fragCoord, uint signBits, float signBitsLength)\n{\n    float scaleFactor = iResolution.y / referenceRes.y;\n    float stride = valueSize.x - valueGap;\n    vec2 textCoord = fragCoord + vec2(0.5f * signBitsLength * stride, 0.0f);\n    float textIndex = floor(textCoord.x / stride);\n    if(textIndex < 0.0f || textIndex >= signBitsLength) return 0.0f;\n    \n    vec2 textUV = (textCoord - vec2(stride, 0.0f) * (textIndex - 0.5f)) / valueSize;\n    int c = (signBitsLength-textIndex) == 1.0f ? 49 : 45;\n    float textAlpha = drawChar(textUV, c, valueSize, -3.0f, scaleFactor);\n    return textAlpha;\n}\n\nint getIntDigit(int iVal, float index, float len, float signLen)\n{\n    if(index < signLen) return 45;\n    float fVal = float(iVal);\n    for (float i=0.0f; i<=(len-index-1.0f); i++)\n    {\n        fVal/=9.999999f;\n    }\n    \n    return int(fract(fVal) * 10.0f) + 48;\n}\n\nfloat drawExpBits(vec2 fragCoord, uint expBits, float expBitsLength, float expBitsSignLength)\n{   \n    float scaleFactor = iResolution.y / referenceRes.y;  \n    vec2 textCoord = fragCoord;\n    vec2 tempValueSize = valueSize;\n    float tempValueGap = valueGap;\n    \n    if(fragCoord.x > 0.0f)\n    {\n        tempValueSize *= expRatio;\n        tempValueGap *= expRatio;\n    }\n    float stride = tempValueSize.x - tempValueGap;\n    \n    float textIndex = floor(textCoord.x / stride);\n    if(textIndex < -1.0f || textIndex >= expBitsLength) return 0.0f;\n    vec2 textUV = (textCoord - vec2(stride, 0.0f) * (textIndex - 0.5f)) / tempValueSize;\n    if(fragCoord.x > 0.0f) textUV.y -= 1.0f;\n    \n    int iExpBits = abs(max(int(expBits) - 127, -126));\n    int c = fragCoord.x < 0.0f ? 50 : getIntDigit(iExpBits, textIndex, expBitsLength, expBitsSignLength);\n    float textAlpha = drawChar(textUV, c, tempValueSize, -3.0f, scaleFactor);  \n    return textAlpha;\n}\n\nint getFracDigit(float fVal, bool leadZero, float index, float len)\n{\n    if(index == 0.0f) return leadZero ? 48 : 49;\n    if(index == 1.0f) return 46;\n\n    for (float i=0.0f; i<=(index-2.0f); i++)\n    {\n        fVal = fract(fVal) * 10.0f;\n    }\n    return int(fVal) + 48;\n}\n\nfloat drawFracBits(vec2 fragCoord, uint expBits, uint fracBits, float fracBitsLength)\n{\n    float scaleFactor = iResolution.y / referenceRes.y;\n    float stride = valueSize.x - valueGap;\n    vec2 textCoord = fragCoord + vec2(0.5f * fracBitsLength * stride, 0.0f);\n    float textIndex = floor(textCoord.x / stride);\n    if(textIndex < 0.0f || textIndex >= fracBitsLength) return 0.0f;\n    \n    vec2 textUV = (textCoord - vec2(stride, 0.0f) * (textIndex - 0.5f)) / valueSize;\n    int c = getFracDigit(uintBitsToFloat(fracBits), expBits==0u, textIndex, fracBitsLength);\n    float textAlpha = drawChar(textUV, c, valueSize, -3.0f, scaleFactor);\n    return textAlpha;\n}\n\nfloat drawX(vec2 fragCoord)\n{\n    float scaleFactor = iResolution.y / referenceRes.y;\n    vec2 textCoord = fragCoord + vec2(0.5f * valueSize.x, 0.0f);\n    vec2 textUV = textCoord / valueSize;\n    int c = 88;\n    float textAlpha = drawChar(textUV, c, valueSize, -3.0f, scaleFactor);\n    return textAlpha * 0.5f;\n}\n\nfloat getFloatValueLength(bool isZero, bool isInf, bool isNan, uint signBits, inout float decVal, float floorPow,\n                            out float decSignLength, out float floorSignLength, out float decimalIndex)\n{\n    float floorPowLength = log(abs(floorPow)) / LOG_E_10;\n    decSignLength = signBits == 0u ? 0.0f : 1.0f;\n    floorSignLength = floorPow >= 0.0f ? 0.0f : 1.0f;\n    float totalLength = decSignLength + 9.0f;\n    if(isZero) return totalLength;\n#ifdef ENABLE_INF_AND_NAN\n    if(isInf) return decSignLength + 3.0f;\n    if(isNan) return 3.0f;\n#endif\n    \n    if(floorPow >= 5.0f || floorPow < -4.0f)\n    {\n        totalLength += 1.0f + floorSignLength + floorPowLength;\n        decimalIndex = 1.0f;\n    }\n    else\n    { \n        decimalIndex = 1.0f + floorPow;\n    }\n    return totalLength;\n}\n\nint getFloatDigit(bool isInf, bool isNan,\n                    float decVal, float floorPow, float index, \n                    float decSignLength, float floorPowSignLength, float decimalIndex)\n{\n#ifdef ENABLE_INF_AND_NAN\n    if(isNan) return index == 1.0f ? 65 : 78;\n\n    index -= decSignLength;    \n    if(index < 0.0f) return 45;\n    if(isInf)\n    {\n        if(index == 0.0f) return 73;\n        if(index == 1.0f) return 78;\n        return 70;\n    }\n#else\n    index -= decSignLength;    \n    if(index < 0.0f) return 45;\n#endif\n\n    float fVal = abs(decVal);\n    float maxDecimalIndex = max(decimalIndex, 1.0f);\n    float minDecimalIndex = min(decimalIndex, 1.0f);\n    if(index == maxDecimalIndex) return 46;\n    \n    if(index < 9.0f)\n    {\n        if(index > maxDecimalIndex) index -= 1.0f;\n        if(index + minDecimalIndex <= 0.0f) return 48;\n        if(index + minDecimalIndex == 1.0f) return int(fVal) + 48;\n        for (float i=0.0f; i<=index+minDecimalIndex-2.0f; i++)\n        {\n            fVal = fract(fVal) * 10.0f;\n        }\n        return int(fVal) + 48;\n    }\n    \n    index -= 9.0f;\n    if(index == 0.0f) return 101;\n    index -= (1.0f + floorPowSignLength);\n    if(index < 0.0f) return 45;\n    \n    float expFloorLength = log(abs(floorPow)) / LOG_E_10;\n    fVal = abs(floorPow);\n    for(float i=index; i<expFloorLength; i++)\n    {\n        fVal /= 9.999999f;\n    }\n    return int(fract(fVal) * 10.0f) + 48; \n}\n\nfloat drawFloatValue(vec2 fragCoord, uint signBits, uint expBits, uint fracBits, float floatVal)\n{\n    int iExpBits = max(int(expBits) - 127, -126);\n    bool isZero = false;\n    bool isInf = (expBits == 255u) && (fracBits == 0x3F800000u);\n    bool isNan = (expBits == 255u) && (fracBits > 0x3F800000u);\n    if(expBits == 0u)\n    {\n        int firstOne = -1;\n        for (int i=22;i>=0;i--)\n        {\n            if(((fracBits >> i) & 0x1u) == 0x1u)\n            {\n                firstOne = i;\n                break;\n            }\n        }\n        iExpBits -= (22 - firstOne);\n        fracBits = ((fracBits << (22 - firstOne)) & 0x007FFFFFu) | 0x3F800000u;\n        isZero = firstOne == -1;\n    }\n    \n    float fracVal = uintBitsToFloat(fracBits);\n    if(expBits == 0u) fracVal -= 1.0f;\n    \n    float powVal = float(iExpBits) * LOG_10_2;\n    float fracPow = fract(powVal);\n    float floorPow = floor(powVal);\n    float decVal = pow(10.0f, fracPow) * fracVal;\n    \n    if(decVal >= 10.0f)\n    {\n        decVal *= 0.1f;\n        floorPow += 1.0f;\n    }\n    \n    float decSignLength, floorPowSignLength, decimalIndex;\n    float floatLength = getFloatValueLength(isZero, isInf, isNan, signBits, decVal, floorPow, decSignLength, floorPowSignLength, decimalIndex);\n    \n    float scaleFactor = iResolution.y / referenceRes.y;  \n    float stride = valueSize.x - valueGap;\n    vec2 textCoord = fragCoord + vec2(0.5f * floatLength * stride, 0.0f);\n    float textIndex = floor(textCoord.x / stride);\n    if(textIndex < 0.0f || textIndex >= floatLength) return 0.0f;\n    \n    vec2 textUV = (textCoord - vec2(stride, 0.0f) * (textIndex - 0.5f)) / valueSize;\n    int c = getFloatDigit(isInf, isNan, decVal, floorPow, textIndex, decSignLength, floorPowSignLength, decimalIndex);\n    float textAlpha = drawChar(textUV, c, valueSize, -3.0f, scaleFactor);\n    return textAlpha;\n}\n\nint getHexDigit(uint floatBits, float index)\n{\n    if(index == 0.0f) return 48;\n    if(index == 1.0f) return 120;\n    index -= 2.0f;\n    uint uHexVal = (floatBits >> (4 * int(7.0f - index))) & 0xFu;\n    return int(uHexVal) + (uHexVal < 10u ? 48 : 55);\n}\n\nfloat drawHexValue(vec2 fragCoord, uint floatBits)\n{\n    float scaleFactor = iResolution.y / referenceRes.y;  \n    float stride = valueSize.x - valueGap;\n    \n    float hexLength = 10.0f;\n    vec2 textCoord = fragCoord + vec2(0.5f * hexLength * stride, 0.0f);\n    float textIndex = floor(textCoord.x / stride);\n    if(textIndex < 0.0f || textIndex >= hexLength) return 0.0f;\n    \n    vec2 textUV = (textCoord - vec2(stride, 0.0f) * (textIndex - 0.5f)) / valueSize;\n    int c = getHexDigit(floatBits, textIndex);\n    float textAlpha = drawChar(textUV, c, valueSize, -3.0f, scaleFactor);\n    return textAlpha;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    vec2 centerFragCoord = fragCoord - iResolution.xy * 0.5f;\n    vec2 scaledFragCoord = centerFragCoord * referenceRes.y / iResolution.y;\n    \n    float index = 0.0f;\n    vec2 bitCoord = getBitCoord(scaledFragCoord, bitSize, index);\n    bool isOne = getBit(uint(index));\n    vec3 bitColor = getBitColor(index);\n    vec3 col = drawBit(bitCoord, bitSize, 1.0f, bitColor, isOne);\n\n    float backgroundAlpha = drawBackground(scaledFragCoord, bitSize, 1.0f);\n    col = mix(backgroundColor, col, backgroundAlpha);\n    \n    float floatValue = loadFromTexel(uint(floatBit.y), uint(floatBit.x));\n    uint signBits, expBits, fracBits, floatBits;\n    getAllBits(floatValue, signBits, expBits, fracBits, floatBits);\n    \n    float signBitsLength = getSignBitsLength(signBits);\n    float expBitsSignLength;\n    float expBitsLength = getExpBitsLength(expBits, expBitsSignLength);\n    float fracBitsLength = getFracBitsLength(fracBits);\n\n    float signBitsLengthInPixel = signBitsLength * valueSize.x - (signBitsLength - 1.0f) * valueGap;\n    float expBitsLengthInPixel = 1.0f * valueSize.x + expRatio * (expBitsLength * valueSize.x - expBitsLength * valueGap);\n    float fracBitsLengthInPixel = fracBitsLength * valueSize.x - (fracBitsLength - 1.0f) * valueGap;\n    float xLengthInPixel = valueSize.x * 3.0f;\n    float totalLength = signBitsLengthInPixel + expBitsLengthInPixel + fracBitsLengthInPixel + 2.0f * xLengthInPixel;\n    \n    float signBitOffset = totalLength * 0.5f - signBitsLengthInPixel * 0.5f;\n    float x1Offset = totalLength * 0.5f - signBitsLengthInPixel - xLengthInPixel * 0.5f;\n    float expBitOffset = totalLength * 0.5f - signBitsLengthInPixel - xLengthInPixel - expBitsLengthInPixel * 0.5f;\n    float x2Offset = -totalLength * 0.5f + fracBitsLengthInPixel + xLengthInPixel * 0.5f;\n    float fracBitOffset = -totalLength * 0.5f + fracBitsLengthInPixel * 0.5f;\n\n    float signBitsAlpha = drawSignBits(scaledFragCoord + vec2(signBitOffset, valueOffset+0.5f*textSize.y), signBits, signBitsLength);\n    float signBitsBoxAlpha = drawBox(scaledFragCoord + vec2(signBitOffset, valueOffset+0.5f*textSize.y), vec2(signBitsLengthInPixel, valueSize.y));\n    float expBitsAlpha = drawExpBits(scaledFragCoord + vec2(expBitOffset + (expBitsLengthInPixel-valueSize.x-valueGap) * 0.5f, valueOffset+0.5f*textSize.y), expBits, expBitsLength, expBitsSignLength);\n    float expBitsBoxAlpha = drawBox(scaledFragCoord + vec2(expBitOffset, valueOffset+0.5f*textSize.y), vec2(expBitsLengthInPixel, valueSize.y));\n    float fracBitsAlpha = drawFracBits(scaledFragCoord + vec2(fracBitOffset, valueOffset+0.5f*textSize.y), expBits, fracBits, fracBitsLength);\n    float fracBitsBoxAlpha = drawBox(scaledFragCoord + vec2(fracBitOffset, valueOffset+0.5f*textSize.y), vec2(fracBitsLengthInPixel, valueSize.y));\n    float xAlpha = drawX(scaledFragCoord + vec2(x1Offset, valueOffset+0.5f*textSize.y)) + drawX(scaledFragCoord + vec2(x2Offset, valueOffset+0.5f*textSize.y));\n    \n    float hexAlpha = drawHexValue(scaledFragCoord + vec2(0.0f, -valueOffset+textSize.y), floatBits);\n    float floatAlpha = drawFloatValue(scaledFragCoord + vec2(0.0f, 2.0f*valueOffset+0.5f*textSize.y), signBits, expBits, fracBits, floatValue);\n    col = mix(col, signColor, signBitsBoxAlpha);\n    col = mix(col, expColor, expBitsBoxAlpha);\n    col = mix(col, fracColor, fracBitsBoxAlpha);\n    col = mix(col, frameColor, signBitsAlpha + expBitsAlpha + fracBitsAlpha + xAlpha + hexAlpha + floatAlpha);\n\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// BufferA: uses bit operations to make float numbers.\n\n// Prevent the compiler from optimizing const values.\n// See https://www.shadertoy.com/view/stK3zD\n#define ZEROu uint(min(0, iFrame))\n\nuint loadFromTexel(uint y, uint x)\n{\n    return floatBitsToUint(texelFetch(iChannel0, ivec2(x, y), 0).r);\n}\n\nvoid saveToTexel(ivec2 iFragCoord, uint y, uint x, uint valueToSave, inout uint prevVal)\n{\n    if(iFragCoord.x == int(x) && iFragCoord.y == int(y))\n    {\n        prevVal = valueToSave;\n    }\n}\n\n// https://www.shadertoy.com/view/4djSRW\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec4 init(ivec2 iFragCoord)\n{\n    vec4 col0 = vec4(uintBitsToFloat(ZEROu+0u), 0.0f, 0.0f, 1.0f);\n    vec4 col1 = vec4(uintBitsToFloat(ZEROu+1u), 0.0f, 0.0f, 1.0f);\n    if(iFragCoord.y == 0)\n    {\n        float rv = hash12(vec2(iFragCoord.x, iDate.w));\n        if(rv > 0.5f) col0 = col1;\n    }\n    return col0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 iFragCoord = ivec2(floor(fragCoord));\n    if(iFrame <= 1)\n    {\n        fragColor = init(iFragCoord);\n        return;\n    }\n\n    uint prevVal = loadFromTexel(uint(iFragCoord.y), uint(iFragCoord.x));\n    if(iFragCoord.y == 0 && iMouse.w > 0.0f)\n    {\n        float index = 0.0f;\n        float scaleFactor = iResolution.y / referenceRes.y;\n        vec2 offset = (iMouse.xy - iResolution.xy * 0.5f) / scaleFactor;   \n        \n        if(abs(offset.y) < bitSize.y * 0.5f)\n        {   \n            getBitCoord(offset, bitSize, index);\n            uint valueToSave = 1u - prevVal;\n            saveToTexel(iFragCoord, 0u, uint(index), valueToSave, prevVal);\n        }\n    }\n    \n    int xOffset = 1 << (iFragCoord.y-1);\n    if(iFragCoord.x >= xOffset && iFragCoord.y >= 1 && iFragCoord.y <= 5)\n    {       \n        uint val1 = loadFromTexel(uint(iFragCoord.y-1), uint(iFragCoord.x));\n        uint val2 = loadFromTexel(uint(iFragCoord.y-1), uint(iFragCoord.x - xOffset));\n        uint valueToSave = (val2 << xOffset) | val1;\n        saveToTexel(iFragCoord, uint(iFragCoord.y), uint(iFragCoord.x), valueToSave, prevVal);\n    }\n  \n    fragColor = vec4(uintBitsToFloat(prevVal), 0.0f, 0.0f, 1.0f);\n    // if(iFragCoord.y >= 1)\n    // {\n    //     fragColor = vec4(uintBitsToFloat(ZEROu+0x3FC00000u), 0.0f, 0.0f, 1.0f);\n    // }\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"\nvec2 referenceRes = vec2(512.0f, 288.0f); \nvec2 bitSize = vec2(15.0f, 30.0f);\n\nivec2 signBit = ivec2(0, 0);\nivec2 expBit = ivec2(8, 3);\nivec2 fracBit1 = ivec2(15, 3);\nivec2 fracBit2 = ivec2(23, 3);\nivec2 fracBit3 = ivec2(31, 3);\nivec2 floatBit = ivec2(31, 5);\n\nvec2 getBitCoord(vec2 fragCoord, vec2 bitSize, out float index)\n{\n    vec2 offset = fragCoord;\n    index = clamp(floor(offset.x / bitSize.x) + 16.0f, 0.0f, 31.0f);\n    return offset - vec2((index - 16.0f) * bitSize.x, -0.5f * bitSize.y);\n}\n","name":"Common","description":"","type":"common"}]}