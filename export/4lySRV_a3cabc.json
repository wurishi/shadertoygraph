{"ver":"0.1","info":{"id":"4lySRV","date":"1484901976","viewed":141,"name":"Moving Colors jittered","username":"hornet","description":"random-sampled version of https://www.shadertoy.com/view/ltXXz2","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["jitter"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n#define SPEED 0.5\n#define NB_SHAPES 6.0\n\n#define TRAIL_DUR 0.35\n#define NB_REPEAT 16.0\n\n//#define TRAIL_MODE\n\n#define DRAW_CIRCLES\n// AND / OR\n#define DRAW_LINES\n\n\n#define LINE_THICKNESS 0.0025\n#define LINE_SHINE 0.01\n\nfloat sqrLen(vec2 vec)\n{\n\treturn dot(vec, vec);  \n}\n\nvec2 pixelToNormalizedspace(vec2 pixel)\n{\n    vec2 res;\n    res.x = pixel.x * 2.0 / iResolution.x - 1.0;\n    res.y = pixel.y * 2.0 / iResolution.y - 1.0;\n    res.y *= iResolution.y / iResolution.x;//correct aspect ratio\n    return res;\n}\n\nvec2 rotate(vec2 pos, float angle)\n{\n    float rad = radians(angle);\n \tmat2 rotM = mat2(vec2(cos(rad), -sin(rad)), vec2(sin(rad), cos(rad)));    \n    return rotM * pos;\n}\n\nfloat circle(vec2 diff, float radius){\n    return abs(length(diff) - radius);\n}\n\nfloat segment(vec2 diff, vec2 dir, vec2 dim)\n{\n    float projDist \t= dot(diff, dir);\n\tfloat dist = 0.0;\n\n    dist += length(diff - dir * dim.x) * step(dim.x, projDist);\n    dist += length(diff) * (1.0 - step(0.0, projDist));\n    dist += length(diff - dir * projDist) * (step(0.0, projDist) - step(dim.x, projDist));\n    return dist - dim.y;\n}\n\nfloat colorStrength(float dist){\n \t   return 1.0 - smoothstep(LINE_THICKNESS - LINE_SHINE,\n                               LINE_THICKNESS + LINE_SHINE,\n                               dist);\n}\n\nfloat hash(in ivec2 c)\n{\n  int x = 0x3504f333*c.x*c.x + c.y;\n  int y = 0xf1bbcdcb*c.y*c.y + c.x;\n    \n  return float(x*y)*(2.0/8589934592.0)+0.5;\n}\nfloat hash( in vec2 c ) { return hash( ivec2(1337.1*c) ); }\n\nvec3 draw(vec2 pos, float in_time, float prev_time, float rnd)\n{ \n    vec3 col \t\t= vec3(0.0);    \n    float colorStr \t= 0.0;    \n    float colTime \t= 0.0;\n\n    float time = prev_time + rnd * (in_time - prev_time);\n    \n#ifdef DRAW_CIRCLES\n    vec2 circlePos = vec2(0.0);\n    circlePos.x += cos(time) - cos(time * 5.0) * 0.5 - sin(time * 15.0) * 0.1;\n    circlePos.y += sin(time) - sin(time * 3.0) * 0.5 + cos(time * 10.0) * 0.3;\n    circlePos \t*= 0.3; \n    float dist = 0.05 + sqrLen(circlePos - vec2(0.5, 0.5)) * 0.1;\n#endif\n    \n#ifdef DRAW_LINES    \n    vec2 lineEnd = vec2(0.0);\n  \tlineEnd.x += (sin(time) * 0.5 - cos(time * 2.0)) * sin(time * 0.5);\n    lineEnd.y += (cos(time) * 0.5 - sin(time * 2.0)) * sin(time * 0.5);\n    lineEnd *= 0.3;    \n    vec2 lineStart = vec2(0.0);\n    lineStart.x -= (sin(time) * 0.5 + cos(time * 2.0)) * cos(time * 0.4);\n    lineStart.y -= (cos(time) * 0.5 + sin(time * 2.0)) * cos(time * 0.4);\n#endif             \n    \n    for(float a = 0.0; a < 359.0; a += 360.0 / NB_SHAPES)\n    {\n        colorStr = 0.0;\n        colTime = time + 1.0 * a / 360.0;        \n    \tvec2 rotPos = rotate(pos, a);\n        \n\t#ifdef DRAW_CIRCLES        \n        colorStr += colorStrength(circle(rotPos - circlePos, dist));\n\t#endif \n        \n\t#ifdef DRAW_LINES        \n        vec2 seg = lineEnd - lineStart;\n        colorStr += colorStrength(segment(rotPos - lineStart,\n                                          normalize(seg),\n                                          vec2(length(seg), LINE_THICKNESS)));        \n\t#endif                \n        col += vec3(0.5 + 0.5 * cos(colTime * 5.0),\n                    0.5 + 0.5 * cos(colTime * 5.0 + 3.14),\n                    0.5 + 0.5 * sin(colTime * 5.0)) * colorStr;\n    }\n       \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float startTime = iTime - iMouse.x / iResolution.x * 5.0;\n    float time = 0.0;\n    vec2 fragPos = pixelToNormalizedspace(fragCoord);\n\tvec2 uv = fragCoord.xy / iResolution.xy;        \n    \n    vec3 finalCol = vec3(0.0);\n\n    //float rnd = hash( fragPos + fract(iTime) );\n    float rnd = texelFetch( iChannel0, ivec2( ivec2(fragCoord)%textureSize(iChannel0,0).xy), 0 ).r;\n    //fragColor = vec4( vec3(rnd), 1.0 ); return;\n    \n    float scale = 1.0;\n    \n    float sumw = 0.0;\n    float prev_time = startTime * SPEED;\n    for(float rep = 0.0; rep < NB_REPEAT; ++rep)\n    {\n        time = (startTime - rep * TRAIL_DUR/NB_REPEAT) * SPEED;\n        float w = pow(1.0 - rep / NB_REPEAT, 2.0);\n        sumw += w;\n        finalCol += draw(fragPos, time, prev_time, rnd) * w;\n        #ifndef TRAIL_MODE\n        scale *= 1.0 + TRAIL_DUR / NB_REPEAT;\n        #endif\n        prev_time = time;\n    }\n    finalCol /= sumw;\n    finalCol *= 7.0;\n    \n\tfragColor = vec4(finalCol, 1.0);\n    fragColor = pow( fragColor, vec4(1.0/2.2));\n}\n","name":"Image","description":"","type":"image"}]}