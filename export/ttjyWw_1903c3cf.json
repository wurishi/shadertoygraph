{"ver":"0.1","info":{"id":"ttjyWw","date":"1594578008","viewed":204,"name":"Triangles v.3","username":"julianlumia","description":"experiment w feedback instead of real motion blur to improve frame-rate","likes":10,"published":1,"flags":32,"usePreview":0,"tags":["mograph"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define T(uv) texture(iChannel0,uv)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 uv = (fragCoord/iResolution.xy);\n    float f = length(uv  - .6);\n    fragColor.x = T(uv + f*0.01).x;\n    fragColor.y = T(uv -f*0.01).y;\n    fragColor.z = T(uv-f*0.01).z;\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// OG code adapted from: day 104 by Jeyko\n// https://www.shadertoy.com/view/WdlcDX\n\n#define pi acos(-1.)\n#define rot(x) mat2(cos(x),-sin(x),sin(x),cos(x))\n\n\nfloat map(float a, float b, float c, float d, float t) {\nreturn ((t-a)/(b-a))*(d-c)+c;\n}\n\n\nfloat ease(float p, float g) {  \n    if(p < 0.){\n        return 0.;\n    } else if(p > 1.){\n    return 1.;\n    } else {\n      if (p < 0.5) \n        return 0.5 * pow(2.*p, g);\n      else\n        return 1. - 0.5 * pow(2.*(1. - p), g);\n    }\n}\n\nfloat sdEquilateralTriangle(  vec2 p, float s ){\n    const float k = sqrt(3.0);\n    p.x = abs(p.x) - s;\n    p.y = p.y + s/k;\n    if( p.x+k*p.y>0.0 ) p = vec2(p.x-k*p.y,-k*p.x-p.y)/2.0;\n    p.x -= clamp( p.x, -2.0, 0.0 );\n    float d = -length(p)*sign(p.y); \n    d = abs(d) - 0.0025;\n    return d;\n}\nconst float speed = 2.5;\nfloat[] scenes = float[4](1.*speed,1.*speed,1.5*speed,1.*speed); \n\n\nvec3 get( vec2 uv, float t  ){   \n    uv *= 1.2;\n    float col = 0.;\n    float d = 10e6;\n    float d2;    \n\tt = mod(t, scenes[0] + scenes[1]+ scenes[2]+ scenes[3]); \n  \n    if(t < scenes[0]){\n        float lsp = 2.;\n        float env = ease(t/scenes[0]*lsp,2.5);  \n        uv *= rot(env*pi*1./3.); \n        d = min(d,  sdEquilateralTriangle( uv*-1.,  0.5 ));\n        lsp = 1.;\n        env = ease(t/scenes[0]*lsp,5.);  \n        uv *= rot(env*pi*4./3.);\n\t\tuv.x /= (env*pi*1./pi);\n        d2 = min(d2,  sdEquilateralTriangle( uv,  .25 ));     \n    }\n    \n\telse if(t < scenes[1] + scenes[0]){\n         t -= scenes[1];\n   \t\t float lsp = 1.;\n        float env = ease(t/scenes[0]*lsp,2.5);  \n        uv *= rot(env*pi*1./3.);\n        d = min(d,  sdEquilateralTriangle( uv*-1.,  .25 ));\n        lsp = 1.;\n        env = ease(t/scenes[0]*lsp,5.);  \n        uv *= rot(env*pi*4./3.);\n        d2 = min(d2,  sdEquilateralTriangle( uv,  0.5 ));    \n        uv.x /= (env*pi*1./pi);\n        d2 = min(d2,  sdEquilateralTriangle( uv,  0.12 ));       \n    }\n    \n    else if(t < scenes[1] + scenes[0] + scenes[2]){\n        t -= scenes[0] + scenes[1];\n  \t    float lsp = 1.;\n        float env = ease(t/scenes[0]*lsp,2.5);  \n   \t\tfloat map1 = map(0.9,.0,2.5,.45,env);\n        float map2 = map(0.9,.0,.0,.45,env);\n        uv *= rot(env*pi*10./3.);\n        d = min(d,  sdEquilateralTriangle(-uv*1.,  map1 ));\n        uv *= rot(env*pi*-4./3.);\n        d2 = min(d2*1.,  sdEquilateralTriangle( -uv*-1.,  -0.23+map2 ));     \n\t\td2 = min(d2,  sdEquilateralTriangle( -uv,  -0.34+map2 )); \n      }\n    \n   else if(t < scenes[1] + scenes[0] + scenes[2]+ scenes[3]){\n   \t\tt -= scenes[0] + scenes[1]+ scenes[2];\n    \tfloat lsp = 1.;\n    \tfloat env = ease(t/scenes[0]*lsp,2.5);  \n   \t\tfloat map1 = map(0.,1.,0.,.5,env);\n    \tuv *= rot(env*pi*10./3.);\n    \td = min(d,  sdEquilateralTriangle( -uv*1.,  map1 ));\n      }\n   d = min(d,d2);\n   return vec3(-d);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;  \n    vec2 uv2= fragCoord.xy/iResolution.xy;\n    vec3 col = vec3(0);\n    col = smoothstep(0.,.00001,get(uv,iTime));\n    col/=float(0.3);\n    col *= 10. - pow(smoothstep(0.,1.,dot(uv,uv)*1.),1.5);\n    col += 2.-texture(iChannel2, uv2).xyz* 1. ;           \n\tcol *= 2.;\n    fragColor = vec4(col,1.0);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"//slide\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n vec2 uv = fragCoord.xy/iResolution.xy;\n float sup = 150.;\n float sdown =1.;\n vec4 in1 = texture(iChannel0, uv);\n vec4 in2 = texture(iChannel1, uv);\n vec4 sld = vec4(1.0 / sdown);\n vec4 slu = vec4(1.0 / sup);\n vec4 down = in1 + ((in2 - in1) * sld);\n vec4 up = in1 + ((in2 - in1) * slu);\n fragColor = mix(down, up, 1.);    \n}","name":"Buffer B","description":"","type":"buffer"}]}