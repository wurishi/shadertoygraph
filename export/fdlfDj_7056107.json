{"ver":"0.1","info":{"id":"fdlfDj","date":"1648066029","viewed":76,"name":"NoobMarch","username":"mAmaro","description":"W Up\nS  Down\nA Lefta\nD Right\nQ Down\n\nRESOURCES\nhttps://www.scratchapixel.com/lessons/mathematics-physics-for-computer-graphics/mathematics-of-shading\nhttps://www.scratchapixel.com/lessons/3d-basic-rendering/minimal-ray-tracer-rendering-simple-shapes\n\nE Up","likes":0,"published":1,"flags":48,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI  3.1415926535\n#define MAX_STEPS 100\n#define MAX_DIST 100.0\n#define SURFACE_DIST 0.01\n\nvoid mainImage( out vec4 glFragColor, in vec2 glFragCoord )\n{\n    vec2 uv = (2.0*glFragCoord-iResolution.xy)/iResolution.y;\n    vec3 col = vec3(uv, 1.);\n    \n    vec3 ro = vec3(0.0,0.0,-1.8);\n    vec3 rd = vec3();\n    \n\n    glFragColor = vec4(col,1.0);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define KEY_W (87)\n#define KEY_A (65)\n#define KEY_S (83)\n#define KEY_D (68)\n#define KEY_Q (81)\n#define KEY_E (69)\n\nconst int\nKeyLe=37,KeyUp=38,KeyRi=39,KeyDn=40,\nKeyA=65,KeyB =66,KeyC =67,KeyD =68,\nKeyE=69,KeyF=70,KeyG=71,KeyH=72,\nKeyI=73,KeyJ=74,KeyK=75,KeyL=76,\nKeyM=77,KeyN=78,KeyO=79,KeyP=80,\nKeyQ=81,KeyR=82,KeyS=83,KeyT=84,\nKeyU=85,KeyV=86,KeyW=87,KeyX=88,\nKeyY=89,KeyZ=90;\n\n// Get Key Codes With This:\n//https://keycode.info/\n\n// References on saving state in shadertoy\n//https://www.shadertoy.com/view/4dGyDm\n//https://www.shadertoy.com/view/4st3WS\n//https://www.shadertoy.com/view/tdGBDG\n\n//State function in Common[^]\n\nbool IsKeyDown(int KeyIndex)\n{\n    float KeyValue = texelFetch(iChannel0, ivec2(KeyIndex, 0), 0).x;\n    return (KeyValue > 0.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 Pos = vec3(1.0);\n\n    if(iFrame == 0)\n    {\n        Pos = vec3(0.0, 1.0, -10.0);\n    }\n    else\n    {\n        if(false)\n        {}\n        else if(ShaderAtStateIndex(PositionIndex, fragCoord))\n        {\n            bool KeyDown[4];\n\n            Pos = GetState(State, PositionIndex).xyz;\n            float Speed = 0.1;\n            //FOWARD BACKWARD\n            if(IsKeyDown(KEY_W))\n            { Pos.z += Speed; }\n\n            if(IsKeyDown(KEY_S))\n            { Pos.z -= Speed;}\n            \n            //LEFT RIGHT\n            if(IsKeyDown(KEY_A))\n            { Pos.x -= Speed;}\n\n            if(IsKeyDown(KEY_D))\n            { Pos.x += Speed;}\n            \n            //UP DOWN\n            if(IsKeyDown(KEY_Q))\n            { Pos.y -= Speed;}\n\n            if(IsKeyDown(KEY_E))\n            { Pos.y += Speed;}   \n        }\n        else if(ShaderAtStateIndex(EulerIndex, fragCoord))\n        {\n            //No point in this...\n            //Maybe i wanted to have a drag effect\n        }\n    }\n    \n    fragColor = vec4(Pos, 0.0);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define State (iChannel1)\n\n#define GetState(State, Index) (texelFetch(State, Index, 0))\n/*TODO: find out how to store spherer state in bufferB\nvoid GetStateElement(State, Index, ElementId, Stride)\n{\n    //check if im within bound of the buffer\n    //will bounds be different on resize???\n    ....\n    // collision logic in bufferB shader???\n    \n    //strid:pos vel radius ... i think...\n    if(Index)\n    texelFetch(State, Index, 0);\n}\n*/\n#define ShaderAtStateIndex(Index, FragCoord) (Index == ivec2(FragCoord))\n\n#define PositionIndex (ivec2(0, 0))\n#define EulerIndex   (ivec2(1, 0))\n#define SphereAreaIndex   (ivec2(0, 1))\n#","name":"Common","description":"","type":"common"},{"inputs":[],"outputs":[{"id":"XsXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0,0.0,1.0,1.0);\n}","name":"Buffer B","description":"","type":"buffer"}]}