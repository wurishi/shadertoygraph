{"ver":"0.1","info":{"id":"WlKyDt","date":"1612302213","viewed":67,"name":"All Up in There (vlllll)","username":"valalalalala","description":"I'd been wanting to make a tunnel demo for a while and stumbled onto an organic shape that pairs nicely with the natural look of the voronoi. ","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["tunnel"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"        /////////////////////////////////////////////////////////////////\n       //                                                            ////\n      //  \"All Up in There\"                                         // //\n     //                                                            //  //\n    //  I'd been wanting to make a tunnel demo for a while and    //   //\n   //  stumbled onto an organic shape that pairs nicely with     //    //\n  //  the natural look of the voronoi.                          //    //\n //                                                            //     //\n////////////////////////////////////////////////////////////////     //\n//                                                            //    //\n// Creative Commons Attribution-NonCommercial-ShareAlike      //   //\n// 3.0 Unported License                                       //  //\n//                                                            // //\n// by Val \"valalalalala\" GvM ðŸ’ƒ 2021                          ////\n//                                                            ///\n////////////////////////////////////////////////////////////////\n\n\n///////////////////////////////////////////////////////////////////\n// scene controls\n\n////////////////////////////////////////////////////////////////\n// handy constants\n\n#define ZED   .0\n#define TAU   6.283185307179586\n\n////////////////////////////////////////////////////////////////\n// ray marching\n\n#define STEPS 55\n#define CLOSE .001\n#define FAR   55.\n#define EPZ   vec2( ZED, CLOSE )\n\n////////////////////////////////////////////////////////////////\n\n#define FROM_SCREEN(uv)  ( ( 2. * uv - iResolution.xy ) / iResolution.y )\n\n#define TRIG(a)    vec2( cos( a  * TAU ), sin( a * TAU ) )\n#define MIN3(v)    min( v.x, min( v.y, v.z ) )\n#define MAX3(v)    max( v.x, max( v.y, v.z ) )\n#define SUM3(v)    ( v.x + v.y + v.z )\n#define AVG3(v)    ( SUM3(v)/3. )\n#define SUM2(v)    ( v.x + v.y )\n#define MODO(v,f)  ( mod( v + .5 * f, f ) - .5 * f )\n#define RGB        vec3\n\n////////////////////////////////////////////////////////////////\n\nfloat getDistance( vec3 p, vec3 a ) {\n    p.x/=.66;\n    float n = noise( p.xy );\n    \n    p.z += n * 4.4;\n    vec2 t = TRIG( p.z );\n    vec2 c = TRIG( p.z * .33 ) * .33;\n    float r = SUM2( abs( t ) ) * .1 + .33;\n    float cylinder = length( p.xy - c ) - r;\n    float tunnel = -cylinder;\n    \n    float fudge = .7;\n    return tunnel * fudge;\n}\n\n////////////////////////////////////////////////////////////////\n\nfloat march( vec3 a, vec3 ab ) {\n    float d = .0;\n    for ( int i = 0 ; i < STEPS ; i++ ) {\n        vec3 b = a + d * ab;\n        float n = getDistance( b, a );\n        d += n;\n        if ( abs( n ) < CLOSE || d > FAR ) break;\n    }\n    return d;\n}\n\nvec3 getDistances( vec3 a, vec3 b, vec3 c, vec3 q ) {\n    return vec3( getDistance( a,q ), getDistance( b,q ), getDistance( c,q ) );\n}\n\nvec3 getNormal( vec3 p,vec3 a ) {\n    return normalize( getDistance( p, a ) - \n        getDistances( p - EPZ.yxx, p - EPZ.xyx, p - EPZ.xxy, a )\n    );\n}\n\n////////////////////////////////////////////////////////////////\n\n// zab,xZup,yXz | zxy:ab,zup,xz\nmat3 makeCamera( vec3 a, vec3 b, float roll ) {\n    vec3 up = vec3( TRIG( roll ).yx, ZED );\n\tvec3 z = normalize( b - a );\n\tvec3 x = normalize( cross( z, up ) );\n\tvec3 y = normalize( cross( x, z ) );\n\treturn mat3( x, y, z );\n}\n\n////////////////////////////////////////////////////////////////\n\nfloat checked( vec2 uv, float scale ) {\n    vec2 st = floor( uv * scale );\n    return mod( st.x + st.y, 2. );\n}\n\nvec3 texaco( vec2 uv ) {\n    return mix( vec3( .7, .7, .9 ), vec3( .9, .9, .7 ), checked( uv, 33. ) );\n}\n\n\n#define SALMON_PINK     RGB( 1.0, .55, .60 )\n#define BRINK_PINK      RGB( 1.0, .34, .45 )\n#define HOT_PINK        RGB( 1.0, .40, .70 )\n#define BUBBLEGUM_PINK  RGB( 1.0, .80, .80 )\n#define RUDDY_PINK      RGB( .83, .57, .57 )\n            \nvec3 colorHit( vec3 p, vec3 a ) {\n    vec3 n = getNormal( p, a );\n    \n    vec3 q = abs( n );\n    \n    float l1 = pow( min( q.x, q.y ), .02 );\n    float l2 = pow( MAX3( q ), .44 );\n    float l3 = .2 + pow( MIN3( q ), .11 );\n    vec3 light = vec3( l1, l2, l3 ) * normalize( vec3( .3, .8, .5 ) ) * .77;\n    float l = SUM3( light );\n\n    ////\n    \n    #if 0\n        n = pow( abs(n), vec3( 4. ) );\n        n /= SUM3( n ); // pseudo normalize\n    \n        vec3 tX = texaco( MAP_11_01( p.yz ) );\n        vec3 tY = texaco( MAP_11_01( p.xz ) );\n        vec3 tZ = texaco( MAP_11_01( p.xy ) );\n        vec3 color = ( n.x * tX + n.y * tY + n.z * tZ );\n    #else\n        vec3 color = voronoi( p * 2.77,  iTime );\n        float m = 1. * ( cos( iTime * .66 ) * .5 + .5 );\n        color = mix(\n            BRINK_PINK,\n            SALMON_PINK,\n            pow( MIN3( color ) / 3.3, m )\n        );\n    #endif\n\n    return l * color;\n}\n\nvec3 colorMiss( in vec2 uv ) {\n    return .4 * texaco( MAP_11_01( uv * .5 ) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = FROM_SCREEN( fragCoord );\n    float view = 4.;\n    float zoom = 2.;\n    \n    ////////////////////////////////////////////////////////////////\n    \n    bool mouseDown = iMouse.z > .0;\n    float roll = mouseDown ? .0 : 2.2 * cos( iTime * .11 );\n    \n    vec2 ms =  iMouse.xy / iResolution.xy * 1. - .5;\n    \n    vec2 t = view * TRIG( ms.x );\n    float by = view * sin( TAU * ms.y * .66 );\n    \n    vec3 a = vec3( .0, .0, iTime  );\n    vec3 b = a + vec3( -t.y, by, t.x );      \n    \n    vec3 ab = normalize( makeCamera( a, b, roll ) * vec3( uv, zoom ) );\n    \n    ////////////////////////////////////////////////////////////////\n\n    float d = march( a, ab );\n    float hit = step( d, FAR );\n\n    vec3 p = hit * ( a + ab * d );\n    \n    ////////////////////////////////////////////////////////////////\n    \n    vec3 color = mix( colorMiss( uv ), colorHit( p, a ), hit );\n    \n    ////////////////////////////////////////////////////////////////\n    \n    float diz = d / FAR;\n    float foginess = pow( diz, .233 ) * hit;\n    vec3 fog = vec3( .22, .22, .4 );\n    color = mix( color, fog, foginess );\n    color *= 1.-pow(diz,.33);\n\n    #if 0\n    color = digitIn( color, uv - vec2(.8,.8), 44., ms.x );\n    color = digitIn( color, uv - vec2(.8,.6), 44., ms.y );\n    #endif\n    \n    ////////////////////////////////////////////////////////////////\n    \n    fragColor = vec4( color, 1. );\n}\n\n// EOF\n////////////////////////////////////////////////////////////////","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"        /////////////////////////////////////////////////////////////////\n       //                                                            ////\n      //  \"All Up in There\"                                         // //\n     //                                                            //  //\n    //  I'd been wanting to make a tunnel demo for a while and    //   //\n   //  stumbled onto an organic shape that pairs nicely with     //    //\n  //  the natural look of the voronoi.                          //    //\n //                                                            //     //\n////////////////////////////////////////////////////////////////     //\n//                                                            //    //\n// Creative Commons Attribution-NonCommercial-ShareAlike      //   //\n// 3.0 Unported License                                       //  //\n//                                                            // //\n// by Val \"valalalalala\" GvM ðŸ’ƒ 2021                          ////\n//                                                            ///\n////////////////////////////////////////////////////////////////\n\nvec2 hash22( in vec2 uv ) {\n    vec3 q = fract( uv.xyx * vec3( 19.191, 53.733, 73.761 ) );\n    q += dot( q, q + vec3( 41.557, 23.929, 37.983 ) );\n    return fract( vec2( q.x * q.y, q.y * q.z ) );\n}\n\nvec2 hash( vec2 x ) {  return hash22( x );}\n\n// iq\n\n\nfloat noise( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n\tvec2 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( dot( hash( i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ), \n                     dot( hash( i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\n                mix( dot( hash( i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ), \n                     dot( hash( i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);\n}\n\n/////\n\n// from my https://www.shadertoy.com/view/wtKcRy\n// alternative distance metrics\n\n#define MANHATTAN\n#define DOTTY_\n\n// alternative voronoi combinations\n#define FBM_\n#define IFBM_\n\n// for some reason... mix isn't working for me...\n#define MIX(x,y,a)   ((1.-a) * x + y * a)\n#define MIX2(x,y,a)  mix(x,y,a)\n#define USE_MIX_INSTEAD_OF_IFS_NOT\n\n////////////////////////////////////////////////////////////////\n\n#define MAP_11_01(v)     ( v * .5 + .5 )\n\n////////////////////////////////////////////////////////////////\n// functions \n\n\nvec4 makeVoronoiPoint( in vec2 id, float time ) {\n    vec2 n = hash22( id ) ;\n    vec2 point = sin( n * time ) * .5 + .5;\n    return vec4( point.xy, n.xy );\n}\n\nfloat voronoiDistanceMetric( in vec2 st ) {\n    #ifdef MANHATTAN\n    return abs( st.x ) + abs( st.y );\n    #endif\n    \n    #ifdef DOTTY\n    st = abs( st );\n    return dot( st, st ) / ( st.x + st.y );\n    #endif\n   \n    return length( st );\n}\n\nvec3 calculateVoronoiDistance( in vec2 st, in vec2 id, in vec2 neighbor, float time ) {\n    vec4 voronoiPoint = makeVoronoiPoint( id + neighbor, time );\n    st -= voronoiPoint.xy + neighbor;\n    \n    float d = voronoiDistanceMetric( st );\n\n    return vec3( d, voronoiPoint.xy );\n    return vec3( d, id );\n}\n\nvec3 calculateVoronoiPoint( in vec2 st, in vec2 id, float time ) {\n    vec3 voronoi_n1_n1 = calculateVoronoiDistance( st, id, vec2( -1., -1. ), time );\n    vec3 voronoi_n1_n0 = calculateVoronoiDistance( st, id, vec2( -1., -0. ), time );\n    vec3 voronoi_n1_p1 = calculateVoronoiDistance( st, id, vec2( -1., +1. ), time );\n    vec3 voronoi_n0_n1 = calculateVoronoiDistance( st, id, vec2( -0., -1. ), time );\n    vec3 voronoi_n0_n0 = calculateVoronoiDistance( st, id, vec2( -0., -0. ), time );\n    vec3 voronoi_n0_p1 = calculateVoronoiDistance( st, id, vec2( -0., +1. ), time );\n    vec3 voronoi_p1_n1 = calculateVoronoiDistance( st, id, vec2( +1., -1. ), time );\n    vec3 voronoi_p1_n0 = calculateVoronoiDistance( st, id, vec2( +1., -0. ), time );\n    vec3 voronoi_p1_p1 = calculateVoronoiDistance( st, id, vec2( +1., +1. ), time );\n\n    vec3 closest = vec3( 1e33 );\n#ifdef USE_MIX_INSTEAD_OF_IFS\n    closest = MIX( closest, voronoi_n1_n1, step( voronoi_n1_n1.x, closest.x ) );\n    closest = MIX( closest, voronoi_n1_n0, step( voronoi_n1_n0.x, closest.x ) );\n    closest = MIX( closest, voronoi_n1_p1, step( voronoi_n1_p1.x, closest.x ) );\n    closest = MIX( closest, voronoi_n0_n1, step( voronoi_n0_n1.x, closest.x ) );\n    closest = MIX( closest, voronoi_n0_n0, step( voronoi_n0_n0.x, closest.x ) );\n    closest = MIX( closest, voronoi_n0_p1, step( voronoi_n0_p1.x, closest.x ) );\n    closest = MIX( closest, voronoi_p1_n1, step( voronoi_p1_n1.x, closest.x ) );\n    closest = MIX( closest, voronoi_p1_n0, step( voronoi_p1_n0.x, closest.x ) );\n    closest = MIX( closest, voronoi_p1_p1, step( voronoi_p1_p1.x, closest.x ) );\n#else\n    if ( voronoi_n1_n1.x < closest.x ) closest = voronoi_n1_n1;\n    if ( voronoi_n1_n0.x < closest.x ) closest = voronoi_n1_n0;\n    if ( voronoi_n1_p1.x < closest.x ) closest = voronoi_n1_p1;\n    if ( voronoi_n0_n1.x < closest.x ) closest = voronoi_n0_n1;\n    if ( voronoi_n0_n0.x < closest.x ) closest = voronoi_n0_n0;\n    if ( voronoi_n0_p1.x < closest.x ) closest = voronoi_n0_p1;\n    if ( voronoi_p1_n1.x < closest.x ) closest = voronoi_p1_n1;\n    if ( voronoi_p1_n0.x < closest.x ) closest = voronoi_p1_n0;\n    if ( voronoi_p1_p1.x < closest.x ) closest = voronoi_p1_p1;\n#endif\n    return closest;\n}\n\nfloat vornoing( in vec2 uv, float scale, float time ) {\n    uv *= scale;\n    \n    vec2 st = fract( uv );\n    vec2 id = uv - st;\n\n    vec3 closest = calculateVoronoiPoint( st, id, time );\n    return closest.x;\n}\n\nfloat voronoi( vec2 uv, float time ) {\n    float s = 1.;\n    #ifdef FBM\n    return .0\n        + .1 * vornoing( uv + 33. * s,  1., time )\n        + .2 * vornoing( uv + 17. * s,  3., time )\n        + .3 * vornoing( uv +  9. * s,  7., time )\n        + .4 * vornoing( uv +  5. * s, 13., time )\n    ;\n    #endif\n\n    #ifdef IFBM\n    return .0\n        + .4 * vornoing( uv + 33. * s,  1., time )\n        + .3 * vornoing( uv + 17. * s,  3., time )\n        + .2 * vornoing( uv +  9. * s,  7., time )\n        + .1 * vornoing( uv +  5. * s, 13., time )\n    ;\n    #endif\n\n    return vornoing( uv, 7., time );\n}\n\nvec3 voronoi( vec3 p, float time ) {\n    return vec3(\n        voronoi( MAP_11_01( p.yz ), time ),\n        voronoi( MAP_11_01( p.zx ), time ),\n        voronoi( MAP_11_01( p.xy ), time )\n    );\n}\n\n////\n\n#if 1\n\nconst int CHARACTERS[14] = int[14](31599,9362,31183,31207,23524,29671,29679,30994,31727,31719,1488,448,2,3640);\n\nfloat digitIsOn( int digit, vec2 id ) {   \n    if ( id.x < .0 || id.y < .0 || id.x > 2. || id.y > 4. ) return .0;\n    return floor( mod( float( CHARACTERS[ int( digit ) ] ) / pow( 2., id.x + id.y * 3. ), 2. ) );\n}\n\nfloat digitSign( float v, vec2 id ) {\n    return digitIsOn( 10 - int( ( sign( v ) - 1. ) * .5 ), id );\n}\n\nint digitCount( float v ) {\n    return int( floor( log( max( v, 1. ) ) / log( 10. ) ) );\n}\n\nfloat digitFirst( vec2 uv, float scale, float v, int decimalPlaces ) {\n    vec2 id = floor( uv * scale );\n\n    if ( .0 < digitSign( v, id ) ) return 1.;\n    v = abs( v );\n    \n    int digits = digitCount( v );\n    float power = pow( 10., float( digits ) );\n    \n    float offset = floor( .1 * scale );\n    id.x -= offset;\n    \n    float n;\n    for ( int i = 0 ; i < 33 ; i++, id.x -= offset, v -= power * n, power /= 10. ) {\n        n = floor( v / power );\n        if ( .0 < digitIsOn( int( n ), id ) ) return 1.;   \n        if ( i == digits ) {\n            id.x -= offset;\n            if ( .0 < digitIsOn( int( 12 ), id ) ) return 1.;\n        }  \n        if ( i >= digits + decimalPlaces ) return .0;    \n    }  \n    return .0;\n}\n\nfloat digitFirst( vec2 uv, float scale, float v ) {\n    return digitFirst( uv, scale, v, 3 );\n}\n\nvec3 digitIn( vec3 color, vec3 fontColor, vec2 uv, float scale, float v ) {\n    float f = digitFirst( uv, scale, v );\n    return mix( color, fontColor, f );\n}\n\nvec3 digitIn( vec3 color, vec2 uv, float scale, float v ) {\n    return digitIn( color, vec3(1.), uv, scale, v );\n}\n\n#endif","name":"Common","description":"","type":"common"}]}