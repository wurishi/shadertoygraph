{"ver":"0.1","info":{"id":"wdB3zz","date":"1547952486","viewed":129,"name":"evankh_RayMarcher","username":"evankh","description":"A ray marching renderer using a distance estimator function. Code is pretty messy right now as I'm trying out some new stuff.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14159265\n\n// Light parameters\nconst vec3 lightPos = vec3(2.0, 3.0, 4.0);\n\n// Scene parameters\n// Infinite grid\nfloat dx = 4.0;\t\t// Distance between objects on the x-axis\nfloat dy = 4.0;\t\t// Distance between objects on the y-axis\n// Distorted spheres\nfloat sphereRadius = 0.5;\t// Radius of each sphere\nfloat wiggleAmplitude = 0.25;\t// Amount of the spiral distortion\nfloat wiggleFrequency = 3.0 * radians(360.0);\t// Number of turns of the spiral distortion\n// Torus\nfloat torusRadiusMajor = 1.0;\t// Major radius of the torus\nfloat torusRadiusMinor = 0.5;\t// Minor radius of the torus\nconst vec3 torusNormal = normalize(vec3(0.0, 0.0, 1.0));\t// Vector normal to the plane in which the torus lies\nconst vec3 torusX = normalize(cross(torusNormal, vec3(-torusNormal.y, torusNormal.zx)));\t// Basis vector of the plane of the torus, pointing in an arbitrary direction\nconst vec3 torusY = cross(torusNormal, torusX);\t// Other basis vector of the plane in which the torus lies, pointing in an arbitrary direction\n// Ripply plane\nfloat rippleAmplitude = 0.25;\t// Amount of distortion in the plane\nfloat rippleX = 0.5;\t// Frequency of bumps on the plane in the x-axis\nfloat rippleY = 0.5;\t// Frequency of bumps on the plane in the y-axis\n\n// Distance estimator function\n// Calculates the shortest distance to any geometry in the scene\nfloat distanceFunc(vec3 p) {\n    // Infinite grid\n    //*\n\tif (abs(p.z) > 2.0)\t// So we can make large jumps and avoid expensive calculations in the region where we know we won't hit anything\n        return abs(p.z) - 1.5;\n\tp.x = mod(p.x + 0.5*dx, dx) - 0.5*dx;\n    p.y = mod(p.y + 0.5*dy, dy) - 0.5*dy;\n\t//*/\n    \n    // Distorted spheres\n    /*\n    p.x += wiggleAmplitude * cos(wiggleFrequency * p.z);\n    p.y += wiggleAmplitude * sin(wiggleFrequency * p.z);\n    return length(p) - sphereRadius;\n\t//*/\n    \n    // Oscillating torus-ish\n    /*\n\tvec3 norm = normalize(vec3(sin(iTime), cos(iTime), 1.0));\n    return -distance(p, torusRadiusMajor * normalize(p * (1.0 - norm))) - torusRadiusMinor;\n\t//*/\n    \n    // Torus\n    //*\n    // Project the point into the plane of the torus\n    vec3 proj = torusX * dot(p, torusX) + torusY * dot(p, torusY);\n\t// Fix the rare discontinuity at the exact center of the torus\n    if (proj == vec3(0.0)) return torusRadiusMajor - torusRadiusMinor;\n    float dist = -(distance(p, torusRadiusMajor * normalize(proj)) - torusRadiusMinor);\n    // Silly Spheres\n    //*\n    dist = min(dist,  distance(p, vec3( 0.6, 0.0, 0.0)) - 0.2);\n    dist = min(dist,  distance(p, vec3( 0.0, 0.6, 0.0)) - 0.2);\n    dist = min(dist,  distance(p, vec3(-0.6, 0.0, 0.0)) - 0.2);\n    dist = min(dist,  distance(p, vec3( 0.0,-0.6, 0.0)) - 0.2);\n    dist = min(dist,  distance(p, vec3( 1.0, 0.0, 0.4)) - 0.2);\n    dist = min(dist,  distance(p, vec3( 0.0, 1.0, 0.4)) - 0.2);\n    dist = min(dist,  distance(p, vec3(-1.0, 0.0, 0.4)) - 0.2);\n    dist = min(dist,  distance(p, vec3( 0.0,-1.0, 0.4)) - 0.2);\n    dist = min(dist,  distance(p, vec3( 1.0, 0.0,-0.4)) - 0.2);\n    dist = min(dist,  distance(p, vec3( 0.0, 1.0,-0.4)) - 0.2);\n    dist = min(dist,  distance(p, vec3(-1.0, 0.0,-0.4)) - 0.2);\n    dist = min(dist,  distance(p, vec3( 0.0,-1.0,-0.4)) - 0.2);\n    //*/\n    // Cavities\n    //*\n    dist = max(dist, -distance(p, vec3( 0.8, 0.0, 0.0)) + 0.1);\n    dist = max(dist, -distance(p, vec3( 0.0, 0.8, 0.0)) + 0.1);\n    dist = max(dist, -distance(p, vec3(-0.8, 0.0, 0.0)) + 0.1);\n    dist = max(dist, -distance(p, vec3( 0.0,-0.8, 0.0)) + 0.1);\n    dist = max(dist, -distance(p, vec3( 1.0, 0.0,-0.2)) + 0.2);\n    dist = max(dist, -distance(p, vec3( 0.0, 1.0,-0.2)) + 0.2);\n    dist = max(dist, -distance(p, vec3(-1.0, 0.0,-0.2)) + 0.2);\n    dist = max(dist, -distance(p, vec3( 0.0,-1.0,-0.2)) + 0.2);\n    dist = max(dist, -distance(p, vec3( 1.0, 0.0, 0.2)) + 0.2);\n    dist = max(dist, -distance(p, vec3( 0.0, 1.0, 0.2)) + 0.2);\n    dist = max(dist, -distance(p, vec3(-1.0, 0.0, 0.2)) + 0.2);\n    dist = max(dist, -distance(p, vec3( 0.0,-1.0, 0.2)) + 0.2);\n    //*/\n    return dist;\n\t//*/\n    \n    // Ripply XY plane\n    //return p.z + rippleAmplitude * sin(p.x * rippleX * 2.0*PI) + rippleAmplitude * sin(p.y * rippleY * 2.0*PI);\n    \n    return 1.0;\n}\n\n// Calculates the angle from the given point to the x axis, in the range (0, 2pi)\nfloat angle(vec2 p) {\n    float angle = acos(p.x / length(p));\n    if (p.y >= 0.0)\n    \treturn angle;\n    return 2.0*PI - angle;\n}\n\n// Experimental: Calculates the texture coordinates of the given point\nvec2 texCoord(vec3 p) {\n    // Infinite grid\n    p.x = mod(p.x + 0.5*dx, dx) - 0.5*dx;\n    p.y = mod(p.y + 0.5*dy, dy) - 0.5*dy;\n    \n    vec2 coord;\n    \n    // Torus\n    // Major and minor angle, mapped to (0, 1)\n    //*\n    vec3 proj = torusRadiusMajor * vec3(dot(p, torusX), dot(p, torusY), 0.0);\n    coord.x = angle(proj.xy) / (2.0 * PI);\n    coord.y = angle(vec2(length(cross(p, torusNormal)) - torusRadiusMajor, dot(p, torusNormal))) / (2.0 * PI);\n    //*/\n    \n    // Sphere\n    // Latitude and longitude, mapped to (0, 1)\n    /*\n    coord.x = angle(p.xy) / (2.0 * PI);\n    coord.y = atan(p.z / length(p.xy));\n    //*/\n    \n    return coord;\n}\n\n// Calculates the gradient of the distance field (e.g. normal) at the given point\nvec3 gradient(vec3 p) {\n    // Torus exact form\n    /*\n    vec3 proj = torusX * dot(p, torusX) + torusY * dot(p, torusY);\n    return -normalize(p - torusRadiusMajor*normalize(proj));\n    //*/\n    // Sphere exact form\n    /*\n\treturn normalize(p);\n\t//*/\n    // General approximation\n    float eps = 0.0001;\n    return normalize(vec3(distanceFunc(p + vec3(eps, 0.0, 0.0)) - distanceFunc(p - vec3(eps, 0.0, 0.0)),\n                          distanceFunc(p + vec3(0.0, eps, 0.0)) - distanceFunc(p - vec3(0.0, eps, 0.0)),\n                          distanceFunc(p + vec3(0.0, 0.0, eps)) - distanceFunc(p - vec3(0.0, 0.0, eps))));\n}//*/\n\n// Render parameters\nfloat eps = 0.0001;\t\t// Epsilon: distance at which the ray is considered to have intersected the geometry\nint maxiter = 500;\t\t// Max iterations: Stop if the ray has not encountered any geometry after this many iterations\nfloat stepsize = 0.25;\t// How far to travel along the ray at each iteration, as a proportion of the distance function\nfloat glowRadius = 0.1;\t// Size of the glow effect around geometry\nvec3 glowColor = vec3(1.0, 0.8, 0.9);\t// Color of the glow effect right at the surface\nvec3 backgroundColor = vec3(0.5, 0.75, 1.0);\t// Color of the background\nvec3 geometryColor = vec3(1.0, 0.0, 0.0);\t// Base color of the geometry\nvec3 insideColor = vec3(0.5, 0.25, 0.0);\t// Color to show if the camera is inside geometry\nfloat fogNear = 10.0;\t// Distance at which to start applying fog\nfloat fogFar = 50.0;\t// Distance at which fog is completely opaque\nint maxrefl = 0;\t// Maximum number of reflections to calculate\n// Having an array of MAX_REFL + 1 size containing pos, normal, texcoord, of each intersection, would be enormously useful.\n\n// Calculate the raymarching algorithm starting at the given point along the given ray\nvec3 raymarch(\n    vec3 start,\t// Position from which the marching starts\n    vec3 ray,\t// Normalized direction in which to march\n    inout float min_dist,\t// Closest approach to any geometry\n    float tracking_radius,\t// When starting closer than this to any geometr, do not track the closest approach\n    out int steps\t// Number of steps taken\n) {\n    vec3 p = start;\n    int i = 0;\n    float dist = distanceFunc(p);\n    bool allow_min_tracking = (dist >= tracking_radius);\t// Only track the minimum once we've left the current iteration's sphere of influence\n    if (dist < 0.0) {\n        return p;\n    }\n    p += ray * stepsize;\n    i++;\n    dist = distanceFunc(p);\n    while (dist > eps && i < maxiter) {\n        dist = distanceFunc(p);\n        if (dist >= tracking_radius) allow_min_tracking = true;\n        if (allow_min_tracking) min_dist = min(min_dist, dist);\n        p += ray * dist * stepsize;\n        i++;\n    }\n    steps = i;\n    return p;\n}\n\nvec4 body(in vec2 fragCoord) {\n    vec4 fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n    // Normalized and centered UVs\n    vec2 uv = fragCoord / iResolution.xy;\n    uv -= vec2(0.5);\n    uv.y *= iResolution.y / iResolution.x;\n    \n    // Camera motion parameters\n    float orbitSpeed = radians(45.0);\t// Orbit speed in radians per second\n    float orbitRadius = 1.49;\t// XY distance from center of orbit\n    float orbitZ = 0.0;\t// Z distance from center of orbit\n    vec3 orbitCenter = vec3(0.0, 0.0, 0.0);\t// Center of orbit\n    \n    // Actual camera parameters\n    vec3 cameraView = vec3(0.0, 0.0, 0.0);\t// Point at which the camera is looking\n\tvec3 cameraPos = orbitCenter + vec3(orbitRadius * cos(iTime * orbitSpeed),\n                                        -orbitRadius * sin(iTime * orbitSpeed),\n                                        orbitZ * sin(0.5*iTime));\n\tvec3 cameraDir = normalize(cameraView - cameraPos);\t// Forward camera direction\n\tvec3 cameraRight = cross(cameraDir, vec3(0.0, 0.0, 1.0)); // Camera right axis\n    if (cameraRight == vec3(0.0)) cameraRight = vec3(-sin(iTime * orbitSpeed), -cos(iTime * orbitSpeed), 0.0);\n    else cameraRight = normalize(cameraRight);\n\tvec3 cameraUp = cross(cameraRight, cameraDir);\t// Camera up axis\n    float fov = 150.0;\t// Field of view of the camera, in degrees\n    float f = tan(radians(90.0 - fov / 2.0));\t//Focal length of the lens, in arbitrary units (not mm)\n    \n    // Ray direction for this pixel\n    vec3 ray = normalize(uv.x * cameraRight + uv.y * cameraUp + f * cameraDir);\n    \n    float min_dist = distanceFunc(cameraPos);\n    int amb_iter = 0;\n    vec3 p = raymarch(cameraPos, ray, min_dist, 0.0, amb_iter);\n    // Reflection loop\n    int i = 0;\n    vec3 incoming = ray;\n    vec3 start = p;\n    vec2 lastTexCoord = texCoord(p);\t// Texture coordinate of the last geometry hit\n    while (i < maxrefl && distanceFunc(start) <= eps){\n        vec3 normal = gradient(p);\n        lastTexCoord = texCoord(p);\n        float this_min_dist = 10.0;\t// Minimum distance on this particular bounce\n        vec3 refl = reflect(incoming, normal);\n        p = raymarch(start, refl, this_min_dist, glowRadius, amb_iter);\n        min_dist = this_min_dist;\n        incoming = refl;\n        start = p;\n        i++;\n    }\n    \n    // Coloring the pixel\n    if (min_dist < 0.0) {\n        // Point is inside geometry\n        fragColor.rgb = insideColor * float(i) / float(maxrefl);\n        return fragColor;\n    }\n    vec4 col = vec4(0.0);\n    \n    // Skybox\n    //*\n    backgroundColor = texture(iChannel1, incoming.xzy).rgb;\n    //*/\n        \n    // Texturing\n    //*\n    geometryColor = texture(iChannel0, lastTexCoord*4.).rgb;\n    //*/\n    \n    float reflections = float(i) / float(maxrefl);\n    \n    if (distanceFunc(p) <= eps) {\n        // At the surface, do the lighting calculation\n        vec3 normal = gradient(p);\n        col.rgb = geometryColor;\n        col.a = 1.0;\n        \n        // Diffuse shading\n        /*\n        float shadefac = clamp(dot(normal, normalize(lightPos - p)), 0.0, 1.0);\n        col.rgb *= shadefac;\n        //*/\n        \n        // Reflection\n        /*\n        vec3 refl = reflect(incoming, normal);\n        col *= texture(iChannel1, refl.xzy);\n        //*/\n        \n        // Ambient Occlusion\n        //*\n        col.rgb *= float(maxiter - amb_iter) / float(maxiter);\n        //*/\n        \n        // Debug: Normal\n        /*\n        col.rgb = normal;\n\t\t//*/\n        \n        // Debug: Reflections\n        /*\n        col.rgb = vec3(reflections);\n        //*/\n    }\n    else {\n        // No intersection, color it as the background\n        if (reflections > 0.0) {\n            col.rgb = mix(backgroundColor*geometryColor, geometryColor, reflections);\n            col.a = 1.0;\n        }\n        else {\n        \t// Glow: calculated according to the closest the ray approached any geometry\n\t        //*\n    \t    float glow = clamp(min_dist / glowRadius, 0.0, 1.0);\n        \tcol = vec4(glowColor, 1.0 - glow);\n        \t//*/\n        }\n        \n        // Output the number of reflections\n        /*\n        col.rgb = vec3(reflections);\n\t\tcol.a = 1.0;\n\t\t//*/\n        \n        // Output the minimum distance\n        /*\n        col.rgb = vec3(min_dist / glowRadius);\n\t\tcol.a = 1.0;\n        //*/\n    }\n    \n    col.rgb = mix(backgroundColor, col.rgb, col.a);\n    col.a = 1.0;\n        \n    // Fog\n    // Doesn't work with glow because the glow pixels aren't at the depth where the glow is\n    // Would have to track the position of the closest pass as well as its distance\n    /*\n    float fog = clamp((distance(p, cameraPos) - fogNear) / (fogFar - fogNear), 0.0, 1.0);\n    col.rgb = mix(col.rgb, backgroundColor, fog);\n    //*/\n    \n    fragColor = col;\n    return fragColor;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec4 sum = body(fragCoord);\n    float msaa = 1.0;\n    // Antialiasing\n    //*\n\tmsaa += 1.0;\n    sum += body(fragCoord + vec2(0.5));\n    //*/\n    \n    //*\n    // Wildly unnecessary\n    msaa += 2.0;\n    sum += body(fragCoord + vec2(0.5, 0.0));\n    sum += body(fragCoord + vec2(0.0, 0.5));\n\t//*/\n    \n    /*\n    // Thoroughly excessive\n\tmsaa += 4.0;\n    sum += body(fragCoord + vec2(0.25));\n    sum += body(fragCoord + vec2(0.75, 0.25));\n    sum += body(fragCoord + vec2(0.25, 0.75));\n    sum += body(fragCoord + vec2(0.75));\n\t//*/\n    \n    /*\n    // Comically absurd\n\tmsaa += 8.0;\n    sum += body(fragCoord + vec2(0.25, 0.0));\n    sum += body(fragCoord + vec2(0.75, 0.0));\n    sum += body(fragCoord + vec2(0.0, 0.25));\n    sum += body(fragCoord + vec2(0.5, 0.25));\n    sum += body(fragCoord + vec2(0.25, 0.5));\n    sum += body(fragCoord + vec2(0.75, 0.5));\n    sum += body(fragCoord + vec2(0.0, 0.75));\n    sum += body(fragCoord + vec2(0.5, 0.75));\n\t//*/\n    fragColor = sum / msaa;\n}","name":"Image","description":"","type":"image"}]}