{"ver":"0.1","info":{"id":"MfcXzj","date":"1714146537","viewed":134,"name":"Spinning Nested Squares","username":"Bingle","description":"A simple pattern that I wanted to try and implement in glsl. I spent a while on desmos trying to figure out the scaling math.","likes":7,"published":3,"flags":0,"usePreview":0,"tags":["square","pattern"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14159265359\n#define MAXITER 1000\n//#define WALL\n\n// Spinning Nested Squares by Bingle\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    \n    #ifdef WALL\n    uv*=2.0;\n    uv+=vec2(0.2,0.06)*iTime;\n    uv = mod(uv+vec2(0.5),1.0)-vec2(0.5);\n    #endif\n    \n    float increment = mod(0.25*iTime+0.125,PI*0.5); // Angle increment (should always be less than Ï€/2)\n    \n    int depth = 0;\n    bool fill = true;\n    \n    float scale = 1.0;\n    float angle = 0.0;\n    \n    while (true){\n        if (depth>MAXITER){\n            break; // break statement so my gpu doesn't break\n        }\n        \n        vec2 local = vec2(dot(uv,vec2(cos(angle),sin(angle))),dot(uv,vec2(-sin(angle),cos(angle)))); // Apply rotation\n        \n        if (max(abs(local.x),abs(local.y))<scale*0.5){\n            depth++;\n            scale *= 0.707106781187/cos(increment-0.785398163397); // These constants are (from left to right) the square root of 2 divided by 2 and pi divided by 4\n            fill = !fill;\n        }else{\n            break; // We're outside of the square\n        }\n        \n        depth++;\n        angle+=increment;\n    }\n    \n    vec3 col = vec3(1.0);\n    \n    if (depth>MAXITER){\n        col = vec3(0.5); // Just average things out\n    }\n    \n    if (fill){ // Invert colors\n        col = vec3(1.0)-col;\n    }\n    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}