{"ver":"0.1","info":{"id":"X3Syzd","date":"1727817460","viewed":106,"name":"Night City in the Stars","username":"incre_ment","description":"Wanted to try doing some embedded domain repetition.  Did it here with the buildings and the windows.","likes":9,"published":1,"flags":0,"usePreview":0,"tags":["2d","domainrepetition","city"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Wanted to try doing some embedded domain repetition.  \n// Did it here with the buildings and the windows.  \n// For-loops are only for layering and neighbor checking.\n// Code is far from optimized.  Would like to figure out how \n// to reduce the number of if-statements.  Was also struggling\n// with how to get the layers to overlap while maintaining the\n// white outline and black fill (see lines 59-62).  Got a \n// solution that works, but feel like there's probably a way to\n// do it with step, mix, etc...  78-85 needs improvement, as well.\n\nfloat TAU = 2.*3.14159;\n\n// Thanks IQ!\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec2 uv = ( fragCoord - .5* iResolution.xy ) /iResolution.y;\n   vec3 col = vec3(0.);\n   float tt = fract(.3*iTime);\n   float w = 1./iResolution.y;\n\n   // Draw Moon\n   float moon = length(uv-vec2(.37,.25)) - .2;\n   col += smoothstep(w,-w,moon);\n\n   // Draw Buildings\n   vec2 uv_b = uv;\n   float minVal;\n   float inB = 1.;\n   \n   // Number of City Layers\n   for(float j = 0.; j <= 3.; j++){\n     float scale = 6.5 + 2.*j;\n     uv_b = uv * scale;\n     float buildingID = floor(uv_b.x);\n     uv_b.x = fract(uv_b.x) - .5;   \n     float off = fract(58.*sin((j+10.)*1.2 * (buildingID + 10.) + 1.));\n     minVal = 1E20;\n     // Building Neighbor Checking\n     for(float i=-1.;i<=1.;i++){\n       float off2 = fract(58.*sin((j+10.)*1.2 * (buildingID + 10. + i) + 1.));\n       float b_width = .25 + .5*off2; \n       float h = round(1.6*off2 + .5) + .25*round(4.*off2);\n       float y = -(scale/2.) + h;\n       float xDel = .3*off2;\n       float b = sdBox((uv_b - vec2(xDel,y)) - vec2(i,0), vec2(b_width, h));\n       minVal = min(minVal,b);\n     }\n   \n     // inB is used to make sure the stars aren't in the buildings\n     if(minVal < 0. && inB > 0.) \n       inB = -1.;\n   \n     // Make the buildings between each layer overlap.  \n     // There's got to be a more effective way to do this.\n     if(minVal < 0.) col = vec3(0.);\n     if(minVal >= 0. && minVal < .05) col = vec3(1.);\n\n     // Setup the new coordinate system with origin at center of each building\n     float hh = round(1.6*off + .5) + .25*round(4.*off);\n     vec2 new_uv_b = (uv_b - vec2(.3*off,-scale/2.+hh));\n     \n     // Draw Windows\n     float winScale = 4.0;\n     vec2 win_uv = new_uv_b * winScale;\n     vec2 winID = floor(win_uv);\n     win_uv = fract(win_uv) - .5;\n\n     float offwin = fract(58.*sin((j+10.)*1.2 * (buildingID + 20.) + 1.));\n     \n     // Don't like all these if statements, here.  Need to try and fix.\n     if (winID.x == -1. || winID.x == 0.){\n      if (winID.y < 4.*hh){\n       float ranOff = fract(1212.3*sin(12.*winID.x + 50. + buildingID) * 212.*cos(98.6*winID.y + 50.));\n       if( ranOff < .80){\n         if (ranOff < .97){\n          float c = sdBox(win_uv,vec2(.2 + .2*off,(.35*offwin)+.05));\n          col += smoothstep(w,-w,c);\n         }\n       }\n      }\n     }\n   }\n   \n   \n   // Draw Stars\n   vec2 uvStars = uv * 30.;\n   vec2 starCell = floor(uvStars);\n   uvStars = fract(uvStars) - .5;   \n   float minStar = 1E20;\n   for(float i=-1.;i<=1.;i++)\n   for(float j=-1.;j<=1.;j++){\n     float r1 = fract(sin(dot(starCell + vec2(i,j), vec2(3.0,12.0)))*15745.7342) * 2. - 1.;\n     float r2 = fract(sin(dot(starCell + vec2(i,j), vec2(7.0,43.0)))*13131.8234) * 2. - 1.;\n     float spark = 0.;\n     if (r2 > .3) spark = .1 * sin(TAU*(tt + r1));     \n     float ssize = r2 * .1;  \n     float star = length((uvStars - vec2(i,j)) - 1.*vec2(r1,r2)) - ssize+spark;\n     minStar = min(minStar, star);\n   }\n   w = 54./iResolution.y; \n   col += smoothstep(w,-w,minStar)*step(0.,inB);\n     \n   fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}