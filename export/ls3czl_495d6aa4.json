{"ver":"0.1","info":{"id":"ls3czl","date":"1519852614","viewed":201,"name":"DeadMan's Basic Raytracer","username":"DeadMan","description":"This is a basic raytracer. It's really simple and basic. It can render cubes and spheres. It uses a deferred rendering style which makes it very easy to write post-process shaders for it. You can click and drag to move the camera.","likes":1,"published":1,"flags":32,"usePreview":0,"tags":["3d","raytracing","deferred"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    fragColor = texture(iChannel0,uv);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"struct RayHit\n{\n    vec3 baseColor;\n    vec3 worldPosition;\n    vec3 normal;\n    vec3 rayDir;\n    float depth;\n    bool hit;\n    bool lit;\n};\n    \nstruct Ray{\n    vec3 origin;\n    vec3 direction;\n};\n    \nstruct Sphere{\n    vec3 origin;\n    float radius;\n    vec3 color;\n    bool castShadow;\n    bool lit;\n};\n    \nstruct Box{\n    vec3 origin;\n    vec3 radius;\n    vec3 color;\n    bool castShadow;\n    bool lit;\n};\nconst int numSpheres = 7;\nconst int numBoxes = 3;\nconst int spheresX = 0;\nconst int spheresY = 0;\nSphere newSphere(vec3 origin, float radius, vec3 color, bool castShadow, bool lit){\n    Sphere sphere;\n    sphere.origin = origin;\n    sphere.radius = radius;\n    sphere.color = color;\n    sphere.castShadow = castShadow;\n    sphere.lit = lit;\n    return sphere;\n}\n\nBox newBox(vec3 origin, vec3 radius, vec3 color, bool castShadow, bool lit){\n    Box box;\n    box.origin = origin;\n    box.radius = radius;\n    box.color = color;\n    box.castShadow = castShadow;\n    box.lit = lit;\n    return box;\n}\n\nRayHit traceSphere(Ray ray, Sphere sphere){\n    RayHit hit;\n    \n    vec3 sphereRelLoc = sphere.origin - ray.origin;\n    \n    float projDist = dot(sphereRelLoc, ray.direction);\n    vec3 proj = ray.direction * projDist;\n    \n    vec3 bv = proj - sphereRelLoc;\n    \n    float b2 = dot(bv, bv);\n    \n    if(b2 > sphere.radius * sphere.radius){\n        hit.hit = false;\n        return hit;\n    }\n    \n    hit.hit = true;\n    float x = sqrt(sphere.radius * sphere.radius - b2);\n    hit.depth = projDist - x;\n    hit.worldPosition = ray.origin + ray.direction * hit.depth;\n    hit.normal = normalize(sphere.origin - hit.worldPosition);\n    hit.baseColor = sphere.color;\n    hit.lit = sphere.lit;\n    \n    return hit;\n}\n\nRayHit traceManySpheres(int numSpheresX, int numSpheresY, Ray ray){\n    RayHit hit;\n    RayHit rayTrace;\n    float depth = 1000000.0;\n    for(int x = 0; x < numSpheresX; x++){\n        for(int y = 0; y < numSpheresY; y++){\n            Sphere sphere = newSphere(vec3((x - numSpheresX / 2) * 20, -30.0, (y) * 20 + 200), 10.00, vec3(1.0, 0.0, 0.0), true, true);\n            rayTrace = traceSphere(ray, sphere);\n            if(rayTrace.hit){\n                if(rayTrace.depth < depth){\n                    depth = rayTrace.depth;\n    \t\t\t\thit = rayTrace;\n                }\n            }\n        }\n    }\n   return hit;\n}\n\nRayHit traceBox(Ray ray, Box box){\n    RayHit rayHit;\n    vec3 bMin = box.origin - box.radius;\n    vec3 bMax = box.origin + box.radius;\n    vec3 rayInv = 1.0 / ray.direction;\n    \n    vec3 t1 = (bMin - ray.origin) * rayInv;\n    vec3 t2 = (bMax - ray.origin) * rayInv;\n    \n    vec3 vMin = min(t1, t2);\n    vec3 vMax = max(t1, t2);\n    \n    float tMin = max(vMin.z, max(vMin.x, vMin.y));\n    float tMax = min(vMax.z, min(vMax.x, vMax.y));\n    \n    \n    if((tMax <= tMin) || (tMin <= 0.0)){\n        rayHit.hit = false;\n        return rayHit;\n    }\n    rayHit.hit = true;\n    rayHit.baseColor = box.color;\n    rayHit.depth = tMin;\n    rayHit.worldPosition = ray.origin + ray.direction * rayHit.depth;\n    rayHit.lit = box.lit;\n    \n    if(t1.x == tMin) rayHit.normal = vec3(1.0, 0.0, 0.0);\n    if(t2.x == tMin) rayHit.normal = vec3(-1.0, 0.0, 0.0);\n    if(t1.y == tMin) rayHit.normal = vec3(0.0, 1.0, 0.0);\n    if(t2.y == tMin) rayHit.normal = vec3(0.0, -1.0, 0.0);\n    if(t1.z == tMin) rayHit.normal = vec3(0.0, 0.0, 1.0);\n    if(t2.z == tMin) rayHit.normal = vec3(0.0, 0.0, -1.0);\n    \n    return rayHit;\n}\n\n\nfloat pp_dirLight(vec3 worldPosition, vec3 normal, vec3 sunNormal, float sunBrightness, Sphere[numSpheres] spheres, Box[numBoxes] boxes){\n    \n    float brightness = dot(sunNormal, normal) * sunBrightness;\n    if(brightness > 0.0){\n    \tRay ray;\n   \t\tray.origin = worldPosition;\n   \t\tray.direction = sunNormal * -1.0;\n   \t\tfor(int i = 0; i < spheres.length(); i++){\n            \tif(spheres[i].castShadow){\n   \t     \t\n    \t    \tRayHit rayHit = traceSphere(ray, spheres[i]);\n    \t    \t   \n    \t    \tif(rayHit.hit && rayHit.depth > 0.0){\n    \t    \t    brightness = 0.0;\n    \t\t\t\treturn brightness;\n    \t    \t}\n            }\n    \t}\n        for(int i = 0; i < boxes.length(); i++){\n            if(boxes[i].castShadow){\n            \tRayHit rayHit = traceBox(ray, boxes[i]);\n            \t\n            \tif(rayHit.hit && rayHit.depth > 0.0){\n            \t    brightness = 0.0;\n            \t    return brightness;\n            \t}\n            }\n        }\n        RayHit rayHit = traceManySpheres(spheresX, spheresY, ray);\n        if(rayHit.hit && rayHit.depth > 0.0){\n            brightness = 0.0;\n            return brightness;\n        }\n    }\n    \n    return clamp(brightness, 0.0, abs(brightness));\n}\n\nfloat pp_pointLight(vec3 worldPosition, vec3 normal, vec3 lightLocation, float lightBrightness, Sphere[numSpheres] spheres, Box[numBoxes] boxes){\n    vec3 diff = worldPosition - lightLocation;\n    \n    vec3 lightNormal = normalize(diff);\n    \n    float dist = length(diff);\n    \n    float brightness = dot(lightNormal, normal) * lightBrightness / (pow(dist, 2.0));\n    \n    if(brightness > 0.0){\n    \tRay ray;\n   \t\tray.origin = worldPosition;\n   \t\tray.direction = lightNormal * -1.0;\n   \t\tfor(int i = 0; i < spheres.length(); i++){\n            if(spheres[i].castShadow){\n   \t    \t \n    \t\t    RayHit rayHit = traceSphere(ray, spheres[i]);\n    \t\t       \n    \t\t    if(rayHit.hit && rayHit.depth > 0.0 && rayHit.depth < dist){\n    \t\t        brightness = 0.0;\n    \t\t\t\treturn brightness;\n\t    \t    }\n            }\n    \t}\n        for(int i = 0; i < boxes.length(); i++){\n            if(boxes[i].castShadow){\n            \tRayHit rayHit = traceBox(ray, boxes[i]);\n            \t\n            \tif(rayHit.hit && rayHit.depth > 0.0 && rayHit.depth < dist){\n            \t    brightness = 0.0;\n            \t    return brightness;\n            \t}\n            }\n        }\n        RayHit rayHit = traceManySpheres(spheresX, spheresY, ray);\n        if(rayHit.hit && rayHit.depth > 0.0 && rayHit.depth < dist){\n            brightness = 0.0;\n            return brightness;\n        }\n    }\n    \n    return clamp(brightness, 0.0, abs(brightness));\n}\n\nvec3 pp_celShading(vec3 baseColor, vec3 currentColor, float numBands){\n    vec3 newColor;\n    \n    vec3 light = vec3(currentColor.x / baseColor.x, currentColor.y / baseColor.y, currentColor.z / baseColor.z);\n    light = round(light * numBands) / numBands;\n    \n    newColor = baseColor * light;\n    \n    return newColor;\n}\n\nvec3 pp_depthFog(float depth, vec3 currentColor, vec3 fogColor, float startDist, float endDist){\n    float depthDiv = (depth - startDist) / endDist;\n    depthDiv = clamp(depthDiv, 0.0, 1.0);\n    return mix(currentColor, fogColor, depthDiv);\n}\n\nvoid initScene(out Sphere[numSpheres] spheres, out Box[numBoxes] boxes){\n    \n    spheres[0] = newSphere(vec3(0.0, 0.0, 200.0), 10.0, vec3(1.0, 0.1, 0.1), true, true);\n    spheres[1] = newSphere(vec3(20.0, 0.0, 200.0), 5.0, vec3(0.1, 1.0, 0.1), true, true);\n    spheres[2] = newSphere(vec3(-20.0, 0.0, 200.0), 5.0, vec3(0.1, 0.1, 1.0), true, true);\n    spheres[3] = newSphere(vec3(0.0, 20.0, 200.0), 5.0, vec3(0.5, 0.5, 0.5), true, true);\n    spheres[4] = newSphere(vec3(0.0, -20.0, 200.0), 5.0, vec3(1.0, 1.1, 0.1), true, true);\n    spheres[5] = newSphere(vec3(sin(iTime) * 39.0, cos(iTime) * 39.0, 180.0), 1.0, vec3(1.0, 1.0, 1.0), false, false);\n    spheres[6] = newSphere(vec3(sin(iTime) * 39.0, 0.0, 180.0 + cos(iTime) * 39.0), 1.0, vec3(1.0, 1.0, 1.0), false, false);\n    \n    boxes[0] = newBox(vec3(0.0, -50.0, 0.0), vec3(500.0, 10.0, 500.0), vec3(0.4, 1.0, 0.4), true, true);\n    boxes[1] = newBox(vec3(0.0, -35, 200.0), vec3(10.0, 5, 10.0), vec3(1, 1, 1), true, true);\n    boxes[2] = newBox(vec3 (sin(iTime * 1.2) * 50.0, -30, (cos(iTime * 2.4) * 50.0) + 200.0), vec3(5.0, 10.0, 5.0), vec3(1.0, 0.1, 0.75), true, true);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    float fov = 180.0;\n    vec3 cameraLocation = vec3((iMouse.xy / iResolution.xy) - 0.5, 0.0) * 100.0;\n    if(iMouse.xy == vec2(0.0, 0.0)){\n        cameraLocation = vec3(0.0, 0.0, 0.0);\n    }\n    Ray ray;\n    ray.origin = cameraLocation;\n    ray.direction = normalize(vec3((uv.x - 0.5) * (fov / 180.0), (uv.y - 0.5) * (fov / 180.0) * (iResolution.y / iResolution.x), 1.0));\n    \n\tSphere[numSpheres] spheres;\n    Box[numBoxes] boxes;\n    initScene(spheres, boxes);\n    \n    RayHit rayTrace;\n    \n    vec3 color;\n    vec3 wp;\n    vec3 normal;\n    float depth = 100000000.0;\n    bool lit = true;\n    bool hit = false;\n    vec3 finalColor;\n    for(int i = 0; i < boxes.length(); i++){\n    \trayTrace = traceBox(ray, boxes[i]);\n        if(rayTrace.hit){\n            if(rayTrace.depth < depth){\n    \t\t\tcolor = rayTrace.baseColor;\n    \t\t\twp = rayTrace.worldPosition;\n    \t\t\tnormal = rayTrace.normal;\n    \t\t\tdepth = rayTrace.depth;\n        \t\tcolor = rayTrace.baseColor;\n        \t\tlit = rayTrace.lit;\n    \t\t\thit = true;\n            }\n        }\n    }\n    \n    \n    for(int i = 0; i < spheres.length(); i++){\n        rayTrace = traceSphere(ray, spheres[i]);\n        \n        if(rayTrace.hit){\n            if(rayTrace.depth < depth){\n    \t\t\tcolor = rayTrace.baseColor;\n    \t\t\twp = rayTrace.worldPosition;\n    \t\t\tnormal = rayTrace.normal;\n    \t\t\tdepth = rayTrace.depth;\n                lit = rayTrace.lit;\n            }\n            hit = true;\n        }\n    }\n    \n    rayTrace = traceManySpheres(spheresX, spheresY, ray);\n    if(rayTrace.hit){\n        if(rayTrace.depth < depth){\n    \t\tcolor = rayTrace.baseColor;\n    \t\twp = rayTrace.worldPosition;\n    \t\tnormal = rayTrace.normal;\n    \t\tdepth = rayTrace.depth;\n            lit = rayTrace.lit;\n        }\n        hit = true;\n    }\n    \n    finalColor = color;\n    \n    vec3 skyColor = mix(vec3(0.8, 0.8, 1.0), vec3(1.0, 1.0, 1.0), ray.direction.y);\n    \n    if(hit){\n        vec3 sunNormal = normalize(vec3(0.5, -1.0, 0.5));\n        \n        float pixelBrightness = 0.0;\n        if(lit){\n            //Here are the lights. You can add/remove lights by commenting or adding new lines.\n        \tpixelBrightness += pp_dirLight(wp, normal, sunNormal, 0.8, spheres, boxes);\n        \tpixelBrightness += pp_pointLight(wp, normal, vec3(sin(iTime) * 39.0, cos(iTime) * 39.0, 180.0), 500.0, spheres, boxes);\n        \tpixelBrightness += pp_pointLight(wp, normal, vec3(sin(iTime) * 39.0, 0.0, 180.0 + cos(iTime) * 39.0), 500.0, spheres, boxes);\n            pixelBrightness += pp_pointLight(wp, normal, vec3(0.0, 0.0, 250.0), 2000.0, spheres, boxes);\n        \tpixelBrightness = clamp(pixelBrightness, 0.0, 1.0);\n    \t\t\n        \tfinalColor = color * pixelBrightness;\n            \n            //Post Process section. Comment/uncomment different lines to get different results.\n            \n            //finalColor = pp_celShading(color, finalColor, 3.0);\n            \n            //finalColor = pp_depthFog(depth, finalColor, skyColor, 100.0, 1000.0);\n        }\n        \n    \tfragColor = vec4(finalColor, 1.0);\n    } else{\n        fragColor = vec4(skyColor, 1.0);\n    }\n}","name":"Buffer A","description":"","type":"buffer"}]}