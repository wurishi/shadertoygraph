{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[{"channel":0,"type":"texture","id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"code":"const int LIGHT_COUNT = 4;\n\nstruct Light {\n\tvec3 position;\n\tvec3 colour;\n\tfloat falloff;\n} lights[LIGHT_COUNT];\n\n\nvoid setUpLights() {\n\tlights[0].position = vec3(sin(iTime)*0.5 + 0.5, sin(iTime)*0.5 + 0.5, 0.0);\n\tlights[0].colour = vec3(1.0);\n\tlights[0].falloff = 3.0;\n\t\n\tlights[1].position = vec3(0.0, 1.0, 0.0);\n\tlights[1].colour = vec3(1.0, 0.0, 0.0);\n\tlights[1].falloff = 3.0;\n\t\n\tlights[2].position = vec3(1.0, 0.0, 0.0);\n\tlights[2].colour = vec3(0.0, 1.0, 0.0);\n\tlights[2].falloff = 12.0;\n\t\n\tlights[3].position = vec3(1.0, 1.0, 0.0);\n\tlights[3].colour = vec3(0.0, 0.0, 1.0);\n\tlights[3].falloff = 3.0;\n}\n\n\nvec3 computeLight(const vec3 surface, const vec3 normal, \n\t\t\t\t  const vec3 lightOrigin, const vec3 lcolour,\n\t\t\t\t  const float falloff) {\n\tvec3 lightDir = lightOrigin - surface;\n\tvec3 ray = -normalize(lightDir);\n\t\n\tfloat intensity = dot(normal, ray);\n\treturn pow(intensity, falloff) * lcolour / length(lightDir);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tsetUpLights();\n\t\n\tvec3 uv = vec3(fragCoord.xy / iResolution.xy, 1.0);\n\t\n\t// Generate the normal and perturb\n\tfloat noise = texture(iChannel0, uv.xy).r;\n\tvec3 normal = normalize(vec3(dFdx(noise), dFdy(noise), 1.0));\n\t\n\t// Aggregate all light interactions\n\tvec3 colour = vec3(0.0);\n\tfor(int i=0; i < LIGHT_COUNT; i++)\n\t\tcolour += computeLight(uv, normal, lights[i].position, lights[i].colour, lights[i].falloff);\n\tcolour /= float(LIGHT_COUNT);\n\t\n\t// Gamma correction\n\tcolour = pow(colour, vec3(1.0/1.4));\n\t\n\tfragColor = vec4(colour, 1.0);\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"MdlXRB","date":"1403610846","viewed":484,"name":"Trivial 2D Lighting Bumpmapping","username":"KrunoSaho","description":"Procedurally generates a perturbed normal via partial derivatives using the dFdx, dFdy functions that take noise as input. My main goal was to trivialise lighting as much as possible for my game, as it is 2D, orthographic, and using a birds eye view.","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["procedural","2d","bumpmapping"],"hasliked":0,"parentid":"","parentname":""}}