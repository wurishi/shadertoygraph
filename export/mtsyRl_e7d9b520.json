{"ver":"0.1","info":{"id":"mtsyRl","date":"1691351934","viewed":247,"name":"BRDF Visualizer","username":"leoneruggiero","description":"A simple visualization of some of the most common isotropic BRDFs. ","likes":17,"published":1,"flags":32,"usePreview":0,"tags":["brdf","pbr"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"dc sdPlane(vec3 p, float s)\n{\n    float l = length(p.xz);\n    float d =  max(l-s, abs(p.y));\n    float a = 1.0 - ((1.0+3.5)*l/s - 3.5);\n    vec4 c = vec4(0.55, 0.55, 0.55, min(1.0, max(0.0, a)));\n    dc r;\n    r.d = d;\n    r.c = c;\n    \n    return r;\n}\n\nfloat sdLight(vec2 p, float r) //0.06\n{\n\n  return \n      min (  sdCircle(p, r),\n      max ( -sdCircle(p, r * 1.33),sdStar(p, r*2.0, 10, 4.0))\n      ); \n}\n\nfloat sdEye(vec2 p)\n{\n\n    float lid = sdVesica(p, 0.13, 0.08);\n    float eye  = sdCircle(p-vec2(0.0, 0.02), 0.04);\n    return min(eye, abs(lid) - 0.01);\n}\n\n\n// --------------------------------------- //\n//        ++       !!! ATTENTION !!!       //\n//       //\\\\                              //\n//      //  \\\\     Duplicate code, keep    //\n//     // || \\\\    in sync with `Buffer B` //\n//    //  ||  \\\\                           //\n//   //   <>   \\\\                          //\n//  ++==========++                         //\n// --------------------------------------- //\nvec2 squareFrame(vec2 screenPos, vec2 screenSize, vec2 coord) {\n\n  vec2 position = ((coord.xy - screenPos.xy) / screenSize.xy);\n  position = position*2.0 - 1.0;\n  position.x*=screenSize.x/screenSize.y;\n  return position;\n}\n\nvec3 getRay(mat3 camMat, vec2 screenPos, float lensLength) {\n  return normalize(camMat * vec3(screenPos, lensLength));\n}\n\nvec2 getCurrentMousePos() // on the controller rect \n{\n  vec2 mousePos = texelFetch(iChannel0, CLK_TEX_UV, 0).xy;    \n  if(mousePos == vec2(0.0)) mousePos = DEFAULT_CTRL_VAL;\n  return squareFrame(CTRL_POS.xy, CTRL_SIZE.xy , mousePos);\n}\n\nvec3 getViewDirOnSphere(vec2 uv)\n{\n    const vec3 sphereCenter = vec3(0.0, 0.0, 2.5);\n    return getRay(mat3(1.0), uv, 3.0);\n}\n\nvec3 getCurrentViewDir()\n{\n    return getViewDirOnSphere(getCurrentMousePos());\n}\n\nvec3 getNormalOnSphere(vec2 uv)\n{\n    const vec3 sphereCenter = vec3(0.0, 0.0, 2.5);\n    \n    vec3 rd = getViewDirOnSphere(uv);\n    \n    float d = dstSphereLine(sphereCenter, 0.5, vec3(0.0), rd);\n    \n    return d > 0.0 ? normalize(d*rd - sphereCenter) : vec3(0.0, 0.0, 1.0);\n}\n\nvec3 getCurrentNormal()\n{\n    return getNormalOnSphere(getCurrentMousePos());\n}\n\nfloat getCurrentSlider0Value()\n{\n    // 0 to 1 parameter\n    float p = texelFetch(iChannel0, SLIDER0_TEX_UV, 0).r;\n    if(p==0.0) p=DEFAULT_SLIDER0_VAL;\n    return p;\n\n}\n\nfloat getCurrentSlider1Value()\n{\n    // 0 to 1 parameter\n    float p = texelFetch(iChannel0, SLIDER1_TEX_UV, 0).r;\n    if(p==0.0) p=DEFAULT_SLIDER1_VAL;\n    return p;\n\n}\n\nvec3 getLightDir()\n{\n    float param = getCurrentSlider0Value();\n    \n    const vec3 y = normalize(vec3(-1.0, 1.0, 0.0));\n    const vec3 z = vec3(0.0, 0.0, 1.0);\n    const vec3 x = cross(y, z);\n    const mat3 t = mat3(x, y, z);\n    \n    // -PI/4 to 3/4 PI\n    float angle  = param * PI - PI_4;\n    vec3  light  = t*vec3(cos(angle), 0.0, sin(angle));\n    \n    return -light;\n\n}\n// end of duplicate code...\n\nvec3 evalBrdf(vec3 l, vec3 n, vec3 v)\n{\n    float dO = length(v); \n    \n    return (v/dO)*(BRDF(l,n,v/dO));\n}\n\ndc sdScene(vec3 p)\n{\n    dc d0 =  sdPlane(p, 1.0);\n    return d0;\n}\n\ndc sdLines(vec3 p, vec3 d, vec3 cd)\n{\n   // Vectors\n   // ------------------------------------------------\n   const vec3 origin = vec3(0.0);\n   \n   // graph reference frame - normal is always positive y \n   // --------------------------------------------------\n   vec3 normal =  getCurrentNormal();\n   vec3 light  =  getLightDir();\n   vec3 eye    = -getCurrentViewDir();\n   \n   vec3 ty = normal;\n   vec3 tz = normalize(cross(normal, vec3(0.0, 1.0, 0.0)));\n   vec3 tx = cross(ty, tz);\n   \n   mat3 tr = transpose(mat3(tx, ty, tz));\n   eye    = tr*eye;\n   light  = tr*light;\n   normal = tr*normal;\n   // --------------------------------------------------\n    \n   vec3 reflec = reflect(-light, normal);\n  \n   float d0 = dstLineLine(origin, normal, p, d);\n   float d1 = dstLineLine(origin, light, p, d);\n   float d2 = dstLineLine(origin, reflec, p, d);\n   float d3 = dstLineLine(origin, eye, p, d);\n   \n   float m = min(min(min(d0, d1), d2), d3);\n   \n   dc res;\n   res.c = BG_COL;\n   \n   if(m == d0){res.d = d0; res.c =   NRM_VEC_COL;}\n   if(m == d1){res.d = d1; res.c = LIGHT_VEC_COL;}\n   if(m == d2){res.d = d2; res.c =   RFL_VEC_COL;}\n   if(m == d3){res.d = d3; res.c =   EYE_VEC_COL;}\n   \n   // Symbols\n   // ------------------------------------------------\n   vec3 po0 = origin + 1.45*light;\n   float d4 = dstLinePlane(p, d, po0,-cd);\n   \n   vec3 po1 = origin + 1.4 *eye;\n   float d5 = dstLinePlane(p, d, po1,-cd);\n   \n   vec3 x = normalize(cross(normal, -cd));\n   vec3 y = normalize(cross(-cd, x));\n   \n   if(res.d > d4)\n   {\n       vec3 p2 = p+d*d4; //line-plane intersection\n       p2 = p2-po0;\n       p2 = vec3(dot(p2, x), dot(p2, y),0.0);\n       if(sdLight(p2.xy, 0.06)<0.0){res.c = LIGHT_VEC_COL; res.d = d4;}\n   }\n   if(res.d > d5)\n   {    \n      vec3 p2 = p+d*d5; //line-plane intersection\n      p2 = p2-po1;\n      p2 = vec3(dot(p2, x), dot(p2, y),0.0);\n      if(sdEye(p2.xy)<0.0){res.c = EYE_VEC_COL; res.d = d5;}\n   }\n  \n   \n   return res;\n}\n\nvec4 shade(vec3 n, vec3 li, vec3 d)\n{\n\n    li = normalize(li);\n    return vec4(dot(n, li) * d, 1.0);\n}\n\nvec3 nrmScene(vec3 pos, float eps) {\n  const vec3 v1 = vec3( 1.0,-1.0,-1.0);\n  const vec3 v2 = vec3(-1.0,-1.0, 1.0);\n  const vec3 v3 = vec3(-1.0, 1.0,-1.0);\n  const vec3 v4 = vec3( 1.0, 1.0, 1.0);\n\n  return normalize( v1 * sdScene( pos + v1*eps ).d +\n                    v2 * sdScene( pos + v2*eps ).d +\n                    v3 * sdScene( pos + v3*eps ).d +\n                    v4 * sdScene( pos + v4*eps ).d );\n}\n\nvec3 nrmScene(vec3 pos) {\n  return nrmScene(pos, 0.001);\n}\n\n\nRayIntersection rayMarch(vec3 rayOrigin, vec3 rayDir, float mind, float maxd, float precis) {\n  dc latest;\n  latest.d = precis;\n  float dist   = mind;\n  float type   = -1.0;\n  vec3  nrm    = vec3(0.0, 0.0, 1.0);\n  \n  RayIntersection res;\n  res.d = mind;\n  res.n = nrm;\n  \n  const int iter = 40;\n  \n  for (int i = 0; i <iter; i++) {\n    \n    if (latest.d < precis) break;\n    if (dist >= maxd) {res.d = maxd; return res;}\n    \n    latest = sdScene(rayOrigin + rayDir * dist);\n    dist  += latest.d;\n  }\n\n  if (dist < maxd) {\n    res.d = dist;\n    res.c = latest.c;\n    res.n = vec3(0.0, 0.0, 1.0);\n  }\n\n  \n  return res;\n}\n\n\nRayIntersection rayMarchLines(vec3 rayOrigin, vec3 rayDir, vec3 cameraDir, float mind, float maxd, float precis) \n{\n    \n    RayIntersection r;\n    dc d;\n    d = sdLines(rayOrigin, rayDir, cameraDir);\n    \n    r.d = d.d;\n    r.c = d.c;\n    r.n = vec3(0.0, 0.0, 1.0);\n    \n    return r;\n}\n\nvec3 getEyePos(vec4 buffVal)\n{ \n    return buffVal.xyz * vec3(1,1,-1); \n}\n\nvec3 getEyeNormal(ivec2 intCoord, int e)\n{\n    // Compute view space normals from view positions.\n    // For each dimension (x/y) take the derivative with the lowest\n    // absolute value to avoid some of the artifacts of the\n    // cross(dFdx, dFdy) method.\n    float sgn = 1.0;\n    \n    vec3 c   = getEyePos(texelFetch(iChannel1, intCoord.xy, 0));\n    vec3 pDx = getEyePos(texelFetch(iChannel1, intCoord.xy + ivec2( e, 0.0), 0));\n    vec3 nDx = getEyePos(texelFetch(iChannel1, intCoord.xy + ivec2(-e, 0.0), 0));\n    vec3 pDy = getEyePos(texelFetch(iChannel1, intCoord.xy + ivec2( 0.0, e), 0));\n    vec3 nDy = getEyePos(texelFetch(iChannel1, intCoord.xy + ivec2( 0.0,-e), 0));\n    \n    vec3 dx = pDx;\n    vec3 dy = pDy;\n    \n    if(abs(nDx.z-c.z)<abs(pDx.z-c.z)) {dx = nDx; sgn*=-1.0;}\n    if(abs(nDy.z-c.z)<abs(pDy.z-c.z)) {dy = nDy; sgn*=-1.0;}\n    \n    return normalize(cross(dx-c, dy-c))*sgn;\n}\n\n\nRayIntersection calcRayIntersection(vec3 rayOrigin, vec3 rayDir, vec3 cameraDir, float mind, float maxd, float precis)\n{\n\n    RayIntersection r0;\n   \n    r0.d = texelFetch(iChannel1, ivec2(gl_FragCoord.xy), 0).a;\n    r0.n = getEyeNormal(ivec2(gl_FragCoord.xy), 4);\n    r0.c = mix(vec4(0.25, 0.21, 0.20, 1.0), vec4(0.8, 0.2, 0.0, 1.0), r0.n.z);\n    \n    \n    RayIntersection r1 = rayMarch         (rayOrigin, rayDir, mind, maxd, precis);\n    RayIntersection r2 = rayMarchLines    (rayOrigin, rayDir, cameraDir, mind, maxd, precis);\n   \n    float m = min(r0.d, min(r1.d, r2.d));\n  \n    if(m == r0.d) return r0;\n    if(m == r1.d) return r1;\n    if(m == r2.d) return r2;\n\n}\n\n\nvec4 scene2d(vec2 uv)\n{\n    uv.y += 0.5; // transl a bit\n    float dst = length(uv);\n    vec4 col = BG_COL;\n\n    // 2d BRDF graph\n    // --------------------------------------------------\n    const vec3 origin = vec3(0.0);\n    \n    // graph reference frame - normal is always positive y \n    // --------------------------------------------------\n    vec3 normal =  getCurrentNormal();\n    vec3 light  =  getLightDir();\n    vec3 eye    = -getCurrentViewDir();\n   \n    vec3 ty = normal;\n    vec3 tz = normalize(cross(normal, vec3(0.0, 1.0, 0.0)));\n    vec3 tx = cross(ty, tz);\n   \n    mat3 tr = transpose(mat3(tx, ty, tz));\n    eye    = tr*eye;\n    light  = tr*light;\n    normal = tr*normal;\n    // --------------------------------------------------\n    \n    vec3 light2d  = vec3(length(cross(normal, light)),dot(normal, light),0.0);\n    vec3 reflec2d = reflect(-light2d, normal);\n    \n    float val  = BRDF(light2d, normal, vec3(uv/dst, 0.0));\n    \n    float r = dst-val;\n    \n    if(r < 0.0) col = vec4(1.0, 0.0, 0.0, 1.0);\n    \n    \n    // vectors (light, normal, ...)\n    // ------------------------------------------------\n    vec3 uv3 = vec3(uv, 0.0);\n    if(dstPointLine(uv3, origin, normal   , 1.2) < 0.012) col = mix(col,   NRM_VEC_COL, 0.7);\n    if(dstPointLine(uv3, origin, light2d  , 1.0) < 0.012) col = mix(col, LIGHT_VEC_COL, 0.7);\n    if(dstPointLine(uv3, origin, reflec2d , 1.2) < 0.012) col = mix(col,   RFL_VEC_COL, 0.7);\n    \n    \n    // Symbols\n    // ------------------------------------------------\n    if(sdLight(uv - (origin.xy + light2d.xy)*1.2, 0.06) < 0.0) col = mix(col, LIGHT_VEC_COL, 0.8);\n    \n    return col;\n}\n\n\nfloat sdCrosshair(vec2 uv)\n{\n    const float r = 0.1;\n    float d0 = sdSegment(uv, vec2(-r, 0.0), vec2(r, 0.0)) - 0.01;\n    float d1 = sdSegment(uv, vec2(0.0, -r), vec2(0.0,r)) - 0.01;\n    float dc0 = sdCircle(uv, 0.04);\n    float dc1 = sdCircle(uv, 0.02);\n    \n    \n    float dcross  = max(min(d0, d1), -dc0);\n    float dcenter = max(dc0,-dc1);\n    return \n        min(dcenter, dcross);\n\n}\n\nvec4 controller(vec2 uv, vec2 mousePos)\n{\n    vec4 col;\n\n    vec3 light = getLightDir();\n\n    vec3 rd = getRay(mat3(1.0), uv, 3.0);\n    const vec3 sphereCenter = vec3(0.0, 0.0, 2.5);\n    \n    float d = dstSphereLine(sphereCenter, 0.5, vec3(0.0), rd);\n    \n    if(d<0.0) \n        col = BG_COL;\n    else\n    {\n        vec3 nrm = normalize(d*rd - sphereCenter);\n\n        vec4 diffuse  = vec4(CTRL_COL * dot(nrm, light));\n        vec4 specular = vec4(BRDF(light, nrm, -rd)); \n        col = diffuse + specular;\n    }\n    \n    if(sdCrosshair(uv-mousePos)<0.0f) col = CRSH_COL;\n        \n    return col;\n\n}\n\nvec4 slider(vec2 uv, float width, float val)\n{\n    const float h0 = 0.1;\n    const float h1 = 0.4;\n    \n    float w_2 = width/2.0;\n    \n    float sdSegm = sdSegment(uv, vec2(-w_2, 0.0), vec2(w_2, 0.0)) - h0;\n    \n    float sdCirc = sdCircle(uv - vec2(w_2 * (val*2.0-1.0), 0.0), h1);\n   \n    vec4 col = BG_COL;\n    if(sdSegm<0.0) col = vec4(0.6, 0.6, 0.7, 1.0);\n    if(sdCirc<0.0) col = vec4(0.4, 0.4, 0.4, 1.0);\n    \n    return col;\n\n}\n\nvec4 sliderIcon0(vec2 uv)\n{\n    return sdLight(uv, 0.4) < 0.0 ? LIGHT_VEC_COL : BG_COL;\n\n\n}\n\nfloat sdTerrain2d(vec2 uv, \n                  float h, // terrain base y-coordinate \n                  float r  // roughness (0 - 1)\n)\n{\n    return  uv.y - (h + 0.5*r*cos(uv.x*5.0*PI));\n    \n}\n\nfloat sdArrow2d(vec2 uv, vec2 s, vec2 e)\n{\n    vec2  v = e-s;\n    vec2  n = vec2(-v.y, v.x);\n    \n    float a = dstPointLine(uv, s, e);\n    float b = dstPointLine(uv, e, e - v*0.2 + n*0.1);\n    float c = dstPointLine(uv, e, e - v*0.2 - n*0.1);\n    \n    return min(min(a, b), c);\n\n}\n\nvec4 sliderIcon1(vec2 uv)\n{\n    const vec2  ld = vec2(-0.1, -0.4) - vec2(-0.7, 0.3);\n    const vec2  rd = reflect(ld, vec2(0.0, 1.0));\n    const vec2 rdn = vec2(-rd.y, rd.x);\n    const float wd = 0.035;\n    \n    float slider = getCurrentSlider1Value();\n    \n    float t =  sdTerrain2d(uv, -0.3, 0.3*slider); // < 0.0 ? vec4(0.9, 0.3, 0.0, 1.0) : BG_COL;\n    \n    float l0 = sdArrow2d(uv, vec2(-0.7, 0.5), vec2(-0.7, 0.5) + ld) - wd;\n    \n    float l1 = sdArrow2d(uv, vec2( 0.0, -0.2), vec2( 0.0, -0.2) + rd) - wd;\n    float l2 = sdArrow2d(uv, vec2( 0.0, -0.2), vec2( 0.0, -0.2) + rd + rdn * slider * 0.5) - wd;\n    float l3 = sdArrow2d(uv, vec2( 0.0, -0.2), vec2( 0.0, -0.2) + rd - rdn * slider * 0.5) - wd;\n    \n    float reflections = min(min(l1, l2), l3);\n    \n    float m = min(0.0, min(min(l0, reflections), t));\n    \n    if(m==t)           return vec4(0.9, 0.3, 0.0, 1.0);\n    if(m==l0)          return vec4(1.0);\n    if(m==reflections) return vec4(0.8);\n    else               return BG_COL;\n\n\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n  \n  // 3D BRDF graph\n  // ------------------------------------------------------------\n  if(isInsideRect(fragCoord, VIEW3D_POS, VIEW3D_POS+VIEW3D_SIZE))\n  {\n      vec2 uv = squareFrame(VIEW3D_POS.xy, VIEW3D_SIZE.xy , fragCoord.xy);\n      vec3 ro = vec3(3.0, 3.0, 3.0);\n      vec3 ta = vec3(0, 0, 0);\n      mat3 camMat = calcLookAtMatrix(ro, ta, -0.0);\n      vec3 rd = getRay(camMat, uv, 3.0);\n      RayIntersection t = calcRayIntersection(ro, rd, normalize(ta-ro), NEAR, FAR, 0.001);\n        \n      vec4 bgcol = BG_COL;\n\n      fragColor = t.d < FAR \n          ? mix(bgcol, t.c, t.c.a) // blend with background\n          : bgcol;\n          \n  }\n  \n  \n  // 2D BRDF graph\n  // ------------------------------------------------------------\n  else if(isInsideRect(fragCoord, VIEW2D_POS, VIEW2D_POS+VIEW2D_SIZE))\n  {\n      vec2 uv = squareFrame(VIEW2D_POS.xy, VIEW2D_SIZE.xy , fragCoord.xy);\n      fragColor = scene2d(uv);\n  }\n  \n  \n  // Sphere controller\n  // ------------------------------------------------------------\n  else if(isInsideRect(fragCoord, CTRL_POS, CTRL_POS+CTRL_SIZE))\n  {\n      vec2 mousePos = getCurrentMousePos();\n\n     \n      vec2 uv   = squareFrame(CTRL_POS.xy, CTRL_SIZE.xy , fragCoord.xy);\n      fragColor = controller(uv, mousePos);\n  }\n  \n  // Sliders and icons\n  // ------------------------------------------------------------\n  \n  // SLIDER ICON 0\n  else if(isInsideRect(fragCoord, SLIDER0_ICO_POS, SLIDER0_ICO_POS+SLIDER0_ICO_SIZE))\n  {\n      float sliderVal = getCurrentSlider0Value();\n      vec2 uv   = squareFrame(SLIDER0_ICO_POS.xy, SLIDER0_ICO_SIZE.xy , fragCoord.xy);\n     \n      fragColor = sliderIcon0(uv);\n  }\n  \n  // SLIDER 0\n  else if(isInsideRect(fragCoord, SLIDER0_POS, SLIDER0_POS+SLIDER0_SIZE))\n  {\n      float sliderVal = getCurrentSlider0Value();\n      vec2 uv   = squareFrame(SLIDER0_POS.xy, SLIDER0_SIZE.xy , fragCoord.xy);\n     \n      fragColor =  slider(uv, 2.0 * SLIDER0_SIZE.x/SLIDER0_SIZE.y, sliderVal);\n  }\n  \n  // SLIDER ICON 1\n  else if(isInsideRect(fragCoord, SLIDER1_ICO_POS, SLIDER1_ICO_POS+SLIDER1_ICO_SIZE))\n  {\n      float sliderVal = getCurrentSlider0Value();\n      vec2 uv   = squareFrame(SLIDER1_ICO_POS.xy, SLIDER1_ICO_SIZE.xy , fragCoord.xy);\n     \n      fragColor = sliderIcon1(uv);\n  }\n  \n  // SLIDER 1\n  else if(isInsideRect(fragCoord, SLIDER1_POS, SLIDER1_POS+SLIDER0_SIZE))\n  {\n      float sliderVal = getCurrentSlider1Value();\n      vec2 uv   = squareFrame(SLIDER1_POS.xy, SLIDER1_SIZE.xy , fragCoord.xy);\n     \n      fragColor =  slider(uv, 2.0 * SLIDER1_SIZE.x/SLIDER1_SIZE.y, sliderVal);\n  }\n  \n  else fragColor = BG_COL;\n  \n  \n \n  \n  \n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define PHONG        0\n#define BLINN_PHONG  1\n#define GGX          2\n\n///////  HOW TO USE ///////////////////////////////\n///////////////////////////////////////////////////\n//\n//     Replace `GGX` with `PHONG` or `BLINN_PHONG` \n//     to show the corresponding BRDF.\n//\n       #define MODEL GGX\n//\n////////////////////////////////////////////////////\n\n#if   MODEL == PHONG\n\n    #define BRDF(li, n, v) BRDF_phong(li, n, v, getCurrentSlider1Value())\n    \n#elif MODEL == BLINN_PHONG\n\n    #define BRDF(li, n, v) BRDF_blinnPhong(li, n, v, getCurrentSlider1Value())\n\n#elif MODEL == GGX\n\n    #define BRDF(li, n, v) BRDF_ggx(li, n, v, getCurrentSlider1Value())\n\n#endif\n\n#define PI   3.14159265359\n#define PI_2 1.57079632679\n#define PI_4 0.78539816339\n\n#define NEAR 4.0\n#define FAR  6.5\n#define LIGHT vec3(0.0, 0.0, 1.0)\n\n#define LIGHT_VEC_COL vec4(1.0, 1.0, 0.0, 1.0)\n#define   NRM_VEC_COL vec4(0.0, 0.0, 1.0, 1.0)\n#define   RFL_VEC_COL vec4(0.0, 1.0, 0.0, 1.0)\n#define   EYE_VEC_COL vec4(0.8, 0.8, 0.8, 1.0)\n#define   CTRL_COL    vec4(0.9, 0.3, 0.1, 1.0)\n#define   CRSH_COL    vec4(0.9, 0.9, 0.9, 1.0)\n\n#define BG_DARK       vec4(0.0, 0.0, 0.1, 1.0)\n#define BG_LIGHT      vec4(0.1 ,0.1, 0.2, 1.0)\n#define BG_COL       (mix(BG_LIGHT, BG_DARK,(length((gl_FragCoord.xy/iResolution.xy)*2.0-1.0)) - 1.3))\n\n#define VIEW3D_SIZE    (iResolution.xy*0.6)\n#define VIEW3D_POS     (vec2(0.0, iResolution.y - VIEW3D_SIZE.y))\n#define VIEW2D_SIZE    (vec2(VIEW3D_SIZE.x, VIEW3D_POS.y))\n#define VIEW2D_POS     (vec2(0.0, 0.0))\n#define CTRL_POS       (vec2(VIEW2D_SIZE))\n#define CTRL_SIZE      (iResolution.xy - vec2(VIEW2D_SIZE))\n\n#define SLIDER_H       (VIEW2D_SIZE.y*0.25)\n#define SLIDER0_POS    (vec2((CTRL_POS.x + CTRL_SIZE.x*0.5) - CTRL_SIZE.x*0.25, CTRL_POS.y - SLIDER_H))\n#define SLIDER0_SIZE   (vec2(CTRL_SIZE.x*0.5, SLIDER_H))\n#define SLIDER0_ICO_POS (vec2(SLIDER0_POS.x - SLIDER_H - 18.0, SLIDER0_POS.y))\n#define SLIDER0_ICO_SIZE (vec2(SLIDER_H))\n#define SLIDER1_POS    (vec2((CTRL_POS.x + CTRL_SIZE.x*0.5) - CTRL_SIZE.x*0.25, CTRL_POS.y - 2.0*SLIDER_H))\n#define SLIDER1_SIZE   (vec2(CTRL_SIZE.x*0.5, SLIDER_H))\n#define SLIDER1_ICO_POS (vec2(SLIDER1_POS.x - SLIDER_H - 18.0, SLIDER1_POS.y))\n#define SLIDER1_ICO_SIZE (vec2(SLIDER_H))\n\n#define CLK_TEX_UV     ivec2(0)\n#define SLIDER0_TEX_UV ivec2(4, 0)\n#define SLIDER1_TEX_UV ivec2(8, 0)\n\n#define DEFAULT_CTRL_VAL   (CTRL_POS + vec2(0.49, 0.36)*CTRL_SIZE)\n#define DEFAULT_SLIDER0_VAL 0.3\n#define DEFAULT_SLIDER1_VAL 0.12\n\n// PHONG \n// -------------------------------------------------------\nfloat BRDF_phong(\n                  vec3 li,    // incoming light direction \n                  vec3 n,     // surface normal\n                  vec3 v,     // view direction\n                  float param // [0-1] comes from the `roughness` slider \n                )\n{\n    float a = 8.0 + 8.0*(1.0 - param);\n    vec3  r = reflect(-li, n);\n    float d = max(0.0, dot(r, v));\n    \n    if(dot(v, n)<=0.0) \n        return 0.0;\n    \n    return pow(d, a);\n}\n\n// BLINN - PHONG \n// -------------------------------------------------------\nfloat BRDF_blinnPhong(\n                        vec3 li,    // incoming light direction \n                        vec3 n,     // surface normal\n                        vec3 v,     // view direction\n                        float param // [0-1] comes from the `roughness` slider \n                      )\n{\n    float a = 16.0 + 8.0*(1.0 - param);\n    vec3  h = normalize(li + v);\n    float d = max(0.0, dot(h, n));\n    \n    if(dot(v, n)<=0.0) \n        return 0.0;\n    \n    return pow(d, a);\n}\n\n// GGX\n// -------------------------------------------------------\n// from: https://cdn2.unrealengine.com/Resources/files/2013SiggraphPresentationsNotes-26915738.pdf\n// and : https://learnopengl.com/PBR/Lighting\nvec3 fresnelSchlick(float cosTheta, vec3 F0)\n{\n    return F0 + (1.0 - F0) * pow(clamp(1.0 - cosTheta, 0.0, 1.0), 5.0);\n}\n\nfloat DistributionGGX(vec3 N, vec3 H, float roughness)\n{\n    float NdotH = max(0.0, dot(N, H));\n    float a2 = roughness * roughness;\n\tfloat d = (NdotH * NdotH * (a2 - 1.0)) + 1.0;\n\treturn a2 / (d * d * PI);\n}\n\nfloat GeometrySchlickGGX(float NdotV, float roughness)\n{\n    float r = (roughness + 1.0);\n    float k = (r*r) / 8.0;\n\n    float num   = NdotV;\n    float denom = NdotV * (1.0 - k) + k;\n\t\n    return num / denom;\n}\n\nfloat GeometrySmith(vec3 N, vec3 V, vec3 L, float roughness)\n{\n    float NdotV = max(dot(N, V), 0.0);\n    float NdotL = max(dot(N, L), 0.0);\n    float ggx2  = GeometrySchlickGGX(NdotV, roughness);\n    float ggx1  = GeometrySchlickGGX(NdotL, roughness);\n\t\n    return ggx1 * ggx2;\n}\n\nfloat BRDF_ggx(\n                vec3 li,    // incoming light direction \n                vec3 n,     // surface normal\n                vec3 v,     // view direction\n                float param // [0-1] comes from the `roughness` slider \n              )\n{\n    \n    float roughness = param;\n    \n    vec3 F0 = vec3(0.04); // dielectric\n    \n    vec3 H = normalize(v + li);\n  \n        \n    // cook-torrance brdf\n    float NDF = DistributionGGX(n, H, roughness);        \n    float G   = GeometrySmith(n, v, li, roughness);      \n    vec3 F    = fresnelSchlick(max(dot(H, v), 0.0), F0);       \n        \n    vec3 kS = F;\n        \n    vec3 numerator    = NDF * G * F;\n    float denominator = 4.0 * max(dot(n, v), 0.0) * max(dot(n, li), 0.0) + 0.0001;\n    vec3 specular     = numerator / denominator;  \n        \n    float NdotL = max(dot(n, li), 0.0);                \n        \n    return specular.x * NdotL;\n}\n\n\n///////////////////////////////////////////// UTILS //////////////////////////////////////////////////////////////////////////\nstruct dc\n{\n    float d;\n    vec4 c;\n};\nbool isInsideRect(vec2 p, vec2 boxmin, vec2 boxmax)\n{\n    return \n    p.x<boxmax.x && p.x>=boxmin.x &&\n    p.y<boxmax.y && p.y>=boxmin.y; \n}\n// from: scratchapixel.com/lessons/3d-basic-rendering/minimal-ray-tracer-rendering-simple-shapes/ray-sphere-intersection.html\n// -----------------------------------------------------\nfloat dstSphereLine(vec3 c, float r, vec3 lo, vec3 ld)\n{\n\n        float t0, t1; // solutions for t if the ray intersects\n\n        // geometric solution\n        vec3 L = c - lo;\n        float tca = dot(L, ld);\n        // if (tca < 0) return false;\n        float d2 = dot(L, L) - tca * tca;\n        if (d2 > r*r) return -1.0;\n        float thc = sqrt(r*r - d2);\n        t0 = tca - thc;\n        t1 = tca + thc;\n\n        if (t0 > t1)\n        {\n            float b = t0;\n            t0=t1;\n            t1=b;\n        }\n\n        if (t0 < 0.0) {\n            t0 = t1; // if t0 is negative, let's use t1 instead\n            if (t0 < 0.0) return -1.0; // both t0 and t1 are negative\n        }\n\n        float t = t0;\n\n        return t;\n}\n\nfloat dstPointLine(vec3 p, vec3 lo, vec3 ld, float len)\n{\n    return length((p - lo) - min(len, max(0.0, dot(p - lo, ld)))*ld);  \n}\nfloat dstPointLine(vec2 p, vec2 lo, vec2 ld, float len)\n{\n    return length((p - lo) - min(len, max(0.0, dot(p - lo, ld)))*ld);  \n}\nfloat dstPointLine(vec2 p, vec2 s, vec2 e)\n{\n    vec2 dir = e-s;\n    float len = length(dir);\n    return dstPointLine(p, s, dir/len, len);\n}\nfloat dstLineLine(vec3 p1, vec3 l1, vec3 p2, vec3 l2)\n{\n    const float lineLen = 1.3;\n    vec3 l3 = normalize(cross(l2, l1));\n    vec3 n  = normalize(cross(l3, l1)); // billboard plane nrm\n    \n    float d =  dot(p1 - p2, n) / dot(l2, n);  \n    vec3 inter = p2 + d*l2;\n    \n    // line - point distance\n    float lpd = dstPointLine(inter, p1, l1, lineLen);\n    \n    if(lpd < 0.01) return d;\n                   return FAR;\n}\nfloat dstLinePlane(vec3 lo, vec3 ld, vec3 po, vec3 pn)\n{\n    return length(dot(po-lo, pn) / dot(ld, pn));\n}\nfloat sdStar( in vec2 p, in float r, in int n, in float m)\n{\n    // from: https://iquilezles.org/articles/distfunctions2d/\n\n    // next 4 lines can be precomputed for a given shape\n    float an = 3.141593/float(n);\n    float en = 3.141593/m;  // m is between 2 and n\n    vec2  acs = vec2(cos(an),sin(an));\n    vec2  ecs = vec2(cos(en),sin(en)); // ecs=vec2(0,1) for regular polygon\n\n    float bn = mod(atan(p.x,p.y),2.0*an) - an;\n    p = length(p)*vec2(cos(bn),abs(sin(bn)));\n    p -= r*acs;\n    p += ecs*clamp( -dot(p,ecs), 0.0, r*acs.y/ecs.y);\n    return length(p)*sign(p.x);\n}\n\nfloat sdCircle( vec2 p, float r )\n{\n    return length(p) - r;\n}\n\nfloat sdVesica(vec2 p, float r, float d)\n{\n    p = abs(p);\n    float b = sqrt(r*r-d*d);\n    return ((p.x-b)*d>p.y*b) ? length(p-vec2(0.0,b))\n                             : length(p-vec2(0.0,-d))-r;\n}\n\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nmat3 calcLookAtMatrix(vec3 origin, vec3 target, float roll) {\n  vec3 rr = vec3(sin(roll), cos(roll), 0.0);\n  vec3 ww = normalize(target - origin);\n  vec3 uu = normalize(cross(ww, rr));\n  vec3 vv = normalize(cross(uu, ww));\n\n  return mat3(uu, vv, ww);\n}\n\nstruct RayIntersection\n{\n    float d;\n    vec3  n;\n    vec4  c;\n};\n\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Sphere-controller click\n    // ------------------------------------\n    if(fragCoord-0.5 == vec2(CLK_TEX_UV))\n    {\n        if(!isInsideRect(iMouse.xy, CTRL_POS, CTRL_POS+CTRL_SIZE) ||\n            length(iMouse.xy-CTRL_POS-CTRL_SIZE*0.5) > 0.3*CTRL_SIZE.y) // not the nicest way to limit cursor position onto the sphere...\n                \n                discard;\n        \n        fragColor =vec4(iMouse.xy, 0.0, 0.0);\n    }\n    \n    \n    // Slider 0 (light)\n    // ------------------------------------\n    else if(fragCoord-0.5 == vec2(SLIDER0_TEX_UV))\n    {\n    \n        if(!isInsideRect(iMouse.xy, SLIDER0_POS, SLIDER0_POS+SLIDER0_SIZE)) discard;\n        \n       \n        float val = (iMouse.x - SLIDER0_POS.x) / SLIDER0_SIZE.x;\n        val = max(0.05, min(0.95, val));\n        fragColor =vec4(val,0.0, 0.0, 0.0);\n    }\n    \n    \n    // Slider 1 (roughness)\n    // ------------------------------------\n    else if(fragCoord-0.5 == vec2(SLIDER1_TEX_UV))\n    {\n    \n        if(!isInsideRect(iMouse.xy, SLIDER1_POS, SLIDER1_POS+SLIDER1_SIZE)) discard;\n        \n       \n        float val = (iMouse.x - SLIDER1_POS.x) / SLIDER1_SIZE.x;\n        val = max(0.05, min(0.95, val));\n        fragColor =vec4(val,0.0, 0.0, 0.0);\n    }\n    \n    else discard;\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// --------------------------------------- //\n//        ++       !!! ATTENTION !!!       //\n//       //\\\\                              //\n//      //  \\\\     Duplicate code, keep    //\n//     // || \\\\    in sync with `Image`    //\n//    //  ||  \\\\                           //\n//   //   <>   \\\\                          //\n//  ++==========++                         //\n// --------------------------------------- //\nvec2 squareFrame(vec2 screenPos, vec2 screenSize, vec2 coord) {\n\n  vec2 position = ((coord.xy - screenPos.xy) / screenSize.xy);\n  position = position*2.0 - 1.0;\n  position.x*=screenSize.x/screenSize.y;\n  return position;\n}\n\nvec3 getRay(mat3 camMat, vec2 screenPos, float lensLength) {\n  return normalize(camMat * vec3(screenPos, lensLength));\n}\n\nvec2 getCurrentMousePos() // on the controller rect \n{\n  vec2 mousePos = texelFetch(iChannel0, CLK_TEX_UV, 0).xy;    \n  if(mousePos == vec2(0.0)) mousePos = DEFAULT_CTRL_VAL;\n  return squareFrame(CTRL_POS.xy, CTRL_SIZE.xy , mousePos);\n}\n\nvec3 getViewDirOnSphere(vec2 uv)\n{\n    const vec3 sphereCenter = vec3(0.0, 0.0, 2.5);\n    return getRay(mat3(1.0), uv, 3.0);\n}\n\nvec3 getCurrentViewDir()\n{\n    return getViewDirOnSphere(getCurrentMousePos());\n}\n\nvec3 getNormalOnSphere(vec2 uv)\n{\n    const vec3 sphereCenter = vec3(0.0, 0.0, 2.5);\n    \n    vec3 rd = getViewDirOnSphere(uv);\n    \n    float d = dstSphereLine(sphereCenter, 0.5, vec3(0.0), rd);\n    \n    return d > 0.0 ? normalize(d*rd - sphereCenter) : vec3(0.0, 0.0, 1.0);\n}\n\nvec3 getCurrentNormal()\n{\n    return getNormalOnSphere(getCurrentMousePos());\n}\n\nfloat getCurrentSlider0Value()\n{\n    // 0 to 1 parameter\n    float p = texelFetch(iChannel0, SLIDER0_TEX_UV, 0).r;\n    if(p==0.0) p=DEFAULT_SLIDER0_VAL;\n    return p;\n\n}\nfloat getCurrentSlider1Value()\n{\n    // 0 to 1 parameter\n    float p = texelFetch(iChannel0, SLIDER1_TEX_UV, 0).r;\n    if(p==0.0) p=DEFAULT_SLIDER1_VAL;\n    return p;\n\n}\n\nvec3 getLightDir()\n{\n    float param = getCurrentSlider0Value();\n    \n    const vec3 y = normalize(vec3(-1.0, 1.0, 0.0));\n    const vec3 z = vec3(0.0, 0.0, 1.0);\n    const vec3 x = cross(y, z);\n    const mat3 t = mat3(x, y, z);\n    \n    // -PI/4 to 3/4 PI\n    float angle  = param * PI - PI_4;\n    vec3  light  = t*vec3(cos(angle), 0.0, sin(angle));\n    \n    return -light;\n\n}\n// end of duplicate code ...\n\n\ndc sdSceneFixedStep(vec3 p)\n{\n\n   // graph reference frame - normal is always positive y \n   // --------------------------------------------------\n   vec3 normal =  getCurrentNormal();\n   vec3 light  =  getLightDir();\n   vec3 eye    = -getCurrentViewDir();\n   \n   vec3 ty = normal;\n   vec3 tz = normalize(cross(normal, vec3(0.0, 1.0, 0.0)));\n   vec3 tx = cross(ty, tz);\n   \n   mat3 tr = transpose(mat3(tx, ty, tz));\n   eye    = tr*eye;\n   light  = tr*light;\n   normal = tr*normal;\n   // --------------------------------------------------\n    \n    const vec3 o = vec3(0.0, 0.0, 0.0);\n    vec3 reflec = reflect(-light, normal);\n    \n    vec3 v = p-o;\n    float dO = length(v); \n    float val = BRDF(light,normal,v/dO);\n    float d = dO -val;\n    \n    vec4 c = vec4(0.7, 0.1, 0.2, 1.0);\n    \n    dc r;\n    r.d=d;\n    r.c=vec4(c.rgb*val, 1.0);\n    return r;\n}\n\nRayIntersection rayMarchFixedStep(vec3 rayOrigin, vec3 rayDir, float mind, float maxd, float precis) {\n  \n  float dist   = mind;\n  float type   = -1.0;\n  vec3  nrm    = vec3(1.0, 0.0, 0.0);\n  \n  RayIntersection res;\n  res.d = maxd;\n  res.n = nrm;\n  \n  const int iter = 300;\n  float dstep = (maxd-mind)/float(iter);\n  \n  res.c = vec4(0.9, 0.2, 0.0, 1.0);\n  \n  for (int i = 0; i <=iter; i++) {\n    \n    if (dist >= maxd) {res.d = maxd; break;}\n    \n    dc d = sdSceneFixedStep(rayOrigin + rayDir * dist);\n    \n    if (d.d<0.0) \n    {\n        res.d = dist;\n        res.c = d.c;\n        break;\n    }\n    \n    dist += dstep;\n  }\n\n  \n  \n  return res;\n}\n\nvec3 calcEyePos(vec3 camOrigin, vec3 ray, float t, mat3 viewMat)\n{\n    return transpose(viewMat) * (ray* t);\n   \n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n  \n  // 3D BRDF graph\n  // ------------------------------------------------------------\n  if(isInsideRect(fragCoord, VIEW3D_POS, VIEW3D_POS+VIEW3D_SIZE))\n  {\n      vec2 uv = squareFrame(VIEW3D_POS.xy, VIEW3D_SIZE.xy , fragCoord.xy);\n      vec3 ro = vec3(3.0, 3.0, 3.0);\n      vec3 ta = vec3(0, 0, 0);\n      mat3 camMat = calcLookAtMatrix(ro, ta, -0.0);\n      vec3 rd = getRay(camMat, uv, 3.0);\n      RayIntersection t = rayMarchFixedStep(ro, rd,  NEAR, FAR, 0.001);\n     \n      fragColor = vec4(calcEyePos(ro, rd, t.d, camMat), t.d);\n  }\n}","name":"Buffer B","description":"","type":"buffer"}]}