{"ver":"0.1","info":{"id":"td2fzt","date":"1590640434","viewed":67,"name":"IFS Menger Sponge Fold","username":"TAKUSAKU","description":"IFS Menger Sponge Fold","likes":0,"published":1,"flags":32,"usePreview":0,"tags":["ifs","fold","mengersponge"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//chromatic aberration\n//https://www.shadertoy.com/view/wsVXzW\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 delta = (uv - 0.5) * 0.05;\n    fragColor.r = texture(iChannel0,uv + delta*sin(iTime)).r;\n    fragColor.g = texture(iChannel0,uv).g;\n    fragColor.b = texture(iChannel0,uv + delta*cos(iTime)).b;\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"const float PI = 3.14159265;\nconst vec3 lightDir = vec3(-0.797,0.857,0.577);\n\nfloat rand (in vec2 _st) {\n    return fract(sin(dot(_st.xy, vec2(-0.370,0.200)))*757.161);\n}\n\n// IFS MengerSponge fold\n// https://gam0022.net/blog/2019/06/25/unity-raymarching/\n// -----------------------------------------\n#define ITERATIONS 4\n\nvec3 _MengerOffset = vec3(1.000,0.072,0.414);\nfloat _MengerScale = 2.9;\nfloat _MengerFold = 3.;\n\n//  IFS MengerSponge　DistanceFunction\nfloat dMenger(vec3 z0, vec3 offset, float scale) {\n    vec4 z = vec4(z0, 1.0);\n    for (int n = 0; n < ITERATIONS; n++) {\n        z = abs(z);\n\n        if (z.x < z.y) z.xy = z.yx;\n        if (z.x < z.z) z.xz = z.zx;\n        if (z.y < z.z) z.yz = z.zy;\n\n        z *= scale;\n        z.xyz -= offset * (scale - 1.0);\n\n        if (z.z < -0.5 * offset.z * (scale - 1.0))\n            z.z += offset.z * (scale - 1.0);\n    }\n    return (length(max(abs(z.xyz) - vec3(1.0, 1.0, 1.0), 0.0)) - 0.05) / z.w;\n}\n\n// 2D rotate\nmat2 rotate(in float a) {\n    float s = sin(a), c = cos(a);\n    return mat2(c, s, -s, c);\n}\n\n// Deformation used folding\n// https://www.shadertoy.com/view/Mlf3Wj\nvec2 foldRotate(in vec2 p, in float s) {\n    float a = PI / s - atan(p.x, p.y);\n    float n = PI*2. / s;\n    a = floor(a / n) * n;\n    p *= rotate(a);\n    return p;\n}\n\n// Final DistanceFunction\nfloat map(vec3 pos) {\n    // 回転foldの適用\n    pos.xy = foldRotate(pos.xy, _MengerFold);\n    //pos.xz = foldRotate(pos.xz, _MengerFold);\n    pos.yz = foldRotate(pos.yz, _MengerFold);\n\n    return dMenger(pos, _MengerOffset, _MengerScale);\n}\n// -----------------------------------------\n\n// Background light\nvec3 background(float t, vec3 rd){\n\tfloat bg = max(0.0, dot(rd, vec3(0.0, 0.5, 0.1)));\n\treturn pow(bg, -0.01)*vec3(0.165,0.617,0.675);\n    \t   \n}\n\n// Normal\nvec3 getNormal(vec3 p){\n    const vec2 e = vec2(0.001, 0.0);\n\treturn normalize(vec3(\n\t\tmap(p + e.xyy) - map(p - e.xyy),\n\t\tmap(p + e.yxy) - map(p - e.yxy),\n\t\tmap(p + e.yyx) - map(p - e.yyx)));\n}\n// -----------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n    \n    // camera\n    float pscale = 1.0 + 0.85*cos(iTime*0.5);;\n    \n    vec3 cPos = vec3(pscale*cos(iTime*0.5), 0.0, pscale*sin(iTime*0.5));\n    vec3 cDir = vec3(1.*sin(iTime*0.5+PI*1.5), 0.0, -1.*cos(iTime*0.5+PI*1.5));\n    vec3 cUp  = vec3(0.0, 1.0, 0.0);\n    vec3 cSide = cross(cDir, cUp);\n    float targetDepth = 1.2;\n     \n    // ray\n    vec3 ray = normalize(cSide * p.x + cUp * p.y + cDir * targetDepth);\n    \n    // marching loop\n    float dist = 0.0;\n    float rLen = 0.0;\n    vec3  rPos = cPos;\n    vec3  rd = cDir;\n    for(int i = 0; i < 42; i++){\n        dist = map(rPos);\n        rLen += dist;\n        rPos = cPos + ray * rLen;\n    }\n    \n    // hit check\n    vec3 color;\n    if(abs(dist) < 0.001){\n        vec3 normal = getNormal(rPos);\n        float diff = clamp(dot(lightDir, normal), 0.1, 1.0);\n        color = vec3(0.835,0.821,0.643) * diff;\n        rd = reflect(rd, normal);\n    }else{\n        color = vec3(0.0);\n    }\n    \n    vec3 bgCol = background(iTime, rd);\n    \n\tfragColor = vec4( bgCol, 1.0 );\n}","name":"Buf A","description":"","type":"buffer"}]}