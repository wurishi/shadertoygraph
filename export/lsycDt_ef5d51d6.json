{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[],"code":"const int MAX_MARCHING_STEPS = 256;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float EPSILON = 0.001;\n\nfloat opU( float d1, float d2 )\n{\n    return min(d1,d2);\n}\n\nfloat opS( float d1, float d2 )\n{\n    return max(-d1,d2);\n}\n\nfloat opI( float d1, float d2 )\n{\n    return max(d1,d2);\n}\n\nvec3 translate(vec3 pos, vec3 tr)\n{\n \treturn pos - tr;   \n}\n\nfloat sdfTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat sdfSphere(vec3 pos, float size)\n{\n \treturn length(pos) - size;   \n}\n\nfloat sdfCube(vec3 pos, vec3 size)\n{\n \treturn length(max(abs(pos)-size,0.0));   \n}\n\nfloat sdfCubeArray(vec3 pos, vec3 size, vec3 dist)\n{\n    vec3 q = mod(pos,dist)-0.5*dist;\n    return sdfCube(q, size);\n}\n\nfloat sdfSphereArray(vec3 pos, float radius, vec3 dist)\n{\n    vec3 q = mod(pos,dist)-0.5*dist;\n    return sdfSphere(q, radius);\n}\n\nfloat sdfPlane(vec3 pos, float level) {\n    return pos.y-level;   \n}\n\n\nfloat sdfScene(vec3 pos) {\n    \n    vec3 cubePos = translate(pos, vec3(3,0,0));\n    vec3 otherCubePos = translate(pos, vec3(-3,0,0));\n    vec3 spherePos = translate(pos, vec3(0,0,3));\n    vec3 otherSpherePos = translate(pos, vec3(0,0,-3));\n    //return opU(sdfSphere(pos, 1.0), sdfPlane(pos, -1.0));\n    //return opU(sdfSphereArray(pos, 1.0, vec3(3,0,3)), sdfPlane(pos, -1.0));\n    //return opU(sdfCube(pos, vec3(1.0)), sdfPlane(pos, -1.0));\n    //return opU(sdfCubeArray(pos, vec3(0.25), vec3(1,0,1)), sdfPlane(pos, -1.0));\n    //return sdfPlane(pos, -1.0);\n    return opU(sdfPlane(pos, -1.0),\n               opU(\n               \t\topU(sdfCube(cubePos, vec3(1.0)),\n                \t\tsdfTorus(otherCubePos, vec2(1.666, 0.666))),\n               \t\topU(sdfSphere(spherePos, 1.0),\n                \t\tsdfSphere(otherSpherePos, 1.0))));\n               \n    \n}\n\nfloat softshadow(vec3 point, vec3 dir, float k)\n{\n \tfloat res = 1.0;\n    for (float t=100.0*EPSILON; t<MAX_DIST; )\n    {\n        float h = sdfScene(point+t*dir);\n        if (h < EPSILON) return 0.0;\n        res = min(res, k*h/t);\n        t += h;\n    }\n    return res;\n}\n\nvec2 phong(vec3 N, vec3 L, vec3 V, float kD, float kS, float shiny)\n{\n    float NdotL = max(0.0, dot(N,L));\n    float diffuse = kD * NdotL;\n    vec3 H = normalize(L-V);\n    float NdotH = max(0.0, dot(N,H));\n    float specular = kS*pow(NdotH, shiny);\n    return vec2(diffuse, specular);\n}\n\n\nvec3 normal(vec3 p)\n{\n\treturn normalize(vec3(\n        sdfScene(vec3(p.x + EPSILON, p.y, p.z)) - sdfScene(vec3(p.x - EPSILON, p.y, p.z)),\n        sdfScene(vec3(p.x, p.y + EPSILON, p.z)) - sdfScene(vec3(p.x, p.y - EPSILON, p.z)),\n        sdfScene(vec3(p.x, p.y, p.z  + EPSILON)) - sdfScene(vec3(p.x, p.y, p.z - EPSILON))));\n}\n\nfloat raymarch(vec3 eye, vec3 ray)\n{\n    float depth = MIN_DIST;\n    \n    for (int i=0; i<MAX_MARCHING_STEPS; ++i) \n    {\n    \tfloat dist = sdfScene(eye + depth * ray);\n        \n        if (dist < EPSILON)\n        {\n         \treturn depth;   \n        }\n        \n        depth += dist;\n        \n        if (depth >= MAX_DIST) return MAX_DIST;\n    }\n    \n    return MAX_DIST;\n}   \n\nmat4 lookAt(vec3 eye, vec3 center, vec3 up)\n{\n    vec3 f = normalize(center - eye);\n\tvec3 s = normalize(cross(f, up));\n\tvec3 u = cross(s, f);\n\treturn mat4(\n\t\tvec4(s, 0.0),\n\t\tvec4(u, 0.0),\n\t\tvec4(-f, 0.0),\n\t\tvec4(0.0, 0.0, 0.0, 1)\n\t);\n}\t\n\nvec3 ray(float fovY, vec2 resolution, vec2 fragCoord)\n{\n\tvec2 xy = fragCoord - resolution / 2.0;\n    float z = resolution.y / tan(radians(fovY) / 2.0);\n    return normalize(vec3(xy, -z));\n\n}\n\n\nvec3 phongMaterial(vec3 point, vec3 light, vec3 n, vec3 ray)\n{\n    vec3 color;\n    if (point.y<(-1.0+EPSILON)) color = vec3(0.4, 0.8, 0.2);\n    else color = vec3(0.8, 0.2, 0.4);\n\n    vec2 ph = phong(n, light, ray, 1.0, 0.75, 40.0);\n    float shadow = softshadow(point, light, 4.0);\n    return shadow*(color*ph.x + (2.0*shadow-1.0)*vec3(1)*ph.y);\n}\n\nbool shiny(vec3 point)\n{\n \treturn (sdfCube(translate(point, vec3(3,0,0)), vec3(1.0)) < EPSILON) ||\n        (sdfSphere(translate(point, vec3(0,0,3)), 1.0) < EPSILON);\n}\n\nint REFLECTION_COUNT = 1;\n\nvec3 material(vec3 point, vec3 light, vec3 norm, vec3 ray)\n{\n    /*\n    bool shiny = shiny(point);\n    if (shiny) \n    {\n       vec3 reflectDir = reflect(ray, normal);\n       float reflectDist = raymarch(point - EPSILON*ray, reflectDir);\n       vec3 reflection;\n       if (reflectDist >= MAX_DIST) reflection = vec3(0);\n       else \n       {\n           vec3 reflectPoint = point + reflectDir * reflectDist;\n           vec3 reflectNormal = normal(reflectPoint);\n           reflection = phongMaterial(reflectPoint, light, reflectNormal, reflectDir);       \n       }\n       \n       return reflection + vec3(1)*phong(normal, light, ray, 0.0, 1.0, 80.0).y; \n    }\n    else \n    {\n     \treturn phongMaterial(point, light, normal, ray);\n    }\n*/\n    \n    if (!shiny(point)) {\n     \treturn phongMaterial(point, light, norm, ray);\n    }\n    \n    vec3 p = point;\n    vec3 n = norm;\n    vec3 r = ray;\n    vec3 reflection = vec3(0);\n    int i;\n    \n    for (i=0; i<REFLECTION_COUNT; ++i)\n    {        \n        vec3 reflectDir = reflect(r, n);\n        float reflectDist = raymarch(p - EPSILON*r, reflectDir);\n        if (reflectDist >= MAX_DIST){\n         \treflection =  vec3(0);\n            break;\n        }\n        \n        r = reflectDir;\n        p += r * reflectDist;\n        n = normal(p);\n        \n        if (i == REFLECTION_COUNT - 1 || !shiny(p+EPSILON*r))\n        {\n         \treflection = phongMaterial(p, light, n, r);\n            break;\n        }\n    }\n    \n    return reflection + vec3(1)*phong(n, light, r, 0.0, 1.0, 80.0).y;\n    //return shiny(p-EPSILON*r) ? vec3(1) : vec3(0);\n    //float ii = float(i);\n    //return vec3(ii/2.0,0,ii/2.0);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 viewRay = ray(70.0, iResolution.xy, fragCoord);\n    vec3 eye = vec3(-10.0*cos(iTime),4,-10.0*sin(iTime));\n    mat4 world = lookAt(eye, vec3(0,0,0), vec3(0,1,0));\n    vec3 worldRay = (world * vec4(viewRay, 0.0)).xyz;\n    \n    float dist = raymarch(eye, worldRay);    \n    \n    if (dist >= MAX_DIST) \n    {\n     \tfragColor.rgb = vec3(0.0);\n        return;\n    }\n    \n    vec3 point = eye + worldRay * dist;\n    //vec3 n = (transpose(world)*vec4(normal(point),0)).xyz;\n    vec3 n = normal(point);\n    //vec3 lightVector = vec3(10.0*sin(0.784*iTime),10,10.0*cos(0.784*iTime))-point;\n    vec3 lightVector = vec3(0,5,0) - point;\n    \n    //vec3 light = (10.0/dot(lightVector, lightVector))*normalize(lightVector);\n    vec3 light = normalize(vec3(1,1,1));\n    vec2 ph = phong(n, light, worldRay, 1.0, 0.75, 40.0);\n    float shadow = softshadow(point, light, 4.0);\n    //float shadow = 1.0;\n    \n    fragColor.rgb = material(point, light, n, worldRay);\n    //fragColor.rgb = vec3(0.5) + 0.5*n;\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"lsycDt","date":"1683671831","viewed":17,"name":"danix raymarch","username":"marcosdanix","description":"Just a little raymarching","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raymarch"],"hasliked":0,"parentid":"","parentname":""}}