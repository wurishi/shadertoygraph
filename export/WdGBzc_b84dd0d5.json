{"ver":"0.1","info":{"id":"WdGBzc","date":"1607604716","viewed":89,"name":"Raymarching Color Mask","username":"Kiltun","description":"Small test about color mask with raymarching","likes":0,"published":1,"flags":48,"usePreview":0,"tags":["raymarching","color","mask"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n        \n    vec4 out_color = texture(iChannel0, uv);\n\tfragColor = out_color;\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"\nint slotid(ivec2 loc) { return loc.x; }\nivec2 slotloc(int id) { return ivec2(id, 0); }\n\nvec4 loadValue(sampler2D buf, int slot_id)\n{\n    return texelFetch(buf, slotloc(slot_id), 0);\n}\n\n\nconst int slotCameraPosition = 0;\nconst int slotCameraRotation = 1;\n\nvec3 cameraPosition(sampler2D BufC) \n{\n    return loadValue(BufC, slotCameraPosition).xyz;\n}\n\nvec3 cameraRotation(sampler2D BufC) \n{\n    return loadValue(BufC, slotCameraRotation).xyz;\n}\n\n\n//// ROTATION\n\nconst float pi = acos(-1.); //3.141592;\n\n// e^(i*rads) Euler's formula complex spinor\nvec2 cossin(float r)\n{\n    return sin(r + vec2(.5*pi, 0));\n}\n\n\nmat2 mrot(vec2 s)\n{\n    return mat2(s.x, -s.y, s.y, s.x);\n} // then can q.xz = mrot(cossin(a)) * q.xz;\n\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"const int KEY_LEFT  = 37;\nconst int KEY_UP    = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN  = 40;\n\nconst int KEY_W = 87;\nconst int KEY_Z = 90;\nconst int KEY_A = 65;\nconst int KEY_S = 83;\nconst int KEY_Q = 81;\nconst int KEY_D = 68;\nconst int KEY_SHIFT = 16;\nconst int KEY_SPACE = 32;\nconst int KEY_C = 67;\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 ip = ivec2(fragCoord);\n    vec3 o = cameraPosition(iChannel1);\n    float deltaTime = iTimeDelta;\n    \n    float zMov = texelFetch( iChannel0, ivec2(KEY_Z,0), 0 ).x - texelFetch( iChannel0, ivec2(KEY_S,0), 0 ).x;\n    float yMov = texelFetch( iChannel0, ivec2(KEY_SPACE,0), 0 ).x - texelFetch( iChannel0, ivec2(KEY_C,0), 0 ).x;\n    float xMov = texelFetch( iChannel0, ivec2(KEY_D,0), 0 ).x - texelFetch( iChannel0, ivec2(KEY_Q,0), 0 ).x;\n    float boost = texelFetch( iChannel0, ivec2(KEY_SHIFT,0), 0 ).x * 4.;\n    \n    deltaTime *= 1. + (boost);\n    o += (vec3(xMov * deltaTime,yMov * deltaTime, zMov * deltaTime));\n    \n    vec3 newPos = o;       \n    fragColor.xyz = newPos;\n\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"\n#define ITERATIONS 32\n\nfloat opSmoothUnion( float d1, float d2, float k ) \n{\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); \n}\n\nvec2 Union(vec2 d1, vec2 d2)\n{\n    vec2 myOutput;\n    \n    myOutput.x = opSmoothUnion(d1.x, d2.x, (sin(iTime) * 0.5 + 0.5) * .4);\n    //myOutput.y = (d1.x<d2.x) ?  d1.y : d2.y;\n    \n    myOutput.y = mix(d1.y, d2.y,smoothstep(0.0, 0.1 ,myOutput.x)) ;\n    \n    return myOutput;\n}\n\nvec2 map(vec3 p)\n{\n    p = fract(p) * 2. -1.;\n    vec2 sqt = vec2(length(p) - 0.25, 0.0);\n    sqt = Union(sqt, vec2(length(p+ vec3(0.5,0.5,0.0))- 0.25, 1.0));\n    sqt = Union(sqt, vec2(length(p+ vec3(-0.5,0.5,0.0))- 0.25, 2.0));\n    sqt = Union(sqt, vec2(length(p+ vec3(0.5,-0.5,0.0))- 0.25, 3.0));\n    sqt = Union(sqt, vec2(length(p+ vec3(0.0,0.5,0.0))- 0.25, 4.0));\n    sqt = Union(sqt, vec2(length(p+ vec3(0.5,0.0,0.0))- 0.25, 5.0));\n    sqt = Union(sqt, vec2(length(p+ vec3(0.0,-0.5,0.0))- 0.25, 6.0));\n    sqt = Union(sqt, vec2(length(p+ vec3(-0.5,0.0,0.0))- 0.25, 7.0));\n    sqt = Union(sqt, vec2(length(p + vec3(-0.5,-0.5,0.0))- 0.25, 8.0));\n    \n    \n    return sqt;\n} \n\nvec3 trace(vec3 o, vec3 r)\n{\n    float t = 0.;\n    vec3 outColor;\n    for(int i = 0; i < ITERATIONS; i++)\n    {\n    \tvec3 p = o + r * t;\n        vec2 d = map(p);\n        \n        if(d.x < 0.001)\n        {\n            //vec3 col1 = vec3(sin(iTime) * 0.5 + 0.5,cos(iTime * 2.0) * 0.5 + 0.5,0.0);\n            vec3 col1 = vec3(1.0, 0.0,0.0);\n            vec3 col2 = vec3(0.0,0.0,1.0);\n            outColor = mix(col1, col2, d.y / 8.0 );\n            return outColor;\n        }\n        \n        t += d.x * 0.5;\n    }\n    //return t;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv = uv * 2.0 -1.0;\n    uv.x *= iResolution.x / iResolution.y;\n\n    vec3 r = normalize(vec3(uv, 1.0));\n    /*r.zx *= mrot(cossin(iTime));\n    r.zy *= mrot(cossin(iTime));*/\n       \n    vec3 o = cameraPosition(iChannel1);\n        \n    vec3 t = trace(o,r);\n    /*vec3 ball1 = 1. / vec3(t,t,t);\n    vec3 ball1Color = vec3(0.4,0.5,0.1);\n    ball1 *= ball1Color;*/\n    \n   /* float ti = trace(o + vec3(0.5,0.5,0.0),r);\n    vec3 ball2 = 1. / vec3(ti,ti,ti);\n    vec3 ball2Color = vec3(0.7,0.2,0.1);\n    ball2 *= ball2Color;*/\n    \n    //float fog = 1. / (1. + t * t* 0.1);\n    \n    //vec3 fc = vec3(fog);\n    \n    //vec3 fini = vec3(max(ball1, ball2));\n\n    fragColor = vec4(t,1.0);\n}","name":"Buffer B","description":"","type":"buffer"}]}