{"ver":"0.1","info":{"id":"7tGGzD","date":"1637247774","viewed":120,"name":"Fork mat4 Mandelbrot Decomp","username":"akohdr","description":"Decomposing mat4 Mandelbrot provides fertile bed for experimentation.  \nTry dropping t variable into various spots in the matrices or applying your own functions to any of elements.\n\n","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["mandelbrot","matrix"],"hasliked":0,"parentid":"7tVGzh","parentname":"mat4 Mandelbrot "},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Created by Andrew Wild - akohdr/2021\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\nvoid mainImage( out vec4 k, vec2 p )\n{\n   // change of coordinates from screen to complex plane\n   vec2 c = p-iResolution.xy/2.; c/= iResolution.y/2.4; \n   \n   // center the mandelbrot\n   c -= vec2(.5,0); \n   \n   // initialize\n   vec4 z = vec4(1);\n   \n   // temporal adjustment of initial condition produces morph\n   float t = max(0.,2. - 2.4*sin(iTime/3.));\n   z *= vec4(t,-t,1,1);\n\n   z = vec4(0,0,0,1);  // start from origin or not by commenting\n   t = sin(iTime);     // provides +/- 1 temporal variable for dropping into matrix\n   \n   // main loop as mat4 transforms foregoing usual escape orbit check\n   mat4 M, R, S, T;\n   for(int i=18; i>0; i--) {\n   \n    /* Original formulation of z -> z^2 + c in single mat4 form\n    \n       M = mat4(    z.x,   -z.y,      0,    c.x,\n                    z.y,    z.x,      0,    c.y,\n                      0,      0,      1,      0,\n                      0,      0,      0,      1);\n       z *= M;\n    */\n       \n    // decompose M into rotation R, scaling S and translation T steps\n       \n       float a = atan(z.x,z.y);\n//       a -= t*TAU;\n       vec2 cs = vec2(COS(a), SIN(a));                 // refer common tab\n       \n       R = mat4(   cs.y,  -cs.x,      0,      0,       // Rotation\n                   cs.x,   cs.y,      0,      0,\n                      0,      0,      1,      0,\n                      0,      0,      0,      1);\n       \n       float s = sqrt(dot(z.xy,z.xy));\n       S = mat4(      s,      0,      0,      0,       // Scaling\n                      0,      s,      0,      0,\n                      0,      0,      s,      0,\n                      0,      0,      0,      1);\n\n\n       T = mat4(      1,      0,      0,    c.x,       // Translation\n                      0,      1,      0,    c.y,\n                      0,      0,      1,      0,\n                      0,      0,      0,      1);\n\n       z *= R*S*T;\n   }\n   \n   // swizzle z into rgba colour (red/green)\n   k = z.grra;\n\n   k = normalize(k);       // reign things in\n//   k = vec4(length(z));  // B/W\n\n   // indicator for +/- value of t\n   k = (p.x>8.) ? k : (t=floor(c.y-sin(iTime)+1.), vec4(1.-t, t, 0, 0));\n   \n   // +/- 1 ruler guides\n   if((t=abs(abs(c.y)-1.))<.01) k = max(k,vec4(.001/t + .001/fract(mod(c.x,.2))));\n   if((t=abs(abs(c.x)-1.))<.01) k = max(k,vec4(.001/t + .001/fract(mod(c.y,.2))));\n\n}\n\n\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define PI12    0.261799387799149436538553615273291907016430783281258818414578716\n#define PI8     0.392699081698724154807830422909937860524646174921888227621868074\n#define RT22    0.707106781186547524400844362104849039284835937688474036588339869\n#define PI4     0.785398163397448309615660845819875721049292349843776455243736148\n#define PI3     1.047197551196597746154214461093167628065723133125035273658314864\n#define RT2     1.414213562373095048801688724209698078569671875376948073176679738\n#define PI2     1.570796326794896619231321691639751442098584699687552910487472296\n#define PI      3.141592653589793238462643383279502884197169399375105820974944592\n#define PI3_2   4.712388980384689857693965074919254326295754099062658731462416888\n#define TAU     6.283185307179586476925286766559005768394338798750211641949889185\n\n// choose implementations for sin() / cos()\n\n#define SIN(x) sin(x)\n//#define SIN(x) sin(iTime*x)\n//#define SIN(x) sin(x/iTime)\n//#define SIN(x) sin(x*3.*t)\n//#define SIN(x) taylorSin(4,x)\n//#define SIN(x) taylorSin(int(12.*abs(t)+1.),x)\n//#define SIN(x) taylorSin(int((.5+.5*sin(iTime/2.))*8.+1.),x)\n\n//#define COS(x) cos(x)\n#define COS(x) SIN(x+PI2)\n\nfloat taylorSin(int n, float x)\n{\n    n = abs(n);\n    x = mod(x,min(TAU,float(n)));\n    float a = 0.;\n    \n    switch(n)   // switch can be flaky hopefully impls have improved\n    {\n        default:\n        case 12: a+=pow(x,25.)/15511210043330985984000000.;\n        case 11: a-=pow(x,23.)/25852016738884976640000.;\n        case 10: a+=pow(x,21.)/51090942171709440000.;\n        case  9: a-=pow(x,19.)/121645100408832000.;\n        case  8: a+=pow(x,17.)/355687428096000.;\n        case  7: a-=pow(x,15.)/1307674368000.;\n        case  6: a+=pow(x,13.)/6227020800.;\n        case  5: a-=pow(x,11.)/39916800.;\n        case  4: a+=pow(x, 9.)/362880.;\n        case  3: a-=pow(x, 7.)/5040.;\n        case  2: a+=pow(x, 5.)/120.;\n        case  1: a-=pow(x, 3.)/6.;\n        case  0: a+=x;\n    }\n    return a;\n}\n","name":"Common","description":"","type":"common"}]}