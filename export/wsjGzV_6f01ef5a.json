{"ver":"0.1","info":{"id":"wsjGzV","date":"1549420629","viewed":91,"name":"Carl Cox","username":"cbrpnk","description":"everyday. Made while listening to this mix https://www.youtube.com/watch?v=UTHEQNdLcUI","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec2 rotate(vec2 p, float a)\n{\n    float c = cos(a);\n    float s = sin(a);\n    return mat2(c, s, -s, c) * p;\n}\n\n\nfloat voronoi(vec2 p)\n{    \n    p = mod(p+vec2(.5), 1.)-vec2(.5);\n    p *= 5.;\n    p = abs(p);\n    \n    float d = 1000000.;\n    float alpha = .25;\n    \n    for(int i=0; i<2; ++i) {\n        for(int j=0; j<2; ++j) {\n        \td = min(d, length(p-vec2(float(i)*alpha, (float(j)+.5*mod(float(i), 2.))*alpha)));\n        \td = min(d, length(p-vec2(i, j)));\n            d = min(d, length(p-vec2(i, j)*2.));\n            d = min(d, length(p-vec2(i, j)*3.));\n        }\n    }\n    \n    return d;\n}\n\n\nfloat sphere(vec3 p, float r)\n{\n    return length(p) - r;\n}\n\nfloat torus(vec3 p)\n{\n    p.y *= .1 * length(p.xz)*abs(sin(iTime*6.5)*.3);\n    p.xz *= 4.*clamp(cos(iTime*6.5), .1, .7);\n    return sqrt(pow(length(p.xz) - 1.1, 2.) + pow(p.y, 2.)) - .35*abs(cos(iTime));\n}\n\nfloat map(vec3 p)\n{\n    p.xz = rotate(p.xz, iTime);\n    p.xy = rotate(p.xy, iTime);\n    \n    //p = mod(p+vec3(1.), 3.)-vec3(1.);\n    \n    float s = sphere(p, .2*cos(iTime*6.5));\n    \n    // polar map\n    vec2 new;\n    new.x = dot(p, vec3(0., 0., -1.));\n    new.y = length(p);\n    \n    float v1 = voronoi(new)*.3;\n    float v2 = voronoi(p.xz*p.y)*.7;\n    \n    s -= v1 + v2;\n    \n    float s2 = sphere(abs(p)-vec3(0., 1., 0.), .2);\n    float t = torus(p);\n    \n    float d = min(s, s2-v2*.1);\n    d = min(d, t-v1*.5);\n    \n    return d;\n}\n\nfloat march(vec3 ro, vec3 rd)\n{\n    float t = 0.;\n    for(int i=0; i<128; ++i) {\n    \tfloat d = map(ro+rd*t);\n        if(d < .001) break;\n        if(t > 40.) return -1.;\n        t += d*.7;\n    }\n    return t;\n}\n\nvec3 getNormal(vec3 p)\n{\n    return normalize(vec3(\n    \tmap(p+vec3(0.001, 0., 0.)) - map(p-vec3(0.001, 0., 0.)),\n        map(p+vec3(0., 0.001, 0.)) - map(p-vec3(0., 0.001, 0.)),\n        map(p+vec3(0., 0., 0.001)) - map(p-vec3(0., 0., 0.001))\n    ));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy - vec2(.5);\n    uv.x *= iResolution.x/iResolution.y;\n\t\n    uv = abs(uv);\n    \n    vec3 eye = vec3(0., 0., 10.);\n    vec3 lookat = normalize(vec3(uv.x, uv.y, -1.*sin(iTime*200.)));\n    float d = march(eye, lookat);\n    \n    \n    vec3 col = vec3(voronoi(uv));\n    if(d < 0.) {\n        col = vec3(0.);\n    } else {\n    \tvec3 normal = getNormal(eye+lookat*d);\n    \tcol = vec3(abs(sin(iTime*6.5)), d/20., length(uv.x+uv.y)+cos(iTime*3.25)) * max(0., dot(normal, vec3(0., 1., .5)));\n    \tcol *= abs(sin(iTime*16.))-max(0., dot(normal, sin(iTime)*lookat))*1.;\n    }\n\t\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}