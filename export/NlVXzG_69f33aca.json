{"ver":"0.1","info":{"id":"NlVXzG","date":"1640918780","viewed":242,"name":"Voxels Containing Walls & Stairs","username":"jt","description":"Experiment with rendering walls in a voxel-grid as a step towards making a voxel building structure,\nbased on [url]https://www.shadertoy.com/view/NstSR8[/url],\nnow with additional random stairs to test performance.","likes":15,"published":1,"flags":0,"usePreview":0,"tags":["3d","raymarching","raycasting","voxel","dda","stairs","textured","walls","subobjects"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sfGRr","filepath":"/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin","previewfilepath":"/media/ap/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin","type":"volume","channel":1,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdX3Rr","filepath":"/media/a/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin","previewfilepath":"/media/ap/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin","type":"volume","channel":0,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// https://www.shadertoy.com/view/NlVXzG Voxels Containing Walls & Stairs\n// based on https://www.shadertoy.com/view/flVXDw Voxels Containing Walls,\n// based on https://www.shadertoy.com/view/NstSR8 Cast Voxels March Sub-Objects,\n// based on https://www.shadertoy.com/view/4dX3zl Branchless Voxel Raycasting by fb39ca4\n// (with loop optimization by kzy), DDA based on http://lodev.org/cgtutor/raycasting.html\n// raymarching subobjects, walls, stairs by jt\n\n// tags: 3d, raymarching, raycasting, voxel, dda, textured, subobjects, walls\n\n#define MAX_DIST 1000.0\n\n// https://iquilezles.org/articles/intersectors\nvec2 boxIntersection( in vec3 ro, in vec3 rd, vec3 boxSize )\n{\n    vec3 m = 1.0/rd;\n    vec3 n = m*ro;\n    vec3 k = abs(m)*boxSize;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n    if( tN>tF || tF<0.0) return vec2(-1.0);\n    return vec2( tN, tF );\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdSphere(vec3 p, float d)\n{\n    return length(p) - d;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat box2d(vec2 p)\n{\n    vec2 q = abs(p) - vec2(1.0);\n    return min(max(q.x,q.y), float(0.0)) + length(max(q, float(0.0)));\n}\n\n// https://www.shadertoy.com/view/NddGWs 2d Infinite Stairs SDF (my stairs function, improved by iq)\nfloat infinite_stairs_even2d(vec2 p, float n)\n{\n    p *= n; // scale by number of stairs\n    p = vec2(p.x+p.y,p.x-p.y)/float(4.0);\n    p = fract(p.x) + vec2(p.y,-p.y);\n    p = float(2.0)*p-float(1.0);\n    return box2d(p) / n;\n}\n\nfloat infinite_stairs_even(vec3 p, float n)\n{\n    return infinite_stairs_even2d(vec2(p.y, p.z), n);\n}\n\nfloat finite_stairs_even(vec3 p, float n)\n{\n    return max(infinite_stairs_even(p + 0.5 / n, n * 2.0), sdBox(p, vec3(1.0) / 2.0));\n    //return max(infinite_stairs_even(p + 0.5 / n - iTime * 0.1, n * 2.0), sdBox(p, vec3(1.0) / 2.0));\n}\n\n#define halfwallsize (1.0/32.0)\n\nfloat sdMixed(vec3 p, bvec3 walls0, bvec3 walls1, uint idx)\n{\n    float d = MAX_DIST;\n    if(walls0.x) d = min(d, sdBox(p + vec3(0.5 - halfwallsize, 0.0, 0.0), vec3(halfwallsize, 0.5, 0.5)));\n    if(walls0.y) d = min(d, sdBox(p + vec3(0.0, 0.5 - halfwallsize, 0.0), vec3(0.5, halfwallsize, 0.5)));\n    if(walls0.z) d = min(d, sdBox(p + vec3(0.0, 0.0, 0.5 - halfwallsize), vec3(0.5, 0.5, halfwallsize)));\n    if(walls1.x) d = min(d, sdBox(p - vec3(0.5 - halfwallsize, 0.0, 0.0), vec3(halfwallsize, 0.5, 0.5)));\n    if(walls1.y) d = min(d, sdBox(p - vec3(0.0, 0.5 - halfwallsize, 0.0), vec3(0.5, halfwallsize, 0.5)));\n    if(walls1.z) d = min(d, sdBox(p - vec3(0.0, 0.0, 0.5 - halfwallsize), vec3(0.5, 0.5, halfwallsize)));\n    //if(idx == 1u) d = min(d, sdBox(p, vec3(0.25)));\n    if(idx == 1u) d = min(d, finite_stairs_even(p.xyz, 8.0));\n    if(idx == 2u) d = min(d, finite_stairs_even(p.zyx, 8.0));\n    if(idx == 3u) d = min(d, finite_stairs_even(p.xyz * vec3(1,1,-1), 8.0));\n    if(idx == 4u) d = min(d, finite_stairs_even(p.zyx * vec3(1,1,-1), 8.0));\n    return d;\n}\n\n#define halfboundsize 6\n\nbool getBoundingShapeVoxel(ivec3 c) {\n    vec3 p = vec3(c) + vec3(0.5);\n    //float d = max(-sdSphere(p, 7.5), sdBox(p, vec3(6.0)));\n    float d = sdBox(p, vec3(halfboundsize));\n    //float d = min(max(-sdSphere(p, 7.5), sdBox(p, vec3(6.0))), -sdSphere(p, 25.0));\n    return d < 0.0;\n}\n\n#define PI 3.1415926\n\nfloat checker(vec3 p)\n{\n    //return step(0.5, length(1.0 - abs(2.0 * fract(p) - 1.0))); // dots\n    return step(0.0, sin(PI * p.x + PI/2.0)*sin(PI *p.y + PI/2.0)*sin(PI *p.z + PI/2.0));\n    //return step(0.0, sin(p.x)*sin(p.y)*sin(p.z));\n}\n\nfloat blob(vec3 p)\n{\n    return step(0.5, length(fract(p)-0.5));\n}\n\nmat2 rotate(float t)\n{\n    return mat2(vec2(cos(t), sin(t)), vec2(-sin(t), cos(t)));\n}\n\n#define EPSILON 0.001\n\n// raymarch subobject\nfloat march(vec3 ro, vec3 rd, float tmin, float tmax, bvec3 walls0, bvec3 walls1, uint idx)\n{\n    for(float t = tmin; t < tmax;)\n    {\n        float h = sdMixed(ro + rd * t, walls0, walls1, idx);\n        if(h < EPSILON)\n            return t;\n        t += h;\n    }\n    return MAX_DIST;\n}\n\n// based on https://iquilezles.org/articles/normalsSDF tetrahedron normals\nvec3 normal(vec3 p, bvec3 walls0, bvec3 walls1, uint idx)\n{\n    const float h = EPSILON;\n    const vec2 k = vec2(1,-1);\n    return normalize(k.xyy * sdMixed(p + k.xyy * h, walls0, walls1, idx) +\n                     k.yyx * sdMixed(p + k.yyx * h, walls0, walls1, idx) +\n                     k.yxy * sdMixed(p + k.yxy * h, walls0, walls1, idx) +\n                     k.xxx * sdMixed(p + k.xxx * h, walls0, walls1, idx));\n}\n\nvec4 process_subobject(vec3 ro, vec3 rd, float tmin, float tmax, bvec3 walls0, bvec3 walls1, uint idx)\n{\n    float d = march(ro, rd, tmin, tmax, walls0, walls1, idx);\n    vec3 n = normal(ro + rd * d, walls0, walls1, idx);\n    return vec4(n, d);\n}\n\n// \"The raycasting code is somewhat based around a 2D raycasting toutorial found here:\n//  http://lodev.org/cgtutor/raycasting.html\" (fb39ca4)\n\n#define MAX_RAY_STEPS 64\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 screenPos = (fragCoord.xy / iResolution.xy) * 2.0 - 1.0;\n    vec3 cameraDir = vec3(0.0, 0.0, 0.8);\n    vec3 cameraPlaneU = vec3(1.0, 0.0, 0.0);\n    vec3 cameraPlaneV = vec3(0.0, 1.0, 0.0) * iResolution.y / iResolution.x;\n    vec3 rayDir = cameraDir + screenPos.x * cameraPlaneU + screenPos.y * cameraPlaneV;\n    vec3 rayPos = vec3(0.0, 0.0 * sin(iTime * 2.7), -12.0);\n\n    mat2 R = rotate(1.0 * iTime / 5.0);\n    rayPos.xz = R * rayPos.xz;\n    rayDir.xz = R * rayDir.xz;\n\n    rayDir = normalize(rayDir);\n\n    vec3 color = vec3(0.0);\n    vec4 result = vec4(vec3(0.0), MAX_DIST);\n\n    {\n        vec3 deltaDist = 1.0 / abs(rayDir);\n        ivec3 rayStep = ivec3(sign(rayDir));\n        ivec3 mapPos = ivec3(floor(rayPos + 0.));\n        vec3 sideDist = (sign(rayDir) * (vec3(mapPos) - rayPos) + (sign(rayDir) * 0.5) + 0.5) * deltaDist;\n\n        for (int i = 0; i < MAX_RAY_STEPS; i++)\n        //for (int i = min(iFrame,0); i < MAX_RAY_STEPS; i++) // prevent unrolling loop to prevent crash\n        {\n            if(min(abs(mapPos.x), min(abs(mapPos.y),abs(mapPos.z))) > 5) // explicit sky-box (letting loop run-out without hitting a wall results in artifacts)\n                break;\n\n            if (getBoundingShapeVoxel(mapPos))\n            {\n                vec3 threshold = vec3(0.1, 0.5, 0.1);\n                bvec3 walls0 = lessThan(vec3(texelFetch(iChannel0, mapPos + 0 + halfboundsize, 0)), threshold);\n                //bvec3 walls1 = lessThan(vec3(texelFetch(iChannel0, mapPos + 1 + halfboundsize, 0)), threshold);\n                bvec3 walls1 = // can this be optimized?\n                    bvec3\n                    (\n                        lessThan(vec3(texelFetch(iChannel0, mapPos + ivec3(1,0,0) + halfboundsize, 0)), threshold).x,\n                        lessThan(vec3(texelFetch(iChannel0, mapPos + ivec3(0,1,0) + halfboundsize, 0)), threshold).y,\n                        lessThan(vec3(texelFetch(iChannel0, mapPos + ivec3(0,0,1) + halfboundsize, 0)), threshold).z\n                    );\n                //uint idx = texelFetch(iChannel1, mapPos + 0 + halfboundsize, 0).x > 0.5 ? 1u : 0u;\n                uint idx = uint(floor(texelFetch(iChannel1, mapPos + 0 + halfboundsize, 0).x * 8.0));\n                if(any(walls0) || any(walls1)) // skip empty voxels\n                {\n                    // Near bounding-box side can be reconstructed from dda, howvever we need far bounding-box side, too.\n                    // float d = length(vec3(mask) * (sideDist - deltaDist)) / length(rayDir);\n                    // It appears to be easier to just do the box-intersection here (potential for optimization).\n                    vec2 bounds = boxIntersection( rayPos - vec3(mapPos) - vec3(0.5), rayDir, vec3(0.5) ); // bounding box\n\n                    result = process_subobject(rayPos - vec3(mapPos) - vec3(0.5), rayDir, bounds.x, bounds.y, walls0, walls1, idx);\n                    if(result.w > 0.0 && result.w < bounds.y)\n                    {\n                        //color = vec3(1.0); // plain\n                        color = 0.5 + 0.5 * vec3(texture(iChannel0, 0.1 * vec3(mapPos))); // some random colors to improve visualization\n                        //color = 0.5 + 0.5 * normalize(result.xyz); // normal colors\n                        vec3 dst = rayPos + rayDir * result.w;\n                        //color *= texture(iChannel0, dst).xyz;\n                        //color *= vec3(0.5 + 0.5 * checker(dst * 8.0));\n                        color *= vec3(0.5 + 0.5 * checker(dst));\n                        //color *= vec3(0.5 + 0.5 * blob(dst));\n\n                        vec3 fogcolor = vec3(0.25, 0.4, 0.5); // fog\n                        //vec3 fogcolor = vec3(0.75, 0.6, 0.3); // smog\n                        color *= mix(fogcolor, color, exp(-result.w * result.w / 200.0)); // fog for depth impression & to suppress flickering\n\n                        break;\n                    }\n                }\n            }\n\n            // Core of https://www.shadertoy.com/view/4dX3zl Branchless Voxel Raycasting\n            bvec3 mask = lessThanEqual(sideDist.xyz, min(sideDist.yzx, sideDist.zxy));\n            sideDist += vec3(mask) * deltaDist;\n            mapPos += ivec3(vec3(mask)) * rayStep;\n        }\n    }\n\n    vec3 ambient = vec3(0.1);\n    vec3 lightdir = normalize(vec3(3.0, 2.0, 1.0));\n    color *= mix(ambient, vec3(1.0), clamp(dot(lightdir, result.xyz), 0.0, 1.0));\n\n    fragColor.rgb = sqrt(color);\n}\n","name":"Image","description":"","type":"image"}]}