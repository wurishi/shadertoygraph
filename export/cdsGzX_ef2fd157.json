{"ver":"0.1","info":{"id":"cdsGzX","date":"1666556203","viewed":311,"name":"Rails and Roads","username":"Alpaga","description":"Consistent Truchet tiling. The orientations of the tiles on a vertical and a horizontal axes are chosen at random, and determine the orientations of all other tiles.\n\nDrag the mouse to change view.","likes":44,"published":1,"flags":0,"usePreview":1,"tags":["raymarching","truchet"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","previewfilepath":"/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Uncomment if your machine is powerful enough.\n\n#define SHADOWS\n//#define REFLECTION\n//#define AA\n\n#define STEPS 100\n#define FAR 30.0\n\nconst float carSpeed = 1.;\nconst float trainSpeed = 2.;\n\nconst float fov = 35.0;\nconst float cameraSpeed = 0.1;\n\nconst int FLOOR = 0;\nconst int ROAD = 1;\nconst int RAIL = 2;\nconst int SLEEPER = 3;\nconst int RUBBER = 4;\nconst int RIM = 5;\nconst int CAR = 10;\nconst int TRAIN = 20;\n\nstruct Material {\n    vec3 albedo;\n    vec3 specular;\n};\n\nint lightNumber = 1;\nvec3 ambient = vec3(0.1);\nconst vec3 lightDirection = normalize(vec3(3,5,-4));\nconst vec3 lightCol = vec3(2,2,1);\n\nvec2 delta = vec2(0.0,0.001);\n\nfloat time;\n\n// Hash function from Dave_Hoskins\n// https://www.shadertoy.com/view/4djSRW\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n// A pair of random bits, each one depending on\n// only one coordinate of p.\n// The tiles on the horizontal axis are vertically flipped randomly,\n// the tiles on the vertical axis are horizontally flipped randomly.\nvec2 rdBits(vec2 p) {\n    return step(.5,vec2(hash11(p.y), hash11(p.x+138.215)));\n}\nvoid flip(inout float x, float bit) {\n    x = mix(x,1.-x,bit);\n}\nvoid flip(inout vec2 p, vec2 bits) {\n    p = mix(p,1.-p,bits);\n}\n// A grid cell has 4 different types, depending on the\n// parities of its coordinates, let's call them 00, 01, 10, 11.\n// It turns out that a vehicle alternates between these 4 types.\n// - One car goes: 00, 01, 11, 10, and cycles,\n// - The other car goes: 00, 10, 11, 01, and cycles.\n// So at a given time, we can figure out in which\n// type of cell a vehicle must be.\nvec2 closestCar(vec2 p, float car, out vec2 dir) {\n    // We first find out what is the parity\n    // of the cell the car is currently in.\n    float t = carSpeed*time;\n    // Think of shift as 0, 1, 2, 3\n    float shift = floor(t/1.5708);\n    \n    vec2 u = vec2(1.-car,car);\n    vec2 parity = floor(.5*mod(shift+u,4.));\n    \n    // We then find the cell with this parity\n    // that is closest to p.\n    vec2 g = 2.*floor(.5*(p+.5-parity))+parity;\n    \n    // Now we calculate the position of the car in the cell.\n    // Each car has a position, a direction and a side.\n    // We first calculate them in the abstract tile\n    // and apply the flipping at the end.\n\n    // The side of the car is determined by the\n    // parity of the random bits.\n    vec2 b = rdBits(g);\n    float side = 2.*mod(b.x+b.y,2.)-1.;\n    side = mix(side, -side, car);\n    \n    float direction = 1.-2.*car;\n    shift += car;// The cars meet in a more random place\n    shift *= 1.5708;\n    \n    t = direction*(t-shift);\n    vec2 cs = vec2(cos(t), sin(t));\n    vec2 pos = (.5+.09*side)*cs;\n    dir = direction*vec2(-cs.y,cs.x);\n    \n    // Parity determines whether the car enters the tile through\n    // a horizontal or vertical edge.\n    float par = mod(parity.x+parity.y,2.);\n    pos = mix(pos, pos.yx, par);\n    dir = mix(dir, dir.yx, par);\n    \n    // We finally apply the tile flipping to\n    // the car position and direction\n    vec2 flipping = mod(g+b,2.);\n    flip(pos,flipping);\n    dir = mix(dir, -dir, flipping);\n  \n    return g+pos;\n}\nvec2 closestTrain(vec2 p, float wagon, out vec2 dir) {\n    float t = trainSpeed*time;\n    float shift = floor(t/1.5708-.5*wagon);\n    \n    vec2 parity = floor(.5*mod(shift+vec2(1.,0.),4.));\n    \n    // Grid cell containing the closest\n    // instance of the wagon.\n    vec2 g = 2.*floor(.5*(p+.5-parity))+parity;\n    \n    shift += .5*wagon;\n    shift *= 1.5708;\n    \n    t -= shift;\n    vec2 cs = vec2(cos(t),sin(t));\n    vec2 pos = 1.-.5*cs;\n    dir = vec2(cs.y,-cs.x);\n    \n    // The parity of the cell determines\n    // the direction.\n    float par = mod(parity.x+parity.y,2.);\n    pos = mix(pos, pos.yx, par);\n    dir = mix(dir, dir.yx, par);\n    \n    // We finally apply the tile flipping.\n    vec2 b = rdBits(g);\n    vec2 flipping = mod(g+b, 2.);\n    flip(pos,flipping);\n    dir = mix(dir, -dir, flipping);\n\n    \n    return g+pos;\n}\n\n// Signed distance fields\nfloat sdFloor(vec3 p) {\n    vec2 q = abs(mod(p.xz,.1)-.05);\n    float depth = .3*max(.025-length(q),0.);//.01*texture(iChannel1,.3*p.xz).r;\n    return p.y+depth;\n}\nfloat sdRoad(vec3 p) {\n    \n   // return length(max(\n   //     vec2(abs(length(p.xz)-.5)-.17,abs(p.y-.05)-.02),\n   //     0.))-.03;\n    float a = length(max(\n        vec2(abs(abs(length(p.xz)-.5)-.09)-.07,abs(p.y-.05)-.03),\n        0.))-.02;\n    float b = length(max(\n        vec2(abs(abs(length(p.xz)-.5)-.19)-.01,abs(p.y-.05)-.05),\n        0.))-.01;\n    return min(a,b);\n}\nfloat sdRail(vec3 p, out int id) {\n    p.xz = 1.-p.xz;\n    float l = length(p.xz);\n    // Rails\n    float dr = length(vec2(max(abs(abs(l-.5)-.1)-.01,0.),p.y-.02))-.02;\n    float a = atan(p.z,p.x)/1.5708;\n    // Sleepers\n    float ds = length(vec2(max(abs(mod(a,.1)-.05),max(l-.65,.35-l)),p.y-.015))-.015;\n    \n    id = dr<ds ? RAIL : SLEEPER;\n    return min(dr,ds);\n}\n// A truchet tile contains a road section and a rail section\nfloat sdTile(vec3 p, out int id) {\n    // Flip the tile\n    vec2 g = floor(p.xz);\n    vec3 f = p;\n    f.xz = fract(f.xz);\n    vec2 b = rdBits(g);\n    vec2 flipping = mod(g+b,2.);\n    flip(f.xz,flipping);\n    \n    float d, minD = 1e6;\n    \n    d = sdRoad(f);\n    if(d<minD) {\n        id = ROAD;\n        minD = d;\n    }\n    int tmp;\n    d = sdRail(f,tmp);\n    if(d<minD) {\n        id = tmp;\n        minD = d;\n    }\n    return minD;\n}\n// From iq: https://www.shadertoy.com/view/ftVXRc\n// r=radius, h=height\nfloat sdCutDisk(in vec2 p)\n{\n    const float r = .15;\n    const float h = .05;\n    const float w = .1414; //qrt(r*r-h*h); // constant for a given shape\n    \n    p.x = abs(p.x);\n    \n    // select circle or segment\n    float s = max( (h-r)*p.x*p.x+w*w*(h+r-2.0*p.y), h*p.x-w*p.y );\n\n    return (s<0.0) ? length(p)-r :        // circle\n           (p.x<w) ? h - p.y     :        // segment line\n                     length(p-vec2(w,h)); // segment corner\n}\nfloat sdCar(vec3 p, int i, out int id) {\n    vec3 q = p;\n\n    // Car body\n    q.y = p.y - .09;\n    float d = length(max(vec2(sdCutDisk(q.xy),abs(q.z)-.02),0.))-.03;\n    \n    // Wheels (= two cylinders)\n    q.y = p.y - .15;\n    q = abs(q);\n    q.x -= .09;\n    float l = length(q.xy);\n    vec2 r = vec2(l-.04,q.z-.05);\n    float dw = length(max(r,0.))-.02;\n    \n    id = d<dw ? CAR+i : l<.02 ? RIM : RUBBER;\n    return min(d,dw);\n}\nfloat sdTrain(vec3 p, int i, out int id) {\n    vec3 q = p;\n    \n    // Wagon body\n    p.y -= .12;\n    vec2 r = vec2(length(p.yz)-.07,abs(p.x)-.15);\n    float dt = length(max(r,0.))-.02;\n    \n    // Wheels (= two cylinders)\n    q.y -=.08;\n    q = abs(q);\n    q.x -= .1;\n    float l = length(q.xy); \n    r = vec2(l-.04,q.z-.1);\n    float dw = length(max(r,0.))-.02;\n    \n    id = dt < dw ? TRAIN+i : l < .02 ? RIM : RUBBER;\n    \n    return min(dt,dw);\n}\nfloat sdLoco(vec3 p, out int id) {\n    vec3 q = p;\n    \n    // Loco body\n    p.y -= .12;\n    vec2 r = vec2(length(p.yz)-.07,abs(p.x)-.15);\n    float dt = length(max(r,0.))-.02;\n    p = q - vec3(.1,.2,0.);\n    r = vec2(length(p.xz)-.03,abs(p.y)-.15);\n    dt = min(dt,length(max(r,0.))-.02);\n    \n    // Wheels (= two cylinders)\n    q.y -=.08;\n    q = abs(q);\n    q.x -= .1;\n    float l = length(q.xy); \n    r = vec2(l-.04,q.z-.1);\n    float dw = length(max(r,0.))-.02;\n    \n    id = dt < dw ? TRAIN : l<.02 ? RIM : RUBBER;\n    \n    return min(dt,dw);\n}\n// pos = car position\n// dir = car direction\n// i = car number (0 or 1)\nfloat sdCar(vec3 p, vec2 pos, vec2 dir, int i, out int id) {\n    p.xz -= pos;\n    p.xz = mat2(dir.x,-dir.y,dir.y,dir.x)*p.xz;\n    return sdCar(p,i,id);\n}\n// pos = car position\n// dir = car direction\n// i = wagon number (0 to 4)\nfloat sdTrain(vec3 p, vec2 pos, vec2 dir, int i, out int id) {\n    p.xz -= pos;\n    p.xz = mat2(dir.x,-dir.y,dir.y,dir.x)*p.xz;\n    return sdTrain(p,i,id);\n}\n// pos = car position\n// dir = car direction\nfloat sdLoco(vec3 p, vec2 pos, vec2 dir, out int id) {\n    p.xz -= pos;\n    p.xz = mat2(dir.x,-dir.y,dir.y,dir.x)*p.xz;\n    return sdLoco(p,id);\n}\n\nfloat sd(vec3 p, out int id) {\n    float d,minD = 1e6;\n    vec2 pos,dir;\n    int tmp;\n    \n    // Floor\n    d = sdFloor(p);\n    if(d<minD) {\n        id = FLOOR;\n        minD = d;\n    }\n   \n    // Tile\n    d = sdTile(p,tmp);\n    if(d<minD) {\n        id = tmp;\n        minD = d;\n    }\n\n    // Car 0\n    pos = closestCar(p.xz,0.,dir);\n    d = sdCar(p, pos, dir, 0, tmp);\n    if(d<minD) {\n        id = tmp;\n        minD = d;\n    }\n    // Car 1\n    pos = closestCar(p.xz,1.,dir);\n    d = sdCar(p, pos, dir, 1, tmp);\n    if(d<minD) {\n        id = tmp;\n        minD = d;\n    }\n    // Loco\n    pos = closestTrain(p.xz,0.,dir);\n    d = sdLoco(p, pos, dir, tmp);\n    if(d<minD) {\n        id = tmp;\n        minD = d;\n    }\n    // Wagons\n    for(int i=1; i<5; i++) {\n        pos = closestTrain(p.xz,float(i),dir);\n        d = sdTrain(p, pos, dir, i, tmp);\n        if(d<minD) {\n            id = tmp;\n            minD = d;\n        }\n    }\n    \n    return minD;\n}\n\nvec3 roadColor(vec2 p) {\n    float xx = .4*floor(p.x/.4);\n    float yy = .2+.7*floor((p.y-xx)/.7);\n    vec2 pp = vec2(xx,yy);\n//    const vec2 vector = vec2(.2,.5);\n//    vec2 pp = vector*floor(p/vector);\n    vec2 uu = p-pp;\n    float h = hash11(63.4*pp.x+135.8*pp.y);\n    vec3 tex = texture(iChannel0, uu+h).rgb;\n    tex = mix(vec3(1),tex,.8+.2*h);\n    tex = tex*tex;\n    return tex;\n    \n    vec2 g = floor(p);\n    vec2 f = fract(p);\n    vec2 b = rdBits(g);\n    vec2 flipping = mod(g+b, 2.);\n    flip(f,flipping);\n   // mix(f,f.yx,mod(g.x+g.y,2.));\n    //f = f+(2.*mod(flipping.x+flipping.y,2.)-1.)*f.yx;\n    \n    f = f+vec2(-f.y,f.x);\n    f.x += hash11(g.x+12.*g.y);\n/*\n    vec3 light = vec3(.89,.6,.28);\n    vec3 dark = vec3(.21,.1,.02);\n    return mix(dark, light, smoothstep(.4,.5,length(mod(20.*f,2.)-1.)));\n  */  \n    float l = length(f)-.5;\n    vec2 uv = vec2(atan(f.y,f.x)*1.2732-1.,5.093*l);\n    vec3 col = texture(iChannel0,f).rgb;\n  //  col = col*col;\n   // col = clamp(.4+(col-.4)*2.,0.,1.);\n    col = mix(vec3(1.),col,.9);\n        \n\n    return col;\n}\n\nMaterial material(vec3 p, int id) {\n    vec3 alb, spe = vec3(.04);\n    switch(id) {\n        case FLOOR:\n            alb = vec3(.15,.25,.03);\n            break;\n        case ROAD:\n            alb = roadColor(p.xz);\n            break;\n        case RAIL:\n            spe = vec3(1);\n            break;\n        case SLEEPER:\n            break;\n        case CAR:\n            alb = vec3(1,1,0);\n            break;\n        case CAR+1:\n            alb = vec3(1,0,0);\n            break;\n        case RUBBER:\n            spe = vec3(0);\n            break;\n        case RIM:\n            #ifdef REFLECTION\n            spe = vec3(1);\n            #else\n            alb = vec3(1);\n            #endif\n            break;\n        default:// Train\n            #ifdef REFLECTION\n            spe = vec3(0,float(id-TRAIN)/5.,1);\n            #else\n            alb = vec3(0,float(id-TRAIN)/5.,1);\n            spe = vec3(.1);\n            #endif\n    }\n    return Material(alb,spe);\n}\n\nvec3 normal(vec3 p) {\n    int id;\n    float d = sd(p,id);\n    return normalize(vec3(\n        sd(p+delta.yxx,id),\n        sd(p+delta.xyx,id),\n        sd(p+delta.xxy,id))-d);\n}\n\nfloat march(vec3 start, vec3 dir, out int id) {\n\tfloat total = 0.0, d = 1.0;\n    float epsilon = 0.5/iResolution.y;\n    int i=0;\n    for(; i<STEPS; i++) {\n        if(d<epsilon*total || total>FAR) break;\n        d = sd(start + total*dir,id);\n        total += d;\n    }\n    if(total>FAR || i==STEPS) id = -100;\n    return total;\n}\n\nfloat lightMarch(vec3 start, vec3 dir) {\n\tfloat d = 1.0, total = 0.0;\n    float epsilon = 0.5/iResolution.y;\n    float minD = 1000.0;\n    int id;\n    for(int i=0; i<STEPS; i++) {\n        if(d<epsilon*total || total>5.) break;\n        d = sd(start + total*dir, id);\n        total += d;\n        minD = min(minD,d);\n    }\n    return minD;\n}\nfloat shadow(vec3 p, vec3 toLight) {\n    float minD = lightMarch(p+0.05*toLight, toLight);\n    return smoothstep(0.0,0.04,minD);\n}\n\nvec3 rayColorWithoutReflection(vec3 start, vec3 dir) {\n    vec3 color = vec3(0);\n    \n    int id;\n    \n    float d = march(start, dir,id);\n\n    if(id == -100) {//No ray intersection\n        vec3 tex = texture(iChannel1,dir).rgb;\n        return tex*tex;\n    } else {\n        vec3 p = start + d * dir;\n\n        vec3 normal = normal(p);\n        Material mat = material(p,id);\n\n        color += ambient*mat.albedo;\n\n        // Diffuse\n        vec3 diff = mat.albedo * max(dot(lightDirection, normal), 0.0);\n        // Specular\n        vec3 h = normalize(lightDirection-dir);\n        vec3 spec = mat.specular * pow(max(dot(h,normal),0.0), 50.0);\n\n        #ifdef SHADOWS\n        // Shadow\n        float sh = shadow(p, lightDirection);\n        #else\n        float sh = 1.;\n        #endif\n            \n        color += sh*(diff + spec)*lightCol;\n\n        // Reflection of environment\n        vec3 ref = reflect(dir, normal);\n        vec3 env = texture(iChannel1,ref).rgb;\n        env = env*env;// Gamma\n\n        #ifdef SHADOWS\n        // Shadow\n        sh = shadow(p, ref);\n        #else\n        sh = 1.;\n        #endif\n        \n        color += sh * vec3(mat.specular) * env;\n    }\n    return color;\n}\nvec3 rayColorWithReflection(vec3 start, vec3 dir) {\n    vec3 coef = vec3(1.0);\n    vec3 color = vec3(0);\n    \n    int id;\n    for(int i=0; i<2; i++) {\n        float d = march(start, dir,id);\n\n        if(id == -100) {//No ray intersection\n            vec3 tex = texture(iChannel1,dir).rgb;\n            return color + coef*tex*tex;\n        } else {\n            vec3 p = start + d * dir;\n\n            vec3 normal = normal(p);\n            Material mat = material(p,id);\n\n            color += coef*ambient*mat.albedo;\n\n            // Diffuse\n            vec3 diff = mat.albedo * max(dot(lightDirection, normal), 0.0);\n            // Specular\n            vec3 h = normalize(lightDirection-dir);\n            vec3 spec = mat.specular * pow(max(dot(h,normal),0.0), 50.0);\n\n            #ifdef SHADOWS\n            // Shadow\n            float sh = shadow(p, lightDirection);\n            #else\n            float sh = 1.;\n            #endif\n            \n            color += coef*sh*(diff + spec)*lightCol;\n            \n            dir = reflect(dir, normal);\n            start = p + .01*dir;\n            coef *= mat.specular;\n            if(dot(coef,vec3(1))<.001) return color;\n        }\n    }\n    return color;\n}\n\nvec3 rayColor(vec3 start, vec3 dir) {\n    #ifdef REFLECTION\n    return rayColorWithReflection(start, dir);\n    #else\n    return rayColorWithoutReflection(start, dir);\n    #endif\n}\n\nmat3 setupCamera(vec3 cam, vec3 center, vec3 up) {\n \tvec3 w = normalize(cam-center);\n    vec3 u = normalize(cross(up, w));\n    vec3 v = cross(w, u);\n    \n    return mat3(u,v,w);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    time = iTime;\n    vec3 center = vec3(cameraSpeed*iTime,0,-2.*cameraSpeed*iTime);\n    vec3 cam = vec3(-1,3,3)+center;\n\n    if(iMouse.z>0.0) {\n        cam.y -= 5.*(iMouse.y-abs(iMouse.w))/iResolution.y;\n        cam.x -= 5.*(iMouse.x-abs(iMouse.z))/iResolution.x;\n        //time = 10.0*iMouse.x/iResolution.x;\n    }\n    \n    mat3 m = setupCamera(cam, center, vec3(0,1,0));\n    \n    vec3 color = vec3(0.0);\n\n    vec2 uv;\n    #ifdef AA\n    for(float i=-0.25; i<0.5; i+=0.5) {\n        for(float j=-0.25; j<0.5; j+=0.5) {\n            uv = 2.0*(fragCoord + vec2(i,j) - 0.5 * iResolution.xy)/iResolution.y;\n            vec3 pix = vec3(tan(0.5*fov*0.01745)*uv,-1.0);\n    \n            vec3 dir = normalize(m*pix);\n    \n            color += rayColor(cam, dir);\n        }\n    }\n    color /= 4.0;\n    #else\n    uv = 2.0*(fragCoord - 0.5 * iResolution.xy)/iResolution.y;\n    vec3 pix = vec3(tan(0.5*fov*0.01745)*uv,-1.0);\n    vec3 dir = normalize(m*pix);\n\n    color = rayColor(cam, dir);\n    #endif\n    \n    // Vignette\n    uv = fragCoord.xy / iResolution.xy;\n    uv *=  1. - uv.yx;\n    color *= pow(uv.x*uv.y * 15.0, 0.25);\n    \n    // Gamma\n    color = sqrt(color);\n        \n    fragColor = vec4(color,1.0);\n}\n","name":"Image","description":"","type":"image"}]}