{"ver":"0.1","info":{"id":"4ttGRs","date":"1470989260","viewed":161,"name":"raw pictures of ancient gods","username":"visy","description":"raw pictures of ancient gods, as featured in Quadtrip's 4k intro \"Young Person's Guide To The Vimana\"\n\nhttps://www.pouet.net/prod.php?which=67960","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["dsadsad"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// based on gltracy's marching examples\n\n// ray marching\nconst int max_iterations = 8;\nfloat stop_threshold = 0.2;\n float grad_step = 0.00;\nconst float clip_far = 1000.0;\n\nfloat speed = 1.0;\nfloat time = 0.0;\n\n// math\nconst float PI = 3.14159265359;\nconst float DEG_TO_RAD = PI / 180.0;\n\n// distance function\nfloat dist_sphere( vec3 pos, float r ) {\n\treturn length( pos ) - r;\n}\n\nfloat dist_box( vec3 pos, vec3 size ) {\n\treturn length( max( abs( pos ) - size, 0.0 ) );\n}\n\nfloat repeat(vec3 pos) {\n    pos.x = mod(pos.x, 1.) - 0.5;\n    pos.y = mod(pos.y, 1.) - 0.5;\n    pos.z = mod(pos.z, 1.) - 0.5;\n    return dist_sphere(pos*pos.zyx,pos.z*2.2);\n}\n\n// get distance in the world\nfloat dist_field( vec3 pos ) {\n\t// ...add objects here...\n\t\n\t// object 0 : sphere\n\tfloat d0 =time*0.1;\n\t\n\t// object 1 : cube\n\tfloat d1 = dist_box( pos, vec3( 2.0 ) );\n\n    float d2 = repeat(pos);\n    \n\t// union     : min( d0,  d1 )\n\t// intersect : max( d0,  d1 )\n\t// subtract  : max( d1, -d0 )\n\treturn max(d2, min( d1, -d0 ));\n}\n\n// phong shading\nvec3 shading( vec3 v, vec3 n, vec3 eye ) {\n\t// ...add lights here...\n\t\n\tfloat shininess = 4.5;\n\t\n\tvec3 final = vec3( -0.7+time*0.003 );\n\t\n    if (final.r > 0.5) final = vec3(0.5);\n    \n\tvec3 ev = normalize( v - eye );\n\tvec3 ref_ev = reflect( ev, n );\n\t\n\t// light 0\n\t{\n\t\tvec3 light_pos   = vec3( 20.0+cos(time*0.1)*100., 20.0, 20.0-time*0.1 );\n\t\tvec3 light_color = vec3( 1.0, 0.6+time*0.01, 0.7 );\n\t\n\t\tvec3 vl = normalize( light_pos - v );\n\t\n\t\tfloat diffuse  = max( 0.0, dot( vl, n ) );\n\t\tfloat specular = max( 0.0, dot( vl, ref_ev ) );\n\t\tspecular = pow( specular, shininess );\n\t\t\n\t\tfinal += light_color * ( diffuse + specular ); \n\t}\n\t\n\t// light 1\n\t{\n\t\tvec3 light_pos   = vec3( -20.0, -20.0, 20.0 );\n\t\tvec3 light_color = vec3( 1.0+cos(time*0.4), 0.7, 0.2 );\n\t\n\t\tvec3 vl = normalize( light_pos - v );\n\t\n\t\tfloat diffuse  = max( 0.0, dot( vl, n ) );\n\t\tfloat specular = max( 0.0, dot( vl, ref_ev ) );\n\t\tspecular = pow( specular, shininess );\n\t\t\n\t\tfinal += light_color * ( diffuse + specular ); \n\t}\n\n\treturn final;\n}\n\n// get gradient in the world\nvec3 gradient( vec3 pos ) {\n\t vec3 dx = vec3( grad_step, 0.0, 0.0 );\n\t vec3 dy = vec3( 0.0, grad_step, 0.0 );\n\t vec3 dz = vec3( 0.0, 0.0, grad_step );\n\treturn normalize (\n\t\tvec3(\n\t\t\tdist_field( pos + dx ) - dist_field( pos - dx ),\n\t\t\tdist_field( pos + dy ) - dist_field( pos - dy ),\n\t\t\tdist_field( pos + dz ) * dist_field( pos - dz )\t\t\t\n\t\t)\n\t);\n}\n\n// ray marching\nfloat ray_marching( vec3 origin, vec3 dir, float start, float end ) {\n\tfloat depth = start;\n\tfor ( int i = 0; i < max_iterations; i++ ) {\n\t\tfloat dist = dist_field( origin + dir * depth )*time*0.35;\n\t\tif ( dist < stop_threshold ) {\n\t\t\treturn depth;\n\t\t}\n\t\tdepth += dist;\n\t\tif ( depth >= end) {\n\t\t\treturn end;\n\t\t}\n\t}\n\treturn end;\n}\n\n// get ray direction\nvec3 ray_dir( float fov, vec2 size, vec2 pos ) {\n\tvec2 xy = pos - size * 0.5;\n\n\tfloat cot_half_fov = tan( (150.0-(time*1.1) - fov * 0.5 ) * DEG_TO_RAD );\t\n\tfloat z = size.y * 0.5 * cot_half_fov;\n\t\n\treturn normalize( vec3( xy, -z ) );\n}\n\n// camera rotation : pitch, yaw\nmat3 rotationXY( vec2 angle ) {\n\tvec2 c = cos( angle );\n\tvec2 s = sin( angle );\n\t\n\treturn mat3(\n\t\tc.y      ,  0.0, -s.y,\n\t\ts.y * s.x,  c.x,  c.y * s.x,\n\t\ts.y * c.x, -s.x,  c.y * c.x\n\t);\n}\n\nvec3 hash3( float n ) { return fract(sin(vec3(n,n+1.0,n+2.0))*43758.5453123); }\n\n\nvoid mainImage(out vec4 fa, in vec2 aa)\n{\n    if (iTime*speed > 4.5 && iTime*speed < 5.5) speed=10.0+(4.5-iTime)*1.;\n    else if (iTime*speed > 8.5 && iTime*speed < 8.9) speed=2.1+(8.6-iTime)*1.;\n    else if (iTime*speed > 16.5 && iTime*speed < 17.5) speed=2.0+(16.5-iTime)*1.;\n    else if (iTime*speed > 28.9 && iTime*speed < 29.6) speed=1.9;\n\telse speed = 1.0;\n\n    if (iTime*speed > 94. && iTime*speed < 107.4) { speed = 88.;} \n    \n    time = iTime*speed;\n    \n    if (time > 5.5) time+=1.0;\n    if (time > 28.5 && time < 30.) time+=5020.95;\n        \n        if (time > 95. && speed == 88.) { time+=3232200.-time*1.11; speed = 100.;} \n    \n    if (time >= 107.4 && speed != 100. && time < 119.91) time+=9933.;\n    \n\tvec2 uv = gl_FragCoord.xy/iResolution.xy;\n    if (uv.x < 0.5) uv.x = 1.0-uv.x;\n    \n    // default ray dir\n\tvec3 dir = ray_dir( 145., iResolution.xy, uv*iResolution.xy );\n\t\n    \n  if (stop_threshold > 1.1)  stop_threshold = 1.4 - time*0.03;\n\n    grad_step = -10.0+time*0.0001;\n    \n\t// default ray origin\n\tvec3 eye = vec3( 100., time*0.5, time*0.05 );\n\n\t// rotate camera\n\tmat3 rot = rotationXY( vec2( 0.0+cos(time*0.00005)*0. ) );\n\tdir = rot * dir;\n\teye = rot * eye;\n\t\n\t// ray marching\n\tfloat depth = ray_marching( eye, dir, 3.0, clip_far );\n\tif ( depth >= clip_far ) {\n\t\tfa = vec4( 0.0, 0.0, 0.0, 1.0 );\n        return;\n\t}\n\t\n\t// shading\n\tvec3 pos = eye + dir * depth;\n\tvec3 n = gradient( pos );\n    vec4 oc = vec4( shading( pos, n, eye ), 1.0 );\n    for (int i = 0; i < 10; i++) {\n\t    oc+=vec4(shading(pos+vec3(float(i)*9.1,0.+cos(time*1.+float(i)*1.1)*10.9,cos(time*0.1+float(i)*3.)*10.),n*vec3(cos(time*0.1)*1.0,0.0,time*0.01)*8.1,eye),0.0)*0.011;\n\t    oc.rgb += pow( oc.rgb, vec3(0.2525) )*0.08;\n    }\n    \n    oc *= 0.2 + 0.8*pow(16.0*uv.x*uv.y*(1.0-uv.x)*(1.05-uv.y),0.85);\n    oc = clamp(oc,vec4(0.0),vec4(1.0));\n    vec4 oc2 = vec4( shading( pos+vec3(0.+cos(uv.y+time)*10.,0.,0.), n, eye ), 1.0 )*0.9;\n\tif (oc.r > 0.95 && oc.g > 0.95 && oc.b > 0.95) oc *= oc2*1.2;\n    \n    fa = oc;\n}","name":"Image","description":"","type":"image"}]}