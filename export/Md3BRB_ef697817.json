{"ver":"0.1","info":{"id":"Md3BRB","date":"1525678488","viewed":339,"name":"tricks 1","username":"MonterMan","description":"A collection of tricks, includes: fake sphere & plane AO, analytical sphere occlusion, vignetting, 3d fbm-based texturing, shadowing, fresnel effect, and GGX lobe specular lighting.","likes":10,"published":1,"flags":0,"usePreview":0,"tags":["raymarch","texturing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float hash(in float entropy)\n{\n    return fract(sin(entropy*821.91)*951.51);\n}\n\nfloat hash3(in vec3 entropy)\n{\n    return hash(3.7*entropy.x + 721.5*entropy.y + 3.91*entropy.z + 0.5);\n}\n\nfloat noise(in vec3 p)\n{\n    vec3 ipos = floor(p);\n    vec3 fpos = fract(p);\n    \n    float a = hash3(ipos + vec3(0, 0, 0));\n    float b = hash3(ipos + vec3(1, 0, 0));\n    float c = hash3(ipos + vec3(0, 1, 0));\n    float d = hash3(ipos + vec3(1, 1, 0));\n    \n    float e = hash3(ipos + vec3(0, 0, 1));\n    float f = hash3(ipos + vec3(1, 0, 1));\n    float g = hash3(ipos + vec3(0, 1, 1));\n    float h = hash3(ipos + vec3(1, 1, 1));\n    \n    vec3 t = smoothstep(0., 1., fpos);\n    \n    return mix(mix(mix(a, b, t.x), mix(c, d, t.x), t.y),\n               mix(mix(e, f, t.x), mix(g, h, t.x), t.y),\n               t.z);\n}\n\nfloat fbm(in vec3 p)\n{\n    float res = 0.;\n    float amp = 0.5;\n    float freq = 2.0;\n    for (int i = 0; i < 5; ++i)\n    {\n        res += amp*noise(freq*p);\n        amp *= 0.5;\n        freq *= 2.0;\n    }\n    return res;\n}\n\nfloat map(in vec3 p, out int id)\n{\n    float sphere = length(p - vec3(0, 1, 0)) - 1.;\n    float ground = p.y;\n    float d = min(sphere, ground);\n    \n    if (d == ground)\n    {\n        id = 0;\n    }\n    if (d == sphere)\n    {\n        id = 1;\n    }\n    \n    return d;\n}\n\nvec3 map_n(in vec3 p)\n{\n    vec2 e = vec2(0, 0.001);\n    int garbage;\n    return normalize(vec3(map(p + e.yxx, garbage), map(p + e.xyx, garbage), map(p + e.xxy, garbage)) - map(p, garbage));\n}\n\nfloat shadow(in vec3 p, in vec3 l)\n{\n    float res = 1.;\n    float k = 4.;\n    \n    float t = 0.1;\n    float t_max = 50.;\n    for(int i = 0; i < 256; ++i)\n    {\n        if (t > t_max) break;\n        int garbage;\n        float d = map(p + t*l, garbage);\n        if (d < 0.001)\n        {\n            return 0.0;\n        }\n        res = min(res, d*k/t);\n        t += d;\n    }\n    \n    return res;\n}\n\n//NOTE: GGX lobe for specular lighting, took straight from here: http://www.codinglabs.net/article_physically_based_rendering_cook_torrance.aspx\nfloat chiGGX(float v)\n{\n    return v > 0. ? 1. : 0.;\n}\nfloat GGX_Distribution(vec3 n, vec3 h, float alpha)\n{\n    float NoH = dot(n,h);\n    float alpha2 = alpha * alpha;\n    float NoH2 = NoH * NoH;\n    float den = NoH2 * alpha2 + (1. - NoH2);\n    return (chiGGX(NoH) * alpha2) / ( 3.1415926 * den * den );\n}\n\nvec4 render(in vec2 uv)\n{\n    float time = 0.1*iTime;\n    \n    vec3 at = vec3(0, 1, 0);\n    vec3 ro = vec3(4.*sin(time), 2, -4.*cos(time));\n    vec3 cam_z = normalize(at - ro);\n    vec3 cam_x = normalize(cross(vec3(0,1,0), cam_z));\n    vec3 cam_y = cross(cam_z, cam_x);\n    vec3 rd = normalize(cam_x * uv.x + cam_y * uv.y + 2. * cam_z);\n    \n    int id = -1;\n    float t_max = 50.;\n    float t = 0.001;\n    for (int i = 0; i < 256; ++i)\n    {\n        if (t > t_max) break;\n        \n        int curr_id;\n        float d = map(ro + t*rd, curr_id);\n        if (d < 0.001)\n        {\n            id = curr_id;\n            break;\n        }\n        t += d;\n    }\n    \n    vec3 sun_color = vec3(1.5);\n    vec3 background = vec3(1.4, 1.6, 1.8);\n    vec3 p = ro + t*rd;\n    vec3 col = background;\n    if (id != -1)\n    {\n        vec3 n = map_n(p);\n        vec3 l = -normalize(vec3(0.5, -0.9, 0.5));\n        \n        vec3 shad = vec3(0);\n        \n        float ao = 1.;\n        if (id == 0)\n        {       \n#if 1       \n           //NOTE: iq's analytical sphere occlusion\n            vec3 d = vec3(0, 1, 0) - p;\n            float l = length(d);\n            ao  = 1.0- max(0.0,dot(n,d))/(l*l*l);\n            \n#else       \n            //NOTE: fake occlusion\n            float t = length(p);\n            ao = smoothstep(0.0, 1.5, t);\n#endif\n        }\n        else if (id == 1)\n        {\n            ao = 0.5 * (dot(n, vec3(0,1,0)) + 1.);\n        }\n        \n     \tfloat roughness;\n        if (id == 0)\n        {\n            roughness = 0.3;\n        }\n        else if (id == 1)\n        {\n            roughness = 0.9;\n        }\n        \n        //ambient\n        shad += 0.3 * ao * background;\n        \n        //sun reflection\n        {\n            vec3 v = normalize(ro - p);\n            vec3 h = normalize(l + v);\n            float R0 = 1. - roughness;\n            float fresnel = R0 + (1. - R0) * pow(1. - dot(v, n), 5.);\n            float diff = (1. - fresnel) * max(0., dot(n, l));\n            float spec = fresnel * GGX_Distribution(n, h, roughness);\n            shad += 0.7 * shadow(p, l) * (diff + spec) * sun_color;\n        }\n        \n        float t = 1.0;\n        if (id == 0)\n        {\n            vec3 _p = p;\n            _p.x = fbm(p);\n            _p.z = fbm(p);\n            t = fbm(_p * vec3(6, 1.0, 0.3));\n        }\n        else if (id == 1)\n        {\n            t = fbm(p * vec3(2.9, 0.2, 3.1));\n        }\n        \n        vec3 color;\n        if (id == 0)\n        {\n            color = mix(vec3(0.05), vec3(0.6, 0.5, 0.35), t);\n        }\n        else if (id == 1)\n        {\n            color = mix(vec3(0.05), vec3(3.0, 2.5, 1.65), t);\n        }\n        \n        col = shad * color;\n        col = mix(col, background, length(p) / t_max);\n    }\n    \n    //poor man's tonemap\n    float k = 1.0;\n    return vec4(1.0 - exp(-col * k), 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\t\n    //vignette\n    vec2 _uv = uv * (1. - uv);\n    float vig = pow(_uv.x*_uv.y*15., 0.15);\n    \n    //render\n    uv = 2.0 * uv - 1.0;\n    uv.x *= iResolution.x/iResolution.y;\n    fragColor = vig * sqrt(render(uv)); //poor man's gamma correct\n}","name":"Image","description":"","type":"image"}]}