{"ver":"0.1","info":{"id":"fl3Gzr","date":"1635561528","viewed":63,"name":"Harmonic Arc","username":"hydrocarborane","description":"Harmonic Arc","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["arc"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Constants\nfloat PI = 3.14159265358979323846;\nvec2 ii = vec2( 0., 1. ); // imaginary unit\n\n\n// Operations on complex numbers (represented as vec2)\n\n// complex logarithm\nvec2 clog(vec2 x){\n    return vec2(log(x.x), atan(x.y, x.x));\n}\n\n// complex multiplication\nvec2 mul(vec2 a, vec2 b){\n    return vec2(a.x * b.x - a.y * b.y,\n                a.x * b.y + a.y * b.x);\n}\n\n// complex conjugation\nvec2 conj(vec2 a){\n    return vec2(a.x, -a.y);\n}\n\n// complex inverse\nvec2 inv(vec2 a) {\n   return conj(a)/dot(a,a);\n}\n\n// complex division\nvec2 div(vec2 a, vec2 b){\n    return mul(a,inv(b));\n}\n\n// harmonic segment\nfloat segment(vec2 z, vec2 p, vec2 q){\n    return clog(div((z - p), (z - q))).y;\n}\n\n// map scalar value to pseudocolor\nvec3 colorMap(float x){\n    x = .5 + .5*x/PI;\n    vec3 colA = vec3(1, 0, 0);\n    vec3 colB = vec3(0, 0, 1);\n    return colA * x + colB * (1.0f - x);\n}\n\nvec2 mobiusTransform(float a, float b, float c, float d, vec2 x){\n    return div(a * x + b, c * x + d);\n}\n\nvec2 invMobiusTransform(float a, float b, float c, float d, vec2 x){\n    return div((-d * x) + b, (c * x) - a);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float t = iTime; // short name for time\n\n    // transform coordinate system so origin is in the center,\n    // and so that pixels have a square aspect ratio\n    vec2 z = (fragCoord-iResolution.xy/2.)/iResolution.x;\n    //float r = sin(t * 2.0f) * 0.25f;\n    float r = 0.25f;\n    // float r = 0.125;\n    // vec2 p = r*vec2(cos(t),sin(t));\n    float s2 = sqrt(2.0) / 2.0;\n    float diamPos = 1.0 / (2.0 * r * s2);\n    float theta = sin(t) * (PI / 2.0);\n    //float anglePos = (1.0 - sqrt(1.0 - 2.0 * (sin(theta)*sin(theta)))) / (2.0 * r * sin(theta));\n    //float anglePos = 2.0 * r;\n    float anglePos = sqrt((diamPos - (diamPos * diamPos * (r * s2)) - (diamPos * diamPos * (r * s2) * sin(theta)))\n                         / (r + r * sin(theta)));\n    vec2 p1 = vec2(diamPos, -anglePos);\n    vec2 p2 = vec2(diamPos, anglePos);\n    float a = 0.0;\n    float b = 1.0;\n    float c = 1.0;\n    float d = 0.0;\n    vec2 offset = vec2(r * s2,r * s2);\n    // vec2 invPos = invMobiusTransform(a,b,c,d,pos);\n\n    vec3 col = colorMap(segment(invMobiusTransform(a,b,c,d,z + offset), p1, p2) );\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}