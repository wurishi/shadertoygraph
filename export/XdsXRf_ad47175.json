{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"#define PI 3.1415926535897932384626433832795\n\nfloat LineToPointDistance2D( vec2 a, vec2 b, vec2 p)\n{\n    vec2 pa = p - a;\n    vec2 ba = b - a;\n\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0);\n\n    return length( pa - ba*h );\n}\n\n\nvec2 rotatePoint(vec2 center,float angle,vec2 p)\n{\n  float s = sin(angle);\n  float c = cos(angle);\n\n  // translate point back to origin:\n  p.x -= center.x;\n  p.y -= center.y;\n\n  // rotate point\n  float xnew = p.x * c - p.y * s;\n  float ynew = p.x * s + p.y * c;\n\n  // translate point back:\n  p.x = xnew + center.x;\n  p.y = ynew + center.y;\n  return p;\n}\n\n\nvoid getBlips(float radius, out vec2[1] blipsOut)\n{\t\n\tvec2 cen = iResolution.xy/2.0;\n\tfloat sec = iDate[3];\n\tfloat mdl = mod(sec,10.0);\n\t\n\t//From 1 to 6 \n\tfloat cstepRot = ((sec-mdl)/10.0)+1.0;\n\tfloat factorRot = cstepRot/6.0;\n\t\n\tfloat factorLen = sin(factorRot)/2.0;\n\tfloat len = radius*factorLen;//0.5;);\n\tvec2 targetP = vec2(cen.x,cen.y+len);\t\n\tfloat ang  =  PI*factorRot*2.0;\n\ttargetP = rotatePoint(cen,ang,targetP);\n\t\n\tblipsOut[0] = targetP;\t\t\n}\n\nfloat angleVec(vec2 a_, vec2 b_) \n{\n    vec3 a = vec3(a_, 0);\n    vec3 b = vec3(b_, 0);\n     float dotProd = dot(a,b); \n     vec3 crossprod = cross(a,b);\n     float crossprod_l = length(crossprod);\n     float lenProd = length(a)*length(b);\n     float cosa = dotProd/lenProd;\n     float sina = crossprod_l/lenProd;\n     float angle = atan(sina, cosa);\n    \n     if(dot(vec3(0,0,1), crossprod) < 0.0) \n        angle=90.0;\n     return (angle * (180.0 / PI));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 center =iResolution.xy/2.0;\n\tfloat minRes = min(center.x,center.y);\n\tfloat radius =minRes-minRes*0.1;\n\tfloat circleWitdh = radius*0.02;\n\tfloat lineWitdh = circleWitdh*0.8;\n\tfloat angleStela = 180.0;\t\n\tvec2 lineEnd =  vec2(center.x,center.y+radius);\n\n\tfloat blue =0.0;\n\tfloat green =0.0;\n\t\n\tfloat distanceToCenter = distance(center,fragCoord.xy);\t\n\tfloat disPointToCircle=abs(distanceToCenter-radius);\n\t\t\t\t\t\t\t\n\t//Draw Circle\n\tif (disPointToCircle<circleWitdh)\n\t{\n\t\tgreen= 1.0-(disPointToCircle/circleWitdh);\n\t}\n\t\n\t//Rotate Line\n\tfloat angle = (-iTime*1.2);\n\tlineEnd = rotatePoint(center,angle,lineEnd);\n\t\n\t//Draw Line\t\n\tfloat distPointToLine = LineToPointDistance2D(center,lineEnd,fragCoord.xy);\n\tif (distPointToLine<lineWitdh)\n\t{ \n\t\tfloat val = 1.0-distPointToLine/lineWitdh;\n\t\tif (val>green)\n\t\t\tgreen=val;\n\t}\n\t\n\t\n\t//Draw Stela\n\tfloat angleStelaToApply = angleVec(normalize(lineEnd-center),normalize(fragCoord.xy-center));\n\tif (angleStelaToApply<angleStela && distanceToCenter<radius-circleWitdh/2.0+1.0)\n\t{\n\t\tfloat factorAngle = 1.0-angleStelaToApply/angleStela;\n\t\t\n\t\tfloat finalFactorAngle = (factorAngle*0.5)-0.15;\n\t\t\n\t\t\n\t\tif (finalFactorAngle>green)\n\t\t\tgreen=finalFactorAngle;\n\t\t\n\n\t\t\t\n\t\t//DrawBlips\n\t\tvec2 blips[1];\n\t\tfloat angles[1];\n\t\tgetBlips(radius,blips);\n\n\t\t\n\t\tfloat distToBlip = distance(fragCoord.xy,blips[0]);//blips[0]);\n\t\t\t\n\t\tif (distToBlip<15.0)\n\t\t{\n\t\t\tfloat blipFactor = 1.0-distToBlip/15.0;\n\t\t\tfloat toSubtract = 1.0-factorAngle;\n\t\t\tfloat final = blipFactor-toSubtract;\n\t\t\tif (final>green)\n\t\t\tgreen = final;\n\t\t}\t\t\t\n\t}\n\n\tfragColor = vec4(0.0,green,blue,1.0);\n}\n\n\n","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"XdsXRf","date":"1405190208","viewed":1741,"name":"Simple Radar","username":"henrydm","description":"A radar, with a circular moving line and a motion blur","likes":18,"published":1,"flags":0,"usePreview":0,"tags":["2d","simple"],"hasliked":0,"parentid":"","parentname":""}}