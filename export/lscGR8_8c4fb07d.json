{"ver":"0.1","info":{"id":"lscGR8","date":"1447968137","viewed":156,"name":"lots of dots","username":"ak","description":"simple","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[],"code":"#define STEPS 128\n\nmat3 my(float beta)\n{\n\treturn mat3(cos(beta), 0, sin(beta),\n\t\t\t\t0, 1, 0,\n\t\t\t\t-sin(beta), 0, cos(beta));\n}\n\nmat3 mx(float beta)\n{\n\treturn mat3(1, 0, 0,\n\t\t\t\t0, cos(beta), sin(beta),\n\t\t\t\t0, -sin(beta), cos(beta));\n}\n\n\nfloat sphere ( vec3 p, float s )\n{\n    return length(p) - s;\n}\n\n\nfloat rep( vec3 p, vec3 c )\n{\n    vec3 q = mod(p, c) - 0.5 * c;\n    return sphere(q, 0.05);\n}\n\nfloat map( vec3 ro, vec3 rd )\n{\n\tfloat res;\n\tfloat val = -1.0;\n\tvec3 ray = ro + rd;\n\tfor (int j = 0; j < STEPS; j++)\n\t{\n\t\tfloat t = float(j)/float(STEPS);\n\t\t\n\t\tfloat res = rep(ray, vec3(0.55));\t\t\n\t\t\n\t\tif (res < .001)\n\t\t{\n\t\t\tval = length(ray);\n            break;\n\t\t}\n\t\t\t\t\n\t\tif (length(ray) > 9.0) return -1.0;\n\t\tray += res * rd;\n\t}\n\treturn val;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n   \n    float aspect = iResolution.x/iResolution.y;\n\tvec3 ro = vec3(0.0, 0.0, 3.0);\n\tvec3 rd = normalize(vec3( (-1.0+2.0*uv) * vec2(aspect, 1.0), -1.0));\n    \n    ro *= my(iTime) * mx(iTime * 0.1);\n    rd *= my(iTime) * mx(iTime * 0.1);\n    \n    float c;\n\tfloat d = map(ro, rd);\n\t\n\tvec3 col;\n\tif (d > 0.0)\n\t{\n        col = vec3(pow(d * 0.3, 0.9));\n\t}\n\telse\n    {\n\t\tcol = vec3(1.0); //background\n    }\n    \n    \n    \n\tfragColor = vec4(col, 1.0);\n}","name":"","description":"","type":"image"}]}