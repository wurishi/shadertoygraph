{"ver":"0.1","info":{"id":"clsfzj","date":"1693623969","viewed":214,"name":"apartment building","username":"MonterMan","description":"building modeling practice","likes":37,"published":1,"flags":32,"usePreview":1,"tags":["building"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define SAMPLE_COUNT 2\n#define T_MAX 100.0\n#define cdot(a, b) clamp(dot((a), (b)), 0.0, 1.0)\n#define TWEAK1 (iMouse.y/iResolution.y)\n#define TWEAK2 (-iMouse.z/iResolution.x)\n#define TWEAK3 (-iMouse.w/iResolution.y)\n\n#define BOUND_GUARD 1\n\nQuery initQuery()\n{\n    Query q;\n    q.t = T_MAX;\n    q.matId = 0;\n    return q;\n}\n\nfloat sdBlindSet(float w, vec3 p)\n{\n    p.z -= 0.01;\n    float id;\n    p.y = opRepeatLinear(p.y, 0.1, id);\n    p.yz *= rot2d(1.1);\n    return sdBox(p, vec3(w,0.01, 0.05));\n}\n\nQuery sdApartment(vec3 p)\n{\n    Query query = initQuery();\n\n#if BOUND_GUARD\n    // bounding volume\n    float udBound = udBox(p, vec3(2.5, 7.0, 2.5));\n    if (udBound > 0.4)\n    {\n        query.t = udBound;\n        return query;\n    }\n#endif\n\n    // mirror 4 faces\n    vec3 mp = p;\n    float faceId;\n    mp.z = -mp.z;\n    mp.zx = opRepeatPolar(mp.zx, 6.28/4.0, faceId);\n    mp.z = -mp.z;\n    \n    const float wallDepth = 0.5;\n    const float wallH = 1.5;\n\n    // single rep\n    float floorId = 0.0;\n    if (mp.y > wallH) { mp.y -= wallH; floorId = 1.0; }\n    \n    // brick wall\n    {\n        const vec2 brickDim = vec2(0.3, 0.1);\n        const float brickPad = 0.02;\n        const float brickNoise = 0.00; //0.01;\n        \n        float sdWall = udBox2(mp.zy-vec2(-wallDepth,0.5*wallH), vec2(2.0*wallDepth, wallH));\n        //if (sdWall < 0.6) // perf guard\n        {\n            vec3 bp = mp;\n\n            vec2 brickId;\n            bp.y = opRepeatLinear(bp.y, brickDim.y+brickPad, brickId.y);\n            if ((int(brickId.y) & 1) == 0)\n            {\n                bp.x += 0.5*brickDim.x;\n            }\n            bp.x = opRepeatLinear(bp.x, brickDim.x+brickPad, brickId.x);\n            float brickPerturb = brickNoise * bilat(fbm2(20.0*mp.xy));\n            float sdBricks = udBox(bp-vec3(0,0,-2.0*wallDepth),\n                                   vec3(brickDim+brickPerturb,0.1)) - 0.01;\n            sdWall = min(sdWall, sdBricks);\n        }\n        update(query, sdWall, 2);\n    }\n    \n    // ledge\n    update(query, udBox2(mp.yz-vec2(0,-2.0*wallDepth), vec2(0.15, 0.25))-0.02, 3);\n    update(query, udBox2(mp.yz-vec2(wallH,-2.0*wallDepth), vec2(0.15, 0.25))-0.02, 3);\n    \n    // side pillars\n    {\n        vec3 sp = mp;\n        sp.x = abs(sp.x);\n        float temp;\n        sp.y = opRepeatLinear(sp.y, 0.185, temp);\n        float sdPillar = udBox(sp-vec3(2.0*wallDepth+0.1,0.0,-2.0*wallDepth),\n                               vec3(0.2,0.16,0.2))-0.01;\n        update(query, sdPillar, 3);\n    }\n    \n    // windows\n    {\n        const vec3 windowSize = vec3(0.5, 1.0, 0.2);\n        vec3 wp = mp;\n        wp -= vec3(0,0.8,-2.0*wallDepth);\n        \n        // cheaper 3-time repetition\n        float windowId = 0.0;\n        if (wp.x > 0.35) { wp.x -= 0.7; windowId = 1.0; }\n        if (wp.x < -0.35) { wp.x += 0.7; windowId = 2.0; }\n        \n        float sdFrame = udBox(wp, vec3(windowSize.xy, 0.2))-0.01;\n        vec3 ep = wp;\n        float temp;\n        ep.y = opRepeatLinear(ep.y, 0.14, temp);\n        sdFrame = smax(sdFrame, -sdBox2(ep.yz-vec2(0.0,-0.15), vec2(0.02, 0.1)), 0.01);\n        update(query, sdFrame, 3);\n        \n        query.t = max(query.t, -sdBox(wp,\n                                      vec3(windowSize.xy-0.1, 0.25)));\n        \n        const float stickW = 0.025;\n        float sdWindow = udBox(wp-vec3(0,0,-0.07),\n                               vec3(windowSize.x, stickW, stickW))-0.01;\n        sdWindow = min(sdWindow, udBox(wp-vec3(0,0,-0.072),\n                               vec3(stickW, windowSize.y, stickW))-0.01);\n        update(query, sdWindow, 4);\n        \n        // blinds\n        {\n            float sdBlinds = sdBlindSet(windowSize.x, wp);\n            sdBlinds = min(sdBlinds, sdBlindSet(windowSize.x, wp-vec3(0,-0.05,0)));\n            update(query, sdBlinds, 3);\n        }\n\n#if 1\n        // AC\n        {\n            vec3 ACId = vec3(floorId, windowId, faceId);\n            vec4 ACSeed = hash43(ACId);\n            \n            if (ACSeed.z < 0.6)\n            {\n                vec3 ap = wp;\n                ap -= vec3(-0.1+0.2*ACSeed.y, -0.4, -0.15);\n                float scale = 0.5;\n                ap /= scale;\n                float sdAC = sdBox(ap, vec3(0.6, 0.45, 0.2))-0.02;\n                float holeOffset = ACSeed.x > 0.5? 0.1: -0.1;\n                sdAC = max(sdAC, -sdCylinder(ap.xzy-vec3(holeOffset,-0.1,0), 0.3, 0.4));\n                update(query, sdAC*scale, 3);\n                float sdFan = sdCylinder(ap.xzy-vec3(holeOffset,-0.06,0), 0.02, 0.36);\n                update(query, sdFan*scale, 5);             \n            }\n        }\n#endif\n\n        wp.z *= 2.;\n        float sdGarg = sdSegment(wp.yxz-vec3(0.62, 0, -0.27), 0.4+0.8*(wp.y-0.7), 0.12)/2.;\n        wp.z /= 2.;\n        vec3 cp = wp;\n        cp.x = abs(cp.x) - 0.15;\n        sdGarg = smax(sdGarg, -sdBox2(cp.xz-vec2(0,-0.165), vec2(0.01, 0.2)), 0.01);\n        update(query, sdGarg, 3);\n    }\n    \n    query.t = max(query.t, mp.y-wallH);\n    \n    return query;\n}\n\nQuery sdEntrance(vec3 p, inout float inOutT)\n{\n    Query query = initQuery();\n\n#if BOUND_GUARD\n    // bounding volume\n    float udGuard = udBox(p-vec3(-0.7, 0.3, -1.55), vec3(1.0, 3.5, 1.2));\n    if (udGuard > 0.5)\n    {\n        query.t = udGuard;\n        return query;\n    }\n#endif\n\n    // entrance \n    {   \n        // stairs\n        {\n            // TODO: expensive, should derive formula for this one\n            vec3 sp = p-vec3(-0.7,0.1,-1.75);\n            update(query, udBox(sp, vec3(0.7, 0.2, 0.2))-0.01, 3);\n            sp.z -= 0.2;\n            update(query, udBox(sp, vec3(0.7, 0.5, 0.2))-0.01, 3);\n            sp.z -= 0.2;\n            update(query, udBox(sp, vec3(0.7, 0.8, 0.2))-0.01, 3);\n            sp.z -= 0.2;\n            update(query, udBox(sp, vec3(0.7, 1.1, 0.2))-0.01, 3);\n        }\n        \n        // door\n        {\n            vec3 dp = p - vec3(-0.7, 1.25, -1.0);\n            // carve out door space\n            inOutT = max(inOutT, -sdBox(dp, vec3(0.6, 1.2, 0.25)));\n            \n            float sdFrame = sdBox(dp, vec3(0.6, 1.2, 0.25));\n            sdFrame = max(sdFrame, -sdBox(dp, vec3(0.6, 1.2, 0.45)-0.1));\n            update(query, sdFrame, 3);\n            \n            float sdDoor = sdBox(dp, vec3(0.6, 1.2, 0.18));\n            sdDoor = min(sdDoor, udBox(dp, vec3(0.02, 1.2, 0.2))-0.003);\n            dp.y = abs(dp.y) - 0.2;\n            sdDoor = min(sdDoor, udBox(dp, vec3(0.5, 0.02, 0.2))-0.003);\n            update(query, sdDoor, 4);\n        }\n        \n        // railings\n        {\n            vec3 rp = p - vec3(-0.7, 1.25, -1.0);\n            // rails\n            rp.x = abs(rp.x) - 0.3;\n            float sdRail = sdSegment2(rp, vec3(0.0, -0.6, -0.9), vec3(0.0, -0.2, -0.3), 0.015);\n            \n            // rail curls\n            vec3 cp = rp - vec3(0, -0.71, -0.13);\n            cp.z -= 2.0*cp.y*cp.y;\n            sdRail = smin(sdRail, 0.75*sdSegment(cp-vec3(0.0,0.0,-0.8), 0.2, 0.01), 0.01);\n            \n            // legs\n            rp -= vec3(0, -0.8, -0.6);\n            rp.y -= rp.z > 0.0? 0.28: 0.0;\n            rp.z = abs(rp.z) - 0.2;\n            sdRail = smin(sdRail, sdSegment(rp, 0.5, 0.01), 0.01);\n            \n            update(query, sdRail, 5);\n        }\n    }\n    \n    return query;\n}\n\nQuery sdBalcony(vec3 p)\n{\n    Query query = initQuery();\n    \n#if BOUND_GUARD\n    // bounding volume\n    float udGuard = udBox(p, vec3(1.7, 2.0, 1.0));\n    if (udGuard > 0.5)\n    {\n        query.t = udGuard;\n        return query;\n    }\n#endif\n    \n    vec3 balcSize = vec3(1.6, 0.1, 0.6);\n    float sdBase = sdBox(p, balcSize);\n    update(query, sdBase, 5);\n    \n    // railings\n    const float railH = 0.6;\n    {\n        const float railW = 0.013;\n        \n        // TODO: need opRepeatRect() instead of opRepeatLinear() on each axis\n        vec3 rp = p - vec3(0, 0.3, -0.27);\n        rp.x = opRepeatLimLinear(rp.x, 0.18, 8);\n        float sdRail = sdSegment(rp, railH, railW);\n        \n        vec3 hp = p - vec3(0, 0.3, 0.05);\n        hp.x = abs(hp.x) - 0.77;\n        hp.z = opRepeatLimLinear(hp.z, 0.2, 3);\n        sdRail = min(sdRail, sdSegment(hp, railH, railW));        \n        \n        update(query, sdRail, 5);\n    }\n    \n    // handle\n    {\n        vec3 hp = p;\n        hp.y -= railH;\n        float sdHandle = sdBox(hp, vec3(balcSize.x, 0.02, balcSize.z));\n        hp.z -= 0.05;\n        sdHandle = max(sdHandle, -sdBox(hp, vec3(balcSize.x-0.1, 0.06, balcSize.z)));\n        update(query, sdHandle, 5);\n    }\n    \n    return query;\n}\n\nQuery map(vec3 p)\n{\n    Query query = initQuery();\n \n#if 1\n    // floor\n    update(query, p.y, 1);\n    \n    // building\n    {\n        vec3 ap = p;\n        ap.y -= 0.1;\n        \n        // apartment\n        Query aptQuery = sdApartment(ap-vec3(0,0.5,0));\n        update(query, aptQuery.t, aptQuery.matId);\n\n        // base\n        update(query, udBox(ap, vec3(2.25, 0.8, 2.25)), 3);\n\n        // entrance\n        Query entranceQuery = sdEntrance(ap, query.t);\n        update(query, entranceQuery.t, entranceQuery.matId);\n\n        // balcony\n        {\n            vec3 bp = ap-vec3(0.35,2.17,-1.3);\n            bp.x *= 1.2;\n            bp.y *= 1.3;\n            bp.z *= 1.4;\n            Query balcQuery = sdBalcony(bp);\n            balcQuery.t /= 1.4;\n            update(query, balcQuery.t, balcQuery.matId);        \n        }\n    }\n    \n    // base\n    {\n        float guard = sdBox(p, vec3(4.3, 0.3, 4.3)+0.03);\n        if (guard > 0.05)\n        {\n            update(query, guard, 6);\n        }\n        else\n        {\n            // voronoi texture is pre-computed in Buffer A\n            float damage = 0.025*texture(iChannel0, 0.2*(p.xz+vec2(3.0))).r;\n            update(query, 0.5*sdBox(p, vec3(4.3, 0.3+damage, 4.3)), 6);\n        }\n        \n        float sdCurb = abs(sdBox2(p.xz, vec2(3.5, 3.5)) - 0.5) - 0.1;\n        sdCurb = smax(sdCurb, p.y-0.2, 0.03);\n        \n        float id;\n        \n        float cutX = opRepeatLinear(p.x, 0.8, id);\n        sdCurb = smax(sdCurb, 0.02-abs(cutX), 0.03);\n        float cutZ = opRepeatLinear(p.z, 0.8, id);\n        sdCurb = smax(sdCurb, 0.02-abs(cutZ), 0.03);\n        \n        update(query, sdCurb, 3);\n    }\n#else\n    // AC\n    {\n        float sdAC = sdBox(p, vec3(0.6, 0.45, 0.2));\n        sdAC = max(sdAC, -sdCylinder(p.xzy-vec3(0.1,-0.1,0), 0.3, 0.3));\n        update(query, sdAC, 3);\n        float sdFan = sdCylinder(p.xzy-vec3(0.1,-0.06,0), 0.02, 0.26);\n        update(query, sdFan, 5);    \n    }\n#endif\n\n    return query;\n}\n\nfloat calcShadow(vec3 ro, vec3 rd, float k)\n{\n    float res = 1.0;\n    float ph = 1e20;\n    float t = 0.0;\n    for( int i=0; i<256 && t<T_MAX; i++ )\n    {\n        float h = map(ro + rd*t).t;\n        if( h<0.001 )\n            return 0.0;\n        float y = h*h/(2.0*ph);\n        float d = sqrt(h*h-y*y);\n        res = min( res, k*d/max(0.0,t-y) );\n        ph = h;\n        t += h;\n    }\n    return res;\n}\n\nfloat calcAO(vec3 p, vec3 n, float stepSize)\n{\n    float res = 0.0;\n    float amp = 0.5;\n    for (int i = 0; i < 5; ++i)\n    {\n        float t = stepSize*float(i+1);\n        vec3 sampleP = p + t * n;\n        float dist = map(sampleP).t;\n        res += amp * (dist / t);\n        amp /= 2.0;\n        stepSize *= 2.0;\n    }\n    return res;\n}\n\nvec3 calcNormal( in vec3 p ) // for function f(p)\n{\n    const float h = 0.0001;      // replace by an appropriate value\n    #define ZERO (min(iFrame,0)) // non-constant zero\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(p+e*h).t;\n    }\n    return normalize(n);\n}\n\nvec3 render(vec2 uv)\n{\n    vec3 at = vec3(0, 1.3, 0);\n    float cam_angle = 6.28 * iMouse.x / iResolution.x;\n    if (cam_angle == 0.0) cam_angle = 6.28 * 66.0/800.0;\n    vec3 ro = 3.8*vec3(sin(cam_angle), 0.5, -cos(cam_angle));\n    vec3 cam_z = normalize(at - ro);\n    vec3 cam_x = normalize(cross(vec3(0,1,0),cam_z));\n    vec3 cam_y = cross(cam_z, cam_x);\n    vec3 rd = normalize(uv.x * cam_x + uv.y * cam_y + 1.3 * cam_z);\n\n    int matId = -1;\n    float t = 0.0;\n    for (int i = 0; i < 256 && t < T_MAX; ++i)\n    {\n        vec3 p = ro + t * rd;\n        Query query = map(p);\n        if (abs(query.t) < 0.001)\n        {\n            matId = query.matId;\n            break;\n        }\n        t += query.t;\n    }\n\n    vec3 skyAvgCol = vec3(0.5,0.6,0.7);\n    \n    vec3 col = vec3(0);\n    \n    // calc sky gradient\n    vec3 skyCol;\n    {\n        float h = max(0.0, rd.y);\n        h -= 0.09;\n        skyCol = mix(skyAvgCol, vec3(0.75, 0.78, 0.8), exp(-5.0*h));\n    }\n    \n    col = skyCol;\n    if (matId != -1)\n    {\n        vec3 p = ro + t * rd;\n        vec3 n = calcNormal(p);\n        float ao = calcAO(p, n, 0.1);\n        \n        vec3 lightCol = vec3(0.8);\n        vec3 l = normalize(vec3(-0.4, 0.5, -0.4));\n        \n        vec3 albedo = vec3(0.9, 0.1, 0.9);\n        if (matId == 1) // floor\n        {\n            albedo = vec3(0.2);\n        }\n        else if (matId == 2) // brick\n        {\n            albedo = vec3(0.6, 0.1, 0.1);\n        }\n        else if (matId == 3) // stone\n        {\n            albedo = vec3(0.99, 0.99, 0.9);\n        }\n        else if (matId == 4) // wood\n        {\n            albedo = vec3(0.2, 0.1, 0.05);\n        }\n        else if (matId == 5) // metal\n        {\n            albedo = vec3(0.03);\n        }\n        else if (matId == 6) // pavement\n        {\n            albedo = vec3(0.1);\n        }\n        \n        // direct light\n        float shadow = calcShadow(p+0.002*n, l, 32.0);\n        col = albedo * lightCol * cdot(n, l) * shadow;\n        // sky ambient light\n        col += 0.3 * albedo * skyAvgCol * (0.5 + 0.5 * n.y) * ao;\n        // bounced light\n        col += 0.2 * albedo * lightCol * (0.5 - 0.5 * n.y) * ao;\n        \n        col = mix(col, skyCol, 1.0-exp(-0.008*t));\n        //col = vec3(ao);\n        //col = vec3(shadow);\n    }\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv = 2.0 * uv - 1.0;\n    float aspectRatio = iResolution.x / iResolution.y;\n    uv.x *= aspectRatio;\n    vec2 pixelSize = vec2(2.0*aspectRatio,2.0) / iResolution.xy;\n    \n    vec3 col = vec3(0);\n    for (int sampleI = 0; sampleI < SAMPLE_COUNT; ++sampleI)\n    {\n        vec2 jitter = hammersley(sampleI, SAMPLE_COUNT) - 0.5;\n        col += render(uv + jitter * pixelSize);\n    }\n    col /= float(SAMPLE_COUNT);\n\n    col = sqrt(col);\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"float hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nvec4 hash43(vec3 p)\n{\n\tvec4 p4 = fract(vec4(p.xyzx)  * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\n\nfloat radicalInverse(int x, float base)\n{\n    int baseI = int(base);\n    float result = 0.0;\n    float b = 1.0 / base;\n    while (x > 0)\n    {\n        result += float(x % baseI) * b;\n        x /= baseI;\n        b /= base;\n    }\n    return result;\n}\n\nvec2 halton23(int index)\n{\n    return vec2(radicalInverse(index, 2.0), radicalInverse(index, 3.0));\n}\n\nvec2 hammersley(int index, int N)\n{\n    return vec2(float(index)/float(N), radicalInverse(index, 2.0));\n}\n\nmat2 rot2d(float theta)\n{\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat2(\n        c, -s,\n        s, c);\n}\n\nfloat bilat(float x)\n{\n    return 2.0 * x - 1.0;\n}\n\n\nfloat noise2(vec2 p)\n{\n    vec2 ip = floor(p);\n    vec2 fp = fract(p);\n    \n    float a = hash12(ip+vec2(0,0));\n    float b = hash12(ip+vec2(1,0));\n    float c = hash12(ip+vec2(0,1));\n    float d = hash12(ip+vec2(1,1));\n    \n    vec2 t = smoothstep(vec2(0), vec2(1), fp);\n    return mix(mix(a, b, t.x),\n               mix(c, d, t.x),\n               t.y);\n}\n\nfloat fbm2(vec2 p)\n{\n    // origin is always black, offset it a little to look more natural\n    p += vec2(31.2, 72.1);\n    \n    float res = 0.0;\n    \n    float amp = 0.5;\n    float freq = 1.0;\n    for (int i = 0; i < 6; ++i)\n    {\n        res += amp * noise2(p*freq);\n        p *= rot2d(0.3*float(i));\n        freq *= 2.0;\n        amp *= 0.5;\n    }\n    \n    return res;\n}\n\nfloat voronoiEdge(vec2 p, float randomness)\n{\n    vec2 ip = floor(p);\n    vec2 a, b;\n    float aDist = 10e30;\n    float bDist = 10e31;\n    for (int dy = -1; dy <= 1; ++dy)\n    {\n        for (int dx = -1; dx <= 1; ++dx)\n        {\n            vec2 gridId = ip + vec2(dx, dy);\n            vec2 gridP = gridId + mix(vec2(0.5), hash22(gridId), vec2(randomness));\n            float currDist = length(gridP - p);\n            if (currDist < aDist)\n            {\n                bDist = aDist;\n                b = a;\n                aDist = currDist;\n                a = gridP;\n            }\n            else if (currDist < bDist)\n            {\n                bDist = currDist;\n                b = gridP;\n            }\n        }\n    }\n    \n    vec2 ab = b - a;\n    vec2 ap = p - a;\n    float t = dot(ap, ab) / dot(ab, ab);\n    return smoothstep(0.0, 0.03, abs(t-0.5));\n}\n\n//\n//\n// modeling essentials\n\n\nstruct Query\n{\n    float t;\n    int matId;\n};\n\n\nvoid update(inout Query query, float t, int matId)\n{\n    if (t < query.t)\n    {\n        query.t = t;\n        query.matId = matId;\n    }\n}\n\nfloat sdSphere(vec3 p, float r)\n{\n    return length(p) - r;\n}\n\nfloat sdSegment(vec3 p, float h, float r)\n{\n    p.y = max(0.0, abs(p.y) - 0.5*h);\n    return length(p) - r;\n}\n\nfloat sdSegment2(vec3 p, vec3 a, vec3 b, float r)\n{\n    vec3 ab = b - a;\n    vec3 ap = p - a;\n    float t = clamp(dot(ap, ab) / dot(ab, ab), 0.0, 1.0);\n    return length((a + t*ab) - p) - r;\n}\n\nfloat udBox2(vec2 p, vec2 dim)\n{\n    p = abs(p);\n    return length(max(vec2(0.0), p-0.5*dim));\n}\n\nfloat udBox(vec3 p, vec3 dim)\n{\n    vec3 q = abs(p) - 0.5*dim;\n    return length(max(q, 0.0));\n}\n\nfloat sdBox2(vec2 p, vec2 dim)\n{\n    vec2 q = abs(p) - 0.5*dim;\n    return length(max(q, 0.0)) + min(max(q.x, q.y), 0.0);\n}\n\nfloat sdBox(vec3 p, vec3 dim)\n{\n    vec3 q = abs(p) - 0.5*dim;\n    return length(max(q, 0.0)) + min(max(max(q.x, q.y), q.z), 0.0);\n}\n\nfloat sdCylinder(vec3 p, float h, float r)\n{\n    return sdBox2(vec2(length(p.xz), p.y), vec2(r, h));\n}\n\nfloat opRepeatLinear(float x, float period, out float outId)\n{\n    outId = floor((x+0.5*period) / period);\n    return mod(x+0.5*period, period)-0.5*period;\n}\n\nvec2 opRepeatLinear2(vec2 x, vec2 period, out vec2 outId)\n{\n    outId = floor((x+0.5*period) / period);\n    return mod(x+0.5*period, period)-0.5*period;\n}\n\n// basically mod(), but limited to hcount on each direction\nfloat modLim(float x, float period, float hcount)\n{\n    float id = floor(x/period);\n    if (id > 0.0) id = min(id, hcount);\n    if (id < 0.0) id = max(id, -hcount);\n    return x - id*period;\n}\n\nfloat opRepeatLimLinear(float x, float period, int count)\n{\n    float hcount = float(count/2);\n    return modLim(x+0.5*period, period, hcount)-0.5*period;\n}\n\nvec2 opRepeatPolar(vec2 p, float periodRadians, out float outId)\n{\n    float radius = length(p);\n    float theta = atan(p.y, p.x);\n    \n    theta = opRepeatLinear(theta, periodRadians, outId);\n    return radius * vec2(cos(theta), sin(theta));\n}\n\nfloat smin(float a, float b, float k)\n{\n    float term = max(0.0, k - abs(a - b));\n    return min(a, b) - 0.25/k*term*term;\n}\n\nfloat smax(float a, float b, float k)\n{\n    float term = max(0.0, k - abs(a - b));\n    return max(a, b) + 0.25/k*term*term;\n}","name":"Common","description":"","type":"common"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// pre-compute voronoi texture\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv = 2.0 * uv - 1.0;\n    uv.x *= iResolution.x/iResolution.y;\n\n    fragColor = vec4(voronoiEdge(vec2(2.5,3.5)*uv, 1.0));\n}","name":"Buffer A","description":"","type":"buffer"}]}