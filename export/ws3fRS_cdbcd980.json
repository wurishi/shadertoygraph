{"ver":"0.1","info":{"id":"ws3fRS","date":"1605403337","viewed":125,"name":"2D Shapes - Fake 3D Lighting","username":"rito15","description":"Mouse Drag : Change Light Direction","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["2d","lighting"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n/**************************************************************************************************\n * Options\n **************************************************************************************************/\n// Current Scene Number\n// 1 : 2.5D Shapes\n// 2 : todo\n#define SCENE_NUMBER 1\n\n// 0 : No Grids / 1 : 0.05 unit / 2 : 0.1 unit\n#define LEVEL_GRID_DEBUG 1\n\n// 0 : No Grids / 1 : Behind Shapes / 2 : In Front of Shapes\n#define LEVEL_SHOW_GRID 1\n\n// Light Options\nfloat3 lightDirection = float3(-0.2, 0.2, 1.0);\nfloat  lightIntensity = 1.0;\nfloat3 lightColor = float3(1.0, 1.0, 0.9);\n\n// Jelly..?\n#define JELLY 1.5\n\n/**************************************************************************************************\n * Macro Constants\n **************************************************************************************************/\n#define SHAPE_TYPE   int\n\n#define SHAPE_SPHERE 0\n#define SHAPE_CIRCLE 1\n#define SHAPE_RECT   2\n#define SHAPE_HEART  3\n\n/**************************************************************************************************\n * Global Variables\n **************************************************************************************************/\nfloat2 T;  // Time value\nfloat3 L;  // Light Vector (Directional)\nfloat3 V  = float3(0.0, 0.0, 1.0); // View Vector\nfloat3 bg = float3(0.2);           // Background Color\n\nfloat3 N;  // Normal Vector\nfloat3 R;  // Refelction Vector (-L -> N)\nfloat3 H;  // Half Vector (L + V)\nfloat NdL; // Normal dot Light\nfloat specular;\n\n/**************************************************************************************************\n * Structs\n **************************************************************************************************/\nstruct SceneColor\n{\n \tfloat  shape;\n    float3 color;\n};\n\nstruct ShapeData\n{\n    SHAPE_TYPE type;\n    float2 uv;\n    float2 position;\n    float2 size;\n    float  smoothness;\n    float3 color;\n};\n\nstruct Shape\n{\n    ShapeData data;\n    float  shape;  // Black or White\n    float3 normal; // Calculated Virtual 3D Normal Vector\n    float  diffuse;// Lambert, ..\n    float3 color;  // Final Color = Shape * Shade * Color\n};\n\n/**************************************************************************************************\n * Drawing Functions\n **************************************************************************************************/\nfloat DrawShape(ShapeData d, SHAPE_TYPE type)\n{\n    float2 uv;\n    float2 size;\n    \n    switch(type)\n    {\n        case SHAPE_SPHERE:\n        case SHAPE_CIRCLE:\n        \treturn smoothstep(1., 1. - d.smoothness, length((d.uv - d.position) / d.size));\n        \n        case SHAPE_RECT:\n        \tuv = d.uv - d.position;\n    \t\tsize = d.size * 0.5;\n \t\t\treturn smoothstep(0.0, - d.smoothness, max(abs(uv.x) - size.x, abs(uv.y) - size.y));\n        \n        case SHAPE_HEART:\n        \tuv = (d.uv - d.position) / (d.size * float2(0.5, 0.4));\n            float2 heartBase = float2(uv.x, uv.y - sqrt(abs(uv.x)) + 0.32);\n            return smoothstep(1.0, 1.0 - d.smoothness, length(heartBase));\n    }\n    \n    return 0.0;\n}\n\n/**************************************************************************************************\n * Normal Functions\n **************************************************************************************************/\nfloat3 GetNormal(ShapeData d, SHAPE_TYPE type)\n{\n    float3 N;\n    float2 uv = d.uv;\n    float2 pos = d.position;\n    float2 size = d.size;\n    \n    float2 dist;\n    float edge;\n    float k;\n    \n    float2 cf1, cf2;\n    \n    switch(type)\n    {\n        /*********************************************************************\n\t\t*                        0 : Sphere\n\t\t**********************************************************************/\n        case SHAPE_SPHERE:\n        \tN.xy = (d.uv - d.position) / d.size;\n        \tN.z  = cos( ( length(d.uv - d.position) ) / max(size.x, size.y) * PI * 0.5 );\n        break;\n        \n        /*********************************************************************\n\t\t*                        1 : Circle\n\t\t**********************************************************************/\n        case SHAPE_CIRCLE:\n            dist = (uv - pos) / size;\n            edge = min(size.x, size.y) * 0.5;\n            float k = min( (dist.x), (dist.y) );\n\n            cf1 = float2(\n                smoothstep( 1.0 - edge, 1.0, length(dist))\n            );\n\n            cf2 = float2(\n                -smoothstep( -1.0 + edge, -1.0, length(dist))\n            );\n\n            N.xy = lerp( lerp(cf1, cf2, 0.5), dist, cf1);\n            N.z = pow( sqrt(cos( k * 0.5 * PI ) ), 0.1) * 0.2;\n        break;\n        \n        /*********************************************************************\n\t\t*                        2 : Rect\n\t\t**********************************************************************/\n        case SHAPE_RECT:\n            dist = (uv - pos) / (size * 0.5);\n            edge = min(size.x, size.y) * 0.2; // 가장자리 음영 부분 너비\n            k = min( (dist.x), (dist.y) );\n\n            cf1 = float2(\n                smoothstep( 1.0 - edge, 1.0, dist.x) ,\n                smoothstep( 1.0 - edge, 1.0, dist.y)\n            );\n\n            cf2 = float2(\n                -smoothstep( -1.0 + edge, -1.0, dist.x) ,\n                -smoothstep( -1.0 + edge, -1.0, dist.y)\n            );\n\n            N.xy = lerp(cf1, cf2, 0.5);\n            N.z = pow( sqrt(cos( k * 0.5 * PI ) ), 0.1) * 0.2;\n        break;\n        \n        /*********************************************************************\n\t\t*                        3 : Heart\n\t\t**********************************************************************/\n        case SHAPE_HEART:\n        \tsize = d.size * float2(0.5, 0.4);\n            pos = d.position;\n            uv = (d.uv - d.position) / (d.size);\n\n            float2 suv = uv * float2(0.27, 0.4);\n\n            dist = uv*0.5;\n            edge = min(size.x, size.y) * 0.5;\n            k = min( (dist.x), (dist.y) );\n\n\n            float2 heartBase = float2(uv.x, uv.y - sqrt(abs(uv.x)) + 0.32);\n            float heart = smoothstep(1.0, edge, length(heartBase));\n\n            float2 sHertBase = float2(suv.x*1., suv.y - sqrt(abs(suv.x)*1.3+0.16)+0.43);\n            float sHeart = smoothstep(edge, 0.0, length(sHertBase)*0.95);\n\n            N.xy = lerp(heartBase, dist, 0.8);\n\n            k = lerp(k, 1. - sHeart, 0.9);\n            N.z = pow( sqrt(cos( k * 0.5 * PI ) ), 2.5)*1.2;\n        break;\n    }\n    \n    return normalize(N);\n}\n\n/**************************************************************************************************\n * Final Shape Functions\n **************************************************************************************************/\n// Lambert + Blinn Phong\nShape DrawLBPShape(ShapeData d)\n{\n    Shape s;\n    float3 N;\n    \n    s.data   = d;\n    s.shape  = DrawShape(s.data, d.type);\n    s.normal = N = GetNormal(s.data, d.type);\n    \n    float NdL = dot(N, L);\n    float lambert = saturate(NdL);\n    \n    float3 H = normalize(L + V);\n    float specular = pow( saturate( dot(H, N) ), 100. );\n    \n    s.diffuse = (lambert + specular); // DO NOT SATURATE\n    s.color = s.shape * s.diffuse * d.color;\n    \n    return s;\n}\n\n\n/**************************************************************************************************\n * Scenes\n **************************************************************************************************/\n// 1 : Many Shapes\nSceneColor Scene1(float2 uv)\n{\n    SceneColor scene;\n    float  shp = 0.0;\n    float3 col = float3(0.0);\n    \n    float2[5] uvJelly;\n    for(int i = 0; i < 5; i++)\n    \tuvJelly[i] = UvWave(uv, float2(Random11(float(i) * 2.345, 5.,15.)), float3(0.2, 0.17, 0.1)*JELLY, iTime*3.0);\n    \n    Shape sphere = DrawLBPShape( ShapeData(SHAPE_SPHERE, uvJelly[0], float2(-1.3, 0.5),  float2(0.4, 0.4), 0.01, WHITE) );\n    Shape circle = DrawLBPShape( ShapeData(SHAPE_CIRCLE, uvJelly[1], float2(-0.2, 0.5),  float2(0.5, 0.4), 0.01, WHITE_MINT) );\n    Shape rect   = DrawLBPShape( ShapeData(SHAPE_RECT,   uvJelly[2], float2(1.1, 0.5),   float2(1.2, 0.8), 0.01, LIGHT_GOLD) );\n    Shape heart  = DrawLBPShape( ShapeData(SHAPE_HEART,  uvJelly[3], float2(-1.3, -0.5), float2(0.8, 0.8), 0.1, LIGHT_PINK * 1.5) );\n    \n    // Shapes ==========================================\n    shp += sphere.shape;\n    shp += circle.shape;\n    shp += rect.shape;\n    shp += heart.shape;\n    \n    // Colors ==========================================\n    col += sphere.color;\n    col += circle.color;\n    col += rect.color;\n    col += heart.color;\n    \n    \n    scene.shape = saturate(shp);\n    scene.color = saturate(col);\n    return scene;\n}\n\n// 2 : Todo\nSceneColor Scene2(float2 uv)\n{\n    SceneColor scene;\n    \n    return scene;\n}\n\n/**************************************************************************************************\n * Main\n **************************************************************************************************/\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // UV ================================================================================================\n    float2 uv  = fragCoord/iResolution.xy;\t\t\t\t\n    float2 uv0 = uv;                                                          // Full Screen  0.0 ~ 1.0\n    float2 uv1 = uv * 2.0 - 1.0;                                              // Full Screen -1.0 ~ 1.0\n    float2 uv2 = (uv - 0.5) * float2(iResolution.x/iResolution.y, 1.0) + 0.5; // Square Area  0.0 ~ 1.0\n    float2 uv3 = uv2 * 2.0 - 1.0;\t\t\t\t\t\t                      // Square Area -1.0 ~ 1.0\n    \n    // Final Variables ===================================================================================\n    float  shp = float(0.0);\t// Shape\n    float3 col = float3(0.0);\t// Color\n    float3 grd = float3(0.0);   // Debug Grids\n    \n    \n    /******************************************************************************************************************\n     * Body Start                                                                                                     *\n     ******************************************************************************************************************/\n    T = float2(cos(iTime), sin(iTime)) * 0.5;\n    \n    L = lightDirection + float3(T.xy, 0.); // Directional Light\n    L = normalize(L);\n    \n    if(iMouse.z > 0.)\n    {\n        L = normalize(float3(iMouse.xy / iResolution.xy * 4.0 - 2.0, 1.0));\n    }\n    \n    SceneColor scene;\n    scene = \n    #if SCENE_NUMBER == 1\n    \tScene1(uv3);\n    #elif SCENE_NUMBER == 2\n    \tScene2(uv3);\n    #endif\n    \n    shp = scene.shape;\n    col = scene.color;\n    \n    /******************************************************************************************************************\n     *                                                                                                       Body End *\n     ******************************************************************************************************************/\n    \n    // Debug Grids =======================================================================================\n    float2 uvGrd = uv2;\n    \n    grd += debugCenterLine(uvGrd) * float(LEVEL_GRID_DEBUG) * 0.4;\n    grd += debugOutLine(uvGrd) * float(LEVEL_GRID_DEBUG) * 0.4;\n    grd += debugGrid(uvGrd, 0.05 * float(LEVEL_GRID_DEBUG) ) * 0.2;\n\n    grd = saturate(grd);\n    \n    // End Point =========================================================================================\n    fragColor.a = 1.0;\n    fragColor.rgb = \n        shp * col * lightColor * lightIntensity\n        + (1. - shp) * bg;\n    \n    #if LEVEL_SHOW_GRID == 1\n    \n    fragColor.rgb += grd * (1. - shp);\n    \n    #elif LEVEL_SHOW_GRID == 2\n    \n    float3 grdWB = float3(step(0.001, grd.r+grd.g+grd.b)); \n    fragColor.rgb = lerp(fragColor.rgb, grd+0.2, grdWB);\n    \n    #endif\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"/**************************************************************************************************\n * DEFINITIONS : Unity Compatibility\n **************************************************************************************************/\n#define float2   vec2\n#define float3   vec3\n#define float4   vec4\n#define float2x2 mat2\n#define float3x3 mat3\n#define float4x4 mat3\n\n#define frac(x)     fract(x)\n#define saturate(x) clamp(x, 0., 1.)\n\n#define atan2(x,y)    atan(y,x)\n#define tex2D(s,t)    texture(s,t)\n#define mul(mat,vec)  vec*mat;\n\n#define lerp(a,b,t) mix(a,b,t)\n\n/**************************************************************************************************\n * DEFINITIONS - Constant\n **************************************************************************************************/\n#define PI 3.141592653589793\n\n/**************************************************************************************************\n * DEFINITIONS - Function\n **************************************************************************************************/\n#define S(a, b, t) smoothstep(a, b, t)\n\n// Remap : (0 ~ 1) => (a, b)\n#define R01(t, a, b) (b - a) * t + a\n\n// Remap : (-1 ~ 1) => (a, b)\n#define R11(t, a, b) (b - a) * (1. - t) * 0.5 + a\n\n/**************************************************************************************************\n * DEFINITIONS - float3 Colors\n **************************************************************************************************/\n#define BLACK float3(0.0, 0.0, 0.0)\n#define WHITE float3(1.0, 1.0, 1.0)\n\n#define RED   float3(1.0, 0.0, 0.0)\n#define GREEN float3(0.0, 1.0, 0.0)\n#define BLUE  float3(0.0, 0.0, 1.0)\n\n#define YELLOW  float3(1.0, 1.0, 0.0)\n#define CYAN    float3(0.0, 1.0, 1.0)\n#define MAGENTA float3(1.0, 0.0, 1.0)\n\n#define GOLD   float3(1.00, 0.80, 0.00)\n#define ORANGE float3(1.00, 0.50, 0.00)\n#define PINK   float3(1.00, 0.00, 1.00)\n#define BROWN  float3(0.50, 0.25, 0.00)\n#define VIOLET float3(0.50, 0.00, 1.00)\n#define LIME   float3(0.75, 1.00, 0.00)\n#define MINT   float3(0.00, 1.00, 0.50)\n#define SKY    float3(0.00, 1.00, 1.00)\n\n#define LIGHT_RED    float3(1.00, 0.50, 0.50)\n#define LIGHT_BLUE   float3(0.50, 0.50, 1.00)\n#define LIGHT_GREEN  float3(0.50, 1.00, 0.50)\n\n#define LIGHT_GOLD   float3(1.00, 0.90, 0.50)\n#define LIGHT_YELLOW float3(1.00, 1.00, 0.75)\n#define LIGHT_ORANGE float3(1.00, 0.75, 0.50)\n#define LIGHT_PINK   float3(1.00, 0.50, 1.00)\n#define LIGHT_BROWN  float3(0.75, 0.50, 0.25)\n#define LIGHT_VIOLET float3(0.75, 0.50, 1.00)\n#define LIGHT_MINT   float3(0.50, 1.00, 0.75)\n#define LIGHT_SKY    float3(0.50, 1.00, 1.00)\n\n#define WHITE_PINK   float3(1.00, 0.75, 1.00)\n#define WHITE_MINT   float3(0.75, 1.00, 0.95)\n\n#define DARK_RED     float3(0.50, 0.00, 0.00)\n#define DARK_GREEN   float3(0.00, 0.50, 0.00)\n#define DARK_BLUE    float3(0.00, 0.00, 0.50)\n\n#define DARK_BROWN   float3(0.25, 0.12, 0.00)\n#define DARK_MINT    float3(0.00, 0.75, 0.50)\n\n/**************************************************************************************************\n * Functions\n **************************************************************************************************/\nfloat smax(float a, float b, float k)\n{\n    float h = clamp((b - a) / k + 0.5, 0.0, 1.0);\n    return mix(a, b, h) + h * (1.0 - h) * k * 0.5;\n}\nfloat3 smax(float3 a, float3 b, float k)\n{\n    float3 h = clamp((b - a) / k + 0.5, 0.0, 1.0);\n    return mix(a, b, h) + h * (1.0 - h) * k * 0.5;\n}\n\nfloat2 UvWave(float2 uv, float2 uvOffset, float3 waveOffset, float t)\n{\n    float a = waveOffset.x;\n    float b = waveOffset.y;\n    float c = waveOffset.z;\n    \n    float x = (uv.x - uvOffset.x) * a;\n    float y = (uv.y - uvOffset.y) * b;\n    float k;\n    \n    k = sin(x * y + t); // 기본\n    //k *= cos(x *b + cos(t)*0.5) * 0.5 + 0.5; \n    \n    float kkc = abs(k * k * c);\n    float w1 = 1. + kkc * a;\n    float w2 = 1. + kkc * b;\n    return float2(uv.x * w1, uv.y / w2);\n}\n\nfloat Random11(float seed, float min, float max)\n{\n    float t = frac(sin(seed * 13.421 + 23.512) * 17593.39482);\n    return lerp(min, max, t);\n}\n\n/**************************************************************************************************\n * DEBUG Functions \n **************************************************************************************************/\nfloat3 debugCenterLine(float2 uv)\n{\n    if(uv.x > 0.498 && uv.x < 0.502 || uv.y > 0.498 && uv.y < 0.502)\n        return float3(1., 0., 0.);\n}\nfloat3 debugOutLine(float2 uv)\n{\n    if(uv.x > 1.0 && uv.x <= 1.004 || uv.x < 0.0 && uv.x >= -0.004)\n        return float3(0., 0., 1.);\n}\nfloat3 debugGrid(float2 uv, float interval)\n{\n    if(interval <= 0.0) return float3(0.);\n    \n    float2 uvTile = uv / interval + 0.025;\n    uvTile = frac(uvTile);\n    \n    float grid = smoothstep(0.1, 0.00, min(abs(uvTile.x), abs(uvTile.y)));\n    return float3(0., grid, 0.);\n}","name":"Common","description":"","type":"common"}]}