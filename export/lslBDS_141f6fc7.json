{"ver":"0.1","info":{"id":"lslBDS","date":"1497971732","viewed":749,"name":" Drifting Characters","username":"gaz","description":"3d","likes":26,"published":1,"flags":0,"usePreview":1,"tags":["raymarching","font","letters"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"mat3 rotate(in vec3 axis, in float theta)\n{\n  axis = normalize(axis);\n  float x = axis.x, y = axis.y, z = axis.z, s = sin(theta), c = cos(theta), o = 1.0-c;\n  return mat3(\n    o*x*x+c,o*x*y+z*s,o*z*x-y*s,\n    o*x*y-z*s,o*y*y+c,o*y*z+x*s,\n    o*z*x+y*s,o*y*z-x*s,o*z*z+c\n    );\n}\n\nmat3 lookat(in vec3 eye, in vec3 target)\n{\n\tvec3 w = normalize(target-eye);\n\tvec3 u = normalize(cross(w,vec3(0,1,0)));\n    return mat3(u,cross(u,w),w);\n}\n\n// https://www.shadertoy.com/view/4djSRW\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * 443.8975);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 *  vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+19.19);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n}\n\n// https://www.shadertoy.com/view/ltcXzs\nvec4 char(vec2 p, float c) {\n    if (p.x<0.|| p.x>1. || p.y<0.|| p.y>1.) return vec4(0,0,0,1e5);\n\t//return texture( iChannel0, p/16. + fract( floor(vec2(c, 15.999-c/16.)) / 16. ));\n\treturn textureLod( iChannel0, p/16. + fract( floor(vec2(c, 15.999-c/16.)) / 16. ), 0.0);\n}\n\nfloat deChar(in vec3 p, in float c)\n{\n    vec4 f = char(p.xy * 0.13 + 0.5, c);\n    //float w = f.w - 0.5 + 1.0/256.0;\n    //float w = f.w*f.w*f.w-0.095;\n    //float w = smoothstep(0.47, 0.75, f.w);\n    \n    //2020/02/02\n    float w = smoothstep(0.30, 0.7, f.w)*2.0-1.0;\n    w*=0.3;\n    //w=max(w,length(max(abs(p.xy)-3.0,0.0)));\n    \n    vec2 d = vec2(w, abs(p.z) - 0.2);\n    return length(max(d,0.0)) - 0.02;\n\n}\n\nfloat mapA(in vec3 p)\n{\n    // https://www.shadertoy.com/view/XlfGDs\n    // sparse grid skill\n    p = rotate(vec3(1,2,3), 0.7)*p;\n\tvec3 seed = floor(p/10.0);\n    p = mod(p,10.0)-5.0;\n    if ( hash13(seed + vec3(188,345,277)) < 0.8) return 1.0;\n    p = rotate(hash33(seed+vec3(324,154,997))-0.5,iTime*1.2)*p;\n    return deChar(p, floor(hash13(seed+ vec3(124,458,206))*16.*16.));\n}\n\nfloat mapB(in vec3 p)\n{\n    p = rotate(vec3(1),1.0)*p;\n\tvec3 seed = floor(p/8.0);\n    p = mod(p,8.0)-4.0;\n    if ( hash13(seed + vec3(102,345,582)) < 0.8) return 1.0;\n    p = rotate(hash33(seed+vec3(253,155,787))-0.5,iTime*0.8+1.2)*p;\n    return deChar(p, floor(hash13(seed+vec3(158,344,266))*16.*16.));\n}\n\nfloat mapC(in vec3 p)\n{\n    p += 3.5;\n    p = rotate(vec3(3,2,1), 1.5)*p;\n\tvec3 seed = floor(p/8.0);\n    p = mod(p,8.0)-4.0;\n    if ( hash13(seed+ vec3(129,457,628)) < 0.8) return 1.0;\n    p = rotate(hash33(seed+vec3(262,456,776))-0.5,iTime+0.5)*p;\n    return deChar(p, floor(hash13(seed+ vec3(142,245,590))*16.*16.));\n}\n\nfloat map(in vec3 p)\n{  \n\treturn min(min(mapA(p),mapB(p)),mapC(p));  \n}\n\n/*\nvec3 calcNormal(in vec3 pos){\n  vec2 e = vec2(1.0, -1.0) * 0.002;\n  return normalize(\n    e.xyy*map(pos+e.xyy)+e.yyx*map(pos+e.yyx)+ \n    e.yxy*map(pos+e.yxy)+e.xxx*map(pos+e.xxx)\n  );\n}\n*/\n\nvec3 calcNormal(vec3 p){\n    vec3 n = vec3(0);\n    for(int i = min(iFrame, 0); i < 4; i++)\n    {\n        vec3 e = vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))*2.0-1.0;\n        n += e * map(p + 0.001* e);\n    }\n    return normalize(n);\n}\n\nvec3 doColor(vec3 p){\n\tconst float precis = 0.001;\n    if (mapA(p)<precis) return vec3(0.3,0.7,0.2);\n    if (mapB(p)<precis) return vec3(0.7,0.3,0.2);\n    if (mapC(p)<precis) return vec3(0.3,0.7,0.5);\n\treturn vec3(1.0, 0.2, 0.2);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n    vec3 ro = vec3(0.0, 0.0, 10.0);\n    vec3 rd = normalize(vec3(p, -2));\n   \n    // camera sequence \n\tfloat phaseTime, tmpTime = mod(iTime,30.0);\n  \tint phaseNumber; \t\n  \t#define PH(n,v) if (tmpTime >= 0.0) {phaseTime = tmpTime; phaseNumber = n;}  tmpTime -= float(v);  \n    PH(0, 5)\n    PH(3, 7)\n    PH(1, 5)\n    PH(2, 8)\n    PH(3, 5)      \n\tfloat offset = floor(iTime/30.0)*80.0;\n        \n    switch (phaseNumber) {\n    \tcase 0:\n   \t\t\tro.x += phaseTime * 5.0+ offset;\n    \t\tbreak;\n    \tcase 1:\n   \t\t\tro.y += -phaseTime * 5.0+ offset;\n    \t\tbreak;\n    \tcase 2:\n   \t\t\tro.z += phaseTime * 7.0+ offset;\n    \t\t break;\n    \tcase 3: \n        \t{\n            \tvec3 ta = vec3(0);\n            \tro = rotate(vec3(1),-mod(phaseTime*0.3+ offset, 6.283))* vec3(0.0, 0.0, 30.0);\n            \trd = lookat(ro,ta)*rd;\n    \t\t} \n        \tbreak;\n    }    \n    \n\tvec3 col = mix(vec3(0.5, 0.3, 0.0), vec3(0.8), smoothstep(1.5, 3.5, length(p*vec2(1,2))));\n\tconst float maxd = 80.0, precis = 0.001;\n\tfloat t = 0.0, d;\n \tfor(int i = 0; i < 128; i++)\n  \t{\n    \tt += d = map(ro + rd * t);\n    \tif(d < precis || t > maxd) break;\n  \t}\n  \tif(d < precis)\n  \t{\n\t  \tvec3 p = ro + rd * t;\n\t \tvec3 nor = calcNormal(p);\n    \tvec3 li = normalize(vec3(1));\n        vec3 bg = col;\n        col = doColor(p);\n        float dif = clamp(dot(nor, li), 0.3, 1.0);\n        float amb = max(0.5 + 0.5 * nor.y, 0.0);\n        float spc = pow(clamp(dot(reflect(normalize(p - ro), nor), li), 0.0, 1.0), 30.0);\n        col *= dif * amb ;\n        col += spc;\n        col = clamp(col,0.0,1.0);\n        col = mix(bg, col, exp(-t*t*0.0001));\n  \t\tcol = pow(col, vec3(0.8));        \n    }\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}