{"ver":"0.1","info":{"id":"wdGBD3","date":"1608070678","viewed":129,"name":"hyperburger","username":"tripzilch","description":"hyperburger, extra cheese. SDF used for my plotter hatching algo in https://www.instagram.com/p/CIySoR2HE5c/ ","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_DIST 1500.\n#define SURF_DIST .001\n#define GAMMA 2.2\n#define IGAMMA 0.454545\n#define PHI1 0.6180339887498949\n#define PHI256 158.2167011199731\n#define TAU 6.283185307179586\n\nmat2 rot(float a) {\n    float s = sin(a), c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat smin(float a, float b, float k) {\n  float h = max(k - abs(a - b), 0.) / k;\n  return min(a, b) - h * h * h * k * (1. / 6.);\n}\n\nfloat df(vec3 p) {   \n    float flr = length(vec2(max(0., length(p.xz) - 200.), p.y)) - 5.;\n    p.x *= .01;\n    p.x = 100. * (p.x - max(-2., floor(p.x)) - .5);\n    float stok = length(vec3(p.xz, max(p.y, 120.) - 120.)) - 20.;\n    float ss = mix(8., 2., .5 + .1 * clamp(stok, -5., 5.));\n    stok = abs(stok) - 6.;\n    stok = abs(stok) - 1.;\n    \n    float ysp = min(p.y, 135.) * .025;\n    float sp0 = abs(fract(ysp + .1) - .5) * 40. - ss;\n    float sp1 = abs(fract(ysp + .6) - .5) * 40. - ss;\n    float zz = (fract(p.z * .01 - .5) - .5) * 100.;\n    float hol = length(vec2(p.x, zz)) - 35.;\n\n    return 0.8 * min(\n      max(stok, min(sp0, sp1)),\n      -smin(-flr, hol, 20.));\n}\n\nfloat intersect(vec3 ro, vec3 rd, float t0, float t1) {\n    for(float t = t0; t < t1; ) {\n        float h = df(ro + t * rd);\n        t += h;\n        if(h < SURF_DIST) return t;\n    }\n    return t1;\n}\n\nfloat shadow(vec3 ro, vec3 rd, float t0, float t1) {\n    float ph = 1.0e-6, res = 1., k = 24.;\n    for (float t = t0; t < t1; ) {\n        float h = df(ro + t * rd);\n        float y = h * h / (2.0 * ph);\n        float d = sqrt(abs(h * h - y * y));\n        //res = min(res, k * h / t);\n        res = min(res, k * d / max(1e-6, t - y));\n        if (h < SURF_DIST && h <= ph) return clamp(res, 0., 1.);\n        t += h;\n        ph = h;\n    }\n    return clamp(res, 0., 1.);\n}\n\nvec3 normal(vec3 p) {\n    const float h = 0.001;\n    const vec2 k = vec2(1, -1);\n    return normalize(k.xyy*df(p + k.xyy * h) + \n                     k.yyx*df(p + k.yyx * h) + \n                     k.yxy*df(p + k.yxy * h) + \n                     k.xxx*df(p + k.xxx * h) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // input coords\n    vec2 uv = (2. * fragCoord - iResolution.xy) / iResolution.y;\n    \n    vec2 mouse = (iMouse.xy - .5 * iResolution.xy) / iResolution.y;   \n    // light, camera\n    vec3 light_pos = vec3(200., 60., 0.);\n    vec3 camera_pos = vec3(270., 80., 160.);\n    vec3 look_at = vec3(0, 20, -20);\n    float zoom = 1.5;\n    // camera axes\n    vec3 fwd = normalize(look_at - camera_pos);\n    vec3 right = cross(vec3(0, 1, 0), fwd);\n    vec3 up = cross(fwd, right);\n\n    // raymarching\n    vec3 rd = normalize(zoom * fwd + uv.x * right + uv.y * up);\n    float d = intersect(camera_pos, rd, 0.0, MAX_DIST);\n    vec3 p = camera_pos + rd * d;\n    vec3 n = normal(p); \n    vec3 col = vec3(1.);     \n    vec3 l = light_pos - p;\n    float ld = length(l); \n    l /= ld;\n    float dif = clamp(dot(n, l), 0., 1.) * shadow(p + n * SURF_DIST * 2., l, SURF_DIST, ld);\n    col *= vec3(dif); // ?\n    col = mix(col, vec3(1.0), smoothstep(150., 600., d));\n    col *= 1. - step(1., max(abs(uv.x), abs(uv.y)));\n    fragColor = vec4(pow(col, vec3(IGAMMA)), 1.0);\n}","name":"Image","description":"","type":"image"}]}