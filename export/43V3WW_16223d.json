{"ver":"0.1","info":{"id":"43V3WW","date":"1717662022","viewed":101,"name":"Fan Shadow","username":"ljbha007","description":"Fan shadow test","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["volumetric"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n#define MOD2 vec2(.16632,.17369)\n#define MOD3 vec3(.16532,.17369,.15787)\nfloat tri(in float x){return abs(fract(x)-.5);}\n\nfloat hash12(vec2 p)\n{\n\tp  = fract(p * MOD2);\n    p += dot(p.xy, p.yx+19.19);\n    return fract(p.x * p.y);\n}\nfloat vine(vec3 p, in float c, in float h)\n{\n    p.y += sin(p.z*.5625+1.3)*3.5-.5;\n    p.x += cos(p.z*2.)*1.;\n    vec2 q = vec2(mod(p.x, c)-c/2., p.y);\n    return length(q) - h*1.4 -sin(p.z*3.+sin(p.x*7.)*0.5)*0.1;\n}\n\nvec3 tri3(in vec3 p){return vec3( tri(p.z+tri(p.y)), tri(p.z+tri(p.x)), tri(p.y+tri(p.x)));}\nfloat Noise3d(in vec3 p)\n{\n    float z=1.4;\n\tfloat rz = 0.;\n    vec3 bp = p;\n\tfor (float i=0.; i<= 2.; i++ )\n\t{\n        vec3 dg = tri3(bp);\n        p += (dg);\n\n        bp *= 2.;\n\t\tz *= 1.5;\n\t\tp *= 1.3;\n        \n        rz+= (tri(p.z+tri(p.x+tri(p.y))))/z;\n        bp += 0.14;\n\t}\n\treturn rz;\n}\n\n// cone inscribed in a unit cube centered at 0\nbool cone(vec3 org, vec3 dir, out float near, out float far)\n{\n\t// scale and offset into a unit cube\n\t//org.x += 0.5;\n\tfloat s = 0.5;\n\torg.x *= s;\n\tdir.x *= s;\n\t\n\t// quadratic x^2 = y^2 + z^2\n\tfloat a = dir.y * dir.y + dir.z * dir.z - dir.x * dir.x;\n\tfloat b = org.y * dir.y + org.z * dir.z - org.x * dir.x;\n\tfloat c = org.y * org.y + org.z * org.z - org.x * org.x;\n\t\n\tfloat cap = (s - org.x) / dir.x;\n\t\n\t// linear\n\tif( a == 0.0 )\n\t{\n\t\tnear = -0.5 * c/b;\n\t\tfloat x = org.x + near * dir.x;\n\t\tif( x < 0.0 || x > s )\n\t\t\treturn false; \n\n\t\tfar = cap;\n\t\tfloat temp = min(far, near); \n\t\tfar = max(far, near);\n\t\tnear = temp;\n\t\treturn far > 0.0;\n\t}\n\n\tfloat delta = b * b - a * c;\n\tif( delta < 0.0 )\n\t\treturn false;\n\n\t// 2 roots\n\tfloat deltasqrt = sqrt(delta);\n\tfloat arcp = 1.0 / a;\n\tnear = (-b - deltasqrt) * arcp;\n\tfar = (-b + deltasqrt) * arcp;\n\t\n\t// order roots\n\tfloat temp = min(far, near);\n\tfar = max(far, near);\n\tnear = temp;\n\n\tfloat xnear = org.x + near * dir.x;\n\tfloat xfar = org.x + far * dir.x;\n\n\tif( xnear < 0.0 )\n\t{\n\t\tif( xfar < 0.0 || xfar > s )\n\t\t\treturn false;\n\t\t\n\t\tnear = far;\n\t\tfar = cap;\n\t}\n\telse if( xnear > s )\n\t{\n\t\tif( xfar < 0.0 || xfar > s )\n\t\t\treturn false;\n\t\t\n\t\tnear = cap;\n\t}\n\telse if( xfar < 0.0 )\n\t{\n\t\t// The apex is problematic,\n\t\t// additional checks needed to\n\t\t// get rid of the blinking tip here.\n\t\tfar = near;\n\t\tnear = cap;\n\t}\n\telse if( xfar > s )\n\t{\n\t\tfar = cap;\n\t}\n\t\n\treturn far > 0.0;\n}\n\nvoid transformray (vec3 ro, vec3 rd, mat2 rotationY, vec3 offset, out vec3 outro, out vec3 outrd)\n{\n\toutro = ro + offset;\n\toutro = vec3(rotationY * outro.xz, outro.y).xzy;\n\toutrd = vec3(rotationY * rd.xz, rd.y).xzy;\n}\n\n#define ITER 200\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t// camera\n\tvec2 q = fragCoord.xy/iResolution.xy;\n\tvec2 p = -1.0 + 2.0 * q;\n\tp.x *= iResolution.x/iResolution.y;\n\tvec3 camro = normalize(vec3(1.0, -0.1, 0.0));\n\tvec3 w = -camro;\n\t//camro *= 2.5;\n\tvec3 u = normalize(cross( vec3(0.0, 1.0, 0.0), w ));\n\tvec3 v = normalize(cross(w,u));\n\tvec3 camrd = normalize(p.x * u + p.y * v + 1.5 * w);\n\tfragColor = vec4(0.0);\n\t\n\t// rotation\n\tfloat angle = 10.0 * iMouse.x / iResolution.x;\n\tif( iMouse.z < 0.5 )\n\t\tangle = iTime + 4.7;\n\tfloat ca = cos(angle);\n\tfloat sa = sin(angle);\n\tmat2  m = mat2(ca, -sa, sa, ca);\n\t\n\tfloat far, near;\n\tvec3 ro, rd;\n\n\t// cone\n\ttransformray(camro, camrd, m, vec3(0.0, 0.0, 0.0), ro, rd);\n\tif (cone (ro, rd, near, far))\n    {\n\t\t//fragColor += vec4(far - max(near, 0.0));\n        vec3 pos = ro + rd * near;\n        float result = 0.0;\n        float marchStep = (far - near) / float(ITER);\n        float tanInnerAngle = tan(25.0 / 180.0 * 3.1415926);\n        for(int i = 0; i < ITER; i++)\n        {\n            pos += rd * marchStep;\n            float h = pos.x;\n            float density = 1.0 - length(pos);\n            density *= density;\n            \n            float r = tanInnerAngle * h;\n            float r0 = length(vec2(pos.y, pos.z));\n            density *= clamp(1.0 - r0 / r, 0.0, 1.0);\n            \n            float theta = atan(pos.y, pos.z);\n            theta += iTime * 3.1415926 * 0.25;\n            theta /= 3.1415926 / 4.0;\n            theta = fract(theta);\n            float section = smoothstep(0.0, 0.05, theta) * smoothstep(0.8, 0.75,theta);\n            section = mix(0.3, 1.0, section);\n            section = mix(section, 1.0, smoothstep(0.33, 0.22, r0 / r));\n            \n            density *= section;\n            result += density * marchStep;\n        }\n        fragColor += vec4(mix(vec4(0.5, 0.65, 0.7, 0.0), vec4(0.0), exp(-result * 10.0)));\n    }\n}","name":"Image","description":"","type":"image"}]}