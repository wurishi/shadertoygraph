{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"// Inspired by iq raymarched toys\n// Created by Ramon Viladomat\n\n#define STEP_REDUCTION 0.5\n#define PI 3.1415\n#define EPSILON 0.002\n\nvec4 starTrans = vec4(0.0,0.0,0.0,1.0);\n\n/////////////////////////\n// DISTANCE PRIMITIVES //\n/////////////////////////\n\nfloat distSquaredCylinder( vec3 p, vec3 d, float r)\n{\n\treturn max(length(max((abs(p.xz)-d.xz),0.0))-r,abs(p.y)-d.y);\n}\n\nfloat distBox( vec3 p, vec3 b )\n{\n  \treturn length(max(abs(p)-b,0.0));\n}\n\n////////////////\n// MORPHOLOGY //\n////////////////\n\n\nvec2 distanceZ( in vec3 p )\n{\n\tvec3 q1 = vec3(p.xy,p.z + 0.2); \n\tq1.x *= sign(q1.y);\n\tq1.y = abs(q1.y) - 0.3;\n\tq1.x += 0.5*q1.y;\n\tq1.y /= (0.5*q1.x+1.0);\n\t\n\t// Commented code: Only one box, but the space is too distorted -> more artifacts\n\t//q1.y *= mix(1.0,0.2,max(-sign(q1.y),0.0)*max(-sign(q1.x),0.0)) / (0.5*q1.x+1.0);\n\t//float dist = udBox(q1,vec3(0.3,0.1,0.1)); \n\t\n\tfloat dist = min(distBox(q1,vec3(0.3,0.1,0.1)),distBox(q1 + vec3(0.15,0.2,0.0),vec3(0.15,0.3,0.1)));\n\t\n\treturn vec2(dist,2.0);\n}\n\nvec2 distanceStar( in vec3 p )\n{\n\tvec3 d = vec3(0.6,0.15,0.2);\n\tvec2 b = vec2(0.05,0.25); \n\t\n\tfloat angleFraction = PI*0.25;\n\tvec3 q = vec3(abs((mod(PI+atan(p.y,p.x),angleFraction)/angleFraction)-0.5)*2.0,length(p.xy),p.z);\n\tfloat currentRadius = d.x + pow(1.0 - q.x,1.5)*d.y;\n\t\n\tfloat distInner2D = q.y-(currentRadius-b.x);\n\tfloat dist = max(distInner2D,abs(q.z)-d.z);\n\tfloat distBorder = max(abs(q.y-currentRadius)-b.x,abs(q.z)-b.y);\n\t\n\treturn vec2(min(dist,distBorder),mix(0.0,1.0,max(sign(distInner2D+EPSILON),0.0)));\n}\n\nvec2 distanceMarker( in vec3 p ) \n{\n\tvec3 q = p - vec3(0.0,-1.0,0.2);\n\treturn vec2(distSquaredCylinder( q, vec3(0.5,0.005,0.75),0.1 ),3.0);\n}\n\nvec3 map( in vec3 p )\n{\n\tvec3 q = p;\n\tq.xz = -q.xz;\n\tq*=starTrans.w;\n\tq-=starTrans.xyz;\n\t\n\tvec2 distStar = distanceStar(q);\n\tvec2 distZ = distanceZ(q);\n\tvec2 distMarker = distanceMarker(p);\n\t\n\tvec2 res = distStar.xy;\n\tif (distZ.x < res.x) res = distZ;\n\tif (distMarker.x < res.x) res = distMarker;\n\t\n\treturn vec3(res,distZ.x); // we need the distance to the Z in order to compute glow \n}\n\n///////////////\n// MATERIALS //\n///////////////\n\nvec4 calcMarkerColor(in vec3 pos)\n{\n\t//Render code \n\tvec2 codePos = pos.xz - vec2(-0.45,-0.5);\n\t\n\tvec2 segment = floor(codePos*5.555);\n\tvec2 inSquare = min(sign(abs(min(segment-5.0,0.0))),sign(max(segment+1.0,0.0)));\n\tfloat blackFactor = min(inSquare.x,inSquare.y);\n\t\n\tvec2 mirrorSeg = vec2(min(segment.x,segment.y),max(segment.x,segment.y));\n\t\t\n\tif (mirrorSeg == vec2(1,3) || mirrorSeg == vec2(2,3) || segment == vec2(1,2))\n\t{\n\t\tblackFactor = 0.0;\n\t}\n\t\n\t//Render Numbers\n\t\n\t//ZERO\n\tvec2 zeroPos = vec2(pos.x + 0.08,max(abs(pos.z - 0.7) - 0.05,0.0));\n\tfloat zeroBlack = 1.0 - clamp(sign(abs(0.05 - length(zeroPos))-0.02),0.0,1.0);\n\t\n\t//ONE\n\tvec2 onePos = pos.xz - vec2(0.08,0.7);\n\tvec2 oneBlack = clamp(sign(abs(onePos)-vec2(0.02,0.12)),0.0,1.0); \n\tfloat numberBlack = max(zeroBlack,1.0 - max(oneBlack.x,oneBlack.y));\n\t\n\treturn mix(vec4(0.2),vec4(0.0),max(numberBlack,blackFactor));\n}\n\nvec4 calcColor( in vec3 pos, in vec3 nor, float material )\n{\n\tvec4 materialColor = vec4(0.0);\n\t\n\t\t if(material < 0.5) materialColor = vec4(0.7,0.7,0.0,0.05);\n\telse if(material < 1.5) materialColor = vec4(0.0,0.0,0.0,0.05);\n\telse if(material < 2.5) materialColor = vec4(0.2,0.0,0.0,0.05);\n\telse if(material < 3.5) materialColor = calcMarkerColor(pos);\n\t\t\n\treturn materialColor;\n}\n\n//////////////////////\n// MAIN RAY/SHADING //\n//////////////////////\n\nvec3 intersect( in vec3 ro, in vec3 rd )\n{\n\tvec3 res = vec3( 2.0*EPSILON, -1.0, 9999.0);\n    float t = 0.0;\n    for( int i=0; i<150; i++ )\n    {\n\t\tif( abs(res.x)<EPSILON ) continue;\n\t\tvec3 aux = map( ro+rd*t );\n\t\tres.xy = aux.xy;\n\t\tres.z = min(res.z,aux.z);\n        t += res.x*STEP_REDUCTION;\n    }\n\tif( abs(res.x)>EPSILON ) res.y = -1.0;\n\tres.x = t;\n    return res;\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n    vec3 eps = vec3(EPSILON,0.0,0.0);\n\treturn normalize( vec3( map(pos+eps.xyy).x - map(pos-eps.xyy).x, map(pos+eps.yxy).x - map(pos-eps.yxy).x, map(pos+eps.yyx).x - map(pos-eps.yyx).x ) );\n}\n\nfloat softShadow( in vec3 ro, in vec3 rd, float mint, float k )\n{\n    float res = 1.0;\n    float t = mint;\n    for( int i=0; i<45; i++ )\n    {\n        float h = map(ro + rd*t).x;\n        res = min( res, k*h/t );\n        t += h*STEP_REDUCTION;\n    }\n    return clamp(res,0.0,1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = -1.0 + 2.0 * fragCoord.xy / iResolution.xy;\n    p.x *= iResolution.x/iResolution.y;\n\t\n\t// Compute Camera\n\tvec2 mousePos = iMouse.xy/iResolution.xy;\n\t\n\t//move camera when clicking\n\tfloat animatedCamAngle = sin(iTime*0.2);\n\tfloat inputCamAngle = PI+2.0*PI*mousePos.x;\n\t\n\tfloat camAngle = mix(animatedCamAngle,inputCamAngle,clamp(iMouse.z,0.0,1.0));\n\tfloat camDist = 1.0+((1.0-mousePos.y)*2.0); \n\t\n    vec3 camPosition = camDist*normalize(vec3(sin(camAngle), 0.25, cos(camAngle)));\n    vec3 camTarget\t = vec3( 0.0, -0.25, 0.0 );\n    vec3 camFront \t = normalize( camTarget - camPosition );\n    vec3 camRight \t = normalize( cross(camFront,vec3(0.0,1.0,0.0) ) );\n    vec3 camUp \t\t = normalize( cross(camRight,camFront));\n    vec3 rayDir \t = normalize( p.x*camRight + p.y*camUp + 2.0*camFront );\n\n\t// light compute (fake fire light)\n\tvec3 lightPos1 = vec3(2.5,2.5,2.0);\n\tvec3 lightColor1 = vec3(1.0,0.7,0.3);\n\t\n\t// compute Star\n\tstarTrans.w = mix(1.15,1.1,sin(iTime*1.3)); \n\tstarTrans.y = cos(iTime)*0.1; \n\t\n\t// Start Ray\n    vec3 finalcolor = vec3(0.0);\n\tfloat attenuation = 1.0;\n\tfor( int reflectCount=0; reflectCount<2; reflectCount++ )\n\t{\n\t\t// Compute color for single ray\n    \tvec3 tmat = intersect(camPosition,rayDir);\n\n\t\t//glow ( use the ray min distance in order to compute real material emision )\n\t\tfinalcolor += attenuation*pow(max(1.0 - length(tmat.z),0.0),20.0)*vec3(0.7,0.0,0.0);\n\t\t\n\t\tif (tmat.y > -0.5)\n\t\t{\n\t\t\t// results extraction\n\t\t\tvec3 position \t= camPosition + tmat.x*rayDir;\n\t\t\tvec3 normal \t= normalize(calcNormal(position));\n\t\t\tvec3 reflDir \t= reflect(rayDir,normal);\n\t\t\t\n\t\t\t// lights and materials \n\t\t\tvec4 materialColor \t= calcColor( position, normal, tmat.y );\n\t\t\t\n\t\t\tfloat ambient  \t\t= 0.7 + 0.3*normal.y;\n\t\t\tvec3 ambientColor \t= ambient*materialColor.rgb;\n\t\t\t\n\t\t\t//light 1\n\t\t\tvec3 lightDir1 \t= normalize(lightPos1 - position);\n\t\t\t\n\t\t\tfloat diffuse1  = max(dot(normal,lightDir1),0.0);\n\t\t\tfloat specular1 = pow(clamp(dot(lightDir1,reflDir),0.0,1.0),3.0);\n\t\t\tfloat shadow1   = softShadow( position, lightDir1, 0.01, 10.0 );\n\t\t\t\n\t\t\tvec3 diffuseColor1 = diffuse1*lightColor1*materialColor.rgb;\n\t\t\tvec3 specularColor1 = specular1*materialColor.w*lightColor1;\n\t\t\tvec3 ilumColor1 = shadow1*(diffuseColor1 + specularColor1);\n\t\t\t\n\t\t\t// mixing lights\n\t\t\tfinalcolor += attenuation*mix(ambientColor,ilumColor1,0.8);\n\t\t\t\n\t\t\t// prepare next ray for reflections \n\t\t\trayDir = reflDir;\n\t\t\tattenuation *= 2.0*materialColor.w;\n\t\t\tcamPosition = position + EPSILON*normal;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tfinalcolor += attenuation*vec3(0.0,0.0,0.2);\n\t\t\tattenuation = 0.0;\n\t\t}\n\t\t\t\n\t}\n\t\n\t// desaturation, gamma correction and simple vignette\n\tfinalcolor = pow(mix( finalcolor, vec3(dot(finalcolor,vec3(0.33))), 0.3 ), vec3(0.45));\n\tfinalcolor *= mix(1.0,0.6,length(p)*0.5);\n\t\n    fragColor = vec4( finalcolor,1.0 );\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"ld2Gzy","date":"1390409244","viewed":1276,"name":"Invizimals Logo","username":"Ramocles","description":"Ray marched the invizimals logo and psvita playcard from the Sony's Augmented Reality games. Test for glow effect almost for free using distancefields.\nMouse controls rotation (X) and zoom (Y).","likes":11,"published":1,"flags":0,"usePreview":0,"tags":["procedural","3d","raymarching","distancefield","logo","glow","ar","invizimals","card"],"hasliked":0,"parentid":"","parentname":""}}