{"ver":"0.1","info":{"id":"ttGyRW","date":"1610551996","viewed":358,"name":"UInt Texture Test","username":"mla","description":"Test for writing & reading uint values to & from texture - red channel shows values being passed incorrectly, green channel shows NaNs being transmitted, blue channel shows subnormal numbers.\n\nMouse button down to use \"texture()\" instead of \"texelFetch()\"","likes":1,"published":3,"flags":48,"usePreview":0,"tags":["test","texture","uint"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Test for round tripping uints through conversion to floats, texture write,\n// texture read, and conversion back to uints.\n// Key 'x' fixes data as at frame 0, use to see if data preserved over window\n// resize (it isn't - NaNs and denormals get corrupted).\n\nbool denormal(uint n) {\n  if (n == 0u) return false;\n  return ((n>>23)&0xffU) == 0U;\n}\n\nbool denormal(uvec4 p) {\n  return denormal(p.x) || denormal(p.y) || denormal(p.z) || denormal(p.w);\n}\n\n// isnan() doesn't work on some platforms, D3D11 it seems\n// This will return true for Inf values too.\nbool nan(uint n) {\n  return ((n>>23)&0xffU) == 0xffU;\n}\n\nbool nan(uvec4 p) {\n  return nan(p.x) || nan(p.y) || nan(p.z) || nan(p.w);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    int frame = key(CHAR_X) ? 0 : iFrame;\n    \n    uvec4 outval = mkoutval(frame,fragCoord);\n    vec4 incol = texelFetch(iChannel0,ivec2(fragCoord),0);\n    if (iMouse.z > 0.0) incol = texture(iChannel0,fragCoord/iResolution.xy);\n\n    uvec4 inval = floatBitsToUint(incol);\n    fragColor = vec4(outval != inval,nan(inval),denormal(inval),1);\n    //if (iMouse.z > 0.0 && inval>>16 == uvec4(0)) fragColor = vec4(1);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void mainImage(out vec4 fragColor, vec2 fragCoord){\n    if (key(CHAR_X) && iFrame != 0) {\n      fragColor = texelFetch(iChannel0,ivec2(fragCoord),0);\n    } else {\n      uvec4 outval = mkoutval(iFrame,fragCoord);\n      fragColor = uintBitsToFloat(outval);\n    }\n    //if (any(isnan(fragColor))) fragColor = vec4(0);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"uint ihash(uint x) {\n    x ^= x >> 16;\n    x *= 0x7feb352dU;\n    x ^= x >> 15;\n    x *= 0x846ca68bU;\n    x ^= x >> 16;\n    return x;\n}\n\nuvec4 mkoutval(int frame, vec2 fragcoord) {\n    uvec4 outval;\n    for (uint i = 0U; i < 4U; i++) {\n      outval[i] = ihash(uint(frame<<2) ^ i ^ ihash(uint(fragcoord.x)^ihash(uint(fragcoord.y))));\n    }\n    return outval;\n}\n\nconst int CHAR_X = 88;\n// const int CHAR_Y = 89;\n// const int CHAR_Z = 90;\n\n#define key(code) (texelFetch(iChannel3, ivec2((code),2),0).x != 0.0)","name":"Common","description":"","type":"common"}]}