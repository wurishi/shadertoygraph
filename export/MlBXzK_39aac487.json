{"ver":"0.1","info":{"id":"MlBXzK","date":"1444925478","viewed":314,"name":"less noob-raymarching","username":"MacSlow","description":"By now the raymarching is a bit more sophisticated (compared my first attempt) as it implements over-relaxed sphere-tracing as described by Keinert et al 2014. The artifacts on the twisting box suck, but that's expected when messing with space like that.","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"////////////////////////////////////////////////////////////////////////////////\n//\n// Basic raymarching-renderer\n//\n// Copyright 2015 Mirco MÃ¼ller\n//\n// Author(s):\n//   Mirco \"MacSlow\" MÃ¼ller <macslow@gmail.com>\n//\n// This program is free software: you can redistribute it and/or modify it\n// under the terms of the GNU General Public License version 3, as published\n// by the Free Software Foundation.\n//\n// This program is distributed in the hope that it will be useful, but\n// WITHOUT ANY WARRANTY; without even the implied warranties of\n// MERCHANTABILITY, SATISFACTORY QUALITY, or FITNESS FOR A PARTICULAR\n// PURPOSE.  See the GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License along\n// with this program.  If not, see <http://www.gnu.org/licenses/>.\n//\n////////////////////////////////////////////////////////////////////////////////\n\nconst float PI = 3.14159265358979323846;\nconst vec4 red   = vec4 (1., .0, .0, 1.);\nconst vec4 green = vec4 (.0, 1., .0, 1.);\nconst vec4 blue  = vec4 (.0, .0, 1., 1.);\nconst vec4 white = vec4 (1.);\nconst vec4 black = vec4 (.0, .0, .0, 1.);\nconst vec4 orange = vec4 (1., .5, .25, 1.);\nconst int MAX_STEPS = 128;\nconst float epsilon = 0.0001;\n\nvec4 gradient (float v) {\n    float steps = 3.;\n    float step = 1. / steps;\n    vec4 col = black;\n\n    if (v >= 0.0 && v < step) {\n        col = mix (white, blue, v * steps);\n    } else if (v >= step && v < 2.0 * step) {\n        col = mix (blue, red, (v - step) * steps);\n    }\n\n    return col;\n}\n\nfloat opUnion (float d1, float d2)\n{\n    return max (d1, d2);\n}\n\nfloat smin (float a, float b, float k)\n{\n    float h = clamp (.5 + .5 * (b - a) / k, .0, 1.);\n    return mix (b, a, h) - k * h * (1. - h);\n}\n\nmat4 trans (vec3 t)\n{\n    mat4 mat = mat4 (vec4 (1., .0, .0, .0),\n                     vec4 (.0, 1., .0, .0),\n                     vec4 (.0, .0, 1., .0),\n                     vec4 (t.x, t.y, t.z, 1.));\n    return mat;\n}\n\nvec3 opTransf (vec3 p, mat4 m)\n{\n    return vec4 (m * vec4 (p, 1.)).xyz;\n}\n\nvec3 opTwistX (vec3 p, float angle)\n{\n    float rad = radians (angle * p.x);\n    float c = cos (rad);\n    float s = sin (rad);\n\n    mat3 mat = mat3 (vec3 (1.0, 0.0, 0.0),\n                     vec3 (0.0,   c,   s),\n                     vec3 (0.0,  -s,   c));\n\n    return p * mat;\n}\n\nvec3 opTwistY (vec3 p, float angle)\n{\n    float rad = radians (angle * p.y);\n    float c = cos (rad);\n    float s = sin (rad);\n\n    mat3 mat = mat3 (vec3 (  c, 0.0,  -s),\n                     vec3 (0.0, 1.0, 0.0),\n                     vec3 (  s, 0.0,   c));\n\n    return p * mat;\n}\n\nvec3 opTwistZ (vec3 p, float angle)\n{\n    float rad = radians (angle * p.z);\n    float c = cos (rad);\n    float s = sin (rad);\n\n    mat3 mat = mat3 (vec3 (  c,   s, 0.0),\n                     vec3 ( -s,   c, 0.0),\n                     vec3 (0.0, 0.0, 1.0));\n\n    return p * mat;\n}\n\nmat4 rotX (in float angle)\n{\n    float rad = radians (angle);\n    float c = cos (rad);\n    float s = sin (rad);\n\n    mat4 mat = mat4 (vec4 (1.0, 0.0, 0.0, 0.0),\n                     vec4 (0.0,   c,   s, 0.0),\n                     vec4 (0.0,  -s,   c, 0.0),\n                     vec4 (0.0, 0.0, 0.0, 1.0));\n\n    return mat;\n}\n\nmat4 rotY (in float angle)\n{\n    float rad = radians (angle);\n    float c = cos (rad);\n    float s = sin (rad);\n\n    mat4 mat = mat4 (vec4 (  c, 0.0,  -s, 0.0),\n                     vec4 (0.0, 1.0, 0.0, 0.0),\n                     vec4 (  s, 0.0,   c, 0.0),\n                     vec4 (0.0, 0.0, 0.0, 1.0));\n\n    return mat;\n}\n\nmat4 rotZ (in float angle)\n{\n    float rad = radians (angle);\n    float c = cos (rad);\n    float s = sin (rad);\n\n    mat4 mat = mat4 (vec4 (  c,   s, 0.0, 0.0),\n                     vec4 ( -s,   c, 0.0, 0.0),\n                     vec4 (0.0, 0.0, 1.0, 0.0),\n                     vec4 (0.0, 0.0, 0.0, 1.0));\n\n    return mat;\n}\n\nfloat hash (float f)\n{\n    return fract (sin (f) * 45734.5453);\n}\n\nfloat noise3d (vec3 p)\n{\n    vec3 u = floor (p);\n    vec3 v = fract (p);\n    \n    v = v * v * (3. - 2. * v);\n\n    float n = u.x + u.y * 57. + u.z * 113.;\n    float a = hash (n);\n    float b = hash (n + 1.);\n    float c = hash (n + 57.);\n    float d = hash (n + 58.);\n\n    float e = hash (n + 113.);\n    float f = hash (n + 114.);\n    float g = hash (n + 170.);\n    float h = hash (n + 171.);\n\n    float result = mix (mix (mix (a, b, v.x),\n                             mix (c, d, v.x),\n                             v.y),\n                        mix (mix (e, f, v.x),\n                             mix (g, h, v.x),\n                             v.y),\n                        v.z);\n\n    return result;\n}\n\n// fractal brownian motion with four different octaves\n// rotating input point p to make it a less dull\nfloat fbm (vec3 p)\n{\n    mat3 m1 = mat3 (rotZ (23.4));\n    mat3 m2 = mat3 (rotZ (45.5));\n    mat3 m3 = mat3 (rotZ (77.8));\n\n    float result = .0;\n    result = 0.5 * noise3d (p);\n    p *= m1 * 2.02;\n    result += 0.25 * noise3d (p);\n    p *= m2 * 2.03;\n    result += 0.125 * noise3d (p);\n    p *= m3 * 2.04;\n    result += 0.0625 * noise3d (p);\n    result /= 0.9375;\n\n    return result;\n}\n\nvec3 opRepeatX (vec3 p, float v)\n{\n    return vec3 (mod (p.x, v), p.y, p.z);\n}\n\nvec3 opRepeatY (vec3 p, float v)\n{\n    return vec3 (p.x, mod (p.y, v), p.z);\n}\n\nvec3 opRepeatZ (vec3 p, float v)\n{\n    return vec3 (p.x, p.y, mod (p.z, v));\n}\n\nfloat opSubtract (float d1, float d2)\n{\n    return max (-d1, d2);\n}\n\nfloat opIntersect (float d1, float d2)\n{\n    return max (d1, d2);\n}\n\nfloat opBlend (float d1, float d2, float k)\n{\n    return smin (d1, d2, k);\n}\n\nfloat sphere (vec3 p, float r)\n{\n    return length (p) - r;\n}\n\nfloat box (vec3 p, vec3 b, float r)\n{\n    return length (max (abs (p) - b + vec3 (r), .0)) - r;\n}\n\nfloat cylinder (vec3 p, vec3 n)\n{\n    return length (p.xz - n.xy) - n.z;\n}\n\nfloat func (vec3 p)\n{\n    return -.4 * sin (p.x * 2.) * cos (p.z * 3.) * sin (p.y * .05);\n}\n\nfloat plane (vec3 p, vec4 n)\n{\n    return dot ((p).xyz, n.xyz) + n.w;\n}\n\nvec3 materialOne (vec3 p)\n{\n    vec3 color;\n\n    color.r = fbm (2.1 * p);\n    color.g = fbm (3.2 * p);\n    color.b = fbm (4.3 * p);\n\n    return color;\n}\n\nvec3 materialTwo (vec3 p)\n{\n    vec3 color;\n\n    color.r = fbm (1.2 * p);\n    color.g = fbm (1.3 * p);\n    color.b = fbm (1.4 * p);\n\n    return color;\n}\n\nfloat map (vec3 p)\n{\n    float d = .0;\n    float d1 = .0;\n    float d2 = .0;\n    float d3 = .0;\n    float d4 = .0;\n    float d5 = .0;\n    float t = iTime;\n\n    // twisting box with sphere cutout\n    mat4 m = trans (vec3 (-2., 1., 3.));\n    d = opSubtract (sphere (opTransf (p, m), 1.),\n                    box (opTwistY (opTransf (p, m),\n                                   sin (t) * 20.),\n                         vec3 (.6, 2., .6), .1));\n\n    d2 = plane (p, normalize (vec4 (.0, -1., .0, 1.)));\n    d = min (d, d2);\n\n    // dice-like things\n    m = rotY (50. * t) * trans (vec3 (-3.6, .5, .5 + 1.5 * sin (t)));\n    mat4 m1 = trans (vec3 (-3., -.45, .0));\n    d3 = opBlend (opIntersect (box (opTransf (p, m), vec3 (.55), .1),\n                               sphere (opTransf (p, m), .7)),\n                  opIntersect (box (opTransf (p, m1), vec3 (.55), .1),\n                               sphere (opTransf (p, m1), .7)),\n                  .6);\n    d = min (d, d3);\n\n    // T1000-ish ball-box magic\n    m = trans (vec3 (1.05, -.3, 2.2 + sin (t)));\n    m1 = trans (vec3 (-.05, .5, 1.5));\n    d2 = opBlend (box (opTransf (p, m), vec3 (.7), .1),\n                  sphere (opTransf (p, m1), .7),\n                  .5 + .25 * cos (iTime));\n    d = min (d, d2);\n\n    // dice with holes\n    m = trans (vec3 (-1.25, -.4, -1.25));\n    m1 = rotX (90.) * trans (vec3 (-.9, .1, 1.5));\n    mat4 m2 = trans (vec3 (-.9, -1., -.75));\n    d2 = opIntersect (box (opTransf (p, m), vec3 (.55), .0),\n                      sphere (opTransf (p, m), .7));\n    d3 = opSubtract (cylinder (opTransf (p, m1), vec3 (.35, .5, .35)),\n                     d2);\n    d2 = opSubtract (cylinder (opTransf (p, m2), vec3 (.35, .5, .35)),\n                     d3);\n    m1 = rotZ (90.) * trans (vec3 (.0, -.75, -.75));\n    d3 = opSubtract (cylinder (opTransf (p, m1), vec3 (.35, .5, .35)), d2);\n    d = min (d, d3);\n\n    return d;\n}\n\n// \"borrowed\" from iq... have a slightly better understanding of this now\nvec3 objectNormal (vec3 p)\n{\n    vec2 e = vec2 (.0001, .0);\n    float d = map (p);\n\n    vec3 n = vec3 (map (p + e.xyy) - d,\n                   map (p + e.yxy) - d,\n                   map (p + e.yyx) - d);\n\n    return normalize (n);\n}\n\nfloat march (in vec3 ro, in vec3 rd, in float pixelSize, out int iter)\n{\n    bool forceHit = true;\n    float infinity = 10000000.0;\n    float t_min = .0000001;\n    float t_max = 1000.0;\n    float t = t_min;\n    float candidate = t_min;\n    float candidate_error = infinity;\n    float w = 1.2;\n    float lastd = .0;\n    float stepSize = .0;\n    float sign = map (ro) < .0 ? -1. : 1.;\n\n    for (int i = 0; i < MAX_STEPS; i++)\n    {\n        iter++;\n        float signedd = sign * map (ro + rd * t);\n        float d = abs (signedd);\n        bool fail = w > 1. && (d + lastd) < stepSize;\n\n        if (fail) {\n            stepSize -= w * stepSize;\n            w = 1.;\n        } else {\n            stepSize = signedd * w;\n        }\n\n        lastd = d;\n\n        float error = d / t;\n        if (!fail && error < candidate_error) {\n            candidate_error = error;\n            candidate = t;\n        }\n\n        if (!fail && error < pixelSize || t > t_max) {\n            break;\n        }\n\n        t += stepSize;\n \n    }\n\n    if ((t > t_max || candidate_error > pixelSize) && !forceHit) {\n        return infinity;\n    }\n\n    return candidate;\n}\n\nfloat softShadow (vec3 ro, vec3 rd, float tmin, float k)\n{\n    float s = 1.;\n    float d = .0;\n    float t = tmin;\n    for (int i = 0; i < 64; i++) {\n        d = map (ro + rd * t);\n        if (d < epsilon) {\n            return .0;\n        }\n        s = min (s, k * d / t);\n        t += d;\n    }\n    return s;\n}\n\nfloat hardShadow (in vec3 ro, in vec3 rd)\n{\n    float t = .02;\n    for (int i = 0; i < 64; i++) {\n        float d = map (ro + rd * t);\n        if (d < epsilon) {\n            return .1;\n        }\n        t += d;\n    }\n\n    return 1.;\n}\n\nvec3 shade (in vec3 p)\n{\n    // animate the light-sources a bit\n    float t = 1.5 * iTime;\n    vec3 lPos0 = vec3 (1.5 * cos (t), -2., 1.5 * sin (t));\n    vec3 lPos1 = vec3 (4. * cos (-t * .2), -4., 4. * sin (-t));\n\n    vec3 lCol0 = vec3 (.95, .95, .75) * 4.75;\n    vec3 lCol1 = vec3 (.5, .5, .75) * 6.5;\n    vec3 normal = objectNormal (p);\n    vec3 lDir0 = normalize (lPos0 - p);\n    vec3 lDir1 = normalize (lPos1 - p);\n    vec3 lInt0 = lCol0 * max (dot (normal, lDir0), .0);\n    vec3 lInt1 = lCol1 * max (dot (normal, lDir1), .0);\n    vec3 col = softShadow (p, normalize (lPos0 - p), 0.001, 64.) * .7 * lInt0;\n    col += softShadow (p, normalize (lPos1 - p), 0.001, 64.) * .8 * lInt1;\n    //vec3 col = hardShadow (p, normalize (lPos0 - p)) * .7 * lInt0;\n    //col += hardShadow (p, normalize (lPos1 - p)) * .8 * lInt1;\n\n    return col;\n}\n\nmat3 camera (in vec3 eye, in vec3 aim, in float r)\n{\n    vec3 cw = normalize (aim - eye);\n    vec3 cp = vec3 (sin (r), cos (r), .0);\n    vec3 cu = normalize (cross (cw, cp));\n    vec3 cv = normalize (cross (cu, cw));\n    return mat3 (cu, cv, cw);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n    float tm = iTime;\n    vec2 mouse = iMouse.xy / iResolution.xy;\n    vec3 eye = vec3 (cos (2. * mouse.x) * 9.,\n                     -6. + 4. * mouse.y,\n                     sin (2. * mouse.x) * 9.);\n    vec3 aim = vec3 (.0, .0, .0);\n    mat3 cam = camera (eye, aim, .0);\n    float u = -.5 + fragCoord.x / iResolution.y;\n    float v = -.5 + fragCoord.y / iResolution.y;\n    vec2 uvRaw = fragCoord.xy / iResolution.xy;\n\n    vec3 ro = eye;\n    vec3 rd = cam * normalize (vec3 (u, -v, 1.8));\n    vec3 bg = vec3 (.125, .125, .05);\n    float pixelSize = 1. / iResolution.x;\n    int iter = 0;\n    float t = march (ro, rd, pixelSize, iter);\n    vec3 p = ro + rd * t;\n    float fog = 1. / pow (1. + t * t * .1, .25);\n    vec3 color = mix (shade (p) * materialTwo (p), bg, length (rd * t) / 30.);\n    color *= fog;\n    \n    color = color / (1. + color);\n    color = pow (color, vec3 (1./2.2));\n    color *= vec3 (.95, .9, .85);\n    color *= .2 + .8 * pow (16. * uvRaw.x * uvRaw.y * (1. - uvRaw.x) * (1. - uvRaw.y), .3);\n\n    fragColor = vec4 (color, 1.);\n}","name":"Image","description":"","type":"image"}]}