{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"#define PI\t\t\t\t\t3.14159265359\n#define PIH \t\t\t\t(PI/2.0)\n#define PIQ \t\t\t\t(PI/4.0)\n#define PI2 \t\t\t\t(PI*2.0)\n#define MARCH_SCALE\t\t\t0.95\n#define MARCH_STEPS\t\t\t48\n#define PRECISION\t\t\t0.001\n\n#define LIGHT_POS\t\t\tvec3(0.0, 0.0, -5.0)\n#define COLOR_1\t\t\t\tvec3(-2.5, 2.5, 4.0)\n#define COLOR_2\t\t\t\tvec3(4.0, 1.5, -1.0)\n\n// Used inside the scene function, requires you to declare float depthCurr = 1000.0; float depthPrev = 1000.0; and float matID = -1.0;\n#define OBJ(inOBJ, inMatID) depthPrev=depthCurr; depthCurr=min(depthCurr, inOBJ); if(depthCurr < depthPrev) matID = inMatID;\n\nvec3 GetRayDir(vec2 inTC, vec2 inAspectRatio)\t{return normalize(vec3((-0.5 + inTC)*1.2 * inAspectRatio, 1.0));}\nmat3 RotX(float a)\t\t\t\t\t\t\t\t{float s = sin(a); float c = cos(a); return mat3(1,0,0,0,c,s,0,-s,c);}\nmat3 RotY(float a)\t\t\t\t\t\t\t\t{float s = sin(a); float c = cos(a); return mat3(c,0,-s,0,1,0,s,0,c);}\nmat3 RotZ(float a)\t\t\t\t\t\t\t\t{float s = sin(a); float c = cos(a); return mat3(c,s,0,-s,c,0,0,0,1);}\n\n// Global variables\nvec2 CrossObj(vec3 p)\n{\n\tfloat depthCurr\t= 1000.0;\n\tfloat depthPrev\t= 1000.0;\n\tfloat matID\t\t= -1.0;\n\t\n\tconst float cylinderHeight\t= 1.0;\n\tconst float cylinderRadius\t= 0.005;\n\t\n\t\n\tvec3 crossp\t\t\t\t\t= cross(vec3(1, 0, 0), vec3(sin(iTime),0,cos(iTime)));\n\tfloat crossHeight\t\t\t= crossp.y;\n\t\n\tOBJ(max(length(p.zy)-cylinderRadius, abs(p.x-cylinderHeight*0.5)-cylinderHeight*0.5), 0.0); // X - Axis\n\t\n\tOBJ(max(length(p.xz)-cylinderRadius, abs(p.y-crossHeight*0.5)-abs(crossHeight)*0.5), 1.0);\t// Y - Axis\n\t\n\t// We rotate only the Z axis vector\n\tp = RotY(iTime) * p;\n\tOBJ(max(length(p.xy)-cylinderRadius, abs(p.z-cylinderHeight*0.5)-cylinderHeight*0.5), 2.0); // Z - Axis\n\t\n\tOBJ(length(p)-0.05, 3.0); // Z - Axis\n\t\n\treturn vec2(depthCurr, matID);\n}\n\n\nvec3 GetColor(float id)\n{\n\t// Background color\n\tvec3 color = vec3(0,0,0);\n\t\n\t// Material Colors\n\tif(id == 0.0)color=vec3(1.0, 0.0, 0.0); // Red\n\tif(id == 1.0)color=vec3(0.0, 1.0, 0.0); // Green\n\tif(id == 2.0)color=vec3(0.0, 0.0, 1.0); // Blue\n\tif(id == 3.0)color=vec3(0.4, 0.4, 0.4); // Grey\n\t\n\treturn color;\n}\n\n\nvec2 Intersect(vec3 ro, vec3 rd)\n{\t\t\n\tvec2 r\t\t= vec2(1000.0, -1.0);\n\tfloat z\t\t= 1.1;\n\tfloat matID\t= -1.0;\n\t\n\tfor(int i=0; i<MARCH_STEPS; i++)\n\t{\n\t\tr = CrossObj(ro + rd*z);\n\t\tif(r.x < PRECISION)\n\t\t\tcontinue;\n\t\tz\t\t+=r.x*MARCH_SCALE;\n\t\tmatID\t= r.y;\n\t}\n\t\n\tif(z > 3.1)\n\t\tz = 0.0;\n\t\n\treturn vec2(z, matID);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv\t\t= fragCoord.xy / iResolution.xy;\n\t\n\t// Construct simple ray\n\tmat3 xrot\t= RotX(0.5);\n\tvec2 aspect\t= vec2(iResolution.x/iResolution.y, 1.0);\n\tvec3 ro\t\t= xrot * vec3(0, 0.0, -2);\n\tvec3 rd\t\t= xrot * GetRayDir(uv, aspect);\n\t\n\t// Draw background color\n\tvec3 c1\t\t= mix(COLOR_2, COLOR_1, pow(uv.x, 2.0));\n\tvec3 c2\t\t= mix(COLOR_2, COLOR_1, pow(uv.y, 2.0));\n\tvec3 color\t= mix(c1, c2, 0.5) * 0.1;\n\n\tvec2 res\t= Intersect(ro, rd);\n\tvec3 p;\n\tvec3 n;\n\tif(res.x > 0.0)\n\t\tcolor = GetColor(res.y);\n\n\tfragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"ld2GWc","date":"1394682385","viewed":333,"name":"Cross/Vector Product","username":"Vlad86","description":"Before I apply cross-product anywhere, I always visualize it in my head... however, sometimes I confuse when its UP or when its DOWN.. so I've made this little shader to show it's behavior. Axis: [Left -X+ Right] [Down -Y+ Up] [Back -Z+ Forward]","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["crossvectorproduct"],"hasliked":0,"parentid":"","parentname":""}}