{"ver":"0.1","info":{"id":"3sGSz3","date":"1574675539","viewed":122,"name":"The Crowd","username":"PretzelPiece","description":"First try 3D\nStill very buggy at startup:\nLook around with the mouse - steer with WASD - up down with XZ - +-5% speed with PGUP, PGDOWN - back to 100% speed with HOME. \nCopied:\nhttps://www.shadertoy.com/view/XlyfRd\nhttps://www.shadertoy.com/view/MdfGRr","likes":2,"published":1,"flags":112,"usePreview":0,"tags":["raymarch","pattern"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy/iResolution.xy;\n//    if (iResolution.y > 1000.) {\n//    \tuv = floor(fragCoord.xy*0.5)/(iResolution.xy*0.5);   \n//    }\n    \n\tfragColor = texture(iChannel0, uv);\n    //fragColor = vec4(vec3(fragColor.a/2.), fragColor.a);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"float VIEWPOINT = 0.5;\nfloat LOOKAT = 1.5;\nfloat LOOKDIR = 2.5;\nfloat RIGHT = 3.5;\nfloat UP = 4.5;\nfloat LAST_MOUSE = 5.5;\nfloat PIVOT = 6.5;\nfloat SPEED = 7.5;\nfloat _MAX_INDEX = 7.5;\n\nfloat org_speed = 0.01;\n\nbool persisting_coord(vec2 fragCoord) {\n    if(fragCoord.x <= _MAX_INDEX && fragCoord.y == 0.5)\n        return true;\n    return false;\n}\n\nvec3 get_vec_val(float index) {\n\tvec2 uv = vec2(index / iResolution.x, 0.5/iResolution.y);\n    return texture(iChannel0, uv).xyz;\n}\n\nbool set_vec_val(float index, vec2 fragCoord, vec3 val, out vec4 col) {\n    if(fragCoord == vec2(index, 0.5)) {\n        col = vec4(val, 1.0);\n    \treturn true;\n    } \n    return false;\n}\n\nfloat KEY_W = 87.0;\nfloat KEY_A = 65.0;\nfloat KEY_S = 83.0;\nfloat KEY_D = 68.0;\nfloat KEY_Q = 81.0;\nfloat KEY_E = 69.0;\nfloat KEY_X = 88.0;\nfloat KEY_Z = 90.0;\nfloat KEY_PGUP = 33.0;\nfloat KEY_PGDOWN = 34.0;\nfloat KEY_HOME = 36.0;\n\n// for DE keyboard\n#if 0\nKEY_Z = 89.0;\n#endif\n\n\nbool is_pressed(float keyCode) {\n    keyCode = (keyCode + 0.5) / 256.0;\n    vec2 uv = vec2(keyCode, 0.25);\n    float key = texture(iChannel1, uv).r;\n\n    return key > 0.0;\n}\n\nmat4 rotate(vec3 axis, float phi) {\n\tvec3 x = normalize(axis);\n    float c = cos(phi);\n    float s = sin(phi);\n    float omc = 1.-c;\n    //mat4 trans_inv = mat4(1.,0.,0.,0.,0.,1.,0.,0.,0.,0.,1.,0.,-vp.x,-vp.y,-vp.z,1.);\n    //mat4 trans = mat4(1.,0.,0.,0.,0.,1.,0.,0.,0.,0.,1.,0.,vp.x,vp.y,vp.z,1.);\n    mat4 rot = mat4 (\n    \tc+x.x*x.x*omc,      x.x*x.y*omc-x.z*s,  x.x*x.z*omc+x.y*s,  0.,\n        x.y*x.x*omc+x.z*s,  c+x.y*x.y*omc,      x.y*x.z*omc-x.x*s,  0.,\n        x.z*x.x*omc-x.y*s,  x.z*x.y*omc+x.x*s,  c+x.z*x.z*omc,      0.,\n        0.,                 0.,                 0.,                 1.\n    );\n    //return trans_inv*rot*trans;\n    return rot;\n}\n\nmat4 translate(vec3 displacement) {\n    return mat4(1., 0., 0., displacement.x,\n                0., 1., 0., displacement.y,\n                0., 0., 1., displacement.z,\n                0., 0., 0., 1.);\n}\n\nvoid up_and_right(inout vec3 lookdir, inout vec3 right, inout vec3 up) {\n\tright = normalize(cross(lookdir, up));\n    up = normalize(cross(right, lookdir));\n    \n    float looklen = length(lookdir);\n    right *= looklen * 0.4;\n    up *= looklen * 0.4;\n}\n\n//TODO: If you fail to click on something, choose the average distance in that vicinity.\nvec3 get_pivot_point(vec3 viewpoint, vec3 lookat, vec3 right, vec3 up) {\n    vec2 uv = iMouse.xy / iResolution.xy;\n    float depth = texture(iChannel2, uv).a;\n    vec2 screen_coord = 2.*uv - 1.;\n    float aspect_ratio = iResolution.x/iResolution.y;\n    return viewpoint + \n        normalize(lookat + screen_coord.x*right + screen_coord.y*up/aspect_ratio - viewpoint) * depth;\n}\n\nvoid manage_camera(inout vec3 viewpoint, inout vec3 lookat, \n                   inout vec3 lookdir, inout vec3 right, inout vec3 up,\n                   inout vec3 pivot_point, inout vec3 speed) {\n    if(iFrame == 0) {\n        viewpoint = vec3(0.,1.,1.);\n        lookat = vec3(0.,0.,0.);\n        up = vec3(0.,0.,1.0);\n        pivot_point = vec3(0., 0., 0.);\n        speed = vec3(org_speed, 0., 0.);\n    } else {\n        viewpoint = get_vec_val(VIEWPOINT);\n        lookat = get_vec_val(LOOKAT);\n        up = get_vec_val(UP);\n        pivot_point = get_vec_val(PIVOT);\n        speed = get_vec_val(SPEED);\n    }\n        \n    lookdir = lookat - viewpoint;\n    up_and_right(lookdir, right, up);\n    \n    //TODO: MAKE ALL OF THIS FRAME-RATE DEPENDENT\n    mat4 rot = mat4(1.,0.,0.,0.,0.,1.,0.,0.,0.,0.,1.,0.,0.,0.,0.,1.);\n    mat4 xpose = mat4(1.,0.,0.,0.,0.,1.,0.,0.,0.,0.,1.,0.,0.,0.,0.,1.);\n\n    if(iMouse.z >= 0.0) {\n        vec3 last_mouse = get_vec_val(LAST_MOUSE);\n        if (last_mouse.z < 0.0) {\n        \t//Store the point of intersection under the mouse. Further rotations\n            //will pivot about that point.\n            pivot_point = get_pivot_point(viewpoint, lookat, right, up);\n        } else {\n        \t//The mouse wasn't clicked during the last frame. \n \t\t\tfloat dx = iMouse.x - last_mouse.x;\n            float dy = iMouse.y - last_mouse.y;\n            //TODO: Just write the values directly into the matrix: !!!!!!!!!!!!!!!\n            xpose *= translate(-pivot_point);\n            if(abs(dx) > 0.5) {\n                mat4 tmprot = rotate(up, -dx/50.);\n            \txpose *= tmprot;\n                rot *= tmprot;\n            }\n            if(abs(dy) > 0.5) {\n                mat4 tmprot = rotate(right, dy/50.);\n            \txpose *= tmprot;\n                rot *= tmprot;\n            }\n            xpose *= translate(pivot_point);\n        }\n        \n    }\n    if(is_pressed(KEY_Q)) rot *= rotate(lookdir, 0.02);\n    if(is_pressed(KEY_E)) rot *= rotate(lookdir, -0.02);\n\n    up = (vec4(up, 1.0)*rot).xyz;\n    right = (vec4(right, 1.0)*rot).xyz;\n    lookdir = (vec4(lookdir, 1.0)*rot).xyz;\n    viewpoint = (vec4(viewpoint, 1.0)*xpose).xyz;\n    lookat = viewpoint + lookdir;\n    float omni_speed = length(speed);\n    // omni_speed=0.01;\n\n    \n    if(is_pressed(KEY_W)) {\n        vec3 displacement = omni_speed * normalize(lookdir);\n        lookat += displacement;\n        viewpoint += displacement;\n    }\n    if(is_pressed(KEY_S)) {\n        vec3 displacement = -omni_speed * normalize(lookdir);\n        lookat += displacement;\n        viewpoint += displacement;\n    }\n    if(is_pressed(KEY_A)) {\n        vec3 displacement = -omni_speed * right;\n        lookat += displacement;\n        viewpoint += displacement;\n    }\n    if(is_pressed(KEY_D)) {\n        vec3 displacement = omni_speed * right;\n        lookat += displacement;\n        viewpoint += displacement;\n    }\n    if(is_pressed(KEY_X)) {\n        vec3 displacement = omni_speed * up;\n        lookat += displacement;\n        viewpoint += displacement;\n    }\n    if(is_pressed(KEY_Z)) {\n        vec3 displacement = -omni_speed * up;\n        lookat += displacement;\n        viewpoint += displacement;\n    }\n    if(is_pressed(KEY_PGUP)) {\n        omni_speed *= 1.01;\n    }\n    if(is_pressed(KEY_PGDOWN)) {\n        omni_speed *= 0.99;\n    }\n    if(is_pressed(KEY_HOME)) {\n        omni_speed = org_speed;\n    }\n    speed = vec3(omni_speed,0.,0.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if(!persisting_coord(fragCoord))\n        return;\n    vec3 viewpoint, lookat, lookdir, right, up, pivot, speed;\n    \n    manage_camera(viewpoint, lookat, lookdir, right, up, pivot, speed);\n\n    if(set_vec_val(VIEWPOINT, fragCoord, viewpoint, fragColor))\n        return;\n    if(set_vec_val(LOOKAT, fragCoord, lookat, fragColor))\n        return;\n    if(set_vec_val(LOOKDIR, fragCoord, lookdir, fragColor))\n        return;\n    if(set_vec_val(RIGHT, fragCoord, right, fragColor))\n        return;\n    if(set_vec_val(UP, fragCoord, up, fragColor))\n        return;\n    if(set_vec_val(LAST_MOUSE, fragCoord, iMouse.xyz, fragColor))\n        return;\n    if(set_vec_val(PIVOT, fragCoord, pivot, fragColor))\n        return;\n    if(set_vec_val(SPEED, fragCoord, speed, fragColor))\n        return;\n\t\n    fragColor = vec4(1.,1.,1.,1.);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"ltfGDs","filepath":"https://soundcloud.com/stefan303/its-friday-showcase-179-felix-basque","previewfilepath":"https://soundcloud.com/stefan303/its-friday-showcase-179-felix-basque","type":"musicstream","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"#define PI 3.141\n#define FRACTAL_SEED 0.234\n#define FRACTAL_MAX_ITER 200\n#define FRACTAL_MAX_VALUE 1024.0\n#define ZERO (min(iFrame,0))\n\n\n\nfloat VIEWPOINT = 0.5;\nfloat LOOKAT = 1.5;\nfloat LOOKDIR = 2.5;\nfloat RIGHT = 3.5;\nfloat UP = 4.5;\nfloat LAST_MOUSE = 5.5;\nfloat PIVOT = 6.5;\nfloat SPEED = 7.5;\nfloat _MAX_INDEX = 7.5;\n\nbool persisting_coord(vec2 fragCoord) {\n    if(fragCoord.x <= _MAX_INDEX && fragCoord.y == 0.5)\n        return true;\n    return false;\n}\n\nvec3 get_vec_val(float index) {\n\tvec2 uv = vec2(index / iResolution.x, 0.5/iResolution.y);\n    return texture(iChannel0, uv).xyz;\n}\n\nint divisions = 18;\nfloat scale = 1.9;\nfloat threshold = 0.001;\nfloat max_dist = 1000.;\n\n\nfloat dist_gasket(vec3 z) {  \n    vec3 z0 = z;\n    float r;\n    int n = 0;\n    while (n < divisions) {\n       if(z.x+z.y<0.) z.xy = -z.yx; // fold 1\n       if(z.x+z.z<0.) z.xz = -z.zx; // fold 2\n       if(z.y+z.z<0.) z.zy = -z.yz; // fold 3\t\n       z = z*scale - vec3(1.,1.,1.)*(scale-1.0);\n       n++;\n    }\n    \n    float retval = (length(z) ) * pow(scale, -float(n));\n    //retval = min(retval, length(z0) - 0.3);\n    \n    //Render the clicked pivot point:\n    //retval = min(retval, length(z0-get_vec_val(PIVOT))-0.03);\n    return retval;\n}\nfloat dist_torus(vec3 pos) {\n\tvec3 n = vec3(sin(iTime), sin(iTime), cos(iTime));\n    float r = 2.0;\n    vec3 on_circle = normalize(cross(n, cross(pos, n))) * r;\n    return length(on_circle-pos) - .5;\n}\n\n//https://iquilezles.org/articles/distfunctions\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\nfloat opSmoothSubtraction( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); }\n\nfloat opSmoothIntersection( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.0-h); }\n\nfloat dist_cell(vec3 pos) {\n \tvec3 v0 = vec3(sin(iTime/3.), 0., cos(iTime)) - pos;\n    vec3 v1 = vec3(-sin(iTime), 0., -cos(iTime)) - pos;\n    vec3 v2 = vec3(0., cos(iTime), sin(iTime/2.)) - pos;\n    vec3 v3 = vec3(sin(iTime), cos(iTime), sin(iTime)) - pos;\n    float l0 = length(v0) - 1.8;\n    float l1 = length(v1) - 1.7;\n    float l2 = length(v2) - 1.6;\n    float l3 = length(v3) - 1.5;\n\n    return opSmoothUnion(opSmoothUnion(opSmoothUnion(l0, l1, .4), l2, 0.4), l3, 0.4);\n    return 1. + 1./l0 + 1./l1;\n}\n\nfloat dist_blob(vec3 pos) {\n \tvec3 v0 = vec3(sin(iTime/3.), 0., cos(iTime)) - pos;\n    vec3 v1 = vec3(-sin(iTime), 0., -cos(iTime)) - pos;\n    vec3 v2 = vec3(0., cos(iTime), sin(iTime/2.)) - pos;\n    vec3 v3 = vec3(sin(iTime), cos(iTime), sin(iTime)) - pos;\n    float l0 = length(v0) - .8;\n    float l1 = length(v1) - .7;\n    float l2 = length(v2) - .6;\n    float l3 = length(v3) - .5;\n\n    return opSmoothUnion(opSmoothUnion(opSmoothUnion(l0, l1, .4), l2, 0.4), l3, 0.4);\n    return 1. + 1./l0 + 1./l1;\n}\n\nfloat Power = 8.0;\nfloat Iterations = 2000.;\nfloat dist_bulb(vec3 pos) {\n\tvec3 z = pos;\n\tfloat dr = 1.0;\n\tfloat r = 0.0;\n\tfor (float i = 0.; i < Iterations ; i+=1.) {\n\t\tr = length(z);\n\t\tif (r>2.) break;\n\t\t\n\t\t// convert to polar coordinates\n\t\tfloat theta = acos(z.z/r);\n\t\tfloat phi = atan(z.y,z.x);\n\t\tdr =  pow( r, Power-1.0)*Power*dr + 1.0;\n\t\t\n\t\t// scale and rotate the point\n\t\tfloat zr = pow( r,Power);\n\t\ttheta = theta*Power;\n\t\tphi = phi*Power;\n\t\t\n\t\t// convert back to cartesian coordinates\n\t\tz = zr*vec3(sin(theta)*cos(phi), sin(phi)*sin(theta), cos(theta));\n\t\tz+=pos;\n\t}\n\treturn 0.5*log(r)*r/dr;\n}\nfloat N21(vec2 p) {\n    float hash =  fract(sin(p.x*4500.+p.y*6573.)*5649.);\n    return fract(hash*hash);\n}\nvec2 N22 (vec2 p) {\n    vec3 a = fract(p.xyx*vec3(123.34, 234.34, 345.65));\n    a += dot(a, a+34.45);\n    return fract(vec2(a.x*a.y, a.y*a.z));\n}\nfloat fractal_plane(vec2 p, vec2 seed) {\n    vec2 c = p;\n\t// iterate\n    float di =  1.0;\n    vec2 z  = vec2(0,0);\n\n    float m2 = 0.0;\n    vec2 dz = vec2(0.0);\n    for( int i=0; i<FRACTAL_MAX_ITER; i++ )\n    {\n        if( m2>FRACTAL_MAX_VALUE ) { di=0.0; break; }\n\t\t// Z' -> 2·Z·Z' + 1\n        dz = 2.0*vec2(z.x*dz.x-z.y*dz.y, z.x*dz.y + z.y*dz.x) + vec2(1.0, 0.);\n        // Z -> Z² + c\t\t\t\n        z += seed;\n        z = vec2( z.x*z.x - z.y*z.y, 2.0*z.x*z.y ) + c;\n        m2 = dot(z,z);\n    } \n    // distance\t\n\t// d(c) = |Z|·log|Z|/|Z'|\n\tfloat d = 0.5*sqrt(dot(z,z)/dot(dz,dz))*log(dot(z,z));\n    if( di>0.5 ) d=0.0;\n    return d;\n}\nfloat mirror_plane(vec2 p) {\n    vec2 cells = vec2(.5);\n    vec2 index = floor(p*cells);\n    vec2 odd = mod(index,2.);\n    if(mod(odd.x+odd.y,2.) == 0.) {\n        vec2 uv = fract(p*cells)*2.-vec2(1.);\n        return (1.-pow(clamp(length(uv),0.,1.),2.))*2.;\n    } else {\n    \treturn 0.;   \n    }\n}\nfloat dist_fractal_plane(vec3 pos) {\n\treturn  pos.z-fract(0.3*fractal_plane(pos.xy/2., vec2(0.0,0.8)));\n}\nfloat dist_sin_plane(vec3 pos) {\n\t// return  pos.z-fract(fractal_plane(pos.xy/2., vec2(0.234,0.5)));\n  \treturn  pos.z-(sin(pos.x)+cos(pos.y))*3.;\n}\nfloat dist_mirror_plane(vec3 pos) {\n    return pos.z-2.*mirror_plane(pos.xy);\n}\nfloat casin(float x) {\n\tfloat negate = float(x < 0.0);\n\tx = abs(x);\n\tfloat ret = -0.0187293;\n\tret *= x;\n\tret += 0.0742610;\n\tret *= x;\n\tret -= 0.2121144;\n\tret *= x;\n\tret += 1.5707288;\n\tret = 3.14159265358979*0.5 - sqrt(1.0 - x)*ret;\n\treturn ret - 2.0 * negate * ret;\n}\nfloat atan2(float y, float x) {\n \tfloat absx, absy, val;\n \n     if (x == 0.0 && y == 0.0) {\n \t\treturn 0.0;\n \t}\n \tabsy = y < 0.0 ? -y : y;\n \tabsx = x < 0.0 ? -x : x;\n \tif (absy - absx == absy) {\n \t\treturn y < 0.0 ? -3.1415*2.0 : 3.1415*2.0;\n \t}\n    \n    if (absx - absy == absx) {\n\t\tval = 0.0;\n    } else {\n        val = casin((y/x)/sqrt(1.0+((y/x)*(y/x))));\n    }\n \tif (x > 0.0) {\n \t\treturn val;\n \t}\n \tif (y < 0.0) {\n\t\treturn val - 3.1415;\n \t}\n \treturn val + 3.1415;\n}\nvec3 toSphere(vec3 cart) {\n\treturn vec3(\n    \tsqrt(cart.x*cart.x+cart.y*cart.y+cart.z*cart.z),\n\t\tatan2(cart.y,cart.x),\n\t\tatan2(sqrt(cart.x*cart.x+cart.y*cart.y),cart.z)\n    );\n}\nfloat dist_sphere(vec3 pos, vec3 cen, float rad, vec2 index) {\n    float fft  = texture( iChannel2, vec2(N21(index),0.25) ).x; \n    return length(cen-pos+vec3(0.,0.,fft*2.))-rad-(sin(floor(atan2(pos.y,pos.x)*5.)*33425.2*index.x*index.y)*0.5+0.5)*fft;\n    //return length(cen-pos)-rad-N21(\n    //    floor(vec2(atan2(pos.y,pos.x),atan2(sqrt(pos.x*pos.x+pos.y*pos.y),pos.z))*vec2(2.,4.)+index))*fft;\n}\n\nvec2 target_floor = vec2(0.123,0.123);\n\nfloat dist_multi_sphere(vec3 pos, out vec2 target) {\n    vec2 box_coord = fract(pos.xy*0.5)*2.-1.;\n    vec2 box_ind = floor(pos.xy*0.5);\n    float fft  = texture( iChannel2, vec2(0.1,0.25) ).x; \n\t\n    float t = iTime;\n    float nearest_sphere_dist = 1000000.;\n    vec2 box_ind_curr;\n    vec2 box_ind_calc;\n    vec2 arr_box_ind_curr[5]; \n    arr_box_ind_curr[0]= vec2(0.,0.);\n    arr_box_ind_curr[1]= vec2(0.,1.);\n    arr_box_ind_curr[2]= vec2(-1.,0.);\n    arr_box_ind_curr[3]= vec2(1.,0.);\n    arr_box_ind_curr[4]= vec2(0.,-1.);\n\tfloat curr_dist;\n    for (int i=0; i<1; i++) {\n        box_ind_curr = arr_box_ind_curr[i];\n        box_ind_calc = box_ind-box_ind_curr;\n        curr_dist = dist_sphere(vec3(box_coord+box_ind_curr*1.,pos.z), \n                                vec3(N22(box_ind_calc)-0.5,\n                                    sin(t+length(box_ind_calc))*0.5+fft+1.), \n                                0.25, \n                                box_ind_calc);\n        if (curr_dist < nearest_sphere_dist) {\n            target = box_ind_calc;\n        \tnearest_sphere_dist = curr_dist;\n        }\n    }\n    if (pos.z <= 0.01) {\n        target = target_floor;\n    }\n    return min(pos.z, nearest_sphere_dist);\n}\n\nfloat dist(vec3 pos, out vec2 target) {\n    if(pos.z>5.) {\n        target = target_floor;\n        return pos.z-4.;\n    } else { \n        return dist_multi_sphere(pos, target);\n    }\n}\n// !!!!!!!!! dist finished !!!!!!!!!!\nvec3 dx = vec3(0.0001, 0.0, 0.0);\nvec3 dy = vec3(0.0, 0.0001, 0.0);\nvec3 dz = vec3(0.0, 0.0, 0.0001);\n\nvec3 norm(vec3 p) {\n    vec2 empty_target;\n    return normalize(\n        vec3(dist(p+dx, empty_target)-dist(p-dx, empty_target),\n\t\t     dist(p+dy, empty_target)-dist(p-dy, empty_target),\n\t\t     dist(p+dz, empty_target)-dist(p-dz, empty_target))\n    );   \n}\n\nfloat rand(float seed) {\n    float s = sin(seed*iTime + 3872983.9);\n    return s*s;\n}\n\n//rd MUST BE NORMALIZED, or distance estimation will march the ray in incorrect step sizes.\nbool march(out int steps, out vec3 point, out float smallest_dist, out vec2 target, in vec3 r0, in vec3 rd) {\n    float total_dist = 0.0;\n    float cur_dist;\n    smallest_dist = 10000000.0;\n    target = target_floor;\n    vec2 curr_target = target;\n    point = r0;\n    for (steps=0; steps<100; steps++) {\n        cur_dist = dist(point, curr_target);\n        if(cur_dist < smallest_dist) {\n            smallest_dist = cur_dist;\n            target = curr_target;\n        }\n        if(cur_dist < threshold) {\n            return true;\n        }\n        total_dist += cur_dist;\n    \tpoint = r0 + rd * total_dist;\n    }\n    if(total_dist < max_dist) {\n        return true;\n    } else { \n    \treturn false;\n    }\n}\n\nvec3 ortho_light_dir;\nvec3 ortho_light_color;\n// https://iquilezles.org/articles/rmshadows\nfloat softshadow( in vec3 ro, in vec3 rd, float mint, float maxt, float k )\n{\n    vec2 empty_target;\n    float res = 1.0;\n    float ph = 1e20;\n    for( float t=mint; t<maxt; )\n    {\n        float h = dist(ro + rd*t, empty_target);\n        if(t == mint &&  h<0.001 )\n            return 1.0;\n       \tif(h<0.001 )\n            return 0.0;\n        float y = h*h/(2.0*ph);\n        float d = sqrt(h*h-y*y);\n        res = min( res, k*d/max(0.0,t-y) );\n        ph = h;\n        t += h;\n    }\n    return res;\n}\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n    vec2 empty_target;\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.15*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = dist( aopos , empty_target);\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 4.0*occ, 0.0, 1.0 ) * (0.5+0.5*nor.y);\n}\n\nvec3 localLightPos = vec3(0.,0.,3.);\nfloat localLightDensity = 60.;\n\nvec3 lighting(vec3 p, vec3 n) {\n    //AMBIENT (currently 0) Should be multiplied by diffuse color.\n    vec3 retval = vec3(0., 0.2, 0.3); \n    float dprod = dot(n, ortho_light_dir);\n    if(dprod >= 0.0) {\n        retval += ortho_light_color * (\n            //DIFFUSE\n            //vec3(0.85, 0.9, 1.0) * dprod +\n            vec3(0.9, 0.9, 0.9) * dprod +\n            //SPECULAR\n            pow(dprod, 10.0)\n            //0.0\n        );\n    }\n    dprod = dot(n, localLightPos-fract(p*localLightDensity)-0.5);\n    if(dprod >= 0.0) {\n        retval += 0.1*vec3(0.9,0.8,0.8) * (\n            //DIFFUSE\n            //vec3(0.85, 0.9, 1.0) * dprod +\n            vec3(0.9, 0.9, 0.9) * dprod +\n            //SPECULAR\n            //pow(dprod, 5.0)\n            0.0\n        );\n    }\n    \n    return retval;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tPower = 2.0 * sin(iTime) + 6.0;\n    //Screenx goes from -1.0 to 1.0\n\tvec2 screen_coord = -1.0 + 2.0 * (fragCoord.xy / iResolution.xy);\n    float aspect_ratio = iResolution.x/iResolution.y;\n    //Screen y goes from (-1.0/aspect_ratio to 1.0/aspect_ratio)\n    screen_coord.y /= aspect_ratio;\n\n    float fft  = texture( iChannel2, vec2(0.1,0.25) ).x; \n    ortho_light_dir = normalize(vec3(sin(iTime+fft), cos(iTime+fft), 2.));\n\t//ortho_light_color = vec3(0.9, 0.75, 1.0);\n    ortho_light_color = vec3(1., 1., 1.0);\n\n\tvec3 viewpoint = get_vec_val(VIEWPOINT);\n    vec3 lookat = get_vec_val(LOOKAT);\n    vec3 lookdir = get_vec_val(LOOKDIR);\n    vec3 right = get_vec_val(RIGHT);\n    vec3 up = get_vec_val(UP);\n\n    vec3 ray_d = \n        normalize(\n        \tlookat\n            + screen_coord.x * right\n            + screen_coord.y * up\n            - viewpoint\n        );\n    \n    int iterations;\n    vec3 intersection;\n    float smallest_dist;\n    vec2 target;\n    bool hit = march(iterations, \n                     intersection, \n                     smallest_dist, \n                     target,\n                     viewpoint, \n                     ray_d*0.75);\n   \n    if(hit) {\n        fragColor = vec4(norm(intersection), \n                         length(intersection-viewpoint));\n\t\t// return;\n        fragColor = vec4(sin(float(iterations)/3.), \n                         cos(float(iterations)/3.), \n                         -sin(float(iterations)/5.), \n                         length(intersection-viewpoint));\n        // return;\n        vec3 normal = norm(intersection);\n        \n        float sh_step_fac = 1.;\n        float sh_res = 0.15+mix(0., .5,\n                               softshadow( \n                                   intersection, \n                                   ortho_light_dir/sh_step_fac, \n                                   3.*threshold*sh_step_fac, \n                                   5.*sh_step_fac, \n                                   10.*sh_step_fac \n                             \t)\n        );\n        localLightPos = vec3(0.5,0.5,.5+1.*(sin(iTime)*0.5+0.5)+2.*fft);\n        vec3 localPos = vec3(fract(intersection.xy*localLightDensity), intersection.z);\n        sh_res += 0.+mix(0., .0,\n                               softshadow( \n                                   localPos, \n                                   (localLightPos-localPos)/sh_step_fac, \n                                   3.*threshold*sh_step_fac, \n                                   5.*sh_step_fac, \n                                   10.*sh_step_fac \n                             \t)\n        );\n        //float occ = calcAO(intersection, normal);\n        vec3 light = lighting(intersection, normal);\n        \n        fragColor = vec4(\n                // sh_res*light*occ*1.5,\n            \tsh_res*light*light*0.75*vec3(N22(target+0.23)*0.5,0.5),\n                //length(intersection-viewpoint)\n                1.0\n        );\n    } else {\n        float sky_brightness = max(dot(ray_d, ortho_light_dir), 0.0);\n        vec3 sky_color = sky_brightness * ortho_light_color;\n    \tfragColor = vec4(sky_color, 10.0);\n    }\n}\n","name":"Buffer B","description":"","type":"buffer"}]}