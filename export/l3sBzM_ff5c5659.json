{"ver":"0.1","info":{"id":"l3sBzM","date":"1728473186","viewed":168,"name":"Monomino Domino Tile Traversal","username":"Shane","description":"Using a simple back-buffer technique to produce a random monomino domino tiling, then extruding it to 3D space via raymarching traversal. Mouse down for more random combinations.","likes":24,"published":3,"flags":32,"usePreview":1,"tags":["raymarching","grid","rectangle","prism","city","block","traversal","sparse","domino","monomino"],"hasliked":0,"parentid":"DdBfzt","parentname":"Cell-By-Cell Raymarching"},"renderpass":[{"inputs":[{"id":"4sXGRn","filepath":"/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","previewfilepath":"/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n\n    Monomino Domino Tile Traversal\n    ------------------------------\n    \n    Using a simple back-buffer technique to produce a random monomino domino \n    tiling, then extruding it to 3D space via raymarching traversal. For those\n    not familiar with the words, monomino and domino, they refer to tiles that\n    take up one square (1x1 only) and tiles that take up two adjacent squares, \n    namely, 1x2 or 2x1 tiles. There are also tromino tiles, tetramino, etc., \n    and all are members of the polyomino family.\n    \n    With that in mind, this example is indirectly related to JT's domino tiling \n    efforts, which also provided the inspiration. There is a lot of imagery \n    featuring random mixes of squares and 2x1 rectangles. There are various ways \n    to produce them, but so far, I haven't seen what I'd discribe as a simplistic \n    way to produce one in a single pass -- other than hard-coding a pattern and \n    rendering that. In fact, for those requiring a specific layout, I'd say that \n    would be the only way to do it... Having said all that, if someone knows of \n    a cute trick to produce a random tiing of 1x1 and 2x1 tiles in a single pass, \n    feel free to let me know.\n    \n    Either way, the patterns are almost trivial to produce with the help of a \n    backbuffer and more than one pass: Basically, you set aside a rectangular\n    grid of pixels. If you want to render 2x1 rectangles, check for any pair of \n    empty ajoining pixels, assign random directions, and if they're compatible \n    (point to one another), record the directions and flag them as non-empty.\n    Rendering 1x1 pixels is trivial, since you can flag any at any point as\n    non-empty, and you're done. Of course, I'm skipping over the details, but\n    you can find those in the backbuffer tab (Buffer A).\n    \n    As an aside, I like the benefits of using backbuffers for precalculation, \n    storage, etc, but I don't enjoy setting them up and so forth. Either way, \n    this one was pretty easy to write, partly due to the ground work of many \n    others on here, but mostly because it was a pretty simple example to begin \n    with.\n    \n    As for the 3D (or 2.5D, if you prefer) rendering, that's pretty simple too,\n    and I've covered it before in other shaders. I'll provide a link to a \n    raymarching traversal example, and a few others that I think will be helpful, \n    for anyone interested in this kind of thing.\n    \n    \n    \n    // Other examples:\n    \n    // This example was inspired by JT's various domino tiling\n    // examples, but is probably more closely related to this one.\n    pair noise (sparse dimer tiling) - jt\n    https://www.shadertoy.com/view/XXVSWV\n    \n    // Fabrice and SnoopethDuckDuck's combined logic, which is\n    // pretty difficult to compete with. It's a really nicely \n    // written example. If anyone does manage to outlogic this \n    // logic, please let me know. :) \n    Cell Swap Automata - SnoopethDuckDuck\n    https://www.shadertoy.com/view/DtccR8\n    \n    // A really nice example on so many different levels.\n\tSelf-Avoiding Random Road - mathmasterzach\n\thttps://www.shadertoy.com/view/wdySWm \n    \n    // Amalgamating cell-by-cell traversal and raymarching to render\n    // a subdivided rectangular grid.\n    Cell-By-Cell Raymarching - Shane\n    https://www.shadertoy.com/view/DdBfzt\n\n*/\n\n\n// Max ray distance.\n#define FAR 20.\n\n// Only display the 2D pattern.\n//#define SHOW_2D_PATTERN\n\n\n// Scene object ID to separate the mesh object from the terrain.\nfloat objID;\n\n\n// Tri-Planar blending function: Based on an old Nvidia writeup:\n// GPU Gems 3 - Ryan Geiss: http://http.developer.nvidia.com/GPUGems3/gpugems3_ch01.html\nvec3 tex3D(sampler2D tex, in vec3 p, in vec3 n){    \n    \n    // Abosolute normal with a bit of tightning.\n    n = max(n*n - .2, .001); // max(abs(n), 0.001), etc.\n    n /= dot(n, vec3(1)); \n    //n /= length(n); \n    \n    // Texure samples. One for each plane.\n    vec3 tx = texture(tex, p.zy).xyz;\n    vec3 ty = texture(tex, p.xz).xyz;\n    vec3 tz = texture(tex, p.xy).xyz;\n    \n    // Multiply each texture plane by its normal dominance factor.... or however you wish\n    // to describe it. For instance, if the normal faces up or down, the \"ty\" texture \n    // sample, represnting the XZ plane, will be used, which makes sense.\n    \n    // Textures are stored in sRGB (I think), so you have to convert them to linear space \n    // (squaring is a rough approximation) prior to working with them... or something like\n    // that. :) Once the final color value is gamma corrected, you should see correct \n    // looking colors.\n    return mat3(tx*tx, ty*ty, tz*tz)*n;\n}\n\n\n// Texture sample.\n//\nvec3 getTex(sampler2D iCh, vec2 p){\n    \n    // Strething things out so that the image fills up the window. You don't need to,\n    // but this looks better. I think the original video is in the oldschool 4 to 3\n    // format, whereas the canvas is along the order of 16 to 9, which we're used to.\n    // If using repeat textures, you'd comment the first line out.\n    //p *= vec2(iResolution.y/iResolution.x, 1);\n    vec3 tx = texture(iCh, p).xyz;\n    return tx*tx; // Rough sRGB to linear conversion.\n}\n\n// Height map value.\nfloat hm(in vec2 p){ \n\n    //float h = dot(getTex(iChannel1, p), vec3(.299, .587, .114)); \n    //float h = texture(iChannel1, p/128.).x; \n    float h = dot(sin(p - cos(p.yx*2.5 + iTime*2.)), vec2(.25)) + .5; \n    return smoothstep(0.2, 1., h)*.7 + h*.3;\n    //return sin(6.2831853*h + iTime)*.5 + .5;\n}\n\n\n\n\n// IQ's extrusion formula.\nfloat opExtrusion(in float sdf, in float pz, in float h, in float sf){\n\n    // Slight rounding. A little nicer, but slower.\n    vec2 w = vec2( sdf, abs(pz) - h) + sf;\n  \treturn min(max(w.x, w.y), 0.) + length(max(w, 0.)) - sf;\n}\n\n/*\n// IQ's 2D signed box formula with some added rounding.\nfloat sBoxS(vec2 p, vec2 b, float sf){\n\n  p = abs(p) - b + sf;\n  return min(max(p.x, p.y), 0.) + length(max(p, 0.)) - sf;\n}\n*/\n\n// IQ's rounded box function -- with added functionality for variable roundness \n// on each corner. I originally infused similar functionality into IQ's original \n// box function, only to find his more succinct version afterward... If I had \n// a dollar for every time that's happened. :D Anyway, the link is here:\n//\n// Rounded Box - distance 2D - iq\n// https://www.shadertoy.com/view/4llXD7\n//\n// The last variable, \"r\", represents roundness of each corner, running clockwise \n// from the bottom left: vec4(bLft, tLft, tRgt, bRgt).\nfloat sBoxS(in vec2 p, in vec2 b, in vec4 r){ \n\n    // Checking which quadrant (corner) the pixel resides in.\n    r.xy = p.x<0.? r.yx : r.wz;\n    r.x  = p.y<0.? r.y  : r.x;\n    \n    p = abs(p) - b + r.x;\n    return min(max(p.x, p.y),0.) + length(max(p, 0.)) - r.x;\n}\n\n// Obtaining a pixel from a GRID_SIZE by GRID_SIZE sized\n// square on the backbuffer.\nvec4 tx(vec2 uv){ \n    uv = mod(uv, GRID_SIZE);\n    return texelFetch(iChannel0, ivec2(uv), 0);\n}\n\n// Subdivided rectangle grid.\nvec3 getGrid(inout vec2 p, vec2 sc){\n      \n    \n    // Positional cell ID and local coordinates. If you didn't want to shift\n    // rows and columns, you wouldn't need any of the code above, nor would you\n    // need the three lines below.\n    vec2 ip = floor(p/sc);\n    p -= (ip + .5)*sc;\n\n    // Read the pixels from the backbuffer.\n    vec4 bufA = tx(ip);\n    \n    float obj = 1e5; // Cell object.\n    vec2 lw = sc/2.; // Rectangle dimensions.\n    \n    \n    // Converting the packed single value buffer position to 2D coordinates.\n    // ID within the block.\n    vec2 pID = vec2(mod(bufA.y, GRID_SIZE), floor(bufA.y/(GRID_SIZE)));\n    // Overall square grid block.\n    pID += floor(ip/GRID_SIZE)*GRID_SIZE;\n    \n    // Random corner roundness values. There are four different sizes,\n    // but we're only using the first two.\n    vec4 crnrSz = vec4(.15, .5, .25, 0);\n \n    // Cast to one of five possible integer values, namely, 0, 1, 2, 3, 4.\n    // Zero for no links, and the other for a possible four link directions.\n    int iVal = int(bufA.x);\n   \n    // No links to adjoining cells, so just a single square.\n    if(iVal==0){\n       // Rendering just a single box. Less work, but not as interesting.\n       //obj = sBoxS(q, vec2(lw), .25);\n        \n       vec4 vRnd = hash42(pID);\n       ivec4 rndIndex = ivec4(mod(floor(vRnd*72.), 2.));\n       // Example outcome: vec4(.15, .5, .5, .15);\n       vec4 r;\n       r.x = crnrSz[rndIndex.x];\n       r.y = crnrSz[rndIndex.y];\n       r.z = crnrSz[rndIndex.z];\n       r.w = crnrSz[rndIndex.w];\n       obj = sBoxS(p, lw, r*sc.x);\n    }\n    else{\n    \n        // Cells with adjoining links; Only one in this example, but\n        // it's possible to have more.\n        \n        // Index. The direction indices are 1, 2, 3, 4, which represent\n        // left, up, right and down (see vectors \"e\").\n        int i = iVal - 1; \n\n         \n        // If an adjoining cell link is flagged, render the adjoining\n        // link. In this case, it'll be a 2x1 domino centered on the\n        // adjoining cell's edge.\n        // Updating the ID by the relative positional ID change.\n        pID = (pID + e[i]*.5); // No need to wrap, on this occasion.\n\n\n        // Move to the cell edge, and rotate accordingly.\n        //vec2 q2 = rot2(3.14159265/2.*float(i))*(q - dir[i]*sc);\n        vec2 q = (i&1)==0? p - e[i]*sc/2. : (p - e[i]*sc/2.).yx*vec2(1, -1);\n\n        // Random corner values.\n        vec4 vRnd = hash42(pID);\n        ivec4 rndIndex = ivec4(mod(floor(vRnd*72.), 2.));\n        // Example outcome: vec4(.15, .5, .5, .15);\n        vec4 r;\n        r.x = crnrSz[rndIndex.x];\n        r.y = crnrSz[rndIndex.y];\n        r.z = crnrSz[rndIndex.z];\n        r.w = crnrSz[rndIndex.w];\n        \n        // Render the square with the variable corner roundness.\n        obj = min(obj, sBoxS(q, lw + vec2(lw.x, 0), r*sc.x));\n    \n    }\n    \n    // Decreasing the size just a little.\n    obj += .005;\n  \n    \n    // Local coordinates and cell ID.\n    return vec3(obj, pID*sc);//\n\n}\n\n// Global cell boundary distance variables.\nvec3 gDir; // Cell traversing direction.\nvec3 gRd; // Ray direction.\nfloat gCD; // Cell boundary distance.\n// Box dimension and local XY coordinates.\nvec3 gSc; \nvec2 gP;\n\n \n// An extruded subdivided block grid. Use the grid cell's center pixel \n// to obtain a height value (read in from a height map), then render a \n// pylon at that height.\n\nvec4 blocks(vec3 q3){\n    \n \n    // Local coordinates.\n    vec2 p = q3.xy;\n\n    vec3 sc = vec3(1)/4.; // Scale.\n    // Local coordinates and cell ID.\n    vec3 p3 = getGrid(p, sc.xy); \n    \n    // 2D field value and corresponding position-based ID.\n    float d2 = p3.x;\n    vec2 id = p3.yz;\n\n\n    // The distance from the current ray position to the cell boundary\n    // wall in the direction of the unit direction ray. This is different\n    // to the minimum wall distance, so you need to trace out instead\n    // of merely doing a box calculation. Anyway, the following are pretty \n    // standard cell by cell traversal calculations. The resultant cell\n    // distance, \"gCD\", is used by the \"trace\" and \"shadow\" functions to \n    // restrict the ray from overshooting, which in turn restricts artifacts.\n    //vec3 rC = (gDir*sc - vec3(p, q3.z))/gRd;\n    vec2 rC = (gDir.xy*sc.xy - p)/gRd.xy; // For 2D, this will work too.\n    \n    // Minimum of all distances, plus not allowing negative distances, which\n    // stops the ray from tracing backwards... I'm not entirely sure it's\n    // necessary here, but it stops artifacts from appearing with other \n    // non-rectangular grids.\n    //gCD = max(min(min(rC.x, rC.y), rC.z), 0.) + .0015;\n    gCD = max(min(rC.x, rC.y), 0.) + .001; // Adding a touch to advance to the next cell.\n\n\n    // The extruded block height. See the height map function, above.\n    float h = hm(id);\n    h = h*1. + .05;\n    \n    // Thin holes.\n    //if(hash21(id + .43)<.5) \n    d2 = max(d2, -(d2 + sc.x*.55));\n\n\n    // Extrude the 2D shape.\n    float d = opExtrusion(d2, q3.z + h/2., h/2., .0);// - bev;\n    \n    // Beveling.\n    d -= min(-d2/sc.x, .15)*.25;\n    //d += d2*.125;\n\n    /*\n    // Putting some random Lego-like circles, or whatever on top.\n    if(min(sc.x, sc.y)>.125 && hash21(id + .03)<1.5){ \n       //float d2 = opExtrusion(d2 + .07, q3.z + h/2. + .3, h/2., .0);\n       \n       float d2 = opExtrusion(length(p)-sc.x/5.5, q3.z + h/2. + .07, h/2., .0);\n       d = min(d, d2);\n    }\n    */\n    \n    // Saving the box dimensions and local coordinates.\n    gSc = vec3(sc.xy, h);\n    gP = p;\n\n        \n   \n    // Return the distance, position-base ID and box ID.\n    return vec4(d, d2, id);\n}\n\n\n// Block ID -- It's a bit lazy putting it here, but it works. :)\nvec4 gID;\n\n// The extruded image.\nfloat map(vec3 p){\n    \n    // Floor.\n    float fl = -p.z;\n\n    // The extruded blocks.\n    vec4 d4 = blocks(p);\n    gID = d4; // Individual block ID.\n    \n \n    // Overall object ID.\n    objID = fl<d4.x? 1. : 0.;\n    \n    // Combining the floor with the extruded image\n    return  min(fl, d4.x);\n \n}\n\n \n// Basic raymarcher.\nfloat trace(in vec3 ro, in vec3 rd){\n\n    // Overall ray distance and scene distance.\n    float d, t = 0.; //hash31(ro + rd)*.15\n    \n    //vec2 dt = vec2(1e5, 0); // IQ's clever desparkling trick.\n    \n    // Set the global ray direction varibles -- Used to calculate\n    // the cell boundary distance inside the \"map\" function.\n    gDir = step(0., rd) - .5;\n    gRd = rd; \n    \n    int i;\n    const int iMax = 128;\n    for (i = min(iFrame, 0); i<iMax; i++){ \n    \n        d = map(ro + rd*t);       \n        //dt = d<dt.x? vec2(d, dt.x) : dt; // Shuffle things along.\n        \n        // Note the \"t*b + a\" addition. Basically, we're putting less emphasis on accuracy, \n        // as \"t\" increases. It's a cheap trick that works in most situations.\n        if(abs(d)<.001*(1. + t*.05)|| t>FAR) break; \n        \n        //t += i<32? d*.75 : d; \n        t += min(d, gCD); \n    }\n    \n    // If we've run through the entire loop and hit the far boundary, \n    // check to see that we haven't clipped an edge point along the way. \n    // Obvious... to IQ, but it never occurred to me. :)\n    //if(i>=iMax - 1) t = dt.y;\n\n    return min(t, FAR);\n}\n\n\n// Standard normal function. It's not as fast as the tetrahedral calculation, but more \n// symmetrical.\nvec3 getNormal(in vec3 p, float t) {\n\tconst vec2 e = vec2(.001, 0);\n\treturn normalize(vec3(map(p + e.xyy) - map(p - e.xyy), map(p + e.yxy) - map(p - e.yxy),\t\n                     map(p + e.yyx) - map(p - e.yyx)));\n}\n\n\n// Cheap shadows are hard. In fact, I'd almost say, shadowing particular scenes with \n// limited iterations is impossible... However, I'd be very grateful if someone could \n// prove me wrong. :)\nfloat softShadow(vec3 ro, vec3 lp, vec3 n, float k){\n\n    // More would be nicer. More is always nicer, but not always affordable. :)\n    const int maxIterationsShad = 48; \n    \n    ro += n*.0015; // Coincides with the hit condition in the \"trace\" function.\n    vec3 rd = lp - ro; // Unnormalized direction ray.\n    \n\n    float shade = 1.;\n    float t = 0.; \n    float end = max(length(rd), .0001);\n    //float stepDist = end/float(maxIterationsShad);\n    rd /= end;\n    \n    // Set the global ray direction varibles -- Used to calculate\n    // the cell boundary distance inside the \"map\" function.\n    gDir = sign(rd)*.5;\n    gRd = rd;\n\n    // Max shadow iterations - More iterations make nicer shadows, but slow things down. \n    // Obviously, the lowest number to give a decent shadow is the best one to choose. \n    for (int i = min(iFrame, 0); i<maxIterationsShad; i++){\n\n        float d = map(ro + rd*t);\n        \n        \n        shade = min(shade, k*d/t);\n        //shade = min(shade, smoothstep(0., 1., k*h/dist)); // Thanks to IQ for this tidbit.\n        // So many options here, and none are perfect: dist += min(h, .2), \n        // dist += clamp(h, .01, stepDist), etc.\n        t += clamp(min(d, gCD), .02, .25); \n        \n        \n        // Early exits from accumulative distance function calls tend to be a good thing.\n        if (d<0. || t>end) break; \n    }\n\n    // Shadow.\n    return max(shade, 0.); \n}\n\n\n// I keep a collection of occlusion routines... OK, that sounded really nerdy. :)\n// Anyway, I like this one. I'm assuming it's based on IQ's original.\nfloat calcAO(in vec3 p, in vec3 n){\n\n\tfloat sca = 2., occ = 0.;\n    for(int i = 0; i<5; i++){\n    \n        float hr = float(i + 1)*.125/5.;        \n        float d = map(p + n*hr);\n        occ += (hr - d)*sca;\n        sca *= .7;\n    }\n    \n    return clamp(1. - occ, 0., 1.);    \n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n    \n    // Screen coordinates.    \n\tvec2 uv = (fragCoord - iResolution.xy*.5)/iResolution.y;\n\t\n\t// Camera Setup.\n\tvec3 ro = vec3(iTime/2., 0, -3); // Camera position, doubling as the ray origin.\n\tvec3 lk = ro + vec3(.0, .05, .25);//vec3(0, -.25, iTime);  // \"Look At\" position.\n \n    // Light positioning.\n    vec3 lp = ro + vec3(2, 1, 0);// Put it a bit in front of the camera.\n\t\n\n    // Using the above to produce the unit ray-direction vector.\n    float FOV = 1.25; // FOV - Field of view.\n    vec3 fwd = normalize(lk - ro);\n    vec3 rgt = normalize(vec3(fwd.z, 0., -fwd.x ));\n    vec3 up = cross(fwd, rgt); \n\n    // rd - Ray direction.\n    //vec3 rd = normalize(fwd + FOV*uv.x*rgt + FOV*uv.y*up);\n    vec3 rd = normalize(uv.x*rgt + uv.y*up + fwd/FOV);\n    \n    // Rotation.\n\trd.xy *= rot2(-.25);    \n\n\t \n    \n    // Raymarch to the scene.\n    float t = trace(ro, rd);\n    \n    // Save the block ID and object ID.\n    vec4 svGID = gID;\n    \n    // Scene object ID. Either the pylons or the floor.\n    float svObjID = objID;\n    \n    // Saving the block scale and local 2D base coordinates.\n    vec3 svSc = gSc;\n    vec2 svP = gP;\n    \n \t\n    // Initiate the scene color to black.\n    vec3 col = vec3(0);\n\t\n\t// The ray has effectively hit the surface, so light it up.\n\tif(t < FAR){\n        \n  \t\n    \t// Surface position and surface normal.\n\t    vec3 sp = ro + rd*t;\n\t    //vec3 sn = getNormal(sp, edge, crv, ef, t);\n        vec3 sn = getNormal(sp, t);\n        \n        // Light direction vector.\n\t    vec3 ld = lp - sp;\n\n        // Distance from respective light to the surface point.\n\t    float lDist = max(length(ld), .001);\n    \t\n    \t// Normalize the light direction vector.\n\t    ld /= lDist;\n        \n          \n        // Obtaining the texel color. \n\t    vec3 oCol; \n        \n        \n        // Standard material properties: Roughness, matType and reflectance.\n        //\n        float roughness = 1.; // Lower roughness reflects more light, as expected.\n        float matType = 0.; // Dielectric (non conducting): 0, or metallic: 1.\n        float reflectance = .25; // Reflective strength.\n\n\n        // The extruded grid.\n        if(svObjID<.5){\n            \n            \n            // Random coloring using IQ's short versatile palette formula.\n            float rnd = hash21(svGID.zw + .34);\n            vec3 sCol = .5 + .45*cos(6.2831853*rnd/1. + vec3(0, 1, 2)*1.5);\n            //sCol *= 1.25;\n            \n            vec3 gr = vec3(1)*dot(sCol, vec3(.299, .587, .114));\n            \n            if(hash21(svGID.zw + .24)<.33) sCol = gr;//sCol.xxx;//\n       \n            // Coloring the individual blocks with the saved ID.\n            vec3 tx = getTex(iChannel1, svGID.zw);\n            // Grunge texturing.\n            vec3 tx2 = tex3D(iChannel1, sp/1., sn);\n            // Combining.\n            oCol = sCol;//*(tx2*3. + .1);\n            //oCol = tx.yzx*.65;//\n            \n            float grT = dot(tx2, vec3(.299, .587, .114)); \n            roughness *= grT*grT*4. + .0;\n            \n           \n            /*\n            #if 0\n            // Last minute edge routine. I've returned the nearest rectangle ID\n            // and dimensions from the \"raycasting\" routine, and the rest \n            // figures itself out.\n            float ew = .0125;//*(1. + t*.1); // Edge width.\n            float h = svSc.z;\n            float top = max(abs(sp.z + h + ew), abs(svGID.y));\n            float objEdge = top - ew/1.5;\n         \n            float svEw = .0125*(1. + t*.1);\n            float sf = 4./iResolution.y;\n            \n            vec3 svCol = oCol;\n            //oCol = mix(oCol, gr, 1. - smoothstep(0., sf, -(sp.z + h)));\n\n            //oCol = mix(oCol, oCol*1.5, 1. - smoothstep(0.,sf, svObjEdge - svEw));\n            oCol = mix(oCol, svCol*.1, 1. - smoothstep(0., sf, objEdge));\n            //oCol = mix(oCol, mix(svCol*2., vec3(1), .5), \n            //           1. - smoothstep(0., sf, sp.z + h + .0125));\n\n            //oCol = mix(oCol, svCol*.1, 1. - smoothstep(0., sf, svD2 + .04));\n            //oCol = mix(oCol, mix(svCol, vec3(1), .0), \n            //           1. - smoothstep(0., sf, svD2 + .04 + .0125));\n            #endif\n            */\n           \n \n        }\n        else {\n            \n            // The dark floor in the background. Hidden behind the pylons, but\n            // I'm including it anyway.\n            //vec3 tx = getTex(iChannel1, sp.xy);\n            //oCol = vec3(.1)/8.*(tx*2. + 1.);\n            oCol = vec3(0);\n        }\n      \n        \n        // Shadows and ambient self shadowing.\n    \tfloat sh = softShadow(sp, lp, sn, 16.);\n    \tfloat ao = calcAO(sp, sn); // Ambient occlusion.\n\t    \n\t    // Light attenuation, based on the distances above.\n\t    float atten = 1./(1. + lDist*.05);\n    \t\n         \n        /*\n        // Cheap specular reflections. Requires loading the \"Forest\" cube map \n        // into \"iChannel2\".\n        float speR = pow(max(dot(normalize(ld - rd), sn), 0.), 5.);\n        vec3 rf = reflect(rd, sn); // Surface reflection.\n        vec3 rTx = texture(iChannel2, rf.xzy*vec3(1, -1, -1)).xyz; rTx *= rTx;\n        oCol = oCol*.7 + oCol*speR*rTx*1.5;\n        */\n         \n        \n        // I wanted to use a little more than a constant for ambient light this \n        // time around, but without having to resort to sophisticated methods, then I\n        // remembered Blackle's example, here:\n        // Quick Lighting Tech - blackle\n        // https://www.shadertoy.com/view/ttGfz1\n        // Studio.\n        //float am = pow(length(sin(sn*2.)*.5 + .5)/sqrt(3.), 2.)*1.5; \n        // Outdoor.\n        float am = length(sin(sn*2.)*.5 + .5)/sqrt(3.)*smoothstep(-1., 1., -sn.z); \n\n\n        // Cook-Torrance based lighting. The last term is specular coloring.\n        vec3 ct = BRDF(oCol, sn, ld, -rd, matType, roughness, reflectance, vec3(1));\n\n\n        // Combining the ambient and microfaceted terms to form the final color:\n        // None of it is technically correct, but it does the job. Note the hacky \n        // ambient shadow term. Shadows on the microfaceted metal doesn't look \n        // right without it... If an expert out there knows of simple ways to \n        // improve this, feel free to let me know. :)\n        col = (oCol*am*(.75 + sh*.25) + ct*(sh));        \n        \n        \n        // Shading.\n        col *= ao*atten;\n          \n\t\n\t}\n    \n    \n    // Applying fog: This fog begins at 90% towards the horizon.\n    //col = mix(col, vec3(1, .5, 2), smoothstep(.25, .9, t/FAR));\n \n    \n    // Greyscale.\n    //col = vec3(1)*dot(col, vec3(.299, .587, .114));\n    \n    #ifdef SHOW_2D_PATTERN\n    vec4 b = blocks(vec3(uv*4. + vec2(0, iTime/4.), 1));\n    float rnd = hash21(b.zw + .34);\n    vec3 sCol = .5 + .45*cos(6.2831853*rnd/1. + vec3(0, 1, 2)*1.5);\n    col = mix(vec3(0), sCol, 1. - smoothstep(0., 1./iResolution.y, b.y/4. + .003));\n    #endif\n    \n \n    // Rough gamma correction.\n    fragColor = vec4(sqrt(max(col, 0.)), 1);\n    \n\t\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// Backbuffer grid size. Thankfully, not many are needed for this example.\nconst float GRID_SIZE = 32.;\nconst float scale = 1./GRID_SIZE;\n\n// Standard 2D rotation formula.\nmat2 rot2(in float a){ float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\n\n// Fabrice's fork of \"Integer Hash - III\" by IQ: https://shadertoy.com/view/4tXyWN\nfloat hash21(vec2 f){\n\n    //f = mod(f, GRID_SIZE);\n    // The first line relates to ensuring that icosahedron vertex identification\n    // points snap to the exact same position in order to avoid hash inaccuracies.\n    uvec2 p = floatBitsToUint(f);\n    p = 1664525U*(p>>1U^p.yx);\n    return float(1103515245U*(p.x^(p.y>>3U)))/float(0xffffffffU);\n}\n\n// IQ's \"uint\" based uvec3 to float hash.\nfloat hash31(vec3 f){\n\n    //f.xy = mod(f.xy, GRID_SIZE);\n    uvec3 p = floatBitsToUint(f);\n    p = 1103515245U*((p >> 2U)^(p.yzx>>1U)^p.zxy);\n    uint h32 = 1103515245U*(((p.x)^(p.y>>3U))^(p.z>>6U));\n\n    uint n = h32^(h32 >> 16);\n    return float(n & uint(0x7fffffffU))/float(0x7fffffff);\n}\n\n\n// A slight reworking of Nimitz's function from here.\n// Quality hashes collection WebGL2 - nimitz\n// https://www.shadertoy.com/view/Xt3cDn\n//\n// Which in turn was modified from IQ's function, here:\n// Integer Hash - III \n// https://www.shadertoy.com/view/4tXyWN\n//\nvec4 hash42(vec2 f){\n\n    //f = mod(f, GRID_SIZE);\n    uvec2 p = floatBitsToUint(f);\n    p = 1664525U*(p>>1U^p.yx); // 1103515245U\n    uint n = 1103515245U*((p.x)^(p.y>>3U));\n    n = n^(n >> 16);\n\n    // See: http://random.mat.sbg.ac.at/results/karl/server/node4.html\n    uvec4 rz = uvec4(n, n*16807U, n*48271U, n*69621U); \n    return vec4((rz >> 1) & uvec4(0x7fffffffU))/float(0x7fffffff);\n}\n\n// The four direction vectors.\nvec2[4] e = vec2[4](vec2(-1, 0), vec2(0, 1), vec2(1, 0), vec2(0, -1));\n\nvec2 indexToDir(float i) {\n    \n    // Converts 0, 1, 2 or 3 to the left, up, right, down vectors respectively.\n    //return mod(i, 2.)==0.? vec2(i - 1., 0) : vec2(0, 2. - i);\n    \n    // The following would do it too.\n    //const vec2[4] e = vec2[4](vec2(-1, 0), vec2(0, 1), vec2(1, 0), vec2(0, -1));\n    return e[int(i)]; \n}\n\nfloat dirToIndex(vec2 u) {\n    \n    // Converts the left, up, right, down vectors to 0, 1, 2 or 3 respectively.\n    //return u.x<0.? 0. : u.y<0.? 3. : u.x==0.? 1. : 2.; \n    \n    // The following would do it too.\n    //const vec2[4] e = vec2[4](vec2(-1, 0), vec2(0, 1), vec2(1, 0), vec2(0, -1));\n    int i;\n    for(i = 0; i<4; i++){ if(u == e[i]) break; }\n    \n    return float(i);\n}\n\nfloat rndDirIndex(vec3 ut){\n    // Returns a random number based on 2D position and time.\n    return mod(floor(64.*hash31(ut)), 4.);\n}\n\nvec2 rndDir(vec3 u) {\n    // Returns a random direction.\n    return indexToDir(rndDirIndex(u));\n}\n\n\n///////////////////////////\nconst float PI = 3.14159265;\n\n// Microfaceted normal distribution function.\nfloat D_GGX(float NoH, float roughness) {\n    float alpha = pow(roughness, 4.);\n    float b = (NoH*NoH*(alpha - 1.) + 1.);\n    return alpha/(PI*b*b);\n}\n\n// Surface geometry function.\nfloat G1_GGX_Schlick(float NoV, float roughness) {\n    //float r = roughness; // original\n    float r = .5 + .5*roughness; // Disney remapping.\n    float k = (r*r)/2.;\n    float denom = NoV*(1. - k) + k;\n    return max(NoV, .001)/denom;\n}\n\nfloat G_Smith(float NoV, float NoL, float roughness) {\n    float g1_l = G1_GGX_Schlick(NoL, roughness);\n    float g1_v = G1_GGX_Schlick(NoV, roughness);\n    return g1_l*g1_v;\n}\n\n// Bidirectional Reflectance Distribution Function (BRDF). \n//\n// If you want a quick crash course in BRDF, see the following:\n// Microfacet BRDF: Theory and Implementation of Basic PBR Materials\n// https://www.youtube.com/watch?v=gya7x9H3mV0&t=730s\n//\nvec3 BRDF(vec3 col, vec3 n, vec3 l, vec3 v, \n          float type, float rough, float fresRef, vec3 spCol){\n   \n    vec3 h = normalize(v + l); // Half vector.\n\n    // Standard BRDF dot product calculations.\n    float nv = clamp(dot(n, v), 0., 1.);\n    float nl = clamp(dot(n, l), 0., 1.);\n    float nh = clamp(dot(n, h), 0., 1.);\n    float vh = clamp(dot(v, h), 0., 1.);  \n\n    // Specular microfacet (Cook- Torrance) BRDF.\n    //\n    // F0 for dielectics in range [0., .16] \n    // Default FO is (.16 * .5^2) = .04\n    // Common Fresnel values, F(0), or F0 here.\n    // Water: .02, Plastic: .05, Glass: .08, Diamond: .17\n    // Metals: I think all need to be converted to linear form (roughly squared).\n    // Copper: vec3(.95, .64, .54), Aluminium: vec3(.91, .92, .92), Gold: vec3(1, .71, .29),\n    // Silver: vec3(.95, .93, .88), Iron: vec3(.56, .57, .58).\n    vec3 f0 = vec3(.16*(fresRef*fresRef)); \n    // For metals, the base color is used for F0.\n    f0 = mix(f0, col, type);\n    vec3 F = f0 + (1. - f0)*pow(1. - vh, 5.);  // Fresnel-Schlick reflected light term.\n    // Microfacet distribution... Most dominant term.\n    float D = D_GGX(nh, rough); \n    // Geometry self shadowing term.\n    float G = G_Smith(nv, nl, rough); \n    // Combining the terms above.\n    vec3 spec = F*D*G/(4.*max(nv, .001));\n\n\n    // Diffuse calculations.\n    vec3 diff = vec3(nl);\n    diff *= 1. - F; // If not specular, use as diffuse (optional).\n    diff *= (1. - type); // No diffuse for metals.\n\n\n    // Combining diffuse and specular.\n    // You could specify a specular color, multiply it by the base\n    // color, or multiply by a constant. It's up to you.\n    return (col*diff + spCol*spec*PI);\n  \n}\n////////////////////\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\n// Texture sample.\nvec4 tx(vec2 uv){ \n    uv = mod(uv, GRID_SIZE);\n    return texelFetch(iChannel0, ivec2(uv), 0);\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord){\n\n    \n    // Reject any pixels outside the wrapping area to lessen the GPU load.\n    // By the way, if this line causes anyone any problems, let me know \n    // and I'll take it out.\n    if(fragCoord.x>GRID_SIZE || fragCoord.y>GRID_SIZE) return;\n\n    // The wrapped pixel position. Technically, the wrapping isn't needed \n    // on account of the line above, but I'll leave it in for completeness.\n    vec2 ip = mod(floor(fragCoord), GRID_SIZE);\n\n    \n    // This is a deliberate time delay, just to show the process.\n    // It's not actually needed, but it's fun to see things play out.\n    if(mod(floor(iTime*160.), 8.)>.5){\n        \n       fragColor = tx(ip);\n       return;\n    } \n    \n    \n    // If we're on the first frame or the texture hasn't loaded initialize\n    // the pixel grid. Also do the same on a mouse-down event.\n    if(textureSize(iChannel0, 0).x<2 || iFrame==0 || iMouse.z>0.){\n        \n        // Zero out the pixel. \n        vec4 a = vec4(0);\n        \n        // Forcing more non-empty single cells. Ie. More 1x1 monomino squares.\n        // The number is non zero, so won't be included in the domino logic \n        // below, but will convert to zero (no joiner edges) when cast to \n        // an integer.\n        if(hash21(ip + .11)<.15) a.x = .01;\n  \n        // Position based ID.\n        a.y = (ip.y*GRID_SIZE + ip.x); ///(GRID_SIZE*GRID_SIZE);\n\n        // Save.\n        fragColor = a;\n        \n    }\n    else {\n        \n        // Obtain the current stored cell states.\n        vec4 a = tx(ip);  \n        \n        // Obtain the random direction for this pixel at this point in time.\n        vec2 dir = rndDir(vec3(ip, iFrame)); \n        // Use the random direction above to move to the neighbor in that direction,\n        // then obtain the random direction for that cell... That was a bit wordy,\n        // but a lot of this stuff depends on understanding it.\n        vec2 dirNgbr = rndDir(vec3(mod(ip + dir, GRID_SIZE), iFrame)); //iResolution.y\n        // Obtain the cell information for that neighbor as well.\n        vec4 colNgbr = tx(mod(ip + dir, GRID_SIZE));\n    \n        // Set the direction. Values 1, 2, 3 or 4. We're deliberately skipping\n        // over zero, which is used for inactive pixels.\n        float dirIndex = dirToIndex(dir) + 1.;\n        \n        \n        // If the current cell and neighboring cell are empty and each have links\n        // pointing toward one another add the link.\n        if(a.x==0. && colNgbr.x==0. && dir == -dirNgbr) a.x = dirIndex; \n        \n        // Save.\n        fragColor = a;\n    }\n}","name":"Buffer A","description":"","type":"buffer"}]}