{"ver":"0.1","info":{"id":"MXt3RB","date":"1716705760","viewed":36,"name":"zig_zag_spherized","username":"graygoose","description":"fun","likes":2,"published":1,"flags":32,"usePreview":0,"tags":["fractal","space","iteration","newton","metric","newtons"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Fork of \"8AB - spherized\" by graygoose. https://shadertoy.com/view/dsyXDG\n// 2024-05-26 06:42:02\n\n\n#define PI 3.14159265359\n#define TAU 6.283185307179586\n#define MAX_ITERS 128\n#define SPHERE_EPS .00001\n\nvec3 sphereMapping(vec3 dir, float iter) {\n  vec2 uv = vec2(atan(dir.z, dir.x), asin(dir.y));\n  uv /= TAU;\n  uv += .5;\n  \n  float displacement = iter / float(MAX_ITERS);\n  vec3 normal = normalize(dir);\n  vec3 perturbation = displacement * normal;\n  \n  float maxDisplacement = length(normal);\n  perturbation *= min(0., maxDisplacement / length(perturbation));\n  \n  return texture(iChannel0, uv).rgb / (1.+perturbation);\n}\n\nvoid mainImage(out vec4 O, in vec2 U) {\n  vec2 z = ( 3.25 * U - iResolution.xy ) / iResolution.y - vec2(1.,.75);\n  \n  float t = iTime;\n  \n  vec3 rayDir = normalize(vec3(z, -1.0));\n  vec3 rayPos = vec3(0.0, 0.0, 1.25);\n\n  float dist = 0.0;\n  vec3 color = vec3(0.0);\n  for (int i = 0; i < MAX_ITERS; i++) {\n    vec3 pos = rayPos + dist * rayDir;\n    vec3 normal = normalize(pos);\n    vec3 sm = sphereMapping(normal, float(i));\n    float smd = dot(sm, sm);\n    float d = length(pos) - 1.0 + 0.2 * smd;  \n    if (d < SPHERE_EPS) {\n      color = sm;\n      break;\n    } \n    dist += d;\n    if (dist > 10.0) break;\n  }\n\n  O = normalize(vec4(8.*color, 1.0));\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"\n\n#define SCALE(v, mx, a, b) (a + (v * (b - a) / mx))\nvec2 scale(vec2 mn, vec2 mx, mat2 bounds) {\n    return vec2(SCALE(mn.x, mx.x, bounds[0][0], bounds[0][1]),\n                SCALE(mn.y, mx.y, bounds[1][0], bounds[1][1]));\n}\n\nvec3 hueShift(vec3 color, float hue) {\n    const vec3 k = vec3(0.57735, 0.57735, 0.57735);\n    float cosAngle = cos(hue);\n    return vec3(color * cosAngle + cross(k, color) * sin(hue) + k * dot(k, color) * (1.0 - cosAngle));\n}\n\n    // screen\nvec2 wrap(in vec2 p, in vec2 res) {\n    if (p.x > res.x) p.x = mod(p.x, res.x);\n    else if (p.x < 0.) p.x = res.x + p.x;\n    \n    if (p.y > res.y) p.y = mod(p.y, res.y);\n    else if (p.y < 0.) p.y = res.y + p.y;\n    \n    return p;\n}\n\n// math\n    //Generic 3x3 filter - vec3(center, edges, diagonals)\n#define GAUSSIAN vec3(.204, .124, .075)\n#define LAPLACIAN vec3(-1., .2, .05)\nvec4 filter3x3(in vec2 pos, in vec3 kernel, in sampler2D channel, in vec2 reso) {\n    vec4 sum = vec4(0.);\n    \n    for(int i=-1; i<=1; i++) {\n        for(int j=-1; j<=1; j++) {\n            float weight = (i==0 && j==0) ? kernel[0] : (abs(i-j) == 1 ? kernel[1] : kernel[2]);\n            \n            sum += weight * texelFetch(channel, ivec2(wrap(pos + vec2(i, j), reso)), 0);\n        }\n    }\n    \n    return sum;\n}\n\n\n    // Sobel\n#define SOBEL_EDGE_COLOR vec4(0.753,0.380,0.796,1.)\nvec4 sobel(in vec2 pos, in sampler2D channel, in vec2 reso) {\n    // \n    mat3 SX = mat3( 1.0,  2.0,  1.0, \n                    0.0,  0.0,  0.0, \n                   -1.0, -2.0, -1.0);\n    mat3 SY = mat3(1.0, 0.0, -1.0, \n                   2.0, 0.0, -2.0, \n                   1.0, 0.0, -1.0);\n\n    vec4 T = texelFetch(channel, ivec2(pos), 0);\n\n    mat3 M = mat3(0.);\n    for(int i=0; i<3; i++) {\n        for(int j=0; j<3; j++) {\n            vec4 A = texelFetch(channel, ivec2(pos + vec2(i-1, j-1)), 0);\n            M[i][j] = length(A);\n        }\n    }\n    \n    float gx = dot(SX[0], M[0]) + dot(SX[1], M[1]) + dot(SX[2], M[2]);\n    float gy = dot(SY[0], M[0]) + dot(SY[1], M[1]) + dot(SY[2], M[2]);\n    \n    \n    // TODO factor into float sobel() and move this to a buffer pass.\n    float g = sqrt(gx*gx + gy*gy);\n    g = smoothstep(0.15, 0.98, g);\n\n    return mix(T, SOBEL_EDGE_COLOR, g);\n}\n\n// have to deal with this / scaling issue w/ color\n#define ERROR 0.01\n\n// Taken from http://lolengine.net/blog/2013/07/27/rgb-to-hsv-in-glsl.\n// All components are in the range [0…1], including hue.\nvec3 rgb2hsv(vec3 c){\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n// All components are in the range [0…1], including hue.\nvec3 hsv2rgb(vec3 c){\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nfloat scale(float v, float mx, float a, float b) {\n    return a + (v * (b - a) / mx);\n}\n\nvec2 scale(vec2 v, float mx, float a, float b){\n    return vec2(scale(v.x, mx, a, b), scale(v.y, mx, a, b));\n}\n\nvec3 scale(vec3 v, float mx, float a, float b){\n    return vec3(scale(v.xy, mx, a, b), scale(v.z, mx, a, b));\n}\n\nfloat hash(float n){ return fract(sin(n)*136.5453123); }\n\n// based on https://github.com/rust-num/num-complex/blob/master/src/lib.rs\n// Copyright 2013 The Rust Project Developers. MIT license\n// Ported to GLSL by Andrei Kashcha (github.com/anvaka), available under MIT license as well.\n// Extended by Grayson Miller 2020, MIT License\nvec2 c_one() { return vec2(1., 0.); }\nvec2 c_i() { return vec2(0., 1.); }\n\nfloat c_magsqrd(vec2 c) { \n    return c.x * c.x + c.y * c.y; \n}\n\nfloat arg(vec2 c) {\n  return atan(c.y, c.x);\n}\n\nvec2 c_conj(vec2 c) {\n  return vec2(c.x, -c.y);\n}\n\nvec2 c_from_polar(float r, float theta) {\n  return vec2(r * cos(theta), r * sin(theta));\n}\n\nvec2 c_to_polar(vec2 c) {\n  return vec2(length(c), atan(c.y, c.x));\n}\n\n/// Computes `e^(c)`, where `e` is the base of the natural logarithm.\nvec2 c_exp(vec2 c) {\n  return c_from_polar(exp(c.x), c.y);\n}\n\n\n/// Raises a floating point number to the complex power `c`.\nvec2 c_exp(float base, vec2 c) {\n  return c_from_polar(pow(base, c.x), c.y * log(base));\n}\n\n/// Computes the principal value of natural logarithm of `c`.\nvec2 c_ln(vec2 c) {\n  vec2 polar = c_to_polar(c);\n  return vec2(log(polar.x), polar.y);\n}\n\n/// Returns the logarithm of `c` with respect to an arbitrary base.\nvec2 c_log(vec2 c, float base) {\n  vec2 polar = c_to_polar(c);\n  return vec2(log(polar.r), polar.y) / log(base);\n}\n\nvec2 c_sqrt(vec2 c) {\n  vec2 p = c_to_polar(c);\n  return c_from_polar(sqrt(p.x), p.y/2.);\n}\n\n/// Raises `c` to a floating point power `e`.\nvec2 c_pow(vec2 c, float e) {\n  vec2 p = c_to_polar(c);\n  return c_from_polar(pow(p.x, e), p.y*e);\n}\n\n/// Raises `c` to a complex power `e`.\nvec2 c_pow(vec2 c, vec2 e) {\n  vec2 polar = c_to_polar(c);\n  return c_from_polar(\n     pow(polar.x, e.x) * exp(-e.y * polar.y),\n     e.x * polar.y + e.y * log(polar.x)\n  );\n}\n\nvec2 c_mul(vec2 self, vec2 other) {\n    return vec2(self.x * other.x - self.y * other.y, \n                self.x * other.y + self.y * other.x);\n}\n\nvec2 c_div(vec2 self, vec2 other) {\n    float norm = length(other);\n    return vec2(self.x * other.x + self.y * other.y,\n                self.y * other.x - self.x * other.y)/(norm * norm);\n}\n\nvec2 c_sin(vec2 c) {\n  return vec2(sin(c.x) * cosh(c.y), cos(c.x) * sinh(c.y));\n}\n\nvec2 c_cos(vec2 c) {\n  // formula: cos(a + bi) = cos(a)cosh(b) - i*sin(a)sinh(b)\n  return vec2(cos(c.x) * cosh(c.y), -sin(c.x) * sinh(c.y));\n}\n\nvec2 c_tan(vec2 c) {\n  vec2 c2 = 2. * c;\n  return vec2(sin(c2.x), sinh(c2.y))/(cos(c2.x) + cosh(c2.y));\n}\n\nvec2 c_atan(vec2 c) {\n  // formula: arctan(z) = (ln(1+iz) - ln(1-iz))/(2i)\n  vec2 i = c_i();\n  vec2 one = c_one();\n  vec2 two = one + one;\n  if (c == i) {\n    return vec2(0., 1./1e-10);\n  } else if (c == -i) {\n    return vec2(0., -1./1e-10);\n  }\n\n  return c_div(\n    c_ln(one + c_mul(i, c)) - c_ln(one - c_mul(i, c)),\n    c_mul(two, i)\n  );\n}\n\nvec2 c_asin(vec2 c) {\n // formula: arcsin(z) = -i ln(sqrt(1-z^2) + iz)\n  vec2 i = c_i(); vec2 one = c_one();\n  return c_mul(-i, c_ln(\n    c_sqrt(c_one() - c_mul(c, c)) + c_mul(i, c)\n  ));\n}\n\nvec2 c_acos(vec2 c) {\n  // formula: arccos(z) = -i ln(i sqrt(1-z^2) + z)\n  vec2 i = c_i();\n\n  return c_mul(-i, c_ln(\n    c_mul(i, c_sqrt(c_one() - c_mul(c, c))) + c\n  ));\n}\n\nvec2 c_sinh(vec2 c) {\n  return vec2(sinh(c.x) * cos(c.y), cosh(c.x) * sin(c.y));\n}\n\nvec2 c_cosh(vec2 c) {\n  return vec2(cosh(c.x) * cos(c.y), sinh(c.x) * sin(c.y));\n}\n\nvec2 c_tanh(vec2 c) {\n  vec2 c2 = 2. * c;\n  return vec2(sinh(c2.x), sin(c2.y))/(cosh(c2.x) + cos(c2.y));\n}\n\nvec2 c_asinh(vec2 c) {\n  // formula: arcsinh(z) = ln(z + sqrt(1+z^2))\n  vec2 one = c_one();\n  return c_ln(c + c_sqrt(one + c_mul(c, c)));\n}\n\nvec2 c_acosh(vec2 c) {\n  // formula: arccosh(z) = 2 ln(sqrt((z+1)/2) + sqrt((z-1)/2))\n  vec2 one = c_one();\n  vec2 two = one + one;\n  return c_mul(two,\n      c_ln(\n        c_sqrt(c_div((c + one), two)) + c_sqrt(c_div((c - one), two))\n      ));\n}\n\nvec2 c_atanh(vec2 c) {\n  // formula: arctanh(z) = (ln(1+z) - ln(1-z))/2\n  vec2 one = c_one();\n  vec2 two = one + one;\n  if (c == one) {\n      return vec2(1./1e-10, vec2(0.));\n  } else if (c == -one) {\n      return vec2(-1./1e-10, vec2(0.));\n  }\n  return c_div(c_ln(one + c) - c_ln(one - c), two);\n}\n\n// Attempts to identify the gaussian integer whose product with `modulus`\n// is closest to `c`\nvec2 c_rem(vec2 c, vec2 modulus) {\n  vec2 c0 = c_div(c, modulus);\n  // This is the gaussian integer corresponding to the true ratio\n  // rounded towards zero.\n  vec2 c1 = vec2(c0.x - mod(c0.x, 1.), c0.y - mod(c0.y, 1.));\n  return c - c_mul(modulus, c1);\n}\n\nvec2 c_inv(vec2 c) {\n  float norm = length(c);\n\treturn vec2(c.x, -c.y) / (norm * norm);\n}\n\nvec2 c_recip(vec2 z){\n    float div_r = 1. / c_magsqrd(z);\n    vec2 result = c_conj(z) * div_r;\n    return result;\n}\n\n//\n//\n\nvec3 draw_point(vec3 col, vec2 pos, vec2 pt, float r){\n    return c_magsqrd(pos - pt) < r ? vec3(1) : col;\n}","name":"Common","description":"","type":"common"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define MAX_ITER 5\n\nvec3 getColor(vec3 c) {\n    float r = sin(c.x * 10.0 + iTime * 0.1) * 0.5 + 0.5;\n    float g = cos(c.y * 10.0 + iTime * 0.2) * 0.5 + 0.5;\n    float b = sin(c.z * 10.0 + iTime * 0.3) * 0.5 + 0.5;\n    return vec3(r, g, b);\n}\nvec2 rotate(vec2 p, float a) {\n    float s = sin(a);\n    float c = cos(a);\n    return vec2(p.x*c - p.y*s, p.x*s + p.y*c);\n}\n\nvec3 fractalFlame(vec2 p, float time) {\n    vec2 c = vec2(sin(time), cos(time)) * 0.5;\n    float a = time * 1.;\n    float scale = 20.0;\n    float weight = 0.5;\n    vec3 sum = vec3(0.0);\n    for (int i = 0; i < MAX_ITER; i++) {\n        p *= scale;\n        p = rotate(p, a);\n        p += c;\n        if (p.x < 0.0) p.x = -p.x;\n        if (p.y < 0.0) p.y = -p.y;\n        if (p.x > 1.0) p.x = 2.0 - p.x;\n        if (p.y > 1.0) p.y = 2.0 - p.y;\n        vec2 q = vec2(p.x - 0.5, p.y - 0.5);\n        float r = length(q);\n        float a = atan(q.y, q.x) + 2.0 * time;\n        vec2 s = vec2(cos(a), sin(a)) * r;\n        vec2 t = vec2(cos(a * 2.0), sin(a * 2.0)) * r * 0.5;\n        vec3 val = vec3(sin(s.x), cos(t.y), sin(s.y + t.x));\n        sum += weight * val;\n        weight *= 0.5*cos(iTime*.01);\n        scale *= 10.*sin(iTime*.01);\n    }\n    return sum / float(MAX_ITER);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord.xy / iResolution.xy) * .5 - .25;\n    float time = iTime * 0.1;\n    vec3 value = fractalFlame(uv, time);\n    fragColor = vec4(getColor(value), 1.0);\n}\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"void mainImage( out vec4 O, in vec2 fragCoord )\n{\n    vec4 C0 = texelFetch(iChannel0, ivec2(fragCoord.xy), 0);\n    vec4 C1 = texelFetch(iChannel1, ivec2(fragCoord.xy), 0);\n    vec4 G0 = filter3x3(fragCoord.xy, GAUSSIAN, iChannel0, iResolution.xy);\n    vec4 G1 = filter3x3(fragCoord.xy, GAUSSIAN, iChannel1, iResolution.xy);\n    \n    O = .5*(C0+G0) + .5*(G1+C1);\n    O *= 0.5;\n\n    \n}","name":"Buffer B","description":"","type":"buffer"}]}