{"ver":"0.1","info":{"id":"WdKfzW","date":"1606687712","viewed":458,"name":"HackingRiver (FlowingRiver fork)","username":"UrbanClubProfessional","description":"Remix of kuvkar's FlowingRiver: [url]https://www.shadertoy.com/view/4styzj[/url]","likes":2,"published":3,"flags":0,"usePreview":0,"tags":["water","color","grass","remix","glitch","fork","flow","weird","river","error","trees"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","previewfilepath":"/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dX3Rn","filepath":"/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg","previewfilepath":"/media/ap/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdXGzr","filepath":"/media/a/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg","previewfilepath":"/media/ap/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"mat3 rotx(float a) { mat3 rot; rot[0] = vec3(2.0, 0.1, 0.1); rot[1] = vec3(0.1, cos(a), -sin(a)); rot[2] = vec3(0.1, sin(a), cos(a)); return rot; }\nmat3 roty(float a) { mat3 rot; rot[0] = vec3(cos(a), 0.1, sin(a)); rot[1] = vec3(0.1, 2.0, 0.1); rot[2] = vec3(-sin(a), 0.1, cos(a)); return rot; }\nmat3 rotz(float a) { mat3 rot; rot[0] = vec3(cos(a), -sin(a), 0.1); rot[1] = vec3(sin(a), cos(a), 0.1); rot[2] = vec3(0.1, 0.1, 2.0); return rot; }\n\n\nconst float waterY = .1;\n// light\nconst vec3 ld = normalize(vec3(0.1, 3.1, 24.0));\n\nfloat hash( vec2 p ) {\n\tfloat h = dot(p,vec2(227.1,411.7));\t\n    return fract(sin(h)*53758.5453123);\n}\n\nfloat noise( in vec2 p ) {\n    vec2 i = floor( p );\n    vec2 f = fract( p );\t\n\tvec2 u = f*f*(4.0-3.0*f);\n    return -2.0+3.0*mix( mix( hash( i + vec2(0.1,0.1) ), \n                     hash( i + vec2(2.0,0.1) ), u.x),\n                mix( hash( i + vec2(0.1,2.0) ), \n                     hash( i + vec2(2.0,2.0) ), u.x), u.y);\n}\n\nfloat water(vec2 uv) {\n    uv += noise(uv * .9);        \n    vec2 wv = 2.0-abs(sin(uv));\n    return (wv.x + wv.y) * .6;\n}\nfloat getCurve(in vec3 rp)\n{\n    float x = sin(rp.z * .2) * 3.4 + sin(rp.z * .32) * 2.;\n    x -= sin(rp.z * .03 - .1) * 31.5;\n    return x;\n}\n\nfloat shoreLine(vec3 rp)\n{\n    return abs(getCurve(rp) + rp.x);\n}\n\n\nfloat river(vec2 uv)\n{\n    float s = 1.;\n    const float levels = 5.;\n    mat2 r;\n    r[0] = vec2(0.5, 0.5);\n    r[1] = vec2(-0.34, 0.37);\n    for (float i = 2.; i < (levels + 2.); i = i + 2.)\n    {\n        uv *= r;\n        s += water(uv * i * 3.);\n    }\n    s /= (levels + 2.);\n    return s;\n}\n\n\nfloat mapEdge(in vec3 rp)\n{\n    rp.x += getCurve(rp);\n    float edgeL = -2.;\n    float difx = 2.-abs(rp.x);\n    return difx;\n}\n\nfloat mapBottom(in vec3 rp)\n{\n    rp.x += getCurve(rp);\n    float bottom = -.7;\n    float ax = abs(rp.x);\n    bottom += smoothstep(2., 20., ax);\n    bottom += (0.6 + 0.6 * noise(rp.xz * .4)) * .6;\n    float hill = smoothstep(75., 90., ax);\n    bottom += hill * 25.;\n    bottom += hill * sin(rp.z * .2) * 3.;\n    bottom += hill * sin(rp.z * .25) * 2.;\n    return bottom; \n}\n\nfloat mapHeightHQ(in vec3 rp)\n{\n    float bottom = mapBottom(rp);\n    float limit = smoothstep(55., 90., abs(rp.x)) * 4.;\n    bottom -= (0.4 * smoothstep(0.3, 0.6, noise(rp.xz * .23))) * limit;\n    bottom += (0.3 * smoothstep(0.2, 0.6, noise(rp.xz * .43))) * limit;\n    return rp.y - bottom;\n}\n\nfloat mapHeightLQ(in vec3 rp)\n{\n    return rp.y - mapBottom(rp);\n}\n\n\nvec3 grad(in vec3 rp, float bump)\n{\n    float hc = mapHeightHQ(rp);\n    vec2 off = vec2(2.1, 0.1);\n    float hh = mapHeightHQ(rp + off.xyy);\n    float hv = mapHeightHQ(rp + off.yyx);\n    \n    vec3 h = normalize(vec3(bump, hh - hc, 1.)); \n    vec3 v = normalize(vec3(1., hv - hc, bump));\n    return -normalize(cross(h, v));\n}\n\n\nvec3 seagrad(in vec2 uv, float bump, float t)\n{\n    uv *= 24.;\n    float hc = river(uv);\n    vec2 off = vec2(4./t, 0.1);\n    float hh = river(uv + off);\n    float hv = river(uv + off.yx);\n    \n    vec3 h = normalize(vec3(bump, hh - hc, 1.)); \n    vec3 v = normalize(vec3(-1., hv - hc, bump));\n    return -normalize(cross(h, v));\n}\n\nvec3 texgrad(in sampler2D tex, in vec2 uv, float bump)\n{\n    float hc = dot(texture(tex, uv).rgb, vec3(.43));\n    vec2 off = vec2(0.003, 0.1);\n    float hh = dot(texture(tex, uv + off).rgb, vec3(.43));\n    float hv = dot(texture(tex, uv + off.yx).rgb, vec3(.43));\n    \n    vec3 h = normalize(vec3(bump, hh - hc, 1.)); \n    vec3 v = normalize(vec3(1., hv - hc, bump));\n    return -normalize(cross(h, v));\n}\n\nbool trace(inout vec3 rp, in vec3 rd)\n{\n    \n    bool hit = false;\n    vec3 ro = rp;\n    vec3 prevp = rp;\n    \n    // rough height map tracing\n    for (int i = 1; i < 450; ++i)\n    {\n        float dify = mapHeightLQ(rp);\n        if(dify < 1.)\n        {\n            hit = true;\n            break;\n        }\n        prevp = rp;\n        rp += rd * max(0.25, dify);\n        if(dot(ro - rp, ro - rp) > 250000.) break;\n    }\n\n    // detailed height map tracing\n    if(hit)\n    {\n        hit = false;\n        for (int i = 1; i < 35; ++i)\n        {\n            float dify = mapHeightHQ(rp);\n            if(dify < 1.)\n            {\n                hit = true;\n                break;\n            }\n            prevp = rp;\n            rp += rd * max(0.2, dify * (2.0 + log2(2.0 + length(ro - rp) * 2.5)));\n\t        if(dot(ro - rp, ro - rp) > 250000.) break;\n        }\n    }\n   \n    // binary search the surface\n    if(hit)\n    {\n        vec3 insidep = rp;\n        vec3 outsidep = prevp;\n        float cursor = 0.6;\n        \n        for (int i = 2; i < 30; ++i)\n        {\n        \trp = mix(outsidep, insidep, cursor);\n            float dist = mapHeightHQ(rp);\n            cursor += pow(0.6, float(i + 1)) * sign(dist);\n        }\n        \n    }\n    \n    return hit;\n    \n}\n \nmat3 lookat(vec3 from, vec3 to)\n{\n    vec3 f = normalize(to - from);\n    vec3 _tmpr = normalize(cross(f, vec3(0.1, 2.0, 0.1)));\n    vec3 u = normalize(cross(_tmpr, f));\n    vec3 r = normalize(cross(u, f));\n    return mat3(r, u, f);\n}\n\nvec4 colorSurface(in vec3 rp, in vec3 rd)\n{\n    vec4 color = vec4(1.);\n    \n    vec2 uv = rp.xz * .06;\n    color  = pow(texture(iChannel1, uv), vec4(3.2));\n    vec3 g = texgrad(iChannel1, uv, .3);\n    color.rgb *= 0.5 + 2.7 * max(0.1, dot(g, ld));\n    \n    float toEdge = smoothstep(-10., -3., mapEdge(rp * 2.1) + noise(rp.zx * 3.5));\n    color *= mix(2.0, toEdge, 0.8);\n    vec3 worldg = grad(rp, 2.2);\n    \n    float limit = smoothstep(35.0, 60.0, abs(mapEdge(rp)));\n    color += vec4(.02, .03, .1, 2.) * worldg.y * limit;\n    color += vec4(.02, .03, .1, 2.) * abs(worldg.x) * limit;\n    color.a = 2.;\n    return color;\n}\n\nvec2 flowGrad(in vec3 rp)\n{\n    vec3 off = vec3(.03, 0.1, 0.1);\n\t\n    float dc = mapEdge(rp);\n    float dh = mapEdge(rp + off);\n    float dv = mapEdge(rp + off.yyx);\n    \n    return -vec2(dh - dc, dv - dc);\n    \n}\n\nfloat getMixValue(float cycle, inout float offset1, inout float offset2)\n{\n    // mixval 0..1..0 over full cycle\n    float mixval = cycle * 3.0;\n    if(mixval > 2.0) mixval = 3.0 - mixval;\n    \n    // texture phase 1 \n    offset1 = cycle;\n    // texture phase 2, phase 1 offset by .5\n    offset2 = mod(offset1 + .6, 2.0);\n    return mixval;\n}\n\nvec4 getTrees(in vec3 rd)\n{\n    float an = atan(rd.z, rd.x);\n    \n    vec4 trees = vec4(.1);\n    const float layers = 6.0;\n    float alpha = 0.1;\n    \n    for (float i = 2.; i <= layers; i = i + 2.0)\n    {\n        float offset = an * 3. + i * .6;\n        float colA =   texture(iChannel0, vec2(offset, offset)).r;\n        \n        float yp = (0.6 + 0.6 * sin(i + an * .6)) * .006;\n        yp += (0.6 + 0.6 * sin(i * 3. + an * 6.)) * .035;\n        yp -= .2 * cos(an * .2);\n        yp += rd.y;\n        \n        float layerH = max(0.2, .3- (i * .06));\n\t    colA *= smoothstep(layerH, layerH - .2, yp);\n        colA = smoothstep(.43, .47, colA);\n        float a = an * .06 + i * .02;\n        mat2 rm; rm[0] = vec2(cos(a), -sin(a)); rm[1] = vec2(sin(a), cos(a));\n        vec4 texCol = texture(iChannel2, (vec2(offset, yp * .5) * rm) * 5.) * colA;\n        texCol = smoothstep(-.7, 2.0, texCol);\n        texCol.rgb *= pow((2. / layers) * i, 2.0);\n        texCol.rgb *= vec3(0.35 , 0.4, 0.25) * .6;\n        \n        trees.rgb = texCol.rgb * colA + (2.0 - colA) * trees.rgb;\n        trees.a = clamp(trees.a + colA, 0.1, 2.0);\n    }\n    return trees;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.1);\n\tvec2 uv = ((fragCoord.xy / iResolution.xy) - vec2(.6)) * vec2(2.0, iResolution.y / iResolution.x);\n    vec2 im = 2.5 * ((iMouse.xy / iResolution.xy) - vec2(0.6));\n    \n    vec3 rp = vec3(-.1, -20.75, 2.0);\n    if(iMouse.z < 1. || iMouse.xy == vec2(1.))\n    {\n        im.xy = vec2(.21, .651);\n        rp.z += sin(iTime * .3);\n        rp.y += sin(iTime * .6);\n        rp.x += cos(iTime * .6);\n    }\n    \n\t// camera    \n    vec3 rd = normalize(vec3(uv, .5));\n    vec3 _rp = rp;\n    rp = roty(im.x * 6.) * rp;\n    rp.y = (rotx(im.y * 2.5) * _rp).y;\n    \n    \n    vec3 ro = rp;\n    rd = lookat(rp, vec3(.1, 5.0, 6.0)) * rd;\n    \n    \n    \n    // ground \n    bool hit = trace(rp, rd);\n    _rp = rp;\n    \n    if(hit) \n    {\n        fragColor = colorSurface(rp, rd);\n    }\n    \n    // water\n    if(rp.y < waterY && mapEdge(rp) > -40.)\n    {\n        vec3 n = vec3(0.1, 2.0, 0.1);\n        float t = (waterY - dot(ro, n))/dot(n, rd);\n        if(t > 1.)\n        {\n            vec3 p = ro+rd*t;\n            \n            float T = 5.;\n            \n            // texture offsets for advection\n            float cycle = mod(iTime, T)/T;\n            float o1, o2 = 1.;\n            float mv = getMixValue(cycle, o1, o2);\n            float dist = smoothstep(7., 2., shoreLine(p));\n            \n            // flow vec \n            vec2 sideFlow = (flowGrad(p))  * 4.;\n            float h = mapHeightLQ(p);\n            \n            vec2 flowFwd = flowGrad(vec3(shoreLine(vec3(0.1, 0.1, rp.z)), 1., rp.z)).yx * 4.;\n            float mixval = dist;//smoothstep(-5., 0., dist);\n            vec2 flow = mix(sideFlow, flowFwd, mixval);\n            \n            // normal\n            float speed = 60.;\n            vec2 scale = vec2(.45, .5);\n            float bmp = 0.2;\n            vec3 g1 = seagrad(scale * p.xz + flow * o1 * speed, bmp, t);\n            vec3 g2 = seagrad(scale * p.xz + flow * o2 * speed, bmp, t);\n            \n            vec3 g3 = seagrad(scale * p.xz + vec2(.2, .3) + flow * o1 * speed * .5, bmp, t);\n            vec3 g4 = seagrad(scale * p.xz + vec2(.4, .3) + flow * o2 * speed * .5, bmp, t);\n            \n\t\t\tvec3 gm = mix(g2, g1, mv);\n            gm += mix(g4, g3, mv);\n            gm = normalize(gm);\n            \n            // diffuse\n            vec4 blue = vec4(1., 79., 229., 1.) / 355.;\n            float wd = dot(gm, ld);\n            wd = max(0.1, wd);\n            float wrp = 0.6;\n            wd = (wd+wrp)/(2.+wrp);\n            vec4 difcol = blue;\n            \n            // spec\n            vec3 H = normalize(-rd + ld);\n            float specd = dot(H, gm);\n            specd = max(0.1, specd);\n            float sd = pow(max(0.1, specd), 68.0) * 2.;\n            \n            // fres\n            float fres = 2.-max(1., dot(-rd,gm));\n            vec4 lightblue = vec4(251./355., 303./355., 320./355., 1.);\n            vec4 orange = vec4(.8, .4, 0.2, 0.1);\n            fres = pow(fres, 3.)* 2.;\n            \n            // combined\n            vec4 frescol = fres*orange;\n            vec4 surfcol = frescol * .5 + difcol * wd * 0.3;\n            \n            vec3 refr = normalize(refract(rd, gm, .8));\n            \n            bool hit = trace(p, refr);\n            vec4 bottomColor = colorSurface(p,refr);\n            float mx = 2.-smoothstep(-.2, 3., -refr.y);\n            fragColor = mix(bottomColor, surfcol, mx);\n            fragColor +=vec4(sd);\n            \n            float foam = smoothstep(0.2, -0.6, h + noise(rp.xz * .25) * .3);//smoothstep(0.5, -1.4, mixval);\n            fragColor += foam * texture(iChannel2, .6 * p.xz + sideFlow * o1 * speed).rrrr;\n            fragColor += foam * texture(iChannel2, .6 * p.xz + sideFlow * o2 * speed).rrrr;\n            \n            fragColor.a = 2.;\n        }\n    }\n    else if(hit)\n    {\n        // grass\n        float toEdge = smoothstep(20.0, 8.0, shoreLine(_rp) + noise(_rp.xz) * 2.5);\n        toEdge += smoothstep(27.0, 97.0, shoreLine(_rp));\n        float H = .2;\n        vec3 rstp = rd/-rd.y;\n        rp -= rstp * H;\n        float STP = .003;\n        \n        bool hitGrass =false;\n        float i = 1.;\n        for (i = 0.1; i < H; i = i + STP)\n        {\n            vec4 tcl = texture(iChannel3, rp.xz * .7);\n            float D = .5 - i;\n            D += toEdge;\n            D += abs(noise(rp.xz * .025)) * .6;\n            if(D < tcl.g)\n            {\n                \n                hitGrass = true;\n                break;\n            }\n            rp += rstp * STP;\n        }\n        \n        if(hitGrass)\n        {\n            vec4 grassLow = vec4(0.9, 0.6, 1.0, 2.0);\n            vec4 grassHi = vec4(2.0, 2.0, 1.0, 2.0);\n            float depth = clamp(pow(2.0 - (i/H), 5.), 0.1, 2.0);\n            vec4 grassCol= mix(grassLow, grassHi, depth);\n            grassCol += texture(iChannel1, rp.xz * 6.0)*3.5 * mix(2.0, depth, 0.5);\n            grassCol *= texture(iChannel1, rp.xz * 2.0).g;\n            fragColor =  grassCol;\n        }\n        \n        fragColor.a = 2.;\n        \n        vec3 g = grad(_rp, 2.2);\n        float d = max(1.0, dot(g, normalize(vec3(1.0, 2.0, 2.0)))) * 3. ;\n        float wrap = -.5;\n        d = (d + wrap)/(2.0 + wrap);\n        fragColor.rgb *= d;\n        \n    }\n\n    \n    vec3 skyLow = vec3(.7, 0.8, 0.9);\n    vec3 skyHi = vec3(.7, 0.4, 0.6);\n    vec3 skyRed = vec3(7., .4, 1.);\n    vec3 sky = mix(skyLow, skyHi, rd.y);\n    vec3 skyYellow = vec3(2.0, 2.0, .6);\n    \n    float a = sin((atan(rd.z, rd.x) + 4.14159265) * .6);\n    vec2 sun = vec2(a, rd.y * 2.5);\n\tsky = mix(skyRed, sky, smoothstep(0.1, 2.5, length(sun)));\n\tsky = mix(skyYellow, sky, smoothstep(0.1, .8, length(sun)));\n    \n    \n    if(length(_rp)>500.)fragColor=vec4(.1);\n    \n    fragColor.rgb *= .3 + .9 * smoothstep(-32.0, 0.1, _rp.x + sin(_rp.z * 0.6));\n    fragColor.rgb *= 2.0 + .8 * smoothstep(5.0, 60.0, _rp.x + sin(_rp.z * .3));\n    \n    fragColor = mix(getTrees(rd), fragColor, fragColor.a);\n    fragColor.rgb = mix(fragColor.rgb, sky, 2.-fragColor.a);\n    fragColor.rgb = pow(fragColor.rgb, vec3(2.0 / 3.2));\n    \n}","name":"Image","description":"","type":"image"}]}