{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[{"channel":0,"type":"video","id":"4sX3Rn","filepath":"/media/a/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"code":"// The MIT License\n// Copyright Â© 2013 Javier Meseguer\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n#define BLACK_AND_WHITE\n#define LINES_AND_FLICKER\n#define BLOTCHES\n#define GRAIN\n\n#define FREQUENCY 15.0\n\nvec2 uv;\n\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat rand(float c){\n\treturn rand(vec2(c,1.0));\n}\n\nfloat randomLine(float seed)\n{\n\tfloat b = 0.01 * rand(seed);\n\tfloat a = rand(seed+1.0);\n\tfloat c = rand(seed+2.0) - 0.5;\n\tfloat mu = rand(seed+3.0);\n\t\n\tfloat l = 1.0;\n\t\n\tif ( mu > 0.2)\n\t\tl = pow(  abs(a * uv.x + b * uv.y + c ), 1.0/8.0 );\n\telse\n\t\tl = 2.0 - pow( abs(a * uv.x + b * uv.y + c), 1.0/8.0 );\t\t\t\t\n\t\n\treturn mix(0.5, 1.0, l);\n}\n\n// Generate some blotches.\nfloat randomBlotch(float seed)\n{\n\tfloat x = rand(seed);\n\tfloat y = rand(seed+1.0);\n\tfloat s = 0.01 * rand(seed+2.0);\n\t\n\tvec2 p = vec2(x,y) - uv;\n\tp.x *= iResolution.x / iResolution.y;\n\tfloat a = atan(p.y,p.x);\n\tfloat v = 1.0;\n\tfloat ss = s*s * (sin(6.2831*a*x)*0.1 + 1.0);\n\t\n\tif ( dot(p,p) < ss ) v = 0.2;\n\telse\n\t\tv = pow(dot(p,p) - ss, 1.0/16.0);\n\t\n\treturn mix(0.3 + 0.2 * (1.0 - (s / 0.02)), 1.0, v);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tuv = fragCoord.xy / iResolution.xy;\n\t\n\tif ( iMouse.z < 0.9 )\n\t{\t\t\n\t\t// Set frequency of global effect to 15 variations per second\n\t\tfloat t = float(int(iTime * FREQUENCY));\n\t\t\n\t\t// Get some image movement\n\t\tvec2 suv = uv + 0.002 * vec2( rand(t), rand(t + 23.0));\n\t\t\n\t\t// Get the image\n\t\tvec3 image = texture( iChannel0, vec2(suv.x, suv.y) ).xyz;\n\t\t\n\t\t#ifdef BLACK_AND_WHITE\n\t\t// Convert it to B/W\n\t\tfloat luma = dot( vec3(0.2126, 0.7152, 0.0722), image );\n\t\tvec3 oldImage = luma * vec3(0.7, 0.7, 0.7);\n\t\t#else\n\t\tvec3 oldImage = image;\n\t\t#endif\n\t\t\n\t\t// Create a time-varying vignetting effect\n\t\tfloat vI = 16.0 * (uv.x * (1.0-uv.x) * uv.y * (1.0-uv.y));\n\t\tvI *= mix( 0.7, 1.0, rand(t + 0.5));\n\t\t\n\t\t// Add additive flicker\n\t\tvI += 1.0 + 0.4 * rand(t+8.);\n\t\t\n\t\t// Add a fixed vignetting (independent of the flicker)\n\t\tvI *= pow(16.0 * uv.x * (1.0-uv.x) * uv.y * (1.0-uv.y), 0.4);\n\t\t\n\t\t// Add some random lines (and some multiplicative flicker. Oh well.)\n\t\t#ifdef LINES_AND_FLICKER\n\t\tint l = int(8.0 * rand(t+7.0));\n\t\t\n\t\tif ( 0 < l ) vI *= randomLine( t+6.0+17.* float(0));\n\t\tif ( 1 < l ) vI *= randomLine( t+6.0+17.* float(1));\n\t\tif ( 2 < l ) vI *= randomLine( t+6.0+17.* float(2));\t\t\n\t\tif ( 3 < l ) vI *= randomLine( t+6.0+17.* float(3));\n\t\tif ( 4 < l ) vI *= randomLine( t+6.0+17.* float(4));\n\t\tif ( 5 < l ) vI *= randomLine( t+6.0+17.* float(5));\n\t\tif ( 6 < l ) vI *= randomLine( t+6.0+17.* float(6));\n\t\tif ( 7 < l ) vI *= randomLine( t+6.0+17.* float(7));\n\t\t\n\t\t#endif\n\t\t\n\t\t// Add some random blotches.\n\t\t#ifdef BLOTCHES\n\t\tint s = int( max(8.0 * rand(t+18.0) -2.0, 0.0 ));\n\n\t\tif ( 0 < s ) vI *= randomBlotch( t+6.0+19.* float(0));\n\t\tif ( 1 < s ) vI *= randomBlotch( t+6.0+19.* float(1));\n\t\tif ( 2 < s ) vI *= randomBlotch( t+6.0+19.* float(2));\n\t\tif ( 3 < s ) vI *= randomBlotch( t+6.0+19.* float(3));\n\t\tif ( 4 < s ) vI *= randomBlotch( t+6.0+19.* float(4));\n\t\tif ( 5 < s ) vI *= randomBlotch( t+6.0+19.* float(5));\n\t\n\t\t#endif\n\t\n\t\t// Show the image modulated by the defects\n        fragColor.xyz = oldImage * vI;\n\t\t\n\t\t// Add some grain (thanks, Jose!)\n\t\t#ifdef GRAIN\n        fragColor.xyz *= (1.0+(rand(uv+t*.01)-.2)*.15);\t\t\n        #endif\t\t\n\t\t\n\t}\n\telse\n\t{\n\t\tfragColor = texture( iChannel0, uv );\n\t}\n\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"Xdl3D8","date":"1368757112","viewed":3903,"name":"Old video","username":"jmpep","description":"Quick and dirty shader to make videos look terribly old. Keep the left mouse button pressed to see the original video.\n\nNot sure whether this shader can be useful, but well, it was fun to do. Any comments are welcome, of course! :)","likes":96,"published":1,"flags":0,"usePreview":0,"tags":["2d","postprocessing","blackandwhite","tv","old","cinema"],"hasliked":0,"parentid":"","parentname":""}}