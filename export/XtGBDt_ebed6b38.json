{"ver":"0.1","info":{"id":"XtGBDt","date":"1547317061","viewed":110,"name":"grid-stochastic","username":"caudya","description":"qwcw","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["grid"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// In GLSL, IEEE 754 infinity can conveniently be achieved by dividing by zero:\nconst float FLT_MAX = 1.0 / 0.0;    \n\n// We can define a structure that will contain the parameters needed\n// by an object to specify its shading according to Phong shading.\nstruct Material\n{\n    float Ka;\t// ambiant        coefficient\n    float Kd;\t// diffuse        coefficient\n    float Ks;\t// specular       coefficient, indice de réfraction\n    float Kn;\t// specular power coefficient\n};\n    \n    // ~ ~ ~ ~ ~ ~ ~ ~ \n        \n// Camera parameters\nvec3\t   cameraPos    = vec3(6,  4, -5);\nconst vec3\t   cameraTarget = vec3(3,  1, -8);\nconst float    cameraFovY   = 90.0;\t\t\t\t// NOTE: angle in degree\n\n// Sky parameters\nconst vec3     skyCol       = vec3(0);\t\t\t// black\nconst int      skyId        = 0;\n\n// Sphere parameters\nvec3 spherePos = cameraTarget + 2.0 * vec3(0.0, 0.0, 1.0) + vec3(0, 1, 0);\nconst float    sphereRadius = 1.0;\nconst vec3     sphereCol    = vec3(1,0,0);\t\t// red\nconst Material sphereMat    = Material(0.2/*Ka*/, 0.7/*Kd*/, 1.0/*Ks*/, 50.0/*Kn*/);\nconst int      sphereId     = 1;\n\n// Plane parameters\nconst vec3     planePos     = vec3(0, 0.1, 0);\nconst vec3     planeNormal  = vec3(0, 1.0, 0);\nconst vec3     planeCol1    = vec3(1.0);\t\t// white\nconst vec3     planeCol2    = vec3(0.4);\t\t// gray\nconst Material planeMat     = Material(0.2/*Ka*/, 1.0/*Kd*/, 0.2/*Ks*/,  5.0/*Kn*/);\nconst int      planeId      = 2;\n\n// Light(s) parameters\nconst vec3     ambiantCol   = vec3(0,0,1);\t\t// blue\nconst vec3     lightCol     = vec3(1,1,1);\t\t// white\nvec3     lightPos     = vec3(8, 10, -12);\n\nconst float eps = 0.01;\n\n\n//value for grid\n\n//boo est vraie alors on prend PIXEL_SAMPLING_GRID_SIZE sinon on choisit PIXEL_SAMPLING_RANDOM \nbool boo = true;\nconst int PIXEL_SAMPLING_GRID_SIZE = 5;\nconst int PIXEL_SAMPLING_RANDOM = 20;\n\n\n\nstruct ShadeInfo\n{\n    vec3 shadedcol;\n    float Ks;\n};\n\nconst int MAX_NB_BOUNCES = 3;\n\n\n    \n//##############################################################################################\n    \n\nfloat raySphere(    vec3 rayPos    ,     vec3 rayDir, vec3 spherePos, float sphereRadius,\n                out vec3 intersecPt, out vec3 normal)\n{\n    \n    vec3 diff = rayPos - spherePos;\n    \n    float a =       dot(rayDir, rayDir);\n    float b = 2.0 * dot(diff  , rayDir);\n    float c =       dot(diff  , diff  ) - sphereRadius * sphereRadius;\n    \n    float di = b*b - 4.0*a*c;\n    \n    if (di >= 0.0)\n    {\n        float sdi = sqrt(di);\n        float den = 1. / (2.0 * a);\n        float t1  = (-b - sdi) * den;\n        float t2  = (-b + sdi) * den;\n \n        float t = -1.0;\n        float dir = 1.0;\n        if (t1 > 0.0)\n        \tt = t1;\n        else if (t2 > 0.0)\n        {\n            t = t2;\n            dir = -1.0;\n        }\n        else\n            return t;\n\n        // As we found the value of t, we can insert it into equation (1) to find\n        // the position of the first intersection point encountered along the ray.\n        intersecPt = rayPos + t * rayDir;\n\n        // Then, we can use the property of a sphere that the infinite line along the\n        // normal vector to a point on the sphere is passing through the center of the\n        // sphere.\n        // Then, we need to reverse the vector direction if the intersection point is\n        // seen from inside the sphere.\n        normal     = normalize(intersecPt - spherePos) * dir;\n        \n        return t;\n    }\n    \n    return -1.0;\n}\n\n//----------------------------------------------------------------------------------------------\n\n// NOTE: planeNormal must be a unit-vector!\nfloat rayPlane(    vec3 rayPos    ,     vec3 rayDir, vec3 planePos, vec3 planeNormal,\n               out vec3 intersecPt, out vec3 normal)\n{\n\n    \n    float den = dot(planeNormal, rayDir);\n    \n    if (abs(den) <= 0.000001)\t// To avoid numerical instabilities we consider the ray to be \n        return -1.0;\t\t\t// parallel if the angle between the normal and the ray is\n        \t\t\t\t\t\t// ALMOST zero.\n        \t\t\t\t\t\n    float t = dot(planeNormal, planePos - rayPos) / den;\n    \n    // As we found the value of t, we can insert it into equation (1) to find\n    // the position of the first intersection point encountered along the ray.\n    intersecPt = rayPos + t * rayDir;\n    \n    // NOTE: The normal to be returned has to be pointing 'towards' the rayPos position.\n    //       So, the angle between the ray direction and the normal must > 90°, so the\n    //       dot-product should be negative.\n    //       This can be expressed by taking the 'sign' of den\n    normal = -sign(den) * planeNormal;\n    \n    return t;\n}\n\n//----------------------------------------------------------------------------------------------\n\nvoid computeCameraRayFromPixel( in vec2 pixCoord, out vec3 rayPos, out vec3 rayDir)\n{\n\n                 \n    float focal = 1.0 / tan(radians(cameraFovY) / 2.0);\n    \n    // Compute camera three main axis (X,Y,Z) expressed in world space\n    //\n    //  NOTES: - First, we compute the Z camera unit vector that goes from the camera position\n    //           and look toward the camera target.\n    \n    vec3 cz = normalize(cameraTarget - cameraPos);\n    \n    \n    vec3 up = vec3(0,1,0);\t\t\t\t\t\t\t// perfect up vector\n    vec3 cx = normalize(cross(-up, cz));\n    \n    //         - Finally, we can find the true cy by applying: cy = cross-product(cz, cx)\n\n    vec3 cy = normalize(cross( cz, cx));\n\n\n    // by the same value: iResolution.y\n    \n    vec2 pt = (2.*pixCoord - iResolution.xy) / iResolution.y;\n\n    //origine du rayon, la caméra\n    rayPos = cameraPos;\n    \n    //direction du rayon\n    rayDir = normalize(pt.x * cx - pt.y * cy + focal * cz);\n}\n\n//----------------------------------------------------------------------------------------------\n\n// trouve l'intersection la plus proche qu'à le rayon avec les objets\nfloat computeNearestIntersection(vec3 rayPos, vec3 rayDir, in int incId,\n                                 out int objectId, out vec3 intersecI, out vec3 normalI)\n{\n    // Set the default value when no intersection is found: we hit the 'sky'\n    float minDist  = FLT_MAX;\n          objectId = skyId;\n    \n    // Test the sphere\n    vec3 intersecS, normalS;\n    float distS = raySphere(rayPos, rayDir, spherePos, sphereRadius, intersecS, normalS);\n    if ((distS > 0.0) && (distS < minDist))\n    {\n        objectId  =  sphereId;\n        minDist   =     distS;\n        intersecI = intersecS;\n          normalI =   normalS;\n    }\n    \n    // Test the plane\n    vec3 intersecP, normalP;\n    float distP =  rayPlane(rayPos, rayDir,  planePos,  planeNormal, intersecP, normalP);\n    if ((distP > 0.0) && (distP < minDist))\n    {\n        objectId  =   planeId;\n        minDist   =     distP;\n\t    intersecI = intersecP;\n    \t  normalI =   normalP;\n    }\n    \n    // To remain coherent with the raySphere & rayPlane function that returns -1 when no\n    // intersetion is found, we add the following two lines:\n    if (objectId == skyId)\n        minDist = -1.0;\n    \n    return minDist;\n}\n\n//----------------------------------------------------------------------------------------------\n\nvec3 getSphereColorAtPoint(vec3 pt)\n{\n    return sphereCol;\n}\n\n//----------------------------------------------------------------------------------------------\n\n// pt is assumed to be on the plane surface\nvec3 getPlaneColorAtPoint(vec3 pt)\n{\n    // As the plane is textured with a checkboard pattern, we need to define\n    // a 'texture coordinate frame'.\n\n\n    vec3 worldX = vec3(1,0,0);\n    vec3 axisX  = normalize(worldX - dot(worldX, planeNormal) * planeNormal);\n    \n    // We then find the plane Y-axis thanks to the cross-product\n    // properties with orthonormal basis\n    vec3 axisY  = normalize(cross(planeNormal, axisX));\n\n    // Now, find the coordinate of the input point according to this texture coordinate frame\n    vec3 diff = pt - planePos; \n    float u = dot(diff, axisX);\n    float v = dot(diff, axisY);\n    \n    // Finally, apply the checkboard pattern by using this very concise formula:\n    return mod(floor(u * 0.5) + floor(v * 0.5), 2.0) < 1.0  ? planeCol1 : planeCol2;\n}\n\n//----------------------------------------------------------------------------------------------\n\nvec3 getObjectColorAtPoint(int objectId, vec3 pt, out Material objectMat)\n{\n    if (objectId == sphereId)\n    {\n        objectMat = sphereMat;\n        return getSphereColorAtPoint(pt);\n    }\n    else if (objectId == planeId)\n    {\n        objectMat = planeMat;\n        return getPlaneColorAtPoint(pt);\n    }\n        \n    return skyCol;\n}\n\n//----------------------------------------------------------------------------------------------\n\nfloat getShadowAtPoint(in vec3 I, in vec3 normalI, in Material objectMat, in vec3 L, in float Ldist)\n{\n    int object;\n    vec3 vec1, vec;\n    float dist = computeNearestIntersection(I, L, -1, object, vec1, vec);\n    if (dist<Ldist && dist>0.0) {\n        return 0.5;\n    } else {\n        return 1.0;\n    }\n}\n\n//----------------------------------------------------------------------------------------------\n\nvec3 computePhongShading(vec3 objectCol, Material objectMat, vec3 N, vec3 L, vec3 R, vec3 V, float shadowFactor)\n{    \n    vec3 ambiant  = objectMat.Ka * ambiantCol;\n    vec3 diffuse  = objectMat.Kd *  objectCol * lightCol *     max(dot(N,L), 0.);\n    vec3 specular = objectMat.Ks *  lightCol * pow(max(dot(R,V), 0.), objectMat.Kn);\n    \n    vec3 phongCol = ambiant + shadowFactor*diffuse + shadowFactor*specular;\n\n    return phongCol;\n}\n\n//##############################################################################################\n\nvec4 RaycastAtPixelCoord(vec2 pixCoord) \n{\n\t// Compute the ray to be casted through the pixel towards the 3D scene\n    vec3 rayPos, rayDir;\n    computeCameraRayFromPixel(pixCoord, rayPos, rayDir); \n    \n    ShadeInfo infos[MAX_NB_BOUNCES];\n    \n    int nbBounces = 0;\n    \n    // Test ray-objetcs intersections and find the nearest one\n    // (with its associated intersection point and normal at the object surface)\n    int  objectId;\n    vec3 intersecI, normalI;\n    \n    vec3 col;\n    vec3 spec;\n        \n    do\n    {\t\n        \n    \tfloat distI = computeNearestIntersection(rayPos, rayDir, -1, objectId, intersecI, normalI);\n    \n    \t// Apply the shading to the points that are on the sphere surface and seen by the camera\n    \tif (distI <= 0.0)\n    \t{\n            \n            infos[nbBounces].shadedcol = skyCol;\n        \tinfos[nbBounces].Ks = 0.0;\n        \tbreak;\n            \n        }\n        \n        // unit-vector going from the surface point toward the light\n\t    vec3 L = normalize(lightPos - intersecI);\n        \n        // unit-vector of the reflection direction of the light at the surface point\n    \tvec3 R = 2.0 * dot(normalI, L) * normalI - L;\n        \n        \n        // unit-vector going from the surface point toward the camera \n        vec3 V = -rayDir;\n        \n        vec3 RayRefr = 2.0 * normalI * dot(normalI, V) - V;\n        \n        \n        \n        // Get the diffuse color at the intersection point\n        Material objectMat;\n        vec3 objectCol = getObjectColorAtPoint(objectId, intersecI, objectMat);\n        \n        vec3 I = intersecI + normalI*eps;\n        \n        float Ldist = length(lightPos-I);\n        \n        float shadowfactor = getShadowAtPoint(I, normalI, objectMat, L, Ldist);\n        \n        // Apply the Phong shading to compute the color\n        // of the surface point as seen from the camera\n       \n        col = computePhongShading(objectCol, objectMat, normalI, L, R, V, shadowfactor);\n        \n        infos[nbBounces].shadedcol = col;\n        infos[nbBounces].Ks = objectMat.Ks;\n        \n        //bounce from the surface towards the reflect direction of the ray\n        \n        rayDir = RayRefr;\n        \n        rayPos = I;\n        \n        nbBounces++;\n    }\n    while (nbBounces < MAX_NB_BOUNCES);\n    \n    vec3 resCol = vec3(0);\n    \n    for (int i=0; i<=nbBounces; i++)\n    {\n        resCol = infos[nbBounces-i].Ks*resCol + infos[nbBounces-i].shadedcol;\n    }\n    \n    //resCol = vec4(computePhongShading(objectCol, objectMat, normalI, L, R, V, shadowfactor), 1);\n    \n    return vec4(resCol, 1);\n \n    //return vec4(computePhongShading(resCol, objectMat, normalI, L, R, V, shadowfactor), 1);; \n}\n\n\n//##############################################################################################\n\nvec2 noise2(vec2 location, vec2 delta) \n{\n    const vec2 c = vec2(12.9898, 78.233);\n    const float m = 43758.5453;\n    return vec2(\n        fract(sin(dot(location + delta, c)) * m),\n        fract(sin(dot(location + vec2(delta.y, delta.x), c)) * m)\n        \n\t);\n}\n\n\nvoid animateScene(in float time) {\n    //animate the sphere position\n\tconst float pi = 3.1415926535;\n\tconst float rs = 2.0;\n\tconst float spr = 5.0;\n\tfloat as = 2.0*pi * time /spr;\n\n    spherePos = cameraTarget + rs * vec3(-sin(as), 0.0, cos(as)) + vec3(0, 1, 0);\n    \n    lightPos += vec3(0.0, 10.5 + 9.5 * cos(time) - 10.0, 0.0);\n    \n    float targetDist = length(cameraTarget - cameraPos);\n    cameraPos -= vec3(0, 0, targetDist);\n    cameraPos += targetDist * vec3(sin(time), max(sin(time*0.5), 0.0), cos(time));\n    \n}\n\n//##############################################################################################\n\n    \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{ \n    vec4 moy = vec4(0);\n    \n    animateScene(0.0);\n    \n    if (boo == true) {\n    for (int i=0; i<PIXEL_SAMPLING_GRID_SIZE; i++) \n    {\n        \n        for (int j=0; j<PIXEL_SAMPLING_GRID_SIZE; j++)\n        {    \n            moy += RaycastAtPixelCoord(fragCoord+vec2(float(i)/float(PIXEL_SAMPLING_GRID_SIZE), float(j)/float(PIXEL_SAMPLING_GRID_SIZE))); \n    \t\t\n        }\n    }\n        \n    } else {\n        for (int i=0; i<PIXEL_SAMPLING_RANDOM ; i++)\n            moy += RaycastAtPixelCoord(fragCoord+noise2(vec2(i),vec2(10000))); \n    }\n    \n    if (boo == true) {\n        fragColor = moy/float(PIXEL_SAMPLING_GRID_SIZE*PIXEL_SAMPLING_GRID_SIZE);\n    } else {\n    \tfragColor = moy/float(PIXEL_SAMPLING_RANDOM);\n    }\n}","name":"Image","description":"","type":"image"}]}