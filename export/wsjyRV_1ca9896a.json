{"ver":"0.1","info":{"id":"wsjyRV","date":"1588872867","viewed":69,"name":"Noise - cis461","username":"sharond106","description":"Noise and uv mapping","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["noise"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float FOVY = 0.25 * 3.141569;\nconst int RAY_STEPS = 256;\n#define BACK_WALL_SDF sdfPlane(pos, BACK_WALL_INVERSE_T)\n#define BACK_WALL_ID 1\n#define BACK_WALL_INVERSE_T inverseTransform(vec3(0., 5., 15.), vec3(0.), vec3(40., 40., 1.))\n#define FLOOR_SDF sdfPlane(pos, FLOOR_INVERSE_T)\n#define FLOOR_ID 2\n#define FLOOR_INVERSE_T inverseTransform(vec3(0., -4.95, 0.), vec3(90., 0., 0.), vec3(40., 40., 1.))\n\n#define TALL_CUBE_SDF sdfBox(pos, vec3(5., 7, 3), TALL_CUBE_INVERSE_T)\n#define TALL_CUBE_ID 3\n#define TALL_CUBE_INVERSE_T inverseTransform(vec3(4, -1.5, 8), vec3(0, 35, 0), vec3(5., 7, 3))\n\n#define SPHERE_SDF sdfSphere(pos, vec3(-5, -1, 5), 3.)\n#define SPHERE_ID 5\n#define SPHERE_INVERSE_T inverseTransform(vec3(-5, -1, 5), vec3(0, 90., 0), vec3(3.))\n\nstruct Intersection {\n    float t;\n    vec3 color;\n    vec3 p;\n    int object;\n};\n    \nmat4 inverseTransform(vec3 translate, vec3 rotate, vec3 scale) {\n    mat4 s;\n    // matrices indexed to columns!\n    s[0] = vec4(scale.x, 0., 0., 0.);\n    s[1] = vec4(0., scale.y, 0., 0.);\n    s[2] = vec4(0., 0., scale.z, 0.);\n\ts[3] = vec4(0., 0., 0., 1.);                                     \n                                    \n    rotate.x = radians(rotate.x);\n    rotate.y = radians(rotate.y);\n    rotate.z = radians(rotate.z);\n      \n    mat4 r_x;\n    r_x[0] = vec4(1., 0., 0., 0.);\n    r_x[1] = vec4(0., cos(rotate.x), sin(rotate.x), 0.);\n    r_x[2] = vec4(0., -sin(rotate.x), cos(rotate.x), 0.);\n    r_x[3] = vec4(0., 0., 0., 1.);\n                                    \n                                    \n    mat4 r_y;\n    r_y[0] = vec4(cos(rotate.y), 0., -sin(rotate.y), 0.);\n    r_y[1] = vec4(0., 1, 0., 0.);\n    r_y[2] = vec4(sin(rotate.y), 0., cos(rotate.y), 0.);\n    r_y[3] = vec4(0., 0., 0., 1.);\n\n    mat4 r_z;\n    r_z[0] = vec4(cos(rotate.z), sin(rotate.z), 0., 0.);\n    r_z[1] = vec4(-sin(rotate.z), cos(rotate.z), 0., 0.);\n    r_z[2] = vec4(0., 0., 1., 0.);\n    r_z[3] = vec4(0., 0., 0., 1.);\n\n    mat4 r = r_x * r_y * r_z;\n    \n    mat4 t;\n    t[0] = vec4(1., 0., 0., 0.);\n    t[1] = vec4(0., 1., 0., 0.);\n    t[2] = vec4(0., 0., 1., 0.);\n    t[3] = vec4(translate.x, translate.y, translate.z, 1.); \n    \n    return inverse(t * r * s);      \n}\n    \nfloat sdfPlane(vec3 p, mat4 inverseT) {\n    p = vec3(inverseT * vec4(p, 1.));\n    float dot = dot(p, vec3(0., 0., 1.));\n    if (abs(dot) < 0.0001) {\n        // n must be normalized\n        if (p.x >= -.5 && p.x <= 0.5 && p.y >= -0.5 && p.y <= 0.5) {\n            return 0.;  \n        }\n        return 324234.;\n    }\n    float dist = 0.f;\n    if (abs(p.x) > 0.5) {\n        dist += ((p.x - 0.5) * (p.x - 0.5));\n    }\n    if (abs(p.y) > 0.5) {\n        dist += ((p.y - 0.5) * (p.y - 0.5));\n    }\n    dist += abs(p.z) * abs(p.z);\n    return sqrt(dist);\n} \n\n// Box with side lengths b\nfloat sdfBox(vec3 p, vec3 scale, mat4 inverseT)\n{\n    p = vec3(inverseT * vec4(p, 1.));\n    vec3 q = vec3(abs(p.x), abs(p.y), abs(p.z)) - vec3(.5);\n    float d = q.x;\n    d = max(d,q.y);\n    d = max(d,q.z);\n    return d * min(min(scale.x, scale.y), scale.z);\n}\n\n\nfloat sdfSphere(vec3 p, vec3 c, float r) {\n    return distance(p, c) - r;\n}\n\nvoid sceneMap3D(vec3 pos, out float t, out int objectHit) {\n\tt = BACK_WALL_SDF;\n    objectHit = BACK_WALL_ID;\n    float t2;\n\n\tif ((t2 = FLOOR_SDF) < t) {\n        t = t2;\n        objectHit = FLOOR_ID;\n    }\n    if ((t2 = TALL_CUBE_SDF) < t) {\n        t = t2;\n        objectHit = TALL_CUBE_ID;\n    }\n     if ((t2 = SPHERE_SDF) < t) {\n        t = t2;\n        objectHit = SPHERE_ID;\n    }\n}\n\n// called by computeNormal\nfloat sceneMap3D(vec3 pos) {\n    float t;\n    int obj;\n    sceneMap3D(pos, t, obj);\n    return t;\n}\n\nvoid march(vec3 origin, vec3 dir, out float t, out int objectHit) {\n    t = 0.001;\n    for (int i = 0; i < RAY_STEPS; i++) {\n        vec3 pos = origin + t * dir;\n        float min;\n        sceneMap3D(pos, min, objectHit);\n        if (min < 0.01) {\n            return;\n        }\n        t += min;\n    }\n    t = -1.;\n    objectHit = -1;\n}\n\nvec3 computeNormal(vec3 p) {\n    vec3 epsilon = vec3(0., .001, 0.);\n    return normalize(vec3(sceneMap3D(p + epsilon.yxx) - sceneMap3D(p - epsilon.yxx),\n                          sceneMap3D(p + epsilon.xyx) - sceneMap3D(p - epsilon.xyx),\n                     \t  sceneMap3D(p + epsilon.xxy) - sceneMap3D(p - epsilon.xxy)));\n}\n\nfloat noise2D( vec2 p ) {\n    return fract(sin(dot(p, vec2(127.1, 311.7))) *\n                  45964.03 / (4372. * (cos(.5 * iTime) + 3.) / 2.));\n}\n\nfloat interpNoise2D(float x, float y) {\n    int intX = int(floor(x));\n    float fractX = fract(x);\n    int intY = int(floor(y));\n    float fractY = fract(y);\n\n    float v1 = noise2D(vec2(intX, intY));\n    float v2 = noise2D(vec2(intX + 1, intY));\n    float v3 = noise2D(vec2(intX, intY + 1));\n    float v4 = noise2D(vec2(intX + 1, intY + 1));\n\n    float i1 = mix(v1, v2, fractX);\n    float i2 = mix(v3, v4, fractX);\n    return mix(i1, i2, fractY);\n}\n\n\nfloat fbm(float x, float y) {\n    float total = 0.;\n    float persistence = 0.5f;\n    float octaves = 4.;\n\n    for(float i = 1.; i <= octaves; i++) {\n        float freq = pow(2.f, i);\n        float amp = pow(persistence, i);\n\n        total += interpNoise2D(x * freq,\n                               y * freq) * amp;\n    }\n    return total;\n}\n\n\nvec2 random2 (vec2 p) {\n    return fract(sin(vec2(dot(p, vec2(127.1, 311.7)),\n                          dot(p, vec2(269.5, 183.3))))\n                 * 43758.5433);\n}\n\nfloat WorleyNoise(vec2 uv) {\n    uv /= 5.;\n    vec2 uvInt = floor(uv);\n    vec2 uvFract = fract(uv);\n    float minDist = 1.0; // Minimum distance initialized to max.\n    for(int y = -1; y <= 1; ++y) {\n        for(int x = -1; x <= 1; ++x) {\n            vec2 neighbor = vec2(float(x), float(y)); // Direction in which neighbor cell lies\n            vec2 point = random2(uvInt + neighbor); // Get the Voronoi centerpoint for the neighboring cell\n            point = 0.5 + 0.5 * sin(iTime + 13.2831 * point);\n            vec2 diff = neighbor + point - uvFract; // Distance between fragment coord and neighborâ€™s Voronoi point\n            float dist = length(diff);\n            minDist = min(minDist, dist);\n        }\n    }\n    return minDist;\n}\n\nvec3 random3( vec3 p ) {\n    return fract(sin(vec3(dot(p,vec3(127.1, 311.7, 191.999)),\n                          dot(p,vec3(269.5, 183.3, 765.54)),\n                          dot(p, vec3(420.69, 631.2,109.21))))\n                 *43758.5453);\n}\n\nfloat surflet(vec3 p, vec3 gridPoint) {\n    vec3 t2 = abs(p - gridPoint);\n    vec3 t = vec3(1.f) - 6.f * vec3(pow(t2.x, 5.),pow(t2.y, 5.), pow(t2.z, 5.)) + 15.f * vec3(pow(t2.x, 4.), pow(t2.y, 4.),pow(t2.z, 4.)) - 10.f * vec3(pow(t2.x, 3.),pow(t2.y, 3.),pow(t2.z, 3.));\n    vec3 gradient = random3(gridPoint) * 2. - vec3(1) * (sin(2. * iTime) + 1.);\n    vec3 diff = p - gridPoint;\n    float height = dot(diff, gradient);\n    return height * t.x * t.y * t.z;\n}\n\nfloat perlinNoise(vec3 p) {\n\tfloat surfletSum = 0.f;\n\t// Iterate over the four integer corners surrounding uv\n\tfor(int dx = 0; dx <= 1; ++dx) {\n\t\tfor(int dy = 0; dy <= 1; ++dy) {\n            for(int dz = 0; dz <= 1; ++dz) {\n\t\t\t\tsurfletSum += surflet(p, floor(p) + vec3(dx, dy, dz));\n            }\n\t\t}\n\t}\n\treturn surfletSum + 0.2;\n}\n\nvec3 computeMaterial(int objectHit, vec3 p, vec3 n, vec3 lightDir, vec3 view) {\n    lightDir = normalize(lightDir - p);\n    float lambert = dot(n, lightDir);\n    vec3 color = vec3(1);\n    \n    switch (objectHit) {\n        case SPHERE_ID:\n        p = vec3(SPHERE_INVERSE_T * vec4(p, 1.));        \n\n        vec3 n = p;\n\t\tfloat u = atan(n.x, n.z) / (2.*3.1415926535897932384626433832795) + 0.5;\n\t\tfloat v = 0.5 - asin(n.y)/3.1415926535897932384626433832795;\n               \n        float f = fbm(u * 20., v * 20.);\n        \n        color = vec3(1) * f;\n        vec3 a = vec3(-0.642, 0.608, 0.608);\n   \t\tvec3 b = vec3(0.588, -0.342, 0.048);\n        vec3 c = vec3(f, f, f);\n    \tvec3 d = vec3(f*f, f*f, f*f);\n        vec3 color1 = a + b * cos(2. * 3.1415926535897932384626433832795 *\n                                 (c  + d));\n        vec3 color2 = c + d * cos(2. * 3.1415926535897932384626433832795 *\n                                 (a  + b));\n        color = mix(color2, color1, (cos(.5 * iTime) + 1.) / 2.) * 1.5;                \n        break;\n        \n        case FLOOR_ID:\n        \n        color = vec3(.8, 1, .7);\n        \n        break;\n        \n        case TALL_CUBE_ID:\n        float perlin = perlinNoise(p);\n        \n        a = vec3(1.000, 0.500, 0.500);\n\t\tb = vec3(0.5);\n\t\td = vec3(0.750, 1.000, 0.667);\n\t\tc = vec3(0.800, 1.000, 0.333);\n        \n        vec3 perlinColor = a + b * cos(6.28 * (perlin * 2. * c + d));\n        color = vec3(1) * perlinColor;\n        \n        break;\n        \n        case BACK_WALL_ID:\n        vec3 uvec = vec3(1, 0, 0);\n        vec3 vvec = vec3(0, 1, 0);\n        u = dot(uvec, p);\n        v = dot(vvec, p);\n        \n        float t = WorleyNoise(vec2(u, v));\n        a = vec3(0.5, 0.5, 0.5);\n\t\tb = vec3(0.5, 0.5, 0.5);\n\t\td = vec3(1.);\n\t\tc = vec3(0.3, 0.2, 0.2);\n        vec3 worleyColor = a + b * cos(6.28 * (t * c + d));\n        \n        color = vec3(1) * worleyColor;\n        break;\n    }\n    return color * lambert;\n}\n\nIntersection sdf3D(vec3 eye, vec3 dir) {\n    float t;\n    int objectHit;\n    march(eye, dir, t, objectHit);\n    vec3 isect = eye + t * dir;\n    \n    vec3 nor = computeNormal(isect);\n    \n    vec3 lightDir = vec3(3, 7, -4);\n    \n    vec3 color = computeMaterial(objectHit, isect, nor, lightDir, normalize(eye - isect));\n    \n    if (objectHit == -1) {\n        color = vec3(0, 0, 0);\n    }\n    \n    return Intersection(t, color, isect, objectHit);\n}\n\nvec3 rayCast(vec3 eye, vec3 ref, vec2 ndc) {\n    vec3 F = ref - eye;\n    vec3 R = normalize(cross(F, vec3(0., 1., 0.)));\n    vec3 U = normalize(cross(R, F));\n    \n    vec3 V = U * length(F) * tan(FOVY * 0.5);\n    vec3 H = R * length(F) * tan(FOVY * 0.5) * float(iResolution.x) / float(iResolution.y);\n    \n    vec3 p = ref + ndc.x * H + ndc.y * V;\n    \n    return normalize(p - eye);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv = uv * 2.0 - vec2(1, 1);\n    \n    vec3 eye = vec3(0, 3, -11);\n    vec3 ref = vec3(0, 0, 2);\n    vec3 rayDir = rayCast(eye, ref, uv); \n    \n    Intersection isect = sdf3D(eye, rayDir);\n\n    fragColor = vec4(isect.color, 1.0);\n}","name":"Image","description":"","type":"image"}]}