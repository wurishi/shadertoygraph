{"ver":"0.1","info":{"id":"7t3XDr","date":"1640360094","viewed":303,"name":"Snowflake Generation 4 high res","username":"soudfv","description":"Snowflake Generation 4 (more physically correct)\nFrom:\nA local cellular model for snow crystal growth\nClifford A. Reiter*\nDepartment of Mathematics, Lafayette College, Easton, PA 18042, USA\nAccepted 8 June 2004","likes":22,"published":1,"flags":32,"usePreview":0,"tags":["simulation","automata","cellular","snowflake","multipass"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Emboss\n\n#define T(uv) texture(iChannel0, fract((uv)/iResolution.xy)).x\n\n// iq's palette\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\n#define PAL vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.0,0.10,0.20)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 tuv0 = (fragCoord - iResolution.xy*.5) * hex_ratio + iResolution.xy*.5;\n    vec3 duv = vec3(-1.,0.,1.)*.75;\n    \n    float col0;\n    if (emboss) {\n        float  u = T(tuv0 + duv.yx);\n        float  l = T(tuv0 + duv.xy);\n        float  r = T(tuv0 + duv.zy);\n        float  d = T(tuv0 + duv.yz);\n        col0 = (r + u + T(tuv0) - d - l);\n    }\n    else {\n        col0 = T(tuv0);\n    }\n    \n    vec3 col = vec3(clamp(log(1.+col0),0.,1.));\n    if (usePalette) {\n        col = pal(col.x*.7+.2, PAL);\n    }\n    fragColor = vec4(col, 1.);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"const bool usePalette = false;\nconst bool vertical = false;\nconst bool emboss = true;\nconst vec2 hex_ratio = vec2(1./1.154,1.);\n\n#define STYLE 3\n\n#if STYLE == 0\n    const float alpha = 0.5;    // laplacian feedback coefficient\n    const float gamma = 0.0005; // additive component\n    const float beta = 0.3;     // initial surrounding temperature\n    const float th_jitter = .2;\n#elif STYLE == 1\n    const float alpha = 1.0;    // laplacian feedback coefficient\n    const float gamma = 0.005; // additive component\n    const float beta = 0.35;     // initial surrounding temperature\n    const float th_jitter = .005;\n#elif STYLE == 2\n    const float alpha = 2.54;    // laplacian feedback coefficient\n    const float gamma = 0.0005; // additive component\n    const float beta = 0.15;     // initial surrounding temperature\n    const float th_jitter = 0.005;\n#else\n    const float alpha = 2.54;    // laplacian feedback coefficient\n    const float gamma = 0.0005; // additive component\n    const float beta = 0.25;     // initial surrounding temperature\n    const float th_jitter = .2;\n#endif\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define T(uv) texture(iChannel1, mod(uv,iResolution.xy-vec2(1.))/iResolution.xy).x\n\n#define PI 3.141592653589793238462643383\n\nconst float an = 60.;\nconst vec2 dir0 = vec2(cos(an * PI/180.), sin(an * PI/180.));\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv0 = fragCoord/iResolution.xy;\n    vec2 tuv0 = fragCoord;\n    vec2 ratio = vec2(1.,iResolution.y/iResolution.x);\n    vec3 col;\n\n    vec2 odd = mod(floor(fragCoord),2.);\n    vec2 uv_screen;\n    if (vertical) {\n        uv_screen.x = odd.x != 0. ? fragCoord.x * .5 : (fragCoord.x + iResolution.x) * .5;\n        uv_screen.y = (odd.y != mod(floor(uv_screen.x),2.)) != (uv_screen.x < iResolution.x * .5)\n            ? fragCoord.y * .5 : (fragCoord.y + iResolution.y) * .5;\n    }\n    else {\n        uv_screen.y = odd.y != 0. ? fragCoord.y * .5 : (fragCoord.y + iResolution.y) * .5;\n        uv_screen.x = (odd.x != mod(floor(uv_screen.y),2.)) != (uv_screen.y < iResolution.y * .5)\n            ? fragCoord.x * .5 : (fragCoord.x + iResolution.x) * .5;\n    }\n    uv_screen = (uv_screen - iResolution.xy*.5) / hex_ratio + iResolution.xy*.5;\n    \n    vec2 mc = abs(uv_screen - iMouse.xy) / iResolution.xy * ratio.xy;\n    \n    if (iFrame == 0) {\n        col = floor(uv_screen) == iResolution.xy * .5 ? vec3(1.) : vec3(beta);\n    }\n    else if (iMouse.z > 0. && dot(mc, dir0) < 0.1 && dot(mc, vec2(1.0,0.)) < 0.1) {\n        col = floor(distance(uv_screen, iMouse.xy)) == 0. ? vec3(1.) : vec3(beta);\n    }\n    else {\n        {\n            vec2 step1 = vec2(2.0);\n            vec2 step2 = vertical ? vec2(0., step1.y) : vec2(step1.x, 0.);\n            vec2 dir = vertical ? vec2(2.,1.) : vec2(1.,2.);\n\n            float ul = T(tuv0 - dir);\n            float ur = T(tuv0 + vec2(dir.x, -dir.y));\n            float dr = T(tuv0 + dir);\n            float dl = T(tuv0 + vec2(-dir.x, dir.y));\n            float  r = T(tuv0 + step2);\n            float  l = T(tuv0 - step2);\n\n            float u = texture(iChannel0, uv0).x;\n            float u_th = texture(iChannel1, uv0).x;\n            float u2 = u_th == 0. ? u + gamma : 0.;\n            float sum = ul + ur + r + dr + dl + l;\n            float u1 = u_th + alpha*(-6.*u_th+sum)/12. + u2;\n            col = vec3(u1);\n        }\n    }\n    fragColor = vec4(col,1.);\n}\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// Threshold\n\n#define T(uv) texture(iChannel0, mod(uv,iResolution.xy-vec2(1.))/iResolution.xy).x\n\nconst float th0 = 0.5;\n\n// Hash without sine by Dave_Hoskins\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv0 = fragCoord/iResolution.xy;\n    vec2 tuv0 = fragCoord;\n    vec3 col;\n\n    col = vec3(0.0);\n    vec2 step1 = vec2(2.0);\n    vec2 step2 = vertical ? vec2(0., step1.y) : vec2(step1.x, 0.);\n    vec2 dir = vertical ? vec2(2.,1.) : vec2(1.,2.);\n\n    float ul = T(tuv0 - dir);\n    float ur = T(tuv0 + vec2(dir.x, -dir.y));\n    float dr = T(tuv0 + dir);\n    float dl = T(tuv0 + vec2(-dir.x, dir.y));\n    float  r = T(tuv0 + step2);\n    float  l = T(tuv0 - step2);\n\n    float u = texture(iChannel0, uv0).x;\n    float th = th0;\n    th += (hash11(iTime) - .5) * th_jitter;\n    bool ulb = ul > th;\n    bool urb = ur > th;\n    bool  lb =  l > th;\n    bool dlb = dl > th;\n    bool drb = dr > th;\n    bool  rb =  r > th;\n    int b = int(ulb) + int(urb) + int(lb) + int(dlb) + int(drb) + int(rb);\n    if (u > th || b > 0) u = 0.;\n    col = vec3(u);\n\n    fragColor = vec4(col,1.);\n}\n","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"// Transpose left/right with odd/even\n\n#define T(uv) texture(iChannel0, fract((uv)/iResolution.xy)).x\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 tuv0 = fragCoord;\n    \n    vec2 tuv = fragCoord;\n    vec2 tuv2 = tuv * 2.;\n    \n    if (vertical) {\n        float x_odd = mod(floor(tuv.x),2.);\n\n        if (tuv2.x < iResolution.x) {\n            tuv.x = tuv2.x + 1.;\n            x_odd = 1. - x_odd;\n        }\n        else {\n            tuv.x = tuv2.x - iResolution.x;\n        }\n\n        if (tuv.y * 2. < iResolution.y) {\n            tuv.y = tuv2.y + (1. - x_odd);\n        }\n        else {\n            tuv.y = tuv2.y - iResolution.y + x_odd;\n        }\n    }\n    else {\n        float y_odd = mod(floor(tuv.y),2.);\n\n        if (tuv2.y < iResolution.y) {\n            tuv.y = tuv2.y + 1.;\n            y_odd = 1. - y_odd;\n        }\n        else {\n            tuv.y = tuv2.y - iResolution.y;\n        }\n\n        if (tuv2.x < iResolution.x) {\n            tuv.x = tuv2.x + (1. - y_odd);\n        }\n        else {\n            tuv.x = tuv2.x - iResolution.x + y_odd;\n        }\n    }\n    \n    tuv = (tuv - vec2(.5));\n    float col = T(tuv);\n    fragColor = vec4(vec3(col),1.0);\n}","name":"Buffer C","description":"","type":"buffer"}]}