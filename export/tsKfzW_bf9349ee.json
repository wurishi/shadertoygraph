{"ver":"0.1","info":{"id":"tsKfzW","date":"1609427894","viewed":173,"name":"20201130_cloud (Windy Fairy)","username":"FMS_Cat","description":"wenis","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["3d"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Ref: https://www.shadertoy.com/view/WdXGRj\n// Shoutouts to kaneta\n\n#define PI 3.14159265\n\n#define MAX_STEPS 96\n#define SHADOW_STEPS 4\n#define VOLUME_LENGTH 20.\n#define SHADOW_LENGTH 1.\n\n#define ROTZ 0.0\n#define SANDWICH_HEIGHT 4.0\n#define DENSITY_MULTIPLIER 1.0\n#define CLOUD_COVER 1.5\n#define LIGHT_DIR (normalize(vec3(1.0, 1.0, 1.0)))\n#define FOV ( 60.0 / 180.0 * PI )\n\n#define saturate(v) clamp((v),0.,1.)\n\n// == math and stuff ===============================================================================\nfloat gray( vec3 rgb ) {\n  return 0.299 * rgb.r + 0.587 * rgb.g + 0.114 * rgb.b;\n}\n\nmat2 rotate2D( float t ) {\n  return mat2( cos( t ), sin( t ), -sin( t ), cos( t ) );\n}\n\n// == random and noise =============================================================================\nfloat fractSin3( vec3 v ) {\n  return fract( 459.912 * sin( dot( v, vec3( 112.283, 117.912, 122.419 ) ) ) );\n}\n\nfloat noise( vec3 v ) {\n  vec3 vi = floor( v );\n  vec3 vf = fract( v );\n  vec3 vs = vi + vf * ( 2.0 * vf * vf - 3.0 * vf + 2.0 );\n  vf = vf * vf * ( 3.0 - 2.0 * vf );\n\n  return mix(\n    texture( iChannel0, ( ( vi.z + 0.0 ) * 0.00390625 * 31.0 + 0.00390625 * vs.xy ) ).x,\n    texture( iChannel0, ( ( vi.z + 1.0 ) * 0.00390625 * 31.0 + 0.00390625 * vs.xy ) ).x,\n    vf.z\n  );\n}\n\nfloat fbm( vec3 v ) {\n  float ret = -0.5;\n  ret += 0.5 * noise( v );\n  ret += 0.25 * noise( v * 2.0 );\n  ret += 0.125 * noise( v * 4.0 );\n  ret += 0.0625 * noise( v * 8.0 );\n  return ret;\n}\n\n// == map ==========================================================================================\nfloat map( vec3 p ) {\n  vec3 pt = p;\n  float dist = 0.0;\n\n  { // wall\n    pt.y = pt.y - sign( pt.y ) * SANDWICH_HEIGHT; // sandwich1\n\n    vec3 q = pt - vec3( 0.0, 0.5, 1.0 ) * iTime; // moving pt for fbm use\n    float f = fbm( q ); // create fbm\n\n    pt.zx = rotate2D( 0.7 ) * pt.zx; // rotate to win\n    pt.y = abs( pt.y ); // sandwich2\n    pt.zx = mod( pt.zx, 2.0 ) - 1.0; // mod\n\n    dist += saturate( CLOUD_COVER - length( pt ) + f * 3.0 ); // dist\n  }\n\n  return saturate( dist );\n}\n\n// == cloud ========================================================================================\nfloat jitter; // whoa\n\nvec4 cloudMarch( vec3 ro, vec3 rd ) {\n  float density = 0.0;\n\n  float stepLength = VOLUME_LENGTH / float( MAX_STEPS ) / dot( rd, vec3( 0.0, 0.0, -1.0 ) );\n  float shadowStepLength = SHADOW_LENGTH / float( SHADOW_STEPS );\n\n  vec4 sum = vec4( 0.0, 0.0, 0.0, 1.0 );\n\n  vec3 rp = ro + rd * jitter * stepLength;\n\n  for ( int i = 0; i < MAX_STEPS; i ++ ) {\n    if ( sum.a < 0.1 ) {\n      break;\n    }\n\n    float d = map( rp );\n\n    if ( d > 0.001 ) {\n      vec3 lpos = rp + LIGHT_DIR * jitter * shadowStepLength;\n      float shadow = 0.0;\n\n      for ( int s = 0; s < SHADOW_STEPS; s ++ ) {\n        lpos += LIGHT_DIR * shadowStepLength;\n        float lsample = map( lpos );\n        shadow += lsample;\n      }\n\n      density = DENSITY_MULTIPLIER * clamp( ( d / float( MAX_STEPS ) ) * 20.0, 0.0, 1.0 );\n      float s = exp( ( -shadow / float( SHADOW_STEPS ) ) * 3.0 );\n      sum.rgb += vec3( s * density ) * vec3( 1.1, 0.9, 0.5 ) * sum.a;\n      sum.a *= 1.0 - density;\n\n      sum.rgb += exp( -map( rp + vec3( 0.0, 0.25, 0.0 ) ) * 0.2 ) * density * vec3( 0.15, 0.45, 1.1 ) * sum.a;\n    }\n    rp += rd * stepLength;\n  }\n\n  return sum;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 p = ( fragCoord / iResolution.xy * 2.0 - 1.0 ) * vec2( iResolution.x / iResolution.y, 1.0 );\n  jitter = 0.1 * fractSin3( p.xyx + iTime );\n  vec3 ro = vec3( 0.0, 0.0, -iTime );\n  vec3 rd = normalize( vec3( p, -1.0 / tan( 0.5 * FOV ) ) );\n  rd.xy = rotate2D( ROTZ ) * rd.xy; // rotZ\n\n  vec4 cloud = cloudMarch( ro, rd );\n  vec3 result = cloud.rgb + mix( vec3( 0.2, 0.4, 0.8 ), vec3( 0.05, 0.3, 0.8 ), p.y + 0.75 ) * cloud.a;\n\n  float sundot = clamp( dot( rd, LIGHT_DIR ), 0.0, 1.0 );\n  result += 0.4 * vec3( 1.0, 0.7, 0.3 ) * pow( sundot, 4.0 );\n\n  result = pow( result, vec3( 0.4545 ) );\n\n  fragColor = vec4( result, 1.0 );\n}\n","name":"Image","description":"","type":"image"}]}