{"ver":"0.1","info":{"id":"lc2Bzz","date":"1724779982","viewed":40,"name":"Shields Up!","username":"incre_ment","description":"More messing around with a polygon SDF 2D mesh and domain repetition","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["2d","domainrepetition","mesh"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float TAU = 2.*3.14159;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec2 uv = ( fragCoord - .5* iResolution.xy ) /iResolution.y;\n   vec3 col = vec3(0.);   \n   float tt = fract(.3*iTime);\n   \n   // Stars\n   vec2 uvStars = uv * 30.;\n   vec2 starCell = floor(uvStars);\n   uvStars = fract(uvStars) * 2. - 1.;\n   float r1 = fract(sin(dot(starCell, vec2(1.0,12.0)))*15745.7342) * 2. - 1.;\n   float r2 = fract(sin(dot(starCell, vec2(1.0,43.0)))*13131.8234) * 2. - 1.;\n   float spark = 0.;\n   if (r2 > .3) spark = .1 * sin(TAU*(tt + r1));     \n     float ssize = r2 * .2;  \n   float star = length(uvStars - .7*vec2(r1,r2)) - ssize+spark;\n   col += smoothstep(.1,-.1,star);\n   \n   // Mesh\n   float scale = 4.;\n   uv *= scale;  \n   vec2 cellID = round(uv);\n   uv = fract(uv +.5) - .5;\n   \n   float minVal = 1E20;\n   for (float i = -1.; i <= 1.; i++)\n     for(float j = -1.; j <= 1.; j++){     \n       float meshDim = .5;  \n       vec2 uvCenter = (cellID + vec2(i,j)) / scale;   \n       float v1delta = TAU*(hash12(uvCenter + vec2(-meshDim/scale,meshDim/scale)));\n       float v2delta = TAU*(hash12(uvCenter + vec2(-meshDim/scale,-meshDim/scale)));\n       float v3delta = TAU*(hash12(uvCenter + vec2(meshDim/scale,-meshDim/scale)));\n       float v4delta = TAU*(hash12(uvCenter + vec2(meshDim/scale,meshDim/scale)));\n      \n       vec2[4] verts; \n       float r = .5;\n       verts[0] = vec2(i,j) + vec2(-meshDim,meshDim) + vec2(r*sin(TAU*tt + v1delta),r*cos(TAU*tt + v1delta));\n       verts[1] = vec2(i,j) + vec2(-meshDim,-meshDim)+ vec2(r*sin(TAU*tt + v2delta),r*cos(TAU*tt + v2delta));\n       verts[2] = vec2(i,j) + vec2(meshDim, -meshDim)+ vec2(r*sin(TAU*tt + v3delta),r*cos(TAU*tt + v3delta));\n       verts[3] = vec2(i,j) + vec2(meshDim, meshDim) + vec2(r*sin(TAU*tt + v4delta),r*cos(TAU*tt + v4delta));;\n  \n       float poly = sdPolygon(verts, uv);\n       minVal = min(poly, minVal);\n     }\n\n   if (minVal < -.1)\n       col += .12/abs(minVal);\n    \n   fragColor = vec4(col,1.0);\n} ","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"const int N = 4;\n\n// SDF from IQ\nfloat sdPolygon( in vec2[N] v, in vec2 p )\n{\n    float d = dot(p-v[0],p-v[0]);\n    float s = 1.0;\n    for( int i=0, j=N-1; i<N; j=i, i++ )\n    {\n        vec2 e = v[j] - v[i];\n        vec2 w =    p - v[i];\n        vec2 b = w - e*clamp( dot(w,e)/dot(e,e), 0.0, 1.0 );\n        d = min( d, dot(b,b) );\n        bvec3 c = bvec3(p.y>=v[i].y,p.y<v[j].y,e.x*w.y>e.y*w.x);\n        if( all(c) || all(not(c)) ) s*=-1.0;  \n    }\n    return s*sqrt(d);\n}\n\n\n// https://www.shadertoy.com/view/4djSRW\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n","name":"Common","description":"","type":"common"}]}