{"ver":"0.1","info":{"id":"tdsyWr","date":"1584606451","viewed":187,"name":"TP3 Graphique S4","username":"LucieFournier","description":"TP3","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["tp3"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Lucie Fournier\n// p1811511\n\nconst float view = 8000.0;  // View distance\nconst float Epsilon = 0.01; // Marching epsilon\n\n// Iterations\nconst int N = 500;\n\n// Lipschitz constant\nconst float K=7.0;\n\n// Terrain -----------------------------------------------------------------------------------------------\n\n// Terrain heightfield\n// x : Position in the plane\nfloat Terrain( in vec2 x )\n{\n\t// Rotation matrix\n\tconst mat2 m2 = mat2(0.8,-0.6,0.6,0.8);\n    const float l0=1950.0;\t// Longueur d'onde de la plus basse fréquence\n    const float a0=575.0;\n    \n\tvec2  p = x/l0;\n    float a = 0.0;\n    float b = 1.0;\n    for( int i=0; i<12; i++ )\n    {\n        float n = Noise(p);\n        a += b*n;\n\t\tb *= 0.5;\n        p = m2*p*2.0;\n    }\n\treturn -500.0+a0*a;\n} \n\n// Implicit surface defining the terrain\n// p : Point\nfloat ImplicitTerrain(in vec3 p)\n{\n    float h = p.z - Terrain( p.xy );\n    return h;\n}\n\n// Sphere tracing\n// ro, rd : Ray origin and direction\n// t : Intersection depth\n// i : Iteration count\nbool IntersectTerrain(in vec3 ro, in vec3 rd, out float t,out int i)\n{\n    t = 0.0;\n\tfor( i=0; i<N; i++ )\n\t{\n        vec3 p = ro + t*rd;\n\t\tfloat h = ImplicitTerrain(p);\n        // 10 cm precision\n\t\tif( abs(h)<(Epsilon*t)  ) return true;\n        if( t>view ) { return false; }\n\t\t// Empirical Lipschitz constant with level of detail (the further, the larger steps)\n        t += max(Epsilon,h*sqrt(1.0+8.0*t/view)/K);\n\t}\n\n\treturn false;\n}\n\n// Calculate object normal\n// p : point\nvec3 NormalTerrain(in vec3 p )\n{\n  float eps = 0.01;\n  vec3 n;\n  float v = ImplicitTerrain(p);\n  n.x = ImplicitTerrain( vec3(p.x+eps, p.y, p.z) ) - v;\n  n.y = ImplicitTerrain( vec3(p.x, p.y+eps, p.z) ) - v;\n  n.z = ImplicitTerrain( vec3(p.x, p.y, p.z+eps) ) - v;\n  return normalize(n);\n}\n\n// Water ------------------------------------------------------------------------------------------------\n\n// Terrain heightfield\n// x : Position in the plane\nfloat Water( in vec2 x )\n{\n    return 20.0*Noise(x/50.0+iTime)- 20.0;\t// Vagues selon un bruit\n} \n\n// Implicit surface defining the terrain\n// p : Point\nfloat ImplicitWater(in vec3 p)\n{\n\tfloat h = p.z - Water( p.xy );\n    return h;\n}\n\n// Sphere tracing\n// ro, rd : Ray origin and direction\n// t : Intersection depth\n// i : Iteration count\nbool IntersectWater(in vec3 ro, in vec3 rd, out float t,out int i)\n{\n    t = 0.0;\n\tfor( i=0; i<N; i++ )\n\t{\n        vec3 p = ro + t*rd;\n\t\tfloat h = ImplicitWater(p);\n        // 10 cm precision\n\t\tif( abs(h)<(Epsilon*t)  ) return true;\n        if( t>view ) { return false; }\n\t\t// Empirical Lipschitz constant with level of detail (the further, the larger steps)\n        t += max(Epsilon,h*sqrt(1.0+8.0*t/view)/K);\n\t}\n\n\treturn false;\n}\n\n// Calculate object normal\n// p : point\nvec3 NormalWater(in vec3 p )\n{\n  float eps = 0.01;\n  vec3 n;\n  float v = ImplicitWater(p);\n  n.x = ImplicitWater( vec3(p.x+eps, p.y, p.z) ) - v;\n  n.y = ImplicitWater( vec3(p.x, p.y+eps, p.z) ) - v;\n  n.z = ImplicitWater( vec3(p.x, p.y, p.z+eps) ) - v;\n  return normalize(n);\n}\n\n// Texture Eau\n// p : point de l'espace\nvec3 Eau(vec3 p) {\n    vec3 q = p + 1.0*N3(p) + 0.5*N3(p/0.5);\t// On deforme le point dans l'espace\n    q.z=(q.x+5.0*iTime);\n \tvec3 Bleu = vec3(0.0,0.0,1.0);\n    vec3 Bleu2 = vec3(0.0,0.0,0.05);\n    vec3 col = mix(Bleu,Bleu2,fbm(q/2.0));\t// Mix de bleus\n    return col;\n}\n\n// Texture Herbe\n// p : point de l'espace\nvec3 Herbe(vec3 p) {\n    vec3 q = p + 1.0*N3(p) + 0.5*N3(p/0.5);\t// On deforme le point dans l'espace\n    q.z=(q.x);\n \tvec3 Vert = vec3(0.1,0.5,0.1);\n    vec3 Vert2 = vec3(0.0,0.1,0.0);\n    vec3 col = mix(Vert,Vert2,fbm(q/2.0));\t// Mix de verts\n    return col;\n}\n\n// Texture Lave\n// p : point de l'espace\nvec3 Lave(vec3 p) {\n    vec3 q = p + 1.0*N3(p) + 0.5*N3(p/0.5);\t// On deforme le point dans l'esapace\n    q.z=(q.x-5.0*iTime);\n \tvec3 Rouge = vec3(1.0,0.0,0.0);\n    vec3 Orange = vec3(0.8,0.5,0.0);\n    vec3 col = mix(Rouge,Orange,fbm(q/2.0));\t// Mix de rouge et d'orange\n    return col;\n}\n\n// Calcule si un point est dans un secteur de disque ou non\n// v : point du cercle (centre 0.0)\n// alpha > beta\n// alpha et beta les angles du secteur entre 0 et 2PI\n// r : rayon du cercle\nbool dansSecteur(vec2 v, float alpha, float beta, float r) {\n    // 4 cas differents selon le quart de cercle\n    if (alpha <= 3.14/2.0 && beta < 3.14/2.0) {\n    \tif(v.x >= 0.0 && v.y >= 0.0) {\n            float c1 = sin(alpha)/cos(alpha);\t// Coefficients directeurs des droites\n            float c2 = sin(beta)/cos(beta);\n            if(v.y < c1*v.x && v.y > c2*v.x) {\t// On regarde si on est entre ces droites\n                return true;\n            }\n        }\n    }\n    else if(alpha <= 3.14 && beta < 3.14) {\n        if(v.x <= 0.0 && v.y >= 0.0) {\n            float c1 = sin(alpha)/cos(alpha);\t// Coefficients directeurs des droites\n            float c2 = sin(beta)/cos(beta);\n            if(v.y > c1*v.x && v.y < c2*v.x) {\n                return true;\n            }\n        }\n    }\n    else if(alpha <= 3.0*3.14/2.0 && beta < 3.0*3.14/2.0) {\n        if(v.x <= 0.0 && v.y <= 0.0) {\n            float c1 = sin(alpha)/cos(alpha);\t// Coefficients directeurs des droites\n            float c2 = sin(beta)/cos(beta);\n            if(v.y > c1*v.x && v.y < c2*v.x) {\n                return true;\n            }\n        }\n    }\n    else {\n     \tif(v.x >= 0.0 && v.y <= 0.0) {\n            float c1 = sin(alpha)/cos(alpha);\t// Coefficients directeurs des droites\n            float c2 = sin(beta)/cos(beta);\n            if(v.y < c1*v.x && v.y > c2*v.x) {\n                return true;\n            }\n        }   \n    }\n    return false;\n    \n}\n\n// Rendering \n// ro, rd : Ray origin and direction\n// pip : Picture in picture boolean\nvec4 Render( in vec3 ro, in vec3 rd, bool pip )\n{\n    // Light direction\n    vec3 light1 = normalize( vec3(-0.8,-0.3,0.4) );\n   \n    \n\tvec3 col;\n    float t;\n    float w;\n    int it;\n    bool bt = IntersectTerrain( ro, rd, t , it);\n    bool bw = IntersectWater( ro, rd, w , it);\n\n    // Sky\n    if( bt==false && bw == false)\n    {\n        // Soleil\n        float soleil = 0.0;\n        vec3 rd2 = rd;\n        rd2 = rd*rd*rd*rd*rd*rd*rd*rd;\n        soleil = smoothstep(0.0, 1.0,(rd2.z*rd2.z + rd2.y*rd2.y));\n        if(rd.y > 0.0) soleil = 0.0;\n        col = mix(vec3(0.7,0.1,0.8),vec3(1.0, 0.6, 0.0),soleil);\t// Tache orange la où il y a le soleil\n        \n        // Nuit\n        float nuit = 0.0;\n        nuit = smoothstep(-0.5, 1.0, rd.y);\n        if(rd.y < -0.5) nuit = 0.0;\n        col = mix(col,vec3(0.05,0.0,0.2),nuit);\t// Tache sombre la ou il y a la nuit\n        \n        // Etoiles\n        vec3 q1 = rd + 0.02*N3(rd/0.005);\t// On deforme les points\n        vec3 q = mod(q1+0.0175, 0.025);\t\t// On les repete selon un modulo bizarre\n        q-=0.0175;\n        q = q*2.0;\n        float d = sqrt(q.x*q.x + q.z*q.z);\t// Cercle\n        if(d < 0.0008) col = mix(col,vec3(1.0),nuit);\t// Point blanc la ou il y a les etoiles\n    }\n\telse \n\t{\n        // Find first intersection by canceling intersection behind\n        if ((bt==true) && (bw==true))\n        {\n            if (t<w) { bw = false; }\n            else { bt = false; }\n        }\n        // Mountains\t\t\n        if (bt==true)\n        {\n\t\t\tvec3 p = ro + t*rd;\n        \tvec3 n = NormalTerrain( p );\n\n        \tvec3 ref = reflect( rd, n );\n        \tfloat fre = clamp( 1.0+dot(rd,n), 0.0, 1.0 );\n        \tvec3 hal = normalize(light1-rd);\n\t\t\t\n            // Herbe a partir d'une certaine hauteur\n            float herbe = 1.0;\n            herbe = smoothstep(400.0, 80.0, p.z + 150.0*Noise(p/1250.0));\n            col = mix(vec3(0.15,0.15,0.1), Herbe(p/50.0), herbe);\n            \n            // Neige\n            float neige = 0.0;\n            // Neige selon hauteur\n            neige = smoothstep(150.0, 350.0, p.z + 150.0*Noise(p/250.0));\n            // Neige selon pente\n            if(dot(n, vec3(0.0,0.0,1.0)) < 0.7) neige = 0.0;\n\t\t\t// Neige selon orientation\n            if(dot(n, vec3(1.0,0.0,0.0)) > 0.3) neige -= 0.5;\n            // Pas de neige négative\n            if(neige < 0.0) neige = 0.0;\n            \n            col=mix(col, vec3(0.7, 0.7, 0.8), neige);\n            \n            \n            //Sable\n            float sable = 1.0;\n            // Sable selon hauteur\n            sable = smoothstep(100.0, 60.0, p.z + 10.0*Noise(p/5.0));\n            \n            // Couleur de base : vec3(0.471,0.361,0.110)\n            col = mix(col, vec3(1.0,0.8,0.3), sable);\n            \n            // Volcan\n            vec3 q = p + 80.0*N3(p/50.0) + 20.0*N3(p/50.0 + iTime);\t// Cercle du volcan\n\t\t\tvec2 v = vec2(q.x, q.y) - vec2(-3800.0, -1700.0);\t// Point du cercle selon ce centre\n            float rayon = 1200.0;\n            if (length(v)*length(v) < rayon*rayon) {\t// Si on est dans le cercle\n                float volcan = 0.0;\n                volcan = smoothstep(1000.0, 800.0, length(v));\n                col = mix(col, vec3(0.0), volcan);\t// On met du noir la ou il y a le volcan\n                // Lave dans tous les secteurs indiques\n                if(dansSecteur(v, 3.14/2.0, 3.14/3.0, rayon)\n                  || dansSecteur(v, 3.14/12.0, 0.0, rayon)\n                  || dansSecteur(v, 3.14/5.0, 3.14/6.0, rayon)\n                  || dansSecteur(v, 2.0*3.14/3.0, 7.0*3.14/12.0, rayon)\n                  || dansSecteur(v, 11.0*3.14/6.0, 9.0*3.14/5.0, rayon)) {\n                    col = Lave(p/50.0);\n                }\n            }\n            \n         \t// Pseudo diffuse lighting\n\t\t\tfloat dif = 0.5*(1.0+dot( light1, n ));\n        \tdif*=dif;\n        \n        \tcol += dif*vec3(0.35,0.35,0.35);\n\n\t\t\t// fog : plus sombre vers la nuit, plus orange vers le soleil\n            float nuit = 0.0;\n        \tnuit = smoothstep(-0.5, 1.0, rd.y);\n        \tif(rd.y < -0.5) nuit = 0.0;\n        \tfloat fo = 1.0-exp(-pow(0.00015*t,1.5) );\n        \tvec3 fco = 0.85*vec3(0.4,0.65,1.0);\n        \tcol = mix( col, fco, nuit*0.7*fo);\t// Nuit\n            float jour = 1.0 - nuit;\n            fco = 0.85*vec3(1.0,0.65,0.0);\n            col = mix(col, fco, jour*fo*0.5);\t// Soleil\n        }\n        // Water\n        if (bw==true)\n        {\n \t\t\tvec3 p = ro + w*rd;\n        \tvec3 n = NormalWater( p );\n\n        \tvec3 ref = reflect( rd, n );\n        \tfloat fre = clamp( 1.0+dot(rd,n), 0.0, 1.0 );\n        \tvec3 hal = normalize(light1-rd);\n        \n\t\t\tcol = Eau(p/40.0);\n        \t\n            // Ecume selon profondeur\n            float ecume = smoothstep(0.0,200.0,t-w);\n        \tcol = mix(vec3(0.8,0.8,1.0),col,ecume);\n            \n            // \"Reflets\" blancs\n            float reflet = 1.0;\n            reflet = smoothstep(0.95,0.90,dot(n, vec3(0.0,0.0,1.0)));\t// Selon la normale\n            col = mix(col, vec3(0.7,0.7,1.0), reflet);\n            \n         \t// Pseudo diffuse lighting\n\t\t\tfloat dif = 0.5*(1.0+dot( light1, n ));\n        \tdif*=dif;\n        \n        \tcol += dif*vec3(0.35,0.35,0.35);\n\n\t\t\t// fog : plus orange vers le soleil\n            float jour = smoothstep(0.0, 1.0, (rd.z*rd.z + rd.y*rd.y));\n        \tif(rd.y > 0.0) jour = 0.0;\n        \tfloat fo = 1.0-exp(-pow(0.00015*w,1.5) );\n        \tvec3 fco = 0.85*vec3(1.0,0.65,0.0);\n        \tcol = mix( col, fco, jour*fo*0.7);\n        }\n\n\t}\n\n    \n    // Shading for iterations\n    if (pip==true)\n    {\n    float s=float(it)/float(N);\n\treturn vec4(0.112+0.824*s,0.418+0.556*s,0.611-0.515*s,t);\n    }\n    else\n    {\n    // Gamma with square root\n    return vec4( sqrt(col), t );\n    }\n\n}\n\nmat3 Camera(float a, out vec3 ro)\n{\n\t// Origin\n    ro = vec3( 0.0,0.0,800.0 );\n\t\n    // Target\n    vec3 ta = ro+vec3(500.0*cos(a),500.0*sin(a),-50.0);\n    \n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(0.0, 0.0,1.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvec2 RayDirection(in vec2 pixel, out bool pip)\n{\n    // Pixel coordinates\n    vec2 p = (-iResolution.xy + 2.0*pixel)/iResolution.y;\n   if (pip==true)\n   {    \n    const float fraction=1.0/4.0;\n    // Picture in picture\n    if ((pixel.x<iResolution.x*fraction) && (pixel.y<iResolution.y*fraction))\n    {\n        //p=(-iResolution.xy*fraction + 2.0*pixel)/(iResolution.y*fraction);\n        pip=true;\n    }\n       else\n       {\n           pip=false;\n       }\n   }\n    pip = false;\n   return p;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   // Time as function of the position of the mouse\n    float a = 6.0*iMouse.x/iResolution.x;\n\n    // Camera transform\n    vec3 ro; \n    mat3 cam = Camera( a, ro);   \n\n    // Picture in picture\n    bool pip=true;\n    \n    // Pixel coordinates\n    vec2 p = RayDirection(fragCoord, pip);\n   \n    // Camera ray    \n    vec3 rd = cam * normalize(vec3(p,5.0));\n    \n    // Render\n    vec4 res = Render( ro, rd, pip );\n     \n    fragColor = vec4( res.xyz, 0.0 );\n    \n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// Texturing\n// Eric Galin\n\n// Texturing and noise ---------------------------------------------------------\n\n// Hashing function\n// Returns a random number in [-1,1]\n// p : Vector in space\nfloat Hash(in vec3 p)  \n{\n    p  = fract( p*0.3199+0.152 );\n\tp *= 17.0;\n    return fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\n}\n\n// Procedural value noise with cubic interpolation\n// x : Point \nfloat Noise(in vec3 p)\n{\n    vec3 i = floor(p);\n    vec3 f = fract(p);\n  \n    f = f*f*(3.0-2.0*f);\n    // Could use quintic interpolation instead of cubic\n    // f = f*f*f*(f*(f*6.0-15.0)+10.0);\n\n    return mix(mix(mix( Hash(i+vec3(0,0,0)), \n                        Hash(i+vec3(1,0,0)),f.x),\n                   mix( Hash(i+vec3(0,1,0)), \n                        Hash(i+vec3(1,1,0)),f.x),f.y),\n               mix(mix( Hash(i+vec3(0,0,1)), \n                        Hash(i+vec3(1,0,1)),f.x),\n                   mix( Hash(i+vec3(0,1,1)), \n                        Hash(i+vec3(1,1,1)),f.x),f.y),f.z);\n}\n\nvec3 N3(vec3 p) {\n    return vec3(Noise(p), Noise(p + vec3(165.0,126.0,127.0)), Noise(p + vec3(34.0,242.0,342.0)));\n}\n\n// FBM\nfloat fbm(vec3 p) {\n\treturn (Noise(p) + 0.5*Noise(p/0.5) + 0.25*Noise(p/0.25) + 0.125*Noise(p/0.125))*0.5;\n}\n\n// Hashing function\n// Returns a random number in [-1,1]\n// p : Vector in the plane\nfloat Hash(in vec2 p)  \n{\n    p  = fract( p*0.3199+0.152 );\n\tp *= 17.0;\n    return fract( p.x*p.y*(p.x+p.y) );\n}\n\n\n// Procedural value noise with cubic interpolation\n// x : Point \nfloat Noise(in vec2 p)\n{\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n  \n    f = f*f*(3.0-2.0*f);\n    // Could use quintic interpolation instead of cubic\n    // f = f*f*f*(f*(f*6.0-15.0)+10.0);\n\n    return mix(mix( Hash(i+vec2(0,0)), \n                        Hash(i+vec2(1,0)),f.x),\n                   mix( Hash(i+vec2(0,1)), \n                        Hash(i+vec2(1,1)),f.x),f.y);\n}\n\nfloat Hash(in float p)  \n{\n    p  = fract( p*0.3199+0.152 );\n\tp *= 17.0;\n    return fract( p*p );\n}\n\nfloat Noise(in float p)\n{\n    float i = floor(p);\n    float f = fract(p);\n  \n    f = f*f*(3.0-2.0*f);\n    // Could use quintic interpolation instead of cubic\n    // f = f*f*f*(f*(f*6.0-15.0)+10.0);\n\n    return mix(Hash(i),Hash(i+1.0),f);\n}\n\n","name":"Common","description":"","type":"common"}]}