{"ver":"0.1","info":{"id":"l3cSR2","date":"1719266058","viewed":29,"name":"First Sample gradient","username":"L1x3N","description":"Shader that aims to reproduce the Sample Gradient node from Unity's Shader Graph, but without the 8 colors limit\nI'll use it extensively in my future works involving noise\nThanks to Jules Fouchy for helping me with some technical bits with the blend !","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["test","gradient","commented"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float SCROLL_SPEED = 0.5f;\nconst bool GRADIENT_BLEND_MODE = true;\nconst bool ASPECT_RATIO = true;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // Tableau de couleurs\n    vec3[] colorsArray = vec3[](vec3(1.0f, 0.0f, 0), vec3(0, 1.f, 0), vec3(0, 0, 1.f), vec3(0, 0, 0), vec3(1.0f, 1.0f, 1.f), vec3(1.0f, 0.0f, 0));\n\n    // Position entre 0 et 1 (début 0 -> fin 1) pour chaque couleur\n    // (Pour que ce soit seamless, mettre des positions de 0 à 1 avec la même couleur au début et à la fin)\n    float[] colorPosTab = float[](0.f / 5.f, 1.f / 5.f, 2.f / 5.f, 3.f / 5.f, 4.f / 5.f, 5.f / 5.f);\n\n    // vec2 uv = vec2(gl_FragCoord.x / iResolution.x);\n    vec2 uv = gl_FragCoord.xy / iResolution.xy;\n    if(ASPECT_RATIO) uv.x *= iResolution.x / iResolution.y;\n\n    float uvPos = fract((uv.x + uv.y) + (iTime / 2.f * SCROLL_SPEED));\n\n    // float colorPos = uvPos * (float(colorsArray.length()) - 1.f);\n    int colorPosIndex;\n\n    for(colorPosIndex = 0; colorPosIndex < (colorPosTab.length()); colorPosIndex ++) {\n        if(uvPos < colorPosTab[colorPosIndex])\n            break;\n    }\n\n    vec3 myColor;\n\n    if(GRADIENT_BLEND_MODE) { // Mode blend : lerp avec uvPos entre les 2 couleurs les plus proches avec floor et ceil\n\n        vec3 colorLower = colorsArray[colorPosIndex - 1];\n        vec3 colorUpper = colorsArray[colorPosIndex];\n\n        float colorUv = (uvPos - colorPosTab[colorPosIndex - 1]) / (colorPosTab[colorPosIndex] - colorPosTab[colorPosIndex - 1]);\n        myColor = mix(colorLower, colorUpper, colorUv);\n\n    } else { // Mode fixed : ceil de colorPos pour prendre toujours la couleur supérieure\n        myColor = colorsArray[colorPosIndex];\n    }\n\n    // myColor = uvPos < 0.5f ? mix(colorsArray[0], colorsArray[1], uvPos) : mix(colorsArray[1], colorsArray[2], uvPos);\n\n    // fragColor = vec4(vec3(uvPos), 1.0f);\n    fragColor = vec4(myColor, 1.0f);\n\n}","name":"Image","description":"","type":"image"}]}