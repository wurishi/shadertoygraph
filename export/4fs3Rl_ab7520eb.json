{"ver":"0.1","info":{"id":"4fs3Rl","date":"1732578293","viewed":178,"name":"Holographic liquid","username":"dennizor","description":"domain warping based on the master's notes at https://iquilezles.org/articles/warp/warp.htm\n","likes":7,"published":3,"flags":0,"usePreview":1,"tags":["noise","fbm","warping","animation","trippy","liquid"],"hasliked":0,"parentid":"wtXXD2","parentname":"liquid warp"},"renderpass":[{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// domain warping based on the master's notes at https://iquilezles.org/articles/warp\n\n// NOISE ////\nvec2 hash2( float n )\n{\n    return fract(sin(vec2(n,n+1.0))*vec2(13.5453123,31.1459123));\n}\n\nfloat noise( in vec2 x )\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    float a = textureLod(iChannel0,(p+vec2(0.5,0.5))/256.0,0.0).x;\n\tfloat b = textureLod(iChannel0,(p+vec2(1.5,0.5))/256.0,0.0).x;\n\tfloat c = textureLod(iChannel0,(p+vec2(0.5,1.5))/256.0,0.0).x;\n\tfloat d = textureLod(iChannel0,(p+vec2(1.5,1.5))/256.0,0.0).x;\n    return mix(mix( a, b,f.x), mix( c, d,f.x),f.y);\n}\n\nconst mat2 mtx = mat2( 0.80,  0.60, -0.60,  0.80 );\n\nfloat fbm( vec2 p )\n{\n    float f = 0.0;\n\n    f += 0.500000*noise( p ); p = mtx*p*2.02;\n    f += 0.250000*noise( p ); p = mtx*p*2.03;\n    f += 0.125000*noise( p ); p = mtx*p*2.01;\n    f += 0.062500*noise( p ); p = mtx*p*2.04;\n    f += 0.031250*noise( p ); p = mtx*p*2.01;\n    f += 0.015625*noise( p );\n\n    return f/0.96875;\n}\n\n// -----------------------------------------------------------------------\n\nfloat pattern(in vec2 p, in float t, in vec2 uv, out vec2 q, out vec2 r, out vec2 g)\n{\n\tq = vec2(fbm(p), fbm(p + vec2(10, 1.3)));\n    \n    float s = dot(uv.x + 0.5, uv.y + 0.5);\n    r = vec2(fbm(p + 4.0 * q + vec2(t) + vec2(1.7, 9.2)), fbm(p + 4.0 * q + vec2(t) + vec2(8.3, 2.8)));\n    g = vec2(fbm(p + 2.0 * r + vec2(t * 20.0) + vec2(2, 6)), fbm(p + 2.0 * r + vec2(t * 10.0) + vec2(5, 3)));\n    return fbm(p + 5.5 * g + vec2(-t * 7.0));\n}\n\n// Gradient Function\nvec3 getGradientColor(float t) {\n    // Convert provided RGB colors to vec3 with range 0-1\n    vec3 color1 = vec3(255.0, 199.0, 51.0) / 255.0; // Yellow\n    vec3 color2 = vec3(245.0, 42.0, 116.0) / 255.0; // Red\n    vec3 color3 = vec3(7.0, 49.0, 143.0) / 255.0; // Blue\n    vec3 color4 = vec3(71.0, 205.0, 255.0) / 255.0; // Cyan\n    vec3 color5 = vec3(185.0, 73.0, 255.0) / 255.0; // Purple\n    vec3 color6 = vec3(255.0, 180.0, 204.0) / 255.0; // Pink\n    \n    // Fixed ratios for color transitions\n    float ratio1 = 0.1; // Transition point for color1 and color2\n    float ratio2 = 0.3; // Transition point for color2 and color3\n    float ratio3 = 0.6; // Transition point for color3 and color4\n    float ratio4 = 0.8; // Transition point for color4 and color5\n\n    if (t < ratio1)\n        return mix(color1, color2, t / ratio1);\n    else if (t < ratio2)\n        return mix(color2, color3, (t - ratio1) / (ratio2 - ratio1));\n    else if (t < ratio3)\n        return mix(color3, color4, (t - ratio2) / (ratio3 - ratio2));\n    else if (t < ratio4)\n        return mix(color4, color5, (t - ratio3) / (ratio4 - ratio3));\n    else\n        return mix(color5, color6, (t - ratio4) / (1.0 - ratio4));\n}\n\n\n\n// Main Image Function\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // Define zoom and speed factors\n    float zoom = 0.05; // Example zoom value; smaller values zoom in\n    float speed = 0.2; // Example speed value; larger values speed up the animation\n\n    // Apply zoom by scaling the fragment coordinates\n    vec2 zoomedCoord = fragCoord * zoom;\n\n    // Apply speed by scaling the time\n    float adjustedTime = iTime * speed;\n\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = zoomedCoord / iResolution.xy;\n\n    // Noise generation with zoomed and time-adjusted coordinates\n    vec2 q, r, g;\n    float noise = pattern(zoomedCoord * vec2(.004), adjustedTime * 0.007, uv, q, r, g);\n\n    // Convert noise to a value between 0 and 1\n    float t = fract(noise * 2.6 - 1.0);\n\n    // Get color from gradient\n    vec3 col = getGradientColor(t);\n\n    // Apply a vignette effect\n    col *= 0.5 + 0.5 * pow(16.0 * uv.x * uv.y * (1.0 - uv.x) * (1.0 - uv.y), 0.1);\n\n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}