{"ver":"0.1","info":{"id":"Mcjfzc","date":"1725313462","viewed":17,"name":"Chessboard tunnel with speres","username":"vivid_bw","description":"Reflective spheres are flying inside chessboard tunnel","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["reflection","tunnel","spheres","chessboard"],"hasliked":0,"parentid":"McXfzj","parentname":"Chessboard with spheres"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"mat3 rotX(float angle) {\n    float s = sin(angle); float c = cos(angle);\n    return mat3(1., 0., 0., 0., c, s, 0., -s, c);\n}\n\nmat3 rotY(float angle) {\n    float s = sin(angle); float c = cos(angle);\n    return mat3(c, 0., -s, 0., 1., 0., s, 0.0, c);\n}\n\nmat3 rotZ(float angle) {\n    float s = sin(angle); float c = cos(angle);\n    return mat3(c, s, 0., -s, c, 0., 0., 0., 1.);\n}\n\nstruct Ray\n{\n    vec3 start;\n    vec3 dir;\n};\n\nstruct Sphere\n{\n    vec3 center;\n    float radius;\n};\n\nstruct Intersection\n{\n    float time;\n    vec3 pos;\n    vec3 normal;\n    vec4 color;\n};\n\nconst float Infinity = 1e20;\nconst float Pi = 3.14159265;\n\nIntersection crossSphere(Sphere sphere, Ray ray)\n{\n    Ray rayInv = ray;\n    // transform ray to make sphere\n    rayInv.start -= sphere.center;\n    rayInv.start /= sphere.radius;\n    rayInv.dir /= sphere.radius;\n    \n    float a = dot(rayInv.dir, rayInv.dir);\n    float b = dot(rayInv.start, rayInv.dir);\n    float c = dot(rayInv.start, rayInv.start) - 1.;\n    float d = b * b - a * c;\n    float t = (-b - sqrt(d)) / a;\n    if (d < 0. || t < 1e-5)\n    {\n        return Intersection(Infinity, vec3(0.), vec3(0.), vec4(1.));\n    }\n    vec3 pos = ray.start + t * ray.dir;\n    vec3 norm = normalize(pos - sphere.center);\n    return Intersection(t, pos, norm, vec4(1.));\n}\n\nvec4 shade(vec3 vnorm, vec3 lnorm, vec3 n, vec4 c, vec4 lc)\n{\n    vec4 diffuse = max(0., dot(n, lnorm)) * c;\n    vec3 r = reflect(-lnorm, n);\n    vec4 specular = pow(max(0., dot(vnorm, r)), 10.) * lc;\n    return diffuse + specular;\n}\n\nIntersection crossPlane(vec4 plane, Ray ray)\n{\n    float t = -dot(vec4(ray.start, 1.), plane) / dot(ray.dir, plane.xyz);\n    if (t < 1e-5 || t > Infinity)\n    {\n        return Intersection(Infinity, vec3(Infinity), normalize(plane.xyz), vec4(1.));\n    }\n    return Intersection(t, ray.start + ray.dir * t, normalize(plane.xyz), vec4(1.));\n}\n\nIntersection crossSpheres(Ray ray)\n{\n    Intersection best = Intersection(Infinity, vec3(0.), vec3(0.), vec4(1.));\n    for (float angle = 0.; angle < Pi + Pi - 1e-4; angle += Pi / 6.)\n    {\n        Intersection i = crossSphere(\n            Sphere(\n                1.2 * vec3(cos(angle + iTime), \n                    .3 * sin(3. * iTime + 2. * angle), \n                    sin(angle + iTime)), 0.2), ray);\n        if (i.time < best.time)\n        {\n            best = i;\n            best.color.rgb *= vec3(cos(angle * 1.5), sin(angle * 3.), sin(angle * 2.)) * .3 + .7;\n        }\n    }\n    return best;\n}\n\nIntersection ptOnCylinder(Ray r, float t, vec4 shade)\n{\n    vec3 pos = r.start + r.dir * t;\n    float angle = atan(pos.y, pos.x) / Pi * 4.;\n    vec3 normal = normalize(vec3(-pos.xy, 0.));\n    vec2 chess = fract(vec2(angle, pos.z + 3. * iTime)) - .5;\n    float nDotV = dot(normal, -normalize(pos));\n    vec4 color = sign(chess.x * chess.y) * smoothstep(10., 1., pos.z) * shade * nDotV;\n    //vec4 color = vec4(normal * 0.5 + 1., 0.);\n    //vec4 color = vec4(pos, 0.);\n    return Intersection(t, pos, normal, color);\n}\n\nIntersection crossCylinder(Ray r0, float radius, vec4 shade)\n{\n    Ray ray = Ray(r0.start / radius, r0.dir / radius);\n    float a = dot(ray.dir.xy, ray.dir.xy);\n    float b = dot(ray.start.xy, ray.dir.xy);\n    float c = dot(ray.start.xy, ray.start.xy) - 1.;\n    float d = b * b - a * c;\n    if (d >= 0.)\n    {\n        float sd = sqrt(d);\n        float t0 = (-b - sd) / a;\n        float t1 = (-b + sd) / a;\n        if (t0 > 0. && t1 > 0.)\n        {\n            return ptOnCylinder(r0, min(t0, t1), shade);\n        }\n        if (t0 > 0.)\n        {\n            return ptOnCylinder(r0, t0, shade);\n        }\n        if (t1 > 0.)\n        {\n            return ptOnCylinder(r0, t1, shade);\n        }\n    }\n    return Intersection(Infinity, vec3(0.), vec3(0.), vec4(0.));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = 2. * fragCoord / iResolution.xy - 1.;\n    float rTime = max(0., iTime - 5.);\n    vec3 r = vec3(uv.x, uv.y * iResolution.y / iResolution.x,  1.);\n    r = r * rotX(-rTime * 0.5) * rotY(-rTime * .7) * rotZ(rTime * .3);\n    Ray ray = Ray(vec3(0.), r);\n    \n    vec4 shade = vec4(1.);\n    int iter = 3;\n    do\n    {\n        Intersection i = crossSpheres(ray);\n        if (i.time >= Infinity)\n        {\n            break;\n        }\n        ray.dir = reflect(ray.dir, i.normal);\n        ray.start = i.pos + 1e-5 * ray.dir;    \n        shade *= i.color;\n    } while (--iter > 0);\n    \n    Intersection i = crossCylinder(ray, 1., shade);\n    fragColor = i.color;\n}","name":"Image","description":"","type":"image"}]}