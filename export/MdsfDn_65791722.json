{"ver":"0.1","info":{"id":"MdsfDn","date":"1495786108","viewed":399,"name":"Spikeball_v2","username":"tholzer","description":"Modified spikeball demo from Patapom's  https://www.shadertoy.com/view/lds3WH\n\nWhat kind of basic polyhedron is this?","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["3d","sphere","animated","ball","spherical","spike"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//-------------------------------------------------------\n// Spikeball_v2.glsl    \n// Modified spikeball demo from Patapom, \n//   see  https://www.shadertoy.com/view/lds3WH\n// which code was stolen from pouet.net and adapted\n//-------------------------------------------------------\n\n#define t iTime*0.1\n\nfloat spikeball(vec3 p, vec3 v)\n{\n  vec3 c[19];\n  c[0] = vec3(1,0,0);\n  c[1] = vec3(0,1,0);\n  c[2] = vec3(0,0,1);\n  c[3] = vec3(.577,.577,.577);\n  c[4] = vec3(-.577,.577,.577);\n  c[5] = vec3(.577,-.577,.577);\n  c[6] = vec3(.577,.577,-.577);\n  c[7] = vec3(0,.357,.934);\n  c[8] = vec3(0,-.357,.934);\n  c[9] = vec3(.934,0,.357);\n  c[10] = vec3(-.934,0,.357);\n  c[11] = vec3(.357,.934,0);\n  c[12] = vec3(-.357,.934,0);\n  c[13] = vec3(0,.851,.526);\n  c[14] = vec3(0,-.851,.526);\n  c[15] = vec3(.526,0,.851);\n  c[16] = vec3(-.526,0,.851);\n  c[17] = vec3(.851,.526,0);\n  c[18] = vec3(-.851,.526,0);\n\n  float MinDistance = 9999.;\n  for ( int i=3; i < 19; i++ )\n  {\n    float d = clamp( dot( p, c[i] ), -1.0, 1.0 );\n    vec3 proj = d * c[i];\n    d = abs( d );\n\t\t\n    float Distance2Spike = length( p - proj );\n    float sd = 1.4+ 0.6*sin(t*8.);\n    float SpikeThickness = 01. * exp( -sd*d ) + 0.0;\n    float Distance = Distance2Spike - SpikeThickness;\n    MinDistance = min( MinDistance, Distance );\n  }\n  return MinDistance;\t\n}\n\n// Rotation\n#define R(p, a) p=cos(a)*p+sin(a)*vec2(p.y,-p.x)\n\nfloat Distance( vec3 p, vec3 v )\n{\n\tvec3 q = p;\n\tR( p.yz, t );\n\tR( p.xz, 2.0*t + p.x*sin(t)*0.2 );\n\tfloat d = spikeball(p, v);\n//return d;   // black background\n\tfloat nd = dot( q + vec3(0.0, 3.0, 0.0), vec3(0.0, 1.0, 0.0));\n\treturn min( nd, d );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = fragCoord.xy / iResolution.xy;\n  vec2 aspect = vec2( iResolution.x / iResolution.y, 1 );\n  vec3 p = vec3( 0, 0, 12 );\n  vec3 v = vec3( (2.0 * uv - 1.0) * aspect, 0 ) ;\n  v = 0.8*normalize(v - p*0.7);\n  \n  // Raymarching loop\n  float r, l, a, s, ml=0.0001;\n  for ( int i=0; i < 64; i++ )\n  {\n    l = Distance(p, v);\n    p += l*v;\n    l = abs(l);\n    r += l;\n    if (l < ml*r) break;\n  }    \n\t\n  // Compute normal\n  vec2 epsilon = vec2( 0.001,0.0 );\n  float pd = Distance(p, v);\n  vec3 n = vec3( Distance(p+epsilon.xyy, v) - pd,\n                 Distance(p+epsilon.yxy, v) - pd,\n                 Distance(p+epsilon.yyx, v) - pd);\n  float c = 1.0 + dot(normalize(n),v);\n  fragColor = vec4(c,c,c, 1.0); \n}\n","name":"Image","description":"","type":"image"}]}