{"ver":"0.1","info":{"id":"XdyBWD","date":"1528930045","viewed":538,"name":"alijaya - Raytracer again","username":"alijaya","description":"raytracer again with reflection","likes":6,"published":3,"flags":0,"usePreview":0,"tags":["raytracer"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"struct Ray {\n    vec3 origin;\n    vec3 direction;\n};\n    \nstruct Material {\n    vec3 ambient;\n    vec3 emission;\n    vec3 diffuse;\n    vec3 specular;\n    float shininess;\n};\n\nstruct HitInfo {\n    Ray ray;\n    bool isHit;\n    float dist;\n    vec3 normal;\n    Material material;\n};\n\nstruct Sphere {\n    vec3 center;\n    float radius;\n    Material material;\n};\n\nstruct Light {\n    bool directional;\n    vec3 position;\n    vec3 color;\n    float attenuation_constant;\n    float attenuation_linear;\n    float attenuation_quadratic;\n};\n\nvec3 camera_position;\nvec3 camera_target;\nvec3 camera_up;\nfloat aspect;\nfloat fovy;\nvec2 mouse;\nfloat PI = acos(-1.);\nfloat EPS = 0.001;\nvec3 ambientLight;\nLight lights[4];\nint numLights = 0;\nconst int maxDepth = 2;\n\nvoid addLight( Light light ) {\n    lights[numLights] = light;\n    numLights++;\n}\n\nHitInfo hitSphere( Ray ray, Sphere sphere ) {\n    // p = o + d * t\n    // (p - c) . (p - c) - r * r = 0\n    // (o + d * t - c) . (o + d * t - c) - r * r = 0\n    // (d . d) tt + 2 (d . (o - c)) t + ((o - c) . (o - c) - rr) = 0\n    \n    \n    vec3 co = ray.origin - sphere.center;\n    float a = dot(ray.direction, ray.direction);\n    float b = 2. * dot(ray.direction, co);\n    float c = dot(co, co) - sphere.radius * sphere.radius;\n    \n    float det = b * b - 4. * a * c;\n    \n    HitInfo hit;\n    hit.ray = ray;\n    if (det < 0.) {\n        hit.isHit = false;\n    } else {\n        hit.isHit = true;\n        \n        float t1 = (-b + sqrt(det)) / (2. * a);\n        float t2 = (-b - sqrt(det)) / (2. * a);\n        \n        if (t1 < 0. && t2 < 0.) {\n            hit.isHit = false;\n        } else if (t1 < 0.) {\n            hit.dist = t2;\n        } else if (t2 < 0.) {\n            hit.dist = t1;\n        } else {\n            hit.dist = min(t1, t2);\n        }\n    }\n    \n    if (hit.isHit) {\n        vec3 p = ray.origin + ray.direction * hit.dist;\n        hit.normal = normalize(p - sphere.center);\n        hit.material = sphere.material;\n    }\n    \n    return hit;\n}\n\nHitInfo selectHit( HitInfo a, HitInfo b ) {\n    if (!a.isHit) return b;\n    if (!b.isHit) return a;\n    if (a.dist < b.dist) return a;\n    else return b;\n}\n\nHitInfo castRay( Ray ray ) {\n    HitInfo hit;\n    \n    for (float i=0.; i<5.; i++) {\n        for (float j=0.; j<5.; j++) {\n            Sphere sp;\n            sp.center = vec3(j-2., i-2., 2.*sin(3.*iTime+i+j));\n            sp.radius = 0.4;\n            sp.material.ambient = vec3(1.);\n            sp.material.diffuse = vec3(i/5., 1., 1.);\n            sp.material.specular = vec3(0.5);\n            sp.material.shininess = (j+1.) * 10.;\n            \n            hit = selectHit(hit, hitSphere(ray, sp));\n        }\n    }\n    \n    return hit;\n}\n\nHitInfo castRayToLight( Ray ray ) {\n    HitInfo hit;\n    \n    for (int i=0; i<numLights; i++) {\n        Light l = lights[i];\n        Sphere sp;\n        sp.center = l.position;\n        sp.radius = 0.1;\n        sp.material.emission = l.color;\n        hit = selectHit(hit, hitSphere(ray, sp));\n    }\n    \n    return hit;\n}\n\nvec3 getColor( HitInfo hit ) {\n    HitInfo hitStack[maxDepth];\n    int depth = 0;\n    hitStack[depth] = hit;\n    \n    while (depth < maxDepth-1) {\n        hit = hitStack[depth];\n        if (!hit.isHit) break;\n        if (dot(hit.material.specular, hit.material.specular) <= 0.) break;\n        \n        vec3 p = hit.ray.origin + hit.ray.direction * hit.dist;\n        vec3 N = hit.normal;\n        vec3 E = normalize(- hit.ray.direction);\n        \n        Ray ray;\n        ray.direction = 2. * dot(N, E) * N - E;\n        ray.origin = p + ray.direction * EPS;\n        HitInfo h = castRay(ray);\n        hitStack[depth+1] = h;\n        \n        depth++;\n    }\n    \n    depth++;\n    \n    vec3 lastColor = vec3(0.);\n    while (depth > 0) {\n        depth--;\n    \t\n        hit = hitStack[depth];\n        if (!hit.isHit) {\n            lastColor = vec3(0.);\n            continue;\n        }\n\n        vec3 p = hit.ray.origin + hit.ray.direction * hit.dist;\n        vec3 N = hit.normal;\n        vec3 E = normalize(- hit.ray.direction);\n\n        // reflection\n        vec3 color = lastColor * hit.material.specular;\n\n        // ambient\n        color += ambientLight * hit.material.ambient + hit.material.emission;\n        for (int i=0; i<numLights; i++) {\n            Light l = lights[i];\n\n            float dist = distance(l.position, p);\n            \n            vec3 L;\n            if (l.directional) L = normalize(l.position);\n            else L = normalize(l.position - p);\n            \n            vec3 H = normalize(E + L);\n\n            // attenuation\n            float attenuation;\n            if (l.directional) attenuation = 1.;\n            else attenuation = l.attenuation_quadratic * dist * dist +\n                                l.attenuation_linear * dist +\n                                l.attenuation_constant;\n\n            // shadow\n            Ray ray;\n            ray.direction = L;\n            ray.origin = p + ray.direction * EPS;\n            HitInfo h = castRay(ray);\n\n            if (!h.isHit || h.dist > dist) { // if there's no other object obstructing\n\n                // diffuse\n                color += l.color / attenuation * hit.material.diffuse * max(dot(N, L), 0.);\n\n                // specular\n                color += l.color / attenuation * hit.material.specular * pow(max(dot(N, H), 0.), hit.material.shininess);\n\n            }\n        }\n        \n        lastColor = color;\n    }\n    \n    return lastColor;\n}\n\nvec3 getImage( vec2 coord ) {\n    // setup camera\n    float camera_distance = 6.;\n    camera_position = vec3(-sin(mouse.x * PI) * camera_distance, mouse.y * camera_distance, -cos(mouse.x * PI) * camera_distance);\n    camera_target = vec3(0., 0., 0.);\n    camera_up = vec3(0., 1., 0.);\n    fovy = 50.; // in degrees\n    \n    // setup lighting\n    ambientLight = vec3(0., 0., 0.1);\n    \n    Light pl1;\n    pl1.directional = false;\n    pl1.position = vec3(4. * cos(3.*iTime), 4. * sin(3.*iTime), 2.);\n    pl1.color = vec3(0.5);\n    pl1.attenuation_quadratic = 0.1;\n    addLight(pl1);\n    \n    Light pl2;\n    pl2.directional = false;\n    pl2.position = vec3(3. * cos(2.*iTime), 0., 3. * sin(2.*iTime));\n    pl2.color = vec3(0.7, 0.3, 0.5);\n    pl2.attenuation_linear = 0.3;\n    addLight(pl2);\n    \n    Light dl1;\n    dl1.directional = true;\n    dl1.position = vec3(3., 3., 3.);\n    dl1.color = vec3(0.7);\n    addLight(dl1);\n    \n    Light dl2;\n    dl2.directional = true;\n    dl2.position = vec3(-3., -3., -3.);\n    dl2.color = vec3(0.7, 0.3, 0.);\n    addLight(dl2);\n    \n    // make camera coordinate\n    vec3 w = normalize( camera_position - camera_target );\n    vec3 u = normalize(cross( camera_up, w ));\n    vec3 v = normalize(cross( w, u ));\n    mat3 giri = mat3(u, v, w);\n    \n    float hasil_tan = tan(radians(fovy / 2.));\n    vec3 ali;\n    ali.y = hasil_tan * coord.y;\n    ali.x = aspect * hasil_tan * coord.x;\n    ali.z = -1.;\n    \n    Ray ray;\n    ray.origin = camera_position;\n    ray.direction = giri * ali;\n    \n    HitInfo hit = selectHit(castRay(ray), castRayToLight(ray));\n    \n    return getColor(hit);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= 0.5;\n    uv *= 2.;\n    aspect = iResolution.x / iResolution.y;\n    \n    mouse = iMouse.xy/iResolution.xy;\n    mouse -= 0.5;\n    mouse *= 2.;\n    \n    //fragColor = vec4(fract(uv), 1., 1.);\n    fragColor = vec4(getImage(uv), 1.);\n}","name":"Image","description":"","type":"image"}]}