{"ver":"0.1","info":{"id":"ftVSDK","date":"1641926426","viewed":187,"name":"Screen saver with 3 vectors","username":"DomenPigeon","description":"I made a very simple scren saver, which I have stumbled upon while learning how to use buffers for memory and how to draw vectors.\nYou can uncomment the first line to show how the 3 vectors move in order to draw the shape on the screen.","likes":4,"published":1,"flags":32,"usePreview":0,"tags":["vector","screensaver"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//#define SHOW_VECTORS\n//#define SHOW_BUFFER_A\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = (2.*fragCoord-iResolution.xy) / iResolution.y;\n    vec4 col = vec4(0);\n    int frame = iFrame + added_frames;\n\n    for (int i=0; i<memory_length && frame >= i; i++) {\n        int pos_x = (frame-i) % memory_length;\n        vec4 v1 = texelFetch(iChannel0, ivec2(pos_x, vec1_mem_y), 0);\n        vec4 v2 = texelFetch(iChannel0, ivec2(pos_x, vec2_mem_y), 0);\n        vec4 v3 = texelFetch(iChannel0, ivec2(pos_x, vec3_mem_y), 0);\n        vec2 start = vec2(v1.x, v1.y);\n        vec2 end = vec2(v3.z, v3.w);\n        \n        vec4 line_col = texelFetch(iChannel0, ivec2(pos_x, col_mem_y), 0);\n\n        float d = line(uv, start, end);\n        vec4 c = mix(col, line_col, d);\n        col = mix(col, c, .2);\n    }\n    \n    #ifdef SHOW_BUFFER_A\n    ivec2 iuv = ivec2(int(fragCoord.x), int(fragCoord.y));\n    vec4 buf_col = texelFetch(iChannel0, iuv, 0);\n    col = mix(buf_col, col, 0.5);\n    #endif\n    \n    #ifdef SHOW_VECTORS\n    vec4 v1 = texelFetch(iChannel0, ivec2(0, vec1_mem_y), 0);\n    vec4 v2 = texelFetch(iChannel0, ivec2(0, vec2_mem_y), 0);\n    vec4 v3 = texelFetch(iChannel0, ivec2(0, vec3_mem_y), 0);\n    \n    float d =  smoothstep(0.0018, 0.0024, sdArrow(uv, v1.xy, v1.zw));\n    d = min(d, smoothstep(0.0018, 0.0024, sdArrow(uv, v2.xy, v2.zw)));\n    d = min(d, smoothstep(0.0018, 0.0024, sdArrow(uv, v3.xy, v3.zw)));\n    col = mix(vec4(1), col, vec4(d));\n    #endif\n    \n    fragColor = col;\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"const float line_width = 0.001;\nconst float line_fade = line_width * 3.7;\n\nconst int memory_length = 300;\nconst int vec1_mem_y = 50;\nconst int vec2_mem_y = 100;\nconst int vec3_mem_y = 150;\nconst int col_mem_y = 200;\nconst int added_frames = 3000;\n\nfloat sdSegment(vec2 p, vec2 a, vec2 b) {\n    float x = clamp(dot(b-a, p-a) / dot(b-a, b-a), 0.0, 1.0);\n    vec2 d = p - a - x * (b - a);\n    return length(d);\n}\n\nfloat sdArrow(vec2 p, vec2 a, vec2 b) {\n    float arrow = sdSegment(p, a, b);\n    \n    vec2 dir = normalize(b - a);\n    // We get the normal if we flip the x and y of arrow_direction\n    // and we multiply the arrow_direction.y with -1\n    vec2 normal = vec2(-dir.y, dir.x);\n    float len = length(b - a);\n    \n    float mar = clamp(0.1 * len, 0.02, 0.04);\n    vec2 p1 = (b - dir * mar) + normal * mar * 0.7;\n    vec2 p2 = (b - dir * mar) - normal * mar * 0.7;\n    \n    arrow = min(sdSegment(p, p1, b), arrow);\n    arrow = min(sdSegment(p, p2, b), arrow);\n    return arrow;\n}\n\nfloat line(vec2 p, vec2 a, vec2 b) {\n    float x = clamp(dot(b-a, p-a) / dot(b-a, b-a), 0.0, 1.0);\n    vec2 d = p - a - x * (b - a);\n    \n    float len = length(d);\n    if (len < line_width && x >= 0.0 && x <= 1.0) {\n        return 1.0;\n    }\n    else {\n        // Generate fade\n        float fade = max(0.0, line_width + line_fade - len) / line_fade;\n        return fade;\n    }\n}","name":"Common","description":"","type":"common"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    int mem_x = int(fragCoord.x);\n    int mem_y = int(fragCoord.y);\n    int frame = iFrame + added_frames;\n\n    for (int i=0; i < memory_length && frame >= i; i++) {\n        if (mem_x != i) continue;\n        \n        float t = float(frame - i) * (1./120.);\n        vec2 uv = fragCoord/iResolution.xy;\n\n        float curve_switch = sin(t  * 0.5);\n        curve_switch += 1.;\n        curve_switch /= 2.; \n\n        vec2 v1a1 = vec2(cos(3.121234*t), sin(1.1234*t));\n        vec2 v1a2 = vec2(cos(t), sin(t));\n\n        vec2 v1a = mix(v1a1, v1a2, curve_switch);\n        vec2 v1b = vec2(2.5*cos(t), sin(t)) * 0.2;\n        vec2 v1d = normalize(v1b-v1a);\n\n        vec2 v2a = v1b;\n        vec2 v2b = v1b + vec2(cos(4.532*t), sin(1.123*t)) * 0.3;\n\n        vec2 v3a = v2b;\n        vec2 v3b = v2b + vec2(cos(1.*t), sin(3.*t)) * 0.2;\n\n        if (mem_y <= vec1_mem_y){\n            fragColor = vec4(v1a, v1b);\n        }\n\n        else if (mem_y <= vec2_mem_y){\n            fragColor = vec4(v2a, v2b);\n        }\n\n        else if (mem_y <= vec3_mem_y){\n            fragColor = vec4(v3a, v3b);\n        }\n        else {\n            vec2 uv = (2.*fragCoord-iResolution.xy)/iResolution.y;\n            vec3 col = 0.5 + 0.5*cos(t+uv.xyx+vec3(0,2,4));\n            fragColor = vec4(col,1.0);\n        }\n    }\n}\n","name":"Buffer A","description":"","type":"buffer"}]}