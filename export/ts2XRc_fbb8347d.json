{"ver":"0.1","info":{"id":"ts2XRc","date":"1554959356","viewed":112,"name":"unnatural girl","username":"taso69","description":"Inspired by MV of Perfume「不自然なガール」\nhttps://youtu.be/kfqToOh7MVA?t=30","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["3d","raymarching","tetrahedron"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14195265359\n\nmat2 rotate(float a)\n{\n\tfloat s = sin(a);\n\tfloat c = cos(a);\n\treturn mat2(c, -s,s, c);\n}\n\n//https://www.shadertoy.com/view/Ws23zt\nfloat sdTetra(vec3 pos,float i){\n    pos.xy *= rotate(iTime+i);\n    pos.xz *= rotate(iTime*2.0);\n    return (max(abs(pos.x+pos.y)-pos.z,abs(pos.x-pos.y)+pos.z)-0.2)/sqrt(3.);\n}\n\nfloat sdPlane( vec3 pos){\n    vec3 n = normalize(vec3(0.0,1.0,0.0)); \n\treturn dot(pos,n.xyz);\n}\n\nfloat sdBox(vec3 pos, vec3 b){\n    vec3 d = abs(pos) - b;\n    return length(max(d,0.0)) + min(max(d.x,max(d.y,d.z)),0.0);\n}\n\nfloat sdPanel(vec3 pos){\n    float d = sdBox(pos,vec3(0.9,0.9,0.01));\n    d = max(d, -sdBox(pos-vec3(0.9,0.0,0.0),vec3(0.1,0.2,0.02)));\n    d = max(d, -sdBox(pos-vec3(-0.9,0.0,0.0),vec3(0.1,0.2,0.02)));\n    d = max(d, -sdBox(pos-vec3(0.0,0.9,0.0),vec3(0.2,0.1,0.02)));\n    d = max(d, -sdBox(pos-vec3(0.0,-0.9,0.0),vec3(0.2,0.1,0.02)));\n    return d;\n}\n\nvec3 rotPanel(vec3 p,vec3 id, float rep){\n    p.xy = mod(p.xy,rep)-rep*0.5; \n    \n    float c = 4.0;//rotation cycle\n    float d = 0.2;\n    float mt = mod(iTime,c);\n    float t = clamp(mt - (c-d), 0.0, 1.0)/d;\n    float rad =  mix(floor(iTime/c),floor(iTime/c+1.0),t)*PI/2.0;\n    p.xy *= rotate(rad);\n    //p.xy *= rotate(rad*(1.0-2.0*mod(id.y,2.0)));//switch the rotation direction by each row\n    return p;\n}\n\n\nvec2 map(vec3 pos){\n    float rep = 2.0;\n    float d = 100000.0;\n    float m = -1.0;\n    vec3 id = floor(pos/rep);\n    \n    float plane = sdBox(pos-vec3(0.0,-0.01,4.0),vec3(5.0,0.1,5.0));\n    d = min(d,plane);\n    m = (d < plane) ? m : 1.0;\n    \n    vec3 p = pos;\n    p.x += (1.0-2.0*mod(floor(p.y/rep),2.0))*iTime;\n    p = rotPanel(p,id,rep);\n    \n    if(id.x > -7.0 && id.x < 6.0 && id.y > -1.0 && id.y < 4.0){\n        float panel = sdPanel(p-vec3(0.0,0.0,2.0)); \n   \t\td = min(d,panel);\n        m = (d < panel) ? m : 2.0;\n    }\n\t\n    vec3 t1= vec3(-0.5,1.0,4.0),t2=vec3(0.0,1.0,4.0),t3=vec3(0.5,1.0,4.0);\n    t1.x += 2.0*sin(iTime*1.1); t1.y += 0.6*cos(iTime*1.3); t1.z += -1.0*sin(iTime*2.9);\n    t2.x += 2.0*cos(iTime*2.1); t2.y += -0.6*cos(iTime*0.8); t2.z += 1.0*sin(iTime*1.5);\n    t3.x += -2.0*sin(iTime*0.6); t3.y += 0.6*sin(iTime*2.5); t3.z += 1.0*cos(iTime*1.2);\n    float tetra = min(sdTetra(pos-t1,1.0),\n                     min(sdTetra(pos-t2,2.0),sdTetra(pos-t3,3.0)));\n    d = min(d,tetra);\n    m = (d < tetra) ? m : 3.0;\n\t\n    return vec2(d,m);\n}\n\n//https://www.shadertoy.com/view/Xds3zN\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n    // bounding volume\n    float tp = (10.0-ro.y)/rd.y; if( tp>0.0 ) tmax = min( tmax, tp );\n\n    float res = 1.0;\n    float t = mint;\n    for( int i=0; i<16; i++ )\n    {\n\t\tfloat h = map( ro + rd*t ).x;\n        res = min( res, 8.0*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( res<0.005 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\nvec3 calcNorm(vec3 pos)\n{\n    float d = 0.0001;\n    return normalize(vec3(\n        map(pos + vec3(  d, 0.0, 0.0)).x - map(pos + vec3( -d, 0.0, 0.0)).x,\n        map(pos + vec3(0.0,   d, 0.0)).x - map(pos + vec3(0.0,  -d, 0.0)).x,\n        map(pos + vec3(0.0, 0.0,   d)).x - map(pos + vec3(0.0, 0.0,  -d)).x\n    ));\n}\n\nvec3 texPanel(vec2 uv,vec2 id){\n    //range of uv : [-1,1]\n    float y =  mod(id.x,2.0) == 0.0 ? uv.y : -uv.y ;\n    vec3 c1,c2,c3,c4;\n    \n    float u = mod(id.x,2.0);\n    float v = mod(id.y,2.0);\n    \n    c1 = (u == 0.0) ? vec3(0.58, 0.9, 0.45) : vec3(0.07, 0.1, 0.55);\n    c2 = (u == 0.0) ? vec3(0.07, 0.1, 0.55) : vec3(0.58, 0.9, 0.45);\n    c3 = (u == 0.0) ? vec3(0.82, 0.12, 0.22) : vec3(0.36, 0.0, 0.48);\n    c4 = (u == 0.0) ? vec3(0.36, 0.0, 0.48) : vec3(0.82, 0.12, 0.22);\n    \n    float d1 = smoothstep(uv.x-0.05,uv.x,uv.y);\n    float d2 = smoothstep(uv.x-0.05,uv.x,-uv.y);\n    \n    vec3 p1 = mix(c1,c2,d1);\n    vec3 p2 =  mix(c3,c4,d2); \n    return u == v ? p1 : p2;\n}\n\nvec3 texPlane(vec2 uv){\n    vec3 col = vec3(0.0);\n    vec2 id = floor(uv/0.4);\n    float u = mod(id.x,4.0);\n    \n    if(u == 0.0) col = vec3(0.9);\n    if(u == 2.0) col = vec3(1.3);\n    \n    return col;\n}\n\nvec3 light = normalize(vec3(0.0,2.0,3.0));\n\nvec3 render(vec3 ro, vec3 rd){\n    vec3 col = vec3(0.0);\n    \n    float t = 0.0;\n    vec2 m;\n    vec3 pos;\n    for(int i = 0; i < 128; i++){\n        pos = ro + t*rd;\n      \tm = map(pos);\n        t += m.x*0.8;\n    }\n    pos = ro + t*rd;\n    \n    if(abs(m.x) < 0.0001){\n    \tvec3 norm = calcNorm(pos);\n        vec3 v = normalize(ro-pos);\n        vec3 l = normalize(light-pos);\n        vec3 r = normalize(reflect(-l,norm));\n    \n        float diff = clamp(dot(light, norm), 0.1, 1.0);\n        float spec = pow(max(dot(r,v), 0.0), 64.0);\n        float shadow = calcSoftshadow( pos, light, 0.02, 2.5 );\n        diff *=  shadow;\n      \n        vec3 tex;\n        if(m.y == 1.0){\n            tex = texPlane(pos.xz);\n        }\n        \n        if(m.y == 2.0){\n        \tfloat rep = 2.0;\n        \tvec3 p = pos;\n        \tp.x += (1.0-2.0*mod(floor(p.y/rep),2.0))*iTime;\n        \tvec3 id = floor(p/rep);\n        \n        \tp = rotPanel(p,id,rep);\n        \ttex = texPanel(p.xy,id.xy);\n        }\n        \n        if(m.y == 3.0){\n          tex = vec3(1.0,0.1,0.1);\n        }\n               \n    \tcol = clamp(vec3(diff)* tex,0.0,1.0) + vec3(0.1);\n        col += spec*vec3(.5);\n        \n    }else{\n        col = vec3(0.2);\n    }\n\treturn col ;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (fragCoord.xy*2.0 - iResolution.xy)/min(iResolution.x,iResolution.y);\n    \n    vec3 up = vec3(0.,1.,0.);\n    vec3 lookAt = vec3(0.0,0.5,0.0);\n    vec3 ro = vec3(0.0,0.5,6.0);\n    ro.xz *= rotate(0.2*sin(iTime*0.5));\n    \n    vec3 cDir = normalize(lookAt-ro);\n    vec3 cSide = normalize(cross(cDir,up));\n    vec3 cUp = normalize(cross(cSide,cDir));\n     \n    vec3 rd= normalize(cSide * p.x + cUp * p.y + cDir );\n \n\tvec3 col = render(ro,rd);\n    vec2 q = fragCoord.xy / iResolution.xy;   \n    col *= 0.4 + 0.6 * pow(16.0 * q.x * q.y * (1.0 - q.x) * (1.0 - q.y), 0.1);\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}