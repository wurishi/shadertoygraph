{"ver":"0.1","info":{"id":"3td3zB","date":"1576768268","viewed":206,"name":"Collatz Loom","username":"uri","description":"Graphic representation of the Collatz conjecture in action.\n\nEach row is the binary expression of each subsequent odd number. Pause and click on the head of the loom to set it up for computation. Press arrows for movement, space for auto scroll.","likes":2,"published":1,"flags":48,"usePreview":0,"tags":["binary","boolean","collatz"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":3,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord) {\n    \n    // Simply render the computation buffer, zoomed accordingly\n    fragColor = color(M(screen2M(fragCoord)));\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":3,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord) {\n    \n    // Calculate matrix-space coordinates\n    ivec2 screenBounds = screen2M(iResolution);\n    ivec2 MCoord = ivec2(fragCoord);\n    \n    // Early culling of out-of-bounds pixels for speed\n    if (MCoord.x >= screenBounds.x || MCoord.y >= screenBounds.y) {\n        fragColor = color(0);\n        return;\n    }\n    \n    // Keyboard displacement commands merely shift coordinates\n    if (texelFetch(iChannel3, ivec2(32, 2), 0).x > 0.0)\n    \tMCoord.y += 1;\n    else if (texelFetch(iChannel3, ivec2(38, 0), 0).x > 0.0)\n        MCoord.y += 1;\n    else if (texelFetch(iChannel3, ivec2(39, 0), 0).x > 0.0)\n        MCoord.x += 1;\n    else if (texelFetch(iChannel3, ivec2(37, 0), 0).x > 0.0)\n        MCoord.x -= 1;\n    \n    // The head of the loom is subject to mouse clicks, while the rest self-arranges\n    if (MCoord.y < headSize) {\n        \n        // Initial sample number\n        if (iTime < 1.0) {\n            \n            fragColor = color(float(\n                (MCoord.x >= 201 && MCoord.x <= 206) || (MCoord.x % 5 == 0 && MCoord.x >= 50 && MCoord.x <= 195)\n            ));\n        } else {\n            \n            // Mouse commands let you edit the loom's head, which is simple a vertical smear of its last row\n            ivec2 mouse = screen2M(iMouse.xy);\n            bool click = (iMouse.w > 0.0) && (mouse.y <= headSize) && (mouse.x == MCoord.x);\n        \tfragColor = color(mod(M(ivec2(MCoord.x, headSize - 1)) + float(click), 2.0));\n        }\n\t} else {\n        \n        // All this computation represents binary addition, and eventually settles into a stable loom that represents the sequence\n        // (unless the loom becomes out of bounds, where the computation degenerates)\n        float A = M((MCoord + ivec2(0 - shift, -1)));\n        float B = M((MCoord + ivec2(1 - shift, -1)));\n        float C = M((MCoord + ivec2(2 - shift, -1)));\n        float D = M((MCoord + ivec2( 1,  0)));\n        float E = mod(A + (C + B) * (C + D), 2.0);\n        fragColor = color(E);\n        \n        // Forces the rightmost bit to flip to \"add one\" part in the binary expression\n        if (A > 0.0) {\n        \t\n            ivec2 coord = MCoord + ivec2(1 - shift, -1);\n            while (M(coord) == 0.0)\n                if(++coord.x >= screenBounds.x) {\n                    \n                \tfragColor = color(0);\n                    return;\n                }\n        }\n    }\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"\n// Settings\n#define zoom\t\t3.0\n#define headSize\t6\n#define shift\t\t2 //0\n\n// Helper definitions\n#define color(bit)\tvec4(vec3(bit), 1.0)\n#define screen2M(c)\tivec2(c/zoom)\n#define M(Mcoord)\ttexelFetch(iChannel0, Mcoord, 0).x","name":"Common","description":"","type":"common"}]}