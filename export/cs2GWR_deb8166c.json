{"ver":"0.1","info":{"id":"cs2GWR","date":"1667465798","viewed":169,"name":"Gatos Fazendo Gatices","username":"panna_pudi","description":"Le fran√ßais, ce sera plus tard je le jure je le jure","likes":18,"published":1,"flags":0,"usePreview":0,"tags":["cat"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define BODY 0.\n#define FACE 1.\n\nconst float PI = acos(-1.);\nconst float TAU = 2. * PI;\n\nvec2 _min(vec2 a, vec2 b) {\n    if (a.x < b.x)\n        return a;\n    return b;\n}\n\nmat2 rot(float a) {\n    float c = cos(a), s = sin(a);\n\n    return mat2(c, -s, s, c);\n}\n\nfloat hash12(vec2 p) {\n    vec3 p3 = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec3 erot(vec3 p, vec3 ax, float a) {\n    return mix(dot(ax, p) * ax, p, cos(a)) + cross(ax, p) * sin(a);\n}\n\n// https://iquilezles.org/articles/distfunctions/\nfloat sd_sphere(vec3 p, float r) {\n    return length(p) - r;\n}\n\nfloat sd_box(vec3 p, vec3 h) {\n    p = abs(p) - h;\n    return length(max(p, 0.)) + min(0., max(p.x, max(p.y, p.z)));\n}\n\nfloat smin(float d1, float d2, float k) {\n    float h = clamp(0.5 + 0.5 * (d2 - d1) / k, 0.0, 1.0);\n    return mix(d2, d1, h) - k * h * (1.0 - h);\n}\n\nfloat sd_round_cylinder(vec3 p, float ra, float rb, float h) {\n    vec2 d = vec2(length(p.xz) - 2.0 * ra + rb, abs(p.y) - h);\n    return min(max(d.x, d.y), 0.0) + length(max(d, 0.0)) - rb;\n}\n\nfloat sd_vertical_capsule(vec3 p, float h, float r) {\n    p.y -= clamp(p.y, 0.0, h);\n    return length(p) - r;\n}\n\nfloat sd_capsule(vec3 p, vec3 a, vec3 b, float r) {\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    return length(pa - ba * h) - r;\n}\n\nfloat sd_round_cone(vec3 p, float r1, float r2, float h) {\n    float b = (r1 - r2) / h;\n    float a = sqrt(1.0 - b * b);\n\n    vec2 q = vec2(length(p.xz), p.y);\n    float k = dot(q, vec2(-b, a));\n    if (k < 0.0)\n        return length(q) - r1;\n    if (k > a * h)\n        return length(q - vec2(0.0, h)) - r2;\n    return dot(q, vec2(a, b)) - r1;\n}\n\nfloat ease_inout_cubic(float x) {\n    return x < .5 ? 4. * x * x * x : 1. - pow(-2. * x + 2., 3.) / 2.;\n}\n\nvec2 bend(vec2 p, vec2 c, float k) {\n    if (p.x < 0.)\n        k = 1.;\n    p -= c;\n    float ang = atan(p.x, p.y);\n    float len = length(p);\n    ang -= ang / sqrt(1. + ang * ang) * (1. - k);\n    return vec2(sin(ang), cos(ang)) * len + c;\n}\n\nvec2 map(vec3 p) {\n    vec3 pp = p;\n    float time = iTime;\n    float swiftly = smoothstep(-1., 1., cos(fract(time) * TAU)) * 2. - 1.;\n    swiftly = ease_inout_cubic(cos(fract(time) * TAU) * 0.5 + 0.5) * 2. - 1.;\n    p.x -= 0.05 * swiftly;\n\n    /* p.yz = kink(p.yz, pc.pos.xy, sin(pc.time) * .5 + .5); */\n    mat2 head_turn = rot(smoothstep(0., 0.32, p.y) * swiftly * 0.15);\n\n    vec3 q = p;\n    q.zx *= head_turn;\n    float body = sd_box(q, vec3(0.15, 0.25, 0.00)) - 0.1;\n    q.x = abs(q.x) - 0.20;\n    q.yx *= rot(0.2);\n    float sides = sd_capsule(q, vec3(0., -0.20, -0.), vec3(0., .11, -0.), 0.02);\n    float belly =\n        sd_capsule(p, vec3(-0.13, -0.11, -0.1), vec3(0.13, -0.11, -0.10), 0.05);\n    float muzzle =\n        sd_capsule(p, vec3(-0.14, 0.20, -0.04), vec3(0.14, 0.20, -0.04), 0.02);\n\n    q = p - vec3(0., 0.25, 0.);\n    q.zx *= head_turn;\n    q.xy *= rot(swiftly * 0.03);\n    q.x = abs(q.x) - 0.15;\n    q.zy *= rot(0.62);\n    q.xy *= rot(0.51);\n    float ears = sd_round_cone(q, 0.07, .025, .11) - 0.01;\n\n    float dir = sign(p.x);\n\n    q = p - vec3(0., -0.26, -0.10);\n    q.x = abs(q.x) - 0.23;\n    // q = erot(q, normalize(vec3(pc.pos)), max(0., swiftly * dir));\n    q.zy *= rot(3.85);\n    float boots = sd_round_cone(q, 0.04, 0.021, 0.12);\n    boots = smin(boots, sd_sphere(q + vec3(0., -0.07, 0.09), 0.02), 0.13);\n\n    q = p - vec3(0.0, 0.08, -.01);\n    q.x = abs(q.x) - 0.21;\n    // q = erot(q, normalize(vec3(0.5, 0., 1.)), PI / 1.5);  // walking\n    q = erot(q, normalize(vec3(-1.43, 0.06, 7.11)), 1.279);\n    // q = erot(q, normalize(vec3(-2.4599981, -0.17999958, 10.470144)), 1.15);\n\n    q = erot(q, normalize(vec3(-4.63, 3.49, 0.46)), 0.4 * swiftly * dir - 0.68);\n    q.yz = bend(q.yz, vec2(0.068, -0.12), 0.5 * swiftly * dir);\n    float arms = sd_capsule(q, vec3(0., 0., 0.), vec3(0., .11, 0.), 0.035);\n\n    body = smin(body, belly, 0.27);\n    body = smin(body, sides, 0.15);\n    body = smin(body, muzzle, 0.15);\n    body = smin(body, ears, 0.05);\n    body = smin(body, boots, 0.08);\n    body = smin(body, arms, 0.02);\n\n    vec2 d = vec2(body, BODY);\n\n    vec3 qq = p;\n    qq.zx *= head_turn * 0.9;\n    q = qq - vec3(0., 0.23, -0.124);\n    q.x = abs(q.x) - 0.145;\n    float eyes = sd_sphere(q, 0.015);\n    vec2 face = vec2(eyes, FACE);\n\n    q = qq - vec3(0., 0.23, -0.10);\n    q.xy = abs(q.xy) - vec2(0.21, 0.025);\n    q.xz *= rot(-0.6);\n    float whiskers =\n        sd_capsule(q, vec3(-0.025, 0., -0.), vec3(0.025, 0., 0.), 0.01);\n\n    q = qq - vec3(0., 0.225, -0.12);\n    float mouth = sd_sphere(q, 0.0115);\n    q.x = abs(q.x) - 0.075;\n    q.xy *= rot(0.05);\n    q.y += 0.015;\n    mouth = smin(\n        mouth, sd_capsule(q, vec3(-0.05, 0., 0.), vec3(-0.005, 0., 0.), 0.010),\n        0.025);\n\n    face = min(face, whiskers);\n    face = min(face, mouth);\n\n    d = _min(d, face);\n\n    return d;\n}\n\nvec3 trace(vec3 ro, vec3 rd) {\n    float t = 0.;\n    for (int i = 0; i < 100; i++) {\n        vec3 p = ro + rd * t;\n        vec2 d = map(p);\n        float pres = .5 / iResolution.y;\n        if ((d.x) < pres * t)\n            return vec3(t, 1., d.y);\n\n        t += d.x;\n        if (t > 10.)\n            break;\n    }\n\n    return vec3(t, -1., -1.);\n}\n\nvec3 get_norm(vec3 p) {\n    mat3 k = mat3(p, p, p) - mat3(0.0001);\n    return normalize(map(p).x - vec3(map(k[0]).x, map(k[1]).x, map(k[2]).x));\n}\n\nmat3 get_cam(vec3 eye, vec3 target) {\n    vec3 zaxis = normalize(target - eye);\n    vec3 xaxis = normalize(cross(zaxis, vec3(0., 1., 0.)));\n    vec3 yaxsi = cross(xaxis, zaxis);\n    return mat3(xaxis, yaxsi, zaxis);\n}\n\nfloat calcAO(in vec3 p, in vec3 n) {\n    float sca = 2., occ = 0.;\n    for (int i = 0; i < 2; i++) {\n        float hr = float(i + 1) * .25 / 5.;\n        float d = map(p + n * hr).x;\n        occ += (hr - d) * sca;\n        sca *= .75;\n        if (occ > 1e5)\n            break;\n    }\n\n    return clamp(1. - occ, 0., 1.);\n}\nfloat AO(float e, vec3 p, vec3 n) {\n    return clamp(map(p + e * n).x / e, 0., 1.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n\n    vec3 ro = vec3(0., .7, -1.3);\n    // ro = vec3(0., .4, 0.) + 1. * vec3(cos(time), 0., sin(time));\n    // ro = vec3(0., .4, 0.) + 1. * vec3(cos(h), 0., sin(h));\n    mat3 cam = get_cam(ro, vec3(0., -0., 0.));\n    vec3 rd = cam * normalize(vec3(uv, 1.2));\n\n    vec3 t = trace(ro, rd);\n\n    vec3 col = vec3(.8);\n    if (t.y > 0.) {\n        vec3 pos = ro + rd * t.x;\n        vec3 nor = get_norm(pos);\n\n        vec3 albedo = vec3(0.);\n        if (t.z == BODY)\n            albedo = vec3(0.93);\n        if (t.z == FACE)\n            albedo = vec3(0.05);\n\n        col = nor * 0.5 + 0.5;\n\n        vec3 ld = vec3(0.0, 2.1699984, -0.3999999);\n        vec3 lp = erot(nor, normalize(vec3(1, 1, 0)), 0.96);\n        float ao = calcAO(pos, nor);\n        float spec = pow(max(dot(reflect(ld, nor), rd), 0.), 35.);\n\n        nor = erot(nor, normalize(vec3(-1, 1, 0)), .96);\n        float diff = dot(max(nor, 0.), vec3(.4));\n        diff = (1. - diff) * 0.75;\n        col = (albedo * diff * ao) / 1.;\n        if (t.z > 0.) {\n            col += spec * exp(-distance(pos, ld) * 14.);\n        }\n    }\n\n    col = smoothstep(0., 1., col);\n    col = pow(col, vec3(0.4545));\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}