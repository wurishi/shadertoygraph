{"ver":"0.1","info":{"id":"dstyDs","date":"1695681559","viewed":127,"name":"Meromorphic Dance","username":"chronos","description":"Using complex arithmetic to render analytic functions. Related to winding number fields.","likes":14,"published":1,"flags":0,"usePreview":1,"tags":["number","complex","dance","arithmetic","operations","meromorphic","complexnumber"],"hasliked":0,"parentid":"DsdcWs","parentname":"Complex Arithmetic"},"renderpass":[{"inputs":[{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":0,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n    Based on tweet by Keenan Crane:\n    https://twitter.com/keenanisalive/status/1448011475231117315\n    \n    \"the imaginary part of the log of a random meromorphic function (i.e., a ratio of complex polynomials)\"\n*/\n\nconst float PI = 3.14159265;\nconst vec2 I = vec2(0, 1);\nvec2 imaginary_unit() { return vec2(0, 1); }\nvec2 conjugate(vec2 a) { return a * vec2(1,-1); }\nvec2 cadd(vec2 a, vec2 b) { return a + b; }\nvec2 csub(vec2 a, vec2 b) { return a - b; }\nvec2 cmul(vec2 a, vec2 b) { return vec2(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x); }\nfloat cabs(vec2 a) { return length(a); } // modulus / absolute value\nfloat carg(vec2 a) { return atan(a.y, a.x); } // \"angle\" or complex argument of polar form\nfloat cabs2(vec2 a) { return cmul(a, conjugate(a)).x; } // modulus / absolute value, squared\nvec2 crcp(vec2 a) { return conjugate(a) / cabs2(a); } // reciprocal\nvec2 cdiv(vec2 a, vec2 b) { return cmul(a, conjugate(b)) / cabs2(b); } // complex division\nfloat re(vec2 a) { return a.x; }\nfloat im(vec2 a) { return a.y; }\n\nvec2 cexp(vec2 a) { return exp(a.x) * vec2(cos(a.y), sin(a.y)); }\nvec2 clog(vec2 a) { return vec2(log(cabs(a)), carg(a)); }\n\n//vec2 csqrt(vec2 a) { return sqrt(cabs(a)) * cos((carg(a) + vec2(0., -PI))/2. ); }\nvec2 csqrt(vec2 a)\n{ \n    float u = sqrt((length(a) + abs(a.x))/2.);\n    vec2 uv = vec2(u, .5 * a.y / u);\n    return a.x > 0. ? uv : uv.yx;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 color = vec3(0);\n\n    vec2 uv = (2.*fragCoord-iResolution.xy)/iResolution.y;\n    vec2 mouse = (2.*iMouse.xy-iResolution.xy)/iResolution.y;\n    \n    float t = iTime * 1.; // Just an easy way to stop the animation by setting to iTime * 0.\n    \n    // Detect and animate idle mouse\n    if(length(iMouse.xy) < 10.) mouse = vec2(cos(t), sin(t));\n    \n    // For AA\n    float pix_size = 2./iResolution.y;\n\n    vec2 a, b, c, d;\n    a = vec2(-1.,  0.);\n    b = vec2( 1.,  0.) * sin(t);\n    c = vec2( .5,  .5 * cos(t * .5)) ;\n    d = vec2( -.5, -.5 * sin(t * 3./2.));\n\n    // Override a point with mouse controls\n    a = mouse;\n\n    // Some pretty dumb AA :)\n    int AA = 32;\n    for(int i = 0; i < AA; i++)\n    {\n        vec2 uv = (2.*fragCoord-iResolution.xy)/iResolution.y;\n        vec2 jitter = pix_size*(-.5+texture(iChannel0, (fragCoord.xy/1024.) + vec2(1.1, .7) *float(iFrame + i * 11) / 64.).rg);\n        uv += jitter;\n        \n        float val = carg(\n            cdiv(a - uv, b - uv) +\n            cdiv(c - uv, d - uv)\n            ); // equivalent to Im(log( a + b + c + d ))\n\n        color += .5*(tanh(val) + 1.);\n    }\n    color /= float(AA);\n    \n    const float r = 0.01; // dot radius\n    vec3 point_color = vec3(.5);\n    \n    // Dot outline\n    color = mix(color, vec3(0), smoothstep(1.2*r + pix_size, 1.2*r, length(a - uv)));\n    color = mix(color, vec3(0), smoothstep(1.2*r + pix_size, 1.2*r, length(b - uv)));\n    color = mix(color, vec3(0), smoothstep(1.2*r + pix_size, 1.2*r, length(c - uv)));\n    color = mix(color, vec3(0), smoothstep(1.2*r + pix_size, 1.2*r, length(d - uv)));\n    \n    // Dot centers\n    color = mix(color, point_color, smoothstep(r + pix_size, r, length(a - uv)));\n    color = mix(color, point_color, smoothstep(r + pix_size, r, length(b - uv)));\n    color = mix(color, point_color, smoothstep(r + pix_size, r, length(c - uv)));\n    color = mix(color, point_color, smoothstep(r + pix_size, r, length(d - uv)));\n    \n    // Approximate gamma correction and dithering.\n    // As far as I could tell i got less noise in the shadows and less banding in the highlights\n    // by dithering after gamma correction. I didn't try gamma-decoding the noise texture though.\n    color = pow(clamp(color, 0., 1.), vec3(1./2.2));\n    color += 1.5*texture(iChannel0, (fragCoord.xy/1024.) + vec2(.9, 1.3) *float(iFrame) / 8.)[iFrame%3] / 255.;\n    fragColor = vec4(clamp(color, 0., 1.), 1.0);\n}","name":"Image","description":"","type":"image"}]}