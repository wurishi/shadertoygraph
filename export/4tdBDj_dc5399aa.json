{"ver":"0.1","info":{"id":"4tdBDj","date":"1541090936","viewed":75,"name":"[ESRM]fire?","username":"DarkAtom","description":"fire","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["fire","marchingrays","esrm"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec2 screenToWorld(vec2 screen);\nvec3 palette(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d);\nvec3 shade(float sd);\n\n\n// --- SDF utility library\n\nfloat sdCircle(in vec2 p, in vec2 pos, float radius)\n{\n    return length(p-pos)-radius;\n}\n\nfloat sdBox(in vec2 p, in vec2 pos, in vec2 size)\n{\n    vec2 d = abs(p-pos)-size;\n    return min(0.0, max(d.x, d.y))+length(max(d,0.0));\n}\n\n// polynomial smooth min (k = 0.1);\nfloat sminCubic(float a, float b, float k)\n{\n    float h = max(k-abs(a-b), 0.0);\n    return min(a, b) - h*h*h/(6.0*k*k);\n}\n\nfloat opU(float d1, float d2)\n{\n    return min(d1, d2);\n}\n\nfloat opN(float d1, float d2)\n{\n    return max(d1, d2);\n}\n\nfloat opBlend(float d1, float d2)\n{\n    float k = 0.2;\n    return sminCubic(d1, d2, k);\n}\n\n\n// --- SDF - TODO!\n\nfloat rand(int seed)\n{\n    vec2 co = vec2(float(seed), 17.);\n\treturn fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat sdf(vec2 p)\n{\n    const int numParticles = 25;\n    const int numClosestDistances = 3;\n    const float width = 0.4;\n    const float widthPerColumn = width / float(numParticles);\n    const float speedVariance = 0.4;\n    const float speedConstant = 1.0 - speedVariance;\n    const float maxHeight = 1.0;\n    \n   \tfloat core = opN(sdCircle(p, vec2(0,-.15), .4), sdCircle(p, vec2(0,.15), .5));\n    float particles[numParticles];\n    for (int i = 0; i < numParticles; ++i)\n    {\n        float speed = 0.6*((rand(i)*speedVariance)+speedConstant);\n        float height = mod(iTime*speed, maxHeight);\n        particles[i] = sdCircle(p,\n                                vec2(float(i)*widthPerColumn-(width/2.0),height),\n                                0.4*(1.0-(height/maxHeight)));\n    }\n    \n    float closestDistances[numClosestDistances];\n    for (int i = 1; i < numClosestDistances; ++i)\n    {\n        closestDistances[i] = particles[i];\n    }\n    for (int i = numClosestDistances; i < numParticles; ++i)\n    {\n        float partDist = particles[i];\n        for (int i2 = 0; i2 < numClosestDistances; ++i2)\n        {\n            if (partDist < closestDistances[i2])\n            {\n                float tmp = partDist;\n                partDist = closestDistances[i2];\n                closestDistances[i2] = tmp;\n            }\n        }\n    }\n    float partUnion = closestDistances[0];\n    for (int i = 1; i < numClosestDistances; ++i)\n    {\n    \tpartUnion = max(partUnion, closestDistances[i]);\n    }\n    //return partUnion;\n    return opU(core, partUnion);\n}\n\n\n// compute pixel colour\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // project screen coordinate into world\n\tvec2 p = screenToWorld(fragCoord);\n    \n    // signed distance for scene\n    float sd = sdf(p);\n    \n    // compute signed distance to a colour\n    vec3 col = shade(sd);\n    \n    fragColor = vec4(col, 1.0);\n}\n\n\n// --- library / misc functions\n\n\n// https://www.shadertoy.com/view/ll2GD3\nvec3 palette(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d)\n{\n    t = clamp(t, 0., 1.);\n    return a + b*cos(6.28318*(c*t+d));\n}\n\nvec2 screenToWorld(vec2 screen)\n{\n    vec2 result = 2.0 * (screen/iResolution.xy - 0.5);\n    result.x *= iResolution.x/iResolution.y;\n    result.y += 0.5;\n    return result;\n}\n\nvec3 shade(float sd)\n{\n    float maxDist = 2.0;\n    if (sd < 0.0)\n    {\n    \tconst vec3 fire1 = vec3(0.8,0.0,0.0);\n    \tconst vec3 fire2 = vec3(0.7,0.4,0.0);\n        return mix(fire2, fire1, abs(sd)*2.0);\n    }\n    else\n    {\n    \tconst vec3 glow = vec3(0.4,0.4,0.0);\n    \tconst vec3 BG = vec3(0.0,0.0,0.0);\n        return mix(glow, BG, sd*2.0);\n        return glow;\n    }\n    vec3 palCol = palette(clamp(0.5-sd*0.4, -maxDist,maxDist),\n                          vec3(0.3,0.3,0.0),//vec3(0.3,0.3,0.0)\n                          vec3(0.8,0.8,0.1),//vec3(0.8,0.8,0.1)\n                          vec3(0.9,0.7,0.0),//vec3(0.9,0.7,0.0)\n                          vec3(0.3,0.9,0.8));//vec3(0.3,0.9,0.8)\n\n    vec3 col = palCol;\n    \n    // Darken around surface\n\tcol = mix(col, col*1.0-exp(-10.0*abs(sd)), 0.4);\n\t// repeating lines\n    //col *= 0.8 + 0.2*cos(150.0*sd);\n    // White outline at surface\n    //col = mix(col, vec3(1.0), 1.0-smoothstep(0.0,0.01,abs(sd)));\n    \n    return col;\n}\n","name":"Image","description":"","type":"image"}]}