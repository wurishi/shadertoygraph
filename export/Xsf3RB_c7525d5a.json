{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[{"channel":0,"type":"texture","id":"4sf3Rn","filepath":"/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"code":"#define MODEL_JELLYFISH  0\n#define MODEL_FISH       1\n#define MODEL_GROUND     2\n\nvec2 t;\nfloat time;\nfloat anim_offset = 0.0;\nint model = 0;\nmat3 rot, trot, rx;\nfloat znear;\nvec3 glow;\nvec2 p;\nfloat tm2;\nvec2 ltc;\nint material;\n\nmat3 rotateYmat(float ang)\n{\n\treturn mat3(cos(ang), 0.0, sin(ang),\n\t\t\t\t0.0, 1.0, 0.0,\n\t\t\t\t-sin(ang), 0.0, cos(ang));\n}\n\nmat3 rotateXmat(float ang)\n{\n\treturn mat3(0.0, 0.0, 1.0,\n\t\t\t\tcos(ang), sin(ang), 0.0,\n\t\t\t\t-sin(ang), cos(ang), 0.0);\n}\n\nfloat traceSphere(vec3 ro, vec3 rd, float radsq)\n{\n\tfloat a = dot(rd, rd);\n\tfloat b = dot(ro, rd);\n\tfloat c = dot(ro, ro) - radsq;\n\tfloat d = (b * b - a * c) * 4.0;\n\n\treturn mix(1e4, (-b + sqrt(d)) / (2.0 * a), step(0.0, d));\n}\n\n\nvec3 tex(vec2 p)\n{\n\tfloat su = 0.5 + 0.5 * cos(p.x * 4.0);\n\tvec3 c = mix(vec3(0.5, 0.1, 0.1) * 0.3, vec3(1.0, 0.9, 0.5), 1.0 - p.y + cos(time * 8.0) * 0.02);\n\tvec3 c2 = c * mix(vec3(1.0, 0.9, 0.5), vec3(0.7, 0.5, 0.1), su);\n\treturn mix(c2, c, sqrt(1.0 - p.y)) + pow(su * (0.5 + 0.5 * cos(p.y * 40.0)) * 1.02, 64.0) * vec3(0.1);\n}\n\nfloat radius(float x)\n{\n\tif(model == MODEL_JELLYFISH)\n\t{\n\t\tfloat t = time + anim_offset;\n\t\treturn (x * 0.3 + (0.5 + 0.5 * cos(x * 4.0 + t * 10.0)) * 0.04);\n\t}\n\t\n\tif(model == MODEL_GROUND)\n\t{\n\t\treturn x * 0.5;\n\t}\n\t\n\treturn mix(x * 0.03, 1.0, 0.5 + 0.5 * sin(x * 0.8 - 0.6)) * 0.6;\n}\n\nfloat zpos(float x)\n{\n\tif(model == MODEL_JELLYFISH)\n\t{\n\t\tfloat t = time + anim_offset;\n\t\treturn cos(x * 0.5 + t) * 2.0 * (1.0 + iMouse.x / iResolution.x * 2.0);\n\t}\n\t\n\tif(model == MODEL_GROUND)\n\t{\n\t\treturn cos(x / 8.0 * 3.14159 * 2.0 + 0.1);\n\t}\n\t\n\treturn x * 0.4 + cos(x + time * 4.0) * 0.1;\n}\n\nvoid swap(inout float a, inout float b)\n{\n\tfloat c = a;\n\ta = b;\n\tb = c;\n}\n\nvoid tubePiece(int j, vec3 ro, vec3 rd, inout vec2 tc, inout float tm)\n{\n    float s0 = radius(float(j)), s1 = radius(float(j + 1));\n    float z0 = zpos(float(j)), z1 = zpos(float(j + 1));\n    \n    float zz0 = -z1;\n    float f = z1 - z0;\n    \n    if(z0 < z1)\n    {\n        swap(s0, s1);\n        swap(z0, z1);\n    }\n    \n    float i = 0.0;\n    vec3 oro = ro, ord = rd;\n    \n\n\tfloat zd = z0 - z1;\n\t\n\tfloat u = (s1 - s0) / zd;\n\t\n\tfloat zofs = s0 / u;\n\tfloat rus = 1.0 / (u * u);\n\t\n\tro.z += zofs + z0;\n\t\n\tfloat a = dot(rd.xy, rd.xy) * rus - rd.z * rd.z;\n\tfloat b = dot(ro.xy, rd.xy) * rus - rd.z * ro.z;\n\tfloat c = dot(ro.xy, ro.xy) * rus - ro.z * ro.z;\n\tfloat d = b * b - a * c;\n\t\n\tif(d < 0.0)\n\t\treturn;\n\t\n\td = sqrt(d);\n\t\n\tfloat cone_min = (-b - d) / a;\n\tfloat cone_max = (-b + d) / a;\n\t\n\tfloat rp0 = ro.z + rd.z * cone_min - zofs;\n\tfloat rp1 = ro.z + rd.z * cone_max - zofs;\n\t\n\t\n\tif(rp0 > 0.0 && rp0 < zd && cone_min > 0.0)\n\t\ti = cone_min;\n\telse if(rp1 > 0.0 && rp1 < zd && cone_max > 0.0)\n\t\ti = cone_max;\n\telse\n\t\treturn;\n\n        \n    ro = oro;\n    rd = ord;\n    \n\tvec3 rp = ro + rd * i;\n\tfloat t = (rp.z - zz0) / f;\n\t\n\tvec2 ltc = vec2(atan(rp.y, rp.x) * 3.0, mix(float(j + 1), float(j), t));\n\tfloat hit = step(i, tm);\n\t\n\ttc = mix(tc, ltc, hit);\n\ttm = mix(tm, i, hit);\n}\n\n\nfloat tube(vec3 ro, vec3 rd, inout vec2 tc)\n{\n\tfloat tm = 1e2;\n\t\n    tubePiece(0, ro, rd, tc, tm);\n    tubePiece(1, ro, rd, tc, tm);\n    tubePiece(2, ro, rd, tc, tm);\n    tubePiece(3, ro, rd, tc, tm);\n    tubePiece(4, ro, rd, tc, tm);\n    tubePiece(5, ro, rd, tc, tm);\n    tubePiece(6, ro, rd, tc, tm);\n    tubePiece(7, ro, rd, tc, tm);\n\t\n\ttc.y /= float(8);\n\t\n\treturn tm;\n}\n\nvec3 backgtex(vec3 p)\n{\n\tfloat f = clamp(smoothstep(8.0, 30.0, p.y), 0.0, 1.0);\n\tvec3 n = pow(smoothstep(10.0, 42.0, p.y), 100.0) * vec3(1.0, 0.9, 0.5);\n\treturn (mix(vec3(0.1, 0.2, 0.2), vec3(0.0, 0.1, 0.1), 0.5 + 0.5 * cos(p.y * 0.4 + time * 10.0)) * 0.4 * f + n) * 0.5\n\t\t+ vec3(0.05, 0.06, 0.1) * smoothstep(-40.0, 1.0, p.y);\n}\n\nfloat noise( vec2 x )\n{\n\treturn texture(iChannel0, x / 64.0).r;\n}\n/*\nmat3 transpose(mat3 m)\n{\n\treturn mat3(m[0].x, m[1].x, m[2].x,\n\t\t\t\tm[0].y, m[1].y, m[2].y,\n\t\t\t\tm[0].z, m[1].z, m[2].z);\n}\n*/\n\nvoid traceFish(int i, inout vec2 tc, inout float tm, vec3 ro, vec3 rd)\n{\n\tmat3 r = rotateXmat(time + float(i) * 0.4 + cos(time + float(i))), trans_r = transpose(r);\n\t\n\tvec3 tr = rotateYmat(float(i)) * rotateXmat(float(i)) * vec3(0.0, float(i), float(i)) * 4.0 +\n\t\tr * vec3(0.0, 8.0, 0.0);\n\t\n\tvec3 vtr = trot * (tr - ro);\n\t\n\tif(vtr.z < -1e-3)\n\t{\n\t\tvec2 ptr = vtr.xy / vtr.z * znear;\n\t\tglow += vec3(0.3, 0.7, 1.0).bgr * pow(max(0.0, 1.0 - distance(ptr, p) * 1.0) * 5.0, 2.0) * 0.4;\n\t}\n\t\n\tanim_offset = float(i) * 1.7;\n\t\n\tvec3 s = vec3(1.0, 2.0, 1.0);\n\t\n\ttm2 = tube((trans_r * (ro - tr)) * s, (trans_r * rd) * s, ltc);\n\t\n\ttc = mix(tc, ltc, step(tm2, tm));\n\ttm = min(tm, tm2);\n}\n\nvoid traceJellyFish(int i, inout vec2 tc, inout float tm, vec3 ro, vec3 rd)\n{\n\tmat3 r = rotateYmat(float(i) * 2.0) * rx, trans_r = transpose(r);\n\tvec3 tr = rotateYmat(float(i)) * vec3(float(i) * 1.0, sin(float(i) * 5.0) * 10.0, 4.0) *\n\t\t(1.0 + iMouse.y / iResolution.y * 2.0);\n\t\n\tvec3 vtr = trot * (tr - ro);\n\t\n\tif(vtr.z < -1e-3)\n\t{\n\t\tvec2 ptr = vtr.xy / vtr.z * znear;\n\t\tglow += vec3(0.3, 0.7, 1.0) * pow(max(0.0, 1.0 - distance(ptr, p) * 2.0) * 7.0, 2.0) *\n\t\t\tmix(0.7, 1.2, 0.5 + 0.5 * cos(float(i) + time * 4.0));\n\t}\n\t\n\tanim_offset = float(i) * 1.7;\n\t\n\ttm2 = tube(trans_r * (ro - tr), trans_r * rd, ltc);\n\t\n\tif(tm2 < tm)\n\t\tmaterial = MODEL_JELLYFISH;\n\t\n\ttc = mix(tc, ltc, step(tm2, tm));\n\ttm = min(tm, tm2);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tt = uv * 2.0 - vec2(1.0);\n\tt.x *= iResolution.x / iResolution.y;\n\t\n\ttime = iTime;\n\t\n\tmaterial = MODEL_FISH;\n\tznear = -0.8;\n\trot = rotateXmat(3.1415926 * 0.5 + cos(time * 0.1) + sin(time * 5.0) * 0.002) * rotateYmat(time * 0.2);\n\ttrot = transpose(rot);\n\t\n\tp = t.xy;\n\t\n\tvec3 ro = rot * vec3(cos(time), sin(time * 0.3), 10.0);\n\tvec3 rd = rot * vec3(p, znear);\n\tfloat tm = 2e2;\n\t\n\tvec2 tc = vec2(0.0);\n\t\n\tglow = vec3(0.0);\n\t\n\tmodel = MODEL_FISH;\n\tfor(int i = 0; i < 8; i += 1)\n\t\ttraceFish(i, tc, tm, ro, rd);\n\n\n\n    \n    model = MODEL_JELLYFISH;\n\trx = rotateXmat(3.1415926);\n\t\n\tfor(int i = 0; i < 10; i += 1)\n\t\ttraceJellyFish(i, tc, tm, ro, rd);\n\n\t\n\n    \n\t// ground\n\t\n\tmodel = MODEL_GROUND;\n\tmat3 r = rotateXmat(-3.1415926), trans_r = transpose(r);\n\tvec3 tr = vec3(0.0, -24.0, 0.0);\n\t\n\tvec3 vtr = trot * (tr - ro);\n\t\n\tanim_offset = 1.7;\n\t\n\tvec3 s = vec3(0.2, 0.2, 0.2);\n\t\n\ttm2 = tube(trans_r * (ro - tr) * s, trans_r * rd * s, ltc);\n\t\n\tif(tm2 < tm)\n\t\tmaterial = MODEL_GROUND;\n\t\n\ttc = mix(tc, ltc, step(tm2, tm));\n\ttm = min(tm, tm2);\n    \n    \n\t\n\t\n\tvec3 rp = ro + rd * tm;\n\t\n\t\n\ttm2 = traceSphere(ro, rd, 40.0 * 40.0);\n\tvec3 backgcol = backgtex(ro + rd * tm2);\n\t\n\tvec3 c;\n\t\n\tif(material == MODEL_FISH)\n\t\tc = tex(tc);\n\t\n\tif(material == MODEL_JELLYFISH)\n\t\tc = tex(tc).bgr;\n\t\n\tif(material == MODEL_GROUND)\n\t\tc = mix(0.3 * mix(vec3(0.5, 0.3, 0.3), vec3(1.0, 1.0, 0.4), mix(0.3, 0.5, noise(rp.xz * 8.0))),\n\t\t\t\tbackgcol, pow(smoothstep(0.0, 1.0, tc.y * 1.0), 2.0)) * smoothstep(-10.0, 1.0, rp.y - -25.0);\n\t\n\tfloat v = pow(1.0 - smoothstep(0.0, 2.0, length(p)), 0.5);\n\t\n\tvec3 col = (mix(vec3(0.0), c, step(tm, 0.9e2))) * 1.1;\n\t\n\tfloat bs = clamp(1.0 - length(backgcol) * 4.0, 0.0, 1.0) * v * 3.5;\n\t\n\tfragColor.rgb = (mix(backgcol, col, step(tm, tm2)) + glow * 0.01) * v;\n\tfragColor.rgb += noise(fragCoord.xy) * 0.01;\n\t\n\tfragColor.rgb += smoothstep(0.9, 0.91,\n\t\t\t\t\t\t\t\t   noise(t.xy * 40.0 + vec2(cos(time + t.y * 5.0) * 4.0, time * 10.0 + cos(time) * 5.0 + sin(time + t.x * 3.0) * 4.0) )) * 0.01 *\n\t\tsmoothstep(0.0, 20.0, tm) * bs;\n\t\n\tfragColor.rgb += smoothstep(0.9, 0.91,\n\t\t\t\t\t\t\t\t   noise(t.xy * 80.0 + vec2(cos(time + t.y * 10.0) * 4.0, time * 10.0 + cos(time + 0.1) * 5.0 + sin(time * 0.5 + t.x * 8.0) * 4.0) )) * 0.01 *\n\t\tsmoothstep(0.0, 15.0, tm) * 2.0 * bs;\n\n\tfragColor.rgb = pow(fragColor.rgb, vec3(0.8));\n}\n","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"Xsf3RB","date":"1372886069","viewed":9335,"name":"Submerged","username":"fizzer","description":"Experimenting with clipped cones. Unfortunately I have not yet got this to work correctly on Firefox on Windows. Chrome should be okay.","likes":73,"published":1,"flags":0,"usePreview":0,"tags":["procedural","glow","fish","jellyfish","undersea"],"hasliked":0,"parentid":"","parentname":""}}