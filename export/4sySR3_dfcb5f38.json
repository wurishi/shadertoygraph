{"ver":"0.1","info":{"id":"4sySR3","date":"1465806844","viewed":491,"name":"Swiss railway clock","username":"elpuri","description":"https://en.wikipedia.org/wiki/Swiss_railway_clock\n\nEyeballed the dimensions, simulates the 2 second synchronization period of the actual clocks. Would be nice if the handles had shadows.","likes":14,"published":1,"flags":64,"usePreview":0,"tags":["2d","clock"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"MdXGWX","filepath":"https://soundcloud.com/spinechillerpro/clock-tick-sound-main","previewfilepath":"https://soundcloud.com/spinechillerpro/clock-tick-sound-main","type":"musicstream","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Juha Turunen (turunen@iki.fi), 2016\n\n#define PI 3.1415926\n\nconst vec3 secondHandleColor = vec3(180.0 / 255.0, 10.0 / 255.0, 18.0 / 255.0);\nconst vec3 flagColor = vec3(160.0 / 255.0, 10.0 / 255.0, 18.0 / 255.0);\nconst vec3 clockFaceColor = vec3(0.985);\n\nconst float secondHandleDotRadius = 0.06;\nconst float secondHandleThickness = 0.015;\nconst float secondHandleLength = 0.78;\nconst float secondHandlePivot = 0.25;\nconst float minuteHandleThickness = 0.035;\nconst float hourHandleThickness = 0.045;\nconst float minuteHandleLength = 0.83;\nconst float hourHandleLength = 0.65;\n\nconst float tickOuterRadius = 0.75;\nconst float majorTickLength = 0.15;\nconst float minorTickLength = majorTickLength / 3.0;\nconst float majorTickWidth = 0.0275;\nconst float minorTickWidth = majorTickWidth / 2.5;\n\nconst float clockFaceRadius = 0.83;\nconst float clockFaceThickness = 0.04;\n\nconst float pinRadius = 0.0075;\n\nmat2 rotation(float angle)\n{\n\treturn mat2(cos(angle), sin(angle), -sin(angle), cos(angle));\n}\n\n\nfloat handle(vec2 p, float angle, float pivot, float length, float width, float slope, float s) \n{\n    p = rotation(angle) * p;\n    p.x += pivot;\n    width -= slope * p.x;\n\tfloat v = smoothstep(0.5 * length + s, 0.5 * length - s, abs(p.x - 0.5 * length)); \n    return v * smoothstep(width + s, width - s, abs(p.y));;\n}\n\nfloat secondHandle(vec2 p, float angle, float s)\n{\n    mat2 rot = rotation(angle);\n    p = rot * p;\n    p.x += secondHandlePivot;\n\t\n    float v = smoothstep(secondHandleThickness + s, secondHandleThickness - s, abs(p.y));\n\tv *= smoothstep(0.0 - s, s, p.x);\n    v *= 1.0 - step(secondHandleLength, p.x);\n    p.x -= secondHandleLength;\n    float dot = smoothstep(secondHandleDotRadius, secondHandleDotRadius - s, length(p));\n    v = mix(v, 1.0, dot);\n    return v; \n}\n\nfloat ring(vec2 p, float radius, float thickness, float s)\n{\n    float d = length(p);\n    return smoothstep(thickness + s, thickness, abs(d - radius));\n}\n\n\n// Should be way faster than the loop, but couldn't make it work properly :(\n/*\nfloat minuteMark(vec2 p, float s)\n{\n    const float radius = 0.7;\n   \tfloat w = 3.1415 * 2.0 / 60.0;\n\tmat2 rot = rotation(-0.25 * w);\n    p = rot * p;\n    float r = length(p);\n    float markWidth = 0.24;\n    float a = atan(p.x, p.y) - iTime;\n    float minAngle = mod(a, w);\n    float isNotMod5 = step(w * 0.5, mod(a, w * 5.0));\n\tmarkWidth -= 0.22 * isNotMod5;\n    float markLength = 0.05;\n\tmarkLength *= 1.0 - 0.50 * isNotMod5;\n    float marksRadius = radius + isNotMod5 * markLength;\n    return smoothstep(markWidth, markWidth - s, minAngle) * \n           smoothstep(markLength, markLength - s, abs(r - marksRadius));\n}\n*/\n\n\nfloat minuteMark(vec2 p, float s)\n{\n    float v;\n    float d = length(p);\n    if (d < tickOuterRadius - majorTickLength - s ||\n        d > tickOuterRadius + s)\n        return 0.0;\n    \n    mat2 r = rotation(3.1415 * 2.0 / 60.0);\n    for (int i = 0; i < 60; i++) {\n\t\tfloat tickWidth, tickLength;\n        if (mod(float(i), 5.0) < 1.0) {\n            tickWidth = majorTickWidth;\n            tickLength = majorTickLength;\n        } else {\n\t\t\ttickWidth = minorTickWidth;\n            tickLength = minorTickLength;\n        }\n\t    \n        v = smoothstep(tickOuterRadius - tickLength - s, tickOuterRadius - tickLength + s, p.x) -\n            \t  smoothstep(tickOuterRadius - s, tickOuterRadius + s, p.x);\n        v *= smoothstep(tickWidth + s, tickWidth - s, abs(p.y));\n        \n        if (v > 0.0)\n            return v;\n        p = r * p;\n    }\n    return v;\n}\n\nvec3 background(vec2 p)\n{\n    const float floorLevel = 0.7;\n    const float fold = 0.05;\n    float y = (p.y - 1.0) / -2.0;\n    vec3 c = mix(vec3(0.86), vec3(0.97), y / floorLevel);\n    if (y > floorLevel)\n    \tc = mix(vec3(0.97), vec3(0.90), (y - floorLevel) / fold);\n    if (y > floorLevel + fold)\n        c = mix(vec3(0.93), vec3(0.86), (y - floorLevel - fold) / (1.0 - floorLevel - fold));\n   \treturn c;        \n}\n\nfloat flag(vec2 p)\n{\n    vec2 fp = abs(p + vec2(0.0, 0.30));\n    fp *= 1.6;\n    if (fp.x < 0.09 && fp.y < 0.09) {\n        if (fp.x < 0.05 && fp.y < 0.02)\n            return 0.0;\n        if (fp.x < 0.02 && fp.y < 0.05)\n            return 0.0;\n        return 1.0;\n    }\n    return 0.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (fragCoord.xy - iResolution.xy * 0.5) / iResolution.yy * 2.0;\n\t    \n    float time = iDate.w;\n\tfloat secondAngle = mod(time, 60.0) / 58.0 * PI * 2.0;\n\tsecondAngle = clamp(secondAngle, 0.0, PI * 2.0) - 0.5 * PI;\n    float minuteAngle = (floor(time / 60.0) - 15.0) / 60.0 * PI * 2.0;\n    float hourAngle = (floor(time / 60.0) / 12.0 - 15.0) / 60.0 * PI * 2.0;\n    \n\tvec3 color = background(p);\n\tvec2 sp = p;\n    sp.y += 0.82;\n    sp *= vec2(0.16, 1.8);\n    color = color * (1.0 - pow(0.13 / (length(sp) + 0.12), 0.7)); \n    \n    p *= 1.05;\n//    float s = dFdx(p.x);\n    float s = 1.0/iResolution.y * 2.0;\n\n    float fromCenter = length(p);\n\t\n    if (fromCenter < 0.9) {\n        color = mix(color, clockFaceColor, 1.0 - step(0.8, fromCenter));\n        \n        if (fromCenter > 0.7) {\n\t        float fromShadowCenter = length(p + vec2(0.0, 0.0075));\n    \t    color = mix(color, vec3(0.0), 0.75 * (1.0 - step(clockFaceRadius, fromCenter)) * \n                        (1.0 - smoothstep(clockFaceRadius - 0.03, clockFaceRadius - 0.07, \n                                          fromShadowCenter)));\n        }\n        color = mix(color, flagColor, flag(p));\n        color = mix(color, vec3(0.0), minuteMark(p, s));\n        color = mix(color, vec3(0.0), handle(p, hourAngle, 0.15, hourHandleLength, hourHandleThickness, 0.03, s));\n        color = mix(color, vec3(0.0), handle(p, minuteAngle, 0.15, minuteHandleLength, minuteHandleThickness, 0.01, s));\n        color = mix(color, secondHandleColor, secondHandle(p, secondAngle, s));\n        color = mix(color, vec3(0.8), smoothstep(pinRadius + s, pinRadius - s, fromCenter));\n\n        if (fromCenter < clockFaceRadius) {\n\t\t\tfloat highlightRadius = 1.5;\n            vec2 hp = p - vec2(0.0, 1.8);\n    \t    color += 0.075 * smoothstep(highlightRadius, highlightRadius - 5.0 * s, length(hp));\n        }\n        color = mix(color, vec3(0.0), ring(p, clockFaceRadius, clockFaceThickness, s)); \n        color = mix(color, vec3(max(0.0, -p.y) * 0.25), ring(p, clockFaceRadius - clockFaceThickness + 0.005, 0.003, s)); \n        color = mix(color, vec3(max(0.0, p.y) * 0.25), ring(p, clockFaceRadius + clockFaceThickness - 0.005, 0.003, s)); \n    }\n    \n    color *= 1.0 - 0.8 * pow(length((fragCoord - 0.5 * iResolution.xy) / iResolution.xy), 2.0); \n    color = pow(color, vec3(1.0 / 1.5, 1.0 / 1.5, 1.0 / 1.5));\n\n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}