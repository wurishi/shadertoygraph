{"ver":"0.1","info":{"id":"Mc3SDj","date":"1714785034","viewed":81,"name":"Bouncing ball (Physics rules)","username":"TWIX3RA","description":"Project","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["physics"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage(out vec4 fragColor, in vec2 fragCoord)\n    {\n    vec2 uv = (fragCoord / iResolution.xy)* 100.; //Mettre l'image sur une échelle de 0 à 100 (écran normalisé)\n    uv.x *= iResolution.x / iResolution.y; //Correction d'image pour tout type de fenêtre\n\n    //Variables\n    float ay = -9.8;  //Accélération gravitationnel(m/s^2)\n    float mb = 4.;    //Masse de la balle(Kg)\n    float Hi = 83.;   //Hauteur initiale(m)\n    float X0 = 18.;   //Position initiale en x(m)\n    float Vxi = 3.;   //Vitesse initiale en x(m/s)\n    float Kp = 0.5;   //Perte d'énergie (Selon les matériaux de la balle)\n    float r = 2.;     //Rayon de la balle (m)\n    float Hs = 9.;    //Hauteur du sol (m)\n\n    //Au premier rebond\n    float t1 = sqrt(2.*-(Hi-Hs)/ay);            //Temps du au premier rebond\n    float Vxa = Vxi;                            //Vitesse en x avant collision\n    float Vya = ay*t1;                          //Vitesse en y avant collision\n    float VTa = sqrt(pow(Vxa,2.)+pow(Vya,2.));  //Vitesse totale avant collision\n    float Ea = mb*pow(VTa,2.)/2.;               //Énergie avant collision\n    float Ed = Ea * Kp;                         //Énergie après collision\n    float VTd = sqrt(2.*Ed/mb);                 //Vitesse totale après collision\n    float Ac = atan(-Vya/Vxa);                  //Angle de collision\n    float Vxd = cos(Ac)*VTd;                    //Vitesse en x après collision\n    float Vyd = sin(Ac)*VTd;                    //Vitesse en y après collision\n\n    //Aux autres rebonds\n    float tn =-2.*Vyd/ay;                       //Temps des autres rebond\n    float tni = t1;                             //Configuration du temps initial\n\n\n        if (iTime < t1)                         // Chute\n            {\n            float X = X0 + Vxi*iTime;           //La position en x de la balle\n            float Y = Hi + ay*pow(iTime,2.)/2.; //La position en y de la balle\n\n\n            if (pow((uv.x - X),2.) + pow((uv.y - Y),2.) <= pow(r,2.)) //Un cercle de rayon r qui suit les\n                {                                                     //positions en x et y en fonction de t\n                fragColor = vec4(0.9, 0.4, 0., 1.);                   //Affiche la balle en orange\n                }\n\n            }\n        else if (iTime-tni < tn)                             //Premier rebond\n            {                               //Tout redéfinir\n            float X = X0 + Vxi*iTime;                        //Appeller X avec son ancienne position fianle\n            float Y;                                         //Appeller Y\n            float Xi = X;                                    //Envoyer la position vers une autre variable\n            float Yi = Hs;                                   //Position initiale de y (hauteur du sol)\n            float Vxa = Vxd;                                 //Vitesse en x avant collision\n            float Vya = Vyd;                                 //Vitesse en y avant collision\n            float VTa = sqrt(pow(Vxa,2.)+pow(Vya,2.));       //Vitesse totale avant collision\n            float Ea = mb*pow(VTa,2.)/2.;                    //Énergie avant collision\n            float Ed = Ea * Kp;                              //Énergie après collision\n            float VTd = sqrt(2.*Ed/mb);                      //Vitesse totale après collision\n            float Ac = atan(-Vya/Vxa);                       //Angle de collision\n            float Vxd = cos(Ac)*VTd;                         //Vitesse en x après collision\n            float Vyd = sin(Ac)*VTd;                         //Vitesse en y après collision\n\n\n            X = Xi + Vxa*(iTime-tni);                              //La position en x de la balle\n            Y = Yi + Vya*(iTime-tni) + ay*pow((iTime-tni),2.)/2.;  //La position en y de la balle\n\n\n            if (pow((uv.x - X),2.) + pow((uv.y - Y),2.) <= pow(r,2.))  //Un cercle de rayon r qui suit les\n                {                                                      //positions en x et y en fonction de t\n                fragColor = vec4(0.9, 0.4, 0., 1.);                    //Affiche la balle en orange\n                }    \n            }\n    if (uv.y > Hi-3. && uv.y < Hi-2. && uv.x < X0-1.)// Crée une ligne pour le sol de la coline\n        {\n        fragColor= vec4(0.5, 0.5, 0.5, 1);\n        }\n    else if (uv.x > X0-1. && uv.x < X0 && uv.y < Hi-2. && uv.y > Hs-3.) // Crée une ligne pour le\n        {                                                               // coté de la falaise\n        fragColor= vec4(0.5, 0.5, 0.5, 1);\n        }\n    else if (uv.y > Hs-3. && uv.y < Hs-2.)            // Crée une ligne pour le sol\n        {\n        fragColor= vec4(0.5, 0.5, 0.5, 1);\n        }\n    }","name":"Image","description":"","type":"image"}]}