{"ver":"0.1","info":{"id":"3l3yDr","date":"1617015343","viewed":640,"name":"Nile","username":"Draedrus","description":"The Nile\n-----------------------\nCloud shadows may seem weird from time to time, its normal, I use the cloud buffer that I sample with reprojected reflected vectors :D it does the trick most of the time\nThe reflected clouds and scene are also using reproj","likes":26,"published":1,"flags":32,"usePreview":0,"tags":["clouds","water","volumetric","reflections","night","pyramid","desert","nile"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/********************************************************************************************************\n * The MIT license\n * Copyright 2021 pierre-marie Plans <pierre.plans@gmail.com>\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy of this software\n * and associated documentation files (the \"Software\"), to deal in the Software without restriction,\n * including without limitation the rights to use, copy, modify, merge, publish, distribute,\n * sublicense, and/or sell copies of the Software, and to permit persons to whom the Software\n * is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all copies\n * or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\n * INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR\n * PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE\n * FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,\n * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n *********************************************************************************************************/\n\n// https://www.shadertoy.com/view/lstSRS\nvec3 tonemapping(vec3 color)\n{\n    //Tonemapping and color grading\n    color = pow(color, vec3(1.5));\n    color = color / (1.0 + color);\n    color = pow(color, vec3(1.0 / 1.5));\n\n    \n    color = mix(color, color * color * (3.0 - 2.0 * color), vec3(1.0));\n    color = pow(color, vec3(1.3, 1.20, 1.0));    \n\n\tcolor = clamp(color * 1.01, 0.0, 1.0);\n    \n    color = pow(color, vec3(0.7 / 2.2));\n    return color;\n}\n\nvec4 sampleBlurr(in sampler2D sampler, vec2 uv, vec2 invRes, float a)\n{\n   \tvec4 c = texture(sampler, uv);\n    for(int i = -1;i<2; ++i)\n    {\n    \tfor(int j = -1;j<2; ++j)\n        {\n        \tif(i==0 && j == 0)\n            \tcontinue;\n        \tvec4 v = (1.-abs(float(i)*a))*(1.-abs(float(j)*a))*texture(sampler, uv+vec2(float(i), float(j))*invRes);\n        \tc += v;\n        }\n    }\n    //c *= c;\n    c *= 0.11;\n    return c;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 invRes = 1./iResolution.xy;\n    vec2 uv = fragCoord*invRes;\n    vec3 m_ = vec3(100.), _m = vec3(0.);\n    vec4 cbb = texture(iChannel0, uv);\n   \tfragColor.rgb = cbb.rgb+cbb.a;\n    for(int i = -1;i<2; ++i)\n    {\n    \tfor(int j = -1;j<2; ++j)\n        {\n        \tif(i==0 && j == 0)\n            \tcontinue;\n            vec4 cb = texture(iChannel0, uv+vec2(float(i), float(j))*invRes);\n        \tvec3 v = clamp((1.-abs(float(i)*0.15))*(1.-abs(float(j)*0.15))*(cb.rgb+cb.a).rgb, 0., 1.);\n            m_ = min(m_, v); _m = max(_m, v);\n        \tfragColor.rgb += v;\n        }\n    }\n    fragColor *= fragColor;\n    fragColor *= 0.11;\n    \n    vec4 ppp = texture(iChannel1, RT_WATER_SCALE*uv);\n    fragColor.rgb = fragColor.rgb*ppp.a+ppp.rgb*(1.-ppp.a);\n    \n    vec4 pppc = sampleBlurr(iChannel2, RT_CLOUD_SCALE*uv, invRes, .2);\n    fragColor.rgb = fragColor.rgb*pppc.a+pppc.rgb*(1.-pppc.a);\n    \n    fragColor.rgb = tonemapping(fragColor.rgb);\n    // Debug output\n    //fragColor = texture(iChannel3, uv).rrrr/CAM_FAR;\n    //fragColor = texture(iChannel0, uv).aaaa;\n    //fragColor = texture(iChannel3, uv);\n    //fragColor = texture(iChannel2, RT_CLOUD_SCALE*uv);\n    //fragColor = texture(iChannel1, RT_WATER_SCALE*uv);\n    //fragColor.rgb = vec3(normalUnpack(texture(iChannel3, uv).zw));\n    //fragColor.rgb = fragColor.yyy/4.;\n    //fragColor.rgb =texture(iChannel1, uv).rgb;\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"/********************************************************************************************************\n * The MIT license\n * Copyright 2021 pierre-marie Plans <pierre.plans@gmail.com>\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy of this software\n * and associated documentation files (the \"Software\"), to deal in the Software without restriction,\n * including without limitation the rights to use, copy, modify, merge, publish, distribute,\n * sublicense, and/or sell copies of the Software, and to permit persons to whom the Software\n * is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all copies\n * or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\n * INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR\n * PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE\n * FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,\n * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n *********************************************************************************************************/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // compute uvs\n    vec2 invRes = 1./iResolution.xy;\n    vec2 uv = (fragCoord-.5*iResolution.xy)*invRes.y;\n    \n    // ray\n    vec3 ro = CAM_POS;\n    vec3 tgt = getCameraTgt(iMouse, invRes);\n    mat3 camMatrix = setCamera(ro, tgt, vec3(0., 1., 0.));\n    vec3 rd = normalize(camMatrix*normalize(vec3(uv, CAM_DEPTH)));\n    \n    // build up scene\n    float t = SCENE_TIME(iTime);\n    vec2 element = raymarch_main(ro, rd, CAM_NEAR, CAM_FAR, t);\n    \n    // evaluate normal\n    vec3 N = raymarch_main_normal(ro+rd*element.x, 0.001, t);\n\n    if(element.x>CAM_FAR)\n        N = vec3(1., 0., 0.);\n    if(element.x<CAM_NEAR)\n        N = vec3(0., 1., 0.);\n\n    vec2 np = normalPack(N);\n    fragColor = vec4(element.x, element.y, np.x, np.y);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"/********************************************************************************************************\n * The MIT license\n * Copyright 2021 pierre-marie Plans <pierre.plans@gmail.com>\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy of this software\n * and associated documentation files (the \"Software\"), to deal in the Software without restriction,\n * including without limitation the rights to use, copy, modify, merge, publish, distribute,\n * sublicense, and/or sell copies of the Software, and to permit persons to whom the Software\n * is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all copies\n * or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\n * INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR\n * PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE\n * FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,\n * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n *********************************************************************************************************/\n\n// LIGHTING\n\nfloat computeLightShadow(vec3 _lightPos, vec3 _pointPos, float _scale, float t)\n{\n    vec3 l2p = _pointPos-_lightPos;\n    float far = min(CAM_FAR, length(l2p));\n    return exp(-_scale*(far-shadows(_lightPos, normalize(l2p), 0.01, far, t)));\n}\n\nfloat Fresnel_Schlick(float n1, float n2, float NdotV)\n{\n    float R0 = (n1-n2)/(n1+n2);\n    R0 *= R0;\n    return R0+(1.0-R0)*(1.0-NdotV)*(1.0-NdotV)*(1.0-NdotV)*(1.0-NdotV)*(1.0-NdotV);\n}\n\nfloat beckmannDistribution(float roughness, float NdotH)\n{\n    float NoH2 = NdotH*NdotH;\n    float rg2 = roughness*roughness;\n    float r1 = 1.0 / max(0.0001, 4.0 * rg2 * NoH2 * NoH2);\n    float r2 = (NoH2 - 1.0) / (rg2 * NoH2);\n    return r1 * exp(r2);\n}\n\nfloat GGX(float a, float NoV, float NoL)\n{\n    float a2 = a*a;\n    float G_V = NoV + sqrt( (NoV - NoV * a2) * NoV + a2 );\n    float G_L = NoL + sqrt( (NoL - NoL * a2) * NoL + a2 );\n\treturn 1.0/( G_V * G_L );\n}\n\n// https://github.com/stackgl/glsl-specular-cook-torrance/blob/master/index.glsl\nfloat cookTorranceSpecular(\n  vec3 lightDirection,\n  vec3 viewDirection,\n  vec3 surfaceNormal,\n  float roughness,\n  float fresnel)\n{\n    float VdotN = max(dot(viewDirection, surfaceNormal), 0.01);\n    float LdotN = max(dot(lightDirection, surfaceNormal), 0.01);\n\n    //Half angle vector\n    vec3 H = normalize(lightDirection + viewDirection);\n\n    //Geometric term\n    float NdotH = max(dot(surfaceNormal, H), 0.01);\n    float VdotH = max(dot(viewDirection, H), 0.0001);\n    float LdotH = max(dot(lightDirection, H), 0.0001);\n    float G1 = (2.0 * NdotH * VdotN) / VdotH;\n    float G2 = (2.0 * NdotH * LdotN) / LdotH;\n    float G = clamp(min(G1, G2), 0.001, 1.);\n  \n    //Distribution term\n    //float D = GGX(roughness, VdotN, LdotN);\n    float D = beckmannDistribution(roughness, NdotH);\n    //Fresnel term\n    float F = pow(1.0 - VdotN, fresnel);\n\n    //Multiply terms and done\n    return  G * F * D / max(3.14159265 * VdotN * LdotN, 0.01);\n}\n\nvec3 brdf(\n    float Ks,\n    float Kd,\n    float roughness,\n    vec3 specularColor,\n    vec3 diffuseColor,\n    vec3 I,\n    vec3 N,\n    vec3 L,\n\tvec3 Lcolor)\n{\n    vec3 Vn = -I;\n    float NdotV = dot(Vn, N);\n    vec3 C = vec3(0.0);\n    float spec = 0.0;\n    if(NdotV>0.0)\n    {\n        float F = Fresnel_Schlick(1.0, 1.0, NdotV);\n        spec = cookTorranceSpecular(L, Vn, N, roughness, F);\n    }\n    return Kd*diffuseColor*max(0.22, max(0.0, NdotV)*max(0.0, dot(N, L)))+Ks*specularColor*spec;\n}\n\nvec4 render(vec2 scene, vec3 ro, vec3 rd, vec3 N, vec2 uv, vec2 res, float t, bool bReflection)\n{\n    vec4 colorNightSky = vec4(0.2, 0.5, 0.8, 0.);\n    vec4 color = colorNightSky;\n    //if(scene.x>CAM_FAR)\n    {\n        #if defined(ENABLE_PBR_SKY)\n            color.rgb = getSkyLight(ro+vec3(0., EARTH_RADIUS, 0.), rd, LIGHT_MOON_DIR, SKY_BETA_RAY, SKY_BETA_MIE, SKY_MIE_HEIGHT);\n        #else\n            color.rgb = getCheapSkyScattering(ro+vec3(0., EARTH_RADIUS, 0.), rd, LIGHT_MOON_DIR, 0.4*LIGHT_MOON_INTENSITY, SKY_BETA_RAY, SKY_BETA_MIE, 0.5*SKY_MIE_HEIGHT);//mix(colorNightSky, vec3(0.), .5*(1.+uv.y));\n        #endif\n        if(!bReflection)\n        {\n            float tmin = -1.0;\n            float tmax = -1.0;\n            float d = IntersectSphere(ro+vec3(0., EARTH_RADIUS, 0.), rd, vec3(0.), ATMOSPHERE_RADIUS, tmin, tmax);\n            color.a = max(0., scene.x-CAM_FAR)*remap01(random(ro+rd*res.xyx*tmax), 0.999, 1.);\n        }\n        float tmin, tmax;\n        vec3 mp = LIGHT_MOON_POS;\n        if(IntersectSphere(ro+vec3(0., EARTH_RADIUS, 0.), rd, mp, MOON_RADIUS, tmin, tmax)>-1.)\n        {\n            vec3 p = ro+rd*tmin;\n            vec3 Nm = normalize((ro+vec3(0., EARTH_RADIUS, 0.)+rd*tmin)-mp);\n            color.rgb = vec3(.3*LIGHT_MOON_INTENSITY)\n            #if defined(ENABLE_MOON_DETAILS)\n            *max(.0, remap01(fbm_hash3D(1.8*Nm), .0, 4.))\n            #endif\n            *max(0.5, dot(-rd, Nm));\n            color.a = 0.;\n        }\n    }\n    {\n        vec3 albedo = vec3(0.);\n        float Ks = 1.;\n        float roughness = 0.;\n        if(scene.y==MATERIAL_SAND)\n        {\n            albedo = vec3(0.3, 0.25, 0.28);\n            Ks = mix(.1, .2, hash2D((ro+rd*scene.x).xz));\n            roughness = .78;\n        }\n        else if(scene.y==MATERIAL_PYRAMID)\n        {\n            albedo = vec3(0.9, 0.9, 0.9)*max(0., 1.-pow(0.5*(1.+sin(6.28*scene.x)), 64.));\n            Ks = 1.;\n            roughness = 0.68;\n        }\n        else if(scene.y==MATERIAL_GOLD)\n        {\n            albedo = vec3(1.0, 0.84, 0.0);\n            Ks = 1.0;\n            roughness = 0.4;\n        }\n        else if(scene.y==MATERIAL_REED)\n        {\n            N = normalize(vec3(0.0, 0.0, -0.5));\n            albedo = vec3(0.0, 0.1, 0.0);\n            Ks = 0.2;\n            roughness = 0.8;\n        }\n        color.rgb = mix(\n            (.1*colorNightSky.rgb\n            +brdf(Ks, 1., roughness, LIGHT_MOON_COLOR, albedo, rd, N, LIGHT_MOON_DIR, LIGHT_MOON_COLOR)),\n            color.rgb\n            , remap01(scene.x, CAM_FAR-50., CAM_FAR));\n    }\n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 invRes = 1./iResolution.xy;\n    vec2 uv = fragCoord*invRes;\n    vec4 scene = texture(iChannel0, uv);\n    \n    // compute uvs\n    vec2 cuv = (fragCoord-.5*iResolution.xy)*invRes.y;\n    \n    // ray\n    vec3 ro = CAM_POS;\n    vec3 tgt = getCameraTgt(iMouse, invRes);\n    mat3 camMatrix = setCamera(ro, tgt, vec3(0., 1., 0.));\n    vec3 rd = normalize(camMatrix*normalize(vec3(cuv, CAM_DEPTH)));\n    \n    float st = SCENE_TIME(iTime);\n    \n    // shadows\n    vec3 wps = ro+rd*scene.x;\n    vec3 N = normalize(normalUnpack(scene.zw));\n    N.z = -abs(N.z);\n    float LMoonLt = max(0., dot(LIGHT_MOON_DIR, N));\n    float shadowMoon = 1.;\n    {\n        float farm = CAM_FAR*1.;\n        vec3 mp = LIGHT_MOON_DIR*farm;\n        float far = length(wps-mp);\n        shadowMoon = max(0.1, \n        clamp(exp(-.2*(far-shadows(mp, normalize(wps-mp), CAM_NEAR, far, st))), 0., 1.)\n        );\n    }\n    \n    vec4 color = render(scene.xy, ro, rd, N, uv, iResolution.xy, st, false);\n    color.rgb *= shadowMoon;\n    \n    if(scene.x<CAM_FAR)\n    {\n        vec3 dir = normalize(rd+LIGHT_MOON_DIR);\n        vec3 reprojection = (inverse(camMatrix)*dir);\n        vec2 ruv = 0.5*(1.+(reprojection.xy/reprojection.z)*CAM_DEPTH);\n        vec4 bc = texture(iChannel1, RT_CLOUD_SCALE*ruv);\n        color.rgb *= clamp((1.-length(bc.rgb))*bc.a, .5, 1.);\n    }\n   \n   fragColor = color;\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"/********************************************************************************************************\n * The MIT license\n * Copyright 2021 pierre-marie Plans <pierre.plans@gmail.com>\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy of this software\n * and associated documentation files (the \"Software\"), to deal in the Software without restriction,\n * including without limitation the rights to use, copy, modify, merge, publish, distribute,\n * sublicense, and/or sell copies of the Software, and to permit persons to whom the Software\n * is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all copies\n * or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\n * INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR\n * PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE\n * FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,\n * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n *********************************************************************************************************/\n\n//#define ENABLE_PBR_SKY\n#define ENABLE_MOON_DETAILS\n#define ENABLE_CLOUDS_HIDE_MOON\n//#define ENABLE_HD_CLOUD_DENSITY\n#define ENABLE_REEDS\n#define ENABLE_HD_SAND_DEPTH\n\n#define RT_WATER_SCALE 1.0\n#define RT_CLOUD_SCALE 0.5\n\n#define CAM_TGT \tvec3(-0.2, 3., 20.)\n#define CAM_POS \tvec3(0., 2.5, -20.)\n#define CAM_DEPTH\t1.3\n#define CAM_NEAR \t0.01\n#define CAM_FAR\t\t200.0\n\n#define LIGHT_MOON_DIR normalize(vec3(0.25, 0.32, 0.6))\n#define LIGHT_MOON_POS LIGHT_MOON_DIR*MOON_DIST*.07\n#define LIGHT_MOON_COLOR vec3(1.)\n#define LIGHT_MOON_INTENSITY 25.\n\n#define MAIN_SCENE_MAX_STEPS 120\n#define SHADOW_STEPS 20\n#define CLOUD_MAIN_STEPS 14\n#define CLOUD_LIGHT_STEPS 8\n\n#define CLOUD_ABSORBTION 0.2\n\n#define SCENE_SPEED 0.1\n#define SCENE_TIME_OFFSET 22.\n#define SCENE_TIME(t) (SCENE_SPEED*(t+SCENE_TIME_OFFSET))\n\n#define SKY_BETA_MIE vec3(10e-7)\n#define SKY_BETA_RAY vec3(5.5e-7, 7.0e-7, 12.4e-7)\n//#define SKY_BETA_MIE vec3(21e-7)\n//#define SKY_BETA_RAY vec3(5.5e-6, 13.0e-6, 22.4e-6)\n// 780.\n#define SKY_MIE_HEIGHT 420.\n#define EARTH_RADIUS\t6360e3\n#define ATMOSPHERE_RADIUS \t6420e3\n// 384467700.0\n#define MOON_DIST 384400e3\n#define MOON_RADIUS 1737.4e3\n#define SUN_DIST \t149597870700.0\n\n#define WATER_LEVEL 0.0\n#define WATER_VISIBILITY 8.0\n\n#define MATERIAL_VOID -1.\n#define MATERIAL_SAND 0.\n#define MATERIAL_PYRAMID 1.\n#define MATERIAL_GOLD 2.\n#define MATERIAL_REED 3.\n\nfloat remap01(float x, float m_, float _m)\n{\n \treturn clamp((x-m_)/(_m-m_), 0., 1.);\n}\n\nvec2 scene_min(vec2 a, vec2 b)\n{\n    return a.x<b.x?a:b;\n}\n\nfloat distToPlane(vec3 o, vec3 d, vec3 p, vec3 n)\n{\n    return dot(o - p, n) / dot(n, -d);\n}\n\nfloat IntersectSphere(vec3 ro, vec3 rd, vec3 sc, float sr, out float tmin, out float tmax) {\n    vec3 Z = ro-sc;\n    float B = 2.0 * dot(rd, Z);\n  \n    float C = Z.x*Z.x+Z.y*Z.y+Z.z*Z.z-sr*sr;\n    float D = B*B - 4.0*C;\n    float d = -1.0;\n    if(D>=0.0) {\n        if(C==0.0) {\n            tmin = -B/2.0;\n            tmax = -1.;\n            d = 0.0;\n        }else{\n            tmin = (-B-sqrt(D))/2.0;\n            tmax = (-B+sqrt(D))/2.0;\n            d = 1.0;\n        }\n    }\n    return d;\n}\n\n// NOISES\n\nvec2 rot(vec2 X, float a)\n{\n \tfloat s = sin(a); float c = cos(a);\n    return mat2(c, -s, s, c)*X;\n}\n\nfloat hash2D(vec2 uv)\n{\n \tvec2 suv = sin(uv);\n    suv = rot(suv, uv.x);\n    return fract(mix(suv.x*13.13032942, suv.y*12.01293203924, dot(uv, suv)));\n}\n\n// begin https://stackoverflow.com/questions/4200224/random-noise-functions-for-glsl#answer-17479300\n// I was already using this on CPU for some work projects but did not had the idea to use it in shaders\n// until now. This has improven performances way more than I expected.\nuint hash( uint x )\n{\n    x += ( x << 10u );\n    x ^= ( x >>  6u );\n    x += ( x <<  3u );\n    x ^= ( x >> 11u );\n    x += ( x << 15u );\n    return x;\n}\n\n// Compound versions of the hashing algorithm I whipped together.\nuint hash( uvec2 v ) { return hash( v.x ^ hash(v.y)                         ); }\nuint hash( uvec3 v ) { return hash( v.x ^ hash(v.y) ^ hash(v.z)             ); }\n\nfloat uintToFloat( uint m )\n{\n    return uintBitsToFloat(0x3F800000u|(m&0x007FFFFFu) ) - 1.0;\n}\n// end https://stackoverflow.com/questions/4200224/random-noise-functions-for-glsl#answer-17479300\n\nfloat random( vec2  v ) { return uintToFloat(hash(packSnorm2x16(v))); }\nfloat random( vec3  v ) { return uintToFloat(hash(\n    uvec3(floatBitsToUint(v.x), floatBitsToUint(v.y),floatBitsToUint(v.z))\n)); }\n\n\nfloat smooth_hash2D(vec2 uv)\n{\n \tvec2 lower\t= floor(uv);\n    vec2 frac \t= fract(uv);\n    vec2 f = frac*frac*(3.0-2.0*frac);\n    \n    return mix(\n        \tmix(hash2D(lower+vec2(0.0, 0.0)), hash2D(lower+vec2(1.0, 0.0)), f.x),\n        \tmix(hash2D(lower+vec2(0.0, 1.0)), hash2D(lower+vec2(1.0, 1.0)), f.x),\n        \tf.y);\n}\n\nfloat fbm_hash2D(vec2 uv)\n{\n    float total = 0.0;\n    total += 0.5000*smooth_hash2D(uv); uv*=2.001;\n    total += 0.2500*smooth_hash2D(uv); uv*=2.003;\n    total += 0.1250*smooth_hash2D(uv); uv*=2.002;\n    total += 0.0625*smooth_hash2D(uv); uv*=2.001;\n    return clamp(total, 0.0, 1.0);\n}\n\nfloat hash3D(vec3 uv)\n{\n \tvec3 suv = fract(sin(uv));\n    mat3 rdz = mat3(0.324354, 0.303147, 0.21024,\n                    0.405434, 0.723953, 0.69343,\n                    0.904379, 0.594319, 0.10439);\n    suv = rdz*suv;\n    return fract(dot(suv, uv)*1204.9324234934);\n}\n\nfloat smooth_hash3D(vec3 uv)\n{\n \tvec3 lower\t= floor(uv);\n    vec3 frac \t= fract(uv);\n    vec3 f = frac*frac*(3.0-2.0*frac);\n    \n    return mix( // Z\n        \tmix( // Y\n                mix( // X\n                    hash3D(lower+vec3(0.0, 0.0, 0.0)), hash3D(lower+vec3(1.0, 0.0, 0.0)), f.x),\n                mix( // X\n                    hash3D(lower+vec3(0.0, 1.0, 0.0)), hash3D(lower+vec3(1.0, 1.0, 0.0)), f.x),\n                f.y),\n        \tmix( // Y\n                mix( // X\n                    hash3D(lower+vec3(0.0, 0.0, 1.0)), hash3D(lower+vec3(1.0, 0.0, 1.0)), f.x),\n                mix( // X\n                    hash3D(lower+vec3(0.0, 1.0, 1.0)), hash3D(lower+vec3(1.0, 1.0, 1.0)), f.x),\n                f.y),\n        \tf.z);\n}\n\nfloat fbm_hash3D(vec3 uv)\n{\n    float total = 0.0;\n    total += 0.5000*smooth_hash3D(uv); uv*=2.001;\n    total += 0.2500*smooth_hash3D(uv); uv*=2.003;\n    total += 0.1250*smooth_hash3D(uv); uv*=2.002;\n    total += 0.0625*smooth_hash3D(uv); uv*=2.001;\n    return clamp(total, 0.0, 1.0);\n}\n\nfloat voronoi2D(vec2 uv)\n{\n    vec2 fl = floor(uv);\n    vec2 fr = fract(uv);\n    float res = 1.0;\n    for(int k=-1;k<=1;k++)\n    for(int j=-1; j<=1; j++ )\n    {\n        vec2 p = vec2(j, k);\n        float h = random(fl+p);\n        vec2 vp = p-fr+h;\n        float d = dot(vp, vp);\n\n        res +=1.0/pow(d, 16.0);\n    }\n    return pow( 1.0/res, 1.0/16.0 );\n}\n\nfloat voronoi3D(vec3 uv)\n{\n    vec3 fl = floor(uv);\n    vec3 fr = fract(uv);\n    float res = 1.0;\n    for(int k=-1;k<=1;k++)\n    for( int j=-1; j<=1; j++ ) {\n        for( int i=-1; i<=1; i++ ) {\n            vec3 p = vec3(i, j, k);\n            float h = random(fl+p);\n            vec3 vp = p-fr+h;\n            float d = dot(vp, vp);\n            \n            res +=1.0/pow(d, 16.0);\n        }\n    }\n    return pow( 1.0/res, 1.0/16.0 );\n}\n\n// SCENE\n\n// iq sdf methods\nfloat sdOctahedron( vec3 p, float s)\n{\n  p = abs(p);\n  float m = p.x+p.y+p.z-s;\n  vec3 q;\n       if( 3.0*p.x < m ) q = p.xyz;\n  else if( 3.0*p.y < m ) q = p.yzx;\n  else if( 3.0*p.z < m ) q = p.zxy;\n  else return m*0.57735027;\n    \n  float k = clamp(0.5*(q.z-q.y+s),0.0,s); \n  return length(vec3(q.x,q.y-s+k,q.z-k)); \n}\n\nfloat sdCappedCylinder( vec3 p, float h, float r )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdCappedCylinder(vec3 p, vec3 a, vec3 b, float r)\n{\n  vec3  ba = b - a;\n  vec3  pa = p - a;\n  float baba = dot(ba,ba);\n  float paba = dot(pa,ba);\n  float x = length(pa*baba-ba*paba) - r*baba;\n  float y = abs(paba-baba*0.5)-baba*0.5;\n  float x2 = x*x;\n  float y2 = y*y*baba;\n  float d = (max(x,y)<0.0)?-min(x2,y2):(((x>0.0)?x2:0.0)+((y>0.0)?y2:0.0));\n  return sign(d)*sqrt(abs(d))/baba;\n}\n\nfloat sdVerticalCapsule( vec3 p, float h, float r )\n{\n  p.y -= clamp( p.y, 0.0, h );\n  return length( p ) - r;\n}\n\nvec3 opCheapBend(in vec3 p, float k)\n{\n    float c = cos(k*p.y);\n    float s = sin(k*p.y);\n    mat2  m = mat2(c,-s,s,c);\n    return vec3(m*p.xy,p.z);\n}\n\nvec2 opRep(in vec2 p, const vec2 r)\n{\n    return mod(p+0.5*r,r)-0.5*r;\n}\n\n// scene build-ups\n\nvec2 scene_base_sand(vec3 _p)\n{\n \treturn vec2(_p.y\n    -(\n    #if defined(ENABLE_HD_SAND_DEPTH)\n        .2*_p.z*fbm_hash3D(_p*.02)+remap01(_p.z, -40., 40.)*voronoi3D(.2*_p)\n    #else\n        .2*_p.z*fbm_hash2D(_p.xz*.02)+remap01(_p.z, -40., 40.)*voronoi2D(.2*_p.xz)\n    #endif\n    )\n    , MATERIAL_SAND);\n}\n\nvec2 scene_reed(vec3 _p, float depth, float o, float t)\n{\n    _p = opCheapBend(_p, -.08*(.5*(1.+sin(10.*t)))+o);\n    float d = (sdVerticalCapsule( _p, 1.5, 0.01 ));\n \treturn vec2(d, MATERIAL_REED);\n}\n\nvec2 scene_reeds(vec3 _p, float depth, float t)\n{\n    float cd = abs(length(_p.xz)-14.);\n    float zo = 0.1*fbm_hash2D(1.*_p.xz);\n    float h = 5.-4.8*(clamp(.9*(5.-cd), 0., 1.));\n    vec2 rp = opRep(_p.xz, vec2(0.2));\n    return scene_reed(vec3(rp-0.2+0.4*hash2D(0.1*_p.xz), _p.y+cd*h-.6+10.*zo).xzy, depth, zo, t+5.14*zo);\n}\n\nvec2 scene_pyramid(vec3 _p, float h)\n{\n    float htop = h*.25;\n    float topPy = sdOctahedron(_p-vec3(0., h-htop*.8, 0.), htop);\n    _p.y = 0.5*floor(2.*_p.y);\n    float d = sdOctahedron(_p, h);\n    return scene_min(vec2(d, MATERIAL_PYRAMID), vec2(topPy, MATERIAL_GOLD));\n}\n\nvec2 scene_pyramids(vec3 _p)\n{\n    return scene_min(\n            scene_min(scene_pyramid(_p-vec3(10., 2., 35.), 16.), scene_pyramid(_p-vec3(-10., 2., 40.), 12.))\n                , scene_pyramid(_p-vec3(-30., 2., 65.), 8.)\n            );\n}\n\nvec2 raymarch_main_scene(vec3 _p, float t)\n{\n    vec2 sand = scene_base_sand(_p);\n    #if defined(ENABLE_HD_SAND_DEPTH)\n    sand.x = max(sand.x, -(length(_p-vec3(30., 10., 140.))-90.));\n    #else\n    sand.x = max(sand.x, -(length(_p-vec3(-20., 2., 53.))-16.));\n    #endif\n    #if defined(ENABLE_REEDS)\n \treturn scene_min(scene_reeds(_p-vec3(1., 0., -3.), sand.x, t), scene_min(sand, scene_pyramids(_p)));\n    #else\n        return scene_min(sand, scene_pyramids(_p));\n    #endif\n}\n\nvec2 raymarch_main_scene_normals(vec3 _p, float t)\n{\n    return scene_min(scene_base_sand(_p), scene_pyramids(_p));\n}\n\n// rm\n\nvec2 raymarch_main(vec3 _ro, vec3 _rd, float _near, float _far, float t)\n{\n    vec2 close;\n    close.x = 0.;\n    for(int i = 0;i < MAIN_SCENE_MAX_STEPS; ++i)\n    {\n        vec3 p = _ro+_rd*close.x;\n        // eval scene\n        vec2 t = raymarch_main_scene(p, t);\n        if(t.x<_near || close.x>_far)\n            break;\n        close.x += t.x*0.5;\n        close.y = t.y;\n    }\n    return close;\n}\n\nvec3 raymarch_main_normal(vec3 _p, float eps, float t)\n{\n    vec3 n;\n    n.y = raymarch_main_scene_normals(_p, t).x;\n    n.x = raymarch_main_scene_normals(_p+vec3(eps, 0., 0.), t).x-n.y;\n    n.z = raymarch_main_scene_normals(_p+vec3(0., 0., eps), t).x-n.y;\n    n.y = raymarch_main_scene_normals(_p+vec3(0., eps, 0.), t).x-n.y;\n    return normalize(n);\n}\n\n// From http://www.scratchapixel.com/old/lessons/3d-advanced-lessons/simulating-the-colors-of-the-sky/atmospheric-scattering/\nvec3 getSkyLight(vec3 ro, vec3 rd, vec3 L, vec3 betaR, vec3 betaM, float _hm)\n{\n    #define ERR vec3(1., 0., 0.)\n    float tmin = -1.0;\n    float tmax = -1.0;\n    float d = IntersectSphere(ro, rd, vec3(0.), ATMOSPHERE_RADIUS, tmin, tmax);\n    \n    //tmax = max(1., min(max(0., temin), tmax));\n  \n    float RdotL = dot(rd, L);\n    float tCurrent = 0.;\n    float segL = (tmax-tCurrent)/16.0;\n     \n    float g = 0.76; // 0.76\n    float g2 = g*g;\n    float hr = 7994.0; // 7994\n    float hm = _hm;//800.0; // 1200\n    // Rayleigh\n    vec3 sumR = vec3(0.0);\n    float phaseR = 3.0/(16.0*3.14)*(1.0+RdotL*RdotL);\n    //vec3 betaR = vec3(5.5e-6, 13.0e-6, 22.4e-6);\n    float opticalDepthR = 0.0;\n    // Mie\n    vec3 sumM = vec3(0.0);\n    //float phaseM = 3.0/(8.0*3.14)*((1.0-g*g)+(1.0+RdotL*RdotL))/((2.0+g*g)+pow(1.0+g*g-2.0*g*RdotL, 1.5));\n    // correction thanks to http://http.developer.nvidia.com/GPUGems2/gpugems2_chapter16.html\n    // my implementation had an error with the first terms in the equation\n    float phaseM = (\n        \t\t\t(3.0*(1.0-g2))/\n        \t\t\t(2.0*(2.0+g2))\n        \t\t\t)*\n        \t\t\t(\n                        (1.0+RdotL*RdotL)/\n                        pow(1.0+g2-2.0*g*RdotL, 1.5)\n                    );\n    //vec3 betaM = vec3(21e-6);\n    float opticalDepthM = 0.0;\n    for (int i = 0; i < 16; ++i)\n    {\n        vec3 X = ro+rd*(tCurrent+0.5*segL);\n        float h = length(X) - EARTH_RADIUS;\n        float _hr = exp(-h/hr)*segL;\n        float _hm = exp(-h/hm)*segL;\n        opticalDepthR += _hr;\n        opticalDepthM += _hm;\n        vec3 lRay = L;//normalize((SUNDIST*L)-X);\n        float tlmin = 0.0;\n        float tlmax = 0.0;\n        float tlemin, tlemax;\n        //vec3 Ll = normalize(Lpos-X);\n        //float dl = IntersectSphere(X, Ll, vec3(0.), ATMOSPHERE_RADIUS, tlmin, tlmax);\n        \n        float tCurrentLight = 0.;\n        float segLLight = (tlmax-tCurrentLight)/8.0;\n        tCurrentLight = max(0., tlmin);\n        segLLight = (tlmax-tCurrentLight)/8.;\n        float opticalDepthLightR = 0.0;\n        float opticalDepthLightM = 0.0;\n        bool ended = true;\n        for (int j = 0; j < 8; ++j)\n        {\n            vec3 samplePositionLight = X+L*(tCurrentLight + 0.5 * segLLight);\n            float hLight = length(samplePositionLight) - EARTH_RADIUS;\n            if (hLight < 0.0)\n            {\n                ended = false;\n                break;\n            }\n            opticalDepthLightR += exp(-hLight / hr) * segLLight;\n            opticalDepthLightM += exp(-hLight / hm) * segLLight;\n            tCurrentLight += segLLight;\n        }\n        if (ended)\n        {\n            vec3 tau = betaR * (opticalDepthR + opticalDepthLightR) + betaM * 1.1 * (opticalDepthM + opticalDepthLightM);\n            vec3 attenuation = vec3(exp(-tau.x), exp(-tau.y), exp(-tau.z));\n            sumR += _hr * attenuation;\n            sumM += _hm * attenuation;\n        }\n        tCurrent += segL;\n    }\n    return LIGHT_MOON_INTENSITY * (sumR * phaseR * betaR + sumM * phaseM * betaM);\n}\n\n// Huge sky approximation, it does not follow the correct end values but is nice and fast\nvec3 getCheapSkyScattering(vec3 ro, vec3 rd, vec3 L, float intensity, vec3 betaR, vec3 betaM, float _iHM)\n{\n    float tmin = -1.0;\n    float tmax = -1.0;\n    float d = IntersectSphere(ro, rd, vec3(0.), ATMOSPHERE_RADIUS, tmin, tmax);\n    if(d<0.)\n        return vec3(0., 1., 0.);\n    float dist = max(0., max(tmin, tmax));\n  \n    float RdotL = dot(rd, L);\n     \n    const float g = 0.76; // 0.76\n    const float g2 = g*g;\n    const float hr = 7994.0; // 7994\n    float hm = _iHM;//800.0; // 1200\n    \n    float phaseR = max(0., /*3.0/(16.0*3.14)*/0.05968310*(1.0+RdotL*RdotL));\n    //float phaseM = 3.0/(8.0*3.14)*((1.0-g*g)+(1.0+RdotL*RdotL))/((2.0+g*g)+pow(1.0+g*g-2.0*g*RdotL, 1.5));\n    // correction thanks to from http://http.developer.nvidia.com/GPUGems2/gpugems2_chapter16.html\n    // my implementation had an error with the first terms in the equation\n    /*float phaseM = (\n                    (3.0*(1.0-g2))/\n        \t\t\t(2.0*(2.0+g2))\n        \t\t\t)*\n        \t\t\t(\n                        (1.0+RdotL*RdotL)/\n                        pow(1.0+g2-2.0*g*RdotL, 1.5)\n                    );*/\n    float phaseM = max(0., /*(3./(2.*g2+2.)-.75)*/0.245810055866*exp(pow(RdotL+.38, 5.) -.85));// this ~works because g = 0.76\n    \n    vec3 pt = ro+rd*dist;\n    float dn = remap01(dot(L, vec3(0., 1., 0.)), 0.95, 1.0); // 0.1 -> 1.\n    //float odr = exp(-h/hr)*dist;\n    //float odm = exp(-h/hm)*dist;\n    const float s = 0.02;\n    float _h = s*(length(pt)-EARTH_RADIUS);\n    if(_h<0.)\n        return vec3(0., 1., 0.);\n    float odr= exp(-_h/hr)*dist, odm = exp(-_h/hm)*dist;\n    float stepL = 300.;\n    \n    float itmin = -1.0;\n    float itmax = -1.0;\n    d = IntersectSphere(pt, L, vec3(0.), ATMOSPHERE_RADIUS, itmin, itmax);\n    if(d<0.)\n        return vec3(0., 1., 0.);\n    stepL = max(0., max(itmin, itmax))*0.25;\n    \n    for(int i = 0;i<4;++i)\n    {\n        pt += L*stepL;\n        float h = s*(length(pt)-EARTH_RADIUS);\n        //if(h<0.)\n        //    return vec3(0.);\n        odr += exp(-h/hr)*stepL;\n        odm += exp(-h/hm)*stepL;\n    }\n    //odr= exp(-0.05*_h/hr)*dist;\n    //odm = exp(-0.05*_h/hm)*dist;\n\n    vec3 attenuation = exp(-(betaR * odr + betaM * 1.1 * odm));\n    vec3 sumR = odr * attenuation;\n    vec3 sumM = odm * attenuation;\n    return intensity * (sumR * phaseR * betaR + sumM * phaseM * betaM);\n}\n\nfloat shadows(vec3 _ro, vec3 _rd, float _near, float _far, float t)\n{\n    float d = _near;\n    for(int i = 0;i < SHADOW_STEPS; ++i)\n    {\n        vec3 p = _ro+_rd*d;\n        // eval scene\n        vec2 t = raymarch_main_scene_normals(p, t);\n        if(abs(t.x)<_near || d>_far)\n            break;\n        d += t.x*0.5;\n    }\n    return d;\n}\n\n// NORMAL\n\nvec2 normalPack(vec3 n)\n{\n    return n.xy*0.5+0.5;\n}\n\nvec3 normalUnpack(vec2 enc)\n{\n    vec3 n;\n    n.xy = enc*2.0-1.0;\n    n.z = sqrt(1.0-dot(n.xy, n.xy));\n    return n;\n}\n\n// CAMERA\n\nvec3 getCameraTgt(vec4 _m, vec2 _ir)\n{\n    #if 0\n    vec2 nm = -3.14*(-1.+2.*_m.xy*_ir.xy);\n    vec2 cs = vec2(cos(nm.x), sin(nm.x));\n    mat2 rot = mat2(cs.x, -cs.y, cs.y, cs.x);\n    vec3 camTgt = CAM_TGT;\n    camTgt.xz = rot*camTgt.xz;\n    return _m.z<=0.?CAM_TGT:camTgt+vec3(0., 2.*sin(3.14*(-1.+2.*_m.y*_ir.y)), 0.);\n    #else\n    return CAM_TGT;\n    #endif\n}\n\n// the camera construction method is inspired by the one from IQ\nmat3 setCamera( in vec3 ro, in vec3 tgt, vec3 up )\n{\n\tvec3 cw = normalize(tgt-ro);\n\tvec3 cu = normalize( cross(cw,up) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"/********************************************************************************************************\n * The MIT license\n * Copyright 2021 pierre-marie Plans <pierre.plans@gmail.com>\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy of this software\n * and associated documentation files (the \"Software\"), to deal in the Software without restriction,\n * including without limitation the rights to use, copy, modify, merge, publish, distribute,\n * sublicense, and/or sell copies of the Software, and to permit persons to whom the Software\n * is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all copies\n * or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\n * INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR\n * PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE\n * FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,\n * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n *********************************************************************************************************/\n\nfloat Water(vec2 p)\n{\n    float f = 0.4;\n    float s = SCENE_SPEED;\n    float wg = 1.0;\n    float it = 0.;\n    float wt = wg*2.0;\n    float wh = wt*fbm_hash2D(1.2*p);\n    for(int i =0; i < 8; ++i)\n    {\n        vec2 dir = vec2(cos(it), sin(it));\n        float x = dot(p, dir)*f+s*iTime;\n        float w = exp(sin(x)*sin(2.*x)*sin(4.*x)-1.)*.58;\n        p += normalize(p) * -w * cos(x) * wg * .2 - vec2(s*iTime, 0.);\n        wh += w * wg;\n        \n        it += .72;\n        f *= 1.6;\n        s *= 1.1;\n        wt += wg;\n        wg = mix(wg, 0., .2);\n    }\n    return wh/wt;\n}\n\nvec3 WaterNormal(vec3 p, float e)\n{\n    vec3 N;\n    N.y = Water(p.xz);\n    N.x = Water(p.xz-vec2(e, 0.))-N.y;\n    N.z = Water(p.xz-vec2(0., e))-N.y;\n    return normalize(N);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 invRes = 1./iResolution.xy;\n    vec2 uv = fragCoord*invRes;\n    \n    vec2 ouv = uv;\n    if(uv.x>RT_WATER_SCALE || uv.y>RT_WATER_SCALE)\n        return;\n    uv *= 1./RT_WATER_SCALE;\n    \n    vec4 scene = texture(iChannel0, uv);\n    \n    // compute uvs\n    vec2 cuv = (-1.+2.*uv);\n    \n    // ray\n    vec3 ro = CAM_POS;\n    vec3 tgt = getCameraTgt(iMouse, invRes);\n    mat3 camMatrix = setCamera(ro, tgt, vec3(0., 1., 0.));\n    vec3 rd = normalize(camMatrix*normalize(vec3(cuv, CAM_DEPTH)));\n    \n    // shadows\n    vec3 wps = ro+rd*scene.x;\n    vec3 color = vec3(0.);\n    // pp\n    float a = 1.;\n    vec3 n = normalUnpack(scene.zw);\n    fragColor.a = a;\n    fragColor.rgb = color;\n    // early exit for reed in front screen\n    if(texture(iChannel0, uv).y==MATERIAL_REED)\n        return;\n\n    if(wps.y<WATER_LEVEL)\n    {\n        float wh = remap01(WATER_LEVEL-wps.y, 0., WATER_VISIBILITY);\n        \n        a *= 1.-wh;\n        vec3 Nw = mix(vec3(0., 1., 0.), WaterNormal(wps, 0.02), wh);\n        float distPlane = distToPlane(ro, rd, vec3(0., WATER_LEVEL, 0.), Nw);\n        distPlane = abs(distPlane);\n        {\n            vec3 pw = ro+rd*distPlane;\n            \n            vec3 rrd = reflect(rd, Nw);\n            vec3 reprojection = (inverse(camMatrix)*rrd);\n            vec2 ruv = 0.5*(1.+(reprojection.xy/reprojection.z)*CAM_DEPTH);\n\n            vec2 iruv = vec2(ruv.x, -ruv.y);\n            \n            vec4 colorBuffer = texture(iChannel1, uv);\n            color = colorBuffer.rgb+colorBuffer.a;\n            vec4 reflBuffer = texture(iChannel1, ruv);\n            \n            float F = 0.02+0.98*pow(1.-max(0., dot(Nw, -rd)), 5.);\n            float lumi = max(.2, dot(Nw, LIGHT_MOON_DIR));\n            vec3 tint = vec3(0.028, 0.032, 0.037);\n            vec3 sceneRefl = exp(0.1*LIGHT_MOON_INTENSITY*reflBuffer.rgb);\n            vec3 wcol = mix(tint*max(.22, 1.0-wh), sceneRefl, F)*lumi;\n            \n            color = mix(color, wcol, wh);\n            \n            vec4 cl = texture(iChannel2, RT_CLOUD_SCALE*ruv);\n            color *= cl.a;\n            color += cl.rgb*(1.-cl.a);\n            \n            wps = pw;\n        }\n    }\n    \n    {\n        vec3 dir = normalize(reflect(rd, normalize(vec3(0.2, 1., 0.)))+LIGHT_MOON_DIR);\n        vec3 reprojection = (inverse(camMatrix)*dir);\n        vec2 ruv = 0.5*(1.+(reprojection.xy/reprojection.z)*CAM_DEPTH);\n        vec4 bc = texture(iChannel2, RT_CLOUD_SCALE*ruv);\n        color *= clamp(bc.a*4.*reprojection.z, 0.5, 1.);\n    }\n   \n    fragColor.rgb = color;\n    fragColor.a = a;\n}","name":"Buffer C","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"/********************************************************************************************************\n * The MIT license\n * Copyright 2021 pierre-marie Plans <pierre.plans@gmail.com>\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy of this software\n * and associated documentation files (the \"Software\"), to deal in the Software without restriction,\n * including without limitation the rights to use, copy, modify, merge, publish, distribute,\n * sublicense, and/or sell copies of the Software, and to permit persons to whom the Software\n * is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all copies\n * or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\n * INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR\n * PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE\n * FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,\n * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n *********************************************************************************************************/\n\nfloat phaseHG(float g, float cosTeta)\n{\n\treturn (1.-g*g)/(4.*3.14*pow(1.+g*g-2.*g*cosTeta, 1.5));\n}\n\nfloat heightSignal(float a, float x, float h)\n{\n    return max(a, h*exp(-x));\n    return (x-a)*(x-a-h)*(-4./(h*h));\n}\n\nfloat cloudDensity(vec3 _p, float bot, float top, float time, float s)\n{\n    float py = remap01(_p.y, bot, top);\n    vec3 dir = vec3(-time, 0., 0.);\n    float base = remap01(fbm_hash2D(_p.xz*0.02+dir.xz), .5, 0.8);\n    #if defined(ENABLE_HD_CLOUD_DENSITY)\n    float bb = (1.-2.0*voronoi3D(_p*0.2+dir));\n    return clamp(\n        (base\n        *(bb+(1.-1.6*fbm_hash3D(_p*1.6-dir)))\n        )\n        *heightSignal(-0.11, max(0., py), 1.0)\n        *s\n    , 0., 1.);\n    #else\n    return clamp(\n        (base-(0.5*fbm_hash3D(0.2*_p+dir))\n        )\n        *heightSignal(-0.11, max(0., py), 1.0)\n        *s\n    , 0., 1.);\n    #endif\n}\n\nvec4 clouds(vec3 ro, vec3 rd, vec2 uv, float scenex, float time, float bot, float top)\n{\n    vec4 sl = vec4(vec3(0.), 1.);\n    float nearPlane = distToPlane(ro, rd, vec3(0., bot, 0.), vec3(0., 1., 0.));\n    if(nearPlane>0.)\n    {\n        float farPlane = distToPlane(ro, rd, vec3(0., top, 0.), vec3(0., 1., 0.));\n        float st=(farPlane-nearPlane)/float(CLOUD_MAIN_STEPS);\n        float t = nearPlane+st*0.5*RT_CLOUD_SCALE*(-1.+2.*random(uv+10.*time));\n        #if defined(ENABLE_CLOUDS_HIDE_MOON)\n            float ds = 1.;\n        #else\n            float ds = 1.-pow(max(0., dot(rd, LIGHT_MOON_DIR)), 5.);\n        #endif\n        float cosTeta = dot(rd, LIGHT_MOON_DIR);\n        float hgf = mix(phaseHG(-0.4, cosTeta), phaseHG(0.7, cosTeta), .5);\n        for(int i = 0;i<CLOUD_MAIN_STEPS;++i)\n        {\n            vec3 p = ro+rd*t;\n            vec3 L = LIGHT_MOON_DIR;\n            float den = .5*max(0., 1.-(max(0., t-scenex)/CAM_FAR));\n            den *= cloudDensity(p, bot, top, time, ds);\n            if(den>0.01)\n            {\n                #if defined(ENABLE_PBR_SKY)\n                vec3 scatter = getSkyLight(p+vec3(0., EARTH_RADIUS, 0.), rd, L, SKY_BETA_RAY, SKY_BETA_MIE, SKY_MIE_HEIGHT);\n                #else\n                vec3 scatter = getCheapSkyScattering(p+vec3(0., EARTH_RADIUS, 0.), rd, L, LIGHT_MOON_INTENSITY, SKY_BETA_RAY, SKY_BETA_MIE, SKY_MIE_HEIGHT);\n                #endif\n                float d = 0.5;\n                float transmittance = sl.a;\n                float stepL = 0.5*st;\n                for(int j = 0;j < CLOUD_LIGHT_STEPS; ++j)\n                {\n                    vec3 pm = p+L*d;\n\n                    float denm = cloudDensity(pm, bot, top, time, ds);\n                    if(denm>0.01)\n                    {\n                        transmittance *= exp(-CLOUD_ABSORBTION*stepL*denm);\n                    }\n                    d+= stepL;\n                }\n                vec3 lum = (.05*remap01(p.y, bot, top)+scatter*den)*hgf*transmittance;\n                sl.rgb += sl.a*(lum-transmittance*lum)/den;\n\n                sl.a = transmittance;\n            }\n            t+=st;\n        }\n    }\n    return sl;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 invRes = 1./iResolution.xy;\n    vec2 uv = fragCoord*invRes;\n    \n    vec2 ouv = uv;\n    fragColor = vec4(0.);\n    if(uv.x>RT_CLOUD_SCALE || uv.y>RT_CLOUD_SCALE)\n        return;\n    uv *= 1./RT_CLOUD_SCALE;\n    \n    vec4 scene = texture(iChannel0, uv);\n    \n    // compute uvs\n    vec2 cuv = -1.+2.*uv;\n    vec3 oTgt = texture(iChannel1, vec2(.0, .0)).rgb;\n    \n    // ray\n    vec3 ro = CAM_POS;\n    vec3 tgt = getCameraTgt(iMouse, invRes);\n    mat3 camMatrix = setCamera(ro, tgt, vec3(0., 1., 0.));\n    vec3 rd = normalize(camMatrix*normalize(vec3(cuv, CAM_DEPTH)));\n   \n    // pp\n    vec3 color = vec3(0.);\n    vec4 sl1 = clouds(ro, rd, uv, scene.x, 0.1*SCENE_TIME(iTime), 100., 120.);\n    vec4 sl2 = clouds(ro, rd, uv, scene.x, 0.6*SCENE_TIME(iTime), 40., 60.);\n    const float temporalValue = 0.1;\n    \n    /*mat3 oCamMatrix = setCamera(ro, oTgt, vec3(0., 1., 0.));\n    vec3 oRd = normalize(oCamMatrix*normalize(vec3(cuv, CAM_DEPTH)));\n    vec3 oVecReproj = (inverse(camMatrix)*oRd);\n    vec2 oCamuv = .5*(1.+oVecReproj.xy*oVecReproj.z*CAM_DEPTH)*RT_CLOUD_SCALE;\n    \n    fragColor = mix(texture(iChannel1, ouv), vec4(sl1.rgb*sl2.a+sl2.rgb, sl1.a*sl2.a), temporalValue);\n    if(fragCoord.x == 0. && fragCoord.y == 0.)\n    {\n        fragColor = vec4(tgt, 1.);\n    }*/\n    fragColor = mix(texture(iChannel1, ouv), vec4(sl1.rgb*sl2.a+sl2.rgb, sl1.a*sl2.a), temporalValue);\n}","name":"Buffer D","description":"","type":"buffer"}]}