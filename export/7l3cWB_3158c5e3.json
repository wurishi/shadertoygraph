{"ver":"0.1","info":{"id":"7l3cWB","date":"1660438484","viewed":114,"name":"Procedural SDF Landscape","username":"nethe550","description":"A simple landscape rendered as a path-traced signed distance field.\n","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["procedural","sdf","landscape"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// nethe550\n// A simple landscape rendered as a path-traced signed-distance field.\n\n#define MAX_STEPS 128\n#define FAR_PLANE 75.0\n\n// ========================= //\n\nstruct Material {\n    vec3 color;\n    float specular;\n};\n\nstruct SDF {\n    vec3 position;\n    Material material;\n};\n\nstruct SDFTest {\n    float dist;\n    SDF sdf;\n};\n\nstruct Ray {\n    vec3 origin;\n    vec3 direction;\n    int maxSteps;\n    float collisionEpsilon;\n    float farPlane;\n};\n\nstruct RaycastHit {\n    float t;\n    bool hit;\n    vec3 position;\n    vec3 normal;\n    SDFTest test;\n};\n\nstruct Camera {\n    vec3 position;\n    vec3 target;\n    vec3 up;\n    float fov;\n    float farPlane;\n};\n\nstruct DirectionalLight {\n    vec3 direction;\n    vec3 color;\n};\n\n// ========================= //\n\nSDFTest terrain(vec3 position, SDF sdf, int octaves, float amplitude, float frequency, float persistence, float lacunarity) {\n    SDFTest t;\n    position += sdf.position;\n    float sum = 0.0;\n    for (int i = 0; i < octaves; i++) {\n        sum += amplitude * (0.5 + 0.5 * snoise(position.xz * frequency));\n        amplitude *= persistence;\n        frequency *= lacunarity;\n    }\n    t.dist = position.y + sum;\n    t.sdf = sdf;\n    return t;\n}\n\n// ========================= //\n\nSDFTest SDFUnion(SDFTest a, SDFTest b) {\n    if (a.dist < b.dist) return a;\n    return b;\n}\n\nSDFTest scene(vec3 position) {\n    SDF sphereSDF;\n    sphereSDF.position = vec3(-0.5, 0.0, 0.0);\n    sphereSDF.material.color = vec3(0.1, 0.0, 0.2);\n    sphereSDF.material.specular = 75.0;\n\n    SDF terrainSDF;\n    terrainSDF.position = vec3(0.0) + vec3(iTime, 0.0, iTime);\n    terrainSDF.material.color = vec3(0.2, 0.09, 0.045);\n    terrainSDF.material.specular = 75.0;\n    \n    SDFTest terr = terrain(position, terrainSDF, 6, 1.0, 0.125, 0.5, 2.0);\n    \n    SDFTest t = terr;\n    return t;   \n}\n\n// ========================= //\n\nvec3 cnormal(vec3 p, float e) {\n    vec2 a = vec2(e, 0.0);\n    return normalize(vec3(\n        scene(p + a.xyy).dist - scene(p - a.xyy).dist,\n        scene(p + a.yxy).dist - scene(p - a.yxy).dist,\n        scene(p + a.yyx).dist - scene(p - a.yyx).dist\n    ));\n}\n\nvec3 cnormal(vec3 position) {\n    return cnormal(position, 0.0001);\n}\n\nRaycastHit castRay(Ray ray) {\n    RaycastHit hit;\n    hit.t = 0.0;\n    hit.hit = false;\n    for (int i = 0; i < ray.maxSteps; i++) {\n        hit.position = ray.origin + ray.direction * hit.t;\n        hit.test = scene(hit.position);\n        if (hit.test.dist < ray.collisionEpsilon) {\n            hit.hit = true;\n            hit.normal = cnormal(hit.position);\n            return hit;\n        }\n        hit.t += hit.test.dist;\n        if (hit.t > ray.farPlane) break;\n    }\n    return hit;\n}\n\nfloat castShadow(Ray ray, float start, float end, float sharpness) {\n    float o = 1.0;\n    float penumbra = 1e20;\n    for(float t = start; t < end;) {\n    \n        float d = scene(ray.origin + ray.direction * t).dist;\n        \n        if(d < ray.collisionEpsilon) return 0.0;\n        \n        float y = d * d / (2.0 * penumbra);\n        float h = sqrt(d * d - y * y);\n        o = min(o, sharpness * h / max(0.0, t - y));\n        \n        penumbra = d;\n        t += d;\n        \n    }\n    return o;\n}\n\n// ========================= //\n\nvec2 clipspace(vec2 uv, vec2 resolution) {\n    return (2.0 * uv - resolution) / resolution.y;\n}\n\nvec3 perspective(vec2 clip, Camera cam) {\n    vec3 w = normalize(cam.target - cam.position);\n    vec3 u = normalize(cross(w, cam.up));\n    vec3 v = normalize(cross(u, w));\n    return vec3(normalize(clip.x * u + clip.y * v + cam.fov * w));\n}\n\n// ========================= //\n\nvec3 diffuse(DirectionalLight light, vec3 normal, float bias) {\n    float d = clamp(dot(light.direction, normal), 0.0, 1.0);\n    if (bias != 0.0) d = bias + bias * d;\n    return light.color * d;\n}\n\nvec3 fog(vec3 color, float dist, vec3 rayDir, vec3 sunDir, float strength) {\n    float fogAmount = 1.0 - exp(-dist * strength);\n    float sunAmount = max(dot(rayDir, sunDir), 0.0);\n    vec3  fogColor = mix(vec3(0.5, 0.6, 0.7), vec3(1.0, 0.9, 0.7), pow(sunAmount, 8.0));\n    return mix(color, fogColor, fogAmount);\n}\n\n// ========================= //\n\nvec3 cameraPosition = vec3(0.0, 0.0, -2.0);\nvec3 cameraTarget = vec3(0.0);\n\n#define sun DirectionalLight(normalize(vec3(-0.8, 0.4, -0.8)), vec3(2.75))\n#define sky DirectionalLight(vec3(0.0, 1.0, 0.0), vec3(0.1, 0.16, 0.18))\n#define bounce DirectionalLight(vec3(0.0, -1.0, 0.0), vec3(0.14, 0.06, 0.04))\n\n#define camera Camera(cameraPosition, cameraTarget, vec3(0.0, 1.0, 0.0), 1.5, FAR_PLANE)\n\n#define fillRay(vec2) Ray(camera.position, perspective(vec2, camera), MAX_STEPS, 0.0001, camera.farPlane)\n#define shadowRay(hit, ray) Ray(hit.position + hit.normal * 0.0001, sun.direction, ray.maxSteps, ray.collisionEpsilon, ray.farPlane)\n\n// ========================= //\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    \n    vec2 clip = clipspace(fragCoord, iResolution.xy);\n    vec2 mouse = (2.0 * iMouse.xy - 1.0) / iResolution.xy;\n    \n    cameraPosition.x = cos(-mouse.x * 2.0) * 30.0;\n    cameraPosition.y = 30.0 - (mouse.y * 15.0);\n    cameraPosition.z = sin(-mouse.x * 2.0) * 30.0;\n  \n    vec3 color;\n    \n    Ray fray = fillRay(clip);\n    RaycastHit fill = castRay(fray);\n    if (fill.hit) {\n        \n        vec3 mat = fill.test.sdf.material.color;\n        mat = mix(mat, vec3(0.1, 0.2, 0.0), pow(clamp(dot(fill.normal, vec3(0.0, 1.0, 0.0)), 0.0, 1.0), 2.0));\n        mat = mix(mat, vec3(0.05), 1.0 - pow(0.5 + 0.5 * dot(fill.normal, vec3(0.0, 1.0, 0.0)), 100.0));\n        mat = mix(mat, vec3(0.1, 0.2, 0.05), -fill.position.y * 0.5);\n        mat = mix(mat, vec3(0.05, 0.05, 0.2), smoothstep(-1.0, -1.25, fill.position.y));\n        mat = mix(mat, vec3(0.0, 0.0, 0.1), smoothstep(-0.75, -1.33, fill.position.y));\n        \n        vec3 sunColor = diffuse(sun, fill.normal, 0.0);\n        \n        vec3 sunShadow = sunColor * castShadow(shadowRay(fill, fray), 0.02, 2.5, 32.0);\n        sunShadow = pow(sunShadow, vec3(1.0, 1.2, 1.5)); // falloffs for r, g, and b\n        \n        vec3 skyColor = diffuse(sky, fill.normal, 0.5);\n        vec3 bounceColor = diffuse(bounce, fill.normal, 0.5);\n        \n        color = mat * sunColor * sunShadow;\n        color += mat * skyColor;\n        color += mat * bounceColor;\n        \n    }\n    else {\n        color = vec3(0.55, 0.85, 1.0) -abs(fray.direction.y);\n        color = mix(color, vec3(0.7, 0.75, 0.8), exp(-10.0 * abs(fray.direction.y)));\n    }\n    \n    color = fog(color, fill.t, fray.direction, sun.direction, 0.01);\n    \n    color = pow(color, vec3(0.4545)); // approximation of 1.0 / 2.2\n\n    // Output to screen\n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"vec3 mod289(vec3 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec2 mod289(vec2 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec3 permute(vec3 x) {\n  return mod289(((x * 34.0) + 10.0) * x);\n}\n\nfloat snoise(vec2 v) {\n  \n    const vec4 C = vec4(0.211324865405187,  // (3.0 - sqrt(3.0)) / 6.0\n                        0.366025403784439,  // 0.5 * (sqrt(3.0) - 1.0)\n                       -0.577350269189626,  // -1.0 + 2.0 * C.x\n                        0.024390243902439); // 1.0 / 41.0\n    vec2 i  = floor(v + dot(v, C.yy));\n    vec2 x0 = v - i + dot(i, C.xx);\n\n    vec2 i1;\n    i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n    vec4 x12 = x0.xyxy + C.xxzz;\n    x12.xy -= i1;\n\n    i = mod289(i); // Avoid truncation effects in permutation\n    vec3 p = permute(permute(i.y + vec3(0.0, i1.y, 1.0)) + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(dot(x0, x0), dot(x12.xy, x12.xy), dot(x12.zw, x12.zw)), 0.0);\n    m = m*m ;\n    m = m*m ;\n\n    // Gradients: 41 points uniformly over a line, mapped onto a diamond.\n    // The ring size 17*17 = 289 is close to a multiple of 41 (41*7 = 287)\n\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n\n    // Approximation of m *= inversesqrt( a0*a0 + h*h );\n    m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n\n    vec3 g;\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n    return 130.0 * dot(m, g);\n}","name":"Common","description":"","type":"common"}]}