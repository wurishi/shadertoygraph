{"ver":"0.1","info":{"id":"WtSfDd","date":"1600365426","viewed":66,"name":"Michael Bowen Lab 2:HelloShaders","username":"mbowen","description":"shaders","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["hello"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Author Michael Bowen\n//Link to shader: https://www.shadertoy.com/view/WtSfDd\n\n//matrix mult think the modifier is moving the main object how much in its respective axis and what is the result\n\n//Utilitiy functions\nfloat lenSq(vec2 x){\n    return dot(x,x);\n}\n\nfloat squareValue(float x){\n\treturn x*x;\n}\n\n// GLSL STARTER CODE BY DANIEL S. BUCKSTEIN\n// asPoint: promote a 3D vector into a 4D vector representing a point (w=1)\n//    point: input 3D vector\nvec4 asPoint(in vec3 point)\n{\n    return vec4(point, 1.0);\n}\n\n// asOffset: promote a 3D vector into a 4D vector representing an offset (w=0)\n//    point: input 3D vector\nvec4 asOffset(in vec3 offset)\n{\n    return vec4(offset, 0.0);\n}\n\n//Structs and their init functions\n\nstruct sSphere\n{\n\tfloat radius;\n    vec4 center;\n};\n\nvoid initSphere (out sSphere sphere, in vec3 center, in float radius) \n{\n\tsphere.center = asPoint(center);\n    sphere.radius = radius;\n\n}\n\nstruct pLight\n{\n\tvec4 center;\n    vec4 color;\n    float intensity;\n};\n\nvoid initPointLight(out pLight light, in vec3 center, in vec4 color, in float intensity)\n{\n  \tlight.center = asPoint(center);\n    light.color = color;\n    light.intensity = intensity;\n    \n}\n    \n\n//Agorithmic functions\n\n// calcViewport: calculate the viewing plane (viewport) coordinate\n//    viewport:       output viewing plane coordinate\n//    ndc:            output normalized device coordinate\n//    uv:             output screen-space coordinate\n//    aspect:         output aspect ratio of screen\n//    resolutionInv:  output reciprocal of resolution\n//    viewportHeight: input height of viewing plane\n//    fragCoord:      input coordinate of current fragment (in pixels)\n//    resolution:     input resolution of screen (in pixels)\nvoid calcViewport(out vec3 viewport, out vec2 ndc, out vec2 uv,\n                  out float aspect, out vec2 resolutionInv,\n                  in float viewportHeight, in float focalLength,\n                  in vec2 fragCoord, in vec2 resolution)\n{\n    // inverse (reciprocal) resolution = 1 / resolution\n    resolutionInv = 1.0 / resolution;\n    \n    // aspect ratio = screen width / screen height\n    aspect = resolution.x * resolutionInv.y;\n\n    // uv = screen-space coordinate = [0, 1) = coord / resolution\n    uv = fragCoord * resolutionInv;\n\n    // ndc = normalized device coordinate = [-1, +1) = uv*2 - 1\n    ndc = uv * 2.0 - 1.0;\n\n    // viewport: x = [-aspect*h/2, +aspect*h/2), y = [-h/2, +h/2), z = -f\n    viewport = vec3(ndc * vec2(aspect, 1.0) * (viewportHeight * 0.5), -focalLength);\n}\n\n// calcRay: calculate the ray direction and origin for the current pixel\n//    rayDirection: output direction of ray from origin\n//    rayOrigin:    output origin point of ray\n//    viewport:     input viewing plane coordinate (use above function to calculate)\n//    focalLength:  input distance to viewing plane\nvoid calcRay(out vec4 rayDirection, out vec4 rayOrigin,\n             in vec3 eyePosition, in vec3 viewport)\n{\n    // ray origin relative to viewer is the origin\n    // w = 1 because it represents a point; can ignore when using\n    rayOrigin = asPoint(eyePosition);\n\n    // ray direction relative to origin is based on viewing plane coordinate\n    // w = 0 because it represents a direction; can ignore when using\n    rayDirection = asOffset(viewport - eyePosition);\n}\n\n\n    \n\n// calcColor: calculate the color of a pixel given a ray\n//    rayDirection: input ray direction\n//    rayOrigin:    input ray origin\nvec4 calcColor(in vec4 rayDirection, in vec4 rayOrigin, in vec4 backroundcolor)\n{\n    // DUMMY RESULT: OUTPUT RAY DIRECTION AS-IS\n    //  -> what does the ray look like as color?\n    //return rayDirection;\n\t\n    //Scene\n    sSphere sphere;\n    initSphere(sphere, vec3(0.0, 0.0, -4.0), .5);\n   \t\n    pLight pointLight;\n    initPointLight(pointLight, vec3(cos(iTime),  cos(iTime), -3.5 + sin(iTime)), backroundcolor, 10.0); //\n    \n    \n    vec3 dp;\n    dp.xy = rayDirection.xy - sphere.center.xy; //ray from pixel toward the center of the circle\n    float lSq = lenSq(dp.xy), //the length function calulates the square length so it is more efficent just square it\n          rSq = squareValue(sphere.radius); \n\n    \n    if(lSq <= rSq){ //if the length of that ray DP^2 is smaller than the radius^2 then it draws the circle. Squared for efficency\n    \t//inside the circle XY\n        //return vec4(1.0);\n        \n        //Render sphere\n        dp.z = rSq - ((dp.x*dp.x)+(dp.y*dp.y));\n        vec3 position = sphere.center.xyz + vec3(dp.x, dp.y, sqrt(dp.z));\n        vec3 normal = (position - sphere.center.xyz) / sphere.radius;\n       \n        \n        //point lighting\n        vec4 reflectionColor = vec4(normal * 0.5 + 0.5, 1.0);\n        //vec4 reflectionColor = vec4(1.0);\n        \n        vec3 lightVector = pointLight.center.xyz - position;\n        float lightVectorLength = length(lightVector);\n        vec3 normalizedLightVector = lightVector/lightVectorLength;\n        float diffusionCoefficent = max(0.0, (dot(normal, normalizedLightVector)));\n        float attenuation = 1.0/ (1.0 + lightVectorLength/pointLight.intensity + squareValue(lightVectorLength)/squareValue(pointLight.intensity));\n        pointLight.intensity = diffusionCoefficent * attenuation;\n\n        vec4 finalColor = pointLight.intensity * reflectionColor * pointLight.color;\n        return finalColor;\n    }\n    \n\t// BACKGROUND\n    return backroundcolor;\n    //return vec4(.5);\n\tconst vec3 warm = vec3(0.8, 0.4, 0.2), cool = vec3(0.2, 0.4, 0.8);\n\treturn vec4(mix(warm, cool, rayDirection.y), 1.0);\n}\n\n\n\n\nvec4 genGradient(in vec2 uv) //Gradient\n{\n    return vec4(uv.x, 0.5, 0.0, 1.0);\n}\n\n\nvec4 genChecker(in vec2 fragCoord, in float size, in vec4 color) //Generate checkerBoard\n{\n    vec2 loc = floor(fragCoord / size);//Scales to pizels for the grid based on size\n    float sum = loc.x + loc.y;//addes the coords of the new grid\n    return mod(sum, 2.0) * vec4(1.0, 1.0, 1.0, 1.0); //if the sum of the coords is positive its black else white   \n\n}\n\n\n\nvec4 myEffect2(in vec2 fragCoord, in vec2 uv) //Circle that changes color and size\n{\n    //generates circle at the center of the screen\n    float cPosX = iResolution.x / 2.0;\n    float cPosY = iResolution.y / 2.0;\n    vec2 center = vec2(cPosX, cPosY);\n    float radius = 100.0; //starting radius in pixels\n    radius += pow(iTime, 2.0); //increases size of circle over time\n    \n    float oc = distance(center,fragCoord);//calculates the distance between a pixel and the center of the circle\n    vec3 color = vec3(cos(iTime),sin(iTime),cos(iTime + 90.0)); //color inside the circle\n    \n    //Caclulates weather the pixel is inside or outside the circle\n    if(oc > radius){ //outside the circle\n        return -vec4(color, 1.0); //inverts the backround from the inside of the circle\n    }\n    else {//inside the circle\n     \treturn vec4(color, 1.0);   \n    }\n    return vec4(1.0, 1.0, 1.0, 1.0);\n}\n\nvec4 myEffect3(in vec2 fragCoord, in vec2 uv) //combined effect of checkerboard and circle with modifications\n{\n    float speed = 100.0;\n    float cWidth = iResolution.x;\n    float cHeight = iResolution.y;\n    float cPosX = cWidth/2.0;\n    float cPosY = cHeight/2.0;\n    \n    //Cause the circle to move on a circular plath\n   \tcPosX += cos(iTime) * speed;\n    cPosY += sin(iTime) * speed;\n    \n    //circle creation\n    vec2 center = vec2(cPosX, cPosY);\n    float radius = 100.0;\n    \n    float oc = distance(center,fragCoord);//distance between center of the circle and the current pixel\n    vec3 color = vec3(cos(iTime),sin(iTime),cos(iTime + 90.0));//Causes the color to change based on cos and sin\n    float size = 10.0; //size of checkerboard\n    //Checks if the current pixel is in or outside the circle\n    if(oc > radius) { //outside the circle\n        \n        //Checkerboard code with rotation\n        //rotation\n        vec2 pointOfRotation = vec2(cWidth/2.0, cHeight/2.0);\n        fragCoord -= pointOfRotation;\n        float rotAngle = (iTime); //Rotation angle is based on time to keep it changing\n        mat2 rot = mat2( cos(rotAngle), -sin(rotAngle), sin(rotAngle), cos(rotAngle));\n        fragCoord *= (rot);\n        fragCoord += pointOfRotation;\n        \n        //Caclulationes the pixels in a grid based on size\n        vec2 loc = floor((fragCoord) / size);//moves the points onto a smaller grid\n        float sum = loc.x + loc.y;\n        \n        //To designate between checker board\n        if(mod(sum, 2.0) == 0.0){\n            color = -color;\n        }\n        return vec4(color, 1.0);\n        \n        //other tested backrounds\n        //modifier = 0.0;\n        //color = vec3(uv.x, uv.y, 0.0) + cos(iTime);\n   \t\t//return  myEffect1(fragCoord, uv);\n        //return -vec4(color, 1.0);\n    }\n    else {//inside the circle\n        \n        //Checkerboard code with rotation       \n        //rotation\n        vec2 pointOfRotation = vec2(cWidth/2.0, cHeight/2.0);\n        fragCoord -= pointOfRotation;\n        float rotAngle = -(iTime*2.0); //Rotation angle is based on time to keep it changing\n        mat2 rot = mat2( cos(rotAngle), -sin(rotAngle), sin(rotAngle), cos(rotAngle));\n        fragCoord *= (rot);\n        fragCoord += pointOfRotation;\n        \n        //Caclulationes the pixels in a grid based on size\n        vec2 loc = floor((fragCoord) / size);//moves the points onto a smaller grid\n        float sum = loc.x + loc.y;\n        \n        //To designate between checker board\n        if(mod(sum, 2.0) == 0.0){\n            color = -color;\n        }\n        return vec4(color, 1.0);\n        \n        //color = vec3(uv.y, uv.x, oc);// + cos(iTime);\n     \t//return vec4(color, 1.0);   \n    }\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    \n    const float CHECKER_SIZE = 10.0;\n    const vec4 CHECKER_COLOR = vec4(1.0);\n    //vec2 uv = fragCoord / iResolution.x;\n    \n    //fragColor = genGradient(uv);\n    //fragColor = genChecker(fragCoord, CHECKER_SIZE, CHECKER_COLOR); \n\t//fragColor = myEffect2(fragCoord, uv);\n    //fragColor = myEffect3(fragCoord, uv);\n    \n     // viewing plane (viewport) info\n    vec3 viewport;\n    vec2 ndc, uv, resolutionInv;\n    float aspect;\n    const float viewportHeight = 2.0, focalLength = 1.0;\n\n    // ray\n    vec4 rayDirection, rayOrigin;\n\n    // setup\n    fragColor = vec4(0.0);\n    \n    calcViewport(viewport, ndc, uv, aspect, resolutionInv,\n    \t             viewportHeight, focalLength,\n    \t             fragCoord, iResolution.xy);\n    calcRay(rayDirection, rayOrigin, vec3(0.0), viewport);\n    \n    fragColor += calcColor(rayDirection, rayOrigin, myEffect3(fragCoord, uv));\n   \n}","name":"Image","description":"","type":"image"}]}