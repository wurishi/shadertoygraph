{"ver":"0.1","info":{"id":"WtGSzz","date":"1582385831","viewed":181,"name":"Riemann zeta triangles packer.","username":"Logos","description":"Packing triangles in 2D space.\n\nArea of each triangle is unrepeatable and decreases via Riemann zeta function.\nAngle depends on triangle center position.","likes":9,"published":1,"flags":32,"usePreview":0,"tags":["2d","2d","triangle","zeta","riemann","packing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Created by Robert Śmietana (Logos) - 22.02.2020\n// Bielsko-Biała, Poland, UE, Earth, Sol, Milky Way, Local Group, Laniakea :)\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    \n    //-- initializations ---//\n    \n\tvec2 uv = fragCoord.xy / iResolution.y;\n\tvec3 c  = vec3(0.0);\n    \n    \n    //--- draw triangles ---//\n    \n    int triangle_count = int(data(0, 0).x);\n    for (int x = 0; x < triangle_count; x++)\n    {\n        \n        //--- get triangle ---//\n        \n        vec4 u = tri(x);\n     \n        \n\t    //--- animate it ---//\n    \n\t    float time\t\t= 0.1*iTime + 0.1*uv.x;\n\t    float t\t\t\t= fract(time);\n    \n\t    if (t > 0.8)\n    \t{\n\t\t\tu.w = mix(u.w, u.w+EA, 5.0*(t - 0.8));\n\t    }\n            \n        \n        //--- construct triangle ---//\n        \n\t\tvec2 bp1 = vec2(u.x + u.z*cos(u.w),\t\t\t\tu.y + u.z*sin(u.w));\n        vec2 bp2 = vec2(u.x + u.z*cos(u.w + EA),\t\tu.y + u.z*sin(u.w + EA));;\n\t\tvec2 bp3 = vec2(u.x + u.z*cos(u.w + 2.0*EA),\tu.y + u.z*sin(u.w + 2.0*EA));;\n        \n            \n        //--- paint triangle ---//\n            \n        if (isInsideTriangle(uv, bp1, bp2, bp3))\n        {\n\t\t    float oot = 1.0 / float(triangle_count);\n            \n            c = 0.5 + 0.5*cos(0.26*iTime+uv.xyx+vec3(30,12,14));\n            c.y = 0.6*c.y - 0.4*float(x) * oot;\n        }\n    }    \n\n    \n    //--- yield output color ---//\n    \n\tfragColor = vec4(c, 1.0); \n    \n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define EA\t\t\t(0.6666666 * 3.1415926535)\n\n#define data(x, y)\ttexelFetch(iChannel0, ivec2(x, y), 0)\n#define tri(i)\t\ttexelFetch(iChannel0, ivec2(i % 40, 1 + i / 40), 0)\n\n\n//--- auxiliary functions ---//\n\nfloat hash12(vec2 p)\n{\n\tfloat h = dot(p , vec2(127.1,311.7));\t\n    return fract(abs(sin(h)*43758.5453123));\n}\n\n\nbool isInsideBB(vec2 p, vec2 bbA, vec2 bbB)\n{\n  return\n    p.x >= min(bbA.x, bbB.x) &&\n    p.x <= max(bbA.x, bbB.x) &&\n    p.y >= min(bbA.y, bbB.y) &&\n    p.y <= max(bbA.y, bbB.y); \n}\n\n\nfloat cross2d(vec2 a, vec2 b)\n{\n\treturn a.x * b.y - a.y * b.x;\n}\n\n\nbool ifSegmentSegment(vec2 l1a, vec2 l1b, vec2 l2a, vec2 l2b)\n{\n  float d = cross2d(l1a - l1b, l2a - l2b);\n  if (0.0 == d) return false;\n   \n  float l1c = cross2d(l1a, l1b);\n  float l2c = cross2d(l2a, l2b);\n   \n  vec2 intersectionPoint = vec2(\n      \t(l1c*(l2a.x-l2b.x) - l2c*(l1a.x-l1b.x)) / d,\n        (l1c*(l2a.y-l2b.y) - l2c*(l1a.y-l1b.y)) / d);\n  \n  return isInsideBB(intersectionPoint, l1a, l1b)\n      && isInsideBB(intersectionPoint, l2a, l2b);   \n}\n\n\n// returns if point p is inside triangle ABC\nbool isInsideTriangle(vec2 p, vec2 A, vec2 B, vec2 C)\n{\n    vec3 s = vec3\n    (\n\t\tcross2d(B - A, p - A),\n\t\tcross2d(C - B, p - B),\n\t\tcross2d(A - C, p - C)\n    );\n\n    return all(greaterThan(s, vec3(0.0))) || all(lessThan(s, vec3(0.0)));\n}\n\n\nbool ifTriangleTriangle(vec2 ap1, vec2 ap2, vec2 ap3, vec2 bp1, vec2 bp2, vec2 bp3)\n{\n  if (isInsideTriangle(ap1, bp1, bp2, bp3)) return true;    \n  if (isInsideTriangle(ap2, bp1, bp2, bp3)) return true;    \n  if (isInsideTriangle(ap3, bp1, bp2, bp3)) return true;\n  if (isInsideTriangle(bp1, ap1, ap2, ap3)) return true;\n  if (isInsideTriangle(bp2, ap1, ap2, ap3)) return true;\n  if (isInsideTriangle(bp3, ap1, ap2, ap3)) return true;\n  \n  if (ifSegmentSegment(ap1, ap2, bp1, bp2)) return true;\n  if (ifSegmentSegment(ap2, ap3, bp1, bp2)) return true;\n  if (ifSegmentSegment(ap3, ap1, bp1, bp2)) return true;\n  if (ifSegmentSegment(ap1, ap2, bp2, bp3)) return true;\n  if (ifSegmentSegment(ap2, ap3, bp2, bp3)) return true;\n  if (ifSegmentSegment(ap3, ap1, bp2, bp3)) return true;\n  if (ifSegmentSegment(ap1, ap2, bp3, bp1)) return true;\n  if (ifSegmentSegment(ap2, ap3, bp3, bp1)) return true;\n  if (ifSegmentSegment(ap3, ap1, bp3, bp1)) return true;\n\n  return false;\n}\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Calculation buffer.\n// Stores triangles.\n// Adds triangles with areas fit via Riemann zeta function (to cover all space).\n// Triangles do not collide.\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    \n    //--- data memory dimensions ---//\n    \n    int x = int(fragCoord.x);\n    if (x >= 40) return;\n\n    int y = int(fragCoord.y);\n\tif (y >= 41) return;\n    \n    \n    //--- initialization ---//\n    \n\tfloat initial_area = iResolution.x/iResolution.y * 0.12415775;\n\n    if (iFrame == 0)\n    {\n\t\tfragColor = vec4(0.0, initial_area, 0.0, 0.0);\n        \n        return;\n    }\n    \n    \n    //--- generation of consecutive triangles ---//\n    \n    fragColor = data(x, y);\n        \n  \tint\t  visible_count = int(data(0, 0).x);\n    float object_area = initial_area * pow(1.0 + float(visible_count), -1.0201);\n\n    float tr = 0.66666666 * sqrt(sqrt(3.0)*object_area);\n    float tx = tr + (1.0 - 1.0*tr)*hash12(fragCoord*1.11 + iTime)*iResolution.x/iResolution.y;\n    float ty = tr + (1.0 - 2.0*tr)*hash12(fragCoord*2.39 - 0.3*iTime);\n    float ta = atan(ty, tx*iResolution.y/iResolution.x); \n    \n    \n    //-- construct new triangle (as 3 points) ---//\n    \n    vec2 ap1 = vec2(tx + tr*cos(ta),\t\t\tty + tr*sin(ta));\n    vec2 ap2 = vec2(tx + tr*cos(ta + EA),\t\tty + tr*sin(ta + EA));\n\tvec2 ap3 = vec2(tx + tr*cos(ta + 2.0*EA),\tty + tr*sin(ta + 2.0*EA));\n\n    \n    //--- check if new triangle collides with other triangles ---//\n    \n    bool collide = false;\n    \n\tfor (int i = 0; i < visible_count; i++)\n    {\n        vec4 u = tri(i);\n            \n\t\tvec2 bp1 = vec2(u.x + u.z*cos(u.w),\t\t\t u.y + u.z*sin(u.w));\n        vec2 bp2 = vec2(u.x + u.z*cos(u.w + EA),\t u.y + u.z*sin(u.w + EA));;\n\t\tvec2 bp3 = vec2(u.x + u.z*cos(u.w + 2.0*EA), u.y + u.z*sin(u.w + 2.0*EA));;\n\n        if (ifTriangleTriangle(ap1, ap2, ap3, bp1, bp2, bp3))\n        {\n           collide = true;\n           break;\n        }\n    }\n\n    \n    //--- save the triangle if there was no collision ---//\n    \n    if (!collide)\n    {\n        if (x == 0 && y == 0)\t// increment visible_count\n        {\n            if (visible_count < 1600)\n            {\n                fragColor = vec4(float(visible_count+1), 0.0, 0.0, 0.0);\n            }\n        }\n            \n        \n        else if (y > 0)\t// save triangle\n        {\n            if (x == (visible_count % 40) && y == (1 + visible_count / 40))\n            {\n            \tfragColor = vec4(tx, ty, tr, ta);\n            }\n        }\n    }\n    \n}\n","name":"Buffer A","description":"","type":"buffer"}]}