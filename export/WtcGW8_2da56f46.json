{"ver":"0.1","info":{"id":"WtcGW8","date":"1576090215","viewed":191,"name":"WIP cig","username":"okelly4408","description":"a cigarette","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_DIST 20.\n#define MIN_DIST .001\n#define MAX_ITER 100\n\n\n\n#define PI  3.141592\n#define TAU 6.283184\n\n\n\nvec2 sp(float t){\n    return vec2(floor(t), fract(t));\n}\n\nfloat rand(vec2 co){\n  return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat dots(vec2 p)\n{\n    vec4 dots = vec4(0.0);\n    for(float i = 0. ; i < 6. ; i++) {\n\t    vec2 t = sp(.15 - i*.1);\n\t    vec4 c = vec4(\n\t        rand(p)*2.0-1.0,\n\t        rand(p)*2.0-1.0,\n\t        rand(p)*0.5+0.5,\n            rand(p)*2.0-1.0\n\t    ); \n    }\n    \n    \n    dots.g =1.0-20.*rand(floor(p*150.0));\n    dots = max(dots, vec4(dots.g));\n    return dots.b;\n}\n\n\n\n\n\n\nconst vec3 BOX = vec3(0.5);\nconst float eps = 0.0001;\nmat3 m = mat3( 0.00,  0.80,  0.60,\n              -0.80,  0.36, -0.48,\n              -0.60, -0.48,  0.64 );\n\nfloat hash( float n )\n{\n    return fract(sin(n)*43758.5453);\n}\n\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\n    f = f*f*(3.0-2.0*f);\n\n    float n = p.x + p.y*57.0 + 113.0*p.z;\n\n    float res = mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                        mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\n                    mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                        mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\n    return res;\n}\n\n/*float fbm( vec3 p )\n{\n    float f;\n    f  = 0.5000*(1.0 - abs(noise( p ))); p = m*p*2.02;\n    f += 0.2500*(1.0 - abs(noise( p ))); p = m*p*2.03;\n    f += 0.1250*(1.0 - abs(noise( p ))); p = m*p*2.01;\n    f += 0.0625*(1.0 - abs(noise( p )));\n    return f;\n}*/\nfloat fbm(vec3 v)\n{\n    float frequency = 1.0;\n    float gain = 1.0;\n    float damp = 0.5;\n    float lacunarity = 1.81;\n\tfloat sum = 0.0;\n    for (int i = 0; i < 8; i++)\n    {\n        sum += (1.0 - pow(abs(noise(v * frequency)), 2.0) )* (gain);\n        frequency *= lacunarity;\n        gain *= damp;\n        v *= m;\n    }\n    return sum * 0.75;\n}\n  \nfloat sdSphere(vec3 p, vec3 c, float r, out float turb) {\n    turb = fbm(p * 2.0);\n    return (length(p - c) - r) - (0.5 * turb);\n}\nfloat sdCylinder( vec3 p, vec2 h )\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n    return (min(max(d.x,d.y),0.0) + length(max(d,0.0)));\n}\n\nvec3 map(in vec3 p){\n    float cylinderD = sdCylinder(p - vec3(0.0, -2.0, 4.0), vec2(1.0, 6.0));\n    //float coneD = sdCone(p - vec3(0.0, 6.0, 4.0), 2.0, 1.0, 0.25);\n    float turb;\n    float sphereD = sdSphere(p, vec3(0.0, 4.0, 4.0), 0.4, turb);\n    float closest = min(cylinderD, sphereD);\n    float type = 0.0;\n    if (closest == sphereD)\n        type = 1.0;\n    return vec3(closest, type, turb);\n}\nvec3 calcNormal( in vec3 pos )\n{\n    const float eps = 0.002;             // precision of the normal computation\n\n    const vec3 v1 = vec3( 1.0,-1.0,-1.0);\n    const vec3 v2 = vec3(-1.0,-1.0, 1.0);\n    const vec3 v3 = vec3(-1.0, 1.0,-1.0);\n    const vec3 v4 = vec3( 1.0, 1.0, 1.0);\n\n\treturn normalize( v1*map( pos + v1*eps ).x + \n\t\t\t\t\t  v2*map( pos + v2*eps ).x + \n\t\t\t\t\t  v3*map( pos + v3*eps ).x + \n\t\t\t\t\t  v4*map( pos + v4*eps ).x );\n}\nvec3 castRay(vec3 ro, vec3 rd){\n    float t = 0.0; // marching distance on ray\n    float typeHit = -1.0;\n    vec3 h;\n    for(int i=0; i<MAX_ITER; i++){\n        vec3 p = ro + t*rd; // marching point\n        h = map(p);\t// hit distance\n        if(h.x<MIN_DIST) {\n            typeHit = h.y;\n            break;\n        }\n        t+=h.x;\n        if(t>MAX_DIST) break;\n    }\n    if(t>MAX_DIST) t = -1.0;\n    return vec3(t, typeHit, h.z);\n}\nvec3 camera(in vec2 uv, in vec3 ro, vec3 ta, float fd){\n    vec3 up = vec3(0,1,0); // global up vector\n    vec3 ww = normalize(ta-ro); // direction to the target\n    vec3 uu = normalize(cross(ww, up)); // camera right direction\n    vec3 vv = normalize(cross(uu, ww)); // camera up direction\n    \n    vec3 rd = normalize(uv.x*uu + uv.y*vv + fd*ww); // camera direction to uv\n    return rd;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= vec2(0.5);\n    uv.x *= iResolution.x/iResolution.y;\n\n    float a = 10.0 * iMouse.x/iResolution.x;\n    float taDist = 2.0; // target distance\n    //vec3 ro = vec3( 8.0 * sin(a ), 7.0, 8.0* cos(a)); // camera origin\n    vec3 ro = vec3(-2.0, -1.0, -13.0);\n    vec3 ta = vec3(0,0,0); // target\n    \n    vec3 rd = camera(uv, ro, ta, 1.0);\n    vec3 marchResult = castRay(ro, rd);\n    vec3 col = vec3(0.0);\n    if (marchResult.x > 0.0) {\n        vec3 pos = ro + marchResult.x*rd;\n        vec3 normal = calcNormal(pos);\n        vec3 color = vec3(1.0);\n        if (marchResult.y == 0.0)\n        {\n            \tif (pos.y < -3.5)\n                {\n                    vec3 orange = vec3(255.0, 165.0, 0.0) / 255.0;\n            \t\tfloat dots = smoothstep(0.0, 0.01, dots(pos.xy * 0.1)) +\n                \t\t\tsmoothstep(0.0, 0.01, dots((pos.xy * 0.07)));\n            \t\tcolor = mix(orange, vec3(orange + vec3(0.3)), dots);\n                } else if (pos.y > 3.5) {\n                    float brownBlend = smoothstep(3.5, 4.0, pos.y);\n                    vec3 brown = vec3(165.0, 128.0, 89.0) / 255.0;\n                    color = mix( vec3(brown), vec3(1.0), 1.0 - brownBlend);\n                }\n        } else {\n            \n        \tcolor = mix(vec3(0.8, 0.3, 0.0) * 1.5, vec3(0.85), smoothstep(0.6, 0.7, marchResult.z * 0.6));\n          // color = mix(vec3(0.75), vec3(0.0), smoothstep(4.1, 4.15, pos.y) );\n          // color = mix(color, vec3(0.6, 0.0, 0.0), smoothstep(4.4, 4.4, pos.y) );\n           // color = vec3(marchResult.z * 0.7);\n            \n        }\n        col = (dot( normal, normalize(vec3(1.0, 0.0, -1.0)))) * color;\n    }\n    // Time varying pixel color\n\n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}