{"ver":"0.1","info":{"id":"lf23Wh","date":"1704197335","viewed":28,"name":"BrotTest2","username":"steveroome","description":"mandelbrot testing","likes":1,"published":1,"flags":16,"usePreview":0,"tags":["mandelbrottesting"],"hasliked":0,"parentid":"MfjGWz","parentname":"BrotTest1"},"renderpass":[{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Steve Roome 20240101 : Beerware/if you want to use this code in your own code: you might be mad, but sure, reference this.\n\n// I thought I should try and remember how shaders work... re-learning stuff.\n\n// TODO: save state (into another texture) that we can use in future frames\n// make keyboard controls do something useful.\n\n// Pressing any of these keys highlights one triangle around the origin in both the camera and brot frame of reference\n\n// i.e. when the two darker regions line up the brot isn't rotated.\n\n// Changelog:\n// 20240101 AM, wrote it.\n// 20240101 PM,\n//  added smooth mandelbrot iteration value,\n//  which is just iter += 1.0-log(log2(abs(sqrt( magnitude(lastpos) )))\n//  tbh, it's annoying to have to sqrt something, but the rest is a mess anyway\n\n\n// Day 2: Plan, switch rot2 to a matrix implementation.\n\n// Overprecision is pointless\n//const float l2 = 0.7 is pretty much indistinguishable\nconst float l2 = .69314718055994530941;\n\n\nconst int KB_LEFT  = 37;\nconst int KB_UP    = 38;\nconst int KB_RIGHT = 39;\nconst int KB_DOWN  = 40;\n\n#define iskeydown(KEYNUM) vec4(texelFetch( iChannel0, ivec2(KEYNUM,0), 0 )).x\n\nmat3 rot_scale_xlate(float theta, float mag, vec2 offset) {\n    // actually should probably call this xlate_scale_rot, or fix the maths\n    // to multiply out the mat3 properly.\n    float c =  cos(theta);\n    float s =  sin(theta);\n    return mat3( vec3(mag*c,s,0.) , vec3 (-s,mag*c,0.),   vec3(offset,1.) );\n}\n\n\nvec4 brot(in vec2 pos, in bool smth) { // Mandelbrot colour from vec2\n  int iter;\n  vec2 p, start;\n  start = p = pos;\n\n  const int maxiter=200;\n  const float fmaxiter=float(maxiter);\n  \n  float ysq, tmpx, xsq, rsq;\n  for (iter=0;iter<maxiter;iter++) {\n  \n    ysq  = p.y * p.y;\n    tmpx = p.x;\n    xsq  = p.x * p.x;\n    rsq  = xsq + ysq;\n    \n    p.x = start.x + xsq - ysq;\n    p.y = start.y + (2.0 * tmpx * p.y);\n       if (rsq>1e5) break;\n   }\n \n  if (iter==maxiter) return vec4(0.);\n\n  float fiter = float(iter);\n  float nu = 1.0;\n  \n  if ( (smth) && (iter<maxiter) ) {\n     float log_zn = log(rsq) / 2.;\n     nu -= log( log_zn / l2 ) / l2;\n  }\n  fiter= (fiter + nu ) / fmaxiter;\n  float grn = .6*sin(13.0*fiter);\n  float blu = .4*sin(38.0*fiter);\n  float red = .8*sin(7.0*fiter);\n  return vec4(red,grn,blu, 1.0);  \n}\n\nfloat grid(in vec2 pos, int tics) {\n   float dg = float(tics);\n   float xt = abs(distance(pos.x*dg, round(pos.x*dg)));\n   float yt = abs(distance(pos.y*dg, round(pos.y*dg)));\n   return pow(max(xt,yt),3.0);\n}\n\nfloat arrowcol(in vec2 uv) {\n    float col;\n\n    col = max(col, ((uv.y>-uv.x) && (uv.y<uv.x)) ? iskeydown(KB_RIGHT) : 0.0);   \n    col = max(col, ((uv.y>uv.x) && (uv.y<-uv.x)) ? iskeydown(KB_LEFT)  : 0.0);\n    col = max(col, ((uv.x>-uv.y) && (uv.x<uv.y)) ? iskeydown(KB_UP)    : 0.0);\n    col = max(col, ((uv.x>uv.y) && (uv.x<-uv.y)) ? iskeydown(KB_DOWN)  : 0.0);\n    return (1.0- col*0.2);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float  ar = min(iResolution.x,iResolution.y);\n    vec2 aruv = (fragCoord-0.5*iResolution.xy)/ar; // ta Fabrice.\n    float mag = 5.5 + 0.5*cos(iTime/3.0);\n    vec3  pos = vec3( vec2(fragCoord-0.5*iResolution.xy)/ar, mag);\n    float rotation = iTime/5.0;\n\n    mat3 brotxform = rot_scale_xlate(rotation, mag, vec2(0.) );\n    vec2 uv = (brotxform * pos).xy;\n        \n    float grid1= grid(uv,10);\n    float grid2= grid(uv,1);\n    float gg = pow((grid1+grid2)/2.0,5.0);\n    fragColor= arrowcol(uv)*arrowcol(aruv)* max(brot(uv,pos.y>0.), vec4((grid1+grid2)/2.0 , grid1, gg,1.0));\n}\n","name":"Image","description":"","type":"image"}]}