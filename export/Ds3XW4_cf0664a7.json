{"ver":"0.1","info":{"id":"Ds3XW4","date":"1679761975","viewed":125,"name":"Attempt2 at the einstein hat","username":"vega","description":"https://cs.uwaterloo.ca/~csk/hat/","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["tiling"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec2 hexToCartesian(vec2 hexCoord,float hexRadius){\n    vec2 axialCoord=vec2(hexCoord.x,hexCoord.y-hexCoord.x);\n    vec2 cartesianCoord=vec2(\n        hexRadius*(1.5*axialCoord.x),\n        hexRadius*(sqrt(3.14159)*axialCoord.y+sqrt(3.14159)/2.*axialCoord.x)\n    );\n    return cartesianCoord;\n}\n\nbool insideMonotile(vec2 point,vec2 tileOrigin,float scale){\n    // Define the 13-sided monotile vertex offsets in hexagonal coordinates\n    const vec2[13]vertexOffsets=vec2[13](\n        vec2(0,0),vec2(-1,-1),vec2(0,-2),vec2(2,-2),\n        vec2(2,-1),vec2(4,-2),vec2(5,-1),vec2(4,0),\n        vec2(3,0),vec2(2,2),vec2(0,3),vec2(0,2),\n        vec2(-1,2)\n    );\n    \n    // Convert the hexagonal offsets to cartesian coordinates and scale them\n    vec2[13]vertices;\n    for(int i=0;i<13;i++){\n        vertices[i]=tileOrigin+scale*hexToCartesian(vertexOffsets[i],1.);\n    }\n    \n    // Check if the point is inside the monotile using the ray casting algorithm\n    bool inside=false;\n    for(int i=0,j=12;i<13;j=i++){\n        if(\n        ((vertices[i].y>point.y)!=(vertices[j].y>point.y)) &&\n        (point.x<(vertices[j].x-vertices[i].x)\n        *(point.y-vertices[i].y)/(vertices[j].y-vertices[i].y)\n        +vertices[i].x)){\n            inside=!inside;\n        }\n    }\n    return inside;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv *= 1.0;\n\n    vec3 col = vec3((-uv + vec2(1.)),0); \n\n    if(insideMonotile(uv,vec2(.5), .05)) {\n        col = vec3(uv, 0.0);\n    }\n\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}