{"ver":"0.1","info":{"id":"3dSXzt","date":"1577700987","viewed":356,"name":"Black and White.","username":"Logos","description":"Newton fractal of complex sinus.","likes":14,"published":1,"flags":0,"usePreview":0,"tags":["fractal","complex","newton","binarydecomposition"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Created by Robert Śmietana (Logos) - 30.12.2019\n// Bielsko-Biała, Poland, UE, Earth, Sol, Milky Way, Local Group, Laniakea :)\n\n\n//--- auxiliary functions ---//\n\nvec2 cmul(vec2 z1, vec2 z2) { return vec2(z1.x * z2.x - z1.y * z2.y, z1.x * z2.y + z1.y * z2.x ); }\nvec2 cdiv(vec2 z1, vec2 z2) { vec2 conj = vec2(z2.x, -z2.y); return cmul(z1, conj) / (length(z2) * length(z2)); }\n\nvec2 ccos(vec2 z)\t\t\t{ return vec2(cos(z.x) * cosh(z.y), -sin(z.x) * sinh(z.y)); }\nvec2 csin(vec2 z)\t\t\t{ return vec2(sin(z.x) * cosh(z.y),  cos(z.x) * sinh(z.y)); }\n\nvec2 newton(vec2 z)\t\t\t{ return z - (1.35 - 0.35 * sin(0.3*iTime))*cdiv(csin(z), ccos(z)); }\nvec2 rot(vec2 z, float a)\t{ return vec2(z.x*cos(a) - z.y*sin(a), z.y*cos(a) + z.x*sin(a)); }\n\n\n//--- calculate pixel color ---//\n\nvec3 calculateColor(vec2 z)\n{\n    \n    //--- invert complex plane ---//\n    \n    z = vec2(z.x, z.y) / dot(z, z);\n\n    \n    //--- iterate newton formula until small const (0.14) ---//\n    \n    int i = 0;\n    for (i = 0; i < 80; i++)\n    {\n        vec2 n = newton(z);\n        if (length(z - n) < 0.14) break;\n        \n        z = rot(n, 0.401*sin(0.512*iTime));\n    }\n    \n    \n    //--- return color by binary decomposition ---//\n    \n    return\tz.x < 0.0? vec3(0.0) :\n\t    \tz.y < 0.0? vec3(1.0 - 0.5*log(float(i)/80.0), 0.95, 0.9 - 0.39*float(i)/80.0) : vec3(1.0);\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    \n    //--- calculate point coordinates ---//\n    \n\tfloat ZOOM = 1.8;\n    vec2 z = ZOOM * (fragCoord - 0.5*iResolution.xy) / iResolution.y;\n    \n    \n    //--- calculate final pixel color ---//\n    \n    float a = 2.0;\n    float e = 0.5/min(iResolution.x, iResolution.y);    \n    vec3 col = vec3(0.0);\n    \n    for (float j = -a; j < a; j++)\n        for (float i = -a; i < a; i++)\n            col += calculateColor(z + ZOOM*vec2(i, j) * (e/a)) / (4.0*a*a);\n        \n\tfragColor = vec4(col, 1.0);  \n    \n}\n","name":"Image","description":"","type":"image"}]}