{"ver":"0.1","info":{"id":"4ddXDn","date":"1459086466","viewed":121,"name":"Dispara a la diana","username":"dml92","description":"Practica Shadertoy - Diego Moreno & RubÃ©n CarreÃ±o.\n\nUse mouse to aim an shoot the targets.","likes":0,"published":1,"flags":32,"usePreview":0,"tags":["shooter"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define CHAR_SIZE vec2(3, 7)\n#define CHAR_SPACING vec2(4, 8)\n\n#define STRWIDTH(c) (c * CHAR_SPACING.x)\n#define STRHEIGHT(c) (c * CHAR_SPACING.y)\n\n// Flyguy. Bit Packed Sprites. https://www.shadertoy.com/view/XtsGRl\n\n// iq. Sphere â€“ visibility. https://www.shadertoy.com/view/XdS3Rt\n\n// iq. Rasterizer â€“ cube. https://www.shadertoy.com/view/XdlGzn\n\n// iq. Bricks Game. https://www.shadertoy.com/view/MddGzf\n\n\n\n// storage register/texel addresses\nconst vec2 txPosDiana    = vec2(0.0,0.0);\nconst vec2 txTiempoDiana = vec2(1.0,0.0);\nconst vec2 txDianaActiva = vec2(2.0,0.0);\nconst vec2 txColorDiana  = vec2(3.0,0.0);\nconst vec2 txVidas       = vec2(4.0,0.0);\nconst vec2 txGameOver    = vec2(5.0,0.0);\nconst vec2 txClickRaton  = vec2(6.0,0.0);\nconst vec2 txPuntaje\t = vec2(7.0,0.0);\n\n\n// Letras\nfloat ch_sp = 0.0;\nfloat ch_a = 712557.0;\nfloat ch_b = 1760622.0;\nfloat ch_c = 706858.0;\nfloat ch_d = 1760110.0;\nfloat ch_e = 2018607.0;\nfloat ch_f = 2018596.0;\nfloat ch_g = 706922.0;\nfloat ch_h = 1498989.0;\nfloat ch_i = 1909911.0;\nfloat ch_j = 1872746.0;\nfloat ch_k = 1498477.0;\nfloat ch_l = 1198375.0;\nfloat ch_m = 1571693.0;\nfloat ch_n = 1760109.0;\nfloat ch_o = 711530.0;\nfloat ch_p = 711972.0;\nfloat ch_q = 711675.0;\nfloat ch_r = 1760621.0;\nfloat ch_s = 2018927.0;\nfloat ch_t = 1909906.0;\nfloat ch_u = 1497963.0;\nfloat ch_v = 1497938.0;\nfloat ch_w = 1498109.0;\nfloat ch_x = 1496429.0;\nfloat ch_y = 1496210.0;\nfloat ch_z = 2004271.0;\nfloat ch_1 = 730263.0;\nfloat ch_2 = 693543.0;\nfloat ch_3 = 693354.0;\nfloat ch_4 = 1496649.0;\nfloat ch_5 = 1985614.0;\nfloat ch_6 = 707946.0;\nfloat ch_7 = 1873042.0;\nfloat ch_8 = 709994.0;\nfloat ch_9 = 710250.0;\nfloat ch_0 = 711530.0;\nfloat ch_col = 65552.0;\n\nvec2 print_pos;\n\n\n// Diana\nvec4  posDiana;\t\t// x,y,z,radio\nvec3  colorDiana;\nfloat tiempoDiana;\nfloat dianaActiva;\n\n// Vidas\nconst int nVidas = 3;\nfloat vidas;\nconst float radioVida = 10.;\n\n// Otros\nfloat gameOver;\nfloat puntos;\nfloat nuevoRecord;\n\n// Puntero\nconst float radioObj = 5.;\nvec4 clickRaton;\n\n// Colores\nconst vec3 white = vec3(1.0);\nconst vec3 red = vec3(1.0, 0.0, 0.0);\nconst vec3 green = vec3(0.0,1.0,0.0);\n\nfloat pintarObjetivo(vec2 r) {\n    return 1.0 - smoothstep( radioObj-0.5, radioObj+0.5, length(r-clickRaton.zw));\n}\n\n// Dibujo de la esfera\n\nfloat iSphere( in vec3 ro, in vec3 rd, in vec4 sph ){\n\tvec3 oc = ro - sph.xyz;\n\tfloat b = dot( oc, rd );\n\tfloat c = dot( oc, oc ) - sph.w*sph.w;\n\tfloat h = b*b - c;\n\tif( h<0.0 ) return -1.0;\n\treturn -b - sqrt( h );\n}\n\nvec3 pintarEsfera(vec2 fragCoord, vec3 col) {\n\tvec2 p = (-iResolution.xy + 2.0*fragCoord.xy) / iResolution.y;\n\n\tvec3 ro = vec3( 3.5*cos(0.0), 0.0, 3.5*sin(0.0) );\n    vec3 ta = vec3( 0.0, 0.0, 0.0 );\n\tvec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n\tvec3 rd = normalize( p.x*uu + p.y*vv + 1.5*ww );\n    \n    vec4 sph1 = vec4(-posDiana.z*2.-1., -1.6, -posDiana.x, posDiana.w);\n    \n    float tmin = 10000.0;\n\tvec3  nor = vec3(0.0);\n\tfloat occ = 1.0;\n\tvec3  pos = vec3(0.0);\n    \n    float h = iSphere( ro, rd, sph1 );\n\tif( h>0.0) { \n        occ *= smoothstep(0.,1.,sin(posDiana.y - pos.y));\n        col *= clamp(occ,0.3,0.6);\n\t}\n\n    sph1 = vec4(-posDiana.z*2., posDiana.y, -posDiana.x, posDiana.w);\n    occ = 1.0;\n    \t\n\th = iSphere( ro, rd, sph1 );\n\tif( h>0.0 && h<tmin ) { \n\t\ttmin = h; \n\t\tpos = ro + h*rd;\n\t\tnor = normalize(pos-sph1.xyz); \n\t\tocc *= smoothstep(-0.6,-0.2,sin(35.0*(pos.x-sph1.x)));\n\t}\n    \n    if( tmin<100.0 ) {\n        col = colorDiana;\n        \n\t\tcol *= occ;\n\t\tcol *= 0.7 + 0.3*nor.y;\n\t\tcol *= exp(-0.5*max(0.0,tmin-2.0));\n        col = pow( col, vec3(0.45) );\n\t}\n    \n    return col;\n}\n\n// Dibujo de las letras\n\nfloat extract_bit(float n, float b) {\n\treturn floor(mod(floor(n / pow(2.0,floor(b))),2.0));   \n}\n\nfloat sprite(float spr, vec2 size, vec2 uv) {\n    uv = floor(uv);\n    float bit = (size.x-uv.x-1.0) + uv.y * size.x;\n    \n    bool bounds = all(greaterThanEqual(uv,vec2(0)));\n    bounds = bounds && all(lessThan(uv,size));\n    \n    return bounds ? extract_bit(spr, bit) : 0.0;\n    \n}\n\nfloat char(float ch, vec2 uv) {\n    float px = sprite(ch, CHAR_SIZE, uv - print_pos);\n    print_pos.x += CHAR_SPACING.x;\n    return px;\n}\n\nfloat get_digit(float d) {\n    d = floor(d);\n    \n    if(d == 0.0) return ch_0;\n    if(d == 1.0) return ch_1;\n    if(d == 2.0) return ch_2;\n    if(d == 3.0) return ch_3;\n    if(d == 4.0) return ch_4;\n    if(d == 5.0) return ch_5;\n    if(d == 6.0) return ch_6;\n    if(d == 7.0) return ch_7;\n    if(d == 8.0) return ch_8;\n    if(d == 9.0) return ch_9;\n    return 0.0;\n}\n\nfloat print_number(float number,vec2 pos, vec2 uv) {\n\tvec2 dec_pos = pos;\n    float result = 0.0;\n    \n\tfor(int i = 3;i >= 0;i--) {\n        float clip = float(abs(number) >= pow(10.0, float(i)) || i == 0); //Clip off leading zeros.\n        \n        float digit = mod(number / pow(10.0, float(i)),10.0);\n        \n        result += sprite(get_digit(digit),CHAR_SIZE, uv - dec_pos) * clip;\n        \n        dec_pos.x += CHAR_SPACING.x * clip;\n    }\n    \n    return result;\n}\n\n// Dibujo de las vidas\n\nfloat corazon(float theta) {\n    return 2. - 2.*sin(theta) + sqrt(abs(cos(theta)))*sin(theta)/(1.4 + sin(theta));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    //---------------------------------------------------------------------------------   \n\t// Cargar estado del juego\n\t//---------------------------------------------------------------------------------\n    posDiana    = texture( iChannel0, (txPosDiana+0.5)/iChannelResolution[0].xy );\n    tiempoDiana = texture( iChannel0, (txTiempoDiana+0.5)/iChannelResolution[0].xy ).x;\n    dianaActiva = texture( iChannel0, (txDianaActiva+0.5)/iChannelResolution[0].xy ).x;\n    colorDiana  = texture( iChannel0, (txColorDiana+0.5)/iChannelResolution[0].xy ).xyz;\n    vidas       = texture( iChannel0, (txVidas+0.5)/iChannelResolution[0].xy ).x;\n    gameOver    = texture( iChannel0, (txGameOver+0.5)/iChannelResolution[0].xy).x;\n    clickRaton  = texture( iChannel0, (txClickRaton+0.5)/iChannelResolution[0].xy );\n    puntos \t\t= texture( iChannel0, (txPuntaje+0.5)/iChannelResolution[0].xy ).x;\n    nuevoRecord = texture( iChannel0, (txPuntaje+0.5)/iChannelResolution[0].xy ).z;\n    \n    vec3 color = texture ( iChannel1, (fragCoord)/iChannelResolution[1].xy ).xyz;\n    \n    puntos = floor (puntos);\n\n    vec2 px = -1.0 + 2.0*fragCoord.xy / iResolution.xy;\n    px.x *= iResolution.x/iResolution.y;\n\n    if (dianaActiva > 0.0) {\n        color = pintarEsfera(fragCoord,color);\n    }\n    \n    // Manejo del ratÃ³n\n    bool mouseDown = clickRaton.x > 0.;\n    if (mouseDown) {    \n    \t// Pintamos el objetivo\n        float distToClick =  distance (clickRaton.zw, fragCoord.xy);\n        if (distToClick > radioObj - 1. && distToClick < radioObj + 1.) {\n            color = (clickRaton.y > 0.) ? green : red;\n        }\n    }\n    \n    // Pintamos las vidas restantes\n    vec2 center;\n    if(floor(vidas) > 1. || mod(iTime, 1.) < 0.75) {\n        for(int i=0; i<nVidas; i++) {\n            if(float(i)+0.5 < vidas) {\n                vec2 point = fragCoord.xy / iResolution.y - \n                    vec2(iResolution.x/iResolution.y * (1. - ((0.05) * float (i+1))), 0.98);\n\n                if (length(point) < corazon(atan(point.y,point.x))/55.) {\n                    color = red;\n                }\n            }\n        }\n    }\n    \n    vec2 uv = fragCoord.xy / 4.0;\n    vec2 res = iResolution.xy / 4.0;\n    float col = 0.0;\n        \n    if(gameOver < 0.5) {\n        print_pos = vec2(2.0, res.y - STRHEIGHT(1.0));\n   \n        col += char (ch_p, uv);\n        col += char (ch_u, uv);\n        col += char (ch_n, uv);\n        col += char (ch_t, uv);\n        col += char (ch_o, uv);\n        col += char (ch_s, uv);\n        col += char (ch_col, uv);\n        col += char (ch_sp, uv);\n        col += print_number(puntos,print_pos,uv);\n \n    } else {\n        color += vec3(0.8,0.0,0.0);\n        \n        print_pos = vec2(res.x/2.0 - STRWIDTH(9.0)/2.0,res.y/2.0 - STRHEIGHT(1.0)/2.0);\n                \n        col += char(ch_g, uv);\n        col += char(ch_a, uv);\n        col += char(ch_m, uv);\n        col += char(ch_e, uv);\n        col += char(ch_sp, uv);\n        col += char(ch_o, uv);\n        col += char(ch_v, uv);\n        col += char(ch_e, uv);\n        col += char(ch_r, uv);\n        \n        print_pos = vec2(res.x/2.0 - STRWIDTH(9.0)/2.0,res.y/2.0 + STRHEIGHT(1.0)/2.0);\n        \n        if (nuevoRecord > 0.0) {\n            col += char(ch_r, uv);\n        \tcol += char(ch_e, uv);\n        \tcol += char(ch_c, uv);\n        \tcol += char(ch_o, uv);\n        \tcol += char(ch_r, uv);\n        \tcol += char(ch_d, uv);\n        \tcol += char(ch_col, uv);\n        \tcol += print_number(puntos,print_pos,uv);\n        }\n        \n    }\n    \n    color += vec3(col); \n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dfGzn","filepath":"/media/a/ec8a6ea755d34600547a5353f21f0a453f9f55ff95514383b2d80b8d71283eda.mp3","previewfilepath":"/media/ap/ec8a6ea755d34600547a5353f21f0a453f9f55ff95514383b2d80b8d71283eda.mp3","type":"music","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"/* NIVELES DE DIFICULTAD\n\n\t1 => FÃCIL\n\t2 => AVANZADO\n\t3 => DIFÃCIL \n\t4 => VETERANO\n\n*/\n\n#define DIFICULTAD 2\n\n#if DIFICULTAD == 1\n\tconst float umbralTiempo = 7.0;\n#endif\n\n#if DIFICULTAD == 2\n\tconst float umbralTiempo = 4.5;\n#endif\n\n#if DIFICULTAD == 3\n\tconst float umbralTiempo = 2.0;\n#endif\n\n#if DIFICULTAD == 4\n\tconst float umbralTiempo = 0.5;\n#endif\n\n// storage register/texel addresses\nconst vec2 txPosDiana    = vec2(0.0,0.0);\nconst vec2 txTiempoDiana = vec2(1.0,0.0);\nconst vec2 txDianaActiva = vec2(2.0,0.0);\nconst vec2 txColorDiana  = vec2(3.0,0.0);\nconst vec2 txVidas       = vec2(4.0,0.0);\nconst vec2 txGameOver    = vec2(5.0,0.0);\nconst vec2 txClickRaton  = vec2(6.0,0.0);\nconst vec2 txPuntaje \t = vec2(7.0,0.0);\n\nvec4  posDiana;\t\t// x,y,z,radio\nvec3  colorDiana;\nfloat tiempoDiana;\nfloat dianaActiva;\nfloat vidas;\nfloat gameOver;\nfloat puntos;\nfloat max_puntos;\nfloat nuevoRecord;\n\nvoid iniciarDiana() {\n\tposDiana    = vec4(0.0);\n    tiempoDiana = 0.0;\n    dianaActiva = -1.0;\n}\n\nfloat random(float seed){\n\t// Return a \"random\" number based on the \"seed\"\n    return fract(sin(seed) * 43758.5453);\n}\n\nvec3 randomPosition(float seed){\n\t// Return a \"random\" position based on the \"seed\"\n\treturn vec3(random(seed), random(seed * 1.1), random(seed * 1.2));\n}\n\nvoid crearDiana() {\n    // Crear diana\n    posDiana     = vec4(randomPosition(iTime),\n                        clamp(random(iTime+0.5),1./8.,1./2.));\n    posDiana.xyz = posDiana.xyz * 2. - 1.0;\n    tiempoDiana  = iTime;\n    dianaActiva  = 1.0;\n    colorDiana   = vec3(randomPosition (iTime * 1.1));\n}\n\nfloat iSphere( in vec3 ro, in vec3 rd, in vec4 sph )\n{\n    vec3 oc = ro - sph.xyz;\n    float b = dot( oc, rd );\n    float c = dot( oc, oc ) - sph.w*sph.w;\n    float h = b*b - c;\n    if( h<0.0 ) return -1.0;\n    return -b - sqrt( h );\n}\n \n/* Devuelve si se ha acertado sobre una diana */\nfloat esAcierto() {\n    vec2 relPos = -1.0 + 2.0*iMouse.zw / iResolution.xy;\n    relPos.x *= iResolution.x/iResolution.y;\n   \n    float an = 0.6 - 0.5*iTime + 10.0*iMouse.x/iResolution.x;\n    vec3 ro = vec3( 3.5*cos(0.0), 0.0, 3.5*sin(0.0) );\n    vec3 ta = vec3( 0.0, 0.0, 0.0 );\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    vec3 pr = normalize( relPos.x*uu + relPos.y*vv + 1.5*ww);\n   \n    vec4 sph1 = vec4(-posDiana.z*2., posDiana.y, -posDiana.x, posDiana.w);\n   \n    return (iSphere(ro, pr, sph1) > 0.0) ? 1.0 : -1.0;\n   \n}\n\n//----------------------------------------------------------------------------------------------\n\nfloat isInside( vec2 p, vec2 c ) { vec2 d = abs(p-0.5-c) - 0.5; return -max(d.x,d.y); }\n\n//----------------------------------------------------------------------------------------------\n\nvec4 loadValue( in vec2 re ) {\n    return texture( iChannel0, (0.5+re) / iChannelResolution[0].xy, -100.0 );\n}\n\nvoid storeValue( in vec2 re, in vec4 va, inout vec4 fragColor, in vec2 fragCoord ) {\n    fragColor = ( isInside(fragCoord,re) > 0.0 ) ? va : fragColor;\n}\n\n//----------------------------------------------------------------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    vec4 clickRaton = vec4(-1.0);\n    //---------------------------------------------------------------------------------   \n\t// Cargar estado del juego\n\t//---------------------------------------------------------------------------------\n    posDiana    = loadValue( txPosDiana );\t\t// x,y,z,radio\n    tiempoDiana = loadValue( txTiempoDiana ).x;\n    dianaActiva = loadValue( txDianaActiva ).x;\n    colorDiana  = loadValue( txColorDiana ).xyz;\n    vidas       = loadValue( txVidas ).x;\n    puntos\t\t= loadValue( txPuntaje ).x;\n    max_puntos  = loadValue( txPuntaje ).y;\n    nuevoRecord = loadValue( txPuntaje ).z;\n    gameOver    = loadValue( txGameOver ).x;\n    \n    //---------------------------------------------------------------------------------\n    // Inicio\n    //---------------------------------------------------------------------------------\n    if (iFrame == 0) {        \n        iniciarDiana();\n        vidas = 3.0;\n        puntos = 0.0;\n        max_puntos=  0.0;\n        nuevoRecord = -1.0;\n    }\n    \n    if (gameOver < 0.5 && dianaActiva < 0.) {\n    \tcrearDiana();\n    }\n    \n    //---------------------------------------------------------------------------------\n    // Logica del juego\n    //---------------------------------------------------------------------------------\n    if (vidas > 0.5) {\n        if (dianaActiva > 0.) {\n            if (iTime - tiempoDiana > umbralTiempo) {\n                // Borrar diana\n                iniciarDiana();\n                vidas -= 1.;\n                gameOver = (vidas < 0.5) ? 1.0 : 0.0;\n            }\n    \t}\n        if(iMouse.w > 0.0) {\n            float acierto = esAcierto();\n        \tclickRaton = vec4(1.0, acierto, iMouse.zw);\n            if(acierto > 0.) {\n            \tiniciarDiana();\n            \tcrearDiana();\n                puntos += 1.;\n                if (puntos > max_puntos) {\n                \tmax_puntos = puntos;\n                    nuevoRecord = 1.0;\n                }\n            }\n        }\n    } else {\n    \t// Esperar click para reiniciar\n        if (iMouse.w > 0.) {\n            gameOver = 0.0;\n            puntos = 0.0;\n            nuevoRecord = -1.0;\n        \tvidas = 3.;\n        }\n    }\n        \n    fragColor = vec4(0.0);\n    \n    \n    //---------------------------------------------------------------------------------\n    // Almacenar estado del juego\n    //---------------------------------------------------------------------------------\n    storeValue( txPosDiana,    posDiana,                      \t\t\tfragColor, fragCoord );\n    storeValue( txTiempoDiana, vec4(tiempoDiana,0.0,0.0,0.0), \t\t\tfragColor, fragCoord );\n    storeValue( txDianaActiva, vec4(dianaActiva,0.0,0.0,0.0), \t\t\tfragColor, fragCoord );\n    storeValue( txColorDiana,  vec4(colorDiana,0.0),          \t\t\tfragColor, fragCoord );\n    storeValue( txVidas,       vec4(vidas,0.0,0.0,0.0),       \t\t\tfragColor, fragCoord );\n    storeValue( txPuntaje,\t   vec4(puntos,max_puntos,nuevoRecord,0.0),\tfragColor, fragCoord );\n    storeValue( txGameOver,    vec4(gameOver,0.0,0.0,0.0),    \t\t\tfragColor, fragCoord );\n    storeValue( txClickRaton,  clickRaton,                    \t\t\tfragColor, fragCoord );\n    \n}","name":"Buf A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dX3Rn","filepath":"/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg","previewfilepath":"/media/ap/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"//-----------------------------------------------------------------------------   \n// Escenario\n//-----------------------------------------------------------------------------\n\n// Si no se cargan correctamente las texturas, pulsar |< para reiniciar.\n\nconst vec2 txResolution = vec2(0.0, 0.0);\nvec3 escenarioColor;\nvec2 oldResolution;\n\nstruct Triangulo {\n    // Coordenadas de los vÃ©rtices\n    vec3 a;\n    vec3 b;\n\tvec3 c;\n    //Coordenadas de las texturas\n    vec2 aT;\n    vec2 bT;\n    vec2 cT;\n    // Normal del triÃ¡nuglo\n    vec3 n;\n};\n    \nstruct Rectangulo {\n\tTriangulo t[2];\n};\n    \n// HabitaciÃ³n / Escenario\nRectangulo escenario[5];\nfloat fondo = 10.0;\n\nfloat tamano = 2.0;\nvec3 lig = normalize( vec3( 0.3,0.7,0.5) );\n\nvoid generarEscenario () {\n    \n    // Suelo\n\tescenario[0].t[0].a   =\t\tvec3 ( -2.0,\t0.0, \t -2.0); \n\tescenario[0].t[0].b   = \tvec3 ( -2.0,  \t0.0,  \tfondo);\n\tescenario[0].t[0].c   = \tvec3 (  2.0,  \t0.0, \t -2.0);\n\tescenario[0].t[0].n   =\t\tvec3 (  0.0,  \t1.0,      0.0);\n\tescenario[0].t[0].aT  =\t\tvec2 (  0.0,  \t0.0);\n\tescenario[0].t[0].bT  = \tvec2 (  0.0,  fondo);\n\tescenario[0].t[0].cT  = \tvec2 (  4.0,  \t0.0);\n\n\tescenario[0].t[1].a   = \tvec3 ( -2.0,  \t0.0,\tfondo);\n\tescenario[0].t[1].b   = \tvec3 (  2.0,  \t0.0,  \tfondo);\n\tescenario[0].t[1].c   =  \tvec3 (  2.0,  \t0.0, \t -2.0);\n\tescenario[0].t[1].n   =\t\tvec3 (  0.0,    1.0,      0.0); \n\tescenario[0].t[1].aT  = \tvec2 (  0.0,  fondo);\n\tescenario[0].t[1].bT  = \tvec2 (  4.0,  fondo);\n\tescenario[0].t[1].cT  = \tvec2 (  4.0,    0.0);\n\t\n\t// Techo\n\tescenario[1].t[0].a   = \tvec3 (  2.0,  \t2.0, \t -2.0);\n\tescenario[1].t[0].b   = \tvec3 ( -2.0,  \t2.0,  \tfondo);\n\tescenario[1].t[0].c   = \tvec3 ( -2.0,  \t2.0,\t -2.0);\n\tescenario[1].t[0].n   = \tvec3 (  0.0,   -1.0,      0.0);\n\tescenario[1].t[0].aT  = \tvec2 (  4.0,    0.0);\n\tescenario[1].t[0].bT  = \tvec2 (  0.0,  fondo);\n\tescenario[1].t[0].cT  = \tvec2 (  0.0,    0.0);\n\t\n\tescenario[1].t[1].a   = \tvec3 (  2.0,  \t2.0, \t -2.0);\n\tescenario[1].t[1].b   = \tvec3 (  2.0,  \t2.0,  \tfondo);\n\tescenario[1].t[1].c   = \tvec3 ( -2.0,  \t2.0,  \tfondo);\n\tescenario[1].t[1].n   = \tvec3 (  0.0,   -1.0,      0.0);\n\tescenario[1].t[1].aT  = \tvec2 (  4.0,    0.0);\n\tescenario[1].t[1].bT  = \tvec2 (  4.0,  fondo);\n\tescenario[1].t[1].cT  = \tvec2 (  0.0,  fondo);\n\t\n\t// Pared izquierda\n\tescenario[2].t[0].a   = \tvec3 (  2.0,  \t0.0,\t -2.0);\n\tescenario[2].t[0].b   = \tvec3 (  2.0,  \t0.0,  \tfondo);\n\tescenario[2].t[0].c   = \tvec3 (  2.0,  \t2.0,     -2.0);\n\tescenario[2].t[0].n   = \tvec3 (  1.0,    0.0,      0.0);\n\tescenario[2].t[0].aT  = \tvec2 (  0.0,    0.0);\n\tescenario[2].t[0].bT  = \tvec2 (  0.0,  fondo);\n\tescenario[2].t[0].cT  = \tvec2 (  4.0,    0.0);\n\t\n\tescenario[2].t[1].a   = \tvec3 (  2.0,  \t0.0,  \tfondo);\n\tescenario[2].t[1].b   = \tvec3 (  2.0,  \t2.0,  \tfondo);\n\tescenario[2].t[1].c   = \tvec3 (  2.0,  \t2.0,     -2.0);\n\tescenario[2].t[1].n   = \tvec3 (  1.0,    0.0,      0.0);\n\tescenario[2].t[1].aT  = \tvec2 (  0.0,  fondo);\n\tescenario[2].t[1].bT  = \tvec2 (  4.0,  fondo);\n\tescenario[2].t[1].cT  = \tvec2 (  4.0, \t0.0);\n\t\n\t// Pared derecha\n\tescenario[3].t[0].a   = \tvec3 ( -2.0,  \t2.0,     -2.0);\n\tescenario[3].t[0].b   = \tvec3 ( -2.0,  \t0.0,  \tfondo);\n\tescenario[3].t[0].c   = \tvec3 ( -2.0,  \t0.0,     -2.0);\n\tescenario[3].t[0].n   = \tvec3 ( -1.0,    0.0,      0.0);\n\tescenario[3].t[0].aT  = \tvec2 (  4.0,    0.0);\n\tescenario[3].t[0].bT  = \tvec2 (  0.0,  fondo);\n\tescenario[3].t[0].cT  = \tvec2 (  0.0,    0.0);\n\t\n\tescenario[3].t[1].a   = \tvec3 ( -2.0,  \t2.0,     -2.0);\n\tescenario[3].t[1].b   = \tvec3 ( -2.0,  \t2.0,  \tfondo);\n\tescenario[3].t[1].c   = \tvec3 ( -2.0,  \t0.0,  \tfondo);\n\tescenario[3].t[1].n   = \tvec3 ( -1.0,    0.0,      0.0);\n\tescenario[3].t[1].aT  = \tvec2 (  4.0,    0.0);\n\tescenario[3].t[1].bT  = \tvec2 (  4.0,  fondo);\n\tescenario[3].t[1].cT  = \tvec2 (  0.0,  fondo);\n\t\n\t// Pared Fondo \n    escenario[4].t[0].a   = \tvec3 ( -2.0, \t0.0,    fondo);\n    escenario[4].t[0].b   = \tvec3 ( -2.0, \t2.0, \tfondo);\n    escenario[4].t[0].c   = \tvec3 (  2.0, \t0.0, \tfondo);  \n    escenario[4].t[0].n   = \tvec3 (  0.0,    0.0,      1.0);\n    escenario[4].t[0].aT  = \tvec2 (  0.0,    0.0);\n    escenario[4].t[0].bT  = \tvec2 (  0.0,    4.0);\n    escenario[4].t[0].cT  = \tvec2 (  4.0,    0.0);\n        \n    escenario[4].t[1].a   = \tvec3 ( -2.0, \t2.0, \tfondo);\n    escenario[4].t[1].b   = \tvec3 (  2.0, \t2.0, \tfondo); \n    escenario[4].t[1].c   = \tvec3 (  2.0, \t0.0, \tfondo);  \n    escenario[4].t[1].n   = \tvec3 (  0.0,    0.0,      1.0);\n    escenario[4].t[1].aT  = \tvec2 (  0.0,    4.0);\n    escenario[4].t[1].bT  = \tvec2 (  4.0,    4.0);\n    escenario[4].t[1].cT  = \tvec2 (  4.0,    0.0);\n             \n}\n\nfloat cross (vec2 a, vec2 b) {\n    return a.x*b.y - a.y*b.x;\n}\n\nvec3 calcularColor (vec3 nor, vec2 uv, float z, vec3 wnor, sampler2D iChannel) {\n\t\n\tfloat dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n    float brdf = 0.5 + 0.8*dif;\n\t\t\t\n\tvec3 mate = texture( iChannel, uv ).xyz ;\n\t\n    vec3 col = brdf * mate;\t\n\t\n    return sqrt( col );\n}\n\nmat4 setRotation( float x, float y, float z ) {\n    float a = sin(x); float b = cos(x); \n    float c = sin(y); float d = cos(y); \n    float e = sin(z); float f = cos(z); \n\n    float ac = a*c;\n    float bc = b*c;\n\n    return mat4( d*f,      d*e,       -c, 0.0,\n                 ac*f-b*e, ac*e+b*f, a*d, 0.0,\n                 bc*f+a*e, bc*e-a*f, b*d, 0.0,\n                 0.0,      0.0,      0.0, 1.0 );\n}\n\nmat4 setTranslation( float x, float y, float z ) {\n    return mat4( 1.0, 0.0, 0.0, 0.0,\n\t\t\t\t 0.0, 1.0, 0.0, 0.0,\n\t\t\t\t 0.0, 0.0, 1.0, 0.0,\n\t\t\t\t x,     y,   z, 1.0 );\n}\n\nvoid pintarEscenario (vec2 px) {\n        \n\tfloat mindist = -1000000.0;\n    \n    mat4 mdv = setTranslation( 0.0, -1.0, -3.0 ) * \n\t\t       setRotation( 0.0, 3.14, 0.0 );\n    \n    for ( int i = 0; i < 5; i++ ){\n        \n\t\tfor ( int j = 0 ; j < 2; j++) {\n                    \n\t\t\tvec3 ep0 = ( mdv * vec4 ( escenario[i].t[j].a, 1.0 )).xyz;\n\t\t\tvec3 ep1 = ( mdv * vec4 ( escenario[i].t[j].b, 1.0 )).xyz;\n\t\t\tvec3 ep2 = ( mdv * vec4 ( escenario[i].t[j].c, 1.0 )).xyz;\n\t\t\tvec3 nor = ( mdv * vec4 ( escenario[i].t[j].n, 0.0 )).xyz;\n\n\t\t\tfloat w0 = 1.0/ep0.z;\n\t\t\tfloat w1 = 1.0/ep1.z;\n\t\t\tfloat w2 = 1.0/ep2.z;\n\n\t\t\tvec2 cp0 = 2.0*ep0.xy * -w0;\n\t\t\tvec2 cp1 = 2.0*ep1.xy * -w1;\n\t\t\tvec2 cp2 = 2.0*ep2.xy * -w2;\n\n\t\t\tvec2 u0 = escenario[i].t[j].aT * w0;\n\t\t\tvec2 u1 = escenario[i].t[j].bT * w1;\n\t\t\tvec2 u2 = escenario[i].t[j].cT * w2;\n\n\t\t\tvec3 di = vec3( cross( cp1 - cp0, px - cp0 ), \n\t\t\t\t\t\t\tcross( cp2 - cp1, px - cp1 ), \n\t\t\t\t\t\t\tcross( cp0 - cp2, px - cp2 ) );\n\t\t\t\n\t\t\tif( all(greaterThan(di,vec3(0.0))) ){\n\t\t\t\t\n\t\t\t\tvec3 ba = di.yzx / (di.x+di.y+di.z);\n\n\t\t\t\tfloat iz = ba.x*w0 + ba.y*w1 + ba.z*w2;\n\t\t\t\tvec2  uv = ba.x*u0 + ba.y*u1 + ba.z*u2;\n\n\t\t\t\tfloat z = 1.0/iz;\n\t\t\t\tuv *= z;\n\n\t\t\t\tif( z>mindist ){\n\t\t\t\t\t\n\t\t\t\t\tmindist = z;\n                    if (i == 0)\n\t\t\t\t\t\tescenarioColor = calcularColor( nor, uv, z, escenario[i].t[j].n, iChannel1 );\n                    else\n                    \tescenarioColor = calcularColor( nor, uv, z, escenario[i].t[j].n, iChannel2 );\n\t\t\t\t}\n\t\t\t}\n\t\t\n\t\t}\n    }\n}\n\n\nbool resolutionChange (vec2 oldRes) {\n\treturn oldRes != iResolution.xy;\n}\n\n\n//---------------------------------------------------------------------------------\nfloat isInside( vec2 p, vec2 c ) {\n    vec2 d = abs(p-0.5-c) - 0.5; return -max(d.x,d.y);\n}\n\nvoid storeScene (in vec2 re, in vec4 va, inout vec4 fragColor, in vec2 fragCoord ) {\n\tfragColor = ( isInside(fragCoord, re) > 0.0) ? va : fragColor;\n}\nvec4 loadScene (in vec2 re ) {\n\treturn texture (iChannel0, (re) / iChannelResolution[0].xy);\n}\n\n//---------------------------------------------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //---------------------------------------------------------------------------------   \n\t// Cargar escenario\n\t//---------------------------------------------------------------------------------\n    escenarioColor = loadScene ( fragCoord ).xyz;\n    oldResolution = loadScene  ( txResolution ).xy;\n    \n    if (iFrame == 0 || resolutionChange(oldResolution)) {\n    \t//-----------------------------------------------------------------------------   \n        // Generar escenario\n        //-----------------------------------------------------------------------------\n        escenarioColor = vec3(0.0);\n        vec2 px = -1.0 + 2.0*fragCoord.xy / iResolution.xy;\n    \tpx.x *= iResolution.x/iResolution.y;\n        generarEscenario();\n        pintarEscenario(px);\n    }\n    \n    fragColor = vec4(escenarioColor, 1.0);\n    \n    //---------------------------------------------------------------------------------   \n\t// Almacenar escenario\n\t//---------------------------------------------------------------------------------\n    storeScene( fragCoord,    vec4(escenarioColor, 1.0), fragColor, fragCoord );\n    storeScene( txResolution, vec4(iResolution, 0.0),    fragColor, fragCoord );\n}","name":"Buf B","description":"","type":"buffer"}]}