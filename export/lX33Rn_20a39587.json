{"ver":"0.1","info":{"id":"lX33Rn","date":"1715974173","viewed":65,"name":"gimbal lock","username":"aoa","description":"Example of a gimbal.\n\nWhen the outer two rings lie in the same plane, the inner most ring spins in the same way as the outermost ring. This is called gimbal lock.\n\nTry pausing the video and playing with the mouse to try to achieve this effect!","likes":9,"published":1,"flags":0,"usePreview":0,"tags":["sdf","raymaching","gimbal","lock","gimballock"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nconst float PI = 3.14159;\n\n// https://iquilezles.org/articles/distfunctions/\nfloat sdTorus( vec3 p, vec2 t )\n{\n    return length( vec2(length(p.xz)-t.x,p.y) )-t.y;\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\n\nfloat sdCylinder( vec3 p, vec3 c )\n{\n  return length(p.xz-c.xy)-c.z;\n}\n\n// https://en.wikipedia.org/wiki/Rotation_matrix#Basic_3D_rotations\nmat3 rotx(float theta) {\n    return mat3(1.0, 0.0,0.0\n               ,0.0,  cos(theta),-sin(theta)\n               ,0.0,  sin(theta),cos(theta)\n                );\n}\nmat3 roty(float theta) {\n    return mat3(\n               cos(theta),0.0,-sin(theta)\n               ,0.0, 1.0,0.0\n               ,sin(theta),0.0,cos(theta)\n                );\n}\nmat3 rotz(float theta) {\n    return mat3(\n               cos(theta),-sin(theta),0.0\n               ,sin(theta),cos(theta),0.0\n               ,0.0, 0.0,1.0\n                );\n}\n\nfloat map( in vec3 pos )\n{\n    vec2 mo = iMouse.xy/iResolution.xy;\n    float not_pressed = 1.0 - float(iMouse.z > 0.0);\n    \n    float res = 10000.;\n    \n    mat3 roto = rotz(PI/9. * iTime + 4. * PI * mo.x); // rotate outer\n    mat3 rotm = rotx(PI/6. * iTime + 4. * PI * mo.y); // rotate middle\n    mat3 roti = rotz(PI/4. * iTime); // rotate inner\n    \n    float r = 0.05;\n    float Rstep = 0.25;\n    \n    float R = 0.75; // radius of current cylinder\n    // outer polls to infinity\n\tres = min(res, sdCapsule(               roto * pos , vec3(0.0,0.0,R),  vec3(0.0,0.0,R+1000.), r));\n\tres = min(res, sdCapsule(               roto * pos , vec3(0.0,0.0,-R), vec3(0.0,0.0,-R-1000.), r));\n                  \n    // outer              \n\tres = min(res, sdTorus(                 roto * pos , vec2(R,r)));\n\tres = min(res, sdCapsule(               roto * pos , vec3(R,0.0,0.0),  vec3(R-Rstep,0.0,0.0), r));\n\tres = min(res, sdCapsule(               roto * pos , vec3(-R,0.0,0.0), vec3(Rstep-R,0.0,0.0), r));\n    // middle       \n    R = 0.5;       \n\tres = min(res, sdTorus(          rotm * roto * pos , vec2(R,r)));\n\tres = min(res, sdCapsule(        rotm * roto * pos , vec3(0.0,0.0,R),  vec3(0.0,0.0,R-Rstep), r));\n\tres = min(res, sdCapsule(        rotm * roto * pos , vec3(0.0,0.0,-R), vec3(0.0,0.0,Rstep-R), r));\n    // inner\n    R = 0.25;\n\tres = min(res, sdTorus(   roti * rotm * roto * pos, vec2(R,r)));\n    // cross\n\tres = min(res, sdCapsule( roti * rotm * roto * pos, vec3(R,0.0,0.0),  vec3(-R,0.0,0.0), r));\n\tres = min(res, sdCapsule( roti * rotm * roto * pos, vec3(0.0,0.0,R),  vec3(0.0,0.0,-R), r));\n\n    return res;\n}\n\n/////////////////////////////////////////////////////////\n// RAYMARCHING LOGIC\n// adapted from https://www.shadertoy.com/view/tl23RK\n/////////////////////////////////////////////////////////\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal( in vec3 pos )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773;\n    const float eps = 0.0005;\n    return normalize( e.xyy*map( pos + e.xyy*eps ) + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx*eps ) + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy*eps ) + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx*eps ) );\n}\n    \n#if HW_PERFORMANCE==0\n#define AA 1\n#else\n#define AA 3\n#endif\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n     // camera movement\t\n\tfloat an = 0.0; 0.7*iTime;\n\tvec3 ro = vec3( 1.0*cos(an), 2.0, 1.0*sin(an) );\n    vec3 ta = vec3( 0.0, 0.0, 0.0 );\n    // camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv =          ( cross(uu,ww));\n    \n    // render\n    vec3 tot = vec3(0.0);\n    \n    #if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n        #else    \n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n        #endif\n\n\t    // create view ray\n        vec3 rd = normalize( p.x*uu + p.y*vv + 1.5*ww );\n\n        // raymarch\n        const float tmax = 5.0;\n        float t = 0.0;\n        for( int i=0; i<256; i++ )\n        {\n            vec3 pos = ro + t*rd;\n            float h = map(pos);\n            if( h<0.0001 || t>tmax ) break;\n            t += h;\n        }\n        \n    \n        // shading/lighting\t\n        vec3 col = vec3(0.0);\n        if( t<tmax )\n        {\n            vec3 pos = ro + t*rd;\n            vec3 nor = calcNormal(pos);\n            float dif = clamp( dot(nor,vec3(0.57703)), 0.0, 1.0 );\n            float amb = 0.5 + 0.5*dot(nor,vec3(0.0,1.0,0.0));\n            col = vec3(0.2,0.3,0.4)*amb + vec3(0.8,0.7,0.5)*dif;\n        }\n\n        // gamma        \n        col = sqrt( col );\n\t    tot += col;\n    #if AA>1\n    }\n    tot /= float(AA*AA);\n    #endif\n\n\tfragColor = vec4( tot, 1.0 );\n}","name":"Image","description":"","type":"image"}]}