{"ver":"0.1","info":{"id":"NllSW8","date":"1625625579","viewed":66,"name":"learning 3d raymarching","username":"wigglewiggle","description":"just learning how to use shadertoy: \nhere is a source I used to learn how \nto do this I basically copied pasted \nit all but I did make some changes \nto the code: https://www.shadertoy.com/view/wdf3zl \n","likes":1,"published":1,"flags":16,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*just learning how to use shadertoy: \nhere is a source I used to learn how \nto do this I basically copied pasted \nit all but I did make some changes \nto the code: https://www.shadertoy.com/view/wdf3zl \n*/\n\n#define maxSteps 1000\n#define maxDist 100.\n#define minDist 0.001\n\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r) {\n\tvec3 ab = b-a;\n    vec3 ap = p-a;\n    \n    float t = dot(ab, ap) / dot(ab, ab);\n    t = clamp(t, 0., 1.);\n    \n    vec3 c = a + t*ab;\n    \n    return length(p-c)-r;\n}\n\nfloat sdCylinder(vec3 p, vec3 a, vec3 b, float r) {\n\tvec3 ab = b-a;\n    vec3 ap = p-a;\n    \n    float t = dot(ab, ap) / dot(ab, ab);\n    //t = clamp(t, 0., 1.);\n    \n    vec3 c = a + t*ab;\n    \n    float x = length(p-c)-r;\n    float y = (abs(t-.5)-.5)*length(ab);\n    float e = length(max(vec2(x, y), 0.));\n    float i = min(max(x, y), 0.);\n    \n    return e+i;\n}\n\nfloat sdTorus(vec3 p,vec3 pos, vec2 r) {\np-=pos;\n\tfloat x = length(p.xz)-r.x;\n    return length(vec2(x, p.y))-r.y;\n}\n\nfloat dBox(vec3 p,vec3 boxPos, vec3 s) {\n    p-=boxPos;\n\treturn length(max(abs(p)-s, 0.));\n}\n\n\nfloat getDist(vec3 checkPos){\n\tvec4 s = vec4(2., 1., 6., 1.);\n    vec4 sTwo=vec4(-2.,1.,4.,1.);\nfloat sphereDist=length(checkPos-s.xyz)-s.w;\nfloat sphereDistTwo=length(checkPos-sTwo.xyz)-sTwo.w;\nfloat planeDist=checkPos.y;\nfloat boxDist=dBox(checkPos,vec3(2.,1.,6.5),vec3(1.,1.,1.));\nfloat boxDistTwo=dBox(checkPos,vec3(-2.,1.,4.),vec3(1.,1.,1.));\nfloat torusDist=sdTorus(checkPos,vec3(0,0.5,-4),vec2(1.5,.4));\nfloat d=max(boxDist,-sphereDist);\nd=min(d,planeDist);\nd=min(d,torusDist);\nfloat per=0.;\nd=min(d,sphereDistTwo+(boxDistTwo-sphereDistTwo)*1.);\nreturn d;\n}\n\nfloat rayMarch(vec3 startPos,vec3 dir){\nfloat dist=0.;\n\nfor(int i=0;i<maxSteps;i++){\nvec3 checkPos=startPos+dir*dist;\nfloat safeStepDist=getDist(checkPos);\ndist+=safeStepDist;\nif(dist>maxDist||safeStepDist<minDist){\nbreak;}\n\n\n}\n\n\n\nreturn dist;\n}\n\nmat2 Rot(float a) {\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\nvec3 getNormal(vec3 p) {\n\tfloat d = getDist(p);\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        getDist(p-e.xyy),\n        getDist(p-e.yxy),\n        getDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\nfloat getLightAtPoint(vec3 point,vec3 lightPos){\n//vec3 lightPos=vec3(cos(iTime)*3.,5.,sin(iTime)*3.+3.);\nvec3 l=normalize(lightPos-point);\nvec3 n=getNormal(point);\n\nfloat dif=dot(n,l);\nfloat d=rayMarch(point+n*minDist*2.,l);\n\nif(d<length(lightPos-point)){\ndif*=0.1;\n}\n\nreturn dif;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n  vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\nvec2 mouse = iMouse.xy/iResolution.xy;\n    \nvec3 camPoint=vec3(0,2,0);\n\n  \n   vec3 rayDir = normalize(vec3(uv.x-.15, uv.y-.2, 1));\n        \n      rayDir.yz*=Rot(-mouse.y*3.14+1.);  \n            rayDir.xz*=Rot(-mouse.x*3.14*4.+3.14*1.);  \n    \n    float distRayTraveled = rayMarch(camPoint, rayDir);\n    \n    \n    vec3 checkPointForLighting=camPoint+rayDir*distRayTraveled;\n//    vec3 lightPos=vec3(cos(iTime)*3.,5.,sin(iTime)*3.+3.);\n\n    float lighting=getLightAtPoint(checkPointForLighting,camPoint);\n    \n    float col=1.-distRayTraveled/maxDist;\n    col=lighting;\n    fragColor = vec4(col,col,col,1.0);\n}","name":"Image","description":"","type":"image"}]}