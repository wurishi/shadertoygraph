{"ver":"0.1","info":{"id":"ltyGRh","date":"1473015924","viewed":832,"name":"Floating Bands","username":"lara","description":"Part of another shader I am working on.\nCubic roots are so sloooow..","likes":6,"published":3,"flags":32,"usePreview":0,"tags":["ribbon","swirls","band"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Change resolution in Buf A\n\n#define inside(a) (fragCoord.x == a.x+0.5 && fragCoord.y == a.y+0.5)\n#define load(a,b) texture(b,(a+0.5)/iResolution.xy)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n   \tvec2 uv = fragCoord.xy / iResolution.xy;\n    float res = load(vec2(0,0), iChannel0).x;\n    \n    fragColor = texture(iChannel0, fragCoord.xy/iResolution.xy*res);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define RES (1./2.)\n#define inside(a) (fragCoord.x == a.x+0.5 && fragCoord.y == a.y+0.5)\n#define load(a,b) textureLod(b,(a+0.5)/iResolution.xy,0.)\n\n#define SHADOW\n#define AMBIENT_OCCLUSION\n\n#define T iTime\n#define PI 3.141592653\n#define TAU (PI*2.)\n\n#define P 0.001  // Precision\n#define D 10.    // Max distance\n#define S 256    // Marching steps\n#define R 1.     // Marching substeps\n#define K 32.    // Shadow softness\n#define A 4.     // AO steps\n\n/* ======================== */\n/* === Marching Globals === */\n/* ======================== */\n\nstruct Hit {\n\tvec3 p;\n\tfloat t;\n\tfloat d;\n\tfloat s;\n};\n\nstruct Ray {\n\tvec3 o;\n\tvec3 d;\n}, _ray;\n\nstruct Cam {\n\tvec3 p;\n\tvec3 t;\n    vec3 u;\n    float f;\n}, _cam;\n\n\nconst int _num_objects = 2;\nfloat _d, _obj[_num_objects];\n\nint _ignore = -1;\n\nbool _ambientOccMarch = false;\nbool _shadowMarch = false;\nbool _normalMarch = false;\n\n/* ================= */\n/* === Utilities === */\n/* ================= */\n\n\nvec3 fbm(vec2 p)\n{\n    vec3 f = vec3(0);\n\t\n    // just noticed that this is the wrong way around\n    // but it actually doesn't look too bad\n    f += textureLod(iChannel0,p/08.,0.).rgb*1.;\n    f += textureLod(iChannel0,p/04.,0.).rgb*2.;\n    f += textureLod(iChannel0,p/02.,0.).rgb*4.;\n    f += textureLod(iChannel0,p/01.,0.).rgb*8.;\n    \n    return f/(1.+2.+4.+8.);\n}\n\n// https://en.wikipedia.org/wiki/Cubic_function#Cardano.27s_method\nvec3 cubicRoot(float a, float b, float c, float d)\n{\n\tfloat p = (9.*a*c-3.*b*b)/(9.*a*a);\n\tfloat q = (2.*b*b*b-9.*a*b*c+27.*a*a*d)/(27.*a*a*a);\n\tfloat p3 = p*p*p;\n\tfloat e = q*q+4.*p3/27.;\n\n\tif (e > 0.0)\n\t{\n\t\te = sqrt(e);\n        \n\t\tfloat u = (-q+e)/2.;\n\t\tfloat v = (-q-e)/2.;\n        \n\t\tu = (u>=0.) ? pow(u,1./3.) : -pow(-u,1./3.);\n\t\tv = (v>=0.) ? pow(v,1./3.) : -pow(-v,1./3.);\n        \n\t\treturn vec3(u+v-b/(3.*a),1.0,1.0);\n\t}\n\n\tfloat u = 2.*sqrt(-p/3.);\n    float v = acos(-sqrt(-27./p3)*q/2.)/3.;\n    \n\treturn vec3(\n        u*cos(v),\n        u*cos(v+2.*PI/3.),\n        u*cos(v+4.*PI/3.))-b/(3.*a\n\t);\n}\n\n/* ===================== */\n/* === SDF Functions === */\n/* ===================== */\n\nfloat udBox(vec3 p, vec3 s, float r)\n{\n    return length(max(abs(p)-s+r,0.))-r;\n}\n\n// q1 = a + ac*t\n// q2 = c + cb*t\n// q3 = a + 2(ac)*t + (a+b-2c)*tÂ²\n// (p-q3)(q2-q1)=0\nfloat sdBand(vec3 p, vec3 a, vec3 b, vec3 c, vec3 n, float r)\n{ \n\tvec3 ac = c-a;\n\tvec3 ap = p-a;\n\tvec3 abc = -2.*c+a+b;\n\n\tvec3 t = clamp(cubicRoot(\n\t\t-dot(abc,abc),\n\t\t-3.*dot(abc,ac),\n\t\t-2.*dot(ac,ac)+dot(ap,abc),\n\t\tdot(ap,ac)\n\t),0.,1.);\n\n\tvec3 q1 = (2.*ac+abc*t.x)*t.x;\n\tvec3 q2 = (2.*ac+abc*t.y)*t.y;\n\tvec3 q3 = (2.*ac+abc*t.z)*t.z;\n\t\n\treturn min(min(udBox(ap-q1,(1.-n)*r,0.),udBox(ap-q2,(1.-n)*r,0.)),udBox(ap-q3,(1.-n)*r,0.));\n}\n\n/* ============ */\n/* === Scene=== */\n/* ============ */\n\nfloat scene(vec3 p)\n{\n\tvec3 q, r; float d = 1e10;\n    \n    // Floor\n    _obj[0] = p.y+1.;\n    \n    for(int i = 0; i < 10; i++)\n    {\n        vec3 p1 = (fbm(vec2(i  ,T)/iChannelResolution[0].xy).rgb-.5)*2.;\n        vec3 p2 = (fbm(vec2(i+1,T)/iChannelResolution[0].xy).rgb-.5)*2.;\n        vec3 p3 = (fbm(vec2(i+2,T)/iChannelResolution[0].xy).rgb-.5)*2.;\n    \td = min(d,sdBand(p,p1,p2,p3,vec3(0,1,0),0.01));\n    }\n    \n    // Swirls\n    _obj[1] = d; d = 1e10;\n\n\tfor(int i = 0; i < _num_objects; i++)\n\t{\n\t\t//if (_ignore == i) continue;\n\t\td = min(d,_obj[i]);\n\t}\n\n\t_d = d;\n\n\treturn d;\n}\n\n/* ================ */\n/* === Marching === */\n/* ================ */\n\nRay lookAt(Cam c, vec2 uv)\n{\n\tvec3 d = normalize(c.t - c.p);\n\tvec3 r = normalize(cross(d,c.u));\n\tvec3 u = cross(r,d);\n\n\treturn Ray(c.p*c.f, normalize(uv.x*r + uv.y*u + d*c.f));\n}\n\nHit march(Ray r)\n{\n\tfloat t = 0., d, s;\n\tvec3 p;\n\t\n\tfor(int i = 0; i < S; i++)\n\t{\n\t\td = scene(p = r.o + r.d*t);\n\n\t\tif (d < P || t > D)\n\t\t{\n\t\t\ts = float(i);\n\t\t\tbreak;\n\t\t}\n\n\t\tt += d/R;\n\t}\n\n\treturn Hit(p, t, d, s);\n}\n\nvec3 getNormal(vec3 p)\n{\n    _normalMarch = true;\n    \n\tvec2 e = vec2(P,0.);\n\n\treturn normalize(vec3(\n\t\tscene(p+e.xyy)-scene(p-e.xyy),\n\t\tscene(p+e.yxy)-scene(p-e.yxy),\n\t\tscene(p+e.yyx)-scene(p-e.yyx)\n\t));\n}\n\n/* =============== */\n/* === Shading === */\n/* =============== */\n\nfloat getShadow(vec3 light, vec3 origin)\n{\n\t_shadowMarch = true;\n\n\tvec3 d = normalize(light - origin);\n\tfloat t = 0.;\n\tfloat maxt = length(light - origin)-.1;\n\tfloat s = 1.0;\n    \n    const int n = S/4;\n\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tfloat d = scene(origin + d * t);\n\t\tif (t > maxt || t > D) { break; }\n\t\tt += d; s = min(s,d/t*K);\n\t}\n\n\treturn s;\n}\n\nfloat getAmbientOcclusion(Hit h) \n{\n    _ambientOccMarch = true;\n    \n    float t = 0., a = 0.;\n    \n\tfor(float i = 0.; i < A; i++)\n    {\n        float d = scene(h.p-_ray.d*i/A*.2);\n        t += d;\n    }\n\n\treturn clamp(t/A*20.,0.,1.);\n}\n\nvec3 getColor(Hit h)\n{\n    vec3 fog = vec3(0);\n\tif (h.d > P) { return fog; }\n\n\tvec3 col = vec3(0);\n\tvec3 n = getNormal(h.p);\n    vec3 light = vec3(0,10,0);\n\n\tfloat diff = max(dot(n, normalize(light-h.p)),.1);\n\tfloat spec = pow(max(dot(reflect(normalize(h.p-light),n),normalize(_cam.p-h.p)),0.),100.);\n\tfloat dist = clamp(length(h.p)/D*1.5,0.,1.);\n    \n    if (_d == _obj[0])\n    {\n        col = vec3(.5) * max(n.y,.5);\n    }\n    else if (_d == _obj[1])\n    {\n\t\tcol = vec3(2,1.5,0) * max(n.y,.5);\n    }\n    \n    #ifdef SHADOW\n    col *= max(getShadow(light,h.p),.5);\n    #endif\n    \n    #ifdef AMBIENT_OCCLUSION\n    col *= getAmbientOcclusion(h);\n    #endif\n\n    return mix(col,fog,dist);\n}\n\n/* ============ */\n/* === Main === */\n/* ============ */\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if (inside(vec2(0,0))) { fragColor.x = RES; return; }\n    \n    _cam = Cam(vec3(0,.5,-1), vec3(0),vec3(0,1,0),1.);\n    _ray = lookAt(_cam,(2.*fragCoord.xy/RES-iResolution.xy)/iResolution.xx);\n    \n    float f = 1.-length((2.0*fragCoord.xy/RES-iResolution.xy)/iResolution.xy)*0.5;\n\tfragColor = vec4(getColor(march(_ray))*f,1);\n}","name":"Buf A","description":"","type":"buffer"}]}