{"ver":"0.1","info":{"id":"tltXz7","date":"1580804359","viewed":299,"name":"univanq 2020-02-04","username":"w23","description":"A nightmare I had about my home town.","likes":16,"published":1,"flags":0,"usePreview":1,"tags":["raymarching","academ"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdX3Rr","filepath":"/media/a/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin","previewfilepath":"/media/ap/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin","type":"volume","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const vec3 E = vec3(0., .01, 1.);\n\nfloat t;\n\nvec4 nz2un(vec2 p) { return textureLod(iChannel0, p, 0.); }\nvec4 nz2(vec2 p) { return textureLod(iChannel0, (p-.5)/vec2(textureSize(iChannel0, 0)), 0.); }\nvec4 nz3un(vec3 p) { return textureLod(iChannel1, p, 0.); }\nvec4 nz3(vec3 p) { return textureLod(iChannel1, (p-.5)/vec3(textureSize(iChannel1, 0)), 0.); }\n\nmat2 Rm(float a) { float c=cos(a),s=sin(a); return mat2(c,s,-s,c); }\n\nfloat rep1(float p, float s) { return mod(p, s) - s * .5; }\nvec2 rep2(vec2 p, vec2 s) { return mod(p, s) - s * .5; }\nvec3 rep3(vec3 p, vec3 s) { return mod(p, s) - s * .5; }\n\nfloat vmax(vec3 v) { return max(max(v.x, v.y), v.z); }\nfloat vmax(vec2 v) { return max(v.x, v.y); }\nfloat box3(vec3 p, vec3 s) { return vmax(abs(p)-s); }\nfloat box2(vec2 p, vec2 s) { return vmax(abs(p)-s); }\nfloat box1(float p, float s) { return abs(p)-s; }\n\n// iq\n// exponential smooth min (k = 32);\nfloat smine( float a, float b, float k )\n{\n    float res = exp2( -k*a ) + exp2( -k*b );\n    return -log2( res )/k;\n}\n\nfloat smin( float a, float b, float k )\n{\n    float h = max( k-abs(a-b), 0.0 )/k;\n    return min( a, b ) - h*h*k*(1.0/4.0);\n}\n\nfloat sminc( float a, float b, float k )\n{\n    float h = max( k-abs(a-b), 0.0 )/k;\n    return min( a, b ) - h*h*h*k*(1.0/6.0);\n}\n\n// hg_sdf\n// first object gets a capenter-style groove cut out\nfloat fOpGroove(float a, float b, float ra, float rb) {\n\treturn max(a, min(a + ra, rb - abs(b)));\n}\n\n\nfloat wgnd = 1e6;\nfloat wbld = 1e6;\nfloat wmetal = 1e6;\nfloat wroad = 1e6;\n\nfloat wcstr = 1e6, wcstr1 = 1e6;\nfloat wd = 1e6;\nfloat wglass = 1e6;\n\nvec2 slope = normalize(vec2(.7, 1.));\n\nfloat roofSlope(vec2 p) {\n    p.x = abs(p.x);\n    return dot(p.xy, slope);\n}\n\nvec3 blduv = vec3(0.);\n\nfloat bld(vec3 p, float flr) {\n    float h = flr * 3. + 1.;\n    float bbox = box3(p, vec3(7., h + 3., 32.));\n    \n    if (bbox > 1.)\n        return bbox;\n    \n    float d = abs(p.x) - 5.;\n    vec3 uv = vec3(p.zy, 0.);\n    float pzwall = abs(p.z) - 30.;\n \n    if (d < pzwall) {\n        d = pzwall;\n        uv = vec3(p.xy, 1.);\n    }\n\n    vec3 pblk = p;\n    pblk.y += .8;\n    pblk.y = rep1(pblk.y, 3.);\n    pblk.z = rep1(pblk.z-3.75*2., 15.);\n    pblk.z = abs(pblk.z)-1.875;\n    float wblk = box3(pblk, vec3(5.9, .7, 1.45));\n    wblk = max(wblk, -box2(pblk.yz+vec2(.6,.0), vec2(.2, 1.3)));\n    wblk = max(wblk, -box2(vec2(pblk.y-.2,rep1(pblk.z, .21)), vec2(.4, .1)));\n    wblk = max(wblk, -box3(pblk-vec3(0.,.3,.0), vec3(5.7, .6, 1.45)));\n    wblk = max(wblk, max(-p.y + 3., - h + p.y + 1.5));\n    wblk = max(wblk, abs(p.z) - 20.);\n    //wbld = min(wbld, wblk);\n    wmetal = min(wmetal, wblk);\n\n    \n    d = max(d, p.y - h);\n    \n    if (wbld > d) {\n        if (d < 1.) {\n            const vec2 window_spacing = vec2(3.75, 3.);\n            //d = max(d, -box2(rep2(uv.xy - vec2(1.25, .75), window_spacing), window_size));\n            //d = fOpGroove(d, box2(rep2(uv.xy - vec2(1.25+1.875, .75), window_spacing), vec2(.01)), .2, .75);\n            d = fOpGroove(d, box2(rep2(uv.xy - vec2(0., .75), window_spacing), vec2(.01)), .2, .75);\n        }\n\n        wbld = d;\n        blduv = uv;\n    }\n\n    vec3 pm = p;\n    pm.x = abs(pm.x);\n    pm.x -= 5.15;\n\n    pm.z = rep1(pm.z, 20.);\n    wmetal = min(wmetal, max(bbox, max(p.y - h + .5, length(pm.xz) - .05)));\n\t\n    vec2 proof = p.xy-vec2(0., h+3.5);\n    float roof = roofSlope(proof);\n    proof.x = p.z; proof.y -= 17.5;\n    roof = max(roof, roofSlope(proof));\n    roof += .02 * sin(p.z*30.);\n    \n    roof = max(roof, - p.y + h - .3);\n    proof.x = abs(p.x) - 3.7;\n    proof.y = rep1(p.z, 15.);\n    roof = min(roof, max(box2(proof, vec2(.5, .2)), p.y - h - 2.5));\n    roof = max(roof, abs(p.z) - 31.3);\n    \n    wmetal = min(wmetal, roof);\n    \n    return wbld;\n}\n\nfloat wtrunk = 1e6;\nfloat wfoliage = 1e6;\n\nfloat tree(vec3 p, float kh) {\n    //wtrunk = length(p.xz) - .15; return;\n    \n    return length(p*vec3(.7,kh,.7) + vec3(0.,-2.,0.)) - 2.;//p.y - 13.;\n    //wtrunk = max(length(p.xz) - .15, bnd);\n    //wfoliage = max(max(length(p.xz) - 2., nz3un(p*.2).r-.5 + nz3un(p*.03).r-.3), bnd);\n}\n\nmat2 rm;\n\nvec3 pmor(vec3 p) {\n    return vec3(rm*p.xz,p.y).xzy-vec3(50.,0.,-70.);\n}\n\nfloat roadmask(vec3 p) {\n    float d = box3(p-vec3(0.,0.,0.), vec3(4., 1., 100.));\n    //d = smin(d, box3(p.xz-vec2(54.,0., 0.), vec3(50., 1., 2.)), .4);\n    d = smin(d, box3(p-vec3(54.,.2,0.), vec3(50., 1., 2.)), 1.);\n    d = smin(d, box3(pmor(p)+vec3(0.,.2,0.), vec3(500., 1., 8.)), 10.);\n    \n    // pedestrian\n    d = smin(d, box3(p-vec3(9.,.2,0.), vec3(1.5, 1., 100.)), 1.5);\n    return d;\n}\n\nvec4 debug = vec4(1e6);\n\nfloat w(vec3 p) {\n    //wgnd = p.y + .5 * nz2un(p.xz*.1).r;\n    wgnd = wbld = wmetal = wroad = wtrunk = wfoliage = wcstr = wcstr1 = wglass = 1e6;\n    \n    wgnd = p.y - .4;\n    \n    if (wgnd < .4) {\n        vec3 pwind = p + .2*sin(p*.4 + t*1.7);\n        float h = .7 * nz2un(pwind.xz*.05).r;\n        h += 3. * nz2un(p.xz*.003).r;\n        wgnd += .2 * (1. - h);\n    }\n    \n    // Roads\n    {\n        wroad = -roadmask(p - vec3(0., 1.2, 0.));\n    }\n\n    // trees distances\n    const float max_tree_height = 15.;\n    float tree_dist_estimate = p.y - max_tree_height;\n    if (tree_dist_estimate > 1.) {\n        wfoliage = min(wfoliage, tree_dist_estimate);\n    } else {\n        vec3 tree_p = p;\n        vec2 tree_spacing = vec2(10.);//10.);\n        vec2 tree_cell = floor(tree_p.xz / tree_spacing);\n        vec4 tree_cell_hash = nz2(tree_cell);\n        \n        // get tree_p local to cell\n        tree_p.xz = rep2(tree_p.xz, tree_spacing);\n        \n        // cell overshoot-fighting imaginary bounding box\n        wfoliage = min(wfoliage, -box2(tree_p.xz, tree_spacing/2.+1.));\n        \n        // apply random offset so that trees aren't spaced too regularly\n        vec2 tree_offset = (tree_cell_hash.xy-.5)*(tree_spacing * .5 - 1.);\n        //tree_offset = vec2(0.);\n        tree_p.xz += tree_offset;\n\n        // cut out trees on roads etc\n        float treemask = min(roadmask(vec3(tree_cell * tree_spacing + tree_spacing*.5 - tree_offset, 0.).xzy), length(p.xz) - 32.);\n        if (treemask > 0.) {\n            float treebnd = tree(tree_p, .2+.3 * tree_cell_hash.z);\n            if (treebnd < 1.) {\n            \t// lol wind\n            \tvec3 pwind = p + .7*sin(p*.1 + t*.7);\n            \t// compute distance to tree geometry\n        \t\twfoliage = .7 * (nz3un(pwind*.2).r-.5 + 2. * nz3un(pwind*.03).r-.3) + treebnd;\n            }\n        }\n        \n        debug.x = wfoliage;\n        debug.y = tree_cell_hash.w;\n        debug.z = step(0., treemask);\n       \t//else wfoliage = .5 - treemask;\n    }\n\n    // Construction site\n    {\n        vec3 ps = p + vec3(30.,0.,0.);\n        wcstr = min(ps.y, -box2(ps.xz, vec2(20.)));\n        \n        wcstr1 = box2(ps.xz, vec2(13., 8.));\n        \n        if (wcstr1 < 1.) {\n            vec2 ccell = floor(p.xz/vec2(3., 3.));\n            vec4 cellhash = nz2(ccell);\n            float flr = floor(p.y / 3.);\n            float t0 = floor(t*12.)/12.;\n            t0 -= cellhash.x;\n            //t0 *= 3.;\n        \n\t        //float wcstrbb = box3(ps, vec3(13., 1. + 3. * t0, 8.));\n        \t//float wcstrbb = box3(ps, vec3(13., 1. + 3. * t0, 8.));\n            \n            float floors = max(ps.y - 3.* t0 + 9., abs(rep1(p.y,3.))-.1);\n            float columns = max(ps.y - floor(t0)*3., box2(rep2(ps.xz, vec2(5.)), vec2(.2)));\n            \n            wglass = max(ps.y - floor(t0)*3. + 16., max(-box2(ps.xz, vec2(13., 8.)), box2(ps.xz, vec2(13., 8.)+.3)));\n\n        \twcstr1 = max(wcstr1, min(floors, columns));\n        }\n    }\n    \n    // poles\n    {\n        vec3 ppole = p;\n        ppole.x -= 6.;\n        ppole.z = rep1(ppole.z, 45.);\n        wmetal = min(wmetal, max(ppole.y - 8., length(ppole.xz) - .09));\n    }\n    \n        \n    // Buildings\n    {\n        vec3 pb = p;\n    \tpb.z = abs(pb.z);\n    \tpb -= vec3(25., 0., 44.);\n    \twbld = bld(pb, 4.);\n        \n        p = pmor(p).zyx;\n        \n        pb = p;\n        pb.x += 35.;\n        //pb.x = abs(pb.x)-35.;\n        //pb.z = rep1(pb.z, 80.);\n        pb.z += 110.;\n        pb.z = abs(pb.z);\n        pb.z -= 40.;\n       \twbld = min(wbld, bld(pb, 4.));\n        \n        pb = p.zyx;\n        pb.x = abs(pb.x);\n        pb.x -= 20.;\n        pb.z += 65.;\n        wbld = min(wbld, bld(pb, 4.));\n    }\n\n    \n    return wd =\n        min(wglass,\n        min(wcstr1,\n    \tmax(wcstr,\n        min(wfoliage,\n        min(wtrunk,\n        min(wmetal,\n        max(wroad,\n        min(wbld, wgnd))))))));\n}\n\nvec3 wn(vec3 p) {\n    return normalize(vec3(\n        w(p+E.yxx) - w(p-E.yxx),\n        w(p+E.xyx) - w(p-E.xyx),\n        w(p+E.xxy) - w(p-E.xxy)\n    ));\n}\n\nfloat tr(vec3 o, vec3 d, float l, float L) {\n    for (int i = 0; i < 120; ++i) {\n        float dd = w(o + d * l);\n        l += dd;\n        if (dd < .001*l || l > L) break;\n    }\n    return l;\n}\n\n\n//vec3 ld = normalize(vec3(1.,.3,.3));\nvec3 ld = normalize(vec3(-1.,.4,1.9));\n//vec3 lc = 2. * vec3(.8,.7,.6);\n//vec3 lc = 2. * vec3(.9,.4,.01);\n//vec3 lc = 2. * vec3(.7,.4,.3);\nvec3 lc = 2. * vec3(.7,.5,.2);\n//vec3 sky = vec3(.2,.4,.8);\n\nvec3 sky(vec3 d) {\n    vec3 skyc = vec3(.3,.5,.8);\n    //vec3 skyc = exp(-vec3(5.8e-1, 13.5e-1, 33.1e-1)*.01);\n    /*\n    if (d.y > .0) {\n        float l = 6000. / d.y;\n        vec2 p = d.xz * l;\n        skyc = mix(skyc, vec3(1.), nz2(p*.0001).r);\n    }*/\n    \n    vec3 air = mix(vec3(.3), skyc, smoothstep(-.2, .23, d.y))\n               + lc * pow(max(0., dot(d,ld)), 10.);\n    return air;\n}\n\nvec3 dbgDist(float d) { return step(.05/*step(.1,d)*/, fract(d)) * vec3(\n    1., smoothstep(0., 2., d), smoothstep(2., 4., d));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord/iResolution.xy * 2. - 1.;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    rm = Rm(.7);\n    t = iTime;\n\n    vec3 O = vec3(40., 30., 40.);\n    //O = vec3(2., 2., 4.);\n    //O = vec3(2., 2., 24.);\n    //O = vec3(8., 2., -41.+30.*sin(t));\n    vec3 D = normalize(vec3(uv, -2.));\n    \n    t = mod(t, 30.);\n    O += 1. * (vec3(1.) + sin(vec3(-.9,.8,-.7)*t));\n    //D.yz *= Rm(.6-.13*sin(t*.4));\n    //D.xz *= Rm(.8+.01*sin(t*.5));\n    \n    vec2 mouse = -iMouse.xy / iResolution.xy * 3.;\n    mouse.x *= 4.;\n    //mouse *= iMouse.zw/ iResolution.xy;\n    mouse.x += 1.;\n    mouse.y += 1.;\n    mouse *= step(1., iMouse.z);//w/ iResolution.xy;\n    \n    //mouse.xy += vec2(4.5,-.7);\n    //mouse.xy += vec2(3.5,-.7);\n    \n    D.yz *= Rm(.2+mouse.y-.13*sin(t*.4));\n    D.xz *= Rm(.8+mouse.x+.01*sin(t*.5));\n\n    vec3 C = vec3(0.), aC = vec3(1.);\n    \n    for (int i = 0; i < 2; ++i) {\n        vec3 skyc = sky(D);\n        vec3 c = vec3(0.);\n\n        float L = 200.;\n        float l = tr(O, D, 0., L);\n        \n        if (l > L) {\n            l = L;\n            /*\n            if (D.y > 0.) {\n                l = 2000. / D.y;\n                vec2 p = D.xz * l;\n                c = vec3(p, 0.);//vec3(1.) * nz2(p*.01).r;\n                //c = vec3(0., 1., 0.);\n            }*/\n            //C += aC * skyc;\n            C += aC * mix(skyc, c, exp(-2. * l/L));\n            \n            break;\n        }\n\n        vec3 p = O + D * l;\n\n        //debug.b = wd;\n        //vec3 dist = vec3(fract(debug.r), fract(debug.r/2.), fract(debug.r/4.));\n        //fragColor = vec4(fract(debug)); return;\n        //fragColor = vec4(vec3(dbgDist(min(wfoliage, wtrunk)).xy, debug.b), 0.); return;\n\n        vec3 n = wn(p);\n\n        vec3 ma = vec3(1.,0.,1.);\n        vec4 ms = vec4(0.);\n\n        \n        if (wd == wgnd || wd == wfoliage) {\n            ma = .6 * vec3(.5, .9, .14);\n            ms = vec4(.3 * vec3(.8, .9, .4), 20.);\n        } else if (wd == wbld) {\n\n            //blduv.x -= .2;\n            blduv.y -= .75;\n\n            if (blduv.y < .2) {\n                ma = mix(vec3(.5, .2, .2), vec3(.7, .6, .5), smoothstep(.6, .9, nz2un(blduv.xy*.02).z));\n            } else {            \n                vec2 section = rep2(blduv.xy, vec2(3.75, 3.));\n\n                //ma = vec3(section, dbgDist(section.x));\n                //ma = vec3(dbgDist(section.x));\n\n                if (section.y > .75 || box2(section, vec2(.8)) < 0.) {\n                    ma = vec3(1.);\n\n                    if (box2(vec2(abs(section.x) - .4, section.y), vec2(.33, .67)) < .0) {\n                        ma = vec3(.2) * smoothstep(.6, .9, nz2un(blduv.xy*.01).r);\n                        ms = vec4(vec3(.3), 90.);\n                    }\n\n                } else {\n                    ma = vec3(.4, .7, .4);\n                    ma *= .8 + .1 * smoothstep(.9, .6, nz2un(blduv.xy*.02).z);\n                    ma *= mix(1., .5, .5 * (1. + sin(section.x*32.)) * step(section.y, -.75) * step(abs(section.x), .75));\n                }\n            }\n\n        } else if (wd == wmetal) {\n            ma = vec3(.5, .5, .6);\n            ms = vec4(vec3(1.), 80.);\n        } else if (wd == wroad) {\n            ma = vec3(.5) * (.6 + .4 * smoothstep(.2, .8, .6 * nz2(p.xz*vec2(2., .3)).b + .2 *nz2(p.xz*7.).z));\n        } else if (wd == wcstr || wd == wcstr1) {\n            ma = vec3(.4) * (nz3un(p/45.).r + nz3un(p/12.).r);\n        } else if (wd == wtrunk) {\n            ma = vec3(1.) * step(.5, nz3un(p*vec3(.2,1.,.2)).r);\n        } else if (wd == wglass) {\n            ma = vec3(.02, .1, .2);\n            ms = vec4(vec3(.6), 90.);\n            vec2 guv = fract((mix(p.xy, p.zy, step(n.z, n.x))+vec2(2., 1.))/3.);\n            ms *= step(.03, guv.x) * step(.03, guv.y);\n        }\n\n        c += ma * skyc *.3 *  max(0., dot(reflect(vec3(0.,1.,0.), ld), n));\n\n        float shadow = step(50., tr(p, ld, .1, 50.));\n        c += ma * lc * max(0., dot(ld, n)) * shadow;\n        if (ms.w > 0.) {\n            c += ms.rgb * lc * pow(max(0., dot(normalize(ld-D), n)), ms.w) * shadow;\n        }\n\n        //c = mix(skyc, C, exp(-2. * l/L));\n\n        C += aC * mix(skyc, c, exp(-2. * l/L));\n        \n        if (ms.w > 80.) {\n            aC *= ms.rgb;\n            D = reflect(D, n);\n            O = p + D * .1;\n            continue;\n        }\n        \n        break;\n    }\n    \n    fragColor = vec4(sqrt(C),1.0);\n}","name":"Image","description":"","type":"image"}]}