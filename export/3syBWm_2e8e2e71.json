{"ver":"0.1","info":{"id":"3syBWm","date":"1608498909","viewed":51,"name":"raytracer_basic_light","username":"Commander_Asdasd","description":"Just implementing raytracer basing on Gabriel Gambetta book code\nhttps://www.gabrielgambetta.com/computer-graphics-from-scratch/introduction.html","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["raytracer"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n\n#ifdef GL_ES\nprecision highp float;\n#endif\n\n#define FLT_MAX 3.402823466e+38\n#define AMBL 0\n#define POINTL 1\n#define DIRL 2\n\n\n\nuniform float time; //1\nuniform vec2 mouse;\nuniform vec2 resolution;\n\n\nstruct Sphere {\n    vec3 center;\n    float radius;\n    vec3 color;\n    float specular;\n};\n\nstruct Light { // zkid3b light structure\n    int type;\n    float intensity;\n    vec3 position;\n    vec3 direction;\n};\n\nstruct Scene {\n\tSphere spheres[3];\n\tvec3 color_background;\n    Light lights[3];\n} main_scene;\n\n\n\n\nvec2 intersectRaySphere(vec3 O, vec3 D, Sphere sphere) {\n\tfloat t1;\n\tfloat t2;\n\tvec3 C = sphere.center;\n\tfloat r = sphere.radius;\n\tvec3 OC = O - C;\n\tfloat k1 = dot(D,D);\n\tfloat k2 = 2. * dot(OC, D);\n\tfloat k3 = dot(OC,OC) - r * r;\n\tfloat discriminant = k2 * k2 - 4. * k1 * k3;\n\tif (discriminant < 0.) {\n\t\treturn vec2(FLT_MAX, FLT_MAX);\n\t}\n\tt1 = (-k2 + sqrt(discriminant)) / (2. * k1);\n\tt2 = (-k2 - sqrt(discriminant)) / (2. * k1);\n\n\treturn vec2(t1, t2);\n}\n\n\nfloat ComputeLighting(vec3 P, vec3 N, vec3 V, float s) { //zkid3a\n      float i = 0.;\n      for (int light_count = 0; light_count < main_scene.lights.length(); light_count++) {\n          Light light_current = main_scene.lights[light_count];\n          if (light_current.type == 0) {\n            i += light_current.intensity;\n          }\n          vec3 L;\n          if (light_current.type == 1) {\n            L = light_current.position - P;\n          }\n          if (light_current.type == 2) {\n            L = light_current.direction;\n          }\n          // zid4 diffuse \n           float n_dot_l = dot(N, L);\n            if(n_dot_l > 0.) {\n                i += light_current.intensity*n_dot_l/(length(N)*length(L));\n          }\n          // Specular\n            if(s != -1.) {\n                vec3 R = 2.* N *dot(N, L) - L; //zkid6 light disperced - change 2 to 1\n                float r_dot_v = dot(R, V);\n                if(r_dot_v > 0.) {\n                    i += light_current.intensity*pow(r_dot_v/(length(R)*length(V)), s);\n                }\n                //r_dot_v = 0.;\n            }\n          \n      }\n      return i;\n}\n\nvec3 TraceRay(vec3 origin, vec3 direction, float t_min, float t_max) {\n\n\tfloat t_closest = FLT_MAX; //zkid1c changed this from 0 to FLT_MAX\n\tbool sphere_found = false; // zkid1d #A: forgot change switcher when found sphere \n    Sphere closest_sphere;\n    vec3 color_val;\n\n\tfor (int sphere = 0; sphere < main_scene.spheres.length(); sphere++) { // zkid1b\n\t\tclosest_sphere = main_scene.spheres[sphere];\n\t\tvec2 intersections = intersectRaySphere(origin, direction, closest_sphere); //zkid5 disable\n\t\tif (t_min < intersections[0] && intersections[0] < t_max &&  intersections[0] < t_closest) {\n\t\t\tt_closest = intersections[0];\t\t\t\n\t\t\tclosest_sphere = main_scene.spheres[sphere];\n            sphere_found = true; //zkid1d1\n\t\t} \n        if (t_min < intersections[1] && intersections[1] < t_max &&  intersections[1] < t_closest) {\n\t\t\tt_closest = intersections[1];\t\t\t\n\t\t\tclosest_sphere = main_scene.spheres[sphere];\n            sphere_found = true; //zkid1d2\n\t\t}\n    }\n    if (!sphere_found) {\n\t   return main_scene.color_background; // zkid1 #Q: debug just black screen, no balls. Change it here chages color\n\t}\n\tvec3 P = origin + t_closest * direction;\n    vec3 N = P - closest_sphere.center;\n    N = N / length(N);\n    float light_contrib = ComputeLighting(P, N, -direction,  closest_sphere.specular);\n\tcolor_val = closest_sphere.color + light_contrib; //zkid1a moving this into for-cycle (1b) not gives anything\n\n    return color_val; // zkid1c\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord / iResolution.xy;\n    uv.x *= iResolution.x/iResolution.y; \n    Sphere sphere1 = Sphere(vec3(.5, .5, 0.5), .65, vec3(0., 255., 255.), 5.); // zkid2a no sphere recreation\n    Sphere sphere2 = Sphere(vec3(.9, -.5, .5), 1., vec3(.9, .4, .4), 10.);\n    \n    Light light3 = Light(AMBL, 0.1, vec3(0.), vec3(0.));\n    Light light1 = Light(POINTL, .3, vec3(0.4,2.,.5), vec3(1.));\n    Light light2 = Light(DIRL, .2, vec3(1.,1.,.5), vec3(1.));\n\n    //uv *= 3.;\n    //uv = fract(uv);\n    vec3 D = vec3(uv, 1.);\n    vec3 O = vec3(0.);\n    \n    //Sphere sphere2 = Sphere(vec3(0.,2.,1.), 1., vec3(1.,1.,1.));\n    //Sphere sphere3 = Sphere(vec3(5), 1., vec3(1.,0.,0.));\n\n    \n    // \n    main_scene.color_background = vec3(.5, .1, 0.5);\n    main_scene.spheres[0] = sphere1;\n    main_scene.spheres[1] = sphere2; \n    main_scene.lights[0] = light1; //zkid3  #Q why light not works?  #A: it works now\n    main_scene.lights[1] = light2;\n    main_scene.lights[2] = light3;\n\n    //main_scene.spheres[0].center = vec3(sin(mouse.x),.3,.5);\n    //main_scene.spheres[1] = sphere2;\n    //main_scene.spheres[2] = sphere3;\n    \n    // Time varying pixel color\n    vec3 color = TraceRay(O, D, 1., FLT_MAX);\n    //main_scene.spheres[0].center = vec3(mouse.x,.3,.5); // zkid2 .center = vec3(sin(time));\n    //color = color;\n    //color = fract(color);\n\n    // Output to screen    \n\tfragColor = vec4(color, 1.);\n}","name":"Image","description":"","type":"image"}]}