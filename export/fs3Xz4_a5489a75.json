{"ver":"0.1","info":{"id":"fs3Xz4","date":"1632710075","viewed":151,"name":"3d rasterizer","username":"icantcomeupwithausername","description":"3d rasterizer with depth sorting, lighting, and perspective projection","likes":9,"published":1,"flags":0,"usePreview":0,"tags":["phong","rasterizer"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define clearColor vec3(0.407843137,0.690196078,0.847058824)\n#define vertexCount 36\n\n//projection variables\n#define pi acos(-1.0)\n#define fov 80.0\n\n//light direction\n#define lightDirection vec3(0.0,0.0,1.0)\n\n//-------//\n//structs//\n//-------//\n\nstruct Vertex{\n    vec3 position, normal;\n};\n\nstruct Material{\n    vec3 color;\n    float shininess;\n};\n\nstruct Varyings{\n    vec4 vt;\n    vec3 surfacePosition;\n};\n\n//----------------------//\n//verticies and material//\n//----------------------//\n\n//define material\nconst Material material = Material(vec3(0.4),800.0);\n\n//define verticies\nVertex verticies[vertexCount];\n\nvoid initVerticies(){\n\t//face 1\n\tverticies[0] = Vertex(vec3(-0.5,-0.5,0.5),vec3(0.0,0.0,1.0)),\n\tverticies[1] = Vertex(vec3(0.5,-0.5,0.5),vec3(0.0,0.0,1.0)),\n\tverticies[2] = Vertex(vec3(0.5,0.5,0.5),vec3(0.0,0.0,1.0)),\n\tverticies[3] = Vertex(vec3(0.5,0.5,0.5),vec3(0.0,0.0,1.0)),\n\tverticies[4] = Vertex(vec3(-0.5,0.5,0.5),vec3(0.0,0.0,1.0)),\n\tverticies[5] = Vertex(vec3(-0.5,-0.5,0.5),vec3(0.0,0.0,1.0)),\n\n\t//face 2\n\tverticies[6] = Vertex(vec3(-0.5,-0.5,-0.5),vec3(0.0,0.0,-1.0));\n\tverticies[7] = Vertex(vec3(-0.5,0.5,-0.5),vec3(0.0,0.0,-1.0));\n\tverticies[8] = Vertex(vec3(0.5,0.5,-0.5),vec3(0.0,0.0,-1.0));\n\tverticies[9] = Vertex(vec3(0.5,0.5,-0.5),vec3(0.0,0.0,-1.0));\n\tverticies[10] = Vertex(vec3(0.5,-0.5,-0.5),vec3(0.0,0.0,-1.0));\n\tverticies[11] = Vertex(vec3(-0.5,-0.5,-0.5),vec3(0.0,0.0,-1.0));\n\n\t//face 3\n\tverticies[12] = Vertex(vec3(0.5,-0.5,-0.5),vec3(1.0,0.0,0.0));\n\tverticies[13] = Vertex(vec3(0.5,0.5,-0.5),vec3(1.0,0.0,0.0));\n\tverticies[14] = Vertex(vec3(0.5,0.5,0.5),vec3(1.0,0.0,0.0));\n\tverticies[15] = Vertex(vec3(0.5,0.5,0.5),vec3(1.0,0.0,0.0));\n\tverticies[16] = Vertex(vec3(0.5,-0.5,0.5),vec3(1.0,0.0,0.0));\n\tverticies[17] = Vertex(vec3(0.5,-0.5,-0.5),vec3(1.0,0.0,0.0));\n\n\t//face 4\n\tverticies[18] = Vertex(vec3(-0.5,-0.5,-0.5),vec3(-1.0,0.0,0.0));\n\tverticies[19] = Vertex(vec3(-0.5,-0.5,0.5),vec3(-1.0,0.0,0.0));\n\tverticies[20] = Vertex(vec3(-0.5,0.5,0.5),vec3(-1.0,0.0,0.0));\n\tverticies[21] = Vertex(vec3(-0.5,0.5,0.5),vec3(-1.0,0.0,0.0));\n\tverticies[22] = Vertex(vec3(-0.5,0.5,-0.5),vec3(-1.0,0.0,0.0));\n\tverticies[23] = Vertex(vec3(-0.5,-0.5,-0.5),vec3(-1.0,0.0,0.0));\n\n\t//face 5\n\tverticies[24] = Vertex(vec3(-0.5,0.5,-0.5),vec3(0.0,1.0,0.0));\n\tverticies[25] = Vertex(vec3(-0.5,0.5,0.5),vec3(0.0,1.0,0.0));\n\tverticies[26] = Vertex(vec3(0.5,0.5,0.5),vec3(0.0,1.0,0.0));\n\tverticies[27] = Vertex(vec3(0.5,0.5,0.5),vec3(0.0,1.0,0.0));\n\tverticies[28] = Vertex(vec3(0.5,0.5,-0.5),vec3(0.0,1.0,0.0));\n\tverticies[29] = Vertex(vec3(-0.5,0.5,-0.5),vec3(0.0,1.0,0.0));\n\n\t//face 6\n\tverticies[30] = Vertex(vec3(-0.5,-0.5,-0.5),vec3(0.0,-1.0,0.0));\n\tverticies[31] = Vertex(vec3(0.5,-0.5,-0.5),vec3(0.0,-1.0,0.0));\n\tverticies[32] = Vertex(vec3(0.5,-0.5,0.5),vec3(0.0,-1.0,0.0));\n\tverticies[33] = Vertex(vec3(0.5,-0.5,0.5),vec3(0.0,-1.0,0.0));\n\tverticies[34] = Vertex(vec3(-0.5,-0.5,0.5),vec3(0.0,-1.0,0.0));\n\tverticies[35] = Vertex(vec3(-0.5,-0.5,-0.5),vec3(0.0,-1.0,0.0));\n}\n\n//--------------------//\n//projection functions//\n//--------------------//\n\n//used to project the verticies\nmat4 perspective(float aspect){\n    float ft = tan(pi*0.5-0.5*radians(fov));\n    float r = 1.0/(0.1-9e20);\n    \n    return mat4(ft/aspect,0.0,0.0,0.0,\n                0.0,ft,0.0,0.0,\n                0.0,0.0,(0.1+9e20)*r,-1.0,\n                0.0,0.0,0.1*9e20*r*2.0,0.0);\n}\n\n//used to translate the verticies \nmat4 translate(vec3 pos){\n    return mat4(1.0,0.0,0.0,pos.x,\n                0.0,1.0,0.0,pos.y,\n                0.0,0.0,1.0,pos.z,\n                0.0,0.0,0.0,1.0);\n}\n\n//rotation matricies\nmat4 rotateY(float rotation){\n\tfloat ysine = sin(rotation);\n\tfloat ycos = cos(rotation);\n\tfloat yoc = 1.0-ycos;\n\treturn mat4(ycos,0.0,ysine,0.0,\n\t\t\t\t0.0,yoc+ycos,0.0,0.0,\n\t\t\t\t-ysine,0.0,ycos,0.0,\n\t\t\t\t0.0,0.0,0.0,1.0);\n}\n\nmat4 rotateX(float rotation){\n\tfloat xsine = sin(rotation);\n\tfloat xcos = cos(rotation);\n\tfloat xoc = 1.0-xcos;\n\treturn mat4(xoc+xcos,0.0,0.0,0.0,\n\t\t\t    0.0,xcos,-xsine,0.0,\n\t\t\t\t0.0,xsine,xcos,0.0,\n\t\t\t\t0.0,0.0,0.0,1.0);\n}\n\n//-------------//\n//interpolation//\n//-------------//\n\nvec3 interpolate(vec3 v1,vec3 v2,vec3 v3,vec3 a,vec3 b,vec3 c,vec2 uv){\n    float h = ((v2.y-v3.y)*(v1.x-v3.x)+(v3.x-v2.x)*(v1.y-v3.y));\n    float weight1 = ((v2.y-v3.y)*(uv.x-v3.x)+(v3.x-v2.x)*(uv.y-v3.y))/h;\n    float weight2 = ((v3.y-v1.y)*(uv.x-v3.x)+(v1.x-v3.x)*(uv.y-v3.y))/h;\n    float weight3 = 1.0-weight1-weight2;\n\n    return a*weight1+b*weight2+c*weight3/(weight1+weight2+weight3);\n}\n\n//---------//\n//edge test//\n//---------//\n\nfloat edge(vec2 a, vec3 b, vec2 c){\n    return (c.x-a.x)*(b.y-a.y)-(c.y-a.y)*(b.x-a.x);\n}\n\n//-------//\n//shaders//\n//-------//\n\nVaryings vertexShader(Vertex vertex, mat4 projection, mat4 rotation){\n    //tranform vertex\n    vec4 vt = vec4(vertex.position,1.0)*projection;\n    \n    //calculate world position of surface\n    vec3 surfacePosition = (vec4(vertex.position,1.0)*rotation).xyz;\n    \n    return Varyings(vt,surfacePosition);\n}\n\nvec3 fragmentShader(vec3 normal, vec3 surfaceToCamera){\n    //normalize normal\n    normal = normalize(normal);\n    \n    //normalize surface to camera vector\n    surfaceToCamera = normalize(surfaceToCamera);\n    \n    //calculate half vector for specular calculation\n    vec3 halfv = normalize(lightDirection+surfaceToCamera);\n    \n    //calculate specular\n    float specular = clamp(pow(dot(normal, halfv),material.shininess),0.0,1.0);\n    \n    //calculate diffuse\n    float diffuse = clamp(dot(lightDirection,normal),0.0,1.0);\n    \n    return material.color*diffuse+specular;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    initVerticies();\n\n    //normalize pixel coordianates\n    vec2 uv = fragCoord/iResolution.xy*2.0-1.0;\n    \n    //camera position\n    vec3 cameraPos = vec3(0.0,0.0,7.0+sin(-iTime*0.5)*2.0);\n    \n    //output color\n    vec3 col = clearColor;\n    \n    //variable to store depth\n    float previousDepth = 9e20;\n    \n    //rasterization starts here\n    for(int i=0;i<vertexCount;i+=3){\n        Vertex vertexA = verticies[i];\n        Vertex vertexB = verticies[i+1];\n        Vertex vertexC = verticies[i+2];\n        \n        //assemble rotation matrix\n        mat4 rotationMatrix = rotateY(-iTime*0.5*0.5)*rotateX(-iTime*0.5);\n        \n        //assemble translation matrix\n        mat4 translationMatrix = translate(cameraPos);\n        \n        //assemble perspective matrix\n        mat4 perspectiveMatrix = perspective(iResolution.x/iResolution.y);\n        \n        //assemble projection matrix\n        mat4 projectionMatrix = rotationMatrix*inverse(translationMatrix)*perspectiveMatrix;\n        \n        //transform verticies\n        Varyings ta = vertexShader(vertexA,projectionMatrix,rotationMatrix);\n        Varyings tb = vertexShader(vertexB,projectionMatrix,rotationMatrix);\n        Varyings tc = vertexShader(vertexC,projectionMatrix,rotationMatrix);\n        \n        //divide transformed verticies by w\n        vec3 va = (ta.vt/ta.vt.w).xyz;\n        vec3 vb = (tb.vt/tb.vt.w).xyz;\n        vec3 vc = (tc.vt/tc.vt.w).xyz;\n        \n        //test if pixel is in triangle\n        float tsa = edge(vb.xy,vc,uv);\n        float tsb = edge(vc.xy,va,uv);\n        float tsc = edge(va.xy,vb,uv);\n        \n        vec3 normal = vertexA.normal*mat3(inverse(transpose(rotationMatrix)));\n        \n        if(((tsa>=0.0)==(tsb>=0.0))&&((tsb>=0.0)==(tsc>=0.0))&&(dot(normal,vec3(0.0,0.0,1.0))>0.0)){\n            //calculate area\n            float area = edge(va.xy,vb,vc.xy);\n            \n            //divide by area\n            tsa/=area;\n            tsb/=area;\n            tsc/=area;\n            \n            //calculate pixel depth\n            float depth = va.z*tsa+vb.z*tsb+vc.z*tsc;\n            \n            //if depth is smaller than the stored depth then triangle is visible\n            if(depth<previousDepth){                \n                //interpolate surface position\n                vec3 surfacePosition = interpolate(va,vb,vc,ta.surfacePosition,tb.surfacePosition,tc.surfacePosition,uv);\n                \n                //calculate surface to camera direction\n                vec3 surfaceToCamera = cameraPos-surfacePosition;\n                \n                //shade pixel\n                col = fragmentShader(normal, surfaceToCamera);\n                \n                //store the depth\n                previousDepth = depth;\n            }    \n        }        \n    }\n\n    //output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}