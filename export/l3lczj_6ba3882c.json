{"ver":"0.1","info":{"id":"l3lczj","date":"1726446466","viewed":25,"name":"Rubik formulas","username":"Elsio","description":"Sempre quis um jeito de guardar e visualizar essas formulas de um jeito menos chato que usando letras.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["cube","magic","rubiks","cubo"],"hasliked":0,"parentid":"43XyzS","parentname":"Rubik's v2"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// playlist mecanics: https://www.shadertoy.com/playlist/mcSSDw\n\n#define _R  3.\n#define _L  -6.\n#define _U  -5.\n#define _B  1.\n#define _D  2.\n#define _F  -4.\n#define _Rl -3.\n#define _Ll 6.\n#define _Ul 5. \n#define _Bl -1.\n#define _Dl -2.\n#define _Fl 4.\n\n#define rot(a) mat2(cos(1.5708 * (a + vec4(0, 7, 21, 0))))\n#define t iTime\n\nvec4 C;\n\n\n// https://jperm.net/algs/oh/oll\nfloat[] F = \n            // COLL case h1\n            // float[](0., 0., 0., _R, _U, _Rl, _U, _R, _Ul, _Rl, _U, _R, _U, _U, _Rl);\n            \n            // OLL case dot\n            //float[](0., 0., 0., 0., 0., _R, _U, _U, _R, _R, _F, _R, _Fl, _U, _U, _Rl, _F, _R, _Fl);\n            \n            // PLL case jb\n            //float[](0., 0., 0., 0., 0., _R, _U, _Rl, _Fl, _R, _U, _Rl, _Ul, _Rl, _F, _R, _R, _Ul, _Rl);\n            \n            // One-Handed OLL - 'Knight Move Shape'\n            float[](0., 0., 0., 0., 0., _F, _U, _R, _Ul, _R, _R, _Fl, _R, _U, _R, _Ul, _Rl);\n            \n\n\nvec3 cam(vec3 p){\n    p.xz *= rot(sin(t) * .05 - 2.3);\n    p.yz *= rot(cos(t) * .04 + .3);\n    p.yx *= rot(-.1);\n    return p;\n}\n\nfloat cube(vec3 p){\n    \n    float d1, d2, d3;\n    vec3 k, q, \n         m = abs(p);\n    \n    k = round(m - max(m - 1., 0.)) * sign(p),\n    q = (1. - sign(abs(m - max(m.x, max(m.y, m.z))))) * sign(p);\n        \n    d1 = length(p) - 1.42;\n    d2 = length(max(abs(p - k) - .26, 0.)) - .2;\n    d3 = length(max(abs(p - k - q * .18) - .29, 0.)) - .05;\n    C = vec4(q, d2 < d3);\n    \n    return min(d1, min(d2, d3));\n}\n\n\n\n\n\nfloat map(vec3 p) {\n    float i, n, s, d;\n    p = cam(p);\n    \n    for(int i; i < F.length(); i++){\n        n = F[i];\n        \n        s = sign(n);\n        n = abs(n);\n        d = n > 3.? n -= 3., 1. : -1.;\n        \n        vec3 S = step(.5, p * d) * s\n                 * smoothstep(.5, 0.,\n                     mod(t, float(F.length() - 4)) - float(i) / 2.);\n                 \n        n == 1. ? p.xy *= rot(S.z) : \n        n == 2. ? p.zx *= rot(S.y) : \n        n == 3. ? p.yz *= rot(S.x) : p.xy;\n    }\n    \n    return cube(p);\n}\n\nvoid mainImage(out vec4 o, vec2 u) {\n    vec3 r = iResolution,\n         p = vec3(0, 0, - 8), N,\n         D = normalize(vec3(u + u - r.xy, r.y / .3)),\n         e = vec3(0, 1e-3, 0);\n    \n    float dt, i, s = 1.;\n    \n    while(i++ < 80. && s > .01)\n        p += s * D * .5,\n        s = map(p);\n        \n    o = s < .01 // hit\n        ? N = vec3(map(p + e.yxx), map(p + e), map(p + e.xxy)) - s,\n          dt = max(0., dot(vec3(-1, 2, -3) / 3.74, N) / length(N)),\n               \n          // o.rgb = \n              (\n                  C.w > 0.      // correct cols\n                    ? vec4(1.3)\n                    : abs(C.z) == 1.                 \n                        ? vec4(0, C.z < 0., C.z > 0., 0) : // green, blue\n                        \n                      abs(C.x) == 1. \n                        ? C.x > 0.\n                            ? vec4(8, 4, 1, 0) / 6.\n                            : vec4(1, 0, 0, 0)           // orange, red\n\n                        : C.y > 0.\n                            ? vec4(1, 1, 0, 0) * 1.2     // yellow, white\n                            : vec4(1.5)\n\n              ) * (.5 - .1 * dt) // shadow\n                      + pow(dt, 2e2) * .3 // spec\n                      \n        : -D.yyyy * 2.2; // bg\n}","name":"Image","description":"","type":"image"}]}