{"ver":"0.1","info":{"id":"Xcj3WG","date":"1704572801","viewed":54,"name":"Arrow Tunnel","username":"gamerprime","description":"This was a cool piece that I created while playing around with \"funarrows\" https://www.shadertoy.com/view/lfsGWj. \n","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":" #define PI 3.1415926538\n\n//distance to scene\nfloat map(vec3 pos){\n\n    \n    vec3 q = pos; //input point copy\n    \n    q.z += iTime;\n    \n    //q.x += iTime /2.;\n    \n    //space repitition\n    q.y = mod(q.y,1.5) -.75; \n    q.x = mod(q.x,3.) - 1.5; \n    q.z = mod(q.z,1.) -.5;\n    \n    //make arrows!\n    q.x -=.5;\n    q.y +=.25;\n    float dist_arrow1 = makearrow(q,0.0);\n    \n    vec3 q2 = q;\n    q2.x += .5;\n    \n    float dist_arrow2 = makearrow(q2,PI);\n    \n    vec3 q3 = q2;\n    q3.x += .5;\n    \n    float dist_arrow3 = makearrow(q3,PI*3./2.);\n    \n    vec3 q4= q3;\n    q4.x -= 1.5;\n    \n    float dist_arrow4 = makearrow(q4,PI/2.);\n    \n    return min_dist(dist_arrow1,dist_arrow2,dist_arrow3,dist_arrow4);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord*2.0 - iResolution.xy)/iResolution.y;\n    vec2 mouse = (iMouse.xy * 2.0 - iResolution.xy)/iResolution.y;\n    float FOV = 1.0;\n\n    //initialization\n    vec3 rayorigin = vec3(0,0,-3.);\n    \n    vec3 raydirection = normalize(vec3(uv * FOV, 1));\n    \n    vec3 col = vec3(0);\n    \n    float dist_travelled = 0.;\n    \n    //raymarching\n    \n    int i;\n    for(i =0; i < 1000 ;++i ){\n    \n        vec3 pos = rayorigin + raydirection * dist_travelled * .15; //play with this variable and the one below it's fun\n    \n        pos.xy *= rot2D(dist_travelled*.12 +iTime*.25) ; //second variable to edit\n        \n        float dist = map(pos);\n        \n        dist_travelled += dist; //march the ray\n        \n        if (dist <.0001 ) {\n        break;\n       \n        }\n        if( dist_travelled > 500.){\n         fragColor = vec4(0,0,0,1);\n         return;\n         //break;\n            \n        }\n    }\n    \n            \n    col = vec3(dist_travelled *.02,dist_travelled *.03,dist_travelled *.04);\n    \n    col = palette(dist_travelled *.1 + float(i)*.005 + iTime*.3);\n    \n    fragColor = vec4(col,1);\n    \n    \n    \n    \n    \n    \n   \n\n\n\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"float min_dist(float d1,float d2,float d3,float d4){\n    if(d1<d2 && d1<d3 && d1 < d4)\n        return d1;\n    else if(d2<d3 && d2<d4)\n        return d2;\n    else if(d3<d4)\n        return d3;\n    else \n        return d4;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n\nmat2 rot2D(float angle){\n    float s = sin(angle);\n    float c = cos(angle);\n    return mat2(c,-s,s,c);\n}\n\nvec3 palette(float x){\n\n     vec3 a = vec3(0.058, 0.478, 1.008);\n     vec3 b = vec3(-0.242, 0.398, 0.398);\n     vec3 c = vec3(-0.204, 0.458, 0.530);\n     vec3 d = vec3(0.358, 1.728, 1.225);\n\n     return a + b *cos(5.8*(c*x+d));\n     \n     \n}\n     \nfloat sdPyramid( in vec3 p, in float h )\n{\n    float m2 = h*h + 0.25;\n    \n    // symmetry\n    p.xz = abs(p.xz);\n    p.xz = (p.z>p.x) ? p.zx : p.xz;\n    p.xz -= 0.5;\n\t\n    // project into face plane (2D)\n    vec3 q = vec3( p.z, h*p.y - 0.5*p.x, h*p.x + 0.5*p.y);\n   \n    float s = max(-q.x,0.0);\n    float t = clamp( (q.y-0.5*p.z)/(m2+0.25), 0.0, 1.0 );\n    \n    float a = m2*(q.x+s)*(q.x+s) + q.y*q.y;\n\tfloat b = m2*(q.x+0.5*t)*(q.x+0.5*t) + (q.y-m2*t)*(q.y-m2*t);\n    \n    float d2 = min(q.y,-q.x*m2-q.y*0.5) > 0.0 ? 0.0 : min(a,b);\n    \n    // recover 3D and scale, and add sign\n    return sqrt( (d2+q.z*q.z)/m2 ) * sign(max(q.z,-p.y));;\n}\n\n\nfloat makearrow(vec3 pos , float rotation){\n    \n    \n    pos.xy *= rot2D(rotation);\n    \n    float box_dist_1 = sdBox(pos, vec3(0.1)); //cube SDF\n    \n    vec3 pos2 = pos;\n    \n    pos2.y -=0.1;//reposition the pyramid SDF\n    \n    //to scale, multiply pos within signed distance call, then divide result by same number to remove artifacts.\n    float Pyramid_1 = sdPyramid(pos2*3., 1.)/3.; //tri SDF\n    \n    return min(box_dist_1,Pyramid_1);\n}","name":"Common","description":"","type":"common"}]}