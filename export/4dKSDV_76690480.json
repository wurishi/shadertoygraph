{"ver":"0.1","info":{"id":"4dKSDV","date":"1466704896","viewed":2204,"name":"2D trabeculum","username":"FabriceNeyret2","description":"Voronoi diagram are nice, but for CG use several goodies are welcome. \nHere, I show how to make an organic look (no sharp angle), i.e., trabeculum patterns. ","likes":45,"published":3,"flags":0,"usePreview":0,"tags":["procedural","voronoi","noise","worley","short","trabeculum"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// simplification of https://www.shadertoy.com/view/lt2GDt\n// used for 3D trabeculum here : https://www.shadertoy.com/view/MlB3Wt\n\n#define H(n) fract( 1e4 * sin( n.x+n.y/.7 +vec2(1,12.34) ) )\n\nvoid mainImage( out vec4 O, in vec2 U )\n{\n    vec2 R = iResolution.xy, p,c;\n    U = 5.* (U+U - R ) / R.y + iTime; \n    float l;\n    \n    O += 1e9-O;  // --- Worley noise: return O.xyz = sorted distance to first 3 nodes\n    for (int k=0; k<9; k++) // replace loops i,j: -1..1\n    { // windows Angle bug with ,, instead of {}\n                p = ceil(U) + vec2(k-k/3*3,k/3)-2., // cell id = floor(U)+vec2(i,j)\n                l = dot(c = H(p) + p-U , c);        // distance^2 to its node\n                  l < O.x  ? O.yz=O.xy, O.x=l       // ordered 3 min distances\n                : l < O.y  ? O.z =O.y , O.y=l \n                : l < O.z  ?            O.z=l : l;\n    }\n    O = 5.*sqrt(O); \n    \n    \n    // --- smooth distance to borders and nodes\n    \n // l = 1./(1./(O.y-O.x)+1./(O.z-O.x)); // Formula (c) Fabrice NEYRET - BSD3:mention author.\n // O += smoothstep(.0,.3, l-.5) -O;\n    O -= O.x;  O += 4.*( O.y/(O.y/O.z+1.) - .5 ) - O;  // simplified form\n}","name":"Image","description":"","type":"image"}]}