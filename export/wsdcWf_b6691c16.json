{"ver":"0.1","info":{"id":"wsdcWf","date":"1601919950","viewed":112,"name":"Traversable Julia Set","username":"Dominexis","description":"Fully traversable Julia set.\n\nUse the arrow keys to move side to side. Move W and S to zoom in and out respectively. Hit the spacebar to activate the hyper drive!\nClick somewhere with the mouse to set the C value to morph the fractal.","likes":2,"published":1,"flags":48,"usePreview":0,"tags":["fractal","traversable"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Initialize values\n    \n    vec2 center = texture(iChannel0, vec2(0.0, 0.0)).xy;\n    float zoom = pow(2.0, 1.0 - texture(iChannel0, vec2(0.0, 0.0)).z/5.0);\n    \n    vec2 z = ( 2.0*fragCoord - iResolution.xy )*zoom/iResolution.y + center;\n    vec2 c = texture(iChannel0, vec2(10.0/iResolution.x, 0.0)).xy;\n    \n    \n    \n    // Run iterations\n    \n    float iter = 0.0;\n    float iter_limit = 10000.0;\n    float bound = iter_limit;\n    \n    for( iter = 0.0; iter <= bound; iter++ )\n    {\n    \tz = vec2( z.x*z.x - z.y*z.y, 2.0*z.x*z.y ) + c;\n        bound = step( length(z), 2.0 )*iter_limit;\n    }\n    \n    \n    \n    // Assign pixel\n    \n    float outside = step( iter, iter_limit );\n    float inside = 1.0 - outside;\n    float color = step( fract(iter/10.0), 0.49 );\n    float shade = 1.0 - (length(z)-2.0)/8.0;\n    fragColor = vec4( outside*color*shade, outside*color*shade, outside*shade + inside*0.5, 1.0 );\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Initialize values\n    \n    vec2 center = texture(iChannel0, vec2(0.0, 0.0)).xy;\n    \n    float scroll = texture(iChannel0, vec2(0.0, 0.0)).z;\n    float zoom = pow(2.0, 1.0 - scroll/5.0);\n    \n    vec2 mouse = texture(iChannel0, vec2(10.0/iResolution.x, 0.0)).xy;\n    \n    float center_speed = 0.04;\n    float scroll_speed = 0.06;\n    \n    \n    \n    // Apply center offset\n    \n    vec2 center_offset = vec2( \n        center_speed*( texture( iChannel1, vec2( 39.0/256.0, 0.0 ) ).x )\n      - center_speed*( texture( iChannel1, vec2( 37.0/256.0, 0.0 ) ).x ), \n        center_speed*( texture( iChannel1, vec2( 38.0/256.0, 0.0 ) ).x )\n      - center_speed*( texture( iChannel1, vec2( 40.0/256.0, 0.0 ) ).x ) );\n    \n    center_offset /= ( 1.0 - step( length(center_offset), center_speed ) )*(sqrt(2.0) - 1.0) + 1.0;\n    center += center_offset*zoom*( texture( iChannel1, vec2( 32.0/256.0, 1.0 ) ).x + 1.0);\n    \n    \n    \n    // Apply scroll offset\n    \n    float scroll_offset = \n        scroll_speed*( texture( iChannel1, vec2( 87.0/256.0, 0.0 ) ).x )\n      - scroll_speed*( texture( iChannel1, vec2( 83.0/256.0, 0.0 ) ).x );\n    \n    scroll += scroll_offset*( texture( iChannel1, vec2( 32.0/256.0, 1.0 ) ).x + 1.0);\n    \n    \n    \n    // Set mouse position\n    \n    if( iMouse.z > 0.0 )\n    {\n    \tmouse = ( 2.0*iMouse.xy - iResolution.xy )*zoom/iResolution.y + center;\n    }\n    \n    \n    \n    // Write to buffer\n    \n    float set_1 = step( fragCoord.x, 5.0 );\n    float set_2 = 1.0 - set_1;\n    \n    fragColor = vec4( set_1*center + set_2*mouse, set_1*scroll, 1.0 );\n}","name":"Buffer A","description":"","type":"buffer"}]}