{"ver":"0.1","info":{"id":"XtXXzS","date":"1437899248","viewed":549,"name":"Light, Dark and Red","username":"predatiti","description":"Test !!! How big is number of sample on your PC ? For my : 15 fps - 32 sample - Nvidia GTX 560","likes":13,"published":1,"flags":0,"usePreview":0,"tags":["pathtracing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","previewfilepath":"/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[],"code":"const float t = 32.0;//nr. sample per pixel\n\n#define pi acos(-1.0)\n#define pi2 pi/2.0\n\nstruct Sphere\n{\n\tvec4 center_radius;\n\tint idmaterial;\n};\n\nstruct Box\n{\n    vec3 min, max;\n   int idmaterial;\n};\n    \nstruct Cylinder \n{\n    vec3 c;\n    float r,h;\n    int idmaterial;\n};\n\nBox box0;\nSphere sfere[4];\nBox boxe[15];\nCylinder cylinder[4];\n//Material material[6];\n\nvec3 light = vec3(0.0, 0.0, 0.0);\nvec3 cub, lcub, nrm, crm;\nvec2 uvCoord;\nvec2 p,rv2;\nvec2 randv2;\nfloat side = 1.0;\nfloat time;// = iTime;\nfloat f0, f1,f2,f3;\n\nvec2 clight = vec2(-1.6,0.1);//vec2(sin(iTime*0.5)*1.9-0.0,0.1);\nvec2 clight1 = vec2(1.6,0.1);\n\nvec2 rand2(){// implementation derived from one found at: lumina.sourceforge.net/Tutorials/Noise.html\n   randv2+=vec2(1.0,1.0);\n   return vec2(fract(sin(dot(randv2.xy ,vec2(12.9898,78.233))) * 43758.5453),\n      \t\t   fract(cos(dot(randv2.xy ,vec2(4.898,7.23))) * 23421.631));\n}\n\nvec3 CosineWeightedSampleHemisphere ( vec3 normal, vec2 rnd )\n{\n   //rnd = vec2(rand(vec3(12.9898, 78.233, 151.7182), seed),rand(vec3(63.7264, 10.873, 623.6736), seed));\n   float phi = acos( sqrt(1.0 - rnd.x)) ;\n   float theta = 2.0 * 3.14 * rnd.y ;\n\n   vec3 sdir = cross(normal, (abs(normal.x) < 0.5001) ? vec3(1.0, 0.0, 0.0) : vec3(0.0, 1.0, 0.0));\n   vec3 tdir = cross(normal, sdir);\n\n   return normalize(phi * cos(theta) * sdir + phi * sin(theta) * tdir + sqrt(1.0 - rnd.x) * normal);\n}\n\nvec3 cosPowDir(vec3  dir, float power) \n{//creates a biased random sample\n   vec2 r=rand2()*vec2(6.2831853,1.0);\n   vec3 sdir=cross(dir,((abs(dir.x)<0.5)?vec3(1.0,0.0,0.0):vec3(0.0,1.0,0.0)));\n   vec3 tdir=cross(dir,sdir); \n   r.y=pow(r.y,0.01/power);\n   float oneminus = sqrt(1.0-r.y*r.y);\n   return cos(r.x)*oneminus*sdir + sin(r.x)*oneminus*tdir + r.y*dir;\n}\n\nvec2 intersectCube(vec3 origin, vec3 ray, Box cube) {      \n   vec3   tMin = (cube.min - origin) / ray;      \n   vec3   tMax = (cube.max - origin) / ray;      \n   vec3     t1 = min(tMin, tMax);      \n   vec3     t2 = max(tMin, tMax);\n   float tNear = max(max(t1.x, t1.y), t1.z);\n   float  tFar = min(min(t2.x, t2.y), t2.z);\n   return vec2(tNear, tFar);   \n}\n\nvec3 normalForCube(vec3 hit, Box cube)\n{  \n   if(hit.x < cube.min.x + 0.0001) return vec3(-1.0, 0.0, 0.0);   \n   else if(hit.x > cube.max.x - 0.0001) return vec3( 1.0, 0.0, 0.0);   \n   else if(hit.y < cube.min.y + 0.0001) return vec3(0.0, -1.0, 0.0);   \n   else if(hit.y > cube.max.y - 0.0001) return vec3(0.0, 1.0, 0.0);      \n   else if(hit.z < cube.min.z + 0.0001) return vec3(0.0, 0.0, -1.0);   \n   else return vec3(0.0, 0.0, 1.0);   \n}\n\nfloat intersectSphere(vec3 origin, vec3 ray, Sphere s) {   \n   vec3 toSphere = origin - s.center_radius.xyz;      \n   float sphereRadius = s.center_radius.w;\n   float a = dot(ray, ray);      \n   float b = dot(toSphere, ray);   \n   float c = dot(toSphere, toSphere) - sphereRadius*sphereRadius;   \n   float discriminant = b*b - a*c;      \n   if(discriminant > 0.0) {      \n      float t = (-b - sqrt(discriminant)) ;   \n      if(t > 0.0) return t;      \n   }   \n   return 10000.0;   \n}  \n\nvec3 normalForSphere(vec3 hit, Sphere s) {   \n   return (hit - s.center_radius.xyz) / s.center_radius.w;   \n} \n\nfloat iCylinder(vec3 ro, vec3 rd, Cylinder cylinder)\n{\n\tvec3  rc = ro - cylinder.c;\n    float a = dot( rd.xz, rd.xz );\n\tfloat b = dot( rc.xz, rd.xz );\n\tfloat c = dot( rc.xz, rc.xz ) - cylinder.r*cylinder.r;//0.249;\n\tfloat d = b*b - a*c;\n\tif( d>=0.0 )\n\t{\n\t\t// cylinder\t\t\t\n\t\tfloat s = (-b - sqrt( d ))/a;\n        float hy = ro.y-cylinder.c.y+s*rd.y;\n\t\tif( s>0.0 && hy<cylinder.h && hy>-cylinder.h )\n\t\t{\n\t\t\treturn s;\n\t\t}\n\t\t// cap\t\t\t\n\t\t/*s = (cylinder.h - ro.y+cylinder.c.y)/rd.y;\n\t\tif( s>0.0 && (s*s*a+2.0*s*b+c)<0.0 )\n\t\t{\n\t\t\treturn s;\n\t\t}*/\n\t}\n    return 100000.0;\n}\n\nvec3 normalforCylinder(vec3 hit,Cylinder cylinder)\n{\n    vec3 nor;\n\tnor.xz = hit.xz - cylinder.c.xz;\n    nor.y = 0.0;\n    nor = nor/cylinder.r;\n    //nor.y = 1.0*sign(hit.y-cylinder.c.y);\n    return nor;\n}\n\nvoid initscene()\n{\n    box0.min = vec3(-3.0, -1.2, -2.0);//room\n   \tbox0.max = vec3( 3.0,  1.2,  2.0);\n    \n    light = vec3(cos(time *0.0)*1.65-0.5, sin(time*0.0)*0.65+0.7, sin(time*0.5)*1.65);\n\n    float h = sin(time*3.0)*0.03;\n    float sinr = sin(time)*0.5; float cosr = cos(time)*0.5;\n    sfere[0].center_radius = vec4(-2.8, -0.49, 0.0,    0.16);//rosu\n   \tsfere[1].center_radius = vec4(-2.8, -0.24, 0.0,    0.10);//verde\n   \tsfere[2].center_radius = vec4(-2.8, -0.10, 0.0,    0.04);//albastru\n    sfere[3].center_radius = vec4(clight, 1.8,  0.1);//albastru\n    \n    vec3 center = vec3(0.0,0.0,0.0); \n    cylinder[0].c = vec3( -2.7,-0.3, 0.5) + center;\n    cylinder[0].r = 0.04;\n    cylinder[0].h = 0.4;\n    \n    cylinder[1].c = vec3(-2.7,-0.3,-0.5) + center;\n    cylinder[1].r = 0.04;\n    cylinder[1].h = 0.4;\n    \n    cylinder[2].c = vec3(-0.55,0.0, 0.25) + center;\n    cylinder[2].r = 0.04;\n    cylinder[2].h = 0.4;\n    \n    cylinder[3].c = vec3(-0.55,0.0,-0.25) + center;\n    cylinder[3].r = 0.04;\n    cylinder[3].h = 0.4;\n\n   \tcenter = vec3(-0.0,-0.0, 0.0);\n    cub = vec3(0.0, 0.0, 1.37) + center;//perete dreapta\n    lcub = vec3(0.03, 1.3, 0.65);    \n   \tboxe[0].min = cub - lcub;\n   \tboxe[0].max = cub + lcub;\n    \n   \tcub = vec3(-0.0, 0.0, -1.37) + center;//perete stanga\n   \tlcub = vec3(0.03, 1.3, -0.65);\n   \tboxe[1].min = cub - lcub;\n   \tboxe[1].max = cub + lcub;\n    \n   \tcub = vec3(0.0, 1.0, 0.0) + center;//perete sus\n    lcub = vec3(0.03, 0.2, 0.8);\n   \tboxe[2].min = cub - lcub;\n   \tboxe[2].max = cub + lcub;   \n    \n   \tcub = vec3( -2.8, -0.8, 0.5) + center;//----------\n   \tlcub = vec3(0.2, 0.15, 1.3);    \n   \tboxe[3].min = cub - lcub;\n   \tboxe[3].max = cub + lcub;\n    \n   \tcub = vec3( -2.8, 0.2, -0.5) + center;//----------\n   \tlcub = vec3(0.2, 0.15, 1.3); \n   \tboxe[4].min = cub - lcub;\n   \tboxe[4].max = cub + lcub;\n/*\n   \tcub = vec3(0.41, 0.0, 0.06) + center;//maner dreapta\n   \tlcub = vec3(0.021, 0.1, 0.01);\n   \tboxe[5].min = cub - lcub;\n   \tboxe[5].max = cub + lcub;\n\n   \tcub = vec3(0.41, 0.0, -0.06) + center;//maner stanga\n   \tlcub = vec3(0.021, 0.1, 0.01);\n   \tboxe[6].min = cub - lcub;\n   \tboxe[6].max = cub + lcub;\n\n//dulap\n\n//birou\n\tcenter = vec3(0.8,-0.8,-1.6);\n   \tcub = vec3( 0.0, 0.4, 0.0) + center;//tablie\n   \tlcub = vec3(0.65, 0.015, 0.35);\n   \tboxe[7].min = cub - lcub;\n   \tboxe[7].max = cub + lcub;\n\n//scaun\n   \tcub = vec3(-0.0, 0.1, 0.5) + center;//tablie\n   \tlcub = vec3(0.25, 0.015, 0.25);\n   \tboxe[8].min = cub - lcub;\n   \tboxe[8].max = cub + lcub;\n\n   \tcub = vec3(-0.22, -0.15, 0.28) + center;//picior stanga fata\n   \tlcub = vec3(0.03, 0.25, 0.03);\n   \tboxe[9].min = cub - lcub;\n   \tboxe[9].max = cub + lcub;\n\n   \tcub = vec3( 0.22, -0.15, 0.28) + center;//picior dreapta fata\n   \tlcub = vec3(0.03, 0.25, 0.03);\n   \tboxe[10].min = cub - lcub;\n   \tboxe[10].max = cub + lcub;\n\n   \tcub = vec3( 0.22, 0.2,  0.72) + center;//picior dreapta spate\n   \tlcub = vec3(0.03, 0.60, 0.03);\n   \tboxe[11].min = cub - lcub;\n   \tboxe[11].max = cub + lcub;\n\n   \tcub = vec3(-0.22, 0.2,  0.72) + center;//picior stanga spate\n   \tlcub = vec3(0.03, 0.60, 0.03);\n   \tboxe[12].min = cub - lcub;\n   \tboxe[12].max = cub + lcub;\n\n   \tcub = vec3(-0.0, 0.6,  0.74) + center;//spatar\n   \tlcub = vec3(0.25, 0.10, 0.01);\n   \tboxe[13].min = cub - lcub;\n   \tboxe[13].max = cub + lcub;\n    \n    cub = vec3(-1.6,-0.87,  1.9) ;//calorifer\n   \tlcub = vec3(0.55, 0.3, 0.06);\n   \tboxe[14].min = cub - lcub;\n   \tboxe[14].max = cub + lcub;\n*/\n}\n\nvoid intersectscene(vec3 ro, vec3 rd, inout float t, inout int i, bool bl)\n{\n    //float tSphere6 = intersectSphere(ro, rd, sfere[3]);\n    //if(tSphere6 < t ) { t = tSphere6;i=6;}\n    //if(tSphere6 < t && bl) { t = tSphere6;i=6;}\n\n   \tfloat tSphere = intersectSphere(ro, rd, sfere[0]);\n    if(tSphere < t) { t = tSphere;i=0;}\n   \ttSphere = intersectSphere(ro, rd, sfere[1]);\n    if(tSphere < t) { t = tSphere;i=1;}\n   \ttSphere = intersectSphere(ro, rd, sfere[2]);\n    if(tSphere < t) { t = tSphere;i=2;}\n\t\n    \n    \n\tfloat tcyl = iCylinder(ro, rd, cylinder[0]);\n    if(tcyl<t) {t = tcyl; i = 10;}\n    tcyl = iCylinder(ro, rd, cylinder[1]);\n    if(tcyl<t) {t = tcyl; i = 11;}\n    tcyl = iCylinder(ro, rd, cylinder[2]);\n    /*if(tcyl<t) {t = tcyl; i = 12;}\n    tcyl = iCylinder(ro, rd, cylinder[3]);\n\tif(tcyl<t) {t = tcyl; i = 13;}\n    */\n\tvec2 tbox = intersectCube(ro, rd, boxe[0]); \n    if(tbox.x>0.0 && tbox.x<tbox.y && tbox.x < t) {t = tbox.x; i = 20;}\n    tbox = intersectCube(ro, rd, boxe[1]); \n    if(tbox.x>0.0 && tbox.x<tbox.y && tbox.x < t) {t = tbox.x; i = 21;}\n    tbox = intersectCube(ro, rd, boxe[2]); \n    if(tbox.x>0.0 && tbox.x<tbox.y && tbox.x < t) {t = tbox.x; i = 22;}\n    tbox = intersectCube(ro, rd, boxe[3]); \n    if(tbox.x>0.0 && tbox.x<tbox.y && tbox.x < t) {t = tbox.x; i = 23;}\n    tbox = intersectCube(ro, rd, boxe[4]); \n    if(tbox.x>0.0 && tbox.x<tbox.y && tbox.x < t) {t = tbox.x; i = 24;}\n\n\n    //tbox = intersectCube(ro, rd, boxe[7]); \n    //if(tbox.x>0.0 && tbox.x<tbox.y && tbox.x < t) {t = tbox.x; i = 27;}\n    /*tbox = intersectCube(ro, rd, boxe[8]); \n    if(tbox.x>0.0 && tbox.x<tbox.y && tbox.x < t) {t = tbox.x; i = 28;}\n    tbox = intersectCube(ro, rd, boxe[9]); \n    if(tbox.x>0.0 && tbox.x<tbox.y && tbox.x < t) {t = tbox.x; i = 29;}\n    tbox = intersectCube(ro, rd, boxe[10]); \n    if(tbox.x>0.0 && tbox.x<tbox.y && tbox.x < t) {t = tbox.x; i = 30;}\n    tbox = intersectCube(ro, rd, boxe[11]); \n    if(tbox.x>0.0 && tbox.x<tbox.y && tbox.x < t) {t = tbox.x; i = 31;}\n    tbox = intersectCube(ro, rd, boxe[12]); \n    if(tbox.x>0.0 && tbox.x<tbox.y && tbox.x < t) {t = tbox.x; i = 32;}\n    tbox = intersectCube(ro, rd, boxe[13]); \n\tif(tbox.x>0.0 && tbox.x<tbox.y && tbox.x < t) {t = tbox.x; i = 33;}*/\n    \n    //tbox = intersectCube(ro, rd, boxe[14]); \n    //if(tbox.x>0.0 && tbox.x<tbox.y && tbox.x < t) {t = tbox.x; i = 34;}\n}\n\nvoid ColorAndNormal(vec3 hit, inout vec4 mcol, inout vec3 normal, vec2 tRoom, inout vec2 mref, inout float t, const int id)\n{\n\tif(t == tRoom.y)\n\t{            \n\t\tmref = vec2(0.0,0.0);\n        normal =-normalForCube(hit, box0);    \n        if(normal.z<0.0)\n\t\t{\n         \t//clight = vec2(-1.6,0.1);//vec2(sin(iTime*0.5)*1.9-0.0,0.1);\n            if(\tall(lessThanEqual(hit.xy,vec2(-0.05,0.6)+clight)) &&\n               \tall(greaterThanEqual(hit.xy,vec2(-0.7,-0.6)+clight)) ||\n               \tall(lessThanEqual(hit.xy,vec2(0.7,0.6)+clight)) &&\n               \tall(greaterThanEqual(hit.xy,vec2(0.05,-0.6)+clight)))\n               \tmcol = vec4(vec3(1.1),2.0);\n                \n             /*if(\tall(lessThanEqual(hit.xy,vec2(-0.05,0.6)+clight1)) &&\n               \tall(greaterThanEqual(hit.xy,vec2(-0.7,-0.6)+clight1)) ||\n               \tall(lessThanEqual(hit.xy,vec2(0.7,0.6)+clight1)) &&\n               \tall(greaterThanEqual(hit.xy,vec2(0.05,-0.6)+clight1)))\n               \tmcol = vec4(vec3(1.1),2.0);\n\t\t\t}*/\n        }\n\t}     \n\telse   \n\t{\n        \t if(id==0) {normal = normalForSphere(hit, sfere[0]);mcol.xyz = vec3(1.0,0.0,0.0);}\n        else if(id==1) {normal = normalForSphere(hit, sfere[1]);mcol.xyz = vec3(1.0,0.0,0.0);}\n        else if(id==2) {normal = normalForSphere(hit, sfere[2]);mcol.xyz = vec3(1.0,0.0,0.0);}\n        //else if(id==6) {normal = normalForSphere(hit, sfere[3]);}\n    \telse if(id==10) {normal = normalforCylinder(hit, cylinder[0]);}\n        else if(id==11) {normal = normalforCylinder(hit, cylinder[1]);}\n        //else if(id==12) {normal = normalforCylinder(hit, cylinder[2]);}\n        //else if(id==13) {normal = normalforCylinder(hit, cylinder[3]);}\n        else if(id==20) {normal = normalForCube(hit, boxe[0]);}\n        else if(id==21) {normal = normalForCube(hit, boxe[1]);}\n        else if(id==22) {normal = normalForCube(hit, boxe[2]);}\n        else if(id==23) {normal = normalForCube(hit, boxe[3]);}\n        else if(id==24) {normal = normalForCube(hit, boxe[4]);}\n        /*else if(id==25) {normal = normalForCube(hit, boxe[5]);}\n        else if(id==26) {normal = normalForCube(hit, boxe[6]);}\n        else if(id==27) {normal = normalForCube(hit, boxe[7]);}\n        else if(id==28) {normal = normalForCube(hit, boxe[8]);}\n        else if(id==29) {normal = normalForCube(hit, boxe[9]);}\n        else if(id==30) {normal = normalForCube(hit, boxe[10]);}\n        else if(id==31) {normal = normalForCube(hit, boxe[11]);}\n        else if(id==32) {normal = normalForCube(hit, boxe[12]);}\n        else if(id==33) {normal = normalForCube(hit, boxe[13]);}\n        else if(id==34) {normal = normalForCube(hit, boxe[14]);}*/\n        \n       \tif(id>-1 && id<10) //sfere\n        {\n            mcol.xyz = vec3(1.0, 0.0, 0.0);\n            mref = vec2(0.0,0.0);// transparent, glossines\n        }\n\t\tif(id>9 && id<20)//cilindrii\n        {\n\t\t\tmcol.xyz = vec3(1.0);\n            mref = vec2(1.0,0.0);// transparent, glossines\n        }\n        \n       \tif(id>22)//suporti gri\n        {\n\t\t\tmcol.xyz = vec3(0.2);\n            mref = vec2(0.0,0.0);// transparent, glossines\n        }\n        \n       /* if(id==34)//calorifer\n        {\n            mcol.xyz = vec3(sin(hit.x*59.0)+2.0-0.2);\n            mref = vec2(0.0,0.0);\n        }*/\n    }  \n}\n\nvec3 directLight(vec3 hit, vec3 normal, vec3 lightf, vec3 cl, inout bool i)\n{\n   vec3 color = vec3(0.0);\n   int id = -1;\n   i = false;\n    \n   vec3 L = normalize(lightf-hit);;//(toLight*rsqrt(sqdist);\n   float diffuse = clamp(dot(normal,L),0.0,1.0);\n \n   if(diffuse>0.0)\n   {\n      float ldist =distance(lightf,hit);\n      float sh = 1000.0;\n      intersectscene(hit + normal * 0.0001, L, sh, id, false);           \n      if(sh>ldist)\n         {color += cl * (diffuse/(ldist))*0.32; i = true;}\n   }\n   return color;\n}\n\nvec3 getColor(vec3 ro, vec3 rd)\n{\n    vec3 color = vec3(0.0);\n    vec3 col = vec3(1.0);\n    int id=-1;\n    int tm = -1;\n    \n    for(int i=0; i<6; i++)\n    {\n    \tfloat t = 10000.0; //seed++;\n\t\t\n   \t\tvec2 tRoom = intersectCube(ro, rd, box0);          \n   \t\tif(tRoom.x < tRoom.y)   t = tRoom.y; \n    \n    \tintersectscene(ro, rd, t, id, true);\n    \n    \tvec3 hit = ro + rd * t;        \n\t\tvec4 mcol = vec4(vec3(0.99),0.0);\n    \tvec3 normal; \n    \tvec2 mref = vec2(0.0);\n      \n    \tColorAndNormal(hit, mcol, normal, tRoom, mref, t, id);\n    \thit = hit + normal * 0.0001;\n         \n        vec2 rnd = rand2();\n        //rnd.x = 1.0/6.0 * ( float(i) + rnd.x );\n        col *= mcol.xyz;\n        if(mcol.w>0.0) \n        {\n            color += col*mcol.xyz*mcol.w ;\n            break;\n        }\n\t\t\n        if(mref.x==0.0)\n        {\n        rd = CosineWeightedSampleHemisphere ( normal, rnd);      \n        \n        col *= clamp(dot(normal,rd),0.0,1.0)*0.62;\n            \n        bool isLight = false;\n        //vec3 rnd3 = vec3(rand2(),rand2().x) *2.0 -1.0;\n        rnd = rand2()*2.0-1.0;\n        vec3 lightf = vec3(clight,2.02)+ vec3(rnd.x*0.6,rnd.y * 0.3,0.0)*0.7;\n        vec3 lightf1 = vec3(clight1,2.02)+ vec3(rnd.x*0.6,rnd.y * 0.3,0.0);\n        \n        light = lightf;\n        //if(rand2().x>1.0)  light = lightf1;\n        vec3 dl = directLight(hit, normal, light, vec3(0.9,0.9,0.9), isLight);\n        float nd = max(0.0,dot(light,vec3(0.0,0.0,1.0)))+max(0.0,dot(light,normal));\n        color += col * dl*5.0 *nd;\n        //if(isLight) break;\n        }\n        else rd = reflect(rd,normal);\n        ro = hit + rd * 0.0001; \n    \n        if(dot(col,col) < 0.1 && i>3) break;\n    }\n \treturn color;   \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    p = -1.0+2.0*fragCoord.xy/iResolution.xy;\n\tp.x *= iResolution.x/iResolution.y;\n    vec2 mo = iMouse.xy/iResolution.xy  -vec2(0.0,2.0);\n\t\t \n\tfloat time = 15.0 + iTime;\n    float seed = iTime + iResolution.y *(p.x+1.0) + p.y;\n\t\n\trandv2=fract(cos((fragCoord.xy+fragCoord.yx*vec2(1000.0,1000.0))+vec2(iTime))*10000.0);\n\t\n    //move camera with mouse\n\tvec3 ro = vec3( 3.5*cos(8.0*mo.x), 2.0 + 1.1*(mo.y*1.0), 0.0 + 3.5*sin(8.0*mo.x) );\n\tvec3 ta = vec3( 0.0, 0.0, 0.0 );\n\t\n    //camera path\n    time = 0.2* iTime;\n    vec3 path = vec3(sin(time*0.5)*2.0, sin(time)*0.7, cos(time*0.5)*2.0);    \n    //ro = path; ta = path + vec3(-sin(time*0.5)*0.5+0.0, -cos(time)*0.2, -cos(time*0.5)*0.5+0.0);\n    \n    //view of raymarch\n    //ro = vec3(-0.4,-0.8, 1.0); ta = vec3(-0.4,-0.8, 1.5);\n\t// camera tx\n\tvec3 cw = normalize( ta-ro );\n\tvec3 cp = vec3( 0.0, 1.0, 0.0 );\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n\tvec3 rd = normalize( p.x*cu + p.y*cv + 2.5*cw );\n    \n    initscene();\n\t\n\tvec3 col = vec3(0.0);\n\n    for(float i=0.0; i<t; i++)\n    {\n        p += (rand2() * 2.0 - 1.0) * 0.7 / iResolution.x;\n        rd = normalize( p.x*cu + p.y*cv + 2.5*cw );\n    \tcol += getColor( ro, rd );\n    }\n\n    col = pow( clamp( col/t, 0.0, 1.0 ), vec3(0.65) );\n    //col.g += tc;\n    fragColor=vec4( col, 1.0 );\n}","name":"Image","description":"","type":"image"}]}