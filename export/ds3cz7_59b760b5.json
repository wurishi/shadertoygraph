{"ver":"0.1","info":{"id":"ds3cz7","date":"1694849900","viewed":43,"name":"sdf bool operator","username":"tomcat7479","description":"union operator, intersection operator, difference operator","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["sdf","booloperator"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/**\n    SDF函数的bool运算\n\n    sdf的并集运算：min实现\n    sdf的交集运算：max实现, 注意这里的max比较的模型之间的最大距离，不包括地面的，该距离与地面需要通过min来获取\n                  否则无法渲染出地面\n    sdf的差集运算：例如A - B，这个可以简单理解为A ∩ B~ (B~为B的补集)，SDF(B) = -SDF(B~), 故我们取的是\n                  max(SDF(A), -1.0 * SDF(B))         \n*/\n#define PI 3.141592658\n#define N 3\n#define plane_id 1.0\n#define sphere_id 2.0\n#define cuboid_id 3.0\n#define torus_id 4.0\n\n#define iter_precision 1e-4\n#define iter_count 200\n#define min_iter_distance 0.1\n#define max_iter_distance 200.0\n\nvec2 fix(in vec2 fragCoord) {\n    return (2.0 * fragCoord.xy - iResolution.xy) / min(iResolution.x, iResolution.y);\n}\n\nfloat grid_smooth_xor(vec3 p, float weight) {\n    vec2 s = sign(fract(p.xz) - 0.5);\n    return weight * (0.5 - 0.5 * s.x * s.y);\n}\n\nfloat tri_signal(float x) {\n    float h = fract(0.5 * x) - 0.5;\n    return 1.0 - 2.0 * abs(h);\n}\n\nfloat center_differnece(float x, float h) {\n    float dy = tri_signal(x + 0.5 * h) - tri_signal(x - 0.5 * h);\n    return dy / h;\n}\n\nfloat checkBroad(vec3 p, vec3 ddx, vec3 ddy) {\n    vec3 delta = max(ddx, ddy) + 1e-2;\n    float dx = center_differnece(p.x, delta.x);\n    float dz = center_differnece(p.z, delta.z);\n    return 0.5 - 0.5 * dx * dz;\n}\n\nmat3 setCamera(vec3 lookAt, vec3 ro, float theta) {\n    vec3 z = normalize(lookAt - ro);\n    vec3 y_dir = vec3(sin(theta), cos(theta), 0.0);\n    vec3 x = normalize(cross(z, y_dir));\n    vec3 y = normalize(cross(x, z));\n    return mat3(x, y, z);\n}\n\nfloat sdfPlane(vec3 p) {\n    return p.y;\n}\n\nfloat sdfSphere(vec3 p, vec3 center, float radius) {\n    return length(p - center) - radius;\n}\n\nfloat sdfCuboid(vec3 p, vec3 center, vec3 edge) {\n    p -= center;\n    vec3 q = abs(p) - edge / 2.0;\n    return length(max(q, 0.0)) + min(max(max(q.x, q.y), q.z), 0.0);\n}\n\n// union operator\nvec2 union_map(vec3 p, vec3 sphere_center, float radius, vec3 cuboid_center, vec3 edge) {\n    float d_plane = sdfPlane(p) + radius;\n    float d_sphere = sdfSphere(p, sphere_center, radius);\n    float d_cuboid = sdfCuboid(p, cuboid_center, edge);\n    \n    float min_d = d_plane;\n    float id = plane_id;\n\n    if (d_sphere < min_d) {\n        min_d = d_sphere;\n        id = sphere_id;\n    }\n\n    if (d_cuboid < min_d) {\n        min_d = d_cuboid;\n        id = cuboid_id;\n    }\n    return vec2(id, min_d);\n}\n\n// intersection operator\nvec2 intersection_map(vec3 p, vec3 sphere_center, float radius, vec3 cuboid_center, vec3 edge) {\n    float d_plane = sdfPlane(p) + radius;\n    float d_sphere = sdfSphere(p, sphere_center, radius);\n    float d_cuboid = sdfCuboid(p, cuboid_center, edge);\n    \n    float max_d = d_sphere;\n    float id = sphere_id;\n\n    if (d_sphere > max_d) {\n        max_d = d_sphere;\n        id = sphere_id;\n    }\n\n    if (d_cuboid > max_d) {\n        max_d = d_cuboid;\n        id = cuboid_id;\n    }\n\n    max_d = min(max_d, d_plane);\n    id = max_d == d_plane ? plane_id : id;\n    return vec2(id, max_d);\n}\n\n// difference operator\nvec2 difference_map(vec3 p, vec3 sphere_center, float radius, vec3 cuboid_center, vec3 edge) {\n    float d_plane = sdfPlane(p) + radius;\n    float d_sphere = sdfSphere(p, sphere_center, radius);\n    float d_cuboid = -1.0 * sdfCuboid(p, cuboid_center, edge);\n    \n    float max_d = d_sphere;\n    float id = sphere_id;\n\n    if (d_sphere > max_d) {\n        max_d = d_sphere;\n        id = sphere_id;\n    }\n\n    if (d_cuboid > max_d) {\n        max_d = d_cuboid;\n        id = cuboid_id;\n    }\n\n    max_d = min(max_d, d_plane);\n    id = max_d == d_plane ? plane_id : id;\n    return vec2(id, max_d);\n}\n\n// k1={1,-1,-1}, k2={-1,-1,1}, k3={-1,1,-1}, k4={1,1,1}\nvec3 calNormal(vec3 p, vec3 sphere_center, float radius, vec3 cuboid_center, vec3 edge) {\n    const float h = 1e-4;\n    const vec2 k = vec2(1.0, -1.0);\n    vec3 part1 = k.xyy * intersection_map(p + k.xyy * h, sphere_center, radius, cuboid_center, edge).y;\n    vec3 part2 = k.yyx * intersection_map(p + k.yyx * h, sphere_center, radius, cuboid_center, edge).y;\n    vec3 part3 = k.yxy * intersection_map(p + k.yxy * h, sphere_center, radius, cuboid_center, edge).y;\n    vec3 part4 = k.xxx * intersection_map(p + k.xxx * h, sphere_center, radius, cuboid_center, edge).y;\n    return normalize(part1 + part2 + part3 + part4);\n}\n\nvec2 rayMarch(vec3 ro, vec3 rd, vec3 sphere_center, float radius, vec3 cuboid_center, vec3 edge) {\n    vec2 res = vec2(-1.0);\n    float t = min_iter_distance;\n    for (int i = 0; i < iter_count; i++) {\n        vec3 p = ro + t * rd;\n        vec2 unionInfo = intersection_map(p, sphere_center, radius, cuboid_center, edge);\n        if (unionInfo.y < iter_precision) {\n            res = vec2(unionInfo.x, t);\n            break;\n        }\n        t += unionInfo.y;\n        res.y = t;\n    }\n    return res;\n}\n\nvec3 render(in vec2 uv, vec2 px, vec2 py) {\n    float amb_coff = 0.31;\n    float diff_coff = 0.95;\n    float spec_coff = 0.81;\n    float brightness = 100.0;\n    vec3 light_pos = vec3(2.0, 4.0, 3.0);\n    vec3 light_col = vec3(1.0);\n\n    vec3 sphere_center = vec3(0.0, 1.0, 0.0);\n    float radius = 1.0;\n    vec3 cuboid_center = vec3(0.0, 0.0, 0.0);\n    vec3 edge = vec3(1.0, 5.0, 1.0);\n\n    float foucs_distance = 1.0;\n    vec3 lookAt = vec3(0.0, 0.0, 0.0);\n    float theta = 0.0;\n    vec3 ro = vec3(4.0 * sin(0.5 * iTime / PI), 2.0, 4.0 * cos(0.5 * iTime / PI));\n    mat3 camera = setCamera(lookAt, ro, theta);\n    vec3 rd = normalize(vec3(camera * vec3(uv, foucs_distance)));\n    vec2 rayMarchInfo = rayMarch(ro, rd, sphere_center, radius, cuboid_center, edge);\n    float id = rayMarchInfo.x;\n\n    vec3 plane_col = vec3(0.372);\n    vec3 sphere_col = vec3(0.93, 0.88, 0.35);\n    vec3 cuboid_col = vec3(0.13, 0.89, 0.87);\n    vec3 bg_col = vec3(0.42, 0.77, 0.92);\n\n    vec3 color = bg_col;\n    if (rayMarchInfo.y < max_iter_distance) {\n        vec3 p = ro + rayMarchInfo.y * rd;\n        vec3 n = normalize(calNormal(p, sphere_center, radius, cuboid_center, edge));\n        vec3 light_dir = normalize(light_pos - p);\n        \n        if (id > 0.9 && id < 1.1) {\n            // 根据平面像素uv的x和y的偏移获取ray的x和y的偏移\n            vec3 rdx = normalize(camera * vec3(px, foucs_distance));\n            vec3 rdy = normalize(camera * vec3(py, foucs_distance));\n            vec3 ddx = ro.y * (rdx / rdx.y - rd / rd.y);\n            vec3 ddy = ro.y * (rdy / rdy.y - rd / rd.y);\n            color = plane_col + 0.2 * checkBroad(p, ddx, ddy);\n        } else if (id > 1.9 && id < 2.1) {\n            color = sphere_col;\n        } else if (id > 2.9 && id < 3.1) {\n            color = cuboid_col;\n        }\n\n        vec3 ambient = light_col * color * amb_coff;\n\n        float diff_cos = clamp(dot(n, light_dir), 0.0, 1.0);\n        vec3 diffuse = color * light_col * diff_cos * diff_coff;\n\n        vec3 refL = normalize(reflect(light_dir, n));\n        float spec_cos = clamp(dot(refL, rd), 0.0, 1.0);\n        vec3 specular = color * light_col * pow(spec_cos, brightness) * spec_coff;\n\n        color = ambient + diffuse + specular;\n    }\n\n    return color;\n}\n\nvec3 after_smooth(in vec2 fragCoord) {\n    vec3 color = vec3(0.0);\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            vec2 offset = 2.0 * (vec2(float(i), float(j)) / float(N) - 0.5);\n            vec2 uv = fix(fragCoord + offset);\n            // 像素在xy轴上的单位偏移\n            vec2 px = fix(fragCoord + offset + vec2(1.0, 0.0));\n            vec2 py = fix(fragCoord + offset + vec2(0.0, 1.0));\n            color += render(uv, px, py);\n        }\n    }\n    return color / float(N * N);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    fragColor = vec4(after_smooth(fragCoord), 1.0);\n}","name":"Image","description":"","type":"image"}]}