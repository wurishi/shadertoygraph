{"ver":"0.1","info":{"id":"7lS3Dc","date":"1624847491","viewed":195,"name":"livecode demozoo jam - oliwi :3","username":"bitnenfer","description":"updated shader done during the launch of https://livecode.demozoo.org/\nmusic by lug00ber","likes":6,"published":1,"flags":64,"usePreview":0,"tags":["livecode"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XlXSDB","filepath":"https://soundcloud.com/lug00ber/flipside-lug00ber-lovin-u","previewfilepath":"https://soundcloud.com/lug00ber/flipside-lug00ber-lovin-u","type":"musicstream","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// updated version of the shader I \n// made during the shader jam https://livecode.demozoo.org/\n// by bitnenfer\nfloat hash(float n) { return fract(sin(n) * 753.5); }\n\nstruct Hit\n{\n    float dist;\n    int id;\n};\n\nfloat fft = .0;\n//iq :D\nfloat torus(vec3 p, vec2 t)\n{\n    vec2 q = vec2(length(p.xz)-t.x, p.y);\n    return length(q) - t.y;\n}\n\nfloat smin(float a, float b, float k)\n{\n    float h = clamp(0.5 + 0.5 * (b-a)/k, 0.0, 1.0);\n    return mix(b, a, h) - k * h * ( 1. - h);\n}\n\nmat2 rot(float r)\n{\n    float c = cos(r), s = sin(r);\n    return mat2(c, s, -s , c);\n}\n\nHit opUnion(Hit a, Hit b)\n{\n    if (a.dist < b.dist) return a;\n    return b;\n}\n\nHit opaque(vec3 p)\n{\n    float t = iTime;\n    float blob = length(p) - 1. + cos(fft * 100.0 + sin(p.z * 10.0 + fft) + sin(p.x * 10.0 + fft * fft) + sin(p.y  * 12.0 + sin(iTime * 10.0 + fft))) * 0.05;\n    for (float i = 0.0; i < 3.0; i += 0.5)\n    {\n        blob = smin(blob, length(p + sin(p.x + p.y + p.z) * vec3(cos(t + i * 10.0), sin(t + i * 10.0), -cos(t - i * 10.0))) - 0.3, 0.5);\n    }\n    Hit blobHit = Hit(blob, 0);\n    return blobHit;\n}\n\nHit trans(vec3 p)\n{\n    vec3 p0 = p;\n    vec3 p1 = p;\n    p0.yz *= rot(iTime);\n    p1.xy *= rot(iTime);\n    float t0 = torus(p0, vec2(1.6, 0.1));  \n    float t1 = torus(p1, vec2(1.8, 0.1));  \n    Hit ringHit = Hit(abs(min(t0, t1)) - 0.01, 1);\n    return ringHit;\n}\n\nHit map(vec3 p) \n{\n    return opUnion(trans(p), opaque(p));\n}\n\nvec3 norm(vec3 p)\n{\n    vec2 e = vec2(0, 0.001);\n    return normalize(vec3(\n        map(p + e.yxx).dist - map(p - e.yxx).dist,\n        map(p + e.xyx).dist - map(p - e.xyx).dist,\n        map(p + e.xxy).dist - map(p - e.xxy).dist\n    ));\n}\n\nvec3 normOpaque(vec3 p)\n{\n    vec2 e = vec2(0, 0.001);\n    return normalize(vec3(\n        opaque(p + e.yxx).dist - opaque(p - e.yxx).dist,\n        opaque(p + e.xyx).dist - opaque(p - e.xyx).dist,\n        opaque(p + e.xxy).dist - opaque(p - e.xxy).dist\n    ));\n}\n\nbool trace(vec3 ro, vec3 rd, out Hit hit)\n{\n    float t = 0.;\n    for (int i = 0; i < 100; ++i)\n    {\n        Hit h = map(ro + rd * t);\n        if (h.dist < 0.001) \n        {\n            hit.dist = t;\n            hit.id = h.id;\n            return true;\n        }\n        t+=h.dist;\n        if (t > 100.) break;\n    }\n    hit = Hit(t, -1);\n    return false;\n}\n\nbool traceOpaque(vec3 ro, vec3 rd, out Hit hit)\n{\n    float t = 0.;\n    for (int i = 0; i < 100; ++i)\n    {\n        Hit h = opaque(ro + rd * t);\n        if (h.dist < 0.001) \n        {\n            hit.dist = t;\n            hit.id = h.id;\n            return true;\n        }\n        t+=h.dist;\n        if (t > 100.) break;\n    }\n    hit = Hit(t, -1);\n    return false;\n}\n\nvec3 render(vec2 uv)\n{\n    fft = texture(iChannel0, vec2(0.0)).r * 0.15;\n    vec3 ro = vec3(0, 0, -4. + sin(iTime) * 0.5);\n    vec3 rd = normalize(vec3(uv, 1));\n    vec3 color = vec3(0.05);\n    ro.xz *= rot(iTime);\n    rd.xz *= rot(iTime);\n\n    Hit sceneHit;\n    if (trace(ro, rd, sceneHit))\n    {\n        vec3 p = ro + rd * sceneHit.dist;\n        vec3 matColor = vec3(0);\n        if (sceneHit.id == 0)\n        {\n            matColor = vec3(1, 205.0/255.0,178.0/255.0);\n        }\n        else if (sceneHit.id == 1)\n        {\n            matColor = vec3(1);\n        }\n        vec3 v = normalize(p - ro);\n        vec3 n = norm(p);\n        vec3 l = vec3(0.5, 0.2, 0.3);\n        vec3 l2 = -l;\n        l.xz *= rot(iTime);\n        l2.xz *= rot(iTime);\n        vec3 h = normalize(l2 + v);\n        float ndl = max(dot(n, l), 0.0);\n        float sp = pow(max(0.0, dot(n, h)), 1.0);\n\n        color = matColor * 0.02 + matColor * ndl + sp * vec3(0.0, 0.5, 0.9);\n\n        if (sceneHit.id == 0)\n        {\n            {\n                vec3 rd2 = l;\n                vec3 ro2 = p + rd2 * 0.1;\n                for (int j = 0; j < 62; ++j)\n                {\n                    float d = map(ro2 + rd2 * 0.35).dist * 0.8;\n                    if (d < 0.0) break;\n                    color += (matColor + vec3(0.8, 0.2, 0.1)) * (d * 0.1) * 0.25;\n                }\n            }\n            \n            {\n                vec3 rd2 = l2;\n                vec3 ro2 = p + rd2 * 0.1;\n                for (int j = 0; j < 16; ++j)\n                {\n                    float d = map(ro2 + rd2 * 0.15).dist * 0.8;\n                    if (d < 0.0) break;\n                    color += (matColor + vec3(1.0, 0.5, 0.9)) * (d * 0.1) * 0.15;\n                }\n            }\n        }\n        else\n        {\n            color = vec3(0.0);\n            color += pow(max(0.0, dot(n, h)), 32.) * vec3(1);\n            \n            {\n                vec3 col = vec3(0);\n                vec3 rd3 = refract(rd, n+ 0.1*(hash(n.x * n.y * n.z) * 2.0 - 1.0), 1./1.1);\n                vec3 ro3 = p + rd3 * 0.2;\n                Hit refHit;\n                if (traceOpaque(ro3, rd3, refHit)) \n                {\n                    vec3 p1 = ro3 + rd3 * refHit.dist;\n                    vec3 matColor1 = vec3(0);\n                    matColor1 = vec3(1, 205.0/255.0,178.0/255.0);\n                    vec3 v1 = normalize(p1 - ro3);\n                    vec3 n1 = norm(p1);\n                    vec3 h1 = normalize(l2 + v1);\n                    float ndl1 = max(dot(n1, l), 0.0);\n                    float sp1 = pow(max(0.0, dot(n1, h1)), 1.0);\n                    col += matColor1 * 0.02 + matColor1 * ndl1 + sp1 * vec3(0.0, 0.5, 0.9);\n                }\n                else\n                    col = vec3(0.07);\n                \n                color.r += col.r;\n            }\n            \n            {\n                vec3 col = vec3(0);\n                vec3 rd3 = refract(rd, n+ 0.1*(hash(n.x * n.y * n.z) * 2.0 - 1.0), 1./1.2);\n                vec3 ro3 = p + rd3 * 0.2;\n                Hit refHit;\n                if (traceOpaque(ro3, rd3, refHit)) \n                {\n                    vec3 p1 = ro3 + rd3 * refHit.dist;\n                    vec3 matColor1 = vec3(0);\n                    matColor1 = vec3(1, 205.0/255.0,178.0/255.0);\n                    vec3 v1 = normalize(p1 - ro3);\n                    vec3 n1 = norm(p1);\n                    vec3 h1 = normalize(l2 + v1);\n                    float ndl1 = max(dot(n1, l), 0.0);\n                    float sp1 = pow(max(0.0, dot(n1, h1)), 1.0);\n                    col += matColor1 * 0.02 + matColor1 * ndl1 + sp1 * vec3(0.0, 0.5, 0.9);\n                }\n                else\n                    col = vec3(0.07);\n                \n                color.g += col.g;\n            }\n            \n            {\n                vec3 col = vec3(0);\n                vec3 rd3 = refract(rd, n+ 0.1*(hash(n.x * n.y * n.z) * 2.0 - 1.0), 1./1.3);\n                vec3 ro3 = p + rd3 * 0.2;\n                Hit refHit;\n                if (traceOpaque(ro3, rd3, refHit)) \n                {\n                    vec3 p1 = ro3 + rd3 * refHit.dist;\n                    vec3 matColor1 = vec3(0);\n                    matColor1 = vec3(1, 205.0/255.0,178.0/255.0);\n                    vec3 v1 = normalize(p1 - ro3);\n                    vec3 n1 = norm(p1);\n                    vec3 h1 = normalize(l2 + v1);\n                    float ndl1 = max(dot(n1, l), 0.0);\n                    float sp1 = pow(max(0.0, dot(n1, h1)), 1.0);\n                    col += matColor1 * 0.02 + matColor1 * ndl1 + sp1 * vec3(0.0, 0.5, 0.9);\n                }\n                else\n                    col = vec3(0.07);\n                \n                color.b += col.b;\n            }\n        }\n    }\n\n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // oliwi :3\n\n    vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n    uv -= 0.5;\n    uv /= vec2(iResolution.y / iResolution.x, 1);\n    vec3 color = render(uv);\n    fragColor = vec4(color, 1);\n}\n","name":"Image","description":"","type":"image"}]}