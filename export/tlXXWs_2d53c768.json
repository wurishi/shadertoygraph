{"ver":"0.1","info":{"id":"tlXXWs","date":"1564602936","viewed":1003,"name":"2d  grass texture with a twist","username":"TLC123","description":"2d texture from https://www.shadertoy.com/view/WsSGWd \tCreated by BynaryCobweb\n Strand directionality and length is determined by the angle between the ground and ray direction\nSome rotor wash artifacts on closeup and obviously nothing on the ridges. \n\n\n","likes":13,"published":1,"flags":0,"usePreview":1,"tags":["2d","texture","grass"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Fork of \"Procedural walk animation\" by None. https://shadertoy.com/view/-1\n// 2019-07-31 19:07:24\n\n \n\n#define AA 1\n# define PI 3.14159265359\n# define PHI 1.618033988749895\n# define TAU 6.283185307179586\n \n# define PLOTPATH 0\n \nvec2 UV;\n//------------------------------------------------------------------\nfloat sdPlane(vec3 p) {\n    return p.y;}\n \n\nfloat pathterrain(float x,float z){\n    // Common height function for path and terrain\n    return (\n        abs(sin(x*.5 )*1.+cos(z*.3 )*0.6)\n        +abs(cos(x*3.+z )*0.1+sin(x-z*.2 )*0.4))*.7\n         ;}\n vec3 timefly(float t) {\n    // main path Called from many places\n    t*=.80;\n\tt += (.125 + sin(t * .125));\n\tvec3 v =\n\tvec3(sin(t / 50.) * 20., 0., cos(t / 25.) * 24.) +\n\t\tvec3(sin(t / 17.1) * 07., 0., cos(t / 17.1) * 05.) +\n\t\tvec3(sin(t / 8.1) * 6., 0., cos(t / 8.1) * 8.) +\n\t\tvec3(cos(t / 3.) * 3.,0., sin(t / 3.) * 2.)\n        +vec3(cos(t  )*2.,0., sin(t  )*2. );\n    v.y=pathterrain(v.x,v.z);\n    return v        ;\n} \n \n\n\nfloat lpnorm(vec3 p, float s) {\n\treturn pow(\n\t\t(\n\t\t\tpow(abs(p.x), s) +\n\t\t\tpow(abs(p.y), s) +\n\t\t\tpow(abs(p.z), s)),\n\t\t1.0 / s);\n}\n\n \n//------------------------------------------------------------------\n \n\nfloat sdSphere(vec3 p, float s) {\n    return length(p) - s;\n}\n\nfloat sdEllipsoid( in vec3 p, in vec3 r) {\n    return (length(p / r) - 1.0) * min(min(r.x, r.y), r.z);\n}\n\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r) {\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    return length(pa - ba * h) - r;\n}\n\nfloat TTorus(vec3 p, vec2 t) {\n    vec2 q = vec2(length(p.xz) - t.x, p.y);\n    return length(q) - t.y;\n}\n\nfloat sdTorus(vec3 p, vec2 t) {\n    vec2 q = vec2(length(p.xz) - t.x, p.y);\n    return length(q) - t.y;\n}\n\nfloat opIntersection(float d1, float d2) {\n    return max(d1, d2);\n}\nfloat sdPlane(vec3 p, vec4 n) {\n    // n must be normalized\n    return dot(p, n.xyz) + n.w;\n}\nfloat opSubtraction(float d1, float d2) {\n    return max(-d1, d2);\n}\n\nfloat opOnion( in float sdf, in float thickness) {\n    return abs(sdf) - thickness;\n}\n\nfloat opSmoothIntersection(float d1, float d2, float k) {\n    float h = clamp(0.5 - 0.5 * (d2 - d1) / k, 0.0, 1.0);\n    return mix(d2, d1, h) + k * h * (1.0 - h);\n}\n//----------------------------------------------------------------------\n\n//----------------------------------------------------------------------\n\n \n        \n\nfloat plant( in vec3 pos, vec4 type) {\n    float l =  length(pos.xz)*max(1.,abs( 4.* pos.y-1.)) ;\n    pos=pos\n        +vec3(l,0,l)*(0.2+sin(pos.x+pos.y+iTime*0.6)*0.2)\n        +vec3(0,l,0)*(0.1+sin(pos.y+iTime*1.6)*0.1)\n                     ;\n    float d, di, plane, lay;\n    d = l;\n    if ((l - type.w) < 0.) {\n\n        for (float i = 0.3; i < 0.28+type.w*0.5; i += +(.101*1./3.)) {\n\n            di = sdTorus(pos + vec3(0, -i * type.z*0.6, 0), vec2(0.18 * type.w + i * type.y, i * 1.5*type.z * type.w));\n\n            di = opOnion(di, type.x * 0.125 * type.w);\n            lay = i * (23.416 * 1.7);\n            plane = sdPlane(vec3(pos.x, pos.y, pos.z), vec4(sin(lay), 0, cos(lay), (-0.5+fract(lay*10.))*0.5*type.x));\n            di = opIntersection(di,\n\n                abs(plane)   -  ( sin(clamp( (min(l,type.w)/type.w )*7.28,.3,6.28) ))*type.x);\n\n            d = min(d, di);\n            if(d<0.01)break;\n\n        }\n        d = opIntersection(d, sdSphere(pos + vec3(0, -type.w * 0.9, 0), type.w));\n\n    }\n\n    return d;\n}\n//-------------------------------------------\nvec2 foliage( in vec3 pos) {\n    \n    pos.y=pos.y-pathterrain(pos.x,pos.z);\n    \n    float Strand, Spread, Lift, Size;\n    float sqr = 1.;\n    float d = length(pos.xz)+1.;\n    vec3 pfract = fract(pos / sqr) * sqr;\n    vec3 pround = round(pos / sqr) * sqr + vec3(sqr * 0.5, 0, sqr * 0.5);\n    vec3 mos = vec3(pfract.x, pos.y, pfract.z);\n\n    float i = (pos - pfract).x;\n    float j = (pos - pfract).z;\n\n    Strand = 0.01 + fract( sin(i * 12. + j*9.9) * 9.219869) * 0.0325;\n    Spread = 0. + fract( sin (i * 12. + j*9.9) * 99.24927) * .3;\n    Lift = .2 + fract(  sin(i * 42. + j*32.9) * 199.210930) * .5;\n    Size = .2 + fract( sin (i * 2. + j) * 99.) * .7;\n\n    d = min(d, plant(mos - vec3(sqr * 0.5, 0., sqr * 0.5), vec4(Strand, Spread * 1.1, Lift, Size)));\n\n      d = max(d, -(length(pfract.xz - vec3(sqr * 0.5, 0., sqr * 0.5).xz) -0.01));\n\n    return vec2(d, 3);\n\n} \n \nvec2 map( in vec3 pos) {\n\tvec2 res = vec2(pos.y-pathterrain(pos.x,pos.z), 1.0);\n\t//vec2 bush =  foliage(pos);\n    //res=res.x<bush.x?res:bush;\n    \n \treturn res;\n}\n\n\n\n\n\n\nvec2 castRay( in vec3 ro, in vec3 rd) {\n\tfloat tmin = .10;\n\tfloat tmax = 50.0;\n\tfloat t = tmin;\n\tfloat m = -1.0;\n\tfor (int i = 0; i < 80; i++) {\n\t\tfloat precis = 0.0001 * t;\n\t\tvec2 res = map(ro + rd * t);\n\t\tif (res.x < precis || t > tmax) break;\n\t\tt += res.x * .7;\n\t\tm = res.y;\n\t}\n\tif (t > tmax) m = -1.0;\n\treturn vec2(t, m);\n}\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax) {\n\tfloat res = 1.0;\n\tfloat t = mint;\n\tfor (int i = 0; i < 32; i++) {\n\t\tfloat h = map(ro + rd * t).x;\n\t\tres = min(res, 8.0 * h / t);\n\t\tt += clamp(h, 0.02, 0.10);\n\t\tif (res < 0.005 || t > tmax) break;\n\t}\n\treturn clamp(res, 0.0, 1.0);\n}\nvec3 calcNormal( in vec3 pos) {\n\tvec2 e = vec2(1.0, -1.0) * 0.5773 * 0.0005;\n\treturn normalize(e.xyy * map(pos + e.xyy).x +\n\t\te.yyx * map(pos + e.yyx).x +\n\t\te.yxy * map(pos + e.yxy).x +\n\t\te.xxx * map(pos + e.xxx).x);\n}\nfloat calcAO( in vec3 pos, in vec3 nor) {\n\tfloat occ = 0.0;\n\tfloat sca = 1.0;\n\tfor (int i = 0; i < 5; i++) {\n\t\tfloat hr = 0.01 + 0.12 * float(i) / 4.0;\n\t\tvec3 aopos = nor * hr + pos;\n\t\tfloat dd = map(aopos).x;\n\t\tocc += -(dd - hr) * sca;\n\t\tsca *= 0.95;\n\t}\n\treturn clamp(1.0 - 3.0 * occ, 0.0, 1.0);\n}\n \n//------------------------------------------------------------------\n// 2d Grass texture from https://www.shadertoy.com/view/WsSGWd \tCreated by BynaryCobweb\n//------------------------------------------------------------------\n\n\n\n#define BLADES_SPACING 0.003\n#define JITTER_MAX 0.004\n// depends on size of grass blades in pixels\n#define LOOKUP_DIST 5\n\n#define HASHSCALE1 .1031\n#define HASHSCALE3 vec3(.1031, .1030, .0973)\n\n \n//----------------------------------------------------------------------------------------\n// Hash without Sine  https://www.shadertoy.com/view/4djSRW\n// Creative Commons Attribution-ShareAlike 4.0 International Public License\n// Created by David Hoskins.\n\n//----------------------------------------------------------------------------------------\n//  1 out, 1 in...\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\n//----------------------------------------------------------------------------------------\n//  1 out, 2 in...\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//----------------------------------------------------------------------------------------\n//  1 out, 3 in...\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//----------------------------------------------------------------------------------------\n//  2 out, 1 in...\nvec2 hash21(float p)\n{\n\tvec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n//----------------------------------------------------------------------------------------\n///  2 out, 2 in...\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n//----------------------------------------------------------------------------------------\n///  2 out, 3 in...\nvec2 hash23(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\n//----------------------------------------------------------------------------------------\n//  3 out, 1 in...\nvec3 hash31(float p)\n{\n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\n\n//----------------------------------------------------------------------------------------\n///  3 out, 2 in...\nvec3 hash32(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\n//----------------------------------------------------------------------------------------\n///  3 out, 3 in...\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n\n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 1 in...\nvec4 hash41(float p)\n{\n\tvec4 p4 = fract(vec4(p) * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n    \n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 2 in...\nvec4 hash42(vec2 p)\n{\n\tvec4 p4 = fract(vec4(p.xyxy) * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n\n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 3 in...\nvec4 hash43(vec3 p)\n{\n\tvec4 p4 = fract(vec4(p.xyzx)  * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 4 in...\nvec4 hash44(vec4 p4)\n{\n\tp4 = fract(p4  * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\n\n\n\n\n\n//----------------------------------------------------------------------------------------\n//// Created by inigo quilez - iq/2014\n//----------------------------------------------------------------------------------------\nfloat noise( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n\tvec2 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( hash12( i + vec2(0.0,0.0) ), \n                     hash12( i + vec2(1.0,0.0) ), u.x),\n                mix( hash12( i + vec2(0.0,1.0) ), \n                     hash12( i + vec2(1.0,1.0) ), u.x), u.y);\n}\nfloat noise13( in vec3 p )\n{\n    vec3 i = floor( p );\n    vec3 f = fract( p );\n\t\n\tvec3 u = f*f*(3.0-2.0*f);\n\n    return mix( \n        mix(\n                mix( hash13( i + vec3(0.0,0.0,0.0) ), \n                     hash13( i + vec3(1.0,0.0,0.0) ), u.x),\n                mix( hash13( i + vec3(0.0,1.0,0.0) ), \n                     hash13( i + vec3(1.0,1.0,0.0) ), u.x)\n               , u.y),\n              mix(\n                mix( hash13( i + vec3(0.0,0.0,1.0) ), \n                     hash13( i + vec3(1.0,0.0,1.0) ), u.x),\n                mix( hash13( i + vec3(0.0,1.0,1.0) ), \n                     hash13( i + vec3(1.0,1.0,1.0) ), u.x)\n               , u.y)\n        \n         , u.z)\n        ;\n}\n\nvec3 noise33(  vec3 p )\n{\n    p=p+10000.;\n    vec3 i = floor( p );\n    vec3 f = fract( p );\n\t\n\tvec3 u;\n    u.x = f.x*f.x*(3.0-2.0*f.x);\n    u.y = f.y*f.y*(3.0-2.0*f.y);\n    u.z = f.z*f.z*(3.0-2.0*f.z);\n\n    return mix( \n        mix(\n                mix( hash33( i + vec3(0.0,0.0,0.0) ), \n                     hash33( i + vec3(1.0,0.0,0.0) ), u.x),\n                mix( hash33( i + vec3(0.0,1.0,0.0) ), \n                     hash33( i + vec3(1.0,1.0,0.0) ), u.x)\n               , u.y),\n              mix(\n                mix( hash33( i + vec3(0.0,0.0,1.0) ), \n                     hash33( i + vec3(1.0,0.0,1.0) ), u.x),\n                mix( hash33( i + vec3(0.0,1.0,1.0) ), \n                     hash33( i + vec3(1.0,1.0,1.0) ), u.x)\n               , u.y)\n        \n         , u.z)\n        ;\n}\nvec3 fbm33( vec3 p )\n{\n   \n     mat3 m = mat3(vec3(0.80,  0.60, -0.6).xyz,\n                    vec3(0.80,  0.60, -0.6).yzx,\n                    vec3(0.80,  0.60, -0.6).zxy);\n    vec3 f = vec3(0.0);\n    f += 0.5000*noise33( p ); p = m*p*2.02;\n    f += 0.2500*noise33( p ); p = m*p*2.03;\n    f += 0.1250*noise33( p ); p = m*p*2.01;\n    f += 0.0625*noise33( p );\n    return f/0.9375;\n}\n\nvec3 getGrassColor(float x) {\n     vec3 a = vec3(0.3, 0.3, 0.3);\n    vec3 b = vec3(0.4, 0.5, 0.2);\n    vec3 c = vec3(0.2, 0.4, 0.2);\n    vec3 d = vec3(0.66, 0.77, 0.33);\n    vec3 col = a + b * cos(2. * PI * (c * x + d));\n    return col;\n}\n\nfloat getGrassBlade(in vec2 position, in vec2 grassPos, out vec4 color) {\n    \n       // grassPos+= abs(noise33(vec3(grassPos*.41,0.)*vec3(3,.0,1)).xy-0.5 )*.5;\n\n    \n\t// between {-1, -1, -1} and {1, 1, 1}\n    vec3 grassVector3 = hash32(grassPos * 123512.41) * 2.0 - vec3(1);\n    // keep grass z between 0 and 0.4\n    grassVector3.z = grassVector3.z * 0.2 + 0.2;\n    vec2 grassVector2 = normalize (\n     //vec2(sin( 1.5+iTime*0.1),cos(1.5+iTime*0.1))*2.\n     (UV)  *1.5 \n        \n    +   grassVector3.xy*.6\n    )     ;\n\n    float grassLength = noise13(vec3(grassPos*1.5,10.)) * 0.01 + 0.012*length(UV) ;\n\n    // take coordinates in grass blade frame\n    vec2 gv = position - grassPos;\n    float gx = dot(grassVector2, gv);\n    float gy = dot(vec2(-grassVector2.y, grassVector2.x), gv);\n    float gxn = gx / grassLength;\n\n    // TODO make gy depends to gx\n    if (gxn >= 0.0 && gxn <= 1.0 && abs(gy) <= 0.0015 * (1. - gxn * gxn)) {\n        \n        vec3 thisGrassColor = \n            getGrassColor(hash12(grassPos * 2631.6));\n        color =\n            vec4(thisGrassColor * (0.2 + 0.8 * gxn) \n            + (fbm33(vec3(position*1.1,0.)*vec3(1,3,1))-0.5 )*.2\n            + (fbm33(vec3(position*10.1,0.)*vec3(5,1,1))-0.5 )*.2\n                 , 1.0);\n        \n     \treturn grassVector3.z * gxn;\n    }\n    else {\n        color = vec4(0., 0., 0., 1.);\n        return -1.0;\n    }\n}\n\nfloat getPoint(in vec2 position, out vec4 color) {\n   \tint xcount = int(1. / BLADES_SPACING);\n    int ycount = int(1. / BLADES_SPACING);\n    int ox = int(position.x * float(xcount));\n    int oy = int(position.y * float(ycount));\n\n    float maxz = 0.0;\n            vec4 tempColor =vec4(vec3(0.1,0.35,0)+fbm33(vec3(position*129.,0.)-.5),0.)*.1;\n\n    for (int i = -LOOKUP_DIST; i < LOOKUP_DIST; ++i) {\n        for (int j = -LOOKUP_DIST; j < LOOKUP_DIST; ++j) {\n            vec2 upos = vec2(ox + i, oy + j);\n            vec2 grassPos = (BLADES_SPACING+0.005*BLADES_SPACING*fbm33(vec3(upos*179.,0.)-.5)).x*  (upos \n                             + 4.5* (noise33(vec3(upos*50.,upos.x+upos.y)).xy-.5) );\n \n            float z = getGrassBlade(position, grassPos, tempColor);\n\n            if (z > maxz) {\n                maxz = z;\n                color = mix(color, tempColor,0.85);\n            }\n        }\n    }\n    if (maxz == 0.0) {\n        color = vec4(vec3(0.1,0.35,0)+fbm33(vec3(position*129.,0.)-.5),0.)*.12;;\n    }\n\n    return maxz;\n}\n\n//------------------------------------------------------------------\n// \n//------------------------------------------------------------------\n\n\nvec3 render( in vec3 ro, in vec3 rd) {\n\tvec3 col = vec3(.8, .9, 1.0) + rd.y * 0.8;\n\tvec2 res = castRay(ro, rd);\n\tfloat t = res.x;\n\tfloat m = res.y;\n\tif (m > -0.5) {\n\t\tvec3 pos = ro + t * rd;\n\t\tvec3 nor = calcNormal(pos);\n\t\tvec3 ref = reflect(rd, nor);\n        \n        vec4 grasscolor;\n        vec4 grasscolor2;\n\t\t// material        \n\t\n        if (m < 1.5) {\n            \tcol = 0.45 + 0.35 * sin(vec3(0.05, 0.08, 0.10) * (m - 1.0));\n\t\t    vec2 position=pos.zx;\n            grasscolor2=  vec4(0.6*getGrassColor(hash13(pos)) * (0.2 + 0.8 * 0.5) \n            + (fbm33(vec3(position*1.1,0.)*vec3(1,3,1))-0.5 )*.2\n            + (fbm33(vec3(position*10.1,0.)*vec3(5,1,1))-0.5 )*.2\n                 , 1.0);if \n                \n            (t<13.){\n\t\t\tfloat f = getPoint( vec2(pos.xz*.1),grasscolor);\n            }\n            else {\n            grasscolor=grasscolor2;\n            }\n            \n            \n            col = mix(grasscolor.rgb,grasscolor2.rgb,smoothstep(10.,13.,t) );\n\t\t}\n\t\tif (m >= 2.0) {\n\t\t\tcol = vec3(0.6);\n\t\t}\n\t\tif (m >= 3.0) {\n\t\t\tcol = vec3(0.07);\n\t\t}\n\t\t// lighting        \n\t\tfloat occ = calcAO(pos, nor);\n\t\tvec3 lig = normalize(vec3(0.2, 0.7, 0.6));\n\t\tvec3 hal = normalize(lig - rd);\n\t\tfloat amb = clamp(0.5 + 0.5 * nor.y, 0.0, 1.0);\n\t\tfloat dif = clamp(dot(nor, lig), 0.0, 1.0);\n\t\tfloat bac = clamp(dot(nor, normalize(vec3(-lig.x, 0.0, -lig.z))), 0.0, 1.0) * clamp(1.0 - pos.y, 0.0, 1.0);\n\t\tfloat dom = smoothstep(-0.1, 0.1, ref.y);\n\t\tfloat fre = pow(clamp(1.0 + dot(nor, rd), 0.0, 1.0), 2.0);\n\t\tdif *= calcSoftshadow(pos, lig, 0.02, 2.5);\n\t\tdom *= calcSoftshadow(pos, ref, 0.02, 2.5);\n\t\tfloat spe = pow(clamp(dot(nor, hal), 0.0, 1.0), 16.0) *\n\t\t\tdif *\n\t\t\t(0.04 + 0.96 * pow(clamp(1.0 + dot(hal, rd), 0.0, 1.0), 5.0));\n\t\tvec3 lin = vec3(0.0);\n\t\tlin += 1.30 * dif * vec3(1.00, 0.80, 0.55);\n\t\tlin += 0.20 * amb * vec3(0.40, 0.60, 1.00) * occ;\n\t\tlin += 0.20 * dom * vec3(0.40, 0.60, 1.00) * occ;\n\t\tlin += 0.30 * bac * vec3(0.25, 0.25, 0.25) * occ;\n\t\t//lin += 0.35 * fre * vec3(1.00, 1.00, 1.00) * occ;\n\t\tcol = col * lin;\n\t\t//col += 10.00 * spe * vec3(1.00, 0.90, 0.70);\n        col=mix(col,vec3((col.x+col.y+col.z)/3.)*vec3(1,1.5,1),0.3);\n\t\tcol = mix(col, vec3(0.8, 0.9, 1.0), 1.0 - exp(-0.00005 * t * t * t  ));\n        \n\t}\n\treturn vec3(clamp(col, 0.0, 1.0));\n}\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr) {\n\tvec3 cw = normalize(ta - ro);\n\tvec3 cp = vec3(sin(cr), cos(cr), 0.0);\n\tvec3 cu = normalize(cross(cw, cp));\n\tvec3 cv = normalize(cross(cu, cw));\n\treturn mat3(cu, cv, cw);\n}\n\n\n\n\n\nvoid setup() {\n }\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\tsetup();\n\tvec2 mo = iMouse.xy / iResolution.xy;\n\tfloat time = .0 + iTime;\n\tvec3 tot = vec3(0.0);\n #\tif AA > 1\n\tfor (int m = 0; m < AA; m++)\n\t\tfor (int n = 0; n < AA; n++) {\n\t\t\t// pixel coordinates\n\t\t\tvec2 o = vec2(float(m), float(n)) / float(AA) - 0.5;\n\t\t\tvec2 p = (-iResolution.xy + 2.0 * (fragCoord + o)) / iResolution.y;\n # else\n\t\t\t\tvec2 p = (-iResolution.xy + 2.0 * fragCoord) / iResolution.y;\n # endif\n\t\t\t// camera\t\n\t\t\tvec3 ta = timefly(time)  ;\n\t\t\tvec3 ro = vec3(0,1,0)+timefly(time-1.) \n                + vec3(-0.5 + 3.5 * cos(  6.0 * mo.x),\n\t\t\t\t1.0 + 2.0 * mo.y,\n\t\t\t\t0.5 + 4.0 * sin( 6.0 * mo.x))*(2.*(sin(iTime*.2)+1.2));\n\t\t\t// camera-to-world transformation\n\t\t\tmat3 ca = setCamera(ro, ta, 0.0);\n\t\t\t// ray direction\n  \n\n\t\t\tvec3 rd = ca * normalize(vec3(p.xy, 2.5));\n            \n                        vec3 centerray=normalize(ca * normalize(vec3(0,0, 2.5)));\n                  float uppness=( abs(dot(mix(rd,centerray,-0.1),vec3(0,1,0))));\n            uppness*=uppness;\n \n            uppness=1.-uppness; \n                UV= centerray.xz*uppness*1.1;\n\t\t\t// render\t\n\t\t\tvec3 col = render(ro, rd);\n\t\t\t// gamma\n\t\t\tcol = pow(col, vec3(0.4545));\n\t\t\ttot += col;\n # if AA > 1\n\t\t}\n\ttot /= float(AA * AA);\n #\tendif\n\tfragColor = vec4(tot, 1.0);\n}","name":"Image","description":"","type":"image"}]}