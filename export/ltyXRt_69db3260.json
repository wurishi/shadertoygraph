{"ver":"0.1","info":{"id":"ltyXRt","date":"1576860173","viewed":50,"name":"GR - Rotating Wave S (Hug Edge)","username":"bradleygriffith","description":"wave","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["wave"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14159265358\n\n//bool isinf(float val) {\n//    return (val != 0.0 && val * 2.0 == val) ? true : false;\n//}\n\n// Fix a floating point number to two decimal places\nfloat toFixedTwo(float f) {\n    return float(int(f * 100.0)) / 100.0;\n}\n\n// Returns the slope of a line given the degrees of the angle on which that line is rotated;\nfloat slopeForDegrees(float deg) {\n\t// Ensure degrees stay withing 0.0 - 360.0\n    deg = mod(deg, 360.0);\n    \n    float radians = deg * (PI / 180.0);\n\n    return tan(radians);\n}\n\n// Returns slope adjusted for screen ratio.\nfloat normalizedSlope(float slope) {\n    vec2 p = vec2(1.0) / iResolution.xy;\n\treturn ((slope * 100.0) / p.x) / (100.0 / p.x);\n}\n\n// Returns offsets (+/-) for any coordinate at distance given slope.\n//   Note: This function does not normalize distance.\n//   Note: This function does not adjust slope for screen ratio.\nvec2 offsetsForCoordAtDistanceOnSlope(float d, float slope) {\n\treturn vec2(\n        (d * cos(atan(slope))),\n        (d * sin(atan(slope)))\n    );\n}\n\n// Returns a boolean designating whether or not an infinite line intersects with an infinite line, and sets an `out` variable for the intersection point if it is found.\n//   Note: This function does not adjust slope for screen ratio.\nbool lineLineIntersection (out vec2 intersect, in vec2 p1, in float m1, in vec2 p2, in float m2) {\n\t// See: http://gamedev.stackexchange.com/questions/44720/line-intersection-from-parametric-equation\n\t//      http://stackoverflow.com/questions/41687083/formula-to-determine-if-an-infinite-line-and-a-line-segment-intersect/41687904#41687904\n\n\tbool isIntersecting = false;\n\n\tfloat dx = 1.0;\n\tfloat dy = m1;\n\n\tfloat dxx = 1.0;\n\tfloat dyy = m2;\n\n\tfloat denominator = ((dxx * dy) - (dyy * dx));\n\tif (denominator == 0.0) {\n\t\t// Lines are parallel\n\t\treturn isIntersecting;\n\t}\n    \n   \tif (isinf(dy)) {\n\t\tisIntersecting = true;\n\t\tintersect = vec2(p1.x, p2.y);\n\t\treturn isIntersecting;\n\t}\n\n\tif (isinf(dyy)) {\n\t\tisIntersecting = true;\n\t\tintersect = vec2(p2.x, p1.y);\n\t\treturn isIntersecting;\n\t}\n\n\tfloat u = ((dx * (p2.y - p1.y)) + (dy * (p1.x - p2.x))) / denominator;\n\n\tisIntersecting = true;\n\tintersect = p2 + (u * vec2(dxx, dyy));\n\n\treturn isIntersecting;\n}\n\n// Returns a boolean designating whether or not an infinite line intersects with a line segment, and sets an `out` variable for the intersection point if it is found.\n//   Note: This function does not adjust slope for screen ratio.\nbool lineLineSegmentIntersection (out vec2 intersect, in vec2 point, in float m, in vec2 pA, in vec2 pB) {\n\t// See: http://gamedev.stackexchange.com/questions/44720/line-intersection-from-parametric-equation\n\t//      http://stackoverflow.com/questions/41687083/formula-to-determine-if-an-infinite-line-and-a-line-segment-intersect/41687904#41687904\n\n\tbool isIntersecting = false;\n\n\tfloat dx = 1.0;\n\tfloat dy = m;\n\n\tfloat dxx = pB.x - pA.x;\n\tfloat dyy = pB.y - pA.y;\n\n\tfloat denominator = ((dxx * dy) - (dyy * dx));\n\tif (denominator == 0.0) {\n\t\t// Lines are parallel\n\t\treturn isIntersecting;\n\t}\n\n\tif (isinf(dy)) {\n\t\tisIntersecting = true;\n\t\tintersect = vec2(point.x, pB.y);\n\t\treturn isIntersecting;\n\t}\n\n\tfloat u = ((dx * (pA.y - point.y)) + (dy * (point.x - pA.x))) / denominator;\n\n\tif (u >= 0.0 && u <= 1.0) {\n\t\t// Intersection occured on line segment\n\t\tisIntersecting = true;\n\t\tintersect = pA + (u * vec2(dxx, dyy));\n\t}\n\n\treturn isIntersecting;\n}\n\n// Dev Note: Terrible code. Needs refactor. Just trying to find \n//   which two edges of the rect the intersections occur at.\nvoid intersectsOnRectForLine(out vec2 iA, out vec2 iB, in vec2 rMinXY, in vec2 rMaxXY, in vec2 point, in float slope) {\n\tbool firstIntersectFound = false;\n\n\tvec2 intersectA = vec2(0.0);\n\tvec2 intersectB = vec2(0.0);\n\tvec2 intersectC = vec2(0.0);\n\tvec2 intersectD = vec2(0.0);\n\n\tbool intersectsLeft = lineLineSegmentIntersection(intersectA, point, slope, rMinXY, vec2(rMinXY.x, rMaxXY.y));\n\tbool intersectsTop = lineLineSegmentIntersection(intersectB, point, slope, vec2(rMinXY.x, rMaxXY.y), rMaxXY);\n\tbool intersectsRight = lineLineSegmentIntersection(intersectC, point, slope, rMaxXY, vec2(rMaxXY.x, rMinXY.y));\n\tbool intersectsBottom = lineLineSegmentIntersection(intersectD, point, slope, rMinXY, vec2(rMaxXY.x, rMinXY.y));\n\n\tif (intersectsLeft) {\n\t\tiA = intersectA;\n\t\tfirstIntersectFound = true;\n\t}\n    \n\tif (intersectsTop) {\n\t\tif (firstIntersectFound) {\n\t\t\tiB = intersectB;\n\t\t}\n\t\telse {\n\t\t\tiA = intersectB;\n\t\t\tfirstIntersectFound = true;\n\t\t}\n\t}\n    \n\tif (intersectsRight) {\n\t\tif (firstIntersectFound) {\n\t\t\tiB = intersectC;\n\t\t}\n\t\telse {\n\t\t\tiA = intersectC;\n\t\t\tfirstIntersectFound = true;\n\t\t}\n\t}\n    \n\tif (intersectsBottom) {\n\t\tif (firstIntersectFound) {\n\t\t\tiB = intersectD;\n\t\t}\n\t\telse {\n\t\t\tiA = intersectD;\n\t\t}\n\t}\n}\n\nfloat isWave(vec2 uv, float deg, float wavelength, float edgeDistance, float centerDistance) {\n    \n    // Setup\n    // -------------------------------\n    \n    // Dev Note: I've seen some strange artifacting when the input degrees have\n    //   a high number of decimal places. Fixing degrees to a max of two decimal places\n    //   fixes this bug. Not sure that it's the full solution but the problem is mitigated.\n\tdeg = toFixedTwo(deg);\n    \n    vec2 centerUv = vec2(0.5);\n\tfloat slope = normalizedSlope(slopeForDegrees(deg));\n    float perpendicularDeg = mod(deg + 90.0, 360.0); // Offset angle by 90.0, but keep it from exceeding 360.0\n    float perpendicularSlope = normalizedSlope(slopeForDegrees(perpendicularDeg));\n   \n\n    // Get wave details\n    // -------------------------------\n\n    // Find point on elipses (imagine oval where radius moves between half height and half width) for perpendicularDeg, adjusting for \n    //   distance from, center space, and amplitude of our wave. Resolution x/y divided by 4 for two waves on screen with amplitude \n    //   equal to 1/4 directional resolution.\n    float ampX = (((iResolution.x / 4.0) - (edgeDistance / 2.0) - (centerDistance / 2.0)) * cos(perpendicularDeg * (PI / 180.0)));\n    float ampY = (((iResolution.y / 4.0) - (edgeDistance / 2.0) - (centerDistance / 2.0)) * sin(perpendicularDeg * (PI / 180.0)));\n    float amplitude = distance(vec2(0.0), vec2(ampX, ampY));\n\n    // Find point on elipses (imagine oval where radius moves between half height and half width) for perpendicularDeg, adjusting for \n    //   distance from, center space, and amplitude of our wave. Resolution x/y divided by 4 for two waves on screen with amplitude \n    //   equal to 1/4 directional resolution. We add centerDistance here (note amplitude subtracts it) to push radius towards edge,\n    //   adjusting for shortened amplitude.\n  \tfloat radiusX = (((iResolution.x / 4.0) - (edgeDistance / 2.0) + (centerDistance / 2.0)) * cos(perpendicularDeg * (PI / 180.0)));\n  \tfloat radiusY = (((iResolution.y / 4.0) - (edgeDistance / 2.0) + (centerDistance / 2.0)) * sin(perpendicularDeg * (PI / 180.0)));\n    float radius = abs(distance(vec2(0.0), vec2(radiusX, radiusY)));\n    \n    \n    // Get offset UVs for width of line, adjacent to center point\n    // -------------------------------\n\n    float angleA = perpendicularDeg;\n    float angleB = mod(perpendicularDeg + 180.0, 360.0); // Offset angle by 180.0, but keep it from exceeding 360.0\n    \n    float slopeA = normalizedSlope(slopeForDegrees(angleA));\n    float slopeB = normalizedSlope(slopeForDegrees(angleB));\n    \n    vec2 kA = offsetsForCoordAtDistanceOnSlope(radius, slopeA);\n    vec2 kB = offsetsForCoordAtDistanceOnSlope(radius, slopeB);\n    \n    vec2 offsetCoordA = centerUv * iResolution.xy;\n    vec2 offsetCoordB = centerUv * iResolution.xy;\n    \n    if (angleA <= 90.0 || angleA >= 270.0) {\n        offsetCoordA += kA;\n    }\n    else {\n        offsetCoordA -= kA;\n    }\n\n    if (angleB <= 90.0 || angleB >= 270.0) {\n        offsetCoordB += kB;\n    }\n    else {\n        offsetCoordB -= kB;\n    }\n\t\n    // Denormalize uvs and uv offsets and find closest point on line for our uv, then renormalize.\n    vec2 uvA = vec2(0.0);\n\tlineLineIntersection(uvA, offsetCoordA, slope, uv * iResolution.xy, perpendicularSlope);\n\tuvA /= iResolution.xy;\n    vec2 uvB = vec2(0.0);\n\tlineLineIntersection(uvB, offsetCoordB, slope, uv * iResolution.xy, perpendicularSlope);\n\tuvB /= iResolution.xy;\n\n\n\t// Find intersects for line with edges of viewport\n    // -------------------------------\n\n    vec2 uvAIntersectA = vec2(0.0);\n    vec2 uvAIntersectB = vec2(0.0);\n    intersectsOnRectForLine(uvAIntersectA, uvAIntersectB, vec2(0.0), iResolution.xy, offsetCoordA, slope);\n    \n    vec2 uvBIntersectA = vec2(0.0);\n    vec2 uvBIntersectB = vec2(0.0);\n    intersectsOnRectForLine(uvBIntersectA, uvBIntersectB, vec2(0.0), iResolution.xy, offsetCoordB, slope);\n    \n    vec2 perpendicularIntersectA = vec2(0.0);\n    vec2 perpendicularIntersectB = vec2(0.0);\n    // Note: We use `uvA` here. `uvB` would have same effect and what we want is to\n    //   find the intersect perpedicular to the uv's closest point on the line.\n    intersectsOnRectForLine(perpendicularIntersectA, perpendicularIntersectB, vec2(0.0), iResolution.xy, uvA * iResolution.xy, perpendicularSlope); \n\t\n    \n    // Prepare wave\n    // -------------------------------\n    \n    // Find length of each edge of line in relation to the viewport, and to the\n    //   perpendicular line cutting through each uv's closest point on the line.\n    float aLength = distance(uvAIntersectA, uvAIntersectB);\n    float bLength = distance(uvBIntersectA, uvBIntersectB);\n    float perpendicularIntersectionLength = distance(perpendicularIntersectA, perpendicularIntersectB);\n\n    // Find percent of edge length that the uv's closest point on the line constitutes\n    //   for each edge of the line.\n    float aDistance = (distance(offsetCoordA, uvA * iResolution.xy) / aLength) - ((wavelength / 4.0) / aLength);\n    float bDistance = (distance(offsetCoordB, uvB * iResolution.xy) / bLength) - ((wavelength / 4.0) / bLength);\n\n    // Create wave, adjusting input wavelength and amplitude (in pixels) in accordance with\n    //   resolution of line edges along the line's slope. This is kind of convuluted so \n    //   consider a value between 0 and 1 on a diagonal line. That's the value on which each\n\t//   'pixel' of the wave's edge must be based. \n    float varianceA = sin(aDistance * PI * (aLength / (wavelength / 2.0))) * (amplitude / perpendicularIntersectionLength);\n    float varianceB = sin(bDistance * PI * (bLength / (wavelength / 2.0))) * (amplitude / perpendicularIntersectionLength);\n    varianceA *= perpendicularIntersectionLength;\n    varianceB *= perpendicularIntersectionLength;\n\n    // Use wave variance as offsets of each point along our line and adjust each uv's closest\n    //   point on the line accordingly.\n    vec2 kVA = offsetsForCoordAtDistanceOnSlope(varianceA, slopeA);\n    vec2 kVB = offsetsForCoordAtDistanceOnSlope(varianceB, slopeB);\n    \n    if (angleA <= 90.0 || angleA >= 270.0) {\n        offsetCoordA += kVA;\n    }\n    else {\n        offsetCoordA -= kVA;\n    }\n    \n    if (angleB <= 90.0 || angleB >= 270.0) {\n\t\toffsetCoordB += kVB;\n    }\n    else {\n    \toffsetCoordB -= kVB;\n    }\n  \t\n\tlineLineIntersection(uvA, offsetCoordA, slope, uv * iResolution.xy, perpendicularSlope);\n\tuvA /= iResolution.xy;\n\tlineLineIntersection(uvB, offsetCoordB, slope, uv * iResolution.xy, perpendicularSlope);\n\tuvB /= iResolution.xy;\n    \n\n    // Define wave edges\n    // -------------------------------\n    \n   \tfloat distX = abs(step(uvB, uv).x - step(uvA, uv).x);\n   \tfloat distY = abs(step(uvB, uv).y - step(uvA, uv).y);\n   \tfloat wave = max(distX, distY);\n\n\n    return wave;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\t\n    // Setup\n    // -------------------------------\n    \n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\n    lowp float deg = 90.0;\n\n    float wavelength = 100.0;\n\n    if (iMouse.z > 0.0) {\n    \twavelength = iMouse.x;\n    }\n\n    float distanceFromEdge = 20.0;\n    float distanceFromCenter = 50.0;\n\tfloat speed = 0.025;\n    \n\n    // Prepare edge details \n    // -------------------------------\n\n\tdeg = fract(iTime * speed) * 360.0;\n    float wave = isWave(uv, deg, wavelength, distanceFromEdge, distanceFromCenter);\n    \n    fragColor = 1.0 - vec4(wave);\n}","name":"Image","description":"","type":"image"}]}