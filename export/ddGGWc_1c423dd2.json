{"ver":"0.1","info":{"id":"ddGGWc","date":"1692041231","viewed":36,"name":"gkurve segments (r11-clean)","username":"slimsag","description":"gkurve","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["gkurve"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define NUM_POINTS 5\n\nfloat dist(vec2 a, vec2 b) {\n    return sqrt(pow(b.x-a.x, 2.0) + pow(b.y-a.y, 2.0));\n}\nvec2 midpoint(vec2 a, vec2 b) {\n    return vec2((a.x+b.x)*0.5, (a.y+b.y)*0.5);\n}\nfloat slope(vec2 a, vec2 b) {\n    return (b.y-a.y)/(b.x-a.x)+1e-100;\n}\nvec2 scalep(vec2 p, vec2 center, float scaleFactor) {\n    return scaleFactor * (p - center) + center;\n}\n\n// returns the distance from p to an oriented linear gradient.\n//\n// The gradient is linear and has two stops: 0.0 to 1.0\n// The gradient is oriented such that z0 and z1 are both 0.0 values.\n// The gradient is oriented such that e is a 1.0 value.\nfloat gradient(vec2 p, vec2 z0, vec2 z1, vec2 e) {\n    vec2 e_z1 = e - z1;\n    vec2 p_z1 = p - z1;\n    float z0_z1_y = z0.y - z1.y;\n    float z1_z0_x = z1.x - z0.x;\n    float n = z0_z1_y*p_z1.x + z1_z0_x*p_z1.y;\n    float d = z0_z1_y*e_z1.x + z1_z0_x*e_z1.y;\n    return n/d;\n}\n\n// returns a value describing which side of a line p is on.\nfloat line(vec2 p, vec2 z0, vec2 z1) {\n    return gradient(p, z0, z1, z1);\n}\n\nfloat clmp(float v) {\n    return clamp(v, 0., 1.);\n}\n\nfloat isConcave(vec2 a, vec2 b, vec2 c) {\n    mat2 v = mat2(\n        (b.x - a.x), (c.x - a.x),\n        (b.y - a.y), (c.y - a.y)\n    );\n    if (determinant(v) < 0.0) {\n        return 1.0;\n    }\n    return -1.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float size = 200.0;\n    vec2 p = fragCoord;\n\n    // User-input points (on-curve)\n    vec2 p0 = vec2(size*2.0, size*1.0);\n    vec2 p1 = vec2(size*1.0, size*1.75);\n    vec2 p2 = vec2(size*2.0, size*2.5);\n    vec2 p3 = vec2(size*3.5, size*2.5);\n    vec2 p4 = vec2(size*4.0, size*1.2);\n    p1 = iMouse.xy;\n\n    // Derived continuity points\n    vec2 pc0 = midpoint(p0, p1);\n    vec2 pc1 = midpoint(p1, p2);\n    vec2 pc2 = midpoint(p2, p3);\n    vec2 pc3 = midpoint(p3, p4);\n    vec2 pc4 = midpoint(p4, p0);\n\n    // Derived off-curve control points\n    float k0 = 1.0;\n    float k1 = 0.0;\n    vec2 c0 = scalep(p0, midpoint(p1, p4), k0); // derived off-curve point\n    vec2 c1 = scalep(p1, midpoint(p0, p2), k0); // derived off-curve point\n    vec2 c2 = scalep(p2, midpoint(p1, p3), k0); // derived off-curve point\n    vec2 c3 = scalep(p3, midpoint(p2, p4), k0); // derived off-curve point\n    vec2 c4 = scalep(p4, midpoint(p3, p0), k0); // derived off-curve point\n\n    // Derived continuity control points\n    vec2 cc0 = scalep(c0, c1, (1./3.)*2.);\n    vec2 cc1 = scalep(c0, c1, (1./3.)*1.);\n    vec2 cc2 = scalep(c1, c2, (1./3.)*2.);\n    vec2 cc3 = scalep(c1, c2, (1./3.)*1.);\n    vec2 cc4 = scalep(c2, c3, (1./3.)*2.);\n    vec2 cc5 = scalep(c2, c3, (1./3.)*1.);\n    vec2 cc6 = scalep(c3, c4, (1./3.)*2.);\n    vec2 cc7 = scalep(c3, c4, (1./3.)*1.);\n    vec2 cc8 = scalep(c4, c0, (1./3.)*2.);\n    vec2 cc9 = scalep(c4, c0, (1./3.)*1.);\n    pc0 = scalep(pc0, midpoint(cc0, cc1), k1);\n    pc1 = scalep(pc1, midpoint(cc2, cc3), k1);\n    pc2 = scalep(pc2, midpoint(cc4, cc5), k1);\n    pc3 = scalep(pc3, midpoint(cc6, cc7), k1);\n    pc4 = scalep(pc4, midpoint(cc8, cc9), k1);\n\n    vec2 points[NUM_POINTS*2] = vec2[](\n        pc4, p0, pc0, p1, pc1, p2, pc2, p3, pc3, p4\n    );\n    vec2 cpoints[NUM_POINTS] = vec2[](\n        c0, c1, c2, c3, c4\n    );\n\n    /*\n    // Draw points\n    for (int i = 0; i < NUM_POINTS*2; i++) {\n        // User input points\n        if (i % 2 == 1 && dist(fragCoord, points[i]) < 10.0) {\n            fragColor = vec4(1, 1, 1, 1);\n            return;\n        }\n\n        // Derived continuity points\n        if (dist(fragCoord, points[i]) < 7.5) {\n            fragColor = vec4(0, 0, 0, 1);\n            return;\n        }\n        if (dist(fragCoord, points[i]) < 10.0) {\n            fragColor = vec4(1, 1, 1, 1);\n            return;\n        }\n    }\n    */\n\n    float mix = 0.0;\n    for (int i=0; i < 2*NUM_POINTS; i+=2) {\n        vec2 p0 = points[(i+0) % (2*NUM_POINTS)];\n        vec2 p1 = points[(i+1) % (2*NUM_POINTS)];\n        vec2 p2 = points[(i+2) % (2*NUM_POINTS)];\n        vec2 c0 = cpoints[(((i/2)+0) % (NUM_POINTS))];\n\n        float blend0 = 1.-gradient(p, p0, c0, p2);\n        float blend1 = 1.-gradient(p, p2, c0, p0);\n\n        float clip0 = line(p, p1, p0);\n        float clip1 = line(p, p2, p1);\n        float clip2 = line(p, p0, p2);\n\n        float convex_gradient = 1.-(blend0*blend0+blend1*blend1);\n        float concave = isConcave(p0, p1, p2);\n        float clip = clmp(clip0*concave)*clmp(clip1*concave)*clmp(clip2*concave);\n        float iclip = 1.0-clip;\n\n        if (concave == -1.0) {\n            convex_gradient = (blend0*blend0+blend1*blend1)-1.;\n        }\n\n        vec2 pxy = vec2(dFdx(convex_gradient), dFdy(convex_gradient));\n        float fx = convex_gradient * pxy.x-pxy.x;\n        float fy = convex_gradient * pxy.y-pxy.y;\n        float base = sqrt(fx*fx + fy*fy);\n        if (iclip < 1.0) {\n            mix = (convex_gradient/(base*100.0))*clip+iclip;\n        }\n    }\n\n    float ga = mix;\n    if (ga > 0.00 && ga < 1.0/100.0) {\n        fragColor = vec4(0, 1, 0, 1);\n        return;\n    }\n    fragColor = vec4(ga, 0, 0, 1.0);\n    return;\n}\n","name":"Image","description":"","type":"image"}]}