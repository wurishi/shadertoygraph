{"ver":"0.1","info":{"id":"XclSzs","date":"1714838268","viewed":106,"name":"RefactorJFig2022&2023","username":"bowari","description":"This shader is a composition and an improvement of the two shaders I submitted to the JFIG for the years 2022 and 2023 : https://www.shadertoy.com/view/sltfz4 and https://www.shadertoy.com/view/clySz3.","likes":11,"published":1,"flags":32,"usePreview":1,"tags":["pathtracing","bsdf","jfig"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// ------------------------------------------------------------------------------------------\n// ------------------------------------ POST-PROCESSING -------------------------------------\n// ------------------------------------------------------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){        \n    fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    vec3 col = fragColor.xyz/fragColor.w;\n    \n    // tone map (aces)\n    float a = 2.51;\n    float b = 0.03;\n    float c = 2.43;\n    float d = 0.59;\n    float e = 0.14;\n    col = clamp((col * (a * col + b)) / (col * (c * col + d ) + e), 0., 1.);\n    \n    // gamma correction\n    col = pow(col,vec3(1./2.2));\n    \n    fragColor = vec4(col,1.);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// --- constants ---\n#define INV_PI    0.318309\n#define PI        3.141592\n#define PI_TWO    1.570796\n#define PI_THREE  1.047197\n#define PI_SIX    0.523598\n#define TWO_PI    6.283185\n\n// --- camera ---\n#define POS_CAM         vec3(20.,-60.,20.)\n#define LOOKAT          vec3(0.)\n#define FOCAL_DISTANCE  2.5\n#define FOVY            PI_THREE\n#define GAMMA           2.2\n\n// --- others ---\nuint seed;\n#define AA                1\n#define NB_OBJ            14.\n#define NB_BOUNCE         10\n#define MAX_STEP          100\n#define FAR               500.\n#define EPS_NORMAL        0.01\n#define EPS               0.001\n#define EPS_OH            0.0015\nbool[int(NB_OBJ)] shrinkScene;\n\n#define Z min(iFrame,0)\n#define pow2(a) (a)*(a)\n#define pow5(a) (a)*(a)*(a)*(a)*(a)\n\n// ------------------------------------------------------------------------------------------\n// ----------------------------------------- RANDOM -----------------------------------------\n// ------------------------------------------------------------------------------------------\n\n// https://www.pcg-random.org/download.html\nuint pcg(){\n    uint state = seed*747796405U+2891336453U;\n    uint tmp  = ((state >> ((state >> 28U) + 4U)) ^ state)*277803737U;\n    return (seed = (tmp >> 22U) ^ tmp);\n}\n\nfloat rand(){return float(pcg())/float(0xffffffffU);}\n\n// ------------------------------------------------------------------------------------------\n// --------------------------------------- MATERIAL -----------------------------------------\n// ------------------------------------------------------------------------------------------\n\nstruct Material{\n    vec3  albedo;           // [0, 1]\n    vec3  emissive;         // [0, +inf[\n    float metalness;        // [0, 1]\n    float roughness;        // [0, 1]\n    float transmitness;     // [0, 1]\n    vec3  absorptionColor;  // [0, 1]\n    float absorptionDensity;// [0, +inf[\n    float ior;              // [0, +inf[\n};\n\nstruct HitRecord{\n    vec3 point;\n    vec3 pointOffsetRefract;\n    vec3 pointOffsetReflect;\n    vec3 normal;\n    float ni;\n    float no;\n    Material material;\n};\n\nstruct AABB{\n    vec3 mini;\n    vec3 maxi;\n};\n\nstruct Ray{\n    vec3 o;\n    vec3 d;\n};\n\n// ------------------------------------------------------------------------------------------\n// ----------------------------------------- BSDF -------------------------------------------\n// ------------------------------------------------------------------------------------------\n\n// fresnel for normal incidence cosTi = cosTo = 1\nfloat fresnel(in float ni, in float no){\n    return pow2((ni-no)/(ni+no));\n}\n\nfloat schlick(in float f0, in float f90, in float cosT){\n    return f0 + (f90-f0) * pow5(1.-cosT);\n} \n\nvec3 schlick(in vec3 f0, in vec3 f90, in float cosT){ \n\treturn f0 + (f90-f0) * pow5(1.-cosT);\n}\n\n// sampling GGX VNDF Dupuy 2023 : https://arxiv.org/pdf/2306.05044.pdf\nvec3 sampleGGXVNDF(in vec3 V, in vec3 N, float rx, float ry) {\n    // https://graphics.pixar.com/library/OrthonormalB/paper.pdf\n    float s = (N.z>=0.) ? 1. : -1.;\n\tfloat a = -1./(s+N.z);\n\tfloat b = N.x*N.y*a;\n\tvec3 T = vec3(1.+s*N.x*N.x*a, s*b, -s*N.x);\n\tvec3 B = vec3(b,s+N.y*N.y*a, -N.y);\n\n    V = vec3(dot(V,T), dot(V,B), dot(V,N));\n    vec3 Vh = normalize(V*vec3(rx,ry,1.));\n\n    float phi = TWO_PI*rand();\n    float z = (1.-rand())*(1.+Vh.z)-Vh.z;\n    float sinTheta = sqrt(clamp(1.-z*z,0.,1.));\n    vec3 Nh = normalize(vec3(sinTheta*cos(phi),sinTheta*sin(phi),z)+Vh);\n    vec3 Ne = normalize(Nh*vec3(rx,ry,1.));\n\n    return normalize(Ne.x*T + Ne.y*B + Ne.z*N);\n}\n\nvec3 sampleHemisphere(in vec3 N) {\n    float a = TWO_PI * rand();\n    float b = 2.*rand()-1.;\n    return normalize(N+vec3(sqrt(1.-b*b)*vec2(cos(a),sin(a)), b));\n}\n\nRay evaluateBSDF(in Ray p_ray, in HitRecord p_hitRecord, inout vec3 p_rayColor){     \n    float r = pow2(clamp(p_hitRecord.material.roughness, 0.01, 0.99));\n    float r2 = r*r;\n    \n    vec3 V = -p_ray.d;\n    vec3 N = p_hitRecord.normal;\n    vec3 H = sampleGGXVNDF(V,N,r,r);\n    \n    float DielF = schlick(fresnel(p_hitRecord.ni, p_hitRecord.no), 1., max(0.,dot(H,V)));\n    float cosNV = max(1e-5, abs(dot(N,V)));\n\n    float diffuseRate = (1.-p_hitRecord.material.metalness)*(1.-p_hitRecord.material.transmitness);\n    float specularRate = DielF; \n    float transmitRate = p_hitRecord.material.transmitness*(1.-p_hitRecord.material.metalness)*(1.-DielF);\n    float GlobalRate = rand();\n    \n    // --- transmition ---\n    if (GlobalRate <= transmitRate) {\n        vec3 transmitRayDir = refract(p_ray.d, H, p_hitRecord.ni/p_hitRecord.no);\n        if (!(transmitRayDir.x==0. && transmitRayDir.y==0. && transmitRayDir.z==0.)) { \n            Ray transmitRay = Ray(p_hitRecord.pointOffsetRefract, normalize(transmitRayDir));\n                    \n            float cosNL = max(0.,dot(-N, transmitRay.d));\n                    \n            float XL = sqrt(r2 + (1. - r2) * cosNL * cosNL);\n            float XV = sqrt(r2 + (1. - r2) * cosNV * cosNV);\n            float G1L = 2. * cosNL / max(1e-5, (cosNL + XL));\n            float G1V = 2. * cosNV / max(1e-5, (cosNV + XV));\n            float G2 = 2. * cosNL * cosNV / max(1e-5, (cosNV * XL + cosNL * XV));\n\n            p_rayColor *= sqrt(p_hitRecord.material.albedo) * (1.-DielF)*G2*pow2(p_hitRecord.ni/p_hitRecord.no)/max(1e-5,G1L);     \n            return transmitRay;\n        }\n    }\n    \n    // --- specular ---\n    if (GlobalRate <= specularRate/(diffuseRate+specularRate)) {\n        Ray specularRay = Ray(p_hitRecord.pointOffsetReflect, normalize(reflect(p_ray.d, H)));\n                \n        float cosNL = max(0.,dot(N, specularRay.d));\n        float cosHL = max(0.,dot(H, specularRay.d));\n\n        vec3 f0 = mix(vec3(1.), p_hitRecord.material.albedo, p_hitRecord.material.metalness);\n        vec3 F = schlick(f0, vec3(1.), cosHL);\n        float XL = sqrt(r2 + (1. - r2) * cosNL * cosNL);\n        float XV = sqrt(r2 + (1. - r2) * cosNV * cosNV);\n        float G1L = 2. * cosNL / max(1e-5, (cosNL + XL));\n        float G1V = 2. * cosNV / max(1e-5, (cosNV + XV));\n        float G2 = 2. * cosNL * cosNV / max(1e-5, (cosNV * XL + cosNL * XV));\n\n        p_rayColor *= F*G2/max(1e-5,G1V);\n        return specularRay;\n    }\n    \n    // --- diffuse ---\n    Ray diffuseRay = Ray(p_hitRecord.pointOffsetReflect, sampleHemisphere(N));\n\n    float cosNL = max(0.,dot(N, diffuseRay.d));\n    float cosHL = max(0.,dot(normalize(diffuseRay.d+V), diffuseRay.d));\n\n    float Rr = r*2.*cosHL*cosHL+0.5;\n    float Fl = pow5(1.-cosNL);\n    float Fv = pow5(1.-cosNV);\n\n    p_rayColor *= p_hitRecord.material.albedo * ((1.-0.5*Fl) * (1.-0.5*Fv) + Rr*(Fl+Fv+Fl*Fv*(Rr-1.)));\n\n    return diffuseRay;\n} \n\n// ------------------------------------------------------------------------------------------\n// --------------------------------------- OPERATIONS ---------------------------------------\n// ------------------------------------------------------------------------------------------\n\n// ****** mix ******\nfloat op_union( in float p_sdf1, in float p_sdf2 ) {\n\treturn (p_sdf1<p_sdf2) ? p_sdf1 : p_sdf2;\n}\n\nfloat op_Sunion( in float p_sdf1, in float p_sdf2, float p_factor ) {\n    float tmp = clamp( 0.5 + 0.5*(p_sdf2-p_sdf1)/p_factor, 0., 1. );\n    return mix( p_sdf2, p_sdf1, tmp ) - p_factor*tmp*(1.-tmp); \n}\n\nfloat op_intersection( in float p_sdf1, in float p_sdf2 ) {\n    return (p_sdf1>p_sdf2) ? p_sdf1 : p_sdf2;\n}\n\nfloat op_Sintersection( in float p_sdf1, in float p_sdf2, float p_factor ) {\n    float tmp = clamp( 0.5 - 0.5*(p_sdf2-p_sdf1)/p_factor, 0., 1. );\n    return mix( p_sdf2, p_sdf1, tmp ) + p_factor*tmp*(1.-tmp);  \n}\n\nfloat op_substraction( in float p_sdf1, in float p_sdf2 ) {\n    return (p_sdf1>-p_sdf2) ? p_sdf1 : -p_sdf2;\n}\n\nfloat op_Ssubstraction( in float p_sdf1, in float p_sdf2, float p_factor ) {\n    float tmp = clamp( 0.5 - 0.5*(p_sdf2+p_sdf1)/p_factor, 0., 1. );\n    return mix( p_sdf1, -p_sdf2, tmp ) + p_factor*tmp*(1.-tmp);  \n}\n\n// ****** transformations ******\nvec3 op_translatePoint( in vec3 p_point, in vec3 p_translation ) {\n    return p_point - p_translation;\n}\n\nvec3 op_rotatePoint( in vec3 p_point, in vec3 p_angle) {\n    vec3 c = vec3(cos(p_angle.x),cos(p_angle.y),cos(p_angle.z));\n    vec3 s = vec3(sin(p_angle.x),sin(p_angle.y),sin(p_angle.z));\n    \n    mat3 rotateX = mat3(1., 0., 0., 0., c.x, -s.x, 0., s.x, c.x);\n    mat3 rotateY = mat3(c.y, 0., s.y, 0., 1., 0., -s.y, 0., c.y);\n    mat3 rotateZ = mat3(c.z, -s.z, 0., s.z, c.z, 0., 0., 0., 1.);\n    \n    return p_point*rotateZ*rotateY*rotateX;\n}\n\n// ****** other ******\nfloat op_round( in float p_sdf, in float p_radius ){\n    return p_sdf - p_radius;\n}\n\nfloat op_onion( in float p_sdf, in float p_h ){\n    return abs(p_sdf)-p_h;\n}\n\n// ------------------------------------------------------------------------------------------\n// ------------------------------------------ SDF -------------------------------------------\n// ------------------------------------------------------------------------------------------\n\nfloat sdf_sphere( in vec3 p_point, in float p_radius ){\n    return length(p_point)-p_radius;\n}\n\nfloat sdf_plane( in vec3 p_point, in vec3 p_normal, in float p_h ){\n    return dot(p_point,p_normal)+p_h;\n}\n\nfloat sdf_cylinder( in vec3 p_point, in float p_h, in float p_radius ){\n    vec2 tmp = vec2(length(p_point.xy)-p_radius,abs(p_point.z)-p_h);\n    return min(max(tmp.x,tmp.y),0.) + length(max(tmp,0.));\n}\n\nfloat sdf_capsule( in vec3 p_point, in float p_h, in float p_radius ){\n  p_point.z -= clamp( p_point.z, 0., p_h );\n  return length(p_point) - p_radius;\n}\n\nfloat sdf_box( in vec3 p_point, in vec3 p_bound ){\n    vec3 q = abs(p_point) - p_bound;\n    return length(max(q,0.)) + min(max(q.x,max(q.y,q.z)),0.);\n}\n\nfloat sdf_torus( in vec3 p_point, in float p_radius, float p_thickness ){\n    return length(vec2(length(p_point.xz)-(p_radius-p_thickness*0.5), p_point.y)) - p_thickness*0.5;\n}\n\n// https://www.shadertoy.com/view/3tBcDR\nfloat sdf_ellipsoid( in vec3 p_point, in vec3 p_radius ){\n    float k = length(p_point/p_radius);\n    return (k<1.) ? (k-1.)*min(p_radius.x,min(p_radius.y,p_radius.z)) : k*(k-1.)/max(1e-3,length(p_point/(p_radius*p_radius)));\n    // return k*(k-1.)/max(1e-3,length(p_point/(p_radius*p_radius)));\n}\n\n// ------------------------------------------------------------------------------------------\n// -------------------------------------- ACCELERATOR ---------------------------------------\n// ------------------------------------------------------------------------------------------\n\nbool intersectAABB( in Ray p_ray, in AABB p_aabb, in float p_tMin, in float p_tMax ){ \n    vec3 tmin = (p_aabb.mini - p_ray.o) / p_ray.d; // care divide by 0 !\n\tvec3 tmax = (p_aabb.maxi - p_ray.o) / p_ray.d; // care divide by 0 !\n\n\tvec3 a = min(tmin, tmax);\n\tvec3 b = max(tmin, tmax);\n\n\tfloat tnear = max(max(a.x, a.y), a.z);\n\tfloat tfar = min(min(b.x, b.y), b.z);\n\n\treturn tnear<=tfar && tfar>=p_tMin && tnear<=p_tMax;\n}\n\nvoid updateShrinkScene(in Ray p_ray, in float p_tMin, in float p_tMax){    \n    shrinkScene[0] = intersectAABB(p_ray,AABB(vec3(-50.,-50.,-0.75),vec3(50.,50.,0.75)),p_tMin,p_tMax);\n    shrinkScene[1] = intersectAABB(p_ray,AABB(vec3(-10.2,24.8,EPS_OH),vec3(10.2,45.2,4.4+EPS_OH)),p_tMin,p_tMax);\n    shrinkScene[2] = intersectAABB(p_ray,AABB(vec3(-10.2,-45.2,EPS_OH),vec3(10.2,-24.8,4.4+EPS_OH)),p_tMin,p_tMax);\n    shrinkScene[3] = intersectAABB(p_ray,AABB(vec3(0.9,13.9,EPS_OH),vec3(9.1,22.1,20.4+EPS_OH)),p_tMin,p_tMax);\n    shrinkScene[4] = intersectAABB(p_ray,AABB(vec3(-9.1,-22.1,EPS_OH),vec3(-0.9,-13.9,23.4+EPS_OH)),p_tMin,p_tMax);\n    shrinkScene[5] = intersectAABB(p_ray,AABB(vec3(-24.6,0.4,EPS_OH),vec3(-15.4,9.6,29.6+EPS_OH)),p_tMin,p_tMax);\n    shrinkScene[6] = intersectAABB(p_ray,AABB(vec3(-24.3,0.7,0.2+EPS_OH),vec3(-15.7,9.3,17.+EPS_OH)),p_tMin,p_tMax);\n    shrinkScene[7] = intersectAABB(p_ray,AABB(vec3(1.1,14.1,10.5+EPS_OH),vec3(8.9,21.9,14.+EPS_OH)),p_tMin,p_tMax);\n    shrinkScene[8] = intersectAABB(p_ray,AABB(vec3(-8.9,-21.9,10.5+EPS_OH),vec3(-1.1,-14.1,18.)),p_tMin,p_tMax);\n    shrinkScene[9] = intersectAABB(p_ray,AABB(vec3(-7.35,32.65,0.2+EPS_OH),vec3(7.35,37.35,5.3+EPS_OH)),p_tMin,p_tMax);    \n    shrinkScene[10] = intersectAABB(p_ray,AABB(vec3(-8.3,-43.3,-0.3),vec3(8.3,-26.7,6.3)),p_tMin,p_tMax);\n    shrinkScene[11] = intersectAABB(p_ray,AABB(vec3(-8.5,-43.5,3.2),vec3(8.5,26.5,6.8)),p_tMin,p_tMax);\n    shrinkScene[12] = intersectAABB(p_ray,AABB(vec3(-6.,-36.,5.8),vec3(6.,-34.,14.9)),p_tMin,p_tMax);\n    shrinkScene[13] = intersectAABB(p_ray,AABB(vec3(-3.1,-35.1,13.7),vec3(3.1,34.9,14.3)),p_tMin,p_tMax);\n}\n\n// ------------------------------------------------------------------------------------------\n// -------------------------------------- EVALUATIONS ---------------------------------------\n// ------------------------------------------------------------------------------------------\n\n// Evaluate the sdf witch correspond to p_num\nfloat evaluate( in vec3 p_point, in float p_num ){\n    switch(int(p_num)){\n        case 0:\n            return sdf_cylinder(op_translatePoint(p_point,-vec3(0.,0.,0.75)),0.75,50.);\n        \n        case 1:\n            p_point = op_translatePoint(p_point,vec3(0.,35.,2.2+EPS_OH));\n            float plateWBase = op_intersection(\n                                  sdf_box(p_point,vec3(15.,10.,2.)),\n                                  op_intersection(sdf_ellipsoid(p_point,vec3(15.,10.,4.)),sdf_ellipsoid(p_point,vec3(10.,15.,4.))));\n            return op_Ssubstraction(op_onion(plateWBase,0.2),sdf_plane(p_point,vec3(0.,0.,-1.),0.),0.2);\n        \n        case 2:\n            p_point = op_translatePoint(p_point,vec3(0.,-35.,2.2+EPS_OH));\n            float plateCBase = op_intersection(\n                                  sdf_box(p_point,vec3(15.,10.,2.)),\n                                  op_intersection(sdf_ellipsoid(p_point,vec3(15.,10.,4.)),sdf_ellipsoid(p_point,vec3(10.,15.,4.))));\n            return op_Ssubstraction(op_onion(plateCBase,0.2),sdf_plane(p_point,vec3(0.,0.,-1.),0.),0.2);\n            \n        case 3:\n            p_point = op_translatePoint(p_point,vec3(5.,18.,5.4+EPS_OH));\n            float glassWTop = op_substraction(\n                                 op_onion( sdf_ellipsoid(op_translatePoint(p_point,vec3(0.,0.,11.)),vec3(4.,4.,6.)),0.1 ),\n                                 sdf_plane(p_point,vec3(0.,0.,-1.),15.));\n            float glassWMid = sdf_cylinder(p_point,5.,0.4);\n            float glassWBot = sdf_cylinder(op_translatePoint(p_point,-vec3(0.,0.,5.2)),0.2,3.5);\n            return op_Sunion(glassWTop,op_Sunion(glassWMid,glassWBot,0.4),0.2);\n            \n        case 4:\n            p_point = op_translatePoint(p_point,vec3(-5.,-18.,5.4+EPS_OH));\n            float glassCTop = op_substraction(\n                                 op_onion(sdf_ellipsoid(op_translatePoint(p_point,vec3(0.,0.,13.)),vec3(4.,4.,8.)),0.1),\n                                 sdf_plane(p_point,vec3(0.,0.,-1.),18.));\n            float glassCMid = sdf_cylinder(p_point,5.,0.4);\n            float glassCBot = sdf_cylinder(op_translatePoint(p_point,-vec3(0.,0.,5.2)),0.2,3.5);\n            return op_Sunion(glassCTop,op_Sunion(glassCMid,glassCBot,0.1),0.2);\n        \n        case 5:\n            p_point = op_translatePoint(p_point,vec3(-20.,5.,8.6+EPS_OH));\n            return op_substraction(\n                      op_union(\n                         op_round(sdf_cylinder(op_translatePoint(p_point,vec3(0.,0.,20.2)),0.3,1.6),0.1),\n                         op_onion(\n                            op_Sunion(\n                               sdf_cylinder(op_translatePoint(p_point,vec3(0.,0.,16.8)),4.2,1.5),\n                               op_union(\n                                  op_substraction(\n                                     sdf_cylinder(p_point,8.5,4.5),\n                                     sdf_sphere(op_translatePoint(p_point,-vec3(0.,0.,9.5)),3.9)),\n                                  sdf_sphere(op_translatePoint(p_point,vec3(0.,0.,8.5)),4.5)),\n                               0.3),\n                            0.1)),\n                      sdf_cylinder(op_translatePoint(p_point,vec3(0.,0.,17.)),5.,1.3));\n        \n        case 6:\n            p_point = op_translatePoint(p_point,vec3(-20.,5.,8.6+EPS_OH));\n            return op_substraction(\n                     sdf_cylinder(p_point,8.4,4.3),\n                     sdf_sphere(op_translatePoint(p_point,-vec3(0.,9.5,0.)),4.1));\n        \n        case 7:\n            return op_substraction(\n                      sdf_ellipsoid(op_translatePoint(p_point,vec3(5.,18.,16.4+EPS_OH)),vec3(3.9,3.9,5.9)),\n                      sdf_plane(p_point,vec3(0.,0.,-1.),14.));\n        \n        case 8:\n            return op_substraction(\n                      sdf_ellipsoid(op_translatePoint(p_point,vec3(-5.,-18.,18.4+EPS_OH)),vec3(3.9,3.9,7.9)),\n                      sdf_plane(p_point,vec3(0.,0.,-1.),18.));\n        \n        case 9:\n            p_point = op_translatePoint(p_point,vec3(0.,35.,2.75+EPS_OH));\n            p_point.x = p_point.x-5.*clamp(round(p_point.x/5.),-1.,1.);\n            p_point = abs(p_point);\n            return op_union(\n                     op_substraction(\n                       op_round(sdf_cylinder(p_point, 2.1, 1.1),0.2),\n                       sdf_sphere(op_translatePoint(p_point,vec3(0.,0.,2.5)),1.5)),\n                     op_Sunion(\n                       op_Sunion(\n                         sdf_capsule(op_translatePoint(p_point,vec3(0.,1.5,0.)),1.7,0.8),\n                         sdf_capsule(op_translatePoint(p_point,1.5*vec3(sin(PI_SIX),cos(PI_SIX),0.)),1.7,0.8)\n                         ,0.1),\n                       op_Sunion(\n                         sdf_capsule(op_translatePoint(p_point,1.5*vec3(sin(PI_THREE),cos(PI_THREE),0.)),1.7,0.8),\n                         sdf_capsule(op_translatePoint(p_point,vec3(1.5,0.,0.)),1.7,0.8)\n                         ,0.1)\n                       ,0.1)\n                   );\n        \n        case 10:\n            return op_round(sdf_cylinder(op_translatePoint(p_point,vec3(0., -35., 3.)), 2., 7.), 1.3);\n       \n        case 11:\n            float icingBase = op_round(sdf_cylinder(op_translatePoint(p_point,vec3(0., -35., 5.)), 0.5, 7.2), 1.3);\n            float icingHole1 = sdf_cylinder(op_rotatePoint(op_translatePoint(p_point,vec3(0.,-35.,2.8)),vec3(PI/2.,0.,0.)),20.,2.);\n            float icingHole2 = sdf_cylinder(op_rotatePoint(op_translatePoint(p_point,vec3(0.,-35.,3.5)),vec3(PI/2.,0.,-0.5)),20.,2.5);\n            float icingHole3 = sdf_cylinder(op_rotatePoint(op_translatePoint(p_point,vec3(0.,-35.,-1.)),vec3(PI/2.,0.,0.5)),20.,6.);\n            float icingHole4 = sdf_cylinder(op_rotatePoint(op_translatePoint(p_point,vec3(0.,-35.,1.1)),vec3(PI/2.,0.,-0.8)),20.,4.);\n            return op_Ssubstraction(op_Ssubstraction(op_Ssubstraction(op_Ssubstraction(icingBase,icingHole1,1.),icingHole2,1.),icingHole3,1.),icingHole4,1.);\n            \n        case 12:\n            float number3 = op_Sunion(\n                                op_round(sdf_box(op_translatePoint(p_point,vec3(3.,-35.,6.8)),vec3(0.2,0.2,0.8)),0.2),\n                                op_Ssubstraction(\n                                    op_Sunion(\n                                        sdf_torus(op_translatePoint(p_point,vec3(3.,-35.,9.1)),2.,1.),\n                                        sdf_torus(op_translatePoint(p_point,vec3(3.,-35.,11.9)),2.,1.),\n                                        0.5),\n                                    sdf_sphere(op_translatePoint(p_point,vec3(5.,-35.,10.5)),2.),\n                                    0.2),\n                                0.2);\n            float number0 = op_Sunion(\n                                op_round(sdf_box(op_translatePoint(p_point,vec3(-3.,-35.,6.8)),vec3(0.2,0.2,0.8)),0.2),\n                                sdf_torus(op_translatePoint(p_point,vec3(-3.,-35.,10.5))-clamp(op_translatePoint(p_point,vec3(-3.,-35.,10.5)),-vec3(0.2,0.2,1.4),vec3(0.2,0.2,1.4)),2.,1.),\n                                0.2);\n            return op_union(number3,number0);\n        \n        case 13:\n            float wickOn3 = sdf_cylinder(op_translatePoint(p_point,vec3(3.,-35.,14.)),0.3,0.1);\n            float wickOn0 = sdf_cylinder(op_translatePoint(p_point,vec3(-3.,-35.,14.)),0.3,0.1);\n            return op_union(wickOn3,wickOn0);\n                             \n        default : return 1e10;\n    }\n}\n\n// Evaluate all the scene and return the distance and the id of the nearest primitive\nvec2 evaluateScene(in vec3 p_point){\n    vec2 res = vec2(1e10,-1.);\n\n    for(float i=0.; i<NB_OBJ ;i++){\n        float tmp = evaluate(p_point,i);\n        if(tmp<res.x) res = vec2(tmp,i); \n    }\n    \n    return res;\n}\n\n// Evaluate shrink scene and return the distance and the id of the nearest primitive\nvec2 evaluateShrinkScene(in vec3 p_point){\n    vec2 res = vec2(1e10,-1.);\n\n    for(float i=0.; i<NB_OBJ ;i++)\n        if(shrinkScene[int(i)]){\n            float tmp = evaluate(p_point,i);\n            if(tmp<res.x) res = vec2(tmp,i); \n        }\n    \n    return res;\n}\n\n// Evaluate scene and find normal by computing gradient at 'p_point'\nvec3 findNormal( in vec3 p_point, in float p_hitId ){\n\treturn normalize(vec3(evaluate( p_point + vec3( EPS_NORMAL, 0., 0. ), p_hitId ),\n\t\t\t\t\t\t  evaluate( p_point + vec3( 0., EPS_NORMAL, 0. ), p_hitId ),\n\t\t\t\t\t\t  evaluate( p_point + vec3( 0., 0., EPS_NORMAL ), p_hitId ))\n\t\t\t\t\t -evaluate( p_point, p_hitId ));\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// This buffer store the camera data\n// inspired by : https://www.shadertoy.com/view/wsVSDd\n\nmat3 rotationMatrix(in vec3 p_rot){\n    vec3 c = vec3(cos(p_rot.x),cos(p_rot.y),cos(p_rot.z));\n    vec3 s = vec3(sin(p_rot.x),sin(p_rot.y),sin(p_rot.z));\n    \n    mat3 rx = mat3(1., 0., 0., 0., c.x, -s.x, 0., s.x, c.x);\n    mat3 ry = mat3(c.y, 0., s.y, 0., 1., 0., -s.y, 0., c.y);\n    mat3 rz = mat3(c.z, -s.z, 0., s.z, c.z, 0., 0., 0., 1.);\n    \n    return rz*ry*rx;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 iFragCoord = ivec2(fragCoord);\n    fragColor = texelFetch(iChannel0, iFragCoord, 0);\n    int index = iFragCoord.x+iFragCoord.y*int(iResolution.x);\n    \n    if(iFrame==0){\n        vec3 w = normalize(LOOKAT - POS_CAM);\n        vec3 u = normalize(cross(w, vec3(0.,0.,-1.)));\n        vec3 v = normalize(cross(w, u));\n    \n        if(index==0) fragColor = vec4(u,0.);       // u\n        if(index==1) fragColor = vec4(v,0.);       // v\n        if(index==2) fragColor = vec4(w,0.);       // w\n        \n        if(index==3) fragColor = vec4(POS_CAM,0.); // camPos\n        if(index==4) fragColor = vec4(LOOKAT,0.);  // lookAt\n        if(index==5) fragColor = vec4(FOCAL_DISTANCE,FOVY,2.*tan(0.5*FOVY)*FOCAL_DISTANCE,1.); // camData : focalDistance,fovy,vpSize,isMoving\n        \n        if(index==6) fragColor = vec4(iMouse);                 // mouse data\n        if(index==7) fragColor = vec4(iResolution.xy,0.,0.);   // resolution\n    }else{\n        vec4 mouseData = texelFetch(iChannel0, ivec2(6%int(iResolution.x),6/int(iResolution.y)), 0);\n        vec2 oldResolution = texelFetch(iChannel0, ivec2(7%int(iResolution.x),7/int(iResolution.y)), 0).xy;\n        \n        float isMoving = 0.;\n        \n        if(iResolution.x != oldResolution.x || iResolution.y != oldResolution.y) isMoving = 1.;\n        \n        if(iMouse.z>=0. && mouseData.z>=0. && (iMouse.x != mouseData.x || iMouse.y != mouseData.y)){\n            vec3 cameraPosition = texelFetch(iChannel0, ivec2(3%int(iResolution.x),3/int(iResolution.y)), 0).xyz * \n                                  rotationMatrix(vec3(0.,0.,(mouseData.x-iMouse.x)*(iResolution.x/iResolution.y) * 0.005));\n            \n            vec3 w = normalize(texelFetch(iChannel0, ivec2(4%int(iResolution.x),4/int(iResolution.y)), 0).xyz - cameraPosition);\n            vec3 u = normalize(cross(w, vec3(0.,0.,-1.)));\n            vec3 v = normalize(cross(w, u));\n            \n            if(index==0) fragColor = vec4(u,0.);\n            if(index==1) fragColor = vec4(v,0.);\n            if(index==2) fragColor = vec4(w,0.);\n            \n            if(index==3) fragColor = vec4(cameraPosition,0.);\n            \n            isMoving = 1.;\n        }\n        \n        if(index==5) fragColor = vec4(fragColor.xyz,isMoving); \n        if(index==6) fragColor = vec4(iMouse);\n        if(index==7) fragColor = vec4(iResolution.xy,0.,0.);    \n    }\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dX3zn","filepath":"/media/a/550a8cce1bf403869fde66dddf6028dd171f1852f4a704a465e1b80d23955663.png","previewfilepath":"/media/ap/550a8cce1bf403869fde66dddf6028dd171f1852f4a704a465e1b80d23955663.png","type":"cubemap","channel":2,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4df3Rr","filepath":"/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","previewfilepath":"/media/ap/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// This buffer render the scene by path tracing\n\n// ------------------------------------------------------------------------------------------\n// --------------------------------------- MATERIAL -----------------------------------------\n// ------------------------------------------------------------------------------------------\n\nMaterial getMaterial( in vec3 p_point ,in float p_num ){\n    switch(int(p_num)){\n        case 0: // table\n            return Material(0.15*texture(iChannel3, 0.01*p_point.xy).xyz,vec3(0.),0.,0.,0.,vec3(1.),0.,1.5);\n        \n        case 1: // plate canele\n        case 2: // plate cake\n            return Material(vec3(0.95),vec3(0.),0.5,0.,0.,vec3(1.),0.,1.5); \n        \n        case 3: // glass wine\n        case 4: // glass champagne\n            return Material(vec3(1.),vec3(0.),0.,0.,1.,vec3(1.),0.,1.5);\n        \n        case 5: // wine bottle\n            return Material(vec3(0.34,0.58,0.),vec3(0.),0.,0.1,1.,vec3(1.),0.,1.5);\n            \n        case 6: // wine inside bottle\n        case 7: // wine inside glass\n            return Material(vec3(1.),vec3(0.),0.,0.1,1.,vec3(0.6,0.,0.),0.6,1.345);\n            \n        case 8: // champagne inside glass\n            return Material(vec3(1.),vec3(0.),0.,0.2,1.,vec3(1.,0.8,0.2),0.1,1.345);\n        \n        case 9: // canele\n            return Material(vec3(0.1,0.058,0.03),vec3(0.),0.,1.,0.,vec3(1.),0.,1.);\n        \n        case 10: // cake\n            return Material(vec3(0.4,0.245,0.09),vec3(0.),0.,1.,0.,vec3(1.),0.,1.5);\n            \n        case 11: // cake icing\n            return Material(vec3(1.),vec3(0.),0.,0.1,0.,vec3(1.),0.,1.5);\n            \n        case 12: // candle\n            return Material(vec3(0.67,0.28,0.06),vec3(0.),1.,0.3,0.,vec3(1.),0.,1.5);\n        \n        case 13: // wick\n            return Material(vec3(0.1),vec3(0.),0.,1.,0.,vec3(1.),0.,1.5); \n        \n        case 14: // sun\n            return Material(vec3(1.),vec3(100.),0.,1.,0.,vec3(1.),0.,1.5);\n        \n        default: return Material(vec3(1.),vec3(0.),0.,1.,0.,vec3(1.),0.,1.5);\n    }  \n}\n\n// ------------------------------------------------------------------------------------------\n// ---------------------------------------- RENDER ------------------------------------------\n// ------------------------------------------------------------------------------------------\n\nvec3 trace( in Ray p_currentRay ){\n    vec3 totalColor = vec3(0.);\n    vec3 rayColor   = vec3(1.);\n    \n    updateShrinkScene(p_currentRay,0.,FAR);\n    vec2 hit = evaluateShrinkScene(p_currentRay.o);\n    bool isInside = hit.x<0.;\n    float numInside = hit.y;\n    float t = abs(hit.x);\n    \n    float ni = (isInside) ? getMaterial(p_currentRay.o, hit.y).ior : 1.;\n\n    for(int i=Z; i<NB_BOUNCE ;i++){\n        for(int nbStep=Z; nbStep<MAX_STEP ;nbStep++){\n            vec3 point = t*p_currentRay.d + p_currentRay.o;\n            hit = (isInside ? vec2(evaluate(point,numInside),numInside) : evaluateShrinkScene(point));\n            \n            if(abs(hit.x)<EPS){\n                Material m = getMaterial(point,hit.y);\n                vec3 normal = findNormal(point, hit.y)*((isInside) ? -1. : 1.);\n            \n                vec3 pointOffsetRefract = point-normal*(EPS_OH+abs(hit.x));\n                vec3 pointOffsetReflect = point+normal*(EPS_OH-abs(hit.x));\n                \n                vec2 hitNo = evaluateScene(pointOffsetRefract); \n                bool isInsideNo = hitNo.x<0.;\n                float no = (isInsideNo) ? getMaterial(pointOffsetRefract,hitNo.y).ior : 1.;\n                \n                totalColor += m.emissive*rayColor;\n                if(isInside) rayColor *= exp(-(1.-m.absorptionColor)*(t+abs(hit.x))*m.absorptionDensity);\n                p_currentRay = evaluateBSDF(p_currentRay,HitRecord(point,pointOffsetRefract,pointOffsetReflect,normal,ni,no,m),rayColor);\n                \n                if(rayColor.x==0. && rayColor.y==0. && rayColor.z==0.) return totalColor;\n                if(dot(normal,p_currentRay.d)>0.f){\n                    t = 0.;\n                }else{\n                    t = abs(hitNo.x);\n                    isInside = isInsideNo;\n                    if(isInside) numInside = hitNo.y;\n                    ni = no;\n                }\n                \n                updateShrinkScene(p_currentRay,0.,FAR);\n                break;\n            }\n\n            t += abs(hit.x);\n            if(t>FAR) {\n                vec3 tex = texture(iChannel2, p_currentRay.d.xzy).xyz;\n                return totalColor+rayColor*2.*tex*tex;\n            }\n            if(nbStep == MAX_STEP) return totalColor;\n        }\n    }\n    \n    return totalColor;\n}\n\n// ------------------------------------------------------------------------------------------\n// ----------------------------------------- MAIN -------------------------------------------\n// ------------------------------------------------------------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){   \n    // --- setup --- \n    seed = uint(iFrame*(int(iResolution.x*iResolution.y)))+uint(fragCoord.x+fragCoord.y*iResolution.x);\n    vec2 uv = fragCoord/iResolution.xy;\n\n    //--- camera ---    \n    vec3 posCam = texelFetch(iChannel0, ivec2(3%int(iResolution.x),3/int(iResolution.y)), 0).xyz;\n    vec4 dataCam = texelFetch(iChannel0, ivec2(5%int(iResolution.x),5/int(iResolution.y)), 0);\n    \n    vec3 w = texelFetch(iChannel0, ivec2(2%int(iResolution.x),2/int(iResolution.y)), 0).xyz;\n    vec3 u = texelFetch(iChannel0, ivec2(0,0), 0).xyz;\n    vec3 v = texelFetch(iChannel0, ivec2(1%int(iResolution.x),1/int(iResolution.y)), 0).xyz;\n    \n    vec3 vpV = v * dataCam.z;\n    vec3 vpU = u * dataCam.z * (iResolution.x/iResolution.y);\n    \n    // --- trace --- \n    fragColor = (dataCam.w==1.) ? vec4(0.) : texelFetch(iChannel1, ivec2(fragCoord), 0);\n    for(int a=0; a<AA ;a++)\n        for(int b=0; b<AA ;b++)\n            fragColor += vec4(trace(Ray(posCam, normalize((uv.x+(float(a)+rand())/(iResolution.x*float(AA))-0.5)*vpU + (uv.y+(float(b)+rand())/(iResolution.y*float(AA))-0.5)*vpV +w*dataCam.x))),1.);\n}","name":"Buffer B","description":"","type":"buffer"}]}