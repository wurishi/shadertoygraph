{"ver":"0.1","info":{"id":"XfjyDd","date":"1723177339","viewed":66,"name":"Clips","username":"Elsio","description":"Meta: fazer isso na vers√£o loopless ","likes":12,"published":1,"flags":0,"usePreview":0,"tags":["tag"],"hasliked":0,"parentid":"mdyyz1","parentname":"cabo enrolado"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define rot(a)    mat2(cos(a + vec4(0, 11, 33, 0)))\n#define normal(p) normalize(map(p)-vec3(map(p-e.xyy),map(p-e.yxy),map(p-e.yyx)))\n#define INIT      vec2 r = iResolution.xy, e = vec2(.001, 0); u = vec2(u - .5 * r) / r.y;\n#define color(a)  fract(a * cos(6. + vec3(1, 2, 3)))\n#define t iTime * .5\n#define far 60.\n#define pi 3.1415\n\nvec3 gD;\nfloat cor;\n\nfloat torus(vec3 p) {\n    float r = .8, \n          l = 1.;\n\n    return length(\n               vec2(\n                   length(\n                       max(\n                           abs(p.xy) \n                               - vec2(0, l), \n                           0.\n                       )\n                   ) - r, \n                   p.z\n               )\n           ) - .1;\n}\n\n\n\n\n\n\nfloat mychain(vec3 p){\n    vec3 q, k;\n    \n    float n = 8., s = 1.,\n          a = 2. * pi / n,\n          b = pi / n,\n          i, j, d = 1e5;\n    \n    while(i++ < n){\n        k = p;\n        k.xy *= rot(i * a);\n        k.y += 7.;\n        k.yz *= rot(s * b / 1. - t * 1.);\n        s = -s;\n    \n        j = 0.;\n        while(j++ < n){\n            q = k;\n            q.xy *= rot(j * a + t * 2.);\n            q.x += 4. ;\n            q.xz *= rot(j * b),\n            d = min(d, torus(q));\n        }\n    }\n    \n    return d;\n}\n\n\nfloat map(vec3 p) {\n    p.xy *= rot(t * 2.4);\n    p.yz *= rot(t * .4);\n    \n    return mychain(p);\n}\n\n\nvoid mainImage(out vec4 o, vec2 u) {\n    INIT\n    \n    float i, d, s;\n    vec3 N, L, col,\n         p = vec3(0, 0, -12), \n         D = normalize(vec3(u, 1));\n    \n    s = 1.;\n    while(i++ < 140. && s > .001 && d < far) \n        s = map(p),\n        p += s * D,\n        d += s;\n\n    col += vec3(3, 5, 8) / 64.;\n    \n    if(d < far)\n        N = normal(p), \n        L = normalize(vec3(cos(t) * 5., 3, -3) - D), \n        \n        col = color(cor),\n\n        col *= (.8 * max(0., dot(L, N)) + .5) * .6,  // diff\n        col += pow(max(0., dot(L, N)), 10.) * .3;    // spec\n    \n    o.rgb =  pow(col, vec3(.4));                     // gama  \n}\n\n","name":"Image","description":"","type":"image"}]}