{"ver":"0.1","info":{"id":"4XyGD3","date":"1718639725","viewed":67,"name":"pxfl ripples","username":"olano","description":"GLSL version of interactive rippled from my 1998 PhD dissertation\n\nOriginally written the pfman shading language for PixelFlow (the first graphics hardware with a real-time high-level shading language)\n\nClick on screen to place ripples","likes":5,"published":1,"flags":32,"usePreview":1,"tags":["reflection","ripple","historic"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Water ripple shader\n//\n// Produces water ripples from drips on a calm surface, rendered as\n// a bump map.\n//\n// Handles up to MAX_DROPS at a time, drop_* parameters control the\n// individual features of each drop (drop location and starting time)\n//\n// Time is given by frame_number parameter.\n//\n// Other control parameters control the general characteristics of the\n// ripples (ripple_*: height, speed, wavelength, and two kinds of\n// fading)\n//\n// See comments in the declaration section of surface ripple for more\n// details\n\nconst int MAX_DROPS = 15;\n\nconst vec3 eye = vec3(0,0,1);\n\n// ripple parameters\nconst float ripple_height = .5;       // amplitude of ripples\nconst float ripple_speed = 0.1;      // in texels/second\nconst float ripple_wavelength = 0.1; // in texels\nconst float ripple_source_fade = 5.; // source will be 0 after x wavelengths\nconst float ripple_front_fade = 20.;  // wave front will be 0 after x wavelengths\n\n\n// conversion from easy to specify quantities to easy to use versions\nconst float PI = radians(180.);\n//   frequency (in radians/texel)\nconst float ripple_frequency = 2.*PI/ripple_wavelength;\n//   decay at source (in 1/texels)\n//   factor of 6 is because exp(-x) is effectively 0 by x = 6\n//   (and my approximation is exactly 0 by x = 6)\nconst float ripple_source_decay = 6./(ripple_wavelength*ripple_source_fade);\n//   decay at wave front with distance from source (in 1/texels)\nconst float ripple_front_decay = 6./(ripple_wavelength*ripple_front_fade);\n//   maximum progress of ripple\nconst float ripple_end = (ripple_source_fade + ripple_front_fade) * ripple_wavelength;\n\n\n// approximate exponential exp(-x) decay with piece of quartic\n// decay = 1 at x=0\n// decay and 3 derivatives = 0 at x=6\n// decay = 0 at all x>6\nfloat decay(float x) {\n    if (x > 6.)\n        return 0.;\n    else {\n        // quartic approximation: ((x-6)^4)/1296\n        float t = x-6., t2=t*t, t4=t2*t2; \n        return t4/1296.;\n    }\n}\n\n// compute normal displacement for ripples from one drop\nvec2 ripple_displacement(\n    // location that drop started\n    vec2 drop_center,\n    \n    // distance traveled by wave front so far\n    float wavefront_progress,\n    \n    // position on surface\n    vec3 ps)\n{\n    // distance of this sample from the drop center\n    vec2 drop_vector = ps.xy - drop_center;\n    float drop_distance = length(drop_vector);\n    \n    // length of ripples that have passed this sample\n    float ripple_progress = max(0., wavefront_progress - drop_distance);\n    \n    // normal displacement in direction ripple is moving\n    // basically the derivative of the ripple height function\n    //   (should really have some terms due to the derivative of each\n    //   decay function, but I ignore these)\n    float normal_displacement = ripple_height\n        * decay(drop_distance * ripple_front_decay)\n        * decay(ripple_progress * ripple_source_decay)\n        * sin(ripple_progress * ripple_frequency);\n    \n    return(normal_displacement/drop_distance * drop_vector);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // plane location\n    vec3 ps = vec3((2.*fragCoord - iResolution.xy)*vec2(1,-1)/iResolution.y,0);\n    \n    // view vector\n    vec3 v = normalize(eye - ps);\n    \n    // displace from each drop\n    vec2 normal_displacement = vec2(0);\n    for (int i=0; i<MAX_DROPS; ++i) {\n        vec4 drop = texelFetch(iChannel1, ivec2(i,0), 0);\n        \n        float drop_start = drop.z;\n        vec2 drop_center = (2.*drop.xy - iResolution.xy)*vec2(1,-1)/iResolution.y;\n        \n        // distance traveled by wave front so far\n        float wavefront_progress = (iTime - drop_start) * ripple_speed;\n        \n        if (wavefront_progress > 0. && wavefront_progress < ripple_end) {\n            normal_displacement += ripple_displacement(\n                drop_center, wavefront_progress, ps);\n        } \n    }\n    \n    // modify normal by bump displacements\n    vec3 material_normal = vec3(0,0,1);\n    material_normal = normalize(material_normal + vec3(normal_displacement,0));\n    \n    // reflection\n    fragColor = texture(iChannel0, reflect(v, material_normal));\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// not in the original, but want to initialize with some random ripple locations\nvec3 rand(vec3 p) {\n    uvec3 v = uvec3(ivec3(p));\n    v = v * 1664525u + 1013904223u;\n    v.x += v.y*v.z; v.y += v.z*v.x; v.z += v.x*v.y;\n    v ^= v >> 16u;\n    v.x += v.y*v.z; v.y += v.z*v.x; v.z += v.x*v.y;\n    return vec3(v & 0xffffu) / float(0x10000);\n}\n\n// original mouse interaction was C++ app and tcl/tk interface\n// I don't have the orignal code anymore, but it did allow click for drops\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 texel = ivec2(fragCoord);\n\n    // initialize\n    if (iFrame == 0) {\n        fragColor = vec4(vec3(0,0,texel.x) +\n            rand(fragCoord.xxy) * vec3(iResolution.xy,1),iMouse.z>0.);\n        return;\n    }\n    \n    // normally just copy existing texel through\n    fragColor = texelFetch(iChannel0,texel,0);\n    \n    // current and previous mouse state\n    bool wasPressed = fragColor.w > 0.;\n    bool isPressed = iMouse.z > 0.;\n\n    // on click, start a new ripple\n    if (isPressed && !wasPressed) {\n        fragColor = texelFetch(iChannel0, texel - ivec2(1,0), 0);\n        if (texel == ivec2(0,0))\n            fragColor.xyz = vec3(iMouse.xy, iTime);\n    }\n    \n    // record pressed state\n    fragColor.w = float(isPressed);\n}","name":"Buffer A","description":"","type":"buffer"}]}