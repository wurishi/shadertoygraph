{"ver":"0.1","info":{"id":"7sdXz4","date":"1632787214","viewed":199,"name":"Party Blob","username":"d3v_null","description":"A gently oscillating ball of energy just going with the flow","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["fluid","flow","neon","tiedye","curvy","energizing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// number of bouncing iterations\n#define N 16\n#define PI 3.14159265\n// how much to gravitate towards hue center\n#define depth 1.0\n// bounce rate: space between blobs\n#define rate 0.3\n// the hue value things tend towards\n#define huecenter 0.5\n\n/**\n * Stolen from https://www.shadertoy.com/view/lsS3Wc\n */\nvec3 hsv2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n    return c.z * mix( vec3(1.0), rgb, c.y);\n}\n\n\n/**\n * Calculate the distance r from a distorted ray-trace of fragCoord, \n * then use the sin of this to colour the frag\n *\n * Inspired by https://github.com/genekogan/Processing-Shader-Examples/blob/master/ColorShaders/data/blobby.glsl\n * Comments are my interpretation of what it's doing\n */\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // a vector that moves around with each iteration, initially normalized relative to center of resolution.\n    vec2 v = (fragCoord.xy - (iResolution.xy * 0.5)) / min(iResolution.y, iResolution.x) * 10.0;\n    // time-based var used to bounce v around\n    float t = iTime * 0.3;\n    // the cumulative sum of each v, used to bounce v around\n    float r = 2.0;\n    // d some multiple of pi that gets bigger with i, used to bounce v around\n    float d = 0.0;\n    for (int i = 1; i < N; i++) {\n        // bounce v around\n        d = (PI / float(N)) * (float(i) * 14.0);\n        r += length(vec2(rate*v.y, rate*v.x)) + 1.21;\n        v = vec2(v.x+cos(v.y+cos(r)+d)+cos(t),v.y-sin(v.x+cos(r)+d)+sin(t));\n    }\n    // normalise r in [0,1]\n    r = (sin(r*0.09)*0.5)+0.5;\n    // make r tend toward 0 with greater depth\n    r = pow(r, depth);\n    \n    vec3 hsv = vec3(\n        // phase shift r around [0,1] by huecenter\n        mod(r + huecenter, 1.0),\n        1.0-0.5*pow(max(r,0.0)*1.2,0.5),\n        1.0-0.2*pow(max(r,0.4)*2.2,6.0)\n        //\n    );\n    \n    //fragColor = vec4(r,pow(max(r-0.55,0.0)*2.2,2.0),pow(max(r-4.875,0.1)*3.0,6.0), 1.0 );\n    fragColor = vec4(hsv2rgb(hsv), 1.0);\n\n//    // Normalized pixel coordinates (from 0 to 1)\n//    vec2 uv = fragCoord/iResolution.xy;\n//\n//    // Time varying pixel color\n//    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n//\n//    // Output to screen\n//    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}