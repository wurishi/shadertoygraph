{"ver":"0.1","info":{"id":"MX3GWH","date":"1716408975","viewed":114,"name":"Lorentz Transform","username":"Gijs","description":"This is a spacetime diagram. The vertical direction indicates time and the horizontal direction indicates distance. The green and blue lines are the spacetime trajectories of two observers. The red diagonal lines indicate the light cone of the observer.","likes":12,"published":1,"flags":0,"usePreview":0,"tags":["2d","transform","relativity","lorentz","spacetime"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float animate1 = smoothstep( 0.1,-0.1,cos(0.50*iTime));\n    float animate2 = smoothstep(-0.1, 0.1,cos(0.25*iTime));\n    float animate3 = smoothstep( 0.1,-0.1,cos(0.125*iTime));\n    \n    float zoom = 1.0*exp2(animate1*1.5);\n    float e = zoom*2.0/iResolution.y;\n\n    vec2 q = (fragCoord*2.0 - iResolution.xy)/iResolution.y * zoom;\n\n    vec3 col = vec3(0.95);\n    float d = 0.0;\n    \n    // observer 0\n    float t0 = iTime * 0.25;\n    float x0 = path0(t0);\n    float v0 = dpath0(t0, 0.01);\n    \n    // observer 1\n    float t1 = iTime * 0.25;\n    float x1 = path1(t1);\n    float v1 = dpath1(t1, 0.01);\n    \n    // interpolated observer (switches abruptly between observer 0 and 1) \n    float i = animate2;\n    float ti = t0 * i + t1 * (1.0 - i);\n    float xi = x0 * i + x1 * (1.0 - i);\n    float vi = v0 * i + v1 * (1.0 - i);\n    \n    // lorentz transform\n    float gamma = 1.0/sqrt(1.0 - vi*vi);   \n    mat2 lorentz;\n    lorentz[0] = vec2(1.0, vi);\n    lorentz[1] = vec2(vi, 1.0);\n    lorentz *= gamma;\n    mat2 ilorentz = inverse(lorentz);\n\n    vec2 qp = lorentz * q;\n    vec2 p = qp + vec2(xi, ti);\n    \n    // random event scattered about\n    vec2 p_m = floor(p / grid_spacing + 0.5) * grid_spacing;\n    vec2 p_f = p - p_m;\n    vec2 s = (hash22(p_m) - 0.5) * grid_spacing * 0.75;\n    \n    // draw background grid\n    d = min(abs(p_f.x), abs(p_f.y));\n    col = mix(col, back_grid_col, smoothstep(2.0*e, 1.0*e, d) * animate3);\n    \n    // draw random events\n    d = length(ilorentz*(p_f - s));\n    col = mix(col, rand_event_col, smoothstep(3.0*e, 2.0*e, d));\n\n    //d = abs(mod(qp.x+0.25,0.5)-0.25);\n    //col = mix(col,vec3(0.8),smoothstep(2.0*e,1.0*e,d));\n    //d = abs(mod(qp.y+0.25,0.5)-0.25);\n    //col = mix(col,vec3(0.8),smoothstep(2.0*e,1.0*e,d));\n    \n    // draw wordline observer 1\n    d = abs(path1(p.y) - p.x) / sqrt(length(ilorentz * vec2(1.0, dpath1(p.y, 0.01))));\n    col = mix(col, obs1_col, smoothstep(3.0*e, 2.0*e, d));\n\n    // draw wordline observer 0\n    d = abs(path0(p.y) - p.x) / sqrt(length(ilorentz * vec2(1.0, dpath0(p.y, 0.01))));\n    col = mix(col, obs0_col, smoothstep(3.0*e, 2.0*e, d));\n   \n    // draw light cone\n    d = min(abs(q.y + q.x), abs(q.y - q.x))/sqrt(2.0);\n    col = mix(col, light_cone_col, smoothstep(2.0*e, 1.0*e, d));\n    \n    // draw observer 1 \n    d = length(ilorentz * (p - vec2(x1,t1)));\n    col = mix(col, obs1_col, smoothstep(7.0*e, 6.0*e, d));\n    \n    // draw observer 0\n    d = length(ilorentz * (p - vec2(x0,t0)));\n    col = mix(col, obs0_col, smoothstep(7.0*e, 6.0*e, d));\n \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"\nconst vec3 light_cone_col = vec3(0.75,0.25,0.25);\nconst vec3 obs0_col = vec3(0.25,0.75,0.25);\nconst vec3 obs1_col = vec3(0.25,0.25,0.75);\nconst vec3 back_grid_col  = vec3(0.8);\nconst vec3 rand_event_col = vec3(0.4);\nconst float grid_spacing = 0.25;\n\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+19.19);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nfloat path0(float t)\n{\n    return cos(2.0*t + 3.5) / 4.0 + cos(4.0*t + 1.4) / 16.0 + cos(8.0*t + 4.0) / 64.0;\n}\n\nfloat dpath0(float t, float h)\n{\n    return (path0(t + h) - path0(t - h))/(2.0 * h);\n}\n\nfloat path1(float t)\n{\n    return smoothstep(0.9,-0.9,sin(t)) * 1.0 - 0.5;\n}\n\nfloat dpath1(float t, float h)\n{\n    return (path1(t + h) - path1(t - h))/(2.0 * h);\n}","name":"Common","description":"","type":"common"}]}