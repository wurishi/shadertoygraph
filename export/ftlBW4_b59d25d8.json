{"ver":"0.1","info":{"id":"ftlBW4","date":"1650915105","viewed":129,"name":"A Ball that bounce","username":"nebbul","description":"I made a curve in graphtoy which resembled a bouncing ball so I decided to create it in shadertoy\n\nI use Spherify UVs on the ball to make it look spherical","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["uv","distort","sphere","bounce"],"hasliked":0,"parentid":"7slyR7","parentname":"Box Mask with rotation"},"renderpass":[{"inputs":[{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n\n#define PI 3.141592\n\nconst float N = 2.0; // grid ratio\nfloat gridTexture( in vec2 p )\n{\n    // coordinates\n    vec2 i = step( fract(p), vec2(1.0/N) );\n    //pattern\n    //return (1.0-i.x)*(1.0-i.y);   // grid (N=10)\n    \n    // other possible patterns are these\n    //return 1.0-i.x*i.y;           // squares (N=4)\n    return 1.0-i.x-i.y+2.0*i.x*i.y; // checker (N=2)\n}\n\n// rotate UVs\n// from https://shadertoyunofficial.wordpress.com/2019/01/02/programming-tricks-in-shadertoy-glsl/\n#define rot(a)      mat2( cos(a), -sin(a), sin(a), cos(a) )\n\nstruct Layers\n{\n    float mask;\n    float depth;\n    vec2 uv;\n    vec3 normals;\n};\nLayers ball(vec2 in_uv, float rad, vec3 pos, vec2 mask_smoothness, vec3 velocity) {\n    vec2 uv_pos = vec2(pos.x, pos.y);\n    float depth = pos.z;\n    \n    vec2 uv = (((in_uv - 0.5) * 2.) + uv_pos) * 1. / rad;\n    uv = (in_uv - uv_pos) * 1. / rad;\n\n    float d = sqrt(1.-clamp(dot(uv, uv), 0., 1.));\n    vec3 normals = vec3(uv, d);\n\n    vec2 q = (vec2(d, d) + vec2(1.,1.));\n    \n    uv /= q;\n    \n    float angularVelocity = length(velocity) / rad;\n    \n    float rotation = angularVelocity;\n    uv *= rot(rotation);\n\n    float mask = smoothstep(mask_smoothness.x, mask_smoothness.y, d);\n\n    return Layers(mask, depth, uv, normals);\n}\n// colors using IQ method\n// https://www.shadertoy.com/view/ll2GD3\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n// pick a color based on index\nvec3 getClr(vec2 uv, int clrIndex) {\n    float p = texture(iChannel0, uv).x;\n    return 1.3 * pal( p, vec3(0.5,0.6585,0.3984),vec3(0.5,0.3384,0.9784),vec3(-0.151,0.3984,.5284),vec3(0.,0.,0.15) );\n}\n\n// draw ball to layers \nvoid MakeBall(vec2 in_uv, vec3 position, vec3 velocity, float radius, int clrIndex, inout float mask, inout float depth, inout vec3 normals, inout vec3 clr, inout vec2 uv, float alpha)\n{\n    Layers myBall = ball(in_uv, radius, position, vec2(0., 0.3), velocity);\n    float mask_ball = mix(0., 1., depth < myBall.depth ? 1. : 0.) * myBall.mask * alpha;\n    //float mask_ball = myBall.mask * alpha;\n    \n    mask = mix(mask, 1., mask_ball);\n    //mask = max(mask, mask_ball);\n    depth = mix(depth, myBall.depth, mask_ball);\n    vec2 ball_uv = myBall.uv * 0.5;\n    uv = mix(uv, ball_uv, mask_ball);\n    \n    clr = mix(clr, getClr(ball_uv, clrIndex), mask_ball);\n    normals = mix(normals, myBall.normals, mask_ball);\n}\n\nfloat pow3(float x)\n{\n return x*x*x;\n}\n\nfloat pow4(float x)\n{\n return x*x*x*x;\n}\n\nfloat remap(float v, float in_min, float in_max, float out_min, float out_max)\n{\n    return out_min + (v - in_min) * (out_max - out_min) / (in_max - in_min);\n}\n\n// main inspiration of this shader\n// https://graphtoy.com/?f1(x,t)=abs(sin(sqrt(1-x)*10*PI))&v1=false&f2(x,t)=f1(x)*pow(1-x,2)&v2=true&f3(x,t)=&v3=false&f4(x,t)=&v4=false&f5(x,t)=&v5=false&f6(x,t)=&v6=false&grid=1&coords=0.5,0.5,0.6666666666666666\nfloat bouncingBall(float t, float bounces)\n{\n\tfloat x = clamp(t, 0., 1.);\n\n\tfloat wave = abs(sin(sqrt(1. - x)  * bounces * PI));\n\n\treturn wave * pow4(1.0 - x);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // define our UVs\n\tvec2 uv = fragCoord.xy;\n    vec2 generic_uv = fragCoord.xy / iResolution.yy;\n    \n    // get center of image\n\tvec2 pos = iResolution.xy * 0.5;\n    // set radius of circle\n\tfloat radius = 0.05 * iResolution.y;\n    \n    float bounces = 20.0f;\n    float speed = 5. / bounces;\n    \n    // init the layers\n    float mask = 0.;\n    float depth = -1.;\n    vec3 clr = vec3(0,0,0);\n    vec3 normals = vec3(.5,.5,1.);\n    \n    float circleMask;\n\n    float t = mod(iTime * speed, 1.);\n\n    float x1 = pow3(clamp(1.0 - t, 0., 1.));\n    float x2 = (1. - x1);\n    float x = remap(x2, 0., 1., 0., iResolution.x - 2. * radius) + radius;\n    float y = bouncingBall(t, bounces) * iResolution.y + radius;\n    \n    vec3 velocity = vec3(x2 * iResolution.x, 0.,0.); // need for angular velocity rotation\n\n    MakeBall(uv, vec3(x,y,0.), velocity, radius, 0, mask, depth, normals, clr, uv, 1.);\n        \n    vec3 lightdir = normalize(vec3(1.,1.,0.));\n    \n    // shadows\n    float shadows = mix(1., smoothstep(0., 1.,(dot(lightdir, normals) + 1.2) / 2.), 0.7);\n    // highlight\n    float highlight = mix(0., smoothstep(0., 1., clamp(dot(lightdir, normals), 0., 1.)), 0.5) * mask;\n    \n    // apply shadows and highlight\n    vec3 fg = clr * shadows + highlight;\n    \n    // background\n    vec4 bg = 0.1 * vec4(1., 1., 1., 1.) * gridTexture(fragCoord.xy/iResolution.xx * vec2(5., 5.)) + 0.2;\n    \n    // blend bg with fg by the mask\n    fragColor = mix(bg, vec4(fg, 1.), mask);\n}","name":"Image","description":"","type":"image"}]}