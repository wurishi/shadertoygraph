{"ver":"0.1","info":{"id":"fllfWl","date":"1651696688","viewed":223,"name":"Roller Coaster Jam","username":"luckyballa","description":"Weird camera movement practice","likes":18,"published":1,"flags":32,"usePreview":0,"tags":["raymarching","grid","infinite","fov","rollercoaster","stonks"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord.xy / iResolution.xy;  \n\n    fragColor = texture(iChannel0, uv);\n}\n\n\n\n\n\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define MAX_STEPS 300\n#define MAX_DIST 300.\n#define SURF_DIST .1\n\n#define PI 3.1415926535\n#define M1 1597334677U  \n#define M2 3812015801U\n#define tex(p) texture(iChannel0, p).rgb\n\n#define iTime iTime * 1.5\n\nconst uvec2 UM = uvec2(M1, M2);\nfloat rand(vec2 q) {\n    uvec2 uq = uvec2(q);\n    uq *= UM;\n    uint n = (uq.x ^ uq.y) * M1;\n    return float(n) * (1.0/float(0xffffffffU));\n}\n\nfloat noise(vec2 p) {\n\tvec2 ip = floor(p);\n\tvec2 u = fract(p);\n\tu = u*u*(3.0-2.0*u);\n\t\n\tfloat res = mix(\n\t\tmix(rand(ip),rand(ip+vec2(1.0,0.0)),u.x),\n\t\tmix(rand(ip+vec2(0.0,1.0)),rand(ip+vec2(1.0,1.0)),u.x),u.y);\n\treturn res * res;\n}\n\nvec3 shape(float t) {\n    float x = t * 0.1;\n    vec2 n2 = vec2(\n        noise(x * vec2(0.1, 0.175)) * 5., \n        noise(x * vec2(0.1111, 0.1666))* 6.\n        )* 5.;\n\treturn vec3(n2,\n    t);    \n}\n\nfloat smin( float a, float b, float k ) {\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nvec2 rot(vec2 p, in float an ) {\n    float cc = cos(an);\n    float ss = sin(an);\n    return mat2(cc,-ss,ss,cc)*p;\n}\n\nvec3 rot(vec3 P, float a, vec3 A) {\n    vec3 O = dot(P, A) * A;\n    return O + (P-O) * cos(a) -  cross(A,P) * sin(a);\n}\n\nvec2 dist(vec3 p) {\n    vec3 lp = p;\n    vec2 s = shape(lp.z).xy;\n    lp.x *= 0.44;\n    lp.xy -= 5.;\n    lp.x -= s.x;\n    lp.x += sin(lp.z * 0.05) * 2.;\n    lp.y -= s.y * 1.5;\n    lp.y -= cos(lp.z * 0.05) * 3.;\n    lp.xy = rot(lp.xy, pow(abs(cos(lp.z * 0.005)), 10.) * 2. * PI);\n    lp.x = abs(lp.x) - 1.;\n\n\tfloat l = length(lp.xy) - .15;\n    float c = length(lp.xy + vec2(pow(fract(lp.z), 1.), 0.)) - .1;\n    float r = smin(l, c, 0.2);\n    float b = smin(p.y + 5., p.x + 35., 10.);\n    float mat = b < r ? 1. : 0.;\n\n    return vec2(min(b, r), mat);\n}\n\nvec2 march(vec3 ro, vec3 rd) {\n\tfloat dO=0.;\n    float matId = -1.;\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        vec2 res = dist(p);\n        float dS = res.x;\n        dO += dS;\n        matId = res.y;\n        \n        if(dO>MAX_DIST || dS<SURF_DIST) break;\n    }\n    \n    return vec2(dO, matId);\n}\n\nvec3 normal(vec3 p) {\n\tfloat d = dist(p).x;\n    vec2 e = vec2(.1, 0);\n    \n    vec3 n = d - vec3(\n        dist(p-e.xyy).x,\n        dist(p-e.yxy).x,\n        dist(p-e.yyx).x);\n    \n    return normalize(n);\n}\n\nfloat diffuse(vec3 p, vec3 n, vec3 lp) {\n    vec3 l = normalize(lp-p);\n    float dif = clamp(dot(n, l), 0., 1.);\n\n    return dif;\n}\n\n// Inspired by https://www.shadertoy.com/view/XtVGzw\nvec3 camera(vec2 uv, vec3 d, float aspect, float f){ \n    vec3 up = vec3(0., 1., 0.);\n    vec3 r = normalize(cross(d, up));\n    vec3 u = cross(r, d);\n    vec2 ab = f / 360. * uv * PI;\n    \n    d = rot(d, -ab.x, u);\n    r = normalize(cross(d, u));\n    d = rot(d, -ab.y, r);\n    \n    return d;\n}\n\nfloat shadow( in vec3 ro, in vec3 rd, float mint, float maxt) {\n    for( float t=mint; t<maxt;) {\n        float h = dist(ro + rd * t).x;\n        if(h <  SURF_DIST) {\n            return 0.0;\n            }\n        t += h;\n    }\n    return 1.0;\n}","name":"Common","description":"","type":"common"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    float aspect = iResolution.x/iResolution.y;\n    vec3 pa = shape(iTime * 10.);\n\n    vec3 ro = abs(pa) * vec3(5., 2., 5.);\n    ro.x += 70.;\n    vec3 rd = normalize(vec3(-PI + pa.y * 0.1 , 0.5 - pa.y * 0.05, pa.y * 0.1));\n    rd = camera(uv, rd, aspect, 120. + pa.y - pa.x * 2.);\n    vec2 d = march(ro, rd);\n    vec3 p = ro + rd * d.x;\n    vec3 n = normal(p); \n    vec3 lp = vec3(20, 20., ro.z + 20.);\n    float dif = diffuse(p, n, lp);\n    \n    vec3 col = vec3(0.);\n    if (d.y == 0.) {\n        col = n;\n    } else if (d.y == 1.) {\n        vec3 fp = fract(p * vec3(0.08)) - 0.5;\n        float g = max(fp.y, max(fp.x, fp.z));\n        col = vec3(dif) * max(smoothstep(0.5, 0.46, g), 0.9);\n    } \n    \n    float s = max(shadow(p, normalize(vec3(1., 3., 0.)), 5., 60.), 0.75);\n    col = col * s;\n    col = mix(vec3(0.1), col, smoothstep(MAX_DIST , MAX_DIST - MAX_DIST * 0.25, d.x)); \n\n    fragColor = vec4(col, 1.0);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// FXAA implementation from\n// https://www.shadertoy.com/view/4tf3D8\n#define RES iResolution.xy\n\nvec3 fxaa(vec2 p) {\n\tconst float FXAA_SPAN_MAX   = 16.0;\n    const float FXAA_REDUCE_MUL = 1.0 / 16.0;\n    const float FXAA_REDUCE_MIN = 1.0 / 128.0;\n\n    vec3 rgbNW = tex(p + (vec2(-1.,-1.) / RES));\n    vec3 rgbNE = tex(p + (vec2( 1.,-1.) / RES));\n    vec3 rgbSW = tex(p + (vec2(-1., 1.) / RES));\n    vec3 rgbSE = tex(p + (vec2( 1., 1.) / RES));\n    vec3 rgbM  = tex(p);\n\n    const vec3 luma = vec3(1.0/3.0);\n\n    float lumaNW = dot(rgbNW, luma);\n    float lumaNE = dot(rgbNE, luma);\n    float lumaSW = dot(rgbSW, luma);\n    float lumaSE = dot(rgbSE, luma);\n    float lumaM  = dot(rgbM,  luma);\n\n    vec2 dir;\n    dir.x = -((lumaNW + lumaNE) - (lumaSW + lumaSE));\n    dir.y =  ((lumaNW + lumaSW) - (lumaNE + lumaSE));\n    \n    float lumaSum   = lumaNW + lumaNE + lumaSW + lumaSE;\n    float dirReduce = max(lumaSum * (0.25 * FXAA_REDUCE_MUL), FXAA_REDUCE_MIN);\n    float rcpDirMin = 1. / (min(abs(dir.x), abs(dir.y)) + dirReduce);\n\n    dir = min(vec2(FXAA_SPAN_MAX), max(vec2(-FXAA_SPAN_MAX), dir * rcpDirMin)) / RES;\n\n    vec3 rgbA = .5 * (tex(p + dir * (1./3. - .5)) +\n        \t\t\t  tex(p + dir * (2./3. - .5)));\n    vec3 rgbB = rgbA * .5 + .25 * (\n        \t\t\t  tex(p + dir * (0./3. - .5)) +\n        \t\t\t  tex(p + dir * (3./3. - .5)));\n    \n    float lumaB = dot(rgbB, luma);\n    \n    float lumaMin = min(lumaM, min(min(lumaNW, lumaNE), min(lumaSW, lumaSE)));\n    float lumaMax = max(lumaM, max(max(lumaNW, lumaNE), max(lumaSW, lumaSE)));\n\n    return ((lumaB < lumaMin) || (lumaB > lumaMax)) ? rgbA : rgbB;\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n    vec2 uv = fragCoord.xy / iResolution.xy;  \n    vec3 col = fxaa(uv);\n    \n    fragColor = vec4(col, 1.);\n}","name":"Buffer B","description":"","type":"buffer"}]}