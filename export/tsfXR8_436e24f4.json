{"ver":"0.1","info":{"id":"tsfXR8","date":"1551328506","viewed":72,"name":"blobs146146","username":"theepicsnail","description":"blobs","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["blobs"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec4 permute(vec4 x){return mod(((x*34.0)+1.0)*x, 289.0);}\nfloat permute(float x){return floor(mod(((x*34.0)+1.0)*x, 289.0));}\nvec4 taylorInvSqrt(vec4 r){return 1.79284291400159 - 0.85373472095314 * r;}\nfloat taylorInvSqrt(float r){return 1.79284291400159 - 0.85373472095314 * r;}\n\nvec4 grad4(float j, vec4 ip){\n  const vec4 ones = vec4(1.0, 1.0, 1.0, -1.0);\n  vec4 p,s;\n\n  p.xyz = floor( fract (vec3(j) * ip.xyz) * 7.0) * ip.z - 1.0;\n  p.w = 1.5 - dot(abs(p.xyz), ones.xyz);\n  s = vec4(lessThan(p, vec4(0.0)));\n  p.xyz = p.xyz + (s.xyz*2.0 - 1.0) * s.www; \n\n  return p;\n}\n\nfloat snoise(vec4 v){\n  const vec2  C = vec2( 0.138196601125010504,  // (5 - sqrt(5))/20  G4\n                        0.309016994374947451); // (sqrt(5) - 1)/4   F4\n// First corner\n  vec4 i  = floor(v + dot(v, C.yyyy) );\n  vec4 x0 = v -   i + dot(i, C.xxxx);\n\n// Other corners\n\n// Rank sorting originally contributed by Bill Licea-Kane, AMD (formerly ATI)\n  vec4 i0;\n\n  vec3 isX = step( x0.yzw, x0.xxx );\n  vec3 isYZ = step( x0.zww, x0.yyz );\n//  i0.x = dot( isX, vec3( 1.0 ) );\n  i0.x = isX.x + isX.y + isX.z;\n  i0.yzw = 1.0 - isX;\n\n//  i0.y += dot( isYZ.xy, vec2( 1.0 ) );\n  i0.y += isYZ.x + isYZ.y;\n  i0.zw += 1.0 - isYZ.xy;\n\n  i0.z += isYZ.z;\n  i0.w += 1.0 - isYZ.z;\n\n  // i0 now contains the unique values 0,1,2,3 in each channel\n  vec4 i3 = clamp( i0, 0.0, 1.0 );\n  vec4 i2 = clamp( i0-1.0, 0.0, 1.0 );\n  vec4 i1 = clamp( i0-2.0, 0.0, 1.0 );\n\n  //  x0 = x0 - 0.0 + 0.0 * C \n  vec4 x1 = x0 - i1 + 1.0 * C.xxxx;\n  vec4 x2 = x0 - i2 + 2.0 * C.xxxx;\n  vec4 x3 = x0 - i3 + 3.0 * C.xxxx;\n  vec4 x4 = x0 - 1.0 + 4.0 * C.xxxx;\n\n// Permutations\n  i = mod(i, 289.0); \n  float j0 = permute( permute( permute( permute(i.w) + i.z) + i.y) + i.x);\n  vec4 j1 = permute( permute( permute( permute (\n             i.w + vec4(i1.w, i2.w, i3.w, 1.0 ))\n           + i.z + vec4(i1.z, i2.z, i3.z, 1.0 ))\n           + i.y + vec4(i1.y, i2.y, i3.y, 1.0 ))\n           + i.x + vec4(i1.x, i2.x, i3.x, 1.0 ));\n// Gradients\n// ( 7*7*6 points uniformly over a cube, mapped onto a 4-octahedron.)\n// 7*7*6 = 294, which is close to the ring size 17*17 = 289.\n\n  vec4 ip = vec4(1.0/294.0, 1.0/49.0, 1.0/7.0, 0.0) ;\n\n  vec4 p0 = grad4(j0,   ip);\n  vec4 p1 = grad4(j1.x, ip);\n  vec4 p2 = grad4(j1.y, ip);\n  vec4 p3 = grad4(j1.z, ip);\n  vec4 p4 = grad4(j1.w, ip);\n\n// Normalise gradients\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n  p4 *= taylorInvSqrt(dot(p4,p4));\n\n// Mix contributions from the five corners\n  vec3 m0 = max(0.6 - vec3(dot(x0,x0), dot(x1,x1), dot(x2,x2)), 0.0);\n  vec2 m1 = max(0.6 - vec2(dot(x3,x3), dot(x4,x4)            ), 0.0);\n  m0 = m0 * m0;\n  m1 = m1 * m1;\n  return 49.0 * ( dot(m0*m0, vec3( dot( p0, x0 ), dot( p1, x1 ), dot( p2, x2 )))\n               + dot(m1*m1, vec2( dot( p3, x3 ), dot( p4, x4 ) ) ) ) ;\n\n}\n\n\n#define PI 3.1416\n#define MAX_DIST 50.0\n#define EPS 0.001\n#define ITR 200.0\nvec2 delta = vec2(.01,0);\nvec3 lastCell = vec3(0);\n\nvec2 rotate(vec2 v, float angle) {return cos(angle)*v+sin(angle)*vec2(v.y,-v.x);}\n\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvec2 rand2(vec2 co){\n    return fract(sin(vec2(dot(co.xy ,vec2(12.9898,78.233)),dot(co.yx,vec2(13.1898,73.231)))) * 43758.5453);\n}\n\nfloat rand3(vec3 co){\n    return fract(sin(dot(co.xyz ,vec3(12.9898,78.233, 49.566))) * 43758.5453);\n}\n\n\nmat3 lookat(vec3 fw){\n\tfw=normalize(fw);vec3 rt=normalize(cross(fw,vec3(0.0,1.0,0.0)));return mat3(rt,cross(rt,fw),fw);\n}\n\n\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nfloat SDF(vec3 ro, vec3 rd) {\n\n    float n = snoise(vec4(ro*.2,iTime*.1));\n    float d = abs(abs(n-.8)-mix(0., .3, abs(cos(iTime))));\n    \n    return d*.5;\n}\n\n\nvec3 EstNormal(vec3 ro, vec3 rd) {\n    float cx = SDF(ro+delta.xyy, rd)-SDF(ro-delta.xyy, rd);\n    float cy = SDF(ro+delta.yxy, rd)-SDF(ro-delta.yxy, rd);\n    float cz = SDF(ro+delta.yyx, rd)-SDF(ro-delta.yyx, rd);\n    return normalize(vec3(cx,cy,cz));\n}\n\nvec3 scene(vec3 ro, vec3 rd, vec2 uv) {\n    vec3 p = ro;\n    float t;\n    float d=0.0;\n    float i = 0.0;\n    float c = 1.0;\n    vec3 pos;\n    for(; i < ITR ; i++) {\n    \tt += d = SDF(pos=ro+rd*t,rd);\n        c = min(d,c);\n        if(t > MAX_DIST || d < EPS) break;\n    }\n   \tvec3 normal =EstNormal(pos, rd);\n    \n    float dist_brightness = 1.0-(t/MAX_DIST);\n    float norm_brightness = -dot(normal, rd);\n    \n    return vec3(1)*norm_brightness*dist_brightness;\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat tim=iTime;\n\tvec2 uv=fragCoord.xy/iResolution.xy;\n\ttim*=0.5;\n\tvec3 ro=vec3(cos(tim),cos(tim*0.3)*0.5,cos(tim*0.7))*min(0.5+tim*0.1+cos(tim*0.4)*0.5,1.5);\n\tvec3 rd=lookat(-ro)*normalize(vec3((fragCoord.xy-0.5*iResolution.xy)/iResolution.y,1.0));\n    \n    ro.yz *= .2;\n    ro.yz += .5;\n    ro.x += iTime;\n    \n\tvec3 color=scene(ro,rd,fragCoord.xy);\n\tcolor=clamp(color,0.0,min(tim,1.0));\n\tfragColor = vec4(color,1.0);\n}\n","name":"Image","description":"","type":"image"}]}