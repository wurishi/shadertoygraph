{"ver":"0.1","info":{"id":"msycDK","date":"1696644146","viewed":137,"name":"Data flow","username":"Krafpy","description":"Futuristic looking flow of data in a wire.","likes":21,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","reflection","tunnel"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define RM_STEPS 256.\n\nmat2 rot(float a){\n    float c = cos(a);\n    float s = sin(a);\n    return mat2(c, s, -s, c);\n}\n\n// hash function from: https://www.shadertoy.com/view/4djSRW\nfloat hash13(vec3 p3){\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.zyx + 31.32);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec3 hash33(vec3 p3){\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n}\n\nvec3 hash31(float p){\n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\nfloat hash11(float p){\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\n\nfloat beat(float a, float b, float t){\n    return smoothstep(0.,a,t)*smoothstep(b,0.,t-a);\n}\n\n\nvec2 path(float z){\n    float w = 0.05;\n    float r = 4.;\n    float s = w*z;\n    return r*vec2(\n        cos(s)*sin(0.5*s),\n        sin(s)*cos(0.7*s)*sin(0.3*s)\n    );\n}\n\n// x = dist, y = id\nvec2 map(vec3 p){\n    float d = 1e9;\n    \n    vec2 tun = p.xy - path(p.z);\n    d = 4. - length(tun);\n    \n    return vec2(d, 0.);\n}\n\nfloat glowAcc = 0.;\n\n// x = dist to itsc, y = i/steps, z = id\nvec3 raymarch(vec3 ro, vec3 rd, float maxT){\n    float t = 0.;\n    \n    for(float i = 0.; i < RM_STEPS && t < maxT; ++i){\n        vec3 p = ro + rd*t;\n        vec2 hit = map(p);\n        if(hit.x < 0.03){\n            return vec3(t, i/RM_STEPS, hit.y);\n        }\n        t += hit.x;\n        \n        float d = hit.x;\n        float h = 0.3;\n        if(abs(d) < h) glowAcc += (h - abs(d))/30.;\n    }\n    return vec3(-1.);\n}\n\n\nfloat pattern(float x){\n    //return step(mod(x, 5.), 1.);\n    float w = 3.;\n    float t = 8.;\n    return smoothstep(0.,w,mod(x,t))*step(mod(x,t),w);\n}\n\nvec3 normal(vec3 p){\n    vec2 h = vec2(0.001, 0.);\n    return normalize(vec3(\n        map(p + h.xyy).x - map(p - h.xyy).x,\n        map(p + h.yxy).x - map(p - h.yxy).x,\n        map(p + h.yyx).x - map(p - h.yyx).x\n    ));\n}\n\nvec3 render(vec3 ro, vec3 rd, inout vec3 hit, float iter){\n    hit = raymarch(ro, rd, 100.);\n    \n    vec3 p = ro + rd*hit.x;\n    \n    vec3 finalCol = vec3(0.);\n    \n    // very basic antialiasing\n    for(float j = 0.; j < iter; j++){\n        vec3 col = vec3(1.);\n        \n        p += (hash31(j+iTime)*0.5-0.5)*0.005;\n\n        col *= 1. - hit.y;\n        \n        vec3 q = p;\n        q.xy -= path(q.z);\n        float a = atan(q.y,q.x);\n        a /= 3.141492*2.;\n        float n = 100.;\n        float i = floor(a*n);\n        vec3 c0 = clamp(hash31(i)+0.5,0.,1.);\n        col *= c0;\n\n        float h = hash11(i);\n        float o = h*50.;\n        float v = (h*0.5+0.5)*5.;\n        float pat = pattern(p.z*0.1 + o - iTime*10.);\n        col = mix(vec3(0.02), col, pat);\n        \n        float bt = mod(iTime + h*33., 30.);\n        col = mix(col, vec3(1.5,0.3,0.4), beat(0.1,0.5,bt));\n\n        float d = abs(a - (i+0.5)/n);\n        float w = 0.35/n;\n        float lines = step(d,w);\n        col = mix(vec3(0.01), col, lines);\n\n        float b = step(1., mod(p.z, 5.));\n        col = mix(vec3(0.01), col, b);\n        \n        finalCol += col;\n    }\n    \n    finalCol /= iter;\n    \n    return finalCol;\n}\n\n\nfloat fresnel(vec3 n, vec3 v){\n    float n1 = 1.;\n    float n2 = 1.5;\n    float r0 = (n1-n2)/(n1+n2); r0 *= r0;\n    float d = max(0., dot(n, v));\n    return r0 + (1.-r0)*pow(1.-d, 5.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= 0.5;\n    uv.x *= iResolution.x/iResolution.y;\n\n    vec3 col = vec3(0.);\n    \n    float cz = iTime*40.;\n    vec3 ro = vec3(path(cz), cz);\n    \n    float o = 2.;\n    vec3 lookAt = vec3(path(cz+o), cz+o);\n    \n    vec3 forward = normalize(lookAt - ro);\n    vec3 right = vec3(forward.z, 0., -forward.x); // 90Â° rotation\n    vec3 up = cross(forward, right);\n    \n    vec3 rd = normalize(uv.x*right + uv.y*up + forward);\n    \n    vec3 hit;\n    col = render(ro, rd, hit, 10.);\n    float t0 = hit.x;\n    \n    vec3 fogCol = vec3(0.2,0.5,0.6);\n    \n    vec3 p = ro + rd*hit.x;\n    vec3 n = normal(p);\n    \n    float fres = fresnel(n, -rd);\n    \n    ro = p + n*0.04;\n    vec3 rcol = vec3(0.);\n    \n    if(hit.x > 0.){\n        float Nref = 10.;\n        for(float i = 0.; i < Nref; i++){\n            vec3 rnd = (hash31(i+iTime)*0.5-0.5)*0.005;\n            rd = reflect(normalize(rd + rnd), n);\n            rcol += render(ro, rd, hit, 1.)*0.6;\n        }\n        col = mix(col, rcol/Nref, fres);\n        \n        float fog = smoothstep(5.,100.,t0);\n        col = mix(col, fogCol, fog);\n    } else {\n        col = fogCol;\n    }\n    \n    // gamma\n    col = pow(col, vec3(1./2.2));\n\n    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}