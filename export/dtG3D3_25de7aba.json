{"ver":"0.1","info":{"id":"dtG3D3","date":"1684764324","viewed":87,"name":"2D Displace With Map","username":"deadsett","description":"adsf","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["asdf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Xdf3zn","filepath":"/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png","previewfilepath":"/media/ap/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float field( vec2 uv ){\n    return texture( iChannel0, uv ).r;\n}\nvec3 getNormal( vec2 uv ){\n    vec3 pix = vec3 (1./iResolution.xy, 0.);\n    return normalize(  vec3(\n        ( field( uv - pix.xz ) - field( uv + pix.xz ) ),\n        ( field( uv - pix.zy ) - field( uv + pix.zy ) ),\n        1.0\n    ) );\n}\n\n// Interpolation function\nfloat interpolate(float a, float b, float t) {\n    return a + (b - a) * t;\n}\n\n// Simple noise function based on the fractional part of the sin function\nfloat noise(float t) {\n    float i = floor(t);\n    float f = fract(t);\n    float a = fract(sin(i) * 43758.5453);\n    float b = fract(sin(i + 1.0) * 43758.5453);\n    float u = f * f * (3.0 - 2.0 * f);\n    return interpolate(a, b, u);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\n        // Calculate time in seconds and find its fractional part.\n    // This value increases with time, but always stays between 0 and 1 due to the fract() function\n    float time = iTime * 23.0f;\n    \n    // Get the noise value based on the current time\n    float n = noise(time*0.1);\n    \n    // Lightning function\n    float lightning = pow(2.71828, -10.0*n) * abs(sin(2.0 * 3.14159 * n));\n    \n    // Set the color of the pixel\n    vec3 color = vec3(lightning);\n    \n    // Set the color of the pixel\n    vec4 light = vec4(lightning);\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord / iResolution.xy;\n   \n    // Calculate normal using getNormal function\n    vec3 normal = getNormal(uv + iTime * 0.015);\n    \n    // Calculate distortion with mask\n    vec2 distorsion = normal.xy * 0.2 * texture(iChannel2, uv).r;\n    \n    vec2 move = vec2(0, 0.01f* sin(iTime));\n\n    // Apply distortion to texture coordinates\n    vec4 displacedTexture = texture(iChannel1, uv + distorsion + move);\n    \n    // Output to screen\n    fragColor = displacedTexture + light* 0.1f;\n}","name":"Image","description":"","type":"image"}]}