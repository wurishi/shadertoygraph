{"ver":"0.1","info":{"id":"fll3z7","date":"1621860166","viewed":156,"name":"Sunset Blobbies","username":"pajunen","description":"Blobs.","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["metaballs","shadow","volumetric","preetham"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Implementation of 1999 preetham skylight model\n\n#define T 4.5\n#define M_PI 3.1415926535897932384626433832795\n\n// Radiance distribution parameters\nfloat A_x = -0.0193 * T - 0.2592;\nfloat B_x = -0.0665 * T + 0.0008;\nfloat C_x = -0.0004 * T + 0.2125;\nfloat D_x = -0.0641 * T - 0.8989;\nfloat E_x = -0.0033 * T + 0.0452;\n\nfloat A_y = -0.0167 * T - 0.2608;\nfloat B_y = -0.0950 * T + 0.0092;\nfloat C_y = -0.0079 * T + 0.2102;\nfloat D_y = -0.0441 * T - 1.6537;\nfloat E_y = -0.0109 * T + 0.0529;\n\nfloat A_Y =  0.1787 * T - 1.4630;\nfloat B_Y = -0.3554 * T + 0.4275;\nfloat C_Y = -0.0227 * T + 5.3251;\nfloat D_Y =  0.1206 * T - 2.5771;\nfloat E_Y = -0.0670 * T + 0.3703;\n\n// Matrices for chromaticity calculations\nmat4x3 x_chromaticity = mat4x3(\n    0.0017, -0.0290, 0.1169,\n   -0.0037,  0.0638,-0.2120,\n    0.0021, -0.0320, 0.0605,\n    0.0000,  0.0039, 0.2589\n);\n\nmat4x3 y_chromaticity = mat4x3(\n    0.0028, -0.0421,  0.1535,\n   -0.0061,  0.0897, -0.2676,\n    0.0032, -0.0415,  0.0667,\n    0.0000,  0.0052,  0.2669\n);\n\nfloat angle(float z1, float a1, float z2, float a2) {\n\treturn acos(\n        sin(z1) * cos(a1) * sin(z2) * cos(a2) +\n        sin(z1) * sin(a1) * sin(z2) * sin(a2) +\n        cos(z1) * cos(z2));\n}\n\nfloat zenith_chromaticity(float sun_z, mat4x3 coefficients) {\n    vec3 T_vec = vec3(T * T, T, 1);\n    vec4 Z_vec = vec4(sun_z*sun_z*sun_z, sun_z*sun_z, sun_z, 1.0);\n    return dot(T_vec, coefficients * Z_vec);\n}\n\nfloat zenith_luminance(float sun_z) {\n \tfloat chi = (4.0 / 9.0 - T / 120.0) * (M_PI - 2.0 * sun_z);\n    return (4.0453 * T - 4.9710) * tan(chi) - 0.2155 * T + 2.4192;\n}\n\nfloat F(float theta, float gamma, float A, float B, float C, float D, float E) {\n\treturn (1.0 + A * exp(B / cos(theta))) * (1.0 + C * exp(D * gamma) + E * pow(cos(gamma), 2.0));\n}\n\n// CIE-xyY to CIE-XYZ\nvec3 xyY_to_XYZ(float x, float y, float Y) {\n\treturn vec3(x * Y / y, Y, (1.0 - x - y) * Y / y);\n}\n\n// CIE-XYZ to linear RGB\nvec3 XYZ_to_RGB(vec3 XYZ) {\n    mat3 XYZ_to_linear = mat3(\n  \t\t 3.24096994, -0.96924364, 0.55630080,\n        -1.53738318,  1.8759675, -0.20397696,\n        -0.49861076,  0.04155506, 1.05697151\n    );\n    return XYZ_to_linear * XYZ;\n}\n\n// CIE-xyY to RGB\nvec3 xyY_to_RGB(float x, float y, float Y) {\n \tvec3 XYZ = xyY_to_XYZ(x, y, Y);\n   \tvec3 sRGB = XYZ_to_RGB(XYZ);\n    return sRGB;\n}\n\n// Clamps color between 0 and 1 smoothly\nvec3 expose(vec3 color, float exposure) {\n    return vec3(2.0) / (vec3(1.0) + exp(-exposure * color)) - vec3(1.0);\n}\n\nvec2 to_zenith_azimuth(vec3 v) {\n \tfloat zenith = acos(v.y);\n    float azimuth = atan(v.x, v.z);\n    return vec2(zenith, azimuth);\n}\n\nvec3 sun_d;\n\nvec3 sample_sky(vec3 v) {\n    vec3 V = v;\n    \n    if (v.y < 0.) V.y = -V.y;\n        \n    vec2 sun_zenith_azimuth = to_zenith_azimuth(sun_d);  \n    \n    vec2 zenith_azimuth = to_zenith_azimuth(V);\n    \n    float gamma = angle(zenith_azimuth.x, zenith_azimuth.y, sun_zenith_azimuth.x, sun_zenith_azimuth.y);\n    float theta = zenith_azimuth.x;\n    \n    float sun_angular_radius = M_PI / 360.0; // About 0.5 deg\n    \n    \n    float x_z = zenith_chromaticity(sun_zenith_azimuth.x, x_chromaticity);\n    float y_z = zenith_chromaticity(sun_zenith_azimuth.x, y_chromaticity);\n    float Y_z = zenith_luminance(sun_zenith_azimuth.x);\n    \n    float x = x_z * F(theta, gamma, A_x, B_x, C_x, D_x, E_x) / F(0.0, sun_zenith_azimuth.x, A_x, B_x, C_x, D_x, E_x);\n    float y = y_z * F(theta, gamma, A_y, B_y, C_y, D_y, E_y) / F(0.0, sun_zenith_azimuth.x, A_y, B_y, C_y, D_y, E_y);\n  \tfloat Y = Y_z * F(theta, gamma, A_Y, B_Y, C_Y, D_Y, E_Y) / F(0.0, sun_zenith_azimuth.x, A_Y, B_Y, C_Y, D_Y, E_Y);\n    \n    vec3 col = xyY_to_RGB(x, y, Y);\n\n    if (gamma < sun_angular_radius && v.y > 0.) {\n         col = vec3(100000.);\n    }\n    \n    if (v.y < 0.) col = mix(15. * vec3(0.05,0.09,0.15), col, pow(zenith_azimuth.x / (M_PI / 2.), 20.));\n    \n    return col;\n}\n\nfloat smin( float a, float b, float k )\n{\n  float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n  return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat sphere_dist(vec3 x, vec3 s_pos, float r) {\n    return length(s_pos - x) - r;\n}\n\nfloat shadow_volume(vec3 x, vec3 pos, vec3 d,  float r) {\n    float proj = dot(x - pos,d);\n    if (proj < 0.) return sphere_dist(x, pos, r);\n    return length(x - pos - proj * d) - r;\n}\n\nfloat scene(vec3 x) {\n    float balls = 100000.0;\n    balls = smin(balls, sphere_dist(x, vec3(sin(iTime), cos(iTime), sin(iTime)), .8), 0.7);\n    balls = smin(balls, sphere_dist(x, vec3(-sin(2. * iTime), -cos(0.1 * iTime), sin(iTime)), 0.5), 0.7);\n    balls = smin(balls, sphere_dist(x, vec3(sin(.5 * iTime), -sin(0.8 * iTime + 0.4), 2. * sin(0.3 * iTime)), 0.5), 0.7);\n    return balls;//sphere_dist(x, vec3(0),1.2);\n}\n\n#define EPSILON .00001\n\nfloat opS( float d1, float d2 )\n{\n    return max(-d1,d2);\n}\n\nfloat shadow(vec3 x) {\n    float balls = 100000.0;\n    balls = smin(balls, shadow_volume(x, vec3(sin(iTime), cos(iTime), sin(iTime)), -sun_d, .8), 0.7);\n    balls = smin(balls, shadow_volume(x, vec3(-sin(2. * iTime), -cos(0.1 * iTime), sin(iTime)), -sun_d, 0.5), 0.7);\n    balls = smin(balls, shadow_volume(x, vec3(sin(.5 * iTime), -sin(0.8 * iTime + 0.4), 2. * sin(0.3 * iTime)), -sun_d, 0.5), 0.7);\n    return opS(scene(x - sun_d * 0.01), balls);\n}\n\n\nvec3 normal(vec3 x) {\n    float x_pos = scene(x + vec3(EPSILON, 0, 0));\n    float x_neg = scene(x - vec3(EPSILON, 0, 0));\n    float y_pos = scene(x + vec3(0, EPSILON, 0));\n    float y_neg = scene(x - vec3(0, EPSILON, 0));\n    float z_pos = scene(x + vec3(0, 0, EPSILON));\n    float z_neg = scene(x - vec3(0, 0, EPSILON));\n    \n    float dx = x_pos - x_neg;\n    float dy = y_pos - y_neg;\n    float dz = z_pos - z_neg;\n    \n    return normalize(vec3(dx, dy, dz));\n}\n\nmat3 rotationX( in float angle ) {\n\treturn mat3(\t1.0,\t\t     0,\t\t\t  0,\n\t\t\t \t\t  0, \tcos(angle),\t-sin(angle),\n\t\t\t\t\t  0, \tsin(angle),\t cos(angle));\n}\n\nmat3 rotationY( in float angle ) {\n\treturn mat3(\tcos(angle),\t\t0,\t\tsin(angle),\n\t\t\t \t\t\t\t0,\t\t1.0,\t\t\t 0,\n\t\t\t\t\t-sin(angle),\t0,\t\tcos(angle));\n}\n\nmat3 rotationZ( in float angle ) {\n\treturn mat3(\tcos(angle),\t\t-sin(angle),\t0,\n\t\t\t \t\tsin(angle),\t\tcos(angle),\t\t0,\n\t\t\t\t\t\t\t0,\t\t\t\t0,\t\t1);\n}\n\nvec3 fresnel_schlick(float cosTheta, vec3 F0)\n{\n    return F0 + (max(vec3(1.0), F0) - F0) * pow(1.0 - cosTheta, 5.0);\n}   \n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.x - vec2(0.5, .5 * iResolution.y / iResolution.x);\n    \n    float ROT = 0.5 * iTime + 3.9;\n    \n    sun_d = vec3(0,0,1) * rotationX(-(M_PI / 5.) * (sin(ROT) + 1.) / 2.) * rotationY(sin(ROT + M_PI/2.));\n\n        \n    vec3 cam_pos = vec3(-4.,-1.5, -3); \n    vec3 v = normalize(vec3(uv, 0.2)) * rotationX(-.4) * rotationY(.2);\n        \n    vec3 col = sample_sky(v);\n    \n    float shadow_thickness = 0.0;\n   \n    vec3 ray = cam_pos;\n    for (int i = 0; i < 70; ++i) {\n        float d = scene(ray);\n        float distance_to_shadow = shadow(ray);\n        bool in_shadow = distance_to_shadow < 0.001;\n        \n        if (d < 0.01) {\n            vec3 n = normal(ray);\n            float cos_theta = max(dot(n, -v), 0.0);  \n            vec3 f = fresnel_schlick(cos_theta, vec3(0.1));      \n            vec3 ambient = 13. * vec3(0.05,0.09,0.15);\n            vec3 albedo = vec3(1,1,1);\n            float NdotL = max(dot(n, sun_d), 0.0);                \n            col = ambient + ((1.0 - f) * albedo / M_PI + sample_sky(n) * f) * 1.0 * NdotL; \n            break;\n        }\n                \n        float march = (in_shadow ? min(max(d, 0.01), max(-distance_to_shadow, 0.1)) : min(max(d, 0.01), max(distance_to_shadow, 0.1)));\n        ray += v * march;\n        if (in_shadow) {\n            shadow_thickness += march;\n        }\n    }\n    \n    \n    col = expose(col, 0.3);\n\n    // Output to screen\n    fragColor = exp(- 0.1 * shadow_thickness) * vec4(col, 1);\n}","name":"Image","description":"","type":"image"}]}