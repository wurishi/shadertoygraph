{"ver":"0.1","info":{"id":"MlfXz8","date":"1434409677","viewed":404,"name":"Time-o-matic","username":"104","description":"My attempt at making the smallest timer display possible. I'm afraid there's a lot of room for improvement. Probably the design is fundamentally inferior.","likes":12,"published":1,"flags":0,"usePreview":0,"tags":["short"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[],"code":"// My attempt to make a very small numerical display, showing integer part of iTime in base-10.\n// Digits are encoded as 2 subtracted rectangles. maybe there's a smaller way to encode the coords?\n\n//---------------------------------------------------------\n// attempt #6: 523 chars\n// more geom encoding using swizzling.\n// todo: R() can probably be size-optimized.\n#define G g+.2/p.ywyw*\n#define E if(floor(mod(t,10.)) == n++) e=G\n#define R(b) (i.x>=b.x&&i.x<b.z&&i.y>=b.y&&i.y<b.w)?1.:-1.// is i inside the rect b? b.xy/topleft, b.zw=bottomright\nvoid mainImage(out vec4 o,vec2 i)\n{\n    o.xyz=iResolution;\n    i/=o.xy;\n    i.x*=o.x/o.y/.7;\n    float d = 1., t=iTime, n;\n    for(float z=5.;z>0.;z--)\n    {\n\t    vec4 g = vec4(z,2,z,2)/4.,\n            e=vec4(1,3,2,4),f=e,j=f.xxzz,k=f.xyyw,m=j,p=f;\n        m.x=e.x=n=0.;\n        p.w=5.;\n        // e = 0 3 2 4\n        // f = 1 3 2 4\n        // j = 1 1 2 2\n        // k = 1 3 3 4\n        // m = 0 1 2 2\n        // p = 1 3 2 5\n        E f.xxzw;\n        E p-f.zwxx+1.;\n        E e,f=G f.xxyz;\n        E e,f=G m;\n        E e.xxzz,f=G p;\n        E m,f=G k;\n        E k,f=G j;\n        E e.xxzw;\n        E j,f=G f;\n        E m,f=G f;\n        t/=10.;\n        d = max(max(min(d, -(R(vec4(g.xy,g.xy+.2)))),\n                    R(e)),\n                R(f));\n\n    }\n    o=o*0.-d;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n//---------------------------------------------------------\n// attempt #5: 569 chars\n/*\n#define G g+.2/vec4(3,5,3,5)*vec4\n#define E if(floor(mod(t,10.)) == n++) e=G\n#define F ,f=G\n#define R(b) (i.x>=b.x&&i.x<b.z&&i.y>=b.y&&i.y<b.w)?1.:-1.// is i inside the rect b? b.xy/topleft, b.zw=bottomright\nvoid mainImage(out vec4 o,vec2 i)\n{\n    o.xyz=iResolution;\n    i/=o.xy;\n    i.x*=o.x/o.y/.7;\n    o*=0.;\n    float d = 1., t=iTime, n;\n    for(float z=5.;z>0.;z--)\n    {\n\t    vec4 g = vec4(z,2,z,2)/4.,\n        e=vec4(0,1,2,2),f=o;// our 2 rects (xy=top left, zw=bottom right)\n        n=0.;\n        E(1,1,2,4);\n        E(0,0,1,5)F(2,0,3,5);\n        E(0,3,2,4)F(1,1,3,2);\n        E(e)F(0,3,2,4);\n        E(1,3,2,5)F(0,0,2,2);\n        E(e)F(1,3,3,4);\n        E(1,3,3,4)F(1,1,2,2);\n        E(0,0,2,4);\n        E(1,1,2,2)F(1,3,2,4);\n        E(e)F(1,3,2,4);\n        t/=10.;\n        // geometry\n        d = max(max(\n                    min(d, -(R(vec4(g.xy,g.xy+.2)))),\n                    R(e)),\n                R(f)\n               );\n\n    }\n    o-=d;\n}\n\n*/\n\n\n//---------------------------------------------------------\n// attempt #6: 600+ chars\n/*\nmy attempt at encoding the digits as base-6 single values.\nBut the unpacking takes way too much code. currently it's broken; seems unviable.\n\ni could try operating on 2 vec2s instead of a single vec4. Unpacking is a pain in the ass\nbecause there are no bitwise ops. So I end up having to use floor(mod()) etc. So the best\nencoding will depend on the smallest method of unpacking. Maybe X=ceil and Y=fract*6. or so?\n\n*/\n/*\n#define X(x,b) floor(mod(x,b))\n#define G(x) g.xyxy+.2/vec4(3,5,3,5)*vec4(X(x/36.*6.,6.),X(x/36.,6.),X(x/6.,6.),X(x,6.))\n#define E(x) if(X(t,10.) == n++) e=G(x)\n#define R(b) (i.x>=b.x&&i.x<b.z&&i.y>=b.y&&i.y<b.w)?1.:-1.\nvoid mainImage(out vec4 o,vec2 i)\n{\n    o.xyz=iResolution;\n    i/=o.xy;\n    i.x*=o.x/o.y/.7;\n    o*=0.;\n    float d = 1., t=iTime, n;\n    for(float z=5.;z>0.;--z)\n    {\n\t    vec2 g = vec2(.24*z,.6);\n        vec4 e,f=o;// our 2 rects (xy=top left, zw=bottom right)\n        n=0.;\n        E(268.);\n        E(11.),f=G(455.);\n        E(124.),f=G(272.);\n        E(50.),f=G(124.);\n        E(341.),f=G(14.);\n        E(50.),f=G(346.);\n        E(346.),f=G(266.);\n        E(16.);\n        E(266.),f=G(340.);\n        E(340.),f=G(50.);\n        t/=10.;\n        d = max(max(\n                    min(d, -(R(vec4(g, g+.2)))),\n                    R(e)),\n                R(f)\n               );\n\n    }\n    o-=d;\n}\n\n*/\n\n\n\n\n//---------------------------------------------------------\n// attempt #4: 595 chars\n/*\n// i = input (uv)\n// o = output\n// d = distance\n// z = loop iterator\n// e = rect1\n// f = rect2\n// g = origin of digit\n// k = multiplier temp value\n// n = temp variable for testing digit\n// s = another temp variable\n\n#define G g.xyxy+.2/vec4(3,5,3,5)*vec4\n#define E if(floor(mod(t,10.)) == n++) e=G\n#define F f=G\n#define R(b) (i.x>=b.x&&i.x<b.z&&i.y>=b.y&&i.y<b.w)?1.:-1.\nvoid mainImage(out vec4 o,vec2 i)\n{\n    o.xyz=iResolution;\n    i/=o.xy;\n    i.x*=o.x/o.y*1.2;\n    i.y=1.-i.y;\n    o*=0.;\n\n    float d = 1., t=iTime, n;\n    \n    for(float z=5.;z>0.;--z)\n    {\n\t    vec2 g = vec2(.24*z,.2);\n        vec4 e,// our 2 rects (xy=top left, zw=bottom right)\n            f=o;\n\n        n=0.;\n        E(1,1,2,4);\n        E(0,0,1,5), F(2,0,3,5);\n        E(0,1,2,2), F(1,3,3,4);\n        E(0,1,2,2), F(0,3,2,4);\n        E(1,0,2,2), F(0,3,2,5);\n        E(1,1,3,2), F(0,3,2,4);\n        E(1,1,3,2), F(1,3,2,4);\n        E(0,1,2,5);\n        E(1,1,2,2), F(1,3,2,4);\n        E(1,1,2,2), F(0,3,2,5);\n        t/=10.;\n\n        d = max(max(\n                    min(d, -(R(vec4(g, g+.2)))),\n                    R(e)),\n                R(f)\n               );\n\n    }\n    o-=d;\n}\n\n\n*/\n\n\n\n\n//---------------------------------------------------------\n// attempt #3: 653 chars\n/*\n// d = distance\n// o = output\n// i = input (uv)\n// z = loop iterator\n// e = rect1\n// f = rect2\n// g = origin of digit\n// k = multiplier temp value\n// n = temp variable for testing digit\n\n#define G vec4(g,g)+.2/vec4(3,5,3,5)*vec4\n#define E if(floor(mod(t,10.)) == n++) e=G\n#define F f=G\nfloat R(vec2 d, vec4 b)\n{\n    d=max(b.xy-d,d-b.zw);\n    return length(max(d-d, d)) + min(0.,max(d.x,d.y));\n}\n\nvoid mainImage(out vec4 o,vec2 i)\n{\n    float d = 1e9, t=iTime, n;\n    o.xyz=iResolution;\n    i/=o.xy;\n    i.x*=o.x/o.y*1.2;\n    i.y=1.-i.y;\n\n    for(float z=5.;z>0.;--z)\n    {\n\t    vec2 g = vec2(.24*z,.2);\n        vec4 e,f=o;// safe because iResolution is always big enough that this will be off-screen.\n\n        n=0.;\n        E(1,1,2,4);\n        E(0,0,1,5), F(2,0,3,5);\n        E(0,1,2,2), F(1,3,3,4);\n        E(0,1,2,2), F(0,3,2,4);\n        E(1,0,2,2), F(0,3,2,5);\n        E(1,1,3,2), F(0,3,2,4);\n        E(1,1,3,2), F(1,3,2,4);\n        E(0,1,2,5);\n        E(1,1,2,2), F(1,3,2,4);\n        E(1,1,2,2), F(0,3,2,5);\n        t/=10.;\n\n        d = max(\n            max(\n                min(d, R(i, vec4(g, g+.2))),\n                -R(i,e)),\n            -R(i,f));\n\n    }\n    o = vec4(i,i*i)* step(0.,-d);\n}\n\n\n*/\n\n\n\n\n\n\n//---------------------------------------------------------\n// attempt #2: 695 chars\n/*\n\nfloat R(vec2 d, vec4 b)\n{\n    d=max(b.xy-d,d-b.zw);\n    return length(max(d-d, d)) + min(0.,max(d.x,d.y));\n}\n// d = distance\n// o = output\n// i = input (uv)\n// z = loop iterator\n// e = rect1\n// f = rect2\n// v = digit value\n// g = origin of digit\n// k = multiplier temp value\n\n#define E if(v == n++) e=vec4(g,g)+k*vec4\n#define F f=k*vec4\n#define O 1,1// to save chars you need to use a 3-char #define 7 times.\n\nvoid mainImage(out vec4 o,vec2 i)\n{\n    float d = 1e9, t = iTime, v,n;\n    o.xyz=iResolution;\n    i/=o.xy;i.x*=o.x/o.y;\n    i.y=1.-i.y;\n    o=o-o;\n\n    for(float z=0.;z<4.;++z)\n    {\n        v = floor(mod(t,10.));\n        t/=10.;\n\t    vec2 g = vec2(.24 * (5.-z), .3);\n\n        vec4 e,\n            f=o,\n            k=.2/vec4(3,5,3,5);\n\n        n=0.;\n        E(O,1,3);\n        E(0,0,1,5), F(2,0,1,5);\n        E(0,1,2,1), F(1,3,2,1);\n        E(0,1,2,1), F(0,3,2,1);\n        E(1,0,1,2), F(0,3,2,2);\n        E(O,2,1), F(0,3,2,1);\n        E(O,2,1), F(1,3,1,1);\n        E(0,1,2,4);\n        E(O,1,1), F(1,3,1,1);\n        E(O,1,1), F(0,3,2,2);\n\n        e.zw += e.xy;\n        f.zw += f.xy;\n//        e += vec4(g,g);\n  //      f += vec4(g,g);\n        \n        d = max(\n            max(\n                min(d, R(i, vec4(g, g + .2))),\n                -R(i,e)),\n            -R(i,f));\n\n    }\n    o = mix(vec4(i,i*i),o, step(0.,d));\n}\n\n*/\n\n\n\n\n\n//---------------------------------------------------------\n// original: 1245 chars.\n/*\nfloat opS( float d2, float d1 ){ return max(-d1,d2); }\n\nfloat sdr(vec2 uv, vec2 tl, vec2 br)\n{\n    vec2 d = max(tl-uv, uv-br);\n    return length(max(vec2(0.0), d)) + min(0.0, max(d.x, d.y));\n}\n\nvoid mainImage(out vec4 o,vec2 i)\n{\n    float d = 1e9;\n    float t = iTime;\n    o.xyz=iResolution;\n    i/=o.xy;i.x*=o.x/o.y;\n    i.y=1.-i.y;\n    o=o-o;\n    vec2 digitSize = vec2(.2,.3);\n    vec4 color = vec4(i,i*i);\n\n    for(float z=0.;z<5.;++z)\n    {\n        float v = floor(mod(t,10.));\n        vec4 rect1=o,rect2=o;\n        if(v == 1.)\n            rect1=vec4(0,0,1,5), rect2=vec4(2,0,1,5);\n        if(v == 2.)\n            rect1=vec4(0,1,2,1), rect2=vec4(1,3,2,1);\n        if(v == 3.)\n            rect1=vec4(0,1,2,1), rect2=vec4(0,3,2,1);\n        if(v == 4.)\n            rect1=vec4(1,0,1,2), rect2=vec4(0,3,2,2);\n        if(v == 5.)\n            rect1=vec4(1,1,2,1), rect2=vec4(0,3,2,1);\n        if(v == 6.)\n            rect1=vec4(1,1,2,1), rect2=vec4(1,3,1,1);\n        if(v == 7.)\n            rect1=vec4(0,1,2,4);\n        if(v == 8.)\n            rect1=vec4(1,1,1,1), rect2=vec4(1,3,1,1);\n        if(v == 9.)\n            rect1=vec4(1,1,1,1), rect2=vec4(0,3,2,2);\n        if(v == 0.)\n            rect1=vec4(1,1,1,3);\n\n        vec2 origin = vec2((digitSize.x + .05) * (5.-z), 0);\n        origin.y += 0.3;// offset on screen.\n        \n        rect1 *= vec4(digitSize,digitSize)/vec4(3,5,3,5);\n        rect2 *= vec4(digitSize,digitSize)/vec4(3,5,3,5);\n\n        rect1.zw += rect1.xy;\n        rect2.zw += rect2.xy;\n        rect1 += vec4(origin,origin);\n        rect2 += vec4(origin,origin);\n        \n        d = min(d,sdr(i, origin, origin + digitSize));\n        d = opS(d, sdr(i, rect1.xy,rect1.zw));\n        d = opS(d, sdr(i, rect2.xy,rect2.zw));\n\n        t/=10.;\n    }\n        o = mix(color,o, step(0.,d));\n}\n*/\n","name":"","description":"","type":"image"}]}