{"ver":"0.1","info":{"id":"wsjGRw","date":"1548480823","viewed":1193,"name":"Anime background","username":"mmerchante","description":"A mix of anime speed lines and an electric shock. Had to change the source song!","likes":30,"published":1,"flags":0,"usePreview":0,"tags":["2d","lines","animated","speed","anime","hero","graphic","speedlines"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Quick and dirty line experiment to generate electric bolts :)\n\n// http://extremelearning.com.au/unreasonable-effectiveness-of-quasirandom-sequences/\nfloat R1seq(int n)\n{\n\treturn fract(float(n) * 0.618033988749894848204586834365641218413556121186522017520);\n}\n\nvec2 R2seq(int n)\n{\n\treturn fract(vec2(n) * vec2(0.754877666246692760049508896358532874940835564978799543103, 0.569840290998053265911399958119574964216147658520394151385));\n}\n\n// modified iq's segment: https://www.shadertoy.com/view/ldj3Wh\nvec2 Line(vec2 a, vec2 b, vec2 p, vec2 identity, float sa, float sb)\n{\n    vec2 pa = p - a;\n    vec2 pb = p - b;\n\tvec2 ba = b - a;\n\tfloat t = clamp(dot(pa,ba)/dot(ba,ba), 0.0, 1.0);    \n    vec2 pp = a + ba * t;\n    vec2 y = vec2(-identity.y, identity.x);\n    float cutoff = max(dot(pb, identity), dot(pa, -identity));\n    float s = mix(sa, sb, t);\n    return vec2(max(cutoff - .005, abs(dot(y, p - pp)) - s), t);\n}\n\nfloat Rythm(float x)\n{\n    x = x * 6.28318 * 10.0 / 60.0;\n\tx = smoothstep(-1.0, 1.0, sin(x));\n\tx = smoothstep(0.0, 1.0, x);\n\tx = smoothstep(0.0, 1.0, x);\n\tx = smoothstep(0.0, 1.0, x);\n\tx = smoothstep(0.0, 1.0, x);\n\treturn x;\n}\n\nvec3 Background(vec2 uv, vec2 baseDir, float time)\n{\n    uv = uv * vec2(.75, .75) + vec2(-.0, .0);\n\tvec3 result = vec3(0.91, 0.56, 0.02);\n    \n    vec2 n = vec2(-baseDir.y, baseDir.x);\n    \n    result = mix(result, vec3(1.0) - result, Rythm(time));\n    \n    float lines = texture(iChannel0, vec2(uv.x - uv.y) + vec2(time * 1.35, 0.0)).r;\n    result += lines * lines * .75 + lines * lines * lines * .35;    \n    result *= smoothstep(.5, .0, abs(dot(uv, n)));\n    \n    return result * 1.25;\n}\n\nvec3 Magic(float leadTime, vec3 baseColor, vec2 uv, vec2 baseDir, float time, float spread, float freq, float intensity)\n{\n    int frame = iFrame / 12;\n    \n    float speed = -1.5 - ((Rythm(time)) * .5 + .5) * 2.0;\n    //speed *= .2;\n    vec2 dir = normalize(baseDir);\n    \n    \n    uv -= dir * mix(.1, .3, Rythm(time));\n    \n    vec2 normal = vec2(-dir.y, dir.x);\n    \n    vec2 baseOffset = dir * speed * floor(float(iFrame) / 24.0);\n    \n    vec2 p = uv;\n    p += dir * speed * (float(iFrame) / 24.0);\n    p -= R2seq(int(floor(float(iFrame)/3.0))) * .05;\n    p += normal * sin(time * 12.0) * .05;\n            \n    float ray = 0.0;\n\tfloat glow = 0.0;\n    \n    p += (texture(iChannel1, p * .015 + leadTime * .25).xy * 2.0 - 1.0) * .1;\n    \n    float leadIntro = mix(.3, .015, smoothstep(10.0, 14.0, time));\n    \n    float leadingTime = 1.0 - smoothstep(leadTime - .5, leadTime, time);\n    float distanceToLead = dot(uv - .5, dir) - leadingTime * 2.0 - leadIntro;\n    float leadingMask = smoothstep(-.85, -.0, distanceToLead);\n    \n    p += leadingMask * (texture(iChannel1, vec2(time * .01 + leadTime * .35)).xy * 2.0 - 1.0) * .35;\n    \n    float sizeIntro = smoothstep(13.85, 14.15, time);\n    spread *= leadingMask * (1.0 - Rythm(time) * .75) * sizeIntro;\n    \n    for(int i = -12; i < 10; i++)\n    {\n\t\tfloat offsetA = R1seq(i+frame) * 2.0 - 1.0;\n        float offsetB = R1seq(i+frame+1) * 2.0 - 1.0;\n        \n        vec2 a = baseOffset + dir * float(i) * freq + normal * offsetA * spread;\n        vec2 b = baseOffset + dir * float(i+1) * freq + normal * offsetB * spread;\n        \n        float sa = mix(.05, 3.0 * intensity, R1seq(frame*7+i-1)) * .005;\n        float sb = mix(.05, 3.0 * intensity, R1seq(frame*7+i)) * .005;\n        \n        vec2 l = Line(a, b, p, dir, sa, sb);\n        float d = .025 * leadingMask;\n\t\t\n        ray += smoothstep(d, d * .75 - .0001, l.x);\n        glow += .5 * leadingMask * smoothstep(d * 20.0, d, l.x);\n    }\n\n    ray = clamp(ray, 0.0, 1.0);\n    return baseColor * (1.0 + glow * (Rythm(time * 16.0) * .05 + .025)) + vec3(ray) * intensity * leadingMask;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time = -.25 + floor(iTime * 1.1 * 24.0) / 24.0;\n    float intro = smoothstep(12.85, 13.15, time);\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    uv.y -= .075;\n    uv.x -= sin(time*4.0) * .2;\n    \n    vec2 baseDir = normalize(vec2(.57, .45));\n    \n    vec3 col = Background(uv, baseDir, time) * intro;\n    \n    float spread = .35 + (sin(time * 10.0) * .5 + .5);\n    float freq = .6 - (sin(time * 4.0) * .5 + .5) * .2;\n    \n    \n    float offset = 1.0 - (smoothstep(5.0, 7.0, time) * smoothstep( 14.0, 13.0, time));\n    \n    spread *= offset;\n    \n   \tcol = Magic(.5, col, uv + vec2(.4, .1) * offset, baseDir, time, .2, .35, 1.0 - intro * .5);\n    col = Magic(3.0, col, uv + vec2(.2, .0) * offset, baseDir, time, .05, .15, .55 + intro * .3);\n\tcol = Magic(8.0, col, uv + vec2(.2, -.25) * offset, baseDir, time, .05, .15, .35 + intro * .3);\n    col = Magic(10.0, col, uv + vec2(-.15, -.35) * offset, baseDir, time, .04, .05, .75 + intro * .3);\n    col = Magic(11.0, col, uv + vec2(-.3, -.15) * offset, baseDir, time, .04, .05, .75 + intro * .3);\n    col = Magic(12.0, col, uv, baseDir, time, spread * .75, freq, 1.0);\n\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}