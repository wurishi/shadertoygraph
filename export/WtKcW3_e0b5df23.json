{"ver":"0.1","info":{"id":"WtKcW3","date":"1611874090","viewed":47,"name":"cubesInASphere","username":"polyomino","description":"adapted from an old pixel bender in Flash","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["cubes"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// adapted from an old Pixel Bender pbk i had lying around...\nvec3 xAxisColor = vec3(1,.3,.4);\nvec3 yAxisColor = vec3(.3, .8,.4);\nvec3 zAxisColor = vec3(.1,.3,1);\nvec3 edgeColor = vec3(.1,.3,1);\n    \n float edgeThickness = 0.05;     \nfloat invert = 1.0;    \nvec2 dstsize = vec2(300.0, 300.0);\nvec3 spin = vec3(.1,.02,.3);\n\n\nfloat plunge = -0.0;\n\nfloat cellDensity = 3.0;\nfloat radius = 0.5;\n\n// evaluatePixel(): The function of the filter that actually does the \n//                  processing of the image.  This function is called once \n//                  for each pixel of the output image.\nvec4\nevaluatePixel(vec2 fragCoord)\n{\n    spin.x = iTime / 5.123;\n    spin.y = iTime / 117.2;\n    cellDensity = 8.0 + sin(iTime / 14.4) * 7.0;\n    dstsize = iResolution.xy;\n    vec3 axis1 = vec3(1.0,0.0,0.0);\n    vec3 axis2 = vec3(0.0,1.0,0.0);\n\n    mat3 elevR = mat3(1,0,0,0,cos(spin.x),sin(spin.x),0,-sin(spin.x),cos(spin.x));\n    mat3 bearR = mat3(cos(spin.y), sin(spin.y), 0,-sin(spin.y), cos(spin.y), 0, 0, 0, 1 );\n    mat3 yamR = mat3(cos(spin.z),0,sin(spin.z),0,1,0,-sin(spin.z),0,cos(spin.z));\n\n    axis1 *= elevR * bearR * yamR;\n    axis2 *= elevR * bearR * yamR;\n\n    float cellDensity2 = cellDensity / 2000.0;\n    vec2 oc = (fragCoord - dstsize / 2.0) * cellDensity2;\n\n    //oc -= outSize/2.0;\n    vec3 p = oc.x * axis1 + oc.y * axis2;\n\n\n    vec3 perp = cross(axis1,axis2);\n\n    float radiusInPixels = radius *  dstsize.x;\n    float plungeMore = radiusInPixels * radiusInPixels * cellDensity2 * cellDensity2 - oc.x * oc.x - oc.y * oc.y;\n    if(plungeMore < 0.0)\n        plungeMore = 0.0;\n    plungeMore = sqrt(plungeMore);\n\n    // Strangely, PBT and Flash have opposite senses here.\n    // Some sort of arithmetic bug, probably, making them\n    // behave differently.\n    if(invert > 0.0)\n        plungeMore = -plungeMore;\n\n    p += (plunge - plungeMore) * perp;\n\n\n    vec3 pCell = floor(p);\n\n\n    p = mod(p,1.0);\n\n    /*\n    Our cell size, here, is 1x1x1. Perp is a unit vector representing\n    the direction we're now looking, the ray cast if you will. We like\n    to cast to the planes x=0, y=0, z=0, because it's easy. So first\n    we'll see if each element of perp is negative, and, if so, flip\n    it and reposition our starting point, like p.x := 1-p.x.\n    */\n\n    /* this is the cleanest way, but Flash doesn't allow bools,\n       and ?: doesn't seem to work in this mixed-dimension way\n       either\n\n    bool3 perpNeg = lessThan(perp,vec3(0,0,0));\n    p = perpNeg ? 1.0 - p : p;\n    perp = abs(perp);\n    */\n\n    /* We can be clever with step and abs, though. */\n    vec3 perpStep = 1.0 - step(0.0,perp);\n    p = perpStep - p;\n    p = abs(p);\n    perp = abs(perp);\n\n\n    vec3 t = p / perp; // casts from p, in direction of perp, to zero. T is how far to each plane (x,y, or z)\n    vec3 co = vec3(0,0,0);\n    float z;\n\n    if(t.x >= 0.0)\n    {\n        co = xAxisColor;\n        z = t.x;\n    }\n    if(t.y >= 0.0 && t.y < t.x)\n    {\n        co = yAxisColor;\n        z = t.y;\n    }\n    if(t.z >= 0.0 && t.z < t.x && t.z < t.y)\n    {\n        co = zAxisColor;\n        z = t.z;\n    }\n\n    vec4 dst;\n    dst.rgb = co * (1.0 - z/1.2);\n    dst.a = 1.0;\n\n    if(t.x < edgeThickness || t.y < edgeThickness || t.z < edgeThickness)\n        dst.rgb = edgeColor;\n\n    if(plungeMore == 0.0)\n        dst.xyz *= 0.0;\n    return dst;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n    \n    fragColor = evaluatePixel(fragCoord);\n}\n","name":"Image","description":"","type":"image"}]}