{"ver":"0.1","info":{"id":"MXXyz7","date":"1725979121","viewed":35,"name":"spinning pulsed chroma trefoil","username":"Zaves119","description":"made via chatgpt and me","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["chroma","pulsing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define AA 2\n\nint seed = 1;\nvoid srand(int s) { seed = s; }\nint rand(void) { seed = seed * 0x343fd + 0x269ec3; return (seed >> 16) & 32767; }\nfloat frand(void) { return float(rand()) / 32767.0; }\nint hash(int n) { n = (n << 13) ^ n; return n * (n * n * 15731 + 789221) + 1376312589; }\n\nvec3 texture_3d(sampler2D sam, in vec3 q) {\n    q *= 0.5;\n    return max(max(textureLod(sam, q.xy, 1.0).xyz,\n                   textureLod(sam, q.yz, 1.0).xyz),\n               textureLod(sam, q.zx, 1.0).xyz);\n}\n\n// Geometry spinning function\nvec3 transform(in vec3 p) {\n    float an = 6.283185 * iTime / 1.0; // Faster rotation\n    p.xz *= mat2(cos(an), -sin(an), sin(an), cos(an));\n    return p.yxz;\n}\n\nconst float kBound = 2.2;\n\n// Sphere intersection function\nvec2 iSphere(in vec3 ro, in vec3 rd, in vec4 sph) {\n    vec3 ce = ro - sph.xyz;  // Center of the sphere\n    float b = dot(rd, ce);   // Dot product for sphere\n    float c = dot(ce, ce) - sph.w * sph.w; // Sphere radius\n    float h = b * b - c;     // Discriminant\n\n    if (h < 0.0) return vec2(-1.0); // No intersection if discriminant is negative\n    h = sqrt(h);\n    return vec2(-b - h, -b + h);    // Return both intersection distances\n}\n\nfloat map(in vec3 p) {\n    p = transform(p);\n    float x = p.x;\n    float y = p.y;\n    float z = p.z;\n    float w = x * x + y * y + z * z - 1.0;\n\n    float s = x * x * x - 3.0 * x * y * y + z * z - w * w;\n    float t = -y * y * y + 3.0 * x * x * y + 2.0 * z * w;\n\n    float u = s * s + t * t;\n\n    float d = pow(u, 1.0 / 8.0) - 0.75 - 0.12 * dot(p, p);\n\n    if (d < 0.02) d -= 0.01 * (texture_3d(iChannel0, p).x - 0.5);\n\n    return d;\n}\n\n// Normal calculation\nvec3 calcNormal(in vec3 pos, in float eps) {\n    vec3 n = vec3(0.0);\n    for (int i = 0; i < 4; i++) {\n        vec3 e = 0.5773 * (2.0 * vec3((((i + 3) >> 1) & 1), ((i >> 1) & 1), (i & 1)) - 1.0);\n        n += e * map(pos + e * eps);\n    }\n    return normalize(n);\n}\n\n// Raymarching function\nfloat raycast(in vec3 ro, in vec3 rd) {\n    float res = -1.0;\n    vec2 bs = iSphere(ro, rd, vec4(0.0, 0.0, 0.0, kBound)); // Bounding sphere\n\n    if (bs.y > 0.0) {\n        float t = max(bs.x, 0.0);\n        for (int i = 0; i < 512; i++) {\n            vec3 pos = ro + rd * t;\n            float d = map(pos); // Get the SDF value\n            if (abs(d) < 0.0002) {\n                res = t; // Ray hit an object\n                break;\n            }\n            t += 0.45 * d;\n            if (t > bs.y) break; // Exit if the ray goes too far\n        }\n    }\n    return res;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec3 tot = vec3(0.0); // Final accumulated color\n#if AA > 1\n    for (int m = 0; m < AA; m++)\n    for (int n = 0; n < AA; n++) {\n        vec2 o = vec2(float(m), float(n)) / float(AA) - 0.5;\n        vec2 p = (2.0 * (fragCoord + o) - iResolution.xy) / iResolution.y;\n#else\n        vec2 p = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n#endif\n        // Camera setup and ray calculation\n        vec3 ta = vec3(0.0, 0.20, 0.0); // Target point for the camera\n        vec3 ro = ta + 5.5 * vec3(sin(iTime), 0.1, cos(iTime)); // Rotating camera position\n\n        vec3 ww = normalize(ta - ro); // Forward vector\n        vec3 uu = normalize(cross(ww, vec3(0.0, 1.0, 0.0))); // Right vector\n        vec3 vv = normalize(cross(uu, ww)); // Up vector\n\n        vec3 rd = normalize(p.x * uu + p.y * vv + 3.0 * ww); // View ray\n\n        // Background color setup\n        vec3 col = vec3(1.0, 0.0, 1.0) / (1.0 + 4.0 * dot(p, p));\n\n        // Perform ray marching\n        float t = raycast(ro, rd); // Find the intersection of the ray with the geometry\n        if (t > 0.0) {\n            vec3 pos = ro + rd * t; // Calculate intersection point\n            vec3 nor = calcNormal(pos, 0.0001); // Calculate surface normal at intersection point\n            float occ = 1.0; // Ambient occlusion (simplified)\n\n            // Pulsing Chroma Colors\n            float pulse = 0.6 + 0.5 * sin(iTime * 5.0); // Create pulsing effect using sine wave\n            vec3 chromaColor = vec3(sin(iTime + pos.x), cos(iTime + pos.y), sin(iTime + pos.z)) * 0.5 + 0.5;\n            col = chromaColor * pulse; // Apply chroma color with the pulsing effect\n        }\n\n        tot += col; // Accumulate the color\n#if AA > 1\n    }\n    tot /= float(AA * AA); // Average the accumulated colors\n#endif\n\n    // Gamma correction\n    tot = pow(tot, vec3(0.4545));\n\n    // Final color output\n    fragColor = vec4(tot, 1.0); // Output the final color to the fragment\n}\n","name":"Image","description":"","type":"image"}]}