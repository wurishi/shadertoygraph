{"ver":"0.1","info":{"id":"DlXXz8","date":"1674241284","viewed":53,"name":"Assignment Adv Graphics","username":"dylandxb","description":"\"Space\" 3D Scene with ray marched sdf's. Mouse input to warp through the wormhole and observe objects.","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["mmu"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const int shuffle[256] = int[256]\n(206,21,27,124,238,156,174,113,170,81,237,12,22,241,23,141,10,167,146,114,\n 162,9,13,5,139,216,91,65,6,189,221,86,7,187,212,166,67,149,131,98,126,1,\n 137,54,8,70,110,148,46,151,106,89,121,236,101,227,49,72,255,239,3,73,244,169,\n 157,96,175,75,77,205,160,30,36,178,112,88,154,228,104,68,185,43,184,182,14,163,\n 233,18,180,45,83,186,59,25,129,111,74,215,122,218,144,44,100,161,53,254,55,92,\n 35,145,220,119,195,66,130,150,140,181,57,56,84,207,245,231,191,248,61,52,118,168,\n 226,223,40,197,116,58,232,243,214,204,33,28,105,202,24,152,133,51,196,210,115,\n 190,97,147,143,132,50,94,165,109,198,39,134,120,2,85,128,135,20,79,123,90,222,\n 26,155,82,252,136,76,217,32,240,63,38,159,247,37,176,78,234,42,219,209,0,103,\n 64,99,15,95,242,47,11,246,211,199,17,62,29,192,69,183,200,34,225,138,224,127,\n 235,229,117,253,71,108,87,201,208,171,203,41,173,102,125,213,107,179,250,80,16,\n 4,153,142,251,31,172,164,188,249,93,60,230,194,177,193,48,158,19);    \n\nconst vec3 gradients[16] = vec3[16](\nvec3(1,1,0),vec3(-1,1,0),vec3(1,-1,0),vec3(-1,-1,0),\nvec3(1,0,1),vec3(-1,0,1),vec3(1,0,-1),vec3(-1,0,-1),\nvec3(0,1,1),vec3(0,-1,1),vec3(0,1,-1),vec3(0,-1,-1),\nvec3(1,1,0),vec3(-1,1,0),vec3(0,-1,1),vec3(0,-1,-1));\n\nint Hash( in int i, in int j, in int k )\n{\n    return shuffle[(shuffle[(shuffle[i%256] + j)%256] + k)%256]%16;\n}\n\nvec3 Gradient( int i, int j, int k )\n{\n\treturn gradients[Hash(i,j,k)];\n}\n\nvec3 PositionVector( int i, int j, int k, vec3 pos )\n{\n\treturn (pos-vec3(i,j,k));\n}\n\nfloat Smoothstep( float f0, float f1, float x )\n{\n\tx = max(x, 0.0);\n\tx = min(x, 1.0);\n\tx = 3.0*x*x - 2.0*x*x*x;\n\treturn f0*(1.0f-x) + f1*x;\n}\n\n\nfloat PerlinNoise( vec3 pos, float iScale )\n{\n\tfloat noiseVals[8];\n\tpos = (pos + vec3(100,100,100))*iScale; // offset of 100 is to make sure it is in the positive quadrant\n\t// get the indices of the cube this vert is in\n\tint i = int( pos.x );\n\tint j = int( pos.y );\n\tint k = int( pos.z );\n\t// get the noise values at the vertices of the cube\n\tnoiseVals[0] = dot( Gradient(i,j,k),       PositionVector(i,j,k,pos) );\n\tnoiseVals[1] = dot( Gradient(i+1,j,k),     PositionVector(i+1,j,k,pos) );\n\tnoiseVals[2] = dot( Gradient(i+1,j,k+1),   PositionVector(i+1,j,k+1,pos) );\n\tnoiseVals[3] = dot( Gradient(i,j,k+1),     PositionVector(i,j,k+1,pos) );\n\tnoiseVals[4] = dot( Gradient(i,j+1,k),     PositionVector(i,j+1,k,pos) );\n\tnoiseVals[5] = dot( Gradient(i+1,j+1,k),   PositionVector(i+1,j+1,k,pos) );\n\tnoiseVals[6] = dot( Gradient(i+1,j+1,k+1), PositionVector(i+1,j+1,k+1,pos) );\n\tnoiseVals[7] = dot( Gradient(i,j+1,k+1),   PositionVector(i,j+1,k+1,pos) );\n\t// now do the interpolation\n\n\t// interpolation parameters tx, ty, tz\n\tvec3 t = pos - vec3(i,j,k);\n\n\tfloat ft, fb;\n\tfloat fy0, fy1;\n\t// bottom xz plane\n\tft = Smoothstep( noiseVals[3], noiseVals[2], t.x);\n\tfb = Smoothstep( noiseVals[0], noiseVals[1], t.x);\n\tfy0 = Smoothstep( fb, ft, t.z); \n\t// top xz plane\n\tft = Smoothstep( noiseVals[7], noiseVals[6], t.x);\n\tfb = Smoothstep( noiseVals[4], noiseVals[5], t.x);\n\tfy1 = Smoothstep( fb, ft, t.z); \n\t// y interpolation\n\treturn Smoothstep(fy0, fy1, t.y);\n}\n\nfloat ScaledNoise( vec3 pos, float iScale )\n{\n\treturn (1.0f + PerlinNoise( pos, iScale))*0.5f;\n}\n\nfloat FractalNoise( vec3 pos, float iScale, float mult, int numOctaves)\n{\n    float fac = 1.0f;\n    float noise = PerlinNoise(pos, iScale);\n    for ( int i = 0; i < numOctaves-1; i++ )\n    {\n    \tfac *= mult;\n        iScale *= 2.0;\n        noise += fac*PerlinNoise(pos, iScale);  //call perlinNoise to center it at 0\n    }\n    return noise;\n}\n\nmat3 rotMatrix( in vec3 about, in float angle )\n{\n    float c = cos(angle);\n    float s = sin(angle);\n    float t = 1.0-c;\n    float x = about.x; \n    float y = about.y;\n    float z = about.z;\n    \n    mat3 rotMat;\n    rotMat[0] = vec3( t*x*x+c, t*x*y - z*s, t*x*z + y*s );\n    rotMat[1] = vec3( t*x*y + z*s, t*y*y + c, t*y*z - x*s);\n    rotMat[2] = vec3( t*x*z - y*s, t*y*z + x*s, t*z*z + c);\n    return rotMat;\n}\n\n//MAKE TRANSLATE MATRIX TO MOVE OBJECT LEFT AND RIGHT WITH BOUNDS OVER TIME\n\n// Jamie Wong's constructive solid geometry operators\n//----------------------------------------------------\nfloat intersectSDF(float distA, float distB) {\n    return max(distA, distB);\n}\n\nfloat unionSDF(float distA, float distB) {\n    return min(distA, distB);\n}\n\nfloat differenceSDF(float distA, float distB) {\n    return max(distA, -distB);\n}\n//----------------------------------------------------\n\n// torus SDF from Inigo Quilez\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n// torus SDF from Inigo Quilez\nfloat noisyTorus( vec3 p, vec2 t )\n{\n  float noise = PerlinNoise(p+vec3(0,0,0.14*iTime),10.0); //float is frequency of noise\n  //float noise = FractalNoise(p+vec3(0,0,0.2*iTime),2.0,0.5, 4);\n  t.x += 0.2*noise; //adds noise value to radius of torus\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat sdOctahedron( vec3 p, float s)\n{\n  p = abs(p);\n  float m = p.x+p.y+p.z-s;\n  vec3 q;\n       if( 3.0*p.x < m ) q = p.xyz;\n  else if( 3.0*p.y < m ) q = p.yzx;\n  else if( 3.0*p.z < m ) q = p.zxy;\n  else return m*0.57735027;\n    \n  float k = clamp(0.5*(q.z-q.y+s),0.0,s); \n  return length(vec3(q.x,q.y-s+k,q.z-k)); \n}\n\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n//Create ellipsoid shape, make ellipsoid translate in x plane by itself\nfloat sdEllipsoid( vec3 p, vec3 r,vec2 center, vec2 uv )\n{\n  float radius = 0.5;\n  float k0 = length(p/r);\n  float k1 = length(p/(r*r));\n  return k0*(k0-1.0)/k1;\n  return 1.0 - smoothstep(radius-1./iResolution.y, radius+1./iResolution.y, k0);\n\n  \n}\n\nfloat sdCircle(float radius, vec2 center, vec2 uv)\n{\n    \tfloat d = distance(center, uv);\n        return 1.0 - smoothstep(radius-1./iResolution.y, radius+1./iResolution.y, d);\n\n}\n\n//Add noise\n//Capped Torus top right of screen\nfloat sdCappedTorus(in vec3 p, in vec2 sc, in float ra, in float rb)\n{\n  p.x = abs(p.x);\n  float k = (sc.y*p.x>sc.x*p.y) ? dot(p.xy,sc) : length(p.xy);\n  return sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;\n}\n\n\n//Box Frame\nfloat sdBoxFrame( vec3 p, vec3 b, float e )\n{\n       p = abs(p  )-b;\n  vec3 q = abs(p+e)-e;\n  return min(min(\n      length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n      length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n      length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n}\n//Hollow sphere\nfloat sdCutHollowSphere( vec3 p, float r, float h, float t )\n{\n  // sampling independent computations (only depend on shape)\n  float w = sqrt(r*r-h*h);\n  \n  // sampling dependant computations\n  vec2 q = vec2( length(p.xz), p.y );\n  return ((h*q.x<w*q.y) ? length(q-vec2(w,h)) : \n                          abs(length(q)-r) ) - t;\n}\n// scene - rotating torus\nfloat sceneSDF(vec3 samplePoint) \n{\n     //rotating torus\n    //vec3 torus_pos = vec3(0,0,1.5);\n   // mat3 inv_torus_rot = rotMatrix(normalize(vec3(1,0,0)),2.0);//*iTime); rotates it around axis\n    //float d0 =  noisyTorus(inv_torus_rot*(samplePoint-torus_pos),vec2(0.5,0.3));\n    //return d0;\n    vec3 translate = vec3(-2.0, 0.0, 2.0);\n    float distance = sdSphere(samplePoint - translate, 0.5);\n\tfloat materialID = 1.0;\n    \n    translate = vec3(0.0, 0.5, 1.0);\n    // A power of raymarching is tiling, we can modify the position in any way we want\n    // leaving the shape as is, creating various results\n    // So let's tile in X with a sine wave offset in Y!\n    //vec3 sphere_pos = position - translate;\n    //Do a raymarch based off the coordinate points of objects\n    float scale = 2.0; //Larger number makes it smaller\n    vec3 spherePos = vec3(-3,1.5,4);\n    spherePos *= scale * 1.2;\n    vec3 octaPos = vec3(-1,-1,2);\n    mat3 inv_octa_rot = rotMatrix(normalize(vec3(0,1,0)),2.0*iTime);\n    mat3 inv_hSph_rot = rotMatrix(normalize(vec3(1,0,1)),2.0*iTime);\n    mat3 inv_torus_rot = rotMatrix(normalize(vec3(0,1,1)),2.0*iTime);\n    mat3 inv_ellip_rot = rotMatrix(normalize(vec3(1,0,0)), 4.0*iTime);\n\n    //Scale factor\n    vec3 ellipsoidPos = vec3(-2,0,2);\n    ellipsoidPos *= scale;\n    vec3 boxPos = vec3(1.5, 0 ,2);\n    vec3 deathStarPos = vec3(1,1,2);\n    vec3 boxFramePos = vec3(0,2,3);\n    vec3 hallowSpherePos = vec3(0,-1,3);\n    vec3 torusPos = vec3(-1,1,2);\n    vec3 noisyTorusPos = vec3(0,0,2);\n \n    \n    float d0 = sdSphere(samplePoint-spherePos, 0.8);\n    float d1 = sdOctahedron(inv_octa_rot*(samplePoint - octaPos), 0.5);\n    float d2 = sdRoundBox(samplePoint - boxPos, vec3(0.4,0.5,0.2),0.1);\n    //float d3 = sdDeathStar(samplePoint - deathStarPos, 0.6, 0.4, 0.25);\n    float d4 = sdEllipsoid(inv_ellip_rot*(samplePoint - ellipsoidPos), vec3(0.4,0.2,0.2), vec2(0.5,0.5), vec2(0.2,0.2));\n //   //float d5 = sdBoxFrame(samplePoint - boxFramePos, vec3(0.5,0.5,0.5), 2.0);\n    float d5 = sdTorus(inv_torus_rot*(samplePoint - torusPos), vec2(0.2,0.2));\n    float d3 = sdCutHollowSphere(inv_hSph_rot*(samplePoint - hallowSpherePos), 0.01, 0.01,0.2);\n    float d6 = noisyTorus(samplePoint - noisyTorusPos, vec2(0.5,0.5));\n    \n    return unionSDF(unionSDF(d0,unionSDF(d1,d2)), unionSDF(unionSDF(d2,unionSDF(d3,d4)),unionSDF(d4,unionSDF(d5,d6))));\n}\n\n\n\n\n// raymarching code from Jamie Wong\n//---------------------------------------------------------------------\nconst int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float EPSILON = 0.0001;\n//args-> ray origin, ray direction, start length, end length\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end)\n{\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < EPSILON) {\n            return depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n//---------------------------------------------------------\n\nvec4 protexmarblecube(in vec3 pos)\n{\n    float A = 5.0;\n    float B = 4.0;\n    float scale = 4.0;\n    float x = 1.0 + sin(pos.y*A + FractalNoise(pos,scale,0.5,5)*B)*0.5;\n    vec4 color1 = vec4(0.5,0.5,0.5,1);\n    vec4 color2 = vec4(1,1,1,1);\n    return ((color1*x) + (color2*(1.0-x)));\n\n}\n\n//Proctex checkerboard cube function\nvec4 proctexchecker( vec3 pos )\n{\n    vec4 colour;                                   //Vec4 colour\n    float gridSize = 0.1;                              \n    int iGrid, jGrid, zGrid;\n    iGrid = int((pos.x + 10.001)/gridSize);        //Add an offset on the boundary positions to prevent fuzziness\n    jGrid = int((pos.y + 10.001)/gridSize);        //All positions are between -1 and 1 so if its -0.5 rounds to 1 and creates  a large gap\n    zGrid = int((pos.z + 10.001)/gridSize);\n    vec3 col = 0.5 + 0.5*(iTime+vec3(0,2,4));\n    if ((iGrid % 2 == 0) ^^ (jGrid % 2 == 0) ^^ (zGrid % 2 == 0))  //^^ is XOR\n         colour  = vec4(col,1);\n    else\n         colour = vec4(0,0,0,1);                   //Else change the colour to black\n    \n    return vec4(colour);\n}\n\nvoid rustychrome( in vec3 pos, out vec4 color, out float reflectance )\n{\n    \n    //FractalNoise(pos, 4.0,0.5,4.0);\n    float noise2 = 0.5*FractalNoise(pos+vec3(5,5,5),1.0,1.0,5);\n    float noise0 = 0.5*FractalNoise(pos,1.0,0.5,5);\n    if (noise0 < 0.5 ^^ noise2 < 1.0)                      //Makes different noise levels\n    {\n        reflectance = 1.0;\n    }\n    else\n    {\n        reflectance = 0.0;\n        float noise1 = FractalNoise(pos+vec3(10,10,10),1.0,0.5,3);\n        color = vec4(1.0,0.0,4.0,1)*noise2 + vec4(1,0.0,0.0,1)*noise0;\n        //Different colours on different positions on the cube, depending on reflectance level of noise0\n    }\n    \n\n}\n\n//Get distance from objects\nfloat GetDist(vec3 p)\n{\n    vec4 s = vec4(0,1,6,1);\n    float sphereDist = length(p-s.xyz)-s.w;\n    float planeDist = p.y / 6.0f;\n    float d = min(sphereDist + 2.0f, planeDist - 2.0f);\n    return d;\n\n}\n\nvec3 GetNormal(vec3 p)\n{\n    float d = GetDist(p);\n    vec2 e = vec2(0.01,0);\n    vec3 n = d - vec3(GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    return normalize(n);\n}\n\nfloat GetLight(vec3 p)\n{\n    vec3 lightPos = vec3(0,5,6);\n    lightPos.xz += vec2(sin(iTime), cos(iTime)) * 2.0; //Moves light around on xz plane\n    vec3 l = normalize(lightPos - p);\n    vec3 n = GetNormal(p);\n    \n    float dif = clamp(dot(n, l),0.0,1.0);\n    float d = shortestDistanceToSurface(p + n*MAX_DIST,l, MIN_DIST, MAX_DIST);\n    if ( d < length(lightPos-p)) dif *= 0.1;\n    return dif;\n\n}\n\nfloat distanceToSegment( vec2 a, vec2 b, vec2 p )\n{\n\tvec2 pa = p - a, ba = b - a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h );\n}\n\n//Rotate an object around\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\n\n\n// main\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    //vec2 uv = fragCoord/iResolution.xy;\n    //uv -= vec2(0.5,0.5);\n    //uv.x *= iResolution.x/iResolution.y;\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    vec3 r, n;\n    r = vec3(0,0,-1);\n    \n    float radius = 1.1;\n    float speed = 1.0;\n\n\n   \n    vec2 cen = 0.5*iResolution.xy/iResolution.x;\n    vec4 m = iMouse / iResolution.x;\n    //Warp with mouse\n    r.yz *= Rot(-m.y*3.14+1.);\n    r.xz *= Rot(-m.x*6.2831);\n    \n    vec3 col = vec3(0.0);\n    n = normalize(vec3(uv,0.0)-r);\n    vec3 ro = vec3(0,1,0);\n    vec3 rd = normalize(vec3(uv.x, uv.y, 1));\n     //float d = shortestDistanceToSurface(ro,rd,1,4);\n\n    float dist = shortestDistanceToSurface(r, n, MIN_DIST, MAX_DIST);\n    vec3 p = r + n * dist;                                              //after raymarch calculate point in 3d space, camera to ray dir by dist\n    float diff = GetLight(p);\n    col = vec3(diff);\n    if( m.z>0.0 ) // button is down\n\t{\n\t\tfloat d = distanceToSegment( m.xy, abs(m.zw), uv );\n        col = mix( col, vec3(1.0,1.0,0.0), 1.0-smoothstep(.004,0.008, d) );\n\t}\n\tif( m.w>0.0 ) // button click\n\t{\n        col = mix( col, vec3(1.0,1.0,1.0), 1.0-smoothstep(0.1,0.105, length(uv-cen)) );\n    }\n\n\tcol = mix( col, vec3(1.0,0.0,0.0), 1.0-smoothstep(0.03,0.035, length(uv-m.xy )));\n    col = mix( col, vec3(0.0,0.0,1.0), 1.0-smoothstep(0.03,0.035, length(uv-abs(m.zw))));\n    //fragColor = vec4(col,1.0);\n    dist /= 2.0;\n    //vec2 center = vec2(.0, .0);\n    vec2 center = vec2(sin(iTime * speed) / 2.0, cos(iTime * speed) / 4.0);\n    float c = sdEllipsoid(ro, rd, center, uv);\n    col = vec3(dist);\n    \n    //COMMENTING EVERYTHING BELOW HERE GOES TO BLACK SCREEN WITH SHADOWS AND MOVING LIGHT\n\n   if (dist > MAX_DIST - EPSILON) {\n      //   Didn't hit anything\n        fragColor = texture(iChannel0,n);\n        return;\n    }\n    \n    vec3 hitPoint = r + n*dist;\n    vec3 hitNorm = estimateNormal(hitPoint);\n    float lightVal = max(0.2, dot(hitNorm, normalize(vec3(1,1,-2))));\n    float reflectance = 0.05f;\n    vec4 materialColor = vec4(1,1,1,1);\n    //checks hitpoints in the scene, and call a function on all objects which meet the conditions\n    if (hitPoint.z > 3.0)\n    {\n    \n         //   sphere\n        rustychrome(hitPoint, materialColor, reflectance);\n    }\n    \n    else if (hitPoint.x < 0.0)\n    {\n    \n    //    octahedron\n        materialColor = proctexchecker(hitPoint);\n    }\n    else if (hitPoint.x <= -2.0 && hitPoint.z >= 2.0)\n    {\n    \n      //  box\n        materialColor = protexmarblecube(hitPoint);\n    \n    }\n    else {\n            materialColor = protexmarblecube(hitPoint);\n    }\n    \t//fragColor = vec4( col, 1.0 );               //Adds mouse movement\n\n    fragColor = texture(iChannel0, reflect(n,hitNorm))*reflectance + (1.0-reflectance)*materialColor*lightVal;\n \n \n\n  \n\n}","name":"Image","description":"","type":"image"}]}