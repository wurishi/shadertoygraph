{"ver":"0.1","info":{"id":"ctBfzd","date":"1694361107","viewed":37,"name":"RayMarching: Torus and Plane","username":"AlexanderPopescu","description":"uses raymarching and smoothmin to be awesome","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"precision mediump float;\n\n//constants\nconst int MAX_STEPS = 1000;\nconst float MAX_DIST = 100.0;\nconst float HIT_THRESHOLD = 0.001;\n\nfloat sdfSphere(vec3 pos, vec3 spherePos, float sphereRadius)\n{\n    //returns the distance to the closest point on the sphere\n    return length(pos - spherePos) - sphereRadius;\n}\n\nfloat sdfPlane(vec3 pos, vec3 planePos, vec3 planeNormal)\n{\n    //returns the distance to the closest point on the plane\n    return dot(pos - planePos, planeNormal);\n}\n\nfloat sdfTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat smoothMin(float a,float b,float k)\n{\n    float h = clamp( 0.5 + 0.5 * (b - a)/k, 0.0, 1.0 );\n    return mix( b, a, h) - k*h*(1.0-h);\n}\n\nfloat scene(vec3 pos)\n{\n    //returns the distance to the closest object\n\n    float distance = 1000.0;\n    float smoothness = abs(sin(iTime));\n\n    //plane\n    vec3 planePos = vec3(0.0, -1.0, 0.0);\n    vec3 planeNormal = vec3(0.0, 1.0, 0.0);\n    float planeDist = sdfPlane(pos, planePos, planeNormal);\n\n    distance = planeDist;\n\n    //torus\n    vec3 torusPos = vec3(0.0, cos(iTime) * 1.1 - 1.2, 6.0);\n    vec2 torusSize = vec2(2.0, 0.5);\n    float torusDist = sdfTorus(pos - torusPos, torusSize);\n   \n    distance = smoothMin(torusDist, distance, smoothness);\n\n    return distance;\n}\n\nvec3 getNormal(in vec3 pos)\n{\n    //returns the normal vector approximation\n    vec3 eps = vec3(0.001, 0.0, 0.0);\n    vec3 normal = vec3(\n        scene(pos + eps.xyy) - scene(pos - eps.xyy),\n        scene(pos + eps.yxy) - scene(pos - eps.yxy),\n        scene(pos + eps.yyx) - scene(pos - eps.yyx));\n    return normalize(normal);\n}\n\nfloat raymarch(in vec3 rayOrigin, in vec3 rayDirection)\n{\n    //returns the distance to the closest object from the given position\n\n    float totalDistance = 0.0;\n    for (int i = 0; i < MAX_STEPS; i++)\n    {\n        //get distance to scene\n        float dist = scene(rayOrigin + rayDirection * totalDistance);\n\n        //if we are close enough to an object, we hit it\n        if (dist < HIT_THRESHOLD)\n        {\n            return totalDistance;\n        }\n\n        totalDistance += dist;\n\n        //dont render past max distance\n        if (totalDistance >= MAX_DIST)\n        {\n            break;\n        }\n    }\n\n    return totalDistance;\n}\n\nvec3 render(in vec3 rayOrigin, in vec3 rayDirection)\n{\n    //base hit color\n    vec3 color = vec3(1.0);\n\n    //calculates the color to render at the pixel that corrosponds to this ray\n    float totalDistance = 0.0;\n    for (int i = 0; i < MAX_STEPS; i++)\n    {\n        //get distance to scene\n        float dist = scene(rayOrigin + rayDirection * totalDistance);\n\n        //if we are close enough to an object, we hit it\n        if (dist < HIT_THRESHOLD)\n        {\n            //calculate normal vector at the collision\n            vec3 collisionPoint = rayOrigin + rayDirection * totalDistance;\n            //general vector calculation\n            vec3 normalVector = getNormal(collisionPoint);\n\n            //calculate light vector\n            vec3 lightOrigin = vec3(0.0, 2.0, 0.0);\n            lightOrigin.xz += vec2(2.0 * sin(28.0), cos(28.0)) * 2.0;\n            vec3 lightVector = normalize(lightOrigin - collisionPoint);\n\n            //calculate light intensity\n            //diffuse,clamp to avoid -1\n            float lightIntensity = clamp(dot(lightVector, normalVector), 0.0, 1.0);\n\n            //calculate shadow by ray marching from plane to lightsource\n            float lightMarchDistance = raymarch(collisionPoint + normalVector * 0.15, lightVector);\n            if (lightMarchDistance < length(lightOrigin - collisionPoint))\n            {\n                lightIntensity *= 0.1;\n            }\n\n            return vec3(lightIntensity, lightIntensity, lightIntensity);\n        }\n\n        totalDistance += dist;\n\n        //dont render past max distance\n        if (totalDistance >= MAX_DIST)\n        {\n            break;\n        }\n    }\n\n    //return background color\n    return vec3(0.0, 0.0, 0.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec3 color = vec3(1.0);\n\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n\n    //camera system\n\n    //ray origin at 0,0,0\n    vec3 rayOrigin = vec3(0.0, 1.2, 0.0);\n\n    //ray direction towards an imaginary grid of the resolution, 1 away for now\n    vec3 rayDirection = vec3(uv.x, uv.y - 0.3, 1.0);\n\n    //find color to render in that direction\n    color = render(rayOrigin, rayDirection);\n\n    //set color\n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}