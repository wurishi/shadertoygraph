{"ver":"0.1","info":{"id":"dldfz4","date":"1701044132","viewed":60,"name":"Soft Alpha Depth Blending","username":"chronos","description":"Fork of my previous shader modified with a method to smoothly transition the alpha blending when the depth of splats becomes close to equal.\nProduces the same as regular sorted alpha blending when depths are not close. Does not avoid O(n^2) complexity!","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["3d","sphere","volumetric","blend","soft","smooth","splat","homogeneous","density","splatting"],"hasliked":0,"parentid":"DlcfzN","parentname":"Volumetric Spherical Splats"},"renderpass":[{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n\n    Soft Alpha Depth Blending by Chronos\n    \n    \n    Fork of my previous shader modified with a method to smoothly transition\n    the alpha blending when the depth of splats becomes close to equal.\n    \n    Produces the same as regular sorted alpha blending when depths are not close.\n    \n    This method does not avoid the O(n^2) of a basic sort, since it must loop over all\n    other spheres for each sphere to acculumate the occlusion factors.\n    The actual benefit is just the blended opacity to reduce the harsh popping when spheres\n    change depth order.\n    \n    Note that it also does not actually produce the same result as what you would expect\n    when volumetric spheres overlap and the ray traverses more than one sphere density for\n    some interval. For that one would have to do (slightly) more involved calculations.\n    \n    Softness of the blending can be adjusted with the paramter\n    \n        'transition_steepness'\n    \n    The blending transition leaves quite a bit to be desired, so I would recommend to keep it quite steep,\n    e.g transition_steepness = 3. Here I set it a bit lower to make the effect more visible.\n    Again, it is mostly designed to reduce harsh popping, not give correct volumetric integrals!\n    \n    A benefit of how I computed it here is that a lot of it could in principle be computed in the vertex shader,\n    avoiding expensive per-fragment operations, which could make it suitable for splat rasterization.\n    One would still have to find avoid a way to mitigate the O(n^2) complexity of the blend factor calculation, however.\n    \n    Left side: Strict ordering that 'pops' when switching order.\n    \n    Right side: Relaxed ordering that softly transitions when switching order.\n    \n    -----------------------------------------------------------------------------\n    Forked shader description:\n    \n    Demonstrates a way to splat volumetric spheres of homogeneous density\n    by cheaply computing the analytical length of the ray segment intersecting\n    the sphere without calculating the hit positions (directly at least).\n    \n    The spheres are sorted using a simple bubble sort \n    of the sphere position projected onto the line\n    from the origin to the camera position.\n    This is why the spheres pop in front and behind when the spheres\n    change position. They are essentially splatted to 2D ellipses.\n    \n    The volumetric transmission should be correct whenever\n    the spheres do not overlap, however.\n    \n    The method for computing the length of the intersecting ray segment\n    is demonstrated here:\n\n    https://www.shadertoy.com/view/mlcfRr\n\n*/\n\nconst float PI = 3.14159265;\n\nconst float transition_steepness = 2.;\n\nfloat sRGBencode(float C_linear)\n{\n    return C_linear > 0.0031308 ? (1.055 * pow(C_linear, 1./2.4) - 0.055) : (12.92 * C_linear);\n}\n\nvec3 sRGBencode(vec3 C_linear)\n{\n    C_linear = clamp(C_linear, 0., 1.);\n    return vec3(sRGBencode(C_linear.x), sRGBencode(C_linear.y), sRGBencode(C_linear.z));\n}\n\nfloat sRGBdecode(float C_sRGB)\n{\n    return C_sRGB > 0.04045 ? (pow((C_sRGB + 0.055)/1.055, 2.4) ) : (C_sRGB / 12.92);\n}\n\nvec3 sRGBdecode(vec3 C_sRGB)\n{\n    return vec3(sRGBdecode(C_sRGB.x), sRGBdecode(C_sRGB.y), sRGBdecode(C_sRGB.z));\n}\n\nfloat lengthSquared(vec3 v) { return dot(v,v); }\n\nfloat sphere_depth(vec3 pos, float radius, vec3 ro, vec3 rd)\n{\n    float d2 = lengthSquared(cross(pos-ro, rd));\n    float x2 = radius*radius - d2;\n    if(x2 < 0.) return 0.; \n    float depth = 2. * sqrt(x2);\n    return depth;\n}\n\nstruct Sphere\n{\n    vec3 pos;\n    vec3 color;\n    float density;\n    float radius;\n};\n\nfloat kron_delta(int i, int j)\n{\n    return float(i == j);\n}\n\n/*\n// Smooth alternative to kron_delta\n// should be almost a drop in replacement, just replace index with corresponding depths\n// but I haven't tested this.\n// Also has the advantage of being differentiable :)\nfloat depth_blend_delta(float depth_i, float depth_j)\n{\n    float x = (depth_i - depth_j) * transition_steepness;\n    return exp(-2. * x * x);\n}\n*/\n\n// Some more unused ways of getting the blending factors \n/*\n// returns   alpha  when i == j\n// returns 1-alpha  when i != j\nfloat get_alpha(int i, int j, float alpha)\n{\n    float d = kron_delta(i, j);\n    return (1.-d) + (2.*d - 1.) * alpha;\n}\n\n// returns   alpha  when i == j\n// returns       1  when i != j\nfloat get_alpha2(int i, int j, float alpha)\n{\n    float d = kron_delta(i, j);\n    //return (1.-d) + d * alpha;\n    //return 1. + (alpha - 1.) * d;\n    return mix(1., alpha, d);\n}\n*/\n\n// I used tanh here, but you can use any sigmoid function that\n// smoothly goes from 0 to 1 as x goes from negative to positive.\n// x = -inf should return 0\n// x = +inf should return 1\n// x = 0    should return 0.5\nfloat sigmoid(float x)\n{\n    return .5 + .5*tanh(transition_steepness * x);\n}\n\n// returns 1 if 'self' is further away, i.e behind 'other'\n// 0.5 if equal depth\n// 0 otherwise\nfloat depth_compare(float self_depth, float other_depth)\n{\n    return sigmoid(self_depth - other_depth);\n}\n\n// Same as mix((1.-other_alpha, 1, sigmoid(self_depth - other_depth))\n// to smoothly transition from occluded to unoccluded\nfloat depth_blend(float self_depth, float other_depth, float other_alpha)\n{\n    float s = depth_compare(self_depth, other_depth);\n    return 1.-s * other_alpha;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.*fragCoord-iResolution.xy) / iResolution.y;\n    vec2 mouse = (2.*iMouse.xy - iResolution.xy) / iResolution.y;\n    \n    if(length(iMouse) < 10.)\n        mouse.xy = vec2(0);\n\n    float time = .75 * iTime;\n\n    float c = cos(time);\n    float s = sin(time);\n    vec3 ro = 15. * vec3(c, 0., s) + vec3(0,0,0);\n    float focal = 2.;\n    vec3 rd = normalize(vec3(uv, -focal));\n    rd.xz = mat2(s, -c, c, s) * rd.xz;\n    \n    vec3 color = 1.*sRGBdecode(texture(iChannel0, rd).rgb);\n    \n    vec3 green = vec3(0.05,.675,.3);\n    vec3 pink = vec3(.675, 0.05, .3);\n    vec3 purple = vec3(.3, 0.05, .675);\n    vec3 blue = vec3(0.05, .3, .675);\n    vec3 yellow = vec3(0.95, .7, .325);\n    \n    Sphere[5] spheres;\n    \n    spheres[0].pos = vec3(0,sin(iTime)*.5,0);\n    spheres[0].radius = 4.0;\n    spheres[0].density = 0.5;\n    spheres[0].color = pink;\n    \n    spheres[1].pos = 2.*vec3(cos(iTime)*5.75,0,1);\n    spheres[1].radius = 2.0;\n    spheres[1].density = 0.75;\n    spheres[1].color = yellow;\n\n    spheres[2].pos = vec3(cos(iTime)*5.75,sin(iTime*.5)*4.,2);\n    spheres[2].radius = 3.;\n    spheres[2].density = 0.25;\n    spheres[2].color = blue;\n    \n    spheres[3].pos = vec3(cos(iTime*2.)*5.75,sin(iTime*2.5)*4.,3);\n    spheres[3].radius = 1.5;\n    spheres[3].density = 0.7;\n    spheres[3].color = green;\n    \n    spheres[4].pos = vec3(sin(iTime*1.5)*5.75, .7*sin(iTime*1.5*PI)*4.,4);\n    spheres[4].radius = 1.;\n    spheres[4].density = 0.9;\n    spheres[4].color = purple;\n    \n    float pix_size = 2. / iResolution.y;\n    \n    if(uv.x > mouse.x)\n    {\n        float alphas[5];     // alpha caching\n        float occlusions[5];  // occlusion accumulation buffer\n        float depths[5];    // depth caching\n\n        for(int i = 0; i < 5; i++)\n        {\n            float depth = sphere_depth(spheres[i].pos, spheres[i].radius, ro, rd);\n            float transmission = exp(-spheres[i].density*depth);\n\n            float alpha = 1.-transmission;\n\n            alphas[i] = alpha;\n            occlusions[i] = alpha;\n\n            color *= transmission;\n        }\n\n        // Sphere center projected onto line from origin to camera\n        for (int i = 0; i < 5; i++)\n            depths[i] = -dot(spheres[i].pos, normalize(ro));\n\n        for(int i = 0; i < 5; i++) // i : self\n        for(int j = 0; j < 5; j++) // j : other\n        {\n            float other_alpha = alphas[j];\n            float self_depth  = depths[i];\n            float other_depth = depths[j];\n            float occlusion   = depth_blend(self_depth, other_depth, other_alpha);\n            \n            occlusion = mix(occlusion, 1., kron_delta(i,j)); // set occlusion=1 when i == j\n            \n            occlusions[i] *= occlusion;\n        }\n\n        for(int i = 0; i < 5; i++)\n        {\n            color += spheres[i].color * occlusions[i];\n        }\n    }\n    else\n    {\n        float depths[5];    // depth caching\n        for (int i = 0; i < 5; i++)\n            depths[i] = dot(spheres[i].pos, normalize(ro));\n        // Bubble sort :)\n        int order[5] = int[5](0,1,2,3,4);\n        for (int i = 0; i < 4; i++)\n        for (int j = 4; j > i; j--)\n        {\n            int a = j-1, b = j;\n\n            // Swap if lowest element is nearer camera, so we draw back to front\n            // (i.e higher value z from origin, kinda reversed z from camera )\n            if(depths[order[a]] > depths[order[b]])\n            {\n                order[a] ^= order[b];\n                order[b] ^= order[a];\n                order[a] ^= order[b];\n            }\n        }\n        \n        // Draw splats\n        for(int i = 0; i < 5; i++)\n        {\n            int j = order[i];\n            float depth = sphere_depth(spheres[j].pos, spheres[j].radius, ro, rd);\n            float transmission = exp(-spheres[j].density*depth);\n            color = mix(spheres[j].color, color, transmission);\n        }\n    }\n    \n    color *= smoothstep(pix_size, 2.*pix_size, abs(uv.x-mouse.x));\n    \n    // Optional tonemapping\n    #if 0\n    color = tanh(color);\n    #endif\n    \n    color = sRGBencode(color);\n\n    fragColor = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"}]}