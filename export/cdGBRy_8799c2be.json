{"ver":"0.1","info":{"id":"cdGBRy","date":"1698314253","viewed":17,"name":"digdig face","username":"zertalious","description":"digdig.io face","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["face"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float det(vec2 a, vec2 b) { return a.x*b.y-b.x*a.y; }\n\nvec2 closestPointInSegment( vec2 a, vec2 b )\n{\n  vec2 ba = b - a;\n  return a + ba*clamp( -dot(a,ba)/dot(ba,ba), 0.0, 1.0 );\n}\n\n// From: http://research.microsoft.com/en-us/um/people/hoppe/ravg.pdf\nvec2 get_distance_vector(vec2 b0, vec2 b1, vec2 b2) {\n\t\n  float a=det(b0,b2), b=2.0*det(b1,b0), d=2.0*det(b2,b1); // ð›¼,ð›½,ð›¿(ð‘)\n  \n  if( abs(2.0*a+b+d) < 100.0 ) return closestPointInSegment(b0,b2);\n\t\n  float f=b*d-a*a; // ð‘“(ð‘)\n  vec2 d21=b2-b1, d10=b1-b0, d20=b2-b0;\n  vec2 gf=2.0*(b*d21+d*d10+a*d20);\n  gf=vec2(gf.y,-gf.x); // âˆ‡ð‘“(ð‘)\n  vec2 pp=-f*gf/dot(gf,gf); // ð‘â€²\n  vec2 d0p=b0-pp; // ð‘â€² to origin\n  float ap=det(d0p,d20), bp=2.0*det(d10,d0p); // ð›¼,ð›½(ð‘â€²)\n  // (note that 2*ap+bp+dp=2*a+b+d=4*area(b0,b1,b2))\n  float t=clamp((ap+bp)/(2.0*a+b+d), 0.0 ,1.0); // ð‘¡Ì…\n  return mix(mix(b0,b1,t),mix(b1,b2,t),t); // ð‘£ð‘–= ð‘(ð‘¡Ì…)\n\n}\n\nfloat approx_distance(vec2 p, vec2 b0, vec2 b1, vec2 b2) {\n  return length(get_distance_vector(b0-p, b1-p, b2-p));\n}\n\nfloat quadCurve(vec2 p,vec2 a,vec2 b,vec2 c,float s){\n\tvec2 mid=(a+c)*0.5+vec2(0.0,0.01);\n\tfloat d=approx_distance(p,a,b,c);\n\tfloat color;\n\tif(d<s){\n        color=1.0;\n\t} else {\n        color=1.0-smoothstep(d,s,s+0.3);\n\t}\n    return color;\n}\n//////////////////////////////\n\nfloat eyeWidth=27.0;\nfloat eyeHeight=50.0;\nfloat eyeStrokeSize=5.5;\nvec3 eyeColor=vec3(0.9);\nvec3 strokeColor=vec3(0.15);\nfloat pupilSize=30.0;\nvec3 pupilColor=vec3(0.1);\n\nvec4 eye(vec2 p,vec2 eyeDir,float x,float y){\n    float w=eyeWidth/2.0;\n    float h=eyeHeight/2.0;\n    if(p.x>x-w&&p.y>y-h&&p.x<x+w&&p.y<y+h){\n        float px=x+eyeDir.x*w;\n        float py=y+eyeDir.y*h;\n        float ps=pupilSize/2.0;\n        if(p.x>px-ps&&p.y>py-ps&&p.x<px+ps&&p.y<py+ps){\n            return vec4(pupilColor,1.0);\n        }\n        return vec4(eyeColor,1.0);\n    }\n    vec2 delta=min(max(p,vec2(x-w,y-h)),vec2(x+w,y+h))-p;\n    float d=length(delta);\n    float stroke;\n    if(d<=eyeStrokeSize){\n        stroke=1.0;\n    }else{\n        stroke=1.0-smoothstep(d,eyeStrokeSize,eyeStrokeSize+0.3);\n    }\n    return vec4(stroke*strokeColor,stroke);\n}\n\nvec2 toWorld(vec2 pos){\n    vec2 p=pos-iResolution.xy/2.0;\n    p*=250.0/min(iResolution.x,iResolution.y);\n    p.y+=5.0;\n    return p;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p=toWorld(fragCoord);\n    vec2 eyeDir=toWorld(iMouse.xy);\n    eyeDir/=length(eyeDir);\n    \n    vec4 col;\n    col+=eye(p,eyeDir,-35.0,30.0);\n    col+=eye(p,eyeDir,35.0,30.0);\n    \n    float lip=quadCurve(\n        p,\n        vec2(-35.0,-35.0),\n        vec2(0.0,-35.0+(iMouse.z<1.0?-35.0:20.0)),\n        vec2(35.0,-35.0),\n        3.5\n    );\n    col+=vec4(strokeColor*lip,lip);\n    fragColor=col;\n}","name":"Image","description":"","type":"image"}]}