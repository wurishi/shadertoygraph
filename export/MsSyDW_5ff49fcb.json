{"ver":"0.1","info":{"id":"MsSyDW","date":"1492077541","viewed":270,"name":"soft shadow,AmbientOcclution.","username":"sw","description":"referenceã€€by https://wgld.org/d/glsl/","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["simple","tutorial","easy"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float sdBox( vec3 p, vec3 b )\n{\n  return length(max(abs(p)-b,0.0));\n}\nfloat sdFloor(vec3 p){\n    return dot(p, vec3(0.0, 1.0, 0.0)) + 1.0;\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat sdAll(vec3 p,out int ColorNumber)\n{\n    vec3 boxPos=vec3(2,0,4);\n    vec3 spherePos=vec3(-2,1,3);\n    float d1 = sdBox(p+boxPos,vec3(1,1,1));\n    float d2 = sdFloor(p);\n    float d3 = sdSphere(p+spherePos,1.0);\n    ColorNumber = d1<d2 ? 0 : d2<d3 ? 1 : 2;\n    return min(min(d1,d2),d3);\n}\n\nfloat sdAll(vec3 p)\n{\n\tint ColorNumber;\n\treturn sdAll(p,ColorNumber);\n}\nvec3 getNormal(vec3 p){\n    float d = 0.0001;\n    return normalize(vec3(\n        sdAll(p + vec3(  d, 0.0, 0.0)) - sdAll(p + vec3( -d, 0.0, 0.0)),\n        sdAll(p + vec3(0.0,   d, 0.0)) - sdAll(p + vec3(0.0,  -d, 0.0)),\n        sdAll(p + vec3(0.0, 0.0,   d)) - sdAll(p + vec3(0.0, 0.0,  -d))\n    ));\n}\n\nfloat getShadow(vec3 RayPos, vec3 RayDir){\n    float h = 0.0;\n    float c = 0.001;\n    float r = 1.0;\n    float shadowCoef = 0.5;\n    for(float t = 0.0; t < 50.0; t++){\n        h = sdAll(RayPos + RayDir * c);\n        if(h < 0.001){\n            return shadowCoef;\n        }\n        r = min(r, h * 5.0 / c);\n        c += h;\n    }\n    return 1.0 - shadowCoef + r * shadowCoef;\n}\n\nfloat getAO(vec3 p,vec3 normal)\n{\n\tfloat ao=0.0;\n\tconst float len=0.2;\n\tao += sdAll(p+vec3(-len,len,-len)*normal);\n\tao += sdAll(p+vec3(-len,len,+len)*normal);\n\tao += sdAll(p+vec3(+len,len,-len)*normal);\n\tao += sdAll(p+vec3(+len,len,+len)*normal);\n    ao = 0.5+(ao/4.0);\n\treturn clamp(ao,0.5,1.0);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // fragment position\n    vec2 p = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n    \n    // light\n    vec2 mouse=iMouse.xy/iResolution.xy;\n\tvec3 lightDir = normalize(vec3(mouse.x, mouse.y, 0.577));\n    \n    // camera\n    vec3 cPos = vec3(0.0, 0.0,  0.0);\n    vec3 cDir = vec3(0.0,  0.0, -1.0);\n    vec3 cUp  = vec3(0.0,  1.0,  0.0);\n    vec3 cSide = cross(cDir, cUp);\n    float targetDepth = 1.0; \n    \n    // ray\n    vec3 ray = normalize(cSide * p.x + cUp * p.y + cDir * targetDepth);\n    \n    // marching loop\n    float distance = 0.0;\n    float rLen = 0.0;     \n    vec3  rPos = cPos; \n    \n    int ColorNumber=0;\n        \n    for(int i = 0; i < 256; i++){\n        distance = sdAll(rPos,ColorNumber);\n        rLen += distance;\n        rPos = cPos + ray * rLen;\n    }\n    \n    // hit check\n    if(abs(distance) < 0.001){\n        // color\n        vec3 SurfaceColors[3];\n        SurfaceColors[0] = vec3(0.3,0.3,0.9);\n        SurfaceColors[1] = vec3(1.0,1.0,1.0);\n        SurfaceColors[2] = vec3(0.9,0.3,0.3);\n        \n        // Light Direction\n        float offsetX=sin(iTime);\n\t\tvec3 lightDir = vec3( 0, 0.57, 0.57);\n        lightDir.x=offsetX;\n        lightDir=normalize(lightDir);\n\n        vec3 normal=getNormal(rPos);\n\n        float shadow=getShadow(rPos+normal*0.001,lightDir);\n\t\tfloat ao=getAO(rPos+normal*0.001,normal);\n        float lighing=dot( lightDir,normal );\n        \n        // no lighting\n        if( ColorNumber==1)\n        {\n            lighing = 1.0;\n        }\n        fragColor.xyz = SurfaceColors[ColorNumber] * lighing*shadow*ao;\n\n    }\n\n}","name":"Image","description":"","type":"image"}]}