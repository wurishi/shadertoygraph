{"ver":"0.1","info":{"id":"dlGyD3","date":"1700730963","viewed":49,"name":"Support Func Path Tracing","username":"kastorp","description":"support function pathtracing (using Reinder's rendering)\npresss space to toggle intersection with sphere (or a=sub, b=union)\n","likes":3,"published":1,"flags":48,"usePreview":0,"tags":["raytracing","csg","supportfunction"],"hasliked":0,"parentid":"flccWs","parentname":"Simple CSG 2"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Support Func Path Tracing\n// ------------------------\n// Based on Ray Tracing - Primitives.  by Reinder Nijhoff \n// https://www.shadertoy.com/view/tl23Rm\n//\nvoid mainImage(out vec4 fragColor, vec2 fc)\n{\t\n\n\n    vec4 data = texelFetch(iChannel0, ivec2(fc), 0);\n    vec3 col = data.rgb / data.w;\n    \n    // gamma correction\n    col = max( vec3(0), col - 0.004);\n    col = (col*(6.2*col + .5)) / (col*(6.2*col+1.7) + 0.06);\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"\n#define NOHIT 1e10\n\nstruct its\n{\n\tfloat t;\n\tvec3 n;    //normal \n\t\n};\n\nconst its  NO_its=its(NOHIT,vec3(0));\nstruct span\n{\n\tits n;\n\tits f;\n};\n\n\n\n\n//-----------Intersection functions--(based on Iq)------------------\nspan iSphere( in vec3 ro, in vec3 rd, float ra )\n{\n    vec3 oc = ro ;\n    float b = dot( oc, rd );\n    float c = dot( oc, oc ) - ra*ra;\n    float h = b*b - c;\n    if( h<0. ) return span(NO_its,NO_its); // no intersection\n    h = sqrt( h );\n    vec3 oNor =normalize(ro-(b+h)*rd); \n    vec3 fNor= normalize(ro-(b-h)*rd); \n    return span(its(-b-h,oNor) , its(-b+h,-fNor));\n}\n\nspan iBox( in vec3 ro, in vec3 rd, vec3 boxSize) \n{\n    vec3 m = 1./rd; \n    vec3 n = m*ro;   \n    vec3 k = abs(m)*boxSize;\n\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n    if( tN>tF ) return span(NO_its,NO_its); // no intersection\n    vec3 oNor = -sign(rd)*step(t1.yzx,t1.xyz)*step(t1.zxy,t1.xyz); \n    vec3  fNor=- sign(rd)*step(t2.xyz,t2.yzx)*step(t2.xyz,t2.zxy); \n    return  span(its(tN,oNor) , its(tF,fNor));\n}\n\n\n\n\n//  plane with thickness h\nspan iPlane( in vec3 ro, in vec3 rd, in vec3 n ,float h)\n{\n    float d1= -dot(ro,n)/dot(rd,n),   d2= -(dot(ro-h*n,n))/dot(rd,n);\n    vec3  u = normalize(cross(n,vec3(0,0,1))), v = normalize(cross(u,n) );\n    vec3 oNor=n;\n    if(d1<d2) return span(its(d1,-oNor),its(d2,oNor));\n    return span(its(d2,oNor),its(d1,-oNor));\n}\n\n\n//---------mixed functions--------------------------\n\nstruct Hit{   \n    float d;\n    vec3 n;\n    int id;\n};\n\n\nHit nearestHit( Hit a, Hit b)\n{   \n   if(a.d<b.d) return a;\n   else return b;\n}\n\n\n\n//------------------------------------\nHit getHit(span s, int mat){\n    \n    if(s.f.t < 0.  ) return Hit(NOHIT,vec3(0),0);    \n    its ix = s.n;\n    if(s.n.t<0.) ix=s.f;\n    return Hit( ix.t,ix.n,mat);\n}\n\n// Iq \n\n\nmat3 rotationAxisAngle( vec3 v, float angle )\n{\n    float s = sin( angle );\n    float c = cos( angle );\n    float ic = 1.0 - c;\n\n    return mat3( v.x*v.x*ic + c,     v.y*v.x*ic - s*v.z, v.z*v.x*ic + s*v.y,\n                 v.x*v.y*ic + s*v.z, v.y*v.y*ic + c,     v.z*v.y*ic - s*v.x,\n                 v.x*v.z*ic - s*v.y, v.y*v.z*ic + s*v.x, v.z*v.z*ic + c);\n}\n\n//-----------\n\n\n\n\nvec3 supMax(vec3 d, vec3 a, vec3 b)\n{\n    return dot(d,a) > dot(d,b) ? a : b;\n}\n\nvec3 supNgon(vec3 d, float n,float v, float h)\n{\n    \n    float a = atan(d.y, d.x);\n    float f = 6.2830 / n;\n    a = (floor(a/f)+.5)*f;\n    return vec3(vec2(cos(a), sin(a))*h, v);\n}\n\nstruct obj{\n    vec3 c;\n    vec3 b; //bounding box\n    int s; //shape (0=box,1=sphere,2=cylinder,3=cone, 4=segment)\n    mat3 rm;\n};\n\nstruct obj2{\n    vec3 p;\n    vec3 b; //bounding box\n    int s; //shape (0=box,1=sphere,2=cylinder,3=cone, 4=segment)\n    float m;\n};\n\nvec3 support(vec3 dir, obj o){\n    const float h=(sqrt(5.)-1.)*.5,h2=h*h;\n    vec3 s= vec3(0);\n    dir=dir*o.rm;\n    switch (o.s) {\n        default:\n        case 0:\n             s= sign(dir)*o.b; //BOX (default)\n             break;\n        case 1: //ELLIPSOID\n             s= normalize(dir*o.b)*(o.b); \n             break;\n        case 2: // CYLINDER\n             s=  supMax( dir,        \n                vec3(normalize(dir.xy)*o.b.x, o.b.y), \n                vec3(normalize(dir.xy)*o.b.x, -o.b.y) \n            );\n            break;\n        case 3: // CONE\n            s=  supMax( dir,        \n                vec3(normalize(dir.xy)*o.b.x, o.b.z) ,\n                vec3(0,0, -o.b.z)\n            );\n            break;\n        case 4: //SEGMENT\n              s=  supMax( dir,o.b ,-o.b) + normalize(dir)*.1; \n              break;\n        case 5: //TETRAHEDRON\n              s=  supMax(dir,\n                          supMax( dir,vec3(o.b),vec3(o.b.x,-o.b.yz)),\n                          supMax( dir,vec3(-o.b.x,o.b.y,-o.b.z),vec3(-o.b.xy,o.b.z))\n                      );\n              break;\n        case 6: //DODECAHEDRON\n               //h=1. romboid dodecahedron                      \n              s=  o.b/(1.+h)* supMax(dir,\n                         supMax(dir, sign(dir)*(1.),sign(dir)*vec3(1.+ h,1.-h2,0)),\n                         supMax(dir, sign(dir)*vec3(0,1. +h,1.-h2),sign(dir)*vec3(1.-h2,0,1.+ h))\n                      );\n             break;\n        case 7: //ICOSAHEDRON\n                //h=0.  Tetradecahedron\n              s=  o.b/(1.+h)* supMax(dir,\n                         sign(dir)*vec3(1.,1.+h,0),\n                         supMax(dir, sign(dir)*vec3(0,1.,1.+h),sign(dir)*vec3(1.+h,0,1.))\n                      );\n              break;\n\n        case 8: //LOWPOLY SPHERE\n             float a = atan(dir.z, length(dir.xy));\n             float f = 6.2830 / 16.;\n             a = (floor(a/f)+.5)*f;\n             s=  supNgon(dir,16.,sin(a)*o.b.z,cos(a)*o.b.x);                \n             break;\n    }   \n    return s *transpose(o.rm)+ o.c ;\n} \n\n\n\n\n#define TOLERANCE 1e-5\n#define ITERATIONS 20\n#define VAXIS vec3(0,1,0)\n// adapted from:  https://www.shadertoy.com/view/wstyRB\n//  Casts ray in rd direction from ro, estimates depth and normal \nspan iSupportFunction( vec3 ro, vec3 rd, obj2 o2)\n{   \n\n    span noHit = span(NO_its,NO_its);\n    \n    vec3 dir, tmp;   \n    vec3 a,b,c,d;\n       \n    //RX=horizontal axis, RY=vertical axis    \n    vec3 rx =normalize(cross(rd,VAXIS)),ry=cross(rx,rd);\n    mat3 rmai=mat3(rx,ry,rd), rma=transpose(rmai); \n    //switch to local coordinates\n    float d0=- dot(ro,rd);  \n    ro*=rmai;\n    rd=vec3(0,0,1);\n    \n    obj o;  \n    o.b=o2.b;\n    o.s=o2.s;\n    o.rm= rma ;  \n    o.c =  cross(cross(rd,ro),rd); \n    \n    #define perp2d(v)  ((v).yx*vec2(-1,1))  //(cross(v,vec3(0,0,-1)).xy) \n    a=o.c;\n    \n    b=support(vec3(-a.xy, 0.),o);\n    if (dot(-a.xy, b.xy) <= 0.) return noHit;\n    \n    dir = vec3(perp2d(b-a),0.);\n    if (dot(dir.xy, a.xy) >= 0.)\n    {\n        dir.xy *= -1.;\n        tmp = a; a = b; b = tmp;\n    }\n    c=support(dir,o);\n    if (dot(c.xy, dir.xy) <= 0.)\n        return noHit;\n    \n    for (int i = 0;; ++i)\n    {\n        \n        if (i == 6) return noHit;\n        if (dot(dir.xy = perp2d(c-a), c.xy) < 0.)\n            {b = c;}\n        else if (dot(dir.xy = perp2d(b-c), c.xy) < 0.)\n             {a = c;}\n        else break; // Origin in triangle -> intersection!\n        \n        c=support(dir,o);    \n        if (dot(c.xy, dir.xy) <= 0.)\n            return noHit;\n    }\n  \n    its iN,iF;\n    for(int j= 0;j<=1;j++){\n        for (int i = 0; i < ITERATIONS; ++i)\n        {\n\n            dir = normalize(cross(b-a, c-a));\n            if(j>0) dir*=-1.; // uncomment to get exit point\n            d=support(dir,o);\n\n            if (abs(dot(dir, d) - dot(dir, a)) < TOLERANCE)break;\n\n            // xd = origin left of xd line\n            bool ad = dot(perp2d(d-a),d.xy) > 0.;\n            bool bd = dot(perp2d(d-b), d.xy) > 0.;\n            bool cd = dot(perp2d(d-c), d.xy) > 0.;\n\n            // Choose triangle that intersects z-axis furthest in z direction\n            if (ad && !bd) {c = d;}\n            else if (bd && !cd) {a = d;}\n            else if (cd && !ad) {b = d;}\n            else break; // Should not happen\n\n        }\n\n        vec3 normal = normalize(cross(b-a, c-a));\n        float depth = a.z + dot(a.xy, normal.xy)/normal.z ;\n        normal*=rma;\n\n        its it= its( - depth +d0,normal); //todo uv\n        if(j==0) iN=it; else iF=it;\n    }\n    \n\n\n    return  span(iN , iF ); \n}\n\n\n\n span Inter(span a, span b)\n {\n    bvec4 cp = bvec4(a.n.t<b.n.t,a.n.t<b.f.t,a.f.t<b.n.t,a.f.t<b.f.t); \n    if(cp.x && cp.z) return span(NO_its,NO_its);\n    else if(cp.x && !cp.z && cp.w)  return span(b.n,a.f);\n    else if(cp.x && !cp.z && !cp.w) return b;\n    else if(!cp.x && cp.y &&  cp.w) return a;\n    else if(!cp.x && cp.y &&  !cp.w) return span(a.n,b.f);\n    else return span(NO_its,NO_its);\n }\n \n span Sub(span a, span b)\n {\n    bvec4 cp = bvec4(a.n.t<b.n.t,a.n.t<b.f.t,a.f.t<b.n.t,a.f.t<b.f.t); \n    \n    if     (cp.x && cp.z) return a;\n    else if(cp.x && !cp.z && cp.w)  return span(a.n,b.n);\n    else if(cp.x && !cp.z && !cp.w && b.n.t>0.) return span(a.n,b.n); \n    else if(cp.x && !cp.z && !cp.w && b.n.t<0.) return span(b.f,a.f); //+ secondary span =  span(b.f,a.f)\n    else if(!cp.x && cp.y && cp.w) return span(NO_its,NO_its);\n    else if(!cp.x && cp.y && !cp.w) return span(b.f,a.f);\n    else return a;\n    \n }\n \n // useful if transparent \n span Union(span a, span b)\n {\n \n    bvec4 cp = bvec4(a.n.t<b.n.t,a.n.t<b.f.t,a.f.t<b.n.t,a.f.t<b.f.t); \n    if(b.n.t==NOHIT) return a;\n    else if(a.n.t==NOHIT) return b;    \n    else if     (cp.x  && cp.z  && a.f.t>0.) return a;\n    else if(cp.x  && cp.z  && a.f.t<0.) return b;\n    else if(cp.x  && !cp.z && cp.w) return span(a.n,b.f);\n    else if(cp.x  && !cp.z && !cp.w) return a;\n    else if(!cp.x && cp.y  && cp.w) return b;\n    else if(!cp.x && cp.y  && !cp.w) return span(b.n,a.f);\n    else if(!cp.x && !cp.y  && a.f.t>0.) return b;\n    else /*if(!cp.x && !cp.y  && a.f.t<0.) */ return a;   \n }\n ","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\n\n\n#define PATH_LENGTH 10\n#define MAX_DIST 1e10\n//\n// Hash functions by Nimitz:\n// https://www.shadertoy.com/view/Xt3cDn\n//\n\nuint baseHash( uvec2 p ) {\n    p = 1103515245U*((p >> 1U)^(p.yx));\n    uint h32 = 1103515245U*((p.x)^(p.y>>3U));\n    return h32^(h32 >> 16);\n}\n\nfloat hash1( inout float seed ) {\n    uint n = baseHash(floatBitsToUint(vec2(seed+=.1,seed+=.1)));\n    return float(n)/float(0xffffffffU);\n}\n\nvec2 hash2( inout float seed ) {\n    uint n = baseHash(floatBitsToUint(vec2(seed+=.1,seed+=.1)));\n    uvec2 rz = uvec2(n, n*48271U);\n    return vec2(rz.xy & uvec2(0x7fffffffU))/float(0x7fffffff);\n}\n\n//\n// Ray tracer helper functions\n//\n\nfloat FresnelSchlickRoughness( float cosTheta, float F0, float roughness ) {\n    return F0 + (max((1. - roughness), F0) - F0) * pow(abs(1. - cosTheta), 5.0);\n}\n\nvec3 cosWeightedRandomHemisphereDirection( const vec3 n, inout float seed ) {\n  \tvec2 r = hash2(seed);\n\tvec3  uu = normalize(cross(n, abs(n.y) > .5 ? vec3(1.,0.,0.) : vec3(0.,1.,0.)));\n\tvec3  vv = cross(uu, n);\n\tfloat ra = sqrt(r.y);\n\tfloat rx = ra*cos(6.28318530718*r.x); \n\tfloat ry = ra*sin(6.28318530718*r.x);\n\tfloat rz = sqrt(1.-r.y);\n\tvec3  rr = vec3(rx*uu + ry*vv + rz*n);\n    return normalize(rr);\n}\n\nvec3 modifyDirectionWithRoughness( const vec3 normal, const vec3 n, const float roughness, inout float seed ) {\n    vec2 r = hash2(seed);\n    \n\tvec3  uu = normalize(cross(n, abs(n.y) > .5 ? vec3(1.,0.,0.) : vec3(0.,1.,0.)));\n\tvec3  vv = cross(uu, n);\n\t\n    float a = roughness*roughness;\n    \n\tfloat rz = sqrt(abs((1.0-r.y) / clamp(1.+(a - 1.)*r.y,.00001,1.)));\n\tfloat ra = sqrt(abs(1.-rz*rz));\n\tfloat rx = ra*cos(6.28318530718*r.x); \n\tfloat ry = ra*sin(6.28318530718*r.x);\n\tvec3  rr = vec3(rx*uu + ry*vv + rz*n);\n    \n    vec3 ret = normalize(rr);\n    return dot(ret,normal) > 0. ? ret : n;\n}\n\nvec2 randomInUnitDisk( inout float seed ) {\n    vec2 h = hash2(seed) * vec2(1,6.28318530718);\n    float phi = h.y;\n    float r = sqrt(h.x);\n\treturn r*vec2(sin(phi),cos(phi));\n}\n\n//\n// Scene description\n//\n\nvec3 rotateY( const in vec3 p, const in float t ) {\n    float co = cos(t);\n    float si = sin(t);\n    vec2 xz = mat2(co,si,-si,co)*p.xz;\n    return vec3(xz.x, p.y, xz.y);\n}\n\nvec3 opU( vec3 d, span s, inout vec3 normal, float mat ) {\n    if( s.n.t<d.y && s.n.t>d.x) {\n        normal=s.n.n;\n        d=vec3(d.x, s.n.t, mat);\n    }\n\treturn d;\n}\n        \nvec3 worldhit( in vec3 ro, in vec3 rd, in vec2 dist, out vec3 normal ) {\n    \n   vec3  d = vec3(dist, 0.);\n \n    span s = iBox(ro-vec3(0.,-.4,0.),rd,vec3(10.,.4,10.));\n        iPlane(ro,rd,-vec3(0,1.,0),1.);           \n    d= opU(  d,  s,  normal, 1. ) ;\n    \n    span s2,s3;\n   \n       \n     obj2 oo[] =obj2[](\n         obj2(vec3(0,.4,0),vec3(.5,.4,.3),1,7.),\n         obj2(vec3(1,.4,0),vec3(.4),8,9.),\n         obj2(vec3(-1,.4,0),vec3(.4),7,10.),\n         obj2(vec3(1,.4,1),vec3(.4),6,11.),\n         obj2(vec3(0,.4,1),vec3(.4),5,3.),\n         obj2(vec3(-1,.4,1),vec3(.3),4,4.),\n         obj2(vec3(1,.4,-1),vec3(.4),3,5.),\n         obj2(vec3(0,.4,-1),vec3(.3),2,10.1),\n         obj2(vec3(-1,.4,-1),vec3(.3),0,7.)\n    );\n    \n    bool inter= texelFetch(iChannel3,ivec2(32,2),0).x>.5,\n        sub=texelFetch(iChannel3,ivec2(65,2),0).x>.5,\n        unio=texelFetch(iChannel3,ivec2(66,2),0).x>.5;\n    \n    for(int i=min(iFrame,0); i< oo.length();i++){\n       s2= iSupportFunction(ro-oo[i].p,rd,oo[i]);\n       if(inter ||sub|| unio){\n           s3= iSphere(ro-oo[i].p,rd,.4);\n           if(sub){\n               s2=Sub(s2,s3);\n           } \n           else if(unio){\n               s2=Union(s2,s3);\n           } else s2=Inter(s2,s3);\n       }\n       d= opU(  d,  s2,normal , oo[i].m);  \n    };\n    \n     if(dot(rd,normal)>0.) normal=-normal;\n    return d;\n}\n\n//\n// Palette by Íñigo Quílez: \n// https://www.shadertoy.com/view/ll2GD3\n//\nvec3 pal(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n    return a + b*cos(6.28318530718*(c*t+d));\n}\n\nfloat checkerBoard( vec2 p ) {\n   return mod(floor(p.x) + floor(p.y), 2.);\n}\n\nvec3 getSkyColor( vec3 rd ) {\n    vec3 col = mix(vec3(1),vec3(.5,.7,1), .5+.5*rd.y);\n    float sun = clamp(dot(normalize(vec3(-.4,.7,-.6)),rd), 0., 1.);\n    col += vec3(1,.6,.1)*(pow(sun,4.) + 10.*pow(sun,32.));\n    return col;\n}\n\n#define LAMBERTIAN 0.\n#define METAL 1.\n#define DIELECTRIC 2.\n\nfloat gpuIndepentHash(float p) {\n    p = fract(p * .1031);\n    p *= p + 19.19;\n    p *= p + p;\n    return fract(p);\n}\n\nvoid getMaterialProperties(in vec3 pos, in float mat, \n                           out vec3 albedo, out float type, out float roughness) {\n    albedo = pal(mat*.59996323+.5, vec3(.5),vec3(.5),vec3(1),vec3(0,.1,.2));\n\n    if( mat < 1.5 ) {            \n        albedo = vec3(.25 + .25*checkerBoard(pos.xz * 5.));\n        roughness = .75 * albedo.x - .15;\n        type = METAL;\n    } else {\n        type = floor(gpuIndepentHash(mat+.3) * 3.);\n        roughness = (1.-type*.475) * gpuIndepentHash(mat);\n    }\n}\n\n//\n// Simple ray tracer\n//\n\nfloat schlick(float cosine, float r0) {\n    return r0 + (1.-r0)*pow((1.-cosine),5.);\n}\nvec3 render( in vec3 ro, in vec3 rd, inout float seed ) {\n    vec3 albedo, normal, col = vec3(1.); \n    float roughness, type;\n    \n    for (int i=0; i<PATH_LENGTH; ++i) {    \n    \tvec3 res = worldhit( ro, rd, vec2(.0001, 100), normal );\n\t\tif (res.z > 0.) {\n\t\t\tro += rd * res.y;\n       \t\t\n            getMaterialProperties(ro, res.z, albedo, type, roughness);\n            \n            if (type < LAMBERTIAN+.5) { // Added/hacked a reflection term\n                float F = FresnelSchlickRoughness(max(0.,-dot(normal, rd)), .04, roughness);\n                if (F > hash1(seed)) {\n                    rd = modifyDirectionWithRoughness(normal, reflect(rd,normal), roughness, seed);\n                } else {\n                    col *= albedo;\n\t\t\t        rd = cosWeightedRandomHemisphereDirection(normal, seed);\n                }\n            } else if (type < METAL+.5) {\n                col *= albedo;\n                rd = modifyDirectionWithRoughness(normal, reflect(rd,normal), roughness, seed);            \n            } else { // DIELECTRIC\n                vec3 normalOut, refracted;\n                float ni_over_nt, cosine, reflectProb = 1.;\n                if (dot(rd, normal) > 0.) {\n                    normalOut = -normal;\n            \t\tni_over_nt = 1.4;\n                    cosine = dot(rd, normal);\n                    cosine = sqrt(1.-(1.4*1.4)-(1.4*1.4)*cosine*cosine);\n                } else {\n                    normalOut = normal;\n                    ni_over_nt = 1./1.4;\n                    cosine = -dot(rd, normal);\n                }\n            \n\t            // Refract the ray.\n\t            refracted = refract(normalize(rd), normalOut, ni_over_nt);\n    \t        \n        \t    // Handle total internal reflection.\n                if(refracted != vec3(0)) {\n                \tfloat r0 = (1.-ni_over_nt)/(1.+ni_over_nt);\n\t        \t\treflectProb = FresnelSchlickRoughness(cosine, r0*r0, roughness);\n                }\n                \n                rd = hash1(seed) <= reflectProb ? reflect(rd,normal) : refracted;\n                rd = modifyDirectionWithRoughness(-normalOut, rd, roughness, seed);            \n            }\n        } else {\n            col *= getSkyColor(rd);\n\t\t\treturn col;\n        }\n    }  \n    return vec3(0);\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr ) {\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv =          ( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    bool reset = iFrame == 0;\n            \n    vec2 mo = iMouse.xy == vec2(0) ? vec2(.125) : \n              abs(iMouse.xy)/iResolution.xy - .5;\n        \n    vec4 data = texelFetch(iChannel0, ivec2(0), 0);\n    if (round(mo*iResolution.xy) != round(data.yz) || round(data.w) != round(iResolution.x)) {\n        reset = true;\n    }\n    \n    vec3 ro = vec3(+2.5*cos(1.5+6.*mo.x), 1.+2.*mo.y, +2.5*sin(1.5+6.*mo.x));\n    vec3 ta = vec3(0.,0.,0.);\n    mat3 ca = setCamera(ro, ta, 0.);    \n    vec3 normal;\n    \n    float fpd = data.x;\n    if(all(equal(ivec2(fragCoord), ivec2(0)))) {\n        // Calculate focus plane.\n        float nfpd = worldhit(ro, normalize(vec3(.0,0.4,0)-ro), vec2(0, 100), normal).y;\n\t\tfragColor = vec4(nfpd, mo*iResolution.xy, iResolution.x);\n    } else { \n        vec2 p = (-iResolution.xy + 2.*fragCoord - 1.)/iResolution.y;\n        float seed = float(baseHash(floatBitsToUint(p - iTime)))/float(0xffffffffU);\n\n        // AA\n        p += 2.*hash2(seed)/iResolution.y;\n        vec3 rd = ca * normalize( vec3(p.xy,1.6) );  \n\n        // DOF\n        vec3 fp = ro + rd * fpd;\n        ro = ro + ca * vec3(randomInUnitDisk(seed), 0.)*.02;\n        rd = normalize(fp - ro);\n\n        vec3 col = render(ro, rd, seed);\n\n        if (reset) {\n           fragColor = vec4(col, 1);\n        } else {\n           fragColor = vec4(col, 1) + texelFetch(iChannel0, ivec2(fragCoord), 0);\n        }\n    }\n}","name":"Buffer A","description":"","type":"buffer"}]}