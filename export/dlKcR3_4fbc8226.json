{"ver":"0.1","info":{"id":"dlKcR3","date":"1700513487","viewed":90,"name":"Shard Noise - Volumetric Slice","username":"ploogle","description":"Based on @ENDESGA Shard Noise - https://www.shadertoy.com/view/dlKyWw#\nForked from @been_jamming https://www.shadertoy.com/view/WstBR2\n\nA cube slicing through a 3D field of Shard Noise.","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["raytracing"],"hasliked":0,"parentid":"WstBR2","parentname":"raytraced cube"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define FOV_CONST 0.15\n#define RENDER_DISTANCE 50.0\n\nvec4 orientation;\n\nvec3 get_camera_ray(vec2 pixel){\n    float least_side;\n    \n    pixel -= vec2(0.5);\n    least_side = min(iResolution.x, iResolution.y);\n    return vec3(0.15*pixel.x*iResolution.x/least_side, 0.15*pixel.y*iResolution.y/least_side, FOV_CONST);\n}\n\nbool lit(vec3 p, vec3 light){\n    vec3 ray;\n    float d;\n    int i;\n    vec3 pos;\n    vec3 normal;\n    triangle tri;\n    \n    p = p + (light - p)*0.001;//We don't want the ray to collide with the original triangle\n    for(i = 0; i < 12; i++){\n        tri = triangles[i];\n        tri = translate_triangle(tri, -p);\n        d = ray_triangle_intersect(light - p, rotate_triangle(tri, vec3(0, 0, 4) - p, orientation), pos, normal);\n        if(d > 0.0)\n            return false;\n    }\n    \n    return true;\n}\n\nvec4 shard_volume(in vec3 surface_pos, in vec3 ray_direction) {\n    vec4 color = vec4(0.0, 0.0, 0.0, 1.0);\n    vec3 current_pos = surface_pos;\n    float depth = 9.0;\n    float steps = depth;//10.0;\n    for (float dist = 0.0; dist <= depth; dist += depth / steps) {\n        color += shard_noise(current_pos, 30.0) / steps * .75;\n        \n        current_pos += ray_direction * dist;\n    }\n    color.a = 1.0;\n    \n    return color;\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\tint i;\n    vec3 camera_ray;\n    vec3 pos;\n    vec3 intersect_pos;\n    vec3 intersect_normal;\n    vec3 normal;\n    float d;\n    float p;\n    float least_distance = RENDER_DISTANCE + 1.0;\n    vec4 current_color = vec4(0.0, 0.0, 0.0, 1.0);\n    vec3 light_pos = vec3(10.0, 15.0, 0.0);\n    vec3 camera_pos = vec3(iTime/2.0,iTime/2.0, iTime/4.0);\n   \n    orientation = create_orientation(vec3(sin(iTime/20.0), cos(iTime/17.0), -cos(iTime/3.0)), iTime/10.0);\n    //orientation = create_orientation(vec3(0.0, 1.0, 0.0), iTime/10.0);\n\n    camera_ray = get_camera_ray(vec2(fragCoord.x/iResolution.x, fragCoord.y/iResolution.y));\n    \n    bool use_cube = true;\n    \n    if (use_cube) {\n        //Loop through 12 triangles and determine if camera ray intersects them\n        for(i = 0; i < 12; i++){\n            d = ray_triangle_intersect(camera_ray, rotate_triangle(triangles[i], vec3(0, 0, 4), orientation), pos, normal);\n\n            if(d > 0.0 && d < least_distance){\n                least_distance = d;\n                current_color = colors[i];\n                intersect_pos = pos;\n                intersect_normal = normal;\n            }\n        }\n\n        if(least_distance < RENDER_DISTANCE){\n            //fragColor = shard_volume(intersect_pos * 2.0, camera_ray);\n            fragColor = shard_volume(intersect_pos * 2.0, camera_ray);\n        } else {\n            fragColor = vec4(0.0, 0.0, 0.0, 1);\n        }\n    } else {\n        fragColor = shard_volume(vec3(fragCoord.x/iResolution.x, fragCoord.y/iResolution.y, 1.0) * 5.0 + camera_pos, camera_ray);\n    }\n}\n\n\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"//Verticies of cube triangle\n\nstruct triangle{\n    vec3 vertex0;\n    vec3 vertex1;\n    vec3 vertex2;\n};\n\ntriangle triangles[12] = triangle[12](triangle(vec3(1.0, 1.0, 3.0), vec3(1.0, -1.0, 3.0), vec3(-1.0, -1.0, 3.0)),\n                                      triangle(vec3(1.0, 1.0, 3.0), vec3(-1.0, 1.0, 3.0), vec3(-1.0, -1.0, 3.0)),\n                                      triangle(vec3(-1.0, 1.0, 5.0), vec3(-1.0, 1.0, 3.0), vec3(1.0, 1.0, 3.0)),\n                                      triangle(vec3(1.0, 1.0, 5.0), vec3(-1.0, 1.0, 5.0), vec3(1.0, 1.0, 3.0)),\n                                      triangle(vec3(-1.0, -1.0, 5.0), vec3(-1.0, -1.0, 3.0), vec3(-1.0, 1.0, 5.0)),\n                                      triangle(vec3(-1.0, 1.0, 3.0), vec3(-1.0, 1.0, 5.0), vec3(-1.0, -1.0, 3.0)),\n                                      triangle(vec3(-1.0, -1.0, 3.0), vec3(1.0, -1.0, 3.0), vec3(-1.0, -1.0, 5.0)),\n                                      triangle(vec3(1.0, -1.0, 3.0), vec3(1.0, -1.0, 5.0), vec3(-1.0, -1.0, 5.0)),\n                                      triangle(vec3(1.0, 1.0, 3.0), vec3(1.0, -1.0, 3.0), vec3(1.0, -1.0, 5.0)),\n                                      triangle(vec3(1.0, 1.0, 3.0), vec3(1.0, 1.0, 5.0), vec3(1.0, -1.0, 5.0)),\n                                      triangle(vec3(-1.0, 1.0, 5.0), vec3(-1.0, -1.0, 5.0), vec3(1.0, -1.0, 5.0)),\n                                      triangle(vec3(-1.0, 1.0, 5.0), vec3(1.0, 1.0, 5.0), vec3(1.0, -1.0, 5.0)));\n\n//Colors of the triangles\nvec4 colors[12] = vec4[12](vec4(0.0, 0.0, 1.0, 1.0),\n                           vec4(0.0, 0.0, 1.0, 1.0),\n                           vec4(0.0, 0.5, 1.0, 1.0),\n                           vec4(0.0, 0.5, 1.0, 1.0),\n                           vec4(0.5, 0.0, 1.0, 1.0),\n                           vec4(0.5, 0.0, 1.0, 1.0),\n                           vec4(0.5, 0.5, 1.0, 1.0),\n                           vec4(0.5, 0.5, 1.0, 1.0),\n                           vec4(0.0, 0.5, 0.0, 1.0),\n                           vec4(0.0, 0.5, 0.0, 1.0),\n                           vec4(1.0, 0.0, 1.0, 1.0),\n                           vec4(1.0, 0.0, 1.0, 1.0));\n\nbool same_side(vec3 p1, vec3 p2, vec3 a, vec3 b){\n    vec3 cp1;\n    vec3 cp2;\n    \n    cp1 = cross(b - a, p1 - a);\n    cp2 = cross(b - a, p2 - a);\n    if(dot(cp1, cp2) > 0.0){\n        return true;\n    } else {\n        return false;\n    }\n}\n\nbool inside_triangle(vec3 p, triangle tri){\n\tif(same_side(p, tri.vertex0, tri.vertex1, tri.vertex2) &&\n       same_side(p, tri.vertex1, tri.vertex0, tri.vertex2) &&\n       same_side(p, tri.vertex2, tri.vertex0, tri.vertex1))\n        return true;\n    else\n        return false;\n}\n\ntriangle translate_triangle(triangle tri, vec3 v){\n    return triangle(tri.vertex0 + v, tri.vertex1 + v, tri.vertex2 + v);\n}\n\n//Return distance of intersection if there is an intersection, otherwise return -1.0\nfloat ray_triangle_intersect(vec3 ray, triangle tri, out vec3 pos, out vec3 normal){\n    float t;\n    vec3 ABC;\n    vec3 i;\n    float K;\n    \n    //Get the plane\n    ABC = cross(tri.vertex2 - tri.vertex0, tri.vertex1 - tri.vertex0);\n    normal = ABC;\n    K = dot(ABC, tri.vertex0);\n    \n    //Get the point of intersection, if it exists\n    t = K/dot(ABC, ray);\n    if(t < 0.0){\n        return -1.0;\n    }\n    i = t*ray;\n    pos = i;\n    \n    //Determine if this point is on the triangle\n   \tif(inside_triangle(i, tri))\n       return i.x*i.x + i.y*i.y + i.z*i.z;\n    else\n       return -1.0;\n}\n\nvec4 create_orientation(vec3 axis, float angle){\n    float len;\n    vec4 outvec;\n    \n    len = length(axis);\n    axis *= sin(angle)/len;\n    outvec.yzw = axis;\n    outvec.x = cos(angle);\n    \n    return outvec;\n}\n\nvec4 inverse_orientation(vec4 orientation){\n    float len;\n    \n    len = length(orientation);\n    orientation /= len;\n    orientation.yzw = -orientation.yzw;\n    \n    return orientation;\n}\n\nvec4 compose_orientation(vec4 a, vec4 b){\n    vec4 outvec;\n    \n    outvec.x = a.x*b.x - a.y*b.y - a.z*b.z - a.w*b.w;\n    outvec.y = a.x*b.y + a.y*b.x + a.z*b.w - a.w*b.z;\n    outvec.z = a.x*b.z - a.y*b.w + a.z*b.x + a.w*b.y;\n    outvec.w = a.x*b.w + a.y*b.z - a.z*b.y + a.w*b.x;\n    \n    return outvec;\n}\n\nvec3 apply_orientation(vec3 p, vec4 o){\n    vec4 v;\n    \n    v.x = 0.0;\n    v.yzw = p.xyz;\n    return compose_orientation(compose_orientation(o, v), inverse_orientation(o)).yzw;\n}\n\ntriangle rotate_triangle(triangle tri, vec3 center, vec4 o){\n    tri = triangle(apply_orientation(tri.vertex0 - center, o), apply_orientation(tri.vertex1 - center, o), apply_orientation(tri.vertex2 - center, o));\n\ttri = triangle(tri.vertex0 + center, tri.vertex1 + center, tri.vertex2 + center);\n    return tri;\n}\n\nvec3 get_rotated_pos(vec3 pos, triangle tri, vec4 o) {\n    \n    //return tri;\n    \n    return apply_orientation(pos, -o);\n}\n\n\n#define tau 6.283185307179586\n\nvec3 hash(vec3 p)\n{\n    p = vec3(dot(p, vec3(127.1, 311.7, 74.7)), dot(p, vec3(269.5,183.3,246.1)), dot(p, vec3(113.5, 271.9, 124.6)));\n    p = fract(sin(p) * 43758.5453123);\n    return p;\n}\n\nfloat shard_noise(in vec3 p, in float sharpness) {\n    vec3 ip = floor(p);\n    vec3 fp = fract(p);\n\n    float v = 0., t = 0.;\n    for (int z = -1; z <= 1; z++) {\n        for (int y = -1; y <= 1; y++) {\n            for (int x = -1; x <= 1; x++) {\n                vec3 o = vec3(x, y, z);\n                vec3 io = ip + o;\n                vec3 h = hash(io);\n                vec3 r = fp - (o + h);\n\n                float w = exp2(-tau*dot(r, r));\n                // tanh deconstruction and optimization by @Xor\n                float s = sharpness * dot(r, hash(io + vec3(11, 31, 47)) - 0.5);\n                v += w * s*inversesqrt(1.0+s*s);\n                t += w;\n            }\n        }\n    }\n    return ((v / t) * .5) + .5;\n}\n","name":"Common","description":"","type":"common"}]}