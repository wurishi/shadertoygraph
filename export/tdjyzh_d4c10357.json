{"ver":"0.1","info":{"id":"tdjyzh","date":"1586120481","viewed":121,"name":"Bezier Experiment","username":"syncryptic","description":"An attempt at determining the closest point on a cubic bezier. Makes some pretty pictures though.","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["bezier","cubic","root","cubicbezier","bairstow","bairstows"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\nThis person has some legit good material: https://pomax.github.io/bezierinfo/#extremities\n*/\n// Cubic\nvec2 toBezier(float t, vec2 P0, vec2 P1, vec2 P2, vec2 P3)\n{\n    /*  Expanded using SageMath, may be faster calculations.\n                of note: https://vicrucann.github.io/tutorials/bezier-shader/, they seem pretty smart\n                 B(t)=(1-t)_3*P0 + 3*(1-t)_2*t*P1 + 3*(1-t)t_2*P2 + t_3*P3\n                B(t)=(1-t)(1-t)(1-t)*P0 + 3*(1-t)(1-t)*t*P1 + 3*(1-t)t*t*P2 + t*t*t*P3\n                B(t)=-3*P2*t_3 + P3*t_3 + 3*P1*t_2 + 3*P2*t_2 - P0*t + P0\n        */\n    float tmin1 = t-1.;\n    float tmin1_2 = tmin1*tmin1;\n    float t2 = t*t;\n    return -P0*tmin1*tmin1_2 + 3.*P1*tmin1_2*t - 3.*P2*tmin1*t2 + P3*t*t2;\n\n}\n\n// Quadratic\nvec2 toBezier(float t, vec2 P0, vec2 P1, vec2 P2)\n{\n    /* Expanded using sagemath.\n            B(t)=(1-t)[(1-t)*P0+t*P1]+t*[(1-t)*P1+t*P2]\n                B(t)=-P1*t_2 + P2*t_2 + P0*t - P0 + 1\n        */\n    float t2 = t*t;\n    return (1. + P0*t - P0 - P1*t2 + P2*t2);\n}\n\nvec3 closest_T(vec2 G, vec2 P0, vec2 P1, vec2 P2, vec2 P3) {\n    vec2 P_0 = P0 - G;\n    vec2 P_1 = P1 - G;\n    vec2 P_2 = P2 - G;\n    vec2 P_3 = P3 - G;\n    vec2 A = P_3-3.0*P_2+3.0*P_1-P_0;\n    vec2 B = 3.0*P_2-6.0*P_1+3.0*P_0;\n    vec2 C = 3.0*(P_1-P_0);\n    vec2 D = P_0;\n    float Q_0 = dot(C,D);\n    float Q_1 = dot(C,C)+2.0*dot(B,D);\n    float Q_2 = 3.0*dot(B,C)+3.0*dot(A,D);\n    float Q_3 = 4.0*dot(A,C)+2.0*dot(B,B);\n    float Q_4 = 5.0*dot(A,B);\n    float Q_5 = 3.0*dot(A,A);\n\n    //Bairstow Polynomial Remainer\n    vec2 rs = bairstow(0.5, 0.5, Q_0, Q_1, Q_2, Q_3, Q_4, Q_5);\n    mat3x3 roots;\n    roots[0] = quadratic_formula(1.0, rs[0],rs[1]);\n    float[4] f_n3 = bairstow_rem(rs[0],rs[1],Q_0, Q_1, Q_2, Q_3, Q_4, Q_5);\n    /*\n    rs = bairstow(0.5, 0.5, f_n3[0],f_n3[1],f_n3[2], f_n3[3]);\n    \n    roots[1] = quadratic_formula(1.0, rs[0],rs[1]);\n    float[2] f_n1 = bairstow_rem(f_n3[1]/f_n3[2], f_n3[0]/f_n3[2],\n                                 f_n3[0], f_n3[1], f_n3[2], f_n3[3]);\n    roots[2] = vec3(-f_n1[1]/f_n1[0], -f_n1[1]/f_n1[0], 1.0);\n\t*/\n    vec4 cube_root = cubic_formula(f_n3[0],f_n3[1],f_n3[2], f_n3[3]);\n    if(cube_root[3] == 3.) {\n        roots[1][0] = cube_root[0];\n        roots[1][1] = cube_root[1];\n        roots[1][2] = 1.0;\n    } \n    if(cube_root[3] == 1.) {\n        roots[2][0] = cube_root[2];\n        roots[2][1] = cube_root[2];\n        roots[1][2] = 1.0;\n    }\n\t\n    \n    float d=99999.;\n    float d_0 = length(toBezier(0.0,P_0,P_1,P_2,P_3));\n    float d_1 = length(toBezier(1.0,P_0,P_1,P_2,P_3));\n\n    float min_t = d_0 < d_1 ? 0.0 : 1.0;\n    float min_d = min(d_0,d_1);\n\t\n    vec3 o = vec3(0.);\n    float d0, d1;\n    for(int i = 0; i < 3; i++) {\n        if(sign(roots[i][2]) > 0.) {\n            if(clamp(roots[i][0],0.,1.)==roots[i][0]) {\n                o[i] = roots[i][0];\n            }\n            if(clamp(roots[i][1],0.,1.)==roots[i][1]) {\n                if(o[i] != 0.) {\n                    d0 = length(toBezier(roots[i][0],P_0,P_1,P_2,P_3));\n                    d1 = length(toBezier(roots[i][1],P_0,P_1,P_2,P_3));\n                    o[i] = d0 < d1 ? roots[i][0] : roots[i][1];\n                } else {\n                    o[i] = roots[i][1];\n                }\n            }\n        } else {\n                                o[i] = roots[i][1];\n\n        }\n        \n    }\n    o = o == vec3(0.0) ? vec3(1.0) : o;\n    vec3 q = vec3(length(toBezier(o[0],P_0,P_1,P_2,P_3)),\n                  length(toBezier(o[1],P_0,P_1,P_2,P_3)),\n                  length(toBezier(o[2],P_0,P_1,P_2,P_3)));\n\treturn o;\n    //return vec3(min(q[0],min(q[1],q[2])));\n    \n    for (int i = 0; i < 3; i++){\n        if(roots[i][2] > 0.0) {\n            for (int j = 0; j < 2; i++){\n                if(0.0 <= roots[i][j] && roots[i][j] <= 1.0) {\n                    float t = roots[i][j];\n                    float t2 = t*t;\n                    float t3 = t2*t;\n                    float t4 = t2*t2;\n                    float t5 = t2*t3;\n                    float f = Q_5*t5+Q_4*t4+Q_3*t3+Q_2*t2+Q_1*t+Q_0;\n                \t\n                \td = length(toBezier(t,P_0,P_1,P_2,P_3));\n                    min_t = min_d <= d ? min_t : roots[i][j];\n                }\n            }\n        }\n    }\n    \n    //return vec2(min_t,min_d);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (2.0*fragCoord.xy-iResolution.xy)/iResolution.y;\n    vec2 n = vec2(-cos(iTime * 1.5) * 0.8, (sin(iTime*1.75)-3.)/6.);\n    vec2 m = mix((2.0*iMouse.xy-iResolution.xy)/iResolution.y,\n        vec2(cos(iTime) * 0.8, 0.25), step(iMouse.z, 0.0));\n    \n    // Define the control points of our curve\n    vec2 A = vec2(0.0, -0.6), D = vec2(0.0, +0.6);\n    vec2 B = vec2(n), C = vec2(m);\n    \n    // Render the control points\n    float d = min(distance(p, A),(min(distance(p, B), min(distance(p, C), distance(p,D)))));\n    if (d < 0.04) { fragColor = vec4(1.0 - smoothstep(0.025, 0.034, d)); return; }\n    \n    // Get the signed distance to bezier curve;\n    d=10000000.;\n    for(float t=0.; t <= 1.; t+=0.05){\n\t\td=min(d,distance(p, toBezier(t,A,B,C,D)));\n        if (d < 0.01) { fragColor = vec4(vec3(0.0),1.0); return; }\n\n    }\n    vec3 uv = closest_T(p,A,B,C,D);\n    fragColor=vec4(uv,1.0);\n    //fragColor = vec4(uv,d,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"float[4] bairstow_rem(float r, float s, float a_0, float a_1, float a_2, float a_3, float a_4, float a_5) {\n    float b_4 = a_5*r + a_4;\n    float b_3 = b_4*r + a_5*s + a_3;\n    float b_2 = b_3*r + b_4*s + a_2;\n    float b_1 = b_2*r + b_3*s + a_1;\n    float b_0 = b_1*r + b_2*s + a_0;\n\n    return float[4](b_0,b_1,b_2,b_3);\n}\n\nfloat[3] bairstow_rem(float r, float s, float a_0, float a_1, float a_2, float a_3, float a_4) {\n    float b_3 = a_4*r + a_3;\n    float b_2 = b_3*r + a_4*s + a_2;\n    float b_1 = b_2*r + b_3*s + a_1;\n    float b_0 = b_1*r + b_2*s + a_0;\n\n    return float[3](b_0,b_1,b_2);\n}\n\nfloat[2] bairstow_rem(float r, float s, float a_0, float a_1, float a_2, float a_3) {\n    float b_2 = a_3*r + a_2;\n    return float[2](b_2, a_3);\n}\n\nvec2 bairstow(float r, float s, float a_0, float a_1, float a_2, float a_3, float a_4, float a_5) {\n\tfor (int i = 0; i < 10; i++) {\n\t    float b_4 = a_5*r + a_4;\n        float b_3 = b_4*r + a_5*s + a_3;\n        float b_2 = b_3*r + b_4*s + a_2;\n\t    float b_1 = b_2*r + b_3*s + a_1;\n\t    float b_0 = b_1*r + b_2*s + a_0;\n\n\t    float c_4 = 2.*a_5*r + a_4;\n\t    float c_3 = c_4*r + a_5*s + b_3;\n\t    float c_2 = c_3*r + c_4*s + b_2;\n\t    float c_1 = c_2*r + c_3*s + b_1;\n            \n\t    float d_r = -(b_1*c_2 - b_0*c_3)/(c_2*c_2 - c_1*c_3);\n\t    float d_s =  (b_1*c_1 - b_0*c_2)/(c_2*c_2 - c_1*c_3);\n\t    float e_r = abs(d_r/r);\n\t    float e_s = abs(d_s/s);\n\t    r += d_r;\n\t    s += d_s;\n\t    if(e_r < 0.00000001 && e_s < 0.00000001) {\n\t        return vec2(r,s);\n\t    }\n\t}\n\treturn vec2(r,s);\n}\n\nvec2 bairstow(float r, float s, float a_0, float a_1, float a_2, float a_3, float a_4) {\n\tfor (int i = 0; i < 10; i++) {\n\t\tfloat c_3 = 2.0*a_4*r + a_3;\n\t\tfloat c_2 = (c_3)*r + (a_4*r + a_3)*r + 2.0*a_4*s + a_2;\n\t\tfloat c_1 = (c_2)*r + ((a_4*r + a_3)*r + a_4*s + a_2)*r + (c_3)*s + (a_4*r + a_3)*s + a_1;\n\n\t\tfloat b_1 = ((a_4*r + a_3)*r + a_4*s + a_2)*r + (a_4*r + a_3)*s + a_1;\n\t\tfloat b_0 = (b_1)*r + ((a_4*r + a_3)*r + a_4*s + a_2)*s + a_0;\n\t\tfloat d_r = -(b_1*c_2 - b_0*c_3)/(c_2*c_2 - c_1*c_3);\n\t\tfloat d_s =  (b_1*c_1 - b_0*c_2)/(c_2*c_2 - c_1*c_3);\n\t\tfloat e_r = abs(d_r/r);\n\t\tfloat e_s = abs(d_s/s);\n\t\tr += d_r;\n\t\ts += d_s;\n        if(e_r < 0.00000001 && e_s < 0.00000001) {\n            return vec2(r,s);\n        }\n\t}\n\treturn vec2(r,s);\n}\n\nvec2 bairstow(float r, float s, float a_0, float a_1, float a_2, float a_3) {\n\tfor (int i = 0; i < 10; i++) {\n\t\tfloat b_3 = a_3;\n\t\tfloat b_2 = b_3*r + a_2;\n\t\tfloat b_1 = b_2*r + b_3*s + a_1;\n\t\tfloat b_0 = b_1*r + b_2*s + a_0;\n\t\tfloat c_3 = a_3;\n\t\tfloat c_2 = c_3*r + b_2;\n\t\tfloat c_1 = c_2*r + c_3*s + b_1;\n\t\tfloat d_r = -(b_1*c_2 - b_0*c_3)/(c_2*c_2 - c_1*c_3);\n\t\tfloat d_s =  (b_1*c_1 - b_0*c_2)/(c_2*c_2 - c_1*c_3);\n\t\tfloat e_r = abs(d_r/r);\n\t\tfloat e_s = abs(d_s/s);\n\t\tr += d_r;\n\t\ts += d_s;\n        if(e_r < 0.00000001 && e_s < 0.00000001) {\n            return vec2(r,s);\n        }\n\t}\n\treturn vec2(r,s);\n}\n\nvec3 quadratic_formula(float a, float b, float c) {\n    float b2_4ac = b*b-4.0*a*c;\n    float sqrt_b2_4ac = sqrt(b2_4ac);\n    float twoa = 2.0*a; \n    return vec3((b+sqrt_b2_4ac)/twoa,\n                (b-sqrt_b2_4ac)/twoa,\n                 sign(b2_4ac));\n}\n\nconst float PI = 3.1415926535897932384626433832795;\n\nvec4 cubic_formula(float a, float b, float c, float d)\n{\n    // https://en.wikipedia.org/wiki/Cubic_equation#Depressed_cubic\n\tfloat p = (3.*a*c - b*b)/(3.*a*a);\n    float q = (2.*b*b*b - 9.*a*b + 27.*a*a*d) / (27.*a*a*a);\n\n    if (p == 0.) {\n        return vec4(0.);\n    };\n        \n    float discriminant = q*q + 4.0*p*p*p / 27.0;\n    vec4 result;\n    if(discriminant < 0.){ // Trigonometric solution for three real roots\n        float outer_part = 2.*sqrt(-p/3.);\n        float inner_part = (1./3.)*acos(3.*q/(2.*p)*sqrt(-3./p));\n\n        result[0] = outer_part*cos(inner_part - 1.*2.*PI/3.);\n        result[1] = outer_part*cos(inner_part - 2.*2.*PI/3.);\n        result[2] = outer_part*cos(inner_part - 3.*2.*PI/3.);\n        result[3] = 3.;\n    } else { // Hyperbolic solution for one root.\n        if(p < 0.) {\n            result[0] = -2.*abs(q)/(q)*cosh((1./3.)*acosh( (-3.*abs(q))/(2.*p)*sqrt(-3./p) ));\n        } else {\n            result[0] = -2.*sqrt(p/3.)*sinh((1./3.)*asinh( (3.*q)/(2.*p)*sqrt(3./p) ));\n\n        }\n        result[3] = 1.;\n    }\n    for(int i = 0; i < int(result[3]); i++){\n        result[i] = result[i] - b/(3.*a);\n    };\n    return vec4(0.);\n}\n","name":"Common","description":"","type":"common"}]}