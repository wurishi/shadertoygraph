{"ver":"0.1","info":{"id":"MftcRn","date":"1730192664","viewed":43,"name":"Generate Number of Islands","username":"Berry","description":"For a coding challenge at work: \"Generate Number of Islands\"\nIt is the creative coding equivalent to the leetcode coding challenge \"Count Number of Islands\"","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["voronoi","island"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// This is the expected number of islands \n//. WITHIN the domain defined in the first line of the main function!\nconst int N_ISLANDS = 10; \nconst int DOMAIN_DIMENSION = 5;\nconst float ISLAND_SEED = 1337.43; // Only used to determine whether a cell is an island\nconst vec3 COLOR_WATER = vec3(114./255.,163./255.,167./255.);\nconst vec3 COLOR_SAND = vec3(208./255., 183./255., 160./255.);\nconst vec3 COLOR_GRASS = vec3(157./255., 170./255., 103./255.);\nconst vec3 COLOR_FOREST = vec3(83./255.,115./255.,73./255.);\nconst vec3 COLOR_MOUNTAIN = vec3(109./255.,117./255.,132./255.);\nconst float JITTER_INTENSITY = 0.05;\n\nfloat hash1( float n ) { return fract(sin(n)*43758.5453); }\nvec2  hash2( vec2  p ) { p = vec2( dot(p,vec2(127.1,311.7)), dot(p,vec2(269.5,183.3)) ); return fract(sin(p)*43758.5453); }\n\n\nvec4 voronoi( in vec2 p )\n{\n    vec2 cell_index = floor( p );\n    vec2 cell_uv = fract( p );\n\n    // ClosestPoint\n    // x = closest_point_distance_squared\n    // y = closest_point_x\n    // z = closest_point_y\n    // w = second_closest_point_distance_squared\n    vec4 closest_point = vec4(8.0,0.,0.,0.);\n    \n    for( int j=-1; j<=1; j++ )\n    for( int i=-1; i<=1; i++ )\n    {\n        vec2 neighbor_offset = vec2( i, j );\n        vec2 neighbor_index = vec2(cell_index + neighbor_offset);\n        vec2 neighbor_seed_point = hash2( neighbor_index );\n        vec2 p_to_seed = vec2( neighbor_offset ) - cell_uv + neighbor_seed_point;\n        float distance_squared = dot( p_to_seed, p_to_seed );\n        if ( distance_squared < closest_point.x )\n        {\n            closest_point = vec4( distance_squared, neighbor_seed_point, closest_point.x );            \n        }\n        else if( distance_squared < closest_point.w )\n        {\n            closest_point.w = distance_squared;\n        }\n    }\n    return closest_point;\n}\n\n\nfloat random_number_to_expected_hit(float random_number, float domain_size, float n_expected_hits) \n{\n    // Calculate the probability threshold based on the expected hits\n    float threshold = float(n_expected_hits) / float(domain_size);\n    \n    // Return 1. if random_number < threshold, 0. otherwise\n    return step(random_number, threshold); \n}\n\n\nfloat is_island( in float cell_hash )\n{\n    // The ~Expected Number~ of islands is N_ISLANDS\n    // However, RNGeezus might decide to give us fewer or more\n    // Note that this means the expected number within the domain bounded by domain dimension, \n    //. and again, more islands can be found in total, \n    //. because the domain leaks into the larger screen dimension.\n    float domain_size = float( DOMAIN_DIMENSION * DOMAIN_DIMENSION );\n    return random_number_to_expected_hit( hash1(ISLAND_SEED + cell_hash), domain_size, float( N_ISLANDS ) );\n}\n\n\nfloat smooth_d( in float v )\n{\n    return smoothstep( 0.003, 0.005, abs(v) );\n}\n\n\nvec3 island_color( in float v )\n{\n    vec3 color = vec3(0.);\n    color = mix(COLOR_SAND, COLOR_GRASS, step(0.45, v));\n    color = mix(color, COLOR_FOREST, step(0.65, v));\n    color = mix(color, COLOR_MOUNTAIN, step(0.95, v));\n    return color;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    // Fit a square coordinate space into the screen.\n    // On the smaller dimension, 0 is bottom/left, and 1 is top/right\n    // On the larger dimension coordinates go below 0, and above 1\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / min(iResolution.x, iResolution.y) + vec2(0.5);\n\t\n    // Scale the domain!\n    // Domain: bottom left = (0,0), top right = (DOMAIN_DIMENSION,DOMAIN_DIMENSION) \n    // Note: the above is true within the fitted square coordinate space!\n    //. it still leaks into the larger dimension!\n    vec4 closest_point = voronoi( float(DOMAIN_DIMENSION) * uv );\n    float distance_to_border = closest_point.w - closest_point.x; // F2-F1 distance\n    \n    // Pre-define to be more flexible with changes later\n    vec3 color = vec3(0.);\n\t\n    // Color by Cell Id - Is it an island?\n    float seed_id = closest_point.y + closest_point.z * 3.;\n    float jitter = hash1( hash1(fragCoord.x) + fragCoord.y ) * JITTER_INTENSITY;\n    vec3 island_color = island_color(distance_to_border + jitter);\n    color = mix(COLOR_WATER, island_color, step(0.5, is_island(seed_id)));\n    \n    // Add Voronoi Borders to clearly separate neighboring islands\n    float border_width = 0.5;\n    color = mix( COLOR_WATER, color, smoothstep( 0., border_width, distance_to_border ) );\n    \n    // Click the output window to show DEBUG info!\n    bool show_debug_info = iMouse.z > 0.;\n    if (iMouse.z > 0.)\n    {   \n        // Draw the Worley/Voronoi Grid\n        for( int i = 0; i <= DOMAIN_DIMENSION; i++ )\n        {\n            float cut = float(i) / float(DOMAIN_DIMENSION);\n            color *= smooth_d( uv.x - cut );\n            color *= smooth_d( uv.y - cut );\n        }\n        \n        // Draw Voronoi Seed Points\n        color -= vec3(1.0-smoothstep( 0.005, 0.01, closest_point.x));\n    }\n    \n    fragColor = vec4( color, 1.0 );\n}","name":"Image","description":"","type":"image"}]}