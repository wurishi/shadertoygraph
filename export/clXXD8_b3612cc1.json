{"ver":"0.1","info":{"id":"clXXD8","date":"1674647868","viewed":110,"name":"Normal Encoding error","username":"orca","description":"Visualize encoding/decoding error of normals (unit vectors) using OctQuad encoding.\nWe compare packing of normals in the G-Buffer as SNORM_16, SNORM_8, or HALF_16 (FP16)","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["normal","pack","unit","octquad","snorm16","half16","snorm8","fp16"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//#define SHOW_NORMAL\n#define SHOW_ERROR\n\n//#define PACK_SNORM16 // Maximum error is ~5e-8\n#define PACK_SNORM8 // Maximum error is ~4e-3\n//#define PACK_HALF16 // Maximum error is ~5e-5 NOT uniformly distributed over unit sphere\n\nprecision highp float;\n\n// Input in [-1.. +1]^2\n// Returns unit vector (AKA normal)\nvec3 OctQuad_decode(vec2 f)\n{\n    vec3 n = vec3(f.x, f.y, 1.0 - abs(f.x) - abs(f.y));\n    float t = clamp(-n.z, 0.0, 1.0);\n    n.xy += vec2(n.x >= 0.0 ? -t : t, n.y >= 0.0 ? -t : t);\n    return normalize(n);\n}\n\n// Input: unit vector (AKA normal)\n// Returns output in [-1.. +1]^2\nvec2 OctQuad_encode(vec3 n)\n{\n\t// http://jcgt.org/published/0003/02/01/paper.pdf\n\t// see also: com.unity.render-pipelines.core\\ShaderLibrary\\Packing.hlsl :: PackNormalOctQuadEncode()\t\n\tfloat l1norm = dot(abs(n), vec3(1.0, 1.0, 1.0));\n\tn /= l1norm;\n\tfloat t = clamp(-n.z, 0.0, 1.0);\n\tvec2 ret = n.xy;\n\tret.x += (n.x >= 0.0 ? t : -t);\n\tret.y += (n.y >= 0.0 ? t : -t);\n\treturn ret;\n}\n\n\n//v in [-1..1]^2\nvec2 pack_as_snorm16(vec2 v)\n{\n    float HALF = float(0x7FFF);\n    ivec2 snorm = ivec2(round(v * HALF));\n    return vec2(snorm) / HALF;\n}\n\n//v in [-1..1]^2\nvec2 pack_as_snorm8(vec2 v)\n{\n    float BYTE = float(0x7F);\n    ivec2 snorm = ivec2(round(v * BYTE));\n    return vec2(snorm) / BYTE;\n}\n\n//v in [-1..1]^2\nvec2 pack_as_half16(vec2 v)\n{\n    return unpackHalf2x16(packHalf2x16(v));\n}\n\n\nfloat calculate_encoding_error(vec3 normal) {\n\n    vec2 enc = OctQuad_encode(normal);\n    \n#if defined (PACK_SNORM16)\n    enc = pack_as_snorm16(enc);\n    float scale = 5e8;\n\n#elif defined (PACK_SNORM8)\n    enc = pack_as_snorm8(enc);\n    float scale = 4e3;\n    \n#elif defined (PACK_HALF16)\n    enc = pack_as_half16(enc);\n    float scale = 5e5;\n    \n#else \n    float scale = 2e13;\n#endif\n    \n    vec3 decoded = OctQuad_decode(enc);\n    vec3 delta = abs(decoded - normal); // For two unit vectors with a small angle θ between them: length(delta) ~= sin(θ)\n    float rmse = dot(delta, delta) * scale;    \n    return rmse;        \n}\n\n\n//https://www.shadertoy.com/view/MdXSD8 -> \n//Simplified version of https://www.shadertoy.com/view/lds3zn\n\n#define M_PI 3.1415926535\n\n//Object setup\nvec4 sph1 = vec4( 0.0, 0.0, 0.0, 1.0);\n//Functions \n\nfloat iSphere(in vec3 ro, in vec3 rd, in vec4 sph)\n{\n\t//sphere at origin has equation |xyz| = r\n\t//sp |xyz|^2 = r^2.\n\t//Since |xyz| = ro + t*rd (where t is the parameter to move along the ray),\n\t//we have ro^2 + 2*ro*rd*t + t^2 - r2. This is a quadratic equation, so:\n\tvec3 oc = ro - sph.xyz; //distance ray origin - sphere center\n\t\n\tfloat b = dot(oc, rd);\n\tfloat c = dot(oc, oc) - sph.w * sph.w; //sph.w is radius\n\tfloat h = b*b - c; //Commonly known as delta. The term a is 1 so is not included.\n\t\n\tfloat t;\n\tif(h < 0.0) \n\t\tt = -1.0;\n\telse\n\t\tt = (-b - sqrt(h)); //Again a = 1.\n\treturn t;\n}\n\n//Get sphere normal.\nvec3 nSphere(in vec3 pos, in vec4 sph )\n{\n\treturn (pos - sph.xyz)/sph.w;\n}\n\nfloat intersect(in vec3 ro, in vec3 rd, out float resT)\n{\n\tresT = 1000.0;\n\tfloat id = -1.0;\n\tfloat tsph = iSphere(ro, rd, sph1); //Intersect with a sphere.\n\t\n\tif(tsph > 0.0)\n\t{\n\t\tid = 1.0;\n\t}\n    resT = tsph;\n    \n\treturn id;\n}\n\nmat4 rotateX(float theta) {\n\tfloat cosTheta = cos(theta);\n\tfloat sinTheta = sin(theta);\n\treturn mat4(1.0, 0.0, 0.0, 0.0,\n\t\t\t\t0.0, cosTheta, -sinTheta, 0.0,\n\t\t\t\t0.0, sinTheta, cosTheta, 0.0,\n\t\t\t\t0.0, 0.0, 0.0, 1.0);\n}\nmat4 rotateY(float theta) {\n\tfloat cosTheta = cos(theta);\n\tfloat sinTheta = sin(theta);\n\treturn mat4(cosTheta, 0.0, sinTheta, 0.0,\n\t\t\t\t0.0, 1.0, 0.0, 0.0,\n\t\t\t\t-sinTheta, 0.0, cosTheta, 0.0,\n\t\t\t\t0.0, 0.0, 0.0, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat aspectRatio = iResolution.x/iResolution.y;\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tvec2 mouse0To2PI = iMouse.xy/iResolution.xy*2.0*M_PI;\n\t\t\n\tmat4 rotY = rotateY(mouse0To2PI.x);\n\tmat4 rotX = rotateX(mouse0To2PI.y );\n    mat4 matrix = rotX * rotY;\n    \n\t//generate a ray with origin ro and direction rd\n\tvec4 ro = vec4(0.0, 0.0, 1.5, 1.0);\n\tvec3 rd = normalize(vec3( (-1.0+2.0*uv) * vec2(aspectRatio, 1.0), -1.0));\n\n\t//intersect the ray with scene\n\tfloat t;\n\tfloat id = intersect(ro.xyz, rd, t);\n\t\n\tvec3 col = vec3(0.5); \n    \n\tif(id > 0.5 && id < 1.5) //If we hit the sphere\n\t{\n\t\tvec3 pos = ro.xyz + t*rd;\n\t\tvec3 normal = nSphere(pos, sph1);\n        \n        normal = normalize((vec4(normal, 1.0) * matrix).xyz);\n#if defined(SHOW_NORMAL)\n        col = normal;\n#elif defined(SHOW_ERROR)\n        float error = calculate_encoding_error(normal);\n        col = vec3(error);\n#endif      \n\t}\n\telse // background: show color of normal at closest sphere edge\n    {\n        vec3 pos = ro.xyz + rd;\n\t\tvec3 nor = nSphere(pos, sph1);\n        nor = normalize((vec4(nor, 1.0) * matrix).xyz);\n        col = nor;\n    }\n\tfragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}