{"ver":"0.1","info":{"id":"XsdGRj","date":"1450878305","viewed":214,"name":"Shape vumeter","username":"gigatron","description":"shape function is imported from glslsandbox .. mixed French Flag ...\nOk shader mixing demo.. so on computer the posibility is 2e65536 combination i think now ! . the next generation of computer is Quantum temporal multi-vec .. 2e(65536*16384); ","likes":1,"published":1,"flags":64,"usePreview":0,"tags":["shape","vumeter"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdXGzn","filepath":"/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","previewfilepath":"/media/ap/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"MdlGzH","filepath":"https://soundcloud.com/user-115435970/unreal2","previewfilepath":"https://soundcloud.com/user-115435970/unreal2","type":"musicstream","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[],"code":"#define PI (3.14159265358979323)\nfloat rand (in vec2 uv) { return fract(sin(dot(uv,vec2(12.4124,48.4124)))*48512.41241); }\nconst vec2 O = vec2(0.,1.);\nfloat noise (in vec2 uv) {\n\tvec2 b = floor(uv);\n\treturn mix(mix(rand(b),rand(b+O.yx),.5),mix(rand(b+O),rand(b+O.yy),.5),.5);\n}\n\n#define DIR_RIGHT -1.\n#define DIR_LEFT 1.\n#define DIRECTION DIR_LEFT\n\n#define LAYERS 8\n#define SPEED 60.\n#define SIZE 5.\n\n\nfloat dfSemiArc(float rma, float rmi, vec2 uv)\n{\n\treturn max(abs(length(uv) - rma) - rmi, uv.x-0.0);\n}\n\nfloat dfSemiArc2(float rma, float rmi, vec2 uv)\n{\n\treturn min(abs(length(uv) - rma) - rmi, uv.x+4.0);\n}\n\n\n\nfloat dfQuad(vec2 p0, vec2 p1, vec2 p2, vec2 p3, vec2 uv)\n{\n\tvec2 s0n = normalize((p1 - p0).yx * vec2(-1,1));\n\tvec2 s1n = normalize((p2 - p1).yx * vec2(-1,1));\n\tvec2 s2n = normalize((p3 - p2).yx * vec2(-1,1));\n\tvec2 s3n = normalize((p0 - p3).yx * vec2(-1,1));\n\t\n\treturn max(max(dot(uv-p0,s0n),dot(uv-p1,s1n)), max(dot(uv-p2,s2n),dot(uv-p3,s3n)));\n}\n\nfloat dfRect(vec2 size, vec2 uv)\n{\n\treturn max(max(-uv.x,uv.x - size.x),max(-uv.y,uv.y - size.t));\n}\n\n//--- Letters ---\nvoid G(inout float df, vec2 uv)\n{\n\t\n\tdf = min(df, dfSemiArc(0.5, 0.125, uv));\n\tdf = min(df, dfQuad(vec2(0.000, 0.375), vec2(0.000, 0.625), vec2(0.250, 0.625), vec2(0.25, 0.375), uv));\n\tdf = min(df, dfRect(vec2(0.250, 0.50), uv - vec2(0.0,-0.625)));\n\tdf = min(df, dfQuad(vec2(-0.250,-0.125), vec2(-0.125,0.125), vec2(0.250,0.125), vec2(0.250,-0.125), uv));\t\n}\n\nvoid I(inout float df, vec2 uv)\n{\n\tdf = min(df, dfRect(vec2(0.200, 1.25), uv - vec2(-0.280,-0.625)));\n    df = min(df, dfRect(vec2(0.550, 0.25), uv - vec2(-0.45,0.40)));\n    df = min(df, dfRect(vec2(0.550, 0.25), uv - vec2(-0.45,-0.625)));\n}\n\n//\n\nvoid A(inout float df, vec2 uv)\n{\n\tdf = min(df, dfRect(vec2(0.200, 1.25), uv - vec2(-0.550,-0.625)));\n    df = min(df, dfRect(vec2(0.200, 1.25), uv - vec2(-0.1,-0.625)));\n    df = min(df, dfRect(vec2(0.550, 0.25), uv - vec2(-0.50,0.38)));\n    df = min(df, dfRect(vec2(0.550, 0.25), uv - vec2(-0.50,-0.20)));\n   \n}\n\n\nvoid T(inout float df, vec2 uv)\n{\n\tdf = min(df, dfRect(vec2(0.200, 1.25), uv - vec2(-0.550,-0.625)));\n    df = min(df, dfRect(vec2(0.700, 0.25), uv - vec2(-0.8,0.38)));\n    \n \n   \n}\n\nvoid R(inout float df, vec2 uv)\n{\n\tdf = min(df, dfRect(vec2(0.200, 1.25), uv - vec2(-1.0,-0.625)));\n    df = min(df, dfRect(vec2(0.550, 0.25), uv - vec2(-0.95,0.38)));\n   df = min(df, dfRect(vec2(0.200, 0.60), uv - vec2(-0.600,-0.10)));\n    df = min(df, dfRect(vec2(0.450, 0.25), uv - vec2(-0.95,-0.10)));\n    \n  //  df = min(df, dfRect(vec2(0.450, 0.25), uv - vec2(-0.80,-0.10)));\n\n   df = min(df, dfQuad(vec2(-0.900,-0.100), vec2(-0.600,-0.100), vec2(-0.350,-0.625), vec2(-0.550,-0.625), uv));\n   \n   \n}\n\nvoid OO(inout float df, vec2 uv)\n{\n\tdf = min(df, dfRect(vec2(0.200, 1.25), uv - vec2(-1.20,-0.625)));\n    df = min(df, dfRect(vec2(0.200, 1.25), uv - vec2(-0.750,-0.625)));\n    df = min(df, dfRect(vec2(0.550, 0.25), uv - vec2(-1.10,0.38)));\n    df = min(df, dfRect(vec2(0.550, 0.25), uv - vec2(-1.10,-0.625)));\n   \n}\n\nvoid N(inout float df, vec2 uv)\n{\n\tdf = min(df, dfRect(vec2(0.200, 1.25), uv - vec2(-1.30,-0.625)));\n    df = min(df, dfRect(vec2(0.200, 1.25), uv - vec2(-0.650,-0.625)));\n   df = min(df, dfQuad(vec2( -1.300,.625), vec2(-1.000,0.625), vec2(-0.450,-0.625), vec2(-0.650,-0.625), uv));\n}\n\n\n\n\n\nvoid S(inout float df, vec2 uv)\n{\n\tdf = min(df, dfSemiArc(0.25, 0.125, uv - vec2(-0.250,0.250)));\n\tdf = min(df, dfSemiArc(0.25, 0.125, (uv - vec2(-0.125,-0.25)) * vec2(-1)));\n\tdf = min(df, dfRect(vec2(0.125, 0.250), uv - vec2(-0.250,-0.125)));\n\tdf = min(df, dfQuad(vec2(-0.625,-0.625), vec2(-0.500,-0.375), vec2(-0.125,-0.375), vec2(-0.125,-0.625), uv));\t\n\tdf = min(df, dfQuad(vec2(-0.250,0.375), vec2(-0.250,0.625), vec2(0.250,0.625), vec2(0.125,0.375), uv));\n}\n//---------------\n\n//--- From e#26829.0 ---\nfloat linstep(float x0, float x1, float xn)\n{\n\treturn (xn - x0) / (x1 - x0);\n}\n \n\n\n\nvec3 hsv(float h,float s,float v) {\n\treturn mix(vec3(1.),clamp((abs(fract(h+vec3(3.,2.,1.)/3.)*6.-3.)-1.),0.,1.),s)*v;\n}\n\n// s is for scale, r is for rotation// supershape from glslsandbox !\nfloat supershape(vec2 p, float m, float n1, float n2, float n3, float a, float b, float s, float r) {\n\tfloat ang = atan(p.y * iResolution.y, p.x * iResolution.x) + r;\n\tfloat v = pow(pow(abs(cos(m * ang / 4.0) / a), n2) + pow(abs(sin(m * ang / 4.0) / b), n3), -1.0 / n1);\n\treturn 1. - step(v * s * iResolution.y, length(p * iResolution.xy)); \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p=(fragCoord.xy/iResolution.xy)-.5;\n    \n    float time=iTime;\n    \n    float snd=texture(iChannel0,p/1000.).x;\n    vec4 color=vec4(0.2);\n    color += supershape(p - vec2(0.0, 0), 8.0, 1.0, 8.0, 4.0, 1.0, 1.0, 0.01+snd/8., sin(time));\n    // include texture ... computer code no limit !\n    color *= 0.8-texture(iChannel1,p+time*0.2);\n    \n    \n    vec3 c = vec3(1.0, 0.0, 0.);\n\tif(p.x < -0.166)\n\t\tc = vec3(0, 0.0, 0.874);\n\telse if(p.x > -0.50 && p.x < 0.166) \n\t\tc = vec3(1.0, 1.0, 1.0);\n        \n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv=p;\n    \n    float stars = 0.;\n\tfloat fl, s;\n\tfor (int layer = 0; layer < LAYERS; layer++) {\n\t\tfl = float(layer);\n\t\ts = (400.-fl*20.);\n\t\tstars += step(.1,pow(noise(mod(vec2(uv.x*s + iTime*SPEED*DIRECTION - fl*100.,uv.y*s),iResolution.x)),18.)) * (fl/float(LAYERS));\n\t}        \n        \n  // logo !\n    float t=time*2.0;\n    float bf=1.4;\n\tuv = (uv - uv/2.0)*16.0*abs(sin(t*0.2+bf/12.));\n\n\tfloat dist = 1e6;\n\t\n\tfloat charSpace = 1.025;\n\t\n\tvec2 chuv = uv;\n\tchuv.x += charSpace * 3.0;\n    \n    G(dist, chuv-vec2(-0.0,abs(sin(t*2.+bf/6.)))); chuv.x -= charSpace;\n    \n    I(dist, chuv-vec2(0.0,abs(sin(t*2.+bf/6.*2.0)))); chuv.x -= charSpace;\n    G(dist, chuv-vec2(0.0,abs(sin(t*2.+bf/6.*3.0)))); chuv.x -= charSpace;\n    A(dist, chuv-vec2(0.0,abs(sin(t*2.+bf/6.*4.0)))); chuv.x -= charSpace;\n    T(dist, chuv-vec2(0.0,abs(sin(t*2.+bf/6.*5.0)))); chuv.x -= charSpace;\n    R(dist, chuv-vec2(0.0,abs(sin(t*2.+bf/6.*6.0)))); chuv.x -= charSpace;\n    OO(dist, chuv-vec2(0.0,abs(sin(t*2.+bf/6.*7.0)))); chuv.x -= charSpace;\n    \n\tN(dist, chuv-vec2(0.0,abs(sin(t*2.+bf/6.*8.0)))); chuv.x -= charSpace;\n\n\t\n\tfloat mask = smoothstep(8.0/iResolution.y,0.008,dist);\n    \n       \n    \n    \n        vec3 textcol =  vec3(.2);\n    \t  \n    \n    \t fragColor = vec4(-1.+color);\n         if(s>0.00)fragColor += 2.*vec4( vec3(stars), 1.0 );\n\t\t fragColor += vec4(c,1.0);\n         fragColor += vec4(2.*textcol*mask,1.0);\n    // and you have a nice demo with mixing glsl.. so we can mix all shadertoy's  !!\n}","name":"","description":"","type":"image"}]}