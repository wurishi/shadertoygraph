{"ver":"0.1","info":{"id":"ttlGWl","date":"1558101767","viewed":136,"name":"Helicoid_Test","username":"Ecter","description":"Helicoid ray tracing attempt, using bisection method given the equation, had to do make the bisection a quad-section in order to get it to properly trace from the top.   Does any one else know how I can raytrace a helicoid better? use WASD + UDLR","likes":1,"published":1,"flags":48,"usePreview":0,"tags":["raytracing","shape","bisection","helicoid"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define STATE_CHANNEL iChannel0\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    Sphere sphere = Sphere(vec3(0.0,0.0,10.0), 1.0);\n    vec4 cyl_quaternion = quaternion(0.0,0.0,0.0);\n    //cyl_quaternion = quaternion();\n    Cylinder cylinder = Cylinder(vec3(0.0, -1.0, 0.0), 2.0, 2.0, \n                                 cyl_quaternion);\n    \n    Helicoid helicoid = Helicoid(vec3(0.0, -1.0, 0.0),\n                                 8.0, 1.0, \n                                 0.5,\n                                 quaternion(vec3(0.0, 1.0, 0.0)));\n    float fov = radians(45.0);\n     \n    CameraState camera_state = getCameraState(STATE_CHANNEL);//CameraState(vec3(0.0), vec3(0.0,0.0,1.0));\n    \n    ScreenRay ray = getRay(fragCoord, iResolution, camera_state, fov);\n    \n    vec3 intersection_point;\n    vec3 normal;\n    float distance_to_sphere_end;\n    float distance_to_sphere;\n    bool inside_sphere;\n    //ray.origin.y = -1.0;\n    float speed = 0.0;\n    float dist = 10.0;\n    //ray.origin.x = cos(speed*iTime)*dist;\n    //ray.origin.z = sin(speed*iTime)*dist;\n    //ray.direction = rotVecZ(ray.direction,1.0);\n    //ray.direction = rotVecY(ray.direction,-speed*iTime -(pi/2.0));\n    //ray.direction = rotVecZ(ray.direction,0.04);\n    \n    bool self_shadow = false;\n    float shadow_value;\n    IntersectionDistance intersection_distance;\n    fragColor = vec4(1.0);\n   if(rayIntersection(ray, \n                      helicoid, \n                      intersection_distance,\n                      normal, \n                      self_shadow,\n                      iTime,\n                      shadow_value)){\n        fragColor = vec4(1.0);\n       //fragColor.rgb *= fogify(intersection_distance.to_object);\n\n       if(self_shadow){\n           fragColor.rgb *= 0.0;\n       }\n       else{\n           fragColor.rgb *= shadow_value;\n       }\n\n    }/*\n    else if(rayIntersection(ray, \n                            cylinder, \n                            intersection_distance,\n                            normal)){\n        \n        //fragColor = vec4(1.0);\n        fragColor.rgb *= fogify(intersection_distance.to_object);\n    }*/\n    else if(rayIntersection(ray, sphere, \n                             intersection_distance,\n                             normal)){\n       fragColor = vec4(1.0); \n    }\n    else{\n        // Normalized pixel coordinates (from 0 to 1)\n        vec2 uv = fragCoord/iResolution.xy;\n\n        // Time varying pixel color\n        vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n        // Output to screen\n        fragColor = vec4(col,1.0);\n    }\n\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define const\n//IO \nconst ivec2 position_index = ivec2(0, 10);\nconst ivec2 rotation_index = ivec2(0, 20);\nconst ivec2 resolution_index = ivec2(0, 30);\n\nvec4 loadValue(in sampler2D iChannel, in ivec2 value_index ){\n    return texelFetch( iChannel, value_index, 0 );\n}\n\nvoid storeValue( in ivec2 value_index, in vec4 value, \n                inout vec4 fragColor, in ivec2 ifragCoord ){\n    fragColor = ( value_index == ifragCoord.xy ) ? value : fragColor;\n}\n\nfloat getKeyState(in sampler2D iChannel, int key_id){\n    return texelFetch( iChannel, ivec2(key_id,0),0 ).x;\n}\n\nfloat getKeyPress(in sampler2D iChannel, int key_id){\n    return texelFetch( iChannel, ivec2(key_id,1),0 ).x;\n}\n\nfloat getKeyToggle(in sampler2D iChannel, int key_id){\n    return texelFetch( iChannel, ivec2(key_id,2),0 ).x;\n}\n\nvec3 getOrigin(in sampler2D iChannel){\n    return vec3(0.0, 0.0, 0.0) + loadValue(iChannel, position_index).xyz;\n}\n\nvec3 getRotation(in sampler2D iChannel){\n    return vec3(0.0, 0.0, 0.0) + loadValue(iChannel, rotation_index).xyz;\n}\n\nstruct CameraState{\n    vec3 origin;\n    vec3 rotation;\n};\n\nCameraState getCameraState(in sampler2D iChannel){\n    vec3 origin = getOrigin(iChannel);\n    vec3 rotation = getRotation(iChannel);\n    return CameraState(origin, rotation);\n}\n\n\n//MATH CONSTANTS\nconst float pi \t= 3.1415926535897932384626433832795;\nconst float tau = 6.2831853071795864769252867665590;\nconst float eta = 1.5707963267948966192313216916397;\nconst float sqrt3 = 1.7320508075688772935274463415059;\nconst float sqrt2 = 1.4142135623730950488016887242096;\nconst float lte1 =  0.9999999999999999999999999999999;\nconst float inf = uintBitsToFloat(0x7F800000u);\n\n\n#define saturate(x) clamp(x,0.0,1.0)\n#define norm01(x) ((x + 1.0) / 2.0)\n\nvec3 rotVecX(in vec3 vector, in float theta){\n    mat3 rotmat = mat3(1, 0, 0,\n                       0, cos(theta), -sin(theta),\n                       0, sin(theta), cos(theta));\n    return vector * rotmat;\n}\n\nvec3 rotVecY(in vec3 vector, in float theta){\n    mat3 rotmat = mat3(cos(theta), 0, sin(theta),\n                       0, 1, 0,\n                       -sin(theta), 0, cos(theta));\n    return vector * rotmat;\n}\nvec3 rotVecZ(in vec3 vector, in float theta){\n    mat3 rotmat = mat3(cos(theta), -sin(theta), 0, \n                       sin(theta), cos(theta), 0,\n                       0, 0, 1);\n    return vector * rotmat;\n}\n\n\nvec2 calcSignNormalizedUV(in vec2 fragCoord, in vec3 resolution){\n    vec2 uv = fragCoord/resolution.xy;\n    uv = (2.0 * uv) - 1.0;\n    return uv;\n}\n\nvec3 calculateFragementRay(in vec2 fragCoord, in vec3 resolution, in float fov){\n    vec2 uv = fragCoord / resolution.xy;\n    uv.x = (uv.x * 2.0) - 1.0;\n    uv.y = (2.0 * uv.y) - 1.0;\n    if(resolution.x >= resolution.y){\n        uv.x *= resolution.x/resolution.y;\n    }else{\n        uv.y *= resolution.y/resolution.x;\n    }\n    float tan_fov = tan(fov/2.0);\n    vec2 pxy = uv * tan_fov;\n    vec3 ray_dir = normalize(vec3(pxy, 1));\n    return ray_dir;\n}\n\nvec3 getRotatedRayDirection(vec3 ray_dir, in vec3 rotation){\n    // Normalized pixel coordinates (from -1 to 1)\n    //vec3 ray_dir = calculateFragementRay(fragCoord, resolution);\n    ray_dir = rotVecX(ray_dir, rotation.x);\n    ray_dir = rotVecY(ray_dir, rotation.y);\n    return ray_dir;\n}\n\n//could use dot product between two vectors to get cos, and use half angle identities\nvec4 quaternion(const in vec3 axis, const in float angle){\n    float half_angle = angle/2.0;\n    return vec4(axis * sin(half_angle), cos(half_angle));\n}\n\nvec4 quaternion(){\n    return vec4(0.0);\n}\n\n\nvec4 quaternion(const in vec3 axis){\n    return vec4(axis, 0.0);\n}\n\nvec4 conjugate(const in vec4 quaternion){\n    return vec4(-quaternion.xyz, quaternion.w);\n}\n\nvec4 inverseQuaternion(const in vec4 quaternion){\n    float norm_denom = length(quaternion);\n    return conjugate(quaternion) / norm_denom;\n}\n\n//https://www.youtube.com/watch?v=CRiR2eY5R_s&list=PLW3Zl3wyJwWOpdhYedlD-yCB7WQoHf-My&index=34\n//not communitive\n//note first rotation should go last\n\nvec4 multiply(const in vec4 q0, const in vec4 q1){\n    //r = 0, s = 1\n    float w = (q0.w * q1.w) + dot(q0.xyz, q1.xyz);                     \n    vec3 v = (q1.w * q0.xyz) + (q0.w * q1.xyz) + cross(q0.xyz, q1.xyz);\n    return vec4(v, w);\n}\n\n\n\nvec4 combineRotations(const in vec4 q0, const in vec4 q1){\n    //doing last rotation first. \n    return multiply(q1, q0);\n}\n\n//https://www.geeks3d.com/20141201/how-to-rotate-a-vertex-by-a-quaternion-in-glsl/\n#define QUAT_ROTATE_FAST 1\nvec3 rotate(const in vec3 v, const in vec4 quaternion){\n    #if QUAT_ROTATE_FAST\n    return v + 2.0*cross(quaternion.xyz, cross(quaternion.xyz,v) + quaternion.w*v);\n    #else\n    return v*(quaternion.w*quaternion.w - dot(quaternion.xyz,quaternion.xyz)) \n        + 2.0*quaternion.xyz*dot(quaternion.xyz,v) \n        + 2.0*quaternion.w*cross(quaternion.xyz,v);\n    #endif\n}\n\nvec3 rotate_vertex_position(vec3 position, vec3 axis, float angle)\n{ \n  vec4 qr = quaternion(axis, angle);\n  vec4 qr_conj = conjugate(qr);\n  vec4 q_pos = vec4(position.x, position.y, position.z, 0);\n  \n  vec4 q_tmp = multiply(qr, q_pos);\n  qr = multiply(q_tmp, qr_conj);\n  \n  return vec3(qr.x, qr.y, qr.z);\n}\n\nvec4 quaternion(const in float yaw, \n                const in float pitch, \n                const in float roll){\n    vec4 quat_yaw = normalize(quaternion(vec3(0,1,0), yaw));\n    vec4 quat_pitch = normalize(quaternion(vec3(1,0,0), pitch));\n    vec4 quat_roll = normalize(quaternion(vec3(0,0,1), roll));\n    vec4 test0 = multiply(quat_roll, quat_yaw);\n    vec4 test1 = multiply(quat_yaw, quat_roll);\n    return multiply(  test0, quat_pitch);\n    //return combineRotations(quat_yaw, combineRotations(quat_pitch, quat_roll));\n}\n\nvec4 quaternion_reverse(const in float yaw, \n                        const in float pitch, \n                        const in float roll){\n    vec4 quat_yaw = quaternion(vec3(0,1,0), yaw);\n    vec4 quat_pitch = quaternion(vec3(1,0,0), pitch);\n    vec4 quat_roll = quaternion(vec3(0,0,1), roll);\n    return multiply(quat_roll, multiply(quat_pitch, quat_yaw));\n    //return combineRotations(quat_roll, combineRotations(quat_pitch, quat_yaw));\n}\n\nstruct Ray{\n    vec3 origin;\n    vec3 direction;\n};\n\nstruct ScreenRay{\n    vec3 origin;\n    vec3 direction;\n    float cosA;\n};\n    \n    \nRay ScreenRayToRay(in ScreenRay screen_ray){\n    return Ray(screen_ray.origin, screen_ray.direction);\n}\n\nvec3 calcRayEndpoint(in Ray ray, in float depth){\n    return ray.origin + (ray.direction * depth);\n}\n\nvec3 calcRayEndpoint(in ScreenRay ray, in float depth){\n    return ray.origin + (ray.direction * depth);\n}\n\nScreenRay moveRayOrigin(in ScreenRay ray, const in float depth){\n    ray.origin += (ray.direction * depth);\n    return ray;\n}\n\nRay calcRayToVec(const in vec3 origin, \n                 const in vec3 destination){\n    vec3 direction = normalize(destination - origin);\n    return Ray(origin, direction);\n}\n\nRay calcRayToVec(const in Ray ray, \n                 const in vec3 destination){\n    vec3 direction = normalize(destination - ray.origin);\n    return Ray(ray.origin, direction);\n}\n\n\nScreenRay getRay(const in vec2 fragCoord, \n                 const in vec3 resolution, \n                 const in CameraState camera_state,\n                 const in float fov){\n\n    vec3 ray_dir = calculateFragementRay(fragCoord, resolution, fov);\n    vec3 rot_ray_dir = getRotatedRayDirection(ray_dir, camera_state.rotation);\n    vec3 ray_origin = camera_state.origin;\n    float cosA = ray_dir.z;\n    return ScreenRay(ray_origin, rot_ray_dir, cosA);\n}\n\nfloat fogify(in float dist){\n    return  1.0/ (1.0 + dist*dist * 0.1);\n}\n\n\nstruct Sphere{\n    vec3 origin;\n    float radius;\n};\n\n    \n    \nstruct Cylinder{\n    //origin = bottom\n    vec3 origin;\n    float height;\n    float radius;\n    vec4 quaternion;\n};\n\nstruct Helicoid{\n    vec3 origin;\n    float height;\n    float radius;\n    float twist;\n    vec4 quaternion;\n};\n\n    /*\nvec3 calcOrientation(const in Helicoid helicoid){\n    return (helicoid.top - helicoid.bottom) / length(helicoid.top - helicoid.bottom);\n}\n*/\n\nCylinder toCylinder(const in Helicoid helicoid){\n    return Cylinder(helicoid.origin, helicoid.height, helicoid.radius, helicoid.quaternion);\n}\n \n#define USE_FAST_QUADRATIC 0\n\n//post: t0 < t1\nbool solveQuadratic(const in float a, \n                    const in float b,\n                    const in float c,\n                    out float t0,\n                    out float t1){\n    float x0, x1;\n    float discriminant = b*b - (4.0 * a * c);\n    //if sqrt(discriminant) will be imaginary\n    if(discriminant < 0.0){\n        return false;\n    }else if (discriminant == 0.0){\n        x0 = -b/(2.0 * a);\n        x1 = -b/(2.0 * a);\n    }else{\n        #if USE_FAST_QUADRATIC\n        //faster quadratic definition\n        x0 = (-b + sqrt(discriminant)) / (2.0 * a);\n        x1 = (-b - sqrt(discriminant)) / (2.0 * a);\n        #else\n        //numerically stable definition \n        //source https://www.scratchapixel.com/lessons/3d-basic-rendering/minimal-ray-tracer-rendering-simple-shapes/ray-sphere-intersection\n        float q = (b > 0.0) ? ((-b + sqrt(discriminant))/2.0) :\n                            ((-b - sqrt(discriminant))/2.0);\n        x0 = q / a;\n        x1 = c / q;  \n        #endif\n    }\n    if(x0 > x1){\n        //swap\n        t0 = x1;\n        t1 = x0;\n    } else {\n        t0 = x0;\n        t1 = x1;\n    }\n    return true;\n}\n\nstruct IntersectionDistance{\n    float to_end;\n    float to_object;\n};\n\nbool isInside(const in IntersectionDistance intersection_distance){\n\treturn intersection_distance.to_object == 0.0;\n}\n\nvec3 objectIntersection(const in IntersectionDistance intersection_distance,\n                        const in ScreenRay ray){\n    return calcRayEndpoint(ray, intersection_distance.to_object);\n}\n\nvec3 endIntersection(const in IntersectionDistance intersection_distance,\n                        const in ScreenRay ray){\n    return calcRayEndpoint(ray, intersection_distance.to_end);\n}\n\nbool checkOrder(const in IntersectionDistance intersection_distance){\n    return intersection_distance.to_object <= intersection_distance.to_end;\n}\n\nbool distanceBehind(const in IntersectionDistance intersection_distance){\n    return intersection_distance.to_object < 0.0;\n}\n\nvec3 shapeNormal(const in Sphere sphere, const vec3 intersection_point){\n    vec3 normal = normalize(intersection_point - sphere.origin);\n    return normal;\n}\n\nbool rayIntersection(const in ScreenRay ray,\n                     const in Sphere sphere,\n                     out IntersectionDistance intersection_distance,\n                     out vec3 normal){\n    float t0, t1;\n    vec3 L = ray.origin - sphere.origin;\n    float a = dot(ray.direction, ray.direction);\n    float b = 2.0 * dot(L, ray.direction);\n    float c = dot(L,L) - sphere.radius*sphere.radius;\n    if(!solveQuadratic(a,b,c,t0,t1)){\n        return false;\n    }\n    intersection_distance.to_end = t1;\n    if(t0 < 0.0){\n        intersection_distance.to_object = 0.0;\n        t0 = t1;\n        //both are negative\n        if(t0 < 0.0){\n            return false;\n        }\n    }else{\n        intersection_distance.to_object = t0;\n    }\n\treturn true;\n}\n\n//https://www.cl.cam.ac.uk/teaching/1999/AGraphHCI/SMAG/node2.html\nbool rayIntersection(const in ScreenRay ray,\n                     const in Cylinder cylinder,\n                     out IntersectionDistance intersection_distance,\n                     out vec3 normal){\n    float t0, t1;\n    ScreenRay offset_ray = ray;\n    offset_ray.origin -= cylinder.origin;\n    offset_ray.origin = rotate(offset_ray.origin, cylinder.quaternion);\n    offset_ray.direction = rotate(offset_ray.direction, cylinder.quaternion);\n    \n    float a = (offset_ray.direction.x*offset_ray.direction.x) + (offset_ray.direction.z*offset_ray.direction.z);\n    float b = 2.0 * ((offset_ray.origin.x*offset_ray.direction.x) + (offset_ray.origin.z*offset_ray.direction.z));\n    float c = (offset_ray.origin.x*offset_ray.origin.x) + (offset_ray.origin.z*offset_ray.origin.z) - cylinder.radius;\n\n    if(!solveQuadratic(a,b,c,t0,t1)){\n        return false;\n    }\n    \n    intersection_distance.to_end = t1;\n    if(t0 < 0.0){\n        //both are negative\n        if(t1 < 0.0){\n            return false;\n        }\n        t0 = 0.0;\n    }else{\n        intersection_distance.to_object = t0;\n    }\n    \n    vec3 p0 = calcRayEndpoint(offset_ray, t0);\n    vec3 p1 = calcRayEndpoint(offset_ray, t1);\n        \n    float t2 = -1.0;\n    float t3 = -1.0;\n    bool t0_above_bottom = p0.y >= 0.0;\n    bool t0_below_bottom = !t0_above_bottom;\n    \n    bool t1_above_bottom = p1.y >= 0.0;\n    bool t1_below_bottom = !t1_above_bottom;\n    \n    bool t0_below_top = p0.y <= cylinder.height;\n    bool t0_above_top = !t0_below_top;\n    \n    bool t1_below_top = p1.y <= cylinder.height;\n    bool t1_above_top = !t1_below_top;\n    \n    \n    if((t0_above_top && t1_above_top) \n       || (t0_below_bottom && t1_below_bottom)){\n        return false;\n    }\n    \n    if((t0_below_bottom && t1_above_bottom) \n       || (t0_above_bottom && t1_below_bottom)){\n        t2 = (0.0 - offset_ray.origin.y) / offset_ray.direction.y;\n    }\n\n    if((t0_below_top && t1_above_top) \n       || (t0_above_top && t1_below_top)){\n        t3 = (cylinder.height - offset_ray.origin.y) / offset_ray.direction.y;\n    }\n        \n    if(t2 > t3){\n        float temp = t3;\n        t3 = t2;\n        t2 = temp;\n    }\n\n    //if only one, then t3 is going to be more than zero\n    //if neither, no need to check the other. \n    if(t3 >= 0.0){\n        if(t2 >= 0.0){\n            t0 = t2;\n            t1 = t3;\n        }else{\n            bool t0_inside = t0_above_bottom && t0_below_top;\n            if(t0_inside){\n                t1 = t3;\n            }else{\n                //we know t1 has to be inside, \n                //otherwise we would have crossed through both lids\n                t0 = t3;\n            }\n        }\n    }\n    intersection_distance.to_object = t0;\n    intersection_distance.to_end = t1;\n    return true;\n}\n\n\n#define use_helicoid_function_plane 0\nfloat shapeFunction(const in Helicoid helicoid, in vec3 endpoint){\n    #if use_helicoid_function_plane\n    //use definition based on rotating plane\n    vec3 n = vec3(cos(helicoid.twist * endpoint.y), 0.0, sin(helicoid.twist * endpoint.y));\n    return dot(endpoint, n);\n    #else\n    //normal definition\n    return cos((atan(1.0* endpoint.z,1.0*endpoint.x)- helicoid.twist*endpoint.y));\n    #endif\n}\n\nvec3 gradientFunction(const in Helicoid helicoid, in vec3 endpoint){\n    //x = r*cos(theta)\n    //y = (1.0/twist)*theta\n    //z = r*sin(theta)\n    float d_x = (endpoint.z*sin(helicoid.twist*endpoint.y - atan(endpoint.z, endpoint.x)))\n        \t\t/ (endpoint.x*endpoint.x + endpoint.z*endpoint.z);\n    float d_y = -helicoid.twist*sin(helicoid.twist*endpoint.y - atan(endpoint.z, endpoint.x));\n    float d_z = (-endpoint.x*sin(helicoid.twist*endpoint.y - atan(endpoint.z, endpoint.x)))\n        \t\t/ (endpoint.x*endpoint.x + endpoint.z*endpoint.z);\n    vec3 d_xyz = vec3(d_x,d_y,d_z);\n    d_xyz = normalize(d_xyz);\n    return d_xyz;\n}\n\n//https://www.mrl.nyu.edu/~dzorin/rendering/lectures/lecture3/lecture3.pdf\nbool rayIntersection(in ScreenRay ray,\n                     const in Helicoid helicoid,\n                     out IntersectionDistance intersection_distance,\n                     out vec3 normal,\n                     out bool self_shadow,\n                     in float itime,\n                     out float shadow_value){\n    ScreenRay offset_ray = ray;\n    offset_ray.origin -= helicoid.origin;\n    offset_ray.origin = rotate(offset_ray.origin, helicoid.quaternion);\n    offset_ray.direction = rotate(offset_ray.direction, helicoid.quaternion);\n    \n    self_shadow = false;\n\tIntersectionDistance bound_intersection_distance;\n    vec3 temp_normal;\n    Cylinder bounding_cylinder = toCylinder(helicoid);\n    bounding_cylinder.quaternion = quaternion();\n    bounding_cylinder.origin = vec3(0.0);\n    if(!rayIntersection(offset_ray, \n                        bounding_cylinder,  \n                        bound_intersection_distance,\n                        temp_normal)){\n        return false;\n    }\n\n    float short_t = bound_intersection_distance.to_object;\n    float far_t = bound_intersection_distance.to_end;\n    float delta_t = far_t - short_t;\n    float mid_t0 = short_t + (1.0 * delta_t) / 4.0;\n    float mid_t1 = short_t + (2.0 * delta_t) / 4.0;\n    float mid_t2 = short_t + (3.0 * delta_t) / 4.0;\n    bool root_exists = false;\n    float epsilon = 0.00000;\n    float epsilon2 = 0.000001;\n    float t_mid_s0 = shapeFunction(helicoid, calcRayEndpoint(offset_ray, mid_t0));\n    float t_mid_s1 = shapeFunction(helicoid, calcRayEndpoint(offset_ray, mid_t1));\n    float t_mid_s2 = shapeFunction(helicoid, calcRayEndpoint(offset_ray, mid_t2));\n    float t_far_s = shapeFunction(helicoid, calcRayEndpoint(offset_ray, far_t));\n    float t_short_s = shapeFunction(helicoid, calcRayEndpoint(offset_ray, short_t));\n    if((t_short_s * t_far_s) > epsilon){\n        //return false; //fails to help on top down. \n    }\n    for(int i = 0; i < 10; ++i){\n        \n\n        if((t_mid_s0 * t_short_s) <= epsilon2){\n            far_t = mid_t0;\n            t_far_s = t_mid_s0;\n        }else if((t_mid_s1 * t_mid_s0) <= epsilon2){\n            short_t = mid_t0;\n            t_short_s = t_mid_s0;\n            far_t = mid_t1;\n            t_far_s = t_mid_s1;\n        }else if((t_mid_s2 * t_mid_s1) <= epsilon2){\n            short_t = mid_t1;\n            t_short_s = t_mid_s1;\n            far_t = mid_t2;\n            t_far_s = t_mid_s2;\n        }else if((t_mid_s2 * t_far_s) <= epsilon2){\n            short_t = mid_t2;\n            t_short_s = t_mid_s2;\n        }else{\n\t\t\treturn false;\n        }\n        delta_t = far_t - short_t;\n        mid_t0 = short_t + (1.0 * delta_t) / 4.0;\n        mid_t1 = short_t + (2.0 * delta_t) / 4.0;\n        mid_t2 = short_t + (3.0 * delta_t) / 4.0;\n        t_mid_s0 = shapeFunction(helicoid, calcRayEndpoint(offset_ray, mid_t0));\n        t_mid_s1 = shapeFunction(helicoid, calcRayEndpoint(offset_ray, mid_t1));\n        t_mid_s2 = shapeFunction(helicoid, calcRayEndpoint(offset_ray, mid_t2));\n    }\n    float mid_t = (short_t + far_t) / 2.0;\n    //TODO will probably want to set up seperate step for the rest of this\n    vec3 intersection_point = calcRayEndpoint(offset_ray, mid_t);\n    \n    vec3 other_point = vec3(cos(1.0 *itime)*5.0, sin(1.0 *itime)*5.0, 0.0);\n    vec3 light_source_dir = normalize(other_point - intersection_point);\n    intersection_point += 0.0*(light_source_dir*.0001);\n    ScreenRay t_ray = ScreenRay(intersection_point, light_source_dir, light_source_dir.z);\n    //TODO may be able to optimize since we know we will hit cylinder\n    float distance_to_cylinder_edge;\n    IntersectionDistance outbound_intersection_distance;\n    if(!rayIntersection(t_ray, \n                        bounding_cylinder,  \n                        outbound_intersection_distance,\n                        temp_normal)){\n        //return outbound_intersection_distance.to_object != 0.0;\n        //return false;\n    }\n    t_far_s = shapeFunction(helicoid, endIntersection(outbound_intersection_distance, t_ray));\n    t_short_s = shapeFunction(helicoid, intersection_point);\n    if((t_far_s * t_short_s) < epsilon){\n        self_shadow = true;\n        \n        shadow_value = 0.0;\n        \n    }else{\n        vec3 n = vec3(cos(helicoid.twist * intersection_point.y), 0.0, sin(helicoid.twist * intersection_point.y));\n        n = gradientFunction(helicoid, intersection_point);\n        //n.y = 0.0;\n        //n = -1.0/n;\n        n = normalize(n);\n        shadow_value = dot(n, t_ray.direction);\n    }\n    intersection_distance.to_object = mid_t;\n    intersection_distance.to_end = mid_t;\n    return true;\n}\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define KEYBOARD_CHANNEL iChannel0\n#define STATE_CHANNEL iChannel1\n\n//KEYS\nconst int KEY_LEFT  = 37;\nconst int KEY_UP    = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN  = 40;\nconst int KEY_SHIFT = 16;\nconst int KEY_CTRL  = 17;\n\n\nconst int KEY_A = 65;\nconst int KEY_B = 66;\nconst int KEY_C = 67;\nconst int KEY_D = 68;\nconst int KEY_E = 69;\nconst int KEY_F = 70;\nconst int KEY_G = 71;\nconst int KEY_H = 72;\nconst int KEY_I = 73;\nconst int KEY_J = 74;\nconst int KEY_K = 75;\nconst int KEY_L = 76;\nconst int KEY_M = 77;\nconst int KEY_N = 78;\nconst int KEY_O = 79;\nconst int KEY_P = 80;\nconst int KEY_Q = 81;\nconst int KEY_R = 82;\nconst int KEY_S = 83;\nconst int KEY_T = 84;\nconst int KEY_U = 85;\nconst int KEY_V = 86;\nconst int KEY_W = 87;\nconst int KEY_X = 88;\nconst int KEY_Y = 89;\nconst int KEY_Z = 90;\n\nconst float linear_velocity = 0.01;\nconst float rotate_velocity = 0.05;\n\nvec3 getAxisMovementVector(){\n\tfloat velocity = linear_velocity;\n    float modifier = 1.0;\n    if(getKeyState(KEYBOARD_CHANNEL, KEY_SHIFT) == 1.0){\n        modifier *= 10.0;\n    }else if(getKeyState(KEYBOARD_CHANNEL, KEY_C) == 1.0){\n        modifier *= 0.1;\n    }else if(getKeyState(KEYBOARD_CHANNEL, KEY_E) == 1.0){\n        modifier *= 10.0;\n    }\n    velocity *= modifier;\n    float left_move = getKeyState(KEYBOARD_CHANNEL, KEY_A)*-velocity;\n    float up_move = getKeyState(KEYBOARD_CHANNEL, KEY_W)*velocity;\n    float right_move = getKeyState(KEYBOARD_CHANNEL, KEY_D)*velocity;\n    float down_move = getKeyState(KEYBOARD_CHANNEL, KEY_S)*-velocity;\n\n    float x_move = left_move + right_move;\n    float y_move = 0.0;\n    float z_move = up_move + down_move;\n\n    return vec3(x_move, y_move, z_move);\n}\n\nvec3 getRotatedMovementVector(){\n    vec3 axis_move_vec = getAxisMovementVector();\n    vec3 last_rot = loadValue(STATE_CHANNEL, rotation_index).xyz;\n    axis_move_vec = rotVecX(axis_move_vec, last_rot.x);\n    axis_move_vec = rotVecY(axis_move_vec, last_rot.y);\n    return axis_move_vec;\n}\n\nvec3 getRotationVector(){\n    float left_rot = getKeyState(KEYBOARD_CHANNEL, KEY_LEFT)*-rotate_velocity;\n    float up_rot = getKeyState(KEYBOARD_CHANNEL, KEY_UP)*rotate_velocity;\n    float right_rot = getKeyState(KEYBOARD_CHANNEL, KEY_RIGHT)*rotate_velocity;\n    float down_rot = getKeyState(KEYBOARD_CHANNEL, KEY_DOWN)*-rotate_velocity;\n    float x_rot = up_rot + down_rot;\n    float y_rot = left_rot + right_rot;\n    float z_rot = 0.0;\n    return vec3(x_rot, y_rot, z_rot); \n}\n\n\nvoid finishCaching(int max_cache_frame_number){\n    //using cached, discard thread result\n    if( iFrame > max_cache_frame_number){\n        discard;\n    } \n}\n\nvoid stateFunction(inout vec4 fragColor, const in vec2 fragCoord){\n    ivec2 ifragCoord = ivec2( fragCoord-0.5 );\n    if(iFrame < 1)\n    {\n        fragColor = vec4(1.0,1.0,1.0,0.0); \n        storeValue(position_index, vec4(0.0, 0.0, -10.0, 1.0), fragColor, ifragCoord );\n        storeValue(rotation_index, vec4(0.0, 0.0, 1.0, 1.0), fragColor, ifragCoord );\n        //storeValue(test_index, vec4(1.0, 1.0, 1.0, 1.0), fragColor, ifragCoord);\n    } else if(ifragCoord == position_index) {        \n        vec3 move_vec = getRotatedMovementVector();\n        vec3 last_pos = loadValue(STATE_CHANNEL, position_index).xyz;\n        vec3 new_pos =last_pos + move_vec;\n        storeValue(position_index, vec4(new_pos,1.0), fragColor, ifragCoord);\n    } else if(ifragCoord == rotation_index){\n        vec3 rot_vec = getRotationVector();\n        vec3 last_rot = loadValue(STATE_CHANNEL, rotation_index).xyz;\n        vec3 new_rot = last_rot + rot_vec;\n        storeValue(rotation_index, vec4(new_rot,1.0), fragColor, ifragCoord);\n\n    }else{\n        fragColor = vec4(1.0,1.0,1.0,0.0); \n    }\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    stateFunction(fragColor, fragCoord);\n}","name":"Buffer A","description":"","type":"buffer"}]}