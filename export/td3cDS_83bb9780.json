{"ver":"0.1","info":{"id":"td3cDS","date":"1601618824","viewed":139,"name":"gradient-noise-effects","username":"phcs93","description":"some effects from libnoise (http://libnoise.sourceforge.net/)","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["3d","noise","simplex"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float F3 = 0.3333333;\nconst float G3 = 0.1666667;\n\n// simplex noise\nfloat noise (vec3 v) { // https://www.shadertoy.com/view/XsX3zB\n\n    vec3 s = floor(v+dot(v,vec3(F3)));\n    vec3 p = v-s+dot(s,vec3(G3));\n    vec3 e = step(vec3(0.0),p-p.yzx);    \n    vec3 i1 = e*(1.0-e.zxy);\n    vec3 i2 = 1.0-e.zxy*(1.0-e);\n    vec3 p1 = p-i1+G3;\n    vec3 p2 = p-i2+2.0*G3;\n    vec3 p3 = p-1.0+3.0*G3;    \n    vec4 w = vec4(dot(p,p),dot(p1,p1),dot(p2,p2),dot(p3,p3));    \n    vec4 d = vec4(dot(random(s),p),dot(random(s+i1),p1),dot(random(s+i2),p2),dot(random(s+1.0),p3));\n    \n\tw = max(0.6-w,0.0);\n    \n    w *= w;\n    w *= w;\n    d *= w;\n\n    return dot(d,vec4(52.0));\n    \n}\n\nfloat fbm (vec3 v, int octaves) {\n\n    float factor = 0.0;\n    float signal = 0.0;\n    float scale = 0.5;\n\n    for (int i = 0; i < octaves; i++){\n        float value = noise(v);\n        signal += value * scale;\n        factor += scale;\n        v *= 2.0;\n        scale *= 0.5;\n    }\n\n    return signal / factor;\n\n}\n\nfloat turbulence (vec3 v, int viscosity, int distortion) {\n\n    float x0 = v.x + (12414.0 / 65536.0);\n    float y0 = v.y + (65124.0 / 65536.0);\n    float z0 = v.z + (31337.0 / 65536.0);\n    float x1 = v.x + (26519.0 / 65536.0);\n    float y1 = v.y + (18128.0 / 65536.0);\n    float z1 = v.z + (60493.0 / 65536.0);\n    float x2 = v.x + (53820.0 / 65536.0);\n    float y2 = v.y + (11213.0 / 65536.0);\n    float z2 = v.z + (44845.0 / 65536.0);\n    float xd = v.x + (fbm(vec3(x0, y0, z0), distortion));\n    float yd = v.y + (fbm(vec3(x1, y1, z1), distortion));\n    float zd = v.z + (fbm(vec3(x2, y2, z2), distortion));\n\n    return fbm(vec3(xd,yd,zd), viscosity);\n\n}\n\nfloat billow (vec3 v, int octaves) {\n\n    float m_frequency = 1.0;\n    float m_lacunarity = 2.0;\n    float m_persistence = 0.5;\n\n    float value = 0.0;\n    float signal = 0.0;\n    float curPersistence = 1.0;\n\n    v *= m_frequency;\n\n    for (int curOctave = 0; curOctave < octaves; curOctave++) {\n        signal = noise(v);\n        signal = 2.0 * abs(signal) - 1.0;\n        value += signal * curPersistence;\n        v *= m_lacunarity;\n        curPersistence *= m_persistence;        \n    }\n    \n    return value + 0.5;\n    \n}\n\nfloat ridged (vec3 v, int octaves) {\n\n    float m_frequency = 1.0;\n    float m_lacunarity = 2.0;\n\n    // calc\n    float[6] spectral; \n    float h = 1.0;\n    float frequency = 1.0;\n    for (int i = 0; i < octaves; i++) {\n        spectral[i] = pow(frequency, -h);\n        frequency *= m_lacunarity;\n    }\n    \n    // get\n    v *= m_frequency;\n\n    float signal = 0.0;\n    float value  = 0.0;\n    float weight = 1.0;\n    float offset = 1.0;\n    float gain = 2.0;\n\n    for (int curOctave = 0; curOctave < octaves; curOctave++) {\n\n        signal = noise(v);\n        signal = abs(signal);\n        signal = offset - signal;\n        signal *= signal;\n        signal *= weight;\n        weight = signal * gain;\n        \n        if (weight > 1.0) {\n            weight = 1.0;\n        }\n        \n        if (weight < 0.0) {\n            weight = 0.0;\n        }\n\n        value += (signal * spectral[curOctave]);\n\n        v *= m_lacunarity;\n        \n    }\n    \n    return (value * 1.25) - 1.0;\n    \n}\n\n//float marble (vec3 v) {\n//    float power = 10.0;\n//    float n = power * fbm(v, 4);\n//    float s = v.x + v.y + v.z + n;\n//    return sin(s * 3.14159) * 0.5 + 0.5;\n//}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord) {\n\n    vec2 uv = fragCoord/iResolution.xy;\n    float x = uv.x;\n    float y = uv.y;\n    uv.x *= iResolution.x/iResolution.y;\n    uv *= 7.5;\n    \n    // mobile?\n    bool m = iResolution.x < iResolution.y;\n    \n    float v = 0.0;\n    \n    if ((m ? y : x) < 0.25) {\n        if ((m ? x : y) > 0.5) {\n            v = fbm(vec3(uv, iTime), 1);\n        } else {\n            v = fbm(vec3(uv, iTime), 6);\n        }\n    } else if ((m ? y : x) < 0.5) {\n        if ((m ? x : y) > 0.5) {\n            v = turbulence(vec3(uv, iTime), 6, 1);\n        } else {\n            v = turbulence(vec3(uv, iTime), 1, 6);\n        }\n    } else if ((m ? y : x) < 0.75) {\n        if ((m ? x : y) > 0.5) {\n            v = billow(vec3(uv, iTime), 6);\n        } else {\n            v = -billow(vec3(uv, iTime), 6);\n        }        \n    } else {\n        if ((m ? x : y) > 0.5) {\n            v = -ridged(vec3(uv, iTime), 6);\n        } else {\n            v = ridged(vec3(uv, iTime), 6);\n        }\n    }\n    \n    v = v * 0.5 + 0.5;\n    \n    fragColor = vec4(vec3(v), 1.0);\n    \n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"uint hash (uint v) {\n    v += (v << 10u);\n    v ^= (v >>  6u);\n    v += (v <<  3u);\n    v ^= (v >> 11u);\n    v += (v << 15u);\n    return v;\n}\n\nuint hash (uvec2 v) { return hash(v.x^hash(v.y)); }\nuint hash (uvec3 v) { return hash(v.x^hash(v.y)^hash(v.z)); }\nuint hash (uvec4 v) { return hash(v.x^hash(v.y)^hash(v.z)^hash(v.w)); }\n\nfloat floatConstruct (uint v) {\n    v &= 0x007FFFFFu; // ieee mantissa\n    v |= 0x3F800000u; // ieee one\n    return uintBitsToFloat(v)-1.0;\n}\n\nfloat random (float v) { return floatConstruct(hash(floatBitsToUint(v))); }\n//float random (vec2 v) { return floatConstruct(hash(floatBitsToUint(v))); }\n//float random (vec3 v) { return floatConstruct(hash(floatBitsToUint(v))); }\n\nvec3 random (vec3 v){\n    v = vec3(random(v.x),random(v.y),random(v.z));\n \tconst vec3 k = vec3(3.1415926,2.71828,6.62607015);\n \tv = v*k+v.yzx;\n \treturn -1.0+2.0*fract(2.0*k*fract(v.x*v.y*v.z*(v.x+v.y+v.z)));\n}","name":"Common","description":"","type":"common"}]}