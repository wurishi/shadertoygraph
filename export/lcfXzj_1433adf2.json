{"ver":"0.1","info":{"id":"lcfXzj","date":"1705437520","viewed":56,"name":"Transition - planes","username":"MV10","description":"A group of several interesting transitions and crossfades I'm revising for parameterization in my external audio visualizer program. \nRestart to see it run again, after iTime exceeds fadeDuration only the new buffer is shown. Change EFFECT on line 11.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["transition","crossfade"],"hasliked":0,"parentid":"DlycWm","parentname":"Plane Transition Collection"},"renderpass":[{"inputs":[{"id":"Xdf3Rn","filepath":"/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm","previewfilepath":"/media/ap/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm","type":"video","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4df3zn","filepath":"/media/a/3405e48f74815c7baa49133bdc835142948381fbe003ad2f12f5087715731153.ogv","previewfilepath":"/media/ap/3405e48f74815c7baa49133bdc835142948381fbe003ad2f12f5087715731153.ogv","type":"video","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n#define oldBuffer iChannel0\n#define newBuffer iChannel1\nfloat fadeDuration = 3.0;\nfloat fadeLevel;\n\n// 1 - rotate (opposite sides of a single plane)\n// 2 - rotate_out (moves away, swaps content, moves back)\n// 3 - rotate_in (moves aside for new content to move forward)\n// 4 - rotate_shuffle (restack one in front of the other)\n#define EFFECT 4\n\n#define PI 3.1415926\n\nconst float mirror_intensity = 0.25;\n\nvec4 box(sampler2D tx, vec2 pos, vec2 size, vec2 uv, float rot, float dy) \n{\n    float z = 0.25;\n    size.x *= abs(rot - 1.0);\n    float arot = 1.0 - abs(rot - 1.0);\n    float dir = (2.0 * step(rot, 1.0)) - 1.0;\n    float amtx = (uv.x - pos.x + size.x / 2.0) / size.x;\n    amtx = (abs(step(1.0, rot) - amtx) - 0.5) * 2.0;\n    float amty = z * size.y * arot * amtx;\n    size.y += amty;\n    pos.y += dy + dy * amty * 1.6;\n    vec2 uvBox = (uv - pos + size / 2.0) / size;\n    vec4 result = vec4(texture(tx, uvBox).rgb, 1.0);\n    result *= step(0.0, uvBox.x) * step(uvBox.x, 1.0);\n    result *= step(uvBox.y, 1.0) * step(0.0, uvBox.y);\n    float d = clamp(size.x + 0.25, 0.0, 1.0);\n    result *= vec4(d, d, d, 1.0);\n    \n    pos.y -= dy * 2.0;\n    uvBox = (uv - pos + size / 2.0) / size;\n    vec4 mirror = vec4(texture(tx, abs(uvBox)).rgb, 1.0);\n    mirror *= step(0.0, uvBox.x) * step(uvBox.x, 1.0);\n    mirror *= step(uvBox.y, 0.0) * step(-1.0, uvBox.y);\n    uvBox = (1.0 - abs(uvBox));\n    mirror *= vec4(uvBox.y, uvBox.y, uvBox.y, 1.0);\n    mirror *= vec4(d, d, d, 1.0) * mirror_intensity;\n    return result + mirror;\n}\n\nvec4 rotate_out(vec4 result, float rtime, vec2 uv) \n{\n    //rtime *= 1.5;\n    vec2 size = vec2(1.0 * abs(cos(rtime * PI)), 1.0 * abs(cos(rtime * PI)));\n    vec2 pos = vec2(0.5, 0.5);\n    float rot = 1.0 - abs(cos(rtime * PI));\n    pos.x += rot / 2.0;\n\n    vec4 first = box(newBuffer, pos, size, uv, rot, 0.0);\n    result = result * (1.0 - min(first.a, 1.0));\n    result += first * step(2.0, mod(rtime * 2.0 + 1.0, 4.0));\n    result += box(oldBuffer, pos, size, uv, rot, 0.0) * step(mod(rtime * 2.0 + 1.0, 4.0), 2.0);\n    return result;\n}\n\nvec4 rotate_in(vec4 result, float rtime, vec2 uv) \n{\n    rtime *= 0.5;\n    \n    // The amount to pull it back before rotating the next plane in\n    float amt = 0.385;\n    float rot = abs(mod(rtime * 2.0, 2.0) - 1.0) * amt * 2.0;\n    \n    // Scene 1 rotation\n    float rot1 = min(rot, amt);\n    vec2 pos = vec2(0.5, 0.5);\n    pos.x += rot1 / 2.0;\n    vec2 size = vec2(1.0 - rot1, 1.0 - rot1);\n    vec4 first = box(newBuffer, pos, size, uv, rot1, 0.0);\n    \n    // Scene 2 rotation\n    float rot2 = max(rot + 2.0 * (1.0 - amt), 2.0 - amt);\n    pos = vec2(0.5, 0.5);\n    pos.x -= (2.0 - rot2) / 2.0;\n    size = vec2(abs(1.0 - rot2), abs(1.0 - rot2));\n    vec4 second = box(oldBuffer, pos, size, uv, rot2, 0.0);\n    \n    // Form the result\n    result = result * (1.0 - min(first.a + second.a, 1.0));\n    \n    // Position first over second if rotation is in an early position\n    result += (first + second * (1.0 - first.a)) * step(rot, amt);\n    \n    // Position second over first if rotation is in a later position\n    result += (second + first * (1.0 - second.a)) * step(amt, rot);\n        \n    return result;\n}\n\nvec4 rotate(vec4 result, float rtime, vec2 uv) \n{\n    //rtime *= 2.0;\n    vec2 pos = vec2(0.5, 0.5);\n    float rot = mod(rtime * 2.0, 2.0);\n    vec2 size = 0.7 + 0.3 * vec2(1.0 * abs(cos(PI * rtime)));\n\n    vec4 first = box(newBuffer, pos, size, uv, rot, 0.0);\n    result = result * (1.0 - min(first.a, 1.0));\n    result += first * step(2.0, mod(rtime * 2.0 + 1.0, 4.0));\n    result += box(oldBuffer, pos, size, uv, rot, 0.0) * step(mod(rtime * 2.0 + 1.0, 4.0), 2.0);\n    return result;\n}\n\n\nconst float stack_rotate_time = 0.2;\nconst float stack_lift_time = 0.1;\nconst float stack_shuffle_time = 0.1;\nconst float stack_rotate = 0.385;\nconst float stack_lift_amount = 0.65;\n\nvec4 rotate_shuffle(vec4 result, float rtime, vec2 uv) \n{\n    // The amount to pull it back before rotating the next plane in\n    float amt = stack_rotate_time;\n    float lift = stack_lift_time;\n    float shift = stack_shuffle_time;\n    \n    float rot_amt = stack_rotate;\n    float lift_y = stack_lift_amount;\n    \n    float period = amt * 2.0 + shift + lift * 2.0;\n    \n    float t0 = mod(rtime * 2.0, period * 2.0);\n    float t = mod(t0, period);\n    \n    // Scene 1 rotation\n    float rot = ((min(t, amt) / amt) * rot_amt) * step(t, amt + lift * 2.0 + shift);\n    rot += max(0.0, (amt - (t - amt - lift * 2.0 - shift)) / amt * rot_amt) * step(amt + lift * 2.0 + shift, t);\n    \n    t -= amt;\n    \n    // Lifting\n    float lift1 = step(0.0, t) * (min(t, lift) / lift * lift_y);\n    \n    // Shift time\n    float t2 = t - lift;\n    \n    // (Working ahead... putting it back down)\n    float t3 = t - lift - shift;\n    vec2 pos = vec2(0.5, 0.5);\n    pos.x += step(0.0, t2) * (min(t2, shift) / shift * 0.05);\n    pos.y += step(0.0, t2) * (min(t2, shift) / shift * 0.05);\n    lift1 -= step(0.0, t3) * (min(t3, lift) / lift * lift_y);\n    vec2 size = vec2(1.0 - rot, 1.0 - rot) * (1.0 - step(0.0, t2) * (min(t2, shift) / shift * 0.1));\n    vec4 first = box(oldBuffer, pos, size, uv, rot, lift1) * step(t0, period);\n    first += box(newBuffer, pos, size, uv, rot, lift1) * step(period, t0);\n    \n    t -= lift;\n    float swapped = t;\n    \n    // Scene 2 rotation\n    pos = vec2(0.5, 0.5);\n    pos.x += 0.05 - step(0.0, t) * (min(t, shift) / shift * 0.05);\n    pos.y += 0.05 - step(0.0, t) * (min(t, shift) / shift * 0.05);\n    size = vec2(1.0 - rot, 1.0 - rot) * (0.9 + step(0.0, t) * (min(t, shift) / shift * 0.1));\n    vec4 second = box(newBuffer, pos, size, uv, rot, 0.0) * step(t0, period);\n    second += box(oldBuffer, pos, size, uv, rot, 0.0) * step(period, t0);\n    \n    // Form the result    \n    // Position first over second if rotation is in an early position\n    result = result * (1.0 - min(first.a + second.a, 1.0));\n    result += (first + second * (1.0 - first.a)) * step(swapped, 0.0);\n    \n    // Position second over first if rotation is in a later position\n    result += (second + first * (1.0 - second.a)) * step(0.0, swapped);\n        \n    return result;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // This is a uniform in my real program\n    fadeLevel = clamp(iTime / fadeDuration, 0.0, 1.0);\n    if(fadeLevel >= 1.0) discard;\n\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec4 result = vec4(0.5 + 0.5 * cos(iTime + uv.xyx + vec3(0, 2, 4)), 1.0);\n    \n    // Scale time to match the target duration\n    float scaled_time = iTime * (1.0 / fadeDuration);\n    \n    if(EFFECT == 1) fragColor = rotate(result, scaled_time, uv);\n    if(EFFECT == 2) fragColor = rotate_out(result, scaled_time, uv);\n    if(EFFECT == 3) fragColor = rotate_in(result, scaled_time, uv);\n\n    // Shuffle needs a magic-number...\n    scaled_time = iTime * (0.352 / fadeDuration);\n    if(EFFECT == 4) fragColor = rotate_shuffle(result, scaled_time, uv);\n}","name":"Image","description":"","type":"image"}]}