{"ver":"0.1","info":{"id":"stVGzG","date":"1637930590","viewed":262,"name":"Rusty metal cubes","username":"bitless","description":"Rusty metal cubes","likes":29,"published":1,"flags":0,"usePreview":0,"tags":["2d","cube","metal","hexagonal","rust"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sXGRn","filepath":"/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","previewfilepath":"/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Author: bitless\n// Title: Rusty metal cubes\n\n// Thanks to Patricio Gonzalez Vivo & Jen Lowe for \"The Book of Shaders\"\n// and Fabrice Neyret (FabriceNeyret2) for https://shadertoyunofficial.wordpress.com/\n// and Inigo Quilez (iq) for  https://iquilezles.org/www/index.htm\n// and whole Shadertoy community for inspiration.\n\n#define maxd .48    //disk max diameter\n#define mind .1     //disk min diameter\n#define cnum 10.    //num of disks\n\n#define p(t, a, b, c, d) ( a + b*cos( 6.28318*(c*t+d) ) )                   //iq's palette\n#define rot(a)   mat2(cos(a + vec4(0,11,33,0)))                             //rotate 2d\n#define h21(a) ( fract(sin(dot(a.xy,vec2(12.9898,78.233)))*43758.5453123) ) //hash21\n\n//  Minimal Hexagonal Grid - Shane\n//  https://www.shadertoy.com/view/Xljczw\nvec4 getHex(vec2 p) //hex grid coords \n{\n    vec2 s = vec2(1, 1.7320508);\n    vec4 hC = floor(vec4(p, p - vec2(.5, 1))/s.xyxy) + .5;\n    vec4 h = vec4(p - hC.xy*s, p - (hC.zw + .5)*s);\n    return dot(h.xy, h.xy)<dot(h.zw, h.zw) ? vec4(h.xy, hC.xy) : vec4(h.zw, hC.zw + .5);\n}\n\nvec3 HexToSqr (vec2 st) //hexagonal cell coords to square face coords \n{ \n    vec3 r;\n    if (st.y > 0.-abs(st.x)*0.57777)\n        if (st.x > 0.) \n            r = vec3(fract(vec2(-st.x,(st.y+st.x/1.73)*0.86)*2.),2.); //right face\n        else\n            r = vec3(fract(vec2(st.x,(st.y-st.x/1.73)*0.86)*2.),3.); //left face\n        else\n            r = vec3(fract(vec2((st.x+st.y*1.73),(st.x-st.y*1.73))),1.); //upper face\n    return r;\n} \n\nfloat sinc( float x, float k, float l)\n{\n    float h = k*x;\n    return sin(x*l)*h*exp(1.0-h);\n}\n\nvec4 Tex (vec4 hx, vec3 sqr, vec2 sh) //face texture\n{\n    float r = h21(hx.zw*vec2(sqr.z))*5.;\n    vec2 uv = ((sqr.xy + vec2(r))  - sh)*.5* rot(r);\n    vec4 t = texture(iChannel0, uv);\n    return mix(vec4(p(h21(vec2(hx.zw))*1.75,vec3(.18,.38,.32),vec3(.46,.42,.58),vec3(.11,.20,.22),vec3(.14,.16,.13))*.125,1.),t,.1);  \n}\n\nvoid tile(vec4 hx,inout vec4 C) \n{\n    vec3 sqr = HexToSqr(hx.xy);\n    vec2    st = sqr.xy - .5  //face square coordinates\n            ,shift;  //disk shift\n    float   n = sqr.z       //face id\n            ,sm = 3./iResolution.y  //smoothness\n            ,h = -sinc (mod(iTime+h21(hx.wz*vec2(n))*20., 10.), .75,3.5)*.3 //bump stright\n            ,df =  abs(h) * .8\n            ,b = (4.-n)*1.2+.8; //face lightness\n\n    C = Tex(hx,sqr,vec2(max(h,0.)*sin(1.2)*1.5)*vec2(1.,-1.))*b*(1.-max(h,0.)*5.);\n    \n    for (float i = 0.; i < cnum; i++)\n    {\n        float k = (h < 0.) ? cnum - 1. - i : i;\n        float diam = mind + (maxd-mind)/cnum*k;\n        shift = vec2(h*sin((cnum-1.-k)/cnum*1.2)*1.5)*vec2(1,-1);\n        vec4 col = Tex(hx,sqr,shift)*b;\n\n        if (h < 0.) //outer disks\n        {\n            C = mix(C, vec4(0.), smoothstep (diam+df,diam-sm,length(st-shift))*.2); //shadow;\n            C = mix(C, col * (1. - (cnum-k)/cnum*h*5.), smoothstep (diam+sm,diam-sm,length(st-shift))); //disk\n            C = mix(C, vec4(max(-st.y,-.1)*2.), smoothstep (.01,.0,abs(length(st-shift)-diam))*df); //disk edge\n        }\n        else //inner disks\n        {\n            C = mix(C, col* (1. - (cnum - 1. -i )/cnum*h*5.) , smoothstep (diam-sm,diam+sm,length(st-shift))); //disk\n            C = mix(C, vec4(st.y), smoothstep (.01,.0,abs(length(st-shift)-diam))*df); //disk edge\n        }\n    }\n    C = mix(C, vec4(0.),(smoothstep(.4,.5,-st.x)+smoothstep(.4,.5,st.y))*.3); //ambient occlusion\n    C = mix(C, vec4(1.),(smoothstep(.45,.5,st.x)+smoothstep(.45,.5,-st.y))*.08); //edge bevel\n}\n\nvoid mainImage( out vec4 C, in vec2 g)\n{\n    vec2 rz = iResolution.xy\n        ,uv = (g+g-rz)/-rz.y;\n    \n    uv *= 1.2+sin(iTime*.3)*.25; //camera scale\n    uv += uv * pow(length(uv),2.)*.025 + vec2(sin(iTime*.2)+5.,-cos(iTime*.2)+9.); //lens distortion and camera moving\n    \n    vec4 hx = getHex(uv);\n    C = -C;\n    tile(hx,C);\n}\n","name":"Image","description":"","type":"image"}]}