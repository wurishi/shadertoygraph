{"ver":"0.1","info":{"id":"MfBGDV","date":"1704743841","viewed":178,"name":"Arc Length Parameterization","username":"vichoeq","description":"Experimenting with arc-length parametrization on splines for smooth movement, specifically Catmull-Rom. Lookup table is computed at frame 0, so make sure to restart the shader if you make any changes! \n\nLeft: normal, Right: arc length parameterized","likes":21,"published":1,"flags":32,"usePreview":0,"tags":["2d","math","spline","study","splines","multipass"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// ------ Moving points animation -------\n\n// T = 0..1\nvec2 eval_spline_uniform(float T)\n{             \n    float d_delta = D(stops + 1) / float(stops + 1);    \n    float d = T*D(stops + 1);        \n    int i = int(floor(T * float(stops + 1)));        \n    if(i == stops + 1) return P(N);       \n    float t = mod(d, d_delta) / d_delta;   \n    return mix(S(i), S(i+1), t);  \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    vec2 uv = (fragCoord * 2. - iResolution.xy) / iResolution.y; \n        \n    fragCoord.x = mod(fragCoord.x, iResolution.x / 2.0);\n    fragCoord.x += 0.25 * iResolution.x;    \n        \n    vec2 luv = (fragCoord * 2. - iResolution.xy) / iResolution.y;         \n    luv *= scale;\n    \n    float px = scale*3./iResolution.y;   \n    \n    \n    vec3 col = T1(ivec2(fragCoord)).rgb;\n     \n    \n    float n = 15.0;    \n    float d = 1.0/n;\n    float T = mod(iTime*0.1,d);\n    \n    for(float i = 0.0; i < n; i++)\n    {\n        vec2 p;\n        if(uv.x > 0.0)\n        {\n            p = eval_spline_uniform(T+i*d);\n        }\n        else\n        {\n            float t = (T+i*d)*domain;\n            p = CR(MP(t),t);\n        }    \n        col = mix(col, vec3(1,1,1), draw_point(luv, p, 3.*px, px));       \n    }\n        \n    col = mix(col, vec3(1,1,1), draw_point(luv, P(1), 3.*px, px));    \n    col = mix(col, vec3(1,1,1), draw_point(luv, P(N), 3.*px, px)); \n    \n    col += 1.0 - smoothstep(0.0, px, abs(uv.x));\n\n    fragColor.rgb = col;\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"//--------------PARAMETERS-----------\n\n// Amount of points on the spline\nconst int N = 8;\n\n// Random seed for the positions of the points\n//const float SEED = 26511.0;\n//const float SEED = 511.0;\nconst float SEED = 5141.0;\n\n// Amount of stops accross the curve for the lookup tables\nconst int stops = 8*N;\n\n/////////////////////////////////////////\n\n// Shared code\n\n#define TAU 6.28318\n#define scale 2.0\n#define domain float(N-1)\nconst mat4 CATMULL_ROM = 0.5 * mat4\n(\n     0, 2, 0, 0,\n    -1, 0, 1, 0,\n     2,-5, 4,-1,\n    -1, 3,-3, 1\n);\n\n\n\n#define T0(U)  texelFetch(iChannel0, ivec2(U), 0)\n#define T1(U)  texelFetch(iChannel1, ivec2(U), 0)\n\n// Read the arrays stored in buffer A\n#define P(i) T0(ivec2(0,i)).xy\n#define D(i) T0(ivec2(1,i)).x\n#define S(i) T0(ivec2(2,i)).xy\n\n// Spline evaluation steps\n#define MPi(ti) mat4x2(P(0+ti), P(1+ti), P(2+ti), P(3+ti))\n#define MP(t) MPi(int(floor(t)))\n#define VT(t) vec4(1,t,(t)*(t),(t)*(t)*(t))\n#define CR(MP, t) (MP*CATMULL_ROM*VT(fract(t)))\n\nfloat draw_point(vec2 uv, vec2 p, float r, float px)\n{\n    float sd = length(uv-p) - r;\n    return smoothstep(px, 0.0, sd);\n}\n\nvec2 hash21(float p)\n{\n\tvec3 p3 = fract(vec3(p,p,p) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// --------Lookup table computation ---------\n\n// Write variables to buffer (called in the same line as the assignment)\n#define SETP(i) if(iU == ivec2(0, i)) {O.xy = P[i]; return;}\n#define SETD(i) if(iU == ivec2(1, i)) {O.x = D[i]; return;}\n#define SETS(i) if(iU == ivec2(2, i)) {O.xy = S[i]; return;}\n\n// Detect changes on parameters\n#define DSEED T0(ivec2(3,1))\n#define DN T0(ivec2(3,2))\n#define DSTOPS T0(ivec2(3,3))\n\n// Redefine MP to get local P\n#undef P\n#define P(i) P[i]\n\nvec2 P[N+2];\nfloat D[stops + 2];\nvec2 S[stops + 2];\n\nbool refresh()\n{\n    return DSEED.x != DSEED.y || DN.x != DN.y || DSTOPS.x != DSTOPS.y;\n}\n\nvoid mainImage( out vec4 O, in vec2 U )\n{\n    ivec2 iU = ivec2(U);\n    \n    O = texelFetch(iChannel0, iU, 0);\n      \n    // Save things that will make us redraw or recompute\n    if (iU == ivec2(3,0)) { O = vec4(iResolution.xy, O.xy ); return; }    \n    if (iU == ivec2(3,1)) { O.xy = vec2(SEED, O.x); return; }    \n    if (iU == ivec2(3,2)) { O.xy = vec2(N, O.x); return; }    \n    if (iU == ivec2(3,3)) { O.xy = vec2(stops, O.x); return; }    \n    \n    // Only do the expensive calculations for the pixels that will store them\n    if(iU.x == 0 && iU.y >= N+2) return;\n    if(iU.x == 1 && iU.y >= stops+2) return;\n    if(iU.x == 2 && iU.y >= stops+2) return;\n    if(iU.x == 3 && iU.y > 4) return;\n    if(iU.x >= 4) return;\n        \n    // INITIALIZATION ROUTINE\n    if (!refresh() && iFrame>0) \n    {\n        if (iU == ivec2(3,4)) { O.x = 0.0; return; } // Mark as not computed this frame\n        return;\n    }\n    \n    /////////// Step 0   \n    \n    // Generate points randomly around a circle (O(N))\n    for(int i = 1; i <= N; i++)\n    {\n        vec2 h = hash21(SEED * float(i)) - 0.5;        \n        float angle = (float(i-1) + h.x) * TAU / float(N);        \n        P[i] = vec2(cos(angle), sin(angle)) * (1.0 + h.y); SETP(i);     \n    }    \n\n    // Add 2 extra control points at both ends of the curve.\n    P[0]   = 2.0*P[1] - P[2];   SETP(0);    \n    P[N+1] = 2.0*P[N] - P[N-1]; SETP(N+1);\n    \n    \n    /////////// Step 1\n    \n      \n    // Build lookup table with equally spaced t values (O(stops))\n    float t_delta = domain / float(stops + 1);\n    vec2 prev = P[1];\n    D[0] = 0.0; SETD(0);\n    \n    for(int i = 1; i <= stops + 1; i++)\n    {\n        float t = float(i)*t_delta;\n        vec2 p = CR(MP(t),t);                        \n        D[i] = D[i-1] + length(prev - p); SETD(i);\n        prev = p;\n    }    \n    \n    /////////// Step 2\n    \n    // Build lookup table with equally spaced d values (O(stops log stops))\n    float d_delta = D[stops + 1] / float(stops + 1);\n       \n    for(int i = 0; i <= stops + 1; i++)\n    {\n        float d = float(i)*d_delta;\n        \n        // Binary search\n        int j_lo = 0;\n        int j_hi = stops + 1;\n                \n        while(j_hi - j_lo != 1)\n        {\n            int jm = (j_lo + j_hi) / 2;                \n            if(d < D[jm]) j_hi = jm;            \n            else j_lo = jm;            \n        }\n        \n        float t = (d - D[j_hi-1])/(D[j_hi] - D[j_hi-1]);\n        \n        t = (float(j_hi-1) + t)*t_delta;\n\n        S[i] = CR(MP(t),t); SETS(i);        \n    }  \n    \n    \n    // Mark as recently computed, so buffer B knows to redraw\n    if (iU == ivec2(3,4)) { O.x = 1.0; return; } \n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// ---------- Smooth curve rendering ----------\n\n#define FLT_MAX 3.402823466e+38\n\n// Detect changes on Resolution or the curve itself\n#define DRES T0(ivec2(3,0))\n#define DCURVE T0(ivec2(3,4))\n\nbool refresh()\n{\n    return DRES.xy != DRES.zw || DCURVE.x > 0.0;\n}\n\nfloat px;\n\nvec3 draw_grid(vec2 uv)\n{ \n    float axis = min(abs(uv.x - round(uv.x)), abs(uv.y - round(uv.y)));            \n    return vec3(smoothstep(px, 0.0, axis));\n}\n\nfloat sdSegment(in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp(dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length(pa - ba*h);\n}\n\nfloat draw_line(vec2 uv, vec2 p1, vec2 p2)\n{\n    float sd = sdSegment(uv, p1, p2);\n    return smoothstep(2.*px, 0.0, sd);\n}\n\nvec3 hsv2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n\trgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nvec3 uv2rgb(vec2 uv)\n{\n    return hsv2rgb(vec3(0.5+atan(uv.y, -uv.x)/TAU, 1, length(uv)/1.5));\n}\n\nvec4 draw_spline(vec2 uv, int stops)\n{    \n    float sd = FLT_MAX;\n    vec3 color = vec3(0);    \n    float delta = domain / float(stops + 1);\n    vec2 prev = P(1);\n    \n    for(int i = 1; i <= stops + 1; i++)\n    {\n        float t = float(i)*delta;\n        vec2 p = CR(MP(t),t);  \n        sd = min(sd, sdSegment(uv, prev, p));\n        color = mix(color, uv2rgb(p), draw_line(uv, prev, p));     \n        \n        prev = p;\n    }    \n    return vec4(color, smoothstep(2.5*px, 0.0, sd));\n}\n\nvoid mainImage( out vec4 O, in vec2 U )\n{\n    ivec2 iU = ivec2(U);\n        \n    if (!refresh() && iFrame>0) \n    {\n        O = texelFetch(iChannel1, iU, 0);\n        return;\n    }\n    \n    vec2 R = iResolution.xy;\n    vec2 uv = (U * 2. - R) / R.y;    \n    uv *= scale;        \n    px = scale*5./R.x;\n          \n    vec3 col = draw_grid(uv) * 0.2;    \n    \n    vec4 spline = draw_spline(uv, 10*stops);\n    \n    col = mix(col, spline.rgb, spline.w); \n        \n    for(int i = 1; i <= N; i++)\n    {\n        vec2 p = P(i);\n        col = mix(col, uv2rgb(p), draw_point(uv, p, 2.5*px, px));\n    }\n        \n    O.rgb = col;\n}","name":"Buffer B","description":"","type":"buffer"}]}