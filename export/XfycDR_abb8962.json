{"ver":"0.1","info":{"id":"XfycDR","date":"1731670193","viewed":229,"name":"Flip numbers","username":"yasuo","description":"Flip numbers","likes":13,"published":3,"flags":0,"usePreview":0,"tags":["digits","fonts","graphicdesign","cineshader"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define Rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define antialiasing(n) n/min(iResolution.y,iResolution.x)\n#define S2(d,b) smoothstep(1.,-1., (d - b) / fwidth(d) )\n#define S(d,b) smoothstep(antialiasing(2.),-antialiasing(2.),d - b)\n#define B(p,s) max(abs(p).x-s.x,abs(p).y-s.y)\n#define BASE_FONT_SIZE 0.07\n\nconst int c0[15] = int[](1,1,1,1,0,1,1,0,1,1,0,1,1,1,1);\nconst int c1[15] = int[](0,1,0,0,1,0,0,1,0,0,1,0,0,1,0);\nconst int c2[15] = int[](1,1,1,0,0,1,1,1,1,1,0,0,1,1,1);\nconst int c3[15] = int[](1,1,1,0,0,1,1,1,1,0,0,1,1,1,1);\nconst int c4[15] = int[](1,0,1,1,0,1,1,1,1,0,0,1,0,0,1);\nconst int c5[15] = int[](1,1,1,1,0,0,1,1,1,0,0,1,1,1,1);\nconst int c6[15] = int[](1,1,1,1,0,0,1,1,1,1,0,1,1,1,1);\nconst int c7[15] = int[](1,1,1,0,0,1,0,0,1,0,0,1,0,0,1);\nconst int c8[15] = int[](1,1,1,1,0,1,1,1,1,1,0,1,1,1,1);\nconst int c9[15] = int[](1,1,1,1,0,1,1,1,1,0,0,1,1,1,1);\n\nfloat random (vec2 p) {\n    return fract(sin(dot(p.xy, vec2(12.9898,78.233)))* 43758.5453123);\n}\n\nfloat baseFontShape(vec2 p){\n    float size = BASE_FONT_SIZE;\n    float d = length(p)-size;\n    p*=Rot(radians(-45.));\n    p.y*=0.8;\n    p.x = abs(p.x)-0.06;\n    float d2 = length(p)-size*0.5;\n    d = max(-d2,d);\n    return d;\n}\n\nfloat chars(vec2 p, int[15] data){\n    vec2 prevP  = p;\n    float size = BASE_FONT_SIZE;\n    float d = 10.;\n    for(int i = 0; i<data.length(); i++){\n        p = prevP;\n        p.x-=(float(i%3)*(size*2.))-(size*2.);\n        p.y+=(float(i/3)*(size*2.))-(size*4.);\n        \n        if (data[i]>=1){\n            float d2 = baseFontShape(p);\n            d = min(d,d2);\n        }\n    }\n    return d;\n}\n\nfloat drawFont(vec2 p, int char){\n    float d = 10.;\n    if(char == 0) {\n        d = chars(p,c0);\n    } else if(char == 1) {\n        d = chars(p,c1);\n    } else if(char == 2) {\n        d = chars(p,c2);\n    } else if(char == 3) {\n        d = chars(p,c3);\n    } else if(char == 4) {\n        d = chars(p,c4);\n    } else if(char == 5) {\n        d = chars(p,c5);\n    } else if(char == 6) {\n        d = chars(p,c6);\n    } else if(char == 7) {\n        d = chars(p,c7);\n    } else if(char == 8) {\n        d = chars(p,c8);\n    } else if(char == 9) {\n        d = chars(p,c9);\n    }\n    \n    return d;\n}\n\n// thx iq! https://iquilezles.org/articles/distfunctions2d/\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nvec3 numberTex(vec2 p, vec3 col, int char){\n    float d = drawFont(p,char);\n    vec3 bgcol = mix(vec3(0.),vec3(0.35),B(p,vec2(0.07)));\n    \n    float d2 = abs(sdBox(p,vec2(0.36))-0.04)-0.005;\n    bgcol = mix(bgcol,vec3(1.),S2(d2,0.));\n    \n    col = mix(bgcol,vec3(1.),S2(d,0.));\n    return col;\n}\n\nfloat baseCard(vec2 p){\n    vec2 size = vec2(0.38);\n    float d = sdBox(p,size)-0.05;\n    return d;\n}\n\nvec3 drawFlipNumber(vec2 p, vec3 col, float n){\n    vec2 prevP = p;\n    \n    float t = 2.*n+iTime*n;\n    float deg = mod(t,1.);\n    int num = int(mod(t,10.));\n    \n    float halfr = radians(90.);\n    float angle = radians(deg*180.);\n    float s = sin(angle);\n    float c = cos(angle);\n    float z  = 2.6; // depth, this will scale the x and y. we can tweak the perspective here.\n    mat3 rotationX = mat3(1., 0, 0., 0., c, -s, 0., 0., z);\n\n    mat3 modelMatrix = rotationX;\n\n    // Apply the inverse transformation to uv\n    vec3 transformedUV = inverse(modelMatrix) * vec3(p, z); // homogeneous\n    p = transformedUV.xy / transformedUV.z; // dividing by z enhances the perspective by normalizing the x and y\n    \n    float d = baseCard(prevP);\n    \n    int currentNum = num;\n    int nextNum = num+1;\n    if(nextNum>=10) nextNum = 0;\n    \n    col = mix(col,numberTex(prevP,col,nextNum),S(d,0.0));\n    \n    d = baseCard(p);\n    \n    if(angle<halfr){\n        d = max(-prevP.y,d);\n        col = mix(col,numberTex(p,col,currentNum),S(d,0.0));\n        \n        d = baseCard(prevP);\n        d = max(prevP.y,d);\n        col = mix(col,numberTex(prevP,col,currentNum),S(d,0.0));\n    } else {\n        d = baseCard(prevP);\n        d = max(prevP.y,d);\n        col = mix(col,numberTex(prevP,col,currentNum),S(d,0.0));\n        \n        p.y*=-1.;\n        d = baseCard(p);\n        d = max(prevP.y,d);\n        col = mix(col,numberTex(p,col,nextNum),S(d,0.0));\n    }\n    \n    d = B(prevP,vec2(0.43,0.01));\n    col = mix(col,vec3(0.0),S(d,0.0));\n    \n    return col;\n}\n\nvec3 drawFlipNumbers(vec2 p, vec3 col){\n    vec2 prevP = p;\n    p.y-=30.+iTime*0.1;\n    p*=3.;\n    vec2 id = floor(p);\n    vec2 gr = fract(p)-0.5;\n    float maxN = 2.;\n    float n = clamp(random(id)*maxN,1.,maxN);\n    \n    col = drawFlipNumber(gr,col,n);\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    vec2 prevP = p;\n    vec3 col = vec3(0.0);\n    col = drawFlipNumbers(p,col);\n    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}