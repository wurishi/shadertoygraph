{"ver":"0.1","info":{"id":"MdKyDw","date":"1522335231","viewed":125,"name":"Sphere - BRDF","username":"nawafuji","description":"tested BRDF","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["practice"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n\nconst float PI = 3.14159265359;\nconst float ONE_OVER_PI = 1.0/PI;\n\nconst float fov = 50.0;\nconst float fovx = PI * fov / 360.0;\n\nconst float S = 0.01;\n\n// const delta vectors for normal calculation\nconst vec3 deltax = vec3(S ,0, 0);\nconst vec3 deltay = vec3(0 ,S, 0);\nconst vec3 deltaz = vec3(0 ,0, S);\n\n/*\nfloat distanceToNearestSurface(vec3 p){\n  return length(p) - 1.0;\n}\n*/\n\n//rolled brass\n/*\nconst vec2 P = vec2(0.100, 0.330);\nconst vec2 A = vec2(0.050, 0.160);\nconst vec3 Scale = vec3(1.0, 1.0, 1.0);\nvec3 surfaceColor = vec3(1.0,0.62,0.31);\n*/\n\n// plastic laminate\n/*\nconst vec2 P = vec2(0.670, 0.070);\nconst vec2 A = vec2(0.092, 0.092);\nconst vec3 Scale = vec3(1.0, 50.0, 2.0);\nvec3 surfaceColor = vec3(0.45,0.54,1.0);\n*/\n\n// semi-gloss paint, rolled\n\nconst vec2 P = vec2(0.450, 0.048);\nconst vec2 A = vec2(0.045, 0.068);\nconst vec3 Scale = vec3(1.0, 20.0, 10.0);\nvec3 surfaceColor = vec3(0.45,0.54,1.0);\n\n\n// lightly brushed aluminum\n/*\nconst vec2 P = vec2(0.150, 0.190);\nconst vec2 A = vec2(0.088, 0.130);\nconst vec3 Scale = vec3(2.0, 2.0, 2.0);\nvec3 surfaceColor = vec3(1.0,0.99,1.0);\n*/\n\n// white ceramic tile\n/*\nconst vec2 P = vec2(0.700, 0.050);\nconst vec2 A = vec2(0.071, 0.071);\nconst vec3 Scale = vec3(1.0, 10.0, 10.0);\nvec3 surfaceColor = vec3(1.0,1.0,1.0);\n*/\n\nfloat fog(vec3 p, vec3 e){\n    bool useFogCoordinate = true;\n    float fdepth;\n    if(useFogCoordinate)\n        fdepth = length(p-e);\n    else\n        fdepth = abs(p.z);\n        \n    float fog;\n    float density = 0.02;\n    fog = exp(-density * fdepth);\n    return clamp(fog, 0.0, 1.0);\n}\n\nfloat cube(vec3 p){\n    float s = 1.0;\n    vec3 d = abs(p) - vec3(s);\n    return min(max(d.x, max(d.y,d.z)), 0.0)\n        + length(max(d,0.0));\n}\n\nfloat sphere(vec3 p){\n    return length(vec3(0.0) - p) - 2.0;\n}\n\nfloat plane(vec3 p){\n    float s = -1.0;\n    float d = abs(p.z - s);\n    return max(d,0.0);\n}\n\nfloat distanceToNearestSurface(vec3 p){\n\n    float dist = 10.0;\n   //\tvec3 q = vec3(mod(p.x, dist) - dist/2.0, p.yz);\n//    return min(min(cube(q), sphere(q)),plane(q));\n    //return min(cube(q), sphere(q));\n    //return plane(p);\n    //return cube(p)/sphere(p);\n\t//return max(-sphere(p),cube(p));\n    return sphere(p);\n}\n\nvec3 computeSurfaceNormal(vec3 p){\n    float d = distanceToNearestSurface(p);\n    return normalize(vec3(\n        distanceToNearestSurface(p+deltax)-d,\n        distanceToNearestSurface(p+deltay)-d,\n        distanceToNearestSurface(p+deltaz)-d\n    ));\n}\n\nvec2 computeSphereTexCoord(vec3 p){\n    float longitude = acos(dot(vec2(0,-1), normalize(p.xz)));\n    if(p.x > 0.0)\n        longitude = 2.0*PI - longitude;\n    longitude /= 2.0*PI;\n    \n    float latitude = acos(dot(vec2(1,0), normalize(p.yz)));\n    latitude /= PI;\n    \n    return vec2(longitude, latitude);\n}\n\nvec3 computeLambert(vec3 p, vec3 n, vec3 l, vec3 e){\n\n    \n    vec3 lightVector = normalize(l-p);\n    vec3 eyeVector = normalize(e-p);\n    vec3 halfVector = normalize(lightVector + eyeVector);\n    \n    float nDotLV = max(0.0, dot(lightVector, n));\n    float nDotHV = max(0.0, dot(halfVector, n));\n  \n    float attenuation = 1.0;\n    float shininess = 10.0;\n    float pf;\n    if(nDotLV == 0.0)\n        pf = 0.0;\n \telse\n        pf = pow(nDotHV, shininess);\n    \n    vec3 ambient = vec3(0.1) * attenuation;\n    vec3 diffuse = vec3(1.0,1.0,1.0) * nDotLV * attenuation;\n    vec3 specular = vec3(1.0,1.0,1.0) * pf * attenuation*1.0;\n    return min(ambient + diffuse + specular, vec3(1.0));\n}\n\nvec3 computeBRDF(vec3 n, vec3 l, vec3 h, vec3 r, vec3 t, vec3 b, vec2 p, vec2 a, vec3 s, vec3 color){\n    \n    float e1, e2, E, cosThetaI, cosThetaR, brdf, intensity;\n    \n    e1 = dot(h,t)/a.x;\n    e2 = dot(h,b)/a.y;\n    E = -2.0*((e1*e1+e2*e2)/(1.0+dot(h,n)));\n    \n    cosThetaI = dot(n,l);\n    cosThetaR = dot(n,r);\n    \n    brdf = p.x * ONE_OVER_PI + p.y * (1.0 / sqrt(cosThetaI * cosThetaR)) * ( 1.0 / (4.0 * PI * a.x * a.y)) * exp(E);\n    \n    intensity = s[0] * p.x * ONE_OVER_PI + s[1] * p.y * cosThetaI * brdf + s[2] * dot(h,n) * p.y;\n    return intensity * color;\n}   \n\nvec3 intersectsWithWorld(vec3 p, vec3 dir){\n  float dist = 0.0;\n  for(int i = 0; i < 20; i++){\n    float nearest = distanceToNearestSurface(p + dir*dist);\n    if(nearest < 0.01)\n    {\n        //return (vec3(1.0)+computeSurfaceNormal(p+dir*dist))/2.0;\n    \tvec3 hit = p+dir*dist;\n                //vec3 light = vec3(100.0,\n                  //          30.0,\n                    //        50.0);\n        vec3 light = vec3(100.0*sin(iTime),\n                            30.0*cos(iTime),\n                            50.0*(1.5+cos(iTime)));\n        \n        vec2 texcoord = computeSphereTexCoord(hit);\n        \n        vec3 N = computeSurfaceNormal(hit);\n        vec3 L = normalize(light-hit);\n        vec3 V = normalize(p-hit);\n        vec3 H = normalize(L+V);\n        vec3 R = normalize(reflect(-L, N));\n        \n        vec3 T = normalize(vec3(-N.y, N.x, 0));\n        vec3 B = normalize(cross(N,T));\n        \n            \n        //vec3 pixelColor = computeLambert(hit, computeSurfaceNormal(hit), light, p);\n\t\tvec3 pixelColor = computeBRDF(N,L,H,R,T,B,P,A,Scale,surfaceColor);\n        \n        return pixelColor;\n    } \n    dist += nearest;\n  }\n  return vec3(0.0);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //vec3 cameraPosition = vec3( cameraDistance*sin(iTime), 0.0, cameraDistance*cos(iTime));\n\t//vec3 cameraDirection = vec3(-1.0*sin(iTime), 0.0,-1.0*cos(iTime));\n    vec2 mouseUV = vec2(0.5);\n    \n    if(iMouse.z>0.0)\n\t    mouseUV = 2.0*iMouse.xy/iResolution.xy-1.0;\n    \n    float d = 10.0;\n    float z = d*cos(mouseUV.y*PI/2.0);\n    vec3 cameraPosition = vec3(sin(mouseUV.x*PI/2.0) * z, d*sin(mouseUV.y*PI/2.0), cos(mouseUV.x*PI/2.0)*z);\n\tvec3 cameraDirection = -normalize(cameraPosition);\n\tvec3 cameraUp = vec3(0.0, 1.0, 0.0);\n    \n    float fovy = fovx * iResolution.y/iResolution.x;\n\tfloat ulen = tan(fovx);\n\tfloat vlen = tan(fovy);\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n\t// generate the ray for this pixel\n\tvec2 camUV = uv*2.0 - vec2(1.0, 1.0);\n\tvec3 nright = normalize(cross(cameraUp, cameraDirection));\n    cameraUp = normalize(cross(nright, cameraDirection));\n\tvec3 pixel = cameraPosition + cameraDirection + nright*camUV.x*ulen + cameraUp*camUV.y*vlen;\n\tvec3 rayDirection = normalize(pixel - cameraPosition);\n\n\tvec3 pixelColour = intersectsWithWorld(cameraPosition, rayDirection);\n            \n\n    fragColor = vec4(pixelColour, 1.0);\n}\n\n\n/** \n\n\tthe screenshot is here:\n    https://www.dropbox.com/s/ya2hhxvz1ixqipv/localShadertoysTextures.jpg?dl=0\n\n\trun fiddler (http://www.telerik.com/fiddler)\n    enable HTTPS ( & decrypt ) in fiddler options\n    go to tab shown on screenshot (autoresponder) and set options\n    add rule, then enter url to capture\n    in this example: https://www.shadertoy.com/presets/tex00.jpg\n    (first in textures set)\n\tand\n    enter url for redirect to ( could be file://... or /usr/user/...\n    \n    in this example \n    http://ogario.wpload.com/skins/amiga.png\n\n\n    image dimensions must be power of 2.\n    load image (thumbnail won't be changed) into channel\n    use iChannel as always\n\n    FB Post: \n    https://www.facebook.com/photo.php?fbid=10153170819997409&set=o.163777690435874&type=3&pnref=story\n**/\n\n","name":"Image","description":"","type":"image"}]}