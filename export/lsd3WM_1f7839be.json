{"ver":"0.1","info":{"id":"lsd3WM","date":"1450183264","viewed":152,"name":"sinwave raycast","username":"Antoine","description":"A simple raycasting shader.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raycast"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/* testRaycat by Antoine - December 2015\n\nThis is my first raycasting shader. Enjoy :)\n*/\n\n/* number of spikes*/\n#define PICK 16.0\n\n\n/* \n======================================================================\nf(x,y) define my surface\nparameters: \n\tfloat x,y the 2D coordinates on my surface\nreturn float: the height of the given point\n*/\nfloat f(float x, float y){\n\treturn 1.0+ cos(atan(y/x)*PICK)*(0.5+sin(3.*(sqrt(x*x+y*y)-iTime)));\n}\n\n/*\n=======================================================================\ncastRay(ro, rd, resT, alt)\nparameters:\n\tvec3 ro: ray origine (in this exempel it's the camera position) \n\tvec3 rd:  ray direction (direction in wich the ray is casted)\n\tout float resT: allow us to know the distance between ro and the collision point\n\tout float alt: allow us to know the position of the collision point\nreturn bool: is the ray has reached my surface ?\ninspired by: https://iquilezles.org/articles/terrainmarching\n*/\nbool castRay( vec3 ro,  vec3 rd, out float resT, out vec3 alt )\n{\n    float delt = 1.0+0.1*cos(iTime);\n    const float mint = 0.001;\n    const float maxt = 20.0;\n    float t = mint;\n    for( int k = 0; k < 1; k += 0 )\n    {\n        vec3 p = ro + rd*t;\n        if( p.y < f( p.x, p.z ) )\n        {\n            resT = t - 0.5*delt;\n            alt = vec3(p.x,p.y,p.z);\n            return true;\n        }\n        t+=delt;\n        if(t >= maxt)\n            break;\n    }\n    return false;\n}\n  \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    /*compute the coordinate UV on our screen */\n\tvec2 uv = fragCoord.xy / iResolution.xy -0.5;\n    \n        \n    /* camera parameters */ \n    vec3 camPos = vec3(-10.0*sin(iTime),10.0,-10.0*cos(iTime)); //camera position\n    vec3 target = vec3(1.0*sin(iTime),1.0+2.0*cos(iTime),1.0*cos(iTime)); // camera target\n   \n    float roll = 0.5*sin(iTime*.2);// camera roll\n    vec3 cw = normalize(target-camPos);// camera direction\n\tvec3 cp = vec3(sin(roll), cos(roll),0.0); // \\\n\tvec3 cu = vec3((cross(cw,cp)));        //  > change screen UV axis according to roll\n\tvec3 cv = vec3((cross(cu,cw)));        // /\n\tvec3 rd = normalize( uv.x*cu + uv.y*cv + 1.*cw ); //ray direction\n \n    \n   \tvec3 alt; // position of the collision point\n   \tfloat resT; // distance to the collision point\n    \n    if(castRay(camPos, rd, resT, alt)) //here we do our raycasting !\n    {\n        /*if the ray touch my surface */\n        \n        float pulse = sin(3.0*(sqrt(alt.x*alt.x+alt.z*alt.z) - iTime));//create a pulse for the colro\n        \n        /* compute the color value */\n    \tfloat red = (1.0-resT/20.0)*alt.y*(0.5+sin(iTime/2.0)/2.0)*(1.0-pulse/2.0);\n        float green = (1.0 - resT/20.0)*alt.y*cos(iTime/3.0)*(1.0-pulse/2.0);\n        float blue = (1.0 - resT/20.0)*alt.y*(0.5+pulse/2.0);\n        \n        /* pixel color */\n        fragColor = vec4(red, green,blue,1.0);\n\t}\n    else\n        /*else, our pixel is black */\n        fragColor = vec4(0,0,0,1);\n\t\n}","name":"Image","description":"","type":"image"}]}