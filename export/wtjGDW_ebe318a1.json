{"ver":"0.1","info":{"id":"wtjGDW","date":"1559662070","viewed":373,"name":"smth like distance semicircle","username":"Imsure1200q_1UWE130","description":"you get the point","likes":0,"published":3,"flags":0,"usePreview":0,"tags":["bl"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define squv *= iResolution.x/iResolution.y;\n#define PI 3.14159\n#define pi PI\n#define twopi 6.2831854\n\nmat2x2 rot( float d ) {\n    return mat2x2 ( cos(d), sin(d),\n                    -sin(d), cos(d) );\n}\n\nfloat map( float a, float a1, float a2, float b1, float b2 ) {\n    return (a - a1) / (a2 - a1) * (b2 - b1) + b1;\n}\n\nfloat totalAtan( float y, float x ) {\n    float v = 0.;\n    \n    if(x>0.)v=atan(y/x);\n    if(y>=0. && x<0.)v=pi+atan(y/x);\n    if(y<0. && x<0.)v=-pi+atan(y/x);\n    if(y>0. && x==0.)v=pi/2.;\n    if(y<0. && x==0.)v=-pi/2.;\n    if (v<0.) v=v+2.*pi;\n    \n    return v;\n}\n\nfloat dsemicircle( vec2 p, vec2 o, float r, float nr, float xr ) {\n    \n    //float rcos = dot(normalize(p-o), vec2(1.,0.));\n    \n    //nr += 0.01;\n    //xr += 0.01;\n    if(nr < 0.) {\n        float abnr = abs(nr);\n        float ffnr = floor( abnr / ( twopi ) ) + 1.;\n        float addition = ffnr * twopi;\n        nr += addition;\n    }\n    //nr += pi;\n    nr = mod(nr, twopi);\n    \n    //nr %= 2.*PI;\n    //xr %= 2.*PI;\n    xr = clamp(xr, 0., twopi);\n    \n    \n    float rd = totalAtan(p.y-o.y, p.x-o.x);\n    float dr = 0.;\n    float xnr = xr+nr;\n    \n    bool isContained = false;\n    \n    if(rd >= nr && rd <= xnr) { isContained = true; }\n    if(xnr >= twopi) {\n        dr = xnr - twopi;\n        if(rd+0.001 <= dr) { isContained = true; }\n    }\n    if(!isContained) {\n        if(rd < xnr) {\n        float rav = (dr+nr)/2.;\n        if(dr == 0.) dr = xnr;\n        //float chr = mix(dr, nr, step(rav, rd));\n        float chr = rd >= rav ? nr : \n            rd-xnr+twopi >= nr-rd ? xnr : nr;\n        rd = chr;\n        } else {\n            float rav = (twopi+xnr)/2.;\n            float chr = rd >= rav ? nr : xnr;\n            rd = chr;\n        }\n    }\n    \n    mat2x2 ro = rot(rd);\n    \n    vec2 rr = ro * vec2(r, 0.);\n    vec2 pr = rr + o;\n    \n    return distance(pr, p);\n    //return rd;\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 mo = iMouse.xy / iResolution.xy;\n    \n    mo.x squv uv.x squv\n\n    // Time varying pixel color\n    ///vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    vec3 col = vec3(pow(sin(dsemicircle( uv, vec2(0.5), distance(mo, vec2(0.5)), iTime, PI)*64.+iTime)/2.+0.5, 0.07));\n    \n        \n    //vec3 col = vec3(dsemicircle(uv, vec2(0.5), distance(mo, vec2(0.5)), 0.)/pi/2.);\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}