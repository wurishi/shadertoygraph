{"ver":"0.1","info":{"id":"4XKGRw","date":"1717433865","viewed":51,"name":"Fork LTT Logo + RadiantMusicVis ","username":"ArthurTent","description":"A merge of two shaders:\nLTT Logo by ChutneyPot \nand\nRadiant Music Visualiser by TekF\n","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["logo","reproduction","ltt","linustechtips"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sXGzn","filepath":"/media/a/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3","previewfilepath":"/media/ap/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3","type":"music","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Fork of LTT Logo by ChutneyPot: https://www.shadertoy.com/view/WsKfDz \n// mixed with Radiant Music Visualiser by TekF: https://www.shadertoy.com/view/4sVBWy\n\n// LTT Logo, December 2020\n// by ChutneyPot\n// https://www.shadertoy.com/view/WsKfDz\n// reference: https://upload.wikimedia.org/wikipedia/commons/7/77/2018_Linus_Tech_Tips_logo.svg\n//--------------------------------------------------------------------------\n#define BLUR 5.0 / iResolution.y\n#define FFT(a) pow(texelFetch(iChannel0, ivec2(a, 0), 0).x, 5.)\n#define PI            3.141592654\n#define ROT(a)        mat2(cos(a), sin(a), -sin(a), cos(a))\n#define TIME          iTime\n#define RESOLUTION    iResolution\n\n// https://stackoverflow.com/questions/15095909/from-rgb-to-hsv-in-opengl-glsl\nconst vec4 hsv2rgb_K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\nvec3 hsv2rgb(vec3 c) {\n  vec3 p = abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www);\n  return c.z * mix(hsv2rgb_K.xxx, clamp(p - hsv2rgb_K.xxx, 0.0, 1.0), c.y);\n}\n// Macro version of above to enable compile-time constants\n#define HSV2RGB(c)  (c.z * mix(hsv2rgb_K.xxx, clamp(abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www) - hsv2rgb_K.xxx, 0.0, 1.0), c.y))\n\n\nconst vec3  grid_color    = HSV2RGB(vec3(0.6, 0.3, 1.0)); \nconst vec3  light0_color  = 16.0*HSV2RGB(vec3(0.6, 0.5, 1.0)); \nconst vec3  light1_color  = 8.0*HSV2RGB(vec3(0.9, 0.25, 1.0)); \nconst vec3  sky0_color    = HSV2RGB(vec3(0.05, 0.65, -0.25)); \nconst vec3  sky1_color    = HSV2RGB(vec3(0.6, 0.5, 0.25)); \nconst vec3  light0_pos    = vec3(1.0, 5.0, 4.0);\nconst vec3  light1_pos    = vec3(3.0, -1.0, -8.0);\nconst vec3  light0_dir    = normalize(light0_pos);\nconst vec3  light1_dir    = normalize(light1_pos);\nconst vec4  planet_sph    = vec4(50.0*normalize(light1_dir+vec3(0.025, -0.025, 0.0)), 10.0);\n\n// fft + ffts by QuantumSuper\nvec4 fft, ffts; //compressed frequency amplitudes\nvoid compressFft(){ //v1.2, compress sound in iChannel0 to simplified amplitude estimations by frequency-range\n    fft = vec4(0), ffts = vec4(0);\n\n    // Sound (assume sound texture with 44.1kHz in 512 texels, cf. https://www.shadertoy.com/view/Xds3Rr)\n    for (int n=0;n<3;n++) fft.x  += texelFetch( iChannel0, ivec2(n,0), 0 ).x; //bass, 0-517Hz, reduced to 0-258Hz\n    for (int n=6;n<8;n++) ffts.x  += texelFetch( iChannel0, ivec2(n,0), 0 ).x; //speech I, 517-689Hz\n    for (int n=8;n<14;n+=2) ffts.y  += texelFetch( iChannel0, ivec2(n,0), 0 ).x; //speech II, 689-1206Hz\n    for (int n=14;n<24;n+=4) ffts.z  += texelFetch( iChannel0, ivec2(n,0), 0 ).x; //speech III, 1206-2067Hz\n    for (int n=24;n<95;n+=10) fft.z  += texelFetch( iChannel0, ivec2(n,0), 0 ).x; //presence, 2067-8183Hz, tenth sample\n    for (int n=95;n<512;n+=100) fft.w  += texelFetch( iChannel0, ivec2(n,0), 0 ).x; //brilliance, 8183-44100Hz, tenth2 sample\n    fft.y = dot(ffts.xyz,vec3(1)); //speech I-III, 517-2067Hz\n    ffts.w = dot(fft.xyzw,vec4(1)); //overall loudness\n    fft /= vec4(3,8,8,5); ffts /= vec4(2,3,3,23); //normalize\n    //for (int n=0;n++<4;) fft[n] *= 1. + .3*pow(fft[n],5.); fft = clamp(fft,.0,1.); //workaround for VirtualDJ, ?any hints for reverting audio limiters appreciated\n}\n\n\nvec3 RGB(vec2 uv)\n{\n    //vec3 result = 0.5 + 0.5 * cos(iTime*4. + uv.xyx + vec3(0,2,4));\n    //vec3 result = 0.5 + 0.5 * cos(iTime*4. + uv.xyy + vec3(0,2,4));\n    //vec3 result = 0.5 + 0.5 * cos(iTime*4. + uv.xyy * vec3(ffts.x, 2.*ffts.w, 4.*fft.y));\n    vec3 result = 0.5 + 0.5  + uv.xyy * vec3(ffts.x, 2.*ffts.w, 4.*fft.y);\n    result.x*=fft.x;\n    result.y*=fft.y;\n    result.z*=fft.z;\n    return result;\n    //return 0.5 + 0.5 * cos(iTime + uv.xyx + vec3(0,2,4));\n}\n\nvec2 rotate(vec2 uv, float deg)\n{\n    float angle = radians(deg);\n    vec2 rot = uv * mat2(cos(angle), sin(angle), -sin(angle), cos(angle));\n    return rot;\n}\n\nfloat rect(vec2 uv, vec2 leftBot, vec2 rightTop)\n{\n    vec2 lb = smoothstep(leftBot, leftBot - BLUR, uv);\n    vec2 rt = smoothstep(rightTop, rightTop - BLUR, uv);\n    vec2 dim = rt - lb;\n    \n    return (min(dim.x, dim.y));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{  \n    compressFft();\n  \tvec2 uv = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n    \n    //uv =rotate(uv,sin(iTime*10.));\n    //uv =rotate(uv,iTime*50.);\n    \n    float circle = length(uv);  \n   \tfloat outer = smoothstep(1.0, 1.0 - BLUR, circle);\n    float inner = smoothstep(0.9, 0.9 - BLUR, circle);\n    float ring =  outer - inner;\n    \n   \tfloat l1 = rect(uv, vec2(-0.65, -0.9), vec2(-0.4, 0.83));\n    float l2 = rect(rotate(uv, 20.0), vec2(-0.66, -0.63), vec2(0.2, -0.38));\n    float l3 = rect(uv, vec2(-0.5, -0.82), vec2(0.32, -0.29));\n    float l = max(l1, min(l2, l3));\n    \n    float t11 = rect(uv, vec2(-0.14, -0.38), vec2(0.11, 0.48));\n    float t12 = rect(rotate(uv, 20.0), vec2(-0.3, 0.4), vec2(0.82, 0.65));\n    float t13 = rect(uv, vec2(-0.32, 0.3), vec2(0.7, 0.86));\n    float t14 = rect(rotate(uv, 20.0), vec2(-0.26, -0.3), vec2(0.28, 0.6));\n    float t1 = max(min(t11, t14), min(t12, t13));\n    \n    float t21 = rect(uv, vec2(0.39, -0.82), vec2(0.64, 0.15));\n    float t22 = rect(rotate(uv, 20.0), vec2(0.15, -0.12), vec2(0.91, 0.13));\n    float t23 = rect(uv, vec2(0.193, -0.23), vec2(0.9, 0.45));\n\tfloat t2 = max(t21, min(t22, t23));\n    \n    float lt = max(l, t1);\n    float ltt = max(lt, t2);\n        \n    vec3 col = vec3(max(min(outer, ltt), ring));\n    \n\n    //float bg = mix(0.0, 1.0, (sin(iTime * 0.5) + 1.0) / 2.0);\n    float bg = 0.;\n    col = mix(vec3(bg), RGB(uv), col);\n    \n    \n    l = length(uv)/length(iResolution.xy/iResolution.y);\n    float a = atan(uv.x,uv.y)+iTime;\n    float s = texture(iChannel0,vec2(abs(fract(5.*a/6.283)*2.-1.),.75)).r;\n    \n    float A = .4;\n    float B = .45;\n    if ( iMouse.z > 0. )\n    {\n        A = iMouse.x / iResolution.x; // strength of chromatic dispersion\n        B = iMouse.y / iResolution.y; // strength of waveform\n    }\n    A *= A; // apply a curve so mouse movements feel better\n    B *= B;\n    \n    fragColor.r = texture(iChannel0,vec2(pow(mix(mix(l,.0,A),    s ,B),2.),.25)).r;\n    fragColor.g = texture(iChannel0,vec2(pow(mix(mix(l,.5,A),(1.-s),B),2.),.25)).r;\n    fragColor.b = texture(iChannel0,vec2(pow(mix(mix(l,1.,A),    s ,B),2.),.25)).r;\n    \n    // tweak the contrast\n    fragColor.rgb = smoothstep(.05,1.,fragColor.rgb+.2*l);\n    fragColor.rgb = pow( fragColor.rgb, vec3(2) );\n    \n    fragColor.a = 1.;\n    \n    \n    fragColor *= vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}