{"ver":"0.1","info":{"id":"wtsfW7","date":"1598735239","viewed":106,"name":"Chaos curves","username":"Kiltun","description":"Based on Code Parade video : https://www.youtube.com/watch?v=fDSIRXmnVvk&t=170s\ncurves + music = peace","likes":3,"published":1,"flags":96,"usePreview":0,"tags":["2d","curves","curve","fade","chaos","codeparade","chaoscurve"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n        \n    vec4 out_color = texture(iChannel0, uv);\n\tfragColor = out_color;\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Xl23DG","filepath":"https://soundcloud.com/kate-dion/the-best-of-classical-music-mozart-beethoven-bach-chopin","previewfilepath":"https://soundcloud.com/kate-dion/the-best-of-classical-music-mozart-beethoven-bach-chopin","type":"musicstream","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"/*\nMade by Kiltun\n\nThis script is not optimized at all ( mostly because of the arrays ) \nIf you have FPS issues, turn down the POINTS_NUMBERS\n\nIt's not real \"Chaos\" because the curves \nfunctions are hard-coded but the fonctions were randomize\n\nNow there is only six not so chaotic curves, \nyou can add more or change them. You will need \nto change their offset and zoom so you can see them clearly\n\n*/\n\n\n\n#define POINTS_RADIUS 0.01\n#define POINTS_NUMBERS 10\n#define POINTS_SPACE .08\n\n#define SPEED 0.1\n\n#define FADING 0.995\n\n#define FONCTIONS_NUMBER 6\n#define TIME_BEFORE_CHANGING 1.\n\n// Point function\nvoid disk(vec2 uv, vec2 center, float radius, vec3 color, inout vec3 pixel) \n{\n\n\tif( length(uv-center) < radius) {\n        \n        pixel = smoothstep(radius, radius - 0.02, length(uv-center)) * color;\n\t}\n}\n\n//// Curves functions\nvec2 fct0( inout vec2 pos, float time)\n{\n     pos.x = pow(pos.x, 2.) - pow(pos.y, 2.) - pow(time, 2.) - pos.x - time;\n     pos.y = pow(pos.y, 2.) + pow(time, 2.) - pos.x*pos.y - pos.y - time;\n\n    return pos;\n}\n\nvec2 fct1( inout vec2 pos, float time)\n{\n    pos.x = -pos.y;\n    pos.y = -pow(pos.y, 2.) + pow(time, 2.) - pos.x - pos.y;\n    \n    return pos;\n}\n\nvec2 fct2( inout vec2 pos, float time)\n{\n    pos.x = pow(pos.x, 2.) - pow(pos.y, 2.) - pow(time, 2.) - pos.y - time;\n    pos.y = -pow(pos.y, 2.) + pow(time, 2.) - pos.x - pos.y;\n    \n    return pos;\n}\n\nvec2 fct3( inout vec2 pos, float time)\n{\n    pos.x = -pow(pos.y, 2.) + pow(time, 2.) - pos.x - pos.y;\n    pos.y = pow(time, 2.) - pos.x - pos.y;\n    \n    return pos;\n}\n\nvec2 fct4( inout vec2 pos, float time)\n{\n     pos.x = pow(pos.x, 2.) - pow(time, 2.) - time*pos.y;\n     pos.y = pow(pos.y, 2.) - pos.x*pos.y - pos.y - time;\n    \n    return pos;\n}\n\nvec2 fct5( inout vec2 pos, float time)\n{\n     pos.x = pow(pos.x, 2.) - pow(pos.y, 2.) - pow(time, 2.) - pos.x*pos.y - time;\n     pos.y = pow(pos.y, 2.) + pow(time, 2.) - pos.x*pos.y - pos.y - time;\n     \n    return pos;\n}\n//__\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = 2.0*vec2(fragCoord.xy - 0.5*iResolution.xy)/iResolution.y;\n    vec2 uv1 = fragCoord.xy / iResolution.xy;\n    float p = 0.2 / (iResolution.y * 0.8);\n    \n    float time = ( mod(abs(iTime - 1.) * SPEED  , TIME_BEFORE_CHANGING) - 0.1);\n\n    vec3 bgColor = vec3(0.0,0.0,0.0);\n\n    vec2 basePos = vec2 (time, time);\n    vec2 pos = vec2(0.,0.);\n\n    vec4 prev_color = texture(iChannel0, uv1);  \n\n    \n    \n\t// The nasty part\n    for(int i = 1; i < POINTS_NUMBERS; i++)\n    {\n        float zoom;\n        vec2 offset;\n\n        for(int y = 0; y < i; y++)\n        {\n\t\t\t// Creates an array of curves at each frame\n            // 6 -> number of curves\n\t\t\tvec2 curves[6] = \n                vec2[](\n                    fct0(pos, time),\n                    fct1(pos, time),\n                    fct2(pos, time),\n                    fct3(pos, time),\n                    fct4(pos, time),\n                    fct5(pos, time)\n                );\n            \n            // The offset param of each curve\n            vec2 offsets[6] =\n                vec2[](\n                    vec2(-0.0,-0.0),\n                    vec2(-0.0,-1.6),\n                    vec2(0.2,-1.2),\n                    vec2(1.6,-0.5),\n                    vec2(-0.3,0.8),\n                    vec2(0.8,-0.2)\n                );\n            \n            // The zoom param of each curve\n            float zooms[6] =\n                float[](\n                    1.9,\n                    3.5,\n                    2.5,\n                    2.5,\n                    1.,\n                    2.\n                );\n            \n\t\t\t// Change which curve is being drawn\n            int currentCurve = int(mod(float(int(iTime * SPEED /TIME_BEFORE_CHANGING)),float(FONCTIONS_NUMBER)));\n            pos = curves[currentCurve];\n                \n    \t\toffset = offsets[currentCurve];\n    \t\tzoom = zooms[currentCurve];\n    \n        }\n\n        pos += vec2(POINTS_SPACE);\n        pos *= zoom;\n     \n        pos += offset;\n\n\t\t// Sort of cheap random color\n        vec3 pointsColor = vec3(0.7,float(i)*0.1,0.1);\n        pointsColor = vec3(float(i)/float(POINTS_NUMBERS), sin(float(i)) + 1.0 * 0.5,float(POINTS_NUMBERS-i)/float(POINTS_NUMBERS));\n\n        disk(uv, pos,POINTS_RADIUS , pointsColor, bgColor );\n        \n\n    }\n\n    prev_color.rgb *= FADING;\n    fragColor = vec4(bgColor + prev_color.rgb,1.0);\n}","name":"Buffer A","description":"","type":"buffer"}]}