{"ver":"0.1","info":{"id":"XtKBzG","date":"1542971470","viewed":492,"name":"3d Glass with caustic modified","username":"tholzer","description":"Slightly modified version of [url]https://www.shadertoy.com/view/4lB3D1[/url] originally created by andregc.","likes":16,"published":1,"flags":64,"usePreview":0,"tags":["raytracing","raymarching","reflection","refraction","glass","caustic"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"MlB3zD","filepath":"https://soundcloud.com/bestmusicingames/plains-the-chinese-orchestra-mix-shadow-of-the-beast-2015-remix-album","previewfilepath":"https://soundcloud.com/bestmusicingames/plains-the-chinese-orchestra-mix-shadow-of-the-beast-2015-remix-album","type":"musicstream","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n//---------------------------------------------------------\n// Shader:   3dGlassWithCaustic.glsl   2018-11-23\n//\n// original: https://www.shadertoy.com/view/XljGWR by andregc\n//\n// Distance function, camera setup and base for raymarching\n//           https://www.shadertoy.com/view/Xds3zN by IQ\n//\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//---------------------------------------------------------\n\n#define calcRecursion rec3  // use n rays levels (rays1 to rays6): total  RAY_COUNT = 2^n-1\n\n#define DIST_EPSILON 0.005\n\n#define ID_SKY 2.001\n#define ID_FLOOR 1.\n#define ID_LIGHT 1.001\n#define ID_GLASS_WALL 2.000\n#define ETA 0.85\n#define PI 3.14159265359\n\n#define DENSITY_MIN 0.1\n#define DENSITY_MAX 0.1\n#define MATERIAL_COLOR vec3(0.05, 0.08, 0.1)\n#define AIR_COLOR vec3(0.2, 0.3, 0.5)\n\n//#define GLASS_1_COLOR vec3(0.8,0.2,0.6)\n#define GLASS_1_COLOR vec3(1.2, 1., 0.8)*(1.-0.2* mod( floor(5.0*p.z) + floor(5.1*p.x) + floor(5.1*p.y), 2.0))\n//#define GLASS_1_COLOR vec3(0.8,1.,0.8)*(0.6+0.4*noise(p.xz*30. + p.yz*23.))\n\nvec3 LIGHT_DIR = normalize(vec3(-0.6,0.7,-0.3));\n//-------------------------------------------------------------------------------\n\nfloat rand(vec2 n) { return fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453); }\n\nfloat noise(vec2 n) {\n\tconst vec2 d = vec2(0.0, 1.0);\n\tvec2 b = floor(n), f = smoothstep(vec2(0.0), vec2(1.0), fract(n));\n\treturn mix(mix(rand(b), rand(b + d.yx), f.x), mix(rand(b + d.xy), rand(b + d.yy), f.x), f.y);\n}\n\nstruct HitData {\n    float dist;\n    vec3 normal;\n    float mat;\n    vec3 p;\n};\n\nstruct Ray {\n    vec3 rd;\n    HitData hit;\n    vec3 col;\n    float share;\n    float eta;\n};\n\n//-------------------------------------------------------------------------------\n// primitives:  https://www.shadertoy.com/view/Xds3zN\n// info: https://iquilezles.org/articles/distfunctions\n//-------------------------------------------------------------------------------\nfloat sdPlane( vec3 p ) {return p.y;}\n\nfloat sdSphere( vec3 p, float radius) {return (length(p)-radius);}\n\n// Rounded Cylinder: ra=radius, rb=roundingRadius, h=height\nfloat sdRoundedCylinder( vec3 p, float ra, float rb, float h )\n{\n  vec2 d = vec2( length(p.xz)-2.0*ra+rb, abs(p.y) - h );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb;\n}\n\n// Box - exact: b=dimension\nfloat sdBox (vec3 p, vec3 b)\n{\n  vec3 d = abs(p) - b;\n  return (min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0)));\n}\n\n// Rounded Box: b=dimension, r=roundingRadius\nfloat sdRoundedBox( vec3 p, vec3 b, float r )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0)) - r + min(max(d.x,max(d.y,d.z)),0.0);\n}\n\n// rounded box: b=size, r=roundingRadius\nfloat roundedBox (vec3 p, vec3 b, float r) { return abs(length(max(abs(p)-b,0.0))-r); }\n\nfloat sdTorus (vec3 p, vec2 t) {return length(vec2(length(p.xz)-t.x,p.y))-t.y;}\n\nfloat sdCone (vec3 p, vec2 c) {return dot(c, vec2(length(p.xz),p.y));}   // c must be normalized\n\n//---------\nvec3 opU (vec3 d1, vec3 d2) { return (d1.x < d2.x) ? d1 : d2; }  // union\n\nvec3 opS (vec3 d1, vec3 d2) { return -d1.x > d2.x  ? d2 : d1; }  // subtraction\n\n//---------\nmat2 rotation(float angle) \n{\n    float c = cos(angle), s = sin(angle);\n    return mat2(c, s, -s, c);\n}\n\n//-------------------------------------------------------------------------------\nvec3 map(in vec3 pos)\n{\n  vec3 res = vec3(sdPlane(pos), ID_FLOOR, -1. );\n\n  res = opU(res, vec3((sdRoundedCylinder (pos-vec3(0.5,0.5,-0.2), 0.15, 0.05, 0.4)), ID_GLASS_WALL, ETA));\n\n  res = opU(res, vec3(sdSphere (pos-vec3(-0.2,0.31,0.4),0.2+0.1*sin(iTime)),ID_GLASS_WALL, ETA));\n\n  res = opU(res, vec3((sdCone  (pos-vec3(-0.7,0.49,-0.2), vec2(0.4,0.3))), ID_GLASS_WALL, ETA));\n\n  mat2 rot1 = rotation(iTime*1.2);  vec3 pr = pos.yxz - vec3(0.4,-0.1,-0.7);\n  pr.yz *= rot1;\n  pr.xy *= rot1;\n  pr.xz *= rot1;\n  res = opU(res, vec3(sdTorus      (pr, vec2(0.3,0.1)),ID_GLASS_WALL, ETA));\n\n  res = opU(res, vec3(sdRoundedBox (pos-vec3(0.8,0.4,0.5), vec3(0.14), 0.06+0.02*sin(iTime)),ID_GLASS_WALL, ETA));\n\n  res.x = abs(res.x);\n  return res;\n}\n//-------------------------------------------------------------------------------\nvec3 calcNormal( in vec3 pos )\n{\n\tvec3 eps = vec3( 0.0001, 0.0, 0.0 );\n    float d = map(pos).x;\n    return normalize( vec3(\n\t    map(pos+eps.xyy).x - d,\n\t    map(pos+eps.yxy).x - d,\n\t    map(pos+eps.yyx).x - d));\n}\n\nHitData findIntersection(vec3 p, vec3 rd)\n{\n    float tmin = 0.000;\n    float tmax = 50.0;\n\n    float precis = DIST_EPSILON;\n    float t = tmin;\n    float eta = -1.;\n    vec3 res;\n    for( int i=0; i<50; i++ )\n    {\n\t  \tres = map(p+rd*t);\n        eta = res.z;\n        if( res.x<precis || t>tmax ) break;\n        t += res.x;\n    }\n\n    p += rd*t;\n    // calculate normal in the father point to avoid artifacts\n    vec3 n = calcNormal(p-rd*(precis-res.x));\n    return HitData(t, n, res.y, p);\n}\n\n//-------------------------------------------------------------------------------\nvec3 refractCaustic(vec3 p, vec3 rd, vec3 ld, float eta)\n{\n    vec3 cl = vec3(1);\n    for(int j = 0; j < 2; ++j)\n    {\n        HitData cp = findIntersection(p, rd);\n        if (length(cp.p) > 2.) {\n            break;\n        }\n        cl *= GLASS_1_COLOR;//*(abs(dot(rd, cp.normal)));\n        vec3 normal = sign(dot(rd, cp.normal))*cp.normal;\n        rd = refract(rd, -normal, eta);\n\n        p = cp.p;\n        eta = 1./eta;\n        p += normal*DIST_EPSILON*2.;\n    }\n    float d = clamp( dot( rd, ld ), 0.0, 1.0 );\n    return smoothstep(0.99, 1., d)*cl;\n}\n\nvec3 caustic(vec3 p,vec3 ld, Ray ray)\n{\n    vec3 VX = normalize(cross(ld, vec3(0,1,0)));\n    vec3 VY = normalize(cross(ld, VX));\n    vec3 c = vec3(0);\n\n    const int N = 3;\n    p += ray.hit.normal*DIST_EPSILON;\n\n    for(int i = 0; i < N;++i) {\n\n        float n1 = rand(p.xz*10. + vec2(iTime*2. +float(i)*123.));\n        float n2 = rand(p.xz*15. +vec2(iTime*3. +float(i)*111.));\n\n        vec3 rd = ld + (VX*(n1-0.5)+VY*(n2-0.5))*0.1;\n     // rd = ld;\n        rd = normalize(rd);\n\n        vec3 cl = refractCaustic(p, rd, ld, ray.eta);\n\n      \tc += cl* dot(rd,ray.hit.normal);\n    }\n    return c*3./float(N);\n}\n\n// lightning is based on https://www.shadertoy.com/view/Xds3zN\nvec3 getFloorColor(in Ray ray)\n{\n    vec3 col = vec3(0);\n    vec3 pos = ray.hit.p;\n    vec3 ref = reflect( ray.rd, ray.hit.normal );\n\n    float f = mod( floor(5.0*pos.z) + floor(5.0*pos.x), 2.0);\n    col = 0.4 + 0.1*f*vec3(1.0);\n\n    float dif = clamp( dot( ray.hit.normal, LIGHT_DIR ), 0.0, 1.0 );\n    vec3 brdf = vec3(0.0);\n    brdf += caustic(pos, LIGHT_DIR, ray);\n    brdf += 1.20*dif*vec3(1.00,0.90,0.60);\n    col = col*brdf;\n    // exclude branching\n    col *= (ID_GLASS_WALL-ray.hit.mat);\n\n    return col;\n}\n\nvec3 getColor(in Ray ray)\n{\n    vec3 p = ray.hit.p ;// can be used by SURFACE_COLOR define\n    vec3 c1 = ray.col * GLASS_1_COLOR;\n    vec3 c2 = getFloorColor(ray);\n    // exclude branching\n    return mix(c2, c1, ray.hit.mat - ID_FLOOR);\n}\n\n//-------------------------------------------------------------------------------\nvec3 getRayColor(Ray ray)\n{\n    float d = mix(DENSITY_MIN, DENSITY_MAX, (ray.eta - ETA)/(1./ETA-ETA));\n    vec3 matColor = mix(AIR_COLOR, MATERIAL_COLOR, (ray.eta - ETA)/(1./ETA-ETA));\n    vec3 col = getColor(ray);\n\n    float q = exp(-d*ray.hit.dist);\n    col = col*q+matColor*(1.-q);\n    return col*ray.share;\n}\n\nvoid getRays(inout Ray ray, out Ray r1, out Ray r2) {\n     vec3 p = ray.hit.p;\n    float cs = dot(ray.hit.normal, ray.rd);\n    // simple approximation\n    float fresnel = 1.0-abs(cs);\n//\tfresnel = mix(0.1, 1., 1.0-abs(cs));\n    float r = ray.hit.mat - ID_FLOOR;\n     vec3 normal = sign(cs)*ray.hit.normal;\n    vec3 refr = refract(ray.rd, -normal, ray.eta);\n    vec3 refl = reflect(ray.rd, ray.hit.normal);\n    vec3 z = normal*DIST_EPSILON*2.;\n    p += z;\n    r1 = Ray(refr, findIntersection(p, refr),  vec3(0),(1.-fresnel)*r, 1./ray.eta);\n    p -= 2.*z;\n    r2 = Ray( refl, findIntersection(p, refl), vec3(0),r*fresnel, ray.eta);\n}\n\n// set of \"recursion\" functions\n\nvoid rec1(inout Ray ray)\n{\n    ray.col += getRayColor(ray);\n}\n\n\nvoid rec2(inout Ray ray)\n{\n    Ray r1,r2;\n    getRays(ray, r1, r2);\n    ray.col += getRayColor(r1);\n    ray.col += getRayColor(r2);\n}\n\nvoid rec3(inout Ray ray)\n{\n    Ray r1,r2;\n    getRays(ray, r1, r2);\n    rec2(r1);\n    ray.col += getRayColor(r1);\n    // use first level of reflection rays only to improve performance\n    rec1(r2);\n    ray.col += getRayColor(r2);\n}\n\nvoid rec4(inout Ray ray)\n{\n    Ray r1,r2;\n    getRays(ray, r1, r2);\n    rec3(r1);\n    ray.col += getRayColor(r1);\n    // use first level of reflection rays only to improve performance\n    rec1(r2);\n    ray.col += getRayColor(r2);\n}\n\nvoid rec5(inout Ray ray)\n{\n    Ray r1,r2;\n    getRays(ray, r1, r2);\n    rec4(r1);\n    ray.col += getRayColor(r1);\n    // use first level of reflection rays only to improve performance\n    rec1(r2);\n    ray.col += getRayColor(r2);\n}\n\nvoid rec6(inout Ray ray)\n{\n    Ray r1,r2;\n    getRays(ray, r1, r2);\n    rec5(r1);\n    ray.col += getRayColor(r1);\n    // use only first level of reflection to improve performance\n    rec1(r2);\n    ray.col += getRayColor(r2);\n}\n\nvec3 render(vec3 p, vec3 rd)\n{\n    HitData hit = findIntersection(p, rd);\n    Ray ray = Ray( rd, hit, vec3(0), 1., ETA);\n    calcRecursion(ray);\n    ray.col = getRayColor(ray);\n    return ray.col;\n}\n\n// https://www.shadertoy.com/view/Xds3zN\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n  vec3 cw = normalize(ta-ro);\n  vec3 cp = vec3(sin(cr), cos(cr),0.0);\n  vec3 cu = normalize( cross(cw,cp) );\n  vec3 cv = normalize( cross(cu,cw) );\n  return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = fragCoord.xy / iResolution.xy-0.5;\n    uv.x *= iResolution.x/iResolution.y;\n  vec2 mo = iMouse.xy/iResolution.xy;\n  // this strange construction is used to define initial view angle\n  mo = mix(vec2(0.6,0.3),mo, sign(mo.x+mo.y));\n  mo.y += 0.02;\n  mo.y *= 1.5;\n  float rotTime = sin(iTime*0.04);\n  mo.x *= 10.;\n  float R = 4.3;   // view distance\n  float Y = sin(mo.y);\n  float X = cos(mo.y);  // ro = ray origin\n  vec3 ro = vec3(cos(rotTime + mo.x)*X, Y, X*sin(rotTime + mo.x) )*R;\n  vec3 ta = vec3( 0,0.4,0);\n\n  // camera-to-world transformation\n  mat3 ca = setCamera( ro, ta, 0. );\n  vec3 rd = ca * normalize( vec3(uv.xy,2.5) ); // ray direction\n\n  // get raymarching color\n  vec3 c = render(ro, rd);\n\n  fragColor = vec4(c, 1);\n}\n","name":"Image","description":"","type":"image"}]}