{"ver":"0.1","info":{"id":"lfjGzD","date":"1703922037","viewed":22,"name":"Super Epic Ray Marched Water","username":"Soulex","description":"Epic water shader","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["3d","raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS 100\n#define MAX_DISTANCE 100.\n#define MIN_DISTANCE 0.001\n\n#define COLOR_SPACE_LUMINANCE vec4(0.0396819152, 0.458021790, 0.00609653955, 1)\n\nconst float _FogDistance = .02;\n\nfloat waveRands[10] = float[10]\n(12938.102, 93828.042, 78123.193, \n9728.156, 129127.1293, 27905893.02398, \n128937129.239, 288199.01238, 21939123.19237, \n123829.1203);\n\nfloat DotClamped(vec3 inputOne, vec3 inputTwo)\n{\n    return clamp(dot(inputOne, inputTwo), 0., 1.);\n}\nfloat Random(vec2 co)\n{\n    return fract(sin(dot(co, vec2(12.9898, 78.233))) * 43758.5453123);\n}\nfloat SDFSphere(vec3 p)\n{\n    return length(p - vec3(0, 1.5, 6)) - 1.;\n}\nfloat SDFPlane(vec3 p)\n{\n    float iter = 0.;\n    float h = 0.;\n    float t = 1.;\n    for (int i = 0; i < 5; i++)\n    {\n        vec2 wave = vec2(sin(t * p.x + p.y + iTime * 1.5 + iter) + cos((p.x + iTime)/4.), \n        cos(t * p.z + p.x + iTime * 1.5 + iter) + sin((p.z + iTime)/4.)) + sin(cos(iTime + p.x/10.) + p.z/10.)/5.;\n        \n        float w = (wave.x + wave.y + 1.)/2.;\n        h += w/t * 10.;\n        iter += waveRands[i];\n        t += float(i);\n    }\n    h/=(t * 5.);\n    return p.y - h;\n}\nfloat GetSDFWorld(vec3 p)\n{\n    return SDFPlane(p);\n}\nvec3 GetNormal(vec3 p)\n{\n    vec2 e = vec2(1e-1, 0);\n    vec3 n = GetSDFWorld(p) - vec3(\n    GetSDFWorld(p - e.xyy),\n    GetSDFWorld(p - e.yxy),\n    GetSDFWorld(p - e.yyx));\n\n    return normalize(n);\n}\nfloat RayMarch(vec3 ro, vec3 rd)\n{\n    float dO;\n    float dS;\n    \n    for(int i = 0; i < MAX_STEPS; i++)\n    {\n        vec3 p = ro + rd * dO;\n        \n        dS = GetSDFWorld(p);\n        \n        dO += dS;\n        \n        if(dO > MAX_DISTANCE || dS < MIN_DISTANCE)\n            break;\n    }\n    return dO;\n}\nvec4 CorrectColor(vec4 inputColor)\n{\n    float luminosity = dot(inputColor.rgb, COLOR_SPACE_LUMINANCE.rgb);\n\n    return vec4((inputColor.rgb - luminosity) * clamp(vec3(1., 1., 1.) - inputColor.rgb, 0.45, 1.) * 3.5 + luminosity, 1.);\n}\nvec4 GetColor(vec3 p, vec3 camPos)\n{\n    vec3 normal = GetNormal(p);\n    vec3 lightDir = -normalize(vec3(50., 50., 100.));\n    \n    vec3 viewDir = normalize(camPos - p);\n    float fresnel = DotClamped(normal, viewDir);\n    \n    vec3 heightColor = mix(vec3(0.2, 0.6, 1) * 0.1, vec3(0.2, 0.9, 1) * 0.8, clamp(pow(p.y, 2.), 0., 1.));\n    vec3 fresnelColor = mix(heightColor, vec3(0.3, 0.8, 1), fresnel);\n    \n    vec3 diffuse = DotClamped(normal, lightDir) * fresnelColor;\n    vec3 reflectionDir = reflect(lightDir, normal);\n    float specular = DotClamped(viewDir, reflectionDir);\n    \n    specular = clamp(pow(specular, 100.), 0., 1.);\n    \n    vec4 col = normalize(vec4(diffuse, 1.) + vec4(0.35, 0.8, 1, 0) * 0.3);\n    col = mix(col, vec4(1., 1., 1., 1.), specular);\n    return col;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec3 ro = vec3(0., 3.5, 0.);\n    \n    vec3 rd = normalize(vec3((fragCoord * 2. - iResolution.xy) / min(iResolution.x, iResolution.y), 1.));\n    \n    float d = RayMarch(ro, rd);\n    vec3 p = ro + rd * d;\n    vec4 col = vec4(mix(vec3(0.7,0.8,0.8), vec3(0.8, 0.9, 1.) * 0.7, pow(abs(rd.y), 0.25)), 1.);\n    \n    float fog;\n    if(d >= MAX_DISTANCE)\n    {\n        fog = 0.;\n    }  \n    else\n    {\n        fog = 1. - exp(-_FogDistance * d);\n        col = GetColor(p, ro);\n    }\n\n    fragColor = CorrectColor(mix(col, vec4(0.7,0.8,0.8,1.), fog));\n}","name":"Image","description":"","type":"image"}]}