{"ver":"0.1","info":{"id":"4dy3Dw","date":"1455614891","viewed":717,"name":"breaking wave curve","username":"hsiangyun","description":"Implementation of http://wscg.zcu.cz/wscg2003/Papers_2003/K11.pdf\n","likes":14,"published":1,"flags":0,"usePreview":0,"tags":["wave","curve","procedure"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Created by Hsiang Yun 2016 \n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// Implementation of http://wscg.zcu.cz/wscg2003/Papers_2003/K11.pdf\n// \n\n#define PI 3.1415926\n\nvec2 rot ( vec2 p, float phi )\n{\n    float s = sin(phi);\n    float c = cos(phi);\n    return mat2(vec2(c,s),vec2(-s,c)) * p ;\n}    \n\nfloat sdLine( vec2 p, vec2 a, vec2 b, float r )\n{\n    vec2 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\n// s : left to right :  [0.0..1.0] \n// s1 : backwave [0.0..0.5], frontwave [0.5..1.0] \n// s2 : backwave [0.0..1.0], frontwave [1.0..0.0]\n\n// k1: parameter for computing s1, s2 \n// k2: controls the height of unrotated wave\n// k3,k4 : make the wave sharper\n// k5, k6 : control the magnitude of rotation \n// k7 : controls the max height of the wave \n\nvec2 waveshape ( float k1, float k2, float k3,float k4,float k5,float k6,float k7, float s, float t, float s1, float s2 ) \n{\n    // the cosine shape of the wave \n    float z1 = k2 * ( 1.0 + cos(PI *(s2-1.0))) *0.5 + k3 * pow(s2,k4);\n    // set the rotation angle \n    float phi = PI * k5 * pow(s2, k6) *0.5;       \n    // rotate clockwise around the center (0.5,0.0)\n    vec2 p = vec2(s1,z1);\n    vec2 o = vec2(0.5, 0.0);   \n    p  = rot(p-o, -phi ) + o ;\n    p.y *= k7;\n    return p ;    \n}\n\nvec2 backwave ( float k1, float k2, float k3,float k4,float k5,float k6,float k7, float s, float t ) \n{\n \tfloat s2 = pow(2.0*s,k1);\n    float s1 = s2 / 2.0; \n    return waveshape ( k1,k2,k3,k4,k5,k6,k7,s,t, s1, s2 ) ;    \n}\n\nvec2 frontwave ( float k1, float k2, float k3,float k4,float k5,float k6,float k7, float s, float t ) \n{\n    float f = pow(2.0*s-1.0, k1);\n    float s1 = (1.0 + f) * 0.5;\n    float s2 = 1.0 - f;\n    return waveshape ( k1,k2,k3,k4,k5,k6,k7,s,t, s1, s2 );\n}\n\n\nvec2 round_front( float s, float t )\n{\n    return frontwave(1.0 + t,0.25,.0,.0,.0,.0,0.8*t,s,t);\n}\n\nvec2 round_back( float s, float t )\n{\n    return backwave(1.0 - 0.3 *t ,0.25,.0,.0,.0,.0,0.8*t,s,t);\n}\n\n\nvec2 breaking_front( float s, float t )\n{\n    float k1 = 2.0;\n    float k2 = (1.0- pow(t,0.85)) *0.25;\n    float k3 = pow(t,0.85) *0.25;\n    float k4 = 4.0;\n    float k5 = pow(t,1.5);\n    float k6 = 16.0;\n    float k7 = (4.0 + t) * 0.2;      \n    return frontwave(k1,k2,k3,k4,k5,k6,k7,s,t);\n}\n\nvec2 breaking_back( float s, float t )\n{\n    float k1 = 0.7 - 0.2 *t ;\n    float k2 = 0.25;\n    float k3 = 0.0;\n    float k4 = 0.0;\n    float k5 = pow(t,1.5);\n    float k6 = 4.0;\n    float k7 = (4.0 + t) * 0.2;\n \treturn backwave(k1,k2,k3,k4,k5,k6,k7,s,t);\n}\n\nvec2 collapsing_front( float s, float t )\n{\n    float k1 = 2.0;\n    float k2 = .0;\n    float k3 = (1.0-t) * 0.25; \n    float k4 = 4.0;\n    float k5 = 1.0;\n    float k6 = 16.0;\n    float k7 = 1.0 - t; \n \treturn frontwave(k1,k2,k3,k4,k5,k6,k7,s,t);\n}\n\nvec2 collapsing_back( float s, float t )\n{\n    float k1 = 0.5;\n    float k2 = 0.25;\n    float k3 = pow(t,0.7) * 0.5;\n    float k4 = 40.0;\n    float k5 = 1.0;\n    float k6 = 4.0;\n    float k7 = 1.0 - t; \n    return backwave(k1,k2,k3,k4,k5,k6,k7,s,t);\n}\n\n\nvec2 round_profile ( float s, float t ) \n{\n\treturn (s <0.5) ? round_back(s,t) : round_front(s,t) ;        \n}\n\nvec2 break_profile( float s, float t )\n{\n    return (s <0.5) ? breaking_back(s,t) : breaking_front(s,t) ;        \n}\n\nvec2 collapse_profile ( float s, float t)\n{\n    return (s <0.5) ? collapsing_back(s,t) : collapsing_front(s,t) ;        \n}\n\nvec2 wave_profile ( float s , float t ) \n{\n    vec2 muv = iMouse.xy / iResolution.xy;\n    vec2 p = vec2(0.0);\n    \n    t = t + muv.y *3.0;\n    t = mod( t , 3.0);\n        \n    if ( t < 1.0 ) \n    {\n        p = round_profile ( s, t);\n    }\n    else if ( t < 2.0)\n    {\n        p = break_profile( s, t - 1.0);\n    }\n    else\n    {\n        p = collapse_profile( s, t - 2.0);\n    }\n    \n    p.y *= 2.0;\n    p.y += 0.3;\n    \n    return p;\n}\n\nconst int steps = 150;\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy ; \n    \n    vec2 p = wave_profile ( 0.0, iTime );\n    \n    float d = 1.0;\n    float delta = 1.0/float(steps);\n    \n    for ( int i = 1 ; i < steps ; ++i)\n    {\n        vec2 q = wave_profile ( float(i) * delta, iTime );\n        d = min(d,sdLine ( uv, p, q, 0.002));\n        p = q;\n    }\n        \n    fragColor = vec4(smoothstep(0.01,0.0,d));\n \n\n}","name":"Image","description":"","type":"image"}]}