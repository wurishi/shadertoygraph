{"ver":"0.1","info":{"id":"3dBBDh","date":"1589895611","viewed":159,"name":"colorful final stellated icosa","username":"darkfox","description":"Final stellation of the icosahedron.","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","polyhedron","stellation"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// I like polyhedron. It's beautiful.\n// reference:https://www.shadertoy.com/view/XtXGRS  thanks!!\n\n// This is the Final stellation of the icosahedron.\n// reference:https://en.wikipedia.org/wiki/Final_stellation_of_the_icosahedron\n\n// constants.\n#define PI\t3.14159\n\n// face vectors of icosahedron.\n// top:(0.0, 1.0, 0.0), inner 5 faces, outer 5 faces.\nconst vec3 f20_1 = vec3(-0.60706, 0.79465, 0.0);\nconst vec3 f20_2 = vec3(-0.18759, 0.79465, 0.57735);\nconst vec3 f20_3 = vec3(0.49112, 0.79465, 0.35682);\nconst vec3 f20_4 = vec3(0.49112, 0.79465, -0.35682);\nconst vec3 f20_5 = vec3(-0.18759, 0.79465, -0.57735);\nconst vec3 f20_6 = vec3(-0.98225, 0.18759, 0.0);\nconst vec3 f20_7 = vec3(-0.30353, 0.18759, 0.93417);\nconst vec3 f20_8 = vec3(0.79465, 0.18759, 0.57735);\nconst vec3 f20_9 = vec3(0.79465, 0.18759, -0.57735);\nconst vec3 f20_10 = vec3(-0.30353, 0.18759, -0.93417);\n// vertice vectors of icosahedron.\nconst vec3 v20_1 = vec3(0.0, 1.0, 0.0);\nconst vec3 v20_2 = vec3(0.89443, 0.44721, 0.0);\nconst vec3 v20_3 = vec3(0.27639, 0.44721, -0.85065);\nconst vec3 v20_4 = vec3(-0.72361, 0.44721, -0.52573);\nconst vec3 v20_5 = vec3(-0.72361, 0.44721, 0.52573);\nconst vec3 v20_6 = vec3(0.27639, 0.44721, 0.85065);\n// from hsb to rgb.\nvec3 getRGB(float h, float s, float b){\n  vec3 c = vec3(h, s, b);\n  vec3 rgb = clamp(abs(mod(c.x * 6.0 + vec3(0.0, 4.0, 2.0), 6.0) - 3.0) - 1.0, 0.0, 1.0);\n  rgb = rgb * rgb * (3.0 - 2.0 * rgb);\n  return c.z * mix(vec3(1.0), rgb, c.y);\n}\n// rotation of vector.\nvec2 rotate(vec2 p, float t){\n  return p * cos(t) + vec2(-p.y, p.x) * sin(t);\n}\n// rotation with X axis.\nvec3 rotateX(vec3 p, float t){\n  p.yz = rotate(p.yz, t);\n  return p;\n}\n// rotation with Y axis.\nvec3 rotateY(vec3 p, float t){\n  p.zx = rotate(p.zx, t);\n  return p;\n}\n// rotation of Z axis.\nvec3 rotateZ(vec3 p, float t){\n  p.xy = rotate(p.xy, t);\n  return p;\n}\n// Final stellation of the icosahedron.\nfloat finalStellaIcosa(vec3 p, float size){\n  float d1 = size; // for vertices... base of 60 corns.\n  float d2 = size * 0.41947; // for faces... sides of 60 corns.\n\n  float v1 = abs(dot(p, v20_1)) - d1;\n  float v2 = abs(dot(p, v20_2)) - d1;\n  float v3 = abs(dot(p, v20_3)) - d1;\n  float v4 = abs(dot(p, v20_4)) - d1;\n  float v5 = abs(dot(p, v20_5)) - d1;\n  float v6 = abs(dot(p, v20_6)) - d1;\n\n  float f1 = abs(dot(p, f20_1)) - d2;\n  float f2 = abs(dot(p, f20_2)) - d2;\n  float f3 = abs(dot(p, f20_3)) - d2;\n  float f4 = abs(dot(p, f20_4)) - d2;\n  float f5 = abs(dot(p, f20_5)) - d2;\n  float f6 = abs(dot(p, f20_6)) - d2;\n  float f7 = abs(dot(p, f20_7)) - d2;\n  float f8 = abs(dot(p, f20_8)) - d2;\n  float f9 = abs(dot(p, f20_9)) - d2;\n  float f10 = abs(dot(p, f20_10)) - d2;\n\n  // corn group 1.\n  float result = max(-v2, max(f6, max(f7, f10)));\n  result = min(result, max(-v3, max(f7, max(f8, f6))));\n  result = min(result, max(-v4, max(f8, max(f9, f7))));\n  result = min(result, max(-v5, max(f9, max(f10, f8))));\n  result = min(result, max(-v6, max(f10, max(f6, f9))));\n\n  // corn group 2.\n  result = min(result, max(-v5, max(f2, max(f5, f10))));\n  result = min(result, max(-v3, max(f10, max(f2, f1))));\n  result = min(result, max(-v1, max(f1, max(f10, f7))));\n  result = min(result, max(-v6, max(f7, max(f1, f5))));\n  result = min(result, max(-v4, max(f5, max(f7, f2))));\n\n  // corn group 3.\n  result = min(result, max(-v5, max(f1, max(f8, f3))));\n  result = min(result, max(-v6, max(f3, max(f1, f6))));\n  result = min(result, max(-v4, max(f6, max(f3, f2))));\n  result = min(result, max(-v1, max(f2, max(f6, f8))));\n  result = min(result, max(-v2, max(f8, max(f2, f1))));\n\n  // corn group 4.\n  result = min(result, max(-v1, max(f3, max(f7, f9))));\n  result = min(result, max(-v3, max(f9, max(f3, f2))));\n  result = min(result, max(-v6, max(f2, max(f9, f4))));\n  result = min(result, max(-v2, max(f4, max(f2, f7))));\n  result = min(result, max(-v5, max(f7, max(f4, f3))));\n\n  // corn group 5.\n  result = min(result, max(-v1, max(f4, max(f8, f10))));\n  result = min(result, max(-v4, max(f10, max(f4, f3))));\n  result = min(result, max(-v2, max(f3, max(f10, f5))));\n  result = min(result, max(-v3, max(f5, max(f3, f8))));\n  result = min(result, max(-v6, max(f8, max(f5, f4))));\n\n  // corn group 6.\n  result = min(result, max(-v2, max(f9, max(f1, f5))));\n  result = min(result, max(-v1, max(f5, max(f9, f6))));\n  result = min(result, max(-v5, max(f6, max(f5, f4))));\n  result = min(result, max(-v3, max(f4, max(f6, f1))));\n  result = min(result, max(-v4, max(f1, max(f4, f9))));\n\n  return result;\n}\n// map function.\nfloat map(vec3 p){\n  return finalStellaIcosa(p, 0.5);\n}\n// normal vector.\nvec3 calcNormal(vec3 p){\n  const vec2 eps = vec2(0.0001, 0.0);\n  // mathematical procedure.\n  vec3 n;\n  n.x = map(p + eps.xyy) - map(p - eps.xyy);\n  n.y = map(p + eps.yxy) - map(p - eps.yxy);\n  n.z = map(p + eps.yyx) - map(p - eps.yyx);\n  return normalize(n);\n}\n// ray marching.\nfloat march(vec3 ray, vec3 camera){\n  const float maxd = 20.0; // limit distance.\n  const float precis = 0.001; // precision.\n  const int ITERATION = 64; // iteration limit.\n  float h = precis * 2.0; // heuristic. \n\n  // marching until arrive at 20.0 .\n\n  float t = 0.0;\n\n  // if marching failed, returns -1.0(negative value).\n  float result = -1.0;\n\n  for(int i = 0; i < ITERATION; i++){\n    if(h < precis || t > maxd){ break; }\n  // add heuristic value.\n    h = map(camera + t * ray);\n    t += h;\n  }\n// if t < maxd, marching success. returns t.\n  if(t < maxd){ result = t; }\n  return result;\n}\n// camera rotation.\nvoid transform(inout vec3 p){\n// AUTO MODE.\n  p = rotateX(p, PI * iTime * 0.3);\n  p = rotateY(p, PI* iTime * 0.15);\n}\n// background color(grey).\nvec3 getBackground(vec2 p){\n  vec3 color = vec3(0.85);\n  return color * (0.4 + p.y * 0.3);\n}\n// main code.\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n  // y:-1.0ï½ž1.0\n  vec2 p = (2.0 * fragCoord.xy - iResolution.xy) / min(iResolution.x, iResolution.y);\n  // get background color.\n  vec3 color = getBackground(p);\n  // set ray vector.\n  vec3 ray = normalize(vec3(p, -1.8));\n  // set camera position. (on z axis, 4.5)\n  vec3 camera = vec3(0.0, 0.0, 4.5);\n  // lighting.\n  vec3 light = normalize(vec3(0.5, 0.8, 3.0));\n  // rotation(ray, camera, lighting, all.)\n  transform(ray);\n  transform(camera);\n  transform(light);\n  // get marching result.\n  float t = march(ray, camera);\n  // if t is negative, color is background color.\n  if(t > -0.001){\n    vec3 pos = camera + t * ray; // on the surface.\n    vec3 n = calcNormal(pos); // get normal vector.\n    // lighting effect.\n    float diff = clamp((dot(n, light) + 0.5) * 0.7, 0.3, 1.0);\n    // coloring.\n    float hue = (atan(pos.z, pos.x) + PI) * 0.5 / PI;\n    float saturation = (1.0 - atan(length(pos.xz), pos.y) / PI) + 0.4;\n    float brightness = length(pos);\n    vec3 baseColor = getRGB(hue, saturation, brightness);\n    // blending.\n    baseColor *= diff;\n    // fadeout effect.\n    color = mix(baseColor, color, tanh(t * 0.02));\n  }\n  // it's all.\n  fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}