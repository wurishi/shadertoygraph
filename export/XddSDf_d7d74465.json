{"ver":"0.1","info":{"id":"XddSDf","date":"1461865813","viewed":199,"name":"Tweens","username":"allegrocm","description":"Bezier curve visualizer for finding animation tween equations.  Turns out 1D Bezier works great for this.","likes":3,"published":1,"flags":32,"usePreview":0,"tags":["beziercurve"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   // gColor = vec3(1.0);\n    //drawTweenCurve(sin(iTime * 0.5));\n    //float b = calcLine(vec2(0.0, 0.0), vec2(30.0, 50.0));\n    //drawCircle(vec2(100.0, 100.0), 10.0, gRed);\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    fragColor = texture(iChannel0, uv);\n    \n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XsXGRn","filepath":"/media/a/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg","previewfilepath":"/media/ap/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\nvec3 gColor;\nvec3 gRed = vec3(1.0, 0.0, 0.0);\nvec3 gBlack = vec3(0.0);\nvec3 gGrey = vec3(0.4);\n\nfloat gBorder = 20.0;\nfloat calcLine(vec2 p1, vec2 p2)\n{\n \tvec2 p = gl_FragCoord.xy;   \n    vec2 toP = p - p1;\n    vec2 dir = p2-p1;\n    float len = length(dir);\n    dir = normalize(dir);\n    float dawt = dot(toP, dir);\n    dawt = clamp(dawt, 0.0, len);\t//clamp so our near-point is on the segment\n\tvec2 nearPos = p1 + dir * dawt;\n    float dist = length(p-nearPos);\n    return 1.0-clamp(dist / 2.0, 0.0, 1.0);\n\n}\n\nvoid drawLine(vec2 p1, vec2 p2, vec3 color)\n{\n    float b = calcLine(p1, p2);\n    gColor = mix(gColor, color, b);\n}\n\nvec2 bezierPoint(float t, vec2 p1, vec2 handle1, vec2 p2, vec2 handle2)\n{\n    //basis functions\n    float y0 = pow(1.0-t, 3.0);\n    float y1 = 3.0 * (1.0-t) * (1.0-t) * t;\n    float y2 = 3.0 * (1.0-t) * t * t;\n    float y3 = t * t * t;\n    \n  \treturn p1 * y0 + (p1+handle1) * y1 + (p2 + handle2) * y2 + p2 * y3; \n    \n    \n}\n\nvoid drawCircle(vec2 pos, float radius, vec3 color);\n\nfloat bezier1D(float t, float a, float b);\n\nvoid bezierCurve(vec2 p1, vec2 handle1, vec2 p2, vec2 handle2, vec3 color)\n{\n    float h = p2.y-p1.y;\n    float a = (handle1.x)/(p2.x-p1.x);\n    float b = (handle2.x+p2.x-p1.x)/(p2.x-p1.x);\n    drawLine(vec2(p1.x+a*(p2.x-p1.x), 0.0), vec2(p1.x+a*(p2.x-p1.x), 200.0), gGrey);\n       drawLine(vec2(p1.x+b*(p2.x-p1.x), 0.0), vec2(p1.x+b*(p2.x-p1.x), 200.0), gRed);\n    float d = 0.0;\n    const int rez = 80;\n    for(int i = 0; i < rez; i++)\n    {\n       \tfloat t1 = float(i) / float(rez);\n        float t2 = float(i+1) / float(rez);\n        vec2 pos1 = bezierPoint(t1, p1, handle1, p2, handle2);  \n        pos1.y = pos1.x;\n        pos1.x = mix(p1.x, p2.x, t1);\n      \t//pos1.y = mix(p1.y, p2.y, bezier1D(t1, a, b));\n        vec2 pos2 = bezierPoint(t2, p1, handle1, p2, handle2); \n        pos2.y = pos2.x;\n        pos2.x = mix(p1.x, p2.x, t2);\n      \t//pos2.y = mix(p1.y, p2.y, bezier1D(t2, a, b));\n        d = max(d, calcLine(pos1, pos2));\n        float b1d = bezier1D(t2*0.5+t1*0.5, a, b);\n        float d1 = mix(p1.y, p2.y, b1d);\n //       float derivative = (pos2.y-pos1.y)/ (pos2.x-pos1.x);\n        drawCircle(vec2(pos1.x * 0.5 + pos2.x * 0.5, d1), 2.0, gRed);\n        if(b1d > 1.0)\n             drawCircle(vec2(pos1.x * 0.5 + pos2.x * 0.5, d1), 3.0, vec3(0.5, 0.5, 1.0));\n            \n    }\n    gColor = mix(gColor, color, d);\n}\n\nvoid drawCircle(vec2 pos, float radius, vec3 color)\n{\n\tfloat dist = length(gl_FragCoord.xy - pos);\n    float b = 1.0-clamp((dist-radius) / 2.0, 0.0, 1.0);\n    gColor = mix(gColor, color, b);\n}\n\nfloat bezier1D(float t, float a, float b)\n{\n\n    float y1 = 3.0 * (1.0-t) * (1.0-t) * t;\n    float y2 = 3.0 * (1.0-t) * t * t;\n    float y3 = t * t * t;\n    \n  \tfloat v = a * y1 + b * y2 + y3 * 1.0; \n   // v = t;\n    v = v * 2.0 - 1.0;\n    float powa = 0.75 + 0.25 * sin(iTime * 0.5);\n    v = v / abs(v) * pow(abs(v), powa);\n //   if(v < 0.0)\n   //     v = -sqrt(-v);\n   \t//else v= sqrt(v);\n   \tv = v * 0.5 + 0.5;\n   \n    return v;\n        \n}\n\nvoid drawTweenCurve(float s)\n{\n    float border = 45.0;\n    vec4 bounds = vec4(border, border, iResolution.xy - vec2(border));\n    bounds.z = bounds.w;\n\tvec2 mid = bounds.xy * 0.5 + bounds.zw * 0.5;\n    \n    mid.x += bounds.z * 0.4 * s;\n    mid.y -= bounds.w * 0.4 * s;\n    mid.y = 0.0;\n    vec2 handleDir = vec2(1.0, 0.0);\n    //handleDir = normalize(handleDir);\n    vec2 midPrevHandle = handleDir * -150.0;\n    vec2 midNextHandle = midPrevHandle * -1.0;\n    vec2 p1 = bounds.xy;\n    vec2 handle1 = vec2(0.0, 0.0);\n    vec2 p2 = bounds.zw;\n    vec2 handle2 = vec2(-0.0, -0.0);\n\tfloat a = 0.25 + 0.25 * s;\n    float b = 1.0;\n    \n    a = 0.0;\n    b = 1.0-a;\n    handle1.x = a * (bounds.z - bounds.x);\n    handle2.x = bounds.x + b * (bounds.z - bounds.x) - p2.x;\n    bezierCurve(p1, handle1, p2, handle2, gBlack);\n   // bezierCurve(mid, midNextHandle, p2, handle2, gRed);\n//\tdrawLine(vec2(handle1.x, 0.0), vec2(handle1.x, iResolution.y), gGrey);\n  //  drawLine(vec2(handle2.x, 0.0), vec2(handle2.x, iResolution.y), gGrey);\n    drawLine(vec2(p1.x+handle1.x, bounds.w), p1+handle1, gGrey);\n    drawLine(vec2(p2.x+handle2.x, bounds.y), p2+handle2, vec3(0.4, 0.4, 0.7));\n    drawLine(mid, mid+midPrevHandle, gGrey);\n    drawLine(mid, mid+midNextHandle, gGrey);\n    drawCircle(mid, 4.0, gRed);\n    drawCircle(p1, 4.0, gBlack);\n    drawCircle(p2, 4.0, gBlack);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    gColor = vec3(1.0);\n    drawTweenCurve(sin(iTime * 0.5));\n    //float b = calcLine(vec2(0.0, 0.0), vec2(30.0, 50.0));\n    //drawCircle(vec2(100.0, 100.0), 10.0, gRed);\n    fragColor = vec4(gColor, 1.0);\n    \n}","name":"Buf A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n        \nvec2 uv = fragCoord.xy / iResolution.xy;\n    vec4 bufB = texture(iChannel1, uv);\n    vec4 bufA = texture(iChannel0, uv);\n    fragColor = mix(bufB, bufA * 1.0, 0.5);\n}","name":"Buf B","description":"","type":"buffer"}]}