{"ver":"0.1","info":{"id":"llffW7","date":"1512087031","viewed":272,"name":"Infinite Template","username":"zackpudil","description":"Experiments with surface bumps. USE MOUSE to look around.","likes":11,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","surfacebump"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGRn","filepath":"/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","previewfilepath":"/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// 3D Geom\n\nvec2 rot(vec2 p, float a) {\n    float s = sin(a);\n    float c = cos(a);\n    \n    return mat2(c, s, -s, c)*p;\n}\n\nfloat de(vec3 p) {\n    vec3 q = p;\n    p.z = mod(p.z + 1.0, 2.0) - 1.0;\n    p.x = abs(p.x) - 1.6;\n    p.xy = rot(p.xy, -0.4*smoothstep(1.0, 2.0, p.y));\n    \n    float s = length(p.xz) - 1.0 + 0.5*smoothstep(-1.0, 1.0, sin(3.0*q.y));\n    float w = min(q.y + 1.0, min(q.x + 2.0, -q.x + 2.0));\n\treturn min(s, w);\n}\n\nfloat trace(vec3 ro, vec3 rd, float mx) {\n\tfloat t = 0.0;\n\tfor(int i = 0; i < 200; i++) {\n\t\tfloat d = de(ro + rd*t);\n\t\tif(d < 0.001 || t >= mx) break;\n\t\tt += d*0.71;\n\t}\n\treturn t;\n}\n\nvec3 normal(vec3 p) {\n\tvec2 h = vec2(0.001, 0.0);\n\tvec3 n = vec3(\n\t\tde(p + h.xyy) - de(p - h.xyy),\n\t\tde(p + h.yxy) - de(p - h.yxy),\n\t\tde(p + h.yyx) - de(p - h.yyx)\n\t);\n\treturn normalize(n);\n}\n\nfloat ao(vec3 p, vec3 n) {\n\tfloat o = 0.0, s = 0.005;\n\tfloat w = 1.0;\n\t\n\tfor(int i = 0; i < 15; i++) {\n\t\tfloat d = de(p + n*s);\n\t\to += (s - d)*w;\n\t\tw *= 0.98;\n\t\ts += s/float(i + 1);\n\t}\n\t\n\treturn 1.0 - clamp(o, 0.0, 1.0);\n}\n\n// Material\n\nvec3 mateball(vec2 p) {\n    p = mod(p + 1.0, 2.0) - 1.0;\n    \n    for(int i = 0; i < 7; i++) {\n        p = abs(p)/clamp(dot(p, p), 0.3, 1.0) - vec2(0.2);\n    }\n    \n    return texture(iChannel0, p).rgb;\n}\n\nvec3 matefloor(vec2 p) {\n    p = mod(p + 1.0, 2.0) - 1.0;\n    \n    for(int i = 0; i < 3; i++) {\n        p = abs(p)/clamp(dot(p, p), 0.4, 1.0) - vec2(0.6);\n    }\n    \n    return texture(iChannel1, p).rgb;\n}\n\n#define MATECUBE(p, n, mate) vec3 m = pow(abs(n), vec3(10.0));\tvec3 x = mate(p.yz);vec3 y = mate(p.xz);vec3 z = mate(p.xy);return (m.x*x + m.y*y + m.z*z)/(m.x+m.y+m.z);\n\nvec3 matecubeball(vec3 p, vec3 n) {\n    MATECUBE(p, n, mateball);\n}\n\nvec3 matecubefloor(vec3 p, vec3 n) {\n    MATECUBE(p, n, matefloor);\n}\n\n// Surface\n\nfloat surfball(vec2 p) {\n     p = mod(p + 1.0, 2.0) - 1.0;\n    \n    for(int i = 0; i < 4; i++) {\n        p = abs(p)/clamp(dot(p, p), 0.3, 1.0) - vec2(0.7);\n    }\n    \n    return smoothstep(0.3, 1.0, abs(p.y));\n}\n\nfloat surffloor(vec2 p) {\n   return -dot(texture(iChannel1, p).rgb, vec3(0.72, 0.21, 0.07));\n}\n\n#define SURFCUBE(p,n,sb) vec3 m = pow(abs(n), vec3(10.0));float x = sb(p.yz);float y = sb(p.xz);float z = sb(p.xy);return (m.x*x + m.y*y + m.z*z)/(m.x + m.y + m.z)\n\nfloat sbball(vec3 p, vec3 n) {\n    SURFCUBE(p, n, surfball);\n}\n\nfloat sbfloor(vec3 p, vec3 n) {\n    SURFCUBE(p, n, surffloor);\n}\n\n#define BUMP(p, n, d, e, m) vec2 h = vec2(e, 0.0); vec3 g = vec3(d(p + h.xyy, n) - d(p - h.xyy, n),d(p + h.yxy, n) - d(p - h.yxy, n),d(p + h.yyx, n) - d(p - h.yyx, n)); g -= n*dot(n, g);return normalize(n + m*g)\n\nvec3 bumpball(vec3 p, vec3 n) {\n    BUMP(p, n, sbball, 0.008, 1.4);\n}\n\nvec3 bumpfloor(vec3 p, vec3 n) {\n    BUMP(p, n, sbfloor, 0.01, 4.0);\n}\n\n// Lighting\n\nvec3 light() {\n    return vec3(0.0, 0.0, 0.3*iTime + 2.0);\n}\n\nvec3 render(vec3 ro, vec3 rd) {\n\tvec3 col = vec3(0.25);\n\tfloat t = trace(ro, rd, 50.0);\n\tif(t < 50.0) {\n        col = vec3(0);\n        \n\t\tvec3 pos = ro + rd*t;\n\t\tvec3 nor = normal(pos);\n        \n        vec3 lig = normalize(light() - pos);\n        float dis = length(lig) - 0.2;\n        \n        if(pos.y > -0.99) nor = bumpball(pos, nor);\n        else nor = bumpfloor(pos, nor);\n        \n\t\tvec3 ref = reflect(rd, nor);\n\t\t\n        float att = 1.0/(1.0 + 1.4*dis*dis);\n\t\tfloat occ = ao(pos, nor);\n\t\tfloat dom = 0.7 + 0.3*smoothstep(0.0, 1.4, trace(pos + nor*0.001, ref, 5.0));\n\t\t\n\t\tcol += 0.2*occ;\n\t\tcol += clamp(dot(lig, nor), 0.0, 1.0)*occ*dom*att;\n        col += 10.0*pow(clamp(dot(lig, ref), 0.0, 1.0), 9.0)*occ*dom*att;\n        \n        if(pos.y > -0.99) {\n        \tcol *= matecubeball(pos, nor);\n        } else {\n            col *= matecubefloor(pos, nor);\n        }\n\t}\n    \n    col = mix(col, vec3(0.0), 1.0 - exp(-0.5*t));\n\t\n\treturn col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n    vec2 mo = (-iResolution.xy + 4.0*iMouse.xy)/iResolution.y;\n\t\n\tvec3 ro = vec3(0, -0.7, 0.3*iTime);\n\tvec3 ww = normalize(vec3(mo, 0.3*iTime + 3.0)-ro);\n\tvec3 uu = normalize(cross(vec3(0, 1, 0), ww));\n\tvec3 vv = normalize(cross(ww, uu));\n\tvec3 rd = normalize(p.x*uu + p.y*vv + 1.4*ww);\n\t\n\tvec3 col = render(ro, rd);\n\t\n\tcol = 1.0 - exp(-0.2*col);\n\tcol = pow(abs(col), vec3(1.0/2.2));\n    \n\tfragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}