{"ver":"0.1","info":{"id":"4fBcWG","date":"1723055847","viewed":54,"name":"Simple PoincarÃ© Disk","username":"inverse_transpose","description":"My first attempt at rendering a Poincare disk, simply rendering circles.","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["poincaredisk"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n * A lot of this code was borrowed from Shane. I wanted to study how\n * to do this and found that his shader was an excellent starting\n * point for this. Being slightly impatient and wanting to create\n * something before I completely understand the derivations, I decided\n * to just copy the relevant parts and try doing something simple in\n * terms of the pattern produced.\n *\n * Shane's shader for reference: https://www.shadertoy.com/view/WlBczG\n *\n * Despite how simple this is, I think it looks rather pretty.\n *\n *\n * Thank you so much to Fabrice Neyret who corrected a lot of parts and\n * showed how to do certain things much more efficiently and concisely.\n */\n\nfloat N\t= 7.,\n      Q = 3.,\n     PI\t= 3.14159265,\n    TAU = 6.28318531,\n    count;\n     \nfloat circle(vec2 p, float w)\n{\n    float d = length(p),\n         dd = fwidth(d);\n    return smoothstep( dd, -dd, abs(d-1.) - .5*w );\n}\n\n#define rot(t) mat2( cos( t + 1.571*vec4(0,-1,1,0)))\n\nvec2 transform(vec2 p, vec3 circ)\n{\n    float  ia = ( floor( N* atan(p.x, p.y) / TAU ) + .5 ) / N, r;\n    vec2 vert = vec2(0, circ.x) * rot( ia*TAU ),\n           pc = p - vert;\n    r = circ.y*circ.y / dot(pc, pc);   \n    if( r > 1. )\n        p = pc*r + vert,\n        count++;\n    return p;\n}\n\nvoid mainImage(out vec4 O, vec2 u)\n{\n    vec2 R = iResolution.xy,\n         U = 1.1* ( 2.*u - R) / R.y,\n         p = U,\n         \n    m = ( 2.*iMouse.xy - R ) / R.y , A = abs(m);\n    if( length(m) < 1e-3 ) m += 1e-3; \n    if( max(A.x,A.y) > .98*.7071 ) m *= .98;\n    float k = 1. / dot(m, m);\n    vec2 invCtr = k * m, \n         q = p - invCtr;\n    p = q * (k-1.) / dot(q,q) + invCtr;\n    p.x = -p.x; \n           \n    p *= rot(iTime/16.);\n\n    float a = sin(PI/N), b = cos(PI/Q),\n\t     d2 = cos(PI/N + PI/Q) / a,\n\t     r2 = 1./(b*b/a/a - 1.);\n\tvec3 domInfo = sqrt(max(vec3(1. + r2, r2, d2*d2*r2), 0.)); \n    \n    for (int i; i<16; i++)\n        p = transform(p, domInfo);\n\n    float l = length(p);\n    if ( length(p) > 1. ) l = 1./l;\n       \n    l = max(.5, smoothstep(1., -1., ( l - .26475 ) / fwidth(l) ));\n\n    if (length(U) > 1.) l = mix(l, 1., .925);\n\n    l = mix(l, .95, circle(U, .08 ));\n    l = mix(l, 1., circle(U, .04 ));\n    l = mix(l, .5, circle(U, .01 ));\n    O = vec4(l);\n}\n","name":"Image","description":"","type":"image"}]}